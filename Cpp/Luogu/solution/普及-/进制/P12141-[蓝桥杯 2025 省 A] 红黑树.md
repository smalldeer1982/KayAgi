# [蓝桥杯 2025 省 A] 红黑树

## 题目描述

小蓝最近学习了红黑树，红黑树是一种特殊的二叉树，树上的结点有两种类型：红色结点和黑色结点。  

小蓝在脑海中构造出一棵红黑树，构造方式如下：  

1. 根结点是一个红色结点；  
2. 如果当前结点 $\rm curNode$ 是红色结点，那么左子结点 $\rm curNode.left$ 是红色结点，右子结点 $\rm curNode.right$ 是黑色结点；  
3. 如果当前结点 $\rm curNode$ 是黑色结点，那么左子结点 $\rm curNode.left$ 是黑色结点，右子结点 $\rm curNode.right$ 是红色结点；  

此二叉树前几层的形态如下图所示：  

![](https://cdn.luogu.com.cn/upload/image_hosting/rc6o7xe8.png)

小蓝会从树上随机挑选结点，请你帮忙判断他选出的是红色结点还是黑色结点。  

## 说明/提示

### 样例说明
- 第一行第一个结点为根结点，红色；
- 第二行第二个结点为黑色结点。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq m \leq 5$，$1 \leq n_i \leq 5$；
- 对于 $40\%$ 的评测用例，$1 \leq m \leq 10$，$1 \leq n_i \leq 5$；
- 对于 $60\%$ 的评测用例，$1 \leq m \leq 5$，$1 \leq n_i \leq 10$；
- 对于 $80\%$ 的评测用例，$1 \leq m \leq 10$，$1 \leq n_i \leq 15$；
- 对于所有评测用例，$1 \leq m \leq 10$，$1 \leq n_i \leq 30$，$1 \leq k_i \leq 2^{n_i-1}$。

## 样例 #1

### 输入

```
2
1 1
2 2```

### 输出

```
RED
BLACK```

# 题解

## 作者：ControlVector (赞：12)

容易证明以下两个性质：

1. 每行的前半部分和后半部分对应位颜色相反。
2. 每行的前半部分就是上一行，故答案只与 $k$ 有关，与 $n$ 无关。

每行从 $0$ 开始编号，编号  $x=k-1$

由 **性质 2**，答案与 $n$ 无关，不妨设节点在可能的最浅行，那么节点一定在该行的后半部分，不然可以更浅。

考虑 $x$ 的 **二进制表示**，例如 $x=(101001)_{2}$，则由 **性质 1**，该节点颜色与 $x_1=(001001)_{2}=(1001)_{2}$ 对应的节点颜色相反，$x_1$ 节点又与 $x_2=(0001)_{}=(1)_{2}$ 对应的节点颜色相反，$x_2$ 节点又与 $x_3=(0)_{2}=0$ 对应的节点颜色相反，而 $0$ 是根节点，颜色为 **红色**，那么 $x$ 的颜色为 **黑色**。

所以，颜色只和 $x$ 二进制表示中 $1$ 的数量的奇偶性相关，可使用内置函数 ```__builtin_parity``` 计算。

```cpp
#include <iostream>
using namespace std;

int main() {
    int m, k;
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> k >> k;
        cout << (__builtin_parity(k-1) ? "BLACK\n" : "RED\n");
    }
}
```

---

## 作者：崔泽禹 (赞：10)

# [P12141 [蓝桥杯 2025 省 A] 红黑树](https://www.luogu.com.cn/problem/P12141)题解

![P12141](https://cdn.luogu.com.cn/upload/image_hosting/qd23cef2.png)

不难发现：

- 一个结点的**右子结点**，列数是当前结点列数的**两倍（偶数）**。
- 一个结点的**左子结点**，列数是当前结点列数的**两倍减一（奇数）**。

可以使用递归查询（当然也可以暴力将这 30 行中的每个结点都使用 `map` 进行标记）。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool dfs(int x, int y) {
    if (x == 1) {
        return true;           // 根结点为红色结点
    }
    if (y % 2 != 0) {          
        int ty = (y + 1) / 2;  // 奇数->左枝（左子结点）
        if (dfs(x - 1, ty)) {  // 递归判断父结点颜色
            return true;       // 父结点为红色，左子结点为红色
        }
        return false;          // 父结点为黑色，左子结点为黑色
    } else {                    
        int ty = y / 2;        // 偶数->右枝（右子结点）
        if (dfs(x - 1, ty)) {  // 递归判断父结点颜色
            return false;      // 父结点为红色，右子结点为黑色
        }
        return true;           // 父结点为黑色，右子结点为红色
    }
}
int main() {
    int m;
    cin >> m;
    while (m--) {
        int n, k;
        cin >> n >> k;
        cout << (dfs(n, k) ? "RED" : "BLACK") << endl;
    }
    return 0; 
}
```

---

## 作者：overdoze (赞：4)

这道题我不会用进制和位运算，但是我会递归。

首先，暴力枚举红黑树，得到下表：
```
R
RB
RBBR
RBBRBRRB
RBBRBRRBBRRBRBBR
```
其中，`R` 表示红色，`B` 表示黑色。

我们可以给它们对半分（除了第一层），得到下表：
```
R
R B
RB BR
RBBR BRRB
RBBRBRRB BRRBRBBR
```
发现了没有？

第 $k$ 层下标 $\le 2^{k-2}$ 的元素是 $k-1$ 层当前下标对应元素的颜色。

而第 $k$ 层下标 $> 2^{k-2}$ 的元素是第 $k-1$ 层当前节点 $-2^{k-2}$ 下标对应元素的颜色取反（即红变成黑，黑变成红）。

我们就可以使用递归解答。

[AC 记录](https://www.luogu.com.cn/record/213485265)

代码就别抄我了。

---

## 作者：Merlin_Meow (赞：2)

## Analysis

注意到在一棵红黑树上，根节点总是和其左儿子颜色相同，右儿子颜色相反。

于是我们可以通过从根节点到一个子节点的路径（即向右走的次数）来判断该子结点的颜色。

我们不妨用 $0$ 表示向左走，$1$ 表示向右走，这样就可以使用一个二进制数来将完整的路径表示出来，容易发现这个数就是 $k-1$。

于是我们只需要统计 $k-1$ 的二进制表示中 $1$ 的个数，偶数则该节点为红色，奇数则该节点为黑色。

实现上，可以使用 `__builtin_popcount()` 快速统计，或者手动按位分解。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define int long long

int m;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> m;
    while (m--)
    {
        int n, k;
        cin >> n >> k;
        if (__builtin_popcountll(k - 1) % 2 == 0)
            cout << "RED" << endl;
        else
            cout << "BLACK" << endl;
    }
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 前言
这题其实非常简单，主要考察递归，个人认为评个橙就差不多了。
# 思路
分析题意，我们可以知道这题要我们查找这棵树上的某一个节点，那到底怎么查呢？肯定是一层一层的查。具体的，我们每次可以将查找的范围一分为二，类似于二分查找，到我们要查找的那一层就只有一个节点了，那时候直接返回这个节点的颜色即可。
# 具体步骤
既然是递归，那三要素可不能少。
## 1.参数
设函数 $\operatorname{dfs}(l,r,col)$ 的作用是当前子树根节点颜色为 $col$，要查找叶子节点范围为 $[l,r]$ 时查找给定节点。
## 2.边界
当 $l=r$ 时，说明此时只有一个节点，也就是我们要查找的节点，返回此时的 $col$ 即可。
## 3.递归形式
定义 $mid$ 为分割区间 $[l,r]$ 的分界线，如果要查找的位置比 $mid$ 大，那么就递归右子树，反之递归左子树。 $\\$ 
现在还有一个问题，那就是如何快速确定节点的颜色，这个其实找规律就行了。设根节点颜色为红色代表 $0$，为黑色代表 $1$。接着，如果是递归左子树，则设 $p=0$，反之设 $p=1$。而子树的根节点颜色只需要将这两个值异或一下就行了。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,k;
int dfs(int l,int r,int col)
{
	if(l==r) return col;
	int mid=l+r>>1,p;
	if(k>mid) p=1;
		 else p=0;
	if(p) return dfs(mid+1,r,col^p);
	 else return dfs(l,mid,col^p);
}
int main()
{
	cin>>t;
	while(t--)
	 {
	 	cin>>n>>k;
	 	cout<<(dfs(1,1<<n-1,0)?"BLACK\n":"RED\n");
	 }
	return 0;
}
```

---


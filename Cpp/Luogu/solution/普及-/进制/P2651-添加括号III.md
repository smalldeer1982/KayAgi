# 添加括号III

## 题目描述

现在给出一个表达式，形如 $a_{1}/a_{2}/a_{3}/.../a_{n}$。

如果直接计算，就是一个个除过去，比如 $1/2/1/4 = 1/8$。

然而小$\text{A}$看到一个分数感觉很不舒服，希望通过添加一些括号使其变成一个整数。一种可行的办法是 $(1/2)/(1/4)=2$ 。

现在给出这个表达式，求问是否可以通过添加一些括号改变运算顺序使其成为一个整数。

## 说明/提示

- 对于 $40\%$ 的数据，$n \le 16$。
- 对于 $70\%$ 的数据，$n \le 100$。
- 对于 $100\%$ 的数据， $2 \le n \le 10000$，$1 \le t \le 100$，$1 \le a_{i}\le 2^{31}-1$。

## 样例 #1

### 输入

```
2
4
1 2 1 4
5
6 5 7 9 12```

### 输出

```
Yes
No```

# 题解

## 作者：kkksc03 (赞：282)

a1肯定是分子，a2肯定是分母，那么尽可能多的是a3以后的变为分子，怎么办呢？

很简单

a1/(a2/a3/a4/...)=a1a3a4.../a2

所以我们只要确认a1a3a4.../a2是否是整数。

如果你非要写高精我也不拦你。

但是如果进行约分，知道a2能被约分成1，那么就是整数。

每次将a2=a2/gcd(a2,ai),i=(1,3,4,5...)

即可约分


---

## 作者：Porsche (赞：48)

首先这道题并没有用到高精，其次我看到其他C++题解都没有人用到__gcd函数，所以我就来发一篇题解

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],t,n;
int main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
	{
        cin>>n>>a[1]>>a[2];
        a[2]/=__gcd(a[1],a[2]);
        for(int i=3;i<=n;i++)
		{
            cin>>a[i];
            a[2]/=__gcd(a[2],a[i]);
        }
        if(a[2]==1)
            cout<<"Yes"<<endl;
        else
            cout<<"No"<<endl;
    }
	return 0;
}
```
希望大家喜欢

---

## 作者：Excim (赞：25)

有点啰嗦了。。。。。。

//luogu p2651 添加括号Ⅲ

首先写成a1/a2/a3/.../an的形式

（题目中的数据已经保证了ai是正整数）

分析：通过加括号的方式使得最终分数的分子所含的所有因子包含分母上的所有因子，也就是通过约分也是是最终的分母变为1

a2一定在最终的分母上，为什么这么说呢？

对于a1/a2/a3/.../an，考虑加括号的方式：

我们可以很容易地知道，a1一定要作为分母出现，因为没有任何一个数在a1之前。所以我们就可以看作是a1去除一个数，这个数是由a2/a3/.../an通过加括号的方式算出的

现在我们要做的，就是使（a2/a3/.../an）中所含的因子数尽量少，此时已经与a1无关了。

可以证明，（a2/a3/.../an）的时候，因子是最少的：

对于（a2/a3/.../an）来说，a2作为分子，不管后面的数字如何添加括号，对于a2，只有乘这个数或是除以这个数（假设中间结果不约分）。a2每乘一个数b，因子加上(b包含的所有因子)，a2除以所有b，因子减去（b包含的所有因子），a2中不含的因子最终将加到a1上。

可以看出，（a2/a3/.../an）中间不加括号，进行连除时，a2可以在不增加新的因子情况下，因子最少，所以我们要加的括号就是这样

a1/（a2/a3/.../an）

然后如何判断能否使最终结果变为整数呢？只需要判断（a3,a4...an）这些数中是否含有a2的全部因子，具体做法：从a1扫到an,每个数（当然除了a2）分别与a2约去他们的最大公因数，an约分结束，a2能变为1，那就是能使最终结果变为整数，反之不能。

说了这么多，就不粘代码了，练练gcd吧


---

## 作者：BlueArc (赞：14)

一道数论题......

因为可改变计算顺序，表达式的值一定可以写成一些ai的乘积除以剩下数的乘积，值记为X；

易得a2必须放在分母上；

X=a1/(a2/a3.../ai)=a1a3...ai/a2;

接下来判断X是否为整数就行了。可以每次约掉ai和a2的最大公约数，只有当约完后a2=1时，X为整数。

程序如下：

```cpp
#include"cstdio"
#include"iostream"
using namespace std;
int n;
int gcd(int x,int y)
{
 return y==0?x:gcd(y,x%y);   
```
}//欧几里德算法求最大公约数
int judge(int\* x)//约分并判断，参数是数组首地址

```cpp
{
 x[2]/=gcd(x[1],x[2]);
 for(int i=3;i<=n;i++) x[2]/=gcd(x[i],x[2]);
 return x[2]==1;   
}
int main()
{
 int T;
 cin>>T;
 while(T--)
 {
  cin>>n;         
  int a[n+2]; 
  for(int i=1;i<=n;i++)
  cin>>a[i];
  if(judge(a)) cout<<"Yes"<<endl;//成立Yes,否则No
  else cout<<"No"<<endl;       
 }  
 return 0;
}

```

---

## 作者：Plozia (赞：10)

[博客阅读效果更佳-csdn](https://blog.csdn.net/BWzhuzehao/article/details/106353870)

如果有部分公式或文字较混乱，请到本人的 Luogu 博客或者上文连接查看。

~~或许是我太蒟了，想了好久的解法。~~

此题很明确，我们需要加上若干括号使得最后结果为整数。

明显的，我们在日常的数学计算中，可以发现：设任意分数 $\dfrac{x}{y}$ （ $x$  ,  $y$ 均为正整数），**如果 $\gcd(x,y)=y$ ，那么 $\dfrac{x}{y}=x$ ，也就是 $\dfrac{x}{y}$ 为整数，即 $x$ , $y$ 可以约分。**

这句话是解题的关键。理解这句话之后，我们只需要了解哪些数是分子，哪些数是分母即可判断。

分析可得， $a_1$ 只能是分子， $a_2$ 只能是分母，剩余的数可以是分子，也可以是分母。（证明见文末）

为了尽可能使 $a_2$ 被约分，最优解法就是：将剩余的数和 $a_1$ 全部处于分子处，分母处只留 $a_2$ 。

这样，**我们只需要判断约分之后 $a_2$是否为1。**

如何约分呢？**将分子的数不断与 $a_2$ 求最大公约数（设为 $z$ ），那么 $a_2$ 与这个数就能约去 $z$ ,令 $a_2 \gets \dfrac{a_2}{z}$，就可以实现最大化约分。**

思路分析完毕。代码实现如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+10;
typedef long long LL;
int t,n;
LL a[MAXN];
LL gcd(LL a,LL b)
{
	return b==0?a:gcd(b,a%b);
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
		for(int i=1;i<=n;i++)
		{
			if(i==2) continue;//特别注意过滤a2!!!
			a[2]=a[2]/gcd(a[2],a[i]);//约分
		}
		if(a[2]==1) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

关于前文的证明（有点粗略，请见谅）：

首先，设存在 长度为 $n$ 的序列 $b_1,b_2,...,b_n$ ，令 $r=b_1/b_2/b_3/.../b_n$ ，那么根据 $\dfrac{a}{\frac{b}{c}}=\dfrac{a \times c}{b}$ ，可以得到如下结论：

1. 如果 $n$ 是偶数，$r=\dfrac{b_1 \times b_3 \times ... \times b_{n-1}}{b_2 \times b_4 \times ... \times b_n}$。
2. 如果 $n$ 是奇数，$r=\dfrac{b_1 \times b_3 \times ... \times b_n}{b_2 \times b_4 \times ... \times b_{n-1}}$。

所以对于这个序列中的 $b_i$ ($1 \leq i \leq n$)，如果 $i$ 是奇数， $b_i$ 处于分子处，如果 $i$ 是偶数， $b_i$ 处于分母处。

对于这道题中的 $a$ 序列，我们虽然可以通过添加括号，使得 $a_i$ ($3 \leq i \leq n$)的位置改变，位于分母还是分子具有不确定性，但是无论如何， $a_1$ 永远是第 1 位， $a_2$ 永远是第 2 位，那么 $a_1$ 只能处于分子处， $a_2$ 只能处于分母处。

---

## 作者：ljc20020730 (赞：8)

数论……

从题意可知a[1]一定为分子，可以证明通过括号让后面的数字为分子；

故只要求a[2]与其他数的最大公约数为gcd1.

若a[2]div gcd1 最后为1，则输出Yes否则输出No；

对于只有一个数的数据特判输出Yes；

```cpp
var nn,i,gcd1,n,t:longint;
    a:array[1..10000]of longint;
function gcd(a,b:longint):longint;
begin
 if b=0 then gcd:=a
 else gcd:=gcd(b,a mod b);
end;
begin
 readln(nn);
 for t:=1 to nn do begin
  readln(n);
  for i:=1 to n do read(a[i]);
  if n=1 then begin writeln('Yes'); continue; end;//特判
  a[2]:=a[2] div gcd(a[1],a[2]);
  for i:=3 to n do
   a[2]:=a[2] div gcd(a[2],a[i]);
  if a[2]=1 then writeln('Yes')
  else writeln('No');
 end;
end.
```

---

## 作者：SUNCHAOYI (赞：6)

**主要学会写gcd函数就行了**


**辗转相除法！**

**然后判断一下能否整除就行了**

**纯数论**
```
#include<iostream>
using namespace std;
int gcd(int x,int y);
int main()
{
	int a[10001],t,n;
    cin>>t;
    while(t--)
    { 
        cin>>n>>a[0]>>a[1];
        a[1]/=gcd(a[0],a[1]);
        for(int i=2;i<n;i++)
        {
            cin>>a[i];
            a[1]/=gcd(a[1],a[i]);
        }
        if(a[1]==1)cout<<"Yes"<<endl;      
        else cout<<"No"<<endl;  
    }
    return 0;
}
int gcd(int x,int y)
{
 return y==0?x:gcd(y,x%y);
}
```


---

## 作者：hswfwkj_ (赞：5)

首先给大家普及一个函数：

`__gcd(a,b)`

这个函数的作用是求 $a$ 和 $b$ 的最大公约数。

然后让我们分析一下题目，既然想要让 $n$ 个数除起来是整数，那么分母自然是越小越好，那么，我们就可以把每组数据都写成如下形式：

$a_1/(a_2/a_3/a_4/\cdot\cdot\cdot\cdot\cdot\cdot)=\frac{a_1a_3a_4\cdot\cdot\cdot\cdot\cdot\cdot}{a_2}$

这样只需要从 $a_1$ 开始，依次除以每个数与 $a_2$ 的最大公约数，等到 $a_2$ 等于一的时候，就能确定这是个整数，否则就不是整数。

贴上代码：
```
#include<bits/stdc++.h>
using namespace std;
long long T,i,n,j,a[10001];
int main(){	
	scanf("%lld",&T);
	for(i=1;i<=T;i++){
		scanf("%lld",&n);
		for(j=1;j<=n;j++)
			scanf("%lld",&a[j]);
		for(j=1;j<=n;j++){
			if(j==2)//特判此时下标是二的时候
			continue;
			a[2]=a[2]/__gcd(a[2],a[j]);//依次除以这几个数的最大公约数
			if(a[2]==1){
				printf("Yes\n");
				break;
			}
		}
		if(j>n)
		printf("No\n");
	} 
    return 0;
}
```
写题解不易，如有不周，请多海涵

---

## 作者：LoveMind (赞：4)

【难度】

~~很难的一道题（显然蒟蒻）~~

【分析】

很显然的一点是

第一个一定是分子

第二个一定是分母

分子越大越好

那么就看一下a1\*a3\*a4\*……an能不能整除a2就好

代码还是比较好写滴！！！

【程序】

```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
const LL MAXN=1e7+10;
inline LL read()
{
    char c=getchar();
    LL flag=1,x=0;
    while(c<'0'||c>'9')    
    {if(c=='-')    flag=-1;c=getchar();}
    while(c>='0'&&c<='9')    
    x=x*10+c-48,
    c=getchar();
    return x*flag;
}
LL T;
LL a[MAXN];
LL gcd(LL a,LL b)
{
    return b==0?a:gcd(b,a%b);
}
int main()
{
    T=read();
    while(T--)
    {
        a[2]=1;
        LL n=read();
        for(LL i=1;i<=n;i++)    
            a[i]=read();
        int mu=a[2];
        mu/=gcd(a[1],mu);
        for(LL i=3;i<=n;i++)
            mu/=gcd(mu,a[i]);
        if(mu==1)cout<<"Yes\n";
        else cout<<"No\n";
    }
    return 0;
}
```

---

## 作者：zhm411821 (赞：3)

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
int b[10100],m,n;
int gcd(int x,int y){
        if(!y)
           return x;
       return gcd(y,x%y);
}//欧几里得算法求最大公约数
int main(){
       cin>>n;
       for(int ij=1;ij<=n;ij++){
        cin>>m>>b[1]>>b[2];//因为b[1]一定为分子，b[2]一定为分母
        b[2]/=gcd(b[1],b[2]);//之后的数字则不确定，但可以考虑极端情况，即之后的所有数都为分子
        for(int i=3;i<=m;i++){//如果这种情况不成立，那么就不存在可行方法
            cin>>b[i];
            b[2]/=gcd(b[2],b[i]);
        }
        if(b[2]==1)//如果从分子中可以提取出b[2]所有的1以外的因子，则成立
            cout<<"Yes"<<endl;
        else
            cout<<"No"<<endl;
    }
    return 0;
} 
```

---

## 作者：_lfxxx_ (赞：1)

本蒟蒻的第二篇题解。
### 题意

添加括号使表达式的结果变成整数。
### 思路

想要使表达式的结果为整数，就相当于要使分母是分子的因数。
通过添加括号，我们可以使除了 $a_2$ 的其它数全部变成分子。
于是题目就相当于求 $\dfrac{a_1a_3a_4\cdots}{a_2}$ 是否为整数，我们可以让每个分子依次与 $a_2$ 约，如果 $a_2$ 等于$1$，则是整数，否则不是整数。
## 上代码：

```c++
#include<bits/stdc++.h>//万能头文件
using namespace std;
int s,t,i,j;
long long a,b;
long long gcd(long long x,long long y){
    int r;
    if(x<y)
        swap(x,y);
    while(y){
        r=x%y;
        x=y;
        y=r;
    }//欧几里得的辗转相除法
    return x;
}//本蒟蒻不知道有__gcd(a,b)函数，于是手编了一个。
int main(){
	cin>>s;//s表示一共有多少个表达式
	for(i=1;i<=s;i++){
   		cin>>t;
    	t-=2;//因为后面先读了两个数，所以-2
      	cin>>a>>b;
      	b/=gcd(a,b);//除以最大公因数
    	for(j=1;j<=t;j++){
        	cin>>a;
        	b/=gcd(a,b);
    	}
    	if(b==1)//b是1说明是整数
    		cout<<"Yes"<<endl;
      	else
          	cout<<"No"<<endl;
    }
    return 0;//结束
}
```
代码较长，还望大佬指教。

$2021.3.15$更新：删去了代码中没用的代码，使代码变短。

---

## 作者：why_always_china (赞：1)

打比赛的时候脑子一抽读入错误wa0……

当时也考虑过gcd,但是论证之后发现了一种不同的方法。

首先题意即为以a2为分母其他数乘积为分子是否能整除，这个前面的题解都解释过了。

具体操作起来就是将其他数相乘，同时边乘边模一下a2，这样可以避免高精。若结果为0,说明可以整除。为证明正确性,可以将每个数分解成k\*a2+r的形式（看做a2进制数），那么有用的部分只不过是r或者第一位。

附代码:

```delphi
program brack;
var t,p,i,n:longint;
    b,c:qword;
    a:array[1..10001] of qword;
begin
    read(t);
    for p:=1 to t do
    begin
        read(n);
        if n=1 then begin  writeln('Yes');continue;end;
        for i:=1 to n do read(a[i]);
        c:=a[1];b:=a[2];
        c:=c mod b;
        if c=0 then begin writeln('Yes');continue;end;
        for i:=3 to n do
        begin
            c:=(c *(a[i] mod b)) mod b;
            if c=0 then begin writeln('Yes');break;end;
        end;
        if c<>0 then writeln('No');
    end;
end.

```

---

## 作者：kczno1 (赞：1)


t<=100 n<=10000 a[i]<=maxlongint

由于a[2]必定为分母，

所以使其他都为分子为最优。

而且可以做到：在a2前，an后加个括号。


成为整数的条件:分子 mod 分母=0

即a[1]\*a[3..n] mod a[2]=0,

用辗转相除法,a[2]:=a[2]/a[2]与a[i]的最大公约数(i=1,3..n)。


时间接近O(t\*n)<=10^6

```delphi

var
 t,n,i,j:longint;
 a:array[1..10000] of longint;

function mgy(x,y:longint):longint;
begin
 if y=0 then exit(x);
 exit(mgy(y,x mod y));
end;

begin
 readln(t);
 for i:=1 to t do
 begin
  readln(n);
  for j:=1 to n do read(a[j]);
  a[2]:=a[2] div mgy(a[2],a[1]); j:=3;
  while (a[2]>1)and(j<=n) do
  begin
   a[2]:=a[2] div mgy(a[2],a[j]);
   inc(j);
  end;
  if a[2]=1 then writeln('Yes')
  else  writeln('No');
 end;
end.

```

---

## 作者：lingfunny (赞：0)

前言：哪里有高精，哪里就有 python。看过了，看过了，题解里没有python 。
## 简单描述解法
~~其实其它题解写的很清楚了，只是挂一下python代码~~

通过简单的观察就可以发现，$a_2$ 是无论如何也不可能作为分子的，而其余项都可以通过添加括号转化为分子。

你说怎么转化？

$$a_1/(a_2/a_3/a_4/.../a_n)$$
$$=a_1/\frac{a_2}{a_3a_4...a_n}$$
$$=\frac{a_1a_3a_4...a_n}{a_2}$$

所以接下来就很简单了，只需要看一下$a_1a_3a_4...a_n$能否整除$a_2$即可。
## Python代码 (python3)
```python
T = int(input())
for case in range(T):
    n = int(input())
    a = list( map(int, input().split()) )
    sum = 1
    for i in range(len(a)):
        if i!=1: sum *= a[i]
    if sum%a[1] == 0:print("Yes")
    else: print("No")
```


---

## 作者：SymphonyOfEuler (赞：0)

这道题是一道简单的数论题。

题目给您一个除法算式，让您求如果添加括号能不能让答案是整数。

我们可以推出，得到最大的一定是 $x1/(x2/x3.../xk)$，所以我们可以让$x2$当分母（因为要尽可能大），其他当分子。

所以式子就是：

$\frac{x1/(x3.../xk)}{x2}$

所以我们判断一下这些$x$/$x2$是否为整数就能判断出$Yes$和$No$了。

输入多组数据需要

```
int main() {
    int T;
    cin >> T;
    while (T--) {
```
然后进入循环先输入

```
int n;
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
        }
```

之后就是核心代码

我们把$p$设为$x[1]$，$q$为 $x[2]$，然后每次$ p=p*a[i] \mod \ q$ 最后判断$p$可不可以被$q$整除就行了

```
int p = a[1], q = a[2];
        for (int k = 3; k <= n; k++) {
            p = p * a[k] % q;
        }
        if (!p % q) cout<<"Yes\n";
        else cout<<"No\n";
```

注意：

- 这题数据挺大，你胡出的乱暴力算法肯定$SPFA$

$end$

---

## 作者：封禁用户 (赞：0)

这个题目有点难度 ~~这个人有点蒟蒻~~。

我们先举个栗子： $1 \div 2 \div 3 \div 4$

我们试着添加几次括号： $(1 \div 2)\div 3 \div 4,1 \div(2 \div(3 \div 4))$。

拆括号： $1 \div 2 \div 3 \div 4,1 \div 2 \times 3 \div 4$。

发现了什么？

**第二个数前面永远是除号！**

那样我们只要保证其它数前面是乘号，而乘起来刚好是第2个数的倍数，那不就搞定了。

想要做出来的方法也很简单，只需要把后面的数都用括号括起来，像这样： $1 \div(2 \div 3 \div 4)$。

拆括号后是这样的： $1 \div 2 \times 3 \times 4$。

把位置调换一下： $1 \times 3 \times 4 \div 2$。

但是因为把除了第二个数以外所有数乘起来会**爆空间**，那只有高精度了？

高精度是可以的，但不过有更好的办法（~~主要是懒得写~~）

我们可以把这个算式看成一个分数，只要约分约得分母是 $1$ 那就可以，而**分母就是第二个数**，**分子就是第一，三，四个数乘起来的结果**。

那就可以**把第一，三，四个数都和第二个数约分**，也就是两边除以最大公约数，当所有数都和第二个数约完分，当第二个数是 $1$ ，那就输出 $Yes$ ，否则输出 $No$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10005];
int gcd(int a,int b){
    if(!b) return a;
    return gcd(b,a%b);
}

int main(){
    int t,n;
    cin>>t;
    while(t--){
        cin>>n>>a[1]>>a[2];
        a[2]/=gcd(a[1],a[2]);
        for(int i=3;i<=n;i++){
            cin>>a[i];
            a[2]/=gcd(a[2],a[i]);
        }
        if(a[2]==1){
            cout<<"Yes"<<endl;
        }
        else{
            cout<<"No"<<endl;
        }
    }
	return 0;
}
```


---


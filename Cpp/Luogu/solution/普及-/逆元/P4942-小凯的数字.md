# 小凯的数字

## 题目背景

NOIP2018 原创模拟题T1

NOIP DAY1 T1 or DAY 2 T1 难度

是否发现与NOIP2017 DAY1 T1 有异曲同工之妙

## 题目描述

小凯有一天突发奇想，写下了一串数字：$\overline{l(l+1)(l+2)...(r-1)r}$

例如：$l=2,r=5$时，数字为：$2345$

$l=8,r=12$时数字为：$89101112$

小凯很喜欢数字 $9$，所以他想问你他写下的数字除以 $9$ 的余数是多少

例如：$l=2,r=5$时，$2345\,\,mod\,\,9 = 5$

## 说明/提示

样例1解释：$2345\,\,mod\,\,9 = 5$   $89101112\,\,mod\,\,9 = 5$

30% 数据满足：$Q\leq10;l,r\leq100$

50% 数据满足：$Q\leq100;l,r\leq10000$

70% 数据满足：$Q\leq1000;l,r\leq10^6$

100%数据满足：$Q\leq10000;0<l,r\leq10^{12}$ 且 $l\leq r$

## 样例 #1

### 输入

```
2
2 5
8 12```

### 输出

```
5
5```

## 样例 #2

### 输入

```
3
1 999
123 456
13579 24680```

### 输出

```
0
6
0```

# 题解

## 作者：OIer991215 (赞：188)

    首先看一下数据氛围！数据范围疯狂暗示着O（1）做法。
    
    
    观察 l，l+1，l+2，l+3，...，r-1，r，这些数字之间去掉逗号之后，成了一个巨大的数，然而模数是9，很小。那么为什么模数是9呢？于是突破点就来了。
    
    
    继续观察l，l+1，l+2，l+3，...，r-1，r。 这些数字之前一旦去掉了逗号，那么上述数字对最后巨大数字的贡献是10的若干次方。
    
    也就是 l*(10)^? + (l+1)*(10)^? + ... + (r)*(10)^?    （？代表“若干”）.


    10的若干次方 除以 9 的余数  恒为 1 ！！！

那么 l*（10）^?  % 9 = l%9。


那么上面那堆数字组起来的大数除以9的余数 就 等同于 那堆数字加起来乘1除以9的余数。


而这些数字之间只相差1，那么根据等差数列求和公式，O（1）计算答案就好了。


等差数列求和里有模运算，也有除法运算，那么把分母转化成逆元（2在模9的意义下 逆元是5）


于是这题就解决了
代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		long long l,r;
		cin>>l>>r;
		long long cnt=(r-l+1)%9;;
		long long ans=cnt*(l%9)%9+(cnt)*(cnt-1)%9*5%9;
		cout<<ans%9<<endl;
	}
	return 0;
}
```

---

## 作者：ttjb (赞：139)

这是一道很有意思的数学题，分享一下我的思路。

首先说一下一个数模 $9$ 有什么特殊性质：

令数字 $a$ 从左往右第 $i$ 位数为 $a_i$，共  $n$ 位，则有**式一**：

$a\mod\ 9 = (a_1+a_2+a_3+...+a_n ) \ mod\ 9$

在加上

$(x+y)\ mod\ p = (x\ mod\ p+ y\ mod\ p)\ mod\ p$

可以想出朴素算法1.0，根据题意将$[a,b]$上的所有整数拆成一位位数，然后累加求模。

然而这显然会爆  ~.~。

于是我们继续优化。

~~一不小心~~注意到式一中 等号两边交换 也是成立的。

由此可将朴素算法1.0优化一下，将$[a,b]$上每一个数直接累加，然后求模，得到朴素算法2.0。

然并卵，还是会爆 -_-。

但我们不要灰心，**优化是无止境的**。

对于每个数 $p$ ,显然都有任意整数 $n$ 满足**式二**：

$[(n+1)+(n+2)+...+(n+p)]\ mod\ p=0 $

也就是说，我们在枚举 $[a,b]$ 时有很多个**连续的** $[kn+1,kn+9]$ 都是不需要管的，我们只需要特判 $a$ 和 $b$ 各自所在的那个 $[k_xn+1,k_xn+9]$ 就可以了。

举个栗子：

$ a=15\ ,b=179 $ 

为了方便，我们让 $n=9$，即 $kn$ 是 $9$ 的倍数，则有 $a \in[10\ ,18] $ ， $b \in[173\ ,180] $ ，我们取其交集，也就是 $[15\ ,18]\cup[173\ ,179]$ ，然后把这个区间上的整数加起来模 $9$ 就是答案。

由此得到O(1)算法3.0 了qwq。

看到这儿，你已经有办法AC这道题了，但是还是那句话，

### 优化是永无止境的。

在算法3.0中，$n$ 的选取还是挺麻烦的。如果$a$ 和 $b$在同一个 $[n+1,\ n+9]$ 里时就好了，可以直接累加。

呀~这个思路貌似可行。反正中间有一大段都没用，我们能否让 $a$ 和 $b$直接跳到同一区间呢？

我们可以让 $b$ 不断减 $9$ ，直到 $a$ 和 $b$ 相遇。用循环效率太低，但是O(1)求又有点绕。这时候，相信你已经能脱口而出了：

### 优化是永无止境的。

实际上，让 $a$ 不断减 $9$ 也不会改变结果。那我们就可以直接模 $9$ ，很轻松地让$a$ 和 $b$一下子跳到同一区间。

记得维护 $a \le b$。

本人才疏学浅，想到这步已经是极限了。期盼有哪位神牛能继续优化下去。

### 优化是永无止境的。

附上高清代码

```cpp
#include<cstdio>
int main()
{
	long long a,b;
	int T,ans;	//自信地将ans定义为 int 
	for(scanf("%d",&T);T;T--)
	{
		scanf("%lld%lld",&a,&b);
		
		a%=9,b%=9;		//一步邂逅
		if(b<a)b+=9;	//维护 
		
		ans=0;
		for(int i=a;i<=b;i++)//累加 
			ans+=i;
		
		printf("%d\n",ans%9);
	}
	return 0;
}

```
----

## 后记
当我敲到这一行时，时间是是2019年11月16日 22:35:11。

今天是CSP-S 的 Day1。

脑袋在出考场后无比清醒，沮丧、悔恨、绝望···

今天已经白给了，省一的梦愈发模糊。

当初搞奥赛谁不是为了拿奖呀...

但是，如果能重来，我仍要选OI。我已经被算法的魅力深深吸引。在这说来话长的一年当中，我对OI的感情更深沉了。这也算是一场美丽的邂逅吧。

人生的相遇相逢不存在O(1)，愿每位OIer仍在路上。

还有不到10小时就是Day2了，该休息了，那就写到这里吧。


---

## 作者：幕天霁宇 (赞：57)

### 蒟蒻第一篇题解，为了发题解学了很长时间markdown，希望审核通过啊，当然如果大家看到了并且能够看明白，那么我再高兴不过了。
题目很简单，就是一串数字对9取模。首先我们要明白一个性质：**一个数字除以9的余数等于它的各位数字之和除以9的余数**（具体证明过程我就不展示了，建议百度一下，还是很好理解的）。

这样一来我们只需要求解每一位数字的和就行了。可以知道根据题目描述我们可以**用等差数列的求和公式**来求得各位数字之和。

那么又出现问题了，直接求和是很容易爆掉long long的，那么我们要考虑对它中途进行取模。

取模过程中又会出现一个问题：我们知道a# 乘b%c=(a%c乘b%c)%c，**可是在求和公式中，出现了除法**，出现了除法又应该怎么办呢？

很容易的看到，我们可以将求和公式拆成两个式子相乘的形式，

比如原式为

    （l+r）*（r-l+1）/2//等差数列求和公式，l+r为首项加尾项，r-l+1为项数
 
 我们可以拆分成两个式子：

    （l+r）与（r-l+1）/2

或者

    （l+r）/2与（r-l+1）

这样分别对它们进行取模操作之后再次进行相乘取模。

接下来我们再来面对下一个问题：**这样会出现小数**。

由于我们无法知道这两个拆分的式子哪一个是偶数，因此这样一来由于long long是整型，计算过程中我们要除以二，如果是除以二的那个式子的分子是奇数，那么就容易出问题。因此我们要判断哪一个是偶数。
我们可以先判断（l+r）与（r-l+1）哪个是偶数，然后让偶数的那一个除以二，接下来再进行取模相乘再取模，这样就大功告成了！
### 接下来是我的代码（注意我的n和m分别代表的是题目中的l与r）
```cpp
#include <iostream>
using namespace std;
long long n,m,k;
int main()
{
    cin>>k;
    long long x,y;
    while(k--)
    {
    cin>>n>>m;//n与m分别代表题目里的l与r，
    if((m+n)%2==0)//拆分等差数列求和公式的关键
    {
		x=(m+n)/2;//当m+n为偶数时，让它除以二作为其中一个因式
		y=m-n+1;//m-n+1必然为奇数，
	}
    else {
		x=(m-n+1)/2;//m-n+1为偶数
		y=m+n;
    }
    cout<<(x%9*y%9)%9<<endl;//用拆分后的两个式子作为等差数列求和公式
    }
	return 0;
}
```
## 祝大家noip更上一层楼！

---

## 作者：汪鸣谦 (赞：56)

这个题似乎不需要用到什么逆元知识

~~尽管我并不知道逆元是什么~~

定理1：一个数模9的余数等于他的数字和模9的余数

举个~~栗~~例子

910111213%9=(9+1+0+1+1+1+2+1+3)%9

再变换一下：9+(1+0)+(1+1)+(1+2)+(1+3)

and then:9+10+11+12+13

发现了吗

答案就是(l+r)*(r-l+1)/2%9

代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n,l,r;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>l>>r;
        cout<<((l+r)*(r-l+1)/2)%9<<endl;
    }
    return 0;
}
```
蛋是

！！！！

WA了三个点

why

l+r and r-l+1是会爆longlong的啊

怎么办

方案1：把l+r和r-l+1分别%9再/2%9

结果：样例都过不了

方案2：带上/2一起%9

结果：AC

双手奉上代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n,l,r;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>l>>r;
        if((l+r)%2==0){
            cout<<(((l+r)/2)%9*(r-l+1)%9)%9<<endl;
        }
        else{
            cout<<((l+r)%9*((r-l+1)/2)%9)%9<<endl;
        }
    }
    return 0;
}
```
只求两个事：过和赞

祝大家rp++！

---

## 作者：vectorwyx (赞：33)

## 数论好题


------------
犹记五年级时，小学数学老师~~拿着占来的体育课~~给我们拓展9的整除特性

有一句话让我印象很深刻：

**判断一个数能否被9整除，可以把这个数按数位随便“切”**

**把“切”下来的数加起来，所得到的数能被9整除，原数就能被整除**

（也就是得到的数与原数关于9同余）


------------
当时我学的东西太少，听不懂~~这么高深的~~理论

老师就举了个例子：
```
比如说12345
可以先在个位和十位切一刀-> 1|2345
然后在百位和千位切一刀-> 1|23|45
那我们切出来3个数：1,23,45
求和 1+23+45=69
69不能被9整除，因此原数12345不能被9整除
```
```
当然，切哪里随便，你也可以切4刀把12345变成1|2|3|4|5
然后求和 1+2+3+4+5=15
15不能被9整除，因此原数12345不能被9整除
有没有发现这种情况就是我们一开始学的把各位数加起来判断的方法？
```


------------
但是为什么呢？

从最简单的情况出发

如果有一个三位数为abc，其中a为百位，b为十位，c为个位

则a+b+c$\equiv$abc(mod9)

由于a+b$\equiv$ab(mod9)

**故ab+c$\equiv$abc(mod9)**

同理可得a+bc$\equiv$abc(mod9)


------------
推广，若有一个N位数a$_ {1}$a$_ {2}$ $\ldots $a$_{N}$

则有$a_{1}$ $\ldots$ a$_ {i}$ + a$_ {i+1}$ $\ldots$ a$_ {N}$ $\equiv$a$_ {1}$a$_ {2}$ $\ldots$ a$_ {N}$

------------

因此，这道题就迎刃而解了：

把$l$到$r$之间的整数加起来,输出它模9的结果

就是求一个等差数列的和，求和公式：

$sum$ = $(l+r)$ $\cdot$ $(r-l+1)/2$ 

由于$l+r$和$r-l+1$中至少有一个为偶数

那我们找到这个偶数，除以2

最后对它们分别取模

输出，搞定！


------------
代码来了~
```cpp
#include<iostream> 
#include<cstdio>
#define ll long long//宏定义，省事
using namespace std;
int main(){
	int n;
	ll l,r,sum;//注意数据范围为longlong
	cin>>n;
	for(int i=1;i<=n;++i){//n次询问
		scanf("%lld%lld",&l,&r);//首项、末项
		ll t1=l+r,t2=r-l+1;
		if(t1&1) t2/=2;//位运算判断t1是否为奇数
	//t1是奇数，那t2就是偶数，除以2 	
		else t1/=2;
    //t1是偶数，那就直接除以2
		sum=t1%9;//分别取模
		sum*=t2%9;
		printf("%d\n",sum%9);//输出
	}
	return 0;
} 
```
你AC了吗？AC了就点个赞呗

---

## 作者：Freddie (赞：12)

#### 先来看规律

| 1 |2  | 3 | 4 |5  |6  |7  | 8 | 9 | 10 | 11 |12  |13  | 14 | 15 | 16 | 17 | 18 | 19 |20  |%9
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  1| 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 2 |3  | 4 | 5 | 6 | 7 |  8| 0 | 1 | 2 |=

所以我们发现 一个数%9=这个数各位的和，
所以 举例： 456%9=16%9=7
我们还可以发现 除余数列为 | 1 2 3 4 5 6 7 8 0 | 1 2 3 4 5 6 7 8 0 | ....
九个一循环

数据范围水 10^12 long long 就可以了 
#### 看渣渣的代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
inline void read(long long &s){//读入优化
	char a;int f=1;s=0;
	a=getchar();
	while(a>'9'||a<'0')
	{
		if(a=='-')f=-1;
		a=getchar();
	}
	while(a>='0'&&a<='9')
	{
		s=10*s+a-'0';
		a=getchar();
	}
	s=s*f;
}
int main()
{
	long long q;
	read(q);
	while(q--)
	{
		long long a,b;
		read(a);read(b);
		//      九个一循环↓ + （ 首项  + 尾项 ）* 项数 /2 
		cout<<(((b-a+1)/9*36)%9+((a%9)*2+(b-a)%9)*((b-a)%9+1)/2%9)%9<<endl;//懒得再简化
	}
    return 0;
}
```
弱鸡的代码↑ dalao轻喷

---

## 作者：文文殿下 (赞：12)

看大家用的都是很复杂的推式子。文文不会推，智商不够，只能算法来凑了。

首先，结论是 

$$(l+r)\times(r-l+1)\div2\mod9$$

我们知道，前两个数乘起来，是会爆$ll$的

这个式子等价于

$$(l+r)\times(r-l+1)\times5\mod9$$

因为$5$是$2$在 膜 $9$ 意义下的逆元.

这样就变成了三个数的乘积，对一个数取模，我们可以在运算过程中取模。

我们使用基于快速幂的快速乘，解决爆$ll$的问题




```cpp
#include<cstdio>
typedef long long ll;
int T;
ll l,r;
inline ll ksc(ll a,ll b,ll m) {
	ll ret = 0;
	while(b) {
		if(b&1) ret=(ret+a)%m;
		a=(a+a)%9;
		b>>=1;
	}
	return ret;
}
inline void solve() {
    ll ans = 0;
    ans = ksc((l+r),(r-l+1),9)*5%9;
    printf("%lld\n",ans);
    return;
}
int main() {
    scanf("%d",&T);
    while(T--) {
        scanf("%lld%lld",&l,&r);
        solve();
    }
    return 0;
}
```


-------------------------------------
UPD at 11/20

文文上面的做法脑残了。
直接 $(l+r)\mod 9\times(r-l+1) \mod 9 \times 5 \mod 9$ 就行了。

如果你不知道什么是逆元的话，没关系。

这里文文非大家分享一个~~珍藏的~~小技巧，攒一下RP

当要除的数非常小的时候，我们可以直接把要取模的数扩大相应的倍数，正常除就行了。最后再对答案取模

代码：

```cpp
#include<cstdio>
typedef long long ll;
int T;
ll l,r;
inline void solve() {
    ll ans = 0;
    ans = (l+r)%18*(r-l+1)%18/2;
    printf("%lld\n",ans%9);
    return;
}
int main() {
    scanf("%d",&T);
    while(T--) {
        scanf("%lld%lld",&l,&r);
        solve();
    }
    return 0;
}
```

---

## 作者：Snowflake_Pink (赞：7)

## [题面](https://www.luogu.org/problemnew/show/P4942)

* 这道题我觉得不应该是绿题啊QAQ，最多应该是黄题吧！题解里面都好像用的是$O(1)$的算法，~~~但是为什么跑的比我慢呢QAQ？？~~我觉得可能是mod地太多了吧。。。。

* 分析：我因为太菜了，所以不会这种做法，这题要求的是9的余数，所以就要用到一个众所周知的定理：一个数字各个数位之和除以9的余数等于这个数除以9的余数。**所以我们只需要算出这个数各位之和除9的余数就可以了！！**
* 接下来我们“化简”一下：这个数的组成方式是$l(l+1)(l+2)...(r-1)$。所以我们只需要`for (i=l;i<=r;i++)`，算出每个$i$的余数（这里也用上面讲的定理）就可以了。
* 但是！！看看那个100%的数据$（0<l,r \leq 10^{12}）$，如果$l=1,r=10^{12}$那一定会超时，在想一下！！我们是否需要将每个$i$都算一遍余数呢？？当然不用，每9个相邻的自然数的余数之和为36，正好是9的倍数，所以我们只要把头和尾的一些$i$算一遍余数就可以了。
* Code：下面还有一些细节会在Code中讲解

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int q;
long long l,r,ans,x,y;//不开long long见祖宗
int Mod(long long num){
	int t=0;
	while (num){
		t+=num%10;//这里不需要每次都mod一遍，因为int不会爆
		num/=10;
	}
	t=t%9;
	return t;
}
int main(){
	long long i;
	scanf("%d",&q);
	while (q--){
		ans=0;
		scanf("%lld%lld",&l,&r);
		for (i=l;i<=r;i++){//开头余数处理
			int t=Mod(i);
			if (t==0) break;//遇到循环节就break
			ans+=t;
		}
		if (i>=r){
			printf("%lld\n",ans%9);//要做特判！！！不然上面没有遇到循环节时，余数会算两遍
			continue;
		}
		for (i=r;i>=l;i--){//末尾余数处理
			int t=Mod(i);
			if (t==0) break;
			ans+=t;
		}
		printf("%lld\n",ans%9);//不会溢出所以不需要每次都mod一遍，尽量避免mod运算！！
	}
	return 0;
}
```

$PS$：题解有问题来私信我哈~~

---

## 作者：kangli (赞：5)

大家都知道的一个性质：~~一个数除以$9$的余数等于这个数每一个位的和除以$9$的余数~~

所以我们考虑枚举每一个区间，但是显然会超时。

考虑优化。我们容易发现，对于任意的九个**连续**自然数，记为$a_1,a_2,a_3...a_9$，这九个数字的每一位数字之和必被九整除。


所以每次读入一个区间，可以舍弃区间后面$9x$个长度的数字（$x$为整数），留下前面几个数，累加求和即可。

复杂度为$O(K*Q*d)$，其中（$K<=9$即数字的数量，$d<=12$为每个数字长度）

蒟蒻奇丑的代码（~~比赛写的~~）
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
long long ans,T,l,r;
long long cd,w,cd2,w2,jilu;
int main()
{
    cin>>T;
    while (T--)
    {
        jilu=0;
        scanf("%lld%lld",&l,&r);
        cd=r-l+1;w=cd%9;
        l=r-w+1;
        while(l<=r)
        {
        	cd2=l;
        	while (cd2)
        	{
        		jilu=jilu+(cd2%10);
        		cd2=cd2/10;
            }
            jilu=jilu%9;
            l++;
        }
        jilu=jilu%9;
        printf("%lld\n",jilu);
    }
    return 0;
}
```

---

## 作者：Flokirie (赞：4)

**引理：一个数等于它各数位上的数码之和$(\mod 9)$。**  
引理的证明：设一个数$\overline{a_na_{n-1}...a_0}=\sum _{i=0} ^n a_i10^i$,那么  
$\sum _{i=0} ^n a_i10^i\equiv \sum _{i=0} ^n a_i1^i=\sum _{i=0} ^n a_i(\mod 9)$，证毕。

----
回到本题，要求$\overline{l(l+1)(l+2)...r}\%9$,根据引理，它等于   
$\sum _{i=l} ^r i\%9$。似乎TLE？
## 优化1
转化为$(\sum _{i=1} ^r i-\sum _{i=1} ^{l-1} i)\%9$，套用等比数列求和公式可以AC。  
也就是说，求$\frac {n(n-1)} 2$时，对n分奇偶讨论，去除分母上的2，模9之后再相乘。
## 优化2
连续的9个数相加一定被9整除。  
所以我们可以将$l$加上9的倍数进行求解。
## 最后附上我压行的C语言程序：
```c
q,s;long long l,r;
sum(long long x){if (x/10)return x%10+sum(x/10);else return x;}
main(){
    for(scanf("%d",&q);q--;s=0){
        scanf("%lld %lld",&l,&r);
        for(l=(l+(((r-l)/9)*9));l<=r;++l)s+=sum(l);
        printf("%d\n",s%9);
    }
    return 0;
}
```

---

## 作者：GMSD (赞：3)


这道题目需要仔细想
可以发现：对于任意连续九个自然数组成的数一定可以被9整除
所以只要（end1-start+1）%9==0 输出0
否则 从end1开始向前枚举，拆分每个数，加起来，输出 %9的值 







```
#include<bits/stdc++.h>
using namespace std;

long long start,end1,ans,number;

long long find(long long num){
	int s=0;
	while(num>0){
		s+=num%10;num/=10;
	}
	return s;
}

int main(){
	cin>>number;
	for(int i=1;i<=number;i++){
	cin>>start>>end1;
	ans=(end1-start+1)%9;
	if(ans==0){
		cout<<0<<endl;return 0;
	}
	int sum=0;
	for(int p=0;p<=ans-1;p++){
		sum+=find(end1-p);       
	}
	cout<<sum%9<<endl;
	}
	return 0;
}
```

---

## 作者：Dirt、 (赞：2)

O(1)好题

l到r的区间中数字的和为(l+r)*(r-l+1)/2

但是乘完再取模可能会爆long long

所以我们先将(l+r)和(r-l+1)对18取模

为什么对18呢？因为后面还要除以2，对9取模可能会WA掉

最后再对9取模就可以了~

或许是最短题解？

```
#include<cstdio>
using namespace std;
int q;
long long l,r;
int main()
{
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		scanf("%lld%lld",&l,&r);	
		printf("%lld\n",(((l+r)%18)*((r-l+1)%18)/2)%9);
	}
	return 0;
}
```

---

## 作者：_ZZH (赞：2)

事实上，这道题就是个等差数列求和。

显然一个数%9的值等于其各位之和%9的值，且有(a+b)%9=(a%9+b%9)%9

那么问题转化为求这个数l(l+1)(l+2)(l+3)……r各位之和

那么就可以看成l+(l+1)+(l+2)+(l+3)+……+r

我们仔细考虑一下其正确性：

如果一个数m∈[l,r],那么一定可以分解为每一位数乘以10的次方相加的形式。

比如这个数是45，那么你在求l(l+1)(l+2)(l+3)……r各位之和时，45你会算4+5而不是45.

但事实上45%9=(4+5)%9.对于答案的贡献是一样的,所以计算4+5和45是等价的。

为什么？

还是因为“一个数%9的值等于其各位之和%9的值”。

所以结果为(l+r)*(r-l+1)/2;

---

## 作者：RedreamMer (赞：1)

# P4942 题解

算法：数论

首先思考题目为什么叫我们 $mod9$ ，显然，我们~~小学时~~学过对于一个数 $n$ 与所有数位之和 $sum(n)$ ，若 $9|sum(n)$ ,则 $9|n$ 

根据以上，其实不难证出 $sum(n)$ $mod$ $9=n$ $mod$ $9$，令

$n=a_1*1000...+a_2*1000...+a_3*1000...+...+a_x$

（其中$a_i$表示n在各个数位上的数字)，将原式子分解为

$S_1=a_1*999...+a_2*999...+a_3*999...+...+a_(x-1)*9$

$S_2=a_1+a_2+a_3...+a_x$

$n=S_1+S_2$

显然，$9|S_1$，则必然 $S_2$ $mod$ $9=n$ $mod$ $9$ ，发现 $S_2$ 等于 $n$ 的各个数字之和

题目中，输入的 $l$ 和 $r$ 可以运用高斯求和公式得到$(l+r)*(r-l+1)/2$，因为两数相乘可能爆 $long$ $long$ ，所以把式子转化为$(l+r)$ $mod$ $9*(r-l+1)$ $mod$ $9/2$


------------


### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,e;//数据范围会爆int 
inline long long r() {//快读 
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int main() {
	a=r();
	for(int i=1;i<=a;i++){
		b=r();
		c=r();
		d=(b+c)%9;
		e=(c-b+1)%9;
		if((d*e)%2)//如果乘积为奇数，则需加上9再除2，必能被2整除 
		printf("%lld\n",(d*e+9)/2%9);
		else
		printf("%lld\n",d*e/2%9);
	}
	return 0;
}
```

---

## 作者：Stick_With_Mars (赞：1)

#  这道题py多好qwq,此处感谢 @sjx233 大佬，
##  公式为((l+r)*(r-l+1)//2)%9
这是我原来的程序
```python
n=int(input())
for i in range(1,n+1):
    l,r=map(int,input().split())
    print(((l+r)*(r-l+1)//2)%9)#//为向下取整
```
然后呢，90分，最后一个RE了,然后我在讨论版里得到了 @sjx233 大佬的帮助qwq。
```python
n = int(input())#输入n
for i in range(n):#循环到n
    s = input()#先输入一个试试水，注意此处s为str类
    while not s.strip():#如果s为空格
        s = input()#人类的本质，循环输入
    l, r = map(int, s.split()) #不是空格了，输入qwq
    print((l + r) * (r - l + 1) // 2 % 9)#不是空格了，输出qwq
``` 
~~可以直接复制，看我对你们多好~~
~~前面最短题解的粗来~~


---

## 作者：Tiphereth_A (赞：1)

极水数学题

首先我们要用到这个式子：

$$l\equiv m(\mathrm{mod}\ 9)\Leftrightarrow 10l\equiv m(\mathrm{mod}\ 9)$$


显然成立，证明略（才不是我懒

所以题目就转换成了：

计算$\displaystyle\sum_{i=l}^r{i}$的值

又等差数列求和公式可以得到结果为$\frac{(r-l+1)(l+r)}{2}$

不过要注意直接算会爆``long long``，所以要中间取模或者用``__int128``（不推荐）

另外除以$2$可以换成乘$32$（参见乘法逆元）

因为太水了所以就不放代码了

---

## 作者：Str1n9 (赞：1)

~~做了一晚上也没做出来的好题~~

# 标签：数论

## 先来看这样一个问题：

对于一个数 mod 9 的结果，可以用数学相关知识来求解。

假设 x = (a_1a_2a_3a_4....a_n+1)，其中ai表示数x对应位置的数字，

那么有：

		x = a_1 * 10 ^ n + a_2 * 10 ^ (n - 1) + ... a_n+1 * 1;
	
		将10 ^ i分解为 9999...9 + 1的形式，那么就有以下操作：
        
        x = a_1 * 99..9 + a_2 * 99..9 + ... a_n * 9
        	+ a_1 + a_2 + ... a_n+1;
        
        因为99..9 mod 9 = 0，所以 a_i * 99..9 mod 9 = 0；
        
        那么我们就可以得出在 mod 9 的情况下 x 与 a_1 + a_2 + ... a_n+1 同余。
        
## 再来看这个问题

对于一个数，每一位由 l ~ r 对应的数字组成，求这个数 mod 9 的结果。

首先我们按照刚才那个结论可以得出：
	
    这个数 mod 9 的结果与它各位数字之和 mod 9 的结果是一样的。
    
由于 l 和 r 给定，那么我们可以暴力的求出 l 到 r 的数字位之和之后再 mod 9 从而得出答案。

但是这样循环只能拿 70 Points，怎么办呢，考虑优化。

### 优化1

	前缀和优化计算速度。
    
    首先递推出每个数的数字位之和，再维护一个前缀和数组，在数组内就 O(1) 查询，否则暴力求解。
    
    这个优化方法可以拿到 80 Points。
    
```cpp
	inline void make() {
    	for(int i = 1;i < size;i++) {
        	cnt[i] = cnt[i / 10] + i % 10;
        	sum[i] = ((cnt[i] % 9) + (sum[i - 1] % 9)) % 9;
    	}
	}
```
	
    是不是很像求二进制下 x 中 1 的个数那种方法？
    
### 优化2

	再次利用最开始那个结论。
    
    将排列出来的数 x 写成以下形式：
    
    x = l * 10 ^ k_1 + (l + 1) * 10 ^ k_2 + ... + r
      
      = l * 99..99 + (l + 1) * 99..99 + .. + r
      	+ l + (l + 1) + ... + r;
    
    同理可以得出 x 与 l + (l + 1) + ... + r 在 mod 9 的情况下是同余的。
    
    所以说只要计算出 l + (l + 1) + ... + r 再 mod 9 就可以了。
    
    利用等差数列求和公式可以很轻松地得出：
    	
        l + (l + 1) + ... + r = (l + r) * (r - l + 1) / 2;
        
    然后计算求解即可。
    
    代码如下：(100 Points)
    
```cpp
	
    #include<iostream>
	#include<cstdio>
	using namespace std;
	typedef long long ll;

	int main() {
   		int T;
    	scanf("%d", &T);
    	while(T--) {
        	ll l, r;
        	scanf("%lld%lld", &l, &r);
        	ll a, b;
        	a = l + r, b = (r - l + 1);
        	if(a % 2) b /= 2; // 防止除以2后向下取整之后出现错误答案
        	else a /= 2;
        	a %= 9, b %= 9;
        	printf("%lld\n", (a * b) % 9);
    	}
    	return 0;
	}
```

---

## 作者：l_water (赞：1)

才发现这个题目没人发题解QAQ，我赶紧过来水一篇.......其实当时考试的时候我反正是没有想出来的QAQ~~我太菜了~~还是我们机房大佬yzx72424给出的思路：一个数对九取余，等于将这个数的各个位上的数加起来的和取余9。
###### 那么题目是不是可以直接写出来了呢
[点这儿查看更多关于求余个位数的方法](https://blog.csdn.net/never__give__up/article/details/78340808)
上代码
```
#include<bits/stdc++.h>
using namespace std;
int t;
long long l,r,sum;
int main()
{
    scanf("%d",&t);
    for(register int i=1;i<=t;i++)
    {
        scanf("%lld%lld",&l,&r);
        sum=(((r-l)%9+1)*(l%9))%9+(((r-l)%9+1)*((r-l)%9))/2;
        sum%=9;
        printf("%lld\n",sum);
    }
    return 0;
}
```
就是酱紫哇！炒鸡简单的有没有虽然我没有写出来QAQ

---

## 作者：DPair (赞：1)

### 小学奥数题都没人证明的。。。我来给大家普及一下小学奥数知识

## 【小学奥数】
我记得我小学五年级级的时候学过一个秘诀，可以快速判断一个数能不能被$9$整除：**把这个数的每一位都加起来，看能不能被9整除，如果能，则原数可以被$9$整除，反之则不能**

当时的证明就可以用在今天这道题上了。~~虽然这是道绿题，但我还是要认真写题解（逃）。~~

## 【思路】
我们看到数据范围时，可以很快想到要用$O(1)$或$O(logn)$查询，鉴于$l,r$有$10^{12}$那么大。

所以，我们开始推断，被$9$除的余数有没有什么特点？

这时，我想起了可爱的小学奥数。

然后，就可以发现，$[l, r]$中的每一个数的和对$9$取余，就是答案。当然，我是肯定会给证明的。

## 【证明】
首先，我们假设有一个数$x$，有$n$位

设它的从低到高（即$a_1$是个位）每一位是$a_1, a_2, a_3, ......a_{n-1}, a_n$

可得
$$x = a_n * 10^{n - 1} +a_{n-1}*10^{n-2} +......+ a_3 * 10^2 + a_2 * 10^1 + a_1 * 10^0$$
由于
$$10 \equiv 1 (mod~9)$$
根据在**取余运算下的分配率**，有
$$10^k \equiv 1 (mod~9)~~~~~~~~(k \in N^*)$$

所以：
$$x \equiv a_n + a_{n - 1} + ...... + a_3 + a_2 + a_1 (mod~9)$$

### 也就是说，一个数被对$9$取余的结果与它的每一位和对$9$取余的结果相同！
但是，这有什么用呢？

我们容易发现：
$$\because x \equiv a_n + a_{n - 1} + ...... + a_3 + a_2 + a_1 (mod~9)$$
$$\therefore x \equiv a_n * 10^k + a_{n - 1} * 10^{k-1} + ... + a_{n - k} * 10^0...... + a_3 + a_2 + a_1 (mod~9)$$
不妨设：
$$a_n * 10^k + a_{n - 1} * 10^{k-1} + ... + a_{n - k} * 10^0 = S$$
则有：
$$x \equiv S_1 + S_2 + S_3 + ...... + S_k (mod~9)$$
比如：$123124125126$这个数（即$l=123, r = 126$）

有
$$\because 123124125126 \equiv 1 + 2 + 3 + 1 + 2 + 4 + 1 + 2 + 5 + 1 + 2 + 6 \equiv 3 (mod~9)$$
$$\therefore 123124125126 \equiv 1* 10^2 + 2*10 + 3 + 1*10^2 + 2*10 + 4 + 1*10^2 + 2*10 + 5 + 1*10^2 + 2*10 + 6 \equiv3 (mod~9)$$
$$\therefore 123124125126\equiv 123 + 124 + 125 + 126\equiv3 (mod~9)$$

这不是等差数列求和吗。。。$O(1)$随便搞搞。

## 【注意】
由于此处要有$\div2$操作，我们要使用**逆元**，这里不再赘述了，只需知道$2$在模$9$意义下的逆元为$5$，因此，把$\div2$变成$\times5$再取模就可以了。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
template <typename T>
inline void read(T &x)//快读
{
    char c;
    x = 0;
    int fu = 1;
    c = getchar();
    while(c > 57 || c < 48)
    {
        if(c == 45)
        {
            fu = -1;
        }
        c = getchar();
    }
    while(c <= 57 && c >= 48)
    {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x)//快输
{
    if(x < 0)
    {
        putchar(45);
        x = -x;
    }
    if(x > 9)
    {
        fprint(x / 10);
    }
    putchar(x % 10 + 48);
}
LL Q, l, r;
int main()
{
    read(Q);
    while(Q --)
    {
        LL ans;
        read(l);
        read(r);
        ans = (r - l + 1) % 9;//冗长的等差数列求和
        l %= 9;
        r %= 9;
        l += r;
        l %= 9;
        ans *= l;
        ans *= 5;//乘5再模9意义下与/2无异
        ans %= 9;
        fprint(ans);
        putchar('\n');
    }
}
```



---

## 作者：Xie_BR (赞：0)

# 逆元大法好

对于标签，我们就知道了这是一道逆元的题目，但是转念一线，~~貌似也没有那么的复杂~~。

我们所理解的逆元是一种在CSP里经常用到的优化办法，但是对于这道题来说，我们可以直接进行答案的求解：  

# AC代码：  
```cpp
#include<bits/stdc++.h>
#define int long long
#define MK 100010
const int mod = 9;
using namespace std;
int T;

signed main()
{
	scanf("%lld",&T);
	while(T--)
	{
		int l,r;
		scanf("%lld%lld",&l,&r);
		int cnt1 = (((r-l)%mod+1)*(l%mod))%mod;
		int cnt2 = (((r-l)%mod+1)*((r-l)%mod))/2;
		int ans = cnt1+cnt2;
		ans = ans%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

# :）

---

## 作者：光阴且含笑 (赞：0)

~~这题好像配不上绿题标准~~

仔细看看题会发现答案是从l累加到r(~~用不来LaTeX...~~) 


但看数据范围：Q<=10000;l和r小于10的12次方

应该不能线性推叭

那公式计算(l+r)*(r-l+1)/2

似乎爆long long

但是又一想：((a*b)%x)=((a%x)*(b%x)%x)

那就好做了

AC代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int q;
long long l,r;
int main(){
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		scanf("%lld%lld",&l,&r);
		long long step,temp;
		if((r-l+1)%9==0){//如果有9的倍数项那%9等于0
			printf("0\n");
			continue;
		}
		step=l+r;
		temp=r-l+1;
		if(step%2==0){//判断哪个是2的倍数
			step/=2;
			step%=9;
			temp%=9;
			step=step*temp%9;//计算答案
		}
		else if(temp%2==0){
			temp/=2;
			step%=9;
			temp%=9;
			step=step*temp%9;
		}
		printf("%lld\n",step);
	}
	return 0;
}
```


---

## 作者：JustinRochester (赞：0)

[题目](https://www.luogu.org/problem/P4942)

为什么看到很多题解区的 dalao 都用逆元？~~是我太菜了吧~~

---

**【分析】**
---

首先，根据弃九验算法的原理，显然可以得到：一个 $n$ 位数

$a_1a_2a_3\dots a_n\equiv a_1+a_2+a_3+\dots+a_n(\mod 9)$

证明：

对于第 $k$ 位数 $a_k$ ，它对答案的贡献为$10^{n-k}\times a_k\%9(n\geq k)$

当 $n=k$ 时 $10^{n-k}=10^{n-n}=1$

当 $n>k$ 时 $10^{n-k}=10^{n-k-1}\times 10\equiv 10^{n-k-1}\times 1\equiv\dots\equiv 10^0=1(\mod 9)$

所以第 $k$ 为的 $a_k$ 贡献为 $a_k$ 累计得到上式

---

而对于 $89101112$ 这样的数字，也同等于：

$89101112\equiv8+9+1+0+1+1+1+2\equiv8+9+10+11+12(\mod 9)$

所以我们要求的东西就变为了 $\displaystyle \sum_{i=l}^ri\%9$

那么，我们设 $\displaystyle Last(n)=\sum_{i=1}^ni\%9$

答案即变为 $Last(r)-Last(l-1)$ ，当然，记得取正数

---

现在，问题转变为求解 $Last(n)$

$\displaystyle \because Last(n)=\sum_{i=1}^ni\%9$

而且 $1+2+3+4+5+6+7+8+9=45\equiv 0(\mod 9)$

所以直接有 $Last(n)=Last(n\% 9)$

我们 $9$ 以内的脑算打表，剩下的直接求解即可

---

**【代码】**
---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了

```cpp
#include<iostream>
using namespace std;
inline int read(int ans){
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57){
        ans+=(c-48);
        c=getchar();
        if(ans>=9) ans-=9;
    }
    return ans;
}
int ar_d_Lst[]={0,1,3,6,1,6,3,1,0};
int main(){
    int q,l,r,ans;
    cin>>q;
    while (q--){
        l=read(8),r=read(0);
        ans=ar_d_Lst[r]-ar_d_Lst[l];
        if(ans<0) cout<<ans+9<<endl;
        else cout<<ans<<endl;
    }
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：_TMT_ (赞：0)

大家都知道，一个数的各位数字之和如果是9的倍数，那么这个数就是9的倍数。
那么这道题就可以转化为：**l到r之间所有数除以9的余数之和模9等于几的问题。**
于是我们惊奇的发现，两个可以被9整除的数之间，所有数除以9的余数只有1，2，3，4，5，6，7，8这几种情况（~~接下来才是见证奇迹的时刻！~~）
不难看出：1+8=9，2+7=9，3+6=9，4+5=9；
于是可以得出一个奇妙的结论：**任何两个可以被9整除的数之间，所有数字的总和必定能被9整除。**
所以我们只需要求出l到从左往右第一个能被9整除的数以及r到从右往左第一个能被9整除的数之间的所有数对9取余后的和，之后再对9取余即可。
显而易见这是一道可以循环做的题（~~手动滑稽~~）
上代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int main()
{
	int q;
	cin>>q;
	while(q--)
	{
		long long l,r,t1,t2,ans=0;//题目数据需要开成long long
		cin>>l>>r;
		t1=r;
		t2=l;
		for(long long i=l;i<=r;i++)//找从左往右第一个能被9整除的数
		{
			if(i%9==0)
			{
				t1=i;//记录从左往右第一个能被9整除的数的位置 
				break;
			}
		}
		for(long long i=r;i>=l;i--)//找从右往左第一个能被9整除的数
		{
			if(i%9==0)
			{
				t2=i;//记录从右往左第一个能被9整除的数的位置 
				break;
			}
		}
		if(t1==r&&t2==l)for(long long i=l;i<=t1;i++)ans+=i%9;//l~r之间没有能被9整除的数只需从头加到尾即可 
		else
		{
			for(long long i=l;i<=t1;i++)ans+=i%9;
			for(long long i=t2;i<=r;i++)ans+=i%9;//求出从左往右第一个能被9整除的数以及r到从右往左第一个能被9整除的数之间的所有数对9取余后的和 
		}
		ans%=9;//一定记住还要取一次余 ！！ 
		cout<<ans<<endl;
	}
	return 0;
}
```



---

## 作者：W_awizard (赞：0)

# 本人蒟蒻，发布一篇不成熟的题解吧。
##  这是本蒟蒻AC的第一道绿题，发个题解纪念一下
[AC纪念](https://www.luogu.org/record/22488284)
------------
**接下来进入正题

下面我规定一种运算，叫做同余运算

运算式很简单（a）b%||%c

意思就是对于一个确定的除数a，b与c除以a的余数相等。

什么意思呢？

一个数除以9的余数等于这个数每一位的和除以9的余数

于是乎（9）x%||%(x每一位的和)

又因为连续的九个整数的和一定是9的倍数（对于[l,r]共有r-l+1个数字）

我们只需要求从l开始（r-l+1）%9个数字拼在一起的数字除以9的余数就好。

上代码：


```
#include<iostream>
  
#include<cstdio>
  
using namespace std;
  
int ans=0;
  
int qiuhe(long long o)
  
{    int y=0;
     while (o>0)
     {y+=o%10;
      o/=10;
	 }
	 return y;
}
int main()
{   long long  q,l,r;
    cin >> q;
    
    for (int i=1;i<=q;i++)
    {   long long a,b,d;
        ans=0;
        scanf("%ld%ld",&a,&b);//对于较多个数据，使用scanf和printf读写更快
        d=(b-a+1)%9;
        for (long long j=a;j<=a+d-1;j++)
        {ans+=qiuhe(j)%9;
         ans%=9;
         }
        printf("%ld\n",ans); 
	}
	return 0;
}
```
祝大家心想事成，万事如意!!RP++

---

## 作者：Zesty_Fox (赞：0)

第一次发题解，请大佬指教~~~  
下面先提供几种思路：
## 思路一：高精度乘法、除法、取模  
即计算出小凯这个数字的值再高精度取模。  
但是，这对我这个对高精度~~**深恶痛绝**~~的人怎能容忍呢？？？  
### 思路一：放弃！  

## 思路二：数学+模拟  
首先，介绍一个9的乱切法则：  
#### 对于任意一个数，可以把它的数位分为若干份（如：1836可以分为1、8、36），若这几个数除以9的余数相加还是9的倍数，则这个数一定是9的倍数。如：28377可以分为28、3、77，28%9=1，3%9=3，77%9=5，5+3+1=9，所以28377能被9整除。    
所以这里我们可以把小凯的那个数分为l、（l+1）、（l+2）......（r-1）、r，再求和取模即可。  
最终得分：80（T了两个点QAQ）  
  
## 思路三：公式  
求和公式我怎么没想到呢......  
最终得分：100    

不多说了，上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	long long l,r,ans=0;
	int q;
	cin>>q;//测试数据的组数
	for(int j=1;j<=q;j++)
	{
		cin>>l>>r;//求和公式:(l+r)*(r-l+1)/2
		if((r-l+1)%2==0)//若r-l+1为偶数
		{
			cout<<(((r-l+1)/2)%9*(l+r)%9)%9<<endl;//代入公式计算和取模并输出
		}
		else//若l+r为偶数
		{
			cout<<((r-l+1)%9*((l+r)/2)%9)%9<<endl;//同理
		}
		ans=0;//将和清零,准备下一组数据
	}
	return 0;
}
```


---

## 作者：z3475 (赞：0)

## 引理1
$$\forall x,k\in\mathbb{Z},x*10^k\%9=x\%9$$
### 证明(如果你不觉得显然的话):
$10\%9=1$

$10^k\%9=1$

$x*10^k\%9=x\%9$

## Solution

题目中的
$$l(l+1)(l+2)(r-1)r\%9$$

等价于
$$(\sum_{i=l}^{r}i*10^{k})\%9$$
~~k不好写出来~~

由引理得其等价于
$$(\sum_{i=l}^{r}i)\%9$$
由等差数列求和公式得
$$(l+r)*(r-l+1)/2\%9$$
由因
$$2*5\equiv 1(mod\ 9)$$
得
$$(l+r)*(r-l+1)*5\%9$$
化简
$$(l+r)\%9*(r-l+1)\%9*5\%9$$
## Program
```cpp
#include <iostream>
long long l,r;
int main(){
	int q;scanf("%d",&q);
	while (q--){
		scanf("%lld%lld",&l,&r);
		printf("%lld\n",(l+r)%9*(r-l+1)%9*5%9);
	}
}
```

---

## 作者：loi_hjh (赞：0)

比赛时没想起来，第二天突然找到一种新思路

##### 这个题貌似规律很多，发个与楼上大佬不同的另一种规律：连续9个自然数和为9的倍数

假设共有n个数，我们只需加起来n%9个数再%9得出答案

证明：

因为1+2+...+9=45(%9=0)

所以x+(x+1)+...+(x+8)=[(x-1)+1]+[(x-1)+2]+...+[(x-1)+9]=9*(x-1)+45(%9=0)

### 附上代码（应该是最短的了吧~~（除去头文件也不压行）~~）：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
int t;
long long l,r,p;
int main(){
	scanf("%d",&t);
	for(ri i=1;i<=t;i++){
		scanf("%lld%lld",&l,&r);
		p=0;
		for(register long long j=l;j<=l+(r-l)%9;j++)
			p+=j;
		printf("%lld\n",p%9);
	}
	return ~~(0-0);
}

```

---

## 作者：cs18 (赞：0)

一串数 mod 9 的余数为每一个数字的和 mod 9 的余数（此处不加证明）。而每一个数字的和 mod 9 又可以拼成 l~r 这些数 mod 9（相当于一个逆操作），发现一串连续的数 mod 9 的余数是循环的，又发现这一个循环为 0~8 这九个数，而这 9 个数的和是 9 的倍数，不妨把循环个数找出来，循环外的再单独算（不会超过 9 个），然后就很完美了。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll n,a,b,T,ans;

int main(){
    cin>>n;
    while(n--){
        cin>>a>>b;
        T=(b-a+1)/9,ans=0;//计算循环个数
        a+=9*T; 
        for(ll i=a;i<=b;i++)	ans+=i%9;
        cout<<ans%9<<"\n";
    }
} 
```

---

## 作者：Letriomphant7396 (赞：0)

这道题和2017noip提高组Day1T1有异曲同工之妙，都是有一定规律的。
首先，题意是给出一个L-R的连续区间，并将它们写在一起，变成一个数L（L+1）（L+2）...(R-1)R,之后输出这个数mod 9的值。易得，(L（L+1）（L+2）...(R-1)R)mod9的值即为(L+L+1+L+2+.....+R-1+R)mod9的值。所以计算(L+L+1+L+2+.....+R-1+R)就是这道题的核心。易得可以使用等差数列公式计算。~~你也可以用循环计算，但根据数据范围，结果显而易见~~。由此，便可以很容易的写出核心代码。
```cpp
int cal(int lr,int rr)
{
	return (lr+rr)*(rr-lr+1)/2;
}
for(int i=1;i<=n;i++)
{
	cin>>l>>r;
	ans=cal(l,r);
	if(ans%9==0)
	cout<<0<<endl;
	else
	cout<<ans%9<<'\n';
}
```
但是如果就这样提交的话，会发现只能得70分，~~我交了十几次QAQ~~，
好像是因为数据范围太大，在相乘时会爆掉，这时需要用__int128来定义（注意__int128在Dev上编译是通不过的。~~反正我的是没过，可能我太蒟蒻~~所以可以在洛谷编译器上编译），下面是修改过后的代码
```cpp
#include<bits/stdc++.h>
#define bll __int128
using namespace std;
bll l,r;
bll ans;
int n;
bll cal(bll lr,bll rr)
{
	return (lr+rr)*(rr-lr+1)/2;
}
void print(bll x){
    if(!x)	return;
    if(x)	print(x/10);
    putchar(x%10+'0');
}
int main()
{
	scanf(n);//防抄袭
	for(int i=1;i<=n;i++)
	{
		scanf(l),scanf(r);//防抄袭
		ans=cal(l,r);
		if(ans%9==0)
		cout<<0;
		else
		cout<<ans%9;
		printf("\n");
	}
}
```
普通的输出在__int128是不能用的，要另写个函数。输入可以输入long long，在计算时用__int128计算。
（好像有一个方法是可以避免使用__int128的，~~但我太蒟蒻了，不会~~，请向神佬cs18询问）

---


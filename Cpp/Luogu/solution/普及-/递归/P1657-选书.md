# 选书

## 题目描述

学校放寒假时，信息学奥赛辅导老师有 $1,2,3,\cdots,x$ 本书，要分给参加培训的 $x$ 个人，每人只能选一本书，但是每人有两本喜欢的书。

老师事先让每个人将自己喜欢的书填写在一张表上。然后根据他们填写的表来分配书本，希望设计一个程序帮助老师求出所有可能的分配方案，使每个学生都满意。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le x\le 20$。


$\text{update 2022/03/07}$，阮行止

本题原始数据中，最后一个数据点的 x 为 $0$，期望输出为  $0$。考虑到这个数据不合理，予以删去。现在提交这个题目不会遇到 $x=0$ 的数据点。




## 样例 #1

### 输入

```
5
1 3
4 5
2 5
1 4
3 5```

### 输出

```
2```

# 题解

## 作者：_xcc_ (赞：151)

主要思路就是产生书的全排列（用dfs，可优化），排除与喜欢列表不符合的方案。

```cpp
#include<iostream>
using namespace std;
int book[50],s,x;
bool flag[50],like[50][50];              //like[i][j]表示第i个人喜欢第j本书。
void so(int i)                           //dfs产生全排列
{
    int j;
    for(j=1;j<=x;j++)
    {
        if(flag[j]&&like[i][j]){         //此书未选且第i个人喜欢这本书
            flag[j]=0;
            book[i]=j;
            if(i==x) s++;
                else so(i+1);            //继续列举第i+1个人的书
            flag[j]=1;                   //还原与回溯
            book[i]=0;
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);         //加快cin、cout（装逼专用）
    cin>>x;
    int i,t1,t2;
    for(i=1;i<=x;i++)                    //读入喜欢列表
    {
        cin>>t1>>t2;
        like[i][t1]=true;
        like[i][t2]=true;
    }
    for(i=1;i<=x;i++)
    {
        flag[i]=true;                   //标记数组初始化
    }
    so(1);
    cout<<s;                            //输出总方案数
    return 0;
}
```

---

## 作者：_louhc (赞：85)

看了这么多题解，竟然没有状态压缩的，所以本蒟蒻来一发。  
这里解释一下状态压缩。  
把t当做2进制来看，它的第( i + 1 )位就表示第i本书有没有拿走。  
比如t = (11010)2表示第1 、 3 、 4本取过了。这里为了方便我不使用第一位  
判断时，只要把 t & ( 1 << 编号 ) 就行了，举个例子，t = (11010)2,要判断第3本，1 << 3 = (01000)2,(01000)2 & (11010)2，第4位都是1，所以是true。  
取书时，只要把&改成|就行了，请自己分析，这里不再赘述，具体请参照程序。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[25][2];
int ans;
void dfs( int s, int t ){
	if ( s > n ){
		if ( t == ( 1 << ( n + 1 ) ) - 2 )//以防万一
			ans++;
		return;
	}
	if ( ( ( 1 << a[s][0] ) & t ) == 0 )
		dfs( s + 1, ( 1 << a[s][0] ) | t );//简单的搜索
	if ( ( ( 1 << a[s][1] ) & t ) == 0 )
		dfs( s + 1, ( 1 << a[s][1] ) | t ); 
}

int main(){
	scanf( "%d", &n );
	for ( int i = 1; i <= n; ++i )
		scanf( "%d%d", &a[i][0], &a[i][1] );
	if ( n ) dfs( 1, 0 );//是0就不做了，数据太坑，有n = 0的情况，要特判。
	printf( "%d", ans );
	return 0;
}
```

状态压缩是一种很好的搜索辅助工具，可以减少时间和空间复杂度，很多较难搜索题都可以用到。当然，开数组也行，结果都是一样的，但我偏好于状态压缩。不过，这里事实上用数组会更快更方便，这里我只是从广义上来说的，状压的主要应用还是在记忆化搜索，这里权当做是状态压缩的练习吧。

---

## 作者：Baihua (赞：61)

这道题属于暴力搜索；变化在于一个人喜爱两本书；

根据数据范围（20）用深搜即可~~不会广搜~~

不考虑**x==0**的情况最后一个点过不了。~~然而无法理解分发0本书给0个人~~


以下代码~~忽略其中多余的大括号，本人强迫症晚期~~

------------

```cpp
 #include <iostream>
 using namespace std;
 const int maxn=21;//考虑数据规模 
 int a[maxn][2],t=0,vis[maxn],x;
 // 数组a存贮每个学生喜爱的书；a[i][j]表示学生i喜爱的第j本书；vis数组标记是否搜索过； 
 void dfs(int xx){
 	if(xx==x+1)t++;//如果搜索完成，增加方案数； 
 	else{
 	   for(int i=1;i<=x;i++){ //选择每一本书 
 	   	for(int j=0;j<=1;j++){ 
 	   		if((!vis[i])&&(a[xx][j]==i)){//如果这书i没有被选走，并且同学x喜爱这本书 
 	   			vis[i]=1;//标记书i； 
 	   			dfs(xx+1);//进行下一位同学的搜索 
 	   			vis[i]=0;//释放书i，便于继续搜索； 
 	   		}
 	   	}
 	   }
 	}
 }
 int  main(){
 	cin>>x; 
 	if(x){//有x==0这种毒瘤的情况；（无法理解将0本书分发给0位同学23333）
 	//当x!=0时使用常规的搜索思路； 
 	for(int i=1;i<=x;i++){
 	 	cin>>a[i][0]>>a[i][1];//读入每位同学喜爱的书的编号； 
 	 }
 	 dfs(1);
 	 cout<<t;//输出结果	
 	}
 	 else cout<<0;//如果人数为零则无法分发
return 0; 
 }
```
搜索题目本身思考价值较低，然而考验耐心和细节；

首个题解；如果~~肯定~~有错误**敬请指出，感激不尽**



---

## 作者：情到深处人孤独 (赞：31)

【题解】：

[color=blue]（以样例分析）[/color]

可用穷举法，先不考虑“每人都满意”这一条件，这样只剩[color=red]**“每人选一本且只能选一本”**[/color]这一条件。在这个条件下，可行解就是五本书的所有全排列，一共有5！=120种。然后[color=green]**在120种可行解中一一删去不符合“每人都满意”的解**[/color]，留下的就是本题的解答。

[color=brown]**这五个数的一种全排列就是五本书的一种分发。例如54321就表示第五本书分给5，第4本书分给4，…，第1本书分给1。“喜爱书表”可以用二维数组来表示，1表示喜爱，0表示不喜爱。**[/color]

算法设计：S1：产生5个数字的一种全排列；

S2：检查是否符合“喜爱书表”的条件，如果符合就解++；

S3：检查是否所有的排列都产生了，如果没有产生完，则返回S1；

S4：结束。

上述算法有可以改进的地方。比如产生了一个全排列12345，从表中可以看出，选第五本书即给1的书,5是不可能的，因为1只喜欢第1,3本书。这就是说5XXXX都是不符合题目的条件。由此想到，[color=purple]**如果选定第一本书后，就得立即检查一下是否符合条件，发现5是不符合的，后面四个数字就不必选了，这样就减少了运算量**[/color]。换句话说，第一个数只在1,3中选择，这样就可以减少3/5的运算量。同理，选定了第一个数字后，也不应该把其他4个数字一次选定，而是选择了第二个数字后，就立即检查是否符合条件，例如，[color=sorrel]**第一个数选1，第二个数选2后，立即检查，发现不符合条件，就应另选第二个数，这样就把12XXX一类的分法在产生前就删去了，又减少了一部分运算量**[/color]。

综上所述，改进后的算法应该是：[color=gold]**在排列产生时，每增加一个数，就检查该数是否符合条件，不符合，就立即换一个，符合条件后，再产生下一个数。因为从第i本书到第i+1本书的寻找过程是相同的，所以可以用回溯算法。**[/color]算法设计如下（伪代码）：

    ```delphi

    int search(i)
    {
        for (j=1;j<=5;j++)
            if (第i个同学分给第j本书符合条件)
               {
                记录第i个数
                if (i==n）解++；
                else search(i+1)；
                删去第i个数
               }
    }
    
```

---

## 作者：hsfzLZH1 (赞：19)

不理解为什么楼下的大佬都是用矩阵存储人和喜欢的书之间的关系，因为每个人都喜欢两本书，所以我们只需要存储两本书所代表的号码就可以了，而且访问的时候也可以直接降低到O(1)的时间复杂度而不是全部扫一遍的O(N)，总的时间复杂度也可以降低一个N项（尽管此题是指数时间复杂度）

我们只需要在dfs的过程中进行3种操作，判断是否所有人都选上了书，当前人选第一本喜欢的书，选第二本喜欢的书，选书的过程再次进行dfs，这里我们需要记录一个tf数组来判断当前这本书是否被选过，一定要留下足迹和擦除足迹。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=25;
int n,a[maxn][2],ans;
bool tf[maxn];
void dfs(int x)//x是当前正要选书的人的编号
{
    if(x==n+1){ans++;return;}//如果所有人都选完书了，下面的过程保证这是一个答案且没有重复
    if(!tf[a[x][0]])tf[a[x][0]]=true,dfs(x+1),tf[a[x][0]]=false;//如果第一本书没有被选过，选择第一本书，dfs
    if(!tf[a[x][1]])tf[a[x][1]]=true,dfs(x+1),tf[a[x][1]]=false;//同上，记得一定要实时更新tf数组的值
}
int main()
{
    scanf("%d",&n);
    if(n==0){printf("0\n");return 0;}//特判，本人拙见，0个人也应该是一种方案，总方案数2^0=1，不成立的方案数没有，所以应该是1种方案
    for(int i=1;i<=n;i++)scanf("%d%d",a[i],a[i]+1);//输入每个人喜欢的两本书
    dfs(1);//进行dfs过程
    printf("%d\n",ans);//输出最后的答案
    return 0;
}
```

---

## 作者：Hope2075 (赞：12)

这题用图论完全可以$O(n)$做

首先建图：对于每个人，将他喜欢的两本书的编号连一条无向边

这样就得到了一个$n$个节点$n$条边的图，而每一个合法方案就是为每一条边选择一个方向，使得每个点的入度为1

然后考虑答案如何计算

- 答案非0，当且仅当这个图的每个连通块内，点的数量和边的数量相同

证明：

（必要性）如果存在一个连通块，块内点的数量大于边的数量（可以看出，这个连通块只能是树），那么无论如何选择边的方向，总有至少一个点入度为0。

而如果存在一个连通块，块内边的数量大于点的数量，那么剩余部分点的数量大于边的数量，可以得出有至少存在一个连通块，块内点的数量大于边的数量

（充分性）可以看出，每个连通块都是一个环或基环树。

对于每个连通块，这样构造：将每个度为1的节点对应的边指向这个点，对剩余部分继续构造，这样最后只剩一个环，而这个环上只要都朝一个方向就行了

大致思路就是把叶子节点一个个撸下来，最后只剩一个环

- 答案非0时，如果这个图有$k$个连通块，那么答案就是$2^k$

由上面充分性的证明，处理不在环上的点时，只有唯一的一种构造方案，而处理环时，有两个方向，并且各个连通块独立。由乘法原理不难得出答案

然后就可以$O(n)$做了

关于出题人说的造数据难，大概就是因为没有发现这些特点吧QWQ

具体做法：

1. 先把$n=0$的情况特判掉（答案为0）

2. 建图，dfs一遍，记录每个点所属的连通块

3. 判断每个连通块内边数是否等于点数

4. 统计连通块数目，计算答案

其中第三步我是这样做的：计算连通块内点的度数之和，如果不满足度数之和是点个数之和的二倍，则答案为0。这应该很显然吧QWQ

最后放代码：

注：这里默认对998244353取模了，对于这个题的数据没问题

```
#include<cstdio>
long long read(){
	long long n=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
	return n;
}
const int N=300007;
#define next next2
int head[N],next[N*2],ver[N*2],tot;
int gid[N];
int deg[N];
int cnt[N],cdeg[N];
void add(int a,int b){
	deg[a]++;
	deg[b]++;
	tot++;
	ver[tot]=b;
	next[tot]=head[a];
	head[a]=tot;
	tot++;
	ver[tot]=a;
	next[tot]=head[b];
	head[b]=tot;
}

void dfs(int id,int p){
	gid[id]=p;
	for(int i=head[id];i;i=next[i]){
		if(gid[ver[i]])continue;
		dfs(ver[i],p); 
	}
}
int n,a,b;
long long ans=1;
int main(){
	n=read();
	if(n==0){
		printf("0\n");
		return 0;
	}
	for(int i=1;i<=n;i++){//建图
		a=read();
		b=read();
		add(a,b);
	}
	for(int i=1;i<=n;i++){//DFS求每个点所属的连通块编号
		if(!gid[i])dfs(i,i);
	}
	for(int i=1;i<=n;i++){//统计每个连通块内的信息
		cnt[gid[i]]++;
		cdeg[gid[i]]+=deg[i];
	}
	for(int i=1;i<=n;i++){
		if(cnt[i]*2!=cdeg[i]){//判断不合法情况
			printf("0\n");
			return 0;
		}
		if(cnt[i]!=0)ans=ans*2%998244353;//计算答案
        //注：这里cnt[i]=0表示这个编号没有被使用，也就是不算一个连通块
	}
	printf("%lld\n",ans);
}
```



---

## 作者：zhanghb (赞：11)

这道题我们可以直接用变形的深搜来完成

从第一个人开始分别判断每个人喜欢的第一本和第二本书是否被其他人取走，如果没有，就把这本书给这个人，继续判断下一个人

--------
AC代码：

```
#include<iostream>
using namespace std;
int a[100][2],x,cn=0;
bool b[1000]={0};
void dfs(int i)//深搜
{
	if(i>x)
	cn++;//如果所有人都拿到了自己喜欢的书，方案数就加一
	else for(int j=0;j<=1;j++)
		if(!b[a[i][j]])//分别判断每个人喜欢的第一本和第二本书是否被别人拿走，如果没有，就把这本书给这个人
			{
				b[a[i][j]]=1;//把这本书值为已拿过
				dfs(i+1);//拿到书人数加一
				b[a[i][j]]=0;//返回判断第二本
			}
}
int main()
{
	cin>>x;//输入人数
	if(x==0)//特判，测试点应该有这个坑
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<=x;i++)
	cin>>a[i][0]>>a[i][1];//输入每个人喜好的书
	dfs(1);
	cout<<cn;
}
```


---

## 作者：BFSBFSBFSBFS (赞：10)

~~观察他人提交记录可得.若n>0,答案是2^x.~~

我们应当通过规律来完成此题.(.....).

题意.有x个人.每人选1本书.且1定是自己喜欢的书.求每个人都拿到书的方案总数..

看样例看样例.

![](https://cdn.luogu.com.cn/upload/pic/14157.png).

第1行每个点表示书.第2行每个点表示人..

从左往右标号1-n.

以下.用**R1**表示第1个人.**B1**表示第1本书.类比1下..

红线代表其中1种方法.

我们知道.每个人都会有2本喜欢的书.那么2个人同时喜欢1本书的话.另1个人只能选另外1本书.

例子.上图中**R1**选了**B1**.同样喜欢**B1**的**R4**不得不选择**B4**.

那么可以看到.**B2**只有**R3**喜欢.这本书自然归他了...

我们去掉**B2**与**R3**再看看..

![](https://cdn.luogu.com.cn/upload/pic/14158.png).

可以发现.每个书都被2个人喜欢....

那么.另外1种方法也可以的...

![](https://cdn.luogu.com.cn/upload/pic/14159.png).

就是说.确定1个人之后.所有人的书全部确定了..

这时.每有1种这样的情况.对答案贡献2.

![](https://cdn.luogu.com.cn/upload/pic/14168.png).

据乘法原理.2*2=4.上图有4种情况.

结果..此题成了...**求联通块的数量**.....

**每有1个联通块.答案乘2**.

对于不合法情况判断...**在以正常顺序的情况下.**.**某人2本喜欢的书都被统计2次或以上.则这个人将会拿不到书..**.

~~(这个判断好假...有时间好好想想.)..~~

时间复杂度低至**O(n)**级别..

~~(n=0判断要加上啊..)..~~

Diu代码..
```
program P1657;
 type
  wa=record
   n,t:longint;
  end;
 var
  a:array[0..41] of wa;
  b,f,f1,h,x,y:array[0..21] of longint;
  i,n,p,ssum,upass:longint;
 procedure hahainc(x,y:longint); //边的存储..
  begin
   inc(p);
   a[p].n:=h[x];
   a[p].t:=y;
   h[x]:=p;
  end;
 procedure hahaBFS(k:longint); //BFS出所有有关联的书本.
  var
   i,j,o,p,t,s:longint;
  begin
   o:=0;
   p:=1;
   b[p]:=k;
   repeat
    inc(o);
    t:=b[o];
    j:=h[t];
    while a[j].n<>-1 do
     begin
      s:=a[j].t;
      if f1[s]=0 then
       begin
        f1[s]:=1;
        if (f[x[s]]=0) and (f[y[s]]=0) then ssum:=ssum<<1; //其实就是联通块统计..
        if (f[x[s]]>=2) and (f[y[s]]>=2) then upass:=1;  //假的.-
        inc(f[x[s]]);
        inc(f[y[s]]);
        if f[y[s]]=1 then
         begin
          inc(p);
          b[p]:=y[s];
         end;
       end;
      j:=a[j].n;
     end;
   until o=p;
  end;
 begin
  readln(n);
  filldword(f,sizeof(f)>>2,0);    //书本访问标记.
  filldword(f1,sizeof(f1)>>2,0);  //人访问标记.
  filldword(h,sizeof(h)>>2,0);
  ssum:=1; //统计系列.
  if n=0 then ssum:=0;
  upass:=0;
  p:=0;
  for i:=1 to n do
   begin
    readln(x[i],y[i]);
    hahainc(x[i],i);
    //hahainc(y[i],i);
   end;
  a[0].n:=-1;
  for i:=1 to n do
   if f[i]=0 then hahaBFS(i);
  if upass=1 then ssum:=upass-1;
  writeln(ssum);
 end.
```
(ಡωಡ).


---

## 作者：w2Tao (赞：6)

**这道题其实就是~~简单粗暴地~~直接DFS就行了**

**但其实——出题人狡猾着呢（后面说）**

**下面上代码**

```
#include <bits/stdc++.h> //万能头文件~
using namespace std;
int like[21][2],ans,used[21],x;
//like存储喜欢的书，ans是结果，used存储已经取过的书，x如题意
void dfs(int n)
{
	if(n==x+1) //递归终止条件
	{
		ans++;
		return;
	}
	if(!used[like[n][0]]) //两本喜欢的书中的一本
	{
		used[like[n][0]]=1; //表示这本书取过了
		dfs(n+1); 	    //下一个人
		used[like[n][0]]=0; //状态清零
	}
	if(!used[like[n][1]]) //同上
	{
		used[like[n][1]]=1;
		dfs(n+1);
		used[like[n][1]]=0;
	}	
}
int main()
{
	cin>>x;
	if(x==0)
	{
		cout<<0;
		return 0;
	}
	//这就是出题者最狡猾的地方——有一组测试数据x=0！这时直接DFS结果是2！WA！
	for(int i=1;i<=x;i++)
	{
		cin>>like[i][0]>>like[i][1];
	}
	dfs(1); //经典的DFS
	cout<<ans;
}
```

**OK!**

---

## 作者：Lolierl (赞：5)

```cpp
//闲来无事写了个二进制枚举。 
#include<iostream>
#include<cstring>
using namespace std;

int kasumi(int p,int q)
{
    if(q==0)return 1;
    int t=kasumi(p,q/2);
    if(q%2==0)return t\*t;else return t\*t\*p;
}//个人喜好快速幂，这里由于不是重点，就不介绍了，其实用pow问题也不大 
//至于函数名 快(ka)速(su)幂(mi)。。。 
int main()
{
    int n;
    cin>>n;
    if(n==0){cout<<0;return 0;}//注意这题的坑 n=0时要特判 
    const int y=kasumi(2,n)-1;//二进制最大子状态（11111···），数据范围较小无需高精 
    
    int a1[n+1],a2[n+1];
    for(int i=1;i<=n;i++)
        cin>>a1[i]>>a2[i];//存取每人 喜欢的书 
    
    int visited[n+1],s=0;
    for(int i=0;i<=y;i++)//枚举至二进制每一个子状态，第i位是1表示第i个人取第一本喜欢的图书，否则取第二本。 
    {
        memset(visited,0,sizeof(visited));//标记数组清零 
        int f=1;//f=1表示此状态可行（无两人选同一本书的情况），反之不可行。 
        for(int j=1;j<=n;j++)//枚举每一位 
        {
            bool k=i&kasumi(2,j);//位运算，kasumi(2,j)会（在二进制下）将第j位 置成1其他位都是0，再进行按位与，就会把i二进制第j位取出来 
            if(k)//k=1表示取第一本，k=0取第二本。 
                if(visited[a1[j]])//如果用过就退出 
                    {f=0;break;}
                else 
                    visited[a1[j]]=1;//打标记 
            else 
                if(visited[a2[j]])
                    {f=0;break;}
                else
                    visited[a2[j]]=1;
        }
        if(f)s++;//可行就计数器++ 
    }
    cout<<s;//输出 
    return 0;
}

---

## 作者：hmh13951417981 (赞：2)

## 规则：让一个人从两本里面选一本，且那一本没被选过


------------

```c
#include<bits/stdc++.h>
using namespace std;
int x,a[21][3],total;//a数组表示每个人喜欢的书
bool b[21];//b数组表示是否选过
void dfs(int k){
	if(k==x+1){
		total++; return;//如果都选过去了，就符合要求，累加
	}
	for(int i=1;i<=2;i++){
		if(!b[a[k][i]])//要是可以选
		{b[a[k][i]]=1; //选这本
		dfs(k+1);	  //让下一个人继续选
		b[a[k][i]]=0;  //回溯，把这本放回去
		}
	}
}
int main()
{	cin>>x;
	for(int i=1;i<=x;i++)
	cin>>a[i][1]>>a[i][2];//输入
	if(x==0) cout<<0;     //特判，如果没有人就直接输出0
	else{
	dfs(1);     //深搜
	cout<<total;//输出
    }
	return 0;
} 
```

---

## 作者：孙广宸 (赞：2)


简单搜索板子题，具体内容看代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int love[10001][2],tot=0;
int n;
int flag[10001]={false};
void dfs(int num)
{
	if(num==n+1)//超过n就代表搜完了
	{
		tot++;
		return;
	}
	if(!flag[love[num][0]])//case1
	{
		flag[love[num][0]]=true;
		dfs(num+1);
		flag[love[num][0]]=false;
	}
	if(!flag[love[num][1]])//case2
	{
		flag[love[num][1]]=true;
		dfs(num+1);
		flag[love[num][1]]=false;
	}
    //千万别忘记回溯哦QAQ
}
int main()
{
	cin>>n;
	if(n==0)
	{
		cout<<0;
		return 0;
	}//这个特判可以说是特别的恶心qwq
	for(int i=1;i<=n;i++)
		cin>>love[i][0]>>love[i][1];
	dfs(1);
	cout<<tot;
	return 0;
}
```



---

## 作者：_ljx_ (赞：1)

C++（递归搜索）

```cpp
#include<iostream>
using namespace std;// 废话不多说，进入正解
int sum=0,n;// 定义两个整型，一个储存次数，一个表示有几本书
int a[21];// 储存满足条件的书
bool b[100][100],g[100];// 一个记录喜欢的书，一个避免重复
int ll(int t)// 搜索
{
    int i,j,l;
    for(j=1;j<=n;j++)
    {
        if(b[t][j] && !g[j])// 满足条件的书
        {
            g[j]=1;// 避免重复
            a[t]=j;// 记录书（其实这是多余的）
            if(t==n) sum++;// 以完成了一种，sum累加
            else ll(t+1);// 否则，t+1，继续递归，向下走
            g[j]=0;    // 回溯：把选书的放回，产生其他的方案
            a[t]=0;  // 同上
        }
    }
}
int main()// 主函数：输入
{
    int i,l,j;
    cin>>n;// 输入几本书    
    for(i=1;i<=n;i++)
    {
        cin>>l>>j;
        b[i][l]=1;// 都是记录每人喜欢的书，将其赋值为1
        b[i][j]=1;
    }                
    ll(1);// 进入递归
    cout<<sum;// 哈哈，输出
    return 0;结束 ，功德圆满！！！
}
```

---

## 作者：_YRH_ (赞：1)

简单的递归题目~废话不说，直接看代码

```cpp
#include<stdio.h>
#include<stdlib.h>
int i,j,k,m,n,x,y,sum,book[21];
bool flag[21],like[21][21];

int search(int z){//开始递归 
    int j;
    for(j=1;j<=n;j++)
        if(flag[j] && like[z][j]){//如果满足分书的条件即可开始 
            flag[j]=0;//吧被选中的书放入flag中，避免重复 
            book[z]=j;//保存第z个人选中的书j 
            if(z==n)//如果等于n，则每个人都分书了，累加sum 
                sum++;
            else 
                search(z+1);//否则继续递归 
            flag[j]=1;//回溯：把已经选中的书放回，产生其他的分书方案 
            book[z]=0;
        }
}

int main(){
    scanf("%d",&n);//读入 
    for(i=1;i<=n;i++){
        scanf("%d%d",&x,&y);//将每人喜爱的书存入like数组中 
        like[i][x]=1;
        like[i][y]=1;
        flag[i]=1;
    }
    search(1);//开始查找，从第一个书开始 
    printf("%d",sum);//输出sum即可~ 
    return 0;
}
```

---

## 作者：cy汀 (赞：1)

### P1657 题解
  这道题要求m本书分配给m个人，然后数据范围~~太水了~~（n<=20）。所以索性开始暴力dfs。
```cpp
#include<bits/stdc++.h>
using namespace std;
int flag=0;
bool ans[21]={false};
int x,a1[21],a2[21];//记录喜欢哪几本书 
void dfs(int m)//表示选到第m本书，第m本没选 
{
	if(m>x)//选完了 
	{
		flag++;//方案 
		return;
	}
	for(int i=1;i<=x;i++)//枚举第m个人需要的 
	{
		if(ans[i]==false && (a1[m]==i || a2[m]==i))//如果可以且没被选 
		{
			ans[i]=true;//标记 
			dfs(m+1);
			ans[i]=false;//回溯 
		}
	 } 
}
int main()
{
	cin>>x;
	if(x==0)//数据坑的特判 
	{
		cout<<0;
		return 0; 
	}
	for(int i=1;i<=x;i++)
    {
    	cin>>a1[i]>>a2[i];
	}
	dfs(1);
	cout<<flag;
	return 0;
}

```


---

## 作者：Komorebi_shine (赞：1)

用回溯的解法，另外加一个函数判断是否重复。当i=n时，t+1，最后输出t。

***需要加对0的判断（别问我为什么！），如果是0，直接跳出。***

```cpp
var
 i,t,n:longint;
 b:array[1..20,1..2]of integer;
 c:array[1..20]of integer;
function pd(i:integer):boolean;
 var
  j:integer;
 begin
  pd:=true;
  for j:=1 to i-1 do
   pd:=pd and (c[j]<>c[i]);
 end;
procedure try(i:integer);
 begin
  if i=n+1 then begin inc(t);exit;end;
  c[i]:=b[i,1];
  if pd(i) then try(i+1);
  c[i]:=b[i,2];
  if pd(i) then try(i+1);
  c[i]:=0;
 end;
begin
 readln(n);
 if n=0 then begin writeln(0);exit;end;
 t:=0;
 for i:=1 to n do
  readln(b[i,1],b[i,2]);
 fillchar(c,sizeof(c),0);
 try(1);
 writeln(t);
end.

```

---

## 作者：Creeper_LKF (赞：1)

###二进制解法

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,love[2][21],ans;
bool used[21];//位运算版
inline int read(){//读入优化超空间压行版
    int num=0;
    char c;
    while(isspace(c=getchar()));
    while((num=num*10+c-48)&&isdigit(c=getchar()));
    return num;
}
inline bool query(int tar){
    memset(used,false,sizeof(used));//初始化没选书
    for(int i=1;i<=x;i++,tar>>=1)//枚举每一个人选的每一本书，tar&1==0代表选第一本，tar&1==1代表选第二本
        if(used[love[tar&1][i]]) return false;//如果该书被选过则方案错误
        else used[love[tar&1][i]]=true;//如果该书没被选过则标记该书
    return true;//所有人选的书都没有重合
}
int main(){
    if(!(x=read())){//特判+压行
        printf("0");
        return 0;
    }
    for(int i=1;i<=x;i++) love[0][i]=read(),love[1][i]=read();
    int max_x=(1<<x);//在不开O2的情况下节约时间，下一行当i++时便可枚举下一种情况
    for(int i=0;i<max_x;i++) if(query(i)) ans++;//如果要按字典序输出的话，可枚举格雷码，如果方案正确则计数器++
    printf("%d",ans);
    return 0;
}
```

---

## 作者：yangshirui (赞：1)

【算法分析】

可用穷举法，先不考虑“每人都满意” 这一条件，这样只剩“每人选一本且只能选一本”这一条件。在这个条件下，可行解就是五本书的所有全排列，一共有5！=120种。然后在120种可行解中一一删去不符合“每人都满意”的解，留下的就是本题的解答。

为了编程方便，设1，2，3，4，5分别表示这五本书。这五个数的一种全排列就是五本书的一种分发。例如54321就表示第5本书（即E）分给张，第4本书（即D）分给王，……，第1本书（即A）分给李。“喜爱书表”可以用二维数组来表示，1表示喜爱，0表示不喜爱。

算法设计：S1：产生5个数字的一个全排列；

S2：检查是否符合“喜爱书表”的条件，如果符合就打印出来；

S3：检查是否所有的排列都产生了，如果没有产生完，则返回S1；

S4：结束。

上述算法有可以改进的地方。比如产生了一个全排列12345，从表中可以看出，选第一本书即给张同学的书，1是不可能的，因为张只喜欢第3、4本书。这就是说，1××××一类的分法都不符合条件。由此想到，如果选定第一本书后，就立即检查一下是否符合条件，发现1是不符合的，后面的四个数字就不必选了，这样就减少了运算量。换句话说，第一个数字只在3、4中选择，这样就可以减少3/5的运算量。同理，选定了第一个数字后，也不应该把其他4个数字一次选定，而是选择了第二个数字后，就立即检查是否符合条件。例如，第一个数选3，第二个数选4后，立即检查，发现不符合条件，就应另选第二个数。这样就把34×××一类的分法在产生前就删去了。又减少了一部分运算量。

       
【参考程序】



```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
using  namespace std;
int  book[6],c;
bool flag[6],like[6][6]={{0,0,0,0,0,0},{0,0,0,1,1,0},{0,1,1,0,0,1},
                                    {0,0,1,1,0,0},{0,0,0,0,1,0},{0,0,1,0,0,1}};;
int  search(int);
int  print();
int  main()
{
  for (int i=1;i<=5;i++) flag[i]=1;
  search(1);                                    //从第1个开始选书，递归。
} 
int search(int i)                              //递归函数 
{
  for (int j=1;j<=5; j++)                   //每个人都有5本书可选
  if (flag[j]&&like[i][j])                      //满足分书的条件
  {
    flag[j]=0;                                    //把被选中的书放入集合flag中，避免重复被选
    book[i]=j;                                   //保存第i个人选中的第j本书
    if (i==5) print();                          //i=5时，所有的人都分到书，输出结果
       else search(i+1);                    //i<5时，继续递归分书
    flag[j]=1;                                    //回溯：把选中的书放回，产生其他分书的方案
    book[i]=0;
  }
}  
int print()
{
  c++;                                                                //方案数累加1
  cout <<"answer " <<c <<":\n";  
  for (int i=1;i<=5;i++)
    cout <<i <<": " <<char(64+book[i]) <<endl;  //输出分书的方案
}
```
输出结果：
zhang: C

wang: A

liu: B
sun: D
li: E


---

## 作者：currycodingg (赞：0)

这道题其实和全排列是有共同之处的。

我们这么考虑n的全排列：有n个盒子，对于每个盒子从1-n中选一个数放进去，并且和之前盒子里面的数不能重复，那么从第一个盒子到第n个盒子里面的数便是一个排列。

而这道题与全排列相比，唯一的不同是：每个盒子里面不能随便从1-n里面选数放进去，而是要看对于这个盒子（人），ta喜欢的是哪两本书，再从中挑一个放进去。

因此，只要我们熟悉回溯法，并且能够熟练打出全排列的代码，这道题还是比较easy的~
```
#include<cstdio> 
#include<iostream>
using namespace std;
int n,b[22][3],d[22];//d[i]表示第i本书有没有没占用
long long ans;

void dfs(int book,int x,int y){
	if(d[book]==1) return ;
	
	if(x==n){
		ans++;
		return ;
	}
	
	d[book]=1;
	if(y==1) dfs(b[x+1][y],x+1,y),dfs(b[x+1][y+1],x+1,y+1);
	if(y==2) dfs(b[x+1][y-1],x+1,y-1),dfs(b[x+1][y],x+1,y);
	d[book]=0;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",&b[i][1],&b[i][2]);
	dfs(b[1][1],1,1);//第一人的第一本书 
	dfs(b[1][2],1,2);//第一人的第二本书 
	printf("%d\n",ans);
	return 0;
}
```


---


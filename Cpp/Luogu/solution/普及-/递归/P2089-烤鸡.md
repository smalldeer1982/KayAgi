# 烤鸡

## 题目背景

猪猪 Hanke 得到了一只鸡。


## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 说明/提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 样例 #1

### 输入

```
11```

### 输出

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 ```

# 题解

## 作者：yyy2015c01 (赞：1910)

正解是搜索，歪解是枚举。

```cpp

#include<iostream>  
using namespace std;  
int main()  
{  
    int a,b,c,d,e,f,g,h,i,j,in,x=0;  
    cin>>in;  
    for (a=1;a<=3;a++)  
    {  
        for (b=1;b<=3;b++)  
        {  
            for (c=1;c<=3;c++)  
            {  
                for (d=1;d<=3;d++)  
                {  
                    for (e=1;e<=3;e++)  
                    {  
                        for (f=1;f<=3;f++)  
                        {  
                            for (g=1;g<=3;g++)  
                            {  
                                for(h=1;h<=3;h++)  
                                {  
                                    for (i=1;i<=3;i++)  
                                    {  
                                        for (j=1;j<=3;j++)  
                                        {  
                                            if (a+b+c+d+e+f+g+h+i+j==in)  
                                            {  
                                                x++;  
                                            }  
                                        }  
                                    }  
                                }  
                            }  
                        }  
                    }  
                }  
            }  
        }  
    }  
    cout<<x<<endl;  
    for (a=1;a<=3;a++)  
    {  
        for (b=1;b<=3;b++)  
        {  
            for (c=1;c<=3;c++)  
            {  
                for (d=1;d<=3;d++)  
                {  
                    for (e=1;e<=3;e++)  
                    {  
                        for (f=1;f<=3;f++)  
                        {  
                            for (g=1;g<=3;g++)  
                            {  
                                for(h=1;h<=3;h++)  
                                {  
                                    for (i=1;i<=3;i++)  
                                    {  
                                        for (j=1;j<=3;j++)  
                                        {  
                                            if (a+b+c+d+e+f+g+h+i+j==in)  
                                            {  
                                                cout<<a<<" ";  
                                                cout<<b<<" ";  
                                                cout<<c<<" ";  
                                                cout<<d<<" ";  
                                                cout<<e<<" ";  
                                                cout<<f<<" ";  
                                                cout<<g<<" ";  
                                                cout<<h<<" ";  
                                                cout<<i<<" ";  
                                                cout<<j<<endl;  
                                            }  
                                        }  
                                    }  
                                }  
                            }  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
//so beautiful!

```

---

## 作者：万枪先生 (赞：866)


```cpp
//来个短短的递归~~(估计没人看...)
#include<iostream>
using namespace std;
int n,kind=0,m1[10000][10],m2[10];
void peiliao(int total,int a){
    if (a==10){
        if (total==n) {
            for (int j=0;j<10;j++) m1[kind][j]=m2[j];//符合要求存起来~~ 
            kind++;
        }
    }
    else if (total>=n) ;//小小优化一下 
    else
      for (int i=1;i<=3;i++){
          m2[a]=i;
          peiliao(total+i,a+1);//其实这和十连for没什么区别。。。 
      }
}
int main(){
    cin>>n;
    peiliao(0,0);
    cout<<kind<<endl;
    for (int j=0;j<kind;j++){
      for (int i=0;i<10;i++) cout<<m1[j][i]<<" "; //大家一定要记得打空格... 
     cout<<endl; 
    }
    return 0;
}
```

---

## 作者：氢氧化铯CsOH (赞：337)

#P2089题解

如果这道题是输出所有方案，再输出方案数，那么这道题将变得很容易。

但是，这要先输出方案数，再输出答案，因此需要考虑怎样将其存起来。

##做法

方法很简单，就是深搜、枚举，甚至连剪枝都可以不用。这道题的奥妙在于输出。

##怎样将方案存起来

我们的方法是，将这个东西输出到字符串中。

###sprintf函数

sprintf函数的作用是将数据输出到字符串中，用法大概如下：

```cpp
#include <cstdio>
int main(){
    char buf[100];
    int a, b;
    scanf("%d%d", &a, &b);
    sprintf(buf, "%d", a + b);
    puts(buf);
    return 0;
}
```
直接交上去可以通过P1001 A+B Problem

如果对同一字符串多次使用sprintf，会怎样呢？

```cpp
#include <cstdio>
int main(){
    char buf[100];
    int a, b;
    scanf("%d%d", &a, &b);
    sprintf(buf, "%d", a + b);
    sprintf(buf, "%d", a + b);
    puts(buf);
    return 0;
}
```
交上去也能过A+B。这说明，sprintf会覆盖原字符串。

如何往字符串末尾输出字符串？我们有另外的方法。

假如说一个字符串s存储了"Hello, world"，其结构将会如下：

```cpp
s[0] = 'H';
s[1] = 'e';
s[2] = 'l';
s[3] = 'l';
s[4] = 'o';
s[5] = ',';
s[6] = ' ';
s[7] = 'w';
s[8] = 'o';
s[9] = 'r';
s[10]= 'l';
s[11]= 'd';
s[12]= '!';
s[13]= '\0';
s[14]= '"未定义"'
s[15]= '"未定义"'
s[16]= '"未定义"'
// 省略一堆……
```
我们只要找到字符串的末尾（也就是'\0'），将字符串末尾看成一个字符串的开头，然后sprintf进去，就可以往字符串末尾添加字符串了。

因此，我们的方法是，找到'\0'的位置，将它视为字符串的开头，然后用sprintf输出到旧的'\0'开始的位置，取代'\0'及之后的位置。

比如：

```cpp
int main(){
    char c[100] = "abc";
    sprintf(c + 3, "defgh%s%s", "ijklmnopqrst", "uvwxyz");
    puts(c);
}
```
在上面的例子中，c + 3是'\0'的位置（因为strlen("abc") == 3，而strlen恰好是'\0'的下标），这样可以实现在末尾添加字符串的功能。

###方案1：strlen函数

strlen可以直接找到'\0'的下标。由此，我们有第一代的程序：

```cpp
#include<cctype>
#include<cstdio>
#include<cstring>
using namespace std;

const int maxn = 13;

char ans[1000000 + 5];
char *anscur = ans;
int nums[maxn];                    // 当前调料 
int cnt = 0;                    // 方案数 

void printans(){
    for(int i = 0; i < 10; i++){
        sprintf(ans + strlen(ans), "%d ", nums[i]);
    }
    sprintf(ans + strlen(ans), "\n");
}

void dfs(int cur, int left){    // 深搜过程 
    if(cur == 10 && !left){        // 已经搜到第10层，这个时候调料恰好加完 
        cnt++;                    // 方案数+1 
        printans();                // 将方案输出到字符串里面 
        return;
    } 
    int &i = nums[cur];            // 声明别名（引用） 
    for(i = 1; i <= 3; i++){
        if((10 - cur - 1) * 3 + i < left) continue;    // 剪枝。如果剩下的调料都加3克都不够，说明不可能 
        if((10 - cur - 1) + i > left) break;        // 剪枝。如果剩下的调料都加一克也超量，说明不可能 
        dfs(cur + 1, left - i); 
    }
}

int main(){
    int n;
    scanf("%d", &n);
    
    if(10 <= n && n <= 30) dfs(0, n);// 如果n不在[10, 30]范围内，说明不可能有解，跳过搜索 
    printf("%d\n%s", cnt, ans);        //输出答案 
}
```
交上去提示AC，最高时间263ms。

###方案2：使用stringstream

stringstream在高手眼里看来，是没什么用的。它非常灵活，但效率低下。我们来看看它的效率如何。

```cpp
#include<cctype>
#include<cstdio>
#include<cstring>
#include<string>
#include<sstream>
using namespace std;

const int maxn = 13;

ostringstream ans;
int nums[maxn];                    // 当前调料 
int cnt = 0;                    // 方案数 

void printans(){
    for(int i = 0; i < 10; i++){
        ans << nums[i] << " ";
    }
    ans << endl;
}

void dfs(int cur, int left){    // 深搜过程 
    if(cur == 10 && !left){        // 已经搜到第10层，这个时候调料恰好加完 
        cnt++;                    // 方案数+1 
        printans();                // 将方案输出到字符串里面 
        return;
    } 
    int &i = nums[cur];            // 声明别名（引用） 
    for(i = 1; i <= 3; i++){
        if((10 - cur - 1) * 3 + i < left) continue;    // 剪枝。如果剩下的调料都加3克都不够，说明不可能 
        if((10 - cur - 1) + i > left) break;        // 剪枝。如果剩下的调料都加一克也超量，说明不可能 
        dfs(cur + 1, left - i); 
    }
}


#include<iostream>

int main(){
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    
    if(10 <= n && n <= 30) dfs(0, n);// 如果n不在[10, 30]范围内，说明不可能有解，跳过搜索          
    cout << cnt << endl << ans.str();// 输出答案
}
```
遗憾的是，结果是RE，我也不知道为什么。

###方案3：直接计算新的'\0'位置

strlen虽然已经过了这道题，但是还是有优化的余地。如果能直接计算'\0'的位置，那么就可以节省时间。

我们考虑使用指针，该指针指向ans字符串的'\0'位置。

int版
```cpp

#include<cctype>
#include<cstdio>
#include<cstring>
using namespace std;

const int maxn = 13;

char ans[1000000 + 5];
int anscur = 0;
int nums[maxn];                    // 当前调料 
int cnt = 0;                    // 方案数 

void printans(){
    for(int i = 0; i < 10; i++){
        sprintf(ans + strlen(ans), "%d ", nums[i]);
        anscur += strlen(ans + anscur);
    }
    sprintf(ans + strlen(ans), "\n");
    anscur += strlen(ans + anscur);
}

// 省略了
```

char\* 版

```cpp
#include<cctype>
#include<cstdio>
#include<cstring>
using namespace std;

const int maxn = 13;

char ans[1000000 + 5];
char *anscur = ans;
int nums[maxn];                    // 当前调料 
int cnt = 0;                    // 方案数 

void printans(){
    for(int i = 0; i < 10; i++){
        sprintf(ans + strlen(ans), "%d ", nums[i]);
        anscur += strlen(anscur);
    }
    sprintf(ans + strlen(ans), "\n");
    anscur += strlen(anscur);
}
```
这样就可以更快了。

###方案4：printf中的%n控制符

上述的方法还是要再进行一次计算才能知道当前的指针。能否在sprintf的同时计算出新的指针呢？这是可能的。

printf家族中，有一个控制符%n——这个东西非常有用，意思是我到底输出了多少个字符。怎么用呢？

```cpp
char s[100];
int cnt;
sprintf(s, "abcdefg%n", &cnt);
```
一共输出了7个字符，此时cnt存储了7。

最终版的程序如下：

```cpp
#include<cctype>
#include<cstdio>

using namespace std;

const int maxn = 13;

char ans[1000000 + 5];
char *anscur = ans;
int nums[maxn];                    // 当前调料 
int cnt = 0;                    // 方案数 

void printans(){
    int offset;
    for(int i = 0; i < 10; i++){
        sprintf(anscur, "%d %n", nums[i], &offset);
        anscur += offset;
    }
    sprintf(anscur, "\n%n", &offset);
    anscur += offset;
}

void dfs(int cur, int left){    // 深搜过程 
    if(cur == 10 && !left){        // 已经搜到第10层，这个时候调料恰好加完 
        cnt++;                    // 方案数+1 
        printans();                // 将方案输出到字符串里面 
        return;
    } 
    int &i = nums[cur];            // 声明别名（引用） 
    for(i = 1; i <= 3; i++){
        if((10 - cur - 1) * 3 + i < left) continue;    // 剪枝。如果剩下的调料都加3克都不够，说明不可能 
        if((10 - cur - 1) + i > left) break;        // 剪枝。如果剩下的调料都加一克也超量，说明不可能 
        dfs(cur + 1, left - i); 
    }
}



int main(){
    int n;
    scanf("%d", &n);
    
    if(10 <= n && n <= 30) dfs(0, n);// 如果n不在[10, 30]范围内，说明不可能有解，跳过搜索 
    printf("%d\n%s", cnt, ans);        //输出答案 
}

```
最终用时34ms，最长一个点10ms，快了差不多几十倍。


---

## 作者：woshiren (赞：147)

回溯AC，方法具体请看代码，代码有注释

```cpp

#include<iostream>
#include<cstdio>
using namespace std;
int n,ans1,ans2[10001][11],sum,a[11];
void trys(int t,int m)//t代表当前的尝试的调料。m代表当前美味程度
{
    if (t>10) 
    {
        if (m==n) //如果美味程度与猪猪的要求相等 
        {
            ans1++;//统计方案总数 
            for (int i=1;i<=10;i++)
            ans2[ans1][i]=a[i];//存入答案的数组 
        }
        return ;
    }
    for (int i=1;i<=3;i++)
    {
        if (m+i>n) break;//如果超过了要求，那么后面的就可以直接忽略 
        a[t]=i;//储存答案 
        trys(t+1,m+i);//查看下一种调料 
        a[t]=0;//状态恢复 
    }
}
int main()
{
    cin>>n;
    trys(1,0);//从第一种调料开始尝试，美味程度为0 
    cout<<ans1<<endl;
    for (int i=1;i<=ans1;i++)
    {
        for (int j=1;j<=10;j++)
            cout<<ans2[i][j]<<" ";
        cout<<endl;
    }//输出结果 
    return 0;
} 

```

---

## 作者：Jelly_Goat (赞：69)

看到这个题一共也就pow(3,10)=**59049**次循环，那不就暴力了嘛！  
虽然说正解是**动归和搜索**，  
~~但是搜索和暴力枚举的差距真心不大(不好好学习qwq)~~。  
看到楼上又说到  
# 答案需要数据存储的问题，  
这里提供一种借助**STL的queue(队列)来进行存储**的方法。  
## 这个方法难度几乎为0，每个新手都可以学习！

------------

### 原理：队列的先入先出原则  
操作：
队列名.push(变量名)  
将变量压入队列  
队列名.front()  
返回队列头部元素  
队列名.pop()  
弹出队列头部元素  

以下是例子：  
假设Farmer John想让你对输入的数据进行分类（ABCD类）存储，  
并且把指定的类型（A型）的数据全部**按照输入的顺序输出来**。  
给一个数据总数，再一个个把数据给你。(假设同一类型的数据最多8个)  
```cpp
输入样例：         输出样例:
6                 21 -12 102
A 21
A -12
A 102
B 134011
D 2147483647
C 2147483647
```
于是样例程序就是：
```cpp
#include <queue>
//以上是队列必须要加上的头文件
#include <cstdio>
using namespace std;
queue<int>qwq[4];
//<你要使用的类型>随便一个合法的名字
//队列是数据类型，可以作为数组使用！
int main()
{
	int n,input;
    char ch;
    cin>>n;
    for (int i=1;i<=n;i++)
    	cin>>ch>>input;
        qwq[ch-'A'].push(input);
        //操作：将数据压入队列
    while (!qwq[0].empty())
    	cout<<qwq.front();qwq.pop();
        //操作：输出队列最先输入的第一个元素，然后弹出它
    //直到qwq[0]内没有元素
    return 0;
}
```
用队列的好处就是如果没有元素输入，那就没有输出，不浪费内存。  
这种情况(巨毒瘤)在我学校老师出的题里面有...  
Python 3的列表也可以用类似这个方法的方法来存储数据，~~但是方便许多~~。  
假的，因为弹出头部元素**其他都得跟着一块动**，伤不起。

------------

回归正题。  
### 既然要减少循环次数，那么就可以使用它。  
### 但仍有最坏的情况(n=20)出现。
那么最坏情况需要输出多少次呢？  
答案：8953  
~~太好了！尽情使用吧！管他呢!这种情况之下队列优化也没有办法！~~  
(Mode:c++)Code:
```cpp
#include <iostream>
#include <cstdio>
#include <queue>

using namespace std;
struct peiliao{//自定义类型peiliao作为队列的元素
    int a,b,c,d,e,f,g,h,i,j;
};
queue<peiliao>qwq;//存储容器在这里！！！！！！！

int main()
{
    int a,b,c,d,e,f,g,h,i,j,n;
    peiliao kaoji;//暂时性质的变量peiliao元素
    scanf("%d",&n);
    if (n<10||n>30)
    {//如果小于10或者是大于30，肯定做不出要求的烤鸡
        putchar('0');return 0;
    }
    for (a=1;a<=3;a++)
        for (b=1;b<=3;b++)
            for (c=1;c<=3;c++)
                for (d=1;d<=3;d++)
                    for (e=1;e<=3;e++)
                        for (f=1;f<=3;f++)
                            for (g=1;g<=3;g++)
                                for (h=1;h<=3;h++)
                                    for (i=1;i<=3;i++)
                                        for (j=1;j<=3;j++)
                                            if (a+b+c+d+e+f+g+h+i+j==n)
                                            {
                                            	kaoji=(peiliao){a,b,c,d,e,f,g,h,i,j};
                                                qwq.push(kaoji);//压入在这里！！！！！！！
                                            }
    if (qwq.empty())
    {
        putchar('0');
    }
    else
    {
        printf("%d\n",qwq.size());
        while (!qwq.empty())
        {//输出在这里！！！！！！！！
            kaoji=qwq.front();
            qwq.pop();
            cout<<kaoji.a<<' '<<kaoji.b<<' '<<kaoji.c;
            cout<<' '<<kaoji.d<<' '<<kaoji.e<<' '<<kaoji.f;
            cout<<' '<<kaoji.g<<' '<<kaoji.h<<' '<<kaoji.i;
            cout<<' '<<kaoji.j<<endl;
        }
    }
    return 0;
}
```
**Upd:2019/2/17**
原先的压进队列的操作被我旁边的学弟吐槽说要优化，然后我就进行了优化。  
原先我们把`kaoji`·一个个赋的值，现在我们新建一个`peiliao`类型的变量赋值给`paoji`然后再压进去。  
还可以更简洁（直接压），但是这样~~自感好看~~qwq。  
(Mode:Python 3)Code:  
(原先的代码还是放在这里，后面有升级版)  
因为从列表头部弹出元素十分耗时，所以放弃它。  
弹出这些元素要花的次数在最坏的情况下最少是8953的阶乘。WTF？！  
所以放弃吧，这样会TLE！但是我们的数据范围不足以让我们MLE。  
经测试，另一种存储诞生了。现在下面不止是两层循环的暴力代码！
```python
#AC代码1
n=int(input())
count=0
L=[1,2,3]
for a in L:
    for b in L:
        for c in L:
            for d in L:
                for e in L:
                    for f in L:
                        for g in L:
                            for h in L:
                                for i in L:
                                    for j in L:
                                        if a+b+c+d+e+f+g+h+i+j is n:
                                            count=count+1
if count<1:
    print("0")
else:
    print(count)
    for a in L:
        for b in L:
            for c in L:
                for d in L:
                    for e in L:
                        for f in L:
                            for g in L:
                                for h in L:
                                    for i in L:
                                        for j in L:
                                            if a+b+c+d+e+f+g+h+i+j is n:
                                                print(a,b,c,d,e,f,g,h,i,j)
```
因为不足以MLE，所以用list存储还算可以的，并且代码压缩至21行。  
至少不用再次10层循环了耶！
```python
#AC代码2
n=int(input())
L=[1,2,3]#省代码用的
L2=list([])
#用来当队列，但是不弹出元素的列表
for a in L:
 for b in L:
  for c in L:
   for d in L:
    for e in L:
     for f in L:
      for g in L:
       for h in L:
        for i in L:
         for j in L:
          if a+b+c+d+e+f+g+h+i+j is n:
           L2.append([a,b,c,d,e,f,g,h,i,j])
		   #压入列表
print(len(L2))#列表长度即统计的个数
for x in range(len(L2)):
  #逐个输出
  print(L2[x][0],L2[x][1],L2[x][2],L2[x][3],L2[x][4],L2[x][5],L2[x][6],L2[x][7],L2[x][8],L2[x][9])
```
~~重新探索，小金羊测试，AC！~~ 果然比原先省下不少时间。

------------

## 尾声。  
望大家多多使用队列这个容器做一些类似的需要存储数据的问题。  
类似的问题：营养膳食(优先队列可解)  
不足求指正！小金羊(是个蒟蒻)尽力学习！  
（本题解已更新！界面优化+新代码优化）  
（实在是累趴下了，求个过吧！）

---

## 作者：wdcxz (赞：49)

 # 这题直接用循环嵌套就可以了
 这题的基本思路就是两个循环嵌套就可以AC了，但我怕超时，只好用一个循环，详情在代码中解释，直接上代码
```cpp
#include <iostream>
using namespace std;
int m[100000000];
int main(){
    int n,a,b,c,d,e,f,g,h,i,j,k=0,l=1;//a,b,c,d,e,f,g,h,i,j就是十种调料，k统计方案个数，l是每个方案中的每一个调料质量
    cin>>n;//输入调料总质量
    for(a=1;a<=3;a++)
       for(b=1;b<=3;b++)
  		  for(c=1;c<=3;c++)
  		     for(d=1;d<=3;d++)
       			for(e=1;e<=3;e++)
  		  			for(f=1;f<=3;f++)
  		  				for(g=1;g<=3;g++)
       						for(h=1;h<=3;h++)
  		  						for(i=1;i<=3;i++)
  		  							for(j=1;j<=3;j++)//十个循环代表十种调料
  		  							if(a+b+c+d+e+f+g+h+i+j==n){//判断条件是否成立，也就是十种调料是否达到总重量
                                        k++;//方案数加一
                                        m[l]=a;
                                        l++;
                                        m[l]=b;
                                        l++;
                                        m[l]=c;
                                        l++;
                                        m[l]=d;
                                        l++;
                                        m[l]=e;
                                        l++;
                                        m[l]=f;
                                        l++;
                                        m[l]=g;
                                        l++;
                                        m[l]=h;
                                        l++;
                                        m[l]=i;
                                        l++;
                                        m[l]=j;
                                        l++;//往m数组里倒一种方案中的十个数
                                    }
    cout<<k<<endl;//输出方案数
    a=0;//把a清零，用来判断是否需要回车
    for(i=1;i<=k*10;i++){
        cout<<m[i]<<" ";//输出每个方案的结果
        a++;
        if(a%10==0)cout<<endl;//每输完一个方案，便输出一个回车
    }
    return 0;//end
}
//巨硬制造，慧及全球
//巨硬万岁
```

---

## 作者：灯芯糕 (赞：30)

  看了前面大佬的代码，发现这道题的解题思路都大同小异。
  
  首先肯定要定义一个变量累加方案数量，因为方案数量要最先输出，所以所有方案要先储存下来。个人不喜欢太多数组，就只定义一个字符串。
  
  然后我们发现只有10种配料，每中在1~3以内，我们便可以模拟一下四进制(4^9==262144，在int范围内)。
  
  ## 累加函数：
  ```cpp
string tot;int n,m;//预备工作 

void leiji(int a){//进行累加的函数 
    int b=262144;//模拟四进制 
    while(a){
        tot+=a/b+'0';//用短除法得出各个位上的数。（要倒着来 ） 
        tot+=' ';//这个空格很重要！ 
        a%=b;b/=4;
    }
    tot+='\n';m++;//换行符也很重要！（m是方案数量） 
}
```
  ## 递归函数：
  ```cpp
void f(int s,int k){
    if(s<1&&k<262145)return;//美味程度达到了 配料还有剩 
    if(s>0&&k>262144)return;//配料放完了而美味程度没达到 
    if(s==0&&k>262144){//达到要求 
        leiji(k);
        return;
    }//以上三种为递归边界 
    f(s-1,k*4+1);
	f(s-2,k*4+2);//k*4是模拟四进制 
	f(s-3,k*4+3);
}
```
  ## 主函数：
  ```cpp
int main(){//主函数 
    cin>>n;
    f(n,0);
    cout<<m<<endl<<tot;//输出，圆满 
    return 0;
}
```

---

## 作者：lovegames (赞：25)

我打一篇卡时间过的题解吧
虽然很暴力但是很好理解呀（个人感觉）
深搜还是不错的
```cpp
#include<iostream>
using namespace std;
int s,t,n;
int a[11];
int b[10000][11];//一个二维数组，先出方案总数很难做呀
int c=1;
int num;
void ss(int k);
void pp();
int main() {
	cin>>n;
	ss(1);
	cout<<num<<endl;
	for(int i=1; i<c; i++) {
		for(int j=1; j<=10; j++) {
			cout<<b[i][j]<<" ";
		}
		cout<<endl;
	}
}
void ss(int k) {
	for(int i=1; i<=3; i++)//每个只能加1,或2或3 {
		s+=i;
		a[k]=i;
		if(k==10) {
			if(s==n)pp();
		} else ss(k+1);
		s-=i;//回溯
	}
}
void pp() {
	num++;
	for(int i=1; i<=10; i++)
		b[c][i]=a[i];//存数组
	c++;
}
```

---

## 作者：冰翼ACE (赞：22)

深搜+剪枝，如果和都大于n了，就不要再搜了

还有，层数为10， 不是n!

还有输出顺序！先出方案，后出具体内容

```cpp
#include<iostream>
#include<cstring> 
using namespace std;
int n;
int ans=0,a[11],b[50000][11];
void init()
{
    scanf("%d",&n);
    memset(a,0,sizeof(a));
}
void search(int dep,int fsum)
{
    if(dep>10)
    {  
        int num=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+a[9]+a[10];
        if(num==n)
        {
            ans++;
            for(int i=1;i<=10;i++)
               b[ans][i]=a[i];
        }
        return;
    }
    for(int i=1;i<=3;i++)
    {
        if(fsum+i>n) break;
        a[dep]=i;
        search(dep+1,fsum+i);
        a[dep]=0;
    }    
}
int main()
{  
   init();
   search(1,0);
   cout<<ans<<"\n";
   for(int i=1;i<=ans;i++)
      {
            for(int j=1;j<=10;j++)
              cout<<b[i][j]<<" ";
             cout<<"\n";
      }
    return 0;
}
```

---

## 作者：CoolTeam (赞：15)

[b ]C语言版深搜[/b ]

在自家电脑上运行将近6s，居然AC了，神机。。。

```cpp
#include<stdio.h>
int ans[9000][10],m=0,num=-1,n,buff[10]={-999};
//m质量，num答案个数(后面要加回1),n为输入
void dfs(int step)
{
    int i;
    if(step==9)//或者step==10时判断是否n==m
    {
        int d=n-m;
        if(d>=1&&d<=3)
        {
            int j;
            buff[9]=d;
            num++;
            for(j=0;j<10;j++)
                ans[num][j]=buff[j];
        }        
        return ;
    }
    for(i=1;i<=3;i++)
    {
        m+=i;
        buff[step]=i;
        dfs(step+1);
        m-=i;
        buff[step]=-999;
    }
}
int main(void)
{
    int i,j;
    scanf("%d",&n);
    dfs(0);
    printf("%d\n",num+1);
    for(i=0;i<=num;i++)
    {
        for(j=0;j<10;j++)
            printf("%d ",ans[i][j]);
        printf("\n");
    }
    return 0;
}

```

---

## 作者：心非 (赞：8)

## 深度优先搜索+剪枝，代码如下:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
int n,ans;
int a[10000][10];//用来存搜索结果

void dfs(int step,int num){//step:深度 num:当前的美味程度
	if(step==10)//递归出口
		if(num==n){
			ans++;//不解释
			memcpy(a[ans],a[ans-1],10*sizeof(int));//因为下一个数组前面都是0，所以用上一个数组覆盖一下
		} 
	else
		for(int i=1;i<=3;i++)
			if(num+i<=n){//剪枝
				a[ans][step]=i;
				dfs(step+1,num+i);
			} 
}

int main(){
	cin>>n;
	if(n<10||n>30) cout<<"0";//显然n<10或者n>30都没有解，直接打印0;
	else{
		dfs(0,0);
		cout<<ans<<endl;
		for(int i=0;i<ans;i++){//输出结果
			for(int j=0;j<10;j++) cout<<a[i][j]<<" ";
			cout<<endl;
		}
	} 
	return 0;
}

```

---

## 作者：xyzhouh (赞：6)

# ~~有点麻烦的~~搜索
看到题目，第一反应是十连for，但我~~又不是垃圾的hz~~，怎么会容忍这种不美观的代码呢？
于是打了一个搜索
代码如下
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n;
int ans[12];
int cnt;
void pu(){
	for(int i=1;i<=10;i++) cout<<ans[i]<<" ";
	cout<<endl;
}
void find(int nu,int last,int lei){
	if(nu==10&&last<=3){
		ans[10]=last;
		if(lei==2)pu();
		cnt++;
	}
	if(nu!=10&&(last>(11-nu)*3||last<11-nu)){
		return;
	}
	for(int i=1;i<=3;i++){
		if(last>i){
			ans[nu]=i;
		find(nu+1,last-i,lei);
		}
	}
}
int main(){
	std::ios::sync_with_stdio(false);
	cin>>n;
	if(n>30) cout<<"0"<<endl;
	else{
		find(1,n,1);//本来想先输出所有可能性的（这样更快）~~我读错题了~~
		cout<<cnt<<endl;
		find(1,n,2);//没想到更好的方法，于是重新递归一下
	}
	
	return 0;
}
```
虽说这样代码有点慢~~但影响不大~~
反正我觉得这样代码更简洁



---

## 作者：BlueMathsForest (赞：6)

正解——深度优先搜索
```
#include<bits/stdc++.h>
using namespace std;
int s;
int flag=0;//判断是否有解 
int sum=0;//总数 
int nice[11],ans[20000][11]; 
void dfs(int dep,int total)//dep代表当前放第几种配料，total代表当前的配料和 
{
	if(dep==11)//若放到第11个格子 
	{
		if(total==s)//若所有配料质量之和达到美味程度 
	{
		flag=1;
		sum++; 
		for(int j=1;j<=10;j++)//存储方案 
		ans[sum][j]=nice[j];
	}	
	return;
	}
	else
	{
		for(int i=1;i<=3;i++)//当前这种配料有三种放法 
		{
			if(total+i>s) break;
			else
			{
				nice[dep]=i;//存储 
				dfs(dep+1,total+i);//搜索下一种配料 
				nice[dep]=0;//回溯 
			}
		}
	}
}
int main()
{
	cin>>s;//输入 
	dfs(1,0);
	if(flag==1)
	{
	cout<<sum<<endl;//输出总数 
	for(int i=1;i<=sum;i++)//输出全部方案 
	{
	for(int j=1;j<=10;j++)
	{
		cout<<ans[i][j]<<" ";
	}
	cout<<endl;
	}	
	}
	else if(flag==0)//若无解 
	{
	cout<<"0";//输出0 
	cout<<endl;	
	}
	return 0;
}
```
NICE！！！

---

## 作者：t14t41t (赞：5)

本题可以直接枚举所有用料方案，总共3^10，还是非常小的。具体过程递归处理的话代码显得好看一些。注意不要用字符串存答案，数组就可以，否则会T。

```cpp

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int n, a[11], ans;
int d[10000][11];
int main()  
{   
    scanf("%d", &n);
    for(a[1] = 1; a[1] <= 3; ++a[1])
    {
        int sum = a[1];
        for(a[2] = 1; a[2] <= 3; ++a[2])
        {
            sum += a[2];
            for(a[3] = 1; a[3] <= 3; ++a[3])
            {
                sum += a[3];
                for(a[4] = 1; a[4] <= 3; ++a[4])
                {
                    sum += a[4];
                    for(a[5] = 1; a[5] <= 3; ++a[5])
                    {
                        sum += a[5];
                        for(a[6] = 1; a[6] <= 3; ++a[6])
                        {
                            sum += a[6];
                            for(a[7] = 1; a[7] <= 3; ++a[7])
                            {
                                sum += a[7];
                                for(a[8] = 1; a[8] <= 3; ++a[8])
                                {
                                    sum += a[8];
                                    for(a[9] = 1; a[9] <= 3; ++a[9])
                                    {
                                        sum += a[9];
                                        for(a[10] = 1; a[10] <= 3; ++a[10])
                                        {
                                            sum += a[10];
                                            if(sum == n)
                                            {
                                                ++ans;
                                                for(int i = 1; i <= 10; ++i)
                                                {
                                                    d[ans][i] = a[i];
                                                }
                                            }
                                            sum -= a[10];
                                        }
                                        sum -= a[9];
                                    }
                                    sum -= a[8];
                                }
                                sum -= a[7];
                            }
                            sum -= a[6];
                        }
                        sum -= a[5];
                    }
                    sum -= a[4];
                }
                sum -= a[3];
            }
            sum -= a[2];
        }
        sum -= a[1];
    }
    printf("%d\n", ans);
    for(int i = 1; i <= ans; ++i)
    {
        for(int j = 1; j <= 10; ++j) printf("%d ", d[i][j]);
        putchar('\n');
    }
    return 0;
}

```

---

## 作者：Neil1110 (赞：5)

这道题其实直接弄一个多重循环就行了，直接列举，并不会超时。

注意需要循环两次，第一次统计个数，第二次输出。

```cpp

#include<iostream>
using namespace std;
int main()
{
    int a,b,c,d,e,f,g,h,i,j,n,m=0;
    cin>>n;
    for(a=1;a<=3;a++)
    for(b=1;b<=3;b++)
    for(c=1;c<=3;c++)
    for(d=1;d<=3;d++)
    for(e=1;e<=3;e++)
    for(f=1;f<=3;f++)
    for(g=1;g<=3;g++)
    for(h=1;h<=3;h++)
    for(i=1;i<=3;i++)
    for(j=1;j<=3;j++)
    {
        if(a+b+c+d+e+f+g+h+i+j==n)
            m++;
    }
    cout<<m<<endl;
    for(a=1;a<=3;a++)
    for(b=1;b<=3;b++)
    for(c=1;c<=3;c++)
    for(d=1;d<=3;d++)
    for(e=1;e<=3;e++)
    for(f=1;f<=3;f++)
    for(g=1;g<=3;g++)
    for(h=1;h<=3;h++)
    for(i=1;i<=3;i++)
    for(j=1;j<=3;j++)
    {
        if(a+b+c+d+e+f+g+h+i+j==n)
        {
            cout<<a<<" ";
            cout<<b<<" ";
            cout<<c<<" ";
            cout<<d<<" ";
            cout<<e<<" ";
            cout<<f<<" ";
            cout<<g<<" ";
            cout<<h<<" ";
            cout<<i<<" ";
            cout<<j<<" ";
            cout<<endl;
        }
    }
} 

```

---

## 作者：wffms69_8 (赞：5)

最朴素的算法

>###保存结果时用sprintf比较简洁
```cpp
#include<vector>
#include<string>
#include<cstdio>
using namespace std;

int main() {
    int n;
    scanf("%d", &n);
    vector<string>ans;
    for (int a(1); a < 4; ++a)
    for (int b(1); b < 4; ++b)
    for (int c(1); c < 4; ++c)
    for (int d(1); d < 4; ++d)
    for (int e(1); e < 4; ++e)
    for (int f(1); f < 4; ++f)
    for (int g(1); g < 4; ++g)
    for (int h(1); h < 4; ++h)
    for (int i(1); i < 4; ++i)
    for (int j(1); j < 4; ++j)
        if (a+b+c+d+e+f+g+h+i+j == n) {
            char s[200];
            sprintf(s, "%d %d %d %d %d %d %d %d %d %d", a,b,c,d,e,f,g,h,i,j);
            ans.push_back(s);
        } 
    printf("%d\n", ans.size());
    for (int i(0); i < ans.size(); ++i)
        printf("%s\n", ans[i].c_str());
    return 0;
}
```

---

## 作者：Warriors_Cat (赞：4)

首先，附上
## 骗分代码一份：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    printf("0");
    return 0;
}//骗分ing...
```
然而，万万没想到的是，

这个代码居然能骗30分！！

好吧，别扯淡了，还是打个正解吧。
### 这道题感觉很像打全排列代码
我用搜索做这道题的。

本蒟蒻的思路如下：

首先，判断当前的条件是否可以继续搜索；

可以则搜索，不仅可以则直接跳过。

当满足题目要求时，答案数+1。

最后输出答案数。

然后重复此操作输出方法数。

## 具体代码如下：

```
#include<bits/stdc++.h>//习惯用万能头文件
using namespace std;
int n, a[11];
int ans;//存储答案数 
void print_ans(){//输出10个配料的克数函数 
	for(int i = 1; i <= 10; ++i){
		printf("%d ", a[i]);
	}//输出配料方案 
	printf("\n");//别忘了换行 
	return;
}
void print_method(int cnt, int step){//输出方案数函数 
	//cnt表示当前的美味程度是多少
	//step表示已经放了几种配料 
	if(cnt < 0) return;//若美味程度为负数，则停止 
	if(step == 10 && cnt != 0) return;//若放完配料后还有剩余则停止 
	if(step == 10 && cnt == 0){//若放完后没剩 
		print_ans();//输出配料方案 
		return;
	}
	for(int i = 1; i <= 3; ++i){
		a[step + 1] = i;//枚举下一种配料放几克 
		print_method(cnt - i, step + 1);//搜索开始 
	}
}
void count_ans(int cnt, int step){//计算答案数函数 
	//和上面几乎一模一样，但是用来存储答案的
	if(cnt < 0) return;
	if(step == 10 && cnt != 0) return;
	if(step == 10 && cnt == 0){
		ans++;//唯二不同的地方之一 
		return;
	}
	for(int i = 1; i <= 3; ++i){
		a[step + 1] = i;
		count_ans(cnt - i, step + 1);
		//函数名也要变一下 
	}
} 
int main(){
	scanf("%d", &n);//输入克数 
	if(n > 30){
		printf("0");//若n>30则输出0即可
		return 0;//再见！ 
	}
	count_ans(n, 0);//统计答案数 
	printf("%d\n", ans);//输出答案 
	print_method(n, 0);//输出方案 
	system("pause");//日常防伪代码 
	return 0;//再见！ 
}  
```
这个代码比上面的其他暴力枚举时间快多了，

才大约50ms。

交了好多次，最快一次有49ms的。

## 求过！！求过！！求过！！
### 重要的事情说三遍！
谢谢各位读者的阅读以及管理员的审阅。

---

## 作者：斯茂 (赞：4)

# 进制枚举法
用一个10位的三进制数表示一种方案,从0枚举到3^10-1就行了

由于要求字典序所以反过来存

由于每种作料是1-3克，所以每一项加1
```
#include <cstdlib>
#include <iostream>
#include <cstdio>

using namespace std;
int a[100005][10], x[10];
int main(int argc, char *argv[])
{
    int n, i, j, t, k, w = 0;
    cin >> n;
    for(i = 0; i <= 59048; i++)
    {
      t = i;
      k = 0;
      for(j = 0; j < 10; j++)
      {
        x[9 - j] = t % 3 + 1;
        k += x[9 - j];
        t /= 3;
      }
      if(k == n)
      {
        for(j = 0; j < 10; j++)
          a[w][j] = x[j];
        w++;
      }
    }
    cout << w << endl;
    for(i = 0; i < w; i++)
    {
      for(j = 0; j < 10; j++)
        printf("%d ", a[i][j]);
      printf("\n");
    }
    system("PAUSE");
    return EXIT_SUCCESS;
}
```

---

## 作者：x670783915 (赞：4)

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#define FU(x) for(x=1;x<=3;x++)
using namespace std;
int ans[10000][10];
int main()
{
    int n,tot=0;
    cin >> n;
    int d[10];
    FU(d[0]) FU(d[1]) FU(d[2]) FU(d[3]) FU(d[4]) FU(d[5]) FU(d[6]) FU(d[7]) FU(d[8]) FU(d[9]) {
        if(d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+d[6]+d[7]+d[8]+d[9]==n){
            for(int i=0;i<10;i++) ans[tot][i] = d[i];
            tot++;
        }
    }
    cout << tot << endl;
    for(int i=0;i<tot;i++)
    printf("%d %d %d %d %d %d %d %d %d %d\n",ans[i][0],ans[i][1],ans[i][2],ans[i][3],ans[i][4],ans[i][5],ans[i][6],ans[i][7],ans[i][8],ans[i][9]);
    return 0;
}
//直接暴力枚举就行
```

---

## 作者：Sktain (赞：3)

咳咳，第一次写题解，小激动。

这道题的话，我们只需要一个十重循环枚举一下就行了。

所以我们将会看到满满一屏幕的for(···;···;···)，这将会非常繁琐，所以我们悄咪咪地宏定义偷个懒。

```cpp
int i[11];//i[x]表示第x种调料的量
//由于每种调料至少1克，所以初值为1

#define f(x) for(i[x]=1;i[x]<=3;i[x]++)
```
这样的话我们就可以轻松地开始枚举了。

（关于字典序，由于for循环的特性，枚举的小伙伴们不用担心这个问题）

再提一点，本题要求我们先输出方案个数，再输出方案，所以我们声明一个sum变量来存储方案数，并声明一个二维数组a[10086][11]/**方案数的最大值在8000+，所以要大一点。（出于某些原因，本人特别喜欢用10086）**/来存储已有的方案，最后再输出。

为了~~强迫症地~~优化一下这个程序，我们判断一下在哪些情况下会没有方案。

由于每种调料的取值范围是[1,3]，所以总数应在[10,30]。这样我们就可以知道在这个区间外的数都是无解的。

这里赋值也懒懒地写个函数解决。

上代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int i[11],a[10086][10],sum=0,n;
#define f(x) for(i[x]=1;i[x]<=3;i[x]++)
void aa(int x)
{
	a[sum][x]=i[x];
}
int main()
{
	cin>>n;
	if(n<10&&n>30)
	{
		cout<<0;
		return 0;
	}
	f(1)
    f(2)
	f(3)
	f(4)
	f(5)
	f(6)
	f(7)
    f(8)
    f(9)
	f(10)
	if(i[1]+i[2]+i[3]+i[4]+i[5]+i[6]+i[7]+i[8]+i[9]+i[10]==n)
	{
		sum++;
		for(int i=1;i<=n;i++)
            aa(i);
	}
		cout<<sum<<endl;
		for(int i=1;i<=sum;i++)
		    for(int j=1;j<=10;j++)
		        if(j==10)
		            printf("%d\n",a[i][j]);
		        else
		            printf("%d ",a[i][j]);
	return 0;
}
```

最后提醒一下：别忘了输出**空格**！

---

## 作者：HoshinoTented (赞：3)

# 开头
挺简单的题目, 本小姐用的是回溯  
~~然而Haskell题解就被困了半天。。~~  

# 正文
## [题解(C++)](https://github.com/HoshinoTented/LuoGu/blob/master/src/P2089.hpp)
```C++
//
// Created by hoshino on 18-11-25.
//

#ifndef LUOGU_P2089_HPP
#define LUOGU_P2089_HPP

#include <bits/stdc++.h>

#define MIN 1		//每种配料最低的质量
#define MAX 3		//每种配料最高的质量
#define KIND_MAX 10	//配料的种类
#define Program int[KIND_MAX]		//。。。

std::vector<int *> programs;		//存方案的一个列表

auto dfs(
		const int &cur,		//当前的配料
		const int &need,	//还需要多少的美味程度
		int *program		//当前方案
) -> void {		//返回 void
	if (cur == KIND_MAX) {	//判断是否已经用完所有配料
		if (! need) {		//判断是否达到了所需要的美味程度
			int *clonedProgram = new Program;	//复制方案
			for (int i = 0; i < KIND_MAX; ++ i) {
				clonedProgram[i] = program[i];
			}

			programs.push_back(clonedProgram);	//添加方案
		}
	} else		//如果没有用完所有配料, 继续添加
		for (int i = MIN; i <= MAX; ++ i) {
			auto newNeed = need - i;
			program[cur] = i;
			dfs(cur + 1, newNeed, program);
		}
}

auto main(int n, char **) -> int {
	std::cin >> n;
	dfs(0, n, new Program);

	std::cout << programs.size() << std::endl;

	for (auto &v : programs) {
		for (int i = 0; i < KIND_MAX; ++ i) {
			std::cout << v[i] << " ";
		}

		std::cout << std::endl;
	}

	return 0;
}
#endif //LUOGU_P2089_HPP
```
## [题解(Haskell)](https://github.com/HoshinoTented/LuoGu/blob/master/src/P2089.hs)
```Haskell
module LuoGu.P2089 (main) where

-- dfs :: 已经记录的方案 -> 当前方案 -> 当前配料 -> 需要的美味程度 -> 最终方案(返回值)
dfs :: [[Int]] -> [Int] -> Int -> Int -> [[Int]]
dfs ps cp 10 0 = cp : ps		-- 如果已经用完所有配料, 并且也达到了美味程度, 则添加上当前的方案
dfs ps _ 10 need = ps	-- 如果用完了所有配料, 但没有达到美味程度, 不添加当前方案
dfs ps _ cur 0 = ps		-- 如果达到了美味程度, 但没有用完所有配料, 不添加当前方案
dfs ps cp cur need = foldr (\x ps -> ps ++ dfs [] (x : cp) (cur + 1) (need - x)) ps [1..3]  -- 如果没有用完配料, 也没有达到美味程度, 继续添加配料

-- 把列表([Int])转字符串的东西
toString :: [Int] -> String
toString [] = ""
toString (x:xs) = show x ++ " " ++ toString xs

-- 输出列表([[Int]])
printList :: [[Int]] -> IO ()
printList [] = putStr ""
printList (x:xs) = do
  putStrLn $ toString x
  printList xs

-- 函数入口
main :: IO ()
main = do
  need <- read <$> getLine :: IO Int		-- 读取需要的美味程度, 类型是 Int
  result <- pure $ dfs [] [] 0 need		-- 计算结果

  print $ length result		-- 输出结果总数
  printList result	-- 输出结果
```
其实在Haskell的题解这边困了很久...  
就因为星野把 `need - x` 写成了 `need - 1`  
大概是因为前面的 `cur - 1`, 所以才这样的吧  

---

## 作者：abtd (赞：3)

如各位大神所言，本题直接枚举即可。

楼下说写成递归代码会更好看，所以这里就贴个递归版的(\*ﾟ▽ﾟ)ﾉ

（这里用stringstream偷懒了...字符串流很慢的...）


```cpp

#include <iostream>
#include <sstream>

using namespace std;

stringstream ss;
int n, cnt;

void solve(int a[], int cur, int sum)
{
    if (cur == 10)
    {
        if (sum == n)
        {
            ++cnt;
            for (int i = 0; i < cur; ++i)
                ss << a[i] << ' ';
            ss << endl;
        }
    }
    else
    {
        for (int i = 1; i <= 3; ++i)
        {
            a[cur] = i;
            solve(a, cur + 1, sum + i);
        }
    }
}

int main(void)
{
    cin >> n;
    int a[10];
    solve(a, 0, 0);
    cout << cnt << endl;
    cout << ss.str();
    return 0;
}

```

---

## 作者：李紫浩 (赞：3)

水题！直接枚举！

```cpp
program kaoji;
var
  i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,num,s:longint;
begin
  readln(s);
  num:=0;
  for i1:=1 to 3 do
    for i2:=1 to 3 do
      for i3:=1 to 3 do
        for i4:=1 to 3 do
          for i5:=1 to 3 do
            for i6:=1 to 3 do
              for i7:=1 to 3 do
                for i8:=1 to 3 do
                  for i9:=1 to 3 do
                    for i10:=1 to 3 do
                      if i1+i2+i3+i4+i5+i6+i7+i8+i9+i10=s then inc(num);
  writeln(num);
  for i1:=1 to 3 do
    for i2:=1 to 3 do
      for i3:=1 to 3 do
        for i4:=1 to 3 do
          for i5:=1 to 3 do
            for i6:=1 to 3 do
              for i7:=1 to 3 do
                for i8:=1 to 3 do
                  for i9:=1 to 3 do
                    for i10:=1 to 3 do
                      if i1+i2+i3+i4+i5+i6+i7+i8+i9+i10=s then
                          writeln(i1,' ',i2,' ',i3,' ',i4,' ',i5,' ',i6,' ',i7,' ',i8,' ',i9,' ',i10,' ');
end.
```

---

## 作者：MXR612 (赞：2)

其实就是枚举，不过十层for有点丑不是吗？（其实也还好，两座小山峰）
于是就递归枚举好啦

虽然数据有点小大，看上去不像是递归，但是其实有效数据只有10<=n<=30，~~根据这个我们可以直接拿下三个点~~

另一方面说，由于有效数据范围小，所以第一问我们可以跑一遍然后打表节省时间（打表的代码已经注释掉啦）

```cpp
#include <iostream>

using namespace std;

int n;
int count,ans[]={0,0,0,0,0,0,0,0,0,0,1,10,55,210,615,1452,2850,4740,6765,8350,8953,8350,6765,4740,2850,1452,615,210,55,10,1};//打表

int pw(int a,int b){
	if(b==0)
		return 1;
	int ans=a;
	for(int i=2;i<=b;i++)
		ans*=a;
	return ans;
}

void dfs(int dep,long long num,int sum){
	if(dep==11){
		if(sum==n){
			for(int i=1;i<=10;i++){
				cout<<num/pw(10,10-i)<<' ';
				num%=pw(10,10-i);
			}
			cout<<endl;
			// count++;
		}
		return ;
	}
	for(int i=1;i<=3;i++)
		dfs(dep+1,num*10+i,sum+i);
}

int main(){
	// freopen("P2089.in","r",stdin);
	cin>>n;
	// for(n=0;n<=30;n++){
	// 	count=0;
	// 	dfs(1,0,0);
	// 	cout<<count<<',';
	// }
	if(n<10||n>30){
		cout<<0;
	}else{
		cout<<ans[n]<<endl;
		dfs(1,0,0);
	}
	return 0;
}
```

---

## 作者：_Eterna1 (赞：1)

这题虽然不算太水，但还是挺简单的

开一个[1..3^10(具体多少忘了)，1..10]of longint;的二维数组

直接用10个变量从1到3循环

每发现等于n的情况就在二维数组中存放并inc(t);

最后for i:=1 to t do 输出；

至于字典序只要你十个变量在数组中从左到右依次存放即可


---

## 作者：24680esz (赞：1)

直接暴力枚举即可，虽然时间复杂度及其恐怖，但毕竟题目数据小（话说这样真的好么？）

```cpp
#include <iostream>  
using namespace std;  
int p[10001][11];  
int main()  
{  
    int sr,sc=0;  
    cin>>sr;  
    for (int q=1;q<=3;q++)  
      for (int a=1;a<=3;a++)  
        for (int z=1;z<=3;z++)  
          for (int w=1;w<=3;w++)  
            for (int s=1;s<=3;s++)  
              for (int x=1;x<=3;x++)  
                for (int e=1;e<=3;e++)  
                  for (int d=1;d<=3;d++)  
                    for (int c=1;c<=3;c++)  
                      for (int r=1;r<=3;r++)  //十重循环噢！
                        if (q+a+z+w+s+x+e+d+c+r==sr)  
                        {  
                            sc++;  //次数+1
                            p[sc][1]=q;p[sc][2]=a;p[sc][3]=z;  
                            p[sc][4]=w;p[sc][5]=s;p[sc][6]=x;  
                            p[sc][7]=e;p[sc][8]=d;p[sc][9]=c;p[sc][10]=r; //用二维数组将数据复制 
                        }  
    cout<<sc<<endl;  
    for (int i=1;i<=sc;i++)  
    {  
        for (int j=1;j<=10;j++)  
          cout<<p[i][j]<<" ";  
        cout<<endl;  
    }     
}
```

---

## 作者：lvdzxcvb (赞：1)

直接暴力可过

```cpp
[codec ]#include<cstdio>
using namespace std;
int n,a[10000][11],s;
void init()
{
    scanf("%d",&n);
}
void solve()
{
    for(int i1=1;i1<=3;i1++)
          for(int i2=1;i2<=3;i2++)
              for(int i3=1;i3<=3;i3++)
                  for(int i4=1;i4<=3;i4++)
                      for(int i5=1;i5<=3;i5++)
                          for(int i6=1;i6<=3;i6++)
                              for(int i7=1;i7<=3;i7++)
                                  for(int i8=1;i8<=3;i8++)
                                      for(int i9=1;i9<=3;i9++)
                                          for(int i10=1;i10<=3;i10++)
                                              if(i1+i2+i3+i4+i5+i6+i7+i8+i9+i10==n)
                                                    a[++s][1]=i1,a[s][2]=i2,a[s][3]=i3,a[s][4]=i4,a[s][5]=i5,a[s][6]=i6,a[s][7]=i7,a[s][8]=i8,a[s][9]=i9,a[s][10]=i10;
}
int main()
{
    init();
    solve();
    printf("%d\n",s);
    for(int i=1;i<=s;i++)
    {
        for(int j=1;j<=10;j++)
              printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}[/codec ]
```

---

## 作者：方形视觉系 (赞：1)

我们可以用纯粹的枚举。

```cpp
[#include<cstdio>
#include<iostream>
using namespace std;
int a,b,c,d,e,f,g,h,i,j,k,n,t;
int s[200000][11];//用一个二维数组s记录方案，11是因为共有10种xx，2000000是因为不为什么，差不多别开太小就是了。
int main(){
    cin>>n;//读入美味程度
    t=0;//计数器
    for(int a=1;a<=3;a++)
     for(int b=1;b<=3;b++)
      for(int c=1;c<=3;c++)
       for(int d=1;d<=3;d++)
        for(int e=1;e<=3;e++)
         for(int f=1;f<=3;f++)
          for(int g=1;g<=3;g++)
           for(int h=1;h<=3;h++)
            for(int i=1;i<=3;i++)
              for(int j=1;j<=3;j++){//共计十重循环
              if(a+b+c+d+e+f+g+h+i+j==n){//如果达成目标
               t++;//计数器++
               s[t][1]=a;s[t][2]=b;s[t][3]=c;s[t][4]=d;s[t][5]=e;
               s[t][6]=f;s[t][7]=g;s[t][8]=h;s[t][9]=i;s[t][10]=j;//记录下来第t个方案
              }
               }
    cout<<t<<endl;//先输出方案数
    for (int i=1;i<=t;i++)cout<<s[i][1]<<' '<<s[i][2]<<' '<<s[i][3]<<' '<<s[i][4]<<' '<<s[i][5]<<' '<<s[i][6]<<' '<<s[i][7]<<' '<<s[i][8]<<' '<<s[i][9]<<' '<<s[i][10]<<endl;//再输出t行方案
return 0;
}]
这道题就是这样；
```

---

## 作者：Ufowoqqqo (赞：1)

**搜索**。由于深度最多只有20，爆栈的可能性微乎其微。需要注意的是解的数量，当n=20时将有**几千组**解，因此我一开始设ans为1000种时就爆了。

这里我没写剪枝[delete]（懒嘛）[/delete]，不过数据不是很大，不剪也是可以的。要剪的话就是当目前方案的质量之和已经超过n时就不再往下一层搜就好了。

```delphi

type data=array [1..10] of longint;
var
 n,i,j:longint;
 ans:array [0..10000] of data;
 t:data;

procedure search(d:longint;a:data);//a储存当前配料情况
var
 sum,i:longint;
begin
 if d=10 then
  begin
   sum:=0;
   for i:=1 to 10 do inc(sum,a[i]);//统计配料质量之和
   if sum=n then
    begin
     inc(ans[0,1]);
     ans[ans[0,1]]:=a;
    end;
   exit;
  end;
 a[d+1]:=1;
 search(d+1,a);
 a[d+1]:=2;
 search(d+1,a);
 a[d+1]:=3;
 search(d+1,a);
end;

begin
 read(n);
 search(0,t);
 writeln(ans[0,1]);
 for i:=1 to ans[0,1] do
 begin
  for j:=1 to 10 do write(ans[i,j],' ');
  writeln;
 end;
end.

```

---

## 作者：飞翔 (赞：1)

我的题解和@李紫浩的差不多啦……没说的，10重循环暴搜，洛谷神机不会超！

```cpp
var
  a,b,c,d,e,f,g,h,i,j,n,s,t:integer;
  a1,a2,a3,a4,a5,a6,a7,a8,a9,a10:array[1..8954]of 1..3;
begin
  s:=0;t:=0;
  readln(n);
  for a:=1 to 3 do
    for b:=1 to 3 do
      for c:=1 to 3 do
        for d:=1 to 3 do
          for e:=1 to 3 do
            for f:=1 to 3 do
              for g:=1 to 3 do
                for h:=1 to 3 do
                  for i:=1 to 3 do
                    for j:=1 to 3 do
                    begin
                      s:=s+a+b+c+d+e+f+g+h+i+j;
                      if s=n then
                      begin
                        inc(t);
                        a1[t]:=a;a2[t]:=b;a3[t]:=c;a4[t]:=d;a5[t]:=e;a6[t]:=f;a7[t]:=g;a8[t]:=h;a9[t]:=i;a10[t]:=j;
                      end;
                      s:=0;
                    end;
  writeln(t);
  for i:=1 to t do
    writeln(a1[i],' ',a2[i],' ',a3[i],' ',a4[i],' ',a5[i],' ',a6[i],' ',a7[i],' ',a8[i],' ',a9[i],' ',a10[i]);
end.
```

---


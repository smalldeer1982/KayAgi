# 放苹果

## 题目描述

把 $m$ 个同样的苹果放在 $n$ 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法。（$5,1,1$ 和 $1,1,5$ 是同一种方法）


## 说明/提示

对于所有数据，保证：$1\leq m,n\leq 10$，$0 \leq t \leq 20$。

## 样例 #1

### 输入

```
1
7 3```

### 输出

```
8```

## 样例 #2

### 输入

```
3
3 2
4 3
2 7
```

### 输出

```
2
4
2
```

# 题解

## 作者：ybb756032937 (赞：168)

#C++代码解析

##基本思路：递归 记录 AC

###代码呈上：

```cpp
#include<iostream>//个人不建议使用万能头文件；可能编译出错；
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int sum[10000];//用来记录每一组数据最后的结果
int apple(int m,int n)//m是苹果数，n是盘子数 
{
    if(m==0||m==1||n==1)//边界：当苹果只有一个或者没有苹果时或者盘子只有一个时，只有一种放法，所以达到边界，返回值；
    return 1;
    if(m<n)//当苹果数少于盘子数，就只有m个盘子作用，所以接下来就计算m个苹果和m个盘子；
    return apple(m,m);
    if(m>=n)//如果苹果数大于等于盘子数，分成两个部分，一种是目前所有的盘子都放一个苹果，另一种是拿一个盘子不放；
    return apple(m-n,n)+apple(m,n-1);
}
int main()
{
    int n,m,s;//其中s是数据的个数；
    cin>>s;
    for(int i=1;i<=s;i++)
    {    
        cin>>m>>n;//m是苹果数，n是盘子数
        sum[i]=apple(m,n);//将每一组的苹果和盘子的到的结果记录在sum数组之中；
    }
    for(int j=1;j<=s;j++)
    cout<<sum[j]<<endl;//输出数据；
    return 0;
}
```
详细解释思路（当苹果数大于等于盘子数时的分法）：一种是**目前**所有的盘子都放一个苹果，盘子数不变，即：apple(m-n,n);

另一种是将一个盘子不放，再来进行思考，即：apple(m,n-1);

两种情况的总和就是答案；

接下来就用一个例子来详细解释：


现在有5个苹果和3个盘子；

因为苹果数大于盘子数，所以分成两种：

第一种：目前所有盘子放一个苹果（目前盘子数3个）apple(2,3);

第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(5,2);


apple(2,3):因为苹果数小于盘子数，所以apple(2,2);


apple(2,2):因为苹果数等于盘子数，所以又分为两种：

第一种：目前所有盘子放一个苹果（目前盘子数2个）apple(0,2);        没有苹果，达到边界，**返回值1**；

第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(2,1);        盘子数只有1个，达到边界，**返回值1**；


apple(5,2):因为苹果数大于盘子数，所以又分为两种：

第一种：目前所有盘子放一个苹果（目前盘子数2个)apple(3,2);

第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(5,1);        因为盘子数只有1个，达到边界，**返回值1**；


apple(3,2):因为苹果数大于盘子数，所以又分为两种：

第一种：目前所有盘子放一个苹果（目前盘子数2个)apple(1,2);        苹果数只有1个，达到边界，**返回值1**；

第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(3,1);        盘子数只有1个，达到边界，**返回值1**；


所有的值相加得到最后的结果5，记录在数组sum中，最后输出；


以上就是本题所有的讲解，要查看更多内容，学到更多知识，请查看我的博客：https://www.luogu.org/blog/AHacker/


---

## 作者：蒟蒻lxy (赞：101)

~~难度中等~~
# 看各位大佬都是递归题解
## 所以现在让我来发一下动态规划题解吧
### 思路：
#### 1：在只有一个盘子的时候，方案数恒为1
![](https://cdn.luogu.com.cn/upload/pic/46460.png)
#### 2：在苹果数为1或0时，方案数恒为1
![](https://cdn.luogu.com.cn/upload/pic/46461.png)
#### 3：在苹果数（i）<盘子数的时候，等于i个苹果放在i个盘子里 
![](https://cdn.luogu.com.cn/upload/pic/46463.png)
#### 4：在苹果数（i）>盘子数（j）时，有两种做法：
```
1.j个盘子里都放 1个，即 f[i-j][j]
2.都不放，即           f[i][j-1]

```



------------

------------

## 所以现在上代码
```
#include<bits/stdc++.h>
using namespace std;
int m,n,ans,f[15][15];//f[i][j]即为i个苹果放在j个盘子里的方案数 
int main()
{
	int t;
	cin >> t;
	while(t--)//t组测试数据 
	{
		cin >> m >> n;
		ans=0;//ans置0 
		memset(f,0,sizeof(f));//清空f数组 
		for(int i=1;i<=n;i++)
			f[0][i]=f[1][i]=1;//当苹果数量是1或0时，永远只有一种方法 
		for(int i=1;i<=m;i++)
			f[i][1]=1;//当只有一个盘子的时候，永远只有一种方法 
		for(int i=2;i<=m;i++)
			for(int j=2;j<=n;j++)
				if(i<j)//如果苹果比盘子还少 
					f[i][j]=f[i][i];//等于i个苹果放在i个盘子里 
				else
					f[i][j]=f[i-j][j]+f[i][j-1];//对于每一次，有两种做法： 
		//1：j个盘子里都放 1个，即 f[i-j][j]
		//2：都不放，即            f[i][j-1]
		cout << f[m][n] << endl;//输出 
	}
	return 0;
}

```

---

## 作者：Frenix (赞：63)

蒟蒻第一个题解……希望可以让同为蒟蒻的小伙伴看得懂

将M个相同苹果放在N个相同的盘子里，盘子可以为空，求方案数。


0.    边界条件：没有苹果或者只有一个盘子的时候，方案数为1

1.    若n>m,那就算每个苹果占一个盘子也最多只能占有n个盘子。f(m,n)=f(m,m);

2.    对其余情况f(m,n)，分为放满盘子和不放满盘子两种情况。

①    若放满盘子，则可以将所有盘子的苹果各拿掉一个，方案数不变。f1(m,n)=f(m-n,n)

②    若不放满盘子，则可以把空盘子直接拿掉一个再做考虑f2(m,n)=f(m,n-1)

所以有f(m,n)=f(m-n,n)+f(m,n-1)


```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;

int N,M;
int d[55][55];

int main()
{
    for(int i=0;i<=50;i++)
        for(int j=1;j<=50;j++)
        {
            if(j==1||i==0) d[i][j]=1;
             else if(i<j) d[i][j]=d[i][i];
            else d[i][j]=d[i-j][j]+d[i][j-1];
        }
    int t,m,n;
    cin>>t; 
    while(t--)
    {
        cin>>m>>n;
        cout<<d[m][n]<<endl;
    }
    return 0;
} 
```

---

## 作者：Panthera_AFO (赞：45)

求通过！考前准备造福一波萌新

骗分神器：DFS，最有用的算法之一

N,M<=10岂不随便搞... `O(2^n)`稳如老狗

有人说DFS要讨论不放的情况，我只想说都爆搜了还讨论啥啊

直接从0搜问题解决

```
#include<iostream>
#include<cstdio>
int ans,n,k;
void dfs(int pos,int now,int lftV)
//pos处理完了几个篮子
//now当前篮子放几个苹果
//lftV剩余的苹果
{
    if(pos==k&&!lftV) {ans++;return;}
    if(pos==k||lftV<0) return;
    for(int i=now;i<=lftV;i++)
        dfs(pos+1,i,lftV-i);
        //因为要去掉重复情况，所以从0开始不下降就好了
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
        ans=0,scanf("%d%d",&n,&k),dfs(0,0,n),printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Karry5307 (赞：36)

### 题意

$n$ 个相同的球放 $m$ 个相同盒子里，求方案数。

$\texttt{Data Range:}1\leq n,m\leq 10$

### 题解

这数据范围太小了，出 $1\leq n,m\leq 10^5$ 都可以。

注意到球和盒子都相同，于是可以考虑按照盒子里的球的数量将盒子排个序，于是就联系到了分拆数的问题。

定义将 $n$ 拆分成 $m$ 个正整数的方案数为 $p(n,m)$。

然后考虑 $\texttt{Ferrers}$ 图与其共轭，不难看出一个将 $n$ 拆分 $m$ 个正整数的方案唯一对应一个将 $n$ 拆分为不超过 $m$ 的方案。

所以，$n$ 拆分成若干个正整数，其中每个都不超过 $m$ 的方案数也为 $p(n,m)$。

与其考虑拆分，不如换种方式，考虑用不超过 $m$ 的正整数组成 $n$ 的问题。

这个就是个经典的背包方案计数问题，于是可以得到以下生成函数：

$$F(x)=\prod\limits_{i=1}^{m}\frac{1}{1-x^i}$$

但是这个是正整数划分，注意到 $n+m$ 的 $m$ 正整数划分与 $n$ 的 $m$ 非负整数划分显然一样，答案就是 $[x^{n}]F(x)$。

但是这个直接算太复杂了，使用 $\texttt{Euler}$ 变换即可。

---

## 作者：c201904 (赞：19)

这道题其实就是一个分类讨论+递归，你可以选择有一个盘子一个苹果都不放，然后盘子数减1，或者（不可能两种方案都不选）每个盘子都放一个苹果，即苹果减去盘子的数量，就一直这样递归下去，就得到了最终的答案。注意：有0个苹果或1个盘子时，只有一种方案，所以（n==0||m==1）return 1，当n<0或m<1时，因为根本不存在这种情况，所以返回一个0
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#include<iostream>
using namespace std;
int solve(int n,int m){//n代表苹果数，m代表盘子数
    if(n==0||m==1)return 1;
    if(n<0|m<1)return 0;//这里很重要，很容易被忘记，我已开始就忘了
    else return solve(n,m-1)+solve(n-m,m);
}
int main()
{
    int cases;
    cin>>cases;//输入测试数据的数目（问题的数量）
    while(cases--){
        int n,m;
        cin>>n>>m;
        cout<<solve(n,m)<<endl;//记得空行
    }
}
```

---

## 作者：于丰林 (赞：14)

好的，先说一下我一开始想到的：

　　首先，这道题是一个十分典型的递归题，至于为什么我就不说了，你们都知道。因此，先找到这道题的出口：当仅剩一个盘子（所有剩的苹果都放在一个盘子里）或没有苹果（所有盘子都空）时，都只有一种可能。因此，将f（m）拆分开成f（m-1）+n，依次递归下去。
  
很显然，这并不成立

比如：如果有盘子不放苹果呢？

好吧，不卖关子了，直接说正确思路：

　　首先，递归出口已经找到，那么下一个目标就是拆分可能性，依次递归，直到满足出口条件（m==0||n==1）时递归回来。
  
　　那么，可能性如何拆分呢？
  
　　我们知道对于m个苹果，只有两大类情况：每个盘子都有和有空盘子。那么我们是不是可以拆分f（m，n）=f（m-n，n）+f（m，n-1）呢？
　　
显然成立

但是，细心的朋友会发现：当m<n时，m-n居然成了负数

？！

原因是：当苹果数小于盘子数时，你居然还要求人苹果把盘子填满？这很显然是错误的。所以我们就可以将问题转化为m个苹果放在m个盘子中（题目中说过顺序不重要），因此，我们要加一个特判。

好的，我讲完了？

并没有！

补充一句：当m<n时，你觉不觉得接下来就会到达一个出口呢？

好吧，这并不重要。。。

最后，附上本题代码

```cpp
#include<cstdio>
using namespace std;
int fang(int m,int n)
{
    if(m==0||n==1)
    {
        return 1;
    }
    else if(m<n)
    {
        return fang(m,m);
    }
    else
    {
        return fang(m-n,n)+fang(m,n-1);
    }
}
int main()
{
    int t,M,N;
    scanf("%d",&t);
    for(int i=1; i<=t; i++)
    {
        scanf("%d%d",&M,&N);
        printf("%d\n",fang(M,N));
    }
    return 0;
}
```

---

## 作者：跪下叫哥 (赞：9)

# [luogu P2386 放苹果](https://www.luogu.org/problemnew/show/P2386)题解
## 题目理解
[![image.png](https://i.postimg.cc/qRmP8f1Y/image.png)](https://postimg.cc/5YCKVrdq)
如果有3个苹果,2个盘子,怎么放呢?

```
3
1 2
```
一个有2种放法.

如果有7个苹果,3个盘子,怎么放呢?

```
7
1 6
2 5
3 4
1 1 5
1 2 4
1 3 3
2 2 4
```

一个有8种放法.

**现在你应该知道具体怎么放苹果了吧!**

## 方法1:搜索

f(n,k)表示有m个苹果,k个盘子的时候的**放法**.

仔细想一想f(n,k)可以分成有两种情况:

  - 至少有一个盘子没有苹果:f(n,k-1）
  - 每个盘子都必须有苹果,相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目:f(n-k,k)

如果n<k,必定有n-k个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即:`if(n<k) f(n,k) = f(n,n)`

[![2.png](https://i.postimg.cc/Nf23rzmJ/2.png)](https://postimg.cc/TpG7zQkg)

那么状态方程为:

```math
f(n,k)=
\begin{cases}
f(n,n) & \text{ if } n<k \\ 
 f(n,k-1)+f(n-k,k)& \text{ if } n \geq k
\end{cases}
```

边界:f(n,1)=1,没有苹果可以放的时候:f(0,k)=1

所以我们可以按下面的方法来写**搜索法**:

 - 当n=1时，所有苹果都必须放在一个盘子里，所以返回１；
 - 当没有苹果可放时，定义为１种放法；
 - 递归的两条路，第一条k会逐渐减少，终会到达出口k==1; 
 - 第二条n会逐渐减少，因为$$k>m$$时，我们会`return f(n,n)`,所以终会到达出口n==0．

### 代码

```c
#include <cstdio>

int t;

int apple(int n,int k){
    if( n == 0 || k == 1) //边界
        return 1;

    if( n < k) return apple(n,n);

    return apple(n,k-1) + apple(n-k,k);
}

int main(){
    scanf("%d",&t);

    for(;t>=1;t--){

        int n,k;
        scanf("%d%d",&n,&k);

        int ans = apple(n,k);
        printf("%d\n",ans);
    }
    return 0;
}
```


## 方法2:动态规化

上面的方法使用搜索法，思路很容易理解，但是很多子问题重复计算，复杂度很高,为了让代码运算速度更快,我们就要使用动态规划!（自底向上）

**转移方向如下:**

[![dp.png](https://i.postimg.cc/rw6vGN98/dp.png)](https://postimg.cc/fJK2DXFF)

```c
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#include <deque>
#include <list>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

int t;
int f[11][11] = {0};
int n,k;

void dp(int n,int k){
    
    int i,j;
    for(i=1;i<=n;i++)
        for(j=2;j<=k;j++){
            if( f[i][j] != -1) continue; //已经计算过

            if( i < j ) 
                f[i][j] = f[i][i];
            else
                f[i][j] = f[i][j-1] + f[i-j][j];
        }
}

int main(){

    int i,j;
    scanf("%d",&t);
    
    memset(f,-1,sizeof(f)); // -1 表示这个点没有算出来
    // 边界
    for(i=0;i<=10;i++) f[i][1] = 1;
    for(i=0;i<=10;i++) f[0][i] = 1;

    for(;t>=1;t--){

        scanf("%d%d",&n,&k);
        if( f[n][k] == -1)
            dp(n,k);

        printf("%d\n",f[n][k]);
    }

    return 0;
}
```

## 方法3:搜索+组合

todo!!

## 整数划分一:将n划分成若干不同整数之和的划分数


3

```
3
1 2
```

有2种

4

```
4
1 3
```
有2种

5
```
5
1 4
2 3
```
有3种

6

```
6
1 5
2 4
1 2 3
```
有4种

f(i,j)表示将数字i划分成不超过j大小的方法数.在划分的过程中你会发现有如下的规律:

 - 划分的数包括j,那么剩余的数i-j继续划分的话,根据不能相同的条件,不能超过j-1,f(i-j,j-1)
 - 划分的数不包括j,f(i,j-1)
 - 如果i<j,f(i,j) = f(i,i)显然成立


```math
f(i,j) = f(i-j,j-1)+f(i,j-1)  f(i,j) = f(i,i)\ i < j
```
边界:f(0,0)=1,其余为0

为了更加理解**状态转移方程**,手动推导一遍**f(6,6)**：

 - $$f(1,1) = f(0,0) + f(1,0) = 1$$
 - $$f(1,2) = f(1,3)=f(1,4)=f(1,5)=f(1,6)= f(1,1) = 1$$
 - $$f(2,1) = f(1,0)+f(2,0) = 0$$
 - $$f(2,2) = f(0,1)+f(2,1) = 1$$
 - $$f(2,3) = f(2,4) = f(2,5) = f(2,6) = f(2,2) = 1$$
 - $$f(3,1) = f(2,0) + f(3,0) = 0$$
 - $$f(3,2) = f(1,1) + f(3,1) = 1$$
 - $$f(3,3) = f(0,2) + f(3,2) = 2$$
 - $$f(3,4) =f(3,5) =f(3,6) =f(3,3) = 2$$
 - $$\cdots$$
 - $$f(6,6) = f(0,5) + f(6,5) = 4$$

---

## 作者：封禁用户 (赞：7)

[原题链接](https://www.luogu.org/problem/P2386)

首先，再好好读一遍题。

提一句，

>5,1,1和1,1,5是同一种方法

这句话要重点读，Ta决定着泥这题是否一排红（滑稽

kk，说正经的了哈

你不妨先人脑算几组

我得出的公式如下：

- $n=1$或$m=0$（也就是只有$1$个盘子或$0$个苹果）

$k=1$

- $m<n$（也就是盘子数多于苹果数）

$k=a[m][m]$

- $m≥n$（也就是盘子数少于苹果数）

$k=a[m][n-1]+a[m-n][n]$

由于数据可能比较大，所以保险起见，函数我开了$long long$

以下是窝的递归$code$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
long long apple(int a,int b) {
	if(a==0||b==1) return 1;
	else if(a<b) return apple(a,a);
	else return apple(a,b-1)+apple(a-b,b);
}
int main() {
	cin>>t;
	for(int i=1; i<=t; i++) {
		cin>>m>>n;
		cout<<apple(m,n)<<endl;
	}
	return 0;
}
```


---

## 作者：安好 (赞：7)

/\*当没有苹果时为一种情况，当只有一个盘子时也有一种情况。（全放与不放)

若a<b,则必定有a-b个盘子空着 f[a][b]=f[a][a]

若a>b分两种情况。1.若 a个苹果放入b-1个盘子里，有一个为空。f[a][b]=f[a][b-1];

2.若没有空盘子，则从每个盘子中拿出一个苹果对方案无影响。f[a][b]=f[a-b][b] ;

方案数等于两者之和 (不断向外拿，定会有空盘子出现，然后转移至情况一)。

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,t,m;
int f[101][101];
int my(int a,int b)
{
    if(a==0||b==1) return 1;
    if(a<0)return 0;
    if(f[a][b]!=-1) return f[a][b];
    f[a][b]=my(a,b-1)+my(a-b,b);
    return f[a][b];
}
int main()
{
    cin>>t;
    memset(f,-1,sizeof(f));
    while(t--)
    {
        cin>>m>>n;
        cout<<my(m,n)<<endl;
    }
}
```

---

## 作者：konglk (赞：5)

本人用的是DFS。规定每个盘子一定要比前一个放的少，这样就不会重复了。

边说代码边解释思路
```cpp
#include<iostream>
using namespace std;
int t,m,n,c=0;//t代表测试组数，m个苹果n个盘子，c代表满足条件的种类数
void dfs(int left,int k,int ma)//left代表放了几个，k代表第几个，ma代表上一个盘子的苹果数，也就是这个盘子最多能放几个
{
	if(left==m&&k==n)//满足条件时
	{
		c++;
		return;
	}
	if(left>m||k>=n)return;//放多了或者盘子超了就返回 注意：k==n是也可以返回，因为已经判断了是否满足条件，若k=n即盘子放满了还没满足条件，则无法满足
	for(int i=ma;i>=0;i--)//不能比上一个盘子多
	dfs(left+i,k+1,i);
}
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>m>>n;
		dfs(0,0,m);//放了0个，第0个盘子，第一个盘子能放m个
		cout<<c<<endl;
		c=0;//记得还原回0！
	}
}
```


---

## 作者：Mr_Squre (赞：5)

改一下楼下一样的画风：

利用三维Dp直接避免重复。f[i][j][k]表示把i个苹果放在前j个盘子里并且第i个盘子放了

k个的方案数，转移的时候注意保持单调不升（降）就可以啦。时间复杂度O(n^4)。

    
        
```cpp
#include<bits/stdc++.h>
#define LL long long  
using namespace std;
LL up,down,f[20][20][20];
int main()
{
    int t,n,m;
    scanf("%d",&t);
    while(t--)
    {
        memset(f,0,sizeof(f));   //注意清零
        scanf("%d%d",&m,&n);
        f[0][0][0]=1;
        for(int i=0;i<=m;++i)
         for(int j=1;j<=n;++j)
           for(int k=0;k<=i;++k)
                for(int l=0;l<=k;++l)
                 f[i][j][k]+=f[i-k][j-1][l];
        int ans=0;
        for(int i=0;i<=m;++i)
         ans+=f[m][n][i];
        cout<<ans<<endl;
    }
}
```

---

## 作者：QianianXY (赞：3)

~~话说离初赛还剩一个星期还有心思水黄题我胆子也是忒大了~~

这里给出个思路不一样的暴搜~~不会记搜和dp的借口~~。

具体看注释：

```cpp
#include <bits/stdc++.h>
#define N 15
#define rei register int
using namespace std;
int t, m, n, f[N][N], ans;
void dfs(int mm, int nn, int last) // mm：当前没用的苹果 nn：剩下的盘子 last：上一个盘子放的苹果 
{
	if (mm < 0) return; // 剪枝，苹果用完了就回头 
	if (!nn) {if (!mm) ans++; return;} // 盘子用完了返回，如果苹果恰好用完，ans加一 
	for (rei i = mm; i >= 0; i--)
		if (i <= last)
			dfs(mm - i, nn - 1, i);
}
int main()
{
	scanf("%d", &t);
	for (rei i = 1; i <= t; i++)
	{
		ans = 0;
		scanf("%d%d", &m, &n);
		dfs(m, n, 0x7f);
		printf("%d\n", ans);
	}
	return 0;
}
```

解释下last的作用：手动模拟一下小数据，自大到小排列一下方案，就会发现盘子里苹果数降序排列的方案数量，恰好等于符合题意的方案数量。根据这一点模拟出搜索函数。~~数学证明的过程就不要难为小蒟蒻了好吗~~总而言之last就是避免方案重复。

最后祝所有$OIerCSPRP++$

---

## 作者：hongzy (赞：3)

### 方法1：搜索

用搜索做，这题难度就降了不少


提供一种简单思路:从1深搜到K,保证当前盘子苹果比上个盘子多(防止重复)，不断计数.

```cpp
#include <iostream>
using namespace std;

//5个参数:上个数、当前需要分配的数、盘子编号(从0开始)、k、方案数 
void DFS(int last, int n, int x, const int k, int &tot) {
    if(x == k) { //已经分了K次 
        if(n == 0) tot ++; //一种方案 
        return;
    }
    for(int i=last; i <= n; i ++) //一定要保证当前数不小于上个数 
        F(i, n-i, x+1, k, tot);
}

int main() {
    int T, n, k, tot;
    cin >> T;
    while(T --) {
        cin >> n >> k;
        DFS(0, n, 0, k, tot = 0); //tot记得赋0 
        cout << tot << endl;
    }
    return 0;
}


```
### 方法2：DP

这题不能就这么放过了，当然要用DP再做一遍


也可以说是递推做法，这个思路像是把大多数递归的题解逆过来


~~（不管怎么说，比递归要快）~~


.

.

思路：F[i][j]表示i分成j份（可空）的方法总数







```cpp
if i == 0 or i == 1 or j == 1
then F[i][j] = 1;
else if i < j
then F[i][j] = F[i][i]; //份数多了无用(一定有空份)，因此总数就是F[i][i]
else F[i][j] = F[i-j][j] + F[i][j-1];
```
最后这个转移方程是这么来的：

分类讨论，若这j份里有空份，取出那空份来，得到方案数F[i][j-1]


若无空份，说明每份至少为1，那就每份取一个1，剩下i-j的数接着分，方案数F[i-j][j]


最后相加得到最终方案数.


```cpp
#include <iostream>
using namespace std;

const int MAXN = 100, MAXK = 100;
int F[501][501];
int T, n, k;

int main() {
    /*预处理*/
    for(int i=0; i<MAXN; i ++)
        for(int j=1; j<MAXK; j ++) {
            if(i < 2 || j == 1) F[i][j] = 1;
            else if(i < j) F[i][j] = F[i][i];
            else F[i][j] = F[i][j-1] + F[i-j][j];
        }
    cin >> T;
    while(T --) {
        cin >> n >> k;
        cout << F[n][k] << endl; //直接输出 
    }
    return 0;
}

```



---

## 作者：新手7889456 (赞：2)

看下面都是动归dalao，我只能蒟蒻地发一篇DFS的题解（叹）

------------

步入正题：
怎么搜呢？

1.首先，先打出一个暴搜（看注释）：

```cpp
void dfs(int n,int m){//n表示还剩多少苹果，m表示还剩多少盘子
	if(m==0){//当没有盘子时return
		if(n==0)//如果恰好放完苹果，则答案+1
		++ans;
		return;
	}
	for(register int i(0);i<=n;++i){//枚举这个盘子放的苹果数
		dfs(n-i,m-1);
	}
}
```

然后就会有一个烧脑的问题，有重复的怎么办？？？

2.我们可以用条件来限制TA

如果每一个盘子放的苹果数都大于上一个盘子放的苹果数，就能保证唯一性了。

```
void dfs(int n,int m,int sh){//sh表示上一个盘子放了多少个
	if(m==0){
		if(n==0)
		++ans;
		return;
	}
	for(register int i(sh);i<=n;++i){//从上一个开始枚举
		dfs(n-i,m-1,i);
	}
}
```

3.这时你会发现可能会超时

这时我们可以用到某个计数原理：在第i个盘子里放的苹果数不能大于$\frac{n}{m}$(n,m的意义在上面的代码中)，否则就会破坏【每一个盘子放的苹果数都大于上一个盘子放的苹果数】的规则。

完整的AC代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int ans;
void dfs(int n,int m,int sh){
	if(m==0){
		if(n==0)
		++ans;
		return;
	}
	for(register int i(sh);i<=n/m;++i){//解释如上
		if(n-i>=0)
		dfs(n-i,m-1,i);
		else
		break;
	}
}
int main(){
	register int t,n,m;
	scanf("%d",&t);
	for(register int okko(0);okko<t;++okko){
		ans=0;
		scanf("%d%d",&n,&m);
		dfs(n,m,0);
		printf("%d\n",ans);
	}
	return 0;
}
```

终于写完了，求过。。。


---

## 作者：ftjy (赞：2)

# c++代码注释及源程序
### 基本思路：递归
代码如下：
```cpp
#include<iostream>
using namespace std;

int ans;

void todo(int m,int n,int s){//m表示还剩多少个，n表示还剩几个盘子，s为最小数目 
	if(n==1){ans++;return;}
	for(int i=s;i<=m/n;++i)todo(m-i,n-1,i);		
}

int main(){
	int M,N,t;
	cin>>t;
	for(int i=0;i<t;++i){
		ans=0;
		cin>>M>>N;
		todo(M,N,0);
		cout<<ans<<endl;
	}	
	return 0;
}
```
### 主要就是递归段的含义问题，这道题目数据量不是很大，所以递归加一定的剪枝可以轻松AC！

递归前进段：为了避免重复查找一种方法，加入了变量s为了防止重复。i表示的是当前盘子中要放的苹果数量。m/n为了防止盘子中的苹果数量太多，所以加了一个条件限制，使苹果可以均匀分配，又进行了一些剪枝。然后就是递归函数了，很简单的！

递归返回段：当盘子数量等于1时计数返回，就可以不用计算剩下的最后一个盘子要放多少苹果了，再次进行优化！

### 所以程序效率已经可以达到较高的地步了，对付此题绰绰有余！

---

## 作者：yszshs1 (赞：2)

## 首先，这道题数据范围特别小！！！
首先，我们分析一下样例：
	把7个苹果放到3个盘子里，所以有一下分法：![](https://cdn.luogu.com.cn/upload/pic/70114.png)
    分析可得，设盘子i里放ai个苹果，则
###     a1>=a2>=a3>=...>=ai
###     a1>=a2>=a3>=...>=ai
###     a1>=a2>=a3>=...>=ai
重要的东西说三遍！

所以我们可以将普通的暴力枚举优化，自动去重，得到答案
# 同志们，见代码

```cpp
//P2386
//请大家注意，看代码从主程序开始看，不要先看函数
#include<iostream>
#include<cstdio>
using namespace std;
int ans,m,n;
int a[11];
void dfs(int step,int sum)
{
	if (step==n)//当放到最后一个盘子时
	{
		if ((m-sum)>=a[step-1])//如果an满足条件的话
        {ans++; a[step]=m-sum;}//答案加1
		return;//返回
	}
	for (int i=a[step-1];i<=m;i++)//枚举，从a[step-1]开始可以减少循环次数
		{a[step]=i; dfs(step+1,sum+i);}//赋值，向下一步枚举
}
void work()
{
	cin>>m>>n;//读入，不多说
	ans=0;//每次将答案清零
	a[0]=0;//将a0置为0，待会有用
	dfs(1,0);//开始枚举大法
	cout<<ans<<endl;//输出
}
int main()
{
	ios::sync_with_stdio(false);//输入输出优化
	int t;
	cin>>t;//测试数据组数
	for (int i=1;i<=t;i++)
		work();//准备点火
	return 0;
}

```
本题不难，关键在于条件的发现。
# 谢谢大家QAQ

---

## 作者：water_lift (赞：2)

比较简单的dfs。没有过多优化。注意为了保证没有重复，可以让后面的必须大于前面的。

直接贴代码，大佬勿喷。



```cpp
#include<iostream>
using namespace std;
int t,m,n;
int ans;
void dfs(int a,int l,int k){//当前剩余a个苹果，最大值l个，枚举第k个盘子
    if(k==n+1){             //枚举完成时 
        if(a==0)ans++;      //必须全部放到盘子里 
        return;
    }
    for(int i=l;i<=a;i++){  //第k个盘子放i个苹果。每个盘子里的数量要比前一个多，但也不能超过剩余数量
        dfs(a-i,i,k+1);     //当前剩余a-i个苹果，最大值i个，枚举第k+1个盘子 
    }
}
int main(){                 //主函数 
    cin>>t;
    while(t--){             //t次循环 
        ans=0;
        cin>>m>>n;
        dfs(m,0,1);         //当前剩余m个苹果，最大值0个，枚举第1个盘子 
        cout<<ans<<endl;
    }
}
```
以m=2，n=2为例:
```cpp
dfs(2,0,1)
 dfs(2,0,2)
  dfs(2,0,3)
  dfs(1,1,3)
  dfs(0,2,3)    ans++
 dfs(1,1,2)
  dfs(1,1,3)    ans++
dfs(0,2,2)
```

---

## 作者：drzo (赞：2)

```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <queue>
#include <iomanip>
using namespace std;
int cnm(int m,int n)
{
    if(n==1)
    return 1;
    if(m==1)
    return 1;
    if(m<n)
    return cnm(m,m);
    if(m==n)
    return 1+cnm(m,m-1);
    if(m>n)
    return cnm(m,n-1)+cnm(m-n,n);
}
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    int t,n,m,i;
    cin>>t;
    for(i=0; i<t; i++)
    {
        cin>>n>>m;
        cout<<cnm(n,m)<<endl;
    } 
    return 0;
}

```

---

## 作者：__gcd (赞：1)

这题明显是一个深搜

当然我们知道苹果数的顺序不同是算作一种方案的，所以本题最中心的就在于如何去重。

那么我们就可以选取可行方案的一个特殊苹果数序列来搜索，来达到去重的目的。

很容易就能想到不下降（或不上升）的序列吧。

接下来就看一下代码怎么实现。

------------
* 第一点：如何找寻深搜中的$ max i $和 $min i$

深搜的步骤里有枚举的过程，在这里面必须找$i$的最大值和最小值，最小值显然就是上一个盘子里放的苹果，最大值就要保证后面的也能是一个不下降序列。

那不就是剩余苹果在剩余盘子中的平均值吗？

所以得到$maxi=(n-sum)/(m-k+1)$

* 第二点：搜索的次数能否再少一些？

因为和是一定的，所以在搜到第$m-1$个盘子的时候，最后一个盘子的苹果数就已经知道了，所以在放最后一个盘子之前搜索就结束了。

所以结束条件就是$k==m$(而非$k>m$)

最终代码
```
#include<cstdio>
using namespace std;
int ans,n,m,t,sum=0,nextmin=0;
int read()//快读 
{
	int x=0,y=1;
	char c=getchar();
	while(c>'9'||c<'0')
	{
		if(c=='-')y=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*y;
}
void dfs(int k)//放第k个盘子的苹果 
{
	if(k==m) 
	{
		ans++;//方案数加一 
		return;
	}
	for(int i=nextmin;i<=(n-sum)/(m-k+1);i++)//从最小到最大枚举 
	{
		nextmin=i;//将当前盘子放入的水果数记录，保证不下降 
		sum+=i;//总苹果数加上当前盘子的苹果 
		dfs(k+1);//搜索下一个盘子 
		sum-=i;//回溯 
	}
}
int main(){
	t=read();
	for(int i=1;i<=t;i++)
	{
		ans=0;nextmin=0;sum=0;//清零（因为可以不放所以nextmin为0） 
		n=read();m=read();
		dfs(1);
		printf("%d\n",ans);//输出 
	} 
	return 0;//开开心心地结束 
}
```

---

## 作者：gary2005 (赞：1)

****看到这个数据范围我只能呵呵了**** 

# 1＜=M，N＜=10

### 暴力就可以拿下

不过为了追求速度，我采用了  **打表法**，可以说是
~~最不要脸~~的方法了

先看下表

```cpp
int biao[10][10]=
{{1,1,1,1,1,1,1,1,1,1},
{1,2,2,2,2,2,2,2,2,2},
{1,2,3,3,3,3,3,3,3,3},
{1,3,4,5,5,5,5,5,5,5},
{1,3,5,6,7,7,7,7,7,7},
{1,4,7,9,10,11,11,11,11,11},
{1,4,8,11,13,14,15,15,15,15},
{1,5,10,15,18,20,21,22,22,22},
{1,5,12,18,23,26,28,29,30,30},
{1,6,14,23,30,35,38,40,41,42},
};
```
那有人就要问了这个表是怎么来的呢？

没错就是

# DFS！

首先dfs参量得弄清
```cpp
dfs(int apple,int dish,int last,int now)
```
1. apple:手头现有苹果
2. dish:总共多少盘子
3. last:上一个
4. now:以装填第几个盘子

搞清了这个就很简单了

首先边界值是
```cpp
if(now==dish){
		if(apple==0)/*只有苹果放完才算*/ ans++;
		return;
	}
```
后面的内容是
```cpp
for(int i=last;i<=apple;i++){
		apple-=i;//减去手头现有苹果
		dfs(apple,dish,i,now+1);//递归下一个
		apple+=i;//回溯
	} 
```
那为什么要i=**last**;i<=apple;i++呢？原因很简单因为不能重复所以最简单的方法就是之后的每一个都**≥**前一个。

好了重点已经差不多了现在上代码（打表代码）


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans=0;
void dfs(int apple,int dish,int last,int now){
	if(now==dish){
		if(apple==0) ans++;
		return;
	}
	for(int i=last;i<=apple;i++){
		apple-=i;
		dfs(apple,dish,i,now+1);
		apple+=i;
	} 
}
int main(){
	for(int i=1;i<=10;i++){//apple
	cout<<'{';
		for(int j=1;j<=10;j++){//dish
			ans=0;
			dfs(i,j,0,0);
			cout<<ans<<',';
		}
		cout<<'}'<<endl;
	} 
	return 0;
}
```
输出大概是这样：
![](https://cdn.luogu.com.cn/upload/pic/45804.png)
微加处理就可

# **AC**

---

## 作者：quantum11 (赞：1)

先放在上一种情况里不空的盘子里，能放的数量就等于上一种情况的数量

如果苹果数量大于等于盘子的数量，就先在每个盘子里都放一个苹果，然后就是用剩下苹果来放盘子

本人经过以上方法的递推，得到以下表格（横为苹果数，竖为盘子数）

```cpp
    1    2    3    4    5    6    7    8    9    10
1    1    1    1    1    1    1    1    1    1    1
2    1    2    2    3    3    4    4    5    5    6
3    1    2    3    4    5    7    8    10    12    14
4    1    2    3    5    6    9    11    15    18    23
5    1    2    3    5    7    10    13    18    23    30
6    1    2    3    5    7    11    14    20    26    35
7    1    2    3    5    7    11    15    21    28    38
8    1    2    3    5    7    11    15    22    29    40
9    1    2    3    5    7    11    15    22    30    41
10    1    2    3    5    7    11    15    22    30    42
```
# 附上代码：

```cpp
#include<cstdio>
using namespace std;
long t,m,n,i,j,a[11][11]={0};
int main()
{
    scanf("%d",&t);
    for(i=1;i<=10;i++)
    a[0][i]=1;//赋初值
    for(i=1;i<=10;i++)
    {
        a[i][1]=1;//赋初值
    for(j=2;j<=10;j++)
    {
        a[i][j]=a[i][j-1];//先加上空一个盘子的
        if(i>=j) a[i][j]+=a[i-j][j];//如果苹果数量大于等于盘子的数量，就先在每个盘子里都放一个苹果，然后就是用剩下苹果来放到盘子里
    }
    }
    for(i=1;i<=t;i++)
    {
        scanf("%d%d",&m,&n);//输入
        printf("%d\n",a[m][n]);//输出
    }
    return 0;
}
```

---

## 作者：檀黎斗·神 (赞：1)

看了一下已经发的题解，大部分都是用递归写的

毕竟这题的测试数据有点水

如果这道题的数据大一点呢

所以我这里提供一个递推的代码

这里简单说一下我的思想

其实和很多人思路都是一样的

先建立一个二维数组

只有一个盘子或一个苹果的时候当然只有一种方法啦

所以我们就可以将边界条件建立好了

而当苹果数量m小于盘子数n，这时候肯定放不满盘子

此时最多也只能放m个盘子

而如果苹果数量m大于等于盘子数n，我们此时有两种方法存放苹果

1.每个盘子里放一个苹果

2.空置一个盘子，再对剩下的盘子进行处理

如果我们提前处理好二维数组，就可以在快速的输出答案了

下面贴出代码


      
```cpp
#include<cstdio>
using namespace std;
int a[205][205],t,n,m; 
//a就是我们对存放方法进行处理的二维数组，t是测试的次数，200是我随手打的，还是要看题目数据范围啊
int main()
{
    scanf("%d",&t);
    for(int i=0;i<=200;i++)
     for(int j=0;j<=200;j++)
     {
         if(i==1||j==1||i==0) a[i][j]=1;
         else if(i<j) a[i][j]=a[i][i];
         else a[i][j]=a[i-j][j]+a[i][j-1];
     } //对我们的数组进行预处理，处理思想上面已经说清了
    for(int i=1;i<=t;i++)
     {
         scanf("%d%d",&m,&n);
         printf("%d\n",a[m][n]);
     } // 处理完之后输出的时候就可以直接输出了
    return 0;
}
```

---

## 作者：MloVtry (赞：1)

首先我们可以想一下如果不能放空的，我们有什么解法：

dp[i][j],表示i拆分成j个不为0的数有多少方案

我们可以想到，dp[i][j]=dp[i-j][1]+dp[i-j][2]+dp[i-j][3]+...+dp[i-j][j-1]+dp[i-j][j]【把 i 个果子 放进 j 个盘子里，其情况等于将i-j个果子放进1个盘子【我们在每个盘子上放上一个，保证不为零，此后相当于把剩下的放进一个盘子里，两个盘子里，三个盘子里....】】

同理，dp[i-1][j-1]=dp[i][j]+dp[i-j][1]+dp[i-j][2]+dp[i-j][3]+...+dp[i-j][j-1]

dp[i][j]-dp[i-1][j-1]=dp[i-j][j]，再移项：

dp[i][j]=max(dp[i-j][j]+dp[i-1][j-1],dp[i][j]);

然后，我们就有了把i拆分成j个不为0的数有多少方案

但是我们要解决为0的情况

既然可以有盘子为空，那么，其实就相当于把i个果子放进1个盘子的【剩下空着】+把i个果子放进2个盘子的+把i个果子放进3个盘子的+...+把i个果子放进j个盘子的

也就是

ans=ans+=dp[n][i]【i：1->J】

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int t,n,k,dp[1000][1000];
int main()
{
    scanf("%d",&t);
    for(int zz=1;zz<=t;++zz)
    {
        memset(dp,0,sizeof(dp));
        scanf("%d%d",&n,&k);
    dp[0][0]=dp[1][1]=1;
/*    for(int i=1;i<=k;++i)
    {
        dp[0][i]=1;
     } */
    for(int i=1;i<=n;++i)
        for(int j=1;j<=k;++j)
        {
            if(i<j)
            {
                //dp[i][j]=dp[i][j-1];
                dp[i][j]=0;
                continue;
            }
            dp[i][j]=max(dp[i-j][j]+dp[i-1][j-1],dp[i][j]);
        }
    int ans=0;
    for(int i=1;i<=k;++i) ans+=dp[n][i]; 
    cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：伤风 (赞：1)

dp，主方程f[i,j]:=f[i-j,j]+f[i,j-1];

```cpp
uses math;
var
  t,mb,nb,i,j,l,fe:longint;
  m,n:array[1..2000] of longint;
  f:array[0..20,0..20] of longint;
begin
  read(t);
  for l:=1 to t do begin
   read(m[l],n[l]);
   mb:=max(m[l],mb);
   nb:=max(n[l],nb);//求最大的m,n
  end;
        for j:=0 to min(mb,nb) do//通过if i<j then f[i,j]:=f[i,i];简化
        for i:=0 to mb do      //这样只需一次了
          begin
            if (i<2) or (j<2) then f[i,j]:=1
            else begin
             if i>=j then f[i,j]:=f[i-j,j]+f[i,j-1];
             if i<j then f[i,j]:=f[i,i];
          end;end;
      for l:=1 to t do
      writeln(f[m[l],min(m[l],n[l])]);
end.
```

---

## 作者：清风我已逝 (赞：1)

数据太小，搜索大法好

此类题目可以使用如下代码，暴力搜索推规律

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int t,m,n,ans,p[15];

void print(){
	int an=0;
	for(int i=1;i<=n;i++){
		an+=p[i];
		printf("%d ",p[i]);
	}
//	if(an==m) ++ans;
	puts("");
}

void dfs(int k,int X,int last){
	if(k==n+1){
//		print();
		if(X==0) ++ans;
		return;
	}
	for(int i=last;i<=X;i++){
		p[k]=i;
		dfs(k+1,X-i,i);
	}
}

int main()
{
	scanf("%d",&t);
	while(t--)
	{
		ans=0;
		scanf("%d%d",&m,&n);
		dfs(1,m,0);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Violette (赞：0)

### 注意：这道题要不能用排列组合的方法做。

先理解一下题意：

参看输入样例1、7个苹果，三个盘子：

```cpp
0 0 7
0 1 6
0 2 5
0 3 4
1 1 5
1 2 4
1 3 3
2 2 4
```
总共有8种放法。

那么具体是怎么算出来的呢？

题中写了5,1,1和1,1,5是同一种方法，所以如果是三个盘子，假设为

a,b,c，要保证不重不漏的话，必须满足a<=b<=c。

放完第一个盘子，假设放了0个，那么此时还剩下7-0=7个苹果，还有

两个盘子，每个盘子至少放0个，记为（7,2,0）

如果放了一个，此时还剩下7-1=6个苹果，还有两个盘子，每个盘子至

少放1个，记为（6,2,1）

以此类推，考虑使用递归。

整体思路：使用递归，定义一个有返回值的函数，直接返回答案。

其余的参考代码注释。

```cpp
#include<iostream>
using namespace std;
int cal(int m,int n,int minn){//定义三个参数 
	if(n==1) return 1; //简单情况 
	int sum=0; 
	for(int i=minn;i<=m/n;i++)//最少放minn个，最多放m/n个 
	sum+=cal(m-i,n-1,i);//还剩m-i个苹果，n-1个盘子，最少放i个
	return sum; 
}
int main(){
	int t;
	int m,n;
	cin>>t;
	while(t--){//注意多组数据，使用while或for循环 
	cin>>m>>n;
	cout<<cal(m,n,0)<<endl;
	}
	return 0;
}
```
整体来说，递归部分不算很难，可以采用以小博大的思路。

---

## 作者：沧海映繁星 (赞：0)

这个题目我看到后马上就想到了一个题 P1025 【数的划分】，就是那个可以不放有一点烦人，于是我想到了一种可以避开这个问题的办法，具体请看代码
```
#include<bits/stdc++.h>
using namespace std;
int ans,m,n,a;//ans:表示每次的答案 m:表示苹果的数量 n:表示盘子的个数 a:表示计算的次数 
void dfs(int num,int p,int s)
{
    if(s+n-p>m) return;//剪枝，原理：因为苹果的个数都是正整数，所以当现在的数字大于剩下的苹果数量时，直接跳出 
    if(p==n&&s<m) return;//当盘子数量达到n，已放的苹果却不到m个，不满足，跳出 
    if(p==n&&s==m)//当条件满足，累加方案数量 
    {
        ans++;
        return;
    }
    for(int i=num;i<=m-s;i++)//继续搜索，利用后面的苹果数量小于或等于前面的苹果数量，去除重复 
    {
        dfs(i,p+1,s+i);
    }
    return; 
}
```
以上为头文件和递归函数，这里和之前提到的 P1025 【数的划分】是没有什么区别的，接下来才是重点。
```
int main()
{
	cin>>a;//输入计算次数 
	for(int x=1;x<=a;x++)
	{
		cin>>m>>n;//输入苹果和盘子的个数 
		while(n>0)
		{
			for(int i=1;i<=m-n+1;i++)
			{
				dfs(i,1,i);
			}
			n--;
		}//处理一下，解释在代码后面。 
		cout<<ans<<endl;
		ans=0;//清空方案数 
	}
	return 0;
}
```
下面我来解释一下之前的运算代码：
    目中说，可以有盘子不放苹果，也就是说，当有P个盘子不放时，就相当于将m个苹果，放入剩下的（n-p）个盘子中。这样想来，只需枚举所有不放苹果的盘子的个数的情况，运算后再把方案数相加就可以将题目转化为“求将m个苹果，放入1,2……n个盘子中的方案数量之和，且每个盘子至少放一个苹果”。

---

## 作者：小黑 (赞：0)

本来是noi题库里的dp经典例题，但是题实在太水所以搜索也能过(＃°Д°)

dp的代码如下，方程就是f[i,j]:=f[i-j,j]+f[i,j-1]


两种情况：至少一个盘子为空的方案数（f[i,j-1]）

每个盘子都至少有一个苹果（f[i-j,j]）

```cpp
[codep]var
  t,m,n:longint;
  i,j,l:longint;
  f:array[0..20,0..20] of longint;
begin
  read(t);
  for l:=1 to t do
    begin
      read(m,n);
      for i:=1 to m do
        for j:=1 to n do
          begin
            if (i=1) or (j=1) then f[i,j]:=1;
            if i>j then f[i,j]:=f[i-j,j]+f[i,j-1];
            if i=j then f[i,j]:=f[i,j-1]+1;
            if i<j then f[i,j]:=f[i,i];
          end;
      writeln(f[m,n]);
    end;
end.[/codep]
```

---

## 作者：Invisible (赞：0)

	这道题可以推一波规律。
	如果说 i 表示盘子的个数， j 表示苹果的个数， a[j][i] 表示将 j 个苹果放到 i 个盘子里的方案数。（当然，在这种条件下，盘子不可能为空，例如a[3][1]表示将3个苹果放到一个盘子里的方案数，a[3][2]表示将3个苹果放到2个盘子里的方案数，a[3][3]表示将3个苹果放到3个盘子里的方案数）
	这时候，我们定义一个函数cal(calculate的缩写)。用它来表示a[3][1]+a[3][2]+a[3][3];
	int cal(int x)
	{
		int ans=0;
		for(int i=1;i<=x;i++)
		{
			ans+=a[x][i];
		}
			return ans;
	}
	那么很容易得到以下几点：
	1.如果将 j 个苹果放到 1 个盘子里的话，有且只有一种方案（这是很明显的），即 a[j][1]=1 。
    2.如果将 j 个苹果放到 j 个盘子里的话，有且只有一种方案（这也是很明显的），即 a[j][j]=1 。
    3.如果盘子的数量 i 大于苹果的数量 j ，那么这种情况下是不存在合法的方案数的。（因为不可能将苹果切开的），即 
    if(i>j)
    {
    	a[j][i]=0;
    }
    好了，有了以上三点,初始化就很好搞了。
    for(int i=1;i<=10;i++)
	{
		a[i][1]=1;
	}
	for(int i=1;i<=10;i++)
	{
		for(int j=1;j<=10;j++)
		{
			if(j==i)
			{
				a[i][j]=1;
			}
		}
	}
    下面，就是重点，请拿出笔记本，做好笔记。
    首先我们的问题是：将j个苹果放到i个盘子里的方案数是多少(当然前提是j>=i)。
    对于一个a[j][i]，也就是说我们要将j个苹果放到i个盘子里，并且没有盘子为空。那么的话，不妨先在每一个盘子里面放一个苹果，这样，我们还有j-i个苹果需要放。
    那么，我们的问题就转变成了：将j-i个苹果随机放入盘子的方案数是多少。
    这时候，不妨举一个例子：
    假设我们有7个苹果，3个盘子，即i=3，j=7；先在每一个盘子里放一个苹果（因为没有盘子为空）。这时候，我们还有4个苹果需要放。
    那么，四个苹果怎么放？
    可以全放到一个盘子里，这时候的方案就是1,1,1+4。
    可以放到两个盘子里，这时候的方案就是1,1+1，1+3，或者1，1+2,1+2。
    可以放到三个盘子里，这时候的方案就是1+1,1+1,1+2。
    这个时候观察一下，就会灵光一闪：其实这个问题就转变成了求4个苹果放到1个盘子，2个盘子，3个盘子的方案数的总和。
    这样的话，转化成一般形式：
    a[j][i]=cal(j-i);
    有了这个思路，初始化一下，代码自然而然就写出来了。
    ```cpp
    //Okita Souji
	#include<iostream>
	#include<cstdio>
	#include<algorithm>
	#include<cstring>
	#include<cmath>
	using namespace std;
	int t,n,m;
	int ans;
	int a[11][11];
	int cal(int x)
	{
		int ans=0;
		for(int i=1;i<=x;i++)
		{
			ans+=a[x][i];
		}
		return ans;
	}
	int main()
	{
		for(int i=1;i<=10;i++)
		{
			a[i][1]=1;
		}
		for(int i=1;i<=10;i++)
		{
			for(int j=1;j<=10;j++)
			{
				if(j==i)
				{
					a[i][j]=1;
				}
				if(i<j)
				{
					a[j][i]=cal(j-i);
				}
			}
		}
	/*	for(int i=1;i<=10;i++)
		{
			for(int j=1;j<=10;j++)
			{
				cout<<a[i][j]<<" ";
			}
			cout<<endl;
		}
	*/	cin>>t;
		for(int i=1;i<=t;i++)
		{
			cin>>m>>n;
			ans=0;
			for(int j=1;j<=n;j++)
			{
				ans+=a[m][j];
			}
			cout<<ans<<endl;
		}
		return 0;
	}


```

---

## 作者：Malefic (赞：0)


### 题目描述


把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分发（5,1,1和1,1,5是同一种方法）

##### 输入输出格式

输入格式：


第一行是测试数据的数目t（0 <= t <= 20），以下每行均包括二个整数M和N，以空格分开。1＜=M，N＜=10


输出格式：


对输入的每组数据M和N，用一行输出相应的K。


##### 输入输出样例

输入样例#1：


1
7 3

输出样例#1：


8

这题可以用递归来做，定义一个函数fun(m,n)返回在n个盘子里放m个苹果的值。


#### 返回值：

- 我可以把m个苹果都放入n个盘子中，但也可以留着1个或几个盘子不放苹果，即把m个苹果放入n-1或n-？个盘子。

- 假设我 **在n个盘子中都放苹果**，那么我先一个盘子放一个，那么剩下的m-n个苹果的放法，就和 **把m-n个苹果放进n个盘子中** 一样了

- 但要是我 **只放n-1或n-?个盘子** 呢？我们可以发现，n-？其实也可以等于n-1-1-1-……，这样我们就可以只考虑 **把m个苹果放入n-1个盘子** 的情况就好了。

- 综上所述，f(m,n) 的返回值:

        return fun(m-n,n)+fun(m,n-1);

#### 边界条件：

- 如果我没有苹果只有盘子，那算不算是1种放法？

- 如果我只有一个盘子，那我只能把所有的苹果放进同一个盘子里，也只有一种放法。

- 当盘子多于苹果的时候，m-n会是个负数，这时就没有意义了，所以返回0。当然对于这点来说，如果当n>m时，其实我们最多也只能放m个盘子，剩下的留空，这种情况与 **将m个苹果放入m个盘子中** 相同，故返回fun(m,m)，并且这样可以保证不会出现苹果是负数的情况。

- 所以，边界条件有:

        if(m==0||n==1) return 1;

        if(m<0) return 0;

        // 可以换成 if(n>m) return fun(m,m);

那~这题就写完了呗√


最后附上代码：

```cpp
        #include <stdio.h>
        int t,m,n;
        int fun(int m,int n){
            if(m==0||n==1) return 1;
            if(m<0) return 0;
            //if(m<n) return fun(m,m);
            return fun(m,n-1)+fun(m-n,n);
        }
        int main()
        {
            scanf("%d",&t);
            while(t--){
                scanf("%d%d",&m,&n);
                printf("%d\n",fun(m,n));
            }
            return 0;
}
```

---

## 作者：Fraction (赞：0)

啊，曾经纯真地认为此题与P1025一样 结果才WA了一堆······


真棒 递归不会TLE 好消息啊


此题数据其实可以分为三种情况：

1.没苹果：只有盘子 一种情况 直接返回1

2.盘子比苹果还多：一定有盘子放不满，返回f(m,m)

3.苹果数量≥盘子数量：开始正常的递归f(m,n-1)+f(m-n,n)，尝试各种情况


代码如下

```cpp
#include <stdio.h>
int f(int m,int n){
    if(m==0||n==1) return 1;//没有苹果，只有盘子，当然只有一种方法 
    if(m<n) return f(m,m);//盘子比苹果多，绝对放不满 
    return f(m,n-1)+f(m-n,n);//正常运作 尝试每一次 
}
int main(){
    int m,n;
    int i;
    scanf("%d",&i);//刚看到这个真觉得要TLE了 
    for(int j=1;j<=i;j++){
        scanf("%d%d",&m,&n);
        printf("%d\n",f(m,n));//函数调用 
    }
    return 0;
}
```

---

## 作者：水墨书香 (赞：0)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int put(int a,int b) //递归——a：苹果数；b:盘子数；
{
if(a==1||b==1||b==0)    return 1;
//只有 1个苹果/1个盘子/0个盘子时：只有一种情况，方案=1，可返回上一层。
if(a==b)    return put(a,b-1)+1;
```
/\*苹果与盘子数相等时：
1.每盘1个，方案=1；

2.使盘子空缺，总盘数-1，进入下一层；

所以，进入少一个盘子（即一个盘子不放）的情况，并且方案+1。\*/

if(a<b)    return put(a,a);

//苹果小于盘子数时：最多放满a个盘子，此时盘子数减为a，进入下一层。

if(a>b)    return put(a,b-1)+put(a-b,b);

/\*苹果多于盘子数，此时应当考虑多种请况：

1.如同条件2的第二种情况；

2.每盘一个的方案是否需要考虑呢？不需要，因为只有苹果全部放在盘子里且方案不重复，才算是一种方案。所以对于这个问题，方案应是，对多余部分（即每盘放一个，多出来的苹果数a-b）重新排列，将其方案数加到这一步的总方案中。

所以，put（a,b-1）与put(a-b,b)的结果相加。


```cpp
}
int main()
{
int m,n,k;
cin>>k;
for(int i=1;i<=k;i++)
{
cin>>m>>n;
cout<<put(m,n)<<endl;
}
return 0;
}
```

---


# [1007] 魔法少女小Scarlet

## 题目描述

Scarlet 最近学会了一个数组魔法，她会在 $n\times n$ 二维数组上将一个奇数阶方阵按照顺时针或者逆时针旋转 $90^\circ$。

首先，Scarlet 会把 $1$ 到 $n^2$ 的正整数按照从左往右，从上至下的顺序填入初始的二维数组中，然后她会施放一些简易的魔法。

Scarlet 既不会什么分块特技，也不会什么 Splay 套 Splay，她现在提供给你她的魔法执行顺序，想让你来告诉她魔法按次执行完毕后的二维数组。

## 说明/提示

对于50%的数据，满足 $r=1$

对于100%的数据 $1\leq n,m\leq500$，满足 $1\leq x-r\leq x+r\leq n,1\leq y-r\leq y+r\leq n$。

## 样例 #1

### 输入

```
5 4
2 2 1 0
3 3 1 1
4 4 1 0
3 3 2 1```

### 输出

```
5 10 3 18 15
4 19 8 17 20
1 14 23 24 25
6 9 2 7 22
11 12 13 16 21```

# 题解

## 作者：黎曦の夜 (赞：247)

第一次写题解。。 主要是看着题解的大佬的代码太长，~~有的同学可能不喜欢看~~，我就给个短一点的。这个很好推到的，模拟一下就行啦！


```cpp
#include<bits/stdc++.h>
using namespace std;
int g[510][510],tot,f[510][510];//f数组充当临时数组 
int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			g[i][j]=++tot;
	for(int i=1;i<=m;i++) {
		int a,b,r,opt;
		scanf("%d %d %d %d",&a,&b,&r,&opt);//下面的分析都是针对那一块矩阵而言的 
		if(opt==0) {//第i行第j个 变成倒数第i列第j个 顺时针 
			for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					f[a-b+j][a+b-i] = g[i][j];
			for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					g[i][j] = f[i][j];
		}
		else { //第i行第j个 变成第i列倒数第j个 逆时针 
			 for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					f[a+b-j][b-a+i] = g[i][j];
			 for(int i=a-r;i<=a+r;i++)
				for(int j=b-r;j<=b+r;j++)
					g[i][j] = f[i][j];
		}
	}
	for(int i=1;i<=n;i++) {//输出结果咯 
		for(int j=1;j<=n;j++)
			printf("%d ",g[i][j]);
		printf("\n");
	}
	return 0;
} 
```

---

## 作者：BzhH (赞：127)

第一次发布题解，请多多谅解
这道题直接模拟就可以做出来
了。

首先是顺时针旋转90°部分
如图一个3*3的矩阵
| 1 | 2 | 3 |	
| :----------: | :----------: | :----------: |
| 4 | 5 | 6 |
| 7 | 8 | 9 | 

顺时针旋转过后
| 7 | 4 | 1 |
| -----------: | -----------: | -----------: |
| 8 | 5 | 2 |
| 9 | 6 | 3 |
由此可以看出
第a行数字与第a列数字有关系
所以可以得出以下代码


```cpp
void spin(int x,int y,int r)
{
	for(int i=x-r;i<=x+r;i++)
	{
		for(int k=y-r;k<=y+r;k++)
			temp[i][k]=square[i][k];
	}//将以（x,y)为中心的(2r+1）*（2r+1）的矩阵赋给temp
	int x1=x+r,y1=y-r;
	for(int i=x-r;i<=x+r;i++)
	{
		for(int k=y-r;k<=y+r;k++)
		{
			square[i][k]=temp[x1][y1];//将某一列的数字赋值给某一列
			x1--;
		}
		x1=x+r,y1++;
	}
}
```
同上，可以得出逆时针旋转90°
完整代码如下
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int square[505][505],temp[505][505];

void spin(int x,int y,int r)//顺时针旋转90°
{
	for(int i=x-r;i<=x+r;i++)
	{
		for(int k=y-r;k<=y+r;k++)
			temp[i][k]=square[i][k];
	}
	int x1=x+r,y1=y-r;
	for(int i=x-r;i<=x+r;i++)
	{
		for(int k=y-r;k<=y+r;k++)
		{
			square[i][k]=temp[x1][y1];
			x1--;
		}
		x1=x+r,y1++;
	}
}

void spin_(int x,int y,int r)//逆时针旋转90°
{
	for(int i=x-r;i<=x+r;i++)
	{
		for(int k=y-r;k<=y+r;k++)
			temp[i][k]=square[i][k];
	}
	int x1=x-r,y1=y+r;
	for(int i=x-r;i<=x+r;i++)
	{
		for(int k=y-r;k<=y+r;k++)
		{
			square[i][k]=temp[x1][y1];
			x1++;
		}
		y1--,x1=x-r;
	}
}

int main()
{
	int n,m,t=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int k=1;k<=n;k++)
			square[i][k]=++t;
	}//首先给矩阵赋值
	int x,y,r,z;
	for(int i=0;i<m;i++)
	{
		cin>>x>>y>>r>>z;
		if(z==0)
			spin(x,y,r);
		else if(z==1)
			spin_(x,y,r);
	}
	for(int i=1;i<=n;i++)
	{
		for(int k=1;k<=n;k++)
			cout<<square[i][k]<<" ";
		cout<<endl;
	}
}
```


---

## 作者：友利奈绪 (赞：46)

洛谷10月月赛T1（然而我错过了。。。）
看到数据范围后知道这道题是道模拟，然后我们又发现数据的范围保证不会出现越界的情况(良心啊qwq)，所以我们不需要特别判断是否越界。然而我比较菜，推了大半天式子还错了。。
因为矩阵是绕着某个中心(x,y)旋转的而且保证是正方形，为了得到正确的式子、便于理解，我们不妨设(x,y)为原点(0,0)，这样稍微模拟一下就可以得到顺时针旋转90°后正方形上一点(i,j)坐标变成(j,-i)，逆时针旋转90°后坐标变成(-j,i)，然后枚举i,j即可。
代码比较长，走了许多弯路。。。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
int n,m;
int x,y,r,z;
int a[510][510],b[510][510];
void change(int x,int y,int r,int z)
{
	if(z==0)
	{
		for(int i=-r;i<=r;i++)
		{
			for(int j=-r;j<=r;j++)
			{ 	
				b[x+j][y-i]=a[x+i][y+j];
			}
		}
	}
	if(z==1)
	{
		for(int i=-r;i<=r;i++)
		{
			for(int j=-r;j<=r;j++)
			{
				b[x-j][y+i]=a[x+i][y+j];
			}
		}
	}
}
void same()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j]=b[i][j];
		}
	}
}
void print()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cout<<b[i][j]<<' ';
		}
		cout<<endl;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	a[1][1]=1;
	for(int i=1;i<=n;i++)
	{
		if(i!=1) a[i][1]=a[i-1][1]+n;
		for(int j=1;j<=n;j++)
		{
			if(j!=1) a[i][j]=a[i][j-1]+1;
			b[i][j]=a[i][j];
		}
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&r,&z);
		change(x,y,r,z);
		same();
	}	
	print();
	return 0;
}
```

---

## 作者：VenusM1nT (赞：27)

月赛第一题，还是比较水的……

大暴力直接上即可

本着代码简单易懂造福后人的心态，蒟蒻Venus恬不知耻地打了一个超级暴力……

大概做法就是用递归，先旋转最外圈，再往里缩一圈，继续递归即可

如果Venus比较强的话可以只用一个函数，本着打比赛不思考的原则还是顺时针逆时针分别写一个好辣……

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[505][505],c[505][505],tot;
void RotateS(int x,int y,int r)//顺时针
{
    if(r<=1) return;
    int t=r/2,now;
    now=x-t+1;
    for(int i=y-t+1;i<=y+t;i++)//top
    {
        c[now][y+t]=a[x-t][i];
        now++;
    }
    now=y-t+1;
    for(int i=x+t-1;i>=x-t;i--)//left
    {
        c[x-t][now]=a[i][y-t];
        now++;
    }
    now=x+t-1;
    for(int i=y+t-1;i>=y-t;i--)//bottom
    {
        c[now][y-t]=a[x+t][i];
        now--;
    }
    now=y+t-1;
    for(int i=x-t+1;i<=x+t;i++)//right
    {
        c[x+t][now]=a[i][y+t];
        now--;
    }
    RotateS(x,y,r-2);//递归
}
void RotateN(int x,int y,int r)//逆时针
{
    if(r<=1) return;
    int t=r/2,now;
    now=x+t-1;
    for(int i=y-t+1;i<=y+t;i++)//top
    {
        c[now][y-t]=a[x-t][i];
        now--;
    }
    now=y+t-1;
    for(int i=x+t-1;i>=x-t;i--)//left
    {
        c[x+t][now]=a[i][y-t];
        now--;
    }
    now=x-t+1;
    for(int i=y+t-1;i>=y-t;i--)//bottom
    {
        c[now][y+t]=a[x+t][i];
        now++;
    }
    now=y-t+1;
    for(int i=x-t+1;i<=x+t;i++)//right
    {
        c[x-t][now]=a[i][y+t];
        now++;
    }
    RotateN(x,y,r-2);//递归
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++) a[i][j]=++tot;
    }
    for(int i=1;i<=m;i++)
    {
/*		printf("\n");
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++) printf("%d ",a[i][j]);
            printf("\n");
        }*/
        int x,y,r,z;
        scanf("%d %d %d %d",&x,&y,&r,&z);
        if(z==0)
        {
            RotateS(x,y,2*r+1);
            c[x][y]=a[x][y];
            for(int i=x-r;i<=x+r;i++)
            {
                for(int j=y-r;j<=y+r;j++) a[i][j]=c[i][j];
            }
        }
        else if(z==1)
        {
            RotateN(x,y,2*r+1);
            c[x][y]=a[x][y];
            for(int i=x-r;i<=x+r;i++)
            {
                for(int j=y-r;j<=y+r;j++) a[i][j]=c[i][j];
            }
        }
    }
//	printf("\n");
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++) printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}
```

# 暴力大法吼啊！

---

## 作者：Gamin (赞：18)

#  这是一道洛谷10月月赛1的题目 
但是这个难度非常照顾我这种蒟蒻了！（虽然我还是想了好久最后因为某种不可逆转原因只拿了10分……~~**其实是不仔细**~~）
赛后还是死磕这道题，终于在结束比赛后2个小时发现了我的
……** 符号错了 ** ……（说明我是个大蒟蒻）

话不多说……进入正题……


------------


## 一眼看上去这道题思维难度不算高，看的第一眼我就决定用我的暴力方法
先造两个图（一个进行修改，另一个保存上一阶段的状态）

然后就是找规律了……
## 跑两个循环，外围的是当前要旋转的某阶矩阵的半径r(用j做变量)
#### 内层是一个k（k是从0到r的一个数）（跑k的原因请看下面的规律）

假设是个三阶的矩阵需要旋转，且旋转方向为顺时针（即题目中的0）
### 当前的j为1，k为0时……

![](https://cdn.luogu.com.cn/upload/pic/36815.png)

顺时针旋转需要从x+k,y-j去到x-j,y+k，从x-j,y+k去到x+k,y+j……以此类推

**所以有tu[x-j][y+k]=t[x-k][y-j]或者tu[x-j][y+k]=t[x+k][y-j]，
**因为此时k=0,-k或者+k都没什么影响（可能我这个蒟蒻凑巧这样子过的吧……）


### 当j=1,k=1时


![](https://cdn.luogu.com.cn/upload/pic/36813.png)

(上述x-k或者x-j都可以，不过要遵循规律……不然很有可能样例对了但是交上去一片红)

大家可以自己手动模拟一下……



### 既然有了三阶矩阵，我们来看看五阶矩阵

可能上面有的人会问：我还不懂怎么办

凡事总得有个过程是吧

从五阶矩阵这里入手，找到一个特殊情况，一般满足特殊情况就基本上是对的了（~~其实我的规律就是从特殊情况入手的~~）

同上面一样（三阶矩阵上面已经有了，所以只用管最外层就好）

在这里我们令j=2，k=1；

特殊的几个点已经在下面的图上标出来了


![](https://cdn.luogu.com.cn/upload/pic/36814.png)

如果是顺时针转移，则x-j,y-k ——> x-k,y+j （即把x-k,y+j这个点赋值成x-j,y-k的值）   

x-j,y+k ———> x+k,y+j  (这两个是不同的哦，请大家仔细体会)

逆时针也可以类似地推出

然后想一想，这种特殊情况概括出来的方程好像就可以概括完所有情况了……（如果有人发现漏解，欢迎评论区评论）

最后不要忘了当更新一次的时候，把两个表格都更新就可以了！

下面贴代码：

```cpp
#include<iostream>
using namespace std;
int tu[505][505],t[505][505];//tu是主图，t是副图
int n,m;
int main()
{
    cin>>n>>m;
    int o=1;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)//读图，初始化
        {
            tu[i][j]=o;
            t[i][j]=o;
            o++;
        }
    }
    for(int i=1;i<=m;i++)
    {
        int x,y,z,r;
        cin>>x>>y>>r>>z;//输入坐标、半径、旋转方向
        if(z==0)//顺时针旋转
        {
            for(int j=1;j<=r;j++)
            {
                for(int k=0;k<=j;k++)
                {
                    {
                        tu[x-j][y+k]=t[x-k][y-j];//各种转移，模拟即可
                        tu[x+k][y+j]=t[x-j][y+k];
                        tu[x+j][y-k]=t[x+k][y+j];
                        tu[x-k][y-j]=t[x+j][y-k];
                        tu[x+j][y+k]=t[x-k][y+j];
                        tu[x+k][y-j]=t[x+j][y+k];
                        tu[x-j][y-k]=t[x+k][y-j];
                        tu[x-k][y+j]=t[x-j][y-k];
                    }	
                }
            }
        }
        else//逆时针旋转
        {
            for(int j=1;j<=r;j++)
            {
                for(int k=0;k<=j;k++)
                {
                    {
                    //别着急，慢慢看
                        tu[x-k][y-j]=t[x-j][y+k];
                        tu[x-j][y+k]=t[x+k][y+j];
                        tu[x+k][y+j]=t[x+j][y-k];
                        tu[x+j][y-k]=t[x-k][y-j];
                        tu[x+j][y+k]=t[x+k][y-j];
                        tu[x-k][y+j]=t[x+j][y+k];
                        tu[x-j][y-k]=t[x-k][y+j];
                        tu[x+k][y-j]=t[x-j][y-k];
                    }
                }
            }
        }
        for(int j=1;j<=n;j++)
        {	for(int k=1;k<=n;k++)
                {
                    t[j][k]=tu[j][k];//这里更新两个图
                    //cout<<tu[j][k]<<" ";
                }
       // cout<<endl;			
        }	
    }
    //cout<<endl;
    for(int j=1;j<=n;j++)
        {
            for(int k=1;k<=n;k++)//输出
            cout<<tu[j][k]<<" ";
            cout<<endl;
        }
    return 0;//代码结束的好习惯
} 



```
最后希望大家能有耐心做这种~~大水题~~

数据可以多造几组，发现不对慢慢改，加油！

---

## 作者：RemiliaScar1et (赞：7)

本蒟蒻的第二篇题解，请多多指教


------------

#### 这题和二小姐的非符一样，暴力即可。

只要把顺时针或逆时针旋转搞清楚一个就没什么问题，另外一个可以转三次得到 ( 反正500x500的范围也不超时。

至于规律，其实很好推。操作数组中的第i行是源数组中第cx-r+i列。

```cpp
#include<bits/stdc++.h>
using namespace std;
int c1[666][666],c2[666][666];//c1为源数组，c2操作数组 
inline void s_turn_(int cx_,int cy_,int r_)//顺时针 旋转 
{
	int width_=2*r_+1;
	int i,j;
	for(i=0;i<width_;i++)
	{
		for(j=0;j<width_;j++)
		{
			c2[i][j]=c1[cy_+r_-j][cx_-r_+i]; 
		}
	}
	for(i=0;i<width_;i++)
		memcpy(c1[cy_-r_+i]+cx_-r_,c2[i],sizeof(int)*width_);
}
inline void n_turn_(int cx_,int cy_,int r_)//逆时针 = 顺时针x3 
{
	for(int i=1;i<=3;i++)
		s_turn_(cx_,cy_,r_);
}
int main()
{
	int k=0,n,times,i,j;
	cin>>n>>times;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			c1[i][j]=++k;
		}
	}
	for(i=1;i<=times;i++)
	{
		int x,y,r,a;
		cin>>x>>y>>r>>a;
		x--;y--;
		if(a==1)
			n_turn_(y,x,r);
		else s_turn_(y,x,r);
		memset(c2,0,sizeof(c2));
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cout<<c1[i][j]<<" ";
		}
		cout<<endl;
	}
}
```
有什么问题请尽管指出。~~(抱头蹲防~~

---

## 作者：7KByte (赞：7)

# [P4924题解](https://www.luogu.org/problemnew/show/P4924#sub)
这是一道洛谷10月月赛的题目  
## 题目大意：
- 给定一个n^2的矩阵，进行m次操作，每次将一个(2r+1)*(2r+1)的子矩阵进行顺时针或逆时针旋转

## 解析
- 这题的n和m均小于500，所以直接对数组进行操作只需要500^3的时间。由于每次操作不可能全部是500*500的矩阵，所以卡常优秀可以直接AC
### 于是主要思路就非常清晰了
- 首先对操作数组初始化
```cpp
inline void init()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    a[i][j]=(i-1)*n+j;  //根据题目要求进行操作
}
```
- 接下来进行旋转操作
 - 旋转分为两部分，一部分是顺时针旋转，一部分是逆时针旋转
 - 经过观察在我们可以发现顺时针旋转时原来的第x列，现在时x行，原来的第y行，现在时第n-y+1列

**旋转的核心程序：a[i+sx-1][j+sy-1]=b[j][tr-i+1]（b为原数组，a为旋转后的数组**
- 所以顺时针旋转代码：
```cpp
for(int i=1;i<=tr;i++)
    for(int j=1;j<=tr;j++)
        b[i][j]=a[sx+i-1][sy+j-1];
for(int i=1;i<=tr;i++)
    for(int j=1;j<=tr;j++)
        a[i+sx-1][j+sy-1]=b[j][tr-i+1];
```
- 逆时针旋转代码：
```cpp
for(int i=1;i<=tr;i++)
	    for(int j=1;j<=tr;j++)
	      b[i][j]=a[sx+i-1][sy+j-1];
	  for(int i=1;i<=tr;i++)
	    for(int j=1;j<=tr;j++)
	      a[i+sx-1][j+sy-1]=b[tr-j+1][i];
```

**这道题便可以完美的解决了**
## 完整代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[505][505],m,n,x,y,z,r,b[505][505];
inline void init()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    a[i][j]=(i-1)*n+j;
}
inline void change()
{
	int sx=x-r,sy=y-r,tr=2*r+1;
	if(z){
	  for(int i=1;i<=tr;i++)
	    for(int j=1;j<=tr;j++)
	      b[i][j]=a[sx+i-1][sy+j-1];
	  for(int i=1;i<=tr;i++)
	    for(int j=1;j<=tr;j++)
	      a[i+sx-1][j+sy-1]=b[j][tr-i+1];
	}
	else{
	  for(int i=1;i<=tr;i++)
	    for(int j=1;j<=tr;j++)
	      b[i][j]=a[sx+i-1][sy+j-1];
	  for(int i=1;i<=tr;i++)
	    for(int j=1;j<=tr;j++)
	      a[i+sx-1][j+sy-1]=b[tr-j+1][i];
	}
}
inline void work()
{
	for(int i=1;i<=m;i++)
	  {
	  scanf("%d%d%d%d",&x,&y,&r,&z);
      change();
	  }
}
inline void out()
{
	for(int i=1;i<=n;i++)
	  {
	  for(int j=1;j<=n;j++)
	    printf("%d ",a[i][j]);
	  printf("\n");
      }
}
int main()
{
	init();
	work();
	out();
	return 0;
}
```
### 欢迎各位指出不足之处

---

## 作者：karma (赞：7)

这时一道简单题,但是蒟蒻月赛时想复杂了,结果细节写挂了爆0了.(QAQ)

这里提供一种~~毒瘤~~简单写法,如果有想练码力的同学可以尝试一二.

思路:

- 将所求矩阵从外向内逐层推进,相相当于每次缩小一圈
- 在这一圈中(以顺时针为例),将上面的移至右边,将右边的移至下面,以此类推.
- 方便起见,可以用两个数组,每次复制一遍再进行移动.

细节:

- 对于每次移动时,要求出"**将移动到**"位置的坐标并进行更新.要注意回复变量每次的值.

- c()表示顺时针,d()表示逆时针.

c()函数代码如下:


![](https://cdn.luogu.com.cn/upload/pic/36929.png)

d()函数代码如下:

![](https://cdn.luogu.com.cn/upload/pic/36931.png)

其余细节自行完成.
 _
附:建议将代码上传为图片格式,可以适当减少抄袭._ 

---


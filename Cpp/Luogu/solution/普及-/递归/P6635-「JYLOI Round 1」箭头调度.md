# 「JYLOI Round 1」箭头调度

## 题目描述

moyu_028 给了你一个有 $n$ 个点 $m$ 条边的无向图，现在要给每条边赋一个方向，现在请你求出一个赋方向的方案，使得按照这个方案能够生成一个拓扑序，且使得这个拓扑序是在所有可能的拓扑序中字典序第 $k$ 小的。


## 说明/提示

## 提示

拓扑序：在一个 DAG（有向无环图）中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点 $u$ 到 $v$ 的有向边 $(u,v)$，都可以有 $u$ 在 $v$ 的前面，则这样的序列称为拓扑序。

----------

## 样例解释

### 样例 1 解释

答案的图如下，根据图可得出答案。

![](https://i.loli.net/2020/05/23/3FK2n78JAYLrGMD.png)

-----------------

## 数据范围

对于 $100\%$ 的数据，$1 \leq n \leq 11, 1 \leq m \leq 2 \times 10^3, 1 \leq k \leq 10^8，1 \leq x_i, y_i \leq n, x_i \not= y_i$。

对于测试点 1（10 分）：$n = 1$。

对于测试点 2（30 分）：$n \leq 11, m \leq 20$。

对于测试点 3（30 分）：$n \leq 11, k = 1$。

对于测试点 4（30 分）：无特殊限制。

本题共 4 个测试点，总分为 100 分，单个测试点的时间限制为 5 秒。

## 题目来源

「JYLOI Round 1」 A

Idea：moyu_028 & abcdeffa

Solution：LiuXiangle

Data：abcdeffa

## 样例 #1

### 输入

```
6 7 5
1 3
2 1
4 2
4 3
4 5
3 6
5 6```

### 输出

```
0111001```

## 样例 #2

### 输入

```
11 20 20091210
2 3
3 1
2 5
4 6
7 9
8 10
8 1
7 2
2 3
3 2
4 5
5 7
7 6
7 8
9 7
9 8
10 2
2 3
1 3
1 7```

### 输出

```
10110000100110110111```

# 题解

## 作者：moyu_028 (赞：13)

官方题解。

- ### 对于测试点 1

什么都不输出即可得到 $10$ 分。

- ### 对于测试点 2

我们可以直接枚举箭头的方向，然后直接找字典序第 $k$ 小的拓扑序，时间复杂度 $O(2^mn)$。

- ### 对于测试点 3

结论：字典序第 $k$ 小的拓扑序为 $n$ 的全排列中字典序第 $k$ 小的那个序列。

证明：考虑先证明当 $k = 1$ 时答案的字典序为 $1$ ~ $n$。连边的方式为从编号小的点连向编号大的点。

为什么这样是最优的？

考虑对于 1 号点，它在一开始时就没有入边，因为如果存在一个点 $x$，有一条从 $x$ 到 1 的有向边的话，那么 $x < 1$，显然 $x$ 不存在。

那么对于 2 号点，如果存在一个点 $x$，有一条从 $x$ 到 2 的有向边的话，那么 $x < 2$，显然 $x$ 不存在，因为 1 号点和它所连出去的边都消失了。

那么对于 $i$ 号点，如果存在一个点 $x$，有一条从 $x$ 到 $i$ 的有向边的话，那么 $x < i(i > 1)$，显然 $x$ 不存在，因为 $1$ ~ $(i - 1)$ 号点和它所连出去的边都消失了。

因此可以证明当 $k = 1$ 时答案的字典序为 $1$ ~ $n$。

考虑证明我们在上面所提到的结论：字典序第 $k$ 小的拓扑序为 $n$ 的全排列中字典序第 $k$ 小的那个序列。

我们不妨换一种方式来证明它，我们考虑证明：对于 $n$ 的全排列中的任意一个排列 $p_1$ ~ $p_n$，它都是可能的拓扑序。

- 证明：连边方式，将原图中的 $p_i$ 号点的编号换成 $i$ 后，从编号小的点向编号大的点连一条有向边。接下来的证明同上所述。

因此对于 $k = 1$ 的测试数据，我们直接从编号小的点向编号大的点连一条有向边即可。

- ### 对于测试点 4

利用上面的结论，暴力求出答案的排列然后有上面所说的结论连边即可。

其实这道题一开始的数据范围是 $1 \leq n \leq 10^5,1 \leq m \leq 2 \times 10^5,1 \leq k \leq 10^{5000}$，但是后来被削弱了，因为如果加强到这个数据范围的话后面的一部分就是套路题了（这里的套路指的是快速求出 $n$ 的全排列中字典序第 $k$ 小的那个排列），于是这套比赛又多了一道水题。

---

## 作者：wzkdh (赞：7)

这道题要求字典序第k小的排列方式，很自然的想到了康拓展开。

康拓展开是将$0$到$n!-1$的任何整数表达为$a[n-1]*(n-1)!+a[n-2]*(n-2)!+...+a[2]*2!+a[1]*1!$
的形式，对于字符的排列，第$k$小排列就是将$k-1$康拓展开后，每一位放置目前没有放置过的第$a[n-1]$大字符。

康拓展开之后我们就得到了第k小的排列，我们可以按照这个排列作为下标，求出拓扑排序的顺序，然后遍历每一条边，如果顺序是自顺序靠前的指向顺序靠后的，则输出0，否则需要翻转，输出1

## 代码:
```
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int n, m, k, c[20] = {1}, ans[12], a[12], tot, xy[12];
bool v[12];
struct edge
{
	int from, to;
} e[2010];
void cantor(int x)
{
	x %= c[n];
	for (int i = n - 1; i >= 0; i--)
	{
		int idx = x / c[i];
		int tot = 0;
		for (int j = 1; j <= 11; j++)
		{
			if (v[j])
				continue;
			if (tot == idx)
			{
				v[j] = 1;
				ans[i] = j;
			}
			tot++;
		}
		x %= c[i];
	}
}
int main()
{
	for (int i = 1; i < 20; i++)
		c[i] = c[i - 1] * i;
	scanf("%lld%lld%lld", &n, &m, &k);
	for (int i = 0; i < n; i++)
	{
		a[i] = i + 1;
	}
	cantor(k - 1);
	for (int i = 1; i <= m; i++)
	{
		scanf("%d%d", &e[i].from, &e[i].to);
	}
	for (int i = n - 1; i >= 0; i--)
	{
		xy[ans[i]] = ++tot;//注意这里是倒序
	}
	for (int i = 1; i <= m; i++)
	{
		printf("%d", xy[e[i].from] < xy[e[i].to] ? 0 : 1);
	}
	return 0;
}

---

## 作者：MoonCake2011 (赞：3)

对于每个连边的方案，可以证明。

能排出的拓扑序列为 $n$ 的全排列。

如果要构造 $n$ 的一个排列 $p_1\dots p_n$。

使每条边 $(p_i,p_j)$，如果 $i<j$ 连正边，否则连反边。

还有一个点就是一个连边的方案可以对应多种拓扑序。

但根据上面的构造，每个拓扑序只对应一个图。

所以能够做了。

暴力 `next_permutation` 去找第 $k$ 小的全排列。

然后按照以上连边。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[12],p[12];
int main() {
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) a[i]=i;
	while(--k) next_permutation(a+1,a+n+1);
	for(int i=1;i<=n;i++) p[a[i]]=i;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		cout<<(p[u]>p[v]);
	}
	return 0;
}
```

---

## 作者：yinlu_offical (赞：3)

本蒟蒻的第一篇题解，希望审核大大能过~
### 解法一：60分的暴力枚举＋队列优化
主要就是对每个点进行枚举，然后从个点开始，枚举他能通过的所有的边，并把没走过的点存入队列中。

队列中所有的点再次重复上述过程，就可以保证，这个点能走到的所有的点都在 $vis$ 数组中有记录。

最后看 $vis$ 数组中标记的最大的点就可以。
### 代码 $1$：
```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int> q;
int tot,to[200001],fi[200001],ne[200001],n,m,n1,n2;
int vis[100001];
int add(int x,int y)//建立一条由x指向y的边 
{
	to[++tot]=y;
	ne[tot]=fi[x];
	fi[x]=tot;
	return 0; 
}
int main()
{
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		scanf("%d%d",&n1,&n2);
		add(n1,n2);
	}
	for(int i=1;i<=n;i++)//枚举每一个点，对于第i个点来说，从他开始，看能到达的所有的点 
	{
		memset(vis,0,sizeof vis);//vis数组表示这个店是否被遍历到 
		vis[i]++;//从i他自己开始，把他放入队列中，并打上标记 
		q.push(i);
		while(!q.empty())
		{
			int x=q.front();//取出队首元素，出队 
			q.pop();
			for(int j=fi[x];j;j=ne[j])//从这个点的第一条边开始，把每一条边能到达的点（如果还没被访问过）就放入队列中 
			{
				int y=to[j];
				if(vis[y]==0)
				{
					vis[y]++;
					q.push(y);
				}
			}
		}
		for(int j=n;j;j--)//倒序寻找最大的能被访问到的点。 
		{
			if(vis[j])
			{
				printf("%d ",j);
				j=1;
			}
		}
	}
	return 0;
}
```
### 解法二：100分做法，反向dfs法
主要的思路就是从最后一个点开始，看看这个点所能到达的前面的所有的点。

把本来应该 $x \to y$ 的边改为 $y \to x$，也就是由一个点所能到达的最远的点改为一个点所能到达的所有的点，好处是之前的算法时间复杂度是 $O(N \times M)$ 的；而由一个点所能到的其他的点的时候，只要这个点已经被找到了，就不需要再进行判断了，时间复杂度就降为了 $O(N+M)$。
### 代码 $2$：
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot,to[200001],fi[200001],ne[200001],n,m,n1,n2;
int ans[100001];
int add(int x,int y)//建立一条由x指向y的边 
{
	to[++tot]=y;
	ne[tot]=fi[x];
	fi[x]=tot;
	return 0; 
}
int dfs(int x,int y)//x子节点，y最终点 
{
	if(ans[x])return 0;
	ans[x]=y;
	for(int i=fi[x];i;i=ne[i])
		if(ans[to[i]]==0)
			dfs(to[i],y);
	return 0;
	 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<m;i++)
	{
		scanf("%d%d",&n1,&n2);
		add(n2,n1);//反向加边 
	}
	for(int i=n;i>0;i--)
		dfs(i,i);
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
	return 0;
}
```
花了 $4$ 个多小时做的，希望大家能读懂~

---

## 作者：tder (赞：2)

不难证明，对于字典序第 $k$ 小的 $1\sim n$ 的排列同为第 $k$ 小的拓扑序，即任意一种 $1\sim n$ 的排列都有解。

具体的，令这个拓扑序为序列 $P$。定义序列 $A$，其中 $A_i$ 表示第 $i$ 个点在序列 $P$ 中的位置。例如，当 $P=\{3,2,4,5,1\}$ 时，对应的 $A=\{5,2,1,3,4\}$。此时，对于一条连接 $x$ 点和 $y$ 点的边，若 $A_x<A_y$，根据拓扑序的定义，则 $x\to y$，反之亦然。

生成第 $k$ 小的排列，再根据上述方式连边即可。

---

## 作者：Fu_xuan_ (赞：1)

本蒟蒻来 ~~水~~ 一篇题解 

看到字典序排列，很容易联想到康托展开，那么可能有小蒟蒻要问：什么是康托展开？

康托展开是将n！-1的整数表达式写成 $ a[n−1] \times (n − 1)!+a[n − 2] \times (n − 2)!+...+a[2] \times 2!+a[1] \times 1! $ 的形式，那么排列字符中第k小的字典序就是将k-1利用康托展开后每一位中没有被放置东西过的第a[n-1]的字符。

进行康托展开后就可以利用我们所得到的第k小的字符的排列
再利用下标来求出拓补排序的序列就可以啦，如果当前序列是从前向后☞的，那就可以输出0，否则就说明需要翻转，就输出1。

当然，上面是一种比较标准的做法，想要打点~~**~~骗分~~**~~运用人类智慧的，请向下看。

测试点一：啥也不输出就可以骗到10分

测试点二：直接枚举找字符，但是复杂度有点超，**慎用**

测试点三：字典序中第 k 小的拓扑序便是 n 的全排列中字典序第 k小的那个序列啦。

证明比较麻烦，可以参考第一篇题解的大佬，本蒟蒻还没有那个实力：（

测试点四：只要对于上面的结论进行一遍暴力然后连边就可以啦，

本蒟蒻第一篇题解，求过！！！

---

## 作者：IOI_official (赞：0)

由于拓扑排序连边规则是对于两个点 $a_i,a_j$，如果 $i<j$，那么将 $a_i$ 连向 $a_j$。

因为数据很小，所以我们用 `next_permutation` 求出第 $k$ 个排列，再将每个数在此排列中的位置存起来，按照上面的规则连边即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[10005],b[10005];
int main() {
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		a[i]=i;
	}
	for(int i=1;i<=k-1;i++){
		next_permutation(a+1,a+n+1);
	}
	for(int i=1;i<=n;i++){
		b[a[i]]=i;
	}
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		cout<<(b[u]>b[v]);
	}
	return 0;
}
```

---

## 作者：HNOIRPplusplus (赞：0)

在拓扑排序后的数列中，一条有向边的起点肯定在终点的前方。因此，如果我们让所有的有向边都从小点指向大点，就可以让（其中一个）拓扑排序的数列是从小到大排列的。  

同理，如果我们任意给出一个 $1\sim n$ 的排列，然后让每条边都从在排列中出现更靠前的点指向更靠后的点，那么这样也可以使这张图的（其中一个）拓扑排序是给出的任意排列。

所以，实际上我们只需要把第 $k$ 小的排列求出来，记录每个元素的位置，然后对每条边进行如上的方向确定即可。使用 `next_permutation` 单词是 $O(n)$ 的，会导致时间复杂度冲到 $O(kn)$，不可取。使用 `dfs` 可以把时间复杂度降低到更低，但是仍然不可取。

实际上不需要生成每个排列。比如说，当前我已经令排列中的 $p_1 = 1$，则可知剩下的部分一共的排列形式是 $(n-1)!$ 种。如果 $k>(n-1)!$，那么可以直接 $k\leftarrow k-(n-1)!$ 然后将 $p_1\leftarrow2$，否则开始确定下一位。以此类推，可以在 $O(n)$ 的时间复杂度内找到对应的排列。

然后就可以愉快确定边的方向了。~~真的是橙题？~~

---


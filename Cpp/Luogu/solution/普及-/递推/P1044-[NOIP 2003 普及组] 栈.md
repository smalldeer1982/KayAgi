# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# 题解

## 作者：xiejinhao (赞：6010)

# P1044 栈 题解
### 这题运用了大量数论，但我不太想写卡特兰，于是有了这篇题解
#### 虽然说不是卡特兰，貌似都差不多，于是我给出4种做法


1、**递归/记忆化搜索**
------------
看这个数据，我总感觉dfs会超时，~~然后真的超了？（没试过）~~，于是很自然的，我们就会想到记忆化搜索，这也是做这题的一种技巧吧，但无论如何，这也是最基础的

- 下面谈谈搜索(递归)思路：
1. 既然记忆化搜索了，定义一个二维数组$f[i,j]$，用下标 $i$ 表示队列里还有几个待排的数，$j$ 表示栈里有 $j$ 个数，$f[i,j]$表示此时的情况数
1. 那么，更加自然的，只要$f[i,j]$有值就直接返回；
1. 然后递归如何实现呢？首先，可以想到，要是数全在栈里了，就只剩1种情况了，所以：$i=0$时，返回$1$；
1. 然后，有两种情况：一种栈空，一种栈不空：在栈空时，我们不可以弹出栈里的元素，只能进入，所以队列里的数$-1$，栈里的数$+1$，即加上 $f[i-1,j+1]$ ；另一种是栈不空，那么此时有出栈$1$个或者进$1$个再出$1$个 $2$种情况，分别加上 $f[i-1,j+1]$ 和 $f[i,j-1]$ ，便是此时的情况了，于是递归就愉快的结束了；

感谢看完我的漫长的思路，但到了这里你就可以跟程序说再见了(代码最后给)；


2、**递推/$DP$(动态规划)**
------------
我们只要顺着递归的思路来就好了：

1. 据上面的递归，可知定义的 $f[i,j]$ 中 $i=0$ 时这个数组的值都为1，同时，这也是递推边界。并且，我们用 $i$ 表示队列里的数，$j$ 表示出栈数，$f[i,j]$表示情况数；
1. 既然我们愉快地得到了递推思路，愣着干嘛，因为即使初始化了我们也不可能直接用递归的思路写出递归！所以开始找规律：$f[i,j]$到底与什么有着不可告人的联系？其实这个很容易可以想到：当 $i$ 个数进栈，$j-1$ 个数出栈的时候，只要再出一个数，便是i个数进栈，$j$ 个数出栈的情况，同理，对于进栈 $i-1$ 个数，出栈   $j$个数，在进栈一个数便是$f[i,j]$了，于是就有了递归式：$f[i,j]=f[i-1,j+1]$.
1. 然而事实上这还没有完，因为 $i=j$ 时，栈空了，那么，此时就必须进栈了，则$i-1$，有$f[i,j]=f[i-1,j]$；解释一下为什么这样会栈空：当队列和出栈的数都有i个数时，数的总数为 $2i$ ，很明显的，栈里面没有元素了！

于是我们又快乐地解决了递推(其实就是$DP$)的做法，其实与递归大同小异，只不过一个通过函数实现，一个通过循环实现；但这还是基础啊~(代码后面给)


3、**数论做法 卡特兰/$Catalan$**
------------
既然很多Dalao都说过，那我直接给式子了；

- **递推式$1$：**

$f[n]=f[0]*f[n-1] + f[1]*f[n-2] + ... + f[n-1]*f[0] (n≥2)$

然后按照这个递推式模拟就好了(代码后面给)

既然上面标了1，那就有递推式2~

- **递推式$2$：**

$h[n]=h[n-1]*(4*n-2)/(n+1)$

依旧按式子模拟(代码后面给)

既然有2，那再来个3吧~

- **递推式$3$：**

$h[n]=C[2n,n]/(n+1) (n=0,1,2,...)$,$C$是组合数

$PS:C[m,n]=C[m-1,n-1]+C[m-1,n]$:且规定： $C[n,0]=1 C[n,n]=1 C[0,0]=1$

**这个公式也叫组合数公式(下面那个也是)**

（不知道组合数可以百度）

于是仍然把标程放到最后~

- **递推式$4$：**

$h[n]=C[2n,n]-C[2n,n-1] (n=0,1,2,...)$ 组合数$C$不解释了；

**~~没有$5$了~~**

但是有个Dalao写的组合数我没看懂，于是我搜集了各方资料，~~还是没看懂~~，不知道他写的组合数是怎么求的，虽然最后结果对了，但是组合数求出来都是错的(￣_￣|||)，~~不知道是不是巧合？~~

不管了，$AC$就好；（程序还是后面给~）

- 但是，出现了一个问题，上面介绍了四种公式，哪种最好？其实是第4种：如果这个数太大，那么题目可能会要求取模，那么第$1$种$n$太大的时候时空太大；第$2$种在取模运算中万一不小心整除了就凉了；第$3$种是除法运算，更行不通；唯有第$4$种,满足取模原则（加减无所谓），且不会出现倍数 $WA$ 的情况，所以第$4$种解为最优解；

- 接着，比较上面四种做法：很明显的，递推式长得差得不多，它们都源于卡特兰思想，那么就没什么好说的了，只是时空复杂度的不同而已；

**当然，已经有$3$种做法了，我再给一种：高精度/打表**
------------
这种做法可以避免一切 WA（~~打表出省一？~~）

所以我们随便拿一种写个高精？

然而并不是的，我们需要找一个好写的，那就是**卡特兰公式$1$！**

因为这就只是个加法，而且只是为了打表而已（~~我只熟悉加法orz~~）


**所有代码如下：**
------------
```cpp
//认真看，杜绝抄袭
//好好消化一下，这题很经典 
//记忆化搜索/递归 做法 
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N][MAX_N];
ll dfs(int i,int j)
{
	if(f[i][j]) return f[i][j]; 
	if(i==0)return 1; //边界 
	if(j>0) f[i][j]+=dfs(i,j-1);
	f[i][j]+=dfs(i-1,j+1);
	return f[i][j];
}
int main()
{
	scanf("%d",&n);
	printf("%lld",dfs(n,0));
	return 0;
}

//递归转递推  递推做法 
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N][MAX_N];
int main()
{
	scanf("%d",&n);
	for(int i=0;i<=n;i++)
	{
		f[0][i]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			if(i==j)f[i][j]=f[i-1][j];
			else f[i][j]=f[i][j-1]+f[i-1][j];
		}
	}
	printf("%lld",f[n][n]);
	return 0;
}

//数论做法 卡特兰数
//公式1：
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N];
int main()
{
	f[0]=f[1]=1;
	scanf("%d",&n);
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<i;j++)
		{
			f[i]+=f[j]*f[i-j-1];
		}
	}
	printf("%lld",f[n]);
	return 0;
}

//公式2：
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N];
int main()
{
	f[0]=f[1]=1;
	scanf("%d",&n);
	for(int i=2;i<=n;i++)
	{
		f[i]+=f[i-1]*(4*i-2)/(i+1);
	}
	printf("%lld",f[n]);
	return 0;
}

//公式3：
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll c[MAX_N*2][MAX_N];
int main(){

    scanf("%d",&n);
    for(int i=1;i<=2*n;i++)
    {
    	c[i][0]=c[i][i]=1;
    	for(int j=1;j<i;j++)
    	{
    		c[i][j]=c[i-1][j]+c[i-1][j-1];
		}
	}
    printf("%lld",c[2*n][n]/(n+1));
    return 0;
}

//公式4： 
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll c[MAX_N*2][MAX_N];
int main(){

    scanf("%d",&n);
    for(int i=1;i<=2*n;i++)
    {
    	c[i][0]=c[i][i]=1;
    	for(int j=1;j<i;j++)
    	{
    		c[i][j]=c[i-1][j]+c[i-1][j-1];
		}
	}
    printf("%lld",c[2*n][n]-c[2*n][n-1]);
    return 0;
}

//高精/打表：
#include<iostream>
#include<cstdio> 
#include<cstring>
#define MAX_N 110
using namespace std;
int f[MAX_N][MAX_N],c[MAX_N];
inline int len(int a[]) 
{
    int i;
    for(i=60;i>=0;i--)//想要100个以上，这个i的范围要改 
    {
    	if(a[i]!=0) break;
	}   
    return i;
}
inline void add(int a[],int b[],int w)//高精加法 
{
    int lena=len(a),lenb=len(b);
    for(int i=0;i<=max(lena,lenb);i++)
    {
    	f[w][i]=a[i]+b[i];
	}
    for(int i=0;i<=max(lena,lenb)+1;i++) 
	{
        f[w][i+1]+=f[w][i]/10;
        f[w][i]%=10;
    }
}
inline void Catalan(int a[],int b[])//卡特兰 
{
    memset(c, 0, sizeof(c));
	int lena=len(a),lenb=len(b);
    for (int i=0;i<=lena;i++){
    	for (int j=0;j<=lenb;j++) 
    		c[i+j]+=a[i]*b[j];
	}      
    for (int i=0;i<=lena+lenb+1;i++)
	{
        c[i+1]+=c[i]/10;
        c[i]%=10;
    }
}
int main() 
{
    //int k;
    freopen("Catalan.txt","w"stdin);//文件操作; 
    f[0][0]=f[1][0]=1;
    for (int i=2;i<=100;i++)//同理，要多输出几个i就等于几 
    {
    	for (int j=0;j<i;j++) 
		{
            Catalan(f[j], f[i-j-1]);
            add(f[i],c,i);
        }
	}
    for(int i=1;i<=100;i++)//输出 卡特兰数 1-100，范围同上，要输出几个自己改 
    {
	    for (int j=len(f[i]);j>=0;j--)
	    {
	    	//printf("%d",f[i][j]);
			putchar((char)f[i][j]+'0');//比printf稍快?  
		}
		printf("\n");
	}
    return 0;
}
```

虽然可能讲的不好，但是看我写了这么多，点个赞好吗 orz
------------



---

## 作者：inexistent (赞：1144)

看到大家的题解都写到了卡特兰数，但是没有细细的讲讲这跟本题有什么关系

本题的描述十分简单。n个数依次进栈，可随机出栈。求有几种可能。

dfs可以解，但是递推仿佛好像如同看上去貌似更简单一些。

解释一下原理：

建立数组f。f[i]表示i个数的全部可能性。

f[0] = 1, f[1] = 1;  //当然只有一个

设 x 为当前出栈序列的最后一个，则x有n种取值

由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分

1. 比x小

2. 比x大

比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]

比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]

这两部分互相影响，所以一个x的取值能够得到的所有可能性为f[x-1] \* f[n-x]

另外，由于x有n个取值，所以

ans = f[0]\*f[n-1] + f[1]\*f[n-2] + ... + f[n-1]\*f[0];

这，就是传说中的卡特兰数


附上代码：

```cpp
//This program is written by QiXingZhi 

#include <cstdio>

int n, f[30];
int main()
{
    //递推实现卡特兰数 
    scanf("%d", &n);
    f[0] = 1, f[1] = 1;
    for(int i=2; i<=n; i++)              
        for(int j=0; j<i; j++) 
            f[i] += f[j] * f[i-j-1];     //递推公式 
    printf("%d", f[n]);
    return 0;
}
```

---

## 作者：Shmily_389704 (赞：372)

#### 先来看一下题目想干啥：
   这道题想让我们来数一下1~n通过栈操作后有多少种出栈情况（~~暴力枚举其实大概可以打就是过不了~~）

------------
#### 正经分析一下
- 这是一道dp，~~不算太难~~，看式子！
## f[i][j]=f[i-1][j]+f[i+1][j-1] (i>=1)
## f[i][j]=f[i+1][j-1] (i=0)
因为栈里的数字只有两种选择，**出去**和**不出去**。
- 如果出去栈里的数字个数-1；如果不出去就要压栈，未进站的数字进来一个，未进栈的个数-1，栈内个数+1，所以f[i][j]=f[i-1][j]+f[i+1][j-1]
- 当**栈内**没有数字时，只能进栈，且此操作后的出栈情况就要取决于f[i+1][j-1]
##### （f[i][j]，i表示栈内数字的个数，j表示未进栈数字的个数，f计当前状态下有几种情况）
 这样来看的话，**边界**也就很清楚了（当**栈外**没有数字时，只能出栈）
## f[i][0]=1(0<=j<=n)

**dp式子和边界出来了，代码还会远吗？**

------------

#### 啥都不说了，上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>//为了NOIP不用万能头文件
using namespace std;
int f[20][20];//数据就给到18，开个20算大方的
int n;
int main()
{
    memset(f,0,sizeof(f));
    scanf("%d",&n);
    for(int i=0;i<=n;i++)
       f[i][0]=1;//边界一定要有
    for(int j=1;j<=n;j++)
       for(int i=0;i<=n;i++)
       //我们要推f[0][n]，所以i要从零开始跑
        {
          if(i>=1) 
            f[i][j]=f[i-1][j]+f[i+1][j-1];
          if(i==0)//栈内没有东西
            f[i][j]=f[i+1][j-1];
        }
    printf("%d",f[0][n]);
    return 0;
}
```
------------
蒟蒻代码，大佬轻喷~



---

## 作者：易颖杰 (赞：365)

看到有童鞋在评论里说不知道卡特兰数怎么办，刚好又发现没人写记忆化搜索（竟然没有！），那我就发一个吧，本来以为搜索可以过的，结果tle了一个点，然后记忆化一下就好了，f[x][y]是表示当操作队列里还有x个，栈里有y个的时候有几种方案，详情看代码：

```cpp
#include<iostream>
using namespace std;
long n,f[20][20];//f数组记录方案
long dfs(int x,int y)//x是操作队列里元素的个数，y是栈里的个数
{
    if(f[x][y]!=0) return f[x][y];//记忆化，走过的方案直接调用
    if(x==0) return 1;//当操作队列里没有了，就只有一种方案了
    if(y>0) f[x][y]+=dfs(x,y-1);//栈里不为空的时候才可以把栈里的元素推出
    f[x][y]+=dfs(x-1,y+1);//操作队列里元素减一，栈里元素加一
    return f[x][y];//返回方案值
}
int main()
{
    cin>>n;
    cout<<dfs(n,0)<<endl;
    return 0;
}
```

---

## 作者：jiangXxin (赞：161)

看了一下，这道题还没有python的题解，以及对于卡特兰数的证明，没有折线法，我来一个.

从题目以及众多题解，我们可以知道这道题是一道卡特兰数，而卡特兰数的最终算数表达式子为：$\frac{(2n)!}{(n+1)!(n)!}$.

**证明过程：**

我们已经知道，栈有两种操作，入栈和出栈.对此，我们可以建立一个坐标系.

像这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/n6qtja5n.png)

我们可以把

**黄色的线作为入栈操作，由$(x,y)$变成$(x+1,y+1)$**

**绿色的线作为出栈操作,由$(x,y)$变成$(x+1,y-1)$**

这样，我们就可以把问题抽象为从(0,0)到(2n,0),有多少种合法方案数

我们先来考虑这样一个问题，因为我每一次操作都可以让x+1,那么我总共要进行2n次操作，考虑到最后的栈要为空，所以**入栈次数等于出栈次数=n**,所以方案数则为$C_{2n}^n$.

**但是！！！**
我们这样，会出现非法的情况，也就是线越过x轴的情况（栈已经空了，但是还在弹出元素），也就是这种情况:

![](https://cdn.luogu.com.cn/upload/image_hosting/zgt6vmfu.png)

对于这种情况，我们可以设k为第一次与y=-1那条图线的交点，然后把交点以后的点都关于y=-1对称（即，交换操作1和操作2）

![](https://cdn.luogu.com.cn/upload/image_hosting/z5r69x8g.png)

由于我们现在的终点变成了$(2n,-2)$,所以我们的入栈次数肯定等于出栈次数-2,入栈次数加出栈次数等于2n,所以入栈为n-1次，出栈n+1次，则有不合法的总方案数为$C_{2n}^{n-1}$,所以最终结果为$C_{2n}^{n}$-$C_{2n}^{n-1}$.

根据组合数的定义，

![](https://cdn.luogu.com.cn/upload/image_hosting/xtfqh80e.png)


化简可以得到最终答案为$\frac{(2n)!}{(n+1)!(n)!}$,完结

**code:**

```python
n=int(input())
m=2*n
a=1
for i in range(1,m+1):#计算(2n)!
    a=a*i
b=1
for i in range(1,n+2):#计算(n+1)!
    b=b*i
c=1
for i in range(1,n+1):#计算n！
    c=c*i
ans=int(a/(b*c))
print(ans)
```


---

## 作者：Nepenthe (赞：119)

#卡特兰数

这是一道经典的卡特兰数例题


卡特兰数有四个公式，显然这题数据太水都可过，但我们要分析每个公式的用处。

**以下内容神犇请无视（话说神犇也不会看这种水题的题解）**


##公式一

**递归公式**

h(0)=h(1)=1 

h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)\*h(0) (n>=2) 

如果我们用这个公式显然我们要使用递归算法，那么数据一大就在时空上很麻烦


##公式二

**递推公式**

h(n)=h(n-1)\*(4\*n-2)/(n+1)

这个公式应用递推，看上起十分和善

但对大数据呢？

我们注意到大数据的时候h(n)会很大，这时候题目一般会让你对某素数取模（当然你可以打高精度（划掉））

但你在取模过程中难保一个h(n)%mod=0

那么根据公式下面所有的数都会等于0，于是你就愉快的WA了


##公式三

**组合数公式1**

h(n)=C(2n,n)/(n+1)  (n=0,1,2,...)

卡特兰数可以与组合数联系起来，得到上面的公式

而组合数就是一个杨辉三角，可以递推得到（这个不属于这道题的讨论范围我假装你们都会（逃））

但我们发现对于大数据你要取模，而对于除法你是没办法用膜的性质的（当然你可以应用逆元（划掉）），所以造成了麻烦


##公式四

**组合数公式2**

h(n)=c(2n,n)-c(2n,n-1) (n=0,1,2,...)

与组合数公式1不同这个是两个组合数的减法

减法是可以用膜的性质的，于是你可以愉快的AC了。


所以我写了这么多就是想说，对于一个特定的任务，可能会有很多方法求解，但其实只要稍稍分析一下就会发现有一种方法是通用而优美的，我在没认真思考前都是记的四个公式，但是有一天我真的认真想过后才发现其实我就记住公式四就好了。

所以学习啊，还是要学会认真思（tou）考（lan）

```cpp
#include<cstdio>
#define siz 20
using namespace std;
int n;
int c[siz*2][siz];
int main(){

    scanf("%d",&n);
    for(int i=1;i<=2*n;i++) c[i][1]=c[i][i]=1;
    for(int i=3;i<=2*n;i++)
     for(int j=2;j<i;j++)
      c[i][j]=c[i-1][j]+c[i-1][j-1];
    printf("%d",c[2*n][n]-c[2*n][n-1]);
    return 0;
}
```

---

## 作者：mingx1 (赞：79)

看完题解才发现自己的想法很low,我还高兴了一会。。

思想：用f(i,j)表示当前状态，i是坑里的，j是坑外的，而f(i,j)=f(i-1,j)+f(i+1,j-1)——要么把坑头上的输出，要么把坑外的推到坑里去，分别对应pop和Push。然后再弄一下边界。

没有用到乘法。。

```cpp
#include<iostream>
using  namespace std;
int zhan[20][20];
int main()
{
    int n;cin>>n;
    for(int j=0;j<=n;j++)
        for(int i=0;i<=n;i++)
        {
            if(j==0) zhan[i][0]=1;
            else if(i==0) zhan[0][j]=zhan[1][j-1];
            else 
            {
                zhan[i][j]=zhan[i-1][j]+zhan[i+1][j-1];
            }
        }
        cout<<zhan[0][n];
        return 0;
}
```

---

## 作者：XCD_OIworld_rookie (赞：55)

emmmm...... Err (日常拖音......)

表！表！！表！！！
```
如果n=1 1
如果n=2 2
如果n=3 5
如果n=4 14
如果n=5 42
如果n=6 132
如果n=7 429
如果n=8 1430
如果n=9 4862
如果n=10 16796
如果n=11 58786
如果n=12 208012
如果n=13 742900
如果n=14 2674440
如果n=15 9694845
如果n=16 35357670
如果n=17 129644790
如果n=18 477638700
```
卡特兰数！！！

代码1
```
#include<bits/stdc++.h>
using namespace std;
int h(int n){
	if(n==0||n==1) return 1;
	return h(n-1)*(4*n-2)/(n+1);//公式
}
int main(){
	int n;
	cin>>n;
	cout<<h(n);
	return 0;
}

```
代码2
```
#include<bits/stdc++.h>
using namespace std;
int h(int n){
	if(n==0||n==1) return 1;
	int hh=0;
	for(int i=0;i<n;i++){
		hh+=h(i)*h(n-1-i);//公式
	}
	return hh;
}
int main(){
	int n;
	cin>>n;
	cout<<h(n);
	return 0;
}

```

---

## 作者：czx20030930 (赞：43)

【方法1】

此题是一个标准的卡特兰数问题，使用f[n]表示n个数出栈入栈的方法数

则对于f[n]，可以以第一个入栈的数字出栈的次数为标准，

若首个入栈数字第k个出栈，f[n]+=f[k-1]\*f[n-k]（其中f[k-1]为首个数字出入栈之间出栈、入栈的数字个数，f[n-k]则为首个数字出栈之后出入栈的数字个数）

以此类推，易得出公式f[n]=f[0]\*f[n-1]+f[1]\*f[n-2]+......+f[n-2]\*f[1]+f[n-1]\*f[0]

代码如下

```cpp
#include <cstdlib>
#include <iostream>
#include <string.h>
using namespace std;
int main() {
    int n,i,j;
    long long f[20]={1};//无数字出入栈的方法数有一种
    cin>>n;
    for(i=1;i<=n;i++)
        for(j=0;j<i;j++)
            f[i]+=f[j]*f[i-j-1];
    cout<<f[n]<<endl;
    return 0;
}
```
【方法三】
对于卡特兰数还有递推公式

f(n)=f(n-1)\*(4\*n-2)/(n+1)

由此可以得出代码

注：我在代码中先使用了multi函数将每次乘法的结果储存在c数组中，再直接在答案（ans）数组中累计，将f[1]~f[100]全部记录下了

```cpp
#include <cstdlib>
#include <iostream>
#include <string.h>
using namespace std;
int main() {
    int n,i,j;
    long long f[20]={1};
    cin>>n;
    for(i=1;i<=n;i++)
        f[i]=f[i-1]*(4*i-2)/(i+1);
    cout<<f[n]<<endl;
    return 0;
}
```
【方法三】
闲来无事，于是用【方法一】＋高精度写一个f[1～100]的代码

```cpp
#include <cstdlib>
#include <iostream>
#include <string.h>
#include <cmath>
using namespace std;
int ans[101][110], c[110];
int len(int a[]) {
    int i;
    for (i = 60; i >= 0; i--)
        if (a[i] != 0)
            break;
    return i;
}
void plu(int a[],int b[],int w) {
    int i, la = len(a), lb = len(b);
    for (i = 0; i <= max(la, lb); i++)
        ans[w][i] = a[i] + b[i];
    for (i = 0; i <= max(la, lb) + 1; i++) {
        ans[w][i + 1] += ans[w][i] / 10;
        ans[w][i] %= 10;
    }
}
void multi(int a[],int b[]) {
    int i, j, la = len(a), lb = len(b);
    memset(c, 0, sizeof(c));
    for (i = 0; i <= la; i++)
        for (j = 0; j <= lb; j++)
            c[i + j] += a[i] * b[j];
    for (i = 0; i <= la + lb + 1; i++) {
        c[i + 1] += c[i] / 10;
        c[i] %= 10;
    }
}
int main() {
    int i, j;
    ans[0][0] = 1;
    ans[1][0] = 1;
    for (i = 2; i <= 100; i++)
        for (j = 0; j < i; j++) {
            multi(ans[j], ans[i - j - 1]);
            plu(ans[i], c, i);
        }
    cin >> i;
    for (j = len(ans[i]); j >= 0; j--)
        printf("%d", ans[i][j]);
    printf("\n");
    return 0;
}
```
【方法四】可采用相同的方法将【方法二】也进行高精度运算，会比方法三快很多
【方法五】提供一份打表代码，可以用于进行对照验证

    
```cpp
#include <iostream>
#include <cstdio>
#include <string.h>
using namespace std;
int main(int argc, char *argv[])
{
    int n;
    while(cin>>n&&n!=-1)
    switch(n)
    {
        case 1:cout<<"1"<<endl;break;
        case 2:cout<<"2"<<endl;break;
        case 3:cout<<"5"<<endl;break;
        case 4:cout<<"14"<<endl;break;
        case 5:cout<<"42"<<endl;break;
        case 6:cout<<"132"<<endl;break;
        case 7:cout<<"429"<<endl;break;
        case 8:cout<<"1430"<<endl;break;
        case 9:cout<<"4862"<<endl;break;
        case 10:cout<<"16796"<<endl;break;
        case 11:cout<<"58786"<<endl;break;
        case 12:cout<<"208012"<<endl;break;
        case 13:cout<<"742900"<<endl;break;
        case 14:cout<<"2674440"<<endl;break;
        case 15:cout<<"9694845"<<endl;break;
        case 16:cout<<"35357670"<<endl;break;
        case 17:cout<<"129644790"<<endl;break;
        case 18:cout<<"477638700"<<endl;break;
        case 19:cout<<"1767263190"<<endl;break;
        case 20:cout<<"6564120420"<<endl;break;
        case 21:cout<<"24466267020"<<endl;break;
        case 22:cout<<"91482563640"<<endl;break;
        case 23:cout<<"343059613650"<<endl;break;
        case 24:cout<<"1289904147324"<<endl;break;
        case 25:cout<<"4861946401452"<<endl;break;
        case 26:cout<<"18367353072152"<<endl;break;
        case 27:cout<<"69533550916004"<<endl;break;
        case 28:cout<<"263747951750360"<<endl;break;
        case 29:cout<<"1002242216651368"<<endl;break;
        case 30:cout<<"3814986502092304"<<endl;break;
        case 31:cout<<"14544636039226909"<<endl;break;
        case 32:cout<<"55534064877048198"<<endl;break;
        case 33:cout<<"212336130412243110"<<endl;break;
        case 34:cout<<"812944042149730764"<<endl;break;
        case 35:cout<<"3116285494907301262"<<endl;break;
        case 36:cout<<"11959798385860453492"<<endl;break;
        case 37:cout<<"45950804324621742364"<<endl;break;
        case 38:cout<<"176733862787006701400"<<endl;break;
        case 39:cout<<"680425371729975800390"<<endl;break;
        case 40:cout<<"2622127042276492108820"<<endl;break;
        case 41:cout<<"10113918591637898134020"<<endl;break;
        case 42:cout<<"39044429911904443959240"<<endl;break;
        case 43:cout<<"150853479205085351660700"<<endl;break;
        case 44:cout<<"583300119592996693088040"<<endl;break;
        case 45:cout<<"2257117854077248073253720"<<endl;break;
        case 46:cout<<"8740328711533173390046320"<<endl;break;
        case 47:cout<<"33868773757191046886429490"<<endl;break;
        case 48:cout<<"131327898242169365477991900"<<endl;break;
        case 49:cout<<"509552245179617138054608572"<<endl;break;
        case 50:cout<<"1978261657756160653623774456"<<endl;break;
        case 51:cout<<"7684785670514316385230816156"<<endl;break;
        case 52:cout<<"29869166945772625950142417512"<<endl;break;
        case 53:cout<<"116157871455782434250553845880"<<endl;break;
        case 54:cout<<"451959718027953471447609509424"<<endl;break;
        case 55:cout<<"1759414616608818870992479875972"<<endl;break;
        case 56:cout<<"6852456927844873497549658464312"<<endl;break;
        case 57:cout<<"26700952856774851904245220912664"<<endl;break;
        case 58:cout<<"104088460289122304033498318812080"<<endl;break;
        case 59:cout<<"405944995127576985730643443367112"<<endl;break;
        case 60:cout<<"1583850964596120042686772779038896"<<endl;break;
        case 61:cout<<"6182127958584855650487080847216336"<<endl;break;
        case 62:cout<<"24139737743045626825711458546273312"<<endl;break;
        case 63:cout<<"94295850558771979787935384946380125"<<endl;break;
        case 64:cout<<"368479169875816659479009042713546950"<<endl;break;
        case 65:cout<<"1440418573150919668872489894243865350"<<endl;break;
        case 66:cout<<"5632681584560312734993915705849145100"<<endl;break;
        case 67:cout<<"22033725021956517463358552614056949950"<<endl;break;
        case 68:cout<<"86218923998960285726185640663701108500"<<endl;break;
        case 69:cout<<"337485502510215975556783793455058624700"<<endl;break;
        case 70:cout<<"1321422108420282270489942177190229544600"<<endl;break;
        case 71:cout<<"5175569924646105559418940193995065716350"<<endl;break;
        case 72:cout<<"20276890389709399862928998568254641025700"<<endl;break;
        case 73:cout<<"79463489365077377841208237632349268884500"<<endl;break;
        case 74:cout<<"311496878311103321137536291518809134027240"<<endl;break;
        case 75:cout<<"1221395654430378811828760722007962130791020"<<endl;break;
        case 76:cout<<"4790408930363303911328386208394864461024520"<<endl;break;
        case 77:cout<<"18793142726809884575211361279087545193250040"<<endl;break;
        case 78:cout<<"73745243611532458459690151854647329239335600"<<endl;break;
        case 79:cout<<"289450081175264899454283846029490767264392230"<<endl;break;
        case 80:cout<<"1136359577947336271931632877004667456667613940"<<endl;break;
        case 81:cout<<"4462290049988320482463241297506133183499654740"<<endl;break;
        case 82:cout<<"17526585015616776834735140517915655636396234280"<<endl;break;
        case 83:cout<<"68854441132780194707888052034668647142985206100"<<endl;break;
        case 84:cout<<"270557451039395118028642463289168566420671280440"<<endl;break;
        case 85:cout<<"1063353702922273835973036658043476458723103404520"<<endl;break;
        case 86:cout<<"4180080073556524734514695828170907458428751314320"<<endl;break;
        case 87:cout<<"16435314834665426797069144960762886143367590394940"<<endl;break;
        case 88:cout<<"64633260585762914370496637486146181462681535261000"<<endl;break;
        case 89:cout<<"254224158304000796523953440778841647086547372026600"<<endl;break;
        case 90:cout<<"1000134600800354781929399250536541864362461089950800"<<endl;break;
        case 91:cout<<"3935312233584004685417853572763349509774031680023800"<<endl;break;
        case 92:cout<<"15487357822491889407128326963778343232013931127835600"<<endl;break;
        case 93:cout<<"60960876535340415751462563580829648891969728907438000"<<endl;break;
        case 94:cout<<"239993345518077005168915776623476723006280827488229600"<<endl;break;
        case 95:cout<<"944973797977428207852605870454939596837230758234904050"<<endl;break;
        case 96:cout<<"3721443204405954385563870541379246659709506697378694300"<<endl;break;
        case 97:cout<<"14657929356129575437016877846657032761712954950899755100"<<endl;break;
        case 98:cout<<"57743358069601357782187700608042856334020731624756611000"<<endl;break;
        case 99:cout<<"227508830794229349661819540395688853956041682601541047340"<<endl;break;
        case 100:cout<<"896519947090131496687170070074100632420837521538745909320"<<endl;break;
    }
    return 0;
}
```

---

## 作者：荼白 (赞：23)

```cpp
#include <iostream>
#include <stack>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;
/*--------------------------------------------------------------------------------*/
//定义 f[i][j] 表示当 i 个数已经入栈，j 个数已经出栈的时候，所拥有的最大数。
//所以必须满足 i≥j
/*--------------------------------------------------------------------------------*/
//当 i≠j 时 f(i,j) 只能从 f(i-1,j) 和f (i,j-1) 里转移。
//因为栈一次操作只能进一个数字或者弹出一个数字。
//即 f(i,j)=f(i-1,j)+f(i,j-1) (i≠j)
//当 i=j 时，f(i,j) 只能由 f(i,j-1) 弹出一个数得到。
//即 f(i,j)=f(i,j-1) (i=j)
/*--------------------------------------------------------------------------------*/
int f[20][20];
int n;
int main()
{
    cin >> n;
    for(int i=1;i<=n;i++) f[i][0]=1;//因为栈的性质，所以对于任何的 i，必然有 f(i,0)=1
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            if(i==j) f[i][j]=f[i][j-1];
            else f[i][j]=f[i-1][j]+f[i][j-1];
        }
    }
    cout << f[n][n];
    return 0;
}
```


---

## 作者：lixiao189 (赞：18)

## 题意：
问如果有一个序列为1到$ n $ 通过不同的操作得到的出栈序列有几个？

## 思路

假如有下面这个图。

![](https://cdn.luogu.com.cn/upload/pic/30485.png )

我们把一个数出栈看成是往上走一步，入栈往右走一步那么（注意是格点）我们从点 $ (1,1) $ 到达 $ (n,n) $ 的方案数就是所求答案。注意由于我们出栈的数量不能大于出栈的数量，所以我们走到的点 $ (i,j) $ 必须要满足 $ i \le j $
。我们设到达 $ (i,j) $ 的方案数为 $ dp_{i,j} $ 那么显然有dp方程 $ dp_{i,j}=dp_{i-1,j}+dp_{i,j-1} $ 最后注意一下边界，和特殊处理一下边缘就可以了。

## 注意：
我们知道这个东西最后算出来的东西是很大的，所以我们一定要记得开 `long long`

## 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 20;

long long n;
long long dp[N][N];

int main(){
	scanf("%lld",& n);
	
	for(register int j=1;j<=n+1;j++){
		for(register int i=1;i<=j;i++){
			if(i==1 && j==1) dp[i][j]=1;
			else if(i==1) dp[i][j]=dp[i][j-1];
			else if(i==j) dp[i][j]=dp[i-1][j];
			else dp[i][j]=dp[i-1][j]+dp[i][j-1];
		}
	}
	
	printf("%lld\n",dp[n+1][n+1]);
	
	return 0;
}
```

---

## 作者：JamlainHamstone (赞：15)

首先一看到这道题就有用dfs方法做的冲动，我们用n表示待进栈数的数量，用k表示栈内数的数量

首先考虑递归出口：
当待进栈的数字数量为零时，就是一种方法，此时return 1;

因为每一次操作不是进栈就是出栈，所以每次递归的返回结果是两种方案的和：dfs(n-1,k+1)+dfs(n,k-1);

最后还需要注意的一点是，必须是在栈内数数量>0的时候才可以做出栈操作，所以还需要加一个判断if(k>0)

最后，话不多说，上代码（~~我知道你们只看这个~~）：
```
#include<bits/stdc++.h>
using namespace std;
int s[20][20];//保险起见，加一个记忆化
int dfs(int n,int k){
	if(s[n][k]) return s[n][k];
	if(n==0) return 1;//没有待进栈的数
	if(k>0) return s[n][k]=dfs(n,k-1)+dfs(n-1,k+1);//可以进行出栈操作
	return s[n][k]=dfs(n-1,k+1);//只能进栈
}
int main(){
	int n;
	cin>>n;
	cout<<dfs(n,0);//初始的栈内数数量为0
	return 0;
} 
```


---

## 作者：徐振羽 (赞：13)

很明显的深搜啊，我看完题目后发现，这道题和栈没关系，因为如果你有一个操作不同，你就会得到一个不同的结果，所以我们其实只要求到底有几种操作方式就行了

先打一个80分的代码，超时一个点
```
#include<iostream>
using namespace std;
long long n,ans;
void dfs(long long x,long long y,long long z)
//x表示出栈的个数，y表示在栈中的个数，z表示没进栈的个数
{
	if (x==n) ans++;//当全部数出栈，ans加一
	if (z>=1) dfs(x,y+1,z-1);//当还有数没进栈时，我们可以让数进栈
	if (y>=1) dfs(x+1,y-1,z);/当还有数在栈里时，我们可以让数出栈
}//这里我其实可以把z给去了，因为x+y+z=n,但为了代码更加易懂，我没去 
int main(){
	cin>>n;//读入
	dfs(0,0,n);//调用
	cout<<ans;//输出
	return 0;
} 
```
作为一个无耻的人，我把最后超时的数据答案算出，打表

出来吧,AC代码
```
//不解释，和上面一样
#include<iostream>
using namespace std;
long long n,ans;
void dfs(long long x,long long y,long long z)
{
	if (x==n) ans++;
	if (z>=1) dfs(x,y+1,z-1);
	if (y>=1) dfs(x+1,y-1,z); 
} 
int main(){
	cin>>n;
	if (n==17) cout<<129644790;
	else if (n==18) cout<<477638700;
	else
	{
		dfs(0,0,n);
		cout<<ans;
	}
	return 0;
} 
```
认真的打一下代码，我问你们，深搜超时怎么办，记忆化呗！

废物忆化代码
```
#include<iostream>
using namespace std;
long long n,ans,f[101][101][101];//其实第三维可以去掉，理由你懂的
long long dfs(long long x,long long y,long long z)//z可以去掉，理由你懂的
//x表示出栈的个数，y表示在栈中的个数，z表示没进栈的个数
{
	if (x==n) return 1;//当全部数出栈，返回一
	if (z>=1) 
	{
		if (f[x][y+1][z-1]==0) f[x][y+1][z-1]=dfs(x,y+1,z-1);
        //记忆化，当f[x][y+1][z-1]为0时存入数据，以后要这个数据，就不用再dfs了
		if (y>=1) 
		{
			if (f[x+1][y-1][z]==0) f[x+1][y-1][z]=dfs(x+1,y-1,z);
            //记忆化，当f[x+1][y-1][z]为0时存入数据，以后要这个数据，就不用再dfs了
			return f[x+1][y-1][z]+f[x][y+1][z-1];//返回值
		}
		else return f[x][y+1][z-1];//返回值
	}
	else 
	{
		if (y>=1) 
		{
			if (f[x+1][y-1][z]==0) f[x+1][y-1][z]=dfs(x+1,y-1,z);
            //记忆化，当f[x+1][y-1][z]为0时存入数据，以后要这个数据，就不用再dfs了
			return f[x+1][y-1][z];//返回值
		}
	}
} 
int main(){
	cin>>n;//读入
	cout<<dfs(0,0,n);//输出
	return 0;
} 
```
优秀的记忆化代码
```
#include<iostream>
using namespace std;
long long n,ans,f[101][101][101];//其实第三维可以去掉，理由你懂的
long long dfs(long long x,long long y,long long z)//z可以去掉，理由你懂的
//x表示出栈的个数，y表示在栈中的个数，z表示没进栈的个数
{
	if (x==n) return 1;//当全部数出栈，返回一
	if(f[x][y][z]) return f[x][y][z];//若dfs(x,y,z)被计算过，直接返回计算结果
	if (z>=1) f[x][y][z]+=dfs(x,y+1,z-1);//f[x][y][z]没被存储过，进行存储
	if (y>=1) f[x][y][z]+=dfs(x+1,y-1,z);//f[x][y][z]没被存储过，进行存储
	return f[x][y][z];//返回值
} 
int main(){
	cin>>n;//读入
	cout<<dfs(0,0,n);//输出
	return 0;
} 
```
我打着题解时突然发现，这个栈是卡特兰树啊，公式放出C 2n n / n+1

卡特兰树×1
```
#include<iostream>
using namespace std;
long long n,x=1,y=1; 
int main(){
	cin>>n;
	for (int i=n+2;i<=2*n;i++) 
	{
		x=x*i;//计算n*2n，C 2n n 的上半部分
		if (x%(i-n)==0) x=x/(i-n);//为了防爆，这里当x可以除就直接除
		else y=y*(i-n);//不可以除存下来最后除
	}
	cout<<x/y;
	return 0;
} 
```
卡特兰树×2
```
#include<iostream>
using namespace std;
long long n,x=1; 
int main(){
	cin>>n;
	for (int i=n+1;i<=2*n;i++) x=x*i/(i-n);
    //当i-n=2时，x为两个数相乘，当i-n=3时，x为三个数相乘，必然整除
	cout<<x/(n+1);//最后再除(n+1)
	return 0;
} 
```


---

## 作者：f070331 (赞：11)

本$\color{#ff0000}\bold{\text{蒟蒻}}$用手算列出一张亚特兰数的表$\color{#ff0000}\bold{\text{（无奈蒟蒻只会打表）}}$：

```
设输入为n

如果n=1 1
如果n=2 2
如果n=3 5
如果n=4 14
如果n=5 42
如果n=6 132
如果n=7 429
如果n=8 1430
如果n=9 4862
如果n=10 16796
如果n=11 58786
如果n=12 208012
如果n=13 742900
如果n=14 2674440
如果n=15 9694845
如果n=16 35357670
如果n=17 129644790
如果n=18 477638700
```
代码：
```
#include <iostream>
#include <cstdio>

using namespace std;

int main(int argc, const char * argv[]) {
    int n;
    cin>>n;
    switch (n) {
        case 1:cout<<'1';break;
        case 2:cout<<'2';break;
        case 3:cout<<'5';break;
        case 4:cout<<"14";break;
        case 5:cout<<"42";break;
        case 6:cout<<"132";break;
        case 7:cout<<"429";break;
        case 8:cout<<"1430";break;
        case 9:cout<<"4862";break;
        case 10:cout<<"16796";break;
        case 11:cout<<"58786";break;
        case 12:cout<<"208012";break;
        case 13:cout<<"742900";break;
        case 14:cout<<"2674440";break;
        case 15:cout<<"9694845";break;
        case 16:cout<<"35357670";break;
        case 17:cout<<"129644790";break;
        case 18:cout<<"477638700";break;
    }
    return 0;
}

```
求过



---

## 作者：yummy (赞：11)

看到题解里有人发了卡特兰数，我表示深深的佩服，因为我不会啊！

于是，就还有一批人，推出了他们的dp算法，然而，我在第一次做时，就没有想到，于是就使用了dfs（居然还通过了）

[我的代码](https://www.luogu.org/record/show?rid=7676823)

60分以下的同学别慌，接下来我会再把解题过程讲一遍。

---
很显然，对于每个合法的操作序列(如题目描述里的push,push,pop,push,pop,pop),都对应一个输出序列，于是题目就转化成了求合法操作序列数量。

我们总结出如下规律：
- 如果栈非空，那么下一步就既可push，又可pop
- 否则，下一步只可以push。

因此，我们dfs时，要传入两个参数，k用于记录当前是第几步，而many记录栈内有几个元素。
```cpp
int way(int k,int many)
{
    int t=0;//计数
    if(k==2*n)//如果步数已满，返回
    {
        if(many==0)//所有操作完成后栈是否清空
            return 1;
        else
            return 0;
    }
    if(a[k][many]!=0)//此处为了加速用了一个记忆化
        return a[k][many];
    if(many<=n)//栈不是满的就可以push
        t+=way(k+1,many+1);
    if(many>0)//栈不是空的就可以pop
        t+=way(k+1,many-1);
    a[k][many]=t;
    return t;
}
```
为防抄袭题解，剩下的部分由读者自行修补

---

## 作者：取名最烦 (赞：11)

**给P党发发福利。。。**

**本题DFS有80，后面20是为DP准备的。**

**下面来讲一下DP方程推导过程。**

**————————————————————**

**设f[i,j]表示已经有j个数出栈，有i个数还未进栈是的方案总数。**

**那么对于每个f[i,j],如果上一步操作是压入，那么一共有f[i+1,j]种方案，因为当有i+1个数未进栈，j个数已出栈时，再进行一次压入操作会使栈外的数的数量减少1，变为f[i,j]的状态。**

**同理，当上一步时弹出，那么共有f[i,j-1]种方案，解释同上。**

**附上核心代码：**

**for j:=1 to n do**

**for i:=n-j downto 0 do**

**f[i,j]:=f[i+1,j]+f[i,j-1];**

**Ps：别忘了预处理！思考一下该如何预处理。**


---

## 作者：jijidawang (赞：8)

[P1044 题目传送门](https://www.luogu.com.cn/problem/P1044)

这道题是一个经典的卡特兰数问题，下面我们来推导出它为什么是卡特兰数。

------------
首先，我们要了解什么是卡特兰数。

>卡特兰数又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。
>
>$ --Baidu$


卡特兰数$C_n$满足以下递推关系:

($C_n$代表卡特兰数的第$n$项)

$$C_{n+1}=C_0C_n+C_1C_{n-1}+\ldots+C_nC_0$$

$$(n-3)C_n=\frac{n}{2}(C_3C_{n-1}+C_4C_{n-2}+C_5C_{n-3}+\dots+C_{n-2}C_4+C_{n-1}C_3)$$

---------
### P1044
一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列? 

### 设$h_n$为$catalan$数的第$n+1$项，令$h_0=1$,$h_1=1$。

-------
------

#### 常规分析
首先，我们设$f_n$=序列个数为$n$的出栈序列种数。（我们假定，最后出栈的元素为$k$）。

显然，$k$取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于$k$最后出栈，因此，在$k$入栈之前，比$k$小的值均出栈，此处情况有$f_{k-1}$种，而之后比$k$大的值入栈，且都在k之前出栈，因此有$f_{n-k}$种方式，由于比$k$小和比$k$大的值入栈出栈情况是相互独立的，此处可用乘法原则，$f_{n-k}f_{k-1}$种，求和便是$Catalan$递归式。

首次出空之前第一个出栈的序数$k$将```1~n```的序列分成两个序列，其中一个是```1~k-1```，序列个数为$k-1$，另外一个是```k+1~n```，序列个数是$n-k$。

此时，我们若把$k$视为确定一个序数，那么根据乘法原理，$f_n$的问题就等价于----序列个数为$k-1$的出栈序列种数乘以序列个数为$n-k$的出栈序列种数，即选择$k$这个序数的$f_n$=$f_{k-1}f_{n-k}$。而$k$可以选$1$到$n$，所以再根据加法原理，将$k$取不同值的序列种数相加，得到的总序列种数为：

$$f_n=f_0f_{n-1}+f_1f_{n-2}+\ldots+f_{n-1}f_0$$

看到此处，再看看卡特兰数的递推式，答案不言而喻，即为
$$ f_n=h_n= C^{2n}_n/{n+1}= c^2
_n-c^{2n}_{n-1}$$
$$(n=0,1,2,\dots)$$

最后，令$f_0=1$，$f_1=1$。
### 非常规分析
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘$1$’，出栈设为状态‘$0$’。$n$个数的所有状态对应$n$个$1$和$n$个$0$组成的$2n$位二进制数。由于等待入栈的操作数按照$1\dots n$的顺序排列、入栈的操作数$b$大于等于出栈的操作数$a(a≤b)$，因此输出序列的总数目$=$由左而右扫描由$n$个$1$和$n$个$0$组成的$2n$位二进制数，$1$的累计数不小于$0$的累计数的方案种数。

在$2n$位二进制数中填入$n$个$1$的方案数为$c^{2n}_n$,不填$1$的其余$n$位自动填$0$。从中减去不符合要求（由左而右扫描，$0$的累计数大于$1$的累计数）的方案数即为所求。

不符合要求的数的特征是由左而右扫描时，必然在某一奇数位$2m+1$位上首先出现$m+1$个$0$的累计数和$m$个$1$的累计数，此后的$2(n-m)-1$位上有$n-m$个$1$和$n-m-1$个$0$。如若把后面这$2(n-m)-1$位上的$0$和$1$互换，使之成为$n-m$个$0$和$n-m-1$个$1$，结果得$1$个由$n+1$个$0$和$n-1$个$1$组成的$2n$位数，即一个不合要求的数对应于一个由$n+1$个$0$和$n-1$个$1$组成的排列。

反过来，任何一个由$n+1$个$0$和$n-1$个$1$组成的$2n$位二进制数，由于$0$的个数多于$2$个，$2n$为偶数，故必在某一个奇数位上出现$0$的累计数超过$1$的累计数。同样在后面部分$0$和$1$互换，使之成为由$n$个$0$和$n$个$1$组成的$2n$位数，即$n+1$个$0$和$n-1$个$1$组成的$2n$位数必对应一个不符合要求的数。
因而不合要求的$2n$位数与$n+1$个$0$，$n－1$个$1$组成的排列一一对应。
显然，不符合要求的方案数为$c^{2n}_{n+1}$。由此得出输出序列的总数目=$c^{2n}_n-c^{2n}_{n-1}=c^{2n}_n/(n+1)=h(n)$。

------
------
公式推导完了，该写代码了：

这里用了公式:

$$C_n=\frac{(4n-2)C_{n-1}}{n+1}$$

$Code$:
```cpp
#include<iostream>
using namespace std;
unsigned long long ctl[34]={0,1};
void calc()
{
    int i;
    for(i=2;i<34;i++)
        ctl[i]=ctl[i-1]*(4*i-2)/(i+1);
}
int main()
{
	int p;
	cin>>p;
	calc();
	cout<<ctl[p];
	return 0;
}
```

---

## 作者：world_execute (赞：7)

> ## [[ 更好的阅读体验 ]](https://www.luogu.org/blog/execute/solution-p1044)
> ## [[    原题面    ]](https://www.luogu.org/problem/P1044)
---


### 第零部分 —— 阅读题目

- 题目大意：有 $ n $ 个元素和1个栈
 
- 如果栈非空，可以选择将栈顶元素弹出

- 如果有数未进过栈，可以选择将一个数入栈

- 已知所有数的入栈顺序，求有多种可能的出栈序列

$$$$

- 明显，每个数只能进出栈一次，进出栈共 $ 2n $ 次


---


### 第一部分 —— 开始分析

- 这看起来很像卡特兰数，但是，这篇题解不是来教你卡特兰数的（卡特兰数的题解，似乎进不了题解界面 $ QAQ $ ）

- 我们今天要用 **暴力+剪枝+卡常** 过了这道题

$$$$
$$$$

- 我们发现暴力的代码似乎很好写，时间复杂度也没那么高，大概 $ O(2^{2n} ) $

- $ Therefore ,$ 一份纯暴力的代码就出现了：

```cpp
//#pragma GCC optimize ("O2")
//#pragma GCC optimize ("O3")
//#pragma GCC optimize ("Ofast")

#include <bits/stdc++.h>

int n,Ans;

inline void Doit(const int x,const int y) {
	if (y == n) {			//边界条件，所有数都出栈了
		++ Ans;
		return;
	}
	if (x+y < n) Doit(x+1,y);	//递归操作1，条件：还有数没有入过栈
	if (x) Doit(x-1,y+1);		//递归操作2，条件：栈里还有数
}

signed main() {
	scanf("%d",&n);
	Doit(0,0);
	printf("%d\n",Ans);
}
```

- 代码中的 $ x $ 表示栈里面有 $ x $ 个数，

-  $ y $ 表示出栈了 $ y $ 个数

- 边界条件就是所有数都出栈

$$$$

-  可是，这份代码即使开了 $ O2 $ 也无法过掉 $ n=18 $的数据

- $ So ,$ 我们需要更多的优化

---

### 第二部分 —— 深入思考
#### 优化1：
- 我们发现，当所有数都入栈之后，出栈的顺序似乎只有一种，就是一直出栈

- $ Therefore ,$ 优化出现了，在边界条件的判断上，我们只需判断是不是所有的数都入栈即可，以避免过多的判断

- 具体实现就是将边界条件的判断，$ y == n $ 改成 $ x+y == n $

- 同时，可以将下面判断是否有数没进过栈的条件也可以省略，进一步优化常数

#### 优化2：
- 我们又发现，如果最后还剩下一个数未进栈时，也就是说，我们最后只剩一次进栈操作时，我们有 $ x+1 $ 个空位可以放入这次进栈操作，也就是说，答案可以一次性增加 $ x+1 $ 种方案

- 具体的实现就是将优化1的 $ x+y == n $ 改成 $ x+y == n-1 $，再将答案一次性加上 $ x+1 $

#### 常数优化：
- 我们知道 $ C++ $ 的 && 运算符的短路特征（见延伸阅读①），这通常被用来优化常数，但是有一点需要注意，就是我们不能用 && 运算符来连接一个 $ void $，我们要附加一个值作为返回值

- 还有，因为第一次操作必定是入栈操作（显然，初始状态下栈空），所以，我们可以先以有一个元素的栈作为起始，特别的，我们需要注意 $ n<2 $ 的情况下的特判

$$$$

- 经过上述优化，在加上洛谷的玄学 $ O2 $，我们成功把时间控制在 $ 0.5Sec $ 以内，足以过掉此题，若没有 $ O2 $ ，时间大约在 $ 0.9Sec $左右，有些吃力，可也能通过

### 第三部分 —— 代码实现

- 我相信，大家都能写出这道题的代码（毕竟已经出示了重要优化的核心代码了），但还是放上一份本人的代码吧（自认为码风不错 $ QuQ $）

```cpp
//#pragma GCC optimize ("O2")
//#pragma GCC optimize ("O3")
//#pragma GCC optimize ("Ofast")

#include <bits/stdc++.h>

int n,Ans;

inline void Doit(const int x,const int y) {
	if (x+y == n-1) {		//优化1+优化2
		Ans += x+1;		//优化2
		return;
	}
	Doit(x+1,y),			//常数优化
	(x) && (Doit(x-1,y+1),0);	//常数优化
}

signed main() {
	scanf("%d",&n);
	Doit(n>1,0);			//特判n<=1
	printf("%d\n",Ans);
}
```

### 第四部分 —— 延伸阅读①

- 前面讲过 $ C++ $ 的短路运算符 &&，但什么是短路运算符呢？

- 短路，就是说形如 (表达式)&&(表达式) 的形式，如若前者为假，那么是不是不需要计算后者，就可以知道，这整个表达式的值为假

- 当然，后者必须是一个表达式才可以进行这种运算，当我们发现我们要执行的语句为一个无返回值的 $ void $ 函数时，我们可用逗号，强制加上一个表达式作为需要，同时，这个表达式可以简单到 $ 0 $ 和  $ 1 $ 这样的纯数值

#### 第五部分 —— 后记

- 不知不觉就写了这么多了呢，如果这篇题解中有任何错误，欢迎在评论区，或私信支出，若是你觉的这篇题解还不错，那就点一个赞吧 （ヽ(”`▽´)ﾉ ）


---

## 作者：学霸壹号 (赞：6)

这道题大家都说是“卡特兰数”~~但是我有点蒙，不知道那是什么东西~~，所以就按照自己的想法，搞了一个深度优先搜索（DFS）。

以下是程序片段：
```cpp
//其中sum、n和top均为全局变量
void dfs(int k){
    if(k==n*2){	//如果已经满n*2步（每个数需要2步（先进栈，在出栈），n个数，有n*2步
        if(top==0)	//如果栈里没数，说明有一种可行方案
            ++sum;	//总数加1
        return;	//回到上一层
    }
    if(top){	//如果栈里有数
        --top;	//把栈顶弹出
        dfs(k+1);	//深搜下一步
        ++top;	//恢复
    }
    ++top;	//不管栈里有没有数，可以进栈
    dfs(k+1);	//下一步
    --top;	//恢复
}
//假设所有数已进栈，但dfs还想栈呢？没关系，又没把数记着，只要最后栈空，就可以。
```
[DFS完整代码（仅供参考）](https://www.luogu.org/paste/sbndj2fh)

但是你要是真的写一个DFS上去，那你完蛋了。给你看看结果，让你有心理准备。![题解图1](https://cdn.luogu.com.cn/upload/pic/65460.png)

你要是愿意这样60分，那你就这样得了。

然后你肯定会不服气，不过我们再回到题面看看。

这是你会惊奇的发现~~其实你应该早就看到了~~
### 输入文件只含一个整数$n(1≤n≤18)$
真的太棒了，那我们打表吧。
```cpp
//打表代码在这里
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    if(n==1)
        cout<<1<<endl;
    if(n==2)
        cout<<2<<endl;
    if(n==3)
        cout<<5<<endl;
    if(n==4)
        cout<<14<<endl;
    if(n==5)
        cout<<42<<endl;
    if(n==6)
        cout<<132<<endl;
    if(n==7)
        cout<<429<<endl;
    if(n==8)
        cout<<1430<<endl;
    if(n==9)
        cout<<4862<<endl;
    if(n==10)
        cout<<16796<<endl;
    if(n==11)
        cout<<58786<<endl;
    if(n==12)
        cout<<208012<<endl;
    if(n==13)
        cout<<742900<<endl;
    if(n==14)
        cout<<2674440<<endl;
    if(n==15)
        cout<<9694845<<endl;
    if(n==16)
        cout<<35357670<<endl;
    if(n==17)
        cout<<129644790<<endl;
    if(n==18)
        cout<<477638700<<endl;
    return 0;
}
```
有人会问我，你是怎么算的？

我说，我有生成程序。

~~[生成程序](https://www.luogu.org/paste/c47f9jr7)简单的不用看了吧~~

修正了一下格式，麻烦管理员重新审核。

---

## 作者：jamespaul (赞：5)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dp[20][20];//动规打表 
int n;
int main()
{
    scanf("%d",&n);
    //打表先要设定边界条件，就是一定能够确定值的状态 
    for(int i=0;i<=n;i++) dp[i][0]=1;
    for(int j=1;j<=n;j++)
    {
            for(int i=0;i<=n;i++)
            {
                    if(i==0) dp[i][j]=dp[i+1][j-1];
                    else dp[i][j]=dp[i-1][j]+dp[i+1][j-1];
            }
    }
    printf("%d",dp[0][n]);
    return 0;
}

```

---

## 作者：封禁用户 (赞：5)

## 童鞋们好啊

这题其实就是一个卡特兰数的裸题。

有童鞋会问了，为什么？

问的好，请看这下面的题解。~~我不会告诉你我不知道的~~

# 嗯。

众所周知，卡特兰数有4个公式；

其中有两个是组合数公式；//题意

1， h(n)=C(2n,n)/n+1

2, h(n)=C(2n,n)-C(2n,n+1)

可我遍观题解，就是没人写，为什么呢？

## 你看

组合数C(n,m)=n!/(m!*（n-m）!)

我们看看n，n<=18,那2n<=36啦

36！=.....

肯定爆long long 了

long long 最多可以承受20!;

怎么搞了？

## 你看

我们回去看看组合数公式

h(n)=2n!/(n!*(n!)-2n!/ (n+1)!

```
#include<iostream>
using namespace std;
long long ans1,ans2;
long long gcd(long long a,long long b)
{
    if (a < b)
     swap(a, b);
    return b == 0 ? a : gcd(b, a % b);
}
long long jc(int f)//阶乘
{   long long sum=1;
    for(int i=1;i<=f;i++)
    {
        sum*=i;
    }
    return sum;
}
long long jc1(int f)
{   long long sum=1;
    for(int i=f/2+1;i<=f;++i)
    {
        sum*=i;
        int u=gcd(sum,ans1);
        sum/=u;
        ans1/=u;
    }
    sum/=ans1;
    return sum;
}
long long jc2(int f)
{   long long sum=1;
    for(int i=f/2+2;i<=f;++i)
    {
        sum*=i;
        long long u=gcd(sum,ans2);
        sum/=u;
        ans2/=u;
    }
    sum/=ans2;
    return sum;
}
int main()
{
    int n;
    cin>>n;
ans2=jc(n-1);
ans1=jc(n);
cout<<jc1(2*n)-jc2(2*n);
 } 
```
//管理员别过，没写完，保存一下

---

## 作者：InfinityTian (赞：5)

# ***首先，这是一道关于~~卡特兰数~~的题！！！***

- ## 其次，给大家推荐一个数列查询网站，方便打表！**

[数列查询网站:oeis](oeis.org)

emmm.......

因为某种原因,上述链接已失效,请自行登录

oeis.org

----

这道题的数据很水!所以:——

是的,你没有看错,我要打表！

----

首先,公布一个~~大坑~~!
**在网站上查询到的结果是~~1~~,1,2,5,14......
但我们不需要第一个~~1~~!
所以拷贝时要将第一个`1`去掉!**

----

***本人也贴心的将前十八个数附上:***

`
1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700
`
----

代码附上:
```cpp
#include <iostream>
using namespace std;
int main(){
	long long catalan[18]={1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700};
	int n;
	cin>>n;
	cout<<catalan[n-1]<<endl;
	return 0;
}
```


----
----
----

---

## 作者：2017gangbazi (赞：5)

/\*
想了半天，有点暴力的想到了这个方法

比如 3的情况有5种，分别为

1 2 3
3 2 1
2 1 3
2 3 1
1 3 2
那么，4的次数在3的基础上增加的第一种情况，就是在每个数字后面加上4，即

1 2 3 4

3 2 1 4

2 1 3 4

2 3 1 4

1 3 2 4

然后，讲4向前移动，变成

1 2 4 3

3 2 4 1

2 1 4 3

2 3 4 1

1 3 4 2

此时继续前移时，只有3种情况，因为需要对4后面的数进行排序

即
1 4 3 2

2 4 3 1

3 4 2 1

最后还有一种

4 3 2 1

那么，显而易见，这个规律就是

1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

2 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

5 5 3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

14 14 9 4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

42 42 28 14 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

132 132 90 48 20 6 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

429 429 297 165 75 27 7 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

1430 1430 （1001） 572 275 110 35 8 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

4862 4862 3432 2002 1001 429 154 44 9 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

每一排的总数即为情况数

1001=429+297+165+75+....+0

下面贴代码\*/




```cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int work[n+100][n+100];
    for(int i=0;i<=n+10;i++)
    for(int j=0;j<=n+10;j++)
    work[i][j]=0;
    work[1][1]=1;
    work[1][2]=0;
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            for(int m=i;m>=j-1;m--)
            work[i][j]+=work[i-1][m];
            work[i][i+1]=0;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    ans+=work[n][i];
    cout<<ans;
}

```

---

## 作者：DarkKris (赞：4)

首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)\*f(k-1)种，求和便是Catalan递归式。ps.author.陶百百）(来自百度百科)


C++代码如下

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n;
int h[20];
int main()
{
        cin>>n;
        h[0]=1;h[1]=1;
        for(int i=2;i<=n;i++)
            for(int j=0;j<=i-1;j++)
                h[i]=h[i]+h[j]*h[i-j-1];
        cout<<h[n];
        return 0;
}
```

---

## 作者：Umbrella_Leaf (赞：4)

又一道比较水的题目~~
 
~~（主要是我太蒟蒻了，只会写水题的题解）~~


这道题用的是一个叫Catalan数的东西（下面的内容大佬请忽略）

卡特兰数是用来表示满足一下递推关系的数列：

            h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)
            且h(0)=1

而且卡特兰数还有如下通项公式：
 h(n)=C(2n,n)/(n+1)

另外卡特兰数还有如下记忆方法：~~（对于记忆力不强的请跳过）~~

 1,1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...

~~这是一个非常好的记忆法则，大家每天晚上睡觉前多读几遍。。。~~

那么，卡特兰数有用吗？


（废话，当然有）

那么，它有什么用呢？

（同学们齐声回答：出题！！！）

~~呵呵，对了。~~

卡特兰数的作用就是：

 请看本题

（刚刚忽略这段的大佬快回来）

题目大意就是：给你一个进栈序列，让你求出所有可能的出栈序列。

让我们先暴力地列举一下：

当n=0时：？

当n=1时：1
         
当n=2时：1 2/2 1

当n=3时：1 2 3/1 3 2/2 1 3/2 3 1/3 2 1

当n=4时：1 2 3 4/1 2 4 3/1 3 2 4/1 3 4 2/1 4 3 2/2 1 3 4/2 1 4 3/2 3 1 4/3 2 1 4/2 3 4 1/2 4 3 1/3 2 4 1/3 4 2 1/4 3 2 1

…………………………

你有没有看出什么呢？如果没有，我们来分类讨论一下：（以n=3作为栗子）

#### 当1在第1个时：前面有一种状况：？（是不是感觉和n=0很像）；后面有两种状况：2 3和3 2（是不是感觉和n=2很像）

#### 当1在第2个时：前面有一种状况：2（是不是感觉和n=1很像）；后面有一种状况：3（是不是感觉和n=1很像）

#### 当1在第3个时，前面有两种状况：2 3和3 2（是不是感觉和n=2很像），后面有一种状况：？（是不是感觉和n=0很像）

请大家对着上面这段话使用“火眼金睛”技能，发现其中的奥妙~~洗衣液~~：

### 当1在第i个时，前面就是2~i的一个出栈序列，后面就是i+1~n的一个序列。

于是我们设这n个数的出栈序列为f[n]，则根据乘法原理有：

##            f(n)= f(0)*f(n-1)+f(1)*f(n-2) + ... +f(n-1)*f(0) (n>=2)
##             且f(0)=1

这不就是卡特兰数吗！！！！！！！！！！……（此处共有Catalan(10000)个感叹号）

但我们怎么求它呢？

显然，递推是可以的~~

但本人认为，可以用通项公式来解决它！！！就是这个：

### h(n)=C(2n,n)/(n+1)

这时有些蒟蒻们就会说了，这道题不是一道大水题吗！！！！！

稍等一下，您就会看到其中的精髓~~

蒟蒻的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int c(int n){//组合数（已经除以n+1）
	int ans=1;
	for(int i=1;i<=n;i++){
		ans*=i+n;ans/=i;
	}
	return ans/(n+1);
}
int main(){
	int n;
	scanf("%d",&n);
	printf("%d\n",c(n));
	return 0;
}
```
但大家吧这段代码交上去后，会发现居然只有60分！

 这是因为有个大大的坑！！！！！（我也被坑了）

就是n<=18！

 虽然18不大，但~~根据前面讲到的记忆法则~~已经要用long long了！！！！！

所以AC代码如下（）：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long c(long long n){
	long long ans=1;
	for(long long i=1;i<=n;i++){
		ans*=i+n;ans/=i;
	}
	return ans/(n+1);
}
int main(){
	long long n;
	scanf("%lld",&n);
	printf("%lld\n",c(n));
	return 0;
}
```

---

## 作者：Masterchief (赞：4)

### 递归

这个看到没有人发递归~（貌似）~就发了出来，分三种情况：

1.栈空

这个情况就只能进栈

2.外面没人了

这个情况就只能挨个出栈，所以就返回1

3.普通情况

有两种选择，要么进栈，要么出栈

裸的最后一个会超时，所以加个表优化，代码如下

```cpp
#include<iostream>
#include<string.h>
using namespace std;
int n,ans=0;
int v[100][100];
int dfs(int x,int top)
{
     if(!x)return 1;//外面没数
     if(!top && x)//栈空
     {
       if(!v[x-1][top+1])
         v[x-1][top+1]=dfs(x-1,top+1);
       return v[x-1][top+1];
     }
     if(!v[x][top])
       v[x][top]=dfs(x-1,top+1)+dfs(x,top-1);//普通情况
     return v[x][top];
}
int main()
{
     scanf("%d",&n);//读入
     memset(v,0,sizeof(v));
     printf("%d",dfs(n,0));
     return 0;
}
```

---

## 作者：小小小朋友 (赞：4)

#### 题目描述:

问一个栈的出栈顺序有几种，一道很经典的题目了

#### 思路:

明显，这是一道卡特兰数的模板题，我们来看看如何使用卡特兰数的组合数公式。

预计算出阶乘，就可以用下面的公式来计算组合数了

$$ C^n_m=n!\div m! \div (n-m)!$$

由于python自带高精度，这道题用python就十分简单了

解释代码里有。

#### 代码:
```python
fact=[1] # fact用来存阶乘
def comb(n,i): # 计算组合数的函数
    return(fact[n]/fact[i]/fact[n-i])
for i in range(1,10000):
    fact.append(fact[i-1]*i) # 预计算阶乘
n=int(input()) # 输入n
print(int(comb(2*n,n)//(n+1))) # 直接计算卡特兰数
```

---

## 作者：niolle (赞：4)

O(n)Catalan数

这是一道Catalan数的题

楼上dalao都讲的灰常清晰，作为语文年排正(dao)数的蒟蒻胡说一下

我们设有n个数的输出总数为f(n)

设第n个数最后出栈

即f(n)=f(0)*f(n-1)+f(1)*f(n-2)+……+f(n-1)*f(0)  
//先搞0个数再搞n-1个数的输出总数+……先搞n-1个数再搞0个数的输出总数

这个就是Catalan数基本工式

经过一系列work可以搞成f(n)=(2n)!/n!/(n+1)!      (catalan数终极公式)


```.cpp
#include <stdio.h>
#include <iostream>
using namespace std;
long long zlk(long long x,long long y){
	long long sum=1;
	for(long long i=y;i<=x;i++) sum*=i;
	return sum;
}
long long gcd(long long x,long long y){return y==0?x:gcd(y,x%y);}
long long wyx(long long x,long long y,long long love){
	long long sum=1;
	for(long long i=y;i<=x;i++){
		long long k=gcd(love,i);
		sum*=i/k;love/=k;
	} 
	return sum;
}
int main()
{
    long long n;
    scanf("%lld",&n);
    printf("%lld",wyx(2*n,n+2,zlk(n,2)));
    return 0;
}```

---

## 作者：WH1KI9RAVE (赞：4)

```cpp
#include <cstdio>
int main(){
    long long n,f=1;
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) f=f*(4*i-2)/(i+1);
    printf("%lld",f); 
}
```
貌似成为了最简
按最后一个数分类，卡特兰数

一些知识：

令h(0)=1,h(1)=1，catalan数满足递推式


h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)\*h(0) (n>=2)

h(n)=h(n-1)\*(4\*n-2)/(n+1);



---

## 作者：一碗粥 (赞：4)

这题真的不难，动规，规律已经给出a[i]:=a[j-1]\*a[i-j]+a[i];，直接出代码：


var
  i,j,k,m,n,s,t:longint;

  a:array[0..18] of longint;

begin
  readln(n);

  a[0]:=1;

  a[1]:=1;

  for i:=2 to n do

    for j:=1 to i do

      a[i]:=a[j-1]\*a[i-j]+a[i];

  writeln(a[n]);

end.


---

## 作者：点击获取“V”认证 (赞：4)

本题等同于多边形三角剖分问题，详情请见旧版人教版数学教科书七年级下册第86页

公式如下：a[n+1]:a[n]=4n-6:n(注：a[3]的值等于本题a[1]的值，其余不变)

递推式如下：a[i]:=a[i-1]\*(4\*i-2) div (i+1);

[center]求精[/center]


---

## 作者：Wind_Shear (赞：3)

### 发现没有Python题解！！！

首先我看了看题，然后看了看题解

又看了看题，又看了看题解

又看了看题，又看了看题解

~~什么东西啊~~

发现这题可以用Python做

然后自信满满地打开了IDLE

然后自信满满地写下了代码

然后~~稻花香里说丰年，听取WA声一片~~

#### 回到正题

首先我是这么搞得

```python
n=int(input(""))#输入
f=[0 for i in range(10000)]//创建那个列表
f[0]=1#递推
f[1]=1#递推
for i in range(2,n+1):
    for j in range(0,i):
            f[i]+=f[j]*f[i-j-1]#递推
    print(f[n])#输出
'''
结束
'''
```
然而WA了，日常发帖求助

然后来了一位大佬[@一个python屑](https://www.luogu.org/space/show?uid=82672)

然后帮我改好了

# AC Code：
```python
n = int(input())
f = [0 for i in range(n + 1)]
f[0] = 1
f[1] = 1
for i in range(2, n + 1):
    for j in range(0, i):
        f[i] += f[j] * f[i - j - 1]
print(f[n])
```

注释就不打了，就是第二行改了

CSP2019 RP++

P.S.CSP管你Python什么事！喂喂喂，我也会C++啊

---

## 作者：Sino_E (赞：3)

纯搜索。

通过观察发现，只要操作序列不同，那么得到的数的序列绝对不同。

样例所示，假设push操作为u，pop操作为o：

五种操作序列为：uououo uuoouo uuouoo uouuoo uuuooo

因此我们发现只要枚举操作序列的个数。

搜索的两个参数为栈内元素的数量和队列元素的数量。

最后发现TLE了一个点，于是加上了记忆化搜索，过了。

最后最后才醒悟过来，这不是dp么....

dp方程：d(i,j)=d(i+1,j-1)+d(i-1,j)   d(0,0)=1 答案是d(0,n)

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
const int N=20;
int d[N][N];
bool tag[N][N];

int dfs(int st,int qu){
    if(tag[st][qu])return d[st][qu];
    int ret=0;
    if(qu)ret+=dfs(st+1,qu-1);//push
    if(st)ret+=dfs(st-1,qu);//pop
    d[st][qu]=ret;
    tag[st][qu]=1;
    return ret;
}
int main(){
    int n;
    cin>>n;
    d[0][0]=1;
    tag[0][0]=1;
    cout<<dfs(0,n);
    return 0;
}
```

---

## 作者：wzf2000 (赞：3)

```delphi

var
  n,i:longint;
  s:int64;
begin
  readln(n);
  s:=1;
  for i:=1 to n do
    s:=s*(n+i) div i;
  s:=s div (n+1);
  writeln(s);
end.

```
卡特兰数列，注意用int64


---

## 作者：林志杰 (赞：3)

卡特兰数，运用公式h(n) =C(2n,n)/(n+1).

假设k是最后一个出栈的数。那么比k早进栈且早出栈的有k-1个数，一共有h(k-1)种方案。比k晚进栈且早出栈的有n-k个数，一共有h(n-k)种方案。所以一共有h(k-1)\*h(n-k)种方案。显而易见，k取不同值时，产生的出栈序列是相互独立的，所以结果可以累加。k的取值范围为1至n，所以结果就为h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)h(0)。

但是不开long long组合数会爆，注意这点







```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define R read()
using namespace std;
inline long long  read(); 
const long long maxn = 4100;
long long n,h[maxn],c[maxn][maxn];
long long C(long long n,long long m)
{
    if(m == 0) return 1;
    if(n == m) return 1;
    if(c[n][m]) return c[n][m];
    else return c[n][m] = C(n-1,m) + C(n-1,m-1);
}
int main()
{
    n = R;
    printf("%d",C(2*n,n)/(n+1));
    return 0;
}
inline long long read()
{
    long long w=1,x=0;
    char ch = getchar();
    while(ch < '0' || ch > '9') {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch <= '9' && ch >= '0') {
        x = (x<<1) + (x<<3) + ch - '0';
        ch = getchar();
    }
    return x*w;
}
```

---

## 作者：青丝、暮成雪 (赞：2)

这道题我用的卡特兰数列，应该有不用的解法，不过直接用应该会简单些，卡特兰递推式：h(n)=(4n-2)/(n+1)\*h(n-1)(n>1) h(0)=1


```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n;
double dp[20];
int main() 
{
    scanf("%d",&n);
    dp[0]=dp[1]=1;//卡特兰数列的前两项（和斐波拉契数列没差）
    for(int i=2;i<=n;i++)
    {
        double temp=(4*i-2.0)/(i+1.0);//会有小数部分
        dp[i]=temp*dp[i-1];//卡特兰数列递推式
    }
    printf("%.lf\n",dp[n]);
    return 0;
}
```

---

## 作者：kongjunfeng (赞：2)

### 便于理解的一种解法 (我这么认为)

80分的解法,最后一个点过不去

#### 主函数:

```cpp
unsigned int n;
int main(){
	scanf("%d",&n);
	printf("%d",f(0,0));//解题函数f
	return 0;
}
```

n是总元素数

#### 首先
递归函数

```cpp
unsigned int f (unsigned int Ru,unsigned int Cu)//因为它返回无符号的整数,所以要加unsigned
```
第一个参数Ru表示栈内有多少个元素

第二个参数Cu表示输出序列有多少个元素(已经处理完成的个数)



计数:
```cpp
unsigned count = 0;
```


#### 接着

当Cu (处理完成的个数) 为 n 时表示这是1个可能,函数返回1
```cpp
if(Cu==n)return 1;
```
如果不为n就代表这不是一个完整的可能,继续递归

```cpp
count += f(Ru-1,Cu+1);// 出栈 
count += f(Ru+1,Cu);// 入栈 
```
但是继续递归的出入栈是有条件的

##### 条件1:

栈里没有元素就不能进行出栈,所以
```cpp
if(Ru > 0)// 必须有元素才可以出栈
	count += f(Ru-1,Cu+1);// 出栈 
```
##### 条件2:

所有输入输入完了就不能进行出栈,所以
```cpp
if(Cu+Ru < n) // 必须没有入完才可以入栈
	count += f(Ru+1,Cu);// 入栈
```
#### 不要忘了
计数count需要返回给上层递归,表示这个操作之后有多少可能,所以
```cpp
return count;
```
#### 最后
最后的最后就是这样
```cpp
#include <iostream>
#include <cstdio>

#using namespace std;

unsigned int f (unsigned int Ru,unsigned int Cu)
{
		
	if(Cu==n)return 1;
	int count = 0;
    
	if(Ru>0)count += f(Ru-1,Cu+1); // 出
	if(Cu+Ru < n) count += f(Ru+1,Cu);// 入
	
	return count;
}
int main(){
	scanf("%d",&n);
	printf("%d",f(0,0));
	return 0;
}
```



---

## 作者：0carryt0 (赞：2)

**这题的深搜算法！！！**

经典的求出栈情况的卡特兰数

栈要有进才能有出，设进为0，出为1；

那么每个1前必有一个0；

所以,

**n=1时 方法数s=1 （01）**

**n=2时 方法数s=2 （0011，0101）**

**n=3时 方法数s=5 （000111，001011，001101，010011，010101）**

………………

**也就是h（n）=h(0)\*h(n-1)+h(1)\*h(n-2)+……+h(n-1)\*h(0)**

但按这递推模拟的话，最后一个点会吃TLE；

所以蒟蒻我将前后对称的就乘2处理（值一样）

特判奇偶，分情况处理（奇数中间不用\*2）

```cpp
#include<bits/stdc++.h>
using namespace std;
int work(int n)
{
    int s=0;
    if ((n==1)||(n==0)) return 1;
    int k=n%2;
      for(int i=0;i<n/2;i++)
        s+=2*work(i)*work(n-1-i);
    for(int i=1;i<=k;i++)
      s+=work(n/2)*work(n/2);
    return s;
}
int main()
{
    int n;
    cin>>n;
    cout<<work(n);
    return 0;
}
```

---

## 作者：li20082008li (赞：2)

这里我给一下hongweixin同学的方法的思想：

我们假设从开始到所有元素都出栈为止，第一个出栈的元素是j（j可以是1~n）。对于每一个大于1的序列，都可以从j拆分成两个序列：

假设从1..j-1是第一个序列，第j+1..n是第二个序列，那么第一个序列就有j-1个元素，第二个序列就有n-j个元素（j-1为0或者n=j时就默认第一个序列或者第二个序列为空，而空序列只有一个可能）。

再假设a(n)是有n个元素的所有出栈序列数目，那么再基于乘法原理，得出a(n)=a(j-1)\*a(n-j)；而j可以从1枚举到n，再依据加法原理，最终的a(n)就是把每一个枚举的a(j-1)\*a(n-j)相加了（a(n)=a(n)+a(j-1)\*a(n-j)）。

这时只要预处理a(0)=1,a(1)=1，再算出a(2..n)（n>=2），打出a(n)就可以了~

[color=green]话说我怎么看这方法怎么像合并类动规......是不是我动规写多了......[/color]

附我自己的程序：

```delphi

program ex1231;
var
  i,j,k,m,n,s,t:longint;
  a:array[0..18] of longint;
begin
  readln(n);
  a[0]:=1;
  a[1]:=1;
  for i:=2 to n do
    for j:=1 to i do
      a[i]:=a[j-1]*a[i-j]+a[i];
  writeln(a[n]);
end.

```

---

## 作者：gb530 (赞：2)

# 2018/10/13 本蒟蒻第一次提高组初赛祭
## 选择题第8题有关卡特兰数


-----------------------------------------------------伟大的分割线--------------------------------------------------------

### 卡特兰数
### 是组合数学中一个常出现在各种计数问题中出现的数列，其前几项为（从第零项开始） : 1, 1, 2, 5, 14, 42, 132, 429,···
### 递推公式为 h(n)=(2n)!/(n+1)!/n!
## 一些有趣的重要结论：
### 括号化
#### 矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n)种)
### 出栈次序
#### 一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?(h(n)种)
### 给定节点组成二叉搜索树
#### 给定N个节点，能构成多少种不同的二叉搜索树？（能构成h(n)个）
### 凸多边形三角划分
#### 在一个凸多边形中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是键盘上输入凸多边形的边数n，求不同划分的方案数f（n）。比如当n=6时，f（6）=14。
## 这里附上求卡特兰数的代码
```cpp
void catalan() //求卡特兰数
{
    int i, j, len, carry, temp;
    a[1][0] = b[1] = 1;
    len = 1;
    for(i = 2; i <= 100; i++)
    {
        for(j = 0; j < len; j++) //乘法
        a[i][j] = a[i-1][j]*(4*(i-1)+2);
        carry = 0;
        for(j = 0; j < len; j++) //处理相乘结果
        {
            temp = a[i][j] + carry;
            a[i][j] = temp % 10;
            carry = temp / 10;
        }
        while(carry) //进位处理
        {
            a[i][len++] = carry % 10;
            carry /= 10;
        }
        carry = 0;
        for(j = len-1; j >= 0; j--) //除法
        {
            temp = carry*10 + a[i][j];
            a[i][j] = temp/(i+1);
            carry = temp%(i+1);
        }
        while(!a[i][len-1]) //高位零处理
        len --;
        b[i] = len;
    }
}
```

---

## 作者：樱墨抄 (赞：2)

标准的卡特兰特数，一层for循环就行。




```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int h[105];
int main()
{
    int n;
    scanf("%d",&n);
    h[0]=1;//初始变量h[0]为1
    for(int i=1;i<=n;i++){//双层循环
        for(int j=0;j<=n-1;j++){
        h[i]+=h[j]*h[i-1-j];//卡特兰特数公式
            }
    }
    printf("%d\n",h[n]);
    return 0;
}
```

---

## 作者：Sagittarius (赞：2)

```cpp
//F(n)=c(2n,n)/(n+1) 通项公式 C为组合数
//这道题我算了几个数发现答案是大名鼎鼎的卡特兰数，于是果断上通项公式
//比较坑的地方就是不管你用longint还是int64，在求C的时候都会爆炸，所以全部开real，最后定义场宽输出整数部分
var
    n:longint;
function c(x1,x2:longint):real;
var
    ans:real;
    i:longint;
begin
    ans:=1;
    for i:=x1 downto x1-x2+1 do
        ans:=ans*i;
    for i:=1 to x2 do
        ans:=ans / i;
    exit(ans);
end;
function catalan(x:longint):real;
var
    ans:real;
begin
    ans:=c(2*x,x) / (x+1);//这是卡特兰数的通项公式
    exit(ans);
end;
begin
    readln(n);
    writeln(catalan(n):0:0);
end.
```

---

## 作者：windyscGPT7 (赞：2)

某蒟蒻路过。。。话说Catalan数不止是运用于stack。。。还可以用于二叉树。。。

DP代码见下：

用一个数组f存方案数，其中fi]代表总数为y时的总方案数

```cpp
program ex_1;
 var i,j,k,n:longint;
      f:array[0..25]of longint;
begin
 {assign(input,'stack.in');
    assign(output,'stack.out');
     reset(input)；
      rewrite(output);}
read(n);
f[0]:=1;
f[1]:=1;
 for i:=2 to n do
begin
 j:=i-1;
  k:=0;
   while k<>i do
begin
  f[i]:=f[j]*f[k]+f[i];
   dec(j);
    inc(k);
end;
end;
 writeln(f[n]);
 {close(input); 
  close(output);}
end.
```

---

## 作者：autoint (赞：0)

###经典的卡特兰数问题

##可以**打表**

#原理

- 令h(0)=1,h(1)=1，catalan数满足递推式:

- h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)h(0) (n>=2)

- 例如:h(2)=h(0)\*h(1)+h(1)\*h(0)=1\*1+1\*1=2

- h(3)=h(0)\*h(2)+h(1)\*h(1)+h(2)\*h(0)=1\*2+1\*1+2\*1=5

- 另类递推式:

- h(n)=h(n-1)\*(4\*n-2)/(n+1);

- 递推关系的解为:

- h(n)=C(2n,n)/(n+1) (n=0,1,2,...)

- 递推关系的另类解为:


- h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...)

#前几项按照方程推出来为

1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452

**这就是打表（预处理）的基础**


#以下是代码


```cpp
#include<iostream>
using namespace std;
int main(){
    int a[50]={0,1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790,     477638700, 1767263190, 6564120420};
    int n;
    cin>>n;
    cout<<a[n];
    return 0;
}
```

---


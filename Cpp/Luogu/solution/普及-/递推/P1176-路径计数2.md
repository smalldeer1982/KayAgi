# 路径计数2

## 题目描述

一个 $N \times N$ 的网格，你一开始在 $(1,1)$，即左上角。每次只能移动到下方相邻的格子或者右方相邻的格子，问到达 $(N,N)$，即右下角有多少种方法。

但是这个问题太简单了，所以现在有 $M$ 个格子上有障碍，即不能走到这 $M$ 个格子上。


## 说明/提示

对于 $20\%$ 的数据，有$N≤3$；

对于 $40\%$ 的数据，有$N≤100$；

对于 $40\%$ 的数据，有$M=0$；

对于 $100\%$ 的数据，有$N≤1000,M≤100000$。


## 样例 #1

### 输入

```
3 1
3 1```

### 输出

```
5```

# 题解

## 作者：憨憨儿 (赞：125)

~~路过请看看啊，点个赞~~

这道题其实非常简单，跟2002年【NOIP普及组】过河卒基本思路一样，用递推的思想，把不能走的地方标记一下。
规律我就不推了直接看吧
```c
x[i][j]=x[i][j-1]+x[i-1][j];//应该看得懂
```
首先就是：定数组
```c
unsigned long long x[2000][2000];
bool y[2000][2000];//开得比n最大值大一些
```
输入并且赋初始值
```c
int n,m,a,b;
	cin>>n>>m;
	x[1][1]=1;
```
先把方格全标成“可以走”，不然标记"不可走"时会很麻烦
```c
for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		y[i][j]=true;
	}
```
输入坐标并标记“不可走”
```c
for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		y[a][b]=false;
	}
```
开始递推
```c
for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		if(y[i][j]==false||(i==1&&j==1))
		continue;//第一个格子和“不可走”格子跳过
		else if(i==1&&y[i][j]==true)x[i][j]=x[i][j-1]%100003;//边界情况，注意模100003
		else if(j==1&&y[i][j]==true)x[i][j]=x[i-1][j]%100003;//同上
		else if(y[i][j]==true)x[i][j]=(x[i-1][j]%100003+x[i][j-1]%100003)%100003;//规律应用
	}
```
输出
```c
cout<<x[n][n];
```
好啦，本片题解就到此啦，各位大佬不喜轻喷。

具体代码我不会发的，把上面的拼接在一起加头文件就可以了。

---

## 作者：Jimmy000 (赞：40)

因为a[i][j]可以走到a[i+1][j]和a[i][j+1]

所以a[i][j]可以由a[i-1][j]和a[i][j-1]走到

所以递推式为

a[i][j]=a[i-1][j]+a[i][j-1]
#### 由此

## 思路：
1. 定义数组a，b  a存储走法  b记录不可以走的
1. 输入 并标记不可以走的
1. a[1][1]有一种走法 a[1][1]=1
1. 递推a[i][j]=a[i-1][j]+a[i][j-1]
1. 把标记了不可以走的数组赋值0
1. 把a[i][j]取%
1. 输出a[n][n]
所以  
### 程序如下

```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int a[1001][1001],b[1001][1001];//数组定义大点，1000会爆
int main()
{	int n,m,x,y; 
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{cin>>x>>y;
	 b[x][y]=1;//b数组标记不可以走的
	}
	a[1][1]=1;//最开始a[1][1]
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{a[i][j]+=a[i-1][j]+a[i][j-1];//赋值
	 if(b[i][j]==1) a[i][j]=0;//不可以走的赋值0
	 a[i][j]=a[i][j]%100003;//取%
	}
	cout<<a[n][n];//输出
	return 0;
}
```
现在小伙伴们懂了吗？？

---

## 作者：wcl95716 (赞：10)

对于每个格子，能走的路径只有下和右，

所以 对于每个格子，路径数喂上和左路径数的和。

第一个格子的路径数喂1；



```cpp
#include<iostream>
#include<string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <map>
#include <cstdio>
using namespace std;
int dp[1005][1005];//路径记录
int tag[1005][1005];//标记障碍物
const int mod=100003;
int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        memset(dp,0,sizeof(dp));
        memset(tag,0,sizeof(tag));
        dp[0][1]=1;
        int x,y;
        for(int i=0;i<m;i++)
        {
            cin>>x>>y;
            tag[x][y]=1;
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                dp[i][j]=(dp[i-1][j]+dp[i][j-1])%mod;
                if(tag[i][j]==1) dp[i][j]=0;//如果此处有障碍物。那么是不可达 标记为0；
            }
        }
        cout<<dp[n][n]<<endl;
    }
}

```

---

## 作者：佳铭 (赞：9)

## 一道经典的递推题
先来看看没有障碍物的：（数字代表路径）
| 1 | 1 | 1 | 1 |
| -----------: | -----------: | -----------: | -----------: |
| 1 | 2 | 3 |  4|
|  1|  3| 6 | 10 |
得出递推式:
```
f[i][j]=f[i-1][j]+f[i][j-1]
```
## 上代码！！！
```cpp
#include<cstdio>
using namespace std;
```
首先，我们开两个数组，一个用于计数，一个标记障碍物。
```cpp
int f[1010][1010];
bool vis[1010][1010];
int main()
{
	int n,m,x,y;
```
扫描到障碍物时，标记一下。
```cpp
scanf("%d%d",&n,&m);
for(int i=1;i<=m;++i)
{
	scanf("%d%d",&x,&y);
	vis[x][y]=true;
}	
```
递推边界：
```cpp
f[0][1]=1;
```
开始递推：
```cpp
for(int i=1;i<=n;++i)
	for(int j=1;j<=n;++j)
	{
		f[i][j]=(f[i-1][j]+f[i][j-1])%100003;//防止数据太大，过程中取模
		if(vis[i][j]) f[i][j]=0;//有障碍物，记为0
	}
```
输出，结束：
```cpp
        printf("%d",f[n][n]);
	return 0;
} 
```

---

## 作者：灵光一闪 (赞：6)

什么？路径？不用说了！递归走起：

从最后一个点【终点】开始递归，碰到边界返回1，障碍返回0，不然返回左边和上面的路径和【怎么算？递归鸭！】
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

using namespace std;
int a[2333][2333];
bool stop[2333][2333];
int dg(int x,int y){
	if(stop[x][y]){
		return 0;
	}
	if(x==1||y==1){//碰到边界
		return 1;
	}
	else{//继续递归
		return dg(x-1,y)%100003+dg(x,y-1)%100003;
	}
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int x,y;
		cin>>x>>y;
		stop[x][y]=true;
	}
	cout<<dg(n,n)%100003<<endl;//递归
	return 0;
}
```

哇，这个递归归（跪）的舒服啊
![](https://cdn.luogu.com.cn/upload/image_hosting/rbv8aido.png)

仔细一想：这一个题其实就是一道小学奥数题：
|  |  |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
|  |  |  |  |  |
只能向右向下，问从(1,1)到(5,5)有多少条路径

这个相信每一位老师都会教你怎么做

递推推一波？
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

using namespace std;
int a[2333][2333];
bool stop[2333][2333];
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int x,y;
		cin>>x>>y;
		stop[x][y]=true;
	}
	a[1][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(stop[i][j]||(i==j&&i==1)){//障碍不能赋值
				continue;
			}
			a[i][j]=a[i-1][j]+a[i][j-1];
			a[i][j]%=100003;//记得取%
		}
	}
	cout<<a[n][n]%100003<<endl;//取%+输出
	return 0;
}
```

The End.

---

## 作者：ydclyq (赞：4)

貌似有点递推的感觉，，，

然后就推，，

貌似是这样的

f[i][j]=f[i][j-1]+f[i-1][j]

注意：障碍不能走，所以就设障碍的点为-1

```cpp
	for(int i=1; i<=m; i++) {
		int a,b;
		cin>>a>>b;
		f[a][b]=-1;
	}
```
再就是特判一下是否可以有上和左转移到该点了
```cpp
	f[i][j]=max(max(f[i][j-1],f[i][j]),max(f[i-1][j],f[i-1][j]+f[i][j-1]));
```
还要注意模数是100003

嗷嗷啊 因为模数被卡了好几次

代码：
```cpp


#include<iostream>
#include<cstdio>
using namespace std;
int f[1001][1001];
int n,m;
int main() {
	cin>>n>>m;
	for(int i=1; i<=m; i++) {
		int a,b;
		cin>>a>>b;
		f[a][b]=-1;
	}
	f[1][1]=1;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			if(f[i][j]!=-1) {
				f[i][j]=max(max(f[i][j-1],f[i][j]),max(f[i-1][j],f[i-1][j]+f[i][j-1]));
			}
			f[i][j]%=100003;
		}
	}
	cout<<f[n][n];
	return 0;
}
```

完结，，，，


---

## 作者：Atmizz (赞：2)

### 思路：
> - DP！注意状态转移方程：
```cpp
g[i][j]=(g[i-1][j]+g[i][j-1])%100003;
```
> - 再者，要注意保存障碍的坐标，然后对经过他路径个数置零。

说一下我的AC艰难过程吧，一开始一看题目，哦！求路径个数，而且还有障碍，二话不说就DFS，当时还想着一定要回溯。
我还是先贴一下DFS的代码吧！
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>

using namespace std;

int n,ans=0,m,g[1001][1001],xx[2]={1,0},yy[2]={0,1};	//两种移动方式
bool v[1001][1001];	//判断是否走过

void DFS(int x,int y)
{
    if(x==n && y==n) 	//到达了终点
    {
        ans++;
        return;		//回溯
    }
    for(int i=0;i<2;i++) {
        int dx=x+xx[i];
        int dy=y+yy[i];
        if(dx>=1 && dx<=n && dy>=1 && dy<=n && g[dx][dy]==0 && v[dx][dy]==0) {		//限定条件，在矩阵内&&没有障碍&&没走过
            v[dx][dy]=1;
            DFS(dx,dy);
            v[dx][dy]=0;//回溯，便于下次查找
        }
    }
}

int main()
{
    int x,y;
    memset(v,0,sizeof v);//初始化
    memset(g,0,sizeof g);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) {
        scanf("%d%d",&x,&y);
        g[x][y]=1;	//障碍都标记一下
    }
    v[1][1]=1;		//起点肯定走过
    DFS(1,1);
    printf("%d",ans%100003);//输出路径个数。
    return 0;
}
```
结果当然是开心的1个AC，4个TLE。于是乎，重新审了题目，发现n的范围挺大的，DFS确实不行，但是我想到了 [过河卒](https://www.luogu.org/problemnew/show/P1002),我觉得差不多，就是DP，这才完美AC掉（~~其实用掉的时间很多！！~~）。
还有一个东西要说明一下（其实也有人证明了）：

**(a+b)%c=((a%c)+(b%c))%c**
### 完整code：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>

using namespace std;

int n,m,g[1001][1001];
bool v[1001][1001];		//判断是否有障碍 

int main()
{
	int x,y;
	memset(g,0,sizeof g);	//初始化步数都为0 
	memset(v,0,sizeof v);	//路障都为0 
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=m;i++) {
		scanf("%d%d",&x,&y);
		v[x][y]=1;
	}
	
	g[0][1]=1;		//初始化第一步棋子 
	
	for(int i=1;i<=n;i++)//逐步开始递推
		for(int j=1;j<=n;j++) {
			g[i][j]=(g[i-1][j]+g[i][j-1])%100003;	//一定要取模 
			if(v[i][j]==1)//这个地方是障碍，那么到这里的步数都为0 
				g[i][j]=0;
		}
	printf("%d",g[n][n]);//最后终点的部署及为答案。 
	return 0;//结束 
}
```

---

## 作者：二力平衡树 (赞：2)

一道基础的动态规划题目

首先，题目描述的重点在于每次只能移动到下方相邻的格子或者右方相邻的格子，所以，我们就可以得出结论：到达第n个格子的路径数量是这个格子左边的格子的路径数量+上边格子的路径数量。我们定义一个DP数组，DP[i][j]（也就是状态）代表第M[i][j]个格子的路径数量，根据上面的推论，我们可以得出状态转移方程：DP[i][j] = DP[i-1][j]+DP[i][j-1];

然而之后我们会发现，我们还没有对题目中的障碍进行处理。对于障碍的处理其实是非常简单的。遇见障碍，这条路就走不通了，也就是不对这个格子进行计算。那么如何做到不对该格子进行计算呢？有两种解决方法。

第一种：

当障碍数量小的时候，这时候我们就可以把所有障碍的路径记录一下，在动态规划的过程中进行处理，也就是当i = x and j = y的时候跳过循环，时间复杂度为O(mn^2)，记录障碍的空间复杂度为O(m)。

第二种：

当障碍数量大的时候，这时候我们就需要多花费一些空间了。其实我们可以把所有的障碍坐标映射到一个二维数组中，也就是构造一个Map，true表示无障碍，false表示有障碍。在输入障碍的时候将对应下标变成false。判断也就是当Map[i][j] = false的时候跳过循环。时间复杂度为O(n^2)，二维数组的空间复杂度为O(n^2)。

  
所以我们就用第二种方法，代码如下：

```cpp
#include <bits/stdc++.h>//偷个懒 
using namespace std;
#define P 100003//膜数 
bool Map[1001][1001];//我们要构造的二维矩阵 
int DP[1001][1001],n,m;//DP数组，n为长度，m为障碍数 
int Max(int a,int b)
{
    return a>b?a:b;
}
int main(int argc,char ** argv)
{
    int i,j,x,y;
    ios::sync_with_stdio(false);//关闭IO同步，增快cin,cout速度 
    cin >> n >> m;//依次输入 
    for(i = 1;i <= n;i++)
    {
        for(j = 1;j <= n;j++)
            Map[i][j]=true;
    }//个人习惯，把Map变为true 
    for(i = 0;i < m;i++)
    {
        cin >> x >> y;//输入 
        Map[x][y] = false;//把Map[x,y]变为false 
    } 
    for(i = 1;i <= n;i++)
    {
        if(Map[i][1] == false)
            break;
        DP[i][1] = 1;
    }//初始化状态 
    for(i = 1;i <= n;i++)
    {
        if(Map[1][i] == false)
            break;
        DP[1][i] = 1;
    }//初始化状态 
    for(i = 2;i <= n;i++)//从2开始循环 
    {
        for(j = 2;j <= n;j++)
        {
            if(Map[i][j] == false)//判断，如果为障碍，则不对该格子进行处理 
                continue;
            DP[i][j] = (DP[i-1][j]+DP[i][j-1])%P;//注意，这里要每步取模，不然会溢出 
        }
    }
    cout << DP[n][n] << endl;//输出最后的答案 
    
    return 0;
}
```

---

## 作者：NF_水饺 (赞：2)

由于走向只能是下或右，所以是一道典型的递推题

考虑边界就是首行、首列，对障碍点做标记

边界……做过二维递推的dalao们都知道的了：方案数设1，遇到障碍就跳

**（设1是因为走到边界只有1种走法...跳是因为单向走中间被堵了后面的也走不通...）**

然后正式递推：障碍点不能走就不用算了…… 

正常点的话，两边只加正常点路径，无视障碍点（障碍点也走不过来啊...）

因为障碍是单点的缘故，这道题似乎比马拦过河卒还要好做，~~应该是入门难度才对吧~~

附上代码：
```
#include<iostream>
#include<cstdio>
#define mod 100003 //常量咯...跟const定义没啥差别吧...
using namespace std;
int n,m,x,y;
bool f[1000+10][1000+10];//障碍点标记
long long sum[1000+10][1000+10];//方案数标记
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y]=1;//标记
	}
	for(int i=1;i<=n;i++)
	{
		if(!f[1][i]) sum[1][i]=1;
		else break;
	}
	for(int i=1;i<=n;i++)
	{
		if(!f[i][1]) sum[i][1]=1;
		else break;
	}
    //上述两个循环均为边界
	for(int i=2;i<=n;i++)
	{
		for(int j=2;j<=n;j++)
		{
			if(f[i][j]) continue;
			if(!f[i-1][j]) sum[i][j]=((sum[i][j]%mod)+(sum[i-1][j]%mod))%mod;
			if(!f[i][j-1]) sum[i][j]=((sum[i][j]%mod)+(sum[i][j-1]%mod))%mod;
		}
	}//递推
	cout<<sum[n][n]<<endl;
	return 0; 
} 
```

PS.注意取膜（模）！！！
本蒟蒻之前没注意取模10003被卡了60分，重新扫了一遍题才发现取模的问题

千万不要学本蒟蒻犯一个连最蒟蒻的蒟蒻都不会犯的蒟蒻错误！！！

---

## 作者：peter·z (赞：1)

```delphi
var i,j,k,m,n,p,q,x,y,sum:longint;
    map:array[0..1001,0..1001]of longint;｛地图数组｝
    b:array[0..1001,0..1001]of boolean;｛障碍标记数组｝
begin
  read(n,m);
      for i:= 1 to m do
      begin
        read(x,y);
        b[x,y]:=true;
      end;
  b[1,1]:=true;｛已走过｝
  map[1,1]:=1;｛标记起始点｝
  for i:= 1 to n do
    for j:= 1 to n do
    begin
      if (b[i,j]<>true) then｛如果不是障碍｝
      begin
        map[i,j]:=(map[i,j-1]+map[i-1,j])mod 100003;｛上一个+左一个方案数｝
      end;
    end;
    write(map[n,n] mod 100003);｛到达终点的路径数｝
end.
```

本体应用了大众的一贯思路，左+上的方案数，用布尔数组标记障碍会更加直观


---

## 作者：墨凝而止 (赞：1)

```delphi
var
a,b:array[0..10000,0..10000]of longint;{a:递推数组；b:障碍数组｝
c,d,i,j,m,n:longint;
begin
  readln(n,m);
  for i:=1 to m do begin read(c,d);b[c,d]:=1;end;｛记录障碍｝
  a[1,1]:=1;b[1,1]:=1;｛记录过｝
  for i:=1 to n do
  for j:=1 to n do if b[i,j]=0 then a[i,j]:=((a[i-1,j]+a[i,j-1])mod 100003);
  write(a[n,n] mod 100003);｛递推式｝
end.
```
[color=green]此题已试过深搜，只能得20分。思路与过河卒不尽相同。a[i,j]的可能性=a[i-1,j]+a[i,j-1];因为要mod100003，所以注意。关于如何做出递推，也可参考《Free Pascal 语言与基础算法》第158页。

墨凝 执笔[/color]


---

## 作者：午尘 (赞：1)

这也算个dp思想的题了吧qwq……

#### dp的四大关键：状态转移初始答案……


------------

状态：

```
/*a[i][j]表示从(1,1)到(i,j)的路径数
  b[i][j]表示(i,j)是否有障碍 */ 
```



------------

转移：

对于每个点，只能从上方或左方移动而来。

（当然，对于初始化就另当别论啦）

------------

这题的一个坑点就是初始：

```cpp
   for (i=1;i<=n;i++){
   	if (b[i][1]==0) a[i][1]=1;
   	              else break;
   }
    for (i=1;i<=n;i++){
   	if (b[1][i]==0) a[1][i]=1;
   	              else break;
   }
```
要break！一条路走到障碍就断了啊……



------------

答案：a[n][n] 

------------

放代码啦~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf=100003;
int a[1001][1001],b[1001][1001],x,y,n,m,i,j,k,s,ans;
int main(){
	scanf("%d%d",&n,&m);
	for (i=1;i<=m;i++) {
		scanf("%d%d",&x,&y);
		b[x][y]=1;
	}
   for (i=1;i<=n;i++){
   	if (b[i][1]==0) a[i][1]=1;
   	              else break;
   }
    for (i=1;i<=n;i++){
   	if (b[1][i]==0) a[1][i]=1;
   	              else break;
   }
	for (i=2;i<=n;i++)
	 for (j=2;j<=n;j++){
	 	 if (!b[i-1][j]) a[i][j]=(a[i-1][j]+a[i][j])%inf;
	 	 if (!b[i][j-1]) a[i][j]=(a[i][j-1]+a[i][j])%inf;
	 	 if (b[i][j]) a[i][j]=0;
	 }
	 cout<<a[n][n]<<endl;
	 return 0;
}

```



------------

最后安利一下，

中间输出调试在这类题中尤其好用!

```cpp
/*	 for (i=1;i<=n;i++){
	 	for (j=1;j<=n;j++) cout<<a[i][j];
	  cout<<endl;
}*/
```



---

## 作者：FishingStar (赞：0)


------------
此题的类型就是传统的快排，尽管在STL中有(sort),但是，逻辑与算法还是要了解的。对于这道题，最基本的快排只能过两个点，不过其实也没必要非要AC。首先读入，然后调用函数，判断这次是否排完，若没有......嗯，不多说，在程序里写了哈。这个程序的精髓在于i与j,遇到比key大的（且在左边），与另一个比key小的（在右边）交换。


------------


```
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<string>
using namespace std;
int a[100005];
int n;
void qisort(int a[], int left, int right){
	if(left >= right){
	    return;
	}
    int key = a[left];//选定基准数
    int i = left, j = right;
    while(i != j){

		while(a[j] >= key && i < j){
		    j--;
		}
		
        while(a[i] <= key && i < j){
            i++;
		}

		if(i < j){
		    swap(a[i], a[j]);
		}
	}
	swap(a[left], a[i]); 
	qisort(a, left, i - 1);
	qisort(a, i + 1, right);

	return;
}
int main(){
//	freopen("qiucksort.in", "r", stdin);
    cin >> n;
    for(int i = 0; i < n; i++){
        cin >> a[i];
	}
	qisort(a, 0, n - 1);
	for(int i = 0; i < n; i++) cout << a[i] << " ";
	return 0;
}
```

---

## 作者：zrjwwsscm (赞：0)

因为本题只能向下或向右走，所以递推式可以轻松得到a[i][j]=a[i-1][j]+a[i][j-1]

------------

本题特殊之处在于有m处障碍，所以需要一个b数组标记障碍
有了这个思路后，可以~~轻松~~得解。

------------

程序实现如下：
```cpp
#include<iostream>
using namespace std;
int a[1001][1001]={0},b[1001][1001]={0},n,m,x,y;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		b[x][y]=1;
	}
	a[1][1]=1;//起始位置为1
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(b[i][j]==1){
				a[i][j]=0;//障碍置为0
			}else if(i!=1||j!=1){
				a[i][j]=(a[i-1][j]%100003)+(a[i][j-1]%100003))%100003;//孙子同余定理，**不然会炸掉**
			}
		}
	}
	cout<<a[n][n];
	return 0;
}
```


---

## 作者：Will_Rem (赞：0)

# EASY的题目 #
### 我们只需要(wang)找(si)规(li)律(tui)就行了 ###
![路径计数](file:///C:/Users/Administrator/Desktop/%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0.png)
____________________________________
##### 我们可以看到到达一个点的路径数=a[x-1]\[y]+a[x]\[y-1] #####
##### 然后我们只要把到达障碍处的路径归零，就A了。
### ↓↓代码如下↓↓ ###
_____________________________________
```cpp 
#include<iostream>
using namespace std;
long long int a[1001][1001],b[1001][1001],n,m,x,y;
int main()
{
	cin>>n>>m;
	for(long long int i=1;i<=m;i++)
	{
		cin>>x>>y;
		b[x][y]=1;//标记障碍点
    }
	a[1][1]=1;//初始数据
	for(long long int i=1;i<=n;i++)
	{
		for(long long int j=1;j<=n;j++)
		{
			a[i][j]+=a[i-1][j]+a[i][j-1];//最最最最最重要的
			if(b[i][j]==1)//有障碍就不能走
			a[i][j]=0;
			a[i][j]=a[i][j]%100003;//取模
		}
	}
	cout<<a[n][n];
	return 0;
}

---

## 作者：zhaowangji (赞：0)

高仿[过河卒](https://www.luogu.org/problem/P1002)，可以去做一做

方法是一样的，小学数学

规定方向只有两个，且是相邻的方向（上+左之类）

到一个点的方案数，是它旁边两个点的方案数之和

比如

| 1 | 1 |
| :----------: | :----------: |
| 1 | 2 |

注意这个2，由左边的1和右边的1相加得到

而至于题目中的无法到达的点，则应是0

```cpp
#include<iostream>
using namespace std;
int m,n;
int a[1007][1007];//存方案
bool jud[1007][1007];//存是否可以走
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	jud[i][j]=1;//先假设全都可以走
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		jud[x][y]=0;//有些不能走
	}
	a[1][1]=1;//第一个点记得赋初值，切记！！！
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(i==1&&j==1)continue;//不然初值被改掉了，全是0（不要问我怎么知道的）
	else a[i][j]=(a[i-1][j]*jud[i-1][j]+a[i][j-1]*jud[i][j-1])%100003;
    	//借用jud，1是可以到，0是不可以到，很方便
   	//可以边做边余，防止爆炸，最后答案是一样的，可自行查阅资料	     
	cout<<a[n][n]<<endl;/输出
	return 0;
 } 
```


---

## 作者：jxpxcsh (赞：0)

简单的递推，将上一格和左一格的累加就行


```delphi


var a:array[1..1000,1..1000]of boolean;
  f:array[0..1000,0..1000]of longint;
  n,m,i,j,x,y:longint;
begin
  readln(n,m);
  for i:=1 to m do
    begin
      readln(x,y);
      a[x,y]:=true;
    end;
  f[1,1]:=1;
  a[1,1]:=true;{避免重复赋值}
  for i:=1 to n do
    for j:=1 to n do
      if not a[i,j] then f[i,j]:=(f[i-1,j]+f[i,j-1])mod 100003;
  writeln(f[n,n]);
  readln;
end.
                                  

```

---

## 作者：Will_Rem (赞：0)

# EASY的题目 #
### 我们只需要(wang)找(si)规(li)律(tui)就行了 ###
![](https://cdn.luogu.com.cn/upload/image_hosting/bx9v3h9c.png)
____________________________________
##### 我们可以看到到达一个点的路径数=a[x-1]\[y]+a[x]\[y-1] #####
##### 然后我们只要把到达障碍处的路径归零，就A了。
### ↓↓代码如下↓↓ ###
_____________________________________
```cpp 
#include<iostream>
using namespace std;
long long int a[1001][1001],b[1001][1001],n,m,x,y;
int main()
{
	cin>>n>>m;
	for(long long int i=1;i<=m;i++)
	{
		cin>>x>>y;
		b[x][y]=1;//标记障碍点
    }
	a[1][1]=1;//初始数据
	for(long long int i=1;i<=n;i++)
	{
		for(long long int j=1;j<=n;j++)
		{
			a[i][j]+=a[i-1][j]+a[i][j-1];//最最最最最重要的
			if(b[i][j]==1)//有障碍就不能走
			a[i][j]=0;
			a[i][j]=a[i][j]%100003;//取模
		}
	}
	cout<<a[n][n];
	return 0;
}

---


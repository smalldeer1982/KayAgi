# 台阶问题

## 题目描述

有 $N$ 级台阶，你一开始在底部，每次可以向上迈 $1\sim K$ 级台阶，问到达第 $N$ 级台阶有多少种不同方式。

## 说明/提示

- 对于 $20\%$ 的数据，$1\leq N\leq10$，$1\leq K\leq3$；
- 对于 $40\%$ 的数据，$1\leq N\leq1000$；
- 对于 $100\%$ 的数据，$1\leq N\leq100000$，$1\leq K\leq100$。

## 样例 #1

### 输入

```
5 2```

### 输出

```
8```

# 题解

## 作者：SmartBoy (赞：392)

# P1192 【台阶问题】
## 好吧我承认这道题确实是 ~~水~~
但是我还是忍不住成为最详细的题解。

先把题目copy过来
#### 题目描述

有N级的台阶，你一开始在底部，每次可以向上迈最多KK级台阶（最少11级），问到达第NN级台阶有多少种不同方式。

#### 输入格式

两个正整数N，K。

#### 输出格式

一个正整数，为不同方式数，由于答案可能很大，你需要输出ans \bmod 100003ansmod100003后的结果。

#### 输入输出样例

输入
5 2
输出 #1 复制
8
说明/提示
对于20\%20%的数据,有N ≤ 10, K ≤ 3；

对于40\%40%的数据，有N ≤ 1000，N≤1000;

对于100\%100%的数据，有N ≤ 100000,K ≤ 100；


在这里我介绍两种方法，~~其实是因为实在想不出其他方法了~~

首先看到这道题目索性先找找规律，然后没想到...
用这种方法AC以后的我非常的不甘心，于是发现这道题正解是DP（难道不应该想象到DP吗？）
于是就有了这两种方法，接下来我会详细解释两种方法的。
orzorzorz
### 方法一：
这种方法已经是很多dalao用过的方法了，我前面也已经有写到过，就是**找规律**。
很多人会问这道题有什么规律，我写出来你自然就明白了了！
```
k=2 : 1 2 3 5 8 13 21 34...
k=3 : 1 2 4 7 13 24 44 81...
k=4 : 1 2 4 8 15 29 56 108...
k=5 : 1 2 4 8 16 31 61 120...
```
大家如果仔细观察，发现k=2时前两项是1,2；
k=3时前三项是1,2,4；以此类推，发现k=n的话，前n项就是等差数列。其中公差是2；
于是乎顺着这个思路我们不难发现隐藏其中的规律...
```
规律： 
当n<=k时,第N项=(上一项*2)%100003;
当n>k时 ,第N项=(上一项*2-第n-1-k项)%100003;
```
于是写到这里（已经没法在详细了）这道题就变成了一道极水无比的小学数学题（虽然我小学数学很垃圾）

~~为了方便你们复制代码~~，我没有在代码里面加注释。
```
#include<iostream>
#include<cstdio>
using namespace std;
const int mod=100003;
int n,k,a[1000000],ans=0;
int main()
{
	cin>>n>>k;
	a[0]=a[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(i<=k)
		{
			a[i]=(a[i-1]*2)%mod;
		}
		else 
		{
			a[i]=(a[i-1]*2-a[i-k-1])%mod;
		}
	}
	ans=(a[n]+mod)%mod;
    cout<<ans;
    return 0;
}
  //华丽结束
```
所以说以上就是第一种方法。


------------

### 方法二：
正解来了，其实很多~~像我一样的~~大佬首先肯定想到**这就是dp的板子！** 于是按照这个板子，就不难想到第二种思路，由于考虑到你们不喜欢看许多文字，只喜欢**代码** 我给你们~~贴心的~~写出了伪代码！
```
台阶问题：
输入：n、k
dp[i]----表示到达当前台阶得方式总和
dp[0]=1;
dp[1]=1;
for(i:2~n)
{//遍历所有台阶
   for(j:1~k)
	{
		if i-j?0
		dp[i]=(dp[i]+dp[i-j])%100003
	}
}
cout<<dp[n]；
```
以上的伪代码其实写的比较明白，首先要明白dp[i]表示的是到达当前台阶得方式总和，但是其中不要忘记把一二级都初始化成为1。由于结果比较大，一定不要忘记边走边模！

有了以上一点微弱的分析，我们就可以按照伪代码写出~~你们想要的~~真正代码！
```
#include<iostream>
#include<cstdio>
using namespace std;
const int mod=100003;
int n,k,dp[1000000];
int main()
{
	cin>>n>>k;
	dp[0]=dp[1]=1;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			if(i>=j)
			{
				dp[i]=(dp[i]+dp[i-j])%mod;
			}
		}
	}
	cout<<dp[n]%mod;
	return 0;
}
```


------------
相信到这里，看完我详细的解释，你已经有一些思路，如果没看懂，欢迎私信。

不要忘记康康我的博客。


---

## 作者：Starlight237 (赞：228)

这是我发布的第一篇题解，如有不妥之处，请各位dalao见谅。

大家都用的是 _O(nk)_ 算法吧？
这里我发现了一种 _O(n)_ 线性算法。

$a_i=\sum^{i-1}_{j=i-k}a_j=\sum^{i-2}_{j=i-k}a_j+\sum^{i-2}_{j=i-k-1}a_j=2a_{i-1}-a_{i-k-1}$

由此可以把时间复杂度降到 _O(n)_ ！
注意当 _i<=k_ 的时候， $a_i=2a_{i-1}$。以及$a_0=a_1=1$。

由此可以写出如下代码（快速AC）：

（注意一定要模mod、防负数！各dalao们已经说过，但重要的事情说三遍！）

~~o(╥﹏╥)o因为没取模被坑了一遍。。。~~
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k;
const int mod=100003;
int a[1000000];
int main(){
	scanf("%d%d",&n,&k);
	a[0]=a[1]=1;//初始条件
	for(int i=2;i<=n;++i)
		if(i<=k)a[i]=a[i-1]*2%mod;//取模
		else a[i]=a[i-1]*2-a[i-k-1],a[i]%=mod;//取模
	cout<<(a[n]+mod)%mod<<endl;//防止有负数
	return 0;
}
```

---

## 作者：weak_ddb (赞：125)

这道题不同于一般的斐波那契数列，我们需要推导（~~瞎猜~~）一下公式。

原版公式:

$F_i=F_{i-1}+F_{i-2}(i>2)$

$F_i=1(i=1$或$ i=2)$

这种斐波那契数列可以解决一下问题

>有$N$级的台阶，你一开始在底部，每次可以向上迈$2$级，$1$级台阶，问到达第$N$级台阶有多少种不同方式。

这种问题我们的第$i$个台阶，只能从第$i-1$个台阶和第$i-2$个台阶上走来，所以公式为上。

**反过来看这道题目：**

>有$N$级的台阶，你一开始在底部，每次可以向上迈最多$K$级台阶，问到达第$N$级台阶有多少种不同方式。

我们的第$i$个台阶，就可以从第$i-1,i-2$到$i-k$个台阶登陆$(i \geq k)$，这就好办了

$F_i=\displaystyle \sum^{t=min(i,k)}_{t=1}{F_{i-t}}$

程序如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100005],n,k;
int main()
{
	cin>>n>>k;
	f[0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=min(i,k);j++)
			f[i]=(f[i]+f[i-j])%100003;
	}
	cout<<f[n];
	return 0;
} 
```


---

## 作者：Awdrgysxc (赞：51)

看到好多人都写递归，递推，其实可以用矩阵快速幂做

不懂的可以看看
https://blog.csdn.net/g_congratulation/article/details/52734306
https://blog.csdn.net/ffgcc/article/details/78055308
（以上是用矩阵快速幂求斐波那契数）

根据台阶问题的性质，我们可以造一个矩阵
（如果台阶数是4）

$1 [][]1[][] 1[][] 1$

$1[][]0[][]0[][]0$

$0[][]1[][]0[][]0$

$0[][]0[][] 1[][] 0$

ps.[][] 是空格

我们可以把这个矩阵与以下这个矩阵相乘

$f_k$

$f_(k-1)$

$f(k-2)$

$f_(k-3)$

乘一次后你会发现矩阵变成了：

$f_(k+1)$

$f_(k)$

$f_(k-1)$

$f_(K-2)$

我们把第一个矩阵叫做A,第二个叫做B

你会发现$f_n  =(B *A*A*A...(n-k))[1]$

即  (g=n-k)$f_n=B*A^g[1]$

$A^g$ 可以用矩阵快速幂求

求的过程中还要用一个有数字1一样性质的矩阵（$1*a =a$）C，即对角线都是一

### 【代码】
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#define max(x,y)(x>Y?x:y)
#define ll long long

using namespace std;

const int Mod = 1e5 + 3;
const int N = 1011;
ll n,k,tmp[N][N],ans[N],ret[N][N],val[N][N];
ll gk[N],pl;
ll f[N];

inline int read()
{
    register int ret;register char c;register bool flag=0;
    while((c = getchar())<'0'||c>'9')flag^=!(c^'-');ret=c^48;
    while((c=getchar())>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48);
    return flag?-ret:ret;
}//快读

inline void init() {
	//预处理
    for(register int i = 1;i <= k; i++) f[i] = 1;
    for(register int i = 1;i <= k; i++)
        for(register int j = 1;j < i; j++)
            f[i] = (f[i] + f[j]) % Mod;
	//算出B矩阵的数
    for(register int i = 1;i <= k; i++) gk[k-i+1] = f[i];
    //赋值到B矩阵
//	for(register int i = 1;i <= k; i++) printf("%lld",gk[i]);

    for(register int i = 1;i <= k; i++) val[1][i] = 1;
    for(register int i = 2;i <= k; i++) val[i][++pl] = 1;
    //造出A矩阵
    for(register int i = 1;i <= k; i++) ret[i][i] = 1;
    //造出c矩阵
//	for(register int i = 1;i <= k; i++)
//	{
//		for(register int j = 1;j <= k; j++)
//		printf("%lld ",val[i][j]);
//		puts("");
//	}
    n -= k;
    //已算出k个数
    return;
}

inline void allow() {
    memset(tmp,0,sizeof(tmp));
    //清空数组不能漏
    for(register int i = 1;i <= k; i++)
        for(register int j = 1;j <= k; j++)
            for(register int kk = 1;kk <= k; kk++)
            tmp[i][j] = (tmp[i][j] + ret[i][kk] * val[kk][j]) % Mod;
            
            //矩阵乘法
    for(register int i = 1;i <= k; i++)
        for(register int j = 1;j <= k; j++)
        ret[i][j] = tmp[i][j];
    return;
}

inline void gg() {
    memset(tmp,0,sizeof(tmp));
    
    for(register int i = 1;i <= k; i++)
        for(register int j = 1;j <= k; j++)
            for(register int kk = 1;kk <= k; kk++)
            tmp[i][j] = (tmp[i][j] + val[i][kk] * val[kk][j]) % Mod;
           // 平方
    for(register int i = 1;i <= k; i++)
        for(register int j = 1;j <= k; j++)
        val[i][j] = tmp[i][j];
        //保存
    return;
}

inline void output() {
//不能忘了最后还有乘B矩阵
    for(register int i = 1;i <= k; i++)
        for(register int j = 1;j <= k; j++)
            ans[i] = (ans[i] + ret[i][j] * gk[j]) % Mod;
    //输出f[n]
    printf("%lld\n",ans[1]);
    return;
}

inline void quick() {
//矩阵快速幂,与快速幂相似
    while(n)
    {
        if(n & 1) allow();
        n >>= 1;
        gg();
    }
}
//请从主程序开始阅读
int main(void) {
    scanf("%lld%lld",&n,&k);
    if(k > n) k = n;
    init();
    quick();
    output();
    return 0;
}
```

以上是矩阵快速幂的做法最后再附上大家都熟悉的递推做法
```cpp
#include <cstdio>
#include <iostream>
#define min(x,y)(x<y?x:y)
#define max(x,y)(x>y?x:y)
#define ll long long

using namespace std;

const int Mod = 100003;
const int M = 1e7+1;
int k,n,ans,f[M];

inline int read() {
    register ll ret;register bool flag=0;register char c;
    while( (c=getchar() )<'0'||c>'9')flag^=!(c^'-');ret=c^48;
    while( (c=getchar())>='0'&&c<='9') ret=(ret<<3)+(ret<<1)+(c^48);
    return flag?-ret:ret;
}//快读

int main(void)
{
    n = read();k = read();
    
    for(int i = 1;i <= k;i++)f[i]=1;
    
    for(int i = 1;i <= n; i++)
        for(int j = max(1,i - k);j < i; j++)
            f[i] = (f[i] + f[j]) % Mod;
            
    printf("%d",f[n]);
    
    return 0;
}
```

---

## 作者：pacel_dicke (赞：32)

深搜超时，于是想到DP...

虽说是递推，但是从思想上来说我更倾向于动态规划的理解方式，因为我就是这么理解的。

定义状态f[i]:走i步台阶的方案总数；

递推公式：f[i]=sigma( j← 1 to min(i,k)) f[i-j];   j的意义是第一步先迈j个阶梯，j<=k是题意要求，j<=i因为j>i没有意义，所以j<=min(i,k)；

分析状态转移公式，可以发现对于i来说,在不考虑方案对称性的前提下（也就是题目的要求，先迈一步再迈十步与先迈十步再迈一步是两个不同的方案），对于不同的j方案在一开始就不同了，所以在求和计算f[i']时因为每次i不存在重复计算的问题。

目标状态f[n],起点状态是f[1],显然f[1]=1；

初始化f[0]=1则是在后面递推的时候写着方便，f[0]的意义在于，由于我们枚举了j=min(i,k),即可能存在i==j的情况，具体意义为一步迈到终点（条件为i<=k），这一步是合法方案，所以令f[0]=1让计算一般化；

代码很短：

```cpp
#include<iostream>
using namespace std;
int n,k;
int main(){
    cin>>n>>k;
    int f[n+1];
    for(int i=2;i<=n;i++) f[i]=0;
    f[1]=f[0]=1;
    for(int i=2;i<=n;i++){
        for(int j=min(i,k);j>=1;j--){
            f[i]+=f[i-j];
            if(f[i]>=100003) f[i]%=100003;        //注意取模！！！卡了我一次
        }
    }
    cout<<f[n];
    return 0;
}

```

---

## 作者：chenzijun (赞：26)

这其实是变相的斐波那契，观察下列等式：

```cpp
//k=2 : 1 2 3 5 8   13 21 34......
//k=3 : 1 2 4 7 13 24 44 81...
//k=4 : 1 2 4 8 15 29 56 108...
//k=5 : 1 2 4 8 16 31 61 120...
```
我们不难发现当n<=k时第N项=(上一项\*2)%100003,当n>k时第N项=（上一项\*2-第n-1-k项）%100003;
所以递推式就是f(x)=x<=n?f(x-1)\*2:f(x-1)\*2-f(x-1-k);

Ps:f(0)=1;

附上代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
long long n,x[110]={0},ans[100010],k=0;
main()
{
    int i,j;
    cin>>n>>k;
    ans[1]=1;ans[0]=1;
    for(i=2;i<=k;i++)
    ans[i]=(ans[i-1]<<1)%100003;
    for(i=k+1;i<=n;i++)
    ans[i]=(ans[i-1]*2-ans[i-1-k]/*递归式*/+100003/*防止负数产生，我因为他WA了一次*/)%100003;
    cout<<ans[n];
}

```

---

## 作者：Scarlet_Hypoc (赞：21)

好像用深搜做的大牛们都TLE了啊。。

这题用记忆化搜索还是能很轻松的过的，那么我就水一发题解吧。

代码如下：

```
#include <cstdio>
#include <cstring>
#define mod 100003

int n,m;
int f[100010];//记忆dfs(i)的答案
int minn(int x,int y){return x<y?x:y;}
int maxx(int x,int y){return x>y?x:y;}
int dfs(int x)
{
	if(x==0)return 1;//第0级台阶只有一种方法，因为一开始就站在这里
	if(f[x]!=-1)return f[x];//假如之前搜过
	int p=0;
	for(int i=1;i<=maxx(minn(m,x),1);i++)//x的ans可以由x-m~x-1的ans得到，注意判断边界（可能有点多余。。。）
	p=(p+dfs(x-i))%mod;
	f[x]=p;//记录
	return p;
}

int main()
{
	memset(f,-1,sizeof(f));
	f[0]=1;//记得初始化
	scanf("%d %d",&n,&m);
	printf("%d",dfs(n)%mod);
}
```

---

## 作者：ModestCoder_ (赞：18)

O(nk)的dp思路很好想吧

好在此题k<=100

如果k<=10000呢？

O(nk)妥妥的Tle了

但是我们可以优化到O(nlogk)

方法？

可以用树状数组完成

开一个树状数组维护从0到当前i的和

求和用前缀和--->ans==getsum(i)-getsum(i-k-1)

不过，此题用树状数组有两个要点

1、初始化，dp中do[0]==1，树状数组的话不行，因为0 and -0=0，更新时会死循环，所以我们把所有下标+1就行了

2、取模，取模的话有点方了，一开始我80分发现一个点输出负数，为什么？

因为更新和求和是取模了，但其实不可以，如果取模，树状数组可能后面的比前面的小，导致getsum(i)<getsum(i-k-1)

所以不能取模








```cpp
uses math;
var
    c:array[0..1000000] of int64;
    ans:int64;
    n,m,i:longint;
function lowbit(x:int64):int64;
begin
    exit(x and -x);
end;
procedure add(x,y:int64);
begin
    while x<=n+1 do
        begin
            c[x]:=c[x]+y;
            inc(x,lowbit(x));
        end;
end;
function getsum(x:int64):int64;
begin
    getsum:=0;
    while x>0 do
        begin
            getsum:=getsum+c[x];
            dec(x,lowbit(x));
        end;
end;
begin
    readln(n,m);
    add(1,1);
    for i:=2 to n+1 do
        begin
            ans:=(getsum(i)-getsum(max(i-m-1,0))) mod 100003;
            add(i,ans);
        end;
    writeln(ans);
end.

```

---

## 作者：zero_0 (赞：17)

个人偏向于递归，好理解，然后数据较大要开记忆化.....dalao都很厉害我第一次发题解QAQ还请多多包涵


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,jilu[100007];
int dg(int m)
{
    if(jilu[m]) return jilu[m];//记忆化 
    if(m==0) return 1; 
    if(m==1) return 1;
    int ans=0;
    for(int i=1;i<=k;i++)
        if(m-i>=0) ans=(dg(m-i)+ans)%100003;//每一步都要取模 
    jilu[m]=ans;
    return ans;
}
int main()
{
    cin>>n>>k;
    jilu[0]=jilu[1]=1;//递归边界条件 
    cout<<dg(n);
}
```

---

## 作者：limuloo (赞：12)

# 这应该是最快的解法了吧
设a[i]为走到第i阶的方法数

假设最多可以走k步，对任意x(x>=k)容易知道

1.a[x]=a[x-1]+a[x-2]+..+a[x-k]

2.a[x+1]=a[x]+a[x-1]+a[x-2]+…+a[x+1-k]=2*a[x]-a[x-k]

所以我们只需要先求出a[1]~a[k]然后剩下的a[k+1]~a[n]就可以直接通过上面的2式通过一次运算直接算出了
因为当数据比较大的时候k<<n，这时候复杂度近似为O(n)

至于a[1]~a[k]可以用一下方法求出
```cpp

void init(){
    a[0]=1;   //a[0]表示走到第0阶（即起点）的方法数很容易理解为1
    for(register int i=0;i<k;i++)
    //从起点开始，访问每一阶级，假设当前访问的是第i阶，那么a[i+1]~a[i+k]要加上a[i],很容易理解
      for(register int j=1;j<=k;j++) a[i+j]=(a[i+j]+a[i])%100003;
    //可能会改变a[x](x>k)的值，但是没有影响，因为接下来是直接给a[k+1]~a[n]赋值的，所以会覆盖掉
}


//实际上对于a[1]~a[k],a[i](1<=i<=k)为2的(i-1)次方
//至于为什么大家可以根据我上面的init()函数带入几个k写一写很容易就懂了
```

以下是完整代码

```cpp
#include <cstdio>
int n,k,a[100005];
void init(){
    a[0]=a[1]=1;
    for(register int i=2;i<=k;i++)
        a[i]=(2*a[i-1])%100003;
}
int main(){
    scanf("%d %d",&n,&k);
    init();
    for(register int i=k+1;i<=n;i++) a[i]=(2*a[i-1]+100003-a[i-1-k])%100003;
    printf("%d\n",a[n]);
    return 0;
}
```



---

## 作者：countryhope_lzc (赞：8)

###  为了不让自己沉沦，跑来发人生中的第一篇题解。
                                
                                ————献给像我一样的蒟蒻
    这是很久以前学DP时做的了，
    主要是为了理解DP的核心———递推式。
    好，我么来引入情景。
    此时你正站在第n级台阶上，你腿很长，可以一次迈1~k级台阶，也就是说你是从n-1，n-2。。。n-k级台阶上迈上来的。
    此时你想知道到达n级台阶有几种走法（用f[n]表示）。
    递推式就很好想出来了：
    f[n]=f[n-1]+f[n-2]+...+f[n-k]
    我们现在只要知道n前面的台阶的走法就可以求出n了，现在我们来找边界。
    设i<=k,到达第i级台阶肯定最多迈i步（迈多了就超过去了嘛）。
    所以：
    f[0]=1(第0级台阶肯定只有一种走法)，
    f[1]=f[0],
    f[2]=f[1]+f[0]
    ,...,
    f[k]=f[k-1]+...+f[0]。
    有了这些，我们就可以求出目标n了。
    上代码！（异常凌乱）
    

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int k;
int f[100010];
int main(){
	cin>>n>>k;
	int i;
	for(i=1;i<=k;i++){
		f[i]=1;
	}
	for(i=1;i<=n;i++){
		if(i<=k){
			int t=1;
			while(t<i){
				f[i]=(f[i]+f[t])%100003;
				t++;
			}
		}
		if(i>k){
			int t=i-k;
			while(t<i){
				f[i]=(f[i]+f[t])%100003;
				t++;
			}
		}
	}
	cout<<f[n]<<endl;
	return 0;
} 
```



---

## 作者：怎庅硕呢 (赞：5)

    本蒟蒻做此题时偶有一得之愚，便发布了本蒟蒻的第一篇题解。希望能给大家带来些许帮助。
    鄙人才疏学浅，文辞拙劣，若文章有不足之处请您包涵。
          *^ω^*


------------

    刚拿到这道题的时候并没有什么思路，看了看数据范围觉得用暴力搜索可能会超时；

    弱弱的我点开了算法标签，发现了有斐波那契（Fibonacci）的标签；

    于是，便花了一些时间去写了个表格：
    

------------

![P1192 表格](https://cdn.luogu.com.cn/upload/image_hosting/v2n9hfpb.png)

------------

    表格打好了，现在就是观察这个表格和斐波那契的关系了；
    
    显而易见：表格的左下半部分都是2的n次方；
    
    所以我们就将表格分为两部分：
    

------------

- Part 1：[左下半部分]
	对于第K行，前K项为**2的(N-1)次方**；
    
- Part 2：[右上半部分]
	对于第K行，从第K+1项开始，每项都是**前K项的和**（这不就是斐波那契的变式嘛！）；
	

------------

    
    找出来规律之后就好办了，接下来：
    

------------

* 第一步：开一个数组，代表第K行的数列，然后用一个For循环（From 1 To K）将前K项赋值为2的(N-1)次方；

* 第二步：再开一个For循环（From K+1 To N），对每一项进行赋值为前K项的和并**取模**；
    

------------

    好了，到此输出数组的第N项模100003的值，本题便可以结束了。
    
    最后，弱弱地献上本蒟蒻的蒟蒻代码（蒟蒻码风）：
	（对于本题可AC，不保证其他题不会爆。）
    
```cpp
#include<iostream>

using namespace std;
int h[100001],mod=100003;

int main() {
	int N,K,er=1;
	cin>>N>>K;
	for(int i=1; i<=K; i++) {
		h[i]=er;
		er=er*2%mod;
	}
	for(int i=K+1; i<=N; i++) {
		for(int j=i-K; j<i; j++) {
			h[i]+=h[j];
			h[i]%=mod
		}
	}
	cout<<h[N]%mod;
	return 0;
}

```


---

## 作者：千梦羽翼 (赞：5)

## 找规律之后的反思

我们一直说是呀找规律找呀找，的确能找规律，也就是当K==2时，整个数列就是斐波那契数列。那真的除了找规律就没别的招数了吗，有的，且各位老爷听我慢慢道来：

咱就以k==2时来

f[n]={1,1,2,3,5,8}

那为什么第二个台阶走法是1呢？

这是因为走两步时，从第一个台阶中的 _**一步**_ 走过来所以只有一种方案

*以此类推 第三个台阶

可以由第二个台阶中的 _**一步**_ 和 第一个台阶中的 _**一步**_ 走来 总共两步

*所以 第四个台阶

可以由第三个台阶中的_**两步**_（两步中每一步都可以走过来，所以f[4]+=2)加上第二个台阶的_**一步**_(f[4]+=1）所以总共三步

综合上所诉：第n个台阶（k==2）


可以由第n-1个台阶中k步（k步中每一步都可以走过来，所以f[n]+=k)加上第n-2个台阶中的m步(m步中每一步都可以走过来，所以f[n]+=m)

推广：
故f[n]=f[n-1]+f[n-2]+f[n-3]...


---

## 作者：GJC_xj (赞：5)

**一道基础的dp题 适合dp新手理解用**

我定义的状态是 对于 \_第i高能到的最多方案有多少\_

众所周知 如果你想到达 一个高度 你有 k种走法：

>i为当前高
从i-1，i-2，i-3~i-k； 也就是递推式

**有以下需注意点**

- 初始值，也就是你走到0高度只有一种走法

- 如果i-k 的循环中出现小于0的情况可能会RE


```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[1001],ans,n,k;
int main()
{
    scanf("%d%d",&n,&k);
    f[0]=1;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=k;j++)
          if(i-j>=0)
          f[i]+=f[i-j];
        f[i]%=100003;
    }
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：樱式分解 (赞：3)

这道题我的想法有点比较简单，像动规，我的思路是这样的：一个阶梯i,它j步前有v[i-j]种走法，所以就有了v[i]+=v[i-j]这一个式子，通过两层循环（外层是阶数，内层是走法）的不断累加，知道v[n]被求出就是答案。

至于中间mod100003我们可以每算一层就mod一次，不用等到最后mod。

### 代码如下
```
#include <iostream>
using namespace std;
int n,k;
long long v[100010];
int main(){
    cin>>n>>k;
    v[0]=1;
    for(int i=1;i<=n;i++){
    if(i>=k)
    for(int j=1;j<=k;j++){
        v[i]+=v[i-j];
        v[i]%=100003;
            }//阶层大于最大步数时;
    else for(int j=1;j<=i;j++){
        v[i]+=v[i-j];
        v[i]%=100003;
        }//否则受限制，最大步数为i;
    }
    cout<<v[n]<<endl;
    return 0;
}
```
#### 用心写题解，希望给大家带来点帮助呀！


---

## 作者：dqa2022 (赞：3)

本题是一道递推题.

我们用f数组记录跳到每个台阶的方式总数，其中f[0]=1；

要跳到第一级台阶只能从底部直接跳，所以跳到第一级台阶的方式总数f[1]=f[0]=1；要跳到第二级台阶能从底部直接跳或从第一级台阶往上跳，所以跳到第二级台阶的方式总数f[2]=f[0]+f[1]=1+1=2（这里约定k>2）；由此我们可以得出f[i]=f[0]+f[1]+...+f[i-1](i<=k)（把i=k的情况放到后面去亦可）；

要跳到第(k+1)级台阶可以从第1级至第k级出发；要跳到第(k+2)级台阶可以从第2级至第(k+1)级出发；因此我们可以得到跳到第i级台阶可以从第(i-k)级至第(i-1)级出发，f[i]=f[i-k]+f[i-k+1]+...+f[i-1](i>k).

编程实现该递推即可.

代码1（时间复杂度O(min{N,K}\*K)）：

```cpp
#include<cstdio>
const int MAXN=100002,MOD=100003;
int n,k,f[MAXN]={1};
int main()
{
    scanf("%d%d",&n,&k);
    for (int i=1;i<k;i++)//第一种分类
        for (int j=0;j<i;j++)
            f[i]=(f[i]+f[j])%MOD;
    if (n<k)//这里可有可无
    {
        printf("%d\n",f[n]);
        return 0;
    }
    for (int i=k;i<=n;i++)//第二种分类
        for (int j=i-k;j<i;j++)
            f[i]=(f[i]+f[j])%MOD;
    printf("%d\n",f[n]);
    return 0;
}
```
这一段代码我们可以进行优化.
不难发现，对于第一段分类，我们要多次求前缀；对于第二段分类，我们要多次求一段前缀减去更短的一段前缀；第i次求的前缀同第(i-1)次和第(i+1)次求的差别不大，因此我们可以用一个变量tot来记录第(i-1)次的前缀（这里约定1<i<min{N,K}）.

这样，我们就能把程序优化至线性复杂度.

代码2（时间复杂度O(min{N,K})）：

```cpp
#include<cstdio>
const int MAXN=100002,MOD=100003;
int n,k,tot=1,f[MAXN]={1};
int main()
{
    scanf("%d%d",&n,&k);
    for (int i=1;i<=k;i++)//第一种分类，tot记录f[0]+f[1]+...+f[i-1]的值
    {
        f[i]=tot;
        tot=(tot+f[i])%MOD;//加上“可以作为起点的台阶”
    }
    if (n<=k)//这里可有可无
    {
        printf("%d\n",f[n]);
        return 0;
    }
    for (int i=k+1;i<=n;i++)//第二种分类，tot记录f[i-k]+f[i-k+1]+...+f[i-1]的值
    {
        tot=(tot+MOD-f[i-k-1])%MOD;//减去“‘过时’的起点”
        f[i]=tot;
        tot=(tot+f[i])%MOD;//加上“可以作为起点的台阶”
    }
    printf("%d\n",f[n]);
    return 0;
}
```

---

## 作者：cmwqf (赞：3)

/\*
看到那么多人写递推，就来个递归的。具体思想与下列一样，用笔试试就知道，

由a[x-k]一直加到a[x-1],再把已计算过的a[i]直接返回，不用再算一遍浪费时间，

当然，若x-k=0,返回1，在循环中，若x-i<0,就不加上去。相对于下面的大牛，

较为啰嗦，见笑了。

\*/
```cpp
#include<cstdio>
using namespace std;
int n,k,a[100001];
int step(int x)
{
    long long s=0;
    if(x==0) return 1;
    if(a[x]!=-999) return a[x];
    for(int i=x-k;i<=x-1;i++)
        if(i>=0) s+=step(i);
    a[x]=s%100003;
    return a[x];
}
int main()
{
    for(int i=0;i<=100001;i++) a[i]=-999;
    scanf("%d%d",&n,&k);
    if(k==1)
    {
        printf("1");
        return 0;
    } 
    printf("%d",step(n));
    return 0;
}
```

---

## 作者：MR_DENGOU (赞：3)

一道很简单的递推题，一个数组搞定，每次可以从前K个台阶上来，类似斐波纳契数列，C语言程序如下：

```cpp
#include<stdio.h>
int k,n,m,a[100002]={1};//第0阶是一开始就在的，所以定1；
int main(){
scanf("%d%d",&n,&k);//输入
for(int i=1i<=n;i++){//第0已经定完了，所以从第1开始
for(int j=1;j<=k&&(i-j)>=0;j++){//防止到负数，不能运行，测一下防
    a[i]+=a[i-j];//每次加前K个数；
}a[i]%=100003;//题目说的}
printf("%d",a[n]);//输出
return 0;}
```
理解就好
不要抄！不要抄！不要抄！

重要事情说三遍！！！！


---

## 作者：qdezzhengxu (赞：3)

表示挺简单的递推

f[i]表示步数

f[i]=从f[i-k]一直加到f[i-1]；

具体有些边界处理自己看代码吧

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int step[110000]={0};
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;i++)
    {
        step[i]=1;
    }
    for(int i=2;i<=n;i++)
    {
        if(i-k<=0)
        {
            for(int j=1;j<i;j++)
            step[i]+=step[j];
            step[i]%=100003;
        }
        else
        {
            for(int j=1;j<=k;j++)
            {
                step[i]+=step[i-j];
                step[i]%=100003;
            }
        }
    }
    printf("%d",step[n]);
    return 0;
}
```

---

## 作者：Kelin (赞：2)

这道题递推公式是这样的f[i]=∑f[i-j](1<=j<=k) f[0]=f[1]=1

朴素算法o(nk)(这里就不贴代码了)

还有一种记录前缀和的算法

即s[i]=∑f[i]  s[0]=1 s[1]=2

我们发现

if i<=k  f[i]=s[i-1]

if i>k f[i]=s[i]-s[i-k-1]

这样就可以o(n)处理了

```cpp
#include<cstdio>
#define re register int
#define fp(i,a,b) for(re i=a,I=b;i<=I;++i)
const int N=1e5+10,P=1e5+3;
int n,k,f[N]={1,1},s[N]={1,2};
int main(){
    scanf("%d%d",&n,&k);
    fp(i,2,k)f[i]=s[i-1],s[i]=(f[i]+s[i-1])%P;
    fp(i,k+1,n)f[i]=(s[i-1]-s[i-k-1]+P)%P,s[i]=(f[i]+s[i-1])%P;
    printf("%d",f[n]);
return 0;
}//f[i]=∑f[i-j](1<=j<=k) f[0]=f[1]=1
```

其实这道题n可以到1e16的（好多这种题目数据一大就变成【提高+/省选-】了）

因为他是线性递推 所以考虑求出前k项然后 矩阵快速幂 复杂度o(k^3logn)=5.3e7挺好的（在这道题上不如上一种算法 可以当做扩展阅读）

其实直接上就是

[f1 f2 ... fk]乘上了这样一个k\*k矩阵（a[i][k]=1 a[i][i+1]=1）

[0 0 0 .... 0 1]

[1 0 0 .... 0 1]

[0 1 0 .... 0 1]

...
[0 0 0 .... 1 1]

就得到了

[f2 f3 ... fk+1]

所以首先a=a^(n-k)

然后ans=∑f[i]\*a[i][k]

```cpp
#include<cstdio>
#include<cstring>
#define re register int
#define fp(i,a,b) for(re i=a,I=b;i<=I;++i)
const int P=1e5+3,N=110;
typedef long long ll;
int pow,n,ans,f[N]={1,1},s[N]={1,2};
struct matrix{
    int a[N][N];
    matrix(re x=0){memset(a,0,sizeof a);if(x==1)fp(i,0,N-1)a[i][i]=1;}
    inline matrix operator*(const matrix&b)const{
        matrix c;
        fp(k,1,n)fp(i,1,n)if(a[i][k])fp(j,1,n)
            c.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j])%P;
        return c;
    }
    matrix operator^(ll b){
        matrix x(1),A=*this;
        for(;b;b>>=1,A=A*A)if(b&1)x=x*A;
        return x;
    }
}A;
int main(){
    scanf("%d%d",&pow,&n);
    fp(i,2,n)f[i]=s[i-1],s[i]=(f[i]+s[i-1])%P;
    if(pow<=n){printf("%d",f[pow]);return 0;}
    fp(i,1,n)A.a[i][n]=1;fp(i,2,n)A.a[i][i-1]=1;
    A=A^(pow-n);
    fp(i,1,n)ans=(ans+1ll*f[i]*A.a[i][n])%P;
    printf("%d",ans);
return 0;
}
```

---

## 作者：Ufowoqqqo (赞：2)

经典递推问题，由最多可以跨2级（即著名的**[color=red]Fibonacci数列[/color]**）衍生而来。

递推公式：第i个台阶的可能性是它前k个台阶的可能性之和。

注意：**[color=red](a+b) mod c=(a mod c+ b mod c) mod c[/color]**，所以千万不能等到输出时再取模，否则只有20分。

```delphi

var
  n,k,i,j:longint;
  a:array [1..100000] of longint;
begin
  read(n,k);
  for i:=1 to k do
    a[i]:=1;
  for i:=1 to n do
    for j:=i-k to i-1 do
      if j>0 then
        a[i]:=(a[i]+a[j]) mod 100003;
 write(a[n]);
end.

```

---

## 作者：ErkkiErkko (赞：2)

这道题可以使用递推+循环解决。

递推公式为str[i]=str[i-1]+str[i-2]+str[i-3]+......+str[i-k]，特殊情况特殊对待。

（题外话：记得以前好像做过一道类似的题，给定k=2，答案是斐波那契数列）

此外还要不断取模来保证数据不会超过整形的范围。

代码如下------

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,str[100005];//str表示到达每一级台阶的方案数 
int main()
{
    cin>>n>>k;
    str[0]=1;
    for(int i=1;i<=n;i++)//这里递推+循环 
    {
        for(int j=1;j<=k&&j<=i;j++)
        {
            str[i]+=str[i-j]%100003;//为了让str不超过整形的范围，要及时mod 100003，下同 
        }
        str[i]%=100003;  
    }
    cout<<str[n]%100003<<endl;//输出这里也要取模 
}
```

---

## 作者：Automaton18 (赞：2)

简单来说无非就是个递推+类似于斐波那契数列的东西。不要想到dp啊！

//台阶问题公式：走到第n阶的方法总数等于走到前n-k阶到第n-1阶的方法总数之和。

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[1000001]={1},i,j,n,k;
    cin>>n>>k;
    for(i=1;i<=n;i++)
    for(j=1;j<=k&&(i-j)>=0;j++)//这里注意要判断一下i-j>=0，否则。。。。。。你们懂的。
    {
        a[i]=（a[i]+a[i-j]）%100003;//每次mod一下，不然要炸。别告诉我你们连mod都不会。
    }
    cout<<a[n]<<endl;
    return 0;
}//结束撒花233
```

---

## 作者：用户已注销 (赞：1)

比较容易的AC方法：

对于每个台阶，累加之前K个台阶的答案并模

最后输出答案，时间复杂度O(N\*K)=10^8

因为常数比较小所以可以过。

----------------------------分割线----------------------------

上面的算法是大家都很容易想到的，

以下介绍一种更优的方法，

时间复杂度可以降到O(N)，也就是说N=5000000的时候也是可以过的

算法思想：

总体的思路还是更普通的方法一样，

其实只是维护了一个数组的前缀和，

使计算之前k个阶梯的时候，复杂度降为O（1），总共是O（N）

统计前缀和是算一个记一个，所以复杂度是O（N）

循环计算N个解题，复杂度也是O（N）

显然，O(N)+O(N)+O(N)=O(N)，常数也小的很

亲测了一下， 耗时3ms/5个点

稍微翻了一下评测记录，不知道为什么好像很少人想到这样的方法

满贴一下代码：

----------------------------分割线----------------------------

```cpp
#include<cstdio>
#define mod 100003
using namespace std;
int k,n;
int num[100005];
int sum[100005];//维护Num的前缀和 
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
int main()
{
    scanf("%d%d",&n,&k);
    k=min(n,k);//一点点优化，k>n时没有用
    num[0]=sum[0]=0;
    num[1]=sum[1]=1;
    for(register int i=2;i<=n;i++)
    {
        num[i]=(sum[i-1]-sum[max(i-k-1,0)]+(int)(i<=k)+mod)%mod;//这一句的“+mod”很重要，因为这里的前缀和不是递增的
        sum[i]=(sum[i-1]+num[i])%mod;//维护前缀和
    }
    return !printf("%d\n",num[n]);
}
```

---

## 作者：__stdcall (赞：1)

这题关系式很明显，几乎是斐波那契

f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f( max(0,n-k) )

max保证了递推式对于前k项也成立，因为f不能作用一个负数

但是直接这么递推复杂度为O(nk)，只能得到40分，后面的全部tle掉

于是需要用前缀和的思想进行优化，即pf(n) = f(n) + f(n-1) + f(n-2) + ... + f(0)

然后就有f(n) = pf(n-1) - pf( max(0,n-k) - 1 )，定义pf(-1) = 0

但是要注意每次计算完pf和f都要膜一下

但是膜完之后可能两个pf相减是个负数，这时就要加上100003

不懂dalao们是如何裸的递推还不tle的。。。反正裸的递推我是tle了。

当然也可以用矩阵加速递推，由于太麻烦，这里就不在讨论，可以参考题目：【模板】矩阵快速幂






```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
typedef long long ll;
const int p = 100003;
ll rst[100010];
ll pf[100010];
int n,k;
ll getpf( int l , int r )
{
    if( l == 0 ) return pf[r];
    else
    {
        ll ret = pf[r] - pf[l-1];
        if( ret < 0 ) ret += p;
        return ret;
    }
}
int main()
{
    cin >> n >> k;
    rst[0] = pf[0] = 1;
    for( int i = 1 ; i <= n ; ++i )
    {
        int j = max(0,i-k);
        rst[i] = getpf(j,i-1);
        pf[i] = pf[i-1] + rst[i];
        pf[i] %= p;
    }
    cout << rst[n] << endl;
    return 0;
}

```

---

## 作者：李宁远 (赞：1)

台阶问题的升级版，每次能上的台阶数不再已知。数据可能有问题，数组开[-100..100000]过不去。

```delphi
var n,k,i,j:longint;
a:array[-100..100000] of longint;
begin
  readln(n,k);
  fillchar(a,sizeof(a),0);
  a[0]:=1;
  for i:=1 to n do
    for j:=i-k to i-1 do
      inc(a[i],a[j]);
  write(a[n]);
end.
```

---

## 作者：oreimo_eromanga (赞：1)

```cpp

//1次2级：1、2、3、5、8。
//1次3级：1、2、4、7、13。
//前k个数相加的变种斐波那契数列。
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<string>
#include<cstdio>
#include<cmath>
using namespace std;
long long a[100001]={0,1};
int main()
{
    long long n,k;
    cin>>n>>k;
    for(int i=2;i<=n+1;i++)
       for(int j=1;j<=k;j++)
       {
          if(i-j>=0){a[i]=(a[i]+a[i-j])%100003;}
       }
    cout<<a[n+1]<<endl;
    system("pause");
    return 0;
}


```

---

## 作者：2015C林铮翔 (赞：1)

首先，设f[i]为走到i的走法数量。

因为这中间的每一级都可以一次跨到i这个台阶

所以到i的方案一定是由(i-k)~(i-1)这之中的所有方案构成(i-k>0)


附上代码

```cpp

#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
long long n,k,i,j,a[10000001]; 
int main()
{
    cin>>n>>k;  
    for(i=1;i<=k;i++) a[i]=1;
    for(i=1;i<=n;i++)
        for(j=i-k;j<=i-1;j++)
        {
            if(j>0)
            a[i]=(a[i]+a[j])%100003;
        }
    cout<<a[n]<<endl;
    system("pause");
    return 0;
}

```

---

## 作者：wjzcom (赞：1)

一道递推的题，建立数组f,f[i]表示迈到i有多少种情况，从头往下扫，对于每一级的f值等于它前面k个的f值之和，初始值：前k个的值一开始就是1，因为可以直接从底部跳到它

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN = 100000 + 10;
int f[MAXN];
int n, k;
int main()
{
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        for(int j = i-1; j >= i-k && j >= 0; j--)
            f[i] += f[j];
        if(i <= k) f[i]++;
        f[i] %=  100003;
    }
    cout << f[n];
    return 0;
}
```

---

## 作者：郭惟一 (赞：0)

# 思路
##### 此题就是递推
假设要到第3个台阶，最大可以走三阶，最小可以走一阶（最小永远是一阶）。
我们一共有四种方法：
### 1.0-1-2-3;
### 2.0-1-3;
### 3.0-2-3;
### 4.0-3.
#### 第一步到的就是123其中之一：
#### 如果到1，再到3方法和第三种的方法一样(2种)之后再加一步到2
#### 再到3和0-1的方法一样（1种）
#### 直接到3，和0-0一样（1种）
综上所述就可以得到
## f[i]+=f[i-j]
## f[n]就是我们要的最终结果！
# 代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[100005];
int main()
{
    cin>>n>>k;
    f[0]=1;//首项为0
    for(int i=1;i<=n;i++) 
    {
        for(int j=1;j<=k;j++) 
        {
            if(i>=j)
            {
                f[i]+=f[i-j];
                f[i]=f[i]%100003;//千万注意这个地方
            }
        }
    }
    cout<<f[n];
    return 0;
}
```


---

## 作者：gxjj (赞：0)

#### 本弱鸡经过自闭、自我怀疑、心态爆炸等状态以及在看了大佬题解还依旧认为自己是正确的解题思路情况下，发现由于边界问题导致的题一直通不过后，决定写该题的题解。

##### 第二次写题解，写的不好还望各位大佬见谅。

看了题解很多都是用了一些我看不懂的方法/规律去解题，我觉得我的思路还是蛮容易懂得。但是写这道题之前要弄清楚斐波那契数列。

这道题不在是当k=2的情况下，而是k在一定范围内变化，既然当k=2
a[0]=1,a[1]=1,a[2]=2,,,,第i项等于前两项之和。

我们来研究一下当k=3的情况：a[0]=1,a[1]=2,a[3]=3,,,发现第i项等于前3项之和，而a[2]=a[1]+a[0]+1.末尾加上的这个1是由于可以一步跨上3阶台阶。

（由于第i项=前3项之和，所以我们要保证前3项都得存在，所以有了递推的边界）

有了以上的规律发现之后就可以有一个大概的思路：

1、求出a[0]~a[k]

2、用递推式：第i项=前k项之和。

（注意边界、负数）

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn=1e5+100;
long long a[maxn];
int mod=100003;

int main()
{
    int n,k,i,j;
    cin>>n>>k;
    a[0]=1;
    for(i=1; i<=k; i++)
    {
        for(j=1; j<=k; j++)
        {
            if(i>j)
            {
                a[i]=(a[i]+a[i-j])%mod;
            }
        }
        a[i]+=1;
    }
    for(i=k+1; i<=n; i++)
    {
        for(j=1; j<=k; j++)
        {
            a[i]=(a[i]+a[i-j])%mod;
        }
    }
    cout<<(a[n]+mod)%mod;
    return 0;
}

```


---

## 作者：Istria (赞：0)

关于这个要用递推就不解释了，否则必定TLE

（C语言）

最好的办法就是用一个数组来存数

那么关于这个存数也有几点需要注意：

代码改了又改我们可以发现：

当i从1递增到K时，对应的数就是2的几次方！

当i=K+1时，是2^(K+1)-1，因为此时不能一次走上K+1个台阶

当i从K+2递增到N时，s[N]即s[N-K]到s[N-1]的和，那么如果K大于N也没关系，这个时候循环条件根本不满足嘛~
而这时为了减少运算量，其实s[i]就是s[i-1]加上一个s[i-1]减去一个s[i-1-K]得到的，一次循环搞定！

最后说到整数溢出的问题：建议算一个，求一次余数，最后的最后加一步判断，s[N]可能<0,这时候加上100003就好了~

第一篇题解，恳请通过！
希望对大家有所帮助，如有不妥之处，欢迎大家指正！
最后上代码：
```c
//找规律
//注意几点：K之前是等比，之后s[i]是s[i-K]加到s[i-1]的和，但处理要注意
//最大的问题是处理溢出的问题 
#include <stdio.h>
#include <math.h>
long N,K,s[100005]={0};//递推数组 
int main()
{
	int i;
	scanf("%ld%ld",&N,&K);
	s[1]=1;
	for(i=2;i<=K;i++) 
	{
		s[i]=2*s[i-1];
		s[i]%=100003;
	}
	for(i=1;i<=K;i++)
	{
		s[K+1]+=s[i];
		s[K+1]%=100003;
	}
	for(i=K+2;i<=N;i++)
	{
		s[i]=2*s[i-1]-s[i-1-K];//这一步有可能减出一个负数
		s[i]%=100003;
	}
	while(s[N]<0) s[N]+=100003;
	printf("%ld\n",s[N]);
	
	return 0;
}
```



---

## 作者：cys2004a (赞：0)

# 这道题数据有点坑

## 我把结果+100003的和再模100003输出的。

## 首先看1-k的种数：当有一阶台阶时，fb[i]=1，两级台阶时， fb[i]=2，三级台阶时，fb[i]=4……

## 也就是fb[1-k]=2^0-k-1.所以我们先算出来它。

## 大家注意，有两位同学使用2重循环解题，代码量虽少，但时间复杂度很高。于是课上讲做最大子段和DP发的前缀和思想，将sum数组先在第一个循环中当作前缀和数组，第二个循环中则当队列来进行操作——虽然我没学队列。


```cpp
### #include<iostream>
### using namespace std;
### int main()
### {
###     int n,k;
###     cin>>n>>k;
###     long long fb[n+2];
###     long long sum[100000+1]={0};
###     fb[1]=1;
###     sum[1]=1;
###     fb[2]=2;
###     sum[2]=3;
###     for(int i=3;i<=min(n,k);i++)
###     {
###         fb[i]=((fb[i-1]%100003)*2)%100003;
###         sum[i]=(sum[i-1]%100003+fb[i]%100003)%100003;
###     }
###     int l=1;
###     fb[k+1]=sum[k]%100003;
###     for(int i=k+1;i<=n;i++)
###     {
###         fb[i]=sum[i-1]%100003;
###         sum[i]=(sum[i-1]%100003-fb[l]%100003+fb[i]%100003)%100003;
###         l++;
###     }
###     cout<<(fb[n]+100003)%100003;
###     return 0;
### }
```

---

## 作者：秀才加点冰 (赞：0)

这份题解的思路应该是很常规的，这也是一道经典的题，先前有很多神牛在尽可能的压缩时间，我提一种压缩空间的方法。

由于n达到了10^6，而k至多仅有100，且答案对100003取模，因此数组可以选用int型，理论上空间是足够的，但此题确实可以作为循环数组的练习。先上代码。






```cpp
#include<iostream> //声明头文件
using namespace std;
int main()
{
    int n,k,a[101],t;  //定义变量，根据题目给出的数据范围，用int即可。
                            //题目的动态转移方程为ans[n]=求和(n-k<=i<=n-1)a[i] 
                            //因此只需维护ans[n-k]-a[n-1]这k个值的和即可
                           //故仅储存之。
    cin>>n>>k;   //输入
    for(int i=1;i<=100;i++)
    a[i]=0;           //赋初值为0
    a[0]=1;          //原地不动仅有一种可能
    for(int i=2;i<=n;i++)
    {
       t=0;                           //待求和值
       for(int j=0;j<=k-1;j++)        
       t+=a[j];                      //进行求和
       a[i%k]=t%100003;     //改变数组中的相应项
    //   cout<<t<<" ";
    }
    cout<<t%100003;     //输出答案
    return 0;
}
程序还有一定的优化空间，即其实并不需要维护数组a[]，仅维护其Sum即可。
```

---

## 作者：shenyi1343395317 (赞：0)

台阶问题，其实是斐波那契数列的变形啦。建议各位OIer们代码之前试试手工算一下。我们就会发现奇妙的规律

k=多少，就向前面加多少

```cpp
program Angel Beats！;
  var n,k,i,j,ans:longint;
      a:array[-199..100020] of longint;    //数组还是开大一点的好，因为涉及到i-k会是负数所以要开负数下标
  begin
  read(n,k);
  if k=1 then begin writeln(1); exit; end; //这是我闲的无聊处理特殊数据的代码，大神勿喷。。
  for i:=-199 to -1 do a[i]:=0;               //初始化
  a[0]:=1;            //大家一定要记得a【0】是1 就像斐波那契数列开始一样1,1,2,3.....
  a[1]:=1;
  a[2]:=2;
  for i:=3 to n do      //接下来就是两个循环计算答案了
   begin
   for j:=1 to k do a[i]:=a[i]+a[i-j];   //还好k<=100这里我们先加上，就不用mod了
   a[i]:=a[i] mod 100003;               //直到完成一个n级台阶后我们再mod。   ps.这样效率要高。
   end;
  ans:=a[n] mod 100003;            //保险起见，最后还是mod了一下
  writeln(ans);
end.
```

---

## 作者：高泽棵 (赞：0)

Pascal代码，我来发个题解，好像题目里的k的范围错误，最后，我用了前缀和。

以下是程序

------------------------------------------------------------------------------------------------------------------------------------------

华丽的分割线

------------------------------------------------------------------------------------------------------------------------------------------

```cpp
var n,m,i,j:longint;
a,b:array[0..100000] of longint;//a存的是第i个方案总数，b存的是前i-1个方案总数之和。
begin
  readln(n,m);
  for i:=1 to m do  //m之内特殊处理
  begin
    for j:=1 to i-1 do
      a[i]:=(a[i]+a[j]) mod 100003;
    a[i]:=(a[i]+1) mod 100003;
    b[i]:=(b[i-1]+a[i]) mod 100003;
  end;
  for i:=m+1 to n do  //m后a[i]是前m个方案总数和
  begin
    a[i]:=(b[i-1]-b[i-m-1]+100003) mod 100003;
    b[i]:=(b[i-1]+a[i]) mod 100003;
  end;
  writeln(a[n]);
end.
```

---

## 作者：Enzymii (赞：0)

这个台阶问题啊……感觉很像斐波那契数列是不是~~然后感觉很水的拍出来...结果上来就忘记了去模100003...

然后居然还出现了负数！！

这个问题我冥(xian)思(de)苦(dan)想(teng)，为什么呢，后来发现——

###是C++的锅！数组没有负数是不是..所以草率的i-j是会爆炸的~~

我就只会加特判了。上代码吧：

‘’‘

```cpp
#include<cstdio>
int f[100001];  //f数组表示到第i个台阶的方案数
int main()
{
        int n,k,a,b,c;scanf("%d%d",&n,&k);
        for(int i=1;i<=k;i++) f[i]=1; //很玄(dan)学(teng)的初始化设定啊
        for(int i=2;i<=n;i++) //每级台阶的方案数要递推
                for(int j=1;j<=k&&j<=i;j++) //这里就是防止减炸的措施 看到&&后面的了没？
//fi加上假设最后一步迈j个台阶到达第i级时的方案数（这就是递推了）
                         f[i]=(f[i]+f[i-j])%100003; 
        printf("%d",f[n]);
}
```

---

## 作者：DreamDraw (赞：0)

```cpp
//比较简单的递推
//（虽然名字叫dp）关系式：dp[i]=sum{dp[j]+1|i-k<=j<i};
#include<iostream>
using namespace std;
int main(){
    int n,k;cin>>n>>k;
    int dp[100005]={1};
    for(int i=1;i<=n;i++){
        int t=0;
        for(int j=(i<k?0:(i-k));j<i;j++){//注意：如果前面台阶不足K,则从0开始递推
            t+=dp[j];
        }
        t%=100003;
        dp[i]=t;
    }
    cout<<dp[n];
        return 0;
}
```

---

## 作者：vegetabird (赞：0)

设f(x)为走上x级台阶的总方法数

递推式很简单：f(x)=∑ f(x-k~x-1)

特殊的，在x<=k时，f(x)=(∑ f(1~x-1))+1

我看到许多人发的题解中数组开的都是n的规模，但其实只要开到k的100就够了

每计算一次f(x)后（此时f(x)尚未存入数组），就将数组中的每一个数向前移一位，然后在数组末尾存入f(x)

代码如下：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int f[110];                                                                  有兴趣的童鞋也可以用队列实现
int main(){
    int n,k,i,j,t;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++){
        t=0;                                                           t临时存放f(x)的值
        for(j=1;j<=k;j++){
            t+=f[j];
            f[j]=f[j+1];
        }
        f[k]=t;
        if(i<=k){                                                     特判
            f[k]++;
        }
        f[k]%=100003;
    }
    printf("%d\n",f[k]);
    return 0;
}
```

---

## 作者：萌萌的林 (赞：0)

....好像理解的不太好呢。。关系式完全手推差评!不是动归


```cpp
#include<stdio.h>
#include<iostream>
long long f[200000];
int n,k;
const long long inf=9223372036854775807ll;
int w(int a)
{
    long long ans;
    ans=0;
    if(a==0) return 1;
    if (f[a]!=-inf) return f[a];//代表访问过
    for(int i=1;i<=k;i++)
    {
        if (a-i>=0)
         ans=ans+w(a-i);//能够推出每一个w都是前面的k个w的和
    }
    f[a]=ans%100003;
    return ans%100003;
}
int main()
{
    for (long long i=0;i<200000;i++) f[i]=-inf;
    scanf("%d%d",&n,&k);
    printf("%d",w(n));
    return 0;
}

```

---

## 作者：ROOToj (赞：0)

斐波那契数列的变式：前k个数相加。注意：如果前面不足k个数，则为前面所有数相加+1！


附上AC源代码：


​#include<cstdio>


















```cpp
#include<cstring>
using namespace std;
#define MAXN 1000010
int n,m,a[MAXN],i,j;
int main()
{
    scanf("%d%d",&n,&m);
    memset(a,0,sizeof(a));
    a[1]=1;
    for(i=2;i<=n;i++)
        for(j=1;j<=m;j++)
            if(i<=j){a[i]++;break;}
            else a[i]=(a[i-j]% 100003+a[i]% 100003)% 100003;
    printf("%d\n",a[n]);
    return 0;
}
```
​

​​-------------------------------------------END-------------------------------------------


---


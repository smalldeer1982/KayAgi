# 【模板】快速幂

## 题目描述

给你三个整数 $a,b,p$，求 $a^b \bmod p$。

## 说明/提示

**样例解释**

$2^{10} = 1024$，$1024 \bmod 9 = 7$。

**数据规模与约定**

对于 $100\%$ 的数据，保证 $0\le a,b < 2^{31}$，$a+b>0$，$2 \leq p \lt 2^{31}$。

## 样例 #1

### 输入

```
2 10 9
```

### 输出

```
2^10 mod 9=7
```

# 题解

## 作者：学委 (赞：1746)

*2018-8-28 更新*

听说有这么一种算法能够

## 让计算机很快地求出$a^b$

暴力相乘的话，电脑要计算 $b$ 次。用快速幂，计算次数在 $log_2(b)$ 级别，很实用。

## 原理 I

(1)如果将 $a$ 自乘一次，就会变成 $a^2$ 。再把 $a^2$ 自乘一次就会变成 $a^4$ 。然后是 $a^8$…… 自乘 $n$ 次的结果是 $a^{2^{n}}$ 。对吧……

(2)$a^xa^y = a^{x+y}$，这个容易。

(3)将 $b$ 转化为二进制观看一下：

比如 $b = (11)_{10}$ 就是 $(1011)_{2}$ 。从左到右，这些 $1$ 分别代表十进制的 $8,2,1$。可以说 $a^{11} = a^8 × a^2 × a^1$。

为什么要这样表示？因为在快速幂的过程中，我们会把 $a$ 自乘为 $a^2$，然后 $a^2$ 自乘为 $a^4$……像上面第一条说的。

___
___

**过程会是这样：**

（好长，可以不看，如果要阅读下面的模拟过程的话，要慢慢地看噢）

·假设我们拿到了 $a$，并且 $b = 11$。想求 $a^{11}$，但是又不想乘11次，有点慢。

·以电脑视角稍稍观察一下 $b = 11$，二进制下是 $b = 1011$。

·制作一个 $base$。现在 $base = a$，表示的是，$a^1 = a$。待会 $base$ 会变的。

·制作一个 $ans$，初值 $1$，准备用来做答案。

___


```cpp
while(b > 0)
{
```

·循环一。看，$b$（二进制）的最后一位是 $1$ 吗？
是的。这代表 $a^{11} = a^8 × a^2 × a^1$ 中的“ $× a^1$ ”存在。所以 $ ans *= base $。

```cpp
if(b & 1)
	ans *= base;

/*关于 b & 1：
“&”美名曰“按位与”。
x & y 是二进制 x 和 y 的每一位分别进行“与运算”的结果。
与运算，即两者都为 1 时才会返回 1，否则返回 0。
那么 b & 1

          二进制
b     =    1011
1     =    0001
b&1   =    0001

因为 1（二进制）的前面几位全部都是 0，
所以只有 b 二进制最后一位是 1 时，b & 1 才会返回 1。
挺巧妙的，并且很快。)*/
```

·然后 $base$ 努力上升，他通过自乘一次，使自己变成 $a^2$。

```cpp
base *= base;
```

同时 

```cpp
b >>= 1;
```

它把（二进制的）自己每一位都往右移动了。原来的最后第二位，变成了最后第一位！$b = (101)_2$。

```cpp
}
```
___

·循环二，再看看 $b$，最后一位还是 $1$。这说明有“ $× a^2$ ”，$ans *= base$。


·$base$ 继续努力，通过 $base *= base$ 让自己变成了 $a^4$。然后 $b$ 也右移
一位。$b = 10$。

___

·循环三，可是 $b$ 的最后一位不再是 $1$ 了，说明不存在“ $× a^4$ ”。$base$ 自我升华，达到了 $a^8$。且 $b >>= 1$。这一步中，答案没有增加，可是毕竟 $b > 0$，还有希望。

___

·循环四，$b$ 的最后一位是 $1$，这说明“ $×a^8$ ”的存在。$ ans *= base $。由于 $b$ 再右移一位就是 $0$ 了，循环结束。
___
___

总的来说，如果 $b$ 在二进制上的某一位是 $1$，我们就把答案乘上对应的 $a^{2^{n}}$。不懂的话，请结合代码理解~

## 实现

```cpp
int quickPower(int a, int b)//是求a的b次方
{
	int ans = 1, base = a;//ans为答案，base为a^(2^n)
	while(b > 0)//b是一个变化的二进制数，如果还没有用完
    {
		if(b & 1)//&是位运算，b&1表示b在二进制下最后一位是不是1，如果是：
			ans *= base;//把ans乘上对应的a^(2^n)
		
        base *= base;//base自乘，由a^(2^n)变成a^(2^(n+1))
		b >>= 1;//位运算，b右移一位，如101变成10（把最右边的1移掉了），10010变成1001。现在b在二进制下最后一位是刚刚的倒数第二位。结合上面b & 1食用更佳
	}
	return ans;
}
```

## 原理 II

没错快速幂有很多种理解方式。

这是2017年NOIP普及组的完善程序第1题，这里提示的思路和上面不一样。

![](https://cdn.luogu.com.cn/upload/pic/30947.png)

从头开始。若当前 $p$ 为偶数，咱们不着急，只需把 $x$ 自乘，然后 $ p /= 2$ （即考虑下一层，下几层会帮我们乘上 $(x^2)^{p/2}$的）。

若当前 $p$ 为奇数，说明 $x^p = x*(x^2)^{(p-1)/2}$ 中前面那个 $x$ 的存在，$ans *= x$。然后继续考虑下一层（下几层会帮我们乘上 $(x^2)^{(p-1)/2}$的）。注意，这里的 $x$ 不是指题目开始给出的 $x$，而是当前层的 $x$ 应有的值，这跟上面的 $base$ 是一样的。

___
____

**也是稍稍模拟一下比较好理解。**

·假设我们拿到了 $x = 3$，并且 $p = 11$。想求 $3^{11}$。

·第一层循环。$b = 11$，一个奇数。将 $3^{11}$ 分解为 $3^1 * (3^2)^5$ 来看。本层只需把 $ans *= 3^1$。那后面的呢？我们到下一层再搞定。下几层的总目标是让 $ans *= (3^2)^5$，也就是让 $ans *= 9^5$。**来到下一层的方法是 $x = 3*3 = 9$ 且 $b  = 11 / 2 = 5$。**

·第二层循环几乎独立于第一层存在。$b = 5$，一个奇数。将 $9^{5}$ 分解为 $9^1 * (9^2)^2$ 来看。本层只需把 $ans *= 9^1$。那后面的呢？我们到下一层再搞定。下几层的总目标是让 $ans *= (9^2)^2$，也就是让 $ans *= 81^2$。于是 $x = 9*9 = 81$ 且 $b  = 5 / 2 = 2$。

·第三层循环，$b = 2$，不是奇数，不着急，只把 $81^2$ 当作 $(81^2)^1$。下几层的总目标是让 $ans *= (81^2)^1$。于是 $x = 81 * 81 = 6561$，$b = 2 / 2 = 1$。

·第四层循环，$b = 1$，是奇数。这时候已经不用看成什么分解了，$ans *= 6561$ 就可完成总目标。$b / 2$ 为 $0$。结束循环。

___
___

代码和上面一样。因为 $b \& 1$ 与 $b \mod 2 == 1$ 等效。$b /= 2$ 与 $b >>= 1$ 等效。

![](https://cdn.luogu.com.cn/upload/pic/30953.png)

## 取余运算

快速幂经常要结合取余运算。这里也讲一点。

取余运算有一些好用的性质，包括：

$(A+B) \mod b = (A \mod b + B \mod b) \mod b$

$(A×B) \mod b = ((A \mod b) × (B \mod b)) \mod b$

证明都很简单，如果要说服自己的话拿起笔试试吧。可设 $A = k_A × b + R_A$……

于是快速幂过程中可以

```cpp

	while(b > 0)
    {
		if(b & 1)
        {
			ans *= base;
            ans %= m;
    	}
		
        base *= base;
        base %= m;
		b >>= 1;
	}

```

能保证这样下来最后的结果与“先乘到最后，再取余”的结果一样。

---

## 作者：龙啸空 (赞：169)

这篇题解我本来是不打算写的，但是为了各位和我自己，于是就写了这篇题解。

有兴趣的同学们可以去看我P1313的题解：[P1313 计算系数](https://www.luogu.org/blog/longxiaokong-de-blog/solution-p1313)

顺便......

求管理员大大通过！！！

（不正经结束）

感谢` Kingod——Andy `发现文中一处错误

---------

									分  割  线

---------

# 基本铺垫

## 指数运算法制

这一部分必须铺垫，否则后面会听不懂

设一个数a自乘b次叫做$a^b$

那么：

$a^b*a^c=a^{b+c}$

解释：b个a和c个a乘在一起，就是b+c个a乘在一起

第一部分铺垫完成！

## 位运算

位运算指的是对于一个数的二进制进行的操作，下面简单介绍一下几个简单运算符。

### 左移/右移（<<和>>)

比如说设一个数p为23，它的二进制是10111。

">>"就是右移符号，它是将整个数的二进制表示向右移n位，空位自动补零。

比如p>>1就是p的二进制表示向右移一位。

从10111变成01011。

"<<"就是左移符号，它是将整个数的二进制表示向左移n位，空位自动补零。

比如p<<1就是p的二进制表示向左移一位。

从10111变成101110

### 逻辑运算

#### 按位或（|）

就是将两个二进制数每一位进行或的逻辑操作，这里简单写一下：

1或1=1
0或1=1
1或0=1
0或0=0

比如说a=10,b=23,a|b的竖式如下：

10111
  
01010

------

11111

所以a|b就是31.

#### 按位与(&)

就是将两个二进制数每一位进行与的逻辑操作，这里简单写一下：

1与1=1
0与1=0
1与0=0
0与0=0

比如说a=10,b=23,a&b的竖式如下：

10111
  
01010

------

00010

所以a&b就是2.


铺垫完成！！！

------

									分  割  线

------

# 基本求幂

这个大家肯定都会，设一个初始的ans为1，一个循环b次的循环

将ans不停乘以n，就好了

简朴版代码：
```cpp
#include<cstdio>
int main(){
	long long b,p,k;
    scanf("%lld%lld%lld",&b,&p,&k);
    long long ans=1;
    for(int i=0;i<p;i++){
    	ans=((ans%k)*(b%k))%k;//记得边除边模，要不然少很多个点的分
    }
    ans=ans%k;//记住最后还要取一次模，要不然少最后一个点的分
    printf("%lld^%lld mod %lld=%lld",b,p,k,ans);
    return 0;
}
```
（分数：84，第六个点TLE）

这看起来很不错了，但是你就是没办法AC...没办法AC...法AC...AC

Aaaaaaaa好烦啊！！！

（我：没错就是这么烦【奸笑】）

好吧，O（N）绝对是没法优化的，那有没有办法降低时间复杂度呢？答案是有的！

# 伪·第一种优化

从小老师就教我们：降复杂度肯定要降一个级别（废话），这里我就排个级别大小：

![](https://cdn.luogu.com.cn/upload/pic/40786.png)

（对，我就是边写题解边排的，chen_zhe不要打我TOT）

从这些函数图像上面可以看出它的增长趋势的变化，所以排序简单明了(P为指数）：

$O_{(P)} > O_{(\sqrt{P})} >O_{(logP)}$

然后思考怎么优化成$O_{(\sqrt{P})}$

然而没想出来怎么优化成$O_{(\sqrt{P})}$

所以就转攻$O_{(logN)}$了

某Luogu新手：快进入正题！

# 真·第一种优化

所以怎么办呢？

log永远和2有关，所以就先看看把P/2会变成什么？

$b^P=b^{\frac{P}{2}} * b^{\frac{P}{2}} * b^{P\%2}$

嗯，很好，那P/2也可以再分，就可以递归了，这是大好消息！可以解决TLE的问题！

AC代码奉上：
```cpp
#include<cstdio>
long long B,P,K;
long long qpow(int base,int p){
	if(p==1){
		return base;
	}else if(p==0){
		return 1;
	}else{
		long long ans=qpow(base,p/2)%K;
		long long ans1=(ans%K*ans%K)%K;
		if(p%2==1){
			ans1=(ans1%K*base%K)%K;
		}
		ans1=ans1%K;
		return ans1;
	}
} 
int main(){
	scanf("%lld%lld%lld",&B,&P,&K);
	long long ans=qpow(B,P);
	ans=ans%K;
	printf("%lld^%lld mod %lld=%lld",B,P,K,ans);
	return 0;
}

```

# 真·第二种优化

都说了log与2有关，那能不能用二进制进行运算？

把P分解成二进制，就也是log的运算了！

那怎么算呢？

一个二进制数肯定是由0或1表示的，他每一位都有一个权值。


比如说p是23，他的二进制形式是10111，表示如下：

$(10111)_2=1*2^4+0*2^3+1*2^2+1*2^1+1*2^0$

没毛病，对不对？

那大家看一下2右上角的指数变化是什么样子的？

是不是每次递增一？

对于每次增加一，是不是意味着这个数是乘2？

比如这个：$1*2^0*2=1*2^1(1*2=2)$

那么他对于$b^P$有什么意义呢？

或者换一句话说，$b^P$和$b^{2P}$的大小有什么差别？

当然是$b^P*b^P=b^{2P}$了！

那么也就是说，在每次访问这个数的二进制最后一位时，

如果是1，那就乘上$b^{2^n}$，这个可以用一个变量tmp来记录；

在此之后，tmp自乘，来增加权值。

如果不是，那就对tmp单独操作，进行自乘，将$b^{2^n}$变成$b^{2^{n+1}}$

大功告成！

我知道这很难理解，但是希望大家能够把这一部分多看几遍，理解深刻一些。

AC代码奉上：

```cpp
#include<cstdio>
long long B,P,K;
long long qpow(int base,int p){
	long long ans=1,tmp=base;//从底数开始乘，不停自乘
	while(p!=0){//指数不是0 
		if(p&1){
			ans=(ans%K*tmp%K)%K;
		} 
		tmp=(tmp%K*tmp%K)%K;//自乘
		p=p>>1;//访问下一位 
	} 
	ans=ans%K;
	return ans;
} 
int main(){
	scanf("%lld%lld%lld",&B,&P,&K);
	long long ans=qpow(B,P);
	ans=ans%K;
	printf("%lld^%lld mod %lld=%lld",B,P,K,ans);
	return 0;
}

```

---

## 作者：ww3113306 (赞：127)

快速幂的题目，注意题目中说是长整型数，所以不要用int。我是直接用一个while循环代替递归。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long b,a,p,k,ans=1,c;
int main()
{
    scanf("%d%d%d",&b,&p,&k);
    a=b;c=p;
    while(p>0)//快速幂
    {
        if(p%2!=0)
            ans=ans*b%k;//如果p为单数，乘到ans里面去，然后取模
        b=b*b%k;//每次运算都取模
        p=p>>1;    //用位运算除2，可能会快一点
    }
    ans %= k;//多年前的代码了……今天突然发现有大佬告知代码错误，仔细一看是在p = 0时没有取模，加上这句话就可以了
    printf("%d^%d mod %d=%d",a,c,k,ans);//输出
    return 0;
}
```

---

## 作者：皮卡丘之王 (赞：51)

## 1、基本的快速幂公式

#### $a$^$n$有两种情况，一种是$n$为偶数，一种是$n$为奇数。
#### 我们都知道：$a^n$+$a^m$=$a^{m+n}$。
#### 因此，$n$为偶数时$a^n$=$a^{n/2}*a^{n/2}$。
#### 而$n$为奇数时只需要再乘一个$a$就可以了。
### 下面奉上代码：
```cpp
if(n%2==0)    return (c*c)%k;
if(n%2==1)    return (c*c*(a%k))%k;
```

------------

## 2、快速幂函数代码展示
```cpp
int Pow(int a,int n)
{
    if(n==0)    return 1;
    if(n==1)    return a;
    int c=Pow(a,n/2);
    if(n%2==0)  return c*c;
    return c*c*a;
}
```
------------
#### 以上是本蒟蒻的快速幂计算方法

---

## 作者：智子 (赞：40)

看到题解里貌似并没有Python的题解，我来发一个，共两行。

众所周知，为什么有时候洛谷er们要用Python呢？因为Python里已经包装了很多算法，用在OI中基本上等于打游戏时开外挂。虽然

对于这道题，Python 3中有一个数学函数pow()，它在help()函数中的说明是这样的：

```python
pow(x, y, z=None, /)
    Equivalent to x**y (with two arguments) or x**y % z (with three arguments)

    Some types, such as ints, are able to use a more efficient algorithm when
    invoked using the three argument form.
```

`x**y % z`，这正好就是这道题所用到的算法，所以直接调用`pow(b, p, k)`就OK了。一般来说，编程语言本身的库函数都会往死里优化，基本上不用担心时间复杂度的问题。（除了某些特别坑的）


最后要注意的一点就是，很多人提交Python都莫名RE，原因是Python 3的`input()`函数返回的是字符串，必须用`int()`转换为整数。如果一行有多个数字，则调用`split()`方法分割成多个字符串。

上代码：

```python
a = input().split()
print(a[0] + '^' + a[1] + ' mod ' + a[2] + '=' + str(pow(int(a[0]), int(a[1]), int(a[2]))))
```

---

## 作者：GXuLuogu (赞：30)

快速幂顾名思义，就是快速算某个数的多少次幂。其时间复杂度为 O(logN)，与朴素的O(N)相比效率有了极大的提高。

简单来说，就是个二分求模的过程。楼下已经有DaLao讲过证明方法，故在此略。

鸟瞰楼下还没有用递归算法解的，就来一波递归（当然朴素的循环也可以）

详情可进笔者blog:[快速幂](http://www.cnblogs.com/powerfulbee/p/7629411.html "快速幂")

具体实现请看代码详解：

```cpp
#include<iostream>
#define ll long long //中间太多long long容易看花 
using namespace std;
ll b,p,k,m;
ll kuai(ll y) //求m(b%k)的y次方对k取模
{
    if (y==0) return 1; //如果幂指数为0，说明分完了，返回1
    else //否则呢。。就分它的指数（当然要判断次数奇偶）
    {
        long long temp;
        temp=kuai(y/2); //递归核心，不断去求它的y/2的值
        if (y%2==0) //说明是偶数 
            return temp*temp%k;
        else //奇数
            return temp*temp*m%k; //要再乘一遍自己 
    }
}
int main()
{
    cin>>b>>p>>k;
    if (b==k) //特判相等情况 
    {
        cout<<b<<"^"<<p<<" mod "<<k<<"="<<'0'<<endl;
        return 0;
    }
    m=b%k; //算之前先取一次模其实是很明智的,之后算m的p次方就行 
    cout<<b<<"^"<<p<<" mod "<<k<<"="<<kuai(p)%k<<endl; //输出有点裹人～～ 
    return 0;
}
```

---

## 作者：豌豆射手皮0608 (赞：28)

求${a^b}$是一个非常常见的问题，现在给大家罗列一下几种算法

~~这篇题解是专门用来纪念我瞎搞出来的O(${\sqrt{n}}$)算法的qwq~~

1. O(n)算法

这应该是求${a^b}$的最朴素算法了

直接暴力乘再取模即可qwq

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,x,k;
int main()
{
    x=1;
    cin>>a>>b>>k;
    for(int i=1;i<=b;i++)
    {
        x=x*a;
        x=x%k;
    }
    cout<<a<<'^'<<b<<" mod "<<k<<'='<<x<<endl;
}
```

当然这种算法是不能满足大部分需要的 ~~(比如这题就会T的很惨~~

2.O($\sqrt{n}$)算法

自己鼓捣出来的一种神奇算法

主要思路：对于幂次方b，递归求解，每次递归都是O($\sqrt{b}$）

递归深度增长很慢，可以当成常数（就是求一个数开几次方后的值≤3,INT_MAX都只用递归4次qwq)


```cpp
#include<bits/stdc++.h>
#define LL long long //不用long long 可能会爆
using namespace std;
LL n,m,k;
LL pow(LL x)
{
	if(x==0) return 1;
	if(x==1) return n%m;
	if(x==2) return n%m*n%m;
	if(x==3) return n%m*n%m*n%m;//打出小数据的表，可以优化一定时间
	LL s=sqrt(x);
	LL k=pow(s)%m,q=k;//k用来记录下一层递归返回的值
	for(int i=1;i<x/s;i++)
	{
		q=q*k;//不断乘k
		q=q%m;
	}
	for(int i=1;i<=x%s;i++)
	{
		q=q*n;//处理余数
		q=q%m;
	}
	return q%m;//为了防止炸long long我也是很害怕了qwq
}
int main()
{
	cin>>n>>k>>m;
	cout<<n<<"^"<<k<<" mod "<<m<<"="<<pow(k)%m<<endl;; 
	return 0;
}
```

当然这种方式肯定会被O($log_2n$)吊打

但是通过此题妥妥的够了qwq

3.O($log_2n$)

这个就不用解释了题解区其他大佬都解释过

直接上代码
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,m,k;
LL ksm(LL x,LL y)
{
	LL a=1,b=x;
	while(y>0)
	{
		if(y%2==1)
		{
			a=a*b;
			a=a%m;
		}
		b=b*b;
		b=b%m;
		y=y/2;
	}
	return a;
}
int main()
{
	cin>>n>>k>>m;
	cout<<n<<"^"<<k<<" mod "<<m<<"="<<ksm(n,k)%m<<endl;; 
	return 0;
}

```

4.一种玄学做法

我们注意到，在执行第二种算法的时候，中间O($\sqrt{n}$)的暴力乘可以用快速幂来优化 ~~(这不是在作死吗)~~ 使得时间复杂度将为O($log_2\sqrt{n}$)

~~这时间复杂度真™玄学~~

所以我们就又有了一种算法（滑稽

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,m,k;
LL ksm(LL x,LL y)
{
	LL a=1,b=x;
	while(y>0)
	{
		if(y%2==1)
		{
			a=a*b%m;
		}
		b=b*b%m;
		y=y>>1;
	}
	
	return a%m;
}
LL pow(LL x)
{
	if(x==0)return 1;
	if(x==1) return n%m;
	if(x==2) return n%m*n%m;
	if(x==3) return n%m*n%m*n%m;
	LL s=sqrt(x);
	LL k=pow(s)%m,q=k;
	q*=ksm(k,x/s-1);
	q=q%m;
	q*=ksm(n,x%s);
	return q%m;
}
int main()
{
	cin>>n>>k>>m;
	cout<<n<<"^"<<k<<" mod "<<m<<"="<<pow(k)%m<<endl;; 
	return 0;
}

```

操作起来比普通的快速幂慢一点点（毕竟调用了那么多次快速幂qwq

当然事实上只用学会普通的快速幂就够啦！

---

## 作者：密期望 (赞：25)

有一个叫做光速幂的算法可以$O(\sqrt{n})$（n为指数范围）预处理，然后$O(1)$求幂，通常用来应付同一底数，多次求幂的场景。由于
$k * k<2^{63}$，所以在这里是适用的。

思路是预处理

$a^0,a^1,a^2,...,a^{\sqrt{n}}$

$a^0,a^{\sqrt{n}},a^{2\sqrt{n}},...,a^n$

这样对于任意一个$k$我们都可以通过上面两个数列中各取一项来求得$a^k=a^{[\frac{k}{\sqrt{n}}] * \sqrt{n} } * a^{ k \% \sqrt{n}}$

```
#include<cstdio>
const int BL=50000;//block's length的缩写，别想多了
typedef long long ll;
ll read(){
    ll a=0;int op=1;char ch=getchar();
    while(ch<'0'||'9'<ch){if(ch=='-')op=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){a=(a<<3)+(a<<1)+(48^ch);ch=getchar();}
    return a*op;
}
ll pow[BL+1];
ll powb[BL+1];
ll a,n;
ll P;
void ini(){
    pow[0]=powb[0]=1;
    for(int i=1;i<=BL;i++){
        pow[i]=pow[i-1]*a%P;
    }
    for(int i=1;i<=BL;i++){
        powb[i]=powb[i-1]*pow[BL]%P;
    }
}
int main(){
    a=read();
    n=read();
    P=read();
    ini();
    printf("%lld^%lld mod %lld=%lld",a,n,P,powb[n/BL]*pow[n%BL]%P);
    return 0;
}
```

---

## 作者：Amor_Hucsy (赞：12)

这是本蒟蒻AC的第一道模板题；
AC代码如下：

```
#include<bits/stdc++.h> //←万能头文件
using namespace std;//没有这个，是不会识别cin和cout的
long a,b,c;//int可能不够大
long mc(long a, long b, long c) //←定义一个函数
//以下为子程序
{
    long jc=1;
    while(b)←判断
    {
    if(b&1) jc=(jc*a)%c;//每次运算都取模c
    a=(a*a)%c;  
    b>>=1;  //←//用位运算除2，可能会快一点
    }
    return jc;
}
//主程序
int main()
{
    cin>>a>>b>>c; //←输入
    cout<<a<<'^'<<b<<" mod "<<c<<'='<<mc(a,b,c)%c;  //←输出，不要忘了最后还要取模一次c哦！不然只有84分
    return 0;
}
```


---

## 作者：Peter_Z (赞：10)

二分法可以做，但是本人根据标程想到了三分法来解题。

三分法与二分法思路基本相同，在结尾判断3的余数即可。

代码如下：

```cpp
- #include<iostream>
- #include<cmath>
- using namespace std;
- long long b,p,k;    //题目给出的三个数
- inline long long cal(int x) {
- //奇怪的三分法快速幂
- if(x==0)    return 1;
- long long wa=cal(x/3)%k;    //三分法将其化为三份
- wa=wa\*wa\*wa;    //立方后模k
- wa%=k;
- //分三种情况：若x模3余0则什么都不用做，若x模3余1则乘上b，否则乘上b^2
- if(x%3==1)
- wa=wa\*b%k;
- else if(x%3==2)
- wa=wa\*b\*b%k;
- return wa;
- }
- int main() {
- cin>>b>>p>>k;
- cout<<b<<"^"<<p<<" mod "<<k<<"=";
- b%=k;             //先模k以防超时
- cout<<cal(p);
- }
···

---

## 作者：Magallan_forever (赞：4)

这道题要求的是计算$ a^b $，我们可以用一种类似于倍增的方法快速求 

例如，我们要计算$ 7^{90} $

因为$ 90 = 1011010_2 $

所以$ 7^{90}=7^{2^1+2^3+2^4+2^6}=(7^{2^1}*7^{2^3}*7^{2^4}*7^{2^6}) $

所以：
```cpp
ans=1;
ans*=7^1;
ans*=7^8;
ans*=7^16;
ans*=7^32;
return ans;
```
所以我们可以写成这个样子：
```cpp
while(b){ 
    if(b&1){//相当于b%2，为了写代码方便，判断b%2的余数，它们是等价的
        ans*=a;
    } 
    a*=a;
    b>>=1;//为了配合if(b&1)，将b右移一位，相当于b/=2;
} 
```
于是我们就已经可以AC了

**但是，下面才是我要说的，一个乱搞做法**

~~我来乱搞一个三分快速幂吧~~

简单的说就是这样:
```cpp
long long fp(long long a,long long b,long long mod){
	long long ans=1;
	a%=mod;
	while(b){
		if(b%3==1) ans=ans%mod*a%mod;
		if(b%3==2) ans=ans%mod*a%mod*a%mod;
		a=a%mod*a%mod*a%mod;
		b/=3;
	}
	return ans%mod;
}
```
时间复杂度为$ log_3n $

~~常数大幅减小~~

同理，我们还可以写四分快速幂，五分快速幂```and so on```

code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long fp(long long a,long long b,long long mod){
	long long ans=1;
	a%=mod;
	while(b){
		if(b%3==1) ans=ans%mod*a%mod;
		if(b%3==2) ans=ans%mod*a%mod*a%mod;
		a=a%mod*a%mod*a%mod;
		b/=3;
	}
	return ans%mod;
}
int main(){
	long long a,b,c;
	scanf("%lld%lld%lld",&a,&b,&c);
	printf("%lld^%lld mod %lld=%lld",a,b,c,fp(a,b,c));
	return 0;
}
```
[评测记录](https://www.luogu.org/record/25929167)

---

## 作者：Catreap (赞：4)

## 在这里讲一下快速幂的**原理**

## 快速幂是什么？
就是能把$pow(num)$算法效率达到$ O(log_2N) $。

利用的就是**二进制** 。

我们可以把$a^b$中的$b$拆成二进制，该二进制数第i位的权值是2^(i-1)

**E.X.** 当$b$=11时，$ a^{11} $ = $a^{2^0+2^1+2^3}$ ，~~很简单吧？~~

**Why** 11的二进制是$1011$，$11=2^{3}×1 + 2^{2}×0 + 2^{1}×1 + 2^{1}×1$

因此，我们将$a^{11}$转化为算 $a^{2^0+2^1+2^3}$ ，看出来快的多了吧原来算11次，现在算三次，那么**怎么算个数？**

有一个神奇的操作**&1**:取二进制的最末位,还可以判断奇偶。

还有一个神奇的操作**>>1**:二进制去掉最后一位。

其实也很好理解，以b=11为例，b=>1011,二进制从右向左算，顺序是 $a^{2^0}×a^{2^1}×a^{2^3}$，是从左向右的，我们不断的让$base$累乘即可。

## 实现

```cpp
ll Pow(ll a,ll b) {
	ll sum=1;//一定要初始化为1，不然返回0
	while(b) {//b!=0执行
    	//如果末位为1累乘
		if(b&1) sum=sum*a%Mod;//取MOD，题目要求
		a=a*a%Mod,b>>=1;//每操作一次，去掉末位
	}
	return sum;
}
```

---

## 作者：Robertspot (赞：4)

今天上午zxg老师依然不在丫OVO学长代课

（周四感冒的我没来上课连递归递推都没听气死、orz）

今天讲了快速幂运算（就是[这道题](https://www.luogu.com.cn/problem/P1226)）

快速幂讲了两种：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long n,a;
long long p=20191221;
long long ans;
long long f(int x,int y)
{
	if(y==0||x==1){
		return 1;
	}
	long long t;
	if(y&1){
		t=f(x,y/2)%p;
		return (t*t*x)%p;
	}
	t=f(x,y/2)%p;
	return (t*t)%p;
}
int main()
{
	scanf("%lld%lld%lld",&n,&a,&p);
	//n=2;a=3;
	ans=f(n,a)%p;
	printf("%lld^%lld mod %lld=",n,a,p);
	printf("%lld",ans);
	return 0;
}
```
这一种快速幂没有调用递归，但也是一种很精巧的算法OVO

递归版：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int b,p,k;
long long f(int x,int y)
{
	if(x==1||y==0){
		return 1;
	}
	long long t;
	t=f(x,y/2)%k;
	if(y&1){
		return (t*t*x)%k;
	}
	return (t*t)%k;
}
int main()
{
	scanf("%d%d%d",&b,&p,&k);
	printf("%d^%d mod %d=",b,p,k);
	printf("%lld",f(b,p));
	return 0;
}
```
这种调用递归的思路便是将每次的幂的指数都%=2，如奇数再*x。

（思路同样很巧妙呀QAQ）


---

## 作者：muyang_233 (赞：4)

快速幂的做法，我不多提了，大家也知道。那么直接讲关于代码的一些内容。  
一开始，我是按照原快速幂交的：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long b,p,k,ans=1,fb,fp;
	cin>>b>>p>>k;
	fb=b;fp=p;
	while(p)
	{
		if (p%2) 
		    ans=ans*b%k;
		p/=2;
		b=b*b%k;
	}
	printf("%d^%d mod %d=%d",fb,fp,k,ans);
}
```
然后，最后一个点WA了。  
因为——
### 需要特判0次幂！！！
## 需要特判0次幂！！！
# 需要特判0次幂！！！
在最后一个测试点中，p的值为0！  
而如果不进行特判的话，相信我们都会把s初值赋为1，这样就错了。  
所以，在循环之前进行特判，p为0就不做循环，赋值为0，else就赋值为1，并循环。 
还有，注意此题输出，在做快速幂时会对b和p的值进行改变，所以请保留一个副本。  
所以，代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long b,p,k,ans=1,fb,fp;
    cin>>b>>p>>k;
    fb=b;fp=p;//所说的副本
    if (p)//特判
    {
        while(p)
        {
            if (p%2) 
                ans=ans*b%k;
            p/=2;
            b=b*b%k;
        }
    }
    else ans=0;//p为0时直接不做循环值为0
    printf("%d^%d mod %d=%d",fb,fp,k,ans);
    return 0;
}
```
~~蒟蒻在其他题目经历过无数次的拒接和删除，我不想在这样了！~~

---

## 作者：Andysun06 (赞：4)

## @da32s1da提供一组可能卡掉部分人的数据,所以现在很多题解都不能通过，让我来一发可以通过的题解吧！
### 上代码：
    var x,n,m,i,j,r:Qword;//数很大！！！
    begin
     readln(x,n,m);//输入
     if (x=1)and(n=0)and(m=1) then//抵抗@da32s1da提供的数据
      begin
       writeln('1^0 mod 1=0');
       halt;
      end;    
     r:=r+1;
     i:=n;
     j:=x;
     while 0<n do//while语句
      begin
       if (n mod 2)=1 then//百度一下就知道了
        begin
         r:=(r*x)mod m;
        end;
      n:=n div 2;
      x:=(x*x)mod m;
     end;
     writeln(j,'^',i,' mod ',m,'=',r);//输出
    end.

---

## 作者：1saunoya (赞：3)

# [博客食用效果更佳](https://www.cnblogs.com/qf-breeze/p/10415945.html)

## 前言：乘法的时间复杂度是O(1)，所以快速幂的时间复杂度O(logN)成立

## Input ：2 10 9

## Output：7

>2^10%9=7 没毛病

>普通幂:废物过程 可你有没有发现这个很烦？

>可是 算到2^64就炸了qwq （__int128啥的给我走开）

```
b=2,p=10,k=9
2^1=2 2%9=2 
2^2=4 4%9=4 
2^3=8 8%9=8 
2^4=16 16%9=7 
2^5=32 32%9=5 
2^6=64 64%9=1
2^7=128 128%9=2
2^8=256 256%9=4
2^9=512 512%9=8
2^10=1024 1024%9=7
```

> 递推幂：甚至还可以在优化 成 b^k-1%p*b 其实也就是递推 这样就好一丢丢吧 大数字的时候可以这样暂且优化一下（至少不容易爆精度） 也是比较有实用性的 orz 这样就可以得到 
```cpp
a[1] = b ;
    for (register int i=2;i<=k;i++) a[i] = a[i-1] % p * b ;
```

>这样不就是个递推了吗 海星 用数组只是好理解 而且不太会爆精度 不知道多少分（应该比较优秀的分数吧）

```
b=2,p=10,k=9
2%9=2 
2*2%9=4 
4*2%9=8 
8*2%9=7 
7*2%9=5 
5*2%9=1
1*2%9=2
2*2%9=4 
4*2%9=8 
8*2%9=7 
```
>看图 其实有一部分是循环节（我还复制了） 可以通过循环节来处理加速（不建议）万一没有循环节呢

>mod：是时候叫出快速幂（超级飞侠）来帮忙了 每次遇到困难...（不玩梗了）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
inline LL quickpow (LL x , LL y , LL mod){ LL ans = 1;//自定义函数可作为快速幂模型
	for ( ; y ; x = x * x % mod , y >>= 1) y & 1 ? ans = ans * x % mod : 0;
	return (LL) ans % mod ;
}
signed main() {
	LL b,k,p;
	cin >> b >> k >> p ;
	cout << b << '^' << k << " mod " << p << '=' << quickpow(b , k , p) << endl ;
	return 0;
}
```


 >这个代码可以作为模板使用
 ~~（背就完事了哪那么多话）~~

---

## 作者：「QQ红包」 (赞：3)

快速幂『其实递归的快速幂更容易理解……这里是递推』

```delphi

 var b,p,m,s,t:qword;//longint49分
 begin
     read(b,p,m);
     write(b,'^',p,' mod ',m,'=');{到后面p变0了}
     s:=1;t:=b;
     while p>0 do
     begin
          if odd(p) {这里用 p mod 2=1 不知为什么会爆215错误}then s:=s*t mod m;
          p:= p div 2;
          t:=t*t mod m;{这里用了一个很强大的技巧,t*t即求出了b^(2^(i-1))原理自己看}
     end;
     write(s);
end.


```

---

## 作者：梦回还 (赞：3)

淳朴善良的快速幂，a的b次方，可以相当于b除2，a乘方一次。（记得每一次都要取模，否则会爆）

那么如果b对2取模剩余了1，那么这个1就归到答案中去，循环求解。



```cpp
var a,b,c,d:int64;
begin
        read(a,b,c);
        write(a,'^',b,' mod ',c,'=');//输出格式保留
        a:=a mod c;
        d:=1;
        while(b<>0)do
        begin
                if(b mod 2=1)then d:=d*a mod c;
                b:=b div 2;
                a:=(a*a)mod c;
        end;//循环求解
        write(d);
end.
```

---

## 作者：DarkMoon_Dragon (赞：3)

先讨论无需取模的


当b为偶数时：ab=a(b/2)\*2=(a2)b/2


当b为奇数时：ab=a\*ab-1=a\*(a2)(b-1)/2


如   28=（22）4         27=2\*(22)3


所以，我们可以如此迭代下去



　　210=(22)5=(22)\*[(22)2]2

 ①       ②              ③


指数为10 是一个偶数，则底数2平方，指数变为一半 [ ①→② ]


指数为5 是一个奇数，则先将底数提出作为系数（22），此时指数为4 是一个偶数，则底数22再平方，指数再变为一半 [ ②→③ ]


归纳总结得到：


      当指数大于1时，若为 偶数 则将指数除以2，底数平方


若为 奇数 则先提出一个为底数的系数（可直接把该系数乘进ans中），所以指数减1，然后再按照 偶数 的办法做


不断迭代下去，当指数为1时，则直接得出答案


最后只要将每次相乘时取模即可，时间复杂度O(log2b)


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
long long ans=1;
//a^n%k
long long quickmi(long long a,long long n,long long k)
{
    while(n>0)
    {
    if(n&1)/*-->n%2!=0*/ans=(ans*a)%k;
    n=n>>1;//-->n/2；n=1时，n位移1为0 
    //注意赋值！！！！！ 
    a=(a*a)%k;
    }
    return ans;
}
int main()
{
    int a,n,k;
    cin>>a>>n>>k;
    cout<<a<<"^"<<n<<" "<<"mod "<<k<<"="<<quickmi(a,n,k);
    return 0;
}
```

---

## 作者：critnos (赞：2)

```cpp
//1.0
#include<iostream>
using namespace std;
long long ksm(long long b,long long p,long long k)
{
    if(p==0)
    return 1;
    long long t=ksm(b,p/2,k);
    t=(t%k)*(t%k)%k;
    if(p%2==1)
    t=(t%k)*(b%k)%k;
    return t;
}
int main()
{
    long long b,p,k;
    cin>>b>>p>>k;
    cout<<b<<"^"<<p<<" mod "<<k<<"="<<ksm(b,p,k);
}
```
原理没什么好说的，如果最后一个没有WA的话，我也不会来写题解

透露一下，最后一个测试点是：1 0 1

这个蒟蒻的代码对此的结果是1

蒟蒻一眼看上去，好像没毛病

好吧，答案是0

正当我准备~~猥琐的~~写特判时，我突然想到——

还有另一种~~不那么猥琐的~~特判（参见2.0）

```cpp
//2.0
#include<iostream>
using namespace std;
long long ksm(long long b,long long p,long long k)
{
    if(p==0)
    return 1%k;
    long long t=ksm(b,p/2,k);
    t=(t%k)*(t%k)%k;
    if(p%2==1)
    t=(t%k)*(b%k)%k;
    return t;
}
int main()
{
    long long b,p,k;
    cin>>b>>p>>k;
    cout<<b<<"^"<<p<<" mod "<<k<<"="<<ksm(b,p,k);
}
```

---

## 作者：IMGBY (赞：2)

## 本蒟蒻初次发题解

拿到题目，看了下内容，发现这道题可以运用到二分算法。

也就是说可以将p拆解，举个栗子3^90%17（之后也以这个为栗子）
```
3^90 % 17可以拆分为 ((3^45 % 17)*(3^45 % 17)) % 17
而3^45 % 17则又可以拆分为((3^22 % 17)*(3^22 % 17)*(3 % 17)) % 17
后3^22 % 17则拆分为((3^11 % 17)*(3^11 %17)) % 17
```
以此类推得
```
3^11 % 17 = ((3^5 % 17)*(3^5 %17)*(3 %17)) % 17
3^5 % 17 = ((3^2 % 17)*(3^2 % 17)*(3 % 17)) % 17
3^2 % 17= ((3 % 17)*(3 % 17)) % 17
```
为了之后方便，我称以上为"结论1"

因此可得如下p得变化

![图飞了](https://cdn.luogu.com.cn/upload/image_hosting/n8ykl76m.png)

为了提升速度，我们据上表，可知只需计算上表绿色部分，即3^"绿色部分" % 17，得代码如下

```
long long cal(long long b,long long p,long long k) {
    if(p==1) return b%k;
    return ( cal( b , p/2 , k )%k * cal( b , p/2 , k )%k )%k;
}
```
为了处理当p出现奇数的情况，可在返回值处添加如下表达式
```
( p%2==0 ? 1 : b%k )
```
即当p为偶数时返回1，否则返回b%k

在return处，调用了cal函数两次，不妨优化一下
```
long long cal(long long b,long long p,long long k) {
    if(p==1) return b%k;
    int t=cal( b , p/2 , k )%k;
    return ( t * t * ( p%2==0 ? 1 : b%k ))%k;
}
```

输入输出就不必讲了，放代码
```
# include <iostream>
# include <cstdio>
using namespace std;
long long b,p,k;
long long cal(long long b,long long p,long long k) {
    if(p==1) return b%k;
    int t=cal( b , p/2 , k )%k;
    return ( t * t *( p%2==0 ? 1 : b%k ))%k;
}
int main() {
    cin>>b>>p>>k;
    printf("%d^%d mod %d=%d",b,p,k,cal( b , p , k ));
    return 0;
}
 ```
 为了避免某些比较毒的测试数据我在主函数里增加了
 ```
    int ansp=p;
    if(p==0) {
        b=1;
        p=1;
    }
 ```
 以上就是取余运算的题解了，本人蒟蒻，如有不足，烦请指出啦！

---

## 作者：Camorgx (赞：2)

这一题的题解已经很多了，但我看没有Java8的题解，我就准备发一篇。

我在我的代码里封装了一个快读类，所有基础类型的读写都可以通过改写nextLong方法实现。顺便教萌新~~大佬请无视~~一个小技巧就是Java也有printf函数。~~由于我写C++比较多代码可能会有C++的代码风格~~

快速幂的思路和方法我就不多说了，唯一要注意的是当p==0时要特判一下，不然第7个点会WA
```java
import java.io.*;
import java.util.*;
class Reader {
	static BufferedReader reader;
	static StringTokenizer tokenizer;
	static void init(InputStream input) {
		reader=new BufferedReader(new InputStreamReader(input));
		tokenizer=new StringTokenizer("");
	}
	static String next() throws IOException {
		while(!tokenizer.hasMoreTokens())
			tokenizer=new StringTokenizer(reader.readLine());
		return tokenizer.nextToken();
	}
	static long nextLong() throws IOException {
		return Long.parseLong(next());
	}//通过对这个函数进行改写，可以快速读入基础类型(比如int、double等等)
}
public class Main {
	public static void main(String[] args) throws IOException {
		Reader.init(System.in); //读入类初始化
		long b=Reader.nextLong(),p=Reader.nextLong();
		long k=Reader.nextLong(),a=b,c=p,ans=1;
        //注意Java中的long就表示64位整数，而不是long long
		if(p==0) { 
			System.out.printf("%d^%d mod %d=%d",b,p,k,1%k);
			return;
		}//这里要特判  555坑
		while(p>0) {
			if(p%2!=0) ans=ans*b%k;
			b=b*b%k; p>>=1;
		}
		System.out.printf("%d^%d mod %d=%d",a,c,k,ans);
	}
}
```

---

## 作者：Erina (赞：2)

之前看了各位神犇的各种思路,现在来写一下一些**不太一样**的版本.

## 快速幂的递归写法
```cpp
long long ksm(long long x,long long y,long long mod){//卡速米是从哪里来的?
	if(y){
    	long long div=ksm(x,y>>1,mod);
        if(y&1)return (div*div)%mod*x%mod;
        else return div*div%mod;
	}
    return 1;
}
```
非常标准,也正是红书的~~偷懒~~解法.

之后是一些奇奇怪怪的写法

比如说曾经的的使用了快速思路的快乘,不会在乘法时爆long long(数据太水,$b*b$不爆long long让很多算法浑水摸鱼过了)

```cpp
#include<iostream>
using namespace std;
long long mult(long long a,long long b){
    if(b==1)return a;
    if(b==0||a==0)return 0;
    long long ans=mult(a<<1,b>>1);
    if(b&1)ans+=a;
    return ans;
}
long long pm(long long a,long long i,long long n){
    if(i==0)return 1%n;
    long long temp=pm(a,i>>1,n);
    temp=mult(temp,temp)%n;
    if(i&1)temp=mult(temp,a)%n;
    return temp;
}
int main(){
    long long int a,b,c;
    cin>>a>>b>>c;
    cout<<a<<"^"<<b<<" mod "<<c<<"="<<pm(a,b,c);
}
```

之后又有大佬发话了,说a可以等于$2^{63}-2$这样快乘也会爆(这个人是个天才)所以我就写出了快加.

```cpp
#include<iostream>
using namespace std;
long long mod;
long long s(long long x,long long y){
	for(;y;y^=y&-y)x+=y&-y,x%=mod;
	return x;
}
long long m(long long x,long long y){
	long long sum=0;
	for(;y;y>>=1,x=s(x,x))if(y&1)sum=s(sum,x),sum%=mod;
	return sum;
}
long long p(long long x,long long y){
	long long sum=1;
	for(;y;y>>=1,x=m(x,x))if(y&1)sum=m(sum,x);
	return sum%mod;
}
long long x,y;
int main(){
	cin>>x>>y>>mod;
	cout<<x<<'^'<<y<<" mod "<<mod<<'='<<p(x,y);
}
```

之后就可以正常通过了......

---

## 作者：zyj_Orz (赞：2)

本题难点在于数据规模较大，对于b^p显然不能手算，要不然时间复杂度与编程复杂度会很高。

# 所以可以使用……分治！

介绍一个原理：```a*b%k=(a%k)*(b%k)%k```,显然，这就可以把较大幂分解，免去高精度等计算。

## 那么到底怎么分解？

显然对于任意自然数n，有```n=2*n/2+n%2```,例如```19=2*19/2+19%2=2*9+1```，利用此原理可以把b^19%k转化为```b^2*9+1即b*b^9*b^9```.这么分解下去不难求出解。


------------


# 代码如下

```
#include<bits/stdc++.h>
using namespace std;
int b,p,k,a;
int mi(int p)//分治 
{
	if(p==0) return 1;//边界 
	int tmp=mi(p/2)%k;
	tmp=(tmp*tmp)%k;
	if(p%2==1)//p为奇数的特判 
	tmp=(tmp*b)%k;
	return tmp%k;
}
int main()
{
	cin>>b>>p>>k;
	cout<<b<<"^"<<p<<" mod "<<k<<"=";
	if(p==0)//进行一个特判，要不最后一个点过不了 
	{
		cout<<1%k;
		return 0;
	}
	b%=k;
	cout<<mi(p);
	return 0;
}
```

---

## 作者：巫妖王 (赞：2)

- 以下以求a的b次方来介绍

- 把b转换成二进制数。

- 该二进制数第i位的权为

- 例如

-  ![](https://cdn.luogu.com.cn/upload/pic/9293.png) 

- 11的二进制是1011

- 11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1

- 因此，我们将a¹¹转化为算

```cpp
-  ![](https://cdn.luogu.com.cn/upload/pic/9295.png) 
var a,b,n:int64;
function f(a,b,n:int64):int64;
var t,y:int64;
begin
  t:=1; y:=a;
  while b<>0 do begin
    if(b and 1)=1 then t:=t*y mod n;
    y:=y*y mod n;{这里用了一个技巧,y*y即求出了a^(2^(i-1))不知道这是什么的看原理 
                    a^(2^(i-1))*a^(2^(i-1))=a^(2^i)
```
而且一般情况下a\*b mod c =(a mod c)\*(b mod c) mod c}
```cpp
    b:=b shr 1;{去掉已经处理过的一位}
  end;
  exit(t);
end;
begin
  read(a,b,n);{n是模}
  writeln(a,'^',b,' mod ',n,'=',f(a,b,n));
end.
```

---

## 作者：yqw2486 (赞：2)

题目中提到求b^p%k；按照普通的做法，有可能会产生很大很大的中间的变量，但是结果只会在0---k之间，因此这里需要使用取模运算的一个性质(a \* b) % k = (a %k \* b %k) %k，当a=b的时候就是a^2%k，p次方就是p次相乘，每乘一次就取模一次，最后再取模一次，这样可以避免超大中间变量，让程序跑p次应该就可以得到正确答案了；但是当p>10^9以后TLE。因此这里需要对p再做一些处理，也就是快速幂；主要使用二分的思想，p有可能是奇数也有可能是偶数，如果是偶数，则b^p=(b^(p/2))\*(b^(p/2));同样的p为奇数b^p=(b^(p-1/2))\*(b^(p+1/2));.。这样就可以将O(n)压缩到O(log n),实现快速幂。

分解：p不断的除以2

解决：当p为1的时候直接返回b,并递归求出其他解

归并：如果是偶数，则b^p=(b^(p/2))\*(b^(p/2));同样的p为奇数b^p=(b^(p-1/2))\*(b^(p+1/2));这既是解决方案也是归并方案

【代码实现】

     
```cpp
#include<iostream>
using namespace std;
long long b,p,k,ans; 
long long getMode(long long int x,long long int y){//x^y
    if(y==1)return x%k;
    else{
        if(y%2==0) {
            int temp=getMode(x,y/2);
            return temp*temp%k;
        }
        else
            return (getMode(x,(y+1)/2)*getMode(x,(y-1)/2))%k;
    }
}
int main(){
    cin>>b>>p>>k;
    ans=getMode(b,p);
    cout<<b<<"^"<<p<<" mod "<<k<<"="<<ans<<endl;
    return 0;
}
```

---

## 作者：jzqjzq (赞：2)

啊！！！。。。终于AC了

虽是很明显的快速幂，但是一开始我尝试用递归，强势WA！

wsm呢？原来数据一大，尽管我用longlong可惜输出全是0！

后来改用非递归版，AC了这题

非递归函数代码如下：

```cpp
long long mi(long long a,long long b,long long c){
    long long x,y;
    x=1; y=a;
    while (b!=0){
        if (b&1==1) x=x*y%c;
        y=y*y%c; b=b>>1;
    }
    return x;
}
其他我不写了，主程序不用说了吧。。。。。
```

---

## 作者：CoolTeam (赞：2)

快速幂取余C语言版：

```cpp
#include<stdio.h>
int PowerMod(int a, int b, int c) 
{
    int ans=1;
    a%=c;
    while(b>0)
    {
        if(b%2==1)
            ans=ans*a%c;//a^b mod c =(a^2 mod c * a mod c )^(b/2) mod c  
        b/=2;
        a=a*a%c;//a^b mod c =(a^2 mod c)^(b/2) mod c  
    }
    return ans;
}
int main(void)
{
    int a,b,c;
    scanf("%d %d %d",&a,&b,&c);
    printf("%d^%d mod %d=",a,b,c);
    printf("%d",PowerMod(a,b,c));
    return 0;
}
```
如果看不懂点进百度文库\_快速幂算法C语言版(超详细)\_：

http://wenku.baidu.com/link?url=rOADvICrA-sOY8lowCYJsxdsjvU0X1Im-ZsgPpWGvFlKzAQG7EZxlHYjRKWM4REqmvPTZ3xHp5A98pzU\_5usvGXwn-dwH2tj5fahBaGirga


---

## 作者：撤云 (赞：2)

可以看看我的博客上面有着道题的解释  [传送门](http://blog.csdn.net/longlong\_long/article/details/77854757)

看了这道题以后不会快速幂的人就会说这题还不简单吗用高进度乘法+高精度膜法。但是这道题的数据十分大都为长整型数，所以这个办法肯定行不通的，所以我们要来考虑别的方法，那么快速幂就派上用场了。


快速幂从字面上来讲就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高

先来看看这两个公式

![这里写图片描述](http://img.blog.csdn.net/20150212134634865)

以b为偶数来举例。

a^b%c = ((a^2)^b/2)%c;

假设b/2还是偶数，则

((a^2)^b/2)%c = (((a^2)^2)^(b/2)/2)%c

所以就很好理解了，话不多说上代码。


```cpp
#include<cstdio>
#include<cstdio>
#include<iostream>
using  namespace  std;
long long mod(long long  a,long long b,long long c) {
    long long ans=1;
    while(b) {
        if(b&1)//位运算相当于b%2==1.
            ans=ans*a%c;
        a=a*a%c;
        b>>=1;//位运算相当于b/=2.
    }
    return ans;
}
int main () {
    long long b,p,k;
    cin>>b>>p>>k;
    cout<<b<<"^"<<p<<" mod "<<k<<"=";
    cout<<mod(b,p,k)%k;
}
```

---

## 作者：刘备 (赞：2)

很明显，对于每一个n^x，若x为偶数，则n^x=(n\*n)^x/2。若x为奇数，则n^x=(n\*n)^x/2\*n。那么我们就能轻松的用简单的递归解决快速幂。

代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
long long b,p,k,ans;
long long qpow(long long n,long long x,long long mod)
{
    if(x==0) return 1;//递归出口：0次方为1
    long long res=qpow(n*n%mod,x/2,mod);//递归
    if(x&1) res=res*n%mod;//若x为奇数那么把返回值乘上n
    return res;
}
int main()
{
    scanf("%lld%lld%lld",&b,&p,&k);
    ans=qpow(b,p,k);
    printf("%lld^%lld mod %lld=%lld",b,p,k,ans);
    return 0;
}
```

---

## 作者：littlefrog (赞：1)

- 1.题目分析

[原题](https://www.luogu.org/problemnew/show/P1226)

本题在于快速幂的使用，以及对long long的应用问题。

- 2.解题思路

1. 快速幂

求幂常见用法：
```cpp
int pow(int a,int b) {
	int ans;
	for(int i = 1;i<=b;++i) {
    	ans*=a;
    }
    return ans;
}
```
原理十分简单，将a乘b次。
时间复杂度： _O(n)_ 

但快速幂比它更快：

```cpp
while(m>0){
        if(m%2==1)
            ans=ans*b%p;
        b=b*b%p;
        m=m>>1;
}
```
（以上是算法示例）
时间复杂度： _O(log n)_ 

所以，代码就出来了：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int main() {
	long long ans = 1, i, j, k, m, n, b, p;
	scanf_s("%lld%lld%lld", &b, &m, &p);
	printf("%lld^%lld mod %lld=", b, m, p);
	while (m > 0) {
		if (m % 2 == 1)
			ans = ans * b % p;
		b = b * b % p;
		m = m >> 1;
	}
	printf("%lld", ans % p);
	return 0;
}
```

---

## 作者：古蔺职高徐扬 (赞：1)

徐氏二分快速幂^v^  

首先这个问题，本渣数学实在太菜看不到1^1是什么意思

然后这个问题，可以很好的体现出二分的威力。

本渣最喜欢问别人的一个问题：10个亿一直除以二除多少次能得到1，

这便是二分的威力。

二分思路：


3 ^ 7 = 6 ^ 3 * 3


6 ^ 3 = 36 *6

t的N次幂 = t*t的 N/2次幂 乘以 N%2次 t，

递归的味道还是比较浓的嘿嘿！


帖个垃圾代码：


    /*徐氏 二分快速幂*/ 

    /*    先写个万写头文件保平安  ^v^ */ 


    #include<bits/stdc++.h>


    using namespace std;


    typedef long long Type;



    Type S[50];


    int top;


    int main()


    {

        top = -1;
        Type d,p,k,t,ans;
        cin >> d >> p >> k;
        ans = d%k;		//这个地方卡了两个点 
        t =  p;
        while(t/2){
            if(t%2) S[++top] = ans;
            ans = ans * ans % k;
            t/=2;
        }
        while(top>=0) ans = ans * S[top--] %k; 
        cout<<d<<"^"<<p<<" mod "<<k<<"="<<ans<<endl;
        return 0;
    }

递归版，微微看好一丢丢


    /*徐氏 二分快速幂*/ 



    /*    先写个万写头文件保平安  ^v^ */ 


      #include<bits/stdc++.h>


      using namespace std;


      typedef long long Type;




      Type Run(Type d,Type p,Type k)

      {


               /*实在记不得运算符优先级，加几个括号压压惊 ^v^*/
               return p<=1 ? d%k :(Run(d*d%k,p/2,k)*(p%2?d:1)%k);

      }

      int main()

      {

          Type d,p,k;

          cin >> d >> p >> k;

          cout<<d<<"^"<<p<<" mod "<<k<<"="<<Run(d,p,k)<<endl;

          return 0;
      }


---

## 作者：_棉花糖_ (赞：1)

# P党福利

这一题呢，其实noip2017完善程序考过的，所以过程我就不多说了

注意一个坑：
任何数的## 0次方都是1……
## 第7个数据是这样的：
### 输入 1 0 1
### 输出 1^0 mod 1=0
（~~我才不告诉你我第一次测的时候这个点没过呢~~）

呵呵，还是给点提示吧：
# 若p为偶数，b^p=(b*b)^p div 2;
# 若p为奇数，b^p=b*(b*b)^(p-1)div 2

上代码
```pascal
var x,p,m,i,result:longint;
begin
    read(x,p,m);
    write(x,'^',p,' mod ',m,'=');
    if p>0 then result:=1;
    while(p>0)do
      begin
          if(p mod 2=1)then result:=result*x mod m;
          p:=p div 2;
          x:=x*x mod m;
      end;
    write(result);
end.

```

最后，有兴趣的可以看看我的[博客](https://www.luogu.org/blog/user67087/)（尽管题解少得可怜）~~

---

## 作者：氢氧化铯CsOH (赞：1)

不使用64位整数过这道题

```cpp
#include<cstdio>

inline int multi(int a, int b, int mod){// 读取三个int a, b, mod，返回(a*b)%mod
//不使用long long
    a %= mod, b %= mod;
    int ans = 0;
    while(b){
        if(b & 1){
            ans += a;
            if(ans >= mod){
                ans -= mod;
            }
        }
        a <<= 1;
        if(a >= mod){
            if((a -= mod) == 0) return ans;
        }
        b >>= 1;
    }
    return ans;
}

inline int powmod(int a, int b, int mod){
    int base = a, ans = 1;
    while(b){
        if(b & 1){
            ans = multi(ans, base, mod); 
        } 
        base = multi(base, base, mod);
        b >>= 1;
    }
    return ans;
} 

int main(){

    int a, b, m;
    scanf("%d%d%d", &a, &b, &m);
    printf("%d^%d mod %d=%d", a, b, m, powmod(a, b, m));

}

```

---

## 作者：HZgzy (赞：1)

基本数学公式: (a\*b)%c=((a%c)\*(b%c))%c





```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
long long b,p,k;
long long ans;
long long Mod(long long t){
     if (t==1) return b%k;
     ans=Mod(t/2);
     ans=(ans*ans)%k;  //注意:千万别写ans=Mod(t/2)*Mod(t/2) 否则时间效率爆炸
     if (t%2==1) ans=(ans*(b%k))%k;  
     return ans;
}
int main(){
    cin>>b>>p>>k;
    cout<<b<<'^'<<p<<" mod "<<k<<'='<<Mod(p)<<endl;
  //  system("pause");
    return 0;
}
```

---

## 作者：wsyzz (赞：1)

!!注意将所有的数据类型啥的都改成“long long”

不然你会得到46大分！！！！！！


```cpp

#include<iostream>
#include<cstdio>
using namespace std;
long long a,p,k,ans;
long long fast(long long a,long long p,long long k){//注意！！！！这里的定义也要long long 不然46分！！！！ 
    long long aa=1;
    while(p!=0){
        if(p&1) aa=(aa*a)%k;
        a=(a*a)%k;
        p>>=1;
    }
    return aa;
}
int main(){
    cin>>a>>p>>k;
    cout<<a<<"^"<<p<<" mod "<<k<<"="<<fast(a,p,k);
    return 0;
}

```

---

## 作者：1517460958dyc (赞：1)

a ^ b mod c 的值必有循环。

```cpp
program hehe;
var
 a,b,c,i,s:longint;
 m:array[1..10000]of longint;存储循环
label 1;
begin
  readln(a,b,c);
  m[1]:=a mod c;
  for i:=2 to 10000 do 寻找循环
  begin
    m[i]:=m[i-1]*a mod c;
    if m[i]=m[1] then goto 1;找到后跳出
  end;
  1:s:=m[b mod (i-1)]; 跳出处
  write(a,'^',b,' mod ',c,'=',s);
end.
```

---

## 作者：自动WA机 (赞：1)

# 超级快速幂  
这是个神马东西？

~~三分优化的快速幂？~~

注意：二分的实用就在于三分的时间复杂度一般为log3（N^2），以此类推。。。

~~我不是故意怼那个[三分装逼者](https://www.luogu.org/space/show?uid=45108)的~~

原理：a^b=a^(b-n*f(m1))*d^(n*f(m1)) (mod m)

~~相信很多人已经明白我在装逼~~

其中 d=gcd(a,m) m=m1*d f(m1)为欧拉函数 n=b/f(m1)

好了，不多介绍了，你的~~抄题解~~任务，就是找出在别人的题解中也有的那一部分。

而不能复制代码中的其他部分。我可是监控了代码的（假的 ~~废话~~）

上~~未知AC情况~~TLE+MLE+PE+RE+OLE+WA+CE的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//比宏定义安全不知道几千倍的定义

ll gcd(ll a,ll b) {
    return b == 0 ? a : gcd(b, a % b);
}

ll eul(ll a) {
    ll res = a;
    for(ll i = 2; i * i <= a; i++) {
        if(a % i == 0) {
            res = res / i * (i - 1);
            while(a % i == 0) a /= i;
    	}
	}
    if(a > 1) res = res / a * (a - 1);
    return res;
}

ll Pow(ll a,ll b,ll m) {
	ll s = 1;
	while(b) {
		if(b & 1)
			s *= a,
			s %= m;//python的大佬和蒟蒻应该都懂。 
		b >>= 1;
		a *= a;
		a %= m;
	}
	return s;	
}

ll FaP(ll a,ll b,ll m) {
	ll d = gcd(a, m), m1 = m / d, f = eul(m1), d1 = gcd(d, m1);
    //真正的装逼时间到了。
	if(d == m) return 0;//废话，要不然这题多水。
	else if(d == 1) return Pow(a, b % f, m);//自己看文章开头找优化不了的原因。
	else return Pow(a, b % f, m) * d / d1 * FaP(d, b / f * f - 1, m1);
}

int main() {
	ios::sync_with_stdio(false);//取地址符真恶心，避免就用这句话。 
	ll a, b, m;
	cin >> a >> b >> m;
	cout << a << '^' << b << " mod " << m << '='; 
	//clock_t start = clock();
	//测试时间，好像真的比其他大佬的快一点。全部输出0我可不负责任233333333 
	a = FaP(a % m, b, m) % m;
	cout << a;
	//clock_t ends = clock();
	//cout << "Running Time : " << (double)(ends-start) / CLOCKS_PER_SEC << endl;
	return 0;
}
```

---

## 作者：sleepyNick (赞：1)

**P党的福利**

快速幂的时间复杂度大致为O（logn），基本采用了分治思想：

x^p={x^(p-1)\*x(p为奇数),(x^(p/2))^2(p为偶数)}

想要避免被卡常，你需要采用位运算快速幂。具体操作有：

1、判断奇数（XXX and 1=1）（看二进制最末位是不是1）

2、div 2（XXX shr 1）（二进制右移1位，即div 2）

采用位运算可以使程序的时间复杂度常数变小很多。

贴程序：




```cpp
var a,p,k,b,t,y:longint;
procedure Print;
begin
    writeln(a,'^',p,' mod ',k,'=',t);
end;
procedure Power;     //快速幂
begin
    t:=1;y:=a;b:=p;
    while b>0 do
        begin
            if b and 1=1     //b and 1=1说明为奇数
                then t:=t*y mod k;
            y:=y*y mod k;
            b:=b shr 1;
        end;
end;
procedure Main;
begin
    readln(a,p,k);
end;
begin
    Main;
    Power;
    Print;
end. 

```

---

## 作者：backordinary (赞：1)

这题本来老早过掉了，但是看到一个有趣的优化，而且优化方式完全类似，就兴奋的发一波题解。

具体的算法就是用**快速乘法**优化快速幂；

而快速乘法的算法也差不多，判断奇偶，

奇数的话先将答案**加**上当前的a （也就是将奇数转化为偶数，后面除二的时候直接舍去了）

偶数的话将当前的a更新为两倍的a，不论怎么样，最后b一定会转化为1 这样就讲最终答案更新上去了

------------------------------------------------------------------------------------------------------

以上是优化快速乘法

接着就是快速幂，判断奇偶，

奇数的话先将答案**乘**上当前的a （也就是将奇数转化为偶数，后面除二的时候直接舍去了）

偶数的话将当前的a更新为\_a的平方\_，不论怎么样，最后b一定会转化为1 这样就讲最终答案更新上去了

放代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read()
{
    ll kk=0,f=1;char cc=getchar();
    while(cc<'0'||cc>'9'){if(cc=='-')f=-1;cc=getchar();}
    while(cc>='0'&&cc<='9'){kk=(kk<<1)+(kk<<3)+cc-'0';cc=getchar();}
    return kk*f;
}
ll q_cheng(ll a1,ll b1,ll mod)
{
    ll asd1=0;
    while(b1)
    {
        if(b1&1)asd1=(asd1+a1)%mod;
        b1>>=1;a1=(a1+a1)%mod;
    }
    return asd1;
}
ll q_pow(ll a,ll b,ll mod)
{
    ll asd=1;
    while(b)
    {
        if(b&1)asd=q_cheng(asd,a,mod);
        b>>=1;
        a=q_cheng(a,a,mod);
    }
    return asd;
}
int main()
{
    ll a=read(),b=read(),c=read();
    printf("%lld^%lld mod %lld=",a,b,c);
    ll jie=q_pow(a,b,c);
    printf("%lld\n",jie);
}
```

---

## 作者：KesdiaelKen (赞：1)

本人看题目看的晕头转向，结果想到了一个奇奇怪怪的方法：二进制拆分。

要求a^b%c可以先求出a^(2^0)%c,a^(2^1)%c,a^(2^2)%c,......,a^(2^k)%c（2^k<=b）。用公式a^(2^k)%c=(a^(2^k-1))^2%c就可以递推求出它们的值。然后，用类似LCA倍增的方式拆分b，将它拆成2^n1\*2^n2\*...\*2^nm的形式，然后答案就等于a^(2^n1)\*a^(2^n2)\*...\*a^(2^nm)%c。大功告成！（是不是有点晕晕的？多看几遍就行了）

下为本人弱弱的代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
long long f[200]={0};//f[i]=a^(2^i)%c，具体见解析
long long b,p,k;
long long n2[100];//n2[i]=2^i
inline long long ksm(long long mi)
{
    long long sum=1;//乘积初始化
    for(int i=62;i>=0;i--)//long long最大范围内枚举
    {
        if(n2[i]<=mi)//若小于它，即属于它二进制表示中的一部分
        {
            mi-=n2[i];//去掉它
            sum=(sum*f[i])%k;//更新乘积
        }
    }
    return sum;
}
int main()
{
    scanf("%lld%lld%lld",&b,&p,&k);
    f[0]=b%k;
    n2[0]=1;//设置初始值，以便递推
    for(int i=1;i<=62;i++)n2[i]=n2[i-1]*2;
    for(int i=1;i<=62;i++)f[i]=(f[i-1]*f[i-1])%k;//递推求值，具体见解析
    printf("%lld^%lld mod %lld=%lld",b,p,k,ksm(p));
    return 0;
}
```

---

## 作者：cjoier_zouzhen1211 (赞：1)

本题主要的难点在于数据规模很大(b,p都是长整型数),对于b^p显然不能死算,那样的话时间复杂度和编程复杂度都很大.

下面先介绍以下原理:a\*b%k=(a%k)\*(b%k)%k.显然有了这个原理,就可以八较大的幂分解成较小的幂,因而免去高精度计算等复杂过程.那么怎样分解最有效呢?显然对于任何一个自然数p,有p=2\*p/2+p%2,如19=2\*19/2+19%2=2\*9+1,利用上述原理就可以把b的19次方除以k的余数转换为求b的9次方除以k的余数,即b^19=b^(2\*9+1)=b\*b^9\*b^9,再进一步分解下去就不难求得整个问题的解.

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;
int b,p,k;
int f(int);//利用分治求b^p%k

int main(){
    scanf("%d%d%d",&b,&p,&k);//输入三个数
    int temp=b;//将b的值备份
    b%=k;//防止b太大
    printf("%d^%d mod %d=%d\n",temp,p,k,f(p));//输出
    return 0;
}

int f(int p){
    if(p==0){//b^0%k=1
        return 1;
    }
    int tmp=f(p/2)%k;
    tmp=(tmp*tmp)%k;//b^p%k=(b^(p/2))^2%k
    if(p%2==1){
        tmp=(tmp*b)%k;//如果p为奇数,则b^p%k=((b^(p/2))^2)*b%k;
    }
    return tmp;
}
```

---

## 作者：Npse_D (赞：1)

这题需要注意写快速幂，快速幂四种标程都在百度百科有，快速幂思想就是免去了多余的二转十再十转二，其实这是一个很费时间的过程。

注意a\*b%k=(a%k\*b%k)%k,有这个等式支持，我们可以把所有乘法运算都%k，这样就不会爆longlong的空间导致进位丢失，变成一个别的答案导致W掉。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long int b,p,k,s;
long long int pow(long long int a,long long int c){
    long long int r=1,base=a;
    while(c){
        if(c&1)r=r*base%k;
        base=base%k*base%k;
        c>>=1;
    }
    return r;
}
int main(){
    cin>>b>>p>>k;
    s=pow(b,p)%k;
    cout<<b<<"^"<<p<<" mod "<<k<<"="<<s;
}
//我尝试写题解，第一次，其实这题没啥好解的……
```

---

## 作者：The_Key (赞：1)

题目已经说明了要使用快速幂，当然这道题是一个模板题。

例如 实际上A^7=A^1\*A^2\*A^4这样每次计算乘法乘的因子都是递增的，而且还是指数递增，还有这些因子是可以递推产生的就是可以利用上次的计算每次平方就可以了，这中其实是使用的二进制的思想，因为任意一个数都可以，表示成二进制，故 A^N以定可以写成A^(一个二进制数如101010)=A^(100000)\*A^(00000)\*A(1000)\*A^(000)\*A^(10)\*A^(0)=A^(2^5)\*A^(2^3)\*A^(2^1)

下面给出的代码就是应用的这种思想并且这个算法是log2(n)(表示以2为底n的对数) 的复杂度，还有一个系数，大约是2 实际上计算次数就是2\*log2(n) 而普通的连乘计算的复杂度是n 乘法计算次数是n-1

这是代码：

```cpp
#include<iostream>
using namespace std;
long long b,k,p;//long long型的变量
long long work(long long a,long long b,long long c)//快速幂函数
{
    long long tt=a,ans=1;
    while(b)
    {
        if(b%2) ans=tt*ans%c;//如果是奇数就乘上外带每步取模
        tt=tt*tt%c;//做平方运算加每步取模
        b>>=1;//此处用右移而不是  /2  因为右移快一些
    }
    return ans%c;
}
int main()
{
    cin>>b>>k>>p;
    cout<<b<<"^"<<k<<" mod "<<p<<"="<<work(b,k,p);//苛刻的输出要求，注意  mod  前后的空格（刚开始被坑了TAT）
    return 0;
}//本蒟蒻代码不精，大神勿喷
```

---

## 作者：laowantong (赞：1)

看了题解，绝大多数都是快速幂。我用的是周期法，原来只有pascal代码，我贴个c++的





```cpp
#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <set>
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <queue>
#include <stack>
#include <iomanip>
#include <fstream>
#include <cstdio>
using namespace std;
int main()
{
    // 1226
    long long base, p, res;
    int k;
    cin >> base >> p >> k;
    long long b1 = base % k;
    vector<int> v;
    v.push_back(b1);
    long long b = (b1 * b1) % k;
    while(v.size() < p && b != v[0])
    {
        v.push_back(b);
        b = (b1 * b) % k;
    }
    if (v.size() >= p)
        res = v[p-1];
    else
    {
        int temp = p % v.size();
        temp = temp - 1;
        if (temp < 0)
            temp = temp + v.size();
        res = v[temp];
    }
    cout << base << '^' << p << " mod " << k << "=" << res << endl;
    return 0;
}

```

---

## 作者：Mr_QwQ (赞：1)

在无数次的WA、CE、TLE之后，我终于AC了！！！

首先想到的是虾米？顺序乘？

呵呵，TLE妥妥的……也不看一下P的范围，MAXlongint啊……

这种幂很大的乘方让你想起了啥？对，快速幂！

代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
long long ipow(long long a,long long b,long long mod)
{
    if(b==0)return 1;
    if(b%2)return (ipow(a,b/2,mod)%mod)*(ipow(a,b/2,mod)%mod)*a%mod;
    else return (ipow(a,b/2,mod)%mod)*(ipow(a,b/2,mod)%mod)%mod;
}
int main()
{
    long long b,p,k;
    cin>>b>>p>>k;
    int m=b%k;
    int r=ipow(m,p,k);
    printf("%d^%d mod %d=%d",b,p,k,r);
    return 0;
}
```
然而依然T了两个点……
问题何在？注意ipow函数的这个代码段：

if(b%2)return (ipow(a,b/2,mod)%mod)\*(ipow(a,b/2,mod)%mod)\*a%mod;

else return (ipow(a,b/2,mod)%mod)\*(ipow(a,b/2,mod)%mod)%mod;

问题就在这！

这里，ipow(a,b/2,mod)%mod被计算了两次！所以，还是会T掉！

那么该怎么办呢？

直接把它存在一个变量里呗！

更正后代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
long long ipow(long long a,long long b,long long mod)
{
    if(b==0)return 1;
    long long v=ipow(a,b/2,mod)%mod;
    if(b%2)return v*v%mod*a%mod;
    else return v*v%mod;
}
int main()
{
    long long b,p,k;
    cin>>b>>p>>k;
    int m=b%k;
    int r=ipow(m,p,k);
    printf("%d^%d mod %d=%d",b,p,k,r);
    return 0;
}
这下终于AC了。
```

---

## 作者：hfyzw (赞：1)

快速幂，我觉得用递归方便些，代码如下：

```cpp
var n,m,k:longint;
function p(n,m:longint):longint;  //求n^m mod k
var t:longint;
begin
  if m=0 then exit(1);
  t:=p(n,m div 2)mod k;
  p:=t*t mod k;
  if m mod 2=1 then p:=p*n mod k;
end;
begin
  read(n,m,k);
  writeln(n,'^',m,' mod ',k,'=',p(n,m));
end.
```

---

## 作者：lightningboosLXY (赞：1)

赤裸裸的快速幂（看题目就知道鸟），不明白你就百度一下。。。直接粘代码


```cpp
var a,b,n:int64;
function f(a,b,n:int64):int64;
var t,y:int64;
begin
  t:=1;
  y:=a;
  while b<>0 do
    begin
      if (b and 1)=1 then t:=t*y mod n;
      y:=y*y mod n;
      b:=b shr 1;
    end;
  exit(t);
end;
begin
  read(a,b,n);
  write(a,'^',b,' mod ',n,'=',f(a,b,n));
end.
```

---

## 作者：yyy2015c01 (赞：1)

[del]不会请查看百度百科词条“快速幂”，将源代码稍作修改[/del]

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#define lovelive long long
using namespace std;
lovelive quick_pow(lovelive b,lovelive p,lovelive k)//快速幂
{
    lovelive ans=1;//答案
    while(p)//如果p不等于0
    {
        if (p&1) ans=(ans*b)%k;//如果p转化为2进制后最后一位是1，乘进答案
        b=(b*b)%k;//原理：a^b*a^c=a^(b+c)
        p>>=1;//位运算，右移一位
    }
    return ans;//返回结果
}
int main()
{
    lovelive b,p,k;
    scanf("%lld%lld%lld",&b,&p,&k);
    printf("%lld^%lld mod %lld=%lld",b,p,k,quick_pow(b,p,k));//这个就不解释了
}

```

---

## 作者：Mayday (赞：1)

裸快速幂。。。不会的请自行百度

```cpp

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#define ll long long
using namespace std;
int  pow(ll a,ll b,ll c)
 {
      ll ans=1;
      while(b!=0)
     {
        if(b&1)
         ans=(ans*a)%c;
         a=(a*a)%c;
         b>>=1;
     }
     return ans;
 }
 int main()
 {
     ll b,p,k,ans;
     cin>>b>>p>>k;
     cout<<b<<'^'<<p<<" mod "<<k<<'='<<pow(b,p,k);
     return 0;
 }
<hr>
基础知识掌握是很重要的

```

---

## 作者：S_Gloria (赞：0)


看到快速幂又想到了机房的痛苦回忆...

较为正确的做法只能看着代码理解...

无奈之下自己手写了递归..

### 那就先上递归：
```cpp
#include<iostream>
#define ll long long
using namespace std;
ll k,b,p,m;
int f(ll x,ll y)//x的y次方
{
    if(y==1)return x;//**key1**
    if(y==0)return 1;
    if(y%2==0) return (f(x*x%k,y/2))%k;**//key2**
    else return (x*f(x*x%k,y/2))%k;
}
int main()
{
    cin>>b>>p>>k;//b的p次方取模k
    m=b%k;
    cout<<b<<"^"<<p<<" mod "<<k<<"="<<f(m,p)%k;
}
```
#### 重点解释：
**首先**递归肯定要用到二分，不然毋庸置疑的tle；

**其次**记得随时取模，不然容易爆long long；

**最后**函数中的两个参数很容易理解，x的y次方，不断二分指数；

##### key1：
y每次整除2最后一定只有两种情况，一种最后等于0，一种最后等于1，当y=1时，也就是指数为1时返回其本身，当y=0时，任意非零数的零次幂等于1；
#### key2：
~~（真的是在这里被坑了好多次..）~~
当y%2为偶数时容易理解，直接指数除以2，x倍增就可以了；但y%2==1呢，返回的值可不是f(x*x*m,y/2)，而应该把一个x放在f外，这里不展开叙述，可以拿4^3做例子自己手动推算一下。

其实自认为递归还是很容易理解的。

### 接下来是~~我回避了半年的~~正解：

#### 先上代码

```cpp
#include<iostream>
#define ll long long
using namespace std;
int main()
{
    ll a,b,k;
    cin>>a>>b>>k;
    cout<<a<<"^"<<b<<" mod "<<k<<"=";
    ll base=a,ans=1;
    while(b>0)
    {
        if(b&1==1)ans=(ans*base)%k;
        base=(base*base)%k;
        b>>=1;
    }
    cout<<ans%k;
}

```

先来举个例子，一个数的11次方：
指数11在二进制下为（1011），11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为
![](https://cdn.luogu.com.cn/upload/pic/69717.png)

然后就可以计算啦。

（f2较为简洁，毕竟楼上dalao已经讲得清楚明了，就不做解释了。）


---


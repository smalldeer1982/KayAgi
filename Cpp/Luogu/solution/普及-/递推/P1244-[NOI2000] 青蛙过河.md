# [NOI2000] 青蛙过河

## 题目描述

**大小各不相同**的一队青蛙站在河左岸的石墩（记为 A）上，要过到对岸的石墩（记为 D）上去。河心有几片荷叶（分别记为 $Y_1 \dots Y_m$）和几个石墩（分别记为 $S_1\dots S_n$）。图示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)

青蛙的站队和移动方法规则如下：

- 每只青蛙只能站在荷叶、石墩，或者**仅比它大一号**的青蛙背上（统称为合法的落脚点）；
- 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；
- 青蛙允许从左岸 A 直接跳到河心的石墩、荷叶和右岸的石墩 D 上，允许从河心的石墩和荷叶跳到右岸的石墩 D 上；
- 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；
- 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；
- 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则 1 落在比它大一号的青蛙的背上。
- 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。
- 每一步只能移动一只青蛙，并且移动后需要满足站队规则；
- 在一开始的时候，青蛙均站在 A 上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则 6 站在比其大一号的青蛙的背上。

青蛙希望最终能够全部移动到 D 上，并完成站队。

设河心有 $m$ 片荷叶和 $n$ 个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从 A 过到 D。

你的任务是对于给出的 $n,m$，计算并输出最多能有多少只青蛙可以根据以上规则顺利过河。

## 说明/提示

$n \leq 20$，$m \leq 10^3$。

## 样例 #1

### 输入

```
1 1
```

### 输出

```
4
```

# 题解

## 作者：深海鱼的眼泪 (赞：345)

必须承认一开始看了很久才看懂题目哇QAQ

原来A和B也是石墩，青蛙也要按大小排不能一个一个跳过去哇QAQ

既然如此我们用 f[h][k] 表示 h 个石墩 k 片荷叶时最多的青蛙数

显然 f[0][k]=k+1

h=1时，让尽可能多的青蛙跳到D区石墩上（f[0][k]），再让尽可能多的青蛙跳到B石墩上（f[0][k]），最后让D区石墩上的青蛙跳到B上，所以 f[1][k]= f[0][k] + f[0][k]。

h=2时，让尽可能多的青蛙跳到D区的第一个石墩上（f[1][k]），再让尽可能多的青蛙跳到D区的第二个石墩上（f[0][k]），再让尽可能多的青蛙跳到B石墩上（f[0][k]），再让D区第二个石墩上的青蛙跳到B石墩上，最后让D区第一个石墩上的青蛙跳到B上，所以 f[2][k]=f[1][k]+ f[0][k] + f[0][k]。

以此类推。f[h][k]=f[h-1][k]+f[h-2][k]+…+f[1][k]+f[0][k]+f[0][k]

由于青蛙跳到D区石墩上和从D区跳到B上环境是一样的（即空石墩的数量是一样的），所以不用担心青蛙跳不到B上啦。

得到递推公式之后，让我们再来看一看。

f[1][k]= f[0][k] + f[0][k]=2\*(k+1)

f[2][k]=f[1][k]+ f[0][k] + f[0][k] =f[1][k]+f[1][k]=2\*2\*(k+1)

f[3][k]=f[2][k]+ f[1][k]+ f[0][k] + f[0][k]=f[2][k]+f[2][k]=2\*2\*2\*(k+1)

…
f[h][k]=2\*f[h-1][k]=(2^h)\*(k+1)

于是我们得到了通项公式f[h][k] =(2^h)\*(k+1)

下面是代码：




```cpp
#include <iostream>
using namespace std;
int main(){
    int h,k;
    cin>>h>>k;
    cout<<(k+1)*(1<<h);
    return 0;
}
```
位运算呢是出于省(zhuang)时(bi)的考虑。
还有就是题目中没有给出数据范围，原题中应该是 h<20 , k<1000 来着，所以不用 long long更不用高精度啦。


---

## 作者：wucstdio (赞：97)

这道题还是比较坑爹的……

首先，青蛙只能往前跳，不能往后跳，而且只能12345这样排下去，所以要想使最多的青蛙到达对岸，只需使编号最大的青蛙首先跳到对岸（否则编号更大的青蛙就跳不过去了）。

然后，要想使编号最大的青蛙首先跳到对岸，只需让河面上承载最多的青蛙。而荷叶上只能承载一只青蛙，所以需要让青蛙尽可能多地叠到石墩上。

接下来便是核心内容：(f[i]表示当有k个荷叶，i个石墩时过河青蛙的最大数量)

1、若有k个荷叶，没有石墩，则最多有k+1个青蛙。所以f[0]=k+1（不需要解释了吧）；

2、若有k个荷叶，1个石墩，则只需要使石墩上承载最多的青蛙。进一步分析，我们只需要将石墩当做对岸，这样就变成1的情况了。所以f[1]=f[0]+k+1；

3、若有k个荷叶，2个石墩，则需要先让石墩1作为对岸，叠完后再让石墩2作为对岸。所以f[2]=f[1]+f[0]+k+1；

继续往下推理，得到状态转移方程：f[h]=f[0]+f[1]+f[2]+……+f[h-1]+k+1;

下面是代码：

```cpp
#include<cstdio>
using namespace std;
int h,k,f[20000];
int main()
{
    scanf("%d%d",&h,&k);
    f[0]=k+1;//初始化
        int t=f[0]+k+1;//设置变量t避免重复相加
        for(int i=1;i<=h;i++)
        {
                f[i]=t;
                t+=f[i];
        }
        printf("%d\n",f[h]);
        return 0;
}

```

---

## 作者：Linune_Gump (赞：43)

# P1244 青蛙过河 题解

## 对题目的解读
这题难度其实并不大，真正的代码很短，只是需要正确的解读。

~~我翻阅了很多题解，发现各位奆佬不屑于解读题目，于是，有了这篇题解~~

假设dp[i][j]表示i片荷叶j片石墩能通过的青蛙数。

则原题中有这样几个关键点：

1. 石墩可以容纳很多青蛙，但是编号必须从小到大；荷叶只能容纳一只青蛙。换而言之，荷叶只是容纳青蛙，保证青蛙能从小到大的一个载体。荷叶的个数和青蛙的个数决定能有青蛙停留的个数，石墩是青蛙的中转站。
2. 题目中青蛙有无数只，不需要考虑青蛙是否足够。也就是说如果荷叶有k片，青蛙直接从出发点去终止点，则有*k*只青蛙可以站在荷叶上，还有一只可以站在青蛙出发的A石墩，共有*k+1*只，（即*dp[0][k]=k+1*）
3. 假设在出发点和终止点中间有一个石墩*C*（即原题中说的*h=1*，也就是dp[1][k]记录的结果）时，青蛙就可以在C点转乘，相当于求蛙从A到C的最多个数，也就是中间没有石墩，k片荷叶的情况，即*dp[0][k]*；当然，一部分青蛙还可以直接转移到终止点，也是dp[0][k]的情况。所以*dp[1][k]=dp[0][k]+dp[0][k]=2 * dp[0][k]*
4. 假设有两个石墩C,D(即原题中说的h=2，也就是dp[2][k]记录的结果)，就比只有一个C点的情况(dp[1][k])多了从C到D，从D到终止点（dp[0][k]+dp[0][k]）两种情况。也就是说dp[2][k]=dp[0][k] * 2+dp[1][k]=dp[0][k] * 2 +dp[0][k] * 2 = 2 * 2 * dp[0][k]
5. 继续探究...

从中不难发现规律：dp[h][k] = dp[0][k] * 2 ^ h = (k+1)* 2 ^ h (参考第一点)

也就是说，答案最终与dp数组无关。

不难写出如下的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int h,k;
    scanf("%d%d",&h,&k);
    long long ans=0;
    ans=(k+1)*(1<<h);
    printf("%lld\n",ans);
    return 0;
} 
```

需要关注一下的有一下几点：

1. 此题的数据比较大，答案需要long long
2. 位运算*1<<n*表示*2^n*

本蒟蒻的代码和第一篇题解的代码很相似，只是想多解释一下题目的一些细节。

---
## 祝各位好运！

---

## 作者：freshwater (赞：29)

设f[i]表示河心i个石礅可承载的最大青蛙数(1<=i<=n)

左岸为A,右岸为D

```cpp
(1) 0个石礅,f[0]=0
(2) 1个石礅,f[1]=m+1
(3) 2个石礅s1,s2，f[2]=?
(1)A上m+1只青蛙s1    (2) A上m+1只青蛙 s2 ,
(3)s1上的m+1青蛙 s2  (4) A上m+1只青蛙s1
```
因此，f[2]=m+1+f[1]+f[1]=3\*(m+1)
(4) 3个石礅s1,s2,s3,

      (1)A上3(m+1)只青蛙s1,s2   (2) A上m+1只青蛙 s2 ,

      (3)s1,s2上的3(m+1)青蛙 s2 (4) A上3(m+1)只青蛙s1,s2

因此，f[3]=m+1+2\*f[2]=7\*(m+1)

……
(5)  n个石礅?

     (1)A上f(n-1)只青蛙s1…sn-1      (2) A上m+1只青蛙 sn 

     (3)s1…sn-1上的f(n-1)只青蛙sn (4) A上f(n-1)只青蛙s1…sn-1

因此， f[n]=m+1+2\*f[n-1]


f(n)只青蛙移到河心的石礅后，按照站队和移动规则，首先应该将A上的m+1只青蛙移到D

设g(n)表示n个石礅，m片荷叶，能过河青蛙的最大值，则

     g(n)=m+1+f(n)

由于f(n)=m+1+2\*f(n-1)，可以递推求出，当然，可以求出g(n).

实际上f(n)=m+1+2\*f(n-1)也可以通过化简得出公式


```cpp
    f(0)=0
    f(1)= m+1
    f(2)= m+1+2*f(1)=(m+1)*(1+2)
    f(2)= m+1+2*f(1)=(m+1)*(1+2+22)
    f(3)= m+1+2*f(1)=(m+1)*(1+2+22+23)
```
……
f(n)=m+1+2\*f(n-1)=(m+1)\*(1+2+22+23+…+2n-1) =(m+1)\* (2n -1)

因此   g(n)=(m+1)\*2n


---

## 作者：yangyutong (赞：23)

~~蒟蒻找规律ing~~

当无石头时，能通过的青蛙数量为k+1只

之后，随着石头数量的增加，方法数ans*2

自行脑补一个二维数组。。。

就像酱紫（横为h，纵为k）

|  | **0** | **1** | **2** | **3** | …… |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **0** | 1 | 2 | 4 | 8 |……
| **1** | 2 | 4 | 8 | 16 |……
| **2** | 3 | 6 | 12 | 24 | …… |
| **3** | 4 | 8 | 16 | 32 | …… |
| …… | …… | …… | …… | …… | …… |

代码就很简单了

```
#include<iostream>
using namespace std;
int h, k, ans=0;
int main(){
	cin>>h>>k;
	ans=k+1;
	for(int i=1; i<=h; i++){
		ans=ans*2;
	}
	cout<<ans<<endl;
}
```

---

## 作者：uhgariej (赞：14)

最开始没想出来，看了前面的几篇题解，感觉也没说到点子上(估计还是我太菜了

现在来写下这题的题解，自认为是**最通俗易懂**的啦，哈哈。

首先题目的意思是，问从A石墩到B石墩最多能过去的青蛙个数。在石墩上可以有无限个
青蛙，不过要求编号大的青蛙在下面。即汉诺塔的排列方式，小的重叠在大的上面。
在A石墩和B石墩之间有h个石墩和k个荷叶。A石墩和B石墩和中间的h个石墩都是一样的，都要满足小的编号重叠在大的上面。

---
**分析**：

A石墩和B石墩，中间只有k个荷叶时，那么可以有k+1个青蛙，跳过去。记为状态S，在这个状态下可以通过的青蛙数记为y，即y等于k+1.

S和y，是为了下面叙述方便。

大家在脑子里想，现在增加一个石墩，记为new。

我们把石墩new看成石墩B，那么我们可以重复上一个状态S，先把y只青蛙运到石墩new上，这时我们又回到了上一个状态S(不看石墩new)，这时又有y只青蛙可以运送到石墩B。最后我们再把石墩new上的青蛙运送到石墩B上(这时可以把石墩new，看成石墩A)。

所以增加一个石墩有，y + y 等于 2 * y个青蛙可以运送过去。y是上一个状态能运送的青蛙数。

接着我们再增加一个石墩，...其实就是重复上一个状态。

这其实就是动态规划里，这个状态由上一个状态转移过来，上一个状态由上上一个状态转移过来，...

我们可以把这种状态转移方式，叫递归或者递推，它俩本质是没有任何区别的。

---

参考代码：代码虽短，但是思考过程还是挺有意思的0..0

```cpp
#include <bits/stdc++.h>

int h, k;

int main() {
    scanf("%d %d", &h, &k);
    long long ans = k + 1;
    for(int i = 1; i <= h; ++i) {
        ans = ans * 2;
    }
    printf("%lld\n", ans);
    return 0;
}

```





---

## 作者：qmieanng (赞：5)

# 第四篇题解
## 浅谈题意
讲实话，这道题看题目的时间，比我写题目的时间还长；
考虑到部分同学可能会有和我一样的困惑，先在这里解释下题目的意思；
题目意思是每个青蛙的大小不同，而青蛙在石墩上必须使大青蛙在最下面；
而荷叶最多只能放一只青蛙，求最多有多少青蛙可以通过；
## 题解
首先假如只有荷叶，有m个荷叶，那么这m个荷叶最多可以过m+1个青蛙（应为每个荷叶最多放1个青蛙）；
而每多一个石墩，可以过的青蛙数会变成原来的2倍，因为每个石墩可以放多只青蛙，吧原来没有这个石墩时的青蛙数转到这个石墩上，剩下便能在放一次，若有n个石墩
则可过青蛙数量为sum=（m+1）*pow（2，n）；
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
} //快读 
int main()
{
	int n,m;
	n=read();
	m=read();
	int sum=m+1;//这道题数据规模不大int就可以过 
	cout<<sum*pow(2,n); 
	return 0;
}
```
这道题其实与汉诺塔问题挺像的

---

## 作者：baolimo (赞：5)

这题的意思给的挺模糊,需要一定的理解能力.


题目想必已知,我就提几点可能会搞错的点吧.


1.题目说了青蛙可以：A→B(表示可以从A跳到B，下同)，A→C，A→D，C→B，D→B，D→C，C→D；但却不能跳到A,B上再跳回来.所以不可以脑补成汉内塔那种跳法.


2.青蛙只能跳到比它大1号的青蛙上面,而不是比他大的青蛙就行.所以不可以脑补成汉内塔.


3.可以把一套操作看成一个单位元.我对一套操作的定义如下:


当k确定而h=0时,没有中间柱子,蛤蛤们只能通过荷叶来移动.每片荷叶只能有1位青蛙.所以要求最大的通过数目就必须把所有的荷叶用上.


由于他们必须按顺序从小到大从上到下垒起来.所以这种情况下,最大通过数目为k+1.


如k=4时

1
2
3
4
5
A          \_  \_  \_  \_          B


从上到下跳到荷叶上:


5          1  2  3  4

A          \_  \_  \_  \_          B


最后一位直接到B

1  2  3  4         5

A          \_  \_  \_  \_          B


然后只能4先跳到B上

4
1  2  3            5

A          \_  \_  \_  \_         B


直至完成全部操作.这个过程就是通过两个柱子和k片荷叶完成的一个单位操作 .之后为了简化问题,我们以单位操作为最小单位讨论问题.



我们把单位元编号,若荷叶有k片,则一个单位最多移动k+1只青蛙.我们令第1到k+1只为整体D1,而k+2到2k+2为D2,以此类推.


假设情况柱子有1根,则易得最多通过2个单位青蛙.(D1-->柱1,D2-->B,D1-->B)


有两根时,我们模拟过程:D1-->柱1,D2-->柱2,这个时候第一这个整体可以满足条件跳到D2头上,D1-->柱2,之后,柱1空着,加入D3,D3-->柱1,


但此时D2被压在下面,所以就没有骚操作可以再进行了,只能加入D4直接跳到B.然后依次全部跳到B.得出结论.h=2时 通过4个单位.


当没有柱子时,显然只有一个单位通过.观察结论,得出公式:当有k荷叶,h柱时,可通过青蛙(k+1)\*2^h只.


答案就出来了,虽然代码很简单,但还是贴一下.

```cpp
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
    int i,j,m,h,k,a;
    while(cin>>h>>k)
    cout<<(k+1)*pow(2,h)<<endl;
}
希望各位在写完后可以为(k+1)*2^h只青蛙奉献出(k+1)*2^h秒,不然他们可能会非常angry.
```

---

## 作者：cys2004a (赞：3)

## 算法分析：首先考虑没有石墩的情况，设n为石墩数，m为荷叶数，f[n][m]表示有n个石墩，m个荷叶时能跳过去得最多的青蛙数。
## 显然，f[0][0]=1,f[0][1]=2,f[0][2]=3……可以归纳出f[0][y]=y+1。
## f[n][m]是我们算出的子问题。在它的基础上，我们可以再增加一个石墩。也就是现在我们算f[n+1][m]。他就应该用到之前的子问题。我们把f[n][m]看成左岸，新增石墩看成右岸，把新增石墩看成左岸，子问题看成右岸，所以可以过的青蛙数翻倍。故有方程：f[n+1][m]=f[n][m]*2; 因为f[0][m]=m+1,所以我们就可以写成这样：
```
#include<iostream>
using namespace std;
int main()
{
	int m,n;
	cin>>n>>m;
	m++;
	for(int i=1;i<=n;i++)
	{
		m*=2;
	}
	cout<<m;
} 
```
## C++源码，详见《算法竞赛宝典》第二册妖兽特工队。

---

## 作者：l1360300734 (赞：3)

/\*
乍一看，这个题没有思路，其实很简单，分别讨论h与k不同数量的请况，就能的到公式s=2^h\*(k+1)

楼下已经说的很详细了，这里就不多说了，附上c++代码；

\*/
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int h,k;
    cin>>h>>k;//输入石墩和荷叶的个数；
    cout<<pow(2,h)*(k+1);//利用公式求解；
}
//s=2^h*(k+1)
```

---

## 作者：aRenBigFather (赞：3)

```
	定义 ans[x] 是石墩数为x时的最终答案 
	1.h = 0,k = k
	  让1 ~ (n-1） 只青蛙站在荷叶上，第n只青蛙跳对面，在荷叶上的青蛙
	  开始叠罗汉
	  ∴ ans[0] = k+1 
	2.h = 1,k = k
	  把石墩当对岸，荷叶上还可以立k只青蛙，起始点可以立一只青蛙
	  ∴ ans[1] = ans[0] + k + 1
	3.(推广)h = h,k = k
	  ∴ ans[h] = ans[0] + ans[1] + ... + ans[h-1] + k + 1 
```
```cpp
#include <bits/stdc++.h>
using namespace std;
int h,k;
const int maxn = 2000;
int ans[maxn];
int presum[maxn];
int main(){
	freopen("1244.txt","r",stdin);
	cin >> h >> k;
	/*
		定义 ans[x] 是石墩数为x时的最终答案 
		1.h = 0,k = k
		  让1 ~ (n-1） 只青蛙站在荷叶上，第n只青蛙跳对面，在荷叶上的青蛙
		  开始叠罗汉
		  ∴ ans[0] = k+1 
		2.h = 1,k = k
		  把石墩当对岸，荷叶上还可以立k只青蛙，起始点可以立一只青蛙
		  ∴ ans[1] = ans[0] + k + 1
		3.(推广)h = h,k = k
		  ∴ ans[h] = ans[0] + ans[1] + ... + ans[h-1] + k + 1 
	*/
	ans[0] = k + 1;
	presum[0] = k + 1;
	for(int i=1;i<=h;i++){
		ans[i] = presum[i-1] + k + 1; 
		presum[i] = presum[i-1] + ans[i];
	}
	cout << ans[h];
	return 0;
}
```

---

## 作者：漩涡鸣人689 (赞：2)

非常简单的一道题。这题可以看成是个简单的递推。

由于跳到B石墩后不能再跳，且小青蛙必须在大青蛙上面，所以第一只跳到B石墩的青蛙一定是编号最大的。

假设D区没有石墩，易知最多有(k+1)只青蛙过河。

假设D区有x个石墩时，最多有y只青蛙。那么当有(x+1)个石墩时，原本跳到B石墩的y只青蛙可以跳到多的这个石墩（设它为E石墩）上。那么E石墩被占用后，又回到了只有x个石墩的问题。这时，有y只青蛙可以到达B石墩。然后，我们再把E石墩看成A石墩，那么这y只青蛙也能过河。所以，最多共有2y只青蛙过河。

递推关系式为：
| | |
| :----------: | :----------: |
| 当i≥1时 | a[i]=a[i-1]×2 |
| 当i=0时 | a[i]=k+1 |
代码如下：
```cpp
#include <cstdlib>
#include <iostream>

using namespace std;

int main()
{
	long long h, k, i ;
	cin >> h >> k ;
	k++ ;
	for(i=1;i<=h;i++)
		k = k * 2 ;
	cout << k ;
	return 0 ;
}

```
如题解有不足之处请各位见谅。

---

## 作者：引领天下 (赞：2)

其实此题远不用那么麻烦

思路楼下已经说过,我这里就是提供一些写得更短的代码

Pascal

```pas
var
h,k:integer;
begin
read(h,k);
writeln(1 shl h*(k+1));
end.
```

C++

```cpp
#include<cstdio>
using namespace std;
int h,k;
int main(){
    scanf("%d%d",&h,&k);
    int t=2*k+2;
    for(int i=1;i<=h;i++)t*=2;
    printf("%d",t/2);
    return 0;
}
```

---

## 作者：吴国铨 (赞：1)

        f(0,0)=1

    f(0,k)=k+1;        （如k=3时，有4只青蛙可以过河）

    f(1,k)=2(k+1);        （递推思想）

……
依此类推：f(2,k)=(2\*(k+1))\*2=22(k+1);

……



```cpp
program exz;
var h,k:longint;
    ans:int64;
    i,j:integer;
function f(a,b,n:int64):int64;
var t,y:int64;
begin
  t:=1; y:=a;
  while b<>0 do
  begin
    if(b and 1)=1 then t:=t*y mod n;
    y:=y*y mod n;
    b:=b shr 1;
  end;
  exit(t);
end;
begin
  readln(h,k);
  ans:=f(2,h)*(k+1);
  writeln(ans);
end.
```

---

## 作者：chenyisan (赞：1)

首先，对于递推的题目，我们一般是从最简单的入手。


为了方便起见，下文中的s表示青蛙数，h是石墩数，k为荷叶数。


当k=0时：

若h=0，则s=1

若h=1，则s=2

若h=2，则s=4

若h=3呢？s是否为8呢

首先，我们对青蛙进行编号，为1,2,3,4,5,6,7,8，则首先将1~4号青蛙移到第一个石墩上，再将5~8号青蛙利用2个石墩移到目标石墩上，最后就能将1~4号移到目标石墩上。


若k不等于0呢？


其实也十分简单，首先将青蛙看为若干组，每组有k+1个青蛙。每次就只要像k=0一样移动就可以了。为什么呢？因为在移动一组青蛙从x1到x2的时候，首先将k只青蛙统统移动到荷叶上，这时荷叶为满，使得青蛙数量为max。再将最后一只青蛙移过去，最后将每只青蛙再移过去即可。因此算法成立。


所以，通项公式为：s=2^h\*(k+1)包括k=0的情况

2的幂用shl完成


标程：

```delphi
var ans,h,k:longint;
begin
  readln(h,k);
  ans:=1 shl h\*(k+1);
  writeln(ans);
end.

---

## 作者：tianjh (赞：1)

此题是汉诺塔的改进版，把荷叶看成一个整体。

当n=0时，河里只有m个荷叶，每片叶上只能有1只青蛙，再加上从右岸可以直接跳到左岸上的一只，所以共有m+1只青蛙，即F[0,m]=m+1，所以F[n,m]=(m+1)*2^n。

代码如下所示：
```cpp
#include<iostream>
using namespace std;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	m++;
	for(int i=1;i<=n;i++)
	{
		m*=2;
	}
	printf("%d\n",m);
	return 0;
}

```

---

## 作者：war1111 (赞：0)

P1244 青蛙过河

NOI2000

主要思想：

数学归纳法 递推 压位高精度  化归

理解能力和找规律的能力

题意再述：

1.青蛙从上到下必须连续递增或者下面是石墩

而不能是

1        1

2     3

3     4

而且每时每刻都要满足这个条件

2.左岸和右岸都是石堆

公式推导过程：


```cpp
k=0
h=0 s=1
h=1 s=2      _  _  _
h=2 s=?
```
当h=1时，共有三个石墩，空石墩有2个，我们可以转移2个青蛙到任意石墩
当h=2时，总石墩数比原来多1，空石墩有3个，我们可以先利用3个空石墩把上面2个小青蛙（1号和2号）移到一个非右岸的一个空石墩上，现在共有2个空石墩，由h=1时

（空石墩有2个，我们可以转移2个青蛙到任意石墩）

，我把下面两个大青蛙，移到右岸，再把，小青蛙移到右岸。完成。


假设当h=x,k=0时，空石墩有x+1个，最多能转移的青蛙数为(1<<x)

当h=x+1时，k=0，空石墩有x+2个，我们可以利用x+1个空石墩把(1<<x)个青蛙移到一个非右岸的一个空石墩上，现在有空石墩h+1个，我们用这x+1个空石墩将下面的(1<<x)个大青蛙移到右岸，现在还是有空石墩x+1个，再用这些把刚才的(1<<x)个小青蛙移到右岸。移动的青蛙总数是h=x时的两倍，故为

（1<<(x+1)）;

所以当k=0时，转移的青蛙数为(1<<h)


要是k>0呢？


我们知道，当k=0时，转移的青蛙数为(1<<h)，单个青蛙可以直接移动，我们把（k+1）只青蛙压成一只青蛙，因为(k+1)只青蛙可以像一只青蛙一样直接移动，why？先把k只青蛙放到k个荷叶上，再把最下面的那只移到目标位置，再把荷叶上的k只青蛙移到最下面的那只上就可以不借助石墩实现(k+1)只青蛙的直接移动。

原来当k=0时，转移的青蛙数为(1<<h)，现在把（k+1）只青蛙压成一只青蛙，所以总数为：


(1<<h)\*(k+1)

结束了？？？

完美了？？？


但是这样只是证明了这种解的存在性，并没有证明最优性。有想法的和我继续讨论。






---


# 旅行

## 题目描述

你要进行一个行程为 $7000$ 千米的旅行，现在沿途有些汽车旅馆，为了安全起见，每天晚上都不开车，住在汽车旅馆，你手里现在已经有一个旅馆列表，用离起点的距离来标识，如下：

- $[0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000]$。

但在出发之前可能还要增加一些旅馆。

现在旅行社为了节约成本，要求每天至少行驶 $A$ 公里，国家旅行社为了安全起见，要求每天最多只能行驶 $B$ 公里。

你想知道一共有多少种旅行方案。

## 样例 #1

### 输入

```
500
1500
0
```

### 输出

```
64
```

# 题解

## 作者：ZERORUSH (赞：151)

# 被机房某位大佬拉了过来点题解的赞，然后就开始做这道题。。。

思路：将所有旅馆的位置都塞进数组里然后不撞南墙不回头

解释都在代码注释里

```cpp
#include<iostream>
using namespace std;
int a,b,n,ans,x[40]={0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000},book[40];//初始化，没有book会死循环 
void dfs(int km)//深搜就完事了 
{
	for(int i=1;i<=n+13;i++)
	{
		if(x[i]>=km+a&&x[i]<=km+b&&book[i]==0)//在最短距离和最长距离之间就行了 
		{
			if(x[i]==7000)//到达目的地就+1； 
			{
				ans++;
				return;
			}
			book[i]=1;
			dfs(x[i]);
			book[i]=0;
		}
		else if(km+a>=7000)//最短距离可以到达目的地就+1 
		{
			ans++;
			return;
		}
	}
	return;
}
int main()//简单的主函数 
{
	cin>>a>>b>>n;
	for(int i=13;i<=n+12;i++) cin>>x[i];
	dfs(0);//从0开始 
	cout<<ans;
	return 0;
}
```

最后，我想说，我没有点赞（滑稽保命）

~~蒟蒻题解，不喜勿喷~~

更新：2018-12-25：dfs函数中的i<=n+14中的14改为13，感谢[编程受害者](https://www.luogu.org/space/show?uid=157433)
的指正

2019-2-20：main函数中的for(int i=13；i<=n+12；i++)改为for(int i=14;i<=n+13;i++),[苍糜](https://www.luogu.org/space/show?uid=160637)
的指正（已证明会影响AC）

---

## 作者：翼德天尊 (赞：69)

**一道普及-的题，真心不难**

废话不多说，现在就正式开始吧！


------------


### STEP 1 本蒟蒻的方法介绍

```
1.一个数组储存所有旅馆，初始化时先存下前面14个旅馆。
2.输入新添加旅馆后，将所有旅馆排序，方便日后比较。
3.根据斐波那契数列，如果可以从A点走到B点，那么A点的总方案数应该加上B点的方案数。
4.循环进行3操作即可（但B点只需要是A点前面的点）。
```
**是不是很简单呢？**


------------


### STEP 2 AC代码及完整注释
```
#include<bits/stdc++.h>//超级万能头
using namespace std;
int a,b,n,ans[40],r[40]={0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000};
//旅馆初始化 
int main(){
	scanf("%d %d %d",&a,&b,&n);
	for (int i=14;i<14+n;i++) cin>>r[i];//输入 
	sort(r,r+14+n);//排序 
	ans[0]=1; //起始点默认一套方案 
	for (int i=1;i<14+n;i++){//枚举所有点 
		for (int j=0;j<i;j++){//枚举这个点之前的点 
			if (r[i]-r[j]>=a&&r[i]-r[j]<=b){//如果这两个点之间的距离符合要求 
				ans[i]+=ans[j];//这个点可以获得前面那个点的所有可能 
			}
		}
	}
	cout<<ans[13+n]<<endl;//输出到终点时的所有可能 
	return 0;//好习惯不可忘
}
```


------------
### STEP 3 完结撒花！
看完这么详细的题解，你是否看懂了呢?

如果还有疑问，可以在评论区随时询问，我会第一时间回复哒！

如果搞懂了这道题，那就点个赞纪念一下你的进步吧！

---

## 作者：xzlhxc_ed (赞：10)

# 据说这题是DP，可是我一个暴搜就AC了呀...
~~可能这就是这题是橙题的原因了吧。~~   
看了一眼题解，貌似我的做法只有pascal语言，码一发c++题解。
# ①状态定义
说实话，看到这道题的题目我不是很理解，想了一会才发觉——

**可以把旅馆当成可以停留的地方，如果是，就可以转移至下一个状态，如果不是，就不能转移。**

当达到7000M的时候就可以```return```了，那么我们自然而然就可以想到，用现在到达的距离用作转移的状态，即可以这么定义：
```cpp
bool is_hotel[7005]={0};
int least,most,ans;
void dfs(int meter)
```
由于7000很小，我们可以用一个```is_hotel[]```数组来标记是否有旅馆（可以到达）。
# ②状态转移
 _个人认为不只有dp才能状态转移，其实搜索也有状态转移的思想。_
 
 其实就是很简单的dfs模板，这里不再赘述，尽在注释中。
 ```cpp
//输入
void dfs(int meter)
{
	//printf("meter=%d\n",meter);
    //以上是调试用语句，推荐使用
	if(meter==7000)//到达目的地，回溯
	{
		ans++;
		return;
	}
	for(int i=least;i<=most&&meter+i<=7000;i++)
    //从最小行程到最大行程开始枚举，如果超出目的地，停止枚举
	 if(ishotel[i+meter])dfs(meter+i);//如果有旅馆，转移！
}
```
本题由于相同的参数值会有不同的映射（即不同的效果），故不能采用记忆化。
# ③ AC！


---

## 作者：Rika (赞：8)

参看注释

>
```cpp
#include <iostream>
#include<algorithm>
using namespace std;
int main()
{
    int n, A, B;
    cin >>A>>B>> n;
    n += 14;                                        //加上初始的旅馆数目
    int a[34] = { 0,990,1010,1970, 2030, 2940,        //录入初始旅馆数目
```
3060 ,3930, 4060, 4970, 5030,

```cpp
                5990, 6010, 7000 };
    int rs[34] = { 0 };                                //创建用来记录方案数的数组
    for (int i = 14; i < n; i++)                    //录入新增的旅馆
        cin>>a[i];
    sort(a, a + n);                                    //排序
    rs[0] = 1;                                        //起点处方案为1
    for (int i = 1; i < n; i++)                        //从前往后处理
        for (int j = i - 1; j >= 0 && a[i] - a[j] <= B; j--) //从当前点向前寻找，符合要求就加上方案数
            if (a[i] - a[j] < A)continue;else rs[i] += rs[j];
    cout << rs[n - 1];                                //输出终点结果
    return 0;
}

```

---

## 作者：Gao_Shang (赞：7)

先看题目

题目有要求:

“现在旅行社为了节约成本，要求每天至少行驶A公里，国家旅行社为了安全起见，要求每天最多只能行驶B公里。”--摘自P1515题目描述

可以在dfs里体现出来(见代码)
```
//从第k个旅馆出发 
for(int i=k+1;i<=n;i++)
//(当日?)所走路程满足条件{A<=路程<=B} 
    if(a[i]-a[k]>=A&&a[i]-a[k]<=B/*可以走*/)
       lx(i);//去第i个旅馆
```

得用个数组把汽车旅馆存起来
```
int a[40]={0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000};
```

因为在出发之前又新增N个汽车旅馆,
所以更新下n:
```
//把新增的旅馆数和本有的旅馆数加起来(方便使用!) 
n=n+13;
```

最后按路程远近把旅馆排序
```
//头文件#include<algorithm>
sort(a,a+n+1,可加函数);
```

得完整(AC)代码:
```
#include<bits/stdc++.h>
using namespace std;
    //              已经有的旅馆列表:
int A,B,n,ans,a[40]={0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000};
void lx/*dfs*/(int k)//k:第k个旅馆 
{
	//所有旅馆都走过了[满足条件] 
	if(k==n){
		//方法+1 
		ans++;
		return;
	}
	//从第k个旅馆出发 
	for(int i=k+1;i<=n;i++)
	//(当日?)所走路程满足条件{A<=路程<=B} 
	   if(a[i]-a[k]>=A&&a[i]-a[k]<=B/*可以走*/)
	      lx(i);//去第i个旅馆
}
int main()
{
	cin>>A>>B>>n;
	//[输入]新增的旅馆(距起点)路程 
	for(int i=1;i<=n;i++)
	    cin>>a[13+i];
	//把新增的旅馆数和本有的旅馆数加起来(方便使用!) 
	n=n+13;
	//此时n代表所有旅馆数量！ 
	//将旅馆路程远近(从小到大)排序{包括起点!} 
	sort(a,a+n+1);
	//从起点出发! 
	lx(0);
	cout<<ans;
	return 0;
}
```


(完美结束)撒花!ヾ(≧▽≦*)o

---

## 作者：MakerOne (赞：4)

# 题意分析：

------------

## 题目意思是在给定的区间范围内行使公里数，中途有一个一个的旅馆能休息，问到达目的地的方案有多少种，也就是问有多少种住旅馆的方案。每个旅馆的路径都是由之前合法距离的旅馆路径总和，是一道简单递推。

------------

# 代码实现：

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int map[14+21];//存放现有的旅馆位置 
int ans[14+21];//记录到达每个旅馆的方案数 
int main()
{
    int a,b,n,i,j,k;
    scanf("%d %d %d",&a,&b,&n);
    i=0;
    map[i++] = 0;
    map[i++] = 990;
    map[i++] = 1010;
    map[i++] = 1970;
    map[i++] = 2030;
    map[i++] = 2940;
    map[i++] = 3060;
    map[i++] = 3930;
    map[i++] = 4060;
    map[i++] = 4970;
    map[i++] = 5030;
    map[i++] = 5990;
    map[i++] = 6010;
    map[i++] = 7000;
    while(n--)scanf("%d",&map[i++]);
    sort(map,map+i);//将新增的旅馆位置从小到大排序 
    ans[0] = 1;//第一个旅馆的方案数为1 
    for(j=0;j<i;j++)
    {
        for(k=0;k<j;k++)
        {
            int dis = map[j] - map[k];//获得两个旅馆间的距离 
            if(dis<=b && dis>=a)ans[j] +=ans[k];//判断是否在合法的距离内，若符合要求，累计方案数 
        }
    }
    printf("%d\n",ans[i-1]);
    return 0;
 } 
```

---

## 作者：Konjacwyw (赞：3)

这题。。。

方法应该叫做深搜吧。。。

方法：

将n个旅馆的位置读入后做最基本的深搜（深度优先搜索）。

find(i)表示旅行到距起点i km的方案总数。

显然下一天可以达到的旅馆在距起点i+A km到i+B km的开区间内。

那么直要在表示旅馆位置的数组中搜一遍，找出在该区间内的旅馆，根据这些旅馆继续搜索即可~~（我做的时候傻不拉几的排序了）~~。

下面上代码
```cpp
#include<bits/stdc++.h>
#include<algorithm>
using namespace std;
int n,a[50],aa,bb;
int find(int k)
{
	int ans=0;
	if (k==7000) return 1;
	for (int i=1;i<=n;i++)
	  if (a[i]>=k+aa&&a[i]<=k+bb) ans+=find(a[i]);
    return ans;
}
int main()
{
	cin>>aa; cin>>bb;
	a[1]=0; a[2]=990; a[3]=1010; a[4]=1970; a[5]=2030; a[6]=2940; a[7]=3060;
	a[8]=3930; a[9]=4060; a[10]=4970; a[11]=5030; a[12]=5990; a[13]=6010; a[14]=7000;
	cin>>n;
	for (int i=15;i<=14+n;i++) cin>>a[i];
	sort(a+1,a+(n+14));	n=n+14;
	cout<<find(0)<<endl;
}
```

---

## 作者：hzzx104_jzk (赞：3)

很明显的一道递推题

先把所有数据读入进来进行排序

从当前点往后搜索，只要符合的旅馆都在方案数上加上当前点的方案数（具体的看程序吧）

一下为代码，有注释



```cpp
var
  dis,ans:array[0..40]of longint;              //dis数组储存第i号旅馆距离起点的距离，ans数组储存到第i号旅馆有几种方案
  a,b,i,j,n:longint;
procedure qsort(h,l:longint);                //用快排进行数据排序
var
  i,j,m,t:longint;
begin
  m:=dis[(h+l)div 2];
  i:=h;j:=l;
  repeat
    begin
      while dis[i]<m do inc(i);
      while dis[j]>m do dec(j);
      if i<=j then
        begin
          t:=dis[i]; dis[i]:=dis[j]; dis[j]:=t;
          inc(i); dec(j);
        end;
    end;
  until i>j;
  if i<l then qsort(i,l);
  if h<j then qsort(h,j);
end;
begin
  dis[1]:=990;dis[2]:=1010;dis[3]:=1970;dis[4]:=2030;dis[5]:=2940;
  dis[6]:=3060;dis[7]:=3930;dis[8]:=4060;dis[9]:=4970;dis[10]:=5030;
  dis[11]:=5990;dis[12]:=6010;dis[13]:=7000;                                                //数据的初始化
  read(a,b,n);
  for i:=14 to n+13 do read(dis[i]);
  qsort(1,n+13);
  ans[0]:=1;
  for i:=0 to n+12 do                                                                                     //这里就是关键了。i表示当前点
    for j:=i+1 to n+13 do                                                                               //j从i号旅馆向后搜索
      begin
        if (dis[j]-dis[i]<=b)and(dis[j]-dis[i]>=a) then                                          //递推公式（我觉得有点像动归了）
          ans[j]:=ans[j]+ans[i];                                                                          //如果符合条件，将i号旅馆的方案数加进j号旅馆的方案数
        if (dis[j]-dis[i]>b)then break;    
      end;
  write(ans[n+13]);
end.
```

---

## 作者：THMITW (赞：2)

这道题我个人认为只有一句话    ~~暴力出奇迹~~

看了一下数据n只有20，完全可以用暴力来枚举所有的情况。

可是怎么来枚举呢？
## （重点，敲板凳）模版/算法：二进制穷举
```
	//双手奉上代码 
	b[n]=1;//初始化二进制数的第一位为1;
	while(b[0]==0)
	{	bool flag=0;//flag用来标记此情况是否成立 
		for(int i=1; i<=n; i++)
			if(b[i]==1) 
			{
				if(/*如果不满足条件*/)
				{
					flag=0;
					break;//标记后break; 
				}
			}
		if(/*如果满足条件，答案++*/)ans++;
		int j=n; 
		while(b[j]==1)j--;
		b[j]=1;
		for(int i=j+1; i<=n; i++)b[i]=0;
		//核心代码：模拟将一个二进制加一的过程，具体如下 
	}
	//该模板是建立在这道题之上的，可根据题目适当修改 
```
首先我们要明白二进制穷举在什么时候可以使用，二进制穷举的局限性较大，主要用于**动态规划的暴力**打法，比如01背包；二进制穷举只有在当题目要求只有**取与不取**两种状态。比如这道题，我们可以把它看成取与不取这个旅馆里的问题，二进制穷举的中心思想就是：暴力枚举所有情况，判断该情况是否成立。

再来讲一下二进制穷举的工作原理：我们先假设现在只有4个旅馆四个旅馆分别是 0 1000 3000 5000，a=3500,b=5000。处在0位置的旅馆可以不看那么到目前为止有这几种可能性：

取1000，3000，5000；

取1000，3000；
取1000，5000；
取3000，5000；

取1000；取3000；取5000；

共7种，如果把取看成1，不取看成0 ,
可以得到7种可能:

001,010,011,100,101,110,111.
这7种可能正好是二进制数0-111(2^3-1)的枚举；
而我们又可以看出一个二进制数的过程分解可以并成两步：加1，进位。但二进制只有0和1，如果为一，后面进1，进位，为0，等于一。

又可以简化成从**最后一位查找，第一个不是0的数加1，在其之后的数全部变为0**。

最后奉上完整代码
```
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=7000;
int a[55]= {0,990,1010,1970,2030,2940,
            3060,3930,4060,4970,5030,5990,6010,7000
           };
bool b[55];//b用来模拟二进制，b[i]表示二进制的第i位数
int ans;
int main()
{
	int x,y,n;
	cin>>x>>y>>n;
	n+=13;//输入 n预处理，加上原有的旅馆数
	for(int i=14; i<=n; i++)cin>>a[i];
	sort(a+1,a+n+1);
	b[n]=1;//初始化二进制数的第一位为1;
	if(y>=maxn)ans=1;//特殊情况：不用住在旅馆里，直接到目的地
	while(b[0]==0)
	{ 
		bool flag=1;
		int last=0;
		for(int i=1; i<=n; i++)
			if(b[i]==1)
			{
				if(a[i]-last<x||a[i]-last>y)
				{
					flag=0;
					break;
				}
				last=a[i];
			}
		if(flag==1&&(!(maxn-last<x||maxn-last>y)))ans++;
		/*{不解释，不懂看上面  
			ans++;
			for(int j=1; j<=n; j++)
				cout<<b[j];
			cout<<' ';
		}*/
		int j=n;
		while(b[j]==1)j--;
		b[j]=1;
		for(int i=j+1; i<=n; i++)b[i]=0;
	}
	cout<<ans;
	return 0;
}
```
本人文笔不好，有什么写的不好的尽管指出。

# 谢谢！

---

## 作者：jzy_go (赞：2)

### ~~~~本篇记录了一只蒟蒻两次WA后终于AC的血泪经历~~~~
开始做题前先分析这道题的**思路**。

#### 以样例为例，想象一下，你就是那个旅行的人。现在你从0处（0表距离，下同）出发，到达第一个汽车旅馆，有几种路径？

第二个呢？

第n个呢？

脑袋冒烟没？~~~~没有的人自行离开~~~~

接着往下想，你就会惊讶的发现自己走上了 ~~~~无算法只暴力~~~~ 枚举的不归路。

### 但如果倒过来想呢？

在A为500，B为1500的情况下，想到达990处，0-----490的区间内出发都可以。这之中，只有一个旅馆（0处的那一个）。0处到0处的方案为1，那么到达990处的方案也为1。

继续，想到达1010处，0-----510的区间出发都可以。同样只有一个旅馆（0处），所以到达1010处方案还是1。

### **接下来，命运的轨迹终于将这道题引向了AC————**

### **想到达1970处，470-----1470的区间里出发都可以。这中间有两个旅馆（990处、1010处）。也就是说到达1970处有1+1=2种方案。**

停，分析到这一步，你可能会恍然大悟：“这不就是斐波那契数列吗！”

所以你以为我第二次是怎么WA的？

冷静下来仔细一想，就会发现其实这和斐波那契数列有本质不同。前者是某一区间内符合条件的所有旅馆方案数相加，而后者只是单纯的前两个数相加。

而最终，7000处的方案数就是答案。

## 有起始条件，重复的运算过程，有边界——妥了，典型递推（说是dp也没毛病）。

然后，敲代码，提交，搞定。

代码如下。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	int a,b,n;
	int ans[7001]={0};//用于记录每处的方案数
	int m[7001];//这里其实可以进一步简化，但我为了偷懒（手动划掉）让广大读者自行体会代码奥妙就不改了。
	cin>>a>>b>>n;//输入数据
	bool bo[7001];
	bo[0]=bo[990]=bo[1010]=bo[1970]=bo[2030]=bo[2940]=bo[3060]=bo[3930]=bo[4060]=bo[4970]=bo[5030]=bo[5990]=bo[6010]=bo[7000]=1;//让人**的初始定义
	for(int i=1;i<=n;i++)
	{
		cin>>m[i];
		bo[m[i]]=1;
	}//输入+数据处理
	ans[0]=1;//设立初始条件
	for(int i=1;i<=7000;i++)
	{
		if(bo[i]==1)//发现旅馆
		{
			for(int j=i-b;j<=i-a;j++)//使用循环查找区间内的旅馆
			if(j>=0)//防止程序炸掉（尽管并无卵用）
			if(bo[j]==1)//发现旅馆
			{
				ans[i]=ans[i]+ans[j];//累加方案数
			}
		}
	}
	cout<<ans[7000]<<endl;//输出答案
	return 0;
} 
```



当然，这个程序格式还可以浓缩至极简，不过这样更方便 ~~~~偷懒~~~~ 讲解

最后插一句蒟蒻的疑问：“如何在代码中使用删除线？”求解。

不喜勿喷【手动蒟蒻的卖萌】


---

## 作者：ljc20020730 (赞：2)

我就问大家没有想过桶排吗？

最快了啊 何况 n<=7000这么大

```cpp
var mins,maxs,n,i,j:longint;
    u:array[1..7001]of longint;
    ans,a:array[0..7000]of longint;
begin
 readln(mins);
 readln(maxs);
 readln(n);
  a[1]:=990;a[2]:=1010;a[3]:=1970;a[4]:=2030;a[5]:=2940;
  a[6]:=3060;a[7]:=3930;a[8]:=4060;a[9]:=4970;a[10]:=5030;
  a[11]:=5990;a[12]:=6010;a[13]:=7000;
  for i:=14 to 13+n do read(a[i]);
  for i:=1 to n+13 do
   u[a[i]]:=1;
  n:=0;
  for i:=1 to 7000 do
   if u[i]>0 then begin
    inc(n);
    a[n]:=i;
   end;
  // for i:=1 to n do write(a[i],' ');
  ans[0]:=1;
  for i:=0 to n-1 do
   for j:=i+1 to n do begin
   if (a[j]-a[i]<=maxs)and(a[j]-a[i]>=mins)
   then ans[j]:=ans[j]+ans[i];
   if (a[j]-a[i]>maxs)then break;
  end;
  writeln(ans[n]);
end.

```

---

## 作者：shengmingkexue (赞：2)

很水的递推题

d[i] 表示 第i个点的距离

f[i] 表示 到第i个点的方案数

初始f[0]=1

则f[i]=sum(f[j])   (a<=d[i]-d[j]<=b)

最后输出f[13+n]


---

## 作者：loceaner (赞：1)

## 思路

一道超级简单的入门搜索题！随便做都可以过的那种（反正我是乱做的。。）

先用一个数组把之前就有的旅馆存下来，然后输入新旅馆的时候从第$15$个开始输入，之后对旅馆的位置排一下序，直接暴力搜索就行了

具体的可以看注释

## 代码
```cpp
//知识点:搜索
/*
By:Loceaner
*/
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

inline int read() { //快读（不会的话无视掉，输入的时候直接用scanf就好了）
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

const int N = 50;

int a, b, n, w[N] = {0, 990, 1010, 1970, 2030, 2940, 3060, 3930, 4060, 4970, 5030, 5990, 6010, 7000}, vis[N], ans = 0; //用w数组存每个旅馆的位置

void dfs(int now, int cnt) {
	if(now >= 7000) {//只要目前的位置大于了7000，直接让方案数加一并返回
		ans++;
		return;
	}
	for(int i = 1; i <= n + 15; i++) {
		if(!vis[i]) {
			if(w[i] - now >= a && w[i] - now <= b) {
				vis[i] = 1;//如果满足条件就将vis数组设为1
				dfs(w[i], cnt + 1);//更新参数，继续搜索 
				vis[i] = 0;//搜索完之后回溯
			}
		}
	}
}

int main() {
	a = read(), b = read(), n = read();
	for(int i = 15; i < n + 15; i++) w[i] = read();
	stable_sort(w, w + n + 15);//从小到大排序
	vis[0] = 1;
	dfs(0, 0);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：1)

**dfs搜索，然后进行回溯（所以需要一个bool的数组）**

**边界：如果已经达到7000或者已经超过，即以到达目的地，则退出**

**记得先把题中已经给的数据记录在数组中**

------------

**代码：**
```
#include<iostream>
#include<cstdio>
using namespace std;
int a[8000] = {0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000},A,B,n,ans = 0;
bool dis[8000] = {0};
void search(int x);
int main()
{
    cin>>A>>B>>n;
    for(int i = 13; i <= n + 12;i++)scanf("%d", &a[i]);
    search(0);//从起点开始
    cout<<ans<<endl;
    return 0;
}
void search(int x)
{
    for(int i = 1; i <= n + 13;i++)
    {
        if(a[i] >= x + A && a[i]  <= x + B && !dis[i])
        {
            if(a[i] == 7000){ans++;return;}//到达目的地就增加方案数
            dis[x] = 1;
            search(a[i]);
            dis[x] = 0;//回溯
        }
        else
            if(x + A >= 7000){ans++;return;}//到达目的地就增加方案数(所行路程已经超过最大路程) 
    }
}
```


---

## 作者：ricky_lin (赞：1)

# 一道比较水的递推
## 解析：题目问有多少种住旅馆的方案。每个旅馆的方法数就是由a和b两个规定距离之内在它前面的旅馆路径总和。
### 直接献上代码：
```cpp
#include<bits/stdc++.h>//不想打这么多头文件，就打个万能的吧
using namespace std;
int a,b,n;//定义
int main()
{
	cin>>a>>b>>n;//输入
	int m[14+n],m2[14+n];//再定义，不想浪费空间
	m[0]=0;m[1]=990;m[2]=1010;m[3]=1970;m[4]=2030;m[5]=2940;m[6]=3060;m[7]=3930;m[8]=4060;m[9]=4970;m[10]=5030;m[11]=5990;m[12]=6010;m[13]=7000;//赋值
	memset(m2,0,sizeof(m2));
	m2[0]=1;//第一个旅馆的方法数为1
	for(int i=0;i<n;i++)
		cin>>m[14+i];输入
	sort(m,m+14+n);//排序方便查找
	for(int i=1;i<n+14;i++)
	{
		for(int j=0;j<i;j++)
		{
			if(m[i]-m[j]>=a&&m[i]-m[j]<=b)//判断
				m2[i]+=m2[j];//求方法数
		}
	}
	cout<<m2[n+13];//输出
	return 0;//结束
}
```

---


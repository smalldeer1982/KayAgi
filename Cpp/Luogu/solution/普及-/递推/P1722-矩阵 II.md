# 矩阵 II

## 题目背景

usqwedf 改编系列题。


## 题目描述


如果你在百忙之中抽空看题，请自动跳到第六行。

众所周知，在中国古代算筹中，红为正，黑为负……

给定一个 $1\times 2n$ 的矩阵（usqwedf：这不是一个 $2n$ 的队列么），现让你自由地放入红色算筹和黑色算筹，使矩阵平衡[即 $\forall i \in[1, 2n]$，$1\sim i$ 格中红色算筹个数大于等于黑色算筹]。

问有多少种方案满足矩阵平衡（注意红色算筹和黑色算筹的数量必须相等）。

## 说明/提示

样例解释： 

- 方案一：红，黑，红，黑

- 方案二：红，红，黑，黑

数据范围：

$1\le n\le 100$

## 样例 #1

### 输入

```
2```

### 输出

```
2```

# 题解

## 作者：Binary_Search_Tree (赞：38)

### [题目传送门](https://www.luogu.org/problemnew/show/P1722)

题目貌似没说清楚，总的红色算筹个数必须与黑色算筹相等。

这一题因为n<=100,所以可以放心大胆地用二维DP

令dp[i][j]表示前i个算筹中放j个红色算筹的方案数

则可以得出dp[i][j]=dp[i-1][j]+dp[i-1][j-1]

**注意：j必须大于等于i/2上取整 **

不说了，下面是[本蒟蒻](https://www.luogu.org/space/show?uid=40985)的代码：
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;
int n,f[505][505];
int main(){
	scanf("%d",&n);
	f[1][1]=1;
	for (int i=2;i<=n+n;i++)
		for (int j=(i+1)>>1;j<=i;j++)
			f[i][j]=(f[i-1][j]+f[i-1][j-1])%100;
	printf("%d",f[n+n][n]);
	return 0;
}
```

---

## 作者：文艺平衡树 (赞：29)

大家好像都说了是卡特兰数了，那我来稍作解释吧：

将红看成是入栈操作，黑看成是出栈操作，那么显然任意时刻红多于黑就意味着出栈操作必须在栈不为空时进行。

所以该问题就转化成了求出栈序列，也就是卡特兰数。

```cpp
#include<stdio.h>
#include<stdlib.h>
long long c[101]={1,1,2};
int main(){
    int n,i,j;
    scanf("%d",&n);
    for(i=3;i<=n;i++){
        j=0;
        while(j<=i-1){
            c[i]+=c[j]*c[i-1-j];
            while(c[i]>=100) c[i]%=100;
            j++;
        }
    }
    printf("%lld",c[n]);
    return 0;
}
```

---

## 作者：x_miracle (赞：16)

​这题是卡特兰数的一道裸题。

利用这一道题介绍一下什么是卡特兰数（Catalan）

### 卡特兰数的定义式：

$
h_n=\left\{\begin{matrix}
 1 & n=1,0 \\ 
 \sum_{k=1}^{n-1}h_kh_{n-k}& n> 1
\end{matrix}\right.
$

由于这个定义式太复杂。平时我们很难用到。

### 卡特兰数的推出式：

常见的有下面两种：

- $\frac{1}{n+1}\textrm{C}_{2n}^{n}$

- $H_{n+1}=\frac{4n+2}{n+2}H_{n}$
 $H_{n}=\frac{4n-2}{n+1}H_{n-1}$

公式一为通项公式。公式二位递推公式。

关于公式一的证明，由于题主的水平有限，再加之以证明过程对于信息竞赛来说意义不大。此处感兴趣的小伙伴可以自行BFS。（思路是利用母函数与二项式定理）

公式二证明：

数学思想：把阶乘拆开，然后**配方**。

过程如下：

$$
\begin{aligned}
h_{n+1}&=\frac{1}{n+2}\textrm{C}_{2n+2}^{n+1} \\
&=\frac{1}{n+2}\frac{\left ( 2n+2 \right )!}{\left ( n+1 \right )!\times\left ( n+1 \right )!}\\
&=\frac{1}{n+2}\frac{\left ( 2n \right )!\times\left ( 2n+1 \right )\left ( 2n+2 \right )}{n!\times n! \times \left ( n+1 \right )^2}\\
&=\frac{1}{n+2}\frac{\left ( 2n+1 \right )\left ( 2n+2 \right )}{n+1}\times\frac{1}{n+1}\textrm{C}_{2n}^{n}\\
&=\frac{4n+2}{n+2}h_n
\end{aligned}
$$

另一个公式类似，读者自证。

### 卡特兰数的应用：

- 出栈次序
- n对括号正确匹配数目
- 给定节点组成二叉搜索树
- 在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数
- 求一个凸多边形区域划分成三角形区域的方法数

（这里建议记住卡特兰数的前几项：1, 1, 2, 5, 14, 42, 132, 429, 1430...）

### 关于此题：

这道题虽然说是卡特兰数裸题，但有一个细节，就是答案对100取模。

嗯。。然后，题主就写了一个错误的写法。像这样：


```cpp
void catalan(int n)
{
	f[0]=f[1]=1;
	for(int i=1;i<=2*n;++i)
	{
		f[i]=(f[i-1]*(4*i-2)/(i+1));
		f[i]=f[i]%100;	//这里是错误点
	}
}
```

错误的原因：模运算与基本四则运算有些相似，**但是除法例外**。其规则如下

- $(a+b)\%p$ $=$  $ ( a\%p + b\%p )$ $\%p$
- $(a-b)\%p$ $=$  $ ( a\%p - b\%p )$ $\%p$
- $(a\times b)\%p$ $=$  $ ( a\%p \times b\%p )$ $\%p$
- $(a^b)\%p$ $=$  $ (( a\%p )^b)$ $\%p$

故这道题不适合用上文中的递推式来做。而应该用卡特兰数的定义式来做。~~虽然它不常用。~~


代码如下：

```cpp
#include <bits/stdc++.h>
#define MAXN 1000
long long f[MAXN];
int main()
{
	int n;
	std::scanf("%d",&n);
	f[0]=f[1]=1;
	for(int i=2;i<=n;++i)
		for(int j=1;j<=i;++j)
		{
			f[i]+=f[j-1]*f[i-j];
			f[i]%=100;
		}
	std::printf("%d",f[n]);
	return 0;
}
```

---

## 作者：EternalEpic (赞：10)

这是一道有些DP思想的普通递推

首先，澄清一下题意：最后要平衡指的是红黑棋子数量一致

而且，有2 * n长

Ok，切入正题—————— ~~~~前面是扯淡~~~~

我们可以考虑f(i,j)表示i米长， 放j个红的的合法方案数

显然它可以由f(i - 1,j)和f(i - 1, j - 1)get到

但是i - 1要大于等于(j - 1) / 2向上取整

所以有方程：

```
for (register int i = 2; i <= n << 1; i++)
	for (register int j = i >> 1; j <= i; j++)
	{
		f[i][j] = f[i - 1][j];
		if (j - 1 - (i - 1) % 2 >= i - 1 >> 1) f[i][j] += f[i - 1][j - 1];
		f[i][j] %= 100;
	}
```

于是乎：

```
#include <bits/stdc++.h>
#include <queue>
#include <set>
#include <vector>
#include <deque>

#define rep(i,n) for (register int i = 1; i <= n; i++ )
#define rup(i,x,y) for (register int i = x; i <= y; i++ )
#define rdown(i,x,y) for (register int i = x; i >= y; i-- )
#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

inline char gc(void)
{
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}

template <class T> inline void read(register T &x)
{
	register long long flag = 1;
	x = 0; register char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') flag = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	x *= flag; return;
}


template <class T> inline void write(register T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

template <class T> inline void writeln(register T x)
{
    write(x);
    puts("");
}

template <class T> inline void writeln(register T x, char c)
{
	write(x); putchar(c);
}

template <class T> inline void chkmax(T &X, const T Y)
{
	X > Y ? X = X : X = Y;
}

template <class T> inline void chkmin(T &X, const T Y)
{
	X < Y ? X = X : X = Y;
}

inline void file_open(string str)
{
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}

inline void file_clo(void)
{
	fclose(stdin);
	fclose(stdout);
}

typedef long long ll;

enum {
	N = 100
};

int n, f[N << 1 | 1][N << 1 | 1];

int main(void)
{
	read(n); memset (f, 0, sizeof f );
	
	f[1][1] = 1;
	for (register int i = 2; i <= n << 1; i++)
		for (register int j = i >> 1; j <= i; j++)
		{
			f[i][j] = f[i - 1][j];
			if (j - 1 - (i - 1) % 2 >= i - 1 >> 1) f[i][j] += f[i - 1][j - 1];
			f[i][j] %= 100;
		}
			
	writeln(f[n << 1][n]);
    return 0;
}



```

谢谢兹磁！

---

## 作者：pzk23 (赞：8)

容易证明，题目要求的是第n个Catalan数，因此套用递推公式：

h(n)=h(0)\*h(n-1) + h(1)\*h(n-2) + ... + h(n-1)\*h(0) （其中h(0)=1，n>=1）

```cpp
h(n)表示第n个Catalan数
#include<cstdio>
using namespace std;
int h[110];
int main()
{
    int n,i,j;
    h[0]=1;
    scanf("%d",&n);
    for(i=1;i<=n;++i)
        for(j=0;j<i;++j)
            h[i]=(h[i]+h[j]*h[i-1-j])%100;
    printf("%d\n",h[n]);
    return 0;
}
```

---

## 作者：1lgorithm (赞：7)

## 一道卡塔兰数的题。

思路：把红色算筹看成左括号，黑色算筹看成右括号，就变成了求第n项卡特兰数的问题。

代码（别问我为什么不用c++，不想打逆元）：
```cpp
n=int(input())
a=1
m=2*n
i=n
while i>=1:
    a=a*(i+n)
    a=a//(n-i+1)
    i-=1
print(a//(n+1)%100)

```

求赞。

<I>o<I>


---

## 作者：俞盛瀚0212 (赞：6)

各位dalao都是C++，我就发个Pascal吧

粗看题目觉得很难，但是当你枚举足够多的小样例后，发现......这不是卡特兰数吗？

（估计大家只知道用它来算出栈序列，但是它的用处其实很大！NOIP初赛经常考）

通项公式自己去搜吧......

```cpp
var n,i,j:longint;
  a:array[0..100000]of longint;
begin
  a[0]:=1;
  readln(n);
  for i:=1 to n do
   for j:=0 to i-1 do
    a[i]:=(a[i]+a[j]*a[i-1-j]) mod 100;
  writeln(a[n]);
end.
```
没错，没了，这些有通项的就是短。

---

## 作者：O2人 (赞：5)

经典的记忆化DFS啊（要不是不会卡特兰数QAQ）。

我觉得题目说的不是很清楚：从样例就可以看出来红的和黑的必须一样多，但是题目里没说所以样例过不去的小伙伴一定要注意这个问题啊。

先定义f[i][cnt]表示前i个位置上红的比黑的多几个（因为要求每个i都必须满足红的>=黑的情况，所以不会有负的）。

接下来上代码：

```
#include <bits/stdc++.h>
#define TT 100
#define LL long long
#define ULL unsigned long long
#define DD double
#define maxn 205
using namespace std;
/*读优*/
inline int read(){
	int red=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
	while (ch>='0'&&ch<='9') red=(red<<3)+(red<<1)+ch-'0',ch=getchar();
	return red*f;
}
/*f[i][cnt]表示前i个位置上红的比黑的多几个*/
int f[maxn][maxn],n,INF,Re,Ba;
/*INF用于表示当前状态是否被求出，如果f[i][cur]==INF说明f[i][cur]这个状态已经求过了return f[i][cur]就好了*/ 
/*Re表示用了几个红的，Ba表示用了几个黑的*/

/*本人习惯压行，表介意啊*/
inline int DFS(int i,int cnt){
	/*i==n+1就说明前n个已经选好了，这样就多了一个方案所以return 1*/
	if (i==n+1) return 1;
	/*嗯，这是记忆化专属的啦~*/
	if (f[i][cnt]!=INF) return f[i][cnt];
	/*初始化*/
	f[i][cnt]=0;
	if (/*只能用和n/2个*/Re<n/2) /*用了一个红的*/++Re,f[i][cnt]=/*此位置已选好，进入下一个，由于红的多了一个，所以差值加一*/DFS(i+1,cnt+1)%TT,/*回溯*/--Re;
	/*黑的和红的差不多，这里就不赘述太多了*/
	if (Ba<n/2&&cnt) ++Ba,f[i][cnt]=/*要Mod干净啊*/(f[i][cnt]%TT+DFS(i+1,/*这里是差值减一*/cnt-1)%TT)%TT,--Ba;
	return f[i][cnt];
}
int main(){
	freopen("luogu.in","r",stdin);
	freopen("luogu.out","w",stdout);
	n=read()*2;/*方便一下啦*/
	memset(f,63,sizeof f);INF=f[0][0];
	printf("%d\n",DFS(1,0));
	return 0;
}
```

---

## 作者：optimize_3 (赞：5)

下面是美丽的标程：

```
#include《bits/stdc++.h》
using namespace std;
long long n,a【233】;
int main（）
｛
	cin》》n;
	a[0]=1;
	for（int i=1;i<=n+1;i++）
		for（int j=0;j<=i;j++）
			a[i]=（a【i】+a【j】*a【i-1-j】）%100；
	cout《《a【n】；
｝
```
标程？然而我更喜欢恶搞（雾

所以我肯定要用别的方法解。（注：想抄标程的放弃吧，符号被我改成中文的了）

#### 我们先不讲思路，看看输出格式：
```
输入格式：
正整数 n

输出格式：
方案数t对100取模
```
也就是说输入输出都是整数。

接着我们再看看数据范围：
```
1<=n<=100
```
好，大家应该都有思路了吧（众：您在说什么？）

好吧，首先这道题目输入输出都是一个数，而且n和t都不超过100。

## ~~简直是一道打表模板题啊！~~

下面是~~表~~程序生成器：

```
#include<bits/stdc++.h>
using namespace std;
long long n,a[233];
int main()
{
	freopen("p1722.cpp","w",stdout); 
	cout<<"#include<bits/stdc++.h>"<<endl;
	cout<<"using namespace std;"<<endl;
	cout<<"long long n,db[]={";
	for(n=1;n<=99;n++)
	{
		memset(a,0,sizeof(a));
		a[0]=1;
		for(int i=1;i<=n+1;i++)
			for(int j=0;j<=i;j++)
				a[i]=(a[i]+a[j]*a[i-1-j])%100;
		cout<<a[n]<<",";
	}
	n=100;
	a[0]=1;
	for(int i=1;i<=n+1;i++)
		for(int j=0;j<=i;j++)
			a[i]=(a[i]+a[j]*a[i-1-j])%100;
	cout<<a[n]<<"};"<<endl;
	cout<<"int main()"<<endl;
	cout<<"{"<<endl;
	cout<<"	cin>>n;"<<endl;
	cout<<"	cout<<db[n-1];"<<endl;
	cout<<"	return 0;"<<endl;
	cout<<"}";
}
```
运行后，你就会发现你多了一个cpp文件：
```
#include<bits/stdc++.h>
using namespace std;
long long n,db[]={1,2,5,14,42,32,29,30,62,96,86,12,0,40,45,70,90,0,90,20,20,40,50,24,52,52,4,60,68,4,9,98,10,64,62,92,64,0,90,20,20,40,0,40,20,20,90,0,72,56,56,12,80,24,72,12,64,80,12,96,36,12,25,50,50,0,50,0,0,0,50,0,0,40,20,20,40,0,30,40,40,80,0,40,20,20,40,0,0,0,0,0,0,0,50,0,0,0,40,0};
int main()
{
        cin>>n;
        cout<<db[n-1];
        return 0;
}
```
我居然让程序写程序。。。

---

## 作者：I_am_The_Flash (赞：2)

对于这一题，我们可以先找它的前几项答案（当然肯定有一些巨擘一眼就看出了其中的奥妙） 

我们发现：

a1=1	a2=2	a3=5	a4=14	a5=42…………、

博学的基~~机~~友们会发现这是著名的Catalan数列，有兴趣的同志们可以好好研究一下这个神奇的数列（真的是在好多地方都可以看见这东西...）

那么，以下就是Catalan数列的通项公式：

1. an=C(2n , n)/(n+1).

2. an=C(2n , n) - C(2n , n-1).

对于这一题，如果直接用通项公式，我们会担心取余对答案的影响，因此我们需要用到费马小定理（有兴趣的话可以仔细去研究研究哦~）

好在n在100以内，不用担心只能用O（n）代码才能过。

所以，这里我们可以用递推式来O（n^2）过

通项公式：a(n)= a(0)*a(n-1)+a(1)*a(n-2) + ... + h(a-1)a(0) (n>=2)

一下就是该方法的全代码：

```
#include<cstdio>
#define _for(i,k,j) for(int i=k;i<j;i++)	//（偷懒操作） 
int a[105]= {1};		//我们令a[0]=1	  //a[i] 表示的是第i个Catalan数哦
int main()
{
	int n;
	scanf("%d",&n);
	_for(i,1,n+1)
		_for(j,0,i)
			a[i]=(a[i]+a[j]*a[i-1-j])%100;  //不要忘了取余哦
	printf("%d",a[n]);
}

```

还是希望大家去看看神奇的Catalan数的有关内容，真的很有趣！

[关于Catalan数的有关内容在这里哦](https://blog.csdn.net/chlele0105/article/details/38739919)

---

## 作者：Qllllll (赞：2)


是时候来一篇玄学题解了   ~~其实是不会写~~

~~其实我用的也是卡特兰数~~

t=1/(n+1)*C(2n,n)

至于为什么 ~~去看别的dalao怎么说的~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,a[101];
bool b[201];
long long t=1;
int main()
{
	//先把1-200内的质数全部找出来 
	b[2]=1;b[3]=1;b[5]=1;b[7]=1;b[11]=1;b[13]=1;b[17]=1;b[19]=1;b[23]=1;b[29]=1;b[31]=1;b[37]=1;b[41]=1;b[43]=1;b[47]=1;b[53]=1;b[59]=1;b[61]=1;b[67]=1;b[71]=1;b[73]=1;b[79]=1;b[83]=1;b[89]=1;b[97]=1;b[101]=1;b[103]=1;b[107]=1;b[109]=1;b[113]=1;b[127]=1;b[131]=1;b[137]=1;b[139]=1;b[149]=1;b[151]=1;b[157]=1;b[163]=1;b[167]=1;b[173]=1;b[179]=1;b[181]=1;b[191]=1;b[193]=1;b[197]=1;b[199]=1;
	scanf("%d",&n);
	for(i=n+2;i<=2*n;i++)
	{
		//这里就是算阶乘了 
		if(b[i]==0) t*=i;
		else continue;
        for(j=n;j>=2;j--) if(t%j==0&&a[j]==0)
        {
            t/=j;
            a[j]=1;
        }	
	}
	//注意  这个时候分子已经全部约掉了   至于为什么  自己想一想 
	//因为刚刚质数没有乘进去  所以现在要把质数乘进去
	for(i=n+2;i<=2*n;i++) if(b[i]==1) t*=i,t%=100;
	printf("%lld",t);
	return 0;
}
```

~~好啦 AC啦~~

---

## 作者：Terrific_Year (赞：1)

这可以看成是一个栈的出入序列：红：入栈；黑：出栈；

就是一个卡特兰数嘛

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005]={1},h=1;//高精度 
int main(){
    int n;
    cin>>n;
    for(int i=n+2;i<=2*n;i++){//阶乘 
        for(int k=0;k<h;k++)a[k]*=i;
        for(int k=0;k<h;k++){a[k+1]+=a[k]/10;a[k]%=10;}
        while(a[h]){a[h+1]+=a[h]/10;a[h]%=10;h++;}
    }
    for(int i=n;i>=2;i--){//除法 
        for(int k=h-1;k>=0;k--){
            if(a[k]%i)a[k-1]+=10*(a[k]%i);
            a[k]/=i;
            while(h>1&&a[h-1]==0)h--; 
        }
    }
    cout<<a[1]<<a[0];//打印后两位 
    return 0;
}
```
这是高精度的~~懒得思考，把以前的拖过来做了些变动~~
~~再也不见~~

---

## 作者：Xie_BR (赞：1)

这是一道典型的卡特兰数的题目，下面我就用卡特兰来解这道题：  
# 卡特兰  
首先我们对于卡特兰的证明上面的大佬们都已经讲得很清楚了，其实本蒟蒻通过某些大佬的指教，明白了一个叫做数轴折线法的证明方法，具体证明过程在网上有很多，所以在此不做过多解释。  
最后说一下具体思路，我们可以先造一个卡特兰数列，具体公式如下（O（n）算法）：  

```cpp
a[0] = 1;
for(int i=1;i<=MK;i++)
{
	for(int j=0;j<=i;j++)
	{
		a[i] += (a[j]*a[i-j-1]%mod);
	}
}
```

然而在我们建完之后，就发现这道题迎刃而解，于是快乐的AC代码来了~  
# AC代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define int long long
#define MK 110
const int mod = 100;
using namespace std;
int n,a[MK];

signed main()
{
	a[0] = 1;
	for(int i=1;i<=MK;i++)
	{
		for(int j=0;j<=i;j++)
		{
			a[i] += (a[j]*a[i-j-1]%mod);
		}
	}
	scanf("%lld",&n);
	int ans = a[n]%mod;
	printf("%lld\n",ans);
	return 0;
}
```

# ：）

---

## 作者：zzr8178541919 (赞：0)

很明显这是个catalan数的模板题。

catalan数的公式可以把它理解为一种动态规划的过程。

利用动态规划的思想，从而catAlan数的通项公式

代码及解释如下

```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
//catalan数的模板
using namespace std;
long long Cat[200005];
long long mod=100;
int main()
{
	int n;
	scanf("%d",&n);
	Cat[0]=1;
	Cat[1]=1;
	for(int i=2;i<=n;i++)
	for(int j=0;j<n;j++)
	{
		Cat[i]+=Cat[j]%mod*Cat[i-j-1]%mod;
		Cat[i]%=mod;
	}//一个能够快速求出catalan数的公式 
	//可以将其理解为一种dp的思想 
	printf("%lld\n",Cat[n]);
	return 0;
} 
```


---

## 作者：shengmingkexue (赞：0)

一个普通的递推

f[i,j]表示第1-i根，使红色比黑色多j根的方案

递推过程：

```delphi
f[i+1,j+1]:=(f[i,j]+f[i+1,j+1]) mod 100;//放个红的
f[i+1,j-1]:=(f[i,j]+f[i+1,j-1]) mod 100;//放个黑的
```
最后输出f[2\*n,0]


---


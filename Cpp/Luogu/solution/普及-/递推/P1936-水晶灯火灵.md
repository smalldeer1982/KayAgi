# 水晶灯火灵

## 题目背景

《爱与愁的故事第五弹·Halloween》第二章。

题目容易吐血请谨慎阅读！


## 题目描述

爱与愁大神兴高采烈地踏出妖精系道馆——他已经获得了妖精系徽章（鼓掌）！可是一出门就遇到一群パンプジン（Because today is Halloween）！仲谋半？没事，爱与愁大神手上还仅存着一只水晶灯火灵（完克パンプジン）。或许是因为这是爱与愁大神存活的最后一只精灵，水晶灯火灵十分振奋，一击打垮了一群パンプジン。水晶灯火灵使用了一招***（被打上了马赛克？！），刚好符合以下③条规则：

1. $m,n \in \{1,2,\cdots ,k\}$；
2. $(n^2-m\times n-m^2)^2=1$；
3. $m,n$ 为整数。

爱与愁大神非常高兴，他想要知道 $m^2+n^2$ 的最大值，以及在什么情况下可以取得最大值。你能帮助他吗？请输出 $m$ 和 $n$。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 数据，$k \le 100$；
- 对于 $100\%$ 数据，$k \le 10^8$。


## 样例 #1

### 输入

```
1995```

### 输出

```
m=987
n=1597```

# 题解

## 作者：pzk23 (赞：49)

记f(n,m)=(n^2-mn-m^2)^2

则有f(m+n,m)=[(m+n)^2-n(m+n)-n^2]^2=(m^2+mn-n^2)^2=(n^2-mn-m^2)^2=f(n,m)

易得f(1,1)=1

故1=f(1,1)=f(2,1)=f(3,2)=...

发现m,n是Fibonacci数列相邻的两项，那么问题就极易解答了

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int k,m,n,c;
    scanf("%d",&k);
    for(m=n=1;m+n<=k;)
    {
        c=m+n;
        m=n;
        n=c;
    }
    printf("m=%d\nn=%d\n",m,n);
    return 0;
}
```

---

## 作者：Mosklia (赞：13)

## 总的来说，还是要先模拟，找到规律再写出代码
对于这道题，本人表示初次看到后：
	一脸懵逼。。。
    两脸懵逼。。。
    千万亿脸懵逼。。。
然后，写了一个模拟代码，模拟题目的运行：
```cpp11
//P1936 (-std ISO C++11, first edition)
#include<iostream>
#include<cmath>
using namespace std;
using ull=unsigned long long;
using ll=long long;
int main(){
	int k,res1=-1,res2=-1;
	ll step=0;
	cin>>k;
	for(ll i=1;i<=k;i++)
		for(ll j=1;j<=k;j++){
			if(i*i-i*j-j*j==-1 || i*i-i*j-j*j==1){//由（n²-mn-m²）²=1易得n²-mn-m²∈{-1,1}
				if(i*i+j*j>step){
					step=i*i+j*j;
					res1=j;
					res2=i;
				}
			}
		}
	cout<<"m="<<res1<<"\nn="<<res2;
	return 0;
} 
```
**注意这里是（n²-mn-m²）²=1，而不是原文的（n²-m\n-m²）²=1（好坑啊）**
运行结果如下：

k=2,m=1,n=2;

k=3,m=2,n=3;

k=4,m=2,n=3; 

k=5,m=3,n=5;

...

k=100,m=55,n=89;

...

k=1995,m=987,n=1597;


好了，结果清晰可见：斐波那契数列；其中m是n的前驱（不知道这么说对不对），n是数列中小于等于k的最大值

发现了规律代码就不难了，如下（我不知道为什么那么多人写斐波那契要用数组，直接两个变量不就好了吗？）：
```cpp11
//P1936(-std ISO C++11)
#include<iostream>
#include<algorithm>
// 偷懒，只用了一个swap（很简单的标准库算法，可以自己手写）
using namespace std;
using ull=unsigned long long;// “typedef”，写前几题忘记删了，留着装13
using ll=long long;
int main(){
    int res1=0,res2=1,k;
    cin>>k;
    while(res2<k){//重点：模拟斐波那契最后两位（而不是用数组把所有的东西保存下来），当最后一位（即n）大于等于k时退出循环
        res1+=res2;
        swap(res1,res2);
    }
    while(res2>k){//由于刚刚的循环退出条件时n>=k，为了避免n>k，再用一个循环往回退
    //应该用if就够了，不需要循环，可以试试（我没试）
        res2-=res1;
        swap(res1,res2);
    }
    cout<<"m="<<res1<<"\nn="<<res2;
    return 0;
} 
```
### 总结：
	1、要学会自己先写出模拟代码，再总结规律（本人由于之前不会这个技巧，NOIp 2017 day1 第一题只拿了30分，然后TLE。。。）
    2、斐波那契数列的题尽量不开数组（把空间留到真正需要的地方，虽说这道题开数组也没什么，但是我们无法保证每一道斐波那契的题都只有斐波那契数列的计算需要大量空间）


以上就是我写这道题的代码和心得，希望对各位有所帮助，也欢迎各位私信我，前来和我讨论

---

## 作者：lrj124 (赞：9)

如果LaTeX挂了，可以到我的博客查看题解：[『点这里』](http://www.cnblogs.com/lrj124/p/8980098.html)

$Fibonacci$相邻两项即可满足条件，证明如下：

$n^2-nm-m^2=n^2-m(n+m)=(f_{n})^2 - f_{n-1}f_{n+1}= \pm 1$

所以我们只要证明$(f_{n})^2 - f_{n-1}f_{n+1}= \pm 1$即可

首先$(f_{2})^2 - f_{1}f_{3}=1-2=-1 \ , \ (f_{3})^2 - f_{2}f_{4}=9-10=-1$

我们使用数学归纳法，假设结论对$n(n\geq 2)$时，$2n$和$2n+1$均成立

则$(f_{2n})^2=(f_{2n-1}+f_{2n-2})^2=(f_{2n-1})^2+2f_{2n-1}f_{2n-2}+(f_{2n-2})^2$

$=f_{2n-1}(f_{2n-1}+f_{2n-2})+f_{2n-1}f_{2n-2}+f_{2n-3}f_{2n-1}-1$

$=f_{2n-1}f_{2n}+f_{2n-1}(f_{2n-2}+f_{2n-3})-1$

$=f_{2n-1}f_{2n}+(f_{2n-1})^2-1$

$=f_{2n-1}(f_{2n}+f_{2n-1})-1$

$=f_{2n-1}f_{2n+1}-1$

所以$f_{2n}$成立,此时又可得

$(f_{2n+1})^2=(f_{2n}+f_{2n-1})^2=(f_{2n})^2+2f_{2n}f_{2n-1}+(f_{2n-1})^2$

$=f_{2n}(f_{2n+1}+f_{2n-1})+f_{2n}f_{2n-1}+f_{2n-2}f_{2n}+1$

$=f_{2n}f_{2n+1}+f_{2n}(f_{2n-1}+f_{2n-2})+1$

$=f_{2n}f_{2n+1}+(f_{2n})^2+1$

$=f_{2n}(f_{2n+1}+f_{2n})+1$

$=f_{2n}f_{2n+2}+1$

所以对一切$n$,结论均成立

```cpp
#include <cstdio>
int main() {
    int k,m = 1,n = 1;
    scanf("%d",&k);
    while (n+m <= k) {
        n += m;
        m = n-m;
    }
    printf("m=%d\nn=%d",m,n);
    return 0;
}
```

---

## 作者：垣根帝督 (赞：6)

只要你学过因式分解,你就可以轻松AC.(前提是你是个学霸!!!)

首先将②式进行因式分解

可得到

n^4-n^3*m-n^2*m^2-n^3*m+n^2*m^2+m^3*n-n^2*m^2+m^3*n+m^4

 化简,合并同类项可得
 
 n^4-2*n^3*m-2n^2*m^2+2*m^3*n+m^4
 
 再化简得到

(m^4-m(n+m)-(n+m)^2)^2

即原来的n变为m,原来的m变为(n+m),即斐波那契数列

然后就简单了,不多说,直接上代码
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#define ll long long
using namespace std;
ll m,n,k,ans,x=3;
ll f[100001];
int main()
{
	cin>>k;
	f[1]=f[2]=1;
	while(f[x]+f[x-1]<=k)
	{
		f[x]=f[x-1]+f[x-2];
		x++;
	}
	cout<<"m="<<f[x-3]<<"\nn="<<f[x-2];
	return 0;
}
```
本蒟蒻的第一篇题解,求过QWQ...

---

## 作者：安子 (赞：4)

原题传送门      [P1936 水晶灯火灵](https://www.luogu.org/problem/P1936)


这里采用一种新的方法(蒟蒻的复杂方法请楼上楼下的大佬不要吐槽)


首先由题目可知:


$(n^{2}-m\times n-m^{2})^{2}=1$   


## so  我们可以得出:


$n^{2}-m\times n-m^{2}=\pm1$


最终得出:

$m1=\sqrt{5\times n\times n\div4-1}-\frac {n}{2}$



$m1=\sqrt{5\times n\times n\div4+1}-\frac {n}{2}$


依据如此就可以写出代码了


下面贴代码:


~~没有防抄袭所以可以放心复制~~

```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    double n,k,m1,m2,sum=0;
    long long x,y,i,j;
    cin>>k;
    for (n=k;n>=1;--n)
    {
      m1=sqrt(5*n*n/4-1)-n/2;
      m2=sqrt(5*n*n/4+1)-n/2;
      if ((n*n-m1*n-m1*m1)*(n*n-m1*n-m1*m1))  
      //因为精度问题所以要再次判断
      {
      x=m1;
      if (x==m1&&m1>=0&&sum<m1*m1+n*n)
        { j=m1;i=n;sum=m1*m1+n*n;break; }
      }
      if ((n*n-m2*n-m2*m2)*(n*n-m2*n-m2*m2)) 
      //再判原因同上,平方可以有正负两种,所以要判断两种不同的情况
      {
      x=m2;
      if (x==m2&&m2>=0&&sum<m2*m2+n*n)
        { j=m2;i=n;sum=m2*m2+n*n;break; }	
      }
    }
    cout<<"m="<<j<<endl;cout<<"n="<<i<<endl;
    return 0;
}

```


---

## 作者：RKcer21 (赞：3)

本题其实是斐波那契数列，在数列中，只要找到第一个连续两个的数大于k就好了，n是较小数，m是较大数

```cpp
var
  a1,a2,a3,a4:longint;
  i,j,k,n,m:longint;
begin
  read(k);
  a1:=0;//数列中代表n
  a2:=1;//数列中代表m
  while a1+a2<k do//如果找到了符合的数就退出
    begin
      a3:=a2+a1;//数列中m的后面一项
      a1:=a2;//往前移一位
      a2:=a3;//往前也移一位
    end;
  writeln('m=',a1);
  writeln('n=',a2);
end.  

```

---

## 作者：2016级8班taiqi (赞：2)

简洁代码~此题求斐波那契数列第n,n-1项。

```cpp
#include<iostream>
using namespace std;
long long f[1001],m,i(3);
int main(){
    cin>>m;
    f[1]=1;f[2]=1;//赋值前两个
    while(f[i]+f[i-1]<=m){
        f[i]=f[i-1]+f[i-2];//将斐波那契数列存储到f数组里
        i++;
    }
    cout<<"m="<<f[i-3]<<endl;//这个地方i多加了一次
    cout<<"n="<<f[i-2];
    return 0;
//perfect!
}
```

---

## 作者：Forever丶CIL (赞：2)

这个题可以先暴力打出表来，就是从1枚举n，m，

每当n，m满足（n2-m\*n-m2）2=1 时，就输出一下此时的n，m；

这样你可以观察一下发现n，m是有规律的，是满足斐波那契数列的

然后就可以直接写斐波那契数列了

。。。


------------

 
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
long long k;
long long fib[101010];
int main()
{
    cin>>k;
    fib[1]=fib[2]=1;
    int i;
    for(i=3;;i++)
    {
        fib[i]=fib[i-1]+fib[i-2];
        if(fib[i]>=k)
            break;        
    }
    cout<<"m="<<fib[i-2]<<"\n"<<"n="<<fib[i-1]<<endl;
    return 0;
}
```


------------


---

## 作者：张铭杨 (赞：1)

快乐的斐波那契数列，快乐的递推……
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long f[1001],m,i=3;
int main(){
    cin>>m;
    f[1]=1;f[2]=1;
    while(f[i]+f[i-1]<=m){
        f[i]=f[i-1]+f[i-2];
        i++;
    }//递推
    cout<<"m="<<f[i-3]<<endl;//输出
    cout<<"n="<<f[i-2];//输出
    return 0;
}
```


---

## 作者：Walking_Fairy_Talesl (赞：1)

初看这道题，似乎有一万只草泥马在向我奔来。仔细一想，肯定是公式推导了，怎么推呢？                    
（n^2-mn-m^2)^2=1      
则n^2-m^2-mn=√￣1=1                       
那我们先算出n^2-m^2等于多少                     
n^2-m^2=n^2-m^2+(mn-mn)    
n^2-m^2=(n^2-mn)+(mn-m^2)    
n^2-m^2=n^2-mn+mn-m^2    
则原式=n^2-mn+mn-m^2-mn=1         
则原式=n^2-mn-m^2=1    
则原式=n^2-m^2=mn+1   
然后怎么做？？？            
我先懵逼了3分钟，后来想到可以通过枚举找规律呀！      
枚举过程(n≠自然数的不写）：           
m=1,则n=2       
m=2,则n=3       
m=3,则n=5       
m=5,则n=8       
m=8,则n=13       
不难发现n=k范围内最大的斐波那契数，m=k范围内次大的斐波那契数。代码就很简单了：          
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int f[1000010];
int main()
{
	int k,i;
	cin>>k;
	f[1]=1;f[2]=1;//斐波那契数列递推边界
	for(i=3;i<=k;i++){//i一定要从3开始
		f[i]=f[i-1]+f[i-2];//斐波那契数列递推
		if(f[i]>k)break;//不满足条件就退出
	}
	cout<<"m="<<f[i-2]<<endl<<"n="<<f[i-1]<<endl;
	return 0;//最好加上它
}//打字很累求通过 
```


---

## 作者：LevenKoko (赞：0)

这种题目，最好先暴力写一个，在慢慢找规律

```cpp
#include<iostream>//暴力代码（40分）
#include<iomanip>
#include<cmath>
using namespace std;
int main()
{
    long long a[1005],n,x,m,k,tot=0;
    for(int n=1;n<=500;n++)//输出前五百组满足条件的数；
    {
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    if((i*i-i*j-j*j)*(i*i-j*i-j*j)==1)
    {
        
        if(tot<i*i+j*j) 
        {
        m=i;
        k=j;
    }
        }
    cout<<"m="<<k<<" "<<"n="<<m<<endl;
}
    return 0;
} 
```
由它的输出结果可以得到这是一个菲波那切数列。。。

条件就是小于K的最小的两个数；

所以：

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[1005],b,c,n;
    cin>>n;
    a[1]=1;
    a[2]=1;
    int i=3;
    while(a[i-1]+a[i-2]<=n)//条件满足
    {
    a[i]=a[i-1]+a[i-2];
    i++;
}
    cout<<"m="<<a[i-2]<<endl<<"n="<<a[i-1];
}
```

---

## 作者：AdzearDisjudge (赞：0)

嘛……大概因为我太蒟蒻了吧居然看不懂很多题解2333

只会写fib的辣鸡到此一游

此题仔细算算还是有规律的，每一个符合要求的数恰好是有序的，并且就是斐波那契数

所以按题面意思写个fib就好了呗

AC代码在此：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
int l,m,n,a[101]={0,1,1};
int main()
{
    cin>>n;
    m=3;
    while(a[m-2]+a[m-1]<=n)
    {
        a[m]=a[m-2]+a[m-1];
        ++m;
    }
    --m;
    printf("m=%d\nn=%d",a[m-1],a[m]);
    return 0;
} 
//月莫好风聚聚&红太阳thx！
```

---

## 作者：mengdai (赞：0)

简单的斐波那契数列的推导

当f[n]+f[n-1]>k时输出f[n],f[n-1]即可

以下代码（代码不瞎打，温暖你我他）


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,s;
int f[100003];
int main(){
    f[1]=1;
    f[2]=1;
    cin>>n;
    s=2;
    while((f[s]+f[s-1])<n){
        s=s+1;
        f[s]=f[s-1]+f[s-2];
    }
    cout<<"m="<<f[s-1]<<endl;
    cout<<"n="<<f[s];
    return 0;
}
```

---

## 作者：AC_Evil (赞：0)

很简单，裸的极值问题，写过吧？

其实就是fibonacci数列刚好<=k时的最后两项。


例如：k=10


原数列：1、1、2、3、5、8、|| 13（>k了）······

故m=5,n=8。


上代码

```cpp
var
f:array[1..100] of int64;
i,k:longint;
begin
readln(k);
f[1]:=1;f[2]:=1;
i:=3;
while (f[i-1]+f[i-2]<=k) do
begin
f[i]:=f[i-1]+f[i-2];
inc(i);
end;
writeln('m=',f[i-2]);
writeln('n=',f[i-1]);
end.
```

---

## 作者：revenger (赞：0)

关于数列的分析 扔个博客http://blog.csdn.net/ta201314/article/details/48417101

其实就是个斐波那契数列  求斐波那契数列在k以内的第一第二大值

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int k,a,b,c;
int main()
{
    scanf("%d",&k); 
    int a=1,b=1;
    c=a+b;
    while(c<=k)
    {
        a=b;
        b=c;
        c=a+b;
    }
    printf("m=%d\nn=%d",a,b);
}
```

---

## 作者：瞎子谦的爱人 (赞：0)

其实就是斐波那契数列，推导一下就知道：

简洁代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int k,m=1,n=1,sum;
    cin>>k;
    while(m+n<=k)
    {
        sum=m+n;
        m=n;
        n=sum;
    }
    cout<<"m="<<m<<endl;
    cout<<"n="<<n;
    return 0;
}
```


---

## 作者：Rainybunny (赞：0)

这道红题真打击人...

## 80分思路
且不谈玄学算法, 我们直接枚举$m$, 并对$n\in\lbrack \,1,k\,]$经行检测即可.  
首先, 对原式化简得:  
$$
n^2-nm-m^2\pm1=0
$$
因为我们可以用配方法轻易地推出一元二次方程的求根公式:  
**若有$ax^2+bx+c=0,a\neq0$**  
**则**:
$$
x_{1,2}=\frac{-b\pm\sqrt{b^2-4ac}}{2a}
$$
假设我们已取$m=a$, 则**以n为主元:**  
$$
n_{1,2}=\frac{a\pm\sqrt{5a^2\mp4}}{2}
$$
若$5a^2\mp4=t^2,t\in N$:  
当$2|a$时, $2|5a^2\mp4$, 故此时$2|t$, 又有$2|a\pm t$.  
当$2\nmid a$时, $2\nmid 5a^2\mp4$, 故此时$2\nmid t$, 又有$2|a\pm t$.  
又因为原方程对称轴$x_0=-\frac{b}{2a}=\frac{a}{2}>0$,  
**故只要$\sqrt{5a^2+4}\in N$或$\sqrt{5a^2-4}\in N$成立, 此时的$m=a$与$n=f(m)$就是一组合法解.**  
检查完全平方数$n\in N_+$, 若下等式:  
$$
\lfloor \sqrt{n} \rfloor ^2=n
$$
成立, 即可知$n$是完全平方数.  
对于每个合法的$(m,n)$, 保留$m^2+n^2$的max即可.  
不过$O(k=10^8)$还是比较难为人, 故勉强80分.

## 100分思路
我们仍利用主元思想, 定义指标函数:
$$
f_m(n)=(n^2-nm-m^2)^2
$$
发现, $f_n(n+m)=(m^2+nm-n^2)^2=(-m^2-nm+n^2)^2=f_m(n)$.  
又有$f_1(1)=1$, 通过上公式, $f_1(1)=f_2(1)=f_3(2)=...=1$.  
也即是, 对于$Fibonacci$数列的相邻两项$F_k, F_{k+1}$, 都会有:
$$
f_{F_{k+1}}(F_k)=1
$$
考虑对数学不感兴趣的小伙伴们, 若想进一步探求, [点这里](https://zhidao.baidu.com/question/500812284069464364.html).  
那么, 只需要求得$F_k, F_{k+1}$, 并且满足$F_{k+2}>k$即可.  
求$Fibonacci$数列的方法很多, 但$Fibonacci$数列的**发散速度是指数级的**, $k\le 10^8$便不值一提, 感兴趣的小伙伴可以学着码一码**矩阵加速**.  

------------
于是乎, 还是贴上代码吧.
## 80分参考代码
```cpp
#include <bits/stdc++.h>

#define Int register int

using namespace std;

int m, n, k;
long long Ans = -1;

inline bool Checkn ( const int a ) {
    double sq1 = sqrt ( 5LL * a * a + 4 ), sq2 = sqrt ( 5LL * a * a - 4 );
    if ( int ( sq1 ) * int ( sq1 ) == 5LL * a * a + 4 && ( a + int ( sq1 ) ) / 2 <= k
    && 1LL * a * a + 1LL * ( a + int ( sq1 ) ) * ( a + int ( sq1 ) ) / 4 > Ans ) {
        Ans = 1LL * a * a + 1LL * ( a + int ( sq1 ) ) * ( a + int ( sq1 ) ) / 4;
        m = a, n = ( a + int ( sq1 ) ) / 2;
        return true;
    }
    if ( int ( sq2 ) * int ( sq2 ) == 5 * a * a - 4 && ( a + int ( sq2 ) ) / 2 <= k
    && 1LL * a * a + 1LL * ( a + int ( sq2 ) ) * ( a + int ( sq2 ) ) / 4 > Ans ) {
        Ans = 1LL * a * a + 1LL * ( a + int ( sq2 ) ) * ( a + int ( sq2 ) ) / 4;
        m = a, n = ( a + int ( sq2 ) ) / 2;
        return true;
    }
    return false;
}

inline void Work () {
    scanf ( "%d", &k );
    for ( Int i = 1; i <= k; ++ i ) {
        Checkn ( i );
    }
    printf ( "m=%d\nn=%d\n", m, n );
}

int main () {
    Work ();
    return 0;
}
```
## 100分参考代码
```cpp
#include <bits/stdc++.h>

#define Int register int

using namespace std;

inline void Work () {
	int k, f1 = 1, f2 = 1;
	scanf ( "%d", &k );
	while ( f1 + f2 < k ) {
		int t = f1;
		f1 = f2;
		f2 += t;
	}
	printf ( "m=%d\nn=%d\n", f1, f2 );
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：zy小可爱ღ (赞：0)

lalala~~

这题确实有点坑，第一遍穷举超时，然后就开始了漫漫找规律之路。。。

终于，在经过5分钟的纠结之后，我终于发现了这个神奇的规律，那就是

**Fabonacci！！！**

好吧，这没什么值的兴奋的。。。

具体解释看代码：



```cpp
#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<string>
#include<cmath>
#include<ctime>
#include<vector>
#include<bitset>
#include<memory>
#include<utility>
#include<cstdio>
#include<sstream>
#include<iostream>//其实本题只需要这一个头文件。。。
#include<cstdlib>
#include<cstring>
#include<algorithm>//个人建议把会的头文件都写上去，以免出现未调用函数库的的命令
using namespace std;
long long k,a,b,c;//可爱的四个函数~~~
int main(){//可爱的主程序~~~
    cin>>k;//可爱的输入~~~
    a=b=1;
    c=a+b;//可爱的赋初值~~~
    while(c<=k){//可爱的循环~~~
        a=b;
        b=c;
        c=a+b;//用三个数据循环模拟数组，起到节省空间的作用
    }
    cout<<"m="<<a<<endl;
    cout<<"n="<<b<<endl;//可爱的输出~~~
    return 0;
}
最后，祝大家编程顺利~~~
```

---


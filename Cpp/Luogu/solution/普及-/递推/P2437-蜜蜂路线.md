# 蜜蜂路线

## 题目背景

无

## 题目描述

一只蜜蜂在下图所示的数字蜂房上爬动,已知它只能从标号小的蜂房爬到标号大的相邻蜂房,现在问你：蜜蜂从蜂房 $m$ 开始爬到蜂房 $n$，$m<n$，有多少种爬行路线？（备注：题面有误，右上角应为 $n-1$）

![](https://cdn.luogu.com.cn/upload/pic/1575.png)


## 说明/提示

对于100%的数据，$1 \le M,N\le 1000$


## 样例 #1

### 输入

```
1 14```

### 输出

```
377```

# 题解

## 作者：一水清浅 (赞：367)

本蒟蒻表示最近在刷高精度的题目，这道题，和P1255 数楼梯基本是一样的呀！！！我刚刚打完那题来打这题，半分钟就AC了（因为只要把原来代码里的变量改一下就行了）

明明这道题很简单，为啥大家写的代码都这么烦，又要考虑这个又要考虑那个的，这只是一道新手题目呀！！！！我来写一份新手能很快看懂的代码，呐———

```cpp
#include <cstdio>
using namespace std;
int n,m,len=1;
int f[1005][1005];
void plus(int x)
{
	for(int i=1;i<=len;i++)
	  f[x][i]=f[x-1][i]+f[x-2][i];
	for(int i=1;i<=len;i++)
	  if(f[x][i]>9)
	  {
	  	f[x][i+1]+=f[x][i]/10;
	  	f[x][i]%=10;
	  }
	if(f[x][len+1]) len++;
}
int main ()
{
	scanf("%d%d",&m,&n);
	f[1][1]=1,f[2][1]=2;
	for(int i=3;i<=n-m;i++) plus(i);
	for(int i=len;i;i--) printf("%d",f[n-m][i]);
	return 0;
}
```

本蒟蒻表示：某某大佬说过，做题目关键是把题目做对，而不是创造条件去展示自己的编程技巧，，，，，要是大家没什么感触就去看看P1001 A+B Problem的题解吧，能把新手吓到的那种，23333

---

## 作者：大魔鬼灿灿 (赞：81)

高精斐波那契数列

本题一看数据范围就知道是高精，很多人看到高精就不会了，因为高精确很好理解却很难打代码，这很让人头疼，其实不难，我将讲一个比较易懂实用的方法，希望对大家有所帮助

**上思路**

思路和斐波那契一样，不过特判a[0][1]=0a[1[1]=1,a[2][1]=1，之后，a[i][j]=a[i-1][j]+a[i-2][j]，这是主要公式，为什么开二维数组呢，因为用到高精，一直循环到n-m，这是斐波那契的主要思路，难点在于如何打高精，接下来我将讲如何打高精的代码

刚才提到的二维数组的第二维是进位用的，满十进一，每个数位加起来，就是高精了（不用字符和字符串），代码是这样

```
//因为1000的fb比较大，所以位数也要大，干脆就加600次
//PS：不会超时
for(int j=1;j<600;j++) 
  a[i][j]=a[i-1][j]+a[i-2][j];
//然后是进位，也是循环600次，看每一位是不是>9了
//如果某一位大于9，高一位++，该位-10，知道该位<10
for(int j=1;j<600;j++)
{
    while(a[i][j]>9)
    {
        a[i][j+1]++;
        a[i][j]-=10;
    }
}
```

**上代码的主要思路**

为了使大家好看代码，在代码上我就不写注意事项了，先在前面说清楚了，然后把无注释的代码奉上。

定义的n,m是输入的蜂房，t是存n-m的，a数组存走法，pd判断输出的最高位是不是0。

主函数首先输入m和n，t为n-m

特判0,1,2这三个数，因为这3个是已知的。

从3开始循环，一直到t，主要的高精代码在前面解释了就不在多说了。

然后该输出n的结果了，从600循环到2，如果该位是0且是最高位，那么不满足数字的要求，就循环下一位，如果该位！=0，那么pd变成1，证明如果再出现0就不是最高位了，可以输出这个0

**注意**

最后的个位是不能在循环里输出的，因为个位比较特殊，如果n是0的话，按照循环里面的规则的不满足输出数的规律的，所以最后一位放到循环里面的话，n==0是输出不了正确答案的，所以个位要放循环外面特判，这样就满足了所有的条件，这道题就能过了

S：因为答案是0的只有n==0，所以也可以刚开始就特判0，最后循环输出的时候加上个位，大家喜欢哪种就用哪种就好了

上代码

```
#include<cstdio>
using namespace std;
int n,m,t;
bool pd=0;
int a[1001][601];
int main()
{
	scanf("%d%d",&m,&n);
	t=n-m;
	a[0][1]=0;
	a[1][1]=1;
	a[2][1]=2;
	for(int i=3;i<=t;i++)
	{
		for(int j=1;j<600;j++) 
		a[i][j]=a[i-1][j]+a[i-2][j];
		for(int j=1;j<600;j++)
		{
			while(a[i][j]>9)
			{
				a[i][j+1]++;
				a[i][j]-=10;
			}
		}
	}
	for(int i=600;i>1;i--)
	{
		if(!pd&&a[t][i]==0)continue;
		pd=1;printf("%d",a[t][i]);
	}
	printf("%d",a[t][1]);
	return 0;
}
最后希望大家能看懂，有所帮助，谢谢

---

## 作者：AdzearDisjudge (赞：68)

结论很简单，斐波那契第n-m+1项。

来一发Py题解

高精？不存在的。

range左闭右开 为了方便我给3减了1

```cpp
m,n=map(int,input().split())
a=1
b=1
for i in range(2,n-m+1):
    c=a+b
    a=b
    b=c
print(b)
```

---

## 作者：pomelo_nene (赞：30)

## 这是一道递推题


首先我们来分析一下：

![这是题目的图片了啦~](https://cdn.luogu.com.cn/upload/pic/1575.png)

在第$m$个蜂箱，方法肯定只有一种，然后可以到$m+1$ 和 $m+2$号蜂箱，所以来到$m+1$ 和 $m+2$号蜂箱肯定只有一种方法。



不如我们来画个图（这里的$m=1,n=7$）：
![画技拙劣，请多见谅](https://cdn.luogu.com.cn/upload/pic/57820.png)

如图，左上角的蜂箱代表第$m$个蜂箱，来到$m+1$ 和 $m+2$号蜂箱只有一种方法，然后到达$m+3$号蜂箱可以从$m+1$ 和 $m+2$号蜂箱走到达。根据加法原理，所以到达第$m+3$号蜂箱的方案数也就是来到$m+1$ 和 $m+2$号蜂箱的方案数之和。同理，第$m+4$号蜂箱的方案数也就是来到$m+3$ 和 $m+2$号蜂箱的方案数之和，直到我们加到$n$号蜂箱

这个时候我们不难得出这就是一个斐波那契数列，递推式$f[i]=f[i-1]+f[i-2]$，结果就是$f[n-m+1]$。

代码如下：
```cpp
#include<iostream>
#include<vector>
#include<string>
using namespace std;
struct Wint:vector<int>//高精度模板
{
    Wint(int n=0)
    {
        push_back(n);
        check();
    }
    Wint& check()
    {
        for(int i=1; i<size(); ++i)
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;
    }
};
istream& operator>>(istream &is,Wint &n)
{
    string s;
    is>>s;
    n.clear();
    for(int i=s.size()-1; i>=0; --i)n.push_back(s[i]-'0');
    return is;
}
ostream& operator<<(ostream &os,const Wint &n)
{
    if(n.empty())os<<0;
    for(int i=n.size()-1; i>=0; --i)os<<n[i];
    return os;
}//输入输出
Wint& operator+=(Wint &a,const Wint &b)
{
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0; i!=b.size(); ++i)a[i]+=b[i];
    return a.check();
}
Wint operator+(Wint a,const Wint &b)
{
    return a+=b;
}//写A+B Problem...
/*以上皆是用重载运算符实现的高精*/
Wint f[1005]={0,1,1};//进行赋初值，f[1]=f[2]=1
int main(){
	int m,n;
	cin>>m>>n;
	for(int i=3;i<=n-m+1;++i)	f[i]=f[i-1]+f[i-2];//进行递推
	cout<<f[n-m+1];//输出答案
	return 0;
}
```

---

## 作者：KEVIN_L (赞：26)

这道题就是递推，~~手动模拟~~就会发现这是一个需要**高精度**计算的斐波那契数列。

在 C++的 **STL** 中有一个很好用的东西——string，用来存储字符串，操作方便，可以整个赋值，拼接，拥有弹性长度……（~~我真的没有在打广告~~）

#### 下面针对本题代码简单介绍一下几种 string 的使用方法
1. 定义一个 string 数组/字符串，string 数组每一个元素是一个字符串，调用与普通数组基本无异 
```cpp
   string f[5005];/string s;
```

2. 返回这个字符串的长度
  ```cpp
     s.size()或s.length()
```

3. 将字符串 s 赋值为"123"
 ```cpp
    s = "123";
```
4. 将字符串 str 拼接到 s 后面
```cpp
   s += str;
```


使用string来存储字符串进行高精度计算更加方便，下面附上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
string f[1005] = {"0","1","2"};//斐波那契数列的初始化
int a[1005],b[1005],c[1005];
int n,m;
void fib_high(){

    for(int i=3;i<=n;i++){
	f[i] = "";
	memset(c,0,sizeof(c));//这一步把c数组全部赋值为0，这很重要
        for(int j=0;j<f[i - 1].size();j++)a[f[i - 1].size() - j - 1] = f[i - 1][j] - '0';//利用斐波那契数列递推公式，将前面两个字符串转数字
	for(int j=0;j<f[i - 2].size();j++)b[f[i - 2].size() - j - 1] = f[i - 2][j] - '0';
	int l = f[i - 1].size();//越靠后的数的位数大于等于前面的
	for(int j=0;j<l;j++){
	    c[j] += a[j] + b[j];
	    if(c[j] >= 10){//处理进位
		c[j + 1] = 1;
		c[j] -= 10;
	    }
	} 
	if(c[l] > 0)l++;//进位可能会多一位，所以要特判
        while(c[l] == 0&&l>0)l--;//习惯性地去除前导0
	for(int k = l;k>=0;k--){
	    f[i] += char(c[k] + '0');//将所得的数转化为字符串储存
	}    
    }
}
int main(){
   scanf("%d%d",&m,&n);
   fib_high();
   cout<<f[n - m];//M到N
	
   return 0;//简洁的主程序结束啦
}
```
感谢观看QAQ

**我写得那么认真，管理大大求过！**

---

## 作者：meyi (赞：17)

### 各位神犇已经在题解中提供了各种各样的高精度代码，但却没有一个可作为模板使用，接下来就让本蒟蒻来写一个模板型代码吧（笑）
```cpp
//本题其实就是求斐波那切数列的第n-m+1项，但由于数据过大，所以需要使用到高精度加法
#include<cstdio>
#include<cstring>	//strlen和memset所需头文件
#include<algorithm>	//reverse所需头文件
#define r register int	//register关键字将变量存储在CPU寄存器中，可以提高效率
struct BigInteger{
    char str[100001];	//str数组用于存储字符串
    int num[100001],len;	//num数组为str数组转为int类型的结果，len为str的长度，也就是num的大小
    inline void output(){	//输出函数，由于是反向模拟加法的，所以也需要反向输出
        for(r i=len-1;i+1;--i)printf("%d",num[i]);
    }
    BigInteger operator+(BigInteger &k){	//开始重载了，加法竖式模拟也不需要多解释
        len=max(len,k.len);r f=0;
        for(r i=0;i^len;++i){
            num[i]+=k.num[i]+f;
            if(num[i]>9)num[i]-=10,f=1;
            else f=0;
        }
        if(f)num[len++]=1;	//这里是对进位的处理
        return *this;	//*this返回一个指向类本身的指针
    }
    BigInteger(){	//初始化，清零所有变量和数组
    	len=0;
        memset(str,0,sizeof str);
        memset(num,0,sizeof num);
    }
    BigInteger(int k){	//将BigInteger类型赋为int类型，也可当做强制转换使用
        memset(str,0,sizeof str);
        sprintf(str,"%d",k);	//sprintf与printf类似，可以当做将数值打印到字符串中，具体用法请自行度娘（笑）
        len=strlen(str);	//保存字符串长度
        std::reverse(str,str+len);	//由于需要反向模拟竖式，所以我们在这里就调用STL的reverse函数将str字符串倒过来
        for(r i=0;i^len;++i)num[i]=str[i]-48;	//将字符串转为int类型
    }
};
main(){
    BigInteger n(1),m(1);	//注意，这里必须初始化为1，否则会出错
    int a,b,c;
    scanf("%d%d",&a,&b);
    c=b-a+1;	//求出是求斐波那切数列的第几项
    for(r i=1;i^c;++i)	//这里的位运算其实优（zhi）化（shi）意（wei）义（le）不（zhuang）大（bi）
        if(i&1)n=n+m;	//这里的a^b可当做a<b或a!=b使用,c&1相当于c%2
        else m=m+n;
    if(c&1)n.output();	//注意这里，如果c为奇数，我们应该输出n（不是题意中的n！）
    else m.output();	//反之则c为偶数，我们应该输出m（不是题意中的m！）
}
```

---

## 作者：_YRH_ (赞：15)

其实就是斐波那契数列改版，只不过是从m开始罢了，每一项等于左边相邻两个和就好了。

而且，千万记住要用高进度！！

[/color][codec]

```cpp
#include<iostream>
#include<string.h>
using namespace std;
int n,m,i,j,a[500],b[500],c[500];
int main(){
    cin>>m>>n;
    a[0]=1;    a[1]=1;
    b[0]=1;    b[1]=0;
    for(j=m+1;j<=n;j++){
        for(i=0;i<=a[0];i++)
            c[i]=a[i];
        for(i=1;i<=a[0];i++){
            a[i]+=b[i];
            a[i+1]+=a[i]/10;
            a[i]%=10;
        }
        while(a[a[0]+1]>0)
            a[0]++;
        memset(b,sizeof(b),0);
        for(i=0;i<=c[0];i++)
            b[i]=c[i];
    }
    for(i=a[0];i>=1;i--)
        cout<<a[i];
    return 0;
}
[/codec]
```

---

## 作者：weak_ddb (赞：12)

 [题目链接](https://www.luogu.org/problem/P2437)

### 蒟蒻写水题题解第一篇

有人说，$m$到$n$，这则么做呀？

别忘了斐波那契数列是记录从起点到终点的方案数。之前的我们的起点是$1$，终点是$n$。这篇的起点是$m$终点是$n(m \leq n)$。我们将起点的值设为$1$，按照正常的斐波那契数列递推下去，就能得到答案了。

**tips**

斐波那契的第$1000$项有约$1e300$，也就是$1$后面跟着$300$个$0$，必须要用高精度。

我们今天欣赏一波自定义运算的优美计算

```cpp
#include<bits/stdc++.h>
using namespace std;
struct big
{
	int a[1005];
	void R(char *s)//将字符串初始化为数字
	{
		for(int i=strlen(s)-1,j=1;i>=0;i--,j++)
		a[j]=(int)s[i]-48;
		a[0]=strlen(s);
	}
	void W()//输出
	{
		for(int i=a[0];i>=1;i--)//倒叙
		printf("%d",a[i]);
	}
	void operator += (const big &b)//高精加
	{
		a[0]=max(a[0],b.a[0]);//处理长度
		for(int i=1;i<=b.a[0];i++)
		{
			a[i]+=b.a[i];
			a[i+1]+=a[i]/10;
			a[i]=a[i]%10;//处理进位
		}
		while(a[a[0]+1]){
			a[0]++;//处理最前面的进位
		}
	}
};
big f[1005];
int main()
{
	int n,m;
	cin>>n>>m;
	f[n].R("1");
	f[n+1].R("1");
	for(int i=n+2;i<=m;i++)
	{
		f[i]+=f[i-2];
		f[i]+=f[i-1];
	}
	f[m].W();
	return 0;//简洁的程序
}
```

---

## 作者：feecle6418 (赞：10)

斐波那契数列+高精：

由于小学的标数法，所以可以推断用斐波那契。

```cpp
#include<cstdio>
#include<iostream>
#define L 11000
using namespace std;
string add(string a,string b) {//高精
    string ans;
    int na[L]= {0},nb[L]= {0};
    int la=a.size(),lb=b.size();
    for(int i=0; i<la; i++) na[la-1-i]=a[i]-'0';
    for(int i=0; i<lb; i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0; i<lmax; i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1; i>=0; i--) ans+=na[i]+'0';
    return ans;
}
string a[1001]={"0","1","1"};//尤其注意！！
int m,n;
int main() {
    cin>>m>>n;
    int cc=n-m+1;
    for(int i=3;i<=cc;i++){
        a[i]=add(a[i-1],a[i-2]);
    } 
    cout<<a[cc];
    return 0;
}
```

---

## 作者：fighter_OI (赞：5)

发现没有Pascal题解，于是贡献一下。

观察可得第n格可由第n-1格或第n-2格爬来，

于是f[n]=f[n-1]+f[n-2]

斐波那契数列。

注意，Pascal用高精度时应四位一存储。

标程：

```cpp
type arr=array[0..100] of longint;
var i,n,m:longint;
    a:array[1..1000] of arr;
    
function max(a,b:longint):longint;
begin if a>b then exit(a);exit(b); end;
function jia(a,b:arr):arr;
var k,i:longint;
begin
 jia[0]:=max(a[0],b[0]);
 if a[0]<b[0] then for i:=a[0]+1 to b[0] do a[i]:=0 else for i:=b[0]+1 to a[0] do b[i]:=0;
 k:=0;
 for i:=1 to jia[0] do
  begin
   jia[i]:=a[i]+b[i]+k;
   k:=jia[i] div 10000;
   jia[i]:=jia[i] mod 10000;
  end;
 if k>0 then begin inc(jia[0]); jia[jia[0]]:=k; end;
end;
begin
 read(n,m);
 n:=m-n+1;
 a[1][0]:=1;
 a[1][1]:=1;
 a[2][0]:=1;
 a[2][1]:=1;
 for i:=3 to n do
  a[i]:=jia(a[i-1],a[i-2]);
 write(a[n][a[n][0]]);
 for i:=a[n][0]-1 downto 1 do
  begin
   if a[n][i]<1000 then begin write(0);
   if a[n][i]<100 then begin write(0);
   if a[n][i]<10 then write(0); end; end;
   write(a[n][i]);
  end;
end.
```

---

## 作者：hz4zzhangyue (赞：5)

![Luogu](https://cdn.luogu.com.cn/upload/pic/1575.png)

#如图，稍微找下规律即可发现

#从1到达i的路径总数=到达i-1的路径总数+到达i-2的路径总数

##且1→1=1 1→2=1

即可推得1→3=2 1→4=3……

##所以我的主要思路就是把m点的位置当成1，不断枚举出m到（m到n中所有节点）的路径总数 枚举完成后直接输出位于n点的值

###但由于本题数据范围较大 如果直接用longint肯定会炸 所以果断高精度

最后 贴上代码

```cpp
Type
  s=array[1..210] of longint;//由于1→1000路径总数为两百多位 所以这个数组开到210 用于存放m→i的路径总数
Var
  m,n,i:longint;
  map:array[1..1000] of s;//存放m到（m到n中所有节点）的路径数量
  flag:boolean;//用于输出去除前导零时的标记变量
Function add(a,b:s):s;//简单的高精度加法
  var
    i,x:longint;
  begin
    x:=0;//x存放余数（其实就是1）
    for i:=1 to 210 do begin//懒得判断位数 直接全部加起来（可能有点浪费时间）
      add[i]:=a[i]+b[i]+x;//累加
      x:=add[i] div 10;//存下余数
      add[i]:=add[i] mod 10;
    end;
  end;
Procedure draw;//枚举
  var
    i:longint;
  begin
    map[m][1]:=1;//1→1=1
    map[m+1][1]:=1;//1→2=1
    for i:=m+2 to n do//枚举
      map[i]:=add(map[i-1],map[i-2]);//累加
  end;
Begin
  readln(m,n);
  draw;//调用子程序 进行枚举
  flag:=true;//开始输出
  for i:=210 downto 1 do
    if flag and (map[n][i]=0) then//前导零不输出
      continue
    else begin
      flag:=false;
      write(map[n][i]);
    end;
End.
```

---

## 作者：2017gangbazi (赞：3)


    



```cpp
#include<iostream>
//需要用高精度，所以稍微长了些
using namespace std;
int a[1001]={0},b[1001]={0},c[1001]={0};
void jia(int a[],int b[])
{
    for(int i=1;i<=1000;i++)
    a[i]+=b[i];
    for(int i=1;i<=1000;i++)
    {
        if(a[i]>=10)
        {
            a[i+1]+=a[i]/10;
            a[i]%=10;
        }
    }
}
void cp(int c[],int a[])//当然有个函数，我记不住了，直接定义了一个
{
    for(int i=1;i<=1000;i++)
    c[i]=a[i];
}
int main()
{
    long long m,n;
    cin>>m>>n;
    a[1]=1;b[1]=2;
    for(long long  i=1;i<=n-m-2;i++)
    {
        jia(a,b);//这里是动态存放a,b,c来实现的
        cp(c,a);
        cp(a,b);
        cp(b,c);
    }
    int h=1000;
    for(int i=1000;i>=1;i--)
    {
        if(c[i]==0)
        h--;//这是出去前导零
        else
        break;
     } 
    for(int i=h;i>=1;i--)
    cout<<c[i];//打印输出即可
    return 0;
}
```

---


# 三角形计数

## 题目背景

三角形计数(triangle) 递推


## 题目描述

把大三角形的每条边 $n$ 等分，将对应的等分点连接起来（连接线分别平行于三条边），这样一共会有多少三角形呢？编程来解决这个问题。


## 说明/提示




## 样例 #1

### 输入

```
3
1
2
3```

### 输出

```
1
5
13```

# 题解

## 作者：Heartlessly (赞：60)

**upd:2019.4.27（因为洛谷多行LaTeX会挂，所以很多公式是图片）**

好像还是会挂，所以到博客里看好了：<https://heartlessly.github.io/problems/luogu-p2807/>

## Description

$n$ 等分大三角形的每条边，将对应的等分点连接起来（连接线分别平行于三条边），求有多少个三角形。


## Source

**[[Luogu]P2807](https://www.luogu.org/problemnew/show/P2807)**

## Solution

看似很简单的数学题，实际上让人摸不着头发（？？？

不妨设$\triangle  ABC$ 的边长为 $n$，这样 $n$ 等分每一条边后，每个小三角形的边长为 $1$ 。

先考虑头朝上的三角形（$\triangle$）：

边长为 $1$ 的三角形有多少个呢？

![Eu7ej1.png](https://s2.ax1x.com/2019/04/27/Eu7ej1.png)

（如图）显然第一层有 $1$ 个，第二层有 $2$ 个，一直到第 $n$ 层有 $n$ 个，共
$$
1 + 2 + \cdots + n = \frac{n\left( n + 1\right)}{2}
$$
那边长为 $2$ 的三角形呢？

![Eu7ZcR.png](https://s2.ax1x.com/2019/04/27/Eu7ZcR.png)

（如图）我们可以数它左下角那个边长为 $1$ 的三角形，因为有大小限制，最右侧一列就不能数了，所以问题变为求边长为 $n - 1$ 的三角形中有几个边长为 $1$ 的三角形，与上面的求法一样，共
$$
1 + 2 + \cdots + n - 1 = \frac{n \left( n - 1\right)}{2}
$$
同理，边长为 $i\ \left(1 \leq i \leq n\right)$ 的三角形共
$$
1 + 2 + \cdots + n - i + 1 = \frac{\left(n - i + 1 \right)\left( n - i + 2 \right)}{2}
$$
由此可以得出结论，边长 $1 \sim n$ 头朝上的三角形共
$$
\frac{\sum\limits_{i = 1}^n\left(n - i + 1 \right)\left( n - i + 2 \right)}{2} = 
\frac{\sum\limits_{i = 1}^n i\left( i + 1\right)}{2} = \frac{n \left( n + 1\right)\left(n + 2 \right)}{6}
$$
至于第 $2$ 步到第 $3$ 步怎么得出来的，这里给出详细解释。

**定理：** 
$$
\sum\limits_{i = 1}^n i^2 = 1^2+2^2+ \cdots + n^2 = \frac{n\left( n + 1 \right) \left( 2n + 1\right)}{6}
$$
**证明：**

首先需要知道
$$
\left( n + 1 \right)^3 = n^3 + 3n^2 + 3n + 1
$$
那么
$$
\left( n + 1 \right)^3 - n^3 = 3n^2 + 3n + 1
$$
因此我们可以列出 $n$ 个式子

![EuLVIK.png](https://s2.ax1x.com/2019/04/27/EuLVIK.png)

把这 $n$ 个式子相加，得到

$$
\left( n + 1\right)^3 - 1^3 = 3\sum\limits_{i=1}^n i^2 + 3\sum\limits_{i=1}^n i + n
$$

化简

$$
n^3 + 3n^2 + 2n = 3\sum\limits_{i = 1}^ni^2 + \frac{3n\left(n + 1\right)}{2}
$$

$$
2n^3 + 6n^2 + 4n = 6\sum\limits_{i = 1}^ni^2 + 3n^2 + 3n
$$

$$
\sum\limits_{i = 1}^ni^2 = \frac{2n^3 + 3n^2 + n}{6}
$$

因式分解，得
$$
\sum\limits_{i = 1}^ni^2 = \frac{2n^3 + 3n^2 + n}{6} = \frac{n\left(2n^2 + 3n + 1 \right)}{6} = \frac{n\left( n + 1 \right) \left( 2n + 1\right)}{6}
$$
证毕。

于是乎，我们就可以推出

![EuLcJU.png](https://s2.ax1x.com/2019/04/27/EuLcJU.png)

再考虑头朝下的三角形（$\bigtriangledown $）：

![Eu7nnx.png](https://s2.ax1x.com/2019/04/27/Eu7nnx.png)

（如图）边长为 $1$ 的三角形第 $1$ 行没有，第二行有 $1$ 个，第三行有 $2$ 个，一直到第 $n$ 行有 $n - 1$ 个，所以共
$$
1 + 2 + \cdots + n - 1 = \frac{n \left( n - 1\right)}{2}
$$

接下来数边长为 $2$ 的三角形。

![Eu7V39.png](https://s2.ax1x.com/2019/04/27/Eu7V39.png)

（如图）我们考虑数它下方的三角形。前三行没有，第 $4$ 行有 $1$ 个，第 $5$ 行有 $2$ 个，一直到第 $n$ 行有 $n - 3$ 个，共
$$
1 + 2 + \cdots + n - 3 = \frac{\left( n - 2 \right)\left( n - 3 \right)}{2}
$$
同理，边长为 $3$ 的三角形共
$$
1 + 2 + \cdots + n - 5 = \frac{\left( n - 4 \right)\left( n - 5 \right)}{2}
$$
边长为 $i\ \left( 2 \leq 2i \leq n \right)$ 的三角形共
$$
1 + 2 + \cdots + n - 2 i + 1 = \frac{\left( n - 2i + 1 \right)\left( n - 2i + 2 \right)}{2}
$$

头朝下的三角形共（第一行式子表示 $n$ 是奇数，第二行式子表示 $n$ 是偶数）

![EuXFN6.png](https://s2.ax1x.com/2019/04/27/EuXFN6.png)

推导一下。

先考虑 $n$ 是奇数的情况。

![EuXnud.png](https://s2.ax1x.com/2019/04/27/EuXnud.png)

$n$ 为偶数也是同样的道理。

![EuXuDA.png](https://s2.ax1x.com/2019/04/27/EuXuDA.png)
把头朝上和头朝下的三角形加起来，得到

![EuXG8S.png](https://s2.ax1x.com/2019/04/27/EuXG8S.png)

这就是最后的答案，每次都可以 $O(1)$ 求了，总时间复杂度为 $O(T)$ 。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1, len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

int t, n;

int main() {
    for (read(t); t; --t) {
        read(n);
        if (n & 1) write((n + 1) * (2 * n * n + 3 * n - 1) / 8);//奇数 
        else write(n * (n + 2) * (2 * n + 1) / 8);//偶数 
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：Bean233 (赞：56)

我的创新找规律思维：  
一看到题，我眼睛一亮，想起了老师讲的规律。那个规律正好可以用在这道题上，但我没有那么做。因为我想找到属于自己的一种算法，想了一阵，忽然想起自己的一个找规律的小方法，立即用在了这道题上：  
已知条件是同学告诉我的这道题的几个答案：  
输入1，输出1  
输入2，输出5  
输入3，输出13  
输入4，输出27  
输入5，输出48  
输入6，输出78  
输入7，输出118  
输入8，输出170  
我开始使用自己的方法找规律：（真受不了缩进问题）  
```cpp
已知数列：1 5 13 27 48 78 118 170  
一次做差：4 8 14 21 30 40 52  
二次做差：4 6 7  9  10 12  
三次做差：2 1 2  1  2  
我的天哪！真的找到了规律！  
```
于是马上去做，写出了这样的代码，一遍AC：  
```cpp
//运行环境：Dev C++ 5.1.0  Windows
#include <iostream>
using namespace std;
unsigned long long Count(int s)
{
	unsigned long long Ans=1,i,j1=4,j2=4,j3=2;
	for(i=1;i<s;i++)
	{
		Ans+=j1;
		j1+=j2;
		j2+=j3;
		if(j3==2)j3=1;
		else if(j3==1)j3=2;
	}
	return Ans;
}
int main()
{
	int n,s;
	cin >> n;
	for(int i=0;i<n;i++)
	{
		cin >> s;
		cout << Count(s) << endl;
	}
	return 0;
}
```  
   
看不懂的地方请在评论区提出，我会尽快解答  
~~估计没人看不懂~~  

第一次发题解，请各位读者（包括管理员）谅解！~~不喜勿喷~~  



---

## 作者：Alex_Wei (赞：29)

#### 个人认为，本题找规律有更好的办法

思路：把大三角形看成等边三角形，先考虑正着放的，再考虑倒着放的

我们把底边在第 $i$ 条线段上的三角形成为在第 $i$ 层

#### 正着放（边长为 $i$）：

三角形个数最少的层数：第 $i$ 层，共有 $1$ 个

三角形个数最多的层数：第 $n$ 层，共有 $n-k+1$ 个

正着放**边长为 $i$** 的小三角形有 $1+2+……+(n-i+1)$ 个

边长 $i$ 的范围：$1,2,3……n$

#### 倒着放（边长为 $j$ ）：

三角形个数最少的层数：第 $j$ 层，共有一个

三角形个数最多的层数：第 $n-j$ 层：共有 $(n-j)-j+1$ 个

倒着放**边长为$j$** 的小三角形有 $1+2+……+(n-2*j+1)$个

边长 $j$ 的范围：$1,2,3……n/2,\ n/2$向下取整 （因为是倒着放的，所以最底下要留出一半的高度）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,f[550],ans;//f[x]为从1加到x的和
int main()
{
	cin>>t;
	for(int x=1;x<=500;x++)f[x]=f[x-1]+x;//预处理 
	while(t-->0){
		cin>>n,ans=0;//ans要清零
		for(int i=1;i<=n;i++)ans+=f[n-i+1];//计算正着的三角形个数
		for(int j=1;j<=n/2;j++)ans+=f[n-j*2+1];//计算倒着的三角形个数
		cout<<ans<<endl;
	}
	return 0;
}
```

如果有错误请私信我，我会及时改正！

$\small{\text{Upd 2019.8.17 美化文章，修改部分文字，添加Latex}}$

---

## 作者：Solo_ruirui (赞：15)

# 推导过程如下：
我们把情况分为奇数和偶数两种（所有情况均以f[1]=1,f[2]=5,f[3]=13作为基础）

### 再来看偶数的：

当n=4时，它相比f[3]增加了：

①顶点向上的：
1. 边长为1，顶点向上的，增加了4个
2. 边长为2，顶点向上的，增加了3个
3. 边长为3，顶点向上的，增加了2个
4. 边长为4，顶点向上的，增加了1个

顶点向上的总共增加了10个

②顶点向下的：
1. 边长为1，顶点向下的，增加了3个
1. 边长为2，顶点向下的，增加了1个

顶点向下的总共增加了4个

总的比f[3]多增加了14个

所有f[4]=f[3]+14=27

继续推边长为n=6，n=8的（这里我就不再继续推了）

可以发现：

顶点向上的增加的个数为：n+n-1+...+2+1

根据高斯求和法（倒序相加求和）可得：

顶点向上的增加的个数为：（n+1）* n / 2

顶点向下的增加的个数为：n-1+n-3+...+3+1

根据高斯求和法（倒序相加求和）可得：

顶点向上的增加的个数为：（n-1+1）* （n/2） / 2

                           =n * n / 4
所以我们得到了：f[n]=f[n-1]+(n+1) * n / 2 + n * n /4


------------

### 再来看奇数的：

当n=5时，它相比f[4]增加了：

①顶点向上的：
1. 边长为1，顶点向上的，增加了5个
2. 边长为2，顶点向上的，增加了4个
3. 边长为3，顶点向上的，增加了3个
4. 边长为4，顶点向上的，增加了2个
5. 边长为5，顶点向上的，增加了1个

顶点向上的总共增加了15个

②顶点向下的：
1. 边长为1，顶点向下的，增加了4个
2. 边长为2，顶点向下的，增加了2个

顶点向下的总共增加了6个

总的比f[4]多增加了21个

所有f[5]=f[4]+21=27+21=48

继续推边长为n=7，n=9的（这里我就不再继续推了）

可以发现：

顶点向上的增加的个数为：n+n-1+...+2+1

根据高斯求和法（倒序相加求和）可得：

顶点向上的增加的个数为：（n+1）* n / 2

顶点向下的增加的个数为：n-1+n-3+...+4+2

根据高斯求和法（倒序相加求和）可得：

顶点向上的增加的个数为：（n-1+2）[（n-1）/ 2 ]/2

                           =（n+1）*（n-1）/4
所以我们得到了：f[n]=f[n-1] + (n + 1 ) * n / 2 + (n+1) * (n-1) / 4
                           

------------
将上述结论总结起来，就可以得到代码（具体细节看代码中解释）：


------------

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long f[501]; 
int n,m;
int main()
{
	f[1]=1;//初始化 
	f[2]=5;
	f[3]=13;
	scanf("%d",&m);//输入数据组数 
	//看数据范围，n<=500
	//所以直接把1~500的答案算出来
	//需要哪个答案就把哪个答案打出来（其实是懒得打表） 
	for(int i=4;i<=500;i++)
	{
		if(i%2==0) f[i]=f[i-1]+(1+i)*i/2+i*i/4;//带入推导出来的结论 
		else f[i]=f[i-1]+(1+i)*(i-1)/4+(1+i)*i/2;   
	}
	for(int i=0;i<m;i++)
	{
		scanf("%d",&n);//输入n 
		printf("%lld\n",f[n]);//直接输出（注意是%lld） 
	}
	return 0;
}
```


---

## 作者：wzhy (赞：9)

这道题一眼望去就觉得是一道要找规律的题，而我又太懒，不想理论推导，所以暴力直接打表，表如下


 | 1 | 2 | 3 | 4 | 5 |  6| 7 | 8 | 9 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 5 | 13 | 27 | 48 | 78 | 118 | 170 | 235 |  |

通过分析表我们看不出什么，那么我们看他们的差，4,8,14,21,30,40,52,65，觉得有些意思，再做差，4，6，7，9,10,12,13，感觉快出来了，再做差，2，1,2,1,2,1，好，规律找出来了我们可预先计算出最后一组数组，在从后往前推，直至推到初始数列即可，再在询问时O(1)输出即可

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a1[600],a2[600],a3[600],a4[600],t,n;
int main(){
	memset(a1,0,sizeof(a1));
	memset(a2,0,sizeof(a2));
	memset(a3,0,sizeof(a3));
	memset(a4,0,sizeof(a4));
	a3[1]=a2[1]=4,a4[1]=1;
	for(int i=1;i<=499;i+=2) a1[i]=2,a1[i+1]=1;
	for(int i=2;i<=500;i++) a2[i]=a2[i-1]+a1[i-1];
	for(int i=2;i<=500;i++) a3[i]=a3[i-1]+a2[i-1];
	for(int i=2;i<=500;i++) a4[i]=a4[i-1]+a3[i-1];
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		printf("%lld\n",a4[n]);
	}
	return 0;
}
```

---

## 作者：阿柒 (赞：4)

###### 我的做题思路：

在刚开始做这题时，我的第一感觉：崩溃，崩溃，再崩溃！（没思路）

于是，我打开了题解，按到了其中一个利用找规律做出的代码。然而，看完后，一个字：一脸懵逼（貌似不是一个字）

我决定不看题解，自己找规律。
这道题的几个答案：

输入1，输出1

输入2，输出5

输入3，输出13

输入4，输出27

输入5，输出48

输入6，输出78

输入7，输出118

输入8，输出170

于是，我就把前两个数作差。
```
1 5 13 27 48 78
5-1=4
13-5=8
27-13=14
48-27=21
78-48=30
```
呵呵，作完差后，还是一脸懵逼。

然后我又继续分解。
```
4=4
8=4+4
14=4+4+(4+2)
21=4+4+(4+2)+(4+2+1)
30=4+4+(4+2)+(4+2+1)+(4+2+1+2)
```
原来如此！我终于明白了题解上的意思！

最后附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int a,s,hh=1,a1=4,a2=4,a3=2;
int main()
{
    cin>>a;
    for(int i=1;i<=a;i++)
    {
        cin>>s;
        hh=1,a1=4,a2=4,a3=2;
        for(int j=1;j<s;j++)

        {
            hh+=a1;
            a1+=a2;
            a2+=a3;
            if(a3==1) a3=2;
            else if(a3==2) a3=1;
        }
        cout<<hh<<endl;
    }
    return 0;
}
```


---

## 作者：LevenKoko (赞：4)

西格玛 Σ 这种东西对于一些人（比如我）来说显然太高深了……但谁说一定要用了呢？


我们先来看正着的三角形（表示懒得做图，实在不行可以看一下其他发布者的图或自己画一幅）

```cpp
n=1   1;
n=2   4(=1+  1+2);
n=3   10(=1+  1+2+  1+2+3);
n=4   20(=1+  1+2+  1+2+3+  1+2+3+4);
n=5   35;
n=6   56;
```
…………
so
规律是这样的：

ans=1+(1+2)+(1+2+3)+(1+2+3+4)+(1+2+3+4+5)…………+(1+2+3+...+n)=(n+1)\*n/2+n\*(n-1)/2+(n-1)\*(n-2)/2;

-------------------------------------------------------------------------------------------------------

然后是倒着的：

```cpp
n=1     0;
n=2     1;
n=3     3(=1+2);
n=4     7(=1+2+3+ 1);
n=5     13(=1+2+3+4+ 1+2);
n=6     22(=1+2+3+4+5+ 1+2+3+ 1);
n=7     34(=1+2+3+4+5+6+ 1+2+3+4+ 1+2);
```
然后规律也就出来,这个用通项公式还真不太好写，所以直接上代码（当然你用西格玛就很好表示了）。
```cpp
for(k=0;n-k>=2;k+=2)
        ans+=(n-k)*(n-k-1);
    ans/=2;
```
-------------------------------------------------------------------------------------------------------

最后，把正着的和倒着的加起来就是最终的Answer；



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    long long ans = 0 , k , n , t;
    cin>>t;
    while(t>0)
    {
    ans=0; 
    scanf("%lld",&n);
    for(k=0;n-k!=0;k++)
        ans+=(n-k)*(n-k+1);
    for(k=0;n-k>=2;k+=2)
        ans+=(n-k)*(n-k-1);
    ans/=2;
    printf("%lld\n",ans);
    t--;
    }
    return 0;
}
```

---

## 作者：弥生 (赞：3)

一道找规律的数学题

n为偶数：n(n+2)(2n+1)/8;

n为奇数：[n(n+2)(2n+1)-1]/8;


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
        int t;
        scanf("%d",&t);
        while(t--){
            int n,ans=0;
            scanf("%d",&n);
            if(n%2==0)
                ans=n*(n+2)*(2*n+1)/8;
            if(n%2==1)
                    ans=(n*(n+2)*(2*n+1)-1)/8;
        printf("%d\n",ans);
        }
        return 0;
}

```

---

## 作者：codemap (赞：2)

这是一道恶心的计数题...

我们用画图来考虑一下(~~画得太丑请谅解~~)

首先,如图易得$n=4$时答案为$13$

![](https://cdn.luogu.com.cn/upload/image_hosting/50pd9vrc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

然后我们考虑一下变成$n=5$时答案的变化

首先是边长为$1$的三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/e72m6y82.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图,共有$9$个

然后是边长为$2$的

![](https://cdn.luogu.com.cn/upload/image_hosting/rsfa06ap.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$4$个

边长为$3$的

![](https://cdn.luogu.com.cn/upload/image_hosting/0g64n6qz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$3$个

以此类推,边长为$4$的$2$个,边长为$5$的$1$个

所以增加了$2*i-1+s[i-1]$(前缀和)个

### 然而,并没有这么简单

## 还要考虑倒着的

如图,这张图里,增加了$2$个倒着的三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/oz5e4u93.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可找规律得(~~实在画不下去了~~),每次增加的三角形为:

i为奇数时,$(i-1)*(i-3)/4$

i为偶数时,$(i-2)^2/4$

综上所述,每次增加的三角形数为$2*i-1+s[i-1]$+上述(分类),递推即可

上代码
```cpp
#include<iostream>
using namespace std;
int main()
{
	int t,i,n,s[501],f[501];//s为前缀和,f为递推数组
	cin>>t;
	for(i=1;i<=500;i++)
		s[i]=i*(i+1)/2;//前缀和(直接用公式即可)
	//前三个必须打表出来(因为递推时有i-3)
	f[1]=1;
	f[2]=5;
	f[3]=13;
	for(i=4;i<=500;i++)//从4开始
	{
		f[i]=f[i-1]+2*i-1+s[i-1];//先加上正的三角形
		if(i%2==1)//奇数的情况
			f[i]+=(i-1)*(i-3)/4;//前面的公式
		else//偶数
			f[i]+=(i-2)*(i-2)/4;//前面的公式
	}
	for(i=1;i<=t;i++)
	{
		cin>>n;
		cout<<f[n]<<endl;//直接输出递推数组
	}
	return 0;//完美结束
}
```
# 请勿抄袭

---

## 作者：智子·起源 (赞：2)

### 这道题其实直接想很简单。
对于每个三角形，只要把它从正面数的三角形个数加上它倒过来数的三角形个数就可以了。

当然，在暴枚过程中，有一些公式还是要自己画图来推的。

不多说，直接上程序。
```cpp
#include<iostream>
using namespace std;
int n,data,ans;
int main()
{
  cin>>n;
  for(int i=0;i<n;i++)
  {
    cin>>data;ans=0;
    for(int j=1;j<=data;j++)
      for(int k=1;k<=data-j+1;k++)
        ans+=data-j+1-k+1;//记录正面三角形的个数。
    for(int j=1;j<=data/2;j++)
      for(int k=1;k<=data-(j*2)+1;k++)
        ans+=data-(j*2)+1-k+1;//记录倒过来的三角形个数。
    cout<<ans<<endl;
  }
  return 0;
}
```
就这么简单。

---

## 作者：Error404 (赞：0)

# ~~终于~~AC了！！！

这个题大家应该~~都是~~分正反做的吧

###  _正_ 
正着的三角只要找规律就好了，可以用等差数列来求


###  _反_ 
反的三角分了等分线个数的奇偶做

   奇数：
              
   奇数需要用到边上的点数
             
   仔细观察一下，可以发现也是等差数列来做
             
   然后是细节问题，底层的三角数可以用点数来表示
             
   最高层的三角应该是一个没有问题
             
   然后是~~最难~~的求多边小三角的个数
   
   就拿小边为2来说，这时大三角上有几个点不能做顶点，每条边应该是n-2个顶点
   
   然后可以找出如下公式：（k-(2i-2)+1)(k-(2i-2)) -------> (k+3-2i)*(k+2-2i)                  
   
   k是定点数，i是所找小三角的边数
   
   然后一个关于i的循环结束
   
   部分代码：
   
   ```cpp
for(int i=1;i<=n/2+0.5;i++){
      down+=(k+3-2*i)*(k+2-2*i)/2;
	  }
      
      
```

   
   偶数：
   
   偶数就简单一些了，需要注意的是偶数的最后一次i循环结果应该是一，但因为算法问题，最后一次的特殊结果是按正常情况算的（因为有重复之类的），所以提前结束循环
   
   部分代码：
   ```cpp
	for(int i=1;i<fen/2;i++){
       down+=(dian+3-2*i)*(dian+2-2*i)/2;
   	}
	down++;
```

### _最后_ !!!

添加一个循环，用于进行多个大三角中找小三角的程序,第一次提交因为这个栽了。。。

## 全部代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int times;
	cin>>times;
	int t[times];
	for(int i=0;i<times;i++){
		cin>>t[i];
	}
    
    
	for(int j=0;j<times;j++){
	    int fen=t[j];                                     //emmm变量名用了拼音
	    int dian=fen-1;
	    int up=0,down=0,total=0;
        
        
	
            if(fen%2==1){                                         //朝下奇数情况
    	            for(int i=1;i<=fen/2+0.5;i++){
    		          down+=(dian+3-2*i)*(dian+2-2*i)/2; //化简后公式
		    }
	    }
        
	    else{                                             //朝下偶数情况
		    for(int i=1;i<fen/2;i++){
			    down+=(dian+3-2*i)*(dian+2-2*i)/2; //化简后公式
		    }
		    down++; //补上特殊情况的个数 
	    }
        
        
	
	    for(int i=1;i<=fen;i++){                          //朝上（此时奇偶都一样）
		    up+=(fen-i+2)*(fen-i+1)/2; //化简后公式
	    }
	
	    total=up+down;                                    //总数
	    cout<<total<<endl;
    }
	return 0;
}
```

   
   
   
   
   
   
   
   
   
   
   
   
   
   

---

## 作者：Floating__Dream (赞：0)

```cpp
#include <cstdio>
int main(){
   // freopen("triangle.in", "r", stdin);
   // freopen("triangle.out", "w", stdout);
    int f[501]={0, 1, 4}, g[501]={0, 0 ,1};
    //f表示顶点在上方的三角形，g表示顶点在下方的三角形 
    for (int i=3; i<=500; i++){
        f[i]=f[i-1];
        for (int j=1; j<=i; j++) 
            f[i]+=j;
        g[i]=g[i-1];
        for (int j=i-1; j>=0; j-=2) 
            g[i]+=j;
    } 
    //for (i=2;i<=500;i++)
    //    printf("%d:%5d\n",i,f[i]+g[i]);
    int t, n;
    scanf("%d", &t);
    while (t--){
        scanf("%d", &n);
        printf("%d\n", f[n]+g[n]);  
    }
    return 0;
}
```

---

## 作者：54Teddy (赞：0)

一开始没思路，找规律找不到，打表打到$n = 10$才勉强找到规律（~~其实是我太弱了~~）规律就是$a[n] = [n(n+2)(2n+1)/8]$

附上代码(*O(1)*):
```cpp
#include<bits/stdc++.h>
#define rep(i, a, b) for(int i = a;i <= b;i++)
using namespace std;
int t, n;
int ans[501] = {0};
int main(){
	scanf("%d", &t);
	rep(i, 1, 500) ans[i] = i * (i + 2) * (2 * i + 1) / 8;
	rep(i, 1, t){
		scanf("%d", &n);
		printf("%d\n", ans[n]);
	}
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

数学问题，主要是要考虑到有倒着的。

里面有一个n>0的判断，原因是因为本人太渣了。怕n运行完后突然变成 mod 2=0 的了，再运行一遍。所以加了这个

```cpp
var
  n,m,i:longint;
begin
  readln(m);
  for i:=1 to m do begin
    readln(n);
    if (n mod 2=0) and (n>0) then begin
      n:=(n*(n+2)*(2*n+1)) div 8;
      writeln(n);
      n:=-10000;
    end;
    if (n mod 2=1) and (n>0) then begin
      n:=(n*(n+2)*(2*n+1)-1) div 8;
      writeln(n);
      n:=-20000;
    end;
  end;
end.
```

---

## 作者：Hangben (赞：0)

pascal题解（注意考虑正着放和倒着放的）

```cpp
program trianglenumbers;
  var
    t,i,j:longint;
    s,a,aa:array[1..1000] of int64;
  begin
    readln(t);
    for i:=1 to t do readln(aa[i]);
    a[1]:=1;
    s[1]:=1;
    for i:=2 to 500 do s[i]:=s[i-1]+i;
    for j:=2 to 500 do
      begin
        a[j]:=j*j;
        for i:=j-1 downto 1 do a[j]:=a[j]+s[i];
      end;
    for j:=4 to 500 do
      begin
        if j mod 2=0 then
          begin
            inc(a[j]);
            for i:=j div 2-1 downto 2 do a[j]:=a[j]+s[j-(i*2)+1];
          end
        else
          begin
            for i:=j div 2 downto 2 do a[j]:=a[j]+s[j-(i*2)+1];
          end;
      end;
    for i:=1 to t do writeln(a[aa[i]]);
end.
```

---


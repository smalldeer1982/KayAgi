# 金坷垃

## 题目背景

@rainheavy 原创

这是一道巨（du）水（liu）题

第一届中国国际博览会于2018年11.5--11.10在上海举行，特朗普统治的国家——美国带来了金坷垃。这是一种神奇的产品，~~肥料用了金坷垃，能吸收20米以下的氮磷钾~~（这是他们的广告）

可是，在经过富土（tu）康的质检员 DevZhu质检的时候发现出了点问题，金坷垃的效果并不像广告所说的那样。毕竟植物的根只能到深度为$1$的位置，金坷垃的效果有限


## 题目描述

它的效果只能如下：（以20为例）

20的约数（除本身）有10、5、4、2、1

从地下20米深处可以往上跳一个约数的长度（比如10）

现在它在10米处，10的约数（除本身）有5、2、1

再跳一个5，为5，5的约数（除本身）有1

再跳1个1，为4，4的约数（除本身）有2、1。

**1已用过，不能再用**

再跳一个2，为2。2的约数（除本身）有1。

**1已用过。**
此时没法再跳了。此时的深度为2。

按上述要求跳，把所有符合要求的能跳的所有情况全试一遍，只要有一种情况最后结果为$1$，这个肥料就合格，否则不合格。

DevZhu面对一大堆待检验的金坷垃，并不想检验那么多，他想问问你有哪些金坷垃是合格的，在这些合格的金坷垃中，初始深度排在第k个的是哪一个

把合格的金坷垃按初始深度从小到大排，请输出第k个金坷垃的初始深度，对$123456789$取模（富土康从不用1e9+7和998244353）

## 说明/提示

（简单死了。。。）

（给不会的人一点福利：数据里有一个是1）

对于30%的数据，$k$<=$10^5$;

对于70%的数据，$k$<=$10^9$;

对于100%的数据，$k$<=$10^{18}$；

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
2```

### 输出

```
2```

# 题解

## 作者：π酱 (赞：23)

首先看题目，模拟？DP？1e18不是开玩笑的，外加读入那么短，肯定会想到数论。

（本题解中不是2的次方的数用“非2方数”代替，是2的次方的数用“2方数”代替）

#### 做法0
打表，打这么个20个就能发现只有1、2、4、8、16满足了，
再用$2^{k-1}$的快速幂轻松解决

（啥？不会快速幂？你是来考$NOIP$的吗？）
  
#### 做法1
倒推1（可以这样蒙蔽你自己）
    
想要最后得到1，那么必然存在一个数$i$，使得$i$减去它的一个因数得到$1$，那么满足条件的只有2了，同理可推得只有4满足，又因为不能重复跳相同的高度

所以就有了1、2、4、8、16向上不断加的过程。

#### 做法2

倒推2（正解）

  我们可以肯定2的次方必然满足要求（一遍一遍减去一半就行），不好验证的就是剩下的数。
   
  对于任意一个2的次方，它只是1、2、4、8...的倍数。也就是说，它不是任何一个非2方数的倍数，那么它加上这个非2方数后，也不是这个数的倍数。
  
  根据题中规则，对于一个深度，只能跳它的因数的深度，且用过的深度不能再用，那么对于任意一个 2方数+非2方数，它一定不是这个非2方数的倍数，也就不能通过减掉这个非2方数来达到2的次方的状态。
    
  同理，对于一个2方数+另一个2方数（2个数不等），你减一个非2方数肯定达不到2的次方的状态，转入上一段所描述的状态。
  
  然后这个两个数的和一定是其中较小2方数的倍数（不解释），那么你需要减去这个较小数以达到2的次方的状态。

  如果你减去了这个较小2方数（重点来了！），**那么你在这个大的2方数不断减成1的过程中一定需要再减一遍这个较小的2方数！**

  用8+4举例，为12。已经知道减3、6都不会到达1（看第3段），减去2又不是2方数（10），所以减4。但8往下减小会用到一次4！所以一个2方数+另一个2方数的情况也无法满足。
  
  2方数+另一个2方数 和 2方数+非2方数已经表示了除2方数以外的所有数，这两种情况都是不行的，所以只有2的次方满足要求。~~（手都打累了~）~~
    
最后k<=1e18，记得用快速幂。

代码如下（短死了~~~）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=123456789;
int k;

ll pow(int x,int k){
    int x1=1;
    for(;k;k>>=1,x=1ll*x*x%mod)
        if(k&1!=0)
            x1=1ll*x1*x%mod;
    return x1;
}

int main(){
    cin>>k;
    cout<<pow(2,k-1)<<endl;
    return 0;
}
```

---

## 作者：哲学家 (赞：11)

首先经过读题，我们发现找到合格的金坷垃，怎么样的金坷垃才是合格的呢？（我们不难发现1肯定是合格的【题目已经给出了】）

然后我们开始手推一下之后合格的金坷垃：

2-1=1（合格）

3-1-1=1（不合格（1重复减了））

4-2-1=1（合格）

......



------------
对于任意一个数，他减去他的任意一个约数（除它本身）最小值都为他本身的1/2，我们可以考虑倒着推回去这样就行了，发现合格的金坷垃必须是2的倍数，我们可以用反证法来证明，如果一个合格的金坷垃不是二的倍数，那么最后经过前面的相减肯定会变成一个质数。

一个质数的约数（除它本身）只有1，但我们用一个数只能用一次，那么这个金坷垃就不是一个合格的金坷垃

如90：

90-45=45；

45-15=30；

30-10=20；

20-5=15；

15-3=12；

12-6=6；

6-3=3；

最后剩下了3（质数）【这个各位可以自己推一下】

------------

1；

1+1=2；

1+1+2=4；

1+1+2+4=8；

1+1+2+4+8=16；

......

不难发现第i个合格的金坷垃就是2的i-1次方，这样我们就可以用快速幂来解决了

------------
直接用快速幂模板就能过了！
```
#include<bits/stdc++.h>//万能头
using namespace std;
const int mod=123456789;//要mod的值
long long n;
long long qmi(long long x,long long k){//快速幂模板
    long long res=1;
    while(k>0){
    	if(k&1){
    		res=res*x%mod;
		}
		x=x*x%mod;
		k>>=1;
	}
	return res;
}
int main(){
    cin>>n;
    cout<<(qmi(2,n-1)%mod+mod)%mod<<endl;//输出2的n-1次方，(qmi(2,n-1)%mod+mod)%mod是防负数的，但这个没有负数就可以不用写
    return 0;//结束程序
}
```

---

## 作者：Yoo_ (赞：10)

>金坷垃，银坷垃

[在这视觉效果更好](https://114677.blog.luogu.org/p5035-jin-ke-la-ti-xie)

本题需要掌握知识：[快速幂](https://www.luogu.org/problemnew/show/P1226)

声明：本篇题解可能过长

P.S.我这种做法貌似时间耗用的更多一些

------------


这道题我们先观察一下题目，可以手算一下，就有了一下的表：

| k的取值 | 结果 |
| :----------- | :----------- |
| 1 | 1 |
| 2 | 2 |
| 3 | 4 |
| 4 | 8 |
| 5 | 16 |

可以发现，结果总是2的k-1次方

那么可以有下列几种做法

**做法1：打表输出**

当然，由于输出答案过大，导致表很难打出来，所以不推荐使用

不过，你用python我也拦不住你

**做法2：直接输出**

直接用C++函数输出pow(2,k-1)，但是还是不够大，所以也不能使用

就像这样：
```
cout<<pow(2,k-1);
```
然后我们的分数就。。。

**做法3：高精度**

我们已经知道了数据范围很大，那我们不妨尝试一下高精度，就有了一下代码
```
#include<iostream>
using namespace std;
int a[400]={0};
int i,j,N;
char lpow(int x){
    a[1]=1;
    for(i=1;i<=x;i++)
    {
        for(j=1;j<=34;j++)
        {
            a[j]*=2;
        }
        for(j=1;j<=34;j++)
        {
            a[j+1]+=a[j]/10;
            a[j]%=10;
        }
    }
    int la=34 ;
    while(a[la]==0)
    la--;
    char c[1001];
    for(i=la,j=1;i>=1,j<=la;i--,j++)
    {
    	c[j]=a[i];
    }
    for(int j=2;j<=la;j++){
    	c[1]+=c[j];
    }
    return c[1];//计算2^n的高精度版本
}
int main()
{
    cin>>N;
    int b=lpow(N-1)%123456789;
    cout<<b;//输出结果
}
```
可是因为时间的原因,也只拿到了10分，所以还要下一种做法

## **做法4：快速幂**

首先我们为什么要用快速幂？

暴力相乘的话，电脑要计算 b 次。用快速幂，计算次数在log(b)级别，很实用。

那么快速幂的概念又是什么呢？

(1)如果将 a 自乘一次，就会变成 a^2再把 a^2自乘一次就会变成 a^4。然后是a^8自乘 n 的结果是a^2^n

(2)a^xa^y = a^{x+y}
 
(3)将 b 转化为二进制观看一下：

比如 b = (11)10就是 (1011)2 从左到右，这些 11 分别代表十进制的 8,2,18,2,1。可以说 a^11 = a^8 × a^2 × a^1

为什么要这样表示？因为在快速幂的过程中，我们会把 a 自乘为 a^2 ，然后 a^2 自乘为 a^4。

所以我们有了下面的代码
```
#include<bits/stdc++.h>
using namespace std;
long long b,p,k,s,t;
int main()
{
    cin>>p;
    p--;
    s=2;
    t=1;
    for (int i=2;i<=p;i++)
    {
        s=s*2%123456789;
        if (s==2) break;
        t++;
    }
    p=p%t;s=1;
    if (p==0) p=t;
    for (int i=1;i<=p;i++)
    s=s*2%123456789;
    cout<<s;
    return 0;
}
```
可是为什么交上去只有90分呢？原来是我们没有特判

加上特判k-1为0的时候就好了
最终代码如下
```
#include<bits/stdc++.h>
using namespace std;
long long b,p,k,s,t;
int main()
{
    cin>>p;
    if(p-1==0){
    	cout<<1;
    	return 0;
	}//特判
    p--;
    s=2;
    t=1;
    for (int i=2;i<=p;i++)
    {
        s=s*2%123456789;
        if (s==2) break;
        t++;
    }
    p=p%t;s=1;
    if (p==0) p=t;
    for (int i=1;i<=p;i++)
    s=s*2%123456789;
    cout<<s;
    return 0;
}
```

---

## 作者：kai586123 (赞：9)

若有$b|a$，且$a-b=1$，则$a=2,b=1$

进一步若$b|a$，且$a-b=2$，则$a=4,b=2$

归纳，答案是$2^{k-1}$

```cpp
#include <bits/stdc++.h>
using namespace std;

long long fpow(long long x, long long y, long long z)
{
    long long ans = 1;
    for (; y; y >>= 1) {
        if (y & 1) ans = ans * x % z;
        x = x * x % z;
    }
    return ans;
}

int main()
{
    long long k;
    cin >> k;
    cout << fpow(2LL, k - 1, 123456789LL) << endl;
    return 0;
}
```

---

## 作者：jzh817 (赞：6)

神奇的题目当然要用神奇的解法

一看k的取值范围，就知道肯定是找规律的题

先做了一个暴力，把1-10全部试一遍，发现只有1,2,4,8是合格的，似乎便是2的多次方，再将16,32,64试一遍，也都是合格的。于是我们可以得到这题的终极结论，答案就是2的k-1次方。

于是，快速幂算法隆重登场。

首先，快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(b)也即是O(n)级别，快速幂能做到O(logn)，快了好多好多。它的原理如下：

　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)

　　11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a^(2^0)×a^(2^1)×a^(2^3)，也就是a^1×a^2×a^3，看出来快的多了吧

原来算11次，现在算三次，但是这三项貌似不好求的样子....不急，下面会有详细解释。 　　由于是二进制，很自然地想到用位运算这个强大的工具：&和>> &运算通常用于二进制取位操作，例如一个数 & 1 的结果就是取二进制的最末位。还可以判断奇偶x&1==0为偶，x&1==1为奇。 >>运算比较单纯,二进制去掉最后一位，不多说了，先放代码
```cpp
ll power(ll a,ll k){
    ll res=1;
    while(k){
        if(k&1)(res*=a)%=mod;
        k>>=1,(a*=a)%=mod;
    }
    return res;
}
```
代码很短，死记也可行，但最好还是理解一下吧，其实也很好理解，以k==11为例，k=>1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)×a^(2^1)×a^(2^3)，是从左向右的。我们不断的让a*=a目的即是累乘，以便随时对ans做出贡献。

然后,附上AC代码（快速幂部分就写在主函数里了）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read(){
    ll a=0,b=getchar(),c=1;
    while(!isdigit(b))c=b=='-'?-1:1,b=getchar();
    while(isdigit(b))a=a*10+b-'0',b=getchar();
    return a*c;
}
ll k,sum=2,ans=1,mod=123456789;
int main(){
    k=read()-1;
    while(k){
        if(k&1)(ans*=sum)%=mod;
        k>>=1,(sum*=sum)%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```
~~再做一个广告哈~~

~~(中国金坷垃运输专用车，缓缓驶来.....)~~

~~日、非:(两人互相挤着正面拦住货车)金坷垃!金坷垃!我们的!我们的!金坷垃!我们的!~~

~~(满载金坷垃的小货车被截住了...)~~

~~美:(走下车)你们想干什么?~~

~~日、非:金坷垃!金坷垃!我们的!我们的!~~

~~非:我要金坷垃!非洲农业不发达，必须要有金坷垃!~~

~~日:我要金坷垃!日本资源太缺乏，必须要有金坷垃!~~

~~日、非:金坷垃!……(日和非扭打 抢金坷垃)~~

~~非:妈妈的!金坷垃,是我的!(非打了日一拳，眼镜掉了)~~

~~美:(拉开两人)不能打架!不能打架!金坷垃好处都有啥? 谁说对了就给他!~~

~~非:(多次挥动手刀)肥料掺了金坷垃，不流失~不蒸发~零浪费!~~

~~日:(夺过金坷垃)肥料掺了金坷垃，能吸收两米下的氮磷钾!~~

~~非:世界肥料都涨价，肥料掺了金坷垃! 一袋能顶两袋撒!~~

~~日:用了金坷垃，小麦亩产一千八，日本的粮食再也不向美国进口啦! 哈哈哈哈哈!~~

~~美(心理台词):小鬼子，真不傻! 金坷垃给了他， 对美国农业威胁大， 绝不能给他!~~

~~美:非洲农业不发达 ，我们都要支援他。金坷垃，你们日本别~想~啦!~~

~~日:狡猾! 狡猾! 没有金坷垃，怎么种庄稼?金坷垃!金坷垃!(撕心裂肺地说)~~

---

## 作者：Aw顿顿 (赞：5)

我们需要用快速幂。

因为：

若 $b|a$ 且 $a-b=k$ 则 $a=2^k,b=2^{k-1}$。

所以答案是 $2^{k-1}$。

放置一下核心代码块：

```cpp
inline ll quickpow(ll a,ll b){
    ll s=1;
    while(b){
        if(b&1)s=(s*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return s%mod;
}
```

然后读入方面进一步优化，手写快读：

```cpp
inline ll read(){
    ll s=0,f=1;
    char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!=EOF){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*f;
}
```

主程序部分：
```cpp
int main()
{
    f=read();
    if(f==1){
        putchar('1');
        return 0;
    }
    printf("%lld\n",quickpow(2,f-1));
    return 0;
}
```

然后注意读程序，当中有 $1$ 个宏定义，有变量，注意学习的时候不要漏了，另外，请勿抄袭。

今天的讲解就到这里了，谢谢！

---

## 作者：HPXXZYY (赞：3)

$\color{blue}{\texttt{[problem]}}$

假设现在又一个 $x$，下一秒 $x$ 可以减去自己的一个约数（但是同一个数不能被同时被减多次）。比如 $10$ 可以减 $2$ 变成 $8$，但是 $8$ 不能再减 $2$ 变成 $2$，因为 $2$ 已经用过了。如果 $x$ 可以通过若干次变化变成 $1$，则我们叫 $x$ 为 `好数`，求第 $k$ 小的 `好数` 对 $123456789$ 取模的结果。

-------------------------------------

$\color{blue}{\texttt{[Solution]}}$

正难则反，直接想哪些数可以变化得到 $1$ 不好想，我们考虑从 $1$ 可以变化到哪些数。

很简单，我们发现只有 $2$ 才能转移到 $1$。然后我们考虑哪些数可以转移到 $2$。

因为 $1$ 已经被用过了，所以我们发现只有 $4$ 才可以转移到 $2$（本来 $3$ 也可以的，但是 $1$ 已经用过了）。同理，$4$ 只能由 $8$ 转移来，$8$ 只能由 $16$ 转移来……

发现了什么？没错，答案就是 $2^{k-1} \bmod 123456789$！用快速幂算法，可以 $O(\log k)$ 解决这道题。

--------------------------------------

$\color{blue}{\texttt{[code]}}$

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606135104795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

---

## 作者：_Imaginary_ (赞：2)

~~今天是个特殊的日子~~

## 思路

### 方法1：倒推

$1$ 绝对可行，原因就是题目已经给出了。

接下来看2. 2 也可以，因为减去 1 就可行了。

然后看3. 3 只能减去1， 可是减去 1 后就不能再减一次1了，所以 3 不行。

最后看看4. 4只要减去 2 就可以。

……

我们发现，任何一个正整数n都能写成两种形式之一：

1. $n=2^k$ ，这样由数学归纳法，每次减去 $2^{k-1}$，显然可行。

2. $n=2^{k_1}+2^{k_2}+...$，并且 $k_1$ 最小。那么下一次做减法要么不是 2的幂，减完后的形式依旧是这样；要么是 $2^{k_1}$ ，此时剩余的数中做减法必定会用到 $2^{k_1}$，显然不成立。

所以，我们得出所有2的幂都是可行的，其他的都不可行。

答案就是 $2^{k-1}$ .

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long p=123456789;
long long MI(long long a,long long b)//a^b
{
	long long ret=1,tmp=a;
	while(b)
	{
		if(b&1)
		{
			 ret = ret*tmp%p;
		}
		b>>=1;
		tmp=tmp*tmp;
		tmp%=p;
	}
	return ret;
}
long long n;
int main()
{
	cin>>n;
	cout<<MI(2,n-1);
	return 0;
}

```

### 方法2：打表

这种方法我尝试过。

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| AC | AC |WA  | AC | WA |WA  |WA  |AC  |WA  |WA  |

(AC表示可以，WA表示不可以)

能猜出是 $2^{k-1}$ 。

### ~~方法3：看题解~~

~~完结撒花~~

---

## 作者：nydzsf_qwq (赞：2)

先算一下前几个

|    k     |   ans    |
| :------: | :------: |
|    1     |    1     |
|    2     |    2     |
|    3     |    4     |
|    3     |    8     |
|    4     |    16    |
| $\vdots$ | $\vdots$ |

答案应该就可以猜到了，是 $2^{k-1}$。

但是怎么证明呢？

---

设原来的数是 $x$，跳的深度为 $y$。

则 $y|x$，可设 $x=ay$。

此时 $x-y=ay-y=(a-1)y$ 是 $y$ 的倍数。

所以假设跳后的数是 $t$，这次跳的深度一定是 $t$ 的约数。

我们可以倒推。

最后结果是 $1$，所以最后一次跳的数只能是 $1$ 的约数，只能是 $1$。

所以在跳最后一次之前一定是 $2$，而且在跳到 $2$ 后还需要跳 $1$。

假设从前往后推 $t$ 次后结果是 $2^{t}$，且还需要跳 $2^{0}、2^{1}、\cdots、2^{t-1}$。

则推第 $t+1$ 次时。

$2^{t}$ 的所有约数仅剩下 $2^{t}$ 可选，所以只能由 $2^{t+1}$ 跳到，且还需要跳的数有  $2^{0}、2^{1}、\cdots、2^{t}$。



在 $t=1$ 时假设成立。

所以由数学归纳法可知所有数均为 $2$ 的自然数次幂，从小到大依次为 $2^{0}、2^{1}、2^{2}、\cdots$。

因此答案为 $2^{k-1}$。

这时我们只需要用上快速幂就可以 AC 这道题了。

---

简单的代码：

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=123456789;
ll k;
ll ksm(int a,ll b) {
	if(b==0) return 1%mod;
	if(b&1) return 1ll*ksm(1ll*a*a%mod,b>>1)*a%mod;
	return ksm(1ll*a*a%mod,b>>1)%mod;
}
int main() {
	scanf("%lld",&k);
	printf("%d",ksm(2,k-1));
	return 0;
}
```

---

## 作者：liangsheng (赞：2)

~~来一发解释较完整的题解~~

以下属于我手推出来的,若有错误,还请各位dalao指出 orz orz

#### 倒推方法:

* 当 k = 1 时: 很明显答案为 1

* 当 k = 2 时: 我们设 y 是 x 的因子

故 x % y == 0 即 x = ay (a为常数)

又 x - y = 1 (题意)

==> ay - y = 1

==> y(a - 1) = 1

==> y = 1 / (a - 1)

因为 y 是正整数 所以此时 a 只能取 2

故 a = 2, x = 2, y = 1

* 当 k = 3 时: 我们设 y 是 x 的因子

故 x % y == 0 即 x = ay (a为常数)

又 x - y = 2

==> ay - y = 2

==> y(a - 1) = 2

==> y = 2 / (a - 1)

因为 y 是正整数 所以此时 a = 2 或 a = 3

	1) 当 a = 3 时 x = 2 y = 1

因为当k=2时,我们已经用过了因子1,所以此种情况舍去

	2) 当 a = 2 时 x = 4 y = 2

通过此种方法,自己手推一下k=3....之后的情况

------------
#### k取值: 1 2 3 4 5 ...

#### 结果: 1 2 4 8 16 ...

------------

#### 这里我们可以发现答案就是 2^(k-1)

直接上快速幂就完事儿了~

```
#include <iostream>

using namespace std;

typedef long long ll;

const ll mod = 123456789;
ll k;

ll ksm(ll a, ll b) {
    ll ans = 1, base = a;
    while(b) {
        if(b & 1) {
            ans *= base;
            ans %= mod;
        }
        base *= base;
        base %= mod;
        b >>= 1;
    }
    return ans;
}

int main() {
    cin >> k;
    cout << ksm(2, k - 1) << endl;
    return 0;
}
```

---

## 作者：CJHGOD (赞：1)

# 介绍一种新的快速幂解法（看下面）

```cpp
int pow(int a,int b,int mod)
{
    int ans=1,base=a%mod;// ans：幂的结果；base：底数a
    while(b)
    {
        if(b&1)//b%2==1；
        {
        	ans=ans*base%mod;//幂
        }
        base=base*base%mod;
         b>>=1;//b*=2；
    }
    return ans;
}
```

(这里的int要改成long long)

[简书上是这么说的](https://www.jianshu.com/p/ec0b97676c3e)

还是原来的a^b，我们会发现，其实指数b是可以拆成二进制的。通过式子a^{m+n} = {a^m*a^n}，我们可以发现，一旦指数b拆成二进制，那么a^b也可以进行相应的拆分。

要求a^{11}，我们只需要进行3次计算，而用朴素算法我们需要进行11次计算。

因为base* base==base^2，下一步再乘，就是base^2*base^2==base^4，然后同理
base^4*base^4==base^8，由此可以到
base-->base^2-->base^4-->base^8-->base^16-->base^32.......

## 懂了这些我们就可以上代码了

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define mo 123456789//define是个好东西
using namespace std;
long long pow(long long a,long long b,long long mod)
{
    long long r=1,base=a%mod;
    while(b!=0)
    {
        if(b%2) r=r*base%mod;
        base=base*base%mod;
        b>>=1;
    }
    return r;
}
int main(){
	ios::sync_with_stdio(0);
	long long n;
	cin>>n;
	cout<<pow(2,n-1,mo);
    return 0;
}

```


---

## 作者：UhhhQQQU (赞：1)

~~这题有提高+难度吗？~~

好了，我们来进入正题。

首先，我们看到这一道题，（哇！提高+难度！ 啪！这不重要QAQ）题面貌似挺正常的，看起来就是一个模拟，直到···

>对于100%的数据，k<=10^18

这怎么弄？这种数据连$O(n)$都过不了啊？

自然而然地，我们会想到这可能会是$O(log n)$或$O(1)$复杂度的(O(1)肯定不可能）

于是乎我们就只能求助于打表找规律，然后···

| k| ans
| :----------: | :----------: |
| 1| 1|
| 2| 2
| 3|4
| 4| 8|
| 5| 16
| 6| 32
| 7|64
| 8|128

我们可以发现以下规律：

$$ans=2^{k-1}$$

规律发现是发现了，但是我们如果用朴素的$O(n)$求乘方的方法，将会TLE，那么，我们就需要一种更快的计算乘方的算法——快速幂

## 快速幂

我们来观察一下一个乘方的式子：

$$a=b^k$$

我们可以把这个式子拆为

$$a=b*b*b*b*b*···*b$$

其中，这里有k个b。然后，我们把它再合起来

$$a=b^{ \frac{k}{2}}*b^{ \frac{k}{2}}$$

所以，我们在计算a的时候，并不用把所有的b全部乘起来，只用计算$b^{ \frac{k}{2}}$就可以了，这样的复杂度是$O(logn)$的！

下面给出一个简单的快速幂模板（用了一点位运算，提升速度）

```
inline long long quickpow(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1)ans*=a,ans%=mod;
		a*=a,a%=mod,b>>=1;
	}
	return ans;
}
```
然后，我们就愉快地A掉了这题啦！

---

## 作者：龙行龘龘 (赞：0)

# 论快读的坑爹性

不造你们发没发现...

无论是快速幂和快乘时,快读都是个锅

这题再次成功背起了guo

改了半个小时,结果就是一快读...

这题其实很简单啊,快速幂板子

顺便献上我的blog:https://www.luogu.org/blog/Root-std-admin/

改前:
```cpp
//Written By:Jason_Root
//Time Limit : 1000 MS
//Memory Limit : 65536 KB
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read() {
	char ch = getchar();
	int x = 0, f = 1;
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while('0' <= ch && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}
ll Power(ll x,ll y,ll p) {
	ll ans = 1;
	while(y) {
		if(y&1) {
			ans = ans*x%p;
		}
		y>>=1;
		x = x*x%p;
	}
	return ans;
}
void func() {
	ios_base::sync_with_stdio(false);
	ll k = read();
	if(k == 1){
		printf("1");
		return;
	}
	printf("%lld",Power(2,k-1,123456789));
}
int main(int argc, char const *argv[]) {
	func();
	return 0;
}
```
死活80分,1WA,1T

改后:
```cpp
//Written By:Jason_Root
//Time Limit : 1000 MS
//Memory Limit : 65536 KB
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll Power(ll x,ll y,ll p) {
	ll ans = 1;
	while(y) {
		if(y&1) {
			ans = ans*x%p;
		}
		y>>=1;
		x = x*x%p;
	}
	return ans;
}
void func() {
	ios_base::sync_with_stdio(false);
	ll k;
	scanf("%lld",&k);
	if(k == 1) {
		printf("1");
		return;
	}
	printf("%lld",Power(2,k-1,123456789));
}
int main(int argc, char const *argv[]) {
	func();
	return 0;
}
```
真心感谢大家观看,谢谢!!!

---


# [COCI 2010/2011 #2] PUŽ

## 题目描述

蜗牛爬井问题：一只蜗牛要爬上 $v$ 米高的树桩，它每天白天向上爬 $a$ 米，晚上向下掉 $b$ 米。几天之后它可以爬到树桩顶？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq  b < a \leq v \leq 1 \times 10^9$。

#### 说明

- 本题满分 $30$ 分。
- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) PUŽ，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

#### 提示

请推导结果公式，单纯的模拟可能导致 `TLE`。

## 样例 #1

### 输入

```
2 1 5```

### 输出

```
4```

## 样例 #2

### 输入

```
5 1 6```

### 输出

```
2```

## 样例 #3

### 输入

```
100 99 1000000000```

### 输出

```
999999901```

# 题解

## 作者：Utilokasteinn (赞：16)

大水题，但是还是错了一次，半分钟打出一个暴力求解，结果TLE了5个点，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int v,a,b,s=0;
	cin>>a>>b>>v;
	for(int i=1;s+=a;i++,s-=b)
		if(s>=v)cout<<i,exit(0);
}
```
然而正解是O(1)输出，当然TLE。

很容易发现，如果直接将v/(a-b)会出错。因为如果白天已经到了，就不用往下滑了。所以，先将高度减去一个白天上升的高度，然后再除以a-b的差，如果有余数，就要天数就要+1，或者直接用ceil函数(向上取整)，最后还有加上刚开始减去的那个白天，也就是天数+1，所以得出的公式是ceil(1.0*(v-a)/(a-b))+1，但是，由于ceil返回的数是浮点数，所以最后还有强制类型转换。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,v;
    cin>>a>>b>>v;
    cout<<int(ceil(1.0*(v-a)/(a-b))+1);
    return 0;
}
```
谢谢观赏。

---

## 作者：Egg_eating_master (赞：2)

难道说，这就是传说中的蜗牛爬井问题？

~~太水了吧~~

一个公式解决的事啊

~~不会的把小学二年级再读一遍~~

这里只介绍一个$\operatorname{ceil}$函数，`ceil(x)`返回$x$上取整的值。

还有个坑点就是要！开！long！long！

其他的各位大佬这么牛，肯定都不需要解释了
```
#include<bits/stdc++.h>
using namespace std;
long long a,b,v;
long long ans;//十年OI一场空，不开longlong见祖宗
int main(){
	cin>>a>>b>>v;
	ans=ceil(1.0*(v-a)/(a-b))+1;//直接套公式
	cout<<ans<<endl;
	return 0;//Happy Ending~
}
```


---

## 作者：宇宙纪念册 (赞：2)

- [这道题](https://www.luogu.com.cn/problem/P6546)

这道题目是经典的`蜗牛爬井问题`（数学问题）

刚开始想的暴力，15分，TLE了5个

优化一下：

- 我的代码:

```
#include<bits/stdc++.h>
using namespace std;
int v,a,b,ans;
int main()
{
    cin >> a >> b >> v;
    v -= a;
    ans = ceil(1.0 * v / (a - b)) + 1;
    cout << ans;
    return 0;
}
```
- 思路：

首先声明变量，a,b,v题目中均对应题目，ans表示需要的天数

要用到ceil，表示向上取整

就是先用v-a

然后用v / (a-b)向上取整，最后加一结束

`+1`的原因是如果蜗牛白天爬出去了晚上就不用下降

点个赞再走吧~

---

## 作者：sh7adow_ (赞：1)

### 说在前头
好一道经典的数学题！小学奥数必备。
### 思路
这个数学公式其实很简单。

给定井深 $a$ ，每天爬行 $b$ 米，每天掉下来 $c$ 米，那么公式就是：

$$\dfrac{a-b}{b-c}+1$$

如果$\dfrac{a-b}{b-c}$有余数，那么再加一。

于是加上 **快读** 和 **O2优化** 就可以AC本题了。

由于这道题很简单，所以代码就不给了，要的话就私信我就可以了。
### 最后的宣传

求过！~~还有安利一波[Legends Never Die](https://y.qq.com/n/yqq/song/00394z9S2ciPAD.html?play=1)来祝zhouwc高考顺利！~~

---

## 作者：LiveZoom (赞：0)

# 题解 P6546 【[COCI2010-2011#2] PUŽ】
~~本题是道蜗牛爬井的模板题~~，不会蜗牛爬井的请看这里：

<https://wenku.baidu.com/view/b708a02d5fbfc77da369b1d4.html>

题目就是：蜗牛要爬$v$米的树，上午爬$a$米，下午爬$b$米，问你它至少要爬多少天。

1. 暴力枚举天数

$i$从$1\sim\infty$之间枚举，用个计数器来记下来现在的高度。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int a, b, v;

int main() {
	cin >> a >> b >> v;
	int tot = 0;
	for (int i = 1; ; ++i) {
		tot += a - b;
		if (tot >= v) {
			cout << i << endl;
			return 0;
		}
	}
	return 0;
}
```
咦？为什么WA了呢？

原来在```tot+=a - b```的这个地方如果上午已经爬上去了，下午有掉下$v$了，就出问题了。

改进后的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int a, b, v;

int main() {
	cin >> a >> b >> v;
	int tot = 0;
	for (int i = 1; ; ++i) {
		if (tot + a >= v){
			cout << i << endl;
			return 0;
		}
		tot += a - b;
		if (tot >= v) {
			cout << i << endl;
			return 0;
		}
	}
	return 0;
}
```
发现TLE了，因为我们每次都用$O(1)$的效率来爬一天，那么时间复杂度就是$O(\frac{v}{a-b})$，极限情况下就是$a=b+1,v=10^9$，显然TLE。

2. 用蜗牛爬井公式

蜗牛爬井的公式就是$\lceil\frac{v-a}{a-b}\rceil+1$，代码这样写：

```cpp
#include<bits/stdc++.h>
using namespace std;

int a, b, v;

int cei (int x, int y) {//自定义取上整
	if (x % y == 0) return x / y;
	else return x / y + 1;
}

int main() {
	cin >> a >> b >> v;
	cout << cei((v - a), (a - b)) + 1 << endl;//套公式
	return 0;
}
```

求通过

# The end

---

## 作者：CCCloud (赞：0)

## 简单的思维题目  
**题目大意**：一只蜗牛要爬上 $v$ 米高的树桩，它每天白天向上爬 $a$ 米，晚上向下掉 $b$ 米。几天之后它可以爬到树桩顶?  
**误区**：只要蜗牛**超过树桩顶**就可以了，**不一定是在掉落下来后**；

------------

### 思路1：模拟一遍  
如果**超过了**树桩顶，那么就**输出**当前所用的时间，否则就一直**循环**下去：  
代码如下：
```cpp
while(1)
    {
        t+=a;//累加
        ans++;//时间++
        if(t>=n)//如果大于
        {
            printf("%d\n", ans);//输出
            return 0;//结束程序
        }
        t-=b;//减去b
    }
```   
当然这种做法是**超时**的；  
那么有没有**更快**的做法呢？  


------------
### 思路2：找规律  
观察样例得知，假设 $ans$ 为蜗牛爬的天数，那么前 $ans-1$ 天蜗牛每天只爬了($a-b$)米，第 $ans$ 天爬了a米，然后超过了树桩；  
所以前 $ans-1$ 天爬的总和也就小于 $n$  
那么我们就可以得到**公式**：  
```cpp
ans=ceil((n-a)*1.0/(a-b))+1；//不能忘记×1.0!
```
其中 $ceil$ 是**向上取整**，如果**有余数**，那么就**进一**；  
那么这道题就可以**AC**了!


---


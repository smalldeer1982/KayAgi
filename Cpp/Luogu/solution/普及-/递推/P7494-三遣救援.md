# 三遣救援

## 题目背景

>就像第一块多米诺骨牌，那个人的出现开启了后面的故事。

穆罗在家里养了许多猪。在他的训练下，这些猪都十分乖巧。当然，有的时候这些猪也会变得十分调皮……

## 题目描述

一天早上，穆罗发现自己私存的一块蛋糕被偷吃了！他立即猜到某只猪吃了这块蛋糕，于是迅速赶到猪圈决定找出这只猪进行惩罚。

猪圈里有 $n$ 只猪，猪的序号是 $1$ 到 $n$ 之间的整数。除了偷吃了蛋糕的那只猪，其他所有猪**一样重**，而那只偷吃了蛋糕的猪会比其他猪**略重一些**（你可以假设原本猪是 $5\text{kg}$ 的，那只吃了蛋糕的猪是 $5.1\text{kg}$ 的）。穆罗无法肉眼判断是哪只猪吃了蛋糕。

幸运的是穆罗有一个天平，可以将猪赶上天平两侧，从而比较出哪边的猪更重。不过这个天平不是很大，每侧最多只能有 $m$ 只猪，否则天平就会损坏导致无法使用（偷吃蛋糕的猪**不会使天平一侧可放置的猪的数目减少**，即**无论猪是否偷吃，每侧都最多只能有 $m$ 只猪**）。

穆罗不想花费太多的时间，所以他希望知道在**天平不损坏**的前提下，**至少需要使用几次天平称量才能保证找出这只偷吃了的猪**。他希望你能求出这个数。

## 说明/提示

#### 样例一解释：

穆罗先让 $1$ 号猪和 $2$ 号猪分别上天平两侧，再让 $3$ 号猪和 $4$ 号猪分别上天平两侧，此时一定能找出偷吃了的猪，使用天平次数为 $2$。显然只使用一次天平无法保证能找出那只偷吃了的猪。

#### 样例三解释：

天平两侧最多都只能放两只猪，所以至少需要三次才能保证找出。

------------
#### 数据范围

**本题采用捆绑测试。**

+ Subtask 1 ( $10\%$ )：$n,m\leq10$。
+ Subtask 2 ( $25\%$ )：$n,m\leq10^6$。
+ Subtask 3 ( $15\%$ )：$n\leq m$。
+ Subtask 4 ( $50\%$ )：无特殊限制。

对于所有数据，$1\leq n,m\leq10^{15}$。

## 样例 #1

### 输入

```
4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
13 6```

### 输出

```
3```

## 样例 #3

### 输入

```
8 2```

### 输出

```
3```

## 样例 #4

### 输入

```
114 514```

### 输出

```
5```

## 样例 #5

### 输入

```
19198 10```

### 输出

```
962```

# 题解

## 作者：_lfxxx_ (赞：28)

## 题意：
有 $n$ 个硬币，有一个重了。给你一个两边最多能称 $m$ 个硬币的天平 ，求**至少**称几次能**保证**称出来重了的那个硬币。
## 思路：
~~小学四五年级芝士~~

**三分法**：每次平均分成三堆，称一次，可以找出硬币在三堆中的一堆。

先不考虑 $m$ ，则只要称 $\lceil\log_3n\rceil$ 次即可。

接下来再考虑 $m$ ，我们可以将 $n$ 分成这三堆：

$m$ ， $m$ ， $n-2m$ 。

当 $n-2m\leq m+1$ 时即 $n\leq3m+1$ 时就可以不用考虑 $m$ 了。即需要称 $\lceil\log_3n\rceil$ 次。

如果不符合，最坏的情况是每次只能筛掉 $2m$ 个，所以每次 $n$ 减去 $2m$ 。

即：
```cpp
while(n>3*m+1){
	n-=2*m;
	s++;
}
```
但这样做浪费了大量的时间，所以我们可以换成除法。
即 $\lfloor\dfrac{n-3m-1}{2m}\rfloor+1$ 。

此时 $n\gets n-(\lfloor\dfrac{n-3m-1}{2m}\rfloor+1)\cdot 2m$

综上，如果设 $a=\lfloor\dfrac{n-3m-1}{2m}\rfloor+1$ ，当 $n>3m+1$ ，称的次数为 $a+\lceil\log_3(n-a\cdot 2m)\rceil$ 。当 $n\leq3m+1$ 时，称的次数为 $\lceil\log_3n\rceil$ 。
## 注意事项：
最后算 $\log_3n$ 时，用乘法比较，因为除法会自动向下取整，并且乘法还快一些。
## 代码：
```cpp
#include<cstdio>
int main(){
	unsigned long long n,m,s=0,a,i;
	scanf("%llu%llu",&n,&m);
    a=(n-3*m-1)/(2*m)+1;
    if(n>3*m+1){
        s=a;
        n-=a*2*m;
    }
    i=1;
    while(n>i){
		i*=3;
		s++;
	}
    printf("%llu",s);
	return 0;
}
```
因为内容较多，可能有错误，如果有神犇找出本蒟蒻的错误，请在评论区指出。
### 更新：
`2021-05-30`：将一处中括号改成小括号。

---

## 作者：littleKtian (赞：22)

小学数学题（bushi）。

------------

这题的关键点是如果将猪分成三组且前两组猪数量相等，那么只要将前两组猪分别放在天平两侧进行一次称量，即可知道要找的猪在三组中的哪一组。

设 $f(x)$ 为猪的数量为 $x$ 时的答案。显然 $f(1)=0$，且当 $m$ 不变时，$f(x)$ 单调不下降。

可以发现每次分组时让三组中猪数量最多的那组猪数量最小时更优，考虑如何分组。

先不考虑 $m$ 的限制。

+ $n=3k$

显然此时令三组猪的数量均为 $k$ 时是最优的。

+ $n=3k+1$

此时令前两组猪数量为 $k$，最后一组为 $k+1$ 最优。

+ $n=3k+2$

令前两组猪数量为 $k+1$，最后一组为 $k$ 最优。

于是有递推式 $f(x)=f(\left\lceil\dfrac{x}{3}\right\rceil)+1$。

现在考虑加上 $m$ 的限制后会有什么影响。

发现只有当 $x\geq 3m+2$ 时才会对我们原先的策略产生影响。实际上此时的递推式也很容易发现是 $f(x)=f(x-2m)+1$。

综合起来，有 $f(x)=\begin{cases}0&x=1\\f(\left\lceil\dfrac{x}{3}\right\rceil)+1&0<x<3m+2\\f(x-2m)+1&x\geq 3m+2\end{cases}$。

实际上上面递推式的 $3m+2$ 换成 $3m+1$ 或 $3m$ 也能得到同样结果。

现在的问题是怎么计算 $f(n)$。容易发现上面式子第二部分直接递归就是 $O(\log m)$ 的，而第三部分每次规模都是 $-2m$，可以直接推式子 $O(1)$ 求出。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m;
ll f(ll x)
{
	if(x==1)return 0;
	if(x>3*m){ll k=(x-3*m-1)/(2*m)+1;return f(x-k*2*m)+k;}
	return f((x-1)/3+1)+1;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	printf("%lld",f(n));
}
```

---

## 作者：pinking_tree (赞：15)

# P7494题解
这是本蒟蒻的第一篇题解，望dalao多加指导，谢谢！

接下来**切入正题**。

## 题意


------------
猪圈里有 $n$ 只猪，有一只猪偷吃了蛋糕。其他所有猪一样重，而那只偷吃了蛋糕的猪会比其他猪略重一些，穆罗无法肉眼判断是哪只猪吃了蛋糕。幸运的是穆罗有一个天平，可以将猪赶上天平两侧，从而比较出哪边的猪更重。不过这个天平不是很大，每侧最多只能有 $m$ 只猪，否则天平就会损坏导致无法使用（偷吃蛋糕的猪不会使天平一侧可放置的猪的数目减少，即无论猪是否偷吃，每侧都最多只能有 $m$ 只猪）。

## 题解
这道题涉及到（~~小学奥数里的~~）**三分法**。

三分法是这样的：

设能保证用天平从 $n$ 个硬币找已知比其他硬币重（或轻）的次品硬币的最小次数记为 $f(n)$ ，则有

$f(n)=log^3n$ ，其中 $log^3n$ 向下取整。

如果想到这一点，你就离 AC 不远了！

接下来我们把 $m$ 加进来

考虑两种情况：

第一种：$n≤3m$

直接三分。

第二种：$n>3m$

碰上这种情况，咱们先不停的让 $n$ 减 $2m$ ，直到$n≤3m$ ，把减的次数和 $f(n)$ 加起来输出。

有人说，我少减一个 $2m$ ,把 $f(n)$（当然是减完的） 换成 $f(2m)$ 不行吗，万一换完答案更大呢（即出现 $f(n)<f(2m)-1$ ）？

我认为，这种情况需要考虑，虽然不考虑也可以 AC （不知道是数据太弱还是本来就不需要考虑，若是后者请dalao指点）。

如果需要考虑的话，那就把输出的数从减的次数加 $f(n)$ 换成减的次数加 $max(f(n),f(2m)-1)$ 即可。

总而言之就是这些东西：

```cpp
if(n<=3*m)cout<<ff(n);
else{
	//
	n-=(3*m);
	long long cnt=n/(2*m),cnt2;
	n%=(2*m);
	if(n!=0){
		n-=(2*m);
		cnt++;
	}
	n+=(3*m);
	//
	//以上两个斜杠之间的代码既是实现不停的让n减2m ，直到n≤3m
	cnt2=cnt-1;
	cnt+=ff(n);
	cnt2+=ff(2*m);
	cout<<max(cnt,cnt2);
	cout<<cnt;
}
```
其中的ff：

```cpp
long long ff(long long n)
{
	long long i=1,j=0;
	while(i<n)i*=3,j++;
	return j;
}
```
还问我为什么开 long long ？请看清楚：

$1\leq n,m\leq10^{15}$

## $Code$:

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
long long ff(long long n)
{
	long long i=1,j=0;
	while(i<n)i*=3,j++;
	return j;
}
int main()
{
	long long n,m,cnt;
	cin>>n>>m;
	if(n<=3*m)cout<<ff(n);
	else{
		n-=(3*m);
		long long cnt=n/(2*m),cnt2;
		n%=(2*m);
		if(n!=0){
			n-=(2*m);
			cnt++;
		}
		n+=(3*m);
		cnt2=cnt-1;
		cnt+=ff(n);
		cnt2+=ff(2*m);
		cout<<max(cnt,cnt2);
	}
	return 0;
}
```

（要个关注鼓励本蒟蒻的第一篇题解不过分吧，qwq）

 

---

## 作者：kkio (赞：5)

# P7494 三遣救援 #

看到这道题, 第一眼是我小学时的奥数题目......

那么这类题有什么特点呢? 每次最快是分三堆处理: $\dfrac{n}{3}$ ,$ \dfrac{n}{3} $ , $n-\dfrac{2n}{3}$ , 每次拿 $\dfrac{n}{3}$ 和 $\dfrac{n}{3}$ 比较,相等的话,就用 $n-\dfrac{2n}{3}$ 再作为 $n$ 分；否则拿重的一堆再分。

但是这里天平有上限,所以当 $\dfrac{n}{3} > m$ 时。修正为分成${m , m , n-2m}$比较。

可以从 $1$ 倒推。每次乘 $3$ 或加 $2m$ 。

打完交上去。
```cpp
#include <cstdio>
using namespace std;
typedef unsigned long long ull;
ull n,m;
int main(){
	scanf("%llu%llu",&n,&m);
	ull check=1;
	ull ans=0;
	while(check<n)
	{
		if(check<=m)
			check*=3,ans++;
		else if(check>m)
			check+=2*m,ans++;
	}
	printf("%llu",ans);
}
```
发现T了几个点。原来当 $m$ 特别小时,会产生巨大的耗时。我们可以用除法解决,
当当前检查完的猪大于 $m$ 后,直接用 $2m$ 除剩下的猪。
## AC代码 ##
```cpp
#include <cstdio>
using namespace std;
typedef unsigned long long ull;
ull n,m;
int main(){
	scanf("%llu%llu",&n,&m);
	ull check=1;
	ull ans=0;
	while(check<n)
	{
		if(check<=m)
			check*=3,ans++;
		else if(check>m)
		{
			ull now=n-check;
			if(now%(2*m)==0)
				ans+=now/(2*m);
			else 
				ans+=now/(2*m)+1;//这里注意要处理整除的情况。
			break;
		}
	}
	printf("%llu",ans);
}
```




---

## 作者：小猪朱qwq (赞：5)

## 题意：
&#x2003;有$n$个硬币，有一个重了。给你一个两边最多能称$m$个硬币的天平，求至少称几次能保证称出来重了的那个硬币。
## 思路
&#x2003;先不考虑上限$m$，我们知道最优的方法是将这堆物品尽可能平均分成三份，称其中两份，平衡就称第三份，反之则称重的那份，直到只剩一个为止（~~不懂的话就回去学小学奥数吧~~）。

&#x2003;然后考虑有上限$m$时，分两种情况：
1. 目前这堆猪的三分之一小于等于$m$，那么直接用上面的方法即可。
2. 目前这堆猪的三分之一大于$m$，那么我们肯定是尽可能多称,那么每次每边就称$m$只猪，为了减少时间，我们一次取多份，让下一次满足条件1，这又分两种情况：
- 当最后剩下那份小于等于$m$，那我们就只能取p-1次（p是我们最多能取的次数），不然不一定会最优。
- 当最后剩下那份大于$m$，那就取p次。

&#x2003;还不理解的话可以画个图理解一下，以下是代码。
## 代码
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
long long n,m,cnt,tmp,p;
int main(){
	scanf("%lld%lld",&n,&m);
	while(1){
		if(n==1) break;
		if(n==2||n==3){
			cnt++;
			break;
		}
		tmp=n/3;
		if(tmp<=m){
			cnt++;			
			if(tmp*3==n) n=tmp;
			else n=tmp+1;
		}else{
			p=n/(m*2);
			if(n-p*m*2>m){
				cnt+=p;
				n=m;
			}else{
				cnt+=p-1;
				n=n-(p-1)*m*2;
			}
		}
	}
	printf("%lld",cnt);
	return 0;
}

---

## 作者：alvis (赞：3)

## 题意
给定 $\text{N}$ 个物体，其中一个的重量比其他物体沉，并给出测量重量上限 $\text{m}$，试求测量重量的最小次数。

## 思路

先不考虑重量上限 $\text{m}$。

很显然，~~通过小学奥数的知识~~我们知道最优的方案是将这堆物体均分成 $\text{3}$ 份，称量其中两份。

如果其重量相等，那么我们再称量第三份。

同理，一直重复上述步骤直到剩 $\text{1}$ 个物体。

显然，上述步骤需要称量 $\lceil \log_3 n\rceil$ 次。

接下来，我们考虑重量上限 $\text{m}$。

认真思考，我们发现只有 $\text{n}\ge \text{3m+2}$ 时才会对我们的结果产生影响。

为什么？

显然当 $\text{n}\ge \text{3m+1}$ 时，每次三分出来的结果都会比重量上限 $\text{m}$ 大。并且此时每次都称量重量上限 $\text{m}$ 的重量，最后剩下的 $\text{n-2m}$ 一定大于等于 $\text{m}$。

所以，当 $\text{n}\ge \text{3m+1}$ 时，我们就可以用除法来处理。即为$\lfloor \dfrac{n-3m-1}{2m} \rfloor \text{+1}$。

然后我们就可以将问题转化为不用考虑 $\text{m}$ 的情况。
## tips

对于不考虑 $\text{m}$ 的情况， 可以直接用 $\text{cmath}$ 库中的 $\text{log}$ 函数来求解。

直接使用换底公式即可。

本代码的时间复杂度大概$\operatorname{O(log_n)}$。（毕竟我也不太会算
## 代码
```cpp
#include <bits/stdc++.h>
typedef unsigned long long ll;
using namespace std;
//快速幂
ll quickpow(ll a,ll b){
    ll res=1;
    while(b>0){
        if(b&1)
            res=(res*a);
        b>>=1;
        a=a*a;
    }
    return res;
}
//求不考虑m的情况
ll lognum(ll n){
	//换底公式
	ll k = ll(log(n)/log(3));
	//特判n == 1 的情况
	if(n == 1)return 0;
	//处理向上取整
	if( n % 3 != 0 || n % 3 == 0 && quickpow(3,k) < n)k ++;
	return k;
}
//考虑m的情况
ll bignum(ll n, ll m){
	ll k = ll(n - 3*m - 1) / ll(2*m)+1;
	return k;
}

int main(){
	ll n,m,t;
	cin >> n >> m;
	if(n < 3*m+2) t = lognum(n);
	else t = bignum(n, m) + lognum(ll(n - bignum(n, m)*m*2));
	cout << t ;
return 0;
}

```


---

## 作者：_Diu_ (赞：2)

~~抢一道红题题解比一道黑题题解还难。 TnT~~

这一道题是从一个很~~简单~~的小学奥数题扩展来的。

## 小学数学小推理

- 有 $n$ 个球，其中有一个质量与其他的不一样，有一个天平，求最少称几次能保证称出来那个球。

答案就是 $\lceil\log_3n\rceil$。

证明：

- 当 $n\%3=0$ 时：

把 $n$ 个球平均分成三份，

选择两份放到天平两边，

若平衡则那个球在另外一堆，

否则在这两对中的其中一堆。

- 当 $n\%3=1$ 时：

分成 $n/3,n/3,n/3+1$ 三堆。

处理方法同上。

最坏情况时剩下 $n/3+1$， 方案数同 $n+2$。

- 当 $n\%3=2$：

分成 $n/3,n/3+1,n/3+1$ 三堆。

处理方法同上。

最坏情况时剩下 $n/3+1$， 方案数同 $n+1$。

所以，每一次剩下的数就是 $\lceil n/3\rceil$

答案便是 $\lceil\log_3n\rceil$。

## 回归题目

题目要求两边所称东西质量不超过 $m$。

也就是说，只要所称个数 $n\le3m+1$，

就可以用上述方法。

那么如果 $n$ 超大的呢？

我们也可以将 $n$ 分成三份：

$m,m,n-2m$

前面两个称一下。

因为这时 $n-2m>m$ 绝对成立，

所以继续下去。

前面称的次数就变成了 $\lfloor \dfrac{n-3m-1}{2m}\rfloor+1$。

再继续上述操作。

## code

上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
int get(int n){//求log3 n
	int x=1,s=0;
	while(x<n)x*=3,s++;
	return s;
}
signed main(){
	scanf("%lld%lld",&n,&m);
	int x=(n<=3*m+1)?0:((n-3*m-1)/(2*m)+1);
	n=n-x*2*m;
	printf("%lld",x+get(n));
}
```

---

## 作者：Mysterious_Cat (赞：2)

### 题目思路：
设 $y=f(x)$ 为 $n = x$ 时的答案，则 $f(x)$ 在 $[1,+\infty]$ 上为增函数。

考虑三分，对于 $x \le 3 \times m$，将 $x$ 等分为三份，左右天平各放一份，即可找出所在份，$f(x)=f(\lceil \frac{x}{3}\rceil) + 1$；对于 $x > 3 \times m$，将 $x$ 分为 $m,m,x-2m$ 三份，即可找出所在份，$f(x)=f(x-2m) + 1$。

使用递归，边界为 $f(1)=0$，对于 $x>3\times m$ 一步操作化为 $x \le 3 \times m$即可。

递归部分代码：
```cpp
long long f(long long x)
{
    if(x == 1) return 0;
    if(x <= 3 * m) return f((x - 1) / 3 + 1) + 1;
    long long tmp = (x - 3 * m - 1) / (2 * m) + 1;
    return f(x - tmp * 2 * m) + tmp;
}
```


---

## 作者：SpeMars (赞：1)

众所周知这道红题是一道~~黑题~~好题。

这道题我们可以先假设一个函数 $f(x)$ 为当前猪总数为 $x$ 时的最坏情况的操作次数。

那么~~显然~~ $f(x)=0$ 也就是不用称就知道了。

~~解锁成就:未卜先知~~。

那么对于 $x>1$ 时我们如何考虑呢？

我们先不考虑 $m$ 的限制，并将 $x$ 分为三组。

由于一个整数除以三的余数只可能为 $0,1,2$ 所以对于任意 $x$， $x$都可以表示为:

① $x=3k$

② $x=3k+1$

③ $x=3k+2$

注:以下的“\”均为向下取整。

我们先看情况①。

我们的最优策略一定是分成三组。

group1: $k$

group2: $k$

group3: $k$

~~顺便 mod 一下 kkk~~

我们称完 group1 & group2 后。

这样我们只需要称一次就能排除掉 $2k$ 只正常的猪。

所以对于当前情况 $f(x)=f(x/3)+1$

对于情况②。

我们的最优策略依然是分成三组。

group1: $k$

group2: $k$

group3: $k+1$

~~显然~~我们称完 group1 & group2 后，最倒霉的情况是两边相等，即重的猪在 group3 中。

因为 group3猪的数量最多，所以此情况最倒霉。

那么对于当前情况 $f(x)=f(x/3+1)+1$

对于情况③。

我们的最优策略又双叒叕是分成三组。

group1: $k+1$

group2: $k+1$

group3: $k$

我们称完 group1 & group2 后。

要使得当前情况最极端(daomei)剩余要处理的猪应该越多(排除的越少)。

那么最多剩下 $k+1$只猪。

则该情况同上，即 $f(x)=f(x/3+1)+1$

综合①②③可以得

## $f(x)=\lceil \dfrac{x}{3} \rceil+1$

但是并没有结束，我们还有一次一边限称重 $m$的限制。

所以上面的式子只在 $x<=3m+1$ 的情况下成立。

因为此时天平两边正好为 $m,m$ 剩余一组 $m+1$ 不能再大了。

所以对于 $x>3m+1$的情况,我们每次可以取出 $2m$ 只猪称重(左 $m$ 右 $m$ )。

即最极端(daomei)情况为每次只排除 $2m$ 只猪。

即可得 $f(x)=f(x-2m)+1$

这里递归时，我们可以用乘法处理(减少递归次数)，那么答案就很明显了。

## code:

```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
using namespace std;
ll n,m;
ll upz(ll x,ll y){return (x+y-1)/y;}//向上取整模板
ll f(ll x){
	if(x==1)return 0;
	if(x<=3*m+1)return f(upz(x,3))+1;
	if(x>3*m+1){
		ll res=x-(3*m+1);//计算需要减少多少个2m才能符合情况②
		ll cnt=upz(res,2*m);//结果上取整
		return f(x-cnt*2*m)+cnt;//加上对应次数
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	printf("%lld",f(n));
	return 0;
}
```

~~人生第一道红题题解...~~

---

## 作者：NSOI (赞：0)

本人第一道红题题解。

[题目传送门](https://www.luogu.com.cn/problem/P7494)

# 分析

如果没有$m$的限制，则$ans=nlog3$。

## but

加上$m$的限制后，发现一次最多减少$2m$只。

而且当$n-2m<m$时就可以**忽略**$m$了！！！

因为你这时候可以左右都随意摆猪了。

把上面的式子左右同时加$2m$后得到：$n<3m$。

代码如下:
```c
while(n){
   n-=2*m;
}
```
但是**时间效率太慢**……

得改成**乘法**！！！

$p.s$:此题要加**long long**！！！

而且在$nlog3$过程中要小心除法**错位**！！！

AC代码：
```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,ans;//要用long long!!!
void calc(){
    scanf("%lld%lld",&n,&m);
	ll a=(n-3*m-1)/(2*m)+1;
	if(n>3*m+1){
        ans=a;
        n-=a*2*m;
    }
    ll x=1;
    while(n>x){//nlog3
        x*=3;
        ans++;
    }
    printf("%lld",ans);
    return ;//记得return ;
}
int main(){
    calc();
    return 0;
}
```
与楼下可能有点像QWQ。

---


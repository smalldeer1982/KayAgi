# 『XYGOI round1』三个数

## 题目描述

MX 有一个有 $(w-2)$ 个数的集合 $S=\{3,4,5,\cdots ,w\}$。要求构造一个只包含非负整数的集合（无重复元素），使得 $S$ 里面的任何一个数都能被这个集合里面大于等于 $3$ 个不同的数相加得到，求这个集合中至少包含多少个元素。

## 说明/提示

#### 样例 1 说明：

集合元素可以为 $0,1,2,3$。

#### 数据范围：

**本题采用捆绑测试。**

对于所有数据，保证 $1\le T \le 10^5$，$3\le w \le 10^{12}$。

| Subtask | $T$ | $w$ | 分值 |
|:-:|:-:|:-:|:-:|
|0|$=1$|$w\le 10$|5|
|1|$1\le T\le 10^3$|$w\le 20$|10|
|2|$1\le T\le 50$|$w\le 10^{3}$|25|
|3|$1\le T\le 10^3$|$w\le 10^{5}$|30|
|4|$1\le T\le 10^5$|$3\le w\le 10^{12}$|30|


## 样例 #1

### 输入

```
1
4```

### 输出

```
4```

## 样例 #2

### 输入

```
5
3
18
999
9999
9999999999```

### 输出

```
3
6
12
15
35
```

# 题解

## 作者：无钩七不改名 (赞：20)

Upd 2024.11.2 改了一点 markdown 错误。

## 出题人题解

首先，$3$ 只有一种拼凑方案就是 $\{0,1,2\}$，所以每个集合一定都包含这 $3$ 个数。

而这 $3$ 个数中选 $2\sim3$ 个数，最多能凑成 $3$，最少能凑成 $1$，选至少三个数只能凑成 $3$，所以集合中第 $4$ 个数选择 $0+1+2=3$，就可以拼凑出 $4\sim6$。同理可得第 $5$ 个数是 $0+1+2+3=6$，因此可以总结出一个递推式：

$$
f_i=f_1+f_2+...+f_{i-1},\forall i\ge 4
$$

又因为：

$$
f_1+f_2+...+f_{i-2}=f_{i-1},\forall i\ge 5
$$

所以：

$$
f_i=2\times f_{i-1},\forall i\ge 5
$$

其中 $f_1=0,f_2=1,f_3=2$。

特殊的，还需要处理出 $f_4=3$。

而每个集合（设有 $n$ 个数）最大能凑成的数就是 $f_1+f_2+...+f_n$，即 $f_{n+1}$。

由于数据范围过大，我选择先预处理出数据范围内的所有 $f$ 数组。输入 $w$ 时，只需二分查找 $f$ 数组中第一个 $\geq w$ 的数，答案便是这个数在 $f$ 数组中的下标 $-1$。



------------

更新于 $2023.7.2$：

有人问我为什么 $\log n\div 3+3$ 是对的。这里解释一下，问题简化一下就是求使得 $3\times 2^{k-3}\ge n$ 成立的最小的 $k$。而很容易看出上面的式子除了前三项其实就是 $f_i=3\times 2^{k-4}$。故结论成立。

---

## 作者：樱雪喵 (赞：4)

终于把在电脑里存丢的题解找到了！

## Description

给定数 $w$，构造一个非负整数集合 $S$ 使 $[3,w]$ 之间所有数都能表示为 $S$ 中至少三个互不相同数的和。求 $S$ 的最少元素个数。

$T\le 10^5,w\le 10^{12}$。

## Solution

首先可以发现，当 $w=3$ 时，$S=\{0,1,2\}$。且对于所有 $w\ge 3$，都要保证 $S$ 里包含这三个数。  

为要构成的数是一个前缀，所以如果 $x-1$ 时的答案集合 $S$ 不能表示出 $x$，新的答案集合一定是原来的 $S$ 加上一个数。  
考虑加上的数为 $x$，原来集合的和为 $sum$。那么分两种情况，不选 $x$ 时，即原集合 $S$。显然可以构造出 $[3,sum]$ 之间的数。而选 $x$ 时，至少要再选两个，也就是可以构造出 $[x+1,x+sum]$ 之间的数。  
既然要让答案最优，肯定尽量不让它能表示的数重复，$x=sum$ 是最优的。  

以此类推，每次 $x$ 都取前面所有数之和一定最优。

设 $f_i$ 表示集合大小为 $i$ 时第 $i$ 位的值，则有：  
$$f_i =\begin{cases}1&x=2\\2&x=3\\ \sum_{x=2}^{i-1} f_x&x>3\end{cases}$$

显然每次 $f_i$ 的值会翻倍，也就是说 $f_i$ 只需要递推到第 $\log w$ 项。  
查询的时候，我们知道对于 $f_i=x$，能够覆盖 $w\in [3,2x]$ 的答案。所以我们直接在 $f$ 数组里二分，找到最小的 $i$ 就是答案。  

预处理时间复杂度 $O(\log^2 w)$，查询复杂度 $O(\log \log w)$，可以通过。  

---

## 作者：yhx0322 (赞：3)

## Description
现在有一个有 $(w-2)$ 个数的集合 $S=\{3,4,5,\cdots ,w\}$。要求构造一个只包含非负整数的集合，使得 $S$ 里面的任何一个数**都能被这个集合里面大于等于 $3$ 个不同的数相加得到**，求这个集合中至少包含多少个元素。

## Solution
看到数据范围 $w \ge 3$，便可以发现集合中必定有 $\{0, 1, 2\}$，相当于是边界条件。

我们发现一个贪心的思想：设集合中所有元素之和为 $x$，**为了使 $x$ 趋近于 $w$，所以每次加入的数必须尽可能地大。**

于是，我们便可以找出规律，每次不断将加入的值 $\times 2$，得到尽可能大的值，当当前集合中所有元素的和 $\ge w$ 的时候，停止，输出答案即可。

**注意本题的数据范围，要开 long long。**

## Code
```cpp
#include <bits/stdc++.h>

#define ll long long

using namespace std;

ll t, w, ans, k;

int main(){
	scanf("%lld", &t);
	while (t--) {
		scanf("%lld", &w);
		k = ans = 3; // 初始化，边界条件
		while (k < w) { ans++; k *= 2; } // 每次不断倍增，直到 k >= w 为止
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：Pink_Cut_Tree (赞：3)

# P9435 『XYGOI round1』三个数 题解

找规律题。

### 规律

我们看到对于 $0,1,2$ 三个数，可满足 $w=3$ 的情况。

对于我们看到对于 $0,1,2,3$ 四个数，可满足 $w=4 \sim 6$ 的情况。

此时问题来了，请问下一个数应该是多少呢？

在赛后与 [Heartquakes](https://www.luogu.com.cn/user/649315) 的交流中，~~我们~~他发现了这样的规律 `0,1,2,3,6,12,24……`。

对于 $7 \sim 12$ 的数，均可用 `0,1,2,3,6` 表示。

对于 $13 \sim 24$ 的数，均可用 `0,1,2,3,6,12` 表示。

以此类推……

### 代码（含具体注释）

```cpp
// C++14 (GCC 9) -O2 by Present_Coming_Time(793625)
#include<bits/stdc++.h>
using namespace std; 
int q;
long long tmp;
int f(long long x){
	if(x<=3){
		return 3;
	}
	if(x<6){
		return 4;
	}
  //以上是特判！
	long long cnt=6;
	int ans=5;
	while(cnt<x){
		cnt*=2,ans++;
	}
	return ans-1; //注意要减1
}
int main(){
	ios::sync_with_stdio(0); //关闭读写同步
	cin>>q;
	while(q--){
		cin>>tmp;
		cout<<f(tmp)<<"\n";
	}
return 0;	
}
```


---

## 作者：Loser_Syx (赞：2)

贪心思路。

考虑当 $w=3$ 时需要只能通过 $\{0,1,2\}$ 凑出，所以 $\{0,1,2\}$ 是必须处于集合内的。

于是可以考虑贪心，$\{0,1,2\}$ 只能凑出 $0,1,2,3$ 这个数，但是可以选择添加一个数 $3$，使得可以凑出来 $3 \sim 6$，发现所有符合条件凑出 $3 \sim 6$ 的情况这样添加 $sum$ 的形式最快，于是就可以一直添加 $sum$，这样可以保证始终可以凑出 $3 \sim sum \times 2$ 的任何数，同时使用最少。

然后就一直加 $sum$ 直到 $sum \geq w$。

复杂度 $O(T \log w)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int T;
	scanf("%d", &T);
	while(T--){
		long long x;
		scanf("%lld", &x);
		long long sum = 3, cnt = 3;
		while(sum < x){
			sum *= 2;
			cnt ++;
		}
		printf("%lld\n", cnt);
	}
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：2)

首先，$k$ 是 $3$ 时 $n$ 为 $3$，说明 $k \ge 3$，这个序列中必须有 $0,1,2$。

接着，我们可以发现：我们给的集合中所有数之和就是能够造出的集合 $S$ 中的最大值。

所以，要想让我们给的集合和最大，每次向集合中添加的数是添加前的集合所有数的和才能让添加后的集合和最大，原本能凑出 $0 \sim$ 总和，添加后能凑出 $0 \sim$ 总和 $\times 2$。

记得开 `long long`。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int t,w;

signed main(){
	cin>>t;
	while(t--){
		cin>>w;
		for(int i=3,j=3;;i++,j*=2){  //i 代表集合中的项数，j 代表当前向集合添加的数，一开始集合为 0,1,2，故 i=3,j=3。
			if(j>=w){  //如果添加后能凑出 w，则输出当前项数。
				cout<<i<<endl;
				break;
			}
		}
	}
	return 0;
}
```


---

## 作者：WsW_ (赞：1)

很有趣。  
看其他题解的证明都看不懂，所以我来写个证明。  

---
### 思路
显然，$3$ 只能被拆成 $0+1+2$。  
所以不管 $w$ 是多少，集合中肯定有 $0,1,2$ 三个元素。  

如果想要表示 $4$，那么集合是唯一确定的 $\{0,1,2,3\}$。  
此时用这个集合可以表示 $3\sim6$ 所有的数，这是唯一确定的集合。  

如果想要表示 $7$，开始有变化了。  
集合是 $\{0,1,2,3,x\},4\le x\le 6$。  
如果 $x$ 取 $4$，那么可以表示的数字为 $1\sim 9$。  
如果 $x$ 取 $6$，那么可以表示的数字为 $1\sim 11$。  
显然的是，如果原来的集合可以表示 $3\sim a$ 所有的数，那么加入 $x$ 后，可以表示 $3\sim x+a-t$ 中的所有数。其中 $t$ 为原集合中第 $3$ 大的数，在单次操作中可以视作一个常量。  

因此，$x$ 在保证区间不断的情况下，肯定是越大越好。  

而要保证区间不断，也就是 $a+1$ 能表示得出来。显然 $x$ 最大只能取 $a$，此时 $a+1=0+1+a$。  
这样取每次区间会翻倍，请自行推导。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int T;
ll w;

void work(){
	cin>>w;
	int cnt=3;//元素个数
	ll sum=3;//a
	while(sum<w){
		sum<<=1;
		cnt++;
	}
	cout<<cnt<<'\n';
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--)work();
	return 0;
}
```

---
### 评分
挺好玩的，但偏向 $\mathtt{Codeforeces}$ 的风格而不像国内竞赛题目的风格

---

## 作者：ncwzdlsd (赞：0)

逐步考虑问题，对于 $3$，集合只能是 $\{0,1,2\}$；为了得到 $4$，再选一个 $3$，就可以得到 $[3,6]$ 的所有数；为了得到 $7$，再选一个 $4$，就可以得到 $[3,12]$ 的所有数……

于是有规律：每一次顺序加入一个数，可以组成的数的个数变为 $2$ 倍。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long

void solve()
{
    int w;cin>>w;
    int now=3,ans=3;
    while(now<w)
        ans++,now*=2;
    cout<<ans<<'\n';
}

signed main()
{
    int T;cin>>T;
    while(T--) solve();
    return 0;
}
```

---

## 作者：ivyjiao (赞：0)

首先，我们考虑：如果去掉了“至少三个数”限制，怎么写？

很简单，$a_1=1,a_i=2a_{i-1}(i\geq 2)$。

注意到这里有一个乘以 $2$ 的过程，因为 $a_i$ 及之前的数能够拼到 $2a_i-1$ 了，所以需要一个新数来拼后面的数。

加上“至少三个数”限制，我们发现必须要添加一个 $0$，否则 $3$ 这个数就无解了。

然后拼成 $4$ 这个数还需要添加 $3$ 这个数，$5$ 就不需要添加新数字了。

然后一直重复，直到 $7$ 这个数拼不出来，需要添加 $6$ 这个数字，就又进入了 $a_i=2a_{i-1}(i\geq 2)$ 这个数列了。

综上，最终数列为 $0,1,2,3,6,12\dots$。

最终数列可能较长，所以要用二分查找。

记得开 long long。

代码：

```
#include<iostream>
#include<algorithm>
using namespace std;
long long t,n,a[10001]={0,0,1,2,3},siz;
int main(){
    cin>>t;
    for(int i=5;;i++){
        if(a[i-1]*2<=1e12) a[i]=a[i-1]*2,siz++;
        else break;
    }
    while(t--){
        cin>>n;
        cout<<lower_bound(a+1ll,a+siz+1,n)-a-1<<endl;
    }
}
```

---

## 作者：Convergent_Series (赞：0)

令集合中的元素和为 $k$。

为了使 $k$ 尽快逼近 $w$，加入的每一个元素都要尽量大。

$3$ 只能分解为 $0+1+2$，所以集合中必有 $0,1,2$。

为算出 $4$，集合中最大只能加入 $3$。此时 $k=6$，$3\sim 6$ 均可算出。

为算出 $7$，集合中最大只能加入 $6$。此时 $k=12$，$7\sim 12$ 均可算出。

为算出 $13$，集合中最大只能加入 $12$。

以此类推，不断加入 $24,48,96\cdots$ 直到集合中的元素和大于等于 $w$。此时答案即为集合中的元素个数。

参考代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,w,ans,k;
signed main(){
	cin>>t;
	while(t--){
		cin>>w;
		k=3;ans=3;
		while(k<w){
			ans++;k<<=1;
		}
		cout<<ans<<"\n";
	}
	return 0;
} 
```

---


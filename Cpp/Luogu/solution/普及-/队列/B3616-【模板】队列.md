# 【模板】队列

## 题目描述

请你实现一个队列（queue），支持如下操作：
- `push(x)`：向队列中加入一个数 $x$。
- `pop()`：将队首弹出。如果此时队列为空，则不进行弹出操作，并输出 `ERR_CANNOT_POP`。
- `query()`：输出队首元素。如果此时队列为空，则输出 `ERR_CANNOT_QUERY`。
- `size()`：输出此时队列内元素个数。

## 说明/提示

### 样例解释
首先插入 `2`，队首为 `2`、队列内元素个数为 `1`。  
插入 `233`，此时队首为 `2`。  
弹出队首，此时队首为 `233`。  
弹出队首，此时队首为空。  
再次尝试弹出队首，由于队列已经为空，此时无法弹出。  
插入 `144`，此时队首为 `144`。  



### 数据规模与约定

对于 $100\%$ 的测试数据，满足 $n\leq 10000$，且被插入队列的所有元素值是 $[1, 1000000]$ 以内的正整数。


## 样例 #1

### 输入

```
13
1 2
3
4
1 233
3
2
3
2
4
3
2
1 144
3```

### 输出

```
2
1
2
233
0
ERR_CANNOT_QUERY
ERR_CANNOT_POP
144```

# 题解

## 作者：RE_Prince (赞：17)

# B3616 【模板】队列 题解

题意：给你一个队列，让你进行加入，查询第一个，查询大小，弹出四个操作，你要输出两个查询操作的答案。

### Algorithm 1

不了解队列的同学[戳这里](http://c.biancheng.net/view/479.html)

运用STL中的队列，具体细节会在代码内详解：

```cpp
#include<iostream>
#include<string.h>
#include<string>
#include<unordered_map>
#include<algorithm>
#include<stdio.h>
#include<queue>
using namespace std;
int n, m, i, j, k;
queue<int> q;
int main()
{
    cin >> n;
    for (i = 1; i <= n; i++)
    {
        int op, x;
        cin >> op;
        if (op == 1) cin >> x, q.push(x);//加入
        else if (op == 2)
        {
            if (q.empty()) cout << "ERR_CANNOT_POP\n";//要判断是否为空，否则RE
            else q.pop();//如果不为空，弹出
        }
        else if (op == 3)
        {
            if (q.empty()) cout << "ERR_CANNOT_QUERY\n";//同上
            else cout << q.front() << endl;//输出第一个
        }
        else cout << q.size() << endl;//输出队列大小
    }
    return 0;//结束
}
```

### Algorithm 2

除了STL，我们还可以手写一个队列！

思路：

+ 定义头和尾
+ 加入时，头 $+1$ ，尾不动
+ 删除时，尾 $+1$ ，头不动
+ 查询大小时，输出头 $-$ 尾 $+1$ 
+ 查询第一个时，直接输出头部。

代码就不给大家了，有兴趣的同学可以自己试着写一写。

---

## 作者：HYdroKomide (赞：8)

### 题意&思路：

普通队列板子。

如果你想手写队列，我不拦着。但是 STL 有封装的，白嫖不香吗？

#### 新手向——队列简介：

队列，顾名思义，就是一列数。你可以将数按照顺序加进去和拿出来。只是加进去必须加到队尾，拿出来必须拿出队首。总结就是先进先出。

#### 队列用法：

用法题面里也基本说清楚了。

首先定义一个队列：

```cpp
queue<int>q;//int代表是整数队列
```

操作：

```cpp
q.push(x)；//从队尾加入一个数x
q.pop();//弹出队首元素
q.front();//返回队首元素
q.size();//返回队列长度
q.empty();//如果队列为空，返回true，否则返回false
```

#### 需要注意的点：

弹出和返回队首之前都要先确认队列是否为空，如果为空就弹出 `ERROR` 信号。

```cpp
if(q.empty())ERROR;
```

所以程序就很简单了。

### 程序如下：

```cpp
#include<cstdio>
#include<queue> 
using namespace std;
int n,op,x;
queue<int>q; 
int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d",&op);
		if(op==1){
			scanf("%d",&x);
			q.push(x);
		}
		else if(op==2){
			if(q.empty())printf("ERR_CANNOT_POP\n");
			else q.pop();
		}
		else if(op==3){
			if(q.empty())printf("ERR_CANNOT_QUERY\n");
			else printf("%d\n",q.front());
		}
		else printf("%d\n",q.size());
	}
	return 0;
}
```

### THE END

---

## 作者：Elgo87 (赞：5)

队列，是一种遵循“先进先出”的线型数据结构。

有对队列不了解的，可以去 oi-wiki 上学习：<https://oi-wiki.org/ds/queue>

而 C++ STL 中提供了队列的容器 `queue`，就不需要手写队列了。

常见的 `queue` 使用方法如下：

- 定义队列：`queue<int> q;`
- 入队：`q.push()`
- 出队：`q.pop`;
- 取队头：`q.front()`；
- 判断队列是否为空：`q.empty()`
- 获取队列元素个数：`q.size()`

------

回到本题，STL 的队列仍然可以帮我们方便地解决问题。

对于操作 $1$，入队即可，操作为 `q.push()`。

对于操作 $2$，：如果队列不空就将队首弹出队列，否则输出 `ERR_CANNOT_POP`。弹出队列的操作为 `q.pop()`，判断是否为空的操作为 `q.empty()`。

对于操作 $3$，队列不空就输出队首元素，否则输出 `ERR_CANNOT_QUERY`。队首元素的获取方法是 `q.front()`。

对于操作 $4$，输出队列的元素个数，过去个数的操作为 `q.size()`。

参考代码：

```cpp
# include <bits/stdc++.h>
using namespace std;


queue<int> q;
int main()
{
	int n;
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i)
	{
		int x,y;
		scanf("%d", &x);
        
		if(x == 1)
		{
			scanf("%d", &y);
			q.push(y);
		}
        
		if(x == 2)
		{
			if(q.empty())
                puts("ERR_CANNOT_POP");
			else          
                q.pop();
		}
        
		if(x==3)
		{
			if(q.empty()) 
                puts("ERR_CANNOT_QUERY");
            else          
                printf("%d\n", q.front());
		}
        
		if(x==4)
		{
			printf("%d\n", q.size());
		}
	}
    
	return 0;
}

```

---

## 作者：ShanCreeperPro (赞：5)

## B3616 【模板】队列 题解

一道队列模板题。

先来介绍一下队列 `queue` 的使用：

STL 提供了队列，头文件是 `#include<queue>`。

你可以使用以下函数来操作此队列：

- `queue<int> q`：建立 int 类型的队列 $q$;
- `q.push(a)`：将 $a$ 放入队列末尾；
- `q.pop()`：将队首删除；
- `q.front()`：查询 $q$ 的队首；
- `q.back()`：查询 $q$ 的队尾；
- `q.size()`：查询 $q$ 元素个数；
- `q.empty()`：查询 $q$ 是否为空；

***

**思路：**

1.定义一个队列 $q$，用来存放队列：

```cpp
queue<int> q;
```

2.读入 $n$，然后在循环中定义操作符 `cmd` 并读入。

- 如果 `cmd` 为 1，读入数 $x$，然后使用 `q.push(x)` 将数字 $x$ 放入队列末尾；

-  如果 `cmd` 为 2：
   - 如果队列不为空（`q.empty()==0`），那么使用 `q.pop()` 弹出队首。
    - 否则输出 "ERR_CANNOT_POP"。
    
- 如果 `cmd` 为 3：
    - 如果队列不为空（`q.empty()==0`），那么用 `q.front()` 查找队列首位元素并输出。
    - 否则输出 "ERR_CANNOT_QUERY"。
    
- 如果 `cmd` 为 4，使用 `q.size()` 得到队列长度并输出。

完整 code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fore(i,x,n) for(int i=x;i<=n;i++)
const int MAXX=1005;
const int mod=1;
queue<int> q;
int n;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
signed main(){
#ifdef LOCAL
    freopen("debug_data.in","r",stdin);
    freopen("debug_data.out","w",stdout);
#endif
    n=read();
    fore(i,1,n){
        int cmd,x;
        cmd=read();
        if(cmd==1){
            x=read();
            q.push(x);
        }
        if(cmd==2){
            if(q.empty()==0){
                q.pop();
                continue;
            } else {
                puts("ERR_CANNOT_POP");
            }
        }
        if(cmd==3){
            if(q.empty()==0){
                write(q.front()); puts("");
                continue;
            } else {
                puts("ERR_CANNOT_QUERY");
            }
        }
        if(cmd==4){
            write(q.size()); puts("");
        }
    }
}
```




---

## 作者：rzh123 (赞：4)

# B3616 题解  

题目链接：[B3616 【模板】队列](https://www.luogu.com.cn/problem/B3616)  

关于队列，有两种做法：  

## 1.手写模拟  

用数组存储数据，用两个指针 $head$ 和 $tail$ 表示队列头、尾位置，插入时 $head$ 加 $1$ 并将新数据存储到头部，弹出时 $tail$ 加 $1$，查询时直接查 $tail+1$ 位置的数据，$head-tail$ 就是队列长度。  

代码：  
```cpp
#include <cstdio>
#define gc getchar()
#define pc(c) putchar(c)
#define N 10007
int n;
int op;
int q[N],qh,qt;
int read(){
	int t=0;
	char c=gc;
	while(c<'0'||c>'9') c=gc;
	while(c>='0'&&c<='9') t=10*t+(c^48),c=gc;
	return t;
}
void write(int x){
	if(x<10){
		pc(x|48);
		return;
	}
	write(x/10);
	pc((x%10)|48);
}
int main(){
	//freopen("B3616.out","w",stdout);
	n=read();
	while(n--){
		op=read();
		switch(op){ 
			case 1:{
				q[++qh]=read();
				break; 
			}
			case 2:{
				if(qt+1>qh){
					puts("ERR_CANNOT_POP");
				}
				else{
					++qt;
				}
				break;
			}
			case 3:{
				if(qt+1>qh){
					puts("ERR_CANNOT_QUERY");
				}
				else{
					write(q[qt+1]);
					puts("");
				}
				break;
			}
			case 4:{
				write(qh-qt);
				puts("");
				break;
			}
		} 
	}
	return 0;
}

```  

## 2.STL 做法  

STL 是 C++ 的一大特色，特别方便。  
C++ STL 自带一种 `queue` 类型。使用时先 `#include<queue>`，之后就可以用了。  
`queue` 在 `std` 名字空间中，需要在前面加 `std::` 或者使用 `using`。  

使用方法：  
- `queue<T> q` 声明一个 `T` 类型的队列 $q$  
- `q.push(x)` 在队列中插入数据  
- `q.pop()` 弹出队尾  
- `q.front()` 查询队尾元素  
- `q.size()` 返回队列长度  
- `q.empty()` 判断队列是否为空  

代码：  
```cpp
#include <cstdio>
#include <queue>
#define gc getchar()
#define pc(c) putchar(c)
#define N 10007
using std::queue;
int n;
int op;
queue<int> q;
int read(){
	int t=0;
	char c=gc;
	while(c<'0'||c>'9') c=gc;
	while(c>='0'&&c<='9') t=10*t+(c^48),c=gc;
	return t;
}
void write(int x){
	if(x<10){
		pc(x|48);
		return;
	}
	write(x/10);
	pc((x%10)|48);
}
int main(){
	n=read();
	while(n--){
		op=read();
		switch(op){ 
			case 1:{
				q.push(read());
				break; 
			}
			case 2:{
				if(q.empty()){
					puts("ERR_CANNOT_POP");
				}
				else{
					q.pop();
				}
				break;
			}
			case 3:{
				if(q.empty()){
					puts("ERR_CANNOT_QUERY");
				}
				else{
					write(q.front());
					puts("");
				}
				break;
			}
			case 4:{
				write(q.size());
				puts("");
				break;
			}
		} 
	}
	return 0;
}
```

---

## 作者：TheSky233 (赞：2)

## Description

实现关于队列的若干操作。

## Solution

看到大佬们都用的是 STL 里的 ```queue```，这里蒟蒻用的是手写队列。

对于手写队列，需要维护两个指针：头指针和尾指针。

1. 对于插入操作，直接插入即可。
2. 对于弹出操作，判断 ```head``` 是否小于 ```tail```，是就弹出，不是就报错。
3. 对于查询操作，判断 ```head``` 是否小于 ```tail```，是就输出 ```que[head]```，不是就报错。
4. 对于查询队列长度，直接输出 ```tail-head+1```。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,x,m;
int que[10005],head=1,tail=0;

int main(){
	cin>>n;
	while(n--){
		cin>>x;
		switch (x){
			case 1:{
				cin>>m;
				que[++tail]=m;
				break;
			}
			case 2:{
				if(head>tail) cout<<"ERR_CANNOT_POP"<<'\n';
				else head++;
				break;
			}
			case 3:{
				if(head>tail) cout<<"ERR_CANNOT_QUERY"<<'\n';
				else cout<<que[head]<<'\n';
				break;
			}
			case 4:{
				cout<<tail-head+1<<'\n';
				break;
			}
		}
	}
	return 0;
}

```

---

## 作者：TsH_GD (赞：1)

[传送门](https://www.luogu.com.cn/problem/B3616)

## 讲解

读入一个数。

分情况（题目给出）进行操作：

1. 直接将元素插入队列。
2. 若队列非空就弹出队首，否则输出 `ERR_CANNOT_POP`。
3. 若队列非空就输出队首元素，否则输出 `ERR_CANNOT_QUERY`。
4. 输出队列长度。

### code:
```cpp
#include<bits/stdc++.h>
using namespace std;

//队列 
queue<int>QS;

//快读 
inline int read(){
    int a=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){a=(a<<3)+(a<<1)+(ch^48);ch=getchar();}
	return a*f;
}

int main(){
	int n;
	n=read();
	for(int i=1; i<=n; ++i) {
		int a;
		a=read();
		if(a==1) {
			QS.push(read());
		}
		if(a==2) {
			if(QS.empty()) cout<<"ERR_CANNOT_POP"<<endl;
			else          QS.pop();
		}
		if(a==3) {
			if(QS.empty()) cout<<"ERR_CANNOT_QUERY"<<endl;
			else          cout<<QS.front()<<endl;
		}
		if(a==4) {
			cout<<QS.size()<<endl;
		}
	}
	return 0;//好习惯 
}
```


---


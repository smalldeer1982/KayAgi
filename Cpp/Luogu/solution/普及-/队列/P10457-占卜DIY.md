# 占卜DIY

## 题目描述

lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。

初始状态下，所有的牌背面朝上扣下。

流程如下：

- 抽取生命牌中的最上面一张（第一张）。
- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。(例如抽到 $2$ ，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放)
- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$ ，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）
- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。
- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。
- 统计一共开了多少对，开了 $0$ 对称作"极凶"，$1\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\sim11$ 为“大吉”，$12$ 为“满堂开花，极吉”。

如果还不明白，请参考样例。

## 说明/提示

注解：第一条命死后前 $12$ 堆牌变成了这个样子：
```
A A A 8
K 5 3 2
3 9 6 0
4 4 3 4
5 5 3 4
6 6 5 6
7 7 7 7 
8 8 8 9
9 9 0 0
0 K J J
J Q A Q//抽到这里的K死掉了
J Q 2 2
```
第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。

第三条命死后前 $12$ 堆牌变成了这个样子：
```
A A A A
2 2 2 K
3 3 3 3
4 4 4 4
5 5 5 5
6 6 6 6
7 7 7 7 
8 8 8 8
9 9 9 9
0 0 0 0//抽到这里的K死掉了
J J J Q
Q Q J Q
```
第四条命死后前 $12$ 堆牌变成了这个样子：
```
A A A A
2 2 2 2//抽到这里的K死掉了
3 3 3 3
4 4 4 4
5 5 5 5
6 6 6 6
7 7 7 7 
8 8 8 8
9 9 9 9
0 0 0 0
J J J Q
Q Q J Q
```
最后发现在所有已经正面朝上的牌中，$A\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 10$这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。

## 样例 #1

### 输入

```
8 5 A A
K 5 3 2
9 6 0 6
3 4 3 4
3 4 4 5
5 6 7 6
8 7 7 7
9 9 8 8
9 0 0 0
K J J J
Q A Q K
J Q 2 2
A K Q 2```

### 输出

```
9```

# 题解

## 作者：mxjz666 (赞：7)

根据题意，我们可以把 $13$ 个牌堆用 $13$ 个双端队列来实现，根据题意模拟即可。但要注意第 $13$ 堆是与前 $12$ 堆不一样的。

献上我丑陋的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20;
deque<int> d[N];
int cnt[N];
int main(){
	for(int i=1;i<=13;i++){
		for(int j=0;j<4;j++){
			char c;
			cin>>c;
			if(c>='1'&&c<='9'){
				d[i].push_back(c-'0');
			}else if(c=='0'){
				d[i].push_back(10);
			}else if(c=='J'){
				d[i].push_back(11);
			}else if(c=='Q'){
				d[i].push_back(12);
			}else if(c=='K'){
				d[i].push_back(13);
			}else{
			    d[i].push_back(1);
			}
		}
	}
	int ck=0,ans=0,key=d[13].front();
	d[13].pop_front();
	while(ck<4){
		if(key==13){
			ck++;
			key=d[13].front();
			d[13].pop_front();
			continue;
		}
		d[key].push_front(key);
		int tmp=key;
		key=d[tmp].back();
		d[tmp].pop_back();
		cnt[tmp]++;
		if(cnt[tmp]==4){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Tulip_ (赞：6)

### 题意

- 从生命牌中抽取的最上面一张。
- 把这张牌放到对应编号的堆的最上边。
- 从刚放了牌的那一堆最底下抽取一张牌，重复第 $2$ 步。
- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。

总共有 $4$ 条命，当 $4$ 条命头没了，就输出总对数。

### 思路

使用`deque`解决。

先输入，将字母改为数字并放入数组。

再模拟步骤，一边判断，一边模拟。

最后找有几个总对数。

### 注意

需要将以下的字母与数字修改：

`0`变为`10`。

`A`变为`1`。

`J`变为`11`。

`Q`变为`12`。

`K`变为`13`。

### 代码

输入，如下。

```cpp
for(int i=1;i<=13;i++){
		for(int j=1;j<=4;j++){
			cin>>x;
			if(x<='9'&&x>='1')a[i].push_back(x-'0');
			else if(x=='0')a[i].push_back(10);
			else if(x=='J')a[i].push_back(11);
			else if(x=='Q')a[i].push_back(12);
			else if(x=='K')a[i].push_back(13);
			else if(x=='A')a[i].push_back(1);
	}
}
```

模拟，如下。

在这里我用了点优化，边循环，边统计对数。

```cpp
while(!a[13].empty()) {
        int t=a[13].front();
		a[13].pop_front();
        while(t!=13) {
            b[t]++;
            if(b[t]>=4)sum++;
            int p=a[t].back();
			a[t].pop_back();
			t=p;
        }
    }
```

整体代码，如下。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
deque<int> a[20];
int b[20],sum;
char x;
signed main(){
	for(int i=1;i<=13;i++)
		for(int j=1;j<=4;j++){
			cin>>x;
			if(x<='9'&&x>='1')a[i].push_back(x-'0');
			else if(x=='0')a[i].push_back(10);
			else if(x=='J')a[i].push_back(11);
			else if(x=='Q')a[i].push_back(12);
			else if(x=='K')a[i].push_back(13);
			else if(x=='A')a[i].push_back(1);
	}
	while(!a[13].empty()) {
        int t=a[13].front();
		a[13].pop_front();
        while(t!=13) {
            b[t]++;
            if(b[t]>=4)sum++;
            int p=a[t].back();
			a[t].pop_back();
			t=p;
        }
    }
	cout<<sum;
	return 0;
}
```

---

## 作者：pengzy (赞：4)

### 思路
按题目要求，从上向下取生命牌，同时统计抽到 $K$ 的个数；一旦抽到 $K$，就再取生命牌。

我用 $s$ 数组来统计每堆牌中**向上**的牌个数（除生命牌）。普通牌从底往上抽，只需要抽到一张就删掉、$s$ 加一即可。

需要注意每张牌代表的数字，不同的拿牌方式。

### 方法
这道题的卡牌可以从上取也可以从下取，所以使用双端队列进行模拟。与 `queue` 不同的是 `deque` 可以从两端插入和删除元素。

`pop_back/front` 弹出队头/队尾元素

`push_back/front` 插入队头/队尾元素

牌的总数很少，不用担心超时。

```cpp
deque<int> q[20];
int s[20],sum;
int main()
{
	for(int i=1;i<=13;i++)
		for(int j=1;j<=4;j++) {
			char c;
			cin>>c;//根据题意把卡牌转换成对应的数字，并入队 
			if(c<='9'&&c>='1')q[i].push_back(c-'0');
			else if(c=='0')q[i].push_back(10);
			else if(c=='J')q[i].push_back(11);
			else if(c=='Q')q[i].push_back(12);
			else if(c=='K')q[i].push_back(13);
			else if(c=='A')q[i].push_back(1);
		}
	while(!q[13].empty()) {//当第13堆牌还有时 
        int t=q[13].front();//取到k就重新开始 
		q[13].pop_front();
        while(t!=13) {//没有取到k就一直操作 
            s[t]++;//翻开了一张牌，统计 
            if(s[t]>=4)sum++;
            int p=q[t].back();//取最后一张牌 
			q[t].pop_back();
			//这里省去了插入操作，因为不会再拿被翻开的牌 
			//q[p].push_front(p);
			t=p;
        }
    }
	cout<<sum;
	return 0;
}
```

---

## 作者：jqQt0220 (赞：3)

我们可以直接用双端队列根据题意模拟。

首先读入，注意特判 $0,A,J,Q,K$，这里分别代表 $10,1,11,12,13$。之后开始循环，终止条件是生命牌堆（即第 $13$ 堆）为空。先在第 $13$ 堆的队列**头**取出一张牌，然后直接存到一个变量，之后继续循环，终止条件为抽到“死神”，即代表牌的变量 $=13$。不难发现，正面朝上的牌只会在对应牌堆上，所以抽到牌只需要计数，之后判断是否 $=4$ 即可。抽到牌后对应计数器 $+1$，并在对应牌堆队列**尾**取一张牌，重复上面的过程。最后看有多少牌堆有 $4$ 张正面朝上，即计数器 $=4$，输出答案即可。

删去缺省源的代码：
```cpp
deque<int> q[20];//牌堆的队列
int s[20];//计数
int main()
{
    ___();
    for(int i=1;i<=13;i++)//读入 13 个牌堆
    {
        for(int k=1;k<=4;k++)//每个牌堆 4 张
        {
            char c;
            cin>>c;
            int x;
            if(c=='0')//特判一下
                x=10;
            else if(c=='A')
                x=1;
            else if(c=='J')
                x=11;
            else if(c=='Q')
                x=12;
            else if(c=='K')
                x=13;
            else
                x=c-'0';
            q[i].push_back(x);
        }
    }
    while(!q[13].empty())//一直循环直到生命牌堆为空
    {
        int nw=q[13].front();q[13].pop_front();//生命牌堆顶取一张
        while(nw!=13)//当前牌不为“死神”
        {
            s[nw]++;//计数
            int t=q[nw].back();q[nw].pop_back();nw=t;//对应牌堆底取一张
        }
    }
    int ans=0;
    for(int i=1;i<=12;i++)//统计开了多少对
        if(s[i]==4)
            ans++;
    cout<<ans<<endl;
    return 0;//完美结束 QwQ
}
```

---

## 作者：__qkj__ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10457)
## 解题思路
按题意模拟。

在输入的时候要注意：
- `A` 要换成 `1`；
- `0` 要换成 `10`；
- `J` 要换成 `11`；
- `Q` 要换成 `12`；
- `K` 要换成 `13`；
- 其他不变。

然后模拟，一开始的值为第 $13$ 堆的第一个，再 `while` 循环，当第 $13$ 堆的 $4$ 张都未翻满时，如果当前值为 $13$ 时，翻第一张，否则翻最后一张。

最后从 $1$ 到 $12$ 遍历，如果翻完了，$s\gets s+1$，最后输出 $s$ 即可。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[20][10];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for(int i=1;i<=13;i++)
	{
		char c[10];
		cin>>c[1]>>c[2]>>c[3]>>c[4];
		for(int j=1;j<=4;j++)
		{
			if(c[j]<='9'&&c[j]>='2')a[i][j]=c[j]-'0';
			if(c[j]=='A')a[i][j]=1;
			if(c[j]=='0')a[i][j]=10;
			if(c[j]=='J')a[i][j]=11;
			if(c[j]=='Q')a[i][j]=12;
			if(c[j]=='K')a[i][j]=13;
		}
		a[i][0]=5;
	}
	int now=a[13][1],s=0;
	a[13][0]=1;
	while(a[13][0]<=4)
		now=a[now][((now==13)?(++a[now][0]):(--a[now][0]))];
	for(int i=1;i<=12;i++)
		if(a[i][0]==1)s++;
	cout<<s;
	return 0;
}

```

---

## 作者：GXZJQ (赞：1)

# P10457 占卜DIY 题解

[题目链接](https://www.luogu.com.cn/problem/P10457)

## 题目分析

这是一道模拟题。

按照题意，不妨用 $13$ 个双端队列代表 $13$ 堆牌，根具题意模拟即可。

## 注意事项
- 每次拿该堆的末尾；
- 读入问题，这里读入需要特判几个点，也就是特殊的几种牌型；
- 注意存储问题，如果用数组模拟要注意堆底和堆顶的下标。

## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int death = 13;
int ans,x,t,cnt[15];
deque<pair<int, bool> >q[15];
int get(char c) {
    if(c=='A')    return 1;
    if (c>='2'&&c<='9')   return c-'0';
    if (c=='0')   return 10;
    if (c== 'J')   return 11;
    if (c=='Q')   return 12;
    return 13;
}
void read() {
    char c;
    for(int i=1;i<=13;i++)
        for(int j=1;j<=4;j++)   cin>>c,q[i].push_back(make_pair(get(c),0));
}
int main() {
    read();
    for (int i=1;i<=4;i++) {
        x=q[death].front().first,cnt[x]++, q[death].pop_front ();
        while(x<13) {
            t=q[x].back().first,q[x].pop_back(),x=t;
            if (x==13)  break;
            q[x].push_front(make_pair(x,1));
        }
    }
    for(int i=1;i<13;i++)
        while(!q[i].empty()) {
            if(q[i].front().second) cnt[q[i].front().first]++;
            q[i].pop_front();
        }
    for(int i=1;i<13;i++)
        if(cnt[i]==4)   ans++;
    cout<<ans;
    return 0;
}
```

---

## 作者：Kamisato_Ayaka_Orz (赞：1)

**对题目的理解：**

1. 从生命牌中抽取的最上面一张。

2. 把这张牌放到对应的堆的最上边。

3. 从底下抽取一张牌，重复第 $2$ 步。

4. 如果抽到 $K$ 就从头开始。

**思路**
大模拟。

**代码展示：**
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[20][5];
int b[20],x=4;
int sd(char a)
{
	if(a>='2'&&a<='9') return a&15;
	if(a=='0') return 10;
	 	else if(a == 'J') return 11;
			else if(a == 'Q') return 12;
				else if(a == 'K') return 13;
					else return 1;
}
int main()
{
	for(int i=1;i<=13;i++)
		for(int j=1;j<=4;j++)
			cin>>a[i][j];
	while(x)
	{
		char s=a[13][5-x];
		if(s=='K')
		{
			x--;
			continue; 
		}
		while(s!='K')
		{
			b[sd(s)]++;
			s=a[sd(s)][5-b[sd(s)]];
		}
		x--;
	}
	int sum=0;
	for(int i=1;i<=12;i++) if(b[i]==4) sum++;
	cout<<sum;
	return 0;
}
```

---

## 作者：Arthur_Douglas (赞：1)

## 思路

首先，我们知道牌的初始状态，那么我们只需要求出每个牌的具体指的是哪套牌，然后进行循环。最后扫到牌 $K$ 时就进行下一次，但是需要注意四次之后要退出以及**死神**的判断。

**特别注意**，$0$ 在题目中指的是 $10$。

## 代码
~~一遍过~~

``` cpp
#include<bits/stdc++.h>
using namespace std;
char a[14][5];
int S[14];
int sWap_number(char a)
{
	if(a >= '2' && a <= '9')
	return a & 15;
	if(a == '0')
	return 10;
	else if(a == 'J')
	return 11;
	else if(a == 'Q')
	return 12;
	else if(a == 'K')
	return 13;
	else
	return 1;
}
int main()
{
	for(int i = 1;i <= 13;++ i)
	for(int j = 1;j <= 4;++ j)
	cin >> a[i][j];
	int Cnt = 4;
	while(Cnt)
	{
		char Bi = a[13][5 - Cnt];
		if(Bi == 'K')
		{
			-- Cnt;
			continue; 
		}
		while(Bi != 'K')
		{
			++ S[sWap_number(Bi)];
			Bi = a[sWap_number(Bi)][5 - S[sWap_number(Bi)]];
		}
		-- Cnt;
	}
	int ans = 0;
	for(int i = 1;i <= 12;++ i)
	if(S[i] == 4)
	++ ans;
	cout << ans;
	return 0;
}
```
~~记得点个赞哩~~

---

## 作者：_dbq_ (赞：1)

## 前言
还没有读题的同学可以点击[这里](https://www.luogu.com.cn/problem/P10457)先读题。

## 思路
本题可以发现我们翻开的牌永远放在一堆的堆顶，而拿出来的牌永远从堆低拿，我们发现这和队列的性质一样，所以考虑队列。

## 做法
1. 将前 12 堆先读入，倒序存入队列中，因为我们要从最后拿牌，所以要做翻转。
1. 第 13 堆生命牌直接读入数组中。
1. 枚举当前在用第几条命
1. 取出生命牌
1. 判断是否是 $K$ ，成立则跳出循环，回到第 3 步；否则将当前牌打上标记并放入对应的队列中，再从队首取出一张牌，继续执行此步。
1. 循环清空每一个队列，统计每种牌的数量（注意：只有被打上标记的牌才是被翻开的，只统计这些牌）。
1. 判断开了多少对。
1. 输出答案

---

## 作者：Mcqueen1210 (赞：1)

# P10457 占卜DIY
[传送门](https://www.luogu.com.cn/problem/P10457)

从题意可以知道，我们要创建 $13$ 个牌堆，不断抽取第 $13$ 号牌堆的牌顶，再从该牌对应的牌堆下抽牌。最后寻找凑成“一对”的。

转换一下可得：维护一个（当然这里有 $13$ 个）序列，**从头抽和放，从尾抽。**

不难想到有一种 STL 模板，**双端队列**，可以很好的解决这道题。

更具体解释见注释。

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=13,M=4;
int n,num[15],ans;
deque<int>a[15]; 
int main()
{
	for(int i=1;i<=N;i++)
	{
		for(int j=1;j<=M;j++)
		{
			char c;
			int d;
			cin>>c;
			if(c>='2'&&c<='9')//普通情况 
			{
				d=c-'0';
			}
			else
			{
				switch(c)//特判 
				{
					case 'A':d=1;break;
					case 'J':d=11;break;
					case 'Q':d=12;break;
					case 'K':d=13;break;
					default:d=10;
				}
			}
			a[i].push_back(d);
		}
	}
	while(!a[N].empty())
	{
		int up=a[N].front();//牌顶 
		int down=up;//牌底 
		a[N].pop_front();//抽走“生命牌” 
		while(up!=N)//抽到K会死 
		{
			num[up]++;
			up=a[up].back();//下一个应抽走的 
			a[down].pop_back();//要抽的 
			down=up;
		}
	}
	for(int i=1;i<=12;i++)
	{
		if(num[i]==4)//满足“一对” 
		{
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：sunhaozhe111022 (赞：1)

#  [题目传送门](https://www.luogu.com.cn/problem/P10457)

**题目大意：**

有十三堆牌堆，前十二堆为普通牌堆，最后一堆为“生命堆”。接着，需要从“生命堆”顶上摸出一张牌，放入其点数大小相对应的牌堆。再从牌堆底部摸出一张，也放入对应的牌堆，如此反复，直至摸出 $K$。摸出 $K$ 后，又再次从“生命堆”摸出一张牌，放入其点数大小相对应的牌堆，反复，直至
“生命堆”的牌全部摸完。

**目标：**

我们需要求出翻出来的牌开了多少对。

**开了一对：**

统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌，比如 $4$ 个 $A$，则称“开了一对”，当然 $4$ 个 $K$ 是不算的。

**思路：**

根据题意，直接用队列模拟：

先将所有数据用队列存储，注意特判字母和 $0$。接着，从最后一个队列读取最顶上的一张牌，弹出最后一个队列最顶上的那张牌，放在其点数大小相对应的队列顶上，在读取此队列最底下一张的牌，放在其点数大小相对应的队列顶上，弹出此队列最顶上的那张牌。

**队列是什么？**

可以看看本蒟蒻的笔记：

[笔记](https://www.luogu.com.cn/article/z2ual8la)

了解完队列是什么以及如何使用之后，我就奉上代码了。

# 代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;//队列必须要这个
char x;
int c,s[15],ans;
deque<int>a[15];//队列的定义 
int main()
{
	for(int i=1;i<=13;i++)//循坏输入
	{
		for(int j=1;j<=4;j++)
		{
			cin>>x;//读入
			if(x>='2'&&x<='9') c=x-'0';
			if(x=='A') c=1;//特判字母
			if(x=='J') c=11;
			if(x=='Q') c=12;
			if(x=='K') c=13;
			if(x=='0') c=10;
			a[i].push_back(c);//放入队列的尾部
		}
	}
	while(!a[13].empty())//判断生命牌那一堆是否为空
	{
		int p=a[13].front(),k=p;//记录生命牌此时最顶上的一张
		a[13].pop_front();//弹出最顶上的那一张
		while(p!=13)//判断这张是不是“死神”牌
		{
			s[p]++;//记录这个数字被翻了
			p=a[p].back();//记录这一堆最底下的那张牌
			a[k].pop_back();//弹出最底下那一张牌
			k=p;
		}
	}
	for(int i=1;i<=12;i++)
	{
		if(s[i]==4) ans++;//判断这个数字是否被翻出了四张，是的话，答案加一
	}
	cout<<ans;//输出答案
	return 0;//结束
}

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 题目分析
本题为模拟题，按题意模拟即可。
## 输入
本题坑一，前十二堆牌从下往上取，第十三堆从上往下。  
前十二堆：
```cpp
for(int i=1;i<=12;i++){
    	char b,c,d;
    	cin>>a>>b>>c>>d;
    	if(a=='0')a+=10;
    	if(b=='0')b+=10;
    	if(c=='0')c+=10;
    	if(d=='0')d+=10;//处理10
    	q[i].push(d);
    	q[i].push(c);
    	q[i].push(b);
    	q[i].push(a);//反存
}
```
十三堆：
```cpp
   char b,c,d;
   cin>>a>>b>>c>>d;
   if(a=='0')a+=10;
   if(b=='0')b+=10;
   if(c=='0')c+=10;
   if(d=='0')d+=10;
   q[13].push(a);
   q[13].push(b);
   q[13].push(c);
   q[13].push(d);
```
## 模拟
首先，$k$ 要判断。如果翻到 $k$，那么减掉一滴血，同时翻第十三堆。
```cpp
if(k=='K'){
	live--;
	k=q[13].front();
	q[13].pop();
	continue;
}
```
其余的模拟即可。
```cpp
if(k=='A'){
	k=q[1].front();
	q[1].pop();
	for(int i=1;i<=4;i++){
		if(!f[1][i]){
			f[1][i]=1;
			break;
		}
	}
}else if(k=='J'){
	k=q[11].front();
	q[11].pop();
	for(int i=1;i<=4;i++){
		if(!f[11][i]){
			f[11][i]=1;
			break;
		}
	}
}else if(k=='Q'){
	k=q[12].front();
	q[12].pop();
	for(int i=1;i<=4;i++){
		if(!f[12][i]){
			f[12][i]=1;
			break;
		}
	}
}else{
	char c=q[k-'0'].front();
	q[k-'0'].pop();
	for(int i=1;i<=4;i++){
		if(!f[k-'0'][i]){
			f[k-'0'][i]=1;
			break;
		}
	}
	k=c;
}
```
完。

---


# 「Wdsr-2.5」小小的埴轮兵团

## 题目背景

杖刀偶磨弓是埴轮兵团的首长。

作为埴轮兵长，训练埴轮兵团是很平常的事情。

## 题目描述

磨弓下达命令让埴轮们站成一行。不妨认为它们站在了一个数轴上，每个埴轮的位置就是它脚下数轴的数字。磨弓会告诉你，第 $i$ 个埴轮的位置为 $a_i$ 。**不保证** $\bm {a_i}$ **升序**。

数轴的长度是有限制的，具体的范围是 $[-k,k]$ 。也就是说，如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。

为了训练埴轮，磨弓给埴轮们下达了 $m$ 个指令，有以下 3 种：

- 指令 1：**全体埴轮**向数轴的正方向移动 $x$ 个单位长度。
- 指令 2：**全体埴轮**往数轴的反方向移动 $x$ 个单位长度。
- 指令 3：依次报数，统计目前队列里一共有多少个埴轮。

但是磨弓发现，埴轮兵团的大小实在是太大了，以至于执行这些操作变得非常缓慢。尽管如此，磨弓仍然希望你告诉她所有指令 3 的结果。

## 说明/提示

#### 样例 1 说明

一共有三个埴轮。初始时，它们的站位分别是 $[-1,1,2]$ 。

- 第一次操作后，所有埴轮向左移动 $3$ 格，位置变成了  $[\underline{\bm{-4}},-2,-1]$ 。第一个埴轮被移出了数轴。
- 第二次操作后，输出当前的埴轮数目，为 $2$ 个。
- 第三次操作后，所有埴轮向右移动 $5$ 格，位置变成了 $[3,\underline \bm4]$ ，第二个埴轮被移出了数轴。
- 第四次操作后，输出当前的埴轮数目，为 $1$ 个。

#### 样例 2, 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 5\times 10^3$；
- 对于另外 $20\%$ 的数据，$1\le k\le 500$；
- 对于 $100\%$ 的数据，$1 \leq n, m \leq 3\times 10^5$，$1 \leq k, x \leq 2 \times 10^9$，$-k \le a_i \le k$ 。

## 样例 #1

### 输入

```
3 4 3
-1 1 2
2 3
3
1 5
3```

### 输出

```
2
1```

# 题解

## 作者：chlchl (赞：65)

## 题目描述
**[题目传送门](https://www.luogu.com.cn/problem/P7505)**

建议看完题不会再来看题解，不要一拿到题就往题解区狂奔。

简单来说，这道题的意思就是：有一个队列，里面有 n 个元素。现在有 m 个指令，每条指令只能是下面三种的其中一种：

1. 将队列里所有元素的值**增加 x**.
1. 将队列里所有元素的值**减少 x**.
1. 输出队列里值在 $\left[k, -k\right]$ 之间的**元素个数**。

而且，如果在某一轮，某个元素的值超出了这个给定范围，它就**不会再次回到队列中**（可以理解为被淘汰了）。

## 思路
题目已经~~疯狂地~~暗示我们了，这道题用的是**队列**。输入元素后先对其进行排序。接着，对于**每个指令1和指令2**，循环判断每一个元素 $a_i$ 在加上或减去 x 后是否在合法区间内。如果不是，就**弹出队列**。对于每个指令3，输出此时队列长度即可（~~STL 大法好！~~）。


用 STL 的 OIer 们请注意：

因为这道题两头都要判断，也就是说，**有可能会在尾部弹出**。所以，此时要用到 **deque**，俗称**双向队列**。

[不知道双向队列的可以点这里](https://www.cnblogs.com/elvisHuster/p/12584537.html)。

## 一些小坑
这题坑比较少，但如果没注意还是会丢分。

- 输入数据不保证 $a_i$ 升序，所以需要进行排序。
- 指令3不需要输入 x，所以不能直接将 op 和 x 一起输入。
- **~~五年 OI 一场空，不开 long long 见祖宗~~**，一定要注意数据范围，本题需要用 long long。

## 代码
代码实现难度也不大，我是个~~很懒的人~~，所以用的是 STL 实现队列。其他题解里也有很多手写队列的，大家也可以去看看。

$Code$：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll N = 300000 + 10;
ll n, m, k, op, x, tot, a[N];
//tot记录目前一共向正方向移动了多少个单位，可以是负数（负数代表向反方向移动） 
deque<ll> q;//定义双向队列 

int main(){
	cin >> n >> m >> k;
	for(ll i=1;i<=n;i++)	cin >> a[i];//需要另开一个数组输入，因为要排序 
	sort(a + 1, a + 1 + n);//排序 
	for(ll i=1;i<=n;i++)	q.push_back(a[i]);//进队 
	for(ll i=1;i<=m;i++){
		cin >> op;
		if(op == 3)	cout << q.size() << endl;//输出队列长度，也就是元素个数 
		else if(op == 1){
			cin >> x;
			tot += x;//刷新tot 
			while(!q.empty()){
				ll v = q.back();
				if(v + tot > k)	q.pop_back();//如果此埴轮移动完超过k，就被淘汰了 
				else	break;
			}
		}else if(op == 2){
			cin >> x;
			tot -= x;//刷新tot 
			while(!q.empty()){
				ll v = q.front();
				if(v + tot < -k)	q.pop_front();//如果此埴轮移动完小于-k，也会被淘汰 （从队头弹出） 
				else	break;
			}
		}
	}
	return 0;
}
```
本篇题解到此结束，如果对你有收获别忘了点赞哦！有什么问题也可以在评论区提出，作者很乐意为你解答。

---

## 作者：幼儿园第一名 (赞：9)

题目意思很明显了。

我们可以设定一个```sum```变量，当操作一时就增加 $x$，当操作二时就减少  $x$。

我们还要设定```l```和```r```，操作一时从 $r$ 循环到 $l$ ，如果$a_i+sum$ 超过右边界，那么 $r$ 减少一，并且给这个点打上标记。

同理，操作二时从 $l$ 循环到 $r$ ，如果$a_i+sum$ 小于左边界，那么 $l$ 增加一，并且给这个点打上标记。

在每次循环的时候，如果这个点已经被打上标记了，就可以退出循环了。

在操作三时，我们只需要输出 $r-l+1$ 就可以了，也就是现在还在队列中的埴轮个数。

当然，我们在最早的时候要将队列**升序**排序，才可以保证我们思路的正确性。

code：
```
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<cstring>
#include<cmath>
#define R register
#define int long long

using namespace std;

#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read() {
    R char c=getchar();R int x=0;R bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c&15);
    return f?(~x+1):x;
}

//快读

typedef long long ll;

const int N=300005;
const int M=300005;
const int INF=0x3f3f3f3f;

int a[N],n,m,k,l_k,r_k;

bool f[N];

//主函数从此开始

signed main() {
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++) {
		f[i]=false;
	}
	for(int i=1;i<=n;i++) {
		a[i]=read();
	}
	sort(a+1,a+1+n);
	l_k=-k,r_k=k;
	int l=1,r=n;
	int ans=n;
	int sum=0;
	while(m--) {
		int opt=read(),tp=0;
		if(opt==1) {
			int x=read();
			sum+=x;
			for(int i=r;i>=l;i--) {
				if(f[i]==true) {
					break;
				}
				if(a[i]+sum>r_k) {
					f[i]=true;
					tp++;
				}
				else {
					break;
				}
			}
			r-=tp;
		}
		else if(opt==2) {
			int x=read();
			sum-=x;
			for(int i=l;i<=r;i++) {
				if(f[i]==true) {
					break;
				}
				if(a[i]+sum<l_k) {
					f[i]=true;
					tp++;
				}
				else {
					break;
				}
			}
			l+=tp;
		}
		else if(opt==3) {
			if(r-l<0) {
				puts("0");
			}
			else {
				printf("%lld\n",r-l+1);
			}
		}
	}
}
```


---

## 作者：Aw顿顿 (赞：8)

一道不错的模拟。

## 做法

先把不保证升序的埴轮进行排序，然后可以开始处理。

可以发现，这其实是一个双头队列的模拟操作。但我们显然不能简单地进行模拟，因为 $O(mn)$ 的时间复杂度难以承受，我们需要利用其它变量来进行记录。

定义变量 $\omega$ 表示当前移动的情况，具体地：

- 向右移动时，操作 $\omega\leftarrow\omega+x$。
- 向左移动时，操作 $\omega\leftarrow\omega-x$。

而对于每一次的操作，我们需要从队尾和队头进行判断，将其原本位置加上当前变化量 $\omega$，得到其真实位置，再判断是否出队，由于仅仅有出队操作，所以整体手写 `deque` 难度不高。

## 实现

对于 $[-k,k]$ 的队列，显然我们只需要分情况（队头或队尾），在与其对应的部分进行比较即可，即：

$$a_l+\omega<-k\quad a_r+\omega>k$$

显然在满足这两种情况的时候需要出队，具体地，需要 `l++` 或者 `r--`。务必注意，在判断时须确认队是否已空，即是否始终有 $l\le r$。

对于询问，仅仅需要输出 $r-l+1$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,op;
int k,a[300005],x,w;
signed main(){
    cin>>n>>m>>k;
    int l=1,r=n;
    for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=m;i++){
		cin>>op;
		if(op==3){
			cout<<r-l+1<<endl;
			continue;
		}cin>>x;
		if(op==1){
			w=w+x;
			while(a[r]+w>k&&l<=r)r--;
		}else if(op==2){
			w=w-x;
			while(a[l]+w<-k&&l<=r)l++;
		}
	}
	return 0;
}
```

[本代码 AC 记录](https://www.luogu.com.cn/record/49577682 "因为完全隐私保护，截至题解发布时不可查看")

---

## 作者：UperFicial (赞：7)

# 尛你题

### 前言

抢到题解一血纪念一下（

感觉我的做法挺 NAIVE，原因我就特 NAIVE。

思路大致是二分+树状数组。

但跑的还算是快，然后沿着这个思路乱搞就可以了（

赛时树状数组初始化的差分写错，成功爆蛋（

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P7505)

### 题意简述

给你坐标轴上 $n$ 个点，支持三种操作：

- 将所有的点的坐标加 $x$。

- 将所有的点的坐标减 $x$。

- 输出目前有多少个点。

**注意：所有的点只能在 $[k,-k]$ 这个区间移动，超出这个区间这个点就消失了，且不会再回来。**

### 题目解析

很容想到先排序，因为本题跟点的数量没有关系。

既然排好了序，那么对于每次更新操作，我们就可以二分出一个编号尽量小的点并使得它在移动后超出了 $[k,-k]$ 这个范围。

然后这个点左边的点就是剩下的点。

但问题是点的坐标也在不断的更新，需要一个 DS 来维护。

当然是用树状数组辣。

但注意到这是区间修改单点查询，那么需要差分一下即可。

注意要开 $\text{long long}$。

具体细节看代码吧，细节还是挺多的。

~~但显然这是个歪解，不过跑的飞快~~

[$code$](https://paste.ubuntu.com/p/Qr2qzSHfHZ/)

[$AC$ 链接](https://www.luogu.com.cn/record/49117145)

时间复杂度：$O(n\log n)$，此时 $n,m$ 同阶。

空间复杂度：$O(n)$。

$$\texttt{The End.by UF}$$

---

## 作者：wangbinfeng (赞：5)

首先，感谢大家阅读这篇题解。


------------

# 1. 思路：
（1）我们看到这个题，发现“**不保证 $\bm {a_i}$升序**”加粗，这给了我们一些思路。若本题是升序，则此题可以用**二分**解决。

（2）证明：若所有数都移动 $+x$ ，则若 $a[i]>k$ ,则$a[i+1],a[i+2]...>k$，反之亦然。

（3）既然我们已经证明出若本题升序时**二分**正确，则本题先**排序**再处理也正确。
# 2. ~~代码：~~
都讲~~这么清楚~~了，代码就不用给出了吧！
## 小细节：
若直接按照如上步骤，每个$a[i]±x$肯定会超时，说以我们可以不必给每个 $a[i]$ 都 $±x$，只需存一个**偏移量** $±x$，判断时直接**±偏移量**即可。


------------
最后，感谢大家阅读。


---

## 作者：EgLund (赞：4)

首先~~当然要~~排序。

然后，我们用指针维护最左端和最右端，同时维护累计向右移动距离 $d$ （向左为负）。

对于操作 1，求解第一个大于 $k+d$ 的前一个；

对于操作 2，求解第一个大于等于 $-k+d$ 的；

我们可以使用`stl`中`lower_bound`和`upper_bound`函数完成。注意先更新 $d$ 再计算。

对于操作 3，减一减即可。

拿样例模拟一下，

![](https://cdn.luogu.com.cn/upload/image_hosting/cp5lb44s.png)

复杂度还是 $\mathcal O((n + m) \log n)$。

Code：
```
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
int *l,*r,a[300003],n,q,k,d=0,typ,kkk;
signed main()
{
	cin>>n>>q>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	l=a+1,r=a+n+1;
	sort(l,r);
	while(q--)
	{
		cin>>typ;
		if(typ==1){cin>>kkk;d-=kkk;r=upper_bound(l,r,k+d);}
		if(typ==2){cin>>kkk;d+=kkk;l=lower_bound(l,r,-k+d);}
		if(typ==3)cout<<r-l<<endl;
	}
}
```

---

## 作者：_Scaley (赞：3)

## 题意概括

一开始给一个长度为 $n$ 的序列 $a$ 和一个范围 $[-k, k]$，

接下来有操作会给 $a$ 的所有元素加上 $x$ 或减去 $x$，

同时需要查询并输出若干个操作后还在该范围的 $a$ 中元素的数量。

**注意：一旦某个元素已经离开该范围，则不再计入查询。**

## 解法分析

每次的加减操作用暴力去模拟无疑是不太明智的，我们可以换个思路：

考虑 $a$ 中的元素与范围的相对大小。

### 原因

需要查询的是元素个数，而不是元素大小，那么元素真正的大小可以去忽略。

此时剩下的问题就是如何改变元素与范围的相对位置。

我们可以看一下下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mq5rme6i.png)

其中对于元素 $w$，是在范围 $[-k, k]$ 中的。

如果我们对 $w$ 加上 $k - w + 1$，则此时 $w$ 的值出了范围 $[-k, k]$，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/m42nedau.png)

但我们可以换个思路：改变范围 $[-k, k]$。

可以看出，当 $w$ 更新为 $k + 1$ 后，新的元素比范围的右端点大 $1$，比范围的左端点大 $2k + 1$。

尝试不改变 $w$，而是将范围整体向左移 $k - w + 1$ 个单位。

此时会变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/fn7drajk.png)

此时元素 $w$ 比范围右端点大 $1$，比范围的左端点大 $2k + 1$。

若不看元素的大小，只看相对大小，此时这种方法与上种方法达成的效果相同。

那么我们可以通过改变范围来达成加减操作。

### 更新操作

如何来快速更新在新的范围内 $a$ 中有用元素的个数呢？

这时候就需要**二分查找**了。

先对 $a$ 进行排序，这样满足二分查找的条件。

设 $L$ 和 $R$ 记录 $a$ 中有用元素的左端点和右端点，$kl$ 和 $kr$ 表示范围的左端点和右端点。

每次在 $a[L]$ 和 $a[R]$ 内找到大于等于 $kl$ 的第一个元素，将其位置记为 $L$；

在 $a[L]$ 和 $a[R]$ 内找到小于等于 $kr$ 的最后一个元素，将其位置记为 $R$。

由于每次只在 $L$ 到 $R$ 中查找，这样就可以避免已经出范围的元素再进范围的情况了。

部分代码：

```cpp
void work() {
	if (R - L + 1 <= 0) return ; //不用再更了，已经没有元素在范围里了。
	if (kr < tmp[L] || kl > tmp[R]) { // 算是偷个懒。
		L = 0, R = -1;
		return ;
	}
	int ansl, ansr, l = L, r = R, mid;
	while (l < r) { //查找出大于等于 kl 的第一个元素的位置。
		mid = (l + r) >> 1;
		if (tmp[mid] < kl) l = mid + 1;
		else r = mid;
	}
	ansl = l; //记录下来
	l = L, r = R; //重新二分
	while (l + 1 < r) { //查找出小于等于 kr 的最后一个元素的位置。
		mid = (l + r) >> 1;
		if (tmp[mid] > kr) r = mid - 1;
		else l = mid;
	}
	if (tmp[r] <= kr) ansr = r;
	else ansr = l;
	L = ansl, R = ansr; //更新 L 和 R 。
}
```

**对于操作 1：**

给范围减去 $x$，更新查询元素数量。

其中为什么是减去而不是加上，可以自己画个图来看一看。

为什么要立刻更新元素数量而不是用一个变量来叠加操作？

这是因为**一旦某个元素已经离开该范围，则不再计入查询**。

**对于操作 2：**

参考上一个操作。

**对于操作 3：**

用两个变量来记录有用元素的左端点和右端点（序列已排序过）。

每次输出 $\text{右端点} - \text{左端点} + 1$ 就行了。

**注意：记得开 long long ！**

### 全部代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MAXN 300010
#define int long long
using namespace std;

int n, m, kl, kr, L, R;
int tmp[MAXN];

inline int read() {
	int f = 0, x = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
	return f ? -x : x;
}
void work() {
	if (R - L + 1 <= 0) return ;
	if (kr < tmp[L] || kl > tmp[R]) {
		L = 0, R = -1;
		return ;
	}
	int ansl, ansr, l = L, r = R, mid;
	while (l < r) {
		mid = (l + r) >> 1;
		if (tmp[mid] < kl) l = mid + 1;
		else r = mid;
	}
	ansl = l;
	l = L, r = R;
	while (l + 1 < r) {
		mid = (l + r) >> 1;
		if (tmp[mid] > kr) r = mid - 1;
		else l = mid;
	}
	if (tmp[r] <= kr) ansr = r;
	else ansr = l;
	L = ansl, R = ansr;
}

signed main() {
	n = read(); m = read(); kr = read();
	kl = -kr;
	for (int i = 1; i <= n; ++i) tmp[i] = read();
	sort(tmp + 1, tmp + 1 + n);
	L = 1, R = n;
	work();
	for (int i = 1, opt, x; i <= m; ++i) {
		opt = read();
		if (opt == 1) {
			x = read();
			kl -= x, kr -= x;
			work();
		}
		else if (opt == 2) {
			x = read();
			kl += x, kr += x;
			work();
		}
		else printf("%lld\n", (R - L + 1 >= 0) ? R - L + 1 : 0);
	}
	return 0;
}
```

码风丑请别介意……

---

## 作者：囧仙 (赞：3)

## 题解

在下文中，我们设 $a_i$ 表示初始时每个埴轮的位置， $a_i'$ 表示经过若干次操作后当前埴轮所在的位置。

本题中，只有“所有埴轮位置加上（减去） $x$ ”这种操作。因而，每个埴轮的相对位置是不变的。同时，所有的 $a_i'-a_i$ 的值应该是一个定值，不妨设为 $d$ ，那么就有 $a_i'=a_i+d$ 。初始时，$d=0$ 。每次操作时，我们不需要真正对所有 $a_i'$ 进行操作，而是更新 $d$ 的值。具体而言：

- 对于操作 $1$ （全体埴轮向右移动 $x$ 单位），我们只要令 $d\gets d+x$ 。

- 对于操作 $2$ （全体埴轮向左移动 $x$ 单位），我们只要令 $d\gets d-x$ 。

下面考虑如何解决出队的问题。显然，每次出队的应当都是**队列最左端或者最右端**的埴轮。假如我们将所有埴轮按照 $a_i$ 排序，那么保留下来的埴轮应当是初始时队列的一个连续的子区间 $[l,r]$ ，**或者空集**（即，此时队列里没有埴轮了）。

因此，每次操作本质上就是缩减 $[l,r]$ 。对于操作 $1$ ，可能出队的肯定是最右端的埴轮。因此我们从 $r$ 开始，往左弹出所有不在 $[-k,k]$ 内的埴轮，直到 $r<l$ 或者 $a_r+d\le k$。对于操作二，可以如法炮制。出队操作结束后，剩余的埴轮总个数应当是 $r-l+1$ 。

关于时间复杂度的正确性： $l$ 最多向右移动 $n$ 次， $r$ 最多向左移动 $n$ 次，这部分复杂度为 $\mathcal O(n)$ 。考虑到排序的复杂度为 $\mathcal O(n\log n)$ ，于是总复杂度为 $\mathcal O(n\log n)$ 。

---

顺带一提，如果你一些变量使用的是 $\text{int}$ 类型，并且没有强制类型转换，可能被极限数据卡掉。比如， $k=2\times 10^9$ ，然后存在 $a_t=2\times 10^9$ 。这时下达了一个向右移动的指令，此时 $d=2\times 10^9$ 。然后 $a_t+d=3\times 10^9$ 在 $\text{int}$ 下会溢出，本来应该被弹出来的 $a_t$ 并没有被弹掉，导致答案错误。边界问题，在 $\text{OI}$ 赛制中是要着重考虑的。



## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long i64;
const int INF =2147483647;
i64 qread(){
    i64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =3e5+3;
i64 n,m,p,q,k,A[MAXN],d;
char fil[256];
int main(){
    n=qread(),m=qread(),k=qread(),p=1,q=n,d=0;
    up(1,n,i) A[i]=qread(); sort(A+1,A+1+n);
    up(1,m,i){
        int op=qread();
        if(op==1){d+=qread();while(p<=q&&A[q]+d> k) --q;} else
        if(op==2){d-=qread();while(p<=q&&A[p]+d<-k) ++p;} else
        printf("%lld\n",q-p+1);
    }
    return 0;
}
```

---

## 作者：信息向阳花木 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7505)

这个题，其实需要用到二分优化。

题目本来就很简洁，我不简化了啊。

### 思路

* 排序
* 对于每次移动，我们就二分出一个编号尽可能小的点并使得它在移动后超出了 $[k,-k]$ 这个范围，超出范围后，它左边的点没有超出范围（我们已经选最小的了）。
* 二分证明
> 证明：若所有数都移动 $+x$ ，则若 $a[i]>k$ ,则 $a[i+1],a[i+2] ...>k$，移动 $-x$ 也一样。

### 细节
若每次真的 $+x$ 或 $-x$，可能会超时。所以，可以用一个偏移量计算有没有超出边界。

代码不给了，看到这里，您这样的大佬一定可以写出来，对吗？

### 谢谢阅读！

---

## 作者：Eason_AC (赞：2)

## Content
给出一个范围为 $[-k,k]$ 的数轴，数轴上有 $n$ 个点，第 $i$ 个点的位置为 $a_i$。有 $m$ 次操作，有且仅有以下三种：
- `1 x`：所有点往右移动 $x$ 个单位。
- `2 x`：所有点往左移动 $x$ 个单位。
- `3`：求出还在数轴范围以内的点的个数。

如果在某个操作中有点移出数轴范围了，那么尽管后面的操作能够把它拉回数轴上来，它也不能够回到数轴上面来了。 

**数据范围：$1\leqslant n,m\leqslant 3\times 10^5$，$1\leqslant k,x\leqslant 2\times 10^9$，$-k\leqslant a_i\leqslant k$。**
## Solution
方法非常地清晰，可以说是整场比赛最良心的一道题目。

首先，为了保证下面的解法合理，我们先将所有的点按照 $a_i$ 升序排序（**注意！题目中并没有保证这一点！**）。

然后我们不难发现，还在数轴范围上的点一定是在某个区间上的一个整体。所以我们考虑存储左边界和右边界。还需要将所有点**往右移动的距离**记为 $dis$。 

对于操作 $1$，我们只需要将 $dis\leftarrow dis+x$，然后再从右往左遍历所有编号在 $[l,r]$ 范围内的点：
- 如果当前遍历的点在之前已经不在数轴范围内了，那么停止遍历。
- 否则，如果当前遍历的点 $a_i+dis>k$，也就是超过了右边界，那么将它标记一下，并且将用来统计在该次操作中被移除数轴范围的点的个数的计数器 $cnt$ 加 $1$。
- 否则，就说明当前遍历的点在数轴范围了，不用再往左遍历了，停止遍历。
- 操作完以后记得将右边界 $r$ 减去统计的在该次操作中被移除数轴范围的点的个数，即 $r\leftarrow r-cnt$。 

对于操作 $2$，我们只需要将 $dis\leftarrow dis-x$，然后再从左往右遍历所有编号在 $[l,r]$ 范围内的点：
- 如果当前遍历的点在之前已经不在数轴范围内了，那么停止遍历。
- 否则，如果当前遍历的点 $a_i+dis<-k$，也就是超过了左边界，那么将它标记一下，并且将用来统计在该次操作中被移除数轴范围的点的个数的计数器 $cnt$ 加 $1$。
- 否则，就说明当前遍历的点在数轴范围了，不用再往右遍历了，停止遍历。
- 操作完以后记得将左边界 $l$ 加上统计的在该次操作中被移除数轴范围的点的个数，即 $l\leftarrow l+cnt$。

对于操作 $3$，我们需要特判一下是否有 $r<l$，如果是的话说明已经没有点在数轴上面了，答案是 $0$，否则答案就是 $r-l+1$。

最后注意一点，上面的操作中 $a_i+dis$ 可能会超出 `int` 的范围 $[-2^{31},2^{31})$，会导致你 `WA 50`，因此要开 `long long`。
## Code
```cpp
const int N = 3e5 + 7;
int n, m, k, L, R, l, r, x, vis[N];
ll dis, a[N];

int main() {
	n = Rint, m = Rint, k = Rint, L = -k, R = k, l = 1, r = n;
	F(int, i, 1, n) a[i] = Rint; sort(a + 1, a + n + 1);
	while(m--) {
		int op = Rint, out = 0;
		if(op == 1) {
			dis += (x = Rint);
			R(int, i, r, l) {
				if(vis[i]) break;
				else if(a[i] + dis > R) vis[i] = 1, out++;
				else break;
			}
			r -= out;
		} else if(op == 2) {
			dis -= (x = Rint);
			F(int, i, l, r) {
				if(vis[i]) break;
				else if(a[i] + dis < L) vis[i] = 1, out++;
				else break;
			}
			l += out;
		} else println(r < l ? 0 : r - l + 1);
	}
    return 0;
}
``` 

---

## 作者：DWT8125 (赞：1)

题意很明显了，我就不多说了。[题目传送门](https://www.luogu.com.cn/problem/P7505)
### 错误思路【淼】
1. 看到**全部**埴轮要移动同样的单位长度，第一反应就是差分…… 我们可以设个变量 $tmp$ 来存放埴轮的现在距离与原来距离的变化，当输入```1 x```
就```tmp-=x;```，输入```2 x```就```tmp+=x;```。
1. 更新 $l$ 和 $r$时，本来想要二分，不过不用那么复杂。我们回顾题目：**如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。**
这说明了什么？区间长度只减不增， $l$ 和 $r$ 在整个程序中最多只移动 $n$ 次（最少有 $0$ 个埴轮），不用担心超时问题。

### 注意事项
1. **不保证 $a_i$ 升序**；这个容易解决，用 ```sort(a+1,a+n+1);```就行了。
1. $1 \leq x \leq 2 \times10^9$ , $1 \leq m \leq 3 \times10^5$ ；最大值是 $x \times m$ ，要开```long long```。
### AC代码
禁止抄袭，我可不希望看见您因为这篇题解变成作弊者！

```cpp
//P7505AC代码
#include<bits/stdc++.h> //万能头
using namespace std;
#define ll long long
ll tmp,a[300005],x,n,m,k,op,l=1,r;
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1); r=n; //准备工作
	while(m--){
		scanf("%lld",&op);
		if(op==3&&r-l+1==0){ //特判已经没有埴轮在区间中的情况
			printf("0\n");
			continue;
		}
		if(op==1||op==2){
			scanf("%lld",&x);
			if(op==1){
				tmp+=x;
				for(;a[r]+tmp>k&&r-l+1!=0;r--); //新颖的写法，在a[r]+tmp<=k前一直缩小右边界
			}
			else{
				tmp-=x;
				for(;a[l]+tmp<-k&&r-l+1!=0;l++); //同上一条注释，在a[l]+tmp>=-k前一直缩小左边界
			}
		}
		else printf("%lld\n",r-l+1);
	}
	return 0; //记得加上，养成好习惯
} 
```

如果有错误的地方，求指正！

---

## 作者：fanypcd (赞：1)

# UPD on June 22th：修正错误
### 题目简述：

有一个由 $n$ 个数 $pos_1, pos_2, ... pos_n$ 组成的序列，每次操作将所有数加 $x$ 或 减 $x$，如果某时刻 $pos_i< -k$ 或者 $pos_i> k$ 则将 $pos_i$ 从序列中删除，操作的同时询问序列中还剩下多少个数。

### 题目思路：

- 模拟（真的模拟，注意 int 会炸）
- 考虑用一个队列来模拟这个序列（先排好序）
- 如果是加操作则从队列尾弹出数，直到队尾再次合法或者队列已空
- 减操作则从队头弹出，同理
- 楼上楼下好多都是手写的队列，我就纳闷了 STL 都封装好了不用干嘛
- 所以这里给一份 STL 的代码，双端队列实现

- [什么是队列容器](https://oi-wiki.org/lang/csl/sequence-container/)
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
deque<long long> q;
long long n, m, k, delta, pos[300005];//使用delta记录位移的值，这样实际的数就是 pos[i] + delta
int main()
{
	ios::sync_with_stdio(false);//读入优化
	cin >> n >> m >> k;
	for(long long i = 1; i <= n; i++)
	{
		cin >> pos[i];
	}
	sort(pos + 1, pos + n + 1);
	for(long long i = 1; i <= n; i++)
	{
		q.push_back(pos[i]);
	}
	long long opt, x;
	for(long long i = 1; i <= m; i++)
	{
		cin >> opt;
		if(opt == 3)
		{
			cout << q.size() << endl;
			continue;
		}
		cin >> x;
		if(opt == 1)
		{
			delta += x;
			while(!q.empty())
			{
				long long ba = q.back();
				if(ba + delta > k)
				{
					q.pop_back();
				}
				else
				{
					break;
				}
			}
		}
		else if(opt == 2)
		{
			delta -= x;
			while(!q.empty())
			{
				long long fr = q.front();
				if(fr + delta < -k)
				{
					q.pop_front();
				}
				else
				{
					break;
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：Kalium (赞：1)

# P7505 小小的埴轮兵团题解

## 前言：

whk原因没参加比赛，听说T2是大模拟（/fad）。

本题解有防抄袭(~~freopen~~)，文件名即为歌名，有兴趣的听听。

## 题意：

给你指定区间，在 N 此操作后，多少个数在此区间内。

## 思路：

题目没说按照升序降序，先排个序。

### 第一眼暴力：

一个个数模拟，每次操作后遍历一遍，看看里面有多少数存在着，碰到3操作时在输出。

做法常规，送水的。

代码懒得贴（~~就没写这个~~）。

### 进一步的模拟：

我们在模拟上更进一步。

用l, r来表示当前区间的左右端点，用sum储存总共操作了多少距离。

明显，当操作1的时候，$sum += k$。

操作2的时候，$sum -= k$。

遍历下去，碰见第一个不行的，标记打在当前字母的前（$op == 1$）或后（$op == 2$）。

输出就输出 $r - l + 1$ 即可。

但是随便一组没有数字在操作完出去的数据即可卡掉。

还得优化

### 正解：

我们用 $flag_i$ 表示这个点出去过没。

这时候我们倒序，碰见 $a_i + sum > k$ （$op == 1$）的情况，我们将 $flag_i$ 标记，然后用 rem 来记录经过了几个出去了。

如果碰到第一个符合条件的，说明下面的必然符合条件，跳出即可。

如果碰到当前的点出去过了了，那么前面的必然是出去过的或者符合条件的，跳出。

$op == 2$ 同理。

## 细节：

注意 long long，不然只有50pts。

## 代码：

```cpp
#include <cstdio>
#include <algorithm>
#define ll long long

const int N = 3e5 + 7;

using namespace std;

int n, m;

ll k;

ll a[N];

bool flag[N];

inline bool cmp(ll x, ll y) {
	return x < y;
} 

int main() {
	freopen("skin.in", "r", stdin);
	freopen("skin.in", "r", stdin);
	
	scanf("%d %d", &n, &m);
	scanf("%lld", &k);
	
	for (int i = 1; i <= n; i ++)
		scanf("%lld", &a[i]);
		
	sort(a + 1, a + 1 + n, cmp);
	
	ll sum = 0;
	int l = 1, r = n;
	
	for (int i = 1, op, move; i <= m; i ++) {
		int rem = 0;
		
		scanf("%d", &op);
		
		if (op == 1) {
			scanf("%d", &move);
			
			sum += move;
			
			for (int j = r; j >= l; j --) {
				if (flag[j]) break;
				
				if (a[j] + sum > k) {
					rem ++;
					flag[j] = 1;
				} else
					break;
			}
			
			r -= rem;
		} else if (op == 2) {
			scanf("%d", &move);
			
			sum -= move;
			
			for (int j = l; j <= r; j ++) {
				if (flag[j]) break;
				
				if (a[j] + sum < -k) {
					rem ++;
					flag[j] = 1;
				} else
					break;
			}
			
			l += rem;
		} else {
			if (r - l + 1 <= 0)
				printf("0\n");
			else 
				printf("%lld\n", r - l + 1);
				
			//printf("%d %d\n", l, r);
		}
	} 
	
	fclose(stdin);
	fclose(stdout);
	
	return 0; 
} 
```

$Atlantic.$


---

## 作者：ZZQF5677 (赞：0)

[题目](https://www.luogu.com.cn/problem/P7505)
### 题意
让一些数字坐标进行移动，每次越界淘汰后询问剩余没有去除的点。

### 解题思路
本题主要考的就是排序和队列。
开始，虽然这题坐标有负数，如果开个数组去存，但是在庞大的数据下显然会超时并且运行是错误的，所以，我们就可以使用两个指针来计算每次移动时领头移动端点越界的人数，从而淘汰。

### 方法
+ 建立 $wz$ 变量做标记点，作为每次端点的移动范围。
+ 然后每次输入移动范围 $x$ 时就 $wz \gets wz + x$ 。
+ 然后从领头移动点出发遍历后面，后面端点有没有越界的，越界了就缩端队列。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 5;
int a[N], n, m, k;
int main() {
  int op, x, l = 1, r;  //设立左右边界。
  long long wz = 0;     //移动标记器。
  cin >> n >> m >> k;
  r = n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  sort(a + 1, a + 1 + n);
  for (int i = 1; i <= m; i++) {
    cin >> op;
    if (op == 1) {
      cin >> x;
      wz += x;                           //加上要移动的范围。
      while (a[r] + wz > k && l <= r) {  //缩减右侧区间淘汰的人。
        r--;
      }
    }
    if (op == 2) {
      cin >> x;
      wz -= x;                            
      while (a[l] + wz < -k/*不用担心wz会因为是左右两个端点的标记点就会导致出差错，因为相对于另一边来说，假如本次是减法上一次是加法会抵消掉一部分，就是因为这样，两个端点才可以同时用一个标记变量。*/ && l <= r) {  //缩减左侧区间淘汰的人。
        l++;
      }
    }
    if (op == 3) {
      if (r >= l) {
        cout << r - l + 1 << endl;
      } else {  //没有人了。
        cout << 0 << endl;
      }
    }
  }
  return 0;
}
```

---

## 作者：STL_qwq (赞：0)

原题链接：[传送门](https://www.luogu.com.cn/problem/P7505)

------------

#### 题目大意：

这道题大致就是说，给你几个点坐标，让它们在根据给定的操作数轴上移动，并给定这个数轴的范围，**每个点出了数轴就不能再回来**。问你经过若干次操作以后，数轴上还剩几个数。

------------
#### 分析：

- 首先我们发现对于一个区间，区间内数的个数等于右指针与左指针的差加一。

  我们令区间个数为 $tot$ ，左，右指针分别为 $l,r$ ;

  就能得到： $tot=r-l+1$ 。

- 我们还发现，对于一个升序序列而言：

  对于向左移动的操作：我们左移后，只需要判断左端点经过操作后是否在区间内，如果不在，我们就将左指针右移来更新左端点。

  向右的操作同理，右移后，对右端点判断，如果右端点超过区间，那么就右指针往左移，直到第一个在区间内的数即为新的右端点。

所以在这道题中，**我们只需要先排个序，不断更新左端点和右端点，并在每次查询时输出区间个数即可**。

------------
 时间复杂度: $O(n \log n)$ 。

------------
#### **AC 代码：**

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define ll long long//记得开 long long 

using namespace std;

ll n, m, k,a[310000],l,r,ans,x,y;

inline ll read()//快读。 
{
	ll x = 0, f = 1; char ch = getchar();
	while (ch<'0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0'&&ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
	return x * f;
}

int main() {

	n = read(); m = read(); k = read();
	for (int i = 1; i <= n; i++) 
		a[i] = read();//读入。 
	sort(a + 1, a + 1 + n);//排序 。
	l = 1;r = n;//左右端点赋值。
	while (m--) {
		x = read(); 
		if (x == 2) {
			ans -= read();//用ans计更改。
			while (l<=r) {
				if (a[l] + ans < -k){ 
					l++;
				} 
				else break;
			}//更新左端点。 
		}
		else if (x == 1) {
			ans += read();//同上ans。
			while (l<=r) {
				if (a[r] + ans > k){
					r--;
				}
				else break;
			}//更新右端点。 
		}
		else if(x == 3){
			printf("%lld\n", r - l + 1);//输出剩余的个数，记得+1。 
		}
	}
	return 0;
}
```

---

## 作者：CPPfive (赞：0)

## 分析

首先，很显然的一点是，在从小到大排序之后，任何时候在数轴上的埴轮都是连续的，并且只会减少不会增加。

因此我们直接维护目前仍在数轴上的区间的左端点和右端点，每次移动时查看左端点与右端点是否仍在数轴上，如果不在就把左端点右移或者右端点左移，直到左端点或右端点在数轴上（向右移时更新右端点，向左移时更新左端点），并且相适应地更新数轴上点的数量。

总复杂度 $\mathcal{O}(N*\log{N})$。

## 代码
```
//洛谷P7505 

#include <bits/stdc++.h>
using namespace std;
const int MAXN=300050;
long long N,M,K,a[MAXN],lpt,rpt,delta,ans;//delta表示数轴上的点移动的路程，ans表示目前还在数轴上的点的数量
//lpt、rpt是目前在数轴上的区间的左端点和右端点 

int main()
{
	std::ios::sync_with_stdio(false); //输入优化 
	cin >> N >> M >> K;
	for(int i=1;i<=N;i++){
		cin >> a[i];
	}
	sort(a+1,a+N+1);
	lpt=1;rpt=N;delta=0;ans=N;
	for(int i=1;i<=M;i++){
		int op;cin >> op;
		if(op==1){
			int x;cin >> x;
			if(lpt>rpt) continue; 
			delta+=x;
			while(a[rpt]+delta>K){
				--rpt;
				--ans;
			}
		}
		else if(op==2){
			int x;cin >> x;
			if(lpt>rpt) continue;
			delta-=x;
			while(a[lpt]+delta<-K){
				++lpt;
				--ans;
			}
		}
		else{
			if(ans<0) ans=0;//会出现ans小于0的情况，注意修正 
			printf("%d\n",ans);
		}
	}
}
```


---

## 作者：Daidly (赞：0)

维护一个区间，设定区间 $l,r$ 和一个此前所有 $x$ 之和 $sumx$

需要保证区间不降，先排序。

初始时设定 $l=1,r=n,sumx=0$

若 $op=1$，则让 $sumx=sumx+x$，代替区间向正方向移动的过程。然后从区间最右端开始判断，如果 $a[r]+sumx>k$，则需要从区间最右端开始向左判断，每次需要把不符合条件的去掉（区间右端点向左移一位）。若有一个满足小于等于 $k$，即可停止（区间不降）。

若 $op=2$，则让 $sumx=sumx-x$，代替区间向反方向移动的过程。然后从区间最左端开始判断，如果 $a[l]+sumx<-k$，则需要从区间最左端开始向右判断，每次需要把不符合条件的去掉（区间左端点向右移一位）。若有一个满足大于等于 $-k$，即可停止（区间不降）。

若 $op=3$，则输出区间长度：$r-l+1$ 即可。

注意 $a[i],k,x,sumx$ 的数据范围，开`long long`。

可结合代码理解，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,op,l,r;
long long k,a[300005],x,sumx;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;++i)cin>>a[i];
	sort(a+1,a+n+1);
	l=1,r=n;
    while(m--){
    	cin>>op;
    	if(op==1){
    		cin>>x;sumx+=x;
    		if(a[r]+sumx>k){
    			for(int i=r;i>=l;--i){
    				if(a[i]+sumx>k)r--;
    				else break;
				}
			}
		}else if(op==2){
			cin>>x;sumx-=x;
			if(a[l]+sumx<-k){
    			for(int i=l;i<=r;++i){
    				if(a[i]+sumx<-k)l++;
    				else break;
				}
			}
		}else{
			cout<<r-l+1<<endl;
		}
	}
	return 0;
}
```


---

## 作者：luckydrawbox (赞：0)

## 题意

维护一个只有出队操作的双端队列。

## 分析

我们先将埴轮排好序，为了模拟出队操作，我们先定义队头 $l$ 为 $1$，队尾 $r$ 为 $n$，若队头出队，只需 ``l++``，若队尾出队，只需 ``r--``，对于每个指令 $3$，只需输出 ``r-l+1`` 即可。

不过，指令 $1、2$ 需要全体坐标全部加或减一个数，暴力去计算会得到 $O(nm)$ 的超时复杂度，所以我们可以用一个变量 $p$ 来表示整体移动的距离，对于每个指令 $1$，只需令 ``p+=x``，再用 ``a[r]+p<=k&&l<=r`` 来判断队尾是否超出范围，并不断进行出队处理；对于每个指令 $2$，只需令 ``p-=x``，再用 ``a[l]+p>=-k&&l<=r`` 来判断队头是否超出范围，并不断进行出队处理。

## 坑点

$x$ 最大为 $2* 10^9$，多次指令 $1$ 或 $2$ 可能会溢出 ``int`` 范围，所以要用 ``long long``。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3e5+10;
int n,m,l=1,r,op;
ll k,a[N],x,p;
int main()
{
    cin>>n>>m>>k;
    r=n;
    for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);//排序 
	for(int i=1;i<=m;i++)
	{
		cin>>op;
		if(op==3)//操作3 
		{
			cout<<r-l+1<<endl;
			continue;
		}
		cin>>x;
		if(op==1)//操作1 
		{
			p+=x;
			while(a[r]+p>k&&l<=r)//队尾出队 
				r--;
		}
		else//操作2 
		{
			p-=x;
			while(a[l]+p<-k&&l<=r)//队头出队 
				l++;
		}
	}
	return 0;
}
```

---


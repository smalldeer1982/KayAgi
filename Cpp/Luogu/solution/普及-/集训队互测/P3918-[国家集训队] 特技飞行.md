# [国家集训队] 特技飞行

## 题目背景

1. wqs 爱好模拟飞行。

2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。

注意：题目中只是用了这样一个背景，并不与真实/模拟飞行相符

## 题目描述

神犇航空开展了一项载客特技飞行业务。每次飞行长 $n$ 个单位时间，每个单位时间可以进行一项特技动作，可选的动作有 $k$ 种，每种动作有一个刺激程度 $c_i$。如果连续进行相同的动作，乘客会感到厌倦，所以定义某次动作的价值为(距上次该动作的时间) $ \times c_i$，若为第一次进行该动作，价值为 $0$。安排一种方案，使得总价值最大。

## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的测试数据，$n \le 20$，$k \le 3$。
- 对于 $100\%$ 的测试数据，$1 \le n \le 10^3$，$1 \le k \le 300$，$0 \le c_i \le 10^3$。

## 样例 #1

### 输入

```
5 2
2 2```

### 输出

```
12

```

# 题解

## 作者：SuperJvRuo (赞：22)

不难发现，同一动作，无论进行几次，其能带来的价值都是$c_i*$(最后一次进行的时间-首次进行的时间)

因此此题的本质是设计方案使得$\sum_{i=1}^kc_i*$(最后一次进行的时间-首次进行的时间)最大

贪心，让$c$大的动作相隔时间最长，尽可能地安排在两端，即可得到最优解

```
#include<cstdio>
#include<algorithm>
#include<functional>

int a[1005];

int main()
{
    int n, k;
    int ans = 0;
    scanf("%d%d", &n, &k);
    for(int i = 0; i < k; i++)
        scanf("%d", &a[i]);
    std::sort(a, a+k, std::greater<int>());
    n--;
    int i = 0;
    while(n > 0 && i < k)
    {
        ans += n*a[i];
        i++;
        n-=2;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：KillerXu (赞：8)

首先，因为做一次动作没有价值，所以至少做$2$个同样的动作才能产生价值。

然后不难发现，在两个相同动作之间的时间内再做这个动作，产生的价值和之前一样，所以是没有意义的。

#### 所以一个动作做且只做$2$次才有意义。

既然要产生最大价值，我们就安排$C_{i}$大的动作两次被做的时间尽量拉开，于是对$C_{i}$从大到小进行排序，最大的安排在第$1$和第$N$个单位时间做，接下来是第$2$和第$N - 1$，以此类推。当然在程序中，只需安排前$N / 2$个活动就可以算出结果了。当$N$是奇数时，最中间($N / 2 + 1$)的时间点随便安排什么动作都可以。

## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <algorithm>

#define MAXN 1005

using namespace std;

int n , k;
int c[MAXN];

bool cmp(int a , int b){
	return a > b;
}

int main(){
	
	cin >> n >> k;
	for(int i = 1; i <= k; i++) cin >> c[i];
	sort(c + 1 , c + k + 1 , cmp); // 从大到小排序 
	int ans = 0;
	for(int i = 1; i <= n / 2 && i <= k; i++) ans += c[i] * (n - (i * 2 - 1)); // 计算结果 
	cout << ans;
	return 0;
}
```

---

## 作者：三好代表 (赞：8)

### **这道题好像是，集训队里面最水的一道题了没有之一**
**看大总价值最大，不用想我的第一反应是：要么贪心，要么背包（这是本人的条件反射）   **  
然后仔细一看，唉！原来是排序+贪心，下面来说一说这俩有啥用  
**排序：**顾名思义将无序变为有序，那么在这里是用$sort$，从小到大排（为什么呢？下面会讲）  
**贪心：**怎么贪？他题目中所述的要总价值最大，那么在这里看来，每个动作的价值是固定的
	   所以只能改变极差，因为动作不能连续相同，所以，从极差最大的开始，不断缩小范围
	   以至于左边界大于或等于右边界为止  
贪完后就找一个变量$ans$来存总价值，此时的$ans$是最大的价值
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 11000;
int n,k;
int c[N];
int l=1,r,ans=0;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=k;i++)
		cin>>c[i];
	sort(c+1,c+k+1);
	r=n;
	for(int i=k;i>0;i--)
	{
		ans+=(r-l)*c[i];
		r--;
		l++;
		if(l>=r) break;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：D12241R (赞：6)

我们发现，每第一次展示一次飞行，后面一次就是与前面的差。

**每个飞行最多两次**，因为![](https://cdn.luogu.com.cn/upload/image_hosting/wwk2os90.png)














那么：

**贪心原则**：

$Max_1$ $in$ $time_1$ $and$ $time_n$

$Max_2$ $in$ $time_2$ $and$ $time_{n-1}$

$Max_3$ $in$ $time_3$ $and$ $time_{n-2}$

$Max_4$ $in$ $time_4$ $and$ $time_{n-3}$

$........$

其中，$Max$用$sort$实现(以$C_i$从小到大)，貌似要开$long long$
```
#include<stdio.h>
#include<algorithm>
#define R register
#define I inline
#define LL long long
#define maxk 301
LL n,k,j,ans;
LL a[maxk];
using namespace std;
I bool cmp(LL a,LL b)
{
	return a>b;
}
int main()
{
	scanf("%lld%lld",&n,&k);
	for(R int i=1; i<=k; i++)
	{
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+1+k,cmp);
	j=n-1;
	for(R int i=1; i<=k; i++)
	{
		ans+=a[i]*j;
		j-=2;
		if(j<=0)
		{
			break;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：partychicken (赞：5)

## 来一发简洁的代码

众所周知，代码冗长会导致调试困难。因此，对自己的代码进行简化是一个很好的习惯。为此，本蒟蒻写了一份比其他题解简短的代码~~，以方便调试~~

```
#include<bits/stdc++.h>
int main()
{
	int n,k,val[310],posl=1,posr=n,tmp,ans=0;
	std::cin>>n>>k;
	for(int i=1;i<=k;i++) std::cin>>val[i];
	std::sort(val+1,val+k+1);
	for(int i=k;i>=1;i--) ~tmp?posr>posl?(ans+=val[i]*(posr-- - posl++)):tmp=-1:1;
	std::cout<<ans<<std::endl;
} 
```

10行搞定！

**特别鸣谢** @Xeonacid @WindowsXP 提供技术指导

---

## 作者：TheAutumnGlory (赞：2)

根据题目，我一想要使**总价值最大**，且**第一次价值为0**，应该是个贪心，所以我猜测要使**总价值最大**：

1. 要使每次特技都飞两次 ~~（不然价值为0）~~

2. 对于贡献价值大的特技尽量两次飞行的时间尽可能长。（就是尽可能第一次靠左，第二次靠右）

**设区间[l,r]对于第i个特技的价值为=$(r-l)*c[i]$**

那么我们如何让贡献价值大的特技尽量两次飞行的时间长呢？？

**只需要将价值排个序**

## code：
```
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[305],ans;
bool cmp(int a,int b){return a>b;}将价值从大到小排序
int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=k;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+1+k,cmp);
	int r=n,l=1;
   r,l暴力模拟区间[l,r]，也就是对于当前特技是最终最大的贡献价值
	for(int i=1;i<=k && l<=r;i++){
		ans+=(r-l)*a[i];
		r--,l++;区间减小
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：zijinjun (赞：2)

不得不说,这个国家集训队的名字配上这个难度,顿时好感人啊啊啊

其实这道题就是一个简单的贪心,设计方案使得最后一次进行的时间-首次进行的时间最大

所以就是要让c大的动作相隔时间最长，尽可能地安排在两端，即可最大

所以一个sort就可以解决了
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#define FOR(i,n,m) for(int i=n;i<=m;++i)
#define FR(i,n,m) for(int i=n;i>=m;--i)
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define re register
#define gc getchar()
using namespace std;
const int N=100010;
inline int read() {
	re int x(0),f(1);
	re char ch=gc;
	while(ch<'0'||ch>'9') {
		if(ch=='-') f=-1;
		ch=gc;
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<1)+(x<<3)+(ch^48);
		ch=gc;
	}
	retunr x*f;
}
//上面都没什么用QAQ

int a[N],k,n,ans=0;

void work() {
	n=read(),k=read();
	FOR(i,1,k) a[i]=read();
	sort(a+1,a+1+k);	//贪心排个序
	int i;
    for (i=k,n--;i>=1&&n>0;i--,n-=2) 
    	ans+=n*a[i];	//全部加上即可
    printf("%d",ans);
}

int main() {
	
	work();
	
	return 0;
}
```

---

## 作者：like1 (赞：2)

这大概是国家集训队最水的题目了

首先看题就知道是一个贪心；

那么怎么贪呢

一眼就可以看出刺激程度越大的动作相隔越远越优，其次我们不难再发现一个结论，就是一个动作只做两次才有价值，这个结论很好证明，（假设一个动作的价值为5，第1秒和第10秒做，那么价值为5*（10-9）=45， 如果第1、5、10秒做，那么价值为5*（5-1）+5*（10-5）=45）

那么既然要产生最大价值,我们就安排ci​大的动作两次被做的时间尽量拉开，于是对ci​从大到小进行排序，最大的安排在第1和第N个单位时间做,接下来是第2和第N-1,以此类推。当然在程序中,只需安排前N/2个活动就可以算出结果了。当N是奇数时,最中间(N/2+1)的时间点随便安排什么动作都可以

```
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;


const int N=1001;
int a[N];
int n,m,ans=0;

int main( )
{
	scanf("%d%d",&n,&m);
	int l=1,r=n;
	for(int i=1;i<=m;i++)
	scanf("%d",&a[i]);
	sort(a+1,a+1+m);
	for(int i=m;i>0;i--)
	{
		ans+=(r-l)*a[i];
		r--;
		l++;
		if(l>=r) break; 
	}
	printf("%d",ans);
}
```
最后祝大家CSP2019rp++,score++；

---

## 作者：aiyougege (赞：2)

#### Solution
　　发现**相同的一对动作之间**如果再加入一个相同的动作, 总价值会变低, 所以要保证两个相同的动作之间的时间差尽量大, 所以就要**将价值大的一对间隔尽量大**,**也就是放到时间的两端**,  所有动作全部放过一遍后或者全部放满之后就不用再放了.
#### Code
```c++
#include<algorithm>
#include<iostream>
#include<cstdio>
#define N 355
using std::sort;
 
int n,k;
int val[N];
 
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;++i)scanf("%d",&val[i]);
    sort(val+1,val+k+1);
    int l=1,r=n,ans=0;
    for(int i=k;i>0;--i){
        ans+=(r-l)*val[i];
        --r,++l;
        if(l>=r)break;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：_vercont (赞：1)

### P3918 特技飞行
### 算法：贪心
```
#pragma GCC optimize(3)//玄学优化  
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
	int n,k;
	scanf("%d%d",&n,&k);
	int c[k+5],d[k+5];
	long long int ans=0;
	for(int i=0;i<k;i++)scanf("%d",&c[i]);//输入价值  
	sort(c,c+k);//排序  
	int l=0,r=n;//左右位置  
	for(int i=k-1;i>=0;i--){
		d[l]=d[r]=c[i];//把当前最大的价值放在数组两端  
		ans=ans+c[i]*(r-l-1);//答案修改 
		++l;--r;//左右位置向里移 
		if(l>=r)break;//两个位置重合  
	}
	printf("%lld",ans);//输出 
	return 0;//结束 
}
```

---

## 作者：qr的小迷妹 (赞：0)

一开始我只看出了sum+=（t2[i]-t1[i]）* c[i]

然后就开始想要怎么安排得到sum的最大值
（= =）

后来听说两头安排就可以，但是没人解释为什么，然所以……还是不知道为什么（太傻）

其实只要简单证明就可以（多推几种情况）


就比如说a>b>c时


有abcabc和abccba

s1=a* 5+b* 3+c* 1;s2=（a+b+c）* 3;
s1>s2


其余类似。。

然后觉得之前好傻

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,i,j,n,k,c[309];
bool cmp(int a,int b)
{
    return a<b;
}
int main()
{
    cin>>n>>k;
    for (i=1;i<=k;i++)
     cin>>c[i];
    sort(c+1,c+1+k,cmp);
    i=n-1;j=k;
    while (1)
    {
        if (i<=0||j<=0)break;
        ans+=i*c[j];
        j--;i-=2;
    }
    cout<<ans;
}
```


---

## 作者：XiXi (赞：0)

### 思路分析
如果我们用$p[i][j]$表示第$i$种特技第$j$次出现的位置，$q[i]$表示出现的次数，那么第$i$个特技的贡献就是$\sum_{j=2}^{q[i]}C[i]\times (p[i][j]-p[i][j-1])$

化简后就是$C[i]\times (p[i][q[i]]-p[i][1])\ ,\ $也就是$C[i]\times($最后出现时间$-$最早出现时间$)$

根据贪心，我们让$C[i]$越大的动作相隔时间越长，也就是更靠近两端

### 代码解析
```cpp
#include<bits/stdc++.h> 
#define mn 1111111
using namespace std;
int n,k,i=1,s,a[mn];
int main()
{
	for (scanf("%d%d",&n,&k);i<=k;i++) scanf("%d",a+i); sort(a+1,a+1+k);
	for (i=k,n--;i>=1&&n>0;i--,n-=2) s+=n*a[i]; printf("%d",s);
}
```

---


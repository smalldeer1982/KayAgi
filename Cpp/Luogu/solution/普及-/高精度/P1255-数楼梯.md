# 数楼梯

## 题目描述

楼梯有 $N$ 阶，上楼可以一步上一阶，也可以一步上二阶。

编一个程序，计算共有多少种不同的走法。

## 说明/提示

- 对于 $60\%$ 的数据，$N \leq 50$；   
- 对于 $100\%$ 的数据，$1 \le N \leq 5000$。


## 样例 #1

### 输入

```
4```

### 输出

```
5```

# 题解

## 作者：AzureGlacier (赞：608)

#CORE:高精加+斐波那契数列

- 但是看了前面的题解感觉都比较麻烦，其实用一个二维数组就可以解决了www

- 思路大概是用数组**f[k][j]**来存储走k个阶梯所用的步数 最后循环输出


代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
int n,len=1,f[5003][5003];//f[k][i]--第k阶台阶所对应的走法数 
void hp(int k)//高精度加法，k来存阶数 
{    
    int i;
    for(i=1;i<=len;i++)
     f[k][i]=f[k-1][i]+f[k-2][i];//套用公式 
    for(i=1;i<=len;i++)             //进位 
     if(f[k][i]>=10)
     {
         f[k][i+1]+=f[k][i]/10;
         f[k][i]=f[k][i]%10;
         if(f[k][len+1])len++;
    }
}
int main()
{
    int i;
    scanf("%d",&n);
    f[1][1]=1; f[2][1]=2;         //初始化 
    for(i=3;i<=n;i++)              //从3开始避免越界 
     hp(i);                         
    for(i=len;i>=1;i--)             //逆序输出 
     printf("%d",f[n][i]);
    return 0;
}
```

---

## 作者：sumijie (赞：497)

矩阵快速幂+压位高精，我的FFT模板不见了，所以用的${n^2}$暴力乘法，所以跑了30ms。

（FFT模板不见了，所以只能跑跑130000的~~水数据~~了大的数据就爆空间RE了，FFT就不需要这么多空间= = 逃

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>

typedef long long ll;

using namespace std;

const ll W = 100000000;

const ll s = 8;

const ll WS[8] = {10000000,1000000,100000,10000,1000,100,10,1};

struct BigInt {
    bool flag;
    int size;
    ll values[220];
    
    BigInt() {
        this->clear();
    }
    
    void clear() {
        memset(values,0,sizeof values);
        this->size = 1;
        this->flag = true;
    }
    
    void operator =(int x) {
        this->clear();
        if (x == 0)
            return;
        ll cnt = 0;
        if (x<0)
            x = -x,this->flag = false;
        while (x) {
            this->values[cnt] = x%W;
            x /= W;
            cnt++;
        }
        this->size = cnt;
    }
    
    void operator =(char* x) {
        this->clear();
        ll start = 0;
        ll len = strlen(x);
        if (len>=1&&x[0]=='-')
            this->flag = false,start++;
        ll size = (len-start)%s?(len-start)/s+1:(len-start)/s;
        this->size = size;
        ll cnt = 0;
        for (ll i = 0;i<this->size;i++){
            for (ll j = s-1;j>=0;j--)		
                this->values[cnt] = this->values[cnt]*10 + (len-i*s-j-1>=start&&x[len-i*s-j-1]?x[len-i*s-j-1]-'0':0);
            cnt++;
        }
    }
    
    void operator =(BigInt x) {
        this->clear();
        this->size = x.size;
        this->flag = x.flag;
        for (int i = 0;i<this->size;i++)
            this->values[i] = x.values[i];
    }
    
    BigInt operator +(BigInt x) const {
        if (this->flag&&x.flag){
            BigInt y = *this;
            add(y,x);
            return y;
        }
        else if (this->flag) {
            x.flag = true;
            BigInt y = *this;
            subtract(y,x);
        	return y;
        }
        else if (x.flag) {
            BigInt a = *this;
            a.flag = true;
            subtract(a,x);
            a.flag = false;
            return a;
        }
        else {
            BigInt a = *this;
            a.flag = true;
            x.flag = true;
            add(a,x);
            a.flag = false;
            return a;
        }
    }
    
    BigInt operator *(BigInt x) const {
        bool flag = this->flag == x.flag;
        BigInt y;
        y = *this;
        multiply(y,x);
        y.flag = flag;
        return y;
    }
    
    BigInt operator *(ll x) const {
        BigInt i;
        i = x;
        return this->operator *(i);
    }
    
    BigInt operator /(BigInt x) const {
        bool flag = this->flag == x.flag;
        BigInt y;
        y = *this;
        divide(y,x);
        y.flag = flag;
        return y;
    }
    
    BigInt operator /(ll x) const {
        BigInt i;
        i = x;
        return this->operator /(i);
    }
    
    void operator /=(BigInt x) {
        bool flag = this->flag == x.flag;
        divide(*this,x);
        this->flag = flag;
    }
    
    void operator /=(ll x) {
        BigInt i;
        i = x;
        this->operator /=(i);
    }
    
    BigInt operator %(BigInt x) {
        bool flag = this->flag == x.flag;
        BigInt y = *this;
        mod(y,x);
        y.flag = flag;
        return y;
    }
    
    BigInt operator %(ll x) {
        BigInt i;
        i = x;
        this->operator %(i);
    }
    
    void operator *=(BigInt x) {
        bool flag = this->flag == x.flag;
        multiply(*this,x);
        this->flag = flag;
    }
    
    void operator *=(ll x) {
        BigInt i;
        i = x;
        this->operator *=(i);
    }
    
    BigInt operator -(BigInt x) const {
        x.flag ^= 1;
        return this->operator +(x);
    } 
    
    BigInt operator -() const {
        BigInt x = *this;
        x.flag ^= 1;
        return x;
    }
    
    BigInt operator +(ll x) const {
        BigInt i;
        i = x;
        return *this+i;
    }
    
    BigInt operator -(ll x) const {
        BigInt i;
        i = x;
        return *this-i;
    }
    
    void operator +=(BigInt x) {
    	if (this->flag&&x.flag)
            add(*this,x);
        else if (this->flag) {
            x.flag = true;
            subtract(*this,x);
        }
        else if (x.flag) {
            this->flag = true;
            subtract(*this,x);
            this->flag = false;
        }
        else {
            this->flag = true;
            x.flag = true;
            add(*this,x);
            this->flag = false;
        }
    }
    
    void operator +=(ll x) {
        BigInt i;
        i = x;
        return this->operator +=(i);
    }
    
    void operator -=(ll x) {
        BigInt i;
        i = x;
        return this->operator -=(i); 
    }
    
    void operator -=(BigInt x) {
        x.flag ^= 1; 
        this->operator +=(x);
    }
    
    BigInt operator ++() {
    	this->operator +=(1);
        return *this;
    }
    
    BigInt operator --() {
        this->operator +=(-1);
        return *this;
    }
    
    char* charValue() const {
        ll maxcnt = 0;
        ll start = 0;
        if(!this->flag)
            start++;
        char* t = new char[this->size*s+1+start];
        if (!this->flag)
            t[0] = '-';
        for (ll i = 0;i<this->size;i++){ 
            for (ll j = s-1;j>=0;j--){
                t[i*s+s-1-j+start] = (this->values[i]/WS[j])%10+'0';
                if (t[i*s+s-1-j+start]!='0')
                    maxcnt = i*s+s-1-j+start;
            } 
        } 
        t[maxcnt+1] = 0;
        reverse(t+start,t+maxcnt+1);
        return t;
    }
    
    operator char*() const {
        return charValue();
    }
    
    bool operator==(BigInt x) const {
        if (this->size != x.size)
            return false;
        if (this->size == 1&&this->values[0]==x.values[0]&&this->values[0] == 0)
        	return true; 
        if (this->flag != x.flag)
            return false;
        for (ll i = 0;i<this->size;i++)
            if (this->values[i]!=x.values[i])
                return false;
        return true;
    }
    
    bool operator==(int x) const {
        BigInt y;
        y = x;
        return *this == y;
    }
    
    bool operator !=(BigInt x) const {
        if (*this == x)
            return false;
        return true;
    }
    
    bool operator <(BigInt x) const {
        if (this->size > x.size)
            return false;
        else if (this->size < x.size)
            return true;
        if ((ll)this->flag > (ll)x.flag)
            return false;
        for (ll i = this->size-1;i>=0;i--){
            if (this->values[i]<x.values[i]){
                if (this->flag)
                    return true;
                else return false;
            } 
            else if (this->values[i]>x.values[i]){
                if (this->flag)
                    return false;
                else return true;           	
            }
        }
        return false;
    }
    
    bool operator >(BigInt x) const {
        if (*this<x)
            return false;
        if (*this == x)
            return false;
        return true;
    }
    
    bool operator <=(BigInt x) const {
        if (*this>x)
            return false;
        return true;
    }
    
    bool operator >=(BigInt x) const {
        if (*this<x)
            return false;
        return true;
    }

    bool operator !() const {
        if (this->size != 1)
            return true;
        if (this->values[0] != 0)
            return true;
        return false;
    }
    
    void println() {
        print(*this);
        print("\n");
    }
    
    static void add(BigInt&a,BigInt b) {
        ll cnt = max(a.size,b.size) + 1;
        for (ll i = 0;i<cnt;i++) {
            ll t = a.values[i] + b.values[i];
            if (t>=W)
                a.values[i] = t - W,a.values[i+1]++;
            else
                a.values[i] = t;
        }
        if (a.values[cnt-1])
        	a.size = cnt;
        else
        	a.size = cnt - 1;
    }
    
    static void subtract(BigInt&a,BigInt b) {
        if (a == b){ 
            a = 0;
        	return; 
        }
        if (a<b)
            swap(a,b),a.flag = false;
        ll maxcnt = 0;
        ll cnt = max(a.size,b.size);
        bool flag = false;
        for (ll i = 0;i<cnt;i++) {
            ll t = a.values[i]-b.values[i];
            if (flag)
                t--,flag = false;
            if (t<0)
                flag = true,a.values[i] = t + W;
            else
                a.values[i] = t;
            if (a.values[i])
                maxcnt = i;
        }
        a.size = maxcnt+1;
    }
    
    static void multiply(BigInt&a,BigInt b) {
    	if (a==1){ 
    		a = b;
    		return; 
        } 
        if (a==0||b==0) {
            a = 0;
            return;
        }
        if (b==1) {
            return;
        }
        ll size = a.size + b.size;
        ll* ts = new ll[size];
        for (ll i = 0;i<size;i++)
            ts[i] = 0;
        for (ll i = 0;i<a.size;i++)
            for (ll j = 0;j<b.size;j++) {
                ll t = a.values[i]*b.values[j];
                if (t>=W)
                    ts[i+j] += t%W,ts[i+j+1] += t/W;
                else 
                    ts[i+j] += t;
            } 
        for (ll i = 0;i<size;i++) {
            if (ts[i]>=W)
                ts[i+1]+=ts[i]/W,ts[i]%=W;
            a.values[i] = ts[i];
        }
        if (ts[size-1])
            a.size = size;
        else a.size = size-1;
    }
    
    static void divide(BigInt&a,BigInt b) {
        if (a<b) {
            a = 0;
            return;
        }
        if (a==b) {
            a = 1;
            return;
        }
        if (b == 0) {
            a = 0;
            return;
        }
        if (b==1)
            return;
        if (b==2) {
            divide2(a);
            return;
        }
        BigInt left,right;
        left = pow10_(max(0,a.size - b.size-1)),right = pow10_(a.size - b.size+1);
        while (left<=right) {
            BigInt mid;
            mid = left + right;
            divide2(mid);
            BigInt o = mid*b;
            BigInt o2 = o + b;
            if (o<=a&&o2>a) {
                a = mid;
                return;
            }
            else if (o2<=a) 
                left = mid + 1;
            else 
                right = mid - 1;
        }
    }
    
    static void divide2(BigInt&a) {
        for (ll i = 0;i<a.size;i++) {
            ll t = a.values[i];
            if (t%2==0||i==0)
                a.values[i] /=2;
            else 
                a.values[i] /=2,a.values[i-1] += W/2;
        }
        if (!a.values[a.size-1])
            a.size--;
    }
    
    static BigInt pow10_(int x) {
        BigInt y;
        if (x == 0) {
            y = 1;
            return y;
        }
        y.size = x;
        y.values[x-1] = WS[0];
        return y;
    }
    
    static BigInt pow10(ll x) {
        ll size = (x+1)%s == 0?(x+1)/s:(x+1)/s+1;
        BigInt y;
        y.size = size;
        if ((x+1)%s) {
            y.values[(x+1)/s] = WS[s-(x+1)%s];
        }
        else 
            y.values[(x+1)/s-1] = WS[0];
        return y;
    }
    
    static void mod(BigInt&a,BigInt b) {
        BigInt x = a;
        divide(x,b);
        a -= b*x;
    }
    
    static void print(BigInt x) {
        if (!x.flag)
            cout<<"-";
        cout<<x.values[x.size-1];
        for (ll i = x.size-2;i>=0;i--) 
            print(x.values[i],s);
    }
    
    static void print(char* x) {
        cout<<x;
    }
    
    static void print(ll x,ll d) {
        for (ll i = 0;i<d;i++)
            cout<<(x/WS[i])%10;
    }
    
    static void swap(BigInt&a,BigInt&b) {
        BigInt x = a;
        a = b;
        b = x;
    }
};

struct Matrix {
	BigInt values[2][2];
	
	ll size;
	Matrix(ll size) {
		this->size = size;
	}
	
	Matrix operator *(Matrix other) {
		Matrix ans(this->size);
		for (ll i = 0;i<this->size;i++)
			for (ll j = 0;j<this->size;j++)
				for (ll k = 0;k<this->size;k++)
					ans.values[i][k] += this->values[i][j]*other.values[j][k];
		return ans;
	}
	
	Matrix operator ^(ll b) {
		Matrix ans(this->size);
		Matrix base = *this;
		for (ll i = 0;i<this->size;i++)
			ans.values[i][i] = 1;
		while(b) {
			if (1&b)
				ans = ans*base;
			base = base*base;
			b>>=1;
		}
		return ans;
	}
	
	void init(ll values[2][2]) {
		for (ll i = 0;i<this->size;i++)
			for (ll j = 0;j<this->size;j++)
				this->values[i][j] = values[i][j];
	}
}; 

int main() {
	ll n;
	cin>>n;
	if (n == 0){
		cout<<0<<endl;
		return 0;
	}
	Matrix base(2);
	ll t[2][2] = {0,1,1,1};
	ll t2[2][2] = {1,2,0,0};
	base.init(t);
	Matrix ans(2);
	ans.init(t2);
	Matrix other = ans*(base^(n-1));
	cout<<other.values[0][0]<<endl;
} 
```

---

## 作者：Ajwallet (赞：113)

走楼梯，要么一次走一格，要么一次走两格，那我每次的走法就等于=上一格的方案数+上上格的方案数咯，这就推出了方程：

$$f[i]=f[i-1]+f[i-2]$$
-

因为此方程只用到了i，i-1，i-2，所以可以滚动压缩，得到

$$f[i\mod3]=f[(i+1)\mod3]+f[(i+2)\mod3]$$
-

然后用了一下各种类型
>int 40分

>long long 50分

>unsigned long long 50分。。。

>__int128 0分，编译错误了。。。

然后，就打了高精度。。。

想想，普通的高精度，我们伟大的管理怎么可能会给通过呢？于是，我打了个压位高精加。。。

# 概念
压位高精加，顾名思义，就是将高精度数组的每个位存多点。

# 优点
因为高精度其实是模拟竖式计算的方法，一个变量存一位，也就是0..9，这样有点浪费时间，而当n，m太大时则会超时，这个时候，就引申除了压位高精加。

# 实现
对高精度略作修改，将原来的%10、/10，改成了%100000000，/100000000，但是输出的时候要记得处理前面的0，例如
9999999999999999+2=10000000000000001

在数组里面它是这样的

101

所以，要判断当它不是第一个数字的时候，要添加0，至于添加几个，则看它有多大。判断可以直接暴力，也可以数学方法（log）去算，从而添加0

例如

1=7个0+1 10=6个0+1,100=5个0+1……以此类推
# 代码
```cpp
#include<bits/stdc++.h>
#define N 250//2000位够了，250*8
using namespace std;
int  f[3][N+10],g;
int n;
int main()
{
	f[0][N]=1;f[1][N]=1;scanf("%d",&n);if(!n){puts("0");return 0;}//0要特判
	for(int i=2;i<=n;i++)
	 for(int j=N;j>0;j--)
	  {
	 	f[i%3][j]=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)%100000000;
	    g=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)/100000000;//8个0，别漏了
	  }
	int j=1;
	while(!f[n%3][j]&&j<N) j++;//处理前导0
	for(int i=j;i<=N;i++)
	{
		if(i!=j){//一定别漏了前面这句
		if(f[n%3][i]<1e7) putchar(48);
		if(f[n%3][i]<1e6) putchar(48);
		if(f[n%3][i]<1e5) putchar(48);
		if(f[n%3][i]<1e4) putchar(48);
		if(f[n%3][i]<1e3) putchar(48);
		if(f[n%3][i]<1e2) putchar(48);
		if(f[n%3][i]<1e1) putchar(48);}//补足前导0
		printf("%d",f[n%3][i]);//输出
	}
}
```

---

## 作者：EndSaH (赞：110)

AC代码：
```cpp
int main(void)
{
	int x;cin>>x;
	Int a[x+1];
    a[0]=0;a[1]=1;
	for(int i=2;i<=x+1;++i) a[i]=a[i-1]+a[i-2];
	if(x==0) cout<<0;//特判 不然90
    else cout<<a[x+1];
	return 0;
}
```

？？？？？？？？？？？？？？？？？？

你（也许）：你在梦游吧？？？这怎么AC的？？？高精标签被你吃了？？
## 然而 你看见了Int吗？
(其实那只是部分的AC代码 头文件都没打2333333)

这道题只写普通高精怎么会过管理大大的审核呢

所以我抖了个机灵 选择了重载运算符

边上代码边解释吧
```cpp
#include<bits/stdc++.h>
#define MAXN 5010//高精的位数
using namespace std;
struct Int
{
	int len,s[MAXN];
    //用数组s倒序存储 len表示长度
    //萌新不会压位...
	Int(){len=1;memset(s,0,sizeof(s));}
	Int(int num){*this=num;}
    /*结构体里面有一个Int()的函数，它称为
    “构造函数（Constructor）”。构造函数是
    C++中特有的，作用就是进行初始化。
    每当我们定义一个 Int 类型的变量时，
    这个变量就会被初始化。例如定义 Int x 时，我们将会
    得 x.len==1,x.s中的所有元素均为0。
    书上原话，不明觉厉233
    但是没有这2行就会编译错误倒是真的
    有dalao来解释一下么- -*/
//对了 const跟&连用是有好处的 虽然我不知道233 有dalao解释么- -
Int operator=(const int &num)//开始重载等号,用来赋值
{
	char a[MAXN];
    sprintf(a,"%d",num);//将整数转成Int型
	len=strlen(a);for(int i=len-1;i>=0;--i)
    s[i]=a[len-i-1]-'0';
	return *this;
}
Int operator+(const Int &a)//原理与高精加法一样
{
	Int c;
	c.len=max(len,a.len)+1;
	for(int i=0,x=0;i<c.len;++i)
	{
		c.s[i]=s[i]+a.s[i]+x;
		x=c.s[i]/10;
		c.s[i]=c.s[i]%10;
	}
	if(c.s[c.len-1]==0) --c.len;
	return c;
};
ostream& operator<<(ostream &out,const Int &x)
//看不懂？没事我也看不懂...反正是跟输出流有关
{
	for(int i=x.len-1;i>=0;--i) cout<<x.s[i];
	return out; 
}
//记得要把这个放在结构体外面
```
本片题解到此结束- -

# 祝各位早日成为神牛牪犇！

---

## 作者：Arcturus1350 (赞：86)

好吧，承认python 轻松水过

代码奉上：

```python
n = int(input())
#定义，输入
a=1
#初始的变量赋值
b=1
n-=1
#我的毒瘤的循环不得不加上这句话
if n > 0 :
#判断，第6,7很坑的
    while n>0 :
        c=a+b
        a=b
        b=c
        n-=1
    print(b)
elif n == 0 :
#判断边界
        print(a)
else :
    a-=1
    #判断边界
    print(a)
    #程序拜拜
```

---

## 作者：lijiahao2017 (赞：83)

# P1255 【数楼梯】



### 题目描述

楼梯有$N$阶，上楼可以一步上一阶，也可以一步上二阶。

编一个程序，计算共有多少种不同的走法。

### 输入输出格式

##### 输入格式：
一个数字，楼梯数。

##### 输出格式：
走的方式几种。

### 输入输出样例

##### 输入样例#1： 复制
4
##### 输出样例#1： 复制
5
### 说明

用递归会太慢，需用递推

（$60$% $N<=50$ ,$100$% $N<=5000$)





又可以和大家见面了。

这道题小菜鸡大约用了半个小时($30$分钟)。

唉，真是不能和大神($dalao$)比呀!

正所谓      鸡蛋撞石头————不自量力。

我先用了个     递推，而且还是$int$，写了个骗分。

$30$分($30$%)

```

#include<cstdio>
int a,b,c,n;
int main()
{
    a=1,b=2;
    scanf("%d",&n);
    for(int i=3;i<=n;i++)c=a+b,a=b,b=c;
    printf("%d",b);
    return 0;
}

```

后来把$int$改成$long long$。

$40$分($40$分)

```

#include<cstdio>
long long a,b,c,n;
int main()
{
    a=1,b=2;
    scanf("%lld",&n);
    for(long long i=3;i<=n;i++)c=a+b,a=b,b=c;
    printf("%lld",b);
    return 0;
}

```

骗分结束，开始正式讲$AC$思路。



## 思路放送:

### $1$.将高精和递推结合。

### $2$.注意数组最好开道$5010$。

### $3$.$3$以下要单独处理。

### $4$.高精要逆序输出。



##### 下面$AC$代码细将：

```

#include<cstdio>//调用 scanf和printf 库
#include<cstring>//调用 memset 库
int n,ns=1; 
int a[5010],b[5010],c[5010];
//定义
//注意数组大小
void Fibonacci()
//开始
{
    a[1]=1,b[1]=2;//注意初始化
    for(int i=3;i<=n;i++)//从第3个循环
    {
        for(int j=1;j<=ns;j++)c[j]=a[j]+b[j];//相加
        for(int j=1;j<=ns;j++)//进位
        {
            if(c[j]>9)//大于9才进
            {
                c[j+1]+=c[j]/10;
                c[j]%=10;
                if(j+1>ns)ns++;//小心要多留一位
            }
        }
        for(int j=1;j<=ns;j++)a[j]=b[j];
        for(int j=1;j<=ns;j++)b[j]=c[j];
        //交换
    }
}
int main()
{
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));
    //清 0       优化
    scanf("%d",&n);//输入
    if(n<3)//小于 3 要多加小心----------卡了我两次
    {
        printf("%d",n);
        return 0;
    }
    Fibonacci();
    //高精和递推合并
    for(int i=ns;i>0;i--)printf("%d",b[i]);
    //逆序输出
    return 0;//再见
}

```

---

## 作者：智子·起源 (赞：54)

# 递推+高精+“感人”的细节

### 递推很简单：

- 由于当前阶梯可以有前一个或者前两个阶梯到达，所以当前阶梯方案数

    **a[i]=a[i-1]+a[i-2]**

- 然后还要知道

    **a[1]=1,a[2]=2;**
    
### 高精：

- 思路就是用数组存放数的每一位来实现非常大的数字的运算。

- 但是写法，在这里推荐一种用结构体写的。（请看下面的程序）

### 细节：

- 0的情况包含在内，所以当n是0时要输出0。（坑了我一个数据点）

- 高精最好定成20000位的。

上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
struct data
{int len,s[2000];}a[5000+5];
data jia(data a,data b)
{
  data c;
  for(int i=0;i<2000;i++)c.s[i]=0;
  c.len=max(a.len,b.len);
  for(int i=1;i<=max(a.len,b.len);i++)
    c.s[i+1]=(c.s[i]+a.s[i]+b.s[i])/10,c.s[i]=(c.s[i]+a.s[i]+b.s[i])%10;
  if(c.s[c.len+1]>0)c.len++;
  return c;
}
int main()
{
  a[1].len=a[2].len=1;
  a[1].s[1]=1;a[2].s[1]=2;
  scanf("%d",&n);
  if(n==0){printf("0");return 0;}
  for(int i=3;i<=n;i++)a[i]=jia(a[i-1],a[i-2]);
  for(int i=a[n].len;i>0;i--)cout<<a[n].s[i];
  return 0;
}
```

### 看在这是多方面的综合优秀题解，请管理员过一下，谢谢！^_^

---

## 作者：plazum (赞：42)

用两个数组反复加来加去，既省空间又省时间……

```cpp

#include<stdio.h>
int a[2][1046],i,j,n,p;
int main()
{
    scanf("%d",&n);
    if(n<=1){putchar(n+'0');goto end;}
    **a=1;
    *a[1]=1;
    for(i=2;i<=n;i++){
        p=1-p;
        for(j=0;j<1045;j++)
            a[p][j+1]+=(a[p][j]+a[1-p][j])/10,a[p][j]=(a[p][j]+a[1-p][j])%10;
    }
    for(i=1044;!a[p][i];i--);
    for(;i>=0;putchar(a[p][i--]+'0'));
    end:
    
    return 0;
}

```

---

## 作者：AkiwaZawa (赞：36)

# 高精度加法+斐波纳契

相信大部分朋友都可以看出来这是斐波那契数组，既然斐波那契已经再熟悉不过，那么棘手的就是高精度的问题。

高精度看起来很烦很麻烦，其实很简单。

    1.既然太大的数字没有办法直接相加减，那么我们来模拟竖式的算法，逐位相加，满十进一。
    2.好了，那我们用 a，b 两个数组 来存两个加数，用 c 来存答案。
    3.那么就有以下等式 c[i]=a[i]+b[i]，同时我们再判断，如果c[i]>9，那就向高一位进一即可。
    4.用x来就答案的长度，最后输出即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5000],b[5000],c[5000];
int main()
{
    int n;
    int x=1;
 	cin>>n;
    if(n<3)
    {
        cout<<n;
        return 0;
    }
    a[1]=1;b[1]=2;
 	for(int i=3;i<=n;i++)
    {
        for(int j=1;j<=x;j++)
            c[j]=a[j]+b[j];
        for(int j=1;j<=x;j++)
        {
            if(c[j]>9)
            {
                c[j+1]=c[j+1]+c[j]/10;
                c[j]%=10;
                if(j+1>x)
                    x++;
            }
        }
        for(int j=1;j<=x;j++)
            a[j]=b[j];
        for(int j=1;j<=x;j++)
            b[j]=c[j];
    }
 	for(int i=x;i>0;i--)
        cout<<b[i];
    return 0;
}
```


---

## 作者：灬Amiya灬 (赞：27)

java自带大数运算，百度一下就有
所以用java很轻松就过了
最后推荐大家先试着写一下非API大数运算，再学调用API做
因为原理是相通的，都是用字符串来做

```java
import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		Scanner in = new Scanner(System.in);
		BigInteger b1 = new BigInteger("1");
		BigInteger b2 = new BigInteger("1");
		BigInteger b3 = new BigInteger("2");
		int N = in.nextInt();
		if(N<1) System.out.println(0);
		else if(N<3)System.out.println(1);
		else {
			for(int i=1;i<N;i++) {
				b3 = b1.add(b2);
				b1 = b2;
				b2 = b3;
			}
			System.out.println(b3);
		}
	}

}

```

---

## 作者：_Andy_Lin_ (赞：8)

[博客传送门](https://www.luogu.com.cn/blog/linguosheng/)

------------
最开始，我看到此题时，发现我在BZOJ做过一样的题，于是将代码交了上去。[结果](https://www.luogu.com.cn/record/27627134)

------------
我仔细看了看，发现BZOJ的是1,1,2,3,5……而这个题是1,2,3,5……我改了代码。又交了一次。[结果](https://www.luogu.com.cn/record/28678364)

------------
我下载测试数据一看——竟然有0级楼梯！！！于是改动了一下。[结果](https://www.luogu.com.cn/record/28678404)

------------
AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100000],b[100000],c[100000];
string s[10000];
bool flag[10000];
string jia(string s1,string s2){
	int lena=s1.length(),lenb=s2.length(),lenc=1,x=0;
	string s3;
	for(int i=0;i<lena;i++)
	{
		a[lena-i]=s1[i]-'0';
	}
	for(int i=0;i<lenb;i++)
	{
		b[lenb-i]=s2[i]-'0';
	}
	for(;lenc<=max(lena,lenb);lenc++){
		c[lenc]=a[lenc]+b[lenc]+x;
		x=c[lenc]/10;
		c[lenc]%=10;
	}
	c[lenc]=x;
	while(c[lenc]==0&&lenc>1)lenc--;
	for(int i=0;i<lenc;i++)
	s3+=(char)(c[lenc-i]+'0');
	return s3;
}
string fbnq(int number){
	if(number==0)return "0";
	if(number==1)return "1";
	if(number==2)return "2";
	if(!flag[number])
	{
		flag[number]=true;
		string s1=fbnq(number-1),s2=fbnq(number-2);
		s[number]=jia(s1,s2);
	}
	return s[number];
}
int main()
{
	memset(flag,false,sizeof(flag));
	cin>>n;
	cout<<fbnq(n);
	return 0;
}
```
一定要设定0的边界！！！不然就会RE
------------

---

## 作者：Stella_Yan (赞：8)

py轻松水过

这里的递推用了数组,而不是楼下的三个变量

递推方程：$f[i]=f[i-1]+f[i-2]$

贴代码:

---

```python
n=int(input())#输入n
f=[0 for i in range(0,n+10,1)]#用循环定义一个从1~n+10的数组,多定义一点是为了保险(有过RE的经历)
f[0]=1
f[1]=1
if n==0:  #有坑!!!不加判断的话n=0会输出1!!
    print(0)
else:
    for i in range(2,n+1,1):#从2开始到小于n+1,千万别写成n
        f[i]=f[i-1]+f[i-2]#递推式
    print(f[n])#输出
```

---

~~py的int型到底是多大啊...~~

---

## 作者：醉梦未苏 (赞：5)

用c++打了第一遍发现要用高精？！

于是~~懒得打~~就用了python

奉上python 3代码

```python
#开数组，更简单
farr =[]
import sys
#输入
n=int(input())
#注意到如果没有台阶就输出0，在这里WA了一次
if n==0:
    print (0)
    sys.exit()
#经典的肥波纳妾数列过程
for i in range(n+1):
    if i ==0 or i ==1:
        farr.append(1)
    else:
        farr.append(farr[i-2]+farr[i-1])
#数列最后一项即为答案
print(farr[n])
#结束

```



---

## 作者：似水年华 (赞：5)

##题目分析

**当n＝0时**，已经用不着数了，x0＝0

**当n＝1时**，只能是一种数法，数法总数为x1＝1

**当n＝2时**，楼梯可以一次上两阶，也可以上两次，每次上一阶，除此之外再无其它方法

**当n＝3时**，楼梯可以上三次，每次上一阶，也可以认为在这三级台阶中已经先上一阶，还剩两阶需要一次上完（无重复方法），或已经一次上完两阶，则剩下的一阶只能上一次，再无其它上法，因此上法总数表示为x3＝3

**推出一般规律**：对于一般的n，要求xn可以这样来考虑，若第一次上了一阶，剩下有n－1阶需要上，这时上台阶的方法总数是x（n-1）；若第一次上了两阶，剩下有n－2阶需要上，这时上台阶的方法总数是x(n－2)

**所以**xn＝x(n－1)+x(n-2)；

x0＝0；

x1＝1；

x2＝2。

xn＝x(n－1)＋x(n－2)就是问题求解的递推公式，任给n都可以从中获得解答

所以问题的结果就是有名的斐波那契数

##算法

求斐波那契数有两种方法：递推和递归。但是考虑到递推比递归快一些，所以我用得递推

由于数据范围太大，所以不得不用高精

##代码如下

```cpp
#include<stdlib.h>
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<math.h>
#include<cstring>
using namespace std;
int j=3;
char fib[5001][2000];\\用来存放结果
void jia(char a1[],char b1[])\\高精加法（具体怎么加这里就不赘述了）
{
    int a[2000]={0},b[2000]={0},c[2000]={0},lena,lenb,lenc,i,x;
    lena=strlen(a1);
    lenb=strlen(b1);
    for(i=0;i<=lena-1;i++)
        a[lena-i]=a1[i]-48;
    for(i=0;i<=lenb-1;i++)
        b[lenb-i]=b1[i]-48;
    lenc=1;
    x=0;
    while(lenc<=lena || lenc<=lenb)
    {
        c[lenc]=a[lenc]+b[lenc]+x;
        x=c[lenc]/10;
        c[lenc]%=10;
        lenc++;
    }
    c[lenc]=x;
    if(c[lenc]==0)
        lenc--;
    for(i=lenc;i>=1;i--)\\把加得的数存一下，以便递推
        fib[j][lenc-i]=c[i]+'0';
    fib[j][lenc]='\0';
} 
int main()
{
    int n,len,i;
    scanf("%d",&n);\\读入数据
    fib[0][0]='0';\\第0项是0
    fib[1][0]='1';\\第1项是1
    fib[2][0]='2';\\第2项是2
    while(j<=n)\\求其余得项
        {
            jia(fib[j-1],fib[j-2]);\\递推求第n项
            j++;
        }
    printf("%s",fib[n]);\\输出结果
}
```

---

## 作者：ylsoi (赞：5)

这一题似乎每一个人都是定义一个很大的二维数组来做，把每一个答案放在第一个维度例如int f[5001][2000],然而可以不要这样做，如果数据大一点的话，这样是会爆炸的，以下是我的代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int f[3][2000],i,n,len;//第一个维度只要定义大小为3就够了，因为斐波那契数列的递推式就是有三个元素；
void sum()
{
    int i=3;
    while(i<=n)
    {
        memset(f[(i-1)%3],0,sizeof(f[(i-1)%3]));//每一次都要将答案数组先清零
        for(int j=1;j<=len;j++)
        {
            f[(i-1)%3][j]+=f[(i-2)%3][j]+f[i%3][j];//以下是正常的高精度加法
            if(f[(i-1)%3][j]>=10)
            {
                f[(i-1)%3][j+1]++;
                f[(i-1)%3][j]%=10;
            }
        }
        if(f[(i-1)%3][len+1]!=0)//如果最前面的那一位进了位，那么长度就要++；
        len++;        
        i++;//根据循环变量i的自增情况除以3，那么就可以反复调用三个数组，从而实现优化空间复杂度，这也是精髓所在
    }
}
int main()
{
    f[0][1]=1;f[1][1]=2;len=1;
    scanf("%d",&n);
    sum();
    if(n==1)printf("1");//如果是1或2的情况则需要特殊地考虑
    else if(n==2)printf("2");
    else for(int i=len;i>=1;i--)
    printf("%d",f[(n-1)%3][i]);
    return 0;
}
```

---

## 作者：f112358 (赞：5)

利用C的数组存储方式来进行递推

因为&a[i][j]=\*(a+i)

即在a[i][j]中，a[i]可表示第i行第一列的首地址

所以我们可以在数组的行中进行递推，在列中进行高精度计算

则在定义二维数组a[i][j]的情况下，递推式a[i]=a[i-1]+a[i-2]仍然成立

具体实现如下：








```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
int n;
int a[6000][3001];
void P(int a[],int b[],int temp[])
{
    int len1=2000,len2=2000,i;
    while(!a[len1]) len1--; 
    while(!b[len2]) len2--;
    int len=max(len1,len2);
    for(i=1;i<=len;i++) temp[i]=a[i]+b[i];
    for(i=1;i<=len+1;i++)
    {
        temp[i+1]+=temp[i]/10;
        temp[i]%=10;
    }
    return;
}
int main()
{
    cin>>n;
    n++;
    if(n==0)
    {
        cout<<0<<endl;
        return 0;
    }
    a[1][1]=1;
    n++;
    for(int i=2;i<=n+1;i++)
    {
        P(a[i-1],a[i-2],a[i]);
    }
    int len=2000;
    while(!a[n][len]) len--;
    while(len) {cout<<a[n][len];len--;}
    return 0;
}
```

---

## 作者：Aehnuwx (赞：4)

首先，这道题如果把 $n\le 5000$ 变成 $n\le 64$ 就成了大水题了，用个斐波那契数列就行，也不会炸 $\text{long long}$。

但是现在 $n$ 到了 $5000$ 的级别，而斐波那契数列基本上是以指数级增长的。即使是用 $\text{long long}$ 也只能对几乎达到 $2^{5000}$ 的数据而感到无能为力了。

所以我们要写个高精加来解决这个（**看似**）棘手的问题。

我将程序中主要的内容封装到了一个`add`函数里，那么我先把`add`函数放上来，再慢慢分析其内容。

```cpp
void add() {
	a[1] = 1;
	b[1] = 2;
	m = 1;
	for(int i = 3; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) ans[j] = a[j] + b[j];
		for(int j = 1; j <= m; ++j)
			if(ans[j] > 9) {
				ans[j] -= 10;
				++ans[j + 1];
				if(j == m) ++m;
			}
		for(int j = 1; j <= m; ++j) a[j] = b[j], b[j] = ans[j];
	}
}
```

首先，我定义了三个数组，分别是`a[]`，`b[]`和`ans[]`。

大家首先来回忆一下，如果像题解开头所说的那样，$n\le 64$，你会怎么写这道题呢？


------------
很显然地，我们利用加法定理，第 $i$ 层楼梯一定可以从第 $i-1$ 层和第 $i-2$ 层走到（$i>2$），而走到第 $1$ 层和第 $2$ 层楼梯的方案数也显然分别为 $1$ 和 $2$。

所以，我们可以得到一个递推（动态规划？）的做法。设 $\rm{dp}_i$ 为走到第 $i$ 层楼梯的方案数，则在 $i>2$ 的情况下，有公式
$$\rm{dp}_i=\rm{dp}_{i-1}+\rm{dp}_{i-2}$$
边界条件为 $\rm{dp}_1=1,\rm{dp}_2=2$。

但因为 $\rm{dp}_i$ 只和 $\rm{dp}_{i-1}$ 和 $\rm{dp}_{i-2}$ 有关系，所以我们可以利用**滚动数组**来优化空间。

初始时，设 $a=1,b=2$（此时 $a$ 就相当于 $\rm{dp}_1$，$b$ 就相当于 $\rm{dp}_2$），我们再定义一个变量 $ans$，则我们跑 $n-2$ 次循环，在每一次循环中：
$$ans=a+b$$
接着，$a\leftarrow b,b\leftarrow ans$，起到滚动数组的效果（~~虽然根本就没有数组~~）。


------------
好，当你看懂了上面有关滚动数组的内容后，`add`函数中`a[]`，`b[]`和`ans[]`的道理也许你已经懂了。

`a[i]`，`b[i]`和`ans[i]`表示的就是在**倒序**的情况下，原本的 $a$，$b$ 和 $ans$ 的**第 $i$ 位**！

请注意，在**倒序**的情况下，而不是**顺序**！

比如说斐波那契数列中的第 $6$ 个数字：$13$。

放进`a[]`后，`a[1]=3,a[2]=1`。

这样，我们就利用滚动数组，将原来的二维数组变成了一维数组。

接下来的代码解释？

自己摆个加法的竖式，一位一位对齐，然后进位...个人认为理解上并不困难（~~潜台词：咕咕咕~~）。

哦，还有一个**很小的**空间优化的地方。

大家还记不记得题解刚开头讲的一段话？

>但是现在 $n$ 到了 $5000$ 的级别，而斐波那契数列基本上是以指数级增长的。即使是用 $\text{long long}$ 也只能对几乎达到 $2^{5000}$ 的数据而感到无能为力了。

几乎达到 $2^{5000}$，而不是达到 $5000$ 位！

所以，，

$a$，$b$ 和 $ans$ 三个数组根本不用像很多题解里那样开到 $5000$ 位！

$2^8=256$，三位数，$8\div 3>2$；

$2^{10}=1024$，四位数，$10\div 4>2$；

$2^{31}=2147483648$，十位数，$31\div 10>3$。

所以，即使从最保险的角度来看，那三个数组最大也只用开到 $\frac{5000}{2}$ 的级别，也就是 $2500$ 就行了。

最后要注意一点，当 $n<3$ 时，直接输出 $n$，退出程序。~~不要问我为什么，自己看下面的清晰无码的程序。~~

$\rm code$

```cpp
# include <bits/stdc++.h>
using namespace std;
# define EXIT cout << n, exit(0)
const int maxN = 2505;
int n, m;
int a[maxN], b[maxN], ans[maxN];
void add();
int main() {
	cin >> n;
	if(n < 3) EXIT;
	add();
	for(int i = m; i; --i) cout << ans[i];
	return 0;
}
void add() {
	a[1] = 1;
	b[1] = 2;
	m = 1;
	for(int i = 3; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) ans[j] = a[j] + b[j];
		for(int j = 1; j <= m; ++j)
			if(ans[j] > 9) {
				ans[j] -= 10;
				++ans[j + 1];
				if(j == m) ++m;
			}
		for(int j = 1; j <= m; ++j) a[j] = b[j], b[j] = ans[j];
	}
}
```

带上贴的代码，一共打了 $3000+$ 个数的字。完整代码长 $589$ 字节。

码字不易，求管理员通过qaq

---

## 作者：飞翔的金鱼 (赞：4)

这道题的难度还是有的！
其实数楼梯就是广为人知的斐波那契
~~（肥不垃圾）~~
数列：f[i]=f[i-1]+f[i-2];

但是呢，这个题目的数据范围非常惊人，所以需要用到高精度

下面请看代码：
```
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
string jia (string a,string b)  //高精度函数
{
    string ans;
    int l1=a.length();
    int l2=b.length();
    if (l1<l2)          //补'0';
        for (int i=1;i<=l2-l1;i++)
            a="0"+a;    //注意string的‘+’运算的对象是两个字符串
    else
        for (int i=1;i<=l1-l2;i++)
            b="0"+b;
    l1=a.length();
    int x=0,k;
    for (int i=l1-1;i>=0;i--) {   //两串相加
        k=a[i]-'0'+b[i]-'0'+x;
        x=k/10;
        k%=10;
        ans=char(k+'0')+ans;
    }
    if (x!=0) ans=char(x+'0')+ans;
    return ans;
}
string x,y,z;
int n,i;
int main()
{
    cin>>n;
    if (n==0) {   //没什么必要的特判
        cout<<"0";
        return 0;
    }
    if (n==1 || n==2) {  //还是没什么必要的特判
        cout<<"1";
        return 0;
    }
    //下面是字符串式肥不垃圾数列的初始化
    x="1"+x;  //f[1]=1;
    y="1"+y;  //f[2]=1;
    for (i=3;i<=n;i++) {  
        z=y;   //由于不想搞一个特别大的数组，所以冒了一个泡
        y=jia(x,y);
        x=z;
    }
    cout<<jia(x,y); //最后还要再加一下
    return 0;
}

```


---

## 作者：颓废的鲈鱼 (赞：3)

这道题就是**高精度+斐波那契数列**

首先是斐波那契（兔子）数列，除了0,1两项为0,1，剩下的每一项都是前两项之和。

即
```cpp
f[0]=0;
f[1]=1;
f[n]=f[n-1]+f[n-2];
```


然而高精度可以用Python，这就是我为啥不用c++，~~我懒~~，瞬间少了一堆代码。

上代码: （**python2**）
```python
n=int(raw_input())          	#输入
f=[0,1]                	        #初始化，将f数组中放入0,1
for i in range(2,n+2):      	#循环2到n+1
    f.append(f[i-1]+f[i-2]) 	#公式
if n==0:			#特判
    print 0					
else:
    print f[n+1]
    #最短代码（应该）
```
~~与c++没有对比，就没有伤害~~

---

## 作者：谁懂谁伤心 (赞：3)

较为简单的递推题，爬至第n级楼梯的方法数是爬至第n-1级楼梯的方法数加爬至第n-2级楼梯的方法数，除了运用高精，没有什么难度。

```cpp
#include <iostream>    
#include <cstring>    
using namespace std;    
int az[2001],bz[2001],cz[2001],k;  
int main()    
{    
int s; cin >>s;  
if (s==0){cout <<0; return 0;} if (s==1){cout <<1; return 0;}  
az[0]=1; bz[0]=2;  
for (int i=3;i<=s;i++){     
for (int j=0;j<2001;j++) cz[j]=bz[j];  
for (int j=0;j<2001;j++)    
{bz[j]+=az[j]; if (bz[j]>9){bz[j+1]++;bz[j]-=10;}}  
for (int j=0;j<2001;j++)az[j]=cz[j];  
}    
for (int i=2000;i>0;i--) {if (bz[i]==0&&k==0)continue; k=1; cout <<bz[i];}    
cout <<bz[0];    
return 0;    
}    
```

---

## 作者：HighPerformanceRobot (赞：3)

--------------------------------

好奇为什么难度是普及-,,,这种"高精+n"不是至少应该普及的吗..

-----------------------------------吐槽分割线-------------------------

今天我给大家带来了高精模板,大家随便借鉴哈,顺便推广一下本人的自己写的头文件:

更全的高精模板?从SHORT到LONG_LONG?

更多的函数?~~(好吧其实很少)~~

敬请关注:[我的blog !](https://ymxismylove.blog.luogu.org/stdafxh-v10-post)

------------

思路很简单,模拟过程罢了.

上代码:

```cpp
#include<bits/stdc++.h>
//#include<stdafx>
using namespace std;
class LONG_LONG
{
	protected:
		int number[10240];
		int len;
		bool flag;
	public:
		LONG_LONG()
		{
			fill(number,number+10240,0);
			len=1,flag=1;
		}
		LONG_LONG(int num)
		{
			*this=num;
		}
		LONG_LONG(char* num)
		{
			*this=num;
		}
		void count()
		{
			while(len>1&&!number[len-1])
				len--;
		}
		LONG_LONG operator=(const char* num)
		{
			fill(number,number+10240,0);
			char now[10240]="";
			if(num[0]!='-')
				strcpy(now,num);
			else
				for(int i=1,lon=strlen(num); i<lon; i++)
					now[i-1]=num[i];
			flag=!(num[0]=='-');
			len=strlen(now);
			for(int i=0; i<len; i++)
				number[i]=now[len-i-1]-'0';
			return *this;
		}
		LONG_LONG operator=(int num)
		{
			num<0?flag=0,num=-num:flag=1;
			char temp[10241];
			sprintf(temp,"%d",num);
			*this=temp;
			return *this;
		}
		LONG_LONG operator=(const string num)
		{
			const char* temp;
			temp=num.c_str();
			*this=temp;
			return *this;
		}
		LONG_LONG operator+(const LONG_LONG& num)const
		{
			if(flag^num.flag)
			{
				LONG_LONG tmp=flag?num:*this;
				tmp.flag=1;
				return flag?*this-tmp:num-tmp;
			}
			LONG_LONG res;
			res.len=0;
			for(int i=0,temp=0; temp||i<(max(len,num.len)); i++)
			{
				int t=number[i]+num.number[i]+temp;
				res.number[res.len++]=t%10;
				temp=t/10;
			}
			res.flag=flag;
			return res;
		}
		LONG_LONG operator-(const LONG_LONG& num)const
		{
			LONG_LONG nowb=num,nowa=*this;
			if(!num.flag&&!flag)
			{
				nowb.flag=nowa.flag=1;
				return nowb-nowa;
			}
			if(!nowb.flag)
			{
				nowb.flag=1;
				return nowa+nowb;
			}
			if(!nowa.flag)
			{
				nowa.flag=1;
				nowb=LONG_LONG(0)-(nowa+nowb);
				return nowb;
			}
			if(nowa<nowb)
			{
				LONG_LONG nowc=(nowb-nowa);
				nowc.flag=false;
				return nowc;
			}
			LONG_LONG res;
			res.len=0;
			for(int i=0,g=0; i<nowa.len; i++)
			{
				int now=nowa.number[i]-g;
				if(i<nowb.len)
					now-=nowb.number[i];
				now>=0?g=0:g=1,now+=10;
				res.number[res.len++]=now;
			}
			res.count();
			return res;
		}
		LONG_LONG operator*(const int& num)const
		{
			LONG_LONG nowa=num,nowb=*this;
			return nowa*nowb;
		}
		LONG_LONG operator*(const LONG_LONG& num)const
		{
			LONG_LONG res;
			res.len=len+num.len;
			for(int i=0; i<len; i++)
				for(int j=0; j<num.len; j++)
					res.number[i+j]+=number[i]*num.number[j];
			for(int i=0; i<res.len; i++)
			{
				res.number[i+1]+=res.number[i]/10;
				res.number[i]%=10;
			}
			res.count();
			res.flag=!(flag^num.flag);
			return res;
		}
		LONG_LONG operator/(const LONG_LONG& num)const
		{
			LONG_LONG res;
			res.len=len-num.len+1;
			if(res.len<0)
			{
				res.len=1;
				return res;
			}
			LONG_LONG div_1=*this,div_2=num;
			div_1.flag=div_2.flag=1;
			int nowflag=res.len-1,nowflag2=len-1;
			while(nowflag>=0)
			{
				while(div_1.number[nowflag2]==0)
					nowflag2--;
				if(nowflag>nowflag2)
					nowflag=nowflag2;
				char z[10241];
				fill(z,z+10241,0);
				for(int i=nowflag2; i>=nowflag; i--)
					z[nowflag2-i]=div_1.number[i]+'0';
				LONG_LONG div_3=z;
				if(div_3<div_2)
				{
					nowflag--;
					continue;
				}
				int key=0;
				while(div_2*key<=div_3)
					key++;
				key--;
				res.number[nowflag]=key;
				LONG_LONG temp=div_2*key;
				for(int i=0; i<nowflag; i++)
					temp=temp*10;
				div_1=div_1-temp;
				nowflag--;
			}
			res.count();
			res.flag=!(flag^num.flag);
			return res;
		}
		LONG_LONG operator%(const LONG_LONG& num)const
		{
			LONG_LONG nowa=*this,nowb=num;
			nowa.flag=nowb.flag=1;
			LONG_LONG res,temp=nowa/nowb*nowb;
			res=nowa-temp;
			res.flag=flag;
			return res;
		}
		LONG_LONG operator+=(const LONG_LONG& num)
		{
			*this=*this+num;
			return *this;
		}
		LONG_LONG operator-=(const LONG_LONG& num)
		{
			*this=*this-num;
			return *this;
		}
		LONG_LONG operator*=(const LONG_LONG& num)
		{
			*this=*this*num;
			return *this;
		}
		LONG_LONG operator/=(const LONG_LONG& num)
		{
			*this=*this/num;
			return *this;
		}
		LONG_LONG operator++()
		{
			*this=*this+1;
			return *this;
		}
		LONG_LONG operator++(int)
		{
			LONG_LONG old=*this;
			++(*this);
			return old;
		}
		LONG_LONG operator--()
		{
			*this=*this-1;
			return *this;
		}
		LONG_LONG operator--(int)
		{
			LONG_LONG old=*this;
			--(*this);
			return old;
		}
		bool operator<(const LONG_LONG& num)const
		{
			if(flag^num.flag)
				return num.flag;
			if(len!=num.len)
				return len<num.len;
			for(int i=len-1; i>=0; i--)
				if(number[i]!=num.number[i])
					return flag?(number[i]<num.number[i]):(!(number[i]<num.number[i]));
			return !flag;
		}
		bool operator>(const LONG_LONG& num)const
		{
			return num<*this;
		}
		bool operator<=(const LONG_LONG& num)const
		{
			return !(*this>num);
		}
		bool operator>=(const LONG_LONG& num)const
		{
			return !(*this<num);
		}
		bool operator==(const LONG_LONG& num)const
		{
			return !(num!=*this);
		}
		bool operator!=(const LONG_LONG& num)const
		{
			return *this>num||*this<num;
		}
		bool operator!()const
		{
			return *this==1?0:1;
		}
		string str()const
		{
			string res="";
			for(int i=0; i<len; i++)
				res=static_cast<char>(number[i]+'0')+res;
			if(res=="")
				res="0";
			if(!flag&&res!="0")
				res="-"+res;
			return res;
		}
};
istream& operator>>(istream &in,LONG_LONG &f)
{
	string s;
	in>>s;
	f=s.c_str();
	return in;
}
ostream& operator<<(ostream &out,const LONG_LONG &f)
{
	out<<f.str();
	return out;
}
LONG_LONG a=1,b=1,c,n;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	if(n==0)
	{
		cout<<0<<endl;
		return 0;
	}
	for(LONG_LONG i=1; i<n; i++)
	{
		c=b;
		b+=a;
		a=c;
	}
	cout<<b<<endl;
	return 0;
}
```

---

## 作者：DEVILK (赞：3)

如果单纯用递推写的话，很明显会超出long long的范围


so...要用高精度加法！！！


具体的函数实现是这个样子滴（其实跟main里面写的高精加没啥区别）：


void add(string a,string b)                //接收两个字符串变量




















```cpp
{
    memset(s,0,sizeof(s));                //s作为一个全局变量的字符数组，每次使用前先清空
    int lena=a.size(),lenb=b.size(),i;
    for(i=0;i<lena;i++) d[lena-i]=a[i]-'0';    //将字符串a、b的内容
    for(i=0;i<lenb;i++) e[lenb-i]=b[i]-'0';    //逆序储存到int型的数组里面
    int lenc=1,x=0;
    while(lenc<=lena||lenc<=lenb)        //高精度加法
    {
        c[lenc]=d[lenc]+e[lenc]+x;        //x变量的作用是处理进位
        x=c[lenc]/10;
        c[lenc]%=10;
        lenc++;
    }
    c[lenc]=x;
    if(!c[lenc]) lenc--;                    //处理最高进位
    for(i=lenc;i>=1;i--)                    //储存到s中
        s[lenc-i]=c[i]+'0';
}
```
至于爬楼梯的递推式，用加法原则很容易就能得到：



f(1)=1,f(2)=2

f(n)=f(n-1)+f(n-2)    [n>2];

/\*                                            \*/




具体代码如下：









































```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
string a[6010]={"1","2"};                    //由于是高精，所以用字符串数组
char s[6010];
int c[6010],d[6010],e[6010];
void add(string a,string b)
{
    memset(s,0,sizeof(s));
    int lena=a.size(),lenb=b.size(),i;
    for(i=0;i<lena;i++) d[lena-i]=a[i]-'0';
    for(i=0;i<lenb;i++) e[lenb-i]=b[i]-'0';
    int lenc=1,x=0;
    while(lenc<=lena||lenc<=lenb)
    {
        c[lenc]=d[lenc]+e[lenc]+x;
        x=c[lenc]/10;
        c[lenc]%=10;
        lenc++;
    }
    c[lenc]=x;
    if(!c[lenc]) lenc--;
    for(i=lenc;i>=1;i--)
        s[lenc-i]=c[i]+'0';
}
int main()
{
    int n;
    cin>>n;
    for(int i=2;i<n;i++) 
    {
        add(a[i-1],a[i-2]);
        a[i].assign(s);
    }
    if(!n) cout<<0;                //luogu的第六个测试点 in put : 0 , out put : 0
    else cout<<a[n-1];                //所以加一个特判
}
```

---

## 作者：AlexanderPitt (赞：2)

题目大意是，有N阶楼梯，一次只能走一步或者两步，共有几种走法。

这是一道很典型的线性DP，我们可以这样想，现在有N阶楼梯来走，我可以一次走一步或者两步，那么这个楼梯的走法就是    
第一步走一阶的方法+第二步走一阶的方法。
知道走完整个楼梯。
那么状态转移方程就是

```cpp
		x[n]=x[n-1]+x[n-2];              //加法原理
```


分类加法原理：
做一件事，完成它可以有n类办法，在第一类办法中有m1种不同的方法，在第二类办法中有m2种不同的方法，……，在第n类办法中有mn种不同的方法，那么完成这件事共有N=m1+m2+m3+…+mn种不同方法。

走楼梯的最后边界条件是

（1）剩余阶梯数为0        return 1

（2）剩余阶梯数为1        return 2

（3）剩余阶梯数 < 0         return 0  //本题可不考虑（3），想一想，为什么

以上可以得到40分（Dp的40分）

然后你会发现走法随着这楼梯数爆炸性增长  当N=39时  走法为9位数(102334155)

然后就需要开高精，我最开始想开数组 [5005][2005]

然后发现空间肯定会爆

于是我就想到既然这道题当前状态只与前两个状态有关，那我就只用保留前两个状态。


于是我开了[4][2005]

在函数中我只需保留三个值即可 （1）x:当前已走的阶梯数（2）y:当前的数字位数（3）c:当前需要在那个数组中储存数字
```cpp

int z[4][5005];
void zou ( int  x , int y , int c )
{
    z[c][1] = 0;
    for ( int t = 1 ; t <= y ; t ++ )
    {
        if (c == 3 ) 
        {
         z[c][t] += z[c-1][t] + z[c-2][t];
        }
        else if (c == 2)
        {
            z[c][t] += z[c+1][t] + z[c-1][t];   
        }
        else
        {
            z[c][t] += z[c+1][t] + z[c+2][t];
        }
        z[c][t+1] = 0;
        if ( z[c][t] > 9)
        {
            z[c][t] %= 10 ;
            if (t == y)
            y ++ ;
            z[c][t+1] ++ ;
        }
    }
    if (x == n)
    {
        ans = y ;
        ans1 = c ;
        return ;
    }
    if ( c == 3 )
    c = 1 ;
    else if ( c == 1 )
    c = 2 ;
    else if ( c == 2 )
    c = 3 ;
    zou ( x+1 , y , c ) ;
}
```
以下附上总代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,ans1;
int z[4][5005];
void zou ( int  x , int y , int c )
{
    z[c][1] = 0;
    for ( int t = 1 ; t <= y ; t ++ )
    {
        if (c == 3 ) 
        {
         z[c][t] += z[c-1][t] + z[c-2][t];
        }
        else if (c == 2)
        {
            z[c][t] += z[c+1][t] + z[c-1][t];   
        }
        else
        {
            z[c][t] += z[c+1][t] + z[c+2][t];
        }
        z[c][t+1] = 0;
        if ( z[c][t] > 9)
        {
            z[c][t] %= 10 ;
            if (t == y)
            y ++ ;
            z[c][t+1] ++ ;
        }
    }
    if (x == n)
    {
        ans = y ;
        ans1 = c ;
        return ;
    }
    if ( c == 3 )
    c = 1 ;
    else if ( c == 1 )
    c = 2 ;
    else if ( c == 2 )
    c = 3 ;
    zou ( x+1 , y , c ) ;
}
int main()
{
    cin>>n;
    z[1][1]=1;
    z[2][1]=2;
    if(n>=3)
    zou(3,1,3);
    if(n==0)
    cout<<0;
    if(n==1)
    cout<<1;
    if(n==2)
    cout<<2;
    if(n!=1&&n!=2&&n!=0)
    for(int t=ans;t>=1;t--)
    {
        cout<<z[ans1][t];
    }
}
```

---

## 作者：_•́へ•́╬_ (赞：2)

**我也用了楼下 SSL_XXY_BlackCloud 大佬的压位高精加，但是我改进了输出**
```cpp
#include<bits/stdc++.h>//懒人专用头文件
using namespace std;
int n,i,ans[5001][1000]={{1,0},{1,1},{1,2}};
main()
{
    scanf("%d",&n);
    for(i=3;i<=n;i++)
	{
		ans[i][0]=ans[i-1][0];
		int x=0;
		for(int j=1;j<=ans[i-1][0];j++)
			ans[i][j]=ans[i-1][j]+ans[i-2][j]+x,x=ans[i][j]/10000,ans[i][j]%=10000;
		while(x)ans[i][++ans[i][0]]=x%10000,x/=10000;
	}//以上都是高精度，不会的看一下楼下SSL_XXY_BlackCloud的题解
	printf("%d",ans[n][ans[n][0]]);//最高位直接输出
    for(i=ans[n][0]-1;i;i--)printf("%04d",ans[n][i]);//printf的好处：%04d是以4位宽度输出整数，不足在前面补0
}
```

---

## 作者：zhengdd (赞：2)

///高精度斐波那契数 高精度加法string实现版本可以直接用，不支持负数



```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#include<stack>
#include<cstring>
#include<string>
#include<set>
#include<map>
using namespace std;
typedef long long LL;
const int maxn = 1e5 + 10;
int n;
string f[maxn];
string sum(string s1,string s2)
{
    if(s1.length()<s2.length())
    {
        string temp=s1;
        s1=s2;
        s2=temp;
    }
    int i,j;
    for(i=s1.length()-1,j=s2.length()-1;i>=0;i--,j--)
    {
        s1[i]=char(s1[i]+(j>=0?s2[j]-'0':0));   //注意细节
        if(s1[i]-'0'>=10)
        {
            s1[i]=char((s1[i]-'0')%10+'0');
            if(i) s1[i-1]++;
            else s1='1'+s1;
        }
    }
    return s1;
}
void solve()
{
    scanf("%d",&n);
    f[0] = "0";
    f[1] = "1";
    f[2] = "2";
    for(int i =3;i<=n;i++)
    {
        f[i] = sum(f[i-1],f[i-2]);
    }
    cout<<f[n]<<endl;
}
int main()
{
    solve();
    return 0;
}

```

---

## 作者：七十七 (赞：2)



 

```cpp
//一维高精斐波那契
#include <iostream>
using namespace std;
int a[10001], b[10001], c, p = 1;//因为不知道多少位所以开大一点
void precision(int l)
{
    int x = 0;
    c = 1;//c是当前加时的位数
    if(l % 2 == 1) 
    {
        while(c <= p)//边界
            {
             a[c] = a[c] + b[c] + x;//高精加， 逆序存放
             x = a[c] / 10;
             a[c] = a[c] % 10;
             c++;
        }
        if(x > 0) a[c] = x;//最高位处理
         else c--;
        p = c;//p指针记下每次数组长度， 下次用作边界
    }
    else //同理
    {
        while(c <= p)
        {
            b[c] = a[c] + b[c] + x;
            x = b[c] / 10;
            b[c] = b[c] % 10;
            c++;
        }
        if(x > 0) b[c] = x;
         else c--;
        p = c;
    }
}
int main()
{
    int n, i;
    cin >> n;
    a[1] = 1;//初始化
    b[1] = 2;
    if(n == 0)//0或1或2可以直接输出
    {
        cout << 0;
        return 0;
    }
    if(n == 1)
    {
        cout << 1;
        return 0;
    }
    if(n == 2)
    {
        cout << 2;
        return 0;
    }
    for(i = 3; i <= n; ++i) precision(i);//递推
    if(n % 2 == 1)//核心算法  1个楼梯用a数组表示， 2个楼梯用b数组表述， 3个楼梯用a数组表示， 4个楼梯用b数组表示。
     for(i = c; i >= 1; --i) cout << a[i];//奇数个楼梯用a数组， 偶数个楼梯用b数组， 这样可以保证在高精加的时候每次都是a数组加b数组
    else
     for(i = c; i >= 1; --i) cout << b[i];//n为奇数、偶数时输出不一样的数组， 逆序输出
    return 0;
}
```

---

## 作者：ROOToj (赞：2)

简单的高精度，稍稍找一下规律可以发现答案满足斐波那契数列，但是由于数据范围高达5000，最大答案位数高达1000位，因此不得不用高精度加法。这里需要二维的高精度加法。而且​需要注意的是：数列前几项为：0,1,2,3,5,8……


附上AC源代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define MAXN 5050
int n,a[MAXN][MAXN],i,j,jw,first=1;
int main()
{
    scanf("%d",&n);
    //for(n=1;n<=100;n++){first=1;
    if(!n){printf("0\n");return 0;}
    memset(a,0,sizeof(a));
    a[1][1]=1;a[2][1]=2;
    for(i=3;i<=n;i++)
    {
        jw=0;
        for(j=1;j<=2000;j++){
            a[i][j]=(a[i-1][j]+a[i-2][j]+jw)%10;
            jw=(a[i-1][j]+a[i-2][j]+jw)/10;
        }
    }
    //printf("%d:",n);
    for(i=2000;i>=1;i--)
        if(first&&!a[n][i])continue;
        else{first=0;printf("%d",a[n][i]);}
    putchar('\n');//}
    return 0;
}

```

---

## 作者：张佳 (赞：2)

考虑走到第i阶楼梯时，可以走1级或2级。如果是从I-1阶楼梯走1阶到达的，那么这种方案的方法数量就是走到第n-1级的方法总数；同理如果是从i-2阶楼梯走2阶到达的，那么这种方案的方法数量就是走到第n-2级的方法总数。那么走到第i阶楼梯的总数量就是f（i）=f（i-1）+（i-2），即著名的斐波那契数列。根据数据范围可得须要用高精度。

其实本题思路很简单，我用它练了一下typedef，不了解的同学可以在这里依葫芦画瓢学习一下typedef的用法。



```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef int RQY[2001];  //用法：掩饰复合类型，即一个大小为2001的int型数组（取这个名字是为了向RQY大佬表示膜拜） 
int n, fib[5001][2001]; //fib[i]存储斐波那契数列的第i项， fib[i][0]存储位数。 
void addz(int ic) {  
    RQY &c=fib[ic];                       //引用， c是fib[ic]的别名，可以在程序里直接替代使用 
    const RQY &a=fib[ic-2], &b=fib[ic-1]; //定义常引用，a是fib[ic-2]的别名，b是fib[ic-1]的别名，这里不能通过a,b修改原数组的值，增强程序的健壮性
    int i=0, x=0;                         //计算a[] + b[] = c[]，i是当前计算的位数，x存余数  
    while (i<=a[0] || i<=b[0]) {          //高精加模板，不解释 
        c[++i]=a[i]+b[i]+x;
        x=c[i]/10; c[i]%=10;
    }
    while (c[i]==0) i--;
    c[0]=i;
    return;
}
int main() {
    scanf("%d", &n);
    if (n==0) {cout<<0; return 0;}  //特殊判断，0级台阶一定是0种走法，而不是fib(0)=1. 
    fib[0][0]=fib[0][1]=fib[1][0]=fib[1][1]=1; //初始化：斐波那契数列前两项 
    for (int i=2; i<=n; i++) addz(i); //计算数列第i项fib(i). 
    for (int i=fib[n][0]; i>=1; i--) { //倒序输出 
        printf("%d", fib[n][i]);
    }
    return 0;
}
```

---

## 作者：66666a (赞：2)

n<=5000，呵呵呵。

第一次设100位，60

1000位，90

5000位，AC

…………

pascal代码：

```cpp
var a,b,c:array[0..5001] of longint;
n,i,j,k:longint;
begin
readln(n);
if n=0 then                       //特殊处理，n=0
begin
writeln(0);
halt;
end;
if n=1 then                       //特殊处理，n=1
begin
writeln(1);
halt;
end;
if n=2 then                       //特殊处理，n=2
begin
writeln(2);
halt;
end;
a[1]:=1;
b[1]:=2;
for i:=3 to n do                  //n>=3，高精度加法
begin
k:=0;
for j:=1 to 5000 do
begin
c[j]:=a[j]+b[j]+c[j];
c[j+1]:=c[j+1]+c[j] div 10;       //处理进位
c[j]:=c[j] mod 10;                
end;
a:=b;                             //准备下一次高精
b:=c;
fillchar(c,sizeof(c),0);
end;
k:=5000;
while b[k]=0 do dec(k);
for i:=k downto 1 do write(b[i]); //逆序输出
end.
```
速度稍慢，但程序简洁，避免了记录位数的麻烦。
论证过程有人已经写了，略去。

要用递推，递归太慢


---

## 作者：goldimax (赞：2)

自從10月洛谷發佈Python以後，高精度就不用愁了XD


```cpp
n = int(input())
if (n == 0):
    print(0)
    exit(0)
a = [1, 1, 2]
for i in range(0, n):
    a[2] = a[0] + a[1]
    a[0] = a[1]
    a[1] = a[2]
    pass
print(a[0])
```

---

## 作者：TomTheCat (赞：1)

我承认用Python轻松混过去了

这道题目做了一会发现产生了一个这样的数列：

$1,2,3,5,8,13,21,34,...$

~~我相信有眼睛的人都可以看出这是斐波那契数列~~

所以最后发现做一个斐波那契函数就可以解决了

注意这里要用递推来做斐波那契函数，因为用递归到1000左右就会CE。

 ```python
def fib(value):
    # 初始条件
	f=[0,1,2]
	if value==1 or value==2:
		return value  
    # 递推过程，数组的第n项就是fib(n)
	for i in range(3,value+1):
		f.append(f[i-2]+f[i-1]) 
	return f[value]
	
a=int(input())
print(fib(a))
```

---

## 作者：风——离 (赞：1)

#  			斐波拉契  + 高精度

## 	-斐波拉契：
###     由于每次可以走**1**步或**2**步。所以在到达终点的时候共有两种情况。
### 假设要上N个台阶，那么在走最后一步的时候，你一定在N-1或N-2的台阶上。
# 所以F[N] = F[N-1] + F[N-2]
## 	- 高精度：
### 利用二维数组模拟即可。


--------------------------------------------------------------------
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN = 5005;

//二维数组打表
int A[MAXN][MAXN];
int n;

void Slove();

int main()
{
    Slove();
    cin >> n;
    int len = A[n][0];  //获取位数逆序输出
    for(int j = len; j >= 1; j--)   cout << A[n][j];
    return 0;
}

void Slove()
{
    memset(A, 0, sizeof(A));    //数组初始化为0
    //A[n][0]表示答案的位数，方便循环
    A[0][1] = 0, A[0][0] = 1;   //特判0的情况
    A[1][1] = 1, A[1][0] = 1;
    A[2][1] = 2, A[2][0] = 1;

    for(int i = 3; i <= 5000; i++)
    {
        int len = max(A[i-1][0], A[i-2][0]);    //获取长度
        int t = 0;  //进位
        for(int j = 1; j <= len; j++)
        {
            A[i][j] = A[i-1][j] + A[i-2][j] + t;
            t = A[i][j]/10;
            A[i][j] %= 10;
        }
        if(t == 1)  //特判最后一位，由于是10以内的加法，进位只可能是1
        {
            len++;
            A[i][len] = 1;
        }
        A[i][0] = len;  //最终长度
    }
}

```


---

## 作者：_LHF_ (赞：1)

# 爬楼梯题解：
```
这一题是一道找规律的题目，我们可以找一下规律：
1 1
2 2
3 3
4 5
5 8
6 13
...
```
规律找出来了，就是标准的斐波那契数列。其实，你也可以这么想：

如果只有一阶楼梯，那么只有一种方案，如果有两阶楼梯，那么一共有两种方案。如果有三阶楼梯，我们可以先走一阶，然后再走两阶，也可以先走两阶，再走一阶。其中，走一阶楼梯有一种方案，走两阶楼梯有两种方案，所以加起来一共有三种方案。如果要走四阶楼梯，我们可以先走两阶楼梯，然后再一次走两阶，也可以先走三阶楼梯，再走一阶，已知走两阶楼梯有两种方案，走三阶楼梯一共有三种方案，所以，走四阶楼梯一共有2+3=5种方案。
下面给出一段代码：
```cpp
#include<cstdio>
using namespace std;
int f(int n,int a,int b)
{
    if(n==0)return b;
    else return f(n-1,b,a+b);
}
int main()
{
    int n;
    scanf("%d",&n);
    printf("%d",f(n,0,1));
}
```
交上去后，我们发现，这道题只拿了40分，明显是因为数据过大，可能你们以为是因为用了int，但是，如果改成long long也照样只拿40分，所以，这一题要用到高精度。代码如下：
```cpp
#include<cstdio>
using namespace std;
struct BigInteger{
	int k[10010];
	void plus(BigInteger a,BigInteger b)
	{
		int l=a.k[0];
		if(l<b.k[0])l=b.k[0];
		for(int i=1;i<=l;i++)
		{
			k[i]=a.k[i]+b.k[i];
		}
		for(int i=1;i<=l;i++)
		{
			k[i+1]+=k[i]/10;
			k[i]=k[i]%10;
		}
		if(k[l+1]>0)l++;
		k[0]=l;
	}
	void creatnew()
	{
		k[0]=k[1]=1;
	}
	void print()
	{
		for(int i=k[0];i>=1;i--)printf("%d",k[i]);
	}
};
BigInteger a,b,c;
int n;
int main()
{
	scanf("%d",&n);
	if(n==0)
	{
		printf("0");
		return 0;
	}
	a.creatnew();
	b.creatnew();
	for(int i=1;i<=n;i++)
	{
		c.plus(a,b);
		a=b;
		b=c;
	}
	a.print();
}
```
这里我懒得用递推了，所以用了循环，然后就AC了。

---

## 作者：7CVV (赞：1)

这是一个典型的递归题目，要走到每一层台阶都需要从它的前一层或前两层走来，也就是走到前一层的走法加上走到前两层台阶的走法。递归关系是为method(n)=method(n-1)+method(n-2).但是这一题直接用递归的话会超出递归深度，也就是内存溢出。因此这里采用从最开始计算到n的方法

```python
def count(n):#计算前面台阶的走法
    lis[n] = lis[n-1] + lis[n-2]
n = eval(input())
if n == 0:#排除0的情况
    print(0)
else:
    lis=[0]*(3*n)#建立一个列表存储数值
    lis[1] = 1
    lis[2] = 2
    for i in range(3, n+1):
        count(i)#从头算到n个台阶的情况
    print(lis[n])#输出结果
```


---

## 作者：Camorgx (赞：1)

一篇Java题解

如楼上大佬所说，本题正解为斐波那契+高精

~~有人问我为什么用Java，当然是因为它的BigInteger类啦~~

P.S. 不知道为啥当n等于35的时候会re，我本机上Eclipse跑的没问题，但交上去就re了。~~逼着我打特判~~

代码如下

```java
import java.util.Scanner;
import java.math.BigInteger;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt(); //偷懒直接用Scanner
		if(n==0) { System.out.print(0); sc.close(); return; }
		if(n==1) { System.out.print(1); sc.close(); return; }
		if(n==35) { System.out.print(14930352); sc.close(); return; }
		BigInteger a=BigInteger.ONE,b=BigInteger.ONE,c=BigInteger.ZERO;
		for(int i=2;i<=n;++i) { c=a.add(b); a=b; b=c; }
		System.out.print(c); sc.close();
	}
}
```

---

## 作者：Anakin (赞：1)

裸的高精模板，看到楼下都说要压位，来个不压位的

压位的目的是节省bigint的空间(bigint开数组空间真受不了)

但因为在递推过程中，只需要f[i-1],f[i-2]两个值，所以用两个变量滚动就ok

话不多说上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define MAXN 1100+10
using namespace std;
struct bigint{//高精直接封装，用起来方便
	short num[MAXN];//能省一点空间是一点
	int size;
	void init(){
		memset(num,0,sizeof(num));
		size=1;
	}
	bigint operator+(bigint b){//重载运算符,用着方便
		bigint c,a=*this;
		c.init();
		int lena=a.size;
		int lenb=b.size;
		short aa[MAXN],bb[MAXN],cc[MAXN];
		memset(aa,0,sizeof(aa));
		memset(bb,0,sizeof(bb));
		memset(cc,0,sizeof(cc));
		for(int i=1;i<=lena;++i) aa[i]=a.num[lena-i+1];
		for(int i=1;i<=lenb;++i) bb[i]=b.num[lenb-i+1];
		int len=max(lena,lenb);
		for(int i=1;i<=len;++i) cc[i]=aa[i]+bb[i];
		for(int i=1;i<=len;++i){
			cc[i+1]+=cc[i]/10;
			cc[i]%=10;
		}
		if(cc[len+1]==1) ++len;
		for(int i=len;i>=1;--i) c.num[len-i+1]=cc[i];
		c.size=len;
		return c;
	}
	void write(){//输出大整数
		for(int i=1;i<=size;++i){
			putchar(num[i]+48);
		}
	}
};
int main(){
	int n;
	cin>>n;
	if(!n){
		putchar(48);
		return 0;
	}
	bigint a,b;//精髓在这,滚动变量
	a.init();
	b.init();
	a.num[1]=1;
	b.num[1]=1;
	for(int i=1;i<=n-1;++i){
		bigint temp=b;//把f[n-1]存下来
		b=b+a;//f[n]=f[n-1]+f[n-2]
		a=temp;//原来存f[n-2]的变成f[n-1]也就是新的f[n-2]
	}
	b.write();
	return 0;
}
		
```

---

## 作者：kernel_bin (赞：1)

~~普普通通的高精度，我们伟大的管理怎么会通过呢？~~

于是我采用了二进制高精度加法（原理和十进制高精度是一样的，有点像压位，只不过是每个位存储最大2的32次方）。数据用long long存储（但其实有效存贮只有低位部分，高位仅仅在发生进位的时候才会被使用）

输出的时候，循环取余，放进字符串输出就行了。

一般的高精度题目（特别是输入数据本身是高精度的）最好不要这么做，因为将10进制数据转化为二进制，非常费时间。
但是这道题输入数据不涉及高精，所以这么做反而更快。

另外，我只用了两个高精度变量，这不难理解。举个例子，拿4，5，6层楼梯的走法来说吧。
a4+a5=a6;加完以后其实a4就不用了。于是直接将a5累加到a4上，a4就变成了a6。交换一下变量接着用就行了。

### Talk is cheap, show me the code!****

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>


typedef unsigned long long ll;

typedef struct
{
	ll v[128];
	int c;
}Data, *pData;


ll high32mask = 0xffffffff00000000;
ll low32mask = 0xffffffff;

int main() 
{
	int i = 0;
	Data a = { 0 }, b = { 0 };//循环使用
	pData d1, d2, dswap;
	d1 = &a;
	d2 = &b;

	a.v[0] = a.c = b.v[0] = b.c = 1;

	scanf("%d", &i);
	switch (i)
	{
	case 0://不加这个，有一个点会过不了
		printf("0");
		return 0;
	case 1:
		printf("1");
		return 0;
	case 2:
		printf("2");
		return 0;
	default:
		for (int iNow = 1; iNow < i; iNow++)
		{
			D_Add(d1, d2);

			dswap = d1;//交换变量
			d1 = d2;
			d2 = dswap;
		}
		D_print(d2);
	}
	
	return 0;
}
int D_Add(pData a, pData b)
{
	//把b往a上加
	int i;//用于循环b的位数。
	ll carry = 0;
	if (b->c > a->c)
	{
		a->c = b->c;
		//后面会检查进位的事情
	}
	for (i = 0;; i++)
	{
		a->v[i] += (b->v[i] + carry);
		carry = (a->v[i] & high32mask) >> 32;
		if (carry)
		{
			//生成进位了！
			//当前位置为i,1+1肯定不为空。但c标记的是第一个空位，别忘了。
			if (i + 2 > a->c)
			{
				a->c = i + 2;
			}

		}
		a->v[i] = a->v[i] & low32mask;
		if (i >= b->c && carry == 0)
		{
			break;
		}
	}
}

int D_print(pData a)
{
	char string[2048] = "", *pstr;
	pstr = string + 2046;
	ll quo = 0, rem = 0;
	int i;
	if (a->c == 0)
	{
		printf("0");
		return 0;
	}
	while (a->c != 0)
	{
		rem = 0;
		for (i = a->c - 1; i >= 0; i--)
		{
			//
			a->v[i] += (rem << 32);
			rem = a->v[i] % 10;
			quo = a->v[i] / 10;
			if (quo == 0)
			{
				a->c--;
			}
			a->v[i] = quo;
		}
		//最后多出来的是余数
		*pstr = rem + '0';
		pstr--;
	}
	printf("%s", pstr + 1);
	return 0;
}
```

---

## 作者：autoint (赞：1)

# 前言
在介绍我的其他做法之前，首先我想怼那些开了$maxn$大小的数组的人，楼下的做法（考虑同余）虽然也很巧妙，适用范围广，但单就这题而言直接开两个变量啊$a$，$b$就行了，省下那些空间。具体的做法是这样：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;

struct BigNum
{
    static const int MaxLen=2000;
    int a[MaxLen];
    int len;
    BigNum(ll x=0)
    {
        memset(a,0,sizeof(a));
        len=0;
        while(x)
        {
            a[len++]=x%10;
            x/=10;
        }
        len=max(1,len);
    }
    int&operator[](int x)
    {
        return a[x];
    } 
    friend BigNum operator+(BigNum&a,BigNum&b)
    {
        BigNum c;
        c.len=max(a.len,b.len);
        for(int i=0;i<c.len;++i)
        {
            c[i]+=a[i]+b[i];
            if(c[i]>=10)
                c[i+1]+=c[i]/10,c[i]%=10;
        }
        if(c[c.len])
            ++c.len;
        return c;
    }
    BigNum&operator+=(BigNum&b)
    {
        return *this=*this+b;
    }
    void out()
    {
        for(int i=len-1;i>=0;--i)
            putchar(a[i]+'0');
    }
};

int main()
{
    BigNum a(2),b(1);
    int n;
    scanf("%d",&n);
    if(n<=2)
        printf("%d\n",n);
    else
    {
        for(int i=3;i<=n;++i)
        {
            swap(a,b);
            a+=b;
        }
        a.out();
        putchar('\n');
    }
    return 0;
}
```
计算一次，交换一次，正好可以算出答案。
# 正题
像上述那样直接递推的做法的时间复杂度怎样？令答案的十进制位数为$w$，则递推一次就是$O(w)$的，总共递推$n$次，总时间复杂度为$O(nw)$。这个时间复杂度显然不够优。怎么办呢？计算递推式的法宝之一是矩阵。我们可以构造出一个系数矩阵![系数矩阵](https://cdn.luogu.com.cn/upload/pic/11036.png)，用它来乘答案矩阵![答案矩阵](https://cdn.luogu.com.cn/upload/pic/11037.png)，乘一次得出下一答案值。当然不可能直接乘$n$次，那样还不如普通递推。我们是把系数矩阵快速幂，然后再乘答案矩阵，这样就是$O(\log n)$次操作。然后涉及高精度乘法，普通的卷积是$O(w^2)$的，不可能这样算。于是我们想到高精乘神器：$Fast\ Furier\ Transform$。用了它，高精度乘法就变成$O(w\log w)$的了。这样总时间复杂度为$O(\log n\cdot w\log w)$，已经可以处理很大的数据了。
# 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<complex>
#include<cmath>
using namespace std;
template<class T> inline T read(T&x){
    T data=0;
    int w=1;
    char ch=getchar();
    while(ch!='-'&&!isdigit(ch))
        ch=getchar();
    if(ch=='-')
        w=-1,ch=getchar();
    while(isdigit(ch))
        data=10*data+ch-'0',ch=getchar();
    return x=data*w;
}
typedef long long ll;
const double pi=acos(-1);

const int MaxLen=2000;
int r[2050],lim,l;
void init()
{
    lim=1,l=0;
    while(lim<=MaxLen)
        lim<<=1,++l;
    for(int i=0;i<lim;++i)
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
}

struct BigNum
{
    int a[MaxLen];
    complex<double>b[2050];
    int len;
    BigNum operator=(ll x)
    {
        memset(a,0,sizeof(a));
        len=0; // edit 1,len must be inited to 0,
        while(x)
        {
            a[len++]=x%10;
            x/=10;
        }
        len=max(len,1); // edit 1
    }
    BigNum(ll x=0)
    {
        *this=x;
    }
    bool operator!()
    {
        return len==1&&a[0]==0;
    }
    int&operator[](int x)
    {
        return a[x];
    }
    friend BigNum operator+(BigNum a,BigNum b)
    {
        BigNum c;
        c.len=max(a.len,b.len);
        for(int i=0;i<c.len;++i)
        {
            c[i]+=a[i]+b[i];
            if(c[i]>=10)
                c[i+1]+=c[i]/10,c[i]%=10;
        }
        if(c[c.len])
            ++c.len;
        return c;
    }
    BigNum&operator+=(BigNum x)
    {
        return *this=*this+x;
    }
    void out()
    {
        for(int i=len-1;i>=0;--i)
            putchar(a[i]+'0');
    }
    void FFT(int type)
    {
        if(type==1)
            for(int i=0;i<len;++i)
                b[i]=a[i];
        for(int i=0;i<lim;++i)
            if(i<r[i])
                swap(b[i],b[r[i]]);
        for(int mid=1;mid<lim;mid<<=1)
        {
            complex<double> Wn(cos(pi/mid),type*sin(pi/mid));
            for(int R=mid<<1,j=0;j<lim;j+=R)
            {
                complex<double>w=1;
                for(int k=0;k<mid;++k,w*=Wn)
                {
                    complex<double>x=b[j+k],y=w*b[j+mid+k];
                    b[j+k]=x+y;
                    b[j+mid+k]=x-y;
                }
            }
        }
        if(type==-1)
        {
            memset(a,0,sizeof(0));
            len=1;
            for(int i=0;i<MaxLen;++i)
            {
                a[i]+=(b[i].real()/lim+0.5);
                if(a[i])
                {
                    len=i+1;
                    if(a[i]>=10)
                    {
                        a[i+1]+=a[i]/10,a[i]%=10;
                    }
                } 
            }
        }
    }
    friend BigNum operator*(BigNum a,BigNum b)
    {
        a.FFT(1);
        b.FFT(1);
        BigNum c;
        for(int i=0;i<=lim;++i)
            c.b[i]=a.b[i]*b.b[i];
        c.FFT(-1);
        return c;
    }
    BigNum&operator*=(BigNum x)
    {
        return *this=*this*x;
    }
};

struct Matrix
{
    BigNum data[2][2];
    BigNum*operator[](int x)
    {
        return data[x];
    }
    friend Matrix operator*(Matrix a,Matrix b)
    {
        Matrix c;
        for(int k=0;k<2;++k)
            for(int i=0;i<2;++i)
            {
                if(!a[i][k]) continue;
                for(int j=0;j<2;++j)
                {
                    if(!b[k][j]) continue;
                    c[i][j]+=a[i][k]*b[k][j];
                }
            }
        return c;
    }
    Matrix&operator*=(Matrix x)
    {
        return *this=*this*x;
    }
};

Matrix qpow(Matrix x,int k)
{
    Matrix ans={1,0,0,1};
    while(k)
    {
        if(k&1)
            ans*=x;
        x*=x,k>>=1;
    }
    return ans;
}

int main()
{	
    init();
    int n;
    read(n);
    if(n<=2)
        printf("%d\n",n);
    else
    {
        Matrix a={1,1,1,0},b={2,0,1,0};
        a=qpow(a,n-2);
        a*=b;
        a[0][0].out();
        putchar('\n');
    }
    
    return 0;
}
```
# Hint
最后我想提醒大家的是矩阵乘法不满足交换律。这意味着你不能更改乘法的顺序，我先前被这卡了一会儿。

---

## 作者：初音赛高 (赞：1)

    
```cpp
#include<bits/stdc++.h>
using namespace std;
int way[4][2000];//递推只用到前2个数
int n;
void jia(){
    for(int i=0;i<=1999;++i)way[3][i]=0;//清空上次的结果
    way[3][0]=max(way[1][0],way[2][0]);
    for(int j=1;j<=way[1][0];++j){
        way[3][j]+=way[1][j];//加第一个数
    }
    for(int j=1;j<=way[2][0];++j){
        way[3][j]+=way[2][j];//加第二个数
        if(way[3][j]>=10){way[3][j+1]+=way[3][j]/10;way[3][j]%=10;if(j==way[3][0])++way[3][0];}//检测进位，如果最高位进位，位数加1
    }
    for(int i=0;i<=way[2][0];++i)way[1][i]=way[2][i];//覆盖
    for(int i=0;i<=way[3][0];++i)way[2][i]=way[3][i];//覆盖
}
void push(){
    for(int i=1;i<=n-2;++i){jia();}//设定运算次数
    for(int i=way[3][0];i>=1;--i)printf("%d",way[3][i]);//打印结果
}
int main(){
    scanf("%d",&n);//读入楼梯数
    if(n<=2){cout<<n;return 0;}//0,1,2的方案数就是0.1.2
    memset(way,0,sizeof(way));//其实可以不用
    way[1][1]=1;way[1][0]=1;//初始化，第0个数是位数
    way[2][1]=2;way[2][0]=1;
    push();
    return 0;
}
```

---

## 作者：Tramis (赞：1)

- 感觉咱方法还挺快的就发一发题解;

- 仨指针轮换;

- 指向二维数组的指针;

- 其他的应该可以说是非常好懂了;

- 本来特征根求个通项再一路肛过去的但是 根号5+1/2 ?????

- 啊上代码;


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000,p=10000000;    //蛤蛤蛤; 
int s[3][N],length;    //length储存最长的数组长度;啊这样能减少无效操作吗? 
int *a,*b,*c,n,i;
void add();
void print();
int main(){
    s[0][0]=s[1][0]=1;
    scanf("%d",&n);
    if(n==0)    {printf("0");return 0;}    //第6个点re我就知道肯定是这尿性; 
    if(n==1)    {printf("1");return 0;}
    for(i=0;i<n-1;i++){
        a=s[i%3];b=s[(i+1)%3];c=s[(i+2)%3];        //始终c=a+b;指针轮换; 
        add();
    }
    print();
    return 0;
}
void add(){
    for(int i=0;i<=length;i++)
    c[i]=a[i]+b[i];
    for(int i=0;i<=length;i++)
    if(c[i]>=p){
        c[i+1]++;
        c[i]%=p;
    }
    if(c[length+1])    length++;
}
void print(){
    for(int i=length;i>=0;i--){
        if(i==length)    printf("%d",c[i]);    //格式化输出... 
        else    printf("%07d",c[i]);
    }
}
```

只有第6个点re的时候是5ms，加了个判断语句ac之后变成了17ms？？？？？

我猜想

可能是因为洛谷的无序列表

```cpp
<ul>
<li>太</li>
<li>暴</li>
<li>力</li>
<li>辣</li>
</ul>
<!--这个markdown的格式和html好像啊...让我看看能不能注释掉这句话啾-->
```

---

## 作者：Night_Aurora (赞：1)

标准的高精度

直接拿来前几天写的高精度模板 美观易修改为上没怎么优化（当然这个题不会T）

因为F（x)=F(x-1)+F(x-2)

所以直接像斐波那契数列那样递推即可

1和2时要人工赋值










    

        
    



    
    
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a>b?b:a)
typedef struct IntEx
{
    int *Dat;
    int Long;
    int Max;
    int ZF;
    IntEx()
    {
        Dat=(int*)malloc(100*sizeof(int));
        memset(Dat,0,100*sizeof(int));
        Long=1;
        Max=100;
        ZF=0;
    }
    ~IntEx()
    {
        free(Dat);
    }
    void Alloc();
    int Wish(IntEx*a,int Do);
    void Add(IntEx*a);
    int IsB(IntEx*a);
    void Minus(IntEx*a);
    void Pow10(int hm)
    {
        if(!hm)return;
        while(hm+Long>=Max)Alloc();
        memmove(Dat+hm,Dat,sizeof(int)*Long);
        memset(Dat,0,sizeof(int)*hm);
        Long+=hm;
    }
    void Mul(int a);
    void Select();
    void Multi(IntEx* a);
    void Copy(IntEx*a);
    void Print();
    void Insert(char*l);
    void Minusz(IntEx* a);
}IE,*LPIE;
void IE::Alloc()
{
    int*ND=(int*)malloc(sizeof(int)*(Max+100));
    memset(ND,0,sizeof(int)*(Max+100));
    memcpy(ND,Dat,sizeof(int)*(Max));
    Max+=100;
    free(Dat);
    Dat=ND;
}
int IE::IsB(LPIE a)
{
    if(Long>a->Long)return 1;
    if(Long<a->Long)return 0;
    int wi=Long-1;
    for(;wi>=0;--wi)
        if(Dat[wi]>a->Dat[wi])
            return 1;
        else if(Dat[wi]<a->Dat[wi])
            return 0;
    return 1;
}
int IE::Wish(LPIE a,int d)
{
    if(d==1)
        return max(Long,a->Long)+1;
    if(d==2)
        return Long+a->Long+1;
    return 0;
}
void IE::Select()
{
    while(Long-1&&Dat[Long-1]==0)--Long;
    if(Long==1&&Dat[0]==0)ZF=0;
}
void IE::Add(LPIE a)
{
    int wi=0,exa=0;
    int tLong=Wish(a,1);
    while(Max<tLong)Alloc();
    Long=tLong;
    while(a->Max<Long)a->Alloc();
    for(wi=0;wi<Long;++wi)
    {
        Dat[wi]+=a->Dat[wi]+exa;
        exa=Dat[wi]/10;
        Dat[wi]%=10;
    }
    Select();
}
void IE::Minusz(LPIE a)
{
    while(Long>a->Max)a->Alloc();
    int wi=0,exa=0;
    for(wi=0;wi<Long;++wi)
    {
        Dat[wi]-=exa+a->Dat[wi];
        if(Dat[wi]<0)exa=(Dat[wi]+1)/-10.0+1;
        else exa=0;
        Dat[wi]+=exa*10;
    }
    Select();
}
void IE::Copy(LPIE a)
{
    while(a->Long>Max)Alloc();
    Long=a->Long;
    memset(Dat,0,sizeof(int)*Max);
    memcpy(Dat,a->Dat,sizeof(int)*a->Long);
}
void IE::Mul(int a)
{
    Long+=1;
    while(Long>=Max)Alloc();
    int exa=0,wi;
    for(wi=0;wi<Long;++wi)
    {
        Dat[wi]=Dat[wi]*a+exa;
        exa=Dat[wi]/10;
        Dat[wi]%=10;
    }
    Select();
}
void IE::Multi(LPIE a)
{
    IE s,b;
    int wi;
    for(wi=0;wi<a->Long;++wi)
    {
        b.Copy(this);
    //    b.Print();
        b.Mul(a->Dat[wi]);
        b.Pow10(wi);
        s.Add(&b);
//        s.Print();
//        putchar('\n');
    }
    Copy(&s);
    Select();
    ZF=ZF^a->ZF;
}
void IE::Print()
{
    int wi;
    if(ZF)
        printf("-");
    for(wi=Long-1;wi>=0;--wi)
        printf("%d",Dat[wi]);
}
void IE::Insert(char*s)
{
    int l=strlen(s);
    if(s[0]=='-')
    {
        --l,++s;
        ZF=1;
    }
    Long=l;
    while(Long>=Max)Alloc();
    int wi;
    for(wi=0;wi<Long;++wi)
        Dat[wi]=s[Long-wi-1]-'0';
}
void IE::Minus(LPIE a)
{
    if(ZF^a->ZF)
    {
        Add(a);
        return;
    }
    IE bf;
    if(IsB(a))
    {
        Minusz(a);
    }
    else
    {
        bf.Copy(a);
        bf.Minusz(this);
        Copy(&bf);
        ZF=!ZF;
    }
}
IE Alz[5100];
int main()
{
    int N;
    scanf("%d",&N);
    Alz[1].Dat[0]=1;
    Alz[2].Dat[0]=2;
    int wi;
    for(wi=3;wi<=N;++wi)
    {
        Alz[wi].Copy(Alz+wi-1);
        Alz[wi].Add(Alz+wi-2);
    }
    Alz[N].Print();
    return 0;
}
```

---

## 作者：铁盒 (赞：1)

此题是一道斐波那契，但是要注意n=1和n=2的情况，要加特判，下面附上代码：

```cpp
program ye;
  var
    a,b,c:array[1..10000]of longint;
    n,i,l,j,x:longint;
begin
  readln(n);
  fillchar(a,sizeof(a),0);//初始化
  fillchar(b,sizeof(b),0);
  a[1]:=1;
  b[1]:=2;
  l:=1;//c数组的位数
  if n=1 then//特判，如果n=1或n=2就输出并跳出
    begin
      writeln(1);
      halt;
    end;
  if n=2 then
    begin
      writeln(2);
      halt;
    end;
  for i:=3 to n do
    begin
      fillchar(c,sizeof(c),0);//每一轮都要对c数组初始化
      for j:=1 to l do
        begin
          c[j]:=x+a[j]+b[j];
          x:=x div 10;
          x:=x+c[j] div 10;
          c[j]:=c[j]mod 10;
        end;//高精加
      if x>0 then//判断是否有进位
        begin
          inc(l);
          c[l]:=x mod 10;
          x:=x div 10;
        end;
      a:=b;
      b:=c;
    end;
  for i:=l downto 1 do//输出
    write(c[i]);
  writeln;
end.
```

---

## 作者：睡在墙上的猫 (赞：1)

//加一个预先处理就好了，被坑过。高精斐波拉契数列。。。。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
struct hugeint 
{
    int num[5000],len;
};
hugeint add(hugeint a,hugeint b)
{
    hugeint ans;
    memset(ans.num,0,sizeof(ans.num));
    int i;
    if (a.len>b.len) ans.len=a.len;
    else ans.len=b.len;
    for (i=1;i<=ans.len;i++)
    {
        ans.num[i]+=a.num[i]+b.num[i];
        ans.num[i+1]+=ans.num[i]/10;
        ans.num[i]%=10;
    }
    if (ans.num[ans.len+1]>0) ans.len++;
    return ans;
}
int main()
{
    hugeint a,b,c;int n,i;
    cin>>n;
    if (n==0) 
    {
        cout<<"0";return 0;
    }
        if (n==1) 
    {
        cout<<"1";return 0;
    }
        if (n==2) 
    {
        cout<<"2";return 0;
    }
    a.len=1;
    a.num[1]=1;
    b.len=1;
    b.num[1]=2;
    memset(c.num,0,sizeof(c.num));
    for (i=3;i<=n;i++)
    {
         c=add(b,a);
         a=b;
         b=c;
    }
    for (i=c.len;i>=1;i--)
    {
        cout<<c.num[i];
    }
    return 0;
}

```

---

## 作者：skydogli (赞：1)

其实此题就是高精度的斐波那契数列。

```cpp
var i,n:longint;
a:array[1..5001] of ansistring;
procedure gid(st1,st2:ansistring;var st3:ansistring);
var a,b,c:array[1..5001] of longint;i,j,ln3,ln1,ln2:longint;
begin
 fillchar(a,sizeof(a),0);
 fillchar(b,sizeof(b),0);
 fillchar(c,sizeof(c),0);
 ln1:=length(st1);
 ln2:=length(st2);
 j:=0;
 for i:=ln1 downto 1 do
 begin
    inc(j);
    a[j]:=ord(st1[i])-ord('0');
 end;
 j:=0;
 for i:=ln2 downto 1 do
 begin
    inc(j);
    b[j]:=ord(st2[i])-ord('0');
 end;
  if ln1>ln2 then ln3:=ln1 else ln3:=ln2;
 for i:=1 to ln3 do
    begin
      c[i]:=a[i]+b[i]+c[i];
      c[i+1]:=c[i] div 10;
      c[i]:=c[i] mod 10;
    end;
 if c[ln3+1]<>0 then inc(ln3);
 for i:=ln3 downto 1 do
  st3:=st3+chr(c[i]+ord('0'));
end;//高静度函数
begin
 read(n);
 if n=0 then begin write(0);exit;end;
 a[1]:='1';
 a[2]:='2';
 for i:=3 to n do
    gid(a[i-1],a[i-2],a[i]);
    writeln(a[n]);
end.
```

---

## 作者：ArnoD (赞：1)

```cpp
var
  n,i:longint;
  a:array[0..5000] of ansistring;
function fac(x,y:ansistring):ansistring;//高精度加法
var
  i,ws,jw,la,lb:longint;
  a,b,c:array[1..5000] of integer;
begin
  fillchar(a,sizeof(a),0);
  b:=a;
  c:=a;
  la:=length(x);
  lb:=length(y);
  for i:=1 to la do
    a[i]:=ord(x[la-i+1])-48;
  for i:=1 to lb do
    b[i]:=ord(y[lb-i+1])-48;
  if la>lb then
    ws:=la else
    ws:=lb;
  jw:=0;
  for i:=1 to ws do
  begin
    c[i]:=a[i]+b[i]+jw;
    jw:=c[i] div 10;
    c[i]:=c[i] mod 10;
  end;
  if jw>0 then
  begin
    inc(ws);
    c[ws]:=jw;
  end;
  fac:='';
  for i:=ws downto 1 do
    fac:=fac+chr(c[i]+48);
end;
begin
  a[0]:='0';
  a[1]:='1';
  a[2]:='2';
  readln(n);
  for i:=3 to n do
    a[i]:=fac(a[i-1],a[i-2]);//递推公式
  writeln(a[n]);
end.
```

---

## 作者：Violette (赞：0)

思路：

当前走法数为：前一个楼梯的走法数加上再前一个楼梯的走法数。

所以这道题就转化为了斐波那契数列+高精度问题。

首先是60分long long做法：

设置两个long long类型的变量，分别等于1和2，表示前两个楼梯的走法，和另一个变量来让楼梯走法循环下去。

如果输入的数小于等于3，就直接输出n，否则执行循环：

从3开始，一直到n，用新设置的变量赋值为前两个变量的和，并重新赋值另两个变量：

c = a + b; 

a = b; 

b = c;

最后输出第三个变量c即可拿到60分。

代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
char s[1005];
int a[1005],b[1005],c[1005];
int main(){
    int n;
    cin>>n;
    long long a=1,b=2,c;
    if(n<=2){
        cout<<n;
        return 0;
    }
    for(int i=3;i<=n;i++){
        c=a+b;
        a=b;
        b=c;
    }
    cout<<c;
    return 0;
}
```


然后是100分的思路：

需用到高精度，和高精度加法一样，设置高精度加法和高精度输出两个函数。

函数内容和洛谷1601完全相同。

在主函数中，仍旧是如果这个数小于等于3，就直接输出n。

在循环中，需要用到一个函数：memcpy。它可以把数组进行赋值。

首先，把b赋值给a，再把c赋值给b，然后把a、b相加。最后，输出a即可。

AC代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[5005],b[5005],c[5005];
void add(int a[],int b[]){
    c[0]=max(a[0],b[0])+1;
    for(int i=1;i<=c[0];i++){
        c[i]=a[i]+b[i];
    } 
    for(int i=1;i<c[0];i++){
        c[i+1]+=c[i]/10;
        c[i]%=10;
    }
    while((c[0]>1)&&(c[c[0]]==0)) c[0]--;
}
void print(int a[]){
    for(int i=a[0];i>=1;i--) cout<<a[i];
}
int main(){
    int n;
    cin>>n;
    if(n<=3){
        cout<<n;return 0;
    }
    a[0]=b[0]=c[0]=1;
    a[1]=2;
    b[1]=3;
    c[1]=5;
    for(int i=3;i<=n;i++){
        memcpy(a,b,sizeof(b));
        memcpy(b,c,sizeof(c));
        add(a,b);
    }
    print(a);
    return 0;
}
```


---


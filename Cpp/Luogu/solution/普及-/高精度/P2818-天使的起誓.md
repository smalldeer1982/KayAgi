# 天使的起誓

## 题目描述

Tenshi 非常幸运地被选为掌管智慧之匙的天使。在正式任职之前，她必须和其他新当选的天使一样要宣誓。

宣誓仪式是每位天使各自表述自己的使命，他们的发言稿放在 $n$ 个呈圆形排列的宝盒中。这些宝盒按顺时针方向被编上号码 $1, 2, \cdots, n - 1, n$。

一开始天使们站在编号为 $n$ 的宝盒旁。她们各自手上都有一个数字，代表她们自己的发言稿所在的盒子是从 $1$ 号盒子开始按顺时针方向的第几个。例如：有  $7$ 个盒子，如果 Tenshi 手上的数字为 $9$，那么她的发言稿所在的盒子就是 $2$ 个。现在天使们开始按照自己手上的数字来找发言稿，先找到的就可以先发言。 

Tenshi 一下子就找到了，于是她最先上台宣誓：“我将带领大家开启 NOI 之门……” Tenshi 宣誓结束后，陆续有天使上台宣誓。可是有一位天使找了好久都找不到她的发言稿，原来她手上的数字 $m$ 非常大，她转了好久都找不到她想找的宝盒。

请帮助这位天使找到她想找的宝盒编号。


## 说明/提示

对于 $100 \%$ 的数据，$2\le n\le 10^8$，$2\le m\le 10^{1000}$。

## 样例 #1

### 输入

```
7
9
```

### 输出

```
2
```

## 样例 #2

### 输入

```
11
108
```

### 输出

```
9
```

# 题解

## 作者：StoneXie (赞：74)

极简代码
```cpp
#include<cstdio>
#include<iostream>
char s[1010];
long long ans,n;//long long 保险 
int main(){
    scanf("%lld%s",&n,s);
    for(int i=0;s[i];i++) ans=(ans*10+s[i]-'0')%n;//边读取 边计算 
    printf("%lld",ans ? ans:n);//ans==0输出n 
}
```

---

## 作者：浅色调 (赞：40)

###Python练手题###

**思路：**直接高精度取模，注意特判一下余数是否为0，就OK了。我这里用的是简单的Python，当练习语法。

**代码：**

```cpp
x=int(input())
y=int(input())
if (y%x==0) :
            print(x)
else: print(y%x)
```

---

## 作者：z3475 (赞：22)

原本一开始以为要上高精,想了一下n进制m的个位就是答案

无奈代码复杂度太高,瞟了一下标签,普及+,同余....

马上想到了读入优化的黑科技

思路楼下讲的很清楚了

1268 mod n=(((1%n\*10+2)%n\*10+6)%n\*10+8)%n

用通俗的话说可以一边读一边模n

然后代码就是读入优化的模板加模然后判断0的特殊点了

好像代码最短?

```cpp
#include <bits/stdc++.h>
typedef long long ll;

using namespace std;
int readd(ll n){
    char l=getchar();ll u=0;
    while (!(l>='0'&&l<='9')) l=getchar();
    while ((l>='0'&&l<='9')) u=(u*10+l-'0')%n,l=getchar();//膜一下
    return u?u:n;//等价u与if (u!=0) return u;else return n;
}
int main (int argc, char const* argv[])
{    
    ll n,m;//m%n 0=n //2<=n<=10^8，2<=m<=10^1000
    scanf("%lld",&n);
    cout << readd(n);
}
```
思路知道了就很简单了


---

## 作者：zyg20010121 (赞：15)

相信这道题很多人写的代码很长，实际上运用同余定理很轻松。

举例说明：123%11=（100%11+20%11+3%11）%11=（（1%11\*10+2）%11\*10+3）%11

```cpp
[color=red]
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
string m;
int a[1010]={0};
int main()
{
    int n;
    cin>>n;
    cin>>m;
    for(int i=0;i<m.size();i++)
        a[i]=m[i]-'0';
    long long ans=0;
    for(int i=0;i<m.size();i++)
        ans=(ans*10+a[i])%n;//公式运用在这里
    if(ans==0) cout<<n<<endl;
    else cout<<ans<<endl;
    return 0;
}
[/color][codec ]
```

---

## 作者：Well_whz (赞：10)

这道题就是高精度除以低精度取余，有许多种方案，下面列举了两种：

方案一：

```cpp
var
  i,n,x:longint;
  a:array[1..100000]of shortint;                                 //开大一点以免爆掉
  s:ansistring;                                                             //同上
begin
  readln(n);                                                                //输入低精度的数
  readln(s);                                                                //输入高精度的数
  for i:=1 to length(s) do a[i]:=ord(s[i])-ord('0');         //把字符串转化成数组
  for i:=1 to length(s)do x:=(x*10+a[i]) mod n;         //这是程序核心部分，一直到最后一位
  if x=0 then  write(n) else  write(x);                         //判断余数是否等于零，如果等于零就输出盒子的个数
end.
```
第二种方案其实是第一种方案的优化，程序如下：
```cpp
var
  i,n,x,k:longint;                                                       //i是循环变量，n是低精度的那个数，x用于存放余数，k是当前一位
  s:anistring;                                                           //开大一点
begin
  readln(n);
  readln(s);                                                             //输入
  for i:=1 to length(s) do 
    begin
       k:=ord(s[i])-ord('0');
      x:=(x*10+k) mod n;
    end;                                                                  //程序核心
  if x=0 then  write(n) else  write(x);                       //判断特殊情况
end.
这就是两个程序，核心部分都相同，核心如下：x:=(x*10+k) mod n;
```

---

## 作者：Mr_WA的大号 (赞：8)

代码千万条，AC第一条，小学生又来发题解了！

题目：P2818

难度：★★★

算法：字符串

## 开课了！

天使的起誓这一道题目，首先分析数据，n是可以直接定义int类型的，但是m是不行的（m<=10^1000你还想用int、long long、unsigned long long）。

所以，我们要用新算法，也就是

### 高精

的好基友

## 字符串

怎么做呢？

首先，用一个int类型的变量ans，来存储数字。

然后，逐位取数求余。

最后输出就行了。

切记：m要用字符串定义。

课讲完了，上代码

```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
using namespace std;
int n,ans;//定义
string m;
int main()
{
	cin>>n>>m;//输入
	for(int i=0; i<m.size(); i++)
		ans=(ans*10+m[i]-48)%n;//逐位取数求余
	if(ans==0)cout<<n;//特判
	else cout<<ans;//输出
	return 0;
}
```
祝愿大家能AC！

---

## 作者：whc2020 (赞：5)

题意：输出（m - 1） % n + 1 的值。

需要注意的坑：

1.数据范围，m<=1e1000，所以只使用long long会爆，需要使用高精度。

2.事实上不必打一遍高精度除法的代码，（~~险些被坑~~）这道题仅仅是求其最终的余数，且最终的余数在int范围内，因而可以采用一位一位取，一位一位模的方法。

3.注意余数为0的时候，这是需要特判，不然只有60分。

更多需要注意的细节在代码里:

```cpp
#include<bits/stdc++.h>
using namespace std;

int n , x , ans;//看不少大佬都用了long long，但实际上不用，因为余数最大也不过是1e8 
string m;

int main() {
	cin >> n >> m;//这里采用了string，因而不能使用scanf，也可以这么写{cin >> n ; getline (cin , m) ; getline (cin , m);} 
	for (int i = 0 ; i < m.length() ; i++) {//string的特性，s[s.length()]是换行符，不用取过来。 
		x = m[i] - '0';
		ans = (ans * 10 + x - 1) % n + 1;//注意先-1再+1，特判，等同于{ans = ans * 10 % n; if (! ans) ans += n;} 
	}
	printf ("%d" , ans);
	return 0;
}
```


---

## 作者：「已注销」 (赞：3)

为什么要开数组？

因为$x\equiv x\bmod m\pmod m$

边读边算即可

```cpp
#include<cctype>
#include<cstdio>
using namespace std;
int n,ans=0;
char c;
int main(){
	scanf("%d\n",&n);
	while(isdigit(c=getchar()))ans=(ans*10+c-'0')%n;
	printf("%d",ans?ans:n);
}
```

---

## 作者：我没有小白 (赞：3)

高精度算法。。。emmm看数据范围也能看出来。
这道题高精度除法里搞一点事情，就出来了。
就是把求商变成求余数。
千万别忘了，当余数为0时，答案就是最后一个。
说多了没用，直接代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000000;
int a[N],b;
char c[N];
int ans[N];
int la,tot=0;
void read()
{
	scanf("%d%s",&b,&c);
	la=strlen(c);
	for(int i=0; i<la; i++)a[i+1]=c[i]-'0';
}
void work()
{
	int x=0;
	for(int i=1; i<la; i++)
	{
		ans[i]=a[i]/b;
		x=a[i]%b;
		a[i+1]+=x*10;
	}
	//
	int t=a[la]%b;
	if(t==0)cout<<b;
	else cout<<t;//这两个“//”之间是当求的数为最后一个数时，用来求余数，so简单 
}
int main()
{
	while(1); 
	read();
	work();
}
```

---

## 作者：Thinking (赞：3)

既然没有pascal，那就发一个哈~~~

首先，转圈肯定是mod。

而且对于数x，x mod n=((x div 10 mod n)+x mod 10 mod n) mod n。

那么就可以按位处理了。

代码（谢绝copy）

```pascal
var
  n,t:longint;
  c:char;
begin
  read(n);
  read(c);
  while (c<'0') or (c>'9') do read(c);  //讨论区里说输入和样例不一样，那就鲁棒一下
  t:=(ord(c)-48) mod n;
  while not eoln do begin
    read(c);
    t:=(t*10+ord(c)-48) mod n
  end;  //按位算
  if t=0 then write(n)  //判断0的情况
  else write(t)
end.
```

---

## 作者：aricept (赞：2)

c++代码如下(下面有pas：

	#include<iostream>
	#include<cmath>
	using namespace std;
	int a,n,x;
	char ch;
	int main()
	{
		cin>>n;
		while(cin>>ch)
		{
			a=ch-'0';
			x=(x*10+a)%n;
		}
		if(x==0)cout<<n;
		else cout<<x;

	}
    
 
   注意这题的“字符串长度”是2<=m<=10^1000，它的意思就是“你不能按规范的高精度处理，必须读一个字符，算一个”，也就是高精除低精，不能先转成逆序的int数组。当然，它也方便你输出，不需要你输出商（其实输出也无妨，因为前导0不会输出）。
   
   参考pascal代码:
   
	var
	a,n,x:longint;
	ch:char;
	begin
 	 readln(n);//读除数
 	 x:=0;
  	while not eoln do
      begin
          read(ch);
          a:=ord(ch)-ord('0');// char 转换成数字;
            x:=(x*10+a) mod n;// (x*10+a)%n;
        end;
  	if x=0 then writeln(n) else writeln(x);//不明白话，就去将样例手工计一计；
	end.


---

## 作者：Motbloveut221 (赞：1)

（本蒟蒻第一篇题解，不喜勿喷哈）

[更好的阅读体验](https://www.luogu.com.cn/blog/lililalalololulu/solution-p2818)

作为一名c++的忠实爱好者

我也是会Python的！

我本来想偷懒直接用Python~~第一遍就是用Python做的~~
```python
x = input(" ")
y = input(" ")
print x%y
```
perfect！

咳咳，咳咳，咳咳咳咳咳咳咳咳咳。。。

一向喜欢challenge的我怎么可能就这么完了

来！上c++！

```cpp
#include<iostream>
#include<string>
using namespace std;
int main(){
	int n;
    string m;
    cin >> n >> m;
    int r = 0;
    for(int i=0;i<m.length();i+)
    {
        r = (r*10+m[i]-'0')%n;
    }
    int answer = (r!=0)?r:n;
    cout << answer;
    return 0;
}
```
### 整个代码，最最最最核心的部分莫过于第11行
这里r指的是余数

其实并不是我们最终的结果

m是高精度数（就是要用高精度做咋地）

比如说m=56，n=3

请看：

```
56%3
5%3 = 2
56%3 = （5*10+6）%3 = （（5%3）*10+6）%3 = 2
```
这里使用到了“余数的和=和的余数”以及“余数的积=积的余数”

你要是认为大一点的数做不了，我们来看看：

```
47483%4
4%4=0
47%4=(4*10+7)%4=0*2+3=3
474%4=(47*10+4)%4=(3*2+0)%4=2
4748%4=(474*10+8)%4=((474%4)*(10%4)+(8%4))=(2*2+0)%4=4%4=0
47483%4=(4748*10+3)%4=(0*2+3)=3
```
看一下4的整除特征

看后两位除4的余数

47483的后两位是83

83%4=3

解法是有效的

##我是"刀锋上的人"

---

## 作者：Happy_Dream (赞：1)


 
 今天刷的这道题看起来挺水实际却不简单
 
 先说一下20分代码吧，只要看懂题这20分就是白送的：
 ***
 ```cpp
 #include <iostream>//头文件
using namespace std;
int main()
{
	long long int x,y;//定义
	cin>>x>>y;
	if(y%x==0)//审题
	cout<<x;
	else
	cout<<y%x;输出
	return 0;
} 
```
***
但是20分不足以满足我的要求，于是就开始思考以为要高精（~~吓死本人了~~），后来发现了一个规律，以二位数举例
一个二位数%另一个数就是先把这个数的十位*10%哪一个模数，加上个位数%哪一个模数再把和模哪一个模数。比如说，

59%5=(5x10%5+9%5)%5=(0+4)%5=4%5=4

这个规律显然对三位数以及更大的数也好用，于是就得到了代码：
***
```cpp
#include <bits/stdc++.h>//万能头文件
#define For for(int i=0;i<la;i++)//省一点长度（其实没啥意义）
using namespace std;//常规
int s[1010]={0};//清不清零都无所谓
int main()//主函数
{
	string a;//用字符串读入
	long r;//定义模数
	cin>>r>>a;//输入
	short la=a.length();//在前面定义可以省时间
	long long ans=0;//一定要清零！！！
	For
	s[i]=a[i]-'0';//把字符转化为数，并存入数组
	For
	ans=(ans*10+s[i])%r;//把前面计算的公式引进来
	if(!ans)//注意审题（只要审了，就知道要怎么做）
	cout<<r;
	else
	cout<<ans;//直接输出即可
	return 0;//华华丽丽的结束
} 
```
***
希望对你有帮助,但切勿抄袭！


---

## 作者：BookofDeath (赞：1)

二话甭说，先上代码
依题意，可知，此题是求余数；
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
	using namespace std;
	const int mmax=1e4+5;

	void getNum(int num[])//首地址； void 
	{
		char temp[mmax];
		cin>>temp;
		memset(num,0,sizeof(int)*mmax);
		num[0]=strlen(temp);
		for(int i=1;i<=num[0];i++)
		{
			num[i]=temp[num[0]-i]-'0';
		}
		return;
	}

	void printNum(int X[])
	{
		for(int i=X[0];i>=1;i--)
		printf("%d",X[i]);
		return;
	}
		
	void chuDi(int A[],int B,int C[],int &yushu)
	{
		int i,t;
		for(i=A[0],t=0;i>=1;i--)
		{
			t=t*10+A[i];
			C[i]=t/B;
			t%=B;
		}
		yushu=t;
		i=A[0];
		while(C[i]==0&&i>1)
		i--;
		C[0]==i;
		return;
		}
		
	int main()
	{
		int num1[mmax],shang[mmax],num2,yushu;
		cin>>num2;
		getNum(num1);
		chuDi(num1,num2,shang,yushu);
		if(yushu==0)
		{
			cout<<num2;
			return 0;
		}
		cout<<yushu; 
		return 0;
	} 
```
秒A无悬念，啦啦啦啦啦

---

## 作者：fzj2007 (赞：0)

诶呀，为什么有这么多人写高精度啊，~~手不累吗~~。。下面我们说一下这道题。

## 第一步 读题

简化题意，就是：

>给定 $n$ 和 $m$ ，请你输出 $\begin{cases}m \bmod n&n\nmid m\\n&n\mid m\end{cases}$

相信大家读完题以后就能想出来。那个整除的边界大家应该仔细想一下。

## 第二步 思路

由于我们发现 $m \le 10^{1000}$，所以有以下思路：

- 高精度，显然不是正解，但是也能过，你非要这么写我也不拦着。。

- 同余方程化简。

现在我们先把整除的情况放一边，看不整除的情况。由于我们有当 $k\times n \lt m$ 时 $m \bmod n \equiv (m-k\times n) \bmod n\pmod{m}$，而且我们是先读入 $n$ 的，我们就有一个想法：手写读入，然后边读入边取模，我们发现 $n \le 10^8$，用`int`显然能存的下。（手写读入的时候最多更多一位，也就是最多乘 $9$）。那我们就无须去写那么麻烦的高精度了~

## 第三步 代码

由于代码中的快读快写是最高级优化，代码较长，所以建议只看函数`readm()`读入和超级短的主函数。

```cpp
#include<bits/stdc++.h>//万能头
using namespace std; //这一串我不说了
using std::cin;
using std::cout;
using std::endl;
int n,m;//声明变量，int即可，不放心可以用long long
namespace IN{//读入优化
    const int MAX_INPUT = 1000000;
    //这里是fread优化
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,MAX_INPUT),p1==p2)?EOF:*p1++)
    char buf[MAX_INPUT],*p1,*p2;
    template<typename T>inline bool read(T &x) {//这里可以跳过，直接看下一个函数
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
        	ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T>inline bool readm(T &x) {//重点部分
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;//初始值
        register int flag=false;//声明，读入需要
        register char ch=getc();//读一个字符
        while(!isdigit(ch))//筛去没用的
        	ch=getc();//重新读入
        if(isdigit(ch)) x=(x*10+ch-'0')%n,ch=getc(),flag=true;//如果存在有意义字符，那就要记录一下，方便下一次读入。（如果不是我这种格式可以不记录）
        while(isdigit(ch)){//循环，直到没有有意义字符
            x=(x*10+ch-48)%n;//这里是加上这一次读入的字符，记得取模
            ch=getc();
        }
        x=x?x:n;//如果x为0的时候，也就是整除，那应该是n，可以仔细看一下题目。
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {//这是我说的为什么要记录。。
       return read(a)&&read(args...);
    }
    #undef getc
}

namespace OUT{//快写不讲了
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
    	for(register int i=0;i<s.length();i++) putc(s[i]);
	}
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);put(ch,args...);
    }
}
using namespace IN;//方便使用
using namespace OUT;

int main(int argc, char const *argv[]){
    std::ios::sync_with_stdio(false);//取消一堆同步流
    cin.tie(NULL);
    cout.tie(NULL);
    read(n),readm(m);//读入，别忘了分别读入。
    put(m);//直接输出，因为读入的时候已经处理好了~
    return 0;下次见
}
```

### 第四步 其他

- 撰文不易，大佬勿喷！
- 文章若有`bug`请私信作者，感激不尽！
- 如果有帮助，请帮忙点下赞，感谢！

---

## 作者：liaokq (赞：0)

这一题一看就是用高精

**But**

本机房的[大佬](https://www.luogu.com.cn/user/19172)告诉我们一个不用高精的方法：

利用快读的原理，边读边取余，最后输出结果。

直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long n,i,ans;
char a;
int main()
{	
	cin>>n;
	while(cin>>a)ans=(ans*10+a-'0')%n;//一位一位取余运算
	if(ans==0)cout<<n<<endl;
	  else cout<<ans<<endl;
 } 
```

---

## 作者：ars4me (赞：0)

这是我同学的做法 不是我自己的

只需要在读入优化上动点手脚 读入m的时候边读入边%一下n 就ok了

然后就是如果最后m是0就输出n

请看代码


    
    
        
        
        
        

        
        
        
        

        
        
        

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
    using namespace std;
    #define in1 = read1()
    #define in2 = read2()
    typedef long long ll;
        ll n,m;
inline ll read1(){
        ll num = 0 ,f = 1;    char ch = getchar();
        while (!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while (isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
inline ll read2(){
        ll num = 0 ,f = 1;    char ch = getchar();
        while (!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while (isdigit(ch)){
                num = num*10 + ch - '0';
                num %= n;                         //没错两个读入优化的区别就是加了这一句 一句。。
                ch = getchar();
        }
        return num*f;
}
int main(){
        n in1;   m in2;
        ll ans = 0;
        if(m == 0)    ans = n;
        else    ans = m;
        printf("%d",ans);
}
校内考试的时候用的题。伟大的同学和可怜的我
```

---

## 作者：wzh1120 (赞：0)

这题就是高精度除单精度。只不过是变成求余数而已。但要注意，如果余数为0.那么就是最后一个宝盒。比如 n==9,m == 9，这个时候 m%n == 0，天使应该选择第9个宝盒。

x = (x \* 10+a[i]) % n;

这就是模拟笔算除法的情况，如下：

```cpp
#include <cstdio>  
#include <string>  
#include <iostream>  
using namespace std;  
int n,m[2000];  
void input_data()  
{  
    scanf("%d",&n); //输入n和高精度数字m  
    string ss;  
    cin >> ss;  
    m[0] = ss.size();  
    for (int i = 1;i <= m[0];i++) //不用倒叙存储  
        m[i] = ss[i-1] - '0';  
}  
  void get_ans()  
{  
    int x = 0;  
    for (int i = 1;i <= m[0];i++) //模拟笔算除法的情况  
        x= (x*10 + m[i])% n;  
    if (x == 0)//如果余数为0 则选择最后一个宝盒  
        x = n;  
    printf("%d\n",x);  
}  
  int main()  
{  
    input_data();  
    get_ans();  
    return 0;     
}
```

---

## 作者：半云_ (赞：0)

直接高精，，高精度除以单精度  代码奉上




    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<math.h>
using namespace std;
char x[1100];
int a[1100],b[1100];
int v;
int aox,u=0;          //u为余数
int main(){
    freopen("YUBIKILI.in","r",stdin);
    freopen("YUBIKILI.out","w",stdout);
    cin>>v;
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    cin>>x;
    aox=strlen(x);
    for (int i=0;i<=aox-1;i++)
        a[i+1]=x[i]-48;
    for (int i=1;i<=aox;i++){          //按位相除
        b[i]=(u*10+a[i])/v;
        u=(u*10+a[i])%v;
    }
    int h=1;
    while (b[h]==0 && h<aox){    //删去前边的0
         h++;
    }
    if (u==0){
        cout<<v;            //注意 余数为0的时候
    }
    else cout<<u;
    return 0;    
}
```

---

## 作者：doby (赞：0)

找了一个高精模……反正这题就是高精模……

输出需要特判……

高精系列经典原题啊……

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int la,lb,lc,a[10001],b[10001],c[10001],tmp[10001],i,x,j,d;
string t,s1,s2;
void print(int a[])
{
    if(a[0]==0){cout<<s2;return;}//整除 
    for(int i=a[0];i>0;i--){cout<<a[i];}return;//输出余数
}
int compare(int a[],int b[])  //比大小
{
    if(a[0]>b[0]){return 1;}if(a[0]<b[0]){return -1;}
    for(int i=a[0];i>0;i--){if(a[i]>b[i]){return 1;}if(a[i]<b[i]){return -1;}}return 0;
}
void numcpy(int p[],int q[],int det){for(int i=1;i<=p[0];i++){q[i+det-1]=p[i];}q[0]=p[0]+det-1;}
void jian(int a[],int b[])//减法
{ 
    int flag=compare(a,b),i;
    if(flag==0){a[0]=0;return;}
    if(flag==1)
    {
        for(i=1;i<=a[0];i++){if(a[i]<b[i]){a[i+1]--,a[i]=a[i]+10;}a[i]=a[i]-b[i];}
        while(a[0]>0&&a[a[0]]==0){a[0]--;}return;
    }
}
void chugao(int a[],int b[],int c[])//算位数后提取相减
{
    c[0]=a[0]-b[0]+1;
    for(int i=c[0];i>0;i--)
    {
        memset(tmp,0,sizeof(tmp));numcpy(b,tmp,i);
        while(compare(a,tmp)>=0){c[i]++;jian(a,tmp);}
    }
    while(c[0]>0&&c[c[0]]==0){c[0]--;}
    return;
}
void adib(string a1,string b1)//高精除
{
    memset(a,0,sizeof(a));memset(b,0,sizeof(b));memset(c,0,sizeof(c));
    a[0]=a1.size();for(i=1;i<=a[0];i++){a[i]=a1[a[0]-i]-'0';}
    b[0]=b1.size();for(i=1;i<=b[0];i++){b[i]=b1[b[0]-i]-'0';}
    chugao(a,b,c);print(a);return;
}
int main()
{
    cin>>s2>>s1;
    if(s1==s2){cout<<s1;return 0;}//相等时特判
    adib(s1,s2);
}
```

---


# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# 题解

## 作者：Unordered_OIer (赞：40)

# P7107 题解

## 题意
构造两个长度为 $n$ 的数列 $x$ 和 $y$ ，使得：  
- $\forall\ 1 \leq i \leq n,x_i+y_i=k$
- $\sum\limits_{i=1}^nx_i=k$
- 一共有且仅有 $p$ 个 $j$ 使得 $x_j=\max\limits_{i=1}^nx_i$

## 题解
先记 $\max\limits_{i=1}^nx_i=q$

首先，我们先考虑**满足一共有 $p$ 个 $j$ 使得** $x_j=\max\limits_{i=1}^nx_i$ 这个条件，由于一共最多只能有 $p$ 个这样的最大值，于是我们可以得到这个最大值 $q \leq \min(m,k/p)$ ，再取大，就会导致 $pq>k$ ，不满足题意。

为了简化操作，我们直接让 $q=\min(m,k/p)$ 。

于是我们先让 $x_{1 \sim p}=q,y_{1 \sim p}=m-q$ 。

然后，我们定义 $rest=k-pq$ ，表示剩余有标记的纸团的个数，又要保证 $\max\limits_{i=p+1}^nx_i<q$ ，所以我们考虑在一定有解且 $rest>0$ 的情况下，剩下的 $x_i$ 取 $q-1$ 最合适。

当第 $h$ 个人取 $q-1$ 时， $rest-(q-1)<0$ ，那么直接把剩下所有的 $rest$ 都给这个 $h$ ，至此，所有有记号的纸条都已经分发完毕。

于是剩下的就直接取 $x_i=0$ ，即 $\forall\ h <i \leq n,x_i=0,y_i=m$ 。

至此，数列 $x$ 和 $y$ 就构造完毕了，而且复杂度也是 $\mathcal O(n)$ 的。

**以上仅为有解情况，还需要考虑无解情况。**

无解情况就是 $p$ 个 $q$ 分配完后所剩余的 $rest$ 分配给剩下的 $n-p$ 个人每人 $q-1$ 后仍有剩余，则我们是找不到这样的 $q$ 的。

用式子表示即为 $k-pq>(n-p)(q-1)$ 。

总的复杂度为 $\mathcal O(n)$ ，可以 $\colorbox{#52C41A}{\color{white}AC}$ 。

## Code
代码因为加了注释比较长，文末有更简洁的代码。
```cpp

// namespace Solution
const ll N = 100005;
ll x[N], y[N];

void check() {  // check
	ll sum = 0, cnt = 0;
	bool flag = 1;

	for (ll i = 1; i <= n; i++)
		sum += x[i], flag &= ((x[i] + y[i]) == m && (x[i] >= 0 && y[i] >= 0)), cnt += (x[i] == q);  // recount
	if (sum != k || !flag || cnt != p) {   // review
		puts("NO");
		exit(0);
	}
}

int main() {
	ll n = read(), m = read(), k = read(), p = read();   //   read
	ll q = min(m, k / p);    //   最大值

	if (k - q * p > (n - p) * (q - 1))    //    如果 分配完所有最大值 后 剩余的数分配给剩余的人 每个人 q-1 仍会有剩余
		return puts("NO"), 0;    //  无解

//  Case 1 - p max 
	for (ll i = 1; i <= p; i++)     //  这些 xi 都取最大值
		x[i] = q, y[i] = m - q;

//  Case 2 - n-p less
	bool fflag = 1;   //     用于记录是否剩余还可以分出 q-1
	ll rest = k - q * p;    //   rest 记录剩余的个数

	for (ll i = p + 1; i <= n; i++) {

		// Subcase 1 - q-1 ok
		if (fflag == true && rest >= q - 1)   //  judge
			x[i] = q - 1, rest -= q - 1;   //  赋值，且剩余减去 q-1

		// Subcase 2 - rest == 0 too little
		else if (rest <= 0)  // judge
			x[i] = 0;   //  0

		// Subcase 3 - still have , but not enough
		else
			x[i] = rest, rest = 0, fflag = 0;  //  get all the rest

		y[i] = m - x[i];   // set y
	}

// namespace Output
	puts("YES");

//	check();

	for (ll i = 1; i <= n; i++)
		write(x[i]), putchar(' '), write_endl(y[i]);  // output

	return 0;
}
```

更简洁一点的代码：

```cpp
	ll n=read(),m=read(),k=read(),p=read();
	ll q=min(m,k/p);
	if(k-q*p>(n-p)*(q-1))return puts("NO"),0;
	for(ll i=1;i<=p;i++)x[i]=q,y[i]=m-q;
	bool ff=1;
	ll rs=k-q*p;
	for(ll i=p+1;i<=n;i++){
		if(ff==true&&rs>=q-1)x[i]=q-1,rs-=q-1;
		else if(rs==0)x[i]=0;
		else x[i]=rs,rs=0,ff=0;
		y[i]=m-x[i];
	}
	puts("YES");
	for(ll i=1;i<=n;i++)write(x[i]),putchar(' '),write_endl(y[i]);
```

## 后记
个人觉得算是半道模拟题

最后，祝洛谷月赛越办越好!  
完结撒花~顺便求赞![](https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/qq/%E5%8F%AF%E6%80%9C.gif)

---

## 作者：HanPi (赞：14)

### 题目大意:

有 $n$ 个人,每人有 $m$ 张纸条,其中 $k$ 张被打了标记,请构造一种记号分布使得**恰好**有 $p$ 个人拿到最多的记号.

~~用了一种比较奇怪的思路~~

### 思路:

我们可以把纸条的分布看成下图:

![](https://cdn.luogu.com.cn/upload/image_hosting/z76bdx7k.png)

既然要使恰好有 $p$ 个人拿到最多,那么我们先将所有带有记号的纸条都分给这 $p$ 个人.(如果每个人分到的大于 $m$ 则只分 $m$ 张)

这些人每个人的带标记数 $hp=\min(k \div p,m)$ .

占用的总数就是: $s=hp \times p$ ,剩下的为 $k-s$ .

对于剩下的纸条我们首先平均分配,
剩余的每人会得到 $h=(k-s)\div(n-p)$ 张纸条.
多出 $mod=(k-s)\%(n-p)$ 张.

因为 $mod$ 是取余得到的,所以可以保证 $mod<n-p$ 即这 $mod$ 个人每人只会多 $each=\begin{cases} 0 & mod=0\\1 & mod>0\end{cases}$ 张.

如果 $h+each>=hp$ 就表明即使我使那 $p$ 个人拿到了最多的纸条,剩下仍然会y有人拿到更多(相等)的纸条,即无解.

另外,当 $n=p$ 时,需要特殊判断:

- 既然 $n=p$ 并且要使恰好有 $p$ 个人拿到最多,则 $k$ 张带标记的纸条一定是被均匀分配给这 $p$ 个人.
也就是说: 当 $n\%p\ne0$ 时是无解的,否则就输出 $p$ 个 $k \div p\quad m-(k \div p)$ .

那么最终答案就应该是:

$p$ 个 $\boxed{hp \quad m-hp}$

$mod$ 个 $\boxed{h+each \quad m-(h+each)}$

$(n-p)-mod$ 个 $\boxed{h \quad m-h}$

$\huge\tt{Code:}$
```c
#include <stdio.h>
long long n,m,k,p;
long long other,s,a,hp,h,mod,each;
long long other2;
int i;
long long mymin(long long vala,long long valb){return vala<valb?vala:valb;}
int main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&k,&p);
    other=n-p;
    if(!other)
    {
        if(k%p!=0)
        {
            puts("NO");
            return 0;
        }
        puts("YES");
        a=k/p;
        for(i=0;i<n;++i)printf("%lld %lld\n",a,m-a);
        return 0;
    }
    hp=mymin(k/p,m);
    s=hp*p;
    a=k-s;
    h=a/other;
    mod=a%other;
    if(mod)each=(mod+other)/other;
    other2=other-mod;
    if(hp<=h||hp<=h+each)
    {
        puts("NO");
        return 0;
    }
    puts("YES");
    for(i=0;i<p;++i)printf("%lld %lld\n",hp,m-hp);
    for(i=0;i<mod;++i)printf("%lld %lld\n",h+each,m-h-each);
    for(i=0;i<other2;++i)printf("%lld %lld\n",h,m-h);
    return 0;
}
```



---

## 作者：Maxmilite (赞：8)

## Solution

按照题面要求，在 $m$ 个人中恰好有 $p$ 个人抽到的带记号纸团数相同且最多。

所以我们不妨小小贪心一下**直接让他们往多里拿，能拿多少拿多少**

#### 正确性证明

~~其实非常简单，你拿的多了那么剩下的人拿的就少了，你自然拿到的就更多~~

我们不妨先假设他们每个人都拿了 $damedane$ 个带记号的纸团罢

` int damedane; `

那么 $damedane$ 需要满足什么条件呢？

1. 你不能从四维空间里拿出带记号纸团来，所以所有 $p$ 个人一共只能拿不大于 $k$ 个带记号纸团：$damedane \times p <= k$
2. 俗话讲不能吃不该吃的东西，所以每个人只能拿至多 $m$ 个纸团：$damedane <= m$

所以最大值要怎么取呢？

$damedane = min (k \div p , m)$

即 ` damedane = k / p > m ? m : k / p; `

既然这 $p$ 个人每个人都拿了最多的纸团了，那么我们就开始验证罢。

什么条件下这种情况就成立了呢？

1. 剩下的在尽可能多的情况下每个人都比这 $p$ 个人拿的少

对就一条。

那么怎么让剩下的每个人都比这 $p$ 个人拿的少的情况下都拿尽可能多呢？

我们不妨先假设他们每个人都拿了 $dameyo$ 个带记号的纸团罢

` int dameyo; `

怎么样最少？

每个剩下的都拿 $(damedame - 1)$ 个，直到拿完为止。

#### 正确性证明

~~其实更简单，你拿的少了同类兄弟要分摊的就多了，所以你要尽可能多拿~~

然后我们就可以算 $dameyo$ 了

对 $dameyo$ ，我们可以通过以下方式计算：

对前 $\frac{(k - damedane \times p)}{damedane - 1}$ 个，每个人拿 $damedane - 1$ 个

如果有多余的话，再来一个兜底

剩下的不拿

然后我们判断下所有 $n - p$ 个人拿完以后剩没剩下就可以了

怎么判断呢？

判断$\frac{(k - damedane \times p)}{damedane - 1}$ ( 可能 + 1 ) 个人有没有超过 $n - p$ 就可以了

### 特判1

_" 如果有多余的话，再来一个兜底 "_

其实这个多余的就是判断下 $\frac{(k - damedane \times p)}{damedane - 1}$ 有没有余数就可以了

_" 可能 + 1 "_

### 特判2

一种情况是 $n = p$ ，所以如果按照上面的式子来算 $dameyo$ 的话就会很悲惨的

**$Segmention \ Fault$**

(除数为0)

所以加个特判就好了

(这俩特判搞了我一个半小时)

## AC Code ( C Language )
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
long long n, m, k, p, t, tot, tmp;
int main()
{
    scanf("%lld%lld%lld%lld", &n, &m, &k, &p);
    tot = k;
    t = k / p > m ? m : k / p;
    tot -= t * p;
    if (n == p)
    {
        if (t * p == k)
        {
            printf("YES\n");
            for (int i = 1; i <= n; ++i)
                printf("%lld %lld\n", t, m - t);
        }
        else
            printf("NO\n");
    }
    else
    {

        if ((n - p) * (t - 1) < tot)
            printf("NO\n");
        else
        {
            printf("YES\n");
            for (int i = 1; i <= p; ++i)
                printf("%lld %lld\n", t, m - t);
            for (int i = p + 1; i <= n; ++i)
            {
                if (tot < (t - 1))
                    printf("%lld %lld\n", tot, m - tot);
                else
                    printf("%lld %lld\n", t - 1, m - t + 1);
                tot -= t - 1;
                if (tot < 0)
                    tot = 0;
            }
        }
    }
    return 0;
}
```

---

## 作者：Meaninglessness (赞：3)

暴力判断题。

因为有 $p$ 个人纸条数量同时最多,所以这 $p$ 个人每人有记号纸条数量最多为:

$$min(m,\lfloor \frac{k}{p} \rfloor)$$

然后我们再判断剩下每人分配的数量是否可以小于这个数。

都小于即为一种合理方案,否则就没有合理方案。


注意数据范围:$p\le n$,$p=n$时不就暴毙了吗

于是加入特判代码,AC。

```cpp
#include <iostream>
#define ios std::ios::sync_with_stdio(0)
using namespace std;
const int MAXN = 1e5+5;
long long n,m,k,p,x[MAXN];


bool check()
{
//	  more  :p个人每个人分得最多的带标记纸条。
//	another :剩下(n-p)个人总共的带标记纸条数量。
	long long more=min(m,k/p),another=k-more*p;
	if(n==p)
	{
		if(another!=0)
			return false;
		else
		{
			for(int i=1;i<=n;i++) x[i]=more;
			return true;
		}
	}
//    less  :剩下(n-p)个人每人分得的带标记纸条。(可能会有剩余) 
	long long less=another/(n-p);
	if(more>less)
	{
//		前p个人 :more 
		for(int i=1;i<=p;i++) x[i]=more; 
//      后(n-p)个人 :考虑每人分得less张带标记纸条后是否有剩余,记为rest。 
		long long rest=another-less*(n-p);
		for(int i=p+1;i<=n;i++) 
		{
			x[i]=less;
//			如果有更多的剩余标记纸条,我们用贪心思想,让他们的纸条数量到达more-1。 
			if(rest>=(more-1)-less)
			{
				rest-=(more-1)-less;
				x[i]=more-1;
			}
//			否则,把这些剩余纸条全都给当前的人。 
			else 
			{
				x[i]+=rest;
				rest=0;
			}
		}
//		如果这些纸条还未发完,说明方案不成功,返回false。 
		if(rest>0)
			return false;
		return true;
	}
	else
		return false;
}

int main()
{
	ios;
	cin>>n>>m>>k>>p;
	if(check())
	{ 
		cout<<"YES"<<endl;
		for(int i=1;i<=n;i++)
			cout<<x[i]<<" "<<m-x[i]<<endl;
	} 
	else
		cout<<"NO"<<endl;
	return 0;
}

```

最后,赠送一些比赛时自己手推的[hack数据](https://www.luogu.com.cn/paste/9kora5oq)


---

## 作者：小蒟蒻皮皮鱼 (赞：2)

T2

一道有趣的构造题。

不难发现想要判断是否有这样的 $p$ 个人满足条件，还缺少最多记号的数量。

设这个数量为 $t$ ，则对于总共的 $k$ 个记号来说，记录一个 $cnt$ 表示当前已经有几个人抽到了恰好 $t$ 个记号。按照贪心的思想，当 $cnt < p$ 并且剩下的记号个数可以再选一组时，如果要满足要求，一定是要再拿出 $t$ 个记号来的。如果 $cnt=p$ ，则已经满足了条件，我们要做的就是尽可能让剩下的记号被分完，最优策略显然是每次分 $t - 1$ 个，看看最后能不能分完。

对于这个数量 $t$ ，只需要二分就可以了。如果分完 $k$ 个记号后的 $cnt <  p$ ，说明当前的数量过小。如果分到最后还有剩余，说明当前的数量过大。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read()
{
	ll ans = 0;
	char c = getchar(), last = ' ';
	while(c < '0' || c > '9') last = c, c = getchar();
	while(c >= '0' && c <= '9') ans = (ans << 1) + (ans << 3) + c - '0', c = getchar();
	if(last == '-') ans = -ans;
	return ans;
}
const int N = 100005;
ll n, m, k, p;
ll a[N], b[N];
int check(ll mid)
{
	ll k1 = k, cnt = 0;
	for(int i = 1; i <= n; i ++)
	{
		if(k1 >= mid && cnt < p) 
		{
			k1 -= mid;
			a[i] = mid;
			b[i] = m - a[i];
			cnt ++;
		}
		else if(k1 >= mid - 1 && cnt >= p)
		{
			k1 -= mid - 1;
			a[i] = mid - 1;
			b[i] = m - a[i];
		}
		else if(k1 < mid - 1)
		{
			
			a[i] = k1;
			k1 -= k1;
			b[i] = m - a[i];
		}
	}
	if(cnt < p) return 0;
	else if(k1 > 0) return 1;
	return 2;
}
int main()
{
	n = read(), m = read(), k = read(), p = read();
	ll t = k / p;
	t = min(t, m);
	ll l = 0, r = t;
	while(l <= t)
	{
		ll mid = l + r >> 1;
		int flag = check(mid);
		if(flag == 2)
		{
			printf("YES\n");
			for(int i = 1; i <= n; i ++)
			{
				printf("%lld %lld\n", a[i], b[i]);
			}
			return 0;
		}
		else if(flag == 1) l = mid + 1;
		else if(flag == 0) r = mid - 1;
	}
	printf("NO");
	return 0;
}
```


---


# [BCSP-X 2024 12 月小学高年级组] 打怪升级

## 题目描述

Alice 在玩一个游戏，游戏共有 $n$ 个关卡，你需要操作 $1$ 个主角过关，主角有 $2$ 个属性：

1. 血量
2. 等级

每关的 Boss 会对主角造成伤害（血量减小），第 $i$ 关的 Boss 对等级为 $j$ 的主角造成的伤害值为 $b[i][j]$。

每关打完 Boss 后，在进入下一关前会得到一本经验书，你有 $2$ 个选择：

1. 回血：第 $i$ 关的经验书可以使血量增加 $a[i]$。
2. 改变等级：若假设主角当前等级为 now，使用经验书可以将等级变为 $[1, now + 1]$ 中的任意值。

你需要在 $2$ 个选择中择一执行。

已知主角的初始血量为 $m$，初始等级为 $1$，游戏过程中任意时刻血量必须 $>0$。

现在请问，在通过第 $k$ 个关卡之后（可以使用第 $k$ 关的经验书），主角能达到的最大等级是多少？如果无法通过第 $k$ 关，答案为 0。

请你输出 $k = 1 \sim n$ 的所有答案，注意这 $n$ 个询问是独立的。

例如 $n = 3, m = 2, a = [2, 1, 1]$

$$b[1][1] = 1$$
$$b[2][1] = 2, b[2][2] = 3$$
$$b[3][1] = 3, b[3][2] = 3, b[3][3] = 3$$

- 当 $k = 1$ 时，第一关血量先减为 $2 - 1 = 1$，然后选择升为 2 级，答案为 $2$。
- 当 $k = 2$ 时，第一关血量先减为 $2 - 1 = 1$，然后选择加血 $1 + 2 = 3$；第二关血量减为 $3 - 2 = 1$，然后选择升为 $2$ 级，答案为 $2$。
- 当 $k = 3$ 时，无论如何选择都无法通过第 3 关，答案为 $0$。

## 说明/提示

### 样例 3-5

见附件。

### 数据范围

对于所有数据，$1 \leq n \leq 1500, 0 \leq a[i], b[i][j] \leq 100, 1 \leq m \leq 1500$

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $n$ | 子任务依赖 |
|:----------:|:----:|:-------:|:------------:|
| 1          | 39   | $\leq 10$ |            |
| 2          | 43   | $\leq 100$ | 1          |
| 3          | 18   | $\leq 1500$ | 1,2        |

## 样例 #1

### 输入

```
3 2
2 1 1
1
2 3
3 3 3```

### 输出

```
2
2
0```

## 样例 #2

### 输入

```
10 98
67 100 76 15 44 86 38 95 5 8
43
25 91
14 18 24
79 79 60 85
35 47 59 22 96
53 78 43 95 55 25
74 26 97 30 42 14 6
100 70 79 49 83 74 43 38
64 38 75 79 59 10 54 17 2
34 19 19 4 23 90 99 97 93 10```

### 输出

```
2
2
3
4
4
4
5
5
5
6```

# 题解

## 作者：wangxiaochai (赞：4)

一道经典的动态规划问题。

设置一个 $dp[i][j]$ 数组，来表示在第 $i$ 关、第 $j$ 级时的血量。根据题意，把 $dp[0][1]$ 初始化为 $m$，其他状态初始化为-1。

在动态转移方程方面，是三重循环嵌套。第一重循环关卡数 $i$，第二重循环 第 $i$ 关的等级数 $j$，第三重循环是在 第 $i$ 关、第 $j$ 级如果选择升级，可以升到 $1～j+1$ 的等级，于是有了下面的核心代码：

```cpp
for (int i = 1; i <= n; ++i)//最大通关
    for (int j = 1; j <= i; ++j)//等级
    {
        if (dp[i - 1][j] <= 0) continue;//无法通过上一关
        int hp = dp[i-1][j] - b[i][j];//计算硬抗伤害之后的血量
        if (hp <= 0) continue; //无法通过本关
        // 选择 1：增加血
        dp[i][j] = max(dp[i][j], hp + a[i]);
        // 选择 2：提升等级
        for (int level=1; level<=j+1; level++)
            dp[i][level] = max(dp[i][level], hp);
        }
```

最后在输出的时候，还是一个二重循环

```cpp
// 输出每一关的结果
for (int k = 1; k <= n; ++k) 
{
    int MAX = 0;
    for (int j = 1; j <= k + 1; j++) 
        if (dp[k][j] > 0) MAX = j;
    cout << MAX << endl;
}
```
注意要点：

1. 计算无法通关的血量时，条件是血量小于等于 $0$，而不是小于 $0$ ，会 WA；
2. 如果选择升级，要循环 $1～j+1$，不能直接选择升级到 $j+1$，会 WA；
3. 输出结果的时候，注意最大通关上限是关卡数+1，也就是 $k+1$，而非 $k$。

做到上以几点，就可以轻松通过本题。

---

## 作者：tomAmy (赞：3)

由于数据太水，$O(n^3)$ 的做法也可以过，这里给出一个 $O(n^2)$ 的做法。

我们可以令 $dp_{i, j}$ 表示第 $i$ 关结束后等级为 $j$ 的最大血量。分为加血量和加等级两种情况，容易推出转移方程：

$$\begin{cases}
  dp_{i,j}=\max(dp_{i,j},dp_{i-1,j}-b_{i,j}+a_i) \\
  dp_{i,j}=\max(dp_{i,j},dp_{i-1,k}-b_{i,k})(k\in [j-1,i])
\end{cases}$$

此 $O(n^3)$ 的做法与前两篇题解不同之处在于这是以 $i$ 的视角来推倒的，这也便于后面的优化。

复杂度瓶颈在于第二个式子，考虑优化。由与每次 $k$ 取值的右端点不变，考虑后缀 max。具体实现就是维护一个变量 $maxn$。倒序枚举 $j$，每次左端点左移一格，就将左端点对应的值更新进 $maxn$。也可以写一个数组，但这种方法被莫名其妙地卡掉了，所以就不详细说了。（我考试的时候就是这么写的，结果被捆绑测试卡到了 39 分）

如果加强了数据，建议升绿，因为本来朴素就很容易想歪，加优化还是挺难的。

贴上代码：

```cpp
#include <iostream>
using namespace std;

const int N = 1505;
int a[N], b[N][N], dp[N][N], maxn[N];

int main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++)
			cin >> b[i][j];
	dp[0][1] = m;
	for (int i = 1; i <= n; i++)
	{
		int maxn = 0;
		for (int j = i + 1; j >= 1; j--)
		{
			if (dp[i - 1][j] - b[i][j] > 0)
				dp[i][j] = max(dp[i][j], dp[i - 1][j] - b[i][j] + a[i]);
			
			maxn = max(maxn, dp[i - 1][j - 1] - b[i][j - 1]);
			if (maxn <= 0) continue;
			dp[i][j] = max(dp[i][j], maxn);
		}
		int ans = 0;
		for (int j = i + 1; j >= 1; j--)
		{
			if (dp[i][j] > 0)
			{
				ans = j;
				break;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：YWT130508 (赞：0)

这道题很明显是动态规划的算法，~~从题目标签可以看出~~。

简单来说题目就是该你一个初始血量，你的等级不同每关受到伤害也不同，注意：并不是等级越高受到伤害越少，样例中就有这样的情况。所以你要保证等级高的同时血量大于 $0$，每关结束可以选择升级或回血。

### 思路
我们设 $dp[i][j]$ 为第 $i$ 关结束后等级为 $j$ 时的血量，循环外层枚举 $i$，内层枚举 $j$，$j$ 的值可以是 $1 \sim i+1$，这里有一个优化，就是 $j$ 从大到小枚举，然后每次取血量的最大值，因为当前等级 $j$ 可以由 $j - 1 \sim i + 1$ 升级得来，再分回血和升级两种选择。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1505
int n,m;
int a[N],b[N][N],dp[N][N];
int main(){
//freopen(".in","r",stdin);
//freopen(".out","w",stdout);
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
cin>>n>>m;
for(int i=1;i<=n;i++){
	cin>>a[i];
}
for(int i=1;i<=n;i++){
	for(int j=1;j<=i;j++){
		cin>>b[i][j];
	}
}
memset(dp,0,sizeof dp);
dp[0][1]=m;
for(int i=1;i<=n;i++){
	int premax=0;
	for(int j=i+1;j>=1;j--){
		if(dp[i-1][j]-b[i][j]>0)dp[i][j]=max(dp[i][j],dp[i-1][j]-b[i][j]+a[i]);
		premax=max(premax,dp[i-1][j-1]-b[i][j-1]);
		if(dp[i-1][j-1]-b[i][j-1]>0)dp[i][j]=max(dp[i][j],premax);
	}
}
for(int i=1;i<=n;i++){
	int ans=0;
	for(int j=i+1;j>=1;j--){
		if(dp[i][j]>0){
		ans=j;
		break;	
		}
	}
	cout<<ans<<endl;
}
return 0;
}

```

---

## 作者：54188_you_Dad (赞：0)

# 前言

一道黄题都没人写题解吗……

# 思路

~~根据算法标签~~这是一道动规题。

我们可以用 $dp_{i,j}$ 表示在第 $j$ 级通过第 $i$ 关之后的最大血量。那么 $dp_{i,j}$ 一定是由 $dp_{i-1,k}$ 推出来的。应该 $dp_{i,j}$ 推 $dp_{i+1,k}$ 也可以，只是本人太菜了，敲不对。

那么回归正题,对于 $dp_{i-1,j}$ 有 
$ \begin{cases}
  dp_{i,j} = \max(dp_{i,j},dp_{i-1,j}-b_{i,j}+a_i) & \text{选择加血}\\
  dp_{i,k} = \max(dp_{i,k},dp_{i-1,j}-b_{i,j})(k \in [1,j+1]) & \text{选择升级}
\end{cases}$

# 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
int a[1505];
int b[1505][1505];
int dp[1505][1505];
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++) cin>>b[i][j];
	}
	dp[0][1] = m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(dp[i-1][j]<=0) continue;
			int t = dp[i-1][j]-b[i][j];
			if(t<=0) continue;
			dp[i][j] = max(dp[i][j],t+a[i]);
			for(int k=1;k<=j+1;k++)
			{
				dp[i][k] = max(dp[i][k],t);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		int ans = 0;
		for(int j=i+1;j>=1;j--)
		{
			if(dp[i][j]>0)
			{
				ans = j;
				break;
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---


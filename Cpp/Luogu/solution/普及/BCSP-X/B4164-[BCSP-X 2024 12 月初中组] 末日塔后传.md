# [BCSP-X 2024 12 月初中组] 末日塔后传

## 题目背景

末日塔 - 后传

## 题目描述

星球上的 $n$ 座末日塔又开始释放以太能量了。

每一座末日塔释放的以太能量都有 $n$ 种类型，对于第 $k$ 种类型的以太能量，它需要通过单向管道运送到第 $k$ 座末日塔，才能被完全抑制住。

作为曾经勇闯末日塔的先锋，你被授予在任意两座末日塔之间建造一条单向管道的权力，而你的任务则是对于所有的 $i, j \in [1, n]$，当第 $i$ 座末日塔出现第 $j$ 种以太能量时，尽你所能的将其通过管道迅速运送到能够抑制这种以太能量的末日塔。

很不幸，由于以太能量过于浓密，当其被单向管道连续运输大于两次后，以太能量散发的射线将透过管道，对星球上的所有生物进行精神控制，你的任务就失败了。

请你判断存不存在能够让你任务圆满完成的管道设计方案。如果有，请输出 YES 以及任意一种设计方案；如果没有，请输出 NO。

## 说明/提示

### 样例解释 1

$d_1$ 一次可以到 $d_2$，$d_1 $先到 $d_2$，再到 $d_3$，最多利用了两个管道；$d_2$ 和 $d_3$ 同理，所以输出 YES。

### 样例解释 2

$n=4$ 的情况，无论你怎么建图，保证不能同时有 $d_i$ 到 $d_j$ 的往返路，这样 $d_i$ 到 $d_j$ 的连接会多于 $2$ 个管道，所以输出 NO。

### 数据范围

对于 $100\%$ 的数据，$n \leq 500$。

## 样例 #1

### 输入

```
3```

### 输出

```
YES
0 1 0
0 0 1
1 0 0```

## 样例 #2

### 输入

```
4```

### 输出

```
NO```

# 题解

## 作者：qhr2023 (赞：2)

## solution

一道构造。

先假设已经有了 $n$ 个点的解，考虑推广到 $n+2$ 个点。

因为 $n$ 个点内部是合法的，令 $n+1$ 和 $n+2$ 到这 $n$ 个点的距离及 $n$ 个点到 $n+1$ 和 $n+2$ 距离都不超过 $2$ 即可。

我们可以从 $n+2$ 到 $n$ 个点都连一条边，$n$ 个点每个点都连一条到 $n+1$ 的边，$n+1$ 再连一条到 $n+2$ 的边，这样就是一种合法的 $n+2$ 的方案了。

如下图，黑点是 $n$ 个点，红色是新加的 $2$ 个点，我们先不管心 $n$ 个点内部怎么连。

![](https://cdn.luogu.com.cn/upload/image_hosting/lk4lz0b3.png)

所以我们知道，只要 $n$ 个点有解，那 $n+2$ 个点也一定有解。

故只要找到有解的最小奇数和偶数即可，$1$ 个点时显然成立，所以奇数都有解，而最小的偶数通过手算是 $6$。这样就可以构造所有 $1+2k$ 和 $6+2k$ 的解了，$k$ 是非负整数。

实现方面，对于奇数，从 $2$ 开始执行上述的连边即可；对于偶数，可以把前 $6$ 个点的边连完，从 $7$ 开始执行上述连边即可。下图是 $n=6$ 的解。

![](https://cdn.luogu.com.cn/upload/image_hosting/fbzw5fy3.png)

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[505][505];
int main () {
	cin >> n;
	if (n==2||n==4) {
		puts("NO");
		return 0;
	}
	puts("YES");
	if (n%2==0) 
		a[1][2]=a[1][3]=a[1][4]=1,
		a[2][3]=a[2][5]=a[2][6]=1,
		a[3][4]=a[3][5]=a[3][6]=1,
		a[4][5]=a[4][2]=a[5][6]=a[5][1]=a[6][1]=a[6][4]=1;
	for (int i=(n%2?2:7); i<=n; a[i][i+1]=1, i+=2)
			for (int j=1; j<i; ++j)
				a[j][i]=a[i+1][j]=1;
	for (int i=1; i<=n; ++i, cout << '\n')
		for (int j=1; j<=n; ++j)
			cout << a[i][j] << ' ';
	return 0;
}
```

---

## 作者：2021CHD (赞：0)

## 题目大意

要求判断是否存在 $n$ 个点的竞赛图使得对于任意有序点对 $(i,j)$，$i$ 都能在走不超过 $2$ 条边的前提下到达 $j$ 并构造方案。

注：竞赛图是每两个不同的点间恰有一条有向边的有向图。

## 解法

首先 $n=2$ 和 $n=4$ 显然无解，并且 $n=1$ 显然有解。

下图给出了一个 $n=6$ 的解：

![一个 $n=6$ 的解](https://cdn.luogu.com.cn/upload/image_hosting/g8a1laht.png)

根据 $n=x$ 的解，我们可以像这样构造出 $n=x+2$ 的解：（以 $x=5$ 为例）

![通解](https://cdn.luogu.com.cn/upload/image_hosting/vqti70dm.png)

也就是说，$1\sim x$ 全部连向 $x+1$，$x+1$ 连向 $x+2$，$x+2$ 连向全部的 $1\sim x$。

不难说明这样做是合法的。

那么 $n$ 是奇数和 $n$ 是大于等于 $6$ 的偶数的解就全部被我们构造出来了。

## 参考代码

这是我的 [AC 记录](https://www.luogu.com.cn/record/203970738)。

```c++
#include<cstdio>
#include<cstring>
using namespace std;
int n,i,j,ans[600][600]; 
main()
{
	scanf("%d",&n);
	if(n==2||n==4)
	{
		printf("NO\n");
		return 0;
	}
	printf("YES\n");
	if(n%2==1)
	for(i=2;i<=n;i=i+2)
	{
		ans[i][i+1]=1;
		for(j=1;j<i;j++)
		{
			ans[j][i]=1;
			ans[i+1][j]=1;
		}
	}
	else
	{
		ans[1][2]=1;
		ans[2][3]=1;
		ans[3][4]=1;
		ans[4][5]=1;
		ans[5][6]=1;
		ans[6][1]=1;
		ans[1][3]=1;
		ans[3][5]=1;
		ans[5][1]=1;
		ans[2][6]=1;
		ans[6][4]=1;
		ans[4][2]=1;
		ans[1][4]=1;
		ans[2][5]=1;
		ans[3][6]=1;
		for(i=7;i<=n;i=i+2)
		{
			ans[i][i+1]=1;
			for(j=1;j<i;j++)
			{
				ans[j][i]=1;
				ans[i+1][j]=1;
			}
		}
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		printf("%d ",ans[i][j]);
		printf("\n");
	}
}
```

---


# [BCSP-X 2024 6 月小学高年级组] 学习计划

## 题目描述

暑假共有 $n$ 天，第 $i$ 天的精力指数为 $a[i]$，你想要利用假期**依次（按 $1, 2, \ldots, m$ 顺序）** 复习 $m$ 门功课，第 $i$ 门功课的重要程度为 $b[i]$，且**每门功课的复习时段必须连续，并且不能有某天不干事。**

假设第 $i$ 门功课的复习时段为第 $l \sim r$ 天，那么第 $i$ 门功课的收益为 $b[i] \times (a[l] + a[l + 1] + \ldots + a[r])$，你的总收益为 $m$ 门功课收益的总和。

请你制订一个复习计划，使得总收益最大。

形式化地，给定序列 $a[1 \sim n], b[1 \sim m]$，你需要把 $1, 2, \ldots, n$ 这个序列分成首尾相连且非空的 $m$ 段，假设每段的 $a$ 之和为 $s[1 \sim m]$，最大化 $\sum_{i=1}^{m} b[i] \times s[i]$ 的值。

例如 $a = [-3, 6, -1, -8, 7, -6], b = [-3, 2]$，最优策略是第 $1 \sim 4$ 天复习第 $1$ 门功课，收益为 $-3 \times (-3 + 6 - 1 - 8) = 18$；第 $5 \sim 6$ 天复习第 $2$ 门功课，收益为 $2 \times (7 - 6) = 2$；总收益为 $18 + 2 = 20$。

例如 $a = [6, 3, 5, 10, 5], b = [-8, -5, -5]$，最优策略是分成 $[1], [2, 3, 4], [5]$ 三段，总收益为 $-8 \times 6 - 5 \times (3 + 5 + 10) - 5 \times 5 = -163$。


## 说明/提示

对于所有数据，满足 $1 \leq T \leq 20, 1 \leq m \leq n \leq 2000, -10^3 \leq a[i], b[i] \leq 10^3$。

- 对于测试点 1~7：$n \leq 10$；
- 对于测试点 8~12：$n \leq 500$；
- 对于测试点 13~16：所有 $a[i], b[i]$ 为正整数；
- 对于测试点 17~20：$n \leq 2000$；

## 样例 #1

### 输入

```
5
6 2
-3 6 -1 -8 7 -6
-3 2
5 4
-9 -6 -6 -7 -8
-5 7 -9 -3
7 7
7 2 3 0 -2 4 2
-9 -2 -5 0 -7 9 -1
5 3
10 4 6 7 4
-1 -9 2
5 3
6 3 5 10 5
-8 -5 -5```

### 输出

```
20
144
-34
-12
-163```

# 题解

## 作者：Yxa_Sheep (赞：5)

**[题目传送门](https://www.luogu.com.cn/problem/B4172)**
## 题意
用 $n$ 天复习 $m$ 个科目，每门科目的复习时间连续。第 $i$ 门科目从第 $l$ 天复习到第 $r$ 天的收益为 $b_i\times (a_l+a_{l+1}+\dots+a_{r-1}+a_r)$，求最大总收益。
## 思路
算法标签都挂着 DP，那我们当然得用了：
- 用 $f_{i,j}$ 表示复习到第 $i$ 天选择 $j$ 门科目的最大收益。
- 首先考虑特殊情况，$i=0$ 或者 $j=0$ 时 $f_{i,j}=0$。
- 接着考虑普通情况，如果第 $i-1$ 天选 $j$ 门科目（$f_{i-1,j}$ 嘛），那么 $f_{i,j}=f_{i-1,j}+a_i\times b_j$（$a_i\times b_j$ 是从题目中那个 $b_i\times (a_l+a_{l+1}+\dots+a_{r-1}+a_r)$ 中分解出来的，乘法分配律嘛），如果 $i-1$ 天选 $j-1$ 个科目，那么第 $i$ 天就是第一个选第 $j$ 个科目的，那么 $f_{i,j}=f_{i-1,j-1}+a_i\times b_j$。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n, m, a[2010], b[2010], f[2010][2010];
int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i++)
            scanf("%d", &a[i]);
        for (int i = 1; i <= m; i++)
            scanf("%d", &b[i]);
        memset(f, -0x3f, sizeof(f)), f[0][0] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                f[i][j] = max(f[i - 1][j], f[i - 1][j - 1]) + a[i] * b[j];
        printf("%d\n", f[n][m]);
    }
	return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4172)**

---

## 作者：Sweet_2013 (赞：4)

# 思路
- 输入。
- 循环。
  - 一定要每次将记忆化数组清零！
  - 调用 dfs 函数计算从第 $2$ 天开始的最大收益，并加上第 $1$ 天的收益 $a_1\times  b_1$。因为递归是从第 $2$ 天开始的，而第 $1$ 天的收益需要单独计算。
- dfs。
 - 初始化变量 $s$ 为最小的 $32$ 位整数，于存储当前递归分支的最大收益。
 - 如果当前天数 $i$ 到达了 $n+1$，并且课程编号 $y$ 到达了 $m$，说明所有课程都安排完毕，且所有天数都用完了。此时返回收益 $0$。
 - 如果当前天数 $i$ 超出了范围，说明当前的安排会让天数不够用。返回一个极小值，表示这种情况会导致总收益极小，不会被选择。
 - 如果 $c_{iy}$ 不为零，说明当前子问题从第 $i$ 天开始复习第 $y$ 门课已经被计算过，直接返回之前存储的结果即可。
 - 将第 $i$ 天分配给当前课程 $y$，并递归计算从第 $i+1$ 天开始的最大收益。$a_i\times b_y$ 表示第 $i$ 天的精力指数与当前课程重要性的乘积。更新当前的最大收益。
 - 将第 $i$ 天分配给下一门课程 $y+1$，并递归计算从第 $i+1$ 天开始的最大收益。$a_i\times b_{y+1}$ 表示第 $i$ 天的精力指数与下一门课程重要性的乘积。再次更新当前的最大收益。
 - 将当前子问题的最大收益 $s$ 存储到记忆化数组 $c_{iy}$ 中。
 - 返回当前子问题的最大收益。
# 上代码！

```cpp
#include <bits/stdc++.h> 
using namespace std;     
const int maxn = 2e3 + 1; 
int t, n, m, a[maxn], b[maxn], c[maxn][maxn]; // c 为记忆化数组，存储已经计算过的子问题结果。
int dfs(int i, int y) {// 定义递归函数 dfs，用于计算从第 i 天开始复习，从第 y 门课程开始安排的最大收益
    int s = 0x80000000;  // 初始化变量 s 为一个极小值，用于存储当前递归分支的最大收益
    if (i == n + 1 && y == m) return 0;// 如果所有天数都安排完毕，且所有课程都复习完毕，返回收益 0
    if (i > n + 1) return -2e9; // 如果天数超出范围，返回一个极小值，表示这种情况不可行。
    if (c[i][y]) return c[i][y];// 如果当前子问题已经计算过，直接返回之前存储的结果。
    s = max(s, dfs(i + 1, y) + a[i] * b[y]); // 将第 i 天分配给当前课程 y，并递归计算从第 i + 1 天开始的最大收益。
    s = max(s, dfs(i + 1, y + 1) + a[i] * b[y + 1]);// 尝试将第 i 天分配给下一门课程 y + 1，并递归计算从第 i + 1 天开始的最大收益。
    c[i][y] = s;// 将当前子问题的最大收益存储到记忆化数组 c[i][y] 中。
    return s;// 返回当前子问题的最大收益。
}

int main() {
    cin>> t;  
    while (t--) { 
        cin >> n >> m; 
        for (int i = 1; i <= n; i++) cin >> a[i];
        for (int i = 1; i <= m; i++) cin >> b[i];
        memset(c, 0, sizeof(c));// 清空之前的记忆化结果。
        cout << dfs(2, 1) + a[1] * b[1] << endl;// 调用 dfs 函数计算从第 2 天开始的最大收益，并加上第 1 天的收益（a[1] * b[1]），因为代码中的递归是从第 2 天开始的，第 1 天的收益需要单独计算。
    }
    return 0;  
}
```

---

## 作者：piano_pei (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/B4172)

### 思路

最优化问题，考虑动态规划。

状态定义 ：$dp_{i,j}$ 表示复习到第 $i$ 天选 $j$ 门功课的最大收益。

由于收益的计算方式与子段和有关，所以我们在设计状态转移方程式要考虑继承 / 不继承 上次的子段和。

先考虑继承，即上一天（第 $i-1$ 天）也选 $j$ 门功课，这次复习产生的收益是 $a_i×b_j$（用乘法分配律拆开之后的柿子），那么产生的总收益为 $dp_{i-1,j}+a_i×b_j$。

考虑不继承，即上一天选 $j-1$ 门功课，加上这次复习的收益，产生的总收益为 $dp_{i-1,j-1}+a_i×b_j$。

综上，可得状态转移方程为 $dp_{i,j}=max\{dp_{i-1,j},dp_{i-1,j-1}\}+a_i×b_j$。

时间复杂度 $O(Tnm)$。

还有几个小点需要注意：

1. 总收益可能为负数，所以 $dp$ 数组初始化成负无穷。
2. 十年 OI 一场空，不开long long见祖宗。

### $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
const int N = 2e3 + 10;
ll a[N], b[N];
ll dp[N][N];
int n, m;
il void init()
{
    cin >> n >> m;
    for(int i = 1;i <= n;++i)
        scanf("%lld", &a[i]);
    for(int i = 1;i <= m;++i)
        scanf("%lld", &b[i]);
}
il void solve()
{
    memset(dp, -0x3f, sizeof(dp));
    dp[0][0] = 0;
    for(int i = 1;i <= n;++i)
        for(int j = 1;j <= m;++j)
            dp[i][j] = max(dp[i - 1][j] + a[i] * b[j], dp[i - 1][j - 1] + a[i] * b[j]);
    cout << dp[n][m] << "\n";
}
int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        init();
        solve();
    }
    return 0;
}

```

---

## 作者：aaalys (赞：1)

## B4172 学习计划 题解

### 思路

可以将收益式子换一下，设 $c_i$ 为 $a_i$ 被分到的段的编号，那收益式子变成 $\sum_{i=1}^n a_i \times b_{c_i}$。

很显然的 dp, 设 $f_{i,j}$ 为将 $a$ 的前 $i$ 个数分成 $j$ 段的最大收益。

那现在有两种选择。

1. $a_{i-1}$ 选的是第 $j$ 段，这样的收益是 $f_{i-1,j}+a_i\times b_j$。
2. $a_{i-1}$ 选的是第 $j-1$ 段，这样的收益是 $f_{i-1,j-1}+a_i\times b_j$。

整理一下就能得到转移方程 $f_{i,j}= \max (f_{i-1,j},f_{i-1,j-1})+a_i\times b_j$。

由于有负数，初始值要设为 $-\inf$，$f_{0,0}$ 设为 $0$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 2010;
int a[N], b[N];
int f[N][N];
void run() {
	memset(f, -0x3f, sizeof(f));
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i];
	f[0][0] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= min(i, m); j++)
			f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i] * b[j];
	cout << f[n][m] << endl;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int _ = 1;
	cin >> _;
	while (_--) run();
	return 0;
}
```

---

## 作者：DashZhanghanxu (赞：0)

# 解析
分析题目：已经给定了 $n$ 天的精力指数数组 $a$ 和 $m$ 门功课的重要程度数组 $b$。需要将 $n$ 天分成 $m$ 段，每段连续且非空。目标是最大化总收益，即每段的重要程度乘以该段精力指数和的总和。

考虑用 dp 解题和前缀和加快计算。

先输入数据，并计算前缀和。然后初始化 $p$ 数组，表示处理到第 1 段时的最大收益。然后递推计算当前收益，并更新 $p$ 数组为当前段的 $cur$ 数组。接着当每次处理当前段时，利用前缀和和当前段的重要程度计算当前段的最大收益。最后输出最大收益。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF=1e18;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin>>T;
    while(T--){
        int n,m;
        cin>>n>>m;
        vector<int> a(n+1),b(m+1);
        for(int i=1;i<=n;++i)cin>>a[i];
        for(int i=1;i<=m;++i)cin>>b[i];
        vector<ll> sum(n+1,0);
        for(int i=1;i<=n;++i){
            sum[i]=sum[i-1]+a[i];
        }
        vector<ll> p(n+1,-INF);
        for(int i=1;i<=n;++i){
            p[i]=b[1]*sum[i];
        }
        for(int j=2;j<=m;++j){
            vector<ll> cur(n+1,-INF);
            ll maxn=p[j-1]-(ll)b[j]*sum[j-1];
            for(int i=j;i<=n;++i){
                cur[i]=maxn+(ll)b[j]*sum[i];
                ll can=p[i]-(ll)b[j]*sum[i];
                if(can>maxn){
                    maxn=can;
                }
            }
            p=move(cur);
        }
        cout<<p[n]<<'\n';
    }
    return 0;
}
```

---


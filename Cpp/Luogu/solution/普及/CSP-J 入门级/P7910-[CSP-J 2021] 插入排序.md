# [CSP-J 2021] 插入排序

## 题目描述

插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H 老师刚刚在上课的时候讲了插入排序算法。

假设比较两个元素的时间为 $\mathcal O(1)$，则插入排序可以以 $\mathcal O(n^2)$ 的时间复杂度完成长度为 $n$ 的数组的排序。不妨假设这 $n$ 个数字分别存储在 $a_1, a_2, \ldots, a_n$ 之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：

这下面是 C/C++ 的示范代码：

```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

这下面是 Pascal 的示范代码：

```pascal
for i:=1 to n do
	for j:=i downto 2 do
		if a[j]<a[j-1] then
			begin
				t:=a[i];
				a[i]:=a[j];
				a[j]:=t;
			end;
```

为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：

H 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的所有元素均为非负整数。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：

$1~x~v$：这是第一种操作，会将 $a$ 的第 $x$ 个元素，也就是 $a_x$ 的值，修改为 $v$。保证 $1 \le x \le n$，$1 \le v \le 10^9$。**注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作**。

$2~x$：这是第二种操作，假设 H 老师按照**上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的第 $x$ 个元素，也就是 $a_x$，在排序后的新数组所处的位置。保证 $1 \le x \le n$。**注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作**。

H 老师不喜欢过多的修改，所以他保证类型 $1$ 的操作次数不超过 $5000$。

小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决这个问题。

## 说明/提示

**【样例解释 #1】**

在修改操作之前，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 2, 1$。

在修改操作之后，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 1, 2$。

注意虽然此时 $a_2 = a_3$，但是我们**不能将其视为相同的元素**。

**【样例 #2】**

见附件中的 `sort/sort2.in` 与 `sort/sort2.ans`。

该测试点数据范围同测试点 $1 \sim 2$。

**【样例 #3】**

见附件中的 `sort/sort3.in` 与 `sort/sort3.ans`。

该测试点数据范围同测试点 $3 \sim 7$。

**【样例 #4】**

见附件中的 `sort/sort4.in` 与 `sort/sort4.ans`。

该测试点数据范围同测试点 $12 \sim 14$。

**【数据范围】**

对于所有测试数据，满足 $1 \le n \le 8000$，$1 \le Q \le 2 \times {10}^5$，$1 \le x \le n$，$1 \le v,a_i \le 10^9$。

对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。

各测试点的附加限制及分值如下表所示。

| 测试点 | $n \le$ | $Q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ | 无 |
| $5 \sim 9$ | $300$ | $300$ | 无 |
| $10 \sim 13$ | $1500$ | $1500$ | 无 |
| $14 \sim 16$ | $8000$ | $8000$| 保证所有输入的 $a_i,v$ 互不相同 |
| $17 \sim 19$ | $8000$ | $8000$ | 无 |
| $20 \sim 22$ | $8000$ | $2 \times 10^5$ | 保证所有输入的 $a_i,v$ 互不相同 |
| $23 \sim 25$ | $8000$ | $2 \times 10^5$ | 无 |

## 样例 #1

### 输入

```
3 4
3 2 1
2 3
1 3 2
2 2
2 3
```

### 输出

```
1
1
2
```

# 题解

## 作者：Otomachi_Una_ (赞：351)

### 题目简述
给定长度为 $n$ 的序列 $a_i$。现在要维护单点修改与冒泡排序后一元素的下标。

$n\leq8000,q\leq2\times 10^5$，修改操作不超过 $5000$ 次。

### 解题思路

可以发现，对于一个已经有序的数列，单点修改一个值，我们可以通过前后冒泡各一次来保持有序，举个例子：

原序列为 $1,1,4,5,6,7$，修改为 $1,1,9,5,6,7$。

我们可以从前往后冒泡，再次维持了数列的有序。这样的操作是 $\mathcal{O}(n)$ 的。

同样的，我们可以维护一个有序数列，并记录原下标与先下标之间的关系（用数组记录），每次修改后更新这种关系。

这样，修改操作是 $\mathcal{O}(n)$ 的，查询是 $\mathcal{O}(1)$ 的。完结撒花。

下面给出考场代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=8005;
int n,q;
int t[MAXN];
struct node{
	int pre,id;
}a[MAXN];
bool cmp(node x,node y){
	if(x.pre!=y.pre) return x.pre<y.pre;
	return x.id<y.id;
}//两个元素之间的优先级
int main(){
	//freopen("sort.in","r",stdin);
	//freopen("sort.out","w",stdout);
	scanf("%d%d",&n,&q); 
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].pre);
		a[i].id=i;
	}//输入
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++)
		t[a[i].id]=i;
	for(int i=1;i<=q;i++){
		int opt,x,v;
		scanf("%d",&opt);
		if(opt==1){//单点修改
			scanf("%d%d",&x,&v);//Ax->v
			a[t[x]].pre=v;
			for(int j=n;j>=2;j--)
				if(cmp(a[j],a[j-1])){
					node kkksc03=a[j];
					a[j]=a[j-1];
					a[j-1]=kkksc03;
				}//前扫
			for(int j=2;j<=n;j++)
				if(cmp(a[j],a[j-1])){
					node kkksc03=a[j];
					a[j]=a[j-1];
					a[j-1]=kkksc03;
				}//后扫
			for(int i=1;i<=n;i++)
				t[a[i].id]=i;//更新关系
		}
		else{
			scanf("%d",&x);
			printf("%d\n",t[x]);
		}
	}
	return 0;
}
```
update 2021.11.7

最近有一些小朋友问我为什么要前后各扫一次。

原因是更改的时候只修改了一个元素，我们不知道他是改大了还是改小了。

举个栗子，比如原序列是 $4,5,6$。

把 $5$ 改成 $1$ 就要往前扫，把 $5$ 改成 $9$ 就要往后扫。

---

## 作者：chenpengda (赞：138)

由于给的条件是修改次数不超过 $5000$ ，我们应该在修改处做文章。

注意到一个数组 $a$ 进行“示范代码”之后，数 $a_i$ 在 $a_j$ 之前的充要条件是以下两者中成立一个：

1. $a_i<a_j$

2. $a_i=a_j$ 且 $i<j$

考虑维护一个数组 $b$ 储存各个数在数组 $a$ 中的相对排名，那么开始输入 $a$ 时进行统计（用以上两条判断）之后：

每进行一次操作 2 ，输出 $b_x$ 。

每进行一次操作 1 ，即将 $a_x$ 修改成 $v$ 。此时用 $O(n)$ 遍历数组中的各个元素，如果某一个元素 $i$ 满足在数组插入排序后原本在 $x$ 之前，现在在 $x$ 之后（仍然用两条判定），因为 $i$ 与数组中其他数的相对位置没有变化，使 $b_i$ 增加一， $b_x$ 减少一即可。另外一种情况同理。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[8005],b[8005],num,x,v,ans;
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(i==j||a[j]<a[i]||a[j]==a[i])b[i]++;
			else b[j]++;
		}//这里的b[i]就是第i个数在数组a[i]中的排位 
	}
	for(int i=0;i<q;i++)
	{
		scanf("%d",&num);
		if(num==1)
		{
			scanf("%d%d",&x,&v);
			for(int i=1;i<=n;i++)
			{
				if(i==x)continue;
				if((a[i]<a[x]||a[i]==a[x]&&i<x)&&(a[i]>v||a[i]==v&&i>x))
				{
					b[i]++;b[x]--;
				}
				else if((a[i]>a[x]||a[i]==a[x]&&i>x)&&(a[i]<v||a[i]==v&&i<x))
				{
					b[i]--;b[x]++;
				}
			}
			a[x]=v;
		}
		if(num==2)
		{
			scanf("%d",&x);
			printf("%d\n",b[x]);
		}
	}
	return 0;
}
```


---

## 作者：WhisperingWillow (赞：106)

题解区没有的做法。

- 对于每个修改操作，我们直接修改。
- 对于每个查询操作，我们暴力查询，从头向后查找，按题意模拟即可。

时间复杂度 $\mathcal{O}(nq)$。


```
#include<iostream>
#include<cstdio>
using namespace std;
int a[10011];
int main()
{
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=q;i++){
		int xx;
		scanf("%d",&xx);
		if(xx==1){
			int x,v;
			scanf("%d%d",&x,&v);
			a[x]=v;
		} 
		else {
			int x;
			scanf("%d",&x);
			int w=a[x];
			int sum=n;
			for(int j=1;j<x;j++){
				if(a[j]>w){
					sum--;
				}
			}
			for(int j=x+1;j<=n;j++){
				if(a[j]>=w) sum--;
			}
			printf("%d\n",sum);
		}
	}
	return 0;
}
```

[Submission](https://www.luogu.com.cn/record/220520536)

---

## 作者：NightTide (赞：58)

## 广告
[$\color{Cyan}\colorbox{White}{无耻地推荐一下我的博客}$](https://www.luogu.com.cn/blog/Michaela-chr/#)
## 
## PART 0：题意描述
给定一个数列 $a_1,a_2,……,a_n$，现在要求出修改和冒泡排序（题目说是插入排序，我楞是看了好久）之后每个元素所在的位置。
## PART 1：思路分析
题目要求的是 **原来的 $a_x$ 在现在的位置**，所以我们可以开一个数组维护 **原位置** 与 **排序后的位置** 的对应关系。

就像这样
```cpp
void get_order(){
    for(int i=1;i<=n;i++){
        order[a[i].num]=i;
    }
}
```

### 完全暴力
首先看到题目中询问的要求

```
假设 H 老师按照上面的伪代码对 a 数组进行排序，你需要告诉 H 老师原来 a 的第 x 个元素，也就是 a[x]，在排序后的新数组所处的位置。保证 1≤x≤n。注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作。
```

题目中提到 **排序后的数组不会被保留，也不会影响后续的操作**，这样看起来我们需要每次将数组复制一遍，然后进行排序，得到答案后再将数组复原，于是得到了这样的代码

```cpp
void query(int x){
    for(int i=1;i<=n;i++){
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    get_order();
    printf("%d\n",order[x]);
}
void updata(int x,int v){
    a[x].val=v;
}
```

显然，这样只有 52 分，想要 AC，还需要其他优化
### 正解
H 老师的每一次询问，都需要排序，这未免太浪费时间了，我们可不可以不用每次排序呢？当然可以。我们可以在每一次修改后，把修改后的元素给他放在正确的位置。没错，就是一个元素的冒泡。

但是我们想要知道的是，这样和题意有冲突，题目中说的是 **排序后的数组不会被保留，也不会影响后续的操作**，这种写法是否正确呢？

这种写法的确是正确的。因为每次在查询的时候都需要排序，所以查询的时候元素一定是有序的，而我们一直保证元素的有序性，这样最终得到的序列和前面暴力得出的序列是一样的，那么答案自然也就正确。

所以修改的函数可以这样写

```cpp
void updata(int x,int v){
    a[order[x]].val=v;
    for(int i=order[x];i<n;i++){
        if(a[i]>a[i+1]){
            swap(a[i],a[i+1]);
        }
    }
    for(int i=order[x];i>1;i--){
        if(a[i]<a[i-1]){
            swap(a[i],a[i-1]);
        }
    }
    get_order();
}
```
而最后的查询只需要输出我们之前维护的对应关系的第 $x$ 个就可以了
## PART 3：细节
和第一种暴力有不同的是，由于我们更改了元素的顺序，所以我们修改的时候并不是直接修改 $a_x$，而需要修改 $a_{order_x}$ ，其中 order 维护的是前面所提到的关系，而冒泡也需要从 $a_{order_x}$ 开始，而非 $a_x$
## PART 4：AC 代码
不会有人会翻到这里吧，那我悄悄放上我的垃圾代码
```cpp
#include<bits/stdc++.h>
#define MAXN 8010
using namespace std;
struct node{
    int val;
    int num;
    bool operator >(const node b) const{
        if(this->val!=b.val) return this->val > b.val;
        else return this->num > b.num;
    }
    bool operator <(const node b) const{
        if(this->val!=b.val) return this->val < b.val;
        else return this->num < b.num;
    }
};
node a[MAXN];
int n,q;
int type,x,v;
/*
    order -> 记录每个点初始编号与当前位置的关系
*/
int order[MAXN];
void get_order(){
    for(int i=1;i<=n;i++){
        order[a[i].num]=i;
    }
}
void updata(int x,int v){
    a[order[x]].val=v;
    for(int i=order[x];i<n;i++){
        if(a[i]>a[i+1]){
            swap(a[i],a[i+1]);
        }
    }
    for(int i=order[x];i>1;i--){
        if(a[i]<a[i-1]){
            swap(a[i],a[i-1]);
        }
    }
    get_order();
}
int main(){
    // freopen("sort.in","r",stdin);
    // freopen("sort.out","w",stdout);
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].val);
        a[i].num=i;
    }
    sort(a+1,a+n+1);
    get_order();
    while(q--){
        scanf("%d",&type);
        if(type==1){
            scanf("%d%d",&x,&v);
            updata(x,v);
        }else{
            scanf("%d",&x);
            printf("%d\n",order[x]);
        }
    }
    return 0;
}
```


---

## 作者：山田リョウ (赞：57)

题外话：今年题太简单了吧。。。我都能阿克。。。

# 题意
有一个长度为 $n$ 的全是正整数的序列，有 $q$ 次询问，分为两种：
1. 把第 $x$ 个数改为 $v$，注意，本操作最多有 $5000$ 次。
1. 查询第 $x$ 个数的排名，注意，如果两个数的值相等的话，那么更靠前的那个排名更低。

# 做法
用一个平衡树维护就可以了，但注意到最多有 $n+5000$ 个数，所以我们离散化一下然后用值域树状数组维护就行了，注意两个值相等但是它放的位置不一样的话，离散化后的值也不应该一样。

考场代码：
```cpp
#include<stdio.h>
#include<ctype.h>
#include<algorithm>
FILE *in=fopen("sort.in","r"),*out=fopen("sort.out","w");
struct{
	int op,x,v;
}q[200001];
struct pair{
	int a,b;
	bool operator <(const pair&o)const{
		return a==o.a?b<o.b:a<o.a;
	}
	bool operator ==(const pair&o)const{
		return a==o.a&&b==o.b;
	}
}b[13001];
int a[8001],cnt[13001],n,Q,m;
inline void add(int x,int y){
	for(;x<=m;x+=(x&-x))
		cnt[x]+=y;
}
inline int sum(int x){
	int ans=0;
	for(;x;x-=(x&-x))
		ans+=cnt[x];
	return ans;
}
namespace fasti{
	char buf[1<<15],*p1=buf,*p2=buf;
	#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,in),p1==p2)?EOF:*p1++)
	inline void read(int&x){
		char c=getc();
		for(;!isdigit(c);c=getc());
		for(x=0;isdigit(c);c=getc())x=(x<<1)+(x<<3)+(c^48);
	}
}
using fasti::read;
int main(){
	read(n),read(Q);
	for(int i=1;i<=n;++i)read(a[i]),b[i]={a[i],i};
	m=n;
	for(int i=1;i<=Q;++i){
		read(q[i].op),read(q[i].x);
		if(q[i].op==1)read(q[i].v),b[++m]={q[i].v,q[i].x};
	}
	std::sort(b+1,b+m+1);
	m=std::unique(b+1,b+m+1)-b-1;
	for(int i=1;i<=n;++i)add(a[i]=(std::lower_bound(b+1,b+m+1,(pair){a[i],i})-b),1);
	for(int i=1;i<=Q;++i){
		if(q[i].op==1){
			add(a[q[i].x],-1);
			add(a[q[i].x]=std::lower_bound(b+1,b+m+1,(pair){q[i].v,q[i].x})-b,1);
		}else
			fprintf(out,"%d\n",sum(a[q[i].x]));
	}
	fclose(in);
	fclose(out);
	return 0;
}
```

---

## 作者：SunsetSamsara (赞：30)

## 前言
当我第一眼看到这道题，我想到的是平衡树……

但想想就能知道普及不可能考平衡树

于是……

**~~大家好，我非常喜欢线段树，所以我用线段树通过了通过了这道题~~**

## 分析

简单的修改权值求排名而已嘛……因为插入排序是**稳定排序**，所以权值可以赋值为 $a_i \times n + i - 1$

接下来就是一个值域线段树了。~~还是裸的。~~ 不过空间不够，所以必须动态开点。

## 代码

```cpp
// Author : Luogu Canstant0x5F3759DF
#include <bits/stdc++.h>
#define lld long long
using namespace std;
#define frein(x) freopen(x, "r", stdin)
#define freout(x) freopen(x, "w", stdout)
int n, q;
lld a[10010];
struct node1 {
	int sons[2];
	int vis;
} tr[3000010];
int cnt = 1;
void insert(lld x) {
	int p = 1;
	++ tr[p].vis;
	int b;
	for (int i = 63; i >= 0; -- i) {
		b = (x >> i) & 1;
		if (!tr[p].sons[b])
			tr[p].sons[b] = ++ cnt;
		p = tr[p].sons[b];
		++ tr[p].vis;
	}
}
void remove(lld x) {
	int p = 1;
	-- tr[p].vis;
	for (int i = 63; i >= 0; -- i) {
		p = tr[p].sons[(x >> i) & 1];
		if (!p) return;
		-- tr[p].vis;
	}
}
int query(lld x) {
	int p = 1;
	int ret = 0;
	int b;
	for (int i = 63; i >= 0; -- i) {
		b = (x >> i) & 1;
		if (b) ret += tr[tr[p].sons[0]].vis;
		p = tr[p].sons[b];
		if (!p) return ret;
	}
	return ret;
}
int main() {
	frein("sort.in");
	freout("sort.out");
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; ++ i) {
		scanf("%lld", a + i);
		insert((lld)a[i] * n + i - 1);
	}
	int op, x, v;
	for (int i = 1; i <= q; ++ i) {
		scanf("%d%d", &op, &x);
		if (op == 1) {
			scanf("%d", &v);
			remove((lld)a[x] * n + x - 1);
			a[x] = v;
			insert((lld)a[x] * n + x - 1);
		} else printf("%d\n", query((lld)a[x] * n + x - 1) + 1);
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

---

## 作者：Astatinear (赞：20)


### 本题正解

这个题目麻烦的地方不在于操作 $1$ ，而在于操作 $2$ 他说排完序之后不仅要知道这个数在原数组的哪一个位置上，而且他不会保留这一次的排序结果，这就导致我们在操作 $1$ 修改完值之后不能对原数组直接进行插入思想的排序。 但是如果我们在操作 $2$ 用一个数组来进行排序，最快也需要 $nlogn$ 是肯定会超时的。

所以，我们可以发现，只有操作 $1$ 可以做 $O(n)$ 的操作,操作 $2$ 只能做 $O(1)$ 的操作。

我们可以先维护一个 $tot$ 一维数组，$tot_i$ 表示原数组的第 $i$ 个数字在现在的数组中是排在第几个位置上的。 显然，操作 $2$ 就直接输出 $tot_x$ , 达到了 $O(1)$ 的效果，接下来的难点就是操作 $1$ ，该怎么运用 $\le O(n)$ 的方法，去修改 $tot$ 的值。

我们可以先将原数组进行从小到大排序，并更新 $tot$ 的值，然后每修改一个 $a_x$ ，我们就可以运用冒泡排序的思想，把修改的这个数往前面挤或者往后面挤。(因为数组有序，且只修改了一个数，所以我们只需要将这一个数的顺序改变)。特别要注意的是，当一个被修改的数在往前面挤的时候，我们需要改变 $tot$ 的值，因为它在现在数组的位置改变了。

其余的都没有什么要说的，就是要注意在修改 $tot$ 值的时候不要写错就可以了。

### AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q;
int tot[100005];//要维护的tot数组 
struct node
{
	int a,id;//记得储存这个数在原数组的编号。 
	bool operator <(const node &n)const
	{
		return a<n.a||(a==n.a&&id<n.id);//排序方式 
	}
}arr[100005];
int s;
int main()
{
	//文件输入输出 
 	freopen("sort.in","r",stdin);
 	freopen("sort.out","w",stdout);
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;++i)
	{
		//输入，变换id的值 
		arr[i].id=i;
		scanf("%d",&arr[i].a);
	}
	sort(arr+1,arr+n+1);//排序 
	for(int i=1;i<=n;++i)
	{
		tot[arr[i].id]=i;//第一次排序后，tot的值 
	}
	while(q--)
	{
		//操作 
		int op,x,y;
		scanf("%d%d",&op,&x);
		if(op==1)
		{
			scanf("%d",&y);
			s=tot[x];
			arr[tot[x]].a=y;//由于x是指的原数组的下标，而现在数组的下标是 tot[y] 
			//向前挤 
			for(int i=s-1;i>=1;--i)
			{
				if(arr[i].a>y||(arr[i].a==y&&x<arr[i].id))
				{
					//交换tot值和arr值，注意先后顺序 
					swap(tot[x],tot[arr[i].id]);
					swap(arr[s],arr[i]);
					s=tot[x];
				}
				else
				break;
			}
			//向后挤 
			for(int i=s+1;i<=n;++i)
			{
				if(arr[i].a<y||(arr[i].a==y&&x>arr[i].id))
				{
					swap(tot[x],tot[arr[i].id]);
					swap(arr[s],arr[i]);
					s=tot[x];
				}
				else
				break;
			}
		}
		else
		{
			//O(1)操作，直接输出 
			printf("%d\n",tot[x]);
		}
	}
	return 0;//记得返回0 
}
```

---

## 作者：OMG_wc (赞：16)

这题一眼看下来是个数据结构题，出到入门组T2感觉很怪，最后发现修改操作不超过 $5000$。

$2$ 操作求的是每个位置的排名（rank），注意相等时位置小的数排名更小（这是根据题中给出的代码分析得到的）。

一个正常思维是用平衡树来做，每个元素为一个`std::pair<int,int>`，每次1操作只是删除一个元素，然后再插入一个元素。

这样时间复杂度 $O((n+q)\log n)$ ，用 PDBS 的代码如下：

```c++
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define TR tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>
int a[N];
TR se;
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        se.insert({a[i], i});
    }
    while (m--) {
        int op, x, y;
        scanf("%d", &op);
        if (op == 1) {
            scanf("%d%d", &x, &y);
            se.erase({a[x], x});
            a[x] = y;
            se.insert({a[x], x});
        } else {
            scanf("%d", &x);
            printf("%d\n", se.order_of_key({a[x], x}) + 1);
        }
    }
    return 0;
}
```

明显可以离线做，当然就可以离散化后用树状数组/线段树来解决这个求rank的问题。考虑到是入门组的比赛，我们也可以不用数据结构，改用分治来解决（~~这就很符合大纲了~~），时间复杂度为 $O((n+q)\log(n+q))$。

第一维时间天然有序，第二维是元素大小`pair<int,int>`，分治的时候对其做归并，求出每个区间左半部分的修改操作对右半部分询问的贡献。

代码如下：

```c++
struct Node {
    int x, y, id;
    bool operator<(const Node &rhs) const {
        if (x == rhs.x) {
            if (y == rhs.y) return id < rhs.id;
            return y < rhs.y;
        }
        return x < rhs.x;
    }
} a[N];
int c[N];
int ans[N];

void solve(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    solve(l, mid);
    solve(mid + 1, r);
    int p1 = l, p2 = mid + 1, len = r - l + 1;
    int now = 0;
    for (int i = 0; i < len; i++) {
        if (p1 <= mid && (p2 > r || a[p1] < a[p2])) {
            if (a[p1].id == -1) now--;
            if (a[p1].id == 0) now++;
            p1++;
        } else {
            if (a[p2].id > 0) ans[a[p2].id] += now;
            p2++;
        }
    }
    inplace_merge(a + l, a + mid + 1, a + r + 1);
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    int tot = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &c[i]);
        a[++tot] = {c[i], i, 0};
    }
    int qid = 0;
    for (int i = 1; i <= m; i++) {
        int op, x, y;
        scanf("%d", &op);
        if (op == 1) {
            scanf("%d%d", &x, &y);
            a[++tot] = {c[x], x, -1};
            c[x] = y;
            a[++tot] = {c[x], x, 0};
        } else {
            scanf("%d", &x);
            a[++tot] = {c[x], x, ++qid};
        }
    }
    solve(1, tot);
    for (int i = 1; i <= qid; i++) {
        printf("%d\n", ans[i]);
    }
    return 0;
}
```

当然这题正解时间复杂度应该为 $O(n\log n+5000n+q)$，就是最初排序依次，然后对每个修改，暴力 $O(n)$ 调一下位置，对每个查询就可以 $O(1)$ 得到，代码如下：

```c++
pair<int, int> a[N];
int b[N];// 原来每个位置的数当前的位置

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i].first);
        a[i].second = i;
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++) b[a[i].second] = i;
    while (m--) {
        int op, x, y;
        scanf("%d", &op);
        if (op == 1) {
            scanf("%d%d", &x, &y);
            a[b[x]].first = y;
            for (int i = 1; i < n; i++) {
                if (a[i] > a[i + 1]) swap(a[i], a[i + 1]);
            }
            for (int i = n - 1; i >= 1; i--) {
                if (a[i] > a[i + 1]) swap(a[i], a[i + 1]);
            }
            for (int i = 1; i <= n; i++) b[a[i].second] = i;
        } else {
            scanf("%d", &x);
            printf("%d\n", b[x]);
        }
    }
    return 0;
}
```



---

## 作者：qwqUwU (赞：12)

## 题目大意

要求对数列 $a$ 维护两个操作：

- 单点修改

- 名次查询

其中名次以**权值从小到大**作为第一关键字，在原数组中的先后顺序为第二关键字。

## 题目分析

看到有一句很关键的话：

**对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。**

也就是说可以在只有每次操作一的时候可以跑一次 $O(n)$ 的算法，每次操作二的时候就只能直接输出。

在联系题目名字叫做**插入排序**，那么**肯定不会是直接的插入排序** qwq。

因为每次操作一只会对一个数进行修改，所以可以考虑把正常的插入排序的外层给扒了，只留内层的排序操作，正好是 $O(n)$ 的复杂度。

但在代码实现的时候会有一个问题：

**如何用 $O(1)$ 的复杂度判断你真正修改的位置？**

具体的讲，如果排序时**带上原数列排序**，那么原数列的 $id$ 将会被打乱；而如果**只对 $id$ 进行排序**，那么只能维护新数列得数在原数列的位置 ~~（至少考场上我没想到 qwq）~~。

在这里我的想法是再次定义一个数组 $fid$ 为 $id$ 的**反函数**，然后**带上原数列排序**。

也就是说，最终答案储存在 $fid$ 中。

然后你会发现一个非常有趣的东西：每次真实修改的位置不是 $x$ ，而是 $fid_x$。

那么上面那个问题就迎刃而解了。

至于如何维护 $fid$，直接在每次排序玩之后 $O(n)$ 暴扫就好了 qwq。

可能讲的有点难懂，那就对照着代码理解吧：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define R register
using namespace std;
const int MAXN=8010;
int n,q;
int fid[MAXN];
struct node{
	int val,id;
}a[MAXN];//带上原数列一起排序
inline bool cmp(node x,node y){
	if(x.val==y.val)return x.id<y.id;
	return x.val<y.val;
}
inline void ssort(int x,bool f){//f表示把x往前放还是往后放
	if(f){
		for(R int i=x;i<n;i++){
			if(a[i].val>a[i+1].val||(a[i].val==a[i+1].val&&a[i].id>a[i+1].id)){
				node t=a[i];
				a[i]=a[i+1];
				a[i+1]=t;
			}
			else break;
		}
	}
	else{
		for(R int i=x;i>1;i--){
			if(a[i].val<a[i-1].val||(a[i].val==a[i-1].val&&a[i].id<a[i-1].id)){
				node t=a[i];
				a[i]=a[i-1];
				a[i-1]=t;
			}
			else break;
		}
	}
}
int main(){
//	freopen("sort.in","r",stdin);
//	freopen("sort.out","w",stdout);
	scanf("%d%d",&n,&q);
	for(R int i=1;i<=n;i++){
		scanf("%d",&a[i].val);
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);//初始排序没有那么多讲究，直接排就完了
	for(R int i=1;i<=n;i++)fid[a[i].id]=i;//
	while(q--){
		int op;
		scanf("%d",&op);
		if(op==1){
			R int x,y;
			scanf("%d%d",&x,&y);
			R bool f=a[fid[x]].val<y;
			a[fid[x]].val=y;//真实的修改位置是fid[x]
			ssort(fid[x],f);
			for(R int i=1;i<=n;i++)fid[a[i].id]=i;//重新维护反函数
		}
		if(op==2){
			R int x;
			scanf("%d",&x);
			printf("%d\n",fid[x]);
		}
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```
**The end.Thanks.**

---

## 作者：nydzsf_qwq (赞：11)

#### 解题思路

新开两个数组，一个表示排完序后的结果，另一个表示排序后每个数的位置。

每次修改的时候重新排序并更新位置。

若直接使用 `sort`，时间复杂度为 $O(5000n\log n)$，可能会超时。

但由于仅仅修改了一个数字，可以将这个数字在时间复杂度 $O(n)$ 将这个数插入排完序的数组。

时间复杂度降为 $O(5000n)$，可通过本题。

#### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num,p;
	bool operator < (const node& nd) const {
		if(num==nd.num) return p<nd.p;
		return num<nd.num;
	}
}b[8005];
int t[8005],n,q,a[8005];
void qsort() {
	for(int i=1;i<=n;++i)
		b[i].num=a[i],b[i].p=i;
	sort(b+1,b+n+1);
	for(int i=1;i<=n;++i) t[b[i].p]=i;
}
void upd(int x,int y) {
	b[t[x]].num=y;
	for(int i=1;i<=n+1;++i) {
		if(b[t[x]]<b[i]) {
			if(i<t[x]) {
				for(int j=t[x];j>i;--j) {
					b[j]=b[j-1];
				}
				b[i].num=y,b[i].p=x;
			}
			else {
				for(int j=t[x];j<i-1;++j) {
					b[j]=b[j+1];
				}
				b[i-1].num=y,b[i-1].p=x;
			}
			break;
		}
	}
	for(int i=1;i<=n;++i) t[b[i].p]=i;
}
int main() {
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	qsort();
	b[n+1].num=0x3f3f3f3f,b[n+1].p=n+1;
	while(q--) {
		int op,x,y;
		scanf("%d",&op);
		if(op==1) {
			scanf("%d%d",&x,&y);
			a[x]=y;
			upd(x,y);
		}
		else {
			scanf("%d",&x);
			printf("%d\n",t[x]);
		}
	}
	return 0;
}
```



---

## 作者：BootsH (赞：9)

平衡树裸题。题解非考场思路。

## 分析

1. 此题明显与排序相关。由此，我们可以想到二叉搜索树，进而想到平衡树。

2. 修改直接改上去（修改不是临时的，会影响后面的操作）启示我们平衡树是可行的（要不就变成了可持久化平衡树）。

3. 操作 `2` 询问一个位置，那么。。。这不就是平衡树给值求排名的操作吗？

4. 插排是稳定的，所以要把元素在 $a$ 数组中的位置也记录下来。

## 做法

所以，我们可以建一棵平衡树，一开始插入原始的值（注意，要把其在 $a$ 数组的位置也当作权值记下来，我用的是结构体），$a$ 数组内的值也要记录。

下面约定：$v1$ 为元素在 $a$ 数组的值，$v2$ 为元素在 $a$ 数组中的位置。

对于操作 `1`，我们考虑把给定的值（同时满足 $v1$ 和 $v2$ 相等）找出来，删掉，再插入新的值（插入新的 $v1$ 和 $v2$）。（注：此时的 $v1$ 为原值，即 $a_{p}$；$v2$ 为题目给定的 $p$；新的 $v1$ 为题目给定的 $v$）。

对于操作 `2`，我们考虑用平衡树的给值（原 $v1$ 和 $v2$）求排名操作来暴力解决。（注：原 $v1$ 为给定的 $a_{p}$；原 $v2$ 为给定的 $p$）。

## 代码

快读快写操作等略，看 [这里](https://www.luogu.com.cn/paste/2i2fp17n)

`iget` 为读入 `int` 类型，`iwln` 为输出 `int` 类型数且换行（`int write line` ~~Chinglish 十级 qwq~~）。

我用的平衡树是 fhq treap，常数可能较大（也可能是我写代码自带大常数吧），因此不保证比 $O(5000 \times n + q)$ 快。

时间复杂度 $O(q \times log_{2}{n})$

```cpp
#include <random>

namespace Solution
{
    using namespace AKA;
    using IO::gc; using IO::pc; 
    using IO::iget; using IO::ipr; using IO::iwsp; using IO::iwln;
    using IO::llget; using IO::llpr; using IO::llwsp; using IO::llwln;
    using IO::ullget; using IO::ullwsp; using IO::ullwln;
    using IO::spr; using IO::swsp; using IO::swln;


    constexpr int maxn = 16e4 + 5;

    std::mt19937 ri(std::random_device{}());
    std::uniform_int_distribution<int> lim(1, maxn << 2);

    int size[maxn], ch[maxn][2], pri[maxn], ncnt = 0;
    struct Val
    {
        int v, p;
        bool operator<(const Val& rhs) const
        {
            return v == rhs.v ? p < rhs.p : v < rhs.v;
        }
        bool operator==(const Val& rhs) const 
        {
            return v == rhs.v && p == rhs.p;
        }
        bool operator<=(const Val& rhs) const 
        {
            return (this->operator<(rhs)) || (this->operator==(rhs));
        }
        Val(int v__, int p__):
            v(v__), p(p__) {}
        Val():
            Val(0, 0) {}
    } val[maxn];


    inline void update(int x)
    {
        size[x] = size[ch[x][0]] + size[ch[x][1]] + 1;
    }

    inline int mk(int v, int p)
    {
        size[++ncnt] = 1;
        val[ncnt].v = v; 
        val[ncnt].p = p;
        pri[ncnt] = lim(ri);
        return ncnt;
    }

    int merge(int x, int y)
    {
        if (!x || !y)
        {
            return x + y;
        }
        if (pri[x] < pri[y])
        {
            ch[x][1] = merge(ch[x][1], y);
            update(x);
            return x;
        }
        else  
        {
            ch[y][0] = merge(x, ch[y][0]);
            update(y);
            return y;
        }
        return 0;
    }

    void split(int now, const Val& k, int& x, int& y)
    {
        if (!now)
        {
            x = y = 0;
            return ;
        }
        if (val[now] <= k)
        {
            x = now;
            split(ch[now][1], k, ch[now][1], y);
        }
        else  
        {
            y = now;
            split(ch[now][0], k, x, ch[now][0]);
        }
        update(now);
    }

    int kth(int now, int k)
    {
        while (true)
        {
            if (k <= size[ch[now][0]])
            {
                now = ch[now][0];
            }
            else if (k == size[ch[now][0]] + 1)
            {
                return now;
            }
            else  
            {
                k -= size[ch[now][0]] + 1;
                now = ch[now][1];
            }
        }
        return now;
    }

    int root;

    int a[maxn];


    void main(void)
    {
        #ifndef ONLINE_JUDGE
            std::ifstream cin("sort.in");
            std::ofstream cout("sort.out");
            IO::inbuf = cin.rdbuf(); IO::outbuf = cout.rdbuf();
        #else
            std::ios::sync_with_stdio(false);
            using std::cin; using std::cout;
            #if __cplusplus >= 201103L
                cin.tie(nullptr); cout.tie(nullptr);
            #else
                cin.tie(NULL); cout.tie(NULL);
            #endif
            IO::inbuf = cin.rdbuf(); IO::outbuf = cout.rdbuf();
        #endif


        int n = iget(), general_q = iget();
        int x = 0, y = 0, z = 0;

        for (int i = 1; i <= n; ++i)
        {
            a[i] = iget();
            split(root, Val(a[i], i), x, y);
            root = merge(merge(x, mk(a[i], i)), y);
        }

        while (general_q--)
        {
            int op = iget(), p = iget();
            if (op == 1)
            {
                int v = iget();
                split(root, Val(a[p], p), x, z);
                split(x, Val(a[p], p - 1), x, y);
                y = merge(ch[y][0], ch[y][1]);
                root = merge(merge(x, y), z);
                a[p] = v;
                split(root, Val(a[p], p), x, y);
                root = merge(merge(x, mk(a[p], p)), y);
            }
            else  
            {
                split(root, Val(a[p], p - 1), x, y);
                iwln(size[x] + 1);
                root = merge(x, y);
            }
        }


        #ifndef ONLINE_JUDGE
            cin.close(); cout.close();
        #endif
    }
} // namespace Solution

int main(int argc, const char* argv[])
{
    Solution::main();
    return 0;
}
```


---

## 作者：YoungL (赞：6)

# P7910 [CSP-J 2021] 插入排序 二分题解


[原题传送门](https://www.luogu.com.cn/problem/P7910)

题意很简单，就不废话了。

## 题解

而题目要我们求某个数是在排序后数组的第几位，~~这不就是二分模板题吗~~。

提交之后，很好，WA 了。

### 为什么呢？

**插入排序是个稳定的排序方法**

注意，我们要求的这个 “排名” 还需要考虑相同数下标间的关系，比如：

$ {3, 2, 2} $ 这个数组，我们要查找第 3 位也就是 2 这个数的排名。

这个数组排序之后就是 $ {2, 2, 3} $。

还是那句话，**插入排序是个稳定的排序方法**，所以，我们这里要查找的是第二个 2，也就是排序后数组的第二个 2。(*这句话是核心，如果没看懂可以多读几遍。*)

那我们应该怎样判断下标呢？答：**结构体**。

```cpp
struct number {
    int x, i;  // x记录值，i记录下标
};
```

然后，我们还需要写出判断的函数（重载运算符）：

```cpp
bool operator<(const number& a, const number& b) {
    return a.x == b.x ? a.i < b.i : a.x < b.x;
}
```

完成后，进行下一步。

#### 我们可以选择两种做法：
- 自己写二分
- lower_bound 大法

在这里，我们选用 lower_bound。

接下来的就很简单了，修改就 lower_bound 先删除旧的，添加新，查找就直接搜就行了。

#### 最后，注意一下细节：
- 选用 vector
- lower_bound 后要 - vec.begin() + 1（输出下标从1开始，vector 从0开始）
- 数组开足够大

这样，查询操作是 $ O(\log n) $ 的，修改操作是 $ O(n) $ 的（insert、erase 的复杂度），而修改操作不超过 5000 次，不会超时。

空间复杂度：$ O(n) $。

跑得还是挺快的，最慢的也就[60ms](https://www.luogu.com.cn/record/148272622)。
# 代码
```cpp
// Created by YoungL
#include <bits/stdc++.h>

// 不使用 using namespace std 是个好习惯
const int MAX_N = 2e5 + 5;  // 其实8005就够了
int n, Q;
struct number { int x, i; } a[MAX_N];  // 带下标的数
std::vector<number> vec;

// 重载运算符
bool operator<(const number& a, const number& b) {
    return a.x == b.x ? a.i < b.i : a.x < b.x;
}

#define OJ

signed main() {
    // 比赛的时候要写freopen啊
#ifndef OJ
    freopen("sort.in", "r", stdin);
    freopen("sort.out", "w", stdout);
#endif

    scanf("%d%d", &n, &Q);
    for (int i=1; i<=n; i++) {
        int x;
        scanf("%d", &x);
        vec.push_back(a[i] = (number){x, i});  // vector和a数组同时更新
    }
    std::sort(vec.begin(), vec.end());  // 对vector排序
    for (int i=1; i<=Q; i++) {
        int x, v, op;
        scanf("%d%d", &op, &x);
        if (op == 1) {
            scanf("%d", &v);
            vec.erase(std::lower_bound(vec.begin(), vec.end(), a[x]));  // 先删除
            a[x].x = v;  // 修改
            vec.insert(std::lower_bound(vec.begin(), vec.end(), a[x]), a[x]);  // 再插入
        }
        else {
            printf("%lld\n", std::lower_bound(vec.begin(), vec.end(), a[x])-vec.begin()+1);  // 记得+1，因为下标原因
        }
    }
    
    // fclose是个好习惯
#ifndef OJ
    fclose(stdin);
    fclose(stdout);
#endif
    return 0;
}
```

---

## 作者：Harry_Hedwig (赞：6)

# 0x00 思路
（此处省去前面的一大堆无用描述）
>H 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的**所有元素均为非负整数**。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：

>$1~x~v$：将 $a$ 的第 $x$ 个元素修改为 $v$。保证 $1 \le x \le n$，$1 \le v \le 10^9$ 。注意这种操作**会**改变数组的元素，修改得到的数组会被保留，也会影响后续的操作。

>$2~x$：假设 H 老师**按照上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的**第 $x$ 个元素**在排序后的新数组所处的位置。保证 $1 \le x \le n$。注意这种操作**不会**改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作。

>H 老师不喜欢过多的修改，所以他保证**类型 $1$ 的操作次数不超过 $5000$**。

那么这里我们发现它提到了前面的伪代码，即
```c
C/C++:
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}

Java:
for i:=1 to n do
	for j:=i downto 2 do
		if a[j]<a[j-1] then
			begin
				t:=a[i];
				a[i]:=a[j];
				a[j]:=t;
			end;
```
而这个排序方法是把整个数组**从小到大**进行排序，所以我们在做这道题的时候也应该**从小到大**进行排序。


如果你想要**老老实实**地用插入排序并且**每一次询问**都要进行查找，那么你一定会 TLE。

接着，我们发现了这句话：
>H 老师不喜欢过多的修改，所以他保证**类型 $1$ 的操作次数不超过 $5000$**。

也就是说，修改操作次数**最多**为 $5000$ 次。那么剩下的操作**一定都是**查询操作。

因此，我们应该对查询进行优化（不应在每次**询问**的时候进行排序，而应该在**修改时**进行排序）。
# 0x01 优化
既然我们要优化**时间**，那么我们肯定需要更多的**空间**进行交换。（算法虽然也有可能，但是这里我们不好进行优化。）于是我们就可以想到将每一个数在插排后的位置进行记录，这样我们就做到了每一次查询时间为 $O(1)$ 的极大优化。当然在我们记录位置的时候肯定不可能排一次全部刷新一次。

根据实验，我们刷新的**仅仅只是**当前被修改的数和与它交换过的数，所以我们在插入排序时可以边排边更新值。

因此我们的时间的最大为 $O(5000\times n+Q)$。

# code
```c
#include<bits/stdc++.h>
using namespace std;
inline void qr(int &ret){int x=0,f=0;char ch;ch=getchar();while(ch<'0'||ch>'9')f|=ch=='-',ch=getchar();while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();ret=f?-x:x;return;}
//快读，可以不看。

typedef struct N
{
	int id,num;
}NUMBER;//需要记录此位置数字的值和编号，好进行更新
NUMBER a[8005];
int num[8005],wei[8005]/*此编号的数字所在位置*/;
bool cmp(NUMBER a,NUMBER b)
{
//从小到大进行排序，若数值相等必须将编号小的放在前面
	if(a.num==b.num)
		return a.id<b.id;
	return a.num<b.num;
}
int main()
{
// 	freopen("sort.in","r",stdin);
// 	freopen("sort.out","w",stdout);
	int n,i,Q,q,x,v;
	qr(n),qr(Q);
	for(i=1;i<=n;i++)
	{
		qr(num[i]);
		a[i].num=num[i];
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmp);//先将其变成有序序列
	for(i=1;i<=n;i++)//初始化位置
		wei[a[i].id]=i;
	for(i=1;i<=Q;i++)
	{
		qr(q);
		if(q==1)//修改操作
		{
			qr(x),qr(v);
			num[x]=v;
			a[wei[x]].num=v;
			int j=wei[x]+1;
			NUMBER t=a[wei[x]];
			//插入排序
			while(j<=n&&(a[j].num<v||(a[j].num==v&&a[j].id<x)))//往后插
			{
				wei[a[j].id]--;
				a[j-1]=a[j];
				a[j]=t;
				j++;
			}
//			puts("Aaa");
			if(j-1==wei[x])//往前插
			{
				j=wei[x]-1;
				while(j>0&&(a[j].num>v||(a[j].num==v&&a[j].id>x)))
				{
					wei[a[j].id]++;
					a[j+1]=a[j];
					a[j]=t;
					j--;
				}
				wei[x]=j+1;
			}
			else//修改在前面没有改掉的值
				wei[x]=j-1;
//			for(i=1;i<=n;i++)
//				printf("%d:%d %d\n\n",i,a[i].id,wei[a[i].id]);
		}
		if(q==2)//查询操作，有什么好说的
		{
			qr(x);
			printf("%d\n",wei[x]);
		}
	}
	return 0;
}
```

---

## 作者：言琢დ (赞：5)

**upd：修改部分表述。**

观察数据范围，发现给的 $n$ 是平方级别的数据范围。

但是 $q$ 是线性或者带一个 $\log$ 的范围，于是又观察到操作 $1$ 的执行次数 $\le5000$ 次。

所以说我们就可以得到：

每次操作 $1$ 之后线性扫描一遍，之后 $O(1)$ 或者 $O(\log)$ 查询答案是我们可以接受的复杂度。

首先考虑操作 $1$ 之后，给我们带来的影响是一遍排序，而已知最优排序是 $O(n\log n)$，简单算一下之后发现不太能过。

**考虑桶排**，如果我们把有贡献的数字离线下来，顶多不会超过 $8000+5000=13000$ 个数，记为 $k$，也就是说 $k\le13000$。

然后离散化一下可以缩小值域，至此我们每次操作 $1$ 之后是 $O(k)$ 的复杂度就能排序完整个序列。

注意到这个有重复元素，所以再多记录一些信息就好了。

具体而言，需要知道每个数字在对应位置上是第几次出现，还是由于 $n\le8000$ 所以这些信息全部都可以线性扫描维护，每次操作全部更新一遍，这就不难了。

详见代码。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define findb(x) std::lower_bound(b+1,b+1+len,x)-(b)
#define findc(x) std::lower_bound(c+1,c+1+c[0],x)-(c)
inline int in();
inline void wr(int);
const int N=(int)8e3+5,M=(int)5e3+5,K=(int)2e5+5;
int a[N],b[N+M],c[N];
struct Node{
	int tp,x,v;
}s[K];
int tong[N+M],len,times[N+M],pos[N];
// times[i]: i 出现了几次
// pos[i]: a[i] 第几次出现
inline void translate();
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("7910.in","r",stdin);
	freopen("7910.out","w",stdout);
#endif
	register int n=in(),q=in();
	for(register int i=1;i<=n;++i)
		b[i]=a[i]=in();
	len=n;
	for(register int i=1;i<=q;++i){
		s[i].tp=in();
		if(s[i].tp==1){
			s[i].x=in(),s[i].v=in();
			b[++len]=s[i].v;
		}
		else
			s[i].x=in();
	}
	std::stable_sort(b+1,b+1+len);
	len=std::unique(b+1,b+1+len)-(b+1);
	for(register int i=1;i<=n;++i)
		a[i]=findb(a[i]);
	for(register int i=1;i<=q;++i)
		if(s[i].tp==1)
			s[i].v=findb(s[i].v);
	for(register int i=1;i<=n;++i)
		++tong[a[i]];
	memset(times,0,sizeof(times));
	for(register int i=1;i<=n;++i)
		pos[i]=++times[a[i]];
	translate();
	for(register int i=1;i<=q;++i)
		if(s[i].tp==2){
			// 查询
			register int id=findc(a[s[i].x]);
			wr(id+pos[s[i].x]-1),putchar('\n');
			//  1 2 3 4 5
			//  5 5 5 5 5
			//  ^
		}
		else{
			// 修改
			--tong[a[s[i].x]];
			a[s[i].x]=s[i].v;
			++tong[a[s[i].x]];
			memset(times,0,sizeof(times));
			for(register int i=1;i<=n;++i)
				pos[i]=++times[a[i]];
			translate();
		}
}
inline void translate(){
	c[0]=0;
	for(register int i=1;i<=len;++i){
		register int x=tong[i];
		while(x--)
			c[++c[0]]=i;
	}
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

---


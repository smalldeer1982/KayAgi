# [CSP-J 2022] 上升点列

## 题目描述

在一个二维平面内，给定 $n$ 个整数点 $(x_i, y_i)$，此外你还可以自由添加 $k$ 个整数点。

你在自由添加 $k$ 个点后，还需要从 $n + k$ 个点中选出若干个整数点并组成一个序列，使得序列中任意相邻两点间的欧几里得距离恰好为 $1$ 而且横坐标、纵坐标值均单调不减，即 $x_{i+1} - x_i = 1, y_{i+1} = y_i$ 或 $y_{i+1} - y_i = 1, x_{i+1} = x_i$。请给出满足条件的序列的最大长度。

## 说明/提示

**【样例 \#3】**

见附件中的 `point/point3.in` 与 `point/point3.ans`。

第三个样例满足 $k = 0$。

**【样例 \#4】**

见附件中的 `point/point4.in` 与 `point/point4.ans`。

**【数据范围】**

保证对于所有数据满足：$1 \leq n \leq 500$，$0 \leq k \leq 100$。对于所有给定的整点，其横纵坐标 $1 \leq x_i, y_i \leq {10}^9$，且保证所有给定的点互不重合。对于自由添加的整点，其横纵坐标不受限制。

| 测试点编号 | $n \leq$ | $k \leq$ | $x_i,y_i \leq$ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10$ | $0$ | $10$ |
| $3 \sim 4$ | $10$ | $100$ | $100$ |
| $5 \sim 7$ | $500$ | $0$ | $100$ |
| $8 \sim 10$ | $500$ | $0$ | ${10}^9$ |
| $11 \sim 15$ | $500$ | $100$  | $100$ |
| $16 \sim 20$ | $500$ | $100$ | ${10}^9$ |


## 样例 #1

### 输入

```
8 2
3 1
3 2
3 3
3 6
1 2
2 2
5 5
5 3```

### 输出

```
8```

## 样例 #2

### 输入

```
4 100
10 10
15 25
20 20
30 30```

### 输出

```
103```

# 题解

## 作者：XTianShuo (赞：200)

正式比赛中一遍切的动态规划真不多见(⊙o⊙)…，本题解，与上面两个题解有略微不同。

## 题目概述
在一个二维平面内，给定 $n$ 个整数点 $(x_i, y_i)$，此外你还可以自由添加 $k$ 个整数点。

你在自由添加 $k$ 个点后，还需要从 $n + k$ 个点中选出若干个整数点并组成一个序列，使得序列中任意相邻两点间的欧几里得距离恰好为 $1$ 而且横坐标、纵坐标值均单调不减，即 $x_{i+1} - x_i = 1, y_{i+1} = y_i$ 或 $y_{i+1} - y_i = 1, x_{i+1} = x_i$。请给出满足条件的序列的最大长度。  
$n \leq 500$，$k \leq 100$，$x_{i},y_{i} \leq 10^9$。

## 思路概述

看完题面，是不是有点像二维最长不下降子序列？所以考虑 $dp$。
这么小的数据范围，我们可以使用三次方级别的算法通过。  


首先我们需要对输入的点进行排序，以 $x$ 为第一关键字，以 $y$ 为第二关键词，方便我们未来状态的转移。

设状态 $f_{i,j}$ 为枚举到第 $i$ 个点，我们还剩余 $j$ 个添加自由点的机会，此时满足题意的点的最大长度。  
易得如下方程。
$$f_{i,j}=\max(f_{k,j+d}+d+1)$$
$$k\in \left[1,i-1\right]$$
$$d=\operatorname{abs}(x_{i}-x_{k})+\operatorname{abs}(y_{i}-y_{k})-1$$

最终答案为 $\max(f_{i,j}+j)  \ j \in [0,k]$。  
复杂度为 $O(n^2k)$。

你可能有几个疑惑。  
$d$ 是什么呢？$d$ 就是在点 $x$ 和点 $y$ 之间，我们需要加多少个自由点才能满足题意。  
为什么最终方程里转移的时候我们要加一呢？因为我们不仅仅加上中间加的点呀，我们还需要把 $y$ 点给加上。  
还有一些小细节在下方代码中有注释。


到这里基本上你已经理解了本题的解题过程，先尝试自己写一下代码，再看下方给出的代码吧。

## code
代码中在重要部分/细节处有注释解释。
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=510,K=110;

int n,k;
struct node{
	int x,y;
	bool operator< (const node &w) const
	{
		if(x==w.x)	return y<w.y;
		return x<w.x;
		//此处为运算符重载，这里的意思就是以x为第一关键字，以y为第二关键词从小到大进行排序
	}
}a[N];
int f[N][K];

int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
	{
		f[i][k]=1;
		for(int j=0;j<=k;j++)
		{
			for(int t=1;t<i;t++)
			{
				if(a[t].x>a[i].x||a[t].y>a[i].y)	continue;//要符合题意的序列限制
				int dx=abs(a[i].x-a[t].x);
				int dy=abs(a[i].y-a[t].y);
				int d=dx+dy-1;//求在x,y之间我们要加多少个自由点
				if(j+d>k)	continue;//如果要加的自由点超过k个，就不能再转移了
				f[i][j]=max(f[i][j],f[t][j+d]+d+1);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=k;j++)
		{
			ans=max(ans,j+f[i][j]);
			//因为我们最终可能有剩余的自由点，所以在取答案的时候，我们需要再加上剩余的自由点数量
		}
	cout<<ans;
	return 0;
}
```
代码较丑，不喜勿喷。

---

## 作者：Wi_Fi (赞：91)

与本年 T2 一样，仍然是一道不符合 CSP 风格的题目。所以说很容易看出，这是一道很模板的 DP。

题目大意：从 $  n $ 个坐标中选择若干个，使得横坐标不减，且纵坐标不减，同时可以插入 $ k $ 个任意位置的点，使得选择的点和差入的点相邻两个点之间距离为 1，求最大点的数量。

考虑一个更简单的问题：令 $ k = 0 $ ，则问题变成了从 $ n $ 个坐标中选择若干个，使得横坐标不减，且纵坐标不减，相邻点之间距离为 1，求最大点数。

感觉有一种熟悉的味道？没错，就是最长上升子序列！此时容易想到对 $ n $ 个点排序，先按横坐标排序，再按纵坐标排序。如此，再对这 $ n $ 个点求最长上升子序列即可。

记 $ f[i] $ 为以 $ i $ 结尾的最长上升点序列最大长度，则有：  
若 $ {j\in[1,i-1]} $ ，则 $ f[i] = \max ( f[i], f[j] + 1 ) $

此时，我们再考虑 $ k > 0$，只需对上述状态增加一维，记 $ f[i][p] $ 为以$ i $结尾，且已经插入了 $ p $ 个额外点的最长上升点序列最大长度，则有：

若 ${ j\in[1,i-1], p\in[d,k] }$ ，则 $ f[i][p] = \max ( f[i][p] , f[j][p-d] + d + 1 )$ $ d = a[i].x - a[j].x + a[i].y - a[j].y - 1 $


**所以推得动态转移方程为：**

```cpp
int d=a[i].x-a[j].x+a[i].y-a[j].y-1;
......
f[i][p]=max(f[i][p],f[j][p-d]+d+1);
```

当然，别忘了初始化：
给定一个点 $ i $ ，可以在前面插入 $ j $ 个点，怎么插入上升点列最长？
当然是直接插入 $ j $ 个点！

```cpp
for(i=1;i<=n;i++)
{
	for(j=0;j<=k;j++)f[i][j]=j+1;
}
```

**完整代码**

```cpp
#include <bits/stdc++.h>

using namespace std;
#define x first
#define y second
int i,j,p,n,k,f[505][105]; // f[i][j]: 前 i 个点，插入了 j 个点后最大长度
pair<int,int>a[505];
int main()
{
	cin>>n>>k;
	for(i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1);
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=k;j++)f[i][j]=1+j; // 直接在 i 点前插入 j 个点
	}
	// 类似最长上升子序列
	for(i=2;i<=n;i++)
	{
		for(j=i-1;j>=1;j--) // j -> i
		{
			if(a[j].y>a[i].y)continue;
			// 从 j 到 i 要插入 d 个点才能满足
			int d=a[i].x-a[j].x+a[i].y-a[j].y-1;
			for(p=d;p<=k;p++)f[i][p]=max(f[i][p],f[j][p-d]+d+1);
		}
	}
	int ans=0;
	for(i=1;i<=n;i++)ans=max(ans,f[i][k]);
	cout<<ans;
	return 0;
}

```


---

## 作者：lizhous (赞：35)

## 分析

显然是 DP。防止歧义，我们称输入的 $k$ 为 $K$。

先假设没有加点操作。可以设 $f_i$ 表示最后一个点为 $i$ 时最长上升点列。转移枚举一个可以作为上一个点的点 $v$，取 $\max\limits f_v$ 即可。

加入加点操作后，我们发现不相邻点也可以通过加点实现转移。上述 DP 也无法维护当前加了多少点，所以多开一维记录加点次数。设 $f_{i,j}$ 表示以点 $i$ 为最后一个非加点的点，共加 $j$ 个点组成的最长上升点列。转移 $i$ 时枚举一个可以作为上一个点的点 $j$ 满足 $x_i\ge x_j$ 且 $y_i \ge y_j$，通过加点拼接，即 $f_{i,k}=\max f_{j,k-dis_{i,j}}+dis_{i,j}$。其中 $dis_{i,j}$ 表示点 $i$ 到点 $j$ 之间至少要添加多少个点才能组成上升点列，先走行在走列即可，也就是 $|x_i-x_j|+|y_i-y_j|$。最终答案记得统计最后一个点后还可以加点的情况，也就是 $\max\limits^{n}_{i=1}\max\limits_{k=1}^{K}f_{i,k}+(K-k)$。时间复杂度为 $O(n^2k)$。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int n,k,ans,f[505][105];
struct poin
{
	int x,y;
}point[1001];
bool cmp(poin a,poin b)
{
	if(a.x==b.x)
	{
		return a.y<b.y;
	}
	return a.x<b.x;
}
int get(int xa,int ya,int xb,int yb) //计算dis
{
	return max(xa-xb,xb-xa)+max(ya-yb,yb-ya)-1;
}
signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&point[i].x,&point[i].y);
	}
	sort(point+1,point+n+1,cmp); //点按xy排序，保证可以转移的点已被DP
	for(int i=1;i<=n;i++) //当前点
	{
		for(int z=0;z<=k;z++) //加点次数
		{
			f[i][z]=z+1;
			for(int j=1;j<i;j++) //上一点
			{
				int lent=get(point[i].x,point[i].y,point[j].x,point[j].y); //点i到点j之间至少要添加多少个点才能组成上升点列
				if(z-lent<0||point[i].y<point[j].y) continue; //不合法跳出
				f[i][z]=max(f[i][z],f[j][z-lent]+lent+1); //转移一下
				ans=max(ans,f[i][z]+k-z); //更新答案
			}
		}
	}
	printf("%lld",ans);
}
```


---

## 作者：Eternality (赞：26)

这道题其实是一道还算挺常规的动归。
不过好像还没有记忆化搜索的题解，我来凑一篇。
（众所周知记忆化比正常动归思维难度小一些）。

## 题意描述
给你 $n$ 个二维平面上的点，再给你一些可以自由选择的 $k$ 个点，让你用这 $n$ 加 $k$ 个点组成最长不下降子序列。（这些点必须是连续的，也就是说必须两个相邻的点之间的平面距离）。

数据范围：保证对于所有数据满足：$1 \leq n \leq 500$，$0 \leq k \leq 100$。给定的整点，其横纵坐标 $1 \leq x_i, y_i \leq {10}^9$。

## 大体思路

其实记忆化的思路很简单。

先来说说我设计的状态： $dp_{i,j}$ 表示第 $i$ 个点及它之后的点的最大数量，且此时还有 $j$ 个自由点可供选择。

状态转移方程也很好想到，由它后边的第 $x$ 个点转移，即   
$$dp_{i,j} = \max (dp_{i,j}, dp{x,j-pot_{i,x}} + pot_{i,x})$$
其中 $pot_{i,x}$ 就是第 $i$ 个点和第 $x$ 个点之间有几个点。

转移约束条件：这两个点之间的点的数量小于等于 $j$ 且保证后边点的 $y$ 要大于等于当前点的 $y$。

边界：当到一个点不能被更新时，返回 $1+k$ 即可（即它本身和后边还能放几个）。

注意先将这些点按坐标从小到大排序，横坐标为第一关键字，纵坐标为第二关键字，这样判断转移条件的时候就直接枚举后边的点，只判断纵坐标就好了。

下边是代码。
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=510;
int n,k,dp[N][N];

struct T
{
	int x,y;
}t[N];

bool cmp(T a,T b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}

int pot(T a,T b)
{
	return b.x-a.x+b.y-a.y-1;
}

int dfs(int id,int k)
{
	if(dp[id][k])return dp[id][k];
	bool flag=true;
	for(int i=id+1;i<=n;i++)
	{
		if(t[i].y>=t[id].y&&k>=pot(t[id],t[i]))
		{
			dp[id][k]=max(dp[id][k],dfs(i,k-pot(t[id],t[i]))+pot(t[id],t[i])+1);
			flag=false;
		}
	}
	if(flag)return dp[id][k]=k+1;
	return dp[id][k];
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&t[i].x,&t[i].y);
	}
	sort(t+1,t+1+n,cmp);
	int maxx=0;
	for(int i=1;i<=n;i++)
	{
		maxx=max(maxx,dfs(i,k));
	}
	cout<<maxx;
	return 0;
}
```

---

## 作者：Jasper08 (赞：18)

我们先将所有点按 $x$ 坐标从小到大排序（$x$ 坐标相同的按 $y$ 坐标从小到大排序）。

我们用 $f_{i,j}$ 表示取到前 $i$ 个点，添加了 $j$ 个点的最长连续上升点列长度。初始时，由于单独的一个点算一个长度为 $1$ 的上升点列，所以 $f_{i,0}=1$；又因为在此基础上我们可以添加 $j$ 个点，所以 $f_{i,j}=j+1$。

接下来考虑转移。$f_{i,j}$ 显然可以由两种情况转移而来：

1. 取到第 $i$ 个点时没有添加点，此时 $f_{i,j}=f_{i-1,j}$。

2. 在第 $t$ 个点的基础上 $(t<i)$，添加了一些点。由于第 $t$ 个点到第 $j$ 个点之间至少要 $p=x_j-x_t+y_j-y_t-1$ 个点才能构成一个上升点列，所以当 $p\ge j$ 时，$f_{i,j}=f_{t,j-p}+p+1$；$p<j$ 时，$f_{i,j}=j+1$。

综上所述，状态转移方程即为：

$$
f_{i,j}=\max_{1\le t<i}\left\{j+1,f_{i-1,j},f_{t,j-p}+p+1\right\} 
$$

其中，$p=x_j-x_t+y_j-y_t-1$。

最终的答案即为 $\max_{1\le i\le n}f_{i,k}$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 510, K = 110;

struct Dot {
    int x, y;
} d[N];

int n, k, ans;
int f[N][K];

bool cmp(Dot a, Dot b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) {
        int x, y;
        scanf("%d%d", &d[i].x, &d[i].y);
    }
    sort(d+1, d+n+1, cmp);

    // for (int i = 1; i <= n; ++i) printf("%d %d\n", d[i].x, d[i].y);

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j)
            f[i][j] = j+1;
    }
    for (int i = 2; i <= n; ++i) {
        for (int t = 1; t < i; ++t) {
            if (d[t].y > d[i].y) continue;

            int p = d[i].x - d[t].x + d[i].y - d[t].y - 1;
            for (int j = 0; j <= k; ++j) {
                if (j >= p) f[i][j] = max(f[i][j], f[t][j-p]+p+1);
                else f[i][j] = max(f[i][j], j+1);
            }
        }
    }

    for (int i = 1; i <= n; ++i) ans = max(ans, f[i][k]);
    printf("%d\n", ans);
    system("pause");
    return 0;
}
```

---

## 作者：Forever1507 (赞：15)

应该是我参加过的正式比赛中唯一一个完整切掉的动态规划（）

先以 $x$ 递增为第一关键字，$y$ 递增为第二关键字排序。

这样至少保证 $x$ 是单调不减的。之后再判一下 $y$ 坐标是否单调不减即可。

定义状态 $dp_{i,j}$ 表示前 $i$ 个点，加了 $j$ 个自由点的答案。
（显然可以发现，自由点一定能满足单调不减。）

转移直接枚举从哪个点转移过来，中间需要加的点就是两点之间距离减去 $1$。

然后再枚举用了多少个自由点，暴力转移即可。

最后有一个细节，我并不知道**用了多少个自由点和在哪个点结束**，所以要枚举，最后还要把剩下的自由点加上。

虽然时间复杂度特别垃圾，但是毕竟数据范围有这么小对吧。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,dp[505][105];
struct node{
	int x,y;
}p[505];
int dist(int i,int j){
	return abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y);
}
bool cmp(node a,node b){
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i){
		cin>>p[i].x>>p[i].y;
	}
	sort(p+1,p+n+1,cmp);
	for(int i=1;i<=n;++i)dp[i][0]=1;
	for(int i=1;i<=n;++i){
		for(int r=1;r<i;++r){
			if(p[r].y>p[i].y)continue;//维护单调
			int K=dist(i,r)-1;
			for(int j=K;j<=k;++j){
				dp[i][j]=max(dp[i][j],dp[r][j-K]+K+1);
			}
		}
	}
	int ans=0;//枚举取最大
	for(int i=1;i<=n;++i)for(int j=0;j<=k;++j)ans=max(ans,dp[i][j]+k-j);
	cout<<ans;
	return 0;
} 
```


---

## 作者：Bot_wxt1221 (赞：14)

[题目传送门](/problem/P8816)



**简化题意**：二维平面上有 $n$ 个点，还可以再添加 $k$ 个点，坐标要求是整数，选取一个点序列使得序列中每个点个横纵坐标非严格单调递增且满足 $x_{i+1}-x_{i}=1$、$y_{i+1}=y_{i}$ 或 $y_{i+1}-y_{i}=1$、$x_{i+1}=x_{i}$，序列最长是多少。

**错误思路**：按照坐标排序选取其中一段是不对的，具体可以手推样例，根本不可能从 $(3,6)$ 跑到 $(5,3)$，但是按照这样的思路一定是连起来的。

**正解**：在对着坐标轴发呆后，突然发现可以用中转的思想，一看 $0\leq n \leq 500$，Floyd 走一波，初始化为两点的曼哈顿距离减 $1$，跑一遍 Floyd 跑出两点连通需要加的最少边。

**细节**：可能两个连接后还可以加点，直接无脑加在最后，所以统计时要加上 $k-map_{i,j}$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
long long read(){
	char temp=getchar();
	long long f=1,x=0;
	while('0'>temp||temp>'9'){
		(temp=='-')?(f=-1):0;
		temp=getchar();
	}
	while('0'<=temp&&temp<='9'){
		x=(x<<3)+(x<<1)+(temp^'0');
		temp=getchar();
	}
	return f*x;
}
long long x[505];
long long y[505];
long long map[505][505];
int mian(){
// 	freopen("point.in","r",stdin);
// 	freopen("point.out","w",stdout);
	int n=read();
	int k=read();
	for(int i=1;i<=n;i++){
		x[i]=read();
		y[i]=read();
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j){
				map[i][j]=0;
			}else if(x[j]>=x[i]&&y[j]>=y[i])
				map[i][j]=abs(x[i]-x[j])+abs(y[i]-y[j])-1;
			else{
				map[i][j]=0x3f3f3f3f3f3f3f3fll;
			}
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
			}
		} 
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(map[i][j]<=k){
				ans=max(ans,abs(x[i]-x[j])+abs(y[i]-y[j])+(k-map[i][j])+1);
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

欢迎到博客看其他题解。

**UPD：感谢机房巨巨巨巨巨佬 gyc 指正曼哈顿距离和欧几里得距离的区别。**

---

## 作者：liujy_ (赞：13)

 说实话这道题最为最后一题稍微简单了，这篇题解将从部分分到正解把我的赛时想法展现出来。  
 $1.$ $k=0$        
 看完题面，这道题好像最长上升子序列的模板题哎！那我们肯定先把所有的点按坐标从左到右再从下至上排序。接下来应该怎么办呢？  
 要是没有添加点的操作就可以直接 $O(n^2)$ 做了呢。看一看有 $45$ 分 $k=0$ 的分耶！于是我们设 $dp_i$ 表示以第排序后的第 $i$ 个点的最大长度。  
 显然 $dp_i=\max_{j=1}^i{dp_j+1}$，其中 $j$ 一定要判断可以到达 $i$ 才可以转移。  
 $2.$ $x_i,y_i\le100$  
 然后我又看向了 $x_i,y_i\le100$ 的点，这两档分加起来就有 $75$ 了呢！于是我们设 $f_{i,j,l}$ 表示以坐标 $(i,j)$ 作为最后一个点，且一共添加了 $l$ 个点的最大长度。  
 如果 $(i,j)$ 本身存在的话，$f_{i,j,l}=\max(f_{i-1,j,l}+1,f_{i,j-1,l}+1)$。 如果 $(i,j)$ 不在给定的点中，那么 $f_{i,j,l}=\max(f_{i-1,j,l-1}+1,f_{i,j-1,l-1}+1)$。  
 $3.$ 正解  
 基于第一部分，我们可以之间枚举当前点从哪个点转移过来，显然两个点之间需要添加的点的个数是确定的，我们设 $c_{i,l}$ 表示以第 $i$ 个点作为结尾，且添加了 $l$ 个点的最大长度。显然 $c_{i,l}=\max_{j=1}^i{c_{j,l-d}+d+1}$，其中 $j$ 一定要判断可以到达 $i$ 才可以转移，$d$ 表示点 $j$ 到 $i$ 之间需要添加的点数，$d=x_i-x_j+y_i-y_j-1$。注意最后一个点不一定是已经存在的点，所以还要枚举一下把剩下还可以添加的点加在点 $i$ 后面的长度。  
 最后附上赛时代码。其实只需要 $work3$ 这个函数就可以啦，另外两个是部分分。  
 ```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,k,ans,dp[105],f[105][105][105],c[105][105],mx;bool p[105][105];
struct node{
	int x,y;
	bool operator < (node b)const{
		if(x==b.x)return y<b.y;
		return x<b.x;
	}
}a[505];
void work1(){
	for(int i=1;i<=n;i++){
		dp[i]=1;
		for(int j=1;j<i;j++)
			if(a[i].x-a[j].x==1&&a[i].y==a[j].y||(a[i].y-a[j].y==1&&a[i].x==a[j].x))dp[i]=max(dp[i],dp[j]+1);
		ans=max(ans,dp[i]);
	}
}
void work2(){
	for(int i=1;i<=n;i++)p[a[i].x][a[i].y]=1;
	for(int i=1;i<=100;i++)
		for(int j=1;j<=100;j++){
			if(p[i][j]){
				for(int l=0;l<=k;l++){
					f[i][j][l]=max(f[i-1][j][l]+1,f[i][j][l]);
					f[i][j][l]=max(f[i][j-1][l]+1,f[i][j][l]);
					ans=max(ans,f[i][j][l]);
				}
			}else{
				for(int l=1;l<=k;l++){
					f[i][j][l]=max(f[i-1][j][l-1]+1,f[i][j][l]);
					f[i][j][l]=max(f[i][j-1][l-1]+1,f[i][j][l]);
					ans=max(ans,f[i][j][l]);
				}
			}
		}
}
void work3(){
	for(int i=1;i<=n;i++){
		c[i][0]=1;
		for(int j=i-1;j>=1;j--){
			if(a[j].x>a[i].x||a[j].y>a[i].y)continue ;
			int x=a[i].x-a[j].x+a[i].y-a[j].y-1;
			for(int l=x;l<=k;l++)c[i][l]=max(c[j][l-x]+x+1,c[i][l]);
		}
		for(int l=0;l<=k;l++)ans=max(c[i][l],ans);
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=k;j++)
			ans=max(ans,c[i][j]+(k-j));
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		mx=max(a[i].x,a[i].y);
	}
	sort(a+1,a+n+1);
	if(k==0)work1();
	else if(mx<=100)work2();
	else work3();
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Pengzt (赞：12)

[P8816](https://www.luogu.com.cn/problem/P8816)

提供一种不一样的做法。

首先将每个点以横坐标为第一关键字，纵坐标为第二关键字排序。

一维的 dp 肯定不够，因为 dp 既要存最多点数，又要保存自由点的点数。

赛时没看 $k$ 的范围，于是开了一个结构体。

$dp_i.w$ 表示从当前起点开始且于 $i$ 点结束的最多的点数，$dp_i.ned$ 表示达到点数所需的最少的自由点的点数。

从其左下部分的点转移即可。

但如果直接转移，这个 dp 的正确性无法保证，即左部点稀疏而右部点稠密时就会出错。

枚举一个起点 $st$，就可以保证 dp 的正确性了。

因为原 dp 出错只能是该点到起点的距离太长，以至于连接后面的稠密点时，自由点不足，此时正解的所选点都在右部的稠密点。

而枚举起点则确定了剩余的所选点只能在右部，相当于枚举了右部点，解决了左疏右密的问题。

时间复杂度：$\mathcal{O}(n^3)$

[评测记录](https://www.luogu.com.cn/record/98184000)

---

## 作者：BFSDFS123 (赞：7)

好吧，好一道 dp 题。

考虑发现，不管坐标们长啥样，最后的结果肯定是 $\ge k$ 的（显然，如果都无法搁到一起，就直接给某个点附近加上 $k$ 个点）

所以考虑建图。将每两个可以通过放置中间节点到达的点进行连边，然后跑最长路即可。

但是又发现，我们连出的图是一个 Dag。（很明显）

所以甚至我们可以直接记忆化搜索找出最长路。

因为是 PJ T4，所以放出考场代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
const int Maxn=610;
const int Maxk=110;
const int Maxm=2e5+10;
int head[Maxn],tot;
struct Edge{
    int to;
    int w;
    int nxt;
}E[Maxm<<1];
void addedge(int u,int v,int w)
{
    tot++;
    E[tot].to=v;
    E[tot].w=w;
    E[tot].nxt=head[u];
    head[u]=tot;
}
struct Point{
    int x,y;
}P[Maxn];
void check(int x,int y)
{
    if(P[x].x>=P[y].x && P[x].y>=P[y].y)
    {
        if(abs(P[x].x-P[y].x)+abs(P[x].y-P[y].y)-1>k) return ;
        if(abs(P[x].x-P[y].x)+abs(P[x].y-P[y].y)==1)
        {
            addedge(y,x,0);
        }else{
            addedge(y,x,abs(P[x].x-P[y].x)+abs(P[x].y-P[y].y)-1);
        }
        //cout<<y<<"->"<<x<<":"<<abs(P[x].x-P[y].x)+abs(P[x].y-P[y].y)-1<<endl;
    }
}
int dp[Maxn][Maxn];
int dfs(int u,int rk) // rk 可供用的加点数量
{
    if(dp[u][rk]!=-1) return dp[u][rk];
    int res=1;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].to,w=E[i].w;
        if(rk>=w)
        {
            //cout<<u<<":"<<v<<endl;
            int tmp=dfs(v,rk-w)+w+1;
            res=max(res,tmp);
        }
    }
    dp[u][rk]=res;
    return res;
}
int main()
{
    //freopen("point.in","r",stdin);
    //freopen("point.out","w",stdout);
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&P[i].x,&P[i].y);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i==j) continue;
            check(i,j);
        }
    }
    int ans=-0x3f;
    memset(dp,-1,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        //memset(dp,-1,sizeof(dp));
        for(int j=0;j<=k;j++)
        {
            int tmp=dfs(i,j);
            tmp+=(k-j);
            //cout<<i<<":"<<j<<",tmp="<<tmp<<endl;
            ans=max(ans,tmp);
        }
    }
    printf("%d\n",ans);
    return 0;
}

```

时间复杂度：$O(n^2k)$


-----

Q： 这题这么简单，为什么你做了 1 个小时

A： 因为我开始在进行搜索的时候，将 dp 数组重置成 -1 了……

---


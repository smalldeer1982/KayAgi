# [CSP-J 2023] 一元二次方程

## 题目背景

众所周知，对一元二次方程 $ax ^ 2 + bx + c = 0(a \neq 0)$，可以用以下方式求实数解：

- 计算 $\Delta = b ^ 2 - 4ac$，则:
	1. 若 $\Delta < 0$，则该一元二次方程无实数解。
  	2. 否则 $\Delta \geq 0$，此时该一元二次方程有两个实数解 $x _ {1, 2} = \frac{-b \pm \sqrt \Delta}{2a}$。
 
例如：

- $x ^ 2 + x + 1 = 0$ 无实数解，因为 $\Delta = 1 ^ 2 - 4 \times 1 \times 1 = -3 < 0$。
- $x ^ 2 - 2x + 1 = 0$ 有两相等实数解 $x _ {1, 2} = 1$。
- $x ^ 2 - 3x + 2 = 0$ 有两互异实数解 $x _ 1 = 1, x _ 2 = 2$。

在题面描述中 $a$ 和 $b$ 的最大公因数使用 $\gcd(a, b)$ 表示。例如 $12$ 和 $18$ 的最大公因数是 $6$，即 $\gcd(12, 18) = 6$。

## 题目描述

现在给定一个一元二次方程的系数 $a, b, c$，其中 $a, b, c$ **均为整数且 $a \neq 0$**。你需要判断一元二次方程 $a x ^ 2 + bx + c = 0$ 是否有实数解，并按要求的格式输出。

**在本题中输出有理数 $v$ 时须遵循以下规则：**

- 由有理数的定义，存在唯一的两个整数 $p$ 和 $q$，满足 $q > 0$，$\gcd(p, q) = 1$ 且 $v = \frac pq$。
- 若 $q = 1$，**则输出 `{p}`，否则输出 `{p}/{q}`**，其中 `{n}` 代表整数 $n$ 的值；
- 例如：

	- 当 $v = -0.5$ 时，$p$ 和 $q$ 的值分别为 $-1$ 和 $2$，则应输出 `-1/2`；
   - 当 $v = 0$ 时，$p$ 和 $q$ 的值分别为 $0$ 和 $1$，则应输出 `0`。
   
**对于方程的求解，分两种情况讨论：**

1. 若 $\Delta = b ^ 2 - 4ac < 0$，则表明方程无实数解，此时你应当输出 `NO`；
2. 否则 $\Delta \geq 0$，此时方程有两解（可能相等），记其中较大者为 $x$，则：
	1. 若 $x$ 为有理数，则按有理数的格式输出 $x$。
   2. 否则根据上文公式，$x$ 可以被**唯一**表示为 $x = q _ 1 + q _ 2 \sqrt r$ 的形式，其中：
   
   		- $q _ 1, q _ 2$ 为有理数，且 $q _ 2 > 0$；
      - $r$ 为正整数且 $r > 1$，且不存在正整数 $d > 1$ 使 $d ^ 2 \mid r$（即 $r$ 不应是 $d ^ 2$ 的倍数）；
   
   此时：
   
   1. 若 $q _ 1 \neq 0$，则按有理数的格式输出 $q _ 1$，并再输出一个加号 `+`；
   2. 否则跳过这一步输出；
   
   随后：
   
   1. 若 $q _ 2 = 1$，则输出 `sqrt({r})`；
   2. 否则若 $q _ 2$ 为整数，则输出 `{q2}*sqrt({r})`；
   3. 否则若 $q _ 3 = \frac 1{q _ 2}$ 为整数，则输出 `sqrt({r})/{q3}`；
   4. 否则可以证明存在唯一整数 $c, d$ 满足 $c, d > 1, \gcd(c, d) = 1$ 且 $q _ 2 = \frac cd$，此时输出 `{c}*sqrt({r})/{d}`；
   
   上述表示中 `{n}` 代表整数 `{n}` 的值，详见样例。
   
   如果方程有实数解，则按要求的格式输出两个实数解中的较大者。否则若方程没有实数解，则输出 `NO`。

## 说明/提示

**【样例 #2】**

见附件中的 `uqe/uqe2.in` 与 `uqe/uqe2.ans`。

**【数据范围】**

对于所有数据有：$1 \leq T \leq 5000$，$1 \leq M \leq 10 ^ 3$，$|a|,|b|,|c| \leq M$，$a \neq 0$。

| 测试点编号 | $M \leq$ | 特殊性质 A | 特殊性质 B | 特殊性质 C |
| :-: | :-: | :-: | :-:| :-:|
| $1$ | $1$ | 是 | 是 | 是 |
| $2$ | $20$ | 否 | 否 | 否 |
| $3$ | $10 ^ 3$ | 是 | 否 | 是 |
| $4$ | $10 ^ 3$  | 是 | 否 | 否 |
| $5$ | $10 ^ 3$  | 否 | 是 | 是 |
| $6$ | $10 ^ 3$  | 否 | 是 | 否 |
| $7, 8$ | $10 ^ 3$  | 否 | 否 | 是 |
| $9, 10$ | $10 ^ 3$  | 否 | 否 | 否 |

其中：

- 特殊性质 A：保证 $b = 0$；
- 特殊性质 B：保证 $c = 0$；
- 特殊性质 C：如果方程有解，那么方程的两个解都是整数。

## 样例 #1

### 输入

```
9 1000
1 -1 0
-1 -1 -1
1 -2 1
1 5 4
4 4 1
1 0 -432
1 -3 1
2 -4 1
1 7 1```

### 输出

```
1
NO
1
-1
-1/2
12*sqrt(3)
3/2+sqrt(5)/2
1+sqrt(2)/2
-7/2+3*sqrt(5)/2```

# 题解

## 作者：_H17_ (赞：94)

## 题目分析

给你 $a,b,c$ 写出 $ax^2+bx+c=0$ 这个方程最大的解，无解输出 `NO`。

也就是表示出 $\frac{-b\pm \sqrt{b^2-4ac}}{2a}$。我们把 $b^2-4ac$ 记为 $\Delta$。

如果 $\Delta<0$ 无解。

因为 $\Delta\ge 0$ 所以 $\sqrt{\Delta}\ge 0$ 较大的解是 $\frac{-b+ \sqrt{\Delta}}{2a}$。

我们把 $\sqrt{\Delta}$ 变成 $a\sqrt{b}$ 的形式后。如果 $b=0,1$ 说明解是有理数，如果是有理数记得把 $-b+\sqrt{\Delta}$ 当做整体然后除以 $2a$ 最后当做有理数输出。

注意：如果 $\sqrt{\Delta}$ 不是有理数 $\frac{-b+\sqrt{\Delta}}{2a}$ 应该表示成 $\frac{-b}{2a}+\frac{\sqrt{\Delta}}{2a}$。

然后分个体约分，对于有理数直接约分，无理数只约掉 $a\sqrt{b}$ 中的 $a$ 与分母的公因数。

注意：分母永远是正数。

难点是模拟输出，细节比较多，没什么算法，直接写在这里不直观，放在代码注释中。

再说一些常见的错误输出：

```
0+sqrt(5)
+sqrt(5)
sqrt(8)
sqrt(5)/1
1*sqrt(5)
2*sqrt(5)/4
5/-2
-5/-1
-5/2+3/2
```

## 代码实现

```cpp
#include<bits/stdc++.h> 
using namespace std;
int T,m,a,b,c,d,k,t;
int gcd(int a,int b){//最大公因数
	return b?gcd(b,a%b):a;
}
void Main(){
	cin>>a>>b>>c;
	if(a<0)
		a=-a,b=-b,c=-c;//细节1：分母非负
	d=b*b-4*a*c,k=1;//d是delta
	if(d<0){
		cout<<"NO\n";
		return;
	}//无解
	for(int i=2;i*i<=d;i++)
		while(d%(i*i)==0)
			k*=i,d/=(i*i);//k*sqrt(d)
	if(d==0||d==1){//有理数
		t=abs(gcd(2*a,-b+k*d));//细节2：取绝对值
		cout<<(-b+k*d)/t;
		if(2*a/t!=1)//细节3：分母非1
			cout<<'/'<<2*a/t;
		cout<<'\n';
		return;
	}
	//-b/2a+k*sqrt(d)/2a
	t=abs(gcd(-b,2*a));//细节2
	if(-b/t==0)//细节4：不能有0+xxx
		goto g;
	cout<<-b/t;
	if(2*a/t!=1)//细节3
		cout<<'/'<<2*a/t;
	cout<<'+';
	g:
	t=abs(gcd(k,2*a));//细节2
	if(k/t!=1)//细节5：乘数不为1
		cout<<k/t<<'*';
	cout<<"sqrt("<<d<<')';
	if(2*a/t!=1)//细节3
		cout<<'/'<<2*a/t;
	cout<<'\n';
	return;
}
int main(){/*
	freopen("uqe.in","r",stdin);
	freopen("uqe.out","w",stdout);*/
	for(cin>>T>>m;T;--T)
		Main();//根据某人言，多测函数好
	return 0;
}
```

---

## 作者：zct_sky (赞：51)

### Solution
-----
~~CCF 特有的今年 T3 大模拟（~~

良心题目，甚至给了你一元二次方程的判别式（）。

按题意模拟即可。

当 $\Delta < 0$ 时，输出 $\texttt{NO}$。

当 $\Delta = 0$ 时，只有一个解，即为 $\dfrac{-b}{2a}$，约分后按要求输出即可。

约分过程：若要对 $\dfrac{-b}{2a}$ 进行约分，求出 $d = \gcd(|b|,|2a|)$，约分后的分数即为 $\dfrac{(-b)\div d}{2a\div d}$。

当 $\Delta > 0$ 时，分类讨论：

- $\sqrt{\Delta}=r$ 时（$r$ 为整数），较大的解为 $\begin{cases}\frac{-b+r}{2a}&a>0\\\frac{-b-r}{2a}&a<0\end{cases}$。

- $\sqrt{\Delta}=r\sqrt{t}$ 时（$r,t$ 为整数，且 $t$ 不为完全平方数），较大的解为 $\begin{cases}\frac{-b}{2a}+\frac{r\sqrt{t}}{2a}&a>0\\\frac{-b}{2a}-\frac{r\sqrt{t}}{2a}&a<0\end{cases}$。

同样对分数约分后输出即可。

至于 $r$ 的求法：由于 $M\le 1000, \Delta \le 5\times M^2$，暴力枚举 $1\dots \left\lfloor\sqrt{\Delta}\right\rfloor$ 即可。

时间复杂度为 $\mathcal{O}(TM)$ 左右。（$\gcd$ 复杂度忽略不计）
### Code
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')y=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*y;
}
ll T,M,a,b,c,delta;
ll gcd(ll a,ll b){
	if(b==0)return a;
	return gcd(b,a%b);
}
int main(){
	T=read();M=read();
	while(T--){
		a=read();b=read();c=read();
		delta=b*b-4*a*c;
		if(delta<0){
			printf("NO\n");
		}else if(delta==0){
			ll p=-b,q=2*a;
			ll pq=gcd(abs(q),abs(p));
			p/=pq,q/=pq;
			if(q<0)q=-q,p=-p;
			if(q==1)printf("%lld\n",p);
			else printf("%lld/%lld\n",p,q);
		}else{
			ll p=-b,q=2*a;
			ll sq=(ll)sqrt(delta);
			if(sq*sq==delta){
				if(q>0)p+=sq;
				else p-=sq;
				ll pq=gcd(abs(q),abs(p));
				p/=pq,q/=pq;
				if(q<0)q=-q,p=-p;
				if(q==1)printf("%lld\n",p);
				else printf("%lld/%lld\n",p,q);
			}else{
				ll pq=gcd(abs(q),abs(p));
				p/=pq,q/=pq;
				if(q<0)q=-q,p=-p;
				if(p!=0){
					if(q==1)printf("%lld+",p);
					else printf("%lld/%lld+",p,q);
				}
				q=abs(2*a);
				p=1;
				ll t=0;
				for(int r=sq;r>=1;r--)
					if(delta%(r*r)==0){
						p*=r;
						t=delta/(r*r);
						break;
					}
				pq=gcd(abs(q),abs(p));
				p/=pq,q/=pq;
				if(q<0)q=-q,p=-p;
				if(p==q) printf("sqrt(%lld)\n",t);
				else if(q==1) printf("%lld*sqrt(%lld)\n",p,t);
				else if(p==1) printf("sqrt(%lld)/%lld\n",t,q);
				else printf("%lld*sqrt(%lld)/%lld\n",p,t,q);
			}
		}
	}
	return 0;
}
```

---

## 作者：Dream__Sky (赞：27)

此题考察思维的缜密性及基本功。

题意在此就不说了，以下使用的字母意义与题中一样。

------------
首先发现，在有解情况下，较大的根与 $a$ 的正负有关，若 $a$ 为正，较大根为 $\dfrac{-b+\sqrt{b^2-4ac}}{2a}$，若 $a$ 为负，较大根为 $\dfrac{-b-\sqrt{b^2-4ac}}{2a}$。

------------
接着分成四部分考虑。

1. 无解，即 $b^2<4ac$。
1. 根号下为 $0$，那么分子一定是整数，可以直接处理对 $\dfrac{-b}{2a}$ 的输出。
1. 能开的尽方的，那么就可以把 $\sqrt{b^2-4ac}$ 与 $-b$ 合并成一个整数，进行与上一次类似的输出。注意要考虑较大根。
1. 最麻烦的情况，即是一个无理数，那么分开来处理。先考虑 $\dfrac{-b}{2a}$，这个处理也和上面类似。然后处理根号，首先要化简，再与分母 $2a$ 进行约分，最后输出。

第四条中不用考虑较大根，即根号的正负。原因是当 $2a$ 为正时，较大根的符号为正，正正得正。当 $2a$ 为负，根号为负，负负得正，根号还是正数。

------------
再来讲讲怎么进行上文中提到的三次输出，我们发现，这里都是整数除以整数。

分成三部分考虑,分子与分母设为 $x$，$y$。

1. 分子为 $0$，输出 $0$。
1. $x\mid y$，输出 $\dfrac{x}{y}$ 的值。
1. 不能整除，最普通的情况，按题意模拟即可。可以用自带的 $\gcd$ 来约分。还要注意考虑正负性，注意如果是负号，是在最前面的数前面加上负号。

还有一些细节，上代码了再讲。


------------
接着考虑根号的处理。

首先要化简。在根号下的数，即 $b^2-4ac$ 中，寻找能整除它的平方数。因为是要找平方数，所以只要枚举到它的平方即可。

然后用最小公倍数来进行约分。接下来的输出就是一个简单的小模拟了。

------------
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
bool p;
void print(int x,int y)
{
	if(x%y==0) cout<<x/y;//情况2
	else //情况3
	{
		int gcd=__gcd(abs(x),abs(y));
		if(x>0&&y>0) cout<<x/gcd<<"/"<<y/gcd;
		else if(x<0&&y<0) cout<<-x/gcd<<"/"<<-y/gcd;
		else cout<<"-"<<abs(x)/gcd<<"/"<<abs(y)/gcd;
	}
}
void print1(int x,int y)
{
	if(!x) cout<<"0";//输出的情况1，由于这里只有整数，那么如果答案为0，还要输出
	else print(x,y);//普通情况
	cout<<"\n";//当前这个例子处理完毕，换行
}
void print2(int x,int y)
{
	if(!x) return ;//输出的情况1，由于这里后面还有根号，那么如果答案为0，不用输出
	else print(x,y);//同上
	cout<<"+";//后面要跟根号
}
void gen(int x,int y)
{
	int xishu=0;
	for(int i=1;i*i<=x;i++)
		if(x%(i*i)==0) xishu=i;//找平方数
	x=x/(xishu*xishu);
	y=abs(y);
	int gcd=__gcd(xishu,y);
	y/=gcd;
	xishu/=gcd;//约分
	
	
	if(xishu==1) cout<<"sqrt("<<x<<")";//如果系数为1，那么不用输出
	else cout<<xishu<<"*"<<"sqrt("<<x<<")";//这里要输出系数
	if(y!=1) cout<<"/"<<y;//分母的处理
	cout<<"\n";
}
void work()
{
	int a,b,c;
	cin>>a>>b>>c;
	b=-b;
	int t=2*a;
	int sq=b*b-4*a*c;
	if(t<0) p=1;
	else p=0;//这是对于较大根的处理
	
	if(sq<0) cout<<"NO\n";//情况1
	else if(sq==0) print1(b,t);//2
	else if((int)sqrt(sq)*(int)sqrt(sq)==sq) //3
	{
		int sum=(p==1?-sqrt(sq):sqrt(sq))+b;//考虑较大根
		print1(sum,t);//合并后输出
	}
	else//4
	{
		print2(b,t);//前面整数的输出
		gen(sq,t);//根号的输出
	}
}
int main()
{
	int T,x;
	cin>>T>>x;
	while(T--) work();
	return 0;
}
```




---

## 作者：sz_wsy (赞：23)

[**CSP-J2023_T3 题目链接**](https://www.luogu.com.cn/problem/P9750)
## 前置知识
1. 一元二次方程 $ax ^ 2 + bx + c = 0 (a \neq 0)$，求根公式为：
$$x_{1,2}=\dfrac{-b\pm\sqrt{b^2-4ac}}{2a}$$

2. $$\sqrt{a^2b}=a\sqrt{b}(a,b\ge0)$$

## 题面简述



对一元二次方程 $ax ^ 2 + bx + c = 0 (a \neq 0)$，可以用以下方式求实数解：

- 计算 $\Delta = b ^ 2 - 4ac$，则:
	1. 若 $\Delta < 0$，则该方程无实数解。
  	2. 否则 $\Delta \geq 0$，此时该方程有两个实数解 $x_{1, 2} = \dfrac{-b \pm \sqrt \Delta}{2a}$。
 
共给 $T$ 组数据 $a,b,c$，求该方程的**较大实数解**。

## 思路分析

~~CCF 又考大模拟。~~ 这道题题面描述比较长，我们可以结合样例进行理解。不难发现，难点不在于计算过程，而在于输出时的数据处理：化简、约分等。

分 $2$ 种情况讨论：

1. $\Delta<0$ 。这是最简单的情况，原方程无实数解，输出 `NO` 即可。

2. $\Delta\geq0$ 。为了防止正负号带来的麻烦，事先做个处理，统一 $a$ 取正，即 `if(a<0) a=-a,b=-b,c=-c;`。这样，就可以保证求根公式中分母 $2a$ 一定为正，方便计算。

话说回来，题目要求较大解，现在 $\dfrac{-b\pm\sqrt{\Delta}}{2a}$ 中分母 $2a$ 已是正数，$\sqrt{\Delta}\geq0$，则较大解必为 $\color{Red}x=\dfrac{-b {+}\sqrt{\Delta}}{2a}$。


接下来又要分 $2$ 种情况讨论了：

1. 当 $\sqrt{\Delta}$ 为有理数 $sq$ 时：此时 $\Delta$ 时完全平方数。$x=\color{Orange}\dfrac{-b+sq}{2a}$。只需将分子 $-b+sq$ 与分母 $2a$ 约分后输出即可。

2. 当 $\sqrt{\Delta}$ 为无理数时：此时 $\Delta$ 不是完全平方数。

设 $\Delta=k^2t$，则 $\sqrt{\Delta}=k\sqrt{t}$（$k$ 取最大值）。
现在，可将原题输出部分分为 $2$ 部分考虑：
 $x=\dfrac{-b+\sqrt{\Delta}}{2a}=-\dfrac{b}{2a}+\dfrac{\sqrt{\Delta}}{2a}=\color{Orange}-\dfrac{b}{2a}+\dfrac{k\sqrt{t}}{2a}$。
 
 
需将此两分数分别约分再输出。即将 $b$ 和 $2a$，$k$ 和 $2a$ 分别约分。**输出时需注意**：若 $b\neq0$，则输出 $-\dfrac{b}{2a}$，此时需要输出 `+`；若 $b=0$，则不用输出 `+`，直接输出 $\dfrac{k\sqrt{t}}{2a}$。

由此，我们可以现写出 $3$ 个函数：

```cpp
//求最大公因数
int gcd(int n,int m){
	if(n%m==0) return m;
	else return gcd(m,n%m);
}
//约分
void YueFen(){
	bool f=(fenzi<0?1:0); //在对负数取模时会出 BUG
	if(f) fenzi*=-1;
	int k=gcd(fenzi,fenmu);
	fenzi/=k;fenmu/=k;
	if(f) fenzi*=-1;
}
//将 n 化为 k^2*t（k 最大）的形式
int k,t;
void solve(int n){
	for(int i=sqrt(n);i>=1;i--){
		int w=n/i/i;
		if(w*i*i==n){
			k=i;
			t=w;  //n=k^2*t
			return;
		}
	}
}

```
最后是输出的问题，详细解释见代码：

## 代码呈现
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

inline int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return x*y;
}
int T,M,fenzi,fenmu;
int gcd(int n,int m){
	if(n%m==0) return m;
	else return gcd(m,n%m);
}
void YueFen(){
	bool f=(fenzi<0?1:0);
	if(f) fenzi*=-1;
	int k=gcd(fenzi,fenmu);
	fenzi/=k;fenmu/=k;
	if(f) fenzi*=-1;
}
int k,t;
void solve(int n){
	for(int i=sqrt(n);i>=1;i--){
		int w=n/i/i;
		if(w*i*i==n){
			k=i;
			t=w;  //n=k^2*t
			return;
		}
	}
}
int main(){
//	freopen("uqe.in","r",stdin);
//	freopen("uqe.out","w",stdout);
	T=read(),M=read();
	for(int i=1;i<=T;i++){
		int a=read(),b=read(),c=read();
		int delta=b*b-4*a*c;
		if(delta<0){
			printf("NO\n");
			continue;
		}
		if(a<0) a=-a,b=-b,c=-c;
		int sq=sqrt(delta);
		
		if(sq*sq==delta){ //有理数 
			fenzi=-b+sq;
			fenmu=2*a;
			YueFen();
			if(fenmu==1){
				printf("%d\n",fenzi);
			}else printf("%d/%d\n",fenzi,fenmu);
		}else{           //无理数 
			solve(delta); //sqrt(delta)=k*sqrt(t)
			fenzi=-b;
			fenmu=a*2;
			YueFen();
			if(b!=0){
				if(fenmu==1){
					printf("%d",fenzi);
				}else printf("%d/%d",fenzi,fenmu);
				printf("+");
			}
			fenzi=k;
			fenmu=a*2;
			YueFen();
			if(fenzi==1&&fenmu==1){
				printf("sqrt(%d)",t);
			}else if(fenzi==1){
				printf("sqrt(%d)/%d",t,fenmu);
			}else if(fenmu==1){
				printf("%d*sqrt(%d)",fenzi,t);
			}else printf("%d*sqrt(%d)/%d",fenzi,t,fenmu);
			
			printf("\n");
		}
	}
	
	return 0;
}
```



---

## 作者：Genius_Star (赞：18)

### 题意：

给定一个一元二次方程 $ax^2+bx+c$，如果没有实数解输出 ``NO``，否则按以下要求输出（设 $x$ 为 $x_1,x_2$ 两个解的较大值）：

- 如果 $x$ 为有理数，那么将 $x$ 表示为互质的两数之比。（如果为整数则直接输出）

- 若 $x$ 为无理数，可以将 $x$ 表示为一个有理数 $q_1+q_2 \sqrt r$ 的形式，且 $\sqrt r$ 为最简（即没有一个数 $d>1$，且 $d^2 |\sqrt r$），然后按照有理数的形式输出 $q_1$，然后如果 $q_2$ 为 $1$，直接输出 $\sqrt r$；若 $q_2$ 为整数，输出 $q_2 \times \sqrt r$；若 $q_2$ 的倒数为整数，则输出 $\sqrt r /q_3$（$q_3$ 为 $q_2$ 的倒数）；否则设 $q_2=\frac{c}{d}$（即两数之比），输出 $c \times \sqrt r / d$。

### 思路：

很好实现的模拟题。

设 $t=b^2-4 \times a \times c$，若 $t<0$，则直接输出 ``NO``。

如果 $t=0$，那么原式等于 $\frac{-b}{2 \times a}$，按照有理数数的格式输出即可。

设 $x$ 为分子，$y$ 为分子，那么先求出两者的最大公约数 $k=\gcd(x,y)$，然后同除一下 $k$ 就可以化为最简分数，注意 $y$ 不能 $<0$，则如果 $y<0$，则将 $y=-y,x=-x$ 转移一下符号即可。

然后再看一下，设 $g=\sqrt t$，如果 $g$ 为整数，那么原式可以化为有理数的形式，为 $\frac{-b \pm g}{2 \times a}$，比较一下 $\frac{-b - g}{2 \times a}$ 与 $\frac{-b + g}{2 \times a}$ 的大小，按照有理数的格式输出即可。

然后再看，若 $g$ 为无理数，则原式可以化为 $\frac{-b}{2 \times a} \pm \frac{\sqrt t}{2 \times a}$，按照有理数的格式输出 $\frac{-b}{2 \times a}$（若 $b=0$，则该式为 $0$，不需要输出）。

之后看 $\frac{\sqrt t}{2 \times a}$，因 $\sqrt a \times \sqrt b=\sqrt {ab}$，若 $\sqrt a$ 或 $\sqrt b$ 为整数则可以化简，所以可以将 $t$ 不断把完全平方数给拆出来即可。

可以提前预处理一下完全平方数的范围，估一下大概的范围 $b^2 -4ac$ 最大为 $1000^2 - 4 \times 1000 \times (-1000)=5 \times 10^6$，找到这个范围内的完全平方数就可以了，然后不断将 $t$ 拆分，直到不能拆为止。

那么我们设 $\sqrt t$ 被拆为 $sum \times \sqrt {t_2}$。

设 $p=2 \times a$，那么原式等于 $\frac{sum}{p} \times \sqrt {t_2}$，然后将 $\frac{sum}{p}$ 化为最简分数，判断一下该式是否为 $1$，如果是那么输出 $\sqrt {t_2}$；

否则，看一下化为最简分数后的 $sum_2$ 是否为 $1$，为 $1$ 则其倒数肯定是整数，输出 $\sqrt {t_2} / p_2$；如果原式为整数，设 $d=\frac{sum}{p}$，那么输出 $d \times \sqrt{t_2}$；否则输出 $sum_2 \times \sqrt {t_2} \times p_2$。

时间复杂度为：$O(T \log M^2)$。

**一定要算好完全平方数的范围啊，我就是因为这个痛失 20pts。**

**最后因为题目中说了 $c,d>0$，所以对于这种输出直接取绝对值即可。**

### 完整代码：（考场代码略加修改）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=3030;
ll T,M,cnt=0,sum=0;
ll F[N];
db a,b,c;
void print(ll x,ll y){
	ll t=__gcd(x,y);
	x/=t,y/=t;
	if(y<0){
		y=-y;
		x=-x;
	}
	if(y==1)
	  printf("%lld",x);
	else
	  printf("%lld/%lld",x,y);
}
bool check(ll &x){
	bool f=0;
	for(int i=1;i<=cnt;i++){
		if(F[i]>x)
		  break;
		if(x%F[i]==0){
			sum*=sqrt(F[i]);
			f=1;
			x/=F[i];
		}
	}
	return f;
}
int main(){
// 	freopen("uqe.in","r",stdin);
// 	freopen("uqe.out","w",stdout);
	scanf("%lld%lld",&T,&M);
	for(int i=2;i<N;i++)
	  F[++cnt]=i*i;
	while(T--){
		sum=1;
		scanf("%lf%lf%lf",&a,&b,&c);
		ll t=b*b-4.0*a*c;
		if(t<0){
			puts("NO");
			continue;
		}
		if(t==0){
			print(-b,2*a);
			putchar('\n');
			continue;
		}
		ll k=sqrt(t);
		if(k*k==t){
			if(((-b+k)/(2*a))>((-b-k)/(2*a)))
			  print(-b+k,2*a);
			else
			  print(-b-k,2*a);
			putchar('\n');
			continue;
		}
		if(b){
			print(-b,2*a);
			putchar('+');
		}
		while(check(t)); //拆分 
		ll x=2*a;
		ll v=__gcd(x,sum);
		x/=v,sum/=v;
		if(x==sum){
			printf("sqrt(%lld)\n",t);
			continue;
		}
		if(sum%x==0){
			ll d=abs(sum/x);
			if(d==1)
			  printf("sqrt(%lld)\n",t);
			else
			  printf("%lld*sqrt(%lld)\n",d,t);
			continue;
		}
		if(sum==1){
			printf("sqrt(%lld)/%lld\n",t,abs(x));
			continue;
		}
		printf("%lld*sqrt(%lld)/%lld\n",abs(sum),t,abs(x));
	}
// 	fclose(stdin);
// 	fclose(stdout);
	return 0;
}
```


---

## 作者：zzx114514 (赞：16)

场上唯一没挂的题，竟然还是大模拟，代码八九十行，接下来慢慢讲。
## [题目传送门](https://www.luogu.com.cn/problem/P9750)
# 题目大意
求解形如 $ax^2+bx+c=0$ 的一元二次方程，无实数解输出 `NO`，有实数解输出较大的那个，但需要按照一定格式输出，也就是 $q1+q2\sqrt{r}$，其中所有有理数需要表示成 $\frac{p}{q}$ 且 $\gcd(p,q)=1$，能化简的要化简，具体地讲就是分母为 $1$ 的要化成整数，分子为 $0$ 的要舍去，根号下可以拆成 $\sqrt{a_1^2a_2^2\cdots a_n^2b}$ 的要化成 $a_1a_2\cdots a_n\sqrt{b}$。  
这样讲有点绕，具体可以看原题描述。  
其中 $ax^2+bx+c=0$ 的两个解 $x_{1,2}=\frac{-b\pm\sqrt{\Delta}}{2a}$，其中 $\Delta=b^2-4ac$。  
显然，若 $\Delta<0$，该方程无实数解。

# 解题思路
既然是模拟，按照题意模拟即可，麻烦在输出。  
注意坑点：很多人以为取较大的解就是取 $\frac{-b+\sqrt{\Delta}}{2a}$，但当 $2a<0$ 时，应当取 $\frac{-b-\sqrt{\Delta}}{2a}$，这一点在赛时很可能卡住了无数选手。  
具体思路在这里讲太麻烦，看代码吧，但有点长。
# 完整代码（赛时）
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,m,a,b,c,delta;
void you(int delta)//处理有理数输出
{
	int p=-b+sqrt(delta),w=-b-sqrt(delta);//计算两个解的分子
	int q=2*a;//计算分母
	if (p*1.0/q<w*1.0/q) p=w;//取较大解
	
	if (p%q==0 && w%q==0)//如果整除直接输出p/q
	{
		cout<<p/q;
		return;
	}
	if ((p<0 && q>0) || (p>0 && q<0)) cout<<'-';//如果为负输出负号
	p=abs(p);
	q=abs(q);//取绝对值
	int k=__gcd(p,q);//求最大公因数
	
	p/=k;
	q/=k;//约分
	if (q==1) cout<<p;//如果分母为1直接输出分子
	else if (p==0) cout<<0;//如果分子为0直接输出0
	else printf("%d/%d",p,q);//否则输出p/q的形式
}
int f(int delta)//化简根号，如果根号下的数的因子中有完全平方数，则可以将其分离出来
{
	int ans=1;
	for (int i=2;i*i<=delta;i++)
		while(delta%(i*i)==0)
		{
			ans*=i;
			delta/=i*i;
		}
	return ans;
}
void wu(int delta)//处理无理数输出
{
	if (-b*1.0/(2*a))//如果q1不等于0
	{
		you(0);//按有理数输出q1
		cout<<'+';//记得输出一个加号
	}
	int k=f(delta);//计算根号化简后的系数
	delta/=k*k;//根号下的数要除以k^2
	double q2=fabs(1.0*k/(2*a));//计算q2
	if (q2==1) printf("sqrt(%d)",delta);//如果等于1直接省略
	else if (q2==floor(q2)) printf("%.0f*sqrt(%d)",q2,delta);//如果是整数直接保留小数点0位输出
	else if (1/q2==floor(1/q2) && 1/q2!=0) printf("sqrt(%d)/%.0f",delta,1/q2);//如果1/q2是整数，那么将q2作为分母输出，具体见题意
	else//否则按照有理数输出q2
	{
		int c=k;
		int d=2*a;
		int x=__gcd(c,d);
		c/=x;
		d/=x;
		if ((c<0 && d>0) || (c>0 && d<0))
		{
			c=abs(c);
			d=abs(d);
		}
		if (c!=1) cout<<abs(c)<<'*';//注意输出乘号，与平常数学中不同
		printf("sqrt(%d)/%d",delta,d);
	}
	cout<<endl;
}
int main()
{
	//freopen("uqe.in","r",stdin);
	//freopen("uqe.out","w",stdout);
	cin>>t>>m;
	while(t--)
	{
		cin>>a>>b>>c;
		delta=b*b-4*a*c;//计算delta
		if (delta<0) cout<<"NO"<<endl;//如果小于0说明没有实数解
		else
		{
			if (sqrt(delta)==floor(sqrt(delta)))//由于保证delta是整数，如果根号下delta是整数，按照有理数输出
			{
				you(delta);
				cout<<endl;
			}
			else wu(delta);//否则按照无理数输出
		}
	}
	return 0;//完结撒花
}

```


---

## 作者：strcmp (赞：13)

一道规模中等的模拟。

由于要做有理数的运算，我们要实现一个分数结构体，并支持乘法，比较大小，和输出。

```cpp
struct fac{
	ll a, b;
	fac() { b = 1; }
	fac(ll x, ll y) { a = x, b = y; }
	void tf() {
        //通分
		if (gcd(a, b) == 0) return;
		ll g = gcd(a, b);
		a /= g; b /= g;
		if (b < 0 && a > 0) b = -b, a = -a;
	}
	fac operator*(fac x) {
		this->tf(); x.tf();
		ll c = x.a, d = x.b;
		fac w = { a * d + b * c, b * d }; w.tf();
		return w;
	}
	inline int operator<(fac x) {
		this->tf(); x.tf();
		ll c = x.a, d = x.b;
		return a * d < b * c;
	}
	inline void output() {
		//cout << "op:" << a << " " << b << "\n";
		this->tf();
		//if (a == 0) printf("0");
		if (b == 1) printf("%lld", a);
		else printf("%lld/%lld", a, b);
	}
};
```

实现分数结构体之后，分别按题意考虑 $a,b,c$。

1. $\Delta < 0$，输出 `NO` 即可。

```cpp
if (dt(a, b, c) < 0) { puts("NO"); return; }
//dt(a, b, c)，求出 a, b, c 的 Delta。 
```
2. $\Delta \ge 0$，根据求根公式，我们要先保证根号下没有平方因子。

```cpp
pll tichu(ll x) {
	ll w = 1;
	for (ll i = 2; i * i <= x; i++) {
		if (x % (i * i) == 0) {
			while (x % (i * i) == 0) x /= i * i, w *= i;
		}
	}
	return {w, x};
}
```

有了这个之后，我们就可以大胆的将返回的 $w$ 乘进 $q_2$ 里了。

```cpp
pll pr = tichu(d); d = pr.second;
fac q2 = {pr.first, 2 * a}; 
ll ls = abs(sq[d] * q2.a);
fac now = Max(fac(-b + ls, 2 * a), fac(-b - ls, 2 * a));
```
注意到，如果 $\Delta$ 是完全平方数，则我们最后的输出是不能带根号的。

```cpp
if (sq[d]) now.output(), puts("");
```

否则按题面分类讨论。

```cpp
q2.tf();
if (q2.a < 0) q2.a = -q2.a;
if (b != 0) { 
	(fac(-b, 2 * a)).output();
	if (d != 0) printf("+");
	else puts("");
}
if (!d) return;
if (q2.a == 1 && q2.b == 1) printf("sqrt(%lld)\n", d);
else if (q2.b == 1) printf("%lld*sqrt(%lld)\n", q2.a, d);
else if (q2.a == 1) printf("sqrt(%lld)/%lld\n", d, q2.b);
else printf("%lld*sqrt(%lld)/%lld\n", q2.a, d, q2.b);
```

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
using pll = pair<ll, ll>;
const int maxn = 2e5 + 10;
ll gcd(ll a, ll b) {
	return !b ? a : gcd(b, a % b);
}
struct fac{
	ll a, b;
	fac() { b = 1; }
	fac(ll x, ll y) { a = x, b = y; }
	void tf() {
		if (gcd(a, b) == 0) return;
		ll g = gcd(a, b);
		a /= g; b /= g;
		if (b < 0 && a > 0) b = -b, a = -a;
	}
	fac operator*(fac x) {
		this->tf(); x.tf();
		ll c = x.a, d = x.b;
		fac w = { a * d + b * c, b * d }; w.tf();
		return w;
	}
	inline int operator<(fac x) {
		this->tf(); x.tf();
		ll c = x.a, d = x.b;
		return a * d < b * c;
	}
	inline void output() {
		//cout << "op:" << a << " " << b << "\n";
		this->tf();
		//if (a == 0) printf("0");
		if (b == 1) printf("%lld", a);
		else printf("%lld/%lld", a, b);
	}
};
inline ll dt(ll a, ll b, ll c) {
	return b * b - 4 * a * c;
}
map<ll, ll> sq;
pll tichu(ll x) {
	ll w = 1;
	for (ll i = 2; i * i <= x; i++) {
		if (x % (i * i) == 0) {
			while (x % (i * i) == 0) x /= i * i, w *= i;
		}
	}
	return {w, x};
}
fac Max(fac a, fac b) {
	return a < b ? b : a;
}
inline void solve(ll a, ll b, ll c) {
	if (dt(a, b, c) < 0) { puts("NO"); return; }
	ll d = dt(a, b, c);
	if (-b + d == 0 && -b - d == 0) { puts("0"); return; }
	pll pr = tichu(d); d = pr.second;
	fac q2 = {pr.first, 2 * a}; 
	ll ls = abs(sq[d] * q2.a);
	fac now = Max(fac(-b + ls, 2 * a), fac(-b - ls, 2 * a));
	if (sq[d]) now.output(), puts("");
	else {
		q2.tf();
		if (q2.a < 0) q2.a = -q2.a;
		if (b != 0) { 
			(fac(-b, 2 * a)).output();
			if (d != 0) printf("+");
			else puts("");
		}
		if (!d) return;
		if (q2.a == 1 && q2.b == 1) printf("sqrt(%lld)\n", d);
		else if (q2.b == 1) printf("%lld*sqrt(%lld)\n", q2.a, d);
		else if (q2.a == 1) printf("sqrt(%lld)/%lld\n", d, q2.b);
		else printf("%lld*sqrt(%lld)/%lld\n", q2.a, d, q2.b);
	}
}
int main() {
	//freopen("uqe.in", "r", stdin);
	//freopen("uqe.out", "w", stdout);
	int t; ll M, a, b, c;
	scanf("%d%lld", &t, &M);
	for (ll i = 0; i <= 7000; i++) sq[i * i] = i;
	while (t--) {
		scanf("%lld%lld%lld", &a, &b, &c);
		solve(a, b, c);
	}
	return 0;
}
```

---

## 作者：Fire_flame (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P9750)

强烈谴责题面太麻烦，做法简单。

## $\mathtt{Solution}$

首先，你需要读好题目再来看题解。

### 特殊性质 $\mathbf{A}$

没啥意义，就是让你少写一些东西。

### 特殊性质 $\mathbf{B}$

原式即为：$ax^2+bx=0$。

化简可得：$x(ax+b)=0$。

可得：$x_1=0,x_2=-\dfrac{b}{a}$。

对 $a,b$ 的正负进行讨论即可。

时间复杂度 $O(T)$。

### 特殊性质 $\mathbf{C}$

~~没啥意义，就是让你少写很多东西。~~

枚举根，然后求最大值即可。

时间复杂度 $O(MT)$。

### 正解

首先，如果 $\triangle<0$，无解。

接下来对 $a$ 的正负进行讨论：

- 如果 $a<0$，显然最大值为 $\dfrac{-b-\sqrt{\triangle}}{2a}$。

- 如果 $a>0$，显然最大值为 $\dfrac{-b+\sqrt{\triangle}}{2a}$。

如果没有讨论这个，只有 $10$ 分。

可以对 $\triangle$ 进行分解质因数，将其化简。

然后稍微讨论一下，把分数根号啥的都考虑一下，就不再赘述。

时间复杂度 $O(T\sqrt M)$

代码：

```cpp
/*
ZYL 好帅！
ZYL S 班太强了！ 
ZYL 好闪，拜谢ZYL！ 
*/
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL read(){
	LL s = 0, f = 1;char ch = getchar();
	while(!isdigit(ch)){if(ch == '-')f = -1;ch = getchar();}
	while(isdigit(ch)){s = s * 10 + ch - '0';ch = getchar();}
	return s * f;
}
const int MAXN = 1e5 + 5;
LL n, t, cnt, num[MAXN];
void print_fac(LL x, LL y){
	if(x == 0){
		printf("0");
		return ;
	}
	LL pos = 1;
	if(x * y > 0){
		if(y < 0)x = -x, y = -y;
	}
	else{
		if(y < 0)y = -y;
		else x = -x;
		pos = -1;
	}
	LL h = __gcd(x, y);
	x /= h, y /= h;
	if(y == 1)
		printf("%lld", x * pos);
	else printf("%lld/%lld", x * pos, y);
}
void print_sqr(LL x, LL y, LL z){
	if(y == 1){
		print_fac(x, z);
		return ;
	}
	LL pos = 1, h;
	if(x * z > 0){
		if(z < 0)x = -x, z = -z;
	}
	else{
		if(y < 0)z = -z;
		else x = -x;
		pos = -1;
	}
	h = __gcd(z, x);
	x /= h, z /= h;
	if(x == 1 && z == 1)printf("sqrt(%lld)", y);
	else if(x == 1)printf("sqrt(%lld)/%lld", y, z);
	else if(z == 1)printf("%lld*sqrt(%lld)", x, y);
	else printf("%lld*sqrt(%lld)/%lld", x, y, z);
}
int main(){
// 	freopen("uqe.in", "r", stdin);
// 	freopen("uqe.out", "w", stdout);
	t = read(), n = read();
	while(t --){
		for(int i = 1;i <= cnt;i ++)num[i] = 0;
		cnt = 0;
		LL a = read(), b = read(), c = read(), delta = b * b - 4 * a * c;
		if(delta < 0){
			puts("NO");
			continue;
		}
		LL h = sqrt(delta);
		if(h * h == delta){
			if(a > 0){
				print_fac(h - b, 2 * a);
				puts("");	
			}
			else{
				print_fac(- h - b, 2 * a);
				puts("");
			}
			continue;
		}
		if(b != 0){
			print_fac(-b, 2 * a);
			printf("+");
		}
		for(int i = 2;i * i <= delta;i ++){
			while(delta % i == 0){
				num[++ cnt] = i;
				delta /= i;
			}
		}
		if(delta != 1)num[++ cnt] = delta, delta = 1;
		LL p = 1, q = 1;
		for(int i = 1;i <= cnt;i ++){
			if(num[i] == num[i + 1])p *= num[i], i ++;
			else q *= num[i];
		}
		if(a > 0){
			print_sqr(p, q, 2 * a);
			puts("");
		}
		else{
			print_sqr(-p, q, 2 * a);
			puts("");
		}
	}	
	return 0;
}
```

---

## 作者：FreedomKing (赞：9)

第一次过审 CSP 的题解！

个人感觉写的还是比较细的，若有错别字或解释不足的地方欢迎私信。

### 思路

有些恶心的中模拟，先列一下需要用到的东西再逐步模拟。

- $\gcd$ 函数，判断最大公因数和约分。

```cpp
int gcd(int x,int y){//板子。
	return (x%y==0?y:gcd(y,x%y));
}
```

- 输出分数。

```cpp
void print(int ans1,int ans2){//输出函数
	pair<int,int>cnt;
	cnt=cl(ans1,ans2);//先统一正负
	ans1=cnt.first;
	ans2=cnt.second;
	int x=gcd(abs(ans1),abs(ans2));//约分
	ans1/=x;
	ans2/=x;
	//判断然后输出
	if(ans2==1) cout<<ans1;//判断分母
	else if(ans2==-1) cout<<-ans1;//判号
	else cout<<ans1<<'/'<<ans2;//正常输出
	return;
}
```

- 整理分数正负符号的位置。

```cpp
pair<int,int> cl(int x,int y){
	if(x<0&&y<0) return {-x,-y};//都为负数则均转为正数
	if(x>0&&y<0) return {-x,-y};//符号移到前面的那个数上
	return {x,y};//原封不动
}
```

然后就是分析题面并模拟了。

- 若 $\Delta<0$ 直接输出 $-1$。

- 否则即 $\Delta\ge 0$，存在两个**可能相同**的实数解。

	- 若 $\Delta$ 是完全平方数，即存在整数解，直接输出。

	- 否则即不存在整数解，可能是小数或无理数之类的。
    
		- 若 $q_1\ge 1$，输出并预留加号。
        
     	- 根据题意判断有理数部分及无理数部分，见代码注释。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int prime[N],n,m,t,k,len;
inline int qread(){//快读
#define qr qread()
	int x=0,c=getchar(),t=1;
	while(!(c>='0'&&c<='9')){
		if(c=='-') t=0;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return (t?x:-x);
}
pair<int,int> cl(int x,int y){//整理正负
	if(x<0&&y<0) return {-x,-y};
	if(x>0&&y<0) return {-x,-y};
	return {x,y};
}
int gcd(int x,int y){//求最大公因数
	return (x%y==0?y:gcd(y,x%y));
}
void print(int ans1,int ans2){//输出函数
	pair<int,int>cnt;
	cnt=cl(ans1,ans2);//先统一正负
	ans1=cnt.first;
	ans2=cnt.second;
	int x=gcd(abs(ans1),abs(ans2));//约分
	ans1/=x;
	ans2/=x;
	//判断然后输出
	if(ans2==1) cout<<ans1;//判断分母
	else if(ans2==-1) cout<<-ans1;//判号
	else cout<<ans1<<'/'<<ans2;//正常输出
	return;
}
int qwq(int x){
	int _sqrt=sqrt(x),cnt=1;
	for(int i=1;i<=_sqrt;i++) if(x%(i*i)==0) cnt=i;
	return cnt;
}
signed main(){
	// 	freopen("uqe.in","r",stdin);
	// 	freopen("uqe.out","w",stdout);
	cin>>t>>m;
	while(t--){
		int a=qr,b=qr,c=qr;
		int dt=((b*b)-(4*a*c));//计算德尔塔
		if(dt<0){//无解
			puts("NO");
			continue;
		}
		int _sqrt_dt=sqrt(dt);
		if(_sqrt_dt*_sqrt_dt==dt){//如果存在整数解
			int ans2=(2*a);
			int ans1;
			if(ans2<0) ans1=-b-sqrt(dt);//求较大解
			else ans1=-b+sqrt(dt);
			print(ans1,ans2);
			putchar('\n');//换行
		}
		else{
			int ans1=-b;
			int ans2=2*a;
			if(ans1!=0){
				print(ans1,ans2);//输出
				cout<<"+";//留加号
			}
			int cnt=qwq(abs(dt));
			ans1=cnt,ans2=2*a;
			if(ans2<0){
				ans2=-ans2;
				cnt=-cnt;
			}
			int x=gcd(abs(ans1),abs(ans2));//约分
			ans1/=x;
			ans2/=x;
			if(ans1!=1){//若前面有因数，输出并留乘号
				if(ans2!=1) cout<<ans1<<'*'<<"sqrt("<<dt/(cnt*cnt)<<')'<<'/'<<ans2;//若分母不为一，输出分母部分
				else cout<<ans1<<'*'<<"sqrt("<<dt/(cnt*cnt)<<')';//否则只输出因数加根号部分
			}
			else{
				if(ans2!=1) cout<<"sqrt("<<dt/(cnt*cnt)<<')'<<'/'<<ans2;//若分母不为一，输出分母部分
				else cout<<"sqrt("<<(dt/(cnt*cnt))<<")";//否则只输出根号部分
			}
			putchar('\n');//换行
		}
	}
	return 0;
}
```

---

## 作者：_JF_ (赞：7)

[P9750 [CSP-J 2023] 一元二次方程](https://www.luogu.com.cn/problem/P9750)

你说的对，但是我期中考前来写题解。

从头开始想这个题，比较抽象的模拟题。

首先几个注意的事项以及一些细节：

- 下文提到的化简，指的是对于分子分母同时除以他们的最大公因数。同时注意如果分母是 $1$，直接输出分子即可。

- 下文提到的对分母的正负性讨论，指的是如果分母可能是正数或者负数，那么讨论分子可能出现的情况。假设如果分母是负数，枚举分子可能出现的两负，两正，一正一负，发现如果要取最大值的话，要求分子尽可能的小，那就是说明 $-b\pm\sqrt{\Delta}$ 要取负号，分母是正的同理。可以发现，这个取法和 $\sqrt{\Delta}$ 的值无关。

首先对于 $\Delta<0$，显然无解。

如果 $\Delta=0$，那我们只用输出 $\frac{-b}{2a}$ 即可。这两个都是整数，直接化简。

如果 $\Delta >0$，那么我们考虑先把 $\Delta$ 算出来，因为它最多也是到 $10^6$，所以一种方法是直接枚举他的最大的平方因子，但是这个人脑抽用了预处理质数然后看每个质数的偶数次平方还获得最大平方因子的方法。仅供参考。

为了方便，我们把 $-b$ 和 $\Delta$ 分开考虑。这时候再考虑，如果 $\Delta$ 恰好是一个完全平方数，那么它势必可以和前面的 $-b$ 合并起来，在这里对分母的正负性讨论，同时化简，否则如果不是完全平方数，那就分开化简以后再进行对分母的正负性讨论。

同时注意 $b=0$ 的情况，因为分开来看了，这时候不能输出前置的 $0$。

代码写得比较抽象。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =4e4+10;
int Prime[N],num;
bool vis[N];
int GCD(int a,int b){
	if(b==0)	return a;
	return GCD(b,a%b);
}
int Quickpow(int a,int b){
	int ans=a,now=1;
	while(b>0){
		if(b&1)	now*=ans;
		ans*=ans;
		b>>=1;
	}
	return now;
} 
void init(){
	for(int i=2;i<=32000;i++){
		if(vis[i]==false)	Prime[++num]=i;
		for(int j=1;j<=num&&i*Prime[j]<=32000;j++){
			vis[i*Prime[j]]=true;
			if(i%Prime[j]==0)
				break;
		}
	}
}
int main(){
//	freopen("uqe.in","r",stdin);
//	freopen("uqe.out","w",stdout);
	init();
	int t,M;
	cin>>t>>M;
	while(t--){
		int a,b,c;
		cin>>a>>b>>c;
		int now=b*b-4*a*c; 
		if(b*b-4*a*c<0)	{cout<<"NO"<<endl;continue;}
		if(b*b-4*a*c==0&&b==0)	{cout<<"0"<<endl;continue;}
		if(now==0){
			int G=GCD(b,2*a);
			b/=G,a=a*2/G;
			if(a==1)	cout<<-b<<endl;
			else if((a<0&&b<0)||(a>0&&b>0))	cout<<"-"<<abs(b)<<"/"<<abs(a)<<endl;
			else{
				if(a<0)	cout<<b<<"/"<<abs(a)<<endl;
				else	cout<<abs(b)<<"/"<<a<<endl;
			}
		}
		else{
//			cout<<now<<endl;
			int lst=a;
			int predis=1;
			for(int i=1;i<=num;i++){
//				if(now%(Prime[i]*Prime[i])==0)	predis*=Prime[i],now/=Prime
				int lsst=1,Q=0;
				while(now%(lsst*Prime[i])==0)	lsst*=Prime[i],Q++;
				if(Q%2!=0)	Q--;
				predis*=Quickpow(Prime[i],Q/2),now/=Quickpow(Prime[i],Q); 
				if(now<Prime[i])	break;
			}
			if(now==1){
				a=a*2;
				int pre1=-b+predis,pre2=-b-predis,ch;
//				cout<<pre1<<" "<<pre2<<endl;
				if(a<0){
					if(pre1>=0&&pre2<0)	ch=pre2;
					else if(pre1<0&&pre2>=0)	ch=pre1;
					else if(pre1>=0&&pre2>=0)	ch=min(pre1,pre2);
					else	ch=min(pre1,pre2);
				}
				else{
					if(pre1>0&&pre2<=0)	ch=pre1;
					else if(pre1<=0&&pre2>0)	ch=pre2;
					else if(pre1>=0&&pre2>=0)	ch=max(pre1,pre2);
					else	ch=max(pre1,pre2);
				}				
//				cout<<ch<<" "<<a<<endl;
				int g=GCD(ch,a);
				if(ch==0)	{cout<<0<<endl;continue;}
				ch/=g,a/=g; 
				if(a==1)	cout<<ch<<endl;
				else if((a<0&&ch<0)||(a>0&&ch>0))	cout<<abs(ch)<<"/"<<abs(a)<<endl;
				else{
					if(a<0)	cout<<"-"<<ch<<"/"<<abs(a)<<endl;
					else	cout<<"-"<<abs(ch)<<"/"<<a<<endl;
				}
				continue;
			}
			if(b!=0){	
				int G=GCD(b,2*a);
				b=b/G,a=a*2/G;
				if(a==1)	cout<<-b<<"+";
				else if((a<0&&b<0)||(a>0&&b>0))	cout<<"-"<<abs(b)<<"/"<<abs(a)<<"+";
				else{
					if(a<0)	cout<<b<<"/"<<abs(a)<<"+";
					else	cout<<abs(b)<<"/"<<a<<"+";
				}
			}
			a=lst;
			int G=GCD(a*2,predis);
			predis/=G,a=a*2/G;
			a=abs(a),predis=abs(predis);
			if(predis==1){
				if(a==1)	cout<<"sqrt("<<now<<")"<<endl;
				else cout<<"sqrt("<<now<<")"<<"/",cout<<abs(a)<<endl;
			}
			else{
				if(a==1)	cout<<abs(predis)<<"*"<<"sqrt("<<now<<")"<<endl;
				else{
					cout<<predis;
					cout<<"*"<<"sqrt("<<now<<")"<<"/";
					cout<<a<<endl;
				}
			}
		}
	}	
}
/*
9 1000
1 0 -432
1 -3 1
2 -4 1
1 7 1

*/
```


---

## 作者：tallnut (赞：5)

~~€€£ 传统技能大（小？）模拟，赛场调了 1h30min。~~

一步一步来实现。
# 具体过程
## 约分
可以看到最终要求输出最简形式，因此约分将会很常用。为此我们可以设计一个 reduce() 函数专门处理约分。

假设需要约分的两个数为 $x,y$。直接枚举 $2$ 到 $\min(x,y)$ 的所有约数，并不断地将两数除以质因子，直到至少有一个数除不尽。

**记得使用引用类型传参**，否则爆零。

代码先不放了，到了最后统一给出。
## main()
main() 函数才是最难调的。

首先发现 $\Delta$ 非常常用，因此需要提前计算出 $\Delta$ 的值。

然后直接判断。
### $\Delta < 0$ 的情况
如果 $\Delta < 0$ 那最好办，直接输出 `NO` 即可。
### $\Delta = 0$ 的情况
如果 $\Delta = 0$ 那也比较简单，判断一下是否为负，未负就打上 `bool` 标签表示为负，然后将两数转换为绝对值；再约一下分，特判一下输出即可。
### $\Delta > 0$ 的情况
这个情况棘手一些。
#### 提取平方因子
首先我们需要将 $\Delta$ 的平方因子提取出来单独输出。依然使用一重循环枚举因子并判断即可。
#### 分离有理数和无理数
如果 $\Delta = 1$ 说明原来的 $\Delta$ 为完全平方数，因此最终结果是有理数，采用类似于 $\Delta = 0$ 的情况下的处理方式即可。

否则 $\Delta$ 就是无理数，需要把有理数部分和无理数部分分别输出。依然采用类似于 $\Delta = 0$ 的情况下的处理方式，对着有理部分和无理部分分别跑一次即可。
# AC 代码
[AC 记录](https://www.luogu.com.cn/record/132354854)，考场上仓促写的，没多少注释，但前面的分析足够了。一道大模拟而已，应该不会看不懂吧。

```
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
//x=(f+g*sqrt(delta))/e
int t,m,a,b,c,delta,e,f,g,fg,tmpe;
bool negative;
void reduce(int& x,int& y)
{
	for (int i = 2;i <= x && i <= y;i++)
		while (x % i == 0 && y % i == 0)
		{
			x /= i;
			y /= i;
		}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	freopen("uqe.in","r",stdin);
	freopen("uqe.out","w",stdout);
	cin >> t >> m;
	while (t--)
	{
		cin >> a >> b >> c;
		delta = b * b - 4 * a * c;
		negative = false;
		e = 0;
		f = 0;
		g = 0;
		fg = 0;
		tmpe = 0;
		if (delta < 0) cout << "NO";
		else if (delta == 0)
		{
			e = a * 2;
			f = -b;
			if ((e < 0 && f > 0) || (e > 0 && f < 0)) negative = true;
			e = abs(e);
			f = abs(f);
			reduce(e,f);
			if (negative) cout << '-';
			if (f == 0) cout << 0;
			else if (e == 1) cout << f;
			else cout << f << '/' << e;
		}
		else
		{
			e = a * 2;
			f = -b;
			g = 1;
			for (int i = 2;i * i <= delta;i++)
				while (delta % (i * i) == 0)
				{
					g *= i;
					delta /= (i * i);
				}
			//youli
			if (delta == 1)
			{
				if (e > 0) fg = f + g;
				else fg = f - g;
				if ((e < 0 && fg > 0) || (e > 0 && fg < 0)) negative = true;
				e = abs(e);
				fg = abs(fg);
				reduce(e,fg);
				if (negative) cout << '-';
				if (fg == 0) cout << 0;
				else if (e == 1) cout << fg;
				else cout << fg << '/' << e;
			}
			//not youli
			else
			{
				//youli part
				tmpe = e;
				if ((tmpe < 0 && f > 0) || (tmpe > 0 && f < 0)) negative = true;
				tmpe = abs(tmpe);
				f = abs(f);
				reduce(tmpe,f);
				if (negative) cout << '-';
				if (f != 0)
				{
					if (tmpe == 1) cout << f;
					else cout << f << '/' << tmpe;
					cout << '+';
				}
				//not youli part
				e = abs(e);
				g = abs(g);
				reduce(e,g);
				if (g != 1) cout << g << '*';
				cout << "sqrt(" << delta << ')';
				if (e != 1) cout << '/' << e;
			}
		}
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：WaterSun (赞：5)

# 思路

大模拟，按照题意模拟即可。

首先按照 $\Delta$ 的取值分为 $3$ 类：

1. $\Delta < 0$。

2. $\Delta = 0$。

3. $\Delta > 0$。

对于第 1 种情况，根据题意，输出 `NO`。

对于第 2 种情况，原方程只会有一个解为 $\frac{-b}{2a}$，求一个 $\gcd$ 约分即可。

对于第 3 种情况，原方程会有两个解 $\frac{-b \pm \times  \sqrt{\Delta}}{2a}$，此时我们可以得到此时取 $-$ 更优，还是取 $+$ 更优。在这里我们定义 $w = -1/1$ 表示在原方程中取 $-$ / $+$ 更优。

然后化简 $\sqrt{\Delta}$ 为一个 `pair t`，表示 $t_1 \sqrt{t_2}$ 并且满足 $\sqrt{t_2}$ 最简。

将 $t_2$ 的取值也分为 $2$ 种情况：

1. $t_2 = 1$。

2. $t_2 \neq 1$。

对于第 1 种情况，答案为 $\frac{-b + w \times t_1}{2a}$。

对于第 2 种情况，由于 $\frac{-b}{2a}$ 有可能为 $0$，所以需要单独判断一下即可。

# code

```cpp
#include <bits/stdc++.h>
#define fst first
#define snd second
#define re register
#define int long long
#define double long double

using namespace std;

typedef pair<int,int> pii;
const double eps = 1e-5;
int T,lim,a,b,c;

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 1) + (r << 3) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

inline int gcd(int a,int b){
    if (!b) return a;
    return gcd(b,a % b);
}

inline int qmi(int a,int b){
    int res = 1;
    while (b){
        if (b & 1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}

inline void print_num(int x,int y,bool f){
    if (!x){
        if (f) printf("0");
        return;
    }
    int w = 1;
    if (x < 0){
        x = -x;
        w *= (-1);
    }
    if (y < 0){
        y = -y;
        w *= (-1);
    }
    int g = gcd(x,y);
    x /= g;
    y /= g;
    if (!~w) printf("-");
    if (y == 1) printf("%lld",x);
    else printf("%lld/%lld",x,y);
}

inline pii get_sqrt(int x){
    pii res = {1,1};
    for (re int i = 2;i * i <= x;i++){
        if (x % i == 0){
            int cnt = 0;
            while (x % i == 0){
                cnt++;
                x /= i;
            }
            res.fst *= qmi(i,cnt / 2);
            res.snd *= max(1ll,i * (cnt % 2));
        }
    }
    if (x != 1) res.snd *= x;
    return res;
}

inline pii get_div(int w,bool ok,int x,int y){
    if (x < 0){
        x = -x;
        w *= (-1);
    }
    if (y < 0){
        y = -y;
        w *= (-1);
    }
    int g = gcd(x,y);
    x /= g;
    y /= g;
    if (ok){
        if (~w) printf("+");
        else printf("-");
    }
    return {x,y};
}

inline void solve(){
    int w;
    a = read();
    b = read();
    c = read();
    int del = b * b - 4 * a * c;
    if (del < 0){
        puts("NO");
        return;
    }
    if (!del){
        print_num(-b,2 * a,true);
        puts("");
        return;
    }
    double sdel = sqrtl(del);
    if ((1.0 * (-1.0 * b - sdel) / (2.0 * a)) > (1.0 * (-1.0 * b + sdel) / (2.0 * a))) w = -1;
    else w = 1;
    pii t = get_sqrt(del);
    if (t.snd == 1){
        int s = -b + w * t.fst;
        int m = 2 * a;
        print_num(s,m,true);
    }
    else{
    	double div = fabs((-b) / (2.0 * a));
    	bool ok;
    	print_num(-b,2 * a,false);
    	if (div > eps) ok = true;
		else ok = false;
		pii res = get_div(w,ok,t.fst,2 * a);
		if (res.fst != 1) printf("%lld*",res.fst);
		printf("sqrt(%lld)",t.snd);
		if (res.snd != 1) printf("/%lld",res.snd);
    }
    puts("");
}

signed main(){
    T = read();
    lim = read();
    while (T--) solve();
    return 0;
}
```

---

## 作者：dinghongsen (赞：4)

### P9750 [CSP-J 2023] 一元二次方程 题解

大模拟！

#### 解题思路

题目比较长，但中心就是求一元二次方程的最大实数解，否则输出 `NO`，读题就可以知道:

$\Delta \ = \ b^{2} \ - \ 4ac$

如果 $\Delta \ < \ 0$，就没有实数解

如果 $\Delta \ \ge 0$，就依照题意来写:

两个实数解 $x_{1,2} \ = \ \frac{-b\pm \sqrt{\Delta} }{2a} $

但 $2a \ < \ 0$ 时，应当用 $\frac{-b\pm \sqrt{\Delta} }{2a} $

#### AC Code

```cpp
# include <bits/stdc++.h>
using namespace std;
bool kaifang(int x) {
	int k = sqrt(x);
	return k * k == x;
}
void huajie(int fenzi, int fenmu) {
	int fu = 1;
	if (fenzi  < 0) {
		fu = -1;
		fenzi = -fenzi;
	}
	int k = __gcd(fenzi, fenmu);
	fenzi /= k;
	fenmu /= k;
	if (fenzi % fenmu == 0) {
		cout << fu * fenzi / fenmu;
	} else {
		cout << fenzi * fu << "/" << fenmu;
	}
}
int check(int x) {
	int ret = 1;
	for (int i = 2; i * i <= x; i++) {
		if (x % (i * i) == 0) {
			ret = i;
		}
	}
	return ret;
}
void huajie2(int fenzi, int fenmu, int delta) {
	if (fenzi % fenmu == 0) {
		if (fenzi / fenmu == 1) {
			cout << "sqrt(" << delta << ")" << "\n";
		} else {
			cout << fenzi / fenmu << "*sqrt(" << delta << ")" << "\n";
		}
		return;
	}
	int k = __gcd(fenzi, fenmu);
	fenzi /= k;
	fenmu /= k;
	if (fenzi == 1) {
		cout << "sqrt(" << delta << ")/" << fenmu << "\n";
	} else {
		cout << fenzi << "*sqrt(" << delta << ")/" << fenmu << "\n";
	}
}
int main() {
	int T, M;
	scanf("%d%d", &T, &M);
	while (T--) {
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		if (a < 0) {
			a *= -1;
			b *= -1;
			c *= -1;
		}
		int delta = b * b - 4 * a * c;
		if (delta < 0) {
			printf("NO\n");
			continue;
		}
		if (kaifang(delta)) {
			int ret;
			int flag = 0;
			int k = sqrt(delta);
			ret = (-b + k) / (2 * a);
			if ((-b + k) % (2 * a) == 0) {
				printf("%d\n", ret);
				continue;
			}
			huajie(-b + sqrt(delta), 2 * a);
			printf("\n");
			continue;
		}
		if (b != 0) {
			huajie(-b, 2 * a);
			printf("+");
		}
		int yinzi = check(delta);
		delta /= yinzi * yinzi;
		huajie2(yinzi, 2 * a, delta);
	}
    return 0;
}
```

---

## 作者：COsm0s (赞：4)

大模拟。

考场上最重要的就是理清思路，我们先把此题所有的细节梳理一遍。

+ 无解，即 $\Delta < 0$，这需要在开头直接判。

+ 解为 $0$，需要特别输出。

+ 解为有理数，即 $\Delta$ 为完全平方数。

+ $q_1$ 为 $0$，即 $2a$ 整除 $b$。

+ $q_2$ 为 $0$，即 $2a$ 整除 $\sqrt{\Delta}$。

+ 化简分数，这里需要除以 $\gcd$，并且注意舍去分母为 $1$ 的情况。

+ 这一步很重要，即判断 $\pm\sqrt{\Delta}$。

	+ 当 $ \sqrt{\Delta}$ 和 $2a$ 同号时，取正号。
    
    + 反之则取负号。

+ 最后一步，就是判断解的正负号。

自此本题所有的情况列出，那么代码就迎刃而解了。

本人赛时半个小时码出，此题必须要求头脑清醒。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int M;
namespace Jelly {
	const int N = 1e6 + 5, inf = INT_MAX;
	void print(int x, int y) {
		if(x == 0) return ;
		if(x < 0 && y < 0) x = -x, y = -y;
		else if(x < 0) x = -x, cout << '-';
		else if(y < 0) y = -y, cout << '-';
		int k = __gcd(x, y);
		if(y / k == 1) cout << x / k;
		else cout << x / k << '/' << y / k;
	}
	int main() {
		int a, b, c;
		cin >> a >> b >> c;
		int delta = b * b - 4 * a * c;
//		cout << delta << '\n';
		if(delta < 0) {
			cout << "NO\n";
			return 0;
		}
//		(-b + sqrt(delta)) / 2a
		int t = sqrt(delta);
		if(t * t == delta) {
			if(a > 0) {
				if(-b + t == 0) cout << 0;
				else print(-b + t, 2 * a);
			} else {
				if(-b - t == 0) cout << 0;
				else print(-b - t, 2 * a);
			}
			cout << '\n';
		} else {
			int xishu = 1;
			for(int i = t; i >= 2; i --) {
				if(delta % (i * i) == 0) xishu *= i, delta /= (i * i);
			}
			print(-b, 2 * a);
			if(b != 0) cout << '+';
//			cout << xishu << ' ' << delta << '\n';
			if(a < 0) a = -a;
			int k = __gcd(2 * a, xishu);
			xishu /= k;
			if(xishu != 1) cout << xishu << '*';
			cout << "sqrt(" << delta << ")";
			if(2 * a / k != 1) cout << '/' << 2 * a / k;
			cout << '\n';
		}
		return 0;
	}
}
signed main() {

	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int T = 1;
	cin >> T >> M;
	while(T --) Jelly::main();
	return 0;
}
```

---

## 作者：Milthm (赞：4)

不难的中模拟，完全按照题意写就可以。

首先读入先判掉 $b^2<4ac$ 的情况，输出 `NO`。

然后按照题意逐条模拟即可，注意分数要约分，要写 `gcd`。其它只有 $2$ 个要注意的点：

- 分子是 $0$ 不需要输出分母。

- 输出最大解分子不一定是 $-b+\sqrt{b^2-4ac}$，在 $2a<0$ 时为 $-b-\sqrt{b^2-4ac}$。

很坑，考场上因为这个调了好久。

### AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,M,a,b,c;
int gcd(int x,int y){
	if(x%y==0)return y;
	return gcd(y,x%y);
}
signed main(){
	cin>>T>>M;
	while(T--){
		cin>>a>>b>>c;
		if(b*b-4*a*c<0){
			cout<<"NO\n";continue;
		}
		if((int)sqrt(b*b-4.0*a*c)*(int)sqrt(b*b-4.0*a*c)==b*b-4*a*c){
			int qwq,ttq=2*a,f=1;
			if(ttq>0)qwq=-b+sqrt(b*b-4*a*c);
			else qwq=-b-sqrt(b*b-4*a*c);
			//cout<<qwq<<" "<<ttq<<'\n';
			int g=1;
			if(qwq<0)f=-1,qwq=-qwq;
			if(ttq<0){
				if(f==1)f=-1;
				else f=1;ttq=-ttq;
			}
			if(qwq!=0&&ttq!=0)g=gcd(qwq,ttq);
			qwq/=g;ttq/=g;qwq*=f;
			if(ttq==1||qwq==0)cout<<qwq<<'\n';
			else cout<<qwq<<"/"<<ttq<<'\n';
		}
		else{
			int q1up=-b,q1down=2*a,f=1;
			if(q1up<0)f=-1,q1up=-q1up;
			if(q1down<0){
				if(f==1)f=-1;
				else f=1;q1down=-q1down;
			}
			int g=1;
			if(q1up!=0&&q1down!=0)g=gcd(q1up,q1down);
			q1up/=g;q1down/=g;q1up*=f;
			if(q1up!=0){
				if(q1down==1)cout<<q1up;
				else cout<<q1up<<"/"<<q1down;
				cout<<"+";
			}
			int r=b*b-4*a*c,q2up=1,q2down=2*a;
			for(int i=2;i*i<=r;++i){
				while(r%(i*i)==0){
					r/=(i*i);
					q2up*=i;
				}
			}
			g=1;f=1;
			if(q2down<0)q2down=-q2down;
			if(q2up!=0&&q2down!=0)g=gcd(q2up,q2down);
			q2up/=g;q2down/=g;q2up*=f;
			if(q2up==1&&q2down==1)cout<<"sqrt("<<r<<")\n";
			else if(q2down==1)cout<<q2up<<"*sqrt("<<r<<")\n";
			else if(q2up==1)cout<<"sqrt("<<r<<")/"<<q2down<<'\n';
			else cout<<q2up<<"*sqrt("<<r<<")/"<<q2down<<'\n';
		}
	}
	return 0;
}


```


---

## 作者：tder (赞：3)

~~中模拟~~

---

浅看一下，大概会涉及到分数和根式的处理，分别写两个结构体吧。

先看分数，$p,q$ 分别表示分子和分母，即 $\dfrac pq$。需要一些函数支持化简、相加两个操作。化简分子分母同时除以最大公因数即可，形式化的说，$\dfrac xy=\dfrac{x\div\gcd(x,y)}{y\div\gcd(x,y)}$。而相加需要先通分后相加，通分让分母都变为最小公倍数，相加分子直接相机，形式化为 $\dfrac ab+\dfrac cd=\dfrac{a\times d\div\gcd(b,d)+c\times b\div\gcd(b,d)}{b\times d\div\gcd(b,d)}$。

然后是根式，$k,r$ 表示系数和被开方数，即 $k\sqrt r$。同样需要化简操作，遍历所有平方数 $i^2$，如果 $r\equiv 0\pmod{i^2}$，则 $r\leftarrow r\div i^2$ 且 $k\leftarrow k\times i$。

模拟一下。先计算出 $\Delta^2=b^2-4ac$，如果 $\Delta^2<0$ 则无解，输出 $\texttt{No}$。否则 $x=\dfrac{-b\pm\sqrt{\Delta^2}}{2a}=\dfrac{-b}{2a}\pm\dfrac{\sqrt{\Delta^2}}{2a}$。其中 $x=q_1+q_2\sqrt{r}$，也就是 $q_1=\dfrac{-b}{2a},q_2=\pm\dfrac{1}{2a},r=\Delta^2$。又因为要求 $q_2>0$，所以当 $a$ 为正时符号为正，当 $a$ 为负时符号为负。

随后按题意模拟即可。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e4 + 5;
int t, m, a, b, c, s[N];
void init() { // 初始化平方数
    for(int i = 1; i <= sqrt(5 * m * m) + 5; i++) s[i] = i * i;
}
struct _frac { // 分数
    int p, q;
};
_frac operator!(_frac x) { // 分数化简
    int g = __gcd(x.p, x.q);
    return {x.p / g, x.q / g};
}
_frac operator+(_frac x, _frac y) { // 分数相加
    _frac r;
    if(x.q == y.q) r = (_frac){x.p + y.p, x.q}; // 同分母
    else { // 异分母
        int g = x.q * y.q / __gcd(x.q, y.q);
        r = (_frac){x.p * g / x.q + y.p * g / y.q, g};
    }
    return !r; // 注意需要再次化简
}
struct _sqrt { // 根式
    int k, r;
};
_sqrt operator!(_sqrt x) { // 根式化简
    for(int i = 2; s[i] <= x.r; i++) // 枚举平方数
        while(x.r % s[i] == 0) {
            x.r /= s[i];
            x.k *= i;
        }
    return x;
}
void printn(_frac x) { // 输出分数
    if(x.q == 1) cout<<x.p; // 分母为 1
    else {
        if(x.p * x.q < 0) cout<<"-"; // 提负号
        cout<<abs(x.p)<<"/"<<abs(x.q);
    }
}
void printr(_frac x, _sqrt y) { // 输出根式
    if(x.p == 1 && x.q == 1) cout<<"sqrt("<<y.r<<")";
    else if(x.q == 1) cout<<x.p<<"*sqrt("<<y.r<<")";
    else if(x.p == 1) cout<<"sqrt("<<y.r<<")/"<<x.q;
    else cout<<x.p<<"*sqrt("<<y.r<<")/"<<x.q;
}
signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin>>t>>m;
    init();
    while(t--) {
        cin>>a>>b>>c;
        int d = b * b - 4 * a * c; // 计算 Delta 方
        if(d < 0) cout<<"NO"<<endl; // 无解
        else {
            _frac q1 = {-b, 2 * a};
            q1 = !q1;
            _sqrt rt = {1, d};
            rt = !rt;
            if(rt.r == 1) { // 特判根号 1
                _frac q2 = {rt.k, abs(2 * a)};
                _frac ans = q1 + q2;
                printn(ans);
            } else if(!rt.r) { // 特判根号 0
                printn(q1);
            } else {
                if(q1.p) { // q1 非 0
                    printn(q1);
                    cout<<"+";
                }
                _frac q2 = {rt.k, abs(2 * a)}; // 注意取绝对值
                q2 = !q2; 
                printr(q2, rt);
            }
            cout<<endl; // 一定要换行
        }
    }
    return 0;
}
```

---

## 作者：happy_zero (赞：1)

感觉其实没有什么难点，题目都描述很清楚了，直接无脑模拟即可。

首先计算 $\Delta=b^2-4ac$：

- $\Delta<0$：直接输出 $-1$ 即可；

- $\Delta\ge0$：
- - $\Delta$ 为完全平方数：

求出两个可能的分子：$-b\pm\sqrt{\Delta}$，按分母 $-2a$ 的正负分类讨论，取较大的那个按实数形式输出（若是分数先约分，具体按题目要求）；
- - $\Delta$ 不为完全平方数：

1. 先把 $\sqrt{\Delta}$ 化简（具体的，枚举 $1\sim \sqrt{\Delta}$ 看存在的最大 $x$ 使得 $x^2$ 整除 $\Delta$，把 $x^2$ 提出来变成 $x$）；

2. 输出分数/整数部分（如果有的话，要求同上）；

3. 输出根号的部分，这是一定是正的，还是按题目要求输出。


代码很短，整理完正好 60 行：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int w = 1, q = 0; char ch = ' ';
	while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if (ch == '-') w = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
	return w * q;
}
void print(int a, int b, int op) {//输出 a/b，op 为 1 是情况二，否则是情况三 
	int w = 1;//w 表示正负 
	if (a < 0 && b > 0) cout << '-';
	if (a > 0 && b < 0) cout << '-';
	a = abs(a), b = abs(b); //有 w 了就按整数考虑 
	if (!b && op) cout << "0";//若为 0 则情况二要输出，情况三不用 
	if (b) {
		int Gcd = __gcd(a, b);
		a /= Gcd, b /= Gcd;//约分 
		if (a == 1) cout << b;//分母为 1 则不输出 
		else cout << b << '/' << a;
	} 
	if (op) cout << "\n";
	else if (b) cout << "+";//情况三若前面为 0 则不用输出 + 
}
signed main() {
	int T = read(), M = read();
	while (T--) {
		int a = read(), b = read(), c = read();
		int t = b * b - 4 * a * c;//计算 /Delta 
		if (t < 0) {//情况一 
			cout << "NO\n";
			continue;
		}
		int sqt = sqrt(t);
		if (sqt * sqt == t) {//情况二 
			int zi1 = -b + sqt, zi2 = -b - sqt, zi;//两个可能的分子 
			a = 2 * a; 
			if (a > 0) zi = max(zi1, zi2);//分情况取 
			else zi = min(zi1, zi2);
			print(a, zi, 1);
			continue;
		}
		//情况三 
		int sum = 1;
		for (int i = sqt; i >= 2; i--) 
			if (t % (i * i) == 0) {//求最大的完全平方数 
				sum = i, t /= i * i;//t 记得除掉 i*i 
				break;
			}
		a = 2 * a, b = -b;
		print(a, b, 0); a = abs(a);//a 要取正 
		int Gcd = __gcd(a, sum);
		a /= Gcd, sum /= Gcd;
		if (sum != 1) cout << sum << "*";//sum 不为 1 的时候才输出 
		cout << "sqrt(" << t << ")";
		if (a != 1) cout << "/" << a;
		cout << "\n";
	}
	return 0;
}	
```


---


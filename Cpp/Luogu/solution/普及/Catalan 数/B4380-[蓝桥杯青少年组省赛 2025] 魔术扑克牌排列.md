# [蓝桥杯青少年组省赛 2025] 魔术扑克牌排列

## 题目描述

魔术师大卫将 $n$ 张红色扑克牌和 $n$ 张蓝色扑克牌混合在一起并打乱洗牌后，整齐叠放在桌子上。然后大卫请现场嘉宾从这叠牌最上面的扑克牌开始拿，连续拿取任意数量的牌组成一沓（至少拿 $1$ 张，最多拿 $2n$ 张）。接下来是见证奇迹的时刻，无论嘉宾拿多少张扑克牌，所拿取的这沓牌中红色扑克牌的数量都不少于蓝色扑克牌的数量。

给定红色扑克牌和蓝色扑克牌的张数 $n$，请帮魔术师计算出能实现上述魔术效果的扑克牌从上到下的排列方式共有多少种。


## 说明/提示

对于 $3$ 红 $3$ 蓝的牌，有以下 $5$ 种排列方式满足条件（用 R 表示红牌，B 表示蓝牌）：

1. R R B R B B
2. R B R B R B
3. R B R R B B
4. R R R B B B
5. R R B B R B

【备注：原题为配图解释，由于没有高清图片，洛谷只提供书面文字说明】

## 样例 #1

### 输入

```
3```

### 输出

```
5```

# 题解

## 作者：FJ_EYoungOneC (赞：5)

### 解题思路

题目要求方案数，考虑动态规划。

$f_{i, j}$ 表示在前 $i$ 张牌中有 $j$ 张红牌的符合题目要求的所有合法方案数。

考虑动态转移：

- 如果第 $i$ 张牌是红牌，那么前 $i - 1$ 张牌需要有 $j - 1$ 张红牌，即 $f_{i, j} = f_{i - 1, j - 1}$。
- 如果第 $i$ 张牌是蓝牌，那么前 $i - 1$ 张牌需要有 $j$ 张红牌，即  $f_{i, j} = f_{i - 1, j}$

所以 $f_{i, j} = f_{i - 1, j - 1} + f_{i - 1, j}$。

由于答案可能很大，需要用高精度进行计算。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 3e2 + 10;

int n, m;
vector<int> f[N][N];

vector<int> add(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size() || i < B.size() || t; ++ i )
    {
        if (i < A.size())
            t += A[i];
        if (i < B.size())
            t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    return C;
}

int main()
{
    cin >> n;
    m = n * 2;

    f[1][1] = vector<int>(1, 1);
    for (int i = 2; i <= m; ++ i )
        for (int j = (i + 1) / 2; j <= n; ++ j )
            f[i][j] = add(f[i - 1][j - 1], f[i - 1][j]);

    vector<int> res(1, 0);
    for (int i = n; i >= n - i; -- i )
        res = add(res, f[m][i]);

    for (int i = res.size() - 1; i >= 0; -- i )
        cout << res[i];
    
	return 0;
}

```

---

## 作者：PoetryAndDistance (赞：5)

## 题意
有 $2N$ 张牌，其中 $N$ 张是红色牌，$N$ 张是蓝色牌，开始时桌子上是空的，每次把一张红色牌或者一张蓝色牌放到牌堆上，且任意时刻红色牌数不能低于蓝色牌数，问有多少种排列方案
## 思路
$f(i,j)$ 表示一共有 $i$ 张牌，红牌有 $j$ 张，蓝牌有 $i-j$ 张的方案数，初始状态 $f(0,0) = 1$，对于 $f(i,j)$ ，如果此时放红牌，那么来自状态 $f(i-1,j-1)$ , 如果此时放蓝牌，那么来自状态 $f(i-1,j)$，答案为此两种状态相加，注意总数很大，要用**高精度加法** ，代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
string add(string a,string b){//高精加 
	string c;
	reverse(a.begin(),a.end());
	reverse(b.begin(),b.end());
	int temp = 0;
	for(int i=0;i<a.size()||i<b.size();i++){
		if(i < a.size()) temp += a[i] - '0';
		if(i < b.size()) temp += b[i] - '0';
		c += temp%10 + '0';
		temp /= 10;
	}
	if(temp) c += '1';
	reverse(c.begin(),c.end());
	return c;
}
int n,m,a[N];
string f[N+N][N];
void solve(){
	cin >> n;
	f[0][0] = "1";
	for(int i=1;i<=n+n;i++){
		for(int j=1;j<=n;j++){
			if(j <= i && j >= i-j)//j为红牌数量，必须大于蓝牌数量,而且j必须小于等于i 
				f[i][j] = add(f[i-1][j-1],f[i-1][j]);
		}
	}
	cout << f[n+n][n] << "\n";
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int t = 1;
//	cin >> t;
	while(t--) solve();
	return 0;
}

```

---

## 作者：zyzxzhangyi (赞：3)

# [题目传送门](https://www.luogu.com.cn/problem/B4380)

# 前言

场切了这题，肯定要写篇题解庆祝一下。

# 思路

考虑动态规划，定义 ${dp_i}_j$ 表示前 $i+j$ 张扑克牌中 $i$ 张红色扑克牌和 $j$ 张蓝色扑克牌的方案数，此时要保证 $i\ge j$。

转移方程很明显就是 ${dp_i}_j = {dp_{i-1}}_j+{dp_i}_{j-1}$，记得判断 $i-1\ge j$，否则无法从 ${dp_{i-1}}_j$ 转移。

最终答案就是 ${dp_n}_n$。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n, dp[105][105];

int main(){
	cin >> n;
	for(int i = 0; i <= n; i++) dp[i][0] = 1;
	for(int i = 1; i <= n; i++)
	    for(int j = 0; j <= i; j++)
	        if(i > j) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
	        else dp[i][j] = dp[i][j - 1];
	cout << dp[n][n] << "\n";
	return 0;
}
```
然后就发现只有 $40$ 分，用 ```__int128``` 也只有 $45$ 分，因为答案可能会达到 $2^n$，我们只能写高精度了。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[105], b[105], c[105];
string dp[105][105];

string jf(string s1, string s2){
	string s3 = "";
	int len1 = s1.length(), len2 = s2.length(), len3 = max(len1, len2) + 1;
	memset(a, 0, sizeof(a)), memset(b, 0, sizeof(b)), memset(c, 0, sizeof(c));
	for(int i = 1; i <= len1; i++) a[i] = s1[len1 - i] - '0';
	for(int i = 1; i <= len2; i++) b[i] = s2[len2 - i] - '0';
	for(int i = 1; i < len3; i++) c[i] += a[i] + b[i], c[i + 1] = c[i] / 10, c[i] %= 10;
	while(!c[len3] && len3 > 1) len3--;
	for(int i = len3; i >= 1; i--) s3 += char(c[i] + '0');
	return s3;
}//高精度

int main(){
	cin >> n;
	for(int i = 0; i <= n; i++) dp[i][0] = "1";//初始化
	for(int i = 1; i <= n; i++)
	    for(int j = 0; j <= i; j++)
	        if(i > j) dp[i][j] = jf(dp[i - 1][j], dp[i][j - 1]);
	        else dp[i][j] = dp[i][j - 1];
	cout << dp[n][n] << "\n";//输出答案
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/230414093)

时间复杂度：$O(n^3)$。

空间复杂度：$O(n^2)$。

---

## 作者：liuyuantao (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B4380)

很版的 dp。唯一恶心的地方就是高精度了。  
赛时看到第 $6$ 题 dp 没有说 $\bmod$ $998244353$ ~~就知道暗藏玄机了……~~  
定义 $dp_{i,j}$ 表示一共摆 $i$ 张扑克牌，其中有 $j$ 张红色的方案数。初始化 $dp_{0,0}=1$，其它均为 $0$。  
考虑转移。根据第 $i$ 张为红色/蓝色，分别加入 $dp_{i-1,j-1},dp_{i-1,j}$ 种方案。

所以转移式子即为：$dp_{i,j}=dp_{i-1,j-1}+dp_{i-1,j}$。  
根据题目限制条件，一定有红色卡数量不少于蓝色，所以红色卡数量不少于总数的一半，即 $j \ge \frac{i}{2}$，枚举这一部分即可。只枚举这一部分可以让 $j-1 < \frac{i-1}{2}$ 的这部分非法情况的 $dp_{i-1,j-1}=0$ 而不加入答案。  
不算高精的话大概时空复杂度 $O(n^2)$。  
当然我这里用滚动数组优化了空间到 $O(n)$，并加入了判断。  
高精加原理就是用数组模拟数位加，这里不细讲，可看模板题 [P1601](https://www.luogu.com.cn/problem/P1601)。  
当然本题也可以用卡特兰数（Catalan number）计算，这里是高精乘模板 [P1303](https://www.luogu.com.cn/problem/P1303)，时间复杂度是 $O(n)$ 的。  
[AC code](https://www.luogu.com.cn/record/230320032)  
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=3e2+5;
int n;

struct Bigint{
	int A[N]={0};
	int sz=1;
	void clear(){
		for(int i=1;i<=sz;i++){
			A[i]=0;
		}
		sz=1;
		return ;
	}
	void wr(){
		for(int i=sz;i>=1;i--){
			cout<<A[i];
		}
		cout<<endl;
		return ;
	}
}dp[2][N];

void add(Bigint &x,Bigint y){
	int t=1;
	for(int i=1;i<=y.sz;i++){
		x.A[i]+=y.A[i];
	}
	for(int i=1;i<=200;i++){
		x.A[i+1]+=(x.A[i]/10);
		x.A[i]%=10;
		if(x.A[i]>0)t=i;
	}
    x.sz=t;
	return ;
}


int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
	dp[1][0].A[1]=1;dp[1][0].sz=1;
	for(int i=1;i<=n*2;i++){
		for(int j=0;j<=min(i,n);j++){
			dp[0][j]=dp[1][j];
			//dp[1][j].clear();
        }
		for(int j=ceil(i/2.0);j<=min(i,n);j++){
			//dp[1][j]=dp[0][j];
            if(2*j-2>=i-1){
                add(dp[1][j],dp[0][j-1]);
            }
		}
	}
	dp[1][n].wr();
    
    return 0;
}
```
这是本人的第 $3$ 篇 B 题库题解，如果觉得有用就点个赞吧！  
同场题解：
* [题解：B4379 [蓝桥杯青少年组省赛 2025] 硬币游戏](https://www.luogu.com.cn/article/a0xkcp7v)
* [题解：B4377 [蓝桥杯青少年组省赛 2025] 平衡奇偶位置的字符交换](https://www.luogu.com.cn/article/6ofc3ylz)

---

## 作者：Maxsong (赞：2)

# B4380 [蓝桥杯青少年组省赛 2025] 魔术扑克牌排列 题解

## 思路这一块

~我不懂卡特兰数~，所以可以用 DP ，设 $f _{i,j}$ 表示在第 $i$ 张牌被填充时有 $j$ 张蓝牌，那么就有 DP 式：

$$
f _{i,j} = f _{i-1,j}+f _{i-1,j-1}\ \ (j>0\  \text{且} \ i\ge 2j\  \text{才计入}\ f _{i-1,j-1})
$$

初始化 $f _{0,0} = 1$ 。

该题数据较大，应当使用高精度。

## 代码这一块

还是相对简单的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int>f[2001][1001];
vector<int>add(vector<int>a,vector<int>b){
    int n=a.size();
	int m=b.size();
    if(n==0) return b;
    if(m==0) return a;
    vector<int>s1,s2;
    vector<int>s3;
    s1=a,s2=b;
    int flag=0;
	for(int i=0;i<max(n,m);i++){
		s3.push_back((i<s1.size()?s1[i]:0)+(i<s2.size()?s2[i]:0)+flag);
		flag=s3[i]/10;
		s3[i]%=10;
	}if(flag==1) s3.push_back(1);
    return s3;
}signed main(void){
    scanf("%d",&n);
    f[0][0].push_back(1);
    for(int i=1;i<=2*n;i++) for(int j=0;j<i;j++){
        if(j>0&&i-j>=j) f[i][j]=add(f[i-1][j-1],f[i][j]);
        f[i][j]=add(f[i-1][j],f[i][j]);
    }for(int i=f[2*n][n].size()-1;i>=0;i--) cout<<f[2*n][n][i];
    cout<<endl;
    return 0;
}
```

> 并非魔术

---

## 作者：yangdezuo (赞：1)

## 解析
根据题意，对于这种两种东西排列，无论取前几个都能使一种不小于另一种，求排列数量，这就是经典的卡特兰数的应用。

如果不知道卡特兰数的[点这里](https://oi-wiki.org/math/combinatorics/catalan/)。

我们知道卡特兰数的计算式子为 $h(i)=h(i−1)∗(4∗i−2)/(i+1)$，在本题中 $1 \le N \le 100$，所以直接计算会超出 ```long long``` 和 ```__int128``` 的范围，如果使用 c++ 解决本题就需要用到高精度，但是高精度~~非常难打~~，一想 python 自带高精，所以使用 python 是个~~好的选择~~，套式子就结束了。

## 参考代码
```python
n=int(input())
x=1
for i in range(1,n+1):
    x=x*(4*i-2)//(i+1)
print(x)

```

---

## 作者：pengyirui (赞：1)

讲个笑话：考场高精度没打完。

---

卡特兰数板子题。

### 卡特兰数介绍

[课前练习。](https://www.luogu.com.cn/problem/P1044)\
卡特兰数是组合数学中一种常出现于各种计数问题中的数列。\
卡特兰数的定义为 $C_n=\frac{1}{n-1}\dbinom{2n}{n}$。\
其前几项为 $1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862$。\
卡特兰数的递推公式为 $C_n=\dfrac{4n-2}{n+1}C_{n-1}$。

### 关于本题

直接套用公式即可。

:::warning[警告]
**高精度！！！\
高精度！！！\
高精度！！！**
:::

### 证明

我们可以把红牌看作 $+1$，蓝牌看作 $-1$。\
题目要求转变为求前缀和均大于等于 0 的方案数。

#### 总排列数

假设不考虑限制条件，那么总排列数为：    
$$\dbinom{2n}{n}$$

#### 非法的排列数

我们可以把前 k 张牌中的 R 和 B 互换。（ R 变 B，B 变 R。）\
非法排列数为：
$$\dbinom{2n}{n+1}$$

#### 合法排列数

$$\dbinom{2n}{n}-\dbinom{2n}{n+1}\\=\frac{(2n)!}{n!n!}-\frac{(2n)!}{(n+1)!(n-1)!}\\=\frac{(2n)!}{n!n!}(1-\frac{n}{n-1})\\=\frac{(2n)!}{n!n!}\cdot\frac{1}{n-1}\\=\frac{1}{n-1}\dbinom{2n}{n}$$     
不难发现，这就是卡特兰数的定义。

### 代码

以前搜集的高精度，码风不同，请勿在意。

```cpp line-numbers
#include <bits/stdc++.h>
using namespace std;
long long n, a[1008617], c[1008617];
string f[105];
string div(string sa, int b) {
	int la = sa.length(), x = 0;
	for (int i = 0; i < la; i++) {
		a[i + 1] = sa[i] - '0';
	}
	for (int i = 1; i <= la; i++) {
		c[i] = (x * 10 + a[i]) / b;
		x = (x * 10 + a[i]) % b;
	}
	int lc = 1;
	while (c[lc] == 0 && lc < la) lc++;
	string s;
	for (int i = lc; i <= la; i++) {
		s += char(c[i] + '0');
	}
	return s;
}
string multiply(const string& num1, const string& num2) {
	string result(num1.size() + num2.size(), '0');
	int len1 = num1.size(), len2 = num2.size();
	for (int i = len1 - 1; i >= 0; --i) {
		int carry = 0;
		int n1 = num1[i] - '0';

		for (int j = len2 - 1; j >= 0; --j) {
			int sum = result[i + j + 1] - '0' + n1 * (num2[j] - '0') + carry;
			result[i + j + 1] = char(sum % 10 + '0');
			carry = sum / 10;
		}

		if (carry) {
			result[i] = char(carry + '0');
		}
	}
	size_t pos = result.find_first_not_of('0');
	return (pos == string::npos) ? "0" : result.substr(pos);
}
int main() {
	cin >> n;
	f[1] = "1";
	for (int i = 2; i <= n; i++) {
		string s = to_string(4 * i - 2);
		f[i] = div(multiply(f[i - 1], s), (i + 1));
	}
	cout << f[n];
	return 0;
}

```

### 课后练习

[更大的数据](https://www.luogu.com.cn/problem/P2532)\
[再推一下式子](https://www.luogu.com.cn/problem/P3978)\
[还有逆元](https://www.luogu.com.cn/problem/P1375)\
[更难的东西](https://www.luogu.com.cn/problem/solution/P4769)

---

## 作者：ethansang (赞：1)

# B4380 [蓝桥杯青少年组省赛 2025] 魔术扑克牌排列 题解
~~这次蓝桥杯题也太水了。~~
## 题意
>给你红蓝扑克牌各 $n$ 张，问有多少种排列方式，使得不论取多少张，红扑克牌数一定不小于蓝扑克牌数。
>
## 思路
>一眼 DP。
>
>设 $f_{i,j}$ 为红扑克牌有 $i$ 张，蓝扑克牌有 $j$ 张的排列数。我们可以想象有一个网格图，每来一张红扑克牌就向右走一步，来一张蓝扑克牌就向上走一步。因为 $j \le i$，则一定不能走超过网格的对角线（左下到右上）。边界条件是 $f_{i,0}=1$。
>
>这样状态转移就很好写了。若 $i=j$，则 $f_{i,j}=f_{i,j-1}$。否则，$f_{i,j}=f_{i-1,j}+f_{i,j-1}$。
>
>但是在考场上，我们发现只有 $55$ 分，原因是答案增长的太快了。因此，再加一维 $k$，表示高精度的第 $k$ 位。这样就能轻松 AC 了。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x3f3f3f3f
#define mod 1000000007
#define pi M_PI
#define lowbit(x) (x & -x)
#define ls u << 1
#define rs u << 1 | 1
#define pii pair<int, int>
#define debug cout << "OK" << endl;
const int N = 1e2 + 5;
int T = 1, n;
int f[N][N][N];

void solve()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		f[i][0][100] = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++){
			if (i == j){
				for (int k = 1; k <= 100; k++)
					f[i][j][k] = f[i][j - 1][k];
			} else {
				for (int k = 1; k <= 100; k++)
					f[i][j][k] = f[i - 1][j][k] + f[i][j - 1][k];
				for (int k = 100; k; k--){
					f[i][j][k - 1] += f[i][j][k] / 10;
					f[i][j][k] %= 10;
				}
			}
		}
	int i = 1;
	while (!f[n][n][i])
		i++;
	for ( ; i <= 100; i++)
		cout << f[n][n][i];
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    //cin >> T;
    while (T--)
        solve();

    return 0;
}
```

---

## 作者：__szh_DNCB__ (赞：1)

**Python 题解，想要高精度代码的同学别想了。**

蒟蒻的第十一篇题解，但不正经。

注意到题目问的是求卡特兰数列的第 $n$ 项。不知道卡特兰数的可以左转[百度百科卡特兰数](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746)和[ B 站卡特兰数讲解](https://www.bilibili.com/video/BV1emM3zbERb/?vd_source=ab07d917f4782e43794cf678c11f4d5b)。

所以套用卡特兰数计算公式，为：

$$C_n = \begin{cases}
  1 & n = 0 \\
  1 & n = 1 \\
  C_0C_{n-1} + C_1C_{n-2} + \cdots + C_{n-2}C_1 + C_{n-1}C_0 & n \ge 2
\end{cases}$$

但这题恶心就恶心在连 `__int128` 都存不下 $C_{100}$ 的大小，即需要使用高精度。

但是某位先贤曾经说过，高精度的题 Python 可以轻松切掉，所以我们这里使用 Python。

那么很容易就可以写出如下的代码。

```python
catalan = [1,1]
for i in range(2,101):
    sum = 0
    for j in range(0,i):
        sum += catalan[j] * catalan[i-1-j]
    catalan.append(sum)
n = int(input())
print(catalan[n])
```

提交，发现[通过了本题](https://www.luogu.com.cn/record/230309374)。

当然为了防止这篇题解太水，这里还是提供一下 C++ 高精度的板子，来源于 [MashPlant 大佬的题解](https://www.luogu.com.cn/article/9hdu0qo0)。

---

## 作者：ryderyang (赞：0)

考试的时候最后 $15$ 分钟把最后两题做出来了，写篇题解纪念一下！

## 解题思路
这道题很明显的卡特兰数，但是当时我忘记递推公式了，所以写了一个动态规划。

### 状态定义
我们设 $dp_{i,j}$ 表示选择 $i$ 个红色和 $j$ 个蓝色的方案数。
### 转移方程
如果最后一个牌是红色的，那么一共有 $dp_{i-1,j}$ 个方案。同理，如果最后一个牌是蓝色的，那么一共有 $dp_{i,j-1}$ 个方案。所以我们就可以得到转移方程：

$$
dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}
$$

注意一下边界条件即可。

## 程序
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Len=1e5+5;
int n;
string dp[105][105];
string add(string a,string b)
{
	int na[Len]={0},nb[Len]={0},nc[Len]={0};
	int la=a.size(),lb=b.size(),lc=max(la,lb);
	string ans="";
	for(int i=0;i<la;i++) na[i]=a[la-i-1]-'0';
	for(int i=0;i<lb;i++) nb[i]=b[lb-i-1]-'0';
	for(int i=0;i<lc;i++)
	{
		nc[i]+=na[i]+nb[i];
		if(nc[i]>=10)
		{
			nc[i]-=10;
			nc[i+1]++;
		}
	}
	if(nc[lc]!=0) lc++;
	for(int i=lc-1;i>=0;i--) ans+=nc[i]+'0';
	return ans;
}
int main()
{
	cin>>n;
	dp[0][0]="1";
	for(int i=1;i<=n;i++)
	{
		dp[i][0]="1";
		for(int j=1;j<=i-1;j++)
		dp[i][j]=add(dp[i-1][j],dp[i][j-1]);
		dp[i][i]=dp[i][i-1];
	}
	cout<<dp[n][n];
	return 0;
}
```

---

## 作者：return_third (赞：0)

其实是一道小奥题目。

# 思路

在解这类题目时，一般把取红色扑克牌看成横线，取蓝色扑克牌看成竖线，然后就可以得到下面的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fjibrp0k.png)

这里我们只取红线以右的三角形。这个图有什么含义呢？举个栗子，（正方形视角下）第二行第二个点表示取了一个红色扑克牌和一个蓝色扑克牌的方案数。那么第 $n$ 行第 $n$ 列就表示取 $n-1$ 个红色扑克牌和 $n-1$ 个蓝色扑克牌的方案数。

然后递推一下就行了。状态转移方程为 $f_{i,j}=f_{i,j-1}+f_{i-1,j}$，初始值为 $f_{1,i}=1$。注意要开高精度。

# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int n;
struct Big
{
	int len,a[1005];
	Big(int x=0)
	{
		len=0;
		memset(a,0,sizeof(a));
		while(x)
		{
			a[++len]=x%10;
			x/=10;
		}
	}
	Big operator+(const Big& x)const
	{
		Big ret;
		ret.len=max(len,x.len);
		for(int i=1;i<=ret.len;i++)
			ret.a[i]=a[i]+x.a[i];
		for(int i=1;i<=ret.len;i++)
			if(ret.a[i]>=10)
			{
				ret.a[i+1]++;
				ret.a[i]-=10;
			}
		if(ret.a[ret.len+1])ret.len++;
		return ret;
	}
	void write()
	{
		for(int i=len;i>=1;i--)
			printf("%d",a[i]);
	}
}f[N][N];
int main()
{
	scanf("%d",&n);
	n++; 
	for(int i=1;i<=n;i++)
		f[1][i]=1;
	for(int i=2;i<=n;i++)
		for(int j=i;j<=n;j++)
			f[i][j]=f[i][j-1]+f[i-1][j];
	f[n][n].write();
	return 0;
} 
```

---


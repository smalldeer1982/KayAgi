# 小猫

## 题目描述

有 $2n$ 只小猫站成一圈，主人小明想把它们两两之间用绳子绑住尾巴连在一起。同时小明是个完美主义者，不容许看到有两根绳子交叉。请问小明有几种连线方案，可以把让所有小猫两两配对？

方案数很大，仅需输出方案数模 $10^9+7$（一个质数）的值。




## 说明/提示

### 数据范围

- 对于 $60\%$ 的数据，$1\le N \le 100$。
- 对于 $100\%$ 的数据，$1\le N \le 10^5$。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

# 题解

## 作者：魁拔 (赞：19)

本题等同于多边形三角剖分问题，详情请见旧版人教版数学教科书七年级下册第86页

公式如下：a[n+1]:a[n]=4n-6:n(注：a[3]的值等于本题a[1]的值，以此类推)

递推式如下：a[i]:=a[i-1]\*(4\*i-2) div (i+1);

亦可用公式a[i]:=0.5\*(∑(j:=3 to i-1) a[j]\*a[i-j+2]);

从答案上也可以看出这题和栈是一样的，但考虑到数据非常大，要mod一个数，因此除法不适用（当然也可以用某种复杂方法解决，这里不展开），所以建议用方法二。

鉴于本人用的是第一种方法，第二种方法公式对不对就不保证了，可以试着自己推一推


---

## 作者：jiangXxin (赞：16)

这道题感觉有点卡python啊!!!,最后两个点始终过不去.

![](https://cdn.luogu.com.cn/upload/image_hosting/nxqhlmuc.png)

最后只好换上c++.

从题目内容来看，我们~~易知这是一道卡特兰数的模板题~~,卡特兰数一般有以下几个考法(摘自百度)：
```cpp
1：括号化

2：出栈次序

3：凸多边形三角划分

4：给定节点组成二叉搜索树

5：n对括号正确匹配数目
```


**本题属于凸多边形三角划分**

**证明过程**：(我抄我自己的另外一篇题解，也是卡特兰数，只不过是出栈次序，差不多，题目是[P1044 栈](https://www.luogu.org/problem/P1044))

我们已经知道，栈有两种操作，入栈和出栈.对此，我们可以建立一个坐标系.

像这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/n6qtja5n.png)

我们可以把

**黄色的线作为入栈操作，由$(x,y)$变成$(x+1,y+1)$**

**绿色的线作为出栈操作,由$(x,y)$变成$(x+1,y-1)$**

这样，我们就可以把问题抽象为从(0,0)到(2n,0),有多少种合法方案数

我们先来考虑这样一个问题，因为我每一次操作都可以让x+1,那么我总共要进行2n次操作，考虑到最后的栈要为空，所以**入栈次数等于出栈次数=n**,所以方案数则为$C_{2n}^n$.

**但是！！！**
我们这样，会出现非法的情况，也就是线越过x轴的情况（栈已经空了，但是还在弹出元素），也就是这种情况:

![](https://cdn.luogu.com.cn/upload/image_hosting/zgt6vmfu.png)

对于这种情况，我们可以设k为第一次与y=-1那条图线的交点，然后把交点以后的点都关于y=-1对称（即，交换操作1和操作2）

![](https://cdn.luogu.com.cn/upload/image_hosting/z5r69x8g.png)

由于我们现在的终点变成了$(2n,-2)$,所以我们的入栈次数肯定等于出栈次数-2,入栈次数加出栈次数等于2n,所以入栈为n-1次，出栈n+1次，则有不合法的总方案数为$C_{2n}^{n-1}$,所以最终结果为$C_{2n}^{n}$-$C_{2n}^{n-1}$.

根据组合数的定义，

![](https://cdn.luogu.com.cn/upload/image_hosting/xtfqh80e.png)


化简可以得到最终答案为$\frac{(2n)!}{(n+1)!(n)!}$,完结

证明过程大致就这样，最后输出答案的时候记得用乘法逆元，~~乘法逆元应该都会吧~~

**Code**:(自己加了个快乘的板子，怕爆long long)

c++:

```cpp
/**
*    author:  a2954898606
*    created: 2019/10/21 15:20:24
**/
#include<bits/stdc++.h>
#define REP(A,B,I) for(int I=(A);I<=(B);I++)
#define PER(A,B,I) for(int I=(A);I>=(B);I--)
#define LL long long
#define N 1000010
#define M 100
#define mod 1000000007
using namespace std;
long long quickmul(long long a,long long b){///快乘
    a%=mod;b%=mod;
    long long c=(long long)a*b/mod;
    long long ans=a*b-c*mod;
    if(ans<0)ans+=mod;
    else if(ans>=mod)ans-=mod;
    return ans;
}
long long quickpow(long long a,long long b){///快速幂
    long long ret=1;
    while(b){
        if(b&1)ret=ret*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ret;
}
long long n;
int main(){
    //read(1)
    //write(1)
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n;
    long long ans1=1,ans2=1,ans3=1,fina=1;
    REP(1,2*n,i){
        if(i<=n)ans2=quickmul(ans2,i);
        if(i<=n+1)ans3=quickmul(ans3,i);
        ans1=quickmul(ans1,i);
    }
    ans2=quickmul(ans2,ans3);
    fina=quickmul(ans1,quickpow(ans2,mod-2));
    cout<<fina<<endl;
    return 0;
}


```

python(只能得80，本人太弱，不能想到什么好的优化方法了):

```python
n=int(input())
m=2*n
m=m+1
a=1
b=1
c=1
for i in range(1,m):
    a=a*i
    if(i<=n):
        b=b*i
    if(i<=n+1):
        c=c*i
b=b*c
b=pow(b,1000000005,1000000007)
ans=int(a*b%1000000007)
print(ans)
```





---

## 作者：aakennes (赞：13)


打个表：$1$ $2$ $5$ $14$ $42$ （后面的打不出来了）
发现是卡特兰数，直接套公式：
$$Catalan(n)=C_{2\times n}^n-C_{2\times n}^{n-1}$$
$$Catalan(n)=\frac{C_{2\times n}^n}{n+1}$$
证明可以转化为一个平面直角坐标系，一个点只能斜向上或斜向下，且不能越过$x=0$，即不能触碰$x=-1$，所以直接全集减经过$x=-1$的方案即可

一般的括号序列，出栈入栈等问题都可以转化为类似的问题

这里的问题也是卡特兰数的一个经典问题：凸多边形三角划分

对卡特兰感兴趣的可以再康康P$1641$，是$excatalan$问题

代码：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e5+5,maxs=2e5+2,mol=1e9+7;
ll f[maxn],c[maxn],ans;
ll qpow(ll a,ll x){
	ll ans=1;
	while(x){
		if(x&1)ans=ans*a%mol;
		a=a*a%mol;
		x>>=1;
	}
	return ans;
}
void Init(){
	c[0]=1;
	for(int i=1;i<=maxs;i++)c[i]=c[i-1]*i%mol;
}
ll C(int n,int m){
	return c[n]*qpow(c[m],mol-2)%mol*qpow(c[n-m],mol-2)%mol;
}
ll Catalan(int n){
	return C(2*n,n)*qpow(n+1,mol-2)%mol;
}
int main(){
	int n;cin>>n;
	Init();
	cout<<Catalan(n);
}
```

---

## 作者：Karl_Aurora (赞：10)

### 在看代码之前，我们先来了解一个组合数学里的经典数列——Catalan数


~~~
Catalan数一般的应用都有括号化、出栈次序、凸多边形三角划分、给定节点组成二叉搜索树、n对括号正确匹配数目等,定义如下：

设h(n)为Catalan数的第n+1项，令h(0)=1,h(1)=1，Catalan数满足递推式：

h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)*h(0) (n>=2)

例如：h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2

h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5

另有递推式：
h(n)=h(n-1)*(4*n-2)/(n+1);

递推式的解为：
h(n)=C(2n,n)/(n+1) (n=0,1,2,...)

另有解为：
h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...)


~~~

看完定义，下面让我们回到这一题

这道题实质上等同于多边形三角剖分问题，是Catalan的一个经典例子，同时我们还要运用快速幂取模和乘法逆元进行优化计算，防止被卡

废话不多说，代码如下


```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
inline long long read(){
    long long X=0,w=0;char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}//快读 
inline void write(long long x) {
    static long long stk[100], top = 0;
    if(x==0){putchar('0');return;}
    if(x<0){x=-x;putchar('-');}
    while(x){stk[++top]=x%10;x/=10;}
    while(top)putchar(stk[top--] ^ '0');
    return;
}//快输 
long long pow_mod(long long a,long long b){
    long long ret=1;
    while(b){
        if(b&1)ret=ret*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ret;
}//快速幂 
long long mul_mod(long long a,long long b){
    a%=mod;b%=mod;
    long long c=a*b/mod;
    long long ans=a*b-c*mod;
    if(ans<0)ans+=mod;
    else if(ans>=mod)ans-=mod;
    return ans;
}//快速乘 
long long n,ans=1,x=1,y=1,z=1;
int main(){
    n=read();
    for(long long i=1;i<=2*n;i++){
        if(i<=n)y=mul_mod(y,i);
        if(i<=n+1)z=mul_mod(z,i);
        x=mul_mod(x,i);
        /*这里的卡特兰数初始化貌似有点玄学，
        我用三个for循环实现会玄学WA，
        于是参考了第一篇题解的写法*/ 
    }
    y=mul_mod(y,z);
    ans=mul_mod(x,pow_mod(y,mod-2));
    write(ans);
    return 0;
}
//实测吸氧后39ms956kb通过
//求资瓷

```


---

## 作者：神眷之樱花 (赞：5)

### 前言
为什么别的板子题都不是黄题 $(；´д｀)ゞ$

### 推荐练习
[有趣的数列  一道很水的紫题](https://www.luogu.com.cn/problem/P3200)

~~其实我直接把那道题的代码给复制了过来，双倍经验~~


------------
### 解析
我们应该记住卡特兰的前几项。

$1, 1, 2, 5, 14, 42, 132, 429, 1430$

~~方便我们套代码~~ 咳咳，方便我们快速解题！

不懂卡特兰数列的点 [这里](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin)

因为本人不太会用 $Markdown$,所以解析在代码中。
### 运用通项公式快速求
```cpp
//第n项=C(2n,n)/n+1
//利用分解质因数的办法分解分子分母。
//然后有很多种做法，我用的是愚蠢但是好打的
//分子减去分母中相同素数出现的次数
//记得在不要忘记乘法溢出哦
------------
#include<cstdio>
#include<cstring>
#define LL long long
const int mod = 1e9 + 7; 
const int N = 2e6 + 5;
int prime[N],num=0,tot[N];
bool notprime[N];
LL power(int a,int b)//快速幂
{
	LL ans = 1;
	while(b){
		if(b & 1) ans = 1LL*ans * a % mod;
		a = 1LL*a * a % mod;
		b >>= 1;//二进制拆分
	}
	return ans;
}
int times(int n,int t)
{
	int ans = 0;
	while(n){
		ans += n / t;
		n /= t;
	}
	return ans;//计算n！中素数t出现的次数
}
int Times(int n,int t)
{
	int ans = 0;
	while(n){
		if(n % t == 0) ans++,n /= t;
		else break;
	}
	return ans;//计算n中素数t出现的次数
}
void solve(int n,int m)
{
	for(int i=1;i<=num&&prime[i]<=n;i++)
	{
		int x = times(n,prime[i]);
		int y = times(n - m,prime[i]);
		int z = times(m,prime[i]);
		x -= (y + z);
		tot[prime[i]] = x;
 }
}
int main()
{
	int n;
	LL ans = 1;
	memset(notprime,false,sizeof(notprime));
	for(int i=2;i<=N-5;i++)
	{
		if(!notprime[i]) prime[++num] = i;
		for(int j=1;j<=num&&i*prime[j]<=N-5;j++)
		{
			notprime[i * prime[j]] = true;
			if(i % prime[j] == 0) break;
		}
	}
    //欧拉筛O(n)快速求得1e6内的素数
	scanf("%d",&n);
	solve(2 * n, n);
	for(int i=1;i<=num&&prime[i]<=n+1;i++)
	{
		int x=Times(n + 1,prime[i]);
		tot[prime[i]] -= x;
	}
	for(int i=1;i<=num;i++)
	{
		if(tot[prime[i]])
			ans *= (LL) power(prime[i],tot[prime[i]]);
		ans %= mod;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Warriorszx (赞：5)

非常裸的卡特兰数c++版

公式就是$$\frac{C_{2n}^{n}}{n+1}$$

组合数公式$$C_{n}^{m}=\frac{n!}{m!(n-m)!}$$

在除的时候用费马小定理求MOD意义下的逆元

然后再乘起来（注意开longlong）

代码如下


```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
const int MOD=1e9+7;
inline long long Pow(long long a,long long b,long long p)
{
	long long ans=1;
	while(b)
	{
		if(b&1)
		{
			ans=ans*a%p;
		}
		a=a*a%p;
		b>>=1;
	}
	return ans%MOD;
}
inline long long js(long long a)
{
	if(a==1)
	{
		return 1;
	}
	else
	{
		return a*js(a-1)%MOD;
	}
}
inline long long zuhe(long long n,long long m)
{
	long long js1=js(n)%MOD;
	long long js2=Pow(js(m),MOD-2,MOD)%MOD;
	long long js3=Pow(js(n-m),MOD-2,MOD)%MOD;
	return (js1*js2%MOD)*js3%MOD;
}
int main()
{
	long long n;
	cin>>n;
	long long y=Pow(n+1,MOD-2,MOD)%MOD;
	long long x=zuhe(2*n,n)%MOD;
	cout<<(x*y)%MOD;
	return 0;
}
```

---

## 作者：L_life (赞：4)

我们看到样例就可以看出这是一个卡特兰数，毕竟卡特兰数前几项就是：
$1,1,2,5,14,42$ 

自己推一下 $2$ 很好推为 $2$ 就可以更加确认它是卡特兰数了，所以就可以套式子了：

$h(n)=C_{2n}^{n}-C_{2n}^{n-1}$ 

但由于题目给的数据点范围太大了，所以要用到快速幂，并且最后输出时还要用费马小定理中求逆元的方法，否则就容易被卡，所以就使这道板子题由橙变为黄。

代码呈上：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int mod=1e9+7;
long long Pow(long long a,long long b)
{
	long long x=1,y=a;
	while(b)
	{
		if(b&1)x=(x*y%mod)%mod;
		y*=y;y%=mod;
		b>>=1;
	}
	return x;
}
signed main()
{
	int n,m,ans=1,ans2=1;
	cin>>n;
	for(int q=1;q<=n;q++)ans*=q,ans%=mod;
	int p=ans*ans%mod*(n+1)%mod;
	for(int q=1;q<=2*n;q++)
	{
		ans2*=q;
		ans2%=mod;
	}
	ans2=Pow(p,mod-2)*ans2%mod;
	cout<<(ans2+mod)%mod;
	return 0;
}
```


---

## 作者：依依 (赞：3)


卡塔兰数的应用：
（此题的模型）

平面上连接可以形成凸包的2n个点分成2个一组连成n条线段，两两线段之间不相交的情况总数是h[n].


类似的有：（1）在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数

（2）一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？

详见[traa]中的第八类(http://www.cnblogs.com/adelalove/p/8504778.html)

[代码](https://www.cnblogs.com/adelalove/p/9184723.html)

---

## 作者：tytyty (赞：2)

## 题意

一个圆上有 $2n$ 个点，用 $n$ 条线段把这些点连起来（每个点只连一条线段），使所有的线段都不相交，问有多少种连线方案。

## 思路

本题是一道 Catalan 数的模板。

我们知道 Catalan 数的应用有：进出栈序列，括号序列，凸多边形三角划分，$n$ 个节点的二叉搜索树等。

这里将点顺（逆）时针从 $1-2n$ 标号，画图可以发现奇偶性相同的点是不能连线的（因为这样会交叉），所以必须奇数点与偶数点，问题转化为括号序列问题。

Catalan 数通项式：$C_n=\dfrac {C_{2n}^n}{n+1}$。另外此题还要用到逆元和快速幂。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long//记得开long long
using namespace std;
const int p=1000000007;
int n;
ll inv;//逆元
ll power(ll x,ll y)
{
	ll ret=1;
	while(y)
	{
		if(y&1)
			ret=ret*x%p;
		x=x*x%p;
		y>>=1;
	}
	return ret;
}
ll c()
{
	ll fz=1,fm=1;
	for(int i=n+1;i<=2*n;i++)//化简后
	{
		fz=fz*i%p;
	}
	for(int i=1;i<=n;i++)
	{
		fm=fm*i%p;
	}
	fm=power(fm,p-2);//求逆元
	return fz*fm%p;
}
int main()
{
	scanf("%d",&n);
	inv=power(n+1,p-2);
	printf("%d",c()*inv%p);
	return 0;
}

```
#### PS:
[双倍经验](https://www.luogu.com.cn/problem/P1976)

一道神奇的题目：[有趣的序列](https://www.luogu.com.cn/problem/P3200)


---


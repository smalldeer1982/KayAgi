# [ICPC 2022/2023 WF] 斯芬克斯的谜语

## 题目描述

埃及最有名的地标之一是吉萨的狮身人面像，这座雕像描绘了一个人头狮身鹰翼的神兽斯芬克斯的形象。在埃及和希腊神话中，斯芬克斯被认为是守护神。最有名的斯芬克斯大概是守卫雅典城市底比斯的那位。根据神话，当俄狄浦斯试图进城时，斯芬克斯问了他一个谜语：「哪种生物有一种声音，但是早上有四只脚，下午有两只脚，晚上有三只脚？」你可能听说过，俄狄浦斯正确地回答了：「是人——人在婴儿时用双脚双手爬行，成年时用双脚走路，晚年使用拐杖。」

本题中，你遇到了另一个斯芬克斯，他问了你一个有点相反的谜语：「一只格里芬，一只巴西利斯克和一只半人马分别有几条腿？」当意识到这是埃及和希腊神话中的神兽时，你并不清楚他们有多少条腿（除了这个数量应该是个非负整数以外）。斯芬克斯严厉地指示你不要碰任何东西，这样你就没法用手机搜索答案了。

然而，斯芬克斯允许你问她五个问题。在每个问题中，你都可以问斯芬克斯一些数量的神兽一共有多少条腿。例如，你可以问「三只巴西利斯克和一只格里芬一共有几条腿？」，或者「五只半人马一共有几条腿？」。你觉得看起来太简单了，但是你此时想起斯芬克斯是十分狡猾的生物：斯芬克斯的五个回答中可能有一个是彻头彻尾的假话，并且你不知道是哪一个。

写一个程序和斯芬克斯交流，询问五个问题，并解开这个谜语。

### 交互过程

恰好有五轮提问过程。每轮提问中，你必须首先输出一行用空格隔开的三个整数 $a,b$ 和 $c$（$0\le a,b,c\le 10$），表示你的问题：「$a$ 只格里芬，$b$ 只巴西利斯克和 $c$ 只半人马一共有几条腿？」在问题问完后，标准输入中会出现一行一个整数 $r$（$0\le r\le 10^5$），表示斯芬克斯对你的问题的回答。

> 特别提示：对于每行输出，你必须输出换行（`\n`），并刷新缓冲区。

在五次提问结束后，输出一行三个被空格隔开的非负整数 $\ell_a,\ell_b$ 和 $\ell_c$，表示一只格里芬，一只巴西利克斯和一只半人马分别有多少条腿。

### 样例交互 1

| 标准输入 | 标准输出 |
| :------: | :------: |
|          | `1 1 1`  |
|   `12`   |          |
|          | `1 1 1`  |
|   `13`   |          |
|          | `5 0 1`  |
|   `24`   |          |
|          | `1 0 0`  |
|   `4`    |          |
|          | `1 1 0`  |
|   `8`    |          |
|          | `4 4 4`  |

### 样例交互 2

| 标准输入 |  标准输出   |
| :------: | :---------: |
|          |   `4 4 4`   |
|  `2023`  |             |
|          |   `1 0 0`   |
|   `0`    |             |
|          |   `0 1 0`   |
|   `42`   |             |
|          |   `0 0 1`   |
|  `2024`  |             |
|          |   `0 0 0`   |
|   `0`    |             |
|          | `0 42 2024` |



# 题解

## 作者：Ian_NIE (赞：2)

## 0x00 前言

这是一道简单的交互题。

另外：没有必要和洛谷的帮助中心一样写 ```extern "C"```，直接先输出再输入即可，毕竟原题没有给出固定的交互库。

关于题目已经给出的一个 [Python 代码](https://www.luogu.me/paste/pz5qut5m)是 Special Judge，并不是交互库。

## 0x01 题目大意

现在有三个未知数 $a$，$b$ 和 $c$。现在你可以向评测提问五个式子，形如 $x_1a + x_2b + x_3c$，评测机会告诉你这个式子的结果。但是在五个回复中最多存在一个答案是错的，求 $a$，$b$，$c$。

## 0x02 算法设计（？）

~~准确来说是数学分析。~~

对于这个问题，我们可以先询问评测机 $a$，$b$，$c$。接下来我们需要一个检查这三个是否正确的式子，所以我们想到了 $a + b + c$。但是，我们不能够确定这个“试金石”是否正确，所以我们还需要一块**完全不一样的**：$a + 2b + 3c$。

注意，我们不可以把两块试金石造成 $a + b + c$ 和 $2a + 2b + 2c$ 这样的格式，否则如果这两个都是正确的，我们就无法分辨 $a$，$b$，$c$ 中错误的是哪一个了。所以，我们的“double check”必须和原来的那个不等价但是此时，我们的试金过程也变得复杂。

首先，我们先假设评测机回答的是这样五个式子：

$$
\begin{cases}
a = A\\
b = B\\
c = C\\
a + b + c = D\\
a + 2b + 3c = E
\end{cases}
$$

继续，如果 $A + B + C = D$ 或者 $A + 2B + 3C = E$，那么对应的四个式子一定是对的。因为如果有错的，那么那个错的结果和评测机给出的结果的两个式子全部都是错的，矛盾，所以都是对的。此时显然：

$$
\begin{cases}
a = A\\
b = B\\
c = C
\end{cases}
$$

如果上面的两个全部都是错的，那么证明 $D$ 和 $E$ 全部都是对的，因为如果有一个是错的，那么另一个和 $A$，$B$，$C$ 就都是对的，上面的式子就有一个会成立，矛盾，所以都是对的。现在我们继续检查 $A$，$B$，$C$ 当中谁是错的。

假设 $A$ 是错的，那么 $E - D = B + 2C$，因为剩下的都是对的。反过来，如果这个式子是对的，那么 $A$ 就是错的。和上面证明的逻辑相同，这个式子代表了 $B$，$C$，$D$，$E$ 全部都是对的，所以 $A$ 就是错的（显然 $A$，$B$，$C$ 中必须有一个是错的，所以 $A$ 不可能是对的）。此时：

$$
\begin{cases}
a = D - B - C\\
b = B\\
c = C
\end{cases}
$$

同理可得，当 $E - 2D = -A + C$ 时，$B$ 错，所以：

$$
\begin{cases}
a = A\\
b = D - A - C\\
c = C
\end{cases}
$$

第三种情况读者自证不难。

所以，代码就是 ```if else```，没有难度了吧。

### 0x03 部分代码实现

下面的求答案的过程大家自己写吧，很简单。我就简单说一下输入输出，直接这样写就可以。

~~大家都是第一次做交互题吧，经验大佬请直接跳过。~~

```cpp
/*
a = ans1;
b = ans2;
c = ans3;
a + b + c = ans4;
a + 2b + 3c = ans5;
*/ 
	cout << "1 0 0" << endl, cin >> ans1;
	cout << "0 1 0" << endl, cin >> ans2;
	cout << "0 0 1" << endl, cin >> ans3;
	cout << "1 1 1" << endl, cin >> ans4;
	cout << "1 2 3" << endl, cin >> ans5;
```

### 0x04 [完整代码](https://www.luogu.me/paste/ptxjw9aj)

一个整合没有解释。

### 0x05 后记

本人第一次写交互题。

[AC 记录](https://www.luogu.com.cn/record/218949262)。

---

## 作者：WuMin4 (赞：0)

## [[ICPC 2022/2023 WF] 斯芬克斯的谜语](https://www.luogu.com.cn/problem/P12295)

## 简要题意

交互库有三个非负整数 $x,y,z$，你需要询问 $5$ 次 $a,b,c$，交互库会回答 $ax+by+cz$ 的值，但是可能会有一次的回答是假的，你需要求出 $x,y,z$ 的值。

## 思路

我们可以考虑将询问 $5$ 次中的任意 $3$ 次拿出来组成一个三元方程组，易得共有 $\binom{5}{3}=10$ 种组合方案。对于每种方案可以运用高斯消元求解出方程的结果。

假设交互库的回答没有假回答，那么选择的任意 $3$ 个询问全都是真的的数量即为 $\binom{5}{3}=10$。假设交互库的回答存在假回答，那么询问全是真回答的数量即为 $\binom{5}{3}-\binom{4}{2}=4$。所以对于出现了 $4$ 次或 $10$ 次的方程解即为求出的答案。

但是上述思路正确的前提是真回答组合成的方程组均有唯一解。于是我们需要构造出一组能保证任意组合都有解的询问。这里可以以如下方式构造：

```txt
1 0 0
0 1 0
0 0 1
1 1 1
1 2 3
```

可以发现该询问怎么选都能至少选出一个能直接得出一个未知数的方程，代入消元后便能得到剩下得未知数。易证该询问对于所有真回答组成的方案都是有解的。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace gx{
	int n;
	long double a[115][115],ans[115];
	bool sol(){
		for(int i=1;i<=n;i++) ans[i]=0;
		for(int i=1;i<=n;i++){
			if(a[i][i]==0){
				for(int j=i+1;j<=n;j++)
					if(a[j][i]!=0){
						for(int k=1;k<=n+1;k++)
							swap(a[i][k],a[j][k]);
						break;
					}
			}
			for(int j=i+1;j<=n;j++){
				if(a[j][i]==0) continue;
				long double x=a[i][i]/a[j][i];
				for(int k=i;k<=n+1;k++)
					a[j][k]=a[i][k]-a[j][k]*x;
			}
		}
		for(int i=n;i>=1;i--){
			for(int j=i+1;j<=n;j++)
				a[i][n+1]-=a[i][j]*ans[j];
			if(a[i][i]==0) return 0;
			else ans[i]=a[i][n+1]/a[i][i];
		}
		return 1;
	}
}
bool isz(long double x){
	return abs(x-floor(x))<=1e-8;
}
int a[15][15]={
	{},
	{0,1,2,3},
	{0,1,0,0},
	{0,0,1,0},
	{0,0,0,1},
	{0,1,1,1}
},cnt;
int ans[15][15];
map<pair<int,pair<int,int>>,int>cc;
signed main() {
	for(int i=1;i<=5;i++)
		cout<<a[i][1]<<" "<<a[i][2]<<" "<<a[i][3]<<endl,cin>>a[i][4];
	for(int i=1;i<=5;i++){
		for(int j=i+1;j<=5;j++){
			for(int k=j+1;k<=5;k++){
				gx::a[1][1]=a[i][1],gx::a[1][2]=a[i][2],gx::a[1][3]=a[i][3],gx::a[1][4]=a[i][4];
				gx::a[2][1]=a[j][1],gx::a[2][2]=a[j][2],gx::a[2][3]=a[j][3],gx::a[2][4]=a[j][4];
				gx::a[3][1]=a[k][1],gx::a[3][2]=a[k][2],gx::a[3][3]=a[k][3],gx::a[3][4]=a[k][4];
				gx::n=3;
				if(gx::sol()){
					if(isz(gx::ans[1])&&isz(gx::ans[2])&&isz(gx::ans[3])){
						cnt++;
						ans[cnt][1]=round(gx::ans[1]),ans[cnt][2]=round(gx::ans[2]),ans[cnt][3]=round(gx::ans[3]);
						cc[{ans[cnt][1],{ans[cnt][2],ans[cnt][3]}}]++;
					}
				}
			}
		}
	}
	for(int i=1;i<=cnt;i++){
		if(cc[{ans[i][1],{ans[i][2],ans[i][3]}}]==4||cc[{ans[i][1],{ans[i][2],ans[i][3]}}]==10){
			cout<<ans[i][1]<<" "<<ans[i][2]<<" "<<ans[i][3]<<endl;
			return 0;
		}
	}
	return 0; 
}
```

---

## 作者：Shunpower (赞：0)

简单交互。

-------------

我们有三个未知数，那么按理来说三个本质不同的方程就足够了。然而题目允许我们使用五个方程，但是其中一个是错的。

考虑我们随便钦定一个方程是错的，那么如果我们没有钦定到错误的方程，那么剩下四个方程一定存在解不出来的现象。因为其中三个方程是正确的，我们一定可以用这三个方程生成所有的等量关系，从而得到一个和错误的方程相悖的方程。

所以剩下四个方程能同时满足当且仅当钦定到了错误的方程。此时我们得到的解也就是答案了。

所以我们直接枚举错误的方程，解剩下的四个方程中的三个，然后再看能不能满足第四个方程。

通过构造尽可能简单的方程，可以简单地实现解方程过程。

```cpp
int a,b,c,sum,chk;
int main(){
#ifdef Shun
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cout<<"1 0 0"<<endl;
	cin>>a;
	cout<<"0 1 0"<<endl;
	cin>>b;
	cout<<"0 0 1"<<endl;
	cin>>c;
	cout<<"1 1 1"<<endl;
	cin>>sum;
	cout<<"2 3 4"<<endl;
	cin>>chk;
	if(sum==a+b+c){
		cout<<a<<" "<<b<<" "<<c<<endl;
	}
	else{
		if(a*2+b*3+c*4==chk) cout<<a<<" "<<b<<" "<<c<<endl;
		else{
			if(chk-2*sum==b+2*c){
				cout<<sum-b-c<<" "<<b<<" "<<c<<endl;
			}
			else if(chk-3*sum==-a+c){
				cout<<a<<" "<<sum-a-c<<" "<<c<<endl;
			}
			else{
				cout<<a<<" "<<b<<" "<<sum-a-b<<endl;
			}
		}
	}
	ET;
}
//ALL FOR Zhang Junhao.
```

---


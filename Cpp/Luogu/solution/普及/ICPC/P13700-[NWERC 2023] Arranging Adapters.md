# [NWERC 2023] Arranging Adapters

## 题目描述

你拿出笔记本电脑，准备插电时，发现唯一的插座已经被占用了。你的朋友们嘲笑道：“没有插座给你，我们也不训练了。”他们的笑容很快消失，因为你拿出了一个插线板，把充电器从插座上拔下来，插到了插线板上。现在，你的充电器也有地方插了。

然而，随着可用插孔的增多，你的朋友们突然又拿出了更多需要充电的设备。你意识到这样下去他们是不会训练的，于是决定用一个问题来“套路”他们。

![](https://cdn.luogu.com.cn/upload/image_hosting/jhlld6he.png)

:::align{center}
样例输入 2 的示意图。前六个充电器可以如图所示插入。注意，这并不是唯一的可行方案。然而，可以证明无法同时插入全部七个充电器。
:::

你的插线板有一排 $s$ 个插孔，每个插孔直径为 $3\,\rm{cm}$。你注意到所有充电器的长度都是整数。每个充电器的插头都在两端之一，并且每个充电器只能有两种朝向。充电器之间不能重叠，但可以相互接触，并且只要插头插入插孔，充电器的其余部分可以伸出插线板的末端。具体如图 A.1 所示。

你的朋友们希望借此逃避训练，于是同意编写一个程序来解决这个问题。

## 说明/提示



由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5 7
7 4 4 5 8```

### 输出

```
5```

## 样例 #2

### 输入

```
8 9
7 4 3 6 4 8 5 6```

### 输出

```
6```

# 题解

## 作者：SXY83296647 (赞：0)

## 思路
题目让我们求在一个有 $s$ 个插座的插线板上最多能够插上几个充电器，所以我们可以先把充电器的长度从小到大进行排序，然后再进行计算。

首先题目告诉我们一个插座的长度为 3，然后每个充电器插入插座的方向可以变换，且边缘插着的充电器可以超出插线板的长度范围，于是我们可以先求 $s-2$ 个插座总共可以插入多少个充电器，然后再加上最边缘可以插入无限长度的 2 个充电器。

为了求剩下 $s-2$ 个插座总共可以插入几个充电器，我们可以先将排序好的第 $i$ 个充电器的长度 $a_i \div 3$，求出这个充电器会占用几个完整的插座，记录在 $x$ 中；再将 $a_i \bmod 3$，得到剩下会占用多少长度的插座，记录在 $y$ 中。于是就可以定义一个变量 $sum$ 用来记录总共占用了几个插座，然后比较 $sum$ 和 $s$ 的大小。若 $sum$ 大于 $s$，则输出 $i+1$（即 $i-1+2$）的值；否则最后输出 $n$ 的值。**注意**，要在循环中将记录下来的 $y$ 进行组合（即把取模得到的 1 和 2 组合在一起，可以减少占用空间），然后再删去组合完毕的 $y$，最后将 $sum$ 加上 1。

以下给出代码，详细内容请看注释：
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,s,remain[3]={0};
int main()
{
    ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    cin>>n>>s;
    int a[n+1];
    for (int i=1;i<=n;i++) cin>>a[i];
    if (s==1&&n>=1)
    {
        cout<<1;
        return 0;
    }
    else if (s>=2&&n<=2)
    {
        cout<<n;
        return 0;
    }//特判
    sort(a+1,a+n+1);
    s-=2;//减去最边缘的两个插座
    int sum=0;
    for (int i=1;i<n;i++)
    {
        if (i==n-1)//判断是否循环到了倒数第2个值
        {
            cout<<n;
            return 0;
        }
        int x=a[i]/3,y=a[i]%3;
        remain[y]++;//存储y的值
        if (remain[1]&&remain[2])//组合y的值
        {
            int k=min(remain[1],remain[2]);
            x+=k;//实际上k只等于0或1
            for(int p=1;p<3;p++) remain[p]-=k;
            //相当于 remain[1]-=k,remain[2]-=k;
        }
        if (sum+x+(remain[1]+1)/2+remain[2]>s)//判断占用的总长度是否超过s
        {
            cout<<i+1;
            return 0;
        }
        sum+=x;
    }
}
```
时间复杂度 $O(n)$

---

## 作者：Zayn_Pan (赞：0)

## 题目

戳[这里](https://www.luogu.com.cn/problem/P13700)看题目。

### 翻译和简化题目

有 $n$（$1\le n\le 2\times 10^5$）个充电器，第 $i$ 个充电器的长度为 $w_i$（$3\le w_i\le 10^9$），还有一个插线板上有 $s$（$1\le s\le 10^9$）个插座。每个插座直径 $3$ 厘米。求满足以下要求最多可以在插线板上插多少个充电器：
1. 充电器的插头必须对准某个插座（插头位置与插座位置重合）。
2. 充电器之间不能重叠，但可以互相接触。
3. 充电器可以伸出插线板的两端（只要插头插在插座上即可）。
4. 每个充电器都可以旋转 $180^{\circ}$。

## 思路

考虑贪心。让更长的充电器伸出插线板更优。

发现每个插进插座的充电器与插座的关系只会有三种：刚好全部在插座上、有 $1$ 厘米没有在插座上、有 $2$ 厘米没有在插座上。意识到需要对 $3$ 取模。

画一下图就可以发现判断是否已经插不了充电器的条件就是：
$$\begin{cases}
s\le m_2+\left \lceil \frac{(m_1-m_2)}{2}\right \rceil ,m_2<m_1\\
s\le m_2,m_2\ge m_1
\end{cases}
$$

$m$ 是充电器对 $3$ 取模的结果的数量，$s$ 表示目前还剩的插座数。

所以先从小到大排序。然后遍历前 $n-1$ 个位置（插座总数 $s$ 也相应的减去一），这样有助于操作。先将答案加一，再将 $s$ 减去这个充电器覆盖到的插座数量，然后将它对 $3$ 取模的结果的数量加一。此时如果满足上述条件就直接结束遍历。

最终输出的答案还要加一（因为我们一开始去掉了一个）。

注意要特判 $s=1$ 的情况。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,s,w[200005],m[5];
signed main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++)cin>>w[i];
	sort(w+1,w+n+1);
	if(s==1){
		cout<<1;
		return 0;
	}
	int ans=0;
	s--;
	for(int i=1;i<n;i++){
		ans++;
		s-=w[i]/3;
		m[w[i]%3]++;
		if(m[2]<m[1]){
			if(s<=m[2]+(m[1]-m[2]+1)/2)break;
		}
		else if(s<=m[2])break;
	}
	cout<<ans+1;
	return 0;
} 
```

---


# [IOI 2000] 回文字串

## 题目背景

IOI2000 第一题


## 题目描述

回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。

比如 $\verb!Ab3bd!$ 插入 $2$ 个字符后可以变成回文词 $\verb!dAb3bAd!$ 或 $\verb!Adb3bdA!$，但是插入少于 $2$ 个的字符无法变成回文词。

**注意**：此问题区分大小写。


## 说明/提示

### 数据范围及约定

记字符串长度为 $l$。

对于全部数据，$0<l\le 1000$。

## 样例 #1

### 输入

```
Ab3bd```

### 输出

```
2```

# 题解

## 作者：gyf12138 (赞：307)

###解题思路：该题说是考察如何将一个字符串添加成一个回文串的，不如说是一道求最长公共自序列的变式题，为啥这么说呢？肯定是有原因在里面的

1.    首先，我们要摸清回文串的特性，回文就是正着读反着读一样，一种非常对称不会逼死强迫症的字符串；这就是我们的突破口。。。你难道以为是逼死强迫症么？哈哈，太天真了，突破口其实是因为回文正着读反着读都相同的特性。。。这样我们就可以再建一个字符数组存储倒序的字符串

2.    我们先分析下样例：ab3bd，

它的倒序是:db3ba

这样我们就可以把问题转化成了求最长公共自序列的问题，为啥可以这么转化呢？

它可以这么理解，正序与倒序“公共”的部分就是我们回文的部分，如果把正序与倒序公共的部分减去你就会惊奇的发现剩余的字符就是你所要添加的字符，也就是所求的正解

ad
da把不回文的加起来就是我们梦寐以求的东西：回文串（卧槽？太没追求了）

把ad，da加起来成回文串就是adb3bda，所以这个问题就可以转化成了求最长公共自序列的问题，将字符串的长度减去它本身的“回文的”（最长公共自序列）字符便是正解

3.    找到解题思路后我们就可以开始写了，最长公共自序列问题是个经典的dp问题，

最容易想到的方法就是开个二维数组dp【i】【j】，i，j分别代表两种状态；

那么我们的动态转移方程应该就是if(str1[i] == str2[j])    dp[i][j]=dp[i-1][j-1]+1;

        Else dp[i][j] = max(dp[i-1][j], dp[i][j-1];

依此即可解出最长公共自序列，用字符串长度减去即是正解


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cstdlib>
using namespace std;
int n;
int dp[5001][5001];
char str1[5001],str2[5001];
int main()
{
    //freopen("palindrome.in", "r", stdin);
    //freopen("palindrome.out", "w", stdout);
    scanf("%s", str1+1);
    n = strlen(str1+1);
    for(int i = 1; i <= n; i++)
        str2[i] = str1[n-i+1];                                //做一个逆序的字符串数组 
    for(int i = 1; i<=n; i++)
        for(int j = 1; j <= n; j++)
            if(str1[i] == str2[j])
                dp[i][j] = dp[i-1][j-1] + 1;        //最长公共自序列匹配 
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);        //不匹配的往下匹配状态 
    printf("%d\n", n-dp[n][n]);                        //字符串长度减去匹配出的最长公共自序列的值 
    return 0;                                        //即需要添加的字符数 
}
```
可这并不是最优解法，只是能ac这道题而已
若是将内存限制改为2MB呢？


不过，没关系，正常开一个5001\*5001的数组一定会爆掉的，此时你是不是在思考另一种解决方案来优化一下空间复杂度，如果我可以把它用一维数组代替二维数组中的状态量是不是也可以求出正解

没错。它真的能

求出正解；

如果你仔细研究一下就会发现每次搜索到str1的第i个元素的时候，数组dp【】【】真正使用到的元素仅仅是dp【i】【j】和dp【i-1】【k】（0    <=    k    <=     n(n = strlen(str1)）

即dp【】【】的第一下标从0-->i-2就没有用处了，因此我们可以开辟两个滚动数组来降低空间复杂度

Dp1【】用来记录当前状态，dp2【】用来记录之前的状态也就相当于刚才的dp【i-1】【j】

动态转移方程应该这么表达if(str1[i]    ==        str2[i])    dp1[j]     =    dp2[j-1] +1;

Else    dp1[j]    =    max(dp1[j-1],     dp2[j]);

源代码在此，天下我有：



```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cstdlib>
using namespace std;
int n;
int dp1[5001],dp2[5001];            //此处用两个滚动数组记录，一个记录之前的状态，一个记录此时的状态
char str1[5001],str2[5001];
int main()
{
    //freopen("palindrome.in", "r", stdin);
    //freopen("palindrome.out", "w", stdout);
    scanf("%s", str1+1);
    n = strlen(str1+1);
    for(int i = 1; i <= n; i++)
        str2[i] = str1[n-i+1];                                //做一个逆序的字符串数组 
    for(int i = 1; i<=n; i++)
    {
        for(int j = 1; j <= n; j++)
            if(str1[i] == str2[j])                     
                dp1[j] = dp2[j-1]+1;                //“发现”匹配就记录
            else
                dp1[j] = max(dp1[j-1],dp2[j]);        //不匹配就匹配后面的状态 
        memcpy(dp2, dp1, sizeof(dp1));                //记录之前的状态“滚动”匹配 
    }
    printf("%d\n", n-dp1[n]);            //字符串长度减去匹配出的最长公共自序列的值                          
    return 0;                            //即需要添加的字符数
}

```

---

## 作者：wisdom_grass (赞：131)

我的思路跟楼下dalao的题解不太一样啊......

设字符串为S。

设$f[i][j]$为要把从i到j（包括i和j）的字符串变为回文串的最少插入字符数。

怎么转移？ 有两种可能：

- $S[i] == S[j]$ 说明串的两头相等，不需要多插入什么，只需要$f[i][j] = f[i+1][j-1]$就好了，$i+1$ 到 $j-1$ 一段就是除两头外的最少插入字符数

- $S[i] != s[j]$ 说明串的两头不同，需要多插入1字符以保持串的回文性质，我们这次新插入的字符可能在最右边，也可能在最左边。所以需要$f[i][j] = min(f[i+1][j], f[i][j-1]) + 1$

具体初始化细节请看代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn = 1007;
int f[maxn][maxn];
char s[maxn];
int len; // 字符串长度

void dp() {
	for(int k = 1; k < len; k++) // 枚举头尾间距
		for(int i = 1; i <= len - k; i++) { // 枚举起点
			int j = i + k; // 算出终点
			if(s[i] == s[j]) {
				f[i][j] = f[i + 1][j - 1];
			} else {
				f[i][j] = min(f[i + 1][j], f[i][j - 1]) + 1;
			}
		}
}
int main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	scanf("%s", s + 1); // 输入字符串，第一个字母在s[1]
	len = strlen(s + 1); // 从s[1]开始算字符串的长度
	
    //对于每一个只有一个字符的字符串来说，它必是回文
    for(int i = 1; i <= len; i++) f[i][i] = 0;
	dp();
	
	cout << f[1][len];
	return 0;
}
```

~~**最后，我们可以向同学炫耀**~~

**~~我刷出了一道IOI题！~~**

---

## 作者：AlexanderPitt (赞：25)

先看题意，给定一个字符串，求最少插入几个字符变为回文串（区分大小写）？

样例给出的是Ab3bd，插法有

（1）以A为新字符串中心，变为 **db3b**Ab3bd 需插入4个字符串

（2）以b为字符串中心，变为 **db3**Ab**A**3bd 需插入4个字符串

（3）以3为字符串中心，变为 A**d**b3bd**A** 需插入2个字符串

（4）以第二个b为字符串中心，变为 Ab3**d**bd**3ba** 需插入4个字符串

（5）以d为字符串中心，变为 Ab3bd**b3bA** 需插入4个字符

分析一下，会发现这道题实际求的是最长回文子串（字符串内最长的回文串），最后输出 长度-最长回文子串长度 就可以了

下来就是如何求最长回文子串，回文串的定义是：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。

既然它正着读，反着读都一样，那我就可以从字符串串首和串尾同时搜索相同的字符进行记录，下来找出最长的就可以了。

这样就可以写出这样的伪代码
```cpp
	if(串首==串尾)
	回文串长度+=（1或2）；  //若串首和串尾为同一个，则++ else +=2  比如只有字符A或者aAc时，因为为同一个字符，则+=1；
	else
	{
		???；
	}
```
下来考虑else怎么写，举个例子AAb时候，很显然回文串长度为2，但是该怎么做呢，这就要用到dp的技巧了；

要求AAb中[1][3]的最长回文串，其中[1][2]为最长回文串，加入为bAA则[2][3]为最长回文串。

那么就可以得出,
```cpp
	if(串首！=串尾)
    {
    	那么F[x][y]=max(F[x-1][y]，F[x][y-1]);
        //[X][Y]中最长回文串为[X-1][Y]与[X][Y-1]中的最大值
    }

```
最后再考虑一下边界，当X==Y时，return 1，想一想为什么
，然后你就过了这道~~水题~~

最后附上AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int len1;
int f[1001][1001];
int pipei(int l,int r)
{
    if(f[l][r]!=0)
    return f[l][r];
    if(l==r)
    return f[l][r]=1;
    if(l>r)
    return f[l][r]=0;
    if(a[l]==a[r])
    return f[l][r]=pipei(l+1,r-1)+2;
    else
    return f[l][r]=max(pipei(l+1,r),pipei(l,r-1));
}
int main()
{
    cin>>a;
    len1=a.length();
    cout<<len1-pipei(0,len1-1);

    return 0;
} 
```

---

## 作者：d3ac (赞：23)

设$dp[i][j]$表示$i\to j$成为回文字串的需要添加最少的字串数

+ 枚举区间长度$k$和区间起点$i$，然后可以算出区间的终点$j=i+k-1$

+ 当$s[i]=s[j]$时， $dp[i][j]=dp[i+1][j-1]$
+ 当$s[i]!=s[j]$时，$dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1$

可是太浪费空间了，而且每次转移只会利用到$dp[i+1][j]$和$dp[i][j-1]$

+ 所以就压维，还是枚举区间长度$k$和区间起点$i$
+ 当$s[i]=s[j]$时， $dp[i \ mod \ 2][j]=dp[(i+1) \ mod \ 2][j-1]$
+ 当$s[i]!=s[j]$时，$dp[i \ mod \ 2][j]=min(dp[(i+1) \ mod \ 2][j],dp[i \ mod \ 2][j-1])+1$

```c++
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int f[2][1200];
char s[1200];
int main(){
	scanf("%s",s+1);
	int len=strlen(s+1),now=0;
	for(int i=len-1;i;i--){
		for(int j=i+1;j<=len;j++){
			if(s[i]==s[j]) f[now^1][j]=f[now][j-1];
			else f[now^1][j]=min(f[now][j],f[now^1][j-1])+1;
		}
		now^=1;
	}
	printf("%d\n",f[now][len]);
	return 0;
}

```

---

## 作者：hovny (赞：16)

## [题面](https://www.luogu.org/problemnew/show/P1435)

主要~~大衣~~大意：

给定一个字符串，求**至少**加入多少个字符才能使字符串变成回文字符串

下面就是我一本正经的~~胡说八道~~题解

## 思路：

很显然，这应该是一道典型的**最长公共子序列**的题目

因此，主要思想就是**DP**

方程式也挺好推的

于是我们就来讲一下为什么这题能用**最长公共子序列（LCS）**求解

### 证明：

#### 求的是什么？

想要使这个字符串加入**最少的字符**变成一个回文串，那么肯定就是要是字符串中不能回文的部分回文

说起来比较难理解，比如：`Ab3bd`最少添的字符就是`A`对应的一个`A`，最后`d`对应的一个`d`

我们可以发现，最少要添的字符就是`不能匹配的字符数=原字符串长度len-最长回文串的长度`

这就变成了求最长回文串的题目

#### 怎么求？

又经验的人肯定就会用**最长公共子序列**去解，但是一些人可能要问为什么，那么我们这里就来证明一下

由于回文串是**回文**的（废话)，也就是说，把原来的字符串**反转**一遍，最长回文串的长度还是**不变**的

于是我们就变成了求两串的**公共子序列的长度**——其实思想就是回文串正着和反着的效果是一样的，也就是抓住这个特性，去求**公共系序列的长度**

转移方程（最好自己去推一下）：

```cpp
if(a[i]==b[j])//目标状态是f[len][len]
	f[i][j]=f[i-1][j-1]+1;//表示i，j两位置相等，那么就由i-1，j-1的状态（最优解）+1得到
else
	f[i][j]=max(f[i-1][j],f[i][j-1]);//否则去掉i或j，转移最优解
```

Code：

```cpp
#include<bits/stdc++.h>
#define N 1010
using namespace std;
int len;
char a[N],b[N];
int f[N][N];
int main()
{
    int i,j;
    scanf("%s",a+1);
    len=strlen(a+1);
    for(i=1;i<=len;i++)
        b[i]=a[len-i+1];//反转
    for(i=1;i<=len;i++)
        for(j=1;j<=len;j++)
            if(a[i]==b[j])
                f[i][j]=f[i-1][j-1]+1;
            else
                f[i][j]=max(f[i-1][j],f[i][j-1]);
    printf("%d",len-f[len][len]);//长度减去最长回文串长度
    return 0;
}
```

### 拓展知识：

**最长上升子序列（LIS）**

### 推荐题目（进阶，~~就是比较难的意思~~）：

[【模板】最长公共子序列](https://www.luogu.org/problemnew/show/P1439)

---

## 作者：Parabola (赞：10)

窝写这篇题解是给你们安利一个新科技（雾），主要是因为没有找到LCS的模板题，只能在这发题解

这是学长想出来的w

------------

我们都知道是把这个序列翻转之后求两个序列的LCS是吧...

那么重点肯定在LCS！

先来看看这道题

> 给你两个小写字母串 $s1$ ， $s2$ ，求它们两个的LCS（最长公共子序列）

对于 70%的数据，$|s1| , |s2|<= 2000$

这个数据是傻逼，只要你会LCS的dp

对于 100%的数据，$|s1| <= 3 * 10^6$ ， $|s2| <= 2000$

~~这个数据是傻逼，只要你会序列自动机~~

好吧我们现在都不会那个什么序列自动机，有什么办法做呢

先看回那个70%数据的那个dp...

状态：

$dp[i][j]$代表$s1$的前$i$个字符构成的子串与$s2$前$j$个字符构成的子串的LCS的长度

转移方程：

$dp[i][j]$ $=$ $max(dp[i-1][j] , dp[i][j - 1],dp[i-1][j-1]+[s1[i]==s2[j]])$

窝看你的数组开不下呀！

因为$|s1|$太大了！

要不把LCS的长度扔进去状态，然后把那个占空间的$s1$当成$dp$数组里存的值？

那么我们的状态变成了

$dp[i][j]$ 代表 $s2$前$i$个字符构成的子串与$s1$ 的前$dp[i][j]$个字符构成的子串的LCS长度为$j$

怎么转移呢？

定义$next[i][c]$，代表找的一个最小的$j$，满足$j>i$并且$s1[j] ==c$的$j$

这个能随便算...

然后转移方程成了这样：

$dp[i][j]$ $=$ $min(dp[i+1][j] , next[dp[i+1][j+1]][s2[i+1]])$

时间复杂度$O(min(|s1|,|s2|) ^ 2)$，空间复杂度$O(26 * |s1|+ min(|s1|,|s2|) ^ 2)$

然后你会发现这个方法可以降低很多个$O(N^2)$的关于子序列的$dp$复杂度，只要能快速算$next$数组

---

## 作者：lqx_bnu (赞：6)

### 蒟蒻的第一篇题解…… ###           
~~dalao勿喷……~~        
          

------------

                
我们知道，回文串就是正反读都一样~~（废话）~~       
所以我们来分析一下一个样例：as3da          
对于这一组样例，我们进行如下简（bao）便（li）操作：    
### as3da->as3daad3sa(接上一个反串）  

这个串明显是一个回文串  
为了保证这个串始终是一个回文串，我们删除掉这个串前后两个部分中所有  _同样位置上相同的部分  _  
步骤如下：  
 ## as3da ad3sa ->~~a~~s~~3~~d~~a~~ ~~a~~d~~3~~s~~a~~->sd da# 
 我们不难看出，剩余部分是sd的回文串  
 在原串中，已经存在了串sd，所以我们只需加入ds  
 即ads3sda  
 ~~（其实就是找原串和反串的最长公共子序列）~~  
 上代码：
 ```cpp
//此题dp的关键就是要想到最长公共子序列
#include <cstdio>
#include <iostream>
using namespace std;
int n,ans,f[5001][5001];//f[i][j]为s数组的前i个数与k数组前j个个数所组成的最长子序列 
char s[5001],k[5001];
int main()
{
	scanf("%d\n",&n);
	for(int i=1; i<=n; i++)s[i]=getchar(),k	[n-i+1]=s[i];
	for(int i=1; i<=n; i++)
    {
		for(int j=1; j<=n; j++)
        {
			if(s[i]==k[j])
            {//如果子序列还能继续 
				f[i][j]=f[i-1][j-1]+1;
			}
            else f[i][j]=max(f[i-1][j],f[i][j-1]);
		}
	}
	printf("%d",n-f[n][n]);
	return 0;
}
```

---

## 作者：梅川丘库 (赞：5)

额，看到楼下都是用什么LCS之类的...

于是我打算来一个不一样的

首先我们看到此题，显然会想到区间DP，且此题是属于2D/0D问题

所以空间复杂度为n^2,时间复杂度也与n^2同阶

（空间优化：楼下讲清楚了...）

关于DP方程的定义：

定义f[i][j]为第i个字符到第j个字符这一段子串需要插入字符构成回文串的最小值

-1 如果str[i]与str[j]相同，显然可以知道f[i][j]=f[i+1][j-1];

-2 如果...不同，可以通过判断是把字符添加在左边小点还是右边小点，即f[i][j]=min(f[i+1][j],j[i][j-1])+1;

(讲个笑话：我自己“自作聪明”，先找了数据自己跑，然后贴数据的时候好像不挂文件就复制不完,结果我调了半个多小时.....（无奈）


-因为此题我是在内部OJ上做的，所以空间开的不同，此题直接乱开空间（233）就是了


```cpp
  #include<stdio.h>

#include<algorithm>

using namespace std;

char str[5001];

int f[2][5001];

int main()
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    int n;
    scanf("%d",&n);
    scanf("%s",str+1);
    int now=0;
    for(int i=n-1;i>=1;i--)
    {
        for(int j=i+1;j<=n;j++)
        {
            if(str[i]==str[j])
            {
                f[now^1][j]=f[now][j-1];
            }
            else
            {
                f[now^1][j]=min(f[now][j],f[now^1][j-1])+1;
            } 
        }
        now=now^1;
    }
    printf("%d",f[now][n]);
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

---

## 作者：张佳 (赞：5)

设计状态f[i][j]表示让前i个字符和后j个字符构成回文串，最少要添加几个字符，则初始化

f[i][0]=i

f[0][i]=i

易得转移方程f[i][j]= f[i-1][j-1]  (a[i]==a[n-j+1])

                              min{f[i-1][j],

f[i][j-1])+1

代码如下：



    
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char a[1002];
int f[1002][1002], n;
int min(int x, int y) { return x>y?y:x; }
int main() {
    scanf("%s", a+1);
    n=strlen(a+1);
    for(int i=1; i<=n; i++) {
        f[i][0]=i;
        f[0][i]=i;
    }
    for (int i=1; i<=n; i++)
        for (int j=1; i+j<=n; j++) {
            if (a[i]==a[n-j+1]) 
                f[i][j]=f[i-1][j-1];
            else {
                f[i][j]=min(f[i-1][j], f[i][j-1])+1;
            }
        }
    int ans=100000000;
    for (int i=0; i<=n; i++) {//调试观察用 
        for (int j=0; j<=n; j++)
            cout<<f[i][j]<<" ";
        cout<<endl;
    }
    for (int i=0; i<n; i++) {
        ans=min(min(f[i][n-i], ans), f[i][n-1-i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Jelly_Goat (赞：3)

刚学区间dp，我来写一篇题解  
这个题就是经典的序列（子串）问题的变种。  

-------

### 思路：
我们发现，我们只需要求出**最长回文子序列**来，  
然后**用原字符串长度减去最长回文子序列的长度**即可。  
### 证明：  
对于回文的，已经算在最长回文子序列的长度中，其他的非回文的，就可以填上一个字母。  
于是乎，需要给非回文填上的字母个数即原先的长度减去最长回文子序列的长度。
### 本题关键：求最长回文子序列的长度
定义：`dp[10001][10001]`，二维dp，第一维枚举区间长度，第二维枚举起点。  
预处理：首先本身一个字母是一个回文字符串。即`dp[i][i]=1`。  
然后我们结合代码理解一下~
```cpp
for (int step = 1; step < n; step++)
{
    //区间起点
    for (int i = 1; i + step <= n; i++)
    {
        //区间终点
        int j = i + step;
        //首先可以是子串[i+1->j]的最...长度或者子串[i->j-1]的...长度
        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        //然后如果两个字母是相同的且是区间端点，就还有一个转移方式
        if (str[i] == str[j])
        {//使用子串[i+1->j-1]的...长度和原先的长度进行比较，选择一个更大的
            dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);
        }
    }
}
```
是够经典的...  
于是乎我们就知道最长的...串的长度就是`dp[1][n]`。  
所以最后答案就是`n-dp[1][n]`。  
然后放上我的代码qwq  
### Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>

using namespace std;
const int mod = 1e9 + 7;
char str[10001];
int n;
int dp[10001][10001];

int main()
{
    scanf("%s", str+1);
    n=strlen(str+1);
    for (int i = 1; i <= n; i++)
    {
        dp[i][i] = 1;
    }
    for (int step = 1; step < n; step++)
    {
        for (int i = 1; i + step <= n; i++)
        {
            int j = i + step;
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            if (str[i] == str[j])
            {
                dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);
            }
        }
    }
    printf("%d\n", n-dp[1][n]);
    return 0;
}
```
需要注意的是，我们在循环中直接使用了`str[i]`和`str[j]`，而这两个下标其中`j`可能是n。  
所以需要从`str+1`开始读入。

---

## 作者：shengmingkexue (赞：1)

经典的动态规划。

f[i,j]表示第i-第j个字符所需的最小字符数

初始化：f[i,i]=0

转移方程：f[i,j]=f[i+1,j-1](a[i]=a[j])

               =min(f[i+1，j],f[i,j-1])+1(a[i]<>a[j])

最后结果是f[1,length(a)]


---

## 作者：xukuan (赞：1)

dp之最长公共子序列（一个字符串的正序和倒序）

参考URL：https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/8010952?fr=aladdin


```pascal
uses math;

var
 s:ansistring;
 i,j,n:longint;
 f:array[0..1010,0..1010] of longint;
// f[i,j] 表示正序取i位，倒序取j位的最大值
begin
 readln(s); n:=length(s);
 for i:=1 to n do//正序
  for j:=1 to n do//倒序
   begin
    if s[i]=s[n-j+1] then f[i,j]:=f[i-1,j-1]+1//两个位置相等
                     else f[i,j]:=max(f[i-1,j],f[i,j-1]);//取较大的
   end;
 writeln(n-f[n,n]);//不能形成公共子序列的长度
end.
```

---

## 作者：l1360300734 (赞：0)

因为这是求回文字串，先把给的序列，倒过来存到另一个数组里，就成了求两个数组的最长公共子序列，在用所给的字串减去最长公共子序列的长度就是要添加的长度；

要求最长公共子序列f[i][j]表示第一个串前i位，第二个串前j位的公共子序列长度；

所以，判断一下第i位于第j为是否相等，于是就有了转移方程：

```cpp
if (ch1[i-1]==ch2[j-1])
                f[i][j]=f[i-1][j-1]+1;
            else
                f[i][j]=max(f[i-1][j],f[i][j-1]);
```
献上蒟蒻的代码：

```cpp
#include<cstdio>
#include<cstring> 
#include<iostream>
using namespace std;
char ch1[1001],ch2[1001];
int f[1001][1001];
int main()
{
    int i,j,l;
    scanf("%s",ch1);
    l=strlen(ch1)-1;
    for (i=0;i<=l;i++)//转化
        ch2[i]=ch1[l-i];
    for (i=1;i<=strlen(ch1);i++)//求最长公共子序列
        for (j=1;j<=strlen(ch2);j++)
            if (ch1[i-1]==ch2[j-1])
                f[i][j]=f[i-1][j-1]+1;
            else
                f[i][j]=max(f[i-1][j],f[i][j-1]);
    printf("%d",strlen(ch1)-f[strlen(ch1)][strlen(ch2)]);//算出所需长度
}
```

---

## 作者：封禁用户 (赞：0)

用动态规划即可，相当于求最长公共子序列。。。

可是没有pascal代码怎么办啊！！！本渣为大家献上一个弱弱的代码

```cpp
var
  n,i,j:longint;
  s:ansistring;
  a,b:array[0..5001] of integer;
  f:array[0..5001,0..5001] of longint;
function max(a,b:longint):longint;
begin
  if a<b then exit(b)
  else exit(a);
end;
begin
  readln(s);
  n:=length(s);
  for i:=1 to n do begin
    a[i]:=ord(s[i]);
    b[n-i+1]:=a[i];
  end;
  fillchar(f,sizeof(f),$7f);
  for i:=0 to n do begin
    f[0,i]:=0; f[i,0]:=0;
  end;
  for i:=1 to n do
    for j:=1 to n do begin
      if a[i]=b[j] then f[i,j]:=f[i-1,j-1]+1
      else f[i,j]:=max(f[i-1,j],f[i,j-1]);
    end;
  writeln(n-f[n,n]);
end.
```

---

## 作者：CoolTeam (赞：0)

设原字符串序列为X，逆序列为Y，则最少需要补充的字母数 = len(X) - X和Y的最长公共子序列的长度 。 问题转化为求最长公共子序列长度。

如果X[i]==Y[j],那么F[i][j]=F[i-1][j-1]+1;

否则F[i][j]=max(F[i-1][j] , F[i][j-1] )

答案我 len(X)-F[len][len]

可以用滚动数组优化空间：F[i%2][j]（虽然完全没有必要）。

```cpp
#include<stdio.h>
#include<string.h>
unsigned short f[2][1010];
int main(void)
{
    char A[1010],B[1010]; 
    gets(&A[1]);
    int i,j,len=strlen(&A[1]);
    for(i=1;i<=len;i++) B[len-i+1]=A[i];//逆序列
    for(i=1;i<=len;i++)
        for(j=1;j<=len;j++)
            if(A[i]==B[j]) f[i%2][j]=f[(i-1)%2][j-1]+1;
            else f[i%2][j]= f[(i-1)%2][j]>f[i%2][j-1] ?f[(i-1)%2][j] :f[i%2][j-1];
    printf("%d",len-f[len%2][len]);
    return 0;
}
```

---


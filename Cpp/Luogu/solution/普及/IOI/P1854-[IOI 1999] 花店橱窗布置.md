# [IOI 1999] 花店橱窗布置

## 题目描述

某花店现有 $F$ 束花，每一束花的品种都不一样。至少有同样数量的花瓶，被按顺序摆成一行。花瓶的位置是固定从左到右按 $1\sim V$ 顺序编号，$V$ 是花瓶的数目。

花束可以移动，并且每束花用 $1\sim F$ 的整数标识。所有花束在放入花瓶时必须保持其标识数的顺序。例如，假设杜鹃花的标识数为 $1$，秋海棠的标识数为 $2$，康乃馨的标识数为 $3$，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。每个花瓶只能放一束花。

每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数 $a_{i,j}$）来表示，空置花瓶的美学值为 $0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示：

|        | 花瓶 1 | 花瓶 2 | 花瓶 3 | 花瓶 4 | 花瓶 5 |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 杜鹃花 | $7$    | $23$   | $-5$   | $-24$  | $16$   |
| 秋海棠 | $5$    | $21$   | $-4$   | $10$   | $23$   |
| 康乃馨 | $-21$  | $5$    | $-4$   | $-20$  | $20$   |

根据表格，杜鹃花放在花瓶 $2$ 中，会显得非常好看，但若放在花瓶 $4$ 中，则显得很难看。

为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值。**每个花束都必须被放入花瓶。** 如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。

## 说明/提示

- 花束的标识数顺序必须严格保持  

对于 $100\%$ 的数据，$1\le F\le V\le 100$。

感谢 @罗恺 提供 SPJ

## 样例 #1

### 输入

```
3 5
7 23 -5 -24 16
5 21 -4 10 23
-21 5 -4 -20 20
```

### 输出

```
53
2 4 5
```

# 题解

## 作者：Godのfather (赞：88)

# 不一样的动态规划

update on 2025.6.18

更新了文章结构/排版，优化了代码实现。

---

我看了很多篇题解，发现大佬们都是以枚举第i束花放在哪个花瓶来进行动态规划的，事实上如果从另一个方向定义状态，则会简单很多。

题意就不多说了，进入正题：

## 状态定义

动态规划最重要的一步如何定义良好的状态。首先，对于本题，会有两种直观的状态定义方式：

1. $f(i, j)$ 表示第 $i$ 束花放在第 $j$ 个花瓶的最大美学值。
2. $f(i, j)$ 表示第 $i$ 束花放不放在第 $j$ 个花瓶的最大美学值（从放和不放两种状态中取一个最大的）。

看上去两种定义方法似乎区别不大。

如果你觉得 **方案二** 更简单，那么恭喜你，你的直觉是对的。无论是代码实现，抑或是时间复杂度（在不对转移方程进行优化的情况下），2 都是要优于 1 的。

如果你觉得 **方案一** 更简单，那么可以详细阅读方案一的部份，了解一点状态转移方程的优化技巧（方案一可能略显复杂，但请不要害怕，这种优化技巧在之后的很多题目中都会用到）。

## 方案一

我们按照 1 的方式定义状态，思考如何求出状态转移方程。

思考如何令 $f(i, j)$ 从 $f(i - 1, \cdots)$ 转移过来。

我们发现，光有 $i$ 和 $j$ 是不够的，因为我们无法确定第 $i-1$ 束花放在了哪个花瓶，也就找不到转移前的状态。

因此，我们还需要枚举一个 $k$，表示第 $i - 1$ 束花放在了第 $k$ 个花瓶，然后从中找到一个最大的 $f(i - 1, k)$ 进行转移。于是可以推出状态转移方程：

$$
f(i, j) = \max\limits_{i-1\le k\le j - 1}\{ f(i - 1, k) \} + a_{i, j}
$$

*为什么 $k$ 的范围是 $[i-1, j-1]$？（留给读者自行思考）*

此时，我们枚举了 3 个变量 $i, j, k$，因此复杂度是 $O(FV^2)$。

其实这个状态转移方程还可以继续优化。我们仔细观察该转移方程，不难发现其相当于是在区间 $k\in[i-1, j-1]$ 中找了一个最大的 $f(i-1, k)$。

因此，我们可以考虑进行 **前缀和** （前缀最大值）优化，将这个最大的 $f(i - 1, k)$ 通过一个前缀最大值数组 $g(i - 1, j)$ 存起来。

即，$g(i - 1, j)$ 表示 $k\in[0, j]$ 中最大的 $f(i - 1, k)$ 的值。可以得到 $g(i, j)$ 的状态转移方程：

$$
g(i, j) = \max\{g(i, j - 1), f(i, j)\}
$$

由于 $f$ 的转移方程中，$k$ 的下界为 $i-1$，为了防止 $g$ 从非法的状态转移，我们还需要将非法的 $f$ 状态设置为负无穷，这样就能够保证 $g$ 不会从非法的 $k$ 值转移过来了。整体的状态转移方程如下：

$$
\begin{cases}
f(i, j) = g(i - 1, j - 1) + a_{i, j} \\
g(i, j) = \max\{g(i, j - 1), f(i, j)\}
\end{cases}
$$

复杂度是 $O(FV)$。

## 方案二

从方案二状态的定义，我们可以很轻松地列出两种条件下的前置状态：

假设当前要计算 $f(i, j)$，考虑其前置状态

1. **第 $i$ 束花放在第 $j$ 个花瓶，则前 $i-1$ 束花可放在前 $j-1$ 个花瓶**：
    $f(i - 1, j - 1) + a_{i,j}\to f(i, j)$
1. **第 $i$ 束花不放在第 $j$ 个花瓶，则前 $i-1$ 束花可放在前 $j$ 个花瓶**：
    $f(i - 1, j) \to f(i, j)$

因此，容易列出转移方程：

$$
f(i, j) = \max\{f(i-1, j-1) + a_{i,j}, f(i-1,j)\}
$$

复杂度为 $O(FV)$

此时还有一个问题，因为该状态的定义没有强制要求第 $i$ 束花一定会放在某个花瓶中（不同于方案一），会不会导致第 $i$ 束花没有放在任何一个花瓶中，违反了题目条件？

答案是不会，原因留给读者自行思考。(tips: 可以考虑状态的边界条件)

下面呈上方案二的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn = 1005, INF = 1e9 + 7;
int f[maxn][maxn], a[maxn][maxn], n, m;
pair<int, int> from[maxn][maxn];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            cin >> a[i][j];

    for(int i = 0; i <= n; i ++)
        for(int j = 0; j <= m; j ++)
            f[i][j] = -INF;

    for(int i = 0; i <= m; i ++)
        f[0][i] = 0;

    for(int i = 1; i <= n; i ++) {
        for(int j = i; j <= m; j ++) {
            int s1 = f[i - 1][j - 1] + a[i][j], s2 = f[i][j - 1];
            if(s1 >= s2) {
                f[i][j] = s1;
                from[i][j] = {i - 1, j - 1};
            } else {
                f[i][j] = s2;
                from[i][j] = {i, j - 1};
            }
        }
    }
    
    cout << f[n][m] << '\n';
    vector<int> path(n + 1);
    for(int i = n, j = m; i > 0;) {
        int pre_i = from[i][j].first, pre_j = from[i][j].second;
        if(pre_i == i - 1) path[i] = j;
        i = pre_i, j = pre_j;
    }
    for(int i = 1; i <= n; i ++)
        cout << path[i] << " \n"[i == n];
    return 0;
}
```

---

## 作者：jackyzhu (赞：49)

最简单题解：此题与2066机器分配一模一样!

如果不过关，那就稍微详细点：

dp[i][j]表示前i个花盆放j棵花的最大观赏度，则有：

dp[i][j]=max(dp[i][j],dp[j+k-1][j-1]+a[j][j+k])（0<=k<=i-j,即对第j棵花的位置在[j,i]闭区间之间遍历）

由于观赏度可能为负值，所以需要初始化：

dp[i][j]=-1\*0x3f3f3f3f;（可以进行加减运算的负无穷大）


另外题目明明说：如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。

其实不然，第7个测试点（虽然看不到数据），有点小问题，我调整了一下递归输出函数print的输出顺序后，才通过。

没通过第七个测试点的print为：


```cpp
for(int k=i-j;k>=0;k--)
        if(dp[i][j]==dp[j+k-1][j-1]+a[j][j+k])
        {
            print(j+k-1,j-1);
            printf("%d ",j+k);
            break;
        }
```
ac代码里的print：

```cpp
for(int k=0;k<=i-j;k++)
        if(dp[i][j]==dp[j+k-1][j-1]+a[j][j+k])
        {
            print(j+k-1,j-1);
            printf("%d ",j+k);
            break;
        }
```
自己认定了此题跟2066一模一样，所以就非得用2066的方法过，我就是那么执着！

AC代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
int f,v;
int a[101][101];
int dp[101][101];
void print(int i, int j)
{
    if(j==0)
        return;
    for(int k=0;k<=i-j;k++)
        if(dp[i][j]==dp[j+k-1][j-1]+a[j][j+k])
        {
            print(j+k-1,j-1);
            printf("%d ",j+k);
            break;
        }
}
int main()
{
    scanf("%d%d",&f,&v);
    for(int i=1;i<=f;i++)
    {
        for(int j=1;j<=v;j++)
            scanf("%d",&a[i][j]);
    }
    for(int i=1;i<=f;i++)
        dp[i][i]=dp[i-1][i-1]+a[i][i];
    for(int i=1;i<=v;i++)
        for(int j=1;j<=f;j++)
        {
            dp[i][j]=-1*0x3f3f3f3f;
            for(int k=0;k<=i-j;k++)
                dp[i][j]=max(dp[i][j],dp[j+k-1][j-1]+a[j][j+k]);
        }
    printf("%d\n",dp[v][f]);
    print(v,f);
}
```

---

## 作者：asuldb (赞：30)

```cpp
//楼下全是dp，那么来个最长路做法 
//可以将这个看成一个以花为横，瓶为纵的表格从下向上找一条路径，上一排的位置必须小于下一排
//那么我们就可以连边去跑最长路了
//同时我们注意到需要记录路径
//那么这里就选dij好了（因为其他的不会记路径啊） 
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#pragma GCC optimize(3)
#define re register
#define maxn 10001
#define maxw 800000
#define inf -99999999
using namespace std;
struct node
{
	int v,w,nxt;
}e[maxw];
int f,v,ans,num=1,end;
int head[maxn],d[maxn],r[maxn];
int a[101][101];
typedef pair<int,int> pii;
priority_queue<pii,vector<pii>,less<pii> > q;
inline int read()
{
    char c=getchar();
    int x=0;
    int r=1;
    while(c<'0'||c>'9') 
    {
    	if(c=='-') r=-1;
    	c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+c-48;
        c=getchar();
    }
    return r*x;
}
inline void add_edge(int x,int y,int z)
{
	e[num].v=y;
	e[num].w=z;
	e[num].nxt=head[x];
	head[x]=num++;
}
inline void dijkstra(int s)
{
	for(re int i=1;i<=f*v;i++)
	  d[i]=inf;
	d[s]=0;
	q.push(make_pair(d[s],s));
	while(q.size())
	{
		pii mid=q.top();
		q.pop();
		int k=mid.second;
		for(re int i=head[k];i;i=e[i].nxt)
		if(d[e[i].v]<d[k]+e[i].w)
		{
			d[e[i].v]=d[k]+e[i].w;
			q.push(make_pair(d[e[i].v],e[i].v));//很常规的松弛操作 
			r[e[i].v]=k;//存一下前驱结点，用来找路径 
		}
	}
}
void dfs(int i)
{
	if(i!=0) dfs(r[i]);
	if(i!=0) cout<<i%v<<" ";//dfs找出路径，再将点还原成二维 
}
int main()
{
	f=read();
	v=read();
	for(re int i=1;i<=f;i++)
	for(re int j=1;j<=v;j++)
	a[i][j]=read();
	for(re int i=1;i<=v;i++)
	  add_edge(0,i,a[1][i]);//我们把0作为起点，把第一列的所有点与0相连 
	for(re int i=2;i<=f;i++)
	for(re int k=1;k<=v;k++)
	for(re int j=k+1;j<=v;j++)
	  add_edge((i-2)*v+k,(i-1)*v+j,a[i][j]);//把点的坐标压成一维 
	  //连边，需要注意的是上一行点的横坐标要小于下一行的 
	dijkstra(0);
	ans=inf;
	for(re int i=1;i<=v;i++)
    if(ans<d[(f-1)*v+i])//从最后一行找最长路 
    {
    	ans=d[(f-1)*v+i];
    	end=(f-1)*v+i;
    }
	cout<<ans<<endl;
	dfs(r[end]);
	end%=v;
	if(end==0) end=v;
	cout<<end<<endl;
	return 0;
}
```

---

## 作者：Seauy (赞：25)

反了所有题解发现写纯的记忆化搜索的题解并不多（好像只有一个），然而并没有在计算的时候就记录好路径，可以认为是DP的递归版实现然后递归找出路径。

那我就来一发记忆化搜索的做法吧。

------------

# 让我们从垃圾桶中捡出10分的爆搜

先展示一下十分~~战斗名族~~的程序：

```cpp
void DFS(int depth,int Last,int sum)//现在要插第几种花，上一种花插入了第几个花瓶，现在的美学值总和
{
	if(depth>F) {ans=max(ans,sum);return;}
	for(int i=Last+1;i<=V-F+depth;i++)
		DFS(depth+1,i,sum+A[depth][i]);
}
```

然后就不会了

~~代码重构~~

停下！还记得记忆化搜索吗？！不要抛弃它呀！

将源程序改成 int 返回值，加一个记忆化数组就能解决的事，对暴力要不抛弃不放弃啊！（代码就不展示了前面的题解里有）

问题来了，知道了最大美学值，怎么知道如何选花瓶的？

~~代码重构~~

我告诉你，就算不改成返回值函数，照样能记忆化。

# 其实记忆化就是大剪枝

把当前算好的答案记录下来，下次就不用算了，这是记忆化的具体实现。

最理想的情况就是返回值，直接返回算好的值就行了。

次理想的情况，就是不返回值，记录算到现在的最优解，如果现在的结果没有历史结果好，就剪枝掉。

当现在已经放了 i 种花并且上一种放在了 j 花瓶内，接下来的选择是不会对截止到现在的答案有影响的，所以如果现在这个状态有历史最优解，那么现在比历史的解更差，肯定是不优的。

所以开记忆化数组

```cpp
int mem[Size+5][Size+5];
```

剪枝+记录
```cpp
if(sum<=mem[depth][_f[depth-1]]) return;
mem[depth][_f[depth-1]]=sum;
```

枚举最好直接在for里写数组
```cpp
for(_f[depth]=_f[depth-1]+1;_f[depth]<=V-F+depth;_f[depth]++)
	DFS(depth+1,sum+A[depth][_f[depth]]);
```

记录答案时方便拷贝
```cpp
if(depth>F)
{
	if(sum>ans)
	{
		ans=sum;
		for(int i=1;i<=F;i++) Choice[i]=_f[i];
	}	
	return;
}
```
当然要赋初值
```cpp
for(int i=0;i<=F+1;i++)
	for(int j=0;j<=V+1;j++)
		mem[i][j]=INT_MIN;
```
最后上总代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int Size=100;

int F,V,ans=INT_MIN;
int A[Size+5][Size+5];
int mem[Size+5][Size+5];
int _f[Size+5],Choice[Size+5];

void DFS(int depth,int sum)//现在要插第几种花，上一种花插入了第几个花瓶，现在的美学值总和
{
	if(sum<=mem[depth][_f[depth-1]]) return;
	mem[depth][_f[depth-1]]=sum;
	if(depth>F)
	{
		if(sum>ans)
		{
			ans=sum;
			for(int i=1;i<=F;i++) Choice[i]=_f[i];
		}	
		return;
	}
	for(_f[depth]=_f[depth-1]+1;_f[depth]<=V-F+depth;_f[depth]++)
		DFS(depth+1,sum+A[depth][_f[depth]]);
}

int main()
{
	scanf("%d %d",&F,&V);
	for(int i=1;i<=F;i++)
		for(int j=1;j<=V;j++)
			scanf("%d",&A[i][j]);
	for(int i=0;i<=F+1;i++)
		for(int j=0;j<=V+1;j++)
			mem[i][j]=INT_MIN;
	DFS(1,0);
	printf("%d\n",ans);
	for(int i=1;i<=F;i++) printf("%d ",Choice[i]);
	return 0;
}
```
~~于是你完美地 AK 了 IOI~~

---

## 作者：Drinkkk (赞：22)

【标签】

DP$50$题，详见https://www.luogu.org/blog/cccx2016/dp50-ti-ti-hao。

【题目描述】

某花店现有$F$束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按$1$到$V$顺序编号，$V$是花瓶的数目。花束可以移动，并且每束花用$1$到$F$的整数标识。如果$I<J$，则花束$I$必须放在花束$J$左边的花瓶中。例如，假设杜鹃花的标识数为$1$，秋海棠的标识数为$2$，康乃馨的标识数为$3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。

每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为$0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示：

> |花名/花瓶编号|花瓶1|花瓶2|花瓶3|花瓶4|花瓶5|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|杜鹃花|7|23|-5|-24|16|
|秋海棠|5|21|-4|10|23|
|康乃馨|-21|5|-4|-20|20|

根据表格，我们可以发现：杜鹃花放在花瓶$2$中，会显得非常好看，但若放在花瓶$4$中，则显得很难看。

为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。

【输入输出格式】

- 输入格式
输入文件的第一行是两个整数$F$和$V$，分别为花束数和花瓶数（$1 \leq F≤100,F \leq V \leq 100$）。接下来是矩阵$A_{i,j}$,它有$I$行，每行$J$个整数，$A_{i,j}$表示花束$I$摆放在花瓶$J$中的美学值。

- 输出格式
输出文件的第一行是一个整数，为最大的美学值；接下来有F行，每行两个数，为那束花放入那个花瓶的编号。

【输入输出样例】
- 输入样例
```
3 5
7 23 -5 -24 16
5 21 -4 10 23
-21 5 -4 -20 20
```
- 输出样例
```
53
2 4 5
```

$10$分思路：

我们考虑进行深度优先搜索（DFS），对每一束花的位置进行枚举。在更新最优解的过程中更新摆放方案。但是这样很显然会超时。

$100$分思路：

我们考虑动态规划（即DP）。一开始我很天真的想，我们可不可以用$f[i][j]$来表示前$i$个花瓶中插$j$朵花的最优解（即$C_j^i$的最优解）。然后用一个二重循环来枚举$i$和$j$。然后发现$f[i][]$可以从$f[i-1][]$中转移过来。其实还有另一种方法来表示我们的$f$数组。我们考虑用$f[i][j]$来表示第$i$束花插在第$j$个花瓶里时的最优解（即最大的美学值）。那么动态转移方程就是$f[i][j]=max(f[i-1][i-1],f[i-1][i]......f[i-1][j-1])+a[i][j]$。那么答案就在$f[n][n]$和$f[n][m]$之间，因为第$n$束花在最靠前的情况下只能够放在第$n$个花瓶里。一定要注意这点，不然会WA哦。

感谢@creed_ 的帮助！

$10$分代码：
```cpp
#include <cstdio>
int n=0,m=0;
int sc[101][101];
int ans[101],a[101];
int da=0;
int max(int x,int y)
{
	return x>y?x:y;
}
void dfs(int x,int su)
{
	if(x==n+1)
	{
		if(su>da)
		{
			da=su;
			for(int i=1;i<=n;i++)
			{
				ans[i]=a[i];
			}
		}
		return ;
	}
	for(int i=a[x-1]+1;i<=m;i++)
	{
		a[x]=i;
		dfs(x+1,su+sc[x][i]);
		a[x]=0;
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&sc[i][j]);
		}
	}
	dfs(1,0);
	printf("%d\n",da);
	for(int i=1;i<=n;i++)
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```
$100$分（满分）代码$1$：

```
#include <cstdio>
int f[101][101],a[101][101];
int inf=999999999;
int min(int x,int y)
{
    return x<y?x:y; 
}
int max(int x,int y)
{
    return x>y?x:y;
}
void print(int x,int y)
{
    if(x>0)
    {
        int n=x;
        while(f[n][x]!=y)
        {
            n++;
        }
        print(x-1,y-a[x][n]);
        printf("%d ",n);
    }
}
int main()
{
    int n=0,m=0;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&a[i][j]);
            f[j][i]=-inf;
        }
    }
    for(int i=1;i<=m;i++)
    {
        f[0][i]=-inf;
    }
    f[0][0]=0;
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=min(n,i);j++)
        {
            f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[j][i]);
        }
    }
    printf("%d\n",f[m][n]);
    print(n,f[m][n]);
    return 0;
}
```

$100$分代码$2$：
```
#include <cstdio>
int f[101][101],a[101][101];
int max(int x,int y)
{
	return x>y?x:y;
}
void print(int x,int y)
{
	if(x>0)
	{
		int n=x;
		while(f[x][n]!=y)
		{
			n++;
		}
		print(x-1,y-a[x][n]);
		printf("%d ",n);
	}
}
int main()
{
	int n=0,m=0;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			f[i][j]=-2147483647;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=m;j++)
		{
			for(int k=i-1;k<=j-1;k++)
			{
				f[i][j]=max(f[i][j],f[i-1][k]+a[i][j]);
			}
		}
	}
	int ans=0;
	for(int i=n;i<=m;i++)
	{
		ans=max(ans,f[n][i]);
	}
	printf("%d\n",ans);
	print(n,ans);
	return 0;
}
```

---

## 作者：烈酒诱鹿 (赞：16)

这一篇题蒟蒻硬着头皮想出了一种O(n2)的算法。

题目中有暗示:

**为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值**

换句话说,dp时无需考虑后效性，因为我们当前放了i束花，下一束就只能放第i+1束花了，第i个位置的最优解只有可能从第i-1个位置转移过来。

所以dp的思路就是：
对于到第i个花瓶为止，一共插了j朵花的状态，只可能从i-1，j-1的状态（当前位置要插）和i-1,j的状态（当前位置不插）的状态转移过来。

贴一波丑陋的代码

```cpp
#include"cstdio"
#include"cstring"
#include"algorithm" 
using namespace std;
int n,m,k,l,r;
int dp[110][110],showti[110][110];
void print(int x,int y)
{
	if(!x||!y)
	return;
	if(x==1&&y==1)//考虑到第一位可能不取的情况，特判一下
	{
		printf("1 ");
		return ;
	}
	if(dp[x-1][y-1]+showti[y][x]==dp[x][y])//这一位放了 
	{
		print(x-1,y-1),printf("%d ",x);
		return ;
	}
	if(dp[x-1][y]==dp[x][y])//这一位没放 
	print(x-1,y);
}
int main()
{
	scanf("%d%d",&n,&m);
	memset(dp,-0x3f,sizeof(dp));//考虑到美观度可能会小于0，必须预处理为极小值 
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	scanf("%d",&showti[i][j]);
    for(int i=1;i<=m;++i)
    dp[i][1]=showti[1][i],dp[i][0]=0;//预处理，后面 
	for(int i=2;i<=m;++i)//第i个花瓶
	for(int j=1;j<=n;++j)//j朵花
	dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+showti[j][i]);//每一位的状态只可能从前一个花盆装和前一个花盆不装转移过来 
	printf("%d\n",dp[m][n]);
	print(m,n);//递归输出，比较方便 
	return 0;
}
```

---

## 作者：CR2016_2 (赞：11)

这个题目采用二维的动态规划，在下的想法是dp[i][j]是当第i束花摆在第j个花瓶里此时求和的最大值，

状态转移方程: dp[i][j]=max(dp[i-1][1],dp[i-1][2], ........ ,dp[i-1][j-1])+a[i][j];

代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<iostream>
#define max(a,b) a>b?a:b
#define debug(x) cout<<#x<<x<<endl;
#define debug1d(a,n)for(int i=1;i<=n;i++)cout<<"a["<<i<<"]="<<a[i]<<endl;
using namespace std;
int f,v,a[105][105],dp[105][105],pre[105][105],pos[105],maxx;
//a：第i朵花放在第j个花瓶的价值
//pre：dp[i][j]时，它的上一朵花的位置
//pos：最大值时，选取的花 
void input()//输入 
{
    scanf("%d%d",&f,&v);
    int i,j;
    for(i=1;i<=f;i++)
     for(j=1;j<=v;j++)scanf("%d",&a[i][j]);
}

int main()
{
    int i;
    input();
    {
    int i,j,k;
    j=1;
    memset(pre,0,sizeof(pre));
    for(i=1;i<=f;i++)
     for(j=1;j<=v;j++)
      dp[i][j]=-32767;
    for(i=1;i<=f;i++)dp[0][i]=0;
    //数据的初始化 
      
      
    //核心代码 
    for(i=1;i<=f;i++)
     for(j=i;j<=v;j++)
      {
           for(k=i-1;k<j;k++)
           if(dp[i][j]<dp[i-1][k]+a[i][j])
            {
                dp[i][j]=dp[i-1][k]+a[i][j];
                pre[i][j]=k;
            }
          
      }
    //核心代码完 
}
    
    
    maxx=-32767;
    for(i=1;i<=v;i++)
    {
        if(dp[f][i]>maxx){
            pos[f]=i;
            maxx=dp[f][i];
        }
    }
    //寻找最大值最后一朵花存放位置 
    
    printf("%d ",maxx);printf("\n");
    //每次从当前位置向前寻找上一个花的位置 
    for(i=f;pre[i][pos[i]]!=0;i--)
    {
        pos[i-1]=pre[i][pos[i]];
    }
    for(int i=1;i<=f;i++){
     printf("%d ",pos[i]);
    }
    return 0;
}
```

---

## 作者：Tari (赞：11)

## 压成一维的DP了解一下。。。
### ~~（我好像没翻到一维的QWQ可能是我瞎，于是花了两天调一维QWQ求过哇）~~

#### 显然我们有二维的dp：f[i][j]代表第i盆花放到第j个位置
```cpp
for(R i=1;i<=n;i++) 
    for(R j=V-(n-i);j>=i;j--) 
        for(R k=j-1;k>=i-1;k--) 
            if(f[i][j]<f[i-1][k]+w[i][j])
                ans[i][j]=k,f[i][j]=f[i-1][k]+w[i][j];
```
由于只访问上一个状态，我们可以理所应当的把它压掉

### 注意，需要倒序循环（好吧我的二维的也是倒序的QWQ）

```cpp
for(R i=1;i<=n;i++) for(R j=V-(n-i);j>=i;j--) {
     	f[j]=0xcfcfcfcf;
		for(R k=j-1;k>=i-1;k--) if(f[j]<f[k]+w[i][j]) ans[i][j]=k,f[j]=f[k]+w[i][j];
}
```

AC代码

二维的：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define R register int
using namespace std;
int n,V,pos=109;
int w[110][110],f[110][110],ans[110][110];

inline void print(int i,int j) {
    if(!i) return ;
    print(i-1,ans[i][j]);
    printf("%d ",j);
}

signed main() {
//freopen("testdata.in","r",stdin);
    memset(f,0xcf,sizeof(f));
    scanf("%d%d",&n,&V);f[n][109]=0xcfcfcfcf;
    for(R i=1;i<=n;i++) for(R j=1;j<=V;j++) scanf("%d",&w[i][j]); 
    for(R i=0;i<=V;i++) f[0][i]=0;
    for(R i=1;i<=n;i++) for(R j=V-(n-i);j>=i;j--) 
        for(R k=j-1;k>=i-1;k--) if(f[i][j]<f[i-1][k]+w[i][j]) ans[i][j]=k,f[i][j]=f[i-1][k]+w[i][j];//,cout<<i<<" "<<j<<" "<<k<<" "<<f[1][1]<<endl;
    for(R i=V;i>=n;i--) if(f[n][i]>f[n][pos]) pos=i;
    printf("%d\n",f[n][pos]),print(n,pos);
}
```

一维的：
### ~~（其实一维的有点像01背包对吧QWQ）~~

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define R register int
using namespace std;
int n,V,pos=109;
int w[110][110],f[110],ans[110][110];

inline void print(int i,int j) {
    if(!i) return ;
    print(i-1,ans[i][j]);
    printf("%d ",j);
}

signed main() {
	//freopen("testdata.in","r",stdin);
    //memset(f,0xcf,sizeof(f));
    scanf("%d%d",&n,&V);f[109]=0xcfcfcfcf;
    for(R i=1;i<=n;i++) for(R j=1;j<=V;j++) scanf("%d",&w[i][j]); 
    //for(R i=0;i<=V;i++) f[0][i]=0;
    for(R i=1;i<=n;i++) for(R j=V-(n-i);j>=i;j--) {
     	f[j]=0xcfcfcfcf;
		for(R k=j-1;k>=i-1;k--) if(f[j]<f[k]+w[i][j]) ans[i][j]=k,f[j]=f[k]+w[i][j];//,cout<<i<<" "<<j<<" "<<k<<" "<<f[1][1]<<endl;	
	}
    for(R i=V;i>=n;i--) if(f[i]>f[pos]) pos=i;
    printf("%d\n",f[pos]),print(n,pos);
}
```



---

## 作者：chenlingxi (赞：8)

# 写在前面的一些背景
@DPair:我看这题能网络流

@chenlingxi：~~显然~~貌似费用流

@DPair：好的我学一下

@chenlingxi：好的我来做

------------
## 好的我真就来做了

上一次貌似~~一眼看出来~~写了个dp

~~尽管那会我在学习网络流~~


------------

# 开始正经讲题

### 费用流的一些套路

费用流的求解基本靠流量来限定取那些值

一般为一个固定值，比如这里的n，P1004里的n+n-1

~~做了P2045后得出的结论~~

至于答案为最大/最小费用


------------

因为这里有n朵花，然后每朵花都需要放进花瓶，且第i行的花一定在第i+1行的花的左上方（显然）

然后~~绞尽脑汁~~自然而然的想到可以用一条流穿过这些花所在的花瓶

得出结论：将流量设为1，然后跑MCMF

不会MCMF的见[【模板】最小费用最大流 ](https://www.luogu.org/problem/P3381)

由于这里求的是最大值，那么最小费用->最大费用

又一个套路：将边权取相反数，答案也取相反数，就变成最大费用了。

建模就很简单了

1.设一个超级源，拆了设为s，s2，连一条流量为1，费用为0的边。

（没拆点导致没法限流为1，这里锅了半小时qwq）

2.每个花瓶同样拆成两个点，流量为1，费用为-Aij（见题面）

3.s2向第一行每个花瓶的入点连一条流量为1，费用为0的边。

4.对于花瓶(i，j)（第i行第j个），对$\forall$k$\in$[j+1,m],将(i,j)的出点与(i+1,k)的入点连一条流量为1，费用为0的边

5.第n行的每个花瓶的出点向超级汇t连一条流量为1，费用为0的边。

（t不用拆）

跑完MCMF后，可以得到最大美学值的答案

至于方案，考虑一下如果一个花瓶被选入，那么它入点和出点的连边流量减了1即变成0

那么就枚举每一个点和它所连的边，判断它们之间的关系是不是入点和出点，如果是且边的流量为0，则输出。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge
{
	int to,nxt,flow,cost;
}edge[500005];
int fir[100005],cnt=1;
void add(int u,int v,int w,int c)
{
	edge[++cnt]=(Edge){v,fir[u],w,-c},fir[u]=cnt;
	edge[++cnt]=(Edge){u,fir[v],0,c},fir[v]=cnt;
}
int dis[100005],vis[100005];
int s,t;
int n,m;
bool spfa()
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);
	dis[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=fir[u];i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].cost&&edge[i].flow)
			{
				dis[v]=dis[u]+edge[i].cost;
				if(!vis[v])q.push(v),vis[v]=1;
			}
		}
	} 
	return dis[t]<0x3f3f3f3f;
}
int MC,MF;
int dfs(int u,int flow)
{
	if(u==t)
	{
		MF+=flow;
		vis[u]=1;
		return flow;
	}
	int used=0;
	vis[u]=1;
	for(int i=fir[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if((v==t||!vis[v])&&edge[i].flow&&dis[v]==dis[u]+edge[i].cost)
		{
			int mi=dfs(v,min(flow-used,edge[i].flow));
			if(mi)
			{
				edge[i].flow-=mi;
				edge[i^1].flow+=mi;
				used+=mi;
				MC+=mi*edge[i].cost;
			}
			if(used==flow)return used;
		}
	}
	return used;
}
void MCMF()
{
	while(spfa())
	{
		vis[t]=1;
		while(vis[t])memset(vis,0,sizeof(vis)),dfs(s,1);
	}
}
int main()
{
	s=0,t=50000;
	int s2=50001;
	add(s,s2,1,0);
	scanf("%d%d",&n,&m);
	int sum=n*m;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			int k;
			scanf("%d",&k);
			add((i-1)*m+j,(i-1)*m+j+sum,1,k);
		}
	}
	for(int i=1;i<n;++i)
	{
		for(int j=1;j<m;++j)
		{
			for(int k=j+1;k<=m;++k)
			{
				add((i-1)*m+j+sum,i*m+k,1,0);
			}
		}
	}
	for(int i=1;i<=m;++i)
	{
		add(s2,i,1,0);
		add((n-1)*m+i+sum,t,1,0);
	}
	MCMF();
	printf("%d\n",-MC);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			for(int k=fir[(i-1)*m+j];k;k=edge[k].nxt)
			{
				int v=edge[k].to;
				if(v-((i-1)*m+j)==sum&&edge[k].flow==0)
				{
					printf("%d ",j);
				}
			}
		}
	}
}
```

## 总结

考场上不建议作死

---

## 作者：wentian (赞：7)

-  定义：
dp[f][v]为f朵花插入v个花瓶中的最优解，则有如下很简单的状态转换方程：  
dp[i][j]=max(dp[i-1][l-1]+a[i][l])，   
其中：i<=l<=j，1<=i<=f,i<=j<=v。


- 这里的l定义为：第i朵花插入l号花瓶，则前面i-1朵花插入前面l-1个花瓶中。取l所有可能值得最大值即为最优解。

- 这里需要注意，根据dp结果反推花瓶摆放情况时，dp[i][j]表示i朵花插入j个花瓶中的值，这里j可以向左回推，而且第i朵花一定在第i行查找。如果减少一个花瓶，值不变的话，即：

   while(dp[i][j-1]==dp[i][j])
		 j--;
         
  则j即为第i朵花插入的花瓶的序号。
- 但是i不能向上回推，因为一旦向上回推，表示减少了一朵花，表示的是第i-1朵花的情况。

- 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=0x7fffffff;//最大的正数 
const int MAXN=101;
const int MAXM=201;
int a[MAXN][MAXN],dp[MAXN][MAXN];
int f,v;
//反推路径，逆序查找 
void printPath(int i,int j) {
	if(i==0)
		return;
	//向左查找 
	while(dp[i][j-1]==dp[i][j])
		j--;
	//第i朵花，必须在第i行查找，所以这里不能向上查找。
	 
	//先打印前面 i-1 朵花的摆放情况 
	printPath(i-1,j-1);
	//打印第i朵花的摆放情况 
	cout<<j<<' ';
}
int main(){
	//初始化为足够小的数组 
	memset(dp,0x80,sizeof(dp));
	scanf("%d%d",&f,&v);
	int i,j,l,t;
	for(i=1;i<=f;i++)
		for(j=1;j<=v;j++)
			scanf("%d",&a[i][j]);
	//初始化 
	for(j=0;j<=v;j++)
		dp[0][j]=0;
	//dp，花的数量作为状态 
	for(i=1;i<=f;i++)//i:花的数量 
		for(j=i;j<=v;j++)//j:花瓶的数量 
		{
			/*
				第i束花摆放在第l个花瓶，前面
				i-1束花摆放在前l-1个花瓶
				前面i-1束花至少使用i-1个花瓶，
				所以 i<=l<=j 
			*/
			for(l=i;l<=j;l++){
				t=dp[i-1][l-1]+a[i][l];
				if(dp[i][j]<t){
					dp[i][j]=t;
				}
					
			}
				
		}
		cout<<dp[f][v]<<endl;
		printPath(f,v);
	return 0;
}
```


---

## 作者：fy0123 (赞：4)

简单DP.


首先将问题简化：在一个n\*m的矩阵a[i][j]内，满足n<=m，求一个序列A1,A2,A3,...,An，满足1<=A1<A2<A3<...<An<=m，使得a[1][A1]+a[2][A2]+a[3][A3]+...+a[n][An]最大。

状态：f[i][j]表示选到前i行，第i行选了第j列的数的最大值。转移就枚举前一行选的是哪个位置。边界条件f[1][j]=a[1][j]，f[i][j]=-INF(i=2..n,j=1..m)。

转移代码如下：

```cpp
for (int i = 2; i <= n; i ++)
    for (int j = i; j <= m; j ++){
        for (int k = i-1; k < j; k ++)
            if (f[i][j] < f[i-1][k]){
                f[i][j] = f[i-1][k];
                g[i][j] = k;
            }
        f[i][j] += a[i][j];
    }
```
这里的数组g，记录的是在选到前i行，第i行选了第j列的数这一状态下，上一行选的位置在哪里。

这样输出方案的时候递归一下就可以了。


具体代码如下：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;

const int N = 110;
const int INF = 1e9;
int n, m;
int a[N][N], f[N][N], g[N][N];

void print(int i, int j) //递归输出方案。
{
    if (i == 1){ //递归边界
        printf("%d", j);
        return;
    }
    print(i-1, g[i][j]);
    printf(" %d", j);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++) scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++) f[i][j] = i == 1 ? a[i][j] : -INF;
    for (int i = 2; i <= n; i ++)  //DP全过程，计算最大值f和前一行的位置g
        for (int j = i; j <= m; j ++){
            for (int k = i-1; k < j; k ++)
                if (f[i][j] < f[i-1][k]){
                    f[i][j] = f[i-1][k];
                    g[i][j] = k;
                }
            f[i][j] += a[i][j];
        }
    int ans = -INF, pos;
    for (int i = 1; i <= m; i ++)
        if (f[n][i] > ans) ans = f[n][i], pos = i;
    printf("%d\n", ans);
    print(n, pos);
    return 0;
}
```

---

## 作者：skylee (赞：3)

思路:

dp[i][j]表示。第i种花选择第j个花盆的最大价值。

i<=j<=v-f+1。

则dp[i+1][k]=max(dp[i][j]+val[i+1][k])。

j+1<=k<=v-f+2.

记录路径感觉写得有点搓。

详细见代码：

 ```cpp

#include <iostream>  
#include<stdio.h>  
#include<string.h>  
using namespace std;  
const int INF=0xcfcfcfcf;  
int val[110][110],dp[110][110],path[110][110],pp[110];  
void getpath(int i,int pos)//获取路径  
{  
    if(i==1)  
    {  
        pp[i]=pos;  
        return;  
    }  
    getpath(i-1,path[i][pos]);  
    pp[i]=pos;  
}  
int main()  
{  
    int i,j,k,f,v,lim,p;  
  
    while(~scanf("%d%d",&f,&v))  
    {  
        for(i=1;i<=f;i++)  
            for(j=1;j<=v;j++)  
            {  
                scanf("%d",&val[i][j]);  
                dp[i][j]=INF;  
            }  
        lim=v-f+1;  
        for(i=1;i<=lim;i++)  
        {  
            dp[1][i]=val[1][i];  
            path[1][i]=i;  
        }  
        for(i=1;i<f;i++)  
        {  
            lim=v-f+i;  
            for(j=i;j<=lim;j++)  
            {  
                for(k=j+1;k<=lim+1;k++)  
                {  
                    if(dp[i][j]+val[i+1][k]>dp[i+1][k])  
                    {  
                        dp[i+1][k]=dp[i][j]+val[i+1][k];  
                        path[i+1][k]=j;  
                    }  
                }  
            }  
        }  
        p=f;  
        for(i=p;i<=v;i++)  
        {  
            if(dp[f][i]>dp[f][p])  
                p=i;  
        }  
        printf("%d\n",dp[f][p]);  
        getpath(f,p);  
        for(i=1;i<f;i++)  
            printf("%d ",pp[i]);  
        printf("%d\n",pp[f]);  
    }  
    return 0;  
}  
```

---

## 作者：Drifting (赞：3)

**欢迎访问博客，获得更佳阅读体验** [戳这里](https://drifts.top/ti-jie/332/)
# 题面
[洛谷 P1854](https://www.luogu.org/problemnew/show/P1854 "洛谷 P1854")
## 题目描述
某花店现有 $F$ 束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按 $1$ 到 $V$ 顺序编号，$V$ 是花瓶的数目。花束可以移动，并且每束花用 $1$ 到 $F$ 的整数标识。如果 $I < J$，则花束 $I$ 必须放在花束 $J$ 左边的花瓶中。例如，假设杜鹃花的标识数为 $1$，秋海棠的标识数为 $2$，康乃馨的标识数为 $3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。

每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为 $0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示：

| 花名/花瓶编号 | 花瓶1 | 花瓶2 | 花瓶3 | 花瓶4 | 花瓶5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 杜鹃花 | 7 | 23 | -5 | -24 | 16 |
| 秋海棠 | 5 | 21 | -4 | 10 | 23 |
| 康乃馨 | -21 | 5 | -4 | -20 | 20 |


根据表格，杜鹃花放在花瓶 $2$ 中，会显得非常好看，但若放在花瓶 $4$ 中，则显得很难看。

为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。

## 输入格式
输入文件的第一行是两个整数 $F$ 和 $V$，分别为花束数和花瓶数 $(1≤F≤100,F≤V≤100)$ 。接下来是矩阵 $A_{ij}$,它有 $I$ 行，每行 $J$ 个整数，$A_{ij}$ 表示花束 $I$ 摆放在花瓶 $J$ 中的美学值。

## 输出格式
输出文件的第一行是一个整数，为最大的美学值；接下来有 $F$ 行，每行两个数，为那束花放入那个花瓶的编号。

## 输入样例
    3 5
    7 23 -5 -24 16
    5 21 -4 10 23
    -21 5 -4 -20 20
## 输出样例
    53
    2 4 5
## 说明
感谢@罗恺 提供SPJ

# 思路
读完题，你一定已经懵逼了。

没错，这种大赛的题目总是有着像 语文/English 阅读理解的题面。

下面我来划一下重点：

> 给定一个 $F \times J$ 的矩阵 $A(F \leq J)$，求一个序列 $a_1,a_2,…,a_n$ 满足
$1 \leq a_1 < a_2 < \dots < a_n \leq J$,
使得 $A[1][a_1]+A[2][a_2]+…+A[n][a_n] $最大。
矩阵中 $A_{ij}$ 可能含有负数。

很显然这是一道DP，然而，一样能把它看成是一道图论题。

把矩阵看成一张图的话，就是求从第 $1$ 行到第 $F$ 行的一条路径，使得路径上经过的点的权值最大。需要注意的是，从一个点出发，只能向它的右下移动，不能垂直向下或向左。

具体的做法，我们考虑设一个虚点 $0$，从 $0$ 向第一行每个点连一条边，再从第一行开始向下一行的节点连边。

然后从 $0$ 开始跑一个 $SPFA$ 求出最长路，同时记录路径。

最后比较一下第 $F$ 行每个点的 $dis$ 值，最大的即为终点。从终点回溯，输出路径。

需要注意的是题目要求的路径是正序的，所以需要借助一个栈把路径正过来。

这种算法没有DP跑得快，但思路很显然很暴力。（毕竟不是标算嘛...）
# Code
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#define trans(i, j) ((i - 1) * V + j)
using namespace std;
const int INF = 0x3f3f3f3f;
const int MAXF = 105;
const int MAXV = 105;
const int MAXN = MAXF * MAXV;
int cnt = 0, F, V, ma[MAXF][MAXV];
int head[MAXN], dis[MAXN + 1], pre[MAXN];
bool vis[MAXN + 1];
struct Edge
{
    int u, v, w, next;
} e[800000];
inline void add_Edge(int u, int v, int w)
{
    e[++cnt].u = u, e[cnt].v = v, e[cnt].w = w;
    e[cnt].next = head[u], head[u] = cnt;
}
void SPFA(int s)
{
    queue<int> q;
    for (int i = 1; i <= F * V; i++)
        dis[i] = -INF;
    dis[s] = 0;
    q.push(s);
    vis[s] = 1;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].v, w = e[i].w;
            if (dis[u] + w > dis[v])
            {
                dis[v] = dis[u] + w;
                pre[v] = u;
                if (!vis[v])
                {
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d", &F, &V);
    for (int i = 1; i <= F; i++)
        for (int j = 1; j <= V; j++)
            scanf("%d", &ma[i][j]);
    for (int j = 1; j <= V; j++)
        add_Edge(0, trans(1, j), ma[1][j]);
    for (int i = 1; i < F; i++)
        for (int j = 1; j < V; j++)
            for (int k = j + 1; k <= V; k++)
                add_Edge(trans(i, j), trans(i + 1, k), ma[i + 1][k]);
    SPFA(0);
    int ans = -INF, end;
    for (int j = 1; j <= V; j++)
    {
        int u = trans(F, j);
        if (ans < dis[u])
            ans = dis[u], end = u;
    }
    printf("%d\n", ans);
    int sta[105];
    for (int i = F, j = end; i && j; j = pre[j], i--)
        sta[i] = j - (i - 1) * V;
    for (int i = 1; i <= F; i++)
        printf("%d ", sta[i]);
    return 0;
}
```

---

## 作者：TianZ (赞：3)

具体的思路楼下的大佬都已经说过了，状态转移请看楼下，重点是如何输出，相信许多朋友都栽在输出这个位置，所以我就重点来讲讲输出。

演算过程：
```cpp
样例，花瓶自身美学值：
7 23 -5 -24 16
5 21 -4 10 23
-21 5 -4 -20 20
样例，花瓶可以有的最大美学值：
48 53 25 -100000001 -99999984
25 41 16 30 -99999977
-21 5 -4 -20 20
不难发现，花瓶可以有的最大美学值-自身美学值就是其他花瓶可以有的最大美学值。（表述有点差，自行理解一哈）
图中：53-23=30，输出53的编号2
	 30-10=20，输出30的编号4
	  输出20的编号5
于是我们就华丽地得到了2-4-5这个输出样例

```
输出方式：

1.求出ans，及最大美学值

2.例如在第1排搜索，当在1-n排花瓶的最大美学值为ans是时，输出花屏编号，并用last数组来记录花瓶编号

3.找到之后ans-=他自身的美学值，这就找到了只有n-1瓶花时，最大的美学值

4.以此类推，继续搜索

具体代码如下：

四十分代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,flower[205][205],beautiful[205][205],maxn=-1e8,ans=-1e8,tot=1,temp=1,last[205][205];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>beautiful[i][j],
            flower[i][j]=beautiful[i][j];
    for(int i=n-1;i>=1;i--)
        for(int j=1;j<=m;j++){
            for(int k=j+1;k<=m;k++)
                maxn=max(maxn,flower[i+1][k]);
            flower[i][j]+=maxn;
            maxn=-1e8;
    }
    for(int i=1;i<=m;i++){
        ans=max(ans,flower[1][i]);
        if(flower[1][i]>ans){
            ans=flower[1][i];
            temp=i;
        }
    }				
    cout<<ans<<endl;
    last[tot][temp]=ans;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(flower[i][j]==last[tot][temp] && j>temp){
                cout<<j<<" ";
                temp=j;
                last[++tot][temp]=flower[i][j]-beautiful[i][j];
            }
        }
    }
    return 0;
}
```
下载了测试点，又看了看题目，赫然发现只用输出一组答案，而我这种可能会在一棵花瓶中插上所有可以达到最大值的花！！于是我又交了1个90分代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,flower[205][205],beautiful[205][205],maxn=-1e8,ans=-1e8,tot=1,temp=1,last[205][205];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>beautiful[i][j],
            flower[i][j]=beautiful[i][j];
    for(int i=n-1;i>=1;i--)
        for(int j=1;j<=m;j++){
            for(int k=j+1;k<=m;k++)
                maxn=max(maxn,flower[i+1][k]);
            flower[i][j]+=maxn;
            maxn=-1e8;
    }
    for(int i=1;i<=m;i++){
        ans=max(ans,flower[1][i]);
        if(flower[1][i]>ans){
            ans=flower[1][i];
            temp=i;
        }
    }				
    cout<<ans<<endl;
    last[tot][temp]=ans;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(flower[i][j]==last[tot][temp] && j>temp){
                cout<<j<<" ";
                temp=j;
                last[++tot][temp]=flower[i][j]-beautiful[i][j];
                break;
            }
        }
    }
    return 0;
}
```
为什么90分呢，我沉思了一会，突然想到当花瓶编号是一时，temp==编号，不会执行下列程序！！！
终于，我交出了一个满分代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,flower[205][205],beautiful[205][205],maxn=-1e8,ans=-1e8,tot=1,temp=1,last[205][205];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>beautiful[i][j],
            flower[i][j]=beautiful[i][j];
    for(int i=n-1;i>=1;i--)
        for(int j=1;j<=m;j++){
            for(int k=j+1;k<=m;k++)
                maxn=max(maxn,flower[i+1][k]);
            flower[i][j]+=maxn;
            maxn=-1e8;
    }
    for(int i=1;i<=m;i++){
        ans=max(ans,flower[1][i]);
        if(flower[1][i]>ans){
            ans=flower[1][i];
            temp=i;
        }
    }				
    cout<<ans<<endl;
    last[tot][1]=ans;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(flower[i][j]==last[tot][temp] && ((j==1 && temp==1) || j>temp)){
                cout<<j<<" ";
                temp=j;
                last[++tot][temp]=flower[i][j]-beautiful[i][j];
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

这个题我用了种怪异的方法：首先用记忆化搜索求出最大美学值，再用dfs“硬凑”出一种符合这个最大值的方案（毕竟我不会路径记录）。记搜的部分很简单：就是求从这个格子开始，取这个格子可以获得的最大值f，它等于下面能取的格子的f值与自身值的和的最大值。当然，这个最大值我们需要在第一束花上枚举所有的花瓶，挨个的记搜，找出那个真正的最大值。求出最大值后直接无脑dfs硬凑出方案即可，但是有一点需要注意：题目只需一种符合要求的方案即可，所以硬凑出方案时要立即停止dfs（我就因为这个一直WA一个点）。

代码如下：

```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    long long v[200][200];     //花与花瓶构成的矩阵
    long long f[200][200];       //搜到的f值
    unsigned char bv[200][200];  //记录是否已经搜到
    int huas;int huapings;
    long long memdfs(int hua,int huaping){    //记搜程序
        if(bv[hua][huaping])return(f[hua][huaping]);
        if(huas-hua>huapings-huaping)return(-92233720368547758);     //要是当前剩的花瓶数小于剩的花数，直接返回
        bv[hua][huaping]=1;
        if(hua==huas){
            f[hua][huaping]=v[hua][huaping];
            return(v[hua][huaping]);
        }
        long long maxn=-9223372036854775808;
        for(int i=huaping+1;i<=huapings;i++){
            long long res=v[hua][huaping]+memdfs(hua+1,i);   
            //向下一束花可能放的位置逐个记搜
            if(res>maxn){   //找最大值
                maxn=res;
            }
        }
        f[hua][huaping]=maxn;
        return(maxn);
    }
    long long iresult;
    long long finds[200];    //记录找到的方格
    int dfs(int hua,int huaping,long long sum){
        if(hua==huas){
            if(sum==iresult){          //成功凑出方案！
                cout<<finds[0];
                for(int i=1;i<huas;i++){
                    cout<<" "<<finds[i];
                }
                return(1);    //立刻结束dfs
            }
        }
        else{
            if(huas-hua>huapings-huaping)return(0);
            for(int i=huaping+1;i<=huapings;i++){
                if(f[hua+1][i]==sum){   
            //这个格子的f值正好满足最大值推出来的结果，说不定真是正确方案
                    finds[hua]=i;
                    if(dfs(hua+1,i,sum-v[hua+1][i])==1)return(1);
                    //成功凑出方案后就不再dfs
                }
            }
            return(0);
        }
    }
    int main(){
        cin>>huas>>huapings;
        for(int i=1;i<=huas;i++){
            for(int j=1;j<=huapings;j++){
                cin>>v[i][j];
            }
        }
        long long maxn=-9223372036854775808;
        for(int i=1;i<=huapings;i++){
        //枚举第一束花可能插的花瓶，逐个求出f值，最后取最大的
            maxn=max(memdfs(1,i),maxn);
        }
        cout<<maxn<<endl;
        dfs(0,0,maxn);//凑方案
        return(0);
}
```

---

## 作者：Sober_Clever (赞：2)

很好的动态规划习题

f [ i ][ j ]表示第i束花插到第j个花瓶中时，最大的美学值（此时已插好的所有花中，i时最后一朵）

f [ i ][ j ] = max ( f[ i-1 ][ k ] )(k<j)+a[ i ][ j ]
（a即为输入中所给的矩阵）

为了是答案有意义，循环中的j要从i到V-F+i（保证前后的每一朵花都有花瓶可插）

由于可能出现负值，因此我们将f数组初始化为负无穷

具体见代码
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=100 + 5;
int a[MAXN][MAXN],f[MAXN][MAXN]={0},pre[MAXN][MAXN]={0};
//f[i][j]表示第i束花插到第j个花瓶中时，最大的美学值
int read()
{
    int x=0,w=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48;c=getchar();}
    return x*w;
}
void Print(int num,int x)
{
    if(!num) return ;
    Print(num-1,pre[num][x]);
    printf("%d ",x);
}
int main()
{
    int F=read(),V=read();
    for(int i=1;i<=F;i++)
        for(int j=1;j<=V;j++)
            a[i][j]=read();
    for(int i=1;i<=F;i++)
        for(int j=0;j<=V;j++)
            f[i][j]=-1<<30;
    for(int i=1;i<=V-F+1;i++) f[1][i]=a[1][i];
    for(int i=2;i<=F;i++)
        for(int j=i;j<=V-F+i;j++)
        {
            int t=0;
            for(int k=i-1;k<j;k++)
                if(f[i-1][t]<f[i-1][k])
                    t=k;
            f[i][j]=f[i-1][t]+a[i][j];
            pre[i][j]=t;
        }
    int ans=0;
    for(int j=F;j<=V;j++)
        if(f[F][j]>f[F][ans])
            ans=j;
    printf("%d\n",f[F][ans]);
    Print(F,ans);
    printf("\n");
    return 0;
}

```
~~难得切道IOI~~

---

## 作者：封禁用户 (赞：2)

```cpp
var
a:array[1..100,1..100]of integer;//A【i，j】放在花瓶j中的美学值；
b:array[1..100,1..100]of integer;//b【i，j】放在放在前j个花瓶的最优解
c:array[1..100,1..100]of integer;//C【i，j】放在b【i，j】的最优解中的位子
d:array[1..100]of integer;
f,v:integer;//花瓶和画的数目
i,j,k,max:integer;
begin
readln(f,v);
for i:=1 to f do
for j:=1 to v do
read(a[i,j]);
for i:=1 to v-f+1 do
b[1,i]:=a[1,i];
for i:=2 to f do
for j:=i to v-f+i do//枚举花束i-1的位置
for k:=i-1 to j-1 do
if b[i-1,k]+a[i,j]>b[i,j] then
begin
b[i,j]:=b[i-1,k]+a[i,j];//更新
c[i,j]:=k;
end;
max:=0;
for i:=f to v do
if b[f,i]>max then
begin
max:=b[f,i];//选择最优
k:=i;//最后一束花的位子
end;
writeln(max);
for i:=1 to f do//打印
begin
d[i]:=k;
k:=c[f-i+1,k];
end;
for i:=f downto 2 do
write(d[i],' ');
writeln(d[1]);
end.
```

---

## 作者：不存在之人 (赞：1)

### 注意：请不要被标签吓到了~~其实我刚开始也被吓到了~~

**这道题一看就是动态规划，多重背包问题，而这道题我是这么想的：用f[i][j]来表示在第i个位置放了第j盆花的最高美学值。f的初始化就是在第i个位置放j盆花的美学值。而且要把第一排预处理一下。**

而第i个位置放j盆花就可以等于两个：

1. 在i位置上不放花，即f[i][j]=f[i][j-1];

2. 在i位置上放花，即f[i][j]=f[i-1][j-1]+f[i][j];

就是在这两个中选max的。

但是在循环中要注意把j的值控制，因为要为后面剩下的花至少留一点位置。

而输出路径就标记一下，如果放了花，就把ans[i][j]设为2，没放就设为1.最后递归输出。

**代码如下：**
```cpp
#include<cstdio>
int f[101][101],ans[101][101],n,m;
void fn(int x,int y)
{
    if(ans[x][y]==0&&x==1)
	{
		printf("%d",y);
		return ;
	}
    if(ans[x][y]==2)
	{
		fn(x-1,y-1);
		printf(" %d",y);
	} 
    else if(ans[x][y]==1) fn(x,y-1); 
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&f[i][j]);
    for(int i=2;i<=m-n+1;i++) 
        if(f[1][i-1]>f[1][i]) 
            f[1][i]=f[1][i-1],ans[1][i]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j=i;j<=m-n+i;j++)
        {
            if(i==j)
                f[i][j]+=f[i-1][j-1],ans[i][j]=2;
            else if(f[i-1][j-1]+f[i][j]>f[i][j-1])
                f[i][j]+=f[i-1][j-1],ans[i][j]=2;
            else
                f[i][j]=f[i][j-1],ans[i][j]=1;
        }
    }
    printf("%d\n",f[n][m]); 
    fn(n,m);  
}
```

---

## 作者：Macwyw (赞：1)

题目描述

有n束花放在m个瓶子里会产生一个价值wnm。第i号花束可任意放在第j号瓶子里。求能产生的最大价值。         规定：m>=n且第i号花束摆放的花瓶编号必须大于第i-1号花束摆放的花瓶编号。

解析
可以转化成在有n行m列的矩阵a[i][j] (满足n<=m)中求一个序列A1,A2,A3,...,An，（A1<=A1<A2<A3<...<An<=m）（An为j）使得a[1][A1]+a[2][A2]+a[3][A3]+...+a[n][An]最大。

花瓶1 花瓶2 花瓶3 花瓶4 花瓶5

杜鹃花 7     23     -5     -24     16

秋海棠 5     21     -4      10     23

康乃馨 -21    5     -4     -20     20

状态：对于第i行第j列。有两种状态：

1、若取aij：则前i-1行只能在j-1列中取。状态为 dp[i-1][j-1]+a[i][j](dp[i-1][j-1]表示前i-1束花放在前j-1个花瓶中)；                                                 2、若不取：则前i行只能在j-1列中取。状态为dp[i][j-1](表示前i束花放在前j-1个花瓶中)；

得装态转移方程为


dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+a[i][j]);

在取路径时就根据上面的状态转移分类：

    
```cpp
void zhao(int i,int j,int k)
{
    if(i==0)
    {
        return;
    }
    if(p[i][j]==1)
    {
        d[k]=j;
        zhao(i-1,j-1,k-1);
    }
    else
    {
        zhao(i,j-1,k);
    }
}
```
#####################
蒟蒻的代码





    

    
    



    
    

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
using namespace std;
int dp[200][200];
int w[200][200];
int p[200][200];
int d[200];
const int MAXN=1<<30;
void zhao(int i,int j,int k)
{
    if(i==0)
    {
        return;
    }
    if(p[i][j]==1)
    {
        d[k]=j;
        zhao(i-1,j-1,k-1);
    }
    else
    {
        zhao(i,j-1,k);
    }
}
int main()
{
    int f,v;
    int i,j,k;
    int ans,t;
    scanf("%d%d",&f,&v);
    for(i=1;i<=f;i++)
    {
        for(j=1;j<=v;j++)
        {
            scanf("%d",&w[i][j]);    
        }    
    }    
    memset(p,0,sizeof(p));
    memset(dp,0,sizeof(0));
    for(i=1;i<=f;i++)
    {
        dp[i][i]=dp[i-1][i-1]+w[i][i];
        p[i][i]=1;
        for(j=i+1;j<=v-f+i;j++)
        {
            t=dp[i-1][j-1]+w[i][j];
            if(dp[i][j-1]<t)
            {
                dp[i][j]=t;
                p[i][j]=1;
            }
            else
            {
                dp[i][j]=dp[i][j-1];
            }
        }
    }
    printf("%d\n",dp[f][v]);
    zhao(f,v,f);
    for(i=1;i<=f;i++)
    {
        printf("%d ",d[i]);
    }
    return 0;    
} 

```

---

## 作者：封禁用户 (赞：1)

问题实际就是给定F束花和V个花瓶，以及各束花放到不同花瓶中的美学值，要求你找出一种摆放的方案，使得在满足编号小的花放进编号小的花瓶中的条件下，美学值达到最大。

将问题进行转化，找出问题的原型。首先，看一下上述题目的样例数据表格。

将摆放方案的要求用表格表现出来，则摆放方案需要满足：每行选且只选一个数(花瓶)；摆放方案的相邻两行中，下面一行的花瓶编号要大于上面一行的花瓶编号两个条件。这时可将问题转化为：给定一个数字表格，要求编程计算从顶行至底行的一条路径，使得这条路径所经过的数字总和最大(要求每行选且仅选一个数字)。同时，路径中相邻两行的数字，必须保证下一行数字的列数大于上一行数字的列数。

看到经过转化后的问题，发现问题与“数学三角形”问题十分相似，数字三角形问题的题意是：

给定一个数字三角形，要求编程计算从顶至底的一条路径，使得路径所经过的数字总和最大(要求每行选且仅选一个数字)。同时，路径中相邻两行的数字，必须保证下一行数字的列数与上一行数字的列数相等或者等于上一行数字的列数加1。

上例中已经知道：数字三角形中的经过数字之和最大的最佳路径，路径的每个中间点到最底层的路径必然也是最优的，可以用动态规划方法求解，对于“花店橱窗布置”问题经过转化后，也可采取同样的方法得出本题同样符合最优性原理。因此，可以对此题采用动态规划的方法。

代码丑，dalao勿喷

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int main()
{
  int a[101][101],b[101][101],c[101][101],d[101];   //a[i][j] 花束i放在花瓶j中的美学值
                                        //b[i][j] 前i束花放在前j个花瓶中的最优解
                                        //c[i][j] 在b[i][j]的最优解中，花束i-1的位置
  int f,v,i,j,k,max;                         //f , v 花束和花瓶的数目
  cin>>f>>v;
  for (i=1;i<=f;i++)
   for (j=1;j<=v;j++)
cin>>a[i][j];
  memset(b,128,sizeof(b));                  //这样处理，可以保证每束花都放进花瓶
  for (i=1;i<=v-f+1;i++)                    //初始化第1束花放在第i个花瓶的情况
   b[1][i]=a[1][i];
  for (i=2;i<=f;i++)
   for (j=i;j<=v-f+i;j++) 
    for (k=i-1;k<=j-1;k++)                  //枚举花束i-1的位置
     if (b[i-1][k]+a[i][j]>b[i][j])
      {
        b[i][j]=b[i-1][k]+a[i][j];             //更新当前最优解
        c[i][j]=k;                         //前一个花束的位置为k
      } 
   max=-2100000000;
   for (i=f;i<=v;i++)
    if (b[f][i]>max)
     {
       max=b[f][i];                       //选择全局最优解
       k=i;                              //k最后一束花的位置
     }   
    cout<<max<<endl;                     //打印最优解
    for (i=1;i<=f;i++)
     {
       d[i]=k;
       k=c[f-i+1][k];
     } 
    for (i=f;i>=2;i--)
     cout<<d[i]<<" ";
    cout<<d[1]<<endl;
}
```

---

## 作者：Harker233333333 (赞：1)

这题用DP：递推方程式w[i][j]=max(w[i-k][j-1]+t[j][k+1]);(下面有解释)

```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;
int main()
{
    int t[101][101],w[101][101]={0},mark[101][101];//w[i][j]:将j束花放入i个花瓶,mark-存放路径 
    int f,v;
    int i,j,k;
    int ans[101];//存放答案 
    cin>>f>>v;
    for(i=1;i<=f;i++)
    for(j=1;j<=v;j++)
    cin>>t[i][j];//t[i][j]-第i束花放在第j花瓶的美学值 
    for(i=1;i<=f;i++)
    w[i][i]+=w[i-1][i-1]+t[i][i];
    for(i=1;i<=v;i++)
    for(j=1;j<=f;j++)
    {
     w[i][j]=-1*0x3f3f3f3f;//先赋个极小值 
    for(k=j-1;k<=i-1;k++)//k表示第j束花放在第k+1花瓶 
    if(w[i][j]<w[k][j-1]+t[j][k+1])
    {w[i][j]=w[k][j-1]+t[j][k+1];mark[i][j]=k+1;}
    }
    cout<<w[v][f]<<endl;
    i=v;j=f;
    while(j>=1)
    {
        ans[j]=mark[i][j];
        i=mark[i][j]-1;j--;
        //理解不了这一步的可以看上面对mark[i][j]的处理:w[i][j]是由w[k][j-1]推来的,而k=mark[i][j]-1
    }
    for(j=1;j<=f;j++)
    cout<<ans[j]<<' ';
    return 0;
}
```

---

## 作者：crowworks695 (赞：1)

其实这道题用O(n2)的DP即可解决。

状态转移方程：f[i][j]=max(f[i-1][j-1]+把第i束花放入第j个花瓶中的美观度,f[i][j-1])。f[i][j]表示将前i束花放入前j个花瓶中的美观度最大值。对于每个状态f[i][j],可以选择将第i束花插入第j个花瓶或者不插，所以就有了如上状态转移方程。这里有个地方需要注意，当i>=j时，即所剩的要放入花瓶的花的数量与花瓶数量相等或更大时，只有f[i-1][j-1]+美观度这一种转移，因为剩下的花每个都必须放入花瓶。

```cpp

#include <cstdio>

using namespace std;

int map[101][101],f[101][101]={0},path[101][101]={0};

int fl,v;

void print(int x,int y)
{
    if(x<1||y<1)return;
    if(path[x][y])
    {
        print(x-1,y-1);
        printf("%d ",y);
    }
    else
    {
        print(x,y-1);
    }
}

int main()
{
    scanf("%d%d",&fl,&v);
    for(int i=1;i<=fl;i++)
    {
        for(int j=1;j<=v;j++)
        {
            scanf("%d",&map[i][j]);
        }
    }
    for(int i=1;i<=fl;i++)
    {
        for(int j=1;j<=v;j++)
        {
            if(f[i][j-1]<f[i-1][j-1]+map[i][j]||i>=j)
            {
                f[i][j]=f[i-1][j-1]+map[i][j];
                path[i][j]=1;//记录对于每个状态是怎么到达的
            }
            else
            {
                f[i][j]=f[i][j-1];
            }
        }
    }
    printf("%d\n",f[fl][v]);
    print(fl,v);//递归方式打印解
    return 0;
}

```

---

## 作者：ShineEternal (赞：1)

# 给大家提供两种方法:

## 法1：

问题实际就是给定F束花和V个花瓶，以及各束花放到不同花瓶中的美学值，要求你找出一种摆放的方案，使得在满足编号小的花放进编号小的花瓶中的条件下，美学值达到最大
。
        将问题进行转化，找出问题的原型。首先，看一下上述题目的样例数据表格。
        
将摆放方案的要求用表格表现出来，则摆放方案需要满足：每行选且只选一个数(花瓶)；摆放方案的相邻两行中，下面一行的花瓶编号要大于上面一行的花瓶编号两个条件。这时可将问题转化为：给定一个数字表格，要求编程计算从顶行至底行的一条路径，使得这条路径所经过的数字总和最大(要求每行选且仅选一个数字)。同时，路径中相邻两行的数字，必须保证下一行数字的列数大于上一行数字的列数。

看到经过转化后的问题，发现问题与“数学三角形”问题十分相似，数字三角形问题的题意是：
      
  给定一个数字三角形，要求编程计算从顶至底的一条路径，使得路径所经过的数字总和最大(要求每行选且仅选一个数字)。同时，路径中相邻两行的数字，必须保证下一行数字的列数与上一行数字的列数相等或者等于上一行数字的列数加1。
       
   上例中已经知道：数字三角形中的经过数字之和最大的最佳路径，路径的每个中间点到最底层的路径必然也是最优的，可以用动态规划方法求解，对于“花店橱窗布置”问题经过转化后，也可采取同样的方法得出本题同样符合最优性原理。因此，可以对此题采用动态规划的方法
       
```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int main()
{
  int a[101][101],b[101][101],c[101][101],d[101];   //a[i][j] 花束i放在花瓶j中的美学值
                                        //b[i][j] 前i束花放在前j个花瓶中的最优解
                                        //c[i][j] 在b[i][j]的最优解中，花束i-1的位置
  int f,v,i,j,k,max;                         //f , v 花束和花瓶的数目
  cin>>f>>v;
  for (i=1;i<=f;i++)
   for (j=1;j<=v;j++)
cin>>a[i][j];
  memset(b,128,sizeof(b));                  //这样处理，可以保证每束花都放进花瓶
  for (i=1;i<=v-f+1;i++)                    //初始化第1束花放在第i个花瓶的情况
   b[1][i]=a[1][i];
  for (i=2;i<=f;i++)
   for (j=i;j<=v-f+i;j++) 
    for (k=i-1;k<=j-1;k++)                  //枚举花束i-1的位置
     if (b[i-1][k]+a[i][j]>b[i][j])
      {
        b[i][j]=b[i-1][k]+a[i][j];             //更新当前最优解
        c[i][j]=k;                         //前一个花束的位置为k
      } 
      max=-2100000000;
   for (i=f;i<=v;i++)
    if (b[f][i]>max)
     {
       max=b[f][i];                       //选择全局最优解
       k=i;                              //k最后一束花的位置
     }   
    cout<<max<<endl;                     //打印最优解
    for (i=1;i<=f;i++)
     {
       d[i]=k;
       k=c[f-i+1][k];
     } 
    for (i=f;i>=2;i--)
     cout<<d[i]<<" ";
    cout<<d[1]<<endl;
}


```
 ## 法2：
 
 flower一题是IOI99第一天第一题，该题如用组合的方法处理，将会造成超时。正确的方法是用动态规划，考虑角度为一束一束地增加花束，假设用b[i][j]表示1～i束花放在1到j之间的花瓶中的最大美学值，其中i<=j ，则b[i][j]=max(b[i-1][k-1]+A[i][k])，其中i<=k<=j，A[i][k]的含义参见题目。输出结果时，显然使得b[F][k]取得总的最大美观值的第一个k值就是第F束花应该摆放的花瓶位置，将总的最大美观值减去A[i][k]的值即得到前k-1束花放在前k-1个瓶中的最大美观值，依次使用同样的方法就可求出每一束花应该摆放的花瓶号。由于这一过程是倒推出来的，所以程序中用递归程序来实现。 。
 
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
void print(int,int);
int max(int a,int b) { return a>b?a:b; }
int a[101][101],b[101][101];
int main()
{
  int f,v;
  cin>>f>>v;
  for (int i=1;i<=f;i++)
    for (int j=1;j<=v;j++)
      cin>>a[i][j];
  memset(b,128,sizeof(b));            //初始化b数组
  for (int i=0;i<101;i++) b[0][i]=0;      //没有放花时，美学值为0。这也是初始化
  for (int i=1;i<=f;i++)
    for (int j=i;j<=v-f+i;j++)
    {
      for (int k=i;k<=j;k++)
	        b[i][j]=max(b[i][j],b[i-1][k-1]+a[i][k]);
 }  
    int c=-1000000;
    for (int i=f;i<=v;i++)
      if (b[f][i]>c)
        c=b[f][i];
    cout<<c<<endl;   
    print(f,c);
}
void print(int i,int j)
{
  int n;
  if (i>0)
    {
      n=i;
      while (b[i][n]!=j)
      {
        n++;
      } 
      print(i-1,j-a[i][n]);
      cout<<n<<" "; 
    }  
}
```
# by  一本通

求过

---

## 作者：gary2005 (赞：0)

我的方法和大家的略有不同

首先我定义dp[i][j] (i<=j<=v)为第i朵花放到第j个花盆的最大美观度(已经放好i-1朵花)

那么我们只需要枚举k(1<=k<j)即可，找出最大值再加上第i朵花放到第j给花盆的美观度。

那么最大美观度就完成了，伪代码
```cpp
memset(dp,-0x3f,sizeof(dp));//初始化
	for(int i=1;i<=v;i++){
		dp[1][i]=tab[1][i];
	}//还是初始化
	for(int i=2;i<=f;i++){//从第二朵开始枚举
		for(int j=i;j<=v;j++){//枚举第i朵放入的花瓶
			int maxk=0;
			for(int k=1;k<j;k++){//找出最大的“K”
				if(dp[i-1][k]>dp[i-1][maxk]){
					maxk=k;
				}
			}
			dp[i][j]=dp[i-1][maxk]+tab[i][j];//加上第i朵花放入第j个花瓶的美观度
		}
	}
```
之后只需要枚举最后一朵花放到的花瓶，找出最大值即可
```cpp
int maxans=-0x3f3f3f3f;
for(int i=f;i<=v;i++){
	if(dp[f][i]>maxans){
		maxans=dp[f][i];
	}
}
printf("%d\n",maxans);
```
到这，我们这题才做好一小半。那怎么才能输出方案呢？

定义step[i][j]表示第i朵花放到第j个花瓶得到最大值是由上面哪一步得来的（也就是上得到最大值是由上一朵放到哪得到的）

现在就很简单了，我们既然已经找到了“maxk”那么就顺便赋值了step[i][j]
```cpp
for(int i=2;i<=f;i++){
		for(int j=i;j<=v;j++){
			int maxk=0;
			for(int k=1;k<j;k++){
				if(dp[i-1][k]>dp[i-1][maxk]){
					maxk=k;
				}
			}
			step[i][j]=maxk;//HERE*\*\*\*\*\*\
			dp[i][j]=dp[i-1][maxk]+tab[i][j];
		}
	}
```
接下来就是递归输出了
```cpp
dfs_print(f,maxnum);
```
```cpp
void dfs_print(int now,int num){
	if(now<1){
		return;
	}
	dfs_print(now-1,step[now][num]);
	printf("%d ",num);
}
```
好现在上完整版代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f,v,tab[101][101],dp[101][101],step[101][101];
void dfs_print(int now,int num){
	if(now<1){
		return;
	}
	dfs_print(now-1,step[now][num]);
	printf("%d ",num);
}
int main(){
	scanf("%d %d",&f,&v);
	for(int i=1;i<=f;i++){
		for(int j=1;j<=v;j++){
			scanf("%d",&tab[i][j]);
		}
	}
	memset(dp,-0x3f,sizeof(dp));
	for(int i=1;i<=v;i++){
		dp[1][i]=tab[1][i];
	}
	for(int i=2;i<=f;i++){
		for(int j=i;j<=v;j++){
			int maxk=0;
			for(int k=1;k<j;k++){
				if(dp[i-1][k]>dp[i-1][maxk]){
					maxk=k;
				}
			}
			step[i][j]=maxk;
			dp[i][j]=dp[i-1][maxk]+tab[i][j];
		}
	}
	int maxans=-0x3f3f3f3f,maxnum;
	for(int i=f;i<=v;i++){
		if(dp[f][i]>maxans){
			maxans=dp[f][i];
			maxnum=i;
		}
	}
	printf("%d\n",maxans);
	dfs_print(f,maxnum);
	return 0;
}
```

---

## 作者：清衡 (赞：0)

论如何不过样例且A题 BY --wf蒟蒻

因为动态规划数组f一旦值变动（且不==-1234567）那么这个瓶子一定有花；那就搜索上一行前一个数组。但样例是不过的~~~~~望管理加强数据QAQ

```cpp
#include<cstdio>
#include<iostream>
#include<map>
#include<string>
using namespace std;
int h,p,num;
int ar[105][105],f[105][105],nu[105];
int main()
{
    cin>>h>>p;
    for(int i=1;i<=h;i++)
    for(int j=1;j<=p;j++)
    {
        cin>>ar[i][j];
    }
    for(int i=1;i<=h+1;i++)
    for(int j=1;j<=p+1;j++)f[i][j]=-1234567;
    for(int i=1;i<=h;i++)
    for(int j=i;j<=p-h+i;j++)
    for(int k=i;k<=j;k++)
    {
        f[i][j]=max(f[i][j],f[i-1][k-1]+ar[i][k]);
    }
    cout<<f[h][p]<<endl;
        for(int i=h;i>=0;i--)//i,j==0,要考虑第一个花瓶被用的情况
        for(int j=p;j>=0;j--)
        {
            if(f[i][j]!=f[i][j+1]&&f[i][j]!=-1234567&&f[i][j+1]!=-1234567)
            {
                //cout<<i<<" "<<j<<endl;
                nu[++num]=j+1;//逆序输出统计
                if(j!=1)i=i-1;
            }
        }
    for(int i=num;i>=1;i--)cout<<nu[i]<<" ";
    return 0;
}
~~~~
```

---

## 作者：xun薰 (赞：0)

题目大意：每个花放入不同的瓶中都会产生一定价值，并且在某朵花前面的花在花瓶中

也必须在那朵花前面，求最大价值。

题解：dp

dp[i][j]表示前i朵花放入前j个瓶子，并且第i朵花放入第j个瓶子的最大价值。

显然转移是从前一朵花转移过来。枚举前一朵花放的花瓶。

dp[i][j]=max{dp[i-1][k]+v[i][j]}，查找最后的朵花到底放入了哪个花瓶，再顺着找前驱就可以了。

注意：初始化，更新答案的ans一开始是负数，dp也要初始化。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int f,p,ans;
int v[120][120],pre[120][120],dp[120][120],pos[120];
int main(){
    scanf("%d%d",&f,&p);
    for(int i=1;i<=f;i++)
     for(int j=1;j<=p;j++)
      scanf("%d",&v[i][j]);
    for(int i=0;i<=f;i++){
        for(int j=1;j<=p;j++){
            if(i==0)continue;
            dp[i][j]=-10000000;
        }
    }
    for(int i=1;i<=f;i++){
        for(int j=i;j<=p-(f-i);j++){
            for(int k=i-1;k<j;k++){
                if(dp[i][j]<dp[i-1][k]+v[i][j]){
                    dp[i][j]=dp[i-1][k]+v[i][j];
                    pre[i][j]=k;
                }
            }
        }
    }
    ans=-1000000;
    for(int i=f;i<=p;i++){
        if(dp[f][i]>ans){
            ans=dp[f][i];
            pos[f]=i;
        }
    }
    for(int i=f;pre[i][pos[i]];i--){
        pos[i-1]=pre[i][pos[i]];
    }
    printf("%d\n",ans);
    for(int i=1;i<=f;i++)
    printf("%d ",pos[i]);
    return 0;
}
```

---

## 作者：yangshirui (赞：0)

【算法分析】

flower一题是IOI99第一天第一题，该题如用组合的方法处理，将会造成超时。正确的方法是用动态规划，考虑角度为一束一束地增加花束，假设用b[i][j]表示1～i束花放在1到j之间的花瓶中的最大美学值，其中i<=j ，则b[i][j]=max(b[i-1][k-1]+A[i][k])，其中i<=k<=j，A[i][k]的含义参见题目。输出结果时，显然使得b[F][k]取得总的最大美观值的第一个k值就是第F束花应该摆放的花瓶位置，将总的最大美观值减去A[i][k]的值即得到前k-1束花放在前k-1个瓶中的最大美观值，依次使用同样的方法就可求出每一束花应该摆放的花瓶号。由于这一过程是倒推出来的，所以程序中用递归程序来实现。

【参考程序】

 
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
void print(int,int);
int max(int a,int b) { return a>b?a:b; }
int a[101][101],b[101][101];
int main()
{
  int f,v;
  cin>>f>>v;
  for (int i=1;i<=f;i++)
    for (int j=1;j<=v;j++)
      cin>>a[i][j];
  memset(b,128,sizeof(b));            //初始化b数组
  for (int i=0;i<101;i++) b[0][i]=0;      //没有放花时，美学值为0。这也是初始化
  for (int i=1;i<=f;i++)
    for (int j=i;j<=v-f+i;j++)
    {
      for (int k=i;k<=j;k++)
            b[i][j]=max(b[i][j],b[i-1][k-1]+a[i][k]);
 }  
    int c=-1000000;
    for (int i=f;i<=v;i++)
      if (b[f][i]>c)
        c=b[f][i];
    cout<<c<<endl;   
    print(f,c);
}
void print(int i,int j)
{
  int n;
  if (i>0)
    {
      n=i;
      while (b[i][n]!=j)
      {
        n++;
      } 
      print(i-1,j-a[i][n]);
      cout<<n<<" "; 
    }  
}

```

---


# [IOI 2021] 修改 DNA

## 题目背景

**滥用本题评测将被封号**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 语言提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数

## 题目描述

Grace 是一名生物学家，在新加坡的一个生物信息学公司工作。她的一部分工作是分析不同有机体的 DNA 序列。DNA 序列是包含字符 A、T 和 C 的字符串。注意在本题中，DNA 序列不包含字符 G。

定义一次修改是把 DNA 序列中的两个元素交换位置的操作。例如，通过交换加粗的字符 A 和 C，一次修改可以把 A**C**T**A** 转化为 A**A**T**C**。

两个序列的修改距离是把一个序列转化为另一个序列所用的最少修改次数。如果不能通过修改把一个序列转化为另一个序列，那么这两个序列的修改距离为 $-1$。

Grace 正在分析两个 DNA 序列 $a$ 和 $b$，每个都由 n 个元素组成，下标从 $0$ 到 $n - 1$。你的任务是帮助 Grace 回答以下形式的 $q$ 个问题：子串 $a[x \ldots y]$ 和 $b[x \ldots y]$ 的修改距离是多少？这里，DNA 序列 $s$ 的子串 $s[x \ldots y]$ 定义为 $s$ 的下标从 $x$ 到 $y$（包括 x 和 y）的连续字符序列。也就是说，$s[x \ldots y]$ 是序列 $s[x] s[x + 1] \ldots s[y]$。

## 说明/提示

对于所有数据：

- $1 \le n, q \le 100 \, 000$
- $0 \le x \le y \le n - 1$
- $a$ 和 $b$ 的每个字符都是 A、T 和 C 之⼀

子任务|分值|特殊限制
:-:|:-:|:-:
$1$	|$21$|$y - x \le 2$
$2$	|$22$|	$q \le 500$，$y - x \le 1000$，$a$ 和 $b$ 的每个字符是 A 或 T
$3$	|$13$|	$a$ 和 $b$ 的每个字符是 A 或 T
$4$	|$28$|	$q \le 500$，$y - x \le 1000$
$5$	|$16$|	没有额外的约束条件

## 样例解释

如果评测程序调用 `get_distance(1, 3)`，那么该调用应返回 $a[1 \ldots 3]$ 和 $b[1 \ldots 3]$（也就是序列 TAC 和 CTA）之间的修改距离。通过 $2$ 次修改可以把 TAC 转化为 CTA：TAC $\to$ CAT，然后是 CAT $\to$ CTA。无法通过比 $2$ 次更少的修改完成该转化。

因此，该调用应返回 $2$。

如果评测程序调用 `get_distance(4, 5)`，那么该调用应返回序列 AT 和 TA 之间的修改距离。 通过一次修改可以把 AT 转化为 TA，而且显然至少需要一次。

因此，该调用应返回 $1$。

最后，如果评测程序调用 `get_distance(3, 5)`，由于无法通过修改将序列 CAT 转化为 ATA，因此该调用应返回 $-1$。

## 样例 #1

### 输入

```
6 3
ATACAT
ACTATA
1 3
4 5
3 5```

### 输出

```
2
1
-1```

# 题解

## 作者：wangbinfeng (赞：7)

[![](https://img.shields.io/badge/题目-P10050【IOI2021】修改DNA-green)
![](https://img.shields.io/badge/难度-提高+/省选---blue)
![](https://img.shields.io/badge/考点-前缀和-yellow)
![](https://img.shields.io/badge/题型-交互题-red)](https://www.luogu.com.cn/problem/P10050)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)


------------
这是一道 IOI2021 的题目，不过比较简单。大家不要被其来源吓住了，其实，[这道 IOI 题](https://www.luogu.com.cn/problem/P1216)大家应该都做过了。

放一个官方中文题面：<https://ioi.te.lv/locations/ioi21/contest/day2/DNA/zh_CN.pdf>。

前置知识：
- 前缀和 ~~、生物学 `DNA`（腺嘌呤 `A`、胸腺嘧啶 `T`、胞嘧啶 `C`、鸟嘌呤 `G`）、英语理解能力~~。

言归正传，开始分析。

- $\texttt{Subtask\;1.}$ 每次查询最多只有三个字符，则答案如下：

$$
\text{ans} = \begin{cases}
   -1 &&\text{if}&& 无解（无论怎么交换，都无法做到一一对应，如对应字母数量不同）  \\
   0 &&\text{if}&& 原本就相同  \\
   1 &&\text{if}&& 有且仅有两个字母不同，且交换后两字符串将相同  \\
   2 &&\text{if}&& 三个字母均不同，且交换后两字符串将相同
\end{cases}
$$

- $\texttt{Subtask\;2.}$ 只有两个字母。通过 $\texttt{Subtask\;1}$ 我们可以清晰的发现，每次交换可以修复一个不匹配的情况，因此计算不匹配的数量即可。时间复杂度为 $\Theta \left(qm^2\right)$。此处，$m=y-x+1$，下面同理。
- $\texttt{Subtask\;3.}$ 相较于 $\texttt{Subtask\;2}$ 仅增加了数据范围。因此，可以再 `init()` 函数中预处理出所有的不匹配数量。显然可以使用前缀和。时间复杂度为 $\Theta \left(n+q\right)$。
- $\texttt{Subtask\;4.}$ 较于 $\texttt{Subtask\;3}$ 仅增加了一个字母。先修改两个字母（需要 $1$ 次），时间复杂度为 $\Theta \left(qm^2\right)$，再修改三个字母（需要 $2$ 次），时间复杂度也为 $\Theta \left(qm^2\right)$。故总时间复杂度显然为 $\Theta \left(qm^2\right)$。
- $\texttt{Subtask\;5.\;\&\;Full\;Solution.}$ 相较于 $\texttt{Subtask\;4}$ 仅增加了数据范围，考虑 $\texttt{Subtask\;3}$ 的做法。用前缀和统计不匹配，然后用常数时间复杂度修改即可。时间复杂度为 $\Theta \left(n+q\right)$。

其实 $\texttt{Subtask\;1}$ 的结论可以衍伸，比如字母差异为 $4$ 时仅需要 $3$ 次即可修改完成。不懂为什么数据中没有 `G`。~~我鸟嘌呤这么没牌面吗？~~

------------
代码如下：
```cpp
#include<bits/stdc++.h>
#include<stdexcept>
using namespace std;
//#define int long long
#ifdef int
const int inf=0x7f7f7f7f7f7f7f7f;
#else
const int inf=0x7f7f7f7f;
#endif
int sum[100009][3][3];
inline int bm(const char c) {
	switch(c){
		case 'A':return 0;
		case 'T':return 1;
		case 'C':return 2;
		default:throw("ERROR! The string is wrong!");
	}
}
int n;
void init(string a,string b){
    n=a.size();
    for(int k=1;k<=n;k++){		//注意，这里sum数组下标从1开始，与string不同（为减少特判，防止下标为负的情况） 
        for(int i=0;i<3;i++)for(int j=0;j<3;j++)sum[k][i][j]=sum[k-1][i][j];
        sum[k][bm(a[k-1])][bm(b[k-1])]++;
    }
}
int get_distance(int x,int y){
    int s[3][3],ret=0,t;
    for(int i=0;i<3;i++)for(int j=0;j<3;j++)s[i][j]=sum[y+1][i][j]-sum[x][i][j];
    for(int i=0;i<3;i++)for(int j=i+1;j<3;j++)
        t=min(s[i][j],s[j][i]),ret+=t,s[i][j]-=t,s[j][i]-=t;			//处理所有的不匹配 
    if(s[0][1]!=s[1][2] or s[1][2]!=s[2][0] or s[1][0]!=s[2][1] or s[2][1]!=s[0][2])return -1;		//不存在 
    return ret+2*(s[0][1]+s[1][0]);
}
#ifndef ONLINE_JUDGE
int q,x,y;
string a,b;
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0),cerr.tie(0);
	cin>>n>>q;
	cin>>a>>b;
	init(a,b);
	for(int i=1;i<=q;i++){
		cin>>x>>y;
		cout<<get_distance(x,y)<<endl;
	}
}
#endif
```

---

## 作者：Vct14 (赞：4)

题目链接：[P8521 [IOI2021] 修改 DNA](https://www.luogu.com.cn/problem/P8521)。

~~说句闲话，我最开始做这题的时候这题是 P10050 来着？~~

upd 24/07/09：修改了一处小错误。

------------

科普一下，生物体中常见的碱基有 $5$ 种，分别是腺嘌呤（`A`）、鸟嘌呤（`G`）、胞嘧啶（`C`）、胸腺嘧啶（`T`）和尿嘧啶（`U`），其中碱基 A、G、C 和 T 存在于 DNA 中。注意，本题中 DNA 序列只含有字符 A、T 和 C。

本题虽然是交互题，但实际上是一道传统题。

------------

为了方便，我们把 A、T 和 C 分别替换为 $0,1,2$。

```c++
int change(char c){
    if(c=='A') return 0;
    else if(c=='T') return 1;
    else return 2;
}
```

注意到本题求修改次数的是同一个区间，那么对于任意 $k$，我们需要把 $a_k$ 改为 $b_k$。定义一个区间的的修改矩阵 $s$ 为一个 $3\times3$ 的矩阵，并且 $s_{i,j}$ 为某一个区间内需要将 $i$ 改为 $j$ 的个数（$0\leqslant i,j\leqslant 2$）。

那么我们可以在 `init` 函数中把修改矩阵求出来。这里使用类似前缀和的思路存储。

```c++
void init(string a,string b) {
    int len=a.length();
    For(k,1,len){
        F(i) F(j) S[k][i][j]=S[k-1][i][j];
        S[k][change(a[k-1])][change(b[k-1])]++; // 类似前缀和 
    }
}
```

我们采取这样的思路修改：能两两交换就交换（如样例二），剩下多出来的考虑三个轮换修改。

对于每一组询问，我们先求出这个区间的修改矩阵。然后进行两两交换。此时 $s_{i,j}$ 和 $s_{j,i}$ 中必有一个为 $0$。若 $s_{1,0}$ 为 $0$，则仅当 $s_{0,1}=s_{1,2}=s_{2,0}$ 时，可以将 $0$ 与 $1$ 交换位置，再将 $0$ 与 $2$ 交换位置，交换次数为 $s_{0,1}+s_{2,0}=2\times s_{0,1}$。$s_{0,1}$ 为 $0$ 同理。

```c++
int get_distance(int x,int y){
    int ans=0;
    F(i) F(j) s[i][j]=S[y+1][i][j]-S[x][i][j]; // 求出修改矩阵 
    F(i){
    	For(j,i+1,3){
	        int m=min(s[i][j],s[j][i]);
	        ans+=m;s[i][j]-=m;s[j][i]-=m; // 抵消 
	    }
	}
	// 轮换修改 
	if(s[0][1]!=s[1][2] || s[1][2]!=s[2][0] || s[1][0]!=s[2][1] || s[2][1]!=s[0][2]) return -1; 
	if(s[0][1]!=0) return ans+2*s[0][1];
	else return ans+2*s[1][0];
}
```

代码如下：

```c++
#include<bits/stdc++.h>
using namespace std;

#define For(i,a,b) for(int i=a; i<=b; i++)
#define F(i) For(i,0,2)
int change(char c){if(c=='A'){return 0;}else if(c=='T'){return 1;}else{return 2;}}

int S[100002][3][3];//ATC
int s[3][3];

void init(string a,string b) {
    int len=a.length();
    For(k,1,len){
        F(i) F(j) S[k][i][j]=S[k-1][i][j];
        S[k][change(a[k-1])][change(b[k-1])]++; // 前缀和 
    }
}

int get_distance(int x,int y){
    int ans=0;
    F(i) F(j) s[i][j]=S[y+1][i][j]-S[x][i][j]; // 求出修改矩阵 
    F(i){
    	For(j,i+1,3){
	        int m=min(s[i][j],s[j][i]);
	        ans+=m;s[i][j]-=m;s[j][i]-=m; // 抵消 
	    }
	}
	// 轮换修改 
	if(s[0][1]!=s[1][2] || s[1][2]!=s[2][0] || s[1][0]!=s[2][1] || s[2][1]!=s[0][2]) return -1; 
	if(s[0][1]!=0) return ans+2*s[0][1];
	else return ans+2*s[1][0];
}

/*
int main(){
	int n,q;string a,b;cin>>n>>q>>a>>b;
	init(a,b);
	while(q--){
		int x,y;cin>>x>>y;
		cout<<get_distance(x,y)<<endl;
	}
	return 0;
}
*/
```

---

## 作者：suzhikz (赞：3)

初看神秘题，再看是糖题！

首先，如果对应好的位置我们显然不会去动它，我们只会交换不对应的。

然后比较优秀的形式显然是 A 对 T，T 对 A，这样两个不匹配的只要一次交换就能都对应上。

但是有时候不都是这种形式，有可能会出现一个环，即 A 对 T，T 对 C，C 对 A 这样子，然后我们显然要转化成上一个形式比较优秀，对于每个环，还原这个环需要 2 步，并且没有更优秀的。

因为要恰好对应，所以每个点都在环上，如果不在环上的话就是不能还原。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define db double
#define il inline
using namespace std;
void read(int &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
void read(ll &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
const int N=1e5+5; 
int x[N],y[N];
int n,pre[N][4][4],ch[1145];
void init(string a,string b){
	n=a.size();
	ch['A']=0,ch['C']=1,ch['T']=2;
	for(int i=0;i<n;i++)x[i+1]=ch[a[i]];
	for(int i=0;i<n;i++)y[i+1]=ch[b[i]];
	for(int i=1;i<=n;i++){
		pre[i][x[i]][y[i]]=1;
		for(int j=0;j<=2;j++)for(int k=0;k<=2;k++)pre[i][j][k]+=pre[i-1][j][k];
	}
}
int get_distance(int x,int y){
	int l=x+1,r=y+1,ans=0;
	int tmp[5][5]={0};
	for(int i=0;i<=2;i++)for(int j=0;j<=2;j++)tmp[i][j]=pre[r][i][j]-pre[l-1][i][j];
	for(int i=0;i<=2;i++)for(int j=0;j<=2;j++){
		if(i==j)tmp[i][j]=0;
		else{
			int c=min(tmp[i][j],tmp[j][i]);
			tmp[i][j]-=c;tmp[j][i]-=c;ans+=c;
		}
	}
	for(int i=0;i<=2;i++){
		for(int j=0;j<=2;j++){
			if(i==j)continue;
			int k=3-i-j;
			int c=min(tmp[i][j],min(tmp[j][k],tmp[k][i]));
			tmp[i][j]-=c;tmp[j][k]-=c;tmp[k][i]-=c;
			ans+=c*2;
		}
	}
	for(int i=0;i<=2;i++){
		for(int j=0;j<=2;j++)if(tmp[i][j])return -1;
	}
	return ans;
}
//int main(){
//	int n,q;
//	read(n);read(q);
//	string a,b;cin>>a>>b;init(a,b);
//	while(q--){
//		int l,r;read(l);read(r);
//		cout<<get_distance(l,r)<<endl;
//	}
//	
//	return 0;
//}
```

---

## 作者：Oracynx (赞：2)

# P8521 [IOI2021] 修改 DNA 题解

### 思路分析

~~I AC IOI.~~

下文记 $\texttt{A}$ 为 $1$，$\texttt{T}$ 为 $2$，$\texttt{C}$ 为 $3$。

计算 $3$ 个前缀数组 $sa, sb, sc$。

- $sa_{i, j}$ 为 $a$ 的前 $i$ 位中 $j$ 出现的次数。
- $sb_{i, j}$ 为 $b$ 的前 $i$ 位中 $j$ 出现的次数。
- $sc_{i, x, y}$ 为如果我们需要将 $a$ 的前 $i$ 位转换为 $b$ 所需要的从 $x$ 到 $y$ 的转换次数。

上面的 $3$ 个数组在 `init` 函数中计算得出。

```cpp
void init(std::string _a, std::string _b)
{
    int l = _a.size();
    _a = " " + _a;
    _b = " " + _b;
    for (int i = 1; i <= l; i++)
    {
        a[i] = _a[i] == 'A' ? 1 : _a[i] == 'T' ? 2 : 3;
        b[i] = _b[i] == 'A' ? 1 : _b[i] == 'T' ? 2 : 3;
        for (int x = 1; x <= 3; x++)
        {
            sa[i][x] = sa[i - 1][x];
            sb[i][x] = sb[i - 1][x];
            for (int y = 1; y <= 3; y++)
            {
                sc[i][x][y] = sc[i - 1][x][y];
            }
        }
        sa[i][a[i]]++;
        sb[i][b[i]]++;
        if (a[i] != b[i])
        {
            sc[i][a[i]][b[i]]++;
        }
    }
}
```

记 $s$ 为 $sc_r - sc_{l - 1}$ 即区间内所需要的修改次数。

先判无解。

如果这一段区间中的 $1, 2, 3$ 的出现次数有任何一个不相同，直接返回 $-1$。

否则我们优先考虑两两互换的情况，如：

```
1 2 2 3
2 1 3 2
```

显然，交换 $(1, 2), (3, 4)$ 即可。

即，对于 $1 \le y < x \le 3$
$$
l \gets min(s_{x, y}, s_{y, x}) \\
s_{x, y} \gets s_{x, y} - l \\
s_{y, x} \gets s_{y, x} - l
$$
剩下的只有三个交换的情况，如：

```
1 2 3
2 3 1
```

对于这种情况，其实我们并不需要考虑得太复杂。

显然所有的排列在经过两两互换的过程后只可能有这种操作。

而完成一次三个交换所需要的次数为 $2$。

统计出剩余的仍需交换的次数 $k$，$res \gets res + \dfrac{2}{3}k$ 的即可。

注：这里的简化是建立在我们之前已经判掉无解之上的。

### 代码实现

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <string>
constexpr int MaxN = 1e5 + 5;
int a[MaxN];
int b[MaxN];
int s[5][5];
int sa[MaxN][5];
int sb[MaxN][5];
int sc[MaxN][5][5];
void init(std::string _a, std::string _b)
{
    int l = _a.size();
    _a = " " + _a;
    _b = " " + _b;
    for (int i = 1; i <= l; i++)
    {
        a[i] = _a[i] == 'A' ? 1 : _a[i] == 'T' ? 2 : 3;
        b[i] = _b[i] == 'A' ? 1 : _b[i] == 'T' ? 2 : 3;
        for (int x = 1; x <= 3; x++)
        {
            sa[i][x] = sa[i - 1][x];
            sb[i][x] = sb[i - 1][x];
            for (int y = 1; y <= 3; y++)
            {
                sc[i][x][y] = sc[i - 1][x][y];
            }
        }
        sa[i][a[i]]++;
        sb[i][b[i]]++;
        if (a[i] != b[i])
        {
            sc[i][a[i]][b[i]]++;
        }
    }
}
int get_distance(int l, int r)
{
    l++;
    r++;
    for (int x = 1; x <= 3; x++)
    {
        if (sa[r][x] - sa[l - 1][x] != sb[r][x] - sb[l - 1][x])
        {
            return -1;
        }
    }
    for (int x = 1; x <= 3; x++)
    {
        for (int y = 1; y <= 3; y++)
        {
            s[x][y] = sc[r][x][y] - sc[l - 1][x][y];
        }
    }
    int res = 0;
    for (int x = 1; x <= 3; x++)
    {
        for (int y = 1; y <= x - 1; y++)
        {
            int l = std::min(s[x][y], s[y][x]);
            res += l;
            s[x][y] -= l;
            s[y][x] -= l;
        }
    }
    int k = 0;
    for (int x = 1; x <= 3; x++)
    {
        for (int y = 1; y <= 3; y++)
        {
            k += s[x][y];
        }
    }
    return res + k / 3 * 2;
}
#ifndef ONLINE_JUDGE
int main()
{
    int n, k;
    std::string a, b;
    scanf("%d%d", &n, &k);
    std::cin >> a;
    std::cin >> b;
    init(a, b);
    for (int i = 1; i <= k; i++)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", get_distance(l, r));
    }
    return 0;
}
#endif
```

交互题，不需要实现主函数。

`#ifndef ONLINE_JUDGE` 标记指如果没定义宏 `ONLINE_JUDGE` 的情况就将下面的代码编译，否则跳过。

在洛谷的编译命令中定义了该标记，所以提交后不会有 `main` 函数被编译。

本地则像传统题一样可以编译运行。

---

## 作者：_sin_ (赞：1)

先判断什么时候无解，显然是 $a$ 中某种字符出现次数和 $b$ 中某种字符出现次数不相等，这样才会出现无解的情况。这个直接用前缀和做即可。

考虑将 $a$ 和 $b$ 每一位配对起来。如果一个位置 $a,b$ 的字符相等则不用管它；如果存在两个位置配对起来的结果正好相反，则这两个位置可以直接抵消，对答案的贡献为 $1$。

将上述两种情况的点删去，剩下的序列只能是这两种情况：
$$
k\text{个}\;\;\; k\text{个} \;\;\;k\text{个}\\
\overbrace{A\cdots A}\overbrace{C\cdots C}\overbrace{T\cdots T}\\
\underbrace{T\cdots T} \underbrace{A\cdots A} \underbrace{C\cdots C}\\
k\text{个}\;\;\; k\text{个}\;\;\;k\text{个} \\
$$ 
或者：
$$
k\text{个}\;\;\; k\text{个} \;\;\;k\text{个}\\
\overbrace{T\cdots T} \overbrace{A\cdots A} \overbrace{C\cdots C}\\
\underbrace{A\cdots A}\underbrace{C\cdots C}\underbrace{T\cdots T}\\
k\text{个}\;\;\; k\text{个}\;\;\;k\text{个} \\
$$ 

我们注意到，这样对答案的贡献是 $2k$，直接加进去就行了。

代码：
```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define ll long long
using namespace std;

ll read(){
    ll x=0,f=1;char ch=getchar_unlocked();
    while(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar_unlocked();}
    while('0'<=ch&&ch<='9'){x=x*10+ch-'0';ch=getchar_unlocked();}
    return f*x;
}

const int N = 1e5+5;
int n,q,s[N][5][5],sa[N][5],sb[N][5],kk[305],cp[5][5];

void init(string a,string b){n=a.size();
    memset(kk,0,sizeof(kk));memset(s,0,sizeof(s));
    memset(sa,0,sizeof(sa));memset(sb,0,sizeof(sb));
    kk['A']=0,kk['T']=1,kk['C']=2;a=" "+a,b=" "+b;
    for(int i=1;i<=n;i++){
        for(int x=0;x<3;x++){
            sa[i][x]=sa[i-1][x];sb[i][x]=sb[i-1][x];
            for(int y=0;y<3;y++)s[i][x][y]=s[i-1][x][y];
        }sa[i][kk[a[i]]]++,sb[i][kk[b[i]]]++;
        s[i][kk[a[i]]][kk[b[i]]]++;
    }
    // for(int x=0;x<3;x++){
    //     for(int i=0;i<n;i++)printf("%d ",sa[i][x]);puts("");
    //     for(int i=0;i<n;i++)printf("%d ",sb[i][x]);puts("");puts("");
    // }
}

int get_distance(int l,int r){int ans=0;l++,r++;
    for(int x=0;x<3;x++)for(int y=0;y<3;y++)cp[x][y]=0;
    for(int x=0;x<3;x++){
        // printf("%d %d %d\n",x,sa[r][x]-sa[l-1][x],sb[r][x]-sb[l-1][x]);
        if(sa[r][x]-sa[l-1][x]!=sb[r][x]-sb[l-1][x])return -1;
    }
    for(int x=0;x<3;x++)for(int y=0;y<3;y++)cp[x][y]=s[r][x][y]-s[l-1][x][y];
    for(int x=0;x<3;x++)for(int y=x+1;y<3;y++){
        int mm=min(cp[x][y],cp[y][x]);ans+=mm,cp[x][y]-=mm,cp[y][x]-=mm;
    }int mx=0;for(int x=0;x<3;x++)for(int y=x+1;y<3;y++)if(cp[x][y]>mx)mx=cp[x][y];
    ans+=mx*2;return ans;
}

#ifndef ONLINE_JUDGE
int main(){
    cin>>n>>q;string a,b;
    cin>>a>>b;init(a,b);
    while(q--){
        int l,r;cin>>l>>r;
        cout<<get_distance(l,r)<<endl;
    }
    return 0;
}
#endif
```

---

## 作者：Il1_1_3 (赞：1)

## P8521 题解

[题目传送门](https://www.luogu.com.cn/problem/P8521)

~~2021 年的 IOI 竟然有黄题~~

## 题意
给定两个长度为 $n$ 的字符串 $a,b$，有 $q$ 次询问，每一次要求出子串 $a_x,a_{x+1} \cdots a_y$ 能否通过若干次交换两个字符使得该子串等于 $b_x,b_{x+1} \cdots b_y$。

## 所用算法
前缀和 ~~，生物学~~。

## 思路
拿 $n=3$ 举例：

- 无解：这一对字符串的成分不同，例如 `AAT` 和 `ATT`；
- $0$ 次修改：即两个子串相等；
- $1$ 次修改：即只有一个字符的位置正确，如 `ATC` 和 `ACT`；
- $2$ 次修改：即三个字符的位置均不对。

下文以字符 `A` 为 $0$，`T` 为 $1$，`C` 为 $2$ 为准（即代码中 $f(c)$ 函数）。

首先计算两个前缀和数组 $ta,tb$，$ta$ 代表第 $i$ 种字符在字符串 $a$ 的前 $j$ 项中出现的次数，$tb$ 代表第 $i$ 种字符在字符串 $b$ 的前 $j$ 项中出现的次数。

然后是数组 $t$，$t_{k,i,j}$ 表示将前 $k$ 项转换成另一个字符串的第 $i$ 到 $j$ 项的最小次数，根据前缀和可以将前 $k$ 项推广到任意 $x,y$。

## 注意
因为不用实现 `main` 函数但在本地需要调试，可以使用 `#ifndef ONLINE_JUDGE` 或直接删去主函数解决问题。

#### 主要代码
```cpp
void init(string a,string b)
{
	n=a.size();
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=2;j++)
		{
			ta[j][i]=ta[j][i-1];
			tb[j][i]=tb[j][i-1];
		}
		if(a[i-1]=='A')ta[0][i]++;
		if(b[i-1]=='A')tb[0][i]++;
		if(a[i-1]=='T')ta[1][i]++;
		if(b[i-1]=='T')tb[1][i]++;
		if(a[i-1]=='C')ta[2][i]++;
		if(b[i-1]=='C')tb[2][i]++;
	}
	for(int k=1;k<=n;k++)
	{
		for(int i=0;i<=2;i++)
		{
			for(int j=0;j<=2;j++)
				t[k][i][j]=t[k-1][i][j];
		}
		t[k][f(a[k-1])][f(b[k-1])]++;
	}
}
int get_distance(int x,int y)
{	
	int s[3][3],tt=0,tims=0;
	for(int i=0;i<=2;i++)
		for(int j=0;j<=2;j++)
			s[i][j]=t[y+1][i][j]-t[x][i][j];
	for(int i=0;i<=2;i++)
		for(int j=i+1;j<=2;j++)
		{
			tt=min(s[i][j],s[j][i]);
			tims+=tt;
			s[i][j]-=tt;
			s[j][i]-=tt;
		}
	if(s[0][1]!=s[1][2]||s[1][2]!=s[2][0]||s[1][0]!=s[2][1]||s[2][1]!=s[0][2])
		return -1;
	tims+=(s[0][2]+s[2][0])*2;
	return tims;
}
```

---

## 作者：zk_y (赞：1)

IOI 简单题。

首先，考虑一下什么时候无解，显然是 $a$ 中某个字符的个数和 $b$ 中某个字符的个数不相等，这样才会出现无解的情况。

然后考虑有解的情况，显然，如果两种字符是 $x$ 在 $y$ 的位置上，$y$ 在 $x$ 的位置上，然后交换 $x,y$，这样显然是最优的。

考虑建立一个表格 $now_{i,j}$ 表示现在 $i$ 字符在 $j$ 位置上的情况的个数。

根据上面的贪心，可以将 $now_{i,j}$ 和 $now_{j,i}$ 先抵消把一部分，直到有某个东西为 $0$。

那么最后就可以直接计算了。

又因为是交互题，加上 ``ONLINE_JUDGE`` 的判断就好了。

$code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+100;
int tota[3][N];
int totb[3][N];
int tot[N][3][3];
int mat[N];
#define L(i,j,k) for(int i=j;i<=k;i++)
int n,q;

int getop(char x){
	if(x=='A')return 0;
	if(x=='T')return 1;
	if(x=='C')return 2;
	return 114514;
}

void init(string a,string b){
	n=a.length();
	L(i,1,n){
		L(j,0,2)tota[j][i]=tota[j][i-1],totb[j][i]=totb[j][i-1];
		if(a[i-1]=='A')tota[0][i]++;
		if(a[i-1]=='T')tota[1][i]++;
		if(a[i-1]=='C')tota[2][i]++;
		if(b[i-1]=='A')totb[0][i]++;
		if(b[i-1]=='T')totb[1][i]++;
		if(b[i-1]=='C')totb[2][i]++;
	}
	
	L(i,1,n){
		L(j,0,2)L(k,0,2)tot[i][j][k]=tot[i-1][j][k];
		tot[i][getop(a[i-1])][getop(b[i-1])]++;
	}
	
}

int get_distance(int x,int y){
	L(i,0,2)if(tota[i][y+1]-tota[i][x]!=totb[i][y+1]-totb[i][x])return -1;
	int ans=0,tmp=0;
	int now[3][3];
	L(i,0,2)L(j,0,2)now[i][j]=tot[y+1][i][j]-tot[x][i][j];
	L(i,0,2)L(j,i+1,2)tmp=min(now[i][j],now[j][i]),ans+=tmp,now[i][j]-=tmp,now[j][i]-=tmp;
	return ans+2*(now[0][2]+now[2][0]);
}


#ifndef ONLINE_JUDGE

string a,b;

int main(){
	ios::sync_with_stdio(0);
	
	cin>>n>>q;
	
	cin>>a>>b;
	
	init(a,b);
	
	while(q--){
		int x,y;
		cin>>x>>y;
		cout<<get_distance(x,y)<<'\n';
	}
	
	return 0;
}

#endif
```

---

## 作者：WuMin4 (赞：0)

这么简单的 IOI 题目不多了。

## 思路

考虑对于两个字符串 $s,t$，我们记录下 $s,t$ 中的字符对 $(x,y)$ 的数量，表示 $s_i=x,t_i=y$。由于是交换任意两个字符，所以我们不考虑位置，只考虑数量。因为字符串仅由 `ATC` 构成，所以不同的字符对最多只有 $9$ 种，可以使用前缀和预处理出所有的不同字符对数。

为了使得两个字符串相同，显然需要使得所有字符对中的两个字符都相同。考虑对于两个不同的字符对 $(x,y),(y,x)$，交换后变成 $(x,x),(y,y)$，一次交换可以使两对字符相同，显然最优，所以我们先统计这种情况并处理。

处理完后，对于字符对 $(x,y),(y,x)$，一定有一个字符对的数量为 $0$。当没有不相等的字符对时，输出答案，否则仅当存在 $(x,y),(y,z),(z,x)$ 的字符对且数量均相等不为 $0$ 时才可以处理。设字符对数量均为 $c$，显然操作次数为 $2\times c$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int cnt[3][3][100005],to[128];
void init(string a,string b){
	to['A']=0,to['T']=1,to['C']=2;
	for(int i=0;i<a.length();i++){
		cnt[to[a[i]]][to[b[i]]][i]++;
		for(int s1=0;s1<3;s1++)
			for(int s2=0;s2<3;s2++)
				cnt[s1][s2][i]+=cnt[s1][s2][i-1];
	}
}
int get_distance(int x,int y){
	int c[3][3],res=0,tot=0;
	for(int s1=0;s1<3;s1++)
		for(int s2=0;s2<3;s2++)
			if(s1!=s2)
				c[s1][s2]=cnt[s1][s2][y]-cnt[s1][s2][x-1],tot+=c[s1][s2];
	for(int s1=0;s1<3;s1++)
		for(int xx,s2=s1+1;s2<3;s2++){
			xx=min(c[s1][s2],c[s2][s1]);
			res+=xx,c[s1][s2]-=xx,c[s2][s1]-=xx;
		}
	if(res*2==tot) return res;
	else if(c[0][1]&&c[0][1]==c[1][2]&&c[1][2]==c[2][0])
		res+=c[0][1]*2;
	else if(c[0][2]&&c[0][2]==c[2][1]&&c[2][1]==c[1][0])
		res+=c[0][2]*2;
	else
		return -1;
	return res;
}
```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的思维题。

### 前置知识

- [前缀和~~不会前缀和做什么绿题~~](https://oi.wiki/basic/prefix-sum/)

### 思路

先考虑什么情况无解，如果存在字符在不同的字符串中出现次数不同，那么无解。

我们考虑把 $a$ 和 $b$ 的每个位置上的字符一一匹配，形成 $n$ 个字符对 $(x,y)$，再把 $x = y$ 的字符对删除，接下来删除 $(x,y)$ 与 $(y,x)$，并对答案产生 $1$ 的贡献，操作完之后，字符对会只剩下 $(A,T)$、$(T,C)$、$(C,A)$ 或者 $(T,A)$、$(C,T)$、$(A,C)$，并且三者的数量肯定相等，设它为 $k$，那么会对答案产生 $2k$ 的贡献。

这样的时间复杂度肯定过不了，但是我们可以用前缀和优化，这样时间复杂度只有 $O(n)$ 了。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n,cnt[N][3][3];
int get_id(char c){
	if(c == 'A'){
		return 0;
	}else if(c == 'C'){
		return 1;
	}else{
		return 2;
	}
}
int get_cnt(int l,int r,int c1,int c2){
	return cnt[r][c1][c2] - cnt[l - 1][c1][c2];
}
void init(string a,string b){
	n = a.length();
	a = ' ' + a;
	b = ' ' + b;
	for(int i = 1;i <= n;i ++){
		for(int j = 0;j < 3;j ++){
			for(int k = 0;k < 3;k ++){
				cnt[i][j][k] = cnt[i - 1][j][k];
			}
		}
		cnt[i][get_id(a[i])][get_id(b[i])] ++;
	}
}
int get_distance(int x,int y){
	int l = x + 1,r = y + 1;
	for(int i = 0;i < 3;i ++){
		int col_a = 0,col_b = 0;
		for(int j = 0;j < 3;j ++){
			col_a += get_cnt(l,r,i,j);
			col_b += get_cnt(l,r,j,i);
		}
		if(col_a != col_b){
			return -1;
		}
	}
	int ans = min(get_cnt(l,r,0,1),get_cnt(l,r,1,0)) + 
		min(get_cnt(l,r,0,2),get_cnt(l,r,2,0)) + 
		min(get_cnt(l,r,1,2),get_cnt(l,r,2,1)) + 
		2 * (max(get_cnt(l,r,0,1),get_cnt(l,r,1,0)) - min(get_cnt(l,r,0,1),get_cnt(l,r,1,0)));
	return ans;
}
```

---

## 作者：Purslane (赞：0)

# Solution

~~小萌新竟然能爆切 IOI 签到题，好感动。 TAT~~

这个东西显然要贪心的。如果两个对应位置相同，显然不用动。

如果存在两个下标 $i$ 和 $j$ 满足：

- $S_i \neq T_i$，$S_j \neq T_j$；
- $S_i = T_j$，$S_j=T_i$。

显然对 $(i,j)$ 操作一次是很优的。

在这样操作完后，一定只剩下 $(S_i,T_i) \in \{(A,T),(T,C),(C,A)\}$ 的 $i$，或者只剩下 $(S_i,T_i) \in \{(T,A),(C,T),(A,C)\}$ 的 $i$。

容易发现三者数量应当相同，设为 $t$。显然需要花费 $2t$ 的代价将其复原。

直接使用前缀和计算区间 $(S_i,T_i) = (X,Y)$ 的个数即可。复杂度 $O(n)$。

这是萌新的第 $693$ 篇题解，喜欢的就点个赞吧。 /kel

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10;
int n,pre[MAXN][3][3];
void init(string a,string b) {
	n=a.size();
	map<char,int> mp;
	mp['A']=0,mp['C']=1,mp['T']=2;
	ffor(i,1,n) {
		ffor(j,0,2) ffor(k,0,2) pre[i][j][k]=pre[i-1][j][k];
		pre[i][mp[a[i-1]]][mp[b[i-1]]]++;
	}
	return ;
}
int get_distance(int x,int y) {
	x++,y++;
	ffor(col,0,2) {
		int ca=0,cb=0;
		ffor(j,0,2) ca+=pre[y][col][j]-pre[x-1][col][j],cb+=pre[y][j][col]-pre[x-1][j][col];
		if(ca!=cb) return -1;	
	}
	int ans=min(pre[y][1][0]-pre[x-1][1][0],pre[y][0][1]-pre[x-1][0][1])+min(pre[y][2][0]-pre[x-1][2][0],pre[y][0][2]-pre[x-1][0][2])+min(pre[y][2][1]-pre[x-1][2][1],pre[y][1][2]-pre[x-1][1][2]);
	ans+=2*(max(pre[y][1][0]-pre[x-1][1][0],pre[y][0][1]-pre[x-1][0][1])-min(pre[y][1][0]-pre[x-1][1][0],pre[y][0][1]-pre[x-1][0][1]));
	return ans;
}
```

---


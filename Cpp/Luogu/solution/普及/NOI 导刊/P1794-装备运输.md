# 装备运输

## 题目描述

德国放松对英国的进攻后，把矛头指向了东边——苏联。$1943$ 年初，东线的战斗进行到白热化阶段。据可靠情报，$90$ 余万德国军队在库尔斯克准备发动浩大攻势。因此，朱可夫元帅要求你立即从远东的军工厂运输大量装备支援库尔斯克前线。列车司机告诉你，一趟列车最多可以容纳 $V$ 体积的武器装备，但是你可能不能装满，因为列车承受不了那么大的重量，一趟列车最多可以承载 $G$ 单位的重量。同时，军工厂仓库提供给你一份装备清单，详细记录了每件装备的体积、重量和火力。为了有效支援朱可夫元帅，你要找到一种方案，使得总火力值最大。

## 说明/提示

对于 $100\%$ 的数据，$1\le V, G, N \le 500$，$1 \leq T_i, V_i, G_i \leq 10^9$。

## 样例 #1

### 输入

```
6 5 
4
10 2 2
20 3 2 
40 4 3 
30 3 3 
```

### 输出

```
50
```

# 题解

## 作者：翼德天尊 (赞：50)

### STEP 1 分析题意

首先，这道题告诉你了总体积和总重量，告诉你了每个物品的价值的重量以及体积。这不就是01背包的进阶版吗！

01背包是什么？用数组记录最佳情况，再考虑放与不放的问题。所以这道题虽然多了一个条件，也只是相当与数组要多开一维而已。依然用滚动数组搞定即可。

但是注意：**枚举体积和重量的时候，一定要倒着枚举！因为一个物品只能被放入一次！当然，如果是完全背包的话，是从头枚举的！切记！切记！切记！重要的事情说三遍！**

------------
### STEP 2 AC代码及注释
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int v,g,n,dp[501][501],h[501],t[501],z[501];//v,g,n如题所示，dp数组记录动规结果，第一维记录体积，第二维记录重量，h,t,z三个数组分别记录每个物品的体积重量和火力值 
int main(){
	scanf("%d %d\n%d",&v,&g,&n);
	for (int i=1;i<=n;i++){
		scanf("%d %d %d",&h[i],&t[i],&z[i]);
	}//正常输入
	for (int x=1;x<=n;x++){
		for (int i=v;i>=t[x];i--){
			for (int j=g;j>=z[x];j--){//体积和重量要倒着枚举，防止物品重复放入
				dp[i][j]=max(dp[i-t[x]][j-z[x]]+h[x],dp[i][j]);//动规转移方程
			}
		}
	}
	printf("%d\n",dp[v][g]);//输出当体积和重量为最大值时的火力值最大的结果
	return 0;//好习惯人人养
}
```

------------
### STEP 3 完结撒花！
看了我的题解，如果还有什么不懂的地方，欢迎在评论区留言哦，我会第一时间回复的。如果都懂了，就点个赞纪念一下你的点滴成长吧！

---

## 作者：355_113 (赞：8)

挺简单的0-1背包，看到没题解我就发一个吧。

一般思路是f[i][j][k]，i表示物品编号，j、k分别代表体积和重量，体积和重量还够就放。

滚动数组可以省去i这一维，但是j和k就需要逆序枚举。

自己推一下dp的方向就会明白，逆序能够保证无后效性。

背包问题重要思想：花费多一种，维数加上一

```cpp
#include<bits/stdc++.h> 
using namespace std;
int f[555][555];//其实各500就够
int main(){
    int v,g,n,t,V,G;
    ios::sync_with_stdio(0);
    cin>>v>>g>>n;
    for(int i=0;i<n;++i){
        cin>>t>>V>>G;
        for(int j=v;j>=V;--j){
            for(int k=g;k>=G;--k)//j、k顺序似乎没关系
                f[j][k]=max(f[j][k],f[j-V][k-G]+t);
        }
    }
    cout<<f[v][g];
//    system("pause");
}
```

---

## 作者：ahawzlc (赞：5)

典型的背包问题

2021.4.18 Update: min->max 感谢@CG、GaryH大佬指出错误！

----

本题当中，每样武器只能选一次，即要么选，要么不选。典型的 01 背包，状态转移：

$dp[j]=\max{dp[j-b[i]]+a[i],dp[j]}$

因为有两个限制条件（质量和体积），所以在 01 背包基础上再加一维，空间复杂度$O(n^2)$，时间复杂度$O(n^3)$，数据在500内，可以通过。

状态转移：$dp[j][k]=\max{dp[j-b[i]][k-c[i]]+a[i],dp[j][k]}(1\le i \le n,b[i]\le j \le v,c[i]\le k \le m)(j,k$倒序$)$

倒序当然是为了防止二次选择物品。

``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[505],b[505],c[505],dp[505][505];
int main() {
	int n,m,v;
	cin>>v>>m>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i]>>c[i];
	for(int i=1;i<=n;i++)
		for(int j=v;j>=b[i];j--)
			for(int k=m;k>=c[i];k--)
				dp[j][k]=max(dp[j-b[i]][k-c[i]]+a[i],dp[j][k]);
	cout<<dp[v][m];
	return 0;
}
```

---

## 作者：HPXXZYY (赞：3)

多重背包模板题……

------------
## 01背包

**【题目】：** 您现在有$n$个物体，每个物体有一个体积和价值，现在您还有$1$个背包，容积为$C$，求在物体体积之和$\leq C$的前提下，价值之和**最大**为多少？（每种物体只能选**一次或零次**）

**【思路】：** 我们记$f_{i,j}$表示考虑到第$i$个物体，容积为$j$时的最大价值和。现在考虑某物体$k$，容积为$l$的转移状态（$W_i$表示物体$i$的体积，$C_i$表示$i$的价值）：

$(1)$不选$k$，则$f_{k,l}=f_{k-1,l}$

$(2)$选$k$，那么我们只剩下$l-W_k$的容积，可以选$[1,k-1]$中的所有物体，所以转移状态为：

$$f_{k,l}=f_{k-1,l-W_k}+C_k$$

只需在两者间取较大值即可。

**【优化前代码】：**
```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=C;j++)
		if (j<w[i]) f[i][j]=f[i-1][j];//第i个物体一定不能更新f[i][j]
		else f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+c[i]);//尝试用第i个物体去更新f[i][j]
```

**【优化】：** 以上```dp```的时间复杂度和空间复杂度都是$O(N \times C)$，似乎时间复杂度**无法优化**了，所以我们想想如何优化空间复杂度。

事实上，$f_{i,j}$只和$f_{i-1,k}(1\leq k \leq j \leq C)$有关。所以我们可以用**滚动数组**优化。

滚动数组这东西听着很高大上，其实也很简单，因为对于任意$k,l$，如果满足$1 \leq k < i-1,1 \leq l \leq j$，那么$f_{k,l}$一定不能**直接**更新$f_{i,j}$，既然如此，那我们就干脆把$f_{i,j}$直接压缩成$f_{j}$，不就少了一维了吗？

其实，这不知优化了空间，也在一定程度上优化了时间。为什么？因为二维数组的**随机访问**比一维数组的**随机访问**慢得多！

**【注意】：** 我们发现单纯加入优化而不作任何其他修改的$dp$会```WA```，原因很简单：**不保证**每个元素只选了一次或零次！优化后的 ```01背包``` 对容积的循环必须改为**倒序循环**。

**【优化后代码】：**
```cpp
for(int i=1;i<=n;i++)//枚举考虑到第i个物体
	for(int j=C;j>=w[i];j--)//注意枚举顺序
		f[j]=max(f[j],f[j-w[i]]+c[i]);//这转移是不是非常的简单？
```
为什么这样就对了？因为$W_i>0$，所以对于任意的$j$都有$j-W_i<j$，因为我们使用**倒序循环**，所以在更新$f_j$时，$f_{j-W_i}$时并没有被更新，保存的还是原来的$f_{i-1,j-W_i}$的值，所以就达到了异曲同工的效果，而且把空间复杂度降为了$O(C)$。

------------
## 完全背包

```完全背包``` 和 ```01背包``` 其实很相似，就是每种物体可以选**无限个**。其实代码也很像，只需把 ```01背包``` 中的倒序循环又改会**正序循环**即可了。

**【代码】：**
```cpp
for(int i=1;i<=n;i++)
	for(int j=w[i];j<=C;j++)//又变成正序了
		f[j]=max(f[j],f[j-w[i]]+c[i]);
```
------------
## 二维背包

也就是每个物体有**两个**体积了……

一个体积就一维$dp$，那么两个体积就二维$dp$吧！

事实也就是这样……

解释一下开头的**多重背包**是什么东西。你们可以简单的了解为**不止**一维背包。

**【代码】：**
```cpp
for(int i=1;i<=n;i++)
	for(int j=W1[i];j<=C1;j++)//j和k的枚举顺序因题目是01背包还是完全背包而已，这里以完全背包为例
		for(int k=W2[i];k<=C2;k++)//事实上01背包也只是把j和k改为倒序即可……
			f[j][k]=max(f[j][k],f[j-W1[i]][k-W2[i]]+C[i]);
```

------------
**【本题代码】：**

```cpp
int c,w1,w2,i,j,k,n;
int m1,m2,f[550][550];
int main(){
//	freopen("t1.in","r",stdin);
	scanf("%d%d%d",&m1,&m2,&n);
	for(k=1;k<=n;k++){
		scanf("%d%d%d",&c,&w1,&w2);
		for(i=m1;i>=w1;i--)
		for(j=m2;j>=w2;j--)
		f[i][j]=max(f[i][j],f[i-w1][j-w2]+c);
	}
	cout<<f[m1][m2];
	return 0;
}
```


---

## 作者：zhzzhzzzz (赞：1)

$Update:$修改一点小手误，前面过了QAQ

挺简单想的01背包，每个装备只有一件。其实只要一个 $dp[\space 501 \space][\space 501 \space]\space$存最大的火力值就行了

什么？你问我每件装备的数据还要不要了，要个蛇！

读入的时候直接用变量读数据，因为每件武器都只能选一次，所以前面的最大火力值**一定在前面的状态里**

这样还能快乐的**省空间**

定义状态 $dp[j][k]$ 表示列车剩余体积还有 $j$ 、剩余重量还有 $k$ 的时候的最大火力值。

非常好想的状态转移方程有：

$dp[j][k]=max(dp[j][k],dp[j-v][k-g]+t),$ 

其中 $v,g,t$ 分别表示当前装备的体积、重量、火力值

$\textcolor{green}{AC}$ 黄题数量++

那么 $dp[V][G]$ 存的就是最终的答案了QAQ

AC Code Time：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[501][501];
int main()
{
    int V, G, N;
    cin >> V >> G >> N;
    for (int i = 1; i <= N;i++)
    {
        int t, v, g;
        cin >> t >> v >> g;
        for (int j = V; j >= v;j--)
        {
            for (int k = G; k >= g;k--)
            {
                f[j][k] = max(f[j][k], f[j - v][k - g] + t);
            }
        }
    }
    printf("%d\n", f[V][G]);
    return 0;
}

---

## 作者：Hiraeth (赞：1)

为什么没有人发题解qaq

01模板题 

需要考虑两种因素所以需要三重循环

然后再滚动数组滚掉第一维

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,pv,pg,v[505],g[505],t[505],f[505][505];
int main(){
	scanf("%d%d%d",&pv,&pg,&n);
	for (int i=1;i<=n;i++) scanf("%d%d%d",&t[i],&v[i],&g[i]);
	for (int i=1;i<=n;i++)
		for (int j=pv;j>=0;j--)
			for (int k=pg;k>=0;k--)
	if (j-v[i]>=0&&k-g[i]>=0) f[j][k]=max(f[j][k],f[j-v[i]][k-g[i]]+t[i]);
	printf("%d\n",f[pv][pg]);
	return 0;
} 
```

---

## 作者：Qwdb (赞：0)

# **P1794 装备运输 题解**

# [移步至博客阅读效果更佳](https://qwdb.github.io/post/P1794/)

[题目链接](https://www.luogu.com.cn/problem/P1794)

序言：*做~~水~~一道背包练练手~*
### 1. 入手程序
01背包，三重限制，直接开整~
### 2. 编程思路
唉，说实话，这个题没什么难点，但这儿总不能空着吧?
给个01背包模板吧
```c
for(int i=1;i<=n;i++)
{
	for(int j=v;j>=v[i];j--)
	{
		for(int k=u;k>=u[i];k--)
		{
			//重复限制个数-1次
			//动态转移方程
		}
	}
}
```
### 3. AC代码
```c
//V和G表示最大体积和重量
//N表示仓库有N件装备
//每行3个数hi ti zi表示各装备的火力值、体积和重量
#include<bits/stdc++.h>
using namespace std;
int v,g,n;
int h[505],t[505],z[505];
int dp[505][505];
int main()
{
	cin>>v>>g>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>h[i]>>t[i]>>z[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=v;j>=t[i];j--)
		{
			for(int k=g;k>=z[i];k--)
			{
				dp[j][k]=max(dp[j-t[i]][k-z[i]]+h[i],dp[j][k]);//动态转移方程 
			}
		}
	}
	cout<<dp[v][g]; 
	return 0;
}
```
### 我是千文杜博，记住我呦~~
#### The end

---

## 作者：WKAHPM (赞：0)

一道01背包模板题吧。。。其实就是再增加了一个体积参数

状态转移方程：

$F_{j,k}=max(F_{j-v_{i},k-g_{i}}+t_{i},F_{j,k})$

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int V,G,n;//V和G为最大体积和重量
int t[510],v[510],g[510];
int f[510][510];
int main()
{
	ios::sync_with_stdio(false);
	cin>>V>>G;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>t[i]>>v[i]>>g[i];
	for(int i=1;i<=n;i++)
	  for(int j=V;j>=v[i];j--)
	    for(int k=G;k>=g[i];k--) 
	      f[j][k]=max(f[j-v[i]][k-g[i]]+t[i],f[j][k]);//状态转移方程
	cout<<f[V][G];//f[V][G]即为答案
	return 0;
}

```


---


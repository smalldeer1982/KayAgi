# 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
2 1
1 2 1```

### 输出

```
1```

# 题解

## 作者：Mine_King (赞：177)

- **Upd 2021/3/10:修了一下 $\LaTeX$，并改正了评论中提到的问题。**

大家有没有发现，这题的正解是拓扑+DP……  
反正闲着没事，写篇拓扑玩玩。因为题目中说了

>且当为 $G$ 中的一条边时有 $i < j$。

所以点 $1$ 绝对是一个没有入度的点，而且不会出现环。而这一点正好满足拓扑的要求。但是，题目并不保证只有点 $1$ 是没有入度的。所以要判断其他没有入度的点。而对他们的处理是？也许你一开始会想到加入队列，那你就错了！他们本身是无法到达的点，所以根本不可能会延伸到其他地方，如果加入队列，那么就会导致个别点，甚至所有点的答案错误。那么就是不管他？还是错了！如果不管，那么他们延伸出来的点的入度永远大于 $0$，因为还有那些点。以至于发生和上一种方法一样的错误，甚至使终点无法到达！那么解决方法就是先做一遍 for 循环，找到那些点，再把延伸出来的点的入度 $-1$，如果这些点入读 $-1$ 后又变成了入度为 $0$ 的点，那么再做同样的处理。至于一个点的最长路的转移方程就是：  
$min\{\text{入度1+相应的边},\text{入度2+相应的边……入度n加相应的边}\}$  
和 SPFA、dijkstra 的松弛操作差不多。  
**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,in[1505];//存入度数量
vector<int>g[1505];//存边
vector<int>d[1505];//存边权
queue<int>q;//队列
int v[1505];//存最长路
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int ff,tt,dd;
		cin>>ff>>tt>>dd;
		g[ff].push_back(tt);
		d[ff].push_back(dd);
		in[tt]++;
	}
	for(int i=2;i<=n;i++)
	{
		v[i]=-1e9;
		if(!in[i]) q.push(i);
	}//初始化
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=0;i<g[x].size();i++)
			if(!--in[g[x][i]]) q.push(g[x][i]);
	}
	//废弃其他的入度为0的点。
	q.push(1);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=0;i<g[x].size();i++)
		{
			if(v[g[x][i]]<v[x]+d[x][i]) v[g[x][i]]=v[x]+d[x][i];//松弛
			if(!--in[g[x][i]]) q.push(g[x][i]);//如果入度为0就加入队列
		}
	}
	if(v[n]==-1e9) cout<<"-1";
	else cout<<v[n];//输出结果
	return 0;
}
```
安利[博客](https://www.luogu.org/blog/yhdhg1395754790/)

---

## 作者：vectorxyz (赞：51)

#### 思路
写一种最好理解的方法。

我们建图的时候就把 $w$ 变成 $-w$，然后再跑一遍最短路，因为权值时相反数，所以自然就有了最长路的效果，最后输出的时候再输出答案的相反数即可。

如何最短路就不再赘述，可以看看 [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)。这题不卡 SPFA。

自认为是思路最好理解的一篇了，时间复杂度 $O(NM)$。

#### 代码
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa() //最短路
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, -c); //这里
    }

    int t = spfa();

    if (t == 0x3f3f3f3f) puts("-1");
    else printf("%d\n", -t); //这里

    return 0;
}
```

---

## 作者：doby (赞：24)

既然Bellman-ford能过……

SPFA咋就没个代码呢……

反着搞最短路初始化和松弛就可以了……

另外肯定是单向边，不然就是类似最短路里的负权环一样，直接正无限上去了……

```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n,m,s,x,y,z,out,fh,cnt,top,head[1510],dis[1510];
bool done[1510];
char cc;
deque<int>q;
struct Edge
{
    int to,next,dis;
}e[100010];
int read()//能读负数但是会变慢的读入优化
{
    out=0,fh=1,cc=getchar();
    while((cc<'0'||cc>'9')&&cc!='-'){cc=getchar();}
    if(cc=='-'){fh=-1,cc=getchar();}
    else{out=cc-'0',cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
void add(int x,int y,int z)//增加单向边的操作
{
    cnt++,e[cnt].next=head[x],e[cnt].to=y,e[cnt].dis=z,head[x]=cnt;
}
void SPFA(int s)
{
    for(int i=1;i<=n;i++){dis[i]=-233333333;}
    dis[s]=0,done[s]=1;
    q.push_back(s);
    while(!q.empty())
    {
        x=q.front();
        q.pop_front();
        for(int i=head[x];i;i=e[i].next)
        {
            y=e[i].to;
            if(dis[y]<dis[x]+e[i].dis)
            {
                dis[y]=dis[x]+e[i].dis;
                if(!done[y])
                {
                    done[y]=1;
                    if(!q.empty())
                    {
                        if(dis[y]<dis[q.front()]){q.push_back(y);}
                        else{q.push_front(y);}
                    }
                    else{q.push_back(y);}
                }
            }
        }
        done[x]=0;
    }
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        x=read(),y=read(),z=read();
        add(x,y,z);
    }
    SPFA(1);
    printf("%d",(dis[n]==-233333333?-1:dis[n]));//最后用三目判断一下是否还是初始值就好了……
    return 0;
}
```

---

## 作者：Furina_Saikou (赞：13)

因为是有向无环图，所以跑最短路算法和拓扑排序都可以，我讲讲拓扑排序的做法。

# 思路

首先，统计每个点的入度，将入度为 $0$ 的入队，每次取出一个点，用动规统计能到的点的最大值，并将能到的点的入度减 $1$，若该点的入度变为 $0$，就将其入队。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=114514;
int n,m,head[N],id,ne[N],to[N],w[N],in[N],maxn[N];//in表示入度
void add(int x,int y,int z)//链式前向星，不会的可以用邻接表
{
	to[++id]=y,in[y]++,w[id]=z,ne[id]=head[x],head[x]=id;
}
void topo()
{
	memset(maxn,0x80,sizeof maxn);//初始化一个极小值
	maxn[n]=-1;
	maxn[1]=0;
	queue<int>q;
	q.push(1);
	for(int i=2;i<=n;i++)
	{
		if(!in[i])
		{
			q.push(i);//入度为0入队
		}
	}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=ne[i])
		{
			int v=to[i];
			maxn[v]=max(maxn[u]+w[i],maxn[v]);//统计最大值
			in[v]--;
			if(!in[v])
			{
				q.push(v);
			}
		}
	}
}
signed main()
{
	cin>>n>>m;
	for(int i=1,x,y,w;i<=m;i++)
	{
		cin>>x>>y>>w;
		add(x,y,w); 
	}
	topo();//拓扑
	cout<<maxn[n];
}
```

板子题，适合练手。

---

## 作者：lijingyuanpp (赞：6)

本人也用到了拓扑排序和动态规划的方法。
具体而言，运用拓扑排序将点的坐标存入一个数组中。每到一个点，将其所有出边所连的点的入度减 $1$ （可以理解为删除该点）。如果该点出边所连的点入度被减 $0$ ，那么将该点出边所连的点加入队列，表示作为没有删除条件了的点准备被删除。当一点枚举完所有出边，则将此点放入上述数组中（拓扑排序基本原理）。这样一来，从头至尾遍历该数组时，因为运用拓扑排序，每一个点入边所连的点一定都不在其后面被遍历。读者不难想到，如果让所有会影响某一节点的其他点的值都不再改变，则这个节点也必将在更新它的邻点时不会改变。这就很符合动态规划的无后效性的特点。直白的说，是拓扑排序给一张图提供了天生的符合使用动态规划的遍历顺序，因此考虑将二者结合使用求解最长路。

针对本题而言，唯一难点在于要求从 $1$ 开始的最长路。拓扑排序和动态规划模板是求解全图中到达某点的最长路。核心问题是节点 $1$ 可能不是该路线的起点，或者会有一条路不经过节点 $1$ 而到达 $n$ 点且最长。因此我们考虑能否将节点 $1$ 看作是起点。

我思考的方法是，利用数组 str 存储是否以 $1$ 为起点。遍历图到节点 $1$ 时，将 str 的第一个设为以 $1$ 为起点。如果再后来碰到父节点 str 值为 $1$ 时，则子节点也被认为是以 $1$ 为起点的点。遍历图结束后，只有我们想要进行动态规划的路径上（也就是以 $1$ 为起点能到达的所有路径上， str 都是 $1$ ）。因为拓扑排序处理有向无环图，显然从 str 值为 $1$ 的点开始，不可能到达 str 值为 $0$ 的点。在进行动态规划时，依照拓扑排序的顺序遍历，在 str 值为 $0$ 的点时直接 continue ,让这些点无法给有用路径上更新长度，就实现了将其余路径排除在外，只考虑以 $1$ 为起点的路径上的长度更新。
（分析冗长，原理简单）

另外注意有负权边要初始化动态规划数组。


代码：
```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <cmath>
using namespace std;
int n,m;
int x,y,z;
//对于这个有向无环图，每一条先驱路径都会有改变该点最长路的可能性,拓扑排序保证后面的所有的先驱点都已经发更新完成不会再对他造成影响

struct node{
	int v, w, next;
}e[500005];
int head[100005], cnt;

int tmp = 0; 
int in[100005];//入度 
int px[100050];//存排序编号，便于dp
int dp[100005];//表示1到i点的最长路径 
bool str[100005];//记录所有由以1为起点的点 

void add(int u, int v, int w){
	cnt++;
	e[cnt].v = v;
	e[cnt].w = w; 
	e[cnt].next = head[u];
	head[u] = cnt;
}

queue<int> q;

void tuopu(){
	for(int i = 1; i <= n; i ++){
		if(in[i] == 0){
			q.push(i); 
		}
	}
	while(q.empty() == 0){
		int u = q.front();
		q.pop();
		if(u == 1){ 
			str[u] = 1;
		}
		for(int i = head[u]; i != 0; i = e[i].next){
			int v = e[i].v;
			in[v] --;
			if(str[u] == 1){ 
				str[v] = 1;
			}//可以推广 
			if(in[v] == 0){
				q.push(v);
			}
		}
		px[++tmp] = u;
	}
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= m; i ++){
		cin >> x >> y >> z;
		add(x, y, z);
		in[y] ++;
	}
	
	tuopu();
	
	for(int i = 1; i <= n; i ++){
		dp[i] = -1e9;
	}
	dp[1] = 0;
	
	for(int i = 1; i <= n; i ++){
		int u = px[i];
		if(str[u] == 0){//不在1路上，不用更新来自这条路的路径长度 
			continue;
		}
		//每一个点按照顺序，对其周围的点进行更新，排序目的是使得所有点更新别的点时不会再被更新
		for(int j = head[u]; j != 0; j = e[j].next){
			int v = e[j].v;
			dp[v] = max(dp[v], dp[u] + e[j].w);
		}
	}
	
	if(n == 1){
		cout << 0 << endl;
		return 0;
	} 
	if(dp[n] != -1e9){
		cout << dp[n] << endl;
	}else{
		cout << -1 << endl;
	}
	return 0;
}

---

## 作者：AutumnKite (赞：6)

#Pascal的SPFA竟然没有？！我来补一发#

其实这题是个很裸很裸的比最短路模板还要裸的“最长路”啦！我用了SPFA算法，把松弛操作的符号改一下就行了，然后把极大值改成极小值，就这样AC了！本来以为需要考虑很多东西......

然而楼下的大佬们都用的是那种非指针伪链表的形式存的边，我这个蒟蒻只会用数组模拟邻接表......也是一种方法嘛，为我这种蒟蒻准备的。

献上我那丑陋的代码：

```cpp
var
  n,m,i,j,h,t,x,y,z,oo:longint;
  a,c:array[0..2000,0..5000]of longint;
  dis:array[0..2000]of longint;
  b:array[0..2000]of boolean;
  q:array[0..5000000]of longint;
procedure spfa();
var
  i:longint;
begin
  for i:=1 to n do
    begin dis[i]:=oo; b[i]:=false; end;
  h:=0; t:=1; q[t]:=1; dis[1]:=0; b[1]:=true; //起点入队列
  while h<t do 
    begin
      inc(h); x:=q[h]; b[x]:=false;
      for i:=1 to a[x,0] do 
        begin
          y:=a[x,i];
          if dis[x]+c[x,i]<dis[y] then continue; //求的是最长路，那么如果小于，就不用更新，直接continue
          dis[y]:=c[x,i]+dis[x]; //更新
          if b[y] then continue; //已经在队列中了就continue
          inc(t); q[t]:=y; b[y]:=true; //加入队列
        end;
    end;
end;
begin
  oo:=maxlongint shr 2*(-1); //极小值
  readln(n,m);
  for i:=1 to n do 
    for j:=1 to n do 
      c[i,j]:=oo; //c数组对应a数组，存储权值，数组模拟邻接表
  for i:=1 to m do 
    begin
      readln(x,y,z);
      inc(a[x,0]); a[x,a[x,0]]:=y; c[x,a[x,0]]:=z; //a[x,0]存储出度
    end;
  spfa();
  if dis[n]=oo then write(-1) else write(dis[n]); //走不到输出-1
end.

```

---

## 作者：ECNUAT_LZX (赞：5)

相信大家看到这道题的第一反应，就是这道最长路和最短路基本没有什么区别，于是我们可以直接套上spfa板子，建**负**边，在最后输出时在转为**正**的就可以了。（注意点:在设初始值的时候不能改成负极大值，因为如果这么改，那我们的松弛操作就会收到影响。）

(小技巧:
```memset```
函数是按照字节对内存块进行初始化，所以不能用它将 数组出初始化为 $0$ 和 $-1$ 之外的其他值（除非该值高字节和低字节相同）。所以设置极大值时推荐使用 ```fill```。)

### code:
```
#include <bits/stdc++.h>

#define int long long
#define PII pair<int,int>
#define MP make_pair
#define INF LONG_LONG_MAX
using namespace std;
int n, m;
vector<PII > g[1510];//个人喜好用 vector 建图，但更推荐邻接表
int dis[1510];
bool vis[1510];

void spfa(int s){
    queue<int> q;
    q.push(s);//把初始点加入队列
    fill(dis+1,dis+1+n,INF);//因为一开始所有点都到不了，所以初始化为INF,不能设置为-INF!!!
    dis[s]=0;//自己到自己肯定距离为0
    while(!q.empty()){
        int u=q.front();//从队列里取出第一个元素
        q.pop();
        for(int i=0;i<g[u].size();i++){
            int v=g[u][i].first,w=g[u][i].second;
            if(dis[v]>dis[u]+w){//松弛操作
                dis[v]=dis[u]+w;
                q.push(v);
            }
            //如果能松弛成功，那么松弛，把松弛成功的目标点放入队列
        }
    }
}

signed main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back(MP(v, -w));//建负边
    }
    spfa(1);
    if (dis[n] == INF)cout << -1;//不存在
    else cout << -dis[n];//转换符号
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：5)

我们可以使用 SPFA 解决这道题目。

我们容易发现，当我们跑完最短路后，一定会有 $d_v \ge d_u + w(v \in \text{son}(u))$，那么我们只要把最短路的判断条件改为 $d_v$ 是否小于 $d_u + w$ 即可。

SPFA 最坏时间复杂度为 $O(nm)$，足以通过此题了。

参考代码如下：

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int n, m;
vector < pair <int, int> > e[1504];
queue <int> q;
long long dis[1504];
bool vis[1504];
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v, w;
		cin >> u >> v >> w;
		e[u].emplace_back(v, w);
	}
	q.push(1);
	for (int i = 1; i <= n; i++) {
		dis[i] = -1145141919810;
	}
	dis[1] = 0;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for (auto [v, w] : e[u]) {
			if (dis[v] < dis[u] + w) {
				dis[v] = dis[u] + w;
				if (!vis[v]) {
					vis[v] = 1;
					q.push(v);	
				}
			}
		}
	}
	cout << (dis[n] == -1145141919810 ? -1 : dis[n]);
}
```

---

## 作者：睿屿青衫 (赞：5)

#终于一遍过了，时隔n月第一次！

##几乎裸的spfa，微处理一下

###建负边，照着spfa跑（当然memset那里还要正的0x7f，为什么呢？若是负的，想想，肯定wa），那么你的最短路跑出来的结果是负值最小的，再乘-1，不就是正边最大的吗？

废话不多说上代码，一看就会（为什么我要多贴代码？每个人风格都不同，可能你看别人的不太懂看我的会容易理解）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 50010
using namespace std;
struct EDGE
{
    int next;
    int to;
    int co;
}edge[maxn*5];
int qr,head[maxn],team[maxn],dis[maxn],exist[maxn];
int n,m,flag;
void add(int from,int to,int co)
{
    edge[++qr].next=head[from];
    edge[qr].to=to;
    edge[qr].co=co;
    head[from]=qr;
}
void spfa()
{
    memset(dis,0x7f,sizeof(dis));
    memset(exist,0,sizeof(exist));
    int h=0,t=1;
    dis[1]=0;exist[1]=1;team[1]=1;
    while(h<t)
    {
        h++;
        int u=team[h];
        exist[u]=0;
        for(int i=head[u];i!=0;i=edge[i].next)
         {
             int v=edge[i].to;
             if(dis[v]>dis[u]+edge[i].co)
              {
                  dis[v]=dis[u]+edge[i].co;
                  if(!exist[v])
                   {
                       exist[v]=1;
                       t++;
                       team[t]=v;
                   }
                if(v==n)
                 flag=1;
              }
         }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;++i)
     {
         int a,b,v;
         cin>>a>>b>>v;
         add(a,b,-v);
     }
    spfa();
    if(!flag) printf("-1");
     else printf("%d",-dis[n]);
    return 0;
}
```

---


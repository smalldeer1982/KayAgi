# 影像之结构化特征

## 题目描述

在影像比对中，有一种方法是利用影像中的边缘（edge）信息，计算每个边缘资讯中具有代表性的结构化特征，以作为比对两张影像是否相似的判断标准。Water-filling 方法是从每个边缘图的一个端点开始，绕着相连的边缘点走并依序编号。若走到某一步时，遇到一个以上不同的连接点，则分成不同路径同时继续走，直到没有任何连接点为止。如果一个点和另一个点为上下左右相邻，就称为连接。

例如，在图 $1$ 的影像中包含三个边缘图，每个边缘图由一些互相连接的边缘点构成。图中以黑色的方块代表边缘点，白色的方块代表背景。在 Water-filling 方法中，首先，从第一行（row）开始，由左至右，由上至下，先找到第一个黑点并编号为 $1$。接着，找 $1$ 的下一个尚未编号的连接点并编号为 $2$。依此方法继续往下一个点前进依次编号。在编号 $6$ 的点之后有两个尚未编号的连接点，此时，则分为两条路线，并同时编号为 $7$ 继续往下走。当走到没有任何的相连点时，则结束现有边缘图的编号，并继续对影像中的其它边缘图编号。走完图 $1$ 所有边缘图后所得到的编号如图 $2$ 所示。所以，走完这三个边缘图所需要的步数分别为 $12$、 $7$ 及 $3$；所以，$12$、$7$ 及 $3$ 可以作为代表此张影像的结构化特征。请注意：位于斜对角上的两点不能算做连接，如：

![](https://cdn.luogu.com.cn/upload/pic/704.png)

请写一个程序计算每个影像中，以 Water-filling 方法走完其中所有的边缘图后，将每个边缘图需走的步数依走访的顺序列出。

## 样例 #1

### 输入

```
10 
0000000000 
0011110000 
0000010000 
0011111000 
0010110100 
0010010110 
0011110010 
0100010010 
0100000110 
0100000000 ```

### 输出

```
3 
3 
7 
12```

# 题解

## 作者：AFOier (赞：6)

这道题是典型的广搜题，然而我在考试的时候用了深搜。。。于是7个点RE，30分。。。（并不知道为什么啊）

题目描述里有个小bug，就是其实寻找第一个点的时候应该从上到下然后再从左到右，而不是从左到右再从上到下，正确的做法应该是像(1,1);(1,2);(1,3);......(2,1);(2,2);(2,3)......的。

接着是思路，说实在最下面那位大佬的解释我看不懂。。。我们找到一个未被覆盖的边缘点后（开始全部都未覆盖），将它的答案设为1，并覆盖这个点，将其放入广搜队列队头，然后寻找它的上下左右四个点，如果它不超过矩阵边缘并且为边缘点，而且还没被覆盖，那么我们就把这个点放入广搜队列的队尾，将它的答案设为队头的答案+1，然后覆盖这个点（这个很重要，如果不直接在插入队尾时覆盖它的话就会有7个点TLE，只能得到30分）。然后一直搜到无路可走，那么这个边缘图需走的步数便是广搜队列中最后一个点的答案。

关于存储答案，楼下zrz大佬用的是优先队列，因为他觉得“sort可能不太好用”，然而我就用了sort，具体就是每次找到一个边缘图，将答案数+1（我用了ans[0]），然后将当前答案存入这个数组中的第ans[0]个中，用sort排序，最后就可以输出了。

如果看不懂前面的就看看代码解释吧，如果还是看不懂的话，欢迎私信向我提问。

（注：有些变量是原来用来备用的，可能在程序里没用）

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <iomanip>
#include <cstdlib>
using namespace std;
int n,a[1001][1001],ans1,ans[1000001],pc[1001][1001],p[1001][1001];
//a数组用来存储整个矩阵，pc是用来判重的，p是答案
int x[1000001],y[1000001],head,tail,xx,yy;
int fx[4]={1,-1,0,0};
int fy[4]={0,0,-1,1};
char f;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        p[i][j]=2333333;
        cin>>f;
        if(f=='1')a[i][j]=1;
        if(f=='0')a[i][j]=0;
```
}//输入和初始化
```cpp
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(a[i][j]==0)continue;
        if(pc[i][j]==1)continue;
        head=0;tail=1;x[1]=i;y[1]=j;p[i][j]=1;
        while(head<tail)
        {
            head++;
            pc[x[head]][y[head]]=1;
            for(int i=0;i<=3;i++)
            {
                xx=x[head]+fx[i];
                yy=y[head]+fy[i];
                if(xx<1||yy<1||xx>n||yy>n||pc[xx][yy]==1||a[xx][yy]==0)continue;
                tail++;
                x[tail]=xx;
                y[tail]=yy;
                p[xx][yy]=p[x[head]][y[head]]+1;
                pc[xx][yy]=1;
            }
//广搜
        }
        ans[0]++;
        ans[ans[0]]=p[x[tail]][y[tail]];//记录答案
    }
    sort(ans+1,ans+(ans[0])+1);
    cout<<ans[0]<<endl;
    for(int i=1;i<=ans[0];i++)
    cout<<ans[i]<<endl;//输出
    return 0;
}
```

---

## 作者：Emily666 (赞：2)

这题看到样例是逐层扩展的时候也知道是广搜呀~


------------
#### 具体思路
1. 读入；
2. 遍历所有点，如果这个点既没有标记过也不是 $0$，就广搜一下；
3. 广搜的时候，用 $vis$ 数组记录这个点的编号，同时还可以起到标记的作用。~~是一个节省空间的好方法~~。广搜函数的返回值类型可以为 int，方便返回这一边缘图的最大编号，放进专存答案的 vector 数组 $ans$ 里；
4. 给 $ans$ 数组排序，输出 $ans$ 数组的大小和里面的元素。

#### 代码
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
int n;
char a[1001][1001];//影像
int vis[1001][1001];//标记数组
vector<int>ans;//答案
struct node{
    int x,y;
    node(int ax=0,int ay=0){//构造函数
        x=ax,y=ay;
    }
};
queue<node>q;
int bfs(int x,int y){//广搜（模板）
    q.push(node(x,y));
    vis[x][y]=1;//左上角的点编号为 1
    int maxx=1;
    int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
    while(!q.empty()){
        node o=q.front();
        q.pop();
        for(int i=0;i<4;i++){
            int nx=o.x+dx[i],ny=o.y+dy[i];
            if(nx>=0&&nx<n&&ny>=0&&ny<n&&a[nx][ny]=='1'&&!vis[nx][ny]){
                vis[nx][ny]=vis[o.x][o.y]+1;//集记录与标记于一体
                maxx=max(maxx,vis[nx][ny]);//更新最大编号
                q.push(node(nx,ny));
            }
        }
    }
    return maxx;
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            cin>>a[i][j];
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(!vis[i][j]&&a[i][j]!='0') ans.push_back(bfs(i,j));//记录答案
        }
    }
    sort(ans.begin(),ans.end());//排序
    cout<<ans.size()<<endl;
    for(int i=0;i<ans.size();i++){
        cout<<ans[i]<<endl;
    }//输出
    return 0;
}
```
小彩蛋：此题的 Water-filling 方法就是洪水漫溉算法。

---

## 作者：zhengrunzhe (赞：2)

一道相当简单的广搜

这里提供C++STL队列算法

因为并不想知道有多少个答案，用sort可能不太好用

所以我用stl优先队列存答案，不用预估空间

```cpp
#include<queue>
#include<cstdio>
using namespace std;
const int N=1002; //多开一点防越界 
int n,i,j,k,xr[4]={-1,0,1,0},yr[4]={0,1,0,-1}; //四个方向数组(按顺序上下左右) 
char c[N][N];
bool f[N][N];
struct dot{int x,y,num;};  //每个点上的坐标和填充的数字
priority_queue<int,vector<int>,greater<int> >ans;  //用优先队列来做最后的sort 
int main()
{
    scanf("%d",&n);
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++)
            scanf(" %c",&c[i][j]),
            c[i][j]-=48;  //转换为01比较方便 
    for (j=1;j<=n;j++)
        for (i=1;i<=n;i++)
            if (c[i][j]&&!f[i][j])
            {
                int nowans=1;
                queue<dot>q;
                q.push((dot){i,j,1});
                while (q.size())
                {
                    int x=q.front().x,
                        y=q.front().y,
                        pos=q.front().num+1;
                    q.pop();f[x][y]=1;
                    for (k=0;k<4;k++)
                    {
                        int a=x+xr[k],b=y+yr[k];
                        if (c[a][b]&&!f[a][b])
                            q.push((dot){a,b,pos}),nowans=pos,
                            f[a][b]=1;
                    }
                }
                ans.push(nowans);
            }
    printf("%d\n",ans.size());
    while (ans.size())
        printf("%d\n",ans.top()),ans.pop();
    return 0;
}
```

---

## 作者：peixiaorui (赞：1)

## 题意
题目可以抽象化判断图内有多少个联通块并按照升序输出各个联通块内 BFS 最远的距离。
## 思路
这是一道简单的广搜板题。每一次从左到右，从上到下找到一个没搜过的联通块，然后跑 BFS，直到无路可走，此时的走距离就是答案了，把它存下来。最后排序输出即可。（存储与排序过程可用优先队列代替。）
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
#define ll long long
const int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
struct node{
	int x,y,z;//x,y表示坐标，z表示已经走的距离
};
int n;
bool maps[1010][1010],vis[1010][1010];//maps存图，vis表示是否访问过
int ans[1000100],tot=0;//ans存储每个联通块BFS的最远距离
void bfs(int sx,int sy){
	queue<node> q;
	q.push({sx,sy,1});
	vis[sx][sy]=1;
	while(!q.empty()){
		int x=q.front().x,y=q.front().y,z=q.front().z;
		q.pop();
		ans[tot]=max(ans[tot],z);//更新最远距离
		fo(i,0,3){
			int nx=x+dx[i],ny=y+dy[i];
			if(nx<1||ny<1||nx>n||ny>n)continue;
			if(vis[nx][ny]||!maps[nx][ny])continue;
			vis[nx][ny]=1;
			q.push({nx,ny,z+1});//将下一个点加入队列
		}
	}
}
int main(){
	cin>>n;
	fo(i,1,n)fo(j,1,n){
		char ch;cin>>ch;
		maps[i][j]=(ch=='1');//char读入单个字符，转化为bool存图
	}
	fo(i,1,n)fo(j,1,n){
		if(vis[i][j]||!maps[i][j])continue;
		tot++;
		bfs(i,j);//找到一个没有搜过的点并BFS
	}
	sort(ans+1,ans+tot+1);
	cout<<tot<<endl;
	fo(i,1,tot)cout<<ans[i]<<endl;//排序并输出
	return 0;
}
```


---

## 作者：small_stone (赞：1)

一道广搜板子题，瞬间 A 掉。

这道题很简单，先找到未被标记的黑点，将边缘图数量加一，再从那个点开始广搜，广搜时将经过的黑点标记并求出边缘图需走的步数，加入答案列表。

最后只需将答案列表排个序，输出边缘图数量和每个边缘图需走的步数即可。

献上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans[500005],pos=0,cnt=0,dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
char m[1005][1005];
bool vis[1005][1005];
struct node{
	long long x,y,num;
};
void bfs(long long x,long long y) {
	long long maxn=0;
	queue<node> q;
	q.push({x,y,1});
	vis[x][y]=true;
	while (!q.empty()) {
		auto cur=q.front();
		q.pop();
		maxn=max(maxn,cur.num);
		for (long long i=0;i<4;i++) {
			long long tx=cur.x+dir[i][0],ty=cur.y+dir[i][1];
			if (tx>0&&tx<=n&&ty>0&&ty<=n&&m[tx][ty]=='1'&&!vis[tx][ty]) {
				q.push({tx,ty,cur.num+1});
				vis[tx][ty]=true;
			}
		}
	}
	ans[++pos]=maxn;
}
int main() {
	cin>>n;
	for (long long i=1;i<=n;i++) {
		for (long long j=1;j<=n;j++) {
			cin>>m[i][j];
		}
	}
	for (long long i=1;i<=n;i++) {
		for (long long j=1;j<=n;j++) {
			if (!vis[i][j]&&m[i][j]=='1') {
				bfs(i,j);
				cnt++;
			}
		}
	}
	sort(ans+1,ans+pos+1);
	cout<<cnt<<endl;
	for (long long i=1;i<=pos;i++) cout<<ans[i]<<endl;
	return 0;
}
//用时：466ms
//内存：4.40MB
```

---

## 作者：Genius_Star (赞：1)

### 题意描述：
给出一个正方形的影像，需要计算每个边缘图需走的步数，以 Water-filling 方法走完其中所有的边缘点后。

### 思路分析：
~~额，又是一道模板题……~~

为了解决这个问题，我们可以使用广度优先搜索（BFS）算法。

首先，遍历整个影像，找到未访问过的边缘点。

对于每个未访问过的边缘点，开始执行 BFS 操作。

具体的 BFS 操作如下：

1. 创建一个队列，用于存储待访问的边缘点。

2. 将当前未访问的边缘点加入队列中，并标记为已访问。

3. 初始化步数为 $0$。

4. 当队列不为空时，执行以下步骤：

5. 从队列中取出一个边缘点，并将步数加 $1$。

6. 检查该边缘点的上、下、左、右四个方向是否有连接的边缘点。

7. 如果存在连接的边缘点且该点还未被访问过，将其加入队列中，并标记为已访问。

8. 当队列为空时，说明当前边缘图已经遍历完成，将步数保存下来。

9. 继续遍历下一个未访问过的边缘点，重复步骤 $2 \to5$。

对所有边缘图的步数进行排序，并输出结果。

该算法时间复杂度为 $O(n^2)$。

### 完整代码：
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;

const int flag[4][2]={{0,1},{1,0},{-1,0},{0,-1}};
int n,head,tail,tot;
int map[1005][1005],ans[1000005];
bool vis[1005][1005];
char ch;
struct point
{
    int x,y,z;
} q[1000005];

bool check(int x,int y)
{
    if (x<1||y<1||x>n||y>n||map[x][y]==0||vis[x][y]) 
	  return false; else return true;
}

void find(int x,int y)
{
    tail++;
    vis[x][y]=true;
    q[tail].x=x;q[tail].y=y;q[tail].z=q[head].z+1;
}

int bfs(int x,int y)
{
    head=0;tail=1;
    q[1].x=x;q[1].y=y;q[1].z=1;vis[x][y]=true;
    while (head<tail)
    {
        head++;
        int xx=q[head].x,yy=q[head].y;
        for (int i=0;i<4;i++) if (check(xx+flag[i][0],yy+flag[i][1])) find(xx+flag[i][0],yy+flag[i][1]);
    }
    return q[tail].z;
}

void qsort(int l,int r)
{
    int i=l,j=r,mid=ans[rand()%(r-l+1)+l],t;
    do{
        while (ans[i]<mid) i++;
        while (ans[j]>mid) j--;
        if (i<=j) {
            t=ans[i];ans[i]=ans[j];ans[j]=t;
            i++;j--;
        }
    } while (i<=j);
    if (i<r) qsort(i,r);
    if (l<j) qsort(l,j);
}

int main()
{
    memset(vis,false,sizeof(vis));
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++) {ch=getchar();while (ch!='1'&&ch!='0') ch=getchar();map[i][j]=ch-48;}
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++) if (map[i][j]==1&&!vis[i][j]) ans[++tot]=bfs(i,j);
    qsort(1,tot);
    printf("%d\n",tot);
    for (int i=1;i<=tot;i++) printf("%d\n",ans[i]);
    return 0;
}
```

手写一个快排（随机中位数），就当练练手啦！

---

## 作者：arrow_king (赞：1)

BFS 模板题。

## 思路

枚举每个节点，如果当前节点是黑点并且没被访问过，那么以这个点为起点进行四联通的广搜，队列结构体里存 $3$ 个值，$x,y$（坐标），还有 $t$，表示被访问的时间戳。访问到一个节点，判断是否在格子内，点是否为黑点，是否没被访问过，如果全是，则入队，时间戳加一。

遍历答案取 $t$ 的最大值。将广搜得到的最大值丢进一个小根堆（优先队列）里，最后按照次序输出就结束了。

时间复杂度 $\mathcal{O}\left(n^2\right)$。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int fx[]={1,-1,0,0};
const int fy[]={0,0,1,-1};		//四联通
struct node {		//队列结构体
	int x,y,t;
	node() {
	}
	node(int a,int b,int c) {
		x=a,y=b,t=c;
	}
};
queue<node> q;
priority_queue<int,vector<int>,greater<int> > pq;		//小根堆
int n;
bool vis[1005][1005];
char c[1005][1005];
bool check(int x,int y) {
	return (x>=1)&&(x<=n)&&(y>=1)&&(y<=n)&&(c[x][y]=='1')&&(!vis[x][y]);		//判断函数
}
int bfs(int x,int y) {
	while(!q.empty()) q.pop();
	node a,b;
	int ans=1;
	a=node(x,y,1);
	q.push(a);
	while(!q.empty()) {
		a=q.front();
		q.pop();
		ans=max(ans,a.t);		//取得答案
		for(int i=0;i<4;i++) {		//进行扩展
			int tx=a.x+fx[i],ty=a.y+fy[i],now=a.t+1;
			if(check(tx,ty)) {
				b=node(tx,ty,now);
				vis[tx][ty]=1;		//标记
				q.push(b);
			}
		}
	}
	return ans;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>c[i][j];
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n;j++) {
			if(!vis[i][j]&&c[i][j]=='1') {
				vis[i][j]=1;		//标记起始点
				pq.push(bfs(i,j));
			}
		}
	}
	printf("%d\n",pq.size());
	while(!pq.empty()) {
		printf("%d\n",pq.top());		//输出答案
		pq.pop();
	}
	return 0;
}
```

---

## 作者：dingshengyang (赞：1)

就这个 BFS 水题，我竟然想了很久都没有明白我为什么 AC……

第一，记录地图。使用字符地图 `maps`（不要问我为什么不用 `map`，会和 STL 的容器冲突）

第二，找到黑点。暴力就可以。

第三，开始广搜。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char maps[1005][1005];
bool vis[1005][1005];
int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};//4 个方向的 x 和 y の增量
struct node{
	int x;
	int y;
	int step; 
}s;//英语好就没问题吧……step 是当前步数
int bfs(){
	int ans = 1;
	queue<node> que;
	que.push(s);
	while(que.empty()==false){//队列非空
		node now = que.front();
		que.pop();
		ans = max(ans,now.step);//就这里
        /*
        我实在搞不懂这和放在下面的 for 循环里面有什么区别，一个 AC，一个 WA
        */
		for(int i = 0;i < 4;i ++){
			int tx = now.x + dir[i][0];
			int ty = now.y + dir[i][1];
			//printf("check-x=%d y=%d step=%d\n",tx,ty,now.step+1);
			if(tx<0||ty<0||tx>=n||ty>=n)//越界
				continue;
			if(vis[tx][ty]||maps[tx][ty]=='0')//走过
				continue;
			vis[tx][ty] = 1;//标记为走过
			que.push({tx,ty,now.step+1});
         //ans = max(ans,now.step+1);//参见上面
			//printf("push-x=%d y=%d step=%d\n",tx,ty,now.step+1);
		}
	}
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i = 0;i < n;i ++){
		scanf("%s",maps[i]); //方便又省事，scanf大法好
	}
	vector<int> ans;//存答案
	for(int i = 0;i < n;i ++){
		for(int j = 0;j < n;j ++){
			if(!vis[i][j]&&maps[i][j]=='1'){//找黑点（独立的）
				s = {i,j,1};vis[i][j] = 1;//记录起点、已经走过
				ans.push_back(bfs());//开搜
			}
		}
	}
	printf("%d\n",ans.size());//不解释
	sort(ans.begin(),ans.end());//排序
	for(int i = 0;i < ans.size();i ++){
		printf("%d\n",ans[i]);//不解释
	}
	return 0;
}
```

---

## 作者：gryql (赞：1)

是一个用来练宽搜的典型好题。你可以通过它搞懂宽搜的原理，搞懂深搜于宽搜的区别。


记录每次宽搜有多少次入队，记录一共有多少次入队。


输出入队次数的降序排列即可。

```delphi

(
type ss=record
    x,y,z:longint;
    end;

const con:array[1..2,1..4] of longint=((1,-1,0,0),(0,0,-1,1));

var a:array[0..1010,0..1010] of longint;
    f:array[0..1000000] of ss;
    b:array[0..1000000] of longint;
    n,i,sum,j:longint;

procedure init;
var ch:char;
begin
    fillchar(a,sizeof(a),0);
    readln(n);
    for i:=1 to n do
        begin
            for j:=1 to n do
                begin
                    read(ch);
                    if ch='1' then a[i,j]:=1;
                end;
            readln;
        end;
end;

procedure sort(l,r:longint);
var i,j,x,y:longint;
begin
    i:=l;j:=r;x:=b[(l+r) div 2];
    repeat
        while b[i]<x do inc(i);
        while b[j]>x do dec(j);
        if i<=j then
            begin
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                dec(j);
            end;
    until i>j;
    if l<j then sort(l,j);
    if i<r then sort(i,r);
end;

procedure bfs(x,y:longint);
var i,xx,yy,head,tail:longint;
begin
    head:=0;tail:=1;
    f[1].x:=x;f[1].y:=y;f[1].z:=1;
    a[x,y]:=0;
    while head<tail do
        begin
            inc(head);
            for i:=1 to 4 do
                begin
                    xx:=f[head].x+con[1,i];
                    yy:=f[head].y+con[2,i];
                    if a[xx,yy]=1 then
                        begin
                            inc(tail);
                            f[tail].x:=xx;
                            f[tail].y:=yy;
                            f[tail].z:=f[head].z+1;
                            a[xx,yy]:=0;
                        end;
                end;
        end;
    inc(sum);
    b[sum]:=f[head].z;
end;

begin
    assign(input,'graph.in');
    assign(output,'graph.out');
    reset(input);
    rewrite(output);
    init;
    for i:=1 to n do
        for j:=1 to n do
            if a[j,i]=1 then
                bfs(j,i);
    sort(1,sum);
    writeln(sum);
    for i:=1 to sum do
        writeln(b[i]);
    close(input);
    close(output); 
end.)

```

---


# 遗址

## 题目描述

很久很久以前有一座寺庙，从上往下看寺庙的形状正好是一个正方形，由 $4$ 个角上竖立的圆柱搭建而成。现在圆柱都倒塌了，只在地上留下圆形的痕迹，可是现在地上有很多这样的痕迹，专家说一定是最大的那个。

写一个程序，给出圆柱的坐标，找出由 $4$ 个圆柱构成的最大的正方形，因为这就是寺庙的位置，要求计算出最大的面积。注意正方形的边不一定平行于坐标轴。

例如图有 $10$ 根柱子，其中 $(4,2),\allowbreak(5,2),\allowbreak(5,3),\allowbreak(4,3)$ 可以形成一个正方形，$(1,1),\allowbreak(4,0),\allowbreak(5,3),\allowbreak(2,4)$ 也可以，后者是其中最大的，面积为 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjic0frl.png)


## 说明/提示


【数据范围】

$30\%$ 满足：$1\leq N \leq100$。

$60\%$ 满足：$1\leq N \leq500$。

$100\%$ 满足：$1\leq N \leq3000$。


## 样例 #1

### 输入

```
10
9 4
4 3
1 1
4 2
2 4
5 8
4 0
5 3
0 5
5 2
```

### 输出

```
10```

# 题解

## 作者：沉石鱼惊旋 (赞：17)

### 前言

CSP-J 模拟赛教练放的一道原题，赛时 AC 了听同学说洛谷有，回来写题解。

### 题目思路

#### 如何找到正方形的四个顶点

最简单的最容易思考到的方法：$\mathcal O(n^4)$ 或 $\mathcal O(n^3)$ 枚举四个顶点。

但由于 $n\leq3000$，肯定超时，复杂度肯定要控制在 $\mathcal O(n^2)$ 左右。

$\mathcal O(n^2)$ 意味着枚举两个点，我们来观察一下这两个点与另外两个点的位置关系。

![](https://s1.ax1x.com/2022/10/04/xleygH.png)

如图所示，我们将左上顶点定为 $i$，左下顶点对应 $j$，那么可以发现如下关系：

1. 标红段为 $i$ 与 $j$ 的横坐标差，正好为左下顶点与右下顶点的纵坐标之差。

1. 标蓝段为 $i$ 与 $j$ 的纵坐标差，正好为左下顶点与右下顶点的横坐标之差。

如此，我们即可仅仅通过两个点推出其余两个点的坐标。

#### 如何求面积

前置知识：勾股定理 $a^2+b^2=c^2$。

![](https://s1.ax1x.com/2022/10/04/xlmFq1.png)

把连接 $i$ 和 $j$ 的虚线以及红蓝两线当做一个直角三角形，我们把蓝线想成 $a$，红线想成 $b$，那么虚线长度即正方形的边长，即为 $\sqrt{a^2+b^2}$。再根据正方形面积公式，正方形面积为 $\sqrt{a^2+b^2}\times \sqrt{a^2+b^2}=a^2+b^2$。 

### 完整代码

```cpp
#include<bits/stdc++.h>
#define max(a,b) a>b?a:b
using namespace std;
bool f[5020][5020];
int x[3020];
int y[3020];
int n,m;
int main()
{
//	freopen("ruin.in","r",stdin);
//	freopen("ruin.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",x+i,y+i);
		f[x[i]][y[i]]=1;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			
			int a=x[i]-x[j];
			int b=y[i]-y[j];
			int Ax=x[i]-b;
			int Bx=x[j]-b;
			int Ay=y[i]+a;
			int By=y[j]+a;	
            if(Ax<1||Ax>5000||Bx<1||Bx>5000||Ay<1||Ay>5000||By<1||By>5000)continue;
			if(f[Ax][Ay]&&f[Bx][By])
			{
				ans=max(ans,a*a+b*b);
			}
		}
	}
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：顾z (赞：8)


## %%%%[troubler](https://www.luogu.org/space/show?uid=88089)

**原作者troubler亲笔.**

~~他没实名~~

这道题一看就很水~~难~~

好吧 ，听我一本正经地胡说八道

首先看到这道题以后， 点的个数 < 3000 ,于是很明显的想到了 O(N ^ 2)  的枚举

于是， 我们可以每两个点都建一条边 ， 然后去找正方形

~~易知，~~在平面直角坐标系中一条边仅能扩展出两个正方形
（不信你可以试试 ， 下面有图）（证明：一条直线将平面分割成两部分，一边各一个），
于是我们只要枚举边 ， 再去找正方形就好了，如果存在 ， 就计算面积 ，总的去一个MAX即可

看图(看不清的放大看)：
![](https://i.loli.net/2018/09/06/5b90a021ca5b5.png)

这一部分的代码在 check 函数里面， 一一对应地看会找到规律 ；

```cpp
ll check(ll xx , ll yy , ll zx , ll zy )
{
    ll cx = xx - zx , cy = yy - zy ;
    if( pd(xx + cy , yy - cx) && mmp[xx + cy][yy - cx] )
        if( pd(zx + cy , zy - cx) && mmp[zx + cy][zy - cx] )
            return cx * cx + cy * cy ; 
    if( pd(xx - cy , yy + cx) && mmp[xx - cy][yy + cx] )
        if( pd(zx - cy , zy + cx) && mmp[zx - cy][zy + cx] )
            return cx * cx + cy * cy ; 
    return 0 ;
}
```
这个函数是用来找正方形的，然后剩下的就很简单了

贴上高清代码
(还有注释 ， 很详尽)
：

```cpp
#include<iostream>
#include<cstdio>
#define ll int 
#define E 3007
using namespace std ;
ll n , ans ;
ll x[E] , y[E] ;
bool mmp[E << 1][E << 1] ;
ll read() 
{ 
    ll s = 0 ; char ch ; 
    while(!isdigit(ch = getchar())) ;
    for(s = ch - '0' ; isdigit(ch = getchar()) ; (s *= 10 ) += ch - '0') ;
    return s ;
}
bool pd(ll uu , ll vv)   // 判断 当前点 有没有出界
{
    if(uu < 0 || uu > 5000)return 0 ;
    if(vv < 0 || vv > 5000)return 0 ;
    return 1 ;
}
ll check(ll xx , ll yy , ll zx , ll zy ) // 用我们在图中找到的规律寻找正方形
{
    ll cx = xx - zx , cy = yy - zy ;
    if( pd(xx + cy , yy - cx) && mmp[xx + cy][yy - cx] )   // 其实mmp 也可以写在pd函数里，判断当前坐标是否存在 点
        if( pd(zx + cy , zy - cx) && mmp[zx + cy][zy - cx] )
            return cx * cx + cy * cy ;           // 如果在第一个时就成立 ， 直接返回就好 ， 因为就算第二个也成立，面积也是一样的
    if( pd(xx - cy , yy + cx) && mmp[xx - cy][yy + cx] )
        if( pd(zx - cy , zy + cx) && mmp[zx - cy][zy + cx] )
            return cx * cx + cy * cy ;           // 面积计算方法有多种证明方法 ， 比较直观的就是 sqrt(cx*cx + cy*cy）^2 ;
    return 0 ;            // 没找到 ， 返回零
}
int main()
{
    n = read() ;
    for(int i = 1;i <= n; i ++)
    {
        x[i] = read() ; y[i] = read() ;
        mmp[x[i]][y[i]] = 1 ;
    }
    for(int i = 1 ; i <= n ; i ++)
        for(int j = 1; j < i ; j ++ )
            ans = max( ans , check(x[i] , y[i] , x[j] , y[j] ) ) ;    // 对答案求最大值
    cout<< ans <<endl;
    return 0 ;
}
```

---

## 作者：Drifterming (赞：6)

/\*
meet-in-the-middle 思想。

因为最多会有3000个点，所以枚举四个点O(n^3)或枚举四个点O(n^4)的效率肯定行不通，所以我们只枚举两个点。

将每个点按横纵坐标从小到大排序。

因为是正方形，所以确定了两个点之后，另外的两个点只有三种情况。

! ![](https://cdn.luogu.com.cn/upload/pic/12501.png) (https://cdn.luogu.com.cn/upload/pic/12501.png)

如果i和j横坐标相同，则正方形与坐标轴平行，

如果x不同，

如果p[i]在p[j]的下边，则向右下斜，如果在上边，则向右上斜。

    
如果向右下斜，那么另外两个点,

        x3=(x1+(y2-y1)),y3=(y1-(x2-x1)) 

        x4=(x2+(y2-y1)),y4=(y2-(x2-x1))

如果向右上斜，那么另外两个点,

         x3=(x1+(y2-y1)),y3=(y1+(x2-x1)) 

        x4=(x2+(y2-y1)),y4=(y2+(x2-x1))

如果正方形与坐标轴平行，那么x1==x2,用上面两个式子做就可以。

    
而且我们只需要考虑这两个点的连线做边的情况，不用考虑做对角线的情况，

因为这条对角线一定在之前被别的点当做边判过了。

    
如果两个点的纵坐标的差值比横坐标的差值小，则不用进行判断，

因为如果有这种情况，那么在这两个点之间一定会有第三个点，

所以这两个点一定在之前被判断过了。

\*/




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int N=5005;
int n,ans;
struct Pillar
{
    int x,y;
    bool operator < (Pillar a) const
    {
        if(x==a.x)
            return y<a.y;
        return x<a.x;
    }
}p[N];
bool map[N][N];
int read()
{
    char c=getchar();int num=0;
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
        p[i].x=read(),p[i].y=read(),
        map[p[i].x][p[i].y]=1;
    sort(p+1,p+n+1);
    int xx,yy,a,b,aa,bb;
    for(int i=1;i<n;++i)
        for(int j=i+1;j<=n;++j)
        {
            xx=abs(p[j].x-p[i].x),yy=abs(p[j].y-p[i].y);    //计算坐标差值 
            if(yy<xx)
                continue;
            a=p[i].x+yy,aa=p[j].x+yy;
            if(a<0||a>N||aa<0||aa>N)    //判断是否越界 
                continue;
            if(p[i].y<p[j].y)    //向右下斜 
            {
                b=p[i].y-xx,bb=p[j].y-xx;
                if(b<0||b>N||bb<0||bb>N);
                if(map[a][b]&&map[aa][bb])
                    ans=max(ans,xx*xx+yy*yy);
            }
            else if(p[i].y>p[j].y)    //向右上斜 
            {
                b=p[i].y+xx,bb=p[j].y+xx;
                if(b<0||b>N||bb<0||bb>N)    //判断是否越界 
                    continue;
                if(map[a][b]&&map[aa][bb])
                    ans=max(ans,xx*xx+yy*yy);
            }
        }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：NobodyThere (赞：5)

- 2021.8.17. update：将代码中 `j` 的左范围从 `1` 改成了 `i + 1`。

~~突然发现这道题还可以发题解就过来水了。~~

### 思路

这道题的数据范围是 $n \leq 3000$，所以需用复杂度 $\operatorname{O}(n^2)$ 的算法。

这样很容易想到一种方法：枚举其中两个点的位置，然后算出最大的面积。

也就是说，需要利用两个点的坐标确定另外两个点的坐标以判断是否存在这样的正方形，然后再算出正方形的面积。

关键在于：**如何确定正方形并求出另外两个点的坐标？**

两点可以确定一条直线，但确定边的位置的话会有两种情况，正方形可能在邻边两侧。这样做虽说完全可以，但还是麻烦了一些。

而两个点之间的连线可能是正方形的边，也有可能是对角线。于是我们可以想到，可以**确定正方形的对角线**，即确定对角的位置，由于对称性，两个正方形重合，于是我们可以认为确定了一个正方形。

**接下来就是推坐标的计算公式。**

直接求坐标似乎有点难度，于是我们可以作一个边与 $x,y$ 轴平行的正方形辅助计算坐标，如下图。

![这是图片，看不了吗？](https://cdn.luogu.com.cn/upload/image_hosting/04wpmrq0.png)

于是我们用坐标差求出辅助的正方形的边长，以及上面某些线段的长度，由于这些线段与 $x,y$ 轴平行，即可以由此算出另外两个点的坐标，公式可见图片。

但不仅有这一种作图方式的可能。

**如果是其他方向的话，这里的公式仍然适用，只不过某些长度带的是负值。**

数据范围是 $x_i,y_i \leq 5000$，可以直接开一个 bool 数组记录是否存在该点。

于是我们可以根据公式算出另两点的位置，并判断是否存在该两点。

**于是判断完后，若符合条件，则只需算出正方形的面积。**

这里确定了对角线，则可以求出对角线的长度 $|l|=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$。

那么正方形的面积即为 $\dfrac{|l|^2}{2}=\dfrac{(x_2-x_1)^2+(y_2-y_1)^2}{2}$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, x[3333], y[3333], ans;
bool vis[23333][23333]; // 记录是否有该点

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d%d", &x[i], &y[i]);
        vis[x[i]][y[i]] = 1;
    }
    for(int i = 1; i < n; i++)
    {
        for(int j = i + 1; j <= n; j++)
        {
            int s = x[i] + y[i] + x[j] + y[j]; // 求和，化简一下代码
            if(s & 1) continue; // 如果和是奇数，则根据公式，另外两点不在整点，可以直接舍去
            else s >>= 1;
            int x1 = s - y[j], y1 = s - x[i], x2 = s - y[i], y2 = s - x[j]; // 套公式
            if(x1 >= 0 && y1 >= 0 && x2 >= 0 && y2 >= 0 && vis[x1][y1] && vis[x2][y2]) // 记得判边界
                ans = max(ans, (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) >> 1); // 如果有这个点，更新答案为原面积与该面积的最大值
        }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：顾z (赞：5)

题目描述--> [P1959 遗址_NOI导刊2009普及（6）](https://www.luogu.org/problemnew/show/P1959)

## 广告： [安利blog](https://www.luogu.org/blog/RPdreamer/#)

## 普通方法分析：

因为题目要求是**找最大正方形**~~(如果是长方形更麻烦.~~

讲真,题目不难,耗时间!

根据题目要求,我们要找的是正方形.

我们可以**根据已知两点去判断其他两点是否存在**

然后就到了~~画图课~~讲解法的时候.

下面所有的**dely代表纵坐标差值,delx代表横坐标差值.**

(记得**在输入的时候,标记圆柱坐标**.

当我们枚举的两个点所在直线平行于x轴或y轴的时候↓.

**直线两侧均可能有正方形**

(即**横坐标差值为0**或**纵坐标差值为0**的时候.)
![](https://i.loli.net/2018/09/06/5b907f73e5d87.png)

纵坐标相同的话,加减横坐标差值即可.

这时只需要**判断其他位置点是否存在**即可.

### 我们的难点在于如何判断两个点是倾斜的情况.

容易发现一个将一个倾斜正方形围起来之后,四个三角形是相等的. 像这样↓
![](https://i.loli.net/2018/09/06/5b9080d67ca2b.png)

很明显全等吧!~~证明过程略~~

然后我们需要**考虑的是两个点所在直线斜率是正还是负**的问题

(亲测只考虑一种情况,不能AC此题.)

``求斜率的公式： k=Δy/Δx``

**分母不能为0!**

然后我们又开始画图 emmm 

**斜率为负**有两种情况.我们可以画图如下↓
![](https://i.loli.net/2018/09/06/5b90a49775949.png)

**斜率为正**.同样有两种情况如下↓
![](https://i.loli.net/2018/09/06/5b909ec9c8eef.png)

按照图片去写代码即可.

--------------------代码---------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9' and s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,x[30008],y[30008];
bool res[6008][6008];
int ans;
IL int dis(int a,int b){return abs(a-b);}
IL bool ok(int x,int y)
{
	if(x<0 || y<0 || x>5000 || y>5000 || !res[x][y])return false;
	return true;
}
IL void search(int px,int py,int nx,int ny)
{
	int delx=dis(px,nx),dely=dis(py,ny);
	if(delx==0)
	{
		if(ok(px+dely,py) && ok(nx+dely,ny))
			ans=std::max(ans,dely*dely);
		else if(ok(px-dely,py) && ok(nx-dely,ny))
			ans=std::max(ans,dely*dely);
	}
	else if(dely==0)
	{
		if(ok(px,py+delx) && ok(nx,ny+delx))
			 ans=std::max(ans,delx*delx);
		else if(ok(px,py-delx) && ok(nx,ny-delx))
			ans=std::max(ans,delx*delx);
	}
	else if(((ny-py)/(nx-px))<0 && nx-px!=0)
	{
		if(ok(px+dely,py-delx) && ok(nx-dely,ny-delx))
			ans=std::max(delx*delx+dely*dely,ans);
		else if(ok(px+dely,py+delx) && ok(nx+dely,ny+delx))
			ans=std::max(delx*delx+dely*dely,ans);
	}
	else if(((ny-py)/(nx-px))>0 && nx-px!=0)
	{
		if(ok(px+dely,py-delx) && ok(nx+dely,ny-delx))
			ans=std::max(delx*delx+dely*dely,ans);
		else if(ok(px-dely,py+delx) && ok(nx-dely,ny+delx))
			ans=std::max(delx*delx+dely*dely,ans);
	}
}
int main(void)
{
	in(n);
	for(RI i=1;i<=n;i++)
		in(x[i]),in(y[i]),res[x[i]][y[i]]=true;
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=n;j++)
			if(i!=j)search(x[i],y[i],x[j],y[j]);
	printf("%d",ans);
}
```
如果**RE的话记得判边界**,还要**判断是否有标记**.

可能会有些麻烦,但个人感觉较好理解.

## 更简单的方法 

通过我们的画图.(如果你不知道请向上看图 qwq

我们很容易发现

**新点的横坐标,只与dely有关.**

**新点的纵坐标,只与delx有关.**

**无论直线如何摆放都是如此.**

且对应坐标为一个加一个减.

因此我们可以精简代码成下面这样：

--------------------代码--------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9' and s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,x[30008],y[30008];
bool res[6008][6008];
int ans;
IL int dis(int a,int b){return abs(a-b);}
IL bool ok(int x,int y)
{
	if(x<0 || y<0 || x>5000 || y>5000 || !res[x][y])return false;
	return true;
}
IL void search(int px,int py,int nx,int ny)
{
	int delx=dis(px,nx),dely=dis(py,ny);
	if(ok(px+dely,py-delx) &&ok(nx+dely,ny-delx))
		ans=std::max(ans,delx*delx+dely*dely);
	else if(ok(px-dely,py+delx) && ok(nx-dely,ny+delx))
		ans=std::max(ans,delx*delx+dely*dely);
     //感觉少考虑了斜率为负的那一种情况,但的确是可以AC的.
     /*
     我们也可以加上判断斜率为负的情况.
    else if(ok(px+dely,py+delx) && ok(nx+dely,ny+delx))
		ans=std::max(ans,delx*delx+dely*dely);
	else if(ok(px-dely,py-delx) && ok(nx-dely,ny-delx))
		ans=std::max(ans,delx*delx+dely*dely);
     难道数据水?
     */
}
int main(void)
{
	in(n);
	for(RI i=1;i<=n;i++)
		in(x[i]),in(y[i]),res[x[i]][y[i]]=true;
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=n;j++)
			if(i!=j)search(x[i],y[i],x[j],y[j]);
	printf("%d",ans);
}
```
里面的``delx*delx+dely*dely`` 是**勾股定理**的内容,就不用我多说了吧.

~~**(逃**~~

---

## 作者：蒟蒻本人 (赞：4)

# 主要就是找正方形！！！
这个题主要就是找正方形，正方形确定了，这道题就直接枚举就可以AC了，具体看代码就知道了；我们可以知道如果枚举对角线，然后
枚举的两个点分别为(x1,y1),(x2,y2)。
则另外两点为((x1+x2+y1−y2/2,(y1+y2−x1+x22)/2),((x1+x2−y1+y2)/2,(y1+y2+x1−x2)/2)。
那么后面就很简单了；
//本来用哈希表（本蒟蒻不会手写哈希表于是就用的map），然后就t了4个点，然后想读入优化卡过去的，结果。。。没成功；
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
   int x=0,k=1;
   char c=getchar();
   while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
   while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c-48);c=getchar();}
   return x*k;
 }
int x[3001],y[3001],n,ans=0;
bool vis[10001][10001];
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		x[i]=read();y[i]=read();
		vis[x[i]][y[i]]=1;
	}
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
	{
	          int xx=x[i]+x[j]-y[i]+y[j],yy=y[i]+y[j]+x[i]-x[j],xxx=x[i]+x[j]+y[i]-y[j],yyy=y[i]+y[j]-x[i]+x[j];//枚举对角线上的点就好；
                    if (xx/2>5000 || yy/2>5000 || xxx/2>5000 || yyy/2>5000 ||xx/2<0 || yy/2<0 || xxx/2<0 || yyy/2<0 )//判断边界 
                    continue;
                    if(vis[xx/2][yy/2]&&vis[xxx/2][yyy/2])
		{
		int mian=((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))>>1;
		ans=max(ans,mian);//更新面积最大值
		}
	}
	printf("%d",ans);
}
```
### 求管理通过，好不容易写个题解

---

## 作者：_Luminous (赞：3)

说在前面的废话：这题被老师前几天用来做上机考试的第二题，蒟蒻当场爆零 ~~（其实是10分，不过跟爆零没区别）~~ ，现在想想不就是个超级简单题。（ ~~蒟蒻大型丢人现场~~


------------

### · 题意


------------
给出n个同一平面上的点，找出任意四个点组成的最大的正方形面积。

### · 解题思路 & 方法


------------

首先我们考虑最朴素的方法，O（n^4）暴力枚举，但是n≤3000，必然超时。因此我们继续往下细想，突然脑子里出现一个点——
```
正方形的定义：有一组邻边相等，并且有一个角是直角的平行四边形称为正方形，又称正四边形。

——摘自百度百科
```
以上~~翻译成人话~~提取关键信息就是：正方形四条边**均相等**。发现什么了吗？只要求出一条边的长度就能求出接下来几条边的范围了对不对？

因此我们只用枚举2个点，这样就绝对不会超时了。

首先在读入的时候就把每个点的下标用vis数组标记为true，这样枚举出两个点之后，方便判断另外两个点是否存在。还有别忘了判断是否越界。

```cpp
读入+初始化
for(int i=1;i<=n;i++){
	scanf("%d%d",&a[i].x,&a[i].y);
	vis[a[i].x][a[i].y]=true;
}
```
```cpp
判断另外两个点是否满足要求
bool check(int i,int j,int x,int y){
	int nx=i-x,ny=j-y;
	if(i+ny>=0 && j-nx>=0 && x+ny>=0 && y-nx>=0 && i+ny<=5000 && x+ny<=5000 && j-nx<=5000 && y-nx<=5000)
		if(vis[i+ny][j-nx] && vis[x+ny][y-nx])
			return true;
	return false;
}
```
然后就是计算正方形面积了，大家肯定瞬间就想到套[勾股定理](https://baike.baidu.com/item/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86/91499?fr=aladdin)求出面积，但其实把问题简化后，我们要求的就是斜边长度本就是正方形的边长，因此直接算出a²+b²的值即可。
```cpp
int sum=(a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y);
ans=max(ans,sum);
```

### · Code


------------
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
inline int max(int a,int b){return a>b?a:b;}
int n,ans;
bool vis[5005][5005];
struct node{
	int x,y;
}a[3005];
bool check(int i,int j,int x,int y){
	int nx=i-x,ny=j-y;
	if(i+ny>=0 && j-nx>=0 && x+ny>=0 && y-nx>=0 && i+ny<=5000 && x+ny<=5000 && j-nx<=5000 && y-nx<=5000)
		if(vis[i+ny][j-nx] && vis[x+ny][y-nx])
			return true;
	return false;
}
int main(){
//	freopen("ruin.in","r",stdin);
//	freopen("ruin.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		vis[a[i].x][a[i].y]=true;
	}
	for(int i=1;i<n;i++)
		for(int j=i+1;j<=n;j++)
			if(check(a[i].x,a[i].y,a[j].x,a[j].y)){
				int sum=(a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y);
				ans=max(ans,sum);
			}
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：ljc20020730 (赞：3)

这是一个有图片的题解，生动形象。

在初中，我们学过一个很经典的题目叫K字形

模型化为：

 ![](https://cdn.luogu.com.cn/upload/pic/5151.png) 

简单证明：

∵∠BCE=90°，

∴∠ACB+∠DCE=90°．

∵∠A=90°，

∴∠ACB+∠B=90°，

∴∠DCE=∠B．

∵∠A=∠D，

∴△ABC∽△DCE；

当然我们AC=BF和AB=BE就可以出全等了

可以尝试一下，我们假设把中间ABE?变成正方形，

那么他的四周就有4个全等的三角形了，

（例子）

 ![](https://cdn.luogu.com.cn/upload/pic/5153.png) 

（例子）

如例子，涂色的四个三角形是全等的。

对于(2,4)(5,3)(4,0)(1,1)

我们不难发现他们之间的关系：

假设不知道(4,0)(1,1)还能推出吗？

可以：

1=abs(3-4) 1=abs(3-4)

 4=1+(5-2)  0=1-abs(4-3)

定义已知的坐标为(x[i],y[i])＆(x[j],y[j])可以求出构成如图例的图形的

另外两个点的坐标(x1,y1)＆(x2,y2)：

```cpp
 x1:=abs(y[i]-y[j])+x[i];
 y1:=abs(x[i]-x[j])+y[i];
 x2:=abs(y[i]-y[j])+x[j];
 y2:=abs(x[i]-x[j])+y[j];
```
所以本题只要遍历两个点，判断得出两个点是否给定即可
而对于100%的数据n<=3000不会超时！

还是给出程序：

```cpp
var n,i,j,max,s,p,x1,x2,y1,y2:longint;
    d:real;
    x,y:array[1..5000]of longint;
    u:array[0..5000,0..5000]of boolean;
begin
 readln(n);
 fillchar(u,sizeof(u),false);
 for i:=1 to n do begin
 readln(x[i],y[i]);
 u[x[i],y[i]]:=true;
 end;
 for i:=1 to n do
  for j:=1 to n do begin
   x1:=abs(y[i]-y[j])+x[i];
   y1:=abs(x[i]-x[j])+y[i];
   x2:=abs(y[i]-y[j])+x[j];
   y2:=abs(x[i]-x[j])+y[j];
   if (x1<=5000)and(x2<=5000)and(y1<=5000)and(y2<=5000)then begin
    s:=sqr(x[i]-x[j])+sqr(y[i]-y[j]);
    if u[x1,y1]and u[x2,y2] then
     if max<s then max:=s;
   end;
  end;
  writeln(max);
end.
```

---

## 作者：Linyize257 (赞：2)

### [传送](https://www.luogu.com.cn/problem/P1959)

这题其实大家也明白，我们要做的就只有一件事——将遍历四个点降低到遍历少一点的点。

![图](https://s1.328888.xyz/2022/08/17/3F2R7.png)

怎么优化？我们可以观察一下，就能发现，欸，似乎我们可以只用枚举两个点就行了！只要我们把两个点的行都加上两个点的列差，两个点的列都减去行差，就分别为另外两个点了；或者我们把两个点的行都减去两个点的列差，两个点的列都加上行差，就是为为另外两个点。

在锁定了点后，就判下是否存在这两个点，都存在，就更新面积(要用上勾股定理 ， $a^2+b^2=c^2$ )。

注意，不能用哈希表，应为我就是因用了哈希表才TLE很多很多遍得。

~~当我不用哈希表 A 了后，我都快想砸电脑了（要文明哦)。~~

$code$

```cpp
#include<iostream>
#include<map>
using namespace std;
struct lyz{
	int x,y; 
}a[5005]; 
int n,lenx,leny;
int maxn=0;
int vis[5005][5005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		vis[a[i].x][a[i].y]=1;
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			if(i!=j){
				lenx=(a[i].x>=a[j].x?a[i].x-a[j].x:a[j].x-a[i].x);
				leny=(a[i].y>=a[j].y?a[i].y-a[j].y:a[j].y-a[i].y);
				if(a[j].y-lenx>=0&&a[j].x+leny<=5000&&a[i].y-lenx>=0&&a[i].x+leny<=5000){
					if(vis[a[i].x+leny][a[i].y-lenx]&&vis[a[j].x+leny][a[j].y-lenx]){
						maxn=(maxn>=(lenx*lenx+leny*leny)?maxn:(lenx*lenx+leny*leny));
					}	
				}
				if(a[j].y+lenx<=5000&&a[j].x-leny>=0&&a[i].y+lenx<=5000&&a[i].x-leny>=0){
					if(vis[a[i].x-leny][a[i].y+lenx]&&vis[a[j].x-leny][a[j].y+lenx]){
						maxn=(maxn>=(lenx*lenx+leny*leny)?maxn:(lenx*lenx+leny*leny));
					}
				}
				
			}
		}
	}
	printf("%d",maxn);
}
```

---

## 作者：loadingnow (赞：1)

3000个点，如果枚举三个点判断第四个点的话时间复杂度事O(n^3)必定会超时，

所以我们选择枚举两个点，判断能和这两个点构成正方形的另两个点是否存在。

枚举任两个点，这两个点可以是正方形一条边上的两个点，也可以是正方形对角线上的两个点，

但是如果正方形存在，则必定在读入的点中存在两点构成存在的正方形的一条边

不要问我为什么不讨论对角线的两点，因为不好写。

vst表示某一个点是否存在，true表示存在，false表示不存在。

注意判断越界，应该先判断越界条件，不能判断越界和判断vst一起写，因为会RE

```cpp
#include <iostream>
#include <cmath>
using namespace std;
const int MAXM=5010;
const int MAXN=3010;
bool vst[MAXM][MAXM];//记录每个点的位置 
int ans=0;
struct str
{
    int x,y;
};
str point[MAXN];
void check(int x1,int y1,int x2,int y2)//选取的两点作为正方的一条边 
{
    int lx=abs(x1-x2),ly=abs(y1-y2);//lx为横坐标差的绝对值，ly为纵坐标差的绝对值 
    if(lx==0)//选择的两点横坐标相同时，检验向左和向右的正方形是否存在 
    {
        if(x1-ly>=0&&x2-ly>=0)//向左，判断是否越界！！！ 
            if(vst[x1-ly][y1]==true&&vst[x2-ly][y2]==true) 
                ans=max(ans,ly*ly); 
        if(x1+ly<MAXM&&x2+ly<MAXM)//向右，判断是否越界！！！ 
            if(vst[x1+ly][y1]==true&&vst[x2+ly][y2]==true)
                ans=max(ans,ly*ly);
    }
    if(ly==0)// 选择的两点纵坐标相同时，检验向上和向下的正方形是否存在 
    {
        if(y1-lx>=0&&y2-lx>=0)//向下，判断是否越界 ！！！ 
            if(vst[x1][y1-lx]==true&&vst[x2][y2-lx]==true)
                ans=max(ans,lx*lx);
        if(y1+lx<MAXM&&y2+lx<MAXM)//向上，判断是否越界！！！ 
            if(vst[x1][y1+lx]==true&&vst[x2][y2-lx]==true)
                ans=max(ans,ly*ly);
    }
    if((x1-x2)*(y1-y2)>0)//等价于(y1-y2)/(x1-x2)>0,即斜率大于零，线段表现为汉字笔画的一撇，判断左上方和右下方是否有正方形 
    {
        if(x1-ly>=0&&y1+lx<MAXM && x2-ly>=0&&y2+lx<MAXM)//左上方，判断越界
            if(vst[x1-ly][y1+lx]==true&&vst[x2-ly][y2+lx]==true)
                ans=max(ans,lx*lx+ly*ly);//可用数学证明或者割补法计算正方形面积，详情参考勾股定理证明方法 
        if(x1+ly<MAXM&&y1-lx>=0 && x2+ly<MAXM&&y2-lx>=0)//右下方，判断越界
            if(vst[x1+ly][y1-lx]==true&&vst[x2+ly][y2-lx]==true)
                ans=max(ans,lx*lx+ly*ly); 
    }
    if((x1-x2)*(y1-y2)<0)//等价于(y1-y2)/(x1-x2)<0,即斜率小于零，线段表现为汉字笔画的一捺，判断左下方和右上方是否有正方形 
    {
        if(x1+ly<MAXM&&y1+lx<MAXM && x2+ly<MAXM&&y2+lx<MAXM)//右上方，判断越界
            if(vst[x1+ly][y1+lx]==true&&vst[x2+ly][y2+lx]==true)
                ans=max(ans,lx*lx+ly*ly);
        if(x1-ly>=0&&y1-lx>=0 && x2-ly>=0&&y2-lx>=0)//左下方，判断越界
            if(vst[x1-ly][y1-lx]==true&&vst[x2-ly][y2-lx]==true)
                ans=max(ans,lx*lx+ly*ly);     
    } 
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>point[i].x>>point[i].y;
        vst[point[i].x][point[i].y]=true;
    }
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            check(point[i].x,point[i].y,point[j].x,point[j].y);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Ultimate (赞：0)

枚举两个点然后利用三角形全等求出另外两个点是否存在

但是好像 1 1 2 2 3 3 4 4 的数据会炸

```cpp
var mapx,mapy:array[1..3000] of longint;
    b:array[0..5000,0..5000] of boolean;
    n,i,j,k,max:longint;
function maxx(x,y:longint):longint;
begin
  if x>y then exit(x) else exit(y);
end;
begin
  readln(n);
  max:=0;
  fillchar(b,sizeof(b),false);
  for i:=1 to n do
  begin
    readln(mapx[i],mapy[i]);//读入
    b[mapx[i],mapy[i]]:=true;//记录 点是存在的
  end;
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if (mapy[i]-abs(mapx[i]-mapx[j])>=0) and (mapx[i]-abs(mapy[i]-mapy[j])>=0) and (mapy[j]-abs(mapx[i]-mapx[j])>=0) and (mapx[j]-abs(mapy[i]-mapy[j])>=0) then
        if b[mapx[i]-abs(mapy[i]-mapy[j]),mapy[i]-abs(mapx[i]-mapx[j])] and b[mapx[j]-abs(mapy[i]-mapy[j]),mapy[j]-abs(mapx[i]-mapx[j])] then//全等判断
          max:=maxx(max,sqr(abs(mapy[i]-mapy[j]))+sqr(abs(mapx[i]-mapx[j])));//记录最大值
  writeln(max);//输出
end.
```

---

## 作者：acaca (赞：0)

枚举4个点必定超时。（这还用说）

典型的方法是利用全等三角形，任选两个点确定一个正方形，再验证另外两个点是否存在。

读入时可以使用二维布尔数组，记下坐标。

附上pascal的AC代码

```pascal
var b:array[0..5000,0..5000] of boolean;
    x,y:array[1..3000] of longint;
    n,i,j,max,w,p1,p2,q1,q2:longint;
begin
  read(n);
  for i:=1 to n do
  begin
    read(x[i],y[i]);
    b[x[i],y[i]]:=true;
  end;
  for i:=1 to n-1 do
    for j:=i+1 to n do
    begin
      p1:=abs(y[i]-y[j])+x[i];
      q1:=abs(x[i]-x[j])+y[i];
      p2:=abs(y[i]-y[j])+x[j];
      q2:=abs(x[i]-x[j])+y[j];
      if (p1>5000)or(q1>5000)or(p2>5000)or(q2>5000) then continue;
      w:=sqr(x[i]-x[j])+sqr(y[i]-y[j]);
      if b[p1,q1] and b[p2,q2] then
        if max<w then max:=w;
    end;
  writeln(max);
end.
```
但是这道题目数据较弱。这样的代码虽然可以AC，但并不完全正确。

假如数据中四个点构成了一条直线，那么利用全等三角形计算会产生错误答案，把一条直线误判做正方形。

例如有四个坐标 A（1，1） B（2，2） C（3，3） D（4，4）

假若用以上的AC代码，输出的结果将是2，而正确结果是0。

p1=abs(1-2)+1=2

q1=abs(1-2)+1=2 

所以正方形的第三个点的坐标就会判定为B自己。于是就得出了错误的结果。

关于解决方法，请联系代码自行思考。

强烈要求增强数据


---

## 作者：niyinchen (赞：0)

水，枚举两个点，确定正方形

```cpp
var b:array[0..5000,0..5000]of boolean;max,p:int64;
n,i,j,k1,k2,y1,y2,x1,x2:longint;x,y:Array[0..4000]of longint;
begin
  readln(n);fillchar(b,sizeof(b),false);max:=0;
  for i:=1 to n do
    begin read(x[i],y[i]);b[x[i],y[i]]:=true;end;{判断是否有这个点}
  for i:=1 to n do
    for j:=1 to n do
      if i<>j then
        begin
          p:=sqr(x[i]-x[j])+sqr(y[i]-y[j]);
          k1:=abs(x[i]-x[j]);k2:=abs(y[i]-y[j]);
          y1:=y[i]+k1;x1:=x[i]-k2;y2:=y[j]+k1;x2:=x[j]-k2;//计算
          if(x1>=0)and(y1>=0)and(x1<=5000)and(y1<=5000)
          and(y2>=0)and(y2<=5000)and(x2>=0)and(x2<=5000)then
          if b[x1,y1]and b[x2,y2]then
            if p>max then max:=p;//最好用整形，实形有误差
        end;
  writeln(max);
end.
```

---


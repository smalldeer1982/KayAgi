# 棋盘游戏

## 题目描述

为了增强幼儿园小朋友的数数能力，小虎老师给了一个家庭游戏作业。让小虎那一块空的围棋盘，随机在一些方格中放些棋子（有黑白两种颜色），如果一个方格和它的上、下、左、右四个方格之一有相同颜色的棋子，则认为两个格子是相互连通的。这期间，要求小虎不断统计共有多少个连通块。

如下图是一个 $5\times 9$ 的一块棋盘，其中 `.` 表示空格，`*` 表示黑棋子，`@`表示白棋子。

则有 $4$ 块连通子块。
```
.  .  .  .  .  .  .  .  .
.  .  *  *  .  .  @  @  .
.  *  *  @  @  .  @  @  .
.  .  *  @  .  .  *  .  .
.  .  .  .  .  .  .  .  .
```

哥哥大虎在一边看一边想，如果棋盘是 $N\times N$ 的，共放了 $M$ 个棋子，如何使用计算机解决这个问题呢？

## 说明/提示

对于 $30\%$ 数据：$1\le N \le 10$。

对于 $60\%$ 数据：$1\le N\le 100$。

对于 $100\%$ 数据：$1\le N\le 500$，$1\le M \le N \times N$，$ 0 \le c \le 1$，$ 1\le x, y \le N$。

## 样例 #1

### 输入

```
3 5    
1 1 1  
1 1 2  
0 2 2  
1 3 1  
1 2 1  
```

### 输出

```
1 
1 
2 
3 
2
```

## 样例 #2

### 输入

```
3 5
1 1 2
1 2 1
1 3 2
1 2 3
1 2 2
```

### 输出

```
1
2
3
4
1
```

# 题解

## 作者：Farkas_W (赞：31)

 $$\text{求连通块数量，首先想到二维并查集}$$

$\quad$与其它并查集不同，在棋盘上需要二维并查集，用一维数组f记录每个坐标的祖先，用二维数组记录每个点的颜色。（1表示白点，2表示黑点）

$\quad$二维并查集一般采用压缩成一维的方法，将坐标为$(x,y)$的点记录为 $(x-1)\times m+y$ ，$m$ 为一行中点的数量（此题中为 $n$，棋盘是 $n\times n$ 的），这样就可以存储祖先了。

$\quad$由于我从 $1$~$n$ 存储点，数组开的略大，所以没有判断边界，然后新加一个点 $ans$++，连通块合并时 $ans$ - - 即可。

$\quad$使用并查集一定要初始化，最好也要路径压缩(没试过，不知道会不会T)，每次修改直接将一个连通块的祖先并到另一个祖先。(就是敲一个并查集板子)

下面贴上蒟蒻的代码，如果有思路的建议不要看下面的代码，自行思考

```cpp
#include<iostream>
#include<cstdio>
#define il inline
#define re register int
using namespace std;
il int read()		//快速读入
{
  int x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
il void print(int x)//快速输出
{
  if(x<0)putchar('-'),x=-x;
  if(x/10)print(x/10);
  putchar(x%10+'0');
}
const int N=505;
int n,m,a[N][N],ans,f[N*N];		  //ans记录连通块数量
int fx[5]={0,1,-1,0,0},fy[5]={0,0,0,1,-1};//用数组存储位置变化，方便判断
il int find(int x)		//并查集  路径压缩
{
  if(x!=f[x])f[x]=find(f[x]);
  return f[x];
}
signed main()
{
  n=read();m=read();
  for(re i=1;i<=n*n;i++)f[i]=i;//并查集初始化
  for(re i=1;i<=m;i++)
    {
      int z=read()+1,x=read(),y=read();//因为a数组初始化为0，所以read()+1，用1表示白点，用2表示黑点,与0区分
      a[x][y]=z;		       //标记颜色
      ans++;			       //增加连通块数量
      for(re j=1;j<=4;j++)		//向上下左右四个方向判断是否连通
	{
	  int xx=x+fx[j],yy=y+fy[j];
	  if(a[xx][yy]!=z)continue;	//条件1：颜色相同
	  int fa=find((xx-1)*n+yy),fu=find((x-1)*n+y);
	  if(fa!=fu)f[fa]=fu,ans--; 	//条件2：祖先不同 ——>合并祖先，连通块数量减少
	}
      print(ans);putchar('\n');		//输出
    }
  return 0;
}
```
$\large\text{后话}$

本蒟蒻目前速度最快（不开O2）。

![](https://cdn.luogu.com.cn/upload/image_hosting/eji3dtk7.png)

都看到这了，还不点个赞支持一下!

完结撒花!

---

## 作者：天南星魔芋 (赞：8)

前言无~


------------
我们看题，统计共有多少个连通块，首先想到 $bfs$。

但再看，他要我们求多次，可 $bfs$ 效率太低，

~~说句闲话：记录联通块的最好方法是——~~

并查集。	~~祝你们学会~~ ~~（逃。~~

所以我们要用并查集。

思路：用并查集记录联通块个数，输出。

但并查集是线性的，此题为二维，故要降成一维，

用 $b=x*N+y$ 来表示一个坐标为 $(x,y)$ 点

那么，下面就见代码吧：


```cpp
#include<bits/stdc++.h>//万能头很香 
using namespace std;
int f[501][501];
int N,M;
int ans=0;
int a,b;
int x,y,z;
int bcj[260100];//并查集 线性 指降成一维 
//--------------------------------------------// 并查集求联通编号 ， 
inline int fa(int x){                        //        不是那个“联通 ”别瞎想 。 
	if(bcj[x]!=x)return bcj[x]=fa(bcj[x]);  // 
	else return x;                         // 
}                                         //
//---------------------------------------// 
//----------------------------------------------------------// 
inline void bfs(){                                         // 
	b=y*N+z;                                              // 
	ans++;                                               // 
	if(z+1<=N)if(f[y][z+1]==f[y][z])                    // 向四周 ， 
	{a=fa(y*N+z+1);if(a!=b){bcj[a]=b;ans--;}}          // 看看有没有可以联通的 区域 。 
	                                                  // 
	if(y+1<=N)if(f[y+1][z]==f[y][z])                 // 注：由于蒟蒻太懒，故在本题中 b 没减 N  ， 
	{a=fa(y*N+z+N);if(a!=b){bcj[a]=b;ans--;}}       //      不过数组开大点就好了。 
	                                               // 
	if(z-1>0)if(f[y][z-1]==f[y][z])               // 
	{a=fa(y*N+z-1);if(a!=b){bcj[a]=b;ans--;}}    // 
	                                            // 
	if(y-1>0)if(f[y-1][z]==f[y][z])            // 
	{a=fa(y*N+z-N);if(a!=b){bcj[a]=b;ans--;}} // 
}                                            //
//------------------------------------------// 
int main(){
	scanf("%d%d",&N,&M);

	for(int i=1;i<=260001;i++)//重要：并查集初始化 
	bcj[i]=i;

	for(int i=1;i<=M;i++){//在线算法，省数组 
		scanf("%d%d%d",&x,&y,&z);
		f[y][z]=x+1;
		bfs();
		printf("%d\n",ans);
	}
}
```



这篇题解就到这里了，

我还没写过几次，有不到之处请多多指教




---

## 作者：Ludo (赞：4)

## Part 1. 题意

现有大小为 $n \times n$ 的棋盘，一共加入 $m$ 个棋子，有不同的颜色（黑白两种）。每次加入后统计连通块数目。

## Part 2. 分析

维护连通块，我们会想到什么？ bfs? dfs? 不过用在这题会慢了点。因为我们有多个修改-查询。

如果想想并查集呢？并查集也可以维护连通性呀~

这是个二维的题目，而我们常见的并查集中，$father$ 是个一维数组。如果我们把二维的棋盘编个号，不就可以转化为一维的情况了吗。

我们可以分析一下下面这个表

| **1** | **2** | **3** | **4** | **5** |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| **6** | **7** | **8** | **9** | **10** |
| **11** | **12** | **13** | **14** | **15** |
| **16** | **17** | **18** | **19** | **20** |
| **21** | **22** | **23** | **24** | **25** |

我们可以得到如下规律，如果现在放下一枚棋子在第 $x$ 行第 $y$ 列的话，那这枚棋子的编号就是 $(n-1) \times x + y$ 了。

然后另外一个重点是如何计算连通块数目了。

当然，我们假设加入一个棋子之后肯定增加了连通块数量。

但是减少的情况咋确定呢？

为了分析得更好，我们找点~~恶心~~有代表性的例子吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/v4f9hw0q.png)

变化前有 $4$ 个连通块，变化后只有 $1$ 个连通块。

我们会开始想，只要每次试着检查上下左右有没有棋子（当然颜色也需要考虑，这里讨论的是相同的情况，因为不相同的分开考虑就行），有的话，连通块数量就减 $1$ 了。

![](https://cdn.luogu.com.cn/upload/image_hosting/j1tanqoq.png)

这种呢？变化前有 $3$ 个连通块，变化后也同样只有 $1$ 个

其实很相似的。但是没减得那么多啊。这时要发挥并查集的作用了。我们一边检查，一边合并，就可以把状况排除掉。

所以说，算法的流程是这样的：

1. 把棋子所在的位置记录为已有棋子。

2. 对应连通块数量加一。

3. 检查上下左右棋子出现状态，有出现的话合并，并且连通块要减一（注意边界！）。

4. 输出连通块数量（黑色的数量加白色的数量就是答案）。

## Part 3. 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,m,c,x,y,visited[2][501][501],fa[2][501*501],ans[2];

//visited(c,x,y)代表颜色c在棋盘第x行第y列中有没有出现过
//fa(c,k) 代表颜色与一维坐标
//ans(x) 代表颜色x连通块数量

int find(int type,int a)
{
	if (fa[type][a]!=a) return fa[type][a]=find(type,fa[type][a]);
	return fa[type][a];
}
void merge(int type,int x,int y)
{
	if (find(type,x)==find(type,y)) return;
	fa[type][find(type,x)]=find(type,y);
	ans[type]--; //连通块减一
}
int main(void)
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n*n;i++)
	{
		fa[0][i]=i;fa[1][i]=i;
	}
	/*
		初始化并查集
	*/
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&c,&x,&y);
        
		//1. 把棋子所在的位置记录为已有棋子。
        
		visited[c][x][y]=1;
        
		//2. 对应连通块数量加一。
        
		ans[c]++;
        
		//3. 检查上下左右棋子出现状态，有出现的话合并（注意边界！）。
        
		//left
		if (y>1&&visited[c][x][y-1]) merge(c,(x-1)*n+y,(x-1)*n+y-1);
		//right
		if (y<n&&visited[c][x][y+1]) merge(c,(x-1)*n+y,(x-1)*n+y+1);
		//up
		if (x>1&&visited[c][x-1][y]) merge(c,(x-1)*n+y,(x-2)*n+y);
		//down
		if (x<n&&visited[c][x+1][y]) merge(c,(x-1)*n+y,x*n+y);
        
		//4. 输出连通块数量（黑色的数量加白色的数量就是答案）。
        
		printf("%d\n",ans[0]+ans[1]); //黑色跟白色
	}
	
	
}
```




---

## 作者：samzhangjy (赞：2)

## 前言

~~蒟蒻来水题解啦~~

前往[窝的小窝](https://www.cnblogs.com/samzhangjy/p/luogu-p5877.html)阅读更佳~

## Description

给定一个 $N \times N$ 的矩阵中的 $M$ 个点，求这些点中的连通块数量。

## Solution

~~正常人~~看到这道题的第一反应应该是广搜吧。但是，很明显使用 BFS 会超时：我们需要求 $M$ 次连通块的数量。

那么怎么办呢？~~凉拌蒟蒻！~~ 我们可以使用 **二维并查集** 进行统计。

为什么我们可以使用并查集呢？我们可以把一个连通块想象成一个树，新加进来（或与其相邻的）的节点都是它的子节点。那么，这棵树的根就是这个连通块在并查集里的祖先。

那还剩下一个问题。二维并查集这么搞？

其实我们不需要真正创建一个二维的并查集。我们可以把这个矩阵进行压缩，使其成为一个我们~~喜闻乐见~~熟悉的一维并查集。

那么，对于一个点 $(x, y)$ ，它在并查集数组中的下标应该是 $x \times N + y$ 。

然后，对于每个新添加的节点，我们都会检测它上、下、左、右四个方位有没有相同颜色的节点。如果有，那么继续判断该节点是否跟当前节点为同一个祖先。如果不是，那么我们将它们合并，使其祖先同一。

## Code

下面，让大家来看看这个蒟蒻~~难看的~~代码啦~

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 510, M = N * N;

int n, m, father[M], a[N][N], ans;  // father数组存储每个节点祖先，a数组用于存储每个节点的颜色，ans变量为当前连通块的数量
int dx[] = {0, 0 ,1, -1}, dy[] = {1, -1, 0, 0};  // 类似BFS，上下左右四个点的偏移量

int Find(int x) {  // 查询祖先
    if (father[x] == x) return x;
    return father[x] = Find(father[x]);
}

void Union(int u, int v) {  // 合并节点
    int fu = Find(u), fv = Find(v);
    if (fu != fv) father[fu] = fv, ans--;  // 如果祖先不同，连通块数量 - 1
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i < M; i++) father[i] = i;
    for (int i = 1; i <= m; i++) {
        int c, x, y;
        scanf("%d%d%d", &c, &x, &y);
        a[x][y] = c + 1, ans++;  // 与默认值区分开
        for (int i = 0; i < 4; i++) {  // 循环4个方位
            int nx = x + dx[i], ny = y + dy[i];  // 当前新的节点坐标
            if (a[nx][ny] != a[x][y]) continue;  // 如果不是同一个颜色那就没必要合并了
            Union(nx * n + ny, x * n + y);  // 合并节点，判断祖先的操作在Union函数里
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：lytqwq (赞：2)

~~抢第一篇题解~~

算法1：

暴力，既然让我们求联通块，我们每次放入棋子就dfs求连通块，时间复杂度 $ O（ N^2 * M）$ ，期望得分60

算法2：

因为每次只是放入棋子改变周围的联通情况，所以我们可以开一个并查集，当放入棋子时，查看周围的棋子，来根据上一次的答案算这一次的答案。

1为有棋子，0为无棋子，红圈为待放棋子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ota9abu9.png)

sum为连通块个数

在放这个棋子之前sum=5，当我们放入这个棋子后，先是因为放入棋子sum++，然后因为上下左右都是独立的连通块，sum-=4;

最后sum=2;

为了防止重复计算，我们每次都 **判断一个方向的，然后join** 直到判断完4个方向

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 501
struct d{
	int x,y;
	bool operator == (const d xx) const
	{
		return x==xx.x&&y==xx.y;
	}
}father[N][N];
int n,m,sum;
int a[N][N],b[4]={1,-1,0,0},cc[4]={0,0,1,-1};
d find(d qwq)
{
	if(!(qwq==father[qwq.x][qwq.y]))
	{
		father[qwq.x][qwq.y]=find(father[qwq.x][qwq.y]);
	}
	return father[qwq.x][qwq.y];
}
void join(d qwq,d qaq)
{
	d fqwq=find(qwq),fqaq=find(qaq);
	father[fqwq.x][fqwq.y]=fqaq;
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int o=1;o<=n;o++)
		{
			father[i][o].x=i;
			father[i][o].y=o;
		}
	}
	for(int i=1;i<=m;i++)
	{
		int c,x,y;
		scanf("%d%d%d",&c,&x,&y);
		d now,now2;
		now.x=x;
		now.y=y;
		a[x][y]=c+1;
		sum++;
		for(int o=0;o<4;o++)
		{
			int fx=x+b[o],fy=y+cc[o];
			now2.x=fx;now2.y=fy;
			if(fx>0&&fx<=n&&fy>0&&fy<=n&&a[fx][fy]==a[x][y])
			{
				if(!(find(now)==find(now2)))
				{
					sum--;
					join(now,now2);
				}
			}
		}
		printf("%d\n",sum);
	}
}
```



---

## 作者：AzzyZhe (赞：1)

## 题解 P5877 棋盘游戏
$\rightarrow$ [题目传送门](https://www.luogu.com.cn/problem/P5877)

蒟蒻之前题没读清最先想到种子填充，但为了~~整活~~考虑 $n$ 更大而 $m$ 小的情况写了个离散化+一维并查集。结果最后才发现每一步都要输出结果，歪打正着。不过最后发现只有在这种 $n$ 较小时可以直接映射，而由于要判相邻四个点能否合并用 `map` 映射还是会TLE，没什么用，也只算是比二维并查集省心一点，再复习下 STL 了……

### 思路
----
每个棋子自己构成一个集合，离散化存储其集合序号，在放下一个棋子若其四个方向有相邻同色棋子则合并集合。放下一个棋子增加一个集合，成功合并一次减少一个集合，放下每个棋子后的总集合数即为答案。

所谓离散化，可以说就是一种将原数据按一定规则重编号的思路。假如你做一个解析几何题，在运用性质寻找关系时就没必要用坐标叫每个点，而是使用字母 $A, B, C, D\dots$ 来表示。

在本题中，我们注意到棋子的坐标和并查集本身之间是没有关系的，因此我们可以将依次放下的棋子记为 $1, 2, 3\dots$ 号棋子，通过坐标映射来找到哪个位置有哪颗棋子，再将可合并的棋子集合合并成连通块。

实现细节请见代码：

### 代码
----
```cpp
#include<iostream>
#define MAXN 502 //数组略大无需对坐标判错
#define MAXM (MAXN*MAXN)
using namespace std;
int color[MAXN][MAXN],num[MAXN][MAXN]；//位置上棋子的颜色和编号
int n,m;
int fa[MAXM],rnk[MAXM];//同时使用路径压缩和按秩合并的并查集
int findfa(int x)
{
	if(fa[x]==x)
		return x;
	return fa[x]=findfa(fa[x]);//路径压缩
}
inline int uni(int a,int b)
{
	a=findfa(a),b=findfa(b);
	if(a==b)
		return 0;
	if(rnk[a]>rnk[b])//异或实现的swap要注意a!=b
		a^=b^=a^=b;  //swap(a,b);
	rnk[b]+=rnk[a];//按秩合并
	fa[a]=b;
	return 1;
}
int ans;
int mian()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		fa[i]=i;
		rnk[i]=1;//显然不会用到未放下的棋子，可在放下前再初始化并查集
		int c,x,y;
		cin>>c>>x>>y;//离散化棋子并建立坐标映射棋子编号
		color[x][y]=++c;//与无棋子区分开来
		num[x][y]=i;
		int f=1;//本次放下棋子后增加的连通块数
		if(color[x+1][y]==c)
			f-=uni(i,num[x+1][y]);//每次合并成功减少一个连通块
		if(color[x][y+1]==c)
			f-=uni(i,num[x][y+1]);
		if(color[x-1][y]==c)
			f-=uni(i,num[x-1][y]);
		if(color[x][y-1]==c)
			f-=uni(i,num[x][y-1]);
		ans+=f;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：oimaster (赞：1)

暴力解法是搜索，用深度优先搜索或广度优先搜索均可。模板题是这道题，在这里需要判定一下颜色是否统一即可。时间复杂度：$O(n^2m)$。可以拿到 $60$ 分的成绩。

分析问题，发现这题也可以使用并查集来解决。每次插入时，如果四周全是空的或异色棋子，那么就把连通块数量加 $1$。否则这个棋子一定不会创建新的连通块，而是会合并到周围的棋子中。

然而还有一种情况，就是新加的棋子“搭出了一座桥”，也就是说把两个连通块连在一起，那么就反而要把连通块数量减一。判断是否搭出桥梁只需要用并查集判断即可（`find()` 函数返回值不一样）。具体可以参照样例 2。

二维前缀和稍微还是考一些代码能力的。代码参见洛谷云剪贴板：<https://www.luogu.com.cn/paste/nnwkcoe4>

---

## 作者：zhangyuhan (赞：1)

一道很好的二维并查集模板题。

题目大意很简单：在一个$N×N$的棋盘上放$M$个棋子，求每放一次后棋盘上的连通块的个数

如果考虑$DFS$或$BFS$来求连通块的话，显然会$T$。

那么，我们该用什么高效的算法或数据结构来解决这个问题呢？

在讲普通的一维并查集的时候，我们采用了一种代表元的思想：一个集合用一个元素作为它的代表，将集合内的所有元素的父节点指向这个代表元，最后根据每个元素的父节点来判断元素所在集合。

那么，这个思想在求连通块个数时有什么应用呢？

我们可以认定一个棋子为代表元，在想四个方向扩展，如果有相同的棋子，就可以将这颗棋子的父节点指向原先的节点，这样不停的拓展下去，会构成一个集合（也就是这个连通块），而代表元就是原先的那枚棋子。

这样，集合个数即为我们所求。

那么，下面我来介绍一下二维并查集的实现。

首先，考虑$f$数组的定义。由于棋盘是二维的，我们可以有二维数组；同时，每个代表元也是一个二维的坐标，所以，我们可以将$f$数组定义为一个结构体，里面存着$(i,j)$的代表元的坐标$(x,y)$。

代码如下：

```cpp
struct node {
    int x, y;
};
node f[MAXN][MAXN];
```

仿照一维并查集，我们可以对二维并查集有如下操作：

$·init()$:初始化集合，即将每个位置的代表元设为自己

$·find(x)$：求$x$所在的集合的代表元

$·unite(x, y)$:将$x$和$y$所在的集合合并

$·same(x, y)$：询问$x$和$y$是否在一个集合内。

下面我来一一讲解。

对于$init$操作，十分简单：$f_{i,j}=(node\{i, j\})$

```cpp
void init() {
    _for (i, 1, n)
        _for (j, 1, n) 
            f[i][j] = (node){i, j};
}
```

对于$find$操作，这就需要一定的思维。

这个$find$操作，我们也要进行路径压缩。

当查询到代表元就是自己时，判断标准自然是$f_{i,j}$的坐标和自己的坐标相同，扩展开写就是$f_{i,j}.x == d.x$ $&&$ $f_{i,j}.y==d.y$，此时就可以`return`；

否则的话，就要更新当前节点的代表元。

```cpp
node find(node d) {
    if (f[d.x][d.y].x == d.x && f[d.x][d.y].y == d.y) return d;
    return f[d.x][d.y] = find(f[d.x][d.y]);
}
```

对于$unite$操作，则是十分简单。

```cpp
void unite(node d1, node d2) {
    d1 = find(d1);
    d2 = find(d2);
    if (d1.x == d2.x && d1.y == d2.y) return ;
    f[d1.x][d1.y] = d2;  
}
```

而$same$操作就只是判断两个元素的代表元坐标是否相等即可。

```cpp
bool same(node d1, node d2) {
    d1 = find(d1);
    d2 = find(d2);
    return d1.x == d2.x && d1.y == d2.y;
}
```

大体上就是差不多。其实我们发现，我在上面大量用到了判断坐标相等，所以我们可以考虑对于$node$来重载$==$这个运算符，这留给读者自己思考。

然后要根据每一次部署棋子来更新集合个数。我们可以从每一次部署的位置向四周扩展，如果遇到同类棋子，可以判断是否处在同一集合里，不是就可以合并。

至于统计答案，我们可以先设定$ans=0$，每下一个棋子$ans++$，但一旦发现周围有同类棋子且集合不一样时，合并集合的同时，$ans--$，最后每次输出$ans$即可。

再讲一下一个小坑点。如果你一开始的棋盘数组初始化是$0$，输入$c$时不能等于$0$，否则。。。$GG$。

所以你可以对输入的$c$进行变换(例如$+1$什么的)

差不多了，上代码！

$AC$ $Code$

```cpp
#include <iostream>
#define _for(i, a, b) for (int i=(a); i<=(b); i++)
using namespace std;

const int MAXN = 510, dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};//方向数组

struct node {
    int x, y;
};
node f[MAXN][MAXN];

int n, m, map[MAXN][MAXN], ans;

void init() {
    _for (i, 1, n)
        _for (j, 1, n) 
            f[i][j] = (node){i, j};
}

node find(node d) {
    if (f[d.x][d.y].x == d.x && f[d.x][d.y].y == d.y) return d;
    return f[d.x][d.y] = find(f[d.x][d.y]);
}

void unite(node d1, node d2) {
    d1 = find(d1);
    d2 = find(d2);
    if (d1.x == d2.x && d1.y == d2.y) return ;
    f[d1.x][d1.y] = d2;  
}

bool same(node d1, node d2) {
    d1 = find(d1);
    d2 = find(d2);
    return d1.x == d2.x && d1.y == d2.y;
}//二维并查集基本操作

bool cango(int x, int y) {
    return x > 0 && x <= n && y > 0 && y <= n;
}//判断是否出界

int main() {
    cin >> n >> m;
    init();//初始化莫忘掉
    while (m--) {
        int c, a, b;
        cin >> c >> a >> b;
        node now;
        now.x = a, now.y = b;
        map[a][b] = c+1;//变换莫忘掉
        ans++;
        _for (i, 0, 3) {
            int nx = a + dir[i][0], ny = b + dir[i][1]; 
            node next;
            next.x = nx, next.y = ny;
            if (cango(nx, ny) && map[a][b] == map[nx][ny]) {//一定要判断棋子种类是否一样
                if (!same(now, next)) {
                    unite(now, next);
                    ans--;
                }
            }
        }
        cout << ans << endl;//换行莫忘掉
    }
    return 0;//完结撒花！
}
```


---

## 作者：StarryWander (赞：0)

# 本题采用：二维并查集（无优化，适合新手）。

对于求连通块数量，我们可能会想到 BFS 搜索，但是，本题需要有多次询问，对于每一次询问我们都 BFS 一次必定会超时，此时我们就可以想到这题可以用：**并查集**。

首先，我们创建一个二维棋盘并查集：$x$ , $y$ 表示祖先的坐标， $f$ 表示所在棋盘坐标落下的棋子颜色。

```cpp
struct node{
    int x,y,f;
};
node pre[505][505];
```
假设每一个 $ pre[i][j]$ （棋盘上的一个点）的祖先为**自己**，因此需要初始化：

```cpp
for(int i=1;i<=n;i++){
   for(int j=1;j<=n;j++){
      pre[i][j].x=i;
      pre[i][j].y=j;
      pre[i][j].f=-1;
   }
}
```

## 接下来就是并查集模板了：

### 寻找祖先函数：

此函数作用为：

1.记录传入棋盘坐标的祖先。

2.判断这个祖先是不是**自己**。

3.如果是自己就返回坐标，如果不是就记录此坐标祖先的祖先。

```cpp
node find(int x,int y){ 
    int tx=x;
    int ty=y;
    while(pre[tx][ty].x!=tx||pre[tx][ty].y!=ty){
        int ttx=tx,tty=ty; 
        tx=pre[ttx][tty].x;
        ty=pre[ttx][tty].y;
    }
    node p;
    p.x=tx;
    p.y=ty;
    return p;
}
```

### 团队合并函数：

功能为：判断两个人的最高祖先是不是同一个人，如果是就**不操作**，如果不是就将其中一个团队的祖先设为另一个团队的祖先。记得将 $ans$ （连通块数量）减一,因为两个连通块合并必然会少一个。

```cpp
void join(int a,int b,int c,int d){
    node f1=find(a,b);
    node f2=find(c,d);
    if(f1.x!=f2.x||f1.y!=f2.y){
        pre[f1.x][f1.y].x=f2.x;
        pre[f1.x][f1.y].y=f2.y;
        ans--;
    }
}
```
## 接下来是主函数：

```cpp
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){//初始化。
        for(int j=1;j<=n;j++){
            pre[i][j].x=i;
            pre[i][j].y=j;
            pre[i][j].f=-1;
        }
    }
	for(int i=1;i<=m;i++){
        int p,x,y;
        scanf("%d %d %d",&p,&x,&y);//输入落子坐标和颜色。
        pre[x][y].f=p;
        ans++;
        for(int i=0;i<4;i++){//查看落子的四个方向是否有颜色相同的棋子。
            int tx=x+off[i].x;
            int ty=y+off[i].y;
            if(tx>=1&&tx<=n&&ty>=1&&ty<=n&&pre[tx][ty].f==pre[x][y].f){//如果有就合并团队。
                join(x,y,tx,ty);
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
## 完整code。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
    int x,y,f;
};
node pre[505][505];
int n,m,ans;
node off[4]={{0,1},{1,0},{0,-1},{-1,0}};
node find(int x,int y){ 
    int tx=x;
    int ty=y;
    while(pre[tx][ty].x!=tx||pre[tx][ty].y!=ty){
        int ttx=tx,tty=ty; 
        tx=pre[ttx][tty].x;
        ty=pre[ttx][tty].y;
    }
    node p;
    p.x=tx;
    p.y=ty;
    return p;
}
void join(int a,int b,int c,int d){
    node f1=find(a,b);
    node f2=find(c,d);
    if(f1.x!=f2.x||f1.y!=f2.y){
        pre[f1.x][f1.y].x=f2.x;
        pre[f1.x][f1.y].y=f2.y;
        ans--;
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            pre[i][j].x=i;
            pre[i][j].y=j;
            pre[i][j].f=-1;
        }
    }
	for(int i=1;i<=m;i++){
        int p,x,y;
        scanf("%d %d %d",&p,&x,&y);
        pre[x][y].f=p;
        ans++;
        for(int i=0;i<4;i++){
            int tx=x+off[i].x;
            int ty=y+off[i].y;
            if(tx>=1&&tx<=n&&ty>=1&&ty<=n&&pre[tx][ty].f==pre[x][y].f){
                join(x,y,tx,ty);
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```


---


# [NOIP 2001 提高组] 数的划分

## 题目描述

将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。

例如：$n=7$，$k=3$，下面三种分法被认为是相同的。

$1,1,5$;   
$1,5,1$;   
$5,1,1$.

问有多少种不同的分法。


## 说明/提示

四种分法为：  
$1,1,5$;  
$1,2,4$;  
$1,3,3$;  
$2,2,3$.

**【题目来源】**

NOIP 2001 提高组第二题

## 样例 #1

### 输入

```
7 3
```

### 输出

```
4
```

# 题解

## 作者：s_r_f (赞：437)

这道题我们可以用dp:


f[i][x] 表示 i 分成 x 个非空的数的方案数。


显然 i<x 时 f[i][x]=0 , i=x 时 f[i][x]=1;


其余的状态，我们分情况讨论：

①有1的 ②没有1的

第一种情况，方案数为 f[i-1][x-1]

第二种情况，方案数为 f[i-x][x] (此时 i 必须大于 x)


所以，状态转移方程为： f[i][x]=f[i-1][x-1]+f[i-x][x]


程序如下：

    
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[201][7];  //f[k][x] k 分成 x 份 ={f[k-1][x-1],f[k-x][x]}
int main(){
    cin >> n >> k;
    for (int i=1;i<=n;i++) {f[i][1]=1;f[i][0]=1;}for (int x=2;x<=k;x++) {f[1][x]=0;f[0][x]=0;}  // 边界，为了防止炸，我把有0的也处理了
    for (int i=2;i<=n;i++)
        for (int x=2;x<=k;x++)
            if (i>x) f[i][x]=f[i-1][x-1]+f[i-x][x];
            else f[i][x]=f[i-1][x-1];
    cout<<f[n][k];
    return 0;
}
```

---

## 作者：Trinity (赞：147)

# 题目：P1025 数的划分 2001 提高组 T2
## 题目描述
将整数 _n_ 分成 _k_ 份，且每份不能为空，任意两个方案不相同(不考虑顺序)。  
例如:  
 _n=7_ , _k=3_ ,下面三种分法被认为是相同的。  
 _1 1 5_   
 _1 5 1_   
 _5 1 1_   
问有多少种不同的分法。
## 分析  
_1_.明显不能枚举求解，需要使用递归，递推或数学结论等方法。  
_2_.显然，当 _n=1_ 时，仅有一种分法。  
_3_.两种策略：要么选择将剩余数字分出 _1_ (即 _2_ )，要么分出其它数 _now_ ( _now > 1_)，然后分出 _1_。  
_4_.上网寻找一波数学方法。  
## 解法1：搜索（dfs）+剪枝
_1_.在dfs中模拟进一步选择的分出的_now_，直到分出_1_，再用计数器统计总方案数。  
_2_.剪枝在如下代码中呈现。
```cpp
//搜索（dfs）+剪枝
int n,k;
inline int dfs(int num,int part,int now)//分别表示剩余待分的数，分的机会数和现在要选出的数。
{
  if(part==1)return 1;//如分析2。
  int sum=0;//sum一定要开在函数中，否则会漏选(看后面的代码就懂了)
  for(int i=now;i<=num/part;i++)//剪枝：不需要枚举到num，否则既有可能重复计算，又会加大运算量(dfs你懂的)。
    sum+=dfs(num-i,part-1,i);//再搜索剩余待分数num-i，分的机会数少1，选择分出now，将所有情况统计于sum。
  return sum;
}
int main()
{
  n=read(),k=read();
  printf("%d",dfs(n,k,1));//从n,k选一种开始搜。
  return 0;
}
```
## 解法2：动态规划(不如说是递推)  
_1_.先初始化，任何当_k=1_的情况下仅有一种分法。  
_2_.然后如分析_3_组建_dp_方程，从_i_中分_j_份的方案数 (f[i,j]) , 为 _i-1_ 中分 _j-1_ 份 ( f[i-1,j-1] ,即分出_1_) 和 _i-j_ 分 _j_ 份 (f[i-j][j],因为分出1后剩下 i-j 个可分的1，j 次机会) 的方案数之和。  
_3_.同时要注意一个小小的细节(未经实测，可能不会导致WA)。
```cpp
//动态规划(不如说是递推)
int n,k,f[N][N];
int main()
{
  n=read(),k=read();
  for(int i=1;i<=n;i++)f[i][1]=1;//如上1。
  for(int i=1;i<=n;i++)
    for(int j=2;j<=k;j++)//1的情况已经处理，从2开始，否则会访问0。
        if(i>=j)f[i][j]=f[i-1][j-1]+f[i-j][j];//小细节：只有n>=k时才能有数分。
  printf("%d\n",f[n][k]);//输出从n中分出k份的方案数
  return 0;
}
```
## 解法3：母函数


------------

先声明一下此方法的参考对象 巨佬 [Hardict ](https://www.luogu.org/blog/hardictdbsd/solution-p1025)
和母函数讲解者[xuzengqiang](https://blog.csdn.net/xuzengqiang/article/details/7464337)。
如果大家想要详细了解母函数的其他高端用法，( 建议数学恐惧症的同学们赶快开溜 )请前往[百度百科：母函数](https://baike.baidu.com/item/%E6%AF%8D%E5%87%BD%E6%95%B0)  


------------

首先母函数是什么，一个数列 _a_，有_a1_，_a2~an_ ,可使用母函数将其表示为：  
$G(x)=a_0+a_1x+a_2x^2+a_3x^3+.....+a_nx^n$  
由此形式，它也叫生成函数  。
其应用于各种排列组合的数学问题中，如可以递推变通项，分配问题，_Catalan_数列等。  

基本解决方法：  
1.将模型变成母函数方程。  
2.求解母函数方程。  
3.将母函数变成幂级数形式。        

然后开始这个题的讲解:  
假设1出现的次数为记为a1,2出现的次数记为a2.........k出现的次数记为ak,那么生成函数为：

$G(x)=(1+x+x^2+x^3+x^4+...)(1+x^2+x^4+x^6+x^8+...)(1+x^3+x^6+x^9+...)...(1+x^n)$   
  
  _1_.前面的$1+x2+x4+x6+x8+...$意思是当出现一个2时为x2，当出现两个2时为$x4...$  
  为什么当出现n时，只有两项$(1+xn)$，因为是将数n划分为若干项，所以不能超过该数，且由数1到n项数依次要 $<=n/k(k=1.2,3,4...n)$。  
第i个括号内，它代表i的选取，而第j项，表示选取j个(在这认为从0开始数项数) 。   
_2_.我们的目的就是让求出$G(x)$表达式，然后得到$x^n$的系数  
基本的思想有了，但是仍有问题，就是本题的 _k_ 其实是未知的，无法直接套公式，就需要一个参量y决定&x&的次数。( Idea by 巨佬 Hardict)  
$G(x)=(1+yx+y^2x^2+y^3x^3+...)((1+yx^2 +y^2x^4 +y^3x^6++...)(1+yx^ 3 +y^2x^6+y^3x^9+...)$
```cpp
//母函数（参考Hardict）
int n,k,val[N][N],temp[N][N];//val表示对j进行分i份的个数，即G(x)的系数，temp用来保存每一次求得的结果。
int main()
{
  n=read(),k=read();
  for(int i=0;i<=k;i++)val[i][i]=1;//初始化，如分析2。
  for(int i=2;i<=n-1;i++)//务必从2开始枚举，本人就是在此WA了一小时。
  {
    for(int j=0;j<=n;j++)
      for(int K=0;K<=k;K++)//分到k停止循环。
        for(int l=0;l<=n-j;l+=i)//控制系数的变化和每个数的最大项数 。
          temp[l/i+K][l+j]+=val[K][j];
    for(int K=0;K<=k;K++)
      for(int l=0;l<=n;l++)val[K][l]=temp[K][l];//反过来赋值给val。
    memset(temp,0,sizeof(temp));//务必请零，最好用memset，可能会留存之前的状态。
  }
  printf("%d\n",val[k][n]);
  return 0;
}
```
## 总结
这就是这道题目的三种解法，说实话，前两种应该是很好理解和掌握的，也是大多数同学们早就掌握的，母函数(生成函数)的方法不好理解，也不方便使用，只是看看就好。  
最后，这是本人第一篇题解&博客，写的不好，希望大家勿喷，谢谢。

---

## 作者：Clouder (赞：77)

# Solution
>参考博客：[Click](https://blog.csdn.net/elma_tww/article/details/86538836)  

发现了本题居然有$O(nk)$的优秀解法，于是我~~闲着没事~~抱着学术探究的心情造了一道数据加强版([Click](https://www.luogu.com.cn/problem/U101024))。各位有兴趣的可以看看数据范围加大后对本题做法的影响。  
本题解面向的数据范围奇大，因此有相当多一部分内容可能看起来与本题矛盾……系数据范围不同导致(逃)。  
总结一下不同点：数据范围悬殊，对答案取模。除去此两点，两题完全一样。  ~~所给标程去掉取模后亦可AC本题。~~  
题目意思很容易看懂，我就直接讲dp解法了。  
# dp
题意可以转化为将$n$个苹果放进$k$个盒子里，并且不允许空盒。  
设$f[i][j]$代表将$i$个苹果放入$j$个盒子中，那么我们来分析：  
我们必须先保证每个盒子非空，因此在$i$个苹果中选出$j$个放入每个盒子。  
此时我们剩余$i-j$个苹果，我们就是要往已有的一层苹果上加$i-j$苹果，求此时的方案数。  
现在$i-j$个苹果可以任意分配了，也就是分成$1$份、$2$份、$3$份都是合法的……  
得到转移方程：
$$ dp[i][j] = \sum_{k=1}^jdp[i-j][k]$$
枚举$i$，随后枚举$j$，随后枚举$k$，三层循环即可得出答案。  
时间复杂度为$O(nk^2)$，预期得分70分。  
这个或许可以套树状数组优化一下求和……  
那么复杂度是$O(nk\log k)$，然而最大的范围$nk$达到了$1.2$亿的大小，再加上个$\log$铁定超时。  
然后你可以发现：  
$$dp[i-1][j-1] = \sum_{k=1}^{j-1}dp[i-j][k]$$
为什么会有这样的奇特之处呢？因为$i-j$就是$i$和$j$的差值，那么同增同减一个$1$，dp数组的一维下标是不变的，只是二维的$k$会少一个$dp[i-j][j]$，那么我们把这个加上就好了。  
据此写出转移方程：
$$dp[i][j] = dp[i-1][j-1] + dp[i-j][j]$$
两层循环即可转移，复杂度就降到$O(nk)$了，由于常数小，可以通过本题。  
但交上去……**MLE！**  
# 空间优化
空间复杂度也是$O(nk)$的，但事实上我们只需要用到$O(k^2)$的内容，很容易想到滚动数组。  
于是写出：
~~~cpp
inline int pos(const int &x)
{
	return (x % 600) + 1;
}
int main()
{
    scanf("%d%d", &n, &k);
    dp[pos(0)][0] = 1;
    int i, j;
    for (i = 1; i <= n; ++i)
	{
		memset(dp[pos(i)], 0, sizeof(dp[pos(i)]));
		for (j = 1; j <= k && j <= i; ++j)
            dp[pos(i)][j] = (dp[pos(i-j)][j] + dp[pos(i-1)][j - 1]) % 10086;	
	}
    printf("%d", dp[pos(n)][k]);
    return 0;
}
~~~
个人预期是能AC了，但实际上……第15个点冷酷无情地T了。  
~~评测机跑得不够快~~  
该毒瘤点数据：  
**Input**  
>177078 505

**Output**  
>7900
# 拯救TLE
吸了氧还是不能拯救世界之后，我想起了当年用的一种奇淫技巧……  
显然此时TLE完全是常数问题，将内层循环的两个判断改成取min逆序后依然无法通过。  
常数影响最大的就是pos函数了，于是改成了~~预处理数组~~指针映射，成功AC！  
## 指针映射
我们考虑要如何避免pos函数的高耗时，当然想到了预处理。预处理一遍pos数组，直接访问即可，这应该也是能卡过的(没有尝试)。  
但还有一种更有技巧性、效率更高的方法：指针。  
开一个f数组，如下：
~~~cpp
int *f[maxn];
~~~
然后赋值：
~~~cpp
f[i] = dp[pos(i)];
~~~
那么访问时，直接：
~~~cpp
f[i][j] = ....
~~~
为什么会快？这个很显然了吧……事实上，这种方法比：
~~~cpp
dp[pos[i]][j] = ....
~~~
要快上不少，为什么？

因为$f[i]$存的索引直接加上$j$就能得到地址，我们实际上避免了两个大数的乘法，而使其变成了加法。
举例：
原先访问方式：
~~~cpp
dp[x∗(m+2)+y]
~~~
进行了一次乘法一次加法
解析一下就是：
~~~cpp
return dp + (x * (m+2) + y);
~~~

而现在的访问方式：
~~~cpp
(f[x]+y)
~~~
解析一下就是：
~~~cpp
return (f + x) + y;
~~~
效率提升相当显著。
同时注意我们的预处理方式：
~~~cpp
int pointer = 0;
++pointer;
if(pointer >= 600)
    pointer -= 600;
~~~
可以避免反复求余的预处理效率损失。  
最后第15个点跑了500ms左右……
# Code
~~~cpp
#include <cstdio>
#include <cstring>
using namespace std;
int n, k;
int dp[610][610];
int *f[200100];
inline int min(const int &a,const int &b){return a<b?a:b;}
int main()
{
    scanf("%d%d", &n, &k);
    int p = 0;
    for (int i = 0; i <= n; ++i)
    {
        if (p >= 600)
            p -= 600;
        f[i] = dp[p + 1];
        ++p;
    }
    f[0][0] = 1;
    int i, j;
    for (i = 1; i <= n; ++i)
    {
        memset(f[i], 0, sizeof(f[i]));
        for (j = min(k,i); j; --j)
            f[i][j] = (f[i - j][j] + f[i - 1][j - 1]) % 10086;
    }
    printf("%d", f[n][k]);
    return 0;
}
~~~
# At last
本篇题解面向加强数据的版本，介绍了常用的滚动数组优化空间~~和不常用的指针优化效率~~，但其实核心是对dp方程的优化，由此我们得出总结：  
当某个dp题目写出了朴素方程后，用上数据结构优化，依然无法得到正确复杂度时，需要考虑优化dp方程。  
各位遇到数据范围小的题，也可以思考下若范围更大要如何应对，还是很有意思的qwq。

---

## 作者：Valhalla_Is_Calling (赞：30)

## 这道题如果思路想明白了，剩下的很简单！
### 拿到题目一看就是深度优先搜索的剪枝技巧。

首先普及一下这种算法：因为搜索算法的时间复杂度大多都是指数级的，所以在比赛或者考试中很少用到，即使是简单的搜索，时间复杂度也令人无法忍受，所以就要加入一些优化技巧，比如深搜的剪枝技巧。

### 一、剪枝策略的寻找的方法
1）微观方法：从问题本身出发，发现剪枝条件。

2）宏观方法：从整体出发，发现剪枝条件。

3）注意提高效率，这是关键，最重要的。  

总之，剪枝策略，属于算法优化范畴；通常应用在DFS 和 BFS 搜索算法中；剪枝策略就是寻找过滤条件，提前减少不必要的搜索路径。

### 二、剪枝优化三原则
正确、准确、高效.原则  搜索算法,绝大部分需要用到剪枝.然而,不是所有的枝条都可以剪掉,这就需要通过设计出合理的判断方法,以决定某一分支的取舍. 在设计判断方法的时候,需要遵循一定的原则.

 1） 正确性  正如上文所述,枝条不是爱剪就能剪的. 如果随便剪枝,把带有最优解的那一分支也剪掉了的话,剪枝也就失去了意义. 所以,剪枝的前提是一定要保证不丢失正确的结果.  

2）准确性  在保证了正确性的基础上,我们应该根据具体问题具体分析,采用合适的判断手段,使不包含最优解的枝条尽可能多的被剪去,以达到程序“最优化”的目的. 可以说,剪枝的准确性,是衡量一个优化算法好坏的标准.

3）高效性 设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的. 倘若一个剪枝的判断效果非常好,但是它却需要耗费大量的时间来判断、比较,结果整个程序运行起来也跟没有优化过的没什么区别,这样就太得不偿失了.

![深搜剪枝举例](data:image/jpeg;base64,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kmhiuIzHPEksZ6o6hgfwrmz4B0GC4a50qGfRp2xltLma3VsdN0a/u2/FTQB1NFcwbDxbYmQ2esWWoIeUTULfy3HTjfHgep+77e9Vb/xhqWiWe7VfDF+sxUBHs3S4geUkKqbsqy5ZgMsoHvQB2NFef6xYQ2cFtP4pvtV1PUr2TZDY6XcywIGCFmEaRumQqqxLOSfpkCtCyeLSNPtdZ0zVbq70K52O0d3O05VHwFdJJCXHVflY469KAOwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACis461YjxANDMpF+bX7WI8cGPdtzn60uq6pbaPYvd3jkICFVEGWkY/dVR3Y+lAGVZA23jzVhcuQ15a27Wu5s7kj3hwo7YZgSP8AaFYmkLok3xPvLmz027tL2GKaCWZrKRFu2Z1Z2MhXDBdmF+buccYrRTwy/iCUatr4kgv1B+wJbylW09T12sOsh43E5HAHTrLH4Y1kzFbjxprE1oSP3Ihto3K+hkWINz6rtPvQBZ011uvGOs3NuwMEUFvaSkAYaZTIzDP+ysifn7V0Ncpp0UnhK7TTDEz6JM/+i3G4s1u5/wCWcrMSSD/C5/3T2rq6ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoorB8W6+3hfw7Nq4thciKWFGjMmzh5VTOcdt2aAN6uf8AGL+T4Xu7gTRxSW7R3EPmNhWkjdXROh+8yheAetbNzdQ2dtJc3MqxQxKWeRzhVA7msPTlk8QXUWr3MZSwj+axt5EKtn/nq4z1P8PHAPrQBm62kXjPRYZdEYR61avvt2lnaCWxkZSreYFy3AYgp0b171XvF0vTvDNh4Htb6O4uNsNg43jcicbmfH3SVBwO5IxXSav4X0HXnV9W0eyvXX7rzQqzDp369hTo/Deiw6TNpdrplta2Uw+eK2iEQJ9flxz70AawGBgUtc3pt9d6TqCaJq8sk4kLfYb98fv15PlyYGBIo7/xAZ65rpKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACio5JUiTdI6ovqxwKiu7uCytXurmZY4I13O56YoA5nVIZNN8dr4mvTHDpFrpElvJMXyxkaVGChAMk4XgDkkgDmrul2NxqV5HrerQGOVQfsVo4H+ioe7f9NGHX+790d8xaZa3muX41nVofJton3adYSL80fUedJ/00YHhf4R75rp6ACiiigCKeCK5geGZA8UilWU9CK5vT7u48Pajb6Jqczz2lwdmn3rjJJH/ACxkP97H3W/iAPcV1NVb2yh1G0ktblC0TjBwSpHuCOQR6igDzvxL4k1ax8U3zW9xKq6fe6dbwWg4juVnJEgb354bsVr06uQsYba28RW1prtvFcatHHix1N4gGuUGcgkDAkAJyB1zkeg6+gAooooAKKKKACiiigAooooAKKKKACiiigArE8U6GPEfh660p7lraOYoWkVQSArhu/8Au1rrIj5CurFeDg9K5u8ebxRqDafbyyRaPbv/AKXcRHBuXU/6hT/d/vMP93+9QA2CSfxXqUryQ7PD9swEOf8Al+kB5YjtGpGAD9489AM9VUUcaQxJFGgSNFCqqjAUDoBUtABRRRQBS1LTbTWNPmsL6BZraVdrq38x6H3rJsdUk0vU4NB1abdJKv8AoN2//L0FHzKx6eYOv+0MkDg10dVb6xg1C1Nvcx7kJDA91YHIZT2IPINAHl2gSXjePtNcNJ/aMl9qi6tv3b/s6N+4Vv8AYG6PZ25OO9et1gWGova6odM1WJYrtyRa3fy7b1FA9OjjPKn0yuR036ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArM1zVf7G0mW8ERmk3JFDCGx5srsERc+7MBWnWV4g0t9X0iS3hdEuY5I7i3aT7oljdZE3f7O5Rn2zQBxh0Gw0zWjP41jh1gT/NBqt7GGhtmPWLa2VjXPKtxnOCciq50yFbhfEttax2fhq1lSZbElitzzj7RsztjC5DKAORkntjQvNWtPF00uiavINJs4VX7fZ3cixy3DcHYvP+rHUuv3sgA9ahN9LrjXXgqB/wC1Ld0XzdTiAaKO2LENFI2cebgbcDru3cYNAHo1FFFABRRRQAUUUUAYvilLFvDd4+pLM1vEol/cNtkDKQVKHs27GK5XUbefTvD9tqHjLxBqhunaOCK0025NsGmbhUXy9rO5xzubaOcAAZrpvF+kS674VvrC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+p+K9J0fWLLS72aaO5vHSOIiB2j3OSqKXA2gkg4yaj1fRLXxdo9n5rTQR5EyiS1TeMr0ZJUO08+gNc/e6FrNjeaDo+n6Wt7odpcrdTzGaKBvMD7lJRVHyqfm4GSVFAHU6d4i0/VdUv8AT7Np5JrF/LncwMIw3dQ5G1iPQGotS8T2WnSajC0NxPLYwRTOkChi5kLBI1GeXOw8ehHrWT4Z8P3Nh4q1fVxYDSrW9QCWzWcSrNPvYtP/ALOQQPfuKzX8NWz/ABAuppNOuZmfUba9jnZpNkZSJsvnO3qoUfXHY0AdVe+JbGz06wvVL3CX1zFbQLFgszOfT/ZAZiOvymqeg+OdI8SX9xZacLppLeZ4nLwlR8oBLf7vI5NcdpXhqHSvCnhe7/s+6jvDfvdXXlpJI5Z4ZsuyDJJxtHT2rK+G2nXWk+INCe90zWIv+JQ9qxksbjZDMXjOGZvlUYU9gPxoA9trD0nxTo+uXstpYXRklRS4yjKJEDFS6E/eXcCMis7UfAen6prcuqT3DiWR1battbnBAA+80Zbt61k+CfCGr6HqNg9+YUt9M06TT4vKk3eful3hyMDHyhRj1z2oA9DooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9k=)

### 三、深度优先搜索的优化技巧
1 优化搜索顺序：在一些搜索问题中，搜索树的各个层次，各个分支之间的顺序是不固定的。不同的搜索顺序会产生不同的搜索树形态，其规模大小也相差甚远。

2 排除等效冗余：在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分支执行搜索。

3 可行性剪枝（上下界剪枝）：该方法判断继续搜索能否得出答案，如果不能直接回溯。在搜索过程中，即使对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。

4 最优性剪枝：最优性剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。

5 记忆化：可以记录每个状态的搜索结果，再重复遍历一个状态时直接检索并返回。这好比我们对图进行深度优先遍历时，标记一个节点是否已经被访问过。

![人工智能中的深搜剪枝](http://img1.imgtn.bdimg.com/it/u=942871901,3330226226&fm=26&gp=0.jpg)

## 关于本题

就如前面所说，想要进行深搜剪枝，就要确定剪枝的上下界，想要确定上下界，一般会根据约束条件。

本体的约束条件：由于分解出来的数字不考虑顺序，所以我们假设分解的数字依次递增，所以扩展节点时不能小于前一个扩展节点的值，即a[i-1]<=a[i],这就是“下界”

假设我们已经将N分解成了a[1]加到a[i-1]，则下一个数的最大值是将i-k这k-i+1个数平均分，即m/k-i+1，这就是“上界”。

### 代码详解：

```cpp
cin>>n>>m;
a[0]=1;
dfs(1);
```
这里是输入和深搜的阶段，将分解出来的数组的第一个置为1

```cpp
if(n==0) return ;
```
这里是深度搜索的结束条件，也就是数被分完了

```cpp
if(k==m)
{
	if(n>=a[k-1]) s++;
	return ;
}
```
这里是处理异常情况，分出第K份

```cpp
for(int i=a[k-1];i<=n/(m-k+1);i++)
{
	a[k]=i;
	n-=i;
	dfs(k+1);
	n+=i;
}
```
这里是根据第K份的上下界来求出第K份的值

下面奉上完整的AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[8],s=0;
void dfs(int k)
{
	if(n==0) return ;
	if(k==m)
	{
		if(n>=a[k-1]) s++;
		return ;
	}
	for(int i=a[k-1];i<=n/(m-k+1);i++)
	{
		a[k]=i;
		n-=i;
		dfs(k+1);
		n+=i;
	}
}
int main()
{
	cin>>n>>m;
	a[0]=1;
	dfs(1);
	cout<<s<<endl;
	return 0;
}
```
## 杜绝抄袭，人人做起




---

## 作者：__CJY__ (赞：14)

## 思路
这不是 DFS 板子题吗？实在没什么好讲的……~还是讲讲吧。~

使用递归的方法来尝试所有可能的划分。每次递归处理一个部分，将整数加入当前部分，然后递归处理下一个部分。

从最小的整数开始尝试，将其加入当前部分。继续递归处理，直到构建出 $k$ 个部分。

当所有 $k$ 个部分都被填满时，检查这些部分的整数和是否等于 $n$。如果是，将这种划分计入结果。

为了确保不同顺序的相同划分只被计数一次，规定每个部分中的整数必须不小于该部分之前的最小整数。这通过在递归调用中只尝试从当前整数开始及之后的整数来实现。

剩下的在代码里讲吧。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
void dfs(int l,int p,int s){//l:当前份中最小的整数，p:当前已经划分的份数，s:当前所有份数的整数和
	if(p==k+1){//已经划分了 k 份
		if(s==n) ans++;//增加答案
		return;//返回
	}
	for(int i=l;s+i<=n;i++) dfs(i,p+1,s+i);//一定要从 l 开始，避免重复；s+i<=n 是为了确保不会超过总和 n；递归，作用分别为：成为下一份的最小可能值、进入下一份的划分、更新当前所有份的总和
}
int main(){
	cin>>n>>k,dfs(1,1,0),cout<<ans;
}
```

---

## 作者：New_Void (赞：6)

# [P1025 [NOIP2001 提高组] 数的划分](https://www.luogu.com.cn/problem/P1025)

### 思路

这道题就是一个搜索，重点就是记录一下搜索的步数也就是分了几份，和搜索的和，并且还要加上剪枝。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int ans,n,k;
void dfs(int x,int step,int sum){
    if (step==k+1){ //分的份数足够了
        if (sum==n){ //和也对了
            ans++; //将答案加一
        }
        return ;
    }
    for (int i=x;i+sum<=n;i++){
        dfs(i,step+1,i+sum); //每次都将份数加一，且将现在的和更新
    }
}
int main(){
    cin>>n>>k;
    dfs(1,1,0);
    cout<<ans;
    return 0;
}
```

---

## 作者：langmouren (赞：6)

## P1025 [NOIP2001 提高组] 数的划分 题解
### 题目分析
这道题的难点主要在于需要求不同的方案，并且不论顺序。

观察后发现，所有的答案**一定是**一个单调不下降序列。即：对于任意答案数组 $a$，一定有 $a_{i} \le a_{j}(i < j)$。（如果有 $a_{i} > a_{j}$，那么两数必须交换，化为 $a_{i} < a_{j}$ 的形式，否则会导致答案重复计数。）

那么，我们可以得到 DFS 时的一个规律：已知整数为 $n$，需要将其分为 $k$ 份，当目前搜索到的数是 $a_{j}$ 时，应有 $a_{j-1} \le a_{j} \le \lfloor\frac{n-\sum_{i = 1}^{j-1} a_{i}}{k-j-1}\rfloor$。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k;
int ans;
int sum;//保存已经搜索到的数的和

void dfs(int x,int dep){
	if(dep==k-1){ //当深度达到 k-1 时就不用搜了 因为最后一个值已经确定了
		ans++;
		return;
	}
	sum+=x;
	for(int i=x;i<=(n-sum)/(k-dep);i++){ //i 的值应该大于等于他的上一个数，小于等于 剩余的数/剩余的数量（向下取整）
		dfs(i,dep+1);
	}
	sum-=x;//恢复原状态
}

int main(){
	cin>>n>>k;
	for(int i=1;i<=n/k;i++){
		sum=0;//每次对一个新的数进行 dfs 之前，先清空 sum
		dfs(i,1);
	}
	cout<<ans<<endl;
	return 0;
} 	
```
### 提交记录

[评测记录](https://www.luogu.com.cn/record/200527906)

2025.1.16：对题解中给出的公式进行了修改。

---

## 作者：GSQ0829 (赞：5)

### 思路：
提供一种递归的解法。

首先，一看到题目，就可以想到[第二类 Stirling 数](https://blog.csdn.net/qq_39565901/article/details/86683315)。

那么，递归的几个条件就有了：

- 如果数字是 $0$（~~题目里说了不可能~~），或者只能分成一份（~~也不可能~~），那答案就是一。虽然原本的数字不可能，但是慢慢递归下去，也是有可能的。

- 如果数字小于分的份数，那么数字是多少，分法就有多少种，就是 $\operatorname{dfs}(n, n)$。

- 否则，数字大于等于份数，递归式就是 $\operatorname{dfs}(n, m - 1) + \operatorname{dfs}(n - m, m)$。

这样，就可以算出答案了。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[201][7], n, k;

int dfs(int n, int m) {
	if (n == 0 || m == 1) return 1;// 条件一
	if (n < m) return dfs(n, n);// 条件二
	return dfs(n, m - 1) + dfs(n - m, m);// 条件三
} 

int main() {
	cin >> n >> k;
	cout << dfs(n - k, k) << endl;
	return 0;
}
```

---

## 作者：qhr2023 (赞：4)

## solution

暴搜题。题意就是求 $k$ 个数和为 $n$ 的方案数。

用搜索解决，$sum$ 表示当前选的 $x$ 个数之和，为了避免方案重复，我们记录一个 $lst$，表示上一个数枚举到几了，对于当前数我们从 $lst$ 开始枚举，枚举上界就是 $n-sum$。初始化 $sum$ 和 $x$ 为 $0$，$lst$ 为 $1$。

[通过记录](https://hydro.ac/record/679b06cd34d9362afb2c5c3c)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, ans;
void dfs(int sum, int lst, int x){
	if(x>=k){
		ans+=(sum==n); 
		return;
	}
	for(int i=lst; i+sum<=n; i++) 
		dfs(sum+i, i, x+1);
}
int main(){
	cin >> n >> k; 
	dfs(0, 1, 0); 
	cout << ans;
	return 0;
}
```

---

## 作者：ridewind2013 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1025)

## 题目大意

把 $n$ 分成 $k$ 个数，求不同方案数。

## 思路

暴搜，$k$ 个数的不降序列，这样可以方案不会重复，搜索有三个参数，$x$ 表示该填几个数，$sum$ 表示前 $x-1$ 个数的和，$l$ 表示第 $x-1$ 个数填的多少，要构造不降序列，那么第 $x$ 个数的最小值为 $l$，由于需要 $a_{x} \le a_{x+1} \dots \le a_{k}$，所以最大值为剩余的和除以剩余的数的个数，也就是 $(n-sum)\div(k-x+1)$，这样只用搜索前 $k-1$ 个数，可以保证序列一定不降。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,cnt;
void dfs(int x,int sum,int l){
	if(x>=k){//边界
		cnt++;
		return;
	}
	for(int i=l;i<=(n-sum)/(k-x+1);i++){
		dfs(x+1,sum+i,i);//继续往后搜索
	}
}
int main(){
	cin>>n>>k;
	dfs(1,0,1);//搜索
	cout<<cnt;//输出答案
	return 0;
}
```

---

## 作者：return_second (赞：1)

一道很简单的 dp 题。

设 $dp_{i,j}$ 为把 $i$ 分成 $j$ 个数的方案数。因为拆成一个数只有一种方案，所以把 $dp_{i,0}$ 设为 $1$，状态转移方程是 $dp_{i,j}=dp_{i-1,j-1}+dp_{i-j,j}$。

给出代码：
```cpp
#include<cstdio>
#include<queue> 
using namespace std;
int n,m;
int dp[2005][2005];
//dp[i][j]:把一个数i分拆成j个数的方案数 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		dp[i][1]=1;
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
			if(i>=j)
				dp[i][j]=dp[i-1][j-1]+dp[i-j][j];
	printf("%d\n",dp[n][m]);
	return 0;
} 
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：搜索。  
这题就是分苹果，一模一样。注意到题目有一句话：“每份不能为空，任意两个方案不相同。”那么，什么是相同呢？就是说 $2,2,3$ 和 $3,2,2$ 是重复的，那么，我们可以让分配方案中的每一份都递增。我们用 $ans$ 数组存储答案，每次从 $ans_{x-1}$ 开始枚举到 $n-sum$。这里的 $sum$ 就是剩下的数的和，因为如果和超过了 $n$ 那么这个方案就不成立了。在循环时，如果这个数没有用过，就存进答案，看下一个数，否则退回来，把标记也变成 $0$，和减去 $i$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e5+5;
int n,k;
int ans[maxn];
int sum=0;
int total=0;
void dfs(int x)
{
	if(x>k)
	{
		if(sum==n) total++;
		return ;
	}
	for(int i=ans[x-1];i<=n-sum;i++)
	{
		if(i==0) continue;
		ans[x]=i;
		sum+=i;
		dfs(x+1);
		
		ans[x]=0;
		sum-=i;
	}
}
signed main()
{
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	dfs(1);
	cout<<total; 
	return 0;
} 
```

---


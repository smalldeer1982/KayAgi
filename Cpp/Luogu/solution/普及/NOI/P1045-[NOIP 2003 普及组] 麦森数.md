# [NOIP 2003 普及组] 麦森数

## 题目描述

形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。

任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）


## 说明/提示

**【题目来源】**

NOIP 2003 普及组第四题

## 样例 #1

### 输入

```
1279
```

### 输出

```
386
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000104079321946643990819252403273640855
38615262247266704805319112350403608059673360298012
23944173232418484242161395428100779138356624832346
49081399066056773207629241295093892203457731833496
61583550472959420547689811211693677147548478866962
50138443826029173234888531116082853841658502825560
46662248318909188018470682222031405210266984354887
32958028878050869736186900714720710555703168729087
```

# 题解

## 作者：FjswYuzu (赞：25)

注意：下列代码因为作者脸黑常数大，所以不一定能够在不吸氧/改用scanf和printf的情况下AC，见谅

---

首先看数据范围:$1000<P<3100000$，求$2^P-1$的位数及后500位。很明显这是一道高精题目，所以先把vector重载高精度模板搬来。看着模板高兴的交了上去，只有0分。所以我们要考虑优化了。

---

问题拆分成两半，第一问求位数，$2^P(P>1000)$的末尾为$2,4,6,8$，所以绝不会有退位的风险，所以可以直接套用公式得到位数为$log_{10}2*P+1$，转化成int后即可输出（当然打表也可以，但是考场上挂着跑半天不好吧...）

第二问求$2^P-1$的后500位。我们已经求出位数，如果位数小于500，输出500-位数个0，然后直接...?

我们发现我们的高精模板只能整个输出？因为这个是vector，所以还是滋磁vector基本的操作。用迭代器！但是请注意用反向迭代器，因为我们储存数字时是倒序存储的。

暴力连乘$P$次，交上去竟然全部超时！

我们该怎么办呢？

~~我会FFT！我会压位高精！~~

我会快速幂！

这时候我们就可以用高精快速幂来求$2^P$，让我们原来的$\Theta (P)$变成更高效的$\Theta log_2(P)$，__最后取个模就OK啦！__

Tip:如果还不会快速幂的请往[这边](https://www.luogu.org/problemnew/show/P1226)

仍然超时，只有40

~~果然脸黑~~

---

我们发现时间主要出在乘这个部分上，位数都可以乘到几十万，当然常数很大。所以我们要介绍一个性质

$$(a \times b)\text{ }mod\text{ }p=((a\text{ }mod\text{ }p) \text{ }\times \text{ }(b\text{ }mod\text{ }p))\text{ }mod \text{ }p$$

有了这个性质，我们发现我们可以在进行快速幂的同时进行取余运算，位数最大500位，让速度快了许多

注：该代码为C++11标准，不保证不吸氧过的了

```cpp
#include<algorithm>
#include<cstring>
#include<random>
#include<iostream>
#include<vector>
#include<string>
#include<cmath>
using namespace std;
struct Wint:vector<int>
{
    Wint(int n=0)
    {
        push_back(n);
        check();
    }
    Wint& check()
    {
        while(!empty()&&!back())pop_back();
        if(empty())return *this;
        for(int i=1; i<size(); ++i)
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;
    }
};
istream& operator>>(istream &is,Wint &n)
{
    string s;
    is>>s;
    n.clear();
    for(int i=s.size()-1; i>=0; --i)n.push_back(s[i]-'0');
    return is;
}
ostream& operator<<(ostream &os,const Wint &n)
{
    if(n.empty())os<<0;
    else	for(int i=n.size()-1; i>=0; --i)os<<n[i];
    return os;
}
bool operator!=(const Wint &a,const Wint &b)
{
    if(a.size()!=b.size())return 1;
    for(int i=a.size()-1; i>=0; --i)
        if(a[i]!=b[i])return 1;
    return 0;
}
bool operator==(const Wint &a,const Wint &b)
{
    return !(a!=b);
}
bool operator<(const Wint &a,const Wint &b)
{
    if(a.size()!=b.size())return a.size()<b.size();
    for(int i=a.size()-1; i>=0; --i)
        if(a[i]!=b[i])return a[i]<b[i];
    return 0;
}
bool operator>(const Wint &a,const Wint &b)
{
    return b<a;
}
bool operator<=(const Wint &a,const Wint &b)
{
    return !(a>b);
}
bool operator>=(const Wint &a,const Wint &b)
{
    return !(a<b);
}
Wint& operator+=(Wint &a,const Wint &b)
{
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0; i!=b.size(); ++i)a[i]+=b[i];
    return a.check();
}
Wint operator+(Wint a,const Wint &b)
{
    return a+=b;
}
Wint& operator-=(Wint &a,Wint b)
{
    for(int i=0; i!=b.size(); a[i]-=b[i],++i)
        if(a[i]<b[i])
        {
            int j=i+1;
            while(!a[j])++j;
            while(j>i)
            {
                --a[j];
                a[--j]+=10;
            }
        }
    return a.check();
}
Wint operator-(Wint a,const Wint &b)
{
    return a-=b;
}
Wint operator*(const Wint &a,const Wint &b)
{
    Wint n;
    n.assign(a.size()+b.size()-1,0);
    for(int i=0; i!=a.size(); ++i)
        for(int j=0; j!=b.size(); ++j)
            n[i+j]+=a[i]*b[j];
    return n.check();
}
Wint& operator*=(Wint &a,const Wint &b)
{
    return a=a*b;
}
Wint divmod(Wint &a,const Wint &b)
{
    Wint ans;
    for(int t=a.size()-b.size(); a>=b; --t)
    {
        Wint d;
        d.assign(t+1,0);
        d.back()=1;
        Wint c=b*d;
        while(a>=c)
        {
            a-=c;
            ans+=d;
        }
    }
    return ans;
}
Wint operator/(Wint a,const Wint &b)
{
    return divmod(a,b);
}
Wint& operator/=(Wint &a,const Wint &b)
{
    return a=a/b;
}
Wint& operator%=(Wint &a,const Wint &b)
{
    divmod(a,b);
    return a;
}
Wint operator%(Wint a,const Wint &b)
{
    return a%=b;
}
Wint pow(const Wint &n,const Wint &k)//虽然这已经是快速幂，但是因为有问题所以还是不要用啦
{
    if(k.empty())return 1;
    if(k==2)return n*n;
    if(k.back()%2)return n*pow(n,k-1);
    return pow(pow(n,k/2),2);
}//以上皆为重载高精
int main(){
    int p;
    cin>>p;
    Wint ans=1,m=2,k=1;
    cout<<int(log10(2)*p+1)<<endl;//直接输出位数
    for(int i=1;i<=500;++i)	k*=10;
    for(;p;p>>=1,m=m*m%k)	if(p&1)	ans=ans*m%k;//快速幂
    ans-=1;//一定要减1！因为这里没写--这个运算符所以只能这么写
    int sis=500-ans.size();
    int t=0;
    if(sis<0);
    else
	{
		for(int i=1;i<=sis;++i)
	    {
	        cout<<0;
	        if(i%50==0)	cout<<endl;
	    }
		t=sis;
	}//输出0
    for(auto i=ans.rbegin();i!=ans.rend() && t<=500;++i)//rbegin及rend为反向迭代器，其实就是倒着输出
    {
        ++t;
        cout<<*i;//注意输出
        if(t%50==0)	cout<<endl;
    }
    return 0;
}
```

至此，我们得到了一份高精模板，一些关于STL的知识，一个叫做快速幂的优化算法以及一条取余运算的性质，~~同时得到了至理名言：STL和O2更配哦~~

温馨提示：或许还需要一些卡常技巧，毕竟NOIp不开O2嘛

---

## 作者：pohseseridinagms (赞：20)

首先，我们来思考如何计算 $2^p-1$ 的位数，由于 $2^p$ 的个位不可能是 $0$，故 $2^p-1$ 与 $2^p$ 的位数必然是相同的。

设 $2^p$ 的位数为 $k$，则有不等式：

$$
10^k>2^p>10^{k-1}
$$ 

变形可以得到：

$$
k>\log_{10}{2^p}>k-1
$$

根据对数的运算法则又可以进行一次变形：

$$
k>p×\log_{10}{2}>k-1
$$

故其位数为 $[p×\log_{10}{2}+1]$，其中 $[x]$ 为不超过 $x$ 的最大整数。

可以使用库函数：
```cpp
log10(x)
```

接下来考虑如何计算 $2^p-1$ 的后 $500$ 位，$p$ 很大，我想到了快速幂和高精度乘法来解决，下面是基础的快速幂。

大家都知道，对于 $a^b$：

若 $b$ 是偶数，有 $a^b=(a^{\frac {b} {2}})^2$。 \
若 $b$ 是奇数，有 $a^b=(a^{\frac {b-1} {2}})^2 × a$。

那么我们就可以写出：
```cpp
//这里是计算a的b次方对mod取余的结果。
long long quick_pow(long long a,long long b,long long mod){
    long long res=1; //因为是幂运算，res要是1不能是0
    while(b){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
```

因为是高精度，所以这里有几个地方要修改，修改过后的代码：
```cpp
void quick_pow(int p){
    res[0]=1,a[0]=2;
    while(p){
        if(p&1) multiply1(); //高精度乘法1
        multiply2(); //高精度乘法2
        p>>=1;
    }
}
```
这个问题就完美地解决了。最后需要注意是 50 个为一行。

**Code**

```cpp
#include<bits/stdc++.h>
int n,a[1010],res[1010],cnt;
void multiply1(){ //高精度乘法模板1
    int tmp[1010]={0};
    for(int i=0;i<500;i++){
        for(int j=0;j<500;j++) tmp[i+j]+=res[i]*a[j];
    }
    int t=0;
    for(int i=0;i<500;i++){
        tmp[i]+=t;
        res[i]=tmp[i]%10;
        t=tmp[i]/10;
    }
}
void multiply2(){ //高精度乘法模板2
    int tmp[1010]={0};
    for(int i=0;i<500;i++){
        for(int j=0;j<500;j++) tmp[i+j]+=a[i]*a[j];
    }
    int t=0;
    for(int i=0;i<500;i++){
        tmp[i]+=t;
        a[i]=tmp[i]%10;
        t=tmp[i]/10;
    }
}
void quick_pow(int p){ //快速幂
    res[0]=1,a[0]=2;
    while(p){
        if(p&1) multiply1();
        multiply2();
        p>>=1;
    }
}
int main(){
    scanf("%d",&n);
    int length=n*log10(2)+1;
    printf("%d\n",length);
    quick_pow(n);
    res[0]-=1; //为什么能减1？因为不可能退位
    for(int i=499;i>=0;i--){
        if(cnt==50) printf("\n"),cnt=0; //每50个要记得换行
        printf("%d",res[i]);
        cnt++;
    }
    return 0;
}
```

---

## 作者：o1__1o (赞：14)

# P1045[NOIP 2003 普及组]麦森数题解

## 题目描述

输入 $P(1000<P<3.1 \times 10^5)$。

计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）。

---------------------------------------

## 题目分析

这道题要用到高精度和快速幂。

本题要求计算 $2^P(P \le 3.1 \times 10^5)$ 的最后 $t ( t = 500 )$ 位，必然要用到高精度，用数组来存储每一位的值，我们将 $k_1$ 定义为 $2^P$ 在十进制中的位数。

如果用普通高精度思路直接运算来做，会超时，时间复杂度达到了 $O(P \times \log ( k_1))$。

通过 $2^P$ 就想到了快速幂（二进制取幂）来优化。

快速幂主要思路：

 $$
 \textstyle a ^ {2 \times b + 1} = a^ {2 \times b} \times a
 $$ 

 $$
 \textstyle a ^ {2 \times b} = a ^ b \times a ^ b
 $$ 

定义 $f$ 数组用于存储当前需要平方的基数，初始值为 $2$，表示 $2^ 1 =2$。$l$ 数组用于存储累积计算结果，保存 $2^P$ 的高精度值，初始值为 $1$，$f_1$ 表示个位，$f_2$ 表示十位，以此类推。

用循环从末尾往前位实现，在二进制中，最后一位若为 $1$，则乘上该位所对应的二次幂的值，即执行 $l = l \times f$。$f $ 每次循环 $ \times 2$。

举例：$P=5$（二进制 $101$）时：

1. 第一次循环：$P=5$（末位 $1$），$l= 1 \times 2 =2$，$f= 2 ^ 2 =4$，$P=2$。

2. 第一次循环：$P=2$（末位 $0$），$f= 4 ^ 2 =16$，$P=1$。

3. 第三次循环：$P=1$（末位 $1$），$l= 2 \times 16 =32$，$f= 16 ^ 2 =256$，$P=0$。

最终结果：$2^ 5 =32$。

我们将 $k_2$ 定义为 $P$ 在二进制中的位数，这时时间复杂度为 $O(k_2 \times t^2)$。

---------------------------------------

## 题目代码

### 超详细注释代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int p;
int f[1005],l[1005];
int s[1005];//用于存储高精度乘法的中间计算
//函数s1：计算 l=l*f（结果乘以当前基数）
void s1(){
    memset(s,0,sizeof(s));//清空临时数组
    for(int i=1;i<=500;i++){
        for(int j=1;j<=500;j++){
            s[i+j-1]+=l[i]*f[j];//l的每一位乘以f的每一位
        }
    }
    //处理进位
    for(int i=1;i<=500;i++){
        s[i+1]+=s[i]/10;//进位到高位
        s[i]%=10;//当前位保留个位数
    }
    memcpy(l,s,sizeof(l));//将结果复制回l数组
}
//函数s2：计算f=f*f（基数平方），方法同函数s1
void s2(){
    memset(s,0,sizeof(s));
    for(int i=1;i<=500;i++){
        for(int j=1;j<=500;j++){
            s[i+j-1]+=f[i]*f[j];
        }
    }
    for(int i=1;i<=500;i++){
        s[i+1]+=s[i]/10;
        s[i]%=10;
    }
    memcpy(f,s,sizeof(f));
}
int main(){
    cin>>p;
    //计算2^P-1的位数公式：log10(2^P)=P*log10(2)，加1得到位数
    cout<<(int)(log10(2)*p+1);
    l[1]=1;
    f[1]=2;
    //通过二进制分解P
    while(p!=0){
        if(p%2==1){
            s1();
        }
        p/=2;//去掉p二进制中的最后一位
        s2();
    }
    //直接对个位减1，因为末尾只可能是2，4，6，8
    l[1]-=1;
    //输出需从高位到低位输出，因为逆序存储
    for(int i=500;i>=1;i--) {
        if(i%50==0)cout<<"\n";//每50位换行
        cout<<l[i];
    }
    return 0;
}
```

### 无注释放心食用代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int p,f[1005],l[1005],s[1005];
void s1(){
    for(int i=1;i<=500;i++){
        for(int j=1;j<=500;j++){
            s[i+j-1]+=l[i]*f[j];
        }
    }
    for(int i=1;i<=500;i++){
        s[i+1]+=s[i]/10;
        s[i]%=10;
    }
    memcpy(l,s,sizeof(l));
}
void s2(){
    memset(s,0,sizeof(s));
    for(int i=1;i<=500;i++){
        for(int j=1;j<=500;j++){
            s[i+j-1]+=f[i]*f[j];
        }
    }
    for(int i=1;i<=500;i++){
        s[i+1]+=s[i]/10;
        s[i]%=10;
    }
    memcpy(f,s,sizeof(f));
}
int main(){
    cin>>p;
    cout<<(int)(log10(2)*p+1);
    l[1]=1;
    f[1]=2;
    while(p!=0){
        if(p%2==1){
            memset(s,0,sizeof(s));
            s1();
        }
        p/=2;
        s2();
    }
    l[1]-=1;
    for(int i=500;i>=1;i--) {
        if(i%50==0)cout<<"\n";
        cout<<l[i];
    }
    return 0;
}
```

### 压缩版代码：

```cpp
#include<bits/stdc++.h>
using namespace std;int p,f[1005],l[1005],s[1005];int main(){cin>>p;cout<<(int)(log10(2)*p+1);l[1]=1;f[1]=2;while(p!=0){if(p%2==1){memset(s,0,sizeof(s));for(int i=1;i<=500;i++){for(int j=1;j<=500;j++){s[i+j-1]+=l[i]*f[j];}}for(int i=1;i<=500;i++){s[i+1]+=s[i]/10;s[i]%=10;}memcpy(l,s,sizeof(l));}p/=2;memset(s,0,sizeof(s));for(int i=1;i<=500;i++){for(int j=1;j<=500;j++){s[i+j-1]+=f[i]*f[j];}}for(int i=1;i<=500;i++){s[i+1]+=s[i]/10;s[i]%=10;}memcpy(f,s,sizeof(f));}l[1]-=1;for(int i=500;i>=1;i--){if(i%50==0)cout<<"\n";cout<<l[i];}}
```

---------------------------------------

#### 写题解不易，记得点个赞再走吧。

---

## 作者：hyx761 (赞：12)

这道题目看上去十分简单，只需要算出 $2^p-1\mod10^{500}$ 的值就可以了，看似是一道高精度模板题

但是当我们写好高精度的时候就会发现超时了，$P$ 的最大值会达到 $3100000$，乘以要维护的 $500$ 位数，就达到了 $1.55\times10^9$ 次的运算。因此我们需要改进。

改进的方法有很多，例如在高精度乘法时不是每次乘以 $2$，而是 $2^n$。考虑到 `unsigned long long`最多只能够表示 $2^{64}-1$，我们可以每 $2^{60}$ 进行一次乘法，这样所需要的运算次数就降低到了约 $2.58\times10^7$，已经是在可接受范围内了。

另外计算位数，我们可以通过对数的基本性质：$\log_a{b^n}=n\log_ab$，把 $2^P$ 的计算回避掉，从而变成 $\lfloor p\lg2\rfloor+1$。

综上所述，就可以得到以下代码：

```cpp
#include <iostream>
#include <cmath>
using namespace std;
unsigned long long a[510] = {0, 1}, t;
int p;
int main()
{
    cin >> p;
    cout << (int)(p * log10(2)) + 1 << endl;
    for (; p >= 0; p -= 60)
    {
        t = 0;
        for (int j = 1; j <= 500; j++)
        {
            if (p >= 60) a[j] <<= 60;
            else a[j] <<= p;
            a[j] += t;
            t = a[j] / 10;
            a[j] %= 10;
        }
    }
    a[1] -= 1;
    for (int i = 500; i >= 1; i--) 
    {
        cout << (char)('0' + a[i]);
        if (i % 50 == 1) cout << endl;
    }
    return 0;
}
```

---

## 作者：Imerance1018 (赞：3)

提供封装结构体的高精快速幂板子。

## Solution

第一问求的是 $\lceil\log_{10}{(2^p-1)}\rceil=\lceil p \log_{10}{2}\rceil$，直接输出。

对于第二问，我们使用快速幂。需要实现 $500$ 位的高精乘高精，过程中保留后 $500$ 位即可。

重点在代码。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=510;

struct Bignum   //养成好习惯
{
    int val[N],len;
    void init()
    {
        memset(val,0,sizeof(val));
        len=0;
    }
    Bignum operator *(const Bignum &x)const
    {
        Bignum res;
        res.init();
        res.len=min(len+x.len,500ll);
        for(int i=0;i<len;i++)
            for(int j=0;j<x.len&&i+j<500;j++)
                res.val[i+j]+=val[i]*x.val[j];
        for(int i=0;i<res.len;i++)
        {
            if(res.val[i]>=10)
            {
                res.val[i+1]+=res.val[i]/10;
                res.val[i]%=10;
            }
        }
        while(res.val[res.len]&&res.len+1<500)
        {
            if(res.val[res.len]>=10)
            {
                res.val[res.len+1]+=res.val[res.len]/10;
                res.val[res.len]%=10;
            }
            res.len++;
        }
        res.val[res.len]=0;
        return res;
    }
    void print()
    {
        val[0]--;     //末位显然不可能是 0，减 1 即可
        for(int i=499;i>=0;i--)
        {
            cout<<val[i];
            if(i%50==0)cout<<"\n";
        }
    }
};

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int p;
    cin>>p;
    cout<<ceil(p*log10(2))<<"\n";
    Bignum ji,base;
    ji.len=base.len=1;
    ji.val[0]=1,base.val[0]=2;
    while(p)
    {
        if(p&1)ji=ji*base;
        base=base*base;
        p>>=1;
    }
    ji.print();
    return 0;
}
``````

---

## 作者：ryderyang (赞：3)

在这篇题解中，我会从三个方面讲解我的解题思路。
# 位数统计公式
对于 $2^p - 1$ 的位数，我们可以这么推导：

  - 因为 $2^p$ 的个位不可能是 $0$，所以 $2^p-1$ 的位数肯定跟 $2^p$ 的位数相等。
  - 根据对数的乘幂法则：$\log_{10}{2^p} = p \times \log_{10}{2}$。
  - 因此，计算位数的公式为 $p \times \log_{10}{2} + 1$。

# 快速幂
这里借鉴了[这篇文章](https://www.luogu.com.cn/article/2uvjodof)。

步骤如下：

  - 初始化 $ans$ 为 $1$。
  - 遍历 $b$ 在二进制里的每一位：

    - 如果这一位是 $1$，那么 $ans$ 的值乘上 $a$。
    - 将 $a$ 的值改为 $a^2$，计算下一位。
  - 返回答案

## 代码

```cpp
int quick_pow(int a,int b)//计算a的b次方
{
	int ans=1;
	while(b)
	{
		if(b&1)
		ans*=a;
		b>>=1;
		a*=a;
	}
	return ans;
}
```
# 高精度乘法
由于 $p$ 的值非常大，我们需要用高精度。

一些关键点：

  - 我们可以用向量储存数字。
  - 我们只需要记录 $500$ 位的数字就够了。

由于这里的高精度乘法不是关键，我就不细讲了，有需要的可以去看[这道题的题解](https://www.luogu.com.cn/article/pxfpoeoi)。

## 代码

```cpp
vector<int> mul(vector<int> &a,vector<int> &b)
{
	vector<int> res(501,0);
	for(int i=0;i<a.size();i++)
	{
		for(int j=0;j<b.size();j++)
		{
			if(i+j>500)
			break;
			res[i+j]+=a[i]*b[j];
			res[i+j+1]+=res[i+j]/10;
			res[i+j]%=10;
		}
	}
	return res;
}
```
最后，只要把这几部分拼在一起，就能 AC 了。注意一下输出的格式。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int p;
vector<int> mul(vector<int> &a,vector<int> &b)
{
	vector<int> res(501,0);
	for(int i=0;i<a.size();i++)
	{
		for(int j=0;j<b.size();j++)
		{
			if(i+j>500)
			break;
			res[i+j]+=a[i]*b[j];
			res[i+j+1]+=res[i+j]/10;
			res[i+j]%=10;
		}
	}
	return res;
}
int main()
{
	scanf("%d",&p);
	int ans1=log10(2)*p+1;
	printf("%d\n",ans1);
	vector<int> a(1,2);
	vector<int> ans2(1,1);
	while(p)
	{
		if(p&1)
		{
			ans2=mul(ans2,a);
		}
		a=mul(a,a);
		p>>=1;
	}
	ans2[0]-=1;
	for(int i=499,j=1;i>=0;i--,j++)
	{
		cout<<ans2[i];
		if(j%50==0)
		printf("\n");
	}
	return 0;
}
```

---

## 作者：MrPython (赞：3)

一篇 python 题解。

先看第一问。一个数 $x$ 的位数，相当于 $\log_{10} x + 1$。用我们小学二年级就学过的换底公式，可以得到：
$$\log_{10} 2^{P} + 1 = \dfrac{\log_{2} 2^P}{\log_{2} 10}+1=\dfrac{P}{\log_{2}10}+1$$

再看第二问，要我们求出 $2^P \bmod 10^{500}$ 的值。python 中的 `pow` 函数还可以接受一个参数，表示结果对其取模。`pow` 函数内部使用快速幂实现，速度非常快，同时其边算边取模避免浪费大量时间。

手写高精题，一边玩去。

```python
from math import log2

n = int(input())
print(int(n / log2(10)) + 1)
P = pow(10, 500)
x = pow(2, n, P)
x = (x - 1) % P
s = str(x)
s = '0' * (500 - len(s)) + s
for i in range(10):
    for j in range(50):
        print(s[i * 50 + j], end="")
    print()
```

---

## 作者：chen_zi_lang (赞：2)

# 题解
# [题目传送门](https://www.luogu.com.cn/problem/P1045)  
## 一、题面描述  
给定正整数 $p$，求 $2^p-1$ 的位数与后 $500$ 位数，不足部分使用高位 $0$ 补齐。
## 二、思路
注意到，数据范围 $1000<p<3100000$，所以考虑使用高精度算法，但由于数据量极大，所以暴力乘出答案是不可能的，于是可以使用快速幂算法，考虑到只用求后 $500$ 位数，便可以使用[同余定理](https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360)，在快速幂的同时取模 $10^{500}$，算出后再减去 $1$ 所以整体思路就是：**高精度+快速幂取模**。
## 三、答案
求 $2^p-1$ 的位数，可以根据[对数运算法则](https://blog.csdn.net/qq_42672770/article/details/120819650)求出公式：
$$\log_{10}2\times p+1$$
求 $2^p-1$的后 $500$ 位数就是：
$$2^p \bmod 10^{500} - 1$$
## 四、代码
代码方面我选择使用高精度重载，利用快速幂算出 $2^p$ 后减去 $1$，再将十进制高精度数转换为字符串，不满 $500$ 高位补 $0$，最后分 $10$ 行输出。以下是完整代码（含注释），顺便附赠一份高精度重载模版：
``` cpp
#include <bits/stdc++.h> 
using namespace std;
const int MAXN=1005;
struct bign{
    int len=1,s[MAXN];
    bool sign=0;
    bign(){
        memset(s,0,sizeof s);
        len=1; 
        sign=0;
    }
    bign(int num){
        *this = num; 
    }
    bign(const char *num){
        *this=num; 
    }
    bign operator=(int num){
        memset(s, 0, sizeof s);
        sign=num<0;
        num=std::abs(num);
        len=0;
        do{
            s[len++]=num % 10;
            num/=10;
        }while(num);
        clean();
        return *this;
    }
    bign operator=(const char *num) {
        memset(s,0,sizeof s);
        sign=0;
        len=0;
        const char *p=num;
        if(*p=='-'){
            sign=1;
            p++;
        }
        while(*p=='0'&&*(p+1)!='\0')p++;
        len=strlen(p);
        if(len==0){
            len=1;
            s[0]=0;
            sign=false;
            return *this;
        }
        for(int i=0;i<len;i++)s[i]=p[len-i-1]-'0';
        clean();
        return *this;
    }
    void clean(){
        while(len>1&& !s[len-1]) len--;
        if(len==1&&s[0]==0)sign=0;
    }
    bign abs()const{
        bign res=*this;
        res.sign=0;
        return res;
    }
    bool operator<(const bign &b)const{
        if(sign!=b.sign)return sign;
        if(len!=b.len)return (len<b.len)^sign;
        for(int i=len-1;i>=0;i--)if(s[i]!=b.s[i])return (s[i]<b.s[i])^sign;
        return 0;
    }
    bool operator>(const bign &b)const{
        return b<*this; 
    }
    bool operator<=(const bign &b)const{
        return !(b<*this); 
    }
    bool operator>=(const bign &b)const{
        return !(*this<b); 
    }
    bool operator==(const bign &b)const{
        return !(*this<b)&&!(b<*this); 
    }
    bool operator!=(const bign &b)const{
        return !(*this==b); 
    }
    bign operator+(const bign &b)const{
        if(sign!=b.sign){
            bign t=b;
            t.sign=!t.sign;
            return *this-t;
        }
        bign c;
        c.len=0;
        c.sign=sign;
        for(int i=0,g=0;g||i<max(len,b.len);i++){
            int x=g;
            if(i<len)x+=s[i];
            if(i<b.len)x+=b.s[i];
            c.s[c.len++]=x%10;
            g=x/10;
        }
        c.clean();
        return c;
    }
    bign operator-(const bign &b)const{
        if(sign!=b.sign) {
            bign t=b;
            t.sign=!t.sign;
            return *this+t;
        }
        if(abs()<b.abs()){
            bign res=b-*this;
            res.sign=!sign;
            return res;
        }
        bign c;
        c.len=0;
        for(int i=0,g=0;i<len;i++){
            int x=s[i]-g;
            if(i<b.len)x-=b.s[i];
            if(x>=0)g=0;
            else{
                g=1;
                x+=10;
            }
            c.s[c.len++]=x;
        }
        c.clean();
        return c;
    }
    bign operator*(const bign &b)const{
        bign c;
        c.len=len+b.len;
        for(int i=0;i<len;i++)
            for(int j=0;j<b.len;j++)
                c.s[i+j]+=s[i]*b.s[j];
        for(int i=0;i<c.len;i++){
            c.s[i+1]+=c.s[i]/10;
            c.s[i]%=10;
        }
        c.sign=sign ^ b.sign;
        c.clean();
        return c;
    }

    bign operator/(const bign &b)const{
        bign c,f=0;
        for(int i=len-1;i>=0;i--){
            f=f*10;
            f.s[0]=s[i];
            while(f>=b.abs()){
                f-=b.abs();
                c.s[i]++;
            }
        }
        c.len=len;
        c.sign=sign^b.sign;
        c.clean();
        return c;
    }
    bign operator%(const bign &b)const{
        return *this-(*this/b)*b;
    }
    bign& operator+=(const bign &b){
        *this=*this+b; 
        return *this; 
    }
    bign& operator-=(const bign &b){
        *this=*this-b; 
        return *this; 
    }
    bign& operator*=(const bign &b){
        *this=*this*b; 
        return *this; 
    }
    bign& operator/=(const bign &b){
        *this=*this/b; 
        return *this; 
    }
    bign& operator%=(const bign &b){
        *this=*this%b; 
        return *this; 
    }
    string str()const{
        if(len==1&&s[0]==0)return "0";
        string res="";
        if(sign)res+="-";
        for(int i=0;i<len;i++)res=char(s[i]+'0')+res;
        return res;
    }
};//以上为高精度重载模版
istream& operator>>(istream &in, bign &x) {
    string s;
    in>>s;
    x=s.c_str();
    return in;
}
ostream& operator<<(ostream &out,const bign &x){
    out << x.str();
    return out;
}
bign a=1,mod=1,m=2;
int n;
void make(){//构造mod
    for(int i=0;i<500;i++){
        mod=mod*10;
    }
}
bign pow(const bign &base, bign x){//快速幂
    if(x==0)return bign(1);
    if(x==1)return base;
    bign res=1,cur=base;
    while(x>0){
        if(x%2==1) {
            res=res*cur%mod;
        }
        cur=cur*cur%mod;
        x=x/2;
    }
    return res%mod;
}
int main(){
    make();
    scanf("%d",&n);
    int len=int(n*log10(2)+1);//计算位数
    printf("%d\n",len);
    a=pow(m,n)%mod;//2^p对10^500取模的余数
    a=a-1;
    string st=a.str();//转换为字符串
    while(st.size()<500){//高位补0
        st='0'+st;
    }
    for(int i=0;i<10;i++){//输出
        for(int j=0;j<50;j++){
            cout<<st[i*50+j];
        }
        cout<<endl;
    }
    return 0;
}
```

---


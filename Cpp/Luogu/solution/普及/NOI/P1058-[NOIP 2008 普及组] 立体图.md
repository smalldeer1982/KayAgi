# [NOIP 2008 普及组] 立体图

## 题目描述

小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。

小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：

$$
\def\arraystretch{1e-10}
\begin{aligned}
&\verb!  +---+!\\
&\verb! /   /|!\\
&\verb!+---+ |!\quad\textsf{高}\\
&\verb!|   | +!\\
&\verb!|   |/ !\quad\textsf{宽}\\
&\verb!+---+  !\\
& \quad\textsf{长}
\end{aligned}$$


每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：

若两块积木左右相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+---+!\\
\verb!./   /   /|!\\
\verb!+---+---+ |!\\
\verb!|   |   | +!\\
\verb!|   |   |/.!\\
\verb!+---+---+..!\\
\end{aligned}
$$

若两块积木上下相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+!\\
\verb!./   /|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/.!\\
\verb!+---+..!\\
\end{aligned}
$$

若两块积木前后相邻，图示为：

$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!....+---+!\\
\verb!.../   /|!\\
\verb!..+---+ |!\\
\verb!./   /| +!\\
\verb!+---+ |/.!\\
\verb!|   | +..!\\
\verb!|   |/...!\\
\verb!+---+....!\\
\end{aligned}
$$

立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。


## 说明/提示

NOIP2008普及组第四题


## 样例 #1

### 输入

```
3 4
2 2 1 2
2 2 1 1
3 2 1 2
```

### 输出

```
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......```

# 题解

## 作者：ZUTTER_ (赞：310)

重点重点啦（敲黑板）：**思路**是先把图形存在数组中，然后从后往前，从下往上，从左往右依次覆盖。

###例
```cpp
               +---+     +---+          +---+        
              /   /|    /   /|         /   /|        
             +---+ |   +---+ |        +---+ |        
     +---+   |   | +   |   | +---+    |   | +---+    
    /   /|   |   |/|   |   |/   /|    |   |/   /|    
   +---+ |   +---+ |   +---+---+ |    +---+---+ |    
   |   | +   |   | +   |   |   | +   /   /|   | +    
   |   |/    |   |/    |   |   |/   +---+ |   |/     
   +---+     +---+     +---+---+    |   | +---+      
                                    |   |/           
                                    +---+            
```
重点是要找到每个立方体输出的**位置**，程序里有讲


至于输出每个立方体，~~打个表~~就好了吖(￣▽￣)／


##程序


```cpp
#include<iostream>
#include<stdio.h>

using namespace std;

int i,m,n,j,k,l,o,p,a[1001][1001],ma[1001],maxx,maxy,z[6]={2,1,0,0,0,0},s[6]={6,6,6,6,5,4};

char c[1001][1001],c1[10][10]={
"  +---+",
" /   /|",
"+---+ |",
"|   | +",
"|   |/",
"+---+",
};//打表(￣▽￣)／

void fg(int x,int y)
{
    int i,j;
    for(i=5;i>=0;i--)//立方体需要倒过来存入数组
        for(j=z[i];j<=s[i];j++)//分别是这一行的宽度
        {
            c[5-i+x][j+y]=c1[i][j];
            if(5-i+x>maxx) maxx=5-i+x;
            if(j+y>maxy) maxy=j+y;//分别记录最大长宽
        }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=0;j<m;j++)
            scanf("%d",&a[i][j]);
    for(o=1;o<=n;o++)//层数
        for(k=0;k<m;k++)//列循环
            for(l=0;l<a[o][k];l++)//高度
                fg((n-o)*2+1+3*l,(n-o)*2+1+4*k);//表示立方体左下角位置

    for(i=maxx;i>=1;i--)
    {    
        for(j=1;j<=maxy;j++)
            if(c[i][j]=='\000') printf(".");
            else printf("%c",c[i][j]);
        printf("\n");
    }
}
```
~~居然做出了第四题，鸡冻到内牛满面(\*/ω＼\*)~~


---

## 作者：Sino_E (赞：37)

有点复杂的模拟。

为了方便，坐标用平面直角坐标系的第一象限来表示，转换到二维数组需要注意一些细节。

大体绘制思路：定位这个立方体在二维平面的左下角坐标进行绘制，从下到上，从左往右，从前往后。上把下覆盖，右把左覆盖，前把后覆盖。

观察这个正方形：

 ![](https://cdn.luogu.com.cn/upload/pic/7650.png) 

我们发现我们只用绘制三个面。根据坐标的规律，我们分别对这一块的坐标进行绘制。

同时我们可以发现这个图形坐标的规律。假设一个立方体的高度为z,所在坐标为x,y（整个矩阵中，左下角的坐标为(0,0)）坐标，那么这个立方体的左下角坐标为：

$x=2*y+4*x$

$y=2y+3z$

通过上面的图，也可以知道整个图的右上角坐标为：

$x=2y+4x+6$

$y=2y+3z+5$

我们将这个右上角坐标取最大值，就是整张图的范围。

然后按照顺序进行绘制就可以了。注意，无论是输入还是输出还是处理，都要使用【左下角】坐标是(0,0)的思想，这样会使过程更加直观容易理解，但如果写代码的思路不清晰很可能会弄错。

更多细节请见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000;
char mz[N][N];
int Z[N][N];

void mdraw(int x,int y){
    /*正面矩阵绘制*/
    mz[x][y+3]=mz[x][y]=mz[x+4][y]=mz[x+4][y+3]='+';
    for(int i=x+1;i<x+4;i++)
        mz[i][y]=mz[i][y+3]='-';
    for(int i=y+1;i<y+3;i++)
        mz[x][i]=mz[x+4][i]='|';
    for(int i=x+1;i<x+4;i++)
        for(int j=y+1;j<y+3;j++)
            mz[i][j]=' ';
    /*顶面矩阵绘制*/
    mz[x+1][y+4]=mz[x+5][y+4]='/';
    mz[x+2][y+5]=mz[x+6][y+5]='+';
    for(int i=x+2;i<=x+4;i++)
        mz[i][y+4]=' ';
    for(int i=x+3;i<=x+5;i++)
        mz[i][y+5]='-';
    /*侧面矩阵绘制*/
    mz[x+5][y+1]='/';
    mz[x+6][y+2]='+';
    mz[x+5][y+2]=mz[x+5][y+3]=' ';
    mz[x+6][y+3]=mz[x+6][y+4]='|';
}

void putout(int x,int y){
    for(int j=y;j>=0;j--){
        for(int i=0;i<=x;i++)
            if(!mz[i][j])putchar('.');
            else putchar(mz[i][j]);
        putchar('\n');
    }//按照平面直角坐标系顺序进行输出 
}

int main(){
    int mx=0,my=0;
    int m,n;
    scanf("%d%d",&m,&n);
    for(int y=m-1;y>=0;y--)
        for(int x=0;x<n;x++)
            scanf("%d",&Z[x][y]); //注意输入 
    for(int y=m-1;y>=0;y--)
        for(int x=0;x<n;x++)
            for(int z=0;z<=Z[x][y]-1;z++){
                mx=max(mx,2*y+4*x+6);
                my=max(my,2*y+3*z+5);
                mdraw(2*y+4*x,2*y+3*z);
            } //注意绘制顺序 
    putout(mx,my); //输出 
    return 0;
}
```

---

## 作者：Moco_jof (赞：22)

## 题目传送门：

[P1058题目传送门](https://www.luogu.com.cn/problem/P1058)


## 基本思路：

### **~~最讨厌这种题了~~**

其实一开始一看也很懵，但仔细一想就开窍了

像这种**~~无耻地~~**让我们输出图案的题目，其实我们可以从后往前来填充方块

比如样例：


```cpp
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
我们可以先填这个：

```cpp
        |    
......+-V-+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
再填这个：

```cpp
            |
......+---+-V-+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
填完这一行后，再填下一行，以此类推……
这样，让这个数组一次次覆盖，最终形成最后的图案。

最后输出，别忘了背景

然后就没了

就没了

## 代码之前：

1.可以建一个二维字符数组用来存储


```cpp
  +---+
 /   /|
+---+ | <-这个东西
|   | +
|   |/ 
+---+  
```
2.再建一个二维字符数组用来存储最终图案

3.应该没了
## 代码

终于到你们最喜欢的代码了~

代码（ ）坑，可安息食用


```cpp
#include <iostream>
#define max(a,b) a>b?a:b
#defie min(a,b) a<b?a:b
using namespace std;
int m,n,x=3000,y=1000,_y,a=2147483647,b,c,d=-2147483648,_x;
//a,b,c,d是上下左右限
int zb[51][51];
char ans[4005][4005];
char ch[8][8]={"..+---+","./   /|","+---+ |","|   | +","|   |/.","+---+.."};
/*
  +---+
 /   /|
+---+ |
|   | +
|   |/ 
+---+  
*/
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>m>>n;
    for(int i=1;i<=m;++i){
        for(int j=1;j<=n;++j){
            cin>>zb[i][j];
        }
    }
    for(int i=1;i<=m;++i){
        _y=y;
        for(int j=1;j<=n;++j){
            _x=x;
            _x-=5;
            for(bool k=1;k<=zb[i][j];++k){//填充一个方块
                for(int l=0;l<=5;++l){
                    for(int o=0;o<=5;++o){
                        if(ch[l][o]!='.'){
                            ans[x+l][_y+o]=ch[1][o];
                            //填充
                        }
                    }
                }
                _x-=3;
            }
            a=min(a,_x+3);
            _y+=4;//下一列
        }
        x+=2;
        y-=2;//下一行
        d=min(d,_y+2);
    }
    b=x-2;
    c=y+2;
    for(int i=a;i<=b;++i){
        for(int j=c;j<=d;++i){
            if(ans[i][j]){
                cout<<'.';//背景
            }else{
                cout<<ans[i][j];
            }
        }
        cout<<'\n';
    }
    return 0;
}

```
千万别点赞

---

## 作者：HasNoName (赞：21)

### 思路
感觉这道题还是有思维含量的。

考虑如何得到一张立体图。

如果从前往后依次放方块是非常困难的。

所以可以从后往前建方块。

然后可以发现前面的其实可以覆盖后面方块的图，左边的可以覆盖右边的，同一个位置上面的可以覆盖下面的。所以从后往前，从左往右，从下往上作图。

具体的，可以从给出的矩阵的左上角开始建，从上往下，从左往右，在对于每一个矩阵中的位置，从下往上堆方块。堆方块时可以设置一个单位正方体的图，从图形的左下角开始，每次将纵坐标向上移动，对于单位方格有实际意义的位置，直接覆盖原来位置的字符即可。

可以用画图软件操作一下。比如这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/upz7bew1.png)

理解了这些之后这题就非常简单了。

但是这样的方式在数组中存储的位置并不确定。

所以可以将作图的其实位置放在数组中间，上下左右给其充分大的空间，再在作图过程中更新打印时图的大小即可。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int num[55][55],u=1e9,d=0,l=1e9,r=0;
char a[4005][4005];//答案数组
char cube[10][10]={"..+---+",
				   "./   /|",
				   "+---+ |",
				   "|   | +",
				   "|   |/.",
				   "+---+.."};//单个方块
void print(int x,int y,int h)//每个二维中同样位置从下往上堆方块
{
	x-=5;
	for(int k=1;k<=h;k++)
	{
		for(int i=0;i<6;i++)
			for(int j=0;j<7;j++)
				if(cube[i][j]!='.')
					a[x+i][y+j]=cube[i][j];
		x-=3;//打印方块起始位置移动
	}
	u=min(u,x+3);//更新上界
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>num[i][j];
	int x=3000,y=1000;
	for(int i=1;i<=n;i++)
	{
		int y_=y;
		for(int j=1;j<=m;j++)//从左到右打印
		{
			print(x,y_,num[i][j]);
			y_+=4;
		}
		r=max(r,y_+2);//右界
		x+=2;
		y-=2;
	}
	d=x-2;//下界
	l=y+2;//左界
	for(int i=u;i<=d;i++)
	{
		for(int j=l;j<=r;j++)
		{
			if(!a[i][j])cout<<".";
			else cout<<a[i][j];
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：skx_515 (赞：5)

拿到这道题，我的第一个想法是：  

**方块的前后关系是什么样子的？？？**

很显然，从最前面看，一定先看到最前面，最上面的方块，再由于我们观看的角度问题，我们可以得出结论：
>在输入中，由于先输入的为后面的方块，所以可以先打印后面的，再打印前面的，同时，再打印同一列时，我们需要先打印下面的，再打印上面的

所以，我们可以~~轻松~~写出代码(具体移动过程见内)：
```cpp
#include<bits/stdc++.h>
#define N 2005
using namespace std;
int n,m,a[N][N],tx,mnx=INT_MAX,mny=INT_MAX,mxx,mxy;
int x=500,y=1;//记录每一个方块的左上角坐标，从(500,1)开始 
char mp[N][N];
char jc[8][8]={{'.','.','+','-','-','-','+'},
			   {'.','/',' ',' ',' ','/','|'},
			   {'+','-','-','-','+',' ','|'},
			   {'|',' ',' ',' ','|',' ','+'},
			   {'|',' ',' ',' ','|','/','.'},
			   {'+','-','-','-','+','.','.'}};//存储一个方块 
int main(){
	memset(mp,'.',sizeof(mp));//初始化背景为'.' 
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		y=(n-i)*2+1;
		for(int j=1;j<=m;j++){
			cin>>a[i][j];//输入 
			tx=x;//记录左上角 
			for(int t=1;t<=a[i][j];t++){
				for(int xx=0;xx<6;xx++){//直接在需要的地方 
					for(int yy=0;yy<7;yy++){
						if(jc[xx][yy]!='.') mp[tx+xx][y+yy]=jc[xx][yy];//'.代表的是空的地方
						mnx=min(mnx,tx+xx),mxx=max(mxx,tx+xx);//记录图形的四个角 
						mny=min(mny,y+yy),mxy=max(mxy,y+yy);
					}
				}
				tx-=3;//向上三格打印上面的
			}
			y+=4;//向右四格到下一个
		}
		x+=2;//向下两个到下一行
	}
	for(int i=mnx;i<=mxx;i++){
		for(int j=mny;j<=mxy;j++) cout<<mp[i][j];
		cout<<"\n";
	} 
	return 0;
}
```

---

## 作者：prh_rpjiajia (赞：3)

## 思路：
- 放置顺序。
- 计算输出的尺寸。
- 怎么让代码更清晰。
***
### 第一部分：
类比生活中放置，最前面肯定是最显眼的。所以，我们采用**从后到前，从左到右，从下往上**的放置方式。

另外，改怎么放呢？打表！提前存在数组里。
### 第二部分：
这部分是最困难的，实际的 $h$、$w$，与 $n,m$ 没有直接关系。**我提供了一种与其他题解不同的方法。**

**思考：**
高要在循环内求，在侧面一层会让高涨 $2$，在正面，一层会让高涨 $3$，$m-i$ 表示层数。宽也以此类推，每一个块的宽首先是点是层数乘 $2$ 的，接着是两个加号两个减号是层数乘 $4$ 的，当然，还要考虑 $a[i][j]$，所以分别加六加七了。累加起来就是了。（具体代码我会在程序里标注）。
### 第三部分：
提到让代码给清晰，大多数人也可以想到它——**函数**。
我们创建一个 $draw$ 函数，枚举左上角和右下角去放块。

## 代码

```cpp
#include<bits/stdc++.h>
#define I return
#define LOVE 0
#define LOUGU ;
using namespace std;
const int MAXN=55,MAXM=550;
char c[MAXM][MAXM],s[6][8]={//打表
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
};
int m,n,a[MAXN][MAXN],h,w;
void draw(int x,int y)
{
    for (int i=0;i<6;++i)
        for (int j=0;j<7;++j)
            if (s[i][j]!='.')c[x+i][y+j]=s[i][j];
}
int main()
{
    cin>>m>>n;
    for (int i=1;i<=m;++i)
    {
        for (int j=1;j<=n;++j)
        {
            cin>>a[i][j];
            h=max(h,(m-i)*2+(a[i][j]-1)*3+6);//高
            w=max(w,(m-i)*2+(j-1)*4+7);//宽
        }
    }
    memset(c,'.',sizeof(c));//初始化
    for (int i=1;i<=m;++i)
        for(int j=1;j<=n;++j)
		for (int k=1;k<=a[i][j];++k)draw(h-1-(m-i)*2-(k-1)*3-5,(m-i)*2+(j-1)*4);
    for (int i=0;i<h;++i)
    {
        c[i][w]='\0';//设置字符串结尾
        cout<<c[i]<<"\n";
    }
    I LOVE LOUGU
}
```
完结，撒花。

---

## 作者：superLouis (赞：3)

## 题解：P1058 [NOIP2008 普及组] 立体图

这道题目其实就是朴素的算算下表就能通过。

----------
### 1. 解题思路
我们可以采用画布思想，先把整个数组都变成 `.`，在这里可以使用 `fill` 来实现，大致就是这样：`fill(&a[0][0], &a[maxn - 1][maxn - 1], '.')`。

我们定义一个 `draw` 函数，传的参数就是你要在 $i$ 行 $j$ 列画出一个立方体。详见下面：

```
*.+---+
./   /|
+---+ |
|   | +
|   |/.
+---+..
```
其中标记 `*` 的点就是 $i$ 行 $j$ 列的点，也就是 `draw` 函数的参数。`draw` 就是传入 $i$ 和 $j$，画出一个 `*` 在 $i$ 行 $j$ 列的立方体。

随后，我们考虑应该按照什么顺序来画立方体。注意到立方体们会互相覆盖，所以我们一层一层的盖楼，每一层从左上角开始，一行一行搭建，这样搭满一层。

形式化的讲，先从一层一层的搭建，每一层从下标为 $(1,1)$ 开始搭建，搭到 $(n,m)$。搭建顺序是：

$$(1,1) \to (1,2) \to (1,3) \to \dots \to (1,m) \to \\ \vdots \\ \to (n,1) \to (n,2) \to (n,3) \to \dots \to (n, m)$$

顺序讲完了，该说说下标问题了。考虑三种情况，分别是在二维数组下标 $i$ 行 $j$ 列的立方体向右、前、上搭建第 $k$ 一个立方体的下标。

1. 向右搭建（right）：下标是 $(i, j+4k)$。
2. 向前搭建（front）：下标是 $(i+2k, j-2k)$。
3. 向上搭建（up）：下标是 $(i-3k, j)$。

这些下表都要自己算一遍。

但是，计算这个图形要多大的数组很难，所以可以直接从中间开始画，画完之后再去确定最大最小的横纵坐标即可。

----------
### 2. 代码实现
思路明白了，代码很好写。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 60;
const int maxm = 3010;
const int st = maxm >> 1;
int n, m, a[maxn][maxn], mxheight;
int stx = maxm, sty = maxm, edx, edy;
char ans[maxm][maxm]; 
void draw(int x, int y) {
	ans[x][y + 2] = ans[x][y + 6] = ans[x + 2][y] = 
	ans[x + 2][y + 4] = ans[x + 3][y + 6] = ans[x + 5][y] = 
	ans[x + 5][y + 4] = '+';
	ans[x + 1][y + 1] = ans[x + 1][y + 5] = ans[x + 4][y + 5] = '/';
	ans[x][y + 3] = ans[x][y + 4] = ans[x][y + 5] = 
	ans[x + 2][y + 1] = ans[x + 2][y + 2] = ans[x + 2][y + 3] =
	ans[x + 5][y + 1] = ans[x + 5][y + 2] = ans[x + 5][y + 3] = '-';
	ans[x + 1][y + 6] = ans[x + 2][y + 6] = ans[x + 3][y] =
	ans[x + 4][y] = ans[x + 3][y + 4] = ans[x + 4][y + 4] = '|';
	ans[x + 1][y + 2] = ans[x + 1][y + 3] = ans[x + 1][y + 4] = ' ';
	ans[x + 2][y + 5] = ans[x + 3][y + 5] = ' ';
	ans[x + 3][y + 1] = ans[x + 3][y + 2] = ans[x + 3][y + 3] = ' ';
	ans[x + 4][y + 1] = ans[x + 4][y + 2] = ans[x + 4][y + 3] = ' ';
}
void print() {
	for (int i = stx; i <= edx; i++) {
		for (int j = sty; j <= edy; j++) cout << ans[i][j];
		cout << "\n";
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	fill(&ans[0][0], &ans[maxm - 1][maxm - 1], '.');
	cin >> n >> m;
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= m; j++) cin >> a[i][j], mxheight = max(mxheight, a[i][j]);
	// right: draw(i, j + 4k);
	// front: draw(i + 2k, j + (-2k));
	// up:    draw(i + (-3k), j);
	for (int h = 1; h <= mxheight; h++) {
		for (int i = 1; i <= n; i++) 
			for (int j = 1; j <= m; j++) 
				if (a[i][j] >= h) draw(st + (i - 1) * 2 - 3 * (h - 1), st + (j - 1) * 4 - 2 * (i - 1));
	}
	for (int i = 1; i < maxm - 30; i++) 
		for (int j = 1; j < maxm - 30; j++) 
			if (ans[i][j] != '.') {
				stx = min(stx, i);
				sty = min(sty, j);
				edx = max(edx, i);
				edy = max(edy, j);
			}
	print();
	return 0;
} 
```

---

## 作者：imnotcfz (赞：2)

# P1058 [NOIP 2008 普及组] 立体图 题解

[原题链接](https://www.luogu.com.cn/problem/P1058/)

## 0x01 省流

题目大家应该都看得懂，这里就不多赘述了，我们的目标是绘制立体图，具体内容可结合样例。

## 0x02 分析

我们先不着手写，先想想下面这些问题。

### 遮挡关系

容易想到在保证遮挡关系的情况下，逐个绘制正方体，因此我们需要按照正确的顺序枚举。

不难发现绘制顺序的关键字即为：从深到浅、从左到右、从下到上，也就是依次按行、列、高度从小到大。

### 确定顶点

接下来就是比较难的绘制部分，我们先确定各个顶点的位置。

为了方便表述，下文中 $x, y, z$ 分别代表正方体的行、列、高度。

每个顶点，无论位于正方体的哪个位置，都受到行、列、高度的影响。

以正面左下角顶点为例，不难得出它的位置（先行后列）为 $\big(2(n - x) + 3z - 2, 2(n - x) + 4y - 3\big)$。

其余顶点的位置，请读者自行计算。（当然也可以[抄作业](https://www.luogu.com.cn/paste/laet0hvu)）

确定顶点之后就好办了，绘制各条棱，最后再用空格填充三个面，没有任何技巧。

## 0x03 实现

思路基本差不多了，现在我们就来着手写。

我们先绘制一个正方体，然后输出。

然而你很快会发现问题，没有发现也没关系，等你写完就知道了（笑）。

### 正确地存图

补兑啊？立体图的大小是多少呢，而且我们是从下至上绘制，我们要从哪一行开始绘制。

我们很容易想到立体图的大小可以在绘制时动态更新，即不断取最大值。

而绘制的起始点……我们可以参照[高精度](https://oi-wiki.org/math/bignum/)的实现，将数组第一维（行）倒序存储，起始点就变为原点，只要输出时倒序输出即可。

由于代码过长，请前往[剪贴板](https://www.luogu.com.cn/paste/koxxll63)查看。

* [P8217 [THUPC 2022 初赛] 数正方体](https://www.luogu.com.cn/problem/P8217) 双倍...补兑？好吧其实是本题的逆运算

## 0x04 Changelog

* 2025-04-12 10:52 初版完成
* 2025-04-14 10:46 一审打回
* 2025-04-16 11:37 第二版完成
* 2025-04-16 12:34 二审打回
* 2025-04-19 15:42 三审打回

---

## 作者：cwxcplh (赞：2)

一道特别具有思维挑战性的模拟题 ~~（我绝对不会告诉你我花了一个多小时去做这道题）~~。

题目简化：给定一个立体几何的每一列的个数，画出这个立体几何。

第一眼看到，很容易想到模拟。我们只需要确定每个立方体的左上角的位置，然后在此基础上放一个立方体就行了。

听着很简单，怎么做呢？我们先打出一个最基本的立方体：

```
..+---+
./   /|
+---+ |
|   | +
|   |/.
+---+..
```

然后以这个立方体为中心，向它的前后左右上下依次加一个立方体，看看左上角的横纵坐标有什么变化。

如果在它的右边加了一个立方体，那么这个新加的立方体的左上角的列数就会加 $4$，而这与这个立方体在俯视图中的列有关。如果在上面加，那么行数会减去 $3$，二者与层数有关。如果在如果在后面加，那么行数会减去 $2$，列数会增加 $2$。所以我们不免大胆猜测：在一个立方体的左上角的坐标 $(x,y)$（$x$ 为行，$y$ 为列）经过变化后会变成:
$$(x+3\times(a_{i,j}-k)+2\times(i-1)+1,y+2\times(n-i)+4\times(j-1)+1)$$

那如果我们把这个点拖到原点 $(0,0)$，那我们就得到了每个点的坐标公式：

$$(3\times(a_{i,j}-k)+2\times(i-1)+1,2\times(n-i)+4\times(j-1)+1)$$

因为前面会覆盖后面、右边会覆盖左边、上面会覆盖下面，所以我们会按照从后往前、从左往右、从下往上的顺序循环。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,mxx,mxy,a[56][56];
char c[1006][1006],cube[16][16]={//单个立方体块，方便后面组装
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
}; 
void tc(int x,int y)//填充立方体
{
	for(int i=0;i<6;i++)
	{
		for(int j=0;j<7;j++)
		{
			c[x+i][y+j]=cube[i][j];
			if(x+i>mxx)
			{
				mxx=x+i;
			}
			if(y+j>mxy)
			{
				mxy=y+j;
			}
		}
	}
}
signed main()
{
	memset(c,'.',sizeof(c));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=a[i][j];k++)
			{
				tc(3*(a[i][j]-k)+2*(i-1)+1,2*(n-i)+4*(j-1)+1);//杠杠的公式
			}
		}
	}
	for(int i=1;i<=mxx;i++)
	{
		for(int j=1;j<=mxy;j++)
		{
			cout<<c[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

但这会出现一个问题，请看样例：

输入：`1 2 1 1`。

输出：

```
..+-..+---+
./  ./   /|
+---+---+ |
|   |   | +
|   |   |/.
+---+---+..
```

其实就是 `.` 符号可能会挡住前面的字符，填充时加个判断就行：

```cpp
if(c[x+i][y+j]!='.'&&cube[i][j]=='.')
{
	continue;
}
```

但加上后这个代码仍然有问题，请看下面这组样例：

输入：`1 2 1 2`。

输出：

```
..+---+---+
./   /   /|
+---+---+ |
|   |   | +
|   |   |/|
+---+---+ |
....|   | +
....|   |/.
....+---+..
```

我们会发现：右边的那个方块悬空了。这是因为我们刚刚的坐标式是只看了自己的坐标，而没看其他的，因此不会受到其他方块的影响。为此，我们需要加一个“重力常数”，让这个方块可以落下去。

不难发现：如果你比最高的方块要矮 $z$ 层，那么行数就需要加 $3z$ 格。所以最后的坐标公式就是：

$$(3\times(a_{i,j}-k)+2\times(i-1)+1+3\times(mx-a_{i,j}),2\times(n-i)+4\times(j-1)+1)$$

但加上去之后这份代码仍然有问题，请看最后一组样例：

输入：`2 1 1 2`。

输出：

```
.........
.........
..+---+..
./   /|-+
+---+ |/|
|   | + |
|   |/| +
+---+ |/.
|   | +..
|   |/...
+---+....
```

这是因为我们是按照最高的对齐，然而最高的却会按照原本的位置站，所以上面会留出原本不属于它的空间。这也很好办，我们只需要一个循环把上面的去掉就行了：

```cpp
int i=1;
while(i<=mxx)
{
	bool flag=false;
	for(int j=1;j<=mxy;j++)
	{
		if(c[i][j]!='.')
		{
			flag=true;
			break;
		}
	}
	if(flag)
	{
		break;
	}
	i++;
}
```

到这，这道题才算是完美解决了。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201487576)

**最终代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,mxx,mxy,mx,a[56][56];
char c[1006][1006],cube[16][16]={
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
}; 
void tc(int x,int y)
{
	for(int i=0;i<6;i++)
	{
		for(int j=0;j<7;j++)
		{
			if(c[x+i][y+j]!='.'&&cube[i][j]=='.')
			{
				continue;
			}
			c[x+i][y+j]=cube[i][j];
			if(x+i>mxx)
			{
				mxx=x+i;
			}
			if(y+j>mxy)
			{
				mxy=y+j;
			}
		}
	}
}
signed main()
{
	memset(c,'.',sizeof(c));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			mx=max(mx,a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=a[i][j];k++)
			{
				tc(3*(a[i][j]-k)+2*(i-1)+1+(mx-a[i][j])*3,2*(n-i)+4*(j-1)+1);
			}
		}
	}
	int i=1;
	while(i<=mxx)
	{
		bool flag=false;
		for(int j=1;j<=mxy;j++)
		{
			if(c[i][j]!='.')
			{
				flag=true;
				break;
			}
		}
		if(flag)
		{
			break;
		}
		i++;
	}
	for(;i<=mxx;i++)
	{
		for(int j=1;j<=mxy;j++)
		{
			cout<<c[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

~~我感觉废话好像多了点。~~

---

## 作者：LiJunze0501 (赞：2)

这道题就是一道模拟，是二维数组的覆盖。  
那么我们要搞清楚这几点：

- 最后长（$L$）是多少？
- 最后宽（$K$）是多少？
- 怎样覆盖？

第一个问题，长（$L$）怎么求。
```
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
$L \gets 4 \times N+2 \times M+1$  
长上有 $N$ 个立方体，我们把 `+---` 看为一个整体，那就会有 $4 \times N$ 个字符。  
宽上有 $M$ 个立方体，我们把 `+/` 看为一个整体，那就会有 $2 \times M$ 个字符。  
最后还会有一个 `+`，所以再加一。
最后就会得到如上的式子。

---
第二个问题，宽（$K$）怎么求。  
这里不再赘述，在循环中 $ K \gets \max(K,a_{i,j} \times 3+2 \times (M-i+1)+1)$。  
示意代码：

```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		cin>>a[i][j];
		k=max(k,a[i][j]*3+2*(n-i+1)+1);
	}
```


---
最后是覆盖，从左下向右上覆盖，最后替换。

---
# AC Code
在代码中因为书写习惯，我把 $N$ 和 $M$ 调换了顺序。
```cpp
#include<bits/stdc++.h>
using namespace std;
char dy[10][10]={
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
};//打表一个立方体

char ans[2001][2001];
void add(int x,int y)
{
	for(int i=0;i<=5;i++)
		for(int j=0;j<=6;j++)
			if(dy[6-i-1][j]!='.')
				ans[x-i][y+j]=dy[6-i-1][j];
}

int a[51][51];
int main()
{
	int n,m,k=0,l;
	cin>>n>>m;
	l=4*m+2*n+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			k=max(k,a[i][j]*3+2*(n-i+1)+1);
		}
	for(int i=1;i<=k;i++)
		for(int j=1;j<=l;j++)
			ans[i][j]='.';
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			int x=k-2*(n-i);
			int y=2*(n-i)+4*(j-1)+1;
			while(a[i][j]--)
			{
				add(x,y);
				x-=3;
			}
		}
	for(int i=1;i<=k;i++)
	{
		for(int j=1;j<=l;j++)
			cout<<ans[i][j];
		cout<<endl;
	}
} 
```

---

## 作者：封禁用户 (赞：1)

## 思路
这道题是道不错的模拟。

首先，思路很明确的是，先将图形存储下来，求出尺寸后打印即可，但是要注意打印顺序。

![](https://cdn.luogu.com.cn/upload/image_hosting/oeae051i.png)

如图，前方右上角的正方体可以被看到 $3$ 个面，是所有正方体里面最多的，而后方左下角的正方体一个面都看不见，是所有正方体里面最少的。因此在打印中，我们先打印后面的、左边的、下面的，这样可以让后面的堆叠更加方便。明白了这一点后，构造代码就很容易了。

## AC CODE
```cpp
#include<iostream>
#include<cstring>
#include<climits>
#define mn INT_MIN
using namespace std;
const char moban[8][8] = {
       "..+---+",
       "./   /|",
       "+---+ |",
       "|   | +",
       "|   |/.",
       "+---+.."
};
char s[2005][20005];
int maxn=mn,maxm=mn,m,n,a;
void init(int x,int y){
    for(int i=0;i<6;i++){
        for(int j=0;j<7;j++){
            if(moban[i][j]!='.'){
                s[y+5-i][x+j]=moban[i][j];
                maxm=max(maxm,y+5-i);
                maxn=max(maxn,x+j);
            }
        }
    }
}
int main(){
    memset(s,'.',sizeof(s));
    cin>>m>>n;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            cin>>a;
            for(int k=0;k<a;k++){
                int t=m-i-1;
                init(2*t+4*j,2*t+3*k);
            }
        }
    }
    for(int i=maxm;i>=0;i--){
       for(int j=0;j<=maxn;j++)cout<<s[i][j];
            cout<<endl;
	}
}
```

---

## 作者：SCma (赞：1)

# 前置
自打初一起就想写这道题，结果拖到初三才写。
# 总体思路
考虑答案是怎么来的，我们从最简单的情况开始思考，即摆放方式是一个简单的柱子时候。
```plainbox
..+---+
./   /|
+---+ |
|   | +
|   |/|
+---+ |
|   | +
|   |/|
+---+ |
|   | +
|   |/|
+---+ |
|   | +
|   |/.
+---+..

```
显然，每当在下面方块上放置了一个新方块时候，上面的方块会把下面的方块在图层上的部分内容给刷新掉。因此，我们得出了一个朴素的结论：放置顺序为从下方开始堆积方块并逐渐刷掉原下方方块的图层。

我们对情况再次进行扩张，即当方块已经成为了一堵墙的时候。
```plainbox
......+---+...+---+
...../   /|../   /|
....+---+ |.+---+ |
..+-|   | +.|   | +
./  |   |/|.|   |/|
+---+---+ |.+---+ |
|   |   | +.|   | +
|   |   |/|.|   |/|
+---+---+ |.+---+ |
|   |   | +-|   | +
|   |   |/  |   |/|
+---+---+---+---+ |
|   |   |   |   | +
|   |   |   |   |/.
+---+---+---+---+..
```
同理，一堵墙是由不同的柱子组成的。可以扩张结论：在柱子排列的过程中，左边柱子的右面图层会被右边的柱子给刷新掉。

那让我们再扩张一下情况？即多堵墙组成一个立体图形时。
```plainbox
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
显然，按照先前的思路，得出结论前面的墙会更新后面的墙的前方图层。

综上所述，更新图层的顺序为从最左下方刷新到右上方：先从下到上更新单个方块组成一根柱子，再从左到右更新柱子组成一堵墙，最后从前往后更新墙组成一个更复杂的立体图形。
# 具体实现
现在我们知道了方块的放置顺序，但是我们仍然面对一个问题：如何将立体图形的三维坐标投影到二维字符串数组中的下标之中呢？

现在已经知道方块在立体图中坐标为 $(a,b,c)$ ，第 $a$ 行的第 $b$ 列中从下往上数的第 $c$ 个方块。经过观察，在已知包含所有立体图的最小列数 $bndx$ 和最小行数 $bndy$ 可得出方块左上角加号对应坐标有
$$x=4(b-1)+2(n-a+1)+1$$
$$y=bndy-[2(n-a+1)+3c+1]$$ 
而对于所有 $bndx,bndy$ 存在
$$bndx=\max_{1< i,j\le n}\{4j+2(n-i+1)+1\}$$
$$bndy=\max_{1< i,j\le n}\{2(n-i+1)+3num_{i,j}+1\}$$

~~在存储图时候，如果你不嫌累可以把存储模式压成一维。~~
# 代码
```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define MIN(a,b,c) min(min(a,b),c)
#define MAX(a,b,c) max(max(a,b),c)
#define ri register int
#define int long long
#define fixedset(a) fixed << setprecision(a)
#define mp(a,b) make_pair(a,b)
#define ls(x) x<<1
#define rs(x) x<<1|1
#define MAXN 9.2211e18
#define inf 2114514
#define mf 5011
#define sf 1011
using namespace std;
mt19937_64 randint{std::chrono::steady_clock::now().time_since_epoch().count()};
int n,m,bndx,bndy,num[inf],ans[inf]; 
int fuc(int a,int b){return m*(a-1)+b;}//获取该方块的在存储数组num中的位置
int pos(int a,int b,int c){//将(a,b,c)坐标转换到一维图层上
	int s=4*(b-1)+2*(n-a+1)+1,t=bndy-(2*(n-a+1)+3*c+1);
	return t*bndx+s;
}
void modify(int a,int b,int c){//放置方块，刷新图层
	ans[pos(a,b,c)]='+' ; ans[pos(a,b,c)+1]='-' ; ans[pos(a,b,c)+2]='-' ; ans[pos(a,b,c)+3]='-' ; ans[pos(a,b,c)+4]='+' ;
	ans[pos(a,b,c)+bndx-1]='/' ; ans[pos(a,b,c)+bndx]=' ' ; ans[pos(a,b,c)+bndx+1]=' ' ; ans[pos(a,b,c)+bndx+2]=' ' ; ans[pos(a,b,c)+bndx+3]='/' ; ans[pos(a,b,c)+bndx+4]='|' ;
	ans[pos(a,b,c)+2*bndx-2]='+' ; ans[pos(a,b,c)+2*bndx-1]='-' ; ans[pos(a,b,c)+2*bndx]='-' ; ans[pos(a,b,c)+2*bndx+1]='-' ; ans[pos(a,b,c)+2*bndx+2]='+' ; ans[pos(a,b,c)+2*bndx+3]=' ' ; ans[pos(a,b,c)+2*bndx+4]='|' ;
	ans[pos(a,b,c)+3*bndx-2]='|' ; ans[pos(a,b,c)+3*bndx-1]=' ' ; ans[pos(a,b,c)+3*bndx]=' ' ; ans[pos(a,b,c)+3*bndx+1]=' ' ; ans[pos(a,b,c)+3*bndx+2]='|' ; ans[pos(a,b,c)+3*bndx+3]=' ' ; ans[pos(a,b,c)+3*bndx+4]='+' ;
	ans[pos(a,b,c)+4*bndx-2]='|' ; ans[pos(a,b,c)+4*bndx-1]=' ' ; ans[pos(a,b,c)+4*bndx]=' ' ; ans[pos(a,b,c)+4*bndx+1]=' ' ; ans[pos(a,b,c)+4*bndx+2]='|' ; ans[pos(a,b,c)+4*bndx+3]='/' ;
	ans[pos(a,b,c)+5*bndx-2]='+' ; ans[pos(a,b,c)+5*bndx-1]='-' ; ans[pos(a,b,c)+5*bndx]='-' ; ans[pos(a,b,c)+5*bndx+1]='-' ; ans[pos(a,b,c)+5*bndx+2]='+' ;
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin >> n >> m;
    for(ri i=0;i<inf;i++) ans[i]='.';
	for(ri i=1;i<=n;i++) for(ri j=1;j<=m;j++) cin >> num[fuc(i,j)]; 
	for(ri i=1;i<=n;i++) for(ri j=1;j<=m;j++) bndx=max(bndx,4*j+2*(n-i+1)+1),bndy=max(bndy,2*(n-i+1)+3*num[fuc(i,j)]+1);
	
	for(ri i=1;i<=n;i++) for(ri j=1;j<=m;j++) for(ri k=1;k<=num[fuc(i,j)];k++){
		modify(i,j,k); 
	}
	
	for(ri i=1;i<=bndy;i++){
		for(ri j=1;j<=bndx;j++) cout << (char)(ans[bndx*(i-1)+j]);
		cout << endl;
	}
	return 0;
}
```

---

## 作者：player_1_Z (赞：0)

### 先来理解题目
这题看似很难，其实就是在找规律，只需找到整个图的行列规律和每一列每一行的横纵坐标规律就行了。
### 思路
首先把这张图简化，也就是把一个立方体看作一个图形，再来推横纵坐标规律，由样例得出：
```
整个图形
行：x
列：y
单个立方体（第 i 行第 j 列的从下往上数等 k 个）
行（最下边一行）：ma-(a[i][j]-k+1)*3-(n-i+1)*2
列（最左边一行）：4*j+(n-i+1)*2-5
其中 ma 为整个图的行数
```
然后枚举其中的 $i$，$j$，$k$，同时枚举 $xx$，$yy$ 作为单个立方体中每个图形的位置（用来在图上添加立方体，具体看代码），然后依次把这个正方体存到大数组中（初始每个位置都是点），最后输出大数组。
### 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[55][55],ma;
char c[10005][10005],c1[10][10]={
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."};
//c为大数组，是最后输出的图。c1为单个正方体 
int main(){
	for(int i=0;i<=10000;i++)//将大数组全赋值为点，解决了题目中空位为点的问题 
		for(int j=0;j<=10000;j++) c[i][j]='.';
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int m1=-1;//对于一行正方体找最高值 
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			m1=max(a[i][j],m1);
		}
		ma=max(ma,((n-i+1)-1)*2+m1*3+3);//判断这一行的正方体最多会占多少行 
	}
	for(int i=1;i<=n;i++){
		int ii=n-i+1;//ii从n到1 
		for(int j=1;j<=m;j++){
			for(int k=1;k<=a[i][j];k++){
				for(int xx=0,x=ma-k*3-ii*2;x<=ma-k*3+5-ii*2;x++,xx++){
					for(int yy=0,y=4*j+ii*2-5;y<=4*j+ii*2+1;y++,yy++){
						if(c1[xx][yy]!='.') c[x][y]=c1[xx][yy];
						//只需要存入正方体部分 
					}
				}
			}
		}
	}
	for(int i=1;i<=ma;i++){ 
		for(int j=1;j<=m*4+1+n*2;j++) cout<<c[i][j];
		//输出时图的行为ma（没找到规律），列为 m*4+1+n*2（最上面一列最右边的一个正方体） 
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：CommonDigger (赞：0)

题目要求我们将一些立体图形在平面内打印出来。由遮挡关系可以分析出，被遮挡的应该先画，最后画视角可以直接看到的。再观察样例给出的视角，可以整理出打印顺序：从下至上、从左至右、从后至前（指的是从离眼睛远的到离眼睛近的）。

那么我们依这个顺序画方块，画的新的的时候直接将之前的图无脑覆盖即可。

先画一个方块：
```cpp
char block[][]={
	"..+---+",
	"./   /|",
	"+---+ |",
	"|   | +",
	"|   |/.",
	"+---+.."};
```
画方块的时候，以 `block[0][0]` 为基准，由于上下高度差为 $3$，向上画的时候纵坐标 $-3$；以此类推，向右画的时候横坐标 $+4$，向近处画的时候横坐标 $-2$，纵坐标 $+2$。到这里很容易发现上下左右边界是会随时拓展的，所以不能从左下角或者什么角落开始画，考虑将数组的长宽翻倍然后从中间开始。

完整代码如下。其中 $x$，$y$ 表示画方块的基准位置，`up`、`down`、`l`、`r` 记录目前图像的边界。 
```cpp
#include <iostream>
using namespace std;
int h[55][55];
int up=1e9, down, l=1e9, r=0, x=3000, y=1000;
char block[10][10]={
	"..+---+",
	"./   /|",
	"+---+ |",
	"|   | +",
	"|   |/.",
	"+---+.."};
char res[4005][4005];
void place(int x,int y,int H) // 摆一个柱子
{
	x-=5;
	for(int k=1;k<=H;k++)
	{
		for(int i=0;i<6;i++)
			for(int j=0;j<7;j++)
				if(block[i][j]!='.') res[x+i][y+j]=block[i][j];
		x-=3; // 继续去打印上面的方块
	}
	up=min(up, x+3); // 记录当前图像的顶部边缘
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin >> n >> m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin >> h[i][j];
	for(int i=1;i<=n;i++) // 枚举底部
	{
		int ty=y;
		for(int j=1;j<=m;j++)
		{
			place(x,ty,h[i][j]);
			ty+=4;
		}
		r=max(r, ty+2); // 右侧边缘
		x+=2, y-=2;
	}
	l = y+2;
	down = x-2;
	for(int i=up;i<=down;i++)
	{
		for(int j=l;j<=r;j++)
		{
			if(!res[i][j])cout<<".";
			else cout<<res[i][j];
		}
		cout<<'\n';
	}
}
```

---

## 作者：JingchenBian (赞：0)

## 解题思路
### 1.表示积木
用二维数组打表。
### 2.贴图表示
易推出坐标 $(i,j)$ 的第 $k$ 个方块左上角坐标应为 $((n-i)\times 2+3\times k+1,(n-i)\times 2+4\times j+1)$。我们从左上角直接覆盖就可以了。
### 3.输出
用两个变量 $maxx$ 和 $maxy$ 计算出图的大小，然后直接按格式输出。
## 代码实现
```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
const char Stick[6][8]={"..+---+","./   /|","+---+ |","|   | +","|   |/.","+---+.."};//打表每个方块
int a[55][55];
char G[550][550];
void copy(int x,int y){  //贴到图上
    for(int i=0;i<6;i++){
        for(int j=0;j<7;j++){
            if(Stick[6-i-1][j]!='.') G[x-i][y+j]=Stick[6-i-1][j];
        }
    }
}
int main(){
    int n,m,k=0,l,x,y;
    cin>>n>>m;
    l=4*m+2*n+1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            k=max(k,a[i][j]*3+2*(n-i+1)+1); 
        }
    }
    for(int i=1;i<=k;i++){
    	for(int j=1;j<=l;j++){
    		G[i][j]='.';
		}   
	}       
    for(int i=1;i<=n;i++){ 
        for(int j=1;j<=m;j++){
            x=k-2*(n-i);
            y=2*(n-i)+4*(j-1)+1;
            while(a[i][j]--){
                copy(x,y);
                x-=3;
            }
        }
    }
    for(int i=1;i<=k;i++){
        for(int j=1;j<=l;j++) cout<<G[i][j];
        puts("");
    }
    return 0;
}
```

---

## 作者：gac497 (赞：0)

# 问题描述

小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$）。要求根据输入的矩阵，绘制出这些格子的立体图。

# 解题思路

## 1.积木的表示：

每个积木的图形由 $6$ 行组成，每行的字符数和位置是固定的。我们可以用一个二维数组 $c2$ 来存储一个积木的图形。

## 2.绘制积木：

对于每个格子上的积木，根据其位置和高度，计算出它在立体图中的起始坐标，然后调用 $\text{build}$ 函数将积木绘制到全局的字符数组 $c$ 中。

## 3.坐标计算：

积木的起始坐标需要根据其在矩阵中的位置和高度来计算。具体来说，第 $i$ 行第 $j$ 列的格子上的第 $k$ 个积木的起始坐标为 $((n-i) \times 2+1+3 \times k, (n-i) \times 2+1+4 \times j)$。

## 4.绘制立体图：

在绘制完所有积木后，根据 $maxx$ 和 $maxy$ 的值来确定立体图的大小，并输出字符数组 $c$ 中的内容。空白部分用 `.` 填充。

# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,maxx,maxy,a[1010][1010],dxy[6]={2,1,0,0,0,0},s[6]={6,6,6,6,5,4};
char c[1010][1010],c2[15][15]={
		"  +---+",
		" /   /|",
		"+---+ |",
		"|   | +",
		"|   |/",
		"+---+",
};

void build(int x,int y){
    for(int i=5;i>=0;i--){
        for(int j=dxy[i];j<=s[i];j++){
            c[5-i+x][j+y]=c2[i][j];
            if(5-i+x>maxx){
				maxx=5-i+x;
            }
            if(j+y>maxy){
				maxy=j+y;
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++){
            scanf("%d",&a[i][j]);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++){
            for(int k=0;k<a[i][j];k++){
                build((n-i)*2+1+3*k,(n-i)*2+1+4*j);
            }
        }
    }
    for(int i=maxx;i>=1;i--){    
        for(int j=1;j<=maxy;j++){
            if(c[i][j]=='\0'){
				printf(".");
            }else{
				printf("%c",c[i][j]);
            }
        }
        printf("\n");
    }
    return 0;
}
```

---


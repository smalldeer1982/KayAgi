# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# 题解

## 作者：brealid (赞：1040)

## 题目解析
这是一道模拟题，主要需要考虑以下几个约束条件：

1. 每个工件的下一个工序必须在上一个工序之后 
2. 同一台机器同一时刻只能加工一个工件
3. 按题目顺序安排下一个工件

按照题目说的做，不会错。

我的题解一般会放一组福利数据，这次也不例外。洛谷官方数据测试点#2奉上，附解释。

## 数据
### input
```plain
3 3
1 1 1 2 3 3 2 2 3
1 2 3
2 1 3
2 3 1
7 2 4
3 2 5
3 2 3
```
### output
```plain
18
```
### explain(可怜我画图花了好久)
![](https://i.loli.net/2019/01/24/5c49b57ea5613.png)
## 附：我的代码

```cpp
#include <stdio.h>

int m, n;
int list[501];
struct Information {
    int id;
    // 在第 id 台机器上加工
    int cost;
    // 花费 cost 时间
} a[21][21];
// a[第几个工件][第几步]
int mac[21][100001] = {0};
// mac[机器编号][时间（话说我也不知道时间最大是多少，反正在空间限制内尽量大）]
int step[21] = {0};
// 每个工件加工到了第几步
int las_time[21] = {0};
// 每个工件上次是 las_time[工件编号] 时加工完的
int ans = 0;

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= m * n; i++) {
        scanf("%d", list + i);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j].id);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j].cost);
        }
    }
    // 以上：读入
    for (int i = 1; i <= m * n; i++) {
        int now = list[i];
        step[now]++;
        int id = a[now][step[now]].id, cost = a[now][step[now]].cost;
        /* 调试代码 */ // printf("%d: now = %d, id = %d, cost = %d\n", i, now, id, cost);
        int s = 0;
        for (int j = las_time[now] + 1; ; j++) {
            if (mac[id][j] == 0) {
                s++;
            } else {
                s = 0;
            }
            if (s == cost) {
                for (int k = j - cost + 1; k <= j; k++) {
                    mac[id][k] = 1;
                }
                /* 调试代码 */ // printf("(%d~%d. \n", j - cost + 1, j);
                if (j > ans) ans = j;
                las_time[now] = j;
                break;
            }
        }
    }
    printf("%d", ans);
    return 0;
}
```
(无耻地求踩，太烂了)

---

## 作者：ShawnZhou (赞：174)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

超难理解的一道题。嘴上说着是一道大模拟实际上无法理解题意就会让事情变得巨麻烦。

**强烈建议画图研究样例。**

这是目前为止我所做过的难度最大的**纯**模拟题。一般来说，模拟题的题解文字说明都比较少，因为代码具体什么意思大家一般都能看明白，但这道题不太一样，所以我打算写的稍微多一些。

这类长模拟代码看的时间久了对一些变量可能有记忆混淆的事情发生，所以我在主要过程基本没使用简单的单字母或者双字母命名变量，那样会严重丧失可读性。

我们来分析一下题意。

题目已经给出了安排好的工序，而每个工序需要在几号机上完成以及每个工序的时间也给了出来，我们要做的就是合理安排机器的工作，让总的加工时间最短。

按照题意的约定，最短方案有且只有一种，而且不必判断输入的合法性。

我们可以把机器想成若干个「时间线」，在这条时间线上去安排工作。

那么明显的，每个时间段对应的机器就只有俩状态：

1.我在干活

2.我闲着呢

而每一个工件也有自己的加工要求，对于每个工件的工序，总应该先完成小号工序再完成大号工序，也就是必须顺着编号来。

每台机器只能在某时刻进行一种工作，并且后面的安排不能把前面的安排改动掉。

模拟的思想便是从左到右无限扫描整个时间线，然后去尝试插空。

这里有三个辅助数组，如果难理解它们的作用将对我的代码有理解困难。第一个是cnt\_now\_work\_step，它表示当前取到工件的工序数。根据之前输入的workline，每个数都代表一个安排的工序，这个数组就是用来方便后面处理工序的，尽管它名字比较长。第二个是lasttime，它代表某个工件出现的最晚的时间（点），它可以用来方便我们扫描时间线，因为每一个工件必须要完全完成上一道工序后才能接着继续下一道工序。第三个是二维bool数组timeline，它代表某一台机器在某一个时间（点）上是不是正在干活。

有了这三个辅助数组，我们就可以开始按照模拟的思路写代码了。

我们取当前工件nowitem[i]，让cnt\_now\_work\_step[nowitem]++，即代表这个工件的工序+1，用nownumber记录当前工件在当前工序时位于哪一台机器，costtime表示做完这道工序应该花费的时间，lasttime[nowitem]+1便是我们扫描时间线的开端，注意lasttime记录的是时间点。这个for没有终止条件，因为时间轴可能会无穷远。

接下来是关键，判断从这个时间点到干完这道工序，机器有没有空，如果机器表示“我闲着呢”，那么就把这道工序安排给机器的这个时间段，更新timeline和lasttime（lasttime[nowitem] = time + costtime - 1，干完活之后这个工件出现的最晚的时间点应该是这道新工序做完的那一刻），然后更新操作立即break掉，继续扫描时间线。如果机器表示“这个时间段我在干其他活”，那这个任务就不能放在这一段，时间线继续扫描。

这个判断要如何写？我用了一个函数，它传入起始时间点和终止时间点和工件编号，然后去判断它的timeline就好。

循环完所有的工件，整个的时间轴也就确定了。

最后去寻找ans，ans应该等于值最大的那个lasttime（即这个工件最后才做完）。

输出ans即可。

参考代码：

```cpp
#include <iostream>
#define maxn 50
using namespace std;
int n,m;
int ans = 0;
int worklist[maxn * maxn];
int worknumber[maxn][maxn];
int worktime[maxn][maxn];
int cnt_now_work_step[maxn];
int lasttime[maxn];
bool timeline[maxn * maxn][maxn * maxn];

bool check_in_line(int begin_time_point,int end_time_length,int workid){
    for (int time = begin_time_point; time <= end_time_length;time++)
        if (timeline[workid][time])
            return false;
    return true;    
}

int main(){
    cin >> m >> n;
    for (int i=1;i<=n*m;i++)
        cin >> worklist[i];

    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            cin >> worknumber[i][j];

    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            cin >> worktime[i][j];

    for (int i=1;i<=n*m;i++){
        int nowitem = worklist[i];
        cnt_now_work_step[nowitem]++;//工序数
        int nownumber = worknumber[nowitem][cnt_now_work_step[nowitem]];
        int costtime = worktime[nowitem][cnt_now_work_step[nowitem]];
        
        for (int time = lasttime[nowitem]+1;;time++)//扫描时间轴
            if (check_in_line(time,time+costtime-1,nownumber)){
                for (int marktime = time;marktime <= time+costtime-1;marktime++)
                    timeline[nownumber][marktime] = true;
                lasttime[nowitem] = time + costtime - 1;
                break;
            }
    }

    for (int i=1;i<=n;i++)
        ans = max(ans,lasttime[i]);

    cout << ans << endl;

    return 0;
}
```

---

## 作者：SimonSu (赞：24)

大佬们把题意讲的也都是足够清楚了，我就再特别提一下一些打代码时候的技巧吧

1. 变量名尽量简洁，最好是对应的英文缩写或者汉语拼音缩写，并且一个代码里尽可能避免相似度极高的变量，如：ii , ij ,ji ,jj ,il ,li…… 当他们同时出现，你不仅容易打错，debug的时候几乎是逼近眼力极限

1. 在一个题编写的过程中可以使用调用函数的方法使代码片段化，不仅可以理清思路，而且看得更顺心。如果实在要写在主函数里，可以使用空行隔开。而且在强制压行之前应分开写完确认无误后再去删除，不然bug de到死。

1. 另外当你的数组调用时是套了几个时，可以先开变量存下来，之后再调用。

1. 适当的注释对自己对思路的理解非常有用

其他的话就是看个人习惯了，你自己觉得最舒服的就是最好的。以上建议仁者见仁，智者见智吧。

希望大家都可以提高码力

noip 2019 RP++



------------
本题 大模拟 数据这么小 跑就是了！

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<queue>
#include<stack>
#include<cmath>
#define LL long long
using namespace std;
inline void read(int &x){
	x=0;int f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();	}
	while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	x*=f;
}
struct node{
	int num,tim;
}e[22][22];
int n,m;//n工件数 m机器数及工序数 
int mac[22][40000];
int ord[400];
int now[22];
int be[22];

int main()
{
	read(m),read(n);  int tmp=n*m;
	for(int i=1;i<=tmp;i++) read(ord[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			read(e[i][j].num);
			
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			read(e[i][j].tim);
			
	int ans=0;
	for(int i=1;i<=tmp;i++)//大模拟 
	{
		int whi=ord[i];//第几个工件 
		int wha=(++now[whi]);//第几步骤
		
		int ma=e[whi][wha].num;//哪个机器 
		int go=e[whi][wha].tim;//多少时间
		
		int cnt=0,end;
		for(int j=be[whi]+1;;j++)
		{
			if(mac[ma][j]==0) cnt++;
			else cnt=0;
			if(cnt==go)
			{
				end=j;
				break;
			}
		}
		
		for(int j=end-go+1;j<=end;j++) mac[ma][j]=1;
		
		be[whi]=end;
		
		ans=max(ans,end);
	}
	
	printf("%d",ans);
	return 0;
}
```


---

## 作者：qhr2023 (赞：12)

## solution

一道模拟题，发现数据很小，可以用枚举时间的方法。我们先约定一些变量。

* $a_i$ 表示现在要加工第几个**工件**。
* $b_{i, j}$ 表示第 $i$ 个工件的第 $j$ 个工序所使用的**机器编号**。
* $t_{i, j}$ 表示第 $i$ 个工件的第 $j$ 个工序所用的**时间**。
* $use_{i, j}$ 表示第 $i$ 个机器在第 $j$ 个时间**是否**被使用，为 $1$ 被使用，为 $0$ 表示没被使用。
* $now_i$ 表示第 $i$ 个工件加工到**第几个工序**。
* $lst_i$ 表示第 $i$ 个工件上个工序是**几时**加工完的。

模拟过程：若当前要加工第 $i$ 工件，先更新 $now_i$，把 $now_i$ 加一，即该工件加工到第 $now_i$ 个工序，那我们就从该工件加工完上一个工序之后，找一段该工件所使用的机器没加工其他工件的时间，即从 $lst_i+1$ 开始枚举时间 $j$，找一段长为 $t_{i, now_i}$ 的时间，使这段时间内 $use_{b_{i, now_i}, j}$ 都为 $0$。找到之后，还要更新 $use$、答案和 $lst_i$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n, a[405], b[25][25], t[25][25], use[21][8005], now[25], lst[25], ans;
int main () {
	cin >> m >> n;
	for (int i=1; i<=m*n; ++i)
		cin >> a[i];
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=m; ++j)
			cin >> b[i][j];
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=m; ++j)
			cin >> t[i][j];
	for (int i=1; i<=m*n; ++i) 
        for (int id=b[a[i]][++now[a[i]]], w=t[a[i]][now[a[i]]], s=0, j=lst[a[i]]+1; s<w; ++j) {
        	s=(use[id][j]?0:s+1);
        	if (s==w) {
        		for (int k=j-w+1; k<=j; k++) 
            		use[id][k]=1;
        		ans=max(ans, j);
        		lst[a[i]] = j;
			}
		}
	cout << ans;
    return 0;
} 
```

---

## 作者：Greeper (赞：6)

# 题意分析
>注：本题的模拟不是模拟最优解，只需要按题意模拟即可

## 解释题意
有 $n$ 个零件与 $m$ 个机器，每个零件有 $m$ 个工序，并且有独立的加工时间和所需的机器，每个工序的加工需要满足此零件所有在此工序之前的工序被完成。\
现在给定一个长 $n \times m$ 序列，表示安排工序的顺序 **（注意！是按照序列安排，不是按照顺序加工！）**，紧接着给出每个工序加工所需的机器和加工所需的时间，求安排后加工完所有零件的所有工序的最短时间 **（注意！是按顺序安排后的最短时间，不是绝对最短时间）**。
## 做法分析
### 先考虑朴素模拟：
存储每一个机器的使用情况，记录每一个时间单位每个机器是否在工作，对于每一个工序，遍历所需机器的占用情况，找出第一段在此零件上一工序结束后长度足够加工该工序的第一段无占用区间（真的很绕口）。
### 考虑优化：
因为暴力的规划时间复杂度高达 $O(m^2n^2t)$，$m \times n$ 个工序，$t$ 为最大时间，所有工序都在一个机器里时的复杂度为 $n \times m \times t$，综合得到 $m^2n^2t$），看数据都小于20……\
好吧，所以 $O(m^2n^2t)$ 等同于 $O(20^5)$，也就是 $3.2 \times 10^6$ 次运算，可以直接算。
>小芝士：各复杂度的数据处理极限\
> $O( \log n) \approx 2^{10^7}$\
> $O(n) \approx 10^7$\
> $O(n \log n) \approx 10^6$\
> $O(n^2) \approx 5 \times 10^3$\
> $O(n^3) \approx 300$\
> $O(n^4) \approx 60$\
> $O(2^n) \approx 20$\
> $O(n!) \approx 12$

# 代码实现
考虑维护每个机器的占用情况，每个零件目前加工到了哪个步骤，每个零件最后一次加工完成的时间。\
然后就直接代码实现啦！！
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=25;//数据极限 
int T,n,m,p,k;
int x;
int a[N*N];//操作序列考虑m*n空间 
int r[N][N],t[N][N];//加工所需的地点与时间 
int last[N],lst[N];//维护每个零件目前加工了的步骤数和最后一次加工的结束时间 
int mac[N][N*N*N];//维护每一个机器的占用情况，因为题目里没说每个零件的工序一定在不同的机器，对于每一个机器维护n*m*t（零件数量*每个零件的工序数量*每个工序的最大时间 
int ans;//答案 
int main()
{
	cin>>m>>n;//开始读入 
	for(int i=1;i<=n*m;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>r[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>t[i][j];
		}
	}//结束读入 
	for(int i=1;i<=n*m;i++)//枚举工序 
	{
		last[a[i]]++;//该零件正在进行工序加一 
		int ma=r[a[i]][last[a[i]]],ti=t[a[i]][last[a[i]]];//分别记录加工该工序的机器和时间 
		int sum=0;//计数器，用于记录当前段空间长度 
		for(int j=lst[a[i]]+1;j<=N*N*N-5;j++)//j从上一个工序结束后开始遍历，因为要先加工完前面的工序，遍历到极限时间 
		{
			if(mac[ma][j])sum=0;//如果该位置已被占用就清零计数器（本段时间不够加工该工件 
			else sum++;//否则计数器加一 
			if(sum==ti)//长度足够 
			{
				lst[a[i]]=j;//更新最后加工时间 
				while(ti--)
				{
					mac[ma][j-ti]=a[i];//由于while里面的条件会先执行，所以此时的ti已经减过一了，不要写j-ti+1，结尾的a[i]可以改为1标记，此处只是为了方便检查 
				}
				break;//已经找到最优位置，停止枚举 
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=N*N*N-5;j>=1;j--)//倒序枚举找到答案 
		{
			if(mac[i][j])
			{
				ans=max(ans,j);//记录答案 
				break;//找到最后的结果，不用往下找了 
			}
		}
	}
	cout<<ans;//输出 
	return 0;//完结撒花 
}
```
完结撒花！

---

## 作者：Kun_is_Me (赞：6)

### 题目分析

纯模拟。

依照题意模拟是 OIer 的必修技能，所以本题依照题意一步一步模拟即可，具体不再展开。

需要注意几个条件：

1. 每一个工件必须按照工序进行，后面的工序不能先于前面的工序进行
2. 每一台机器每一个时刻只能完成一道工序
3. 需要按题目顺序安排

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int lst[514];
struct inf{int id,cost;}a[25][25];
int mc[25][114514]={0},stp[25]={0},ltime[25]={0},ans=0;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>m>>n;
	for(int i=1;i<=m*n;i++)cin>>lst[i];
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)cin>>a[i][j].id;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j].cost;
    for(int i=1;i<=m*n;i++)
	{
        int nw=lst[i];
        stp[nw]++;
        int id=a[nw][stp[nw]].id,cost=a[nw][stp[nw]].cost;
        int s=0;
        for (int j=ltime[nw]+1;;j++)
		{
            if (mc[id][j]==0) s++;
            else s=0;
            if (s==cost)
			{
                for(int k=j-cost+1;k<=j;k++) mc[id][k]=1;
                if (j>ans) ans=j;
                ltime[nw]=j;
                break;
            }
        }
    }
    cout<<ans;
    return 0;
}
```

为了防止有人说我的 TJ 过不了，在这里把 [AC 记录](https://www.luogu.com.cn/record/201136150) 贴上。

欢迎大家前来 hack。

不说了，我要去写大模拟了，Bye！

---

## 作者：取名最烦 (赞：6)

这是一道考察审题与代码实现能力的题。
题目已经将详细算法都告诉我们了，只要照着模拟即可。

建立一个标记数组，每次操作直接扫描整条时间线，直到找到一个足够大的空档为止。

同时储存每个工件上一工序结束时间与每台机器目前的最后工作时间，供搜索时使用，会快很多。

最后在所有工件的最后工作时间里找个最大的，就是答案。

上代码，**我是P党**。
```pascal
var i,j,k,l,m,n,s,t,x,y:longint;
a,b:array[0..30,0..30]of longint;
p,c,ti,st:array[1..1000]of longint;
q:array[1..30,1..10000]of longint;
begin
 read(m,n);
 for i:=1 to n*m do read(c[i]);
 for i:=1 to n do
  for j:=1 to m do read(a[i,j]);
 for i:=1 to n do
  for j:=1 to m do read(b[i,j]);
 for i:=1 to n do st[i]:=1;
 for i:=1 to n*m do
 begin
  inc(p[c[i]]);
  k:=1;
  l:=0;
  t:=0;
  x:=st[c[i]];
  if st[c[i]]>ti[a[c[i],p[c[i]]]] then ti[a[c[i],p[c[i]]]]:=st[c[i]]-1;
  for j:=st[c[i]] to ti[a[c[i],p[c[i]]]] do
  begin
   if q[a[c[i],p[c[i]]],j]<>0 then
   begin
    if l>=b[c[i],p[c[i]]] then
    begin
     t:=1;
     break;
    end;
    l:=0;
    x:=j+1;
   end else inc(l);
  end;
  if t=0 then
  begin
   for j:=ti[a[c[i],p[c[i]]]]+1 to ti[a[c[i],p[c[i]]]]+b[c[i],p[c[i]]] do q[a[c[i],p[c[i]]],j]:=c[i];
   inc(ti[a[c[i],p[c[i]]]],b[c[i],p[c[i]]]);
   st[c[i]]:=ti[a[c[i],p[c[i]]]]+1;
  end else
  begin
   for j:=x to x+b[c[i],p[c[i]]]-1 do q[a[c[i],p[c[i]]],j]:=c[i];
   st[c[i]]:=x+b[c[i],p[c[i]]];
  end;
 end;
 for i:=1 to m do if ti[i]>s then s:=ti[i];
 writeln(s);
 {for i:=1 to m do
 begin
  for j:=1 to s do write(q[i,j]);
  writeln;
 end;}//调试环节
end.


```

---

## 作者：翠竹叶飞 (赞：5)

/\*
乍一看，不知所云；细读数遍，一头雾水。

这道题目的题面实在是很难理解，这也就是它的难度较高的最最主要原因。

这真是一道高质量的模拟题，堪称模拟中的经典，可谓融会贯通！

考察语文（审题能力）而且一定要看懂题目，否则就是扯淡。

题目很长，大意如下：

1.按照给定的安排顺序依次安排

2.同一工件的每道工序在之前工序完成后才可以开始

3.每一操作插入最前面的空档中

于是方案唯一，简单模拟即可。

附赠主要算法

1.按照安排顺序模拟

2.每个工件记录最后时间

考虑到n,m<20，无需考虑时间复杂度，只需细心即可。

由于条件复杂，需注意每个变量的含义

\*/
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int i,j,k,m,n,ans;
int a[405]; //安排顺序 
int mord[21][21],t[21][21];
int cnt[21],last_[21]; //last_ 每个工件最晚时间 
bool rec[21][8001]; //每台机器的每个时间是否被占用 
int main()
{
    scanf("%d%d",&m,&n);
    for (i=1; i<=m*n; i++)
        scanf("%d",&a[i]);
    for (i=1; i<=n; i++)
        for (j=1; j<=m; j++)
            scanf("%d",&mord[i][j]);
    for (i=1; i<=n; i++)
        for (j=1; j<=m; j++)
            scanf("%d",&t[i][j]);
    for (i=1; i<=m*n; i++) {
        cnt[a[i]]++;
        int tmp1=a[i],tmp2=cnt[tmp1]; //tmp1:工件 tmp2:工序
        int tmpm=mord[tmp1][tmp2]; //机器号 //t[tmp1][tmp2]
        for (j=last_[tmp1];;j++) {
            bool flag = 1;
            for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
                if (rec[tmpm][k]) { 
                    flag = 0;
                    break;
                }
            if (flag) {
                for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
                    rec[tmpm][k] = 1; //扔入空档
                last_[tmp1] = max(last_[tmp1],j+t[tmp1][tmp2]);
                ans = max(ans,last_[tmp1]); //将新覆盖的结束点更新 
                //printf("%d : %d %d\n",i,j+1,j+t[tmp1][tmp2]);
                break;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ClV_Csy (赞：3)

# P1065 [NOIP2006 提高组] 作业调度方案
## 题意
先给出机器数 $m$（工序数也为 $m$）和工件数 $n$。再给出 $m \times n$ 个数，为安排顺序。最后给出 $2$ 组 $n$ 行，每行 $m$ 个数的数据，第一组表示每个工件的每个工序的**机器号**，第二组表示每个工件的每个工序的**加工时间**。  
按题目的约束条件完成工件加工（保证实施方案唯一），求出该方案完成全部任务所需的总时间。
## 思路
比较复杂的模拟题，需要很多变量。
1. int 数组 `l[410]`，存储给定的安排顺序。
2. 结构体 `a[30][30]`，其中 `a[i][j]` 表示第 $i$ 个工件的第 $j$ 个工序的一些性质，拥有成员变量 `id`，表示它所需的机器号以及 `time`，表示加工它所需的时间。

以上变量用于保存输入数据。
```cpp
#include <iostream>
using namespace std;
int m, n;
int l[410];
struct node {
	int id, time;
} a[30][30];
int main() {
	cin >> m >> n;
	for (int i = 1; i <= m * n; i++)
		cin >> l[i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].id;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].time;
	return 0;
}
```
3. int 数组 `step[30]`，保存每个工件已经完成的最后一个工序编号。
4. int 数组 `last[30]`，保存每一个机器完成当前已经完成的最后一道工序的时间点。
5. bool 数组 `mac[30][8010]`，保存每个机器的每个时间点是否有在加工。
6. int 变量 `ans`，表示当前加工所需总时间。

其他的变量较为琐碎，在代码中体现。
## 代码

```cpp
#include <iostream>
using namespace std;
int m, n;
int l[410];
struct node {
	int id, time;
} a[30][30];
int step[30];
int last[30], ans;
bool mac[30][8010];
int main() {
	cin >> m >> n;
	for (int i = 1; i <= m * n; i++)
		cin >> l[i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].id;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].time;
	for (int i = 1; i <= n * m; i++) {
		int now = l[i]; //now表示当前加工的工件编号
		step[now]++; //该工件完成的工序编号加1
		int id = a[now][step[now]].id; //获取当前工序需要的机器编号
		int time = a[now][step[now]].time; //获取当前工序需要的加工时间
		int sum = 0; //统计加工所用的时间
		for (int j = last[now] + 1; ; j++) {
			if (mac[id][j]) //若当前时间点已经有工件在加工
				sum = 0;
			else {
				sum++;
				if (sum == time) {
					for (int k = j - time + 1; k <= j; k++) //循环time次，最后一次在j的时间点
						mac[id][k] = 1; //标记有工件在加工
					ans = max(ans, j); //更新加工总时间
					last[now] = j; //更新当前工件的最后一道工序的时间点
					break;
				}
			}
		}
	}
	cout << ans; //输出所得时间
	return 0;
}
```

---

## 作者：Doraeman (赞：2)

~~读题可真是个困难啊。~~
## 题意
给出多个工件，每个工件又分为不同工序，**按照题目要求的安排顺序正确分配每个工序的时间**。

不难发现，这道题给出的“安排方案约束条件”会得到唯一的方案，所以不用我们考虑最优策略的问题，直接按照题意模拟即可。
## 读入
读入所有重要的数据。
1. 安排顺序（按照这个顺序模拟）。
2. 编号，即（工件号，工序号）。
3. 机器。
4. 时间。

用结构体记录每道工序的基本信息。
1. 完成时间。
2. 使用的机器。
## 做法
1. 数组记录安排顺序，并按照这个顺序模拟。
2. 数组记录各个机器的安排情况。
3. 用来安排工序先后的函数：返回最早的可以挑选的时间。
4. 按照安排顺序安排每个工序。
5. 检查从找到的最早的可以挑选的时间 $L$ 到工序的结束时间 $R$ 能否完整放置工序。
## 详细解法
我将主要讲解**用于安排各个工序的函数**。

首先，使用布尔数组记录每个机器的每个时间点是否已经有安排。如果有安排，不能考虑方案；如果没有安排，可以考虑将**正在被安排的工序**放置在这个时间。

其次，从这道工序的同工件的**上一道工序的结束时间或者这个机器的上一道工序的结束时间开始**（因为题目给出的约束条件 $1$：对同一个工件，每道工序必须在它前面的工序完成后才能开始），在这个工序要求的机器上寻找时间段，每次找到连续时间段后**检查这个空时间段是否足够长**，即能不能放下整个工序。  
如果时间长度足够，将这段时间全部标记为 $1$，表示**这个连续的时间都已经被占用**，以后的工序不能被安排在这段时间。  
同时，记录**这个工序的结束时间**（下次寻找时间段时从这个时间开始找，同时**这个结束时间可能能是全部工序的结束时间**）。  
如果长度不够，继续向后遍历寻找长度足够的时间段。
## 记录答案
每个工序完成的末端点（上面已经讲过，这个数值还可用作时间段遍历的开始）。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 25, M = 25, T = 40000;
// 此处T表示完成所有工序所用的最长时间，无法确定，可以先试一个大数，注意不要空间超限 

/*
1.struct记录每道工序的基本信息：
  完成时间 
  使用的机器 
2.数组记录安排顺序，并按照这个顺序模拟（这个数组关乎） 
3.数组记录各个机器的安排情况  
4.用来安排工序先后的函数：返回最早的可以挑选的时间 
*/

struct work{
	int r, t, end; 
	// robot, time, order, end;
}a[N][M]; 

int o[N], ord[N*M][2], cnt; bool robot[M][T];
// o[i] 表示 第i个工件目前有几个工序 
// ord[i][0] 表示 安排顺序的第i项的工件编号(x) 
// ord[i][1] 表示 安排顺序的第i项的工序编号(y)
// robot[i][j] 表示 第i个机器的第j个时间点是否有安排 (有安排为 1) 
 
void make(int x, int y){
	int rob = a[x][y].r, 
		tim = a[x][y].t; 
		
	for(int L=a[x][y-1].end+1; ; L++){
		// L遍历第x个工件的第y道工序的左端点（开始点） 
		// L的范围是 (上一道工序的结束时间, ∞) 
		bool flag = 1;
		for(int R=L; R<=L+tim-1; R++){
			// R：从当前假定的左端点L开始，是否存在连续的tim个时间点的空位 
			if(robot[rob][R] == 1){
				// =1表示已经有安排，不用再考虑从L开始的左端点 
				flag = 0;
				break;
			}
		}
		if(!flag) continue;
		// 如果标记是当前左端点假设错误，直接开始下一次假设
		// 如果没有回到循环开头，表示当前左端点假设正确，即为最小左端点，开始计算答案并更改robot数组  
		
		// 标记a[x][y]的结束点，用于最后求出整个工程的结束点(max)
		a[x][y].end = L + tim - 1;
		// 或者写成 a[x][y].end = R; 但R需要提前定义 
		
		// 更新robot数组，所有(x, y)所占据的时间点都被标为1(表示有工序占据了这个时间点)
		for(int R=L; R<=L+tim-1; R++)
			robot[rob][R] = 1;
			 
		return; // 得到了答案，可以返回 
	}
}

int main(){
    int m, n;
    cin >> m >> n;
    for(int i=1; i<=n; i++)
    	for(int j=1; j<=m; j++){
			int x; cin >> x;
	    	
	    	o[x]++, cnt++; 
	    	ord[cnt][0] = x,
	    	ord[cnt][1] = o[x];
		}
		
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			cin >> a[i][j].r;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			cin >> a[i][j].t;
			
	for(int i=1; i<=n*m; i++)
		make(ord[i][0], ord[i][1]);
	
	// 遍历a[i][j]数组，求第i个工件的第j项工序的结束点最大是多少，即为我们所求的答案（总耗时按照最后一个时间点计算） 
	int ans = -1;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			ans = max(ans, a[i][j].end);
			
	cout << ans;
	
	return 0; 
}
```

---

## 作者：ARZhu (赞：1)

感谢 stl，要不是 stl，我还真不知道怎么处理**比较快速**得处理空闲时间段。而且其他很多题解都默认了时间段是一万以内或是多少。如果操作的时间到 $10^9$，那些方法都会完蛋。

这道题目的难点就在于如何维护每一个机器到底在哪些连续的时间段是有空档的；知道哪些连续的时间段是空的，才能把后面的工序插入到这些空闲时间段中。

这不就是操作系统里面的内存分配问题嘛！空闲的内存就相当于这道题目里面的空闲时间段，进程相当于这道题目里面的工序。而且是题目告诉你怎么分配了，不需要想奇技淫巧去想怎么最优化分配内存空间。唉，又让我想起被 ICS 和操作系统课程折磨的痛苦，那时候维护空闲内存的方法大抵就是用链表，或者高端一点的用平衡数。我是不会再去考虑手搓链表的了，不如直接借用 stl 里面的 `map` 来维护每个机器的空闲时间段，然后从头到尾遍历一遍是否有满足题意的空闲时间段。这里有一个小技巧：初始化的时候，空闲时间段可以认为是 `[0, INF]`，`INF` 就取很大很大的数就可以了。

下面是代码。


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <utility>
#include <set>
using namespace std;
const int INF = (1 << 30) -1;
int seq[410], machinenum[21][21], t[21][21];
int step[21], stamp[21];
set<pair<int, int> > interval[21];
void insert(int l, int r, int machi) {
    if(r-l<=0) return;
    interval[machi].insert(make_pair(l, r));
}
int main() {
    int m, n;
    scanf("%d %d", &m, &n);
    for(int i=1; i<=m*n; ++i) scanf("%d", &seq[i]);
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=m; ++j) scanf("%d", &machinenum[i][j]);
    for(int i=1; i<=n; ++i) 
        for(int j=1; j<=m; ++j) scanf("%d", &t[i][j]); 
    
    for(int i=1; i<=m; ++i) interval[i].insert(make_pair(0, INF));

    for(int i=1; i<=n*m; ++i) {
        int cur_art = seq[i]; 
        step[cur_art] ++;
        int cur_machi = machinenum[cur_art][step[cur_art]], cur_time = t[cur_art][step[cur_art]];
        for(set<pair<int, int> >::iterator ii = interval[cur_machi].begin(); ii != interval[cur_machi].end(); ++ ii) {
            int l = ii->first, r = ii->second;
            if(l < stamp[cur_art]) { 
                if(r - stamp[cur_art] >= cur_time) {
                    interval[cur_machi].erase(make_pair(l, r));
                    insert(l, stamp[cur_art], cur_machi);
                    insert(stamp[cur_art]+cur_time, r, cur_machi);
                    stamp[cur_art] = stamp[cur_art] + cur_time;
                    break;
                }
            } else {
                if(r - l >= cur_time) {
                    interval[cur_machi].erase(make_pair(l,r));
                    insert(l+cur_time, r, cur_machi);
                    stamp[cur_art] = l+cur_time;
                    break;
                }
            }
        } 
    }
    int res = 0;
    for(int i=1; i<=n; ++i) res = max(res, stamp[i]);

    printf("%d\n", res);
    return 0;
}
```

---

## 作者：jej333 (赞：1)

## 前言
这个题的题面非常长，而且还很难读懂。作为一道黄题，难度还是非常大的（蒟蒻的发言）。
## 正文

这题有很多要注意的点。

注意事项：
1. 每个工件的一个步骤只能由指定的机器加工；
2. 只能先完成工件的前面步骤再完成后面的；
3. 一台机器在某一个时刻只能有两种状态：加工一个零件或者闲着。
4. 尽可能让每台机器每时每刻都在工作。（也就是尽可能插空）

照着题意模拟就行，此处不赘述（我觉得这题测试点读题占一半分，代码极简）。

贴上 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c[401],cnt,e[21][100001],f[21],g[21],n,h,k,num=0,l;
struct gj{
	int h,time;
}d[21][21];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>a>>b;
	for(int i=1;i<=a*b;i++) cin>>c[i];
	for(int i=1;i<=b;i++){
		for(int j=1;j<=a;j++) cin>>d[i][j].h;
	}
	for(int i=1;i<=b;i++){
		for(int j=1;j<=a;j++) cin>>d[i][j].time;
	}
	for(int i=1;i<=a*b;i++){
		n=c[i];
		f[n]++;
		h=d[n][f[n]].h;
		k=d[n][f[n]].time;
		num=0;
		for(l=g[n]+1;;l++){
			if(!e[h][l]) num++;
		    else num=0;
		    if(num==k){
			    if(l>cnt) cnt=l;
			    for(int j=l-k+1;j<=l;j++) e[h][j]=1;
		    	g[n]=l;
			    break;
	        }
	    }
	}
	cout<<cnt;
	return 0;
}
```

---


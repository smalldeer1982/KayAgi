# [NOIP 2012 普及组] 摆花

## 题目描述

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

## 说明/提示

【数据范围】

对于 $20\%$ 数据，有 $0<n \le 8,0<m \le 8,0 \le a_i \le 8$。

对于 $50\%$ 数据，有 $0<n \le 20,0<m \le 20,0 \le a_i \le 20$。

对于 $100\%$ 数据，有 $0<n \le 100,0<m \le 100,0 \le a_i \le 100$。

NOIP 2012 普及组 第三题


## 样例 #1

### 输入

```
2 4
3 2
```

### 输出

```
2```

# 题解

## 作者：Godのfather (赞：2608)

# 摆花解题报告

> 这是一篇长达三年的解题报告。

### update on 2020.10.21：

增加了前缀和优化

### update on 2021.03.18：

增加了生成函数做法，修改了部分内容，更正了部分谬误。

### update on 2021.07.30：

增加了生成函数（封闭形式）的做法，更正了部分谬误。

## （〇）数学符号注释

> 本文中的某些符号体系并不标准，一些读者会在其他书中学习类似的内容。这里列出了他们可能不熟悉的符号。

| 符号                      | 名称                       | 等价形式                                            |
| :------------------------ | :------------------------- | :-------------------------------------------------- |
| $\sum\limits_{i=1}^na_i$  | 求和（和式）               | $a_1+a_2+\cdots+a_{n-1}+a_n$                        |
| $\prod\limits_{i=1}^na_i$ | 求积                       | $a_1\times a_2\times\cdots\times a_{n-1}\times a_n$ |
| $[m=n]$                   | 如果$m=n$值为$1$;否则为$0$ | $\begin{cases}1&m=n\\ 0& m\not=n\end{cases}$        |


## （一）题目大意

[题目传送门](https://www.luogu.org/problemnew/show/P1077)

简化一下题意：

有 $n$ 个数（$c_1,c_2,...,c_n$）， $0\leqslant c_i\leqslant a_i$,求有多少种方案数使$\sum\limits_{i=1}^nc_i = m$。

## （二）解题思路

乍一看，似乎题目有些复杂，一时找不到思路，肿么办!!!

### 方法一：搜索

没有思路当然就搜索啦 ~~废话~~。如何搜索呢？

从 1 到 $n$​ 考虑每个 $c_i$​ 的值，和当前前 $i$​ 个数的总和 $k$​，然后枚举当前 $x_i$​ 所有可能的值，再递归求解。

时间复杂度 $O(\prod\limits_{i=1}^na_i)$，明显超时，~~但可以拿部分分（30）嘛...~~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105, mod = 1000007;
int n, m, a[maxn];
int dfs(int x,int k)
{
    if(k > m) return 0;
    if(k == m) return 1;
    if(x == n+1) return 0;
    int ans = 0;
    for(int i=0; i<=a[x]; i++) ans = (ans + dfs(x+1, k+i))%mod;
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    cout<<dfs(1,0)<<endl;
    return 0;
}
```

搜索超时怎么办!!! 别着急...

### 方法二（搜索优化法宝）：记忆化

所谓记忆化，其实就是用一个数组将搜索过的值存起来，避免重复搜索，从而提高效率。~~（有必要可以上网搜一下，会搜索的应该很容易理解记忆化吧）~~

时间复杂度大概是：$O(nma_i)$ 吧，100%的数据稳过。

代码（其实只是改动了一点点）：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=105, mod = 1000007;
int n, m, a[maxn], rmb[maxn][maxn];
int dfs(int x,int k)
{
    if(k > m) return 0;
    if(k == m) return 1;
    if(x == n+1) return 0;
    if(rmb[x][k]) return rmb[x][k]; //搜过了就返回
    int ans = 0;
    for(int i=0; i<=a[x]; i++) ans = (ans + dfs(x+1, k+i))%mod;
    rmb[x][k] = ans; //记录当前状态的结果
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    cout<<dfs(1,0)<<endl;
    return 0;
}
```

但是搜索的时间有些不稳定，想要更稳定的算法有木有...

### 方法三：动态规划

记忆化搜索都可以转成动态规划，但是动态规划却不一定能转成记忆化搜索 ——$by$  $clg$

定义状态：$f(i, j)$ 表示前 $i$ 个数总和为 $j$ 的方案数。

那么，易得状态转移方程：$f(i, j) = \sum\limits_{k=0}^{a_{i}}f(i-1,j-k)$

其中, $k$是枚举当前第 $i$ 个数的取值。

时间复杂度：$O(nma_i)$，稳得一批。

空间复杂度：$O(nm)$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105, mod = 1000007;
int n, m, a[maxn], f[maxn][maxn];
int main()
{
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    f[0][0] = 1;
    for(int i=1; i<=n; i++)
       for(int j=0; j<=m; j++)
           for(int k=0; k<=min(j, a[i]); k++)
              f[i][j] = (f[i][j] + f[i-1][j-k])%mod;
    cout<<f[n][m]<<endl;
    return 0;
}
```

仔细观察上述代码，有木有发现什么...

### 方法四(dp优化法宝)：滚动数组

因为我们发现，状态转移方程中，当前状态 $f(i, j)$只跟 $f(i-1, j)$ 有关系，与 $i-2,i-3...$无关。于是，我们可以利用滚动数组优化dp。

所谓滚动数组，其实就是**只保留两个状态**（当前状态和前一个状态），算完当前状态后，将当前状态变为前一个状态，再去算下一个状态，看上去就像二维数组的两层不断地**迭代**。

时间复杂度：$O(nma_i)$

空间复杂度：$O(m)$

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=105, mod = 1000007;
int n, m, a[maxn], f[2][maxn], t;
int main()
{
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    f[0][0] = 1;
    for(int i=1; i<=n; i++)
    {
        t = 1-t; //滚动
        for(int j=0; j<=m; j++)
        {
            f[t][j] = 0; //注意初始化
            for(int k=0; k<=min(j, a[i]); k++)
              f[t][j] = (f[t][j] + f[1-t][j-k])%mod;
        }
    }
    cout<<f[t][m]<<endl;
    return 0;
}
```

看到上述dp代码，有木有感觉很熟悉...

这熟悉的优化方法... 这~~TM~~不就是个**背包**吗!!!

### 方法五(背包大法好)：一维动态规划

通过观察上面的代码，二维数组，数组滚动优化空间......还有那熟悉的格式...

猛然发现这怎么可能不是**背包**呢（01背包）？

既然是背包，那么就可以为所欲为啦... [邪恶.jpg]

直接压成一维的**01背包**，跑一波，搞掂!!!

时间复杂度：$O(nma_i)$

空间复杂度：$O(m)$

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=105, mod = 1000007;
int n, m, a[maxn], f[maxn];
int main()
{
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    f[0] = 1;
    for(int i=1; i<=n; i++)
        for(int j=m; j>=0; j--) //注意，是01背包
            for(int k=1; k<=min(a[i], j); k++)
              f[j] = (f[j] + f[j-k])%mod;
    cout<<f[m]<<endl;
    return 0;
}
```

### 方法六：前缀和优化

继续观察方法五的代码，时间复杂度是$\Theta(n^3)$级别的。与背包有一些差别的是这一句：

```cpp
for(int k=1; k<=min(a[i], j); k++)
    f[j] = (f[j] + f[j-k])%mod;
```

然而，这一句的作用只不过是将连续的一段$f[j-a[i]]$到$f[j-1]$累加起来而已。因此，可以用前缀和将这个操作优化（众所周知，前缀和的作用就是$\Theta(1)$求一段区间的和）。

时间复杂度：$\Theta(nm)$

顺便卡到了次优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105, mod = 1000007;
int n, m, f[maxn], sum[maxn], a[maxn];
int main(){
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
	f[0] = 1;
    for(int i=0; i<=m; i++) sum[i] = 1;
    for(int i=1; i<=n; i++){
    	for(int j=m; j>=1; j--) f[j] = (f[j] + sum[j-1] - sum[j - min(a[i], j) - 1] + mod)%mod;
		for(int j=1; j<=m; j++) sum[j] = (sum[j-1] + f[j])%mod;
	}
    cout<<f[m]<<endl;
    return 0;
}
```

提示：上面的程序在计算$f[j]$的时候有可能会出现数组越界的情况，但为了代码美观容易理解，没有特判。这一点需要注意，考场上不慎就会抱灵。

下面是加上了特判的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105, mod = 1000007;
int n, m, f[maxn], sum[maxn], a[maxn];
int main(){
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
	f[0] = 1;
    for(int i=0; i<=m; i++) sum[i] = 1;
    for(int i=1; i<=n; i++){
    	for(int j=m; j>=1; j--){
    		int t = j - min(a[i], j) - 1;
    		if(t < 0) f[j] = (f[j] + sum[j-1])%mod;
    		else f[j] = (f[j] + sum[j-1] - sum[t] + mod)%mod;
		}
		for(int j=1; j<=m; j++) sum[j] = (sum[j-1] + f[j])%mod;
	}
    cout<<f[m]<<endl;
    return 0;
}
```

### 方法七：生成函数

建议初学者跳过此方法，权当提供一种思路。

回到开头，我们需要求的是这样一个式子：

$$\sum\limits_{c_k=0}^{a_k}\left[\sum\limits_{i=1}^nc_i=m\right ] ,k=\{1,2,...,n-1,n\}$$

于是我们可以构造这样一个生成函数：
$$
g(x)=(1+x^1+x^2+\cdots+x^{a_1})(1+x^1+x^2+\cdots+x^{a_2})\cdots(1+x^1+x^2+\cdots+x^{a_n})
$$
即，
$$
g(x)=\prod\limits_{i=1}^n\sum_{j=0}^{a_i}x^j
$$

#### 7.1多项式

最后所得的多项式中，$x^m$ 项的系数即为答案。可以做$n$​次NTT得到答案。假设$a_i$ 的值域是$k$ ，那么，

时间复杂度：$\Theta(n^2k\log nk)$

实际上，$m$最大可以取到$nk$。因此如果用$k$来表示，前缀和优化后的复杂度应当是：$\Theta(n^2k)$

NTT的局限在于要做$n$次。其实只需要取$\ln$就能将多项乘法转化为多项式加法，具体参考[付公主的背包](https://www.luogu.com.cn/problem/P4389)。

时间复杂度降到了$\Theta(nk\log nk)$​，即 $\Theta(m\log m)$​

#### 7.2封闭形式

也可以将其写成封闭形式，参考[[CEOI2004] Sweets](https://www.luogu.com.cn/problem/P6078)。

等比数列求和，得到：
$$
g(x)=\dfrac{\prod_{i=1}^n(1-x^{a_i})}{(1-x)^n}
$$
在 $n$ 较小，$m$ 很大的时候，可以考虑将 $\prod_{i=1}^n(1-x^{a_i})$​ 暴力展开，对于 $(1-x)^{-n}$ 使用牛顿二项式定理。即，
$$
(1-x)^{-n}=\sum_{i\ge0}\binom {n+i-1}{i}x^i
$$
枚举前一个式子 $x$ 的幂次，假设为 $k$，设 $x^k$ 项的系数为 $c_k$，那么，
$$
{\rm {ANS}}=\sum _{k=0}^m c_k\cdot\binom {n+m-k-1}{m-k}
$$
时间复杂度：$\Theta(2^n+m)$

## (三)总结

总的来说，这道题适合 搜索/动态规划 的初学者练习。

有一点点的思维难度。

这道题的价值在于，它既可以从简单的动态规划开始，一路优化，也可以从生成函数的视角观察，继续优化。这两条道路，竟是殊途同归。或许，这也是数学的魅力吧。

---

## 作者：wjyyy (赞：304)

这个题是一道典型的动态规划，即可以从之前的状态推出后面的状态的最优解。

这里我开了一个二维数组，$f[i][j]$指摆第$i$个花后总共摆了$j$盆的最优解。

每次摆花的循环要从$0$开始，到$t$结束（题中是$a[i]$），即摆放$t$盆第$i$种花。

这个状态可以由上一个$i$的$j$转移过来，其中$j+t$要小于$m$（$m$是最多摆放的花盆数）。为防止变量冲突，代码里用的是$k$。

------------


因为$i$总在$i-1$后面
则$DP$的状态转移方程为$f[i][j+k]+=f[i-1][k];$

最后，不要忘了每做一次都要$mod1000007$，因为这个题不用$max,min$等函数，是从左向右推的过程，所以保险起见，在各个涉及$f$数组的地方都要$mod1000007$

```cpp
#include<cstdio>
#include<cstring>
#define mod 1000007
int max(int x,int y){return x>y?x:y;}
int f[101][101];//f[i][j]指摆第i个花后总共摆j盆的最优解
int main()
{
    int n,m,t;
    scanf("%d%d",&n,&m);
    memset(f,0,sizeof(f));
    for(int i=0;i<=n;i++)
        f[i][0]=1;
    for(int i=1;i<=n;i++)//枚举到第i盆花
    {
        scanf("%d",&t);
        for(int j=0;j<=t;j++)//第i盆花装j盆
            for(int k=0;k<=m-j;k++)//从已经装k盆转移过来
            {
                if(j==0&&k==0)
                    continue;
                f[i][j+k]+=f[i-1][k];
                f[i][j+k]%=mod;
            }
    }
    printf("%d\n",f[n][m]%mod);
    return 0;
}

```


------------
从这个题我才知道$DP$并不是全都有$max,min$函数的啊，$DP$的核心其实是从上一层的最优解推下一层的最优解，但这个题的最优即所有方案加起来的和，所以这个题没有取$max,min$。
#### 其实这个题的$DP$特点是比较强的。


---

## 作者：AFOier (赞：114)

update in 2019.08.26：格式出锅了，改一下

【解题思路】

这一题乍一看有些难度，理解后看一下觉得其实还蛮简单的。

主要思路是：先开一个二维数组$b[][]$，存储放i种j盆花的方案总数。

首先进行初始化，大家想想,无论有多少种花，如果一盆都没有，那是不是只有一种方案总数了（什么也不放）？

所以初始化为$b[i][0]=1(0<=i<=m)$。然后呢，我们进行三重循环。变量i表示有多少种花，j表示有多少盆花，k则是用于计算某种花放多少盆。

从总盆数开始循环到总盆数-最大盆数，如果k小于0（说明最大盆数大于总盆数）就退出循环。我们得到的状态转移方程则是：

$b[i][j]+=b[i-1][k](j>=k>=j-a[i])$

最终的答案就是$b[n][m]$。

当然，随时加上%1000007会更保险。然后就AC啦。



【代码】

```
#include <iostream>
using namespace std;
long long b[101][101],n,m,a[101]; //定义数组
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=0;i<=m;i++){b[i][0]=1;} //初始化，不管有多少种花，只要是0盆花，就只有1种可能性，啥都不放
    for(int i=1;i<=n;i++)//几种花
    for(int j=1;j<=m;j++)//几盆花
    for(int k=j;k>=j-a[i];k--)//这种花放多少盆？我们用变量k来循环
    {    
	if(k>=0){b[i][j]+=b[i-1][k]%1000007;b[i][j]%=1000007;}//每次    mod以防万一
        else break; //如果超出限制就退出循环
    }
    cout<<b[n][m]<<endl; //输出（因为每次都mod了所以最后不用mod）
}

```

---

## 作者：CYJian (赞：76)

upd: 修陈年破题解

明显的 `dp`。

记 $f_{i,j}$ 表示摆完前 $i$ 种花，目前已经有了 $j$ 盆花的方案数。

可以考虑先枚举当前摆第 $i$ 种花，然后再枚举摆完第 $i$ 种花之后，目前已经有了 $j$ 盆花。

不难发现，这种情况下，第 $i$ 种花有可能摆了 $0, 1, 2, \ldots, \min(a_i, j)$ 盆。

那么就可以得到：

$f_{i,j}=(f_{i-1,j}+f_{i-1,j-1}+...+f_{i-1,j-\min(a_i, j)}) \pmod {10^6+7}$

边界条件：$f_{0,0}=1$。

然后不难发现的是，我们计算第 $i$ 层的 `dp` 值是只需要第 $i-1$ 层的答案的。可以只存当前层和上一层的 `dp` 值。

如果枚举 $j$ 是从大到小枚举，那么我们可以发现，此时的 $j$ 只需要比它小的那些位置的 `dp` 值，那么在我们更新 $f_{i,j}$ 的时候，$f_{i,j+1},f_{i,j+2},\ldots,f_{i,m}$ 都是我们已经不需要的信息了。这时候我们发现，我们无论何时需要的信息都只是恰好 $m$ 个。那么我们甚至可以将第一维完全去掉，只需要一维就足够我们计算了。

$\rm Code:$


```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1000007;
int n, m, a[105], dp[105];
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    dp[0] = 1;  //边界条件
    for(int i = 1; i <= n; i++) //枚举每一种花
        for(int j = m; j >= 1; j--)  //枚举每一个摆花的结束点
            for(int k = 1; k <= a[i] && j - k >= 0; k++)  //枚举摆花的盆数
                dp[j] = (dp[j - k] + dp[j]) % mod;  //求和
    printf("%d\n", dp[m]); //输出
    return 0;
}
```

---

## 作者：lam_dyr (赞：40)

曾经刚学 dp 时做的题现在能交题解了，写篇纪念一下吧。

## 题意

给定 $n$ 种花，每种花的上限是 $a_i$，求摆放 $m$ 盆花的方案数（同种花放一起，按编号从小到大摆放，结果对 $1000007$ 取模）。

## 思路

设 $dp_{i,j}$ 为考虑前 $i$ 种花，摆放 $j$ 盆花的方案数。

但是如何判断这是道 dp 题呢？~~算法标签。~~

但是你打比赛的时候是没有算法标签的，所以在这讲一下如何判断 dp 。

- **依赖性**
  - 动态规划的核心思想是将一个复杂问题分解成一系列相互重叠的子问题，也就是 dp 的一个重要性质 —— 子任务依赖性！
  - 例如在本题中，计算 $dp_{i,j}$ 时，需要用到 $dp_{i-1,j-k}$ 的值，其中 $k$ 的取值范围是 $0$ 到 $\min(a_i,j)$。这意味着，计算 $dp_{i,j}$ 的过程，会依赖于之前计算过的 $dp_{i-1,...}$ 的结果。
- **无后效性**

   

  - dp 的另一个性质是无后效性。无后效性是指，在推导后面阶段的状态时，我们只需要关心上一个阶段的状态，而不需要关心前面阶段是如何达到这个状态的。也就是说，一旦某个状态的值确定了，它就不会受到后续决策的影响。
  - 在本题中计算 $dp_{i,j}$ 时，我们只关心 $dp_{i-1,j-k}$ 的值，而不关心 $dp_{i-1,j-k}$ 的值是如何计算出来的。只要它的值是正确的，我们就可以用它转移 $dp_{i,j}$。

综上，本题适合用**动态规划**解决。

考虑如何转移。

对于第 $i$ 种花，可以摆放 $k$ 盆 $( 0 \le k \le \min (a_i, j) )$。

因此，当计算 $dp_{i,j}$ 时，可以累加前 $i-1$ 种花摆放 $j-k$ 盆的方案数，也就是 $dp_{i,j} = \sum dp_{i-1,j-k}$。

细节：

- 初始化 $dp_{0,0}=1$：不放花，$0$ 盆的方案数是 $1$。
- 结果 $dp_{n,m}$：所有花都考虑，摆放 $m$ 盆花的方案数。
- 注意取模。

## Code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MOD=1000007;
int dp[105][105];
int n,m;
int a[105];
int main() {
    cin>>n>>m;
    for(int i=1;i<=n;++i) 
        cin>>a[i];
    dp[0][0]=1;
    for(int i=1;i<=n;++i){
        for(int j=0;j<=m;++j){
            for(int k=0;k<=min(a[i],j);++k) 
                dp[i][j]=(dp[i][j]+dp[i-1][j-k])%MOD;
        }
    }
    cout<<dp[n][m];
    return 0;
}
```

写题解不易，点个赞再走呗～

---

## 作者：WsW_ (赞：7)

### 思路
和目前其他的题解转移思路均不同。  
设计状态 $f_{i,j}$ 表示一共摆了 $i$ 盆，以第 $j$ 种结束的方案数。  

显然摆 $i$ 盆从已经摆了 $0\sim i-1$ 盆转移过来。

由于不同种类的花需按标号的从小到大的顺序依次摆列，所以 $f_{i,j}$ 只会从 $1\sim j-1$ 转移过来。当然还可以全部都摆 $j$，所以还可以从 $f_{0,0}$ 转移过来。  

知道从哪些地方转移过来之后，从 $1\sim a_j$ 枚举第 $j$ 种摆多少盆。再从 $1\sim j-1$ 枚举摆的前一种是啥。  
最后答案就是 $\sum^{n}_{i=1}f_{m,i}$。  

时间复杂度为 $O(n^2mA)$，其中 $A$ 表示 $a_i$ 的值域。常数较小，可以通过。  

容易发现，有非常多的无效转移。具体来说，有很多状态 $f_{i,j}=0$，也就是不存在合法方案，但我们仍然进行了转移。  
可以通过适当的剪枝和向后转移来优化时间复杂度。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e6+7;
int n,m;
int a[105];
int f[105][105];//一共摆了i盆，以第j种结束 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(a[j]>=i)f[i][j]=1;
			for(int k=1;k<=min(i,a[j]);k++){
				for(int l=1;l<j;l++){
					f[i][j]+=f[i-k][l];
					f[i][j]%=mod;
				}
			}
		}
	}
	
	int ans=0;
	for(int i=1;i<=n;i++)(ans+=f[m][i])%=mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：Il1_1_3 (赞：5)

# P1077 题解
## 思路
考虑动态规划，设 $dp_{i,j}$ 表示前 $i$ 种花摆 $j$ 盆的方案数，其中 $dp_{0,0}=1$，可得转移方程为：

$$dp_{i,j}=\sum dp_{i-1,j-k}(0 \le k \le \min(a_i,j))$$

最终结果就是 $dp_{n,m}$，记得取模。

## 代码
```cpp
#include <iostream>
#define pri 1000007
using namespace std;
int dp[103][103];
int main()
{
    int n,m,a[103];
	cin >> n >> m;
    for(int i=1;i<=n;i++) cin >> a[i];
    dp[0][0]=1;
    for(int i=1;i<=n;i++) for(int j=0;j<=m;j++) for(int k=0;k<=min(j,a[i]);k++) dp[i][j]=(dp[i][j]+dp[i-1][j-k])%pri;
    cout << dp[n][m];
    return 0;
}
```

---

## 作者：_Weslie_ (赞：5)

## Solution P1077

### Idea

dp。

#### 状态设计

令 $f_{i,j}$ 表示种到第 $i$ 种花，用完了前 $j$ 个位置的方案数。

#### 转移方程

显然有：

$$f_{i,j}=\sum_{k=1}^{\min(a_i,j)} f_{i-1,j-k}$$

接着按照题意，我们去理解一下这个式子：

$f_{i,j}$：种到第 $i$ 种花，用完了前 $j$ 个位置的方案数。

$\min(a_i,j)$：显然最多从往前数 $a_i$ 个位置转移来。可能用完的位置太少，还不到 $a_i$，为防止数组越界，去一个最小。

$\sum$：各种情况显然都满足，求和。

$f_{i-1,j-k}$：种到第 $i-1$ 种花，用完了前 $j-k$ 个位置的方案数。显然如果第 $i$ 种花用 $k$ 个位置，应该从种到第 $i-1$ 种花，用完了前 $j-k$ 个位置的状态转移来。

#### 初值设计

显然有 $f_{0,0}=1$。因为你放 $0$ 种花，用 $0$ 个位置，显然只有一种方案。

这个在一部分其他 dp 题中也是常见的初值设计套路。

#### 答案统计

显然是 $f_{n,m}$。

### Code

虽然是 $2025$ 年的题解，但是这份代码是我在 $2022$ 年底写的，如果有码风问题还请见谅。

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[101],f[101][101];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];f[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int k=0;k<=min(j,a[i]);k++){
				f[i][j]=(f[i][j]+f[i-1][j-k])%1000007;
			}
		}
	}
	cout<<f[n][m]; 
	return 0;
}
```

---

## 作者：Like_Amao (赞：3)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P1077)

**思路**

我们可以用动态规划来做这道题。我们可以用一个二维数组 $dp$，令 $dp _ {i,j}$ 表示摆了 $i$ 个花后最多用了 $j$ 个花盆，用 $k$ 来枚举当前第 $i$ 个花的取值，因此可以得出状态转移方程：

$f _ {i,j} = \sum _ {k = 0} ^ {a _ i} f _ {i - 1,j - k}$

**代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101],dp[101][101];
int main()
{
	int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
    dp[0][0]=1;
    for(int i=1;i<=n;i++)
    {
    	for(int j=0;j<=m;j++)
    	{
    		for(int k=0;k<=min(a[i],j);k++)
    		{
    			dp[i][j]=(dp[i][j]+dp[i-1][j-k])%1000007;
			}
		}    
	}
    cout<<dp[n][m];
    return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

动态规划。

设 $f_{i, j}$ 表示前 $i$ 种花摆了 $j$ 个的方案数，第 $i$ 种花的摆法就应从第 $i-1$ 种的摆法转移。初值是 $f_{0, 0}=1$，从 $0$ 到 $\min(j, a_i)$ 枚举 $k$，转移是 $f_{i, j}=f_{i,j}+f_{i-1, j-k}$，即 $$\begin{aligned} f_{i, j} = \sum_{k=0}^{\min(j, a_i)} f_{i-1, j-k} \end{aligned}$$，答案是 $f_{n, m}$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e6+7;
int n, m, a[105], f[105][105];
int main(){
	cin >> n >> m;
	for(int i=1; i<=n; i++)
		cin >> a[i];
	f[0][0]=1;
	for(int i=1; i<=n; i++)
		for(int j=0; j<=m; j++)
			for(int k=0; k<=min(j, a[i]); k++)
				f[i][j]=(f[i][j]+f[i-1][j-k])%M;
	cout << f[n][m];
	return 0;
}
```

---

## 作者：ShuYuMo (赞：3)

---
title: 【luogu-1077】摆花
date: 2019-10-28 21:06:48
tags:
---


# 方程

设计状态
$f[j][i]$摆了前$j$盆花，用到了第$i$种，总共方案数。


每盆花在摆的过程中只有在换花的时候会产生不同的方案，也就是是否继续摆这个花或者换花摆，这是一个决策。

所以在转移的过程中，需要从这个点入手

当我摆到第$j$盆花的时候，我会思考当前这个花要摆的个数，叠加多种情况。


$$f[j][i] = \sum_{k = 0}^{cnt[i]} f[j - k][i - 1]$$

$f[j][i]$摆了前$j$盆花，用到了第$i$种，总共方案数。
$cnt[i]$是第$i$种花的数量，$\sum_{k = 0}^{cnt[i]}$就是累加，第$i$种花选不同个数的方案数。

```cpp
/*!
 * FileName: luogu-1077.cpp
 * This Problem is on luogu. The ID of the problem is 1077. 
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool on 2019-10-25 20:25:52 written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define inf 0x7fffffff
#define _R register
using namespace std;
const int _ = 1e2 + 10;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } 
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
int f[_][_];
int A[_];
int n;
int m;
const int MOD = 1000007;
int main()
{
	n = read(); m = read();
	for(_R int i = 1;i <= n;i++) A[i] = read();
	for(_R int i = 0;i <= n;i++)  f[0][i] = 1;
	for(_R int i = 1;i <= n;i++) {
		for(_R int j = 1;j <= m;j++) {
			for(_R int k = 0;k <= A[i];k++)
				if(j - k >= 0)
					f[j][i] += f[j - k][i - 1];
				else break;
			f[j][i] %= MOD;
		}
	}
	printf("%d", f[m][n] % MOD);
	return 0;
}
```

---


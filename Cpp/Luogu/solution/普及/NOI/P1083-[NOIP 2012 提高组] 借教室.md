# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。

## 说明/提示

【输入输出样例说明】

第 $1$ 份订单满足后，$4$ 天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$ 天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# 题解

## 作者：皎月半洒花 (赞：799)

## 一、暴力简述
   
   [甩链接.jpeg](https://www.luogu.org/problemnew/show/P1083#sub)
   
   首先我们不难看出，这道题————并不是一道多难的题，因为显然，第一眼看题目时便很容易地想到暴力如何打：枚举每一种订单，然后针对每一种订单，对区间内的每一天进行修改（做减法），直到某一份订单使得某一天剩下的教室数量为负数，即可得出结果。
   
   先小小的评析一下吧：**凡是能打出几近正解的暴力题，都不是难题！**（蒟蒻可以骗到50+的不就是水题吗qwq）但是，显然枚举形式的暴力会很慢，期望的时间复杂度约为 
### $O(m \times n)$，
可能会更快一些（~~但没卵用qwq~~）

## 二、思想详述

让我们开动脑筋想一下：每张订单其实就可以看作是一个区间（操作），左右区间分别为开始时间和结束时间，所以这不就是一个区间操作吗——首选线段tree啦！但是笔者在这里并不打算介绍线段树，因为虽然线段tree操作方便、复杂度低，但是——————我不会写啊qwq！（逃

并且总感觉你考试的时候撸一个线段树模板的时间完全可以多打两个暴力啊qwq（~~虽然暴力也不一定对~~）

所以，选择引入一种好理解、好实现的算法：**差分数组**

在介绍差分之前，需要介绍**前缀和思想**

（qwq此处当然只会讲一维线性的前缀和啦）

**我们有一组数（个数小于等于一千万），并且有一大堆询问——给定区间l、r,求l、r之间所有数之和（询问个数小于等于一千万） **

此处暴力肯定不行啊（O（N*Q*length）），那么我们来观察前缀和是怎么做的：用sum[i]来存储前i个数的和，然后用sum[r]-sum[l-1]来表示l~r之间所有数的和。（l-1原因是l~r只看要包含l）而sum数组便可以通过简单的递推求出来

代码核心：

```cpp
for(int i=1;i<=n;i++)
{cin>>a[i];sum[i]=sum[i-1]+a[i];}
for(int i=1;i<=q;i++)
{cin>>l>>r;cout<<sum[r]-sum[l-1]<<" ";}
```

而所谓的差分数组，即是前缀和数组的逆运算：

我们给定前i个数相邻两个数的差（1<=i<=n）,求每一项a[i]（1<=i<=n）。

此时无非就是用作差的方式求得每一项，此时我们可以有一个作差数组diff，diff[i]用于记录a[i]-a[i-1],然后对于每一项a[i],我们可以递推出来：

```cpp
for(int i=1;i<=n;i++)
{cin>>diff[i];a[i]=diff[i]+a[i-1];}
for(int i=1;i<=n;i++)
{cout<<a[i];}
```

到这儿，我们可以看出来，**前缀和是用元数据求元与元之间的并集关系，而差分则是根据元与元之间的逻辑关系求元数据，是互逆思想**（qwq但是有时元数据和关系数据不是很好辨别或者产生角色反演啊）

但是，理解了前缀和&差分，并不代表肯定能做到模板题：毕竟，**思想只能是辅助工具**啊

## 三、关于答案二分

一般来说，二分是个很有用的优化途径，因为这样会直接导致减半运算，而对于能否二分，有一个界定标准：**状态的决策过程或者序列是否满足单调性或者可以局部舍弃性。**
而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。


## 四、终于要bb正解了！

首先，要明白如为什么要用区间差分而不是区间前缀和：因为这个题每次操作针对的对象都是原本题目中给的元数据，而不是让求某个关系，所以采用差分。

其次，要知道差分会起到怎样的作用：因为diff数组决定着每个元数据的变化大小、趋势，所以，当我们想要针对区间操作时，钱可以转化成对diff数组操作：

```cpp
diff[l[i]]+=d[i];
diff[r[i]+1]-=d[i];//d[i]是指每天要借的教室数
```

因为后面的元数据都由之前的diff数组推导出来，所以改变diff[i]就相当于改变[i](包括)之后的每一个值，并通过重新减去改变的量，达到操作区间的目的。

then，我们需要想明白策略：从第一份订单开始枚举，直到无法满足或者全枚举完结束。

最后，一点提示，我下面的标程是通过比大小来判断是否满足，而不是作差判负数————能不出负数就别出负数，否则容易基佬紫（re）/手动滑稽

贴标程：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio> 
using namespace std;
int n,m;
int diff[1000011],need[1000011],rest[1000011],r[1000011],l[1000011],d[1000011];
bool isok(int x)
{
    memset(diff,0,sizeof(diff));
    for(int i=1;i<=x;i++)
    {
        diff[l[i]]+=d[i];
        diff[r[i]+1]-=d[i]; 
    }
    for(int i=1;i<=n;i++)
    {
        need[i]=need[i-1]+diff[i];
        if(need[i]>rest[i])return 0;
    }
    return 1;
} 
int main()
{
    
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&rest[i]);
    for(int i=1;i<=m;i++)scanf("%d%d%d",&d[i],&l[i],&r[i]);
    int begin=1,end=m; 
    if(isok(m)){cout<<"0";return 0;}
    while(begin<end)
    {
        int mid=(begin+end)/2;
        if(isok(mid))begin=mid+1;
        else end=mid;
    }
    cout<<"-1"<<endl<<begin;
}
```


writter:皎月半洒花_pks




---

## 作者：noble_ (赞：43)

无耻的安利一发自己博客：[传送门](http://www.cnblogs.com/noblex/)

---

哈哈哈哈，蒟蒻来介绍一种暴力**新**做法

这题前缀和搞一搞是可以把每天的教室需求数量算出来的


```cpp
sum[s[i]]+=d[i]; sum[t[i]+1]-=d[i];
........
........
for(int i=1;i<=n;i++) sum[i]+=sum[i-1];
```

这样子就把每天的需求量统计出来了


接着一个循环暴力计算哪天供不应求，再暴力一个个减回去直到符合条件

最坏复杂度是可以卡到$ O(mn) $的，但可能出题人去卡其他做法了QwQ


代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+100;
int s[maxn],t[maxn];
long long  sum[maxn],r[maxn],d[maxn];
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&r[i]);
	for(int i=1;i<=m;i++){
		scanf("%lld%d%d",&d[i],&s[i],&t[i]);
		sum[s[i]]+=d[i]; sum[t[i]+1]-=d[i];
	}
	for(int i=1;i<=n;i++) sum[i]+=sum[i-1];
	int anss=1e9;
	for(int i=1;i<=n;i++){
		if(sum[i]>r[i]){
			long long ans=sum[i]; int j;
			for(j=m;j>=1;j--){
				if(s[j]<=i && t[j]>=i){
					ans-=d[j]; if(ans<=r[i]) break;
				}
			}
			anss=min(anss,j);
			if(anss==1) break;
		}
	}
	if(anss==1e9) puts("0");
	else printf("%d\n%d",-1,anss);
	return 0;
}
```


没读入优化1120ms

这种小优化暴力真是NOIp中的不二之选啊，代码只有31行！！！！

---

## 作者：WsW_ (赞：12)

### 思路
存在不能满足的订单，也就是存在某一天需要的教室数量大于可用于租借的教室数量。  
容易发现，如果到第 $X$ 个订单时存在某天教室不够，那到第 $X+1\sim n$ 肯定都会存在某天教室数量不够。  
所以可以二分订单，并判断从第 $1$ 个订单到这个订单是不是都能满足。  
对于每次判断，形式都是有一段区间加同一个数，并判断最终结果是否有哪天数字大于 $r_i$。  
容易发现，这个区间加和最后一次查询可以通过差分修改和前缀和统计来完成。  

时间复杂度为 $O(n\log m)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
typedef unsigned long long ull;

int n,m;
int r[1000003];
int d[1000003];
pii a[1000003];
ll c[1000003];

bool check(int x){
	memset(c,0,sizeof(c));
	for(int i=1;i<=x;i++){
		c[a[i].first]+=d[i];
		c[a[i].second+1]-=d[i];
	}
	for(int i=1;i<=n;i++){
		c[i]+=c[i-1];
		if(c[i]>r[i])return 0;
	}
	return 1;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>r[i];
	for(int i=1;i<=m;i++){
		cin>>d[i]>>a[i].first>>a[i].second;
	}
	int lft=1,rig=m,mid,ans=-1;
	while(lft<=rig){
		mid=lft+rig>>1;
		if(check(mid))lft=mid+1;
		else{
			ans=mid;
			rig=mid-1;
		}
	}
	if(ans==-1)cout<<0;
	else cout<<"-1\n"<<ans;
	return 0;
}

```

---

## 作者：LeavingZzz (赞：9)

额....线段树题解有几篇了，，这里除了介绍一般思路外还提几个可以略略优化线段树的点。
~~（卡常用）（逃）~~  
正解肯定是差分了，但是为什么线段树也可以过呢？  
[2018年CCF升级了评测CPU](https://www.zhihu.com/question/301938619)  
所以时代在进步，虽然差分性能好，但是也要接纳线段树啊。  
废话说完了讲题目。  


------------
## P1083 借教室[NOIP提高组2012]  题解  
#### 题意简述
对于一个长为N的线性序列(即每天有多少个教室可用),进行M次操作，每个操作用一个三元组(L,R,k)表示，意为区间[L,R]内的每个数减去k,当序列中出现负数时终止操作并输出操作编号。  
#### 分析  
emmm.....区间操作，而且要知道什么时候序列最先出现负数，可以用最小值，也就是如果整个序列内的最小值等于负数就立马停止操作，线段树可以满足这些需求。（数据结构确定）  
**分析结果**：用线段树中的节点表示该区间内的**最小值**，**区间减掉**定值k，最小值出现**负数**时停止操作。  
还有不懂的去代码里面找我。   
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define mid (L+R>>1)
//加法优先级高于位运算加括号是担心翻车
inline int Read()//读入优化
{
	int f=1,re;
	char c;
	while((c=getchar())>'9'||c<'0');
	re=c-48;
	while((c=getchar())>='0'&&c<='9')
	re=re*10+c-48;
	return re;
}
inline int min_(const int &x,const int &y)
{
	return x>y?y:x;
} 
int TREE[4000007],lazy[4000007];
//TREE就是线段树数组，lazy是懒人标记（是不是很硬核）
//lazy[i]表示TREE[i]的区间内需要减去的值
int N,M;
int c,s,e;
int h[1000007];
bool flag;
inline void Build(int L,int R,int i)//建立线段树
{
	if(L==R)
	{
		TREE[i]=h[L];
		return ;
	}
	Build(L,mid,i<<1);
	Build(mid+1,R,i<<1|1);
	TREE[i]=min_(TREE[i<<1],TREE[i<<1|1]);
	return ;
}
inline void LAZY(int i)//懒惰标记下传
{
	if(lazy[i]==0) return ;
	lazy[i<<1]+=lazy[i];//记住是加号（减去的值叠起来）
	lazy[i<<1|1]+=lazy[i];
	TREE[i<<1]-=lazy[i];//表示区间最小值直接减
	TREE[i<<1|1]-=lazy[i];
	lazy[i]=0;//这五句话一个都不能少！
	return ;
}
inline void Update(int L,int R,int l,int r,int i,int k)
{
	if(l<=L&&R<=r)
	{
		TREE[i]-=k;
		lazy[i]+=k;//这里TREE和lazy同步更新不要掉了
		return ;//不return就会无限递归RE
	}
	LAZY(i);//只要要访问子节点就一定要下传标记
	if(l<=mid) Update(L,mid,l,r,i<<1,k);
	if(r>mid) Update(mid+1,R,l,r,i<<1|1,k);
	TREE[i]=min_(TREE[i<<1],TREE[i<<1|1]);//更新
	return ;
}
int main()
{
	N=Read();M=Read();
	for(int i=1;i<=N;i++)
		h[i]=Read();
	Build(1,N,1);
	for(int i=1;i<=M;i++)
	{
		c=Read();s=Read();e=Read();
		Update(1,N,s,e,1,c);
		if(TREE[1]<0)//这里也是个技巧吧
      //TREE[1]表示的就是整个序列的最小值
		{
			printf("-1\n%d",i);
			return 0;//直接终止程序
		}
	}
	printf("0");//能够运行到这里表示全都是可以满足的
	return 0;
}
```
线段树效率还是比较高的，但是有些地方还是要注意一下：  
- 1- 懒惰标记  
	懒惰标记运用在区间更新的时候，线段树访问到叶节点用时在操作多起来的时候会积累的很大，加上懒惰标记可以不到叶节点就完成信息更新。这个技巧在区间特别是大区间时优势会变得很明显。  
- 2- 标记下传  
	不同的线段树维护不同的信息，下传也自然不同，这棵线段树维护区间最小值，若当前区间被待更新区间完全包含就直接减去，因为区间内所有的数字都减去相同的值大小关系不变，最小值就等于原来的最小值减去这个定值，而子节点的懒惰标记也需要叠加（万一有孙子呢），标记下传也是一个非常易错的点！！  
- 3- 一个小小的常数优化  
	如果在更新的时候大量使用max/min函数建议自己写，这样会提高效率，另外这样的小函数用const+传引用也能加速一丢丢。（亲测属实）  
 

------------

 实际上线段树这个数据结构还是挺强的，大家也可以学习其他的线段树变形，比如zkw线段树和李超线段树等等（蒟蒻我不会的那些线段树）。  
 题解不易，有问题请私信或者评论@我，谢谢大家。

---

## 作者：清远学会 (赞：6)

**题目大意就是：**

**第$i$天有$a_i$个教室可供使用**，还有**$m$个童鞋想来租借教室(天数与个数不定)**，问**最多可以满足前多少个**；

很快可以想出**二分做法**：

因为在**童鞋越少情况下**，教室越有**可能满足**，而**童鞋一旦多了**，那么**GG的概率就大了**

所以，现在问题转换成：

**现有$x$个童鞋来借教室，问是否可行**，而**$x$是我们二分的答案**；

现在问题的难点在于如何判定是否可行；

既然**第$i$个童鞋需要在第$u$到 $v$天借$d$个教室**，需要判定在这几天中是否足够，那么，我们**可以用差分来实现**

设$a[i]$为第$i$天的**教室可用量**，$b[i]$为$a[i]-a[i-1]$;

对于每个童鞋的请求：借**$u_i$到$v_i$的$d_i$个教室**，我们可以**在$b[i]$的位置减去$d_i$**,**在$b[i-1]$的位置加上$d_i$**即可**实现$O(1)$**修改,在**从$1到x$求前缀和，就是修改过后的$a[i]$数组**啦；

不合法情况为**在修改过后的$a[i]$数组中有$< 0$**的情况，**返回$faluse$,负责就为$true$**

**具体实现还是看代码吧** ：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 2005000
using namespace std;

int n,m;
int a[N],b[N],c[N];
struct node {
	int d,s,t;
}data[N];

inline bool Check(int x) {
	for(int i = 1;i <= n;i ++) c[i] = b[i];
	for(int i = 1;i <= x;i ++) {
		int u = data[i].s,v = data[i].t;
		c[u] -= data[i].d;
		c[v + 1] += data[i].d;
	}
	for(int i = 1;i <= n;i ++) {
		c[i] += c[i - 1];
		if(c[i] < 0) return false;
	}
	return true;
}

int main() {
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i ++) scanf("%d",&a[i]);
	for(int i = 1;i <= n;i ++) b[i] = a[i] - a[i - 1];
	for(int i = 1;i <= m;i ++) 
		scanf("%d%d%d",&data[i].d,&data[i].s,&data[i].t);
	int l = 1,r = m,ans = 0;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(Check(mid)) l = mid + 1,ans = mid;
		else r = mid - 1;
	}
	if(ans == m) cout << 0 << endl;
	else cout << -1 << endl << ans + 1 << endl;
}
```


**其实还有线段树的做法：**

既然**求在满足第$i$个童鞋后是否存在不合法的情况**，，我们用**线段树维护区间减，与区间最小值**

具体实现是酱：

假设**第$i$个童鞋的要求我可以满足**，那么**先借给他**，就是执行一次**从$u_i$到$v_i$减去$d_i$的操作**

当**满足后，发现其中有一天不够用**，即为在**线段树的$1$号位置的最小值为负**，不合法，**输出当前编号**

具体代码如下(**比二分慢，不过可以过的，放心食用**)：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 2006005
using namespace std;

int n,m;
int a[N];
struct node {
	int val,laz;
}tr[N * 4];

inline void Built(int k,int l,int r) {
	if(l == r) {
		tr[k].val = a[l];
		return ;
	}
	int mid = (l + r) >> 1;
	Built(k << 1,l,mid); 
	Built(k << 1 | 1,mid + 1,r);
	tr[k].val = min(tr[k << 1].val,tr[k << 1 | 1].val);
}

inline void Pushdn(int k) {
	if(tr[k].laz) {
		tr[k << 1].val -= tr[k].laz;
		tr[k << 1 | 1].val -= tr[k].laz;
		tr[k << 1].laz += tr[k].laz;
		tr[k << 1 | 1].laz += tr[k].laz;
		tr[k].laz = 0;
	}
}

inline void Change(int k,int l,int r,int a,int b,int c) {
	if(a <= l && r <= b) {
		tr[k].val -= c;
		tr[k].laz += c;
		return ;
	}
	Pushdn(k);
	int mid = (l + r) >> 1;
	if(a <= mid) Change(k << 1,l,mid,a,b,c);
	if(b > mid) Change(k << 1 | 1,mid + 1,r,a,b,c);
	tr[k].val = min(tr[k << 1].val,tr[k << 1 | 1].val);
}

int main() {
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i ++) scanf("%d",&a[i]);
	Built(1,1,n); int flag = 0,ans;
	for(int i = 1;i <= m;i ++) {
		int u,v,w; scanf("%d%d%d",&w,&u,&v);
		Change(1,1,n,u,v,w);
		if(tr[1].val < 0 && flag == 0) {
			flag = 1; ans = i;
		}
	}
	if(flag) cout << -1 << endl << ans << endl;
	else cout << 0 << endl;
}
```

---

## 作者：1jia1 (赞：4)

[传送门](https://www.luogu.org/problem/P1083)

看到dalao们都写了线段树/二分+差分，我提供一个倍增+差分的做法。

其实倍增和二分的思想都差不多，只不过倍增是从左开始往右走，而二分是从中间开始往两边走。

每个借教室操作可以看成把[s,t]天的教室数量-d，这个可以用差分。

具体做法是：设$k=log_2n+1$，先执行第1个操作到第$2^k$操作，执行完后扫一遍数组，如果有某一天的教室数量<0，说明在$[1,2^k]$中某一天会出现某一天的教室数量<0。所以，就可以缩小范围至$[1,2^{k-1}]$。

如果执行$[1,2^{k-1}]$中操作后没有哪一天的教室数量<0，就说明出现教室数量<0的操作肯定在$2^{k-1}$后，那么就执行$[2^{k-1},2^{k-1}+2^{k-2}]$的操作。否则，执行$[1,2^{k-2}]$的操作。以此类推，一直算下去，直到2的幂次为0为止。

由于每个十进制数都可以拆分成若干个2的次幂之和，所以这么找肯定能找到最后一个 不使某一天的教室数量<0 的操作的编号。这样，这个编号+1，就是第一个 使某一天的教室数量<0 的操作的编号了。

```cpp
#include <cstdio>
#include <algorithm>
#define N 1000011
using namespace std;
int n,m,num[N],l[N],r[N],add[N],dif[N],day=0;
inline void read(int &in)
{
	in=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while('0'<=c&&c<='9')in=in*10+c-'0',c=getchar();
	return;
}
int main()
{
	read(n),read(m);
	for(int i=1;i<=n;i++)read(num[i]);
	for(int i=1;i<=m;i++)read(add[i]),read(l[i]),read(r[i]);
	for(int i=20,pow2,frog=0;i>=0;i--)
	{
		pow2=1<<i;
		if(day+pow2>m)continue;
		for(int j=day+1;j<=min(day+pow2,m);j++)dif[l[j]]-=add[j],dif[r[j]+1]+=add[j];
		frog=0;
		for(int j=1,sum=0;j<=n;j++)
		{
			sum+=dif[j];
			if(sum+num[j]<0){frog=1;break;}
		}
		if(!frog)day+=min(pow2,m+1);
		else for(int j=day+1;j<=min(day+pow2,m);j++)dif[l[j]]+=add[j],dif[r[j]+1]-=add[j];
	}
	if(day>=m)puts("0");
	else printf("-1\n%d\n",day+1);
	return 0;
}
```

---

## 作者：WAMonster (赞：4)

## 【非正解】来一发普通（求和）树状数组+二分+玄学优化的题解qwq

首先这题是个普通的差分+前缀和板子，正解蓝题有些高。~~但由于我闲的蛋疼~~，于是打了一个妥妥TLE的树状数组+二分，然后一通优化，过了……

### 树状数组 区间修改+单点查询的基础题【[请戳这里](https://www.luogu.org/problemnew/show/P3368)】【[转一篇Chanis dalao的洛谷日报](https://www.luogu.org/blog/Chanis/super-BIT)】

***
## 步入正题：
### 准备工作:
用四个数组（开到$10^6$），一个作为树状数组，其他三个分别存储每个订单的开始时间、结束时间、需要的教室数。

输入可用教室时，只需执行左端点和右端点相同的区间修改，即可实现单点修改。这些都暂时存在一个数组`c`中。

### 先看获得答案的方法：二分
先分析题意：题目中有一句这样的话：

`借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。`

注意：**先到先得**

想到了什么没有？

如果你想到了一个重要的等量关系——**不能满足的订单之前的订单总数**`等于`不能满足的订单标号-1，那么你就跨出了第一步。

接着我们可以用二分法找最小的总数（即上面的粗体部分），然后判断是否合法即可。如果该总数满足，则扩大总数的值尝试；否则缩小范围尝试。注意查找时$R$从$m+1$开始。

另外注意，如果使用循环时$L≤R$的做法，由于最后的$L$会等于$Mid+1$，所以直接输出\$L$即可。

#### 二分复杂度$O(\log m×?)$，其中$?$是判断是否合法的复杂度。

### 再看判断方法：树状数组（区间修改+单点查询）
#### ~~各位用树状数组RMQ的dalao轻喷~~
首先一看数据范围$n,m≤10^6$，放弃暴力枚举。然后考虑差分+前缀和做法。差分+前缀和妥妥的$O(n)$能过，但树状数组呢？$O(n\log n)$，有点悬，但还是可以~~苟延残喘~~尝试一下。

我们可以写出判断函数的代码：
```cpp
int chk(int x){//O(nlogn)
    memcpy(t,c,(n+1)*sizeof(int));//这里是拷贝一份之前做好的c数组重复计算初始数组
    for(int i=1;i<=x;++i)
        update(t,l[i],r[i],-room[i]);//区间减
    for(int i=1;i<=n;++i)
        if(query(t,i)<0)return 0;//不满足，返回0
    return 1;
}
```

先前二分已经推出了所要求的总数，接下来便是树状数组一通乱搞啦。把每个总数之内的订单都考虑上，然后`for`一遍看有没有不满足的订单（即`query(pos)<0`）,再根据以上方法调整范围即可。

如果你树状数组和二分等成分都没有写错，那么恭喜你：**80分**。

现在不必质疑这个算法的~~玄学性~~正确性，只需一点小小的优化，就能完美的卡进时限。

### 优化方法：
我们可以发现：在二分调整范围时，有一些订单会被重复计算。我们可以在二分循环体里面直接微调空闲教室数，此时`chk`函数只需判断是否合法即可。

具体的做法是：如果范围缩小，则把之前多计算的订单所减去的教室数加回来，反之在之前的基础上多减去需要减去的订单。

举例：假设`chk`返回了0，则区间缩小，$R$变成了原来的原来的$Mid-1$，$Mid$也变成了原来的$(L+Mid-1)/2$（二分）。此时只需循环$Mid+1$（现在的$Mid+1$，即将做`chk`的下一个数）到现在的$R+1$，再把之前计算的订单加回来即可。

假设`chk`返回了1，则区间扩大，$L$变成了原来的原来的$Mid+1$，$Mid$也变成了原来的$(Mid+1+R)/2$（二分）。此时只需循环现在的$L$到现在的$Mid$，再计算订单即可。

#### ~~原谅我水了这么多字~~

这样一来，在调整区间时，树状数组的`update`操作最多被执行$O(n)$次，总时间复杂度从$O(n\log n+(n\log n+n\log m)\log m)$优化到$O(n\log n+n\log n×\log m)$（当然也可以认为是常数的优化），完美卡进时限。

### 最后贴个代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int t[1000010],l[1000010],r[1000010],room[1000010],n,m;
inline int lowbit(int x){
	return x&-x;
}
void add(int x,int k){
	for(int i=x;i<=n;i+=lowbit(i))t[i]+=k;
}
void update(int x,int y,int k){
	add(x,k);
	add(y+1,-k);
}
int query(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i))res+=t[i];
	return res;
}
#define isdigit(x) ((x)>='0'&&(x)<='9')
#define gc(c) c=getchar()
inline int read(){
    int res=0;
    char c;
    gc(c);
    while(!isdigit(c))gc(c);
    while(isdigit(c))res=(res<<1)+(res<<3)+c-48,gc(c);
    return res;
}
int chk(int x){//O(nlogn)
	for(int i=1;i<=n;++i)
		if(query(i)<0)return 0;
	return 1;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;++i){
		int xx=read();
		update(i,i,xx);
	}
	for(int i=1;i<=m;++i){
		room[i]=read();
		l[i]=read();
		r[i]=read();
	}
	int L=1,R=m+1,Mid=(L+R)>>1;
	for(int i=1;i<=Mid;++i)update(l[i],r[i],-room[i]);
	while(L<=R){//O(logm)
		if(chk(Mid)){
			L=Mid+1;
			Mid=(L+R)>>1;
			for(int i=L;i<=Mid;++i){
				if(Mid<=m)update(l[i],r[i],-room[i]);//不加if死循环（不要在意if在循环内部）
                //如果Mid>m了，L也会超出，所以写法正确，暂时找不到hack数据
			}
				
		}
		else{
			R=Mid-1;
			Mid=(L+R)>>1;
			for(int i=Mid+1;i<=R+1;++i)
				update(l[i],r[i],room[i]);
		}
	}
	if(L>=m)printf("0");
	else {
		printf("-1\n");
		printf("%d",L);
	} 
	return 0;
}
```
#### 鸣谢：[野心qwq](https://www.luogu.org/space/show?uid=96968)帮我找出了某个点死循环的错误 以及教练对本题算法的要求（树状数组）

---

## 作者：曹老师 (赞：4)

# 史上最全解法分析


------------

## 差分+二分版
#### 一定要二分！一定要二分！一定要二分！
楼下有我第一次写的没二分的代码

没二分的话挺简单的 直接差分

然后如你所愿 TLE

那么就要二分查找找答案啊

二分什么呢？记住每一次检查的时候一定要从1到当前这个点

这个1和二分时候的left是不一样的~~（蒟蒻表示当时弄混了~~）

我们这里二分1-m （二分程序见第二版while部分）

检查你二分到的这个点是否符合条件 我定义了个chafen函数

直接来判断这个点是不是我们要二分的答案

然后最后逐渐找到left和right接近

注意：我们开始搜的时候是先搜的right

只有chafen(right)满足条件我们才做

所以最后输出答案的时候 要明白right右端点一定是满足条件的

所以直接输出左端点即可

## 线段树版
开始我的pushdown的lazy下标只是放的0或者1

开始的时候我想的是如果是1就下传 如果是0就不pushdown

但是就是不应该只放0和1

因为你pushdown的时候你儿子节点的最小值还要更新

那么要更新的这个值放到哪里呢？就是放到这个标记里

这里我百度了一下lazy标记的东西 截图献上

![](https://i.loli.net/2018/02/25/5a9226f41d69e.png)

其他的话都是线段树的基本操作

# 程序代码
#### 40分未二分版
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define MAXN 1000005
using namespace std;
int n,m,a[MAXN],b[MAXN];
void solve();
void del(int,int,int);
int check();
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    solve();
    for(int i=1;i<=m;i++)
    {
        int d,s,t;
        scanf("%d%d%d",&d,&s,&t);
        del(s,t,d);
        if(check()==1)
        {
            printf("-1\n%d",i);
            return 0;
        }
    }
    printf("0");
    return 0;
}
void solve()
{
    for(int i=1;i<=n;i++)
        b[i]=a[i]-a[i-1];
}
void del(int l,int r,int x)
{
    b[l]-=x;
    b[r+1]+=x;
    for(int i=1;i<=n;i++)
        a[i]=b[i]+a[i-1];
}
int check()
{
    for(int i=1;i<=n;i++)
        if(a[i]<0)
            return 1;
    return 0;
}
```
#### 差分+二分版
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define MAXN 1000005
using namespace std;
struct cf{
    int x,l,r;
};
cf f[MAXN];
int n,m,a[MAXN],b[MAXN],c[MAXN];
bool chafen(int);
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&f[i].x,&f[i].l,&f[i].r);
    if(chafen(m))
        printf("0");
    else
    {
        int l=1,r=m;
        while(l<r)
        {
            int mid=(l+r)>>1;
            if(chafen(mid))
                l=mid+1;
            else
                r=mid;
        }
        printf("-1\n%d",l);
    }
    return 0;
}
bool chafen(int x)//差分 
{
    memset(b,0,sizeof(b));
    for(int i=1;i<=x;i++)
    {
        b[f[i].l]+=f[i].x;
        b[f[i].r+1]-=f[i].x;
    }
    for(int i=1;i<=n;i++)
    {
        c[i]=b[i]+c[i-1];
        if(c[i]>a[i])
            return 0;
    }
    return 1;
}
```
#### 线段树版
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define MAXN 1000005
using namespace std;
struct tree{
    int l,r,p,minn;
};
tree node[MAXN*4+1];
int n,m,a[MAXN];
void update(int);
void build(int,int,int);
void pushdown(int);
void update_qj(int,int,int,int);
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int b,c,d;
        scanf("%d%d%d",&b,&c,&d);
        update_qj(1,c,d,-b);
        if(node[1].minn<0)
        {
            printf("-1\n%d",i);
            return 0;
        }
    }
    printf("0");
    return 0;
}
void build(int x,int l,int r)
{
    node[x].p=0;//lazy
    node[x].l=l;
    node[x].r=r;
    if(l==r)
    {
        node[x].minn=a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(2*x,l,mid);
    build(2*x+1,mid+1,r);
    node[x].minn=min(node[x<<1].minn,node[(x<<1)|1].minn);
}
void pushdown(int x)
{
    node[x<<1].p+=node[x].p;
    node[(x<<1)|1].p+=node[x].p;
    node[x<<1].minn+=node[x].p;
    node[(x<<1)|1].minn+=node[x].p;
    node[x].p=0;
}
void update_qj(int x,int l,int r,int v)
{
    if(node[x].l==l&&node[x].r==r)
    {
        node[x].p+=v;
        node[x].minn+=v;
        return ;
    }
    if(node[x].p)
        pushdown(x);
    int mid=(node[x].l+node[x].r)>>1;
    if(r<=mid)
        update_qj(x<<1,l,r,v);
    else
        if(l>mid)
            update_qj((x<<1)|1,l,r,v);
    else
    {
        update_qj(x<<1,l,mid,v);
        update_qj((x<<1)|1,mid+1,r,v);
    }
    node[x].minn=min(node[x<<1].minn,node[(x<<1)|1].minn);
}
```

---

## 作者：_Bluehole (赞：4)


**先说一下总体思路: 二分答案 + 差分前缀和优化。**

## 一.思路分析


首先，读题的时候注意到订单顺序是已经安排好的，而我们要做的就是求出哪些订单能被满足。

比较原始的一个思路就是:两重for循环，第一重枚举每一天，第二重按顺序遍历所有的需求，

看一下哪个需求在这一天需要教室，并累加一下，每加一次比较r[i]与need[i]的大小。

这样的话是O(nm)的复杂度，只有30分。而且这个思路不好优化。


所以要换个思路。这里要用到【正难则反】的思想。

就是，如果答案正着求不好求的话，我们可以想，如果有了答案，怎么验证它。

又：通常这类题答案又具有单调性，因此 => 二分答案。

这个题满足这2个条件：

①如果知道了能满足到哪些订单，我们验证只需要从头扫一遍即可。=>【知道答案易验证】

②因为订单是有顺序的，所以如果订单i能被满足，那么订单1...i-1一定都能

被满足；如果订单i不能满足，那么订单i+1...m一定都不能被满足。=>【答案具有单调性】


二分答案的一般套路是：二分 + check。

套模板=>我们只要二分出【能满足到哪个订单】(mid)，然后check(mid)，表示验证一下1...mid这些

订单能否被满足。如果能被满足，就去【右边区间】找——尝试满足更多的订单；如果不能满足，就

去【左边区间】找——尝试更少的订单能否被满足。


然后，在check的时候，我们发现要枚举1...mid的所有订单，把need[s...t]这一段区间加上d(这份

订单今天需要多少教室)。这里有【区间加】的操作，我们可以考虑【差分】，

将区间操作转换为端点操作，可以将复杂度的次幂降一个，如O(n^2) -> O(n)。

/\*
怎么做呢？就是，比如我们要将a[L...R]加1，我们可以在a[L]处加1，在a[R+1]处减1，然后对a数组

做一遍前缀和，就完成a[L...R]加1的操作了。

建议还是自己搜一下差分

\*/
以本题为例，假设我们要把所有need[s...t]这一段区间加d，暴力的写法就是：

```cpp
for(int i = 1; i <= mid; ++i){
    for(int j = a[i].s; j <= a[i].t; ++j)
        need[j] += a[i].d;
}
```
然而用差分就可以：

```cpp
for(int i = 1; i <= num; ++i){
    need[ a[i].s ] += a[i].d;
    need[ a[i].t+1 ] -= a[i].d;
}
for(int i = 1; i <= n; ++i)
    need[i] += need[i-1];
```
可以优化掉一层循环，使check的复杂度降到了O(n)。


另外，差分是可以推广的。比如11.2晚上的noip Day2模拟赛T3——星空(不剧透了)。


最后，不要排序！不要排序！认真读题，题目已经给你安排好顺序了、

我排了序，一直10分...后来看题解才幡然醒悟。

 
##  二.AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN = 1e6 + 10;
int n, m, ans;
//二分能满足多少订单(logm),每次差分+前缀和O(n)后扫一遍所有天数O(n),判断能否满足;
long long r[MAXN], cha[MAXN];
struct Order{
    long long d;
    int s, t;
}a[MAXN];

//检查能否满足1...num这些订单,如果能,返回true;如果不能,返回false;
bool check(int num){
    //差分.当然也可以用两个数组:一个差分数组,一个原数组;
    //做完操作后将差分数组做一遍前缀和再与原数组相加即可。
    for(int i = 1; i <= num; ++i){
        cha[ a[i].s ] += a[i].d;
        cha[ a[i].t+1 ] -= a[i].d;
    }
    for(int i = 1; i <= n; ++i){
        cha[i] += cha[i-1];
        if(cha[i] > r[i])return false;
    }        
    return true;
}

int main(){    
    cin>>n>>m;
    for(int i = 1; i <= n; ++i)scanf("%d", &r[i]);
    for(int i = 1; i <= m; ++i)scanf("%d%d%d", &a[i].d, &a[i].s, &a[i].t);

    //我不用L是因为小写L和1太容易混了!好吧我承认我懒得调Dev-C++数字颜色...
    int lef = 1, rig = m;
    while(lef <= rig){
        int mid = (lef + rig)>>1;
        if(check(mid)){
            ans = mid;    //如果能满足，就记录一下当前订单数
            lef = mid + 1;
        }
        else rig = mid - 1;
        for(int i = 1; i <= n; ++i)cha[i] = 0;
    }
    if(ans == m)cout<<0<<endl;
    else{
        cout<<-1<<endl;
        //因为当恰好不满足的时候二分退出，而ans记录的是满足的(最后一个)一个订单，
        //所以ans+1就是恰好不满足的那一个订单。要理解“恰好”的含义。 
        //这里不理解的话，可以画一个简单的例子模拟一下二分的最后一步。 
        cout<<ans+1<<endl;
    }
    return 0;
}
```

---

## 作者：Gorun (赞：1)

# 借教室 题解

&emsp;&emsp;其实对于这一题，我们可以发现，无论当前教室申请还是不申请，通过还是没有通过，都对于接下来的状态没有影响。那也就是说，它满足动态规划的一个非常重要的特点：无后效性；

&emsp;&emsp;相信做到这道题的同学以前都应该对于动态规划算法有所了解，那么就可以非常轻易地设计出状态：

设$f_{i,j}$表示当前处理到第$i$堂课且使用了$j$次申请机会，则状态转移方程如下：

&emsp;&emsp;等一下下，好像这样设计转移不出来。

&emsp;&emsp;为什么转移不出来？因为上一次申请的通过与否会影响到当前的状态到底要走那一边（即从$c_i$出发还是从$d_i$出发）。那么我们可以再附加一个上一次是否使用过申请机会的附加维度$0/1$，其中0表示上一次没有使用，1表示上次使用了。

那么我们就可以列出状态转移方程了：

$f_{i,j,0}=min\begin{cases}f_{i-1,j,0}+dis_{C1,C3}\\f_{i-1,j,1}+dis_{C1,C3} \times (1-k_{i-1})+dis_{C2,C3} \times k_{i-1}\end{cases}$

$f_{i,j,1}=min\begin{cases}f_{i-1,j-1,0}+dis_{C1,C3} \times (1-k_{i})+dis_{C1,C4} \times k_i\\f_{i-1,j-1,1}+dis_{C1,C3} \times (1-k_{i-1}) \times (1-k_{i})+dis_{C1,C4} \times (1-k_{i-1}) \times k_i+dis_{C2,C3} \times k_{i-1} \times (1-k_i) + dis_{C2,C4} \times k_{i-1} \times k_i\end{cases}$

（11.8更新） 抱歉。递推公式似乎显示有点问题，现稍微修改一下。

其中，$dis_{x,y}$表示教室$x,y$之间的最短距离，可以使用Floyd来解决。

定义如下：

$C1=c_{i-1},C2=d_{i-1},C3=c_i,C4=d_i$

附源代码：

```cpp
#include <cstdio>
using namespace std;
const int MAXN=1e6+10;
int n,m;
int ren[MAXN];
int dat[MAXN*4],add[MAXN*4];
int min(int a,int b)
{
	return a<b?a:b;
}
void build(int k,int l,int r)
{
	if (l==r)
	{
		dat[k]=ren[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	dat[k]=min(dat[k<<1],dat[k<<1|1]);
}
void pushdown(int k,int l,int r,int mid)
{
	if (add[k]==0) return;
	dat[k<<1]+=add[k];
	add[k<<1]+=add[k];
	dat[k<<1|1]+=add[k];
	add[k<<1|1]+=add[k];
	add[k]=0;
}
bool query(int k,int l,int r,int x,int y,int v)
{
	if (x<=l&&r<=y)
	{
		if (dat[k]<v) return false;
		else return true;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	bool ok1=true,ok2=true;
	if (x<=mid) ok1=query(k<<1,l,mid,x,y,v);
	if (mid<y) ok2=query(k<<1|1,mid+1,r,x,y,v);
	return ok1&&ok2;
}
void modify(int k,int l,int r,int x,int y,int v)
{
	if (x<=l&&r<=y)
	{
		add[k]+=v;
		dat[k]+=v;
		return;
	}
	int mid=l+r>>1;
	pushdown(k,l,r,mid);
	if (x<=mid) modify(k<<1,l,mid,x,y,v);
	if (mid<y) modify(k<<1|1,mid+1,r,x,y,v);
	dat[k]=min(dat[k<<1],dat[k<<1|1]);
}
int read()
{
	char a=getchar();
	int x=0;
	while (a<'0'||'9'<a) a=getchar();
	while ('0'<=a&&a<='9')
	{
		x=x*10+a-'0';
		a=getchar();
	}
	return x;
}
int main()
{
	//freopen("classroom.in","r",stdin);
	//freopen("classroom.out","w",stdout);
	n=read(); m=read();
	for (int i=1;i<=n;i++)
		ren[i]=read();
	build(1,1,n);
	for (int i=1;i<=m;i++)
	{
		int num,a,b;
		num=read(); a=read(); b=read();
		if (!query(1,1,n,a,b,num))
		{
			printf("-1\n%d",i);
			return 0;
		}
		modify(1,1,n,a,b,-num);
	}
	printf("0");
}
```


---

## 作者：brealid (赞：1)

## 0x00 先看数据范围

$ 1≤n,m≤10^6  $，第一反应 $O(nlogn)$

## 0x01 5 pts 

直接输出 '0' 即可。

不要问我怎么知道输出 '0' 可以拿 5 pts。

保持微笑.jpeg \*1

## 0x02 40~50 pts

考虑暴力。

按照题意枚举即可。

核心伪代码如下：

```
定义 n, m 为 int 型变量 
定义 r 为 int 型数组，大小为 Max_N 
读入 n, m
读入 r 数组 
定义 d, s, t 为 int 型变量 
使用变量 i 从 1 到 m 遍历
	读入 d, s, t
	使用变量 j 在 r 数组里从 s 到 t 遍历
		r[j] 减去 d;
		如果 r[j] < 0 那么 
			输出 "-1" 和回车 
			输出 i 
			结束程序
		否则 
			j 指针后移
输出 "0" 
结束程序 
``` 
然后，考察你程序的常数的时候到了。

保持微笑.jpeg \*2

## 0x03 70 pts

一看就是线段树。

然而，众所周知，线段树的常数是比较大的，所以只有 70 pts。

当然，我也看见了用线段树A题的大佬，在此表示由衷的敬意.

## 0x04 深入思考

回忆我们预测的时间复杂度：$O(nlogn)$

开始猜算法

> ![](https://cdn.luogu.com.cn/upload/pic/30121.png)
 
> ——阮行止

保持微笑.jpeg \*3

然后想到二分答案

## 0x05 二分？

设：二分答案的内容为最多可以满足第 mid 个人的需求

然后开始想 judge 函数。

这时候拼尽脑子想 $O(n)$ 算法

然后想到差分

## 0x06 二分 judge 函数之差分

伪代码：
```
函数参数：x(int 型整数) // 表示可否满足第 x 个人的需求
    Clear dif // dif 是大小为 Max_N 的 int 型数组
    For i (i between [1, x])
        dif[s[i]] = dif[s[i]] + d[i]
        dif[t[i] + 1] = dif[t[i] + 1] - d[i]
    now = 0
    For i (i between [1, n])
        now += dif[i];
        If now > r[i] Return false;
    Return true;
} 
```

## 0x07 二分

```
int l = 0, r = m, mid;
while (l < r) {
	mid = (l + r + 1) >> 1;
	if (judge(mid)) l = mid;
	else r = mid - 1;
}
if (l == m) putchar('0');
else puts("-1"), write(l + 1);
```

几点说明：

1. 如果 judge(m) 为真，说明所有订单均可满足
2. 因为 l 表示最多可以满足第 l 个人的需求，所以第一个需要修改订单的人的编号为 l + 1

## 0x08 代码

```
// luogu-judger-enable-o2
/**
 * Problem:	P1083 借教室. 
 * Author:	航空信奥. 
 * Date:	2018/08/23. 
 * Upload:	Luogu. 
 */
#include <stdio.h>
#include <string.h>

namespace HangKongXinAo {
    template <typename _TpInt> inline _TpInt read();
    template <typename _TpInt> inline void write(_TpInt x);
    
#	define Max_N 1000007
    
    int n, m, r[Max_N];
    int d[Max_N], s[Max_N], t[Max_N];
    int dif[Max_N]; 
    
    bool judge(int x)
    {
        memset(dif, 0, sizeof(dif));
        for (int i = 1; i <= x; i++) {
            dif[s[i]] += d[i];
            dif[t[i] + 1] -= d[i]; 
        }
        int now = 0;
        for (int i = 1; i <= n; i++) {
            now += dif[i];
            if (now > r[i]) return false;
        }
        return true;
    } 
    
    void Binary_search() 
    {
        int l = 0, r = m, mid;
        while (l < r) {
            mid = (l + r + 1) >> 1;
            if (judge(mid)) l = mid;
            else r = mid - 1;
        }
        if (l == m) putchar('0');
        else puts("-1"), write(l + 1);
    }
    
    int main() 
    {
        n = read<int>();
        m = read<int>();
        for (int i = 1; i <= n; i++) {
            r[i] = read<int>();
        }
        for (int i = 1; i <= m; i++) {
            d[i] = read<int>();
            s[i] = read<int>();
            t[i] = read<int>();
        }
        Binary_search();
        return 0;
    }

    char BufferRead[1 << 17];
    int rLen = 0, rPos = 0;
    inline char Getchar()
    {
        if (rPos == rLen) rPos = 0, rLen = fread(BufferRead, 1, 1 << 17, stdin);
        if (rPos == rLen) return EOF;
        return BufferRead[rPos++];
    } 

    template <typename _TpInt>
    inline _TpInt read()       
    {
        register int flag = 1;
        register char c = Getchar();
        while ((c > '9' || c < '0') && c != '-') 
            c = Getchar();
        if (c == '-') flag = -1, c = Getchar();
        register _TpInt init = (c & 15);
        while ((c = Getchar()) <= '9' && c >= '0') 
            init = (init << 3) + (init << 1) + (c & 15);
        return init * flag;
    }

    template <typename _TpInt>
    inline void write(_TpInt x)
    {
        if (x < 0) {
            putchar('-');
            write<_TpInt>(~x + 1);
        }
        else {
            if (x > 9) write<_TpInt>(x / 10);   
            putchar(x % 10 + '0');
        }
    }
}

int main()
{
    HangKongXinAo::main();
    return 0;
}
```

## 0x09 奶一口

标签为 $\color{#ffffff}\colorbox{#3498db}{提高+/省选-}$ ? 貌似恶意评分。。。

蒟蒻见解：$\color{#ffffff}\colorbox{#5eb95e}{普及+/提高}$

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P1083)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题主要有两种思路。一种属于暴力优化，常数大；另一种是二分。  
### P1 暴力优化
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这道题，首先想到区间同时减去一个值和查询最小值，暴力做$O(nm)$，线段树来维护的话就可以做到$O(m\log_2n)$，但是常数非常大。隔壁二分最快$212ms$（榜上数据），线段树$2s$（！！！）左右，在榜上根本找不着人......    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~如果要用线段树来做这道题的话，说实话它就是个板子。~~  
### P2 二分  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，可以维护区间减值的东西不止线段树一个，还有差分！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~雾草，难道你还要每次修改完之后再检查一遍吗？不还是$O(nm)$？~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然不是。有了差分这个东西，我们就可以用$O(1)$的时间完成一次修改，转而用$O(n)$的时间完成一次查询。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们的目标就是多修改，少查询。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回头再看一下题目。如果第$x$个订单出现了冲突，那么$x+1,x+2,......,m$在用差分处理的时候都会存在冲突，也就是说，冲突这个事件是单调的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们可以开始愉快地二分了。每次用$O(m)$的时间处理出操作完前$mid$条订单后的差分数组，再用$O(n)$的时间检查是否有冲突，这样时间就是$O((n+m)\log_2m)$的。
# 代码
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线段树代码：
```cpp
#include <cstdio>
//#define __DEBUG

#define isLeaf( a ) ( segTree[a].l == segTree[a].r )

const int MAXN = 1e6 + 5, MAXM = 1e6 + 5, INF = 0x3f3f3f3f;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ){ f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ), x = -x; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct segmentTreeNode
{
	int l, r;
	int minVal, lazy;
}segTree[MAXN << 2];

int r[MAXN], d[MAXM], s[MAXM], t[MAXM];
int N, M;

void upt( const int now )
{
	segTree[now].minVal = MIN( segTree[now << 1].minVal, segTree[now << 1 | 1].minVal );
}

void normalize( const int now )
{
	if( ! segTree[now].lazy ) return ;
	segTree[now << 1].minVal += segTree[now].lazy, segTree[now << 1 | 1].minVal += segTree[now].lazy;
	segTree[now << 1].lazy += segTree[now].lazy, segTree[now << 1 | 1].lazy += segTree[now].lazy; 
	
	segTree[now].lazy = 0;
}

void build( const int now, const int left, const int right )
{
	segTree[now].l = left, segTree[now].r = right;
	if( left == right )
	{
		segTree[now].minVal = r[left];
		segTree[now].lazy = 0;
		return ;
	}
	build( now << 1, left, ( left + right ) >> 1 );
	build( now << 1 | 1, ( ( left + right ) >> 1 ) + 1, right );
	upt( now );
}

void update( const int now, const int segL, const int segR, const int val )
{
	#ifdef __DEBUG
	segmentTreeNode &node1 = segTree[now];
	#endif
	if( segR < segTree[now].l || segTree[now].r < segL ) return ;
	if( segL <= segTree[now].l && segTree[now].r <= segR )
	{
		segTree[now].minVal += val;
		segTree[now].lazy += val;
		return ;
	}
	if( isLeaf( now ) ) return ;
	normalize( now );
	update( now << 1, segL, segR, val );
	update( now << 1 | 1, segL, segR, val );
	upt( now );
}

int query( const int now, const int segL, const int segR )
{
	#ifdef __DEBUG
	segmentTreeNode &node2 = segTree[now];
	#endif
	if( segR < segTree[now].l || segTree[now].r < segL ) return INF;
	if( segL <= segTree[now].l && segTree[now].r <= segR ) return segTree[now].minVal;
	if( isLeaf( now ) ) return INF;
	normalize( now );
	int v = query( now << 1, segL, segR );
	return MIN( v, 
				query( now << 1 | 1, segL, segR ) ); 
}

int main()
{
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) read( r[i] );
	build( 1, 1, N );
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( d[i] ), read( s[i] ), read( t[i] );
		if( query( 1, s[i], t[i] ) < d[i] )
		{
			write( -1 ), putchar( '\n' ), write( i ), putchar( '\n' );
			return 0;
		}
		update( 1, s[i], t[i], -d[i] );
	}
	puts( "0" );
	return 0;
}
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分代码：
```cpp
#include <cstdio>

const int MAXN = 1e6 + 5, MAXM = 1e6 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ){ f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ), x = -x; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int r[MAXN], d[MAXN], s[MAXN], t[MAXN], dif[MAXN];
int N, M;

bool chk( const int pos )
{
	for( int i = 1 ; i <= N ; i ++ ) dif[i] = 0;
	for( int i = 1 ; i <= pos ; i ++ ) dif[s[i]] += d[i], dif[t[i] + 1] -= d[i];
	int num = 0;
	for( int i = 1 ; i <= N ; i ++ )
	{
		num += dif[i];
		if( num > r[i] ) return false;
	}
	return true;
}

int main()
{
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) read( r[i] );
	for( int i = 1 ; i <= M ; i ++ ) read( d[i] ), read( s[i] ), read( t[i] );
	if( chk( M ) )
	{
		puts( "0" );
		return 0;
	}
	puts( "-1" );
	int l = 1, r = M - 1, mid;
	while( r - l > 1 )
	{
		mid = ( l + r ) >> 1;
		if( chk( mid ) ) l = mid + 1;
		else r = mid;
	}
	if( ! chk( l ) ) write( l );
	else write( r );
	putchar( '\n' );
	return 0;
}
```

---

## 作者：OguraEn (赞：0)

~~（谢邀）~~

各位二分线段树大佬太巨了emmm，菜鸡太久没写二分，看此题第一反应是差分水题。

这道题目最明显的提示我是差分的地方在于**区间加减**，数据在10000以上暴力地无脑计算是肯定会T的，那么对于这种大区间级别运算问题，通常我们考虑的有**树状数组（线段树）**和**差分**。

因为本题不会涉及到区间修改，普通的差分就可以过。

差分的含义在于：对于一段要进行相同加减操作的区间，**它进行操作的结果是会比后面的区间大或小一个常数**，我们在意的只是最终效果，因此我们不必完全暴力模拟这个过程，只需要**记录这段区间进行运算后的效果**就好了。

因此，我们重新声明一个区间效果数组，在需要运算的区间的开头元素的下标处加上这个常数，在这个区间末尾元素后一个元素的下标减去这个常数，就记录下这个区间产生的效果。

当我们需要求最终区间的时候，只需从开头开始做一次前缀和即可。

本题在处理好差分数组后只需从头扫一遍，遇见第一个不合法的天数记录下来，在从第一个请求开始验证，遇到第一个使当前天数不合法的订单，输出即可。

贴下我丑陋的代码：
```c
#include <bits/stdc++.h>
using namespace std;
int n,m;
struct edge
{
  int x;
  int y;
  int v;
}e[1001000];
long long a[1001000];
long long sum[1001000];
void init()
{
  scanf("%d %d\n",&n,&m);
  for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
  for(int i=1;i<=m;i++)
    scanf("%d %d %d\n",&e[i].v,&e[i].x,&e[i].y);
}
void work_()
{
  memset(sum,false,sizeof(sum));
  for(int i=1;i<=m;i++)
  {
    sum[e[i].x]+=e[i].v;
    sum[e[i].y+1]-=e[i].v;
  }
  for(int i=1;i<=n;i++)
    sum[i]+=sum[i-1];
}
int main()
{
  init();
  work_();
  int temp=0;
  for(int i=1;i<=n;i++)
  {
    if(sum[i]>a[i])
    {
	  temp=i;  //找到不合法的天数 
	  break;
	}
  }
  long long k=0;
  for(int i=1;i<=m;i++)
  {
    if(e[i].x<=temp&&e[i].y>=temp)  //如果当前区间段包含了不合法天数 进行处理 
    {
      k+=e[i].v;
	  if(k>a[temp])
	  {
	    cout<<-1<<endl;
	    cout<<i<<endl;
	    return 0;
	  }
	}
  }
  cout<<0<<endl;
  return 0;
} 


```

洛谷首文，感谢各位dalao阅读

---


# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17\text{m/s}$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1\text{s}$ 内移动 $60\text{m}$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。

## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。

## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# 题解

## 作者：wpy233 (赞：101)

诶，看了四十余篇题解，似乎没有发现跟本蒟蒻思路一样的QAQ

**思路如下：**

①题目里给你多少魔，你就先用掉多少魔，如果在时间$t$内都闪不出去，守望者：~~啊啊啊我弃疗了~~，输出`No`。

②闪完后，先记得把距离、时间、还有魔都扣掉，然后开一组死循环，**按照剩余魔的数量进行模拟**。

为啥要这么模拟？~~因为没人写这种思路~~因为这样处理起来会爽很多QAQ

魔的数量只可能是0~9，有了范围，下面就一起来愉快地判断吧！
```
魔为0~1，很显然，原地恢复5秒再闪2秒比跑7秒来的快；
魔为2~5，很显然，原地恢复2秒再闪1秒比跑3秒来的快；
魔为6~9，很显然，原地恢复1秒再闪1秒比跑2秒来的快；
```
让我们打出一个表，就是这样的：
```
魔剩余点数  剩余距离范围  剩余时间范围  闪后魔点数
    0          >=120          >=7s          0
    1          >=120          >=7s          1
    2          >=52           >=3s          0
    3          >=52           >=3s          1
    4          >=52           >=3s          2
    5          >=52           >=3s          3
    6          >=35           >=2s          0
    7          >=35           >=2s          1
    8          >=35           >=2s          2
    9          >=35           >=2s          3
```
让我们写出代码，就是这样的：
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int m,s,t;//定义
int main()
{
    cin>>m>>s>>t;
    int AK=t;
    int ak=s;//emmm，个人喜好
    if((m/10)*60>=s&&m/10>=t)//能不能直接用魔闪完
    {
    	cout<<"Yes"<<endl;
    	if(s%60==0)
    		cout<<s/60<<endl;
    	else
    		cout<<s/60+1<<endl;
    	exit(0);
	}
	int p=(m/10)*60;//计算魔可以闪过的米数
	if(t<m/10)//如果给定的时间不可以把魔全闪完
		if(t*60<s)//如果连魔都闪不完
		{
			cout<<"No"<<endl;
			cout<<t*60<<endl; //守望者弃疗了
			exit(0);
		}
		else
		{
			if(s%60==0)
    			cout<<s/60<<endl;
    		else
    			cout<<s/60+1<<endl;
    		exit(0);
		}
	else
		t-=(m/10);//把魔闪完减掉的时间
	m%=10;
	s-=p;//更新剩余距离
	for(;;)//死循环
	{
		if(s<=0)
		{
			cout<<"Yes"<<endl;
			cout<<AK-t<<endl;//如果已经跑完了，输出
			exit(0);
		}
		if(t==0)//如果时间用完了还是跑不完
		{
			cout<<"No"<<endl;
			cout<<ak-s<<endl;//守望者弃疗了
			exit(0);
		}
		if(m<=1&&s>=120&&t>=7)//魔剩余点数0~1
		{
			s-=120;
			t-=7;
			continue;
		}
		if(m>=2&&m<=5&&s>=52&&t>=3)//魔剩余点数2~5
		{
			s-=60;
			t-=3;
			m+=8;
			m%=10;
			continue;
		}
		if(m>=6&&m<=9&&s>=35&&t>=2)//魔剩余点数6~9
		{
			s-=60;
			t-=2;
			m+=4;
			m%=10;
			continue;
		}
		while(1)//如果时间不够没法闪
		{
			s-=17;//守望者开始跑步
			t--;
			if(s<=0||t<=0)
				break;
		}
	}
    //码了1k，好累啊。。。
    return 0;
}

---

## 作者：wzr1125 (赞：52)

### 简化的DP
首先算一下速度，发现闪现在时间足够的时候比跑步快。有两种走法：原地攒魔法放法术，或者直接跑步。

不妨用两个变量分别模拟闪现的距离（fla）和跑步的距离（run），并用fla维护run，使跑步的距离最优。在每一时刻判断fla和run的最大值有无满足条件的，输出即可。

什么意思呢，如果在某一时刻，闪现的距离大于了跑步的距离，就将跑步的距离更新成此时闪现的距离，在此基础上继续跑。因为如果时间够，就可以在闪现的基础上跑步，闪现是比跑步快的。

模拟一下，以第2个样例为例：

| 最大距离 | 60 | 120 | 180 | 197 | 240 | 255 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 闪现 | 60 | 120 | 180 | 180 | 240 | 240 |
| 跑步 | 17 | 77 | 137 | 197 | 214 | 255 |
可以看出，跑步是在上一步闪现与跑步的最大值的基础上跑的。

上代码，与普通DP相比用变量代替了数组
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,fla,run;//分别代表闪现距离，跑步距离
int main(){
	cin>>m>>s>>t;//读入; 
	for(int i=1;i<=t;i++){//时间; 
		
		if(m>=10)m-=10,fla+=60,run+=17;//蓝够了就闪,另一边跑步;
		else{if(fla>run)run=fla;//在最优的基础上跑; 
			m+=4,run+=17;}//回蓝,另一边跑步; 

		if(max(fla,run)>=s){
			printf("Yes\n%d\n",i);return 0;} //出去了 
	}
	cout<<"No"<<endl<<max(fla,run)<<endl;//没出去 
	return 0;
}
```


---

## 作者：GLr137 (赞：38)

### 思路

[更加舒适的阅读体验](https://www.luogu.com.cn/article/9thae549)

难度大约为橙。

我们令 $ dp_i $ 为守望者再第 $ i $ 秒最多可以逃离的米数。

我们不难发现，守望者在任何一点所使用闪烁法术而逃离的距离是固定的，我们就可以先把每一点用闪烁法术可逃离的最大距离保存下来，然后再遍历一遍，根据已有数组判断是否要根据前面的状态转移过来，还是保留原先的利用闪烁法术逃离的米数。在遍历的过程中，顺势判断此时逃离的最大距离是否大于初始位置与岛的出口之间的距离，是则输出 `Yes` 和时间，并结束程序。

### 代码

```cpp
# include <bits/stdc++.h>
using namespace std;
int main (){
    int m, s, t, z, dp[300005] = {0};
    cin >> m >> s >> t;
    for (int i = 1; i <= t; i++){
        dp[i] = dp[i - 1] + (60 * (m >= 10));    //省去判断
        z = m;
        m -= (10 * (z >= 10));   //省去判断
        m += (4 * (z < 10));    //省去判断
    }
    for (int i = 1; i <= t; i++){
        dp[i] = max(dp[i], dp[i - 1] + 17);
        if (dp[i] >= s){
            cout << "Yes\n" << i;
            return 0;
        }
    }
    cout << "No\n" << dp[t];
    return 0;
}
```

[AC 记录。](https://www.luogu.com.cn/record/198766901)

---

## 作者：Cold_Eyes_bystander (赞：24)

先猜想在大部分的情况下，最优策略是什么，当然是即用魔法又正常走路。

那我们不妨让所有走路的过程都放到最后，那什么时候开始走路了？

这就是我们要贪心的地方了，我们假设有两个人跑步，第一个人正常走路，另一人使用魔法，在某一时间点时，第二人超过了第一人，第一人很后悔，**于是重新开始跑步，但这次使用第二人的策略直到原来的时间点**，如果第二人不敌第一人，**第一人坚持原来策略，直到第二人追上第一人**。

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int m,s,t;
    cin>>m>>s>>t;
    int s1=0,s2=0;
    for(int i=1;i<=t;i++)
    {
        s1+=17;
        if(m>=10)
        {
            s2+=60;
            m-=10;
        }
        else
        {
            m+=4;
        }
        if(s2>s1)
        {
            s1=s2;
        }
        if(s1>=s)
        {
            cout<<"Yes"<<endl<<i;
            return 0;
        }
    }
    cout<<"No"<<endl<<s1;
    return 0;
}
```

---

## 作者：jingwenhan (赞：13)

~~本蒟蒻的第一篇题解~~

## 思路：

1. 定义一个 $dp[i]$ ，表示第 $i$ 秒最多能走都远。

2. 先全部用闪烁，记录最远能走多远，因为闪烁平均每 3 秒能完成一次闪烁，能前进 60 米，而步行 3 秒只能前进 51 米，所以尽量选择闪烁。

3. 由于可能会出现以下情况，我们要比较步行和闪烁哪个先到终点。

 
```
s=94
60        60          60
闪烁      恢复        恢复
dp[i]     dp[i+1]     dp[i+2]
闪烁      步行        步行
60        77          94
                      /\
                    / || \
                      ||
                     终点
```

这样就能完美 $AC$ 了！

## 代码：


```cpp
#include<bits/stdc++.h>//万能头文件
#define ll long long
using namespace std;
int m,s,t,ans,dp[10000010];
int main(){
	cin>>m>>s>>t;
	for(int i=1;i<=t;i++){//全部闪烁
		if(m>=10) dp[i]=dp[i-1]+60,m-=10;
		else m+=4,dp[i]=dp[i-1];
	}
	for(int i=1;i<=t;i++){
		if(dp[i]<dp[i-1]+17) dp[i]=dp[i-1]+17;//比较那个快
		if(dp[i]>=s){//到终点了就输出
			cout<<"Yes"<<endl<<i;
			return 0;
		}
	}
	cout<<"No"<<endl<<dp[t];//到不了终点
	return 0;
}
```

---

## 作者：Asurudo (赞：11)

这个守望者跑步啊，仔细想一想，有以下几种"奔跑礼包"可供选择:

① $-1s$  $+60m$ ($M≥10$)

② $-2s$  $+60m$ ($M≥6$)

③ $-3s$  $+60m$ ($M≥2$)

④ $-4s$ $+60m$ (无要求)

⑤ $-7s$ $+120m$ ($T≥7$ && $S≥120$)

⑥ $-1s$ $+17m$ (无要求)

也许还有其他选择礼包，不过都是由这六种礼包拼出来的，不然就无法达到最优。

很显然，礼包①②③血赚不亏，只要能用就一定最优，所以有魔力值的时候先用魔力值进行移动。
但是魔力值总归会有耗光的那一天，当魔力值严格小于2的时候我们就不能用前三种礼包了，这就要求我们从下面三个礼包中选择来进行移动。

不管用两次④礼包，还是用七次⑥礼包，在③礼包满足条件的情况下，他们都没有⑤礼包收益高，因此当⑤礼包满足条件的时候，我们优先选取⑤礼包。

这时候，魔力值应该只可能是$0,1,2$三种可能，时间也只可能剩下$1-6s$这六种可能，因为**没有时间**或者**已经到达出口**这两种情况都已经退出循环可以直接输出结果了。现在我们依然寻求在最后这几秒到达更远的距离($PLUS ALTRA$)(x)

现在要么用④礼包，要么用⑥礼包，很显然，⑥礼包明显更优。贪心完了，写出程序跑一下，发现第一个样例就$WA$了(....。

原因在哪里呢？原因在于之前②③并不是血赚不亏的。我们来想象这样两种情况，如果时间只剩$1s$，蓝还有$9$，我难道还选择补蓝然后来一个②礼包吗？如果距离只剩下$15m$，蓝还有$9$，我难道还选择补蓝然后来一个②礼包吗？显然不是，我不用瞬移，跑两步就完事了。

因此，我们改变一下策略。如果蓝足够，选①一定没错，然后时刻关注剩余时间和剩余距离，如果⑥礼包更优，那就选⑥礼包。

①礼包将魔力值消耗到$10$以下，如果⑥礼包不是最优，考虑选购②③礼包，魔力值不断加$4$接着对$10$取余，总会有魔力值不到$2$的那一次，因此②③礼包也有不能用的时候，这时候就狂用⑤礼包，用到没魔力$(0-2)$也没时间$(1-6)$或没距离的时候$(1-119)$，这时候一定是⑥礼包最优。

$AC$代码
```cpp
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
#define maxn 13003
#define _for(i,a,b) for(int i = (a);i < b;i ++)
typedef long long ll;
using namespace std;

inline ll read()
{
    ll ans = 0;
    char ch = getchar(), last = ' ';
    while(!isdigit(ch)) last = ch, ch = getchar();
    while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
    if(last == '-') ans = -ans;
    return ans;
}
inline void write(ll x)
{
    if(x < 0) x = -x, putchar('-');
    if(x >= 10) write(x / 10);
    putchar(x % 10 + '0');
}
int M,S,T;
int SS,TT;
int main()
{
    M = read(),S = read(),T = read();
    SS = S;TT = T;
    int i;
    for(i = 0;i < T;i ++)
    {
		if(S <= 0) break;
		if(M >= 10)
		{
			M -= 10;
			S -= 60;
		}
		else if(((T-i<=1||S<=17)&&M<10) || ((T-i<=2||S<=34)&&M<6)
		 || ((T-i<=3||S<=51)&&M<2) || ((T-i<=4||S<=68)&&M<2)
		 || ((T-i<=5||S<=85)&&M<2) || ((T-i<=6||S<=102)&&M<2)
		 || (S<=119&&M<2))
			S -= 17;
		else if(M >= 2)
			M += 4;
		else if(S >= 120 && T-i >= 7)
		{
			while(S >= 120 && T-i >= 7)
			{
				i += 7;
				S -= 120;
			}
			i --;
		}
	}
	if(S <= 0)
		printf("Yes\n%d\n",i);
	else
		printf("No\n%d\n",SS-S);
    return 0;
}
```


---

## 作者：小睿2012 (赞：7)

首先，能闪烁，就肯定先闪烁，因为这样 $1$ 秒能跑 $60$ 米，肯定最优，留着后面用，肯定不会更优。

无法直接闪烁就分 $3$ 种情况讨论。

1. 点数为 $0 \sim 1$ 时，原地休息 $5$ 秒，再闪烁 $2$ 秒，前进 $120$ 米, 比跑 $7$ 秒，前进 $119$ 米更优，剩余原来的点数，所以距离大于等于 $119$ 米，点数为 $0 \sim 1$ 时，剩余时间是 $7$ 秒及以上时一定最优。
2. 点数为 $2\sim 5$ 原地休息 $2$ 秒，再闪烁 $1$ 秒，前进 $60$ 米， 比跑 $3$ 秒，前进 $51$ 米更优，点数减少 $2$，所以剩余距离超过 $51$ 米，点数为 $2\sim 5$ 时，剩余时间是 $3$ 秒及以上时，一定最优。
3. 点数为 $6 \sim 9$ 是原地休息 $1$ 秒，再闪烁 $1$ 秒，前进 $60$ 米, 比跑 $2$ 秒，前进 $34$ 米更优，点数减少 $6$，所以剩余距离超过 $34$ 米，点数为 $6 \sim 9$ 时，剩余时间是 $3$ 秒及以上时，一定最优。

如果不满足条件直接正常跑最快。

所以模拟即可。

给出代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int m,s,t;//如题意
	cin >> m >> s >> t;
	int tt = 0,jl = 0;//表示时间,路程
	while(tt < t && jl < s)
	{
		while(m >= 10)//能闪烁
		{
			m -= 10;
			jl += 60;
			tt++;
			if(jl >= s)
			{
				cout << "Yes" << '\n';
				cout << tt;
				return 0;
			}
			if(tt >= t)
			{
				cout << "No" << '\n';
				cout << jl;
				return 0;
			}
		}
		if((m == 0 || m == 1) && t - tt >= 7 && s - jl >= 119) // 情况1
		{
			jl += 120;
			tt += 7;
		}
		else if(m >= 2 && m <= 5 && t - tt >= 3 && s - jl > 51)//情况2
		{
			jl += 60;
			tt += 3;
			m -= 2;
		}
		else if(m >= 6 && m <= 9 && t - tt >= 2 && s - jl > 34)//情况3
		{
			jl += 60;
			tt += 2;
			m -= 6;
		}
		else//正常跑
		{
			while(tt < t && jl < s)
			{
				jl += 17;
				tt++;
			}
			break;
		}
	}
	if(tt > t || (tt == t && jl < s))
	{
		cout << "No" << '\n' << jl;
	}
	else
		cout << "Yes" << '\n' << tt;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/198693147)

---

## 作者：ryf2011 (赞：7)

# 题目思路
注：本题解的题目思路中所有没有提及意义但出现的变量或常量都为输入值或题目中给出的值。

题目说岛沉没的时间为 $T$，所以我们用循环枚举 $T$ 秒之内的路程，并判断能否逃离。

我们维护一个变量记录最远距离，如果最远距离大于或等于 $S$，就计算最短时间。

如果当前的魔法值大于或等于 $10$，那我们就使用魔法，否则，就原地恢复魔法值。

如果当前已经逃离，就计算最短时间，并退出循环。

如果最短时间小于 $T$，说明成功逃离，否则，说明未成功逃离，再按照格式输出即可。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int m,s,t,nowt,mint=2147483647,maxd,nowd; //mint:最短时间，maxd:最长距离，nowd:当前移动距离
int main(){
	scanf("%d %d %d",&m,&s,&t); 
	for(int i=1;i<=t;i++){ //在 t 秒内 
		maxd=max(maxd,nowd+(t-i+1)*17); //计算最远距离（即最远距离与当前路程取最大值，速度 17 由题意可知） 
		if(maxd>=s){ 
			mint=min(mint,i-1+(s-nowd+16)/17); //计算最短时间 
		}
		if(m>=10){ //如果魔法值 >=10，则可以使用魔法，直接使用 
			m-=10; //魔法值 -10 
			nowd+=60; //当前移动距离 +60（由题意可知） 
		}
		else{ //否则，原地恢复魔法值 
			m+=4;	
		}
		if(nowd>=s){ //如果逃离，计算最短时间，即取最短时间和当前时间的最小值，并退出循环 
			mint=min(mint,i);
			break;
		}
		maxd=max(maxd,nowd); //计算最大距离，即最大距离与当前移动距离取最大值 
	}
	if(mint<=t){ //如果成功逃离，先输出 "Yes" 并换行，再输出最短时间 
		printf("Yes\n%d\n",mint);
	}
	else{ //否则，先输出 "No" 并换行，再输出最长距离 
		printf("No\n%d\n",maxd);
	}
	return 0;
} 
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：Ryan114 (赞：5)

[原题链接](https://www.luogu.com.cn/problem/P1095)
### 题意简化
守望者所在的这座岛 $T$ 秒就会沉下去，守望者跑步 $17m/s$，可以消耗 $10$ 魔法值闪烁，$1s$ 移动 $60m$，不动每秒可以恢复 $4$ 魔法值。给定初始魔法值 $M$ ，距离 $S$ 和沉没时间 $T$ ，求能否逃离岛，逃离距离和逃离时间。

注意：守望者跑步、闪烁或休息均以秒为单位，且持续时间为整数秒。

### 思路
一眼看到这道题是贪心+模拟：

如果魔法值大于 $10$，直接使用闪烁，已走距离加 $60$ ，魔法值减 $10$ ；

当魔法值不够 $10$ 时，肯定一会恢复一会跑步更快，因为这样不仅可以更快使用闪烁同时可以向前移动。那么如何切换呢？考虑一种状态 $S_1$ 只跑步，考虑一种状态 $S_2$ 只闪烁，因为闪烁的先后不影响结果，所以当 $S_2$ 超过 $S_1$ 时，$S_1$ 开始使用闪烁，那么 $S_1$ 就是既闪烁又走路的最优距离。

### 代码
```cpp
#include<iostream>
using namespace std;
int main()
{
    int m,s,t; //魔法值，距离，时间
    int x1=0,x2=0; //两种状态
    cin>>m>>s>>t;
    for(int i=1;i<=t;i++) //在 t 秒内
    {
        x1+=17; //第一种状态：走路
        if(m>=10) m-=10,x2+=60; //第二种状态：闪烁
        else m+=4;
        if(x2>x1) x1=x2; //跟进
        if(x1>s) //到了输出时间
        {
            cout<<"Yes"<<endl<<i;
            return 0;
        }
    }
    cout<<"No"<<endl<<x1; //没到输出距离
    return 0;
}
```

[我的记录](https://www.luogu.com.cn/record/198868195)

本蒟蒻第一篇题解，有错漏请指出，希望管理通过。
### 感谢查看

---

## 作者：Danny_chan (赞：4)

我们可以使用贪心同时维护跑步和休息。先记下使用魔法的地方，然后跑步的位置可以由之前使用魔法的地方继续走，最后取最大值就可以了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int m,s,t;
int d=0,maxx=-1e18;
signed main(){
	cin>>m>>s>>t;
	for(int i=1;i<=t;i++){
		if(m>=10){
			m-=10;
			d+=60;
		}
		else{
			m+=4;	
		}
		maxx+=17;
		if(d>maxx){
			maxx=d;
		}
		if(maxx>s){
			cout<<"Yes"<<endl;
			cout<<i<<endl;
			return 0; 
		}
	}
	cout<<"No"<<endl;
	cout<<maxx<<endl;
	return 0; 
}

```

---

## 作者：suzhikz (赞：3)

首先能闪现肯定会闪现，这是显然的。

但是有时候不能闪现，于是我们有两个选择，跑步和休息。

但是这两玩意谁也说不准谁更大，于是这两个我们都要维护。

发现能量足够的情况下，先跑步再闪现和先闪现再跑步本质相同，所以我们可以直接记下只闪现的位置，然后跑步的位置可以由上一秒闪现后再继续走。然后对于跑步贪心取最大即可。

放下古早码风。


```cpp
long long a,b,c,s1=0;
long long book=0;
cin>>a>>b>>c;
for(long long i=1;i<=c;i++){
	if(a>=10){a-=10;s1+=60;}
	else a+=4;
	book+=17;
	if(s1>book)book=s1;
	if(book>b){
  	cout<<"Yes"<<endl<<i;
           return 0;
	}
}
cout<<"No"<<endl<<book;
```

---

## 作者：a202401006 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1095)


# 分析
题意：求得下一步该是用魔法闪现还是跑步，魔法闪现又分为魔法闪现完跑步或恢复魔法值。考察动态规划和贪心算法。具体解析见代码注释。

# AC 代码
亮出简单明了的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,run,magic;
int main()
{
	cin>>m>>s>>t;
	for(int i=1;i<=t;i++)//倒计时 
	{
		m>=10?m-=10,magic+=60:m+=4;//这里是缩写 
		run=max(run+17,magic);//求能否闪现，不能则用跑步最大值 
		if(run>=s)
		{
			cout<<"Yes"<<endl<<i;//输出能 
			return 0;
		}
	}
	cout<<"No"<<endl<<run;//输出不能 
	return 0;
}
```

---

## 作者：NewbieZZZ (赞：2)

这道题是老师给我的 dp 练习题。然而，我觉得 dp 太繁琐~~我还不会~~，转而贪心地去贪心了。

---

设 $dis_i$ 表示守望者 $i$ 秒内走的最大路程（单位：米）。 

首先，我们发现，闪现速度绝对比守望者跑步速度快，并且守望者不会后退（~~废话~~）。\
因此，我们尽可能让他使用闪现，每秒跑 $60$ 米，消耗 $10$ 点魔法值。而如果魔法值不够用，就原地回复。

但是，在没有魔法值的情况下，回复 $10$ 点魔法值需要停 $3$ 秒。这速度，让守望者跑步都能跑 $51$ 米，时间就是金钱，效率就是生命！

我们要尽量让守望者跑得更远，就要在跑步和回复魔法值之间取一个平衡。

---

~~好像还要考虑 dp~~。在一秒内（如果不闪现）有两种情况：

1. 不走，回复魔法值，准备闪现（在之前已经将这种情况所走的路程存储入 $dis$ 数组）；
2. 走 $17$ 米，跑路要紧！即，$dis_i = dis_{i-1} + 17$。

最后，枚举时间 $i(1\le i\le t)$，更新状态（$dis_i = \max\left(dis_{i-1} + 17,dis_i\right)$）。

如果我们发现提前逃出去了，我们就没必要枚举了，直接中止程序（他跑了 $i$ 秒）；否则如果 $t$ 秒内没有跑 $s$ 米，那么他没有逃出去，跑的路程即为 $dis_t$。

### 代码

其实，基础 dp 真的不太难，有点像分类讨论。经过刚刚的推理，代码其实已经呼之欲出了。

建议自行编写代码。

```cpp
#include <bits/extc++.h>
using namespace std;
// #define cin goodbye2024
// #define cout hello2025

int m, s, t, dis[300030];

int main(){
    cin >> m >> s >> t;
    for(int i=1; i<=t; ++i){
        dis[i] = dis[i-1];
        if(m >= 10){
            dis[i] += 60, m -= 10;
        } else {
            m += 4;
        }
    }
    for(int j=1; j<=t; ++j){
        dis[j] = max(dis[j], dis[j-1] + 17);
        if(dis[j] >= s){
            cout << "Yes\n" << j;
            return EXIT_SUCCESS;
        }
    }
    cout << "No\n" << dis[t];
    return EXIT_SUCCESS;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

动态规划和贪心。

能闪现一定闪现，若不能闪现，则可能在原地等魔法值恢复，或跑步。考虑动态规划，设 $S_1$ 表示用闪现和跑步的最远距离，$S_2$ 表示不用跑步只用闪现的最远距离。

因为能闪则闪，所以当某一时刻闪现的最远距离超过跑步最远距离，应在闪现的基础上跑步，由此得到转移。枚举时间，先更新 $S_2$，只需要判断是否能闪现，若能 $S_2=S_2+60$，若不能就恢复魔法值，则 $S_1=\max(S_1+17, S_2)$。

那任意时刻的最远距离就是 $S_1$，判断能否逃离，若此时能逃离，最短时间就是当前时间。若最后不能逃离，再按题目输出即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int m, s, t, s1, s2;
int main(){
	cin >> m >> s >> t;
	for(int i=1; i<=t; i++){
		m>=10?m-=10,s2+=60:m+=4; 
		s1=max(s1+17, s2);
		if(s1>s){
			cout << "Yes\n" << i;
			return 0;
		}
	}
	cout << "No\n" << s1;
	return 0;
}
```

---

## 作者：__mutsumi__ (赞：1)

很显然，在魔法值大于 $10$ 时闪一定比跑步快，所以一开始一定要尽可能使用闪。在闪到不能继续闪后，就要尝试用等的时间来恢复魔法值。

注释在代码里面~~有点少~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,ma,dp[300005];
int main(){
	cin>>m>>s>>t; 
	for(int i=1;i<=t;i++){//dp[i]为用i秒一直闪（不跑）的最远距离 
		if(m>=10){
			dp[i]=dp[i-1]+60;
			m-=10;
		}else{
			dp[i]=dp[i-1];
			m+=4;
		}
	}
	for(int i=1;i<=t;i++){
		dp[i]=max(dp[i],dp[i-1]+17);//将第i-1秒用来跑
		ma=max(ma,dp[i]);//更新最远距离 
		if(dp[i]>s){
			printf("Yes\n%d",i);
			return 0;
		}
	}
	printf("No\n%d",ma);
	return 0;
}
```

---

## 作者：Andy_WA (赞：1)

## 题目大意
守望者所在的这座岛 $T$ 秒就会沉下去，守望者跑步 $17m/s$，可以消耗 $10$ 魔法值闪烁，$1s$ 移动 $60m$，不动每秒可以恢复 $4$ 魔法值。给定初始魔法值 $M$，距离 $S$ 和沉没时间 $T$，求能否逃离岛，逃离距离和逃离时间。

注意：守望者跑步、闪烁或休息均以秒为单位，且持续时间为整数秒。

## 题目思路
能闪烁，就肯定闪烁，因为这样 $1$ 秒能跑 $60$ 米，肯定最优。

先枚举每一秒（$timex$），更新如下代码的 $S_2$ （纯技能运动的距离）：能发动技能就发动，$S_2+60$，$magic-10$；否则原地休息，$magic+4$。

$S_1$ 取跑步和发动技能的最大值即可，即 $S_1=max(S_1+17,S_2)$。

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long magic,s,timex;
int main(){
    cin>>magic>>s>>timex;
    int s1=0,s2=0,time1=timex;
    while(s>s1 && timex>0){
        if(magic>=10) s2+=60,magic-=10;
        else magic+=4;
        s1=max(s1+17,s2);
        timex--;
    }
    if(s1<s) cout<<"No"<<endl<<s1<<endl;
    else cout<<"Yes"<<endl<<time1-timex<<endl;
    return 0;
}
```

---

## 作者：sunny12888 (赞：1)

## 题目链接
[Link](https://www.luogu.com.cn/problem/P1095)
## 题目解法
考虑多种情况。

1. 若魔法值大于等于 $10$ 时，一定使用魔法移动。

2. 若魔法值 $<10$ 时，分 $3$ 种情况讨论：
- 若魔法值大于等于 $0$ 且小于等于 $1$ 时：休息 $5$ 秒，使用魔法移动 $120$ 米（魔法移动时间为 $2$ 秒）（否则会造成浪费）。若跑步，路程为 $119$ 米。只要魔法值大于等于 $0$ 且小于等于 $1$ 且距终点的路程大于等于 $119$ 米，剩余时间大于等于 $7$ 秒时，就使用魔法；否则选择跑步。

- 若魔法值大于等于 $2$ 且小于等于 $5$ 时：休息 $2$ 秒，使用魔法移动 $60$ 米（魔法移动时间为 $1$ 秒）。若跑步，路程为 $34$ 米。只要魔法值大于等于 $2$ 且小于等于 $5$ 且距终点的路程大于等于 $34$ 米，剩余时间大于等于 $3$ 秒时，就使用魔法；否则选择跑步。

- 若魔法值大于等于 $6$ 且小于等于 $9$ 时：休息 $1$ 秒，使用魔法移动 $60$ 米（魔法移动时间为 $1$ 秒）。若跑步，路程为 $17$ 米。只要魔法值大于等于 $6$ 且小于等于 $9$ 且距终点的路程大于等于 $17$ 米，剩余时间大于等于 $2$ 秒时，就使用魔法；否则选择跑步。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int m,s,t;
	cin >> m >> s >> t;
	int time = 0,lucheng = 0;//表示时间,路程
	while(time<t &&lucheng< s)
	{
		while(m>=10)//能使用闪烁法术 
		{
			m-=10;//减少 
			lucheng+=60;//距离 
			time++;
			if(lucheng>=s)//判断 （可以
			{
				cout <<"Yes"<<endl;
				cout << time<<endl;
				return 0;
			}
			if(time>=t)//判断（不可以）
			{
				cout << "No" <<endl;
				cout << lucheng<<endl;
				return 0;
			}
		}
		if((m == 0 || m == 1) && t-time>=7 && s-lucheng>=119) // 情况1：魔法值在0到1之间 
		{
			lucheng += 120;
			time += 7;
		}
		else if(m >= 2 && m<=5 && t-time >= 3 && s-lucheng>51)//情况2
		{
			lucheng += 60;
			time += 3;
			m -= 2;
		}
		else if(m >= 6 && m <= 9 && t-time>=2 && s-lucheng> 34)//情况3
		{
			lucheng += 60;
			time += 2;
			m -= 6;
		}
		else//正常跑
		{
			while(time<t && lucheng<s)
			{
				lucheng+=17;
				time++;
			}
			break;
		}
	}
	//只考虑跑步情况 
	if(time> t||(time == t && lucheng<s))
	{
		cout<<"No"<<'\n'<<lucheng;
	}
	else
		cout <<"Yes"<<'\n'<<time;
	return 0;
}
```

---

## 作者：mairuisheng (赞：1)

[P1095 [NOIP2007 普及组] 守望者的逃离](https://www.luogu.com.cn/problem/P1095)

算法：贪心：

分析：一步步贪心，首先枚举每秒钟 $i$，如果闪烁法术条件，就累加闪烁距离；否则累加跑步距离并恢复魔法值，最后在闪烁和跑步距离中取最大值，作为时间为 $i$ 时守望者能走的最远距离，如果途中逃离了荒岛，直接输出 `Yes` 和最少秒数，否则等到 $t$ 次循环后输出 `No` 和最远距离。
```cpp
#include<cstdio>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<3)+(x<<1)+(s-48);
		s=getchar();
	}
	return x*f;
}
int m,s,t;
int dis,dis2;
int max(int x,int y)
{
	return x>y?x:y;
}
int main()
{
	int i;
	m=read();
	s=read();
	t=read();
	for(i=1;i<=t;++i)
	{
		dis+=17;
		if(m>=10)
		{
			m-=10;
			dis2+=60;
		}
		else m+=4;
		dis=max(dis,dis2);
		if(dis>=s)
		{
			printf("Yes\n%d",i);
			return 0;
		}
	}
	printf("No\n%d",dis);
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
即用魔法又正常走路是这道题的主要策略。

设置两个人跑步，第一个人正常走路，另一人使用魔法，在某一时间点时，第二个人超过了第一个人，第一个人就重新开始跑步，但这次使用第二个人的方法直到原来的时间点，如果第二个人追不上第一个人，第一个人坚持原来的方法，直到第二人追上第一人，就停止了。

---
### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

int m, s, t, x = 0, y = 0;

int main() {
	cin >> m >> s >> t;
	for(int i = 1;i<=t;i++){
		x += 17;
		if (m >= 10) {
			m -= 10;
			y += 60;
		} else m += 4;
		x = max(x, y);
		if (x >= s) {
			cout << "Yes" << endl << i << endl;
			return 0;
		}
	}
	cout << "No" << endl << x << endl;
	return 0;
}
```

---

## 作者：Loyal_Soldier (赞：1)

### 思路

这一题我们用变量 $now1$ 表示当前能走的最大的距离，变量 $now2$ 表示当前使用闪烁法术移动的距离，如果当前的魔法值足够使用闪烁法术，则使用闪烁法术，$now2$ 增加 $60$，魔法值减去 $10$，否则我们恢复魔法值，魔法值加 $4$，每次循环 $now1$ 在 $now1+17$ 和 $now2$ 中取最大值。如果当前能逃离荒岛则输出 `Yes` 和当前用的时间，否则输出 `No` 和 $now1$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t;
int now1,now2;
int main(){
	cin>>m>>s>>t;
	for(int i=1;i<=t;i++){
		if(m>=10)//如果当前可以使用闪烁法术
			now2+=60,m-=10;//now2增加60，且魔法值减10
		else
			m+=4;//恢复魔法值
		now1=max(now1+17,now2);//取最大值
		if(now1>=s){//如果能够逃离荒岛
			cout<<"Yes"<<endl<<i;
			return 0;//记得结束程序
		}
	}
	cout<<"No"<<endl<<now1;
	return 0;
}
```

---

## 作者：__Crafty_Wolf__ (赞：1)

### 题目解析
这道题是一道简单的动态规划和贪心算法，他每次移动有两种方法。一种是直接走，恢复魔力值，而是瞬移，减掉魔力值。如果在时间结束后还没有出去，就是为失败。
### 代码
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
const int maxn=1e6+7;
typedef long long ll;//宏定义
ll m,s,t;
int main()
{
	cin>>m>>s>>t;
	ll zoulu=0,shan=0;
	for(ll i=1;i<=t;i++){//枚举时间
		zoulu=zoulu+17;//正常走
		if(m>=10) {//如果魔法值够了就可以使用技能
			shan=shan+60;
			m=m-10;//减去魔力值
		}
		else m=m+4;//不然恢复魔力值
		if(shan>zoulu) zoulu=shan;//如果走比瞬移快就更新
		if(zoulu>=s) {
			cout<<"Yes"<<endl<<i;
			return 0;
		}
	}
	cout<<"No"<<endl<<zoulu;
	return 0;
}
```

---


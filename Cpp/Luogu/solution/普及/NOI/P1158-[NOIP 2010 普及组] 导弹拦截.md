# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# 题解

## 作者：TEoS (赞：146)

  前面有些大佬好像讲得太深奥了，作为蒟蒻我完全看不懂啊，于是我还是以一枚蒟蒻的角度来讲一下吧
  
  思路：
  
  所有的导弹，不是被1号系统拦截就是被2号系统拦截，所以将导弹分成两部分（即被1号系统拦截的部分和被2号系统拦截的部分）进行枚举答案。
  
  因为根据题意，每个系统的半径即为该系统拦截的导弹中距离系统坐标最远的导弹的距离，所以不妨先算出每个导弹距离1号系统的距离，然后以距1号系统的距离进行升序排序。然后从距离1号系统最远的那枚导弹开始，计算出比它距离1号系统的距离远的所有导弹中距离2号系统的距离最远的那个距离（即以它前一枚导弹为1号系统所拦截的最远的导弹时，2号系统的半径），预处理结束后直接进行枚举答案，枚举1号系统所拦截的最远的导弹，然后输出最小的答案即可。
  为了方便代码中所有距离直接用它的平方进行比较
  
  接下来是代码：
  ```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int x11,y11,x22,y22,n,minn=4000010;
struct DI
{
	int d1,d2,i;//d1、d2分别为于1、2号系统的距离，i为该导弹的初始编号
}di[1000010];//导弹的信息
bool cmp(DI a,DI b)
{
	return a.d1<b.d1;
}//不会写重载运算符，只能这样写了，排序比较
int main()
{
	cin>>x11>>y11>>x22>>y22>>n;
	int x[n+5],y[n+5];//存储每枚导弹的坐标
	memset(di,0,sizeof(di));//初始化
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];
		di[i].d1=pow(x[i]-x11,2)+pow(y[i]-y11,2);//计算该枚导弹与1号系统的距离
		di[i].i=i;//存储该枚导弹的初始编号
	}
	sort(di+1,di+n+1,cmp);
	for(int i=n;i>0;i--)
	{
		int a;
		a=pow(x[di[i].i]-x22,2)+pow(y[di[i].i]-y22,2);//计算该枚导弹与2号系统的距离
		di[i].d2=max(a,di[i+1].d2);//比较，若比后面所有导弹的距离都大，则替换
	}
	for(int i=0;i<=n;i++)
	{
		int a;
		a=di[i].d1+di[i+1].d2;//计算以该枚导弹为1号系统拦截的最远导弹所需的代价
		minn=min(a,minn);
	}//枚举答案，取最小值
	cout<<minn;//输出
	return 0;
}
```
变量名比较土请见谅

这估计是最朴素的一篇代码了

---

## 作者：暗ざ之殇 (赞：19)


这个题耗了我好长时间呐QwQ~，看题解好多都是用的DP做，可是我这么蒟肯定是不会DP啦（以后要加强训练啊），所以用了暴力枚举+预处理过的此题！

直接说正解吧：

大体思路：
我们可以先让第一个拦截系统将所有导弹全部拦截，此时的答案就是第一个系统到最远的点的距离，然后依次去掉最远的导弹让第二个拦截系统拦截，同时注意取最小值，然后再输出最小值就好啦；

枚举之前我们可以将每个导弹按照距第一个拦截系统的距离从小到大排个序，这样我们枚举到 i 的话，那么比 i 小的也顺便给覆盖了，也就是$1$ ~ $i-1$我们也顺便覆盖了，所以我们只算第 i 个导弹就行了； 

详细步骤：
1.按照每个导弹到第一个拦截系统的距离$(x-x1)^2+(y-y1)^2$从小到大排序；

2.然后我们枚举 $i$，$i$∈ [1，n）（表示第一个拦截系统能覆盖多少个导弹，也可以理解为最多拦截 i 个导弹），那么此时第一个拦截系统肯定是正好拦截到距离它第 i 远的导弹（比它近的导弹一定也被拦截了），那么此时第一个拦截系统的半径就是距离它第 i 小的导弹的距离；我们只要再找剩下的导弹中距离第二个拦截系统最大的那个导弹的距离作为第二个导弹的半径就好啦；

例如：
![](https://img2018.cnblogs.com/blog/1617486/201906/1617486-20190616100527306-1326777753.png)

此时第一个拦截系统拦截了6个导弹，那么第1~5枚导弹也一定被拦截了（我们已经将导弹按照距第一个拦截系统的距离从小到大排序了），那么此时第一个拦截系统的半径最小就是距离第 i 小的导弹的距离，那么第7，8小的导弹就由第二个拦截系统覆盖，我们再找这两个导弹中距离第二个拦截系统最大的那个作为第二个拦截系统的半径；

当然还有好多技巧都在代码里哦，结合代码认真分析吧：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int read()
{
    char ch=getchar();
    int a=0,x=1;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') x=-x;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        a=(a<<3)+(a<<1)+(ch-'0');
        ch=getchar();
    }
    return a*x;
}
int x1,y11,x2,y2,n,x,y,minx;
int dis2[100001],nxt[100001];      
/*
nxt[i]表示第i枚导弹到第n枚导弹的所有导弹中距离第二个拦截系统的最大距离；
也就是区间[i，n]中距离第二个拦截系统的最大距离，作为第二个拦截系统的半径 
*/
struct dis                                          //存导弹的信息 
{
    int dis1;
    int id;                                         //导弹的编号 
}a[100001];
int cmp1(dis x,dis y)
{
    return x.dis1<y.dis1;                           //从小到大 
}
int main()
{
    x1=read();y11=read();                           //第一个拦截系统的坐标 
    x2=read();y2=read();                            //第二个拦截系统的坐标 
    n=read();
    for(int i=1;i<=n;i++)
    {
        x=read();y=read();                          //每个导弹的坐标 
        a[i].dis1=(x-x1)*(x-x1)+(y-y11)*(y-y11);    //导弹距离第一个拦截系统的距离 
        a[i].id=i;                                  //第i个导弹 
        dis2[i]=(x-x2)*(x-x2)+(y-y2)*(y-y2);        //导弹距离第二个拦截系统的距离 
    }
    sort(a+1,a+1+n,cmp1);                           //将导弹按照距离第一个拦截系统的距离从小到大排序 
    minx=a[n].dis1;                                 //第一套系统全部拦截                   
    nxt[n]=dis2[a[n].id];                           //最后一颗导弹的nxt值就是它到第二个拦截系统的距离 
    for(int i=n-1;i>=1;i--)                         //预处理nxt的值 
       if(dis2[a[i].id]>nxt[i+1]) nxt[i]=dis2[a[i].id]; //如果当前导弹的距离比后面的区间的nxt大，那么加上这个导弹所组成的新区间的最大值就是当前导弹的距离 
          else nxt[i]=nxt[i+1];                     //如果不如后面的那个区间大，那就继承后面那个区间的最大值 
    for(int i=n-1;i>=1;i--)                         //第一个系统能拦截i个 
        minx=min(minx,a[i].dis1+nxt[i+1]);            
    /*
    a[i].dis1 就是第一个拦截系统的半径
    nxt[i+1]  就是第二个拦截系统的半径 (仔细想想，第一个系统已经拦了i个，后面的[i+1，n]需要第二个系统拦截，就是nxt[i+1] 
    */
    printf("%d",min(minx,nxt[1]));                   //nxt[1]就是第二个拦截系统全部拦截的情况 
    return 0;
}
```


---

## 作者：NewSjf (赞：8)

大家好      
由于我太菜并没有想出正确的贪心策略   
所以我乱搞O(N)过了这道题   
起初我想到了一个贪心策略   
考虑到系统半径应该是由被拦截的最远的导弹决定的
所以考虑每个导弹分别放到系统1和系统2     
取平方和最优的为俩系统工作半径   
仔细一想似乎很有道理还没找到反例    
```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#define MAXN 1000001
#define pi 3.1415926
using namespace std;
struct node
{
	double x,y;
	double friend operator-(const node a,const node b)
	{
		return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
	}
}O1,O2,point;
double MaxDis1,MaxDis2;
int n;
int main()
{
//	freopen("testdata.in","r",stdin);
	cin>>O1.x>>O1.y>>O2.x>>O2.y;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>point.x>>point.y;
		if((O1-point)*(O1-point)+MaxDis2*MaxDis2<(O2-point)*(O2-point)+MaxDis1*MaxDis1) //选谁更优先
		{
			MaxDis1=max(MaxDis1,O1-point);
		}
		else MaxDis2=max(MaxDis2,O2-point);
	}
	cout<<MaxDis1*MaxDis1+MaxDis2*MaxDis2;
}
```
然后得到了60分的好成绩   
蒟蒻想不出什么更好贪心策略,又不想翻题解   
所以我将点的顺序随机打乱,重复跑15遍贪心取最优值  
然后神奇的AC了这道题   
```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 1000001
#define pi 3.1415926
using namespace std;
struct node
{
	double x,y;
	double friend operator-(const node a,const node b)
	{
		return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
	}
}O1,O2,point[MAXN];
double ans=2147483647.0;
int n;
int main()
{
//	freopen("testdata.in","r",stdin);
	ios::sync_with_stdio(false);
	cin>>O1.x>>O1.y>>O2.x>>O2.y;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>point[i].x>>point[i].y;
	}
	for(int t=1;t<=16;t++)  //随机打乱数组贪心50遍 
	{
		random_shuffle(point+1,point+1+n);
		double MaxDis1=0,MaxDis2=0;
		for(int i=1;i<=n;i++)
		{
			if((O1-point[i])*(O1-point[i])+MaxDis2*MaxDis2<(O2-point[i])*(O2-point[i])+MaxDis1*MaxDis1)
			{
				MaxDis1=max(MaxDis1,O1-point[i]);
			}
			else MaxDis2=max(MaxDis2,O2-point[i]);
		}
		if(MaxDis1<MaxDis2)
		{
			swap(MaxDis1,MaxDis2);
			swap(O1,O2);
		}
		if(O1-O2+MaxDis2<=MaxDis2)MaxDis2=0;
		ans=min(ans,MaxDis1*MaxDis1+MaxDis2*MaxDis2);
	}
	cout<<(int)ans<<endl;
}
```
轻微压行一下   
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#define MAXN 1000001
using namespace std;
struct node
{
	double x,y;
	double friend operator-(const node a,const node b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
}O1,O2,point[MAXN];
double ans=2147483647.0;
int n;
int main()
{
	cin>>O1.x>>O1.y>>O2.x>>O2.y>>n;
	for(int i=1;i<=n;i++)cin>>point[i].x>>point[i].y;
	for(int t=1;t<=16;t++)  //随机打乱数组贪心50遍 
	{
		random_shuffle(point+1,point+1+n);
		double MaxDis1=0,MaxDis2=0;
		for(int i=1;i<=n;i++)
		{
			if((O1-point[i])*(O1-point[i])+MaxDis2*MaxDis2<(O2-point[i])*(O2-point[i])+MaxDis1*MaxDis1)
				MaxDis1=max(MaxDis1,O1-point[i]);
			else MaxDis2=max(MaxDis2,O2-point[i]);
		}
		if(MaxDis1<MaxDis2)swap(MaxDis1,MaxDis2),swap(O1,O2);
		if(O1-O2+MaxDis2<=MaxDis2)MaxDis2=0;
		ans=min(ans,MaxDis1*MaxDis1+MaxDis2*MaxDis2);
	}
	cout<<(int)ans<<endl;
}
```
32行代码,400ms跑完,自我感觉还听良好的    
~~乱搞出奇迹~~

---

## 作者：Heavenly_meteorite (赞：7)

这道题整篇题目及附加图都看起来跟**解析几何**有关，不妨往这上面想一想。下文把一个设备的导弹拦截范围抽象成一个圆，把导弹抽象成一个点。

首先，有一个**贪心**的想法，就是让两个圆的半径尽量小（非常明显，过一下步骤，不过多赘述）。那么就只对于一个圆，是不是就只需要看**离圆心距离最远**的那个点，以那个**点到圆心的距离**为半径。可这道题有两个圆，我们的脑瓜只会处理一个圆。那我们就看看算法标签“排序”，是不是我们只需要对每个点到**指定的一个圆**（以下简称圆一）的圆心的距离**从大到小**排序，在循环遍历一下，处理另一个圆（以下简称圆二），当遍历到 $i$ 时 ( $1 <= i <= N$ ) ，让圆一处理第 $i+1$ 个点到第 $N$ 个点，让圆二处理前面的。因为我们按点到圆一的圆心距离排了序的，再结合上面对于一个圆的处理方法，它的半径就是排序后第 $i+1$ 个点到它圆心的距离。而圆二就可以用一个变量去存储前 $i$ 个点到圆二圆心的距离的最大值，它的半径就是这个变量。每次处理时，代价就是半径的平方和，用一个变量来存这些代价的最小值，这就是答案。

其次，计算过程中不是有个点到点的距离吗？公式中有根号，但结果要平方，那就可以在计算的时候就存距离的平方，答案也直接存变量的和不用平方了，就不会有根号带来的**精度问题**。


完整代码奉上。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int num1_x,num2_x,num1_y,num2_y,r,ans=0x3f3f3f3f3f3f3f3f,n;
const int N=1e5+10;
struct Node{//结构体存到两圆心的距离的平方
	int num1,num2;
}a[N];
bool cmp(Node f,Node g){//排序按到圆一的距离的平方从大到小
	return f.num1>g.num1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>num1_x>>num1_y>>num2_x>>num2_y>>n;
	for(int i=1;i<=n;i++){
		int num1,num2;
		cin>>num1>>num2;
		a[i].num1=(num1_x-num1)*(num1_x-num1)+(num1_y-num2)*(num1_y-num2);//两点之间的距离公式是sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))，用勾股定理推的，可以画个平面直角坐标系看。我这里直接平方了，去了根号。
		a[i].num2=(num2_x-num1)*(num2_x-num1)+(num2_y-num2)*(num2_y-num2);//同理
	}
	sort(a+1,a+n+1,cmp);//排序
	ans=a[1].num1;
	for(int i=1;i<=n;i++){
		r=max(r,a[i].num2);//圆二半径的平方
		ans=min(a[i+1].num1/*圆一半径的平方*/+r,ans);
	}
	cout<<ans;//半径平方和的最小值
	return 0;
}
```

---

## 作者：WsW_ (赞：4)

### 思路
对每个导弹计算两个系统拦截它所需要的代价各是多少。  
按照第一个系统拦截代价对导弹升序排序。  
从大到小枚举 $k$，枚举第一个系统要拦截他们所需要的代价。显然排序后，如果第一个系统拦截了第 $k$ 个导弹，那么第 $1\sim k$ 个导弹第一个系统都可以拦下来，所需代价就是拦截第 $k$ 个导弹的代价。第 $k+1 \sim N$ 个导弹都必须由第二个系统拦下来。  
在第 $k+1 \sim N$ 个导弹中，第二个系统拦截所需代价求最大值。这里可以用多种数据结构维护，其中用后缀最大值优化即可 $O(1)$ 求出。  

枚举过程中求出最小答案即可。  

时间复杂度为 $O(n \log n)$，瓶颈在于排序。  


注意 `y1` 是 C++ 非标准库函数，不能在全局定义。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;


pii d[100001];

int cost(int x1,int y1,int x2,int y2){
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}
int main(){
    int n;
    int x1,y1,x2,y2,miin=2e9;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x,y;scanf("%d%d",&x,&y);
		d[i]={cost(x1,y1,x,y),cost(x2,y2,x,y)};
	}
	sort(d+1,d+n+1);
	int max2=0;
	for(int i=n;i>=0;i--){
		miin=min(miin,d[i].first+max2);
		if(d[i].second>max2)max2=d[i].second;
	}
	printf("%d",miin);
	return 0;
}
```

---

## 作者：mcturtle (赞：3)

## 前置知识
当你需要记录用数组记录一个平面坐标时，或者你要将两个数组合并为一个数组时，你该想到 `STL` 里有二元组 `pair`。对了，还有三元组 `tuple`。

还想知道更多？点 [OI-Wiki](https://oi-wiki.org/lang/csl/pair/)。
## 题意
给你 $2$ 套导弹拦截系统，让你去拦截 $N$ 颗导弹，求最小代价和。
## 思路
一眼贪心。

为了好进行排序操作，先用一个二元组数组，$A_i$ 记录第 $i$ 个被 $2$ 颗拦截系统的使用代价。代入公式计算即可。

然后进行排序。

最后用一个 `ans` 记录最小代价值。记录过程是这样的：先用一个临时变量 $tmp$ 存储 $A_1\sim A_i$ 的第 $2$ 项的最大值，再用 `ans` 存储 $tmp$ 与 $A_i$ 的第 $1$ 项之和的最小值。（是不是有点复杂？）

完结撒花。

---

## 作者：wang6w6 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1158)

需要用到[两点间距离公式](https://baike.baidu.com/item/%E4%B8%A4%E7%82%B9%E9%97%B4%E8%B7%9D%E7%A6%BB%E5%85%AC%E5%BC%8F/6773405)。

## 思路

先预处理每个点到两个系统距离，注意距离可以**不用开方**直接相加求出代价，再按到第一个系统的距离**从小到大**排序，这样只需要将剩下的 $n - 1$ 个点到第二个系统的距离取最大值即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
struct stu{
	ll x,y,dis1,dis2;
}d[N];
ll a1,b1,a2,b2,n,x,y,ans,cnt;
ll dist(ll a1,ll b1,ll a2,ll b2){
	return pow(a1-a2,2)+pow(b1-b2,2);//距离公式 
}
bool cmp(stu a,stu b){
	return a.dis1<b.dis1;//dis1从小到大 
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>a1>>b1>>a2>>b2>>n;
	for(ll i=1;i<=n;i++){
		cin>>d[i].x>>d[i].y;
		d[i].dis1=dist(d[i].x,d[i].y,a1,b1);
		d[i].dis2=dist(d[i].x,d[i].y,a2,b2);
	}
	sort(d+1,d+1+n,cmp);
	ans=d[n].dis1;
	for(ll i=n;i>=1;i--){
		ans=min(ans,cnt+d[i].dis1);
		cnt=max(cnt,d[i].dis2);//维护cnt是最大dis2 
	}
	ans=min(ans,cnt);//收尾 
	cout<<ans;
	return 0;
}
```

---

## 作者：Zh_terminal (赞：2)

## 思路
由于导弹必然会被两个导弹拦截系统中的一者拦截，故先考虑其中一个导弹拦截系统（下称“系统一”，另一个导弹系统称为“系统二”）。对于所有的导弹，将它们和系统一的距离进行排序，将临时答案表示为其中的最大值，此时系统一可以拦截所有的导弹，从这个导弹往下枚举，枚举到第 $n$ 个时，系统二需要拦截前 $(n-1)$ 个导弹，因此需要存储当前 $n$ 个导弹离系统二距离的最大值作为系统二的半径，来计算新答案并与旧答案进行比较，取其中最小值。枚举完即可得到答案。

时间复杂度为 $O(n\log{n})$。
## 代码
答案输出半径平方和，所以代码中直接使用距离的平方代替距离本身，避免了使用浮点数。

核心代码：
```cpp
sort(a+1,a+N+1,cmp);
int ans=a[N].d1;
int d=0;
for(int i=N;i>=1;i--){
    d=max(d,a[i].d2);
    int ans2=a[i-1].d1+d;
    ans=min(ans,ans2);
}
```
完整代码：
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#define int long long
using namespace std;
struct missile{
    int d1,d2;
}a[100010]; //使用结构体存储导弹和两个系统之间的距离
double dis(int x1,int y1,int x2,int y2){
    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
} //距离的平方
bool cmp(missile a,missile b){
    return a.d1<b.d1;
}
signed main(){
    int x1,y1,x2,y2,N;
    cin>>x1>>y1>>x2>>y2>>N;
    for(int i=1;i<=N;i++){
        int x,y;
        cin>>x>>y;
        a[i].d1=dis(x1,y1,x,y);
        a[i].d2=dis(x2,y2,x,y);
    }
    sort(a+1,a+N+1,cmp);
    int ans=a[N].d1; //不可写为int ans=a[N].d1+a[N].d2,当只有一个导弹的时候会WA
    int d=0; //存储和系统二之间距离的最大值
    for(int i=N;i>=1;i--){
        d=max(d,a[i].d2); //计算系统二距离，作为当前系统二的半径
        int ans2=a[i-1].d1+d; //计算新答案
        ans=min(ans,ans2);
    }
    cout<<ans<<'\n';
    return 0;
}
```
评测状态：

![](https://cdn.luogu.com.cn/upload/image_hosting/g2rbdt1w.png)

完结撒花awa

---

## 作者：qhr2023 (赞：2)

## solution

upd：被讨论区 hack 了，原因是枚举时要枚举到 0，若枚举到 $1$ 则没有考虑全被二号系统拦截的情况。

这是一道枚举题。

我们用一个二元组存储一颗导弹到两个系统的距离并按到第一个系统的距离排序。因为系统的半径一定是系统到某个导弹的距离，从远到近枚举导弹到第一个系统的距离作为第一个系统的半径，也就是枚举一号系统拦截的最远的导弹，剩下更远的就让二号系统拦截，同时记录答案。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
pair<int, int> a[100005];
int main () {
	int x1, y1, x2, y2, n, ans=1e9;
	cin >> x1 >> y1 >> x2 >> y2 >> n;
	for (int i=1, x, y; i<=n; ++i)
		cin >> x >> y,
		a[i]={(x1-x)*(x1-x)+(y1-y)*(y1-y),
			(x-x2)*(x-x2)+(y-y2)*(y-y2)};
	sort(a+1, a+n+1);
	for (int i=n, r2=0; i>=0; --i) 
		ans=min(ans, a[i].first+r2),
		r2=max(r2, a[i].second);
	cout << ans;
	return 0;
}
```

---

## 作者：_luogu_huowenshuo_ (赞：2)

## 思路
贪心！用公式 $(x1-x)^2+(y1-y)^2$ 把它放进结构体 ```d[i].d1``` ，$(x2-x)^2+(y2-y)^2$ 把它放进结构体 ```d[i].d2```。然后 `sort` 一下让 $r_1{^2}+r_2{^2}$ 最小，然后定义一个结构体数组存 $r_1$ 和 $r_2$，然后从大到小排序，最后 ```ans=min(d[i+1].d1+r2,ans);``` 一下就行了（```ans``` 的值需要很大）。
## 警示后人
用了万能头**不能**用 ```x1,x2,y1,y2``` 之类的变量。所以我才用 ```define```。
## 代码
```cpp
#include<bits/stdc++.h>
#define x1 X1
#define x2 X2
#define y1 Y1
#define y2 Y2
#define int long long
using namespace std;
int x1,x2,y1,y2,r1,r2,ans=0x3ffffffff,n;
struct node
{
	int d1,d2;
}d[114514];
bool cmp(node x,node y)
{
	return x.d1>y.d1;
}
signed main() 
{
	cin >> x1 >> y1 >> x2 >> y2 >> n;
	for(int i=1;i<=n;i++)
	{
		int x,y;
		cin >> x >> y;
		d[i].d1=(x1-x)*(x1-x)+(y1-y)*(y1-y);
		d[i].d2=(x2-x)*(x2-x)+(y2-y)*(y2-y);
	}
	sort(d+1,d+n+1,cmp);
	ans=d[1].d1;
	for(int i=1;i<=n;i++)
	{
		r2=max(r2,d[i].d2);
		ans=min(d[i+1].d1+r2,ans);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Bearbrother18 (赞：1)

### 思路


---


神犇们都用的贪心，但是我发现题目标签是（模拟，枚举，排列）。所以蒟蒻在这里发一篇用排列的题解。

我们可以用 pair 来储存每颗导弹到一号和二号系统的距离。不知道 pair 的点击[这里](https://oi-wiki.org/lang/csl/pair/)。

然后对导弹的距离进行排序，我们按照一号到导弹的距离排序，这样当导弹超出一号系统的最远距离时，我们再用二号系统拦截。这时 pair 的优点就体现出来了，当我们用 sort 给 pair 排序时，它的第二组的顺序是按照第一组数据的顺序排列的。不理解的运行下面的代码就知道了。

```cpp
#include <bits/stdc++.h>

using namespace std;

pair <int,int> a[10];
 
int main(){
    for(int i=1; i<=5; i++){
        cin >> a[i].first >> a[i].second;
    }
    sort(a+1,a+5+1);
    for(int i=1; i<=5; i++){
        cout << a[i].first << "    " << a[i].second << endl;
    }

    return 0;
}
/*
3 8
4 6
7 1
2 9
6 3
*/
```

每次拦截记录最新答案，最后输出即可。


---


### AC代码


---


```cpp
#include <bits/stdc++.h>

using namespace std;

int x1,yl,x2,y2,n,r,ans=1e8;
pair <int,int> a[100005];

int main (){
	cin >> x1 >> yl >> x2 >> y2;
	cin >> n;
	for(int i=1; i<=n; i++){
		int x,y;
		cin >> x >> y;
		a[i]={pow((x1-x),2)+pow((yl-y),2),pow((x-x2),2)+pow((y-y2),2)};
	}
	sort(a+1,a+n+1);//按一号顺序从小到大排列
	for (int i=n; i>=0; i--){
		ans=min(ans,a[i].first+r);
		r=max(r,a[i].second);
	}
	cout << ans;
	
	return 0;//好习惯
}
```

---

## 作者：sdsswyd (赞：0)

[传送门](https://www.luogu.com.cn/problem/P1158)
# 思路
**贪心**。  
出 hack 的来亲自写题解，其实新题解已经提到了，也许有一个会拦截所有导弹，所以不能只从 $n$ 枚举到 $1$，要到 $0$ 才行哟。  
大致说一下，我们假设所有导弹全用 $1$ 号拦截，那么先求出 $1$ 号到各个导弹的距离，不用开方，因为答案要开方（但别忘了求另一套的！），从大到小排序，最大的即 $1$ 的代价，$0$ 即 $2$ 号的代价。  
再从 $n$ 枚举到 $0$，令 $ans$ 为答案，$temp$ 是 $2$ 的代价。不难写出如下伪代码：  

```cpp
ans=min(ans,第i个点到1的距离+temp);
temp=max(temp,第i个点到2的距离);
```
整合一下，代码就非常好写：

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define sq(a,b) (a)*(a)+(b)*(b)
using namespace std;
struct p{
	int s1,s2,x,y;
}a[100005]; 
bool cmp(p aa,p bb){
	return aa.s1<bb.s1;
}
int main(){
	int X1,X2,Y1,Y2,n;
	scanf("%d%d%d%d",&X1,&Y1,&X2,&Y2);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		a[i].s1=sq(a[i].x-X1,a[i].y-Y1);
		a[i].s2=sq(a[i].x-X2,a[i].y-Y2);
	}
	sort(a+1,a+1+n,cmp);
	int ans=0x3f3f3f3f,temp=0;
	for(int i=n;i>=1;i--){
		ans=min(ans,a[i].s1+temp);
		temp=max(temp,a[i].s2);
	}
	ans=min(ans,a[0].s1+temp);
	temp=max(temp,a[1].s2);
	printf("%d",ans);
	return 0;
}
```
## end
hack 数据：[点这里](https://www.luogu.com.cn/discuss/1046028)

---


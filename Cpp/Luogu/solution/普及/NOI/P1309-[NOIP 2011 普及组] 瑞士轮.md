# [NOIP 2011 普及组] 瑞士轮

## 题目背景

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于 1895 年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。

## 题目描述

$2 \times N$ 名编号为 $1\sim 2\times N$ 的选手共进行 $R$ 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第 $1$ 名和第 $2$ 名、第 $3$ 名和第 $4$ 名、……、第 $2\times K - 1 $ 名和第 $2\times K$ 名、……  、第 $2\times N - 1$ 名和第 $2\times N$ 名，各进行一场比赛。每场比赛胜者得 $1$ 分，负者得 $0$ 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在 $R$ 轮比赛过后，排名第 $Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

## 说明/提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/98.png) 

【数据范围】

对于 $30\%$ 的数据，$1\le N\le 100$；

对于 $50\%$ 的数据，$1\le N\le 10000$；

对于 $100\%$ 的数据，$1\le N\le 10^5,1\le R\le 50,1\le Q\le 2\times N,0\le s_1, s_2,\dots,s_{2\times N}\le 10^8,1\le w_1, w_2 , \dots, w_{2\times N}\le 10^8$。

noip2011 普及组第 3 题。

## 样例 #1

### 输入

```
2 4 2 
7 6 6 7 
10 5 20 15 
```

### 输出

```
1
```

# 题解

## 作者：皎月半洒花 (赞：464)

大佬路过，萌新参考。

哎呀，本人第一篇题解啦，如果有误，敬请斧正。

首先来看题（~~没看题的看题去！~~），题面应该不难理解，就是每次相邻分数的两个人根据实力值进行比较，然后输赢分治，不断排序罢了。

“肯定要 `sort` 哇！每次更新分数，然后 `sort` 不就得了？”

其实本质上来说，是可以的，但是 `sort` 会爆炸——时间会爆炸。但是无论时间怎样，那都是 `ccf` 的测试点有没有卡 TLE 的问题而已。但如果真从程序设计本身探讨，`sort` 无疑是一个很浪费的算法。

**一、关于 `sort` 的浪费**
 
首先让我们想想，`sort` 其实就是快速排序，而快速排序其实就是二分的思想（~~胡乱在中间立flag~~）。稳定的话 $O(n \log n)$左右。但是仔细想想此题——每次需要更新的值，都是相邻两个人变化后的分数；而相邻的分数，有些是不会改变位置的，而快速排序则是每次全部修改，必然会造成浪费。

**二、关于归并排序**

然后考虑归并排序：归并排序的思想就是合并两个同序数组的线性方式——每次比较两个有序数组指针指向的值，谁更小（大）则放到 `temp` 数组里，然后删掉进入 `temp` 的元素，指针 `++`。

于是归并排序的代码就不难理解了：

```cpp
void merge(int l,int r){
    if(l==r)return 0;
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid+1,r);
    int i=l,j=mid+1,p=l;
    while(i<=mid&&j<=r){
        if(a[i]>a[j])temp[++p]=a[++i];
        else temp[++p]=a[++j];
	} 
    while(i<=mid)temp[++p]=a[++i];
    while(j<=r)temp[++p]=a[++j];
    for(int i=l;i<=r;i++)a[i]=temp[i];
} 
```

____


在归并排序中，无非就是将“两个有序数组”变成“一个被一分为二的数组（也是两个）”——因为不断二分后，剩下的单个元素必定有序，所以合并相邻相邻元素并使之有序，之后产生两个有序区间等价于合并两个有序数组。但此处仍有值得注意的地方，就是由于两个数组的大小关系具有不确定性，在第一个 `while` 结束后两个原数组中有剩余的元素未参与排序,所以需要再加两个 `while` 来处理剩余元素（此时一定是只会执行其中的一个 `while`，原因不言自明）。最后，**一定要把过程数组 `temp` 覆盖原数组a的值**，保证每次传递到上一级区间（大区间）的数值都有序。

稳定复杂度：$O(n\log n)$ 。

三、关于为何引进归并排序

大家可以发现，归并排序每次的操作只针对相邻区间，或者说合并时是对相邻几个区间的操作，所以这符合只需要修改相邻几个分数的排布状况的题意。即使和快排的复杂度相同，但是省掉了冗杂无用的操作，是一个极大的改良。

最后，附 `ac` 代码：
```cpp
#include<iostream> 
#include<algorithm>    
using namespace std;  
int n,r,q;  
int a[200100],win[200100],lose[200100];  
int s[200100],w[200100];   
bool cmp(int x,int y)  
{  
  if(s[x]==s[y])   return x<y;
  return s[x]>s[y];
}  
void merge()  
{  
  int i,j;  
  i=j=1,a[0]=0;  
  while(i<=win[0] && j<=lose[0])  
    if(cmp(win[i],lose[j]))  
      a[++a[0]]=win[i++];  
    else   
      a[++a[0]]=lose[j++];  
  while(i<=win[0])a[++a[0]]=win[i++];  
  while(j<=lose[0])a[++a[0]]=lose[j++];          
}  
int main()  
{  
  cin>>n>>r>>q;n*=2;  
  for(int i=1;i<=n;i++)a[i]=i;  
  for(int i=1;i<=n;i++)cin>>s[i];  
  for(int i=1;i<=n;i++)cin>>w[i];  
  sort(a+1,a+n+1,cmp);  
  for(int i=1;i<=r;i++)  
    {  
      win[0]=lose[0]=0;  
      for(int j=1;j<=n;j+=2)  
        if(w[a[j]]>w[a[j+1]])  
          {  
            s[a[j]]++;  
            win[++win[0]]=a[j];  
            lose[++lose[0]]=a[j+1];  
          }  
        else  
          {  
            s[a[j+1]]++;  
            win[++win[0]]=a[j+1];  
            lose[++lose[0]]=a[j];  
          }    
      merge();          
    }  
  cout<<a[q];
  return 0;  
}  
```


---

## 作者：List (赞：190)

/\*
每组比赛的胜者：赛前，总分是按降序排的；获胜后都得1分，仍是降序；


每组比赛的负者：赛前，总分是按降序排的；不得分，仍是降序。


先按初始分数排序，然后按分数高低两人一组比赛；


胜者入队A，负者入队B。这样A、B自身仍是有序的；


只需进行合并操作即可，合并操作的复杂度是O(n),而如果用快排其复杂度为O(nlogn)

\*/













```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 200001
typedef  struct Node{
    int grade;
    int num;
}Node;
Node a[maxn];
Node A[100001];
Node B[100001];
int w[maxn];
bool cmp(Node a,Node b)
{
    if(a.grade == b.grade)
        return a.num<b.num;
    return a.grade>b.grade;
}
int n,r,q;
void MergeSort()///把AB归并到a中
{
    int i=1,j=1,k=1;///分别用来在AB以及a中移动的指针
    while(i<=n && j<=n)
    {
        if(A[i].grade > B[j].grade || (A[i].grade == B[j].grade && A[i].num < B[j].num))
        {
            a[k].grade = A[i].grade;
            a[k++].num = A[i++].num;
        }
        else{
            a[k].grade = B[j].grade;
            a[k++].num = B[j++].num;
        }
    }
    while(i<=n)
    {
        a[k].grade = A[i].grade;
        a[k++].num = A[i++].num;
    }
    while(j<=n)
    {
         a[k].grade = B[j].grade;
        a[k++].num = B[j++].num;
    }
}
int main()
{
    cin>>n>>r>>q;///2*n名选手 r轮比赛 关心的名次q
    for(int i=1;i<=2*n;i++)
    {
        cin>>a[i].grade;
        a[i].num=i;
    }
    for(int i=1;i<=2*n;i++)
        cin>>w[i];
    sort(a+1,a+1+2*n,cmp);
    for(int k=1;k<=r;k++)
    {
        int tt=1;
        for(int i=1;i<2*n;i+=2)
        {
            //cout<<w[a[i].num]<<" "<<w[a[i+1].num]<<endl;
            if(w[a[i].num]>w[a[i+1].num])
            {
                A[tt].grade = a[i].grade+1;
                A[tt].num = a[i].num;
                B[tt].grade  =  a[i+1].grade;
                B[tt].num = a[i+1].num;
                tt++;
            }    //a[i].grade++;
            else
            {
                A[tt].grade = a[i+1].grade+1;
                A[tt].num = a[i+1].num;
                B[tt].grade  =  a[i].grade;
                B[tt].num = a[i].num;
                tt++;
            }
        }
        MergeSort();
    }
    cout<<a[q].num<<endl;///排名第q的选手的编号
    return 0;
}

```

---

## 作者：LevenKoko (赞：15)

//用什么排序，为什么用它，下面许多人已经讲清楚了，现在讲一讲合并函数 merge()

//merge函数的作用是：将两个有序的序列合并为一个有序的序列。

//函数参数：merge(first1,last1,first2,last2,result,compare);

//firs1t为第一个容器的首迭代器，last1为第一个容器的末迭代器

//first2为第二个容器的首迭代器，last2为容器的末迭代器，

//result为存放结果的容器，comapre为比较函数（可略写，默认为合并为一个升序序列）。

```cpp
#include<iostream>
#include<algorithm>//merge头文件 
#include<cstdio>
using namespace std;
struct A
{
    int s,p,k;
}a[200005],w[200001],l[200001];
bool cmp(A x,A y)
{
    if(x.s!=y.s) return x.s>y.s;
    else return x.k<y.k;
}
int n,r,q;
int main()
{
    scanf("%d%d%d",&n,&r,&q);
    for(int i=1;i<=2*n;i++)
        scanf("%d",&a[i].s),a[i].k=i;
    for(int i=1;i<=2*n;i++)
        scanf("%d",&a[i].p);
    sort(a+1,a+2*n+1,cmp);//一次快排就好了 ，用多超时（我还曾想过读入优化，结果照样TLE，浪费了我十几分钟。。） 
    for(int i=1;i<=r;i++)
    {
        int lose=0,win=0;
        for(int j=1;j<=2*n;j=j+2)
        {
            if(a[j].p>a[j+1].p) w[++win]=a[j],l[++lose]=a[j+1],w[win].s++;
            else l[++lose]=a[j],w[++win]=a[j+1],w[win].s++;//这里把一个数组分为两个，以便于归并； 
        }
        merge(w+1,w+1+win,l+1,l+1+lose,a+1,cmp);//重点！！！用法见上； 
    }
    cout<<a[q].k;//上面scanf，下面cout自己都感觉奇怪。。 
    return 0;
}
//所以说这道题目就不难啦 

```

---

## 作者：GSQ0829 (赞：10)

### 思路：
因为每一轮胜者的得分只加一，所以如果把每一轮的胜败者分别放入两个数组，那么这两个数组就都是有序的，所以我们就可以归并排序合并。在这里我就用了 ```stable_sort(a, a + n, cmp)```。

---

### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	int d, w, ans;
} a[2000001];

bool cmp(node x, node y) {
	if (x.d != y.d) return x.d > y.d;
	return x.ans < y.ans;
}
int n, r, q;

int main() {
    cin >> n >> r >> q;
    n *= 2;
    for (int i = 0; i < n; i++) {
    	cin >> a[i].d;
    	a[i].ans = i;
    }
    for (int i = 0; i < n; i++) cin >> a[i].w;
    sort(a, a + n, cmp);
    for (int i = 0; i < r; i++) {
    	for (int j = 0; j < n; j += 2) {
    		if (a[j].w > a[j + 1].w) a[j].d++;
    		else a[j + 1].d++;
		}
		stable_sort(a, a + n, cmp);
	}
	cout << a[q - 1].ans + 1;
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：5)

## 思路

常规难度的黄题，简单的模拟即可。\
一、每一次比赛时，确定对阵的双方，比较两人实力值的大小，更牛的人分数加一。\
二、根据题意，给所有人的分数进行降序排序，如果分数相同，按照编号升序排序，此处可能需要使用自定义比较器。\
三、按照要求输出即可。

注意：排序使用 `sort()` 会爆掉，而经过我的不懈尝试，发现使用归并排序 `stable_sort()` 最佳。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

struct Player{
	int s;
	int w;
	int id;
};

Player k[200005];

bool cmp(Player p1, Player p2){ //自定义比较器
	if(p1.s != p2.s) return p1.s > p2.s; //降序排列分数
	else return p1.id < p2.id; //升序排列序号
}
int main(){
	int n, r, q;
	cin >> n >> r >> q;

    for(int i = 1; i <= 2 * n; ++i){
    	cin >> k[i].s;
    	k[i].id = i;
	}
	for(int i = 1; i <= 2 * n; ++i){
	    cin >> k[i].w;
	}
	
	for(int i = 1; i <= r; ++i){
	    stable_sort(k + 1, k + 2 * n + 1, cmp); //排序
		//两两比赛，判断胜负
		for(int j = 1; j <= 2 * n; j += 2){
			//判断哪个人更有石粒
            if(k[j].w > k[j + 1].w) ++k[j].s; 
            else ++k[j + 1].s;
		}
	}
	stable_sort(k + 1, k + 2 * n + 1, cmp); //由于又经过了一次比赛，需要排序后再输出
	cout << k[q].id;
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：3)

## Solution

首先会想到暴力模拟，模拟 $r$ 轮，每轮去处理相邻两个选手的分数，然后再排序一遍，但是使用 `sort` 会超时。那么我们把每轮的胜者放到一个数组，败者放到一个数组，这两个数组是有序的，我们就可以用归并排序合并。最后输出第 $Q$ 选手的编号即可完成。

## Code

这个代码是去年我是个萌新的时候写的，很丑，大佬勿喷。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n,r,q;
struct player
{
	ll no;
	ll score;
	ll w;
};
player a[200005],winner[100005],loser[100005];
bool cmp(player x,player y)
{
	if(x.score!=y.score) return x.score>y.score;
	else return x.no<y.no;
}
void merge() 
{
	ll zhi1=1,zhi2=1,zhi3=1;
	while(zhi2<=n&&zhi3<=n)
	{
		if(cmp(winner[zhi2],loser[zhi3])) 
		{
			a[zhi1++]=winner[zhi2++];
		}
		else 
		{
			a[zhi1++]=loser[zhi3++];
		}
	}
	while(zhi2<=n)
	{
		a[zhi1++]=winner[zhi2++];
	}
	while(zhi3<=n)
	{
		a[zhi1++]=loser[zhi3++];
	}
}
int main()
{
	cin>>n>>r>>q;
	for(ll i=1;i<=n*2;i++)
	{
		cin>>a[i].score;
		a[i].no=i;
	}
	for(ll i=1;i<=n*2;i++) cin>>a[i].w;
	sort(a+1,a+n*2+1,cmp);
	for(ll i=1;i<=r;i++)
	{
		ll zhi1=0,zhi2=0,zhi3=0;
		for(ll i=1;i<=n*2;i+=2)
		{
			if(a[i].w>a[i+1].w)
			{
				a[i].score++;
				winner[++zhi2]=a[i];
				loser[++zhi3]=a[i+1];
			}
			else
			{
				a[i+1].score++;
				winner[++zhi2]=a[i+1];
				loser[++zhi3]=a[i];
			}
		}
		merge();
	}
	cout<<a[q].no<<endl; 
	return 0;
}
```

---

## 作者：ycy1124 (赞：3)

### 题意
有 $2\times n$ 个人参加一场比赛，每个人都有一个初始分数与实力值，一共 $r$ 轮。每一轮比赛选手会先按分数从大到小排序，然后第 $2\times i-1$ 个与第 $2\times i$ 个选手进行比赛，实力值大的胜出，胜出者加一分。求最终第 $q$ 名的选手。
### 思路
首先不难想到模拟，但是每一轮排序的复杂度过大，所以我们考虑其他方法。

不难发现，每一轮会将所有选手分为两类，一种是赢了的，一种是输了的，每种 $n$ 个人。对于这两类人，他们的大小的顺序是不变的，即原来 $a$ 在 $b$ 前面，他们同时输了或赢了，$a$ 还是在 $b$ 前面。根据这个，我们可以将每轮输的和赢得分别按顺序放到两个队列里面，每次新一轮排序就拿两个队列最前面的人比较。接下来就只剩简单的模拟了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct csxs
{
	long long sl,fs,bh;
}xs[210000],xs1[105000],xs2[105000];
bool cmp(csxs a1,csxs a2)
{
	if(a1.fs==a2.fs)
		return a1.bh<a2.bh;
	return a1.fs>a2.fs;
}
int main()
{
	int n,r,q;
	scanf("%d%d%d",&n,&r,&q);
	for(int i=1;i<=n*2;i++)
	{
		scanf("%lld",&xs[i].fs);
	}
	for(int i=1;i<=n*2;i++)
	{
		scanf("%lld",&xs[i].sl);
		xs[i].bh=i;
	}
	sort(xs+1,xs+2*n+1,cmp);
	for(int i=1;i<=r;i++)
	{
		for(int i=1;i<=2*n;i+=2)
		{
			if(xs[i].sl>xs[i+1].sl)
			{
				xs[i].fs++;
				xs1[(i+1)/2]=xs[i];
				xs2[(i+1)/2]=xs[i+1];
			}
			else
			{
				xs[i+1].fs++;
				xs1[(i+1)/2]=xs[i+1];
				xs2[(i+1)/2]=xs[i];
			}
		}
		int x1=1,x2=1;
		while(x1<=n||x2<=n)
		{
			if(x1>n)
			{
				while(x2<=n)
				{
					xs[x1+x2-1]=xs2[x2];
					x2++;
				}
			}
			else if(x2>n)
			{
				while(x1<=n)
				{
					xs[x1+x2-1]=xs1[x1];
					x1++;
				}
			}
			else if(xs1[x1].fs>xs2[x2].fs)
			{
				xs[x1+x2-1]=xs1[x1];
				x1++;
			}
			else if(xs1[x1].fs==xs2[x2].fs&&xs1[x1].bh<xs2[x2].bh)
			{
				xs[x1+x2-1]=xs1[x1];
				x1++;
			}
			else
			{
				xs[x1+x2-1]=xs2[x2];
				x2++;
			}
		}
	}
	cout<<xs[q].bh;
	return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/150367308)

---

## 作者：qhr2023 (赞：2)

## solution

模拟题。

按题目要求排序，循环 $r$ 轮，每轮处理相邻两选手分数，然后再排序，但是直接 ```sort``` 会超一点时。我们发现每次更新的都是相邻两个人变化后的分数，这样快排每次重新排序会有很大浪费，而这个过程很符合归并排序，所以手写归并排序，或用 ```merge``` 归并两个序列。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, r, q;
struct node {
	int s, w, id;
} a[200005], b[200005],c[200005];
bool cmp (node a, node b) {
	if (a.s!=b.s)
		return a.s>b.s;
	return a.id<b.id;
}
int main () {
	cin >> n >> r >> q;
	for (int i=1; i<=2*n; a[i].id=i, i++)
		cin >> a[i].s;
	for (int i=1; i<=2*n; ++i)
		cin >> a[i].w;
	for (sort(a+1, a+n+n+1, cmp); r--; merge(b+1, b+n+1, c+1, c+n+1, a+1, cmp))
		for (int i=1, j=1; i<=2*n; ++j, i+=2) 
			if (a[i].w>a[i+1].w) 
				a[i].s++,
				b[j]=a[i],
				c[j]=a[i+1];
			else	
				a[i+1].s++,
				b[j]=a[i+1],
				c[j]=a[i];
	cout << a[q].id;
	return 0;
}
```

---

## 作者：zsq9 (赞：2)

[AC 记录](https://www.luogu.com.cn/record/197499052)

## 题目大意

$2 \times N$ 选手共进行 $R$ 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前，每次比赛是 $2N-1$ 与 $2N$ 位打比赛给定每个选手的初始分数及其实力值，计算在 $R$ 轮比赛过后，排名第 $Q$ 的选手编号是多少。选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

## 思路

按照题目模拟，每次比赛每次相邻分数的两个人根据实力值进行比较，比赛结束后排序，我一下就想到了 sort 但是，
![](https://cdn.luogu.com.cn/upload/image_hosting/uswt774e.png)

翻了一下质料原来有个 **stable\_sort** 归并排序，改了一下，但是又，
![](https://cdn.luogu.com.cn/upload/image_hosting/cm4yezuv.png)

仔细一看原来 cmp 顺序写错了改了一下终于 AC 了。
![](https://cdn.luogu.com.cn/upload/image_hosting/2cnojvqq.png)

## sort 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c;
struct sb{
	long long c,s,x;
}d[200005];
bool cmp(sb a,sb b){
	if(a.c==b.c)return a.x<b.x;
	else return a.c>b.c;
}
int main(){
	cin>>a>>b>>c;
	for(int i=1;i<=a*2;i++){
		cin>>d[i].c;
		d[i].x=i;
	}
	for(int i=1;i<=a*2;i++){
		cin>>d[i].s;
	}
	sort(d+1,d+1+a*2,cmp);
	for(int i=1;i<=b;i++){
		for(int j=1;j<=a*2;j+=2)
			if(d[j].s>d[j+1].s)d[j].c++;
			else d[j+1].c++;
	sort(d+1,d+1+a*2,cmp); 
	}
	cout<<d[c].x;
return 0;
}
/*
2 6 2
9 10 10 8
5 15 20 25
*/
```

## stable\_sort 但是 cmp 错了

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c;
struct sb{
	long long c,s,x;
}d[200005];
bool cmp(sb a,sb b){
	if(a.c==b.c)return a.x<b.x;
	else return a.c>b.c;
}
int main(){
ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>a>>b>>c;
	for(int i=1;i<=a*2;i++){
		cin>>d[i].c;
		d[i].x=i;
	}
	for(int i=1;i<=a*2;i++){
		cin>>d[i].s;
	}
	stable_sort(d+1,d+1+a*2,cmp);
	for(int i=1;i<=b;i++){
		for(int j=1;j<=a*2;j+=2)
			if(d[j].s>d[j+1].s)d[j].c++;
			else d[j+1].c++;
		stable_sort(d+1,d+1+a*2,cmp); 
	}
	cout<<d[c].x;
return 0;
}
/*
2 6 2
9 10 10 8
5 15 20 25
*/
```

## 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
struct opzc{
	int c,s,x;
}d[200005];
bool cmp(opzc a,opzc b){
	if(a.c!=b.c)return a.c>b.c;
	return a.x<b.x;
}
int main(){
ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>a>>b>>c;
	for(int i=1;i<=a*2;i++){
		cin>>d[i].c;
		d[i].x=i;
	}
	for(int i=1;i<=a*2;i++){
		cin>>d[i].s;
	}
	stable_sort(d+1,d+1+a*2,cmp);
	for(int i=1;i<=b;i++){
		for(int j=1;j<=a*2;j+=2)
			if(d[j].s>d[j+1].s)d[j].c++;
			else d[j+1].c++;
		stable_sort(d+1,d+1+a*2,cmp); 
	}
	cout<<d[c].x;
return 0;
}
/*
2 6 2
9 10 10 8
5 15 20 25
*/
```

---

## 作者：WsW_ (赞：2)

### 思路
类似于 [P2827 [NOIP2016 提高组] 蚯蚓](https://www.luogu.com.cn/problem/P2827)。  
根据题目模拟即可，难点在于每一轮都要进行一次排序，如果直接使用快速排序或者归并排序会超时。  

首先一开始要排序，直接使用快速排序或者归并排序即可。  
在每一轮过后，可以把所有人分成胜者和败者两类。  
显然，这一轮之前积分比另一个胜者高的胜者，这一轮过后依旧比那个胜者积分高；这一轮之前积分比另一个败者高的败者，这一轮过后依旧比那个败者积分高。  
所以可以维护两个单调的队列，分别存胜者和败者。之后利用归并排序中的合并方法就可以 $O(n)$ 将两个单调的队列合并成一个单调的队列。  

用较少个数的单调队列来维护顺序，和 [P2827 [NOIP2016 提高组] 蚯蚓](https://www.luogu.com.cn/problem/P2827)的思想是一样的。

时间复杂度为 $O(n\log n+nR)$。

---
### 代码
由于使用了 `list` 这一常数极大的容器，而且本身的写法常数也很大，所以在 $0.5s$ 的时限内不能稳定通过。  
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fastIO {
#define BUF_SIZE 100010
    bool IOerror = 0;
    inline char nc() {
        static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
        if(p1 == pend) {
            p1 = buf;
            pend = buf + fread(buf, 1, BUF_SIZE, stdin);
            if(pend == p1) {
                IOerror = 1;
                return -1;
            }
        }
        return *p1++;
    }
    inline bool blank(char ch) {
        return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
    }
    inline void read(int &x) {
        char ch;
        while(blank(ch = nc()));
        if(IOerror)
            return;
        for(x = ch - '0'; (ch = nc()) >= '0' && ch <= '9'; x = x*10 + ch - '0');
    }
#undef BUF_SIZE
};
using namespace fastIO;
inline void write(int X){
    if(X<0){X=~(X-1); putchar('-');}
    if(X>9)write(X/10);
    putchar(X%10+'0');
}

struct node{
    int id,s,w;
};

node a[200003];
list<node>l1,l2;
list<node>::iterator it;
node x,y;
int n,r,t,rn;

inline bool cmp(node X,node Y){
	if(X.s!=Y.s)return X.s>Y.s;
	return X.id<Y.id;
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    read(n);read(r);read(t);
    rn=n;
    n<<=1;
    for(register int i=1;i<=n;i++){
    	read(a[i].s);
        a[i].id=i;
    }
    for(register int i=1;i<=n;i++){
    	read(a[i].w);
    }
    sort(a+1,a+1+n,cmp);
    for(register int i=1;i<=n;i++)l1.push_back(a[i]);
    while(r--){
        for(register int i=1;i<=rn;i++){
            x=l1.front();
            l1.pop_front();
            y=l1.front();
            l1.pop_front();
            if(x.w<y.w)swap(x,y);
            x.s++;
            
            l1.push_back(x);
            l2.push_back(y);
        }
        it=l1.begin();
        while(it!=l1.end()&&!l2.empty()){
        	if(cmp(l2.front(),*it)){
        		l1.insert(it,l2.front());
        		l2.pop_front();
			}
			else it++;
        }
        while(!l2.empty()){
        	l1.push_back(l2.front());
			l2.pop_front();
		}
    }
    it=l1.begin();
    while(--t)it++;
    write((*it).id);
    return 0;
}
```

---

## 作者：lylcpp (赞：0)

## 思路

看了题面之后，我们都能明白，是时候要用排序了，但是一般的排序算法效率太低，所以我们可以使用归并排序。

只不过这个归并排序属于一个~~缩水版~~简单版。

假设有 $2$ 个对手，$a$ 和 $b$，则他们对应的编号为 $i$ 和 $i+1$，每次我们就对 $i$ 和 $i+1$ 进行分类，赢的放左边，输的放右边。

最后在合并时比较，放回原数组。

我们要的答案，就是排完 $m$ 遍序之后的数组中的第 $q$ 个位置。

## 代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>

using namespace std;

int n, r, q;

struct node{
	int id, s, w;
}a[200005], le[200005], ri[200005];
// l:win, r:lose;

bool cmp(node x, node y) {
	if (x.s != y.s) return x.s > y.s;
	return x.id < y.id;
}

void merge_sort() {
	int l_pos = 0, r_pos = 0, a_pos = 1;
	for (int i = 1; i <= 2 * n; i += 2) {
		if (a[i].w < a[i+1].w) {
			a[i+1].s++;
			le[++l_pos] = a[i+1];
			ri[++r_pos] = a[i];
		}
		else if (a[i].w > a[i+1].w) {
			a[i].s++;
			le[++l_pos] = a[i];
			ri[++r_pos] = a[i+1];
		}
	}
	l_pos = 1, r_pos = 1;
	while (l_pos <= n && r_pos <= n) {
		if (cmp(le[l_pos], ri[r_pos])) a[a_pos++] = le[l_pos++];
		else a[a_pos++] = ri[r_pos++];
	}
	while (l_pos <= n) a[a_pos++] = le[l_pos++];
	while (r_pos <= n) a[a_pos++] = ri[r_pos++];
}

int main() {
	scanf("%d%d%d", &n, &r, &q);
	for (int i = 1; i <= 2 * n; i++) {
		scanf("%d", &a[i].s);
		a[i].id = i;
	}
	for (int i = 1; i <= 2 * n; i++) scanf("%d", &a[i].w);
	sort(a + 1, a + 2 * n + 1, cmp);
	while (r--)
		merge_sort();
	printf("%d", a[q].id);
	return 0;
}
``````

---

## 作者：Loyal_Soldier (赞：0)

### 思路
我们用一个结构体存储每个选手的初始分数、实力值以及编号，然后从大到小按分数排序，如果分数一样则编号小的在前，然后我们循环 $R$ 轮，每次进行 $1\sim 2N$ 的循环，每次比较相邻两个人的实力值，实力值大的分数增加一，每个选手比较完再排序一次，最后输出第 $Q$ 名的编号。

注意，本题排序需要比 `sort` 更快的归并排序，手写归并或者使用 `stable_sort` 函数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct t{
	int w,now,id;
}a[200100];//定义结构体数组，其中now表示分数，w表示实力值，id表示编号
bool cmp(t a,t b){//结构体排序函数
	if(a.now!=b.now)
		return a.now>b.now;
	return a.id<b.id;
}
int n,r,q;
int main(){
	cin>>n>>r>>q;
	for(int i=1;i<=n*2;i++){
		cin>>a[i].now;
		a[i].id=i;//记录编号
	}
	for(int i=1;i<=n*2;i++)
		cin>>a[i].w;
	stable_sort(a+1,a+n*2+1,cmp);//排序
	for(int i=1;i<=r;i++){
		for(int j=1;j<=2*n;j+=2){//由于每次需要比较两个人，所以每次j要加二
			if(a[j].w>a[j+1].w)//比较实力值
				a[j].now++;
			else
				a[j+1].now++;
		}
		stable_sort(a+1,a+n*2+1,cmp);//每轮比赛打完都要排序
	}
	cout<<a[q].id;//输出
	return 0;
}
```

---

## 作者：sieve (赞：0)

## 题解：[P1309](https://www.luogu.com.cn/problem/P1309)

## 思路

按照题目模拟，使用结构体储存每个选手的信息。排序时先按照分数多的在前，如果分数一样，则编号小的在前。然后循环 $r$ 轮，然后每次找到排序后相邻的两个人，比较实力，实力大的加一分。完成后继续排序。

不过题目有点卡常，所以使用 `sort` 会超时，需要手写归并排序或使用 `stable_sort`。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int n,r,q;
struct no{
    int id;
    int sl,fen;
}a[N];
bool cmp(no x,no y)
{
    if(x.fen==y.fen)
        return x.id<y.id;
    return x.fen>y.fen;
}
int main()
{
    cin>>n>>r>>q;
    n*=2;
    for(int i=1;i<=n;++i) cin>>a[i].fen;
    for(int i=1;i<=n;++i) a[i].id=i;
    for(int i=1;i<=n;++i) cin>>a[i].sl;
    stable_sort(a+1,a+n+1,cmp);
    while(r--)
    {
        for(int i=1;i<=n/2;++i)
        {
            int x=i*2-1,y=i*2;
            if(a[x].sl>a[y].sl) a[x].fen++;
            else a[y].fen++;
        }
        stable_sort(a+1,a+n+1,cmp);
    }
    stable_sort(a+1,a+n+1,cmp);
    cout<<a[q].id;
    return 0;
}
```

---

## 作者：Tracy_Loght (赞：0)

## 思路：

很容易发现可以打暴力。

> 对于所有的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50 $。

则我们可以写出一个暴力：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct xx{int x,v,b;}; 
int n,m,k;xx o[200001];
int cmp(xx x,xx y){if(x.x==y.x) return x.b<y.b;return x.x>y.x;}
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=2*n;i++) cin>>o[i].x;
	for(int i=1;i<=2*n;i++) cin>>o[i].v;
	for(int i=1;i<=2*n;i++) o[i].b=i;
	for(int i=1;i<=m;i++){
		sort(o+1,o+n+n+1,cmp);
		for(int j=1;j<=2*n;j+=2){
			if(o[j].v<o[j+1].v) o[j+1].x++;
			else o[j].x++;
		}
	}
	sort(o+1,o+n+n+1,cmp);
	cout<<o[k].b;
	return 0;
}
```

会发现有两个点过不了，最大的 $720ms$。

这是由于**常数**大和**时间**只有 $500ms$ 的情况下，这样的排序太慢了，排序需要更加的快捷，建议使用 `stable_sort`。

**注：当前的 $n$ 是总人数。**

---

`stable_sort` 是一个**稳定**的排序算法，排序后保证相同值的元素的相对位置不变。

也就是说，如果有多个相同值的元素，它们在排序后仍然保持原始顺序（大抵就是修改的不多，特别的稳定）。

---

然后加上快读就可以很轻松的跑过了。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct xx{int x,v,b;}; 
int n,m,k;xx o[200001];
int cmp(xx x,xx y){if(x.x==y.x) return x.b<y.b;return x.x>y.x;}
char buf[1<<20],*p1,*p2;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1<<20,stdin), p1 == p2) ? 0 : *p1++)
template<typename T>inline void readT(T &x){//int的快读
    bool f=1;x=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=!f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=(f?x:-x);return;
}
inline void read128(__int128 &x){//int128的快读
    bool f=1;x=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=!f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=(f?x:-x);return;
}
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	readT(n);readT(m);readT(k);
	for(int i=1;i<=2*n;i++) readT(o[i].x);
	for(int i=1;i<=2*n;i++) readT(o[i].v);
	for(int i=1;i<=2*n;i++) o[i].b=i;
	for(int i=1;i<=m;i++){
		std::stable_sort(o+1,o+n+n+1,cmp);//排序
		for(int j=1;j<=2*n;j+=2){
			if(o[j].v<o[j+1].v) o[j+1].x++;//判断每一次排名的改变
			else o[j].x++;
		}
	}
	std::stable_sort(o+1,o+n+n+1,cmp);//最后再排一次
	cout<<o[k].b;//输出
	return 0;
}
```

---

## 作者：songyuchen (赞：0)

具体思路与楼下的差不多，因为每一轮胜者的得分只加一，所以如果把每一轮的胜败者分别放入两个数组，那么这两个数组就都是有序的，所以我们就可以归并排序合并。

但发现楼下的归并排序太繁琐啦，这里来个简单版的，易于理解：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

class PEOPLE//定义人的结构体
{
public:
    int point,w,num;
};

bool operator < (PEOPLE a,PEOPLE b)//重载小于运算符，因为要使用STL中的sort
{
    if (a.point==b.point)
        return a.num<b.num;
    else
        return a.point>b.point;
}

const int maxN=1000001;
const int inf=2147483647;

int n,R,Q;
PEOPLE A[maxN*2];//存放所有人
PEOPLE K1[maxN*2];//每轮后临时存放胜者
PEOPLE K2[maxN*2];//临时存放败者

int main()
{
    cin>>n>>R>>Q;
    for (int i=1;i<=n*2;i++)
        cin>>A[i].point;
    for (int i=1;i<=n*2;i++)
        cin>>A[i].w;
    for (int i=1;i<=n*2;i++)
        A[i].num=i;
    sort(&A[1],&A[2*n+1]);//第一轮前用一边快排
    for (int i=1;i<=R;i++)
    {
        for (int j=1;j<=2*n;j=j+2)
        {
            if (A[j].w>A[j+1].w)
            {
                K1[j/2+1]=A[j];//分别放入两个数组
                K2[j/2+1]=A[j+1];
                K1[j/2+1].point++;
            }
            else
            {
                K1[j/2+1]=A[j+1];
                K2[j/2+1]=A[j];
                K1[j/2+1].point++;
            }
        }
        int j1=1,j2=1;
        for (int j=1;j<=2*n;j++)//归并排序
            if ((j2>n)|| ((j1<=n)&&((K1[j1].point>K2[j2].point)||((K1[j1].point==K2[j2].point)&&(K1[j1].num<K2[j2].num))) )     )
            {
                A[j]=K1[j1];
                j1++;
            }
            else
            {
                A[j]=K2[j2];
                j2++;
            }
    }
    cout<<A[Q].num<<endl;
    return 0;
}
```

---


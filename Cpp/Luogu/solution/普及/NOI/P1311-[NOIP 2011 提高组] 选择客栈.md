# [NOIP 2011 提高组] 选择客栈

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/101.png) 

2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住 $4,5$号客栈的话，$4,5$ 号客栈之间的咖啡店的最低消费是 $4$ ，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

### 数据范围

- 对于 $30\% $ 的数据，有 $n \leq 100$ ；
- 对于 $50\% $ 的数据，有 $n \leq 1\,000$；
- 对于 $100\%$ 的数据，有 $2 \leq n \leq 2 \times 10^5$，$1 \leq k
 \leq 50$，$0 \leq p \leq 100$，$0 \leq b_i \leq 100$。

## 样例 #1

### 输入

```
5 2 3 
0 5 
1 3 
0 2 
1 4 
1 5 
```

### 输出

```
3
```

# 题解

## 作者：ShawnZhou (赞：388)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

暴力好想不好写，正解好写不好想。

刚开始读题的时候总给我一个感觉，那就是k可以不用。因为我们有时根本没必要去关心它的编号具体是什么。后来发现还真是。

如果是暴力枚举客栈的话，不能同时枚举两个客栈，那样会超时，所以只能同时枚举一个。我们枚举第二个客栈，然后用第二个客栈反推出前面的方案数。

思路就是，从1到n枚举，输入color和price的值，我们需要记录一个距离第二个客栈最近的咖啡厅价钱合理的客栈位置，用一个now变量记录。

开三个辅助数组，last[i]表示最后一个以i为颜色的客栈的位置，cnt[i]表示以i为颜色的客栈总数，sum[i]可以看作是一个临时数组，用来存储当前的方案数。

可以这么想，当前枚举到一个客栈i，这个i是第二个客栈，那么显然第一个客栈一定在第二个客栈之前，编号必定是0~i-1之间的一个数。如果我发现枚举的时候在某一个客栈前面有一个价钱合理的咖啡厅，那么在这之前的任何一个同色客栈都是第一个客栈可以选的，那么统计一下数量，这就是当前的方案数。

然后更新last数组，更新ans，让cnt[color]++，这样从左到右地推过来就好了。

这个解法简化于暴力算法，暴力算法要循环三层，一层1客栈，二层2客栈，3层合理的位置，这样做显然不行，而我们做的就是去优化掉两层，而是从枚举2客栈出发推出1客栈的位置和所有可行方案，所以这样做是正确的。最后输出即可。

参考代码：

```cpp
#include <iostream>
#define maxn 200005
using namespace std;
int n,k,p;
int color,price;
int last[maxn];
int sum[maxn];
int cnt[maxn];
int ans = 0;
int now;
int main(){
    cin >> n >> k >> p;
    for (int i=1;i<=n;i++){
        cin >> color >> price;
        if (price <= p)
            now = i;
        if (now >= last[color])
            sum[color] = cnt[color];
        last[color] = i;
        ans += sum[color];
        cnt[color]++;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Shunpower (赞：18)

Fun fact：本题题解区在清理前有 $92$ 篇题解。

因为这道题是经典的一题多解题目，对计数子区间类的问题有重大的启发意义，所以在排除一些故弄玄虚故意复杂化问题的做法后，这篇题解将尽可能多地提供这个题题解区曾经有的不同做法。

那些题解有很多写得几乎使人无法阅读，我加上了自己的思考整理出这篇题解。

## 枚举咖啡店

时间复杂度 $\mathcal O(nk)$，空间复杂度 $\mathcal O(nk)$。

考虑枚举咖啡店，那么问题是同一种住宿方案可能有很多种咖啡店的选择方案，这样就会算重。于是我们不妨钦定一个可行的住宿方案在**最靠左**的咖啡店选择中被计算到。

假设我们枚举的 $b_i\le p$ 的咖啡店是 $i$，上一个满足条件的咖啡店是 $las$（初始设置为 $0$），那么意味着两个人的客栈需要分别在 $(las,i]$ 和 $[i,n]$ 中选择。

因为左边那个人的住宿必须满足这个咖啡店是最靠左的满足条件的咖啡店，右边那个人就没什么限制，只要保证咖啡店在他们中间就行了。

所以直接对所有颜色做前缀和即可。注意要减去两个人同时住在 $i$ 的方案。

```cpp
int n,k,p;
int a[N],b[N];
int pre[N][51],suf[N][51];
int lst;
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>k>>p;
    fr1(i,1,n) cin>>a[i]>>b[i];
    fr1(i,1,n){
        if(b[i]<=p){
            fr1(j,lst+1,i) pre[i][a[j]]++;
            lst=i;
        }
    }
    fr2(i,n,1){
        fr1(j,0,k-1) suf[i][j]=suf[i+1][j];
        suf[i][a[i]]++;
    }
    ll ans=0;
    fr1(i,1,n){
        if(b[i]<=p){
            fr1(j,0,k-1) ans+=pre[i][j]*suf[i][j];
            ans--;
        }
    }
    cout<<ans<<'\n';
    ET;
}
```

## 枚举右边的客栈

时间复杂度 $\mathcal O(n)$，空间复杂度 $\mathcal O(k)$。

考虑枚举右边的客栈，那么我们完全可以维护它及它前面第一个可行的咖啡店，也就是当前最靠右的合法咖啡店。很明显，这个咖啡店及其前面的客栈是可以供左边那个人随意选择的。

那么我们只需维护每种颜色在当前最靠右的合法咖啡店前面有多少种选择就可以了。可以在向右移动该咖啡店的同时维护掉。

注意也要去掉两个人同时住在咖啡店那个客栈的情况。

```cpp
int n,k,p;
int a[N],b[N];
int sum[51];
int lst;
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>k>>p;
    fr1(i,1,n) cin>>a[i]>>b[i];
    ll ans=0;
    fr1(i,1,n){
        if(b[i]<=p){
            fr1(j,lst+1,i) sum[a[j]]++;
            lst=i;
        }
        ans+=sum[a[i]]-(b[i]<=p);
    }
    cout<<ans<<'\n';
    ET;
}
```

## 枚举左边的客栈（二分/双指针）

时间复杂度 $\mathcal O(n)$，空间复杂度 $\mathcal O(n)$。

其实也可以把上面枚举右边客栈的方法倒过来做，但是这里介绍另外一种更自然的想法。我们**先按照颜色拆开，然后每种颜色独立做。**

考虑对于某种颜色枚举左边的客栈，那么显然右边的可选客栈应该是单调的（前一半不合法，后一半合法）。因为只要存在一个合法咖啡店它右边的客栈就全部可选了。

所以找出第一个合法的客栈之后，这个客栈后面的全部同色客栈都可以计入答案。

考虑**我们可以 $\mathcal O(1)$ 地判断一个客栈区间 $[l,r]$ 是否合法**：我们可以维护每个点右边第一个合法咖啡店 $nxt_i$，检验 $nxt_l\le r$ 即可。

于是二分加这个判定即可做到 $\mathcal O(n\log n)$。

也可以使用双指针。显然随着枚举的左边的客栈向右移动，第一个可选的右边的客栈一定也是向后移动的（区间内的咖啡店在越来越少）。那么我们只需要移动右边的客栈这个指针，维护区间是否合法即可。

于是可以做到 $\mathcal O(n)$。

代码写的是双指针。

```cpp
int n,k,p;
int a[N],b[N];
int nxt[N];
vector <int> col[55];
int main(){
#ifdef Shun
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>k>>p;
    fr1(i,1,n) cin>>a[i]>>b[i];
    nxt[n+1]=n+1;
    fr2(i,n,1) {
        if(b[i]<=p) nxt[i]=i;
        else nxt[i]=nxt[i+1];
    }
    fr1(i,0,k-1) col[i].pb(0);
    fr1(i,1,n) col[a[i]].pb(i);
    ll ans=0;
    fr1(i,0,k-1){
        if(col[i].size()<=2) continue; 
        int m=col[i].size()-1;
        int r=0;
        fr1(l,1,m){
            while(nxt[col[i][l]]>col[i][r]||l>r){
                if(r>=m) break;
                r++;
            }
            if(nxt[col[i][l]]<=col[i][r]) ans+=m-r+1-(l==r);
            else break;
        }
    }
    cout<<ans<<'\n';
    ET;
}
```

Bonus：

其实也可以不用这么麻烦。考虑枚举左侧客栈 $i$ 之后，$[nxt_i,n]$ 之间全部的同色点都可以选择，如果我们能够直接查询这中间颜色为 $a_i$ 的点数也做完了。使用前缀和就可以以 $\mathcal O(nk)$ 的空间完成。

事实上可以发现 $nxt_i$ 单调不减，所以用类似双指针的方式扫过去也可以做到线性空间，但是和双指针做法本质上区别不大了。

## 分治

时间复杂度 $\mathcal O(n\log n)$，空间复杂度 $\mathcal O(n\log n+k)$。

数合法子区间数！可以考虑分治。

我们考虑分治区间 $[l,r]$，需要计数跨越 $mid$ 的合法区间数。

考虑左半边 $[l,mid]$ 的最靠右的合法咖啡店 $x$，右半边 $(mid,r]$ 的最靠左的合法咖啡店 $y$。那么考虑只要子区间左半边包含 $x$ 或者子区间右半边包含 $y$ 就一定合法。

可以正向统计，但是不如把不合法的斥掉。可以发现不合法的方案就是左边的客栈选在了 $(x,mid]$，右边的客栈选在了 $(mid,y)$。我们用这一层的总方案数减掉这种方案数就可以了。

注意每种颜色还是要分开统计，以及要处理一下某一半没有合法咖啡店的情况。

注意这里的代码我写成了 $\mathcal O(nk\log n)$，事实上在分治的时候如果只考虑两边存在的颜色而不是扫完所有颜色就可以轻易做到 $\mathcal O(n\log n)$。

```cpp
int n,k,p;
int a[N],b[N];
int lef[51],rig[51];
ll divide(int l,int r){
    if(l==r) return 0;
    ll ans=0;
    int mid=(l+r>>1);
    fr1(i,0,k-1) lef[i]=rig[i]=0;
    fr1(i,l,mid) lef[a[i]]++;
    fr1(i,mid+1,r) rig[a[i]]++;
    fr1(i,0,k-1) ans+=lef[i]*rig[i];
    int x=l-1;
    fr2(i,mid,l){
        if(b[i]<=p){
            x=i;
            break;
        }
    }
    int y=r+1;
    fr1(i,mid+1,r){
        if(b[i]<=p){
            y=i;
            break;
        }
    }
    fr1(i,0,k-1) lef[i]=rig[i]=0;
    fr1(i,x+1,mid) lef[a[i]]++;
    fr1(i,mid+1,y-1) rig[a[i]]++;
    fr1(i,0,k-1) ans-=lef[i]*rig[i];
    ans+=divide(l,mid);
    ans+=divide(mid+1,r);
    return ans;
}
int main(){
#ifdef Shun
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>k>>p;
    fr1(i,1,n) cin>>a[i]>>b[i];
    cout<<divide(1,n)<<'\n';
    ET;
}
```

## 容斥

时间复杂度 $\mathcal O(n)$，空间复杂度 $\mathcal O(n)$。

一个比较厉害的做法。

考虑所有颜色可以产生的所有可能性是 $\sum\limits_{i=0}^{k-1}{cnt_i\choose 2}$，其中 $cnt_i$ 表示第 $i$ 种颜色的出现次数。

然后我们考虑去掉其中不可行的客栈选法。这些客栈选法的共同点是不存在任何 $b_i\le p$ 也就是合法咖啡店在中间。所以我们不妨用合法咖啡店把原序列切开（合法咖啡店所在的客栈就可以看成消失了）成若干段，那么不合法的方案等价于选择一个不跨越段的方案。

所以对于每一段的每一种颜色又统计一次 $\sum\limits_{i=0}^{k-1}{cnt'_i\choose 2}$，其中 $cnt'_i$ 表示第 $i$ 种颜色在这一段的出现次数。把这个从所有可能性中扣掉就可以了。

实现精美一点就可以轻易做到时间和空间都线性了。

```cpp
int n,k,p;
int a[N],b[N];
int sum[51];
ll ans;
ll C(int n){
    if(n<2) return 0;
    return 1ll*n*(n-1)/2;
}
stack <int> st;
int main(){
#ifdef Shun
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>k>>p;
    fr1(i,1,n) cin>>a[i]>>b[i];
    fr1(i,1,n) sum[a[i]]++;
    fr1(i,0,k-1) ans+=C(sum[i]);
    memset(sum,0,sizeof sum);
    fr1(i,1,n){
        if(b[i]>p) sum[a[i]]++,st.push(a[i]);
        if(i==n||b[i]<=p){
            while(!st.empty()){
                ans-=C(sum[st.top()]);
                sum[st.top()]=0;
                st.pop();
            }
        }
    }
    cout<<ans<<'\n';
    ET;
}
```

## 分块

时间复杂度 $\mathcal O(n\sqrt n)$，空间复杂度 $\mathcal O(n)$。

原题解里面有一个分块做法，看似是分块实则不是分块。

考虑分块怎么计数子区间。块内我们可以直接暴力枚举两端，在扫的同时维护区间最小值就可以了，两端合不合法直接看是否 $\le p$ 就好了。时间复杂度 $\mathcal O(nB)$。

考虑怎么统计跨块区间的贡献。考虑枚举两个块 $b_1,b_2$，那么这两个块中间（即 $(b_1,b_2)$）的最小值也可以在维护好块的整体最小值后边扫边知道。假设这个最小值是 $mn$，那么：

- $mn\le p$，这两个块内部可以任选了，直接把两块的大小乘起来就行。
- $mn>p$，说明至少有一边要包含一个 $b_i\le p$ 的咖啡店。我们类似分治地扫一下两块看一下两边至少要取到哪里，把选在那两个位置中间的扣掉就可以了。这一个部分和分治的做法几乎完全一样，可以做到 $\mathcal O(B)$。

所以这部分的时间复杂度 $\mathcal O(\frac{n^2}{B})$。

平衡取 $B=\sqrt n$，就有总时间复杂度 $\mathcal O(n\sqrt n)$ 了。

---

## 作者：Listar (赞：6)

**思路：**
---

将数据分组来处理，将每一个小于 $p$ 值的前后分开处理，每一个最低消费小于等于 $p$ 值的左侧和右侧的数据分为两组：


|客栈编号|**1**|**2**|**3**|**4**|**5**|
|:-:|:-:|:-:|:-:|:-:|:-:|
|色调|0|1|0|1|1|
|最低消费|5|3|2|4|5|

对于最低消费，我们只关心他是否大于 $p$。

从左向右处理，对于第一个没有大于 $p$ 的客栈（即客栈二）。

第一次分组、以客栈二作为分组中心。

将客栈分为三组，第一组是分组中心的前边与上一次分组中心的所有客栈（例子中即为客栈一），第二组是分组的中心（即客栈二），第三组是分组客栈的后边所有客栈（即客栈三、四、五）。

第二次分组，以客栈三作为分组中心。

组一是空组，客栈三之前，客栈二之后不存在客栈。

组二即为客栈三。

组三即为客栈四、五。


为什么要这样分组
---
这样分组有一个显而易见的好处：从前向后分组，分组的情况只与上一组有关，与接下来的无关，可以做到边输入边输出。


计数原则
---


1.  对于组一和组三中的相同颜色客栈，我们可以直接粗暴的把组一中选出来一座，组三中选出来一座进行组合，这样可以保证作为分组中心的客栈一定小于等于 $p$。

2. 对于分组中心与组一，我们把组一的所有与这次分组中心颜色相同的进行组合（可以想一下为什么这样排序不会重复，接下来会解释）。

3. 对于分组中心与组三，我们可以粗暴的把分组中心归为第一组，与计数原则 1 中一起运算。


为什么不会重复
---
对于组一和组三的所有组合均是组一中的元素第一次向后组合，计数原则 1、3 中不会出现重复的情况。

对于计数原则 2 中前一次与后一次的分组中，均没有计算到分组中心，与组内的计算，但是如果再往前越过前一次分组计算，前一次分组计算明确算到了跨越上一次分组中心前后的所有相同元素（包括分组中心与上次分组的组三元素）。


具体实现
---
这里直接给出可读性稍高的 python 代码。


```python
n,k,p=map(int,input().split())
l1=[0]*k        #统计每个颜色数目
l2=[0]*k        #上次分组中心前的所有的元素的个数
line=[0]*k      #统计两组之间的
r=0             #结果累加计算
for i in range(n):
    x,y=map(int,input().split())
    l1[x]+=1            #统计每个颜色的总个数
    line[x]+=1          #统计两次分组中心每个颜色的个数
    r+=l2[x]            #把与上次分组中心前的所有与自身颜色相同的元素与自身组合
    if y>p:continue
    else:
        l2=l1.copy()    #统计分组后，分组中心前中各个颜色元素的个数
        r+=line[x]-1    #分组中心和组一中每个元素的组合
        line=[0]*k      #分组计算后，将之前所有的清零，继续计算所有的分组
print(r)
```

代码解释
---
代码采用边输入边计算的方式。

不断检查输入的第二个值是否大于 $p$，若小于等于 $p$，则作为分组中心进行计算。

对于计数原则 1、3 我们采用统一统计所有分组中的第一组的各个色调的个数，之后与后边颜色相同的进行组合，因为一个颜色输入之后才进行组合，保证了不会重复。

  对于计数原则 2，我们直接在检查到分组中心后，将分组中心与我们统计两个分组中心之间所有相同的颜色的客栈进行组合。

  

---
蒟蒻第一次写题解，如有解释不当，还望指出。

---

## 作者：WsW_ (赞：5)

### 思路
枚举靠左边的那个客栈，考虑对于左边的客栈为 $i$ 时右边客栈有多少种选择。  
发现如果没有咖啡店这个限制，那么答案就是 $i+1\sim n$ 之间有多少个客栈的色调为 $a_i$。这可以通过前缀和快速求出。  
但是有咖啡店这个限制，也就是两个客栈之间至少要有一个咖啡店的消费小于 $p$。我们发现，如果选择在第 $t$ 个咖啡店喝咖啡，那么右边客栈的选择数就是 $t\sim n$ 之间有多少个客栈的色调为 $a_i$。容易发现，越是选择靠左的咖啡店，右边客栈的选择数越多，所以我们直接选择最靠左的咖啡店。  
然后这道题就变成了查询在 $i$ 右边且最靠左的咖啡店位置 $t$ 是多少，以及 $t\sim n$ 之间有多少个客栈色调为 $a_i$。第一个查询可以通过前缀最值求出，第二个查询可以通过前缀和求出。  
注意，两个人不能选择同一个客栈，当 $t=i$ 时第二个查询的区间就变成了 $t+1\sim n$。  

时间复杂度为 $O(nk)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn=2e5+5;
int n,k,p;
ll ans;
int a[maxn],b[maxn];
int sum[maxn][55];
int c[maxn];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>k>>p;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
	
	for(int i=n;i>0;i--)
		for(int j=0;j<k;j++){
			sum[i][j]=sum[i+1][j]+(a[i]==j);
			c[i]=(b[i]<=p?i:c[i+1]);
		}
	
	for(int i=1;i<=n;i++)
		ans+=sum[(c[i]==i?c[i]+1:c[i])][a[i]];//要特判
	
	cout<<ans;
	return 0;
}
```

---

## 作者：__yiLIUyi__ (赞：4)

# 题解：P1311 [NOIP2011 提高组] 选择客栈
[题目传送门](https://www.luogu.com.cn/problem/P1311)
## 简化题意
给出 $n$，$k$，$p$。

共有 $n$ 个数字，编号从 $1$ 到 $n$，并对于每个数给出对应的 $a$ 与 $b$。

然后，要求在 $1$ 到 $n$ 中，找出 $l$，$m$，$r$，使得：
- $l \le m \le r$。
- $a _ l = a _ r$。
- $b _ m < p$。

求符合条件的 $l$，$m$，$r$ 的方案数的个数。
## 大致思路
暴力解法需要三重循环，两个客栈与咖啡厅各需要一层。显然是会超时。我们可以进行如下优化：

每输入一组数，就从当前下标 $i$ 向前遍历。如果找到一个咖啡厅价格符合要求，那么在它之前的所有相同色调的客栈都符合要求。依次递推。

换言之：
- 对于整个数组，在输入时把每一个数作为 $r$。
- 对于每一个 $r$，都向前寻找所有符合条件（即 $b _ m < p$）的 $m$。
- 对于每一个 $m$，都向前寻找所有符合条件（即 $a _ l = a _ r$）的 $l$。

然后将总数相加。这样我们就把三重循环中的两层都优化掉了。其它具体内容放在代码里了。
## 代码实现

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
ll n,k,p,x,y,d,ans,a[200010],b[200010],c[200010];
int main(){
	cin>>n>>k>>p;
	for(ll i=1;i<=n;i++){
		cin>>x>>y;
		if(y<=p) d=i;//更新
		if(d>=a[x])//如果所有相同色调的都在后面
			b[x]=c[x];//那么所有前面的都符合 
		a[x]=i;//否则根据上一次更新
		ans+=b[x];//方案数增加
		c[x]++;
	}cout<<ans;
	return 0;
}
```

---

## 作者：Ray_yi (赞：4)

#### 思路：

看到数据范围就知道，肯定不能暴力，我们要想想其他做法。

由题目可知，要求选两个颜色相同且不超过规定花费的客栈有多少种选择。我们可以建一个类似桶的数组，在每次输入一个客栈时，从当前下标开始，向前遍历，记住当前的下标。

具体看代码注释。
#### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p,t,ans,price,num[110],color[200100];
int main(){
	scanf("%d%d%d",&n,&k,&p);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&color[i],&price);
		if(price<=p){
			for(int j=i;j>t;j--) num[color[j]]++;//从当前下标开始向前遍历 
			t=i;//记住当前的下标 
			ans+=num[color[i]]-1;
		}//不超过规定费用 
		else ans+=num[color[i]];//超过规定费用直接记答案 
		cout<<ans<<endl;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：GSQ0829 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1311#submit)

---
### 思路：
本题要求选两个颜色相同且不超过规定花费的客栈有多少种选择。我们可以建一个桶，在每次输入一个客栈时，从当前下标开始，向前遍历，记住当前的下标即可。

---
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200001;
int a[MAXN], b[MAXN], c[MAXN], n, k, p, x, y, d = 0, ans = 0;

int main() {
	cin >> n >> k >> p;
    for (int i = 1; i <= n; i++) {
		cin >> x >> y;
		if (y <= p) d = i;
		if (d >= a[x]) b[x] = c[x];
		a[x] = i;
		ans += b[x];
		c[x]++;
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：zhengrunzhe (赞：3)

现有题解里有一个$O(nk \log n)$的树状数组做法，还有一个空间复杂度$O(nk)$的，甚至还有$O(n^2 \log n)$然而这种玩意在loj的加强数据肯定过不去的，这里提供一个时间复杂度$O(n \log n)$，空间复杂度$O(n)$的高效做法，并且肯定能说得清楚，希望通过

首先由于全局的$p$都是一个同一个，很容易地就能想到把消费$<=p$的客栈的权值设为1然后做个前缀和记作$sum$

然后因为住宿的条件包含两个客栈颜色相同，自然想到把同个颜色的所有客栈编号装在一起，所以就开$k$个$vector$记作$v[]$，$v[c]$表示所有颜色为c的客栈编号的集合，比如$v[1]=\left \{1,7,8 \right \}$表示客栈$1,7,8$颜色为1，注意这个vector是按升序排序的，在读入时插入即可

然后我们来考虑如何统计答案，对于两个颜色相同的客栈$l,r$，如果$[l,r]$中有消费$<=p$的，那么就是$[l,r]$的权值和$>0$，即$sum[r]-sum[l-1]>0$

我们不妨只考虑$j<i$的情况，然后对每个i统计有多少个j满足条件，就能不重不漏地得到答案，根据上面的描述，我们可以写出偏序组:

$$1.col[j]=col[i]$$

$$2.sum[j]<sum[i]$$

$$3.j<i$$

然后这是一个三维偏序，乍一看没法写，但由于我们把$col$相同的装在同一个$vector$里$(v[col])$，也就是我们只要在$v[col]$内进行统计就能满足第一维限制，所以就转化成了$2.3.$的二维偏序问题，观察发现这显然是个正序对问题，然后直接上树状数组维护即可
```cpp
#include<cstdio>
#include<vector>
using std::vector;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool f=0;
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
const int N=2e5+10,K=60;
typedef long long ll;
typedef vector<int>vit;
ll ans;
vit v[K];
int n,k,p,sum[N];
class Binary_Indexed_Tree
{
	private:
		int t[N];
		inline const int lowbit(int x)
		{
			return x&-x;
		}
	public:
		inline const void update(int x,int y)
		{
			for (;x<=n;x+=lowbit(x))t[x]+=y;
		}
		inline const int query(int x)
		{
			int sum=0;
			for (;x;x-=lowbit(x))sum+=t[x];
			return sum;
		}
}bit;
inline const ll query(int c)
{
	ll cnt=0;
	for (vit::iterator i=v[c].begin();i!=v[c].end();i++)
	{
		if (i!=v[c].begin())cnt+=bit.query(sum[*i]-1);
		bit.update(sum[*i-1],1);
	}
	for (vit::iterator i=v[c].begin();i!=v[c].end();i++)
		bit.update(sum[*i-1],-1);
	return cnt;
}
int main()
{
	read(n);read(k);read(p);
	for (int c,w,i=1;i<=n;i++)
		read(c),read(w),
		v[++c].push_back(i),
		sum[i]=sum[i-1]+(w<=p);
	for (int i=0;i<=n;i++)sum[i]++;n++;
	for (int i=1;i<=k;i++)ans+=query(i);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Ngo123 (赞：2)

在本题中，我们要计算可选的住宿方案的总数。

对于这个问题，我们可以考虑左右两个端点。我们每次枚举右端点，然后将所有符合要求的左端点的方案加进答案。

根据题目给的小数据，总装饰色调种类 $k \le 50$。因此我们可以直接开一个数组 $sum$，对于每种装饰颜色且满足要求的旅店进行统计。

统计方式是这样的：

若当前旅店的咖啡店最低消费 $b_{i}$ 大于能接受的最低消费的最高值 $p$，此时这个旅店可以作为右端点，但不参与合法数量统计。

若当前旅店的咖啡店最低消费 $b_{i}$ 符合题目要求，此时这个旅店既可以作为右端点，也参与合法数量统计。

我是使用两个指针进行统计和计算方案的操作。

本题代码时间复杂度为 $O(n)$。

以下是我的代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int n,k,p,sum[55],a[N],b[N];
long long ans;
int main()
{
    cin>>n>>k>>p;
    for(int i = 1;i<=n;i++) cin>>a[i]>>b[i];
    for(int i = 1,j = 0;i<=n;i++)
    {
        if(b[i] > p) ans += sum[a[i]];
        else
        {
            while(j < i)
            {
                j++;
                sum[a[j]]++;
            }
            ans += sum[a[i]]-1;
        }
    }
    cout << ans << endl;
	return 0;
}
```

---

## 作者：JCT_addyi (赞：1)

### 题目大意：

有 $n$ 个旅店，一共有 $k$ 种颜色，预算为 $p$ ，给你每一个客栈的颜色和这个客栈的咖啡店的价钱，要住在相同颜色的两家客栈，并且这两家客栈之间的咖啡店费用不超过预算，相当于小于等于预算，包含这两家客栈的咖啡店，求方案数。

### 思路：

用桶标记每个客栈的方案数，用一个变量来标记上一个不超预算的咖啡店，再遍历这个区间。

### 代码如下：

详细看代码注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p,t,ans,pr,m[110],c[200100];
int main(){
	cin>>n>>k>>p;
	for(int i=1;i<=n;i++){
		cin>>c[i]>>pr;//输入颜色和价钱，因为价钱只用判断所以只用一个变量 
		if(pr<=p){//如果当前客栈的咖啡店的价钱不超过预算 
			for(int j=i;j>t;j--) m[c[j]]++;//标记 
			t=i;//标记第i个不超预算的咖啡店 
			ans+=m[c[i]]-1;//加上当前客栈的方案数 
		}
		else ans+=m[c[i]];//加上与其他客栈搭配的方案数 
	}
	cout<<ans;
	return 0;
}
```

谢谢大家！

---

## 作者：bravo11111111 (赞：1)

## 解题想法
这道题我们如果枚举每两个客栈，时间肯定是要超的。但这到题要求选两个颜色相同的客栈，我们可以枚举每种颜色的客栈,时间复杂度为 $O(k\times n)$。
## 解题思路
我们不难可以发现，当两个颜色相同客栈中间，有满足最小花费小于 $p$ 的客栈时，那么两个客栈中后面的那个客栈一定能和前面的那个客栈及其他前面所有与他颜色相同客栈配对。了解这点，就可以做出这道题。
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long  long n, k,p,a[200005],ans,b[200005],sum,num,ma,x,nu;
int main(){
	scanf("%d%d%d",&n,&k,&p);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);
	for(int i=0;i<k;i++){//枚举颜色
	long long t=0,answer=0,mi=1e18;
		for(int j=1;j<=n;j++)
		{
			mi=min(mi,b[j]);
			if(a[j]==i){//颜色相同
				t++;
				if(t>1)
					if(mi<=p)
						answer=t-1;//更新最前面可以与它配对的客栈
					mi=b[j];
					ans+=answer;//相加
				}
			}
		}
	printf("%d",ans);
	return 0;
	}
```

---

## 作者：chinazhanghaoxun (赞：1)

## 思路

这道题思路很难想，但是代码很简洁。考虑到如果第 $i$ 个客栈作为第二个客栈，那么第一个客栈 $x$ 和可行的咖啡馆 $y$ 一定满足 $x\le y\le i$。所以我们可以在输入的同时就统计以当前客栈为第二个客栈的个数，最后相加即可。

## 实现

假设我们目前输入到第 $i$ 个客栈，只要前面任何一个色调相同的客栈和这个客栈中间能找到一个 $b_j\le p$ 的咖啡馆，这一方案就是成立的。而 $p$ 是题目输入给定的，不会随我们选择哪两个客栈而改变。所以我们需要让这个咖啡馆的位置尽可能靠近 $i$，这样才能让总方案数最大。

那么我们就记录一个变量 $lst$，表示最靠近 $i$ 的 $b_{lst}\le p$ 的位置。接下来就加上所有在 $lst$ 前的同色客栈的个数即可。创建几个数组，每次输入时更新一下即可。这样讲有点抽象，看代码的注释吧。

## 代码+注释

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,k,p;
int lst[N];//lst[i]：上一个i客栈的位置
int cnt[N];//cnt[i]：当前位置前色调为i的客栈的个数
int ans[N];//ans[i]：记录i色调客栈的答案，具体使用方法看主函数 
int ANS;//记录最终答案 
int main(){
	cin>>n>>k>>p;
	int lst_kf=0; //记录离第二个客栈最近的可行咖啡馆的位置
	for(int i=1;i<=n;i++){ //在输入的同时寻找以它为第二个旅馆的方案数 
		int hotel,price;
		cin>>hotel>>price;
		if(price<=p)
			lst_kf=i;//更新位置
		if(lst[hotel]<=lst_kf){//所有相同颜色的都在这个咖啡馆后面，那么所有前面的都可以与之配对 
			ans[hotel]=cnt[hotel];
		}//否则就还是按照上一次该颜色客栈的个数更新 
		//注意在全部处理完后再更新这次
		lst[hotel]=i;
		ANS+=ans[hotel];
		cnt[hotel]++;
	}
	cout<<ANS;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

前缀和优化枚举。

对于两个客栈，我们枚举右边的客栈。维护 $C_{i, j}$ 表示前 $i$ 个客栈中第 $j$ 个颜色的客栈有多少家，记录 $lst$ 表示上一个最低消费不超过 $p$ 的客栈，那么颜色是 $a$ 的客栈 $i$ 作为右客栈的贡献就是 $C_{lst, a}$，对于 $lst=i$ 的情况答案要减一。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, p, c[200005][55];
long long ans;
int main () {
	cin >> n >> k >> p;
	for (int lst=0, i=1, a, b; i<=n; ++i) {
		cin >> a >> b;
		for (int j=0; j<k; ++j)
			c[i][j]=c[i-1][j];
		c[i][a]++;
		if (b<=p)
			lst=i;
		ans+=c[lst][a]-(lst==i);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Leo_Anderson (赞：1)

# P1311 [NOIP2011 提高组] 选择客栈

**2023/11/17  Fri.**

- - - -

### [-原题链接-](https://www.luogu.com.cn/problem/P1311)
  
### [-题解原文-](https://www.luogu.com.cn/article/lwo348oa)

- - - -

## 题意简述

有 $N$ 个点，包含 $K$ 种颜色，所能接受的最大价格为 $P$。  
$\left( 2 \le N \le 2 \times 10^{5} , 1 \le K \le 50 , 1 \le P \le 100 \right) $  
其中第 $i$ 个点的颜色为 $ a_i \left( a_i \in \left[ 0,K-1 \right] \right) $，价格为 $ b_i \left( b_i \in \left[ 0,100 \right] \right) $。  
请问存在多少个点对 $ \left( x,y \right) \left( 1 \le x<y \le N \right) $，使得 $ a_x = a_y $ 并且 $ \exists b_i \le P , i \in \left[ x,y \right]$。  

- - - -

## 题目分析   

### 思路  

1. 由于点对 $ \left( x,y \right) $ 必须符合 $ a_x = a_y $，所以可以将 $K$ 种颜色拆开处理（具体表现为代码均使用大小为 $K$ 的数组记录数值)，最后将 $K$ 种颜色的方案数加在一起即为总答案方案数。  

2. 对于每种颜色的方案数，可以利用递推求得，因此可以在数据读入的时候边读入边处理答案（具体解释见下文做法分析）。  

### 做法分析

因为 ***思路 1***，所以我们将 $K$ 种颜色分开处理。

如下图，  
$[K]$ 表示当前处理中的颜色，  
**黑横线** 代表所有读入的点，  
**红竖线** 代表所有颜色为 $[K]$ 的点，  
**绿竖线** 代表所有价值 $\le P$ 的点。  
（$hav$，$cor$，$ans$ 均为储存用数组，具体作用见下文）  

![](https://cdn.luogu.com.cn/upload/image_hosting/lgrm73uc.png)

然后解释 ***思路 2***。  
对于上图中的每一个合法点（即红色竖线），只需计算它与它之前的合法点的可构成的所有答案点对的数量，然后将每一个点可构成的答案点对的数量求和即为该种颜色的方案数。  
因此我们选择递推求解。  

那么如何求每一个点所拥有的答案点对的数量呢？  

首先定义一下在图中如何判断一个点对是答案点对：  
如果两个**合法点**（红色竖线）间（**包括合法点本身**）存在**至少一个答案点**（绿色竖线，其对应的 $b_i\le P$ ）时，  
那么这两个点所组成的点对即为一个**答案点对**。

首先对于图中第 2、3 个合法点进行分析（每两个合法点间都有一个答案点）。  
我们不难发现合法点 2 可以和它前面的 1 个合法点组成答案数点对，  
![](https://cdn.luogu.com.cn/upload/image_hosting/e2jzhxrw.png)  
因此我们可以得出初步结论：**每一个合法点可构成的答案点对数量即为该点以前所有合法点的数量。**   
- 所以我们使用一个数组 $hav$ 记录当前时刻下对应颜色所拥有的合法点的数量。

同时要注意一点：我们要使用的合法点数量是**不包括当前所处理的合法点**的，所以要在当前点的所有数据处理完后再进行 `hav++`。  

记录一下每个合法点处理时所对应的 $hav$。  
![](https://cdn.luogu.com.cn/upload/image_hosting/14buxrzo.png)  

接着我们对第 4 个合法点进行分析（除与上一个合法点间没有答案点外，与其余合法点间都有至少一个答案点）。
![](https://cdn.luogu.com.cn/upload/image_hosting/01asdbj9.png)  
此时我们发现仅有前 2 个合法点可以和他组成答案点对！因为第 3 个合法点和第 4 个合法点间不存在答案点！  
这个时候答案点对数量与 $hav$ 不相等了。  

我们需要别的方式来计算答案点对数量。   

保险起见我们再对第 6 个合法点分析一下（一般情况）。    
![](https://cdn.luogu.com.cn/upload/image_hosting/0tkdf4ek.png)
这时我们发现虽然合法点 3、4 间不存在答案点，但是由于合法点 4、5 间存在一个答案点，所以合法点 3、4 也成为了可以与合法点 6 组成答案点对的点。

不难发现这其中存在一个单调不减的答案点对数量。  
- 所以我们还需要一个数组 $cor$ 来记录当前的答案点对数量。

![](https://cdn.luogu.com.cn/upload/image_hosting/okp01i3y.png)  
通过观察 $hav$ 和 $cor$ 的关系，不难发现特征：  
**当处理遇到一个答案点时，就将下一个合法点的 $cor$ 更新为其对应的 $hav$。**  
**若从前一个合法点处理到当前合法点的过程中没有出现过答案点，那么当前点的 $cor$ 值继承上一个合法点的 $cor$。**  
- 因此我们可以用一个变量 $flag$ 记录离当前处理的合法点最近的一个答案点的位置，用数组 $lst$ 储存每种颜色的最后一个合法点的位置。  
若 $ lst_{[K]} \le flag $，则上一个合法点与当前处理的合法点间存在答案点。  

最后就是记录答案的 $ans$ 数组。  

 - 由于我们已经将答案点对数量存进了 $cor$ 数组里，所以新的 $ans$ 即为 $ ans + cor_{[K]} $。

得到最后的状态图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/q2iopnzy.png)  
~~经人工暴力查数量发现，最后的 ans 和当前颜色 [K] 所拥有的所有答案点对数量一致，算法成立。~~  

因为边读入边处理，所以每一次处理均为 $O(1)$，总复杂度为 $O(N)$。   
最后对所有颜色方案数求和复杂度为 $O(K)$，但 $1 \le K \le 50$，故求和时间可以省略。   
因此该做法时间复杂度 $O(N)$，做法可行。 

***~~（另：你要是想在处理的时候就把总方案数加起来以节约掉 ans 数组也不是不行）~~***

- - - -

## 主要解答过程

对于当前读入：  
1. 对于当前点 $i$，读入其颜色 $a_i$ 和价格 $b_i$。  
2. 如果 $b_i\le P$，则将 $flag$ 更新为 $i$。  
3. 如果 $lst_{a_i}\le flag$，并且上一个合法点是存在的 $\left( lst_{a_i} \ne 0 \right)$，则将 $cor_{a_i}$ 更新为 $hav_{a_i}$。  
4. $ans_{a_i}$ 更新为 $ ans_{a_i} + cor_{a_i}$。  
5. $lst_{a_i}$ 更新为 $i$。  
6. $hav_{a_i}$ 自增 $1$。  

- - - -

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define lli long long
//#define int long long
#define MAXK 55

int  N,K,P; 
int  hav [MAXK];
int  cor [MAXK];
int  flag;
int  lst [MAXK];
int  ans [MAXK];
int  outnum=0;
//---------------------
signed main(){//注：signed == int，均表示有符号整数。
	cin>>N>>K>>P;

	for(int i=1;i<=N;i++){
		int a,b;scanf("%d%d",&a,&b);
		
		if(b<=P)flag=i;
		if(lst[a]<=flag && lst[a]!=0)cor[a]=hav[a];
		
		ans[a]+=cor[a];
		
		lst[a]=i;
		hav[a]++;
	}
	
	for(int i=0;i<K;i++)
		outnum+=ans[i];
	
	cout<<outnum<<"\n";
	return 0;
}

```
**[100pts，AC.](https://www.luogu.com.cn/record/163306438)**

---

## 作者：崔泽禹 (赞：0)

# [P1311 NOIP2011 提高组 选择客栈](https://www.luogu.com.cn/problem/P1311)题解

## 解题思路

前缀和处理每个客栈间合理的咖啡店的个数，按照颜色将客栈编号，在每个颜色中，用**左指针**遍历这个颜色中的所有客栈编号，用**右指针**找到相同颜色中第一个合理的客栈，于是在这个颜色中，之后的所有客栈都是合法的。

## 核心代码

1. 维护数组

    - 用 `a[K][N]` 维护相同颜色 $k_i$ 的客栈编号。

    - 用 `t[K]` 维护相同颜色 $k_i$ 的客栈数量。

    ```cpp
    for (int i = 1; i <= n; i++) {
        a[hc][t[hc]] = i;
        t[hc]++;
    }
    ```

2. 前缀和

    - 要预先处理出 `pre[N]`，为后面判断编号为 $[l,r]$ 间有没有可以去的咖啡店，即 `pre[tr] - pre[tl - 1]`。

    ```cpp
    for (int i = 1; i <= n; i++) {
        if (hw <= p) {
            pre[i]++;
        }
        pre[i] = pre[i - 1] + pre[i];
    }
    ```

3. 双指针

    - 判断这一个颜色中所有的客栈组合间是否有可以去的咖啡店，即 `pre[ a[i][t[i] - 1] ] - pre[ a[i][l] - 1 ]`。

    - 遍历相同颜色客栈中的全部客栈编号，固定 `l` 指针，找到第一个合法的 `r` 指针，不难发现：**找到第一个合法的客栈组合后，固定“左客栈”，“右客栈”（包含）后的所有客栈都符合要求**。

    - 答案增加 `t[i] - r`。

   示例：

   ![img1](https://cdn.luogu.com.cn/upload/pic/101.png)

   用 `a[K][N]` 维护后：

   ![img2](https://cdn.luogu.com.cn/upload/image_hosting/wnw4uh6x.png)

   双指针 `l` 与 `r` 遍历，找到第一个，之后的也都符合要求：

   ![img3](https://cdn.luogu.com.cn/upload/image_hosting/wp4dn6uc.png)

    ```cpp
    for (int i = 0; i < k; i++) {
        if (t[i] >= 2) {
            or (int l = 0, r; l < t[i] - 1; l++) {
                r = l + 1;
                if (pre[ a[i][t[i] - 1] ] - pre[ a[i][l] - 1 ]) {
                    while (pre[tr] - pre[tl - 1] == 0) {
                        r++;
                    }
                    ans += t[i] - r;
                }
            }
        }
    }
    ```

## 完整代码

```cpp
#include <bits/stdc++.h>
#define tl a[i][l]
#define tr a[i][r]
#define hc h[i].c
#define hw h[i].w
using namespace std;
const int N = 2e5 + 5;
struct Node {
    int c, w;
};
Node h[N];
int n, k, p;
int a[55][N];
int t[55];
int pre[N] = {0};
long long ans = 0;
int main() {
    cin >> n >> k >> p;
    for (int i = 1; i <= n; i++) {
        cin >> hc >> hw;
    }
    for (int i = 1; i <= n; i++) {
        a[hc][t[hc]] = i;
        t[hc]++;
    }
    for (int i = 1; i <= n; i++) {
        if (hw <= p) {
            pre[i]++;
        }
        pre[i] = pre[i - 1] + pre[i];
    }
    for (int i = 0; i < k; i++) {
        if (t[i] >= 2) {
            for (int l = 0, r; l < t[i] - 1; l++) {
                r = l + 1;
                if (pre[ a[i][t[i] - 1] ] - pre[ a[i][l] - 1 ]) {
                    while (pre[tr] - pre[tl - 1] == 0) {
                        r++;
                    }
                    ans += t[i] - r;
                }
            }
        }
    }
    cout << ans;
    return 0;
}
```

---


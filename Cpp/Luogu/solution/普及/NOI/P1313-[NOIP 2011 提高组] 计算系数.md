# [NOIP 2011 提高组] 计算系数

## 题目描述

给定一个多项式 $(by+ax)^k$，请求出多项式展开后 $x^n\times y^m$ 项的系数。

## 说明/提示

【数据范围】

对于 $30\%$ 的数据，有 $ 0\le k\le 10$。

对于 $50\%$ 的数据，有 $ a=1$，$b=1$。

对于 $100\%$ 的数据，有 $0\le k\le 1000$，$0\le n,m\le k$，$n+m=k$，$0\le a,b\le 10^6$。

noip2011 提高组 day2 第 1 题。


## 样例 #1

### 输入

```
1 1 3 1 2
```

### 输出

```
3```

# 题解

## 作者：cheny0604 (赞：136)

大佬们没搞错吧，这题这么难？（快速幂之类的蒟蒻表示完全不会）

看到像这样的多项式，想必都可以想到杨辉三角

1

1 1

1 2 1

1 3 3 1

1 4 6 4 1

……

但这只有~~50分~~

因为啊，a,b可以不是1

这样我们就看一下杨辉三角

举个例子：第3行到第4行

(x^2+2·x·y+y^2)(x+y)

看一下x^2 · y 这一项是怎么来的

是 (x^2 · y)+(2xy · x)=3·x^2·y

就是杨辉三角x[4][2]=x[3][1]·1+x[3][2]·1

当a,b,不为1时呢，相加的两个相的系数乘的便不是1,1 ，而是y的系数与x的系数

既 x[4][2]=x[3][1]·b+x[3][2]·a

可得到递推公式 x[i][j]=x[i-1][j-1]·b+x[i-1][j]·a

假设当a=2,b=3时,杨辉三角为

1

2 3

4 12 9

8 36 54 27

16 96 216 216 81

……

杨辉三角的行数便是(k+1),最后输出的是(m+1)【是y的m次方相】pas:这里数组不能从0开始哈


----------------------------------萌萌哒的分割线----------------------------------



    #include<iostream>
    using namespace std;
    long long x[1010][1010];
    int main()
    {
	    long long a,b,k,n,m;
	    cin>>a>>b>>k>>n>>m;
	    x[1][1]=1;
	    for(int i=2;i<=k+1;i++) for(int j=1;j<=i;j++)
	    x[i][j]=(x[i-1][j-1]*b+x[i-1][j]*a)%10007;
	    cout<<x[k+1][m+1];
	    return 0;
    }
    
13行，可能比较玄学,~~不符合day2第一题~~

---

## 作者：aiyougege (赞：93)

### 计算系数
#### Solution
　　根据二项式定理, 
$$(a+b)^n=\sum_{k=0}^nC_{n}^{k}a^kb^{n-k}$$
那么
$$(ax+by)^k=\sum_{p=0}^kC_{k}^p(ax)^p(by)^{k-p}=\sum_{p=0}^k(C_{k}^pa^pb^{k-p})x^py^{k-p}$$
算$a^n,b^m$需要用快速幂.
- 可以根据组合式的递推公式算组合数.我是这么写的.
$$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$$
- 或者是利用组合数的定义式,但是因为有取余, 所以要用逆元.
$$C_n^m=\frac{n!\mod 10007}{m!(n-m)!\mod 10007}=n!\times [m!(n-m)!]^{-1}\mod 10007$$
其中$[m!(n-m)!]^{-1}$为逆元, 这个可以直接用费马小定理, 正好前面写了快速幂, 岂不是美滋滋.

#### Code
```cpp
#include<cstdio>
#define N 1005
#define mod 10007
using namespace std;

#define int long long
int c[N][N];
int a,b,k,n,m;
int pow(int x,int y){
    int ans=1,pas=x;
    while(y){
        if(y&1)ans*=pas%mod,ans%=mod;
        pas=(pas*pas)%mod;
        y>>=1;
    }
    return ans%mod;
}

int dfs(int n,int m){
    if(!m)return c[n][m]=true;if(m==1)return c[n][m]=n;
    if(c[n][m])return c[n][m];
    if(n-m<m)m=n-m;
    return c[n][m]=(dfs(n-1,m)+dfs(n-1,m-1))%mod;
}

main(){
    //freopen("factor.in","r",stdin);
    //freopen("factor.out","w",stdout);
    scanf("%lld%lld%lld%lld%lld",&a,&b,&k,&n,&m);
    c[1][0]=c[1][1]=1;a%=mod;b%=mod;
    int ans=1;
    ans*=(pow(a,n)*pow(b,m))%mod;
    if(n>m)n=m;
    ans*=dfs(k,n)%mod;ans%=mod;
    /*for(int i=1;i<=k;++i){
        for(int j=0;j<=i;++j)
            printf("%d ",c[i][j]);
        printf("\n");
    }*/
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：龙啸空 (赞：48)

这道题我也是~~瞎搞~~十分认真地做才做出来，所以会从头讲一遍我的思路和做题方法

~~对蒟蒻们天然无公害哟~~

下面进入正题


------------

									分割线

------------


# 问题转化

相信大家接到这道题，内心是这样的(蒟佬们跳过)：

- mmp什么鬼题，怎么做？

- 这到底tm什么鬼东西？

- 什么鬼，信息考数学？（chen_zhe:好像信息就是考数学）

(逃 ε=ε=ε=┏(゜ロ゜;)┛

好吧，我们可以把问题转化成下面这幅图（手绘勿喷）：

![](https://cdn.luogu.com.cn/upload/pic/40104.png)

没看懂？正常，稍微解释一下：

一件x a分

一件y b分

有k个包，从每个里面挑一个x或一个y，要求：要n个x，m个y，

挑完一次后将所有的a和b相乘，并加到总分里

最后求总分多少

emmmm......好像变的更复杂了

没事没事，把问题规模缩小一点，变成两包就好，就像这样：

![](https://cdn.luogu.com.cn/upload/pic/40105.png)

我们只能像下面那样挑：

![](https://cdn.luogu.com.cn/upload/pic/40106.png)

最后得到2ab是答案

某luogu新手：规律找出来了，赶紧写！！！（WA 0）

为什么不对？因为他只是一个点，还有其他数据XD

下面正常一点，换成3个包袱，看看能不能找规律：

![](https://cdn.luogu.com.cn/upload/pic/40207.png)

此处n=1，m=2

我们可以怎么挑选呢？可以先挑x，后挑y,就是从k个包袱里挑n（1）个作为x，

剩下的就都是y了。

你问我为什么？当然因为n+m=k了！数据范围里面写着呢！

某luogu新手：那怎么求从k个里选n个呢？

我：问得好，等一下我去想想（逃

---

								  2000年以后

---

我：~~查~~想出来了！你们有没有听说过杨辉三角，专门用来解决这类问题的，这个叫组合数，他有一个推导公式：

$$C^n_k=C^{n-1}_k+C^{n-1}_{k-1}$$

某luogu新手：这就去交！！！（悲催的WA 30）

某luogu新手：你TM骗我！！！MDZZ！！！

我：你有N(1个)多优化没加，想的挺美！你的组合数是不是用递归写的？

某luogu新手：是呀是呀，怎么了？

我（汗）：你不知道在你递归的时候，会有很多重复吗？比如这样：

c(5,3)=c(4,3)+c(4,2)=c(3,3)+c(4,2)+c(4,2)

看，c(4,2)就重复了！

别看在这里好像就一次，但你c(4,2)也是要递归，

于是就重复了N多次，造成时间上的浪费。

比如你算100+100，你难道要算1+1+1+......+1吗？

某luogu新手：嗯嗯，明白了，所以我只用开个数组，记录这个位置的答案，

如果有，就直接用，这样就可以省出不少时间了！

我：你的悟性不错嘛！你给一个代码吧！

某luogu萌新：代码在此！镇楼！

```cpp
#include<cstdio>
using namespace std;
int zuhe[1005][1005]; 
int powf(int a,int b){
    int ans=1;
    int i=1;
    while(i<=b){
        ans=ans*a%10007;
        i++;
    }
    return ans;
}
void pre(){
    for(int i=0;i<=1000;i++){
        zuhe[i][0]=1;
        zuhe[i][i]=1;
    }
    for(int i=2;i<=1000;i++){
        for(int j=1;j<=1000;j++){
            zuhe[i][j]=(zuhe[i-1][j]+zuhe[i-1][j-1])%10007;
        }
    }
}
int main(){
    pre();
    int a,b,k,n,m;
    scanf("%d%d%d%d%d",&a,&b,&k,&n,&m);
    a=a%10007;
    b=b%10007;
    int ans=powf(a,n)%10007*powf(b,m)%10007*zuhe[k][n]%10007;
    printf("%d",ans);
    return 0;
}
```

时间很快！9ms就过了！！！

我：其实有更快的优化，叫做快速幂，就是快速求一个数的N次方，这样就方便多了，但因为篇幅原因，这里就不赘述了，直接上代码，想要了解的可以进入我的Luogu博客：[夏凌云的博客](https://www.luogu.org/blog/longxiaokong-de-blog/)

```cpp
#include<cstdio>
using namespace std;
int zuhe[1005][1005]; 
int powf(int a,int b){
    int ans=1,base=a;
    while(b!=0){
        if((b&1)!=0)
    		ans=ans*base%10007;
        base=base*base%10007;
        b>>=1;
    }
    return ans;
}
void pre(){
    for(int i=0;i<=1000;i++){
        zuhe[i][0]=1;
        zuhe[i][i]=1;
    }
    for(int i=2;i<=1000;i++){
        for(int j=1;j<=1000;j++){
            zuhe[i][j]=(zuhe[i-1][j]+zuhe[i-1][j-1])%10007;
        }
    }
}
int main(){
    pre();
    int a,b,k,n,m;
    scanf("%d%d%d%d%d",&a,&b,&k,&n,&m);
    a=a%10007;
    b=b%10007;
    int ans=powf(a,n)%10007*powf(b,m)%10007*zuhe[k][n]%10007;
    printf("%d",ans);
    return 0;
}
```
完结撒花~~~

---

## 作者：4041nofoundGeoge (赞：15)

$\text{2025.01.07 19:45 update:}$ 修正了笔误。

## 公式推导

大佬们的公式太复杂。让我这个蒟蒻好好推导一下。

首先，我们来看几个多项式展开：

$$
(a+b)^2=1a^2+2ab+1b^2
$$
$$
(a+b)^3=1a^3 + 3a^2b + 3ab^2 + 1b^3
$$
$$
(a+b)^4=1a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + 1b^4
$$
$$
(a+b)^5=1a^5 + 5a^4b + 10a^3b^2 + 10a^2b^3 + 5ab^4 + 1b^5
$$

我们可以发现，每一项系数都以某种规律排列，每一项而指数的和都为展开前的指数。

然而这种规律就是杨辉三角的数列。杨辉三角可以写成组合数 $C^n_m$ 的形式（其中 $C^n_m$ 也可写作 ${m \choose n}$，表示 $\dfrac{n!}{m!(n-m)!}$，其中 $x!=\prod\limits^x_{i=1}i=x(x-1)(x-2)\dots1$，特别地 $0!=1$），所以我们可以得出：

$$
(a+b)^k=C^0_ka^kb^0+C^{1}_ka^{k-1}b^1+C^2_ka^{k-2}b^2+\dots+C^{k}_{k}a^0b^k
$$

我们用 $\sum$ 列出通项公式。

$$
(a+b)^k = \sum_{n=0}^{k} C^{n}_{k} a^{k-n} b^n
$$

现在我们设 $a'=ax,b'=by$，代入得：

$$
(a'+b')^k=\sum_{n=0}^{k} C^{n}_{k} a'^{k-n} b'^n
$$

我们将 $a'$ 和 $b'$ 变回原来的形式：

$$
(ax+by)^k=\sum_{n=0}^{k} C^{n}_{k} (ax)^{k-n} (by)^n
$$

我们就求出了多项式分解的公式。

## 思路

为了求解本题，我们需要对此公式拆解成每一项求解公式：

$$
a^nb^m=C^{m}_{k} x^{n}y^m a^{n}b^m\bmod10007
$$

系数即为 $C^{m}_{k} x^{n}y^m\bmod10007$。其中 $C^m_k=C^{m-1}_{k-1}+C^{m}_{k-1}$。

这道题就做出来了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long //其实不用 long long 也能过。
using namespace std;
const int mod=1e4+7;
int poww(int x,int p){//快速幂
	int result=1;
	while(p>0){
		if(p%2)result=result*x%mod;
		p/=2;
		x=x*x%mod;
	}
	return result;
}
int c[1005][1005];//这里的c[i][j]=c^i_j
signed main(){
	int a,b,k,n,m;
	cin>>a>>b>>k>>n>>m;
	c[0][0]=1;
	for(int i=1;i<=k;c[i][0]=c[i][i]=1,i++);
	for(int i=1;i<=k;i++){
		for(int j=1;j<i;j++){
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//公式
		}
	}
	cout<<c[k][n]*(poww(a,n)*poww(b,m)%mod)%mod<<endl;
	return 0;
} 
```

#### 后记

$\KaTeX$ 都快敲炸了，给个赞在走吧。

---

## 作者：WsW_ (赞：7)

### 思路
首先你需要知道[二项式定理](https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/7134359?fromModule=lemma_inlink)，这个内容在人教版数学选择性必修三第 $29\sim 30$ 页，信息学奥林匹克辞典第 $232$ 页。  
对于形如 $(ax+by)^n$ 的式子，展开后第 $k+1$ 项为 $T_{k+1}=a^{n-k}b^{k}C_{n}^{k}x^{n-k}y^k$。  
题目中求 $x^n\times y^m$ 项的系数，将这个项带入上式，得到系数为 $a^n b^m C_{k}^{n}$。  
组合数 $C_{k}^{n}$ 可以通过递推式 $C_{n}^{i}=C_{n-1}^{i}+C_{n-1}^{i-1}$ 求出。$a^n$ 和 $b^m$ 可以直接暴力求出。  
注意 $a,b\le 10^6>mod$，$a\times mod>10^9$。应当先将 $a,b$ 取模再进行运算。  

时间复杂度为 $O(k^2)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10007;

int a,b,k,n,m;

int C[1003][1003];

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>a>>b>>k>>n>>m;
	int ans=1;
	
	for(int i=0;i<=k;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++){
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
		}
	}
	a%=mod;b%=mod;
	for(int i=1;i<=n;i++)(ans*=a)%=mod;
	for(int i=1;i<=m;i++)(ans*=b)%=mod;
	cout<<ans*C[k][m]%mod;
	return 0;
}
```

---

## 作者：北方有小仙儿 (赞：3)

~~反正数论题对我来说都是蓝题~~

一看题感觉是二项式定理【~~然而我没记住gg】~~

二项式定理：

$${(a+b)}^n=\sum_{k=0}^n{C_n^ka^kb^{n-k}}$$ 

所以

$${(ax+by)}^k=\sum_{p=0}^k{C_k^p(ax)^p(by)^{k-p}}$$

整理得

$${(ax+by)}^k=\sum_{p=0}^k{(C_k^pa^pb^{k-p})x^py^{k-p}}$$

【~~反正我这智商是搞不到这一步。。~~】

所以答案是

$$C_k^na^nb^m$$

【~~终于到我智商范围内了。。。~~】

求组合数 再用快速幂就搞定啦

求组合数的两个方法： 

1.公式法

$$C_n^m=\frac {n!} {m!(n-m)!}$$

          预处理出阶乘和逆元，带入公式即可。
          
2.杨辉三角递推
       
$$C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$$

          也预处理出来直接带入即可



```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
using namespace std;
typedef long long ll;
const ll p=10007;
ll a,b,k,n,m,ans; 
ll c[1005][1005];
ll ksm(ll a,ll b)
{
	ll res=1;
	while(b)
	{
		if(b&1)res=(res*a)%p;
		a=(a*a)%p;
		b>>=1;
	}
	return res;
}
void build()
{
	c[0][0]=c[1][0]=c[1][1]=1;
	for(ll i=2;i<=k;i++)
	  for(ll j=0;j<=i;j++)
	  {
	  	if(j==0)c[i][j]=1;
	  	else c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
	  }
}
int main()
{
	cin>>a>>b>>k>>n>>m;   
	build(); 
	ans=(c[k][n]*ksm(a,n))%p*ksm(b,m)%p;
	cout<<ans;
	return 0;
	
}
```


---

## 作者：GoldenSTEVE7 (赞：2)

## 题意
求多项式 $(by+ax)^k$ 展开后 $x^ny^m$ 项的系数。

## 分析
本题的求解需要用到一个定理：二项式定理。
$$
(x+y)^n = \sum^n_{i = 0}C^i_n \times x^iy^{n-i}
$$
该定理的证明不会的可以去百度一下，在这里我就不详细证明了。

-------

我们观察一下原式，发现这不就是二项式定理的样子吗，直接硬拆！
$$
(by+ax)^k = \sum^n_{i = 0}C^i_k \times (by)^i(ax)^{k-i}
$$
我们要找的 $x^ny^m$ 项即为当上式的 $i$ 取到了 $k-n$ 时的那一项，具体为 $C^n_k \times (by)^{k-n}(ax)^{n}$。化简一下，是 $C^n_k b^{k-n} a^n \times y^nx^{k-n}$。在这之中 $a^n$ 与 $b^m$ 均需要快速幂进行计算。

那么接下来问题又来了，$C^n_k$ 如何计算呢？

这时候我们需要用到组合数的定义式：
$$
C_n^m = \frac{n!}{m!(n-m)!}
$$

但是由于计算中包含了除法，所以我们还需要通过逆元进行计算。

-----

下面是科普时间（学习过逆元的大佬可以直接跳过）：

我们看下面一个式子：
$$
a\times a^{-1} = 1
$$
是不是很有道理。

那么我们在取模的时候，也是可以这么干的。
$$
a\times a^{-1} \equiv 1 \pmod p
$$
这其中 $a^{-1}$ 被称作 “$a$ 在模 $p$ 意义下的逆元”。

那我们可以发现，两个正整数 $n,m$，一定 $nm^{-1} \equiv n \times (1 \div m) \equiv \displaystyle\frac{n}{m} \pmod p$

那么我们就可以回到上面的那个式子啦！

所以
$$
C_n^m \equiv \frac{n!}{m!(n-m)!} \equiv n! \times [m!(n-m)!]^{-1} \pmod p
$$

那么问题又又来了，咋求逆元啊？

这就不得不再提到一个定理了——费马小定理：

如果 $p$ 是一个质数，而整数 $a$ 与 $p$ 互质，则有 $a^{p-1}\equiv 1 \pmod p$

我们的目标是通过这个定理去求 $a$ 的逆元。

接下来不要眨眼，由于 $a$ 与 $p$ 互质，所以我们可以将同余式子的两边大胆同时除以 $a$ 就可以得到：
$$
a^{p-2}\equiv 1\div a\equiv a^{-1} \pmod p
$$

吔，这右边不就是 $a$ 在模 $p$ 意义下的逆元吗？

所以我们就得到了结论：$a$ 在模 $p$ 意义下的逆元等于 $a$ 的 $p-2$ 次方。

好的以上是对于逆元的科普。

----

回到原题，那么这个可爱（~~可恶~~）的 $C_k^n$ 就可以求出来了。

最后将其与 $a^n\times b^m$ 相乘输出即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int p = 10007;
ll fpow(ll a, ll b) {
    ll ret = 1;
    for(; b; b >>= 1) {
        if(b & 1) ret = ret*a%p; 
        a = a*a%p;
    }
    return ret;
}//快速幂
ll inv(ll x) {return fpow(x,10005);}//求逆元
int main() {
    int a, b, k, n, m;
    cin >> a >> b >> k >> n >> m;
    ll N = 1, KN = 1, K = 1;
    ll ans = fpow(a, n) * fpow(b, m); ans %= p;
    if(n > m) n = m;
    for(int i = 1; i <= n; i++) N *= i, N %= p;
    for(int i = 1; i <= k; i++) K *= i, K %= p;
    for(int i = 1; i <= k-n; i++) KN *= i, KN %= p;
    //分别求出n!,k!,(k-n)!
    ans = ans * K * inv(N*KN%p) % p;
    cout << ans;
    return 0;
}
```

---

## 作者：lgmulti (赞：2)

在做这题之前，请先学习以下知识

- [乘法逆元](http://iwo.im/?q=%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83)

- [快速幂](http://iwo.im/?q=%E5%BF%AB%E9%80%9F%E5%B9%82)

- [卢卡斯定理（会不会都行）](http://iwo.im/?q=%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86)

接下来开始做题

# 1. 分解该多项式

根据二项式定理，

$(x+y)^2=x^2+2xy+y^2$

$(x+y)^3=x^3+3x^2y+3xy^2+y^3$

$(x+y)^k=\sum\limits_{i=0}^k C_k^i x^{k-i}y^i$

$(ab)^k=a^kb^k$

综上，分解原式

$(ax+by)^k=\sum\limits_{i=0}^k C_k^i a^{k-i}b^i x^{k-i}y^i$

该式中$x^ny^m$的系数是：$C_k^m a^nb^m$

# 2. 求解该系数

首先，看清楚我们要求的系数是

$C_k^m a^nb^m \mod 10007$

## 2.1 求$C_k^m \mod 10007$
其中的$C_k^m \mod 10007$可用卢卡斯定理改为 $C_{k \mod 10007}^{m \mod 10007} C_{k \div 10007}^{m \div 10007}$，当然不用也能过，这里以不用为例。

如果不用，$C_k^m=\frac{k!}{(k-m)!m!}=k! \times inv[(k-m)!] \times inv[m!]$，其中$inv[x]$表示x的乘法逆元，这样就不用作除法了

但是我们得先求出数组inv:

```
const int MOD=10007;
int inv[1005];

inv[1]=1;
for(i=2;i<=a;i++)
	inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
```

但是如果要求阶乘的逆元的话，量太大，所以可以用以下方法求阶乘逆元，存在$jc\_inv$里面

```
jc[1]=1;
for(i=2;i<=a;i++)
	jc[i]=jc[i-1]*i%MOD;

jc_inv[1]=1;
for(i=2;i<=a;i++)
	jc_inv[i]=jc_inv[i-1]*inv[i]%MOD;
```

这样我们要求的东西变成了$jc[k] \times jc\_inv[k-m] \times jc\_inv[m]$，时间复杂度为$O(1)$

至此，整个C函数写好了

```
long long c(long long a,long long b){
	long long i,j;
	inv[1]=1;
	for(i=2;i<=a;i++)
		inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
	
	jc[1]=1;
	for(i=2;i<=a;i++)
		jc[i]=jc[i-1]*i%MOD;

	jc_inv[1]=1;
	for(i=2;i<=a;i++)
		jc_inv[i]=jc_inv[i-1]*inv[i]%MOD;

	return jc[a]*jc_inv[a-b]%MOD*jc_inv[b]%MOD;
}
```

## 2.2 求$a^n$ 和 $b^m \mod 10007$

直接用快速幂，快速幂是运用分治思想解决$a^b$的一种方法，具体见代码

```
long long quickmi(long long a,long long b){
	long long i,j;
	if(b==0)
		return 1;
	long long sp=quickmi(a,b/2)%MOD;
	if(b%2==0)
		return sp*sp%MOD;
	else
		return sp*sp%MOD*a%MOD;
}
```

**注：为避免数字过大，能用long long就尽量用long long**

# 3. 最后。。。

本题结束，上完整代码

```
#include<iostream>
using namespace std;

const long long MOD=10007;
long long a,b,k,n,m;
long long ans=1;

long long quickmi(long long a,long long b){
	long long i,j;
	if(b==0)
		return 1;
	long long sp=quickmi(a,b/2)%MOD;
	if(b%2==0)
		return sp*sp%MOD;
	else
		return sp*sp%MOD*a%MOD;
}

namespace C{
	long long inv[1005];
	long long jc[1005];
	long long jc_inv[1005];

	long long c(long long a,long long b){
		long long i,j;
		inv[1]=1;
		for(i=2;i<=a;i++)
			inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
		
		jc[1]=1;
		for(i=2;i<=a;i++)
			jc[i]=jc[i-1]*i%MOD;

		jc_inv[1]=1;
		for(i=2;i<=a;i++)
			jc_inv[i]=jc_inv[i-1]*inv[i]%MOD;

		return jc[a]*jc_inv[a-b]%MOD*jc_inv[b]%MOD;
	}
}

int main(){
	long long i,j;
	cin>>a>>b>>k>>n>>m;
	cout<<C::c(k,m)*quickmi(a,n)%MOD*quickmi(b,m)%MOD<<endl;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

[二项式定理](https://oi-wiki.org/math/combinatorics/combination/#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86)：$$\begin{aligned} (x+y)^n=\sum_{i=0}^n C_n^i x^i y^{n-i} \end{aligned}$$。

所以 $$\begin{aligned} (ax+by)^k=\sum_{i=0}^k C_{k, i} (ax)^i (by)^{k-i} &= \sum_{i=0}^k C_{k, i} a^i b^{k-i} x^i y^{k-i}\end{aligned}$$。

有 $n+m=k$，求 $x^n y^m$ 的系数，令 $i=n$ 且 $k-i=m$，其系数是 $C_{k, n} a^n b^m$。

$a^n b^m$ 直接乘就行，不用快速幂。考虑 $C_{k, n}$。

有 $n$ 个数选 $m$ 个数，求方案数 $C_{n, m}$，对于其中一个数考虑选不选。
* 若选这个数，则应在另外 $n-1$ 个数中选 $m-1$ 个数，方案数 $C_{n-1, m-1}$。
* 若不选，则要在另外 $n-1$ 个数中选 $m$ 个数，方案数 $C_{n-1, m}$。

由加法原理得到组合数递推公式：$C_{n, m}=C_{n-1, m}+C_{n-1, m-1}$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a, b, k, n, m, c[1005][1005];
int Pow (int a, int b) {
	long long r=1;
	while (b--)
		r=(r*a)%10007;
	return r;
}
int main () {
	cin >> a >> b >> k >> n >> m;
	c[0][0]=1;
	for (int i=1; i<=k; ++i)
		c[i][0]=c[i][i]=1;
	for (int i=1; i<=k; ++i)
		for (int j=1; j<i; ++j)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%10007;
	cout << Pow(a, n)*Pow(b, m)%10007*c[k][m]%10007;
	return 0;
}
```

---

## 作者：Kawaii_qiuw (赞：1)

题面非常简洁，不再赘述。

### 解题思路

$x ^ {n} \times y ^{m}$ 项的系数为 $C ^{m} _ {k} \times b ^{m} \times a ^{n}$。根据组合数的性质，有 $C ^ {m} _ {n} \to C ^ {m-1} _ {n-1} + C ^{m} _ {n-1}$。可以用动态规划的方法计算 $C ^ {m} _ {k}$：

$$dp _ {i,j} \to dp _ {i-1,j-1} + dp _ {i-1,j}$$

其中 $dp _ {i,j}$ 表示 $C ^ {j} _ {i}$，注意 $dp _ {0,0} \to 1$ 以及取余就可以了。

### 代码

```cpp
#include<cstdio>
using namespace std;

const int maxn = 1005, mod = 10007;
int dp[maxn][maxn], a, b, k, n, m;

signed main() {
    scanf("%d%d%d%d%d", &a, &b, &k, &n, &m);
    dp[0][0] = 1;
    for (int i = 1; i <= 1000; i++) {
        for (int j = 0; j <= i; j++) {
            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;
            if (j >= 1)
                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
        }
    }
    a = a % mod;
    b = b % mod;
    int am = 1, bm = 1;
    for(int i = 1; i <= m; i++)
        bm = (bm * b) % mod;
    for(int i = 1; i <= n; i++)
        am = (am * a) % mod;
    a = am * bm % mod * dp[k][m] % mod;
    printf("%d", a);
    return 0;
}
```

[AC 记录。](https://www.luogu.com.cn/record/197352987)

完结撒花。

---

## 作者：lam_dyr (赞：1)

一眼二项式定理。

## 前置知识

**什么是二项式？**

在数学中，二项式是指只有两项的代数式，通常形式为 $(a + b)$ 或 $(a - b)$，其中 $a$ 和 $b$ 可以是数字、变量或更复杂的表达式。

**什么是二项式定理？**

二项式定理描述了如何将一个二项式的整数次幂展开成一个和的形式。具体来说，对于任意正整数 $n$，二项式定理给出了 $(a + b)^n$ 的展开式：

$(a+b)^n = \binom{n}{0}a^n b^0 + \binom{n}{1}a^{n-1}b^1 + \binom{n}{2}a^{n-2}b^2 + \cdots + \binom{n}{n-1}a^1 b^{n-1} + \binom{n}{n}a^0 b^n$

也可以用求和符号表示为：

$(a+b)^n = \sum_{k=0}^n \binom{n}{k} a^{n-k} b^k$

以上内容摘自百度百科。

知道了这些之后，本题就是二项式定理的一个简单变形。

## 思路

在本题中，直接应用二项式定理，得 $(by + ax)^k = \sum_{i=0}^{k} \binom{k}{i} (ax)^i (by)^{k-i}$。

其中 $\binom{k}{i}$ 是二项式系数，表示从 $k$ 个元素中选择 $i$ 个元素的组合数，计算公式为 $\binom{k}{i} = \frac{k!}{i!(k-i)!}$。

我们需要求的是 $x^n \times y^m$ 项的系数。

在展开式中，当 $i = n$ 时，我们得到 $x^n$ 项，此时 $k-i = k-n = m$，所以 $y^{k-n} = y^m$。

因此，计算当 $i = n$ 时的展开项系数：$\binom{k}{n} a^n b^m$ 就是答案。

$a^n$ 和 $b^m$ 可以通过快速幂计算，但是如何计算 $\binom{k}{n}$ 呢？

直接计算组合数会溢出，不妨使用如下递推公式：

$$\binom{k}{0} = 1$$
$$\binom{k}{i} = \binom{k}{i-1} \times \frac{k-i+1}{i}$$

~~请读者自行证明。~~

最后将计算得到的组合数与 $a^n \times b^m$ 相乘并输出即可。

注意取模。

## Code

```cpp
#include <iostream>
using namespace std;
const int mod = 10007;
long long ksm(long long a, long long b) {
    long long ans = 1;
    while (b) {
        if (b & 1)
            ans = (ans * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return ans % mod;
}
int a, b, k, n, m;
long long ans;
int main() { 
    cin >> a >> b >> k >> n >> m;
    long long bin = 1;
    for (int i = 1; i <= n; ++i) {
        bin = (bin * (k - i + 1)) % mod;
        bin = (bin * ksm(i, mod - 2)) % mod; //费马小定理求逆元
    }
    long long apn = ksm(a, n);
    long long bpm = ksm(b, m);
    ans = (bin * apn) % mod;
    ans = (ans * bpm) % mod;
    cout << ans;
    return 0;
}

```

---

## 作者：Vct14 (赞：0)

由二项式定理，$(a+b)^n=\sum\limits_{i=0}^nC_n^ka^kb^{n-k}$，有 $(ax+by)^n=\sum\limits_{i=0}^nC_n^k(ax)^k(by)^{n-k}=a^kb^{n-k}C_n^kx^ky^{n-k}$。那么 $x^ny^m$ 的系数为 $a^nb^mC_k^n$。

前面的 $a^nb^m$ 可用快速幂解决。后面的组合数可用组合数递推公式 $C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$ 递推得。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 10007

int qpow(int a,int b){
	if(b==0) return 1;
    long long ans=1;
    for(int i=1; i<=b; i++) ans=(ans*a)%mod;
    return ans;
}

int t[1002][1002];

int main(){
	int a,b,k,n,m;cin>>a>>b>>k>>n>>m;t[0][0]=1;
	for(int i=1; i<=k; i++) t[i][0]=t[i][i]=1;
	for(int i=1; i<=k; i++) for(int j=1; j<i; j++) t[i][j]=(t[i-1][j-1]+t[i-1][j])%mod;
	cout<<t[k][n]*(qpow(a,n)*qpow(b,m)%mod)%mod;
	return 0;
}
```

---


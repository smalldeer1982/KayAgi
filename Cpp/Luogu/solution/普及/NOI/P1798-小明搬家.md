# 小明搬家

## 题目描述

小明要搬家了，大家都来帮忙。

小明现在住在第 $N$ 楼，总共 $K$ 个人要把 $M$ 个大箱子搬上 $N$ 楼。

最开始 $M$ 个箱子都在 $1$ 楼，但是经过一段混乱的搬运已经乱掉了。最后大家发现这样混乱地搬运过程效率太低了，于是总结出了提高效率的方法。

大家的速度都是每分钟上（或下）一层楼。所有向上走的人手中都拿一个箱子，所有向下走的人手中都不拿箱子。到达第 $N$ 层立刻放下箱子向下走，到达第 $1$ 层立刻拿起箱子向上走。当一个人向上走，另一人向下走而在楼道里相遇时，向上走的人将手中的箱子交给另一人，两人同时反向。即原来拿箱子向上走的人不拿箱子向下走，原来不拿箱子向下走的人现拿着箱子向上走。

求将所有箱子搬完所需的最短时间。

## 说明/提示

对于 $30\%$ 的数据，$K \leq 100$，$M \leq 100$；

对于 $60\%$ 的数据，$K \leq 1000$，$M \leq 10^9$;

对于 $100\%$ 的数据，$N \le 10^9$，$K \le 5 \times 10^5$，$M \le 10^9$。

## 样例 #1

### 输入

```
5 2 4
1 0
3 0
```

### 输出

```
20```

# 题解

## 作者：风中の菜鸡 (赞：9)

看了几篇题解，感觉分析的~~不是很清楚~~，所以我就来一篇详细分析的题解，像我这样的蒟蒻都能看懂（巨佬请自行跳过）。

注意题目中的一句话："当一个人向上走，另一人向下走而在楼道里相遇时，向上走的人将手中的箱子交给另一人，两人同时反向。即原来拿箱子向上走的人不拿箱子向下走，原来不拿箱子向下走的人现拿着箱子向上走。"其实这句话根本不需要考虑，因为所有人速度一样，所以谁接手谁的箱子去送是一样的，因此我们就不需要考虑了。

然后这道题就变成了一道数学题了，不难发现一个人从起始位置出发，再以同样的状态回到此位置的时间是固定的，这个时间就是 $2(n-1)$ 。至于为什么，请看下图。
![.](https://cdn.luogu.com.cn/upload/image_hosting/nfx1o1r2.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

看到这有人可能以为再次以同样状态回到出发楼层的时间不应该是  $2n$ 吗，但请你仔细想想，你从一楼爬到五楼要爬几层？正解应该是四层，因为你不是从 $0$ 楼出发。

得到这个结论后，做出此题就不难了。

我们的思路：

 $1$ .  输入时预处理每个人到顶楼的距离。
 
 $2$ . 从小到大对这个距离排序。（至于干嘛下面解释）
 
 $3$ . 算出搬完这些箱子需要几个来回。
 
 $4$ . 用来回数乘上一个来回所用时间。
 
 $5$ . 在加上最慢的返回第 $n$ 楼所用时间。（因为第 $4$ 步操作仅仅算出了回到起始位置所用时间，但其实还要搬到顶楼才搬完）
 
这道题就做完了，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,ans,minn=1e9,t[500010];
int a[500010];
int main(){
//	freopen("box.in","r",stdin);
//	freopen("box.out","w",stdout);
	cin>>n>>k>>m;
	for(int i=1;i<=k;i++){
		int b;
		cin>>a[i]>>b;
		if(b==1){
			t[i]=a[i]-n;
		}
		else{
			t[i]=n-a[i];
		}//预处理出每个人到顶楼时间。 
	}
	sort(t+1,t+k+1);
	t[0]=t[k]; //m%k==0时情况 
	cout<<2*(n-1)*(m/k)+t[m%k];//公式 
	return 0;//完结撒花
}
```

---

## 作者：xcyy (赞：4)

此题洛谷数据其实非常水,只考虑了m%k==0的情况，所以第一篇题解能过，但实际上存在m%k!=0的情况，但洛谷没有这种数据，但我考试的测试数据是有的，我的程序貌似还和下面一位同学的撞了....真的非常像。。但我真的是自己写的，这题的想法其实和，P1007独木桥，非常的像就是交换箱子其实相当于他们灵魂互换，走了过去，其实也就可以试做他们穿过对方身体而过，这样想之后，题目回简单很多，然后就是一开始所以人有往上的有往下的，的确非常混乱，**我们可以计算出每个人拿了一个箱子第一次到n楼的时间**，然后对这个时间进行从小到大的排序。

这里分2种情况考虑：m%k==0，就是m/k趟能刚好搬完，所有人搬m/k趟就行了，这种情况只要计算最慢的那个人的速度也就是整体速度，

ans=ans=ren[k].tim+2*(n-1)*(t-1);

第二种就是m%k!=0这种情况所有人搬完m/k趟之后，还有m%k个没搬，这个时候第m%k个人会刚好搬掉最后一个箱子，所以计算第m%k的人所用的时间即可

ans=ren[m%k].tim+2*(n-1)*(t);

之所以不是t-1了是因为他要多搬一趟加一

最后上代码

```
#include<cstring>
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
#define ll long long 
ll ans;
#define N 500005
ll n,m,k;
int maxtim=0;
//其实算最慢的就好了，其它的肯定有更快的 
//交换箱子其实就是没换
//计算出第k个箱子到楼顶的时间 
//和m%k个箱子到达的时间 
//
struct node{
	ll a,b,tim;
}ren[N];

inline bool cmp(node a,node b){
	/*if(a.b!=b.b)
	return a.b>b.b;
	return a.a>b.a;*/
	return a.tim<b.tim;
}
int main()
{
	//freopen("box.in","r",stdin);
	//freopen("box.out","w",stdout);
	scanf("%lld%lld%lld",&n,&k,&m);
	
	for(int i=1;i<=k;i++){
		scanf("%lld%lld",&ren[i].a,&ren[i].b);
		if(ren[i].b==0)
		{
		ren[i].tim=n-ren[i].a+n-1+n-1;
		}//ren[i].tim为第i个人第一次到1楼拿箱子并送到n楼的时间 
		
		if(ren[i].b==1)
		ren[i].tim=ren[i].a-1+n-1;
	}
	int t=m/k;
	sort(ren+1,ren+k+1,cmp);
	if(m%k==0)
	{
	//cout<<ren[k].tim<<endl;
	ans=ren[k].tim+2*(n-1)*(t-1);//上下是2*（n-1） 
	printf("%lld",ans);
	}
	else {
		ans=ren[m%k].tim+2*(n-1)*(t);
		printf("%lld",ans);
	}
	return 0;
}
/*
5 2 4 
1 0 
3 0
*/

```


---

## 作者：荣一鸣 (赞：3)

本题的意思十分清楚，~~不就是搬家吗~~，~~不就是搬箱子吗~~。

那么这道题一看是可以模拟的，30%的数据应该能过。

当然这么~~简单~~的题肯定不能只拿30分

我们手动模拟一下，发现是有周期规律的，又想到按周期做一下。

我们可以把题意改一下，就是，当两个人在同一层楼相遇时不做处理，其实和原来是等效的，所以我们就可以直接处理了，把每个人分为两部分，第一部分是将这个人按现在的方向移到最顶楼（如果向下就倒着算），最后剩下的就直接搬就行了。

```
#include<iostream>
#include<cstdio>
using namespace std;
long long n,k,m;
long long a[500010];
long long t,maxt=-1000000;

int main(){
	cin>>n>>k>>m;
	for(int i=1;i<=k;i++){
		int s,t;
		cin>>s>>t;
		if(t==0){
			a[i]=n-s;
		}
		else{
			a[i]=-(n-s);
		}
		maxt=max(maxt,a[i]);
	}
	n--;
	t=m/k*n*2+maxt;
	cout<<t;
	return 0;
}
```

应该没问题吧

---

## 作者：Rainey (赞：2)

这道题分析时可以忽略“当一个人向上走，另一人向下走而在楼道里相遇时，向上走的人将手中的箱子交给另一人，两人同时反向”这句话，因为想想就知道换了和没换其实差不多。。分析时先假设所有人都一起搬了整数趟回到原来位置，然后若刚好搬完则把这些时间加上所有人中距楼顶所需时间最大的人的时间（向下时时间为负数），没有正好搬完则从最小时间开始依次再加一趟，然后再取最长的时间（说得太乱了，你们还是看程序吧。。）

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
int a[500010]={0};
using namespace std;
int main()
{
    int n,k,m,s=0;
    scanf("%d%d%d",&n,&k,&m);
    for(int i=1;i<=k;++i)
    {
        int x,y;
        s++;
        scanf("%d%d",&x,&y);
        if(y==0) a[s]=n-x;
        else a[s]=x-n;
    }
    sort(a+1,a+k+1);
    a[0]=a[k];//刚好整数趟搬完特殊处理
    printf("%lld",(long long)(ceil(m/k)*2*(n-1)+a[m%k]));//注意答案最大有2*10^18左右，远超int，不过还在long long范围内，ceil向上取整
    return 0;    
}
```

---

## 作者：joyoi (赞：1)

这道题思想其实很简单

每一个位于一楼上的盒子，都是要 $ 2 *（n-1)$ 的时间的，因为无论如何，无论是否传递，都要一个人上去到顶层一个人下来拿箱子 ——> 传递 = 越过

然后位于一楼的箱子所有箱子所需要的时间即为：$(m/k) * (n-1) * 2$（每一个人每一时刻都在走动所以要除）

然后那些已经在楼梯上的箱子则是需要最久的搬运

所以再加上一个 a[m % k]

程序如下 :

```cpp
#include<bits/stdc++.h>
using namespace std;

long long a[500010], cnt, n, k, m;

int main()
{
    int x, y;
    cin >> n >> k >> m;
    for(long long i = 1; i <= k; i++)
    {
        cin >> x >> y;
        if (y == 0) a[++cnt] = n - x;
        else a[++cnt] = x - n;
    }
    sort(a + 1, a + k + 1);
    a[0] = a[k];
    cout << (m / k) * (n - 1) * 2 + a[m % k]; //必定有 (m/k)*(n-1)*2个路程要走的 再加上余下的
    return 0;
}
```




---

## 作者：sparta (赞：1)

水题我实在无法说什么……不用算法。

你写过[color=red]独木桥[/color]吗？那你这题就萌大奶！


ans：答案

cishu：总搬运次数……

a[i]：第i个人还需才可到达顶楼[color=blue]（有可能是负数，绝对值表示他已经放下箱子多久了）[/color]

ans=cishu\*(n-1)\*2+a[hou];


---

## 作者：anke2017 (赞：0)

发现没有二分答案的方法，提交一篇题解。

## 题目描述

[传送门](https://www.luogu.com.cn/problem/P1798)

## 正题

首先，类似于 `P1007`，将两人相遇的情况忽略。

此时，给每人增加一单位时间，他们搬到的箱子并不会因此减少（而且有可能增多），也就是说，搬箱子的个数**满足单调性**。

所以，考虑**二分答案**。

假如我们现在有 $t$ 分钟来搬运箱子，那么如何计算出一个人可以搬运的箱子数量呢？  
先将初始时的状态恢复成在 $1$ 楼，刚搬起一个**新的**箱子的状态，这需要一段时间。  
然后，在此状态下，每搬一个箱子并回到 $1$ 楼的时间就是 $2(n-1)$ 分钟（上下楼都为 $n-1$ 分钟），直接将剩下的时间除以这个时间并下取整就可以了。

如何计算初始时状态恢复的时间？

分两种情况讨论。

1. 如果这个人正在往上搬箱子，那么需要 $n-1$ 分钟来从上往下，要 $n-now$ 分钟来从下往上（$now$ 表示现在所处的楼层），共为 $2\times n -1-now$ 分钟。
2. 如果这个人在往下走，那么需要 $now-1$ 分钟来回到 $1$ 楼。（$now$ 表示现在所处的楼层）

上述计算是 $O(1)$ 的，所以 `check` 函数的复杂度是 $O(n)$。

### 一个细节

只要箱子到了就行了，不用人回到 $1$ 楼，所以可用时间要增加 $n-1$，以保证答案正确（因为上述计算的箱子数保证了人搬完这些箱子还能回到 $1$ 楼，但实际上不需要）

这样，这个题就做完了。时间复杂度为 $O(n\log{val})$，$val$ 为二分上界。  
空间复杂度为 $O(n)$。

### 二分上界

显然，只有一个人的时候，时间最长，最长约为 $n\times m$（由于这个人可以手上拿着箱子，所以实际使用时需要略大），即 $10^{18}$。所以本解法的运行速度略慢（时间约为 $3$ 倍），但可以通过。

### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

struct man//存人的数组
{
    int now;int type;
}men[500001];

long long n,k,m;

bool check(long long now)//可行返回true
{
    long long ans=0;//答案可能爆 int
    for(int i=1;i<=k;i++)
    {
        ans+=(now+
        n-1-//额外的时间，见上
        (men[i].type==1?(men[i].now-1):(2*n-1-men[i].now))//恢复时间
        )/(2*n-2);
    }
    //cout<<now<<' '<<ans<<'\n';
    return ans>=m;//如果搬了 m 个箱子就够了
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);//优化读入
    cin>>n>>k>>m;
    for(int i=1;i<=k;i++)cin>>men[i].now>>men[i].type;
    long long l=0,r=1e18+1e10;//略微开大一点
    while(l<r-1)
    {
        long long mid=(l+r)>>1;
        if(check(mid))r=mid;
        else l=mid;
    }
    cout<<r;
    return 0;
}
```

---


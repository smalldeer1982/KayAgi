# [NOIP 2013 提高组] 转圈游戏

## 题目背景

NOIP2013 提高组 D1T1

## 题目描述

$n$ 个小伙伴（编号从 $0$ 到 $n-1$）围坐一圈玩游戏。按照顺时针方向给 $n$ 个位置编号，从 $0$ 到 $n-1$。最初，第 $0$ 号小伙伴在第 $0$ 号位置，第 $1$ 号小伙伴在第 $1$ 号位置，……，依此类推。游戏规则如下：每一轮第 $0$ 号位置上的小伙伴顺时针走到第 $m$ 号位置，第 $1$ 号位置小伙伴走到第 $m+1$ 号位置，……，依此类推，第 $n - m$ 号位置上的小伙伴走到第 $0$ 号位置，第 $n - m+1$ 号位置上的小伙伴走到第 $1$ 号位置，……，第 $n-1$ 号位置上的小伙伴顺时针走到第 $m-1$ 号位置。

现在，一共进行了 ${10}^k$ 轮，请问 $x$ 号小伙伴最后走到了第几号位置。

## 说明/提示

对于 $30\%$ 的数据，$0 < k < 7$；

对于 $80\%$ 的数据，$0 < k < {10}^7$；

对于 $100\%$ 的数据，$1 < n < {10}^6$，$0 < m < n$，$0 \le x \le n$，$0 < k < {10}^9$。

## 样例 #1

### 输入

```
10 3 4 5
```

### 输出

```
5
```

# 题解

## 作者：kunkun127 (赞：7)

## 思路

此题根据题意模拟即可。

由于是 $n$ 个人在转圈，每个人每次前进 $m$ 个单位，走 $10^k$ 次。

显然，每个人移动过 $n$ 个单位后回到起点，**相当于没运动**，因此我们可以直接计算初始位置 $x$ 加上 $10^k m$，再对一圈的长度 $n$ 取模即可求出答案。

## 注意事项

- 计算 $10^k$ 时数据较大，要用**快速幂**。
- 编号从 $0$ 开始。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL ksm(LL a, LL b, LL p)
{
	LL ans = 1;
	while (b)
	{
		if (b & 1) ans = ans * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return ans;
}

int main()
{
	int n, m, k, x;
	cin >> n >> m >> k >> x;
	cout << (x % n + m % n * ksm(10, k, n) % n) % n << endl;
	return 0;
}
```

---

## 作者：ZSYhaouuan (赞：3)

思路其实不难发现：因为是围成一个环的，所以转圈的位置应该是个周期的。

具体来说，最后那个人的位置是在 $(x+10^km) \bmod n$ 这个位置上的，应该好理解吧！

然后会发现，这个数实在太大了，不可能算完再去取余，所以要边算边取余。

然后会发现，如果一个一个算的话，效率太慢了。有没有什么快速算幂的方法呢？这里就要用到**快速幂**了。

什么是快速幂呢？

快速幂的原理是通过巧妙分解幂运算来提升效率。它将指数逐步分解，每次把运算规模缩小，利用已有的计算结果。在指数为偶数时，底数平方来更新；指数为奇数时，在更新底数平方的同时，保留之前的部分结果，通过这样不断迭代，快速得到幂运算的结果。

如果还是不懂，可以去看一下[这个文章](https://oi-wiki.org/math/binary-exponentiation/)，这里不再赘述。

这是代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n, m, k, x;
ll fpow(ll x, ll p) { //快速幂模板
	ll num = 1;
	while (p > 0) {
		if (p % 2 == 1) num = num * x % n; //奇数时更新值
		p /= 2;
		x *= x;
		x %= n; //边算边取余，避免爆掉
	}
	return num;
}
int main() {
	cin >> n >> m >> k >> x;
	//这里的ans同样记得算一步模一步
	ll ans = (x + (fpow(10, k) % n * m) % n) % n;
	cout << ans;
	return 0 & 114514;
}
```

总结：快速幂的模板题，练练手用的。

---

## 作者：傅思维666 (赞：3)

## 题解：

一道数学推导的题。

题意还是很简单的，就是一圈人围着转，m值还是固定的，所以我们发现，我们不用模拟它到底是不是个圈，就按照线性队列站和移动，最后直接模上圈的人数n就是最后所在的位置。

当然，看不懂的同学可以自己手出几组数据模拟一下，百试百灵。

所以答案的公式就是下面这个东西：
$$
Ans=(x+m\times 10^k)mod\ n
$$
还不能直接输出，因为这里还有一个数据限定，$k\le 10^9$，所以裸的幂运算肯定会T，就可以弄个带模数的快速幂解决。

这题就是在考数学推导和快速幂取模的写法，如果有快速幂不会的小可爱可以看我下面的博客：

[浅谈快速幂](https://www.cnblogs.com/fusiwei/p/11599881.html)

代码大体长这个样子：

```cpp
#include<cstdio>
using namespace std;
int n,m,k,x;
int qpow(int a,int b)
{
    int ans=1;
    while(b>0)
    {
        if(b&1)
            ans=(ans*a)%n;
        a=(a*a)%n;
        b>>=1;
    }
    return ans%n;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&k,&x);
    printf("%d",(x%n+m*qpow(10,k))%n);
    return 0;
}
```

---

## 作者：mairuisheng (赞：2)

[P1965 [NOIP2013 提高组] 转圈游戏](https://www.luogu.com.cn/problem/P1965)

主要算法：快速幂。 

分析：答案显然是轮数乘每次移动的位置数，再加上编号数，由于它是一个环，是有周期的，所以最后还要对人数取模，即 $(10^km+x)\bmod n$。另外，本题数据范围较大，需要用快速幂。

快速幂算法：

计算 $x^k$：

若 $k$ 为偶数，计算 $x^{k/2}\times x^{k/2}$；

若 $k$ 为奇数，计算 $x^{k/2}\times x^{k/2}\times x$。

边界条件：当 $k$ 为 $1$ 时，返回 $x$。

时间复杂度：$O(\log k)$。

```cpp
#include<cstdio>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<3)+(x<<1)+(s-48);
		s=getchar();
	}
	return x*f;
}
int n,m,k,x;
int ans;
int quickpow(int num,int c)//快速幂
{
	if(c==1)return num;
	int tmp=quickpow(num,c/2)%n;
	tmp=tmp*tmp%n;
	if(c%2==0)return tmp;
	else return tmp*num%n;
}
int main()
{
	n=read();
	m=read();
	k=read();
	x=read();
	ans=m*quickpow(10,k)%n;
	ans=(ans+x)%n;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zhoujunchen (赞：2)

做题思路
--

一道数学题。

首先，设这个人的编号为 $x$，转一次位置就是 $(x+m) \bmod n$，那转 $10^k$ 次，位置就是 $(x+m\times10^k)\bmod n$。

用快速幂求解即可，不会的看 [OI Wiki](https://oi.wiki/math/binary-exponentiation/)。

code:


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,k,x;
int qp(int a,int b){
    int ans=1;
    while(b>0){
        if(b&1)ans=(ans*a)%n;
        a=(a*a)%n;
        b>>=1;
    }
    return ans%n;
}
signed main(){
    cin>>n>>m>>k>>x;
    cout<<(x%n+m*qp(10,k))%n;
    return 0;
}
```

时间复杂度 $O(\log k)$。

---

## 作者：4041nofoundGeoge (赞：2)

这道主要是练习快速幂。

## 思路

不难发现规律，答案为 $(x+10^km)\bmod n$。

#### $1.$ 我会暴力

这是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	//freopen("","",stdin);
	//freopen("","",stdout);
	int n,m,k,x;
	cin>>n>>m>>k>>x;
	long long ans=1;
	for(int i=1;i<=k;i++){
		ans=ans*10%n; 
	}
	ans=ans*m%n;
	ans+=x;
	cout<<ans%n;
	return 0;
}

```

复杂度 $O(k)$，可以发现得了 $90$ 分，TLE 了最后一个测试点（~~说明数据很水~~）。这是因为 `for` 循环中耗时太长，所以我们就需要用快速幂。

#### $2.$ 正解

快速幂顾名思义就是快速计算 $x^p\bmod m$，详见 [OI WIKI](https://oi-wiki.org/math/binary-exponentiation/)。我们就可以减少时间耗费，拿到满分。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x;
int poww(int x,int p){//快速幂
	int result=1;
	while(p>0){
		if(p%2)result=result*x%n;
		p/=2;
		x=x*x%n;
	}
	return result;
}
int main(){
	//freopen("","",stdin);
	//freopen("","",stdout);
	cin>>n>>m>>k>>x;
	long long ans=((poww(10,k)%n*m)%n+x)%n;
	cout<<ans<<endl;
	return 0;
}
```

复杂度 $O(\log k)$。

---

## 作者：Malkin_Moonlight (赞：1)

## Solution

快速幂板子。

根据题意模拟即可，显见对于每名小伙伴，每轮移动 $m$ 个位置，一共走了 $m \times 10 ^ k$ 个位置。题目要求第 $x$ 个小伙伴，那么这位小伙伴走了 $x + m \times 10 ^ k$。但是，走一圈回到起点等于没走，也就是需要取模 $n$。

综上所述，题目的答案可以表示为：


$$x+\left(10^{k} \times m\right) \bmod n$$

但是注意到 $0 < k < 10 ^ 9$，故使用快速幂。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
ll n, m, k, x;

ll fpow(ll x, ll p) { //快速幂模板
	ll num = 1;
	while (p > 0) {
		if (p % 2 == 1) num = num * x % n;
		p /= 2;
		x *= x;
		x %= n;
	}
	return num;
}

int main() {
	cin >> n >> m >> k >> x;
	cout << (x + m * fpow(10, k)) % n;
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：1)

### 思路

观察到转圈轮数较大，考虑使用数学方法。

依题意，显见对于每名小伙伴，每轮移动 $m$ 个位置，走一轮后都回到起点，考虑使用取模计算。故答案用数学方式表示为：

$$$
x + (10^k \times m) \bmod n
$$$

考虑到 $k$ 较大，故使用快速幂。

### 代码

```cpp
# include <iostream>
using namespace std;
long long pow(long long a,long long b,long long m){
	if (b == 1) return a;
	if (b % 2 == 0){
		long long x = pow(a,b/2,m) % m;
		return (x * x) % m;
	}return ((a % m) * (pow(a,b-1,m) % m)) % m;
}int main(){
	long long n,m,k,x; cin >> n >> m >> k >> x;
	printf("%lld",(x + (pow(10,k,n) * m % n)) % n);
	return 0;
}
```

---

## 作者：lam_dyr (赞：1)

小清新数学题。

## 题意

有 $n$ 个小伙伴围成一圈，编号从 $0$ 到 $n-1$。每一轮，每个小伙伴都顺时针移动 $m$ 个位置。

求出经过 $10^k$ 轮后，小伙伴 $x$ 的最终位置。

## 思路

先考虑只移动 $1$ 轮的情况。

如果小伙伴当前位置是 $pos$，移动一轮后的位置是 $(pos + m) \bmod n$。

那么如果移动 $t$ 轮，小伙伴的最终位置就是 $(x + t \times m) \bmod n$。

所以问题转化成了计算出 $10^k$ 轮后，小伙伴 $x$ 的位置，即计算 $(x + (10^k \times m) \bmod n) \bmod n$。

因为 $k$ 较大，所以需要用快速幂计算 $10^k$，注意取模。

那么这题就做完了。

不会快速幂的见以下讲解：

- 快速幂原理：

  - 如果 $k$ 是偶数，则 $10^k = (10^{ \frac {k} {2}} )^2$。
  - 如果 $k$ 是奇数，则 $10^k = 10 \times (10^{ \frac {k} {2}})^2$。
  - 即通过递归或循环的方式，不断将指数除以 $2$，直到指数为 $0$，从而快速计算出结果。

## Code

```cpp
#include <iostream>
using namespace std;
long long ksm(long long a,long long b,long long mod){
    long long ans=1;
    while(b){
        if(b&1)
            ans=(ans*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return ans%mod;
}
long long n, m, k, x;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    cin>>n>>m>>k>>x;
    long long res=ksm(10, k, n);
    long long ans=(x+(res*m)%n)%n;
    cout<<ans;
    return 0;
}
```

---

## 作者：TainityAnle (赞：1)

### 题意

有 $n$ 个人，围成一圈转圈，每个人每次向后走 $m$ 个位置。如果位置到了 $n$ 就回到一圈的起点，变成 $0$ 位置。

问初始编号位置为 $x$ 的人走 $10^k$ 次后的位置。

### 思路

每次走 $m$ 个位置，走 $10^k$ 次一定移动 $10^k\times m$ 个位置。而每移动 $n$ 个位置就相当于没移动，把初始位置加上移动位置数再对 $n$ 取模即可。

由于 $k$ 可能很大，所以要用快速幂。注意快速幂过程中也要对 $n$ 取模。

注意编号从 $0$ 开始。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,x;
int mi(int a,int b){
	int xx=a,ans=1;
	while(b){
		if(b&1) ans=ans*xx%n;
		xx=xx*xx%n;
		b>>=1;
	}
	return ans;
}
signed main(){
	cin>>n>>m>>k>>x;
	cout<<(x+m*mi(10,k))%n;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 前置知识：
[快速幂](https://blog.csdn.net/m0_52072919/article/details/116400820)

---
### 思路：
这题是数学题，可以用快速幂的方法来做。

首先，得先写出快速幂的模版：
```cpp
int qmi(int a, int b, int m) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % m; // res *= a % m;
		b >>= 1; // b /= 2;
		a = a * a % m;// a *= a % m;
	}
	return res;
}
```
不难吧！

接着来看调用快速幂部分的思路。一圈人围着转，直接模上圈的人数就是最后所在的位置。

那么，就能有一个公式 $(x + m \times 10^k) \bmod n$。

最后，用代码形式表现出来，就可以了。

---
### code：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m, k, x;

int qmi(int a, int b, int m) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % m; // res *= a % m;
		b >>= 1; // b /= 2;
		a = a * a % m;// a *= a % m;
	}
	return res;
}

signed main() {
	scanf("%lld %lld %lld %lld", &n, &m, &k, &x);
	printf("%lld\n", (x + m * qmi(10, k, n) % n) % n);
	return 0;
}

---

## 作者：Vct14 (赞：0)

评橙。注意到每轮每个小朋友都走 $m$ 个位置，那么一共走了 $m\times10^k$ 个位置，最后在 $x+m\times10^k$ 号位置。由于走 $n$ 个位置相当于没动，因此最终的位置为  $(x+m\times10^k)\bmod n$。$10^k\bmod n$ 可用快速幂求。

```cpp
#include<bits/stdc++.h>
using namespace std; 

int n,m,k,x;

int ksm(int a,int b){
	int re=1;
	int t=a;
	while(b){
		if(b&1) re=re*t%n; 
		t=t*t%n;
		b>>=1;
	}
	return re;
}

int main(){
	cin>>n>>m>>k>>x;
	cout<<(x%n+m%n*ksm(10,k)%n)%n;
	return 0;
}
```

---

## 作者：glass_goldfish (赞：0)

比较简单的数论。  

原本，某个人的位置在 $i$ 号，进行一轮之后，他的位置就变成了 $(i+m)\bmod n$ 号，进行两轮之后，他的位置就变成了 $(i+2\times m)\bmod n$ 号…进行 $r$ 轮之后，他的位置就变成了 $(i+rm)\bmod n$ 号。所以，进行 $10^k$ 轮之后，他的位置就变成了 $(i+10^k\times m)\bmod n$ 号。

最后输出即可。答案为 $(x+10^k\times m)\bmod n$。代码不放了。

---

## 作者：ZJYelizaveta (赞：0)

### 描述

$n$ 个小伙伴围成一个圈（编号从 $0 \sim 1$），按照顺时针方向给 $n$ 个位置标号，每次每个人向后移动 $m$ 个位置，问操作 $10^{k}$ 次的时候，第 $x$ 号小伙伴走到了第几号位置？

$1 < n < 10^{6}, 0 < m < n, 1 \leq x \leq n, 0 < k < 10^{9}$

### 分析

我们可以用式子表示出 $x$ 号小朋友最后的位置：

$$x = (x + m \times 10^{k}) \% n$$

我们可以将式子恒等变形一下，变成一个比较容易求的形式：

$$x = (x + m \times (10^{k}\  \% \ n) \ \% \ n) \ \% \ n$$

这样一来式子的关键就变成了做快速幂的时候顺便取模。


mdzz，第一次竟然把快速幂写错了qwq

### 代码

```cpp
//  Created by ZJYelizaveta on Tuesday, October 17, 2017 AM08:58:17 CST
//  Copyright (c) 2017年 ZJYelizaveta. All rights reserved.

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
template<typename T> T readIn() {
    T x(0), f(1);
    char ch = getchar();
    while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}
const int MAX_N = 1000000 + 3;
const int INF = 0x3f3f3f3f;
ll n, m, k, x;

inline ll quickPow(ll a, ll b) {
    ll res = 1; //
    while (b) {
        if (b & 1) (res *= a) %= n;
        (a *= a) %= n;
        b >>= 1;
    }
    return res;
}


int main()
{
    n = readIn<ll>(), m = readIn<ll>(), k = readIn<ll>(), x = readIn<ll>();

    ll temp = quickPow(10, k);

    x = (x + m * quickPow(10, k) % n + n) % n;
    printf("%lld\n", x);
    return 0;
}
```

---

## 作者：DemonPlayer (赞：0)

### 思路：   
根据题意模拟。       
先向串 $10^k$ 轮，不过每乘一次 $\bmod n$。不然就会算出 $10^{10^9}$，根本存不下。另外，由于 $k\le 10^9$，$\mathcal O(k)$的时间复杂度无法接受，所以需要使用快速幂。  
### Code：   
```cpp
#include<bits/stdc++.h>
using namespace std;

long long n,m,k,x,pos,res;

long long pow(long long a,long long b,long long m) {
	a%=m;
	res=1;
	while (b>0) {
		if(b&1){
			res*=a;
			res%=m;
		}
		a*=a;
		a%=m;
		b>>=1;
	}
	return res;
}

int main(){
	cin>>n>>m>>k>>x;
	pos=pow(10,k,n);
	pos*=m;
	pos+=x;
	pos%=n;
	cout<<pos;
	return 0;
}

---

## 作者：刘心远 (赞：0)

解：数学题，爆简单！

不过有些小东西~~~：

【算法分析】

显然，所求答案为（x+10^k\*m）%n

不过这个暴力破解法特别的有用：80分！！！

想要AC，不能暴力，得分治计算（递归）

原式=x%n+10^k%n\*（m%n）

=x%n+（10%n）^k%n\*（m%n）

讨论（10%n）^k

令10%n=a，k=b

令num=exp（a，b/2）

（一）    若b为偶数

exp（a，b）=num\*num%n

（二）    若b为奇数

exp（a，b）=num\*num%n\*a%n

算法分析结束

【温馨提示】别忘了%n！

```cpp
#include<iostream>
using namespace std;
int n,m,k,x,i;
int exp(int a,int b)
{
    if(b==0)return 1; //a^0=1
    if(b==1)return a;
    int num=exp(a,b/2);
    if(b%2==0)return num*num%n;
    else return num*num%n*a%n;
}
int main()
{
    cin>>n>>m>>k>>x;
    int sum=1,ans;
    sum=exp(10%n,k);
    ans=(x+sum*m)%n;
    cout<<ans<<endl; return 0;
}
```
请大神多多指教！

---


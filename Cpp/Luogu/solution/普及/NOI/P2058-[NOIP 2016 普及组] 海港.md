# [NOIP 2016 普及组] 海港

## 题目背景

NOIP2016 普及组 T3

## 题目描述

小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。

小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。

小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $=86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。

形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400<t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。


## 说明/提示

【样例解释 1】

第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；

第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 = 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；

第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1=7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。

【样例解释 2】

第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。

第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2=6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。

第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2=4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。

第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1=5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。

【数据范围】

- 对于 $10\%$ 的测试点，$n=1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。
- 对于 $20\%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。
- 对于 $40\%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。
- 对于 $70\%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。
- 对于 $100\%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。


## 样例 #1

### 输入

```
3
1 4 4 1 2 2
2 2 2 3
10 1 3```

### 输出

```
3
4
4
```

## 样例 #2

### 输入

```
4
1 4 1 2 2 3
3 2 2 3
86401 2 3 4
86402 1 5```

### 输出

```
3
3
3
4```

# 题解

## 作者：theb0t (赞：35)

使用队列存储每一个船上的每一个人，当一条新的船到达时，把之前超时的人弹出队列，然后输出答案。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
struct node
{
	int timee,country;
}q[300005];
int cnt[100005],ans;
int head,tail;
int main()
{
	//freopen("a.txt","r",stdin);
	int T;
	cin>>T;
	while(T--)
	{
		int t,k;
		cin>>t>>k;
		for(int i=1;i<=k;i++)
		{
			int x;
			cin>>x;
			q[++tail]={t,x};
			cnt[x]++;
			if(cnt[x]==1) ans++;
		}
		while(head<tail&&t-q[head].timee>=86400)
		{
			cnt[q[head].country]--;
			if(cnt[q[head].country]==0) ans--;
			head++;
		}
		cout<<ans<<'\n';
	}
    return 0;
}
```

---

## 作者：qhr2023 (赞：19)

## solution

桶加队列。开一个桶数组 $num$ 记录 $24$ 小时内每个国籍的人数，在读入时，若某个国籍的人刚好为 $1$，说明是新的国籍，答案加一。对于二十四小时这个条件，可以用队列维护，队首是最先入队的，让队首满足二十四小时内即可。若队首不满足 $num$ 数组减一，若 $num$ 数组减后为 $0$，说明减少了一种国籍，答案减一。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans, num[100005];
struct node{ int x, t; } h;
queue<node> q;
int main(){
	cin >> n;
	for(int i=1, t, k; i<=n; i++){
		cin >> t >> k;
		for(int j=1, x; j<=k; j++)
			cin >> x,
			q.push({x, t}),
			ans+=(++num[x]==1);
		for (h=q.front(); q.size()&&h.t+86400<=t; q.pop(), h=q.front())
			ans-=(--num[h.x]==0);
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：_ztyqwq (赞：11)

听说这题很烦，来做做

一遍AC。。。

这个题目就是CF里的 ```two-pointer```，用 $ j $ 表示当前输入&处理哪艘船（我是在线的233），$ i $ 表示满足 $ t_j - t_i < 86400 $ 的最小的 $ i $。所以就是类似队列的做法。

具体来说，用一个 $ b $ 数组，当前国籍为 $ i $ 的人人数为 $ b_i $。每读入一艘船，先把这艘船上的人数加到 $ b $ 数组里（如果有新人种 ```ans++```），然后用 ```while``` 循环把 $ i $ 更新，每次 ```i++``` 时先把第 $ i $ 艘船的人从 $ b $ 数组里减去（如果一个人种消失 ```ans--```），然后输出答案完事。

因为总人数很少，所以我把所有的人都放到 $ x $ 数组里了。代码里面的 $ f $ 和 $ e $ 就是用来记录从哪里开始删人（即第 $ i $ 艘船的人开始位置）和从哪里开始加人（即第 $ j $ 艘船的人结束位置）。

奉上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[100001],k[100001],x[300001],b[100001];
int main()
{
	int n;
	scanf("%d",&n);
	int f=1,e=0,ans=0;
	for(int i=1,j=1;j<=n;j++)
	{
		scanf("%d %d",&t[j],&k[j]);
		for(int _k=1;_k<=k[j];_k++)
		{
			scanf("%d",&x[++e]);
			if(!b[x[e]])
				ans++;
			b[x[e]]++;
		}
		while(t[j]-t[i]>=86400)
		{
			for(int _k=1;_k<=k[i];_k++)
			{
				if(b[x[f]]==1)
					ans--;
				b[x[f++]]--;
			}
			i++;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Nahia (赞：7)

### 思路

以下记 $sum_i$ 为在一天内国籍 $i$ 有抵达的人数，$num$ 为一天内抵达的人的国籍数。

每一艘船上的每一个人到达时，若当前到达的是国籍 $x$ 的乘客，且 $sum_x = 0$，那么就将 $sum_x+1$，且 $num+1$，接着，让这个人的国籍以及到达时间入队，并把队尾指针 $+1$。

然后，把在一天之前到达的人弹出队列。如果当前的人国籍为 $y$ 且在一天之前到达（即当前时间减去到达时间大于等于 $86400$），那么 $sum_y-1$。如果此时 $sum_y=0$，那么 $num-1$。然后队头 $+1$ 再处理下一个人。

### solution

```cpp
#include<bits/stdc++.h>
#define ll long long
const int N = 5e5+5;
using namespace std;
ll n,t,k,x,l,r;
ll a[N],f[N],tme[N];
ll num;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>t>>k;
		while(k--){
			tme[++r]=t;
			cin>>a[r];
			if(!f[a[r]])num++;
			f[a[r]]++;
		}
		while(t-tme[l]>=86400){
			if(!--f[a[l++]])num--;
		}
		cout<<num<<"\n";
	}
	return 0;
}
```

---

## 作者：Danny_chan (赞：7)

我们可以用队列加桶来写，先把输入的数入队，如果还没有这个国籍，答案增加一。后面判断如果队列中的数的时间超过 $86400$ 秒，那么弹出队列，如果这个国籍被删完了答案增减一。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T;
int q[500010],r;
int a[500010],f[500010],sum=0;
signed main(){
	cin>>T;
	while(T--){
		int n,k;
		cin>>n>>k;
		for(int i=1;i<=k;i++){
			q[++r]=n;
			cin>>a[r];
			if(f[a[r]]==false){
				sum++;
			}
			f[a[r]]++;
		} 
		int t;
		while(n-q[t]>=86400){
			f[a[t]]--;
			if(f[a[t]]==false){
				sum--; 
			}
			t++;
		}
		cout<<sum<<endl;
	}
	return 0;
}
```

---

## 作者：_luogu_huowenshuo_ (赞：7)

## 思路
在 $86400$ 内多少乘客来自不同的国家，对于乘客来说有两个信息，一是国籍，二是到达时间，我们可以使用结构体来存储。**循环输入，有新国家的人就 `ans++`，如果一个国家的人被减没了，则 `ans--`**。
## code
```
#include<bits/stdc++.h>
#define int long long
const int N=2e6+5;
using namespace std;
int n,t,k,na[N],ans,x;
struct node
{
	int x;//国籍
	int t;//到达时间
}p;
queue<node>ship;//队列
signed main()
{
	cin >> n;
	for(int i=1;i<=n;i++)
	{
		cin >> t >> k;//到达时间，多少乘客
		while(!ship.empty())//查人
		{
			p=ship.front();//队头开始
			if(p.t+86400<=t)//24小时
			{
				na[p.x]--;//人数减一
				if(na[p.x]==0)ans--;//人没了，ans--;
				ship.pop();//出队
				continue;//继续搜；
			}
			break;//搜完了
		}
		for(int j=1;j<=k;j++)//统计
		{
			cin >> x;
			p.x=x,p.t=t;//存入结构体
			ship.push(p);//
			na[x]++;//国的人++
			if(na[x]==1)ans++;//新国家的人
		}
		cout << ans << "\n";//输出
	}
 	return 0;
}
```

---

## 作者：WsW_ (赞：6)

### 思路
给一个之前没在题解区见过的黑科技解法。  
一个很容易想到的思路是：把所有的 $x_{i,j}$ 开数组全部记录下来，如果新加入了一个之前没有的国籍，那么答案加一。对于 $24$ 小时内这个条件，维护一个窗口即可，由于窗口尾必定是最末，所以只要维护窗口头 $head$ 满足 $t_i-t_{head}\ge 86400$ 即可。  

但是 $k_i$ 最大可以到 $3\times 10^5$。所以 $x_{i,j}$ 得开成 $n \times \max k_i=10^5\times 3\times 10^5$，会超空间。但是 $\sum k_i\le 3\times 10^5$，可以把数组压成一维并记录每艘船乘客在压维后数组所处的区间。  
但是这种做法太要脑子了，我们可以用直接用 `vector` 来动态维护，直接把原数组换成 `vector` 就行了。  

时间复杂度和空间复杂度均为 $O(n+\sum k_i)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3;
vector<int>x[N];
int ans,cnt[N];
int head=1,k[N],t[N];
int n;
int in;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&t[i],&k[i]);
		for(int j=1;j<=k[i];j++){
			scanf("%d",&in);
			x[i].push_back(in);
			if(!cnt[in])ans++;
			cnt[in]++;
		}
		while(t[i]-t[head]>=86400){
			for(int i=0;i<x[head].size();i++){
				cnt[x[head][i]]--;
				if(!cnt[x[head][i]])ans--;
			}
			head++;
		}
		printf("%d\n",ans);
	}

	return 0;
}
```

---

## 作者：Jerry_zpl (赞：4)

本题考查算法：队列，模拟，桶的思想。

---

我们可以定义桶数组 $sum$，然后每输入一个人的国籍就统计，顺便把这个人的信息记录下来。如果这个国籍第 $1$ 次出现，国家的个数就增加 $1$。统计完后，我们还要注意：超时的旅客不能算进去，所以当队头（即最开始来的游客）来的时间大于 $86400$ 秒时我们要把他弹出队列。别忘了，最后让我们求的是游客国籍个数，所以在弹出队列时国籍数要减 $1$，若国籍数为 $0$，那么就没有这个国籍了，国籍个数减 $1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long tong[1000005];
struct node
{
	int s,j;
}q[300005];
int main()
{
	int n;
	cin>>n;
	int head=1,tail=1;
	int k;
	int ans=0;
	int t;
	int x;
	for(int i=1;i<=n;i++)
	{
		cin>>t>>k;
		while(k--)
		{
			cin>>x;
			tong[x]++;//统计国籍
			if(tong[x]==1) ans++;//该国家第1次出现，个数+1
			q[tail]={t,x};//把乘客信息装进去
			tail++;//队尾下标+1
		}
		while(head!=tail&&t-q[head].s>=86400)//把超时的游客弹出队列
		{
			tong[q[head].j]--;//国籍个数-1
			if(tong[q[head].j]==0) ans--;
			head++; //弹出队列了那么对头下标就要+1
		}
		cout<<ans<<endl;//输出并换行
	}
	return 0;
}
```

---

## 作者：STLGirlfriend (赞：4)

为什么我不用队列都一次过，明明很简单，按题意模拟就行了呀 QAQ~

只要维护一个 `std::unordered_map<int, int>`，对于每一艘船，判断是否有船只到达时间超过 $24$ 小时，如果有就把当前船上的所有乘客的国籍从 `std::unordered_map<int, int>` 中删除，然后再统计当前到达的船上乘客的国籍，最后输出 `std::unordered_map<int, int>` 的大小，就 A 了呀 QWQ~

PS：因为数据太大，$x_{i, j}$ 要动态分配内存。

下面是萌萌哒代码（用了 `fread` 快读，事实上并不需要）：

```c++
#include <cstdio>
#include <cctype>
#include <unordered_map>

const int MaxN = 1e5;
const int Limit = 1e5;
const int DaySec = 86400;

char next() {
    static const size_t BufSize = 1 << 17;
    static char *fs, *ft, buf[BufSize];

    if (fs == ft) {
        ft = (fs = buf) + fread(buf, 1, BufSize, stdin);

        if (fs == ft) return EOF;
    }

    return *fs++;
}

int nextInt() {
    int x = 0;
    char c;
    while (!isdigit(c = next()));
    while (isdigit(c)) { x = x * 10 + c - '0'; c = next(); }

    return x;
}

int main() {
    int n;
    n = nextInt();

    static int t[MaxN + 1], k[MaxN + 1];
    static int *x[MaxN + 1];
    for (int i = 1; i <= n; ++i) {
        t[i] = nextInt();
        k[i] = nextInt();
        x[i] = new int[ k[i] ];
        for (int j = 0; j < k[i]; ++j) x[i][j] = nextInt();
    }

    int p = 1;
    std::unordered_map<int, int> cnt;
    for (int i = 1; i <= n; ++i) {
        while (!(t[i] - DaySec < t[p])) {
            for (int j = 0; j < k[p]; ++j) if (--cnt[ x[p][j] ] == 0) cnt.erase(x[p][j]);
            ++p;
        }

        for (int j = 0; j < k[i]; ++j) ++cnt[ x[i][j] ];

        printf("%d\n", cnt.size());
    }
}
```

---

## 作者：xiaobeng_0912 (赞：2)

## $\mathbf{Knowledge}$

1. 模拟
1. 队列

## $\mathbf{Solution}$

首先，对于每一条船，有到达时间，乘客人数和乘客国籍这些信息需要存，有些麻烦。于是我就想到，每个乘客只有到达时间和国籍这两个信息需要存储，如果存储每个乘客的信息的话，就方便多了。

观察到依次输入的每艘船的到达时间**单调不降**，所以我们就可以采用队列的存储方式。对于队列中的每个元素，其代表着一名乘客。然后，我们再开一个数组，统计每种国籍的乘客的数量。

读入每艘船时，将该艘船的到达时间以及当前乘客的国籍打包，放入队列中，视为一个元素（一名乘客）。

当读入完每艘船时，我们就从头依次来看乘客们的到达时间是否已经超过了 $86400$ 秒，如果超过了，就将该乘客对应的国籍的人数减一，并且弹出该元素（乘客）。

在模拟的同时，用一个计数器实时统计不同国籍的乘客的数量即可。

## $\mathbf{Code}$

```cpp
#include<cstdio>
struct node{ //一名乘客
    int ti;//到达时间
    int co;//国籍
}q[300001];//队列
int w[100001];//统计每种国籍乘客的数量的数组
int n,t,k,x;
int head,tail,sum;//手写队列+计数器
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d%d",&t,&k);
        for(int j=0;j<k;j++){
            scanf("%d",&x);
            q[tail].ti=t;//打包时间
            q[tail].co=x;//打包国籍
            tail++;//放入队列
            w[x]++;//将该乘客国籍的人数加一
            if(w[x]==1)sum++;//如果又多出来一种国籍，计数器加一
        }
        while(t-q[head].ti>=86400){//如果该乘客超时了
            w[q[head].co]--;//将该乘客国籍的人数减一
            if(w[q[head].co]==0){//如果该乘客国籍的人数为零（海港暂时没有这种国籍的人了）
                sum--;//计数器就减一
            }
            head++;//弹出该元素（乘客）
        }
        printf("%d\n",sum);//输出统计结果
    }
    return 0;
}
```

---

## 作者：glass_goldfish (赞：1)

解法类似于队列。以下记 $sum_i$ 为在一天内国籍 $i$ 有多少人抵达，$num$ 为一天内有多少个国籍的人抵达。

每一艘船上的每一个人到达时，若当前到达的是国籍 $r$ 的乘客，那么 $sum_r=0$，那么 $sum_r+1$（这个国籍多了一个人），并且 $num+1$（多了一种国籍）。接着，把这个人的国籍以及到达时间压进队列，并把队尾指针 $+1$。  

然后，处理在一天之前到达的人（要把他们移出队列），如果当前的人（记其国籍为 $r$）在一天之前到达（当前时间 $t$ 减去到达时间 $time_r$ 大于等于 $86400$），那么 $sum_r-1$（该国籍少了一个人），如果此时 $sum_r=0$（没人了），那么 $num-1$（少了一个国籍）。然后把队头 $+1$，处理下一个人。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int n,t,k,x,i,r;
int a[500001],noty[500001],tim[500001];
int num;
signed main(){
	cin>>n;
	for(int pas=1;pas<=n;pas++){
		cin>>t>>k;
		while(k--){
			tim[++r]=t;
			cin>>a[r];
			if(!noty[a[r]])num++;
			noty[a[r]]++;
		}//入队
		while(t-tim[i]>=86400){
			if(!--noty[a[i++]])num--;
		}//出队
		cout<<num<<"\n";
	}
	return 0;
}
```

---

## 作者：Garen (赞：0)

# 杀鸡偏用牛刀系列

这道题的“牛刀”是莫队。看到大家都没用莫队就发一波莫队题解咯qwq

~~其实是我菜，不懂队列解法~~

---

显然这道题可以看成有$n$个区间，在区间上有若干个点，求指定区间内的点的种类数。

哇！这不就是莫队模板题吗？！

虽然数据看起来是挺大的，左右端点的移动应该不算是$O(1)$，但还是过了。。。

~~所以如果数据再强一点这篇题解就没了~~

代码：

```cpp
#include<bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
#define ll long long
const int maxn = 100005;
struct Questions {
    int len;
    std::vector<int> vec;
} que[maxn];
int times[maxn];
int n;
struct Nodes {
    int l, r;
} segment[maxn];
int belong[maxn], len;
int cnt[maxn];
int answers[maxn];
void add(int idx, int &ans) {
    for(int i = 0; i < que[idx].len; i++) {
        if(++cnt[que[idx].vec[i]] == 1) ans++;
    }
}
void remove(int idx, int &ans) {
    for(int i = 0; i < que[idx].len; i++) {
        if(--cnt[que[idx].vec[i]] == 0) ans--;
    }
}
void moqueue() {
    int l = 1, r = 0, ans = 0;
    for(int i = 1; i <= n; i++) {
        while(r < segment[i].r) add(++r, ans);
        while(r > segment[i].r) remove(r--, ans);
        while(l < segment[i].l) remove(l++, ans);
        while(l > segment[i].l) add(--l, ans);            
        answers[i] = ans;
    }
}
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        int t, k; cin >> t >> k;
        times[i] = t;
        for(int j = 1; j <= k; j++) {
            int temp; cin >> temp;
            que[i].vec.push_back(temp);
        }
        std::sort(que[i].vec.begin(), que[i].vec.end());
        que[i].len = std::unique(que[i].vec.begin(), que[i].vec.end()) - que[i].vec.begin();
    }
    for(int i = 1; i <= n; i++) {
        int temp1 = std::lower_bound(times + 1, times + n + 1, times[i] - 86400 + 1) - times;// must +1 here
        segment[i].l = temp1, segment[i].r = i;
    }
    len = sqrt(n);
    for(int i = 1; i <= n; i++) belong[i] = (i - 1) / len + 1;
    std::sort(segment + 1, segment + n + 1, [](Nodes A, Nodes B) {
        if(belong[A.l] == belong[B.l]) return A.r < B.r;
        return belong[A.l] < belong[B.l];
    });
    moqueue();
    for(int i = 1; i <= n; i++) cout << answers[i] << endl;
    return 0;
}
```

---

## 作者：hjz_0821_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2058)

## 思路
利用桶和队列模拟。

建一个桶的数组，输入国籍并统计，并将其到达时间与国籍记录下来。每遇到一个新的国籍，也就是说这个国籍第一次出现，就将国籍总数加 $1$。统计完再排一遍，如果队头的旅客来的时间大于 $24$ 小时，就把他从队列里弹出。并且在弹出这名旅客时，将其所属的国籍数量减去 $1$。当这个国籍的数量为 $0$ 时，证明没有这个国籍，总数减去 $1$。挨个输出即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,k,x;//按题意定的变量 
int dt=1,dw=1,ans;//队头下标，队尾下标，总数 
long long a[1000005];//桶的数组 
struct node{
	int s;//时间 
	int j;//国籍 
}q[300005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	//加速 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>t>>k;
		while(k--){
			cin>>x;
			a[x]++;//统计国籍
			if(a[x]==1){
				ans++;
			}//该国家第1次出现，个数+1
			q[dw]={t,x};//把旅客信息装进去
			dw++;//队尾下标+1
		}
		while(dt!=dw && t-q[dt].s>=86400){//弹出超时的旅客 
			a[q[dt].j]--;//对应国籍人数-1 
			if(a[q[dt].j]==0){
				ans--;
			}//判断弹出这名旅客是否导致国籍总数-1 
			dt++;//队头下标+1 
		}
		cout<<ans<<"\n";//输出+换行 
	}
	return 0;
}
```

---


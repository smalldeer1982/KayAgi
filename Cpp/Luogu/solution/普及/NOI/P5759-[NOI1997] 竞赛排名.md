# [NOI1997] 竞赛排名

## 题目描述

某市组织了一次中学生科技全能竞赛，每个选手要参加数学、物理、化学、天文、地理、生物、计算机和英语共八项竞赛,最后综合八项竞赛的成绩排出总名次。

选手编号依次为： $1,2,\dots,N$（$N$ 为参赛总人数）。设 $x_{i, j}$（$1 \le i \le N, 1 \le j \le 8$）分别表示编号为 $i$ 的选手第 $j$ 项竞赛的成绩。其它指标如下：

- 第 $j$（$1 \le j \le 8$）项竞赛的平均分 $avg_j = \frac{1}{N} \sum_{i=1}^N x_{i, j}$
- 选手 $i$（$1 \le i \le N$）的总分 $sumx_i = \sum_{j=1}^8 x_{i, j}$
- 选手 $i$（$1 \le i \le N$）第 $j$（$1 \le j \le 8$）项竞赛的位置分

$$
y_{i, j}= \begin{cases} 0 & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\right) \\ \frac{x_{i, j} - avg_j}{\frac{1}{N} \sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| \ne 0\right)\end{cases}
$$

- 选手 $i$（$1 \le i \le N$）的总位置分 $sumy_i = \sum_{j=1}^3 y_{i, j} + 0.8 \sum_{j=4}^8 y_{i, j}$

排名规则如下:
1. 总位置分高的选手名次在前；
2. 若两个或两个以上的选手总位置分相同，则总分高的选手名次在前；
3. 若两个或两个以上的选手总位置分和总分均相同，则编号在前的选手名次在前。

请你为竞赛组委会编一程序，计算本次全能竞赛的总排名情况。

## 说明/提示

#### 数据范围

对于所有测试数据，满足 $1 \le N \le 1000$。

## 样例 #1

### 输入

```
3
72 82 73 68 95 86 82 90
72 90 50 60 80 70 65 80
72 82 73 68 95 86 82 90
```

### 输出

```
1
3
2
```

# 题解

## 作者：HanPi (赞：6)

[P5759 [NOI1997]竞赛排名](https://www.luogu.com.cn/problem/P5759)

~~以极其暴力的模拟过了此题~~

解释一下这些符号

- $|a|$ 绝对值和 $\dfrac{b}{a}$ 分数应该没有人不懂吧...

- $\sum_{i=1}^Nx_{ij}$ : 求 $x_{1j}+x_{2j}+\cdots+x_{Nj}$ 的和,可以看成是 `for(i=1;i<N;++i)sum+=x[i][j]`

- $y_{ij}=\begin{cases}0&\sum_{i=1}^N|x_{ij}-avg_J|=0\\\frac{x_{ij}-avg_j}{\frac{1}{N}\sum_{i=1}^N|x_{ij}-avg_j|}&\sum_{i=1}^N|x_{ij}-avg_J|\ne0\end{cases}$

	当 $\sum_{i=1}^N|x_{ij}-avg_J|$ 的值为零时 $y_{ij}$ 的值为 $0$.
	当 $\sum_{i=1}^N|x_{ij}-avg_J|$ 的值不为零时 $y_{ij}$ 的值为 $\frac{x_{ij}-avg_j}{\sum_{i=1}^N|x_{ij}-avg_J|\div N}$
    
   用人话来讲就是 用 ( $x$ 与 第 $j$ 科平均分相差的分数) 去除以 ( $x$ 每一科的分数与平均分的差的平均值)
   
- $sumy_i=\sum_{k=1}^3y_{jk}+0.8\sum_{k=4}^8y_{jk}$ 

	前三科成绩的位置分直接加,后四科要 $\times0.8$ 再相加. ~~(语数英?)~~
    
读懂题目模拟就比较好打了.

另外注意double类型的等于判断.
    
$\huge\tt{Code:}$

```c
#include <stdio.h>
#include <stdlib.h>

const double dis=1e-6;

typedef struct _Student
{
    int ind;
    int mark[9];
    int allMark;
    double y[9];
    double sumy;
}Stu;
Stu a[10086];

int cmp(const void* a,const void* b)
{
    Stu* pa=a;
    Stu* pb=b;
    double tmp=pa->sumy-pb->sumy;
    tmp=tmp>0?tmp:-tmp;
    /*奇妙的判断,省略了else*/
    if(tmp>dis)return pa->sumy<pb->sumy?1:-1;
    if(pa->allMark!=pb->allMark)return pa->allMark<pb->allMark?1:-1;
    return pa->ind-pb->ind;
}

int n;
int sumJMark[11];
double avg[11];
double tmp;
double cha;
int main()
{
    int i,j,k;
    scanf("%d",&n);
    for(i=0;i<n;++i)
    {
        a[i].ind=i;
        for(j=0;j<8;++j)
        {
            scanf("%d",&a[i].mark[j]);
            a[i].allMark+=a[i].mark[j];
            sumJMark[j]+=a[i].mark[j];
        }
    }
    for(i=0;i<8;++i)
    {
        avg[i]=((double)sumJMark[i])/((double)n);
    }
    for(j=0;j<8;++j)
    {
        for(i=0;i<n;++i)
        {
            cha=0;
            for(k=0;k<n;++k)
            {
                tmp=a[k].mark[j]-avg[j];
                cha+=(tmp>0)?tmp:-tmp;
            }
            cha/=n;
            if(cha)a[i].y[j]=(a[i].mark[j]-avg[j])/cha;
            
        }
    }
    for(k = 0; k < 3; ++k)a[i].sumy+=a[i].y[k];
    for(k = 3; k < 8; ++k)a[i].sumy+=0.8*a[i].y[k];
    qsort(a,n,sizeof(Stu),cmp);
    for(i=0;i<n;++i)printf("%d\n",a[i].ind+1);
    return 0;
}
```


---

## 作者：Liuxizai (赞：4)

### $Updated \ 2020.11.26$ 修改了代码中的一些错误
### $Updated \ 2021.2.19$ 偶然发现博客格式炸了，求管理通过

[$\huge\color{red}My\ Blog$](https://liuxizai.ac.cn/post/solution-p5759-noi1997jing-sai-pai-ming/)

## 解题思路

这道题是华一高2020级信息学竞赛班在八月份一次考试中的T3。

作为一名新初一学生，在题目里看到这么复杂的数学公式时我的心情是崩溃的。

~~读题完全在读是天书~~

但其实这题也没有那么难，裸的**模拟**。

首先，解释一下我定义的变量。

```cpp
struct stures{            // 存储每个选手的数据
	int id;               // 选手编号
	double yv;            // 总位置分
  double sumv;            // 总分
}res[1005];
int n;                    // 题目中N
int x[1005][10] = {};     // 题目中x
double y[1005][10] = {};  // 题目中y
double avg[10] = {};      // 题目中avg
```



接下来我们用文字语言来解释一下那些求和公式。

- 第 $j$ 项竞赛的平均分 $ avg_j = \frac{1}{N} \sum_{i=1}^N x_{ij}  $

    求平均分应该没有不会的吧。将每位选手第$j$项竞赛的分数加起来，除以选手个数就是第$j$项竞赛的平均分了。

    代码实现：

    ```cpp
    for(int i = 0; i < 8; i++){                                            // 算均分 
    	for(int j = 0; j < n; j++) avg[i] += x[j][i];
    	avg[i] /= n;
    }
    ```

- 选手 $i$ 的总分 $sumx_i = \sum_{j=1}^8 x_{ij}$

    这也不难理解，将选手每项竞赛的分数加起来就是了。

    代码实现：

    ```cpp
    for(int i = 0; i < n; i++) for(int j = 0; j < 8; j++)                  // 算总分 
    	res[i].sumv += x[i][j];
    ```

- 选手 $i$ 第 $j$ 项竞赛的位置分

    $$
    y_{ij}=\left\{\begin{array}{l}{0,\left(\sum_{j=1}^{N}\left|x_{ij}-a v g_{j}\right|=0\right)} \\ {\frac{x_{ij}-a v g_{j}}{\left(\frac{1}{N} \sum_{i=1}^{N}\left|x_{ij}-a v g_{j}\right|\right.},\left(\sum_{i=1}^{N}\left|x_{ij}-a v g_{j}\right| \neq 0\right)}\end{array}\right.
    $$
    这个有点复杂，首先来弄懂后面括号的内容。

    首先，`#define` 分差 竞赛得分与均分的差

    $\sum_{j=1}^{N}\left|x_{ij}-a v g_{j}\right|$这个式子就是选手$j$的分差之和。

    若分差之和为$0$，则选手$i$竞赛$j$位置值为$0$。

    若分差之和不为$0$，则位置值取选手$i$竞赛$j$的分差除以选手$i$所有竞赛分差的平均值。

    读不懂就仔细多读几遍吧，我写的不好。

    代码实现：

    ```cpp
    for(int i = 0; i < 8; i++) for(int j = 0; j < n; j++){                 // 算位置分 
    	for(int k = 0; k < n; k++) y[j][i] += abs(x[k][i] - avg[i]);
    	if(y[j][i] != 0) y[j][i] = (x[j][i] - avg[i]) / (y[j][i] / n);
    }
    ```

- 选手 $i$ 的总位置分 $sumy_i = \sum_{k=1}^3 y_{jk} + 0.8 \sum_{k=4}^8 y_{jk}$

    也就是说，在总位置分中，前三项竞赛的位置分权值为1，后五项的权值为0.8，求和即可。

    代码实现：

    ```cpp
    for(int i = 0; i < n; i++){                                            // 算总位置分 
    	res[i].id = i;
    	res[i].sumv = 0;
    	for(int j = 0; j < 3; j++) res[i].yv += y[i][j];
    	for(int j = 3; j < 8; j++) res[i].yv += 0.8 * y[i][j];
    }
    ```

    > 在这里顺便为res数组作初始化

以上工作做完以后，我们再根据排名规则写一个`cmp`函数：

```cpp
bool cmp(stures r1, stures r2){
	if(r1.yv != r2.yv) return r1.yv > r2.yv;
	else if(r1.sumv != r2.sumv) return r1.sumv > r2.sumv;
	else return r1.id < r2.id;
}
```

就是这样，$THE \space END$

## $AC \space CODE$

```cpp
#include<bits/stdc++.h>
using namespace std;
struct stures{
	int id;
	double yv, sumv;
}res[1005];
bool cmp(stures r1, stures r2){
	if(r1.yv != r2.yv) return r1.yv > r2.yv;
	else if(r1.sumv != r2.sumv) return r1.sumv > r2.sumv;
	else return r1.id < r2.id;
}
int main(){
//	freopen("ranking.in", "r", stdin);
//	freopen("ranking.out", "w", stdout);
	int n, x[1005][10] = {};
	double y[1005][10] = {}, avg[10] = {};
	cin >> n;
	for(int i = 0; i < n; i++) for(int j = 0; j < 8; j++) cin >> x[i][j];  // 输入 
	for(int i = 0; i < 8; i++){                                            // 算均分 
		for(int j = 0; j < n; j++) avg[i] += x[j][i];
		avg[i] /= n;
	}
	for(int i = 0; i < 8; i++) for(int j = 0; j < n; j++){                 // 算位置分 
		for(int k = 0; k < n; k++) y[j][i] += abs(x[k][i] - avg[i]);
		if(y[j][i] != 0) y[j][i] = (x[j][i] - avg[i]) / (y[j][i] / n);
	}
	for(int i = 0; i < n; i++){                                            // 算总位置分 
		res[i].id = i;
		res[i].sumv = 0;
		for(int j = 0; j < 3; j++) res[i].yv += y[i][j];
		for(int j = 3; j < 8; j++) res[i].yv += 0.8 * y[i][j];
	}
	for(int i = 0; i < n; i++) for(int j = 0; j < 8; j++)                  // 算总分 
		res[i].sumv += x[i][j];
	sort(res, res+n, cmp);                                                 // 快排 
	for(int i = 0; i < n; i++) cout << res[i].id+1 << endl;                // 输出 
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/37470548)

- 用时 89ms
- 内存 832.00KB

~~我这代码效率真的低~~

## 本蒟蒻第一篇题解，管理大大求通过


---

## 作者：long_hao (赞：3)

# 前言
目前来说的话是最优解榜一。

![](https://pic1.imgdb.cn/item/6345421e16f2c2beb15b3537.png)

~~当时没看见可以提交题解过了一个月才来写。~~

在我提交题解之后管理大大发现情况马上就很负责任地修改了题面，在我私信建议下也进一步修改不恰当的地方，添加了 $n$ 的取值，现在不存在这道题有题目错误导致无法写题的情况了，谢谢 \_RSY\_ 管理。

~~所以我还得重新修改、提交题解并等待。~~

这道题的难点在于数学公式，至少第一眼十分复杂。
# 分析
首先理清思路，每个选手都有八个科目的竞赛成绩，题目中表达式 $i,j$ 使用次数过多，要仔细看待。

## 一条条分析罢

第一项和第三项是计算其他两项用到的中间过程量。
### 1.第 $j$ 项目的平均分 $ avg_j $

这个地方其实是该竞赛科目的平均分，注意是**该竞赛科目**不是每个选手。

### 2.选手 $i$ 的总分 $sumx_i$

这里大家就比较轻松了，就是这个选手所有八个科目的总成绩之和。

难点来力。
### 3.选手 $i$ 的 $j$ 项竞赛的位置分


这一坨式子要表达的意思是如果分母等于 $0$ 的时候这个选手这项竞赛位置分就等于 $0$。

分母是 $x_{i,j}-avg_j$，这里就用到了之前算出来的 $ avg_j $。

按照题干公式老老实实进行计算，一点一点看，其实也不是特别难搞懂。

注意观察一下**分母**，很明显 $n$ 个选手竞赛位置分在一个竞赛科目上分母都是一样的，如果我们**预先处理**出来这个分母，就可以大大缩短时间复杂度。

### 4.选手 $i$ 的总位置分 $sumy_i$

这个式子还算比较好理解，前三项的成绩是实打实的，后五项的成绩要乘上 $0.8$。

注意这里的**成绩**指的是**竞赛的位置分**，即上面刚刚计算过的第三项计算项目。
## 排序
又到了紧张刺激的排序阶段了。

优先级为:
1. 总位置分为先
2. 总分为次要
3. 编号为第三要点

使用 C++ 实现的话大致为以下：
```cpp
bool cmp(const edge &a, const edge &b)
{
    if (a.sum1 != b.sum1)//如果总位置分不同
        return a.sum1 > b.sum1;
    else if (a.sum != b.sum)//总分相同的情况下，总分不同
        return a.sum > b.sum;
    else//第三要点，排序编号位置
        return a.i < b.i;
}
```

# 其他事项

### 千万记得给两个位置分开个 double 
涉及到了小数位分数的运算，不开 double 的话会直接爆零。

### 输出的时候输出的是原始编号
虽然没什么人会犯这种低级错误，但是我确实在一场模拟赛中直接输出了排完序之后的编号。

~~那不就是 1 2 3 4 吗?~~

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
class edge// 相当于 struct 
{
public:
    int i, sum, ben[9];// i 代表编号， sum 代表总分 ben 代表八个成绩的原始分，从1开始用
    double sum1, wei[9];// sum1 代表总位置分 wei 代表各学科的位置分
} m[100010];
double xue[9];//各学科的总分
double wei_xue[9];//计算第三项的时候的分母
inline int read()//快读
{
    int x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')
        ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}
bool cmp(const edge &a, const edge &b)
{
    if (a.sum1 != b.sum1)//如果总位置分不同
        return a.sum1 > b.sum1;
    else if (a.sum != b.sum)//总分相同的情况下，总分不同
        return a.sum > b.sum;
    else//第三要点，排序编号位置
        return a.i < b.i;
}
int n;
int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= 8; j++)
            m[i].ben[j] = read(), m[i].sum += m[i].ben[j], xue[j] += m[i].ben[j], m[i].i = i;
    for (int j = 1; j <= 8; j++)//计算第三项的分母
    {
        xue[j] /= n;//取平均数
        int ans = 0;
        for (int k = 1; k <= n; k++)
            wei_xue[j] += abs(m[k].ben[j] - xue[j]);
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= 8; j++)
        {
            if (wei_xue[j])//计算第三项，如果等于 0 正好不需要处理
                m[i].wei[j] = (m[i].ben[j] - xue[j]) / (wei_xue[j] / n);
            if (j <= 3)//计算第四项
                m[i].sum1 += m[i].wei[j];
            else
                m[i].sum1 = m[i].sum1 + 0.8 * m[i].wei[j];
        }
    }
    sort(m + 1, m + 1 + n, cmp);
    for (int i = 1; i <= n; i++)
        printf("%d\n", m[i].i);
    return 0;
}
```
代码中仍有注释供大家参考。

题外话，我的博客：[hifumi](http://www.hifumi.cn/)。


我本来以为我的打法十分暴力但是没想到拿到了最优解榜一，实际上还有优化空间。

[提交记录详情](https://www.luogu.com.cn/record/86550238)

* 代码长度 1.45K
* 用时 16ms
* 内存 680.00KB

---

## 作者：Eason_AC (赞：2)

有一场比赛有 $n$ 个人参加，一共要参加 $8$ 场比赛。已知第 $i$ 位选手的第 $j$ 场比赛拿了 $x_{i,j}$ 分。另外还有一些重要指标：

- 第 $j$ 场比赛的平均分 $avg_j=\dfrac{\sum\limits_{i=1}^nx_{i,j}}{n}$。
- 第 $i$ 位选手的总分 $sum_{x_i}=\sum\limits_{j=1}^8x_{i,j}$。
- 第 $i$ 位选手在第 $j$ 场比赛的位置分 $y_{i,j}=\begin{cases}0&\sum\limits_{i=1}^n|x_{i,j}-avg_j|=0\\\dfrac{n\times (x_{i,j}-avg_j)}{\sum\limits_{i=1}^n|x_{i,j}-avg_j|}&\sum\limits_{i=1}^n|x_{i,j}-avg_j|\neq 0\end{cases}$。
- 第 $i$ 位选手的总位置分 $sum_{y_i}=\sum\limits_{j=1}^3y_{i,j}+0.8\sum\limits_{j=4}^8y_{i,j}$。

排名的规则如下：


- 总位置分高的选手名次在前；
- 若两个或两个以上的选手总位置分相同，则总分高的选手名次在前；
- 若两个或两个以上的选手总位置分和总分均相同，则编号在前的选手名次在前。

请求出第 $1\sim n$ 名的选手编号。

**数据范围：$n$ 未知，但亲测 $10^5$ 能过，$0\leqslant x_{i,j}\leqslant 100$。**
## Solution
除了式子有些复杂之外，这题就是一道纯粹的模拟。我们直接开个结构体来存储每个选手的指标以及每种竞赛的指标，然后直接按照上面的公式计算，最后利用结构体的 $\texttt{operator}$ 来排序之后直接输出就好。
## Code
```cpp
int n, x[100007][17], s[17];
double ave[17];
struct node {
	int sum, id;
	double pl[17], plsum;
	bool operator < (const node& rhs) const {
		if(plsum != rhs.plsum) return plsum > rhs.plsum;
		if(sum != rhs.sum) return sum > rhs.sum;
		return id < rhs.id;
	}
}a[100007];

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) {
		a[i].id = i;
		for(int j = 1; j <= 8; ++j) {
			scanf("%d", &x[i][j]);
			s[j] += x[i][j];
			a[i].sum += x[i][j];
		}
	}
	for(int j = 1; j <= 8; ++j)
		ave[j] = s[j] * 1.0 / n;
    double tmpsum[17] = {0};
	for(int j = 1; j <= 8; ++j)
		for(int i = 1; i <= n; ++i)
			tmpsum[j] += abs(x[i][j] - ave[j]);
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= 8; ++j) {
			if(tmpsum[j] == 0) a[i].pl[j] = 0;
			else a[i].pl[j] = (x[i][j] - ave[j]) * n * 1.0 / tmpsum[j];
		}
		for(int j = 1; j <= 3; ++j) a[i].plsum += a[i].pl[j];
		for(int j = 4; j <= 8; ++j) a[i].plsum += a[i].pl[j] * 0.8;
	}
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; ++i) printf("%d\n", a[i].id);
}
```

---

## 作者：_Luminous (赞：2)

### · 解题思路 & 方法


------------
其实刚看到这题~~我的内心几乎是崩溃的，这么多公式对我这个数学渣渣来说简直是天书~~ ，但是其实静下心来看，按照所给的公式打代码，~~只要你有手~~就能打出来，因为这只是个**模拟**而已，先求出题意中要求的所有值，再用**sort排序**就可以了。

看我前面说得那么简单，你肯定要骂我qwq，而且这题的公式乍一眼看确实不太好理解，为了理清思路，接下来我们根据题意一步一步打代码（中间可能会有代码重复，因为这是按照由浅到深的思维过程一点点完善代码）——

①求第 j 项竞赛的平均分 ：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=8;j++){
        cin>>x[i].score[j];
        avg[j]+=x[i].score[j];
    }
for(int j=1;j<=8;j++)
    avg[j]/=n;
```

②求选手 i 的总分 sum x_i ：
```cpp
（这个其实就是上一个代码的扩充）
for(int i=1;i<=n;i++){
    x[i].id=i;//保存这是第几个选手
    for(int j=1;j<=8;j++){
        cin>>x[i].score[j];
        x[i].sum+=x[i].score[j];
        avg[j]+=x[i].score[j];
    }
}
for(int j=1;j<=8;j++)
    avg[j]/=n;
```

③选手 i 第 j 项竞赛的位置分 ：
```cpp
（这一部分的公式是最复杂的，但其实也不难写。）
for(int i=1;i<=n;i++)
    for(int j=1;j<=8;j++)
        temp[j]+=abs(x[i].score[j]-avg[j]);//abs就是取绝对值
for(int j=1;j<=8;j++)
    temp[j]/=n;
for(int i=1;i<=n;i++)
    for(int j=1;j<=8;j++)
    	if(temp[j])
            x[i].wz[j]=(x[i].score[j]-avg[j])/temp[j];
```

④求选手 i 的总位置分 sum y_i ：
```cpp
for(int i=1;i<=n;i++){
    double temp=0,temp1=0;
    for(int j=1;j<=3;j++)
        temp+=x[i].wz[j];
    for(int j=4;j<=8;j++)
        temp1+=x[i].wz[j];
    temp1*=0.8;
    x[i].zwz=temp+temp1;
}
```

⑤按照题目中的排序规则排序 ~~（胜利的曙光就在眼前了！）~~ ：
```cpp
bool cmp(node a,node b){
	if(a.zwz==b.zwz){//如果总位置分相等，则继续判断总分
		if(a.sum==b.sum)//如果总分相等
			return a.id<b.id;//则直接按照编号从小到大排
		return a.sum>b.sum;
	}
	return a.zwz>b.zwz;
}
```

###  · Code

------------
（接下来是完整代码，无注释）
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
int n;
struct node{
    int score[9],sum,id;
    double avg,wz[9],zwz;
}x[1010];
double avg[9],temp[9];
bool cmp(node a,node b){
	if(a.zwz==b.zwz){
		if(a.sum==b.sum)
			return a.id<b.id;
		return a.sum>b.sum;
	}
	return a.zwz>b.zwz;
}
int main(){
	cin>>n;
    for(int i=1;i<=n;i++){
        x[i].id=i;
        for(int j=1;j<=8;j++){
        	cin>>x[i].score[j];
        	x[i].sum+=x[i].score[j];
        	avg[j]+=x[i].score[j];
		}
    }
    for(int j=1;j<=8;j++)
        avg[j]/=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=8;j++)
            temp[j]+=abs(x[i].score[j]-avg[j]);
    for(int j=1;j<=8;j++)
        temp[j]/=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=8;j++)
        	if(temp[j])
            	x[i].wz[j]=(x[i].score[j]-avg[j])/temp[j];
    for(int i=1;i<=n;i++){
        double temp=0,temp1=0;
        for(int j=1;j<=3;j++)
            temp+=x[i].wz[j];
        for(int j=4;j<=8;j++)
            temp1+=x[i].wz[j];
        temp1*=0.8;
        x[i].zwz=temp+temp1;
    }
    sort(x+1,x+1+n,cmp);
    for(int i=1;i<=n;i++)
    	cout<<x[i].id<<endl;
    return 0;
}
```


---

## 作者：Crasole (赞：2)

## 思路
 

知识：$\sum_{i = 1} ^ N  x_i = x_1 + x_2 + ... + x_N$。

- 第 $j$ 项竞赛的平均分 $avg_j = \frac{1}{N}\sum_{i = 1} ^ N x_{i, j}$。

第 $j$ 项竞赛平均分也就等于 $ (x_{1, j} + x_{2, j} + ... + x_{N, j}) \div N $。

- 选手 $i$ 的总分 $sumx_i = \sum_{j = 1} ^ 8 x_{i, j}$。

选手的总分就等于 $ x_{i, 1} + x_{i, 2} + x_{i, 3} + ... +x_{i, 8} $。

- 选手的 $i$ 的第 $j$ 项竞赛位置分：

$$ 
y_{i, j}= \begin{cases} 0 & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\right) \\ \frac{x_{i, j} - avg_j}{\frac{1}{N} \sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| \ne 0\right)\end{cases}
$$

别看公式有一长串，但实际求的是：

选手 $i$ 的第 $j$ 项竞赛减去第 $j$ 项竞赛的平均分 $avg_j$ 的差除以所有选手的第 $j$ 项竞赛成绩与第 $j$ 项竞赛的平均分 $avg_j$ 的差的绝对值之和。

但是由于 $\sum_{i = 1} ^ N |x_{i, j} - avg_i|$ 的值可能为 $0$，所以要分类讨论。

- 选手 $i$ 的总位置位置分 $sumy_i = \sum_{j = 1} ^ 3 y_{i, j} + 0.8\sum_{j = 4} ^ 8 y_{i, j}$。

与总分计算方法相似，等于 $y_{i, 1}+y_{i, 2}+y_{i, 3}+0.8 \times (y_{i, 4}+y_{i, 5}+y_{i, 6}+y_{i, 7}+y_{i, 8})$。

接着按照题意排序即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010,J=10;
double n,avg[J];
struct per{//用结构体per存储每个选手 
	double sumx,sumy,y[J],x[J]; 
	int id;
}a[1010];
void y_i_j(int i,int j){//选手i的第j项竞赛的位置分 
	double sum=0;
	for(int k=1;k<=n;k++)
		sum+=abs(a[k].x[j]-avg[j]);
	if(sum==0) a[i].y[j]=0;//判断是否为0 
	else {
		a[i].y[j]=(a[i].x[j]-avg[j])/(sum/n);
	}
}
bool cmp(per x,per y){//排序函数cmp 
	if(x.sumy==y.sumy&&x.sumx==y.sumx) return x.id<y.id;//如果sumx和sumy都相等则看编号 
	if(x.sumy==y.sumy) return x.sumx>y.sumx;//如果只有sumy相等则比较sumx 
	return x.sumy>y.sumy;//如果都不相等直接比较sumy 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=8;j++){
			cin>>a[i].x[j];
			avg[j]+=a[i].x[j];
			a[i].id=i;
			//输入，同时累加平均分、处理编号 
		}
	for(int i=1;i<=8;i++)
		avg[i]=avg[i]/n;//计算平均分 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=8;j++)
			a[i].sumx+=a[i].x[j];//计算sumx 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=8;j++)
			y_i_j(i,j);//计算y(i,j) 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=3;j++)
			a[i].sumy+=a[i].y[j]; 
		for(int j=4;j<=8;j++)
			a[i].sumy+=(a[i].y[j]*0.8);
	}//计算sumy 
	int t=n;
	sort(a+1,a+t+1,cmp);//排序 
	for(int i=1;i<=n;i++)
		cout<<a[i].id<<endl;	
	return 0;
}
```

---


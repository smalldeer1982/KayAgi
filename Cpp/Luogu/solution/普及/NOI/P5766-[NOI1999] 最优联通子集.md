# [NOI1999] 最优联通子集

## 题目描述

众所周知，我们可以通过直角坐标系把平面上的任何一个点 $P$ 用一个有序数对 $(x,y)$ 来唯一表示，如果 $x,y$ 都是整数，我们就把点 $P$ 称为整点，否则点 $P$ 称为非整点。我们把平面上所有整点构成的集合记为 $W$。

定义 1 ：两个整点 $P_1(x_1,y_1),P_2(x_2,y_2)$，若 $|x_1-x_2|+|y_1-y_2|=1$，则称 $P_1,P_2$ 相邻，记作 $P_1$~$P_2$ ，否则称 $P_1,P_2$ 不相邻。

定义 2 ：设点集 $S$ 是 $W$ 的一个有限子集，即 $S$=$\{P_1,P_2,…,P_n\}$ $(n \ge 1)$，其中 $P_i (1 \le i \le n)$ 属于 $W$，我们把 $S$ 称为整点集。

定义 3 ：设 $S$ 是一个整点集，若点 $R$,$T$ 属于 $S$ ，且存在一个有限的点序列 $Q_1,Q_2,…,Q_k$ 满足: 
1. $Q_i$ 属于 $S$ （$ 1 \le i \le k $）;
2. $Q_1$ = $R$,$Q_k$ = $T$;
3. $Q_i$~$Q_{i+1} (1 \le i \le k-1)$，即 $Q_i$ 与 
 $Q_{i+1}$ 相邻;
4. 对于任何 $1 \le i<j \le k$ 有 $Q_i≠Q_j$;

我们则称点 $R$ 与点 $T$ 在整点集 $S$ 上连通，把点序列 $Q_1,Q_2,…,Q_k$ 称为整点集 $S$ 中连接点 $R$ 与点 $T$ 的一条道路。

定义 4 ：若整点集 $V$ 满足：对于 $V$ 中的任何两个整点， $V$ 中有且仅有一条连接这两点的道路，则 $V$ 称为单整点集。

定义 5 ：对于平面上的每一个整点，我们可以赋予它一个整数，作为该点的权，于是我们把一个整点集中所有点的权的总和称为该整点集的权和。

我们希望对于给定的一个单整点集 $V$ ，求出一个 $V$ 的最优连通子集 $B$ ，满足：
1. $B$ 是 $V$ 的子集
2. 对于 $B$ 中的任何两个整点，在 $B$ 中连通；
3. $B$ 是满足条件 (1) 和 (2) 的所有整点集中权和最大的。


## 样例 #1

### 输入

```
5
0 0 -2
0 1 1
1 0 1
0 -1 1
-1 0 1
```

### 输出

```
2
```

# 题解

## 作者：include13_fAKe (赞：7)

## 前言
以前的 NOI 真的如此简单吗？
## 题意
给定一颗树，点有点权，求树上连通块的最大权值（可以是连通块的一部分）。
### 为什么一定是树呢？
题中已经说到，整点集 $V$ 是**单整点集**，即对于 $V$ 中的**任何两个整点**， $V$ 中**有且仅有**一条连接这两点的道路。

这不就是树的性质吗？
## 思路
树形 dp 模板题。

大多数的树形 dp 都是**从叶向根更新、传值**，这道题也不例外。

此题给出的是一棵无根树，但我们可以以 $1$ 结点为根。

设 $dp_u$ 表示在以 $u$ 为根的子树中找到的包含 $u$ 结点的所有连通块的最大权值。

对于所有 $u$ 的子结点 $v$，如果 $dp_v>0$，就让 $dp_u+=dp_v$（不然 $dp_u$ 反而变得更小了）。而 $u$ 结点是必选的，所以不要忘了在 $dp_u$ 中加上结点 $u$ 本身的权值（$C_u$）。

定义函数 
$$P(u,v)=\begin{cases}1&(u\text{ 是 }v\text{ 的父结点 })\\
0&(u\text{ 不是 }v\text{ 的父结点 })\end{cases}$$

将转移方程式写成 $\KaTeX$ 公式，就是这样的：
$$dp_u=C_u+\sum\limits_{i=1}^{n}\max(dp_v,0)\times P(u,v)$$
最终答案就是 $\max dp_i$ 了。

接下来就可以认真做题了。
## 注意事项
- $dp$ 数组的初值应该赋为 $-\infty$，因为 $C_i$ 可能为负。
- $dp_1$ 的值**不一定**是 $dp$ 数组中最大的。
- 由于 $n \le 10^3$，数据范围较小，所以可以通过枚举整点集 $V$ 中每个点对是否相邻即可，无需对点集排序。$n^2$ 的时间复杂度没有任何问题。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1005;
int n;
int x[N],y[N],c[N];
bool vis[N];
int dp[N];
vector<int> g[N];
void dfs(int u){
	vis[u]=true;
	dp[u]=c[u];
//	cout<<u<<endl;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(!vis[v]){
			dfs(v);
			if(dp[v]>0)	dp[u]+=dp[v];
		}
	}
	return;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i]>>c[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i!=j){
				if(abs(x[i]-x[j])+abs(y[i]-y[j])==1){
					g[i].push_back(j);
				}
			}
		}
	}
	dfs(1);
	int ans=INT_MIN;
	for(int i=1;i<=n;i++){
		ans=max(ans,dp[i]);
//		cout<<dp[i]<<endl;
	}
	cout<<ans<<endl;
	return 0;
} 
```



---

## 作者：zry……yrz (赞：5)

树形DP模板题

[又臭又长的题面](https://www.luogu.com.cn/problem/P5766)

补充本题数据范围： $2 \leq n \leq 1000$ ， $-10^6 \leq X_i,Y_i \leq 10^6$ ， $-100 \leq C_i \leq 100$ 。

------------


这道题目题面很长，其实题目本身很水，就是普通的树形DP。

和[这道题](https://www.luogu.com.cn/problem/P1122)非常相似，无非是这道题需要自己建一下边。

建完边后就可以发现其实该题就是一颗树，显而易见的树形DP。

用 $dp$ 数组表示以 $x$ 为根的子树中权和最大的子集并且一定包含 $x$ ;

若 $x$ 的子树权和大于 0 则加上，否则不加。

$dp[x]=\sum dp[v](dp[v]>0)$

最后再比较一下，取 $dp$ 数组中的最大值输出就可以了。

时间复杂度 $O(n^2)$



------------


其余说明详见代码如下。

```cpp
//いつもこのような人がいます。優しくしてあげたいです。
#include <bits/stdc++.h>
using namespace std;
struct node{
	int v,next;
}zry[2005];
int n,i,j,cnt,ans;
int x[1005],y[1005],head[1005],dp[1005];
inline int read()//快读
{
	int s=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=(s<<3)+(s<<1)+c-'0';
		c=getchar();
	}
	return s*f;
}
inline void build(int p,int q)
{
	cnt++;
	zry[cnt].v=q,zry[cnt].next=head[p];
	head[p]=cnt;
}
inline int js(int x,int fa)
{
	for(int i=head[x];i;i=zry[i].next)
	{
		if(zry[i].v!=fa)
		{
			js(zry[i].v,x);
			if(dp[zry[i].v]>0) dp[x]=dp[x]+dp[zry[i].v];//如果权和大于0则加上
		}
	}
}
signed main()
{
	n=read();
	cnt=0,ans=-998244353;
	memset(head,0,sizeof(head));
	for(i=1;i<=n;i++)
	{
		x[i]=read(),y[i]=read(),dp[i]=read();
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<i;j++)
		{
			if(abs(x[i]-x[j])+abs(y[i]-y[j])==1)//横纵坐标之差的和为一的两个点之间建边
			{
				build(i,j),build(j,i);//前向星建边
			}
		}
	}
	js(1,0);//树形DP
	for(i=1;i<=n;i++)
	{
		ans=max(ans,dp[i]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：过氧化氢_syq0057 (赞：2)

## 题外话

模拟赛 T1，来写题解了 /bx。

## Solution

光看题面全是定义感觉挺麻烦，但一精读就会发现很多定义都没太大用（但要好好看，我因没看到空集不是整点集挂了 $10pts$），简单来说就是曼哈顿距离为 $1$ 的点建边，然后求最大子树和。

我们设 $dp[u]$ 表示我选点 $u$ 的子树，于是有
$$
dp[u]= \sum \max(dp[v],0)
$$

注意我们不可以不选，于是 $ans$ 要初始化 $- \infty$。

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <functional>
#include <cmath>
#include <queue>
#include <map>
using namespace std;
const int N = 1000005;
const int M = 2000005;
#define ll long long
const int INF = 0x3f3f3f3f;
const int mod = 1000000007;
inline int read() {
	int x = 0, f = 1; char ch;
	ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
		x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}
int n;
int x[N], y[N], c[N];
int head[N], ver[M], Next[M], tot;
bool isok[N];
bool vis[N];
int dp[N];//dp[i]:以 i 为根的子树中选 i 的最大权值和 
int ans;
int Abs(int x) {
	return x > 0 ? x : -x;
}
int manhaten(int a, int b, int c, int d) {//(a,b) (c,d)
	return Abs(a - c) + Abs(b - d);
}
void ADD(int x, int y) {
	ver[++tot] = y;
	Next[tot] = head[x];
	head[x] = tot;
}
int Max(int x, int y) {
	if (x > y) return x;
	return y;
}
void dfs(int u) {
	vis[u] = 1;
	int v;
	for (int i=head[u]; ~i; i=Next[i]) {
		v = ver[i];
		if (!vis[v]) {
			dfs(v);
			dp[u] += Max(0, dp[v]);//注意这里！如果小于 0 我们肯定是不选的 
		}
	}
	dp[u] += c[u];
}
int main() {
// 	freopen("subset.in", "r", stdin);
// 	freopen("subset.out", "w", stdout);
	memset(head, -1, sizeof(head));
	scanf("%d", &n);
	for (int i=1; i<=n; ++i)
		scanf("%d%d%d", &x[i], &y[i], &c[i]);
	for (int i=1; i<=n; ++i) {
		for (int j=i+1; j<=n; ++j) {
			if (manhaten(x[i], y[i], x[j], y[j]) == 1)
				ADD(i, j), ADD(j, i), isok[i] = isok[j] = 1;
		}
	}
	for (int i=1; i<=n; ++i) {
		if (isok[i]) {
			dfs(i);
			break;
		}
	}
	for (int i=1; i<=n; ++i) {
//		printf("%d\n", dp[i]);
		ans = Max(ans, dp[i]);
	}
	printf("%d\n", ans);
// 	fclose(stdin);
// 	fclose(stdout);
	return 0;
}
```

---

## 作者：SmallTownKid (赞：1)

一开始以为第一篇题解是错的，其实是我理解错了，这个题保证没有环了。。所以不用特判环，当然判也可以。。我这个代码是判环的。

题目那么长 看懂了其实就很简单。

这个题显然是给你一个坐标纸，有一些点，求一个最大权值的连通块（可以是连通块的一部分）。

建图很简单，不赘述了，关键在于找这个最大权值的连通块，dfs，中文名是深度优先搜索，这个题正好用到了dfs的性质，我们dfs到最深处，然后回溯的时候更新答案，只需要判断v这个集合的权值是否大于0就行了，如果大于0，肯定是要更新u的集合权值的。否则不选它。这样确保了全局的答案正确性。

建图的时候可能出现环，所以我们用vis标记一下，防止死循环。

还有一个坑点，就是这个图不一定连通，所以每个点都要dfs一次，这里可以把一次dfs中所有遍历过的点用use数组标记出来，这样就不需要一个个点dfs了，只需要在图中找未被标记过的点就行了。
```
#include<bits/stdc++.h>
using namespace std;
int ans,n;
int head[100010],sum[100010],val[100010],x[100010],y[100010],vis[100010],use[100010];
struct node{
	int nxt,to;
}edge[100010];
int idx;
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
void dfs(int x,int fath)
{
	use[x]=1;
	vis[x]=1;
	sum[x]=val[x];//给点赋值 
	for(int i=head[x];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fath&&vis[v])//判环 
		continue;
		dfs(v,x);
		if(sum[v]>0)
		sum[x]+=sum[v];
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&val[i]);
	}
	for(int i=1;i<=n;i++)//枚举第一个点 
	{
		for(int j=i;j<=n;j++)//枚举第二个点 
		{
			if(abs(x[i]-x[j])+abs(y[i]-y[j])==1)
			{
				add(i,j);//点的标号从1开始 
				add(j,i);
			}
		}
	}
	for(int i=1;i<=n;i++)//图不一定连通，每个点都dfs一遍 
	{
		if(!use[i])
		{
			memset(vis,0,sizeof(vis));
			dfs(i,0);
		    ans=max(ans,sum[i]);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：mahaorui2012 (赞：0)

~~这题怎么越读越像阅读理解题呢？~~

# 题意

定义一：曼哈顿距离为1的两个点之间可以连一条边。

定义二：整点集就是一堆点的集合**空集不算整点集！！！**。

定义三：联通的两个点一定有至少一些点能把它们连起来，这些点组成了连接这两个点的一条“道路”。

定义四：如果一个整点集里的任意两个点**只有一条**“道路”，则称TA为一个“单整点集”。

定义五：每个点都有个权值，一个整点集里所有点上的权值的和就是TA的权和。

然后题目给我们输入了一个单整点集 $V$，求 $V$ 里的一个整点集 $B$，使 $B$ 里的所有点全都联通，并且权和是最大的。

另外根据一篇[题解](https://www.luogu.com.cn/blog/001060617268z/solution-p5766)说的，
$$2 \leqslant n \leqslant 10^3$$
$$10^6 \leqslant X_i,Y_i \leqslant 10^6$$
$$-100 \leqslant C_i \leqslant 100$$

看样子 $O(n^2)$ 能过。

=========================我是分割线==========================

# 分析

因为“单整点集”意味着两个点之间**有且只有一条**“道路”，所以其实一个“单整点集”**其实就是一颗树**。

那么我们搞一个数组 $f$，$f_i$ 表示包含点 $i$ 的权和最大的子整点集的权和（好绕），$next$ 数组表示 $f_i$ 连接的所有点，那么。

$$\Large f_i=\sum\limits_{j=0}^{len(next_i)}next_i[j]\quad \large (f_j>0)$$

想不到吧，是树形dp！

========================我还是分割线=========================

# $\color{#00FF00}AC \space Code$:

```c++
#include <iostream>
#include <cmath>
#include <cstring>
#include <vector>
#define INF 0x7ffffffe
using namespace std;

//============各种定义变量============ 
struct node{
	int x,y,c;
} nodes[1005];

int n;
vector<int> nxt[1005];
int dp[1005];

//============树形dp的函数============ 
void dpfunc(int cur,int father){
	dp[cur]=nodes[cur].c;
	for(auto i:nxt[cur]){
		if(i!=father && i!=cur){
			dpfunc(i,cur);
			if(dp[i]>0){
				dp[cur]+=dp[i];
			}
		}
	}
}

int main(){
	int ans=-INF;
	cin>>n;
	//============输入和建边============ 
	for(int i=0;i<n;++i){
		cin>>nodes[i].x>>nodes[i].y>>nodes[i].c;
	}for(int i=0;i<n;++i){
		for(int j=0;j<i;++j){
			if(abs(nodes[i].x-nodes[j].x)+abs(nodes[i].y-nodes[j].y)==1){
				nxt[i].push_back(j);
				nxt[j].push_back(i);
			}
		}
	}dpfunc(0,-1);
	//============统计答案============  
	for(int i=0;i<n;++i){
		if(dp[i]>ans){
			ans=dp[i];
		}
	}cout<<ans;
	return 0;
} 
```

---

## 作者：RiceFruit (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5766)

## 题目大意

给你一个整点集 $V$，让你求出它的一个子集 $B$，使得 $B$ 中任意两个整点都联通，且 $B$ 的点权和最大。

## 题目思路

因为题目中说了需要 $B$ 联通，所以我们不妨把所有相邻的点以父子关系存进一张图中，这样当我们取到以 $u$ 为根的子树时，可以保证它和下面每一个点联通。

接下来就是树形 $\texttt{DP}$ 了，我们设 $f_{x}$ 表示以 $x$ 为根的子树中，选取 $x$ 所得到的最大值。则转移方程为（设 $y_1,y_2\cdots y_t$ 为 $x$ 的子节点） 对于它的所有子节点 $f_{y_i}(1\le i\le x$) 若 $f_{y_i}>=0$，则加上 $f_{y_i}$，最后加上 $val_{x}$，即可得出转移式。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register
#define ri register int
#define ll long long
#define ull unsigned long long
#define lid (id<<1)
#define rid (id<<1|1)
void swap(int &x,int &y){int t=x;x=y;y=t;}
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
inline int read();
inline void write(int ans);
inline void put(int x,char c);
const int N=2e5;
int n;
struct sa{
	int nxt;
	int to;
}e[N];
struct node{
	int x,y,val;
	void in(){
		x=read();
		y=read();
		val=read();
	}
};
node a[N];
bool check(int u,int v){
	if(abs(a[u].x-a[v].x)+abs(a[u].y-a[v].y)==1)return true;
	return false;
}
int f[N];
int h[N],cnt,maxn;
void add(int u,int v){
	e[++cnt]=(sa){h[u],v};h[u]=cnt;
	return;
}
void dfs(int x,int fa){
	f[x]=a[x].val;
	for(int i=h[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(y==fa)continue;
		dfs(y,x);
		if(f[y]>0)f[x]+=f[y];
	}
	return;
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i].in();
	}
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			if(check(i,j))add(i,j),add(j,i);
		}
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)maxn=max(maxn,f[i]);
	put(maxn,'\n');
	return 0;
}
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void write(int x){if(x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x % 10+'0');return;}
inline void put(int x,char c){write(x);putchar(c);return;}

```

---


# [NOI1997] 最优乘车

## 题目描述

H 城是一个旅游胜地，每年都有成千上万的人前来观光。为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。

一名旅客最近到 H 城旅游，他很想去 S 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 S 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 S 公园。

现在用整数 $1 , 2 , … , N$ 给 H 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 $1$，S 公园巴士站的编号为 $N$。

写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 S 公园的过程中换车的次数最少。



## 样例 #1

### 输入

```
3 7
6 7
4 7 3 6
2 1 3 5
```

### 输出

```
2
```

# 题解

## 作者：Warriors_Cat (赞：74)

又来码题解咯~~

~~其实只是为了补一下咕值QAQ~~

首先，看到这一道题，我第一步想到的就是最短路。

为什么？~~蒟蒻的灵魂拷问QAQ~~

因为这道题在一定程度上是可以把公交车信息转化成一个图，而最少转车次数就是它的最短路。

所以，我们可以预处理出这样的一个图，然后就用堆优化$dijkstra$模板跑一遍最短路就可以了。

那么，我们怎么建图呢？

首先，在一条信息之内，每两个公交车站可以互相到达，不需要换车，于是这两个公车站之间的权值为$0$；

其次，对于同一个车站，我们可以枚举出两条信息都有没有包含这一个车站。如果有，就在它们之间连一条权值为$1$的边。

于是，建图就这样大功告成了！0^_^0

$Code$如下：

```cpp
void Add_nei(){
	for(int k = 1; k <= m; ++k){
		for(int i = 1; i < mp[k][0]; ++i){
			for(int j = i + 1; j <= mp[k][0]; ++j){
				int x, y, z, w;
				x = z = k;
				y = mp[k][i], w = mp[k][j];
				add(x * 1000 + y, z * 1000 + w, 0);//相同信息内两个车站的连边
			}
		}
	}
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= m; ++j){
			if(vis[j][i]){
				int x, y, z, w;
				x = j, y = i, w = i;
				for(int k = 1; k <= m; ++k){
					if(k == j) continue;
					if(vis[k][i]){
						z = k;
						add(x * 1000 + y, z * 1000 + w, 1);//相同车站的连边
					}
				}
			}
		}
	}
	return;
}
```

当然，这道题还有许多需要处理的地方：

$i.$输入。这里是以换行符为分界点来输入的。大家可以用手写快读来处理输入，我用的是$string$的$getline$输入。

$ii.$节点表示。因为这里涉及到公交车信息，所以我们需要同时存储信息编号和公交车站编号。但，为了前向星链表的存储，我是用的是哈希，节约空间。

$iii.$最后输出。注意输出时应当每个信息里的$n$号车站的最小值。

于是，这道题就这么结束了……

接下来上完整$Code$啦~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
#include <cctype>
#include <string>
using namespace std;
int m, n, mp[110][510], ans = 0x7fffffff;
bool vis[110][510];
string s;
struct edge{
	int v, w, nxt;
}e[2500010];
int head[2500010], cnt, dis[2500010];
inline void add(int u, int v, int w){//前向星 
	e[++cnt].v = v;
	e[cnt].w = w;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
void work(int k){//输入处理 
	int sz = s.size();
	for(int i = 0; i < sz; ++i){
		int x = 0;
		while(s[i] >= '0' && s[i] <= '9'){
			x = (x << 3) + (x << 1) + (s[i] ^ 48);
			++i;
		}
		mp[k][++mp[k][0]] = x;
		vis[k][x] = 1;
	}
	return; 
}
void Add_nei(){//建图 
	for(int k = 1; k <= m; ++k){
		for(int i = 1; i < mp[k][0]; ++i){
			for(int j = i + 1; j <= mp[k][0]; ++j){
				int x, y, z, w;
				x = z = k;
				y = mp[k][i], w = mp[k][j];
				add(x * 1000 + y, z * 1000 + w, 0);//相同信息内两个车站的连边
			}
		}
	}
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= m; ++j){
			if(vis[j][i]){
				int x, y, z, w;
				x = j, y = i, w = i;
				for(int k = 1; k <= m; ++k){
					if(k == j) continue;
					if(vis[k][i]){
						z = k;
						add(x * 1000 + y, z * 1000 + w, 1);//相同车站的连边
					}
				}
			}
		}
	}
	return;
}
struct node{
	int u, d;
	bool operator<(const node&rhs)const{
		return d > rhs.d;
	}
};
priority_queue <node> q;
void Dij(){//dijkstra模板 
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= m; ++j){
			dis[j * 1000 + i] = 0x3f3f3f3f;
		}
	}//最小值初始化最大 
	for(int i = 1; i <= m; ++i) dis[i * 1000 + 1] = 0;//车站1为0 
	for(int i = 1; i <= m; ++i) if(vis[i][1]) q.push((node){i * 1000 + 1, 0});
	while(!q.empty()){
		node data = q.top();
		q.pop();
		int u = data.u, d = data.d;
		if(d != dis[u]) continue;
		for(int i = head[u]; i; i = e[i].nxt){
			int v = e[i].v, w = e[i].w;
			if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				q.push((node){v, dis[v]});
			}
		}
	}
	return;
}
int main(){
	scanf("%d%d", &m, &n);
	getline(cin, s);
	for(int i = 1; i <= m; ++i){
		getline(cin, s);
		work(i);
	}
	Add_nei();
	Dij();
	for(int i = 1; i <= m; ++i) ans = min(ans, dis[i * 1000 + n]);//取最小值 
	if(ans == 0x3f3f3f3f){//注意特判 
		printf("NO"); 
		return 0;
	}
	printf("%d", ans);
	return 0;
}
```

这篇题解就到此结束了，求大家的资瓷QAQ

~~帮忙点个赞呗~~

## End

---

## 作者：Strong_Jelly (赞：41)

**做法 ：Floyd + 神奇思路**

**博客效果更佳：[传送门](https://www.cnblogs.com/qqq1112/p/12045742.html)**

**思路**：此题可以换个思路去想，以样例为例，我们不考虑换乘的次数，设同一条线路上的任意两点间的距离为1，同时不需要换乘，这时便可以惊奇的发现从1（起点）跑到n（终点）的最短路径 - 1即为正确答案！这是为什么呢？其原因是当需要换乘时，肯定会从当前线路上走到任意一点再进行换乘，至于为什么肯定会从当前线路上走到另外一点自己去想（或者评论私信问），从而换乘的次数就便是在任意一条路径上走的次数了（走完之后肯定会去换乘，最后走的一次除外）。当然我们最后答案必须减一，其原因就是当走到最后一条（再也不会换乘了）线路时，直接走到终点是不花换成次数的，而我们却记录了一次，所以最后要减一。数据很小，用Floyd实现就行了。

**本题坑点**：读入很坑，需要用字符串读入，还有记得把第一行行末空格给过滤掉，否则getline或gets会把这个回车也给读了。

**code**：
```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f//很大的数 
using namespace std;
int n, m, x, q[100001], f[1001][1001];
string s;
inline void floyd()//模板 
{
	for(register int k = 1; k <= n; ++k)
	{
		for(register int i = 1; i <= n; ++i)
		{
			for(register int j = 1; j <= n; ++j)
			{
				if(i != j && i != k && j != k)
				{
					f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
				}
			}
		}
	}
	return;
}
int main()
{
	memset(f, INF, sizeof(f));
	scanf("%d %d\n", &m, &n);//记得 + \n 
	while(m--)
	{
		int z = 0;
		getline(cin, s);//字符串读入 
		for(register int i = 0; i < s.length(); ++i)
		{
			x = 0;//记录当前答案 
			while(s[i] <= '9' && s[i] >= '0')//转换(遇到空格就退了) 
			{
				x = x * 10 + s[i] - '0';//当前所有位都向前移一位再加上最低位(转成数字) 
				++i;//不停的加 
			}
			q[++z] = x;//存储 
		}
		for(register int i = 1; i <= z; ++i)
		{
			f[i][i] = 0;//自己到自己是0 
			for(register int j = i + 1; j <= z; ++j)
			{
				f[q[i]][q[j]] = 1;//车站任何一位到除了自己以外的任何一位的距离都是1 
			}
		}
	}
	floyd();//经典算法 
	if(f[1][n] == INF)//到不了 
	{
		printf("NO");//注意一本通上的这道题是N0，但好像不影响，没有这种数据 
	}
	else
	{
		printf("%d", f[1][n] - 1);//记得 - 1 
	}
	return 0;
}
```


---

## 作者：x_miracle (赞：35)

**核心思路：Dijkstra算法**

------------

首先，我认为这道题最重要的是建图，解释一下我是如何建图：

（题目中说明了是“**单程**巴士线路”，故图为有向图。）

样例：
![](https://cdn.luogu.com.cn/upload/image_hosting/ue25y66b.png)

（线路的站点就是节点，边上的数字就是指这条边属于哪一条线路）

由样例图可以看出，1->7的最少换乘的次数是2次：

1->3  换乘  3->6  换乘 6->7 

但如果只是单纯的作模拟，这道题就失去了意义。

我们不妨这样建图：

**将每一条线路的站点，都与这条线路的起点相连。**

![](https://cdn.luogu.com.cn/upload/image_hosting/t8rkn89r.png)

**在同一条线路上的节点，对于最后的换乘数是没有贡献的。** 也就是说，同一条线路上的点是等价的。

而将每个点都与起点相连，**是因为不能确定后来读入的线路是否与先前的线路存在换乘点。** 所以干脆就全连上。

这样一来，**图中1->n的最短路，就是最小换乘数+1。**

------------

然后，讲这道题如何读入。

我看已有的许多的题解中，是用字符串读入的。大可不必。

我们可以利用**空格**和**换行符**来读入。

像这样：

```cpp
while(c!=-1 && c!='\r')	//'\n'
{
	scanf("%d",&a[ ++n ]);
	c=-1;
	scanf("%c",&c);
}
```

（这个'/r'和洛谷的测评姬有关）

------------

难度评分：建议绿题

理由：这题在Dijkstra模板题的基础上，增加了对Dijkstra的理解应用，同时这道题卡读入。

附上代码：
```cpp
#include <bits/stdc++.h>
#define MAXN 510
#define MAX 0x3f3f3f3f
using namespace std;
int ori=1,node;	//ori 起点   node 节点数 
int a[5005];	//存输入 
int dis[MAXN],g[MAXN][MAXN];
bool vis[MAXN]; 
void init()			//初始化 
{
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
	vis[ori]=1;
	for(int i=1;i<=node;++i)		dis[i] = (i == ori ? 0 : g[ori][i]);
}
void Dijkstra()		//朴素Dijkstra 
{
	int k;	init();
	for(int i=1;i<=node-2;++i)
	{
		int m=MAX;
		for(int j=1;j<=node;++j)
		{
			if(dis[j]<m && vis[j]==0)
			{m=dis[j];	k=j;}
		}
		if(m==MAX)		break;
		vis[k]=1;
		for(int j=1;j<=node;++j)
			if(dis[k]+g[k][j]<dis[j])
				dis[j]=dis[k]+g[k][j];	
	}
	return ;
}
int main()
{
	int edge;
	scanf("%d%d",&edge,&node);
	for(int i=1;i<=node;++i)
		for(int j=1;j<=node;++j)
			g[i][j]=MAX;
	for(int i=1;i<=edge;++i)
	{
		memset(a,0,sizeof(a));
		int n=0;				//计数器 
		char c=1;
		while(c!=-1 && c!='\r')	//'\n'
		{
			scanf("%d",&a[ ++n ]);
			c=-1;
			scanf("%c",&c);
		}
		for(int j=1;j<n;++j)
			for(int k=j+1;k<=n;++k)
				g[ a[j] ][ a[k] ]=1;
	}
	Dijkstra();
	if(dis[node]>=MAX) printf("NO");
    	else printf("%d",dis[node]-1);	//换乘数为最短距离-1 
	return 0;
}
```



---

## 作者：cunzai_zsy0531 (赞：17)

题目链接[Link](https://www.luogu.com.cn/problem/P5767)

一道简单图论题，主要难点在于建图。

![](https://cdn.luogu.com.cn/upload/image_hosting/27y2bhji.png)

我们把同一条线路上的所有车站之间全部连一条边，这样就可以直接利用bfs求得最短距离，因为bfs只要到达终点就一定是最短的。

上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=500+21;
int g[N][N],a[N];//因为数据范围较小所以可以直接使用邻接矩阵 
struct node{int u,dep;}q[N];
bool vis[N];
int n,m;
int bfs(int s){
	memset(vis,0,sizeof(vis));//初始化是好习惯 
	q[0]=(node){s,0};
	vis[s]=1;
	int head=0,tail=1;//head头指针，tail尾后指针，这样比较好写。 
	while(head<tail){
		node p=q[head++];
		if(p.u==n)return p.dep-1;
		int u=p.u;
		for(int v=1;v<=n;v++){
			if(g[u][v]&&vis[v]==0){
				q[tail++]=(node){v,p.dep+1};
				vis[v]=1;
			}
		}
	}
	return -1;
}
int main(){
	scanf("%d%d",&m,&n);
	for(int p=1;p<=m;++p){
		int cnt=0;
		scanf("%d",&a[++cnt]);
		char ch=getchar();//读入需要注意 
		while(ch==' '){
			scanf("%d",&a[++cnt]);
			ch=getchar();
		}
		for(int i=1;i<=cnt;i++)
			for(int j=i+1;j<=cnt;j++)g[a[i]][a[j]]=1;
	}
	int ans=bfs(1);
	if(ans==-1)cout<<"NO"<<endl;
	else cout<<ans<<endl;
	return 0;
}
```

谢谢大家！


---

## 作者：菜鸡咕 (赞：8)

## 解题思路
这道题是一道**BFS**，难点在于BFS要求**代价相同**，而这道题在搜的时候可能会出现在同一辆车上，经过两站后代价就变成**2**的情况，这样的话**代价就不相等**，所以我们要预处理，将巴士和站的关系转化成一个**01矩阵**，就可以进行广搜了。
## 参考程序

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
using namespace std;
struct abc{
	int ans,zhan;
}f[10000010];
int n,m,bus[1100][1100],a[2100],hd=1,tl=1;
char x;
bool check(int q,int p)//判断
{
	if(!bus[q][p])
		return 0;
	if(a[p])
		return 0;
	return 1;
}
int main()
{
	cin>>m>>n;
	for(int i=0;i<=m;i++)//快读加预处理
	{
		memset(a,0,sizeof(a));
		a[0]=1;
		do{
			x=getchar();
			if(isdigit(x))
				a[a[0]]=a[a[0]]*10+x-48;
			else
				a[0]++;
		}while(x!='\n'&&x!=EOF);
		a[0]--;
		for(int j=1;j<=a[0]-1;j++)//转换成01矩阵
			for(int k=j+1;k<=a[0];k++)
				bus[a[j]][a[k]]=1;
	}
	f[1].ans=-1;f[1].zhan=1;
	memset(a,0,sizeof(a));//循环利用，下面用作标记到达的情况，防止跳码。
	while(hd<=tl)
	{
		for(int i=1;i<=n;i++)
		{
			if(check(f[hd].zhan,i))
			{
				tl++;
				f[tl].ans=f[hd].ans+1;
				f[tl].zhan=i;
				a[f[tl].zhan]=1;//标记
				if(f[tl].zhan==n)
				{
					cout<<f[tl].ans<<endl;
					return 0;
				}
			}
		}
		hd++;
	}
	cout<<"NO"<<endl;
} 
```

---

## 作者：Licykoc (赞：7)

**没有P党，赶紧来交个题解~~水估值~~**

这题是个很好的最短路练手题，当然其他题解也有用`bfs`做的，不过本蒟蒻刚学`Dijkstra`,就用`Dijkstra`来做此题。

题目多读几遍就学会了如何建图，至于具体的话其他题解讲的也很细，可以去康康）。

本题的坑点就是输入，但`Pascal`语言可以很$Easy$的解决，`eoln`函数就是判断当前输入是否有换行,使用`not eoln`函数就可以将一整行的数字输入啦！

```pascal
j:=0; //读入指针
while not eoln do begin 
  inc(j);  //指针++
  read(a[j]); //读入
end;
```

这样本题就没什么难点啦：

$Code:$

```pascal
uses math;//调用math库，包含了max,min等函数
var
  i,j,k,n,m,l,t,g:longint;
  v:array[0..10000] of boolean; //Dijkstra算法中判断已加入的端点数组
  f:array[0..701,0..701] of longint; //保存建图的数组
  dis,a:array[0..10000] of longint; //记录最后答案的数组
begin
  readln(m,n);
  filldword(f,length(f),maxlongint);
  //这个函数就是将f数组全置为maxlongint即2147483647
  for i:=1 to m do begin
    j:=0;
    while not eoln do begin inc(j); read(a[j]); end;
	for k:=1 to j do 
	  for t:=k+1 to j do 
	    f[a[k],a[t]]:=1;
	readln;
  end;
  
  //以上为建图
  
  filldword(dis,length(dis),maxlongint);
  
  //接下来是Dijkstra算法的模板
  dis[1]:=0;  
  for i:=1 to n-1 do begin
    t:=maxlongint;
	for j:=1 to n do if (not v[j])and(dis[j]<t) then begin t:=dis[j]; g:=j; end;
	v[g]:=true;
	for j:=1 to n do if (not v[j])and(f[g,j]>0) then dis[j]:=min(dis[j],dis[g]+f[g,j]);
  end;
  if dis[n]=maxlongint then write('NO') //特判
    else write(dis[n]-1);
end.
```


---

## 作者：Prean (赞：7)

这道题坑了我好久呢。。。。。。

首先这道题的输入就很坑，我决定使用getchar输入。
```cpp
while(m--)
{
	char x;bool flag=true;vector<int>ans;
   while(flag)
  	{
      int num=0;
      while(x=getchar())
      {				
      if(isdigit(x))num*=10,num+=x-'0';	
      else if(x==' ')break;	
      else{flag=false;break;}
      }ans.push_back(num);
 	 }
    for(i=0;i<ans.size();++i)
    	for(j=i+1;j<ans.size();++j)
    	  a[ans[i]][ans[j]]=true;	
}
```
ans是用来存车站的顺序的，然后左边的车站能到右边的全部车站，为了防止WA，我就不是只连接右边的一个车站，而是像上面的那样

然后，只有30分。。。。。。我就猜到了那30分的答案全是-1。。。。。。

于是我思考了半个月，终于想到了一个方法，就是整行读入getline+字符串string，然后再加上判断十进制整数超级快的isdigit函数，最终我的时间只有32ms

```cpp
while(m--)
{
	vector<int>ans;int l,num=0;
	getline(cin,s);l=s.length();
	for(i=0;i<=l;++i)
	if(isdigit(s[i]))num*=10,num+=s[i]-'0';//判断十进制整数
	else ans.push_back(num),num=0;//否则是空格，把数塞进去，num归零
     for(i=0;i<ans.size();++i)
     	for(j=i+1;j<ans.size();++j)
     		a[ans[i]][ans[j]]=true;//连接图
}
```
然后就是算法了。这道题我选用的是Dijkstra算法，因为我看数据范围是500，怕Floyed会超时。
```cpp
for(j=1;j<=n;++j)
{
	int mi=INF,x;
	for(i=1;i<=n;++i)if(!flag[i]&&d[i]<mi)mi=d[i],x=i;//找最小点
	flag[x]=true;//标记
	for(i=1;i<=n;++i)if(!flag[i]&&a[x][i])d[i]=min(d[i],d[x]+1);//因为是换乘，所以只要+1就行了
}
```
最后，完结撒代码：
```cpp
#include<bits/stdc++.h>
#include<vector>
using namespace std;
int n,m,mx,d[1005];bool flag[1005],a[1005][1005];
const int INF=0x7fffffff;string s;
int main()
{
	int i,j;ios::sync_with_stdio(false);
	cin>>m>>n;getline(cin,s);//输入的时候会有换行符
	while(m--)
	{
		vector<int>ans;int l,num=0;
		getline(cin,s);l=s.length();
		for(i=0;i<=l;++i)if(isdigit(s[i]))num*=10,num+=s[i]-'0';
		else ans.push_back(num),num=0;
		for(i=0;i<ans.size();++i)for(j=i+1;j<ans.size();++j)
		a[ans[i]][ans[j]]=true;
	}for(i=2;i<=n;++i)d[i]=INF;//初始化
	for(j=1;j<=n;++j)
	{
		int mi=INF,x;
		for(i=1;i<=n;++i)if(!flag[i]&&d[i]<mi)mi=d[i],x=i;
		flag[x]=true;
		for(i=1;i<=n;++i)if(!flag[i]&&a[x][i])
		d[i]=min(d[i],d[x]+1);
	}if(d[n]!=INF)cout<<d[n]-1;else cout<<"NO";
}
```

---

## 作者：KaguyaH (赞：6)

> [P5767](https://www.luogu.com.cn/problem/P5767).

---

**Changelog:**

更新简化代码、$\LaTeX$、分析过程，加入读入方式注解。

---

容易想到最短路或搜索一类的算法。

我们考虑将每个车站视为一个节点建图，进而我们想到对于每个点向其一次乘车可达的点连有向边。

这样的话，两点间最短距离即为从一个车站到另一个车站的最少乘车次数。

那么，最少换乘次数即为最少乘车次数减一。

---

这里由于数据范围较小，可以直接用 Bellman-Ford 暴力松弛。BFS 也可。

时间复杂度 $\mathcal O(mn^2)$，空间复杂度 $\mathcal O(mn)$。

---

本题读入有些特殊，做一些注释。

就是每次读入一个字符。读入非数字字符时判断是否为换行符或文件结束符。

`isdigit(int)` 函数定义在头文件 `cctype` 中，可用来判断字符是否为数字字符。

    static inline const void read_bus(vector& bus) {
        char u;
        while (not isdigit(u = getchar()));
        // 过滤掉行首空白字符，跳出后 u 中应为本行第一个数字字符。
        // 无负数，不必考虑符号
        while (true) {
            // 注意循环开始时 u 中存储了一位数字
            hu t(0);
            while (t = t * 10 + (u - '0'), isdigit(u = getchar()));
            // t 为当前读入的数值，逗号作为运算符从左计算（左结合）返回右侧值
            bus.push_back(t);
            bool brk(false);
            do { if (u == '\n' or u == EOF) { brk = true; break; } }
            while (not isdigit(u = getchar()));
            if (brk) break;
            // 读入非数字位，若有换行符或文件结束符则退出循环
        }
        for (hu i(0); i < bus.size(); ++i) for (hu j(i); j < bus.size(); ++j)
            out[bus[i]].push_back(bus[j]); // 连边
    }

---

```cpp
# include <cctype>
# include <cstdio>
# include <cstring>
# include <vector>

namespace Main {
    namespace Source {
        typedef short unsigned int hu;
        typedef std::vector<hu> vector;
        static inline const hu min(const hu a, const hu b) { return b < a ? b : a; }
        static inline const void amin(hu& a, const hu b) { a = min(a, b); }
    }
    using namespace Source;
    enum { M = 100, N = 500 };
    static hu m, n;
    static vector bus[M];
    static vector out[N + 1];
    static hu ans[N + 1];
    static inline const void read_bus(vector& bus) {
        char u;
        while (not isdigit(u = getchar()));
        while (true) {
            hu t(0);
            while (t = t * 10 + (u - '0'), isdigit(u = getchar()));
            bus.push_back(t);
            bool brk(false);
            do { if (u == '\n' or u == EOF) { brk = true; break; } }
            while (not isdigit(u = getchar()));
            if (brk) break;
        }
        for (hu i(0); i < bus.size(); ++i) for (hu j(i); j < bus.size(); ++j)
            out[bus[i]].push_back(bus[j]);
    }
    static inline const void main() {
        scanf("%hu%hu", &m, &n);
        for (hu i(0); i < m; ++i) read_bus(bus[i]);
        memset(ans, 0x7f, sizeof ans), ans[1] = 0;
        for (hu i(0); i < n; ++i)
            for (hu j(1); j <= n; ++j)
                for (hu k(0); k < out[j].size(); ++k)
                    amin(ans[out[j][k]], ans[j] + 1);
        if (ans[n] == ans[0]) puts("NO");
        else printf("%hu\n", ans[n] ? ans[n] - 1 : 0);
    }
}

signed int main() { Main::main(); return 0; }
```



---

## 作者：flyfree (赞：4)

捋一捋思路：

问最小换乘次数，巴士站和巴士线路又长得像一个图，想到最短路。

求什么设什么，自然会想到把边权的意义设为换乘次数。

但想象一下建出的图，只有零边，显然没法做。

该怎么解决呢？两种方法。

法一：

这种我觉得是比较好想的（~~因为第一遍做的时候我就是这么想的~~）：拆点。

把每个点拆成m个点，每条巴士线路一套点，根据读入建零边。每个巴士站的所有巴士线路之间两两建边。然后dijkstra求最短路（感觉不是单源的？感性理解一下，把1号巴士站拆成的m个点看作一个大点，是一样的），在n号巴士站拆成的m个点的最短路中求一个最小值即可。

显然，这样会出现很多建了但根本用不到的边和点。
所以具体实现不用真的把那些边权为1的边建出来的（占空间），只建零边即可（这样边权也省了）。我们只会用到读入中涉及到的点，所以读入时顺便记录一下用到的点，可以加速。

放下代码

```
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int N=50005;
int m,n,x,y,last,head[N],sum;
int dis[N];
bool vi[N],use[N];
char xx;
struct edge{int to,next;}a[N];
struct node
{	int num,dis;
	bool operator < (const node x) const
	{	return x.dis<dis;}
};
priority_queue <node> f;
void insert(int x,int y)
{	sum++;a[sum].to=y;a[sum].next=head[x];head[x]=sum;}
void dijkstra()
{	memset(dis,0x7f,sizeof(dis));
	for(int i=1;i<=m;i++)
	{	if(use[i])
		{ dis[i]=0;f.push((node){i,0});}
	}
	int x,y,z;
	while(!f.empty())
	{	x=f.top().num;f.pop();
		if(vi[x]) continue;
		vi[x]=true;
		for(int i=head[x];i;i=a[i].next)
		{	y=a[i].to;//用零边更新
			if(dis[y]>dis[x])
			{	dis[y]=dis[x];
				f.push((node){y,dis[y]});
			}
		}
		y=x%m;z=x-y;
		if(y==0) z=x-m;
		for(int i=1;i<=m;i++)
		{	y=z+i;//用边权为1的边更新
			if(use[y]&&dis[y]>dis[x]+1)
			{	dis[y]=dis[x]+1;
				f.push((node){y,dis[y]});
			}
		}
	}
}
int main()
{	scanf("%d %d",&m,&n);
	for(int i=1;i<=m;i++)
	{	scanf("%d",&last);
		xx=getchar();
		while(xx==' ')
		{	scanf("%d",&x);
			insert((last-1)*m+i,(x-1)*m+i);//建零边，反正都是零边，就不用边权了
			use[(last-1)*m+i]=use[(x-1)*m+i]=true;//记录有没有用到
			last=x; 
			xx=getchar();
		}
	}
	dijkstra();
	x=0xffffff;
	y=(n-1)*m;
	for(int i=1;i<=m;i++)
	if(dis[y+i]<x) x=dis[y+i];
	if(x==0xffffff) printf("NO\n");
	else printf("%d\n",x);
	return 0;
}
```

法二：

个人感觉这个方法特别巧妙。发现上述建图行不通后，不考虑拆点，考虑改变边权的意义，使边权不是0。于是想到 **最少换乘次数=最少乘车次数-1**，这样，就建出了一个边权全部为1的图，bfs,floyd,dijkstra……随便用什么求最短路都行

注意：这里建边时，对于每条公交线路，每个巴士站必须向在它后面的每个巴士站都连边，而不能像法一一样只向后一个建边。因为法一是零边，向后一个连，就相当于向每个都连了零边，边权不为零就不行了。

---


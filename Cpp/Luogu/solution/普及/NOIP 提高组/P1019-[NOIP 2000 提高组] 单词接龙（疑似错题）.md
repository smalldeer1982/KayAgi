# [NOIP 2000 提高组] 单词接龙（疑似错题）

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。

## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# 题解

## 作者：RyanLi (赞：38)

传送门：[P1019 [NOIP 2000 提高组] 单词接龙](https://www.luogu.com.cn/problem/P1019)

更佳的阅读体验：[洛谷 P1019 题解](https://blog.ryanli.top/index.php/archives/248/)

---

题目没有给字符串的数据范围，但有 $n \le 20$，尝试搜索发现可以通过本题。

在搜索时处理重合部分为本题难点，需要留意截取字串的边界问题（即下文代码 `dfs()` 函数中的 $i$ 和 $j$）。

```cpp
#include <iostream>
using namespace std;

const int N = 30;
int n, vis[N], ans;
string s[N];
char c;

void dfs(const string &tmp) {
    ans = max(ans, int(tmp.size()));
    for (int i = 1; i <= n; ++i) {
        if (vis[i] >= 2) continue;
        for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
            if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                ++vis[i];
                dfs(tmp + s[i].substr(j));
                --vis[i];
            }
    }
}

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> s[i];
    cin >> c;
    for (int i = 1; i <= n; ++i) if (s[i][0] == c) {
        ++vis[i];
        dfs(s[i]);
        --vis[i];
    } cout << ans << '\n';
    return 0;
}
```

---

## 作者：__yiLIUyi__ (赞：15)

# 题解：P1019 [NOIP 2000 提高组] 单词接龙
[题目传送门](https://www.luogu.com.cn/problem/P1019)
## 题意
给出 $n$，然后给出 $n$ 个单词，最后给出一个字符 $char$，将单个单词连接成一个长度为 $len$ 且以字符 $char$ 开头的字符串，使得 $len$ 尽可能大，输出 $len$。

**连接时要注意**：
- 每个单词最多使用两次；
- 第一个单词要以 $char$ 开头；
- 后一个单词的开头部分应与前一个单词的结尾部分相同（也就是题目中所说的“重合部分”）；
- 应保证重合部分的长度**最多必须小于**这两个单词的长度。或者说，两个单词不能互相包含；
- 连接后，重合的部分会被覆盖。
## 思路
**搜索**。

我们依次枚举所有可能的排列情况，每一次都更新最大长度 $len$，最后输出。

首先，我们需要一个函数来判断已有的总字符串和新加入的单词的重合部分长度是多少。或者说，有几位是重合的。如果这个长度为 $0$，则说明这个单词不能被添加（没有重合部分）。

```cpp
ll check(string s1,string s2){
	ll num=min(s1.size(),s2.size());
	for(ll i=1;i<num;i++){//枚举可能的长度
		bool f=true;//用来判断是否相同
		for(ll j=0;j<i;j++)//对比每一位
			if(s1[s1.size()-i+j]!=s2[j]){
				f=false;//如果不相同则判断为否
				break;
			}
		if(f==true) return i;//如果判断为正，返回重合部分的长度
	}return 0;//否则说名不能被添加，返回0
}
```

对于搜索部分，我们通过 $n$ 次循环依次判断是否能在总字符串后面添加对应的单词。如果不行，则直接进行下一次循环；否则添加新单词，进行递归，然后回溯。再进行下一次循环。当然，如果这个单词已经使用过两次，也直接进行下一次循环。

```cpp
void dfs(string st,ll num){//num是当前总字符串的长度
	len=max(num,len);//更新最大长度
	for(ll i=0;i<n;i++){//枚举n个单词
		if(a[i]>=2) continue;//如果使用次数大于2，跳过
		ll m=check(st,str[i]);//记录重合部分长度
		if(m>0){//如果m大于0，也就是说可以被添加
			a[i]++;//单词使用次数增加
			dfs(str[i],num+str[i].size()-m);//递归
			a[i]--;//回溯
		}//m等于0就不进行操作
	}return;
}
```

特别要强调的是，这其中的 $st$ 是最近添加的单词，而不是总的字符串。因为我们在通过函数计算重合部分长度时，应保证该长度小于前后两个单词的长度。而如果使用总字符串，无法确定上一个单词从哪里开始。
## 代码实现
刚才思路部分给出了主要代码，所以这里代码中仅对个别地方进行了注释。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a[20],len,n;//a记录每个单词使用次数
string str[20];//记录每个单词
ll check(string s1,string s2){
	ll num=min(s1.size(),s2.size());
	for(ll i=1;i<num;i++){
		bool f=true;
		for(ll j=0;j<i;j++)
			if(s1[s1.size()-i+j]!=s2[j]){
				f=false;
				break;
			}
		if(f==true) return i;
	}return 0;
}
void dfs(string st,ll num){
	len=max(num,len);
	for(ll i=0;i<n;i++){
		if(a[i]>=2) continue;
		ll m=check(st,str[i]);
		if(m>0){
			a[i]++;
			dfs(str[i],num+str[i].size()-m)
			a[i]--;
		}
	}return;
}
int main(){
	cin>>n;
	for(ll i=0;i<=n;i++)
		cin>>str[i];//特别强调：这里把最后输入的首字母作为单词中的一个输入
	dfs(' '+str[n],1);
	cout<<len;
	return 0;
}
```

---

## 作者：yedalong (赞：10)

## Solution
考虑预处理一个数组 $g$，$g_{i,j}=k$ 表示第 $i$ 个字符串和第 $j$ 个字符串的最小重合长度为 $k$，$0$ 则表示这两个字符串没有重合。  

那么这个 $g$ 该怎样预处理呢？这里介绍一个对于 `string` 类型的好东西：`substr`。这函数可以截取一个字符串内你所指定的子串。那么这预处理就很简单了。由于是要让接出来的龙尽可能长，因此，要从小到大枚举字符串 $a_i$ 和 $a_j$ 的重合部分，一有发现，立刻退出循环。  

对于搜索部分也挺简单的。对于找到符合条件的字符串搜索下去即可，需要回溯。  

## AC code


```cpp
#include <bits/stdc++.h>
using namespace std;
string a[25];int n,maxx,pd[25],g[25][25];
void dfs(string s,int k){
    maxx=max(maxx,(int)s.size());
    pd[k]++;
    for(int i = 1;i<=n;i++){
        if(g[k][i]&&pd[i]<2){
            dfs(s+a[i].substr(g[k][i]),i);
        }
    }
    pd[k]--;
}
int main(){
    cin>>n;
    for(int i = 1;i<=n;i++) cin>>a[i];
    char s;cin>>s;
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=n;j++){
            for(int k = 1;k<min(a[i].size(),a[j].size());k++){
                if(a[i].substr(a[i].size()-k,k)==a[j].substr(0,k)){
                    g[i][j]=k;
                    break;
                }
            }
        }
    }
    for(int i = 1;i<=n;i++){
        if(a[i][0]==s){
            dfs(a[i],i);
        }
    }
    cout<<maxx;
}
```

---

## 作者：kungeruyi (赞：7)

**解题思路**

>枚举每一个用可能的单词，然后判断单词的开头是否和上个单词的结尾相同，如果相同就继续枚举，如果一个都没有，就回溯。

**AC Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=66;
int n,t,ans,v[N]; 
string s[N];
void dfs(string x){
    ans=max(t,ans);
    int g=x.size();
    for(int i=1;i<=n;i++){
        if(v[i]<2){
            int len;
            for(len=1;len<g && len<s[i].size();len++){
                if(x.substr(g-len,len)==s[i].substr(0,len)){
					break;	
				}
            }
            if(len<g && len<s[i].size()){
                v[i]++; 
                t+=s[i].size()-len;
                dfs(s[i]);
                t-=s[i].size()-len; 
                v[i]--; 
            }
        }
    }
    return ;
}
int main(){
    char c;
    cin>>n;
    for(int i=1;i<=n;i++){
		cin>>s[i];	
	}
    cin>>c;
    for(int i=1;i<=n;i++){
        if(s[i][0]==c){
            v[i]++; 
            t=s[i].size();
            dfs(s[i]);
            v[i]--;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：SuyctidohanQ (赞：4)

### 思路分析

UPD：修改了代码。

本题为搜索。考虑使用 `dfs` 枚举以指定字母开头的单词开始，连接所有可能的单词的单词串的长度。

注意还需要使用一个数组保证每个单词使用次数不超过 $2$ 次。

### 代码实现

```cpp
#include <bits/stdc++.h>
#define please return
#define AC 0
#define rep(i, a, b) for (int i = a; i <= b; i++)
using namespace std;
const int MAXN = 20 + 10;
string S[MAXN];
int n, ans = 0, cnt[MAXN];
char c;
int check (string x, string y) {
	string a = "", b = "";
	rep(i, 1, min (x.size (), y.size ()) - 1) {	
		a = x.substr (x.size () - i, i);
		b = y.substr (0, i);
		if (a == b) return i;	
	}
	return 0;
}

void dfs (string s, int len) {
	ans = max (ans, len);
	int x;
	rep(i, 1, n) {	
		x = check (s, S[i]);
		if (cnt[i] < 2 && x != 0) {	
			cnt[i] ++;
			
			dfs (S[i], len + S[i].size () - x);		
			cnt[i] --;
			
		}
		
	}
	
}
signed main (void) {
	cin >> n;
	rep(i, 1, n) cin >> S[i];
	cin >> c;
	rep(i, 1, n) {
		
		if (S[i][0] == c) {
			
			cnt[i] ++;
			dfs (S[i], S[i].size ());
			cnt[i] --;
			
		}
		
	}

    cout << ans << endl;
	
	please AC;
}
```

---


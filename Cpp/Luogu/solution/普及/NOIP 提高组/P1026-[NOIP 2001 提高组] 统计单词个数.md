# [NOIP 2001 提高组] 统计单词个数

## 题目描述

给出一个长度不超过 $200$ 的由小写英文字母组成的字母串（该字串以每行 $20$ 个字母的方式输入，且保证每行一定为 $20$ 个）。要求将此字母串分成
 $k$ 份，且每份中包含的单词个数加起来总数最大。  

每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 `this` 中可包含 `this` 和 `is`，选用 `this` 之后就不能包含
 `th`。

单词在给出的一个不超过 $6$ 个单词的字典中。

要求输出最大的个数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$2 \le k \le 40$，$1 \le s \le 6$。

【样例解释】
划分方案为 this / isabookyoua / reaoh

**【题目来源】**

NOIP 2001 提高组第三题

## 样例 #1

### 输入

```
1 3
thisisabookyouareaoh
4
is
a
ok
sab
```

### 输出

```
7
```

# 题解

## 作者：千反田 (赞：19)

这里讲一下我和其他题解有点不一样的思路QAQ

~~首先珂以知道这是一道DP~~

这道题的思路和[P1018乘积最大](https://www.luogu.org/problem/P1018)的思路有点像

把一个单词分成 $k$ 份就相当于在单词中放置 $(k-1)$ 条分割线

### 为方便说明，下文把 $(k-1)$ 直接用 $k$ 表示

设 $f[i][j]$ 为在第 $i$ 个字母后放第 $j$ 个分割线，前 $i$ 个单词所能获得的最大价值

**注意每份单词不能为空**

最后统计答案的时候在 **$f[i][k](k<=i<=n-k)+(i+1,n)$对答案的贡献**，扫一遍取个 $max$

### case1：如何转移？

我的想法还是比较暴力的，首先初始化 $f[i][1]$ 全部为初始化为$(1,i)$这个区间对答案的贡献

第一层循环$j$枚举**正在放置第$j$个分割线**$(2<=j<=k)$；

第二层循环$i$枚举分割线放置的位置$(j<=i<=n-1)$;

最后一层循环$l$枚举从前面的哪个状态转移过来

也就是在($f[l][j-1]$+$(l+i,i)$这个区间对答案的贡献)中取 $max$ $(j-1<=l<=i-1)$

```cpp
rep(i,1,n-1)
 f[i][1]=query(1,i);
rep(j,2,k)
 rep(i,j,n-1)
  rep(l,j-1,i-1)
   f[i][j]=max(f[i][j],f[l][j-1]+query(l+1,i));
```
$query(l,r)$既区间$(l,r)$对答案的贡献

### case2:如何统计一个区间对答案的贡献

显然一个区间对答案的贡献就是一个区间中字典中单词个数(去重后)

题目中给出了一个限制:**当选用一个单词之后，其第一个字母不能再用。**

那我们就珂以依次对字典中的每个字符串进行匹配，如果匹配成功就将该字符匹配位置的开头标记为匹配过，下回如果匹配到同一位置既不合法，跳过该次匹配

```cpp
//本人习惯字符串下标从1开始
inline int cnt(int index,int l,int r){
	int len=r-l-strlen(word[index]+1)+2,res=0;//len为匹配次数，res为该字符串的贡献
	rep(i,0,len-1)
	 rep(j,1,strlen(word[index]+1))
	  if((word[index][j]^str[l+i+j-1])||(trace[l+i]))
	   break;
	  else
	   if(j==strlen(word[index]+1))
	    ++res,trace[l+i]=true;
	return res;
}
inline int query(int l,int r){ 
	rep(i,l,r)
	 trace[i]=false;
	int res=0;
	rep(i,1,s)//依次对每个字符串进行匹配
	 if(r-l+1>=strlen(word[i]+1))//如果区间长度>字符串长度
	  res+=cnt(i,l,r);//统计该字符串的贡献
	return res;
}
```

## 祭上代码：
```cpp
#include<bits/stdc++.h>
#define rint register int
#define rc register char
#define rll register long long 
#define rep(i,j,k) for(rint i=j;i<=k;++i)
#define dow(i,j,k) for(rint i=j;i>=k;--i)
#define MAXN 205
#define N 10
int p,k,ans=0,s,n;
char str[MAXN];
int f[MAXN][MAXN];
char word[N][MAXN];
bool trace[MAXN];
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}//手写较快
inline int cnt(int index,int l,int r){
	int len=r-l-strlen(word[index]+1)+2,res=0;//len为匹配次数，res为该字符串的贡献
	rep(i,0,len-1)
	 rep(j,1,strlen(word[index]+1))
	  if((word[index][j]^str[l+i+j-1])||(trace[l+i]))
	   break;
	  else
	   if(j==strlen(word[index]+1))
	    ++res,trace[l+i]=true;
	return res;
}
inline int query(int l,int r){ 
	rep(i,l,r)
	 trace[i]=false;
	int res=0;
	rep(i,1,s)//依次对每个字符串进行匹配
	 if(r-l+1>=strlen(word[i]+1))//如果区间长度>字符串长度
	  res+=cnt(i,l,r);//统计该字符串的贡献
	return res;
}
void calc(){/程序核心dp
	rep(i,1,n-1)
     f[i][1]=query(1,i);
    rep(j,2,k)
     rep(i,j,n-1)
      rep(l,j-1,i-1)
       f[i][j]=max(f[i][j],f[l][j-1]+query(l+1,i));
    rep(i,k,n-k)
     ans=max(ans,f[i][k]+query(i+1,n));
}
void Debug(){//个人调试用
	rep(i,1,s)
	 printf("%s\n",word[i]+1);
	rep(i,1,n)
	 rep(j,1,k)
	  printf("f[%d][%d]=%d\n",i,j,f[i][j]);
}
int main(){
	scanf("%d %d\n",&p,&k);
	--k;//分割线数量
	rep(i,1,p)
	 scanf("%s",str+20*(i-1)+1);//s每次输入把字符串拼接到下标为20*(i-1)+1上，+1是因为下标从1开始
	n=strlen(str+1);
	scanf("%d",&s);
	rep(i,1,s)
	 scanf("%s",word[i]+1);//下标从1开始
	calc();
	//Debug();
	printf("%d\n",ans);
} 
```
~~第一次提交忘了把Debug注释掉居然还有20？你谷评测机太玄学~~

---

## 作者：KobeBeanBryantCox (赞：8)

# P1026 [NOIP 2001 提高组] 统计单词个数 题解

-------------

[题目传送门](https://www.luogu.com.cn/problem/P1026)。

怎么这个这么老的题没题解啊？

-------------

## 题意

看题目描述去。略。

--------------

## 思路

这一看就是 DP 啊。

设 $dp_{i,j}$ 表示处理完前 $i$ 个字符，划分了 $j$ 段的最大个数（答案）。

非常简单，有 $dp_{i,j}=\max_{k=1}^{i}\{dp_{k-1,j-1}+w_{k,i}\}$，其中 $w_{i,j}$ 表示区间 $[i,j]$ 所能包含的最大个数（不划分）。

设字符串长度为 $n$，这个转移是 $O(n^2k)$ 的。

考虑怎么算这个 $w_{i,j}$。

注意到开头的字符的位置不能重用，但是非开头的可以。

这就说明了我们可以贪心啊。能包含进去我就包含。

证明是简单的。考虑我不包含这个，包含另一个进去，对答案的贡献都是 $1$，且不影响其他单词的加入。

所以这两者发现是等价的。所以不妨直接贪心能包含就包含。

然后你在扫描的过程中顺便维护 $w$ 和之前出现过的位置（表示接下来不能用这些位置）即可。

所以就有以下代码：

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=i;j<=n;j++)vis[j]=false;
	for(int j=i;j<=n;j++)
	{
		w[i][j]=w[i][j-1];
		for(int k=1;k<=m;k++)
		{
			int l=j-siz[k]+1;
			if(l<i||vis[l])continue;
			if(get(l,j,a)==get(1,siz[k],b[k]))w[i][j]++,vis[l]=true;
		}
	}
}
```

其中 $get$ 是得到哈希值。

~~题目没说单词的长度是多少，所以我就用了哈希（其实暴力匹配应该是能过的，因为单词的长度貌似不长？）~~

这部分时间复杂度为 $O(n^2s)$。如果您暴力匹配，时间复杂度是 $O(m\times n^2s)$，其中 $m$ 是单词的长度。

--------------

## AC 代码

注意细节，比如前 $i$ 个字符不能分出 $>i$ 个数的段，这在我的 $dp$ 转移中可以体现。

不会哈希的话可以去洛谷的模板题看看。或者采取暴力扫描匹配。

注意要开 ll，如果您暴力匹配的话就不用开了。

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
const int N=210,B=131,mod=998244353; // 居然不卡单模哈希！
int power[N];
void init(int n){power[0]=1;for(int i=1;i<=n;i++)power[i]=power[i-1]*B%mod;}
void calc(string s,int a[]){for(int i=1;i<=s.size();i++)a[i]=(a[i-1]*B+s[i-1])%mod;}
int get(int l,int r,int a[]){return (a[r]-a[l-1]*power[r-l+1]%mod+mod)%mod;}
int a[N],b[10][N],siz[10];
int w[N][N];bool vis[N];
int dp[N][50];
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	string s="",t;
	int m,kk;cin>>m>>kk;
	while(m--)cin>>t,s+=t;
	init(s.size()),calc(s,a);
	cin>>m;
	for(int i=1;i<=m;i++)cin>>t,siz[i]=t.size(),calc(t,b[i]);
	int n=s.size();
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)vis[j]=false;
		for(int j=i;j<=n;j++)
		{
			w[i][j]=w[i][j-1];
			for(int k=1;k<=m;k++)
			{
				int l=j-siz[k]+1;
				if(l<i||vis[l])continue;
				if(get(l,j,a)==get(1,siz[k],b[k]))w[i][j]++,vis[l]=true;
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=min(kk,i);j++)
			for(int k=j;k<=i;k++)dp[i][j]=max(dp[i][j],dp[k-1][j-1]+w[k][i]);
	cout<<dp[n][kk];
	return 0;
}
```

---------------

若有错或讲述不清，欢迎评论或私信。

---

## 作者：cwxcplh (赞：5)

废话不多说，多说的不是废话，我们直接进入正题。

**题目简化：** 没什么好简化的，自己看[题目](https://www.luogu.com.cn/problem/P1026)去。

首先，让我们来回顾一下区间 DP 的知识。

区间 DP，即对一个区间内的元素进行合并或拆分的操作，在满足要求的前提下求出最小（或最大）代价。

好，让我们回到这道题上。题目中的“分割成 $k$ 个部分”这句话，看上去不就很像一个区间 DP 吗？因为这是分割型 DP（具体定义详见[这篇文章](https://blog.csdn.net/cwplh/article/details/147073064?sharetype=blogdetail&sharerId=147073064&sharerefer=PC&sharesource=cwplh&spm=1011.2480.3001.8118)），所以我们定义的 DP 状态 $dp_{i,j}$ 表示前 $i$ 个字符分割成 $j$ 个区间的最大个数，那么状态转移方程就可以写成这样：

$$dp_{i,j}=\max^i_j\{dp_{k-1,j-1}+a_{k,i}\}$$

其中 $a_{i,j}$ 表示从第 $i$ 个字符到第 $j$ 个字符中的单词数。

现在我们就需要考虑一下这个 $a_{i,j}$ 怎么求了。

我这里提供一种思路：我们可以把 $a_{i,j}$ 也当做一个 DP，那么 $a_{i,j}$ 首先就肯定要继承上一个状态，即 $a_{i,j}=a_{i,j-1}$，然后我们看看当前从 $i$ 到 $j$ 这个字符串中有没有单词。

但我相信很多人都能看出来其中的问题：这个字符串里的同一个单词在上次和这次会被重复计算。我又想到了一个办法：我只需要找后几个字母构成的“词”是不是单词就行了，而这个“词”的长度就是单词的长度。

由于本人怕跑循环会 TLE，但又不会哈希，于是决定用 STL，不会 STL 中的 `string` 的 `find` 的用法的同学见[这篇文章](https://blog.csdn.net/dislike_shuati/article/details/143688893?ops_request_misc=%257B%2522request%255Fid%2522%253A%252230a8e44b1449b43dd245ebfaede18a44%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=30a8e44b1449b43dd245ebfaede18a44&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-143688893-null-null.142^v102^pc_search_result_base3&utm_term=string%E7%9A%84find%E7%94%A8%E6%B3%95&spm=1018.2226.3001.4187)。

[提交记录，完美 AC。](https://www.luogu.com.cn/record/212573913)

**代码：**

```cpp
#include<bits/stdc++.h>
#define int long long
#define npos string::npos
using namespace std;
int n,m,kk,vis[206],siz[16],a[206][206],dp[206][46];
string s,ss[16];
signed main()
{
    s+=" ";
    cin>>m>>kk;
    while(m--)
    {
        string t="";
        cin>>t;
        s+=t;
    }
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>ss[i];
        siz[i]=ss[i].size();
    }
    n=s.size()-1;//这里注意！！！
    for(int i=1;i<=n;i++)
    {
        string t="";
        memset(vis,0,sizeof(vis));
        for(int j=i;j<=n;j++)
        {
            a[i][j]=a[i][j-1];
            t+=s[j];
            int l=t.size();
            for(int k=1;k<=m;k++)
            {
                if(l-siz[k]<0||vis[l-siz[k]])
                {
                    continue;
                }
                if(t.rfind(ss[k])==l-siz[k])//详见上面的文章
                {
                    a[i][j]++;
                    vis[l-siz[k]]=1;
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=min(i,kk);j++)
        {
            for(int k=j;k<=i;k++)
            {
                dp[i][j]=max(dp[i][j],dp[k-1][j-1]+a[k][i]);
            }
        }
    }
    cout<<dp[n][kk];
    return 0;
}
```

---

## 作者：uncle_steve (赞：3)

## 解题思路：

### 直接暴力：

直接暴力枚举 $k$ 部分的方案，再求最大值，发现会 TLE。

### 正解（区间 DP）：

首先用 $dp_{i,k}$ 表示前 $i$ 个数形成了 $k$ 段数字的最大答案，再 init 函数预处理 $pre[l,r]$，最后通过离线算法处理单词个数（STL 中字符串 find 函数），三重循环即可。

状态转移方程：$dp_{i,k}=\max(dp_{i,k},dp_{j,k-1}+pre_{j+1,i})；$

设字符串长度为 $n$，这个转移是 $O(n^2k)$ 的。

**坑点：可能同一个位置会有多个单词开始，但是只计数一个单词。**

```
1 2
then
2
the 
then
```
答案应该是 1。

## 代码：


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e5 + 10;
string str, s;
int p, k, n, x;
vector<string> v;
int dp[202][44];
int pre[202][202];

inline bool check(int l, int r) {
    string tem = s.substr(l, r - l + 1);
    for(auto x : v) {
        if(r - l + 1 >= x.size()) {
            if(tem.find(x) == 0) return 1;
        } 
    }
    return 0;
}

void init() {  // 预处理pre[l, r]
    for(int r = n; r >= 1; r--) {    // r 也可以从前往后
        for(int l = r; l >= 1; l--) {
            pre[l][r] = pre[l + 1][r];
            if(check(l, r)) pre[l][r]++; 
        }
    }
}

int main() {
    cin >> x >> k;
    while(x--) {
        cin >> str;
        s += str;
    }
    s = " " + s;
    n = s.size() - 1;
    if(k > n - 1) {
        puts("0");
        return 0;
    }
    cin >> p;
    for(int i = 1; i <= p; i++) {
        cin >> str;
        v.push_back(str);
    }

    init();

    for(int K = 1; K <= k; K++) {  // K <= k
        for(int i = 1; i <= n; i++) {  //  i < n
            for(int j = K - 1; j < i; j++) {
                dp[i][K] = max(dp[i][K], dp[j][K - 1] + pre[j + 1][i]);
            }
            // cout << "i: " << i << " k: " << K << "dp[i][K]: " << dp[i][K] << endl;
        }
    }
    cout << dp[n][k] << endl;
    return 0;
}

```

---

## 作者：tangzirui1016 (赞：3)

刚写完**乘积最大**的题解又来做这道题，发现这两道题竟然如出一辙。

就连 dp 的思路也一模一样。 

或许你可以先读一读[这一篇文章](https://www.luogu.com.cn/article/40gtaj23)。

定义 $dp_{i,j}$ 表示前 $i$ 个字母划分 $j$ 次的最大结果。$ans_{a,b}$ 表示字符串区间 $[a,b]$ 的答案，枚举上一步操作，取最大，得到转移方程： 

$$dp_{i,j}=\max_{j\le k < i}dp_{k,j-1}+ans_{k+1,i}$$

当然，这题也有坑点，要划分成 $k$ 段，就是要划分 $k-1$ 次。

难点在于如何求 $ans_{a,b}$。

先考虑最基础的，给你一个区间，如何求答案数？

其实先不用管题目限制，先把单词填进去，再用一个标记记录哪一些角标被当作开头，答案即为被标记的角标个数。这样就可以满足题目要求了。

或许有点抽象，依旧画个图理解。
![](https://cdn.luogu.com.cn/upload/image_hosting/5tyrqyk1.png)
这样做既简单又可以得到正确答案。

设字母串的总长为 $L$。所以查询一个区间的答案的时间复杂度大致为 $O(L\times s^2)$。枚举所有区间，总的复杂度为 $O(L^3\times s^2)$。

但是这样的复杂度我们不能接受，因为顶着上限计算后足有 $2\times 10^8$ 计算量之多，很容易超时。

那么如何优化呢？

我们可以把一些区间的答案**联系**起来。如区间 $[1,5]$ 应该是区间 $[1,3]$ 的答案和区间 $[4,5]$ 的答案之和加上把这两个区间拼接起来产生的新答案。发现这个过程很像**分治**。

我们可以每次向后推一个字母，再来算这一个字母和前面的小区间新产生的答案，这样就可以得到这个大区间的答案了。

这样做只需要枚举一个区间开头，再往后推，每次推一个字母，算答案时先加上**上一个区间的答案**，再算这个字母和上个区间**连接**起来产生的新答案。由于每次只新加一个字母，因此时间复杂度为 $O(L^2\times s^2)$。

$$ans_{i,j}=ans_{i,j-1}+newans(j,[i,j])$$

再算产生的新答案时，我们可以逆向枚举。

我觉得这道题用到两个 dp 都很巧妙，尤其是第二个。  

至此，完美地解决了这道题，时间复杂度为 $O(L^2\times s^2 + L^2\times k)$。  

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200,K=40;
int p,k,n,m,dp[N+5][K+5],ans[N+5][N+5];
string s,a[10];
void init(){ 
	bool vis[N+5]={};
	for(int i=1;i<=m;i++){
		memset(vis,0,sizeof(vis)); 
		//每次开一个新区间都要把标记清空 
		for(int j=i;j<=m;j++){
			ans[i][j]=ans[i][j-1]; 
			//先加上上一区间答案 
			for(int x=1;x<=n;x++){ //枚举每个单词来匹配 
				if(i+a[x].size()-1>j) continue; 
				//长度比单词都短，肯定没戏 
				bool flag=0;
				for(int y=0;y<a[x].size();y++){ 
					if(s[j-y]!=a[x][a[x].size()-y-1]) flag=1;
					//这里是逆向匹配 
				} 
				if(!flag){
					int beg=j-a[x].size()+1;
					if(!vis[beg]) ans[i][j]++,vis[beg]=1; 
					//注意vis标记 
				}
			}
		}
	}
}
int main(){
	cin>>p>>k;
	k--; //注意是k段，切k-1次 
	for(int i=1;i<=p;i++){
		string w;
		cin>>w;
		s+=w;
	}
	m=s.size();
	s=" "+s; //先给字符串偏移一下，对好下标 
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	init(); //预处理ans[i][j] 
	for(int i=1;i<=m;i++) dp[i][0]=ans[1][i];
	for(int j=1;j<=k;j++){
		for(int i=1;i<=m;i++){
			for(int x=j;x<i;x++){
				dp[i][j]=max(dp[i][j],dp[x][j-1]+ans[x+1][i]); 
			}
		}
	}
	cout<<dp[m][k];
	return 0;
} 
```

---


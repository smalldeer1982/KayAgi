# [NOIP 1996 提高组] 挖地雷

## 题目描述

在一个地图上有 $N\ (N \le 20)$ 个地窖，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后每次可以移动到一个编号比当前节点大且联通的节点去挖地雷，当无满足条件的节点时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。

## 说明/提示

**【样例解释】**
![](https://img.picui.cn/free/2025/05/15/6825a221c60ba.png)
最优路径为 $1 \to 3 \to 4 \to 5$，结果为 $27$。

**【题目来源】**

NOIP 1996 提高组第三题。

## 样例 #1

### 输入

```
5
10 8 4 7 6
1 1 1 0
0 0 0
1 1
1
```

### 输出

```
1 3 4 5
27```

# 题解

## 作者：公主殿下MIKU (赞：333)

本题那么好的一道dfs爆搜题，为啥要用DP？（~~本蒟蒻不会DP~~）

思路很简单，由于n很小，完全可以枚举每一个点当起点，
同时记录路径；下面贴代码

神奇分割线

------------
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<queue>
using namespace std;
bool f[21][21];//记录是否有路径相连
int a[21];//记录地雷数
int path[21],ans[21],cnt;//path记录路径，ans记录答案，cnt记录走了多少个点
bool b[21];//记录该点是否走过
int n;
int maxx;//记录挖的最大地雷数
bool chck(int x)//检查是否还能继续往下挖
{
	for(int i=1;i<=n;i++)
	{
		if(f[x][i]&&!b[i]) return false;
 	}
 	return true;
}
void dfs(int x,int stp,int sum)//x记录现在位置，stp记录走了几个点，sum记录挖的地雷数
{
	if(chck(x))
	{
		if(maxx<sum)//更新最大值和路径
		{
			maxx=sum;
			cnt=stp;
			for(int i=1;i<=stp;i++)
			ans[i]=path[i];	
		}
		return ;
	}
	for(int i=1;i<=n;i++)//寻找下一个能去的地方
	{
		if(f[x][i]&&!b[i])
		{
			b[i]=1;//标记走过
			path[stp+1]=i;//记录路径
			dfs(i,stp+1,sum+a[i]);
			b[i]=0;//回溯
		}
		
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	for(int i=1;i<n;i++)
	for(int j=i+1;j<=n;j++)
	{
		cin>>f[i][j];//这里是单向边，题目没啥清楚，导致我调了半个小时；
	}
	for(int i=1;i<=n;i++)
	{
		b[i]=1;
		path[1]=i;//记录起点
		dfs(i,1,a[i]);
		b[i]=0;
	}
	for(int i=1;i<=cnt;i++)
	cout<<ans[i]<<' ';
	cout<<endl<<maxx;
	return 0;
}
```
华丽的结束。

-----
安利一下我的[博客](https://me.csdn.net/weixin_43795131)。

求管理大大给过。

---

## 作者：Drawing_Yang (赞：195)

## 分析

看各位大佬用的基本上都是逆推的思想,本蒟蒻就发一个顺推的把.其实也不难想.定义状态$f[i]$为以第$i$个节点结束的最大值,则$f[i]=max \{ f[j]\}+a[i]\ \ (g[j][i]=1)$,这样就不难写出代码来了.至于输出,用一个$pre[i]$数组存储$i$的前驱结点,递归输出即可.

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int n,a[205],g[205][205],pre[205],t,f[205],ans;
void print(int x) {
	if (pre[x]==0) {
		printf("%d",x);
		return;
	}
	print(pre[x]);
	printf(" %d",x); 
}
int main() {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",a+i);
	for (int i=1;i<n;i++) {
		for (int j=i+1;j<=n;j++) {
			int x;
			scanf("%d",&x);
			if (x==1) g[i][j]=1;
		}
	}
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=n;j++) {
			if (g[j][i]&&f[j]>f[i]) {
				f[i]=f[j];
				pre[i]=j;
			}
		}
		f[i]+=a[i];
		if (f[i]>ans) {
			ans=f[i];
			t=i;
		}
	}
	print(t);
	printf("\n%d",ans);
	return 0;
}
```

---

## 作者：vectorwyx (赞：192)

蒟蒻来发题解了~


------------
由于正解是DP，那我们就用DP

（尽管数据很水可以搜索）


------------
老样子，DP考虑3件事：数组、方程、初始化


------------
## 一.数组
通过对线性动规的学习我们知道

这类题目的数组大多都是一个一维数组

这题作为典型题目之一，自然逃不出一维数组的手掌心

我们**用$dp_{i}$表示挖地雷时以点i为终点所能挖到的最大地雷数**

用$a_{i}$表示第$i$个点的地雷数

然后**用顺推的方式从2一直推到$n$**

最后输出$dp$数组存储的最大值即可


------------
## 二.方程
我们可以借鉴一下最长XX子序列的思路：
```cpp
for(int i=2;i<=n;++i){
		dp[i]=0;
		for(int j=i-1;j>0;--j){
			if(a[i]>a[j]){
				dp[i]=max1(dp[i],dp[j]);
			}
		}
		dp[i]++;
		if(dp[i]>ans) ans=dp[i];
	}
```
对于$dp_{i}$，用$j$从1到$i$-1枚举

如果从$j$到$i$有路可走且$dp_{j}$>$dp_{i}$

那就把$dp_{i}$的值更新为$dp_{j}$

枚举结束后把$dp_{i}$的值加上第$i$个点的地雷数

一句话，**找出点$j$使得$j$<$i$，$dp_{j}$为最大值且$i,j$之间有通路**

**再加上第$i$个点的地雷数**

状态转移方程：

$dp_{i}$=$a_{i}$ + $\max$($dp_{1}$ , $dp_{2}$ $\ldots$ $ dp_{i-1}$)

------------
## 三.初始化
首先，$dp_{1}$=$a_{1}$

其次，对于$dp_{i}$（2<=$i$<=$n$），有两种选择：

一是都初始化为0

二是都初始化为$a_{i}$

前者需在枚举完之后加上$a{i}$，但判断条件较为简略

后者不需再加上$a_{i}$，但判断条件略显繁琐

笔者在此选后者


------------
代码来了~||ヽ(*￣▽￣*)ノミ|Ю
```cpp
#include<iostream>
#include<cstdio>
#define maxn 201//数组开大一点
#define fo(x) for(register int i=1;i<=x;++i)//宏定义，省事
using namespace std;
bool rd[maxn][maxn];
//rd[i][j]记录i到j是否是通路
//dp[i]表示以i为终点所能挖到的最大地雷数 
//a[i]表示第i个点的地雷数
int a[maxn],dp[maxn],p[maxn],pos;//p[i]表示i的前趋 
void DFS(int x){//倒着输出
	if(p[x]) DFS(p[x]);//如果x有前趋，继续搜
	cout<<x<<" ";
}
int main(){
	int n,ans=0;
	cin>>n;
	fo(n) scanf("%d",&a[i]);
	fo(n-1)
		for(register int j=i+1;j<=n;++j){//按格式输入路径
			scanf("%d",&rd[i][j]);
		}
	dp[1]=a[1];//初始化
	for(register int i=2;i<=n;++i){//从2开始到n结束
		dp[i]=a[i];//初始化
		for(register int j=i-1;j>0;--j){//枚举寻找最大值
			if(rd[j][i]&&dp[i]<dp[j]+a[i]){
            //有路径且大于目前的最大值
				dp[i]=dp[j]+a[i];//更新
				p[i]=j;//记录i的前趋为j
			}
		}
		if(ans<dp[i]){//更新答案
			 ans=dp[i];
			 pos=i;//记录取点的位置
		}
	}
	DFS(pos);//先输出最优路径
	cout<<endl<<ans;//再输出答案
	return 0;//后话：此题可概括为“最长连通子序列”
}
```


---

## 作者：sshwy (赞：70)

### 楼上诸位均有DP/图论之类的算法

### 本尊也不多说，记忆化搜索（）思维简单

------

# 思路


- d[i]:从i出发能获得的最多的地雷数量
- next[i]:相应的路径
- w[i]:i结点原有的地雷数量


- count(u)
	- 对于从u出发能到达的每一个与u相邻的结点i
		- if (d[i]未计算)d[i]=count(i);
		- 记录v=max{d[i]},k为v的对应的结点
	- next[u]=k;
	- return v+w[u];

## 主算法

- 对于每一个入度为0的点z
	- d[z]=count(z);
	- 记录y=max{d[z]},x为对应的结点
- while(x!=-1)
	- 输出x
	- x=next[x]
- 输出y 

------

# 代码
```cpp
#include<iostream>

using namespace std;

int n,a,y,x;
int d[30],w[30],id[30],next[30];
bool linker[30][30];

int count(int u)
{
	if(d[u])return d[u];
	int v=0,k=-1;
	for(int i=1;i<=n;i++)
		if(linker[u][i])
		{
			if(d[i]==0)d[i]=count(i);
			if(d[i]>v)v=d[i],k=i;
		}
	next[u]=k;
	return v+w[u];
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>w[i];
		id[i]=0;
		next[i]=-1;
	}
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			cin>>a;
			if(a)linker[i][j]=true,id[j]++;
		}
	for(int i=1;i<=n;i++)
		if(id[i]==0)
		{
			d[i]=count(i);
			if(d[i]>y)y=d[i],x=i;
		}
	while(x!=-1)
	{
		cout<<x<<' ';
		x=next[x];
	}
	cout<<endl<<y;
	return 0;
}
```

---

## 作者：田阙西 (赞：47)

就是个升级版拦截导弹嘛QWQ

可能是题意不清所以让人觉得麻烦

其实很简单诶

自以为代码写的比较清楚：
```
#include<cstdlib>
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int n,a[25][25];
int f[25],w[25],q[25],ans[25];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){scanf("%d",&w[i]);f[i]=w[i];}
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
	scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(a[j][i])
			{
				if(f[j]+w[i]>f[i])
				{
				    f[i]=f[j]+w[i];
				    q[i]=j;
				}
			}
		}
	}
	int x=0,tot=0;
	for(int i=1;i<=n;i++)
	{
		if(f[x]<f[i])x=i;
	}
	ans[0]=f[x];
	while(x)
	{	
		ans[++tot]=x;
		x=q[x];
	}
	for(int i=tot;i>1;i--)printf("%d ",ans[i]);
	printf("%d",ans[1]);
	printf("\n%d",ans[0]);
	return 0;
}
```

---

## 作者：yyy2015c01 (赞：35)

奥赛一本通上就有。。。

f[i]表示第i个地窖能挖的最大地雷数。

w[i]代表第i个地窖原本有的地雷数。

a[i][j]==1代表i能到j,否则不能

初始边界：f[i]=w[i](1<=i<=n)

状态转移方程是f[i]=max{f[j]+w[i]}(a[i][j]=1,i<j<=n)。。。吧

ans=f[n]

书上就有，详看程序

```cpp

#include<iostream>  
#include<cstdio>  
#include<cstdlib>  
#include<cmath>  
#include<algorithm>  
#include<cstring>  
#include<map>  
#include<vector>  
using namespace std;  
const int maxn=201;  
bool adja[maxn][maxn]={false};  
int data[maxn]={0},pre[maxn]={0},f[maxn]={0},n=0;  
int main()  
{  
    scanf("%d",&n);  
    for (int i=1;i<=n;i++)  
    {  
        scanf("%d",&data[i]);  
        f[i]=data[i];  
    }     
    for (int i=1;i<n;i++)  
        for (int j=i+1;j<=n;j++)  
            scanf("%d",&adja[i][j]);  
    //f[n]=data[n];  
    for (int i=n-1;i>=1;i--)  
    {  
        int fj=0,path=0;  
        for (int j=i+1;j<=n;j++)  
            if (adja[i][j]&&f[j]>fj)  
            {  
                fj=f[j];  
                path=j;  
            }  
        f[i]=fj+data[i];  
        pre[i]=path;  
    }  
    int k=1;  
    for (int i=2;i<=n;i++)  
        if (f[i]>f[k])  
           k=i;  
    int _max=f[k];  
    printf("%d",k);  
    k=pre[k];  
    while(k)  
    {  
        printf(" %d",k);  
        k=pre[k];  
    }  
    puts("");  
    printf("%d",_max);  
    return 0;  
}  

```

---

## 作者：Trinity (赞：30)

# 题目：P2196 挖地雷 1996 提高组 T2
## 题目描述
在一个地图上有 $N$ 个地窖 $ (N \le 20) $，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，**某人可以从任一处开始挖地雷**，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。
## 分析
$1$ .有图论的特点。  
$2$ .数据范围很小$ (N \le 20) $，可以进行“奇特”的尝试。  
$3$ .又要输出路线，又要输出最大方案结果，可以结合起来，减少码量。
$4$ .题目有坑，这是有向图，意味着题干中(即以上黑体)其实有误。  
            
                      ————只能从头往后挖哦!  
         						            by kkksc03
## 解法1：递推关系式 ( dp )


------------
感谢本方法的来源者 巨佬 [Logic_](https://82805.blog.luogu.org/solution-p2196)。（虽然本题的官方做法是倒推dp，但我感觉正推思路更清晰）


------------
$1$ .使用pre记录合理方案中选择的点的前驱，递归输出。(也可以用while循环，下一种方法中给出）  
$2$ .明显不能简单的求出答案，所以设计好状态，方便转移，以 $f[i]$ 表示从起点到点$i$时挖到地雷的最大数，当 $i$ 与 $j$ 相连，$f[j]$ (即另一点，枚举一下）取到最大值时，就得到了递推式$f[i]=max(f[j])+mine[i]  ( map[j,i]=1)$。
$3$ .务必记下路径上最后的点，以此递归输出。
```cpp
int n,ans,pos;
int mine[N],f[N],_map[N][N],pre[N];
void print(int x)//递归输出。
{
  if(pre[x]==0) {cout<<x;return;}//如果没了，就输出，回溯。
  print(pre[x]);//继续打印前驱。
  cout<<' '<<x;
}
int main()
{
  std::ios::sync_with_stdio(false);
  cin>>n;
  for(int i=1;i<=n;i++)cin>>mine[i];
  for(int i=1;i<=n-1;i++)
    for(int j=i+1;j<=n;j++)//读入01串，不要读错位。
      cin>>_map[i][j];
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=n;j++)
    {
      if(_map[j][i])
      {
        f[i]=max(f[i],f[j]);//递推式的实现，f[i]=max9f[j]。
        if(f[i]==f[j])pre[i]=j;//记下前驱。
      }
    }
    f[i]+=mine[i];//然后别忘了加上地雷数
    。
    ans=max(ans,f[i]);//答案取大值
    if(ans==f[i])pos=i;//记下最后的点。
  }
  print(pos);
  cout<<endl<<ans<<endl;//不要输出了f[n]，这不是答案。
  return 0;
}
```
## 解法2：图论 ( 其实实质区别不大 )


------------
再来模一波机房帮忙纠正思路的巨神 [kl膜法59改](https://www.luogu.org/space/show?uid=55458) and [Asougi_Kazuma](https://www.luogu.org/space/show?uid=55501) ，没有他们的帮助 ，我极有可能陷入题目巨坑（ 见分析$4$ )无法自拔。  
一开始的思路是建双向边，然后枚举点跑$floyd$，复杂度$ok$，但是有正环，跑不了最长路。


------------
$1$ .既然是有向图，又要降低复杂度 ( 虽然$N$很小 ),所以我们连个假起点，指向每个图中的点，边权为点的地雷数，再来个假终点，由各个点指向它，无边权( 其实为$0$ ).  
$2$ .然后当两点相连时，由来点指向去点 ( 输入数据很好，保证单向 ) , 边权为去点的地雷数。
$3$ .在跑spfa时利用一下松弛操作，记下前驱 $pre$ 数组.
$4$ .不懂的再看图和代码，懂了的就开始打吧。  
![](http://m.qpic.cn/psb?/80c76f18-4372-4a40-bc51-07add1310ee4/jYX1tikmtkjJoZJw*wvCSBETKnSVgXz2H29Mzwzioco!/b/dDMBAAAAAAAA&bo=wAMcAgAAAAADB*8!&rf=viewer_4)  
```cpp
struct node
{
  int next,to,val;
}e[M*2];
bool vis[M];
int n,sum,cnt,src=101,_end=102,pos=_end;
int pre[M],mine[N],_map[N][N],head[M*2],dis[M],ans[M];//N=21,M=N^2,这是理论上的大小，但实际的不需这么大的数组，但不要开成N的了。
inline void addedge(int u,int v,int w)
{
  e[++cnt].next=head[u];
  e[cnt].to=v;
  e[cnt].val=w;
  head[u]=cnt;
}
inline void spfa(int src)//spfa法。
{
  queue<int>q;
  memset(vis,false,sizeof(vis));
  memset(dis,0,sizeof(dis));//最长路记得把dis初始化成0
  dis[src]=0;
  vis[src]=true;
  q.push(src);
  while(!q.empty())
  {
    int u=q.front();
    q.pop();
    vis[u]=false;
    for(int i=head[u];i;i=e[i].next)
    {
      int v=e[i].to;
      if(dis[v]<dis[u]+e[i].val)
      {
        pre[v]=u;//记录前驱，在松弛操作后，不要写到前面了。
        dis[v]=dis[u]+e[i].val;
        if(!vis[v])
        {
          vis[v]=true;
          q.push(v);
        }
      }
    }
  }
}
int main()
{
  std::ios::sync_with_stdio(false);
  cin>>n;
  for(int i=1;i<=n;i++)
  {
      cin>>mine[i];
      addedge(src,i,mine[i]);//连接假起点和每个点。
      addedge(i,_end,0);//点解每个点和终点。
  }
  for(int i=1;i<=n-1;i++)
    for(int j=i+1;j<=n;j++)
    {
      cin>>_map[i][j];
      if(_map[i][j])addedge(i,j,mine[j]);//连接图中的点，不连反向边。
    }
  spfa(src);
  while(pre[pos]!=src)
  {
    sum++;
    ans[sum]=pre[pos];//答案数组为前驱，还是要筛一遍。
    pos=pre[pos];
  }
  for(int i=sum;i>=1;i--)cout<<ans[i]<<' ';//因为从终点开始找，找出的序列是反的。
  cout<<endl<<dis[_end]<<endl;//输出答案。
  return 0;
}
```  
## 总结
$1$ .对于越简单粗暴的题，想出的方法更多，但是要通过现有的算法来实现，不要像我一样spfa跑负环这些蠢事。  
$2$ .NOIP2000前的题目都有一定的问题，语文要好才能顺利AC。  
$3$ .当$N \le 200$时(其它OJ上有),第二种方法就没方法一优秀了，大家还可以想一想更好的方法，来个其他OJ的链接，这里的数据大一点 , [let's have a try!!!](http://ybt.ssoier.cn:8088/problem_show.php?pid=1262)

---

## 作者：liuzitong (赞：24)

dalao们为什么总有各种nb的思路,本蒟蒻只会最短路
这个题之前在  信息学奥赛一本通  上做过几乎一样的题，但是由于数据太水导致我当时过了，进而导致我昨天（4.28）考试丢了20分，今天写一篇题解

这个挖地雷我们首先要想一个问题（基本人人能想到）：
![](https://i.loli.net/2019/04/29/5cc64a1f1b85d.png)
#### 看这个图，如果我们从4出发，假设能挖到10颗雷，那么我们从1或3出发肯定能挖到更多的雷，毕竟你不可能挖到的雷是负数个或者会丢失雷

## 那么我们就应该从没有入度的点开始，这貌似跟最短路差不多  

## 思路：

## 1.从入度为0的点开始,若能更新它的出边的点则更新,然后删边并让它的入度减一,若减到0则入队.

## 2.标记刚刚更新的点

## 3.检查是否全部标记

## if(没有全部标记)

## 4.不断重复;

#### 注意:并不是只有更新过的点才删边及减入度,不管有无更新,与入度为0的点相连的边都要删,入度都要减(如果不明白可以拿上面那个图手动模拟一下就知道为什么了)

蒟蒻代

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<stack>
#include<queue>
#include<iostream>
using namespace std;
bool b[21][21];//临界矩阵存边
stack <int> ss;//栈输出路径
int a[21],du[21],s[21],pre[21];//a[]->每个地窖的地雷数,du[]指入度,s[]指当前挖到这个地窖最优,pre[]用来记录路径
int n,yyy;//n指有几个地窖,yyy用来去掉最后的空格
queue <int> q;//队列储存入度为0
void print(int x) {//打印路径
    if(x==0)//没有前驱就返回
        return ;
    yyy++;
    ss.push(x);
    print(pre[x]);//递归找
}
void dd(int x) {
    for(int i=1; i<=n; i++) {//枚举每一个点
        if(b[x][i] == 1) {//有路的话
            b[x][i] = 0;//删边
            du[i]--;//减度
            if(du[i] == 0) {//如果减到0就入队
                q.push(i);
            }(这几句不能放到下面)
            if(s[i] < s[x]+a[i]) {//如果能更新就更新
                s[i] = s[x]+a[i];
                pre[i] = x;//记录路径
            }
        }

    }

}
void dg() {
    for(int i=1; i<=n; i++) {//找一开始入度为0的边
        if(du[i] == 0) {
            q.push(i);
        }
    }
    while(q.empty() == 0) {//这个可以写到dd()里面
        int a=q.front();
        q.pop();
        dd(a);
    }
}

int main() {
//    freopen("lei.in","r",stdin);
//    freopen("lei.out","w",stdout);
    scanf("%d",&n);
    for(int i=1; i<=n; i++) {
        scanf("%d",&a[i]);
        s[i]= a[i];//一开始最优就是只走一个
    }
    for(int i=1; i<=n; i++) {
        for(int j=i+1; j<=n; j++) {
            scanf("%d",&b[i][j]);
            if(b[i][j] == 1)//记录度数
                du[j]++;
        }
    }

    dg();
    int zd=0,xx;
    for(int i=1; i<=n; i++) {//找到最大值,并找到最大值的序号
        if(s[i]>zd) {
            zd=s[i];
            xx=i;
        }
    }
    print(xx);//打印
    for(int i=1; i<yyy; i++) {//yyy的用途
        cout<<ss.top()<<' ';
        ss.pop();
    }
    cout<<ss.top()<<endl;//最后换行格式错了貌似会WA
    cout<<zd;
    return 0;
}
```
一篇博客水完啦希望大家喜欢


---

## 作者：yaojinzhong (赞：17)

~~水一波题解~~

题目思路很简单，数据范围也很良心，爆搜完全可以过。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=20+3;
int f[N][N],a[N],n,ans;
int p[N],op[N],cnt,tot;
//op代表当前的路径 cnt来记录op数组的范围
//p代表最优方案的路径 tot来记录p数组的范围 
bool v[N];
void dfs(int x,int sum)
{
	for(int i=x+1;i<=n;i++)//因为只能从上往下挖，所以由x+1开始 
	{
		if(f[x][i])
		{
			op[++cnt]=i;
			dfs(i,sum+a[i]);
			cnt--;
		}
	}
	if(sum>ans)
	{
		ans=sum;
		for(int i=1;i<=cnt;i++)
		{
			p[i]=op[i];
		}
		tot=cnt;
	}
	return ;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			scanf("%d",&f[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		op[++cnt]=i;
		dfs(i,a[i]);
		cnt--;
	}
	for(int i=1;i<=tot;i++)
	{
		printf("%d ",p[i]);
	}
	printf("\n%d",ans);
	return 0;
}
```

但本题还可以用DP做掉。

#### 本蒟蒻的DP方程：$p[i]=max(p[i],p[j]+a[j])$

~~我也不知道为什么要用p而不用f~~

但更新到最后我们最开始挖的点的地雷数还没加到，所以最后再加上就好了。

（我的输出有点蠢）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=20+3;
int f[N][N],a[N],n,p[N],ans,op,cnt[N],m;
void PRINT()//蠢蠢地输出 
{
	cnt[++m]=op;
	p[op]-=a[op];
	for(int i=op+1;i<=n;i++)
	{
		if(p[op]==p[i])
		{
			cnt[++m]=i;
			p[op]-=a[i];
		}
	}
	for(int i=1;i<=m;i++) printf("%d ",cnt[i]);
	cout<<endl;
	return ;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			scanf("%d",&f[i][j]);
		}
	}
	for(int i=n;i>=1;i--)
	{
		for(int j=i+1;j<=n;j++)
		{
			if(f[i][j])//有路径就转移 
			{
				p[i]=max(p[i],p[j]+a[j]);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		p[i]+=a[i];//因为此刻我们最开始的点没有挖 
		if(p[i]>ans)
		{
			op=i;//记录最优路径的起始点 
			ans=p[i];
		}
	}
	PRINT();
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Cagulo (赞：8)

#**典型的树形dp**

//从每一个点遍历一遍，找出最大值，更新答案并更新路径，最后输出即可

//dp[u]表示以u为根的子树能得到的最大值，因为是有向图，只能取与u相邻的节点中的最大值，不能累加

//数据范围比较小，时间复杂度是(n^2)，每个点(n)遍历一遍图(n)，2000应该没问题，因为只建单向边，话不多说，代码如下


```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct node
{
    int to,next;
}edge[500];
int head[500],cnt=0;
void add(int u,int v)
{
    edge[++cnt].to=v;edge[cnt].next=head[u];head[u]=cnt;//邻接表建图，贼好用 
}
int dp[30],pre[30],s[30];
int n,w[30];
int dfs(int u,int fa)
{
    if(dp[u]) return dp[u];//如果当前这个点找到了就返回他原来的值，减少重复搜索 
    for(int i=head[u];i!=0;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==fa) continue;//无向图专用，当然用在这里也没什么错，以防万一 
        dp[v]=dfs(v,u);
        if(dp[u]<dp[v])//更新以u为根节点的子树的最大值 
        {
            dp[u]=dp[v];
            pre[u]=v;//记录路径 
        }
    }
    return dp[u]+w[u];//别忘记加上他自己本身的值 
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&w[i]);
    for(int i=1;i<n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {    int x;
            scanf("%d",&x);
            if(x>0) add(i,j);
        }
    }
    int ans=0,k;
    for(int i=1;i<=n;i++)
    {
        memset(dp,0,sizeof(dp));//记得每次都要清零，不然要GG 
        int tmp=dfs(i,0);
        if(ans<tmp)
        {
            ans=tmp;
            swap(pre,s);//这里更新路径，一个简单的函数swap直接交换，不需要其他空间辅助 
            k=i;//k表示从那个点出发找到的最大值 
        }
    }
    while(k!=0)
    {
        printf("%d ",k);
        k=s[k];
    }
    printf("\n%d\n",ans);
    return 0;
}
```

---

## 作者：高木木 (赞：5)

看那么多大佬么那么简洁的代码，蒟蒻我来发一个简单易懂的 ** 双DFS **吧
# 本题的主要思路：
### ①求挖地雷的最多个数。
### ②输出最多地雷的挖掘方法。
## 明确思路后代码实现
数据范围 **n<=20** 所以我们完全可以跑n遍DFS 求出其中的可以一次性挖的最多地雷数，
然后再跑一遍 计路DFS 把一个等于这个最多地雷数挖法记录下来输出，本题就结束了，简单易懂的双DFS。
### 下面是AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2147483647;
int n,a[21];
int f[21][21],step=0;// f[i][j]用来判断i和j是否联通。 step用来记录最多的地雷数
void read(int &x)
{
	x=0;int p=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') p=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	x*=p;
}// （读入优化自动忽略）
void dfs(int x,int y)// 求最多地雷数的DFS x来记录当前到达的点，y来记录地雷数目。
{
	bool p=0;
	for(int i=1;i<=n;i++)
	{
		if(f[x][i])
		{
			p=1;
			break;
		}
	}// 判断n个地窖里是否有地窖与当前地窖x联通。
	if(p==0)
	{
		step=max(y,step);
		return ;
	}// 没有地窖联通，已经挖到头了，判断已挖到的地雷是否为最大地雷数。
	for(int i=1;i<=n;i++)
	{
		if(f[x][i]) dfs(i,y+a[i]);// 如果联通就挖下去。
	}
}
int e1[21];// e1数组用来记录挖掘顺序。
bool p=0;
int dfs1(int x,int y,int z)// 记录挖掘顺序的DFS x，y所代表的意义同上，z来记录已经挖了几个地窖。
{
	if(y==step)
	{
		p=1;
		for(int i=0;i<z;i++)
		 cout<<e1[i]<<" ";
		return 0;
	}// 如果为最大地雷数，输出所记录的顺序然后直接跳出就好了！
	for(int i=1;i<=n;i++)
	{
		if(f[x][i])
		{
			e1[z]=i;
			dfs1(i,y+a[i],z+1);
		}
	}
}
int main()
{
	read(n);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
	}
	for(int i=1;i<n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			int y;
			read(y);
			if(y) f[i][j]=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		dfs(i,a[i]);	
	}
	for(int i=1;i<=n;i++)
	{
		e1[0]=i;
		dfs1(i,a[i],1);
		if(p) break;// 已经找到最优顺序，直接Break掉！
	}
	cout<<endl<<step;// 换行输出最多地雷数！
	return 0;
}// AC！！！
```

---

## 作者：欧chenleyu的中号 (赞：4)

一题DP题，单向搜索，符合动归条件。只不过我一开始一直以为是双向的……因为是单向的，所以从第n-1个地雷坑开始判断，用自己的地雷数加上本坑能通到的所有坑中地雷数最多的。这样一直倒推回去，就能AC啦！

上菜！（误）上代码！

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;
int n,a[21]={0},b[21][21]={0},pa,pb,c[21]={0},k=0,s=0,dd,d[21]={0},w[21]={0};
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)cin>>b[i][j];
    w[n]=-1;
    for(int i=n-1;i>=1;i--)   倒推
    {
        dd=0,k=0;
        for(int j=1;j<=n;j++)
        {
            if(b[i][j]==1&&a[j]>k)k=a[j],w[i]=j;  找最多，并记录路线
        }
        if(k==0)w[i]=-1;  如果没有通的地雷坑，就赋值-1。
        else a[i]+=k;
    }
    dd=0;
    for(int i=1;i<=n;i++)  找最多的那个地雷坑，就它是起点了！
    {
        if(a[i]>a[dd])dd=i;
        if(a[i]>s)s=a[i];
    }
    cout<<dd;
    while(w[dd]!=-1){cout<<' '<<w[dd];dd=w[dd];}  输出到最后一个地雷坑
    cout<<endl<<s;  输出地雷
    return 0;
}
```

---

## 作者：以墨 (赞：4)

一道动规题~

和楼下说的差不多，数字三角形升级版，但是楼下说的有点小问题......

因为输出时要求字典序最小，所以动规大循环需要从大到小，这样邻接表（可能不太准确）的顺序就可以保证从小到大（位置），字典序就是最小的。

i从大到小枚举，每次在比i靠后的区域中选取最优值连到i的后面。这样i的下一个位置一定比i大，i-1的下一个位置一定比i-1大，以此类推。

```cpp
#include<cstdio>
using namespace std;
bool z[202][202];
int k,a[202],f[202],nxt[202],n,i,j,ans;//nxt[i]记录i连接的下一个地窖
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(i=1;i<=n-1;i++)
        for(j=i+1;j<=n;j++)
            scanf("%d",&k),z[i][j]=(k==1?true:false);//记录i,j是否联通
    for(f[n]=a[n],i=n-1;i>=1;i--)//初始化很重要，最后一个地窖对应最优值就是本身
    {
        for(j=i+1;j<=n;j++)
            if(f[j]>f[i]&&z[i][j])//在i之后的区域里找到最大的总和且连通的地窖，把i的连接的地窖设为最大的
            {
                f[i]=f[j];
                nxt[i]=j;
            }
        f[i]+=a[i];//第i个地窖还要加上本身的值
```
}//状态转移方程f(i)=max{f(j)}+a[i]
```cpp
    for(i=1;i<=n;i++)
        if(f[i]>ans)//找到全部的最优值
        {
            ans=f[i];
            k=i;
        }
    for(i=k;nxt[i];i=nxt[i])//从最优值下手，每次找其紧连接的一个地窖，和邻接表很类似
        printf("%d ",i);
    printf("%d\n",i);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：maorui_cow (赞：4)

可以说是一道很经典的dp了，还是很简单的

我们可以推出状态转移方针为f[i]=max(a[i]+w[j])
```
#include<bits/stdc++.h>
using namespace std;
int a[25],s[25][25],t[25],c[25],f[25];
int main()
{
	int n,maxx=0,l,k;
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1; i<=n; i++)
	{
		for(int j=i+1; j<=n; j++)
		{
			scanf("%d",&s[i][j]);//直接记录连接情况
		}
	}
	f[n]=a[n];//这里是从n往下的一个递推
	for(int i=n-1; i>=1; i--)
	{
		l=0,k=0;//注意要清零
		for(int j=i+1; j<=n; j++)
		{
			if(s[i][j]==1&&f[j]>l)//记录最大值
			{
				l=f[j];
				k=j;
			}
		}
		f[i]=l+a[i];//加上地雷数
		c[i]=k;//记录最优顺序
	}
	k=1;
	for(int i=2;i<=n;i++)//计算最多地雷数
	{
		if(f[i]>f[k])
		{
			k=i;
		}
	}
	maxx=f[k];//记下最大值
	cout<<k;
	k=c[k];
	while(k!=0)
	{
		printf(" %d",k);
		k=c[k];
	}
	printf("\n");
	printf("%d\n",maxx);
	return 0;
}

```

//^w^

---

## 作者：晔子 (赞：3)

我发现没人写Floyd。。。

其实这道题是可以Floyd跑最长路的，但是注意一个问题就是dis数组要初始化负无穷，两个点之间不能相互到达一定要初始化dis数组为负无穷！！！敲黑板

当一条路不能走的时候，要把这条路赋成负无穷，不能赋成0，因为如果这条路走完后面的路权值和更大的话还是会选上这条路。~~（Orz Fusu）~~

![FSAKIOI](https://cdn.luogu.com.cn/upload/image_hosting/vsxht6tk.png)

然后就是一个很简单的Floyd


```cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#include<queue>
#include<cstdlib>

using namespace std;

typedef long long ll;

inline int read(){
    int ans=0;
    char last=' ',ch=getchar();
    while(ch<'0'||ch>'9') last=ch,ch=getchar();
    while(ch>='0'&&ch<='9') ans=ans*10+ch-'0',ch=getchar();
    if(last=='-') ans=-ans;
    return  ans;
}

int n;
int a[25];
int f[25][25];
int path[25][25];
int s=0,t=0,maxx=-63;

int main()
{
    n=read();
    memset(f,-63,sizeof(f));
    for(int i=1;i<=n;i++) a[i]=read(),f[i][i]=a[i];

    for(int i=1;i<n;i++)
       for(int j=i+1;j<=n;j++){
       	int x=read();
       	if(x) f[i][j]=a[i]+a[j];
	   }
       
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        path[i][j]=j;

    for(int k=1;k<=n;k++) 
       for(int i=1;i<=n;i++)
          for(int j=1;j<=n;j++){
            if((f[i][j]<f[i][k]+f[k][j]-a[k])){
                f[i][j]=f[i][k]+f[k][j]-a[k];
                path[i][j]=path[i][k];
              }
            if(f[i][j]>maxx){
                    s=i;t=j;
                    maxx=f[i][j];
                  }
          }    

    while(s!=t){
        printf("%d ",s);
        s=path[s][t];
    }  
    printf("%d\n",t);
    printf("%d\n",maxx);
    return 0;
}
```



---

## 作者：千反田 (赞：3)

题解里一群大佬用图论 dp 记忆化 ~~我都不会~~

本蒟蒻看了眼数据于是决定水一发爆搜

结果真的过了2333

我们用way数组表示两个地窖中是否存在联通路径

用trace数组表示该点是否遍历过

```cpp
bool way[N][N],trace[N];
```

需要注意的是这里的路径是单向联通的

（感谢题解里@公主殿下MIKU的提醒 ）

每到一个地窖 判断是否后面是否还有路

```cpp
int check(int x)
{
	for(int i=1;i<=n;++i)
	{
		if(way[x][i]&&!trace[i])
		return true;
	}
	return false;
}
```
大概的思想就是这样了

# 祭上代码
```cpp
#include<bits/stdc++.h>
#define inf INT_MAX
#define N 25//个人习惯
using namespace std;
int number[N],ans=-inf,ansf[N],temp[N],n;
bool way[N][N],trace[N];
int check(int x)//判断函数
{
	for(int i=1;i<=n;++i)
	{
		if(way[x][i]&&!trace[i])//如果两个地窖联通且没有被遍历过
		return true;
	}
	return false;
}
void DFS(int now,int step,int num)
//now为现在处在的地窖编码，step为第几层，num为当前挖到的地雷数
{
	if(!check(now))//如果不可以再走了
	{
		if(ans<num)
		{
			ans=num;
			for(int i=1;i<=n;++i)
			{
				ansf[i]=temp[i];
			}
		}//更新答案
		return;
	}
	else//否则
	for(int i=1;i<=n;++i)
	{
		if(way[now][i]&&!trace[i])
		{
			trace[i]=true;
			temp[step]=i;
			DFS(i,step+1,num+number[i]);//快乐地继续爆搜
			trace[i]=false;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	 scanf("%d",&number[i]);
	for(int i=1;i<=n;++i)
	 for(int j=i+1;j<=n;++j)
	  scanf("%d",&way[i][j]);
	for(int i=1;i<=n;++i) //尝试从每一个地窖开始遍历
	{
		memset(temp,0,sizeof(temp));
		trace[i]=true; 
		temp[1]=i;
		memset(trace,false,sizeof(trace));
		DFS(i,2,number[i]);
	} 
	for(int i=1;i<=n;++i)
	 printf("%d ",ansf[i]);
	printf("\n%d",ans);
    return ~~(0-0);//卖萌
}
```


---

## 作者：zhr1502 (赞：3)

楼下也说了，这一题显然满足dp的条件，可用动归求解，这里就再讲一下思路吧。

不难看出，编号为n的地窖是没有路径通往其他地窖的，因此边界为f[n]=c[n];

所以这是一道逆推的题目o(∩\_∩)o，不难得出方程式：设f[i]为以i为起点能挖出的最多地雷数。那么状态转移方程式就是

```cpp
    f[i]=max(f[j]+c[i]);
```
代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int l,k,f[21],n,c[21],b[21][21],nexts[21];  
void maxx(int f,int j){
    if(f>l) {
        l=f; k=j;        //若有状态比当前更优，则更新 
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>c[i];            //读入c数组 
    for(int i=1;i<=n;i++)
      for(int j=i+1;j<=n;j++) cin>>b[i][j];        //读入b数组 
    f[n]=c[n];        //边界 
    for(int i=n-1;i>=1;i--){    //逆推 
        l=0; k=0;
        int j;
        for(j=i+1;j<=n;j++) 
          if(b[i][j]) maxx(f[j],j);            //i，j有联通时判断可否更新 
        nexts[i]=k; f[i]=c[i]+l;         //找到起点i的后续并将i更新 
    }
    for(int i=1;i<=n;i++) maxx(f[i],i);        //找到可挖出最多的一条路径 
    cout<<k;
    k=nexts[k];
    while(nexts[k]!=k){
        cout<<" "<<k;
        k=nexts[k];
    }
    cout<<endl<<l;
    /*
        输出被和谐了，动动脑吧 
    */
}
```

---

## 作者：Rey_HR (赞：3)

# 图的存储
这道题目的DP思路还是很好想的，前面几位大佬~~（%%%）~~在自己的题解中讲的很详细了，所以，我想谈一谈这个图的存储方式。


------------
## 邻接矩阵
很常见的图的存储方式，空间复杂度为**O(N^2)**，因为可以直接查找，所以查找的时间复杂度为**O(1)**。

主要代码如下：
```cpp
for (int i = 1; i <= n; i++)
{
	for (int j = 1; j <= n; j++)
		if (g[j][i] && dp[i] < dp[j])
        dp[i] = dp[j], pre[i] = j;
	dp[i] += num[i];
	if (dp[i] > maxn) maxn = dp[i], k = i;
}  
```
不难看出，时间复杂度为**O(N^2)**。


------------
## 邻接表
邻接矩阵的空间之所以大，是因为有些点之间没有边，出现浪费。所以，我们可以用邻接表存。**注意**：这里我用的是vector，没用链表~~（因为我懒）~~。空间复杂度为**O(N*2+1)**，查找却要**O(N)**。

主要代码如下：
```cpp
for (int i = 1; i <= n; i++)
{
	for (int j = 1; j <= n; j++)
		if (gfind(j,i) && dp[i] < dp[j])
        //gfind是我自己写的查找函数，时间复杂度为O(N);
        	dp[i] = dp[j], pre[i] = j;
	dp[i] += num[i];
	if (dp[i] > maxn) maxn = dp[i], k = i;
}
```
时间复杂度显然为**O(N^3)**，但由于**N<=20**，所以这个复杂度还可以接受。


------------
最后，附上完整代码：
```cpp
#include<bits/stdc++.h> 
#define inf 0x3f3f3f3f
using namespace std;
inline int read()//读入优化
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || '9' < ch) { if (ch == '-') f = -1; ch = getchar(); }
	while ('0' <= ch && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
int n, k;
int maxn = -inf;
int num[30];
int pre[30] = { 0 };
int dp[30];
vector<int>g[30];
void put_out(int x)//输出路径
{
	stack<int>s;
	for (int i = x; i; i = pre[i])//因为根据前驱找到的路径是倒序的，所以我把它们放到一个栈里
		s.push(i);
	while (!s.empty())//将栈从顶到底输出
	{
		printf("%d ", s.top());
		s.pop();
	}
	printf("\n");
	return;
}
bool gfind(int a, int b)
{
	for (int i = 0; i < g[a].size(); i++)
		if (g[a][i] == b) return 1;
	return 0;
}
int main()
{
	n = read();
	for (int i = 1; i <= n; i++)
		num[i] = read();
	for (int i=1;i<=n;i++)
		for (int j = i + 1; j <= n; j++)
		{
			int x;
			x = read();
			if (x) g[i].push_back(j);
		}
	for (int i = 1; i <= n; i++)//DP
	{
		for (int j = 1; j <= n; j++)
			if (gfind(j,i) && dp[i] < dp[j]) dp[i] = dp[j], pre[i] = j;//记录前驱
		dp[i] += num[i];
		if (dp[i] > maxn) maxn = dp[i], k = i;
	}
	put_out(k);
	printf("%d\n", maxn);//输出
	//system("pause");
	return 0;
}
```
**P.S.** STL大法好！！！

---

## 作者：龘龘龘龘龘龘 (赞：3)

本题可以运用递推思想，从f[n]往前逐个找出所有的f[i]；再从中找出最大的一个解；对于具体走过的路径，可以通过一个向后的链接来实现；

并且这是一道典型的动规题，很明显题目规定所有路径都是单向的，所以满足无后效性原则和最优化原理。

鄙人初学C++若代码中有多余的，请勿见怪。

具体代码如下：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
    long f[201]={0},w[201],c[201]={0};
    bool a[201][201]={0};
    long i,j,n,x,y,l,k,maxx;
    memset(f,0,sizeof(f));
    memset(c,0,sizeof(c));
    memset(a,0,sizeof(a));//将f，c，a三个全部初始化为0；
    cin>>n;
    for(i=1;i<=n;i++)
    cin>>w[i];//输入每个地窖中的地雷数
    for(i=1;i<=n;i++)
        for(j=i+1;j<=n;j++)
        cin>>a[i][j];//输入路径数
    f[n]=w[n];//从后面的f[n]往前逐个找出所有的f[i]
    for(i=n-1;i>=1;i--)
      {
          l=0;k=0;
          for(j=i+1;j<=n;j++)
            if((a[i][j])&&(f[j]>l)) 
            {
               l=f[j];
             k=j;    
          }
          f[i]=l+w[i];//保存从第i个地窖起能挖到的后继点最大地雷数
          c[i]=k;//k地窖是i地窖最优路径
      }
    k=1;
    for(j=2;j<=n;j++)//计算最多挖出的地雷数
      if(f[j]>f[k]) k=j;
    maxx=f[k];
    cout<<k;
    k=c[k];
    while(k!=0)//输出挖出地雷的顺序
    {
        cout<<" "<<k;
        k=c[k];
    }
    cout<<endl;
    cout<<maxx<<endl;//输出最多挖出的地雷数
}
//给大家推荐一本书《信息学奥赛一本通C++版》；很好用
```

---

## 作者：动态WA (赞：2)

你还在为程序运行时间长而苦恼吗？

你还在为程序空间大而苦恼吗？

你还在因为只会简单dp而苦恼吗？

只要~~998~~链式前向星，让你的程序更美好qwq
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a[21],head[21],h,to[4001],next[4001];
int f[21],ans[21],pre[21],da,dw;
void add(int u,int v){
	to[++h]=v;
	next[h]=head[u];
	head[u]=h;
}//存图
void find(int w){
	if (!pre[w]){
		printf("%d ",w);
		return;
	}
	find(pre[w]);
	printf("%d ",w);
}//输出前驱
int main(){
	int d;
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for (int i=1;i<n;i++){
		for (int j=i+1;j<=n;j++){
			scanf("%d",&d);
			if (d) add(j,i);//存下从哪个点到自己
		}
	}
	f[1]=a[1];
	da=a[1];
	dw=1;
	for (int i=2;i<=n;i++){
		f[i]=a[i];
		if (f[i]>da){
			da=f[i];
			dw=i;
		}
	}//不一定从一号开始
	for (int i=2;i<=n;i++){
		for (int k=head[i];k;k=next[k]){
			int j=to[k];
			if (f[j]+a[i]>f[i]){
				pre[i]=j;
				f[i]=f[j]+a[i];
				if (f[i]>da){
					da=f[i];
					dw=i;
				}
			}
		}
	}
	find(dw);
	printf("\n");
	printf("%d",da);
}
```


---

## 作者：飞翔 (赞：2)

#题解：

比较简单的DP，不需要配上其他的算法，只要静下心来想一想，动规方程就出来了。

输出有点恶心啊……

```delphi
var
  g:array[0..1000,0..1000] of longint;
  w,opt,path:array[0..1000] of longint;
  i,j,n,ans:longint;
begin
  fillchar(g,sizeof(g),0);
  fillchar(opt,sizeof(opt),0);
  fillchar(path,sizeof(path),0);
  readln(n);
  for i:=1 to n do read(w[i]);
  for i:=1 to n do
    for j:=i+1 to n do
      read(g[i,j]);
  for i:=n downto 1 do
  begin
    for j:=i+1 to n do
      if (g[i,j]=1) and (opt[j]>opt[i]) then
      begin
        opt[i]:=opt[j];
        path[i]:=j;
      end;
    inc(opt[i],w[i]);
  end;
  ans:=1;
  for i:=2 to n do
    if opt[i]>opt[ans] then ans:=i;
  write(ans,' ');
  i:=path[ans];
  while i>0 do
  begin
    write(i,' ');
    i:=path[i];
   end;
  writeln;
  write(opt[ans]);
end.
```

---

## 作者：香风智乃 (赞：2)

//在讨论上有，但是本萌新怕这帖沉了.....所以就发到题解上

注意事项：

1.除第n个地窖外，其他地窖都只与第n个地窖相连。（1个点 20分）//貌似是第3点的数据


2.某些地窖没有与其他地窖的通路（相当于一座孤岛），但是心机的数据偏就把这个地窖设为答案，举个栗子：


共3个地窖


第1、第3个地窖相连，共有2+3=5个地雷


第2个地窖没有通路 有6个地雷


此时判第2个地窖为答案：   2   6      而不是    1  3   5   （请别在意空格）


（2个点 40分）

//看到2个wa点少的可怜的数据推出来的

//本萌新的程序和楼下（和未来的楼上）dalao的程序根本不可比，所以就不献丑了

//费了半个多小时才分析出来的


---

## 作者：yangshirui (赞：2)

【算法分析】

本题是一个经典的动态规划问题。很明显，题目规定所有路径都是单向的，所以满足无后效性原则和最优化原理。设W[i]为第i个地窖所藏有的地雷数，A[i][j]表示第i个地窖与第j个地窖之间是否有通路，F[i]为从第i个地窖开始最多可以挖出的地雷数，则有如下递归式：

F[i]=max{ W[i]+ F[j]}               (i<j<=n , A[i][j]=true)

边界：F[n]=W[n]

于是就可以通过递推的方法，从后F(n)往前逐个找出所有的F[i]，再从中找一个最大的即为问题2的解。对于具体所走的路径（问题1），可以通过一个向后的链接来实现。

【参考程序】

        

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
   long f[201]={0},w[201],c[201]={0};
   bool a[201][201]={0};
   long i,j,n,x,y,l,k,maxx;
   memset(f,0,sizeof(f));
memset(c,0,sizeof(c));
   memset(a,false,sizeof(a));
   cin>>n;
   for (i=1;i<=n;i++)
     cin>>w[i];                                //输入每个地窖中的地雷数
   do
    {
      cin>>x>>y;                               //表示从X可到Y
      if ((x!=0)&&(y!=0)) a[x][y]=true;
    }while ((x!=0)||(y!=0));
    f[n]=w[n];                                 //从后F[n]往前逐个找出所有的F[i]
    for (i=n-1;i>=1;i--)
     {
      l=0;k=0;
      for (j=i+1;j<=n;j++)
       if ((a[i][j])&&(f[j]>l))
         { l=f[j]; k=j; }
      f[i]=l+w[i];                             //保存从第i个地窖起能挖到最大地雷数
      c[i]=k;                                  //k地窖是i地窖最优路径
     }
     k=1;
     for (j=2;j<=n;j++)                        //计算最多挖出的地雷数
      if (f[j]>f[k]) k=j;
     maxx=f[k];
     cout<<k;
     k=c[k];
     while (k!=0)                              //输出挖地雷的顺序
      {
        cout<<"-"<<k;
        k=c[k];
      } 
     cout<<endl;
     cout<<maxx<<endl;                          //输出最多挖出的地雷数
}

```

---

## 作者：Leaved_ (赞：1)

# 完全没有优化的DFS

PS：为什么 for 循环里什么 i 呀 j 呀全是long long？

因为手懒直接用的替换

```cpp
#include <bits/stdc++.h> 

using namespace std;

#define s(x) scanf("%lld",&(x))
#define p(x) printf("%lld\n",(x))
//一些简写

long long  n,sum[21],master[21][21];
bool vis[21];
long long  ans,step[21],ans1[21];
long long  cnt;
long long  camp;
//第一次交以为爆long long 
//PS：实际上是脑抽

bool can_boom(long long  now) {
	for(long long  i=1;i<=n;i++) {
		if(!vis[i] and master[now][i]) return true;
	}
	return false;
}
//判断能否往下挖，如果挖不了就 return

//这个利用递归方式存路径
//倒序存储，倒序输出
void out_out(long long  now) {
	if(!step[now]) return;//如果到达起点，就返回
	else {
		ans1[++cnt]=step[now];//存ta的上一个节点
		out_out(step[now]);//递归
	}
}

void input() {
	s(n);
	for(long long  i=1;i<=n;i++) {
		s(sum[i]);
	}
	for(long long  i=1;i<n;i++) {
		for(long long  j=i+1;j<=n;j++) {
			long long  now;s(now);
			master[i][j]= now ? true:false;//三目运算符，判断是否连接 
		  //master[j][i]= now ? true:false;
			//这里一定要注意的是 “沿着指出的连接往下挖 ”指的是单向边 
			//导致我交了3遍 
		}
	}
}

void Dfs(long long  now,long long  now_boom) {
	//这里我用的两次判断，第一次更新路径，第二次返回
	//第一次
	if(!can_boom(now) and ans<now_boom) {
		ans=max(ans,now_boom);//更新答案
		cnt=0;//计数器一定要归0！！！
		ans1[++cnt]=now;//存当前节点
		out_out(now);//递归存储路径
		camp=cnt;//答案计数器，因为下一次cnt要归0，所以输出不能用cnt
		return;
	}
	//第二次
	else if(!can_boom(now)) return;
	//搜索
	else {
		for(long long  i=1;i<=n;i++) {
			if(!vis[i] and master[now][i]) {
				vis[i]=1;
				step[i]=now;
				Dfs(i,now_boom+sum[i]);
				vis[i]=0;
			}
		}
	}
}

void output() {
	//枚举每个节点
	for(long long  i=1;i<=n;i++) {
		vis[i]=true;//一定要初始化，不然要出锅
		Dfs(i,sum[i]);
		//PS：还好数据量小
	}
	//倒序输出，在搜索及记录函数里写的很清楚
	for(long long  i=camp;i>=1;i--) {
		cout<<ans1[i]<<" ";
	}
	cout<<endl;
	p(ans);
}

//简洁的主程序
int main() {
	input();
	output();
	return 0;
}
```

~~这就是道DFS入门题~~

---

## 作者：醉语梦 (赞：1)

经典的DP，不过我直接用了图(\*/ω＼\*)


写的邻接表（链式前向星）不知道的可以查查 (=´ω｀=)


当然这道题写的时候把值赋给点而不是边


具体看代码：(不要抄袭哦)

```cpp
#include<cstdio>
int n,m,cnt,ma_sum,ma_t,ma_num;
int last[21],vis[21],c[21],ans[21],a[21];
struct node{
    int pre,to;
}bian[21];
void add_n(int x,int y){//链式前向星~ 具体的不解释了上网查吧
    bian[++cnt].pre=last[x];
    bian[cnt].to=y;
    last[x]=cnt;
}
void dfs(int t,int sum,int num);
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++){
            scanf("%d",&m);
            if(m){
                add_n(i,j);//无向图
                add_n(j,i);
            }
        }
    for(int i=1;i<=n;i++) 
         dfs(i,0,1);//防止出现一地窖不与任何地窖连 但雷数比其他的最大值大的情况
    for(int i=1;i<=ma_num;i++) printf("%d ",ans[i]);
    printf("\n%d",ma_sum);
    while(1);//反copy~
    return 0;
}
void dfs(int t,int sum,int num){
    vis[t]=1;sum+=a[t];c[num]=t; //标记 累计 当前所挖地窖编号
    if(sum>ma_sum){
        ma_sum=sum, ma_num=num;//更新最大值 
        for(int i=1;i<=num;i++) ans[i]=c[i];//更新答案数组
    }
    for(int i=last[t];i;i=bian[i].pre){
        if(!vis[bian[i].to]&&t<bian[i].to)//一个点走一回&&字典序
            dfs(bian[i].to,sum,num+1);
    }
    vis[t]=0;
}
```

---

## 作者：ljc20020730 (赞：1)

来一发Pascal的dfs的题解 ~~毕竟pascal在OIer中普及率越来越低了 伤心~~

这道题主要是单向的，而不是双向的，~~害死人啊~~

如果你一不小心打成双向了，呵呵样例都过不了！交给luogu评测好像60（数据略水）

所以大家要好好的看题~~

var  u:array[1..1000]of boolean;//查看第i个元素有没有被遍历

a,anss,road:array[1..1000]of longint;//a表示地雷数，anss表示最佳路线，road表示当前路线

map:array[1..1000,1..1000]of longint;//map表示一个01矩阵，表示能走不能走

```cpp
     i,j,sum,n,maxn:longint;
procedure dfs(num,ans,s:longint);//num表示当前的地窖号，ans表示当前挖的地雷数，s代表经过几个地窖
var  i:longint;
begin
 if u[num]=false then exit;//遍历过不重复
 road[s]:=num;//录入
 for i:=1 to n do
  if map[num,i]=1 then begin//能走如果是num，i交换打出来的路线反向
   u[num]:=false;
   dfs(i,ans+a[num],s+1);
   u[num]:=true;
  end;
 //注意以下语句在循环外
   if ans+a[num]>maxn then begin
    maxn:=ans+a[num]; sum:=s;
    for j:=1 to s do anss[j]:=road[j];
   end;
end;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 for i:=1 to n do
  for j:=i+1 to n do begin
    read(map[i,j]);
    //map[j,i]:=map[i,j];加了60
    end;
    fillchar(u,sizeof(u),true);
  for i:=1 to n do dfs(i,0,1);//每个点都遍历
  for i:=1 to sum do write(anss[i],' ');
  writeln;
  writeln(maxn);
end.
```

---

## 作者：pzc2004 (赞：1)

[题目传送门](https://www.luogu.org/problem/P2196)

直接上状压DP！！！

令$f_{i,j}$表示取过的点的状态为i，当前在j点的最大地雷个数。状态转移直接扫描j点的所有出边就好了，DP方程$f[i|(1<<k-1)][k]=\min(f[i|(1<<k-1)][k],f[i][j]+a[k])$（j到k有边）。我用的是邻接矩阵存图。

注意：直接开$2^{20}*20$会MLE，要改成short。

代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define N 21
#define int short//懒人专用
inline int read(){int x=0;char c=getchar();while(c<'0' || c>'9')c=getchar();while(c>='0' && c<='9')x=(x<<3)+(x<<1)+(c^'0'),c=getchar();return x;}//快读
short n,ans2[N],cnt,a[N],f[1<<20][N],ans;
pair<short,short>pre[1<<20][N],s;//pre记录前驱
bool e[N][N];//邻接矩阵存图
signed main()
{
    n=read();
    for(register int i=1;i<=n;i++)a[i]=read();
    for(register int i=1;i<n;i++)for(register int j=i+1;j<=n;j++)e[i][j]=read();
    for(register int i=0;i<(1<<n)-1;i++)
    {
        if(i==0)
        {
            for(register int j=1;j<=n;j++)f[1<<j-1][j]=a[j];
        }
        else
        {
            for(register int j=1;j<=n;j++)
            {
                if(!(i&(1<<j-1)))continue;
                for(register int k=1;k<=n;k++)
                {
                    if(!e[j][k] || i&(1<<k-1))continue;
                    if(f[i|(1<<k-1)][k]<f[i][j]+a[k])//状态转移
                    {
                        f[i|(1<<k-1)][k]=f[i][j]+a[k];
                        pre[i|(1<<k-1)][k]=make_pair(i,j);
                    }
                }
            }
        }
    }
    for(register int i=1;i<(1<<n);i++)//记录答案
    {
        for(register int j=1;j<=n;j++)
        {
            if(!(i&(1<<j-1)))continue;
            if(f[i][j]>ans)
            {
                ans=f[i][j];
                s=make_pair(i,j);
            }
        }
    }
    for(pair<short,short>i=s;i.first;i=pre[i.first][i.second])ans2[++cnt]=i.second;//记录路径
    for(register int i=cnt;i;i--)printf("%hd ",ans2[i]);//输出
    putchar('\n');
    printf("%hd",ans);
}
```
![](https://www.luogu.org/images/congratulation.png)

---

## 作者：My_Newstart (赞：1)

### 方法：
作为一个刚刚接触OI的蒟蒻，看到题目想都没想就写了一个搜索，**枚举每一个地窖作为起点再比较答案然后记录下最优的**，虽然此方法十分地暴力，但由于n<=20所以仍然能AC的


------------
### 代码：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int MAXN = 20;

int n, max1, ans, depth, final;
//数量，最大的地雷数，每一个作为起点的最大价值，每一次地窖数，最优的地窖数
int a[MAXN], f[MAXN], vis[MAXN], path[MAXN];
//每一个地窖的地雷数，最终的答案，是否访问过，每一次的路径

vector <int> G[MAXN];
//标记相连

bool dfs(int x)
{
	if(x == n) //到达终点
	{
		path[depth] = x;
		return true;
	}
	if(vis[x]) //已访问过
	{
		return false;
	}
	vis[x] = true; //标记
	path[depth] = x;
	++depth;
	for(int i=0; i<G[x].size(); i++) //访问和当前相邻的每个节点
	{
		int u = G[x][i];
		if(dfs(u) == true)
		{
			return true;
		}
	}
	--depth;
	return false;
}

int main()
{
	cin >> n;
	for(int i=1; i<=n; i++)
	cin >> a[i];
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=n-i; j++)
		{
			int x;
			cin >> x;
			if(x == 1)
			G[i].push_back(i + j); //标记相连
		}
	}
	for(int i=1; i<=n; i++)
	{
		ans = depth = 0;//初始化
		memset(path, 0, sizeof(path));
		memset(vis, 0, sizeof(vis));
		dfs(i); //访问
		for(int i=0; i<=depth; i++)
			ans += a[path[i]];
		if(ans > max1) //当前更优
		{
			max1 = ans;
			final = depth;
			for(int i=0; i<=depth; i++)
			f[i] = path[i];
		}
	}
	for(int i=0; i<=final; i++)
	{
		cout << f[i] << " ";
	}
	cout << endl << max1;
	return 0;
} 
```


------------
## 请各位大佬指出本蒟蒻代码中的~~（太多的）~~不足，以便改正，谢谢！！！

---

## 作者：Jigsaw_Killer (赞：1)

本题的数据真的是水上加水。。。原来本蒟蒻打算先写DFS然后改成记忆化，练练手，结果。。。直接DFS，没有任何优化纯暴力就这么过了。没有任何要说明的地方，直接上代码，相信学三个月C语言的这个代码都看得懂。缩进太差，我还是解释一下吧

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
int N,num[25],edge[30][30],ans[10005],ans1=0,ce[10005],end=0;
using namespace std;
int pan(int k)//判断有没有可以挖的雷了
{
for(int a=k+1;a<N;a++)
if(edge[k][a]==1)
return 0;
return 1;
}
int DFS(int n,int m,int sum)
{
if(pan(n))
{
if(sum+num[n]>ans1)//比当前更优，更新
{
for(int a=0;a<m;a++)
ans[a]=ce[a];
ans[m]=n;
ans1=sum+num[n];
end=m;
}
return 0;
}
int a;
for(a=n+1;a<N;a++)
{
if(edge[n][a]==1)//枚举每一条可走的边
{
ce[m]=n;
DFS(a,m+1,sum+num[n]);
ce[m]=0;
}
}
}
int main ()
{
scanf("%d",&N);
for(int a=0;a<N;a++)
scanf("%d",&num[a]);
for(int a=0;a<N-1;a++)
for(int b=a+1;b<N;b++)
scanf("%d",&edge[a][b]);
for(int a=0;a<N-1;a++)//一个小坑，可以从任意一个点出发。我第一遍没注意，只从1出发，结果还有40分。可见数据之水
DFS(a,0,0);
for(int a=0;a<=end;a++)
printf("%d ",ans[a]+1);
printf("\n");
printf("%d",ans1);
return 0;
}

```

---

## 作者：Eleven谦 (赞：0)

emmm...最开始接触这道题，是在学深搜的时候（~~具体哪本书忘了~~）那时候还做不来，就听老师讲了之后直接交的代码，并没有多大的感悟。

为了CSP，又开始复习（~~重学~~）万能的深搜；再加上想练习一下 vector ，于是重新编了一遍。交了三遍AC了。

思路：

1、题目中：“某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。”

很明显就是 DFS嘛！尝试所有N个洞作为起始点，不断探索与之相连的点（洞），把每一种方案的结果记录下来再比较最大，完事！

2、不过，这道题还要求输出最大值的路径。我认为这才是这道题的难点（~~最大值直接套深搜板子就好~~）。那就用一个数组 nxt记录路径。每当更新最多地雷数的时候，顺便也将路径更新。当然，要用另外一个数组sum保存。

具体的见代码注释吧

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x,k,ans,tot,nxt[10010],a[10010],sum[10010],p[10010];
vector<int> ssty[10010];

inline void dfs(int x,int y,int tot) { //x记录位置，走了y个点，tot是当前的地雷数
	bool pd=false; //判断当前方案是否走到极点
	for(register int i=0; i<ssty[x].size(); i++) { //与x点相连的点
		if(p[ssty[x][i]]==0) { //没有走过
			pd=true; //方案没有结束
			p[ssty[x][i]]=1; //标记为走过
			nxt[y+1]=ssty[x][i]; //记录路径
			dfs(ssty[x][i],y+1,tot+a[ssty[x][i]]); //从这个点继续向下挖
			p[ssty[x][i]]=0; //回溯必备
		}
	}
	if(pd==false) {
		if(ans<tot) { //如果最大值更改，说明路径也要改变
			ans=tot;
			k=y;
			for(register int i=1; i<=y; i++) sum[i]=nxt[i]; //将最大值路径复制在sum数组中
		}
		return;
	}
}

int main() {
	scanf("%d",&n);
	for(register int i=1; i<=n; i++) scanf("%d",&a[i]);
	for(register int i=1; i<n; i++) { //题目要求的输入
		for(register int j=i+1; j<=n; j++) {
			scanf("%d",&x);
			if(x==1) ssty[i].push_back(j); //将与 i 洞相连的点加入“队列”
		}
	}
	for(register int i=1; i<=n; i++) { //尝试每一个点
		p[i]=1; //标记为已走过
		nxt[1]=i; //将第一个洞设为自己
		dfs(i,1,a[i]);
		p[i]=0;
	}
	for(register int i=1; i<=k; i++) printf("%d ",sum[i]); //最终的最大值路径
	printf("\n%d",ans); //最多能挖到的地雷数
	return 0;
}
```

深搜，一种把板子套上去就差不多成功一半的神奇算法QVQ

如果这篇题解有任何问题，欢迎指正，谢谢！

---

## 作者：kangli (赞：0)

## DFS算法 0ms ##
做法：暴力枚举每个点是否走过，若走过则不用走。
     
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int f[22],n,ans=0,b[22],v[22][22],ls[22],len=1;
bool go[22];//是否走过
void dfs(int now,int quan,int pan,int ff)
{
    for (int i=1; i<=n; i++)
    if (!v[now][i]||!go[i]) pan++;//判断有无其他路径可走
    if (pan==n)
    {
        if (ans<quan)
        {
            memset(b,0,sizeof(b));
            for (int i=1; i<=len; i++)
            b[i]=ls[i];
            ans=quan;
        }
        return ;
    }
    pan=0;
    for (int i=1; i<=n; i++)
    {
        if (i==ff) continue;//自己不用搜，剪枝
        if (v[now][i] && go[i])
        {
            go[i]=false;
            quan+=f[i];
            ++len;
            ls[len]=i;
            dfs(i,quan,pan,ff);
            quan-=f[i];
            ls[i]=0;
            len--;
            go[i]=true;、//回溯
        }
    }
}
int main()
{
    scanf("%d",&n);
    for (int i=1; i<=n; i++) scanf("%d",&f[i]);
    for (int i=1; i<=n-1; i++)
    {
        for (int j=i+1; j<=n; j++)
        {
            int x;
            scanf("%d",&x);
            if (x==1)
            {
                v[i][j]=1;
            }
        }
    }
    for (int k=1; k<=n; k++)
 memset(go,true,sizeof(go)),go[k]=false,ls[1]=k,dfs(k,f[k],0,k);每次记得清零
    for (int i=1; i; i++)
    {
        if (b[i]==0) break;//输出非零的路径，遇到零退出当前循环！
        else printf("%d ",b[i]);
    }
    printf("\n");
    printf("%d\n",ans);
    return 0;
}
```
个人建议：数据大不能用此方法（除非你是剪枝巨佬%%%%%%）

---

## 作者：Michael_Li (赞：0)

我翻了一下，楼下的众位大佬都是用dp来写，我这里推荐一个最长路的写法，~~虽然本质也是dp貌似~~

把每个点的点权作为它入边的边权，然后一开始把所有点都加入到队列里，由于它这个图是个dag，所以应该是对的，这样最后裸地spfa找到最长路在把路径输出来就行啦，注意dis[i]初值为data[i].

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#define LL long long
#define N (100001)
using namespace std;
template <typename T> void read(T&t) {
	t=0;
	bool fl=true;
	char p=getchar();
	while (!isdigit(p)) {
		if (p=='-') fl=false;
		p=getchar();
	}
	do {
		(t*=10)+=p-48;p=getchar();
	}while (isdigit(p));
	if (!fl) t=-t;
}
int n,t,h,ans,k,top,now;
int data[N],q[N],a[N],b[N],nxt[N],head[N],dis[N],fro[N],st[N];
bool vis[N];
inline void add(int x,int y,int z){
	a[++k]=y,b[k]=z,nxt[k]=head[x],head[x]=k;
}
int main(){
	read(n);
	for (int i=1;i<=n;i++){
		read(dis[i]);
	}
	for (int i=1;i<n;i++){
		for (int j=i+1;j<=n;j++){
			int x;
			read(x);
			if (x==1){
				add(i,j,dis[j]);
			}
		}
	}
	for (int i=1;i<=n;i++){
		q[++t]=i;
	}
	while (h<t){
		int u=q[++h];
		for (int p=head[u];p;p=nxt[p]){
			if (dis[u]+b[p]>dis[a[p]]){
				dis[a[p]]=dis[u]+b[p];
				fro[a[p]]=u;
				if (!vis[a[p]]){
					vis[a[p]]=1;
					q[++t]=a[p];
				}
			}
		}
		vis[u]=0;
	}
	for (int i=1;i<=n;i++) if(dis[i]>dis[ans]) ans=i;
	st[++top]=ans;
	now=ans;
	while (fro[now]!=0){
		st[++top]=fro[now];
		now=fro[now];
	}
	while (top) printf("%d ",st[top--]);
	puts("");
	printf("%d",dis[ans]);
	return 0;
}

```

---

## 作者：2015wangpengshu (赞：0)

a是原始数据，w是最优，c存的是前驱节点，d是打印，t是组号

```cpp
(#include<iostream>  
using namespace std;  
int a[30],w[30],c[30],d[30],t=1,n;  
bool sf[30][30];  
void search(int x)  
{  
    if(c[x]==0) return;  
    int y=c[x];  
    d[t++]=y;  
    search(c[x]);  
}  
int main()  
{  
    cin>>n;int max;  
    for(int i=1;i<=n;++i) cin>>a[i];  
    for(int i=1;i<n;++i) for(int j=i+1;j<=n;++j) cin>>sf[i][j];  
    w[n]=a[n];  
    for(int i=n-1;i>=1;--i)  
    {  
        max=0;  
        for(int j=n;j>=i+1;j--)  
        {  
            if(max<w[j]&&sf[i][j]) {max=w[j];c[i]=j;}  
        }  
        w[i]=a[i]+max;  
    }  
    max=0;int b,c;  
    for(int i=1;i<=n;++i)  
        if(w[i]>max) {max=w[i];b=i;}  
    d[0]=b;  
    search(b);  
    for(int i=0;i<t;++i) cout<<d[i]<<" ";  
    cout<<endl;  
    cout<<max;  
})
```（c/c++）


---

## 作者：Hydra_ (赞：0)

## 分析 ##

这道题目有些图论的味道，因为这些地窖它是选择性连通的，我就用f[i][j]来设置一个邻接矩阵。对于a数组，我们要存三个参数a[i][1]来存储当前地窖有多少个地雷，a[i][2]来存储通过这个地窖最多可以挖到多少个地雷，a[i][3]来存储，如果要挖到最多的地雷，我们经过这个地窖之后要去哪个地窖。那么这道题目就跟最长不下降序列有点像了。下面上代码


代码
--

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    bool f[210][210];//邻接矩阵
    int a[210][4],n;//a数组上面有介绍
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i][1]);//读入地雷数量
        a[i][2]=a[i][1];//默认最长和是自身
        a[i][3]=0;//后继是0代表结束了。
    }
    for(int i=0;i<=209;i++)
    for(int j=0;j<=209;j++)
    f[i][j]=false;//邻接矩阵的初始化，默认都不能通
    int x=0;
    for(int i=1;i<=n-1;i++)
    for(int j=i+1;j<=n;j++)
    {
        cin>>x;
        if(x==1) f[i][j]=true;//在图中造路，注意是有向图
    }
    
    for(int i=n-1;i>=1;i--)
    {
        int maxbomb=0,nexthole=0;//maxbomb代表当前这个地窖过去以后可以挖掉多少地雷，nexthole代表要挖到最多的地雷，接下来应该去哪里
        for(int j=i+1;j<=n;j++)
        if((a[j][2]>maxbomb)&&(f[i][j]))//如果能挖到的地雷多于当前记录的，并且ij之间有通路
        {
            maxbomb=a[j][2];
            nexthole=j;//更新累加和与标记
        }
        if(nexthole>0)//如果更改过
        {
            a[i][2]=a[nexthole][2]+a[i][1];//那么就把累加和记录进去
            a[i][3]=nexthole;//更新当前结点的后继
        }
    }
    int ans=0;
    int firsthole=0;
    for(int i=1;i<=n;i++)
    if(a[i][2]>ans)
    {
        ans=a[i][2];
        firsthole=i;
    }//来寻找要挖到最多的地雷，第一个对哪个地窖下手。
    while(firsthole>0)//这里跟链表的遍历有点像。真的太像了
    {
        printf("%d ",firsthole);//打印路径
        firsthole=a[firsthole][3];//后继
    }//如果是0，就代表没有后继了
    printf("\n%d",ans);//把路径长度打印出来
    return 0;
}
```

---

## 作者：石榴 (赞：0)

发一发比较暴力的题解，数据200就超时orz。。。

我也没有考虑字典序输出最小

先从每个入度为1的节点暴力dfs，搜索dp值并更新

然后从dp值最大的那个往回搜


```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<queue>
#include<map>
#define N 1000
using namespace std;
int n;
int hea[N],nex[N],to[N],val[N];
int hea1[N],nex1[N],to1[N];
int dp[N];
int zr[N];
int st[N];
int zhan[N];
int head;
void dfs(int now,int pre)
{
    dp[now]=max(dp[now],val[now]);
    if(to[hea[now]]==pre&&!nex[hea[now]]) {
        return ;
    }
    for(int i=hea[now];i;i=nex[i]){
        int j=to[i];
        if(j!=pre){
            dp[j]=max(dp[j],dp[now]+val[j]);
            dfs(j,now);
        }
    }
}
void dfs1(int now ,int pre)
{
    if(to1[hea1[now]]==pre&&!nex1[hea1[now]]) {
        return ;
    }
    for(int i=hea1[now];i;i=nex1[i]){
        int j=to1[i];
        if(j!=pre&&dp[j]==dp[now]-val[now]){
            zhan[++head]=j;
            dfs1(j,now);
        }
    }
}
int main()
{
    int vis=0;
    int gg=0;
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&val[i]);
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            int x;
            scanf("%d",&x);
            if(x==1){
                to[++vis]=j,nex[vis]=hea[i],hea[i]=vis;
                to1[vis]=i,nex1[vis]=hea1[j],hea1[j]=vis;
            }
        }
    }
    for(int i=1;i<=n;i++) if(!zr[i]) st[++gg]=i;
    for(int i=1;i<=gg;i++){
        dfs(st[i],0);
    }
    int maxn=0;
    for(int i=1;i<=n;i++) if(dp[i]>maxn)maxn=max(maxn,dp[i]),gg=i;
    zhan[++head]=gg;
    dfs1(gg,0);
    cout<<zhan[head--];
    while(head>0) printf(" %d",zhan[head--]);
    cout<<endl;
    cout<<maxn<<endl;
    return 0;
}

```

---


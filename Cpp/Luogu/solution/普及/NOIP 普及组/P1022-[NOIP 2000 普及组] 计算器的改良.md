# [NOIP 2000 普及组] 计算器的改良

## 题目背景

NCL 是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手 ZL 先生。


## 题目描述

为了很好的完成这个任务，ZL 先生首先研究了一些一元一次方程的实例：

- $4+3x=8$。
- $6a-5+1=2-2a$。
- $-5+12y=0$。

ZL 先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及 `+`、`-`、`=` 这三个数学符号（当然，符号“`-`”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。

你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。


## 样例 #1

### 输入

```
6a-5+1=2-2a
```

### 输出

```
a=0.750```

# 题解

## 作者：吴名玄 (赞：483)

这道题思维难度和代码难度都不大，就是细节处理有点麻烦，需要判断一些特殊情况（~~比如 --0.0什么的~~）。那我就直接上~~代码~~思路了。

------------
因为是一元一次方程，所以最终一定可以化成 $kx+b=0$ 的形式，整理可得 $x=-\frac{b}{k}$ ，为了~~减少变量数~~方便，将等号右边的多项式直接移到等式左边，即系数均乘 -1，可以用一个变量标记一下。

------------
## 然后就是一连串的判断：
1. 对于符号 ‘+’，‘-’，‘=’ 的处理
```cpp
if(c=='-') {b+=now*f*x;x=0;f=-1;}
if(c=='+') {b+=now*f*x;x=0;f=1;}
if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;}
```
	这里 b 为常数部分的值；now 表示相对等号的位置，左边为 1 ，右边为 -1；f 表示项的系数的正负性，x 则是项的系数。
	
    读到加号，常数累加，系数清零，符号标记为正，减号同理。读到等号则需额外将 now 改为 -1。

1. 关于数字的读入
```cpp
if(c>='0'&&c<='9') {x=x*10+c-'0';}
```
	若判定为数字则叠加当前项系数。
    
1. 关于未知数的处理
```cpp
if(c>='a'&&c<='z') {k+=now*f*x;x=0;a=c;}
```
	若判定为小写字母，则将未知数的系数累加，项系数清零，并标记未知数名 a。   

------------
至此，这一题就成功的~~解决~~挂掉了。因为(~~变量 r 的含义还没讲呢！~~)还有
## 特殊情况
1. 要是遇到 +x , -x 这种情况怎么办？

	那还不简单，系数为 0 就默认改为 1 就好了嘛。
    ```cpp
	if(c>='a'&&c<='z')
    {
    	x?k+=now*f*x:k+=now*f;
        x=0;a=c;
    }
	```
    那如果是 +0x , -0x 这种~~毒瘤~~情况又怎么办？
    
    这就需要引入一个新的变量 r 来标记是否有系数的读入。至于 r 的处理，只需要在读到数字时将 r 置为 1 ，读到其它字符都将 r 置为 0 就行了。
    ```cpp
	if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
	if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
	if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
	if(c>='a'&&c<='z')
	{
		if(r)
		{
			k+=now*f*x;x=0;
		}
		else k+=now*f;
		a=c;r=0;
	}
	if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
	```
    
1. 遇到 $-x=0$ 这种情况总是输出 -0.0 怎么办？
	
    我就是这个原因死在了第五个点，~~看了题解才知道原来是因为~~ 0 除以负数会被计算成 -0.0 。所以需要特判一下。
    
# 完整AC代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
char c,a;//c用来读入,a是未知数名
int f=1,now=1,k,b,x;//f初始化为正，now初始为左，k、b、x意义如上
bool r;//用来判是否有数字读入
int main()
{
	while(cin>>c)//各种处理上面已经解释的很清楚了……（吧）
	{
		if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
		if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
		if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
		if(c>='a'&&c<='z')
		{
			if(r)
			{
				k+=now*f*x;x=0;
			}
			else k+=now*f;
			a=c;r=0;
		}
		if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
	}
	b+=now*f*x;//加上最后一项常数（若最后一项是未知数则会加0）
    double ans=double(-b*1.0/k);
	if(ans==-0.0) ans=0;//特判，将-0.0改为0
	printf("%c=%.3lf",a,ans);//保留三位小数输出
	return 0;
}
```

---

## 作者：Jy_Amoy (赞：237)

大致的看了下题解

感觉大家都把这道题想难了

其实是~~十分简单~~的

↓讲一下我是怎么想的↓

~~看到题目后我先去翻了下小学五年级的课本~~

~~明白了如何解一元一次方程：~~

- 1.去分母：在方程两边都乘以各分母的最小公倍数； （这个不需要）

- 2.去括号：先去小括号，再去中括号，最后去大括号； （这个也不需要）

- 3.**移项**：把含有未知数的项都移到方程的一边，其他项都移到方程的另一边；

- 4.**合并同类项**：把方程化成ax=b(a≠0)的形式；

- 5.**系数化成1**：在方程两边都除以未知数的系数a，得到方程的解


看完了步骤，我相信大家能想出一点东西了把

我看到这想到了**可以把未知数的系数储存起来，把数字也储存起来，最后再相÷**

然后就开始打代码了↓

这是代码：：

`
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
double num=0,x=0;//num是数字之和，x为系数之和 
char c,p;//c被用作读入每一个字符，p用来储存未知数是啥 
int a[100],l=1,mid,pd;//a[]储存每一个出现的数,l记录数组长度,mid分开等号两边,pd为判断此数字是正是负 
int main()
{
    memset(a,0,sizeof(a));//数组清0，因为第一个有可能是又前置符号的数，这样不好解决判断问题，索性全为0，最后加起来也没啥影响 
    pd=1;//默认开头第一个数为正 
    while(c!='=')//读入等号左边 
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;//只要判断是-数，切换到下一个数,设置这个数为负数 
        if(c=='+')
            ++l,pd=1;//判断为正，切换下一个数，设置这个数为正数 
        if(c>='0'&&c<='9')//读入的是数字 
        {
            if(!a[l])//这个数字字符是数字中的第一个 
                a[l]=(c-'0')*pd;//赋值（记得乘上判断的数） 
            else
                a[l]=a[l]*10+(c-'0')*pd;//数字中已经有数了，为了加上这个数，向前移一位再塞进去 （记得乘上判断的数） 
        }
        if(c>='a'&&c<='z')//发现未知数！ 
        {
            p=c;
            if(a[l]!=0)
                x+=a[l],a[l]=0;//如果有前面的系数，则存入系数集合，把塞在数字数组中的系数去掉 
            else
                x+=pd;//判断特殊情况如-x/+x 
            --l; //减去这一位数 
        }
    }
    mid=l,++l,pd=1;//存储mid，数组位数进一位，pd=1与上面同理 
    while(c!='\n')//同上 
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;
        if(c=='+')
            ++l,pd=1;
        if(c>='0'&&c<='9')
        {
            if(!a[l])
                a[l]=(c-'0')*pd;
            else
                a[l]=a[l]*10+(c-'0')*pd;
        }
        if(c>='a'&&c<='z')//这里有点不一样，因为未知数要放在等号左边所以这里要减去系数 
        {
            p=c;
            if(a[l]!=0)
                x-=a[l],a[l]=0;
            else
                x-=pd; 
            --l; 
        }
    }
    for(int i=1;i<=l;++i)//叠加数字 
    {
        if(i<=mid)//在等号左边要减去 
            num-=a[i];
        else//在等号右边的要加上 
            num+=a[i]; 
    }
    if(!(num/x))//这里要加个特判断，因为会出现-0，虽然-0和0等效，但评测机并不吃这一套 
        printf("%c=0.000",p);
    else
        printf("%c=%.3lf",p,num/x);//输出 
    return 0; 
}
```
`
至于那个特判断我问了下老师和机房的大佬

得出了

> > 浮点数的表示里会有负零，负零被表示为指数为编码内任意合法数值、所有系数均为零、符号比特为一的数。和正零等效

也希望这个题解能给大家提供点帮助把






---

## 作者：teafrogsf (赞：49)

## 此题不需要代码很长的模拟。

我们首先可以~~敏锐地~~发现，+的ASCII码值为43，-的ASCII码值为45，于是在判断是+还是-时，只需要算s[i]-44再乘个-1就可以了。

所有加减操作都可以在一个if里解决——当判断到符号时，**用存好的上一个符号结算在这个符号之前的那个数。**这种方法主要的难点是**特判**。

### ① 读入

读入的时候从1开始，0的位置添加一个加号，方便计算。循环中判定一下字母是什么。

### ② 等于号

检查到等于号时，将lor从1变为-1。\_lor是用于切换在方程左边还是右边的int。\_等于号直接变为加号就可以了，注意存一下等于号的位置。

### ③ 结果

将分子(整数和)和分母(未知数系数和)放在方程两边(在计算时的实现是son比mother**多乘一个-1**)，直接相除即可。

### ④ 0

当一个未知数前面只有一个负号或正号(比如-x)，系数为±1。需进行特判。同时，若这个数是0则它就是0，不能修改它。这一点详见代码，我是用是否走过循环来判定的。

### ⑤ 0.0(C/C++)

~~上面这个东西并不是表情符号。~~当0除以一个负数时，C/C++会默认将其判断成-0.0。所以要特判一下。

### ⑥ 计算过程

公式是son=x\*lor\*-1\*(s[pre]-44)\*-1，mother少一个-1。

### ⑦ 代码

如下。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#define f(i,a,b) for(register int i=a;i<=b;++i)
bool flag,havenum;
char s[100010],ansx;
int son,mother,pre,lor=1,equal;
int main()
{
    int len;
    scanf("%s",s+1);
    s[pre]='+';len=strlen(s+1);s[len+1]='+';//随便一个符号都可以
    f(i,1,len+1)
    {
        if(s[i]>='a'&&s[i]<='z')ansx=s[i];
        if(s[i]=='='||s[i]=='-'||s[i]=='+')
        {
            havenum=0;
            if(i==1||i-1==equal){pre=i;continue;}
            int j,x=0;
            if(isdigit(s[i-1]))flag=0;
            else flag=1;
            for(j=pre+1;j<=i-1-flag;++j)
            {x=(x<<1)+(x<<3)+(s[j]^'0');havenum=1;}
            if(havenum==0)x=1;
            if(flag==0)son+=x*lor*-1*(s[pre]-44)*-1;
            else mother+=x*lor*(s[pre]-44)*-1;//ASCII - 45 + 43
            //printf("%d %d %d %d\n",i,x,son,mother);
            pre=i;
            if(s[i]=='=')lor=-1,s[i]='+',equal=i;
        }
    }double ansy=double(son)/double(mother);if(fabs(ansy)-0.0<0.000001)ansy=0.0;
    printf("%c=%.3lf",ansx,ansy);return 0;
}
```

---

## 作者：JustinRochester (赞：6)

[题目](https://www.luogu.org/problemnew/show/P1022)

嗯......感觉这道题不难，但是好坑......

------------

**【分析】**
-------------
正常人做这种数学题时，我们一般先进行移项。

将含未知数的移到左边，不含未知数的移到等式右边。

接着，两边分别化简，然后左边的除到右边，得到答案。

这题的思路也大概如此。

因此，我们在输入等号前，输入的常数应化为其相反数，系数不变；输入等号后，输入的系数应化为其相反数，常数不变(移项会变号)。

那如何判断是常数还是系数呢?实质上，系数的后面一定跟有未知数。只要判断下一个字符是不是字母就可以确定是哪一个了。

有人可能会问，如果这个是常数，那不就相当于将下一项的正负('+'或'-')也给输入了吗?

所以我们这里可以优雅地处理一下(论如何优雅地处理代(zhuang)码(bi)2333)：

如果下一项是字母，就再次输入字符，保证其与不是字母的具有一致性。

然后，再将正负性输出，作为下一次的输入。

这样，这个程序的主体就差不多解决完了，剩下的细节修改一下就行了。

------------
**【代码】**
-------------
本蒟蒻就奉上代码了:
```cpp
#include<cstdio>
#include<cctype>
using namespace std;
float x=0,y=0;
char b=0;
int read(int k){//k为上一项传下来的正负号,在这里当作符号使用 
	float ans=0;//储存数值 
	char c=getchar();
	while(!isalpha(c)&&!isdigit(c)) {
		if(c=='-') k=-k;//如果得到'-',则将k变号 
		c=getchar();
	}
	while(isdigit(c)) {//数值输入 
		ans=ans*10+c-'0';
		c=getchar();
	}
	if(isalpha(c)) {//如果是常数 
		x+=k*ans;//等式左边系数不变号 
		ans=0;
		if(!isalpha(b)) b=c;//若还未储存变量名称，则储存一下 
		c=getchar();//保持与常数一致 
	}
	y+=(-k)*ans;//等式左边常数变号 
	return (c=='-')?(-1):((c=='+')?1:0);
	//如果下一项是正数，则返回 1 ,负数则返回 -1 ,否则(=或结束)返回 0 
}//仅为等式左边的输入 
int uread(int k) { return read(-k); }
//等式右边的输入全移到左边，相当于全部的前面加一个'-' 
int main(){
	int a=read(1);//第一项默认为正数(负数的话可以在read()中得到修改) 
	while(a) { a=read(a); }//将这一项的正负用以读入这一项 
	a=uread(1);
	while(a) { a=uread(a); }
	printf("%c=%.3f",b,y/x);
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：Salmon_lee (赞：5)

C++中的奇技淫巧：**cin.peek()**大法

cin.peek()可以从缓冲区中直接"窥视"到下一个字符而不改变读取指针的位置，也就是说我们可以提前知道应该怎么处理下一个字符串片段。

例如：我们探测到下一个字符是一个数字，那么就可以直接cin>>temp来获取这个数字。~~好吧，好像并没有太大的一个用处~~

下面是代码：

	int main()
	{
		double coe = 0.0;
		double num = 0.0;
		double flag1 = 1.0;		//等号左边为1，等号右边为-1
		double flag2 = 1.0;		//遇到'-'，由1变为-1
	
		char c;							
		char letter;					 	//case中的字母
		double temp;					 	//储存获取到的数字
		while((c = cin.peek()) != -1)
		{
			if(c == '=')				
			{
				flag1 = -flag1;		   	//遇到'-'，由1变为-1
				cin.get();				    //吃掉这个字符
			}
			else if(isdigit(c))		    	
			{
				cin>>temp;
				temp = temp*flag1*flag2;	
				if(isalpha(cin.peek()))
				{
					letter = cin.peek();
					coe += temp;
					cin.get();
				}
				else num -= temp;	//因为数字在右边，所以是-=
				flag2 = 1.0;
			}
			else if(c == '-')
			{
				flag2 = -1.0;		//遇到'-'要变号，但要记得变回来
				cin.get();
			}
			else if(isalpha(c))
			{
				coe += flag1*flag2;
				flag2 = 1.0;
				cin.get();
			}
			else cin.get();
		}
		if(num==0) 			//这里是个坑，0/(负数) = -0.000
			cout<<letter<<'='<<fixed<<setprecision(3)<<0.0;
		else
			cout<<letter<<'='<<fixed<<setprecision(3)<<num/coe;
		return 0;
}

---

## 作者：Altria_Pendragon_ (赞：5)

~~难道就我一个人写出详细过程了吗~~

小学一年级难度。

首先看看$ZL$先生研究的一些一元一次方程的实例：

$4+3x=8$

$6a-5+1=2-2a$

$-5+12y=0$

方程两边合并同类项：

$4+3x=8$

$6a-4=2-2a$

$-5+12y=0$

然后两边降次排列：

$3x+4=8$

$6a-4=-2a+2$

$12y-5=0$

方程1和方程3还可以写成：

$3x+4=0x+8$

$12y-5=0x+0$

see?所以这些方程都可以表示为:

$a_1x+b_1=a_2x+b_2$

移项：

$ (a_1-a_2)x=b_2-b_1 $

分类讨论：

- 如果$a_1=a_2$

  - 如果$b_1=b_2$，方程为$0=0$，方程恒成立
  - 如果$b_1≠b_2$，方程为$0=b_2-b_1(b_1≠b_2)$，方程无解
  - 所以不可能出现$a_1=a_2$的情况
- 如果$a_1≠a_2$
  - 方程的解为$x=\frac{b_2-b_1}{a_1-a_2}$
  
然后大胆码就行了。

听说0除以负数得-0，就把它避开了……

(0真是个麻烦的数)

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3],b[3];
int main(){
    char c,x;
    int p=1,tmp=1;
    while(scanf("%c",&c)!=EOF){
        if(c=='=')p++;
        if(c=='\r'||c=='\n')break;//注意行末有换行，被坑了一次
        int f=tmp,t=0;
        while(!isdigit(c)){
            if(c=='-')f=-f;
            if(isalpha(c)){
                x=c;
                a[p]+=1*f;
                tmp=1;
                goto _;
            }
            c=getchar();
        }
        while(isdigit(c))t=(t<<1)+(t<<3)+c-48,c=getchar();
        t*=f;
        if(isalpha(c))x=c,a[p]+=t;else b[p]+=t;
        if(c=='=')p++;
        if(c=='-')tmp=-1;else tmp=1;
        _:;
    }
    if(b[1]==b[2]){
        printf("%c=0.000",x);//注意，是0.000啊，又被坑了一次
        return 0;
    }
    printf("%c=%.3f",x,(b[2]-b[1]+0.0)/(a[1]-a[2]));
    return 0;
}
```

~~这么丑的码风，应该没人抄袭了吧233~~

---

## 作者：__CJY__ (赞：4)

感谢[这篇题解](/article/no0u58xo)给我了思路。
## 思路
这里先设定一下变量，之后在题解中会用到：
* $c$：用于存储当前读取的字符。
* $a$：用于存储未知数的名称（假设只有一个未知数）。
* $f$：用于存储当前项的符号，初始值为 $1$（表示正号）。
* $w$：用于指示当前是在等号的左边还是右边，初始值为 $1$（表示左边）。
* $k$：用于累加未知数的系数，初始值为 $0$。
* $s$：用于累加常数项，初始值为 $0$。
* $t$：用于临时存储当前读取的数字，初始值为 $0$。
* $r$：布尔值，用于标记是否正在读取一个数字。

这里要用 `while(cin>>c)` 来进行读入。

接下来处理每读入进来的字符：
* 如果 $c$ 是`-`或`+`，这表示一个项的结束。根据 $w$ 和 $f$ 更新常数项 $s$，`s+=w*f*t`；重置 $f$ 为新的符号（`+`表示正，`-`表示负）；`t=0`，准备读取下一个数字；设置 `r=0`，表示当前不在读取数字。
* 如果 $c$ 是`=`，表示等式两边的切换。更新 $s$ 以包括当前项，`s+=w*f*t`；切换 $w$ 到右边，`w=-1`；`f=1,t=0,r=0`。
* 如果 $c$ 是小写字母（即未知数），这表示遇到了未知数。如果 $r=1$，说明之前读取了一个数字，应更新 $k$，`k+=w*f*t`；否则，直接更新 $k$，`k+=w*f`；记录未知数名称，`a=c`；`r=0`。
* 如果 $c$ 是数字字符，更新当前数字 $t$，`t=t*10+(c-'0')`；`r=1`，表示正在读取数字。

循环结束后，最后一项可能还未被处理（如果是常数项或未知数的最后一部分）。更新 $s$ 以包括最后一项，`s+=w*f*t`。

计算未知数的值，`double ans=abs(double(-s*1.0/k))`。

格式化输出，保留三位小数。

有任何问题请指出！点个赞吧！

---

## 作者：canwen (赞：3)

## 分析
比较简单的题，虽然交了两发。

一元一次方程，统计左右两边的常数和以及左右两边所有含字母项的系数和即可。

例如对于样例 `6a-5+1=2-2a`，统计出左边的常数和 $l=-4$，右边的常数和 $r=2$，左边字母项的系数和 $l1=6$，右边字母项的系数和 $r1=-2$。

根据小学知识，等式的性质，答案就是 $\frac{r-l}{l1-r1}$。

那么注意一下如下坑点：

- 如果你用了 `double` 类型进行运算，请注意减法之后 $0$ 会添加上负号，即 $-0.000$，注意特判，否则你会 WA 测试点五。

- 注意有些时候可以忽略系数 $1$，注意根据自己的代码进行适当修改。

## Code
以下是我的一种实现方式：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar();return k*kk;}
void out(int a){if(a<0) putchar('-'),a=-a;if(a>9) out(a/10);putchar('0'+a%10);}

string s;
int len,k,f1;
char c = '\0';
double l, r, l1, r1, num;
signed main(){
	cin >> s;
	len = s.size();
	s = " " + s;
	_rep(i,1,len){
		if(s[i] == '=') k = i;
		if(c == '\0' && s[i] >= 'a' && s[i] <= 'z') c = s[i];
	}
	_rep(i,1,k-1){
		if(s[i] >= '0' && s[i] <= '9'){
			num = num*10+s[i]-'0';
		}else if(s[i] == '-'){
			l += (f1 == 0? num : -num);
			num = 0, f1 = 1;
		}else if(s[i] == '+'){
			l += (f1==0?num:-num);
		}else if(s[i] == c){
			if(num == 0 && f1 == 0) l1+=1.0;
			else if(num == 0 && f1 == 1) l1-=1;
			else l1 += (f1==1?-num:num);
		}
		if(i == k-1 && s[i]>='0'&&s[i]<='9'){
			l += (f1==0?num:-num);
		}
		if(!(s[i]>='0'&&s[i]<='9'||s[i]=='-')) num = f1 = 0;
	}
	num = f1 = 0;
	_rep(i,k+1,len){
		if(s[i] >= '0' && s[i] <= '9'){
			num = num*10+s[i]-'0';
		}else if(s[i] == '-'){
			r += (f1 == 0? num : -num);
			num = 0, f1 = 1;
		}else if(s[i] == '+'){
			r += (f1==0?num:-num);
		}else if(s[i] == c){
			if(num == 0 && f1 == 0) r1+=1.0;
			else if(num == 0 && f1 == 1) r1-=1;
			else r1 += (f1==1?-num:num);
		}
		if(i == len && s[i]>='0'&&s[i]<='9'){
			r += (f1==0?num:-num);
		}
		if(!(s[i]>='0'&&s[i]<='9'||s[i]=='-')) num = f1 = 0;
	}
	r = (r-l)/(l1-r1);
	printf("%c=%.3lf",c,r==0?(int)0:r);
	return 0;
}
```

---

## 作者：UKE_Piu (赞：3)

[P1022 [NOIP 2000 普及组] 计算器的改良 ](https://www.luogu.com.cn/problem/P1022)

这题是个模拟，细节有点恶心，但不多，主要是试着找一些 corner case

## Solution
首先我们要想想，如果让我们来接一元一次方程，我们应该如何解。

基本步骤如下：

1.合并同类项

2.将常数项移到等号右边，将未知数项移到等号左边

3.系数化为一

那么我们考虑如何对于上述操作，用代码来实现。

### 操作 $1$

对于操作 $1$，我们可以考虑维护等号两边的未知数项系数和常数项（用一个变量）。每次找到一个未知数项系数或常数项都将其累加到这个变量上

具体实现如下

```cpp
int nxt=-1; // nxt 用来存放等号的位置
int Lc=0,Rc=0,Lx=0,Rx=0;
// get(i) 用来处理以下标 i 为开头的系数，不处理负数
// Lc 表示等号左边的常数项，Lx 表示等号左边未知数项的系数
// Rc 表示等号左边的常数项，Rx 表示等号左边未知数项的系数

//处理等号左边
for(int i=0;i<F.size();i++)
  if(F[i]=='=') {
  	nxt=i;
  	break;
     // 找到等号，跳出
  }
  else if(F[i]=='-'){
  	i++;
  	int t=get(i);
  	if(F[i]==x) Lx-=t,i++;
  	else Lc-=t;
  	i--;
  }
  else if(isdigit(F[i])){
  	int t=get(i);
  	if(F[i]==x) Lx+=t,i++;
  	else Lc+=t;
  	i--;
  }

//处理等号右边，nxt 是等号，所以从 nxt+1 开始
for(int i=nxt+1;i<F.size();i++)
  if(F[i]=='-'){
  	i++;
  	int t=get(i);
  	if(F[i]==x) Rx-=t,i++;
  	else Rc-=t;
  	i--;
  }
  else if(isdigit(F[i])){
  	int t=get(i);
  	if(F[i]==x) Rx+=t,i++;
  	else Rc+=t;
  	i--;
  }
```

这里有一个细节，如果出现了如`a`或`-a`这样的未知数项，我们就无法求出它的系数。所以我们可以做一个预处理，即在`a`或`-a`的未知数前添加一个`1`

具体实现如下

```cpp
F=" "+F;
for(int i=0;i<F.size();i++){
	if(F[i]=='-'||F[i]=='+'||F[i]==' ')
	  if(isalpha(F[i+1])) F=F.substr(0,i+1)+"1"+F.substr(i+1);
    // 萌新不会insertqwq
	}
```

### 操作 $2$
对于操作 $2$，我们应该能想起来一句话“移项要变号”这一句经典的数学老是台词，那么操作 $2$ 就可以看作是用等号左边的未知数项系数减去等号右边的未知数项系数，用等号右边的常数项减去等号左边的常数项。

具体实现如下

```cpp
int X=0,C=0;
// X 表示进行完操作 $2$ 后的未知数项系数
// C 同理
X=Lx-Rx;
C=Rc-Lc;
```

### 操作 $3$
对于操作 $3$，实现是容易的，但是有一个容易被忽略的细节，即 $0 \div (-1)$ 的值默认输出是 $-0.000$（保留三位小数）

所以需要特判！

具体实现如下

```cpp
if(C==0) cout<<x<<"=0.000"; // 特判
else cout<<x<<"="<<fixed<<setprecision(3)<<(double)C*1.0/X*1.0;
```

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string F;
char x;
int get(int &i){
	int s=0;
	while('0'<=F[i]&&F[i]<='9'&&i<F.size()) s=s*10+F[i++]-'0';
	return s;
}
int main(){
  cin>>F;
  F=" "+F;
  for(int i=0;i<F.size();i++){
	if(isalpha(F[i])) x=F[i];
  	if(F[i]=='-'||F[i]=='+'||F[i]==' ')
  	  if(isalpha(F[i+1])) F=F.substr(0,i+1)+"1"+F.substr(i+1);
      // 萌新不会insertqwq
  	}
  int nxt=-1; // nxt 用来存放等号的位置
  int Lc=0,Rc=0,Lx=0,Rx=0;
  // get(i) 用来处理以下标 i 为开头的系数，不处理负数
  // Lc 表示等号左边的常数项，Lx 表示等号左边未知数项的系数
  // Rc 表示等号左边的常数项，Rx 表示等号左边未知数项的系数
  
  //处理等号左边
  for(int i=0;i<F.size();i++)
    if(F[i]=='=') {
    	nxt=i;
    	break;
       // 找到等号，跳出
    }
    else if(F[i]=='-'){
    	i++;
    	int t=get(i);
    	if(F[i]==x) Lx-=t,i++;
    	else Lc-=t;
    	i--;
    }
    else if(isdigit(F[i])){
    	int t=get(i);
    	if(F[i]==x) Lx+=t,i++;
    	else Lc+=t;
    	i--;
    }
  
  //处理等号右边，nxt 是等号，所以从 nxt+1 开始
  for(int i=nxt+1;i<F.size();i++)
    if(F[i]=='-'){
    	i++;
    	int t=get(i);
    	if(F[i]==x) Rx-=t,i++;
    	else Rc-=t;
    	i--;
    }
    else if(isdigit(F[i])){
    	int t=get(i);
    	if(F[i]==x) Rx+=t,i++;
    	else Rc+=t;
    	i--;
    }
  int X=0,C=0;
  // X 表示进行完操作 $2$ 后的未知数项系数
  // C 同理
  X=Lx-Rx;
  C=Rc-Lc;
  
  if(C==0) cout<<x<<"=0.000"; // 特判
  else cout<<x<<"="<<fixed<<setprecision(3)<<(double)C*1.0/X*1.0;
  return 0;
}
```

---

## 作者：xiyihan (赞：2)

看了一眼题解，好像没有除了 C/C++ 之外的做法，那我这里正好可以尝试使用 Python 完成这题的解答。

相比 C/C++ 这一类编译型语言，Python 这一类脚本语言正好可以完成对字符串表达式的求值。所以如果使用 Python，我们只需把这个方程转换为 Python 能够解析的表达式即可完成此题，所需的具体操作如下：

1. 将 `=` 右边的内容替换为 `-(...)`；
2. 将形如 `123x` 这种省略了乘法符号的模式补全原来的符号；
3. 将未知数替换为给定值。

而这些操作 Python 的 `re` 模块都可以高效地完成。所以代码就可以很容易的写出来了：

```python
import re
s = input().strip()
char = list(filter(lambda x: x.isalpha(), s))[0]
s0 = re.sub(r'=(.*)', r"-(\1)", s) # Step1
s1 = re.sub(rf'(\d+)({char})', r'\1*\2', s0) # Step2
def calc(s, x):
    s2 = re.sub(char, f"({str(float(x))})", s) # Step3
    return eval(s2)

def solve(s):
    b = calc(s, 0)
    k = calc(s, 1) - b
    return -b/k

print(f"{char}={solve(s1)+1e-9:.3f}")
```

---

## 作者：3_14 (赞：1)

[**题目传送门**](https://www.luogu.com.cn/problem/P1022)

# 思路


**解析**：
*   将方程分为左右两部分，以等号为分界。
*   分别解析左右两部分的系数和常数项。

**处理符号**：
*   从左到右遍历方程，记录当前的符号（正号或负号）。
*   遇到等号后，符号需要取反（因为等号右边的项需要移到左边）。

**提取系数和常数项**：
*   如果遇到数字，继续读取直到非数字字符，提取出完整的数字。
*   如果数字后面跟着字母（未知数），则将该数字作为未知数的系数。
 *   如果数字后面没有字母，则将该数字作为常数项。

**计算未知数**：
*   将所有未知数的系数相加，得到 $a$。
*   将所有常数项相加，得到 $b$。
*   解方程 $x=-\frac{b}{a}$。

**处理特殊情况**：
*   如果 $a$ 为 $0$，则方程无解或有无穷多解（根据题目描述，可以忽略这种情况）。
*   如果结果为 $-0.0$，需要将其转换为 $0.0$。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5;
void work(string&equation,char&variable,double&coeff,double&constant){
    coeff=0;// 未知数的系数
    constant=0;// 常数项
    int n=equation.size(),i=0,sign=1;// sign——当前符号，1 表示正，-1 表示负
    bool isLeft=true;// 是否在等号左边
    while(i<n){
        if(equation[i]=='='){
            isLeft=false;// 进入等号右边
            sign=1;// 重置符号
            i++;
        }else if(equation[i]=='+'){
            sign=1;// 正号
            i++;
        }else if(equation[i]=='-'){
            sign=-1;// 负号
            i++;
        }else{
            double num=0;// 当前数字
            bool isCoeff=false;// 是否是未知数的系数
            // 读取数字
            while(i<n&&isdigit(equation[i])){
                num=num*10+(equation[i]-'0');
                i++;
            }
            // 判断是否是未知数的系数
            if(i<n&&isalpha(equation[i])) {
                variable = equation[i];// 记录未知数
                if(num==0)num=1;// 如果系数为 0，默认为 1
                coeff+=sign*num*(isLeft?1:-1);// 更新系数
                i++;
            }else constant+=sign*num*(isLeft?-1:1);// 更新常数项
        }
    }
}
string equation;
char variable;
int main(){
    cin>>equation;
    double coeff=0,constant=0;
    // 解析方程
    work(equation,variable,coeff,constant);
    // 计算未知数的值
    double result=constant/coeff;
    // 处理负零的情况
    if(result==-0.0)result=0.0;
    // 输出结果，保留三位小数
    cout<<fixed<<setprecision(3)<<variable<<"="<<result<<'\n';
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/201140355)

---


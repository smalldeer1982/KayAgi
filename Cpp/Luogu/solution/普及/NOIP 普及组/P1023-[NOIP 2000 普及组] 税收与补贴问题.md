# [NOIP 2000 普及组] 税收与补贴问题

## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）


## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

- 总利润 $=$ 单位商品利润 $\times$ 销量
- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）


## 说明/提示

### 数据范围及约定

保证输入的所有数字均小于 $10^5$。

### 样例解释（2023/6/22 更新）

如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。

![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)

根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。

当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。

## 样例 #1

### 输入

```
31
28 130
30 120
31 110
-1  -1
15```

### 输出

```
4
```

# 题解

## 作者：Mitch谜团 (赞：1725)

看了半天大家的题解，好像都是解不等式啥的，大家好像都没想过：
# 说到底，计算机是用来干嘛的？
所以直接来个暴力枚举的算法：   
1：把用户输入的价格和销量通通存进数组里。   
2：如果发现有的价格和销量用户没输入则按线性的规则自己写入。  
3：在用户输入的最大价格后面按用户输入的递减数量把最后所有销量不为零的价格补充完整。   
4：现在，你已经有了一个存有所有销量大于等于零的价格-销量表。   
5：从1/-1开始枚举所有可能的补贴或税收，并看看在每种税收或补贴下总利润最高的价格是不是政府预期价，如果是则打印。（因为从最小的开始找的）      

好了，废话不多说，上代码：  

    #include <iostream>
    #include <cmath>
    using namespace std;
    int a[100010][3];//用于存放价格和销量的数组
    int main()
    {
	    int i=1,j=1,k,expect,down,max,temp,cha,xl,num,s,price,p;
	    cin>>expect;//读入预期价
	    while(cin>>a[i][1]>>a[i][2]&&a[i][1]!=-1&&a[i] [2]!=-1)//如果输入的两个数不是-1，-1
	    {
		    i++;//循环变量i++
		    if(i>2&&a[i-1][1]-a[i-2][1]>1)//如果两个价格之间差大于一
		    {
			    i--;//回到上一个读入的销量
			    cha=(a[i-1][2]-a[i][2])/(a[i][1]-a[i-1][1]);//求出每次销量减少多少：销量差/价格差
			    temp=a[i][1];//记录下价格
			    for(j=a[i-1][1]+1;j<=temp;j++)//按价格递增顺序依次写入
			    {
			    	a[i][1]=j;//写入价格
			    	a[i][2]=a[i-1][2]-cha;//按销量差写入销量
			    	i++;
			    }
		    }
	    }
	    cin>>down;//输入超过最大价格之后每次销量降低多少
	    i--;//因为上面的while循环最后有i++所以用i--抵消……
	    xl=a[i][2];//记录目前的销量
	    while(xl>0)
	    {
		    if(xl-down<0)break;//如销量小于零则退出
		    else//否则
		    {
		    	xl-=down;//销量每次减掉down
		    	i++;//循环变量++
		    	a[i][1]=a[i-1][1]+1;//每次价格+1
		    	a[i][2]=xl;//销量就是xl
		    }
	    }
	    for(j=1;j<=10000;j++)//该遍历了，因为收税相当于补贴*-1所以记录一下符号即可
	    {
		    max=-99999;//用于存储最大的总利润
		    for(k=1;k<=i;k++)//每次扫一遍每一种价格
		    {
			    num=(a[k][1]-a[1][1]+j)*a[k][2];//套公式算出总利润
			    if(num>=max)//如果总利润比目前最大的大
			    {
			        max=num;//更新max
				    price=a[k][1];//记录下价格
				    p=1;//记录下符号
			    }
		    }
		    if(price==expect){cout<<j*p;return 0;}//如果价格就是政府预期价则打印出来，因为本身就是从小到大遍历所以不用求绝对值最小的
		    max=-99999;//后面是收税，原理同上
		    for(k=1;k<=i;k++)
		    {
			    num=(a[k][1]-a[1][1]-j)*a[k][2];
			    if(num>=max)
			    {
			       max=num;
				    price=a[k][1];	
				    p=-1;
			    }
		    }
		    if(price==expect){cout<<j*p;return 0;}
	    }
        //前面有了return 0;这儿就不用了。
    }

总的来说，我觉得我的题解还是最~~暴力~~通俗易懂的。而且很短小精悍，只有66行。（你看这数字多好）   
## 还有，虽然我只是个萌新，但你看我辛辛苦苦写了这么多，能不能~~昧着~~摸着良心给我个赞再走呢？

---

## 作者：Ofnoname (赞：209)

这道题花费了我许多时间，我不仅理解了很久的题意，没有看懂题解，还在细节上出过问题，所以我写篇题解来总结总结。

- 首先我们要知道，相邻价位间销售量是线性变化的，由此可以推出没有直接给出销量的价位。比如样例中的`28 130 30 120`，由此可以计算出29时的销量应该是`125`，超过最高价位后的销量，一直推到小于0为止即可。**要相信数据一定可以整除，不然就没法做了。**

- 要求给定价位的利润最高，显然利润`ans=(单价+补贴)*销量`，也就是说对于任意价位，它的利润都不能大于给定价位的利润。比如在样例中，对于价位29，我们需要满足`(x+3)*110>=(x+2)*125`，对于价位32，需要满足`(x+3)*110>=(x+4)*95`。所有这样不等式的解集就是答案，取绝对值最小的就是答案。

- 取整问题：解出上面两个不等式就可以发现正数应该向上取整，负数应该向下取整。

### 接下来让我们模拟样例体会这个过程：

1. 读入期望价格，记为`r=31`；
2. 读入`28 130`，用`d[i]`表示价位i的销售量，则`d[28]=130`；
3. 读入`30 120`，则`d[30]=120`，并在`[28,30]`之间递推(我先计算出公差d=5，然后再计算28至30的销售量)，得到`d[29]=125`，之后以此类推；
4. 读入`15`，则递推计算`d[32]=95,d[33]=80,...,d[38]=5`，负数以后就不算了。
5. 对于价位`d[28]=130`，解不等式`(x+3)*110>=(x+0)*130`；
6. 对于价位`d[29]=125`，解不等式`(x+3)*110>=(x+1)*125`；
7. 重复循环直到结束，解出所有不等式得`4<=x<=9`;
8. 答案就是4。

其中解不等式有一些技巧，我将在代码里给出解释：

```cpp
//时间紧迫，没有整理码风，见谅
#include <bits/stdc++.h>
#define MAX (100000+100)
using namespace std;

int x,r,m,n,p,d[MAX];//r代表成本价,x代表期望价格，d代表价位
double Min=-1e9,Max=1e9;//答案区间，开始无穷大

inline void read(int &a)
{
    register char c=getchar(); bool f=0; 
    for (a=0; c<'0'||'9'<c; c=getchar())
        if (c=='-') f=1;//要写快读记得判负数，有-1
    for (; '0'<=c && c<='9'; c=getchar())
        a=(a<<3)+(a<<1)+(c^48);
    if (f) a=-a;
}

int main()
{
    read(x); read(m); read(n); r=m;//记录成本价
    while (m!=-1 && n!=-1)
    {
        d[m]=n; 
        for (int i=p+1; i<m; i++)
            d[i]=d[i-1]+(n-d[p])/(m-p);//此处递推、未知价格销量，(n-d[p])/(m-p)是公差
        p=m;//记录上一次的m。
        read(m); read(n);
    }read(m);//此时m是最后输入的数
    while (d[p]>m)
        p++,d[p]=d[p-1]-m;//继续递推，递推完成后p就是d>0的范围
    for (register int i=r; i<=p; i++)//从成本到p的递推
    {
        double ans=(d[x]*(x-r)-d[i]*(i-r))*1.0/(d[i]-d[x]);
		//求(x+d[i])*(i-r)<=（x+d[x_])+(x_-r)的通解，x_是期望价格
        double g=d[i]-d[x];//判断解的符号,g为正是小于，反之为大于。
        if (g>0) Max=min(Max,ans);//取所有"x<=..."中的最小值
        else Min=max(Min,ans);//取所有"x>=..."中的最大值
    }
	//此时[Min,Max]就是答案的范围，取绝对值最小的输出。
    if (Min>0) printf("%d",(int)ceil(Min));//Max>Min>0，答案为Min上取整
    else if (Max<0) printf("%d",(int)floor(Max));//Min<Max<0，答案为Max下取整
    else puts("0");//Min<0<Max，显然是0绝对值最小
	//此处应有Min>Max，输出"NO SOLUTION"的情况，不过其实并没有这个点，所以就省略了。
    return 0;
}
```













---

## 作者：majorli (赞：68)

# P1023 税收与补贴问题 题解



## 1. 问题的数学描述



问题是要求出政府要提供怎样的调控手段 $x$，来使得商品在特定价格 $p_z$ 时保持总利润最高。$x>0$ 表示政府补贴，$x<0$ 表示政府收税，$x=0$ 表示没有调控。

设输入的数据为二元组$(p_i,s_i)$，其中 $i\ge0$，$(p_0,s_0)$ 为商品的成本价和成本价时的销量，$(p_i,s_i)$ 是商品价格为 $p_0+i$，销量为 $s_i$。那么此时在政府调控下商品的总利润为 $t_i(x)=(p_i-p_0+x)s_i=is_i+xs_i$。这是一个直线方程（其他题解中，大部分大牛都用了 $t(i)=(i+x)s_i$ 的形式，然后计算不等式。但是我觉得用直线方程来描述这个题目更佳）。

所以，本题的数学描述是在一系列直线方程中，找到一个离起点 $x_0=0$ 最近的点 $x_z$，使得目标价格 $p_z$ 的总利润直线上的点 $t_z(x_z)$ 在其他所有价格的总利润直线的点 $t_i(x_z)$ 之上。模拟的过程就是从 $x=0$ 开始，逐步增大或减小调控量 $x$，直到第一次发现 $t_z(x)$ 大于所有其他 $t_i(x)$ 值。

根据题目给出数据的规律，我们发现，随着单个商品本身利润额 $i$ 的增大，销量 $s_i$ 是单调下降的，也就是说，直线 $t_i$ 的斜率是单调下降的。从函数图像来分析，如果两条直线 $l_1$ 和 $l_2$ 在某点 $x$ 处有 $l_1(x)>l_2(x)$，现在要移动点 $x$ 使得 $l_2(x)>l_1(x)$，当 $l_1$ 的斜率大于 $l_2$ 的斜率时，我们需要减小 $x$；反之如果 $l_1$ 的斜率小于 $l_2$ 的斜率，我们需要增大 $x$。有了这个概念之后，我们就可以分情况来本题目的数据了。

读入所有数据，并补全最后的单调线性下降部分后，首先以 $p_z$ 为分界点，把数据分为价格低于 $p_z$ 的和价格高于 $p_z$ 的两部分，前一部分的销量（也就是直线的斜率）总是大于 $s_z$（也就是 $t_z$ 的斜率），后一部分则相反。

然后进行如下模拟：

1. 分别找出前一部分的最大值和后一部分的最大值。
2. 如果前一部分的最大值比 $t_z(x)$ 大，而后一部分的最大值比 $t_z(x)$ 小，那么 $x$ 减小1，再进行下一步模拟。
3. 如果前一部分的最大值比 $t_z(x)$ 小，而后一部分的最大值比 $t_z(x)$ 大，那么 $x$ 增加1，再进行下一步模拟。
4. 如果前后两部分的最大值都比 $t_z(x)$ 小，那么当前的 $x$ 就是题目的解，模拟结束。
5. 如果前后两部分的最大值都比 $t_z(x)$ 大，那么题目无解，输出"NO SOLUTION"，模拟结束。

到目前为止，程序其实已经可以编写了。但是还是有几个问题需要优化和澄清一下。

1. 输入的数据在跳过一些价格的时候，线性插值需不需要做？这个问题如果解决了，也就顺便解决了插值会不会引出浮点数的纠结了。
2. 能不能只模拟 $p_z$ 前后两点，而不需要模拟所有点？
3. 本题是不是如某些大牛所说的肯定有解？

下面对这几个问题都进行一下分析。



### 1.1. 线性插值区域的分析



很多其他题解里有大牛说题目里如果出现线性插值区域，可以不用插值，只要对端点进行模拟即可。但是所有题解里的证明都比较简单，有些是直接出结论的，所以我来详细证明一下。

设有一段线性插值区域，从 $(p_m,s_m)$ 开始到 $(p_{m+k},s_{m+k})$ 结束，所以每两个相邻点之间销量的减少量为 $\Delta s=(s_m-s_{m+k})/k$。对于这段区域中任意一个价格点 $p_{m+i}$，$(i=0,1,\dots,k)$，其单品利润为 $m+i$，销量为 $s_m-\Delta s\cdot i$，总利润直线方程为：

$$
t_{m+i}(x) = (m+i)(s_m-\Delta s \cdot i)+x(s_m-\Delta{s}\cdot i)
$$

目标点的直线方程为：

$$
t_z(x)=zs_z+xs_z
$$

联立这两个方程后，可以求出这两个直线的交点处的 $x$ 值如下：

$$
x=\frac{zs_z-(m+i)(s_m-\Delta s\cdot i)}{s_m-s_z-\Delta s\cdot i}
$$

其中 $z,s_z,m,s_m,\Delta s$ 都是常量，$x$ 是 $i$ 的函数。如果我们能证明随着 $i$ 从 $0$ 到 $k$ 递增，$x(i)$ 也是有序地变化的，那么线性插值区域内部的价格点和目标价格的交点就不会超出两个端点和目标价格的交点，也就不需要真正进行插值，只要模拟它的端点即可。然而这是一个分子二次、分母一次的有理函数，它的取值并不能保证有序。事实上，对 $x(i)$ 求导后分析单调性可以发现：当 $z>m+k$ 时，只有满足 $\vert s_z-s_m\vert >\Delta s\vert z-m\vert$ ，即从插值区域的端点到目标价格点的平均销量降速大于插值区域内的销量降速时，$x(i)$ 才确保单调的（而本题的样例数据刚好是满足这个条件）；而当 $z < m $ 时，只有满足 $\vert s_z-s_m\vert<\vert\Delta s(z-m)\vert$，即从目标价格点到插值区域端点的平均销量降速小于插值区域内的销量降速时，$x(i)$ 才能保证单调；其他情况下无法保证插值区域内的价格点对应的 $x(i)$ 的变化是有序的。

所以很多大牛所说的插值区域可以不用插满具体的值，只需要模拟两端即可，这个结论是没有保障的。如果没有进行插值就过了，只能感恩洛谷的测试用例非常温柔。**该插值的点还是要插值！**

这就引发出本题的**第一个不明确之处：插值点是否会得到小数销量。**从数学的角度，或者从工程编程的角度出发，肯定要考虑插值点处销量为小数的情况的。但是从很多题解来看，似乎洛谷的测试用例非常善良，所有插值点都得到整数销量。反正不管是不是考虑用小数，解题的思路是一样的。我就像某位大神所说的那样，采取就简原则，就当不会出现小数来处理，全部用整数运算了。**重点是通过了！感恩洛谷的友好善良！**



### 1.2. 能不能只模拟 $p_z$ 前后两点，忽略其他点？



好吧，其实上一个问题的分析已经告诉我们，就算是保持恒定降速的线性插值区域都不能确保其中每一个点对应的总利润直线与目标价格的总利润直线的交点分布是单调有序的，更何况降速不确定的其他区域了。所以这个问题的答案已经不言而喻，肯定不能只模拟目标价格 $p_z$ 的前后两点。

事实上，如果用类似的方法进行分析，也可以得到和前一问题类似的答案。随着价格的攀升，如果销量降速也是递增，那么确实可以只模拟 $p_z$ 前后两点，忽略其他。本题提供的样例数据也正是如此，销量降速随着价格的升高，依次是5，10和15！这个样例迷惑不少人啊，不过看题解似乎这样也能过，洛谷的评判数据太体贴了。



### 1.3. 本题是不是肯定有解？



好几篇大牛的题解都说本题必定有解。然而对于这种结论，证伪比证明简单多了，给个反例就行。举反例也很简单，样例数据稍微改一下就行了，如下：

```
31
28 130
30 30
31 18
-1  -1
1
```

根据上面这套输入数据，马上可以计算得到下面的数据：

```
单品纯利润	单价	销量	初始点（无调控）时总利润
	0		28	 130	130 * 0 =  0
	1		29	  80	 80 * 1 = 80
	2		30	  30	 30 * 2 = 60
	3		31	  18	 18 * 3 = 54
	4		32	  17	 17 * 4 = 68
	5		33	  16	 16 * 5 = 80
	...
```

很显然，在 $p_z=31$ 的前半段，有两个价格点的无调控总利润 $t_1(0)=80,t_2(0)=60$ 高于 $t_z(0)=54$。由于这两个点处的总利润直线斜率 $s_1 = 80,s_2=30$ 都高于 $s_z=18$，所以如果想要让 $t_z(x)$ 追上它们，必须减小 $x$（征税）。但是同时在后半段，也至少有两个价格点的无调控总利润 $t_4(0)=68,t_5(0)=80$ 高于 $t_z(0)=54$，而且斜率 $s_4=17,s_5=16$ 都小于 $s_z=18$，所以减小 $x$ 只能让 $t_z(x)$ 越来越小于它们。这个过程反之亦然，如果增大 $x$（补贴），那么 $t_z(x)$ 会逐渐追上后半段的 $t_4(x), t_5(x)$，但和前半段的 $t_1(x),t_2(x)$ 却必然差距越拉越大。

所以如果有上述这样一套输入数据，此题无解！不少大牛可能在数学计算上有所失误（估计还是被样例数据误导了，没有考虑到降速大幅度上下波动的情况）。如果这样的失误下仍然能过本题，说明洛谷的判题数据不仅温柔体贴，而且善良。



## 2. 代码



### 2.1. 解集的判断



不得不说一下本题的**第二个不明确之处，确保指定价格的总利润最高，是指严格最高呢？还是可以有别的价格点和它一样高呢？**我首先选择后者，因为如果必须严格高于的话，会产生更多的无解。前面所说的数学上的解要落地为计算机程序里的解判断。可以整理出以下的关系：

令：

max_forward = 前半段各价格点总利润的最大值。

max_backword = 后半段各价格点总利润的最大值。

t = 目标价格点总利润值。

则：

当 max_forward > t 而且 max_backward > t 时，无解；

当 max_forward > t 而且 max_backward = t 时，无解；

当 max_forward > t 而且 max_backward < t 时，尝试增加1元税收；

当 max_forward = t 而且 max_backward > t 时，无解；

当 max_forward = t 而且 max_backward = t 时，得解；

当 max_forward = t 而且 max_backward < t 时，得解；

当 max_forward < t 而且 max_backward > t 时，尝试增加1元补贴；

当 max_forward < t 而且 max_backward = t 时，得解；

当 max_forward < t 而且 max_backward < t 时，得解。



### 2.2.  代码（C++）



刚刚一次性AC的代码，C++，用到STL库的vector类和algorithm库的max_element算法。总共七十多行，就一个main函数，还算简单的吧。14ms，924KB通过。

前面解释已经很详细了，变量名也都是完整的英语单词，不好意思不写注释了。噢对了，最后啰嗦一句，因为每一个需要插值的价格值都取完整了，所以vector元素的下标就是商品单件的纯利润，不需要保存输入的价格数据哦。


```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
	vector<int> sales;
	int target_price, tail_speed;

	cin >> target_price;
	int target_p = -1, len = 0;
	int price, sale, last_price, last_sale;
	cin >> price >> sale;
	sales.push_back(sale);
	last_price = price;
	last_sale = sale;
	if (price == target_price)
		target_p = len;
	len++;
	while ((cin >> price >> sale) && price != -1 && sale != -1) {
		int delta_sale = (sale - last_sale) / (price - last_price);
		for (int p = last_price + 1; p < price; p++) {
			last_sale += delta_sale;
			sales.push_back(last_sale);
			if (p == target_price)
				target_p = len;
			len++;
		}
		sales.push_back(sale);
		last_price = price;
		last_sale = sale;
		if (price == target_price)
			target_p = len;
		len++;
	}
	cin >> tail_speed;
	while (last_sale > tail_speed) {
		last_price++;
		last_sale -= tail_speed;
		sales.push_back(last_sale);
		if (last_price == target_price)
			target_p = len;
		len++;
	}

	vector<int> total;
	for (int i = 0; i < len; i++)
		total.push_back(i * sales[i]);

	int max_forward, max_backward, x = 0;
	while (true) {
		max_forward = *max_element(total.begin(),
				total.begin() + target_p);
		max_backward = *max_element(total.begin() + target_p + 1,
				total.end());
		int t = total[target_p];
		if (max_forward <= t && max_backward <= t) {
			cout << x << endl;
			break;
		} else if (max_forward >= t && max_backward >= t) {
			cout << "NO SOLUTION" << endl;
			break;
		}
		if (max_forward > t) {
			for (int i = 0; i < len; i++)
				total[i] -= sales[i];
			x--;
		} else {
			for (int i = 0; i < len; i++)
				total[i] += sales[i];
			x++;
		}
	}

	return 0;
}
```



---

## 作者：dodo (赞：23)

# 看到题解里好多去解不等式了，我就发一个纯模拟题解

对于每两个价格之间，因为题目说相邻价位间销量的变化是线性的，所以我们处理处每两个价格间的斜率和每一种价格的单价

## 接下来就开始模拟

容易发现，当补贴上涨时，最大利润时的价格也会随之上涨。反之，当税收上涨时，最大利润时的价格也会随之下降，所以这是一个单调递增的函数

我们先计算出当不补贴或收税时计算出最大利润时的价格，如果价格大于期望，则从小到大枚举每一个补贴，如果这时最优价格是期望就输出并退出循环。如果价格小于期望，则从大到小枚举每一个税收，如果这时最优价格是期望就输出并退出循环。才33行。。。
```cpp
#include<cstdio>
int exp,max,ans,pc,lc,ln,cnt,t=1,c,n,cc;
double k[100005],num[100005],kk,nn;
int main(){
	scanf("%d",&exp);
	scanf("%d%d",&c,&n); pc=c;
	while(c!=-1&&n!=-1){
		lc=c,ln=n,num[c]=n; 
		scanf("%d%d",&c,&n);
		k[lc]=(n-ln)/(c-lc);//计算斜率 
	}
	scanf("%d",&cnt);
	for(int i=pc;i<=lc;++i)//处理出每一个价格的销售量 
		if(!num[i]) num[i]=kk*(i-cc)+nn;
		else kk=k[i],cc=i,nn=num[i];
	while(ln-cnt>0) lc++,ln-=cnt,num[lc]=ln;
	for(int i=pc;i<=lc;++i) if((i-pc)*num[i]>max) ans=i,max=(i-pc)*num[i];//当不补贴或收税时计算出最大利润时的价格 
	if(ans==exp) puts("0");
	else if(ans>exp){//枚举补贴 
		for(int x=1;;x++){
			max=ans=0;
			for(int i=pc;i<=lc;++i) if((i-pc+x)*num[i]>=max) ans=i,max=(i-pc+x)*num[i];
			if(ans==exp){printf("%d",x);return 0;}
		}
	}
	else{//枚举税收 
		for(int x=-1;;x--){
			max=ans=0;
			for(int i=pc+1;i<=lc;++i) if((i-pc+x)*num[i]>=max) ans=i,max=(i-pc+x)*num[i];
			if(ans==exp){printf("%d",x);return 0;}
		}
	}
} 
```

---

## 作者：dingcx (赞：15)

我其实不信这道题只是黄题。。。

## 题目意思
政府有一个预期价，~~为了不丢脸~~，政府搞了一个“税收与补贴”政策，使得售价正好是政府预期价时总利润达到最高。

补贴a元钱表示每卖出一件商品能够直接多得a元；税收a元钱表示每卖出一件商品必须交出a元。

现在有几个价位（**原价也是一个，并且是第一个**），相邻价位的中间部分**按线性增长**，最后一个价位往后都按**输入的最后一个数递减**。

政府想知道补贴几元钱或税收几元钱能~~让自己不丢脸~~，如果有多解，**输出绝对值最小的**。
## 分析
定义一个记录销售量的数组xsl[i]表示单价为i元时的销售量。

读入时，用a,b记录读入的数，c,d记录上次的两个数，以计算中间的线性变化。

用一个int型函数getmax(gqs)记录在补贴gqs(给钱数,可以为负)钱时单价为多少总利润最大。

如果getmax(0)就是政府预期价，就输出0；如果getmax(0)大于政府预期价，那么**一定是补贴**，这样才能在单价少时得到更多的钱；反之就是税收。

我本来是准备搞二分来遍历的，但我太弱了，导致漏洞百出。于是我换成了暴力枚举，也能过。。。暴力就只用从1枚举到一个很大的数，找到就输出并return即可。
## 代码
```cpp
#include<cstdio>
using namespace std;
const int MAXN=100010;
int zf,cb,jg,sml;//政府预期价,成本,最大价格,最后一个价位往后的递减数
int xsl[MAXN];//销售量
int getmax(int gqs){//给钱数
    int maxm=-100000,maxa;//maxa记录单价为多少总利润最大
    for(int i=cb;i<jg;i++){//只用从成本遍历到最大价格
    	int k=(i-cb+gqs)*xsl[i];//计算总利润
    	if(k>=maxm) maxm=k,maxa=i;//修改
	}
	return maxa;
}
int main(){
	int a,b,c,d,i;
	scanf("%d%d%d",&zf,&c,&d);//原始的两个数
	xsl[c]=d;cb=c;//c后面要变化，提前cb=c
	while(scanf("%d%d",&a,&b)&&a!=-1&&b!=-1){//输入，如果是-1就退出
		for(i=c+1;i<=a;i++) xsl[i]=d-(b-d)/(c-a)*(i-c);//线性公式
		c=a,d=b;//准备下一次读入
	}
	scanf("%d",&sml);
	for(i=c+1;;i++){//计算最后一个价位往后的销售量
		xsl[i]=xsl[i-1]-sml;
		if(xsl[i]<0) break;//如果到0就不算了
	}
	jg=i-1;//记录最大价格，要-1
	int s=getmax(0);//没有税收和补贴
    //分类讨论
	if(s==zf) printf("0");//直接输出0
	if(s>zf){//补贴
		for(i=1;i<jg;i++){//遍历
			if(getmax(i)==zf){//找到
				printf("%d",i);//输出
				return 0;//返回
			}
		}
		printf("NO SOLUTION");//没找到
	}
	if(s<zf){//税收
		for(i=-1;i>-jg;i--){//同上
			if(getmax(i)==zf){
				printf("%d",i);
				return 0;
			}
		}
		printf("NO SOLUTION");
	}
	return 0;//华丽结束
}
```

---

## 作者：2011hym (赞：5)

~~前言：变量最多的一集。~~

## 题目分析

题目意思就是让你从一堆总利润中找到最大的并输出。

而利润的计算公式为：

$$
\text{利润}=(\text{单位价格}−\text{单位成本}+\text{税收或补贴}) \times  \text{销量}
$$

看一眼**标签**：**数学**。

再看一眼题中给的**数据范围**：

>保证输入的所有数字均小于 $1\times10^5$。

其实暴力推公式也不是不行。

## 思路梳理

1. 计算销量：

- 我们需要根据给定的价格和销量数据，计算出在任意价格下的销量。已知的价格和销量数据点之间是**线性变化**的，而在最高价格之后，销量会**递减**。

- 我们可以通过**线性插值**来计算任意价格下的销量。

2. 计算预期利润：

- 对于每一个可能的税收或补贴金额，计算预期利润。

- 同时，我们需要确保预期利润是**最大**的，即对于所有价格，预期价格下的利润都**不小于**（你猜我为什么加粗）其他价格下的利润。

3. 确定金额：

- 我们需要遍历**所有**的可能金额（从 $-1\times10^5$ 到 $1\times10^5$），找到使得预期下的**利润最大**，并且金额**绝对值最小**的金额。

- 如果**找不到**这样的金额，则输出 `NO SOLUTION`。记住要**大写**！（~~别问我怎么知道的~~）

感觉不是很费脑子，但是仍然要注意细节别弄错。

## 上代码
AC  Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a,h,h1,max1,max2,cou;
int m[100010],n[100010],cnt;
int solve(int pp){
    if(pp<h){
        return 0;
    }
    if(pp<=m[0]){
        return h1-(h1-n[0])*(pp-h)/(m[0]-h);
    }//可以将这两段理解成剪枝优化。
    for(int i=1;i<cnt;i++){
        if(pp<=m[i]){
            return n[i-1]-(n[i-1]-n[i])*(pp-m[i-1])/(m[i]-m[i-1]);
        }
    }
    // 如果价格高于已知的最高价位，销量以固定数值递减。
    return max(0,max2-cou*(pp-max1));
}
int main(){
    cin>>a>>h>>h1;
    while (1) {
        int p,s;
        cin>>p>>s;
        if(p==-1&&s==-1){//判断是否结束，否则就会爆炸。
            break;
        }
        m[cnt]=p;
        n[cnt]=s;//存储。
        cnt++;
    }
    cin>>cou;
    max1=m[cnt-1];//最高价位。
    max2=n[cnt-1];//销量。
    int sum=0,cnt1=-1;
    for(int i=-100000;i<=100000;i++){
        int cnt=(a-h+i)*solve(a);//计算预期总利润。
        bool flag = true;
        for(int j=h;j<=100000;j++){
            int cnt2=(j-h+i)*solve(j);
            if(cnt2>cnt){
                flag=false;
                break;
            }
        }
        // 如果预期价格总利润最大，并且当前税收或补贴金额的绝对值最小，更新结果。
        if (flag&&(cnt1==-1||abs(i)<abs(sum))){
            cnt1=cnt;
            sum=i;
        }
    }
    if(cnt1!=-1){
        cout<<sum;
    }else{
        cout<<"NO SOLUTION";
    }
    return 0;
}
```

整体感觉就是一道数学题，需要花脑子去思考，但同时码量也不小，所以感觉这道题挺不错的。

## 完结撒花~

---

## 作者：邱江坤 (赞：3)

这道题的题解挺少的，来补充一下

难点1:售价和对应销售量的计算。题目给定范围内，是线性的关系，需要自己列方程计算。在题目所给范围外，已经给定斜率，这个比较容易计算。但是，售价算错了不好排查。

难点2:题目叙述不清，根据数据，在某一个价格时利润最大，并不要求唯一最大（第四个点），所以此程序中用小于号。

PS： 如其他人所说，可以只判断相邻两个售价的利润大小，这里没有进行修改。

证明：

设$y_i = k_ix + b_i$，$y_i$为一段销量

根据市场供需原理，$k_i<0, b_i>0, y_i>0$

利润$w=(x - c + b)*y_i$，$x$为售价，$c$为生产成本，$b$为补贴金额

$w=(x - c + b)*y_i=(x - c + b)*(k_ix + b_i)=k_ix^2+b_ix+C$

所以，$w$是关于$x$的二次函数，且开口向下。易证$\exists s, \forall x \ne s, w_{max} \ge w_x $（这说明不会出现无解情况）且在$x\ne s$范围内$w$分别单调。可以只判断相邻两个售价的利润大小的，证毕。

另外，题意为，求$b$，使得$|b|$最小且对于给定s，$\forall x \ne s, w_{max} \ge w_x$



```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100000;
struct Node
{
	int pr, sel;
	bool operator< ( const Node &node )
	{
		return pr < node.pr;
	}
};
int wtf[MAXN][2], len, up;

int y;
int sel[MAXN];

void calc()
{
	for ( int i = 0; i < len - 1; ++i )
	{
		for ( int j = wtf[i][0]; j < wtf[i + 1][0]; ++j )
		{
			double d = 1.0 * ( wtf[i][1] - wtf[i + 1][1] )
			           / ( wtf[i][0] - wtf[i + 1][0] );
			double y = wtf[i][1] + ( j - wtf[i][0] ) * d;
			sel[j] = round(y);

		}

	}

	sel[wtf[len - 1][0]] = wtf[len - 1][1];

	int j;
	for ( j = wtf[len - 1][0] + 1; j < MAXN && sel[j - 1] - up > 0; ++j )
		sel[j] = sel[j - 1] - up;
	wtf[len][0] = j;
	wtf[len][1] = sel[j];


}
bool sure_max ( int ii )
{
	int cost = wtf[0][0] - ii;
	int m = ( y - cost ) * sel[y];

	if ( m <= 0 ) return false;

	//printf ( "ii = %d: (%d - %d) * %d = %d\n", ii, y, cost, sel[y], m );


	for ( int i = cost; i <= wtf[len][0]; ++i )
	{
		double s = ( i - cost ) * sel[i];
		if(abs(y-i) < 10)
	//	printf ( "m=%d, y=%d, ii=%d, i=%d, s=%lf\n", m, y, ii, i, s );
		if ( i != y && s > m )
			return false;
	}

	return true;
}
int main()
{
	cin >> y;

	while ( cin >> wtf[len][0] >> wtf[len][1],
	                not ( wtf[len][0] == -1 and wtf[len][1] == -1 ) )
		++len;

	cin >> up;
	calc();
//	for ( int i = 280; i < 500; ++i )
//	{
//		cout << i << " "<< sel[i] << "\n" ;
//	}

	for ( int i = 0; i <= max ( wtf[0][0], wtf[len][0] ); ++i )
	{
		if ( sure_max ( i ) )
		{
			cout << i << endl;
			break;
		}
		if ( sure_max ( -i ) )
		{
			cout << -i << endl;
			break;
		}
	}

}


```

---

## 作者：ZHDX (赞：3)

题解重点 : 二分查找

先吐槽一下题目真的太啰嗦和不明确了. 基本上做这题是让代码去"适应"答案. 本人并不认为第4个数据点的答案正确, 详细可看代码中的说明. 

二分查找的主要目的是防止价格数据太大而导致超时. (虽然题目给出的4个数据点太简单了)

而能使用二分的基本要求是数据是合理地连续变化的, 而不是有意把人卡住而弄出一些不合理的价格与数量组合 . 

因为二分的性能是log级别的, 所以起手的政策干预上下限就设置在200000与-200000之间

让变量 int ganyu=0 , 由0开始测试. 寻找最大利润的位置. 


调整区间的判断为:

```cpp
		else if (priceformax < yuqijia)
		{
			maxganyu = ganyu;
		}
		else
		{
			minganyu = ganyu;
		}
```

基本意思是, 

补贴太多就会导致薄利多销, 所以要偏向于征税.  

征税太多的话导致商家抬价, 所以要偏向于补贴.

所以不断调整区间后, 会迅速找到最合适的点. 
        

```cpp
#include <iostream>
using namespace std;

//预期价
int yuqijia;

//价格,数量表
int prices[100000], counts[100000];
int arrlen = 0;



void collect()
{
	static int inputa[100000], inputb[100000];
	int inputlen = 0;

	//预期价
	cin >> yuqijia;

	int jiage, xiaoliang;

	while (true)
	{
		//收集数据, 直到-1 -1 
		cin >> jiage >> xiaoliang;
		if (jiage == -1)
			break;
		inputa[inputlen] = jiage;
		inputb[inputlen] = xiaoliang;
		inputlen++;
	}

	//每价格减少量
	int jianshao;
	cin >> jianshao;

	//重新填表 , 题目有争议的地方, 描述不清楚, 反正成本价到最高价都得计算出来
	for (int inputi = 0; inputi < inputlen; inputi++)
	{
		jiage = inputa[inputi];
		xiaoliang = inputb[inputi];
		prices[arrlen] = jiage;
		counts[arrlen] = xiaoliang;
		arrlen++;

		int maxjiage = inputi + 1 < inputlen ? inputa[inputi + 1] : 2e8;
		while (true)
		{
			jiage += 1;
			xiaoliang -= jianshao;
			if (jiage >= maxjiage || xiaoliang <= 0)
				break;
			prices[arrlen] = jiage;
			counts[arrlen] = xiaoliang;
			arrlen++;
		}
	}

}

void program()
{
	//收集数据
	collect();

	//成本价
	int chengben = prices[0];

	//二分法寻找
	int maxganyu = 200000;//补贴, 大量的补贴会让商家考虑薄利多销
	int minganyu = -200000;//收税, 重税会让商家考虑抬高价格

	//最后合理的干预:
	int matchtimes = 0;
	int matchganyu = 0;
	int ganyu = 0;
	while (true)
	{
		//最大利润
		long long maxlirun = 0;
		//最大利润定价
		int priceformax = 0;

		//是否包含预期价
		int containsyuqijia = 0;

		int uniquecount = 0;

		for (int i = 0; i < arrlen; i++)
		{
			long long lirun = (prices[i] - chengben + ganyu)*(long long)counts[i];

			//这里需要注意一下, 利润最大必须要唯一
			if (priceformax == 0 || lirun > maxlirun)
			{
				maxlirun = lirun;
				priceformax = prices[i];
				if (prices[i] == yuqijia)
					containsyuqijia = 1;
				else
					containsyuqijia = 0;
				uniquecount = 1;
			}
			else if (lirun == maxlirun)
			{
				if (prices[i] == yuqijia)
					containsyuqijia++;
				//题目有争议的地方, 
				//如果一个策略下, 同时存在2个或以上价格是最大利润的, 
				//那么这个还能算是合适的策略不? 
				//例如第四点数据的答案是4010与4011同时达到最大的利润, 那么不排除商家选择卖4010
				uniquecount++;//not unique
			}
		}

		if (containsyuqijia)//( priceformax == yuqijia)
		{
			matchtimes++;
			matchganyu = ganyu;

			//尝试寻找绝对值更小的值
			if (ganyu == 0)
				minganyu = maxganyu = 0;
			else if (ganyu > 0)
				maxganyu = ganyu - 1;
			else
				minganyu = ganyu + 1;

		}
		else if (priceformax < yuqijia)
		{
			maxganyu = ganyu;
		}
		else
		{
			minganyu = ganyu;
		}

		int newganyu = (minganyu + maxganyu) / 2;
		if (newganyu == ganyu)
		{
			if (minganyu == maxganyu)
				break;
			//最后差异
			if (minganyu == ganyu)
				newganyu = minganyu = maxganyu;
			else
				newganyu = maxganyu = minganyu;
		}

		ganyu = newganyu;
	}

	if (matchtimes == 0)
	{
		cout << "NO SOLUTION" << endl;
		return;
	}

	cout << matchganyu << endl;


}


int main()
{
	program();

	return 0;
}


```


---

## 作者：LINYUHENG2 (赞：2)

使用模拟即可。

对于每两个价格之间，因为相邻价位间销量的变化是线性的，所以我们处理每两个价格间的斜率和每一种价格的单价。

当补贴上涨时，最大利润时的价格也会随之上涨。反之，当税收上涨时，最大利润时的价格也会随之下降，所以这是一个单调递增的函数。

我们可以这么做：先计算出当不补贴或收税时计算出最大利润时的价格，如果价格大于期望，则从小到大枚举每一个补贴，如果这时最优价格是期望就输出并退出循环。如果价格小于期望，则从大到小枚举每一个税收，如果这时最优价格是期望就输出并退出循环。

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int ex,maxn,ans,pc,lc,ln,cnt,t=1,c,n,cc;
double k[100005],num[100005],kk,nn;
int main(){
	scanf("%d",&ex);
	scanf("%d%d",&c,&n); pc=c;
	while(c!=-1&&n!=-1){
		lc=c,ln=n,num[c]=n; 
		scanf("%d%d",&c,&n);
		k[lc]=(n-ln)/(c-lc);
	}
	scanf("%d",&cnt);
	for(int i=pc;i<=lc;++i)
		if(!num[i]) num[i]=kk*(i-cc)+nn;
		else kk=k[i],cc=i,nn=num[i];
	while(ln-cnt>0) lc++,ln-=cnt,num[lc]=ln;
	for(int i=pc;i<=lc;++i) if((i-pc)*num[i]>maxn) ans=i,maxn=(i-pc)*num[i];
	if(ans==ex) puts("0");
	else if(ans>ex){
		for(int x=1;;x++){
			maxn=ans=0;
			for(int i=pc;i<=lc;++i) if((i-pc+x)*num[i]>=maxn) ans=i,maxn=(i-pc+x)*num[i];
			if(ans==ex){printf("%d",x);return 0;}
		}
	}
	else{
		for(int x=-1;;x--){
			maxn=ans=0;
			for(int i=pc+1;i<=lc;++i) if((i-pc+x)*num[i]>=maxn) ans=i,maxn=(i-pc+x)*num[i];
			if(ans==ex){printf("%d",x);return 0;}
		}
	}
	return 0;
}
```

---

## 作者：JustinRochester (赞：2)

这题没必要用那么优美的方法，暴力+分类讨论即可

**【分析】**
---

题目的表述，本蒟蒻感觉有点迷。

看了 [dalao的解释](https://www.luogu.org/discuss/show/119090) 才理解过来

所以理解题意方面就翻看这个解释吧，本蒟蒻就直接开始讲做法了：

根据题意，我们直接暴力枚举补贴和税收，因为最大值不超过 $100000$ ，所以枚举补贴的时候显然直接从 $0$ （没补贴也没收税）枚举到 $100000$ 即可

而一旦枚举到某数值的补贴有解了，我们就用 $Ans$ 记录一下答案，然后可以直接跳了。因为接下来的补贴一定绝对值更高。

其次，我们再枚举税收，枚举税收我们可以用负数来表示，从 $(-1)$ 到 $(-100000)$ 。也是一样，枚举到解就记录了跳掉。

但是，枚举税收可以加一个优化，枚举到超过 $(-Ans)$ 即跳掉，因为接下来枚举的肯定绝对值超过补贴了。而且这样一来，一旦税收枚举到解，它的结果一定绝对值比补贴小，肯定更优，可以直接替换。

所以我们可以初始化 $Ans>100000$ 的任意整数，这样就保证补贴枚举不到，不会影响税收的枚举。最后的判定也是如果 $Ans$ 为你初始设定的那个整数，就无解。

---

大体思路就是如此，接下来我们说说如何判定是否有解：

我们可以将每个相邻的两组**价格-销量**关系视为坐标上的两个点 $(x_1,y_1)$ 与 $(x_2,y_2)$ ，它们当中的价格销量呈线性变化

所以它们满足直线 $y=kx+b$

所以 $\forall x\in[x_1,x_2]$ 都有利润 $w(x)=(kx+b)(x-x_0+t)$

其中， $k={y_2-y_1\over x_2-x_1},b=y_1-kx_1,x_0$ 为成本, $t$ 为补贴或税收

代入可得 $w(x)=({y_2-y_1\over x_2-x_1}\times x+y-{y_2-y_1\over x_2-x_1}x_1)(x-x_0+t)$

展开就不算了，可以自行去算，最后算一下二次函数对称轴 $x=-{b\over2a}$

因为题目保证价格越高，销量越低，所以 $k<0,b>0$ 恒成立

所以我们分类讨论：

1. 若 $-{b\over 2a}\geq x_2$ ，则这两点中最高利润为 $w(x_2)$ ，取到该值时的价格为 $x_2$
2. 若 $-{b\over 2a}\leq x_1$ ，则这两点中最高利润为 $w(x_1)$ ，取到该值时的价格为 $x_1$
3. 其他情况，说明二次函数的最大值在该区间内，这两点中最高利润应为 $max\{w(\lceil-{b\over 2a}\rceil),w(\lfloor-{b\over 2a}\rfloor)\}$ ，取值相对应为里面的值（因为只考虑整数）

最后就是从第一对相邻两点枚举到最后一对相邻两点，求最大利润值出现的位置。判定跟预期价是否相符。如果相符，即为有解。

---

那最后这个点以后的递减如何处理呢？我们也将它化为直线的两端点就可以了：

假设最后的价格为 $P$ ，销量为 $G$ ，之后每增加 $1$ 元，销量减少 $D$

那么，我们增加 $\lfloor{G\over D}\rfloor$ 元时能保证销量为最小正整数

所以再增添一个点 $(P+\lfloor{G\over D}\rfloor,G-D\times \lfloor{G\over D}\rfloor)$ 即可

其中 $(G-D\times\lfloor{G\over D}\rfloor)$ 就是 $(G\% D)$

---

但是大家会发现，展开式这一步需要手推，再扔给计算机去算，很是麻烦。我们考虑一下优化：

$k={y_2-y_1\over x_2-x_1}={y_2-y_1\over (x_2-x_0-t)-(x_1-x_0-t)}$

$y=kx+b=kx+y_1-kx_1=k(x-x_1)+y_1$

$\therefore y=k[(x-x_0-t)-(x_1-x_0-t)]+y_1=k(x-x_0-t)+[y_1-k(x_1-x_0-t)]$

发现了没有，如果我们把所有的价格都直接减去成本，得出的税后单件利润 $x'=(x-x_0-t)$，公式会更加简单：

$w(x')=(kx'+b)x'=kx'^2+bx'$

这样，可以直接得到对称轴为 $x'=-{b\over 2k}$

其余的讨论同上。虽然计算机的计算没有简便，但至少我们的推导计算方便了很多

至于 $x'$ 的计算，在读入完以后先计算税前利润 $\hat x$ ，每次设定补贴或税收 $t$ 的时候，$x'=\hat x+t$ 即可。

其他细节就看本蒟蒻代码吧

---

**【代码】**
---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了:

```cpp#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
//#define LOCAL
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
#ifdef LOCAL
    inline char gc() { return getchar(); }
#else
    inline char gc() {
        static char s[1<<20|1]={0},*p1=s,*p2=s;
        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
    }
#endif
inline i32 read(){
    register i32 ans=0;register char c=gc();register bool neg=0;
    while(c<48||c>57) neg^=!(c^'-'),c=gc();
    while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
    return neg?-ans:ans;
}//读入优化

i32 d_Wan,d_Cnt=0;
struct xy{
    i32 d_P,d_G;
    bool operator < (const xy &t) { return d_P<t.d_P; }
}ar_xy_Goods[100010];

inline void inport(){
    d_Wan=read();
    i32 d_A,d_B;
    while( (((d_A=read())>=0)&((d_B=read())>=0)) ){
        ar_xy_Goods[++d_Cnt].d_P=d_A;
        ar_xy_Goods[d_Cnt].d_G=d_B;
    }//判定条件的解释看下文
    
    sort(ar_xy_Goods+1,ar_xy_Goods+d_Cnt+1);//f防爆
    
    f(i,2,I,d_Cnt) ar_xy_Goods[i].d_P-=ar_xy_Goods[1].d_P;//算税前利润
    
    d_Wan-=ar_xy_Goods[1].d_P;
    ar_xy_Goods[1].d_P=0;
    i32 d_Ex=read();
    ar_xy_Goods[d_Cnt+1].d_P=ar_xy_Goods[d_Cnt].d_P+ar_xy_Goods[d_Cnt].d_G/d_Ex;
    ar_xy_Goods[d_Cnt+1].d_G=ar_xy_Goods[d_Cnt].d_G%d_Ex;
    //算最后一个点
}

inline void solve(i32 d_P1,i32 d_P2,double &db_Prc,i32 &d_Pos,i32 d_Gm){
    i32 d_X1=ar_xy_Goods[d_P1].d_P+d_Gm,d_Y1=ar_xy_Goods[d_P1].d_G;
    i32 d_X2=ar_xy_Goods[d_P2].d_P+d_Gm,d_Y2=ar_xy_Goods[d_P2].d_G;
    //算税后利润和销量

    double db_K=(1.0*d_Y2-d_Y1)/(1.0*d_X2-d_X1);
    double db_B=1.0*d_Y1-db_K*d_X1;
    double db_P=-db_B/(2*db_K);//对称轴

    if(db_P>=1.0*d_X2) { db_Prc=d_Y2*d_X2,d_Pos=-d_Gm+d_X2; return ; }
    if(db_P<=1.0*d_X1) { db_Prc=d_Y1*d_X1,d_Pos=-d_Gm+d_X1; return ; }
    //d_Pos 记得要还原回去

    double db_X1=floor(db_P),db_Y1=db_K*db_X1*db_X1+db_B*db_X1;
    double db_X2=ceil(db_P),db_Y2=db_K*db_X2*db_X2+db_B*db_X2;
    if(db_Y1>db_Y2) { db_Prc=db_Y1,d_Pos=-d_Gm+db_X1; }
    else { db_Prc=db_Y2,d_Pos=-d_Gm+db_X2; }
}

inline i32 work(i32 d_Gm){
    double db_Maxprc=-0x7f7f7f7f;
    i32 d_Maxpos=0;
    f(i,1,I,d_Cnt){
        double db_Prc;
        i32 d_Pos;
        solve(i,i+1,db_Prc,d_Pos,d_Gm);
        if(db_Prc>db_Maxprc) db_Maxprc=db_Prc,d_Maxpos=d_Pos;
    }
    return d_Maxpos;
}

int main(){
    inport();
    i32 d_Ans=200000;
    f(i,0,I,100000){
        i32 d_Cal=work(i);
        if(d_Cal==d_Wan) { d_Ans=i; break; }
    }
    g(i,-1,I,-100000){
        if(-i>=d_Ans) break;
        i32 d_Cal=work(i);
        if(d_Cal==d_Wan) { d_Ans=i; break; }
    }
    if(d_Ans==200000) puts("NO SOLUTION");
    else printf("%d",d_Ans);
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---


那个 while 循环内的神奇  ~~毒瘤~~  判定条件:

```cpp
while( (((d_A=read())>=0)&((d_B=read())>=0)) ){
}
```

是这么来的：

首先会运行
```cpp
d_A=read()
```

然后这是个赋值语句，返回值就是赋的值，所以
```cpp
(d_A=read())>=0)
```

就相当于:

```cpp
d_A=read();
d_A>=0;
```

后面的同理

这样就能一边读入，一边判定是否是循环边界了

---

## 作者：LeavingAC (赞：0)

**begin**

[P1023 [NOIP 2000 普及组] 税收与补贴问题](https://www.luogu.com.cn/problem/P1023)

# 题目大意

给定一个政府期待价值 $e$ 和该商品在某些价位上的销量，以及超过已知最高单价每增加一块钱的销量的递减数量。且相邻价位之间的变化是**线性的**。

要求我们求出一个绝对值最小的 $ans$，使得该商品在政府期待价值的价位上的总利润是所有非零销量价位中总利润**最高的**。

（~~吐槽一句，这题对理解能力要求确实有点高。~~）

# 思路

我们用 $a_i$ 来表示该商品价值为 $i$ 时的销量，因为相邻价位之间变化是线性的且我们知道后续递减的销量，所以我们可以求出从成本一直到最后一个销量不为零的销量。

我们设补贴或者收税的钱为 $x$ 元。那么此时我们根据题目显然要满足对于任意 $\ge 0$ 的 $a_i$（其中 $cost$ 为成本）：

$$(e-cost+x)\times a_e \ge (i-cost+x)\times a_i$$

那么这个不等式的解集中所有值都满足题目要求，我们只要找出绝对值最小的那个即可。

# Code

```
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define gc() getchar()
#define pc(a) putchar(a)
#define sqrt(a) __builtin_sqrt(a)
#define gcd(a,b) __gcd(a,b)
#define lcm(a,b) a/__gcd(a,b)*b
#define y1 fuck_cmath
using namespace std;
const int N=1e5+10;
ll e,a[N],cost,prize,num,lst,down,avg;
db x,l=LLONG_MIN,r=LLONG_MAX; // 初始区间无限大
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>e>>cost>>num;
    lst=cost; // lst是上一个价位
    a[cost]=num;
    while (1)
    {
        cin>>prize>>num;
        if (prize==-1) break;
        a[prize]=num;
        if (prize-lst>1) // 如果中间还有其他价位就递推求解
        {
            avg=(a[prize]-a[lst])/(prize-lst); // 求公差
            for (ll i=lst+1;i<prize;i++) a[i]=a[i-1]+avg;
        }
        lst=prize; // 更新lst
    }
    cin>>down;
    while (a[lst]>down) a[lst+1]=a[lst]-down,lst++; // 求出后面所有合法销量（>0）
    for (ll i=cost;i<=lst;i++) // cost~lst 就是所有合法销量的范围
    {
        if (i==e) continue;
        x=((i-cost)*a[i]-(e-cost)*a[e])*1.0d/(a[e]-a[i]); // 通项公式（自己解一下就知道了）
        if (a[e]-a[i]>0) l=max(l,x); // x>= 中的最大值（大大取较大 这是我学不等式的时候老师教我的口诀）
        else r=min(r,x); // x<= 中的最小值（小小取较小）
    }
    if (l>r) cout<<"NO SOLUTION"; // 无解
    else if (l>0) cout<<ceil(l); // 0<l<=r
    else if (r<=0) cout<<floor(r); // l<=r<0
    else cout<<0; // l<=0<=r
    return 0;
}
```

**end**

---


# [NOIP 2002 普及组] 产生数

## 题目描述

给出一个整数 $n$ 和 $k$ 个变换规则。

规则：
- 一位数可变换成另一个一位数。
- 规则的右部不能为零。

例如：$n=234,k=2$。有以下两个规则：

- $2\longrightarrow 5$。  
- $3\longrightarrow 6$。 

上面的整数 $234$ 经过变换后可能产生出的整数为（包括原数）:

- $234$。
- $534$。
- $264$。
- $564$。

共 $4$ 种不同的产生数。

现在给出一个整数 $n$ 和 $k$ 个规则。求出经过任意次的变换（$0$ 次或多次），能产生出多少个不同整数。

仅要求输出个数。

## 说明/提示

对于 $100\%$ 数据，满足 $n \lt 10^{30}$，$k \le 15$。

**【题目来源】**

NOIP 2002 普及组第三题

## 样例 #1

### 输入

```
234 2
2 5
3 6
```

### 输出

```
4
```

# 题解

## 作者：认真的Ben (赞：185)

~~Debug写了一个下午，写写题解纪念一下，顺便复习刚学的Floyed。本题解是针对初学Floyed的同学写的，请各位大佬忽略。~~

**【算法分析】**

这道题目的一种思路是对数字进行宽度优先搜索，~~但是本蒟蒻尝试写了一下，发现非常麻烦。~~
具体可参考[传送门](https://www.luogu.org/blog/yycdeboke/solution-p1037)。

另外还有一些~~本蒟蒻尚不能理解的~~高端算法，亦可参考[传送门](https://www.luogu.org/blog/communist/solution-p1037)。

题目只要求输出方案总数，那么就要引出我们的算法了，先请出今天的主人公——弗洛伊德（Floyed）算法！

**【算法讲解】**

看这样一道题目：

给出一张含6个点，9条边的图，要求求出每两个点之间的最短距离。

![](https://cdn.luogu.com.cn/upload/pic/75533.png)

怎么做呢？我刚学的时候考虑的是**宽度优先搜索**，但这并非正解，为什么呢？

看图，若以宽度优先搜索解此题，我们将观察到栈的变化如下：
![](https://cdn.luogu.com.cn/upload/pic/75532.png)
![](https://cdn.luogu.com.cn/upload/pic/75530.png)
![](https://cdn.luogu.com.cn/upload/pic/75534.png)

可以看到，宽度优先搜索的想法并不现实，因为宽度优先搜索中，一个点一旦被访问，就不会被二次访问，因此不会更新最优解。要修改宽度优先搜索，就变成了另外一种算法——**SPFA**了。而且，宽度优先搜索每辆点之间的距离是1，只能计算经过点最少的路径。

回到这里，如何处理这个问题呢？观察1到4的最短路径是1-3-4，可见如果选取中转点，可以使路径变短，这个过程叫做**松弛**。

以dis[i][j]表示从i到j的最短距离，则有

![](https://cdn.luogu.com.cn/upload/pic/75536.png)

其中1<=i,j,k<=n。

于是我们得到了一个类似区间DP的算法，它的基本框架如下：
```cpp
memset(dis,0x3f,sizeof(dis));      //初始化为极大值
for(int i=1;i<=n;i++) dis[i][i]=0; //自己到自己不必花费
for(int k=1;k<=n;k++)
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(dis[i][j]<dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j];
		}
	}
}
```
基本思想是枚举中转点和出发、到达的点，若有更优解就更新更优解。

问题又来了，为什么k要放在外面呢？

原因很简单，DP要保证正确性，就要保证每阶段的决策都是最优解，然而dis[i,k]和dis[k,j]未必在dis[i,j]之前算出，因此会导致一种错误。譬如下图中，从6到7的最短路径本是6-1-5-4-1，但dis[7,5],dis[7,1]和dis[7,4]并未算出，于是遍历了1-7几个中转点后，dis[6,7]还未更新为最优解，就因为i,j在循环外部而不会更新解了。

![](https://cdn.luogu.com.cn/upload/pic/75549.png)

**弗洛伊德算法的时间复杂度是O（N^3)，可以处理负边权，也可以求出每两个点之间的最短路。**

另外，弗洛伊德算法还可以用于判断两点之间是否有相连的路：
```cpp
memset(dis,0,sizeof(dis));
for(int k=0;k<=9;k++)
{
	for(int i=0;i<=9;i++)
	{
		for(int j=0;j<=9;j++)
		{
			if(dis[i][j] || (dis[i][k]&&dis[k][j])) dis[i][j]=1;
		}
	}
}
```

终于讲完啦！

**【弗洛伊德算法的运用】**

回到本题，观察输入部分：

n k

x_1 y_1 

x_2 y_2

... ...

x_k y_k 

咦，长得有点像图的输入，仔细分析可以发现：这就是一个有向图呀！

以这样一组数据为例，可以画出这样的图（箭头表示数字的转换关系）：

12040 7

1 2

1 3

4 1

2 5

5 3

4 6

6 0

![](https://cdn.luogu.com.cn/upload/pic/75547.png)

看图可知，

1可以变成2、3,2又可以变成5，共有1（不变）、2、3、5四个可能数字；

同理，2有2、5、3三个可能数字。

3不能变成其他数字，只有一个可能数字。

4可以变成4、1、2、3、5五个可能数字。

5可以变成5、3两个可能数字。

6不能变成其他数字，只有一个可能数字。

0可以变成0、6两个可能数字。

在12040这个数字中，每个数码都可能变为对应的可能数字，根据乘法原理，共有4×3×2×5×2=240种可能数字，并且不会重复。

**Q:我们怎么找出每个数字对应的可能数字呢？**

**A：用弗洛伊德算法啊！**

建立一个二维表dis[10][10]，dis[i][j]=1表示数字i可以变成数字j。那么套用刚刚的代码，就可以了！


可是看看这组数据：

222222 2

1 2

2 1

猜猜刚刚的代码会有什么结果？

dis[1]={0,1,1,0,0,0,0,0,0,0};

dis[2]={0,1,1,0,0,0,0,0,0,0};

是的，dis[i][i]=1是不合法的，我们要将它改为0。

```cpp
for(int i=0;i<=9;i++)
	dis[i][i]=0; //自己不能变回自己 
```
**【代码实现】**

**Q:怎么知道每个数字可以变成多少个可能数字呢？**

**A:t[i]表示i能变成多少个可能数字，check[i]=1表示原数字中有这个数码（要不然不能变）。check可以在输入中存储（见输入部分）。如下：**

```cpp
for(int i=0;i<=9;i++)  //枚举初始数据
{
	int tmp=1;         //不变为1种方案
	for(int j=0;j<=9;j++)   //枚举变成的数字
	{
		if(dis[i][j] && check[i]) tmp++; //如果i可以变成j，并且原数字中有这个数码，就多一种方案
	}
	if(s[0]-'0'==i && dis[i][0]) tmp--;   //处理最高位不能变为0的情况 
	if(tmp) t[i]=tmp;  //存储i能变成多少个可能数字
}
```
**Q:n有30位数，最终答案也可能很大，怎么办？**

**A:高！精！度！**

其实这是高精乘低精，因为每个数码对应的可能数字最多也就是10个。

```cpp
void times(int tmp)  //高精度函数，用于计算答案
{
	int l=strlen(ans),x=0,cnt=0;   //x是每一位的得数，cnt存储进位情况
	if(tmp==10)   //唯一的两位数特别处理
	{
		for(int i=l;i>0;i--) ans[i]=ans[i-1];  //每一位都要前进一位
		ans[0]='0'; //末尾补0
    }
    else
	{
		for(int i=0;i<l;i++)  //注意高精度的数字逆序存储
		{
			x=(ans[i]-'0')*tmp+cnt;  //每一位都与乘数相乘，加上前一位的进位
			cnt=x;     //存一下以免x%10后丢失进位
			if(x>=10)
			{
				x%=10;	//只保留个位
			}
			ans[i]=x+'0';
			cnt=(cnt-x)/10;   //剩下的交给下一位
		}
		if(cnt) ans[l]=cnt+'0';  //如果乘第一位后还有进位，再填前一位
	}
}
```

**Q:输入输出怎么办？**

**A:以字符串输入，以字符串输出。**

```cpp
scanf("%s %d",s,&K);  
int L=strlen(s);
for(int i=0;i<L;i++) 
	check[s[i]-'0']++;   //记录每一个数码有无出现
ans[0]='1';              //初值要赋为1而不是0
memset(dis,0,sizeof(dis));  //弗洛伊德算法要初始化，养成好习惯

for(int i=1;i<=K;i++)
{
	int a,b;
	cin>>a>>b;
	dis[a][b]=1;       //注意这里存的是有向图
} 

for(int i=0;i<L;i++) 
    if(t[s[i]-'0'])    //0不能乘上去
        times(t[s[i]-'0']);  //乘上数码所对应的可能数字数目
	
int L_=strlen(ans);
for(int i=L_-1;i>=0;i--) cout<<ans[i];  //逆序输出
```

经历这么多以后，我们终于迎来了最爱的

**【AC代码】**

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char ans[40],s[40];int K,check[10],dis[10][10],t[10];

void times(int tmp)
{
	int l=strlen(ans),x=0,cnt=0;
	if(tmp==10)
	{
		for(int i=l;i>0;i--) ans[i]=ans[i-1];
		ans[0]='0';
    }
    else
	{
		for(int i=0;i<l;i++)
		{
			x=(ans[i]-'0')*tmp+cnt;
			cnt=x;
			if(x>=10)
			{
				x%=10;	
			}
			ans[i]=x+'0';
			cnt=(cnt-x)/10;
		}
		if(cnt) ans[l]=cnt+'0';
	}
}
int main()
{
	scanf("%s %d",s,&K);
	int L=strlen(s);
	for(int i=0;i<L;i++) 
	    check[s[i]-'0']++;
	ans[0]='1';
	memset(dis,0,sizeof(dis));
	
	for(int i=1;i<=K;i++)
	{
		int a,b;
		cin>>a>>b;
		dis[a][b]=1;
	} 
	
	for(int k=0;k<=9;k++)
	{
		for(int i=0;i<=9;i++)
		{
			for(int j=0;j<=9;j++)
			{
				if(dis[i][j] || (dis[i][k]&&dis[k][j])) dis[i][j]=1;
			}
		}
	}
	for(int i=0;i<=9;i++)
		dis[i][i]=0; //自己不能变回自己 
	for(int i=0;i<=9;i++) 
	{
		int tmp=1;
		for(int j=0;j<=9;j++)
		{
			if(dis[i][j] && check[i]) tmp++;
		}
		if(s[0]-'0'==i && dis[i][0]) tmp--;//处理最高位不能变为0的情况 
		t[i]=tmp;
	}
	for(int i=0;i<L;i++) if(t[s[i]-'0']) times(t[s[i]-'0']);
	
	int L_=strlen(ans);
	for(int i=L_-1;i>=0;i--) cout<<ans[i];
	return 0;
}
```
上面的程序片段已经有详细注释了，我~~犯懒~~就不贴了。

【总结】

1、弗洛伊德算法的时间复杂度是O（N^3)，数据范围小于500时适用。可以处理负边权。可以求出每两个点之间的最短路，适用于多次提问的题目。弗洛伊德算法还可以用于判断两点之间是否有通路。不要忘了k要放在最外层，不要忘了初始化。

2、图论题目可能会变出许多形式，但是我们要善于在图的立场上思考，怎样把题目变成图？有什么算法可以解决？

3、熟悉高精度的写法。

PS：码字不易，希望支持！

---

## 作者：communist (赞：66)

### 做完发现居然没人用map搞映射
### 特意来补充一发
#### 很容易看出这是一道搜索题
考虑搜索方案，如果按字符串转移，必须存储每种状态，空间复杂度明显会爆炸

观察到每一位之间是互不影响的
#### 考虑使用乘法原理
搜索出每一位的情况总数，求它们的连乘积即为答案
### 时间复杂度$O(n2^k)$
可以看出答案最大可以达到三十的十次方，会爆掉$long$ $long$，所以需要写高精
### 具体处理可以选择STL~~（懒得自己写）~~
对于映射，这是$map$的专长

如果一个数能够映射到多个数呢？

用$map$的时候从$char$映射到$vector<char>$即可

### 代码：
```
#include<iostream>
#include<cstdio>
#include<map>
#include<vector>
#include<cstring>
using namespace std;
map<char,vector<char> >mp;
string st;
int k,l,c[10],mul[100];
void dfs(char th)
{
    c[th-'0']=1;
    int sz=mp[th].size();
    for(int i=0;i<sz;i++)
        if(!c[mp[th][i]-'0'])
            dfs(mp[th][i]);
}
signed main()
{
    cin>>st>>k;
    l=st.length();
    for(int i=1;i<=k;i++)
    {
        char x,y;
        cin>>x>>y;
        mp[x].push_back(y);
    }
    mul[0]=1;
    for(int i=0;i<l;i++)
    {
        memset(c,0,sizeof(c));
        dfs(st[i]);
        int sum=0;
        for(int i=0;i<=9;i++)
            sum+=c[i];
        int x=0;
        for(int i=0;i<100;i++)
        {
            mul[i]=mul[i]*sum+x;
            x=mul[i]/10;
            mul[i]%=10;
        }
    }
    int i=99;
    while(i>0&&!mul[i])
        i--;
    for(;i>=0;i--)
        cout<<mul[i];
    cout<<endl;
    return 0;
}
```

---

## 作者：yangrunze (赞：62)

$\colorbox{white}{\color{white}这两天运气爆棚，不光AC300还红名了，就来写篇题解吧} $

这个题虽然表面上看是深搜，其实他就是个深搜——不过，这个题的综合性还是蛮高的，单用深搜肯定不能AC 别急，咱们慢慢讲，让我们一起A掉这道题！

看到这个题，我一开始也是这么想的：不就是深搜嘛！于是我就编（杜）写（撰）了这样一段代码：

```cpp
#include<iostream>
#include<map>
using namespace std;
bool a[15][15];//a[x][y]=1表示可以把x换成y
int ans,n;
map<string,bool> vis;//统计每一个数字有没有出现过
void dfs(string s){//因为数很大，所以可以用string存
	if(!vis[s])ans++;//统计答案
	vis[s]=1;//更新vis
	for(int i=1;i<=9;i++){//从1到9开始找
		int pos=s.find(char(i+'0'));//找到出现的位置
		if(pos!=-1){//如果找得到（注意是-1）
			for(int j=1;j<=9;j++){//从目标状态1~9枚举
				if(a[i][j]){//如果找到可以变换的了
					string ss=s;
					ss[pos]=(char)(j+'0');//变换
					dfs(ss);	//继续深搜
				}	
			}
		}
	}
}
int main(){
	string s;
	cin>>s>>n;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]=1;//处理A数组
	}
	dfs(s);//搜索
	cout<<ans;
	return 0;
} 
```
这个方法确实是对的，然而交上去之后......

[我啥也不想说，你自己看](https://www.luogu.com.cn/record/30516036)

看来这题纯暴力的搜索是不彳亍的，那有什么好方法呢？？我是思来想去，怎么也没想到，最后只好默默地点开了“[查看题解](https://www.luogu.com.cn/problemnew/solution/P1037)”

顿时，“**一位一位地变**”“**乘法原理**”等词语，瞬间映入眼帘，原来如此！我们可以按照每一位去变化，再把**变化每一位可以得到的方案数相乘**，就可以得到答案啦！

不过，在编新的代码之前，我又打量了一下a数组......

等会，这A数组怎么那么像**图的邻接矩阵**呢？？

再往这方面想想：我去！这哪只是搜索啊，这就是一个**图的遍历**的过程！

既然是图的遍历，那咱们的思路就有啦！接下来的代码，我要给大家介绍一个好用的小东西——**链式前向星**

（不会的当然也可以写邻接矩阵鸭qwq）

所谓链式前向星，顾名思义：

链式.....像链表一样**建立连接关系**

前向.....边的顺序是**从后往前存**的

所以我们可以知道链式前向星的存储结构啦！
```cpp
struct lsqxx{//l(ian)s(hi)q(ian)x(iang)x(ing)，拼音无敌（逃）
	int v;//v代表这条边的终点
	int next;//next是这个顶点的“下一条”边（也就是前一条边）
}e[15];
int head[15];//head表示每个顶点遍历时的“第一条”边（也就是编号最往后的一条边）
int tot=0;//tot表示边的编号，先初始化成0
```
而链式前向星的基本操作，就是**连边**啦！让我们来看看怎么写吧！
```cpp
void add(int a,int b){//表示连接一条从a节点到b节点的边
	tot++;//肯定要新的一条边啦！
	e[tot].v=b;//标记这条边的终点是b
	e[tot].next=head[a];//重点来啦！它的“下一条边”就是当前从a节点出发的“第一条边”
	head[a]=tot;//更新head，使当前的边变成“第一条边”
}
```
而用链式前向星进行图的遍历呢，是这样写：
```cpp
for(int i=head[x];i;i=e[i].next){//从“第一条边”开始,遍历从a出发的每一条边
		/*do something......*/	
}
```
（你品，你仔细品.....）

既然学会了链式前向星，那咱们练习一下：~~比如[用链式前向星写个SPFA](https://www.luogu.com.cn/paste/b21475al)？？~~

好了好了扯远了......我们继续来研究这个题：既然就是“图的遍历”，那我们就很容易把dfs写出来啦！
```cpp
void dfs(int x){//从数字x开始搜索
	if(vis[x])return;//如果已经搜到过了那就不用搜啦
	vis[x]=1;//标记
	ans++;//更新答案
	for(int i=head[x];i;i=e[i].next){//每一条边去找
		dfs(e[i].v);	//找到的新点再接着搜
	}
}
```
嗯~o(\*￣▽￣\*)o，不错不错

#### 但是，你以为这就完了吗？！

哎呀，标签君怎么还有个“高精”呀？？？

吓得我赶紧瞅了一眼数据范围，word天！10的30次方？！看来“乘法原理”那一步要用**高精度乘法**才OK

这是底下肯定有人说了：要高精乘法的，散了散了

别急啊，高精乘法不会写，**高精×低精**总会吧......高精乘低精和**高精度加法**很像，回想一下小学的两三位数乘一位数是怎么列竖式的，再结合一下学高精度加法的经历，咱们一起来下面的代码：
```cpp
int qwq[35];//高精度是要用数组存der
void gjcf(int x){//原有的基础上乘个x进去
	int jw=0;//进位
	for(int i=1;i<=30;i++){//为了保险，咱乘到第30位
		qwq[i]=qwq[i]*x+jw;//乘因数，加进位
		jw=qwq[i]/10;//进位的处理和高精度加法一模一样
		qwq[i]%=10;
	}
}
```
当然为了保险起见，想写高精度乘法也是可以的！友情放送一个高精度乘法的模板（就是时间复杂度高了点）：

```cpp
	for(int i=1;i<=l1;i++){
		for(int j=1;j<=l2;j++){
			c[i+j-1]+=a[i]*b[j];
			c[i+j]+=c[i+j-1]/10;
			c[i+j-1]%=10;
		}
	}
```

总的来说，这题的难度和综合性都是挺高的，既有深搜，又有高精，还涉及到一点点图论的相关知识，祝大家早日AC！（不骗赞，真的）

```cpp
#include<iostream>
using namespace std;
int ans,n;
struct lsqxx{//链式前向星
	int v;
	int next;
}e[15];
int head[15];
int tot=0;
int qwq[35];
void add(int a,int b){
	tot++;
	e[tot].v=b;
	e[tot].next=head[a];
	head[a]=tot;
}
bool vis[10];
void dfs(int x){//dfs
	if(vis[x])return;
	vis[x]=1;
	ans++;
	for(int i=head[x];i;i=e[i].next){
		dfs(e[i].v);	
	}
}
void gjcf(int x){//高精乘法
	int jw=0;
	for(int i=1;i<=30;i++){
		qwq[i]=qwq[i]*x+jw;
		jw=qwq[i]/10;
		qwq[i]%=10;
	}
}
int main(){
	string s;
	cin>>s>>n;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);//连接x到y的边
	}
	qwq[1]=1;//将记录答案的qwq数组初始化成1
	for(int i=0;i<s.size();i++){//一位一位搜索
		ans=0;//千万别忘了把答案和vis数组清零呀喂！
		for(int j=0;j<10;j++)
		vis[j]=0;
		dfs(s[i]-'0');//搜索
		gjcf(ans);//乘进去
	}
	int pos=30;
	while(!qwq[pos]&&pos>1)pos--;//删除前导0，高精度常规操作
	for(int i=pos;i>0;i--)cout<<qwq[i];//输出
	return 0;
} 
```
The    
end
$\colorbox{white}{\color{white}红名后的第一篇题解施工完毕！如愿以偿梦想成真qwq} $



---

## 作者：yedalong (赞：13)

## 前言

虽然本题算出来的答案很大，但是不会超过 `int128` 的范围，因此此题我们可以用 `int128` 来存答案，无需用到高精度，但是以防万一，建议大家在不知道答案范围的情况下还是乖乖使用高精度。

## 思路

看到这道题，肯定有不少人想到此题可以用搜索来做，但是单纯的搜索肯定会超时。\
那我们该怎么办呢？这时候，我们又看到规则只和单个数字有关，那么我们就可以只搜索单个数字，就能在很短的时间内求出这个位置上的数字能有多少种可能，这里还得加上一个记忆化，避免出现环的情况。\
那最后的答案是什么呢？我们设第 $i$ 个位置有 $x_i$ 种可能，且这个 $n$ 有 $m$ 位数，那么根据组合数学，我们可以知道答案其实就为 $\prod\limits_{i=1}^mx_i$。

## AC code:

```cpp
#include <bits/stdc++.h>
using namespace std;
int k,x[20],y[20],cnt;
bool pd[10];
__int128 ans=1;
string n;
void dfs(int ch){
	if(pd[ch]) return;
	pd[ch]=1;cnt++;
	for(int i = 1;i<=k;i++) if(x[i]==ch) dfs(y[i]);
}
void print(__int128 num){
	if(num<0) putchar('-'),num=-num;
	if(num>9) print(num/10);
	putchar(num%10+'0');
}
int main(){
	cin>>n>>k;
	for(int i = 1;i<=k;i++) cin>>x[i]>>y[i];
	for(int i = 0;i<n.size();i++){
		cnt=0;
		dfs(n[i]-'0');
		memset(pd,0,sizeof(pd));
		ans*=cnt;
	}
	print(ans);
    return 0;
}
```

---

## 作者：quanjun (赞：12)

题目链接：[https://www.luogu.com.cn/problem/P1037](https://www.luogu.com.cn/problem/P1037)  

### 题目描述
给出一个整数 $n(n<10^{30})$ 和 $k$ 个变换规则 $(k \le 15)$ 。  
规则：  
一位数可变换成另一个一位数：  
规则的右部不能为零。  

例如：$n=234$。有规则（$k=2$）：

$2$－>$5$  
$3$－>$6$  

上面的整数$234$经过变换后可能产生出的整数为（包括原数）:

$234$  
$534$  
$264$  
$564$  

共 $4$ 种不同的产生数  

问题：  
给出一个整数 $n$ 和 $k$ 个规则。
求出：
经过任意次的变换（$0$次或多次），能产生出多少个不同整数。  
仅要求输出个数。

### 输入格式
键盘输入，格式为：

$n$ $k$  
$x_1$ $y_1$   
$x_2$ $y_2$   
... ...  
$x_n$ $y_n$  

### 输出格式
屏幕输出，格式为：  
$1$ 个整数（满足条件的个数）  

### 样例输入1
```
234 2
2 5
3 6
```

### 样例输出1
```
4
```

### 题解
这个问题我们可以转换成图论里面的问题。  

我们可以把 $0$ 到 $9$ 这 $10$ 个数看成 $10$ 个点。  
然后对于任意一对关系 $x$ -> $y$ ，我们从 $x$ 向 $y$ 连一条边。  

那么我们怎么存这个图呢？  
图论里面最基础的存图方式是 __邻接矩阵__ 和 __邻接表__ 。  

__邻接矩阵__ 的方法：  
我们开一个 $10 \times 10$ 的数组 $g[10][10]$ ，  
一开始置所有的 $g[i][j]$ 为 $false$，  
然后如果有一对关系 $x$ -> $y$ ，则令 $g[x][y]$ 为 $true$。  
这样操作之后，我就知道对于任意一个数 $x$ ，它能够直接到达的数的个数，即：所有 $g[x][j]$ 为 $true$ 的数的个数。  

我们这里说的是 $x$ 到 $y$ 能直接到达是指 $x$ 到 $y$ 有一条直接可达的边（即 $g[x][y] = true$）。  
但是除了直接可达以外，还有间接可达的，比如，如果有两对关系：

$1$ -> $2$  
$2$ -> $3$  

那么 $1$ 是可以通过 $2$ 间接到达 $3$ 的。  

那么怎么确定每一个数可达的数的范围呢？比较方便的形式就是 __搜索__。  
我们再开一个bool数组 $vis[10][10]$ ，$vis[x][y]$ 用于标记 $x$ 到 $y$ 是否可达（包括直接或间接可达）；  
然后开一个函数 `dfs(int u, int s)` ，其中 $u$ 表示当前点， $s$ 表示起点，如果当前到达点 $u$ ，则置 $vis[s][u]$ 为 $true$，然后对于所有 `u` 直接可达的点 `v` ，执行 `dfs(v, s)`（但是要注意，如果此时 $vis[s][v]$ 为 $true$ ，则不需要访问了，因为递归的访问访问过的点会致使函数陷入死循环）。  

实现的伪代码如下（伪代码就是不可以编译的代码，但是你可以看懂的代码）：  
```
dfs(u, s):
    vis[s][u] = true;
    for 所有u能够直接到达的v:
        if (v没有访问过):
            dfs(v, s);
```

但是这里遇到一个问题，这个问题是邻接矩阵的效率问题，这个问题体现在：  
如果现在有 $10$ 对关系：  
$0$ -> $1$  
$1$ -> $2$  
... ...  
$8$ -> $9$  
那么如果一开始从 $0$ 开始搜索，会搜索 $10$ 层，在每一层，对于当前 `dfs(u, s)` 中的 $u$ ，我们需要从 $0$ 到 $9$ 遍历 $v$ ，所以总共需要进行 $10^{10}$ 次判断。  
而这个时间是不允许的（一道题的时间复杂度不能超过 $10^9$）！

因为邻接矩阵中存在很多多余的判断，对于任意一个 $u$ ，你需要从 $0$ 到 $9$ 去遍历 $i$ 并判断 $g[u][i]$ 是否为 $true$，来确定 $u$ 到 $i$ 是否有一条边。这样就有着很多多余的判断。  

那么是否能够对于每一个点 $u$ ，我们都用一个东西记录和它邻接的点（即：它能够到达的点）有哪些呢？  
实现的方式有两种：  
1. 链表（链表刚好可以实现这个功能）
2. 可变数组。  

__邻接表__ 的方法：  
我们在这里使用 STL （C++标准库）中提供给我们的 vector 容器来实现这个功能。  
vector 容器提供给我们的功能就是可变数组的功能。  
使用 vector 之前需要添加头文件：  
```c++
#include <vector>
```
当然这个头文件也是包含在万能头文件中的。  

我们可以通过下面的代码来体会一下 vector 的使用：  
```c++
#include <bits/stdc++.h>
using namespace std;
vector<int> vec;    // 定义一个int类型的可变数组vec
int main() {
    for (int i = 1; i <= 5; i ++)
        vec.push_back(i);   // vec内一次push进去1至5
    cout << vec.size() << endl; // vec的大小
    for (int i = 0; i < 5; i ++)
        cout << vec[i] << ",";  // 通过vec[i]获取vec的第i个元素，坐标同样从0开始
    return 0;
}
```
输出结果如下：  
```
5
1,2,3,4,5,
```

那么我们可以开一个 `vector<int>` 类型的数组 $g[10]$ ，然后对于每一对关系 $x$ -> $y$ ，执行：  
```c++
g[x].push_back(y);
```

然后想要知道点 $x$ 有哪些直接可达的点 $y$ ，可以这样遍历：  
```c++
for (int i = 0; i < g[x].size(); i ++) {
    int y = g[x][i];
}
```

但是以我多年的经验，每次执行 `g[x].size()` 效率比较低，所以我们可以一开始开一个变量 `sz` 来存放 `g[x].size()` ，然后再进行遍历，实现代码如下：  
```c++
int sz = g[x].size();
for (int i = 0; i < sz; i ++) {
    int y = g[x][i];
}
```

这样我们就大致讲解好了 __邻接表__ 的 vector 实现。  

然后我们再开一个 $cnt$ 数组， $cnt[x]$ 表示 $x$ 能够达到的数的数量。  

对于我们的样例：  
因为 $2$ 能够到达 $5$ ， $3$ 能够到达 $6$ ，所以：  
$cnt[2]=2$  
$cnt[3]=2$  
其它的 $cnt$ 值都为 $1$ 。  

所以对于 $234$ 来说，总的方案数为：  
$cnt[2] \times cnt[3] \times cnt[4] = 2 \times 2 \times 1 = 2$。

因为数据量达到了 $10^{30}$ ，用 long long 也存不下，所以得使用高精度乘法（我的代码里面实现了一个很简单的高精度乘法）。

然后我们结合上面讲到的 `dfs` 函数，可以实现代码如下：  
```c++
#include <bits/stdc++.h>
using namespace std;
char s[33];
int len, ans[33], k, x, y, cnt[10];
bool vis[10][10];
vector<int> g[10];
void dfs(int u, int s) {
    vis[s][u] = true;
    int sz = g[u].size();
    for (int i = 0; i < sz; i ++) {
        int v = g[u][i];
        if (!vis[s][v])
            dfs(v, s);
    }
}
void multi(int a) {  // 实现大数和小数的乘法
    for (int i = 0; i < 33; i ++)
        ans[i] *= a;
    for (int i = 0; i < 32; i ++) {
        ans[i+1] += ans[i]/10;
        ans[i] %= 10;
    }
}
void output() { // 输出结果
    int i = 32;
    while (i > 0 && ans[i] == 0) i --;
    while (i >= 0) cout << ans[i--];
    cout << endl;
}
int main() {
    cin >> s >> k;
    while (k --) {
        cin >> x >> y;
        g[x].push_back(y);
    }
    for (int i = 0; i < 10; i ++)
        dfs(i, i);
    for (int i = 0; i < 10; i ++)
        for (int j = 0; j < 10; j ++)
            cnt[i] += vis[i][j];
    ans[0] = 1;
    int len = strlen(s);
    for (int i = 0; i < len ; i ++)
        multi(cnt[ s[i]-'0' ]);
    output();
    return 0;
}
```

---

## 作者：lei_yu (赞：9)

### 简化版题目

首先是输入一个数，然后输入n排，每一行有一个$x$和$y$,表示$x$可以替换为$y$，特别的，$y≠0$，但$x$可以，以及如果$x$可以替换为$y$，$y$可以替换为$z$，那么$x$就可以替换为$z$。

以上就是本题的意思以及所有的坑点

### 解题过程
本题可以使用图论思想简单地解出来：

设$p[i][j]$为第$i$可以替换为$j$，输入就不用说了，
看代码吧：

```cpp
cin>>a>>n;//a为原数，n位替换规则的个数
for(int i=1;i<=n;i++)
{
	cin>>x>>y;
	p[x][y]=1;//1表示x可以替换为y，反之则不能
}
```

下一步，由于前面说的：如果$x$可以替换为$y$，$y$可以替换为$z$，那么$x$就可以替换为$z$

so我们可以使用Floyd来算出一个数字到底可以替换成其他哪几种数字，和$0/1$最短路很相似。

继续上代码

```cpp
for(int k=1;k<=9;k++)//注意这里k,j的初始值为1，因为规则右边不能为1
	for(int i=0;i<=9;i++)//注意这里i的初始值为0,因为规则左边可以为0
		for(int j=1;j<=9;j++)//Floyd
			if(p[i][k]&&p[k][j])p[i][j]=1;//0\1最短路
```

又是特别的，由于不换也是一种情况，我们需要令$p[i][i]=true$

看懂了上面，下面的步骤就比较清晰了：又设$b[i]$为数字i可以替换为其他的数字的个数，那么又双重循环预处理出每一个b[i]的值就完了。

这一段的代码如下：

```cpp
for(int i=0;i<=9;i++)
{
	p[i][i]=1;
	for(int j=0;j<=9;j++)
		if(p[i][j])b[i]++;//这里应该看得懂吧？
}
```

福利代码（自己都可以打）：输出b的值用于调试

```cpp
cout<<"b[i]:";
for(int i=1;i<=9;i++)cout<<b[i]<<" ";
cout<<endl;//用于查看b的值 
```

继续，到了算值阶段，其实就是把每一位上的数字可以替换成其他的数字的个数全部乘起来就是答案了。

不难发现答案是爆long long的，我们不得不使用高精度乘法，如果宁不会或者忘了，这里是我的博客传送门（P1303题解，几乎无人问津）

### [P1303高精度乘法](https://www.luogu.org/blog/leiyu666/solution-p1303)

附上最后一段代码，以及测试每一位的值的代码

```cpp
int z=0;//z用于进位
ans[0]=1;//ans用于存大小
for(int i=0;a[i];i++)
{
	z=0;
	int x=b[a[i]-'0'];//其实就是当前数位的数字
	//cout<<"x:"<<x<<endl<<"ans:";
	for(int j=0;j<500;j++)
	{
		ans[j]=ans[j]*x+z;//高精度乘法
		z=ans[j]/10;
		ans[j]%=10;
		//cout<<ans[j]<<" ";
	}
	//cout<<endl;
	//用于查看每一次的因数和积，不要忘了是反的 
	}
	int i=500;
	while(ans[i]==0)i--;//去除所有最高位上的0
	for(;i>=0;i--)cout<<ans[i];//最后倒着输出
```
### 完整代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
string a;
int n,x,y,p[1001][1001],b[10001];
int ans[100001];
int main()
{
	cin>>a>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		p[x][y]=1;
	}
	for(int k=1;k<=9;k++)
	for(int i=0;i<=9;i++)
	for(int j=1;j<=9;j++)
	if(p[i][k]&&p[k][j])p[i][j]=1;
	for(int i=0;i<=9;i++)
	{
		p[i][i]=1;
		for(int j=0;j<=9;j++)
		if(p[i][j])
		b[i]++;
	}
	/*cout<<"b[i]:";
	for(int i=1;i<=9;i++)cout<<b[i]<<" ";
	cout<<endl;*/
	int z=0;
	ans[0]=1;
	for(int i=0;a[i];i++)
	{
		z=0;
		int x=b[a[i]-'0'];
		//cout<<"x:"<<x<<endl<<"ans:";
		for(int j=0;j<500;j++)
		{for
		{
			
		} 
			ans[j]=ans[j]*x+z;
			z=ans[j]/10;
			ans[j]%=10;
			//cout<<ans[j]<<" ";
		}
		//cout<<endl;
	}
	int i=500;
	while(ans[i]==0)i--;
	for(;i>=0;i--)cout<<ans[i];
}
```
### CSP加油！！！！

---

## 作者：ZZA000HAH (赞：4)

对于这道题，我们可以用深度搜索 DFS。

用深度搜索是因为它的变化规则并不局限于所给原数，在变化不为 $0$ 次后所得到的数上也同样适用变化规则。

对于这道题，所用算法为：深度搜索、乘法原理、高精度计算。
给的整数范围是 $n<10^{30}$，那我们可以用一个 string 类存起来，遍历每一个数字字符，进行 DFS 找出这个数可以变化多少次，最后根据乘法原理，将每一位上的数的可能情况数量相乘，得到 ans。
## DFS

```cpp
void dfs(int id)
{
	b[id]=1;//标记，不重复搜索
	a[fl]++;//记录情况总数
	int len=G[id].size();
	for (int i=0; i<len; i++)
	{
		int x=G[id][i];//由变化规则得
		if (!b[x]) dfs(x);//搜索没搜过的
	}
}
```
### 高精度、乘法原理
乘法原理：例--小明可以从3件不同的上衣，4件不同的裤子中分别选出一件，组成一套服装，组成的服装总数为 $3\times4=12$ 件。

高精度：利用数组变相计算特别大的数。

```cpp
for (int i=0; i<fl; i++)//循环每一位
	{
		memset(d,0,sizeof(d));//初始化！
		int g,h;
		for (int j=N; j>=0; j--)
		{
			c[j]*=a[i];//乘法原理、高精度：每一位分别相乘
			g=j,h=c[j];
			c[j]%=10;
			while (h!=0)
			{
				g--;
				h/=10;
				d[g]+=h%10;
			}//高精度向前进位
		}
		for (int m=g; m<=N; m++) c[m]+=d[m];//高精度向前进位
	}
```
# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int>G[12];
const int N=90;
int a[50],fl,c[100],d[100],f;
bool b[12];
void dfs(int id)
{
	b[id]=1;//标记，不重复搜索
	a[fl]++;//记录情况总数
	int len=G[id].size();
	for (int i=0; i<len; i++)
	{
		int x=G[id][i];//由变化规则得
		if (!b[x]) dfs(x);//搜索没搜过的
	}
}
int main()
{
	c[N]=1;
	int n,k,x,y;
	string s;
	cin>>s;//用string类，很方便
	n=s.size();
	scanf("%d",&k);
	while (k--)
	{
		scanf("%d%d",&x,&y);
		if (y!=0) G[x].push_back(y);//存变化规则
	}
	for (int i=0; i<n; i++)
	{
		memset(b,0,sizeof(b));//初始化！
		dfs(int(s[i]-'0'));
		fl++;
	}
	for (int i=0; i<fl; i++)//循环每一位
	{
		memset(d,0,sizeof(d));//初始化！
		int g,h;
		for (int j=N; j>=0; j--)
		{
			c[j]*=a[i];//乘法原理、高精度：每一位分别相乘
			g=j,h=c[j];
			c[j]%=10;
			while (h!=0)
			{
				g--;
				h/=10;
				d[g]+=h%10;
			}//高精度向前进位
		}
		for (int m=g; m<=N; m++) c[m]+=d[m];//高精度向前进位
	}
	for (int i=0; i<=N; i++)
	{
		if (c[i]!=0) f=1;//从第1个不为0的数开始输出
		if (f==1) printf("%d",c[i]);
	}
	return 0;
}
```
### 无高精度代码~~80分~~

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int>G[12];
int a[50],fl;
bool b[12];
void dfs(int id)
{
	b[id]=1;
	a[fl]++;
	int len=G[id].size();
	for (int i=0; i<len; i++)
	{
		int x=G[id][i];
		
		if (!b[x]) dfs(x);
	}
}
int main()
{
	int n,k,x,y;
	unsigned long long ans=1;
	string s;
	cin>>s;
	n=s.size();
	scanf("%d",&k);
	while (k--)
	{
		scanf("%d%d",&x,&y);
		if (y!=0) G[x].push_back(y);
	}
	for (int i=0; i<n; i++)
	{
		memset(b,0,sizeof(b));
		dfs(int(s[i]-'0'));
		fl++;
	}
	for (int i=0; i<fl; i++)
	{
		ans*=a[i];
	}
	printf("%llu",ans);
	return 0;
}
```
### End

---

## 作者：xingsunderen (赞：4)

~~蒟蒻来水一篇题解。~~

## 题意
题目讲述很清楚，就不赘述了。

## 做法
### dfs
一开始做得时候，感觉是标准的 dfs，再一看数据范围，觉得 dfs 水水就能过，写了个代码如下：

```cpp
long long dfs(string s){
	long long ans=1;
	if(m[s]==1) return 0;
	m[s]=1;
	for(int i=0;i<s.size();i++){
		int t=s[i]-'0';
		for(auto v:e[t]){
			s[i]=v;
			if(m[s]==0){
				ans+=dfs(s);
			}
			s[i]=t+'0';
		}
	} 
	return ans;
```
结果就是，听取 MLE 声一片。以为是一些奇奇怪怪的问题，改成了 bfs，结果变成了“TLE 与 MLE 齐飞”。那么我们该怎么做呢？
### 弗洛伊德
通过观察题意与输入可以发现，与图很像，把每种数字看成图的节点，使用弗洛伊德找出一种数字可以变成那种数字。这里有一个问题害的本人调试很久，因为题目说规则右边不能为 0，所以题目左边可以为 0，因此 i 应从 0 开始，j 应从 1 开始。还有一点可能会搞错，因为题目说原数可以不变，所以自身到自身是能够到达的。
```cpp
	for(int v=1;v<=10;v++){
		for(int i=0;i<=10;i++){
			for(int j=1;j<=10;j++){
				if(a[i][v]==1&&a[v][j]==1) a[i][j]=1;
			}	
		}
	}
```

### 乘法原理
既然找出了每个数字可以变为哪些数，那我们只需要统计每个数字总共有几种变法，最后就可以运用乘法原理算出来了。

```cpp
for(int i=0;i<=10;i++){
		for(int j=0;j<=10;j++){
			if(a[i][j]==1) sum[i]++;
		}
	}
```

### 计算结果
刚刚讲了乘法原理，那么乘法乘法，顾名思义把刚刚的 $sum$ 数组乘起来就好了，有些人说高精度，但是 int128 够了，~~不必写那些我忘记的东西~~。
## 完整代码
思路和部分代码都给了，那么最后给个完整代码，想我一样的蒟蒻可以好好理解一下。

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
int k;
int a[11][11];
__int128 ans=1;
int sum[11];

void print(__int128 x){ //int_128 没有 cout
	if(x>9) print(x/10);
	putchar(x%10+'0');
}

int main(){
	cin>>s>>k;
	for(int i=1;i<=k;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]=1;
	}
	
	for(int i=0;i<=10;i++){ //其实循环不需要到10，到9就够了
		a[i][i]=1;
	}
	
	for(int v=1;v<=10;v++){
		for(int i=0;i<=10;i++){
			for(int j=1;j<=10;j++){
				if(a[i][v]==1&&a[v][j]==1) a[i][j]=1;
			}	
		}
	}
	
	for(int i=1;i<=10;i++){ //规则右部不能为0
		a[i][0]=0;
	}
	
	for(int i=0;i<=10;i++){
		for(int j=0;j<=10;j++){
			if(a[i][j]==1) sum[i]++;
		}
	}
	
	for(int i=0;i<s.size();i++){
		int t=s[i]-'0';
		ans*=sum[t];
	}
	print(ans);
}

```

---

## 作者：cjy0329 (赞：2)

# P1037 [NOIP 2002 普及组] 产生数题解

## 题意：

一个数（$<10^{30}$），可执行 $k$ 个数位替换操作：

>如果第 $i$ 位为 $x$，可将第 $i$ 为替换为 $y$。
>
>保证 $y\not=0$。

## 思路：

利用乘法原理的数学思想，只需算出每一位进行若干次替换操作后数字的可能方案数，再每一位乘起来，就是答案了。

想象数字的替换关系是一张图，如果 $x$ 能替换为 $y$，那就在 $x$ 和 $y$ 之间建一条有向边。只需求出第 $i$ 位的数能到达几个点，就是这一位进行若干次替换操作后数字的可能方案数了。

## 代码：

```cpp
#include<iostream>
#include<string>
#include<vector>
#include<cstring>
using namespace std;
long long num[105], cut = 0;//高精（非传统）
bool vis[105];   
int k, Ans[105];            //Ans[i]表示i进行若干次替换操作后数字的可能方案数
vector<int>edge[105];
int dfs(int x) {            //dfs来求可到达的点数
	if (vis[x])return 0;    //走过了直接返回
	vis[x] = 1;             //标记，防止走重复的边
	int ans = 1;            //不进行任何操作也是一种发方案
	for (auto y : edge[x]) {
		ans += dfs(y);      //加上邻接点的答案
	}
	return ans;          
}
void init() {                      //初始化Ans
	for (int i = 0; i < 10; i++) {
		memset(vis, 0, sizeof vis);//清空标记
		Ans[i] = dfs(i);           //存储答案
	}
	return ;
}
void read() {                       //读入高精度数（非传统）
	char ch = getchar();
	while (ch < '0' || '9' < ch)
		ch = getchar();
	while ('0' <= ch && ch <= '9') {
		num[++cut] = ch - '0';
        ch = getchar();
	}
	return ;
}
void out(__int128 x){   //输出__int128类型的整数（__int128本身不带有输入输出函数）
	if(x==0)return ;
	out(x/10);
	putchar(x%10+'0');
	return ;
}
int main() {
	read();                       //输入
	cin >> k;
	for (int i = 1; i <= k; i++) {
		int x, y;
		cin >> x >> y;
		edge[x].push_back(y);     //存储单向边
	}
	init();
	__int128 ans = 1;             //答案最多为10^30,选择__int128存储
	for (int i = 1; i <= cut; i++) {
		ans = ans * Ans[num[i]];  //乘法原理
	}
	out(ans);                     //输出
	return 0;
}
```

---

## 作者：xiaobeng_0912 (赞：2)

## $\mathbf{Knowledge}$

1. 深度优先搜索
1. 高精度

## $\mathbf{Solution}$

因为 $k\le15,n\le10^{30}$，所以光使用爆搜显然不行。

然后我们可以发现，设第 $i$ 位能变成的数有 $a_i$ 个，$n$ 是 $x$ 位数，那么答案为：

$$\left(\prod\limits_{i=1}^{x}{a_i}\right)\times x$$

然后，考虑到会有 $2\rightarrow5$，$5\rightarrow6$，$6\rightarrow2$ 这样可以连续变换（例如 $2$ 变 $5$ 变 $6$）并且成环的变换规则，所以我们需要用到 `dfs`，并且在搜索的同时用一个数组来统计某个数字在这轮中是否已经被标记过（即，这个位上的数字是否已经能够变换成这个数了）。

最后，考虑到答案过大，超过了 `long long` 的范围，不过并没有超过 `__int128` 的范围，所以可以使用 `__int128`（不过考场上还是用高精度更保险）。

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,x,y,sum,vis[10];
__int128 ans=1;
string n;
vector <int> e[10];//记录了每个数字能直接转换成的数字 
void dfs(int x){
	if(vis[x]){
		return;//如果这个数字已经搜过了，就不用再搜一遍了 
	}
	vis[x]=1;//标记这个数已经被搜过了 
	sum++;//这个数位上的数字能转换成的数字个数加一 
	for(int i=0;i<e[x].size();i++){
		dfs(e[x][i]);//依次搜索当前数字能直接转换成的数字 
	}
}
void write(__int128 x){ //__int128类型只能使用快写来输出 
	if(x>9){
		write(x/10);
	}
	putchar(char(x%10+'0'));
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=k;i++){
        scanf("%d%d",&x,&y);
        e[x].push_back(y); 
    }
    for(int i=0;i<n.size();i++){
        memset(vis,0,sizeof(vis));//记得清空数组 
        sum=0;//统计变量也要清空 
        dfs(int(n[i]-'0'));//搜索统计这个数位上的数字能转换成的数字个数
        ans*=sum;
    }
    write(ans);//输出答案 
    return 0;
}
```

---

## 作者：a202401006 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1037)
## 分析
### 题意分析
给出一个数和一些将某个数替换成别的数的规则（将要替换成的数非零），问能够组合出多少种数。
### 考察内容
一看它的数据范围，就知道考高精度，同时它还考深搜。
### 思路
输入所有数据，将那些替换的位数定义为真，然后循环枚举每一位，然后高精度（怎么搞高精度？将其像列竖式一样相乘，然后去掉头部的零即可），输出。

具体见代码解析。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string number;//定义字符串，用于后面的高精度计算 
int rulesum,lsrule1,lsrule2,rules[10086][10086],change[10086],outnumber[1008610];//初始化 
int main()
{
	cin>>number>>rulesum;//输入原数和规则数量 
	for(int i=1;i<=rulesum;i++)
	{
		cin>>lsrule1>>lsrule2;//输入规则 
		rules[lsrule1][lsrule2]=1;//存储规则，rules[lsrule1][lsrule2]表示将第lsrule1位换成第lsrule2位的状态位真，表示这里要换。 
	}
	for(int i=1;i<=9;i++)
	{
		for(int j=0;j<=9;j++)
		{
			for(int k=1;k<=9;k++)
			{
				if(rules[j][i]&&rules[i][k])//这里表示如果i换成j，j可以换成k，则i可以换成k，那么把rules[j][k]也定义状态为真，表示这里要换。 
				{
					rules[j][k]=1;
				}
			}
		}
	}
	for(int i=0;i<=9;i++)//枚举0至9，毕竟可以涉及0 
	{
		rules[i][i]=1;//这里，我们将一开始不换也一样的那个数定义为真 
		for(int j=0;j<=9;j++)
		{
			if(rules[i][j])//如果可以换 
			{
				change[i]++;//change[i]表示为数字i能替换为别的数字的个数
			}
		}
	}
	/*开始高精度，毕竟题目是10的30次方*/ 
	int ls1=0;
	outnumber[0]=1;
	for(int i=0;number[i];i++)
	{
		ls1=0;
		int ls2=change[number[i]-'0'];
		for(int j=0;j<10086;j++)
		{
			outnumber[j]=outnumber[j]*ls2+ls1;//高精度乘法 
			ls1=outnumber[j]/10; 
			outnumber[j]%=10;
		}
	}
	int i=10086;//设有10086位 
	while(!outnumber[i])
	{
		i--;
	}//去除首位0 
	/*高精度算法*/ 
	for(;i>=0;i--)
	{
		cout<<outnumber[i];
	}//输出
	return 0;//好习惯 
}
```

---

## 作者：kunkun127 (赞：2)

此题解顺便纪念自己的 DFS 第一题。

## 思路

如上，这题是一道 DFS，深度优先搜索的一道入门题。

- DFS
  
  如果我们直接暴搜，很容易 MLE 或者 WA。这是因为数据范围中的 $n \le 10^{30}$。那么我们不妨转变思路，转变过程中并不会有变成 $0$ 的情况。因此数的位数不会改变，所以所有数位上，可能出现的数的个数的乘积就是所求的答案。
  
  那么我们将所有数可能改变的数的个数记录下来，然后直接遍历原字符串把每一位可能出现的数的个数乘起来就行了。

- 高精度

  我们有两种选择：

  - 手写高精度乘法函数
  - `int128`，但是要专门写输出
  
  对于初学者，建议练习高精度。以免在考场上出问题。

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
int k, x[20], y[20];
bool vis[114];

void dfs(char c)
{
	if (vis[c]) return ;
	vis[c] = true;
	for (int i = 1; i <= k; i++)
	{
		if (x[i] == c - '0') dfs(y[i] + '0');
	}
	return ;
}

void out(__int128 n)//手写输出
{
	if (n > 9) out(n / 10);
	putchar(n % 10 + '0');
}

int main()
{
	cin >> s >> k;
	for (int i = 1; i <= k; i++) cin >> x[i] >> y[i];
	dfs(s[0]);
	vis[0] = 0;
	__int128 t = 0;
	for (int c = '1'; c <= '9'; c++) t += vis[c], vis[c] = 0;
	__int128 ans = t;
	for (int i = 1; i < s.size(); i++)
	{
		int t = 0;
		dfs(s[i]);
		for (char c = '0'; c <= '9'; c++)
		{
			t += vis[c];
			vis[c] = 0;
		}
		if (t != 0) ans *= t;
	}
	out(ans);
	return 0;
} 
```

---

## 作者：chrispang (赞：1)

## 题目大意

有一个数 $n$ 和 $k$ 种操作，每种操作包含 $x$ 和 $y$，表示可以让一位数 $x$ 变成 $y$，且 $y \ne 0$。求经过任意次操作一共可以转化成几个数（包括原数 $n$）。

## 题目分析

考虑到一共有 $k\le 15,n\le 10^{30}$。也就是说，如果每一位都变化个 $k$ 次，那么答案最大有 $15^{30}$，一个一个转换枚举肯定会超时。因此，考虑使用深搜枚举每一位数的转化，之后使用乘法原理乘起来，答案就出炉啦！

注意，答案会很大，可以考虑使用 `__int128` 或者高精度来存储答案。

```cpp
#include <bits/stdc++.h>
#define int __int128
using namespace std;

__int128 read() { //快读
	__int128 x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(__int128 x) { //快写
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int k, ans = 1; //答案肯定会有一个数
string s; //输入的原数
bool vis[10]; //记录一位数是否有被搜索过
vector<int> linker[10]; //存储一个数能转化的数
struct node {
    int u, v;
} a[20];

void dfs(int x) { //搜索每一位可以变成多少位
    if(vis[x]) return; //搜索到相同的数了，return
    vis[x] = 1; //否则进行标记
    for (auto i:linker[x]) dfs(i); //继续搜索
}

signed main() {
    cin >> s, k = read(); //读入
    for (int i = 1; i <= k; i++) {
        int x = read(), y = read();
        linker[x].push_back(y);
    }
    for (int i = 0; i < s.size(); i++) {
        memset(vis, 0, sizeof(vis)); //清空数组
        dfs(s[i] - '0'); //枚举这个位置的数
        int sum = 0;
        for (int k = 0; k <= 9; k++) sum += vis[k]; //看看能转化成多少个数
        ans *= sum; //乘法原理
    }
    write(ans); //输出
    return 0;
}
```

---

## 作者：PartiallyCorrect (赞：0)

题目中可以将一个数字变为另一个，把 $0$ 到 $9$ 这 $10$ 个数字看成 $10$ 个点，每一条规则看作一条边，因为只有 $10$ 个点，所以可以直接用弗洛伊德求出每一个数字可以变出的数字，然后将每一位上的数字可以变成的数字的个数相乘，就是答案，但由于 $n<10^{30}$ 每一位都可能有 $10$ 种选择，需要用高精度来计算。具体代码如下: 
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10;
bool g[N][N];
int cnt[N];
struct bigInt{
	int a[35],len;
	bigInt(){
		memset(a,0,sizeof(a));
		a[1]=1;
		len=1;
	}
	void mul(int x){
		for(int i=1;i<=len;i++)
			a[i]*=x;
		for(int i=1;i<=len;i++){
			a[i+1]+=a[i]/10;
			a[i]%=10; 
		}
		if(a[len+1]>0)
			len++;
	}
	void print(){
		for(int i=len;i>=1;i--)
			cout<<a[i];
	}
};
int main(){
	string s;
	int T;
	cin>>s>>T;
	while(T--){ 
		int x,y;
		cin>>x>>y;
		g[x][y]=true;
	}
	for(int i=0;i<=9;i++)
		g[i][i]=true;
	for(int k=0;k<=9;k++)
		for(int i=0;i<=9;i++)
			for(int j=0;j<=9;j++)
				g[i][j]|=g[i][k]&g[k][j];
	for(int i=0;i<=9;i++)
		for(int j=0;j<=9;j++)
			cnt[i]+=g[i][j];
	bigInt ans;
	for(int i=0;i<s.size();i++)	
		ans.mul(cnt[s[i]-'0']);	
	ans.print();	
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：0)

### 思路

观察到题目中写明「规则的右部不能为零」，可以推导出无论数字怎么变换，它的位数永远不变。于是，我们可以考虑计算每一位数的转换次数，然后相乘得到答案。

同时，我们可以推出每位最多可以转换 $15$ 次，最多有 $30$ 位，所以答案小于 $30^{15}$，需要用到高精度。（这里作者为了~~偷懒~~方便使用了 `__int128`，它最大可以表示 $2^{127} - 1$，大于最大答案 $30^{15}$。）

### 实现

```cpp
# include <iostream>
# include <cstring>
# include <vector>
# include <map>
using namespace std;
bool vis[10]; map< int,vector<int> > go;
void output(__int128 x){
	if (x > 9) output(x / 10);
	putchar(x % 10 + '0');
}void dfs(int x){
	if (vis[x]) return;
	vis[x] = true;
	for (int i = 0;i < go[x].size();i++) dfs(go[x][i]);
}int main(){
	string n; int k; cin >> n >> k;
	for (int i = 1;i <= k;i++){
		int x,y; cin >> x >> y;
		go[x].push_back(y);
	}__int128 ans = 0; dfs(n[0] - '0');
	for (int j = 0;j <= 9;j++) ans += vis[j];
	for (int i = 1;i < n.size();i++){
		memset(vis,false,sizeof(vis));
		dfs(n[i] - '0'); int cnt = 0;
		for (int j = 0;j <= 9;j++) cnt += vis[j];
		ans *= cnt;
	}output(ans);
	return 0;
}
```

---

## 作者：Co_Ce (赞：0)

# Solution

[link](https://www.luogu.com.cn/problem/P1037)

**核心思想**：组合数 + dfs + 高精度。
1. 如果一个数字有 $3$ 位，每位有 $2$ 种可能性，则数字的组合数为 $2\times 2\times 2 = 8$ 种。故只要求出每一位数字有多少种变体即可。  
求 $[0,9]$ 每一个数字的变体数量，可使用 dfs 深搜，并将结果存储在对应的 $c_i$ 中。  
**具体方法**：对 $[0,9]$ 每一个数字执行一次 dfs，统计该数字发生的变体数量（最终要加上自己，比如 $2→3$，$3→5$，则最终该位置有 $3$ 种数字的变体（分别为$3$，$5$和自身 $2$））。  
2. 把输入的字符串转换成 `int` 数组。  
3. 最终结果 $=$ 每一位变体数量的乘积。如 $2\times 2\times2=8$ 种
由于 $n$ 能达到 $10^{30}$，所以 $n$ 的位数可达 $31$ 位，每一位都有 $[1,10]$ 种变体，所以 $10\times 10\times 10… \times 10$ 就变成了高精度乘法。  
4. 最后注意结果为逆序输出。  

## std：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int K = 20;
const int N = 35;

int k, cnt = 0, c[10]; 	// 用于存储 0~9 这10个数每个数可以变的次数。举例：1可以变为3和 5，则 c[1]=3；2可以变为6、7、8、9，则c[2]=5
int vis[10]; 	// 用于记录每个数字是否被访问过 
int x[K], y[K];	// 记录每次读进来的规则，举例：第一个规则是 2 →3，则 x[1]=2; y[1]=[3];   第二个规则是 3 →5，则 x[2]=3; y[2]=[5]

void dfs(int a)
{
    for(int i = 1; i <= k; ++i)
    {
        if(x[i] == a && vis[y[i]] == false)
        {
            vis[y[i]] = true;
            cnt++; 
            dfs(y[i]);
        }
    }
}

void init()
{
    for(int i = 0; i <= 9; ++i)
    {
        memset(vis, 0, sizeof(vis));//vis[j]:i能否通过应用某些规则变成数字j 
        cnt = 0;			// cnt 用于记载当前数字可以转变为多少个数字。举例： 2 →3，   3 →5，则表示 2可以转变为 2个数字（3和5），故cnt为2 
        vis[i] = true;
        dfs(i);//标记vis 	// 在执行 dfs 时，cnt会不断增加 
        c[i] = cnt + 1;   	// 加上自身后，存储在该数字对应的数组下标中。举例： 2 →3，   3 →5，则最终该位置有 3 种数字的组合（分别为3，5和自身2） 
    }
}

void Multiply(int a[], int b)  // 高精乘低精 a * b 赋值给 a。 
{
    int t = 0, i;   // c存储进位 
    for(i = 1; i <= a[0]; ++i)
    {
        a[i] = a[i] * b + t;
		t = a[i] / 10;
        a[i] %= 10; 
    }
    while(t > 0)
    {
        a[i] = t % 10;
        t /= 10;
        i++;
    }
    while(a[i] == 0 && i > 1)  // 消除前导0 
        i--;
    a[0] = i; // a[0]存储 a数组长度 
}

int main()
{
    string s; 
    cin >> s >> k;

    for(int i = 1; i <= k; ++i)   cin >> x[i] >> y[i];
	
    // 第一步：对 0~9 每一个数字执行一次 dfs，统计该数字发生的变体数量（最终要加上自己，比如 2 →3，3 →5，则最终该位置有 3 种数字的变体（分别为3，5和自身2）） 
    init();		
	
    // 第二步：把输入的字符串转换成int数组	
    int a[N];			// 用于存储拆分的数字 
    a[0] = s.length();  // 输入数字的长度 
    for(int i = 1; i <= a[0]; i++)  a[i] = s[i-1] - '0'; 
    
    // 第三步：最终结果 = 每一位变体数量的乘积  。如  2*2*2 = 8 种 
    int f[N];	// f[i]：前i位数字可以变换成的数字种类
    memset(f, 0, sizeof(f));
    f[0] = f[1] = 1;
    for(int i = 1; i <= a[0]; ++i)  Multiply(f, c[a[i]]);  // f * c[a[i]] 赋值回 f 

    for(int i = f[0]; i >=1 ; i--)  cout << f[i];  // 逆序输出      
	
    return 0;
}

```

---

## 作者：HuangRuibo (赞：0)

# 题解

## P1037

[题目传送门](/problem/P1037)

### 题目思路：

1. **输入处理**：读取输入值，包括整数 `n` 和变换规则。
2. **图的构建**：使用邻接表表示变换规则，其中每个节点（数字）指向它可以变换成的其他节点（数字）。
3. **可达性计算**：对于每个数字（$\texttt0$\~$\texttt9$），使用**广度**优先搜索（**BFS**）计算所有可达数字。这有助于确定每个数字在经过任意次数变换后可以变换成的数字数量。
4. **结果计算**：将整数 `n` 转换为字符串，以便逐个处理每个数字。使用高精度乘法方法，将 `n` 中每个数字的可达数字数量相乘，以处理较大的结果。

---

### AC Code:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
#include <string>
#include <algorithm>
using namespace std;

string multiply(const string& a, int b) {
	if (b == 0) return "0";
	string res;
	int carry = 0;
	for (int i = a.size() - 1; i >= 0; --i) {
		int product = (a[i] - '0') * b + carry;
		res.push_back(product % 10 + '0');
		carry = product / 10;
	}
	if (carry > 0) {
		res.push_back(carry + '0');
	}
	reverse(res.begin(), res.end());
	size_t start = res.find_first_not_of('0');
	if (start != string::npos) {
		return res.substr(start);
	} else {
		return "0";
	}
}

int main() {
	string n;
	int k;
	cin >> n >> k;

	vector<vector<int>> adj(10);

	for (int i = 0; i < k; ++i) {
		int x, y;
		cin >> x >> y;
		adj[x].push_back(y);
	}

	int size[10];
	for (int d = 0; d < 10; ++d) {
		unordered_set<int> visited;
		queue<int> q;
		q.push(d);
		visited.insert(d);

		while (!q.empty()) {
			int u = q.front();
			q.pop();

			for (int v : adj[u]) {
				if (visited.find(v) == visited.end()) {
					visited.insert(v);
					q.push(v);
				}
			}
		}
		size[d] = visited.size();
	}

	string result = "1";
	for (char c : n) {
		int d = c - '0';
		result = multiply(result, size[d]);
	}

	cout << result << endl;

	return 0;
}
```

---

---


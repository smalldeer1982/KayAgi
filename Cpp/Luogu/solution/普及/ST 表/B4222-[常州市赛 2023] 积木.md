# [常州市赛 2023] 积木

## 题目背景

搬运自 <http://czoj.com.cn/p/679>。数据为民间数据。

## 题目描述

小 X 在地上玩积木，每块积木都是一个 $1\times 1\times 1$ 的正方体。地面可以看成一个 $n\times m$ 的网格，其中每一小格内都整齐地从下到上堆着若干块积木。其中第 $i$ 行第 $j$ 列中有 $h_{i,j}$ 块积木。

现在小 X 想要拿走一些积木，使得剩下来到积木组成一个正方体，正方体指的是长、宽、高都相同的长方体。

小 X 想问你他最少拿掉多少块积木才能使得最后剩下来的积木组成一个正方体。

## 说明/提示

本题共有 $12$ 个测试点。

|测试点编号|$n,m$|$h_{i,j}$|
|:-:|:-:|:-:|
|$1\sim3$|$1\le n,m\le50$|$0\le h_{i,j}\le1000$|
|$4\sim6$|$1\le n,m\le200$|$0\le h_{i,j}\le 1000$|
|$7\sim9$|$1\le n,m\le1000$|$0\le h_{i,j}\le 20$|
|$10\sim12$|$1\le n,m\le1000$|$0\le h_{i,j}\le1000$|

## 样例 #1

### 输入

```
3 3 
2 2 1 
3 2 2 
3 1 2```

### 输出

```
10```

## 样例 #2

### 输入

```
5 5 
4 4 3 4 3
3 4 3 3 3 
3 3 1 4 4 
3 4 4 3 3 
4 3 4 4 4```

### 输出

```
77```

# 题解

## 作者：Noah03 (赞：1)

### 分析
---
首先，题意很好理解，但是数据范围 $1 \le n,m \le 1000$，我们就会发现直接暴力不可行。

优化：首先，可以观察到答案是具有单调性的，所以我们可以使用**二分答案**来解决这个问题。$L$ 的取值肯定是 1，而 $R$ 的取值为 $\min\{m,n\}$（因为最多能构造出棱长为 $\min\{m,n\}$ 的正方体）。```check``` 函数中可以使用**二维前缀和**来优化时间复杂度，用 $s$ 数组来记录前缀和，公式如下：
$$s_{i,j}=\begin{cases} s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}&\text{if}\ h_{i,j} \lt mid\\ s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+1&\text{if}\ h_{i,j} \ge mid\end{cases}$$

对于计算前缀和时，按照正常板子就好了。

### 代码
---
**请勿抄袭。**

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MAXN=1e3+10;
ll h[MAXN][MAXN],s[MAXN][MAXN];
int n,m;
bool check(int x){
	memset(s,0,sizeof(s));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+(h[i][j]>=x);
	for(int i=1;i<=n-x+1;i++)
		for(int j=1;j<=m-x+1;j++)
			if (s[i+x-1][j+x-1]-s[i-1][j+x-1]-s[i+x-1][j-1]+s[i-1][j-1]==x*x) return true;
	return false;
}
int main(){
	scanf("%d %d",&n,&m);
	ll sum=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%lld",&h[i][j]),sum+=h[i][j];
	int l=1,r=min(m,n);
	ll ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if (check(mid)) l=mid+1,ans=mid*mid*mid;
		else r=mid-1;
	}
	printf("%lld\n",sum-ans);
	return 0;
}
```

代码时间复杂度为 $O(\log(\min\{m,n\}) \times m \times n)$，空间复杂度为 $O(n \times m)$。

**The End.**

---

## 作者：SpeedStar (赞：1)

考虑二分出最后留下的正方体的边长。

如何 check？

假设最后留下的正方体的边长为 $k$。

验证是否存在某个 $k \times k$ 的区域满足每个格子中的高度都 $\geqslant k$ 即可。

对于给定的边长 $k$，每个格子中的积木数或者 $\geqslant k$，或者 $< k$，只有这两种大小关系，不妨将前者的权值记为 $1$，后者的权值记为 $0$。

可以先预处理出关于网格权值的二维前缀和，然后在其中找到一个累加和等于 $k^2$ 的 $k \times k$ 区域即可。

#### 代码实现

```cpp
#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (n); ++i)

using namespace std;

int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector a(n, vector<int>(m));
    rep(i, n)rep(j, m) cin >> a[i][j];
    
    auto judge = [&](int k) {
        vector s(n+1, vector<int>(m+1));
        rep(i, n)rep(j, m) s[i+1][j+1] = a[i][j] >= k;
        rep(i, n+1)rep(j, m) s[i][j+1] += s[i][j];
        rep(i, n)rep(j, m+1) s[i+1][j] += s[i][j];
        
        rep(i, n-k+1)rep(j, m-k+1) {
            int now = s[i+k][j+k];
            now -= s[i][j+k];
            now -= s[i+k][j];
            now += s[i][j];
            if (now == k*k) return true;
        }
        return false;
    };
    
    int ac = 0, wa = min(n, m)+1;
    while (abs(ac-wa) > 1) {
        int wj = (ac+wa)/2;
        (judge(wj) ? ac : wa) = wj;
    }
    
    int tot = 0;
    rep(i, n)rep(j, m) tot += a[i][j];
    
    int ans = tot - ac*ac*ac;
    cout << ans << '\n';
    
    return 0;
}
```

---

## 作者：glass_goldfish (赞：1)

睿智二分+二维前缀和。

显而易见，拿走最少就是保留最多，也就是剩下的正方体的棱长最大。所以，进行二分处理。对于每次的判断（是否可以达成），我们需要一个二维前缀和来处理。如果能够找到合法的矩阵，那么就可以，否则不可以。具体见代码注释。

```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1145141919810
using namespace std;
int n,m,h[1201][1201]; 
int ans,l,r,rlt;
int f[1201][1201];
bool akioi(int x){
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		if(h[i][j]>=x)
			f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+1;
		else f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1];//求出前缀和
	for(int i=1;i<=n-x+1;i++)
	for(int j=1;j<=m-x+1;j++)
		if(f[i+x-1][j+x-1]-f[i-1][j+x-1]-f[i+x-1][j-1]+f[i-1][j-1]==x*x)
			return 1;//找到了合法的矩阵
	return 0;//没找到合法矩阵
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		cin>>h[i][j],ans+=h[i][j];//输入，并加和
	r=min(n,m);//上界
	while(l<=r){
		int mid=(l+r)>>1;//中间值
		if(akioi(mid))l=mid+1,rlt=mid*mid*mid;//如果可以就l=mid+1，并且保存结果
		else r=mid-1;//不可以
	}
	cout<<ans-rlt;//拿走的数目
    return 0;
}
```

---

## 作者：sfb1363II (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4222)

## Solution

这题我的思路是最小化拿走积木相当于最大化保留的积木，也就是最大化保留的立方体的边长。 这题的答案是可以二分的，问题也就变成了如何判断是否可以保留一个边长为 $mid$ 的立方体。我们需要判断每个 $mid \times mid$ 的矩形里面高度是否都 $\ge mid$。然后我们就可以用二维前缀和来计算。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+10;
int n,m,tot,res;
int a[N][N],sum[N][N];
bool check(int x){
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(a[i][j]>=x);
    for(int i=1;i<=n-x+1;i++)
        for(int j=1;j<=m-x+1;j++)
            if(sum[i+x-1][j+x-1]-sum[i-1][j+x-1]-sum[i+x-1][j-1]+sum[i-1][j-1]==x*x) return true;
    return false;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            tot+=a[i][j];
        }
    int l=0,r=min(n,m);
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)){
            l=mid+1;
            res=mid;
        }
        else r=mid-1;
    }
    cout<<tot-res*res*res<<"\n";
    return 0;
}
```

---


# 质量检测

## 题目描述

为了检测生产流水线上总共 $N$ 件产品的质量，我们首先给每一件产品打一个分数 $A$ 表示其品质，然后统计前 $M$ 件产品中质量最差的产品的分值 $Q[m] = min\{A_1, A_2, ... A_m\}$，以及第 2 至第 $M + 1$ 件的 $Q[m + 1], Q[m + 2] $... 最后统计第 $N - M + 1$ 至第 $N$ 件的 $Q[n]$。根据 $Q$ 再做进一步评估。

请你尽快求出 $Q$ 序列。

## 说明/提示

[数据范围]

对于 $30\%$ 的数据，$N \le 1 000$。

对于 $100\%$ 的数据，$M \le N \le 100 000, A_i \le 1 000 000$。

## 样例 #1

### 输入

```
10 4
16 5 6 9 5 13 14 20 8 12
```

### 输出

```
5
5
5
5
5
8
8
```

# 题解

## 作者：JJJJones_Zhu (赞：41)

RMQ！！！

这题数据~~水~~其实还可以，但肯定是不如1440了（这两题很像哦）[1440 RMQ](https://www.luogu.org/problemnew/show/P1440)

但是！不同的是1440的数据到了2000000 但其实那题数据也很~~水~~

那题ST表最多拿到80分，而且~~毒瘤~~数据卡输入输出（雾。而这题只需要简单的ST表便可以处理，效率也是蛮高的，时间上根本不用担心，数据缩到了1000000会减去不少麻烦。

特地献上本 juruo 的ST表一份，请客官品尝

 
```
#include <iostream>
#include<algorithm>
#include<cstdlib>
#include <cstdio>
#include <cmath>
#include <cstring>
#define MAXN 1000005
using namespace std;
int dp[MAXN][25],i,N,M;
//dp[i][j]表示区间[i,i+2^j-1]的最小值。
inline void build()//ST表初始化，用到了DP思想
{
    for(int j = 1;j <= 20;++j)
    //倍增思想
    {
        for(i = 1;i <= M;++i)
            if(i+(1<<j)-1<=M)
                dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
                //状态转移方程
    }
}
int main()
{
    scanf("%d%d",&M,&N);
    //一定要改scanf和printf！！！血的教训！！！
    for(i=1;i<=M;++i)
        scanf("%d",&dp[i][0]);
        //dp[i][0]=第i个物品本身的质量，因为[i,i+2^0-1]这个区间长度为1，元素只有i本身。
    build();
    for(int op = 1;op <= M-N+1;++op){
        int k=log2(N);
        //k的值是[op,op+N-1]这个区间内最长的2的k次方的区间。
        printf("%d\n",min(dp[op][k],dp[op+N-1-(1<<k)+1][k]));}
    return 0;
}
```


倍增是很有价值的工具，掌握没有什么坏处


最后 juruo祝大家能在OI道路上越走越远～～

---

## 作者：My_666 (赞：28)

# 单调队列

#### 概念：

一种具有单调性的队列，即单调递减或单调递增。

#### 操作：

不断向队列内读入新元素，并实时更新队列，去掉最老值或加入最新值，不定期查询当前区间内的最小/大值。

#### 作用：

查询当前区间内的最小值或最大值。


### 那么我们该怎么实现它呢？

就用样例模拟一遍：

1. 队列为空，直接让16进队，此时q={16}

2. 下面读入5，队尾元素大于5，说明只要有5，那么16就不可能是最小值，16从队尾出列，5则进队，此时q={5}

3. 下面读入6，队尾元素小于6，但是如果接下来3个数都比6大，那么6还是有可能成为最小值的，所以6进队，此时q={5，6}

4. 下面读入9，同上，9入队，此时q={5,6,9}

5. 下面读入5，同上，6、9出队，5进队，此时q={5,5}

6. 下面读入13，因为现在的队首已经不在区间内了，直接将队首弹出，然后同上，13加入队列，此时q={5，13}

7. 同上同上……

8. 然后输出就是每移动一次区间就输出队首就可以了。

## 代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m;

int q1[1000001];//q为a数组内元素的下标

int a[1000001];

int min_deque() {
    int h = 1, t = 0;
    for (int i = 1; i <= n; i++) {
        while (h <= t && q1[h] + m <= i) h++; //如果队首元素已经不在区间内，弹出
        while (h <= t && a[i] < a[q1[t]]) t--; //如果队尾元素大于新元素，弹出
        q1[++t] = i;//新元素入队
        if(i >= m) printf("%d\n", a[q1[h]]);//输出当前区间的最小值
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    min_deque();
    return 0;
}
```



------------
## 感谢！


---

## 作者：YoungLove (赞：15)

[Youngsc](http://youngscc.github.io/)

### 来一波单调队列


个人感觉这种区间长度固定的问题用**单调队列**比较好写，~~ST表太麻烦了，而且做了好多无用功~~


不是很懂单调队列的可以去做一做滑动窗口，比较经典的单调队列模板题。


我们可以维护一个单调递增的队列，每次从队尾增加一个数，将队尾比他小的数弹出，并将已经在区间外的队首的数弹出，并且随时输出就好。


STL中有一个双端队列deque，但是好像很慢，慢到不敢想象，所以最好还是数组模拟实现。


## 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# include <ctime>
# include <cstdlib>
# define R register
# define LL long long

using namespace std;

int n,m,p[100010],q[100010],head = 1,tail,d;

inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

inline void maxx(R int &a,const int b){a>b? 0:a=b;}
inline void minn(R int &a,const int b){a<b? 0:a=b;}

inline int yg(){
    in(n),in(m);
    for(R int i=1; i<m; ++i)
    {
        in(d);
        while(head <= tail&&q[tail] >= d) tail--;
        q[++tail] = d,p[tail] = i;
    }
    for(R int i=m; i<=n; ++i)
    {
        in(d);
        // cout << d <<' ';
        while(p[head]<i-m+1) head++;
        while(head <= tail&&q[tail] >= d) tail--;
        q[++tail] = d,p[tail] = i;
        printf("%d\n",q[head]);
    }
}

int youngsc = yg();
int main(){;}
```
（减少代码复制，共创美好洛谷）


---

## 作者：king12138 (赞：11)

看到区间查询自然就想到了线段树啦~~

本题甚至还不需要更新。。

那么暴力查每个区间就好了嘛~~

不多说了上代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int oo = 0x7fffffff;
int n,m;
int a[100005];
int Minn[100005*4];
void create(int root,int l,int r){
	if(l==r){
		Minn[root] = a[l];
		return;
	}
	int mid = (l+r)/2;
	create(root<<1,l,mid);
	create(root<<1|1,mid+1,r);
	Minn[root] = min(Minn[root<<1],Minn[root<<1|1]);
}
int query(int root,int l,int r,int x,int y){
	if(l>y||x>r) return oo;
	if(l>=x&&r<=y) return Minn[root];
	int mid = (l+r)/2;
	int k=oo;
	if(y<mid) k = min(k,query(root<<1,l,mid,x,y));
	else if(x>mid) k =min(query(root<<1|1,mid+1,r,x,y),k);
	else  k = min(query(root<<1|1,mid+1,r,x,y),query(root<<1,l,mid,x,y));
	return k;
}
int main(){
	fill(Minn,Minn+100005,oo);
	cin>>n>>m;
	int d = 1;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	create(1,1,n);
	for(int i=1;i<=n-m+1;i++){
		cout<<query(1,1,n,i,i+m-1)<<endl;
	}
	return 0;
}

蒟蒻的第一篇题解，不喜勿喷

谢谢大家


---

## 作者：_Grey (赞：9)

### [更好的阅读体验(安利窝自己的博客QAQ)](https://lllinea.github.io/%E9%A2%98%E8%A7%A3-%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B/)

## 昨天刚学了ST表今天就来练练手

## 看着题解区的巨佬们的代码

## 感觉窝好蒟啊

## 只能用跟着学长写的板子混混日子

### ~~窝太难了~~

## 上代码QAQ

```
#include <bits/stdc++.h>
#define Maxn 100010
using namespace std;
int n, m, a[Maxn], f[Maxn][33];
int Query(int l, int r) {
	int len = r - l + 1, w = 0;
	while((1 << w) <= len) ++w;
	--w;
	return min(f[l][w], f[r - (1 << (w)) + 1][w]);
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
		f[i][0] = a[i]; // f[i][j] ====> 从i开始 长度为 2^j 的区间中最大值 
	}
	for(int j = 1; j <= 20; ++j) {
		for(int i = 1; i <= n; ++i) {
			if(i + (1 << j) - 1 <= n) {
				f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
			}
		}
	}
	int l = 1,r = m;
	while(l <= n - m + 1 and r <= n) {
		printf("%d\n", Query(l, r));
		l++;r++;
	}
	return 0;
}
```


---

## 作者：玫葵之蝶 (赞：6)

我为什么一看见这题就想用树状数组，又好写，又实用，多好。。。

nlogn建树，单词查询logn，对于100000的数据绰绰有余。

不过这好像和一般的树状数组不一样，一般都是求和，这次是求最值，变一下查询函数query。

```cpp
//a[i]代表第i个数字，t[i]就是树状数组
//函数过程：每次强制让r指针进入下一棵子树（r--），在防止r指针出查询界限的同时（r-l>=lowbit(r)），
//不断跳跃（r-=lowbit(r)），并用r指针更新答案，直到剩余查询区间长度为0时退出（l==r）。
int query(int l,int r){
    int ans=a[r];
    while(1){
        ans=min(ans,a[r]);
        if(l==r)break;
        for(r--;r-l>=lowbit(r);r-=lowbit(r)){
            ans=min(ans,t[r]);
        }
    }
    return ans;
}
```
除了这个，也没什么了。

我可能讲的不好，大家可以百度“树状数组求区间最值”，自己学。

欢迎来[我的博客](http://blog.csdn.net/stone41123)转转哦，有我的最新题解，个人体会，请大家多多捧场。

下面是完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f
using namespace std;
int n,m;
int a[1000001];
int t[1000001];
inline int lowbit(int x){
    return x&-x;
}
void add(int i,int x){
    while(i<=n){
        t[i]=min(t[i],x);
        i+=lowbit(i);
    }
}
int query(int l,int r){
    int ans=a[r];
    while(1){
        ans=min(ans,a[r]);
        if(l==r)break;
        for(r--;r-l>=lowbit(r);r-=lowbit(r)){
            ans=min(ans,t[r]);
        }
    }
    return ans;
}
int main(){
    memset(t,0x3f,sizeof(t));
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        add(i,a[i]);
    }
    for(int i=1,j=m;j<=n;i++,j++){
        printf("%d\n",query(i,j));
    }
    return 0;
}
```

---

## 作者：Ofnoname (赞：6)

# 为什么要用单调队列而不是ST表？

因为单调队列是严格`O(N)`的，在这道区间长度固定，有尺取思想的题上是优于`O(NlogN)`的ST表的。ST表的优势在于更通用，可以任意查询。

时刻维护当前最小值即可，并将超过长度的移出即可。

```cpp
//省略火车头
#define MAXN (100000 + 7)
using namespace std;

int N,M,a[MAXN];
deque <int> Q;

int main()
{
//  ios :: sync_with_stdio(0);
    read(N); read(M);
    Fors (i, 1, N)
    {
    	read(a[i]);
    	while (Q.size() && i-Q.front()>=M) Q.pop_front();
		while (Q.size() && a[Q.back()]>=a[i]) Q.pop_back();
		Q.push_back(i);
		
		if (i >= M) printf("%d\n", a[Q.front()]);
	}
}

```

---

## 作者：shuiyuhan (赞：5)

看这题没有p党写线段树的，所以来一发

这题我想了n种方法，比如ST表，莫队......但最后发现本蒟蒻似乎只会线段树版本的

这题是道线段树~~裸题~~啊!

先建树，之后对于每组询问查询最小值即可
(代码里有解释)

代码：
```pascal
uses math;
var
  i,j,n,k,m,oo,ans,p,mid,x,y,id:longint;
  a,tree:array[0..4000009] of longint;
procedure build(p,l,r:longint);//建树，用tree[p]表示每段最小值
var
  mid:longint;
begin
  if (l=r) then begin tree[p]:=a[l]; exit; end;
  mid:=(l+r) div 2;
  build(p*2,l,mid);
  build(p*2+1,mid+1,r);
  tree[p]:=min(tree[p+p],tree[p+p+1]);
end;
function query(p,l,r,x,y:longint):longint;//求每段区间最小值
var
  mid:longint;
begin
  mid:=(l+r) div 2;
  if (l=x)and(r=y) then exit(tree[p])
  else if y<=mid then exit(query(p*2,l,mid,x,y))
  else if x>=mid+1 then exit(query(p*2+1,mid+1,r,x,y))
  else exit(min(query(p*2,l,mid,x,mid),query(p*2+1,mid+1,r,mid+1,y)));
end;
begin
  oo:=100000000;
  readln(n,m);
  for i:=1 to n do read(a[i]);
  build(1,1,n);//建树的build函数
  for i:=1 to n-m do//把询问转换为每次询问区间i~i+m中的最小值
    writeln(query(1,1,n,i,i+m-1));
  writeln(query(1,1,n,n-m+1,n));
end.
```


---

## 作者：team109 (赞：4)

Update:2019.8.10。更新图片$\color{#cecece}{\textsf{，增设水印专区。}}$  
Update:2020.2.19。改错别字；由于洛谷Markdown的一些feature又有了改动，于是还得跟着改。  
Update:2020.3.12。Markdown又炸了。并修$\LaTeX$  


首先，[$\bold{\Large{\color{#3399dd}{\text{双倍经验警告}}}}$](https://www.luogu.org/problem/P1886)


（弱弱地说一句：尽管ST表不是P1886标算，但还是可以AC的）  
$ $  

然后，把那题代码搬过来：
```cpp
//前面的部分省略
int st1[1000005],st2[1000005];
int main()
{
	int n=read(),k=read(),tmp=log2(k+0.1);
	for(int i=1;i<=n;i++)st1[i]=st2[i]=read();
	for(int i=1;i<=tmp;i++)
		{
			for(int j=1;j<=n-(1<<i)+1;j++)
			st1[j]=max(st1[j],st1[j+(1<<i-1)]),st2[j]=min(st2[j],st2[j+(1<<i-1)]);
		}
	for(int i=1;i<=n-k+1;i++)
		print(min(st2[i],st2[i+k-(1<<tmp)])),putchar(' ');
	putchar('\n');
	for(int i=1;i<=n-k+1;i++)
		print(max(st1[i],st1[i+k-(1<<tmp)])),putchar(' ');
}
```
$ $  

注意不用滚动数组会MLE。或者把st1和st2合在一起，输出st1后再算st2，就不会MLE了。  

$ $   

*~~话说我有点扯远了，现在讲的可是P2251啊。~~* 不过还是平生第一次见到ST表配滚动数组这种奇怪搭配。大概是我太水了吧。  

___
$ $  
现在稍微改一下，得到本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	register char ch=getchar();
	register int x=0;
	register bool b=0;
	while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
	(ch=='-')&&(b=1,ch=getchar());
	while(ch<='9'&&ch>='0')x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	b&&(x=-x);
	return x;
}
inline void print(int x)
{
	if(!x){putchar('0');return;}
	register int cnt=0;
	char ch[12];
	(x&-2147483648)&&(putchar('-'),x=-x);
	while(x)ch[cnt++]=x%10+48,x/=10;
	while(cnt--)putchar(ch[cnt]);
}
int st[100005];
int main()
{
	int n=read(),k=read(),tmp=log2(k+0.1);
	for(int i=1;i<=n;i++)st[i]=read();
	for(int i=1;i<=tmp;i++)
		for(int j=1;j<=n-(1<<i)+1;j++)//防止溢出
			st[j]=min(st[j],st[j+(1<<i-1)]);
	for(int i=1;i<=n-k+1;i++)
		print(min(st[i],st[i+k-(1<<tmp)])),putchar('\n');
}
```
------------
$ $  

### 最后讲一下ST表本身。 
ST表是用倍增的思路实现的。  
ST表专门用于O(1)处理区间最值的询问。  

ST表的定义：  
`st[i][j]`表示$\mathtt{a[j]}$到$\mathtt{a[j+2^i-1]}$一共$\mathtt{2^i}$个数的最值。  
如图（因为*画图3D*不资瓷上下标，所以就把指数一律改成2和3，这两个是可以在字符表里找到的）。
![404](https://cdn.luogu.com.cn/upload/pic/70754.png)  

这样，因为总共n个数，所以一维下标做到`log2(n)`就可以了，所以st数组的一维下标是 `O(logn多一点点)` 的，二维下标是 `O(n多一点点)` 的。空间复杂度O(nlogn)。  

然后讲ST表的O(nlogn)预处理。  
首先，$\mathtt{st[0][i]=a[i]}$，没有问题。  
然后，有$\mathtt{st[i][j]=min(st[i-1][j],st[i-1][j+2^{i-1}])}$。如图。**注意图中字母`l`和数字`1`长得是不一样的。**  
![404](https://cdn.luogu.com.cn/upload/pic/70766.png)
一般的ST表还要预处理一个`lg2[1...n]`数组，是这样预处理的：
```cpp
lg2[1]=0;
for(int i=2;i<=n;i++)lg2[i]=lg2[i>>1]+1;
```  
只是这里不用。(~~lg2==某谷2？~~[滑稽])  
这样就预处理完了。  

接下来讲查询：  
查询闭区间(就是指两个端点都取的到的)l...r,是这样的：  
![404](https://cdn.luogu.com.cn/upload/pic/70995.png)  
这里就要用到`lg2`数组了。
```cpp
int query(int l,int r)
{
	int len=lg2[r-l+1];
	return min(st[len][l],st[len][r-(1<<len)+1]);
}
```

最后给出我的代码仓库里的代码：
```cpp
int a[SIZE_],st[SIZE_LOGN][SIZE_],lg2[SIZE_];//SIZE_和SIZE_LOGN是两个我自己定义的宏
void pre(int n)
{
	memset(lg2,0,sizeof lg2);
	for(int i=2;i<=n;i++)lg2[i]=lg2[i>>1]+1;
}
int qry1(int l,int r)
{
	int len=lg2[r-l+1];
	return max(st[len][l],st[len][r-(1<<len)+1]);
}
void work1(int n)
{
	memset(st,-256,sizeof st);
	for(int i=1;i<=n;i++)st[0][i]=a[i];
	for(int i=1;i<=SIZE_LOG;i++)
		for(int j=1;j<=n;j++)st[i][j]=max(st[i-1][j],st[i-1][j+(1<<(i-1))]);
}
int qry2(int l,int r)
{
	int len=lg2[r-l+1];
	return min(st[len][l],st[len][r-(1<<len)+1]);
}
void work2(int n)
{
	memset(st,255,sizeof st);
	for(int i=1;i<=n;i++)st[0][i]=a[i];
	for(int i=1;i<=SIZE_LOG;i++)
		for(int j=1;j<=n;j++)st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
}
```
$\boxed{\textbf{完}}$  


---

## 作者：lzpclxf (赞：3)

####$P2251$质量检测

读完题目之后我们可以很清楚的明白这是求区间最值$(RMQ)$的问题， 我使用的方法是倍增。

不是很清晰的宝宝可以看这篇文章：[关于倍增](https://www.cnblogs.com/yanxiujie/p/11758674.html)

我们首先要有一个数组$f[i][j]$表示从节点$i$向后走$2^j$个单位的区间范围内我们所需要求的最值，接下来就是合并更新的问题了

很明显的我们可以做到$O(1)$的查询，但是我们需要先预处理出一个$ST$表，也就是我们的$f$数组

```cpp
for(int j = 1; j <= 20; j++)
		for(int i = 1; i <= m; i++) 
			if(i + (1 << j) - 1 <= m) f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
```

这就是更新的过程，需要注意的是我们在更新的过程中外层循环是需要枚举$j$的，具体原因在上边说的文章里有(当然咯那篇文章可是博主非常认真的总结的)，他那样循环的目的与$01$背包的倒序枚举差不多，都是因为我们当前需要被更新的区间的子区间是否已经被更新或者被正确更新的问题。

再就是查询的时候，我们在两个区间里取我们需要的最值即可

我们可以存一个变量表示在当前的区间范围内，$2^j$最大可以到多大，我们可以使用一个$lg$数组来优化常数，这个$lg$数组存的是以$2$为底$i$的对数，更新也是$O(n)$的

```cpp
for(int i = 2; i <= n; i++)
    lg[i] = lg[i >> 1] + 1;
```
这是$2019$年之前高中数学课本必修一的内容，其实也不是很难理解(虽然我一开始并不明白)。

_说句闲话：_

一点小建议：窝写代码在不久之前开始喜欢压行，但是这样会导致调试的时候比较困难，所以可以在敲的时候先不压行，最后修改成自己喜欢的亚子。

The Last:
```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 1000050;
int n, m, f[N][25], len, k;
int read() {
	int s = 0, w = 1; char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
	while(isdigit(ch)) {s = s * 10 + ch - '0'; ch = getchar();}
	return s * w;
}
int main() {
	m = read(), n = read(), len = m - n + 1, k = log2(n);
	for(int i = 1; i <= m; i++) f[i][0] = read();
	for(int j = 1; j <= 20; j++)
		for(int i = 1; i <= m; i++) 
			if(i + (1 << j) - 1 <= m) f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
	for(int i = 1; i <= len; i++) cout << min(f[i][k], f[i + n - 1 - (1 << k) + 1][k]) << endl;
	return 0;
}

```
谢谢收看， 祝身体健康！

---

## 作者：zybnxy (赞：2)

[题目传送门](https://www.luogu.org/problemnew/show/P2251)

这题几乎是[ST表](https://www.luogu.org/problemnew/show/P3865)裸题了吧，本蒟蒻是刚从模板题走过来的，在这里简单的介绍一下$ST$表。

$ST$表是一种可以求$RMQ$问题的一种数据结构，它可以做到$O(n \times logn)$的预处理和$O(1)$查询。预处理运用的是倍增+区间动规，也是由于倍增让它达到了$log$。

$ST$表使用$dp$的思想来求解区间最值，每次运用倍增的思想，每次增加$2^i$个长度。

使用$F[i][j]$表示以$i$为起点，区间长度为$2^i$的区间最值，此时区间为$[i,i+2^j-1]$。

我们举个栗子

用$f[0][2]$来表示区间$[0,3]$的最值，$f[2][2]$表示区间$[2,5]$的最值。在求解$f[i][j]$时，$ST$算法先对长度为$2^j$的区间$[i,i+2^{j-1},j-1]$分成两等分，每份的长度为$2^{j-1}$。然后在分别求解这两个区间的最值。最后结合这两个区间的最值，求出整个区间的最值。

状态转移方程为
$$f[i][j]=min(f[i][j-1],f[i+2^{j-1}][j-1]$$

初始状态为
$$f[i][0]=a[i]$$

在实际的代码中，我们运用位运算加速~~当然如果你手写快速幂也没意见~~

其中

$$2^j=1<<j$$

代码如下
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ri register int
using namespace std;
int a[1000001],f[1000001][25],log[1000001];
int n,m;
inline int read()
{
    int res=0,flag=1;
    char ch;
    for(;!isdigit(ch);ch=getchar())
        if(ch=='-')flag=-1;
    for(;isdigit(ch);ch=getchar())
        res=res*10+ch-48;
    return res*flag;
}
inline int build()
{
    for(ri i=1;i<=n;i++)f[i][0]=a[i];
    for(ri j=1;j<=21;j++)
        for(ri i=1;i+(1<<j)-1<=n;i++)
            f[i][j]=min(f[i][j-1],f[i+(1<<j-1)][j-1]);
    for(ri i=2;i<=n;i++)
        log[i]=log[i>>1]+1;
    return 0;
            
}
inline int rmq(int l,int r)
{
    int t=log[r-l+1];
    return min(f[l][t],f[r-(1<<t)+1][t]);
}
int main()
{
    n=read();m=read();
    for(ri i=1;i<=n;i++)a[i]=read();
    build();
    for(ri i=1;i<=n-m+1;i++)
        printf("%d\n",rmq(i,i+m-1));
    return 0;
}
```

此外，这道题还可以用线段树求解，对于$RMQ$问题，线段树可以轻松的做到$O(N)$的预处理和$O(logn)$的查询，这也是一个很不错的复杂度。但是如果查询的量很大，还是推荐使用$ST$表。

在这里也给上代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define ri register int
#define lson o<<1
#define rson o<<1|1
#define N 100000
using namespace std;
int a[N+1],Min[N<<2+1],add[N<<2+1];
int n,m;
inline int read()
{
    int res=0,flag=1;
    char ch;
    for(;!isdigit(ch);ch=getchar())
        if(ch=='-')flag=-1;
    for(;isdigit(ch);ch=getchar())
        res=res*10+ch-48;
    return res*flag;
}
inline int push_up(int o)
{
	Min[o]=min(Min[lson],Min[rson]);
}
inline int push_down(int o)
{
	if(!add[o])return 0;
	add[lson]+=add[o];
	add[rson]+=add[o];
	Min[lson]+=add[o];
	Min[rson]+=add[o];
	add[o]=0;
}
inline int build(int o,int l,int r)
{
	add[o]=0;
	if(l==r)
	{
		Min[o]=a[l];
		return 0;
	}
	int mid=(l+r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	push_up(o);
}
inline int query(int o,int l,int r,int ql,int qr)
{
	if(ql<=l&&r<=qr)return Min[o];
	int mid=(l+r)>>1,ans=0x7fffffff;
	if(ql<=mid)ans=min(ans,query(lson,l,mid,ql,qr));
	if(qr>mid)ans=min(ans,query(rson,mid+1,r,ql,qr));
	return ans;
}
int main()
{
    n=read();m=read();
    for(ri i=1;i<=n;i++)a[i]=read();
    build(1,1,n);
    for(ri i=1;i<=n-m+1;i++)
        printf("%d\n",query(1,1,n,i,i+m-1));
    return 0;
}
```

---

## 作者：EarringYYR (赞：2)

**这一道题的主要思路：单调队列**（不熟的可以做一下滑动窗口这一道题）**~~（表示蒟蒻不会ST表）~~

建立一个从小到大的单调队列，每次如果读入到比队尾的数小就将队尾的数弹出（贪心思想：你后面都有更小值的了你还要前面的干什么呢？反而长度更长更容易失效），另外不要忘了将已经超出整个序列长度的物体从队首弹出，的而每一组的答案就是这个单调队列的队首元素**

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[1000001];
struct node
{
    int a;//物体的质量
    int b;//物体的位置
}b[1000001];
int main()
{
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
    int n,m,head=1,top=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i]; 
    for(int i=1;i<=m;i++)//前m个数可以直接进入队列，不需要考虑超出长度的问题
    {
        while(head<=top&&b[top].a>=a[i])//将队尾较大元素弹出（建立单调队列）
            top--;
        b[++top].a=a[i];//将当前元素加入队列中
        b[top].b=i;
    }
    cout<<b[head].a<<endl;//输出第一个序列中的最小值
    for(int i=m+1;i<=n;i++)
    {
        while(head<=top&&b[head].b<=i-m)//将队首已经超出序列长度的元素弹出
            head++;
        while(head<=top&&b[top].a>=a[i])//将队尾较大元素弹出（建立单调队列）
            top--;
        b[++top].a=a[i];//将元素压入队列中
        b[top].b=i;
        cout<<b[head].a<<endl;//输出当前序列最小值
    }
    return 0;
    ```
}

---

## 作者：ars4me (赞：1)

还没有线段树的吧 我来一发

和 p1886滑动窗口 还有 p1816忠诚 差不多的 只需要找区间的最小值就可以

这个题我们可以把查询的区间一点一点向后滑

可以设两个变量leftpoint和rightpoint 每查询完一个区间就++ 相当于滑动了

最关键的函数:

        
        
        
```cpp
ll query(ll from ,ll to ,ll l ,ll r ,ll rt){
        if(from <= l && to >= r)    return tree[rt];
        ll ans = 0x7fffffff;
        if(from <= mid)   ans = query(from ,to ,lson);
        if(to > mid)     ans = min(ans ,query(from ,to ,rson));
        return ans;
}
```
这就等于是在向两边的儿子不断的比较得出最小值

总耗时172ms 应该算快的了

整体代码如下



        
        
        
        


        
        


        
        
        

  
  
        
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
using namespace std;
#define in = read()
typedef long long ll;
const ll size = 4000000 + 10000;
#define left (rt<<1)
#define right (rt<<1|1)
#define lson l,mid,left
#define rson mid+1,r,right
#define mid ((l + r)>>1)
ll n,m;
ll tree[size]; 
inline ll read(){
        ll num = 0, f = 1;    char ch = getchar();
        while (!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while (isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
inline ll pushup(ll rt){    tree[rt]=min(tree[left],tree[right]);}
void buildtree(ll l ,ll r ,ll rt){
        if (l == r){    tree[rt] in ;   return;}
        buildtree(lson);    buildtree(rson);    pushup(rt);
}
ll query(ll from ,ll to ,ll l ,ll r ,ll rt){
        if(from <= l && to >= r)    return tree[rt];
        ll ans = 0x7fffffff;
        if(from <= mid)   ans = query(from ,to ,lson);
        if(to > mid)     ans = min(ans ,query(from ,to ,rson));   
        return ans;
}
int main(){
        n in;   m in;
        buildtree(1,n,1);
        ll leftpoint = 1, rightpoint = m;
        for(int i=1;i<=n-m+1;i++){
                printf("%lld\n",query(leftpoint ,rightpoint ,1 ,n ,1));
                leftpoint ++;   rightpoint ++;
        }
}
```

---

## 作者：Vin_1999 (赞：1)

楼下都是st表，orz......

这题就是很裸的单调队列啊。不能再裸了。

好吧rmq用st表和单调队列都是正解。





```cpp
#include<bits/stdc++.h>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);++(i))
using namespace std;
static int n,m,a[100007],l,r,q[100007];
int main()
{
    freopen("e:/in.txt","r",stdin);
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    int i;
  for(i=0;i<n;++i)
    {
      cin>>a[i];
      while(a[q[r-1]]>a[i]&&l<r) --r;
      q[r++]=i;
      while(q[l]<i-m+1&&l<r) ++l;
      if(i>=m-1) cout<<a[q[l]]<<endl;
    }
    return 0;
}
```

---

## 作者：dunko (赞：1)

## **题目**
[点这里](https://www.luogu.org/problemnew/show/P2251)
## **思路**
看完题目之后发现这不就是一道单调队列求区间最小值吗？   
这还不简单吗？
单调队列又短又快，不选它那选谁？
## **代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7;
int n,m,a[maxn];
deque<int>que;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1;i<=n;i++){
		while(que.size()&&a[i]<=a[que.back()]) que.pop_back();//去尾
		while(que.size()&&i-que.front()>=m) que.pop_front();//去头
		que.push_back(i);//加入当前的位置
		if(i>=m) printf("%d\n",a[que.front()]);//输出
	}//四步结束...
	return 0;
}
```
结束了，谢谢观看！！

---

## 作者：EarthGiao (赞：0)

## 【思路】
ST表    
几乎就是ST表的模板题     
先预处理出跳的步数小于等于m的2^k步     
然后自己处理处LG函数     
目的就是为了知道2^k<=m中    
k的最大值是多少    
如果刚好2^k==m那就不需要继续了   
如果不刚好    
那就记录最大的那个枚举到的k    
就是LG[m]的值    

然后按照板子输出      
区间最小值就好了   

区间怎么算呢？    
起点是i很显然     
终点是i + m - 1   
这样起点和重点就知道啦    
所以这个区间的最小值就是    
min(f[i][LG[m]],f[i + m - 1 - (1 << LG[m]) + 1][LG[m]]); 

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 100005;
int a[Max];
int f[Max][18];
int LG[Max];
int main()
{
	int n,m;
	cin >> n >> m;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i],f[i][0] = a[i];
	for(register int j = 1;(1 << j) <= m;++ j)
		for(register int i = 1;i + (1 << j) - 1 <= n;++ i)
			f[i][j] = min(f[i][j - 1],f[i + (1 << j - 1)][j - 1]);
	int acioi = 0;
	for(register int i = 1;(1 << i) <= m;++ i)
		LG[1 << i] = i,acioi = i;
	if(LG[m] == 0)
		LG[m] = acioi;
	for(register int i = 1;i <= n - m + 1;++ i)
		printf("%d\n",min(f[i][LG[m]],f[i + m - 1 - (1 << LG[m]) + 1][LG[m]]));
	return 0;
}
```

---

## 作者：PrefixAMS (赞：0)

[在博客中阅读体验更佳](https://prefixautomatasong.github.io/%E9%A2%98%E8%A7%A3/2019/08/21/luogu-P2251-%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B.html)

## 刚刚学st表的我显得有些不知所措

昨天听什么树上倍增，LCA，听得津（~~亿~~）津（~~脸~~）有（~~懵~~）味（~~13~~）

就只有一个st表听得有点明白

初学st表的同学可以先做[这道题](https://www.luogu.org/problem/P3865)练练手

st表核心位置


```cpp
int pcm(int l,int r){
	int m=r-l+1;
	int w=log(m)/log(2);
	return max(f[l][w],f[r-(1<<w)+1][w]);
   //核心位置  按照题意可以将max换成min求最小值
}
```


-----------
进入正题，本题是一道st表的板子题

一直求 l-r的区间最小值即可

（P.S.:l=1,r=m）  随后l++,r++

当r=n时即可停止查询

话不多说上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[1000010][33],a[1000010],i,j; 
int pcm(int l,int r){
	int m=r-l+1;
	int w=log(m)/log(2);
	return min(f[l][w],f[r-(1<<w)+1][w]);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
	scanf("%d",&a[i]);
	f[i][0]=a[i];
	}
	for(j=1;j<=20;j++){
		for(i=1;i<=n;i++){
			if(i+(1<<j)-1<=n){
				f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
			}
		}
	}
	int l=1,r=m;
	while(r<=n)
	{
	printf("%d\n",pcm(l,r));
	l++;r++;
	}
	return 0;
}
```


---

## 作者：sram (赞：0)

无意中刷st表题看到的题目（~~抄模板~~），一看到题目，，，没想用st表，直接莫队？？？？？跑起来也不是特别慢。。。
这里用flag数组记录出现次数，set维护最小值，用的时候直接取头部。
代码也很短
```cpp
#include<bits/stdc++.h>
#define swap(a,b) {a^=b;b^=a;a^=b}
#define rep(a,b,c) for(int a=b;a<=c;a++)
#define per(i,n,a) for (int i=n;i>=a;i--)
#define PII pair<int,int>
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 1;
int n, m, mi = INF,flag[1000001], a[1000001];;
set<int>val;
int main()
{
    scanf("%d%d", &n, &m);
    rep(i, 1, n)scanf("%d", &a[i]);
    int l = 1, r = 0;
    int ll=1,rr=m;
    rep(i, 0, n - m)
    {
        while(l < ll){flag[a[l]]--;if(!flag[a[l]])val.erase(a[l]); mi = *val.begin();++l;}
        while(r < rr){++r;flag[a[r]]++;if(flag[a[r]] == 1)val.insert(a[r]);mi = *val.begin();}
        cout << mi << endl;
        ll++,rr++;
    }
    return 0;
}
```

---

## 作者：Nero_Claudius (赞：0)

其实这道题还可以用莫队、线段树、树状数组和分块的。。。【滑稽】

言归正传，这道题的标准思路应该是ST表。

ST表这玩意只支持查询，不支持修改。

有一定局限性，但是代码量相比线段树要少很多，而且不是特别难写。

ST表总共有两种操作：初始化和查询。

```cpp
inline void init() {
	for(int i = 1; i <= n; i++) scanf("%d", &mn[i][0]);
    for(int j = 1; (1 << j) <= n; j++)
        for(int i = 1; i + (1 << j) - 1 <= n; i++)
            mn[i][j] = min(mn[i][j - 1], mn[i + (1 << (j - 1))][j - 1]);
}
```

用mn[i][j]表示从j到j+2^i-1的最小值（长度显然为2^i）

注：为了方便就在初始化里面读入了。

然后是查询：

```cpp
inline int query(int l, int r) {
	int k = log2(r - l + 1); 
    return min(mn[l][k], mn[r - (1 << k) + 1][k]);
}
```

注意一下log2是cmath库里的。

这两个OK了之后这道题基本就是套模板。

```cpp
scanf("%d%d", &n, &m);
init();
for(int i = 1; i <= n - m + 1; i++) {
	cout << query(i, i + m - 1) << endl;
}
```


------------

tada! AC!

588ms，氧化后1280ms 【滑稽】

不过话说回来，ST表并不是特别快，好像最优解是模拟的（48ms）。。。

---

## 作者：noip_Tom (赞：0)

[/color][h1 ]

RMQ模板O(nlogn)预处理，O(1)查询区间


```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cmath>
#define N 100001
#define MAXM 10000011
#define M 22
using namespace std;
int a[N],q[N];
int n,m,pl,minm=MAXM;
int minsum[N][M];
void RMQ(int num) //预处理->O(nlogn)
{
    int i,j;
    for(int j = 1; j <= 20; ++j)
        for(int i = 1; i <= num; ++i)
            if(i + (1 << j) - 1 <= num)
            {
                minsum[i][j] = min(minsum[i][j - 1], minsum[i + (1 << (j - 1))][j - 1]);
            }
} 
int ret(int x,int y)
{
    int k=(int)(log(y - x + 1.0) / log(2.0));
    //改为int就为向下取整，忽略后面的小数位 
    //有一个数学公式为 log k n/log k m =log m n 
```
/\*因为前面是向下取整，当直接输出“maxsum[x][k]-minsum[x][k]”，
因此就有可能区间中有的值会搞不到，因此便用这个方便读入所有的区间值\*/

int minres = min(minsum[x][k],minsum[y - (1 << k) + 1][k]);


```cpp
    return minres;
} 
int main ()
{
    cin>>n>>m;
    int i,j;
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    for (i=1;i<=n;i++) minsum[i][0]=a[i];//RMQ初始化以i位置后2的0次方最小为本身 
    RMQ(n);
    for (i=1;i<=n-m+1;i++)
        q[i]=ret(i,i+m-1);
    for (i=1;i<=n-m+1;i++) cout<<q[i]<<endl;
    return 0;
}
[/h1 ]
```

---

## 作者：hfyzw (赞：0)

这题是rmq，但因为是静态的，可以用稀疏表来做：

f[i,j]表示从第i个数开始后2^j个数中的最小数，询问时直接查询，代码如下：

```cpp
var f:array[0..1000000,0..19]of longint;
      a:array[0..1000000]of longint;
      n,m,s,t,r,i,j:longint;
function min(x,y:longint):longint;
begin
    if x<y then min:=x else min:=y;
end;
begin
    readln(n,m);
    fillchar(f,sizeof(f),$7f);
    for i:=1 to n do begin
        read(a[i]); f[i,0]:=a[i];
    end;
        for j:=1 to trunc(ln(n)/ln(2)) do
        for i:=1 to n-(1 shl j)+1 do
                        f[i,j]:=min(f[i,j-1],f[i+(1 shl(j-1)),j-1]);
    for i:=1 to n-m+1 do begin
                r:=trunc(ln(m)/ln(2));
        writeln(min(f[i,r],f[i+m-(1 shl r),r]));
        end;
end.
```

---

## 作者：封禁用户 (赞：0)

[个人博客同步更新，欢迎友链游览团点击捐助](http://www.cinema000.xyz/676.ruby)

这题可以线段树啦，楼下也只有一篇线段树的题解，但是线段树的题解只有一篇怎么行呢。

线段树的讲解可看[个人博客中的讲解](http://www.cinema000.xyz/660.ruby)

这里只需要维护一个区间最小值就好了，而且都不用去写修改的方法，只用建树和查询就好了。

```cpp
#include<cstdio>

const int MAXN = 1000000 + 6;
int a[MAXN];

class SegmentTree{//线段树结构体 
	public:int l,r;
	public:int data;
};
SegmentTree t[MAXN * 4];//用来存线段树 

inline int LEFT(int x){return x << 1;}//求左儿子 
inline int RIGHT(int x){return x << 1 | 1;}//求右儿子 
inline int MID(int l,int r){return (l + r) >> 1;}//求中值 
inline int min(int a,int b){return a < b ? a : b;}//求最小值 

void build(int p,int l,int r){//递归建树 
	t[p].l = l;t[p].r = r;
	if(l == r){
		t[p].data = a[l];
		return;
	}
	build(LEFT(p),l,MID(l,r));//建左儿子 
	build(RIGHT(p),MID(l,r) + 1,r);//建右儿子 
	t[p].data = min(t[LEFT(p)].data,t[RIGHT(p)].data);//维护最小值 
}

void change(){}//修改，更新操作，都不用写233 

int ask(int p,int l,int r){//查询 
	if(l <= t[p].l && r >= t[p].r){//如果查询区间完全覆盖当且结点区间，则直接返回 
		return t[p].data;
	}
	int ans = 0x7fffffff;//最小值赋正无穷，而最大值就赋负无穷 
	if(l <= MID(t[p].l,t[p].r)){//如果左孩子与查询区间有重叠，就递归查左儿子 
		ans = min(ans,ask(LEFT(p),l,r));
	}
	if(r > MID(t[p].l,t[p].r)){//右儿子同理 
		ans = min(ans,ask(RIGHT(p),l,r));
	}
	return ans;//记得返回哇 
}

int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	
	for(int i = 1;i <= n;i++)
		scanf("%d",&a[i]);
	build(1,1,n);//建树 
	
	for(int i = 1;i <= n - m + 1;i++)
		printf("%d\n",ask(1,i,i + m - 1));//查询 
	
	return 0;
} 
```

---


# [THUPC 2019] 组合数据结构问题

## 题目描述

> 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。

小葱同学在学习了组合数的计算之后，开始了研究数据结构的道路。通过十五分钟的刻苦学习，小葱同学初步掌握了队列、栈和堆这三种数据结构。小葱同学发现这三种数据结构都支持两种操作：

1. 将某个数插入该数据结构。
2. 从该数据结构中按照数据结构的原理取出一个数。

小葱同学为了检验自己对这三种数据结构的理解，设计了一个类似的黑箱模型。该模型也支持两种操作，向黑箱中输入一个数或者从黑箱中输出一个数。现在小葱对该黑箱做了若干次操作，并给出每次输入和输出的数，问这个黑箱实现的是否可能是队列、栈、大根堆或者小根堆。

虽然小葱同学对这四种数据结构了如指掌，但他还是决定告诉你它们的分别是什么：

- 如果黑箱是**队列**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**最早被放入的**数将被输出并移出黑箱。
- 如果黑箱是**栈**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**最晚被放入的**数将被输出并移出黑箱。
- 如果黑箱是**大根堆**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**值最大的**数将被输出并移出黑箱。特别地，如值最大的数有多个，则仅将其中一个移出黑箱。
- 如果黑箱是**小根堆**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**值最小的**数将被输出并移出黑箱。特别地，如值最小的数有多个，则仅将其中一个移出黑箱。



## 说明/提示

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
6
1 1
1 2
1 3
2 1
2 2
2 3```

### 输出

```
Yes
No
No
Yes```

# 题解

## 作者：天南星魔芋 (赞：5)

~~本蒟蒻由于被教练的贪心虐爆，故找了道数据结构题找自信。~~


------------


先看题，题目要求我们模拟四种数据结构 **队列、栈、大根堆和小根堆**，

由于本蒟蒻不会同时用一种数据结构维护，所以我对以上结构进行了在线模拟。

先看时间复杂度 $0≤N≤10^5$ ，

队列是 $O(N)$ , 栈是 $O(N)$ , 堆是 $O(NlogN)$ ,

故总复杂度是 $O(2\times(N+NlogN))$ ，

也就是 三百六十万  ...够了。

另外 题上没说数据为空时不能取出，

所以我们要加特判；

接下来就上代码啦：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dd[60000],xd[60000],dl[60005],zan[50005];
//四种结构  dd 大根 堆  xd  小根 堆   dl  队列   zan 栈 

int dtop=0,xtop=0,l=1,r=0,top=0;
//指针   dtop 大根堆  xtop  小根堆   l r  队列   top 栈 

int n;
int pd;//存数---详见 
bool qwq[10];//判断数据结构是否符合 

//------------------------------------------------//堆放入 
void ddn(int x){                                 // 大根堆 
	if(x!=1){                                   //
		if(dd[x]>dd[x/2]){                     //
		swap(dd[x],dd[x/2]);                  //
		ddn(x/2);                            //
		}                                   //
	}                                      //
	return ;                              //
}                                        //
//--------------------------------------// 
void xdn(int x){                       // 小根堆 
	if(x!=1){                         //
		if(xd[x]<xd[x/2]){           //
		swap(xd[x],xd[x/2]);        //
		xdn(x/2);                  //
		}                         //
	}                            //
	return ;                    //
}                              //
//----------------------------//

//-------------------------------------------------------------//比大小 
int pdx(int x){                                               //小根堆 
	if(xd[x]<=xd[x*2]&&xd[x]<=xd[x*2+1])return 1;            //
	else return xd[x*2]<xd[x*2+1]? 2:3;                     //
}//--------------------------------------------------------//
int pdd(int x){                                           //大根堆 
	if(dd[x]>dd[x*2]&&dd[x]>dd[x*2+1])return 1;          //
	else return dd[x*2]>dd[x*2+1]? 2:3;                 //
}                                                      //
//----------------------------------------------------// 

//----------------------------------------------------------------------//取出 
void ddm(int x){                                                       //大根堆 
	if(x*2+1<=dtop){                                                  //
		pd=pdd(x);                                                   //
		if(pd==2){                                                  //
			swap(dd[x],dd[x*2]);ddm(x*2);                          //
		}else if(pd==3){                                          //
			swap(dd[x],dd[x*2+1]);ddm(x*2+1);                    //
		}                                                       //
	}                                                          //
	else if(x*2<=dtop){                                       //
		if(dd[x]<dd[x*2])                                    //
			swap(dd[x],dd[x*2]);                            //
	}                                                      //
	return ;                                              //
}                                                        //
//------------------------------------------------------// 
void xdm(int x){                                       //小根堆 
	if(x*2+1<=xtop){                                  //
		pd=pdx(x);                                   //
		if(pd==2){                                  //
			swap(xd[x],xd[x*2]);xdm(x*2);          //
		}else if(pd==3){                          //
			swap(xd[x],xd[x*2+1]);xdm(x*2+1);    //
		}                                       //
	}                                          //
	else if(x*2<=xtop){                       //
		if(xd[x]>xd[x*2])                    //
			swap(xd[x],xd[x*2]);            //
	}                                      //
	return ;                              //
}                                        //
//--------------------------------------// 

int main(){
	memset(qwq,1,sizeof(qwq));//初始化 
	scanf("%d",&n);
	int op,shu;
	for(int i=1;i<=n;i++){//在线算法--可省个数组 
		scanf("%d%d",&op,&shu);
		if(op==1){
			//加入 
			zan[++top]=shu;
			dl[++r]=shu;
			dd[++dtop]=shu;
			xd[++xtop]=shu;
			ddn(dtop);
			xdn(xtop);
		}
		else if(op==2){
			if(top>0){//特判---是否为空-----------------------// 
			if(shu!=dl[l])qwq[1]=0;//------------------------//不是 
			if(shu!=zan[top])qwq[2]=0;                      // 
			if(shu!=dd[1])qwq[3]=0;                        // 
			if(shu!=xd[1])qwq[4]=0;                       // 
			top--;                                       // 
			l++;                                        // 
			dd[1]=dd[dtop];                            // 
			xd[1]=xd[xtop];                           // 
			dtop--;                                  // 
			xtop--;                                 // 
			ddm(1);                                // 
			xdm(1);                               // 
			}                                    // 
			else {//----------------------------//是 
				for(int i=1;i<=4;i++){         // 
				qwq[i]=0;                     // 
				}                            // 
			}//-----------------------------// 
		}
		/*for(int i=1;i<=4;i++){//调试组，调试堆 
			cout<<qwq[i]<<"   ";
		}cout<<endl;
		for(int i=1;i<=xtop;i++){
			cout<<"   "<<xd[i]<<"  "<<dd[i]<<endl;
		}*/
	}
	
	for(int i=1;i<=4;i++){
		if(qwq[i]==1)cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
}
```

好了，这篇题解就到这里了。

这是我的一篇题解，有不当之处请指出。


------------
$update:$
修补了$\LaTeX$

---

## 作者：songhongyi (赞：3)

这道题好像是一道经典题目吧，蓝书里都有的。  
题意：有一个数据结构，告诉您若干次操作，请问它可能是哪些数据结构。（栈，队列，大根堆，小根堆）  
很容易我们会想到一种方法：维护这四种数据结构，对于插入操作，直接在四个结构中一起操作；对于弹出操作，对这四个结构进行弹出，判读是否正确，每个数据结构打一个标记维护一下逻辑与的结果。  
注意到题目中有这样一句话
> 注意输入的数据仅保证在格式和范围上完全正确，**不保证任何其他条件**。

于是这就带来了一个坑点，那就是有可能在没有元素是弹出，显然这时候四个标记都应该为`false`，**并不再弹出**，不然和RE。  

另外，一定记得：**要弹出**（认真的）。

代码如下，直接使用STL
```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<int> qd;
priority_queue<int,vector<int>,greater<int> >qx;
queue <int> qp;
stack <int> s;  // 使用STL维护四种数据结构
int main ()
{
	int n;
	cin>>n;
	bool qdb,qxb,qpb,sb;
	qdb=qxb=qpb=sb=1;  // 四个标记
	while (n--)  //对于每一次操作
	{
		int opt,x;
		cin>>opt>>x;
		if (opt==1)  //插入操作
		{
			qd.push(x);
			qx.push(x);
			qp.push(x);
			s.push(x);  // 直接插入，没什么好说的
		}
		if (opt==2)
		{
			qdb&=(!qd.empty())&&(qd.top()==x);
			qxb&=(!qx.empty())&&(qx.top()==x);
			sb&=(!s.empty())&&(s.top()==x);
			qpb&=(!qp.empty())&&(qp.front()==x); // 和标记and 一下 非空与首部为x 的 and(如果and前面的为false，则不会执行下一项，因此不会RE)
			if (!qd.empty())
				qd.pop();
			if (!qx.empty())
				qx.pop();
			if (!s.empty())
				s.pop();
			if (!qp.empty())
				qp.pop();  // 对于非空的结构进行弹出
		}
	}
	cout<<(qpb?"Yes":"No")<<endl;
	cout<<(sb?"Yes":"No")<<endl;
	cout<<(qdb?"Yes":"No")<<endl;
	cout<<(qxb?"Yes":"No")<<endl;  //  对于四个标记进行输出，顺序：队列，栈，大根堆，小根堆
}
```

代码写起来可以复制，还是很好写的

---

## 作者：破忆 (赞：3)

这题在线分别模拟队列、栈、堆即可

注意判断数据结构是否为空

由于博主~~不会用STL~~追求更高的效率

所有手写了数据结构
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n;
int que[maxn],hed,til;  //队列
int stk[maxn],top;		//栈
int HEP[maxn],LEN;		//大根堆
int hep[maxn],len;		//小根堆
bool ans[4];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void put(int x){
	hep[++len]=x;
	int son=len;
	while(son>1&&hep[son]<hep[son>>1]){
		swap(hep[son],hep[son>>1]);
		son>>=1;
	}
}
int get(){
	int ret=hep[1],fa=1,son;
	hep[1]=hep[len--];
	while((fa<<1)<=len){
		if((fa<<1|1)>len||hep[fa<<1]<hep[fa<<1|1]) son=fa<<1;else son=fa<<1|1;
		if(hep[son]<hep[fa]) swap(hep[son],hep[fa]),fa=son;else break;
	}
	return ret;
}
void PUT(int x){
	HEP[++LEN]=x;
	int son=LEN;
	while(son>1&&HEP[son]>HEP[son>>1]){
		swap(HEP[son],HEP[son>>1]);
		son>>=1;
	}
}
int GET(){
	int ret=HEP[1],fa=1,son;
	HEP[1]=HEP[LEN--];
	while((fa<<1)<=LEN){
		if((fa<<1|1)>LEN||HEP[fa<<1]>HEP[fa<<1|1]) son=fa<<1;else son=fa<<1|1;
		if(HEP[son]>HEP[fa]) swap(HEP[son],HEP[fa]),fa=son;else break;
	}
	return ret;
}
int main(){
//	freopen("P5375.in","r",stdin);
//	freopen("P5375.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		int k=read(),x=read();
		if(k==1){
			que[++til]=x;
			stk[++top]=x;
			PUT(x);
			put(x);
		}
		else{
        	//注意判当前数据结构中是否还有元素
			if(hed==til||que[++hed]!=x) ans[0]=1;
			if(!top||stk[top--]!=x) ans[1]=1;
			if(!LEN||GET()!=x) ans[2]=1;
			if(!len||get()!=x) ans[3]=1;
		}
	}
	for(int i=0;i<4;i++) printf("%s\n",ans[i]?"No":"Yes");
	return 0;
}
```


---

## 作者：Sora1336 (赞：1)

彻头彻尾的模拟题。主要就是被一道毒瘤树剖虐爆了来这里找征服感的。

使用四个 STL ，要求插入的话四个数据结构一起插入，如果删除的话，那么判断队头/栈顶元素是不是要删除的那个数，如果是的话就删除，如果不是的话就直接认定不是这个数据结构，同样，如果是在空的时候删除话那么也不是这个数据结构。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdio>
#include <stack>
#include <queue>
using namespace std;
int n, opt, v;
stack<int> stk;
queue<int> que;
priority_queue<int> Sheap;
priority_queue<int, vector<int>, greater<int> > Bheap;
bool _[5];
int main() {
	scanf("%d", &n);
	while(n --) {
		scanf("%d%d", &opt, &v);
		if(opt == 1) {		//模拟加入元素
			stk.push(v);
			que.push(v);
			Sheap.push(v);
			Bheap.push(v);
		} else {
			if(que.empty()) _[1] = true;		//判断是否删完了
			if(stk.empty()) _[2] = true;
        	if(Sheap.empty()) _[3] = true;
			if(Bheap.empty()) _[4] = true;
			if(!_[1]) {							//判断删除的数是否符合这个数据结构
				if(que.front() != v) _[1] = 1;
				else que.pop();
			} if(!_[2]){
				if(stk.top() != v) _[2] = 1;
				else stk.pop();
			} if(!_[3]) {
					if(Sheap.top() != v) _[3] = 1;
					else Sheap.pop();
			} if(!_[4]) {
				if(Bheap.top() != v) _[4] = 1;
				else Bheap.pop();
			} 
		}
	} for(int i = 1; i <= 4; i ++) _[i] ? printf("No\n") : printf("Yes\n");
}
```


---

## 作者：ModestCoder_ (赞：1)

直接模拟四个数据结构的操作即可

一旦某一个数据结构不满足要求以后就不用模拟了

注意每一次都要判断是否为空，否则会RE

Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
queue <int> a;
stack <int> b;
priority_queue <int> c;
priority_queue <int, vector<int>, greater<int> > d;
int n, flag[5];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int main(){
	n = read();
	while (n--){
		int opt = read(), k = read();
		if (opt == 1){
			if (!flag[1]) a.push(k);
			if (!flag[2]) b.push(k);
			if (!flag[3]) c.push(k) ;
			if (!flag[4]) d.push(k);
		} else{
			if (a.empty()) flag[1] = 1;
			if (b.empty()) flag[2] = 1;
			if (c.empty()) flag[3] = 1;
			if (d.empty()) flag[4] = 1;
			if (!flag[1]) if (a.front() == k) a.pop(); else flag[1] = 1;
			if (!flag[2]) if (b.top() == k) b.pop(); else flag[2] = 1;
			if (!flag[3]) if (c.top() == k) c.pop(); else flag[3] = 1;
			if (!flag[4]) if (d.top() == k) d.pop(); else flag[4] = 1;
		}
	}
	for (int i = 1; i <= 4; ++i)
		if (flag[i]) puts("No"); else puts("Yes");
	return 0;
}
```


---

## 作者：Silky_Dove (赞：0)

$\quad\;$**这道题目是对于四种基本数据结构模板的整合。**

### 前置芝士(只有3个~~模板~~)：栈 , 队列 , 大/小根堆

​		题目就是给您四个数据结构和一堆操作，问你这些操作是否满足其中一种或多种数据结构的特性，询问您这些数据结构可能是哪些(栈，队列，大/小根堆)。

​		我们可以从反方向想，我们维护这四种数据结构，假设所有的数据结构都满足，若在维护时发现有一个元素不满足某个数据结构的特性，就把 $box[i]$ 置为 $false$ 。最后离线输出即可。

### 坑点：一定要判数据结构是否为空

​		如果为数据结构为空，就直接把四个都置为 $false$ ，**不要弹出**。否则你会在下下次插入时**数组访问越界( $STL$ 也会) $RE$ ,这里一定记得特判一下。**

​		其他的就没啥了，这题时间复杂度 $O(n \log n)$,**不卡时间空间$\iff$巩固模板**

### 接下来上代码


```cpp
//[Code]P5375 [THUPC2019]组合数据结构问题
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 100;
inline int read(){
	int x = 0 , f = 1;char ch = getchar();
	while(!isdigit(ch)){if(ch == '-') f = -1;ch = getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch = getchar();}
	return x * f;
}
int stk[maxn],top;//stk是用数组模拟栈,top表示栈顶 
int q[maxn],head=1,tail;//q是用数组模拟队列,head是队头,tail是队尾 
int bigheap[maxn],idx1;//bigheap表示大根堆,idx1是大根堆元素个数 
int smlheap[maxn],idx2;//smlheap表示小根堆,idx2是小根堆元素个数 
bool box[5];//box表示 5 种类型的数据结构 
//---------------Cut Line---------------// 
//以下是队列维护函数 
void q_push(int v){q[++tail] = v;}
void q_pop(){head++;}
//---------------Cut Line---------------// 
//以下是栈维护函数 
void stk_push(int v){stk[++top] = v;}
void stk_pop(){top--;}
//---------------Cut Line---------------// 
//以下是大根堆维护函数 
void big_dataup(int p){
	while(p > 1){
		if(bigheap[p] > bigheap[p>>1]){
			swap(bigheap[p],bigheap[p>>1]);
			p >>= 1;
		}else break;
	}
}
void big_insert(int val){
	bigheap[++idx1] = val;
	big_dataup(idx1);
}
int bigtop(){return bigheap[1];}
void big_down(int p){
	int s = p << 1;
	while(s <= idx1){
		if(s < idx1 && bigheap[s] < bigheap[s+1]) s++;
		if(bigheap[s] > bigheap[p]){
			swap(bigheap[s],bigheap[p]);
			p = s , s = p << 1;
		}else break;
	}
}
void big_extract(){
	bigheap[1] = bigheap[idx1--];
	big_down(1);
}
//---------------Cut Line---------------// 
//以下是小根堆维护函数 
void sml_dataup(int p){
	while(p > 1){
		if(smlheap[p] < smlheap[p>>1]){
			swap(smlheap[p],smlheap[p>>1]);
			p >>= 1;
		}else break;
	}
}
void sml_insert(int val){
	smlheap[++idx2] = val;
	sml_dataup(idx2);
}
int smltop(){return smlheap[1];}
void sml_down(int p){
	int s = p << 1;
	while(s <= idx2){
		if(s < idx2 && smlheap[s] > smlheap[s+1]) s++;
		if(smlheap[s] < smlheap[p]){
			swap(smlheap[s],smlheap[p]);
			p = s , s = p << 1;
		}else break;
	}
}
void sml_extract(){
	smlheap[1] = smlheap[idx2--];
	sml_down(1);
}
//---------------Cut Line---------------// 
int main(){
	int T = read();
	memset(box,true,sizeof(box));
	//注意要先初始化的全 true 
	for(int i = 1;i <= T;i++){
		int opt = read();
		int val = read();
		if(opt == 1){
			q_push(val);
			stk_push(val);
			big_insert(val);
			sml_insert(val);
			//分别往这四个中插入 val 
		}
		if(opt == 2){
			if(!top)
				for(int i = 1;i <= 4;i++)
					box[i] = false;
			//这里一定要注意特判是否为空 !!!
			//我成功 RE 了一次 
			else{
				//如果不满足性质,就直接改为 false,下面同理 
				if(val != q[head]) box[1] = false;
				if(val != stk[top]) box[2] = false;
				if(val != bigtop()) box[3] = false;
				if(val != smltop()) box[4] = false;
				q_pop(); stk_pop();
				big_extract(); sml_extract();
			}
		}
	}
	for(int i = 1;i <= 4;i++)
		if(box[i]) puts("Yes");
		else puts("No");
	return 0; 
}
```

### 感谢您的阅读

---

## 作者：SpectatorX (赞：0)

[UVA11995](https://www.luogu.com.cn/problem/UVA11995)的升级版？

同时维护题目所述的四种数据结构，同时进行插入与弹出，弹出时通过弹出元素与给出元素是否相等来判断这种数据结构是否合法。

一个坑点，如果队列已经为空，**则不能再弹出**。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,opt,x;
stack<int> st;
queue<int> q;
priority_queue<int> pq;
priority_queue<int,vector<int>,greater<int> > pqx;
int is_st,is_q,is_pq,is_pqx;
int check[5];
void clear()
{
	while(!st.empty())st.pop();
	while(!q.empty())q.pop();
	while(!pq.empty())pq.pop();
	while(!pqx.empty())pqx.pop();
	check[1]=check[2]=check[3]=check[4]=1;
}
void insert(int x)
{
	st.push(x);
	q.push(x);
	pq.push(x);
	pqx.push(x);
}
void pop(int x)
{
	if(q.empty())check[1]=check[2]=check[3]=check[4]=0;
	else
	{
		int t=st.top();st.pop();
		if(t!=x)check[2]=0;
		t=q.front();q.pop();
		if(t!=x)check[1]=0;
		t=pq.top();pq.pop();
		if(t!=x)check[3]=0;
		t=pqx.top();pqx.pop();
		if(t!=x)check[4]=0;
	}
}
inline int read()
{
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	n=read();
	clear();
	while(n--)
	{
		opt=read();x=read();
		if(opt==1)insert(x);
		else pop(x);
	}
	for(int i=1;i<=4;++i)puts(check[i]?"Yes":"No");
	return 0;
}
```

---

## 作者：Kisaragi_77 (赞：0)

这题感觉离线更好写啊。。


注意四种数据结构都要预判弹空栈/空队列

检测到矛盾操作或者非法操作立即退出

至于long long 的小根堆我是没写过greater<>方法

我直接丢负数进去的

其实并没有多少细节，四种数据结构的判断复制粘贴就好

```cpp
#include<stack>
#include<queue>
#include<cstdio>
#define ll long long
#define N (int)1e5+4
using namespace std;
inline ll read(){
    ll x;scanf("%lld",&x);return x;
}
int n,op[N];
ll a[N];
inline bool stack_test(){
    stack <ll> s;
    for(int i=1;i<=n;++i){
        if(op[i]==1)    s.push(a[i]);
        else{
            if(s.empty() || s.top()!=a[i])  return false;
            s.pop();
        }
    }   return true;
}
inline bool queue_test(){
    queue <ll> Q;
    for(int i=1;i<=n;++i){
        if(op[i]==1)   Q.push(a[i]);
        else{
            if(Q.empty() || Q.front()!=a[i])    return false;
            Q.pop();
        }
    }   return true;
}
inline bool max_queue_test(){
    priority_queue <ll> Q;
    for(int i=1;i<=n;++i){
        if(op[i]==1)   Q.push(a[i]);
        else{
            if(Q.empty() || Q.top()!=a[i])  return false;
            Q.pop();
        }
    }   return true;
}
inline bool min_queue_test(){
    priority_queue <ll> Q;
    for(int i=1;i<=n;++i){
        if(op[i]==1)   Q.push(-a[i]);
        else{
            if(Q.empty() || Q.top()!=-a[i])  return false;
            Q.pop();
        }
    }   return true;
}
int main(){
    n =read();
    for(int i=1;i<=n;++i)   op[i] =read(),a[i] =read();

    if(queue_test())    puts("Yes");
    else puts("No");

    if(stack_test())    puts("Yes");
    else puts("No");

    if(max_queue_test())    puts("Yes");
    else puts("No");

    if(min_queue_test())    puts("Yes");
    else puts("No");
}

```



---

## 作者：Aehnuwx (赞：0)

这个题看上去很有高论，但其实没有那么复杂。只需要分别模拟队列、栈、大根堆和小根堆的处理过程即可。

细节和注释都在代码里了。

$ \rm code $

```cpp
# pragma GCC optimize (2)
# include <bits/stdc++.h>
using namespace std;
queue<int> que;
stack<int> stk;
priority_queue<int> heap1;
priority_queue<int, vector<int>, greater<int> > heap2;
// 使用 C++ 的 STL 库，分别定义四个数据结构：队列、栈、大根堆和小根堆.
int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    int N; bool flag[5];
    memset(flag, true, sizeof(flag));
    cin >> N;
    while(N--) {
        int opt, x;
        cin >> opt >> x;
        if(opt == 1) {
            if(flag[1]) que.push(x);
            if(flag[2]) stk.push(x);
            if(flag[3]) heap1.push(x);
            if(flag[4]) heap2.push(x);
            // 如果黑箱里暂时可能是这个数据结构的话且opt为1，那么就插入x
            // 这里模拟的是插入操作.
        }
        else {
            if(que.empty()) flag[1] = false;
            if(stk.empty()) flag[2] = false;
            if(heap1.empty()) flag[3] = false;
            if(heap2.empty()) flag[4] = false;
            // 如果该数据结构已经为空，直接把flag改一下
            if(flag[1]) {
                if(que.front() != x) flag[1] = false;
                que.pop();
            }
            if(flag[2]) {
                if(stk.top() != x) flag[2] = false;
                stk.pop();
            }
            if(flag[3]) {
                if(heap1.top() != x) flag[3] = false;
                heap1.pop();
            }
            if(flag[4]) {
                if(heap2.top() != x) flag[4] = false;
                heap2.pop();
            }
            // 模拟删除操作.
        }
    }
    for(int i = 1; i <= 4; ++i)
        flag[i] ? puts("Yes") : puts("No"); // 输出
    return 0;
}
```


---

## 作者：Setsugesuka (赞：0)

模拟 分别创建四个数据结构 每次查询的时候看一看哪个不符合即可

注意到可能会在没有储存一个元素的情况下取出元素 注意判断数据结构是否为空以防止RE

```cpp
#include<bits/stdc++.h>
using namespace std;

template <class T>
inline bool read(T &ret)
{
    char c;
    int sgn;
    if (c = getchar(), c == EOF)
    {
        return 0;
    }
    while (c != '-' && (c < '0' || c > '9'))
    {
        c = getchar();
    }
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9')
    {
        ret = ret * 10 + (c - '0');
    }
    ret *= sgn;
    return 1;
}

template <class T>
inline void write(T x)
{
    if (x > 9)
    {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}

int n;
queue<int> queue1;
stack<int> stack1;
priority_queue<int,vector<int>,greater<int> > priority_queue1;
priority_queue<int> priority_queue2;

int main()
{
    bool pd1=true,pd2=true,pd3=true,pd4=true;
    read(n);
    while(n--)
    {
        int op,x;
        read(op);
        read(x);
        if(op==1)
        {
            if(pd1)
                queue1.push(x);
            if(pd2)
                stack1.push(x);
            if(pd3)
                priority_queue1.push(x);
            if(pd4)
                priority_queue2.push(x);
        }
        else
        {
            int num1,num2,num3,num4;
            if(queue1.empty())
                pd1=false;
            if(stack1.empty())
                pd2=false;
            if(priority_queue1.empty())
                pd3=false;
            if(priority_queue2.empty())
                pd4=false;
            if(pd1)
            {
                num1=queue1.front(),queue1.pop();
                if(num1!=x)
                    pd1=false;
            }
            if(pd2)
            {
                num2=stack1.top(),stack1.pop();
                if(num2!=x)
                    pd2=false;
            }
            if(pd3)
            {
                num3=priority_queue1.top(),priority_queue1.pop();
                if(num3!=x)
                    pd3=false;
            }
            if(pd4)
            {
                num4=priority_queue2.top(),priority_queue2.pop();
                if(num4!=x)
                    pd4=false;
            }
        }
    }
    if(pd1)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    if(pd2)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    if(pd4)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    if(pd3)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    return 0;
}
```


---


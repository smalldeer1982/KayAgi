# [THUPC 2022 决赛] 匹配

## 题目描述

定义“匹配项”是一个长度为 $L$ 的字符串，每一位要么是 0，要么是 1。现在有 $N$ 个这样的“匹配项”，我们希望设计一个“方案”，“方案”同样是长度为$L$的字符串，每一位要么是 0，要么是 1。定义每个“匹配项”的错误值为“方案”与“匹配项”不同位的个数，比如“匹配项”是 `101`，“方案”是 `000`，那么两者的第一位和第三位是不同的，所以该“方案”对于该“匹配项”的错误值为 2。我们希望找到一个“方案”，使得这 $N$ 个“匹配项”的错误值之和最小。此外，有 $M$ 个互不相同的禁用“方案”，我们要求找到的“方案”不能是禁用“方案”之一。

## 说明/提示

保证 $1 \le N \le 1000$, $1 \le M \le \min(1000,2^L-1) $, $ 1 \le L \le 1000 $。

## 样例 #1

### 输入

```
4 1 4
0000
1000
1100
1010
1000
```

### 输出

```
5
```

## 样例 #2

### 输入

```
2 4 4
0000
0000
0000
1000
0100
0010

```

### 输出

```
2
```

# 题解

## 作者：A_zjzj (赞：4)

[更好的阅读体验](https://www.cnblogs.com/A-zjzj/p/16411832.html)

## 题目大意
给定 $N$ 个长度为 $L$ 的 01 匹配串 $a$ 和 $M$ 长度为 $L$ 的 01 禁用串 $b$，要求找到一个不是禁用串的长度为 $L$ 的 01 字符串 $c$，使得 $\sum\limits_{i=1}^N\sum\limits_{j=1}^L{[a_{i,j}\ne c_j]}$ 最小，求出这个最小值。

## 思路
这是与官方题解不同的解法，时空复杂度：$O((N+M)\times L)$。

首先考虑将禁用串全部扔到一个 Trie 上，然后考虑一步一步从 Trie 上 dfs。

由于要求不能与禁用串一样，所以直到 dfs 到一个空节点时，此时当前的字符串已经不在禁用串当中了。

然后在这个节点考虑以最优情况填充后面的几位——每一位上 $0$ 的个数少就填 $0$，否则就填  $1$，这一步可以直接后缀和预处理出来。

然后会发现 Trie 中最多只有 $O(M\times L)$ 个节点，所以每个节点最多只会产生 $2$ 个空节点，所以最多只会 dfs 到 $O(M\times L)$ 个空节点。

因为到达一个空节点之后，就没有必要再 dfs 下去了，此时的最优情况已经确定。

常数十分小，跑得飞快。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e3+10;
int n,m,k,cnt,ch[N*N][2],tot[N],sum[N],ans=1e9;
char a[N][N],b[N][N];
void insert(int x) {
	int now=0;
	for(int i=1; i<=k; i++) {
		if(ch[now][b[x][i]^'0']==-1)ch[now][b[x][i]^'0']=++cnt;
		now=ch[now][b[x][i]^'0'];
	}
}
void dfs(int i,int s,int now) {
	if(now==-1)return ans=min(ans,s+sum[i]),void();
	if(i==k+1)return;
	dfs(i+1,s+tot[i],ch[now][0]);
	dfs(i+1,s+n-tot[i],ch[now][1]);
}
int main() {
	freopen(".in","r",stdin);//freopen(".out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1; i<=n; i++)scanf("%s",a[i]+1);
	for(int i=1; i<=m; i++)scanf("%s",b[i]+1);
	memset(ch,-1,sizeof ch);
	for(int i=1; i<=m; i++)insert(i);
	for(int i=1; i<=n; i++)for(int j=1; j<=k; j++)tot[j]+=a[i][j]-'0';
	for(int i=k; i>=1; i--)sum[i]=sum[i+1]+min(tot[i],n-tot[i]);
	dfs(1,0,0);
	cout<<ans;
	return 0;
}
```
有问题请指出，谢谢。

---

## 作者：周子衡 (赞：2)

- **题意：** 给定 $N$ 个长度为 $L$ 的 `01` 串 $A_1,...,A_N$ 和 $M$ 个长度为 $L$ 的 `01` 串 $B_1,...,B_M$。对两个长度皆为 $L$ 的串 $S,T$，定义其距离为满足 $S_i\neq T_i$ 且 $1\leq i\leq L$ 的整数 $i$ 的数量。对某个长度为 $L$ 的 `01` 串 $S$，定义其代价为 $S$ 与 $A_1,...,A_N$ 的距离之和。求一个串 $S$，使得 $S$ 不与 $B_1,...,B_M$ 中的任何一个相等，且最小化 $S$ 的代价。输出最小代价即可。
- **数据范围：** $N,M,L\leq 1000$，$M < 2^L$。

---------------------------

显然可以把每位拆开来考虑。设 $A_1,...,A_N$ 中第 $i$ 位为 $j(j\in \{0,1\})$ 的串有 $cnt_{i,0}$ 个。在不考虑 $B$ 的限制的情况下，答案显然为 $\sum \min\{cnt_{i,0},cnt_{i,1}\}$。我们先构造一个达到下界的串 $S$。在此基础上，我们计算翻转 $S$ 的第 $i$ 位所需要付出的额外代价 $b_i$，并将 $b_1,...,b_L$ 排序。下面假定 $b_1\leq \cdots \leq b_L$。

由于 $B$ 一共只有 $M$ 个，我们只要能求得代价前 $M+1$ 小的串，那么答案也就出来了。求代价前 $k$ 小的串有个很漂亮的做法：维护一个元素为 `01` 串、以代价为权值的小根堆，开始时堆中只有 $S$ 一个元素。每次从堆顶弹出一个串 $T$，

- 如果 $S=T$ 那么把 $T$ 的第 $1$ 位翻转之后插回去。
- 否则，我们找到最大的 $j$ 使得 $T$ 与 $S$ 在第 $j$ 位不同。设 $T_0$ 为把 $T$ 第 $j$ 位翻转后的结果，$T_1$ 为把 $T$ 第 $j,j+1$ 位都翻转后的结果，我们把 $T_0,T_1$ 都插到堆中。

那么第 $k$ 次从堆中弹出来的就是代价第 $k$ 小的串了。

要说明这个做法的正确性并不难。事实上，对于一个类似的贪心策略，只要满足：

- 每个串在整个过程中被恰好访问一遍；
- 每个串所生成的串的代价不小于它本身的代价；

那么这个贪心策略都是可行的。

由于我们弹一个元素出来最多会插入两个元素，整个过程中考虑到的元素数量是 $O(M)$ 的。使用最暴力的做法已经可以在 $O(MT\log M)$ 的时间复杂度内求出答案了，如果使用哈希来判断串是否相等还能更快。

下面代码实现的时候只要一遇到一个不在 $B$ 中的串就直接输出答案。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>

using namespace std;

struct dat
{
	int val,pos;vector<bool> V;
};
bool operator<(dat a,dat b){return a.val>b.val;}
priority_queue<dat> pq;

map<vector<bool>,bool> mp;
char s[2000];
int cnt[2000][2];
pair<int,int> b[2000];

int main()
{
	int n=0,m=0,l=0;scanf("%d%d%d",&n,&m,&l);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);for(int j=0;j<l;j++)if(s[j]=='0')cnt[j][0]++;else cnt[j][1]++;
	}
	int ans=0;vector<bool> minn(l);for(int i=0;i<l;i++)if(cnt[i][0]<=cnt[i][1])ans+=cnt[i][0],b[i].first=cnt[i][1]-cnt[i][0],minn[i]=1;
	else ans+=cnt[i][1],b[i].first=cnt[i][0]-cnt[i][1],minn[i]=0;
	
	for(int i=0;i<l;i++)b[i].second=i;
	sort(b,b+l);
	dat T;T.val=ans,T.pos=-1,T.V=minn;pq.push(T);
	vector<bool> ban(l);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s);for(int j=0;j<l;j++)ban[j]=s[j]-'0';mp[ban]=1;
	}
	while(!pq.empty())
	{
		T=pq.top();pq.pop();
		if(mp[T.V]==0){printf("%d\n",T.val);return 0;}
		if(T.pos==-1)
		{
			T.pos=0,T.val+=b[0].first,T.V[b[0].second]=T.V[b[0].second]^1;pq.push(T);
		}
		else
		{
			int p=T.pos;
			if(T.pos==l-1)continue;
			else
			{
				T.val+=b[p+1].first-b[p].first;T.V[b[p].second]=T.V[b[p].second]^1,T.V[b[p+1].second]=T.V[b[p+1].second]^1;T.pos=p+1;
				pq.push(T);
				T.val+=b[p].first;T.V[b[p].second]=T.V[b[p].second]^1;
				pq.push(T);
			}
		}
	}
}
```

---

## 作者：lndjy (赞：2)

这个错误值看起来就很假，明显可以预处理出来每一位填 0 或者 1 的错误值贡献。

这样问题变为了你需要确定一个 01 串，每位填 0 或者 1 都有不同的代价，你需要让代价最小，同时不能是某些串。

这个是很套路的 dp：对所有不能出现的串建立 Trie 树，不能是某些串的限制就变为了不能到 Trie 的某些节点。

然后设 $f_{i,j}$ 表示长度为 $i$ 的串，匹配到 Trie 节点 $j$ 的最小代价。枚举下一位字符转移即可。

复杂度看起来是立方，实际远远跑不满，可以通过。

这个是赛时做法，赛时代码找不到了，不放了。

---

## 作者：wangtairan114 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8420)

马上就要到 THUPC2025 啦！做一下历年的题目。
## 题意
给定 $n$ 个串（记为数组 $s_1$）和 $m$ 个禁用串（记为数组 $s_2$），求构造一个字符串使其与数组 $s_1$ 各数位上字符不同的位置个数最少，同时满足该串没有在 $s_2$ 中出现过。

## 思路
观察到如果一个前缀 $a$ 满足前 $(|a|-1)$ 的位置是 $s_2$ 的一个前缀，而 $a$ 本身不满足，则 $a$ 的贡献即为前缀本身的贡献与 $s_1$ 中 $(|a|,l]$ 产生最小贡献之和。利用 $s_2$ 维护一棵 Trie 树，遍历时对于缺少儿子节点的位置进行操作。根结点到所缺的儿子节点的路径即为合法的前缀 $a$。最后统计答案即可。

## 代码
```
#include <bits/stdc++.h>
using namespace std;
#define min(a,b) ((a)>(b)?(b):(a))
#define max(a,b) ((a)<(b)?(b):(a))
#define INF 0x3f3f3f3f
#define ll long long
#define sc scanf
#define pr printf
#define v1 first
#define v2 second
#define f(nm1,nm2,nm3) for(int nm1=nm2; nm1<= nm3; nm1++)
#define lowbit(x) (x&(-x))
struct node{
    int l,r;
    int dep;
    node(){
        l=0;
        r=0;
        dep=0;
    }
}tr[1000005];//trie树的节点
int cnt=1;
int n,m,l;
string s1[1005],s2[1005];
int val[1005][2];
void search(string s)//建一棵trie
{
    int now=1;//根节点记为1
    for(int i=0; i < s.size(); i++){
        if(s[i]=='0'){
            if(tr[now].l)
                now=tr[now].l;
            else{
                tr[now].l=++cnt;
                now=cnt;
                tr[now].dep=i+1;
            }
        }
        else{
            if(tr[now].r)
                now=tr[now].r;
            else{
                tr[now].r=++cnt;
                now=cnt;
                tr[now].dep=i+1;
            }
        }
    }
}
int minval[1005];
int ans=INT_MAX;
int val1;
void dfs(int k){//遍历trie
    if(tr[k].dep==l)
        return;
    if(!tr[k].l)
        ans=min(ans,val1+val[tr[k].dep+1][0]+minval[tr[k].dep+2]);
    else{
        val1+=val[tr[k].dep+1][0];
        dfs(tr[k].l);
        val1-=val[tr[k].dep+1][0];
    }
    if(!tr[k].r)
        ans=min(ans,val1+val[tr[k].dep+1][1]+minval[tr[k].dep+2]);
    else{
        val1+=val[tr[k].dep+1][1];
        dfs(tr[k].r);
        val1-=val[tr[k].dep+1][1];
    }
}
int main(){
    sc("%d%d%d",&n,&m,&l);
    for(int i=1; i <= n; i++){
        cin >> s1[i];
        for(int j=0; j < s1[i].size(); j++){
            if(s1[i][j]=='0')
                val[j+1][1]++;
            else
                val[j+1][0]++;
        }
    }
    for(int i=1; i <= m; i++){
        cin >> s2[i];
        search(s2[i]);
    }
    for(int i=l; i>=1; i--)
        minval[i]=minval[i+1]+min(val[i][1],val[i][0]);//计算对于区间[i,l]的最小贡献
    dfs(1);
    cout << ans;
    return 0;
}
```

---

## 作者：ttq012 (赞：1)

由于只有 $0$ 和 $1$ 两个不同的字符，可以开一个 `01-Trie` 维护。

枚举的时候直接进行 `dfs` 爆搜即可。枚举第 $i$ 位位 $0/1$，最后判断是否是禁用串，如果不是计算这个字符串的错误值即可。

但是这样时间复杂度是 $O(2^n)$ 的，无法通过。

可以进行剪枝：如果当前枚举到的这一位在 `01-Trie` 上走不到，那么就直接暴力。

可以玄学水过。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 2010;
struct Node
{
  int next[2];
  Node()
  {
    next[0] = next[1] = 0;
  }
} z[N * N];
char s[N][N], t[N][N];
int n, m, k, su[N], cnt[N];
int c = 1;
void insert(char *s)
{
  int now = 1;
  for (int i = 0; i < k; i ++)
  {
    char &opt = s[i];
    if (opt == '1')
    {
      if (!z[now].next[1])
        z[now].next[1] = ++ c;
      now = z[now].next[1];
    }
    else
    {
      if (!z[now].next[0])
        z[now].next[0] = ++ c;
      now = z[now].next[0];
    }
  }
}

int ans = 1e18;
void dfs(int u, int sum = 0, int now = 1)
{
  if (u == k + 1 && now)
    return ;
  if (!now)
  {
    ans = min(ans, sum + su[u]);
    return ;
  }
  dfs(u + 1, sum + cnt[u], z[now].next[0]);
  dfs(u + 1, sum + n - cnt[u], z[now].next[1]);
}

signed main()
{
  cin >> n >> m >> k;
  for (int i = 1; i <= n; i ++) cin >> s[i] + 1;
  for (int i = 1; i <= m; i ++) cin >> t[i] + 1;
  for (int i = 1; i <= m; i ++) insert(t[i] + 1);
  for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= k; j ++)
      if (s[i][j] == '1')
        cnt[j] ++;
  for (int i = k; i; i --)
    su[i] = su[i + 1] + min(cnt[i], n - cnt[i]);
  dfs(1);
  cout << ans << '\n';
}

```



---

## 作者：Jeremiahy (赞：1)

## 分析

每位相互独立，可以预处理出来每一位填 $0$ 或 $1$ 的错误值，设第 $i$ 位填 $0$ 或 $1$ 的错误值为 $cnt_{i,x},x\in \{0,1\}$。

然后对禁用方案建立 Trie 树，在 Trie 树上 dfs 并累计走过的代价（注意不能走到禁用方案的末尾），当走出 Trie 树时，我们后面可以随便走，不用担心遇见禁用方案，也就是每一步都采用最小代价。

实际可以预处理出一个最小后缀和数组来快速计算走出 Trie 树后的代价。

算法时间复杂度 $O(n^2)$。

#### 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int trie[1000005][2], end[1000005], tot = 1, sum[1005], cnt[1005][2], ans = 0x7f7f7f7f, n, m, l;
char a[1005][1005], c[1005];

int min(int x, int y) {
	return (x > y ? y : x);
}

void dfs(int x, int y, int w){
	if (x) { // 还在 Trie 树内
		if (!end[trie[x][0]]) //不是禁用方案末尾
			dfs(trie[x][0], y + 1, w + cnt[y + 1][1]); //走并累加错误值
		if (!end[trie[x][1]])
			dfs(trie[x][1], y + 1, w + cnt[y + 1][0]);			
	}
	else //走出 Trie 树
		ans = min(ans, w + sum[y + 1]);// 计算最小错误值
}

signed main(){
	scanf("%d%d%d", &n, &m, &l);
	for (register int i = 1; i <= n; i++)
		scanf("%s", a[i] + 1);
	for (register int i = 1, u = 1; i <= m; i++){
		scanf("%s", c);
		u = 1;
		for(register int j = 0, v; j < strlen(c); j++){//建树
			v = c[j] - '0';
			if (!trie[u][v])
				trie[u][v] = ++tot;
			u = trie[u][v];
		}
		end[u] = 1;
	}
	for (register int i = 1; i <= l; i++)//预处理每位放 0/1 的代价
		for (register int j = 1; j <= n; j++)
			if (a[j][i] == '1')
				cnt[i][1]++;
			else
				cnt[i][0]++;
	for (register int i = l; i >= 1; i--) // 计算后缀和
		sum[i] = sum[i + 1] + min(cnt[i][0], cnt[i][1]);
	dfs(1, 0, 0);
	printf("%d", ans);
	return 0;
}
```


---


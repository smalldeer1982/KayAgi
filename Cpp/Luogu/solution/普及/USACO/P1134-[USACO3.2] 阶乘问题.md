# [USACO3.2] 阶乘问题

## 题目描述

也许你早就知道阶乘的含义，$N$ 阶乘是由 $1$ 到 $N$ 相乘而产生，如：

$$12!=1\times 2\times 3\times 4\times 5\times 6\times 7\times 8\times 9\times 10\times 11\times  12=479{,}001{,}600$$

$12$ 的阶乘最右边的非零位为 $6$。

写一个程序，计算 $N\ (1\le N\le5\times 10^7)$ 阶乘的最右边的非零位的值。

**注意**：$10{,}000{,}000!$ 的末尾有 $2499999$ 个零。

## 说明/提示

USACO Training Section 3.2


## 样例 #1

### 输入

```
12```

### 输出

```
6```

# 题解

## 作者：karma (赞：277)

看完下面的16篇题解,总觉得方法只有三种,只是有很多重复的题解.但实际此题只有一种正解.下面将三种方法都进行详细讲解.(其他的讲的较为模糊,估计他们自己都不清楚)

### 算法:

- 暴力 暴力乘,每次保留得到的数的后7位左右(保证不出现误差)

如果每次 mod 10,会造成误差.因为当相乘后得到的是10的倍数时,mod 10 会变成0.所以每次大概mod 1000000.最后输出ans%10

原理:最后一位相乘只会影响最后一位.故只保留最后几位就行了

- 数学方法:有两种.**第一种**分析10怎么出现.发现如果两个数的因数中分别有2,5.那么相乘末尾一定有0.于是统计1~N中每个数的因数中2和5的个数.用2的个数减去5的个数(2的个数一定比5的个数多).剩下的是会对答案(即末尾的数)造成影响.之后大胆mod 10 就行了.

- **第二种**应该是**正解**.

- 分析:N!的末尾只会是2,4,6,8(在此题中没有0).又[2,4,6,8]中任意一个数乘6,末尾仍是本身.2 \* 6 = 12,末尾为2, 4 \* 6 =24,末尾为4, 6 \* 6=36,末尾为6,8 \* 6 =48,末尾为8.又末尾数字只受末尾数字影响,如4. 4 \* 6得到的末尾数字与4 \* 16的末尾数字一样.又4 \* 10=40,末尾数字为4(此题不要末尾0).则4 \* 2 \*8==4 \* 2 \*5(意思是得到的末尾数字是一样的).故所有乘5的时候都可以换为乘8.又多次乘8末尾是有规律的.找出规律即可.

- 前两种方法就不贴代码了,贴一下正解代码并进一步解释:

```cpp
#include <cstdio>
using namespace std;
int n,ans=1;
int a[4]= {6,8,4,2};
int main() {
    scanf("%d",&n);
    while (n>0) {
        for (int i=1; i<=n%10;++i)//除了5之外,其他数字原样乘.
        //n%10 的原因:答案只受末尾数字影响 
            if (i!=5) ans=ans*i%10;//跳过乘5(此时可以放心%10) 
        n=n/5;//n/5即少乘了多少次5
        //即乘8的次数 
        ans=ans*a[n%4]%10;//四次一循环(此时可以放心%10) 
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：lsoer (赞：228)

###### 最下面，将对karma的题解进行一些解释。

本题要求我们“**计算N！的最右边的非零位的值。**”

首先，如果不知道什么是阶乘的话，先去[百度](https://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fr=aladdin)。

### 1. 初次审题

N!就是N的阶乘，你已经知道它什么意思了。

最右边非零位的值？应该没有人会不懂这是什么意思。

如17005722最右边非零位的值是2，479001600最右边非零位的值是6。

怎么求呢？

最简单的是暴力算。

int不够开longlong，longlong不够开高精。

运行太慢开O2，O2不行开臭氧。

空间（~~压位高精~~）可以炸，时间（~~O4,O5，O1134~~）一定炸。

------------

我们可以发现，两个数乘积的最右边的值，只与这两个数最右边的值有关。如5\*7=35,665\*137=91105。最右边的值都是5。

那么我们可以乘的时候只记最后一位，有零就全去掉。就像这样：
```c
{
	int ans=1;//初值为1 
	for (int i=1;i<=n;++i)//遍历 
	{
		ans*=i;
		while (ans%10==0)
		ans/=10;//去零 
		ans%=10;//只保留最后一位 
	}
}
```
当然过不了。

如n=15时：14!=87178291200，我们只保留了末尾数字2，乘15会得到30，即答案为3。但是，15!=130767438000，正确答案为8。12\*15=180正确，2\*15=3由于保留位数太少而错。

那么，我们多保留几位就可以了。

```c
{
	int ans=1;//初值为1 
	for (int i=1;i<=n;++i)//遍历 
	{
		ans*=i;
		while (ans%10==0)
		ans/=10;//去零 
		ans%=100000000;//保留最后好多位 
	}
	ans%=10;//保留最后一位 
}
```
可以过，但不够好。

### 2.这可是数论题

让我们有对待数论题该有的亚子。

本题的罪恶之点就是‘0’，那么是谁引起的呢？

2\*5=10，是2和5团伙作案。

我们知道，能被2整除的数和能被5整除的数相乘会产生末尾的0。

而在1到10中，有5个数能被2整除（2,4,6,8,10），只有2个能被5整除（5,10）。因此在2和5的缠斗中，2总是能活下来

2比5多，我们可以在处理的时候将所有要乘的2和所有要乘的5拿出来。用2的个数减去5的个数（减去的数相乘得到了末尾的0，然后被忽略），把剩下的2再乘回去。

```c
{
	int ans=1;
	int num_2=0,num_5=0;
	for (int i=1;i<=n;++i)
	{
		int ii=i;//建立一个备份，因为一会儿会改变它的值 
		while (ii%2==0)
		{
			num_2++;
			ii/=2;
		} //去所有的2，像4这样的数因子中有不止一个2（4=2*2） 
		while (ii%5==0)
		{
			num_5++;
			ii/=5;
		} //去5，同上 
		ans=ans*i%10;
	}
	num_2=num_2-num_5;//剩下多少2 
	for (int i=1;i<=num_2;++i)
	ans=ans*2%10;//乘回去 
}
```
在最后，我们让ans连续乘很多2，由于连续乘很多2的末尾数是有规律的，可把最后的循环改一下。
```c
int c[4]={6,2,4,8};
ans=ans*c[num_2%4]%10;
```
规律：乘1个2为2,2个为4,3个为8,4个为6,5个为2······四个一循环。

这题本应该在这里结束的。

### 3.神奇之处

上一个解法还不错，但时间复杂度没降下来。

我们说末尾的0是2和5造成的，但主谋还是5。~~谁少谁是主谋~~

那么我们处理时把所有可以被5整除的数先跳过不乘。

利用下面的程序我们可以看到一些有意思的东西。
```c
#include<cstdio>
#define xman 30
using namespace std;
int main()
{
	for (int n=1;n<=xman;++n)
	{
		int ans=1;
		for (int i=1;i<=n;++i)
		if (i%5!=0)
		ans=ans*i%10;
		printf("%d\n",ans);
	}
}
```
结果：
![](https://cdn.luogu.com.cn/upload/pic/73200.png)

除1以外，我们发现结果是有规律的。记下来：
```c
 int a[10]={6,6,2,6,4,4,4,8,4,6}
```
- **由此，我们可以直接得到任意数这么处理后的末尾数。那么可以将此数和 被跳过数的乘积的末尾数 相乘得到答案。（至于0，我们有方法处理）**

再看被跳过的那些数。

![](https://cdn.luogu.com.cn/upload/pic/73427.png)

是一个5的幂和一个阶乘的乘积。

- **阶乘的末尾数可以递归的处理。**

5的幂？有点难处理。因为乘5会产生0，这个过程如果我们只保留末尾数，答案会出错。（见上方15！）

这时，神奇的8，出来了。

除1以外，我们的最终答案一定是2,4,6,8中的一个。

因为与5相乘剩余的2，会让去0后的数成为偶数。

又有**2**\*6=1**2**,**4**\*6=2**4**,**6**\*6=3**6**,**8**\*6=4**8**。

所以答案乘6得到的数末尾数不变。

末尾数乘积只与末尾数有关，有**2**\*16=3**2**,······

同时，乘10末尾数也不变。**2**\*10=**2**0,······

那么，2\*2\*5==2\*2\*8······

- **所以乘5时我们可以换成乘8！**

同时乘8的末尾数也有规律：

```c
b[4]={6,8,4,2}
```
那么，它来了：
```c
#include<cstdio>
using namespace std;
int a[10]={6,6,2,6,4,4,4,8,4,6},b[4]={6,8,4,2};
int toans(int n)
{
	if (n==0)
	return 1;//边界 
	int ans=1;
	ans=ans*a[n%10];//不乘5倍数的阶乘 
	int times_5=n/5;//没乘5的次数 
	ans=ans*b[times_5%4]%10;//以8代5，处理幂 
	ans=ans*toans(n/5)%10;//递归处理阶乘 
	return ans;
}
int main()
{
	int n;
	scanf("%d",&n);
	if (n==1)//特判
	{
		printf("1");
		return 0;
	}
	printf("%d",toans(n));
	return 0;
}
```
用while循环代替递归，则是：
```c
#include<cstdio>
using namespace std;
int a[10]={6,6,2,6,4,4,4,8,4,6},b[4]={6,8,4,2};
int main()
{
	int ans=1,n;
	scanf("%d",&n);
	if (n==1)
	{
		printf("1");
		return 0;
	}
	while(n)
	{
		ans*=a[n%10];
		n=n/5;
		ans=ans*b[n%4]%10;
	}
	printf("%d",ans);
	return 0;
}
```
这种神奇的做法，log(n)的复杂度，速度达到了一流。

有多快？

![](https://cdn.luogu.com.cn/upload/pic/73198.png)

~~我想本题的数据完全可以大个几万倍~~

- **特判**

为什么我们会需要特判？

我们用“2\*2\*5==2\*2\*8······”来证明可以用乘5代替乘8，但是你会发现式子中两边都有一个特别的‘2’。

这要求我们的的答案不仅仅只是偶数，还要能支付一个‘2’来订购‘以8换5’业务。

对于，1！=1，2！=2，3！=6。它们都无法支付‘2’（即在除2后不是偶数），因此都不能由8替5。

但是，2！，3！的末尾数都是偶数，又正好要乘6，结果因此不变，~~运气好过了~~

1就不行了，但测试数据没有1!

------------

最后，本题的AC代码可以很短：
```c
#include<cstdio>
int main()
{
	int a[]{6,6,2,6,4,4,4,8,4,6},b[]{6,8,4,2},r=1,n;
	scanf("%d",&n);
	while(n)r=r*a[n%10]*b[(n=n/5)%4]%10;
	printf("%d",r);
	return 0;
}
```

---

## 作者：「QQ红包」 (赞：47)

题解by：redbag

第一个AC+第一个写题解。

10=2\*5。

不难发现，2的个数一定比5的个数多。

其他数我们只需要尾数就好。

结果就是2^(2的个数-5的个数)\*其他数%10。

```cpp
/*
ID: ylx14271
PROG: fact4
LANG: C++     
*/
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
int n;//读入用
int sum;//存结果
int s;//存2的个数减去5的个数，即剩余2的个数
int i;//循环控制变量
int qiu(int k)
{
    int kk=k; 
    while (kk%2==0)
    {
        kk/=2;
        s++; 
    }//2的个数
    while (kk%5==0)
    {
        kk/=5;
        s--; 
    }//5的个数
    return kk;
} 
int main() 
{
    sum=1;//初始化 
    freopen("fact4.in","r",stdin);
    freopen("fact4.out","w",stdout); 
    scanf("%d",&n);//读入
    for (i=2;i<=n;i++) sum=(sum*qiu(i))%10; 
    for (i=1;i<=s;i++) sum=(sum*2)%10;
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：Shallowy (赞：24)

很多题解里都没有提到这一点，(**一定是我太菜了**)我在这里作个补充。

首先，n>1时，答案一定是2,4,6,8.

而2,4,6,8这四个数分别乘6，个位是不变的。

###### 于是蒟蒻我就想不通了：为什么每次计算完之后n可以/5而不影响答案呢？~~因为我真的太菜了。~~

```cpp
    while(n){
        t=n%10+1; while(--t) if(t!=5) (ans*=t)%=10;
        n/=5, //就是这里
        (ans*=a[n%4])%=10;
    }
```

其实通过观察(kan)，计算(ti)和模拟(jie)，我们可以发现，去掉5之后，也就是![](http://a3.qpic.cn/psb?/V10Cnxsq3A6dvO/I2VN2RzKprbI30OEFCIKKmjr8OW54MED3ptEiy3cJrQ!/b/dF4BAAAAAAAA&ek=1&kp=1&pt=0&bo=kQFSAAAAAAARF.I!&vuin=2533136630&tm=1523062800&sce=60-2-2&rf=viewer_4)

~~费尽千辛万苦打乘号~~

我们可以发现，**上面这个式子算出来的个位数是6**。

于是，我们可以只算**5的倍数中的5**和它们**除掉5**之后的乘积，以及n的个位上那几个数。

如12： 

	      1. 有5*1=5，

            5*2=10，共两个5.
                     
          2.对于10,除掉5后还有2.
          
          3.剩下11和12.

得到答案为

![](http://a3.qpic.cn/psb?/V10Cnxsq3A6dvO/i1hxSsPMSU1y6401.l73FlJ6PZpK9kVqleHWTHKCbeI!/c/dPIAAAAAAAAA&ek=1&kp=1&pt=0&bo=igFwAAAAAAARF9s!&vuin=2533136630&tm=1523066400&sce=60-2-2&rf=0-0)

---

## 作者：jklover (赞：16)

/\*
基本思路：纯模拟，算0前的最后1位。

末尾0就是多个10相乘得来的 ，我们只需要在相乘算个位数时将末尾0的个数的2,5提前约去即可

计算末尾0的个数，只需要计算1~n中有多少个因数5，因为因数2的个数肯定比5多 ，每一组2,5凑成10.

计算出来后，在从1~n相乘时，约去对应个数的2，5，再取 个位，结尾肯定没有0，膜10得来的数就是答案。

具体代码见下

\*/



```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,s=1,k1=0,k2=0;//s计算结果，k1,k2分别计算2,5需要除去的个数 
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        int m=i;//i是不能随便除的，我们把它的值赋给m 
        while(!(m%5))
            {
                m/=5;
                k2++;//只用计算因数5的个数 
            }
    }
    k1=k2;//2也只需要除这么多 
    for(int i=2;i<=n;i++)
        {
            int p=i;//i不能随便除 
            while(!(p%2)&&k1)//整除，并且次数够 
            {
                p/=2;
                k1--;
            }
            while(!(p%5)&&k2)//同理 
            {
                p/=5;
                k2--;
            }
            s*=p%10;
            s%=10;//只用计算个位 
        }
    printf("%d",s);
    return 0;
}
```

---

## 作者：XZYQvQ (赞：11)

安利自己的博客QvQ：[http://www.k-xzy.xyz/archives/5073](http://www.k-xzy.xyz/archives/5073)

对于这题确实是可以用$O(n)$或$O(nlogn)$级别的算法做

但是我们怎么能止步于如此浅薄的层次呢QvQ

参见[OEIS - A008904](http://oeis.org/A008904)

算法过程：

+ 读入$A$
+ 将$A$转换为$5$进制，得到$5$进制数字$A_5$，其第$i$位的值为$A_5[i]$（$i$从$0$开始）
+ 设$t$为$\sum_{i \text{ mod } 2 =0} A_5[i]$
+ 设$x$为$\sum A[i] * i$
+ 设$z$为$x+\frac{t}{2}\text{ mod }4$
+ 设$y$为$2^z$
+ 则答案为$\{6 * (y\text{ mod }2)+y * [1-(y\text{ mod }2)]\} \text{ mod }10$

复杂度$O(log_5A)$

（貌似楼下也有个复杂度同级的算法，但这个算法不带常数233333～）

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int a, x, t, z, y;

vector<int> a5;

void ito5() {while (a) a5.push_back(a % 5), a /= 5;}

int main(int argc, char const* argv[])
{
	scanf("%d", &a), ito5();
	for (int i = 0; i < a5.size(); i += 1)
	{
		if (!(a5[i] & 1)) t += a5[i];
		x += a5[i] * i;
	}
	z = (x + (t >> 1)) % 4, y = (1 << z);
	printf("%d\n", (6 * (y & 1) + y * (1 - (y & 1))) % 10);
	return 0;
}
```

---

## 作者：gaussrz (赞：9)

提供另一种思路。
这题的主要问题就在于如何消去运算时出现的10这个因数。我们知道10=2×5,所以只要成对地消去2和5这两个因数就可以了。

对于以0结尾的数很简单，只要把0去除就可以。
```cpp
//以下为除去0的函数
int noz(int a){
    while(true)
        if (a%10 == 0) a/=10;
    else return a;
}
```
但对于以5结尾的数，就需要做一些处理：

因为5的个数肯定小于2的个数，所以我们在乘上以5结尾的数时先把因数5除去（可能有多个）并记录个数，这样就避免了结果出现以0结尾的情况，可以放心地mod10.
```cpp
//以下为除去5的函数
int timer=0;//timer为表示5的个数的全局变量
int nf(int a){
    while(a%5==0){
        a/=5;
        timer++;
    }
    return a;
}
```

最后一步就是除去相应个数的2。因为2的个数大于5,所以在除去相应个数的2后，得到的结果一定为偶数。而要使一个偶数除以2之后仍为偶数，末尾会有如下的规律：2/2=6，4/2=2,6/2=8,8/2=4。
```cpp
//以下为除去2的函数
int b[5] = {0,6,2,8,4};
int nt(int a){
    return b[a/2];
}
```
除去2后得到的就是正确的答案。
最后放上main()供参考：
```cpp
#include<iostream>
using namespace std;
int main(){
    int N;
    cin >> N;
    int ans=1;
    for(int i=1;i<=N;i++){
        int ti=i;
        ti=nf(noz(ti));//除去5和10
        ans*=ti;
        ans%=10;
    }
    //除去2
    while(timer--){
        ans=nt(ans);
    }
    cout<<ans;
    return 0;
}
```
发现和第一的题解的处理方法有点像，但是思路还是不太一样（~~显然我的慢一些）~~

---

## 作者：QWsin (赞：8)

= =woc刚才打了一大篇点一下外面就没了  QAQ

方法吧  把2 5拿出来凑成一个10 然后扔了= =

手玩一下10的阶乘发现只有2 5能凑成十 然后质因数2的数量貌似一定比5多的样子

然后就把2全部拿出来 拿一个cnt加一

同时把5全部拿出来 拿一个cnt减一

直接在最开始加上%10好像可以更快些= =（那是不是%100更快？不知道）

最后必然是2会多出来一些 然后2的乘方是可以找规律的 打表即可

然后最坑的就是当我全部改好之后T了一个点

百思不得其解   各种看题解看别人代码= =

发现别人实际时间复杂度比我高都能A

然后你猜为什么-> ->

**因为我脑残用long long 谁知道常数这么大！！！！！**

代码
```cpp

#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int c2[]={6,2,4,8};
const int maxn=50000000;

int main()
{    
    int n;cin>>n;
    int cnt=0;// number of 2
    int fac=1;
    for(int i=2;i<=n;i++)
    {
        int tmp=i;
        while(tmp%10==0)tmp/=10;
        while(tmp%2==0)  tmp/=2,cnt++;
        while(tmp%5==0)  tmp/=5,cnt--;
        fac=fac*(tmp%10);
        fac%=10;
    }
    if(cnt)fac=fac*c2[cnt%4]%10;
    printf("%d\n",fac);
    return 0;
}

```

---

## 作者：redegg (赞：5)

希望管理员能撤销部分题解，那些题解并没有严格证明其做法的正确性，反而像是试出来的答案。

发现高赞题解都是通过直接$\%1000000$来做的？

但是简单想想，进位是可能一直进位到最高位的，所以直接取末尾的方案我是理解不了也证明不了正确性的。

但是，我们可以用质因数拆解来做这题，我们知道，末尾的$0$都来自于质因数$2$和$5$相乘，其他的质因数都无法乘出末尾为$0$简单证明下：

1.没有末尾为$0$的质数，不然就会存在10的因子，所以不可能有。

2.任何一个两个数相乘，最末尾的值一定是两个数的个位数相乘得到的数的个位数。

两个数的个位数相乘后的数字的个位数字是$0$的，要么某个的个位数本来就是$0$，要么就是偶数和$5$，由$(1)$已经知道末尾不是$0$，并且是质数的只有$2$和$5$了。

在$[1,n]$区间里$2$的质因数个数一定是多于$5$的。

所以我们只需要求出$5$的质因数个数，假设是$k$个，我们就在阶乘中约去$k$个$2$和$k$个$5$。

那么会不会超时呢？明确不会，$k$和$n$是同一数量级的，我们在阶乘过程中是均摊的$k$,所以总复杂度还是$O(n)$。

```
#include <bits/stdc++.h>
using namespace std;

int n;
long long ans=1;
long long last=10;
int main()
{
    scanf("%d",&n);
    int maxn=5;
    int k=0,p;
    while(1)
    {
        k+=n/maxn;
        maxn*=5;
        if(maxn>n)break;
    }
    p=k;
    for(int i=1;i<=n;i++)
    {
        int lins=i;
        while(lins%2==0&&p)
        {
            lins/=2;
            p--;
        }
        while(lins%5==0&&k)
        {
            lins/=5;
            k--;
        }
        ans=(ans*lins)%last;
    }
    printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：3lG5ht (赞：3)

**萌新第一次写题解，如有不当，烦请指出,谢谢！**

第一眼看到题目的时候，先想到**高精度**（高精度：又有我的事!）......

因为本人不喜(gao)欢(jing)敲(da)高(fa)精(hao)度，转念一想发现没必要用高(zhen)精(bang)度......



------------
转入正题：

设t2表示1~n中每个数的因数中2的个数总和（如：1~4中有3个2）

再设t5表示1~n中每个数的因数中5的个数总和（如：1~10中有3个5）

设ans表示去掉0后的值

设sum表示1~n所有数除以如果因数中有2和5，则把因数中的2和5直接÷掉后的乘积（当n=6时，sum=9）

则有 ans=2^(t2-t5)*sum

结果就是ans%10

证明：
~~由目测可得：~~

∵10=2*5

∴末尾的x个0一定是因为由x个2*5得来的

∵t2≧t5(最容易想到的是1~n中是2的倍数的个数一定不小于是5的倍数的个数）

∴x=t5，也就是留下（t2-t5）个2，即2^(t2-t5)

再乘上sum即可

于本人不想写求2^(t2-t5),便换了一种处理方法
（详见代码）

贴上代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,t2=0,t5=0;
ll ans=1;
int main(){
	cin>>n;
	int t2=0,t5=0;//t2表示当前已经删了的2的个数 
	for(int i=2;i<=n;i++){
		int j=i;//i不能乱用 
		while(j%5==0) {t5++;j/=5;}//求t5 
	}
	for(int i=2;i<=n;i++){
		int j=i;
		while(!(j%2)&&t2<t5){j/=2;t2++;}//如果这个数因数中有2,则删去,记录删了多少个,最多删t5个 
		while(!(j%5)) j/=5;//如果因数中有5,则删去 
	    ans=ans*j%10000000; //mod 10000000 可以使储存的结果不大且保证ans一定正确 
	}
	cout<<ans%10;
	return 0;
}

```


------------

本篇题解到此结束~

纪念本人洛谷AC100题
~~后的第2天~~


---

## 作者：huangxuhan (赞：2)

跟题解中大部分做法不太一样  
我是利用 n! 中质因子p的次数进行求解的  
相信大家都知道唯一分解定理，即正整数N被唯一分解为  
$N= \prod_ {}{p_i}^{c_i}$的形式，其中$p_i$为$N$的质因子  
而我们要求的就是$n!$中**5**和**2**这两个质因子的${c_i}$

------------

首先，我们抛出引理:   
$n!$中质因子p的$c_i$可通过以下计算得出  
$c_i=\sum_{i=1}^{∞}{}\frac{n}{{p^i}}$  

------------
可当成定理记住，也可以根据这篇博客参考理解[n!中质因子p的个数](https://www.cnblogs.com/zxhyxiao/p/8026280.html)  
接下来就很好解决，因为大家知道，$n!$中$5$的次数$2$少，所以我们计算$5$的出现次数（即为$n!$中末尾0的个数）$cnt0$在最后计算时候将含有$5$这个质因子的数全部除到不含$5$这个质因子，同时除去$cnt0$个2（在每个数乘之前除$2$直到除够$cnt0$或者这个数为奇数了为止），为了求最后一位，所以在每次乘完 $%10 $ 

------------
接下来是代码
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#define N 100010
#define ll long long
using namespace std;
int n;
bool v[100010];
int main()
{
	cin>>n;
	int cnt0=0,p=5;
	for (;p<=n;p*=5)
	{
		cnt0+=n/p;
	}
	int ans=1;
	for (int i=1;i<=n;i++)
	{
		int x=i;
		while(cnt0&&x%2==0)
		{
			cnt0--;
			x/=2;
		}
		while(x%5==0) x/=5;
		ans=(ll)(ans*x)%10;
	}
	cout<<ans<<endl;
}
```


---

## 作者：li20082008li (赞：2)

本题用存非零的最后一位的方法是有反例的，

因为当的之前乘积的非零最后一位和当前这个数的非零最后一位相乘，可能乘积 mod 10会等于0。

这时就要用到之前乘积的非零倒数第二位了，可是程序并没有存这个东西。

而且即使存了，那么倒数第2、3、4、5.......位都会有诸如倒数第一位的情况，那就变成是每相乘一次就要存储一次积，但这时就会超过计算机能存储的最大整数。

而且即使用高精度也会超时，[color=red]那么就需要考虑如何使这种情况“分离”出来单独处理。[/color]

-------------------------------以下为题解-------------------------------

既然要“分离”出这种情况，

那么就考虑有哪几个小于10大于0的两个自然数相乘的乘积 mod 10等于0。

不难发现只有2、4、6、8去乘5的乘积才会如此，而2、4、6、8的质因子中又都有2，

由此只要让一个数不能被5和2整除，剩下的没有2和5的因子的两个数再怎么相乘，都不可能让乘积 mod 10等于0了。


好了，那么现在开始考虑怎么处理。

设要运算的数为i（1<=i<=n），先去掉最右边所有的0。

接着设一个变量k，为i！去掉最右边所有的0并分解质因数后得出k个2，

以及一个变量ans，用来存储去掉2的因子的最终结果。

（div为整除的意思）

只要i mod 2=0 ，那么就让i div 2（消掉这个数为2的因子），并在k上加1；

接着只要i mod 5=0 ，那么就让i div 5（消掉这个数为5的因子），并在k上减1。

（大家可以换一个思路来理解，就是k被减掉j个1代表(i-1)！（已去掉最右边所有的0）\*i（同样已去掉最右边所有的0）的乘积最右边的0有j个，而题目要求是取最右边非0的数，那么这j个2和5就要“扔掉”，不用在最终结果上乘啦）

最后就在ans乘上处理完的数再 mod 10，这样这个数i就处理完了~


因为2的k（k>0）次方的最右边的非零位只可能是6、2、4、8[color=purple]

【分布规律为k mod 4=0时为6，k mod 4=1时为2，k mod 4=2时为4，k mod 4=3时为8】[/color]，

所以最终输出{k mod 4所对应的值乘上ans，得出的乘积再 mod 10}，结束~！

附上代码：

```delphi

program ex1134;
const
  a:array[0..3] of longint=(6,2,4,8);
var
  i,j,k,m,n,s,t:longint;
begin
  readln(n);
  s:=1;
  k:=0;
  for i:=2 to n do
  begin
    j:=i;
    while j mod 10=0 do
      j:=j div 10;
    while j mod 5=0 do
    begin
      j:=j div 5;
      k:=k-1;
    end;
    while j mod 2=0 do
    begin
      j:=j div 2;
      k:=k+1;
    end;
    s:=(s*j) mod 10;
  end;
  s:=s*a[k mod 4];    
//k不可能小于0，因为最终结果5的因子在题目所述的前提下一定不会比2的因子多= =
  writeln(s mod 10);
end.

```

---

## 作者：CZQ_King (赞：1)

发现有很多大佬的题解都是重复的解法，这里提供一种新思路，时间复杂度$O(\log_5n)$。

当时无聊，把前$14$的数都列了出来，试图寻找规律

但是很久都没有找出来，于是我去了[oeis.org](http://oeis.org/)直接去找这个数列

```
1,1,2,6,4,2,2,4,2,8,8,8,6,8
```

然后就看到这个：[link](http://oeis.org/search?q=1%2C1%2C2%2C6%2C4%2C2%2C2%2C4%2C2%2C8%2C8%2C8%2C6%2C8&language=english&go=Search)，然后发现~~这都是什么鬼全都看不懂~~，但是我在``FORMULA``中看到了他的生成公式：

```
The generating function for n>1 is as follows: for n = a_0 + 5 a_1 + 5^2 a_2 + ... + 5^N a_N (the expansion of n in base-5), then the last nonzero digit of n!, for n>1, is 6* product_{i=0..N} (a_i)! (2^(i a_i)) mod 10. - Greg Dresden (dresdeng(AT)wlu.edu), Feb 21 2006
```

也就是说，对于$n>1$，它的末尾数公式是他转成$5$进制后，每一个数的阶乘乘上二的$i$乘这个数次方。

文字有点难表达，举个$233$的例子吧：

首先转成五进制，但是不要翻转数组（这样会简单一点），转成之后就是``a[]={3,1,4,1}``，此时$l=4$（数组长度）。

然后套用公式：
$$ans=6\times\prod\limits_{i=0}^l(a[i]!\times2^{i\times a[i]})\mod10$$

虽然这里用到了阶乘，但是``a[i]``必定是小于$5$的数字，因此不会很大。~~反正我用python~~

另外，这个公式仅适用于$n>1$的情况，那么$0,1$需要特判。

py3中速度最快的代码：
```python
import math# 阶乘需要
n=int(input())
ans=1;l=0# 初始化
if n<2:# 特判
    print(1)
else:
    while n:# 一边转进制一边计算
        ans=ans*math.factorial(n%5)*2**(n%5*l)# 计算每一项
        l=l+1
        n=n//5
    print(ans*6%10)# 别忘了乘6和膜10
```


---

## 作者：tlylz99 (赞：1)

首先，过早模 $10$ 的话，$15!$ 这个地方，其他题解解释过了。

然后，我们可以考虑这样一个问题：

> 在 1~n 中，将数字分为5的倍数和非5的倍数。

显然，如果我们这样分类，5的倍数的那些数字的乘积其实就是

$$
\left\lfloor \frac{n}{5} \right\rfloor ! \times 5^{\lfloor n/5\rfloor}
$$

那么我们将这么多个5提取出来，和剩下非5倍数的因子2进行配对。这个阶乘本身的末尾非0位和处理过的非5倍数相乘，就是整个阶乘的末尾非0位了。

这样就产生了一个递归的做法。

时间复杂度 $T(n) = \sum_{i=0}^\infty \lfloor n/5^i \rfloor = O(n)$

在此基础上还可以进行一些其他的加速计算，比如我们把剩下一大截不用除以2的直接计算掉。这样可以大约做到 $O(\log n)$ 的时间复杂度吧。

```cpp
#include <bits/stdc++.h>
typedef long long lld;
using namespace std;

int get_non0(int n)
{
    if (n == 0) return 1;
    int ans1 = get_non0(n/5);
    int cnt2 = n/5;
    for (int i = 1; i <= n; i++)
    {
        if (i % 5 == 0) continue;
        int j = i;
        while (cnt2 && j % 2 == 0)
            cnt2--, j >>= 1;
        ans1 = (ans1 * j) % 10;
    }
    return ans1;
}

int main()
{
    int N;
    scanf("%d", &N);
    printf("%d\n", get_non0(N));
    return 0;
}
```

---

## 作者：a526955194 (赞：1)

这题数据太水了  O(n)算法加上一个偌大的常数(div 与 mod很慢)都可以过 建议增强

正解是楼下曹彦晨大神讲的方法  但是讲的似乎并不清楚 于是鄙人再次阐述一遍


我们很容易发现，阶乘的结果会是一个偶数(0！与1！除外，我也非常惊讶为什么数据里没有0！)，即数的末尾只可能是（2,4,6,8）（屏蔽0），经过观察之后，我们可以发现这样一个规律：（2,4,6,8）任意一个数乘6之后，其最后一位是不会变的，下面我们拿4来举例，ans表示最后一位：

ans(4\*10)=ans(4\*6)=ans(4\*16) （最后一位的结果只与两个数的末位有关）

可以推得：ans(4\*2\*5)=ans(4\*2\*8)

这是一个重要的结论，当乘5的时候，我们可以用8来替代，这样就不会出现0了

可是还有一个问题：我们应该怎样替代呢？如果仅仅是这样的话复杂度还是O（n）

答案是每做一次  我们可以将n/5，得到的结果是5的乘的次数，也就是我们需要代替成乘8的次数

我们发现，多次乘8肯定是要出事的，经过观察发现，多次乘8的末尾变化是有规律的：

8,4,2,6 四次一循环

这样的话就很简单了：

附上代码：

```cpp

#include <cstdio>
using namespace std;
int n,w,i;
int a[4]={6,8,4,2};
int main()
{
    scanf("%d",&n);
    w=1;
    while (n>0)
    {
        for (i=1; i<=n%10; i++)
            if (i!=5) w=w*i%10;
        n=n/5;
        w=w*a[n%4]%10;
    }
    printf("%d",w);
    return 0;
}

```
吐槽一下，下面的朴素代码..我很多东西看不懂..似乎多弄了很多东西

---

## 作者：clyoyo (赞：1)

这道题首先也是想到模拟，也用了楼下几楼的题解中的模拟方法，但最后一个点一直TLE（P党伤不起）。

看到了大神的算法，感觉楼下的思路描述太过简洁，思考n久终于顿悟，思路如下：

N！的末位0是来自于所有乘数的因数5和2相乘，有多少个因数5就有多少个末位0（因数2个数远大于因数5个数）

（1）先将所有含有因数5的乘数（5,10,15,20，....）跳过不乘，先算所有不含因数5的数的乘积最后一位，

发现除了初始1以外有规律可循：

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ...

1 2 6 4 X 4 8 4 6  X  6   2   6   4   X   4   8   4   6   X

每10项为一个循环

（2）再来计算乘5,10,15,20..... （共n div 5个）

我们将所有因数5提取出来，就有5^(n div 5)\*1\*2\*3\*4\*...\*n div 5

先来解决5^(n div 5)，乘以一个5，就会有一个2和它组合成0，所以乘以5相当于除以2

2的尾数为 2,4,8,6,2,4,8,6....4个数一个循环，除以2就前移一位，也就相当于乘以8（后移3位）

所以乘以5的尾数和乘以8的尾数是一样的，4个一循环

再来解决1\*2\*3....\*n div 5，显然可以递归解决！

再来看代码：


```cpp
var i,j,n,ans:longint;
    ba:array[0..3] of longint=(6,8,4,2);
    a:array[0..9] of longint=(1,6,2,6,4,4,4,8,4,6);//第5个数应该是相等于第4个
begin
   readln(n);
   if n=1 then begin writeln(1);halt;end;//1特判
   ans:=1;
   while n>0 do
   begin
     ans:=ans*a[n mod 10];//10个一组有规律
     n := n div 5;//n缩小规模
     ans := ans*ba[n mod 4] mod 10;//n个5相乘，4个一组有规律
   end;
   writeln(ans);
end.

```

---

## 作者：Ghost_lzy (赞：1)

把含有多少个5求出来（tot），sum=tot(记录要除多少个2)然后在从1-n遍历的时候，如果i（1<=i<=n）整除2的话就除2直到除不尽或者sum=0(没有除的了)，这个时候就把末尾的0全部去掉了，然后强行膜10（滑稽）；（x[i][j]装的是i\*j的末尾的数，1<=i<=9,1<=j<=9）

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[10][10]={0},n;
int tot=0;//先算出有多少个5（0） 
void init()
{
    for(int i=1;i<=9;i++)
     for(int j=1;j<=9;j++)
     {
         x[i][j]=(i*j)%10;
     }
}
void find()
{
    int w=n;
    while(w) 
    {
        tot=tot+w/5;
        w/=5;
    }
}
int main()
{
    scanf("%d",&n);
    init();
    find();
    int ans=1;
    int sum=tot;//记录2的 
    for(int i=1;i<=n;i++)
    {  int p=i;
        while(p%5==0)
        {
            tot--;
            p/=5;
        }
        while(p%2==0&&sum)
        {
            p/=2;
            sum--;
        }
        ans=x[ans][p%10];
    }
    printf("%d",ans);
}

```

---

## 作者：Uni_Tune (赞：1)

这道题如果明目张胆地暴力是肯定WA的。

高精这种方法的确可取，但是本人经过思考，认为用**模拟**同样可以解决。

首先，最右边的第一个非零数即去掉0后的个位数。而0即是10，而10=2\*5，经过试验，阶乘中2的个数足够，统计5的个数即可。

所以，本人先用sum只储存个位数，当遇到5的倍数时，除去所有5，并统计个数。

但最后，问题来了，剩下的2如何除去呢？同样的思路：只用个位数，下面是2^n的个位数规律：

2     4     8     6     2     4     8     6.......

那么除去的思路也是一样的，倒推即可。具体请见代码：

```cpp
#include<iostream>
using namespace std;
int n,sum=1,ans=0;
int main()
{
    cin>>n;
    int i,j,k;
    for(i=1;i<=n;i++)
    {
        if(sum>10)//只用各位
        {
            sum%=10;
        }
        if(i%5==0)
        {
            k=i;
            while(k%5==0)//除去5并统计其个数
            {
                k/=5;
                ans++;
            }
        } 
        else
        {
            k=i;
        }
        sum*=k;
    } 
    sum%=10;
    for(i=1;i<=ans;i++)//将2全部除去，同样用个位思想，为了思路明确，使用各个数特判
    {
        if(sum==2)
        {
            sum=6;
            continue;
        } 
        if(sum==4) 
        {
            sum=2;
            continue;
        }
        if(sum==8) 
        {
            sum=4;
            continue;
        }
        if(sum==6)
        {
            sum=8;
            continue;
        }
    } 
    cout<<sum;
    return 0;
}
```

---

## 作者：sqc1999 (赞：0)

呵呵，前面两位大神已经说得很详细了，实质上就是计算1~i中所有数的因子2、5的数量和，并在计算时把他们除掉，最后再让2的数量和5的数量相互抵消后，把剩余的2或剩余的5再乘上去，这样就避免了计算时末位乘出0的情况。

既然没有C++的代码，那我就来放一份吧。

```cpp

#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int n, c2 = 0, c5 = 0, e = 1;
    cin >> n;
    for (int i = 2; i <= n; i++)
    {
        int t = i;
        while (t % 10 == 0) t /= 10;
        while (t % 2 == 0)
        {
            t /= 2;
            c2++;
        }
        while (t % 5 == 0)
        {
            t /= 5;
            c5++;
        }
        e *= t;
        e %= 10;
    }
    if (c2 > c5)
    {
        for (int i = 1; i <= c2 - c5; i++)
        {
            e *= 2;
            e %= 10;
        }
    }
    else if (c5 > c2)
    {
        for (int i = 1; i <= c5 - c2; i++)
        {
            e *= 5;
            e %= 10;
        }
    }
    cout << e;
}

```

---

## 作者：Celebrate (赞：0)

这一题n有五千万，也不是特别大，我就直接暴力打了一遍

但是，这一题有一个细节，就是么次mod不能小，因为比如说

15！=1307674368000代码输出2而不是8，原因是最后应是

2X15=180,但是这样做最后是2X15=30,所以要mod大一些，

由于i可能很大，说以mod一亿会比较保险（用longlong)

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans=1,i,n;
int main()
{
	scanf("%lld",&n);//输入 
	for(i=2;i<=n;i++)
	{
		ans=ans*i;
		while(ans%10==0) ans/=10;//把尾数0全部去掉 
		ans%=10000000000;//为了防止炸掉 
	}
	printf("%lld\n",ans%10);//输出 
	return 0;
}
```

---


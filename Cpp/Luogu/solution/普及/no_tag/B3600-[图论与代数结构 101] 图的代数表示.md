# [图论与代数结构 101] 图的代数表示

## 题目描述

给定一张 $n$ 个点 $m$ 条边的图，**有可能存在重边和自环**。请你给出这张图所有的代数表示。

## 说明/提示

对于所有数据，满足 $1 \le n \le 300$，$1 \le m \le 300$，$1 \le 边权 \le 32768$。

**细节提示：**

1.无向图中一些数组可能需要 $2 m$ 的长度，请仔细检查以免数组开小。

2.无向图中如果存在自环，则在邻接表和正向表中都需要将这条边输出两次，但不影响邻接矩阵或权矩阵的输出。

3.逆向表中对于连向一点的边也要按输入顺序输出而不是边权大小顺序。

4.无向带权图中每条非自环边都会修改权矩阵中两个位置。

5.无法通过时可以通过构造有向/无向、带权/不带权、有/无自环、有/无重边的小数据来检查代码。


##### 样例一解释

第 $1$ 行至第 $3$ 行是邻接矩阵；

第 $4$ 行至第 $6$ 行是关联矩阵；

第 $7$ 行至第 $9$ 行是邻接表；

第 $10$ 行至第 $11$ 行是正向表。

##### 样例二解释

第 $1$ 行至第 $2$ 行是邻接表；

第 $3$ 行至第 $5$ 行是正向表；

第 $6$ 行至第 $8$ 行是逆向表。

## 样例 #1

### 输入

```
3 3 0 0
2 3
1 3
1 2```

### 输出

```
0 1 1
1 0 1
1 1 0
0 1 1
1 0 1
1 1 0
3 2
3 1
2 1
1 3 5 7
3 2 3 1 2 1```

## 样例 #2

### 输入

```
3 3 1 1
3 1 5
2 2 4
3 1 3```

### 输出

```

2 4
1 5 1 3
1 1 2 4
2 1 1
4 5 3
1 3 4 4
3 3 2
5 3 4```

## 样例 #3

### 输入

```
3 3 0 1
1 3 5
2 2 3
2 3 1```

### 输出

```
0 0 5
0 3 1
5 1 0
3 5
2 3 2 3 3 1
1 5 2 1
1 2 5 7
3 2 2 3 1 2
5 3 3 1 5 1```

## 样例 #4

### 输入

```
4 3 0 1
3 3 5
2 4 6
2 4 7```

### 输出

```

4 6 4 7
3 5 3 5
2 6 2 7
1 1 3 5 7
4 4 3 3 2 2
6 7 5 5 6 7```

# 题解

## 作者：Daidly (赞：147)

题目较简单，但代码较长。

### 邻接矩阵和权矩阵

两者差不多，只不过一个存是否有边 $(0,1)$，一个存边权。

使用一个二维数组 `a` 来表示。

若为无权图，`a[u][v]=1` 表示存在 $u$ 到 $v$ 的边，`a[u][v]=0` 表示不存在。

若为赋权图，`a[u][v]=d` 表示存储 $u$ 到 $v$ 的边的边权 $d$。

若为无向图，存两次即可。

#### 复杂度

查询是否存在某条边：$O(1)$。

遍历一个点的所有出边：$O(n)$。

遍历整张图：$O(n^2)$。

空间复杂度：$O(n^2)$。

#### 判断重边：

```cpp
bool f1=0;
if(a[u][v]>0)f1=1;
```
在赋值 `a[u][v]` 前先查看 `a[u][v]` 之前是否被赋值过，若赋值过，则是有重边。

#### 邻接矩阵和权矩阵代码：

```cpp
void work1(){
    for(int i=1;i<=n;++i){
    	for(int j=1;j<=n;++j){
    		cout<<a[i][j]<<" ";
		}cout<<endl;
	}
}
```

### 关联矩阵

使用一个二维数组 `b` 来表示。

关联矩阵即用一个矩阵来表示各个点和每条边之间的关系，所以当图不是赋权图且无自环时，可以用关联矩阵表示。

#### 对于无向图：

第 $i$ 条边 $(u,v)$ 可表示为：

```cpp
b[u][i]=1;
b[v][i]=1;
```
若 `b[u][i]=1`，表示边 $i$ 上有点 $u$。

若 `b[u][i]=0`，表示边 $i$ 和点 $u$ 不相关联。

#### 对于有向图：

第 $i$ 条边 $(u,v)$ 可表示为：

```cpp
b[u][i]=1;
b[v][i]=-1;
```

若 `b[u][i]=1`，表示边 $i$ 离开点 $u$。

若 `b[u][i]=-1`，表示边 $i$ 进入点 $u$。

若 `b[u][i]=0`，表示边 $i$ 和点 $u$ 不相关联。

#### 判断自环：

```cpp
bool f2=0;
if(u==v)f2=1;
```
看 $u$ 和 $v$ 是否是同一个点，若是，则有自环。

#### 关联矩阵代码：

```cpp
void work2(){
    for(int i=1;i<=n;++i){
    	for(int j=1;j<=m;++j){
    		cout<<b[i][j]<<" ";
		}cout<<endl;
	}
}
```

### 邻接表

#### 对于无权图：

使用一个动态数组 `vector<int>c1[MAXN];` 来表示。

对于无向图:

```cpp
c1[u].push_back(v);
c1[v].push_back(u);
```

对于有向图：

```cpp
c1[u].push_back(v);
```

#### 对于赋权图：

由于要存两个数，考虑使用 `pair<int,int>`，使用一个动态数组 `vector<pair<int,int> >c2[MAXN];` 来表示。

其中 `c2[i][j].first` 表示第 $i$ 个点的第 $j$ 条边的对应点，`c2[i][j].second` 表示第 $i$ 个点的第 $j$ 条边的边权。

对于无向图:

```cpp
c2[u].push_back(make_pair(v,d));
c2[v].push_back(make_pair(u,d));
```

对于有向图：

```cpp
c2[u].push_back(make_pair(v,d));
```
#### 邻接表代码：

```cpp
void work3(){
	if(type2==0){
		for(int i=1;i<=n;++i){
			for(int j=0;j<c1[i].size();++j){
				cout<<c1[i][j]<<" ";
			}cout<<endl;
		}
	}else{
		for(int i=1;i<=n;++i){
			for(int j=0;j<c2[i].size();++j){
				cout<<c2[i][j].first<<" "<<c2[i][j].second<<" ";
			}cout<<endl;
		}
	}
}
```
### 正向表

用三个数组 `A`、`B`、`Z` 来表示。

对于 `A` 数组，$A[1]=1$，$A[i]=A[i-1]+c[i-1].size()$。

其中，$c[i-1].size()$ 表示第 $i-1$ 个点的连点个数。

注意 `A` 数组的点要到第 $i+1$ 个。

对于 `B`、`Z` 数组，设长度为 $num$，初始为 $0$。

`B` 数组负责存对应点，`Z` 数组负责存对应边权，长度一样（按照点的顺序和存对应点的顺序），可结合代码理解。

#### 正向表代码：

```cpp
void work4(){
	num=0,A[1]=1;
	if(type2==0){
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c1[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c1[i].size();++j){
				B[++num]=c1[i][j];
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
	}else{
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c2[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c2[i].size();++j){
				B[++num]=c2[i][j].first;
				Z[num]=c2[i][j].second;
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<Z[i]<<" ";
		}cout<<endl;
	}
}
```

### 逆向表

对于无向图，逆向表与正向表相同，不用输出。

#### 对于有向图：

顾名思义，“逆”就是把顺序逆过来。

- 对于无权图，使用一个动态数组 `vector<int>c3[MAXN];` 来表示。

例如：边 $(u,v)$，可存为：`c3[v].push_back(u);`。

- 对于赋权图，使用一个动态数组 `vector<pair<int,int> >c4[MAXN];` 来表示。

例如：边 $(u,v)=d$，可存为：`c4[v].push_back(make_pair(u,d));`。

其余与正向表类似，可结合代码理解。

#### 逆向表代码：

```cpp
void work5(){
	num=0,A[1]=1;
	if(type2==0){
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c3[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c3[i].size();++j){
				B[++num]=c3[i][j];
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
	}else{
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c4[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c4[i].size();++j){
				B[++num]=c4[i][j].first;
				Z[num]=c4[i][j].second;
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<Z[i]<<" ";
		}cout<<endl;
	}
}
```

### 写在最后

- 注意 $1$：正向表和逆向表的 `B`、`Z` 两个数组要开两倍 `MAXN` 大小，代码简用 `MAXN<<1` 来表示。

- 注意 $2$：当一个点邻接表中没有连边时，也要换行，如样例二，应该是：

```cpp

2 4
1 5 1 3
1 1 2 4
2 1 1
4 5 3
1 3 4 4
3 3 2
5 3 4
```

### 总体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 305
int n,m,u,v,d;
int a[MAXN][MAXN];
int b[MAXN][MAXN];
vector<int>c1[MAXN];
vector<pair<int,int> >c2[MAXN];
vector<int>c3[MAXN];
vector<pair<int,int> >c4[MAXN];
int A[MAXN],B[MAXN<<1],num,Z[MAXN<<1];
bool type1,type2,f1,f2;
void work1(){
    for(int i=1;i<=n;++i){
    	for(int j=1;j<=n;++j){
    		cout<<a[i][j]<<" ";
		}cout<<endl;
	}
}
void work2(){
    for(int i=1;i<=n;++i){
    	for(int j=1;j<=m;++j){
    		cout<<b[i][j]<<" ";
		}cout<<endl;
	}
}
void work3(){
	if(type2==0){
		for(int i=1;i<=n;++i){
			for(int j=0;j<c1[i].size();++j){
				cout<<c1[i][j]<<" ";
			}cout<<endl;
		}
	}else{
		for(int i=1;i<=n;++i){
			for(int j=0;j<c2[i].size();++j){
				cout<<c2[i][j].first<<" "<<c2[i][j].second<<" ";
			}cout<<endl;
		}
	}
}
void work4(){
	num=0,A[1]=1;
	if(type2==0){
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c1[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c1[i].size();++j){
				B[++num]=c1[i][j];
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
	}else{
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c2[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c2[i].size();++j){
				B[++num]=c2[i][j].first;
				Z[num]=c2[i][j].second;
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<Z[i]<<" ";
		}cout<<endl;
	}
}
void work5(){
	num=0,A[1]=1;
	if(type2==0){
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c3[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c3[i].size();++j){
				B[++num]=c3[i][j];
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
	}else{
        for(int i=2;i<=n+1;++i){
		    A[i]=A[i-1]+c4[i-1].size();
	    }
		for(int i=1;i<=n;++i){
			for(int j=0;j<c4[i].size();++j){
				B[++num]=c4[i][j].first;
				Z[num]=c4[i][j].second;
			}
		}
		for(int i=1;i<=n+1;++i){
			cout<<A[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<B[i]<<" ";
		}cout<<endl;
		for(int i=1;i<=num;++i){
			cout<<Z[i]<<" ";
		}cout<<endl;
	}
}
int main(){
	cin>>n>>m>>type1>>type2;
	if(type2==0){
	    for(int i=1;i<=m;++i){
		    cin>>u>>v;
		    if(a[u][v]>0)f1=1;
		    if(u==v)f2=1;
		    if(type1==0){
		    	a[u][v]=1;
		    	a[v][u]=1;
	    	    b[u][i]=1;
	    	    b[v][i]=1;
		    	c1[u].push_back(v);
	    	    c1[v].push_back(u);
		    }else{
		    	a[u][v]=1;
		    	b[u][i]=1;
	    	    b[v][i]=-1;
		    	c1[u].push_back(v);
		    	c3[v].push_back(u);
	    	}
	    }
	    if(f1==0)work1();
	    if(f2==0)work2();
	    work3();
	    work4();
	    if(type1==1)work5();
	}else{
		for(int i=1;i<=m;++i){
			cin>>u>>v>>d;
			if(a[u][v]>0)f1=1;
			if(type1==0){
				a[u][v]=d;
				a[v][u]=d;
	    	    c2[u].push_back(make_pair(v,d));
	    	    c2[v].push_back(make_pair(u,d));
			}else{
				a[u][v]=d;
				c2[u].push_back(make_pair(v,d));
				c4[v].push_back(make_pair(u,d));
			}
		}
		if(f1==0)work1();
		work3();
		work4();
		if(type1==1)work5();
	}
	return 0;
}
```

如果您看懂了或是对您有帮助，请点一个小小的赞吧，谢谢！

---

## 作者：hensier (赞：14)

## 定位

本题虽说是一道技术含量并不高的基础题，但是易错点较多，可以称得上是一道模拟题。

## 图的代数表示方法归类

|名称|规模|用途|适用对象|值域|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|邻接矩阵|$n$ 行 $n$ 列|表示两个点 $u,v$ 是否直接相连|无重边的无权图|$[0,1]$|
|权矩阵|$n$ 行 $n$ 列|保存两个点 $u,v$ 之间的边权大小|无重边的赋权图|$[0,d]$|
|关联矩阵|$n$ 行 $m$ 列|表示两个点 $u,v$ 及其所在边 $i$ 之间的关系|无自环的无权图|$\{-1,0,1\}$|
|邻接表|$n$ 行|保存与一个点 $u$ 相连的所有点及其权值（如果为赋权图）|任意图||
|正向表/逆向表|$2 \sim 3$ 行|减少空间代价，方便遍历全图|任意图|$\forall A_i \in [1,m+1]$，$\forall B_i \in [1,n]$，$\forall Z_i \in [1,d]$|

## 重边

重边表示图中的同一条边出现两次或两次以上，如一个无向图中出现边 $(1,4)$ 和 $(4,1)$。

判断方式：

```cpp
bool multiple; // 表示是否存在重边
if(wgt[u][v])multiple=true; // 若该边已经出现过，则说明邻接矩阵/权矩阵已被修改，因此可用这种方式判断
```

## 自环

自环表示图中有至少一条边的起点 $u$ 和终点 $v$ 相同，如图中出现边 $(1,1)$。

判断方式：

```cpp
bool loop; // 表示是否存在自环
if(u==v)loop=true;
```

## 邻接矩阵、权矩阵

- 【时间复杂度】$\mathcal O(m)$
- 【空间复杂度】$\mathcal O(n^2)$

现有两个结点 $u$ 和 $v$（有向图中方向为 $u \to v$）。

邻接/权矩阵为一个规模为 $n \times n$ 的数组，下列称之为 $\text{wgt}$。

如果 $u,v$ 之间存在一条边能够将二者之间相连，那么规定 $\text{wgt}_{u,v}=1$（无权图），$\text{wgt}_{u,v}=d$（赋权图）；否则 $\text{wgt}_{u,v}=0$。

对于一个无权图中的两个直接相连的点 $u,v$，其对应元素的值为 $1$，因此我们可以把邻接矩阵视为权为 $0$ 或 $1$ 的权矩阵。

![](https://cdn.luogu.com.cn/upload/image_hosting/zvwf0sow.png)

以上述无向图为例，我们不难发现：

|结点编号|与之相连的结点|
| :----------: | :----------: |
|$1$|$2,4,5$|
|$2$|$1,3,4$|
|$3$|$2$|
|$4$|$1,2$|
|$5$|$1$|

则得到的邻接矩阵为：

$$\left[\begin{matrix}
0 & 1 & 0 & 1 & 1 \cr
1 & 0 & 1 & 1 & 0 \cr
0 & 1 & 0 & 0 & 0 \cr
1 & 1 & 0 & 0 & 0 \cr
1 & 0 & 0 & 0 & 0 \cr
\end{matrix}\right]
$$

因此，我们可以新建一个 $n \times n$ 的二维数组 $\text{wgt}$。然后，对于每条边所连接的两个结点 $u,v$，将 $\text{wgt}_{u,v}$ 进行赋值即可（具体赋值内容取决于图的类型）：

```cpp
int wgt[305][305]; // wgt 是 weight（权值）的缩写
void init1(int u,int v,int d=1) // 当类型为无权图的时候，默认权值 d 的大小为 1
{
    wgt[u][v]=d;
    if(!type1)wgt[v][u]=d; // 如果为无向图则还需进行反向操作
}
```

## 关联矩阵

- 【时间复杂度】$\mathcal O(m)$
- 【空间复杂度】$\mathcal O(nm)$

现有一条边 $i$ （$i$ 必须与该边的输入次序相同）以及该条边所连接的结点 $u$ 和 $v$（有向图中方向为 $u \to v$）。

关联矩阵为一个规模为 $n \times m$ 的数组，下列称之为 $\text{inc}$。我们分两种情况对其进行赋值：

- 如果图为有向图，则规定 $\text{inc}_{u,i}=1$，$\text{inc}_{v,i}=-1$。
- 如果图为无向图，则规定 $\text{inc}_{u,i}=\text{inc}_{v,i}=1$。

以下面的有向图为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/5kcwrwbe.png)

我们将各边的情况整理出来：

|边的编号|起点边 $u$|终点边 $v$|赋值|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$1$|$2$|$\text{inc}_{1,1}=1$，$\text{inc}_{2,1}=-1$|
|$2$|$1$|$3$|$\text{inc}_{1,2}=1$，$\text{inc}_{3,2}=-1$|
|$3$|$2$|$3$|$\text{inc}_{2,3}=1$，$\text{inc}_{3,3}=-1$|
|$4$|$2$|$4$|$\text{inc}_{2,4}=1$，$\text{inc}_{4,4}=-1$|
|$5$|$3$|$5$|$\text{inc}_{3,5}=1$，$\text{inc}_{5,5}=-1$|
|$6$|$4$|$5$|$\text{inc}_{4,6}=1$，$\text{inc}_{5,6}=-1$|

整理后得到关联矩阵：

$$\left[\begin{matrix}
1 & 1 & 0 & 0 & 0 & 0 \cr
-1 & 0 & 1 & 1 & 0 & 0 \cr
0 & -1 & -1 & 0 & 1 & 0 \cr
0 & 0 & 0 & -1 & 0 & 1 \cr
0 & 0 & 0 & 0 & -1 & -1 \cr
\end{matrix}\right]
$$

与邻接矩阵/权矩阵相似，我们可以直接利用题目中输入的数据得到关联矩阵：

```cpp
int inc[305][305]; // inc 是 incidence（关联）的缩写
void init2(int u,int v,int i)
{
    if(type1)
    {
        inc[u][i]=1;
        inc[v][i]=-1;
    }
    else inc[u][i]=inc[v][i]=1;
}
```

## 邻接表

- 【时间复杂度】$\mathcal O(m)$
- 【空间复杂度】$\mathcal O(n^2)$

现有一个结点 $u$。设 $V$ 为所有与 $u$ 直接相连的点 $v$ 的集合（有向图中方向必须为 $u \to v$）。

邻接表的保存同样分两种情况：

- 如果图为无权图，则对于每个 $u$ 只需存储集合 $V$ 中所有点 $v$ 即可。
- 如果图为赋权图，则对于集合中每个点 $v$ 需要保存两个元素，分别是 $v$ 和边 $u \to v$ 的权值大小。

例：

![](https://cdn.luogu.com.cn/upload/image_hosting/muze7hf4.png)

|起点 $u$|终点 $v$|集合 $V$|
| :----------: | :----------: | :----------: |
|$1$|$3,4$|$\{(3,1),(4,3)\}$|
|$2$|$3$|$\{(3,4)\}$|
|$3$|$4$|$\{(4,6)\}$|
|$4$|无|$\varnothing$|

对于每个起点 $u$，我们不妨用一个 `vector` 类型来存储集合 $V$ 内的内容，这样会方便维护一些。

代码如下：

```cpp
vector<pair<int,int>>adj[305]; // adj 为 adjacency（邻接）的缩写
void init3(int u,int v,int d=1) // 每个 pair 中第一个元素存储结点 v，第二个存储权值（若为无权图则为 1）
{
    adj[u].push_back(make_pair(v,d));
    if(!type1)adj[v].push_back(make_pair(u,d));
}
```

输出的时候需要注意，如果对于一个结点 $u$，集合 $V$ 为空，则**需要输出空行**。这一点题目中并没有描述清楚。

## 正向表、逆向表

- 【时间复杂度】$\mathcal O(n+m)$
- 【空间复杂度】$\mathcal O(n^2)$

例：

![](https://cdn.luogu.com.cn/upload/image_hosting/02cdfu7h.png)

正向表中的 $A$ 向量相当于做了一个前缀和，把每个结点 $i$ 所直接连接的结点个数进行加和。这沿用了邻接表中存储的数据，其中结点个数即为 $\text{card(adj}_i)$。

规定 $A_1=1$，则对于结点 $i \in [1,n]$：
$$A_{i+1}=A_i+\text{card(adj}_i)$$

对于上例而言：

|结点编号|集合 $\text{adj}_i$ 中的元素数量|$A_i$ 的值
| :----------: | :----------: | :----------: |
|$1$|$2$|$1$|
|$2$|$2$|$1+2=3$|
|$3$|$0$|$3+2=5$|
|$4$|$0$|$5+0=5$|

特别地，$A_5=5+0=5$。

而 $B$ 向量保存每个结点 $u$ 所直接连接的所有结点 $v$，$Z$ 向量则保存权值。因此正向表的处理方式与邻接表有相似之处：

|结点编号|$B$ 向量新增元素|$Z$ 向量新增元素|$B$ 向量|$Z$ 向量|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1$|$2,3$|$5,6$|$\{2,3\}$|$\{5,6\}$|
|$2$|$3,4$|$3,1$|$\{2,3,3,4\}$|$\{5,6,3,1\}$|
|$3$|无|无|$\{2,3,3,4\}$|$\{5,6,3,1\}$|
|$4$|无|无|$\{2,3,3,4\}$|$\{5,6,3,1\}$|

代码如下：

```cpp
void query4() // 该操作需在输入全部完成后进行
{
    A[1]=1; // 初始化 A[1]=1
    cnt=0; // 初始化 B,Z 向量初始下标为 0
    for(int i=1;i<=n;++i)
    {
        A[i+1]=A[i]+adj[i].size(); // 前缀加和
        for(pair<int,int> j:adj[i]) // 取出邻接表中的元素
        {
            B[++cnt]=j.first;
            if(type2)Z[cnt]=j.second; // 只有赋权图才需要记录权值
        }
    }
    for(int i=1;i<=n+1;++i)printf("%d ",A[i]);
    putchar('\n');
    for(int i=1;i<=cnt;++i)printf("%d ",B[i]);
    putchar('\n');
    if(type2)
    {
        for(int i=1;i<=cnt;++i)printf("%d ",Z[i]);
        putchar('\n');
    }
}
```

逆向表则与正向表极为相似，其唯一不同的就是改变了原来所有边的顺序，即 $u \to v$ 变为 $v \to u$。在进行反转之后，逆向表就与原来的正向表毫无区别。

因此，我们在处理邻接表时，可以新定义一个 `vector` 数组 $\text{rev}$ 来把反转后的内容进行存储，同时仿照正向表的处理方式进行操作：

```cpp
// 修改部分（开始）
vector<pair<int,int>>adj[305],rev[305];
void init3(int u,int v,int d=1)
{
    adj[u].push_back(make_pair(v,d));
    if(!type1)adj[v].push_back(make_pair(u,d));
    else rev[v].push_back(make_pair(u,d));
}
// 修改部分（结束）
void query5()
{
    A[1]=1;
    cnt=0;
    for(int i=1;i<=n;++i) //这里唯一不同的就是把之前的 adj 改为 rev
    {
        A[i+1]=A[i]+rev[i].size();
        for(pair<int,int> j:rev[i])
        {
            B[++cnt]=j.first;
            if(type2)Z[cnt]=j.second;
        }
    }
    for(int i=1;i<=n+1;++i)printf("%d ",A[i]);
    putchar('\n');
    for(int i=1;i<=cnt;++i)printf("%d ",B[i]);
    putchar('\n');
    if(type2)
    {
        for(int i=1;i<=cnt;++i)printf("%d ",Z[i]);
        putchar('\n');
    }
}
```

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,wgt[305][305],inc[305][305],A[305],B[90005],Z[90005],type1,type2;
bool multiple,loop;
vector<pair<int,int>>adj[305],rev[305]; // C++11 以下版本中尖括号之间要加空格
void init1(int u,int v,int d=1)
{
    wgt[u][v]=d;
    if(!type1)wgt[v][u]=d;
}
void init2(int u,int v,int i)
{
    if(type1)
    {
        inc[u][i]=1;
        inc[v][i]=-1;
    }
    else inc[u][i]=inc[v][i]=1;
}
void init3(int u,int v,int d=1)
{
    adj[u].push_back(make_pair(v,d));
    if(!type1)adj[v].push_back(make_pair(u,d));
    else rev[v].push_back(make_pair(u,d));
}
void query1() // 输出邻接矩阵/权矩阵
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)printf("%d ",wgt[i][j]);
        putchar('\n');
    }
}
void query2() // 输出关联矩阵
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)printf("%d ",inc[i][j]);
        putchar('\n');
    }
}
void query3() // 输出邻接表
{
    for(int i=1;i<=n;++i)
    {
        for(pair<int,int> j:adj[i])
        {
            printf("%d ",j.first);
            if(type2)printf("%d ",j.second);
        }
        putchar('\n'); // 考虑了空行的情况
    }
}
void query4() // 输出正向表
{
    A[1]=1;
    cnt=0;
    for(int i=1;i<=n;++i)
    {
        A[i+1]=A[i]+adj[i].size();
        for(pair<int,int> j:adj[i])
        {
            B[++cnt]=j.first;
            if(type2)Z[cnt]=j.second;
        }
    }
    for(int i=1;i<=n+1;++i)printf("%d ",A[i]);
    putchar('\n');
    for(int i=1;i<=cnt;++i)printf("%d ",B[i]);
    putchar('\n');
    if(type2)
    {
        for(int i=1;i<=cnt;++i)printf("%d ",Z[i]);
        putchar('\n');
    }
}
void query5() // 输出逆向表
{
    A[1]=1;
    cnt=0;
    for(int i=1;i<=n;++i)
    {
        A[i+1]=A[i]+rev[i].size();
        for(pair<int,int> j:rev[i])
        {
            B[++cnt]=j.first;
            if(type2)Z[cnt]=j.second;
        }
    }
    for(int i=1;i<=n+1;++i)printf("%d ",A[i]);
    putchar('\n');
    for(int i=1;i<=cnt;++i)printf("%d ",B[i]);
    putchar('\n');
    if(type2)
    {
        for(int i=1;i<=cnt;++i)printf("%d ",Z[i]);
        putchar('\n');
    }
}
void solve()
{
    if(!multiple)query1(); // 邻接矩阵/权矩阵适用于无重边的图
    if(!type2&&!loop)query2(); // 关联矩阵适用于无自环的无权图
    query3(); // 邻接表
    query4(); // 正向表
    if(type1)query5(); // 若是有向图则输出逆向表
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&type1,&type2);
    for(int i=1,u,v,d;i<=m;++i)
    {
        scanf("%d%d",&u,&v);
        if(u==v)loop=true;
        if(wgt[u][v])multiple=true;
        if(type2) // 权矩图
        {
            scanf("%d",&d);
            init1(u,v,d);
            init3(u,v,d);
        }
        else // 无权图
        {
            init1(u,v);
            init3(u,v);
        }
        init2(u,v,i);
    }
    solve();
    return 0;
}
```

---

## 作者：Hughpig (赞：8)

## 前言

图论基础练习题，一道中模拟，细节较多。

现在好像没有每个计算进行一次，不在主函数内特判分别计算的题解，我来发一篇。

此题在我做的时候数据很水，所有数据点的 $n=m$。因此如果以下代码中如果有不小心把 $n$ 和 $m$ 写错的情况，请私信我或评论指出，谢谢。

~~蒟蒻为了做题甚至买了一本《图论与代数结构》。~~

upd $2023/5/9$：更改错别字，代码加上一些注释，更改标点。

## 解法

### 一些定义

这里 $n,m,type1,type2$ 等变量，$A,B,Z$ 等向量意义均同题目中的意义。

对于每条边，$u$ 代表这条边的起点，$v$ 代表这条边的终点，$d$ 代表这条边的权值（如果是赋权图的话）。

设 $matrix$ 代表用邻接矩阵，权矩阵或关联矩阵存图时的矩阵。$matrix_{i,j}$ 代表矩阵 $matrix$ 的第 $i$ 行第 $j$ 个元素。每个矩阵的初始元素都为 $0$。

我们一个存图方式一个存图方式来看。

以下存图方式除正向表和逆向表外，都是将原始数据转化为图的。正向表和逆向表因为是邻接表的压缩，因此我是直接将邻接表转化为正向表和逆向表的。

### 输入

按找题意模拟，并没有太多细节。注意在 $type2=1$ 时还要输入边权。

```cpp
void input()
{
	cin>>n>>m>>type1>>type2;
	for(int i=1;i<=m;i++)
	{
		cin>>u[i]>>v[i];
		if(type2)cin>>d[i];//如果是赋权图还要输入边权
	}
}
```

### 邻接矩阵/权矩阵

一张无权图的邻接矩阵 $A$ 是一个 $n$ 阶方阵，用于表示点与点之间的关系。

对于每个元素 $A_{i,j}$，如果存在一条起点为 $i$，终点为 $j$ 的边，此元素为 $1$。否则为 $0$。

而如果是赋权图，就把 $1$ 替换成对应的边权 $d$。

我们可以遍历一遍原始数据，每次把 $A_{u,v}$ 设为 $1$ 或 $d$。

如果 $A_{u,v}$ 在赋值前不是 $0$，那么说明有重边。

注意点：

* 若是无向图，把 $A_{v,u}$ 也设为 $1$ 或 $d$，注意此时不需要判断重边，否则如果 $u=v$ 的话，会误判为重边。

存图时间复杂度：$O(m)$。

空间复杂度：$O(n^2)$。

查询某条边是否存在：$O(1)$。

遍历整张图：$O(n^2)$。

遍历某个点的所有出边：$O(n)$。

缺点：无法表示重边。

代码：

```cpp
void output1()
{
	int A[307][307];
	memset(A,0,sizeof(A));//初始全部赋值为 0
	for(int i=1;i<=m;i++)
	{
		if(A[u[i]][v[i]])return;//判断重边
		if(type2)A[u[i]][v[i]]=d[i];//如果是赋权图，建立权矩阵
		else A[u[i]][v[i]]=1;//否则建立邻接矩阵
		if(!type1)//如果是无向图，还要反向在建一条边
		{
			if(type2)A[v[i]][u[i]]=d[i];
		    else A[v[i]][u[i]]=1;
		}
	}
	for(int i=1;i<=n;i++)//输出
	{
		for(int j=1;j<=n;j++)
		{
			cout<<A[i][j]<<' ';
		}
		cout<<'\n';
	}
}
```

### 关联矩阵

一张无权图的关联矩阵 $B$ 是一个 $n\times m$ 的矩阵。

对于每个元素 $B_{i,j}$，如果点 $i$ 在第 $j$ 条边中作为起点出现；$B_{i,j}=1$；如果点 $i$ 在第 $j$ 条边中作为终点出现；$B_{i,j}=-1$；否则此元素为 $0$，代表这两条边没有关联。

对于无向图的任意某条边，如果 $B_{u,j}=1$，那么 $B_{v,j}=1$，即把两端都看作起点。


注意点：

* 由于对于赋权图无法体现边权，因此关联矩阵无法表示赋权图。

* 对于自环（即一条起点和终点相同的边，$u=v$）一个元素无法同时是 $1$ 和 $-1$，因此也无法表示。

存图时间复杂度：$O(m)$。

空间复杂度：$O(n\times m)$。

查询某条边是否存在：$O(m)$。

遍历整张图：$O(n\times m)$。

遍历某个点的所有出边：$O(m)$。

缺点：无法表示赋权图与自环。

代码：

```cpp
void output2()
{
	if(type2)return;//如果是赋权图无法建立关联矩阵
	int B[307][307];
	memset(B,0,sizeof(B));//初始全部赋为 0
	for(int i=1;i<=m;i++)
	{
		if(u[i]==v[i])return;//自环
		if(!type1)B[u[i]][i]=B[v[i]][i]=1;//无向图，两端都是起点
		else B[u[i]][i]=1,B[v[i]][i]=-1;//有向图
	}
	for(int i=1;i<=n;i++)///输出
	{
		for(int j=1;j<=m;j++)
		{
			cout<<B[i][j]<<' ';
		}
		cout<<'\n';
	}
}
```

### 邻接表

邻接表应该是 OIer 平时存图用的最多的方法吧。

我们通过观察可以发现，在以上几种存图方式中都有大量 $0$ 存在（没有边），很浪费空间，遍历效率低。

邻接表是采用 $n$ 个单链表结构表示一张图 $G$。这里定义 $G_i$ 为第 $i$ 个单链表。$G_{i,j}$ 为第 $i$ 个单链表的第 $j$ 个元素。

在邻接表中，$G_i$ 表示的是以第 $i$ 个点作为起点的所有边的终点的集合。

实际代码中，用 $\text{STL}$ 中的 `std::vector` 来存储，它具有大小可变化这个优点，代替链表实现。用手写链表（链式前向星）可以一定的加快效率，但实现相对困难。

注意点：

* 如果某个点没有任何出边，也要输出换行（`\n`），题目中的样例是有误的。

* 对于无向图的某条边，把 $v$ 加入 $G_u$ 时，还要把 $u$ 加入 $G_v$。

* 对于赋权图，我们可以在加入出边的同时也加入边权，因此我用的是 `std::vector<std::pair<int,int> >` 存储，第一个元素代表出边，第二个元素代表边权。

存图时间复杂度：$O(m)$。

空间复杂度：$O(m)$。

查询某条边是否存在：$O(u\ \text{的出边数量})$。

遍历整张图：$O(m)$。

遍历某个点的所有出边：$O(u\ \text{的出边数量})$。

我代码中的 $G$ 用的是全局变量，还同时存下了 $G$ 的反图 $G\_$，方便后文的逆向表建立。

代码：

```cpp
void output3()
{
	for(int i=1;i<=m;i++)
	{
		G[u[i]].push_back(make_pair(v[i],d[i]));//加入一条边
		G_[v[i]].push_back(make_pair(u[i],d[i]));//反图加边
		if(!type1)G[v[i]].push_back(make_pair(u[i],d[i])),G_[u[i]].push_back(make_pair(v[i],d[i]));//如果是无向图还需反向建边
	}
	for(int i=1;i<=n;i++)//输出
	{
		for(int j=0;j<G[i].size();j++)//G[i].size() 代表 i 的出边数量
		{
			cout<<G[i][j].first<<' ';
			if(type2)cout<<G[i][j].second<<' ';//如果是赋权图还要输出边权
		}
		cout<<'\n';
	}
}
```

### 正向表

正向表是对邻接表压缩的结果。

为了进一步的压缩空间，我们把邻接表的出边部分改成一个  $m$ 维向量 $B$，把边权也改成一个 $m$ 维向量 $Z$。

那么如何判断每条出边对应的起点是哪个呢？我们再建立建立一个 $(n+1)$ 维向量 $A$。$A_i$ 代表前 $i-1$ 个点的出边之和 $+1$。

这样，如果我们像遍历第 $i$ 个点的全部出边或元素，只要访问 $B$ 或 $Z$ 中 $[A_i,A_{i+1})$ 的所有元素即可。

注意点：

* 如果是赋权图还要输出 $Z$ 向量。

* 如果你用静态的数组存储 $B$ 和 $Z$ 的话，无向图最多可能会有 $600$ 条出边，需要开最大边数两倍的空间。

存图时间复杂度：$O(m)$。

空间复杂度：$O(m)$。

查询某条边是否存在：$O(u\ \text{的出边数量})$。

遍历整张图：$O(m)$。

遍历某个点的所有出边：$O(u\ \text{的出边数量})$。

代码：

```cpp
void output4()
{
	vector<int> A,B,Z;//向量 A,B,Z 
	A.push_back(1);
	for(int i=1;i<=n;i++)A.push_back(G[i].size()+A[i-1]);//
	for(int i=1;i<=m;i++)
	{
		for(int j=0;j<G[i].size();j++)
		{
			B.push_back(G[i][j].first);
			if(type2)Z.push_back(G[i][j].second);//如果是赋权图还要建立 Z 向量
		}
	}
    //输出
	for(int i=0;i<=n;i++)cout<<A[i]<<' ';
	cout<<'\n';
	for(int i=0;i<B.size();i++)cout<<B[i]<<' ';
	cout<<'\n';
	if(!type2)return;
	for(int i=0;i<Z.size();i++)cout<<Z[i]<<' ';
	cout<<'\n';
}
```

### 逆向表

逆向表可以看作是反图的正向表。

具体地，$A_i$ 中存储的改为第 $i$ 个点的入边个数 $+A_{i-1}$。$B$ 改为存储所有的每个点的入边。$Z$ 不变。

我在邻接表中就提前存好了反图，因此之间对反图建正向表即可。

在无向图中，因为每个点既可以看作起点也可以看作终点，所以正向表和逆向表相同，不用输出。

存图时间复杂度：$O(m)$。

空间复杂度：$O(m)$。

查询某条边是否存在：$O(v\ \text{的入边数量})$。

遍历整张图：$O(m)$。

遍历某个点的所有入边：$O(v\ \text{的入边数量})$。

代码：

```cpp
void output5()
{
	if(!type1)return;//无向图不用输出
	vector<int> A,B,Z;//代码基本同正向表
	A.push_back(1);
	for(int i=1;i<=n;i++)A.push_back(G_[i].size()+A[i-1]);
	for(int i=1;i<=m;i++)
	{
		for(int j=0;j<G_[i].size();j++)
		{
			B.push_back(G_[i][j].first);
			if(type2)Z.push_back(G_[i][j].second);
		}
	}
	for(int i=0;i<=n;i++)cout<<A[i]<<' ';
	cout<<'\n';
	for(int i=0;i<B.size();i++)cout<<B[i]<<' ';
	cout<<'\n';
	if(!type2)return;
	for(int i=0;i<Z.size();i++)cout<<Z[i]<<' ';
	cout<<'\n';
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,type1,type2,u[1007],v[1007],d[1007];
vector<pair<int,int> >G[307],G_[307];

void input()//输入
{
	cin>>n>>m>>type1>>type2;
	for(int i=1;i<=m;i++)
	{
		cin>>u[i]>>v[i];
		if(type2)cin>>d[i];
	}
}

void output1()//邻接矩阵（权矩阵）
{
	int A[307][307];
	memset(A,0,sizeof(A));
	for(int i=1;i<=m;i++)
	{
		if(A[u[i]][v[i]])return;
		if(type2)A[u[i]][v[i]]=d[i];
		else A[u[i]][v[i]]=1;
		if(!type1)
		{
			if(type2)A[v[i]][u[i]]=d[i];
		    else A[v[i]][u[i]]=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cout<<A[i][j]<<' ';
		}
		cout<<'\n';
	}
}

void output2()//关联矩阵
{
	if(type2)return;
	int B[307][307];
	memset(B,0,sizeof(B));
	for(int i=1;i<=m;i++)
	{
		if(u[i]==v[i])return;
		if(!type1)B[u[i]][i]=B[v[i]][i]=1;
		else B[u[i]][i]=1,B[v[i]][i]=-1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cout<<B[i][j]<<' ';
		}
		cout<<'\n';
	}
}

void output3()//邻接表
{
	for(int i=1;i<=m;i++)
	{
		G[u[i]].push_back(make_pair(v[i],d[i]));
		G_[v[i]].push_back(make_pair(u[i],d[i]));
		if(!type1)G[v[i]].push_back(make_pair(u[i],d[i])),G_[u[i]].push_back(make_pair(v[i],d[i]));
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<G[i].size();j++)
		{
			cout<<G[i][j].first<<' ';
			if(type2)cout<<G[i][j].second<<' ';
		}
		cout<<'\n';
	}
}

void output4()//正向表
{
	vector<int> A,B,Z;
	A.push_back(1);
	for(int i=1;i<=n;i++)A.push_back(G[i].size()+A[i-1]);
	for(int i=1;i<=m;i++)
	{
		for(int j=0;j<G[i].size();j++)
		{
			B.push_back(G[i][j].first);
			if(type2)Z.push_back(G[i][j].second);
		}
	}
	for(int i=0;i<=n;i++)cout<<A[i]<<' ';
	cout<<'\n';
	for(int i=0;i<B.size();i++)cout<<B[i]<<' ';
	cout<<'\n';
	if(!type2)return;
	for(int i=0;i<Z.size();i++)cout<<Z[i]<<' ';
	cout<<'\n';
}

void output5()/逆向表
{
	if(!type1)return;
	vector<int> A,B,Z;
	A.push_back(1);
	for(int i=1;i<=n;i++)A.push_back(G_[i].size()+A[i-1]);
	for(int i=1;i<=m;i++)
	{
		for(int j=0;j<G_[i].size();j++)
		{
			B.push_back(G_[i][j].first);
			if(type2)Z.push_back(G_[i][j].second);
		}
	}
	for(int i=0;i<=n;i++)cout<<A[i]<<' ';
	cout<<'\n';
	for(int i=0;i<B.size();i++)cout<<B[i]<<' ';
	cout<<'\n';
	if(!type2)return;
	for(int i=0;i<Z.size();i++)cout<<Z[i]<<' ';
	cout<<'\n';
}

int main()
{
    input();
    output1();
    output2();
    output3();
    output4();
    output5();
}
```

### 参考资料

* 《图论与代数结构》

* 现有的部分题解

---

## 作者：SUNCHAOYI (赞：7)


Update on 2021.07.10：修改了题解中**关联矩阵【无权图】** 部分的错误。

----

这道题目需要极大的耐心以及细心程度，但是思维难度不大，按照题意模拟即可。【**注：本题解所有内容涉及的图片见文章底部。图片的圈中的黑色数字为结点编号，边上的紫色数字为边编号，边上的黑色数字为边权。**】

### 前置

设输入的一条边为 $(u,v)$，$dis[u][v]$ 为非零时即有连边。

判断重边：`if (dis[u][v]) chong = 1;//dis非零，说明出现重边`；  
判断自环：`if (u == v) itself = 1;//说明是自环`。

----

### 邻接矩阵【无权图】

邻接矩阵表示**结点之间的邻接关系**。该矩阵是由 $n \times n$ 的布尔数组组成，若 $G[i,j] = 1$，则表示一条 $i$ 至 $j$ 的边；若 $G[i,j] = 0$，则表示没有一条 $i$ 至 $j$ 的边。因此不难发现，在无向图的邻接矩阵中，有 $G[i,j] = G[j,i]$。  

$\color{red} \text{特点：可以表示自环，但无法表示重边。}$

如图一，这是一张结点数为 $5$ 的无向无权图，将其表示成邻接矩阵为：

$$
\left [ \begin{matrix} 

0&1&1&0&0\\
1&0&1&0&1\\
1&1&0&1&0\\
0&0&1&0&1\\
0&1&0&1&0\\
\end{matrix} \right ]
$$

因此可以得到代码：

```cpp
if (!ty_2)
{
  int u = read (),v = read ();
  if (!ty_1) dis[u][v] = dis[v][u] = 1;//无向图
  else dis[u][v] = 1;//有向图
}
for (int i = 1;i <= n;++i)//矩阵的打印
{
	for (int j = 1;j <= n;++j) printf ("%d ",dis[i][j]);
   puts ("");
}
```

----

### 权矩阵【赋权图】

与邻接矩阵相似，表示**结点之间的邻接关系**。该矩阵是由 $n \times n$ 的数组组成，若 $G[i,j] = d$，则表示一条 $i$ 至 $j$ 的权值为 $d$ 的边；若 $G[i,j] = 0$，则表示没有一条 $i$ 至 $j$ 的边。

$\color{red} \text{特点：可以表示自环，但无法表示重边。}$

如图二，这是一张结点数为 $5$ 的有向赋权图，将其表示成权矩阵为：

$$
\left [ \begin{matrix} 

0&2&0&0&0\\
0&0&3&0&0\\
1&0&0&0&0\\
0&0&5&0&1\\
0&3&0&0&0\\
\end{matrix} \right ]
$$

代码与邻接矩阵大题相似，无非把 `dis[u][v] = 1` 改为 `dis[u][v] = d`，故不再赘述。

----

### 关联矩阵【无权图】

关联矩阵表示**结点与边之间的关联关系**。该矩阵是由 $n \times m$ 的数组组成，设矩阵为 $G$，则有 $\forall x \in G,x \in \{1,0,-1\}$。对于无向图，若 $G[i,j] = 1$，则点 $i$ 是边 $j$ 的端点；对于有向图来说，若 $G[i,j] = 1$，则点 $i$ 是边 $j$ 的始点，若 $G[i,j] = -1$，则点 $i$ 是边 $j$ 的终点。若 $G[i.j] = 0$，则点 $i$ 与边 $j$ 不相连。

$\color{red} \text{特点：可以表示重边，但无法表示自环。}$

如图一，这是一张结点数为 $5$ 的无向无权图，将其表示成关联矩阵为：

$$
\left [ \begin{matrix} 
1&1&0&0&0&0\\
1&0&1&1&0&0\\
0&1&1&0&1&0\\
0&0&0&0&1&1\\
0&0&0&1&0&1\\
\end{matrix} \right ]
$$

代码如下：

```cpp
int u = read (),v = read ();
if (!ty_1) con[u][i] = con[v][i] = 1;//无向图
else con[u][i] = 1,con[v][i] = -1;//有向图一个为始点，一个为终点
for (int i = 1;i <= n;++i)//关联矩阵的打印
{
	for (int j = 1;j <= m;++j) printf ("%d ",con[i][j]);
   puts ("");
}
```

----

### 邻接表

邻接表相当于一张表示**结点结构的单链表**。对于一张图，结点 $u$ 的表的元素 $v$ 满足 $dis[u][v] > 0$。若为赋权图，则还要记录 $u$ 到 $v$ 的边权。

$\color{red} \text{特点：可以表示重边与自环。}$

如图二，这是一张结点数为 $5$ 的有向赋权图，将其表示成邻接表为：

```cpp
2 2
3 3
1 1
3 5 5 1
2 3
```

因为每个结点的表的元素个数不确定，因此可以用动态数组 `vector <int> name[MAX],quan[MAX]`。代码很简单：

```cpp
if (!ty_2)
{
	int u = read (),v = read ();
	if (!ty_1) name[u].push_back (v),name[v].push_back (u);//无向图两个点均加入
	else name[u].push_back (v);//有向图只加单向的
}
else
{
	int u = read (),v = read (),d = read ();
	if (!ty_1) name[u].push_back (v),name[v].push_back (u),quan[u].push_back (d),quan[v].push_back (d);	//此时为赋权图，还需要记录权值
	else name[u].push_back (v),quan[u].push_back (d);//有向图只加单向的
}
//注意，如果某个节点的表的元素个数为 0，也要单独输出一个空行，不能忽略（之前样例有误）
if (!ty_2)//有无赋权的两种情况
{
	for (int i = 1;i <= n;++i)
	{
		for (int j = 0;j < name[i].size ();++j) printf ("%d ",name[i][j]);
		puts ("");
	}
}
else
{
	for (int i = 1;i <= n;++i)
	{
		for (int j = 0;j < name[i].size ();++j) printf ("%d %d ",name[i][j],quan[i][j]);
		puts ("");
	}
}
```

----

### 正向表/逆向表

一种压缩储存的方式，可以**节省空间**。向量 $A$ 表示结点 $u$ 的直接后继结点在 $B$ 中的首地址(逆向表则为前驱结点)，向量 $B$ 储存结点编号，向量 $C$ 储存权值。

如图二，这是一张结点数为 $5$ 的有向赋权图，将其表示成正向表/逆向表为：

```cpp
//正向表
1 2 3 4 6 7
2 3 1 3 5 2
2 3 1 5 1 3
//逆向表
1 2 4 6 6 7
3 1 5 2 4 4
1 2 3 3 5 1
```

设结点 $u$ 的邻接表的元素个数为 $x$。则正向表的三个向量计算如下：对于向量 $A$，首先规定 $A[1] = 1$。对于结点 $1$ 至 $n$，$A[i + 1] = A[i] + x_i$。向量 $B,C$ 便是遍历邻接表中所有元素并记录编号(以及权值)。

代码如下：

```cpp
for (int i = 1;i <= n;++i)//正向表 
	{
		zheng.push_back (zheng[zheng.size () - 1] + name[i].size ());//向量 A 的计算
		for (int j = 0;j < name[i].size ();++j)
		{
			zn.push_back (name[i][j]);//向量 B 记录结点编号
			if (ty_2) zq.push_back (quan[i][j]);//向量 C 记录权值
		}
	}
```

对于逆向表来说，正好与正向表相反。在为有向图的前提下，进行反向连边，如原来为 $u \to v$，变为 $v \to u$。然后根据反向边，进行与正向表相同的操作即可。

----

### 尾声 
这样就完整地解决了题目的所有表示方法。做该题目时，一定要严格按照题意输入输出，利用好 `if` 语句判断每一张表在不同的数据中是否要输出。

最后，再次感谢您能看到结尾！

----

### 附

文中图如下：

![附](https://cdn.luogu.com.cn/upload/image_hosting/xzjjvyh3.png)

完整代码戳此链接：[代码](https://www.luogu.com.cn/paste/ltbi4fqx)


---

## 作者：封禁用户 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B3600)

最初是在整理 B 题库的时候发现了这道题，一直想做却又没做，今天终于 AC，也刚好让这题通过数达到 $555$，遂写一篇题解纪念一下。

当然也有知识盲区，所以一部分参考了网上关于图论的知识点，勿喷。

思路比较简单但是代码很长，共 $130$ 行。

---

### $\textbf{Part.1 邻接矩阵或权矩阵}$

用 $vis$ 数组标记重边，如果遇到重边则不输出，否则把这条边设为出现过，然后如果该图是赋权图就把 $a_{u_i,v_i}$ 设为边权 $w_i$，否则就设为 $1$。注意如果该图是无向图还需要反向建边。最后如果该图没有重边就输出 $a$。

### $\textbf{Part.2 关联矩阵}$

如果该图是赋权图或者该图有自环则不输出，用 $f$ 标记。然后如果该图是有向图就把起点 $b_{u_i,i}$ 设为 $1$，把终点 $b_{v_i,i}$ 设为 $-1$，如果该图是无向图就把 $b_{u_i,i}$ 和 $b_{v_i,i}$ 都设为 $1$，也就是都看作起点。最后如果该图没有自环又不是赋权图就输出 $b$。

### $\textbf{Part.3 邻接表}$

用 `vector` 存储，构造图 $G$ 和图 $J$，后续的逆向表也会用到，然后对于每条边，把 $\{v,w\}$ 加入 $G_u$，把 $\{u,w\}$ 加入 $J_v$，然后如果该图是无向图还需要反向建边。最后输出 $G$，如果该图是赋权图还需要输出边权。

### $\textbf{Part.4/5 正向表/逆向表}$

正向表的 $Ax$ 向量相当于前缀和，也就是规定向量 $Ax_1=1$，那么 $Ax_{i+1}=Ax_i+|G_i|$，其中 $|G_i|$ 表示 $G_i$ 的长度。然后用 $Bx$ 向量保存结点 $u$ 连接的所有结点，$Cx$ 存储权值，都从图 $G$ 里取出就可以了。最后输出，如果该图是赋权图那么输出 $Cx$，赋权图也是一样的操作，只不过是从 $J$ 里取出结点和边权，注意如果该图是无向图则不输出逆向表。

### $\textbf{Part.6 完整代码}$

```cpp
#include <iostream>
#include <vector>
#define F first
#define S second
using namespace std;

const int N = 1005;

bool t1, t2;
int n, m, u[N], v[N], w[N];
int a[N][N], b[N][N], cur;
int Ax[N], Bx[N], Cx[N];
int Ay[N], By[N], Cy[N];
bool f = true, vis[N][N];
vector<pair<int, int> > G[N], J[N];

int main()
{
	// Input.
    cin >> n >> m >> t1 >> t2;
    for (int i = 1; i <= m; i++)
    {
    	cin >> u[i] >> v[i];
    	if (t2) cin >> w[i];
	}
	// Part.1
	for (int i = 1; i <= m; i++)
	{
		if (vis[u[i]][v[i]]) f = false; // 重边 
		else
		{
			vis[u[i]][v[i]] = true; // 标记为出现过 
			if (t2) a[u[i]][v[i]] = w[i]; // 权矩阵 
			else a[u[i]][v[i]] = 1; // 邻接矩阵 
		}
		if (!t1) // 无向图 
		{
			if (t2) a[v[i]][u[i]] = w[i]; // 权矩阵 
			else a[v[i]][u[i]] = 1; // 邻接矩阵 
		}
	}
	if (f)
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				cout << a[i][j] << " \n"[j == n];
	}
	// Part.2
	f = !t2; // 赋权图 
	for (int i = 1; i <= m; i++)
	{
		if (u[i] == v[i]) f = false; // 自环 
		if (t1) // 有向图 
		{
			b[u[i]][i] = 1; // 起点 
			b[v[i]][i] = -1; // 终点 
		}
		else b[u[i]][i] = b[v[i]][i] = 1; // 无向图都设为 1 
	}
	if (f)
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				cout << b[i][j] << " \n"[j == m];
	}
	// Part.3
	for (int i = 1; i <= m; i++)
	{
		G[u[i]].push_back(make_pair(v[i], w[i])); // 加边 
		J[v[i]].push_back(make_pair(u[i], w[i])); // 反图，逆向表会用到 
		if (!t1) // 无向图 
		{
			G[v[i]].push_back(make_pair(u[i], w[i])); // 加边 
			J[u[i]].push_back(make_pair(v[i], w[i])); // 反图，逆向表会用到 
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j < (int)G[i].size(); j++)
		{
			cout << G[i][j].F << " ";
			if (t2) cout << G[i][j].S << " "; // 边权 
		}
		cout << "\n";
	}
	// Part.4
	Ax[1] = 1; // 初值 
	for (int i = 1; i <= n; i++)
	{
		Ax[i + 1] = Ax[i] + (int)G[i].size(); //类似前缀和 
		for (int j = 0; j < (int)G[i].size(); j++)
		{
			Bx[++cur] = G[i][j].F; // 保存邻接表的结点 
			if (t2) Cx[cur] = G[i][j].S; // 权值 
		}
	}
	for (int i = 1; i <= n + 1; i++)
		cout << Ax[i] << " \n"[i == n + 1];
	for (int i = 1; i <= cur; i++)
		cout << Bx[i] << " \n"[i == cur];
	if (t2) // 赋权图输出边权 
	{
		for (int i = 1; i <= cur; i++)
			cout << Cx[i] << " \n"[i == cur];
	}
	// Part.5
	Ay[1] = 1, cur = 0; // 初值 
	for (int i = 1; i <= n; i++)
	{
		Ay[i + 1] = Ay[i] + (int)J[i].size(); // 类似前缀和 
		for (int j = 0; j < (int)J[i].size(); j++)
		{
			By[++cur] = J[i][j].F; // 保存邻接表的结点 
			if (t2) Cy[cur] = J[i][j].S; // 权值 
		}
	}
	if (t1) // 有向图 
	{
		for (int i = 1; i <= n + 1; i++)
			cout << Ay[i] << " \n"[i == n + 1];
		for (int i = 1; i <= cur; i++)
			cout << By[i] << " \n"[i == cur];
		if (t2) // 赋权图输出边权 
		{
			for (int i = 1; i <= cur; i++)
				cout << Cy[i] << " \n"[i == cur];
		}
	}
    return 0;
}
```

---

## 作者：Contain_Thunder (赞：2)

模板题，但~~码量大~~。本题主要考察的是存图的方式。
## 图的类别
**有向图**：简单来说是指一副具有**方向性**的图。例如节点 $a$ 指向节点 $b$，则只能从 $a$ 走到 $b$，而不能从 $b$ 走到 $a$。

**无向图**：若一个图中每条边都是**无方向**的，则称为无向图。如果一个图为无向图，则既可以从节点 $a$ 走到节点 $b$，又可以从 $b$ 走到 $a$。

**赋权图**:若一个图中连接两个节点的边有长度，则这个图是赋权图。
## 图的存储方式
### 邻接矩阵

邻接矩阵是一个 $n$ 行 $n$ 列的矩阵，$n$ 代表节点数。仅能在一张**无重边**的图中使用。

**赋权图**

假如节点 $i$ 连接节点 $j$，则将矩阵中第 $i$ 行第 $j$ 列设为边权，表示这里有一条长度为 $w$ 的边。

**无权图**

存法都差不多只不过将第 $i$ 行第 $j$ 列的值设为一。仅表示这里有一条边。

**注意**

邻接矩阵中如果节点 $a$ 连接节点 $b$ 且这个图为无向图，那么第 $a$ 行第 $b$ 列和第 $b$ 行第 $a$ 列都要赋值，因为两边都可以走。如下图。
![](https://cdn.luogu.com.cn/upload/image_hosting/7cg2l52e.png)

**代码实现**

```
jz[u][v]=w  //节点u到节点v之间有一条长为w的边
```

### 关联矩阵

同样是一个二维数组，他记录的是一个点与一条边的关系。并且关联矩阵仅能在一张**无自环**并且**无权**的图中使用。

**存法**

现在第 $i$ 条边上有节点 $u$ 和 $v$ 相连，如果点 $u$ 在第 $i$ 条边中作为起点出现，则将 $b_{u,i}=1$，否则等于负一。如果这个图是无向图则将 $b_{u,i}$ 和 $b_{v,i}$ 都设为一。如下。
![](https://cdn.luogu.com.cn/upload/image_hosting/lxhit97j.png)
### 邻接链表

相对于邻接矩阵，邻接表虽然更加复杂却极大减少了空间复杂度。邻接表就相当于一维数组与链表的结合体。同时他还有一个熟悉的名字，链式前向星。

**存法**

顶点：按编号顺序将顶点数据存储在一维数组中。

关联同一顶点的边：用线性链表存储。


**无向图**

![](https://cdn.luogu.com.cn/upload/image_hosting/6qv19y5x.png)

**有向图**

![](https://cdn.luogu.com.cn/upload/image_hosting/tuqpby8j.png)

**链式前向星**
```
void add(int x,int y,int v){ //x节点指向y节点，长度为v
	c[++cnt].v=v;
	c[cnt].to=y;
	c[cnt].next=h[x];
	h[x]=cnt;
}
```
### 正向表/逆向表

**正向表**

当对图 $G$ 的节点与边进行编号后，正向表将每个节点
的直接后继集中在一起存放。

有向图的正向表有一个 $(n+1)$ 维向量 $A$，一个 $m$ 维向量 $B$ 组成。

$A(i)$ 表示节点 $v_i$ 的第一个后继在 $B$ 中的地址。$B$ 中存放这些后继节点的编号，即 $A(n+1)=m+1$。
![](https://cdn.luogu.com.cn/upload/image_hosting/94q3ep6y.png)
**逆向表**

与正向表相反，逆向表是将每个结点的直接前驱集中在一起存放。

---


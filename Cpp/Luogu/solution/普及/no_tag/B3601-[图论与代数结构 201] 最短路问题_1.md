# [图论与代数结构 201] 最短路问题_1

## 题目描述

给定一张 $n$ 个点、$m$ 条边的有向图，求 $1$ 号点到每个点的最短路径长度。

**注意，图可能存在重边和自环，保证不存在负环。**

## 说明/提示

本题没有部分分。

对于所有数据，$1\leq n,m \leq 2\times 10^3$，$-10^9\leq w_i\leq 10^9$。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 2 1
2 3 4
1 3 3
4 1 5
3 1 2
```

### 输出

```
0 1 3 -1```

## 样例 #2

### 输入

```
10 50
5 9 6
1 3 10
3 1 1
10 2 5
8 5 1
10 10 6
6 5 2
1 5 10
2 5 5
10 1 4
1 5 2
8 8 7
7 2 7
9 2 8
3 1 4
6 2 5
3 9 9
4 9 5
5 10 9
10 1 9
5 4 5
9 1 2
5 10 6
3 8 7
10 3 7
5 8 8
9 2 6
9 8 6
3 2 8
1 3 8
1 10 1
7 8 4
9 4 5
4 6 2
2 7 6
10 1 5
9 9 7
6 7 4
1 1 7
8 3 10
8 3 9
10 9 8
3 9 1
7 4 8
1 5 4
8 4 4
3 4 4
9 9 2
2 10 4
8 9 6
```

### 输出

```
0 6 8 7 2 9 12 10 8 1```

# 题解

## 作者：伟大的王夫子 (赞：27)

首先，观察此题的数据范围 $1\le n,m \le 2 \times 10^3$ 并且
$-10^9 \le w_i \le 10^9$，说明这是一道带有负边权的单源最短路问题，并且我们可以用一个 $O(nm)$ 的算法来进行求解。在这种情况下，相对于 spfa，我选择了更为容易实现的 Bellman_Ford。

Bellman_Ford 算法的思路是这样的。令 $d_i$ 为从节点 $1$ 到节点 $i$ 的最短路。扫描所有边 $(x, y, z)$，如果 $d_y > d_x +z$，那么令 $d_y = d_x + z$。如此这样扫描 $m$ 条边，每条边都扫描 $n$ 次，便得到了最短路的值。

而 spfa 则是该算法的一个队列优化。使用队列可以有效避免不需要扫描的节点的扫描，优化了效率，但是写起来更麻烦，极端情况下效率也未必比前者高。并且此题数据范围小，Bellman-Ford完全可以胜任。

当然，我们还可以加一个小优化，就是当循环次数还没有到 $n$ 次时，如果有一次循环中一个节点的最短路值都没有更新，那么就直接跳出循环。（~~虽然这个优化可能没什么用~~）

跑的还挺快，21ms。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
long long dis[2010];
struct P {
	int x, y, z;
} a[2010];
int main() {
	scanf("%d%d", &n, &m);
	bool flag = 1;
	for (register int i = 1; i <= n; ++i) dis[i] = 1e18;
	dis[1] = 0;
	for (register int i = 1; i <= m; ++i) scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].z);
	for (register int i = 1; i <= n; ++i) {
		flag = 1;
		for (register int j = 1; j <= m; ++j)
			if (dis[a[j].y] > dis[a[j].x] + a[j].z) flag = 0, dis[a[j].y] = dis[a[j].x] + a[j].z;
		if (flag) break;
	}
	for (register int i = 1; i <= n; ++i) printf("%lld ", dis[i] == 1e18 ? -1 : dis[i]);
}
```






---

## 作者：一扶苏一 (赞：12)

## Analysis

注意到边权存在负数，因此 dijkstra 不能胜任，需要使用 bellman-ford 或其队列优化算法（即所谓的 SPFA）来完成。

需要指出的是，SPFA 只能提升 bellman-ford 在一般数据情况下的效率，而不能优化其复杂度。极端情况下，二者的效率是相同的（甚至 SPFA 的常数更大）。二者的时间复杂度均为 $O(nm)$。

SPFA 算法的思想是，首先将源点加入队列，然后只要队列不为空就取出队首进行松弛；松弛成功后将被松弛的节点（如果不在队列中）加入队列。

## Code

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

class Edge {
  int w;
  Node v;
  Edge nxt;
  public Edge(Node vv, int ww, Edge nn) {
    v = vv; w = ww; nxt = nn;
  }
}

class Node {
  Edge hd;
  boolean inq;
  long dist;

  public void add(Node v, int w) {
    hd = new Edge(v, w, hd);
  }

  void release(Queue<Node> Q) {
    this.inq = false;
    for (Edge e = hd; e != null; e = e.nxt) {
      Node v = e.v;
      if (v.dist > dist + e.w) {
        v.dist = dist + e.w;
        if (v.inq == false) {
          v.inq = true;
          Q.offer(v);
        }
      }
    }
  }
}

class Graph {
  Node[] node;
  int n, m;
  static public long INF = 0x3f3f3f3f3f3f3f3fl;

  public void addedge(int u, int v, int w) {
    node[u].add(node[v], w);
  }

  Graph(int N, int M) {
    n = N; m = M; node = new Node[n + 1];
    for (int i = 1; i <= n; ++i) node[i] = new Node();
  }

  public void SPFA() {
    Queue<Node> Q = new LinkedList<Node>();
    Q.add(node[1]);
    for (int i = 2; i <= n; ++i) {
      node[i].dist = INF;
    }
    while (!Q.isEmpty()) {
      Node u = Q.poll();
      u.release(Q);
    }
  }

  public void print() {
    for (int i = 1; i <= n; ++i) {
      System.out.printf("%d%c", node[i].dist == INF ? -1 : node[i].dist, i == n ? '\n' : ' ');
    }
  }
}


public class Main {
  public static void main(String[] argv) {
    Scanner cin = new Scanner(System.in);
    int n = cin.nextInt(), m = cin.nextInt();
    Graph G = new Graph(n, m);
    for (int i = 1, u, v, w; i <= m; ++i) {
      u = cin.nextInt(); v = cin.nextInt(); w = cin.nextInt();
      G.addedge(u, v, w);
    }
    G.SPFA();
    G.print();
  }
}
```



---

## 作者：追梦的黑旋风 (赞：11)

## 提供一个 Johnson 做法！！！


我们知道 `spfa` 的时间复杂度很容易被卡，但可以处理负边权；`dijkstra`可以时间复杂度优秀但无法处理负边权

**那么是否存在这样一个算法把二者的优秀之处结合呢**？

答案是肯定的，这个算法就是我要说的 `Johnson` 算法了

`
Johnson
`算法用于求图上的全源最短路径，其核心思想是利用设置虚点，重赋权值的方法把原问题带负权的图转化为权值非负的图，然后再利用N 次 `Dijkstra`  求出全源最短路，这样一来就可以结合 `spfa` 和 `Dijkstra` 二者的优点了。

大概的思路如下:

1.建立一个虚点，从虚点处向每个点连接一条权值为 0 的边；

2.利用 `spfa` 求出虚点到每个点的最短路，即代码中的 `hh` 数组；

3.最后我们更新每两个节点的最短路径为**原最短路加上虚点到起点的最短路减去虚点到终点的最短路**

最后的时间复杂度为  ![](https://cdn.luogu.com.cn/upload/image_hosting/dri6thfn.png)

不多废话，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll maxn=5007;
struct node{
	ll nxt,pre,w,from;
}e[maxn<<1];
ll head[maxn],cntedge;
inline void add(ll u,ll v,ll w) {
	e[++cntedge]=(node){head[u],v,w,u},head[u]=cntedge;
}
ll dis[maxn][maxn],hh[maxn],vis[maxn];
ll qq[maxn],h,t;
ll n,m;
inline void spfa(ll st){
	for(register ll i=1;i<=n;i+=3){
		hh[i]=0x3f3f3f3f;
		hh[i+1]=0x3f3f3f3f;
		hh[i+2]=0x3f3f3f3f;
	}
	hh[st]=0;
	qq[++t]=st;
	while(h!=t){
		ll u=qq[++h];
		if(h>=maxn-5)h=0;
		vis[u]=false;
		for(register ll i=head[u];i;i=e[i].nxt){
			ll v=e[i].pre;
			if(hh[v]>hh[u]+e[i].w){
				hh[v]=hh[u]+e[i].w;
				if(!vis[v]){
					vis[v]=true;
					qq[++t]=v;
					if(t>=maxn-5)t=0;
				}
			}
		}
	}
}

struct nod {
	ll x,w;
	bool operator < (const nod &com) const{
		return w>com.w;
	}
};
priority_queue <nod> q;
ll dis1[maxn];
inline void dijkstra(ll st){
	for(register ll i=1;i<=n;i+=3){
		dis1[i]=0x3f3f3f3f;
		dis1[i+1]=0x3f3f3f3f;
		dis1[i+2]=0x3f3f3f3f;
	}
	dis1[st]=0;
	q.push((nod){st,0});
	while(!q.empty()){
		ll u=q.top().x,w=q.top().w;
		q.pop();
		if(w!=dis1[u]) continue;
		for(register ll i=head[u];i;i=e[i].nxt){
			ll v=e[i].pre;
			if(dis1[v]>dis1[u]+e[i].w){
				dis1[v]=dis1[u]+e[i].w;
				q.push((nod){v,dis1[v]});
			}
		}
	}
}

int main() {
	cin>>n>>m;
	for(ll i=1;i<=m;i++){
		ll u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);
	}
	for(ll i=1;i<=n;i++){
		add(0,i,0);
	}
	spfa(0);
	for(ll i=1;i<=cntedge;i++){
		e[i].w+=hh[e[i].from]-hh[e[i].pre];
	}
	for(ll i=1;i<=n;i++){
		dijkstra(i);
		for(ll j=1;j<=n;j++){
			dis[i][j]=dis1[j]-hh[i]+hh[j];
		}
	}
	for(ll i=1;i<=n;i++){
		if(dis[1][i]==1061109567){
			printf("-1 ");
			continue;
		}
		printf("%d ",dis[1][i]);
	}
	return 0;
}
```
~~简洁地求通过~~


---

## 作者：白简 (赞：8)

## 题目

给定一张 $n$ 个点、$m$ 条边的有向图，求 $1$ 号点到每个点的最短路径长度。

注意，图可能存在重边和自环，保证不存在负环。

## 分析

这是一道单源最短路径的模板题。

常用来处理单源最短路径的算法有 Dijkstra 算法、Bellman-Ford 算法和 SPFA 算法。

注意，Dijkstra 算法**无法处理负边权**。因此 ，本篇题解使用 SPFA 算法。

这里要说一下，由于在某年，某~~良心~~出题人卡了 SPFA 。


因此，在**没有负边权**的图中，推荐大家优先使用 Dijkstra 算法。

SPFA 算法思想：
我们设立一个先进先出的队列来保存待优化的结点，优化时每次都取出队首结点 $x$，用 $x$ 点当前的最短路径值对 $x$ 点所指向的结点 $y$ 进行松弛操作。若结点 $y$ 的最短路径值受到影响，并且 $y$ 点不在队列中，就将其入队。重复上述操作直到队列为空。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define inf 2147483647

using namespace std;

struct Edge{
	int next,to,l;
}E[10000];

int h[15000],cnt;

void add(int u,int v,int w)
{
	cnt++;
	E[cnt].next=h[u];
	h[u]=cnt;
	E[cnt].to=v;
	E[cnt].l=w;
}

int n,m;

int s,t;
int u,v,w;

int k;

queue<int> q;

int dis[15000];
bool vis[15000];

void spfa(int s)
{
	for(int i=1;i<=n;i++)
		dis[i]=inf;
	dis[s]=0;
	vis[s]=1;
	q.push(s);
	do
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=h[x];i;i=E[i].next)
		{
			int y=E[i].to;
			if( dis[y] > dis[x]+E[i].l )
			{
				dis[y]=dis[x]+E[i].l;
				if( !vis[y] )
					q.push(y);
				vis[y]=1;
			}
		}
	}while( !q.empty() );
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	
	spfa(1);
	
	for(int i=1;i<=n;i++)
	{
		if( dis[i] != inf )
			printf("%d ",dis[i]);
		else
			printf("-1 ");
	}
	return 0;
}
```



---

## 作者：刘嘉琦 (赞：3)

这题的正解是用 **Bellman-Ford** 算法（或其优化版本）。

## Bellman-Ford 算法
Bellman-Ford 算法是一种可以处理负权边的最短路算法，复杂度为 $O(nm)$。

想法是这样的：

记 $dis_i$ 为目前求出的从起点 $1$ 到 $i$ 点的最短路，将初值 $dis_1$ 设为 $0$，其他为无穷大。

对于一条边 $(u,v)$，我们可以做如下**松弛**操作：

$dis_v=min(dis_v,dis_u+w(u,v))$，其中 $w(u,v)$ 是边 $(u,v)$ 的权值。

这样做是为了求出从起点到 $v$ 最短路的更优情况。

我们每次遍历图上每一条边进行一次松弛操作，可以发现：

第一次遍历，由一条边组成的最短路径的长度一定能被算出；

第二次遍历，在一条边组成的最短路的基础上再加一条边，一定能得到由两条边组成的最短路径长度……

以此类推，最终一定能算出从起点到每个点的最短路。

因为一共有 $n$ 个点，所以最短路径最多只可能由 $n-1$ 条边组成，也就是说我们遍历 $n-1$ 次之后，一定能得到最终答案。

上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int N = 2005;
int n, m, tot = -1, head[N], nxt[N], to[N];
long long val[N], d[N]; // 不开long long见祖宗

void add(int u, int v, long long w) {
	to[++tot] = v, val[tot] = w;
	nxt[tot] = head[u], head[u] = tot;
}

void Bellman_Ford() {
	memset(d, 0x3f, sizeof d);
	d[1] = 0; // 初值
	for (int k = 1; k < n; k++) // n - 1次遍历
		for (int i = 1; i <= n; i++)
			for (int j = head[i]; ~j; j = nxt[j]) // 对于每条边
				d[to[j]] = min(d[to[j]], d[i] + val[j]); // 松弛
}

int main()
{
	scanf("%d %d", &n, &m);
	memset(head, -1, sizeof head); // 用链式前向星千万别忘这一行
	for (int i = 1; i <= m; i++) {
		int u, v;
		long long w;
		scanf("%d %d %lld", &u, &v, &w);
		add(u, v, w);
	}
	Bellman_Ford();
	for (int i = 1; i <= n; i++)
		printf("%lld ", (d[i] == 0x3f3f3f3f3f3f3f3f ? -1 : d[i]));
	printf("\n");
	return 0;
}
```

## 队列优化
Bellman-Ford 算法有很多种优化，虽然这些优化能在大多情况下效率极高，但总能有数据把它们卡回原形，即 $O(nm)$。

一种最常见也最好写的优化是**队列优化**，有些人称为 **SPFA（Shortest Path Fastest Algorithm，最短路最快算法）**，但卡它的数据多了去了，根本不配拥有这个名字。

队列优化的想法是：只有上一次被松弛成功的结点，这一次才有可能成功松弛别的边。

所以，我们可以用队列维护哪些结点“有资格”松弛其他点，而不用把每个点连出的边都松弛一遍，这样在随机图中效率会高很多。

具体实现还是看代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int N = 2005;
int n, m, tot = -1, head[N], nxt[N], to[N];
long long val[N], d[N]; // 不开long long见祖宗

void add(int u, int v, long long w) {
	to[++tot] = v, val[tot] = w;
	nxt[tot] = head[u], head[u] = tot;
}

void Bellman_Ford() {
	queue<int> q;
	bool v[N] = {0}; // v[i]表示i号点是否在队列中
	memset(d, 0x3f, sizeof d);
	d[1] = 0, q.push(1), v[1] = true; // 一开始只有1号点有资格松弛
	while (!q.empty()) { // 当队列为空时，没有点能松弛别的点，说明所有点最短路都已求出，此时结束遍历
		int k = q.front();
		q.pop(), v[k] = false; // 队首出队，令其“失去资格”
		for (int i = head[k]; ~i; i = nxt[i])
			if (d[k] + val[i] < d[to[i]]) {
				d[to[i]] = d[k] + val[i]; // 松弛，此时to[i]应获得资格
				if (!v[to[i]]) // 若to[i]已经有资格，就不用重复加入队列
					q.push(to[i]), v[to[i]] = true;
			}
	}
}

int main()
{
	scanf("%d %d", &n, &m);
	memset(head, -1, sizeof head);
	for (int i = 1; i <= m; i++) {
		int u, v;
		long long w;
		scanf("%d %d %lld", &u, &v, &w);
		add(u, v, w);
	}
	Bellman_Ford();
	for (int i = 1; i <= n; i++)
		printf("%lld ", (d[i] == 0x3f3f3f3f3f3f3f3f ? -1 : d[i]));
	printf("\n");
	return 0;
}
```

## 提醒
Bellman-Ford 算法，大家最好只用于处理负权边或其他 Dijkstra 算法解决不了的问题。

对于非负权边图，大家可以去[B3602](https://www.luogu.com.cn/problem/B3602)学习 Dijkstra 算法，用Bellman-Ford 会出事的！！！

---

## 作者：Usada_Pekora (赞：3)

本题是单源最短路径的模板题目。

求解单源最短路，常用的有两种算法： Bellman-Ford 算法和 Dijkstra 算法。（ SPFA 算法实际上是前者的队列优化）。

Dijkstra 在此不做考虑，因为 Dijkstra 的贪心思想导致其无法处理带有负权的最短路径问题。

Bellman-Ford 核心思想：初始除了源点之外到所有点的距离都是无穷大， $dist_v = \min (dist_u+w_{u,v},dist_v )$ , $dist_i$ 表示从源点 $s$ 到 $i$ 的最短路径长度，这种操作也叫松驰操作，运用了动态规划的思想。 复杂度为 $O(nm)$ 。

Bellman-Ford 核心代码：

```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
    	dis[to[j]]=min(dis[from[j]]+len[j],dis[to[j]]);
```

SPFA 核心思想：对 Bellman-Ford 进行优化，每次将还能继续松驰操作且没有入队的点进行入队，这样子减少了对已经求出最短路径的点的重复计算。

AC 代码 （SPFA 代码）：

```cpp
#include<bits/stdc++.h>
#include<queue>
#define N 10005
#define INF dis[0]
#define int long long
using namespace std;
struct edge{
	int to,nxt,w;
}Edge[500005];
int n,m,fir[500005],dis[N],cnt,s;
bool vis[N];
queue<int>q;
inline void add(int u,int v,int w){
	Edge[++cnt].to=v;
	Edge[cnt].w=w;
	Edge[cnt].nxt=fir[u];
	fir[u]=cnt;
}
void SPFA(){
	memset(dis,0x3f,sizeof dis);
	q.push(s);dis[s]=0;vis[s]=true;
	while(!q.empty()){
		int u=q.front();q.pop();
		vis[u]=false;
		for(int i=fir[u];i;i=Edge[i].nxt){
			int v=Edge[i].to,w=Edge[i].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				if(!vis[v]){
				vis[v]=true;
				q.push(v);	
				}
			}
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;s=1;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);
	}
	SPFA();
	for(int i=1;i<=n;i++)
	if(i==s)cout<<0<<' ';
	else if(dis[i]==INF)cout<<-1<<' ';
	else cout<<dis[i]<<' ';
	return 0;
}
```


---


# [图论与代数结构 202] 最短路问题_2

## 题目描述

给定一张 $n$ 个点、$m$ 条边的有向图，求 $1$ 号点到每个点的最短路径长度。

**注意，图可能存在重边和自环。**

## 说明/提示

本题没有部分分。

对于所有数据，$1\leq n,m \leq 3\times 10^5$，$1\leq w_i\leq 10^9$。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 2 1
2 3 4
1 3 3
4 1 5
3 1 2
```

### 输出

```
0 1 3 -1```

## 样例 #2

### 输入

```
10 50
5 9 6
1 3 10
3 1 1
10 2 5
8 5 1
10 10 6
6 5 2
1 5 10
2 5 5
10 1 4
1 5 2
8 8 7
7 2 7
9 2 8
3 1 4
6 2 5
3 9 9
4 9 5
5 10 9
10 1 9
5 4 5
9 1 2
5 10 6
3 8 7
10 3 7
5 8 8
9 2 6
9 8 6
3 2 8
1 3 8
1 10 1
7 8 4
9 4 5
4 6 2
2 7 6
10 1 5
9 9 7
6 7 4
1 1 7
8 3 10
8 3 9
10 9 8
3 9 1
7 4 8
1 5 4
8 4 4
3 4 4
9 9 2
2 10 4
8 9 6
```

### 输出

```
0 6 8 7 2 9 12 10 8 1```

# 题解

## 作者：BlachSnake (赞：20)

**2021/8/29 Update：修改了题解中的两处错误，并在“链式前向星”部分加上了部分注释、增加了建边函数**
## 1.题意
给出一张有 $n$ 个节点，$m$ 条**有向边**的图，求 $1$ 号点到图中每个节点的最短路。
## 2.单源最短路问题
给定一个源点（此题中为 $1$ 号点），求从这个源点到图中每个点的最短路径。

接下来先考虑怎么把这个有向图存下来。

用二维数组（设 $a_{i,j}$ 为点 $i$ 到点 $j$ 的距离，空间复杂度 $O(n^2)$）存图？肯定不行，题目规定 $n\le3\times10^5$，妥妥的 MLE。

所以就有了这个东西——
## 3.链式前向星
链式前向星，是一种利用单向链表存图的数据结构。

那么它长什么样呢？

![lsqxx](https://cdn.luogu.com.cn/upload/image_hosting/ur2t5u4a.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

其实它就是 $n$ 个单向链表，第 $i$ 个单向链表存储从点 $i$ 开始的每条边所指向的点（图中的 to）以及这条边的边权（图中的 weight）。

然后把每个链表的头部用一个 head 数组存起来,如果要遍历某个点开始的所有边，直接写
```cpp
for(int i=head[x];i;i=next[i])//遍历每一条边

```
就行了。

那么如何加边呢？

很简单，只需要在链表的头部插入，就像这样：
```cpp
next[++t]=head[x];//记录后继
to[t]=y;//记录这条边指向的地方
weight[t]=z;//记录边权
head[x]=t;//更新链表头部
```
存图的问题是解决了，但怎么求最短路呢？

如果用 Dfs 暴搜的话，时间复杂度为 $O(n!)$，稳稳的 TLE。

用 Floyd（其实就是 DP）来做的话，时间复杂度为 $O(n^3)$，也会 TLE。

于是，就有了这么一个算法：
## 4.Dijkstra 求最短路
Dijkstra 单源最短路算法，是一种用贪心实现的最短路算法，只能在边权值均为正的情况下运行。至于为什么只能在边权值为正的情况下运行，等一下会提到。

这里我们用一个 $\textit{dis}$ 数组存储从源点（这里为点 $1$）到图中每一个点的最短路径长度。

先来看一下算法流程：
![dij1](https://cdn.luogu.com.cn/upload/image_hosting/46zkciaj.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

初始化，把 $\textit{dis}_1$（源点到源点本身）设为 $0$，$\textit{dis}$ 的 其余值设为 $\infty$；

![dij2](https://cdn.luogu.com.cn/upload/image_hosting/vmkv79yy.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

找到 $\textit{dis}$ 数组的最小值所在的下标 $1$，将其打上标记，并用点 $1$ 的 $\textit{dis}$ 值去更新它周围的点的 $\textit{dis}$ 值，使得 $\textit{dis}_2$ 更新为 $3$，$\textit{dis}_3$ 更新为 $2$，$\textit{dis}_5$ 更新为 $6$；

这里我把 $\textit{dis}_1$ 的数值以及点 $1$ 标蓝了，是因为这个点的最短路已经被求出来了，所以以后不再更新这个点的 $\textit{dis}$ 值。

至于为什么不再更新这个点的 $\textit{dis}$ 值，等一下讲负边权的时候会讲。~~（这句话你不已经说过一遍了吗……）~~

点 $2$、点 $3$ 和点 $5$ 因为被点 $1$ 成功更新了 $\textit{dis}$ 值，所以我把它们的 $\textit{dis}$ 值标黄了。

点 $4$ 和点 $6$ 由于没有被遍历到，所以我把它们的 $\textit{dis}$ 值标黑了。

![dij3](https://cdn.luogu.com.cn/upload/image_hosting/p3w1woi5.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

找到 $\textit{dis}$ 数组**没打过标记**的最小值所在的的下标 $3$，将其打上标记，并用点 $3$ 的 $\textit{dis}$ 值去更新它周围**没打过标记**的点的 $\textit{dis}$ 值，使得 $\textit{dis}_5$ 更新为 $3$，$\textit{dis}_6$ 更新为 $7$。

点 $1$ 因为已经被打上标记了，所以不用更新它的 $\textit{dis}$ 值。

点 $2$ 因为没被点 $3$ 更新到 $\textit{dis}$ 值，所以我这里把他标红了。

![dij4](https://cdn.luogu.com.cn/upload/image_hosting/g3ktgglc.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

找到 $\textit{dis}$ 数组没打过标记的最小值所在的的下标 $2$，将其打上标记，并用点 $2$ 的 $\textit{dis}$ 值去更新它周围没打过标记的点的 $\textit{dis}$ 值，使得 $\textit{dis}_4$ 更新为 $10$。

![dij5](https://cdn.luogu.com.cn/upload/image_hosting/cvfnbgj3.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

找到 $\textit{dis}$ 数组没打过标记的最小值所在的的下标 $5$，将其打上标记，并用点 $5$ 的 $\textit{dis}$ 值去更新它周围的没打过标记点的 $\textit{dis}$ 值，~~然而并没有更新到任何点的 $\textit{dis}$ 值~~。

![dij6](https://cdn.luogu.com.cn/upload/image_hosting/q26lp5gz.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

找到 $\textit{dis}$ 数组没打过标记的最小值所在的的下标 $6$，将其打上标记，并用点 $6$ 的 $\textit{dis}$ 值去更新它周围的没打过标记点的 $\textit{dis}$ 值，~~但仍然没有更新到任何点的 $\textit{dis}$ 值~~。

另外点 $2$ 到点 $6$ 之间那条边的权值是 $8$，我画图的时候漏了……

![dij7](https://cdn.luogu.com.cn/upload/image_hosting/584eabu8.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

找到 $\textit{dis}$ 数组没打过标记的最小值所在的的下标 $4$，将其打上标记，并用点 $4$ 的 $\textit{dis}$ 值去更新它周围的没打过标记点的 $\textit{dis}$ 值，~~结果还是没有更新到任何点的 $\textit{dis}$ 值~~。

所有的点都已经被打上了标记，算法结束。

为什么这个算法是正确的呢？

因为你把一个点打上标记后，如果这条路不是最短路，那就必须得从其他的地方绕过来，而这样求出来的路的长度一定比用 Dijkstra 求出来的路要长。

除非这条路上有负边权，不然你怎样也不可能让这条路变成最短路。

这就是为什么 Dijkstra 不能跑负权图的原因。（滑稽）

但是题目规定 $1\le w\le10^7$，没有负边权啊！（哈哈哈）

好的，然后我们就可以开开心心地 AC 了这道题……

了吗？

当然不。

由于 Dijkstra 算法查找 $\textit{dis}$ 值的最小值的下标的时间复杂度为 $O(n)$，而查找下标时一共要查找 $O(n)$ 次，更新每个节点的 $\textit{dis}$ 值时一共又要 $O(m)$ 次，所以总的时间复杂度为 $O(n^2+m)$，还是过不了……

那么，怎么优化这个算法呢？
## 5.Dijkstra算法的优化
注意每次查找最小值的时候时间复杂度都是 $O(n)$ 的，算法的瓶颈就在这里。

那么我们每次就把这些被更新的点扔进某一个神奇数据结构里，之后只要对着这个神奇数据结构问一发：此时 $\textit{dis}$ 数组里没被打上标记的最小值的下标是多少，再把这个点拉出来，把更新后的点扔进去就行了~

那么问题来了这个神奇数据结构叫什么呢？

二叉堆啊！

当把符合要求的那个点弹出堆后，就把其他更新后的点扔进堆中；

由于扔进去的点的 $\textit{dis}$ 值一定比原先在堆里的这个点的 $\textit{dis}$ 值要小（就是长江后浪推前浪），所以原先在堆里的那些点可以不用管它，因此如果这个点已经被弹出过（就是被标记过）就直接跳过。/xyx

时间复杂度为 $O(m\log m)$，可以通过此题。

至于堆的写法可以参考一下[P3378的题解](https://www.luogu.com.cn/problem/solution/P3378)。
## 6.Code
终于可以上代码了……

不过我这里自己手写了一个堆和一个 pair，实际上也可以用 STL 的 priority_queue，~~但我不想用……~~

```cpp
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
using namespace std;
const int N=300003,M=5555555;
template<class T>inline void swap(T &x,T &y){T z=x;x=y,y=z;}//交换函数
namespace io{
	inline int Read(){//快速读入数字
		int x=0;
		bool d=0;
		char c=getchar();
		for(;!isdigit(c);c=getchar())if(c=='-')d=1;
		for(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
		if(d)x=~x+1;
		return x;
	}
	inline void Print(ll x){//快速输出数字
		if(x){
			if(x<0)x=~x+1,putchar('-');
			short a[22],l;
			for(l=0;x;x/=10)a[++l]=x%10;
			for(;l;--l)putchar(a[l]+48);
		}
		else putchar('0');
		putchar(' ');
	}
}
namespace Classes{
	int nxt[N],to[N],w[N],h[N],t;//链式前向星
	inline void AE(int x,int y,int z){//加边操作
		nxt[++t]=h[x];
		to[t]=y;
		w[t]=z;
		h[x]=t;
	}
	template<class T1,class T2>
	class Pair{//自己手写的pair，也可以用STL的pair
	public:
		T1 x;
		T2 y;
		inline bool operator<(const Pair<T1,T2>b)const{return x==b.x?y<b.y:x<b.x;}//排序函数
	};
	template<class T1,class T2>
	inline Pair<T1,T2> Make_Pair(T1 x,T2 y){//把两个元素做成一个pair
		Pair<T1,T2>a;
		a.x=x,a.y=y;
		return a;
	}
	template<class T>
	class Priority_Queue{//手写堆，也可以用STL的priority_ueue
	private:
		T q[N];
		int l;
		inline void Up(int x){
			int y=x>>1;
			while(y&&q[x]<q[y]){
				swap(q[x],q[y]);
				x=y,y=x>>1;
			}
		}
		inline void Down(int x){
			int y=x<<1;
			while(y<=l){
				if(y<l&&q[y+1]<q[y])++y;
				if(q[y]<q[x])swap(q[x],q[y]),x=y,y=x<<1;
				else break;
			}
		}
	public:
		Priority_Queue(){l=0;}
		inline bool Empty(){return l==0;}
		inline void Clear(){l=0;}
		inline void Push(T x){q[++l]=x,Up(l);}
		inline void Pop(){q[1]=q[l--],Down(1);}
		inline T Top(){return q[1];}
	};
}
using namespace io;
using namespace Classes;
ll d[N];//dis数组，注意一定要开long long
bool b[N];//打标记的数组
Priority_Queue<Pair<ll,int> >q;
inline void Dijkstra(){
	memset(d,63,sizeof(d));//初始化
	d[1]=0;//让源点1的dis值为0
	int x,y,z;
	q.Push(Make_Pair(0ll,1));//把源点插入堆中（假装你已经更新过了源点的dis值）
	while(!q.Empty()){
		x=q.Top().y,q.Pop();
		if(b[x])continue;//如果这个点已经被弹出过就跳过
		b[x]=1;//否则就给它打上标记
		for(int i=h[x];i;i=nxt[i]){
			y=to[i],z=w[i];
			if(d[y]>d[x]+z){//如果这个点的dis值不是最优的
				d[y]=d[x]+z;//更新这个点的dis值
				q.Push(Make_Pair(d[y],y));//把更新后的点插入堆中
			}
		}
	}
}
int main(){
	int n=Read(),m=Read(),x,y,z;
	for(int i=1;i<=m;i++)x=Read(),y=Read(),z=Read(),AE(x,y,z);
	Dijkstra();
	for(int i=1;i<=n;i++)Print(d[i]>=0x3f3f3f3f3f3f3f3fll?-1:d[i]);//三元运算符，如果某个点的dis值没被更新过（就是dis值还是初始化的那个值），直接输出-1
	//否则输出这个点的dis值
	return 0;
}
```
## 7.一些闲话
可能会有人就会问了：STL 这么好用，为什么不用 STL 呢？

因为 STL 的堆使用的数组是动态开空间的 vector，而动态开空间又很慢，因此最好能不用 STL 就不用 STL。

另外还有一个叫 SPFA 的最短路算法，时间复杂度为 $O(km)$，其中 $k$ 为常数，平均值为 $2$，在随机数据下极快。

那我们为什么不能用 SPFA 做这道题呢？

因为 SPFA 在某些特殊构造的数据下，时间复杂度会从 $O(km)$ 退化成 $O(nm)$，而此题的 $n$ 和 $m$ 的最大值都为 $3\times10^5$，因此会超时。

所以 NOI2018 就出了这样一个梗：/doge

![SPFA died](https://cdn.luogu.com.cn/upload/pic/26431.png?x-oss-process=image/resize,m_lfit,h_500,w_800)

---

## 作者：Leonid (赞：8)

# B3602 最短路问题_2

[原题传送门](https://www.luogu.com.cn/problem/B3602)

**最短路**裸题。

这里介绍 3 种求最短路的算法：

1、**Floyd**

这是一种求**多源最短路径**的算法，运用了 dp 的思想。

核心代码：

```cpp
for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
```

这种算法的时间复杂度为 $O(n^3)$，显然会 **TLE** ，且原题只需求 1 号点到每个点的最短路径长度，多源最短路径算法完全没必要。

2、**SPFA**

这是一种**单源最短路径**的算法，运用了贪心的思想。

核心代码：

```cpp
void spfa(int s){
	for(int i=1;i<=n;i++)
		dis[i]=inf;
	int u,v;
	q.push(s);
	dis[s]=0;
	vis[s]=true;
	while(!q.empty()){
		u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=h[i].next){
			v=h[i].to;
			if(dis[v]>dis[u]+h[i].w){
				dis[v]=dis[u]+h[i].w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
```

这种算法的时间复杂度通常是 $O(kE)$，k 是常数。看起来是一个很好的情况，但是他最坏情况下是 $O(VE)$，在这道题的[弱化版](https://www.luogu.com.cn/problem/B3601)可以通过，但是这道题会卡 SPFA，使我们 **TLE**。

3、**Dijkstra 堆优化**

原版 Dijkstra 的时间复杂度为 $O(n^2)$，无法通过此题，所以我们需要用到 **priority_queue（优先队列）**，才可通过此题。

核心代码：

```cpp
void Dijkstra(int s){
	
	dis[s]=0;
	pq.push((qwq){0,s});
	
	while(!pq.empty()){
		
		f=pq.top();
		pq.pop();
		int u=f.now;
		if(vis[u])continue;	
		vis[u]=1;
		
		for(int i=head[u];i;i=h[i].next){
			int v=h[i].to;
			if(dis[v]>dis[u]+h[i].w){
				dis[v]=dis[u]+h[i].w;
				if(!vis[v])
					pq.push((qwq){dis[v],v});
			}
		}
			
	}
	
}
```

于是这道题就很简单的通过啦。

 _**My code**_ 
 
```cpp
#include<iostream>
#include<cstdio>
#include<queue>

using namespace std;

#define int long long //注意long long

int read(){
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
} //快读

const int inf=0x7fffffffffffffff; //long long的INF
int n,m,s,tot,dis[300005],head[300005];
bool vis[300005];
struct node{
	int next,to,w;
}h[1000005];
struct qwq{
	int dis,now;
	bool operator<(const qwq &x)const{return x.dis<dis;} //重载运算符
}f,v;
priority_queue<qwq>pq; //优先队列

void add(int u,int v,int w){
	
	tot++;
	h[tot].next=head[u];
	h[tot].to=v;
	h[tot].w=w;
	head[u]=tot;
	
} //邻接表

void Dijkstra(int s){
	
	dis[s]=0;
	pq.push((qwq){0,s});
	
	while(!pq.empty()){
		
		f=pq.top();
		pq.pop();
		int u=f.now;
		if(vis[u])continue;	
		vis[u]=1;
		
		for(int i=head[u];i;i=h[i].next){
			int v=h[i].to;
			if(dis[v]>dis[u]+h[i].w){
				dis[v]=dis[u]+h[i].w;
				if(!vis[v])
					pq.push((qwq){dis[v],v});
			}
		}
			
	}
	
} //Dijkstra算法

signed main(){
	
	n=read();
	m=read();
	
	for(int i=1;i<=n;i++)
		dis[i]=inf; //初始化
	
	int u,v,w;
	
	for(int i=1;i<=m;i++){
		u=read();
		v=read();
		w=read();
		add(u,v,w);
	} //存图
	
	Dijkstra(1);
	
	for(int i=1;i<=n;i++)
		printf("%lld ",dis[i]==inf?-1:dis[i]); //输出
	return 0;
	
}
```



---

## 作者：chlchl (赞：6)

Upd 2022.7.25：增加 SPFA 的解法。

Upd 2023.2.23：修改正确性证明中部分错误内容。


# 题目描述
题意很简单，就是让你通过程序求出从结点 $1$ 到其他节点的最短距离。

# 思路
本题做法颇多，这里重点介绍效率最高的 Dijkstra 堆优化算法。

## Dijkstra 堆优化算法
Dijkstra 堆优化算法是一种在**有向无环图**上求最短路的算法，是目前求**最短路效率最高的算法**。

在讲 Dijkstra 堆优化算法前，我们要先了解一个操作：**松弛操作**。

设 $d_i$ 为从结点 $1$ 到结点 $i$ 的最短路，并且现在有两个结点 $u$,$v$，且 $u$ 有一条边连向 $v$。设这条边的权值为 $w$。则松弛算法是这样实现的：

``if(d[u] + w < d[v])	d[v] = d[u] + w;``

这个松弛算法应该很好理解，就是**基于动态规划思想**实现的，应该算是初步的动态规划。

了解了松弛算法之后，我们就可以正式来看 Dijkstra 算法的实现了：

下面是一个有向无环图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bwao3so4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们将 d 数组全部初始化为正无穷，并知道 ``d[1]=0``，之后该算法主要重复两个步骤：

1. 在目前未确定最短路的点中找到最小的点，将其染成红色。
1. 枚举这个点的所有出边，看看能否松弛其他点。

如果不清楚的话，结合我的文字看看下面的图吧：

1. 将结点 $1$ 染红，然后遍历出边，松弛结点 $2$ 和结点 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/zd6d65a1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2. 将结点 $3$ 染红，遍历出边，松弛结点 $2$ 和结点 $5$，其中结点 $2$ 不能松弛。

![](https://cdn.luogu.com.cn/upload/image_hosting/egrqy3px.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

3. 将结点 $2$ 染红，遍历结点 $4$ 和结点 $5$，因为结点 $5$ 之前是 $9$，现在是 $6$，所以可以被松弛。

![](https://cdn.luogu.com.cn/upload/image_hosting/lorghip1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

4. 现在，结点 $4$ 和结点 $5$ 都为 $6$，我这里就直接一步把两个点都染红了。但实际上应该是先染结点 $4$ 再染结点 $5$。大家懂就好（不影响结果）。遍历结点 $1$，结点 $3$ 和结点 $5$。三者都已经确定，所以全部不能松弛。全部节点的最短路都已确定，程序结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/ctmm4v1h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## 正确性证明

- **已选取节点不改性**

对于一直在更新迭代的距离数组 $d$，它的值**只会增加而不会减少**。因为**边的权值都是非负**的，每次更新距离只会在**已选取节点的距离上增加**，不可能存在另一条更短的路。正因如此，**Dijkstra 堆优化算法只能用于非负权图中**，如果出现负权，则该算法可能得出**错误答案**。

- **为什么贪心思路可行？**

设源点（即上图中的 $0$）为 $S$，距离 $S$ 最近的点为 $B$（即上图中的 $3$）。

1. 从 $S$ 直接确定 $B$ 的权值一定是正确的（不难证明）。

**反证法**：假设 $B$ 距离**不是最短**，**那么必定存在一个点 $C$，使得 $S\rightarrow C\rightarrow B$ 这条路比 $S\rightarrow B$ 这条路距离要短**。但是这样**违背了贪心步骤**：假如存在这样的 $C$ 点 我们选取到的**第一个点应该是 $C$ 而不是 $B$。**（因为全是非负权，易得 $S\rightarrow C$ 的距离会比 $S\rightarrow B$ 的距离小）。

2. 对于已经选取过的点，不妨把它看作为一个大的源点 $S$，那么新考虑的点符合上述的情况，归纳得证。

2.1. 为什么可以把选过的点看成一个更大的 $S$？
根据算法步骤 $2$，我们对**每一个选取过的结点的邻接点都尝试了松弛操作**，那就**不存在有大源点 $S$ 向外部的点的连边丢失**。如果大源点 $S$ 内有**多条边指向同一个外部节点 $x$**，其实最终也只会**保留最短的边**，因为其他更长的边权**被松弛替代了**。

3. 为什么不能负权？

这个比较好证明：如果有一条边权为负（设两个端点分别为为 $u$，$v$），那么就会出现这种情况：当全部点的最短路确定后，我们惊讶地发现：如果**在 $v$ 的最短路确定的情况下**，通过**走 $v\rightarrow u$ 这条路**，可以**使 $u$ 的最短路更短**。贪心思路失败，**因此不能出现负权**。

为什么松弛的时候不会直接走负权？很简单，负权的那条边对应的起点**不一定是当前点中到起点距离最小**的。而松弛其它边的时候有可能**把负权边的另一头也松弛掉了**。一旦终点那头被松弛，按照 dijkstra 的贪心思路，这一定是它的最短路，所以不会再动，就忽略了那条负权。

我们使用优先队列优化，每次都取距离最小的节点进行松弛。每个节点都**只会入队一次**，相应的**每条边也只会遍历一次**，加上优先队列单次插入、查询的复杂度，总时间复杂度是 $O((n+m)\log n)$。

------------
## SPFA 算法
SPFA 没有 dijkstra 稳定，最优效率也不如后者，但是它可以处理负权的情况，也可以判断负环，在某些情况下也要快于 dijkstra 的堆优化版本。

所以在一年后的今天，我加上了 SPFA 的解法（~~主要是学网络流，写一写当复习~~）。

SPFA 的原理与 dijkstra 很像，都是利用了松弛操作求最短路。但它程序执行的步骤不一样：
1. SPFA 使用普通队列，这意味着无法保证当前节点是距离最小的那个，所以一个点可能出队之后又再次进队。
2. 使用 $inque$ 数组标记节点是否在队列中。
3. 使用 $cnt$ 数组记录每个节点入队次数。如果某个节点进队次数大于等于 $n$，证明图中存在负环（这个待会会提到）。

其它就与 Dijkstra 很像了，放个带注释模板供大家参考理解：
```cpp
bool spfa(int s){
	memset(d, 127, sizeof(d));
	memset(inque, 0, sizeof(inque));//初始化
	d[s] = 0;
	q.push(s);
	inque[s] = 1, cnt[s]++;//登记起点信息
	while(!q.empty()){
		int u = q.front();
		q.pop();
		inque[u] = 0;//pop 掉以后把u标记为未入队
		for(int i=0;i<g[u].size();i++){
			int v = g[u][i].v;
			int w = g[u][i].w;
			if(d[u] + w < d[v]){
				d[v] = d[u] + w;//松弛
				if(inque[v] == 0){
					q.push(v);
					inque[v] = 1, cnt[v]++;//进队、进队标记、进队次数的变化
					if(cnt[v] == n)	return false;//存在负环，返回无解
				}
			}
		}
	}
	return true;//程序顺利结束，有解
}
```
### SPFA 判断负环
为什么某个节点进队次数大于等于 $n$ 就证明有负环？

首先我们明确负环的定义：图上的一个环，其边权之和为负。我们知道，这样的环是不存在最短路解的，因为可以越走越小。

一个节点的入度最多只有 $n-1$，即其他节点都与该节点有连边。当一个节点入队次数为 $n$ 时，证明有 $n$ 条路径都通向该节点。又因为入度最多只有 $n-1$，根据鸽笼原理，至少有两条路是重复的，即存在环。

存在环还不算什么，要是边权和是正的，走完整个环距离还是会变大。我们的程序是不会傻乎乎地看到环就撞进去的。所以只有一种可能：那就是出现了一个边权之和为负的环，也就是负环。



最后是时间复杂度：由于一个点可能进队多次，即一条边可能会被遍历多次，所以 SPFA 的时间复杂度是 $O(KE)$（$K$ 是常数，$E$ 为边数）。但是最坏情况下（好像是菊花图），SPFA 的时间复杂度可以被卡到 $O(VE)$（$V$ 是节点数）的。

在本题的弱化版（即 B3601）可用 SPFA 通过，但是本题就不行。尽管如此，SPFA 相比于 Dijkstra 却更重要。因为它在很多后续算法中都需要使用，因此务必牢记该算法（~~为什么不用 DIjkstra？还不是因为那该 s 的负权~~）。

~~归程：关于 SPFA，它死了……~~

## 一些小坑
- 输出时记得判断自环。
- 输入时注意重边。
- **五年 OI 一场空，不开 ``long long`` 见祖宗**。一定要记得开 ``long long``。
- 在本题中，用 ``memset`` 来初始化为 $127$ 是不行的，因为数据范围可能超出 ``int`` 范围，$127$ 并不是最大值。所以，应该用最朴素的循环手动赋一个很大的值。

## 代码
我使用 dijkstra 堆优化算法。以下是参考代码，珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

struct edge{
	ll u, v, w;
};

const int N = 2000 + 10;
vector<edge> g[N];
priority_queue<pair<ll, ll> > q;
int n, m, u, v, w, d[N], visit[N];
//d[i]表示每个点到起点的距离，visit[i]表示是否确定最短路 

void dijkstra(ll s){//s为起点 
	memset(d, 127, sizeof(d)); 
	memset(visit, 0, sizeof(visit));//初始化 
	d[s] = 0;
	q.push(make_pair(0, s));//起点信息入队 
	while(!q.empty()){
		ll u = q.top().second;//取出队头元素的编号 
		q.pop();
		if(visit[u] == 1)	continue;//这里是堆优化算法的核心，如果已经染色了，就不用再循环了 
		visit[u] = 1;//模拟将最小的点染成红色 
		for(int j=0;j<g[u].size();j++){//枚举所有出边 
			ll v = g[u][j].v;//出边所指的点 
			ll w = g[u][j].w;//v的权值 
			if(d[u] + w < d[v]){//松弛操作 
				d[v] = d[u] + w;
				q.push(make_pair(-d[v], v));//为什么是-d[v]？自己思考一下~ 
			}
		}
	}
}

int main(){
	cin >> n >> m;
	for(int i=1;i<=m;i++){
		cin >> u >> v >> w;
		g[u].push_back((edge){u, v, w});
	}
	dijkstra(1);
	for(int i=1;i<=n;i++){
		if(d[i] == 2139062143)	cout << -1 << ' ';
		else	cout << d[i] << ' ';
	}
	cout << endl;
	return 0;
}
```
本篇题解到此结束，如果对你有帮助记得点个赞哦！

---

## 作者：Unordered_OIer (赞：2)

# B3602 题解

最短路水题（

## Description
- 给定一张 $n$ 节点的**有向有权**图
- $\forall\ 1 \leq i \leq n$，求 $1 \rightarrow i$ 的最短路

## Solution

从 $0$ 讲起。

首先，看到最短路这个问题，我们的第一反应是 Dijkstra/BellmanFord，这两个算法的复杂度的最差情况可以达到 $\mathcal O(VE)$，但是看到题目的数据范围：

- $1 \leq n,m \leq 3 \times 10^5$

所以，我们需要对其进行优化。

### 1. dijkstra

普通 dijkstra 不再细讲了，它的步骤可以大致分为两步：

1. 找一个当前到 $1$ 距离最小的节点 $u$
2. 查找 $u$ 的所有邻居 $v$ 更新最短路

我们知道 2 步骤肯定是无法避免的，但是这个 1 步骤似乎耗费了很多的时间复杂度。

可以考虑优化 1 操作，其本质上就是做 $\max\limits_{i=1}^n dis[i]$，普通做是需要一个 for 循环去枚举的。

所以我们希望能够降低枚举的复杂度，那么也就自然想到了 STL 中的 priority\_queue。

实现的时候有一个问题，priority\_queue 取 top 的时候取到的是最大值，需要自定义一下 “<” 号。

### Code

```cpp
inline void dijkstra(){
	fill(d, d + n + 5, inf);
	d[1] = 0; q.push((node){0, 1});
	while(!q.empty()){
		ll u = q.top().u; q.pop();
		if(vst[u]) continue;
		vst[u] = 1;
		for(ll i = hd[u]; i; i = es[i].nxt){
			ll v = es[i].t;
			if(!vst[v] && d[v] > d[u] + es[i].w){
				d[v] = d[u] + es[i].w;
				q.push((node){d[v], v});
			}
		}
	}
}
int main(){
	n = read(), m = read();
	for(ll i = 1, u, v, ww; i <= m; i++){
		u = read(), v = read(), ww = read();
		add(u, v, ww);
	}
	dijkstra();
	for(ll i = 1; i <= n; i++) write(d[i] != inf ? d[i] : -1), putchar(' ');
	puts("");
	return 0;
}
```

### 2. BellmanFord
本质上就是个暴力

它的算法步骤是：

1. 遍历每一条边，对于 $u \rightarrow v$，权重为 $w$ 的边，$dis[v] \leftarrow \min(dis[v],dis[u]+w)$
2. 重复如上操作 $n-1$ 次

显然，对于操作 1 来说，只有更新过 $u$ 的 $v$ 才会对最终的 $u$ 有贡献，因此考虑把更新过 $u$ 的 $v$ 进行入队操作。

然后每次更新的时候直接从队首拿出来更新就行了。

这就是著名的 SPFA(Shortest Path Faster Algorithm) 算法。

### Code

```cpp
inline void spfa()
{
	fill(dst, dst + n + 5, INF);
	queue<ll> q;
	dst[1] = 0;
	in[1] = 1;
	q.push(1);
	while(!q.empty())
	{
		ll u = q.front(); q.pop();
		in[u] = 0;    // in queue
		for(ll i = 0, v; i < to[u].size(); i++)
			if(dst[v = to[u][i]] > dst[u] + w[u][i])
			{
				dst[v] = dst[u] + w[u][i];
				if(!in[v])
				{     // push
					q.push(v);
					in[v] = 1;
				}
			}
	}
}
```

## Something Else

SPFA 这个算法是可以被卡到 $\mathcal O(VE)$ 的。

例如下面的一类图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7b0lqnel.png)

它的最短路是

![](https://cdn.luogu.com.cn/upload/image_hosting/4obscxan.png)

于是就被迫的要做 $\mathcal O(VE)$ 次更新，SPFA 也就退化了（

所以只要题目里是正权图，最好用堆优 dij，SPFA 说不定会被卡。

---

## 作者：Kagamino_Natsumi (赞：2)

## B3602 最短路问题_2 题解

## 题意

给定一张n个点、m条边的有向图，求1号点到每个点的最短路径长度。

$1\leq n,m\leq 3×10^5$ ，$1\leq w_i\leq 10^9$

## 前置芝士

链式前向星， STL priority_queue

若没有学习过这两块知识，可分别参阅[链式前向星视频教程](https://www.bilibili.com/video/BV1mJ411S7BB)和[P1090题解](https://www.luogu.com.cn/problem/solution/P1090)

## 一、单源最短路问题

单源最短路问题（Single Source Shortest Path，即SSSP问题），即为像本题一样，求图中一个源点到每个点的最短路径长度的问题。此问题有多种解决方式，每种方式各有优劣。本题解主要介绍的是Dijkstra算法。这种算法仅能解决边权均为非负数时的最短路。

## 二、普通的Dijkstra算法

Dijkstra算法基于贪心思想，时间复杂度为 $O(n^2)$。
令源点为 $s$，其算法流程分为如下几步：

第一步，建立一个数组 $dis$ 存储源点到每个点的最短路长度，并初始化 $dis_s$ 为 $0$，其余结点的 $dis$ 值为 $INF$ 。

第二步，找到一个结点 $u$，使此结点为**未被标记的点**中 $dis$ 值最小的点。

第三步，对于结点 $u$ 有边相连的所有结点 $v$，更新 $dis_v=\min(dis_v,dis_u+edge_{u,v})$，并给 $u$ 打上标记。

第四步，重复2~3两个步骤 $n-1$ 次。此时所有结点的 $dis$ 值即为源点 $s$ 到该点的最短路长度。若有 $dis[x]=INF$ 成立，则说明从源点 $s$ 无法到达结点 $x$。若重复时存在找不到满足条件的 $u$ 的情况，则直接退出循环。

此算法的正确性在于，图的每条边权值均为非负数，则第2步中选出的结点 $u$ 在选出时，已经满足 $dis[u]$ 等于源点到 $u$ 的最短路长度。在此基础上更新其余结点，则其余结点被取出时也能满足上述条件。

根据上述流程，我们可以打出以下的代码（建图等过程省略）：

```cpp
typedef long long ll;//下面出现的ll即为long long
const int MAXN=300007;
const ll INF=0x3f3f3f3f3f3f3f;
struct node{
	int nxt;
	int to;
	ll w;
}g[MAXN];
int head[MAXN],tot,n,m;
vector<ll>dijkstra(int s)//将答案封装成vector
{
	vector<ll>dis(n+1,INF);//初始化，相当于建立一个长度为n+1的数组，并全部赋值为INF
	dis[s]=0;
	for(int i=1;i<n;i++){
		int u=0;
		for(int j=1;j<=n;j++){
			if(!vis[j]&&(u==0||dis[j]<dis[u]))u=j;
		}//流程第2步，寻找符合条件的结点u
		if(!u)break;//特殊情况：找不到满足的u，这意味着由源点不能到达目前没有标记的剩余点
		vis[u]=1;//标记
		for(int j=head[u];j;j=g[j].nxt){//遍历起点为u的所有边
			int v=g[j].to;
			dis[v]=min(dis[v],dis[u]+g[j].w);//更新最短长度
		}
	}
	return dis;
}
```

时间复杂度 $O(n^2)$，[评测结果](https://www.luogu.com.cn/record/52321153)
## 三、堆优化的Dijkstra算法

让我们审视一下数据范围，$1\leq n\leq 3×10^5$，故上面的解法并不能得到AC。观察代码，发现此解法的瓶颈在于第$2$步寻找最小值的过程。于是，我们需要一个数据结构，支持插入，查询最小值，删除最小值等操作。什么数据结构可以担此重任呢？二叉堆（STL priority_queue）！这样，单次查询最小值的时间就从 $O(n)$ 降到了 $O(\log\ n)$ ，从而取得AC。总时间复杂度为 $O(m \log n)$ 。

具体实现过程可观看注释。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=300007;
const ll INF=0x3f3f3f3f3f3f3f;//要设的足够大
struct node{
	int nxt;
	int to;
	ll w;
}g[MAXN];
int head[MAXN],tot,n,m;
bool vis[MAXN];
void add(int a,int b,ll c)//链式前向星加边
{
	tot++;
	g[tot].w=c;
	g[tot].nxt=head[a];
	g[tot].to=b;
	head[a]=tot;
}
vector<ll>dijkstra(int s)
{
	vector<ll>dis(n+1,INF);//初始化
	priority_queue<pair<ll,int>,vector<pair<ll,int> >,greater<pair<ll,int> > >q;
	//二叉小根堆，在取出堆顶时堆顶保存的即为最小值
   //pair<ll,int>为第一维为dis[u]，第二维为u的二元组
	dis[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		pair<ll,int>tmp=q.top();//取出堆顶
		int u=tmp.second;
		q.pop();
		if(vis[u])
			continue;//结点u已经被访问过，就不能再用u来更新了
		vis[u]=1;//打标记
		for(int i=head[u];i;i=g[i].nxt)//遍历每条边
		{
			int v=g[i].to;
			if(dis[v]>dis[u]+g[i].w)
			{
				dis[v]=dis[u]+g[i].w;//更新最小值
				q.push(make_pair(dis[v],v));//将新获得的值插入堆中
			}
		}
	}
	return dis;
}
int main()
{
	scanf("%d%d",&n,&m);
	int xx,yy;ll zz;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%lld",&xx,&yy,&zz);
		add(xx,yy,zz);//连边
	}
	vector<ll>dis=dijkstra(1);
	for(int i=1;i<=n;i++)
	{
		if(dis[i]==INF) //不连通，输出-1
			printf("-1 ");
		else //否则dis[i]即为答案
			printf("%lld ",dis[i]);
	}
	printf("\n");
	return 0;
}
```

[AC](https://www.luogu.com.cn/record/52321595)

## 四、后记

求解SSSP问题常用的算法还有SPFA算法，可以求解带有负权边图的单源最短路，时间复杂度一般为 $O(km)$，其中 $k$ 是一个较小的常数，但在数据经过特殊构造的情况下会降到 $O(nm)$。所以，在图中只有非负权边时，还是选用更快的Dijkstra算法比较明智。

---

## 作者：luozhichen (赞：1)

正刷着水题，却突然发现了这道题目。刚好是我们昨天学的，于是前来巩固。

**题意**：给我们 $n$ 个点,$m$ 条边，每个边都有个长度，让我们求从 1 到各个点的最短路径。

**思路**：这道题它的权值（也就是路径）大于等于 $1$，所以就可以用 Dijkstra 来解这道题。（~~因为我暂时只学懂了这个算法~~）由于怕数据点卡我，于是我和题目斗智斗勇，加上了堆优化。这也是很经典的 SSSP 题目(单源最短路问题），值得去刷。对于这种题目有几种做法：

1.Dijkstra 算法。

2.用了优先队列的 Dijkstra。

3.Bellman-Ford 算法

4.SPFA

接下来介绍一下 Dijkstra。Dijkstra (迪杰斯特拉)算法是典型的**单源最短路径算法**，用于计算一个节点到其他所有节点的最短路径。主要特点是**以起始点为中心向外层层扩展，直到扩展到终点为止**。

**算法思想** ： 设 $G=(V,E)$ 是一个带权有向图，把图中顶点集合 $V$ 分成两组，第一组为已求出最短路径的顶点集合（用 $S$ 表示，初始时 $S$ 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 $S$ 中，直到全部顶点都加入到 $S$ 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用 $U$ 表示），按最短路径长度的递增次序依次把第二组的顶点加入 $S$ 中。在加入的过程中，总保持从源点 $v$ 到 $S$ 中各顶点的最短路径长度不大于从源点 $v$ 到 $U$ 中任何顶点的最短路径长度。此外，每个顶点对应一个距离，$S$ 中的顶点的距离就是从 $v$ 到此顶点的最短路径长度，$U$ 中的顶点的距离，是从 $v$ 到此顶点只包括 $S$ 中的顶点为中间顶点的当前最短路径长度。
普通的 Dijkstra 的时间复杂度是 $O(n^2)$，由于出题者可能不怀好意所以我们就用堆优化的。时间复杂度只需要$O((n + m) * log m)$。

**算法证明：**
![](https://cdn.luogu.com.cn/upload/image_hosting/cmor0vw2.png)

**代码分析**：首先把那些路径全部输入，然后用[链式前向星存图](https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE&fenlei=256&rsv_pq=f7fe6b6f0002ae48&rsv_t=172fFT1OpR7P8jIJX%2FEeIiPHoMUNNWtSphjpR9KB0i812RTd1kiRzToDrhY&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_sug3=20&rsv_sug1=18&rsv_sug7=100&rsv_sug2=1&rsv_btype=i&prefixsug=%25E9%2593%25BE%25E5%25BC%258F%25E5%2589%258D%25E5%2590%2591%25E6%2598%259F&rsp=0&inputT=8274&rsv_sug4=8275)。
```cpp
int cnt,z[1000001],qz[1000001],next[1000001],f[100001];
void add(int a,int b,int c){
	cnt++;
	z[cnt] = b;
	qz[cnt] = c;
	next[cnt] = f[a];
	f[a] = cnt;
}
```

后面是Dijkstra部分
```
for(int i = 1;i <= n;i++){
	d[i] = inf;//初始化，让d[1] = 0
}
d[1] = 0;
q.push(make_pair(0,1));////这里采用C++自带二元组编写。注2* 
while(q.size()){//当堆中还有元素 
	int x = q.top().second;
	q.pop();//取完就删 
	if(visited[x]){//判断有没有经过
		continue;
	}
	visited[x] = 1;//把它标记为走过
	for(int i = f[x];i;i = next[i]){
		if(d[z[i]] > d[x] + qz[i]){//dijkstra算法核心语句 
			d[z[i]] = d[x] + qz[i];//替换
			q.push(make_pair(d[z[i]],z[i]));//每次松弛成功，把关于当前点的信息压入堆。
		}
	}
}
注2：C++自带的二元组pair,定义方法是pair<(数据类型1),(数据类型2)>(名称)。相当于一个包含两个变量的结构体。pair中的两个成员使用.first和.second进行访问。在优先队列里，pair是以first为第一关键字、以second为第二关键字排序的。向pair中插入元素可以直接像结构体一样赋值，也可以使用make_pair()插入。 
```

**完整代码**：
```
#include<bits/stdc++.h>
using namespace std;
const int inf = 2147483647;
priority_queue <pair<int,int>,vector<pair<int,int> //STL优先队列（使用pair的情况下）的定义方法。由于要采用小根堆，所以需要这样定义。注* >,greater<pair<int,int> > >q;
int n,m,s,u,v,w;
long long z[1000001],qz[1000001],cnt,d[10000001],next[10000001],f[10000001];
bool visited[1000001];
void add(int a,int b,int c){//链式前向星存图
	cnt++;
	z[cnt] = b;
	qz[cnt] = c;
	next[cnt] = f[a];
	f[a] = cnt;
}
int main(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		cin >> u >> v >> w;
		add(u,v,w);
	}
	for(int i = 1;i <= n;i++){
		d[i] = inf;
	}
	d[1] = 0;//初始化dis数组
	q.push(make_pair(0,1));//这里采用C++自带二元组编写。注2*
	while(q.size()){ 
		int x = q.top().second;//q.top()取出堆顶，也就是当前距离起点最近的点。
		q.pop();//取完就删 
		if(visited[x]){
			continue;
		}
		visited[x] = 1;
		for(int i = f[x];i;i = next[i]){
			if(d[z[i]] > d[x] + qz[i]){
				d[z[i]] = d[x] + qz[i];
				q.push(make_pair(d[z[i]],z[i]));
			}
		}
	}
	for(int i = 1;i <= n;i++){
		if(d[i] == 2147483647){
			cout << "-1 ";
			continue;
		}
		cout << d[i] << " ";
	}
	return 0;
}
注：priority_queue<(数据类型)>的定义方法默认是大根堆。只有priority_queue<(数据类型),vector<(数据类型)>,greater<(数据类型)> >的方法才能定义小根堆。另外，应该用空格分开两个连在一起的尖括号(<<或>>)，否则编译器会把它识别成流读取运算符。
 	当然，你也可以选择重载运算符，不过我觉得这样更好些。毕竟不少人不会重载。
 	另外，优先队列虽然等价于堆，但是内部原理是通过给予变量一个优先值来实现的，与堆不同。
注2：C++自带的二元组pair,定义方法是pair<(数据类型1),(数据类型2)>(名称)。相当于一个包含两个变量的结构体。pair中的两个成员使用.first和.second进行访问。在优先队列里，pair是以first为第一关键字、以second为第二关键字排序的。向pair中插入元素可以直接像结构体一样赋值，也可以使用make_pair()插入。 
```

思路来自于 Ophelia 的 P3371 的博客。

蒟蒻的代码，如有不足，请大佬指教。

---

## 作者：ZBAA_MKC (赞：1)

这是一道最短路的模板题。

看数据范围，$n,m ≤ 3 \times 10^5$,普通的   $\text{dijsktra}$ 时间复杂度 $O(n^2)$, 肯定通不过，而 $\text{SPFA}$ 容易被卡，我们要采用堆优化 $\text{dijsktra}$ 算法。

算法思想我就不多介绍了，就是用 $\text{STL}$ 中的优先队列来优化找最小值。时间复杂度 $O((n+m)  \ log_2\ n)$。

重边和自环忽略即可，因为上述算法不会首它们的影响。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long inf = 1e15 + 7; //inf要足够大

struct edge
{
	long long w;
	long long v; 
};

struct node
{
	long long pos;
	long long dis;
	bool operator <(const node &a)const //给priority_queue重载运算符
	{
		return dis > a.dis;
	}
};

vector<edge> adj[300005];
priority_queue<node> q;
long long dist[300005];
bool vis[300005];
long long n, m, s;

void djstl()
{
	for(int i = 1; i <= n; i++)
	{
		vis[i] = false;
		dist[i] = inf;
	}
	node node_u;
	node_u.pos = s;
	node_u.dis = 0;
	q.push(node_u);
	dist[s] = 0;
	while(!q.empty())
	{
		node_u = q.top();
		q.pop();
		if(vis[node_u.pos] == true)
		{
			continue;
		}
		vis[node_u.pos] = true;
		for(int i = 0; i < adj[node_u.pos].size(); i++)
		{
			long long v = adj[node_u.pos][i].v;
			long long w = adj[node_u.pos][i].w;
			if(dist[node_u.pos] + w < dist[v]) //松弛，拐弯
			{
				dist[v] = dist[node_u.pos]+w;
				node tmp;
				tmp.dis = dist[v];
				tmp.pos = v;
				q.push(tmp);
			}
		}
	}
}

int main(){
	scanf("%lld%lld", &n, &m);
    s = 1;	
	int u;
	edge vw;
	for(int i = 0; i < m; i++) //邻接表存图
	{
		scanf("%d%lld%lld", &u, &vw.v, &vw.w);
		adj[u].push_back(vw);
	}
	djstl();
	for(int i = 1; i <= n; i++) //输出
	{
		if (dist[i] == inf)
        {
            cout << "-1 ";
            continue;
        }
        cout << dist[i] << " ";
	}
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：1)

## 原文阅读

[**重学最短路：步步递进，层层紧逼**](https://www.luogu.com.cn/blog/LinearExpectation/shortest-path-in-another-sight)

由于本题并不涉及那么多种的最短路算法，这里只介绍 Dijkstra 一种。

## Dijkstra 基础

现在我们一共有 $n$ 个节点，$m$ 条边（大概是有向边），以及一个初始节点 $s$，要求我们求出从 $s$ 到其他所有节点的最短路，怎么办呢？

首先我们需要一个数组 $d$，用于存储从 $s$ 到 $1\sim n$ 的最短路长度，表示为 $d_1\sim d_n$。于此类似的，我们需要一个 $e$ 数组来存储整张图，$e_{u,v}$ 表示从 $u$ 到 $v$ 的路径长度。此外，我们还需要一个数组 $vis$ 来确定从 $s$ 到一个节点的最短路是否被确定了。

首先，我们可以把 $s$ 的所有出边都加入到 $d$ 数组中，譬如这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/d3qg0843.png)

如果令 $s=1$，那么它的 $d=\{0,5,3,2,\infty,\infty\}$

接着我们需要在这个数组中找到最小的那个节点——也就是离出发点最近的那个节点，你会发现，这个记得点是 $4$，那么我们考虑走向 $4$ 号节点。

这时这个 $4$ 号节点的最短路就已经确定了，为什么？因为如果走任何一条其他路，刚走第一步就会比这条最短路要长，所以，直接走到 $4$ 必然比绕其他的路要来的短。那么，我们标记 $4$ 为已经确定最短路的点

接着我们要做的是考察 $4$ 号节点的所有出边，这时你需要看一看的是，如果我们从 $4$ 经过再到某个节点 $x$，会不会比直接从 $1$ 到 $x$ 更近？如果是的，那么更新最短路就可以了。

你发现 $1\to 4\to 5$ 长度为 $8$，比 $d_5=\infty$ 要小多了，那么更新吧！此时的的 $d=\{0,5,3,2,8,\infty\}$

这时，未确定最短路的点中，最小的是 $3$ 了，那就走向 $3$ 吧，并且把他标记为已经确定。$3$ 的出边指向 $4,5$，此时执行如下：

- $(1\to 3\to 4)>(1\to 4)$，不需要更新。
- $(1\to 3\to 5)<(1\to 4\to 5)$，需要更新。

这时候发现有一条路比原有的 $d_5$ 更小！那么就可以更新了更新完是这样：$d=\{0,5,3,2,7,\infty\}$。此时的 $vis$ 数组中 $1,3,4$ 都已经被确定了。我们把目光投向 $2$。

继续更新！此时的 $2$ 一共有 $3,6$ 两个出边，作类似的判断之后我们发现只有 $6$ 可以更新，那么 $d=\{0,5,3,2,7,10\}$，$vis={1,2,3,4}$。

接着的更新内容就简单地概述了：

- 看向 $5$ 号节点。
- 更新不了节点，$5$ 号设为确定。
- 看向 $6$ 号节点。
- 更新不了节点。

算法结束。这时候你会发现，有一部分边是没有走过的，我们只遍历了一些点，并且一直在走“权值最小”的那条路。这似乎是贪心，那么，他为什么正确呢？

对于一个不含负边的图，全局最小值不可能再被其他节点更新，因为每当 $x$ 被纳入了 $vis$ 数组，他的最短路就已经确定了，正如前文所说：“如果走任何一条其他路（走已经更新的最短路），所使用长度必然的比当前这条最短路要长，所以，现在这条老路不可能再被其他已确定最短路更长的路径更新了。”

由于这种算法不包含后悔的情况，所以不能应对含负权边的图。

由于有 $n$ 个节点，每个节点必然走过一次，且每次都需要在 $n$ 个 $d_i$ 中找最小值，且每次都要在找所有的出边，所以时间复杂度是 $O(n^2)$ 的。

## Dijkstra 优化

我们发现，在 $d$ 数组中找到最小值的这个过程可以优化，怎么优化呢？

如果用堆优化是 $O(m\log n)$，如果用优先队列时 $O(m\log m)$。但是也有说法说堆优化是 $O((n+m)\log n)$，似乎还挺优秀的。

由于 $m$ 最大时可以达到 $n^2$ 级别，所以时间复杂度看着办吧。似乎对于普通的数据并不容易出现 $m=n^2$ 这种情况（稠密图），所以对于随机数据，你可能可以选择卡常而不优化，但是面对刻意为之的数据，你不得不承认：这个优化是广泛而且有效的。

接下来的代码用链式前向星存图，如果不会请回到本文开头找资料。

首先你需要一个 $\rm\small node$ 类型，这种类型包含两个信息：$\rm\small id,dis$，分别是上文所说的“下标”和“距离起点的长度”。下标也就是这个节点的编号。接着我们重载运算符，让 $<$ 比较的“依据”是距离起点的长度，这样我们导入优先队列时，就自然按照距离排序，我们也就能够很容易取出“距离最短”的那个点了。

这一段的参考代码：

```cpp
struct node{
    int dis,id;
    bool operator <(const node &x)const{
        return x.dis<dis;
    }//重载运算符，比较节点的方式是比较其相距起点的距离
	//便于之后使用优先队列比较 
};
```

然后我们每次取出队头、弹出就行了。注意一些小优化：

- 处理 $x$ 节点时，如果他已经被处理过，就跳过。

为什么“已经确定”的节点还会再遇到一次？这是因为优先队列只能对队头进行操作，不能够实现删除任意元素，所以我们每次松弛都要压入。那这样为什么不会影响正确性呢？因为我们每次取出节点，都是取它“所有在队列中值”最小的那个，而既然“最小”，必定更符合要求，所以是正确的的。

- 遍历 $x$ 的出边 $y$ 的时候，如果处理过，就跳过。

没什么有用的优化，但是看着代码逻辑更清晰。

这里给出全文代码，可以结合注释理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 1000005
#define MAXM 3000005
#define INF 4557430888798830399
struct edge{
	int to,w,nxt;
}e[MAXM];
int head[MAXN],dis[MAXN];
int n,m,s,cnt;
bool sure[MAXN];//通往该节点的最短路是否确定 
struct node{
    int dis,id;
    bool operator <(const node &x)const{
        return x.dis<dis;
    }//重载运算符，比较节点的方式是比较其相距起点的距离
	//便于之后使用优先队列比较 
};
void addedge(int u,int v,int w){
    e[cnt].w=w;//权值为 w 
    e[cnt].to=v;//终点为 v 
    e[cnt].nxt=head[u];//接到 u 的 "邻居链表" 开头 
    head[u]=cnt++;//把 "开头 " 更新为这条边 
}void init(){//初始化
    for(int i=0;i<=n;i++){
    	head[i]=-1;//尚未连边 
    	e[i].nxt=-1;//每个节点都没连边 
	}cnt=0;//一条边都没有 
}priority_queue<node>q;
void Dijkstra(){
	dis[1]=0;q.push((node){0,1});//压入起点 
	while(!q.empty()){
		node cur=q.top();q.pop();//当前处理的节点 
		int x=cur.id,d=cur.dis;
		if(sure[x])continue;//如果这个节点的最短路已经确定，跳过
		sure[x]=1;//否则标记为确定，并且开始着手确定
		for(int i=head[x];~i;i=e[i].nxt){//遍历出边 
			int y=e[i].to;//取出这条边 
			if(sure[y])continue;//如果取出了，就跳过 
			if(dis[y]>dis[x]+e[i].w){//如果路径更短 
				dis[y]=dis[x]+e[i].w;//松弛 
				q.push((node){dis[y],y});//加入队列 
			}
		}
	}
}signed main(){
	scanf("%lld%lld",&n,&m);
	init();//初始化 
	for(int i=0;i<=n;i++)dis[i]=INF;//全部设为 INF 
	for(int i=0;i<m;i++){
		int u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		if(u!=v)addedge(u,v,w);
	}Dijkstra();
	for(int i=1;i<=n;i++){
	    if(dis[i]==INF)printf("-1 ");
	    else printf("%lld ",dis[i]);
	}
	return 0;
}
```

之所以能应对重边，因为你存储的时候会把两个边都存下来。

这道题目需要注意 $\inf$ 的设置需要足够大。

---

## 作者：无咕_ (赞：1)

## 题解索引
1. **题目大意**
2. **Solution**
3. **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：57（最短路一般短不到哪去）

------------

## 题目大意
题面： [<传送门>](https://www.luogu.com.cn/problem/B3602)

题意：给一张 $n$ 个点 $m$ 条边的 **有向图** ，可能带有 **重边** 与 **自环** ，求点 $1$ 到点 $i(1\le i \le n)$ 的最短路径。

~~术语理解：堆优dij板子题。~~

## Solution
 
首先讲一下自环与重边以及解决方式，以及选择算法、存储的方式。

### 重难点介绍

#### 自环

指图中有边指向两个相同点，即边 $x$ 从点 $i$ 出发指向点 $i$ 。

#### 重边

指图中有起点和终点相同的边（权值不一定相等），即两条边 $x$ 、 $y$ 均从点 $i$ 指向点 $j$ ，且权值分别为 $w_{1}$ 与 $w_{2}$ 。

### 选择存储方式

#### 邻接矩阵

数据范围 $n\le 3\times 10^{5}$ ，邻接矩阵是二维的，肯定开不起来

#### 邻接表与链式前向星

其实如果这两个再用不了的话，基本就没有存储方式可以过了

因为数据范围是 $n,m\le 3\times 10^{5}$ ，爆不掉

本文中使用链式前向星

### 算法选择

#### Floyd

不会吧不会吧，不会真有人在这么大的数据范围用Floyd吧？

#### Dij

$n\le 3\times 10^{5}$ ，开 $O(n^{2})$ 指定爆炸

#### 堆优Dij

一般情况下，只要没有负权就用 [堆优Dij](https://www.luogu.com.cn/blog/wugu-2333/dijkstra-dui-you-hua) ，优秀的时间复杂度仅仅只有 $O(n \log n)$ 

### 自环与重边具体解决方式

~~笑死，根本不用解决~~

首先看自环，因为堆优Dij原本就有标记数组，也不必担心卡在自环里 ~~无法自拔~~ 跳不出来

其次是重边，这个更加好理解。我提个小问题来讲：

对于起点 $u$ 与终点 $v$ ，如果存在两条边（方向一致），权值分别为 $w_{1}$ 与 $w_{2}$ 。如果已知 $w_{1} > w_{2}$ ，那么换做是你来选 **最短路** 的话，你会选哪条边呢？

无疑是权值为 $w_{2}$ 的这条边，因为它最短啊……

所以，在两个点之间多条路，长的那条边总会被短的比下去，如此循环往复， **重边并不影响结果**

## AC code

题目中强调了 ~~不开 `long long` 见祖宗~~ 要开 `long long` ，但因为编号最高也才到 $n$ 所以编号类的用 `int` 就够了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MAXN=3e5+9,MAXM=6e5+9;//注意边要开2倍大
struct Edge{
    int nxt,to;
    long long w;
}edge[MAXM];
int head[MAXN],num_edge=0;
int n,m;
long long dis[MAXN];
bool path[MAXN];
struct priority{
    int id;
    long long w;
    bool operator <(const priority &x)const{return w>x.w;}
};
priority_queue<priority>q;
void add_edge(int from,int to,long long w){
    edge[++num_edge]={head[from],to,w};
    head[from]=num_edge; 
}void Dijkstra(int s){
    memset(dis,0x3f,sizeof(dis));
    memset(path,0,sizeof(path));
    q.push((priority){s,0});
    dis[s]=0;
    while(!q.empty()){
        priority x=q.top();
        q.pop();
        int id=x.id;
        if(path[id])continue;
        path[id]=1;
        for(int i=head[id];i;i=edge[i].nxt){
            int to=edge[i].to;
            if(dis[to]>dis[id]+edge[i].w){
                dis[to]=dis[id]+edge[i].w;
                q.push((priority){to,dis[to]});
            }
        }
    }
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++){
        int u,v;
        long long w;
        scanf("%d %d %lld",&u,&v,&w);
        add_edge(u,v,w);
    }Dijkstra(1);
    for(int i=1;i<=n;i++){
        if(dis[i]==4557430888798830399)printf("-1 ");
        else printf("%lld ",dis[i]);
    }
    return 0;
}
```
AC记录[<传送门>](https://www.luogu.com.cn/record/52989620)

## 类似题型

[P1359 租用游艇](https://www.luogu.com.cn/problem/P1359)

（其实这种类型的题挺多的，大多都是板子一套改改数据改改几行代码就能AC的）



---


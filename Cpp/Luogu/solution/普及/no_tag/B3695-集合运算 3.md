# 集合运算 3

## 题目背景

关于集合、交集、并集的定义请参考 https://www.luogu.com.cn/problem/B3633 。

以下给出对称差的定义：

对两个集合 $A, B$，规定 $A$ 和 $B$ 的对称差 $A \Delta B$ 为在 $A$ 中出现但不在 $B$ 中出现，或在 $B$ 中出现但不在 $A$ 中出现的元素。  
例如，$A = \{1, 2, 3\}$，$B = \{2, 3, 5\}$，则 $A \Delta B = \{1, 5\}$

## 题目描述

给定 $n$ 个集合 $s_1, s_2, \dots s_n$，每个集合都含有 $[1, m]$ 之间的若干个整数。

现在，有 $q$ 次操作，每次操作如下：
- `1 x y`：将 $s_x$ 中的每个元素都加上 $y$，再删去其中大于 $m$ 的；
- `2 x y`：将 $s_x$ 中的每个元素都减去 $y$，再删去其中小于 $1$ 的；
- `3 x y`：查询 $s_x$ 和 $s_y$ 的**交集**的元素个数；
- `4 x y`：查询 $s_x$ 和 $s_y$ 的**并集**的元素个数；
- `5 x y`：查询 $s_x$ 和 $s_y$ 的**对称差**的元素个数；

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m,q \leq 3 \times 10^4$，$1 \leq \sum_{i = 1}^n c_i \leq 10^6$，$1 \leq x, y \leq n$，$1 \leq o \leq 5$。集合里的元素都是不超过 $m$ 的正整数。

感谢 @[Zyingyzzz](/user/434929) 提供 hack 数据一组。

## 样例 #1

### 输入

```
2 5 5
3 1 2 3
4 1 2 4 5
1 2 1
2 1 1
3 1 2
4 1 2
5 1 2```

### 输出

```
1
4
3```

# 题解

## 作者：Limitless_lmw (赞：11)

建议先阅读[扶苏的bitset浅谈](https://www.luogu.com.cn/blog/fusu2333/fu-su-di-bitset-qian-tan#)

本文主要描述如何实现题目中所述操作。

我们用一个 `bitset<30005>` 的第 $i$ 位是 $0/1$ 表示存在/不存在。

那么我们一个一个操作来看：

---

操作 $1$:

我们观察一个序列 `1 3 5 9` 在一个 `bitset<15>` 中的映射：`000000100010101`

再观察这个序列所有元素都加上 $6$ 之后的映射：`100010101000000`

你发现了什么？

对，就是左移，所以操作 $1$，就是左移这个 `bitset`。

你是不是以为，我们建一个 `bitset<m>`，然后左移之后超出去的部分就为自动删掉？

这里有一个**坑点**：`bitset<N>` 中的 $N$ 必须为一个编译期常数，那么这里的 $m$ 显然在输入了之后不是一个编译期常数，那么就不能 `bitset<m>`，怎么办？

我们可以给另一个 `bitset<30005>` 的 $1\sim m$ 位都赋为 $1$，剩余的位 $0$，那么在左移之后，我们就用左移了的这个 `bitset` 与上后一个 `bitset`，就能起到将不在 $[1,m]$ 内的元素删除的作用。

---

操作 $2$:

相对操作 $1$ 就简单了，因为操作 $2$ 中的右移出了 $0$ 之后会自动删除，那么直接左移即可。

---

操作 $3$:

**交集**是由**同时在两个集合**中的元素构成的，那么这恰好符合哪种位运算？——与运算 `&`。

所以操作 $3$ 就是 `S[x]&S[y]`。

---

操作 $4$:

同理可得，**并集**是由**在任意一个集合**中的元素构成的，那么这就是或运算 `|`，操作 $4$ 便是 `S[x]|S[y]`。

---

操作 $5$:

**对称差**是由**只在其中一个集合**的元素构成的，那么这就是异或运算 `^`，得操作 $5$ 为 `S[x]^S[y]`。

Tip: 如果不知道异或是什么的，记住：若两个布尔值相等，则它们的异或值为 $0$，反之为 $1$。

---

至此，你就可以利用 STL AC 一道黄题了。

附代码：

```cpp
#include <bitset>
#include <vector>
#include <iostream>

const int maxn=30005;
int n,m,q;
std::bitset<maxn> s[maxn];

int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin>>n>>m>>q;
    for(int i = 1,c,x;i<=n; i++){
        for(std::cin>>c;c;--c){
            std::cin>>x;
            s[i].set(x-1,1);
        }
    }
    for(int i = 0; i<m; i++) s[0].set(i,1);
    for(int o,x,y;q;--q){
        std::cin>>o>>x>>y;
        if(o==1){
            s[x]<<=y;
            s[x]&=s[0];
        }else if(o==2){
            s[x]>>=y;
        }else if(o==3){
            std::cout<<(s[x]&s[y]).count()<<'\n';
        }else if(o==4){
            std::cout<<(s[x]|s[y]).count()<<'\n';
        }else if(o==5){
            std::cout<<(s[x]^s[y]).count()<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：Usada_Pekora (赞：6)

容易想到用 `bool` 类型去表示一个集合里面有没有这个数。维护一个长 $m$ 的 `bool` 数组表示一个集合，则整体加减操作变成了整个数组右移/左移的操作，空出的位补 0 即可；取交集是两个都有，结果中对应位作 $\mathrm{bitand}$ 运算；取并集是二者有一个即可，结果中对应位作 $\mathrm{bitor}$ 运算；作对称差是二者必须只有一个，结果中对应位作 $\mathrm{xor}$ 运算。此时直接维护这个过程的复杂度是 $O(\sum c + mq)$。

复杂度瓶颈在于每次操作只能对一个位进行操作，能不能将多个位一起操作呢？答案是可以的，我们注意到一个 `int` 变量可以与一个长度为 32 的 `bool` 数组相互映射，因为 `int` 转二进制后的 32 个位上的数不是 0 就是 1，所以可以用一个 `int` 变量代替长 32 的 `bool` 数组，利用位运算判断每一位的值即可实现操作。

那么把连续的一些 `bool` 用 `int` 代替即可，所有操作同上，使用 `__builtin_popcount(x)` 可以查询整数 $x$ 在二进制下有多少个 1。

复杂度 $O(\sum c+\frac{mq}{w})$，其中 $w$ 是 `int` 的字长。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4 + 5;
int n, m, q;
template<const int siz> struct Bitset {
	private:
		static const int buksize = (siz >> 6) + ((siz & 63) != 0);
		uint64_t bukket[buksize];
	public:
		Bitset() {
			memset(bukket, 0, sizeof bukket);
		}
		inline void set1(int pos) {
			if (pos >= m || pos < 0)
				return;
			bukket[pos >> 6] |= 1ull << (pos & 63);
		}
		inline void set0(int pos) {
			if (pos >= m || pos < 0)
				return;
			bukket[pos >> 6] &= ~(1ull << (pos & 63));
		}
		Bitset<siz> &operator <<= (const int len) {
			for (int i = buksize - 1; ~i; i--)
				for (uint64_t j = 63; ~j; j--) {
					if (bukket[i] >> j & 1)
						set1((i << 6 | j) + len), set0(i << 6 | j);
				}
			return *this;
		}
		Bitset<siz> &operator >>= (const int len) {
			for (int i = 0; i < buksize; i++)
				for (uint64_t j = 0; j < 64; j++) {
					if (bukket[i] >> j & 1)
						set1((i << 6 | j) - len), set0(i << 6 | j);
				}
			return *this;
		}
		Bitset<siz> operator | (const Bitset<siz> &o) const {
			Bitset<siz> res;
			for (int i = 0; i < buksize; i++)
				res.bukket[i] = bukket[i] | o.bukket[i];
			return res;
		}
		Bitset<siz> operator & (const Bitset<siz> &o) const {
			Bitset<siz> res;
			for (int i = 0; i < buksize; i++)
				res.bukket[i] = bukket[i] & o.bukket[i];
			return res;
		}
		Bitset<siz> operator ^ (const Bitset<siz> &o) const {
			Bitset<siz> res;
			for (int i = 0; i < buksize; i++)
				res.bukket[i] = bukket[i] ^ o.bukket[i];
			return res;
		}
		inline int count() {
			int res = 0;
			for (int i = 0; i < buksize; i++)
				res += __builtin_popcountll(bukket[i]);
			return res;
		}
		inline void print() {
			for (int i = 0; i < m; i++)
				printf("%d", bukket[i >> 6] >> (i & 63) & 1);
			printf("\n");
		}
};
static Bitset<N> s[N];
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> m >> q;
	for (int i = 1; i <= n; i++) {
		int c, x;
		cin >> c;
		while (c--) {
			cin >> x;
			s[i].set1(x - 1);
		}
	}
	while (q--) {
		int op, x, y;
		cin >> op >> x >> y;
		if (op == 1)
			s[x] <<= y;
		if (op == 2)
			s[x] >>= y;
		if (op == 3)
			cout << (s[x] & s[y]).count() << '\n';
		if (op == 4)
			cout << (s[x] | s[y]).count() << '\n';
		if (op == 5)
			cout << (s[x] ^ s[y]).count() << '\n';
	}
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：3)

~~本来我打的是[暴力](https://www.luogu.com.cn/blog/HuangRenhe123/solution-b3695)，本来过了，然后就被[学长大佬](https://www.luogu.com.cn/user/434929) hack 了。~~

这道题很容易想到用二进制位维护，因为 C++ 里左移和右移又快又方便。本来我也是这么想的，但是由于一个 $c_i \leq 10^6$,用 long long 存储不下,才打了暴力。

经过[大佬](https://www.luogu.com.cn/user/470348)的提示之后，我发现了 bitset 这个东西。它可以存储很多位数的内容，我们存储就不用 long long 了。

## 需要用的知识

`bitset<N>a,b[maxn]`:创建 $n$ 位的 bitset 变量 $a$， 数组 $b$。

`x.count()`:返回 bitset 量 $x$ 的 $1$ 的个数。

**注意：bitset 中的运算长度必须一样。**

## 开始打代码

- $op=1$ or $o=2$ 

左移右移即可，值得注意的是，左移会把不符合的去掉（但是第 $0$ 位如果不符合也要去掉）, 右移可能超过位数或者没有把大于 $m$ 的去掉，所以这里需要我们手动去除。

- $o=$ or $o=4$ or $o=5$

这里，我们就用"与"，"或"，"异或"这三个位运算符号来操作即可。（具体对应大家可以思考）。

接下来放完整代码。

我这里用了 $mm$ 来表示总共的，所有的和 $mm$ "与"一下就可以把小于 $1$ 的或者大于 $m$ 的去掉了。 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+5;
int n,m,q,x,y,o;
bitset<N*2>a[N],ans,mm;
inline void read(int &res){
	res=0;int f=1;char ch=getchar();
	while('0'>ch||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^48);
		ch=getchar();
	}
	res*=f;
}
inline void put(int x){
	if(x<0) putchar('-'),x=-x;
	int i=1;
	while(i*10<=x) i*=10;
	while(i){
		putchar(x/i+'0');
		x%=i;i/=10;
	}
}
int main(){
	read(n),read(m),read(q);
	for(int i=1;i<=m;i++) mm[i]=1;
	for(int i=1;i<=n;i++){
		read(y);
		while(y--) read(x),a[i][x]=1;//bitset的赋值
	}
	while(q--){
		read(o),read(x),read(y);
		if(o==1) a[x]=(a[x]<<y)&mm;
		if(o==2) a[x]=(a[x]>>y)&mm;
		if(o==3) ans=a[x]&a[y];
		if(o==4) ans=a[x]|a[y];
		if(o==5) ans=a[x]^a[y];
		if(o>=3) put(ans.count()),putchar('\n');
	}
	return 0;
}

```

加了读优和输优可以更快。

---

## 作者：oddy (赞：3)

# 题意简述

你需要维护若干个集合，让每个集合里的元素共同加一个数，并保留 $[1,m]$ 范围内的数。你还可能需要回答任意给定的两个集合之间的交集、并集、对称差。

集合个数和 $m$ 都不大于 $3\times 10^4$。

# 心路历程

看到题和数据范围，我两眼一黑。感觉像是个数据结构题，但这对于 $O(n^2)$ 的算法来说有些大（一般出到 $5\times 10^3$），对 $O(n\log n)$ 的算法又太小（一般出到 $10^5$）。

所以，我考虑在 $O(n^2)$ 的算法中选一个常数小的。

那么，想一想，哪个数据结构的常数极小呢？

就是 $O\left(\dfrac nw\right)$，其中 $w$ 表示计算机位数的 bitset！

我们发现，若 $w=64$，则运算次数约为 $\dfrac{(3\times 10^4)^2}{64}=14\ 062\ 500$，足以通过本题。

# 前置知识

仅介绍了此题用到的 bitset 相关语句。

```cpp
#include <bitset>

using namespace std;

bitset<30005> s, t; // 定义了两个能存下 30005 位的 bitset
int x;
```

```cpp
s.set(x); // 将 s 的第 x 位设为 1
s << x; // s 作为一个大二进制数（下同）左移 x 位
s >> x; // s 右移 x 位
s & t; // s 与 t 按位与
s | t; // s 与 t 按位或
s ^ t; // s 与 t 按位异或
s.count(); // s 内 1 的个数
```

# 解题思路

用 bitset 的每一位表示这一位的下标的数在不在里面。

则 $5$ 个操作对应的 bitset 运算分别如下：

1. 右移。
2. 左移。
3. 按位与后统计 $1$ 的个数。
4. 按位或后统计 $1$ 的个数。
5. 按位异或后统计 $1$ 的个数。

注意两种修改操作有可能使得 $[1,m]$ 外的位也为 $1$，所以需要再与上一个底集（有且仅有 $[1,m]$ 内的位为 $1$）。

# 代码

```cpp
#include <cstdio>
#include <bitset>

int n, m, q, o, x, y;
std::bitset<30005> s[30005], t;

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for(int i = 1; i <= n; i++)
        for(scanf("%d", &x); x; --x)
            scanf("%d", &y), s[i].set(y);
    for(int i = 1; i <= m; i++) t.set(i); // 底集

    while(q--) {
        scanf("%d%d%d", &o, &x, &y);
        switch(o) {
            case 1: s[x] = s[x] << y & t; break;
            case 2: s[x] = s[x] >> y & t; break;
            case 3: printf("%d\n", (s[x] & s[y]).count()); break;
            case 4: printf("%d\n", (s[x] | s[y]).count()); break;
            case 5: printf("%d\n", (s[x] ^ s[y]).count());
        }
    }

    return 0;
}
```

---

## 作者：Farland (赞：2)

## 暴力思路

数据范围：

>$$1\le n,m,q\le 3\times 10^4$$

1. 我们可以使用暴力依次令元素自增、自减和判断等，时间复杂度最劣可达立方级别，显然超时。

2. 使用布尔 $\texttt{vector}$ 数组（直接建数组不行，会 MLE，但是 $1\le \sum^{n}_{i=0} c_i\le 10^6$，所以考虑用 $\texttt{vector}$）来记录每一个数在集合中是否存在，然后依旧暴力，时间复杂度是平方级别的，依旧超时。

## 正解

使用 **STL 中的 bitset**，大佬请跳过讲解环节。

### 创建方法

```cpp
// 一维 bitset
bitset<大小>数组名;

// 二维 bitset
bitset<内层大小>数组名[外层大小];
```

头文件：`<bitset>`

### bitset 简介

bitset 可以**简单**理解为一个布尔数组，但是它有一些特殊之处：

1. 每一个 $0$ 和 $1$ 都只占 $1\ \texttt{bit}$

2. 支持位运算和其它一些内置函数，如你可以对它进行这样的操作：

```cpp
bitset<100>a; // 默认均为 0。
bitset<100>b;
bitset<100>c;

a.set(5); // 将 a 的第 5 位设为 1。

b[12] = 1; // 与数组基本赋值操作一样。
b[13] = 1;
b[12] = 0;

c = a | b; // 这里可以视 a 和 b 是两个长 100 的整形串，这里把 a 和 b 的或运算取得的值赋给了 (std::bitset) c。
// 异或和与运算也可以。

c <<= 1;
b >>= 1;
// 移位也可以进行。

cout << c.count();
// 输出 c 里面有多少个为 1 的位。
```

知道了，我们就可以轻松写出代码了~

```cpp
#include <iostream>
#include <cstdio>
#include <bitset>

using namespace std;

const int maxn = 3e4 + 5;
bitset <maxn> s[maxn], f; // s 是这 n 个集合，f 是一个用于清除集合中超出限制的数的 bitset。
int n, m, q; 

int read() // 输入
{
    int x;
    scanf("%d", &x);
    return x;
}

void print(int val) // 输出
{
    printf("%d\n", val);
}

int main()
{
    n = read(), m = read(), q = read(); // 读入 n, m, q。

    for (int i = 1, c; i <= n; i++)
        for (int c = read()/* 读入每个集合的长度 */, j = 0, x; j < c; j++)
            scanf("%d", &x), s[i][x] = 1; // 读入每个集合的每一个数，并将对应的下标设为 1。

    for (int i = 1; i <= m; i++) // 将 f 数组里 1~m 的所有值设为 1.
        f[i] = 1; 

    while (q--)
    {
        int opr = read(), x = read(), y = read();
        if (opr == 1)
            s[x] <<= y, s[x] &= f;
        // 左移，并且与 f 取 and，确保集合的数不会超过 m 。
        else if (opr == 2)
            s[x] >>= y, s[x] &= f;
        // 右移，并且与 f 取 and，确保集合的数不会为 0。
        else if (opr == 3)
            print((s[x] & s[y]).count());
        // 在 x 集合与 y 集合的交集中查找一共有多少个 1 并输出（取 and）。
        else if (opr == 4)
            print((s[x] | s[y]).count());
        // 在 x 集合与 y 集合的并集中查找一共有多少个 1 并输出（取 or）。
        else
            print((s[x] ^ s[y]).count());            
        // 在 x 集合与 y 集合的对称差中查找一共有多少个 1 并输出（取 xor，即异或）。
    }

    return 0; // 结束撒花
}
```

---


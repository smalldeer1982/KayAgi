# 组合数问题

## 题目背景

**禁止套取数据提交。违者将处罚。**

## 题目描述

给出 $T$ 次询问，每次给出 $n,m$，请求出 $\binom{n}{m}$ 对 $998,244,353$ 取模的结果。

其中 $\binom{n}{m}$ 为二项式系数，它的另一种写法是 $C_n^m$。

## 说明/提示

### 样例 1 解释

三组询问的答案依次是 $1, 6, 10$。

### 数据规模与约定

对 $100\%$ 的数据，保证 $1 \leq T \leq 5 \times 10^6$，$0 \leq m \leq n \leq N \leq 5 \times 10^6$。

### 提示

请注意大量的数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。

## 样例 #1

### 输入

```
3 5
3 3
4 2
5 3```

### 输出

```
13```

# 题解

## 作者：cjh20090318 (赞：37)

大家好，我是 CQ-C2024 蒟蒻 CJH。

最近回来复习一下组合数，于是就看到了这一道题。

## 题意

给定两个整数 $n,m$，求出 $\dbinom{n}{m}$。

## 分析

根据组合数的定义可知：

$$\dbinom{n}{m}=\dfrac{n!}{m!(n-m)!}$$

根据数据范围 $1 \leq T \leq 5 \times 10^6$，$0 \leq m \leq n \leq N \leq 5 \times 10^6$，可知单次求组合数时间复杂度为 $O(1)$ 才行。

很容易想到预处理阶乘以及[乘法逆元](https://oi-wiki.org/math/number-theory/inverse/)的阶乘。

总体时间复杂度 $O(N+T)$。

## 代码

```cpp
//the code is from chenjh
#include<cstdio>
#define MAXN 5000005
typedef long long LL;
const int mod=998244353;
int f[MAXN],inv[MAXN];//阶乘以及乘法逆元。
int main(){
	int T,N;scanf("%d%d",&T,&N);
	f[0]=f[1]=inv[0]=inv[1]=1;//记得赋初始值！
	for(int i=2;i<=N;i++) f[i]=(LL)f[i-1]*i%mod,inv[i]=(LL)(mod-mod/i)*inv[mod%i]%mod;//递推阶乘和逆元，中间运算可能会超过 long long，所以需要临时转换类型。
	for(int i=1;i<=N;i++) inv[i]=(LL)inv[i-1]*inv[i]%mod;//预处理逆元的阶乘。
	int ans=0;
	for(int n,m;T--;)scanf("%d%d",&n,&m),ans^=(LL)f[n]*inv[m]%mod*inv[n-m]%mod;//根据组合数公式求出组合数。
	printf("%d\n",ans);
	return 0;
}
```

## 关于此题的题外话

因为此题只有一组数据，所以用以下的代码也可以 AC 此题：

```c
main(){puts("522716868");}
```

故请求管理员加强数据。

---

## 作者：zzx0102 (赞：12)

[上一篇题解](https://www.luogu.com.cn/blog/Stitch0711/solution-b3717)

考虑直接根据费马小定理求出 $(n!)^{-1}$。

然后根据 $(i!)^{-1}=(i+1)!^{-1}\times (i+1)$ 反推回去，这样更加巧妙，但理论上复杂度一样。

显然时效更好，因为不需要求逆元了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e6 + 5, p = 998244353;
ll f[N], inv[N], t, maxn;
ll Pow(ll a, int b) {
	ll ans = 1;
	while(b) {
		if(b & 1) ans = ans * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false);
	cin >> t >> maxn; f[0] = 1;
	for(int i = 1; i <= maxn; i++) f[i] = f[i - 1] * i % p;
	inv[maxn] = Pow(f[maxn], p - 2);
	for(int i = maxn - 1; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % p; // 反推阶乘逆元
	int ans = 0;
	while(t--) {
		int n, m; cin >> n >> m;
		ll tmp = f[n] * inv[m] % p * inv[n - m] % p;
		ans ^= tmp;
	}
	cout << ans;
	return 0;
}
```

在 C++20 O2 的环境下：

本题解代码 1.11s 通过。

上一篇 1.19s。

~~80ms 差距不大。~~

---

## 作者：Orange1015 (赞：6)

# B3717 组合数问题 题解

###### ad: [better_reading_experience](https://www.luogu.com.cn/blog/DMTX-blog/b3717-ti-jie)

$\text{2023/3/19}$ 更新：修复 $\text{markdown}$ 。

$\text{2023/3/24}$ 更新：修复 $\LaTeX$ 。

------------

[传送门](https://www.luogu.com.cn/problem/B3717)

拿到这道题，我们先来简单分析一下可行的思路：

- 暴力算
- 卢卡斯定理
- 逆元

我们分别来看一下这三个思路的可行性。

## plan 1 暴力 (TLE)

很显然，这个方法是不可行的。题目中有这样的数据范围：

> $1 \le T \le 5 \times 10^6 \text{， } m \le n \le N \le 5 \times 10^6$

如果我们暴力算出每一个值的话，显然会超时。所以，我们来看 plan 2。

## plan 2 卢卡斯定理 (TLE)

[**卢卡斯定理**](https://oi-wiki.org/math/number-theory/lucas/)

卢卡斯定理是这样的：

对于质数 $p$， 正整数 $n \le m$， 有：

$C _{m} ^{n} =  C _{\frac{m}{p}} ^{\frac{n}{p}} \times C _{m \bmod p} ^{n \bmod p} \bmod p$

但这一做法会 TLE，所以不能用来做这一道题，但可以 AC [P3807](https://www.luogu.com.cn/problem/P3807)。

[悲伤的TLE](https://www.luogu.com.cn/record/105101464)

## plan 3 逆元 (AC)

[**逆元**](https://oi-wiki.org/math/number-theory/inverse/)

因为 $C _{m} ^{n} \bmod p = \dfrac{n!}{m! \times (n-m)!} \bmod p = (n! \bmod p) \times (m!^{-1} \bmod p) \times ((n-m)!^{-1} \bmod p) \bmod p$ ，所以我们只需要预处理出 $m!$ 和 $(n-m)!$ 在 $\bmod p$ 下的逆元即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,maxn,n,m,tmp,ans=0;
int ny[5000005],nyjie[5000005],jie[5000005]; 
const int p=998244353;
inline int read(){	//快读模板 
	register int x=0,f=1;
	register char c;
	c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x * f;
}
inline void write(int x){	//快写模板 
	if(x < 0){
		putchar('-');
        x = -x;
	}
	if(x > 9){
		write(x/10);
	}
	putchar(x % 10 + '0');
    return;
}
void init(){
	ny[1]=1;
	nyjie[0]=1;
	jie[0]=1; 
	for(int i=2;i<=maxn;i++){	// p.s. 只能用线性筛法来求逆元，否则会TLE 
		ny[i]=(p-p/i)*ny[p%i]%p; //线性筛求逆元 
	}
	for(int i=1;i<=maxn;i++){	//注意是 maxn ，不是 n 
		nyjie[i]=nyjie[i-1]*ny[i]%p;	//线性筛求阶乘的逆元 
		jie[i]=jie[i-1]*i%p;	//线性求阶乘
	}
}
signed main(){
	T=read(),maxn=read();
	init();	//千万别忘了初始化 
	while(T--){
		n=read(),m=read();
		tmp=(jie[n]*nyjie[m]%p)*nyjie[n-m]%p;	//求值 
		ans=ans^tmp;	//按位异或 
	}
	write(ans);
	return 0;
}
```

[喜悦的AC](https://www.luogu.com.cn/record/105113208)

---

## 作者：Homework_King (赞：6)

这道题是逆元板题。

众所周知： 

### $C _ {n}^{m} = \frac{n!}{m!(n-m)!}$

## 思路1 暴力 0pts

我们可以对于每个 n 和 m 都去求其组合数。除法可以用扩欧求逆元。

时间复杂度达到了恐怖的 $\mathcal O(TN \log N)$，必然超时。

## 思路2 预处理 100pts

先预处理好阶乘，存储在 A 数组。然后计算每一个阶乘的逆元（免得每次都计算，浪费时间），将其放在 inv 数组。

故可以得出：

### $C _ {n}^{m} = A _ {n}\cdot inv _ {m}\cdot inv _ {n-m}$

注意结果一定要取余干净！~~不然爆数据范围QWQ。~~

## 时间复杂度分析

预处理： $\mathcal O(N \log N)$

查询：$\mathcal O(1)$

## AC CODE
```cpp
#include<cstdio>
#define MOD 998244353
using namespace std;
long long T,NwN,n,m;
long long A[5000001],inv[5000001];

void exgcd(long long a,long long b,long long &x,long long &y){
	if(!b){
		x = 1;
		y = 0;
		return;
	}
	exgcd(b,a%b,x,y);
	long long t = x;
	x = y;
	y = t-a/b*y;
} 

inline long long read() {
	long long x = 0;
    bool f = false;
	char ch = getchar();
	while(ch > '9' || ch < '0'){
        if(ch == '-')
            f = true;
        ch = getchar();
    }
	while(ch >= '0' && ch <= '9'){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f? -x : x; 
}

void init(){
	A[0] = A[1] = 1;
	for(long long i=2;i<=NwN;i++) A[i] = A[i-1]*i%MOD;
	for(long long i=0;i<=NwN;i++){
		long long x,y;
		exgcd(A[i],MOD,x,y);
		x = (x+MOD)%MOD;
		inv[i] = x;
	}
}

int main(){
	T = read(); NwN = read();
	init();
	long long qwq = 0;
	while(T--){
		n = read(); m = read();
		long long awa = A[n]*inv[n-m]%MOD*inv[m]%MOD;
		qwq ^= awa;
	}
	printf("%lld",qwq);
	return 0;
}
```

蒟蒻第一篇题解，管理员求过QWQ。

---

## 作者：wanghx (赞：5)

[传送门](https://www.luogu.com.cn/problem/B3717)

此题是练习逆元的好题，不会逆元的点[这里](https://oi-wiki.org/math/number-theory/inverse/)或[这里](https://www.luogu.com.cn/problem/P3811)。


模数是质数，可以使用逆元计算除法。

我们可以一边输入一边求逆元，但这样时间复杂度为 $O(\log n)$，会 TLE，我们应先预处理 $[1,N]$ 里数的阶乘和阶乘的逆元。

我们知道 $a!^{-1}=(a-1)!^{-1}*a^{-1}$。

所以可以线性递推求逆元，这样预处理后就可以 $O(1)$ 查找一个数的逆元了。
```cpp
for(int i=1;i<=maxn;i++) jcny[i]=jcny[i-1]*ny[i]%mod;
```
总体时间复杂度为 $O(N+T)$。
```cpp
#define maxn 5000002
int t,N,ans,n,m,jc[maxn],jcny[maxn],ny[maxn];  //jc[maxn]={1,1}会CE，我也不知道为什么
signed main(){
	t=read(),N=read();
	ny[1]=1,jcny[0]=1,jc[0]=1,jc[1]=1;
	for(int i=2;i<=N;i++) ny[i]=(mod-mod/i)*ny[mod%i]%mod,jc[i]=jc[i-1]*i%mod;
	for(int i=1;i<=N;i++) jcny[i]=jcny[i-1]*ny[i]%mod;
	while(t--) n=read(),m=read(),ans^=(jc[n]*jcny[m]%mod*jcny[n-m]%mod)%mod;
	write(ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：4)

## 题目描述

[组合数问题](https://www.luogu.com.cn/problem/B3717)

## 思路

先公式推导：

$$
\begin{aligned}
\binom{n}{m} \bmod p
& = \frac{n!}{m!(n-m)!} \bmod p \\
& = (n! \bmod p)  \times (m! ^ {-1} \bmod p) \times ((n - m)! ^ {-1} \bmod p) \bmod p\\

\end{aligned}
$$


看到范围 $1 \leq T \leq 5 \times 10^6$，$0 \leq m \leq n \leq N \leq 5 \times 10^6$，可以想到用到[逆元](https://blog.csdn.net/weixin_40895249/article/details/124477029)。但是一边输入一边求逆元的时间复杂度是 $O(\log n)$，会 TLE ，所以我们要预处理 $1 \sim n$ 的逆元和阶乘的逆元。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5000010,MOD=998244353;
ll t,n,m,jiecheng[N],niyuan[N],ans;
void init(ll n,ll p)
{
	jiecheng[0]=1;
	jiecheng[1]=1;
	niyuan[0]=1;
	niyuan[1]=1;
	for(int i=2;i<=n;i++)
	{
		jiecheng[i]=jiecheng[i-1]*i%p;
		niyuan[i]=(p-p/i)*niyuan[p%i]%p;
	}
	for(int i=1;i<=n;i++)
	{
		niyuan[i]=niyuan[i-1]*niyuan[i]%p;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t>>n;
	init(n,MOD);
	while(t--)
	{
		cin>>n>>m;
		ans^=jiecheng[n]*niyuan[m]%MOD*niyuan[n-m]%MOD;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：Elairin176 (赞：1)

[传送门](https://www.luogu.com.cn/problem/B3717)   
一道练习逆元的好题。     
首先，我们知道，$C^m_n=\frac{n!}{m!\times(n-m)!}$。     
那取模怎么做呢？     
考虑到模数是质数，可以使用逆元计算除法。        
所以，我们可以预处理阶乘，之后每次计算用逆元计算即可。    
但是这样会 TLE。     
为什么呢？      
求逆元是 $O(\log n)$ 的，而 $1\le T,N\le5\times10^6$，时间太慢了。        
考虑到上面的式子可以把乘法化成除法，所以，我们直接预处理阶乘的逆元即可。       
不难想到，$i!^{-1}=(i-1)!^{-1}\times i^{-1}$。        
我们先预处理出 $[1,N]$ 里的逆元，再预处理阶乘的逆元即可。     
[CODE](https://www.luogu.com.cn/paste/68ryutoe)

---

## 作者：zzx0102 (赞：1)

$C_n^m={\dfrac{n!}{m!\times(n-m)!}}$

那么可以理解为 $n!\times (m!)^{-1}\times (n-m!)^{-1}$。

$n!$ 对 $p$ 取模可以预处理。

接下来是预处理阶乘的逆元 $(x!)^{-1}$。

显然可得 $(x!)^{-1}=({(x-1)!)^{-1}\times x^{-1}}$。

那么先线性递推 $x^{-1}$，再线性递推 $(x!)^{-1}$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pc putchar
const int N = 5000010;
int inv[N], jc[N], Jc[N];
const int p = 998244353;
void init(int n, int p) {
	inv[1] = 1, jc[0] = 1, Jc[0] = 1;
	for(int i = 2; i <= n; i++) inv[i] = 1LL * (p - p / i) * inv[p % i] % p; // 线性求逆元
	for(int i = 1; i <= n; i++) jc[i] = 1LL * jc[i - 1] * inv[i] % p, Jc[i] = 1LL * Jc[i - 1] * i % p; // 线性求阶乘逆元
}
signed main() {
	ios::sync_with_stdio(0);
	int ans = 0, t, maxn; cin >> t >> maxn; init(maxn, p);
	while(t--) {
	    int n, m; cin >> n >> m;
	    int a = 1LL * Jc[n] * jc[m] % p * jc[n - m] % p;
	    ans ^= a;
	}
	cout << ans << endl;
    return 0;
}
```

---


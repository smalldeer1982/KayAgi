# 扔骰子问题 1

## 题目描述

有 $n$ 个六面骰子，投掷时，每个面朝上的概率均相同，且每个骰子的投掷结果相互独立。

现在投掷出这些骰子，请问恰好有 $m$ 个骰子的朝上面为一号面（仅有一个点的面）的概率是多少？

请你求出这个概率对 $998,244,353$ 取模的结果。

## 说明/提示

### 样例 1 解释

样例输出的第一行被抹去了，你应该用一个仅含小写字母的字符串替换它。

### 数据规模与约定

对 $100\%$ 的测试点，保证 $1 \leq T \leq 5 \times 10^6$，$m \leq n \leq 5 \times 10^6$，$n \geq 1$，$m \geq 0$。

### 评分说明

本题共两行输出，第二行输出错误得 $0$ 分，第二行输出正确但第一行输出错误的，得 $50$ 分。

## 样例 #1

### 输入

```
3
4 2
9 8
123456 789```

### 输出

```
#####
563183570```

# 题解

## 作者：未来姚班zyl (赞：10)

# 题目分析
## $50$ 分做法
一道较为简单的概率题。


第一眼看到这个问题，应该很容易想到用到古典概型公式：
#### $P(A)=\frac{x}{y}$ 
其中 $x$ 表示 $A$ 事件包含的基本事件的个数，$y$ 代表基本事件的总数,基本事件为包含所有结果的等概率的事件。


这道题中 $y$ 的值非常简单，由于 $n$ 个骰子中每个骰子有6个面，根据乘法原理（或分步原理）及基本事件的定义容易得到本题的基本事件总数 $y=6^{n}$。


于是问题变为如何求 $x$。


这时再来看 $A$ 事件在本题的定义：


恰好有 $m$ 个骰子的朝上面为一号面（仅有一个点的面）的方案数？


“恰好”启发着我们用加法（或分类）原理来计算方案数，因为这样做我们大概率不需要容斥。


于是就可以想到这题的正解了！！


如果已经有 $m$ 个骰子是一号面朝上了，则剩下的 $(n-m)$ 个骰子就只能选择 $2$ 到 $6$ 共 $5$ 种选择。如果这 $m$ 个骰子已经选定了，则该情况的方案数 $5^{n-m}$。
而选定这 $m$ 个骰子的方案数就是从 $n$ 个骰子中选择 $m$ 个骰子的朝上面为一号面的方案数，即 $C_{n}^{m}$。根据分步原理，就能得到：
#### $x=C_{n}^{m}5^{n-m}$
把组合数拆开后，就得到 $P(A)$ 的表达式了！（别忘了，我们还要将每次的结果模去 $998244353$）
#### $P(A)=\frac{5^{n-m}n!}{6^{n}m!(n-m)!}$
由于还要模 $998244353$ ,且询问次数 $T$、$n$ 与 $m$ 的范围都达到了 $5e6$,则需要线性预处理 $i!$，$(i!)^{-1}$，$6^{i}$,$(5^{i})^{-1}$。（但这些不是这道题的重点，不加详解，还不会的可以前往[洛谷P3811【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
学习相关知识。）最后每次只用 $O(T)$ 求出每次询问的答案并按位异或累计即可。总复杂度 $O(n+T)$，足以通过此题。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define ll long long
#define ci const int
ci mod=998244353;
ci N=5e6+5;
ll inv[N],mul[N],ans,mul5[N],inv6[N];
int t;
ll qp(ll a,ll b){
	if(b==0)rt 1;
	ll c=qp(a,b/2);
	c=c*c%mod;
	if(b&1)c=c*a%mod;
	return c;
}
void preset(){//预处理
	mul[0]=mul5[0]=1;
	for(int i=1;i<=N-5;i++){
		mul[i]=mul[i-1]*i%mod;
		mul5[i]=mul5[i-1]*5%mod;
	}
	inv[N-5]=qp(mul[N-5],mod-2);
	inv6[N-5]=qp(qp(6,N-5),mod-2);
	for(int i=N-6;i>=0;i--){
		inv[i]=inv[i+1]*(i+1)%mod;
		inv6[i]=inv6[i+1]*6%mod;
	}
}
int main(){
	cin >>t;
	preset();
	for(int i=1,n,m;i<=t;i++){
		scanf("%d%d",&n,&m);
		ans^=mul5[n-m]*mul[n]%mod*inv6[n]%mod*inv[m]%mod*inv[n-m]%mod;
	}
	cout <<ans;
	return 0;
}
```

什么，你做完了？！提交了代码然后……WA了？！


你这时回去看输入输出格式，发现：


共输出两行。


第一行输出一个仅含小写字母的字符串，表示『骰』这个字的汉语拼音（不含声调）。
~~啊啊啊这是什么鬼？NOI 大纲里好像没有这方面的知识啊？~~


这个对于只会敲代码的 OIer 们来讲超纲了，因为 NOI 大纲里根本没有认识某些汉字的拼音这项知识。


由于接下来的内容有些超纲，只想练习敲代码的 OIer 们可以选择拿到 $50$ 分的部分分就继续敲别的题了。
## 满分做法
在 $50$ 分的基础上，我们现在需要知道汉字“骰”的拼音。


这里介绍两个新的概念：


$1$.拼音，是拼读音节的过程，就是按照普通话音节的构成规律，把声母、介母、韵母急速连续拼合并加上声调而成为一个音节。


$2$.字典是为字词提供音韵、意思解释、例句、用法等等的工具书。


在知道这些定义的前提下，要知道“骰”的拼音，我们有以下几种途径：


$1$.通过日常所积累的知识，直接说出其拼音。（这需要较强的语文功底，比较困难。）


$2$.通过查字典，找到骰字的拼音。



对于第二条途径，我们一般采用[字形法或五笔输入法](https://m.bala.iask.sina.com.cn/p/u1l6bf9ZyNA)
。
请读者根据指引自行操作并得到答案，并用喜欢的输出方式输出其读音，记得换行。









---

## 作者：2huk (赞：4)

## Description

有 $n$ 个六面骰子，投掷时，每个面朝上的概率均相同，且每个骰子的投掷结果相互独立。

现在投掷出这些骰子，请问恰好有 $m$ 个骰子的朝上面为一号面（仅有一个点的面）的概率是多少？

请你求出这个概率对 $998,244,353$ 取模的结果。

## Solution

首先我们要从 $n$ 个骰子中选出 $m$ 个骰子，其方案数为 $\dbinom nm$。

其次，对于选出的 $m$ 个骰子而言，每个都有 $\dfrac 16$ 的概率朝上的面为 $1$。因此 $m$ 个骰子都朝上的概率为 $\left( \dfrac 16 \right)^m$。

再其次，对于没有选出的 $n - m$ 个骰子而言，由于是 $1$ 的都已经被选走了，因此它们只能填 $2 \sim 6$ 中的一个数，也就是有 $\dfrac 56$ 的概率合法。因此它们全部合法的概率为 $\left( \dfrac 56 \right)^{n - m}$。

因此答案为：
$$
\dbinom nm \times \left( \dfrac 16 \right)^m \times \left( \dfrac 56 \right)^{n - m}
$$

## Code

对于这三部分答案，可以分别来求：

- 组合数可以预处理阶乘和阶乘的逆元；

- $\left( \dfrac 16 \right)^m$ 可以写作 $\dfrac 1{6^m}$，因此需要预处理 $6$ 的次幂的逆元。
- $\left( \dfrac 56 \right)^{n - m}$ 可以写作 $\dfrac {5^{n - m}}{6^{n - m}}$ ，因此需要预处理 $5$ 的次幂。

```cpp
typedef long long LL;

const int N = 5e6 + 10;

int fpm(int a, int b)
{
	int res = 1;
	while (b)
	{
		if (b & 1) res = (LL)res * a % P;
		b >>= 1, a = (LL)a * a % P;
	}
	return res;
}

int T, n, m;
int k, res;
int fac[N], inv[N];
int p5[N];		// p5[i] = 5 ^ i
int inv6[N];	// inv6[i] = 6 ^ i 的逆元

void init(int n)
{
	fac[0] = p5[0] = 1;
	fup (i, 1, n)
		fac[i] = (LL)fac[i - 1] * i % P;
	
	inv[n] = fpm(fac[n], P - 2);
	fdw (i, n - 1, 0)
		inv[i] = (LL)inv[i + 1] * (i + 1) % P;
	
	fup (i, 1, n)
		p5[i] = (LL)p5[i - 1] * 5 % P;
	
	inv6[n] = fpm(fpm(6, n), P - 2);
	fdw (i, n - 1, 0)
		inv6[i] = (LL)inv6[i + 1] * 6 % P;
}

int C(int n, int m)
{
	return (LL)fac[n] * inv[m] % P * inv[n - m] % P;
}

int main()
{
	init(N - 1);
	
	puts("tou");		// 骰 念 tou
	T = read();
	
	while (T -- )
	{
		n = read(), m = read();
		k = (LL)C(n, m) * inv6[m] % P * p5[n - m] % P * inv6[n - m] % P;
		res ^= k;
	}
	
	write(res);
	
	return 0;
}
```

---

## 作者：rainygame (赞：0)

本题可以转化为：

给定 $n$ 个骰子，规定其中 $m$ 个的结果为 $1$。其它的不为 $1$。求满足条件的方案数除以总方案数的值。

$m$ 个骰子的结果唯一，方案数为 $1$。$n-m$ 个骰子的结果维五，方案数 $5^{n-m}$。从 $n$ 个中选择 $m$ 个的方案数为 $\binom{n}{m}$。三个相乘可得 $\binom{n}{m}\times5^{n-m}$。

考虑总方案数，每个骰子都有 $6$ 个面，所以总方案数为 $6^n$。

所以答案为：

$$
\frac{\binom{n}{m}\times5^{n-m}}{6^n} \bmod p
$$

用逆元求出即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MOD 998244353
#define MAXN 5000001

int t, n, m;
long long ans, inv6;
long long fac[MAXN], ifac[MAXN], inv[MAXN];
long long fm[MAXN], ifs[MAXN];

long long C(long long a, long long b){
    return ((fac[a] * ifac[b]) % MOD * ifac[a-b]) % MOD;
}

long long qpow(long long a, long long b){
	long long res = 1;
	while (b){
		if (b & 1) res = (res * a) % MOD;
		a = (a * a) % MOD;
		b >>= 1;
	}
	
	return res;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    fac[0] = inv[0] = inv[1] = ifac[0] = fm[0] = ifs[0] = 1;
    for (int i=1; i<MAXN; i++) fac[i] = (fac[i-1] * i) % MOD;
    for (int i=2; i<MAXN; i++) inv[i] = (((MOD-MOD/i) * inv[MOD%i] % MOD) + MOD) % MOD;
    for (int i=1; i<MAXN; i++) ifac[i] = (ifac[i-1] * inv[i]) % MOD;
    
    inv6 = qpow(6, MOD-2);
    for (int i=1; i<MAXN; i++){
    	fm[i] = (fm[i-1] * 5) % MOD;
    	ifs[i] = (ifs[i-1] * inv6) % MOD;
    }
    
    cin >> t;
    while (t--){
    	cin >> n >> m;
    	ans ^= ((fm[n-m] * C(n, m)) % MOD * ifs[n]) % MOD;
    }
    
    cout << "tou\n" << ans;
    
    return 0;
}
```


---

## 作者：zzx0102 (赞：0)

$m$ 次投中，可以随意安排顺序，所以有 $C_n^m$ 种方案。

另外 $n-m$ 次没中的，可以取 $2,3,4,5,6$，即 $5^{n-m}$ 种方案。

由于总共有 $6^n$ 种方案，所以方案数就是 $\dfrac{C_n^m\times 5^{n-m}}{6^n}$。

所以我们需要筛的有

* $6^n$ 的逆元：这个东西简单，$6$ 的逆元可以用快速幂求出，是 $166374059$，然后就相当于 $\dfrac{1}{6^i}\equiv 166374059^i\pmod p$

* $5^n$：这个更简单，$five_i=5five_{i-1}$

* $C_n^m$：可以参考 [这篇题解](https://www.luogu.com.cn/blog/Stitch0711/solution-b3717) 和 [这篇题解](https://www.luogu.com.cn/blog/Stitch0711/solution-b37172)。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5000010, p = 998244353;
int inv[N], jc[N], Jc[N], six[N], five[N];
void init(int n, int p) {
	inv[1] = 1, jc[0] = 1, Jc[0] = 1; int Inv = 166374059; inv[0] = 1;
	for(int i = 2; i <= n; i++) inv[i] = 1LL * (p - p / i) * inv[p % i] % p;
	for(int i = 1; i <= n; i++) jc[i] = 1LL * jc[i - 1] * inv[i] % p, Jc[i] = 1LL * Jc[i - 1] * i % p;
	six[0] = 1; for(int i = 1; i <= n; i++) six[i] = 1ll * six[i - 1] * Inv % p;
	five[0] = 1; for(int i = 1; i <= n; i++) five[i] = 1ll * five[i - 1] * 5 % p;
}
signed main() {
	ios::sync_with_stdio(0);
	long long ans = 0, t; cin >> t; init(5000005, p); cout << "tou" << endl;
	while(t--) {
	    int n, m; cin >> n >> m;
	    int a = 1ll * five[n - m] * Jc[n] % p * jc[m] % p * jc[n - m] % p * six[n] % p;
	    ans ^= a;
	}
	cout << ans << endl;
    return 0;
}
```

---

## 作者：云裳 (赞：0)

**思路**

在 $n$ 个骰子中选出 $m$ 个骰子点数是 $1$，方案数是 $\binom{n}{m} $。

剩下的 $n-m$ 个骰子的点数可以是 $2,3,4,5,6$，共有 $5^{n-m}$ 种方案。

有 $n$ 个骰子，每个骰子 $6$ 个面，总的方案数是 $6^{n}$。

把所求的答案的方案数相乘，再除以总方案数，可以得到答案是 $\frac{\binom{n}{m} \cdot 5^{n-m}}{6^{n}}$。

将 $\binom{n}{m} $ 展开，每次询问的答案就是 $\frac{n!  5^{n-m}}{m!(n-m)! 6^n }$。

因为要取模，所以要算出答案的分母的逆元。

而 $n,m,T$ 最高都是 $5\times10^6$，就把 $i!$，$(i!)^{-1}$，$5^i$，$(6^i)^{-1}$ 都预处理出来，就可以每组数据 $O(1)$ 查询。

注意[骰的读音](https://baike.baidu.com/item/%E9%AA%B0/5263979)。

**代码**

```cpp
#define up(i, l, r) for (int i = l, END##i = r; i <= END##i; i++)
typedef long long ll;
using namespace std;
const int mod = 998244353, N = 5e6 + 10;
ll jc[N], inv[N], jcinv[N], five[N], inv6[N];
ll qpow(ll base, ll p, ll mod) {
  ll ans = 1, tmp = base;
  while (p != 0) {
    if (p & 1)
      ans = (ans % mod * tmp % mod) % mod;
    tmp = (tmp % mod * tmp % mod) % mod;
    p >>= 1;
  }
  ans %= mod;
  return ans;
}
void init() {
  jc[0] = jc[1] = 1;
  inv[1] = 1, inv[0] = 1;
  jcinv[1] = jcinv[0] = 1;
  five[0] = 1, five[1] = 5;
  ll inv_ = qpow(6, mod - 2, mod);
  inv6[0] = 1;
  up(i, 1, N - 10) inv6[i] = inv6[i - 1] * inv_ % mod;
  up(i, 2, N - 10) {
    five[i] = five[i - 1] * 5 % mod;
    jc[i] = jc[i - 1] * i % mod;
    inv[i] = (-mod / i + mod) * inv[mod % i] % mod;
    jcinv[i] = jcinv[i - 1] * inv[i] % mod;
  }
}
void solve() {
  cout << "tou\n";
  ll t,ans = 0;
  cin >> t;
  init();
  while (t--) {
    ll n, m;
    cin >> n >> m;
    ll a = ((jc[n] % mod * jcinv[m] % mod) * jcinv[n - m] % mod) % mod,
       b = five[n - m] % mod, c = inv6[n] % mod;
    ll f = a % mod * b % mod * c % mod;
    ans ^= f;
  }
  cout << ans;
}
```


---


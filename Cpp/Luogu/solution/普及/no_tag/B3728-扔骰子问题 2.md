# 扔骰子问题 2

## 题目描述

有 $n$ 个六面骰子，投掷时，每个面朝上的概率均相同，且每个骰子的投掷结果相互独立。

现在投掷出这些骰子，请问所有骰子朝上的面的点数之和恰好为 $m$ 的概率是多少？

请你求出这个概率对 $998,244,353$ 取模的结果。

## 说明/提示

### 数据规模与约定

对 $100\%$ 的测试点，保证 $1 \leq T \leq 6 \times 10^6$，$1 \leq n \leq 10^3$，$1 \leq m \leq 6 \times 10^3$。

## 样例 #1

### 输入

```
5
1 6
2 7
13 98
23 999
234 567```

### 输出

```
873483306```

# 题解

## 作者：Milthm (赞：3)

## B3728 题解

### 前置知识

- 动态规划

- 逆元

### 题目解法

这题状态很好设计，又因为数据范围小，所以是一个明显的动态规划题目。

设 $dp_{i,j}$ 为前 $i$ 个骰子朝上一面的点数之和为 $j$ 的方案数量，则答案为 $\frac{dp_{n,m}}{6^n}$。

转移方程和背包有点像，因为当前状态是由第 $i-1$ 个骰子的状态与第 $i$ 个骰子的六种选择方式来的，所以 $dp_{i,j}=\displaystyle\sum_{k=1}^{6}dp_{i-1,j-k}$。注意转移过程不要放到多组数据里面，要提前预处理好。

动态规划还有边界的处理，容易发现当 $i=1,1\le j \le 6$ 时，有 $1$ 种方案，其它情况没有方案。

答案不能直接算，要先预处理 $6$ 的次幂的逆元，记得取模。另外，本题略微卡常，这里我使用了快读。

### AC 代码

```cpp
#include<iostream>
#define int long long //不开 ll 见祖宗
using namespace std;
const int mod=998244353; 
int read(){
	char c=getchar();
	int ans=0;
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans;
}
int qpow(int a,int b){//快速幂，处理逆元用的
	int ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int T,n,m,fsix[6000005],ans,dp[1005][6005];
signed main(){
	T=read();
	fsix[0]=1;
	int qwq=qpow(6,mod-2);//先算出 6 的逆元
	for(int i=1;i<=6e6;++i)fsix[i]=fsix[i-1]*qwq%mod;//预处理 6 的次幂的逆元
	for(int i=1;i<=6;++i)dp[1][i]=1;//dp 边界
	for(int i=2;i<=1000;++i){
		for(int j=1;j<=6000;++j){
			for(int k=1;k<=6;++k){
				dp[i][j]+=dp[i-1][j-k];//dp 转移
			}
			dp[i][j]%=mod;//记得取模
		}
	}
	while(T--){
		n=read();m=read();
		ans^=(dp[n][m]*fsix[n]%mod);//统计答案
	} 
	cout<<ans;
	return 0;
}

```


---

## 作者：落花月朦胧 (赞：3)

upd23/4/22: 发现放的代码过不了。

# 前置知识

以下的知识点都可以在网上搜到，为了不占篇幅，这里就不再赘述了。

逆元，小学乘法原理，概率，DP（背包）。

# 题目大意

给 $n$ 个骰子，每个骰子相互独立且它们面向每一个面的概率是相同的。

求它们面向上方的点数的和是 $m$ 的概率。

答案要取模，有多组数据。

# Solution

样本空间：可以理解为一个事件总共的情况组成的集合。

随机事件：可以理解为满足一个条件的情况组成的集合。

我们拿到一个概率题，首先应该思考的是这个事件的样本空间是什么，怎么求随机事件的大小，然后用样本空间的大小除以随机事件的大小即可。

## 对于求本题的样本空间大小

对于每一个骰子，都会有 $6$ 种等概率的情况，由于有 $n$ 个骰子，所以我们要抛 $n$ 次，就是说每个骰子都属于一个阶段。通过乘法原理可以知道总共的情况有 $6^{n}$ 种。

## 对于求随机事件的大小。

首先发现数据范围很有意思， $T$ 非常的大，意味着我们回答必须是 $\mathcal{O} (1)$ 的，然后发现 $n$ 只有千位级，考虑用 $\mathcal{O}(n^2)$ 的做法预处理后 $\mathcal{O}(1)$ 询问。

在看一下这个条件，发现这就是一个裸的完全背包，同时其还满足前面推的时间复杂度的要求，至此，你就发现你已经做完了。

值得一提的是，如果这里我们用快速幂每次都求一遍 $6^{n}$ 是会 TLE 的，所以我们也要预处理这个东西。还要注意开 long long 和看数据范围的大小。

# Code
```cpp
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr); std::cout.tie(nullptr);

    int t;
    std::cin >> t;

    int max = 1E3;
    std::vector<i64> invfac_6(max + 1);
    invfac_6[max] = power(power(6, max, P), P - 2, P);
    for (int i = max; i >= 1; i--) {
        invfac_6[i - 1] = (invfac_6[i] * 6) % P;
    }

    std::vector<std::vector<i64>> dp(max + 1, std::vector<i64>(6 * max + 1));
    dp[0][0] = 1;
    for (int i = 1; i <= max; i++) {
        for (int k = 1; k <= 6; k++) {
            for (int j = k; j <= 6 * i; j++) {
                dp[i][j] += dp[i - 1][j - k];
                dp[i][j] %= P;
            }
        }
    }

    i64 ans = 0;
    while (t--) {
        int n, m;
        std::cin >> n >> m;

        i64 res = invfac_6[n] * dp[n][m];
        res %= P;
        // std::cerr << dp[n][m] << " " << res << "\n";

        ans ^= res;
    }

    std::cout << ans << '\n';

    return 0;
}

```

---

## 作者：zzx0102 (赞：3)

首先，概率 $=$ 出现次数 $\div$ 总次数。

显然总次数 $=6^n$。

这个东西的逆元就是 $166374059^i$（$166374059$ 是 $6$ 的逆元）。

接下来出现次数就是个计数 dp 的板子了。

转移方程：$dp_{i,j}=\sum^{6}_{k=1} dp_{i-1,j-k}(j\ge k)$

当然，也可以顺着推。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1005, p = 998244353; int dp[N][N * 6], six[N]; int n, m, t;
signed main() {
	ios::sync_with_stdio(0); cin >> t; dp[0][0] = 1; int ans = 0; six[0] = 1;
	for(int i = 0; i < 1000; i++)
		for(int j = 0; j <= i * 6; j++)
			for(int k = 1; k <= 6; k++)
				dp[i + 1][j + k] = (dp[i + 1][j + k] + dp[i][j]) % p;
	for(int i = 1; i <= 1000; i++) six[i] = 1ll * six[i - 1] * 166374059 % p;
	while(t--) {int n, m; cin >> n >> m; ans ^= 1ll * dp[n][m] * six[n] % p;}
	cout << ans << endl;
    return 0;
}
```

经证明，此题代码仅 14 行，属于标准的水题。

---

## 作者：小小小朋友 (赞：3)

## 思路

考虑动态规划，设计 $f_{i,j}$ 表示前 $i$ 个骰子总和为 $j$ 的方案数，可以得到方程 $f_{i,j}=\sum_{k=1}^{6}f_{i-1,j-k}$。

题目所求的是概率，所以我们要求出方案总数，由于每个骰子互相独立，可得方案总数为 $6^n$，答案为 $f_{i,j} \div 6^n$。

这个数值当然不能直接算，我们要使用[乘法逆元](https://oi-wiki.org/math/number-theory/inverse/)来计算它对 $998244353$ 的模。又有 $(6^n)^{-1} \equiv {(6^{-1})}^n (\text {mod } 998244353)$，我们就可以用快速幂计算出 $6^{-1}$，然后线性预处理出 ${(6^{-1})}^n$ 了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int f[1005][6005],n,ts[1005],pwre[1005];
int ksm(int x,int y){
	int r=1;
	while(y){
		if(y&1)r=r*x%mod;
		y>>=1;x=x*x%mod;
	}
	return r;
}
signed main(){
	ios::sync_with_stdio(0);
	f[0][0]=1;
	for(int i=0;i<1000;i++){
		for(int j=0;j<=i*6;j++){
			for(int k=1;k<=6;k++){
				f[i+1][j+k]=(f[i+1][j+k]+f[i][j])%mod;//递推，除数可以直接取模。
			}
		}
	}
	pwre[0]=1;int re6=ksm(6,mod-2);//快速幂求逆元。
	for(int i=1;i<=1000;i++) pwre[i]=pwre[i-1]*re6%mod;//预处理出6的次方的逆元。
	cin>>n;
	int ans=0;
	for(int i=0;i<n;i++){
		int l,r;cin>>l>>r;
		ans^=f[l][r]*pwre[l]%mod;
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：2huk (赞：2)

## Description

有 $n$ 个六面骰子，投掷时，每个面朝上的概率均相同，且每个骰子的投掷结果相互独立。

现在投掷出这些骰子，请问所有骰子朝上的面的点数之和恰好为 $m$ 的概率是多少？

请你求出这个概率对 $998,244,353$ 取模的结果。

## Solution

如果不考虑点数之和恰好为 $m$ 的条件，那么显然总方案数为 $6^n$。

如果考虑点数之和这个条件，考虑 DP。

设状态 $f_{i, j}$ 表示对于前 $i$ 个棋子，点数和为 $j$ 的**方案数**。那么答案显然为 $\dfrac{f_{n, m}}{6^n}$。

对于转移，我们可以枚举第 $i$ 枚骰子（也就是最后一枚）的点数是多少。若第 $i$ 枚骰子的点数为 $k$（$1 \le k \le \min(6, j)$），则它的方案数为 $f_{i - 1, j - k}$，表示前 $i - 1$ 枚骰子点数和为 $j - k$ 的方案数。将所有满足条件的 $k$ 计算贡献累加即为答案。

## Code

注意数据范围 $T \le 6 \times 10^6$，$n \le 10^3$，$m \le 6 \times 10^3$，在每次询问时进行 DP 是会超时的。因此我们可以预处理出所有 $f_{i, j}(i \in [1, 10^3], j \in [1, 6 \times 10^3])$ 的值，询问时查表即可。

还有要预处理 $6^i$ 的逆元。

```cpp
int fpm(int a, int b)
{
	int res = 1;
	while (b)
	{
		if (b & 1) res = (LL)res * a % P;
		b >>= 1, a = (LL)a * a % P;
	}
	return res;
}

int T, n, m, res;
int inv[N], f[N][M];

void init(int n, int m)
{
	inv[n] = fpm(fpm(6, n), P - 2);
	fdw (i, n - 1, 0)
		inv[i] = inv[i + 1] * 6ll % P;
	
	f[0][0] = 1;
	fup (i, 1, n)
		fup (j, 1, m)
			fup (k, 1, 6)
				if (j >= k)
					f[i][j] = ((LL)f[i][j] + f[i - 1][j - k]) % P;
}

int main()
{
	init(N - 1, M - 1);
	
	T = read();
	while (T -- )
	{
		n = read(), m = read();
		res ^= ((LL)f[n][m] * inv[n] % P);
	}
	
	write(res);
    
	return 0;
}
```

---


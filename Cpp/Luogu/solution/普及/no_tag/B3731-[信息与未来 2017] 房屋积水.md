# [信息与未来 2017] 房屋积水

## 题目描述

乌龟家的屋顶是凹凸不平的，所以每次雨后都会积水。为了知道屋顶是否会在暴雨后塌掉，他把屋顶的形状给了你，希望你帮他计算暴雨后屋顶的积水总量。

乌龟的屋顶由顺次排在同一水平线上的 $n$ 个宽度为 $1$、高度为整数 (分别给出) 的瓦片组成。例如给定 $n=5$，瓦片的高度分别为 $4,2,3,5,1$，屋顶可以画在下图所示的网格中，灰色格子为瓦片。

暴雨过后，如果一个方格向左右两侧延伸都能到达瓦片占据的方格，它就会积水。所以图中波浪线格子在暴雨后会积水，屋顶的积水方格总数为 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qd0c3htr.png)

---

试题中使用的生成数列 $R$ 定义如下：整数 $0\leq R_1\lt 201701$ 在输入中给出。

对于 $i\gt 1,R_i=(R_{i−1}\times 6807+2831)\mod 201701$。

## 说明/提示

$1\leq n\leq100$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
10 1```

### 输出

```
23```

# 题解

## 作者：WsW_ (赞：6)

### 思路
首先生成每个瓦片的高度。  
对于每个瓦片，我们要求出该瓦片所在区域内水的高度。  
先求假设以左边最高点为水的高度，会积多少水；再求假设以右边最高点为水的高度，会积多少水。两者较小值即为该瓦片上积的水，变量累计即可。

在循环的过程中，需要不断更新最高点。

### 代码和[提交记录](https://www.luogu.com.cn/record/126272241)
```cpp
#include<bits/stdc++.h>
using namespace std;

void change(int &r){
	r=(r*6807+2831)%201701;
}

int r,n,a[105];
int ans;
int lst;
int l[2][105];

int main(){
	scanf("%d%d",&n,&r);
	for(int i=1;i<=n;i++){
		a[i]=r%10;
		change(r);
	}
	for(int i=1;i<=n;i++){
		lst=max(lst,a[i]);
		l[0][i]=max(0,lst-a[i]);//以左边最高点为
	}
	lst=0;
	for(int i=n;i>0;i--){
		lst=max(lst,a[i]);
		l[1][i]=max(0,lst-a[i]);
	}
	for(int i=1;i<=n;i++)ans+=min(l[1][i],l[0][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Gongyujie123 (赞：4)

## [B3731 [信息与未来 2017] 房屋积水](https://www.luogu.com.cn/problem/B3731) 题解
### 1. 思路分析
首先，我们先根据题目中的方法，生成数列 $R$，再进一步求出每个瓦片的高度，其中第 $i (1 \le i \le n)$ 个瓦片的高度 $a_i = R_i \bmod 10$。

然后，对于每个瓦片，分别记录在它**左侧的最高的**瓦片的高度和在它**右侧的最高的**瓦片的高度，如果当前瓦片的高度**高于**在它左侧或右侧的最高的瓦片的高度，那么当前瓦片的积水格数为 0，否则当前瓦片的积水格数就为在它左侧与右侧的最高的瓦片的高度的较小值减去当前瓦片的高度，即 
$$b_i = \max( 0,\min(l,r)-a_i) $$
其中 $b_i$ 为第 $i$ 个瓦片的积水格数，$l$ 为在第 $i$ 个瓦片左侧的最高的瓦片的高度，$r$ 为在第 $i$ 个瓦片右侧的最高的瓦片的高度 $(1 \le i \le n)$。

最后，答案 $ans$ 就为所有瓦片的积水格数之和，即
$$ans = \sum_{i = 1}^{n} b_i$$

### 2. AC 代码
[AC 记录](https://www.luogu.com.cn/record/206933667)。  
时间复杂度：$O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int r[102], a[102];
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin >> n >> r[1];
	for (int i = 2; i <= n; i++) {
		r[i] = (r[i-1] * 6807 + 2831) % 201701;
	}
	for (int i = 1; i <= n; i++) {
		a[i] = r[i] % 10;
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		int l = 0, r = 0;
		for (int j = 1; j <= n; j++) {
			if (j == i) continue;
			if (j < i) l = max(l, a[j]);
			if (j > i) r = max(r, a[j]);
		}
		ans += max(0ll, min(l, r) - a[i]);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Mark_Pei (赞：2)

一道模拟题，略难。

要解决这个问题，我们需要计算屋顶在暴雨后的积水量。屋顶由一系列高度不同的瓦片组成，每个瓦片的宽度为 $1$，高度由给定的数列生成。积水的条件是：一个方格向左右两侧延伸都能到达瓦片占据的方格。

#### 献上我的思路：
生成瓦片高度,根据题目中给出的生成数列公式，生成每个瓦片的高度。

计算积水量，对于每个位置，找到其左侧和右侧的最高瓦片高度，取两者中的较小值，然后减去当前瓦片的高度，即为该位置的积水量。

累加积水量,将所有位置的积水量累加，得到总的积水量。

按要求一步步模拟题意即可。

**至于时间和空间复杂度：**

时间复杂度：$O(n)$，其中 $n$ 是瓦片的数量。我们需要遍历数组三次，分别生成高度、计算左侧最大值和右侧最大值。

空间复杂度：还是 $O(n)$，用于存储高度、左侧最大值和右侧最大值的数组。

**AC** ~~code~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,n,a[103],b[2][103],s,c;
int main()
{
	cin>>n>>r;
	for(int i=1;i<=n;i++)
    {
        a[i]=r%10;
		r=(r*6807+2831)%201701;//模拟题意
	}
	for(int i=1;i<=n;i++)//计算积水量
    {
		c=max(c,a[i]);
		b[0][i]=max(0,c-a[i]);
	}
	c=0;
	for(int i=n;i>0;i--)
    {
		c=max(c,a[i]);
		b[1][i]=max(0,c-a[i]);
	}
	for(int i=1;i<=n;i++)//累加积水量
    {
        s+=min(b[1][i],b[0][i]);
    }
	cout<<s;
	return 0;
}
```

---

## 作者：Chengqijun2012 (赞：2)

一道不算太难的模拟题，但是要动点脑子。

### 题目步骤：
1. 先按照题目要求生成数列 $R$ ，顺便把 $a$ 数组的值也求出来。
2. 声明两个数组 $lmax$ 和 $rmax$ ，然后令 $lmax_{i}$ 表示在 $i$ 号位置以**左侧**的最高瓦片高度为水位的积水量；同理 $rmax_{i}$ 表示在 $i$ 号位置以**右侧**的最高瓦片高度为水位的积水量。根据“木桶效应”：一个木桶能装多少水，并不取决于最长的那块木板，而是取决于最短的那块木板（摘自百度百科），容易得出第 $i$ 个点的积水量等于 $\min(lmax_{i}, rmax_{i})$。
3. 最后开一个变量把每个点的积水量累加起来即可。

AC Code：
```cpp
#include <iostream>
#define ll long long
using namespace std;
const int N = 100 + 5;
int n, t, a[N], lmax[N], rmax[N], maxx, ans;

void make_R(){      //生成数列
	for(int i = 1; i <= n; i++){
		a[i] = t % 10;
		t = (t * 6807 + 2831) % 201701;
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> t;
	make_R();
	for(int i = 1; i <= n; i++){      //以左侧的最高瓦片高度为水位的积水量
		maxx = max(maxx, a[i]);      //更新最高点
		lmax[i] = max(0, maxx - a[i]);
	}
	maxx = 0;      //记得归0！！！
	for(int i = n; i > 0; i--){      //以右侧的最高瓦片高度为水位的积水量
		maxx = max(maxx, a[i]);      //更新最高点
		rmax[i] = max(0, maxx - a[i]);
	}
	for(int i = 1; i <= n; i++) ans += min(lmax[i], rmax[i]);      //取min再累加
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：Bill_luogu (赞：2)

## 题目思路：
我们从题目中得知：如果一个方格向左右两侧延伸都能到达瓦片占据的方格，它就会积水。我们开两个数组，一个记录当前格子向左延伸的积水量，一个记录当前格子向右延伸的积水量。最后累加每个格子**最少**的积水量。  
为什么是**最少**呢？  
很简单，因为每个格子的积水量取决于向左右两侧延伸都能到达瓦片的**最低高度**。  
**AC Code：**
```cpp
#include<iostream>
using namespace std;
int n,r1,a[110],l[110],r[110],maxx;
long long ans;
int main()
{
	cin>>n>>r1;
	for(int i=1;i<=n;i++)//生成瓦片高度
	{
		a[i]=r1%10;
		r1=(r1*6807+2831)%201701;
	}
	for(int i=1;i<=n;i++)//向左延伸
	{
		maxx=max(maxx,a[i]);
		l[i]=max(0,maxx-a[i]); 
	}
	maxx=0;
	for(int i=n;i>=1;i--)//向右延伸
	{
		maxx=max(maxx,a[i]);
		r[i]=max(0,maxx-a[i]);
	}
	for(int i=1;i<=n;i++)
		ans=ans+min(r[i],l[i]);//取最小值
	cout<<ans;
	return 0;
}
```

---

## 作者：no_response (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/B3731)
## 解题思路
首先需计算每个瓦片的高度。  
对于每个瓦片，我们需求出当前瓦片所在区域内水位的高度。  

先假设以左边最高点为水位的高度，会积多少水。  
再求假设以右边最高点为水的高度，会积多少水。  
两次假设中较小值即为该瓦片上积的水，用变量累计即可。

在循环的过程中，我们需不断更新最高点。
最终再将答案输出。
## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105], b[2][105];
int main() {
	int n, r;
	cin >> n >> r;
	int ans = 0, sum = 0;
	for (int i = 1; i <= n; i++) {
		a[i] = r % 10;
		r = (r * 6807 + 2831) % 201701;
	}
	for (int i = 1; i <= n; i++) {
		sum = max(sum, a[i]);
		b[0][i] = max(0, sum - a[i]);
	}
	sum = 0;
	for (int i = n; i > 0; i--) {
		sum = max(sum, a[i]);
		b[1][i] = max(0, sum - a[i]);
	}
	for (int i = 1; i <= n; i++) {
		ans += min(b[1][i], b[0][i]);
	}
	cout << ans;
	return 0;
}
```
为保持洛谷的良好学习习惯，请勿抄袭。  
**千万别抄袭哦。**  
管理大大辛苦了，各位大佬给蒟蒻点个赞呗。

---

## 作者：jiezecheng (赞：1)

## 题解：[B3731 [信息与未来 2017] 房屋积水](https://www.luogu.com.cn/problem/B3731)

### 做题情况
共用时 $15\min$ 写出代码，

不难，需要一些小思维。

[提交记录](https://www.luogu.com.cn/record/206930412)
### 主体思路
首先根据递推公式求得 $a$ 数组，

对于瓦片 $a_i$ ，可以积水的要求有 $2$ 点：
1. 左方最高的瓦片 $l_{\max}$ 小于自身高度；
2. 右方最高的瓦片 $r_{\max}$ 小于自身高度。
   
满足这 $2$ 点的瓦片可以积水的高度为：
$$
\min(l_{\max},r_{\max})-a_i
$$
 如果暴力每个瓦片左右的最大值，复杂度就是 $O(n^2)$。

但是注意到所求的数值为 $1\sim i$ 与 $i\sim n$ 的最大值，则可以考虑使用前缀和，两个数组 $\text{leftmax}$ 与 $\text{rightmax}$，记录 $1\sim i$ 与 $i\sim n$ 的最大值。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int calc(int x){
    return (x*6807+2831)%201701;
}
int a[N];
int leftmax[N];
int rightmax[N];
int main(){
    int n,r1;
    cin>>n>>r1;
    for(int i=1;i<=n;i++){
        a[i]=r1%10;
        r1=calc(r1);
    }
    for(int i=1;i<=n;i++){
        leftmax[i]=max(leftmax[i-1],a[i]);
    }
    for(int i=n;i>=1;i--){
        rightmax[i]=max(rightmax[i+1],a[i]);
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(leftmax[i]>a[i] and rightmax[i]>a[i]){
            ans+=min(leftmax[i],rightmax[i])-a[i];
        }
    }
    cout<<ans<<endl;
}
```
### 时间复杂度分析
处理数组 $a$ 为 $O(n)$。

预处理两个数组为 $O(n)$。

输出答案 $O(n)$。

所以程序总时间复杂度为 $O(n)$。

---

## 作者：getchar_unlocked (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3731)

### 思路

首先初始化 $R_i$，再令 $A_i=R_i\bmod10$，表示每个瓦片的高度。

正序遍历 $A_i$，用 $L_{\max,i}$ 表示前 $i$ 个瓦片的最大值，则 $L_{\max,i}\gets\max(L_{\max,i-1},A_i)$。同理初始化 $R_{\max,i}$，表示第 $i$ 个及以后的瓦片的最大值。

最后遍历一遍，统计积水之和，即 $\sum\min(L_{\max,i},R_{\max,i})-A_i$。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=105;
int a[N],r[N],l_max[N],r_max[N];
int main(){
	int n=read();r[1]=read();
	a[1]=r[1]%10;
	for(int i=2;i<=n;++i){
		r[i]=(r[i-1]*6807+2831)%201701;
		a[i]=r[i]%10;
	}
	l_max[1]=a[1];
	for(int i=2;i<=n;++i)
		l_max[i]=max(l_max[i-1],a[i]);
	r_max[n]=a[n];
	for(int i=n-1;i>=1;--i)
		r_max[i]=max(r_max[i+1],a[i]);
	int res=0;
	for(int i=1;i<=n;++i)
		res+=min(l_max[i],r_max[i])-a[i];
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 题意简述
  - 题目要求计算暴雨后屋顶积水方格的总数。屋顶由多个连续瓦片组成，每个瓦片的高度由生成的数列确定。只有当某个方格的左右两侧都有瓦片时，该方格才会积水。问有多少个方格会积水。
# 解题思路
  - 通过题目中的 $r_1$ 和递推公式算出数组 $a$。
  - 遍历每一层，算出每一层中第一个瓦片的位置 $fst$ 和最后一个瓦片的位置 $lst$。
  - 遍历每一个方格，更新答案 $ans$。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r[101],a[101],b[101][101],fst[101],lst[101],ans=0;
int main()
{
	scanf("%d%d",&n,&r[1]);
	for(int i=2;i<=n;i++)
	r[i]=(r[i-1]*6807+2831)%201701;
	for(int i=1;i<=n;i++)
	a[i]=r[i]%10;
	for(int i=1;i<=n;i++)
	{
		for(int j=n;j>=n-a[i]+1;j--)
		b[j][i]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(b[i][j]==1)
			{
				fst[i]=j;
				break;
			}
		}
		for(int j=n;j>=1;j--)
		{
			if(b[i][j]==1)
			{
				lst[i]=j;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=fst[i];j<=lst[i];j++)
		{
			if(b[i][j]==0)
			b[i][j]=2;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(b[i][j]==2)
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
}
```
# 程序细节
  - $b_{i,j}=0$ 则该方格中没有瓦片，也没有水。
  - $b_{i,j}=1$ 则该方格中有瓦片。
  - $b_{i,j}=2$ 则该方格中有水。

---

## 作者：LoongPig (赞：0)

## 题意

这道题让我们求出每一个瓦片所在区域内水的高度，最后输出积水高度的总和。

## 思路

1. 根据题目中的方法，求出每一片瓦片的高度；

1. 对于第 $i$ 个瓦片，我们分别记录左侧 $i$ 个瓦片中最高瓦片的高度和右侧 $n-i+1$ 个瓦片中最高瓦片的高度；

1. 令 $b_i$ 为第 $i$ 个瓦片的积水高度，$l_i$ 为左侧 $i$ 个瓦片中最高瓦片的高度，$r_i$ 为右侧 $i$ 个瓦片中最高瓦片的高度，则：

   $$b_i=\max(\min(l_i,r_i),0)$$

1. 把序列 $b$ 中所有项加起来就行了。

## 标程

[提交记录](https://www.luogu.com.cn/record/208855772)

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,a[105],n,maxl[105],maxr[105];
int main(){
	cin>>n>>r;
	for(int i=1;i<=n;i++){
		a[i]=r%10;
		r=(r*6807+2831)%201701;
	}
	for(int i=1;i<=n;i++){
		maxl[i]=max(maxl[i-1],a[i]);
		maxr[n-i+1]=max(maxr[n-i+2],a[n-i+2]);
        //计算l[i]和r[i]
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=max(0,min(maxl[i],maxr[i])-a[i]);
        //求和
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：HsNu1ly7_ (赞：0)

## 思路

对于每一列，分别统计该列左侧最高和该列右侧最高的瓦片。

如果左侧或右侧最高瓦片没有当前瓦片高，就不能积水。

否则计算积水量，第 $i$ 列的积水量为 $\min(maxn_1 , maxn_2) - a_i$，$maxn_1 , maxn_2$ 分别代表该列左侧最高瓦片高度和右侧最高瓦片高度。

时间复杂度为：$O(n^2)$。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep( i , l , r ) for (int i = (l) ; i <= (r) ; i++)
#define per( i , r , l ) for (int i = (r) ; i >= (l) ; i--)
int n ;
int a[110] ;
int f[110][2] ;
int r ;
void solve (){
	cin >> n >> r ;
	rep (i , 1, n){
		a[i] = r % 10 ;
		a[i] %= 10 ;
		r = (r * 6807 + 2831) % 201701 ;
	}
	int ans = 0 ;
	rep (i , 1 , n){
		int maxn = -1 ;
		rep (j , 1 , i - 1){
			maxn = max (maxn , a[j]) ;
		}
		int maxn1 = -1 ;
		rep (j , i + 1 , n){
			maxn1 = max (maxn1 , a[j]) ;
		}
		if (maxn == -1 || maxn1 == -1){
			continue ;
		}
		ans += max (0ll , min (maxn , maxn1) - a[i]) ;
	}
	cout << ans ;
}

signed main (){
	int _ = 1 ;
	//cin >> _ ;
	while ( _-- ){solve () ;}
	return 0 ;
}
```

---

## 作者：aaalys (赞：0)

## 思路

第一步肯定是处理出 $R$ 数列和 $a$ 数列。

接着对于每个 $i \in [1,n]$，考虑位置 $i$ 上面水的高度。

$i$ 上面水的高度一定是左边有一个 $j<i$ 且 $a_j>a_i$ 的 $j$，右边也有一个 $k>i$ 且 $a_k>a_i$ 的 $k$。

答案就是 $j\sim k$ 之间水的高度减去 $a_i$，即 $\min{(a_j,a_k)}-a_i$。

可能有多个 $j$ 和 $k$，需要取最大的 $a_j$ 和 $a_k$。

也有可能没有 $j$ 或 $k$，那么答案为 0。为了统一计算，可以不限制 $a_j>a_i$ 和 $a_k>a_i$，将位置 $i$ 上面水的高度设为 $\max{(0,\min{(a_j,a_k)}-a_i)}$。

这样就能得出答案，时空复杂度均为 $O(n)$。

## Code（只展示关键代码）

```cpp
//输入，生成a和r。我这里不写，请读者自行思考。
for (int i = 1; i <= n; i++)//左边的最大值。
  lmx[i] = max(lmx[i - 1], a[i]);
for (int i = n; i; i--)//右边的最大值。
  rmx[i] = max(rmx[i + 1], a[i]);
for (int i = 1; i <= n; i++)//累加答案
  ans += max(0, min(lmx[i], rmx[i]) - a[i]);
```

---

## 作者：xuyifei0302 (赞：0)

这道题让我们要求出每一个瓦片所在区域内水的高度，最后输出积水方格总数。

我们可以考虑先求出以左边的瓦片为水的最高点所积水的方格总数，然后求出以右边的瓦片为水的最高点所积水的方格总数，二者的较小值就是这个瓦片上所积攒的水。

但是有一点值得注意，输入是由固定的生成函数生成，记得注意数值。

下面是代码环节：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, randseed, a[105], l[105], r[105];
int rnd_(int x) {
	return (x * 6807 + 2831) % 201701;	
}
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> randseed;
	for (int i = 1; i <= n; i ++) {
		a[i] = randseed % 10;
		randseed = rnd_(randseed);
	}
	int maxn = -1;
	for (int i = 1; i <= n; i ++) {
		maxn = max(maxn, a[i]);
		l[i] = max(maxn - a[i], 0);
	}
	maxn = -1;
	for (int i = n; i >= 1; i --) {
		maxn = max(maxn, a[i]);
		r[i] = max(maxn - a[i], 0);
	}
	int ans = 0;
	for (int i = 1; i <= n; i ++) {
		ans += min(l[i], r[i]);	
	}
	cout << ans;
	return 0;
}
```

---


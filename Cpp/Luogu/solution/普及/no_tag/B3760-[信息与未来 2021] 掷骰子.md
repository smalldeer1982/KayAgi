# [信息与未来 2021] 掷骰子

## 题目背景

骰子是一个正六面体（立方体），每一面上有圆点表示的数字（圆点的数量表示数字的大小）。一个普通的骰子的六个面上分别有 $1\sim 6$ 这 $6$ 个不同的数字：

![](https://cdn.luogu.com.cn/upload/image_hosting/unawcttj.png)

## 题目描述

但是今天你得到了一个特殊的骰子，虽然每个面上的数字依然是 $1\sim 6$ 之间的一个，但不同面上的数字却可能重复。为了还原骰子上的数字，你使用摄像头从不同角度拍摄了多张骰子的照片（骰子可能在空间中任意翻转）。但限于摄像头的角度，你拍摄的每张照片都只能拍到骰子的三个面。

你需要根据摄像头拍摄到的多张照片，推断出骰子每个面上可能的数字。

## 说明/提示

### 样例解释
#### 样例 $1$
我们知道骰子上至少有三个 $1$、两个 $2$。剩下的数字可能是 $1$ 也可能是 $6$。

#### 样例 $2$
这是一个“普通”的骰子，$1\sim 6$ 这些数字恰好出现⼀次。

对于 $20\%$ 的数据，$0\le n\leq 1$。

对于 $100\%$ 的数据，$0\leq n\leq 20$。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
2
1 1 1
2 2 1```

### 输出

```
8 13```

## 样例 #2

### 输入

```
2
1 2 3
4 5 6```

### 输出

```
21 21```

# 题解

## 作者：zengyongxu (赞：23)

# B3760 [信息与未来 2021] 掷骰子 题解

### 写在前面

下文中图片可能字不是很好看，如果需调整指出即可。

UPD 7/27 将图床链接更新

### 正片

首先，这道题的这一个部分很吸引人：

$0\leq n\leq 20$

的确，这提示了这题的一个不错的想法：暴力枚举，检验。

### 第一部分：暴力枚举
非常容易（不用想象中复杂的深搜），只需要一个六重循环即可。

随后根据题意修改：
```cpp
int mn = 50, mx = 1;
for (a = 1; a <= 6; a++)
{
    for (b = 1; b <= 6; b++)
    {
        for (c = 1; c <= 6; c++)
        {
            for (d = 1; d <= 6; d++)
            {
                for (e = 1; e <= 6; e++)
                {
                    for (f = 1; f <= 6; f++)
                    {
                        int sum = a + b + c + d + e + f;
                        if (judge()){
                            mn = min(mn, sum);
                            mx = max(mx, sum);
                        }
                    }
                }
            }
        }
    }
}
```

### 第二部分：检验

根据上文所说，我们需要一个用于检验的函数。

那么代码：
```cpp
bool judge()
{
    // ...
}
```

然后，我们只需要枚举每一个条件，看看有没有符合的。

那么代码：
```cpp
bool judge()
{
    for (int i = 1; i <= n; i++)
    {
        // ...
    }
    return true;
}
```

接下来对循环里面的判断条件进行思考：

这里采取一种暴力的方式~~来映衬上面暴力的枚举~~：直接枚举每一种拍摄角度，判断是否和条件吻合即可，不过我们需要一些准备。

首先，我们计算不同角度拍摄的方案总数：一共有六个面，对于每个面在顶上，一共有四种拍摄角度，即：$6\times 4 = 24$。

那么，我们先画24个正方体：

![](https://cdn.luogu.com.cn/upload/image_hosting/vg8legw5.png)

随后，根据上面的计算，每个面作为顶有4个角度，于是我们把每个正方体的顶部画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/g2dk6o9f.png)

接着，只需要拿一个长方体（我选用了牛奶盒），六个面分别标上：`abcdef`。

出示一下我的标注字母的图片，以便下文描述。

~~众所周知，正方体展开图是六上第一个单元的内容。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/ah8d8nm3.png)

接下来，以每个面为顶，转动长方体，记录剩余两个面的字母。

以下是我的结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/iwdzoqd6.png)

那么判断函数也就能写出来了。这里的代码太长了，我就不出示了，毕竟在最后代码里也有的。

小技巧：

可以用：`uvw`来代替：$x_i,y_i,z_i$以减少代码量。

### 你们期待的 AC 代码！你的键盘上不只有 ctrl, c, v 这三个键！

~~不要贬我的码风555...~~
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 25;

int n, x[N], y[N], z[N];
int a, b, c, d, e, f;

bool judge()
{
    for (int i = 1; i <= n; i++)
    {
        int u = x[i], v = y[i], w = z[i];
        if (u == a && v == c && w == d)
            continue;
        if (u == a && v == d && w == f)
            continue;
        if (u == a && v == f && w == b)
            continue;
        if (u == a && v == b && w == c)
            continue;

        if (u == b && v == e && w == c)
            continue;
        if (u == b && v == c && w == a)
            continue;
        if (u == b && v == a && w == f)
            continue;
        if (u == b && v == f && w == e)
            continue;

        if (u == c && v == e && w == d)
            continue;
        if (u == c && v == d && w == a)
            continue;
        if (u == c && v == a && w == b)
            continue;
        if (u == c && v == b && w == e)
            continue;

        if (u == d && v == e && w == f)
            continue;
        if (u == d && v == f && w == a)
            continue;
        if (u == d && v == a && w == c)
            continue;
        if (u == d && v == c && w == e)
            continue;

        if (u == e && v == f && w == d)
            continue;
        if (u == e && v == d && w == c)
            continue;
        if (u == e && v == c && w == b)
            continue;
        if (u == e && v == b && w == f)
            continue;

        if (u == f && v == e && w == b)
            continue;
        if (u == f && v == b && w == a)
            continue;
        if (u == f && v == a && w == d)
            continue;
        if (u == f && v == d && w == e)
            continue;

        return false;
    }
    return true;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> x[i] >> y[i] >> z[i];
    }

    int mn = 50, mx = 0;
    for (a = 1; a <= 6; a++)
    {
        for (b = 1; b <= 6; b++)
        {
            for (c = 1; c <= 6; c++)
            {
                for (d = 1; d <= 6; d++)
                {
                    for (e = 1; e <= 6; e++)
                    {
                        for (f = 1; f <= 6; f++)
                        {
                            if (judge())
                            {
                                mn = min(mn, a + b + c + d + e + f);
                                mx = max(mx, a + b + c + d + e + f);
                            }
                        }
                    }
                }
            }
        }
    }

    cout << mn << " " << mx << "\n";
}
```

本蒟蒻耗费快两个月写完的 ~~（我只有周末或者放假有空）~~，重审多次，有错请指出，求赞 qwq。

---

## 作者：ztd___ (赞：6)

提供一个很不需要脑子但是又很对的做法。

好吧还是需要很强大的空间想象力。

- - -

看一下题目，发现 $n$ 非常小。所以考虑爆搜。~~其实复杂度与 $n$ 关系不大。~~

显然是爆搜出骰子的每种情况。具体地，枚举每个面上填 $1$ 到 $6$ 中的每一个数字，再暴力地判断这个骰子是否可以满足 $n$ 个条件中的每一个。

考虑到这个爆搜的维数是固定的，我们直接用一个嵌套的 $6$ 层 `for` 循环来枚举。这样的优势在于逻辑非常清晰，但劣势在于码量非常惊人。~~非常适合像我这种做题不带脑子的人。~~

- - -

接下来难点就在判断上面。我们假设 $6$ 个面上的数字分别为 $a$，$b$，$c$，$d$，$e$，$f$。

**建议拿一张纸折一下看看，实在不行也要画一下。**  
如果你是立体几何大蛇就当我没说。

我们条件比较简陋，所以就画一下这个展开图。

![](https://cdn.luogu.com.cn/upload/image_hosting/azko5cem.png)

不难发现，每次拍摄的照片里面，只有 $1$ 个顶点是被**完整地**拍下来的。（即**完全包含**了这个顶点和与它相邻的 $3$ 条棱、$3$ 个面。）  
然后通过小学知识可以知道一个正方体有 $8$ 个顶点，所以我们直接暴力地将每一次拍摄的照片所对应的点和每个顶点去匹配，具体的 $8$ 种情况如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/85ksdoeb.png)

然后我们有了初步的代码。

建议发现匹配上了就直接 `continue` 掉，然后在单次循环的末尾直接 `return 0;`。一来是省下了标记变量，二来待会复制粘贴也方便。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[50], y[50], z[50];
bool check(int a, int b, int c, int d, int e, int f) {
    for (int i = 1;i <= n;i++) {
        if (a == x[i] && b == y[i] && d == z[i]) continue;
        if (c == x[i] && b == y[i] && a == z[i]) continue;
        if (b == x[i] && e == y[i] && d == z[i]) continue;
        if (c == x[i] && e == y[i] && b == z[i]) continue;
        if (e == x[i] && f == y[i] && d == z[i]) continue;
        if (a == x[i] && d == y[i] && f == z[i]) continue;
        if (c == x[i] && f == y[i] && e == z[i]) continue;
        if (f == x[i] && c == y[i] && a == z[i]) continue;
        return 0;
    }
    return 1;
}
signed main() {
    cin >> n;
    for (int i = 1;i <= n;i++)
        cin >> x[i] >> y[i] >> z[i];
    int minx = 1e18, maxx = -1e18;
    for (int a = 1;a <= 6;a++)
        for (int b = 1;b <= 6;b++)
            for (int c = 1;c <= 6;c++)
                for (int d = 1;d <= 6;d++)
                    for (int e = 1;e <= 6;e++)
                        for (int f = 1;f <= 6;f++)
                            if (check(a, b, c, d, e, f)) {
                                int s = a + b + c + d + e + f;
                                minx = min(s, minx), maxx = max(s, maxx);
                            }
    cout << minx << " " << maxx;
    return 0;
}
```

然而提交发现只有 30pts。原因是我们忽略了下面的情况：即使拍摄的是同一个顶点，骰子本身也是可以绕着这个顶点来旋转的。

即并非总是上面是 $x$，前面是 $y$，右面是 $z$。

**这也是图与代码不完全相同的原因。**

经过手玩可以发现骰子可以转成下面的样子。

![](https://cdn.luogu.com.cn/upload/image_hosting/ajpnzy8v.png)

所以我们只要把 $x$，$y$，$z$ 互换几下，再判断几次即可。这里建议是用另外 $3$ 个变量来存储 $x$，$y$，$z$，这样复制自己的代码时要改的就会少一点。

- - -

分析一下复杂度。我分析的可能不太准确，如有错欢迎指出。

我们的判断函数中进行了 $n$ 次的循环，但是循环内有 $24$ 倍的大常数。所以判断的复杂度是 $O(24 \times n)$，可能还要多一点。

然后主函数里 $6$ 层的 `for` 循环，复杂度显然是 $O(6 ^ 6)$。

总复杂度就是 $O(6 ^ 6 \times 24 \times n) = O(1119744 \times n)$。因为 $n \le 20$，所以随便过。

当然你要说 $1119744$ 是常数所以复杂度是 $O(n)$ 我也没有话说。

<https://www.luogu.com.cn/record/213271173>

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[50], y[50], z[50];
bool check(int a, int b, int c, int d, int e, int f) {
    for (int i = 1;i <= n;i++) {
        int X = x[i], Y = y[i], Z = z[i];
        if (a == X && b == Y && d == Z) continue;
        if (c == X && b == Y && a == Z) continue;
        if (b == X && e == Y && d == Z) continue;
        if (c == X && e == Y && b == Z) continue;
        if (e == X && f == Y && d == Z) continue;
        if (a == X && d == Y && f == Z) continue;
        if (c == X && f == Y && e == Z) continue;
        if (f == X && c == Y && a == Z) continue;
        X = y[i], Y = z[i], Z = x[i];
        if (a == X && b == Y && d == Z) continue;
        if (c == X && b == Y && a == Z) continue;
        if (b == X && e == Y && d == Z) continue;
        if (c == X && e == Y && b == Z) continue;
        if (e == X && f == Y && d == Z) continue;
        if (a == X && d == Y && f == Z) continue;
        if (c == X && f == Y && e == Z) continue;
        if (f == X && c == Y && a == Z) continue;
        X = z[i], Y = x[i], Z = y[i];
        if (a == X && b == Y && d == Z) continue;
        if (c == X && b == Y && a == Z) continue;
        if (b == X && e == Y && d == Z) continue;
        if (c == X && e == Y && b == Z) continue;
        if (e == X && f == Y && d == Z) continue;
        if (a == X && d == Y && f == Z) continue;
        if (c == X && f == Y && e == Z) continue;
        if (f == X && c == Y && a == Z) continue;
        return 0;
    }
    return 1;
}
signed main() {
    cin >> n;
    for (int i = 1;i <= n;i++)
        cin >> x[i] >> y[i] >> z[i];
    int minx = 1e18, maxx = -1e18;
    for (int a = 1;a <= 6;a++)
        for (int b = 1;b <= 6;b++)
            for (int c = 1;c <= 6;c++)
                for (int d = 1;d <= 6;d++)
                    for (int e = 1;e <= 6;e++)
                        for (int f = 1;f <= 6;f++)
                            if (check(a, b, c, d, e, f)) {
                                int s = a + b + c + d + e + f;
                                minx = min(s, minx), maxx = max(s, maxx);
                            }
    cout << minx << " " << maxx;
    return 0;
}
```

对没有经过手玩就下定论说数据有误的行为提出批评。

---

## 作者：沉石鱼惊旋 (赞：4)

# 前言

2025.04.07 晚。被 cz 拷打让我看一眼这个题讨论区。经过我的手算和代码验证，我們的數據並非確有問題。考虑到这个题可能目前网上没有任何一份正确题解，遂写此文。

强烈谴责套数据特判过题来写错误题解的行为。

# 做法

这个数据范围很小啊，我们可以枚举这个骰子的所有面，然后判断要求的 $n$ 个限制对应的 $3$ 个面是否出现。

考虑怎么判断三个面是否出现。

我们小学就学过立方体的展开。让我们把他展开出来看一看。

![](https://cdn.luogu.com.cn/upload/image_hosting/mt4x3fcu.png)

如图是 1-4-1 类型的展开。注意题目给出的 $(x,y,z)$ 是有顺序的。$x$ 在最上方，$y,z$ 从左向右。

我们把每个点作为最上方的点，然后把这个立方体想象出来（实在不行咱拿张纸折一下），把某一面朝上时，中间四面的顺序写出来。那么我们判断是否存在一个 $(x,y,z)$ 的图，就是判断 $x$ 作为顶端的时候，是否 $y$ 的下一个面是 $z$。例如按本图标号，则 $1$ 面朝上时，依次是 $2,3,4,5$。说明 $(1,2,3),(1,3,4),(1,4,5),(1,5,2)$ 都是正确的视角。

所以我们在搜出这个立方体每一面的数之后，对于每一条限制我们都看一下是否存在这样的一张 $(x,y,z)$ 的图。如果没有那么这个方案就是不合法的。

---

另外附一份数据以及对应的唯一解，这一份数据好像卡死了很多人，但事实上数据并没有错误：

```plain
5
1 6 3
2 3 6
3 6 1
6 3 2
1 3 1
```

![](https://cdn.luogu.com.cn/upload/image_hosting/dyyeb0vj.png)

# 代码

<https://www.luogu.com.cn/record/212499277>

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>
void chkmx(T &x, T y) { x = max(x, y); }
template <typename T>
void chkmn(T &x, T y) { x = min(x, y); }
const int inf = 1e9;
int mn = inf, mx = -inf;
int mp[7];
int n;
struct node
{
    int x, y, z;
} a[50];
int e[7][4] = {
    {0, 0, 0, 0},
    {2, 3, 4, 5},
    {1, 5, 6, 3},
    {1, 2, 6, 4},
    {1, 3, 6, 5},
    {1, 4, 6, 2},
    {5, 4, 3, 2}};
void dfs(int dep)
{
    if (dep == 7)
    {
        int ans = accumulate(mp + 1, mp + 7, 0);
        for (int i = 1; i <= n; i++)
        {
            auto [x, y, z] = a[i];
            bool ok = 0;
            for (int tx = 1; tx <= 6; tx++)
            {
                for (int j = 0; j < 4; j++)
                {
                    int ty = e[tx][j];
                    int tz = e[tx][(j + 1) % 4];
                    if (mp[tx] == x && mp[ty] == y && mp[tz] == z)
                    {
                        ok = 1;
                        break;
                    }
                }
                if (ok)
                    break;
            }
            if (!ok)
                return;
        }
        chkmn(mn, ans);
        chkmx(mx, ans);
        return;
    }
    for (int i = 1; i <= 6; i++)
    {
        mp[dep] = i;
        dfs(dep + 1);
    }
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i].x >> a[i].y >> a[i].z;
    dfs(1);
    cout << mn << ' ' << mx << '\n';
    return 0;
}
```

---

## 作者：Mark_Pei (赞：3)

## Solution

对于这道题，可以用**贪心**~~大法~~做 。

我们需要根据给定的骰子拍摄结果，推断出骰子六个面上数字的可能组合。骰子的每个面数字可以是 $1$ 到 $6$，可能有重复。每张照片能看到三个面，所有照片都是从同一个骰子拍摄的。我们需要找到满足所有照片条件的骰子数字和的最小值和最大值。这是，我们可以用到贪心来求最值。

## 解题思路

先统计每个数字的最小出现次数，对于每个数字（$1$ 到 $6$），它在骰子上的出现次数至少是所有照片中该数字出现次数的最大值。例如，如果一个数字在多个照片中出现，那么它在骰子上的出现次数不能少于它在任何一张照片中出现的次数。更准确地说，对于每个数字 $i$，其在骰子上的出现次数至少是它在任何一张照片中出现的次数的最大值。例如，如果数字 $1$ 在某张照片中出现 $3$ 次，那么骰子上至少有 $3$ 个 $1$。

再确定剩余数字的分配，在满足最小出现次数后，剩下的数字可以自由分配（$1$ 到 $6$），但要保证骰子总共有 $6$ 个面。

最后计算最小和与最大和，最小和就是在剩余的数字中尽可能多地填 $1$。最大和则是在剩余的数字中尽可能多地填 $6$。这里是贪心的精髓，保证是最优解。

这样确保了在满足所有照片条件的情况下，能够正确计算骰子数字和的最小值和最大值。

### AC code


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[103],y[103],z[103];
bool p(int a,int b,int c,int d,int e,int f)
{
	for(int i=1;i<=n;i++)
	{
		int X=x[i],Y=y[i],Z=z[i];
		if((a==X&&b==Y&&d==Z)||(c==X&&b==Y&&a==Z)||(b==X&&e==Y&&d==Z)||(c==X&&e==Y&&b==Z)||(e==X&&f==Y&&d==Z)||(a==X&&d==Y&&f==Z)||(c==X&&f==Y&&e==Z)||(f==X&&c==Y&&a==Z)) continue;
		X=y[i],Y=z[i],Z=x[i];
		if((a==X&&b==Y&&d==Z)||(c==X&&b==Y&&a==Z)||(b==X&&e==Y&&d==Z)||(c==X&&e==Y&&b==Z)||(e==X&&f==Y&&d==Z)||(a==X&&d==Y&&f==Z)||(c==X&&f==Y&&e==Z)||(f==X&&c==Y&&a==Z)) continue; 
		X=z[i],Y=x[i],Z=y[i];
		if((a==X&&b==Y&&d==Z)||(c==X&&b==Y&&a==Z)||(b==X&&e==Y&&d==Z)||(c==X&&e==Y&&b==Z)||(e==X&&f==Y&&d==Z)||(a==X&&d==Y&&f==Z)||(c==X&&f==Y&&e==Z)||(f==X&&c==Y&&a==Z)) continue;
		return 0;
	}
	return 1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>x[i]>>y[i]>>z[i];
	int minn=1e9,maxx=-1e9;
	for(int a=1;a<=6;a++)
		for(int b=1;b<=6;b++)
			for(int c=1;c<=6;c++)
				for(int d=1;d<=6;d++)
					for(int e=1;e<=6;e++)
						for(int f=1;f<=6;f++)
				 			if(p(a,b,c,d,e,f)) 
				 			{
				 				int s=a+b+c+d+e+f;
								minn=min(s,minn),maxx=max(s,maxx);
							 }
	cout<<minn<<" "<<maxx;
	return 0;
 }
```

---


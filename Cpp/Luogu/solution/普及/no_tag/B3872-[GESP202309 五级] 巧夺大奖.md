# [GESP202309 五级] 巧夺大奖

## 题目描述

小明参加了一个巧夺大奖的游戏节目。主持人宣布了游戏规则：

1. 游戏分为 $n$ 个时间段，参加者每个时间段可以选择一个小游戏。

2. 游戏中共有 $n$ 个小游戏可供选择。

3. 每个小游戏有规定的时限和奖励。对于第 $i$ 个小游戏，参加者必须在第 $T_i$ 个时间段结束前完成才能得到奖励 $R_i$。

小明发现，这些小游戏都很简单，不管选择哪个小游戏，他都能在一个时间段内完成。关键问题在于，如何安排每个时间段分别选择哪个小游戏，才能使得总奖励最高？

## 说明/提示

**样例解释 1**

$7$ 个时间段可分别安排完成第 4、2、3、1、6、7、5 个小游戏，其中第 4、2、3、1、7 个小游戏在期限内完成。因此，可以获得总计 $40+60+50+70+10=230$ 的奖励。

## 样例 #1

### 输入

```
7
4 2 4 3 1 4 6
70 60 50 40 30 20 10```

### 输出

```
230```

# 题解

## 作者：cool_xu (赞：494)

[博客中食用更佳～](https://www.luogu.com.cn/blog/cool-xu/mido-kosark-ti-xie)

[题目传送门](https://www.luogu.com.cn/problem/B3872)

## Part 1.题目大意
很好理解，就是有 $n$ 个项目，每个项目有规定时限，时限内完成有奖金，求最多能得到多少奖金。

## Part 2.蒟蒻的思路
### 一眼杀，贪心！

（我是不会告诉你我写过差不多的[题](https://wzoi.cc/s/1/2459)的）

以奖金为关键字进行排序，然后再按顺序将每个项目进行枚举，枚举这个项目的时限内有没有空闲时间来完成这个项目。如果有，就标记一下这个时间并将答案加上这个项目的奖金。（**记住，得从大时间往小时间枚举！！！**）

输出答案，完成！

## Part3.蒟蒻的代码
```
#include <bits/stdc++.h> //万能头起手
using namespace std;
struct data{
	int money,time;
}a[10001]; //记录每个项目的数据以用来sort的结构体数组
int n,m,b[10001];
bool cmp(data x,data y){
	return x.money>=y.money;
} //sort排序的自定顺序函数
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].time;
	}for(int i=1;i<=n;i++){
		cin>>a[i].money;
	} //相信我，cin读入不会超时
   sort(a+1,a+1+n,cmp); //sort排序
	for(int i=1;i<=n;i++){
		bool c=false; //判断是否有空闲时间的布尔值
		for(int j=a[i].time;j>=1;j--){ //从大时间往小时间枚举
			if(b[j]==0){ //判断时间是否空闲
				b[j]=1; //标记
				c=true; //有空闲时间
				break; //跳出
			}
		}if(c){ //好耶，项目可以完成
			m+=a[i].money; //加奖金！
		}
	}cout<<m; //汇报一日战果
	return 0;
}
```

任务完成！谢谢您的阅读～（可以顺手点个赞咩？）

---

## 作者：zjhzs666 (赞：39)



# B3872 [GESP202309 五级] 巧夺大奖 题解


## 题意


有 $n$ 个游戏在 $n$ 个时间段内进行，告诉你每个游戏规定的最大时限与完成游戏后得到的奖金，且完成一个游戏只需要占用一个时间段，同一时间段内只能进行一个游戏，求能够获得的最大奖金。


## 思路


由于完成一个游戏只需要一个时间段，因此我们应优先完成奖金较大的游戏，为了避免奖金相同的游戏中时限较大的游戏影响到时限较小的游戏，我们应优先选择较大的时间段，所以我们可以利用贪心的思想来对该题进行求解。


## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
struct game{
	int q,w;
}a[511];
int n,ans,f[511];
bool cmp(game a,game b){
	return a.w>b.w;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].q;
	for(int i=1;i<=n;i++)cin>>a[i].w;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
		for(int j=a[i].q;j>0;j--)
			if(!f[j]){
				f[j]=1;
				ans+=a[i].w;
				break;
			}
	cout<<ans;
	return 0;
} 
```



---

## 作者：wangjue1629 (赞：23)

# Solution
[题目传送门](https://www.luogu.com.cn/problem/B3872)

## 题目分析
这道题是一个经典的贪心算法问题，要求在有限的时间段内完成尽可能多的小游戏以获得最大的奖励。每个游戏有一个截止时间和一个奖励值。目标是制定一个策略来选择游戏，以最大化总奖励。

## 题目思路
这道题的关键在于如何选择和安排游戏。贪心就提供了一个有效的解决方案：优先考虑奖励最高的游戏。

## 解题步骤

1. 将所有游戏按照奖励值（$r$）降序排序。
2. 使用一个布尔数组来跟踪每个时间段是否已经被游戏占用。
3. 按排序后的顺序遍历。对于每个游戏，从其截止时间开始向前寻找第一个空闲的时间段进行安排。
4. 每次成功安排一个游戏，累加其奖励到总奖励中。

## AC Code
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn = 500 + 10;
bool flag[maxn] = {false};
struct Node{
    int r, d; //r 表示游戏的奖励，d表示游戏的截止时间
} a[maxn];
bool cmp(const Node& x, const Node& y){
    return x.r > y.r;
}
int main(){
    int n;
    cin >> n;
    for(int i = 0; i < n; ++i) {
        cin >> a[i].d;
    }
    for(int i = 0; i < n; ++i) {
        cin >> a[i].r;
    }
    sort(a, a + n, cmp);
    int ans = 0;
    for(int i = 0; i < n; ++i) {
        for(int t = a[i].d; t > 0; --t) {
        //如果找到一个空闲的时间段，那么安排游戏
            if(!flag[t]) {
                flag[t] = true; //标记时间段为已占用
                ans += a[i].r; //累加奖励
                break; //跳出循环
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```
时间复杂度：$O(n^2)$，可以通过本题。

---


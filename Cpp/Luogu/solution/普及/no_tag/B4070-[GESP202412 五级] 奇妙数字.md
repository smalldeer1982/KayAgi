# [GESP202412 五级] 奇妙数字

## 题目描述

小杨认为一个数字 $x$ 是奇妙数字当且仅当 $x=p^a$，其中 $p$ 为任意质数且 $a$ 为正整数。例如，$8=2^3$，所以 $8$ 是奇妙的，而 $6$ 不是。

对于一个正整数 $n$，小杨想要构建一个包含 $m$ 个奇妙数字的集合 $\{x_1,x_2,\cdots,x_m\}$，使其满足以下条件：
- 集合中不包含相同的数字。
- $x_1\times x_2\times \cdots\times x_m$ 是 $n$ 的因子（即 $x_1,x_2,\cdots,x_m$ 这 $m$ 个数字的乘积是 $n$ 的因子）。

小杨希望集合包含的奇妙数字尽可能多，请你帮他计算出满足条件的集合最多包含多少个奇妙数字。

## 说明/提示

#### 样例解释

关于本样例，符合题意的一个包含 $3$ 个奇妙数字的集合是 $\{2,4,8\}$。首先，因为 $2=2^1$，$4=2^2$，$8=2^3$，所以 $2,4,8$ 均为奇妙数字。同时，$2\times 4\times 8=64$ 是 $128$ 的的因子。

由于无法找到符合题意且同时包含 $4$ 个奇妙数字的集合，因此本样例的答案为 $3$。

#### 数据范围

对于 $100\%$ 的数据，保证 $2\le n\le 10^{12}$。

| 子任务编号 | 得分占比 | $n$ |
| :--: | :--: | :--: |
| $1$ | $20\%$ | $\le 10$ |
| $2$ | $20\%$ | $\le 1\,000$ |
| $3$ | $60\%$ | $\le 10^{12}$ |



## 样例 #1

### 输入

```
128```

### 输出

```
3```

# 题解

## 作者：FJ_EYoungOneC (赞：30)

### 解题思路

数字 $x$ 是奇妙数字当且仅当 $x=p^a$ 其中 $p$ 为任意质数且 $a$ 为正整数。

那么我们可以对 $n$ 进行质因子分解，并统计每个质数因子的个数。

假设数字 $n$ 含有 $9$ 个因子 $2$，那么可以凑出 $2^1, 2^2, 2^3$，共三个数。

那么我们需要计算的就是 $1+2+\dots+k > $ 因子的个数时 $k$ 的最小解，那么 $k-1$ 就是答案。

我们可以使用二分 $+$ 等差数列求和公式进行计算，由于数据范围较小（`long long` 范围以内，质因子最多个数的即为 $2^{63}$），直接模拟即可。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

LL x;

int calc(int x)
{
    int res = 0, k = 1;
    while (x >= k)
    {
        res ++;
        x -= k ++;
    }
    return res;
}

int main()
{
    cin >> x;
    
    LL res = 0;
    for (int i = 2; i <= x / i; ++ i )
    {
        int cnt = 0;
        while (x % i == 0)
            x /= i, cnt ++;
        if (cnt)
            res += calc(cnt);
    }
    
    if (x > 1)
        res ++;
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：niuniudundun (赞：14)

**注：本题解是按代码讲的，如果听不懂，可以边看代码边看解法。**

[原题](https://www.luogu.com.cn/problem/B4070)

# 题目大意

认为一个数字 $x$ 是奇妙数字当且仅当 $x=p^a$，其中 $p$ 为任意质数且 $a$ 为正整数。例如，$8=2^3$，所以 $8$ 是奇妙的，而 $6$ 不是。

对于一个正整数 $n$，构建一个包含 $m$ 个奇妙数字的集合 $\{x_1,x_2,\cdots,x_m\}$，使其满足以下条件：
- 集合中不包含相同的数字。
- $x_1\times x_2\times \cdots\times x_m$ 是 $n$ 的因子（即 $x_1,x_2,\cdots,x_m$ 这 $m$ 个数字的乘积是 $n$ 的因子）。

# 解法

**注：本题解是按代码讲的，如果听不懂，可以边看代码边看解法。**

一眼杀，数学。

$x$ 既然要拆成 $x=p^a$，由此我们判断出要先将 $n$ 进行质因子分解。

假设 $n=p_{1}^{q_{1}}\times \cdots \times p_{m}^{q_{m}}$。

在每轮循环中求出 $q_1\cdots q_m$，已知 $n=p_{1}^{q_{1}}\times \cdots \times p_{m}^{q_{m}}$，所以我们判断 $q_i$ 最多能拆成几个连续的数字之和（从 $1$ 开始），随后令集合长度 $m$ 加上这个数最多能拆成几个连续的数字之和即可。

最后还有一个特判，如果 $n$ 等于 $1$，那么集合中没有数，否则，众所周知 $n=n\times 1$，也就是说 $n$ 不等于 $1$ 时集合长度 $m$ 要加上 $1$ 最多能拆成几个连续的数字之和。

注意开 **$\texttt{long long}$**。

# 代码

复杂度：$O(\sqrt{n}\times \delta_{i})$，其中 $\delta_{i}$ 为 $q_i$ 最多能拆成几个连续的数字之和。

```cpp
#include<iostream>
using namespace std;
long long f(long long x){//qi 最多能拆成几个连续的数字之和
	long long ans0=0,t=1;
	while(x>=t){
		ans0++,x-=t,t++;
	}
	return ans0;
}
int main(){
	long long n,ans=0;
	cin>>n;
	for(long long i=2;i*i<=n;i++){//质因子分解
		if(n%i==0){
			long long sum=0;
			while(n%i==0){
				sum++;
				n=n/i;
			}
			ans+=f(sum);
		}
	}
	if(n!=1){//特判
		ans+=f(1);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：PCSJZ (赞：13)

## 思路

可以考虑质因数分解，使得最后每一个奇妙数字以及它们的乘积是 $n$ 的因数。

奇妙数字的定义：$x=p^a$。

所以在质因数分解的过程中，我们统计每个质因数有多少，然后统计可以分解成多少个奇妙数字。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>


using namespace std;

using ll = long long;
ll n, ans;

// cnt 为指数 
ll solve(ll cnt) {
	ll res = 0;
	ll tmp = 1;
	while (cnt >= tmp) { // 每次 - tmp 是使乘积为 n 
		cnt -= tmp;
		tmp++;
		res++;
	}
	return res;
} 

int main() {
	scanf("%lld", &n);
	for (ll i = 2; i * i <= n; i++) { // 质因数分解 
		if (n % i == 0) {
			ll cnt = 0;
			while (n % i == 0) {
				cnt++;
				n /= i;
			}
			ans += solve(cnt);
		}
	}	
	if (n != 1) // 没有分解彻底，还有一个质数 
		ans += solve(1); // 指数为 1 
	printf("%lld", ans);
	return 0;
}
``````

---

## 作者：Andy1101 (赞：10)

# [题目传送门](https://www.luogu.com.cn/problem/B4070)
# 思路
不难发现，因为 $x_1$ 到 $x_m$ 的积是 $n$ 的因数，所以我们可以将 $n$ 进行质因数分解，得到：
$$n = p_1^{r_1} \times p_2^{r_2} \times \dots \times p_s^{r_s}$$
对于每个 $r$，算出一个最小的 $k$ 使得 $1+2+ \dots +k \le r_i$，并累加答案。

最后还有一个特判，如果最后 $n$ 还大于 $1$，那么答案 $+1$。
# AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e7+5;
int query(int x)
{
	int cnt=0,t=1;
	while(x>=t)
	{
		cnt++;
		x-=t;
		t++;
	}
	return cnt;
}
signed main()
{
	int n,t,maxx=0;
	cin >>n;
	int sum=0;
	for(int i=2;i*i<=n;i++)
	{
		int cnt=0;
		while(n%i==0)
		{
			n/=i;
			cnt++;
			maxx=max(maxx,i);
		}
		sum+=query(cnt);
	}
	if(n>1) sum++;
	cout <<sum;
	return 0;
}

```

---

## 作者：SkyLines (赞：6)

## Solution

因为 $x$ 是次方的形式，所以将 $n$ 质因数分解。

设 $n=a_1^{b_1} \times a_2^{b_2} \times \dots \times a_r^{b_r}$。对于每个 $b_i$，对答案的贡献为：从 $1$ 一直加到 $t$，和小于等于 $b_i$ 中，$t$ 的最大值（整数）。因为，只有这样，才能使 $m$ 最大化。

一个小优化，$1$ 一直加到 $t$ 等于 $\frac{t^2+t}{2}$，$\frac{t^2+t}{2}=b_i$（求出的是 $t$ 的最大值，但不一定为整数，向下取整即可），移项得 $t^2+t-2 \times b_i=0$。$\Delta = 1^2 -4 \times 1 \times (-2b_i)=1+8b_i$，$t=\frac{-1 \pm \sqrt{\Delta}}{2 \times 1}=\frac{-1 \pm \sqrt{\Delta}}{2}$。负数舍去，$t=\frac{-1 + \sqrt{\Delta}}{2}$。

时间复杂度：$O(\sqrt{n})$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int max_(int aa, int bb){
	return aa > bb ? aa : bb;
}
int min_(int aa, int bb){
	return aa < bb ? aa : bb;
}
int abs_(int aa){
	return aa > 0 ? aa : -aa;
}
int pow_(int aa, int bb, int cc){
	int ans = 1;
	while(bb){
		if(bb & 1) ans = ans * aa % cc;
		aa = aa * aa % cc;
		bb >>= 1;
	}
	return ans;
}
int n, cnt, delt, ans;
int get(int aa){
	aa *= 2;
	delt = 1 + 4 * aa;
	return (int) ((sqrt(delt) - 1) / 2);
}
signed main(){
	scanf("%lld", &n);
	for(int i = 2; i * i <= n; i++){
		cnt = 0;
		while(!(n % i)){
			n /= i;
			cnt++;
		}
		ans += get(cnt);
	}
	if(n > 1) ans += get(1);
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Lcm_simida (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/B4070)

思路：很明显，因为从 $x_1$ 到 $x_m$ 的乘积是 $n$ 的因数，所以很容易想到对 $n$ 进行分解质因数。那么对于每一个 $x_i^{y_i}$ 想让它们组成的数更多，就要贪心使每次分解的数小，让每次分解的次数最小即可。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans,a[1000005],maxx;
int main(){
	cin>>n;m=n;
	for(long long i=2;i*i<=m;i++){
		while(m%i==0){
			m/=i;a[i]++;maxx=max(maxx,i);//cout<<i<<"\n";
		}
	}
	if(m>1) ans++;
	for(long long i=1;i<=maxx;i++){
		long long l=0,r=a[i]+1;
		while(l+1<r){
			long long mid=(l+r)>>1;
			if(mid*(mid+1)<=a[i]*2) l=mid;
			else r=mid;
		}
//		cout<<a[i]<<":"<<l<<"\n";
		ans+=l;
	}
	cout<<ans;
	return 0;
}
```

---


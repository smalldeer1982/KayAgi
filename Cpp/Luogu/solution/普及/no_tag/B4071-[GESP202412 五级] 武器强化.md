# [GESP202412 五级] 武器强化

## 题目描述

小杨有 $n$ 种武器和 $m$ 种强化材料。第 $i$ 种强化材料会适配第 $p_i$ 种武器，小杨可以花费 $c_i$ 金币将该材料对应的适配武器修改为任意武器。

小杨最喜欢第 $1$ 种武器，因此他希望适配该武器的强化材料种类数**严格大于**其他的武器，请你帮小杨计算为了满足该条件最少需要花费多少金币。

## 说明/提示

#### 样例解释

花费 $1$，将第三种强化材料的适配武器由 $3$ 改为 $1$。此时，武器 $1$ 有 $2$ 种强化材料适配，武器 $2$ 和武器 $3$ 都各有 $1$ 种强化材料适配，满足适配第 $1$ 种武器的强化材料种类数**严格大于**其他的武器。

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le n,m\le 1\, 000$，$1\le p_i\le n$，$1\le c_i\le 10^9$。

| 子任务编号 | 得分占比 | $n$ | $m$ |
| :--: | :--: | :--: | :--: |
| $1$ | $20\%$ | $\le 2$ | $\le 1\, 000$ |
| $2$ | $20\%$ | $\le 1\,000$ | $\le 2$ |
| $3$ | $60\%$ | $\le 1\, 000$ | $\le 1\, 000$ |


## 样例 #1

### 输入

```
4 4
1 1
2 1
3 1
3 2```

### 输出

```
1```

# 题解

## 作者：niuniudundun (赞：57)

[原题](https://www.luogu.com.cn/problem/B4071)

# 题目大意

有 $n$ 种武器和 $m$ 种强化材料。第 $i$ 种强化材料会适配第 $p_i$ 种武器，小杨可以花费 $c_i$ 金币将该材料对应的适配武器修改为任意武器。小杨最喜欢第 $1$ 种武器，因此他希望适配该武器的强化材料种类数**严格大于**其他的武器，请你帮小杨计算为了满足该条件最少需要花费多少金币。

# 解法

假设结果为 $ans$。

可以用数组 $cs_{p}$ 表示适配第 $p$ 种武器的所有材料花费，然后用 $cnt_i$ 表示共有 $cnt_i$ 适配第 $p$ 种武器的材料，你也可以理解为 $cs_p$ 的长度。

随后，开**贪**，既然要求最少花费，那么就将 $cs_p$ 小的排在前，极易证明，如果不把 $cs_p$ 小的排在前，求花费时加不到 $cs_{p,min}$（$cs_p$ 中最小值），花费就不是最小的。

排序后，核心来了。定义 $i$ 为遍历 $m$ 种强化材料的循环变量。因为题面有：

>小杨最喜欢第 $1$ 种武器，因此他希望适配该武器的强化材料种类数**严格大于**其他的武器，请你帮小杨
>
>计算为了满足该条件最少需要花费多少金币。

所以我们尽量使用 $cnt$ 中材料多的，$cs_{1\cdots cnt_i}$ 中最便宜的材料，使用这种材料将第 $i$ 种武器改成第 $1$ 种武器，随后 $ans$ 判断当前花费和 $ans$ 取最小值，即 $ans\gets \min(ans,当前花费)$。

如何算当前花费呢？先令 $curcnt\gets cnt_1,res\gets 0$（$res$ 表示当前花费）并定义数组 $tmp$ 表示最便宜的材料有那些。因为要让第 $1$ 种武器适配该武器的强化材料种类数尽可能多，必然会产生一个单调上升序列：$\left \{ 1,2,3,4,\cdots \right \} $。假设 $ii$ 指序列中的数（对应代码中 $f$ 函数的形参），如果 $cnt_i-ii+1$ 是负数，说明 $cs_i$ 中的长度比 $ii$ 短，如果比 $ii$ 长，$res$ 加上花费即可。

假设 $b$ 是 $cs_i$ 中减去 $ii$ 加一的长度，然后将 $cs_i$ 的数值加入到 $tmp$ 中。$curcnt$ 指的是 $tmp$ 的长度，所以每轮循环 $curcnt\gets curcnt+b$。但是如果 $cnt_i-ii+1$ 是负数，$curcnt$ 就小了，所以 $b\gets \min(cnt_i-ii+1,0)$。

最后对 $tmp$ 进行排序，$res$ 加上 $tmp$ 前 $ii-curcnt$ 个数，然后 $ans$ 和 $res$ 进行比较 $ans$ 取小的。

最后开 `long long` 就行了。

# 代码

```cpp
#include<iostream>
#include<bits/stdc++.h>
#include<algorithm>
using namespace std;
const int maxm=1001,maxn=maxm;
long long n,m,p[maxn],c[maxm];
long long cnt[maxn];
vector<int> cs[maxn];
long long ans=1e18;
long long f(int ii){
	long long curcnt=cnt[1],res=0;
	vector<int> tmp;
	for(int i=2;i<=n;i++){
		int b=max((int)(cs[i].size()-ii+1),0);
		for(int j=0;j<b;j++){
			res+=cs[i][j];
		}
		curcnt+=b;
		for(int j=b;j<cs[i].size();j++){
			tmp.push_back(cs[i][j]);
		}
	}
	sort(tmp.begin(),tmp.end());
	for(int i=0;i<ii-curcnt;i++){
		res+=tmp[i];
	}
	return res;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>p[i]>>c[i];
		cnt[p[i]]++;
		cs[p[i]].push_back(c[i]);
	}
	for(int i=1;i<=n;i++){
		sort(cs[i].begin(),cs[i].end());
	}
	for(int i=max((long long)(cnt[1]),1ll);i<=m;i++){//注意范围！
		ans=min(ans,f(i));
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：dortmund2013 (赞：36)

枚举第一种武器的最终材料数，假设为 $i$ ，那么其他各种武器最多为 $i - 1$ ， 对于多于 $i - 1$ 的肯定要锻造掉，那么锻造掉哪些呢，对于同一个武器，一定优先锻造花费金币少的材料。所有武器的材料锻造完之后，如果第一种还是不够 $i$ 怎么办？
显然剩下的各种武器材料数都小于 $i$ 了，那么没了限制，我们优先选花费金币最少的，因此把剩下的所有材料的花费里进行排序，从小到大取。
此题枚举+贪心


```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
int n, m;
vector<LL> wp[1005];//wp[i]是第i种武器的强化材料按照花费从小到大排序的vector
LL check(int tar)
{
	LL sum = 0, now = wp[1].size();//now为第一种武器目前有多少种材料
	vector<LL> rem;
	//第1种武器的材料种类为tar，那么其他的最多为tar-1，先把多余的都锻造掉
	//从头开始，也就是从小到大依次锻造
	for(int i = 2; i <= n; i++)
		if(!wp[i].empty())
		{
			int numi = max((int)wp[i].size() - tar + 1, 0);//第i种武器的材料减少多少才能为tar-1
			now += numi;//第一种武器材料数更新
			for(int j = 0; j <= numi - 1; j++)
				sum += wp[i][j];//花费的金币数
			for(int j = numi; j <= (int)wp[i].size() - 1; j++)
				rem.push_back(wp[i][j]);//如果还有剩余，放入rem中
		}
	if(now < tar)//如果还不够的话，从rem数组里从小取，取够为止
	{
		sort(rem.begin(), rem.end());
		for(LL ele : rem){
			sum += ele;
			now++;
			if(now == tar) break;
		}
	}
	return sum;
}
int main(){
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
	{
		int p, c;
		cin >> p >> c;
		wp[p].push_back(c);//花费进vector
	}
	for(int i = 1; i <= n; i++)
		if(!wp[i].empty())//第i种武器材料数不为0，按照花费从小到大排序
			sort(wp[i].begin(), wp[i].end());
	LL ans = 1e18;//最小花费初始化，记得开longlong
	//枚举适配第1种武器的强化材料种类数为i时的最小花费
	//第1种武器的材料种类最小值为当前值和1取最大
	for(int i = max((int)wp[1].size(), 1); i <= m; i++)
		ans = min(ans, check(i));
	cout << ans;
	return 0;
}
```

---

## 作者：N_ty (赞：10)

# B4071 武器强化
这个题目通过一些对比来解决，题目不是很难，就是有两个点要注意。
$\\$

首先因为金币可能很大，所以需要开大一点的变量。
$\\$

其次这道题的一些特殊情况需要考虑到。
$\\$

当时考试的时候我想的比较简单，只写了判断需要多少个模板，再进行购买的片段，只拿了一半分。考完试经老师讲解才想起来其他的模板可能大于平均值，需要进行一一对比！
$\\$

这题可以把每一个武器适配的模板都用动态数组存储起来。$\\$

而某个武器的适配模板就是动态数组的长度。
$\\$

遍历每一个武器，求出它们每一个武器能使第一种武器模板数量**严格大于**其他武器模板的最小消耗金币，再进行对比即可。
$\\$

特别注意：遍历完这个武器的所有模板后，可能不能使第一种武器模板数量**严格大于**其他武器模板，所以需要进行特判。

代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int> cost[1010];//cost[i]:第i种武器 适配的材料修改需要的费用 动态数组
int n, m, ans = LONG_LONG_MAX;//cost总和可能大于int 范围
void work(int x) {
	int money = 0;
	int d = x - cost[1].size();//第一种武器变为x需要d个其他材料
	vector<int> v;
	for (int i = 2; i <= n; i++) { //从2号武器开始
		int isz = cost[i].size(); //第i号武器原本的适配模板
		int need = max(isz - (x - 1), 0ll);//“0ll”指转为long long ;need最少需要多少模板
		//适配模板需要小于x
		for (int j = 0; j < need; j++)
			money += cost[i][j]; //加钱
		d -= need; //还需要的
		for (int j = need; j < cost[i].size(); j++) //和下面 if 对应
			v.push_back(cost[i][j]);
	}
	if (d > 0) { //d不一定能在前面变成0,可能还需要在其他武器的适配材料中索取
		sort(v.begin(), v.end());//排序
		for (int i = 0; i < v.size() && d > 0; i++) { //d==0时跳出循环
			money += v[i];
			d--;
		}
	}
	ans = min(ans, money);//求更小的值
}
signed main() {//小技巧
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int p, c;
		cin >> p >> c;
		cost[p].push_back(c);
	}
	for (int i = 2; i <= n; i++)
		sort(cost[i].begin(), cost[i].end());//排序
	int s1 = cost[1].size();
	if (s1 == 0) s1 = 1; //x>=1，但是s1可能为0
	for (int x = s1; x <= m; x++) {
		work(x);//函数
	}
	cout << ans;
	return 0;
}
```

---

## 作者：__CJY__ (赞：10)

## 题意简述
重新分配强化材料给武器，使第 $1$ 种武器材料数最多，且总转移成本最小。
## 思路
读取武器的种类数 $n$ 和强化材料的数量 $m$。对于每个强化材料，记录其对应的武器编号和成本，并统计每种武器的材料数量和成本列表。

对每种武器的强化材料成本列表进行排序，以便后续能够高效地选择成本最低的材料。

我们定义一个函数 $f$：该函数计算了在给定第 $1$ 种武器需要达到的强化材料数量 $x$ 时，将其他武器的材料转移到第 $1$ 种武器所需的最小成本。

函数内部通过遍历每种非第 $1$ 种武器，计算需要转移的材料数量，并从该武器的成本列表中选择成本最低的材料进行转移。如果转移后第 $1$ 种武器的材料数量仍然不足 $x$，则从剩余的材料中选择成本最低的进行补充。

我们遍历一个范围，从第 $1$ 种武器的初始材料数量到总材料数量。对于每个可能的 $x$ 值，调用函数 $f$ 计算转移成本，并更新全局最小成本。最终输出全局最小成本作为结果。

---

## 作者：PCSJZ (赞：8)

## 思路

可以用 vector 来维护每一种强化材料。

$g_{i,j}$ 表示适配武器为 $i$ 的第 $j$ 种强化材料。

我们对每一个 $g_i$ 按照价格进行排序。

接下来是处理花费。

用 $\operatorname{get}$ 函数来计算最小花费。

设 $cur = cnt[1]$（cnt 为统计数组），表示 $1$ 号武器的强化材料有多少个。从 $2$ 号武器开始，设 $ned = \max(cnt_i - x + 1, 0)$ 表示需要买多少个武器（$cnt_i$ 表示有多少种编号为 i 的强化材料）。

用 $res$ 变量计算 $ned$ 个的强化材料的总和。在给 $cur$ 加上 $ned$，因为这 $ned$ 个我们都配给 $1$ 号武器了。

至于剩下的，我们存入 tmp 数组。再根据价格把 tmp 排序。在循环结束后，在处理还要买多少武器，加上他的价格。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#define int long long

using namespace std;

int n, m;
int cnt[1003];
vector<int> g[1003];

int get(int x) {
	int cur = cnt[1];
	int res = 0;
	vector<int> tmp;
	for (int i = 2; i <= n; i++) {
		int ned = max((int)(g[i].size() - x + 1), (int)0);
		for (int j = 0; j < ned; j++)
			res += g[i][j];
		cur += ned;
		for (int j = ned; j < g[i].size(); j++)
			tmp.push_back(g[i][j]);
	}
	sort(tmp.begin(), tmp.end());
	for (int i = 0; i < x - cur; i++)
		res += (int)tmp[i];
	return res;
}

signed main() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= m; i++) {
		int p, c;
		scanf("%lld%lld", &p, &c);
		cnt[p]++;
		g[p].push_back(c);
	}
	for (int i = 1; i <= n; i++)
		sort(g[i].begin(), g[i].end());
	int ans = 1e18;
	for (int i = (cnt[1] > 1 ? cnt[1] : 1); i <= m; i++)
		ans = min(ans, get(i));
	printf("%lld", ans);
	return 0;
}
``````

---

## 作者：hhhan (赞：5)

题意不多解释：

需要注意的是，可能存在多个最多的， 那么需要分类讨论
    	假设最多的那批共计存在 $cnt$ 个， 那么考虑以下情况：
      
1、如果将最多那一批的 $cnt$ 个全部转变为1， 1在过程中已经超过最多的那批的数量，则直接挑现存的代价最小的转换，一直到1的数量超过最多的则结束；

2、如果将 $cnt$ 个转变为 1，且全部转变为 1 后， 1 的数量未超过所有的最多的数量，进行分类讨论：
- 2.1 假设挑的是 $cnt$ 个最多的数的转变代价是 $ans1$;
- 2.2 假设不挑最多的 $cnt$ 个，则需要挑剩余的代价最小的 $cnt+1$ 个，因为最多的数量不会降，故需要多选一个，此时的代价是 $ans2$。

综上，如果 $ans2 > ans1$ ， 选 2.1， 否则走 2.2。
代码如下：
```c++

#include <bits/stdc++.h>
using namespace std;
vector<int> q[1005];
struct node{
	int c, id;
	friend bool operator<(node a, node b){
		return a.c<b.c;
	}
}tmp[1005]; 
int p[1005],c[1005];

bool cmp(int x, int y){
	return x>y;
}
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>p[i]>>c[i];
		q[p[i]].push_back(c[i]);
	}
	
	for(int i=1; i<=n; i++){
		sort(q[i].begin(), q[i].end(),  cmp);
	}
	long long ans=0;
	while(1){
		int mx = 0;
		for(int i = 2;i<=n;i++)	{
			if(q[i].size()>mx){
				mx = q[i].size();
			}
		}
		if(q[1].size()>mx){
			break;
		}
		
		int cnt1=0, cnt2=0;
		long long ans1=0, ans2=0;
		for(int i=2; i<=n; i++){
			if(q[i].size()==mx){
				ans1+=q[i].back();
				cnt1++;
			}
		} 
		//存在多个最大值， 那么需要分类讨论
    	//假设最大的那个存在cnt1个， 那么存在三种情况
		//1、将cnt1个转变为1已经则1在过程中已经超过所有的最大的
		//2、将cnt1个转变为1已经则1在过程中未超过所有的最大的
		//3、最所有情况中最小的cnt1+1（为什么加1因为不是取最大的cnt1个中的最小值，故会需要多一个来抵消） 
		//情况1 
		if(q[1].size()+cnt1 > mx){
			while(1){
				int mn=1e9, mnid;
				for(int i=2; i<=n; i++){
					if(q[i].size() && mn>q[i].back()){
						mn=q[i].back();
						mnid=i;
					}
				}
				ans+=mn;
				q[1].push_back(mn);
				q[mnid].pop_back();
				if(q[1].size()>mx){
					break;
				}
			}
			break;
		}
		//最所有的排序取前cnt1+1个 
		for(int i=2; i<=n; i++){
			for(auto v: q[i]){
				tmp[++cnt2]={v, i};
			}
		}
		sort(tmp+1, tmp+1+cnt2);
		int x=1;
		for(; x<=cnt1+1; x++){
			ans2+=tmp[x].c; 
		}
		
		//对比情况2和情况3 
		if(x<=cnt1+1 || ans2>ans1){
			ans+=ans1;
			for(int i=2; i<=n; i++){
				if(q[i].size()==mx){
					q[1].push_back(q[i].back());
					q[i].pop_back();
				}
			}
		}else{
			ans+=ans2;
			for(int i=1; i<x; i++){
				q[1].push_back(1);
				int id=tmp[i].id;
				q[id].pop_back();
			}
		}
	}
	cout<<ans;
	return 0;
}

/*
构造的测试样例 
4 9
2 100
2 50
2 3
3 100
3 100
3 300
4 2
4 2
4 300

*/



```

---


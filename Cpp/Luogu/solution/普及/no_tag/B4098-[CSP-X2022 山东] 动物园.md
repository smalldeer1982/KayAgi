# [CSP-X2022 山东] 动物园

## 题目描述

某动物园里有 $n$ 个场馆和 $m$ 种动物（$m ≤ n$）。

$n$ 个场馆的编号分别用 $1,2,3, . . , n$ 表示；$m$ 种动物的编号分别用 $1,2,3, . . , m$ 表示。每一个场馆中只饲养了一只动物，不同的场馆可能饲养着相同种类的动物。

这个动物园的门票比较特殊，游客在购买门票时必须说明要参观的场馆的起止编号 $a$ 和 $b$（起止编号会打印到游客购买的门票上），代表游客只能参观动物园的第 $a$ 个场馆至第 $b$ 个场馆（包含 $a,b$）里的动物，其他的场馆不能去。门票按一个场馆十元收费。

如果你购买的门票的起止场馆编号是 $3$ 到 $8$，那么你需要花 $60$ 元钱购买门票，只能观看$3,4,5,6,7,8$ 号场馆的动物。

小明希望看到动物园内所有种类的动物，同时小明是个非常节约的孩子，他希望花最少的钱买门票。 请你帮小明计算：他最少需要花费多少钱买门票才能看到所有种类的动物（同一种动物他可能不止看一个）。注意：小明只能买一张门票。

## 说明/提示

对于 $30\%$ 的数据，有 $ n ≤ 200 , m ≤ 20$。

对于 $60\%$ 的数据，有 $n ≤ 1000 , m ≤ 1000$。

对于 $100\%$ 的数据，有 $1 ≤ n≤ 10^6，1 ≤ x_i ≤ m ≤ 2 × 10^3$。

## 样例 #1

### 输入

```
12 5
2 5 3 1 3 2 4 1 1 5 4 3```

### 输出

```
60```

# 题解

## 作者：Yxa_Sheep (赞：16)

**[题目传送门](https://www.luogu.com.cn/problem/B4098)**
## 题意
选出一个区间，使这个区间包含 $1$ 到 $m$ 之间的所有数，求这个区间最短长度是多少。
## 思路
用 $l$ 与 $r$ 两个指针，表示区间的左端点与区间的右端点。如果这个区间包含了 $1$ 到 $m$ 之间的所有数，更新 $ans$ 的值，否则继续扩大这个区间。细节看代码。
## 代码
### 有注释

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, l = 1, r, x, ans = 1e6, a[1000010], book[2010]; // l要初始为 1，ans 开 1e6 是因为 n 最大为 1e6，ans <= n
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
	//毫无技巧的输入
    while (r <= n) //右端点在 n 以内
    {
        if (x == m) //包含 1 ~ m 所有数
        {
            ans = min(ans, r - l + 1); //更新ans
            if (!--book[a[l++]]) //左端点加一
                x--; /*如果左端点的那个数去掉后没有和它一样的数了
					则出现的不同数字的数量减一*/
        }
        else
            if (!book[a[++r]]++) //右端点加一
                x++; /*如果右端点的那个数没出现过
					则出现的不同数字的数量加一*/
    }
    printf("%d", ans * 10);
    return 0;
}
```

### 无注释

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, l = 1, r, x, ans = 1e6, a[1000010], book[2010];
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    while (r <= n)
    {
        if (x == m)
        {
            ans = min(ans, r - l + 1);
            if (!--book[a[l++]])
                x--;
        }
        else
            if (!book[a[++r]]++)
                x++;
    }
    printf("%d", ans * 10);
    return 0;
}
```

个人觉得代码加注释看起来很长。题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4098)**

---

## 作者：Fuchsia (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/B4098)

### 解题思路：
- 本题我们如果知道小明去了哪些场馆（即一个区间），那么就好做了。因此，本题可以使用双指针来做。
- 既然已经确定好用双指针来做，那如何才能使花的钱最少呢？很显然，去的场馆越少，花的钱就越少。这时候又有一个新的问题产生了，怎么样才能使去的场馆尽量少并且可以看完所有动物呢？答案也是显而易见的，每种动物看的次数尽量少。那我们又如何知道这一个区间内每一种动物看过多少遍呢？可以使用桶来记录。
- - 既然已经确定好这么多东西，那么这道题就好做了。
  - 判断一下这个区间内，这种动物是不是只看过一次。如果是，那么 ```sum++```。
  - 接着，判断一下这个区间左指针所指向的哪种动物在整个区间内是否多次看过。若是，左指针后移一位，继续进行此操作。
  - 最后判断一下 ```sum``` 是否等于 ```m```。如果是，则在判断一下这个区间的长度是否小于之前的最优方案，若是，则更新最优方案，以及左右指针。
- 由于我们记录的是最短区间的左右指针，因此，我们不能直接输出，仍然需要计算过，```ans=(right-left+1)*10```。


---

##### 大家看代码以及注释理解一下哟~(#^.^#)

```cpp
#include"bits/stdc++.h"
using namespace std;
const int z=1e6,z1=1e3;
int a[z],f[2*z1+1];//数组一定要多开一点，我因为卡着开，挂了好久o(╥﹏╥)o 
int main(){
	int n,m;
	int left,right;
	cin>>n>>m;
	for(int i=0;i<n;i++) scanf("%d",&a[i]);
	int sum=0,minn=INT_MAX;//minn 为最少经过场馆数的数量 
	for(int i=0,j=0;i<n;i++){//j 为左指针 
		f[a[i]]++;
		if(f[a[i]]==1) sum++;//如果是第一次看这个动物，就累加 
		while(f[a[j]]>1) f[a[j]]--,j++;
		//如果左指针的那种动物已经看了不止一次，那么没必要看多次
		//所以左指针向后移一位
		//不断循环，一直判断 
		if(sum==m&&(i-j)<minn) right=i+1,left=j+1,minn=i-j;
		//判断一下是否看到了所有动物，并且判断一下经过的场馆书是否小于前面最少的
		//如果是，跟新左右指针，以及最少经过场馆数的数量 
	}
	int ans=(right-left+1)*10;//right 和 left 分别为右指针与左指针，所以要计算一共去了几个场馆，然后乘 10 
	cout<<ans;
	return 0;
}
```
##### 最后就完结撒花了~

---

## 作者：zhouyuxuan2023 (赞：4)

## 1. 题目简化  
这题的大概意思是选一个区间 `[i, j]`，在这个区间里必须包含 `[1, m]` 之间的所有数，求这个区间的**最小长度**。  

## 2. 做题方法  
这题可以用双指针 `l, r`。`l` 初始为 `1`，`r` 初始为 `0`，再用 `c` 记录当前区间 `[l, r]` 的不同数字个数，并用桶数组统计数字。  

用一个 while 循环，只要 $r \leq n$ 就一直运行：  
- 如果 $c < m$（未凑齐所有数），则 `r` 右移，并检查是否有新数字加入，若有则 `c++`。  
- 否则，用 `r - l + 1` 更新最小长度，并尝试右移 `l`，若某个数字被移出区间则 `c--`。  

最后输出最小区间长度 $\times 10$。  


## 3.code :
```cpp
#include <bits/stdc++.h>
const int N=1e6+5,M=2e3+5;
int tong[M],a[N],n,m,l=1,r,c,mi=0x7fffffff;
signed main(){
	std::cin>>n>>m;
	for(int i=1;i<=n;i++){
		std::cin>>a[i];
	}
	while(r<=n){
		if(c<m){
			r++;
			if(!tong[a[r]])c++;
			tong[a[r]]++;
		}else{
			mi=std::min(r-l+1,mi);
			tong[a[l]]--;
			if(!tong[a[l]])c--;
			l++;
		}
	}
	std::cout<<mi*10;
	return 0;
}
```

---

## 作者：FHY_patrickpp (赞：2)

## [题目](https://www.luogu.com.cn/problem/B4098)

## 分析

要找到门票的起止场馆编号，让这个子数组包含所有 $$m$$ 种动物。然后计算最小花费。

## 思路

滑动窗口：找包含所有动物种类的最短连续子数组。

哈希表：记录当前窗口中每种动物的出现次数。

窗口调整：当窗口包含所有动物时，缩小窗口以找到更短的子数组。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
const int M=2e3+5;
int ani[N];
int freq[M];
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,m,cnt=0,min_len=INT_MAX,l=0,r=0,i;
    cin>>n>>m;
    for(i=0;i<n;i++) cin>>ani[i];
    for(r=0;r<n;r++) 
	{
        if(freq[ani[r]]==0) cnt++;
        freq[ani[r]]++;
        while(cnt==m) 
		{
            if(r-l+1<min_len) min_len=r-l+1;
            freq[ani[l]]--;
            if(freq[ani[l]]==0) cnt--;
            l++;
        }
    }
    cout<<min_len*10;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4098)
### 前言
这道题目要求我们找到一个包含所有动物种类的最短连续场馆区间，计算参观这些场馆的最小费用。

### 思路

这题其实就是要找一个最短的连续区间，这个区间里必须包含 $1$ 到 $m$ 的所有数字。我们可以用两个指针 $l$ 和 $r$ 来表示这个区间，$r$ 负责往后走，把数字加进来，$l$ 负责往前走，把数字踢出去。用一个数组 $cnt$ 记录每个数字出现的次数，变量 $u$ 记录当前区间里有多少种不同的数字。当 $u$ 等于 $m$ 的时候，说明区间里已经包含所有数字了，这时候就可以计算区间长度，并尝试移动 $l$ 指针看看能不能找到更短的满足条件的区间。最后把最短的区间长度 $×10$ 就是答案。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> x(n);
    for (int i = 0; i < n; ++i) {
        cin >> x[i];
    }
    vector<int> cnt(m + 1, 0);
    int l = 0, il = n + 1;
    int u = 0;
    for (int r = 0; r < n; ++r) {
        if (cnt[x[r]] == 0) {
            u++;
        }
        cnt[x[r]]++;
        while (u == m) {
            il = min(il, r - l + 1);
            cnt[x[l]]--;
            if (cnt[x[l]] == 0) {
                u--;
            }
            l++;
        }
    }
    
    cout << il * 10 << endl;
    return 0;
}
```

---

## 作者：DemonPlayer (赞：1)

### 思路：         
1. 维护两个指针 $i$ 和 $j$ 代表一个区间的起点与终点。
2. 循环移动快指针 $j$，直到区间 $[i,j]$ 罩住了 $m$ 种元素，或 $j>n$。
3. 当罩住 $m$ 种元素时，得到了以 $i$ 为起点的最短区间 $[i,j]$，然后不断 $i+1$。
4. 重复执行步骤 $2,3$，在所有合法区间内取最短长度 $\times 10$。
5. 维护一个桶 $cnt_x$ 统计 $x$ 出现的次数，当 $x$ 加入区间，$cnt_x+1$，当 $x$ 移出区间 $cnt_x-1$。
6. 时间复杂度 $\mathcal O(n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000050;

int n,m,sum,l,r,a[maxn],B[2005],minn;

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	l=1;
	r=0;
	minn=1e9;
	while(1){
		if(r>n||l>n){
			break;
		}
		if(sum==m){
			minn=min(minn,(r-l+1)*10);
			B[a[l]]--;
			if(B[a[l]]==0){
				sum--;
			}
			l++;
		}else{
			r++;
			B[a[r]]++;
			if(B[a[r]]==1){
				sum++;
			}
		}
	}
	cout<<minn;
	return 0;
}
```

---

## 作者：linyunxiang1111 (赞：0)

# 题解：B4098 [CSP-X2022 山东] 动物园
> update: 2025-07-03 去除公式与标点间空格。
## 形式化题意

给定一个长度为 $n$ 的数组 $a$，其中每个元素包含 $a_i$ 一个参数（参数在 $1$ 到 $m$ 之间）。要求找到一个最短连续子序列 $[l,r]$，使得这个子数组包含所有 $m$ 个参数，最终输出子数组长度乘 $10$ 的结果。

## 解题思路
1. 容易想到使用双指针 $l$ 和 $r$ 维护一个滑动窗口。使用桶数组来记录当前窗口中每种动物的出现次数，同时记录当前窗口内不同动物的种类数。
2. 如果当前区间包含所有动物种类时，尝试收缩左边界 $l$ 来寻找更小的窗口，否则扩展右边界 $r$ 来包含更多动物。
3. 每当找到一个包含所有 $m$ 种动物的窗口时，比较并更新最小窗口长度。
- 时间复杂度：$\mathcal{O}(n)$，空间复杂度：$\mathcal{O}(n)$。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000100],sum[2010]/* sum是桶 */;
int main(){
    int n,m;
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    int l=1,r=1; // 双指针
    int l1=1,r1=n; // 记录最好情况
    int cnt=1; // 内含动物种类数
    sum[a[1]] ++; // 因为l=r=1,所以先把第一个加进去
    while(r <= n){
        if(cnt == m){ // 所有动物都看过了
            if(r-l < r1-l1){ // 更新最好情况
                r1 = r;
                l1 = l;
            }
            sum[a[l]]--;
            if(sum[a[l]] == 0) cnt--; // 种类减少
            l++;
        }
        else{
            r++;
            sum[a[r]]++;
            if(sum[a[r]] == 1) cnt++; // 新种类
        }
    }
    cout << (r1-l1+1)*10 << endl; // 中间的个数乘10
    return 0;
}
```

---

## 作者：wenjunyi (赞：0)

## 大意

寻找一个区间，要包含 $1$ 到 $m$ 中所有数字。

## 思路

~~和[逛画街](https://www.luogu.com.cn/problem/P1638)一样，复制改一下就行。~~

发现是求一个区间中的什么什么，时间复杂度又要是 $O \lparen n \rparen$ 或 $O \lparen n \log \lparen n   \rparen \rparen$，就可以想到双指针。

用 $l$ 和 $r$ 代表从第 $l$ 个展馆参观到第 $r$ 个展馆，再用一个数组记录参观了几种动物就行了。

---


## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,arr[2005],a1[1000005],l=1,r=1,cnt,a,b=1e9;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a1[i];
	}
	arr[a1[1]]++;
	cnt++;
	while(r<=n){
		if(cnt==m){
			if(b-a>r-l){
				a=l;
				b=r;
			}
			if(arr[a1[l]]==1){
				cnt--;
			}
			arr[a1[l]]--;
			l++;
		}
		else{
			r++;
			arr[a1[r]]++;
			if(arr[a1[r]]==1){
				cnt++;
			}
		}
	}
	cout<<(b-a+1)*10;
	return 0;
} 
```

---

## 作者：Danny_chan (赞：0)

这题类似于[[信息与未来 2022]完美字符串](https://www.luogu.com.cn/problem/B3773)都是有关于区间最小值，而且都是用滑动窗口。

大概思路是这样的：首先维护两个指针 $l$ 和 $r$ 表示区间的首尾。我们先固定 $l$ 让 $r$ 往前移，如果移到某位置符合 $m$ 种动物，那么收缩 $l$ 直到不满足位置，最后求出最小值即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
int a[1000010],f[2010],minn=1e9;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
	}
	int l=1,r=1,sum=0,ans=0;
	while(r<=n) {
		f[a[r]]++;
		if(f[a[r]]==1) {
			sum++;
		}
		ans+=10;
		r++;
		while(sum==m) {
			if(ans<minn) {
				minn=ans;
			}
			if(f[a[l]]==1) {
				sum--;
			}
			f[a[l]]--;
			ans-=10;
			l++;
		}
	}
	cout<<minn<<endl;
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 解题思路
标准的双指针题目。我们可以设小明要从第 $l$ 个场馆到第 $r$ 个场馆，且当前有 $sum$ 个不同的动物。对于每一个状态，我们可以分成 $2$ 类。
1. $sum \lt m$：我们让 $r$ 变成 $r+1$，也就是扩大区间的长度，再更新 $sum$。
2. $sum=m$：先更新最终答案 $ans$，再让 $l$ 变成 $l+1$，也就是缩小区间的长度，最后更新 $sum$。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000001],sum,ans=INT_MAX,l=1,r;
map<int,int> mp;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	while(r<=n)
	{
		if(sum<m)//第1种情况
		{
			r++;//扩大区间长度
			if(mp[a[r]]==0)
			sum++;//更新sum
			mp[a[r]]++;
		}
		else//第2种情况
		{
			ans=min(ans,r-l+1);//更新答案
			mp[a[l]]--;
			if(mp[a[l]]==0)
			sum--;//更新sum
			l++;//缩小区间长度
		}
	}
	printf("%d",ans*10);//别忘记乘以10
	return 0;
}
```

---


# [CSP-X2022 山东] 摧毁

## 题目描述

坐地日行八万里，巡天遥看一千河。

2077 年，人类不仅仅是赛博科技得到了发展，太空技术也已经得到了极大的发展。地球的不同外轨道上已经充斥着各种功能用途的人造卫星。因为一个轨道上的卫星数量是有上限的，且卫星更新换代速度很快，如果想要发射新的卫星，需要把所有旧的卫星摧毁。

人类有两种不同的武器可以摧毁卫星，具体如下（其中 $\rm PW$ 为新的能量单位）：

1. 使用定点激光武器花费 $1\ \rm{PW}$ 的代价摧毁任意轨道上指定的一个卫星。

2. 使用脉冲轨道武器花费 $c\ \rm{PW}$ 的代价把某一轨道上的所有卫星摧毁。

现在有 $n$ 个旧卫星分布在不同的外轨道上，你的任务是摧毁这些旧卫星。给出这 $n$ 个卫星的轨道编号，求将这些卫星全部摧毁的最小代价是多少？

## 说明/提示

对于 $30\%$ 的数据，$T = 1,1 ≤ n ≤ 10，1 ≤ x_i ≤ 10，1 ≤ c ≤ 10$；

对于 $60\%$ 的数据，$1 ≤ n ≤ 10^3， 1 ≤ x_i ≤ 1000，1 ≤ c ≤ 100$；

对于 $100\%$ 的数据，$1 ≤ T ≤ 10,1 ≤ n ≤ 10^6, 1 ≤ x_i ≤ 10^6，1 ≤ c ≤ 100$，且所有测试数据的 $n$ 加起来不超过 $10^6$。

## 样例 #1

### 输入

```
4
10 1
2 1 4 5 2 4 5 5 1 2
5 2
3 2 1 2 2
2 2
1 1
2 2
1 2```

### 输出

```
4
4
2
2```

# 题解

## 作者：zhuoqizhi (赞：6)

## 题目分析
###### 前置芝士：贪心，计数排序。
首先，我们需要考虑如何贪心：

因为使用脉冲轨道武器打一条轨道上的多少颗卫星都是 $c$ 元，所以先用定点激光武器打若干个，再用脉冲轨道武器打完剩下的，肯定是不如用脉冲轨道武器一次性打完的。

而如果一条轨道上只有 $1$ 颗卫星，用脉冲轨道武器要   $2$ 元，那么用定点激光武器打比较优。

所以，如果一条轨道上的卫星个数如果小于 $c$ 就用定点激光武器，否则用脉冲轨道武器。

接着用计数排序的思想，以数组的值为下标统计个数。

最后用一个数组储存下这个高度是否被轰炸过。
## Code
```cpp
#include<iostream>
#include<set>
#include<deque>
#include<vector>
#include<map>
#include<queue>
#include<stack>
#include<random>
#include<ctime>
#include<climits>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
#define int long long
bool isprime(int x){
	if(x<=1){
		return 0;
	}
	int sq=sqrt(x);
	for(int i=2;i<=sq;i++){
		if(x%i==0){
			return 0;
		}
	}
	return 1;
}
int gcd(int x,int y){
	if(y==0){
		return x;
	}
	return gcd(y,x%y);
}
int lcm(int x,int y){
	return x/gcd(x,y)*y;
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		int n,c;
		cin>>n>>c;
		vector<int> can(1000005)/*桶*/,has(1000005)/*是否被轰炸过*/,num;
		int ans=0;
		for(int i=0;i<n;i++){
			int tmp;
			cin>>tmp;
			can[tmp]++;//计数
			num.push_back(tmp);
		}
		for(int i=0;i<n;i++){
			if(!has[num[i]]){//判断是否被轰炸过
				if(can[num[i]]>c){//脉冲轨道武器打比较优
					ans+=c;
				}
				else{
					ans+=can[num[i]];//定点激光武器打比较优
				}
				has[num[i]]=1;//将同一轨道上的卫星全都标记为炸掉
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
``````

---

## 作者：syx_2014 (赞：6)

CSP-X 模拟赛时看见了，后来发现洛谷上有……

## 题目思路

比较简单的贪心。

摧毁一个卫星需要 $1 \operatorname{PW}$，用激光摧毁一条轨道需要 $c \operatorname{PW}$。

分类讨论：

- 如果这条轨道上的卫星数量大于 $c$，那一个一个摧毁所花费的能量就会大于 $c \operatorname{PW}$，而如果用激光一下摧毁的话，那就正好是 $c \operatorname{PW}$，所以激光更值得。
- 如果这条轨道上的卫星数量小于 $c$，那一个一个摧毁所花费的能量就是 $c\operatorname{PW}$，所以一个一个摧毁更值得。
- 如果这条轨道上的卫星数量等于 $c$，那两者皆可。

因为 $a_i$ 不算太大，我们用一个桶记录 $a_i$ 出现了多少次，再判断是否大于、小于或等于 $c$ 就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int a[1000010];
int b[1001000];
int main(){
	cin>>T;
	for(int o=1;o<=T;o++){
		int p=0;
		memset(b,0,sizeof(b)); //十年 OI 一场空，多测不清空见祖宗
		int n,c;
		cin>>n>>c;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			b[a[i]]++; //记录 a[i] 出现次数
		}
		for(int i=1;i<=1000100;i++){
            //贪心，判断判断是否大于、小于或等于 c
			if(b[i]<c) p+=b[i];
			else p+=c;
		}
		cout<<p<<'\n';
	}
	return 0;
}
```

### 第一次写题解，求过！！

---

## 作者：AnotherDream (赞：2)

# [B4099 [CSP-X2022 山东]](https://www.luogu.com.cn/problem/B4099) 摧毁 题解
## 题目思路
贪心思想。

统计每个轨道上卫星的数量。对于每一个轨道，选取定点激光武器和脉冲激光武器花费最少的一个，总花费一定最小。
## 代码
``` cpp
#include <bits/stdc++.h>
using namespace std;
#define debug cerr<<"The code runs successfully.\n";
#define endl '\n'
#define TRACE 1
#define tcout TRACE && cout
#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define int long long
const int P = 998244353; 
const int Base = 3221225477;
const int INF = 0x3f3f3f3f3f3f3f3f; 
const int N = 1e6 + 10, M = 2e6 + 10;
map<int,int> mp;
int n,c,T,ans;
inline void solve() {
	cin>>n>>c;
	mp.clear();//多测一定清空
	for(int i=1;i<=n;i++) {
		int x;
		cin>>x;
		mp[x]++;//统计每一轨道上卫星的数量
	}
	ans=0;
	for(auto e:mp) {
		int cnt=e.second;//这一轨道上卫星的数量
		ans+=min(cnt,c);//定点激光武器花费cnt*1，脉冲激光武器花费c
	}
	cout<<ans<<endl;
}
signed main() {
	fst;
	cin>>T;
	while(T--) {
		solve();
	}
	return 0;
}


```

---

## 作者：TN_lougu (赞：2)

~~很水~~ \
[题目](https://www.luogu.com.cn/problem/B4099)
# 思路
定义一个桶，把题面中的卫星位置记录下来。\
然后比较两种方案，可以用 $\min$ 。\
最后用 ans 相加。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int t[N];
int main() {
	int T;
	cin>>T;
	while(T--) { 
		memset(t,0,sizeof(t));     //清空桶，避免和上组冲突，导致程序错误。
		int n,k,m=-1,ans=0;
		cin>>n>>k;
		for(int i=1; i<=n; i++) {
			int inf;
			cin>>inf;     //不需要存到 a[] 数组。 
			m=max(inf,m);     //求最大值。 
			t[inf]++; 
		}
		for(int i=1; i<=m; i++) ans+=min(t[i],k);     //可以用下面那种，哪种都行。 
//		for(int i=1; i<=m; i++)
//		{
//			if(t[i]<=k) ans+=t[i];
//			else ans+=k;
//		}
		cout<<ans<<"\n";
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/195675639)

---

## 作者：_lxc__ (赞：2)

遍历每个轨道，求每个轨道最小代价之和。

首先为了存储每个轨道旧卫星的个数，又看到 $a_i$ 的范围是 $1\le a_i\le10^6$，所以直接用桶计数即可。

接着再遍历桶，每个桶取个数 $h_i$ 与使用脉冲轨道武器花费 $c$ 的最小值，最后累加即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,h[1000010];
int main(){
	cin>>t;
	while(t--){
		int n,c,ans=0;
		cin>>n>>c;
		memset(h,0,sizeof(h));   //多测不清空，家人两行泪
		for(int i=1;i<=n;i++){
			int x;
			cin>>x;
			h[x]++;   //存桶
		}
		for(int i=1;i<=1000000;i++){
			ans+=min(c,h[i]);   //累加求和
		}
		cout<<ans<<"\n";   //输出
	} 
	return 0;
}
```

---

## 作者：zhanghuanwen (赞：1)

## 开头
~~水题一道……~~  
**警告：Python 党请勿偷懒！（后果自负）**  
## 正文
[题目传送门](https://www.luogu.com.cn/problem/B4099)  
很明显，这道题的答案只与每个轨道上的卫星数量有关。  
摧毁每个轨道上的卫星都只用最小 $\rm{PW}$ 数，最终的答案显然也是最小的。问题来了，**我们又该如何得出摧毁每个轨道上的卫星的最小 $\rm{PW}$ 数呢？** 大家思考一下。

答案来了，就是 $\min(c,t[i])$，其中 $t[i]$ 是第 $i$ 个轨道的卫星数量。  
如果 $t[i]>c$，那么定点激光武器（代价：$1 \times t[i]=t[i]$）比脉冲轨道武器（代价：$c$）要贵，所以用脉冲轨道武器。  
如果 $t[i]<c$，那么定点激光武器比脉冲轨道武器要便宜，所以用定点激光武器。  
如果 $t[i]=c$，那么定点激光武器与脉冲轨道武器一样代价，所以就随便了。  
最终答案：
$$
ans=\sum_{i=1}^{n}\min(c,t[i])
$$
**提示：十年OI一场空，多测不清空见祖宗！**

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,ans,c,n,p,t[1000005];
int main(){
    cin>>T;
    while(T--){
        cin>>n>>c;
        ans=0;memset(t,0,sizeof t);
        for(int i=1;i<=n;i++){
            cin>>p;
            t[p]++;
        }
        for(int i=1;i<=n;i++) ans+=min(c,t[i]);
        cout<<ans<<endl;
    }
}
```
## 结尾
[Python TLE 的代码](https://www.luogu.com.cn/record/212637549)  
[C++ AC 代码](https://www.luogu.com.cn/record/212640552)  
蒟蒻第一次写题解，难免有一定的错误或让人无法理解的地方，请大佬们多多指点，谢谢！！！

---

## 作者：_zhaosihan_qwq_ (赞：1)

# 题解：B4099 [CSP-X2022 山东] 摧毁
## 闲话：
话说 CSP-X 可是小学组啊，T2 就上黄了，可我做模拟赛时感觉这道题也就橙吧。
## 思路：
这道题最好用贪心，只要判断每一个轨道上的卫星的数量是否大于 $c$，如果大于 $c$ 就使用激光，否则就一个一个击毁，每次摧毁计算一次总费用，最后输出即可。  
为什么这道题能用贪心呢，因为花费最少就可以击毁，那么就不用考虑此轨道，后面击毁其他轨道就一定是最优解。
## AC code

```cpp
#include<bits/stdc++.h>

#define zh printf("by-_zhaosihan_qwq_");

#define int long long//开 long long

#define N 1000005

using namespame std;

int t,a[N],b[N];

signed main(){
	
	cin>>t;
	
	while(t--){//多测数据
		
		int n=0,m=0,c=0;
		
		cin>>n>>m;
		
		for(int i=1;i<=n;i++){
			
			cin>>a[i];
			
			b[a[i]]++; 
			
		}
		
		for(int i=1;i<=1000005;i++){
			
			if(b[i]<m){
				
				c+=b[i];//单个击破
				
			} 
			
			else{
				
				c+=m;//使用激光
				
			}
			
		}
		
		cout<<c<<endl;//换行！
		
		memset(b,0,sizeof(b));//清空！
		
	}
	
	return 0;
	
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4099)

**~~这有黄？~~**

## 思路：

这是一个非常一眼的**贪心**，对于在位置 $i$ 上的卫星数量为 $a_i$。显然的 $a_i \le c$ 的时候一个一个打的代价是 $a_i$，不比 $c$ 大，优；而 $a_i>c$ 时直接用 $c$ 的代价打完即可，一定小于 $c$，优。

统计 $a_i$ 用桶就可以。

## 代码实现：


```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int>m;
int t[1000005];//桶 
int ts;
int x,y;
int main(){
	cin>>ts;
	for(int i=1;i<=ts;i++){
		cin>>x>>y;
		m.clear();
		memset(t,0,sizeof(t));
		//多测要清空 
		for(int j=1;j<=x;j++){
			int a;
			cin>>a;
			if(t[a]==0) m.push_back(a);
			t[a]++;
		}
		
		int s=m.size(),da=0;
		for(int j=0;j<s;j++){
			da+=min(t[m[j]],y);//取小值 
		}
		cout<<da<<endl;
	}
	return 0;
}

```
[通过记录](https://www.luogu.com.cn/record/212012136)

---

## 作者：jej333 (赞：0)

这题真水。每个 $x_i$ 居然 $\le 10^6$，这意味着如果用桶的话不会超空间。
## 主要思路
每读入到一个 $x_i$ 就让 $can_{x_i}+1$，然后再遍历每个桶是否有数，如果有数，则：
- 如果 $can_{x_i} \ge c$，那么使 $cnt$ 加 $c$；
- 如果 $can_{x_i} < c$，那么使 $cnt$ 加 $can_{x_i}$，也就是加 $can_{x_i}$ 个 $1$。

结束一次循环后，别忘了清空哦！

贴上 AC 代码：

```
#include<bits/stdc++.h>
using namespace std;
int t,can[1000001];
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		int n,c,cnt=0;//cnt用来记录一共代价是多少 
		cin>>n>>c;
		for(int j=1;j<=n;j++){
			int x;
			cin>>x;
			can[x]++;//对应的桶++
		}
		for(int j=1;j<=pow(10,6);j++){
			if(can[j]){//如果有数 
				if(can[j]>=c) cnt+=c;//如果大于c则cnt加c 
				else cnt+=can[j];//否则加can[j],也就是加can[j]个1 
			}
		}
		cout<<cnt<<'\n';
        for(int j=1;j<=pow(10,6);j++) can[j]=0;//清空 
	}
	return 0;
} 
```

---

## 作者：DemonPlayer (赞：0)

## 思路：   
使用贪心算法。       
因为需要选择最小花费。     
1. 记录下每条轨道的卫星数量。
   - 可以使用 map 解决。
2. 进行贪心，对于第 $i$ 条轨道，可以选择：    
    - 使用定点激光武器一个一个摧毁，花费为 $k$，其中 $k$ 为此轨道卫星。
    - 使用一次脉冲轨道武器，花费为 $c$。
3. 将最小花费求和输出。

```cpp
#include<bits/stdc++.h>
using namespace std;

int T,n,c,x,val,ans;
map<int,int> B;

int main(){
	scanf("%d",&T);
	while(T--){
		B={};
		ans=0;
		scanf("%d%d",&n,&c);
		for(int i=1;i<=n;i++){
			scanf("%d",&x);
			if(B.count(x)){
				B[x]++;
			}else{
				B.insert({x,1});
			}
		}
		for(auto p:B){
			val=p.second;
			ans+=min(val,c);
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```
通过使用 map，也可以处理 $1\le x_i \le 10^{9}$ 的数据。

---

## 作者：easy42 (赞：0)

### 题意

有两种操作。

1. 使用定点激光武器花费 $1\ \rm{PW}$ 的代价摧毁任意轨道上指定的一个卫星。

2. 使用脉冲轨道武器花费 $c\ \rm{PW}$ 的代价把某一轨道上的所有卫星摧毁。

### 思路

首先，我们先把每种卫星给分类，有点儿像计数排序。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3cpn7bx7.png)

所以，我们可以一次性把一个桶里所有卫星都销毁，也可以一个一个销毁。

所以在个数与 $c$ 中取最大值就好了。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/78bauzc7.png)

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int n,c,a[1000005],ans;
int main(){
    cin>>t;
    while(t--){
        memset(a,0,sizeof(a));//清空
        ans=0;
        cin>>n>>c;
        for(int i=1;i<=n;i++){
            int m;
            cin>>m;
            a[m]++;//计数排序
        }
        for(int i=1;i<=1000000;i++){//最大值
            if(a[i]!=0) ans+=min(c,a[i]);//如果有就加
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：0)

# B4099 [CSP-X2022 山东] 摧毁 题解

[题目传送门](https://www.luogu.com.cn/problem/B4099)

## 题目分析

看到题目，我们思考一下，可以想到遍历每一个轨道，计算每个轨道最小代价，最后再加起来。

### 记录轨道的卫星个数
要计算每个轨道的代价，就要记录每个轨道上的卫星个数。  
由于题目中说到：
>$1 \le a_i \le 10^6$

那么我们可以用一个数组来记录每个轨道的卫星数。  
代码如下：

```cpp
int a[1000005] = {},maxn = 0;
for(int i = 1,x;i <= n;i++)
    cin >> x,a[x]++,maxn = max(maxn,x);//maxn用于优化
```

### 计算每个轨道最小代价
每个轨道的代价有两种：  
第一种，使用定点激光武器消除，每一个卫星 $1$ $PW$ 的代价。一个轨道的代价就是其卫星个数。  
第二种，使用脉冲轨道武器消除。一个轨道的代价就是一开始输入的 $c$。

那么对于每一个轨道，我们取两种代价的最小值，再相加。  
代码如下：
```cpp
int ans = 0;
for(int i = 1;i <= maxn;i++)
	ans += min(a[i],c);
```

### 一些提醒
因为有多组测试数据，所以若我们将**计数数组，答案**等定义在**循环外**，都要将计数数组**清零**并把答案等**归零（或其它）**。  
输出答案时记得**换行**！

最终代码如下：
```cpp
#include <iostream>
#include <cstring> // memset所需的库
using namespace std;
int T,n,c,a[1000005],maxn,ans;

int main(){
	cin >> T;
	while(T--){
		ans = maxn = 0;
		memset(a,0,sizeof(a)); // 数组清零
		cin >> n >> c;
		for(int i = 1,x;i <= n;i++)
			cin >> x,a[x]++,maxn = max(maxn,x);
		for(int i = 1;i <= maxn;i++)
			ans += min(a[i],c);
		cout << ans << '\n'; // '\n'比endl效率高
	}
	return 0;
}
```

## 总结
是一道比较基础的题，综合考察桶计数和贪心，适合初学者练习。

感谢您的阅读！

---

## 作者：DoubleQLzn (赞：0)

考虑使用贪心。

对于消灭一种卫星，有两种情况：

- 依次消灭，消耗出现次数 $\text{PW}$。
- 直接使用脉冲武器消灭，消耗 $c\ \text{PW}$。

对于每种武器，取最小值并加和即可。用 map 实现会比较简单。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T,n,c;
	cin >> T;
	while (T--)
	{
		cin >> n >> c;
		int x,s = 0;
		map<int,int> f;
		while (n--)
		{
			cin >> x;
			f[x]++;
		}
		for (auto u : f) s += min(u.second,c);
		cout << s << '\n';
	}
	return 0;
}
```

---

## 作者：Lfz312g (赞：0)

# Solution
## 题目分析
开一个桶，记录下每一个轨道的卫星数量。  
遍历每一条轨道，若该轨道的卫星数量大于使用脉冲轨道武器的代价，则使用脉冲轨道武器，否则使用定点激光武器一个一个摧毁。  
## 代码实现

```cpp
#include <bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
int vis[1000005];
void solve() 
{
	int n,c;
	cin>>n>>c;
	memset(vis,0,sizeof vis);
	ffor(i,1,n) {
		int x;
		cin>>x;
		vis[x]++;
	}
	ll ans=0;
	ffor(i,1,1000000) ans+=min(c,vis[i]);
	cout<<ans<<'\n';
}
int main()
{
	int T;
	cin>>T;
	while (T--) solve();
	return 0;
}
```
做法简单。建议降橙。

---

## 作者：Fantasy_Segment_Tree (赞：0)

这道题做法很明显，建议降橙。

我们可以开一个桶，存下每个轨道上有多少个卫星。

然后看每个位置的卫星数量。若大于 $c$ 则使用脉冲轨道武器。否则使用定点激光武器。

最后加起来就可以了。

注意：**多测要清空**！

```cpp
#include <iostream>
#include <cstring>

using namespace std;

long long n, c, a[1000005], js[1000005];

int main() {
	long long T;
	cin >> T;
	while(T--) {
		memset(js, 0, sizeof(js));
		cin >> n >> c;
		for(long long i = 1; i <= n; i++) cin >> a[i], js[a[i]]++;
		long long ans = 0;
		for(long long i = 1; i <= 1000000; i++) {
			ans += min(c, js[i]);
		}
		cout << ans << endl;
	} 
}
```

---


# [CSP-X2023 山东] 赚钱

## 题目描述

小 A 很喜欢旅游，他的国家共有 $n$ 个城市，编号依次为 $1$ 到 $n$，这个暑假小 A 打算从 $1$ 号城市开始按编号从小到大依次旅游完所有的城市，最后达到 $n$ 号城市，而且他不走回头路，每个城市只走一次。

小 A 很聪明，在没出发之前，他已经了解到，每个城市都有他喜欢的小熊纪念品，但是每个城市的价格却不完全一样（在同一个城市买入和卖出一个小熊纪念品的价格相同），于是小 A 打算从经过的某一个城市 $x$ 买一个纪念品，然后在后面经过的某个城市 $y$ 卖掉，从而赚取其中的差价。**但是他必须在某个城市买 $1$ 次，而且只能买 $1$ 个，并且一定要在后面的某个城市卖掉（不能在同一个城市先买入后再卖出）**，因为他家里已经有很多小熊纪念品了。

如，$2$ 号城市的纪念品价格是 $10$ 元，$6$ 号城市的纪念品是 $8$ 元，$10$ 号城市的纪念品是 $18$ 元，假设小 A 在 $2$ 号城市花 $10$ 元钱买了一个纪念品，如果在 $6$ 号城市卖掉他就亏了 $2$ 元（赚 $-2$ 元），如果在 $10$ 号城市卖，他就会赚 $8$ 元。

小 A 希望赚的钱越多越好。

问：小 A 最多能赚多少钱（当然也有可能亏钱）？

## 说明/提示

对于 $30\%$ 的数据：$n\le 1000$。

对于 $100\%$ 的数据：$2\le n\le 2\times 10^5$，$0\lt a_i\le 2\times 10^9$。

## 样例 #1

### 输入

```
5
2 1 6 8 4```

### 输出

```
7```

## 样例 #2

### 输入

```
6
10 8 7 5 3 1```

### 输出

```
-1```

# 题解

## 作者：songge888 (赞：6)

### 题意

给你一个长度为 $n$ 序列 $a$，对任意 $1 \le j < i \le n$，求 $a_i-a_j$ 的最大值。

### 思路

以为 $n \le 2 \times 10^5$，显然暴力 $O(n^2)$ 会爆，考虑优化。

贪心地想，对于每个 $a_i$，它的最大收益只跟它前面的最小值有关，可以在遍历时找到维护前面的最小值 $minn$，每次对 $a_i-minn$ 取最大值即可。

注意到答案可能小于 $0$，所以 $ans$ 要赋初值为极小。

时间复杂度：$O(n)$。

### Code

```c++
#include<bits/stdc++.h>
#define bug cout<<"songge888"<<'\n';
#define int long long
using namespace std;
const int INF=1e18;
int ans=-INF,mi=INF;
int n,a[200010];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        ans=max(ans,a[i]-mi);//维护答案
        mi=min(mi,a[i]);//维护最小值
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：Temp113 (赞：3)

## Solution

对于在 $i$ 号城市卖出，要使其获得最大利润，显然，应在之前城市中选择价格的最小值买入。因为只能买卖 $1$ 个，所以直接求最大值即可。可以直接在输入时统计最小值，并求出答案。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 5;
int n, a, mina = 1e18, ans = -1e18;
inline int min_(int aa, int bb){
	return aa < bb ? aa : bb;
}
inline int max_(int aa, int bb){
	return aa > bb ? aa : bb;
}
signed main(){
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++){
		scanf("%lld", &a);
		ans = max_(ans, a - mina);
		mina = min_(mina, a);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：brbrbread (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/B4100)
# 思路
这道题本蒟蒻想了一下，最后决定用贪心+递推去做。     
在每次递推的时候，求出当前买进价格最小的城市，在用现在这个城市的卖出价格做差，再与之前最大的价格取较大者。这就是我们基本的贪心+递推思想。      
~~不开 long long 见祖宗。~~
# AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+5;
int n,a[N],ans=INT_MIN;
void func(int k,int minn){
	if(k==n+1)	return ;//判断是否越界
	ans=max(ans,a[k]-minn);//找出最优解
	func(k+1,min(a[k],minn));//递推
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	func(1,INT_MAX);
	cout<<ans;
	return 0;//好习惯
}
```
有点玄学的做法，感谢观看。

---

## 作者：Xiaonao_Dali (赞：2)

## 一、题目大意
小A 需要买小熊纪念品，并且要卖纪念品，赚取差价，但是，必须买卖 $1$ 次，不能多也不能少。当然他可能赚，也可能亏，所以赚的要把他最大化，亏要把他尽可能减小亏损。
## 二、易错点拨
注意，小A必须进行交易，不可不交易，也不可多次交易，所以这里动态规划可能行不通。\
还有小明不会走回头路，他不会在后面城市买到纪念品，在跑到前面的去卖，所以 $\max(a_i)-\min(a_i)$ 必然行不通。
## 三、思路点拨
据观察，要想在后面获得更多钱或尽可能减少亏损，一定和前面几个最小值有一定挂钩。(但凡有点商业头脑的都知道~~你总不可能找最大值去吧~~)，我看样例突然找到的规律\
这就要考虑新建一个变量啦。但是初始值要尽可能大，也不超出范围，最土的方法就是看数据范围，然后视情况而定。\
你若是看不出哪个是对应的，你可以试试下列的特殊值：

```INT_MAX``` 解析：他会把对应变量初始值调到 int 范围内的最大值，使用变量求最小值的初始变量\
```INT_MIN``` 解析：他会把对应变量初始值调到 int 范围内的最小值，使用变量求最大值的初始变量\
上述两个特殊值字母均为大写(~~你写小写就编译错误啦！~~)
## 四、AC代码参考

```
#include<bits/stdc++.h>
using namespace std;
#define int long long//保持良好习惯，避免超出 int 范围
int n,a[200005],ans=INT_MIN,minx=INT_MAX;
signed main() {//应为define int long long 了，所以一定要把 int 改为 signed 。
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<n;i++){
		ans=max(ans,a[i]-minx);
    	minx=min(minx,a[i]);
	}
	cout<<ans;
    return 0;
}
```
## 五、后言
感觉这道题放黄题过于夸张了些，因为明明可以几行代码搞定的，建议降橙。\
当然在代码中写宏定义是一个好习惯，这样可以避免一些数据超出 int 范围而你仍旧使用 int 的情况，这样可以让你避免这种情况。\
原代码中第三行解析：把所用定义成 int 类型的变量，全部宏定义为 long long 类型。

---

## 作者：lam_dyr (赞：2)

# B4100 \[CSP-X2023 山东] 赚钱 题解

~~好久没写过这么简单的题了 QaQ~~

## Solution

朴素的想法：暴力枚举。

思路：就是尝试所有可能的买入和卖出组合。

步骤：

1. 双重循环：用两层循环遍历所有城市。外层循环 $i$ 代表买入城市，内层循环 $j$ 代表卖出城市。
2. 条件判断：$j > i$。
3. 计算收益：计算 $a_{j} - a_{i}$，即卖出价格减去买入价格。
4. 更新最大收益：维护一个变量 $\max$，每次计算出新的收益后，都和 $\max$ 比较，取较大值。

问题：两层循环，时间复杂度为 $O(n^2)$，当 $n$ 很大时会超时。

优化思路：动态规划思想

核心：避免重复计算，利用之前计算的结果来优化后续计算。

关键观察：

- 卖出价格固定：当你确定在某个城市卖出时，卖出价格是固定的。
- 最大收益取决于最小买入价格：为了最大化收益，你应该选择到目前为止遇到的最小买入价格。
  步骤：

1. 维护最小值：从左到右遍历城市，同时维护一个变量 $\min$，记录到当前城市为止遇到的最小价格。
2. 计算当前收益：对于每个城市，计算以当前城市作为卖出城市时的收益：当前价格 $-\min$。
3. 更新最大收益：维护一个变量 $\max$，每次计算出新的收益后，都和 $\max$ 比较，取较大值。
4. 更新最小值：在每次遍历时，更新 $\min$ 为当前遇到的最小值。

最终结果就是 $\max$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long//好习惯 
using namespace std;
int n,a[200010];
int minn,maxx;
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i]; 
	minn=a[1];
	maxx=-2e9;//初始化成极小值 
	for(int i=2;i<=n;++i){
		int res=a[i]-minn;
		maxx=max(maxx,res);
		minn=min(minn,a[i]);
	} 
	if(maxx==-2e9)
		printf(0);
	else
		printf("%lld",maxx);
	return 0;
}
```

感谢管理大大审核，求过 qwq

---

## 作者：RenZhen1 (赞：2)

这个题目给定一个组数字，找到买入和卖出差值的最大值。但是买入和卖出有先后顺序，一定是**先买入，再卖出**。

对于 $30\%$ 的数据来说，直接嵌套循环枚举即可，对于每个数字，找到前面比它小的数字中最小的，并且存储差值。这样把每个差值的最大值找出来就是答案。




```cpp
int maxx=0;
for(int i=1;i<=n;i++) 
{
    int Maxx = 0;
	for(int j=1;j<i;j++)
    {
        if(a[j]<a[i]&&Maxx<a[i]-a[j])
        {
            Maxx=a[i]-a[j];
        }
	}
	maxx=max(maxx,Maxx);
}
cout<<maxx;
```


对于 $100\%$ 的数据，可以对上述做法进行优化：

从前往后扫描每个数字的时候，随时记录最小值，这样每个数字就不用再用一个循环找最小值了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005];
int main() {
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int minx=a[1],maxx=-2e9;
	for(int i=2;i<=n;i++){
		maxx=max(maxx,a[i]-minx);
		minx=min(minx,a[i]);
	}
	cout<<maxx;
	return 0;
}

```

---

## 作者：TainityAnle (赞：1)

### 思路

题面中需要注意的一点就是只能拿一个数，所以当前位置 $i$ 的答案就是 $a_i$ 减去之前选的数字。

既然要求答案尽可能的大，我们就贪心地选前 $i$ 个中最小的。经证明，一定是最优的。

这个题就转化成了求前缀最小值。设 $m_i$ 表示前 $i$ 个数的最小值，因为不能当前点选了当点前卖，所以遍历到 $i$ 位置时答案是 $a_i-m_{i-1}$。对所有答案统计最大值即可。

这个题数据范围到 $2\times10^9$，开 int 可能会有点极限，建议开 long long。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200005],m[200005],ans=-0x3f3f3f3f;
signed main(){
	cin>>n;
	for(int i=0;i<=n;i++) m[i]=2000000000000ll;
	for(int i=1;i<=n;i++) cin>>a[i],m[i]=min(m[i-1],a[i]);
	for(int i=1;i<=n;i++) ans=max(a[i]-m[i-1],ans);
	cout<<ans;
	return 0;
}
```

---

## 作者：zhangrui2023 (赞：1)

### 题面解释

题意：小A在某个城市买 $1$ 个小熊纪念品，在后面的某个城市卖掉，求赚取的差价的最大值。

可以抽象成：**求序列 $a_1,a_2,...,a_n$ 中 $a_i-a_j$ 的最大值 $(1\le j<i\le n)$**。

### 30pts

枚举每对 $(i,j)$，计算 $a_i-a_j$ 的值并更新答案。

时间复杂度 $O(n^2)$。

**Code:**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200010],ans=-2147483647;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
    	for(int j=i+1;j<=n;j++){
    		ans=max(ans,a[j]-a[i]);
		}
	}
	cout<<ans;
    return 0;
}
```

### 100pts

对于每个 $a_i$ 来说，其最优解只与 $a_i$ 之前序列中的最小值有关，且如果一定要在 $i$ 号城市卖掉，最优解就一定是 $a_i - \min(a_j) \text{ } (j<i)$。

因此，只需要不断找出从 $a_1$ 到 $a_{i-1}$ 的最小值，求出 $a_i - a_j$ （其中 $a_j$ 位于 $a_i$ 之前且在 $a_1$ 到 $a_{i-1}$ 最小）并更新答案即可。

**Code:**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200010],ans=-2147483647,minx=2147483647;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
		ans=max(ans,a[i]-minx);
		minx=min(minx,a[i]);
	}
	cout<<ans;
    return 0;
}
```

时间复杂度 $O(n)$。

---

## 作者：JoyLosingK (赞：1)

这道题明显是****贪心****。

设买入的城市为 $i$，由于只能在它后面的城市卖出，所以不考虑它和它前面的城市。

那么在哪一个城市卖能得到的价值最大呢？这是一个很明显的贪心。为了差价最大，我们肯定要尽量卖得贵。所以，我们可以在一个在 $i$ 后面且价格最贵的城市卖出。

于是问题转化为：****求数列中一个数后面最大的那个数。****

明显可以用暴力枚举的方式来求这个值，据此可以写出 $30$ 分代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define endl '\n'
const int N=2e5+5;
int a[N],n,ans=-3e9,mx;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;} 
int main(){ ios::sync_with_stdio(0),cout.tie(0);
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<n;i++){
		mx=-3e9;
		for(int j=i+1;j<=n;j++)
			mx=max(mx,a[j]);
		ans=max(ans,mx-a[i]);
	}
	cout<<ans;
	return 0;
} 
```

于是考虑如何优化，我们利用前缀和的思想，维护一个数组 $mx_i$ 表示 $i$ 的****后缀最大值****。

那么数列中一个数后面最大的那个数就是 $mx_{i+1}$ 了。

这样我们枚举买入的位置，用 $O(1)$ 的时间求出它能够获得的最大差价，总时间复杂度为  $O(n)$，可以通过本题。

****Code:****


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define endl '\n'
const int N=2e5+5;
int a[N],n,mx[N],ans=-3e9;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;} 
int main(){ ios::sync_with_stdio(0),cout.tie(0);
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=n;i>=1;i--)
		mx[i]=max(mx[i+1],a[i]);
	for(int i=1;i<n;i++)
		ans=max(ans,mx[i+1]-a[i]);
	cout<<ans;
	return 0;
} 
```

---

## 作者：jinhangdong (赞：1)

我们在求答案的过程中记录一下前面的最小值，我们就从那里买，然后对于每一个位置能赚的钱取个最大值即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,ans=-2e9,Min=4e9;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>x;
		ans=max(ans,x-Min);
		Min=min(Min,x);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：1)

### 解题思路

> 小明**必须**在某个城市买 $1$ 次，而且只能买 $1$ 个，并且**一定**要在后面的某个城市卖掉（**不能在同一个城市先买入后再卖出**）

由于只能购买一次，并且必须购买一次，那么我们可以枚举购买的点。根据贪心的策略，卖掉的点应当尽可能大，且这个点必须在购买的点之后，时间复杂度 $O(n^2)$。

我们会发现每次在寻找最大值时，都要枚举后续的点，效率较低，那么我们可以考虑维护一个 $f$ 数组，$f_i$ 表示 $a_i, a_{i+1}, \dots, a_n$ 的最大值，这样当我们在第 $x$ 点购买时，卖出的最高价格为 $f_{x+1}$，即在第 $x$ 点购买的收益为 $f_{x + 1} - x$。

时间复杂度 $O(n)$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2e5 + 10;

int n;
int a[N];
int mx[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n;
    for (int i = 1; i <= n; ++ i )
        cin >> a[i];
    for (int i = n; i; -- i )
        mx[i] = max(mx[i + 1], a[i]);
    
    int res = -2e9;
    for (int i = 1; i < n; ++ i )
        res = max(res, mx[i + 1] - a[i]);
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：michaelwanghaoyu (赞：0)

## 题意+分析
这道题就是一个贪心，在最便宜的地方买下来，最贵的地方卖出去，看一看差价。

怎么卖差价最大。

AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200001],mr,mc,m=-2147463648;
int main()
{
    //freopen("money.in","r",stdin);
    //freopen("money.out","w",stdout);上战场别忘了。
    cin>>n;
    for(int i=0;i<n;i++)
	{
        cin>>a[i];
    }
    mr=a[0];
    for(int i=1;i<n;i++)//遍历，看最大差价。
	{
    	m=max(a[i]-mr,m);
        if(a[i]<mr)
  		{
            mr=a[i];
        }
    }
    cout<<m<<endl;
    //fclose(stdin);
    //fclose(stdout 上战场别忘了。
}
```

---

## 作者：AnotherDream (赞：0)

# [B4100](https://www.luogu.com.cn/problem/B4100) 题解
## 思路
假设卖掉的城市一定，那么能获得的最大收入就是这一城市的价格减去前面经过城市的最小值（被减数固定，减数越小，差越大）。

提示：收入可能为负，答案的初始值一定要是负无穷而不是零。
## 代码
``` cpp
// Problem: B4100 [CSP-X2023 山东] 赚钱
// Contest: Luogu
// Date: 2024-12-28 21:11:13
// URL: https://www.luogu.com.cn/problem/B4100
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
#define debug cerr<<"The code runs successfully.\n";
#define endl '\n'
#define TRACE 1
#define tcout TRACE && cout
#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define int long long
const int P = 998244353; 
const int Base = 3221225477;
const int INF = 0x3f3f3f3f3f3f3f3f; 
const int N = 1e6 + 10, M = 2e6 + 10;
int n,ans=-INF,minn;//n是城市个数，minn是经过城市价格的最小值，ans存储答案，初始值负无穷
signed main() {
	fst;
	cin>>n>>minn;//一号城市不能卖出
	for(int i=1;i<n;i++) {
		int x;
		cin>>x;
		ans=max(ans,x-minn);
		minn=min(minn,x);//更新经过城市价格的最小值
	}
	cout<<ans<<endl;
	return 0;
}


```

---

## 作者：AnOIer (赞：0)

~~场内选手补题解。~~

## 思路

$O(n^2)$ 的做法肯定会超时，考虑优化。

用 $\text{minn}$ 来记录目前纪念品的最低价格，再从此开始购买纪念品，用 $\text{ans}$ 记录赚的钱的最大值即可。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[200100],minn=2e9,ans=-2e9;
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		ans=max(ans,a[i]-minn); 
		minn=min(minn,a[i]);
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：joker_opof_qaq (赞：0)

## 思路

无论在哪里卖出去，都一定要在前面的最小值处买进。

考虑维护自己前面的最小值，再一个一个找出答案最大值。

## AC CODE

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<iomanip>
#include<cstring>
#include<string>
#include<cmath>
#include<queue>
#include<map>
#include<list>
#include<stack>
#include<cctype>
#include<cstdlib>
#include<utility>
#include<set>
#include<bitset>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x) {
	if (x<0)x=-x,putchar('-');
	if (x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=1e6;
int n=read(),minn=114514114,ans=-1e9,a[N];
int main(){
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,a[i]-minn);
		minn=min(minn,a[i]);
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：UNDERTALE_RS (赞：0)

# B4100 [CSP-X2023 山东] 赚钱 题解

[题目传送门](https://www.luogu.com.cn/problem/B4100)

## 题目分析

看到题目，我们仔细思考一下，假设已经决定好在某一个城市卖掉，那么从这个城市之前最便宜的城市买，才可以使现在的利益最大；接着每一个枚举求出利益最大值。

### 求出每一个城市之前的最小值
如果对每一个城市，都往前遍历来求最小值，则时间复杂度为 $O(n^2)$

由于题目中说到：
>$2 \le n \le 2 \times10^5$

所以必然是会超时的，那么就必须要优化。

这里可以利用**类似前缀和的思想**：  
假设 $m_i$ 表示包括当前城市之前的最小值，$a_i$ 表示当前城市。  
那么如果要求出 $m_j$，就取 $m_{j-1}$ 和 $a_i$ 的最小值就可以了。  
（不明白建议停下仔细思考一下）

我们可以先把 $m_1$ 设为 $a_1$，会方便一点。  
代码如下：
```cpp
m[1] = a[1];
for(int i = 2;i <= n;i++)
    m[i] = min(a[i],m[i-1]);
```

### 求出最多赚到的钱
对于一个城市，如果要在这卖掉，最大所赚到的钱就是该城市的价格减去该城市**之前**最小的价格。即：
$$
w = a_i-m_{i-1}
$$

所以要求出最多赚到的钱，每次取最大值就行了。  
代码如下：
```cpp
int ans = -2e9 // 答案可能是负数
for(int i = 2;i <= n;i++)
    ans = max(ans,a[i]-m[i-1]);
```

### 再度优化
仔细观察代码，发现我们求最小值的部分还可以再优化。  
我们可以发现求最终结果和求出前缀最小值是可以**同时进行**的，甚至还可以再与输入结合，只是**进行的先后顺序**需要注意。  
于是最终代码如下：
```cpp
#include <iostream>
using namespace std;
int n,x,ans = -2e9,minn;

int main(){
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> x;
		if(i > 1) ans = max(ans,x-minn),minn = min(minn,x);
		else minn = x;
	}
	cout << ans;
	return 0;
} 
```

## 总结
是一道比较基础的题，考察算法优化能力，适合初学者练习。

感谢您的阅读！

---

## 作者：wht_1218 (赞：0)

对于地点 $i$，为了赚最多的钱，我们自然要选择 $x=\max_{i+1}^na_i$ 所对应的位置卖出，此时收益为 $k-a_i$。

预处理出最大值，再枚举 $i,i\neq n$ 即可。

开 `long long`。


```
#define int long long
int n,a[N],mx[N],ans=-0x3f3f3f3f; 
main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	mx[n+1]=0;
	for(int i=n;i;--i)mx[i]=max(mx[i+1],a[i]);
	for(int i=1;i<n;++i)ans=max(ans,mx[i+1]-a[i]);
	cout<<ans;
	return 0;
}
```

---


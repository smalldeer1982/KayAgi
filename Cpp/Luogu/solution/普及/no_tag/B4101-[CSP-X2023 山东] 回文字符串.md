# [CSP-X2023 山东] 回文字符串

## 题目描述


作为一个新手，小明刚学了回文字符串，知道了一个字符串如果关于中心对称，则该字符串为回文字符串。

于是他自己就发明了属于他自己的回文字符串，即符合以下条件的字符串 $S$ 是回文字符串：

首先把字符串 $S$ 分割成 $n$ 个子串 $S_1,S_2,\ldots,S_n$，即 $S_1+S_2+\ldots+S_n = S$（其中 $+$ 为字符串拼接操作）。

分割成的子串数量需要大于 $1$，且不能为空，即 $n > 1$ 且 $S_i$ 为非空子串。

对于所有的 $i \in[1, n]$ 有：要么 $S_i$ 与 $S_{n−i+1}$ 相等，要么 $S_i$ 与 $S_{n−i+1}$ 互为回文。（补充说明：字符串 $A$ 和 $B$ 互为回文指 $A$ 倒过来与 $B$ 相等，反之亦然。举例说明：$\texttt{abc}$ 与 $\texttt{cba}$ 互为回文。）

给定一个字符串 $S$，请你帮助小明确定该字符串是否是在上述规则下的回文字符串。

如果是，他还想将字符串 $S$ 分成尽可能多的子串。

## 说明/提示


### 样例解释

- 样例 $1$ 解释：最多可以把字符串分成 $\texttt{(a)(b)(c)(ab)(a)}$ 共 8 个子串。
- 样例 $2$ 解释：很显然不存在满足题意的分割方案。
- 样例 $3$ 解释：最多可以把字符串分成 $\texttt{(waha)(code)(waha)}$ 共 3 个子串。


### 数据范围

对于 $30\%$ 的数据，$1\le |S|\le 10$；（其中 $S$ 为给定字符串的长度）

对于 $60\%$ 的数据，$1\le |S |\le 10^3$；

其中有 $30\%$ 的数据，输入的字符串为回文字符串；

对于 $100\%$ 的数据，$1\le| S |\le10^4$，保证输入的字符串全为小写字母。

## 样例 #1

### 输入

```
abcababcba```

### 输出

```
YES 
8```

## 样例 #2

### 输入

```
goodluckhavefun```

### 输出

```
NO```

## 样例 #3

### 输入

```
wahacodewaha```

### 输出

```
YES
3```

# 题解

## 作者：2021CHD (赞：8)

## 题目大意

问字符串 $S$ 是否可以被划分为 $n(n>1)$ 个非空子串 $S_1,S_2,\dots,S_n$，满足对于所有 $1\le i\le n$，有 $S_i=S_{n-i+1}$ 或 $S_i=\text{rev}(S_{n-i+1})$，若可以，求出 $n$ 的最大值。

其中 $\text{rev}(T)$ 表示将字符串 $T$ 反转得到的结果。

- $1\le |S|\le10^4$，其中 $|S|$ 表示字符串 $S$ 的长度。

## 题解

首先可以将 $n>1$ 的限制解除再求出 $n$ 的最大值，如果最大值是 $1$，就是无解，否则就是有解。

第一个显然的观察是 $|S_i|=|S_{n-i+1}|$。

首先可以考虑到，其实题目中给出的 $S_i=\text{rev}(S_{n-i+1})$ 的条件其实是无用的，原因见下图。

![将字符串拆散](https://cdn.luogu.com.cn/upload/image_hosting/juz1fm8h.png)

所有的 $S_i=\text{rev}(S_{n+1-i})$ 就可以表示成 $|S_i|$ 对相等的字符串，而在这个过程中，$n$ 不会减小。

（另外，如果 $n$ 是奇数，那 $S_{\frac{n+1}{2}}$ 始终和自身相等，所以不用考虑 $S_{\frac{n+1}{2}}=\text{rev}\left(S_{\frac{n+1}{2}}\right)$ 这种情况）

所以现在只需考虑对所有的 $i$ 都满足 $S_i=S_{n-i+1}$ 的情况。

容易想到一个贪心：每次从两边贪心地选取最短的一个合法的串，直接把这个串选上并计入答案。如果选中的两个串有重叠部分，说明只能把最后一个串放在中间，答案就会是奇数。

实现是容易的，但是很多人可能忽略了一个问题：**为什么这样是对的呢？**

考虑一个位置，如果在这个位置上有两种可转移的串，下面这两张图说明了选短的串一定由于选长的串：

![解释1](https://cdn.luogu.com.cn/upload/image_hosting/5psv16m9.png)

此时 $n$ 会增加，而且选择二包含了选择一，所以选择二更优。

![解释2](https://cdn.luogu.com.cn/upload/image_hosting/ams37wp8.png)

具体地，如果选择一的长度为 $L_1$，选择二的长度为 $L_2>\frac{L_1}{2}$，那一定有一种长为 $(L_1-1)\bmod(L_1-L_2)+1$ 的选择。

另外，如果选择 1 是选择最中心的整个串，那显然不可能比选择 2 更优。

所以我们可以放心地说这个贪心是对的。

贴上代码和 [AC 记录](https://www.luogu.com.cn/record/196668593)。

```c++
#include<cstdio>
#include<cstring>
using namespace std;
int n,i,j,ll,len,ans;
char s[11000];
main()
{
	scanf("%s",s+1);
	len=strlen(s+1);
	ll=1;
	for(i=1;i<=len;i++)
	{
		for(j=ll;j<=i;j++)
		if(s[j]!=s[len-i+j-ll+1])
		break;
		if(j>i)
		{
			ll=i+1;
			if(i*2<=len)
			ans=ans+2;
			else
			ans++;
		}
		if(ll*2-1>len)
		break;
	}
	if(ans==1)
	printf("NO");
	else
	printf("YES\n%d",ans);
}
```

## 后记

随便开了一道题，发现是黄的，花了几分钟做了出来，感觉是一道好题。

打开题解区，发现上面写着“算法分析：好像没有。”

……

于是我决定把证明补上。

---

## 作者：woyaoxiaban (赞：3)

## 题目大意
将一个字符串 $S$ 划分成 $n$ 个连续子串，判断一个字符串 $S$ 中的任意第 $i$ 个连续子串 $S_i$ 和第 ${n-i+1}$ 个连续子串 $S_{n-i+1}$ 都相等或互为回文。
## 题目思路
题目要求 $n$ 尽可能的大，所以从头和尾开始判断，$s1$ 表示从头匹配的字符串，$s2$ 表示从尾部匹配的字符串，只要相等就匹配成一对子串。两个不相等且互为回文的字符串一定可以分割成单个字符，比如 $\texttt{abcgoodcba}$ 中，$\texttt{abc}$ 与 $\texttt{cba}$ 互为回文，匹配时会分成最小的字符串 $\texttt{a}$、$\texttt{b}$、$\texttt{c}$，又回到了前面相等的情况。

因为除了和相等的字符串匹配外还会和自身匹配一次，所以匹配成功次数等于划分子串个数。直接看代码更好理解：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s,s1,s2;
int n,ans,len;
int main(){
	cin>>s;
	len=s.size();
	int i=0,j=len-1;
	while(i<len&&j>=0){
		s1+=s[i]; //s1从开头匹配
		s2=s[j]+s2; //s2从结尾匹配
		if(s1==s2) ans++,s1="",s2=""; //配对成功，清空
		i++,j--;
	}
	if(ans==1) cout<<"NO";  //说明只有自己和自己匹配，没有回文子串，否则一定>1
	else {
		cout<<"YES\n"<<ans;
	}
	
}
```

---

## 作者：fr_dr (赞：2)

## 题目大意
将给定的字符串在符合题目条件的前提下，分成尽可能多的子串。
## 思路
满足以下两个条件中的任意一个即可。
- 条件一： $S_i$ 和 $S_{n-i+1}$ 回文，因为要尽可能多的拆分那么会发现只要满足该条件的子串的可继续拆分成更小的单位，那么只需要判断对称的两个字母是否相同即可。
- 条件二： $S_i$ 和 $S_{n-i+1}$ 相等。若字母不满足条件一则一定和其他字母结合共同满足条件二。

回文和相等都要求子串长度相同，划分的子串应对称分布，也就是说将其翻过来后位置相同，那么我们就可以放心大胆的挨个比较对称的两个字母分别判断上述的两个条件再根据上述特性计算答案。
## 代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[10010];
long long len,ans=0;
int main(){
	cin>>a+1;
	len=strlen(a+1);
	long long i=1,j=len;//定义首尾指针 。
	bool flag=0;
	string s,s1;
	s.clear();
	s1.clear();
	while(i<=j){	
	   if(i==j&&!flag){//如果长度为奇数个且仅剩该字母，单独一个子串 。
			ans++;
			break;
		}
		 if(flag){//如果前面字母不合条件一那么当前字母需和前面字母共同构成子串 。
		 	s+=a[i]; 
		 	s1.insert(s1.begin(),a[j]); 
		 //	cout<<s<<" "<<s1<<'\n';
		 	if(s==s1){//如果相等结束添加。
		 		flag=0;
		 		s.clear();
		 		s1.clear();
		 		ans+=2;
			 }
		 }
		 else{
		 	if(a[i]==a[j]){//若果没有需要和其共同满足条件二的字母且该字母与其对称字母相同则直接增加子串数量 。
		 		ans+=2;
			 }
			 else{//不满足条件一，需和后面字母共同满足条件二 。
			 	flag=1;
			 	s+=a[i];
			 	s1.insert(s1.begin(),a[j]);
			 }
		 }
		 i++;//移动指针 。
		 j--;
	}
	if(flag){//如果不合条件一的字母到最后也没合成子串时期符合条件二，那么将其合为一个子串 。
		ans++;
	}
	if(ans>1){//子串数量若再加完一个子串后大于一则合题 。
	flag=0;
}
	if(flag){//不能合题的字符串只能为没有字母符合条建一且最后只合成一个的 。
		cout<<"NO";
	}
	else{
		cout<<"YES"<<'\n';
		cout<<ans;
	}
}

```

---

## 作者：cxoi1501 (赞：2)

### 题目传送门：[B4101](https://www.luogu.com.cn/problem/B4101)
### 算法分析：好像没有。
### 主要思路：
一首一尾去模拟一遍。有子串相同了就加一下，再把临时字符串清空。最后特判一下即可。   
核心代码如下。
```cpp
for(int i=0,j=s.size()-1;i<=j;i++,j--)
	{
		a+=s[i];
        b=s[j]+b;
        c=b+s[j];
		if(i!=j&&(a==b||a==c))
		{
			cnt+=2;
			a=b=c="";
		}
	}
``````   
好像有些抽象。   
### 看代码吧。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,a,b,c;
int cnt;
int main()
{
	cin>>s;
	if(s.size()==1)//没意义
	{
		cout<<"NO";
		return 0;
	}
	for(int i=0,j=s.size()-1;i<=j;i++,j--)
	{
		a+=s[i];
        b=s[j]+b;
        c=b+s[j];
		if(i!=j&&(a==b||a==c))//核心部分
		{
			cnt+=2;
			a=b=c="";//清空
		}
	}
	if(a!="") cnt++;//特判
	if(cnt==1) cout<<"NO";
	else cout<<"YES\n"<<cnt;
}
``````
最后求管理员大大通过。

---

## 作者：mishitaotuoyyds (赞：1)

# 题目分析：
由题目的样例可知我们只需要将 $s$ 分为两段，如果两段相等就说明可以分的段数多了两段，然后清零两段字符，所以我们只需要控制两段的位置就可以了，至于如何判断能不能分，分为两种情况。

- 字符 $s$ 长度为 $1$。
- 字符 $s$ 一直没有可以分成的两段相等。

## 参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s,s1,s2,s3;
long long ans,y;
int main () {
	cin>>s;
    y=s.size()-1;
	if (s.size ()==1)cout<<"NO";
	else{
        for(int i=0;i<=y;i++){
            s1+=s[i],s2=s[y]+s2,s3=s2+s[y],ans+=2*(i!=y&&(s1==s2||s1==s3));
            if(i!=y&&(s1==s2||s1==s3))s1="",s2="",s3="";
            y--;
        }
        ans+=(s1!="");
        if (ans==1)cout<<"NO";
        else cout<<"YES\n"<<ans;
    }
}
```

---

## 作者：SuyctidohanQ (赞：0)

### 题目分析

具体实现步骤：

$1.$ 如果，字符串长度 $= 1$，直接输出 `NO` 结束。

实现代码：

```cpp
if (s.size () == 1){
	cout << "NO" << endl;
    return 0;
}
```

$2.$ 接下来，我们用一个循环，从字符串左右两边开始，一起向中间跑，用字符串 $a,b,c$ 把字符串 $s$  穿起来，每次进行判断，用一个变量进行累加。**注意：$a,b,c$ 清空！**

代码实现

```cpp
for (int i = 0, j = s.size () - 1; i <= j; i ++, j --) {
	a += s[i]; 
	b = s[j] + b; c = b + s[j];
	if (i != j && (a == b || a == c)) {
		ans += 2;
		a = b = c = "";
	}
}
```

循环结束后，需要特判一下字符串 $a$，如果字符串 $a$ 内还有字符，变量累加。

### 代码实现

```cpp
#include<iostream>
#include <bits/stdc++.h>
using namespace std;
string s, a, b, c;
int ans = 0;;
int main () {
	cin >> s;
	if (s.size () == 1) {
		cout << "NO" << endl;
		return 0;
	}
	for (int i = 0, j = s.size () - 1; i <= j; i ++, j --) {
		a += s[i];
		b = s[j] + b;
		c = b + s[j];
		if (i != j && (a == b || a == c)) {
			ans += 2;
			a = b = c = "";
		}
	}
	if (a != "") ans ++;
	if (ans == 1) cout << "NO" << endl;
	else cout << "YES" << endl << ans << endl;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4101 [CSP-X2023 山东] 回文字符串](https://www.luogu.com.cn/problem/B4101)
## 思路：
我们先来观察一下本题的数据，字符串长度有 $=1$ 的情况，由于题目里说“分割成的子串数量需要大于 $1$，且不能为空，即 $n>1$ 且 $S_i$ 为非空子串”，所以没学过字符串的同学可以直接输出 NO。不过，在写代码时，这种情况还是需要特判一下。
```cpp
cin>>s;
if(s.size()==1){
	cout<<"NO";return 0;
}
``````
然后，我们用一个循环，定义两个变量 $i$ 和 $j$，从字符串左右两边开始，一起向中间跑，用字符串 $a$、$b$、$c$ 把字符串 $S$ 穿起来，每次进行判断，成功用 $cnt$ 进行累加， $a$、$b$、$c$ 清空。
```cpp
for(int i=0,j=s.size()-1;i<=j;i++,j--){
	a+=s[i];b=s[j]+b;c=b+s[j];
  if(i!=j&&(a==b||a==c)){
		cnt+=2;
		a=b=c="";
	}
}
``````
循环结束后，需要特判一下字符串 $a$，如果字符串 $a$ 内还有字符，$cnt$ 进行累加。
## AC Code：
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<map>
#include<ios>
#include<ostream>
#include<queue>
#include<stack>
#include<vector>
#include<set>
#include<string>
#include<cwchar>
#include<fstream>
#include<list>
#include<iomanip>
#include<cwctype>
#include<utility>
#include<iosfwd>
#include<streambuf>
#include<algorithm>
#include<bitset>
#include<complex.h>
#include<ctime>
using namespace std;
string s;
string a;
string b;
string c;
int cnt;
int main(){
	cin>>s;
	if(s.size()==1){
		cout<<"NO";return 0;
	}
	for(int i=0,j=s.size()-1;i<=j;i++,j--){
		a+=s[i];b=s[j]+b;c=b+s[j];
		if(i!=j&&(a==b||a==c)){
			cnt+=2;
			a=b=c="";
		}
	}
	if(a!="")cnt++;
	if(cnt==1)cout<<"NO";
	else cout<<"YES\n"<<cnt;
}
``````

---

## 作者：yyycj (赞：0)

## 题目简述
如果能把一个字符串 $S$ 分割成 $n$（$n>1$）个非空子串 $S_{1},S_{2},\cdots,S_{n}$，并且对于每个 $i \in [1,n]$，$S_{i} = S_{n-i+1}$ 或者 $S_{i}$ 与 $S_{n-i+1}$ 互为回文，字符串 $S$ 就称为回文字符串。

给定字符串 $S$，要求判断 $S$ 是否是一个回文字符串。如果是，输出 `YES`，并输出 $n$ 的最大值；否则输出 `NO`。

## 主要思路
如果两个字符串要满足相等或互为回文，那么长度一定相等；并且 $S_{i}$ 和 $S_{n-i+1}$ 刚好可以看做序列 $S$ 的从左往右数第 $i$ 个和从右往左数第 $n$ 个。

所以可以遍历 $1 \sim \lceil \frac{|S|}{2} \rceil$，记录字符串 $s1$ 和 $s2$，每次在 $s1$ 前面添加 $S[i]$，在 $s2$ 前面添加 $S[n-i+1]$。每次判断一下 $s1$ 和 $s2$ 是否满足条件，由于要求 $n$ 最大，所以如果满足，则立即清空 $s1$ 和 $s2$，并将答案增加 $2$。  
但是存在一种情况，在 $i = \lceil \frac{|S|}{2} \rceil$ 并且 $n$ 是奇数时，如果满足条件，则 $s1$ 和 $s2$ 表示的是同一个位置的字符，这时候答案就不能增加 $2$ 而是 $1$。  
最后遍历完后，还可能会出现样例#3的情况，$n$ 为偶数导致不会被检测到，所以需要额外特判。

## AC Code
```cpp
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

#define endl '\n'
typedef long long ll;
typedef unsigned int ui;
typedef pair<int,int> pii;
typedef unsigned long long ull;
// ----------------------------

// ----------------------------

// ----------------------------
inline int read() {
	int f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch=getchar();}
	return sum*f;
}

void print(int x) {
	if(x<0){putchar('-');x=-x;}
	if(x>9){print(x/10);}
	putchar(char(x%10+'0'));
}

bool check(string s1,string s2) {
	if (s1 == s2) return true;
	reverse(s2.begin(),s2.end());
	return s1 == s2;
}

int main() {
	string s;
	cin>>s;
	// ------------------------
	int ans = 0;
	string s1 = "";
	string s2 = "";
	int n = s.length();
	for (int i=0;i<(n+1)/2;i++) {
		s1 += s[i];
		s2 = s[n-i-1] + s2;
		if (check(s1,s2)) {
			s1 = "";
			s2 = "";
			ans += 2;
			if (n&1 && i==n/2) ans--;
		}
	}
	if (ans && s1!="" && s2!="") ans++;
	// ------------------------
	if (!ans) cout<<"NO";
	else {
		cout<<"YES"<<endl;
		print(ans);
	}
	return 0;
}
```

---


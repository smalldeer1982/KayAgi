# [CSP-X2023 山东] 代价

## 题目描述

因为“黑发不知勤学早”，于是小明成为了一名伟大的流水线工人，天天起早摸黑打螺丝。

这一天，小明所在的流水线生成了 $n$ 件产品，其中第 $i$ 号产品规格用一个正整数 $a_i$ 表示。

所谓流水线，就是需要标准化。于是，小明想把这 $n$ 件产品规格修整得全部相同。

小明手边有两种工具来进对产品进行修整，但是使用不同工具需要花费不同的代价，小明可以进行以下操作任意次：

- 使用一次第一种工具花费 $A$ 的代价将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i+1$（其中 $i\in [1,n]$）。
- 使用一次第二种工具花费 $B$ 的代价将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i-1$（其中 $i\in [1,n]$）。

现在小明想要花费最少的代价将所有产品的规格都变得相同，于是他找到了自幼勤学苦练的你来帮忙。

你只需要计算出把所有产品调整为相同规格的最小代价即可。


## 说明/提示


### 样例解释

- 样例 $1$ 解释：两种操作的代价相等，所以把所有产品规格修改成 $2$ 花费的代价最小，计算可得最小代价为 $4$（$1$ 变为$2$，$5$ 变为 $4$，$4$ 再变为 $3$，$3$ 再变为 $2$，已经规格相同，共 $4$ 次）。
- 样例 $2$ 解释：因为二操作代价 $B$ 太大，所以把所有产品规格修改成 $5$ 花费代价最小，计算可得最小代价为 $7$（用一操作，$1$ 变为 $5$ 需要 $4$ 次，$2$ 变为 $5$ 需要 $3$ 次，共 $7$ 次）。


### 数据范围

对于 $30\%$ 的数据，$1\le n\le 10$，$1\le a_i \le100 $，$1\le A,B \le10$；

对于 $60\%$ 的数据，$1\le n\le 10^5$，$1\le a_i \le10^5 $，$1\le A,B \le100$；

其中有 $30\%$ 的数据，$A=B$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le a_i \le10^9 $，$1\le A,B \le1000$。
	

## 样例 #1

### 输入

```
3 1 1 
1 2 5```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1 100 
1 2 5```

### 输出

```
7```

## 样例 #3

### 输入

```
3 2 5 
999999999 999999999 999999999```

### 输出

```
0```

# 题解

## 作者：songge888 (赞：13)

~~目前没有人发二分做法，我先交一发题解。~~

### 题意

有一个长度为 $n$ 的序列 $a$，每次可以花费 $A$ 的代价将 $a_i+1$，也可以花费 $B$ 的代价将 $a_i-1$，求将 $a$ 序列全部变成相同的一个数的最小代价。

### 思路

注意到 $n \le 10^5,a_i \le 10^9$，可以使用 $O(n \log a_i)$ 的做法。

考虑二分值域。

设序列中最小值为 $minn$，最大值为 $maxn$。

贪心的想，最终的答案一定在 $[minn,maxn]$ 之间。

所以把左边界 $l$ 赋为 $minn$，右边界 $r$ 赋为 $maxn$，进行二分。

$O(n)$ 的枚举答案时 $mid$ 和 $mid+1$ 时的代价 $f(mid)$ 和 $f(mid+1)$，如果 $f(mid)<f(mid+1)$ ，则可以尝试缩小 $mid$，否则反之。

总时间复杂度：$O(n\log a_i)$。

注意当 $minn=maxn$ 时要特判输出 $0$。
### Code

```c++
#include<bits/stdc++.h>
#define bug cout<<"songge888"<<'\n';
#define int long long
using namespace std;
int n,a,b,v[100010],l=1e18,r,ret;
int f(int x){
    int s=0;
    for(int i=1;i<=n;i++){
        if(v[i]<x){
            s+=(x-v[i])*a;
        }
        else{
            s+=(v[i]-x)*b;
        } 
    }
    return s;
}
signed main(){
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>v[i];
        l=min(l,v[i]);
        r=max(r,v[i]);
    }
    if(l==r){
        cout<<0<<endl;
        return 0;
    }
    while(l<=r){
        int mid=(l+r)/2;
        if(f(mid)<=f(mid+1)){
            ret=mid;
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }
    cout<<f(ret)<<endl;
    return 0;
}

```

---

## 作者：Sweet_2013 (赞：7)

需要使用前缀和思想解决问题。  
- 输入。
- 定义前缀和数组 $s$，计算 $a_1—a_i$ 之和，并定义 $minn$ 作为最后要输出的答案，将其定义成 long long 范围内的最大值。
- 计算代价 $sum$，我们推出公式，即 $(a_i\times(i-1)-s_{i-1})\times a1$，如果这个 $sum$ 比原来的答案要小，那么就更新答案，否则不更新。
- 输出答案。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a1, b; 
long long a[100005], s[100005], minn=LLONG_MAX, sum; //s 为前缀和数组，minn 是最后输出的答案，定为 long long 的最大值 LLONG_MAX，sum 是每次遍历计算代价的变量。
int main() {
    cin>> n>> a1>> b; 
    for(int i=1;i<=n;i++) cin>> a[i]; 
    sort(a+1, a+1+n);//排序。
    for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];//s[i] 就是计算 a[1]——a[i] 的和。
    for (int i=1;i<=n;i++) {
        sum=((i-1)*a[i]-s[i-1])*a1+(s[n]-s[i]-(n-i)*a[i])*b;//计算代价的公式套进去，这就是本题的关键。
        minn=min(minn, sum);//如果计算出的代价比原来的答案小，那么就更新，否则不管它。
    }
    cout<<minn; 
    return 0;
}
```

---

## 作者：fr_dr (赞：6)

## 分析
找到一个数 $s$ 使每个 $a_i(i\in[1,n])$ 通过花费 A 代价的操作或花费 B 代价的操作变为 $s$ 的总代价最小   

## 思路
- 如果 $A=B$ 那么答案为中位数

- 如果 $A \ne B$ 那么代价的增减在两个相邻不同大小的产品规格之间成单调性

原因：将其所有数字标到平面直角坐标系中下标为横轴，产品规格为纵轴
![](https://cdn.luogu.com.cn/upload/image_hosting/xkgbazk4.png)
当将所选标准在相邻不相等的产品规格间移动时，

向下移动

$W=W-num_1\times k\times A+num_2\times k\times B$


向上移动


$W=W-num_2\times k\times B+num_1\times k\times A$

（其中 $W$ 表示代价， $num_1 $ 表示在标准线下的数 $num_2$ 表示在标准上方的数， $k$ 为移动的长度）

可以发现区间内 $num_1$ 和 $num_2$ 不变所以记

$f(k)=-num_2 \times k \times B + num_1 \times k \times A = k \times ( -num_2 \times B + num_1  \times A )$  
$f_1(k) = -num_1 \times k \times A + num_2 \times  k \times B = k \times ( -num_1 \times A + num_2 \times B )$ 

因为在同一区间 $num_1$ $num_2$ 不变，所以 $- num_1 \times A + num_2 \times B$ 和 $- num_2 \times B + num_1 \times A$ 不变，所以 $W = W + f(k)$ 和 $W= W + f_1(k)$ 是单调的。

所以将标准初始为中位数，分别向上向下移动，即枚举标准的大小，又因为在两个相邻不相等的产品规格之间的区间成单调性，所以直接枚举产品规格的数值即可（若其向上移动或向下移动代价单调递减，那么向上向下移动的末点即产品规格的数值点即为该区间的最小值点），如果当前枚举到的值要比当前最优解要小，继续枚举，否则停止。
## 代码


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long a[100010],n,sta,a1,b1,rans=1e18,b[100010];
long long read(){
	long long x=0,d=1;
	char a=getchar();
	while(a>'9'||a<'0'){
		if(a=='-'){
			d=-1;
		}
		a=getchar();
		
	}
	while(a>='0'&&a<='9'){
		x=x*10+a-'0';
		a=getchar();
	}
	return x*d;
}
int main(){
	cin>>n>>a1>>b1;
	for(int i=1;i<=n;i++){
		b[i]=a[i]=read();
	}   
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	long long q=(long long)(unique(b+1,b+n+1)-b);//将b数组去重以便后续枚举标准大小 
	if(n%2==0){
		sta=a1>=b1?n/2:n/2+1;
	}
	else
        sta=(n+1)/2;//计算中位数下表 
    for(int i=1;i<q;i++){ 
        	if(a[sta]==b[i])
        	sta=i;
		}//寻找中位数在b数组中的位置 
		for(long long k=sta;k<q;k++){//将标准线向上移动 
			long long i=b[k]; 
    		long long ans=0;
			for(long long j=1;j<=n;j++){
    			ans+=a[j]<=i?a1*(i-a[j]):b1*(a[j]-i);//计算代价 
			}
			if(rans>=ans)
			rans=ans;
			else
			break;//如果比当前最优解要大那么停止 
		}
        if(a1!=b1)
		for(long long k=sta;k>=1;k--){//将标准线向下移动 
			long long i=b[k]; 
    		long long ans=0;
			for(long long j=1;j<=n;j++){
    			ans+=a[j]<=i?a1*(i-a[j]):b1*(a[j]-i);//同上 
			}
			if(rans>=ans)
			rans=ans;
			else
			break;//同上 
		}
	cout<<rans;
}

```

---

## 作者：michaelwanghaoyu (赞：3)

## 闲话
~~代价？代驾~~。

咳咳，言归正传。
## 题意+分析
看见 $a_i+1$（其中 $i\in[1,n]$。和 $a_i+1$）其中（$i\in [1,n]$）。是不是脑子一热？

但是这道题并不难，我们只需要计算每种规格的代价，最后选最小的就可以，至于 $a_i+1$（其中 $i\in [1,n]$）。直接放进代码就行。

温馨提示：排序不能忘~~因为我忘了~~。

AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
long long w[100005],sum[100005];
int main() 
{
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++)
    {
        cin>>w[i];//输入代价 
	} 
    sort(w+1,w+1+n);//排序 
    for(int i=1;i<=n;i++)
	{
        sum[i]=sum[i-1]+w[i];//前缀和 
    }
    long long ans=LONG_MAX;//Cu Ball地用LONG _MAX
    for(int i=1;i<=n;i++)
	{
        //计算每种规格的代价，计算最小的 
        long long t=((i-1)*w[i]-sum[i-1])*a+(sum[n]-sum[i]-(n-i)*w[i])*b;//把两眼一昏的公式带进去
        ans=min(ans,t);
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：xinxin2022 (赞：1)

## 简述题意：

先排序。

然后设 $a_x$ 为小于 $v$ 中最大的 $a_i$，求 $v$ 使得下面式子最小，并输出该式最小值：


$$(\sum_{i=1}^{x} A\times(v-a_i))+(\sum_{i=x+1}^{n}B\times (a_i-v))$$

## 思路

首先发现可以枚举 $v$，$O(n^2V)$ 是容易的，若使用前缀和，还能优化到 $O(nV)$，$V$ 为最大的 $a_i$。

然后考虑如何优化成时间复杂度基于 $n$ 的。

思考 $v$ 与 $a_i$ 有何关联。

设 $x$ 为第一种操作的执行次数，$y$ 为第二种操作的执行次数。

问题转为求最小 $xA+yB$。

若 $v$ 增加时 $xA+yB$ 不变，可枚举 $i$，令 $v=a_i$ 找到答案。

若 $xA+yB$ 变化，因为 $v$ 不增加至下一个 $a_i$ 时 $x$ 和 $y$ 的变化值一定为定值，因此 $v$ 一定可取某个 $a_i$，枚举 $i$ 即可。

对于 $x$ 和 $y$ 的快速求值，设 $y=\sum_{i=1}^{n} a_i$

当 $i$ 增加时：

令 $x$ 加上 $(a_i-a_{i-1}) \times(i-1)$。

令 $y$ 减去 $(a_i-a_{i-1}) \times(n-i-1)$。

时间复杂度取决于排序速度，最快为 $O(n \log n)$。

加入快读后轻松 $68ms$。

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long A,B,ans=1e18,x,y,a[100005];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>A>>B;
    for(int i=1;i<=n;i++) cin>>a[i],y+=a[i];
    sort(a+1,a+1+n);
    a[n+1]=a[n];
    for(int i=1;i<=n;i++){
        y-=(a[i]-a[i-1])*(n-i+1);
        x+=(a[i]-a[i-1])*(i-1);
        ans=min(ans,x*A+y*B);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：1)

### 解题思路

**标准数字一定是数组中的一个数字**，证明如下：

假设我们要将所有产品规格调整为一个标准数字 $x$，这个数字可以是任意整数。

**成本函数**:
对于给定的标准数字 $x$，调整每个产品的规格 $a_i$ 到 $x$ 的成本可以表示为：

- 如果 $a_i < x$，需要使用第一种工具，成本为 $(x - a_i) \times A$。
- 如果 $a_i > x$，需要使用第二种工具，成本为 $(a_i - x) \times B$。
- 所以，总成本可以表示为：
  $$\text{cost}(x) = \sum_{i=1}^{n} ( (x - a_i) \times A \times 1_{a_i < x} + (a_i - x) \times B \times 1_{a_i > x} )$$

注意到 $cost(x)$ 是分段线性函数，其在 $x$ 为每个 $a_i$ 取值时可能会改变。因此，我们只需考虑 $x$ 在数组中的值。

所以我们只需要枚举每一个数作为标准数字 $x$ 的情况，再用一个循环去统计所有数字变为 $x$ 的代价之和，时间复杂度 $O(n^2)$。

考虑优化，在数组中第 $i$ 个元素作为标准数字 $x$ 时，我们需要让所有小于 $a_i$ 的所有数使用第一种工具，代价为两者之差与 $A$ 的积，大于 $a_i$ 的数同理。为了方便找到小于 $a_i$ 的所有数字与 $a_i$ 的差，我们可以将数组从小到大排序，那么小于 $a_i$ 的数为 $a_1, a_2, \dots, a_{i-1}$，代价和为 

$$(a_i - a_1) \times A + (a_i-a_2) \times A+ \dots (a_i-a_{i-1}) \times A = (a_i \times (i-1) - (a_1+a_2+\dots+a_{i-1})) \times A$$

为了方便计算 $a_1+a_2+\dots+a_i$ 的结果，我们可以使用**前缀和**算法进行优化，计算大于 $a_i$ 的部分同理。

时间复杂度 $O(n)$。

另外需要注意本题数据范围为 $1 \leq a_i \leq 10^9$，但是样例 $3$ 出现了 $a_i = 10^{10}-1$ 的情况，故需要将 $a$ 数组定义为 `long long` 类型。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, A, B;
LL a[N];
LL l[N], r[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> A >> B;
    for (int i = 1; i <= n; ++ i )
        cin >> a[i];
    
    sort(a + 1, a + n + 1);
    
    for (int i = 1; i <= n; ++ i )
        l[i] = l[i - 1] + a[i];
    for (int i = n; i; -- i )
        r[i] = r[i + 1] + a[i];
    
    LL res = 1e18;
    for (int i = 1; i <= n; ++ i )
        res = min(res, A * ((i - 1) * a[i] - l[i - 1]) + B * (r[i + 1] - (n - i) * a[i]));
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：qjh_2014 (赞：0)

## [题目](https://www.luogu.com.cn/problem/B4103)
## 思路
我们计算前缀和，无脑套题目里给出的公式，最后输出答案即可，就不过解释了，~~感觉还是太水了~~。
## 代码
注意点：
```
long long answer=0x7fffffff;//十年OI一场空不开long long见祖宗
//而且answer要等于一个很大的数
```

总代码，有注释不懂的私信问我，如有雷同纯属偶然。
```
#include <bits/stdc++.h>
using namespace std;
int read() {//快读 
	int x=0, w=1;
	char ch=0;
	while (ch<'0'||ch>'9') {
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+(ch-'0');
		ch=getchar();
	}
	return x*w;
}
long long w[1000005],sum[1000005];//题目中的数组和前缀和数组 
int main() {
	int n=read(),a=read(),b=read();
    for(int i=1; i<=n; i++){
        cin>>w[i];//read读入数据 
	} 
    sort(w+1,w+n+1);//一定要排序不然出错
    for(int i=1; i<=n; i++){
        sum[i]=sum[i-1]+w[i];//求前缀和的公式 
    }
    long long answer=999999999999999999;//十年OI一场空不开long long见祖宗
    //而且answer要等于一个很大的数
    for(int i=1; i<=n; i++){
        long long cnt;
		cnt=((i-1)*w[i]-sum[i-1])*a+(sum[n]-sum[i]-(n-i)*w[i])*b;//无脑地套公式
        answer=min(answer,cnt);//取min 
    }
    cout<<answer;//输出 
}

```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4103 [CSP-X2023 山东] 代价](https://www.luogu.com.cn/problem/B4103)
## 思路：
这道题并不是很难，千万不要被题干里~~张牙舞爪~~的数学公式吓到，只需要计算每种规格修改的代价，最后取最小值即可。

用 $sum$ 数组来求前缀和，为后面计算代价~~做铺垫~~做准备。$t$ 用来计算代价的，公式的前半部分是计算第一种工具的代价是多少，后半部分是计算第二种工具的代价是多少，最后 $ans$ 对 $t$ 求最小值即可。
## AC Code：
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,A,B,t,a[100100],sum[100100],ans=LLONG_MAX;
signed main(){
	scanf("%d%d%d",&n,&A,&B);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i];
	for(int i=1;i<=n;i++){
		t=((i-1)*a[i]-sum[i-1])*A+(sum[n]-sum[i]-(n-i)*a[i])*B;
		ans=min(ans,t);
	}
	cout<<ans;
}
``````

---

## 作者：JingchenBian (赞：0)

## 理解题意
题目要求：给定 $n$ 件产品，每件产品有一个规格 $a_i$，以及两种操作工具的代价 $A$ 和 $B$。操作一是将某件产品的规格加 $1$，花费 $A$ 的代价；操作二是将某件产品的规格减 $1$，花费 $B$ 的代价。目标是找到一种方案，使得所有产品的规格相同，并且总代价最小。
## 解题思路
1. 考虑到要将所有产品的规格调整为相同，一个直观的思路是遍历所有可能的规格值（即所有产品的规格中的某一个），然后计算将所有产品调整到该规格所需的总代价。
2. 对于每一个可能的规格值 $x$，计算将所有产品规格调整到 $x$ 的总代价。这个总代价可以通过操作一和操作二来实现，分别计算将所有小于 $x$ 的规格提升到 $x$ 的代价，以及将所有大于 $x$ 的规格降低到 $x$ 的代价。
3. 选择所有可能规格值中，使得总代价最小的那个规格值作为最终的目标规格。
## 实现过程
1. 首先，对所有产品的规格进行排序，这样可以更方便地计算提升到某个规格或降低到某个规格的代价。
2. 使用一个数组 $s$ 来记录前缀和，即 $s[i]$ 表示前 $i$ 个产品的规格之和。这样，可以快速计算出某个区间内产品的规格之和。
3. 遍历所有可能的规格值（即排序后的规格数组中的每一个值），对于每一个规格值 $x$，计算将所有产品规格调整到 $x$ 的总代价。这个总代价可以通过操作一和操作二的代价以及前缀和数组 $s$ 来计算。
4. 记录并更新最小代价。

---

## 作者：yu1128_AKIOI (赞：0)

## 思路

个人认为二分思路更好想。

不难发现区间 $[l,r]$ 是在 $a_i$ 的最值之间的。

用一个函数记录以一个数 $x$ 为基准时，小明的代价。

如果一个值 $mid$ 的函数值低于 $mid+1$，就说明还有比 $\operatorname{f}(mid)$ 更小的函数值，此时更新答案 $ans$，并把区间向左移，反之则需把区间向右移。

注意开 ```long long```！！并把 $ans$ 与最小值的值调大。

```cpp
#include<iostream>
#define int long long
using namespace std;
int n,A,B,a[100100],b[100100],mn=1e18,mx,ans=5e18+5;
int f(int k){
	int s=0;
	for(int i=1;i<=n;i++){
		if(k>a[i]) s+=(k-a[i])*A;
		else s+=(a[i]-k)*B;
	}
	return s;
}
signed main(){
	cin>>n>>A>>B;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		mn=min(mn,a[i]);
		mx=max(mx,a[i]);
	}
	if(mn==mx){
		cout<<0;
		return 0;
	}
	int l=mn,r=mx;
	while(l<=r){
		int mid=(l+r)/2;
		if(f(mid)<=f(mid+1)){
			ans=min(ans,f(mid));
			r=mid-1;
		}
		else l=mid+1;
	}
	if(ans==5e18) ans=mx;
	cout<<ans;
}

---

## 作者：huangzilang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4103)

**题目大意：**

给出三个数 $n,a,b$，$n$ 表示有 $n$ 个产品。

- $a$ 表示将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i+1$ 需要 $a$ 的代价。
- $b$ 表示将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i-1$ 需要 $b$ 的代价。

现在题目要你求出将所有产品的规格都变得相同的最少的代价。

**思路：**

我先把数组排了个序，然后用了一个前缀和，表示从 $0$ 到 $i$ 没个数的和，这两个操作是为了让求值时代码更短，减少时间复杂度。接着就到求和，求和时我用了一个公式，具体可以看下面的解释。求出公式的值后，与当前最小值作比较，如果最小值比它小，就把最小值的值改变为它。

**公式解释：**

我的公式是：

$((i-1)\times a_i-s_{i-1})\times x+(s_n-s_i-(n-i)\times a_i)\times y$

我先解析一下前面的 $((i-1)\times a_i-s_{i-1})\times x$ 是什么意思，因为我们排了序，所以 $i-1$ 为比 $a_i$ 小的数的个数，然后 $\times a_i$ 是算出如果这些数要修改成 $a_i$ 的总和，因为他们不是 $a_i$，所以要 $-s_{i-1}$ 来计算出与实际这些数的和的差值，最后结果就是一共修改的次数，再 $\times x$ 就是比 $a_i$ 小的数的总修改价值。

后面的以此类推。

**代码：**


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,y,a[10000005],s[10000005];
long long ans=1e18;
int main()
{
	scanf("%lld%lld%lld",&n,&x,&y);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	} 
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		s[i]=s[i-1]+a[i];
	}
	for(int i=1;i<=n;i++)
	{
		long long sum=((i-1)*a[i]-s[i-1])*x+(s[n]-s[i]-(n-i)*a[i])*y;
		ans=min(ans,sum);
	}
	cout<<ans;
} 
```

如果在代码或公式上有任何不懂的，欢迎在评论区或私信问我。

---

## 作者：hjz_0821_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4103)

## 思路
看题目，$a_i+1$ 和 $a_i-1$ （其中 $i \in [1,n]$）的（$i \in [1,n]$），有没有感觉想冲动地直接打或者感觉这题有难度？

但是，这道题不算很难。只需要计算每种规格的代价，最后选最小的即可。而 $a_i+1$ 和 $a_i-1$（其中 $i \in [1,n]$），直接原封不动地放到代码里。还要排序。

## 代码

```cpp
#include<bits/stdc++.h>
#define MAXN 9223372036854775807//后面会用到 
using namespace std;
int n,a,b;
long long w[100005],sum[100005];
int main(){
    cin>>n>>a>>b;//输入 
    for(int i=1;i<=n;i++){
        cin>>w[i];//还是输入 
	} 
    sort(w+1,w+1+n);//排序 
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]+w[i];//计算前缀和 
    }
    long long ans=MAXN;//定义成最大，便于找最小的结果 
    for(int i=1;i<=n;i++){
        long long t;
		t=((i-1)*w[i]-sum[i-1])*a+(sum[n]-sum[i]-(n-i)*w[i])*b;//套公式 
        ans=min(ans,t);//找最小 
    }
    cout<<ans;//输出 
    return 0;
}
```

---

## 作者：yyycj (赞：0)

## 题目简述
有 $n$ 件产品，规格分别为 $a_{1} \sim a_{n}$，需要把所有产品的规格改成相同的。

操作 $A$：将 $a_{i}$ 的规格改成 $a_{i+1}$，代价为 $A$。  
操作 $B$：将 $a_{i}$ 的规格改成 $a_{i-1}$，代价为 $B$。

求把所有产品的规格改成相同的需要的最小代价。

## 主要思路
比较简单，先将 $a$ 排一遍序，然后遍历 $a_{1} \sim a_{n}$，记录一个最小值表示答案。每次让 $a_{1} \sim a_{i-1}$ 的产品规格改成 $a_{i}$，代价为：
$$[a_{i} \times (i-1) - \sum_{j=1}^{i-1} a_{j}] \times A$$
让 $a_{i+1} \sim a_{n}$ 的产品规格改成 $a_{i}$，代价为：
$$[\sum_{j=i+1}^{n} a_{j} - a_{i} \times (n-i)] \times B$$
求和的过程可以用前缀和解决，最后将答案设为答案和这两个代价的总和中的最小值即可，依次遍历，就可以得到最后的答案。

最最后：十年 OI 一场空，_______________。

## AC Code
```cpp
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

#define endl '\n'
typedef long long ll;
const int N = 1e5 + 10;
typedef unsigned int ui;
typedef pair<int,int> pii;
typedef unsigned long long ull;
// ----------------------------

// ----------------------------
ll pre[N];
ll nums[N];
// ----------------------------
inline ll read() {
	ll f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch=getchar();}
	return sum*f;
}

void print(ll x) {
	if(x<0){putchar('-');x=-x;}
	if(x>9){print(x/10);}
	putchar(char(x%10+'0'));
}

int main() {
	ll n = read();
	ll a = read();
	ll b = read();
	for (int i=1;i<=n;i++) nums[i] = read();
	// ------------------------
	ll ans = 1e18;
	sort(nums+1,nums+n+1);
	for (int i=1;i<=n;i++) pre[i] = pre[i-1] + nums[i];
	for (int i=1;i<=n;i++) {
		ll sum1 = (nums[i]*(i-1)-pre[i-1]) * a;
		ll sum2 = ((pre[n]-pre[i])-nums[i]*(n-i)) * b;
		ans = min(ans,sum1+sum2);
	}
	// ------------------------
	print(ans);
	return 0;
}
```

---

## 作者：RenZhen1 (赞：0)

题目中 $30\%$ 的数据 $A=B$ 这种情况直接找中位数即可。

对于 $100\%$：

产品规格可以 $+1$，也可以 $-1$，并且操作的代价还不相同，避免不了枚举了，最终**目标代价一定是数组中的某一个数字** 。


下面给出目标代价一定在数组中的说明：

假设目标代价 $x$ 不是数组中的数，即 $x$ 不等于任何 $a_i$ 。那么 $x$ 必然位于两个数组元素之间，即存在 $k$ 使得 $a_k<x<a_{k+1}$。

那么对于所有数字全部变成 $x$ 的代价：

$$C(x)=A\sum_{i=1}^k(x-a_i)+B\sum_{i=k+1}^n(a_i-x)$$

那么所有数字变成 $a_k$ 和 $a_{k+1}$ 的代价分别是：

$$C(a_k)=A\sum_{i=1}^{k-1}(a_k - a_i)+B\sum_{i=k+1}^n(a_i-a_k)$$

$$C(a_{k+1})=A\sum_{i=1}^k(a_{k+1}-a_i)+B\sum_{i=k+2}^n(a_i-a_{k+1})$$

接下来比较一下 $C(x)$ 与 $C(a_k)$：

考虑 $(C(x)-C(a_k))$：

$$C(x)-C(a_k)=\left(A\sum_{i=1}^k(x-a_i)+B\sum_{i=k+1}^n(a_i-x)\right)-\left(A\sum_{i=1}^{k-1}(a_k-a_i)+B\sum_{i=k+1}^n(a_i-a_k) \right)$$
$$=A\left(\sum_{i=1}^k(x-a_i)-\sum_{i=1}^{k-1}(a_k-a_i)\right)+B\left(\sum_{i=k+1}^n(a_i-x)-\sum_{i=k+1}^n(a_i-a_k)\right)$$
$$=A\left(kx-\sum_{i=1}^ka_i-(k-1)a_k+\sum_{i=1}^{k-1}a_i\right)+B\left(\sum_{i=k+1}^n a_i-(n-k)x-\sum_{i=k+1}^na_i+(n-k)a_k\right)$$
$$=A\left(kx-\sum_{i=1}^k a_i-(k-1)a_k+\sum_{i=1}^{k-1}a_i\right)+B\left((n-k)a_k-(n-k)x\right)$$
$$=A\left(kx-a_k-\sum_{i=1}^k a_i+\sum_{i=1}^{k-1}a_i\right)+B(n-k)(a_k-x)$$
$$=A\left(kx-a_k-a_k\right)+B(n-k)(a_k-x)$$
$$=A(kx-ka_k)+B(n-k)(a_k-x)$$
$$=kA(x-a_k)+(n-k)B(a_k-x)$$
$$=(kA-(n-k)B)(x-a_k)$$

再比较一下 $C(x)$ 与 $C(a_{k+1})$：

考虑 $C(x)-C(a_{k+1})$：
$$C(x)-C(a_{k+1})=\left(A\sum_{i=1}^k(x-a_i)+B\sum_{i=k+1}^n(a_i-x)\right)-\left(A\sum_{i=1}^k(a_{k+1}-a_i)+B\sum_{i=k+2}^n(a_i-a_{k+1})\right)$$
$$=A\left(\sum_{i=1}^k(x-a_i)-\sum_{i=1}^k(a_{k+1}-a_i)\right)+B\left(\sum_{i=k+1}^n(a_i-x)-\sum_{i=k+2}^n(a_i-a_{k+1})\right)$$
$$=A\left(kx-\sum_{i=1}^k a_i-ka_{k+1}+\sum_{i=1}^k a_i\right)+B\left(\sum_{i=k+1}^na_i-(n-k)x-\sum_{i=k+2}^na_i+(n-k-1)a_{k+1} \right)$$
$$=A\left(kx-ka_{k+1}\right)+B\left(a_{k+1}-(n-k)x+(n-k-1)a_{k+1}\right)$$
$$=Ak(x-a_{k+1})+B\left(a_{k+1}-(n-k)x+(n-k-1)a_{k+1}\right)$$
$$=Ak(x-a_{k+1})+B\left(na_{k+1}-(n-k)x-a_{k+1}\right)$$
$$=Ak(x-a_{k+1})+B(n-k)(a_{k+1}-x)$$
$$=(kA-(n-k)B)(x-a_{k+1})$$
从上述推导中，我们可以看到：
$$C(x)-C(a_k)=(kA-(n-k)B)(x-a_k)$$
$$C(x)-C(a_{k+1})=(kA-(n-k)B)(x-a_{k+1})$$
由于 $x$ 位于 $a_k$ 和 $a_{k+1}$ 之间，即 $a_k<x<a_{k+1}$，我们可以得出以下结论：
- 如果 $kA\geq(n-k)B$，则 $C(x)-C(a_k)\geq0$，即 $C(x)\geq C(a_k)$。
- 如果 $kA<(n-k)B$，则 $C(x)-C(a_{k+1})\geq0$ ，即 $C(x)\geq C(a_{k+1})$。
因此，无论哪种情况，$C(x)$ 一定大于或等于 $C(a_k)$ 或 $C(a_{k+1})$ 中的某一个。

确定了目标产品规格一定在数组中的某一个之后，我们枚举数组中的所有数字，找出答案。

首先对所有产品的规格进行排序，这样可以方便地计算出调整到每个规格的代价。

然后从前往后扫描，计算每个数字当做目标规格时的代价，然后直接找最小值即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll a[100005];
int main() {
	ll n,A,B;
	cin>>n>>A>>B;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	ll sum=0;
	for(int i=2; i<=n; i++)
		sum+=(a[i]-a[1])*B;
	ll minx=sum;
	for(int i=2; i<=n; i++) {
		sum+=(i-1)*(a[i]-a[i-1])*A;
		sum-=(n+1-i)*(a[i]-a[i-1])*B;
		minx=min(minx,sum);
	}
	cout<<minx;
	return 0;
}

```

---


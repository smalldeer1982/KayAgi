# [CSP-X2024 山东] 刷题

## 题目描述

比赛之路多艰，做题方得提升。努力刷题的人在比赛中往往能取得很好的成绩，小红就是这样的人。

为了继续提升自己的编程实力，小红整理了一份刷题题单，并选中了题单中的 $n$ 道编程题，将它们从 $1$ 到 $n$ 编号，计划用 $m$ 天时间按照题目编号顺序做完所有的题目（一道题目只能在同一天完成，不可以使用多天完成同一道题目）。

在小红的计划中，她完成第 $i$ 道题目的时间为 $a_i$。因为题目有难有易，小红做题时可以找好朋友小明帮忙解题，通过询问小明一道题目的解法，可以省去这个题目的做题时间。当然了，小红做题是为了提升自己，而不是提升小明。因此小红决定一天最多求助小明一次。

本题 $m$ 天中，小红做题时间最长一天的总耗时定义为 $T$（小明帮忙做的题目不计入小红的做题总时间）。请你帮小红求出 $T$ 的最小值是多少？

## 说明/提示

对于 $30\%$ 的数据，满足 $1 \leq n \leq 10^3$。

对于 $60\%$ 的数据，满足 $1 \leq n \leq 10^4$。

对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^5,0 \leq a_i \leq 10^4,1 \leq m \leq 1000$。

## 样例 #1

### 输入

```
4 2
1 2 3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 4
999 999 999```

### 输出

```
0```

# 题解

## 作者：lam_dyr (赞：5)

# B4107 \[CSP-X2024 山东] 刷题

注意到答案有单调性，考虑二分答案，二分做题时间。

check 函数思路：

先求出目前的最大值，贪心的给小明做最难的题，如果超出了做题的最大值，这一天就不做了，如果其中一天做完了，就返回 $1$，否则返回 $0$。

update on 2025.7.7 修改了 mid 的计算错误。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, m;
int a[N];
// 检查在给定的时间限制下是否可以完成任务
bool check(int x) {
    // 表示已经使用的天数
    int c = 1;
    // 表示当前任务的索引
    int s = 1;
    // 循环直到所有任务都被分配
    while (s <= n) {
        // 初始化变量t，表示当前天的总耗时
        int t = 0;
        // 初始化变量mx，表示当前天的最大耗时
        int mx = 0;
        // 循环直到当前天的总耗时超过给定的时间限制或所有任务都被分配
        int i;
        for (i = s; i <= n; i++) {
            // 更新当前天的最大耗时
            mx = max(mx, a[i]);
            // 检查是否可以将当前任务分配到当前天
            if (t + a[i] - mx <= x) {
                // 如果可以，将当前任务分配到当前天
                t += a[i];
            } else {
                // 如果不能，跳出循环
                break;
            }
        }
        // 更新当前任务的索引
        s = i;
        // 如果所有任务都被分配，跳出循环
        if (s > n) break;
        // 增加已经使用的天数
        c++;
    }
    // 检查是否可以在给定的天数内完成任务
    return c <= m;
}
int main() {
	// 好习惯 
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    int l = 0, r = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        r += a[i];
    }
    // 初始化变量ans，表示最小的最大耗时
    int ans = r;
    // 循环直到找到最小的最大耗时
    while (l <= r) {
        // 计算中间值
        int mid = l + (r - l) / 2;// 好习惯 
        // 检查是否可以在中间值的时间限制下完成任务
        if (check(mid)) {
            // 如果可以，更新最小的最大耗时和时间限制的范围
            ans = mid;
            r = mid - 1;
        } else {
            // 如果不能，更新时间限制的范围
            l = mid + 1;
        }
    }
    // 输出最小的最大耗时
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：robin512 (赞：4)

#### 题意
给定  $n$  道题目，每道题的完成时间为 $a_i$，计划在  $m$  天内按照题目编号顺序完成。所有题目每天可以求助一次好友，好友可以帮忙完成当天耗时最长的一道题目，被帮忙完成的题目不计入当天的总耗时。

求做题时间最长的一天所耗时的最小值。
#### 思路
发现答案有单调性使用二分答案二分做题时间，检查使用贪心，将最难的给好友，如果当天时间超过最小值，就不做，如果能做完返回 true，不能返回 false。
#### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[100010]; 
bool check(int x){
	int j=1;
	for(int i=1;i<=m;i++){
		int s=0,maxn=0;
		while(j<=n){
			maxn=max(maxn,a[j]);
			if(s+a[j]-maxn>x){
				break;
			}
			s+=a[j];
			j++;
		}
		if(j>n){
			return 1;
		}
	}
	return 0;
}
signed main(){
    int l=0,r=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		r+=a[i];
	}
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)){
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	cout<<l;
	return 0;
}
```

---

## 作者：songge888 (赞：4)

### 题意

给定 $n$ 道题目，每道题的完成时间为 $a_i$，计划在 $m$ 天内按照题目编号顺序完成所有题目。每天可以求助一次好友，好友可以帮忙完成当天耗时最长的一道题目，被帮忙完成的题目不计入当天的总耗时。

求做题时间最长的一天所耗时的最小值。

### 思路

发现 $n\le 10^5$，要使用一种 $O(n \log n)$ 的算法。

求最大值最小，考虑二分+贪心。

二分做题时间最长的一天的耗时 $x$。

$l$ 初始为 $0$（理论最小值）。

$r$ 初始为所有 $a_i$ 的和（全题目加起来做一天的情况）。

假设遍历到了第 $i$ 道题，记录所选题目区间的最大值 $maxn$，如果总时间 $sum$ 减去 $maxn$ 小于 $x$，说明今天不能再做题了，下一天从第 $i$ 道题开始做，当做完所有题后，如果天数大于 $m$，则说明 $x$ 要增加，否则反之。

以样例为例：

```
1 2 3 3
```

一开始 $l=0,r=9,mid=4$。

前 $3$ 题 $sum=6,maxn=3$，$sum-maxn<mid$。

第 $4$ 题下一天做，这是合法的。

然后 $l=0,r=3,mid=1$。

这样不合法。

再然后 $l=2,r=3,mid=2$。

同样不合法。

最后 $l=r=3$，输出 $3$，结束。

### Code

```c++
#include<bits/stdc++.h>
#define bug cout<<"songge888"<<'\n';
#define int long long
using namespace std;
int n,m,a[100010]; 
int l,r,ret;
bool check(int x){
	int num=1;
	int sum=0;
	int maxn=0;
	for(int i=1;i<=n;i++){
		maxn=max(maxn,a[i]);
		if(sum+a[i]-maxn<=x){
			sum+=a[i];
		}
		else{
			num++;
			sum=a[i];
			maxn=a[i];
		}
	}
	return (num<=m);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	r+=a[i];
	}
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)){
			ret=mid;
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	cout<<ret;
	return 0;
}


```

---

## 作者：RenZhen1 (赞：2)

题目可以采用二分答案的做法。

首先，按照耗时最长一天的总耗时 $T$ 来拆分组，如果 $T$ 越大，那么拆分的组数就会越少，运用这样一个单调性，我们使用二分查找来确定 $T$ 的最小值。对于每个中间值 $mid$，我们检查是否可以在 $m$ 天内完成所有题目，且每天的做题时间不超过 $mid$。

当然，在确定分多少组的时候，需要用到贪心的思想，从前往后扫描数组，尽量按照能分到一组的情况下就分到一组的原则来分配，这样划分的组数是最少的。

```cpp
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], n, m;
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    int left = 0, right = 1e9;
    while (left < right)
    {
        int mid = left + right >> 1;
        int cnt = 1, maxx = 0, sum = 0;
        for (int i = 1; i <= n; i ++)
        {
            maxx = max (maxx, a[i]);
            if (sum + a[i] - maxx <= mid)
            {
                sum += a[i];
            }
            else
            {
                cnt ++;
                sum = a[i];
                maxx = a[i];
            }
        }
        if (cnt <= m)
        {
            right = mid;
        }
        else
        {
            left = mid + 1;
        }
    }
    cout << left << endl;
    return 0;
}
```

---

## 作者：SuyctidohanQ (赞：1)

### 前言

作为一名打过 CSP-X 的学生，我要说，CSP-X 的题目看上去很难，实际上一点也不简单。

### 思路分析

考虑二分答案。

先求出目前的最大值，贪心的给小明做最难的题，如果超出了做题的最大值，这一天就不做了，如果其中一天做完了，就返回 $1$，否则返回 $0$。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
int n, m, a[MAXN];
bool check (int x) {
    int c = 1, s = 1;
    while (s <= n) {
        int t = 0, maxx = 0, i;
        for (i = s; i <= n; i ++) {
            maxx = max (maxx, a[i]);
            if (t + a[i] - maxx <= x) t += a[i];
			else break;
        }
        s = i;
        if (s > n) break;
        c ++;
    }
    return c <= m;
}
int main () {
    cin >> n >> m;
    int l = 0, r = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        r += a[i];
    }
    int ans = r;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check (mid)) {
            ans = mid;
            r = mid - 1;
        } 
		else l = mid + 1;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：yyycj (赞：1)

## 题目简述
小红有 $n$ 道编程题，每到编程题需要的时间为 $a_{i}$。她要在 $m$ 天内**按顺序**做完所有题目，**不能用多天完成同一道题**。每天她还可以求助小明 $1$ 道题，求助的这道题省去做题时间。

求她在 $m$ 天内最长做题时间的最小值.

## 主要思路
首先注意到一种情况：如果 $n \le m$ 也就是题目数小于规定天数，那么她就可以在任意 $n$ 天每天都问 $1$ 道题，这样答案就为 $0$。

### 采用算法
暴力搜肯定是想多了，$n \le 10^{5}$。于是可以采用二分答案的算法，时间复杂度 $O(n \log n)$。

一开始设定变量 $l$ 和 $r$，然后每次取中间值，判断这个值是否能成为答案，不断压缩区间，最后一个满足条件的值即为答案就是二分答案的思路。

$l$ 直接取 $0$ 即可；由于答案最大也不会超过做题时间总和，所以 $r$ 取 $\sum_{i=1}^{n}a$。

### 判断是否能成为答案
记录一个 $cnt$ 变量，一开始设为 $1$，用于表示现在是第几天；再记录一个 $sum$ 变量，一开始设为 $0$，用于表示当天的做题时间和；还要记录一个 $maxn$ 变量，一开始设为 $0$，用于表示当天最长做题时间。

遍历 $a_{1} \sim a_{n}$，判断 $sum - maxn + a_{i}$ 是否大于 $mid$。由于答案要求最小，所以一定要问做题时间最长的题在代码中表现出来就是减 $maxn$。

如果大于，则开始下一天，将 $cnt$ 自增 $1$，$sum$ 和 $maxn$ 设为 $a_{i}$；否则，只将 $sum$ 加上 $a_{i}$ 即可。

## AC Code
```cpp
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

#define endl '\n'
typedef long long ll;
const int N = 1e5 + 10;
typedef unsigned int ui;
typedef pair<ll,ll> pll;
typedef pair<int,int> pii;
const double PI = acos(-1.0);
typedef unsigned long long ull;
// ----------------------------

// ----------------------------
int a[N];
// ----------------------------
inline int read() {
	int f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch=getchar();}
	return sum*f;
}

void print(int x) {
	if(x<0){putchar('-');x=-x;}
	if(x>9){print(x/10);}
	putchar(char(x%10+'0'));
}

bool check(int n,int m,int x) {
	int cnt = 1;
	int sum = 0;
	int maxn = 0;
	for (int i=1;i<=n;i++) {
		maxn = max(maxn,a[i]);
		if (sum-maxn+a[i] > x) {
			cnt++;
			sum = a[i];
			maxn = a[i];
		}
		else sum += a[i];
	}
	return cnt <= m;
}

int _find(int n,int m,int r) {
	int l = 0;
	int ans = 0;
	while (l <= r) {
		int mid = (l+r) / 2;
		if (check(n,m,mid)) {
			ans = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	return ans;
}

int main() {
	int r = 0;
	int n = read();
	int m = read();
	if (n <= m) {
		print(0);
		return 0;
	}
	for (int i=1;i<=n;i++) {
		a[i] = read();
		r += a[i];
	}
	// ------------------------
	print(_find(n,m,r));
	return 0;
}
```

## 后言
本人山东省小学生，有幸参加了 CSP-X2024，这道题在赛场看+想 $15$ 分钟左右，代码 $25$ 分钟左右，最后成功 AC，我甚至觉得挺简单。但是上半场 B 题只拿了 $55$ 就很蒻。

---

## 作者：FJ_EYoungOneC (赞：1)

### 解题思路

本题要求解最小的 $T$，观察题目发现，时间越短越难完成，时间越长越容易完成，具有单调性。

假设当 $T=x$ 时，恰好完成所有任务，那么当 $T>x$ 时，一定也可以完成任务，且当 $T<x$ 时，一定完不成任务，具有单调性，可以使用**二分**算法。

综上本题可以二分答案 $T$，那么我们考虑一下如何完成二分所需的 `check` 函数。

我们需要检测当 $T = x$ 时，需要多少天可以完成所有任务，若天数不大于 $m$，则表示可以在 $m$ 天内完成，反之无法完成。

在计算需要多少天可以完成任务时，可以向小明提出帮助，并且小明帮忙做的题目不计入小红的做题总时间，那么根据贪心的策略，我们肯定选择耗时最长的一道题目，所以需要在处理的过程中维护一个最大值，表示耗时最长的题目。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int w[N];

bool check(int x)
{
    int cnt = 1, s = 0, mx = 0;
    for (int i = 1; i <= n; ++ i )
    {
        s += w[i];
        mx = max(mx, w[i]);
        if (s - mx > x)
        {
            s = mx = w[i];
            cnt ++;
        }
    }
    
    return cnt <= m;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i )
        cin >> w[i];
    
    if (m >= n)
    {
        puts("0");
        return 0;
    }
    
    int l = 1, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid))
            r = mid;
        else
            l = mid + 1;
    }
    
    cout << l << endl;
    
    return 0;
}
```

---


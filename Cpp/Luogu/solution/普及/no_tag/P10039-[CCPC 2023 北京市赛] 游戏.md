# [CCPC 2023 北京市赛] 游戏

## 题目描述

小 I 和小 J 又在玩游戏。

小 J 找来了一棵 $n$ 个点的树。树上的每条边有开启和关闭两个状态，初始树上每条边都是开启的。

初始树上有一颗棋子放在 $1$ 号节点。小 I 可以移动棋子，目标是将棋子移动到一个度数**恰好**为 $1$ 的节点上；小 J 可以关闭树上的边，目标是阻止小 I 将棋子移动到度数恰好为 $1$ 的节点上。

游戏分为若干轮，每轮有如下环节：

1. 小 I 任务判定：如果棋子在度数恰好为 $1$ 的节点上，小 I 获胜，否则进入第 2 步；
2. 小 J 行动：小 J 将一条目前开启的边，将这条边永久关闭，进入第 3 步，如果目前不存在开启的边则直接跳过行动进入第 3 步；
3. 小 I 行动：小 I 选择一条连接当前棋子所在节点且开启的边，将棋子移动到这条边的另一个节点上。如果没有这样的边，小 J 获胜，否则进入新的一轮，回到第 1 步。

小 J 想知道，如果小 I 和小 J 知道这棵树的形态且绝顶聪明，谁会获胜。

## 说明/提示

【样例解释 1】

小 J 的策略如下：

- 小 J 将 $(1,2)$ 关闭，这样小 I 只能移动到 $5$；
- 小 J 将 $(5,6)$ 关闭，这样小 I 只得移动回 $1$；
- 小 J 将 $(1,5)$ 关闭，于是小 I 无法移动。

## 样例 #1

### 输入

```
6
1 2
2 3
2 4
1 5
5 6```

### 输出

```
Wasted.```

## 样例 #2

### 输入

```
7
1 2
2 3
2 4
1 5
5 6
5 7```

### 输出

```
You win, temporarily.```

# 题解

## 作者：Loser_Syx (赞：2)

考虑小 I 获胜的情况，对于当前节点 $i$，如果可以令小 $i$ 获胜的方案不止 $1$ 种，那么小 J 就算封锁通道也不能使小 I 无法获胜了，此时小 I 到这个节点时必胜，除了令初始时的叶子节点可以获胜外，这个节点 $i$ 我们也认为可以获胜。

如果最后认为节点 $1$ 也是必胜节点的话，那么小 I 就有赢的方案。

```cpp
vector<int> g[100005];
int dfs(int u, int fa){
	if (g[u].size() == 1) return 1;
	int cnt = 0;
	for (const int i : g[u]){
		if (i == fa) continue;
		cnt += dfs(i, u);
	}
	return cnt >= 2;
}
signed main() {
	int n = read();
	for (int i = 1, u, v; i < n; i++) {
		read(u, v);
		g[u].emplace_back(v);
		g[v].emplace_back(u);
	}
	puts(dfs(1, -1) ? "You win, temporarily." : "Wasted.");
	return 0;
}
```

---

## 作者：__Cby___ (赞：2)

##  思路
### 学术版
很明显，若最终能在叶子节点小 $I$ 就可以获胜（废话？）。  
那怎么办呢，很明显，当以一个点的子节点为根的子树若超过两棵可以满足题目的要求，那这个以这个点为根的子树也能满足要求。正确性显然，因为你堵哪边都有路可走。  
特别的，若一个点的子节点为**叶子节点**，那么认为这个叶子节点构成的树也满足要求。同时，若根节点本身就出度为 $1$ ，那么直接认为满足要求。   
### 通俗版
若堵住这个点通往其子节点的一条边，从这个点往下仍可以到达叶子节点，则该点满足要求。
## 代码 
其他解释都在代码里了：  
```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int> g[100025];
int dfs(int u,int fa){
	if(g[u].size()==1)return 1;//特判
	if(g[u].size()==2&&u!=1)return 0;
        //剪枝，若一个点的子节点只有一个，很明显不满足要求
        //因为可以把连接那个子节点的边堵住
	int cnt=0;
	for(auto v:g[u]){
		if(v==fa)continue;//父亲节点不算
		cnt+=dfs(v,u);
	}
	return cnt>=2;//看看这颗以u为节点的子树是否满足要求
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n-1;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
        //经典建图
	if(dfs(1,-1)){
		label:cout<<"You win, temporarily."<<endl;
	}
	else{
		cout<<"Wasted."<<endl;
	}
	return 0;
}
```


---

## 作者：him的自我修养 (赞：2)

~~开创历史！~~

首先，我们可以根据题意画出一个树，因为走到任何一个叶子节点都可以。

所以，我们首先考虑只有一个节点的树，发现必然可行，因为在判断任务时就是对的。接下来，我们考虑有一颗有两层的树，设其根为 $u$，那么只要 $u$ 有两个子节点就必然可行。

再推广到 $k$ 层，我们假设有一个布尔类型的数组 $vis$，其中 $vis_i$ 代表以 $i$ 为根的子树是谁获胜。那么显然有只要 $u$ 的子节点中有两个或以上的节点是 $vis_{son_{k}}=1$，那么 $vis_u=1$。

## code

```
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
vector<int> g[N];
int cnt[N],n,u,v;
void dfs(int x,int fa){
	if(g[x].size()==1){
		cnt[x]=1;
		return ;
	}
	for(auto v:g[x]){
		if(v==fa) continue;
		dfs(v,x);
		cnt[x]+=cnt[v];
	}
	cnt[x]=(cnt[x]>=2);
	return ;
}
int main(){
	cin >>n;
	for(int i=1;i<n;i++){
		cin >>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,-114514);
	cout <<(cnt[1]?"You win, temporarily.":"Wasted.");
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

题意：

给你 $n$ 条无向边，你需要找到至少两条通往同一个子节点的路（没有儿子但有爸爸）。

思路：

不难想到深搜。我们可以一直搜，到达子节点就说明这是一种方案，并返回。当这个点的方案数是大于等于 $2$ 了，说明走这个点是可行的，并返回。以此类推……

~~有点抽象对吧，我结合着代码讲。~~

***Code***
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define R register
#define re ra()
	
const int N = 1e5 + 100;

inline int ra()
{
    int jjy = 0,txy = 1;
    char ch = getchar();
    while(!isdigit(ch)){if(ch == '-') txy = -1; ch = getchar(); }
    while(isdigit(ch)){jjy = jjy * 10 + ch - '0'; ch  getchar(); }

    return jjy * txy;
}

struct setyid
{
	int next, to, len;
} egth[N * 4];

int panda[N], head[N], cnt, n;

inline void add(int a, int b, int c)
{
	egth[++ cnt] = (setyid) {head[a], b, c};
	head[a] = cnt;
}

inline int sous(int x, int y)
{
	//if(egth[x].to == 0) return 0;
	if(panda[x] == 1) return 1; //子节点 
	int ans = 0;
	for(int i = head[x]; i; i = egth[i].next)
	{
		if(egth[i].to == y) continue; //如果下个要搜的点刚刚搜过，就没必要再搜了
		ans += sous(egth[i].to, x);//ans存的是方案数
	}
//	cout << ans << endl;
	if(ans > 1) //方案数在2及以上这个点才是能走的，算是一种方案
	return 1;
	else 
	return 0;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n = re;
	for(int i = 1; i < n; i ++)
	{
		int a, b;
		a = re, b = re;
		panda[a] ++, panda[b] ++; //用一个桶来存，如果panda[x]为1，说明他没有儿子，就是子节点
		add(a, b, 0); //链式存向星建边
		add(b, a, 0);
	}
		
	if(sous(1, 0) > 0) cout << "You win, temporarily.";//方案数有一种及以上
	else cout << "Wasted.";
	return 0;
}
	
	

```

---

## 作者：TangyixiaoQAQ (赞：0)

### 样例分析

  显然，在样例一中，小 J 对于以 $1$ 为根的树，加以 $(1,2)$ 的处理后，对于 $(1,5)$ 与 $ (5,6) $ 的关闭，只剩下了右子树。因为在该子树中只有 $1$ 个节点 $5$ 的度为 $1$ 。故其获胜。

![](https://i.072333.xyz/file/7b540c908e04738299f56.png)


然而，在样例二中，小 I 因为有两个度为 $1$ 的点，所以无论关闭哪一条，都会有一个度为 $1$ 的点出现。故其获胜。

![](https://i.072333.xyz/file/d36902f000ae7065c769c.png)

#### 推演

那么对于第 $i$ 个节点

- 当 $i$ 的度数为 $1$ 时，不可行
- 在其所有子树中，只有 $1$ 个度为 $1$ 的节点，不可行
- 在其所有子树中，有 $2$ 个度为 $1$ 的节点，可行
- 在其所有子树中，有 $3$ 个度为 $1$ 的节点，可行
- ·······

### 结论

当树的第  $i$  个节点有 $\ge 2$ 个度为 $1$ 的节点时，那么这个节点 $i$ 就是可行的。

### 做法

我们可以用标记数组来表示当前点拥有的度数为 $1$ 的点的个数。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 114514;

int U,V,n,cnt[N]; 
vector<int> v[N];

//输入 
inline void input() {
	cin>>n;
	for(int i=1;i<=n-1;i++){
		cin>>U>>V;
		v[U].push_back(V);
		v[V].push_back(U);
	}
	return;
}

//输出 
inline void output() {
	if(cnt[1]){
		cout<<"You win, temporarily.";
	}
	else{
		cout<<"Wasted.";
	}
	return;
}

//遍历树 
inline void dfs(int x,int dad) {
	if(v[x].size()==1){
		cnt[x]=1;
		return;
	} 
	for(auto i:v[x]){
		if(i!=dad){
			dfs(i,x);
			cnt[x]+=cnt[i];//继承度为 1 的点的个数 
		}
	}
	//度数清零 
	if(cnt[x]>=2){
		cnt[x]=1;
	}
	else{
		cnt[x]=0;
	}

	return;
}

inline void solve() {
	input();
	dfs(1,-N);
	output();
	return;
}

int main(){
	//加快cin、cout速度 
	ios::sync_with_stdio(false);
	cin.tie(0);

	solve();
	return 0;
}
```

---

## 作者：Empty_Dream (赞：0)

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P10039)


## 分析

先看题目，小 I 要求度为 $1$，即走到了叶子节点上，而封锁操作相当于小 I 的方案减少这颗子树可能的方案。

第一眼像贪心，每次封锁操作去封锁方案数最多的那颗子树。

细想后发现，非常简单：考虑**不可能**的情况，如果这个点只有一个子节点，那么一定不行。更进一步，如果只有一颗子树满足要求，那么也不行；因为是封路在先，所以只要一个节点只有一个子节点，那么会被直接封上，这一个点不能。

反面来说，只要这个点有两个及以上个子树满足，那么这个点就满足要求。不难想到这是一个递归，如果每一层（除了叶子节点）都有两个及以上的子树满足，那么根节点也满足，小 I 胜。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<int> g[100005];

int dfs(int u, int fa){
	if (g[u].size() == 1) return 1;//叶子节点一定满足
	if (g[u].size() == 2 && u != 1) return 0;//只有一个子节点
	int cnt = 0;
	for (int i = 0; i < g[u].size(); i++){
		int v = g[u][i];
		if (v == fa) continue;
		cnt += dfs(v, u);//记录满足条件子树个数
	}
	return cnt >= 2;//是否有2个及以上的子树满足
}

signed main(){
	cin >> n;
	for (int i = 1, u, v; i < n; i++){
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	if (dfs(1, 114514)) cout << "You win, temporarily.";//根节点也有两个及以上的子树满足
	else cout << "Wasted.";
	return 0;
}
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

# P10039 [CCPC 2023 北京市赛] 游戏 题解

## Sol

我们知道，小 I 最终在叶子节点才能获胜。我们可以发现，如果当前结点为的子树个数 $\ge 2$ 则可以满足要求。因为不管小 J 关闭哪条边，总有路可走。还有，如果一个点的子节点为叶子节点，那么也满足要求。

直接深搜即可。当然，我们可以剪枝，如果一个点的子节点个数 $=1$，不满足要求，直接返回 `false`。

可以用 `vector` 存边。

## Code

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <queue>

using namespace std;

using ll = long long;

const int kMaxN = 1e5 + 10, kInf = (((1 << 30) - 1) << 1) + 1;
const ll kLInf = 9.22e18;

int n;
vector<int> e[kMaxN]; // 存边

void AddEdge(int x, int y) {
	e[x].push_back(y);
	e[y].push_back(x);
}

bool Dfs(int x, int f) {	
	if (e[x].size() == 2 && x != 1)  { // 注意，不能为根节点
	  return 0;
	}
	if (e[x].size() == 1) { // 特判
		return 1;
	}
  int cur = 0;
	for (int i = 0; i < e[x].size(); ++ i) { // 向 x 的边搜索
		if (e[x][i] == f) { // 不能为父亲
			continue;
		}
		cur += Dfs(e[x][i], x);
	}
	return (cur >= 2);
}

int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
	for (int i = 1, x, y; i < n; ++ i) {
    cin >> x >> y;
		AddEdge(x, y); // 加一条 x->y 的边
	}
	bool ans = Dfs(1, -1); // 搜索
	cout << (ans? "You win, temporarily." : "Wasted.") << '\n';
	return 0;
}
```

---

## 作者：MrSWdAxiv (赞：0)

## 思路

首先这道题肯定需要遍历树，所以我们用邻接表存树。

理解一下题目，小 I 只有在走到叶子节点时才能获胜，那么这棵树可以考虑以下几种情况：

- 只有一个节点，显然小 I 直接获胜。
- 有两层但只有一个叶子节点，那么无法获胜。
- 有两层但有两个叶子节点，能获胜。

- 以此类推，当有 $n$ 层时，考虑小 I 在每个点是否获胜，如果删去这个点通往其子节点的路径，它还能到达叶子节点，那么这个点能获胜，否则不能。

这样的话，我们就可以用深搜来遍历这棵树，依次算节点能否获胜即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAX 100005
using namespace std;
struct Edge{
    int v,next;
}edge[MAX*2];
int cnt,head[MAX],ans[MAX],len;
void add(int u,int v){//邻接表
    edge[++cnt].v=v;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
int n;
void dfs(int u,int fa){
    int len=0;
    for(int i=head[u];i;i=edge[i].next){
        len++;
    }
    if(len==1){//若一棵树只有一层，显然可以
        ans[u]=1;
        return ;
    }
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].v;
        if(v==fa)continue;
        dfs(v,u);
        ans[u]+=ans[v];
    }
    ans[u]=ans[u]>=2;
    return;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    int u,v;
    for(int i=1;i<=n-1;i++){
        cin>>u>>v;
        add(u,v);//建树，注意要建双向边
        add(v,u);
    }
    dfs(1,-1);
    if(ans[1]){
        cout<<"You win, temporarily.\n";
    }else{
        cout<<"Wasted.\n";
    }
    return 0;
}
```


---


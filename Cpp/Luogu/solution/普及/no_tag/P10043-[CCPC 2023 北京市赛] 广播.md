# [CCPC 2023 北京市赛] 广播

## 题目描述

小 I 正在学习使用 Pytorch。这是一个非常热门的用于机器学习训练的 Python 库。

小 I 注意到，Pytorch 中对于张量运算有称作“广播”(broadcast)的机制。你可以认为张量是高维数组。对于一个 $k$ 维张量 $A$，我们用长度为 $k$ 的序列 $(a_1,a_2,\cdots,a_k)$ 表示其各个维度的长度，也就是说 $A$ 是一个 $a_1 \times a_2 \times \cdots \times a_k$ 的张量。

对于两个张量 $A$ 和 $B$，设它们的维度分别为 $(a_1,a_2,\cdots,a_m)$ 和 $(b_1,b_2,\cdots,b_n)$，称 $A$ 和 $B$ 是 **可广播的**，当且仅当以下性质成立：

- 对于任意整数 $0 \le i \le \min(n,m) - 1$，要么 $a_{m-i} = b_{n-i}$，要么 $a_{m-i}$ 和 $b_{n-i}$ 中至少有一个是 $1$。

现在小 I 有两个张量，它们的维度分别是 $(p_1,p_2,\cdots,p_m)$ 和 $(q_1,q_2,\cdots,q_n)$，它们不一定是可广播的。

为此，小 I 可以使用 Pytorch 内置的函数进行若干次操作（可以不做操作），每次操作对序列 $p$ 或 $q$ 进行以下修改：

- 选择 $p$ 或 $q$，在选定序列的任意一个位置插入一个 $1$。

小 I 想知道他最少要多少次操作才能让两个张量变为可广播的。

## 说明/提示

在序列 $q$ 的第二个位置之前插入一个 $1$（得到 `4 1 2`），两个张量就会变为可广播的。

## 样例 #1

### 输入

```
4 2
2 1 3 2
4 2```

### 输出

```
1```

# 题解

## 作者：Sparse_Table (赞：5)

欢迎来我的[博客](https://www.cnblogs.com/0x3f3f3f3f3f3f/p/18324687)玩。


[题目传送门](https://www.luogu.com.cn/problem/P10043)


这道题是一个标准的 dp 了，只不过它要倒序来做。


还是分三步。


1. 初值：初值想必都知道吧，若要求最小值，就把初值设成无穷大，$dp_{0,i}$ 和 $dp_{i,0}$ 都要设成 $i$，$dp_{0,0}$ 一定要赋值成 $0$，这是本人亲自犯过的错误QwQ。


1. 状态：$dp_{i,j}$ 表示 $a$ 数组的前 $i$ 个，$b$ 数组的前 $j$ 个变成可以广播的情况需要最小的操作次数。


1. 答案：只要有一个走到头时说明这种情况已经解决完毕，当 $i$ 是 $n$ 或者 $j$ 是 $m$ 时取最小值。


千万要把 $dp_{0,m}$，$dp_{n,0}$ 算上QwQ。


话不多说，直接上代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[2010], b[2010];
int dp[2010][2010];

int main() 
{
	memset(dp,0x3f,sizeof dp);
	cin >> n >> m;
	dp[0][0] = 0;
	for (int i = n; i >= 1; i--)
	{
		cin >> a[i];
		dp[i][0] = i;
	}
	for (int i = m; i >= 1; i--)
	{
		cin >> b[i];
		dp[0][i] = i;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if(a[i] == b[j] || a[i] == 1 || b[j] == 1) dp[i][j] = min({dp[i - 1][j - 1],dp[i][j - 1] + 1,dp[i - 1][j] + 1});
			else dp[i][j] = min(dp[i - 1][j] + 1,dp[i][j - 1] + 1);
	int ans = 0x3f3f3f3f;
	for (int i = 0; i <= m; i++) ans = min(dp[n][i],ans);
	for (int i = 0; i <= n; i++) ans = min(dp[i][m],ans);
	cout << ans;
    return 0;
}
```
有兴趣的童鞋们可以挑战一下 [编辑距离](https://www.luogu.com.cn/problem/P2758)

---

## 作者：stripe_python (赞：4)

很简单的线性 DP。和 [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758) 很像。

看到 $n,m \le 2000$，显然复杂度为 $O(nm)$。题意是倒序匹配的，为了方便，对 $a,b$ 作翻转。

令 $dp_{i,j}$ 表示将 $a$ 的前 $i$ 个和 $b$ 的前 $j$ 个匹配的最小操作次数。三种转移：

1. 当 $a_i=b_j$ 或 $a_i=1$ 或 $b_j=1$ 时，可以不插入 $1$，从 $dp_{i-1,j-1}$ 转移；
2. 在 $a_i$ 处插入，从 $dp_{i-1,j}+1$ 转移；
3. 在 $b_j$ 处插入，从 $dp_{i,j-1}+1$ 转移。

考虑边界条件。匹配 $a$ 的前 $i$ 个和空的 $b$，插入$i$ 个 $1$ 即可。则 $dp_{i,0}=i$，同理 $dp_{0,i}=i$。

答案统计时，将 $a$ 的所有 $n$ 个或者 $b$ 的所有 $m$ 个匹配时符合要求。

```cpp
#include <bits/stdc++.h>
#define N 2005
using namespace std;

int n, m, a[N], b[N], dp[N][N];

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i];
	reverse(a + 1, a + n + 1), reverse(b + 1, b + m + 1);
	
	memset(dp, 0x3f, sizeof(dp));
	for (int i = 0; i <= n; i++) dp[i][0] = i;
	for (int i = 0; i <= m; i++) dp[0][i] = i;
	
	int res = min(n, m);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (a[i] == b[j] || a[i] == 1 || b[j] == 1) dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
			dp[i][j] = min(dp[i][j], min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
			if (i == n || j == m) res = min(res, dp[i][j]);
		}
	}
	cout << res;
	return 0;
}
```

---

## 作者：heyZZZ (赞：2)

线性 DP。

不难想到 $dp_{i,j}$ 代表在 $a$ 中前 $i$ 个数和 $b$ 中前 $j$ 个数满足要求。

状态转移方程是：

边界：

1. 如果 $i=m$，$dp_{i,j+1}=\min\{dp_{i,j}\}$。
2. 如果 $j=n$，$dp_{i+1,j}=\min\{dp_{i,j}\}$。

之后：

1. $a_{i+1}=b_{j+1}$ 或者 $a_{i+1}=1$ 或者 $b_{j+1}=1$，$dp_{i+1,j+1}=\min\{dp_{i,j}\}$。

最后 $dp_{i+1,j}=\min\{dp_{i,j}+1\},dp_{i,j+1}=\min\{dp_{i,j}+1\}$。

代码楼上楼下都已经写的很明白了，我就不在赘述了。

---

## 作者：__Sky__Dream__ (赞：2)

## **题意**
很简单：给定两个数组，求最少更改次数。

因为数据大小 $(1≤m,n≤2000)$，所以 $O(n^2)$ 的时间复杂度可以过。

## **思路**

根据题意：
- 对于任意整数 $0≤i≤\min(n,m)-1$，要么 $a_{m-i}=b_{n-i}$，要么 $a_{m-i}$ 和 $b_{n-i}$ 中至少有一个是 $1$。

由此我们可以得出（以我的代码为例，见下）：

1. 在 $a_i=b_j$ 或 $a_i=1$ 或 $b_j=1$ 时， $dp_{i,j}=\min(dp_{i,j},dp_{i-1,j-1})$。
1. 在 $i=m$ 时，有 $dp_{i,j}=\min(dp_{i,j},dp_{i-1,j}+1)$。
1. 在 $j=n$ 时，有 $dp_{i,j}=\min(dp_{i,j},dp_{i,j-1}+1)$。

据此，我们就可以完成题目了！

## AC Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX=2000;
const int INF=1e9;
int n,m;
int p[MAX+50];
int q[MAX+50];
int dp[MAX+50][MAX+50];
int main()
{
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>p[i];
	for(int j=1;j<=m;j++) cin>>q[j];
	reverse(p+1,p+n+1);
	reverse(q+1,q+m+1);
	int ans=min(n,m);
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			dp[i][j]=i+j;
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			dp[i][j]=INF;
			if(p[i]==q[j]||p[i]==1||q[j]==1) dp[i][j]=min(dp[i][j],dp[i-1][j-1]);
			dp[i][j]=min(dp[i][j],dp[i-1][j]+1);
			dp[i][j]=min(dp[i][j],dp[i][j-1]+1);
			if(i==n||j==m) ans=min(ans,dp[i][j]);
		}
	}
	cout<<ans;		
	return 0;
}
```

---

## 作者：him的自我修养 (赞：1)

~~开创历史！~~

题目看着很唬人啊。（雾）

题意：

给定数组 $a$ 和数组 $b$，求最少修改多少个数，是的对于任意 $0 \le i \le \min(n,m)-1$，要么 $a_{m-1}=b_{n-1}$，要么在 $a_{m-i}$ 和 $b_{n-i}$ 之中，至少有一个的值为 $1$。

分析数据，$1 \le m,n \le 2000$。所以一眼丁真为 $O(n^2)$ 的时间复杂度与空间复杂度。

所以，可以设计 $dp_{i,j}$ 代表在 $a$ 中前 $i$ 个数和 $b$ 中前 $j$ 个数满足题目要求。

那么，我们就可以列出一下转移式：

1.在 $i=m$ 时，有 $dp_{i,j+1}=\min(dp_{i,j+1},dp_{i,j})$。

2.在 $j=n$ 时，有 $dp_{i+1,j}=\min(dp_{i+1,j},dp_{i,j})$。

3.在 $a_{m-i}=b_{n-j} \wedge a_{m-i}=1 \wedge b_{n-i}=1$ 时，有 $dp_{i+1,j+1}=\min(dp_{i+1,j+1},dp_{i,j})$。

最后，有 $dp_{i+1,j}=\min(dp_{i+1,j},dp_{i,j}+1)$ 和 $dp_{i,j+1}=\min(dp_{i,j+1},dp_{i,j}+1)$。

最后，因为 $n \le 2000$，所以 $O(n^2)$ 可以通过。

## code
```
#include <bits/stdc++.h>
using namespace std;
const int N=2010;
int n,m,a[N],b[N],dp[N][N];
int main(){
	memset(dp,0x3f,sizeof(dp));
	cin >>n>>m;
	for(int i=1;i<=n;i++) cin >>a[i];
	for(int i=1;i<=m;i++) cin >>b[i];
	for(int i=1;i<=(n+1)/2;i++) swap(a[i],a[n-i+1]);
	for(int i=1;i<=(m+1)/2;i++) swap(b[i],b[m-i+1]);
	dp[0][0]=0;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			if(i==n) dp[i][j+1]=min(dp[i][j+1],dp[i][j]);
			if(j==m) dp[i+1][j]=min(dp[i+1][j],dp[i][j]);
			if(a[i+1]==b[j+1] || a[i+1]==1 || b[j+1]==1) dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]);
			dp[i+1][j]=min(dp[i+1][j],dp[i][j]+1);
			dp[i][j+1]=min(dp[i][j+1],dp[i][j]+1);
		}
	}
	cout <<dp[n][m];
	return 0;
}
```

---

## 作者：A2ure_Sky (赞：1)

这里提供一种另类的思路。

同样是线性 DP，不过我们这么想，求出最长公共子序列 $dp_{i,j}$，对于任意 $i,j$，把最长公共子序列之外的部分全部用 `1` 补上，再将没有对齐的末尾部分全部用 `1` 对齐，可以选择对齐 $m$ 或 $n$。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2010;
int m,n;
int a[N],b[N],f[N][N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin>>m>>n;
	for(int i=m;i>=1;i--) cin>>a[i];
	for(int i=n;i>=1;i--) cin>>b[i];
	
	int ans=min(m,n);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++){
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(a[i]==b[j]||a[i]==1||b[j]==1) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
			int tmp=min(m-i,n-j);
			ans=min(ans,i+j-2*f[i][j]+tmp); 
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：Reserved_ (赞：1)

# 思路：
线性 dp，我们令 $dp_{i,j}$ 表示将 $a$ 的前 $i$ 个和 $b$ 的前 $j$ 个匹配的最小操作次数。我们会发现：

当 $a_i$ 等于 $b_j$ 或 $a_i$ 等于 $1$ 或 $b_j$ 等于 $1$ 时：
- $\min(dp_{i-1,j-1},\min(dp_{i,j-1}+1,dp_{i-1,j}+1)) \to dp_{i,j}$。

否则：
- $\min(dp_{i-1,j}+1,dp_{i,j-1}+1) \to dp_{i,j}$。

最后用变量 $ans$ 判断一下最小值即可。

关键代码：

```cpp
if(a[i]==b[j]||a[i]==1||b[j]==1)
{
    dp[i][j]=min(dp[i-1][j-1],min(dp[i][j-1]+1,dp[i-1][j]+1));
}
else
{
    dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1);
}
```

---

## 作者：FamousKillerconan (赞：1)

动态规划来喽！
~~我不会告诉你我错了一次~~。
## STEP1
设状态！  
当然，这一题与编辑距离有异曲同工之妙，
所以我们可以设 $dp_{i,j}$ 为将 $a$ 的前 $i$ 个和 $b$ 的前 $j$ 个匹配的最小操作次数。（这里我们把 $a$ 数组与 $b$ 数组倒序一下，更方便一点，后面也一样）
## STEP2
推公式！
当 $a_i$ 和 $b_j$ 相等时或 $a_i=1$ 或 $b_j=1$ 时，
直接从 $dp_{i-1,j-1}$ 那转移。
如果要在 $a$ 或 $b$ 中增添一个1，
直接 $dp_{i-1,j}$ 和 $dp_{i,j-1}$ 选一个最小的 $+ 1$。
~~是不是和编辑距离的公式差不多呢？~~
## STEP3
设边界！（反正我是这么称呼的）和编辑距离差不多，这里就不做解释了。
```cpp
for(int i=0;i<=n;i++)dp[i][0]=i;
for(int i=0;i<=m;i++)dp[0][i]=i;
```  
**代码时间到！**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2005],b[2005],dp[2005][2005],ans;//题目范围2000
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	reverse(a+1,a+n+1),reverse(b+1,b+m+1);//倒序
	memset(dp,0x3f,sizeof(dp));//注意这个
	ans=min(n,m);//不加这个0分
	for(int i=0;i<=n;i++)dp[i][0]=i;
	for(int i=0;i<=m;i++)dp[0][i]=i;//边界
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i]==b[j]||a[i]==1||b[j]==1)dp[i][j]=min(dp[i][j],dp[i-1][j-1]);
			dp[i][j]=min(dp[i][j],min(dp[i-1][j],dp[i][j-1])+1);
			if(i==n||j==m)ans=min(ans,dp[i][j]);
        		//状态转移
		}
	}
	cout<<ans;
    return 0;
}//码风奇特，大佬勿喷
```
**完结撒花**

---

## 作者：zhaisx (赞：1)

### 思路

题目描述中，使长度分别为 $n,m$ 的张量 $p,q$ 广播的条件为：对于任意整数 $0 \le i \le \min(n, m) - 1$，要么 $p_{m - i} = q_{n - i}$，要么 $p_{m - i}$ 和 $q_{n - i}$ 中有一个是 $1$。那么可以先将 $p$ 和 $q$ 颠倒，再求编辑距离即可。

颠倒直接用 reverse 函数即可。

用 $f_{i,j}$ 表示颠倒后张量 $p$ 的前 $i$ 位与颠倒后张量 $q$ 的前 $j$ 位的编辑距离，也就是需要操作的次数。

首先，$f_{i,0}$ 与 $f_{0,i}$ 都应该赋值为 $i$。

其次，状态转移方程为：
+ 当 $p_i = q_j$ 或 $p_i$ 与 $q_j$ 中任意一个为 $1$ 时，$f_{i,j} = \min(f_{i - 1,j} + 1, f_{i,j - 1} + 1, f_{i - 1, j - 1}))$；
+ 否则 $f_{i,j} = \min(f_{i - 1,j} + 1, f_{i,j - 1} + 1$。

最后，循环枚举 $i$，答案取 $f_{n,i}$ 与 $f_{i,m}$ 的最小值即可。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int p[2005];
int q[2005];
int f[2005][2005];

int main() {
    memset(f, 0x7f, sizeof(f)); // 先将 f 数组设置为最大值，否则最后会输出 0。
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
      	cin >> p[i];
    for (int i = 1; i <= m; i++)
      	cin >> q[i];
    reverse(p + 1, p + n + 1); // reverse 颠倒
    reverse(q + 1, q + m + 1);
    for (int i = 0; i <= max(m, n); i++)
      	f[i][0] = f[0][i] = i;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            if (p[i] == q[j] || p[i] == 1 || q[j] == 1)
                f[i][j] = min({ f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] });
            else
                f[i][j] = min({ f[i - 1][j] + 1, f[i][j - 1] + 1 });
        }
    int ans = INT_MAX;
    for (int i = 0; i <= m; i++)
      	ans = min(f[n][i], ans);
    for (int i = 0; i <= n; i++)
      	ans = min(f[i][m], ans);
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：yanxu_cn (赞：0)

本题显然是线性 DP，复杂度是 $O(nm)$。DP 大致思路，分类讨论如下。

+ 如果我们发现 $p_i,q_j$ 两者相等或是其中有至少一个是 $1$，那么我们显然可以考虑继承 $(i-1,j-1)$ 的状态，或者选择继承 $(i,j-1)$ 或者 $(i-1,j)$ 的状态并且补一个一！但是我们发现 $(i,j-1)$ 或者 $(i-1,j)$ 这个状态是不可能比 $(i-1,j-1)$ 优的（本质上是由这个状态转移过去的，所以一定不够优），所以直接继承 $(i-1,j-1)$ 的状态；
+ 其余的情况，可以直接转移 $(i,j-1)$、$(i-1,j)$ 中小的那个，原因显而易见同上。

下面是代码部分。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n;
	int m;
	constexpr int maxn = 2007;
	alignas(64)short a[maxn];
	alignas(64)short b[maxn];
	alignas(64)short dp[maxn][maxn];

	cin>>n>>m;
	dp[0][0] = 0;

	for(int i = n;i>=1;--i)
	{
		cin>>a[i];
		dp[i][0] = i;
	}
	for(int i = m;i>=1;--i)
	{
		cin>>b[i];
		dp[0][i] = i;
	}
	
	for(int i = 1;i<=n;++i)
	{
		for(int j = 1;j<=m;++j)
		{
			if(a[i]==b[j]||a[i]==1||b[j]==1)
				dp[i][j] = dp[i-1][j-1];
			else
				dp[i][j] = min(dp[i][j-1]+1,dp[i-1][j]+1);
		}
	}
	short ans = 30000;
	for(int i = 0;i<=m;++i)
		ans=min(ans,dp[n][i]);
	for(int i = 0;i<=n;++i)
		ans=min(ans,dp[i][m]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Like_Amao (赞：0)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P10043)

**思路**

这道题与[编辑距离](https://www.luogu.com.cn/problem/P2758)有点像，因为编辑距离用 DP，所以这道题也用 DP，只不过要逆序处理。

我们设 $dp _ {i,j}$ 为 $a$ 的前 $i$ 个和 $b$ 的前 $j$ 个匹配的最小操作次数。

不难发现：

当 $a _ i = b _ j$ 时或 $a _ i = 1$ 时或 $b _ j = 1$ 时，$dp _ {i,j} = \min ( dp _ {i - 1,j - 1},\min (dp _ {i,j - 1} + 1,dp _ {i,j - 1} + 1))$。

否则，$dp _ {i,j} = \min (dp _ {i,j - 1} + 1,dp _ {i,j - 1} + 1)$。

最后用一个变量 $ans$ 来判断最小值即可。

**代码**


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[2001],b[2001],dp[2001][2001];
signed main()
{
	int n,m;
	cin>>n>>m;
    for(int i=n;i>=1;i--)
    {
    	cin>>a[i];
		dp[i][0]=i;
	}
    for(int i=m;i>=1;i--)
    {
    	cin>>b[i];
		dp[0][i]=i;
	}
	dp[0][0]=0;
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=m;j++)
		{
            if(a[i]==b[j] or a[i]==1 or b[j]==1)
            {
            	dp[i][j]=min(dp[i-1][j-1],min(dp[i][j-1]+1,dp[i-1][j]+1));
			}
            else
			{
				dp[i][j]=min(dp[i][j-1]+1,dp[i-1][j]+1);
			}
        }
    }
    int ans=INT_MAX;
    for(int i=0;i<=m;i++)
	{
		ans=min(ans,dp[n][i]);
	}
    for(int i=0;i<=n;i++)
	{
		ans=min(ans,dp[i][m]);
	}
    cout<<ans;
    return 0;
}
```

---

## 作者：Aix_Eric (赞：0)

### Solution:


类似 P2758 编辑距离。

考虑线性 DP 。

设 $dp_{i,j}$ 为 $a$ 的前 $i$ 个和 $b$ 的前 $j$ 个匹配的操作次数。

容易得到:
- $a_i = b_j$ 或 $a_i = 1$ 或 $b_j = 1$ 时，可以不插入 $1$。可以从 $dp_{i-1,j-1}$ 和 $dp_{i-1,j}$ 和 $dp_{i,j-1}$ 转移。
- 否则只能插入 $1$ 从 $dp_{i-1,j}$ 和 $dp_{i,j-1}$ 转移。操作次数 $+1$ 。

边界情况:

- $dp_{0,0} = 0$ 。
- 匹配 $a$ 的前 $i$ 和空的 $b$ 需要插入 $i$ 个 $1$ ， $dp_{i,0} = i$ ，同理 $dp_{0,i} = i$。

注意要倒序输入。

统计答案为 $a$ 的 $m$ 个和 $b$ 的 $n$ 个匹配的次数。


### Code:

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 2005;
int a[N], b[N], dp[N][N];
int main(){
    int m, n; cin >> m >> n;
    //1倒序输入
    for(int i = m;i >= 1;i--)
        cin >> a[i], dp[i][0] = i;
    for(int i = n;i >= 1;i--)
        cin >> b[i], dp[0][i] = i;
    dp[0][0] = 0;
    for(int i = 1;i <= m;i++){
        for(int j = 1;j <= n;j++){
            if(a[i] == b[j] || a[i] == 1 || b[j] == 1)
                dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1] + 1, dp[i-1][j] + 1));
            else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1);
        }
    }
    int ans = 1e9;
    for(int i = 0;i <= n;i++) ans = min(ans, dp[m][i]);
    for(int i = 0;i <= m;i++) ans = min(ans, dp[i][n]);
    cout << ans << '\n';
    return 0;
}
```

---


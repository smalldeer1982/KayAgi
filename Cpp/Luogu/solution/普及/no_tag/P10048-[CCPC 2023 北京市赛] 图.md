# [CCPC 2023 北京市赛] 图

## 题目描述

给定一个 $n$ 个点的无向正权完全图，请对于每一条边 $(a,b)$，求出是否存在一个点对 $(x,y)$ 使得 $x\rightarrow y$ 的所有最短路都经过 $(a,b)$。

## 样例 #1

### 输入

```
4
0 3 2 100
3 0 8 100
2 8 0 10
100 100 10 0```

### 输出

```
0110
1000
1001
0010```

# 题解

## 作者：Loser_Syx (赞：5)

转化一下题意。  
你考虑边 $(i,j)$ 是否满足要求的本质，实际是求是否存在 $i\rightarrow j$ 的路径可以替换掉 $(i,j)$ 这个边。

然后就好做多了，Floyd 跑完每个点对的最短路后，枚举边 $(i,j)$ 再枚举一个断点 $k\ (k \neq i,j)$，看一下 $i\rightarrow k$ 的最短路加 $k\rightarrow j$ 的最短路是否小于等于 $a_{i,j}$，是就是不符合。

```cpp
void solve() {
	int n = read();
	for (int i=1;i<=n;++i) for (int j=1;j<=n;++j) a[i][j] = f[i][j] = read();
	for (int k=1;k<=n;++k) for (int i=1;i<=n;++i) for (int j=1;j<=n;++j) f[i][j]=min(f[i][j], f[i][k]+f[k][j]);
	for (int i=1;i<=n;++i,putchar(10)) for (int j=1;j<=n;++j) {
		int ans=1;
		for (int k=1;k<=n;++k) if (i!=k&&j!=k&&f[i][k]+f[j][k]<=f[i][j]) ans=0;
		putchar(ans&&i!=j?'1':'0');
	}
}
```

---

## 作者：him的自我修养 (赞：3)

~~开创历史！~~

~~输出格式真的会谢……~~

好的，回归正题。

对于 $(a,b)$ 这条边，如果存在有一个中继节点 $k$，使得 $dis_{a,k}+dis_{k,b} \le w_{a,b}$，那么可以判定 $ans_{i,j}=0$，其中的 $w_{a,b}$ 代表题中给的 $a \rightarrow b$ 的权值；$dis_{a,b}$ 代表两点之间的最短路。

然后，因为 $n \le 500$，所以可以偷懒做 $O(n^3)$ 的弗洛伊德，但是输出好像只能是 $n^3$ 的，所以总体复杂度为 $O(n^3)$，因为 $n \le 500$，所以能过。

## code
```
#include <bits/stdc++.h>
using namespace std;
const int N=514;
int n,a[N][N],f[N][N];
int main(){
	cin >>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin >>a[i][j];
			f[i][j]=a[i][j];
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j){
                cout <<0;
			}else{
				bool falg=1;
				for(int k=1;k<=n;k++) falg&=!(k!=i & k!=j & f[i][k]+f[k][j]<=a[i][j]);
				cout <<falg;
			}
		}
		cout <<endl;
	}
	return 0;
}

```

---

## 作者：约瑟夫用脑玩 (赞：2)

嚎队友，首先 $n\le 500$ 支持 $O(n^3)$，先把 Floyd 跑了再说。

如果顺着题目考虑发现先枚举 $a,b$，再枚举点对 $x,y$，你还得判断最短路有没有不经过 $a,b$ 的，甚至除了删边做还不太会，复杂度 $O(n^5)$ 直接起飞。

这时候队友站出来说：

> 我们考虑先枚举 $x,y$ ，去找能贡献的 $a,b$，不妨以 $x$ 为起点跑一棵最短路树，再考虑一个 $y$ 贡献了最短路树路径上的某个 $a,b$。
>
> 这时候看优非树边（指经过它同样为最短路）覆盖路径的贡献，发现我们需要且必须将 $y$ 往上挪到 $b$ 处来判断，而此时，唯一影响到 $a,b$ 的只有直达 $b$ 的优非树边。
>
> 也就是末尾为 $b$ 的优非树边，那么所有优非树边覆盖一条树边致使其不能成为答案，这道题就做完了。

这么做确实是对的，但也很 nt，因为他都发现可以把 $y$ 挪到 $b$ 上了，再把 $x$ 往后挪挪到 $a$ 上，判断 $(a,b)$ 这条边是否为 $a\to b$ 的唯一最短路径，这道题简单的正解就出来了。

虽然讲了个故事，但其实这种思维过程更符合做题心态，当然一眼秒了的我对先开题还对着我侃侃而谈麻烦做法的队友表示深深的看不起。

代码：（更新了就不是，求 Floyd 过程顺便记录就完了，哪还用跑了再枚举一次啊）

```cpp
for(i=1;i<=n;i++)for(j=1;j<=n;j++)a[i][j]=read();
for(k=1;k<=n;k++)for(i=1;i<=n;i++)if(i^k)for(j=1;j<=n;j++)if(j^k)if(a[i][j]>=a[i][k]+a[k][j])a[i][j]=a[i][k]+a[k][j],ans[i][j]=1;
for(i=1;i<=n;i++,pc(10))for(ans[i][i]=j=1;j<=n;j++)pc(ans[i][j]^49);
```

---

## 作者：_IceCream_ (赞：1)

### 题目转换

给你一个 $n$ 个点的无向正权完全图的邻接矩阵，让你求对于图中的每一条边，有没有一个点对 $(x,y)$ 使得 $x$ 到 $y$ 的最短路中有这条边。

### 思路

既然是最短路有这条边，那么如果这条边可以被其他边以更小的权值转换的话，答案就会更新，点对也会选择更小的权值的那条边而不是此条边。

设 $e_{i,j}$ 为点 $i$ 到点 $j$ 的最短路径权值之和，那么如果 $e_{i,j} \le e_{i,k} + e_{k,j}(i \neq j \neq k)$，也就是说有一点 $k$ 使得 $i$ 到 $j$ 的最短路径更改成为 $i$ 到 $k$，再从 $k$ 到 $j$，此时最短路径更改，答案失效。

可以使用 Floyd 来实现边最短路边统计答案，被其他边更小的权值转换与多源最短路完美契合了 Floyd 的统计距离的方式及实现对象，而且 $1 \le n \le 500$ 也使得 Floyd 的时间复杂度 $O(n^3)$ 不会超时。

对于答案，可以先把答案数组全部赋值为 $1$ ，再根据 Floyd 来把不符合条件的答案赋值为 $0$，对于 $i = j$ 的情况，答案一定为 $0$，所以可以直接赋值。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 500 + 9;
int n;
int a[N][N]; // a[i][j] 表示边 (i, j) 的权值。
bool ans[N][N]; // ans[i][j] 表示点对 (i, j) 是否成立。

int main(){
	
	memset (ans, 1, sizeof ans); // 先全部初始化为1
	
	scanf ("%d", &n);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			scanf ("%d", &a[i][j]);
	
	for (int i = 1; i <= n; ++i) ans[i][i] = 0; // 对于 i = j 的情况，一定为 0，所以直接赋值
	
	for (int k = 1; k <= n; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= n; ++j){
				if (i != j && i != k && j != k && a[i][j] >= a[i][k] + a[k][j]) { // 如果当前的路径不是最短路径
					ans[i][j] = 0; // 那么就把当前的答案赋值为 0
					a[i][j] = a[i][k] + a[k][j]; // 更新最短路
				}
			}
			
	for (int i = 1; i <= n; ++i){
		for (int j = 1; j <= n; ++j) printf ("%d", ans[i][j]);
		printf ("\n");
	}
	
	return 0;
}

```

---

## 作者：_Gabriel_ (赞：0)

### 思路

因为这条边包含一个点对的所有最短路，所以这条边必须是两个顶点间的唯一最短路。

那么如果有一条更短的路径连接这条边的两个顶点，则 $(x,y)$ 的最短路经过时就会选择那条更短的路径，这条边就不符合条件了。


因为 $n \le 500$，可以使用 `Floyd` 算法。

### 代码

```c++
#include <bits/stdc++.h> 
using namespace std;

typedef long long ll;
const int N = 5e2 + 10;
int g[N][N], ans[N][N];
int n;

void floyd() {
	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (i != k && j != k && g[i][j] >= g[i][k] + g[k][j]) {
					g[i][j] = g[i][k] + g[k][j]; 
					ans[i][j] = 0;
				}
			}
		}
	}
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		ans[i][i] = 0;
		for (int j = 1; j <= n; j++) {
			cin >> g[i][j];
		}
	}	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (i != j) ans[i][j] = 1;
		}
	}
	floyd();
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			printf("%d", ans[i][j]);
		}
		printf("\n");
	}
	return 0;
}		 

```

---

## 作者：zk_y (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10048)

我们发现 $n\le 500$，又是与最短路相关，于是立马想到简单的 ``Floyd``。

我们只需要先算出两个点的最短路，然后通过枚举判断每个节点是否在两个节点的最短路上即可。

需要注意判断两个节点相同的情况。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+100;
int m_map[N][N];
int dis[N][N];
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&m_map[i][j]);
			dis[i][j]=m_map[i][j];
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j){
				printf("0");
				continue;
			}
			int ans=1;
			for(int k=1;k<=n;k++){
				if(i==k||j==k)continue;
				if(dis[i][k]+dis[k][j]==dis[i][j]){
					ans=0;
					break;
				}
			}
			printf("%d",ans);
		}
		printf("\n");
	}
	return 0;
}
```


---

## 作者：T_TLucas_Yin (赞：0)

这道题要我们求对于完全图上的每一条边，这条边是否包含于一个点对 $(x,y)$ 的所有最短路中。

我们可以反过来想，既然这条边包含于一个点对的所有最短路，那么这条边也必须是其两个顶点间的唯一最短路。如果有一条更短的路径连接这条边的两个顶点，则 $(x,y)$ 的最短路径经过时就会选择那条更短的路径，这条边就不符合条件了。

使用 Floyd 的理由：

1. 数据范围很小
2. 题目给出的是完全图，对此算法有优势。
3. 要求多源最短路。

看到有些人的做法是先跑一遍 Floyd，再依次判断，其实不用。可以直接在跑 Floyd 时，把连接每条更新过最短路径的两个点的边判定为不符合即可。注意加的特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool flag[1005][1005];
int n,a[1005][1005];
int main(){
    cin>>n;
    memset(flag,1,sizeof(flag));
    for(int i=1;i<=n;i++) flag[i][i]=0;
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>a[i][j];
    for(int k=1;k<=n;k++) 
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(k!=i&&k!=j&&a[i][k]+a[k][j]<=a[i][j])//中转点不能属于本来的边，且有相等的路径也要排除掉。
					flag[i][j]=0,a[i][j]=a[i][k]+a[k][j]; 
                    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++) cout<<flag[i][j];
        cout<<"\n";
    }
    return 0;
}
```

---

## 作者：Saint_ying_xtf (赞：0)

我们可以从另一个角度来看这道题，对于一条边 $(a,b)$，是否存在一个点对 $(x,y)$ 使得 $x\rightarrow y$ 的所有最短路都经过 $(a,b)$。我们设 $res$ 为：从 $a$ 到 $b$ 不经过 $(a,b)$ 这条边的最短路。然后题面可以转换为 $res$ 是否大于 $(a,b)$ 的边权。然后是多源最短路，所以用 Floyd 解决。要注意细节，关于题目中对 $i=j$ 的处理要特判。

```cpp
int n;int a[N][N];
int dis[N][N];
bool check(int x,int y){
	for(int i = 1;i <= n;i++){
		if(dis[x][i]+dis[i][y]<=a[x][y] && i!=x&&i!=y){
			return false;
		}
	}return true;
}
void solve(){
	cin >> n;for(int i = 1;i <= n;i++)for(int j = 1;j <= n;j++){cin >> a[i][j];dis[i][j]=a[i][j];}
	for(int k = 1;k <= n;k++){
		for(int i = 1;i<=n;i++){
			for(int j = 1;j <= n;j++){
				dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
	
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= n;j++){
			cout<<(check(i,j)&&i!=j);
		}cout<<endl;
	}
	
}
```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

给定一个 $n$ 个点的无向正权完全图，请对于每一条边 $(a,b)$，求出是否存在一个点对 $(x,y)$ 使得 $x \rightarrow y$ 的所有最短路都经过 $a,b$。

## Part 2 引入

一眼就看到 $1 \leq n \leq 500$ 了！既然是最短路，那么就可以考虑 Floyd 算法。也就是先用 Floyd 算出每一条边之间的最短路。

附赠最短路模板：

```
for (int k=1;k<=n;k++) // k枚举断点
{
	for (int i=1;i<=n;i++) // i枚举起点
	{
		for (int j=1;j<=n;j++) // j枚举终点
		{
			f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
		}
	}
}
```

## Part 3 思路

本题题意的难点就在于，什么叫求出是否存在一个点对 $(x,y)$ 使得 $x \rightarrow y$ 的所有最短路都经过 $a,b$？

那不妨让我们换个思路：若 $f_{a,b}$ 表示 $(a,b)$ 间最短路的长度，在什么情况下，$f_{a,b}$ 可以代替所有 $(a,b)$ 的最短路？

很显然，当没有任何一个断点 $c$ 可以满足 $f_{a,c}+f_{c,b} \leq f_{a,b}$ 时满足。为什么呢？因为这就表示 $(a,b)$ 之间的最短路有且只有 $f_{a,b}$ 所统计的这一条，这样 $f_{a,b}$ 就可以直接表示 $(a,b)$ 间的距离。

接着，题目中对于点 $(x,y)$，只要判断是否有断点 $z$ 能满足 $f_{x,z}+f_{z,y} \leq f_{x,y}$ 即可。若没有，说明 $(x,y)$ 间的最短路只有这一条，$(a,b)$ 也必定存在。

## Part 4 代码

```
#include <bits/stdc++.h>
using namespace std;
int n,a[505][505],f[505][505];
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++) cin>>a[i][j];
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++) f[i][j]=a[i][j];
	}
	for (int k=1;k<=n;k++)
	{
		for (int i=1;i<=n;i++)
		{
			for (int j=1;j<=n;j++)
			{
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			if (i==j) { cout<<"0";continue; }
			bool result=true;
			for (int k=1;k<=n;k++)
			{
				if (i==k || j==k) continue;
				if (f[i][k]+f[k][j]<=f[i][j]) result=false;
			}
			cout<<(int)result;
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：ZBH_123 (赞：0)

## 题目分析
首先，我们先处理出任意两点间的最短路，接着，我们遍历所有边 $(i,j)$，如果存在一个点 $k$，使得 $i \to j$ 的最短路中经过 $k$ 的最短路小于等于 $(i,j)$ 的权值，那么 $(i,j)$ 就不满足要求，反之就满足要求。

**AC code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dis[505][505],w[505][505];
void init(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&w[i][j]);
			dis[i][j]=dis[j][i]=w[j][i]=w[i][j];
		}
	}
}
void solve(){
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j){
				putchar('0');
				continue;
			}
			bool flag=true;
			for(int k=1;k<=n;k++){
				if(i!=k&&k!=j&&dis[i][k]+dis[k][j]<=w[i][j]){
					flag=false;
				}
			}
			if(flag){
				putchar('1');
			}
			else{
				putchar('0');
			}
		}
		puts("");
	}
}
int main(){
	init();
	solve();
	return 0;
}
```

---


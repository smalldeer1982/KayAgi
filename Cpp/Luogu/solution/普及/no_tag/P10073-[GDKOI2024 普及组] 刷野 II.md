# [GDKOI2024 普及组] 刷野 II

## 题目描述

Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。

Zayin 知道许多被压制的咒语，在这场战斗中，他决定使用一个名为” 闪电连击” 的咒语来一口气击败所有的怪物。让我们看看这个咒语是如何工作的。

- 首先，Zayin 选择一个怪物 $i(1 \leq i \leq n)$ 以及咒语的初始力量 $x$。
- 然后这个咒语会首先击中怪物 $i$，随后对于除第一个目标怪物外，Zayin 可以选择一个没有被该咒语击中过，并且与其中一个已经被击中的怪物相邻的怪物。
- 第一个被击中的目标怪物会受到 $x$ 的伤害，第二个目标怪物会受到 $x-1$ 的伤害，第三个受到 $x-2$ 的伤害，以此类推。不难看出，每个怪物都会被击中恰好一次。

如果一个怪物受到的伤害不低于其生命值，则视为死亡。

Zayin 想展示他作为一个高级巫师的能力，所以他希望在只使用一次咒语就能杀死所有怪物的前提下，使用最少的初始力量 $x$。

现在你需要求出所需的最少的初始力量，并给出一个方案。如果有多个不同的方案，只需要给出任意一个就可以了。

## 说明/提示

对于所有测试数据，保证 $1 \leq n \leq 5 \times 10^6$
，$1 \leq a_i \leq 10^9$。

| 测试点编号 | $n\leq$ |
| :----------: | :----------: |
| $1$ | $10$ |
| $2$ | $20$ |
| $3$ | $500$ |
| $4$ | $5000$ |
| $5$ | $5\times 10^4$ |
| $6,7$ | $5\times 10^5$ |
| $8,9,10$ | $5\times 10^6$ |


## 样例 #1

### 输入

```
1 10
19 9 12 5 10 7 16 15 17 12```

### 输出

```
25
1 2 3 4 5 6 7 8 9 10```

# 题解

## 作者：2022tysc0776 (赞：16)

其实这题比较简单，本人考场上想出来了正解，但是我当时太大意了，忘了输出第二行的答案，然后我又不大自信，所以没有检查，狂挂 100 分

---------------------------------------------------------

说回题目，我们先猜一个结论：每次都找一个当前除了已经打完的怪物之外，最大血量的怪物 $u$，接一路打过去，这样的走法一定最优。

然后说证明：我们用反证法，如果我们当前不走上面结论的走法，肯定会多走一点才到 $u$，$u$ 是当前除吃完的怪物的最大血量的怪物，所以多走一点肯定不优。

但是还有一个问题，题目不保证所有怪物的血量不同，有没有可能，两个怪物的血量相同但是先走某一个更优呢？

然后再想一下其实也能发现是不可能的，因为这两个怪物肯定都要打，不管先打哪个，最后的所需的 $x$ 肯定是一样的。

那么代码就很好写了：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,d,a[5000010],as[5000010],cnt=1;
pair<int,int> b[5000010];
int main(){
	scanf("%d%d",&d,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i].first=a[i];b[i].second=i;
	}
	sort(b+1,b+n+1);
	int lid=b[n].second,rid=b[n].second,id=n-1;
	int ans=b[n].first,x=b[n].first-1;
	as[1]=b[n].second;
	while(lid!=1||rid!=n){
		if(b[id].second<lid){
			for(int i=lid-1;i>=b[id].second;i--){
				lid=i;
				if(x<a[i]) x=a[i],ans=a[i]+(rid-lid);
				x--;
				as[++cnt]=i;
			}
		}else if(b[id].second>rid){
			for(int i=rid+1;i<=b[id].second;i++){
				rid=i;
				if(x<a[i]) x=a[i],ans=a[i]+(rid-lid);
				x--;
				as[++cnt]=i;
			}
		}
		id--;
	}
	printf("%d\n",ans);
	for(int i=1;i<=cnt;i++) printf("%d ",as[i]); 
	return 0;
}
```

而且我的想法和别人不太一样，还有这是本人第一次题解，所以如有问题，可在评论区指出。

---

## 作者：2023fyc (赞：13)

### 题目大意：
有 $n$ 只小怪，可以选任意一直先打，然后每次再打已打过的小怪相邻的怪兽，攻击的能量也会每次少 $1$ 。问最少的初始力量是多少。

### 正解：
由于我们要求一开始的最少能量，所以我们可以得出一个结论：
$A_1$ 和 $A_n$ 血量更小的会更晚被打死，我们就可以以此类推,再用一个数组来存它们的先后顺序。

拿样例举个例子：
```
1 10
19 9 12 5 10 7 16 15 17 12
```

我们先比较第一只小怪和最后一只小怪，发现 $19>12$，于是 $B_1=12$。然后我们再拿 $19$ 和 $17$ 比较，发现 $19>17$，$B_2$ 就等于 $17$ 。最后求出怪兽死的先后顺序即为 $B_1$ 到 $B_n$，等于
```
12 17 15 16 7 10 5 12 9 19
```

求出了 $B$ 数组，也就是怪兽死的先后顺序，也就能求出题目要求的能量最小值。

注意：题目要求出的还要是编号为 $i$ 的怪兽是第几个死的，而我们的 $B$ 数组是怪兽死的先后顺序，而且是从晚死到早死的，不过我们只需要在求 $B$ 数组时把它的编号也存下来就行了。

代码如下：
~~~cpp
#include<bits/stdc++.h>
using namespace std;
long long d,n,k,mx,a[5000005],b[5000005],c[5000005];
int main(){
	scanf("%lld%lld",&d,&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1,j=n;i<=j;)
		if(a[i]<a[j]){//判断头的血量多还是尾的血量多
			c[++k]=i;//存编号
			b[k]=a[i];
			i++;
		}
		else{
			c[++k]=j;//存编号
			b[k]=a[j];
			j--;
		}
	for(int i=1,j=n;j>0;i++,j--) if(b[j]+i-1>mx) mx=b[j]+i-1;//算最少的初始力量
	printf("%lld\n",mx);
	for(int i=n;i>0;i--) printf("%lld ",c[i]);//记得要反着输出
	return 0;
}
~~~

---

## 作者：This_Rrhar (赞：5)

考虑倒推 $monster$ 序列。由于咒语的传递方式，最后被击中的怪物必然是第 $1$ 或第 $n$ 只。

如果最后是第 $1$ 只怪物被击中，那么有 $x\ge a_1-n+1$，$x\ge a_n-n+2$。

如果最后是第 $n$ 只怪物被击中，那么有 $x\ge a_n-n+1$，$x\ge a_1-n+2$。

显然有：

- $a_1<a_n$ 时，第 $1$ 只最后被击中。

- $a_1>a_n$ 时，第 $n$ 只最后被击中。

- $a_1=a_n$ 时，任选一只即可。

去掉最后被击中的怪物，剩余的怪物仍是一段连续区间，那么用一样的方法可以回推整个区间，中途再记录一下顺序即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
 
#define N 5000001
 
ll D,n;
 
ll a[N];
 
stack<ll>s;
ll ans;
 
ll l=1,r,res;
 
int main()
{
    ios::sync_with_stdio(false);
    cin>>D>>n,r=n,res=n-1;
    for(int i=1;i<=n;i++)cin>>a[i];
    while(l<=r)
    {
        if(a[l]<a[r])ans=max(ans,a[l]+res),s.push(l),l++;
        else ans=max(ans,a[r]+res),s.push(r),r--;
        res--;
    }
    cout<<ans<<"\n";
    while(!s.empty())cout<<s.top()<<" ",s.pop();
}
```

---

## 作者：mgcjade (赞：4)

# [P10073 [GDKOI2024 普及组] 刷野 II](https://www.luogu.com.cn/problem/P10073) 的题解

谨以此篇题解记录我考场上唯一通过的一题~

## 解题思路

可以考虑定义两个指针 `x` 和 `y`，分别为左侧攻击到哪里和右侧。此时，从两侧线性想中间递推，若先打左边的代价小就打左边的，否则就打右边的。按照这个方法向中间推就可以了。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e6 + 5;

void read(int &s)
{
    s = 0;
    char ch = getchar();
    char last = ch;

    while (ch < '0' || ch > '9')
        last = ch, ch = getchar();

    while (ch >= '0' && ch <= '9')
        s = (s << 3) + (s << 1) + (ch ^ 48), ch = getchar();

    if (last == '-')
        s = -s;
}

int n;
int a[N];
int x, y;
int ans[N];
int t;

int main()
{
    read(t), read(n);

    for (int i = 1; i <= n; i++)
        read(a[i]);

    x = 1, y = n;

    while (x <= y)
    {
        int nx = max(a[x], ans[0] + 1), ny = max(a[y], ans[0] + 1);

        if (nx >= ny)
            ans[0] = ny, ans[n - y + x] = y, y--;
        else
            ans[0] = nx, ans[n - y + x] = x, x++;
    }

    printf("%d\n", ans[0]);

    for (int i = n; i; i--)
    printf("%d ", ans[i]);

    return 0;
}
```

---

## 作者：liuhongyang123 (赞：4)

题外话：听说这道题很水只要常数优化的好暴力都能卡过。

## 题目大意

有 $n$ 个怪物站成一排，第 $i$ 个怪的生命值为 $a_i$。

- Zayin 一开始会从中挑选一个幸运观众，对其发起力量为 $x$ 的咒语进行攻击。

- 随后咒语会对于除第一个目标怪物外，一个没有被该咒语击中过，并且与其中一个已经被击中的怪物相邻的怪物发起下一轮攻击。

- 第一个被击中的目标怪物会受到 $x$ 的伤害，第二个目标怪物会受到 $x−1$ 的伤害，第三个受到 $x−2$ 的伤害，以此类推。

求只使用一次咒语就能杀死所有怪物的前提下，使用最少的初始力量 $x$ ，并给出一个方案。

## 正解


~~暴力~~ 额，好吧这里就不讲了。

我今天要讲的可是简单的不能再简单的 **DP**。

我们设 $f[i]$ 表示倒数第 $i$ 个被打的怪所承受的咒语力量的基本值（具体开看下面），$fa[i]$ 表示倒数第 $i$ 个被打的怪的下表，也就是题目中的方案。


根据
- 随后咒语会对于除第一个目标怪物外，一个没有被该咒语击中过，并且与其中一个已经被击中的怪物相邻的怪物发起下一轮攻击。

我们可以得出最后一个被打的肯定是一个区间中最左或最右，由此可得状态转移方程：

```cpp
if(a[l]<a[r]) f[++cnt]=a[l],fa[cnt]=l,l++;
else f[++cnt]=a[r],fa[cnt]=r,r--;
```

求 $x$ 为 $f[i]-n+i$。

```cpp
for(int i=1,j=n;j>0;i++,j--) if(f[j]+i-1>maxx) maxx=f[j]+i-1;
```

### Last
给给位附上~~高清无码~~ 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=5E6+10;
long long m,n,a[MAXN],f[MAXN],fa[MAXN],cnt,maxx;
int main(){
	scanf("%lld%lld",&m,&n);
	for(long long i=1;i<=n;i++) scanf("%lld",&a[i]);
	long long i,j;
	for(i=1,j=n;i<=j;){
		if(a[i]<a[j]) f[++cnt]=a[i],fa[cnt]=i,i++;
		else f[++cnt]=a[j],fa[cnt]=j,j--;
	}
	for(int i=1,j=n;j>0;i++,j--) if(f[j]+i-1>maxx) maxx=f[j]+i-1;
	printf("%lld\n",maxx);
	for(long long k=n;k>=1;k--) printf("%lld ",fa[k]);
	return 0;
}
```

#### 华丽收尾

---

## 作者：Guizy (赞：3)

我们发现，两端的一定是最后被打到，那我们肯定贪心选血量小的一个后打，一直这样直到得到了打所有怪物的顺序，最后根据顺序求初始力量即可。

实现可以用双指针和 `while`，代码很短。

```cpp
#include<bits/stdc++.h>
#define Max 5000001
using namespace std;

int d,n,a[Max],list[Max],ans[Max],maxn=-1;

int main(){
	
	scanf("%d%d",&d,&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	
	int l=1,r=n,cnt=n;
	while(l<=r){
		if(a[l]<a[r]) //这里求顺序和求初始力量放一起了
		    ans[cnt--]=l,maxn=max(maxn,a[l++]+cnt);
		else ans[cnt--]=r,maxn=max(maxn,a[r--]+cnt);
	}
	
	printf("%d\n",maxn);
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
}
```

---

## 作者：Steve_xh (赞：1)

题外话：有幸参加了今年的 GDKOI，~~也有幸体验到被全广东的大佬踩爆的感觉~~。

# 题意：

[题目传送门](https://www.luogu.com.cn/problem/P10073)

**题目大意：**

有一个法师，他遇到了 $n$ 个血量分别为 $a_i$ 的怪站在一排。他可以选择用一定的法力攻击其中的一个怪，随后法力衰减 $1$ 点，接着会选择其中一个被攻击过的怪的相邻的没被攻击过的怪继续攻击，如此反复直到所有怪物均被攻击。

对于每个被攻击到的怪，如果它的血量小于攻击它的法力值，那这个怪就会被打死。这个法师他很懒，他想一开始使用尽可能小的法力，并选择一个最优的初始怪使得这些怪能被一次性打死。要求这个最小的初始法力值以及被攻击的怪的顺序。

# 思路

由于法力会不断衰减，所以第一个被攻击到的怪一定是血量最厚的。且不难发现，对于每个时刻，所有被攻击的怪一定是连在一起的一段区间，并且下一个时刻被攻击的怪一定处于这个区间的**左端点的前一个位置**或者**右端点的后一个位置**。

接下来是我考场时的想法。根据这个思路可以很快写出代码：将初始答案与当前期望法力 $now$ 设为最大值，确定两个指针 $l$ 和 $r$ 分别表示当前被攻击怪区间的左端点和右端点，比较 $a_{l-1}$ 和 $a_{r+1}$，选择其中较大的攻击。若这个怪的血量比 $now$ 大，则表示以初始法力值无法打死这个怪，就将答案加上这个怪的血量与 $now$ 的差值并将 $now$ 设为当前血量，表示将初始法力值提高至能打死这个怪为止。如此反复直到 $l$ 和 $r$ 指针到头为止。

以下是核心代码：

```cpp
ans=a[maxi];//初始答案
int l=maxi-1,r=maxi+1,now=ans-1;//两个指针以及当前法力
anses.push_back(maxi);//先打血最厚的
while(l>=1&&r<=n){
	int tmp=(a[l]>=a[r])?l:r;//打血厚的
	if(a[tmp]>now)//如果法力不够杀死，就提高初始法力
		ans+=a[tmp]-now,now=a[tmp];
	anses.push_back(tmp);//将这个怪划入生死簿（bushi
	if(tmp==l)
		l--;
	else
		r++;
	now--;//法力衰减
}
while(l>=1){//将剩下没杀完的怪全杀了
	if(a[l]>now)
		ans+=a[l]-now,now=a[l];
	anses.push_back(l--);
	now--;
}
while(r<=n){//同上
	if(a[r]>now)
		ans+=a[r]-now,now=a[r];
	anses.push_back(r++);
	now--;
}
```

就在我考完兴致勃勃地与码友交换思路时，我感到一丝不对劲。出结果那天，这题不出所料的爆零了 QwQ。

为什么？不难想到，若当前两个怪血量相等，那法师就不知道要杀哪个而只能选择其中一个杀掉，但这个决定可能会影响后来的选择，而且一排怪的血量最大值有可能有多个，此时就无法确定最优答案了。

那么怎样才能正确呢？赛后反思，发现把这个思路倒过来做就好了！

由于法力的衰减是由中间开始发散的，所以不难推断出最后一个杀死的一定是第一个或最后一个。

首先将两个指针定位 $1$ 和 $n$，还是依次比较两个血量，不过这次是选小的加入答案序列。这样我们就确定了最后一个要杀死的。接下来得到一个长度为 $n-1$ 的怪，把它当作一个子问题继续按这个方式来选。每次确定一个最后被杀的怪，直到确定完 $n$ 次，得到答案序列，将其倒置过来即可。

那初始法力怎么确定？法力是按每次一点的形式衰减的，若杀掉最后一个怪 $end$ 所需法力就是 $end$，那么初始最小法力就是 $n-1+end$。因为从第一个开始衰减到最后一个需要 $(n-1)$ 次，再加上要杀的怪的血量就得出了这个式子。

知道了每次所需法力的最小值，每次进行子问题的杀怪时我们就将这个值与下一次所需的值取最大值，最终就能得出答案了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int d,n,a[5000006];
vector<int> ans;
int solve(int l,int r,int last){//杀掉当前序列的最后一个怪，last表示当前的序列长度，当然也可以用(r-l+1)表示，不过太麻烦
	if(l>r)//杀完了直接退出
		return 0;
	if(a[l]>a[r]){//l的血更厚，所以杀r
		ans.push_back(r);
		return max(a[r]+last-1,solve(l,r-1,last-1));//取法力最大值
	}else{//否则杀l
		ans.push_back(l);
		return max(a[l]+last-1,solve(l+1,r,last-1));
	}
}
int main(){
	scanf("%d%d",&d,&n);
	for(int i=1;i<=n;i++)
		scanf("%d",a+i);
	printf("%d\n",solve(1,n,n));
	for(int i=n-1;i>=0;i--)//每次都杀最后一个，所以倒着输出
		printf("%d ",ans[i]);
	return 0;
}

```

---

## 作者：homo_snow (赞：1)

## 全场最水题

~~但我爆 $0$。~~

一眼题，首先我们肯定要从最大的那只怪开始杀。然后以这只怪向左右扩展，选出以处理区间左右端点中的较大的杀。

本人赛时没想出 O(n) 贪心，所有选择了不怎么优秀的 O(nlogn) 二分。

以第一次攻击造成的伤害为二分答案，当 check 函数返回 $1$ 时，缩小答案范围，反之增大答案范围。

在 check 函数中，我们以血量最高的那只怪开始，按照上面讲的进行区间扩展，当遇到伤害不够时返回 $0$，当区间可以扩展完毕，就返回 $1$ 即可。

然后这道题就没了。

~~还好出题人没卡 O(nlogn)。~~

---

## 作者：nyC20 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10073)
# 题意
找到一个最小的 $x$，使得 $x$ 在传递并不断衰减过程中始终大于每一个 $a_i$，并输出传递顺序。
# 思路
首先想到的肯定是贪心，在输入的时候找出最大值，从最大值开始，往两边扩散，每次找血量高的怪击杀，并在此过程中维护答案 $x$。但这样的思路看似天衣无缝，实则会 WA！这个思路的错误点在于如果出现两边的怪的血量相同的情况，我们不知道应该选哪边，如果随便选的话就会导致答案错误。

于是，我们把思路改一下，把这个思路反过来，左端点初始化为 $1$，右端点为 $n$，不断向中间收拢，然后维护答案 $x$，就能 A 掉！
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
stack<int>stk;
int d, n, a[5000003], x, l, r;
int main() {
	scanf("%d%d",&d,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	l=1,r=n;//初始化 
	for(int i=1;i<=n;i++){
		if(a[l]<a[r]){
			stk.push(l);//栈把倒序变为正序 
			x=max(x,a[l]+n-i);//维护答案x，如果到这里会不够就变成刚好够的攻击力 
			l++;//左端点向中间靠拢 
		}
		else{//同上 
			stk.push(r);
			x=max(x,a[r]+n-i);
			r--;
		}
	}
	printf("%d\n",x);
	while(stk.size()){//变成正序输出 
		printf("%d ",stk.top());
		stk.pop();
	}
	return 0;
}
```


---

## 作者：Escapism (赞：0)

~~考场上没思路，我是什么东西。~~

[题目传送门](https://www.luogu.com.cn/problem/P10073)

# 题意

$n$ 只怪排成一排，第 $i$ 只怪物血量为 $a_i$，血量小于等于 $0$ 就判定死亡。

现在有一种技能，可以选取一只怪物对其造成 $k$ 的伤害。当这只怪物死亡，这个技能可以扩散到其相邻的、没有死亡的怪物，对其造成 $k-1$ 的伤害，以此类推。

现在问如果想只使用一次这个技能，那么 $k$ 的最小值可以使多少。

# 思路

倒推一下。

显然最后一个被击中的怪物是第 $1$ 只或第 $n$ 只。同时，头尾相反的那一只至后是在倒数第二只时被杀死。因而必然存在：

- 如果最后被击中的是第 $n$ 只，那么有 $a_n > x - n + 1,a_1 > x - n + 2$。

- 如果最后被击中的是第 $1$ 只，那么有 $a_1> x - n + 1,a_n > x - n + 2$。

为了使 $x$ 尽可能小，我们显然会选择 $a_n$ 与 $a_1$ 小的那一只开始。

由于攻击方式的限制，我们倒推时去掉了 $a_1$ 或 $a_n$，存活的怪物仍然是一个连续的区间。因而我们可以一直按照这个方式进行倒推。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

const int N  = 5 * 1e6 + 5;
ll D,n,a[N];
stack<ll> s; //由于是倒推，所以答案用栈记录
ll ans,l=1,r,res;

int main(){
    cin>>D>>n;
    r = n,res = n - 1;
    for(int i = 1;i <= n;i++)cin>>a[i];
    while(l <= r){
        if(a[l] < a[r]){ //取头来打
            ans=max(ans,a[l] + res);
            s.push(l);
            l++;
        }
        else{ //取尾来打
            ans = max(ans,a[r] + res);
            s.push(r);
            r--;
        }
        res--; //减少当前存活的怪物数量。
    }
    cout<<ans<<"\n";
    while(!s.empty()){
        cout<<s.top()<<" ";
        s.pop();
    }
}
```



---

## 作者：PZYi (赞：0)

赛时想出了一半的思路，只可惜没有理解到题意想错了。
# 思路
贪心

根据题意，每次攻击后，伤害都会减一，所以第 $i$ 个被击中的怪物相当于它的血量会增加 $i$。由于攻击的传递方式，我们可以知道最后一个被攻击的一定是第一个或者最后一个，所以我们可以得出 $a_1+n-x\leq0$ 或者 $a_n+n-x\leq0$。

为了使发出的伤害最小，所以我们需要比较上面两个式子的大小，通过化简，只比较 $a_1$ 和 $a_n$ 的大小。

如果 $a_1>a_n$，那么最后一个被攻击的是 $a_n$，

如果 $a_1<a_n$，那么最后一个被攻击的是 $a_1$，

如果两者相等，随便选一个。

之后，我们发现剩下的怪物仍然是一个连续的区间，按照同样的步骤，倒推整个区间，再用栈记录一下答案便可。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
long long d,n,a[5000010],ans;
stack<long long>h;
int main()
{
	cin>>d>>n;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	int l=1,r=n,w=n-1;
	while(l<=r)
	{
		if(a[l]>=a[r]) ans=max(ans,a[r]+w),h.push(r--);
		else ans=max(ans,a[l]+w),h.push(l++);
		w--;
	}
	cout<<ans<<endl;
	while(h.size())
	{
		cout<<h.top()<<' ';
		h.pop();
	}
}
```


---

## 作者：WaterSky (赞：0)

# [P10073 [GDKOI2024 普及组] 刷野 II](https://www.luogu.com.cn/problem/P10073)

以下思路是听讲座之后会的，赛时挂了。

---
## 算法：
- 贪心。

## 具体思路：
可以这样想，第 $k$ 个被击中的相当于血量加上了 $k$，再减去 $x$，其结果小于 $0$。

根据咒语的传递方式，得出结论，最后被咒语击中的怪物必定是第 $1$ 个或者第 $n$ 个，

如果结束的是 $1$，那么可以得出 $a_1+n-x\le0$ 移项得 $a_1+n \le x$。
同理，如果结束的是 $n$，可以得出 $a_n+n \le x$。

因为题目要求是 $x$ 最小，那么在当前，我们可以通过比较 $a_n+n \le x$ 与 $a_1+n \le x$。同样，可以化简为比较 $a_n$ 与 $a_1$，那么可以得出一下步骤：

- 当 $a_n>a_1$，使第 $1$ 个作为最后一个被击中。

- 当 $a_1>a_n$，使第 $n$ 个作为最后一个被击中。

- 当 $a_1=a_n$，任选一个，不影响结果。

接下来我们会发现，选了最后一个，剩下的又回到开始的局面，我们使 $n$ 减去 $1$，然后重复执行上述步骤。

那么存储答案我们可以使用栈来存储。

## 实现（如上）：
```
#include<bits/stdc++.h>
using namespace std;
long long d,n,ans,l=1,r,t;
long long a[5000001];
stack<long long>s;
int main()
{
    cin>>d>>n;
	r=n,t=n-1;
    for(int i=1;i<=n;i++)cin>>a[i];
    while(1)
    {
        if(a[l]>=a[r])
			ans=max(ans,a[r]+t),s.push(r),r--;
        else 
			ans=max(ans,a[l]+t),s.push(l),l++;
        t--;
        if(l>r) break;
    }
    cout<<ans<<endl;
    while(!s.empty())
	cout<<s.top()<<" ",s.pop();
    return 0;
}
```
感谢管理员审核！

---


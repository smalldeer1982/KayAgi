# [GDKOI2024 普及组] 捉迷藏

## 题目描述

Zayin 和 Ziyin 正在玩有趣的捉迷藏游戏。

该游戏在一颗具有 $n$ 个节点（编号从 $1$ 到 $n$）的树上进行。

在游戏的开始，Zayin 在节点 $a$，而 Ziyin 在节点 $b$。他们轮流操作，Zayin 先移动。在每次移动中，Zayin
能移动到距离当前所在点不超过 $da$ 的节点上，而 Ziyin 能移动到距离当前所在点不超过 $db$ 的节点上（注意
可以保持在当前点不动）。

当某次移动后，其中一人抓住了另外一人，即移动到了另外一人的节点上，则游戏结束，被抓住的人输掉游戏。

当 Zayin 和 Ziyin 都按最优策略移动的话，谁会是最后赢家呢。

注解：
- 一颗具有 $n$ 个节点的树是指一个具有 $n$ 个节点，$n - 1$ 条边的连通无向图。
- 树上两个节点的距离定义为连接该两点的最短路径所包含的边数。

## 说明/提示

保证所有测试用例的 $n$ 之和不超过 $10^6$，$q$ 之和不超过 $10^6$。

| 数据点编号 | $\sum n \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | 无 |
| $2$ | $100$ | $q=1$ |
| $3$ | $100$ | 无 |
| $4$ | $10^4$ | $q=1$ |
| $5$ | $10^4$ | 无 |
| $6$ | $10^6$ | $q=1$ |
| $7,8,9,10$ | $10^6$ | 无 |


## 样例 #1

### 输入

```
1 2
6 5
2 3
2 6
2 1
4 3
5 1
5 4 1 2
6 4 4 3
1 4 5 4
5 2 1 4
2 5 1 5
4 5
1 4
3 4
2 4
4 2 2 3
4 3 2 2
4 3 3 3
1 2 1 1
1 2 1 2```

### 输出

```
Ziyin
Zayin
Zayin
Ziyin
Ziyin
Zayin
Zayin
Zayin
Draw
Ziyin```

# 题解

## 作者：yzx3195 (赞：10)

# 题目大意

Zayin 和 Ziyin 在一颗树上互追，谁先移动到另外一个人所在的结点上就算胜利，两个人都会按照**最优**方式移动，询问最后谁会赢。若在 $10^{10^5}$ 后，仍没人抓得到对方，则输出平手 Draw。

# 做法

显然，树上求两点之间的距离，用 LCA，下面给出公式：$dis_{a,b} = depth_a + depth_b - 2 \times depth_{lca} $, 其中，$depth_x$ 表示结点 $x$ 的深度，$lca$ 表示 $a, b$ 两点的[最近公共祖先](https://www.luogu.com.cn/problem/P3379)。

~~想必大家都会求 LCA 吧。~~

对于 Zayin，只要当前 Zayin 可移动的距离 $da$ 大于了 Zayin 与 Ziyin 之间的距离，那么 Zayin 就可以抓住 Ziyin，或者，Zayin 可移动的距离 $da$ 大于 Ziyin 可移动的距离 $db$。这样，在若干次操作之后，Ziyin 一定会被 Zayin 逼到树上的某一个点上，所以 Zayin 在这种情况下也会胜利。

对于 Ziyin 也同理。

当且仅当 $da = db$ 时，两人平手。

时间复杂度为 $O(T(n \log n + q \log n))$，卡一卡常也能通过本题。

切记，清零不要用 memset，否则会 TLE。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define re register

const int MAXN = 1e06 + 7;

const int LG = 20;

int d, t;

int n, q;

int lg;

struct Edge {
	int to;
	int nxt;
} Num[MAXN * 2];//双向边开两倍

int head[MAXN * 2];

int cnt;

int f[MAXN][LG];

int depth[MAXN];

void add(int x, int y)
{
	Num[++cnt].to = y;
	Num[cnt].nxt = head[x];
	head[x] = cnt;
	return ;
}

void dfs(int x, int fa)//LCA预处理
{
	f[x][0] = fa, depth[x] = depth[fa] + 1;
	for(re int i = 1; (1 << i) <= depth[x]; i++)
		f[x][i] = f[f[x][i - 1]][i - 1];
	for(re int i = head[x]; i; i = Num[i].nxt)
	{
		if(Num[i].to != fa)
		{
			dfs(Num[i].to, x);
		}
	}
	return;
}

int LCA(int x, int y)//倍增求LCA
{
	if(x == y)
		return x;
	if(depth[x] < depth[y])
		swap(x, y);
	for(re int i = lg; i >= 0; i--)
	{
		if(depth[x] - (1 << i) >= depth[y])
			x = f[x][i];
	}
	if(x == y)
		return x;
	for(re int i = lg; i >= 0; i--)
	{
		if(f[x][i] != f[y][i])
			x = f[x][i], y = f[y][i];
	}
	return f[x][0];
}

inline void read(int &x)//卡常小技巧
{
	int f = 1;
	x = 0;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f *= -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	x *= f;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-'), x = -x;
	}
	if (x > 9)
	{
		write(x / 10);
	}
	putchar(x % 10 ^ 48);
}

signed main()
{
//	freopen("game.in", "r", stdin);
//	freopen("game.out", "w", stdout);
	read(d), read(t);
	
	while(t--)
	{
		read(n), read(q);
		lg = log2(n);
		cnt = 0;
		for(re int i = 1; i <= n; i++)//不要用 memset!
		{
			depth[i] = 0, Num[i].nxt = 0, Num[i].to = 0, head[i] = 0;
			for(re int j = 1; j <= lg; j++)
			{
				f[i][j] = 0;
			}
		}
		for(re int i = 1; i < n; i++)
		{
			int u, v;
			read(u), read(v);
			add(u, v), add(v, u);
		}
		dfs(1, 0);
		int a, b, da, db;
		for(re int i = 1; i <= q; i++)
		{
			read(a), read(b), read(da), read(db);
			int dis = depth[a] + depth[b] - 2 * (depth[LCA(a, b)]);
			if(dis <= da)
			{
				putchar('Z'), putchar('a'), putchar('y'), putchar('i'), putchar('n');
				putchar('\n');
			}
			else if(da > db)
			{
				putchar('Z'), putchar('a'), putchar('y'), putchar('i'), putchar('n');
				putchar('\n');
			}
			else if(da == db)
			{
				putchar('D'), putchar('r'), putchar('a'), putchar('w');
				putchar('\n');
			}
			else
			{
				putchar('Z'), putchar('i'), putchar('y'), putchar('i'), putchar('n');
				putchar('\n');
			}
		}
	}
	
}
```

---

## 作者：Red_river (赞：6)

# 题目大意
给出一棵树，和两个人在树上的位置。两个人按能移动的距离轮流行动。如果一个人移动到了另一个人的位置上，则该人获胜，问谁会先到达对方的位置，也就是本题中要赢的条件。

## 结论

这道题实际上就是一道贪心。其实一个人是否可以先到达另一个人的位置，主要看的是这个人的移动步数是否能够大于对方。

因为对于一个点来说，它的距离大于对方，那么如果要退，那么对方一定追不上。如果要追，对方也一定逃不了。

但是有一种特殊情况：

对于先手，如果可以直接到达，则先手获胜。

### 注意

由于数据较大并且时间也够，所以这里使用倍增。时间复杂度为：$ ( N\log N ) $

# Code
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#define ll long long
#define lll __int128
#define wk(x) write(x),putchar(' ')
#define wh(x) write(x),putchar('\n')
#define r(x) read(x)
const long long M=2147483647;
const int N=1000005;
const int NM=1005;
using namespace std;
void read(int&);
void write(int);
int n,m,k,t,jk,tot,cnt,ans,sum,num,answer;
int a[N],f[NM][NM],dep[N],mx[N][105];
int head[N*2],to[N*2],nxt[N*2];
void add(int x,int y)
{
    to[++cnt]=y;
    nxt[cnt]=head[x];
    head[x]=cnt;
}
void dg(int x,int y,int de)
{
    dep[x]=de;
    for(register int i=head[x];i;i=nxt[i])
    {
        int v=to[i];
        if(v==y) continue;
        mx[v][0]=x;
        dg(v,x,de+1);
    }
}
int lca(int u,int v)
{
    int pop=1,pop1=1;
    if(dep[u]<dep[v]) swap(u,v);
    for(register int i=22;i>=0;i--)
    if(dep[mx[u][i]]>=dep[v]) u=mx[u][i];
    if(u==v) return u;
    for(register int i=22;i>=0;i--)
    if(mx[u][i]!=mx[v][i]) u=mx[u][i],v=mx[v][i];
    return mx[u][0];
}
int main()
{
    freopen("game.in","r",stdin);//
    freopen("game.out","w",stdout);//乱杀。
    read(jk);read(jk);
    while(jk--)
    {
        read(n),read(m);int x=0,y=0;
        for(register int i=1;i<=n;i++)
        {
            head[i]=nxt[i]=to[i]=0;
            dep[i]=0;
            for(int j=1;j<=22;j++)
            {
                mx[i][j]=0;
            }
        }
        cnt=0;
        for(register int i=1;i<n;i++) r(x),r(y),add(x,y),add(y,x);//建边。
        dg(1,0,1);
        for(register int j=1;j<=22;j++)
            for(register int i=1;i<=n;i++)
                mx[i][j]=mx[mx[i][j-1]][j-1];//一个点的祖先是父亲的父亲。
        for(register int i=1;i<=m;i++)
        {
            int da=0,db=0;
            ans=2147483647;
            r(x),r(y),r(da),r(db);
            ans=lca(x,y);//判断。
            ans=dep[x]+dep[y]-2*dep[ans];
            if(ans<=da||da>db) printf("Zayin\n");
            else
            {
                if(da<db) printf("Ziyin\n");
                else printf("Draw\n");
            }
        }
    }
    return 0;
}
void read(int &x)
{
    x=0;int ff=1;
    char ch=getchar();
    while (ch<'0'||ch>'9')
    {
        if(ch=='-') ff=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    x*=ff;return;
}
void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return;
}
```

---

## 作者：Guizy (赞：4)

前置知识：[LCA](https://oi.wiki/graph/lca/)

结论题。

先给结论：谁步长大谁就获胜，步长一样就平局。

证明：步长大的那一个总能移动一定距离，使自己可以抓到对方而对方抓不到自己。最后可以把对方逼到一个死角然后抓住。

特殊情况：先手有可能第一步就抓到对方，这时输出 `Zayin`。

这里判断先手第一步是否能抓到对方用倍增 LCA 实现。

**不要用 memset 清空**，上次用多少就清多少，否则会超时。

这里使用链式前向星存图，有略微卡常。

```cpp
#include<bits/stdc++.h>
#define Max 1000001
using namespace std;

int n,m,root,head[Max];
int fa[25][Max],dep[Max];
int cnt,vis[Max];
struct graph{
	int to,nxt;
}edge[Max<<1];

void adde(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
}

void dfs(int now,int pre){
	vis[now]=1;
	for(int i=head[now];i;i=edge[i].nxt){
		if(!vis[edge[i].to]){
			dep[edge[i].to]=dep[now]+1;
			fa[0][edge[i].to]=now;
			dfs(edge[i].to,now);
		}
	}
}

void init(){
	for(int i=1;i<=log2(n);i++)
		for(int j=1;j<=n;j++)
			fa[i][j]=fa[i-1][fa[i-1][j]];
	return;
}

int lca(int x,int y){
	
	int ans=0;
	
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=log2(n);i>=0;i--)
		if(dep[fa[i][x]]>=dep[y])
			x=fa[i][x],ans+=1<<i;
	
	if(x==y) return ans;
	
	for(int i=log2(n);i>=0;i--){
		if(fa[i][x]!=fa[i][y]){
			x=fa[i][x],y=fa[i][y];
			ans+=(1<<(i+1));
		}
	}
	return ans+2;
}

void read(int&x){
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+ch-48,ch=getchar();
}

int main(){
	
//	freopen("game.in","r",stdin);
//	freopen("game.out","w",stdout);
	
	int d,t;
	read(d),read(t);
	
	while(t--){
		int u,v,a,b,da,db,q;
		cnt=0;
		for(int i=0;i<=n;i++){
			head[i]=0,edge[i]={0,0};
			edge[i+n]={0,0},vis[i]=0;
		}
		
		read(n),read(q);
		for(int i=1;i<n;i++){
			read(u),read(v);
			adde(u,v),adde(v,u);
		}
		
		dep[1]=1;
		dfs(1,0);
		init();
		
		for(int i=1;i<=q;i++){
			read(a),read(b),read(da),read(db);
			if(lca(a,b)<=da) puts("Zayin");
			else if(da<db) puts("Ziyin");
			else if(da>db) puts("Zayin");
			else puts("Draw");
		}
	}
	return 0;
}
```

---

## 作者：This_Rrhar (赞：2)

最优策略：在保证移动后距离大于对方最大移动距离时尽量移动。

首先用 LCA 求两点的距离 $dis$。

如果 $da\ge dis$，那么 $\text{Zayin}$ 可以闪击 $\text{Ziyin}$。

如果 $da>db$，那么存在某次移动后 $da\ge dis>db$，$\text{Zayin}$ 胜。

如果 $da=db$，那么存在某次移动后 $da=dis=db$，平局。

如果 $da<db$，那么存在某次移动后 $db\ge dis>da$，$\text{Ziyin}$ 胜。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _r return*this
#define _o &operator
namespace IO
{
	const int _S=1<<21;
	char b[_S],*p1=b,*p2=b,pb[_S],*pp=pb;
	void fl(){fwrite(pb,1,pp-pb,stdout),pp=pb;}
	struct input
	{
		char gc(){if(p1==p2)p2=(p1=b)+fread(b,1,_S,stdin);return p1==p2?' ':*p1++;}
		input _o>>(char&num){do num=gc();while(num==' '||num=='\n'||num=='\r'||num=='\t');_r;}
		template<typename T>input _o>>(T&x)
		{
			char c=gc();T f=1;
			for(x=0;!isdigit(c);)(c=='-'?f=-1:1),c=gc();
			while(isdigit(c))x=(x*10)+(c^48),c=gc();
			x*=f;_r;
		}
		input(){}
	}in;
	struct output
	{
		void pt(char num){*pp++=num;if(pp-pb==_S)fl();}
		output _o<<(char num){pt(num);_r;}
		template<typename T>output _o<<(T x)
		{
			if(!x){pt(48);_r;}
			if(x<0)pt('-'),x=-x;
			int s[64],t=0;
			while(x)s[++t]=x%10,x/=10;
			while(t)pt(s[t--]+48);
			_r;
		}
		output _o<<(const char*s){int num=0;while(s[num])pt(s[num++]);_r;}
		output(){}
	}out;
	struct fe{~fe(){fl();}}fls;
}
using IO::in;
using IO::out;
using ll=int;

#define N 1000001

ll D,T,n,q,lg;

ll x,y;

ll a,b,da,db;

vector<ll>e[N];

ll dep[N],dp[N][20];
void dfs(ll u,ll f)
{
	dep[u]=dep[f]+1,dp[u][0]=f;
	for(int j=1;j<=lg;j++)dp[u][j]=dp[dp[u][j-1]][j-1];
	for(ll v:e[u])if(v!=f)dfs(v,u);
}
ll LCA(ll x,ll y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i=lg;i>=0;i--)if(dep[dp[x][i]]>=dep[y])x=dp[x][i];
	if(x==y)return x;
	for(int i=lg;i>=0;i--)if(dp[x][i]!=dp[y][i])x=dp[x][i],y=dp[y][i];
	return dp[x][0];
}

const char*final[]={"Zayin\n","Ziyin\n","Draw\n"};
ll play(ll dis)
{
	if(da>=dis||da>db)return 0;
	if(da==db)return 2;
	return 1;
}

void destory()
{
	lg=log2(n);
	for(int i=1;i<=n;i++)e[i].clear();
	for(int i=1;i<=n;i++)for(int j=0;j<=lg;j++)dp[i][j]=0;
}
int main()
{
	in>>D>>T;
	while(T--)
	{
		in>>n>>q,destory();
		for(int i=1;i<n;i++)in>>x>>y,e[x].push_back(y),e[y].push_back(x);
		dfs(1,0);
		while(q--)in>>a>>b>>da>>db,out<<final[play(dep[a]+dep[b]-dep[LCA(a,b)]*2)];
	}
}
```

---

## 作者：0_lan_0 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P10076)
#    题目大意  
  给一棵树，两人在**树**的点上移动，每次第一个人可移动 $[0,da]$ 步，每次另一个人可移动 $[0,db]$ 步，两人都用最优策略，一个人移动到对方的点则为胜利，可能平局。
#   思路
 有两种情况

用倍增 lca 求出 $dis$ 为两人一开始的距离

### 当 $dis \le da$ 时（即第一个人在第一轮直接移动到对方的点）
此时第一个人胜利，输出Zayin
### 当 $dis > da$ 时（即第一个人无法在第一轮直接移动到对方的点）
此时两人都用最优策略移动，因为他们在**树**上移动，所以移动距离小的一定会退到死角，最终失败。

 如果 $ da = db$  此时平局，输出 Draw。
 
 如果 $ da > db$  此时第一个人胜利，输出 Zayin。
 
 如果 $ da < db$  此时第二个人胜利，输出 Ziyin。
 
  最后附上代码
#    Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-'){
            f=-1;
        }
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-48;c=getchar();
    }
    return x*f;
}
vector<int>edge[N];
int o,t,n,q,u,v,a,b,c,d,p,dep[N],f[N][21],log2n;
bool flag; 
void dfs(int x,int fa){
    dep[x]=dep[fa]+1,f[x][0]=fa;
    for(int i=1;(1<<i)<=dep[x];i++)
        f[x][i]=f[f[x][i-1]][i-1];
    for(int i=0;i<edge[x].size();i++){
        v=edge[x][i];
        if(v!=fa) dfs(v,x);
    }
}
int LCA(int x,int y){
    if(dep[x]>dep[y]) swap(x,y);
    for(int i=log2n;i>=0;i--)
        if(dep[f[y][i]]>=dep[x]) y=f[y][i];
    if(x==y) return x;
    for(int i=log2n;i>=0;i--)
        if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    return f[y][0];
}
int main(){
    //freopen("game.in","r",stdin);
    //freopen("game.out","w",stdout); 
    o=read(),t=read();
    while(t--){
        n=read(),q=read();
        memset(dep,0,sizeof(dep));
        log2n=int(log2(n))+1;//减少耗时
        for(int i=1;i<=n;i++){
        	edge[i].clear();
            for(int j=1;j<=log2n;j++){
                f[i][j]=0;
            }
        }
        for(int i=1;i<n;i++){
            u=read(),v=read();
            edge[u].push_back(v);
            edge[v].push_back(u);
        }
        dfs(1,0);
        for(int i=1;i<=q;i++){
            a=read(),b=read(),c=read(),d=read();
            int dis=dep[a]+dep[b]-2*dep[LCA(a,b)];
            if(dis<=c||c>d) printf("Zayin\n");
            else if(c==d) printf("Draw\n");
            else printf("Ziyin\n");
        }
    }
    return 0;
}
```

   
 
  

---

## 作者：yyrwlj (赞：2)

学校模拟赛 vp 了普及组第二天，喜提 $100+60+85+16=261$，可惜没去现场。

## 题意简述

给定一棵树，再给出树上两点的位置。两点交替移动，第一个点每次可以移动 $[0, da]$ 步，第二个点每次可以移动 $[0, db]$ 步。

当一个点移动到另一个点的位置上时，该点获胜。

问哪个点会获胜，或告知平局。

## 思路

我们分情况讨论。

下文 $dist$ 表示两点的距离。

### 开始时第一个点就能移动到第二个点的位置上

那么就说明 $dis \le da$，倍增 LCA 求解两点距离即可。

这种情况肯定是第一个点获胜。

### $da = db$

显然，当第一个点移动到再移动一次就能满足 $dis \le da$ 的位置时，此时必然也满足 $dis \le db$。

而且，第一个点移动之后，就轮到第二个点移动了，因为 $dis \le db$。所以第二个点就可以直接移动到当前第一个点的位置。第一个点肯定不希望这种事情发生。

所以两个点永远都不会让 $dis \le da$ 满足，肯定是平局。

### $da > db$

那么就肯定存在满足第一个点移动后，$db < dis \le da$ 的情况。

此时第二个点无法移动到第一个点，而且若不移动到第一个点的移动范围外，再轮到第一个点移动时，就会让第一个点移动到自己的位置上。

所以第二个点就只能躲避第一个点。

但是树上不存在环，躲到最后肯定会无路可逃，所以这种情况肯定是第一个点赢。

### $db > da$

由上个情况同理可证：这种情况肯定是第二个点赢。

## Code

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1000005;
struct Edge{
    int to, nxt;
}g[N << 1];
int h[N], idx;
int dep[N], f[N][18];
void add(int a,int b)
{
    g[++idx].to = b, g[idx].nxt = h[a], h[a] = idx;
}
void dfs(int u,int fa)
{
    for (int i = h[u]; i; i = g[i].nxt)
    {
        int j = g[i].to;
        if (j == fa)
            continue;
        dep[j] = dep[u] + 1;
        f[j][0] = u;
        for (int k=1;k<18;k++)
            f[j][k] = f[f[j][k - 1]][k - 1];
        dfs(j, u);
    }
}
int lca(int a,int b)
{
    if (dep[a] < dep[b])
        swap(a, b);
    for (int i=17;i>=0;i--)
        if (dep[f[a][i]] >= dep[b])
            a = f[a][i];
    if (a == b)
        return a;
    for (int i=17;i>=0;i--)
        if (f[a][i] != f[b][i])
        {
            a = f[a][i];
            b = f[b][i];
        }
    return f[a][0];
}
inline int dist(int a,int b)
{
    return dep[a] + dep[b] - 2 * dep[lca(a, b)];
}
int main()
{
    int T;
    scanf("%*d%d", &T);
    while (T--)
    {
        int n, q;
        scanf("%d%d", &n, &q);
        for (int i=1;i<=n;i++)
            h[i] = 0;
        idx = 0;
        for (int i=1;i<n;i++)
        {
            int a, b;
            scanf("%d%d", &a, &b);
            add(a, b);
            add(b, a);
        }
        dfs(1, 1);
        while (q--)
        {
            int a, b, da, db;
            scanf("%d%d%d%d", &a, &b, &da, &db);
            if (dist(a, b) <= da)
                puts("Zayin");
            else if (da == db)
                puts("Draw");
            else if (da > db)
                puts("Zayin");
            else
                puts("Ziyin");
        }
    }
    return 0;
}
```

---

## 作者：xiaofu15191 (赞：1)

在现场，赛时没有 AC qaq。

思路实际上很简单：

令 Zayin 到 Ziyin 的距离为 $dis$，则：

- 如果 $da > dis$，Zayin 先走，一下就可以闪击 Ziyin，Zayin 赢；

- 如果 $da > db$，也是 Zayin 赢，因为先手距离更长，有优势，Ziyin 不能一下秒掉 Zayin，Zayin 却可以耗死 Ziyin；

- 反过来 $db > da$ 同理；

- 如果 $da = db$，两个人都不能一步秒掉对方，两个人会互相僵持。

所以，只要用简单的方法维护树上距离即可 AC。

树剖求距离 Code：

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
vector<int>graph[1000010];
int n,q,tree[4000010],a,b,da,db,dep[1000010],dfn[1000010],son[1000010],siz[1000010],top[1000010],father[1000010],sum;
void dfs1(int now,int fa,int depth)
{
	father[now]=fa;
	siz[now]=1;
	dep[now]=depth;
	int tmp=0;
	for(auto to:graph[now])
	{
		if(siz[to]!=0) continue;
		dfs1(to,now,depth+1);
		siz[now]+=siz[to];
		if(siz[to]>tmp)
		{
			tmp=siz[to];
			son[now]=to;
		}
	}
}
void dfs2(int now,int root) 
{
	dfn[now]=++sum;
	top[now]=root;
	if(son[now]) dfs2(son[now],root);
	for(auto to:graph[now])
		if(to!=father[now]&&to!=son[now])
			dfs2(to,to);
}
long long distance(long long x,long long y)
{
	long long x2=x,y2=y;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]]) x=father[top[x]];
		else y=father[top[y]];
	}
	long long LCA;
	if(dep[x]<dep[y]) LCA=x;
	else LCA=y;
	if(LCA==x2) return dep[y2]-dep[LCA];
	else if(LCA==y2) return dep[x2]-dep[LCA];
	else return dep[x2]-dep[LCA]+dep[y2]-dep[LCA];
}
int main()
{
	freopen("game.in","r",stdin);
	freopen("game.out","w",stdout);
	int d,t;
	scanf("%d%d",&d,&t);
	while(t--)
	{
		scanf("%d%d",&n,&q);
		for(int i=1;i<=n;i++) graph[i].clear(),son[i]=0,siz[i]=0;
		for(int i=1;i<n;i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			graph[x].push_back(y);
			graph[y].push_back(x);
		}
		sum=0;
		dfs1(1,1,1);
		dfs2(1,1);
		for(int i=1;i<=q;i++)
		{
			scanf("%d%d%d%d",&a,&b,&da,&db);
			int dis=distance(a,b);
			if(da>=dis) printf("Zayin\n");
			else if(da>db) printf("Zayin\n");
			else if(da<db) printf("Ziyin\n");
			else printf("Draw\n");
		}
	}
}
```

注：赛时没有 AC 是因为自己不会倍增 LCA，只会树剖，结果多测 ``memset`` 太多，直接被卡成了 TLE50。

---

## 作者：Little_Cart (赞：1)

学校 vp 了这场，说是这场有难度，做了一会确实，每道拎出来都可以当 CF div2 的一道 D 或 E 了。然后这题我讲的。

### 一句话题意：

两个点交替在树上移动，每条边边权为 $1$，给定两个点的起始位置以及他们每次最多移动的距离，移动到对方的位置即为胜利，问那个点获胜或是平局。

### 思路：

首先肯定需要处理一下树上两点之间的距离，$\sum n ,\sum q \le 10^6$ 的话就考虑倍增 $\text{LCA}$ 一下就行，这里不过多赘述。

如果 $a$ 和 $b$ 的距离不大于 $da$ 的话，那么 $a$ 可以直接移动到 $b$ 的位置，此时 $\text{Zayin}$ 获胜。

剩下的情况分为三种：

如果 $da<db$，那么 $b$ 每回合可以追 $db-da$ 的距离，直到与 $a$ 的距离为 $da+1$，显然如果追的更近会被 $a$ 反杀。

由整数的离散性可知，如果 $da<db$，那么 $da+1 \leq db$，也意味着 $db-da \geq 1$。

所以 $b$ 每回合都能拉进与 $a$ 的距离，直到和 $a$ 的距离为 $da+1$，此时 $b$ 可以一步追上 $a$。

$a$ 此时无法移动到 $b$，所以只能退 $da$ 的距离。

因此，如果 $2\times da+1\leq db$，那么 $b$ 可以追到 $a$ 的位置，否则，$b$ 将无法追上 $a$。

但是这张图是一棵树，并不存在环，所以 $a$ 总会无路可退，此时 $b$ 就可以追到 $a$ 的位置。

综上所述，如果 $da<db$，那么 $b$ 一定能追上 $a$，此时 $\text{Ziyin}$ 获胜。

如果 $da>db$ 同理，这种情况 $a$ 一定能追上 $b$，此时 $\text{Zayin}$ 获胜。

如果 $da=db$，因为此时 $a$ 和 $b$ 的距离一定大于 $da$（不大于的已经讨论过了），所以 $a$ 不能一次就移动到 $b$ 的位置，$b$ 也不能一次就移动到 $a$ 的位置。

如果 $a$ 移动后，$a$ 和 $b$ 的距离不大于 $da$，那么$b$ 可以立刻移动到 $a$ 点所在的位置，使得 $a$ 失败。

$b$ 移动后同理。

所以 $a$ 和 $b$ 的最优策略是保证每次移动后 $a$ 和 $b$ 的距离不大于 $da$，所以此时无人胜利，输出 $\text{Draw}$。

### 代码：

PS：这个代码建议只用于对拍。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define PII pair<int,int>
const int N=1000024,M=2000024;
int d,t,n,q,u,v,root,dep[N],fa[24][N],a,b,da,db,dis,lca;
//string tmp,b;
int nxt[M],head[N],to[M],idx;
void add(int x,int y){
	idx++;
	nxt[idx]=head[x];
	to[idx]=y;
	head[x]=idx;
}
void dfs1(int u){
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa[0][u]) continue;
		fa[0][v]=u;
		dep[v]=dep[u]+1;
		dfs1(v);
	}
}
int Little_CArt(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	if(dep[x]!=dep[y]){
		for(int i=20;i>-1;i--){
			if(dep[fa[i][x]]>dep[y]){
				x=fa[i][x];
			}
		}
		x=fa[0][x];
	}
	if(x!=y){
		for(int i=20;i>-1;i--){
			if(fa[i][x]!=fa[i][y]){
				x=fa[i][x];
				y=fa[i][y];
			}
		}
		x=fa[0][x];
	}
	return x;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>d>>t;
	while(t--){
		cin>>n>>q;
		for(int i=1;i<n;i++){
			cin>>u>>v;
			add(u,v);
			add(v,u);
		}
		root=1;
		dep[root]=1;
		dfs1(root);
		for(int i=1;i<=20;i++){
			for(int j=1;j<=n;j++){
				fa[i][j]=fa[i-1][fa[i-1][j]];
			}
		}
		for(int i=1;i<=q;i++){
			cin>>a>>b>>da>>db;
			lca=Little_CArt(a,b);
			dis=a[dep]+b[dep]-lca[dep]*2;
			if(dis<=da){
				cout<<"Zayin\n";
				continue;
			}
			if(da>db){
				cout<<"Zayin\n";
			}
			else if(da==db){
				cout<<"Draw\n";
			}
			else{
				cout<<"Ziyin\n";
			}
		}
		for(int i=1;i<=n;i++){
			dep[i]=0;
			head[i]=0;
		}
		idx=0;
	}
	return 0;
}
```


---

## 作者：homo_snow (赞：0)

## 结论题

首先要熟悉树的性质：无环。

这代表着什么？

首先，当两人的距离小于任意一人的步长时，答案可以确定。

不然的话，其中一人肯定能将另一人逼入死路。

分两种情况：

如果两人步长相同，那么一人将另一人逼进死胡同后，如果自身再次前进就会被吃，所以这种情况平局。

剩下的情况就是步长大的那个赢。

用 LCA 求一下两点之间的距离即可。

然后这道题就没了。

~~Day2 最水的含金量。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e6+10;
const int INF = 0x3f3f3f3f;
const int MOD =  998244353;

int d,t,n,q,a,b,da,db,deep[N],fa[N][24];
vector<int> v[N];

void dfs(int x,int f){
	deep[x] = deep[f] + 1;
	fa[x][0] = f;
	for(int i = 1; (1 << i) <= deep[x]; i++) fa[x][i] = fa[fa[x][i-1]][i-1];
	for(int i = 0; i < v[x].size(); i++){
		int t = v[x][i];
		if(t == f) continue;
		dfs(t,x);
	}
}

int lca(int x,int y){
	if(deep[x] < deep[y]) swap(x,y);
	int d = deep[x] - deep[y];
	for(int i = 0; (1 <<i) <= d; i++)
		if((1 << i) & d)
			x = fa[x][i];
	if(x == y) return x;
	for(int i = 23; i >= 0; i--)
		if(fa[x][i] != fa[y][i]) 
			x =fa[x][i],y = fa[y][i];
	return fa[x][0];
}

int get_dis(int x,int y){
	int fat = lca(x,y);
	return deep[x] - deep[fat]*2 + deep[y];
}

signed main(){
	scanf("%lld%lld",&d,&t);
	while(t--){
		for(int i = 0; i <= n; i++) v[i].clear(),deep[i] = 0;
		for(int i = 1; i <= n; i++)
			for(int j = 0; j <= 23; j++)
				fa[i][j] = 0;
		scanf("%lld%lld",&n,&q);
		for(int i = 1; i < n; i++){
			int x, y;
			scanf("%lld%lld",&x,&y);
			v[x].push_back(y);
			v[y].push_back(x);
		}
		dfs(1,0);
		while(q--){
			scanf("%lld%lld%lld%lld",&a,&b,&da,&db);
			int dis = get_dis(a,b);
			if(da >= dis) puts("Zayin");
			else if(da == db) puts("Draw");
			else if(da > db) puts("Zayin");
			else puts("Ziyin");
		}
		
	}
}
```


---

## 作者：_JF_ (赞：0)

## P10076 [GDKOI2024 普及组] 捉迷藏 

赛时能 LCA 写挂，难评。

首先考虑先计算出两个人的距离，这个使用 LCA 即可。

首先可以发现，如果一个人击杀了另一个人，在这前一步绝对要控制一个距离使得对面不能攻击到自己，不然就被反杀了。

然后不难发现，如果先手可以一次性解决问题，那么先手胜利。

这时候分类讨论

- 如果 $da>db$，那么先手完全可以控制一个距离，使得 $db$ 没办法直接通过一步秒掉自己，但是自己缺可以一步秒掉他。 ，因为先手可以走的步长大于后手，这是一定可以追上的，先手必胜。

- 同理如果 $da<db$ ，则后手必胜。

- 如果 $da=db$，那么谁都秒不掉谁，因为无法控制可以找到一步可以击杀对方。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
vector<int> g[N<<1]; 
int fa[N][23],dep[N];
int d,t;
void dfs(int u,int fath){
	dep[u]=dep[fath]+1,fa[u][0]=fath;
	for(int i=1;(1<<i)<=dep[u];i++)	fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fath)	continue;
		dfs(v,u);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y])	swap(x,y);
	int d=dep[x]-dep[y];
	for(int i=0;(1<<i)<=d;i++)	if((1<<i)&d)	x=fa[x][i];
	if(x==y)	return x;
	for(int i=22;i>=0;i--)	
		if(fa[x][i]!=fa[y][i])	x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int main(){
//	freopen("game1.in","r",stdin);
//	freopen("game.out","w",stdout);
	cin>>d>>t;
	while(t--){
		int n,q;
		cin>>n>>q;
		for(int i=1,u,v;i<n;i++)	scanf("%d%d",&u,&v),g[u].push_back(v),g[v].push_back(u);
		dfs(1,0);
		while(q--){
			int Zas,Zis,Zal,Zil;
			cin>>Zas>>Zis>>Zal>>Zil;
			int LCA=lca(Zas,Zis);
			int dis=(dep[Zas]-2*dep[LCA]+dep[Zis]);
			if(Zal>=dis)	cout<<"Zayin"<<endl;
			else{
				if(Zal==Zil)	cout<<"Draw"<<endl;
				else if(Zal>Zil)	cout<<"Zayin"<<endl;
				else	cout<<"Ziyin"<<endl;
			}
		}
		for(int i=1;i<=n;i++)	g[i].clear(),dep[i]=0;
		for(int i=1;i<=n;i++)	for(int j=0;j<=22;j++)	fa[i][j]=0;
	}
	return 0;
}
// please clear  victory or lose? 100pts  I will review LCA carefully 
```


---

## 作者：PZYi (赞：0)

# 思路
最优策略：控制与对方的距离使对方不能攻击自己，防止被反杀。

仔细思考一下，我们不难发现以下规律：
- 如果先手的最大移动距离大于等于与敌方的距离，那么可以一步获胜。

- 如果先手的最大移动距离大于敌方的最大移动距离，那么通过最优策略，先手胜。

- 如果两者的最大移动距离相等，平局。

- 否则后者胜。

求两者之间的距离：若 $w$ 为 $a$ 和 $b$ 的最近公共祖先，则 $a$ 和 $b$ 之间的距离为：$dis_{a,b}=depth_a+depth_b-2\times depth_w$.

最后，多测要清空。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
int l[1000010],n,dep[5000010],f[5000010][31],q;
vector<int>a[5000010];
void dfs(int son,int fa)
{
	f[son][0]=fa;
	dep[son]=dep[fa]+1;
	for(int i=1;i<=l[dep[son]];i++) f[son][i]=f[f[son][i-1]][i-1];
	for(int i=0;i<a[son].size();i++)
		if(a[son][i]!=fa) dfs(a[son][i],son);
}
int LCA(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]) x=f[x][l[dep[x]-dep[y]]-1];
	if(x==y) return x;
	for(int i=l[dep[x]-1];i>=0;i--)
		if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void clean()
{
	for(int i=0;i<=n;i++)
	{
		a[i].clear();
		dep[i]=0;
		for(int j=0;j<=30;j++) f[i][j]=0;
	}
}
int main()
{
	int t,d;
	cin>>d>>t;
	for(int i=1;i<=1e6;i++) l[i]=l[i-1]+(1<<l[i-1]==i);
	while(t--)
	{
		scanf("%d%d",&n,&q);
		for(int i=1;i<n;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			a[u].push_back(v);
			a[v].push_back(u);
		}
		dfs(1,0);
		while(q--)
		{
			int x,y,da,db;
			scanf("%d%d%d%d",&x,&y,&da,&db);
			int ans=LCA(x,y);
			int dis=dep[x]-2*dep[ans]+dep[y];
			if(da>=dis) cout<<"Zayin";
			else if(da>db) cout<<"Zayin";
			else if(da==db) cout<<"Draw";
			else cout<<"Ziyin";
			cout<<endl;
		}
		clean();
	}
}
```




---

## 作者：rainygame (赞：0)

感觉没有绿。赛时 10 min 想出来。

这里令 A 表示 Zayin，B 表示 Ziyin。

首先注意到如果两人初始时的距离 $\le da$，那么直接判 A 获胜。

然后，对于 $da=db$ 的情况，A 和 B 的最优策略均为走到对方的距离再远一些的位置，因为这样可以保证自己不被对方吃掉。这样两人最后都是“不输”，因此答案是平局。

然后假设 $da>db$，那么 A 一定会把自己卡在距离 B 恰好远 $db+1$ 的位置，这样可以保证“不输”的同时吃掉对方。而 B 是怎样也不会靠近 A 的，因为这样就更容易被 A 吃掉，所以只能一直加速往后退。因为这是一棵树，所以肯定有退无可退的时候，然后被 A 吃掉。

$db>da$ 同理。

查初始距离直接上树剖 LCA 即可。

[赛时 AC 代码](https://www.luogu.com.cn/paste/fgaykja3)

---


# [GESP样题 八级] 区间

## 题目描述

小杨有一个长度为 $n$ 的正整数序列 $A$。

小杨有 $q$ 次询问。第 $i$ 次（$1\le i\le q$）询问时，小杨会给出 $l_i,r_i,x_i$，请你求出 $x_i$ 在 $A_{l_i}, A_{l_i+1}, \dots A_{r_i}$ 中出现的次数。

## 说明/提示

|子任务|分值|$n$|$q$|$\max A_i$|
|-|-|-|-|-|
|$1$|$30$|$\le 100$|$\le 100$|$\le 10$|
|$2$|$30$|$\le 10^5$|$\le 10^5$|$\le 10^5$|
|$3$|$40$|$\le 10^5$|$\le 10^5$|$\le 10^9$|

对于全部数据，保证有 $1 \leq T\le 5$，$1 \le n,q\le 10^5$，$1 \le A_i\le 10^9$。

## 样例 #1

### 输入

```
2
5
7 4 6 1 1
2
1 2 3
1 5 1
5
1 2 3 4 5
2
5 5 3
1 4 3```

### 输出

```
0
2
0
1```

# 题解

## 作者：huangzixi071018 (赞：22)

# 题目大意：
给定 $n$ 个数，查询 $l$ 到 $r$ 区间中 $x$ 出现的次数。

# 思路：
首先先对 $a$ 数组进行离散化，我是个蒟蒻，啥也想不到，只知道莫队可以处理。最后用基础莫队进行处理一下就可以了。

# 题目推荐：
不会的可以先写一下这一题
[P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)。

顺便推荐一下[P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct node{
	int x,l,r,id;
}d[100005];
int a[100005],b[100005],c[100005],k,m[100005],res[100005];
bool cmp(node x,node y){
	if((x.l/k)!=(y.l/k)){
		return x.l>y.l;
	}
	if(x.l%k){
		return x.r<y.r;
	}
	return x.r>y.r;
}
void add(int x){
	m[a[x]]++;
}
void del(int x){
	m[a[x]]--;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		memset(m,0,sizeof(m));
		int n,len=0,q;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			b[i]=a[i];
		}
		sort(b+1,b+1+n);
		for(int i=1;i<=n;i++){
			if(b[i]==b[i-1]){
				continue;
			}
			c[++len]=b[i];
		}
		for(int i=1;i<=n;i++){
			a[i]=lower_bound(c+1,c+1+len,a[i])-c;
		}
		cin>>q;
		k=sqrt(q);
		for(int i=1;i<=q;i++){
			cin>>d[i].l>>d[i].r>>d[i].x;
			int h=lower_bound(c+1,c+1+len,d[i].x)-c;
			if(c[h]==d[i].x){
				d[i].x=h;
			}else{
				d[i].x=n+1;
			}
			d[i].id=i;
		}
		sort(d+1,d+1+q,cmp);
		int l=0,r=0;
		for(int i=1;i<=q;i++){
			while(d[i].l<l)add(--l);
			while(d[i].l>l)del(l++);
			while(d[i].r<r)del(r--);
			while(d[i].r>r)add(++r);
			res[d[i].id]=m[d[i].x];
		}
		for(int i=1;i<=q;i++){
			cout<<res[i]<<"\n"; 
		}
	}
	return 0;
}
```

---

## 作者：无名之雾 (赞：18)

## 题意

求出 $x$ 在 $r$ 到 $l$ 中的出现次数。

## $30$ pts

显然只需要写一个暴力去统计 $x$ 的出现次数即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
int a[100005];
signed main(){ 
	int t=read();
	while(t--){ 
		int n=read();
		for(int i=1;i<=n;i++)a[i]=read();
		int q=read();
		while(q--){
			int l=read(),r=read(),x=read();
			int cnt=0;
			for(int i=l;i<=r;i++){
				if(a[i]==x)cnt++;
			}
			cout<<cnt<<"\n";
		}
	} 
	return 0;
}
```

## $60$ pts

不难想到可以用一个 `vector` 存储 每种数字出现的位置。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=1e5+5;
int a[N];
signed main(){ 
	int t=read();
	while(t--){ 
		vector<int>b[N];
		int n=read();
		for(int i=1;i<=n;i++){
			a[i]=read();
            b[a[i]].push_back(i);
		}
		int q=read();
		while(q--){
			int l=read(),r=read(),x=read();
			int cnt=0;
			for(int i=0;i<b[x].size();i++){
				if(b[x][i]>=l&&b[x][i]<=r)cnt++;
			}
			cout<<cnt<<"\n";
		}
	} 
	return 0;
}
```


## $100$ pts

观察数据范围，发现 $a_i\le10^9$ 单纯 `vector` 存储会爆掉。所以可以采用 `map` 套 `vector` 来解决。

同时在对于 数字出现次数进行查找时，采用二分的方法降低复杂度。可以直接使用 `lower_bound` 与 `upper_bound`。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=1e5+5;
map<int,vector<int> >mp;
signed main(){ 
	int t=read();
	while(t--){ 
		mp.clear();
		int n=read();
		for(int i=1;i<=n;i++){
			int a=read();
            mp[a].push_back(i);
		}
		int q=read();
		while(q--){
			int l=read(),r=read(),x=read();
			int cnt=upper_bound(mp[x].begin(),mp[x].end(),r)-lower_bound(mp[x].begin(),mp[x].end(),l);
			write(cnt),puts("");
		}
	} 
	return 0;
}
```

---

## 作者：spfa_ (赞：14)

[P10288 [GESP样题 八级] 区间](https://www.luogu.com.cn/problem/P10288)

### 题目分析

首先我们可以将“$[l,r]$ 内有多少 $x$”转化为“多少个 $x$ 在 $[l,r]$ 中”。先将 $a_i$ 离散化一下，然后用 vector 记录每个值所出现的下标。对于询问，用二分求第一个大于等于 $l$ 的下标和小于等于 $r$ 最大的下标，即可求出答案。

### code

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

const int N = 1e5+5;
int n, q, tot, a[N], b[N];

void solve() {
	vi s[N];
	n = rd();
	for (int i = 1; i <= n; ++i) a[i] = b[i] = rd();
	sort(b+1, b+n+1); tot = unique(b+1, b+n+1)-b-1;
	for (int i = 1; i <= n; ++i) a[i] = lower_bound(b+1, b+tot+1, a[i])-b, s[a[i]].pb(i);
	q = rd();
	while (q--) {
		int l = rd(), r = rd(), x = rd();
		int k = lower_bound(b+1, b+tot+1, x)-b;
		if (b[k] != x) { puts("0"); continue; }
		auto i = lower_bound(s[k].begin(), s[k].end(), l), j = --upper_bound(s[k].begin(), s[k].end(), r);
		write(j-i+1), enter;
	}
}

int main() {
	int t = rd();
	while (t--) solve();
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：8)

主席树板题，这里讲一下主席树的板子，本文重点是复习主席树的易错点。

## 为什么需要主席树

一般对主席树的定义是可持久化线段树，但这放到本题和大部分主席树的题目里并不本质，我对主席树的理解是支持一个单点修改，子矩阵查询二维数组的数据结构。

有人可能会觉得可以用二维线段树，但二维线段树主流的四分四叉树写法时间复杂度是不对的，另一种树套树写法是严格强于主席树的，这个东西我会放在最后讲解。

具体的，你可以看一下这个题[【模板】可持久化线段树2](https://www.luogu.com.cn/problem/P3834)

本题是严格若于模板题的，而且我认为如果不是因为本题有更简单的做法其实更适合当作主席树模板题，所以从本题讲起。

## 另一个角度写暴力

假设我强制你使用二维数组，然后忽略掉一切时空限制该怎么做？

其实用坐标系来形容更加贴切，但由于我们习惯的笛卡尔坐标系的 $y$ 轴正方向是上方，与我们一般的二维数组的第一维正方向是下方相反，但其实生活中我们更习惯二维数组而不是笛卡尔坐标系，所以这里默认两个维度的正方向分别是下和右。根据习惯，我们把横着的一维称为第 $2$ 维或者 $i$ 维，竖着的称为第 $1$ 维或者 $j$ 维。本文种将统一使用这样的定义，避免写错导致产生歧义，主要是防止自己绕晕。

根据一般的习惯，我们把 $i$ 维表示下标，$j$ 维表示值，现在，我们就可以用二维数组写暴力了。
```cpp
for(int i=1;i<=n;++i){int j;cin>>j;a[i][j]=1;}
```
对于询问，可以：
```cpp
int j,l,r;cin>>l>>r>>j;int cnt=0;
for(int i=1;i<=r;++i)cnt+=a[i][j];
```
容易发现，这个东西还可以实现形如下标为 $i$ 的位置有 $k_i$ 个数的问题，这个性质后面会用到。

## 对暴力的优化

这里默认大家会前缀和，容易发现，内层循环其实就是一个区间求和，显然可以用前缀和优化到 $O(1)$。

然后这个题好像就过了，但是，如果写个前缀和就能过还要主席树干什么，容易发现，前缀和需要一个很大的数组，而且需要 $O(n^2)$（这里默认已经完成了离散化，且不同元素的个数与 $n$ 同阶）的建立，所以我们不能用这种需要单独建立的数据结构，我们需要可以通过在线插入的数据结构。

什么数据结构可以在线插入？

这个比较多，不好一一列举，但对于处理这种序列上的求和问题的主要有以下几种：

1. 树状数组。

1. 平衡树。

1. 分块。

1. 线段树。

不会的可以自行 bdfs，这些算法都比较基础，网上有很多讲解，甚至在 B 站上有视频讲解，个人认为 B 站上的视频讲解已经不是很书面语了。

来挨个排除一下，树状数组倒是可以，但没法从根本上解决很大的数组的问题，你可以开个 map，但这仅仅只是能够帮你水过这个题，而且卡一下空间就卡掉了，用处不大。

至于平衡树，你写出来就会发现 STL 完全够用了，~~于是有了本题正解，全局终~~，虽然卡不掉，但这仅仅只是能过这个题，可以看一下上面放的主席树模板 2，这和树状数组有一样的问题，当然，你如果会用平衡树实现这种查询第 $k$ 小的操作的话那用线段树你肯定也能写得出来。

最后说一下分块，分块的本质是形态比较特殊的线段树，它是一个只有两层的 $\sqrt n$ 叉树，对于那种必须用分块的题，都是利用了只有两层的性质，这个性质使得我们只需要下传一次标记，但本质上，这还是像一个树状数组那样结构残缺导致功能不全的线段树，虽然分块不太好卡，但是一定有题目能卡掉，而且本题的空间并不宽裕，分块容易被卡空间，最重要的是，你写一下发现，其实分块并不比线段树好写。

所以，一种比较万能，相对好写的办法是用线段树。

## 前置知识

现在介绍一下线段树的一些性质和线段树二分。

首先，我们定义一下线段树加法。

一般地，对于两个有其类型支持加法操作并返回一个类型确定的元素的等长数组 $a$ 和 $b$，我们定义 $a+b$ 为两个数组的各个位置相加生成的数组，定义 $\operatorname{tree}(x)$ 表示维护 $x$ 数组区间和的线段树，则有 $\operatorname{tree}(a+b)=\operatorname{tree}(a)+\operatorname{tree}(b)$。

如果我们要维护的元素在题设的值域内存在加法逆元（一般是支持减法操作），我们可以维护一个“线段树类型”的前缀和数组，容易发现，这个数组一定具有可差分性。

这里先仅考虑维护整数的线段树，因为再难的不太容易出题，也不太好解释，需要先通过整数来理解本质后自行理解。

先假设线段树可以 $O(1)$ 的复制。

那你有了一个想法，建立过程可以这样：

我们定义线段树加一个整数 $x$ 为区间 $[x,x]$ 加 $1$ 后的线段树。

定义线段树的逆元是对其所有元素全都取逆元后的线段树。

定义 $\operatorname{sum}(t,l,r)$ 表示线段树 $t$ 所维护的区间 $[l,r]$ 的和，特别的，$\operatorname{sum}(t,x)$ 表示区间 $[x,x]$ 的和。

$$\operatorname{tree}(t_i)\gets \operatorname{tree}(t_{i-1})+a_i$$

对于每次询问，输出：

$$\operatorname{sum}(\operatorname{tree}(t_r-t_{l-1}),x)$$

于是，你在线段树可以 $O(1)$ 复制的假设下过掉了这个题。

然后再讲一下线段树二分，因为主席树的题一般如果不需要线段树二分都能乱搞搞掉，所以线段树二分会很常用。

不需要**会写正常的二分**作为前置，但是要会二分的思想，假设你~~和我一样~~不会写正常的二分，现在我教你一种不容易写挂，且边界问题好处理的二分写法。

二分的思想是检查中点是否够大，够就找右区间，反之找左区间，现在我告诉你线段树可以不通过区间操作实现单点操作，你可以写出一个递归版的二分。

```cpp
int qry(int l,int r){if(l==r)return l;int m=l+r>>1;return chk(m)?qry(l,m):qry(m+1,r);}
```

chk 表示检查中点够不够大，现在告诉你，这个写法最终找到的点正好是要找的点，不需要加 $1$ 或者减 $1$，于是你得到了一个常数略大但不用处理边界问题的二分模板。

这个东西可以实现单点查改。

修改：
```cpp
#define ls o<<1
#define rs ls|1
int x;
void aa(int o,int l,int r){if(l==r)return ab(o);int m=l+r>>1;return x<=m?aa(ls,l,m):aa(rs,m+1,r);}
```
查询：
```cpp
int qry(int o,int l,int r){if(l==r)return t[o];int m=l+r>>1;return x<=m?qry(ls,l,m):qry(rs,m+1,r);}
```
你也可以用这个实现查询第 $k$ 小的元素，默认你会权值线段树。
```cpp
int qry(int o,int l,int r,int k){if(l==r)return l;int m=l+r>>1;
	return t[ls]>=k?qry(ls,l,m,k):qry(rs,m+1,r,k-t[ls]);}
```
如果你不太理解，那你一定是不理解为什么找到的一定是对的，观察这个程序，可以发现，当左区间的和小于 $k$ 的时候 $k$ 就会减去这个和，只有这样才会往右走，且一定往右走，最后这个 $k$ 一定会变成 $1$，等价于求从某个地方起的最小值，这个就相对好理解，具体的你可以上 WHK 听不下去的时候画一个很大的线段树试一下，我当时学主席树的时候就是这么干的，用大数据试一下是学数据结构学不会的时候最好的方法。

## 如何实现线段树的 $O(1)$ 复制

介绍一个技巧——动态开点，看到这里我估计有人可能被吓走了，我在学 OI 两个月的时候也是被动态开点吓到的导致数据结构止步于主席树，以致于直到去年 $12$ 月才学会，整整间隔了将近一年，但其实动态开点并没有那么吓人，主要是大部分讲解只是提了一句可以动态开点然后展示了一下，但并没有具体讲为什么这样开，那我这里讲一下自己的一点理解。

动态开点实际上就是模拟一个链表，你不要把线段树看成一个整体看一整棵，先只看一个节点，因为实际程序运行的时候就是一个节点一个节点的处理，现在，你走到了一个空节点，你需要给它一个编号，因为动态开点的本质是假设建好了所有节点，然后重新编号，空节点其实并不是真正意义上的空节点，它只是没有编号而已，这样，当你想进左子树而左子树空的时候就大胆的进就行，因为在动态开点意义下，不存在空节点，只有没有编号的节点。

只看一个节点，不存在空节点，这样就好理解了，而且对于理解主席树也有了帮助。

主席树中，一般 $\operatorname{tree}(t_i)$ 比起 $\operatorname{tree}(t_{i-1})$ 只会进行均摊 $O(1)$ 次的修改，每次只会修改 $O(\log n)$ 个点，这个时间复杂度的正确性很显然，如果你不理解说明线段树每学好，建议回去理解一下线段树的时间复杂度，因为修改的点很少，我们可以直接用上一个线段树，这是主流的说法，现在，我们只看单点，假设每个线段树只会对上一个进行一次单点修改。

发现只有两种情况，而且这两种是对称的，会做一个就会做另一个，假设我们要修改的是右子树。

我们在递归的过程中维护一个表示上一个线段树的对应位置节点的指针，发现由于左子树一样，我们可以直接把上一个线段树的左子树当作当前节点的左子树，这一步不需要复制，直接把指向左子树的指针指向上一个线段树对应节点的左子树即可，右子树和上一个线段树的右子树肯定不一样，那就不能用上一个线段树对应节点的右子树。

总之，这就像你网课期间要抄你同学的作业，你要改一个题，你可以把整个文件夹考下来，每次进入你要改的文件夹，如果你的同学没做完，那会出现几个文件夹的名字是“新建文件夹”的情况，如果正好是你要改的题，你需要手动给在这个文件夹起个名字，我们假设你的同学是一个喜欢做表面但半途而废的人，已经建好了所有文件夹，但由于半途而废有的连名字都没起。

一个容易把自己绕进去不理解的地方，万一后面的线段树改掉了前面的线段树怎么办，我上面的比方不是白打的，你虽然拿着你同学的文件夹而且没做任何改变，但这已经是你的文件夹了，你不管怎么改都不会影响你同学的原版，这个时候相当于线段树开了新点，事实上我们可以认为没开新点的也开了新点，只不过编号一样而已。

那这样就能做这个题了。

```cpp
int x;
void add(int&o,int pre,int l,int r){o=++id;t[o]=t[pre]+1,ls[o]=ls[pre],rs[o]=rs[pre];
if(l==r)return;int m=l+r>>1;if(x<=m)add(ls[o],ls[pre],l,m);else add(rs[o],rs[pre],m+1,r);}
```
对于查询，由于我们定义了线段树加法和逆元的返回值都是线段树，所以我们可以得出线段树减法的返回值也是线段树。

对于表示 $\operatorname{tree}(t_r)-\operatorname{tree}(t_{l-1})$ 的某个节点，我们可以用两个同步的指针 $o_l,o_r$ 每次跳到左子树就都跳到左子树，跳到右子树就都跳到右子树，然后用 $t_{o_r}-t_{o_l}$ 表示当前节点。然后其他的都和普通的线段树和线段树二分一模一样，不做单独展示。

现在展示一下主席树模板的完整程序，可能写法和上面不太一样，但是这个东西有很多写法，建议大家对于模板仅仅只是参考一下然后自己选择自己习惯的写法。

```cpp
#include<bits/stdc++.h>
using namespace std;const unsigned N=2e5+1;
#define void inline void
#define int register unsigned
unsigned ls[N<<8],rs[N<<8],t[N<<8],rt[N<<2],cnt,x,a[N],b[N];
void cp(const int &x,const int &y){ls[x]=ls[y],rs[x]=rs[y],t[x]=t[y];}
#define up(o) t[o]=t[ls[o]]+t[rs[o]]
void dpdate(int &o,int &las,int l,int r){if(!o)o=++cnt;
	if(l==r){++t[o];return;};int m=l+r>>1;
	if(x<=m)rs[o]=rs[las],ls[o]=++cnt,cp(ls[o],ls[las]),dpdate(ls[o],ls[las],l  ,m);
	else    ls[o]=ls[las],rs[o]=++cnt,cp(rs[o],rs[las]),dpdate(rs[o],rs[las],m+1,r);
	up(o);}set<unsigned>s;unordered_map<unsigned,unsigned>mp;
inline unsigned qry(int &x,int &y,int l,int r,const int k){
	if(l==r)return l;const int m=l+r>>1,_=t[ls[y]]-t[ls[x]];//cerr<<t[ls[y]]<<' '<<t[ls[x]]<<'\n';
	return _>=k?qry(ls[x],ls[y],l,m,k):qry(rs[x],rs[y],m+1,r,k-_);}
signed main(){ios::sync_with_stdio(0);int n,m,_,id=0;cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>_,s.insert(_),a[i]=_;for(int i:s)mp[i]=++id,b[id]=i;
	for(int i=1;i<=n;++i)x=mp[a[i]],dpdate(rt[i],rt[i-1],1,n);while(m--){int l,r;
		cin>>l>>r>>_;cout<<b[qry(rt[l-1],rt[r],1,n,_)]<<'\n';
	}
}
```
## 主席树的缺点

可以发现，主席树不能处理建好树之后继续修改的问题，因为本质上说主席树是一个前缀和，所以，对于带修问题，可以使用树状数组来维护，这样不需要学新东西，看起来也比较好写，实际上，我个人认为这个东西比较毒瘤，不如写二维线段树的树套树写法。

然后，一定要注意，主席树不能实现下放标记，区间修改要标记永久化。

## 主席树和树套树的应用

可以发现，这是用来维护二维数组单点修改子矩阵查询的东西，有很多问题我们可以通过离散化等操作转化成一个二维问题，然后发现有很多问题就比较好处理了，这种题的思路就是先强制自己用二维数组写个暴力，然后用主席树或者树套树来优化。

下面给出几个例题。

[P4054](https://www.luogu.com.cn/problem/P4054)

[P3157](https://www.luogu.com.cn/problem/P3157)

[P9068](https://www.luogu.com.cn/problem/P9068)

---

## 作者：luxiaomao (赞：5)

## [P10288](https://www.luogu.com.cn/problem/P10288) 离散化和二分的入门应用

最近专攻线段树，然后随机跳题过来发现自己已经成功忘记了 `lower_bound()` 和 `upper_bound()` 的用法，所以写篇题解，权当复习一下。

## Solution

首先是题意：

> 有一个长度为 $n$ 的序列 $A$，给出 $q$ 组询问，每次询问 $A$ 在区间 $[l,r]$ 内有几个 $x$。总共 $T$ 组数据。

题意还是比较~~模板~~简明易懂的。$n \le 10^5$ 的数据范围，首先排除 $O(n^2)$ 的暴力。

不妨把“在区间 $[l,r]$ 内有几个 $x$”转化为“$x$ 在区间 $[l,r]$ 出现了几次”，那么可以考虑对于每一种 $x$ 的值都开一个数组记录每个 $x$ 出现的位置。每次询问时，分别**二分**出区间里最靠左的 $x$ 编号和最靠右的 $x$ 编号，两数相减再加一就是答案了。

但是 $A_i \le 10^9, n \le 10^5$，开一个 $10^9 \times 10^5$ 大小的数组显然是不科学的，那就把 $A_i$ 离散化一下，这样 $A_i \le 10^5$ 了，可是开一个 $10^5 \times 10^5$ 的数组依然吃不消。那么就开 $10^5$ 个 `vector` 喽~

思路到这就推完了。

## Code

请看代码和注释。

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;

int T;
int n,m,q,a[N],b[N];
vector<int> c[N];
//a：原数组  b：离散化的a数组  c:存每个b[i]出现的位置

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i = 1;i <= n;i++)scanf("%d",&a[i]),b[i] = a[i],c[i].clear();
		//多测不清零，__________。
		sort(b+1,b+1+n);
		m = unique(b+1,b+1+n)-b-1;
		for(int i = 1;i <= n;i++)a[i] = lower_bound(b+1,b+m+1,a[i])-b,c[a[i]].push_back(i);
		scanf("%d",&q);
		while(q--)
		{
			int l,r,x,y;
			scanf("%d%d%d",&l,&r,&x);
			y = lower_bound(b+1,b+1+m,x)-b;
			if(b[y] != x)printf("0\n");
			else printf("%d\n",upper_bound(c[y].begin(),c[y].end(),r)-lower_bound(c[y].begin(),c[y].end(),l));
			//这里输出答案其实有一个抵消，就是用“第一个大于r”的位置去减掉“第一个大于等于l”的位置
		}
	}
	return 0;
}
```

用 `STL` 的二分函数的时候还要记得，自己开的数组多是从下标 $1$ 开始用，而 `vector` 是从下标 $0$ 开始用，~~应该没人跟我一样错这些吧~~。

---

## 作者：Nightsky_Stars (赞：4)

# 题目大意：
给定一个长度为 $n$ 的数组 $a$，有 $q$ 次询问，每次询问输出 $l$ 到 $r$ 区间中 $x$ 出现的次数。

# 思路：

现将数组 $a$ 离散化，然后记录一下每个值所出现的下标。
询问时，用二分求解就行了。

# CODE：

```
#include <bits/stdc++.h>
using namespace std;
inline int read(){//快读，不然会TLE
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int a[100010],b[100010];
int main(){
	int t=read();
	while(t--){
		vector<int> s[100010];//vector存下标
		int n=read(),sum;
		for(int i=1;i<=n;i++){
			a[i]=read();
			b[i]=a[i];
		}
		sort(b+1,b+n+1);
		sum=unique(b+1,b+n+1)-b-1;
		for(int i=1;i<=n;i++){//离散化
			a[i]=lower_bound(b+1,b+sum+1,a[i])-b;
			s[a[i]].push_back(i);
		}
		int q=read();
		while(q--){
			int l=read(),r=read(),x=read();
			int k=lower_bound(b+1, b+sum+1,x)-b;
			if(b[k]!=x){
				cout<<"0\n";
				continue; 
			}
			auto g=lower_bound(s[k].begin(),s[k].end(),l),h=--upper_bound(s[k].begin(),s[k].end(),r);//二分求解
			cout<<h-g+1<<"\n";
		}
	}
	return 0;
}
```

最后来推荐我一个很有实力的同学打这题的[题解](https://www.luogu.com/article/4mgghu7j)。

用的是莫队，大家可以来学习一下。

---

## 作者：_zuoqingyuan (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10288)

# 题意简述
原题面已经够直白了

# 思路分析
虽然不是正解，但是我还是想引入一种强大的，可以解决区间静态问题的神仙算法：**莫队**。

## 第一步优化
暴力解法想必十分好像，但是如果令时间复杂度更近一步就很难。不过我们也可以想到一个大致的优化思路：求出第一个询问，然后在第一个询问的基础上回答后续的询问。

什么意思？我们定义一个权值数组 $Cnt$ 和两个指针 $l,r$。$Cnt_i$ 表示 $[l,r]$ 区间内 $i$ 的出现次数。假设我们要回答的询问是 $[L_i,R_i]$。

如果 $l=L_i,r=R_i-k(k<0)$。我们不断另 $r\to r+1$.同时让 $Cnt_{A_r}\to Cnt_{A_r}+1$。表示 $A_r$ 扩展进入了 $[l,r]$ 区间。重复以上操作直到 $r=R_i$。此时的 $Cnt_x$ 即为答案。
```cpp
while(l<ql)cnt[a[l]]--,l++;
while(l>ql)l--,cnt[a[l]]++;
while(r<qr)r++,cnt[a[r]]++;
while(r>qr)cnt[a[r]]--,r--;
```

## 第二步优化
这样做看似大大节省了时间，降低了时间复杂度，但实际上并没有。可以举例
```
100
A1 A2 A3 ... A99 A100
100
1 1 x1
1 100 x2
1 1 x3
1 100 x4
...
```
这样时间复杂度又退回 $O(n^2)$。但是我们可以优化处理询问的顺序，对于上面的例子，我们先处理所有 $[1,1,x_i]$ 的询问，再处理 $[1,100,x_i]$。

不过我们很难猜想到出题人的想法，有没有一种综合的评估方法可以快速的解决这个问题。这就是莫队算法的核心：现将所有询问按左端点排序，然后将其分为 $\sqrt n$ 块。再将块内按照右端点排序。

这样做看似奇怪，但实际上优化了时间。我们把一个询问扩展或缩减的时间称为转移时间。将转移分为以下两种。
- 不同块之间的转移：
任意两个块的第一个和最后一个询问都会发生这种转移，最差情况会到达 $O(n)$。一共 $\sqrt n$ 个块，时间复杂度 $O(n\sqrt n)$
- 同一块内的转移
>1. 左端点转移
>由于被划分同一块内，左端点的移动不超过 $O(\sqrt n)$。一共转移 $n$ 次，时间复杂度 $O(n\sqrt n)$
>
>2. 右端点转移
>由于同一块内右端点单调递增，一次一个块内右端点的转移总共为 $O(n)$。一共 $\sqrt n$ 个块，时间复杂度 $O(n\sqrt n)$

总上，该算法时间复杂度大致为 $O(n\sqrt n)$。可以看更严谨的[证明](https://oi-wiki.org/misc/mo-algo/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)。

```cpp
bool cmp(node a,node b){
	return (a.l/t)^(b.l/t)?(a.l<b.l):(a.r<b.r);
}
```

# Code
记得离散化
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=2e5+10;
int a[N],book[N],n,t,q,cnt[N],ans[N];
struct node{
	int l,r,x,idx;
}p[N];
bool cmp(node a,node b){
	return (a.l/t)^(b.l/t)?(a.l<b.l):((a.l/t)&1?(a.r<b.r):(a.r>b.r));//一个常见的奇偶排序优化，可以思考原理
}
void work(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i),book[i]=a[i];
	t=sqrt(n);
	scanf("%d",&q);
	for(int i=1;i<=q;i++)scanf("%d %d %d",&p[i].l,&p[i].r,&p[i].x),p[i].idx=i,book[n+i]=p[i].x;//一定要把询问也加进来
	sort(p+1,p+1+q,cmp);
	sort(book+1,book+1+n+q);
	int tot=unique(book+1,book+1+n+q)-(book+1);
	for(int i=1;i<=n;i++)a[i]=lower_bound(book+1,book+1+tot,a[i])-book;
	int l=1,r=0;
	for(int i=1;i<=q;i++){
		int x=lower_bound(book+1,book+1+tot,p[i].x)-book,ql=p[i].l,qr=p[i].r;
		while(l<ql)cnt[a[l]]--,l++;
		while(l>ql)l--,cnt[a[l]]++;
		while(r<qr)r++,cnt[a[r]]++;
		while(r>qr)cnt[a[r]]--,r--;
		ans[p[i].idx]=cnt[x];
	}
	for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
	return;
}
void clear(){
	memset(a,0,sizeof(a));
	memset(book,0,sizeof(book));
	memset(cnt,0,sizeof(cnt));
	memset(ans,0,sizeof(ans));
	memset(p,0,sizeof(p));
}
int main(){
	int T;
	cin>>T;
	while(T--){
		work();
		clear();
	}
	return 0;
} 
```
其实可以用主席树快速水掉。

莫队推荐例题：
- [P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)。更好得理解莫队优势。
- [P1494 [国家集训队] 小 Z 的袜子](https://www.luogu.com.cn/problem/P1494)。简单方案计数。
- [P4396 [AHOI2013] 作业](https://www.luogu.com.cn/problem/P4396)。莫队套值域分快。

---

## 作者：哈哈人生 (赞：2)

## 题外话
本篇题解适合蒟蒻食用，大佬还是去写主席树吧。

## 思路
遇到这类区间和数相关的题目，第一感觉肯定是排序完再二分。先把这 $n$ 个数依照“数的大小为第一关键字、数的位置为第二关键字”排序，再在每次查询二分到这个数出现的最左、最右位置，依此计算区间长度即可（用右端点减去左端点再加一）。

## 代码
马蜂良好，益于食用。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,q,al,ar,x;
struct A {
	int a,i;//a为数的大小，i为数的位置
} a[100005];
bool cmp(A a,A b) {
	if(a.a!=b.a)return a.a<b.a;
	else return a.i<b.i;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--) {
		cin>>n;
		for(int i=1; i<=n; i++)cin>>a[i].a,a[i].i=i;
		sort(a+1,a+n+1,cmp);//排序
		cin>>q;
		while(q--) {
			cin>>al>>ar>>x;
			int l=1,r=n,sl=-1,sr=-1;
			while(l<=r) {//二分左端点
				int mid=(l+r)/2;
				if(a[mid].a==x) {
					if(a[mid].i==al) {
						sl=mid;
						break;
					} else if(a[mid].i<al)l=mid+1;
					else {
						if(a[mid].i<=ar)sl=mid;
						r=mid-1;
					}
				} else if(a[mid].a>x)r=mid-1;
				else l=mid+1;
			}
			l=1,r=n;
			while(l<=r) {//二分右端点
				int mid=(l+r)/2;
				if(a[mid].a==x) {
					if(a[mid].i==ar) {
						sr=mid;
						break;
					} else if(a[mid].i>ar)r=mid-1;
					else {
						if(a[mid].i>=al)sr=mid;
						l=mid+1;
					}
				} else if(a[mid].a>x)r=mid-1;
				else l=mid+1;
			}
			if(sl==-1||sr==-1)cout<<0<<"\n";//如果没找到这个数，输出0
			else cout<<sr-sl+1<<"\n";//计算区间长度
		}
	}
	return 0;
}
```

---

## 作者：2022linzhiyi (赞：2)

## 题意
给定一个序列，每次询问一个数在一个区间内出现的次数。
## 思路分析
利用 vector 存储每个数出现的位置，每次询问时二分寻找边界，注意到值域为 $a_i\le10^9$，需要进行离散化或者 map 等操作，后面使用的是 map ~~因为离散化我没调出来~~。

注意：使用 cin/cout 可能会 TLE，没开 O2 也可能会 TLE，应该是我的代码常数太大了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[N];
map<int,vector<int> > maps;
int main()
{
	int t;
	cin >> t;
	while (t --) {
		scanf("%d",&n); maps.clear();
		for (int i=1;i<=n;i++) scanf("%d",&a[i]),maps[a[i]].push_back(i);
		int q;
		cin >> q;
		while (q --) {
			int l,r,x;
			scanf("%d%d%d",&l,&r,&x);
			int p=lower_bound(maps[x].begin(),maps[x].end(),l)-maps[x].begin();
			int q=upper_bound(maps[x].begin(),maps[x].end(),r)-maps[x].begin()-1;
			if (p > r || q < p) cout << "0\n";
			else cout << q-p+1 << '\n';
		}
	}
	return 0;
}
```

---

## 作者：Tomle (赞：2)

# 思路

暴力复杂度 $\mathcal{O}(nq)$，会 TLE。

可以用 map + vector 记录每个数出现的下标，不用离散化，空间 $\mathcal{O}(n)$，$n$ 个数只用存 $n$ 个下标。每次查询用 lower_bound 和 upper_bound 相减。

**多测清空！！！**

cin 好像不行，要用快读。（~~难得的 ccf 高强度数据~~）

```cpp
#include <bits/stdc++.h>
using namespace std;

int t, n, m, q, a[100005], l, r, x;
map <int, vector <int> > mp;

void read(int &a) {
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	a = x * f;
}
int main() {
	read(t);
	while (t--) {
		mp.clear();
		read(n);
		for (int i = 1; i <= n; i++) {
			read(a[i]);
			mp[a[i]].push_back(i);
		}
		read(q);
		while (q--) {
			read(l);
			read(r);
			read(x); 
			cout <<(int)(upper_bound(mp[x].begin(), mp[x].end(), r) - lower_bound(mp[x].begin(), mp[x].end(), l)) << endl;
		}
	}
	return 0;
}
```

---

## 作者：Wy_x (赞：1)

[P10288 [GESP样题 八级] 区间](https://www.luogu.com.cn/problem/P10288)

[My Blog](https://www.luogu.com.cn/article/m28ugcx2)

------------

### Solution：

由题可知，有 $T$ 组数据，每组数据中给出 $n$ 个数字，并伴随着 $q$ 次询问，每次询问需要求区间 $[l,r]$ 内数字 $x$ 的出现次数。

其中，$1 \le T \le 5$，$1 \le n,q \le 10^5$，$1 \le x \le 10^9$。

容易想到，以 $x$ 作为第一维，$x$ 出现的坐标为第二维，建立记录数组。

易知，存储的坐标是由小到大单调递增的，故计算答案时，只需要在第 $x$ 维上进行二分。\
从该维上二分，第一个大于 $r$ 的坐标在数组中的位置（指针）减去第一个大于等于 $l$ 的坐标在数组中的位置（指针）。可证得，该差为非负整数，故直接输出即可。

但由于 $x$ 的范围极大，每一维中的数据量也不定，若建满数组，空间太大。故，在实际代码中，需要用 `map<int,vector<int>> mp;` 代替上述解法中的数组。其余不变。

此外，由于 STL 常数比较大，数据规模也大，使用 `cin` 和 `cout` 容易超时，建议使用快读快写。

------------
### Code:

```cpp
#include<stdio.h>
#include<map>
#include<vector>
#include<algorithm>

inline int read() // 快读
{
	int x=0,c=getchar(),f=0;
	for(;c<'0'||c>'9';f=c=='-',c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c^48);
	return f?-x:x;
}

inline void write(int x) // 快写
{
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

using std::map;
using std::vector;

void solve()
{
	map<int,vector<int>> mp;
	//记录数字 x 出现的下标
	int n=read(),q;
	
	for(int i=1;i<=n;i++)// 输入 x 并推入 mp[x] 中
		mp[read()].push_back(i);
	
	q=read();
	while(q--)
	{
		int l=read(),r=read(),x=read();
		//输入[l,r]和数字 x
		
		//二分求数量
		//令指针相减，得出区间长度
		write(upper_bound(mp[x].begin(),mp[x].end(),r)
		-lower_bound(mp[x].begin(),mp[x].end(),l));
		
		putchar('\n');
	}
}

signed main()
{
	int t=read();//t 组数据 
	while(t--) solve();
	
	return 0;
}
```

---


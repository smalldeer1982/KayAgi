# [SHUPC 2024] 为美好的世界献上爆焰！

## 题目背景

小 A 目前正在带着小 B 进行攻打魔王城的每日一爆演练。

## 题目描述

具体来说，魔王城的结界护盾共有 $x$ 的血量，小A想在 $n$ 天内完成对魔王城护盾的破坏。每天小 B 的魔力值会恢复至 $m$ ，且魔力值的上限为 $M$ ，使用爆裂魔法时每 $1$ 点魔力值可以对魔王城护盾造成 $1$ 点伤害。当然，爆裂魔法每天只能使用一次。

为了确保小 B 可以造成充足的伤害，小 A 每天可以花钱去商店购买魔晶石为小 B 增加魔力值。但是商店每天出售的魔晶石的数量、价格、和魔力值都有所不同。且当天出售的**魔晶石只能当天使用**，不然会过期，无法补充魔力。小A现在想知道，如果要小 B 能够顺利爆破魔王城的护盾，最少需要花费多少钱？（如果无法完成破坏，则输出 `-1`）

**注意**：由于小 B 的魔力值具有上限，因此当魔晶石魔力含量 $h$ 加上小 B 当前魔力值 $m$ 大于等于 $M$ 时，使用该魔晶石只能使小 B 的魔力值变为 $M$ ，也就是说 $ m'=\min(M,m+h)$ 。

## 说明/提示

样例解释：

样例 1 中，可以选择购买第一天的第一个魔晶石，花费为 $1$，当天总魔力值为 $8$。再购买第二天的第一个魔晶石，花费为 $1$，当天总魔力值为 $9$。这样两天总共可以造成 $17$ 点伤害，成功破坏结界，且花费最少为 $2$。

样例 2 中，因为存在魔力值上限，因此第一天最多造成 $10$ 点伤害，而第二天最多造成 $9$ 点伤害，因此无法破坏结界。

## 样例 #1

### 输入

```
2 17 10 6
3
1 1 2
2 1 7
2
1 2
3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
2 20 10 8
3
10 2 3
8 2 1
1
1
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 17 10 9
3
1 1 2
2 2 7
2
1 2
3 4```

### 输出

```
0```

# 题解

## 作者：jhdrgfj (赞：7)

昨晚刚把素晴第十五卷看完，准备看爆炎最后一卷。灌水时看到这个题很激动。

## 解法

我们不妨称小 A 为和真，小 B 为惠惠。

一个很显然的想法是，设 $f_{i,j}$ 为第 $i$ 天对魔王城造成 $j$ 点伤害时和真所需的最小代价，则最终答案为 $f_{n,x}$。

但是我们需要考虑到魔晶石对惠惠魔力造成的影响，因为每天魔晶石与魔力都是独立的，所以我们考虑对每一天单独 dp。考虑设 $g_i$ 为当天将惠惠的魔力补充至 $i$ 时和真所需的最小代价，那么显然有 $g_i=0 \ (0\le i \le m)$。

我们可以将每个魔晶石的价格看成体积，魔力看成价值。求 $g_i$ 便转化成了一个 01 背包问题，但是做 01 背包时价值如果枚举到惠惠的魔力上限会变成 $O(nM\sum num)$，无法接受。注意到 $\sum h\le5000$，故价值只要枚举到 $\min(\sum h_i + m,M)$ 就行了。

现在我们求出了 $g$，考虑如何求出 $f_i$。我们枚举 $j$，再枚举惠惠今天的魔力。也就是 $f_{i,j}=\min\{f_{i,j-k}+g_k\} \ (m \le k \le \sum h_i)$。

然后本题就做完了。

## 代码
```cpp
#include<bits/stdc++.h>
#define Explosion 1145141919810ll
#define int long long
using namespace std;
int dp1[5005],dp2[5005],n,x,s,m,w[5005],v[5005];
//dp1 对应 f，dp2 对应 g
//dp1 用了滚动数组优化
signed main()
{
	cin>>n>>x>>s>>m;
	for (int i=1;i<=x;i++){
		dp1[i]=Explosion;
	}
  //以下是上述的转移
	for (int i=1;i<=n;i++){
		int u,konosuba=0;
		cin>>u;
		for (int j=1;j<=u;j++){
			cin>>v[j];
		}
		for (int j=1;j<=u;j++){
			cin>>w[j];
			konosuba+=w[j];
		}
		for (int j=m+1;j<=s;j++){
			dp2[j]=Explosion;
		}
		konosuba=min(konosuba+m,s);
		for (int j=1;j<=u;j++){
			for (int k=konosuba;k>=w[j];k--){
				dp2[k]=min(dp2[k],dp2[k-w[j]]+v[j]);
			}
		}
		for (int j=x;j>=0;j--){
			for (int k=m;k<=konosuba;k++){
				dp1[j]=min(dp1[j],dp1[max(j-k,0ll)]+dp2[k]);
              //max(j-k,0ll) 防止出现负数 
			}
		}
	}
	cout<<(dp1[x]==Explosion?-1:dp1[x]);
}
// Explosion！
```

##

说句题外话，素晴第三季四天后就播出了，真好。希望有生之年能看到素晴第四季和爆炎第二季。

---

## 作者：Fisher9 (赞：1)

**题意理解**

这道题其实就是一个 dp 问题，要花费最少的钱数攻破魔王城护盾，魔法石不能留到第二天可以当成是每天可以花费一定量的钱数来获得一定价值，问最少需要多少钱才能获得足够价值。

**步骤**

因为每天魔力值有上限，魔法石不能到第二天，所以可以对每天进行单独的处理，转化为一个背包 dp 问题，可以设每一天中想要造成 $i$ 的伤害，最少需要 $f2[i]$ 的钱数。由题目限制条件可知这些天总共至多有 5000 个魔晶石，所以时间复杂度是可以的。下面是这部分代码。
```cpp
cin>>c;//魔晶石数量
zh=0;
for(int j=1;j<=c;j++){
    cin>>mf[j][0];//魔晶石价格
}
for(int j=1;j<=c;j++){
    cin>>mf[j][1];//魔晶石所补充魔力
    zh+=mf[j][1];//计算当天魔晶石所能补充魔力上限
}
for(int j=m+1;j<=M;j++){
    f2[j]=MAXN;
}
zh=min(zh+m,M);//魔力值上限
for(int j=1;j<=c;j++){
    for(int k=zh;k>=mf[j][1];k--){
        f2[k]=min(f2[k],f2[k-mf[j][1]]+mf[j][0]);//状态转移
    }
}
```
写这部分代码时调了挺久，~太久没做 dp 了~，感谢 @jhdrgfj 的思路。

处理完每天的情况后问题变为了在 $n$ 天中，每天可以花一定的钱造成一定的伤害，然后再进行一次背包 dp 即可。这里 $f1[j]$ 表示当前想要造成 $j$ 的伤害所需的最小代价。
```cpp
for(int j=x;j>=0;j--){
    for(int k=m;k<=zh;k++){
        f1[j]=min(f1[j],f1[max(j-k,zero)]+f2[k]);
        //zero=0，防止出现负数导致RE
    }
}
```
最后附上 [AC 记录](https://www.luogu.com.cn/record/228898253)。

---

## 作者：Mierstan085 (赞：1)

有点小难的 DP，刚开始没思路，然后没忍住看了题解，所以要感谢 @jhdrgfj 大佬提供的思路。

# 状态设计

这道题目就是难在这里（吧），如果你一眼就看出来了就当我没说。

我们设 $f_{i_j}$ 代表了第 $i$ 天造成 $j$ 点伤害小 A 需要的最小代价，最终答案为 $f_{n_x}$。

但是我们要考虑到魔晶石对小 B 的影响。

由于每一天的魔晶石与魔力都相互独立，我们可以对单独一天 DP。

考虑 $g_i$，其代表当天小 B 的魔力补充到 $i$ 小 A 需要付出的最小代价，显然，对于所有的 $0 \le i \le m$，有 $g_i = 0$。

不妨对魔晶石做 01 背包。但是注意到，如果做背包时枚举到小 B 的体力值上限，时间复杂度会变为 $\Omicron(nM\sum\text{num})$，显然是无法接受的。于是发现 $\sum h \le 5000$，于是考虑枚举到 $\min (\sum h_i + m, M)$ 即可。

我们已经求出 $g$，现在考虑 $f_i$。

可以考虑枚举 $j$，再枚举小 B 今天的魔力值。动态转移方程为 $f_{i_j} = \min\{f_{i, j - k} + g_k\}(m \le k \le \sum h_i)$。

# 代码

```cpp
#include <bits/stdc++.h>
#define INF LONG_LONG_MAX
#define int long long
using namespace std;

int dp[2][5005], w[5005], v[5005];
signed main(){
    int n, x, s, m;
    cin >> n >> x >> s >> m;
    
    for (int i = 1; i <= x; i ++){
        dp[0][i] = INF;
    }
    
    for (int i = 1; i <= n; i ++){
        int u, sumw = 0;
        cin >> u;
        
        for (int j = 1; j <= u; j ++){
            cin >> v[j];
        }for (int j = 1; j <= u; j ++){
            cin >> w[j];
            sumw += w[j];
        }for (int j = m + 1; j <= s; j ++){
            dp[1][j] = INF;
        }
        
        sumw = min(sumw + m, s);
        
        for (int j = 1; j <= u; j ++){
            for (int k = sumw; k >= w[j]; k --){
                dp[1][k] = min(dp[1][k], dp[1][k - w[j]] + v[j]);
            }
        }for (int j = x; j >= 0; j --){
            for (int k = m; k <= sumw; k ++){
                dp[0][j] = min(dp[0][j], dp[0][max(j - k, 0ll)] + dp[1][k]);
            }
        }
    }
    
    cout << (dp[0][x] == INF ? -1 : dp[0][x]);
}
```

完结撒花！最后再次感谢 @jhdrgfj 的思路！

---

## 作者：wzy0 (赞：0)

我们读题分析。 \
第一段相当于是说，我们每天可以无代价造成 $m$ 点伤害，最多造成 $M$ 点伤害。要求在 $n$ 天内造成至少 $x$ 点伤害。 \
第二段是说，我们第 $i$ 天有 $num_i$ 种加成，每种加成付出 $p_{i,j}$ 的代价，多造成 $h_{i,j}$ 点伤害，加成只限当天。 \
要求是计算出最小的代价。

我们发现，这个题很像 dp，但是不同天之间不能一起计算贡献。 \
所以考虑对于每一天分开计算贡献。

我们设 $in_{i,j}$ 为考虑前 $i$ 天要造成 $j$ 点伤害的最小代价；$dp_i$ 为当天造成 $i$ 点伤害的的最小代价。 \
答案就是 $in_{n,x}$。

在加入一个 $h_0 = m , p_0 = 0$ 后，我们发现，求 $dp_i$ 就变成了一个01背包问题。 \
而 $in_{i,j} = \min \{ in_{i-1,j-k}+dp_{i,k} \}$。也就可以求出答案。

但是，如果这样直接计算，时间复杂度为 $O(n M \sum num_i + n x M)$，$n^3$ 级别，显然无法通过。 \
所以我们考虑优化，发现题目要求 $\sum h \le 5000$。于是考虑在枚举 $dp_i$ 的时候，$i$ 只枚举到 $\sum h_j$ 。 \
这样，时间复杂度优化到 $n^2$ 级别，可以通过。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

const long long ax=10000000000000016;
long long n,x,M,m,in[5003];
long long g,l,p[5003],h[5003],dp[5003];

int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>x>>M>>m;
	for(int i=1;i<=x;i++)in[i]=ax;
	for(int i=1;i<=n;i++){
		cin>>g;l=0;
		for(int j=1;j<=g;j++)cin>>p[j];
		for(int j=1;j<=g;j++)cin>>h[j],l+=h[j];
		l=min(l+m,M);
		for(int j=m+1;j<=M;j++)dp[j]=ax;
		for(int j=1;j<=g;j++){
			for(int k=l;k>=h[j];k--){
				dp[k]=min(dp[k],dp[k-h[j]]+p[j]);
			}
		}
		for(int j=x;j>0;j--){
			for(int k=m;k<=l;k++){
				in[j]=min(in[j],in[max(j-k,0)]+dp[k]);
			}
		}
	}
	if(in[x]==ax)cout<<-1;
	else cout<<in[x];
	return 0;
}
```

---

## 作者：__maqiyue (赞：0)

美好的一天从写题解开始。
```
感谢 @jhdrgfj 的思路
```
## 思路
很显然，设 $f_{i,j}$ 为在第 $i$ 天造成 $j$ 点伤害。

但是，每一天都是一个 01 背包，任意两天的魔力值都是互不影响的，所以考虑每一天一次 dp。  
设 $f_i$ 为将魔力值提高到 $i$ 的最小花费（当天），就是求 01 背包。
## code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define MAX 1145141818810ll
//照楼上
int n, x, s, m, f1[5010], f2[5010], w[5010], v[5010];
signed main()
{
	cin >> n >> x >> s >> m;
	for(int i = 1; i <= x; i++)
		f1[i] = MAX;
	for(int i = 1; i <= n; i++)
	{
		for(int j = m + 1; j <= s; j++)//f2需要每次清理
			f2[j] = MAX;
		int N, sum = 0;
		cin >> N;
		for(int j = 1; j <= N; j++)
			cin >> v[j];
		for(int j = 1; j <= N; j++)
			cin >> w[j], sum += w[j];
		sum = min(sum + m, s);
		/*更新f2*/
		for(int j = 1; j <= N; j++)
			for(int k = sum; k >= w[j]; k--)
				f2[k] = min(f2[k], f2[k - w[j]] + v[j]);
		/*更新f1*/
		for(int j = x; j >= 0; j--)
			for(int k = m; k <= sum; k++)
				f1[j] = min(f1[j], f1[max(j - k, 0ll)] + f2[k]);//max(j - k, 0ll)防止可能出现负数
	}
	cout << (f1[x] == MAX ? -1 : f1[x]);
	return 0;
}
```

---


# [PA 2024] Mrówki

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda próbna [Mrówki](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/mro/)**

数轴上有 $n$ 只蚂蚁，第 $i$ 只位于点 $x=i$。每只蚂蚁面向右（数轴的正方向）或者向左（数轴正方向的反方向）。蚂蚁小到我们可以认为他们是独立的点。

信号发出后，所有蚂蚁开始以相同的单位速度朝它们面向的方向前进。如果两只蚂蚁相撞（位于同一点），它们就会弹开，也就是说，它们都会改变行进方向，继续前进。可以证明，经过一定时间后，不会再发生碰撞。你能编写一个程序，计算出每只蚂蚁会与其他蚂蚁碰撞多少次吗？

## 说明/提示

第一只蚂蚁一开始面向左，不会与其他蚂蚁碰撞。最后一只蚂蚁会在 $x=5.5$ 处与第五只蚂蚁相撞，然后开始向右行进，并且再也不会停下来。第三只蚂蚁在 $x=3.5$ 处与第四只蚂蚁碰撞后，开始向左行走。第二只蚂蚁会在 $x=3$ 处碰撞，然后向左转，之后一直走下去。

## 样例 #1

### 输入

```
6
LPPLPL
```

### 输出

```
0 1 3 3 2 1
```

# 题解

## 作者：we_are_the_chuibing (赞：5)

## 思想

想起来了 [P1007](https://www.luogu.com.cn/problem/P1007)，有一个重要思想：

> 由于两只蚂蚁速度不变，所以这两只蚂蚁碰撞反弹时，可以看做两只蚂蚁互相穿过并且交换灵魂。

但由于这题要求每个蚂蚁的碰撞次数，所以并不能这样做。

但是思想还是可以借鉴一下的。

## 思路

因为对于每个蚂蚁求碰撞次数时，别的蚂蚁的碰撞不需要计算，所以我们可以看成只有需要计算次数的这只蚂蚁和其他蚂蚁碰撞会造成反弹。

现在将这只蚂蚁左边和右边分成两个区域左部分和右部分。

很明显，在左部分且朝向左边的蚂蚁和在右部分且朝向右边的蚂蚁不会和需要计算次数的蚂蚁永远碰撞不上，舍去。

接下来设在左部分且朝向右边的蚂蚁个数为 $x$，在右部分且朝向左边的蚂蚁个数为 $y$。

由于需要计算次数的蚂蚁肯定是在这些蚂蚁之间来回碰撞，且被碰撞到的蚂蚁就永远不会再次被碰撞，当一个部分的蚂蚁被碰完时，需要计算次数的蚂蚁就再也不会碰到这个部分的蚂蚁，同时只能进行一次碰撞了。所以我们可以得出以下结论：

- 当 $x=y$ 时，答案为 $x+y$。
- 当 $x<y$ 时：
  - 如果需要计算次数的蚂蚁面向左边，那么答案为 $2x$。
  - 如果需要计算次数的蚂蚁面向右边，那么答案为 $2x+1$。
- 当 $x>y$ 时：
  - 如果需要计算次数的蚂蚁面向右边，那么答案为 $2y$。
  - 如果需要计算次数的蚂蚁面向左边，那么答案为 $2y+1$。
  
然后将所有的 $x$ 和 $y$ 预处理即可。
  
```cpp
#include<iostream>
using namespace std;
int n,lans,rans,l[300001],r[300001];
char c[300001];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<=n;i++){
		l[i]=lans;
		if(c[i]=='P')lans++;
	}
	for(int i=n;i>=1;i--){
		r[i]=rans;
		if(c[i]=='L')rans++;
	}
	for(int i=1;i<=n;i++){
		if(l[i]==r[i])cout<<l[i]+r[i];
		else if(l[i]<r[i]){
			if(c[i]=='L')cout<<l[i]*2;
			else cout<<l[i]*2+1;
		}
		else{
			if(c[i]=='P')cout<<r[i]*2;
			else cout<<r[i]*2+1;
		}
		cout<<" ";
	}
	return 0;
}
```

如果各位有什么不懂的地方，欢迎私信询问。

---

## 作者：Hulless_barley (赞：3)

[P10349 [PA2024] Mrówki](https://www.luogu.com.cn/problem/P10349)
# 思路

## 第一步分析
当两个蚂蚁相撞时，就会改变方向。也就是说无论如何，第 $i$ 只蚂蚁永远是在第 $i+1$ 只蚂蚁左边。

## 转换题意
所有蚂蚁的顺序始终不变，所以可以设置一个蚂蚁会走路，其余都不会。

数轴上有 $n$ 只蚂蚁，分 L 型蚂蚁和 P 型蚂蚁两种。L 型蚂蚁只会向左走，P 型蚂蚁只会向右走。当 P 型蚂蚁遇到 L 型蚂蚁后，它会变异成 L 型蚂蚁；当 L 型蚂蚁遇到 P 型蚂蚁后，也会变异成 P 型蚂蚁。假设仅有第 $i$ 只蚂蚁会走路，并且遇到其他种类蚂蚁后，自己变异，而其他蚂蚁消失，记录每个第 $i$ 只蚂蚁会消灭多少蚂蚁（是不是有点恐怖了）。

## 初版代码
由转换题意可以轻松地写出如下代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5+5;
bitset<N>vis;
char a[N];
int n,ans;
char Readc(){
	char c;
	do c=getchar();
	while(!isalpha(c));
	return c;
}
void work(int p,char s){
	int step=(s=='L'?-1:1),i;
	for(i=p+step;i>=1&&i<=n;i+=step){
		if(vis[i])continue;
		if(a[i]!=s)break;
	}
	if(i<1||i>n)return;
	vis[i]=1,ans++;
	work(p,s=='L'?'P':'L');
}
int main(){
	cin>>n;
	for(register int i=1;i<=n;i++)a[i]=Readc();
	for(register int i=1;i<=n;i++){
		ans=0,vis.reset();
		work(i,a[i]);
		printf("%d ",ans);
	}
	return 0;
}
```
很可惜只有 $40$ 分，很多测试点都超时了（[测评结果](https://www.luogu.com.cn/record/156427833)）。时间复杂度 $O(n^2)$，对于 $1\le n\le 3\times10^5$ 的数据绝对过不去。

## 第二步分析
可以使用前缀和、后缀和进行优化，记录第 $i$ 只蚂蚁前后的 L、P 型蚂蚁数量，然后 $O(1)$ 询问。总时间复杂度 $O(n)$。记录前、后缀和也很简单，代码如下：

```cpp
/*
qL 是 L 的前缀和，qP 是 P 的前缀和；
hL 是 L 的后缀和，hP 是 P 的后缀和。
*/
for(register int i=1;i<=n;i++){
	int j=n-i+1;
	qL[i]=qL[i-1],qP[i]=qP[i-1];
	hL[j]=hL[j+1],hP[j]=hP[j+1];
	if(a[i]=='L')qL[i]++;
	if(a[i]=='P')qP[i]++;
	if(a[j]=='L')hL[j]++;
	if(a[j]=='P')hP[j]++;
}
```

对于每个 $i$，若它是 L 型蚂蚁，只需要根据 $qP$ 和 $hL$ 来求出 $ans_i$；若它是 P 型蚂蚁，只需要根据 $hL$ 和 $qP$ 来求出 $ans_i$。那 $qL$ 和 $hP$ 是不是没用了？好像是的，~~已经写过了不想删了~~。求解过程：

```cpp
int work(int p){
	const int P = qP[p]-(a[p]=='P');//自己不在自己前面，所以减去
	const int L = hL[p]-(a[p]=='L');//同上
	switch(a[p]){
		//几种情况画一个图就可以推出来，这里就不详细讲了
		case 'L':{
			if(P>L)return L*2+1;
			if(P<L)return P*2;
			if(P==L)return P*2;
		}
		case 'P':{
			if(P>L)return L*2;
			if(P<L)return P*2+1;
			if(P==L)return L*2;
		}
	}
	throw p;//不可能无解，以防万一就写一个
}
```

## 最终代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5+5;
int qL[N],hL[N],qP[N],hP[N],n,ans;
char a[N];
char Readc(){//过滤多余的空格
	char c;
	do c=getchar();
	while(!isalpha(c));
	return c;
}
int work(int p){
	const int P = qP[p]-(a[p]=='P');//自己不在自己前面，所以减去
	const int L = hL[p]-(a[p]=='L');//同上
	switch(a[p]){
		//几种情况画一个图就可以推出来，这里就不详细讲了
		case 'L':{
			if(P>L)return L*2+1;
			if(P<L)return P*2;
			if(P==L)return P*2;
		}
		case 'P':{
			if(P>L)return L*2;
			if(P<L)return P*2+1;
			if(P==L)return L*2;
		}
	}
	throw p;//不可能无解，以防万一就写一个
}
int main(){
	cin>>n;
	for(register int i=1;i<=n;i++)a[i]=Readc();
	for(register int i=1;i<=n;i++){
		int j=n-i+1;
		qL[i]=qL[i-1],qP[i]=qP[i-1];
		hL[j]=hL[j+1],hP[j]=hP[j+1];
		if(a[i]=='L')qL[i]++;
		if(a[i]=='P')qP[i]++;
		if(a[j]=='L')hL[j]++;
		if(a[j]=='P')hP[j]++;
	}
	for(register int i=1;i<=n;i++){
		try{printf("%d ",work(i));}
		catch(int){goto exit;}//同理，以防万一
	}
	exit:return 0;
}
```

---

## 作者：yuanruiqi (赞：2)

一个关键结论是，所有蚂蚁的相对位置不会改变。从左到右考虑每次碰撞的影响，若序列最左端是一段 `L`，则可以直接去除。若是一段 `PPPL`，则经过一些碰撞后会成为 `LPPP`，贡献是，中间的蚂蚁 $2$ 次碰撞，边上的 $1$ 次。前缀和处理，复杂度 $O(n)$。

---

## 作者：mozhao (赞：2)

# 题目大意
要求判断两只蚂蚁碰撞的次数。
## 思路
和前缀和差不多，对于每一只蚂蚁，通过前缀和分别计算它左边有多少只朝右的蚂蚁，右边有多少只朝左的蚂蚁，得到两个数组 
Z，Y，接着通过不断实践，就得出了以下结论：

当 $z=y$ 时，$ans=z+y$；

当 $z<y$ 且蚂蚁朝左时，$ans=2\times z$；

当 $z<y$ 且蚂蚁朝右时，$ans=2\times z+1$；

当 $y<z$ 且蚂蚁朝右时，$ans=2\times y$；

当 $y<z$ 且蚂蚁朝左时，$ans=2\times y+1$。

完结撒花！

---

## 作者：__qkj__ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10349)
## 解题思路
先找规律。

|  | 1 | 2 | 3 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| **0** | L | P | P | L | P | L |
| **1** | L | P | L | P | L | P |
| **2** | L | L | P | L | P | P |
| **3** | L | L | L | P | P | P |

我们发现，当出现形如 `P-L` 的一对蚂蚁，会发生碰撞。最后，会变成左边全是 `L`，右边全是 `R` 的样子。

我们又注意到，从左数第 $i$ 个 `L` 最终会到第 $i$ 个位置。而在每一次移动中，都会碰撞一次。一样的，从右数第 $j$ 个 `R` 最终会到右数第 $j$ 个位置，在每一次移动中，也都会碰撞一次。

但是给数组从 $l$ 到 $r$ 每一项都加一会超时。怎么办呢？这时，我们就要用到差分了。

差分是让数组的一段加上一个相同的数变为 $O(1)$，查询变为 $O(n)$ 的算法，代码中有解释。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int s[300010];
void insert(int l,int r)//差分
{
	if(l<=r)//判断是否合法
	{
		s[l]++;//左端点加一，意味着他后面的数字都加一
		s[r+1]--;//右端点后一位减一，使 r+1 后面的数字都减一（变回原样）
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,now=0;
	string a;
	cin>>n>>a;
	for(int i=1;i<=n;i++)
		if(a[i-1]=='L')insert(++now,i-1);
	for(int i=1;i<=n;i++)
		if(a[i-1]=='P')insert(i+1,++now);
	for(int i=1;i<=n;i++)
		cout<<(s[i]+=s[i-1])<<' ';//前缀和，变为正常数组
	return 0;
}

```

---

## 作者：rainygame (赞：0)

> 这个消愁模拟赛想了 1h。

先观察到两个简单的性质：

- 碰撞调转方向等价于交换编号后继续走。
- 蚂蚁相对位置不变。

考虑对每个 `P` 作贡献，根据性质 1，他会贡献 $x$ 次碰撞，其中 $x$ 为右边的 `L` 个数。又有性质 2，所以它必定会和它右边的那些蚂蚁碰撞。

但是这个 `P` 对于每个的贡献并不都是 $1$，注意到每次碰撞后它会交换一次编号，所以中间的 $x-1$ 个会碰撞 $2$ 次。

直接差分维护区间加即可，时间复杂度 $O(n)。$

---

## 作者：GeXiaoWei (赞：0)

# P10349 [PA2024] Mrówki
## 解析
一道思维题，两层循环枚举肯定超时。

仔细想一想，若当前这只蚂蚁左边的蚂蚁数量等于右边的蚂蚁数量，答案即为这两数之和。若左边的蚂蚁数量大于右边的蚂蚁数量时，且当前这只蚂蚁面向左，答案为右边蚂蚁数的两倍，否则多一只。若左边的蚂蚁数量小于右边的蚂蚁数量，且当前这只蚂蚁面向右，答案为左边蚂蚁数量的两倍，否则多一只。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,l,r,a[300005],b[300005];
string s;
int main(){
	cin>>n>>s;
	for(int i=0;i<n;i++) a[i]=l,l=l+(s[i]=='P'); 
	for(int i=n-1;i+1;i--) b[i]=r,r=r+(s[i]=='L'); 
	for(int i=0;i<n;i++){
		if(a[i]==b[i]) printf("%lld ",a[i]+b[i]);
		else if(a[i]<b[i]) printf("%lld ",a[i]*2+(s[i]!='L'));
		else printf("%lld ",b[i]*2+(s[i]!='P'));
	}
	return 0;
}
```

---

## 作者：__hjwucj__ (赞：0)

# 题解：P10349 [PA2024] Mrówki

[题目传送门](https://www.luogu.com.cn/problem/P10349)

## 思路

众所周知，你谷有道题目的编号是 [P1007](P1007)。这道题目的主要思想是 P1007 的翻版。



------------
由于两只蚂蚁速度不变，所以这两只蚂蚁碰撞反弹时，可以看做两只蚂蚁互相穿过并且交换灵魂。

------------

当两个蚂蚁相撞时，就会改变方向。也就是说无论如何，第 $i$ 只蚂蚁永远是在第 $i+1$ 只蚂蚁左边。

------------

~~这是两位大佬写的，不敢改。~~

以上来自 @dingjunwei 和 @511_Juruo_wyk 的题解。

我们预处理蚂蚁的方向（右侧倒着来），接着就可以 $O(n)$ 输出了！！！

设在左部分且朝向右边的蚂蚁个数为 $x$，在右部分且朝向左边的蚂蚁个数为 $y$。

那么：

当 $x=y$ 时，答案为 $x+y$。

当 $x<y$ 并且当前的蚂蚁是朝左时，答案为 $2x$。

当 $x<y$ 并且当前的蚂蚁是朝右时，答案为 $2x+1$。

当 $x>y$ 并且当前的蚂蚁是朝右时，答案为 $2y$。

当 $x>y$ 并且当前的蚂蚁是朝左时，答案为 $2y+1$。

## 代码参考

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int n,a[300002],b[300002];
int main ()
{
	cin>>n>>s;
	int ans=0;
	for (int i=0;i<s.size ();i++)
	{
		a[i]=ans;
		if (s[i]=='P') ans++;
	}
	ans=0;
	for (int i=s.size ()-1;i>=0;i--)
	{
		b[i]=ans;
		if (s[i]=='L') ans++;
	}
	for (int i=0;i<s.size ();i++)
		if (a[i]==b[i]) cout<<a[i]+b[i]<<' ';
			else if (a[i]<b[i]&&s[i]=='L') cout<<2*a[i]<<' ';
				else if (a[i]<b[i]&&s[i]=='P') cout<<2*a[i]+1<<' ';
					else if (a[i]>b[i]&&s[i]=='P') cout<<2*b[i]<<' ';
						else cout<<2*b[i]+1<<' ';
    return 0;
}
```

---

## 作者：KyleShen1213 (赞：0)

## 思路
和前缀和差不多，对于每一只蚂蚁，通过前缀和分别计算它左边有多少只朝右的蚂蚁，右边有多少只朝左的蚂蚁，得到两个数组 $Z$（计算左边朝右的蚂蚁数量），$Y$（计算右边朝左的蚂蚁数量），接着通过不断实践，就得出了以下结论：

对于朝右的蚂蚁 $i$，

如果 $z_i=y_i$，碰撞次数就是 $(z_i+y_i)$；

如果 $z_i<y_i$，碰撞次数就是 $(2\times z_i+1)$；

如果 $z_i>y_i$，碰撞次数就是 $(2\times y_i)$。

对于朝左的蚂蚁 $i$，

如果 $z_i=y_i$，碰撞次数就是 $(z_i+y_i)$；

如果 $z_i<y_i$，碰撞次数就是 $(2\times z_i)$；

如果 $z_i<y_i$，碰撞次数就是 $(2\times y_i+1)$。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,z[300005]={0},y[300005]={0};
char a[300005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)//计算z数组 
	{
		if(a[i]=='P')
		{
			z[i+1]+=z[i]+1;
		}
		else
		{
			z[i+1]+=z[i];
		}
	}
	for(int i=n;i>=1;i--)//计算y数组 
	{
		if(a[i]=='L')
		{
			y[i-1]+=y[i]+1;
		}
		else
		{
			y[i-1]+=y[i];
		}
	}
	for(int i=1;i<=n;i++)//for循环每个判断，输出答案 
	{
		if(a[i]=='P')
		{
			if(z[i]==y[i])  cout<<z[i]+y[i]<<" ";
			else if(z[i]<y[i])  cout<<2*z[i]+1<<" ";
			else  cout<<2*y[i]<<" ";
		}
		else
		{
			if(z[i]==y[i])  cout<<z[i]+y[i]<<" ";
			else if(z[i]<y[i])  cout<<2*z[i]<<" ";
			else  cout<<2*y[i]+1<<" ";
		}
	}
	return 0;
}
```

---

## 作者：iyka (赞：0)

### 思路
首先考虑暴力枚举时间，但时间复杂度有可能达到恐怖的 $4.5\times 10^{10}$ 大小，果断放弃。  
因为本题数据较大，所以考虑从单只蚂蚁入手，目标是一个 $O(N)$ 的算法。

### 如何在 $O(1)$ 的时间里求出单个蚂蚁的碰撞次数：
把这单个蚂蚁命名为 $x$，如果想求出碰撞次数，不难发现能做出贡献的只有在右边面向左边的蚂蚁和在左边面向右边的蚂蚁，把他们的个数分别记为 $l$ 和 $r$。又因为撞击会改变方向，那对于一个方向能贡献的单个目标就只能做一次贡献，那就有以下结论：

1. 若 $l=r$ 则答案为 $l+r$。
2. 若 $l<r$：
	- 若 $x$ 面向右，则答案为 $2\times l+1$。
   - 若 $x$ 面向左，则答案为 $2\times l$。
3. 若 $l>r$：
	- 若 $x$ 面向左，则答案为 $2\times r+1$。
   - 若 $x$ 面向右，则答案为 $2\times r$。
   
最后只需要预处理出 $l$ 和 $r$，再模拟一下就可以了。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int a[N],n;
int l[N],r[N],cnl,cnr;
char chr;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>chr, a[i]=(chr=='L')?0:1;
	for(int i=1;i<=n;++i) //预处理 
		l[i]=cnl, cnl+=(a[i]==1);
	for(int i=n;i>=1;--i)
		r[i]=cnr, cnr+=(a[i]==0);
	for(int i=1;i<=n;++i)
	{
		if(l[i]==r[i]) //情况1 
			cout<<l[i]+r[i]<<" ";
		else if(l[i]<r[i]) //情况2 
			cout<<2*l[i]+(a[i]==1)<<" ";
		else //情况3
			cout<<2*r[i]+(a[i]==0)<<" ";
	}
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

竟然没人写题解。

[传送门。](https://www.luogu.com.cn/problem/P10349)

# 题意简述
>数轴上有 $n$ 个点。其中，第 $i$ 个点初始在第 $i$ 个位置上。每个点都在运动，每个点都有一个运动方向（左或右）
>
>在运动过程中，如果两个点相遇，那么他们的方向会变成各自的相反方向继续运动。求问结束后每个点的碰撞次数

# 思路分析
如果一个点像左运动，标记其为 $0$。如果一个点向右运动，则标记其为 $1$。对于两个点相遇后反弹，可以看成相邻，且数字不相同的两个点交换位置，且一定是 $0-1$ 交换为 $1-0$。

我们考虑每个点最后的状态，因为最后所有的都不发生碰撞，所以可以看成所有的 $0$ 在所有的 $1$ 左边。

![交换过程](https://cdn.luogu.com.cn/upload/image_hosting/ntvc2jd3.png)

我们假设一共有 $t$ 个 $0$。显然，第 $i(1\le i\le t)$ 个 $0$ 最后会移动到位置 $i$，设其下标为 $A_i$，则 $i\sim A_i-1$ 中的每个点都会交换一次。

同理，第 $i(1\le i\le n-t)$ 个 $1$ 最后会移动到位置 $t+i$，设其下标为 $B_i$，则 $B_i+1\sim t+i$ 中间的每个点都会交换一次。

区间加法，最后统计答案，差分法即可。时间复杂度 $O(n)$。

# Code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
const int N=3e5+10;
int n,tot=1;
long long c[N];
bool v[N];
char s[N];
inline void add(int l,int r){
    if(l>r)return;
    else return c[l]++,c[r+1]--,void();
}
int main(){
    scanf("%d",&n);
    scanf("%s",s+1);
    for(int i=1;i<=n;i++)v[i]=(s[i]=='L'?0:1);
    for(int i=1;i<=n;i++)if(v[i]==0)add(tot,i-1),tot++;
    for(int i=1;i<=n;i++)if(v[i]==1)add(i+1,tot),tot++;
    for(int i=1;i<=n;i++)c[i]+=c[i-1],printf("%lld ",c[i]);
    return 0;
}
```

如有错误，请指出。

---

## 作者：Populus_euphratica (赞：0)

我们要求的是每一只蚂蚁的碰撞次数，所以可以先一只一只的单独考虑，设当前考虑的是第 $i$ 只蚂蚁。

首先，我们可以把两只蚂蚁碰撞在一起然后往回走，看成交换一次编号，增加这两只的碰撞次数。但是，这并不影响第 $i$ 只蚂蚁与其中一只碰撞。

也就是说，在考虑第 $i$ 只蚂蚁的时候，其他的碰撞以及换位是没有意义的，所以我们可以看成除了第 $i$ 只蚂蚁都是静止的，在与第 $i$ 只蚂蚁对碰后会消失。

那么就可以来讨论碰撞次数了。

设在 $i$ 左边且朝向右的蚂蚁有 $l$ 只，在 $i$ 右边且朝向左的蚂蚁有 $r$ 只，那么 $x$ 的碰撞次数就是这样的：

```cpp
if(l == r){
	cout << l + r << " ";
	continue;
}
if(l < r){
	if(s[i] == 'L') cout << 2 * l << " ";
	else cout << 2 * l + 1 << " ";
}
if(l > r){
	if(s[i] == 'P') cout << 2 * r << " ";
	else cout << 2 * r + 1 << " ";
}
```

$l, r$ 通过前后缀维护即可。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int Maxn = 500010;
int n;
string s;
int pre[Maxn], suf[Maxn];
signed main(){
	ios::sync_with_stdio(false);
	cin >> n >> s;
	s = ' ' + s;
	for(int i = 1 ; i <= n ; i++){
		if(s[i] == 'P') pre[i]++;
		pre[i] += pre[i - 1];
	}
	for(int i = n ; i >= 1 ; i--){
		if(s[i] == 'L') suf[i]++;
		suf[i] += suf[i + 1];
	}
	for(int i = 1 ; i <= n ; i++){
		int x = pre[i - 1], y = suf[i + 1];
		if(x == y){
			cout << x + y << " ";
			continue;
		}
		if(x < y){
			if(s[i] == 'L') cout << 2 * x << " ";
			else cout << 2 * x + 1 << " ";
		}
		if(x > y){
			if(s[i] == 'P') cout << 2 * y << " ";
			else cout << 2 * y + 1 << " ";
		}
	}
	cout << '\n';
	return 0;
}
```

---


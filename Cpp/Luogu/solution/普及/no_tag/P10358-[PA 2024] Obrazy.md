# [PA 2024] Obrazy

## 题目背景

PA 2024 3C

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 3 [Obrazy](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/obr/)，感谢 Macaronlin 提供翻译**

给定尺寸为 $h\times w$ 的矩形墙面，以及 $n$ 种尺寸的正方形画框，每种尺寸画框都有无穷多个。对于任意两种不同尺寸的画框，其中一个尺寸的边长总能整除另一个尺寸的边长。

现用这些画框完全覆盖墙面，而且画框之间不能重叠，只能边缘相接，请求出最少需要购买多少个画框？如果不可能完全覆盖墙面，则程序应输出 $-1$。

## 说明/提示

在第一个样例中，Byteasar 可以用九个画框（六个 $1\times 1$、两个 $3\times 3$ 和一个 $6\times 6$）覆盖一面墙，具体如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/t6g3zuws.png)

在第二个样例中，无法完全覆盖墙面。

## 样例 #1

### 输入

```
6 10
3
1 3 6
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3 3
1
2
```

### 输出

```
-1```

# 题解

## 作者：EMO_smile (赞：4)

# P10358 [PA2024] Obrazy

[题目传送门](https://www.luogu.com.cn/problem/P10358)

## 题意分析：

### 1.特判

我们~~很容易~~能够想到本题的特殊判断：即当**最小的画框**都不可能覆盖**整个**矩形墙面时，输出 $-1$。

### 2.常规

若我们将墙面的长设为 $l$，宽设为 $r$,画框**最小边长**为 $a[i]$，画框可覆盖面积为 $ans$（因为需要保证画框的完整性，不能让一个 $2\times2$ 的画框变为 $1\times4$），易得：
$$
ans=((l-(l\bmod a[i]))\times(r-(r\bmod a[i]));
$$
当 $ans < l\times r$ 时，输出 $-1$。

我们可用一个变量 $tmp$ 来表示当前画框可覆盖面积， $a1[i]$ 来判断第 $i$ 个画框的面积，判断当前有多少个  $a1[i-1]$ 面积的画框可以被 $a1[i]$ 整除即可：
```cpp
tmp=(l-(l%a[i]))*(r-(r%a[i]));
ans-=tmp/a1[i-1];//较小画框可换数量
ans+=tmp/a1[i];//较大画框可换数量
```
代码：
```cpp
//#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
using namespace std;
inline long long read(){//快读
	long long x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
void write(int x){//快写（虽然不经常用）
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
	return;
}
long long a[1145141],f[1145141],n,m,l,r,a1[1145141];
int main(){
	l=read();r=read();
	m=l*r;//计算总面积
	n=read();
	long long ans=0;
	for(int i=1;i<=n;i++){
		a[i]=read();
		a1[i]=a[i]*a[i];
		if(i==1){//特判：最小画框有无可能全部覆盖
			ans=(l-(l%a[i]))*(r-(r%a[i]));
			ans=ans/a1[i];
			if(ans*a1[i]<m){
				cout<<-1;
				exit(0);//=return 0;
			}
		}else{
			long long tmp=(l-(l%a[i]))*(r-(r%a[i]));//tmp表示当前画框可覆盖面积
			ans-=tmp/a1[i-1];//较小画框可换数量
			ans+=tmp/a1[i];//较大画框可换数量
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：__Octhyccc__ (赞：3)

我们可以把题目中给出的 $d_1$ 当成 $1$ 个单位，$h,w$ 不能整除 $d_1$ 的肯定不可以，输出 $-1$。

又因为其余正方形画框肯定是 $d_1$ 的倍数，令数组 $b$ 为 $\frac{d_i}{d_1}$ 的值，其中 $1\le i\le n$，$\frac{h}{d_1},\frac{w}{d_1}$ 分别表示长，宽中分别有多少个 $d_1$，令 $x,y$ 分别为 $\frac{h}{d_1},\frac{w}{d_1}$。

从 $d_n$ 开始寻找，如果 $x\ge d_i$ 并且 $y\ge d_i$，就说明该矩形中可以放下 $d_i$，然后尽量的往长方形里塞 $d_i\times d_i$ 的正方形，可以证明，该策略为最优解。

证明：如果能塞下 $d_i\times d_i$ 的正方形，那么 $d_{i-1}\times d_{i-1}$ 的正方形一定可以被塞下，但是必须用 $\frac{b_i}{b_{i-1}}$ 个  $d_{i-1}\times d_{i-1}$ 的正方形来代替，块数反而增多，所以在可以塞进的情况下 $d_i$ 比 $d_i-1$ 更优。

塞完了之后会出现 $2$ 种情况，下面我将会结合样例来解释我的思路。

```
6 10
3
1 3 6
```

首先，建立一个 $10\times 6$ 的矩形（我习惯长边作长，短边作宽，不影响程序正确），用横线分割，$1\times 1$ 的矩形为 $1$ 个单位（上文中的 $d_1$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/0sdyq7tb.png)

由上文结论知，在此时选择 $6\times 6$ 最佳。

![](https://cdn.luogu.com.cn/upload/image_hosting/h0z8kjpz.png)

这是第 $1$ 种情况，刚好裁剪完毕，如果下面还有剩余（假设），就需要裁剪。

![](https://cdn.luogu.com.cn/upload/image_hosting/v0hy5udv.png)

我们可以把剩下的任务拆成红色和白色两部分，递归解决（方法和上文一样）。

让我们再回到样例上来，还剩下一个 $4\times 6$ 的。

![](https://cdn.luogu.com.cn/upload/image_hosting/l2d2vmzc.png)

可以拆成两个 $3\times 3$ 的，还剩下一个 $1\times 6$ 的。

因为现在只有 $1\times 1$ 可以填 $1\times 6$ 的了，只能使用 $1\times 1$。

答案为 $1+2+6=9$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int h,w,n,cnt;
int d[31],b[31];
void f(int x,int y){//(6,1)
	if(x<y)swap(x,y);
	int e1=0,e2=0,e3=0,e4=y,e5=x;
	for(int i=n-1;i>=0;i--){
		if(x>=b[i] && y>=b[i]){
		    int t1=x/b[i];
		    x-=t1*b[i];
		    e1+=t1;
		    t1=y/b[i];
		    y-=t1*b[i];
		    e2+=t1;
			cnt+=1ll*e1*e2;e3=b[i];
			break;
		}
	}
	if(e5-e1*e3>0 && e4>0)f(e5-e1*e3,e4);
	if(e1*e3>0 && e4-e2*e3>0)f(e1*e3,e4-e2*e3);//(6,1)
}
signed main(){
	scanf("%lld%lld%lld",&h,&w,&n);
	for(int i=0;i<n;i++){
		scanf("%lld",&d[i]);
	}
	if(h%d[0]!=0 || w%d[0]!=0){
		printf("-1");
		return 0;
	}
	for(int i=0;i<n;i++){
		b[i]=d[i]/d[0];
	}
	f(h/d[0],w/d[0]);
	printf("%lld",cnt);
	return 0;
}
```

如果你有数据过不去，我给你一个坑人的：

```
100000 100000
1
1
```

答案：

```
10000000000
```

**所以，记得开 long long。**

---

## 作者：abc1234shi (赞：2)

我做这题，刚开始想着用枚举，但 $30$ 个画框，很明显枚举不了一点，后面想了一下用贪心选择最大的画框就可以了，先用最大的画框去覆盖，之后会剩下两个边一个角，再递归地用更小的画框覆盖这两个区域（两边都可能有余，所以需要递归），大白话就是：从最大的开始试，然后每次取余继续除，最后算出多少次就行了，如果不能完全覆盖（不与墙面面积相等），就输出 $-1$。还有一点就是会超整形范围，要开长整型（极端条件 $100000000$ 的平方）。

---

## 作者：yuanruiqi (赞：1)

类似于 ARC172A 的思路，对于一个矩形可以先在左上角填尽量多的能填的最大的正方形，并拆出两个子矩形，由于每个子矩形的边长都是最小正方形边长的倍数，所以一定不会有方案使得两个子矩形产生后效性，可以直接递归。

---

## 作者：mozhao (赞：1)

首先，注意到满足每个 $𝑑𝑖+1$ 是 $𝑑𝑖$ 的倍数 
$(1≤𝑖<𝑛)$ ，那么说明每个正方形都能转化为若干个最小的正方形，所以 $𝑤$ $mod$ $𝑑1≠0$ 或 $ℎ$ $mod$ $𝑑1≠0$ 无解。

有解时，我们可以使用逆向思维，先将矩形用最小的正方形铺好，算出需要多少块之后，从小往大一块一块填，每填一块，就相应地减少正方形数量，计算即可。

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long h,w,d[35],n,ans;
int main() {
	cin>>h>>w>>n;
	for(long long i=1; i<=n;i++){
		cin>>d[i];
	}
	if(h%d[1]!=0||w%d[1]!=0){//判断能否填满
		cout<<-1;
		return 0;
	}
	ans=h*w/d[1]/d[1];
	for(int i=2; i<=n;i++) {
		if(d[i]>h||d[i]>w){
			break;
		}
		h=h-h%d[i];
		w=w-w%d[i];
		ans=ans-h*w/d[i-1]/d[i-1]+h*w/d[i]/d[i]; //更新此时放入的正方形的个数
	}
	cout<<ans;
	return 0;
}
```
完结撒花！

---

## 作者：KyleShen1213 (赞：1)

## 题目分析
考虑递归。将正方形画框由大到小能摆就摆，由于题目说了大的画框边长一定能整除小的画框边长。

所以容易证明如果这样摆到最后有剩余（表示最小的也无法在摆进去）。

不懂得详见代码～

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long h,w,ans,n,d[35];
bool fl;
void Do(long long a,long long b,long long i)//递归函数 
{
	if(i==0)//如果有剩余却无法填满，fl=1，主函数输出-1 
	{
		fl=1;
		return;
	}
	ans+=(long long)(a/d[i])*(long long)(b/d[i]);//加上新放入的数量 
	long long t1=a%d[i],t2=b%d[i];//下一次递归的数值 
	if(t1&&t2)//t1和t2分别表示上下剩余和左右剩余，i表示画框编号 
	{
		Do(t1,b,i-1);//递归
		Do(a-t1,t2,i-1);//递归
	}
	else if(t1)  Do(t1,b,i-1);//递归
	else if(t2)  Do(a,t2,i-1);//递归
}
int main()
{
	cin>>h>>w>>n;//输入
	for(int i=1;i<=n;i++)
	{
		cin>>d[i];
	}
	Do(h,w,n);//递归 
	if(fl==1)
	{
		cout<<"-1"<<endl;//如果fl=1，说明无法填满，输出-1 
	}
	else
	{
		cout<<ans<<endl;//输出ans
	}
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：1)

首先，注意到满足每个 $d_{i+1}$ 是 $d_i$ 的倍数 $(1\le i<n)$，那么说明每个正方形都能转化为若干个最小的正方形，所以 $w \bmod d_1 \ne 0$ 或 $h \bmod d_1 \ne 0$ 时，无解。

有解时，我们可以使用逆向思维，先将矩形用最小的正方形铺好，算出需要多少块之后，从小往大一块一块填，每填一块，就相应地减少正方形数量，计算即可。

```cpp
#include<iostream>
using namespace std;
long long h,w,n,d[31],ans;
int main(){
	cin>>h>>w>>n;
	for(int i=1;i<=n;i++)cin>>d[i];
	if((h%d[1])||(w%d[1])){cout<<-1;return 0;}
	ans=h/d[1]*w/d[1];
	for(int i=2;i<=n;i++){
		long long a=(d[i]/d[i-1])*(d[i]/d[i-1])-1;
		long long b=(h/d[i])*(w/d[i]);
		ans-=(a*b);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 题目大意
用最少的方块贴最大的墙，无遗漏重叠。
## 思路
### 判不行
注意这句话：**其中一个尺寸的边长总能整除另一个尺寸的边长**。

也就是说，只要连最小的方块都不能整除（正好铺满）边长，既可判否。
### 可以
因为要省方块，所以要从大往小用。

显然这并不行，因为铺多了后，整个长方形剩的奇形怪状的。

所以考虑逆向思维，再看这句话：**其中一个尺寸的边长总能整除另一个尺寸的边长**。然后逐渐用大正方形替换小正方形就行了。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long h,w,n,d[40],ans;
int main(){
	cin>>h>>w;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>d[i];//朴实无华的输入
	if(h%d[1]!=0||w%d[1]!=0){
		cout<<-1;
		return 0;
	}判不行
	ans+=(h/d[1]*w/d[1]);//全用最小的
	for(int i=2;i<=n;i++){
		int sl=(w/d[i]*h/d[i])/*放下几个大的*/
        int gs=(d[i]/d[i-1]*d[i]/d[i-1])-1;/*每个节约多少*/
		ans-=(sl*gs);//减去减少的
	}
	cout<<ans;//输出
	return 0;
}
```
## 提醒
- 审题不规范，分数两行泪。
- int 真能存下？
- 细节决定成败。

---

## 作者：Il1_1_3 (赞：0)

# P10358 Obrazy 题解

[题目传送门](https://www.luogu.com.cn/problem/P10358)

~~PA 的题繁殖后代能力好强！~~

## 题目大意
尺寸为 $h \times w$ 的矩形墙面，有 $n$ 种不同的画框，将画框铺在墙上，不能重叠，求最少用多少个画框可以把墙壁铺满。若不可能，输出 $-1$。

**重要条件：每个画框的边长 $d_i (2 \le i \le n)$ 一定满足 $d_{i-1} \mid d_i$**。


## 思路分析

- 先来看不可能实现的情况。

  我们知道：

  $\because$ 如果 $a \mid b$ 且 $c \not\equiv 0 (\bmod \: a)$，

  $\:\:\:$ 可以推出 $c \not\equiv 0 (\bmod \: b)$。

  $\therefore$ 当只用 $d_1$ 边长的画框都不能覆盖，那么其他画框也一定不可能，这时候，输出 $-1$。

- 可能的情况：

  这里我们的思路是：先把墙面用边长 $d_1$ 的画框铺满，再从小到大把能替换的 $(\dfrac{d_i}{d_{i-1}})^2$ 个边长为 $d_{i-1}$ 的小正方形用大一点的替换掉，计算只需在 $ans$ 里减去就可以了。

下面贴上完整代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll h,w,n,ans,dan,gong;//long long 要注意
ll d[33];//同上
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> h >> w >> n;
	for(int i=1;i<=n;i++)
		cin >> d[i];
	if((h%d[1]||w%d[1])||(h<d[1]||w<d[1]))//判断不可能的情况
	{
		cout << "-1";
		return 0;
	}
	ans=(h/d[1])*(w/d[1]);//所有都用d[1]画框
	for(int i=2;i<=n;i++)
	{
		dan=(d[i]/d[i-1])*(d[i]/d[i-1])-1;//-1是因为替换后也有一个
		gong=(h/d[i])*(w/d[i]);//大号正方形个数
		ans-=dan*gong;
	}
	cout << ans;
	return 0;
}
```

[完美结束！](https://www.luogu.com.cn/record/169676547)

~~1！6！2！个测试点。~~

---

## 作者：__rnfmabj__ (赞：0)

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P10358)

大意是给定 $w × h$ 的矩阵，并给出 $n$ 种尺寸不同的小矩阵，问**最少**可以用多少个小矩阵将大矩阵填满。

## 理清思路

首先注意到题面有一句话：**对于任意两种不同尺寸的画框，其中一个尺寸的边长总能整除另一个尺寸的边长**。

那么我们不难想到，我们可以用不同的小矩阵来凑成一个大矩阵，也就是说，我们可以先求出一共可以用多少个小矩阵，在逐步拼成一个大矩阵。

那么我们只需要预处理出**每一个小正方形转换为更大正方形节省了多少**，以及**可以容纳多少个更大的正方形**。将他们累加起来，就是最终节省下了的矩阵总数。

那么无解的情况也就好判断了，如果当前的大矩阵连最小的矩阵都分解不了，那么也无法被别的矩阵分解。

## Code

可能会有问题的都塞注释里了。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long h,w,n,d[55];//变量如题面
long long ans,k,l,sum;
//ans用于记录答案，k表示将小正方形改成大正方形后节省了多少
//l表示可以塞多少个更大的正方形，sum表示最终节省了多少

int main(){
	scanf("%lld%lld%lld",&h,&w,&n);

	for (int i=1;i<=n;i++){
		scanf("%lld",&d[i]);
		if (i==1)continue;

		k=(d[i]/d[i-1])*(d[i]/d[i-1])-1;
		//减1是因为转换之后它自己仍是一个，也会占用一个ans的位置
		l=(w/d[i])*(h/d[i]);
		//计算可以容纳多少个更大的正方形
		sum+=(k*l);
		//记录下节省的总数
	}
	if (h%d[1]!=0 || w%d[1]!=0)
		//无法通过最小的矩阵都分解，无解
		printf("-1");
	else {
		ans=(w/d[1])*(h/d[1])-sum;
		//用所有的减去节省下来的，就是答案
		cout<<ans;
	}
	return 0;
}
```

---

## 作者：Happy_mouse (赞：0)

# [P10358 Obrazy](https://www.luogu.com.cn/problem/P10358) 题解

[AC证明](https://www.luogu.com.cn/record/163010423)~~（这题样例是真多啊……）~~

## 看完题目，分析一下：

注意到题目中一句话：“对于**任意**两种不同尺寸的画框，其中一个尺寸的边长**总能整除**另一个尺寸的边长。”

因此，大一点的画框占的位置一定可以用很多个小一点的画框铺上。

而问题又让用画框最少，因此，选大的一个肯定要比选很多个小的铺同样的位置用画框少。

这样，办法就定下来了：先选大的，把能铺的铺完，再选小的。

## 细节

- 画框“**整齐靠边站**”，否则会让剩下的整块儿空间变小。
- 铺完一片画框，可能会形成 $L$  型空白，此时可以递归解决，绿色区域就是刚铺完的画框，接下来可以分红、白两块进行递归。
![](https://cdn.luogu.com.cn/upload/image_hosting/v0hy5udv.png)

（图片来自 @\_\_Ending__）

## 递归部分

```
//n存画框种类数，a数组存画框种类
//cnt累加用到的画框数

void dg(int x,int y){//x,y存当前递归的规模（横向与纵向的单位数）
	if(x==0||y==0) return ;//面积为0，直接跳出
	int k;//存最大能使用画框的边长
	for(int i=n;i>0;i--){//从大到小遍历
		if(x>=a[i]&&y>=a[i]){//找到能放得下的最大值
			k=a[i];//存
			break;//直接跳出
		}
	}
	int dx=x/k,dy=y/k;//分别算横向与纵向各能放多少个
	cnt+=dx*dy;//累加画框个数
	dg(x-dx*k,dy*k);//上图红色部分
	dg(x,y-dy*k);//白色部分
}
```

为防止抄袭，就不放完整代码了欧。

---

## 作者：iyka (赞：0)

### 题目分析
给出一个 $h\times w$ 的空旷区域，要求用给定的 $n$ 种正方形中取出部分，无重叠填满空旷区域，其中任意一个 $d_i$ 和 $d_j\ (1\le i\le j\le n)$ 都有 $d_j$ 整除 $d_i$（$d$ 为正方形的边长），若可以填满，则输出最少需要多少个正方形；若不可以填满，则输出 $-1$。

### 如何判断能否填满
注意题目中给出的条件，$\text{保证 } d_{i+1} \text{ 能被 } d_i \text{ 整除}$，即其中任意一个 $d_i$ 和 $d_j(1\le i\le j\le n)$ 都有 $d_j$ 整除 $d_i$，所以我们只用考虑 $d_1$ 是否能被 $h$ 和 $w$ 同时整除即可，若不可以，即不可以填满，则输出 $-1$。

### 如何计算填满最少需要多少个正方形
因为题目给出的 $h$ 和 $w$ 都十分的大（$1\le h,w\le 10^9$），所以我们无法直接暴力搜索得出答案，这里考虑利用题目给出的 $d$ 的特性来计算。首先先计算出全部用边长为 $d_1$ 的正方形填满时需要的正方形数量，然后从 $2$ 遍历到 $n$, 每次 $O(1)$ 算出边长为 $d_i$ 的正方形能填满的区域，再把 $h$ 和 $w$ 更新为这个区域的大小，若有 $d_i>h$ 或 $d_i>w$ 则终止遍历，因为 $d$ 是从小到大排序的，$d_i$ 无法放入，那 $d_j\ (i\le j\le n)$ 自然也无法放入，并在过程中不断更新放入的正方形的个数，根据贪心，我们就能求出填满最少需要多少个正方形。时间复杂度为 $O(n)$，轻松通过（记得开 long long）。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std; 
#define int long long
const int N=35;
int h,w,d[N],n,ans;
signed main()
{
	cin>>h>>w>>n;
	for(int i=1;i<=n;++i)
		cin>>d[i];
	if(h%d[1]!=0 || w%d[1]!=0) //判断能否填满
		return cout<<-1, 0;
	ans=h*w/d[1]/d[1];
	for(int i=2;i<=n;++i)
	{
		if(d[i]>h || d[i]>w)
			break;
		h-=h%d[i], w-=w%d[i];
		ans=ans-h*w/d[i-1]/d[i-1]+h*w/d[i]/d[i]; //更新此时放入的正方形的个数
	}
	cout<<ans;
	return 0;
}
```

---


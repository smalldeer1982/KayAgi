# [蓝桥杯 2023 国 A] XYZ

## 题目描述

给定一个区间 $[L,R]$，请求出有多少组 $X,Y,Z$ 满足 $X+Y=Z$ 且 $L\le X,Y,Z\le R$。

## 说明/提示

**【样例解释 1】**

$1+1=2$  
$1+2=3$  
$2+1=3$  
$1+3=4$  
$2+2=4$  
$3+1=4$

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$T\le 1000$，$L_i,R_i\le 100$。  
对于所有评测用例，$1\le T\le 100000$，$1\le L_i\le R_i\le 10^9$。

## 样例 #1

### 输入

```
2
1 3
1 4```

### 输出

```
3
6
```

# 题解

## 作者：yitian_ (赞：15)

## 题目分析

本题将有 $T$ 组询问，每组询问给定一个区间 $[L,R]$，需要求出有多少组 $X,Y,Z$ 在区间范围内并满足 $X+Y=Z$。对于所有评测用例，$1\leq L\leq R\leq10^9$。


## 思路

由于数据范围为 $1\leq L\leq R\leq10^9$，暴力枚举将是不可行的，需要找规律。

因为 $X$ 和 $Y$ 的最小值为 $L$，所以 $Z$ 的最小值为 $2L$。

- 当 $Z=2L$ 时，$X=L,Y=L$，共一组。

- 当 $Z=2L+1$ 时，$X=L,Y=L+1$ 或 $X=L+1,Y=L$，共两组。

- 当 $Z=2L+2$ 时，$X=L,Y=L+2$ 或 $X=L+1,Y=L+1$ 或 $X=L+2,Y=L$，共三组。

- 当 $Z=2L+3$ 时，$X=L,Y=L+3$ 或 $X=L+1,Y=L+2$ 或 $X=L+2,Y=L+1$ 或 $X=L+3,Y=L$，共四组。

- $\cdots$

- 当 $Z=2L+n=R$ 时，可推导出共有 $n+1$ 种满足条件的 $X,Y,Z$ 组合。变形可得 $n=R-2L$。所以此时满足条件的 $X,Y,Z$ 有 $R-2L+1$ 种。

答案已经很明显了，为一个公差为 $1$ 的等差数列之和。即 $1+2+3+\cdots+(R-2L+1)$。

因为公差为 $1$，首项为 $1$，末项为 $R-2L+1$，所以该等差数列的项数为 $R-2L+1$。

所以，该等差数列之和为 $\dfrac{(R-2L+1)\times(R-2L+2)}{2}$。

需要注意的是，因为 $Z$ 最小为 $2L$，所以 $R<2L$ 时将没有任何一组满足条件的 $X,Y,Z$。因此需要先判断 $R$ 是否小于 $2L$。如果是，输出 $0$ 并跳过循环的其余部分，进行下一组询问。 

## C++ 代码实现

```c
#include<bits/stdc++.h>  // 包含所有标准 C++ 库
using namespace std;  

int main()
{
    long long ans,t;
    cin >> t;  // 输入测试用例的数量
    while(t--)
    {
        long long l,r,n,m;
        cin >> l >> r;  // 输入 l 和 r 的值
        if(r<2*l)
        {
            cout << 0 << endl;  // 输出 0 并换行
            continue;  // 跳过循环的其余部分
        }
        // 计算项数以及首项与末项的和
        n=r-2*l+1;
        m=r-2*l+2;
        ans=n*m/2;
        // 输出答案
        cout << ans << endl;  // 输出 ans 的值并换行
    }
    return 0;  // 表示程序成功完成
}
```

---

## 作者：GXZJQ (赞：3)

# P10416 [蓝桥杯 2023 国 A] XYZ 题解

[题目链接](https://www.luogu.com.cn/problem/P10416)

## 题目大意

给定一个区间 $[L,R]$，请求出有多少组 $X,Y,Z$ 满足 $X+Y=Z$ 且 $L\le X,Y,Z\le R$。

## 题目分析

乍一看这道题，本来以为需要双指针算法，但仔细一看，发现这是一道规律题，我们只需要对 $Z$ 进行枚举讨论就可以了。需要注意当 $R<2L$ 时，不存在任何一组 $X,Y,Z$ 满足条件，因为此时 $X,Y$ 将会小于下界。

首先，因为 $X,Y,Z$ 必须要满足 $X+Y=Z$ 且 $L\le X,Y,Z\le R$，所以当 $X,Y$ 均取到下界 $L$ 时，$Z=2L$，所以对于所有的 $Z < L$，都不存在任何一组 $X,Y,Z$ 满足条件，当 $Z=2L$ 时，有且仅有一组 $X,Y,Z$ 满足条件，此时 $X=L,Y=L,Z=2L$。

接下来讨论 $Z=2L+1$ 的情况，不难发现，此时共有 $2$ 种情况，分别为 $X=L,Y=L+1$ 和 $X=L+1,Y=L$。我们可以发现 $X,Y$ 的取值是**轮换对称**的，所以对于每次询问，我们只需要计算出 $X$ 的值，$Y$ 值就是 $Z-X$。

推广上面的发现，可以得到，当 $Z=2L+m \le R$ 时，共存在 $m+1$ 种情况，所有情况的 $X$ 的取值可以构成公差为 $1$ 的等差数列 $[L,L+m]$，其本质就是 $X$ 增加 $1$ 的时候，为了保证和不变，就对应将 $Y$ 减少 $1$。

这时对 $m$ 的取值进行讨论，对 $Z=2L+m \le R$ 进行移项可得 $m \in [0,R-2L]$，总的方案数分别对应为 $1+2+3+ \cdots + (m_{\max} +1)$。

不难发现上面的式子是一个等差数列，运用等差数列求和公式可得方案数 $ans$ 为：

$$ans=\frac{(R-2L+1)\times (R-2L+2)}{2} $$

这样子的话，对于每次询问，仅需用 $\mathcal{O}(1)$ 的复杂度即可完成，注意变量类型的选取，选取不当会造成溢出。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t;
long long l, r;
unsigned long long ans;
int main() {
	cin >> t;
	while (t--) {
		cin >> l >> r;
		if (r < 2 * l) {
			cout << 0 << endl;
			continue;
		}
		ans = (1ll * (r - 2 * l + 1) * (r - 2 * l + 2) / 2ll);
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：DFM_O (赞：2)

## [P10416 题目](https://www.luogu.com.cn/problem/P10416)

### 解题思路
我们可以先枚举 $X$，当 $X=L$ 时，由于 $Z$ 不能超过 $R$，所以 $L\le Y\le R-L$，当 $X=L+1$ 时，$L\le Y\le R-L-1$，以此类推。

不难发现，当 $X=L$ 时，$Y$ 有 $R-L-L+1$ 种取值，当 $X=L+1$ 时，$Y$ 有 $R-L-L$ 种取值，当 $X=L+2$ 时，$Y$ 有 $R-L-L-1$ 种取值，以此类推，一直到 $X=R-L$ 时，$Y$ 有 $1$ 种取值。

所以一共有
$$(R-L-L+1)+(R-L-L)+(R-L-L-1)+\cdots+1$$
种情况，易知这个等差数列共有 $R-L-L+1$ 项，上面的式子可化简为：
$$\frac{(R-L-L+2)\times(R-L-L+1)}{2}$$
这样我们就可以在 $O(1)$ 的时间复杂度中回答每个询问了，总时间复杂度 $O(T)$，别忘了特判 $L+L>R$ 的情况。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--)
	{
		int l,r;
		cin>>l>>r;
		if(l+l>r)
		{
			cout<<"0\n";
			continue;
		}
		int x=r-l-l+1;
		int s=(r-l-l+2)*x/2;
		cout<<s<<"\n";
	}
    return 0;
}
```

---

## 作者：Lele_Programmer (赞：1)

# P10416 题解

## 思路

给出 $L$ 和 $R$，对于此区间内第一个存在可行 $X,Y$ 的 $Z$ 值，最小为 $L \times 2$，证明：因为 $X,Y$ 最小只能取 $L$，所以最小 $Z$ 值为 $L \times 2$。

所以，若 $L \times 2 > R$，无解，输出 $0$。

对于一个存在可行解的 $Z (Z<R)$，设 $Z$ 存在 $K$ 组 $X,Y$，则 $Z+1$ 存在 $K+1$ 组 $X,Y$，证明：对于一个 $Z$ 的所有 $X$ 值分别为 $L$ 到 $Z-L$ 之间的正整数，设总共有 $K$ 个解，那么同理，$Z+1$ 的所有 $X$ 值分别为 $L$ 到 $Z+1-L$ 之间的正整数，即 $K+1$ 个解。

所以，问题就变成了求 $\sum\limits_{i=1}^{R-L \times 2+1}i$。

记得开 `long long`！

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

int T,l,r;

signed main() {
    scanf("%lld",&T);
    while (T--) {
        scanf("%lld %lld",&l,&r);
        if (l*2>r) {
            puts("0");
            continue;
        }
        int a=l*2;
        int b=r-a+1;
        printf("%lld\n",(1ll+b)*b/2ll);
    }
    return 0;
}
```

---

## 作者：Chu_awa_xing (赞：1)

# P10416 题解
## 思路
这道题是一道简单的规律题，规律并不难找。通过下面几个例子就能找到规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/ofmbo28e.png)

看完这几个例子会发现解是一个等差数列的和，等差数列的项数和首项是 $R-2L+1$ 而末项是 $1$ 。所以我们就可以通过等差数列求和公式来求出答案，但需要注意的是，如果 $R<2L$ 那么就是无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/56kmip7h.png)

（这没必要贴代码了吧）

---

## 作者：The_jester_from_Lst (赞：0)

一道大水题。

首先考虑无解。阅读题面，首先我们可以发现，$x$ 与 $y$ 的最小值是 $l$，也就是说 $z$ 的最小值为 $2l$。因此当 $r$ 小于 $2l$ 时，答案为 $0$。

进一步观察，我们可以发现对于任意一个不小于 $2l$ 不大于 $r$ 的可能的和 $z$，我们都能从 $l$ 到 $z-l$ 为其匹配两个加数。就样例来说，当和为 $2$，有 $1+1$ 一种可能。当和为 $3$，有 $1+2$ 和 $2+1$ 两种可能。当和为 $4$，有 $1+3$ 和 $2+2$ 和 $3+1$ 三种可能。再明显一点，当和为 $2l$ 时，方案数为 $1$，当和为 $2l+1$ 时，方案数为 $2$，当和为 $2l+2$ 时，方案数为 $3$。于是答案为 $1+2+3$。

这是啥？等差数列求和啊！首项为 $1$，末项为 $r-2l+1$，项数为 $r-2l+1$，那么答案显而易见：
$$(r-2*l+1)*(r-2*l+2)/2$$

附上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define pii pair<int,int>
#define mk make_pair
#define mod 20123
using namespace std;
il int rd(){
    int jya=0,tl=1;char jyt=getchar();
    while(!isdigit(jyt)){if(jyt=='-')tl=-1;jyt=getchar();}
    while(isdigit(jyt)){jya=jya*10+(jyt-'0');jyt=getchar();}
    return jya*tl;
}
il void wr(int jjy){
    if(jjy<0)putchar('-'),jjy=-jjy;
    if(jjy>9)wr(jjy/10);
    putchar(jjy%10+48);
}
il int max(int x,int y){return x>=y?x:y;}
il int min(int x,int y){return x<=y?x:y;}
const int JYAAKIOI=1145141919810;
int T,l,r;
signed main(){
	//freopen("jytwcnm.in","r",stdin);
	//freopen("jytwcnm.out","w",stdout);
	T=rd();
	while(T--){
		l=rd();r=rd();
		if(r<2*l)putchar('0');
		else wr((r-2*l+1)*(r-2*l+2)/2);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Ethan812820 (赞：0)

## 思路
当 $X,Y$ 被最小化为 $L$ 时，$Z$ 被最小化为 $2L$。因此，如果 $Z<2L$，答案为 $0$。  
否则对于每个 $Z\in[2L,R]$，$X$ 可取值为 $[L,Z-L]$，对于每个 $X$ 可对应唯一的 $Y=Z-X$。因此答案为对于每个满足条件的 $Z$ 满足条件的的 $X$ 的数量之和，也就是 $\sum_{i=2L}^{R} i-2L+1$，也就是 $\sum_{i=1}^{R-2L+1} i$。根据等差数列求和公式，答案为 $\frac{[1+(R-2L+1)] \times (R-2L+1)}{2}$。
## 代码
```cpp
#include<iostream>
#define int long long
using namespace std;
signed main(){
    int t;
    cin>>t;
    while(t--){
        int l,r;
        cin>>l>>r;
        if(l*2>r) cout<<0<<"\n";//特判
        else{
            int fir=1,las=r-l*2+1,num=las;//首项、尾项和项数
            cout<<(fir+las)*num/2<<"\n";//等差数列求和
        }    
    }        
    return 0;
}
```

---

## 作者：aCssen (赞：0)

[双倍经验](https://atcoder.jp/contests/arc112/tasks/arc112_a)

### Solution

先考虑个暴力点的做法：枚举 $X \in [L,\color{red}T]$，由 $X+Y=Z,L\le Z \le R $ 得，$ L-X\le Y \le R-X$，又因为 $L \le Y \le R$，所以可以得到 $L \le Y \le R-X$。

为了存在合法的 $Y$，需要满足 $R-X\ge L$，所以可以得到 $X \le R-L$，所以前文中的 $T=R-L$。

那么 $R-L<L$ 怎么办呢？那么就是说，不存在满足存在一个合法的 $Y$ 的合法的 $X$，那答案就是 $0$。

否则，答案为 

$$\sum_{i=L}^T R-L-i+1$$

浅浅的化一下式子，就是 $\sum_{i=L}^T(R-L+1)-\sum_{i=L}^Ti$。

也就是 $(T-L+1)(R-L+1)-[\frac{T(T+1)}{2}-\frac{L(L-1)}{2}]$。

到这里就可以直接算了，但为了让答案更好看一点，可以再算一步，最终答案为

$$\frac{R^2+4L^2-4LR+3R-6L+2}{2}$$

---

## 作者：cute_114514eggy (赞：0)

一道不难的数学题，当 $R < 2L$ 时，无解，因为 $X$ 或 $Y$ 会小于 $L$ ,所以直接输出 0 即可。

如果不是呢？会有规律吗？我们来推导一下：  
当 $Z = 2L$ 时，有一种方案，当 $Z = 2L + 1$ 时，有两种方案，那么 $Z = 2L+sum$ 时，就会有 $sum+1$ 种方案， $X$ 的取值是 $L$ 到 $L+sum$ ,答案就是一个等差数列的和，有 $R-2L+1$ 项， $a_{1} = 1$ , $a_{R-2L+1}=R- 2L+1$ 。 
$$ans=\frac{(R-2L+1)(R-2L+2)}{2}$$
 时间复杂度为 $O(1)$ ，总时间复杂度为 $O(T)$ 。
# code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() 
{
   	int n;
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
	   	long long b,c,sum;//开long long
		cin>>b>>c;
		if (c < 2 * b)
		{
			cout << "0" << endl;
			continue;
		}
		else
		{
    			sum = (1ll * (c - 2 * b + 1) * (c - 2 * b + 2 ) / 2ll);//注意1ll和2ll
    			cout << sum << endl;
		}
	}
	return 0;
}
```

---

## 作者：览遍千秋 (赞：0)

考虑在 $[L,R]$ 范围内枚举 $Z$。

容易观察到：

- 当 $Z<2L$，不存在有序对 $(X,Y)$ 满足 $X+Y=Z$ 且 $L \le X,Y \le R$。
- 当 $Z=2L$，存在一种方案：
1. $X=L,Y=L$
- 当 $Z=2L+1$，存在两种方案：
1. $X=L,Y=L+1$
2. $X=L+1,Y=L$
- $\cdots$
- 当 $Z=2L+k$，且 $Z \le R$，存在 $k+1$ 种方案：$X$ 取遍 $[L,L+k]$，$Y$ 容易对应计算出。

容易发现，$k$ 的取值范围受到 $Z=2L+k\le R$ 的限制，取值范围为 $[0,R-2L]$。

总的方案数为 $1+2+\cdots + (k_{\max}+1)$。

这是一个等差数列，共有 $k_{\max}+1$ 项，和为 $\dfrac{(k_{\max}+1)\cdot (k_{\max}+2)}{2}=\dfrac{(R-2L+1)\cdot (R-2L+2)}{2}$。

需要注意的是，当 $R<2L$，答案为 $0$。

至此，我们可以以 $O(1)$ 的时间复杂度回答每一个询问，总时间复杂度为 $O(T)$。

---

## 作者：xu_zhihao (赞：0)

- 高斯求和：$S=n\times(a_1+a_n)\div2$。~~这么简单的东西~~。

### 题目理解：
- 朴素写法是枚举 $X$，符合条件的 $Y$ 就满足 $L_i\le Y\le R_i-X$。其中 $R_i-X$ 可理解为 $Z$ 的最大值。复杂度 $O(\sum R_i-L_i)$。显然会超时。然而朴素写法复杂度错误的原因最主要就是因为枚举的 $X$ 的一个循环。

- 正解部分。分析题目，可以得知如果 $X=n$，那么满足 $L_i \le Y \le R_i-n$ 的 $Y$ 即为满足条件。 如果满足 $ L_i\le X \le R_i-L_i$ 的 $X$ 即为满足条件。简单整理结合两个条件，即可使用高斯求和算出答案为 $(2+R_i-2 \times L_i) \times(1+R_i-L_i\times2)\div 2$。使复杂度降为了 $O(T)$。可以通过本题。

### AC 代码：

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		long long l,r;
		cin>>l>>r;
		if(l*2>r){cout<<0<<endl;continue;}
		long long xl=l,xr=r-l;
		long long sum=(1+xr-xl+1)*(xr-xl+1)/2ll;
		cout<<sum<<endl;
	}
}
 
~~~

[AC 记录](https://www.luogu.com.cn/record/158420310)

---


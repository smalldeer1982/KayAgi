# [蓝桥杯 2024 省 B] R 格式

## 题目描述

小蓝最近在研究一种浮点数的表示方法：$R$ 格式。对于一个大于 $0$ 的浮点数 $d$，可以用 $R$ 格式的整数来表示。给定一个转换参数 $n$，将浮点数转换为 $R$ 格式整数的做法是：
1. 将浮点数乘以 $2^n$。
2. 四舍五入到最接近的整数。

## 说明/提示

### 样例 1 解释

$3.14 \times 2^2 = 12.56$，四舍五入后为 $13$。

### 数据规模与约定

用 $t$ 表示将 $d$ 视为字符串时的长度。

- 对于 $50\%$ 的数据，保证 $n \le 10$，$t \le 15$。
- 对于全部的测试数据，保证 $1 \le n \le 1000$，$1 \le t \le 1024$，保证 $d$ 是小数，即包含小数点。

## 样例 #1

### 输入

```
2 3.14```

### 输出

```
13```

# 题解

## 作者：YSchencheche (赞：61)

# P10425 [蓝桥杯 2024 省 B] R 格式
[戳这食用更佳哦](https://www.luogu.com.cn/article/kzaoecld)
## 1.注意
$1≤n≤1000$

也就是 $2^{1000}$！

~~还想啥呀~~直接高精度！

## 2.思路

直接乘一个这么大的数是肯定不行的，所以我们要这样：

一次一次地 $\times2$:

```cpp
for(int i=1;i<=n;i++)//n次乘2
	C();//乘法函数（详见后面）
```
一位一位地 $\times2$:
```cpp
for(int i=1;i<=l;i++)//每位都要
	a[i]*=2;
```
这样，这道题就变成了高精度乘低精度最后再判断四舍五入的题了!
## 上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[114514],p,l;//数组开大一点
string q;
void C()//乘法
{
	for(int i=1;i<=l;i++)
		a[i]*=2;//按位乘2
	for(int i=1;i<=l;i++)//进位
	{
		a[i+1]+=a[i]/10;
		a[i]%=10;	
	}
	if(a[l+1])//如果最高位的前一位进位后不是0就要增加长度
		l++;
}
int main()
{
	cin>>n>>q;//q为输入的小数
	reverse(q.begin(),q.end());//反转q方便后续做题
	p=q.find(".");//p用来分割整数、小数部分
	q.erase(p,1);//把烦人的小数点删了
	l=q.size();//l为小数总长
	for(int i=0;i<l;i++)
		a[i+1]=q[i]-48;//字符串转整数数组
	for(int i=1;i<=n;i++)//n次乘2
		C();
	if(a[p]>=5)//小数部分第一位为5四舍五入进位
		a[p+1]++;	
	for(int i=p+1;i<=l;i++)//检查进位
	{
		a[i+1]+=a[i]/10;
		a[i]%=10;
	}	
	if(a[l+1])//再次检查最高位
   		l++;	
	for(int i=l;i>p;i--)//因为前面逆序了所以这里倒着输出
		cout<<a[i];
	return 0;
}
```
## 完结撒花 求通过QwQ
~~点个赞吧~~

---

## 作者：3_14 (赞：6)

## [题目传送门](https://www.luogu.com.cn/problem/P10425)

# 思路

注意：先看数据，$1\le n\le 1000$，就是 $2 ^{1000}$，所以要涉及到的算法是高精（乘）。

我们可以简化一下问题，把高精乘高精转化为高精乘低精，再判断四舍五入，这样就简单多了。


#### 判断四舍五入的主要是

1. 一次一次地$\times 2$

这里乘法用封装成函数比较好。

2. 一位一位地$\times 2$

```
for(int i=1;i<=l;i++) //每位都要
	a[i]*=2;
```

# 代码

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
const int MAX=1e5+1;
int n,a[MAX],len;//定义 
string q;//因为数据太大，用string存储 
void times(){//高精乘法
	for(int i=1;i<=len;i++)a[i]*=2; //按位乘2
	for(int i=1;i<=len;i++){//处理进位
		a[i+1]+=a[i]/10;
		a[i]%=10;
	}
	if(a[len+1])len++;//如果最高位的前一位进位后不是0就要增加长度
}
int main(){
	cin>>n>>q;//输入
	reverse(q.begin(),q.end());//反转q（方便后续） 
	int p=q.find(".");//p用来分割整数、小数部分
	q.erase(p,1);//把小数点删了
	len=q.size();//小数总长
	for(int i=0;i<len;i++)a[i+1]=q[i]-'0';//字符串转整数数组
	for(int i=1;i<=n;i++)times();//n次乘2
	if(a[p]>=5)a[p+1]++;//小数部分第一位为5四舍五入进位 
	for(int i=p+1;i<=len;i++){//检查进位 
		a[i+1]+=a[i]/10;
		a[i]%=10;
	}
	if(a[len+1])len++;//再次检查最高位 
	for(int i=len;i>p;i--)cout<<a[i];//因为前面逆序了,所以这里倒着输出
	return 0;//完美结束 
}
```

---

## 作者：lbh666 (赞：4)

## 题目大意

给你一个整数 $n$ 和一个浮点数 $d$，让你进行以下操作：

1. 将浮点数乘以 $2^{n}$。
2. 四舍五入到最接近的整数。

## 思路分析

考虑到 $2^{n}$ 很大，所以我们需要用到高精度计算。

- 一种直观的想法是用高精度乘法，但更简单的思路是用高精度加法，每次自增一次，相当于乘 $2$，做 $n$ 次加法即可。

注意：做加法时，小数点先忽略。四舍五入的时候，再根据小数点的位置进行四舍五入。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,l,r) for(int i=l;i<=r;++i)
using namespace std;

const int N=100005;
string s;
bool flag=0;
int n,tot=0;
int a[N],lena=0;

void add(){
	int b[N];
	memset(b,0,sizeof(b));
	for(int i=1;i<=lena;++i){
		b[i]+=a[i]+a[i];//自增 
		b[i+1]+=(b[i]/10);//进位 
		b[i]%=10;
	} 
	if(b[lena+1])lena++;//判定位数 
	for(int i=1;i<=lena;++i)a[i]=b[i];//拷贝一份 
}

signed main(){
	cin>>n>>s;//把浮点数当做字符串读进来 
	for(int i=s.size()-1;i>=0;--i){
		if(s[i]!='.'){
			a[++lena]=s[i]-'0';//把去除小数点的浮点数存在a数组里 
			if(!flag)++tot;//tot记录有几位小数 
		}else{
			flag=1; 
		}
	}
	for(int i=1;i<=n;++i)add();//做n次高精度加法 
	int t=tot;//小数点后一位（十分位）所在位置 
	if(a[t]>=5){//四舍五入 
		a[t+1]++;
		for(int i=t+1;i<=lena;++i){//处理进位 
			a[i+1]+=(a[i]/10);
			a[i]%=10;
		}
		if(a[lena+1])lena++; 
	}
	for(int i=lena;i>=t+1;--i)cout<<a[i];//输出 
	return 0;
}
```

---

## 作者：Rindong (赞：2)

# 题意

给定一个浮点数 $d$ 和一个整数 $n$，求出 $d \times 2^{n}$ 之后四舍五入去除小数点的结果。

其中 $n \le 1000$ 即可能要乘 $2^{1000}$，那就是要实现大整数了。

# 思路

回忆小学学的乘法竖式计算，我们在计算两个小数的时候，计算过程中是不用在意有多少个小数点的，直至计算完成才根据多少个小数点添加在结果后面。

所以我们只需要先把读取到的小数，先记录它的小数点位置，经过乘法计算后，把小数点前面的整数部分取出来，再判断小数点之后是否 $\ge 5$，若符合则使新的大整数自增，反之不用管就好。

# 代码

本人比较啰嗦，写代码也比较长，不过比较细，初学者可以容易看懂。

除了大整数，还用了快速幂提高了计算 $2^n$ 的效率。

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;
class BigInt : public vector<int> {
public:
	int float_ind = 0;
	BigInt(string str) {
		int ind = 0;
		for (int x = str.size() - 1; x >= 0; x--, ind++) {
			if (str[x] == '.') {
				float_ind = ind;
				continue;
			}
			push_back(str[x] - '0');
		}
		clear_front_zero();
	}
	//自增 四舍五入的时候用来进位
	void add() {
		at(0)++;
		int carry = at(0) / 10, ind = 1;
		at(0) %= 10;
		while (carry) {
			if (ind >= size()) push_back(0);
			at(ind)++;
			carry = at(ind) / 10;
			at(ind) %= 10;
			ind++;
		}
		clear_front_zero();
	}
	//清除前导零
	void clear_front_zero() {
		for (int x = size() - 1; x != float_ind; x--) {
			if (at(x)) break;
			pop_back();
		}
	}
	//左位移(乘1eX)
	void left_shift(int x) {
		if (!x) return;
		int n = size();
		for (int i = 0; i < x; i++) push_back(0);
		for (int i = size() - 1; i >= x; i--) {
			at(i) = at(i - x);
			at(i - x) = 0;
		}
		clear_front_zero();
	}
	//两个大整数相加 逻辑与自增相似
	BigInt operator+ (const BigInt& other) const {
		BigInt ret(*this);
		int m = other.size(), ind = 0, carry = 0;
		while (ind < m || carry) {
			if (ind >= ret.size()) ret.push_back(0); 
			if (ind < m) ret[ind] += other[ind]; //对位相加
			if (carry) ret[ind]++; //处理进位
			carry = ret[ind] / 10;
			ret[ind] %= 10;
			ind++;
		}
		ret.clear_front_zero();
		return ret;
	}
	BigInt operator* (const int& other) const {
		BigInt ret(*this);
		int carry = 0, ind = 0, n = ret.size();
		while (carry || ind < n) {
			if (ind >= ret.size()) ret.push_back(0);
			if (ind < n) ret[ind] *= other;
			if (carry) ret[ind] += carry;
			carry = ret[ind] / 10;
			ret[ind] %= 10;
			ind++;
		}
		ret.clear_front_zero();
		return ret;
	}
	//模拟竖式计算
	BigInt operator* (const BigInt& other) const {
		BigInt ret("0");
		//乘数中小数点有几位，结果就有几位
		ret.float_ind = float_ind;
		int m = other.size();
		for (int x = 0; x < m; x++) {
			BigInt temp = *this * other[x];
			temp.left_shift(x);
			ret = ret + temp;
		}
		ret.clear_front_zero();
		return ret;
	}
	//四舍五入去除小数
	BigInt round() {
		string ret = "";
		for (int x = size() - 1; x >= float_ind; x--) ret += at(x) + '0';
		BigInt res(ret);
		if (float_ind) if (at(float_ind - 1) >= 5) res.add();
		return res;
	}
	void print(bool int_mode) {
		int n = size();
		for (int x = n - 1; x >= 0; x--) {
			printf("%d", at(x));
			if (x == float_ind) {
				if (int_mode) break;
				printf(".");
			}
		}
		printf("\n");
	}
};
BigInt quick_mi(int b) {
	BigInt ret("1"), a("2");
	while (b) {
		if (b % 2) ret = ret * a;
		a = a * a;
		b /= 2;
	}
	return ret;
}
int main() {
	int n;
	string d;
	cin >> n >> d;
	if (d[0] == '-') {
		cout << d;
		return 0;
	}
	BigInt b(d);
	//b.print(false);
	b = b * quick_mi(n);
	//b.print(false);
	b.round().print(true);
	return 0;
}
```

---

## 作者：__Sky__Dream__ (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P10425)

## 解题思路
数据量很大，所以要用高精度了。$2^{1000}$ 大概是 $10^{300}$，$10^{300} \times 10^{1024}$ 位数在两千位以内，所以内存够。

这里给出两种解法：一个是使用数组，一个是使用队列。使用数组需要考虑 $n$ 的边界。

### 解法一
因为有小数的情况，所以需要记录一下小数点的位置（或者说是小数占几位），无论怎么乘小数位是不会变的，因为每次 $\times 2$ 整数位最多上进 $1$ 位。

详见**代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10010], B = 2, n = 0;

void gj(int a[]) {
	int t = 0; // 用于存储进位
	for (int i = 0; i < n; i++) {
		a[i] = (a[i] * B) + t;
		t = a[i] / 10;
		a[i] %= 10;
	}
	// 如果有进位
	if (t != 0) {
		a[n] = t;
		n++;
	}
}

int main() {
	int N;
	scanf("%d", &N); // 输入需要乘以的次数
	string str;
	cin >> str; // 输入浮点数
	int flag = 0;
	for (int i = str.size() - 1; i >= 0; i--) {
		if (str[i] == '.') {
			flag = str.size() - 1 - i; // 记录小数点的位置
			continue;
		} else {
			a[n] = (str[i] - '0');
			n++;
		}
	}
	while (N--)
		gj(a); // 执行乘法操作
	// 注意 此时为倒序储存 3.14为413 所以起始位i=n-1 十分位为 flag-1（数组有下标0）
	// 判断是否需要四舍五入
	if (a[flag - 1] >= 5) {
		int t = 1; // 末尾+1 注意i=flag
		for (int i = flag; i < n; i++) {
			a[i] = a[i] + t;
			t = a[i] / 10;
			a[i] %= 10;
		}
		if (t != 0) {
			a[n] = t;
			n++;
		}
	}
	// 直接打印
	for (int i = n - 1; i >= flag; i--)
		cout << a[i];
	return 0;
}
```

### 解法二
使用 STL 库里面的队列，不用考虑 $n$ 的位置，不过不能直接获得十位数判断四舍五入。

详见**代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;

// 用于模拟大整数的乘法，每次乘以2
void gj(vector<int> &ver) {
	int t = 0; // 用于存储进位
	for (auto &x : ver) {
		x = x * 2 + t; // 当前位乘以2并加上之前的进位
		t = x / 10; // 计算新的进位
		x = x % 10; // 更新当前位的值
	}
	if (t)
		ver.push_back(t); // 如果还有进位，则添加到vector的末尾
}

int main() {
	int n;
	scanf("%d", &n); // 输入需要乘以的次数
	string str;
	cin >> str; // 输入浮点数
	reverse(str.begin(), str.end()); // 反转字符串，这样小数的处理会变得更简单
	vector<int> ver; // 存储每一位的整数值
	int flag = 0;
	for (int i = 0; i < str.size(); i++) {
		if (str[i] == '.') {
			flag = i; // 记录小数点的位置
			continue;
		} else
			ver.push_back(str[i] - '0'); // 将字符转换为数字并添加到vector中
	}
	while (n--)
		gj(ver); // 执行乘法操作
	reverse(ver.begin(), ver.end()); // 再次反转，恢复原始顺序
	int bak = -1;
	while (flag--) {
		bak = ver.back(); // 从小数点开始，逐个移除位
		ver.pop_back();
	}
	// 如果最后一位（被移除的小数部分的最后一位）大于等于5，则进行四舍五入
	if (bak >= 5) {
		reverse(ver.begin(), ver.end());
		int flag = 1;
		for (int i = 0; i < ver.size(); i++) {
			ver[i] += flag;
			flag = ver[i] / 10;
			ver[i] = ver[i] % 10;
		}
		if (flag)
			ver.push_back(flag);
		reverse(ver.begin(), ver.end());
	}
	for (auto x : ver)
		printf("%d", x); // 输出结果
	return 0;
}
```

完结撒花！

---

## 作者：GXZJQ (赞：1)

# P10425 [蓝桥杯 2024 省 B] R 格式 题解

[题目链接](https://www.luogu.com.cn/problem/P10425)

## 题目大意

给定整数 $n$ 和浮点数 $d$，求出按照题目要求操作后的答案。

## 题目分析

考虑高精度运算。

由题意，$2^n$ 值可能会非常大，属于高精度数据；$d$ 就为浮点数，属于低精度数据。所以这道题就是一个高精度数据乘低精度数据的题目。

但是一定要这样子做吗？对于 $d \times 2^n$，换个角度看一看，这不就是将 $d$ 相加 $2^n$ 次吗？再转换一下，对于给出的数据，我们只需要执行 $n$ 次 $d \leftarrow d + d$ 即可。

到这里应该都明白了，这是一道高精度加法的题目，最后将答案四舍五入即可。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string d;
int n;

//高精度加法函数
string sum(string s) {
	int x = 0;
	string temp = s;
	reverse(s.begin(), s.end());
	reverse(temp.begin(), temp.end());
	//倒序存储
	for (int i = 0; i < s.size(); i++) {
		int y = temp[i] - '0' + s[i] - '0' + x;
		if (y <= 9) {//不需要进位
			s[i] = y + '0';
			x = 0;
		} else {//有进位的情况
			s[i] = y % 10 + '0';
			y /= 10, x = y;
		}
	}
	if (x)s.append(1, x + '0');
	reverse(s.begin(), s.end());
	//倒序输出
	return s;
}

//四舍五入函数
string half_adjust(string ans) {
	unsigned long index = ans.find('.');
	char ch = ans[index + 1];
	ans = ans.erase(index);
	if (ch - '0' >= 5) {//向上舍入
		reverse(ans.begin(), ans.end());
		unsigned long len = ans.size();
		int x = 1;
		for (int i = 0; i < len; i++) {
			int y = ans[i] - '0' + x;
			if (y <= 9) {//不需要进位
				ans[i] = y + '0';
				x = 0;
			} else {//有进位的情况
				ans[i] = y % 10 + '0';
				y /= 10, x = y;
			}
		}
		if (x)ans.append(to_string(x));
		reverse(ans.begin(), ans.end());
		//倒序输出
		return ans;
	} else return ans;//直接抛弃小数部分
}

int main( ) {
	cin >> n >> d;
	int len = d.size();
	if (d[len - 1] == '0') {
		d.pop_back();
		len--;
	}
	int idx = d.find('.');
	int re_index = len - idx;//找出小数点的位置
	auto it = remove(d.begin(), d.end(), '.');
	string ans = "";
	d.erase(it, d.end());
	for (int i = 1; i <= n; i++) {
		d = sum(d);//倍增法求和
	}
	ans = d;
	ans.insert(ans.begin() + ans.size() - re_index + 1, 1, '.');
	//重新加入小数点
	cout << half_adjust(ans) << endl;
	return 0;
}

```

---

## 作者：nightwatch.ryan (赞：1)

### 思路

我们可以封装一个大整数类。对于这道题来说，只需要有乘法和加法操作即可。

```cpp
#define N 1350
struct Bigint{
	int len,a[N];
	Bigint(int x=0){
		memset(a,0,sizeof(a));
		for(len=1;x;len++)
		a[len]=x%10,x/=10;len--;
	}
	int &operator[](int i){return a[i];}
	void flatten(int L){
		len=L;
		for(int i=1;i<=len;i++)
		a[i+1]+=a[i]/10,a[i]%=10;
		for(;!a[len];)len--;
	}
	void print(){
		for(int i=std::max(len,1);i>=1;i--)
		std::cout<<a[i];
	}
};
Bigint operator+(Bigint a,Bigint b){
	Bigint c;
	int len=std::max(a.len,b.len);
	for(int i=1;i<=len;i++)
	c[i]+=a[i]+b[i];
	c.flatten(len+1);
	return c;
}
Bigint operator*(Bigint a,Bigint b){
 Bigint c;
 for(int i=1;i<=a.len;i++)
 for(int j=1;j<=b.len;j++)
 c[i+j-1]+=a[i]*b[j];
 c.len=a.len+b.len-1;
 c.flatten(c.len+1);
 return c;
}
```

接下来，我们需要实现一个函数 `ToInt`，这个函数的作用是把输入的字符串（浮点数）转化为一个乘了 $rightmove$ 倍的正整数（字符串，因为存不下），并且返回 $rightmove$。

```cpp
std::pair<std::string,int>ToInt(std::string s){
	int rightmove=0;
	for(int i=(int)s.size()-1;i>=0;i--)
		if(s[i]=='.')break;
		else rightmove++;
	s.erase(s.find('.'),1);
	return {s,rightmove};
}
```

现在到了主函数部分，我们将 $d$ 用上文所提到的 `ToInt` 函数转化为一个乘了 $rightmove$ 倍的正整数，并且保存 $rightmove$ 的值。

```cpp
int n,rightmove=0;
std::string d;
std::cin>>n>>d;
std::pair<std::string,int>result=ToInt(d); 
d=result.first,rightmove=result.second;
```

接着用大整数类的 $power$ 来保存 $2^n$ 的值。

```cpp
Bigint power(1),fac(2);
for(int i=1;i<=n;i++)
	power=power*fac;
```

然后将 $d$ 转换为大整数类型。

```cpp
Bigint ans;
for(int i=d.size()-1;i>=0;i--)
 ans.a[++ans.len]=d[i]-48;//d[i]是字符
```

最后将 $power$ 和 $ans$ 相乘，用 $final$（大整数类的变量）保存结果，并且按照题目的要求进行四舍五入。

```cpp
final=power*ans;
if(final.a[rightmove]>=5){
	Bigint rtl,_1(1);
	for(int i=rightmove+1;i<=final.len;i++)rtl.a[++rtl.len]=final.a[i];
	rtl=rtl+_1; 
	for(int i=rtl.len;i>=1;i--)std::cout<<rtl.a[i];
}
else if(final.a[rightmove]<5){
	Bigint rtl;
	for(int i=rightmove+1;i<=final.len;i++)rtl.a[++rtl.len]=final.a[i];
	for(int i=rtl.len;i>=1;i--)std::cout<<rtl.a[i];
}
```

### 代码

[完整代码点这里](https://www.luogu.com/paste/lr67275g)

---

## 作者：Lele_Programmer (赞：0)

# P10425 题解

## 思路

求 $d \times 2^n$ 四舍五入后的结果。

不难发现，这道题需要用到高精度。

对于输入的 $d$，记录小数点的位置 $mt$，然后将小数点去掉，反转后按位存到数组里。循环 $n$ 次，每次将数字乘 $2$。最后，如果十分位上的数字大于 $5$，则将个位加 $1$，此时可能产生进位，还需进一步处理。

最后，再反着输出数组中的数位即可，只需要输出整数部分（可能需要特判 $0$）。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1000005;

int n;
int a[N];
int len;
int mt;

int main() {
    scanf("%d",&n);
    string d;
    cin>>d;
    bool flag=false;
    for (int i=d.size()-1;~i;--i) {
        if (d[i]=='.') {
            flag=true;
            continue;
        }
        a[++len]=d[i]-'0';
        if (!flag) mt++;
    }
    for (int i=1;i<=n;++i) {
        int j=1,jw=0;
        while (j<=len || jw) {
            a[j]<<=1;
            a[j]+=jw;
            jw=a[j]/10;
            a[j]%=10;
            ++j;
        }
        --j;
        len=j;
    }
    if (a[mt]>=5) {
        int i=mt+1;
        a[i]++;
        while (a[i]>=10) {
            a[i+1]+=a[i]/10;
            a[i]%=10;
            ++i;
        }
    }
    int t=N-1;
    while (t>=mt+1 && !a[t]) t--;
    if (t<mt+1) puts("0");
    else {
        for (int i=t;i>=mt+1;--i) {
            printf("%d",a[i]);
        }
    }
    return 0;
}
```

---


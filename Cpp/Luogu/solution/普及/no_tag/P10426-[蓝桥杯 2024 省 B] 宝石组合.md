# [蓝桥杯 2024 省 B] 宝石组合

## 题目描述


在一个神秘的森林里，住着一个小精灵名叫小蓝。有一天，他偶然发现了一个隐藏在树洞里的宝藏，里面装满了闪烁着美丽光芒的宝石。这些宝石都有着不同的颜色和形状，但最引人注目的是它们各自独特的 “闪亮度” 属性。每颗宝石都有一个与生俱来的特殊能力，可以发出不同强度的闪光。小蓝共找到了 $n$ 枚宝石，第 $i$ 枚宝石的 “闪亮度” 属性值为 $H_i$，小蓝将会从这 $n$ 枚宝石中选出三枚进行组合，组合之后的精美程度 $S$ 可以用以下公式来衡量：

$$
S = H_a H_b H_c \cdot \frac{\operatorname{LCM}(H_a, H_b, H_c)}{\operatorname{LCM}(H_a, H_b) \cdot\operatorname{LCM}(H_a, H_c) \operatorname{LCM}(H_b, H_c)}
$$

其中 $\operatorname{LCM}$ 表示的是最小公倍数函数。

小蓝想要使得三枚宝石组合后的精美程度 $S$ 尽可能的高，请你帮他找出精美程度最高的方案。如果存在多个方案 $S$ 值相同，优先选择按照 $H$ 值升序排列后字典序最小的方案。


## 说明/提示

### 数据规模与约定

- 对 $30\%$ 的数据，$n \leq 100$，$H_i \leq 10^3$。
- 对 $60\%$ 的数据，$n \leq 2 \times 10^3$。
- 对全部的测试数据，保证 $3 \leq n \leq 10^5$，$1 \leq H_i \leq 10^5$。

## 样例 #1

### 输入

```
5
1 2 3 4 9
```

### 输出

```
1 2 3```

# 题解

## 作者：suzy0921 (赞：83)

# 题目分析
### 看到那么大长串的柿子不要慌
![容斥](https://cdn.luogu.com.cn/upload/image_hosting/cy7scp9d.png)
我们把式子 $H _ {a}$ 看作圈 $a$ ,把式子 $H _ {b}$ 看作圈 $b$ ,把式子 $H _ {c}$ 看作圈 $c$ 
$$
\begin{aligned} 
S &= H _ {a} H _ {b} H _ {c} \cdot \frac{\operatorname{LCM}(H _ {a}, H _ {b}, H _ {c})}{\operatorname{LCM}(H _ {a}, H _ {b}) \cdot\operatorname{LCM}(H _ {a}, H _ {c}) \operatorname{LCM}(H _ {b}, H _ {c})}\\


&= (d \times h \times j \times g) \times (g \times j \times e \times i) \times (j \times i \times h \times f) \times\frac{(d \times e \times f \times g \times h \times i \times j)}{(d \times g \times h \times j \times i \times f) \times (d \times g \times h \times j \times e \times i) \times (h \times j \times i \times f \times g \times e)}
\end{aligned}\\
$$
化简完之后我们得到了
$$
S=j\\
$$
$j$ 指的是 $\gcd(H _ {a},H _ {b},H _ {c})$，所以
$$
S=\gcd(H _ {a},H _ {b},H _ {c})
$$
# 做题思路
1.找一个 $cnt[i]$ 用于记录从 $H _ {1}，H _ {2}$ 一直到 $H _ {n}$ 中能被 $i$ 整除的个数。  
2.找到最大的 $i$ 使得 $cnt[i] \ge 3$  记为 $x$  
3.从小到大排序 $H$ 数组。  
4.从 $1$ 到 $n$ 遍历，判断 $H _ {i}\mid x$ ，输出前 3 个满足要求的数。
# 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int h[N],cnt[N];
int main()
{
	int n,x,c=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
		for(int j=1;j*j<=h[i];j++) {
			if(h[i]%j==0){
				cnt[j]++;
				if(j*j!=h[i]) cnt[h[i]/j]++; 
			}
		}
	}
	for(int i=N-5;i>=1;i--){
		if(cnt[i]>=3){
			x=i;
			break;
		}
	}
	sort(h+1,h+n+1);
	for(int i=1;i<=n;i++){
		if(h[i]%x==0){
			cout<<h[i]<<" ";
			c++;
		}
		if(c==3) return 0;
	}
	return 0;
}
``````
完结撒花
~~点个赞趴~~

---

## 作者：ダ月 (赞：25)

我们不妨对 $H_a,H_b,H_c$ 质因数分解，$H_a=\prod p_i^{a_i}$，$H_b=\prod p_i^{b_i}$，$H_c=\prod p_i^{c_i}$。

那么有以下推导：

$$
\begin{aligned}
H_aH_bH_c\dfrac{\operatorname{lcm}(H_a,H_b,H_c)}{\operatorname{lcm}(H_a,H_b)\operatorname{lcm}(H_a,H_c)\operatorname{lcm}(H_b,H_c)}&=\prod p_i^{a_i+b_i+c_i+\max(a_i,b_i,c_i)-\max(a_i,b_i)-\max(a_i,c_i)-\max(b_i,c_i)}
\end{aligned}
$$

不妨令 $a_i\le b_i\le c_i$，那么 $a_i=\min(a_i,b_i,c_i)$，因此：

$$
\begin{aligned}
\prod p_i^{a_i+b_i+c_i+\max(a_i,b_i,c_i)-\max(a_i,b_i)-\max(a_i,c_i)-\max(b_i,c_i)}&=\prod p_i^{a_i+b_i+c_i+c_i-b_i-c_i-c_i}\\&=\prod p_i^{a_i}\\&=\gcd(H_a,H_b,H_c)
\end{aligned}
$$

因此，我们只需要找到三个数，满足 $\gcd$ 最大即可。

然后随便预处理一下每个数的因子，随便做一下就 $O(n\sqrt n)$ 了。

代码就不给了。

---

## 作者：Sweet_2013 (赞：12)

## 我的推导过程

$$
a=2^3\cdot3^2
$$

$$
b=2^2\cdot3^3
$$

最小公倍数（看最大）：$2^3\cdot3^3$。

最大公因数（看最小）：$2^2\cdot3^2$。

$$
S=H_aH_bH_c\dfrac{\operatorname{lcm}(H_a,H_b,H_c)}{\operatorname{lcm}(H_a,H_b)\operatorname{lcm}(H_a,H_c)\operatorname{lcm}(H_b,H_c)}
$$

令 $H_a=x$，$H_b=y$，$H_c=z$。

$$
S=x+y+z+\max(x,y,z)-\max(x,y)-\max(y,z)-\max(x,z)
$$

不妨设 $x\ge y\ge z$，

$$
S=x+y+z+x-x-y-x=z=\gcd(H_a,H_b,H_c)
$$

找到此规律后，也不能枚举 $H_a$，$H_b$，$H_c$，需要用桶排序，将 $1$ 至 $10^5$ 作为桶，把输入的数放到对应的因子桶中，从后往前第一个满足 $3$ 个因子的数即为最大的 $S$。时间复杂度最多是 $O(n\sqrt H)$。
# 附上代码！！！
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pp ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
vector<int>a[100001];
int s[100001], n;
void solve(){
    pp;
    cin>>n;
    for(int i=0;i<n;i++)cin>>s[i];
    sort(s,s+n);
    for(int i=0;i<n;i++){
        for(int j=1;j<=sqrt(s[i]);j++){
            if(s[i]%j==0){
                a[j].push_back(s[i]);
                //需要在满足是因子的基础上判断是否是乘方因子，放在外面是错的
                if(s[i]/j!=j)a[s[i]/j].push_back(s[i]);
            }
        }
    }
    for(int i=100001-1;i>=0;i--){
        if(a[i].size()>=3){
            cout<<a[i][0];
            for(int j=1;j<3;j++)cout<<" "<<a[i][j];
            break;
        }
    }
    return ;
}
int main( ){
    solve();
    return 0;
}
```

---

## 作者：WydnksqhbD (赞：7)

# [P10426 [蓝桥杯 2024 省 B] 宝石组合](https://www.luogu.com.cn/problem/P10426) 题解

## 思路

首先考虑对式子化简。

进行质因数分解：

$$H_a=p_1^{a_1}p_2^{a_2}\dots p_k^{a_k}$$

$$H_b=p_1^{b_1}p_2^{b_2}\dots p_k^{b_k}$$

$$H_c=p_1^{c_1}p_2^{c_2}\dots p_k^{c_k}$$

此时：

$$S=\prod_{i=1}^{k}p_i^{a_i+b_i+c_i-\max\{a_i,b_i\}-\max\{b_i,c_i\}-\max\{a_i,b_i\}+\max\{a_i,b_i,c_i\}}$$

这时，我们可以假设大小关系。因为 $a_i,b_i,c_i$ 的大小关系不影响结果，所以设 $a_i\ge b_i\ge c_i$。

$$S=\prod_{i=1}^{k}p_i^{a_i}$$

所以只需让 $\gcd(H_a,H_b,H_c)$ 最大即可。

使用 `vector` 存储一个数是多少个数的约数，这样复杂度是 $O(\sqrt{x})$ 的。

处理 $n$ 个数的时间复杂度为 $O(n\sqrt{n})$。

接下来寻找元素个数 $=3$ 的 $i$，并使 `vector` 里的 $3$ 个元素 $v_0,v_1,v_2$ 满足 $\gcd(v_0,v_1,v_2)=i$。找到了输出即可。**不 `break` 见祖宗！**

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;
#define int long long

const int N = 1e5 + 5;

int n;
int h[N];

vector<int> v[N];

signed main() {
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		cin >> h[i];
	}
	
	sort(h + 1, h + 1 + n);
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j * j <= h[i]; j++) {
			if (h[i] % j == 0) {
				if (v[i].size() < 3) {
					v[j].push_back(h[i]);
				}
				
				if (j * j < h[i] && v[h[i] / j].size() < 3) {
					v[h[i] / j].push_back(h[i]);
				}
			}
		}
	}
	
	for (int i = 1e5; i; i--) {
		if (v[i].size() >= 3 && __gcd(v[i].at(0), __gcd(v[i].at(1), v[i].at(2))) == i) {
			cout << v[i].at(0) << ' ' << v[i].at(1) << ' ' << v[i].at(2) << endl;
			break;
		}
	}
	
	return 0;
}
```

---

## 作者：DeepSleep_Zzz (赞：5)

**begin**

[P10426 [蓝桥杯 2024 省 B] 宝石组合](https://www.luogu.com.cn/problem/P10426)

# 分析

这题最显眼的就是那一大串数学表达式。

如果暴力解题的话，目测必超时。

所以我们考虑化简。（本人蒟蒻一只，没有神犇们的那般才智，所以接下来的证明过程可能有些玄学，如果想要学习正解的话请移步其他题解。）

首先观察原式，我们可以发现有一堆 $\textup{lcm}$ 那么我们充分~~发挥人类的智慧~~，我们猜想这题很有可能跟 $\gcd$ 有关。

进一步的，因为 $H_a$、$H_b$ 和 $H_c$ 的数量关系对化简结果是没有影响的，所以我们不妨设：

$$H_a=H_b\times k_1=H_c\times k_1 \times k_2$$

其中 $k_1$、$k_2$ 为正整数。（人话就是 $H_a$ 是 $H_b$ 和 $H_c$ 的倍数，且 $H_b$ 是 $H_c$ 的倍数。）

那么有原式化简为：

$$
\begin{aligned}
H_a H_b H_c \cdot \frac{H_a}{H_a \cdot H_a \cdot H_b}
&=H_c\\
&=\gcd(H_a,H_b,H_c)
\end{aligned}
$$

看起来这个结果挺靠谱的，所以我就抱着试一试的心态打了一下代码，然后就水灵灵的 AC 啦！

# 代码实现
开一个桶数组存一下每个因子的数量。

然后从后往前找第一个因子数量 $\ge 3$ 的因子并记录。

对 $H$ 数组排序过后从前往后找前三个闪亮度能被这个因子整除的数输出即可。

总时间复杂的 $O(n \sqrt{n})$。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll n,h[100010],t[100010],cnt,a,maxh=-1;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for (ll i=1;i<=n;i++)
    {
        cin>>h[i];
        maxh=max(maxh,h[i]);
        for (ll j=1;j*j<=h[i];j++) // 记录因子数量
        {
            if (h[i]%j==0)
            {
                t[j]++;
                if (j*j!=h[i])
                {
                    t[h[i]/j]++;
                }
            }
        }
    }
    for (ll i=maxh;i>=1;i--)
    {
        if (t[i]>=3)
        {
            a=i;
            break;
        }
    }
    sort(h+1,h+n+1);
    for (ll i=1;i<=n;i++) // 找前三个符合要求的闪亮度
    {
        if (cnt==3)
        {
            break;
        }
        if (h[i]%a==0)
        {
            cout<<h[i]<<" ";
            cnt++;
        }
    }
    return 0;
}
```

**end**

---

## 作者：cmrhhh (赞：4)

## [P10426 [蓝桥杯 2024 省 B] 宝石组合](https://www.luogu.com.cn/problem/P10426)
# 题目大意 
略
# 解法
$$ H_1=p_1^{a_1}p_2^{a_2}...p_n^{a_n} $$ 
$$ H_2=p_1^{b_1}p_2^{b_2}...p_n^{b_n} $$
$$ H_3=p_1^{c_1}p_2^{c_2}...p_n^{c_n} $$
化简式子，有：
$$ 
S=H_1 H_2 H_3\frac{\prod p_i^{\max(a_i,b_i,c_i)}}{\prod p_i^{\max(a_i,b_i)}\prod p_i^{\max(b_i,c_i)}\prod p_i^{\max(a_i,c_i)}} $$
即：
$$
S=\prod p_i^{a_i+b_i+c_i+\max(a_i,b_i,c_i)-\max(a_i,b_i)-\max(b_i,c_i)-\max(a_i,c_i)} 
$$
不妨设 $ a_i \le b_i \le c_i $ 再化简得：
$$ S=\prod p_i^{c_i}=\gcd(H_1,H_2,H_3) $$
此处给出解法：$ O(n\sqrt n) $ 复杂度预处理出所有因数所在的所有 $ H_i $（升序排列，以便处理字典序），之后遍历出解，总复杂度 $ O(n\sqrt n) $
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int MAXN=1e5+10;
int n,h[MAXN+10];
int gcd(int a,int b){if(b==0)return a;return gcd(b,a%b);}
vector<int>fac[MAXN+10];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>h[i];
	sort(h+1,h+1+n);//保证字典序 
	for(int i=1;i<=n;++i){
		for(int j=1;j*j<=h[i];++j)
			if(h[i]%j==0){
				fac[j].push_back(h[i]);
				if(h[i]/j!=j)fac[h[i]/j].push_back(h[i]);
			}
	}
	for(int i=MAXN;i>=1;--i){//最大i从MAXN开始 方便 不用记maxH 
		if(fac[i].size()>=3){
			int a=fac[i][0],b=fac[i][1],c=fac[i][2];
			if(gcd(gcd(a,b),c)==i){cout<<a<<" "<<b<<" "<<c<<"\n";return 0;}
		}
	}
	return 0;
} 
```

---

## 作者：King_and_Grey (赞：3)

# [题目传送门](https://www.luogu.com.cn/problem/P10426)

先把 $ 3 $ 个宝石的闪亮度进行质因数分解：

$$

H_a = p_1^{a_1}p_2^{a_2}p_3^{a_3} \cdots

\\
\\
H_b = p_1^{b_1}b_2^{b_2}p_3^{b_3} \cdots
\\
\\
H_c = p_1^{c_1}p_2^{c_2}p_3^{c_3} \cdots

$$

简化式子：

$$

S = H_aH_bH_c \frac{\prod{p_i}^{ \max{(a_i,b_i,c_i)}}}{\prod{p_i}^{ \max{(a_i,c_i)}}\prod{p_i}^{ \max{(a_i,b_i)}}\prod{p_i}^{ \max{(b_i,c_i)}}}

$$

即：
$$
S = {\prod{p_i}^{ a_i + b_i +c_i + \max{(a_i,b_i,c_i) - \max{(a_i,b_i) - \max{(a_i,c_i) - \max{(b_i,c_i)}}}}} }
$$

都化简到这一步了，我们不难发现：最后的答案和这三枚宝石的质因数有着不可割舍的关系——不就是求三枚宝石的闪亮度的最大公因数最大吗！

化简式子后，就有了下面的超级简单的简述。
## 题目简述
现有 $ n $ 枚宝石，使得其中三枚宝石的闪亮度的最大公因数最大。


------------
C++有个求最大公因数的函数叫 `__gcd()` ，这个函数在 `algorithm` 头文件里面，他的作用是求两个数的[最大公因数，](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308)但是这一题要求**三**个数的最大公因数。

没关系，可以用 `__gcd(a, __gcd(b,c))` 这种方法来求 $ 3 $ 个数的最大公因数，也就是用 $ \gcd $ 嵌套 $ \gcd $ 这种方法来求 $ \gcd (H_a,H_b,H_c)$，那不就好办了吗！

## 思路

先分解质因数，开一个 `vector` 存储，分解完之后判断 `v[i].size() >= 3 && __gcd(v[i].at(0), __gcd(v[i].at(1), v[i].at(2))) == i`，如果符合条件就输出，并 `return 0`。

如果忘记 `return 0`，万一后面还有其他解法也会一起输出，而题目只要输出按照**H值升序排列后字典序最小的方案**。





**奉上 AC 代码：**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
#define int long long
#define AC return 0
const int N = 1e5;
int a[N],n;
vector<int> v[N + 5];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n;i++) {
		cin >> a[i];
	}
	sort(a + 1, a + 1 + n);// 记得导入algorithm
	for (int i = 1; i <= n;i++) {
		for (int j = 1; j * j <= a[i];j++) { // 分解质因数
			if (a[i] % j == 0) {
				if (v[i].size() < 3) { 
					v[j].push_back(a[i]);
				}
				if (j * j < a[i] && v[a[i] / j].size() < 3) {
					v[a[i] / j].push_back(a[i]);
				}
			}
		}
	}
	//输出
	for (int i = 1e5; i >= 0; i--) {
		if (v[i].size() >= 3 && __gcd(v[i].at(0), __gcd(v[i].at(1), v[i].at(2))) == i) { // 最终判断
			cout << v[i].at(0) << " " << v[i].at(1) << " " << v[i].at(2) << "\n";
			AC;//记得退出程序，不然就完蛋
		}
	}
	//华丽收场 <^V^>
}
```

谢谢观看！

---

## 作者：RAY091016 (赞：3)

### 1. 题目解释

给出 $n$ 个数，在其中选出 $3$ 个数 $a$，$b$，$c$ 使得以下式子最大：

$\dfrac{a\times b\times c\times\operatorname{lcm}(a,b,c)}{\operatorname{lcm}(a,b)\times\operatorname{lcm}(a,c)\times\operatorname{lcm}(b,c)}$

### 2. 思路

考虑对此式子做分解。

不妨设 $a=\prod\limits p_i^{a_i}$，$b=\prod\limits p_i^{b_i}$，$c=\prod\limits p_i^{c_i}$。

则有 $\operatorname{lcm}(a,b)=\prod\limits p_i^{\max(a_i,b_i)}$，$\operatorname{lcm}(a,c)=\prod\limits p_i^{\max(a_i,c_i)}$，$\operatorname{lcm}(b,c)=\prod\limits p_i^{\max(b_i,c_i)}$，$\operatorname{lcm}(a,b,c)=\prod\limits p_i^{\max(a_i,b_i,c_i)}$。

因而原式可化为 $\dfrac{\prod\limits p_i^{a_i+b_i+c_i+\max(a_i,b_i,c_i)}}{\prod\limits p_i^{\max(a_i,b_i)+\max(a_i,c_i)+\max(b_i,c_i)}}$。

也即 $\prod\limits p_i^{{a_i+b_i+c_i+\max(a_i,b_i,c_i)-\max(a_i,b_i)-\max(a_i,c_i)-\max(b_i,c_i)}}$。

不妨设对于 $\forall i$，有 $a_i\le b_i\le c_i$。

则有 $\max(a_i,b_i,c_i)=c_i$，$\max(a_i,b_i)=b_i$，$\max(a_i,c_i)=c_i$，$\max(b_i,c_i)=c_i$。

则原式化为 $\prod\limits p_i^{a_i+b_i+c_i+c_i-b_i-c_i-c_i}=\prod\limits p_i^{a_i}=\prod\limits p_i^{\min(a_i,b_i,c_i)}=\gcd(a,b,c)$

至此，问题也就转化为求三个数的最大公约数的最大值。

我们使用一个 vector 数组存储能被 $i$ 整除的数。

遍历整个数组，用 $O(\sqrt n)$ 的时间找因数，然后存到对应的 vector 中。

最后遍历整个 vector,如果 vector 的大小大于等于 $3$，就输出前三项，直接 break。

最后一个需要注意的点是输入进去的数不是严格递增的，所以要先排序。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100100],maxn=-1e9;
vector<int>vec[100100];
int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		maxn=max(maxn,a[i]);
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=sqrt(a[i]);j++){
			if(a[i]%j==0){
				vec[j].push_back(a[i]);
				if(a[i]/j!=j)vec[a[i]/j].push_back(a[i]);
			}
		}
	}
	for(int i=maxn;i>=1;i--){
		if(vec[i].size()>=3){
			cout<<vec[i][0]<<" "<<vec[i][1]<<" "<<vec[i][2];
			break;
		}
	}
	return 0;
}

```

---

## 作者：Vindictae (赞：2)

# 题目大意
有 $n$ 个数 $H_1, H_2, H_3, \dots , H_n$。

我们定义 $S_{a, b, c} = H_a \cdot H_b \cdot H_c \cdot \frac{\operatorname{LCM}(H_a, H_b, H_c)}{\operatorname{LCM}(H_a, H_b) \cdot\operatorname{LCM}(H_a, H_c) \operatorname{LCM}(H_b, H_c)}$，求最大的 $S$ 的排序后字典序最小的方案的 $H_a, _Hb, H_c$。

# 题目思路
首先，看似这个 $S$ 的定义非常离谱，但是我们一统计算，发现：

$$
S_{a, b, c} = \gcd (a, b, c)
$$

于是乎，问题就变成了在 $n$ 个数中找三个数，使得他们的最大公因数最大。

现在就很简单了，我们只需要记录从 $1$ 至 $\max(H_1, H_2, H_3, \dots, H_n)$ 的每一个数都可以被几个数整除，记为 $Mltpl_i$，然后找到最大的 $i$，使得 $Mltpl_i \geq 3$，记此 $i$ 为 $Mx$， 给 $H$ 数组从小到大排序，然后一个一个试可不可以被 $Mx$ 整除。

时间复杂度（由于 $n$ 的最大值与值域最大值相同，为简便统一记为 $n$）：
- 输入：$O(n)$；
- 求 $Mltpl$：$O(n^2)$；
- 排序：$O(n \log n)$；
- 找答案：$O(n)$。

总时间复杂度：$O(n^2)$。

很明显，过不了。

此时我们发现瓶颈在于求 $Mltpl$ 这一步骤，有什么办法优化呢？

欸，我们是不是恰好学过求一个数的左右因数的时间复杂度是 $O(\sqrt {n})$ 啊，所以我们可以将求 $Mltpl$ 与输入合并到一起，在输入的过程中直接把 $Mltpl$ 也求了。

时间复杂度：
- 输入与求 $Mltpl$：$O(n\sqrt {n})$；
- 排序：$O(n \log n)$；
- 找答案：$O(n)$。

总时间复杂度：$O(n\sqrt {n})$。

# AC Code
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

#define endl '\n'
#define int long long
#define inf 0x3f3f3f3f
#define lnf 0x3f3f3f3f3f3f3f3f

using namespace std;

const int N = 1e5 + 5;

int n;
int a[N];
int _Mltpl[N], _Mx;
int cnt;

signed main () {
	cin.tie (nullptr) -> ios :: sync_with_stdio (false);
	
	cin >> n;
	
	for (register int i = 1; i <= n; ++ i) {
		cin >> a[i];
		
		for (register int j = 1; j <= a[i] / j; ++ j) {
			if (a[i] % j) {
				continue ;
			}
			
			++ _Mltpl[j];
			
			if (j ^ (a[i] / j)) {
				++ _Mltpl[a[i] / j];
			}
		}
	}
	
	for (register int i = N - 1; i; -- i) {
		if (_Mltpl[i] > 2) {
			_Mx = i;
			break ;
		}
	}
	
	sort (a + 1, a + n + 1);
	
	for (register int i = 1; i <= n; ++ i) {
		if (a[i] % _Mx) {
			continue ;
		}
		
		cout << a[i] << ' ';
		
		if (++ cnt > 2) {
			break;
		}
	}
	
	cout << endl;
	return 0;
}
```

---

## 作者：coreyyp (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10426)

## 思路

根据 $\gcd$ 和 $\operatorname{lcm}$ 的性质可得：
$$
\operatorname{lcm}(a,b)=\frac{a\cdot b}{\gcd(a,b)}
$$
将这个性质应用到原式 $S$ 中，用 $\gcd$ 表示 $\operatorname{lcm}$ ：
$$
S = H_a H_b H_c \cdot \frac{\frac{H_a \cdot H_b \cdot H_c}{\gcd(H_a,H_b,H_c)}}{\frac{H_a \cdot H_b}{\gcd(H_a,H_b)} \cdot \frac{H_a \cdot H_c}{\gcd(H_a,H_c)} \cdot \frac{H_b \cdot H_c}{\gcd(H_b,H_c)}}
$$
将分子和分母中的 $H_a,H_b,H_c$ 相互约去：
$$
S = \frac{\gcd(H_a,H_b) \cdot \gcd(H_a, H_c) \cdot \gcd(H_b, H_c)}{\gcd(H_a, H_b, H_c)}
$$
根据 $\gcd$ 的性质，易得：
$$
\gcd(a,b,c)=\gcd(\gcd(a,b),c)
$$
因此原式可化简为：
$$
S=\gcd(H_a,H_b,H_c)
$$
所以只要找到三个数 $H_a,H_b,H_c$，让 $\gcd(H_a,H_b,H_c)$ 最大便可。

总时间复杂度 $O(n\sqrt n)$。

---

## 作者：_awa_wangjiawen (赞：1)

观察这个一长串的式子，先尝试进行化简。
$$\begin{aligned} 
S &= H_a H_b H_c \cdot \frac {\operatorname{lcm}(H_a,H_b,H_c)}{\operatorname{lcm}(H_a,H_b) \cdot \operatorname{lcm}(H_a,H_c) \cdot \operatorname{lcm}(H_b,H_c)}\\
&=H_aH_bH_c \cdot \frac{H_aH_bH_c \div \operatorname{gcd}(H_a,H_b) \div \operatorname{gcd}(H_a,H_c) \div \operatorname{gcd}(H_b,H_c) \div \operatorname{gcd}(H_a,H_b,H_c)}{H_aH_b \div \operatorname{gcd}(H_a,H_b) \cdot H_bH_c \div \operatorname{gcd}(H_b,H_c) \cdot H_aH_c \div \operatorname{gcd}(H_a,H_c)}\\
&=\operatorname{gcd}(H_a,H_b,H_c)
\end{aligned}$$
观察到 $1 \le H_i \le 10^5$，可以直接用桶存下每个数的因子。当有一个数至少为三个数的因子时，这个数就是最大的 $S=\operatorname{gcd}(H_a,H_b,H_c)$。找出三个最小的 $H_i$ 使得 $S \mid H_i$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100001],s[100001],sum,x;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=sqrt(a[i]);j++)
			if(a[i]%j==0)
			{
				s[j]++;
				if(j*j!=a[i])
					s[a[i]/j]++;
			}
	for(int i=100000;i>=1;i--)
		if(s[i]>=3)
		{
			x=i;break;
		}
	for(int i=1;i<=n;i++)
	{
		if(a[i]%x==0)
		{
			cout<<a[i]<<" ";
			sum++;
		}
		if(sum==3)	
			return 0;
	}
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

# P10426 [蓝桥杯 2024 省 B] 宝石组合 题解  
一道烦死人的题目。  
### 解题思路
我们定义 $g_{a_1,a_2,...,a_k}$ 为满足是 $a_1,a_2,...,a_k$ 的因数**不是**不是上其中数的因数的最大的数。  
如 $g_{1,2}$ 为 $a_1,a2$ 的因数且不是 $a_3$ 的因数，同理还有 $g_1,g_2,g_3,g_{1,3},g_{2,3},g_{1,2,3}...$。  

那么我们就易得下表：


||$H_a$|$H_b$|$H_c$|$LCM(H_a,H_b,H_c)$|$LCM(H_a,H_b)$|$LCM(H_a,H_c)$|$LCM(H_b,H_c)$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|相等于|$g_ag_{a,b}g_{a,c}g_{a,b,c}$|$g_bg_{a,b}g_{b,c}g_{a,b,c}$|$g_cg_{a,c}g_{b,c}g_{a,b,c}$|$g_ag_bg_cg_{a,b}g_{a,c}g_{b,c}g_{a,b,c}$|$g_ag_bg_{a,b}g_{a,c}g_{b,c}g_{a,b,c}$|$g_ag_cg_{a,b}g_{a,c}g_{b,c}g_{a,b,c}$|$g_bg_cg_{a,b}g_{a,c}g_{b,c}g_{a,b,c}$|  

再带入 $S$。  
得 $S=g_ag_bg_c(g_{a,b}g_{a,c}g_{b,c})^2(g_{a,b,c})^3\frac{g_ag_bg_cg_{a,b}g_{a,c}g_{b,c}g_{a,b,c}}{(g_ag_bg_c)^2(g_{a,b}g_{a,c}g_{b,c}g{a,b,c})^3}=g_{a,b,c}$，非常神奇是不是。  
那好了，回到问题，即求出数组中三个数的最大公因数最大的那几组中数最小的那一组。
因为 $H_i$ 不怎么大，可以直接算出每个数的因数，再看这些因数中有没有超过 3 次的，找出最大的，再看含有该因数最小的 3 个数，按顺序输出即可。  
***
### AC 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int h[100005];
int pri[100005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
		for(int j=1;j*j<=h[i];j++){
			if(h[i]%j==0){
				pri[j]++;
				if(j*j!=h[i])pri[h[i]/j]++;
			}
		}
	}
	int num;
	for(int i=100000;i>=1;i--){
		if(pri[i]>=3){
			num=i;
			break;
		}
	}
	sort(h+1,h+n+1);
	int cnt=0,idx=1;
	while(cnt<3){
		if(h[idx]%num==0){
			cnt++;
			cout<<h[idx]<<" ";
		}
		idx++;
	}
}
```

---

## 作者：AuCodingFrogHoward (赞：0)

注：本文提到的数均为正整数！！！

## 证

对于任意 $H_a$，$H_b$，$H_c$，可以设$H_a=w \times x $，$H_b=w \times y $，$H_c=w \times z $。

正确性易证。

$\therefore$
$\operatorname{lcm}(H_a,H_b,H_c)=w \times x \times y \times z$，$\operatorname{lcm}(H_a,H_b)= w \times x \times y$，$\operatorname{lcm}(H_a,H_c)= w \times x \times z$，$\operatorname{lcm}(H_b,H_c)= w \times y \times z$。

代上七式入原式，得：$S=\frac{w^4 \times x^2 \times y^2 \times z^2 }{w^3 \times x^2 \times y^2 \times z^2}$
$=w$

显然，$\gcd(H_a,H_b,H_c)=w $，
故：$S=w$。

问题转化为：求出最大的 $w$，最小的 $a,b,c$，使得$\gcd(a,b,c)=w$。

依题意 % 你枚举云云。细节见注释。

## 石马：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300005],zc[100005],zx[100005],cx[100005],sx[100005];
int main()
{
	int n;
	cin>>n;
	memset(zx,0x7f,sizeof(zx));//赋极值，保稳定。 
	memset(cx,0x7f,sizeof(cx));
	memset(sx,0x7f,sizeof(sx));
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//π一遍序 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*j<=a[i];j++)
		{
			if(a[i]%j==0)
			{
				zc[j]++;
				if(j!=a[i]/j)
				{
					zc[a[i]/j]++;//判平方 
				}
			}
		}
	}
	int xk;
	for(int i=100005;i>=1;i--)//倒序枚举 
	{
		if(zc[i]>=3)//最大找到就退 
		{
			xk=i;
			break;
		}
	}
	for(int i=1,j=1;i<=n,j<=3;i++)//顺序枚举 
	{
		if(a[i]%xk==0)
		{
			j++;
			cout<<a[i]<<" ";
		}
	}
}
```

---


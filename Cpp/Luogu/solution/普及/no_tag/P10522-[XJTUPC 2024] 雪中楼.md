# [XJTUPC 2024] 雪中楼

## 题目描述

西安交通大学下雪了，所有楼顶都被积雪覆盖。

在梧桐道上有 $n$ 座房子，自南向北第 $i$ 座房子的标号是 $i$，所有房子的高度互不相同。LNC 从南向北，依次登上每栋楼楼顶，然后他会回头观察他已经到达过的房子，并记录下这些房子中，比当前他所在房子矮的所有房子中，最高的房子的编号，记为 $a_i$。特殊的，当没有房子比当前房子矮的时候，$a_i=0$。

现在给你所有的 $a_i$，要求你还原出所有楼的大小关系。由于高度的具体值未知，你只需要按照高度从低到高，输出房子编号。

可以证明对于任何合法的输入，均存在唯一解。

## 说明/提示

假设高度是一个 $1\sim n$ 的排列，那么可以发现高度为 $5, 3, 2, 1, 4$ 是唯一的解，按照高度排名输出得到 $4, 3, 2, 5, 1$。


## 样例 #1

### 输入

```
5
0 0 0 0 2
```

### 输出

```
4 3 2 5 1 
```

# 题解

## 作者：Strange_qwq (赞：5)

每次输入一个 $a_i$
如果 $i=0$ 就插入到链表尾部，否则插入到 $a_i$ 左边，最后再翻转即可。

因为既然左边的房子都已经构造好了。那么右边的房子不影响左边的答案，因此可以增量构造。考虑 $i$ 在答案序列插入到 $a_i$ 后面就是恰好比 $a_i$ 高。

### code
```cpp
#include <bits/stdc++.h>
#using namespace std;
int f[200005];
int g(int u){
	if(f[u]==u){
		return u;
	}
	return f[u]=g(f[u]);
}
int a[200005];
int next[200005];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",a+i);
	}
	for(int i=1;i<=n;++i){
		f[i]=i;
	}
	for(int i=n;i;--i){
		int x=g(a[i]);
		next[x]=i;
		f[x]=i;
	}
	int k=n;
	while(a[k]!=0) --k;
	while(k){
		printf("%d ",k);
		k=next[k];
	}
	return 0;
}

---

## 作者：SICKO (赞：4)

一道很有意思的图论。

### 分析

每一个房子会给出在这一个房子前最高的房子，可以把 $0$ 看成空地，然后要给房子按照高度排序。

既然是高度排序，且不存在高度绝对相等的房子，很容易联想到拓扑排序，我们建图让 $a_i$ 指向 $i$，然后跑拓扑排序即可。

但是有一个问题需要解决：$a_i = a_j$ 且 $(i<j)$ 时，谁更高？考虑 $a$ 全部为 $0$ 的情况，说明每一个房子的前面都没有比自己更矮的房子，所以房子的高度是单调递减的。同理回到这个题目里，第 $i$ 个房子的高度会大于第 $j$ 个房子。

这个有向无环图的最终结果应该是除开 $0$ 与最高房子的编号外，每一个房子指向另一间房子且被另一间房子指向，也就是入度出度均为 $1$。所以我们从 $0$ 开始按照拓扑序处理，对当前点所有的指向点按序号大小排序，并且按照序号大小重新指向。说的不是很清楚，可以看看代码。

```c++
for(int i=1, j=0; i<=n; i++){
        sort(vec[j].begin(), vec[j].end(), cmp);
        while(vec[j].size()>1){
            int pos = vec[j].back(); vec[j].pop_back();
            vec[vec[j].back()].push_back(pos);
        }
        j = vec[j].front();
    }
```

### CODE

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 2e5+6;
vector<int> vec[N];
bool cmp(int a, int b){
    return a>b;
}
int main(){
    int n; cin>>n;
    for(int i=1; i<=n; i++){
        int x; cin>>x;
        vec[x].push_back(i);
    }
    for(int i=1, j=0; i<=n; i++){
        sort(vec[j].begin(), vec[j].end(), cmp);
        while(vec[j].size()>1){
            int pos = vec[j].back(); vec[j].pop_back();
            vec[vec[j].back()].push_back(pos);
        }
        j = vec[j].front();
    }
    int res = 0;
    for(int i=1; i<=n; i++){
        res = vec[res].front();
        cout<<res<<" ";
    }
    return 0;
}
```

时间复杂度近似 $O(n)$。

---

## 作者：sillation (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10522)


------------
因为需插入的元素较多，$1 \le n \le 2 \times 10^{5}$。所以考虑用链表，边读边插入。最后翻转就行。

考虑用 C++ 的 STL 库。
支持以下操作：

- `list<int> a`，定义一个 int 类型的链表 $a$。在本题中可以建立一个 int 类型的链表 $s$。

- `list<int>::iterator it`，定义一个 int 类型名为 $it$ 的迭代器。在本题中可以建立一个 int 类型的迭代器数组 $a$。
  
- `insert(it,x)`，在迭送器 $it$ 所在的元素的前面插入元素 $x$。

- `a.begin(),a.end()`，链表开始和末尾的迭送器指针。
  
- `s.pop()_front`，删除链表开头。

代码：
  
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
list<int> s;
list<int>::iterator a[N]={s.begin(),s.end()};//初始化 
int x;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		a[i]=s.insert(a[x],i);
	}
	reverse(s.begin(),s.end());//反转
	while(!s.empty()){
		cout<<s.front()<<" ";
		s.pop_front();
	}
	return 0;
}


```

---

## 作者：shentianxing (赞：2)

## P10522 雪中楼 题解

先假定从低到高的顺序为：$n,(n-1)\dots,2,1$；  
如果在 $i$ 号楼上记的 $x$ 号楼，就说明这栋楼比 $x$ 号楼高，则把 $i$ 插入到 $x$ 后面。  
如果有比 $i$ 编号大的楼也记的是 $x$ 号楼，则说明 $i$ 号楼比那座楼高，所以也可以插入到 $x$ 后面。

因为有很多次插入操作，使用链表实现。  
AC 代码如下：  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct lll{
	int num;
	lll *lastl=NULL;
	lll *nextl=NULL;
}; 
lll s[1000005];
int main(){
	
	int n;cin>>n;
	int first=n;
	for(int i=n;i>0;i--){
		s[i].num=i;
		s[i].lastl=&s[i+1];
		s[i].nextl=&s[i-1];
	}
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		if(x!=0){
			if(i==first){
				first=s[i].nextl->num;
			}
			s[i].lastl->nextl=s[i].nextl;
			s[i].lastl=&s[x];
			s[x].nextl->lastl=&s[i];
			s[i].nextl=s[x].nextl;
			s[x].nextl=&s[i];
			
		}
	}
	for(int i=first;s[i].nextl!=NULL;i=s[i].nextl->num){
		cout<<i<<" ";
	}
	return 0;
}

```

---

## 作者：dingYKP (赞：2)

维护一个链表 $d$，编号为 $d_i$ 的楼的高度高于编号为 $d_{i+1}$ 的楼的高度。

对于每一次观察，有两种情况：  
若 $a_i$ 为 0，由题意知当前楼的高度为最矮的，将当前楼加入到链表尾部。  
若 $a_i$ 不为 0，说明当前楼高度比编号为 $a_i$ 的楼高且在所有高度高于 $a_i$ 的楼中，当前楼是最矮的。故在 $d$ 中将当前楼插入到 $a_i$ 之前。

最后将 $d$ 倒序输出即可。

## Code
```cpp
#include <iostream>
using namespace std;
int pre[200010],nxt[200010];
int main(){
	int n,f=1,l=1;//f代表当前高度最高的楼编号，l代表最低的楼编号
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
		if(t==0){
			pre[i]=l;
			nxt[l]=i;
			l=i;
		}
		else{
			if(pre[t]==0){
				f=i;
				nxt[i]=t;
			}
			else{
				nxt[pre[t]]=i;
				pre[i]=pre[t];
				pre[t]=i;
				nxt[i]=t;
			}
		}
	}
	int cur=l;//当前输出的楼编号
	for(int i=0;i<n;i++){
		cout<<cur<<" ";
		cur=pre[cur];
	}
}
```

---

## 作者：Melo_qwq (赞：2)

拓扑啊？

# 题目大意

给出每个房子前面比它矮的最高的那栋房子的编号，由低到高输出房子编号排列。

# 题目实现

直接从低到高连边，这样高的入度大自然会在后面输出。

所以我们将 $a_i$ 向 $i$ 连边。

特别的，对于 $a_i=0$ 的情况，为了方便我们直接将 $i$ 到 $i-1$ 连边，不能建超级源点是因为会影响拓扑。

不喜欢让读者自行思考，如果两个点出度一样先输出编号大的，因为编号大的在编号小的后面，它的前面又没有比它矮的，所以编号大的一定比编号小的矮。

把拓扑里的队列换成大根堆就行了。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 2e5 + 7 ;
int n ,head[N << 1] ,tot ,in[N] ,x ;
struct edge {
	int to ,nxt ;
}e[N << 1] ;
namespace shin {
	template <typename T> inline void read (T &x) {
		x = 0 ;
		char ch = getchar () ;
		while (! isdigit (ch)) {
			ch = getchar () ;
		}
		while (isdigit (ch)) {
			x = (x << 1) + (x << 3) + (ch xor 48) ;
			ch = getchar () ;
		}
	}
	inline void add (int u ,int v) {
		e[++ tot].nxt = head[u] ;
		head[u] = tot ;
		e[tot].to = v ;
		in[v] ++ ;
	}
	inline void topo () {
		priority_queue <int ,vector <int> ,less <int> > q ;
		rep (i ,1 ,n ,1) {
			if (! in[i]) q.push (i) ;
		}
		while (! q.empty ()) {
			int now = q.top () ;
			q.pop () ;
			cout << now << " " ;
			for (int i = head[now] ;i ;i = e[i].nxt) {
				int nex = e[i].to ;
				if (! -- in[nex]) {
					q.push (nex) ;
				}
			}
		}
	}
}
int main () {
	shin :: read (n) ;
	rep (i ,1 ,n ,1) {
		int x ;
		shin :: read (x) ;
		if (i == 1) goto her ;
		if (! x) {
			shin :: add (i ,i - 1) ;
			goto her ;
		}
		shin :: add (x ,i) ;
		her : ;
	}
	return shin :: topo () ,0 ;
}
//kafka & かみや & やえみこ
```

---

## 作者：Drifty (赞：2)

### Preface

简单题赛时做了 30+ 分钟，太菜了。

### Solution

由于每次输入 $a_i$ 我们会发现，在当前已经形成的序列中，$i$ 比一直到 $a_i$ 的高度都要大，因此在统计高度关系时要用到大量的插入操作，那么自然而然就想到了链表。

考虑维护一个链表 $l$，每次输入一个 $a_i$，若 $i\neq 0$ 就把 $i$ 插入到 $l_{a_i}$ 的左边即可，否则插入到尾部。最后翻转即可。

如 $\{0,0,0,0,2\}$：
- 读入 $a_1=0$，将 $i=1$ 插入到尾部，序列变成 $\{1\}$。
- 读入 $a_2=0$，将 $i=2$ 插入到尾部，序列变成 $\{1,2\}$。
- 读入 $a_3=0$，将 $i=3$ 插入到尾部，序列变成 $\{1,2,3\}$。
- 读入 $a_4=0$，将 $i=4$ 插入到尾部，序列变成 $\{1,2,3,4\}$。
- 读入 $a_5=2$，将 $i=5$ 插入到下标 $2$ 的左边，序列变成 $\{1,5,2,3,4\}$。

最后翻转即可。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
list <int> q;
list <int> :: iterator 
    p[200005] = {q.begin(), q.begin()};
int main() {
    ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
    int n;
    cin >> n;
    for (int i=1, x; i<=n; i++)
        cin >> x, p[i] = q.insert(p[x], i);
    reverse (q.begin(), q.end());
    for (auto i : q) cout << i << ' ';
    return 0;
}
```

---

## 作者：水星湖 (赞：2)

给出一种与官方题解不一样的做法。

考虑拓扑排序，从高度低的点向高度高的点连边。

具体地，若 $a_i=0$，那么从 $i$ 向 $i-1$ 连边；否则，从 $a_i$ 向 $i$ 连边。

因为题目要求按照高度从低到高的顺序输出，所以对于两个点 $i$ 和 $j$，如果此时两个点的入度相同（在拓扑排序中修改过的），应该优先输出更大的点的编号（请读者自行思考原因）。

代码就很简单了。
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> p[200005];
int ind[200005], n, x;
void topo() {
    priority_queue<int> q;
    for(int i = 1; i <= n; i++) if(!ind[i]) q.push(i);
    while(!q.empty()) {
        int u = q.top();
        q.pop();
        cout << u << " ";
        for(auto v : p[u]) {
            if(!--ind[v])
                q.push(v);
        }
    }
}
signed main()
{
    cin >> n >> x;
    for(int i = 2; i <= n; i++) {
        cin >> x;
        if(!x) p[i].push_back(i-1), ind[i-1]++;
        else p[x].push_back(i), ind[i]++;
    }
    topo();
    return 0;
}
```

---

## 作者：ChampionCyan (赞：1)

# P1522题解

[更好的观看体验](https://www.luogu.com.cn/article/5gpzgn9z)

## 前言

这道题代码比较简单，思维比较难，我在这里为大家复盘我的赛时思路。

update on 2024.7.8:

增加了关于结构体的部分解释。

## 题目大意

已知每一个数之前比它小的数中最大的数的下标（所有数各不相同），给下标按它所对应的数从小到大排序。

## 解题思路（赛时）

**以下用 $a_i$ 表示下标为 $i$ 的数之前比它小的数中最大的数的下标，若之前没有比它小的数，$a_i$ 计为 $0$。**

维护一个有序数列 $ans$，内容为最终下标排序结果（也就是答案），我们将使用插入排序（看下去你就知道为什么了）。

`for (int i = 1; i <= n; i++)`，若 $a_i \neq 0$，则将 $i$ 插入到 $ans$ 中 $a_i$ 的后面，因为插入后，根据题意，$ans$ 中 $i$ 后面的下标所代表的数都应该大于下标 $i$ 所代表的数，同样 $ans$ 中 $i$ 前面的下标所代表的数都应该小于下标 $i$ 所代表的数。因此插入后 $ans$ 仍然有序。
 
若 $a_i = 0$，直接将其插入最前即可。
 
但是如果不优化插入的时间复杂度，即朴素插入的复杂度为 $O(n)$，总体时间复杂度为 $O(n^2)$，肯定过不了。

等等，我们已经知道了我们插入的位置，如果能直接以 $O(1)$ 的时间复杂度插入，那么这题就完了！

链表恰好可以做到这一点,那么我们将 $ans$ 打包成结构体，那它就长这样（这里使用链状数组）：

update:

结构体无需储存自身信息，最后输出的时候可以根据上一个节点得到该节点的下标，同样下一个节点的下标也可以由这个节点信息里的 next 变量输出。

```cpp
struct node {
	int last, next;
} ans[200001];
```

那么我们就可以写出代码啦！（不懂处看代码）

## Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	int last, next;
} ans[200001];

int n, head, tmp;

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &tmp);//即a[i]，不过a[i]后面用不着，用tmp省内存
		if (tmp)//如果a[i]!=0
			ans[i].last = tmp, ans[i].next = ans[tmp].next, ans[ans[tmp].next].last = i, ans[tmp].next = i;//O(1)插入
		else//如果a[i]=0
			ans[head].last = i, ans[i].next = head, head = i;//O(1)插入到最前，记得把head设为i
	}
	while (head)//如果没扫完
		printf("%d ", head), head = ans[head].next;//打印、下标更新
	return 0;
}
```

## 最后

为什么使用插入排序？因为插入排序扫一遍是 $O(n)$ 的，在**不知道插入哪里或需要移动数据时**是 $O(n^2)$ 的，因为插入是 $O(n)$ 的。但这题使用链表后既知道插入哪里，又可以 $O(1)$ 插入，那么最终时间复杂度就是 $O(n)$，可以通过此题。

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10522)

感觉赛时没 A 这题挺可惜的，毕竟链表用的不多。

边输入边插入，如果 $x=0$ 就插入到链表尾部，否则插入到 $a_x$ 左边，最后翻转输出。

```cpp
#include <iostream>
#include <algorithm>
#include <list>
using namespace std;
const int N = 2e5 + 10;
list<int> ls;
list<int>::iterator a[N] = {ls.begin(), ls.end()};
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        a[i] = ls.insert(a[x], i);
    }
    reverse(ls.begin(), ls.end());
    while (!ls.empty()) {
        cout << ls.front() << " ";
        ls.pop_front();
    }
    return 0;
}
```

---

## 作者：Y_zhao111 (赞：0)

### Description
题目传送门：[P10522 [XJTUPC2024] 雪中楼](/problem/p10522)。

由于 $n \le 2 \times 10^5$，插入次数太多，考虑维护链表。

### Analysis
对于每次操作，输入 $a_i$，若 $i=0$ 就将 $a_i$ 插到链表尾部，否则插到 $a_i$ 左边，最后翻转完输出，就这么简单。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 2e5 + 10

list <int> l;
list <int> :: iterator number[int(MAXN)] = 
{
	l.begin() , l.end()
};

main()
{
	int n;
	cin >> n;
	
	for(int i = 1 ; i <= n ; i ++)
	{
		int x;
		cin >> x;
		
		number[i] = l.insert(number[x] , i); //插入函数
	}
	
	reverse(l.begin() , l.end()); //翻转
	
	for(list <int> :: iterator it = l.begin() ; it != l.end() ; it ++) // 迭代器
	{
		cout << *it << " ";
	}
	return 0;
}
```

---

## 作者：SSHHXD (赞：0)

## **题意**
$n$ 间房子，告诉了第 $i$ 间房子在 $1$ 到 $i-1$ 这个区间内比它矮的所有房子中最高的房子。按高度从低到高还原房子编号顺序。

## **题解**
我有一个很大胆的想法，并且它成功了……  
首先声明，这种解法并非最优解。

不妨对每间房子下定一个**地位** $k_i$（可以为负数），地位越低的越矮。

按地位算一下，地位在两个房子之间的房子的地位就取它们的平均值，插入进去，排序就可以了，下面是详细做法。

令第一个房子地位为 0，对于后面输入的第 $i$ 间房子的，比它矮的所有房子中最高的房子的编号 $a_i$，记 $h_{max}$ 为在 $1$ 到 $i-1$ 中最高的房子的编号，$h_{min}$ 为最矮的。  
维护每一个房子的所有的比这个房子高的最矮的房子 $b_i$。

若 $a_i=0$，  
则此时第 $i$ 号房子的地位是最低的：  
$$k_i\gets k_{h_{min}}-1$$
$$b_i\gets h_{min}$$
$$h_{min}\gets i$$

若 $a_i=h_{max}$，  
则此时第 $i$ 号房子的地位是最高的:
$$k_i\gets k_{h_{max}}+1$$
$$b_{h_{max}}\gets i$$
$$h_{max}\gets i$$

否则，就可以把第 $i$ 号房子插入到 $b_i$ 和 $a_i$ 房子之间：
$$b_i\gets b_{a_i}$$

由于 $k_{a_i}<k_i < k_{b_i}$，我们可以：
$$k_i\gets \frac{k_{a_i}+k_{b_i}}{2}$$

同时，$b_{i}$ 和 $b_{a_i}$ 都会收到改变：
$$b_{a_i}\gets i$$

最后得到每一个房子的地位，读入时可以用结构体记录一下顺序，结构体排序 `sort()` 一下就解决了。

### 注意的细节：
由于数据量大，  
$k_i$ 需要是 `long double`  
对于  
$k_i\gets k_{h_{min}}-1$  
$k_i\gets k_{h_{max}}+1$  
这两条公式，为了防止精度丢失过快，可以改为  
$k_i\gets k_{h_{min}}-10^{14}$  
$k_i\gets k_{h_{max}}+10^{14}$  

时间复杂度 $O(n \times \log{n})$，  
空间复杂度 $O(n)$。  
代码：
```cpp
#include <bits/stdc++.h>
#define N 200200
using namespace std;
int n;
struct info{
	long double val;
	int index;
}k[N];
bool cmp(info a,info b){
	return a.val<b.val;
}
int b[N],x,Hmin,Hmax;
int main(){
	cin>>n;
	cin>>k[1].val;
   /*读入的第一个数必然为0，故可以作为k[1]的地位*/
	k[1].index=1;
	
	Hmin=1;
	Hmax=1;
	for(int i=2;i<=n;i++){
		scanf("%d",&x);
		k[i].index=i;
		if(x==0){
			b[i]=Hmin;
			k[i].val=k[Hmin].val-1e14;
          /*开大一点的数字防止精度丢失*/
			Hmin=i;
		}else if(x==Hmax){
			b[Hmax]=i;
			k[i].val=k[Hmax].val+1e14;
			Hmax=i;
		}else{
			k[i].val=(k[x].val+k[b[x]].val)*1.0/2;
			b[i]=b[x];
			b[x]=i;
		}
	}
	sort(k+1,k+n+1,cmp);
	for(int i=1;i<=n;i++){
		printf("%d ",k[i].index);
	}
	return 0;
}
```

---

## 作者：abc1856896 (赞：0)

# solution
由于每次插入 $a_i$ 要用到的插入操作极多，那么考虑维护链表。

每次插入一个 $a_i$，若 $i$ 不是 $0$，那么就把 $i$ 插入到链表 $a_i$ 的左边即可。

最后再翻转即可。

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
list<int> st;

void solve(){
	list<int>::iterator a[200005]={st.begin(),st.begin()};
    cin>>n;
    for(int i=1;i<=n;i++){
    	int x;
    	cin>>x;
    	a[i]=st.insert(a[x],i);
    }
    reverse(st.begin(),st.end());
    for(auto i:st){
    	cout<<i<<" ";
    }	
}
int main() {
	solve();
    return 0;
}
```

---

## 作者：Kazeno_Akina (赞：0)

写在前面：这题一道线性题为啥要出 $2 \times 10^5$ 的数据范围……

----

[题目传送门](https://www.luogu.com.cn/problem/P10522)

题意感觉写的还是相当清楚的，在此不作赘述。

考虑到题目里面写到“**可以证明对于任何合法的输入，均存在唯一解**”，我们考虑一个事情：显然对于一个合法的输入序列，它的任意前缀也是合法的输入序列。

但是你发现在一个合法的输入序列后面接东西并不会影响前面这些楼之间的相对高度关系。

也就是说，对于一个合法输入序列 $a_{1} \sim a_{k}$，假设我们得到的答案序列是 $b_{1} \sim b_{k}$，这是 $1 \sim k$ 的一个排列；那么对于输入序列 $a_{1} \sim a_{k+1}$，它对应的答案序列中，$1 \sim k$ 的排列顺序和 $b_{1} \sim b_{k}$ 中应当一致。

换句话说对于新的答案序列 $c_{1} \sim c_{k+1}$，存在一个下标 $x$，满足：

+ $\forall 1 \le i \le x-1,c_{i}=b_{i}$；

+ $c_{x}=k+1$；

+ $\forall x+1 \le i \le k+1,c_{i}=b_{i-1}$。

那么我们考虑怎么找到这个下标 $x$。发现题目里给的 $a_{k+1}$ 正好符合这个要求：你只需找到 $a_{k+1}$ 在原有答案序列中的位置，然后将 $k+1$ 插在该位置的后面即可，正确性易见（$a_{n}$ 序列的定义就是这个……）

于是只需要通过链表简单维护该答案序列即可，输入一个 $a_{i}$ 就更新序列。复杂度 $O(n)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
struct node{int fa,ch;};
int n,init;
node l[N];
inline void insert(int p,int fa,int ch){l[fa].ch=p,l[ch].fa=p,l[p].ch=ch,l[p].fa=fa;}//如果你不想思考这四个操作的顺序不妨直接这么干
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> init,l[1].fa=l[1].ch=0,l[0].fa=l[0].ch=1;//注意到a序列第一项必然是0
    for(int i(2);i<=n;++i){
        cin >> init;//输入a序列
        insert(i,l[init].fa,init);
    }
    for(int p(l[0].fa);p;p=l[p].fa) cout << p << ' ';
    return 0;
}
```

---


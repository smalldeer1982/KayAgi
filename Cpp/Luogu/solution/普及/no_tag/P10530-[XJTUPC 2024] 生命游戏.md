# [XJTUPC 2024] 生命游戏

## 题目背景

在著名的生命游戏中，二维方格中每个细胞死或活的状态由它周围的八个细胞（上、下、左、右、左上、左下、右上、右下）所决定。

具体规则如下：

孤单死亡：如果细胞的邻居小于等于 1 个，则该细胞在下一次状态将死亡；

拥挤死亡：如果细胞的邻居在 4 个及以上，则该细胞在下一次状态将死亡；

稳定：如果细胞的邻居为 2 个或 3 个，则下一次状态为稳定存活；

复活：如果某位置原无细胞存活，而该位置的邻居为 3 个，则该位置将复活一个细胞。

在此规则下也出现了很多有趣的图形，比如说下图就是"轻量级飞船"连续的五个回合的情况：它的周期是 4，每 2 个回合会向右边走一格。

![](https://cdn.luogu.com.cn/upload/image_hosting/28o5txyh.png)

## 题目描述

现在我们将在树上进行简化版的生命游戏，首先将给出一棵含有 $n$ 个点，$n-1$ 条边的树和一个整数 $k$。

在每回合时，当前剩余的度数为 $k$ 的点及与其连接的边会瞬间同时被删去。

形式化的，每回合都将按顺序进行如下操作：

   -  统计当前剩余每个点的度数（一个点的度数定义为为，这个点当前连接的边的条数）。
   - 将所有度数**恰好**为 $k$ 的点标记。
   - 将上一步标记的点及其连接的边全部删去。

我们希望知道在无穷多回合后，这棵树将被分为多少个连通块。若最终两个点能够直接或间接的通过若干条边相连，则认为这两个点属于同一个连通块。

## 说明/提示


对于样例 1:

这棵树的初始形态为：

![](https://cdn.luogu.com.cn/upload/image_hosting/g5x6u2fx.png)

其中三个点的度数依次为 $1,2,1$。

在一回合过后，点 $1,3$ 被删除。

这棵树变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/5x6vo3it.png)

容易发现之后这棵树的形态将不会变化，所以最终的连通块个数是 $1$。

对于样例 2：

初始形态为：

![](https://cdn.luogu.com.cn/upload/image_hosting/hdq30nrf.png)

一回合之后变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/td8lj616.png)

之后保持不变，最终连通块个数为 $2$。

对于样例 3：

初始形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/tfu21fc0.png)

一回合之后变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/3ad1bwnz.png)

再过一回合之后变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/2ax9h1tt.png)

之后保持不变，最终连通块个数为 $5$。

## 样例 #1

### 输入

```
3 1
1 2
2 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 2
1 2
2 3
3 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
10 3
1 2
2 3
9 4
3 5
5 6
6 7
3 9
5 8
5 10
```

### 输出

```
5
```

# 题解

## 作者：Rigel (赞：15)

## 题意

给定一棵 $n$ 个点、$n-1$ 条边的树。每轮找到所有度数为 $k$ 的点并删去这些点与其连接的所有边。求最后的连通块个数。

## 思路

按题意模拟即可。

采用邻接链表存图，**建双向边**，并维护每个点的度数。

考虑队列。首先将所有度数为 $k$ 的点入队并标记。

每一轮开始，遍历所有与队首（本轮结束后将删去的点）相连的点。若一个点不在队列中（无标记），则将其度数减 $1$。若此时该点度数为 $k$，则将其编号存入 $t$ 数组。因为此轮结束后，此点的度数可能仍为 $k$，在下一轮可能被删去。遍历完后，队列头指针后移，继续遍历下一个即将删去的点所连接的点，重复上述操作，直至队空。

每一轮结束后，判断 $t$ 数组中每个点的度数是否依旧为 $k$。若是，将其入队并标记。最后清空 $t$ 数组。

重复操作，直至队列为空，即没有度数为 $k$ 的点可以删除。统计连通块个数即可出答案。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 1000010
using namespace std;
int n,k,tot,deg[maxn],lnk[maxn],q[maxn],t[maxn],vis[maxn],f[maxn],ans;
struct edge{
	int to,nxt;
}e[maxn*2];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')ret=ret*10+(ch&15),ch=getchar();
	return ret*f;
}
void add_edge(int x,int y){
	e[++tot]=(edge){y,lnk[x]};
	lnk[x]=tot;
}
void dfs(int x){
	f[x]=1;
	for(int i=lnk[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(f[v]||vis[v])continue;
		f[v]=1;
		dfs(v);
	}
}
void bfs(){
	int hed=0,til=0;
	for(int i=1;i<=n;i++)if(deg[i]==k)q[++til]=i,vis[i]=1;
	while(hed!=til){
		int tot1=0;
		while(hed!=til){
			hed++;
			int u=q[hed];
			deg[u]=0,vis[u]=1;
			for(int i=lnk[u];i;i=e[i].nxt){
				int v=e[i].to;
				if(vis[v]==1)continue;
				deg[v]--;
				if(deg[v]==k)t[++tot1]=v;
			}
		}
		for(int i=1;i<=tot1;i++)if(deg[t[i]]==k)q[++til]=t[i],vis[t[i]]=1;
	}
}
signed main(){
	n=read(),k=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add_edge(u,v),add_edge(v,u);
		deg[u]++,deg[v]++;
	}
	bfs();
	for(int i=1;i<=n;i++)if(!vis[i]&&!f[i])ans++,dfs(i);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：KXY_Moon (赞：3)

# 解法

**按题意模拟就可以了**。

用 bfs 结合队列来模拟：

- 初始先将度数是 $k$ 的点加入到队列里，将其标记后把这个点有连边的点度数减 $1$。

- 如果将其减 $1$ 后度数为 $k$ 就加到候补的数组里。

- 队列清空后，先将度数为 $k$ 的点加入队列，直到候补数组和队列都为空。

- 搜索求连通块数量。

复杂度: $O(n)$。


# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> g[1000020];
int out[1000020];
bool vis[1000020];
int dfs(int u)
{
	vis[u] = 1;
	for (auto v:g[u]) if (!vis[v])dfs(v);
	return 0;
}
int main() 
{
	int n,k;
	cin>>n>>k;
	for (int i=1;<=n-1; i++) 
   {
		int u,v;
		cin >>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
		++out[u];
		++out[v];
	}
	queue<int> q;
	for (int i = 1; i <= n; i++) {
		if (out[i] == k)q.push(i);
	}
	while (1){
		if (q.empty())break;
		vector<int> rgw;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			vis[u] = 1;
			out[u]--;
			for (auto& v : g[u]) {
				out[v]--;
				if (out[v] == k)rgw.push_back(v);
			}
		}
		for (auto v:rgw) {
			if (out[v] == k)q.push(v);
		}
	}
	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt++;
			dfs(i);
		}
	}
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：zlqwq (赞：2)

我们开一个数组 $d$ 去表示每个点的入度与出度之和。

一定要双向建边！

第一次，我们直接把度为 $k$ 的点提前扔到队列里。

然后直接 bfs 模拟：

模拟每一个点的细胞游戏，每次让所有与当前点有连边的点度数减一，如果在这一过程中，有一些点的度数变为了 $k$，我们就把它加入队列。

最终数一下连通块的数量即可。


```cpp
#include<iostream>
#include<queue>
#include<vector>
#define int long long
#define debug cout << "zlqwq"
#define inf 1e18

using namespace std;
const int N = 1e6 + 5;
int n,k;
int d[N];
vector<int>ed[N];
int vis[N];
int ans;
void dfs(int now) {
	vis[now] = 1;
	for(auto u : ed[now]) {
		if(!vis[u]) dfs(u);
	}
}
queue<int>q;
void bfs() {
	while(q.size()) {
		vector<int>vec;
		while(q.size()) {
			int f = q.front();
			q.pop();
			d[f]--;
			vis[f] = 1;
			for(auto v : ed[f]) {
				d[v]--;
				if(d[v] == k) vec.push_back(v);
			}
		}
		for(auto v : vec) {
			if(d[v] == k) {
				q.push(v);
			}
		}
	}	
}
signed main() {
	cin >> n >> k;
	for(int i = 1;i < n;++i) {
		int u,v;
		cin >> u >> v;
		ed[u].push_back(v);
		ed[v].push_back(u);
		d[u]++;
		d[v]++;
	}
	for(int i = 1;i <= n;++i) {
		if(d[i] == k) q.push(i);
	}
	bfs();
	for(int i = 1;i <= n;++i) {
		if(!vis[i]) {
			dfs(i);
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Ooj_bai (赞：2)

### 思路  

我们看到题目可以首先想到使用 BFS 进行模拟，当一个点在所连接边恰为 $k$ 时删去。删去时更改相连的点的所连边数。但题目中指明每个点在一轮结束后才可删去，在一轮中这个点的边数可能减至小于 $k$ 从而存活。考虑到可以利用 BFS 的搜索顺序，在每一轮开始时对上一轮的点进行删除。

### 实现
在 BFS 进行的过程中，每一轮要删除的节点额外放进 $Q$ 队列中，当搜索到下一轮时，对队列中的点进行判断是否仍恰有 $k$ 条边，并进行删除。结束后用 BFS 跑一次联通块即可。
### 注意事项
双向边开双倍数组  
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct as{int next,to;}e[50000005];int cnt_a,h[5000005]; 
void add(int x,int y){
  e[++cnt_a].to=y;
  e[cnt_a].next=h[x];
  h[x]=cnt_a;
}//前向星 
int vis[5000005],ans, cnt_b    ,n,k,d[5000005];
//  是否存活     答案 当前轮数       所连边数            
struct node{int o,t;};
void bfs(){
	queue<node>q;queue<int>Q;
	for(int i=1;i<=n;i++){
		if(d[i]==k)q.push({i,0}),vis[i]=-1;
	}
	while(q.size()){
		node Now=q.front();q.pop();
		int now=Now.o;
		if(Now.t!=cnt_b){//当已经结束一轮时，对下一轮进行判断
			cnt_b=Now.t;
			while(Q.size()){
				int del=Q.front();Q.pop();
				if(d[del]!=k){continue;}
				vis[del]=-1;//若del上一轮过去后仍只有k条边相连，标记为消失.
			}
		}
		if(vis[now]!=-1)continue;
		for(int i=h[now];i;i=e[i].next){
			int j=e[i].to;
			d[j]--;
			if(d[j]==k)q.push({j,Now.t+1}),Q.push(j);//如果更改后为正好j所连边数为k,加入队列
		}
	}
}
void check(int o){
	queue<int>q;q.push(o);
	while(q.size()){
		int Now=q.front();q.pop();
		for(int j=h[Now];j;j=e[j].next){
			if(vis[e[j].to]!=0)continue;
			q.push(e[j].to);vis[e[j].to]=2;
		}
	}
}
int main(){
	cin.tie(0);
   	cin>>n>>k;
	for(int i=2;i<=n;i++){
		int a,b;cin>>a>>b;
		add(a,b);add(b,a);//建双向边 
		d[a]++;d[b]++;//记录每个点的边数 
	}
	bfs();
	for(int i=1;i<=n;i++)if(vis[i]==0)check(i),ans++;//检查联通块 
	cout<<ans;
	return 0;
} 
```

---

## 作者：菲斯斯夫斯基 (赞：2)

### 前言

晚修的最后四十分钟为了不划水并结束美妙的一天而做的一道题。

### 思路

首先看到题有一个直觉，就是可以模拟。因为每一个点被删除之后，只有**与这个点相邻的点**的度数会被改变。很容易有一个想法：用一个队列维护度数为 $k$ 的点，然后将相邻的且度数为 $k$ 的点入队。

但是这样的做法是错误的，因为操作**同时进行**。比如样例二，先把节点 $2$ 删了之后节点 $3$ 的度数就只有 $1$ 了。

考虑怎么把上面的做法搞正确。于是想到队列可以维护**这一次**操作要删除的节点。那么上一次操作而新增的点就要在操作完之后统一入队。

那么就可以用一个堆来维护新增的点（为什么是堆下文会提到）。我们将这个新增的节点放入堆，最后在队列空的时候全都进队就好。

但是这样就有了新的问题，一个节点可能在删了一条边之后恰好度数为 $k$ 而放入了堆，但是后面又删了一条与其相邻的边，这个时候它的度数又变为了 $k-1$。所以如果某个节点第二次出现的时候就要将它在堆中删除。

然后就做完了，最后给没有删除的点跑一遍 dfs 就行。因为每条边都至多遍历常数次，加上用了堆，时间复杂度是 $\mathcal O(n \log n)$ 的，当然远远跑不满。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,k,ans;
int in[N],chk[N];
vector<int>v[N];
set<int>s;
queue<int>q;
void dfs(int x)
{
	chk[x]=1;
	for(int i:v[x])
		if(!chk[i])dfs(i);
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		v[x].push_back(y);
		v[y].push_back(x);
		in[x]++,in[y]++;
	}
	for(int i=1;i<=n;i++)
		if(in[i]==k)q.push(i),chk[i]=1;
	while(!q.empty())
	{
		auto x=q.front();
		q.pop();
		for(int i:v[x])
		{
			if(chk[i])continue;
			in[i]--;
			if(s.count(i))s.erase(i);
			else if(in[i]==k)s.insert(i);
		}
		if(q.empty()&&!s.empty())
		{
			for(int i:s)
				chk[i]=1,q.push(i);
			s.clear();
		}
	}
	for(int i=1;i<=n;i++)
		if(!chk[i])dfs(i),ans++;
	cout<<ans;
	return 0;
}

```

---

## 作者：Genius_Star (赞：1)

### 思路：

按题意模拟。

注意到最多只会删除 $n$ 个点，考虑广搜。

即初始先将度数为 $k$ 的点加入队列，然后枚举其相邻的点，若其入度为 $k$，则加入一个栈中，表示下一个**可能**删除的点。

当队列为空时，将栈中度数**真**为 $k$ 的点加入队列。

循环进行下去，直到没有度数为 $k$ 的点停止。

时间复杂度为 $O(N)$，略带小常数。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef long long ll;
typedef double db;
const ll N=1e6+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,k,ans;
ll d[N];
bool f[N];
vector<ll> E[N];
stack<ll> T;
queue<ll> Q;
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
	d[u]++,d[v]++;
}
void dfs(ll u){
	f[u]=1;
	for(auto v:E[u]){
		if(f[v])
		  continue;
		dfs(v);
	}
}
int main(){
	n=read(),k=read();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	  if(d[i]==k)
	    Q.push(i);
	while(1){
		if(Q.empty())
		  break;
		while(!Q.empty()){
			ll u=Q.front();
			Q.pop();
			if(f[u])
			  continue;
			f[u]=1;
			d[u]--;
			for(auto v:E[u]){
				d[v]--;
				if(d[v]==k)
				  T.push(v);
			}
		}
		while(!T.empty()){
			if(d[T.top()]==k)
			  Q.push(T.top());
			T.pop();
		}
	}
	for(int i=1;i<=n;i++){
		if(!f[i]){
			dfs(i);
			ans++;
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：__Cby___ (赞：1)

## 思路  
直接模拟题意即可。  
先广搜，开个队列，初始时加入度数为 $k$ 的点，将其标记并把和这个点有连边的点度数减 $1$，若其减 $1$ 后度数为 $k$ 就加到候补数组里，把队列清空后，将候补数组内度数为 $k$ 的点加入队列，直到候补数组和队列都为空。  
最后深度优先搜索求连通块数即可。复杂度 $O(n)$。
## 代码
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
vector<int> g[1000025];
int out[1000025];
bool vis[1000025];
int dfs(int u) {
	vis[u] = 1;
	for (auto v : g[u]) if (!vis[v])dfs(v);
	return 0;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n - 1; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
		out[u]++;
		out[v]++;
	}
	queue<int> q;
	for (int i = 1; i <= n; i++) {
		if (out[i] == k)q.push(i);
	}
	while (1){
		if (q.empty())break;
		vector<int> rgw;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			vis[u] = 1;
			out[u]--;
			for (auto& v : g[u]) {
				out[v]--;
				if (out[v] == k)rgw.push_back(v);
			}
		}
		for (auto v:rgw) {
			if (out[v] == k)q.push(v);
		}
	}
	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt++;
			dfs(i);
		}
	}
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：WhiteNight__ (赞：1)

# P10530 [XJTUPC2024] 生命游戏
## 题目连接
[P10530 [XJTUPC2024] 生命游戏](https://www.luogu.com.cn/problem/P10530)

## 思路分析
由题目容易想到，用 $ou[i]$ 记录第 $i$ 点的度，每一次迭代找到度为 $k$ 的点，然后删除改点并且把该点所连接的点的度减一，并且当某一次迭代无法删除点时停止迭代，最后统计连通块即可。

但是要注意，可能会出现某个点的度在一次迭代前 $ou[i] > k$，在迭代后 $ou[i] < k$ 的情况，这时不能删除第 $i$ 个点，所以**要在一次迭代结束后再删除点**。

那么就可以想到用两个队列来实现，一个用来记录每一次迭代被删除的点，另一个记录一次迭代后被改变的点，删除点时只用判断被改变过的点的度就可以了。

## 代码实现
```cpp
#include <iostream>
#include <cstdio>
#include <queue>

using namespace std;

struct Edge { // 链式前向星
	int to , next;
}edge[4000050];

int N , K , cnt , ans , ou[1000050] , head[1000050]; // ou用来统计每一个点的度
bool ok;
queue <int> q , add; // q记录被删除的点，add记录一次迭代中被改变的点

inline int Read () // 快读
{
	int x = 0 , y = 1;
	char ch = '\0';
	while ((ch > '9' || ch < '0') && ch != '-') ch = getchar();
	while (ch == '-') y = -y , ch = getchar();
	while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48) , ch = getchar();
	return x * y;
}

void dfs (const int to)
{
	if(ou[to] == -1) return;
	ou[to] = -1;
	for(int i = head[to] ; i ; i = edge[i].next)
		dfs (edge[i].to);
	return;
}

int main()
{
	N = Read() , K = Read();
	for(int i = 1 ; i < N ; i ++)
	{
		int u = Read() , v = Read();
		++ ou[u] , ++ ou[v]; // 每连接一条边度就加一
		edge[++cnt] = {u , head[v]};
		head[v] = cnt;
		edge[++cnt] = {v , head[u]};
		head[u] = cnt;
	}
	
	for(int i = 1 ; i <= N ; i ++) // 统计被删除的点
		if(ou[i] == K)
		{
			ou[i] = -1; // 用-1标记被删除
			q.push(i);
		}
	
	ok = true;
	
	while (ok)
	{
		ok = false;
		
		while (!q.empty()) // 一次迭代，删除连接被删除点的边
		{
			const int t = q.front();
			q.pop();
			
			for(int i = head[t] ; i ; i = edge[i].next)
			{
				const int to_ = edge[i].to;
				
				if(ou[to_] != -1) // 如果这个点没有被删除，就删除连接的一条边
					-- ou[to_] , ok = true , add.push(to_);
			}
		}
		
		while (!add.empty()) // 寻找可以被删除的点
		{
			const int k = add.front();
			add.pop();
			
			if(ou[k] == K)
			{
				ou[k] = -1;
				q.push(k);
			}
		}
	}
	
	for(int i = 1 ; i <= N ; i ++) // 统计连通块
		if(ou[i] != -1)
		{
			dfs(i); 
			++ ans;
		}
	
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：minstdfx (赞：1)

签到题，按题意模拟即可。需要精细实现，如每轮只访问度数改变的点，当度数恰被减为 $k$ 时，加入队列，每次忽略掉被减到度数小于 $k$ 的点。  
考虑证明复杂度，删点操作复杂度为度数之和 $O(n)$，每个点进入队列的次数 $O(1)$，总复杂度线性。
```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge{
	int to;
	int next;
}e[3333333];
int pe=1111111;
int deg[1111111];
void insert(int a,int to){
	e[pe]=(edge){to,e[a].next};
	e[a].next=pe++;
	deg[to]++;
}
std::vector<int> now,tmp;
int vis[1111111];
void dfs(int o){
	vis[o]=1;
	for(int p=e[o].next;p;p=e[p].next){
		if(!vis[e[p].to]){
			dfs(e[p].to);
		}
	}
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;++i){
		int u,v;
		scanf("%d%d",&u,&v);
		insert(u,v);
		insert(v,u);
	}
	for(int i=1;i<=n;++i){
		if(deg[i]==k){
			now.push_back(i);
		}
	}
	while(1){
		for(int i:now){
			vis[i]=1;
			for(int p=e[i].next;p;p=e[p].next){
				deg[e[p].to]--;
				if(deg[e[p].to]==k){
					tmp.push_back(e[p].to);
				}
			}
		}
		now.clear();
		for(int i:tmp){
			if(deg[i]==k){
				now.push_back(i);
			}
		}
		tmp.clear();
		if(now.empty())break;
	}
	int ans=0;
	for(int i=1;i<=n;++i){
		if(!vis[i]){
			++ans;
			dfs(i);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：yegengghost (赞：0)

你说的对，但是晚自习打开该游戏差点误解被撅力（悲）。

题目改完后就是明显的图论问题。

开始就建图，并且把度数已经为 $k$ 的点放进队列里广搜：

接着我们开始模拟生命游戏。把队列里的点一一干掉，邻居的度数减一；其中若删度数时可能会有些点度数恰好变为 $k$，所以我们也可以直接在删度数时把度数有过 $k$ 的点接近数组备用。

最后我们深搜统计联通块数量即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
const int mod=1;
int ksm(int x,int k)
{
	int ans=1,base=x;
	while(k)
	{
		if(k&1) ans=1ll*ans*base%mod;
		base=1ll*base*base%mod; k>>=1;
	}
	return ans;
}
int read()
{
	int f=1,x=0;char ch;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	return f*x;
}
int n,k;
int d[N];
vector<int>a[N];
int vis[N];
int ans;
void dfs(int x)
{
	vis[x]=1;
	for(auto v:a[x])
		if(!vis[v])
			dfs(v);
}
signed main()
{
	n=read();
	k=read();
	for(int i=1;i<n;i++)
	{
		int s,e;
		s=read();
		e=read();
		a[s].push_back(e);
		a[e].push_back(s);
		d[s]++;
		d[e]++;
	}
	queue<int>q;
	for(int i=1;i<=n;i++)
	{
		if(d[i]==k)
			q.push(i);
	}
	while(114514)
	{
		if(!q.size())
			break;
		vector<int>p;//短暂存数据
		while(q.size())
		{
			int f=q.front();
			q.pop();
			d[f]--;
			vis[f]=1;
			for(auto v : a[f])
			{
				d[v]--;
				if(d[v]==k)//如果邻居的度数变成 k 了，那就顺便放进 vector 里
					p.push_back(v);
			}//模拟细胞死亡
		}
		for(auto v:p)
			if(d[v]==k)//在这个过程中可能会有些点在删度数时不是 k 了，所以要判断
				q.push(v);
	}
	//最后统计联通块。
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			dfs(i);
			ans++;
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：WA_sir (赞：0)

## [题目链接](https://www.luogu.com.cn/problem/P10530)

### 题目分析

根据题目，每次操作删除所有度为 $k$ 的点及其连边，并记录下因删除某一点产生的新的度为 $k$ 的点，用于下一次操作。重复操作直到一次操作后没有任何点被记录。

但是，由于每次操作的删点操作同时进行，可能会有点的度 $d_i>k$ 在操作后变成 $d_i<k$ 的情况。此时 $i$ 点并未被删除，但在删边时会将其记录并在下次操作将其删除。

可以在记录下次操作需要删除的点时判断其是否出现过，若出现过则取消记录。

最后计算联通块即可。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int now,to,nxt;
}p[2000005];
queue<int>d;
int n,k,h[1000005],cnt,b[1000005],fa[1000005],ans;
bool live_[1000005],cg,nd[1000005];
int rd()
{
	int xf=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		ch=getchar();
	}
	while(ch<='9'&&ch>='0')
	{
		(xf*=10)+=ch-'0';
		ch=getchar();
	}
	return xf;
}
void ad(int x,int y)
{
	p[++cnt]=node{x,y,h[x]};
	h[x]=cnt;
}
int gf(int x)
{
	if(fa[x]-x)return fa[x]=gf(fa[x]);
	return x;
}
int main()
{
	p[0].nxt=-1;
	n=rd();k=rd();
	for(int i=1,xx,yy;i<n;i++)
	{
		xx=rd();yy=rd();
		ad(xx,yy);
		ad(yy,xx);
		b[xx]++;b[yy]++;
	}
	for(int i=1;i<=n;i++)
		if(b[i]==k)
			d.push(i),live_[i]=true;
	while(!d.empty())
	{
		queue<int>dd;
		while(!d.empty())
		{
			int dq=d.front();d.pop();
			if(live_[dq])
			{
				for(node i=p[h[dq]];i.nxt!=-1;i=p[i.nxt])
				{
					if(live_[i.to])continue;
					b[i.to]--;
					if(nd[i.to])
					{
						nd[i.to]=false;
						continue;
					}
					if(b[i.to]==k)
					{
						nd[i.to]=true;
						dd.push(i.to);
					}
				}
			}
		}
		while(!dd.empty())
		{
			int dq=dd.front();dd.pop();
			if(nd[dq])nd[dq]=false,live_[dq]=true,d.push(dq);
		}
	}
	
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=cnt;i++)
	{
		if((!live_[p[i].now])&&(!live_[p[i].to]))
		{
			int xx=gf(p[i].now),yy=gf(p[i].to);
			if(xx-yy)fa[yy]=xx;
//			cout<<p[i].now<<' '<<p[i].to<<endl;
		}
	}
	for(int i=1;i<=n;i++)if(fa[i]==i&&(!live_[i]))ans++;//,cout<<"i: "<<i<<endl
	printf("%d",ans);
	return 0;
}
```
感谢阅读。

---

## 作者：CaoSheng_zzz (赞：0)

### 题目大意
一棵树一共 $ n $ 个点如果有 $ k $ 个点与某一个点相连那么这一轮的结尾这个点就会~~死~~。

### 思路
这道题有几个坑！

1. 并没有说哪一个节点是根节点。

2. 双向边记得开双倍数组。

3. 等这一轮的点消除完了才能再次判断哪一些点可以消除。

首先我们创建一个数组 $ Size_{n} $ 来表示这个点与几个**存活**的点有连边，既然都说到存活了那么我们还需要创建一个数组 $ life_{n} $ 来表示这个点是否存活。我们还需要注意到一个东西就是消除完点后寻找一个点是否边数为 $ k $，必须是跟这些消除的点所相连的点不然一个点的边数为什么会平白无故的减少。还有最后一个要点再添加消除的点的时候我们要看当前点是否已经被消除过一次了（肯能会有两个消除的点连着同一个点在添加时我们也不好判断）。

最后答案跑一边 dfs 就行了。

如果你全部都懂了的话建议去写吧，代码量极其短~~我觉得因该是普及组第三题的难度~~。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#define sc(ppt) scanf("%d" , &ppt)
#define ll long long
#define prt printf
using namespace std; // 屎山头文件

const int maxn = 1e6 + 1;
bool life[maxn] , vis[maxn]; //life 表示这个点是否存活 vis dfs是表示这个点是否搜索过 
int n , k , Size[maxn] , ans = 0; //size 当前点与几个存活的点相连 
int h[maxn] , cnt = 0;
queue<int> q , p; //q需要消除的点 p被消除完的点判断下一部分该消除哪一些点 
struct edge{
	int next , to;
}e[maxn << 1]; //双边 

inline void add(int u , int v){
	++ cnt;
	e[cnt].next = h[u] ; e[cnt].to = v;
	h[u] = cnt;
} // 链式前向心 

void dfs_ans(int u , int fa){
	vis[u] = 1;
	for(int i=h[u] ; i ; i=e[i].next){
		int v = e[i].to;
		if(v == fa || vis[v] == 1 || life[v] == false) continue;
		dfs_ans(v , u);
	}
} // 树上搜索板子多了几个判断 

signed main(){
	sc(n) ; sc(k) ;
	for(int i=1 ; i<n ; i++){
		life[i] = life[i + 1] = true;
		int u , v ; sc(u) ; sc(v) ;
		add(u , v);
		add(v , u);
		Size[u] ++ ; Size[v] ++;
	} // 输入 
	for(int i=1 ; i<=n ; i++) if(Size[i] == k) q.push(i);
	while(! q.empty()){ // 判断是否还有可以消除的点 
		while(! q.empty()){ // 消除当前需要消除的点 
			int u = q.front() ; q.pop() ; p.push(u);
			if(life[u] == false) continue;
			for(int i=h[u] ; i ; i=e[i].next){
				int v = e[i].to;
				Size[v] --; // 与他有边的点Size-- 
			}
			life[u] = false; // 趋势了 
		}
		while(! p.empty()){ // 寻找下一些需要消除的点 
			int u = p.front() ; p.pop() ;
			for(int i=h[u] ; i ; i=e[i].next){
				int v = e[i].to;
				if(life[v] == true && Size[v] == k) q.push(v);
			}
		}
	}
	for(int i=1 ; i<=n ; i++){
		if(vis[i] == 0 && life[i] == true){ // 看有几个连通块 
			dfs_ans(i , -1);
			++ ans;
		}
	}
	prt("%d" , ans);
	return 0;
}
//CaoSheng' code
```

---

## 作者：MJustinM (赞：0)

## 分析 
这道题首先想到 bfs。

预处理:先将所有度为 $k$ 的点放入队列。

再 bfs，每次将队列中的点的所连的所有点度数减一，并且判断这个点度数减一后是否为 $k$，如果为 $k$，就放入栈中，等候加入队列。

搜索完毕后，队列中数已经被清空了，这时将栈中度数为 $k$ 的点加入队列中,直到栈中没有能加入队列的点，就停止搜索。

最后用 dfs 搜索剩余的连通块个数，就完成了。
# code:
```cpp
#include<bits/stdc++.h>//好习惯*1
using namespace std;
const int N=1e6+5;
vector<int> g[N];
queue<int> q;
int n,k,out[N];
bool vis[N];
void bfs(){
    while(!q.empty()){
		vector<int>sc;
		while(!q.empty()) {
			int u=q.front();
			q.pop();
			vis[u]=1;//标记“删”记号
			out[u]--;
			for(auto v:g[u]) {
				out[v]--;
				if(out[v]==k)sc.push_back(v);//先入sc_
			}                               //        |
		}                                   //        |--------|
		for(auto v:sc)if(out[v]==k)q.push(v);//后入q,一起删 <--|
	}
}
void dfs(int u) {
	vis[u]=1;
	for(auto v:g[u])if(!vis[v])dfs(v);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);//好习惯*2
	cin>>n>>k;
	for(int i=1;i<n;i++) {
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);g[v].push_back(u);
		out[u]++;out[v]++;//记出度
	}
	for(int i=1;i<=n;i++)if(out[i]==k)q.push(i);//初始化
	bfs();
	int ans=0;
	for(int i=1;i<=n;i++){
		if(!vis[i]){//未删
			ans++;
			dfs(i);
		}
	}//dfs找连通块数量
	cout<<ans;
	return 0;//好习惯*3
}
```

---


# [蓝桥杯 2024 国 A] 最长子段

## 题目描述

给定一个长度为 $n$ 的序列 $(s_1,s_2,\cdots,s_n)$ 和三个数 $a,b,c$，你需要找出一对 $L,R$ 满足如下式子：

$$
\sum\limits_{i=L}^Rs_i>a(bR-cL),1 \le L \le R \le n
$$

即，序列中的第 $L$ 至 $R$ 项之和大于 $a\cdot (b\cdot R - c \cdot L)$，求出满足条件的 $L,R$ 中 $R - L + 1$ 的最大值。

测试数据保证存在这样的一对 $L$ 和 $R$。

## 说明/提示

对于 $60\%$ 的评测用例，$n\le 5000$；  
对于所有评测用例，$1\le n\le 3 \times 10^5$，$1\le a,b,c\le 1000$，$|s_i| \le 10^9$。

## 样例 #1

### 输入

```
4 1 5 6
1 2 3 4```

### 输出

```
3```

# 题解

## 作者：yuruilin2026 (赞：12)

一道~~水~~好题 By [Hootime](https://www.luogu.com.cn/user/1275540)。\
简单来说，这道题就是这样滴：\
在数组 $a$ 中确定一个左端点 $l$ 和一个右端点 $r$。\
记录 $sum$ 为 $a_l$ 到 $a_r$ 的和。\
如果 $sum$ 大于一个神奇的式子，那么就算出 $r - l + 1$ 的值，最后输出最大值就行了。\
$a_l$ 到 $a_r$ 的和可以使用前缀和解决，时间复杂度 $O(n^2)$。\
然后我就写出了下面一份代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long p[300005],sum[300005],a,b,c,n,maxx = -1;//开long long是好习惯,虽然我不知道不开行不行
int main(){
	cin >> n >> a >> b >> c;
	for(long long i = 1;i <= n;i++){
		cin >> p[i];
		sum[i] = sum[i-1] + p[i];//前缀和,sum[i]存储的是p[1] ~ p[i]的和
	}
	for(long long l = 1;l <= n;l++){
		for(long long r = l;r <= n;r++){
			if(sum[r] - sum[l-1] > a * (b * r - c * l)){//sum[r] - sum[l-1]代表了p[l] ~ p[r]的和
				maxx = max(maxx,r-l+1);//满足式子就求最大值呗
			}
		}
	}
	cout << maxx;
	return 0;
}
```

然后成功的 TLE 了，只拿到了 $60$ 分。\
为什么呢？题目中的 $n$ 达到了 $3×10^5$，所以说 $O(n^2)$ 是肯定 AC 不了滴！\
我们需要把时间复杂度压缩到近似于 $O(n \log n)$。\
让我们分析一下题目，已知我们求的是 $r - l + 1$ 的最大值，所以 $r$ 和 $l$ 的差值一定要尽量的大，而这个奇奇怪怪的式子又告诉我们，如果 $r$ 和 $l$ 的差值越大，条件就越难满足，如果不能满足，就是差值太大了。\
所以说，一个名叫二分的东东就很有用了。\
建立一个数组 $f$，TA 存储的是左端点耗费的权值。
$$
f_i = min(f_{i-1},sum_{i-1} - a \times c \times i)
$$
其中 $sum$ 是前缀和数组。\
为肾木呢？\
序列中的第 $l$ 至 $r$ 项之和大于 $a \times (b \times r − c \times l)$。\
也就是说序列中的第 $1$ 至 $r$ 项之和减去序列中的第 $1$ 至 $l-1$ 项之和大于 $a \times b \times r − a \times c \times l$。\
所以 $sum_r - sum_{l-1} - a \times b \times r + a \times c \times l$ 大于 $0$。\
所以 $sum_r - a \times b \times r$ 大于 $sum_{l-1} - a \times c \times l$。\
其中右端点的部分就是 $sum_r - a \times b \times r$。\
左端点的部分是 $sum_{l-1} - a \times c \times l$。\
如果 $f_i$ 比 $f_{i-1}$ 还要大，那肯定取 $f_{i-1}$ 啊， $r - l + 1$ 足足能大 $1$ 啊！\
接下来，用 $i$ 枚举 $1 \sim n$，表示 $1 \sim i$ 中的最大值就行了。\
那不多废话，上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long p[300005],sum[300005],f[300005],a,b,c,n; 
int main(){
	cin >> n >> a >> b >> c;
	for(long long i = 1;i <= n;i++){
		cin >> p[i];
		sum[i] = sum[i-1] + p[i];//前缀和 
	}
	long long maxx = 0;
	f[0] = 1e18;//初始化一个
	for(long long i = 1;i <= n;i++){
		f[i] = min(f[i-1],sum[i-1] - a * c * i);
		long long cur = sum[i] - a * b * i;
		long long l = 0,r = i + 1;
		while(l + 1 < r){//二分,但不太一样
			long long mid = (l+r) / 2;
			if(f[mid] < cur){
				r = mid;
			}
			else{
				l = mid;
			}
		}
		if(r <= i){//一定要小于等于!!!
			maxx = max(maxx,i - r + 1);
		}
	}
	cout << maxx;
	return 0;
}
```

---

## 作者：DeepSleep_Zzz (赞：11)

**begin**

[P10579 [蓝桥杯 2024 国 A] 最长子段](https://www.luogu.com.cn/problem/P10579)

# Part 0 前置芝士

前缀和，二分。

# Part 1 题目分析

题意已经清晰了，无需多言。

这题一个最明显也是最好想的思路就是**暴力**，但是显然时间复杂的是 $O(n^2)$ 的。而 $n$ 的最大值可以达到 $3 \times 10^5$，所以这样必 **TLE**，~~但是你拿到 60 pts 后可以去借鉴别人代码了~~。

我们思考一下比 $O(n^2)$ 耗时更少的复杂度，最终我们锁定了 $O(n)$、$O(n \log n)$ 和 $O(n \sqrt{n})$ 三种时间复杂度。

经过~~简单的思考~~深思熟虑过后，我们发现，这题用 $O(n)$ 来求解可能不太现实（或者可能是我太弱了 /bei），而 $O(n \sqrt{n})$ 的耗时也有些极限，所以我们考虑 $O(n \log n)$。

再思考一下，由于 $\log$ 出现的场合比较有限，常见的就两种，一种是排序，另一种就是**二分**。

很显然，这题跟排序连一分钱关系都没有，所以我们最终锁定二分。

# Part 2 解题思路

二分最重要的就是单调性，没有一个单调性的数组这一切就全都是空谈。所以我们现在的问题就是如何构建一个与题目有关的且具有单调性的数组呢？

我们将目光放在题目所给的那一大段条件上（以下我们记 $sum_i$ 为 $s_1 \sim s_i$ 的和）：
$$
\begin{aligned}
\sum_{i=L}^R&>a \cdot (b \cdot R-c \cdot L)\\
sum_R-sum_{L-1}&>a \cdot b \cdot R-a \cdot c \cdot L\\
sum_R-a \cdot b \cdot R&>sum_{L-1}-a \cdot c \cdot L
\end{aligned}
$$

我们考虑用一个数组 $f$ 存储左端点（$L$），然后为了保证其单调性和正确性，我们得出数组 $f$ 的递推式为：
$$
f_i=\min(f_{i-1},sum_{i-1}-a \times c \times i)
$$
为什么要取 $\min$ 呢？  
当 $f_{i-1}<sum_{i-1}-a \times c \times i$ 时，我们来讨论一下：
- 如果 $f_i=f_{i-1}$，它对答案的贡献就是：
  $$
  R-(i-1)+1=R-i+2
  $$
- 如果 $f_i=sum_{i-1}-a \times c \times i$，它对答案的贡献是：
  $$R-i+1$$
显然前者更优，足足比后者大了 $1$ 呢！

这也同时保证了 $f$ 数组的单调不增的性质，为接下来的二分做好了准备。

# Part 3 Tips

到了这里，这道题你就已经完成 90% 了。但是正所谓行百里者半九十，所以最后的写代码环节也是至关重要的。如果你搞不定细节，那一样[完蛋](https://www.luogu.com.cn/record/list?pid=P10579&user=LeavingAC&status=14&page=1)。

大前提：

- 我用的二分方法是 `while (l+1<r)`，如果你的方法和我不同的话可以参考一下思路。

- 以下我们设 $sum_R-a \cdot b \cdot R=x$。

### Part 3.1

首先需要注意的就是二分时 $l$ 的初始值（这个跟上面的 $L$ 没关系！）究竟是 $1$ 还是 $0$？

我们来举个栗子：若 $\forall f_{1 \sim i} < x$，当 $l=1$ 时，$r=2$；$l=0$时，$r=1$。

显然 $r=1$ 是正确结果。所以 $l$ 的初始值为 $0$。

### Part 3.2

然后就是每个二分的易错点：内部判断条件是 `if (f[mid]<=x) r=mid`  还是 `if (f[mid]<x) r=mid`？

要找到这个问题的答案，我们首先要知道我们的目标是找到 $f$ 数组的第一个 $i$ 使 $f_i<x$，所以在 $f_{mid}=x$ 的时候我们要继续找更小的 $f_{mid}$，也就是找更大的 $mid$，也就是右移左端点，也就是 $l=mid$。

所以后者是正确的。

# Part 4 Code


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll n,a,b,c,sum[300010],now,f[300010],x,l,r,mid,pos,ans;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); // 输入输出加速     
    cin>>n>>a>>b>>c;
    for (ll i=1;i<=n;i++)
    {
        cin>>now; // 省点空间
        sum[i]=sum[i-1]+now; // 前缀和
    }
    f[0]=1e18; // 是极大值就行，防止第一次 min 出祸
    for (ll i=1;i<=n;i++)
    {
        f[i]=min(f[i-1],sum[i-1]-a*c*i); // 求 f 数组
        x=sum[i]-a*b*i; // x
        l=0,r=i+1;
        while (l+1<r)
        {
            mid=(l+r)>>1;
            if (f[mid]<x)
            {
                r=mid;
            }
            else
            {
                l=mid;
            }
        }
        if (i>=r)
        {
            ans=max(ans,i-r+1); // 维护最大答案
        }
    }
    cout<<ans;
    return 0; // 完结撒花~
}
```

**end**

---

## 作者：Tan_Wei_Ye (赞：5)

## 贪心 $+$ 尺取（不知道算不算）
不要被标签的二分骗了（

记 $S_i$ 是 $s_i$ 的前缀和。
原柿子可以写为：
$$
S_R - S_{L-1} > abR - acL
$$
变形：
$$
S_R - abR > S_{L-1} - acL
$$
记不等式左边为 $A_R$，右边为 $B_{L-1}$，给两个数组升序排序，排序的同时记录序号。

因为升序，所以若 $A_x > B_y$，那么 $A_{x+1}$ 和 $B_{y-1}$ 肯定也满足。

然后记 $pre$ 是 $B$ 的前缀最小序号；$suf$ 是 $A$的后缀最大序号。

当满足 $A_x > B_y$，用 $suf_x-pre_y$ 更新答案就行。

### 如何找到 $x$ 和 $y$
让 $i$ 从 $1$ 到 ${n-1}$ 循环 (有人教我波浪线怎么打吗？）作为 $y$。

因为 $A$ 是单调的，用指针 $p$ 记录一下当前 $x$ 位置，下次从这里开始就行。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10;
int n,a,b,c,ans;
int s[N],pre[N],suf[N];
pair<int,int> A[N],B[N];
signed main()
{
	cin>>n>>a>>b>>c;
	for(int i=1;i<=n;i++) 
	{
		cin>>s[i];
		s[i]+=s[i-1];
		A[i].first=s[i]-a*b*i,A[i].second=i;
		B[i].first=s[i]-a*c*(i+1),B[i].second=i;
	}
	B[0].first=-a*c,B[0].second=0;
	sort(A+1,A+n+1);
	sort(B,B+n);
	
	pre[0]=B[0].second,suf[n]=A[n].second;
	for(int i=1;i<n;i++) 
		pre[i]=min(pre[i-1],B[i].second);
		
	for(int i=n-1;i>=1;i--)
		suf[i]=max(suf[i+1],A[i].second);
	int p=1;
	for(int i=1;i<n;i++)
	{
		while(A[p].first<=B[i].first && p<n) p++;
		if(A[p].first>B[i].first) ans=max(ans,suf[p]-pre[i]);
	}
	cout<<ans<<endl;
}

---

## 作者：zsq9 (赞：4)

[AC 记录](https://www.luogu.com.cn/record/196115315)

## 思路

首先想暴力，但是因为 $n$ 是 $2\times 10^5$ 所以 $O(n^2)$ 暴力过不了但是可以二分，我细讲一下二分，二分就是在一个序列里（序列是从大到小或从小到大）找一个数，怎么找呢？像猜数游戏，比如从 $1 \sim 100$ 之间猜数我们先猜 $50$ 看是大了还是小了大了就猜 $25$ 小了就猜 $75$ 就这样猜两个数之间的一半，这样的复杂度是多少呢？我们想，每次猜一半就是每次去掉一半可能就是去 $2$ 的幂次可能所以复杂度就是 $O(\log{n})$。这题为什么可以二分呢？做了前缀和所以序列是从小到大，直接套二分模板就行了。

## 代码

二分代码

```cpp
long long l=1,r=n;
	while(l<=r){//二分 
			long long mid = (l+r) / 2;
			if(opzc1[mid]<opzc){
				r = mid+1;
			}
			else{
				l = mid-1;
			}
		}
cout<<l<<"\n";
```

这题正解

```cpp
#include <bits/stdc++.h>
using namespace std;
long long p[500005],ans[500005],opzc35[500005],a,b,c,n; 
int main(){
	cin >> n >> a >> b >> c;
	for(long long i = 1;i <= n;i++){
		cin >> p[i];
		ans[i] = ans[i-1] + p[i];//前缀和 
	}
	long long maxx = 0;
	opzc35[0] = 1e18+5;
	for(long long i = 1;i <= n;i++){
		opzc35[i] = min(opzc35[i-1],ans[i-1] - a * c * i);
		long long opzc = ans[i] - a * b * i;
		long long l = 0,r = i+1;//r-l+1
		while(l<r-1){//二分 
			long long mid = (l+r) / 2;
			if(opzc35[mid]<opzc){
				r = mid;
			}
			else{
				l = mid;
			}
		}
		if(r <= i){
			maxx = max(maxx,i-r+1);
		}	
	}
	cout << maxx;
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：3)

稍微推一推原式：
$$fr1_R-fr1_{L-1}>abR-acL$$
$$fr1_R-fr1_{L-1}+acL-abR>0$$
$$acL-fr1_{L-1}>abR-fr1_{R}$$

其中 $fr1_i$ 表示 $\sum_{j=1}^{i}s_j$，也就是前缀和。

再考虑二分，我们建立一个前缀数组 $fr2_i$ 维护 $\max_{j=1}^{i}acj-fr1_{j-1}$，这样每次二分时可以保证数组单调不减，能够准确找到最合适的下标。对于每次二分 $i$，寻找以 $i$ 为右端点，在 $i$ 左边的距离最远的合法左端点，每次统计最大答案即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int s[300005],fr1[300005],fr2[300005];
signed main()
{
	int n,a,b,c;
	cin>>n>>a>>b>>c;
	for(int i=1;i<=n;i++) cin>>s[i],fr1[i]=fr1[i-1]+s[i];
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		fr2[i]=max(fr2[i-1],a*c*i-fr1[i-1]);
		int sum=a*b*i-fr1[i];
		int l=1,r=i;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(fr2[mid]>sum) r=mid-1,ans=max(i-mid+1,ans);
			else l=mid+1;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：player_1_Z (赞：1)

### 先来理解题目
[题目](https://www.luogu.com.cn/problem/P10579)
### 思路
我们发现可以直接枚举点 $L$ 和 $R$ 然后判断是否符合要求，如果符合就取当前最大值和当前的 $R  - L + 1$ 的最大值。然而，这样的复杂度为 $O(n^2)$，但 $n$ 最大为 $3 \times 10^5$，所以会超时。我们就可以用一个叫二分的东西优化（[大佬的二分博客](https://blog.csdn.net/weixin_73378557/article/details/140895117)）。但我们不能直接用题目的条件，需要给这个条件做一个改变。

首先定义一个数组 $q$，使 $q_i$ 存 $1$ 到 $i$ 的和（前缀和）。
那么条件就是这样一个不等式：$q_r - q_{l - 1} > a \times (b \times r - c \times l)$。

然后再拆括号：$q_r - q_{l - 1} > a \times b \times r - a \times c \times l$。

最后移个项：$q_r - a \times b \times r >q_{l - 1} - a \times c \times l$

很明显，$q_r - a \times b \times r$ 是右端点，$q_{l - 1} - a \times c \times l$ 是左端点。再用 $f_i$ 存 $q_{l - 1} - a \times c \times l$，那么我们就可以用循环加二分，但是二分有些不一样（详见代码），然后在每次二分结束后取最大值。最后输出这个最大值。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c,ax[300005],q[300005],ma=-1,f[300005];
int main(){
	cin>>n>>a>>b>>c;
	for(int i=1;i<=n;i++){
		cin>>ax[i];
		q[i]=q[i-1]+ax[i];
	}
	f[0]=1e18;//极大值就行 
	for(int i=1;i<=n;i++){
		f[i]=min(f[i-1],q[i-1]-a*c*i);
		long long l=0,r=i+1,mid,tj=q[i]-a*b*i;
		while(l+1<r){//l 不能等于 r
			mid=(l+r)/2;
			if(f[mid]<tj){//tj:条件的变形 
				r=mid;
			}
			else l=mid;
		}
		if(r<=i) ma=max(ma,i-r+1);
	}
	cout<<ma;
	return 0;
}
```

---


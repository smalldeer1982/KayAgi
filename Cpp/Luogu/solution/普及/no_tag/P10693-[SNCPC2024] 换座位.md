# [SNCPC2024] 换座位

## 题目描述

树王国在筹备着举办一次盛大的庆典！

Shirost 作为树王国的庆典设计师，准备邀请 $n$ 个嘉宾来参加本次庆典。庆典上一共准备了 $2n$ 个座位，**一个座位最多只能坐一个人且一个人恰好坐一个座位**。Shirost 初步计划将第 $i$ 个嘉宾安排在第 $i$ 个座位上。但是总统调查了这 $n$ 个嘉宾的意愿，第 $i$ 个嘉宾的心仪座位为第 $a_i$ 个座位。但除非能坐到心仪座位上，否则他们只愿意坐在原来的座位上。总统希望 Shirost 能够修改计划，使得尽可能多的嘉宾坐在他们的心仪座位上。

形式化的讲，你需要找到长为 $n$ 的数组 $b_i$ ($1 \leq i \leq n, 1 \leq b_i \leq 2n$) 满足 $\forall i \neq j,b_i \neq b_j$ 且 $\forall i, b_i=i$ 或 $b_i=a_i$。且最大化 $b_i = a_i$ 的个数。

你只需要输出最多的个数即可。

## 说明/提示



对于第一个样例，所有人都可以换到自己的心仪座位。


## 样例 #1

### 输入

```
5
2 6 4 5 3
```

### 输出

```
5
```

# 题解

## 作者：I_am_kunzi (赞：11)

# P10693 题解

温馨提醒：本题解约一千字，请耐心看完。

### 题目思路

首先所有题解都会告诉你要连一条从 $ i \rightarrow a_i $ 的边，但为什么要这样连呢？下面我会手搓几组小数据，分析这种方法的思路。

先看样例，这对应着一种情况：如果所有的 $ a_i $ 都不相同，那么结果一定为 $ n$。我试图对这个结论推广为：答案为所有 $ a_i $ 中不同的个数。显然这个结论对于样例成立，但[提交记录](https://www.luogu.com.cn/record/167662958)告诉我这个结论是错误的。

于是我搓了另一组数据：

```
5
2 3 4 5 5
```

我将刚刚的结论带入，发现这与真正的答案并不相同。用刚刚的结论得到的结果为 $ 4$，但当你尝试让 $ 1 \sim 4 $ 号都坐在心仪的位置上时，$5 $ 号就没有地方坐了；如果让 $ 1 \sim 3 $ 号和 $ 5 $ 号坐在心仪的位置上时，由于 $ a_3 = 4$，所以 $ 4 $ 号就没有位置坐了。

这时我们就可以引出开头说的连边方式的原因了：我们假设让 $ i $ 号坐在心仪的位置上时，$a_i $ 这个位置自然不能坐其他的人，这时第 $ a_i (a_i \le n) $ 个人只能接着坐到自己的心仪位置，自然就是 $ a_i $ 向自己的心仪位置连边（当然保证 $ a_i \le n$）。

连边方式有了，答案怎么确定呢？这时研究一下我给出的数据就会发现：当 $ i = 5 $ 时，$a_i = 5$，此时 $ i \rightarrow a_i $ 的连边形成了一个环。也就是说，如果有环，那么环中的人都可以坐到自己的心仪位置上，而且不会影响到环外的人坐座位。

然而我们模拟样例连边就会发现，图中形成了两个部分：一个是 $ 1 \rightarrow 2 \rightarrow 6 $ 的链；另一个是 $ 3 \rightarrow 4 \rightarrow 5 \rightarrow 3 $ 的环。这时候出现了新的可能的连边情况：链，当然更准确的说是有向树（这种数据在本文章中并没有列出，但仍然可以构造）。对于这种情况，我们使用 DFS 求出最大深度，取这一条路径上的所有点，这些人可以坐到他们的心仪位置上。

但是还有最后的问题：上一段中的最大路径应该怎么求？这里先给出结论：本题的有向树中只会有一个点的编号 $ > n$，从这个点出发反向寻找即为最长路径。那么为什么只会有一个点编号 $ > n $ 呢？考虑反证法：设没有点的编号 $ > n$，即所有点编号都 $ \le n$。此时一定有一个点没有向其他点连过边，而这个点的编号又 $ \le n$，那么设这个点为 $ i$,一定可以连一条 $ i \rightarrow a_i $ 的边，如果此时 $ a_i \le n$，则可以继续通过刚刚的方式连边。最后只会有两种可能：第一，所有点的编号都 $ \le n$，而此时没有边可连，这形成了环；第二，找到了一个 $ a_i > n$，连边结束。这两种情况都与原假设不符，故证明成功。

所以，我们需要从 $ > n $ 的编号开始反向找最长路径（所以需要反向连边）；还需要判断图中所有的环（可以用拓扑排序，没有访问过的点即为环上的点），并将两部分答案相加，输出即可。

### 题目代码

注：代码略去缺省源部分，若希望看到缺省源，[点击这里](https://www.luogu.com.cn/paste/9xcy6boi)。


```cpp
int a[200005];
int ans;
int maxdep;
int n;
vector < int > v[200005]; // 反向图
vector < int > tppx[200005]; // 正向图，拓扑排序用
int in[200005];
bool flag[200005]; // 判一下有没有被 DFS 求路径，防止拓扑排序之后答案重复
void dfs(int now , int dep)
{
	if(now <= n)
	{
		flag[now] = 1; // 防止这个点被加入拓扑排序
		maxdep = max(maxdep , dep);
	}
	for(int i : v[now])
	{
		dfs(i , dep + 1);
	}
}
signed main()
{
	read(n);
	readarray(a , 1 , n);
	for(int i = 1 ; i <= n ; i++)
	{
		v[a[i]].push_back(i);
		tppx[i].push_back(a[i]);
		in[a[i]]++;
	}
	for(int i = n + 1 ; i <= n * 2 ; i++)
	{
		maxdep = 0;
		dfs(i , 0);
		// 路径上的第一个点 ~ 倒数第二个点都会整体向后平移一位
		// 所以实际上路径上如果有 x 个点，这一部分答案只有 x - 1
		// 所以初始深度设为 0 可以计算出正确答案
		// 设成 1 最后 maxdep - 1 其实也行
		ans += maxdep;
	}
	queue < int > q;
	for(int i = 1 ; i <= n ; i++)
	{
		if(!in[i] && !flag[i])
		{
			q.push(i);
		}
	}
	while(q.size())
	{
		int now = q.front();
		q.pop();
		flag[now] = 1;
		for(int i : tppx[now])
		{
			if(--in[i] == 0)
			{
				q.push(i);
			}
		}
	}
	for(int i = 1 ; i <= n ; i++)
	{
		ans += !flag[i];
		// 没进入拓扑排序就是环上的点
		// 因为一个环不可能单独拆出一个点入度为 0
	}
	printnl(ans);
	return 0;
}
```

---

## 作者：OoXiao_QioO (赞：4)

如果你经常做 Atcoder 和 Codeforces 的题会发现这题是个套路题。

用图论建模，将 $i$ 和 $a_i$ 连边。手玩一下样例，发现若编号 $\le n$，出度都为 $1$；编号 $>n$，出度都为 $0$（既然有 $2n$ 个座位，那么肯定坐不满，也就是说有些点既没有出边又要要求联通）。

所以建模后的图无非形成了两种结构：环和有向树。

分类讨论，对于环：答案为环上节点个数，因为环上所有的点可以选，但是环外的点无论如何都不能到自己心仪的位置。可以用拓扑排序求解，没有标记过的点也就是环上的点。


```cpp
int sub1()
{
	queue<int> q;
	int i;
	for(i=1;i<=n;i++)
		if(!f[i]&&!deg[i])
			q.push(i);
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		f[u] = 1;
		for(auto v:e[u])
			if(!--deg[v])
				q.push(v);
	}
	int res = 0;
	for(i=1;i<=n;i++)
		res += !f[i];
	return res;
}
```


对于有向树：找一条最长链，链上的所有点都可以到自己心仪的位置。求法可以用先建反图， DFS 跑一遍最大深度即可。


```cpp
int ma;//最长链长度。
void dfs(int u,int dep)
{
	if(u<=n)
		ma = max(ma,dep),f[u] = 1;
	for(auto v:b[u])//在反图上跑
		dfs(v,dep+1);
	return;
}
int sub2()
{
	int i;
	int res = 0;
	for(i=n+1;i<=n*2;i++)
	{
		ma = 0;
		dfs(i,0);
		res += ma;
	}
	return res;
}
```


两者相加即为答案。



```cpp
void solve()
{
	cin>>n;
	int i;
	for(i=1;i<=n;i++)
	{
		int u;
		cin>>u;
		deg[u]++;
		e[i].push_back(u);
		b[u].push_back(i);
	}
	//答案是环和有向树两种情况的和。
	//细节：先求有向树，得到标记数组 f，再求拓扑排序。
	ans = sub2();
	ans += sub1();
	cout<<ans<<endl;
	return;
}
```

---

## 作者：JuRuoOIer (赞：3)

# 题解 P10693 [SNCPC2024] 换座位

~~既然教练要求了，就来看看这题吧。~~

首先看到**第 $i$ 个嘉宾心仪的座位为第 $a_i$ 个座位**，立刻想到（没想到的建议立刻扇自己 $2^{63}-1$ 个大耳瓜子）建图，$i\rightarrow a_i$ 连边。接着顺水推舟，有了图，想到算连通块的贡献。因此我们需要连通块的形态。

先不要那么多座位，考虑只有 $n$ 个座位。猜想一下：可能是个环。因为每个点有且仅有一条出边，所以 $k$ 个点的连通块一共有 $k$ 条边，这并不足以说明连通块就是个环，但它一定是个基环树，而其中只有环上的点是能动的，所以贡献就是环长。

但这题比较特殊，我们注意到他一共给了 $2n$ 个座位，于是有些时候一个点不一定有出边。但是既然要连通， $k$ 个点就至少要 $(k-1)$ 条边，所以这样的点最多只能有一个，所形成的连通块就是一棵树，树上所有边都指向那个没有出边的点。然后就做完了。

---

## 作者：Night_sea_64 (赞：3)

建出一张有向图，$i$ 连向 $a_i$。

然后会出现若干连通块。如果一个连通块中包含一个编号 $>n$ 的点 $k$，那么只会有一个这样的点（因为如果还有的话，边数就等于点数 $-2$，就不是一个连通块了），也可以看出这是一棵树，每个点的出边方向都是 $k$ 的方向。以 $k$ 为根，这棵树的深度就是这个连通块的答案。

否则每个连通块是一个内向基环树。环的大小就是这个连通块的答案。

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int n,cnt,maxn,ans;
int in[200010];
bool flag[100010];
vector<int>vb[200010],v[200010];
void dfs(int x,int dep)
{
    if(x<=n)cnt++,maxn=max(maxn,dep),flag[x]=1;
    for(auto y:vb[x])dfs(y,dep+1);
}
void topsort()
{
    queue<int>q;
    for(int i=1;i<=n;i++)
        if(!flag[i]&&!in[i])q.push(i);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        flag[x]=1;
        for(auto y:v[x])
            if(!--in[y])q.push(y);
    }
    for(int i=1;i<=n;i++)
        if(!flag[i])ans++;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        v[i].push_back(x);
        vb[x].push_back(i);
        in[x]++;
    }
    for(int i=n+1;i<=2*n;i++)
    {
        cnt=maxn=0;
        dfs(i,0);
        ans+=maxn;
    }
    topsort();
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：CheZiHe929 (赞：2)

从 $i$ 向 $a_i$ 连边，建图。

不难发现整个图会分为若干个连通块，我们分别考虑连通块的形态及对答案的贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/lsnk1jb0.png)

- 连通块为树

树的情况就是上图样例的左半部分。

考虑什么情况一个连通块会是树。我们设当前连通块的点的数量为 $n'$。

不难发现，如果一个连通块中含有一个点 $x$ 满足 $x > n$，那么这个连通块就一定是树。因为根据题意，$x$ 不会有出边，而其他的 $n'-1$ 个点都会有一条引向它们心仪的作为的一条边，所以该连通块有 $n'$ 个点、$n'-1$ 条边，是一棵树。

注意，一个连通块中**至多**有一个点 $x$ 满足 $x>n$，若有多个点 $x$ 满足此条件，那么必有一个点 $i$ 作为根，且它有多条出边。但根据题意，我们得知每个人的心仪座位只有一个，所以不会出现出边不为 $1$ 的情况。

接下来考虑作为树时的连通块对答案的贡献。

我们令 $x$ 为根（$x$ 满足 $x>n$），建一个该连通块的反图。从 $x$ 的儿子考虑，最多只有一个 $x$ 的儿子可以坐到它心仪的位置。而其他儿子 $i$ 只能坐到位置 $i$ 上，因此以 $i$ 为根的子树中的所有点 $j$ 都只能坐在位置 $j$ 上。

推广可得答案为该树上一条根到叶子的链的长度，而我们要最大化答案，所以答案为树的深度 $-1$。

对于求法，我们枚举 $i$（$n < i \le 2\times n$），在反图上跑 `dfs`，求该以 $i$ 为根的树的深度。

- 连通块中包含环（即基环树）

注意它不仅仅只有是环的情况，也会存在基环树的情况。

若一个连通块不是树，那么它就一定是一个基环树。

考虑对答案的贡献。

答案只能是环上的节点的个数，并不是以环上一个点 $x$ 为根的子树的深度。因为如果要满足答案是以环上一个点 $x$ 为根的子树的深度时，$x$ 一定会被它的一个儿子所连，因此 $x$ 只能连向环上它指向的点，以此类推，会发现最后环上指向 $x$ 的点会没有位置坐，所以答案只能是环上的节点的个数。

求环的大小需要用到拓扑排序，最后入度 $\not= 0$ 的点就是环上的点。为了防止情况一（连通块为树）中的点的影响，需要用 `f` 数组来打标记。

完整代码如下：


```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define debug puts("#CheZiHe929")
#define Time std::cout<<1.0*clock()/CLOCKS_PER_SEC<<'s'<<endl;
#define Memory std::cout<<abs(&mst - &men)/1024.0/1024<<"MB"<<endl;
#define eps 1e-5

#define YES puts("YES");
#define Yes puts("Yes");
#define yes puts("yes");
#define NO puts("NO");
#define No puts("No");
#define no puts("no");

const int MAXN=2e5+5; 

inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
inline void print(int x){char st[105];int top=0;if(x==0)putchar('0');if(x<0)putchar('-');while(x){if(x>0)st[++top]=x%10+48;else st[++top]=-(x%10)+48;x/=10;}while(top)putchar(st[top--]);}
inline void println(int x){print(x);putchar('\n');}
inline void printsp(int x){print(x);putchar(' ');}
inline void put(int x,int i,int n){i==n?println(x):printsp(x);}

inline void IOS(){std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0);}
inline void Freopen(){freopen("test.in","r",stdin);freopen("test.out","w",stdout);}

bool mst;
int n,a[MAXN];
int ans; 

int in[MAXN];//入度，topo 排序需要 
std::vector<int> g1[MAXN];//原图 
std::vector<int> g2[MAXN];//反图，当连通块为树的时候需要 
void add(int u,int v){//连边建图 
	g1[u].push_back(v);
	g2[v].push_back(u);
	in[v]++;
}

bool f[MAXN];
int maxn=0;//最大深度 
void dfs(int x,int dep){
	if(x<=n){//反图中非根的节点 
		f[x]=1;
		maxn=std::max(maxn,dep);
	}
	for(int i=0;i<g2[x].size();i++)//遍历反图中点 x 的儿子 
		dfs(g2[x][i],dep+1);
}

int topo(){
	int cnt=0;
	std::queue<int> q;
	
	for(int i=1;i<=n;i++)
		if(!f[i]&&!in[i]){//每个以环上的点为根的子树的叶子（入度为 0）
			q.push(i); 
			f[i]=1; 
		}
		
	while(q.size()){
		int u=q.front();
		q.pop();
		
		for(int i=0;i<g1[u].size();i++){
			int v=g1[u][i];//一条 u->v 的边 
			in[v]--;
			if(!in[v]){
				q.push(v);
				f[v]=1; 
			}
		}
			
	}
	
	for(int i=1;i<=n;i++)
		if(!f[i])cnt++;//求环上点的个数 
	return cnt;
}
bool men;

signed main(){

	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		add(i,a[i]);
	}
	
	for(int i=n+1;i<=2*n;i++){//枚举所有 >n 的点，看是否有以其为根的树，并求对答案的贡献 
		maxn=0;
		dfs(i,0);
		ans+=maxn;
	}
	
	ans+=topo();//连通块为基环树对答案的贡献 
	println(ans);
	
	return 0;
}

```

**Thanks.**

---

## 作者：Dream_poetry (赞：2)

## 思路：
先将每个 $i$ 连向对应的 $a_i$，形成若干个连通块。

对于每个连通块，我们思考一下，不难想出它要么是一个有向树，最终指向一个点 $x$，且 $n < x \le 2n$；要么它是一个基环树，且是一个内向基环树，其中每个点都大于等于 $1$ 且小于等于 $n$。

对于一个有向树，我们建反边，从每个 $x$ 来查找最长链计入答案即可。

对于基环树，我们进行拓扑排序，判断有几个点没有出过队，它们一定在环上，计入答案即可。

## 代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
int a[500005];
vector<int> z[500005];
int in[500005];
int vis[500005];
int maxn;
vector<int> v[500005];

int ans;
void dfs(int x,int sd){
	vis[x]=1;
	if (x<=n){
		maxn=max(maxn,sd);
	}
	for (int i=0;i<v[x].size();i++){
		dfs(v[x][i],sd+1);
	}
}


void topsort(){
	queue<int> q;
	for (int i=1;i<=n;i++){
		if (!vis[i] && !in[i]){
			q.push(i); 
		}
	}
	while (q.size()){
		int x=q.front();
		q.pop();
		vis[x]=1;
		for (int i=0;i<z[x].size();i++){
			in[z[x][i]]--;
			if (!in[z[x][i]]){
				q.push(z[x][i]);
			}
		}
	}
	for (int i=1;i<=n;i++){
		if (!vis[i]){
			ans++;
		}
	}
}

signed main(){
    cin>>n;
    for (int i=1;i<=n;i++){
    	cin>>a[i];
		z[i].push_back(a[i]);
		v[a[i]].push_back(i);
		in[a[i]]++;
	}
	for (int i=n+1;i<=n*2;i++){
		maxn=0;
		dfs(i,0);
		ans+=maxn;
	}
	topsort();
	cout<<ans;
	
    return 0;
}

```

---

## 作者：Drest (赞：1)

# [P10693] [SNCPC2024] 换座位 题解


这道题考察建图能力。

因为嘉宾 $i$ 的座位只能是 $i$ 和 $a_i$，于是我们可以将 $1 \le i \le n$ 与 $a_i$ 连一条边，然后对这个图进行讨论。

这个图可能包括的内容如下：

1. 树：如果图中有一颗树，那么显然只能满足一条链上嘉宾的要求，所以我们选择最长的一条链。
2. 环：如果图中有一个环，那么环上所有嘉宾都移动一位，即可满足所有嘉宾的要求。
3. 基环树：如果图中有一个基环树，那么显然所有环上的嘉宾都可以像 $2$ 那样满足自己要求，但是环外的嘉宾都动不了。

对于树，我们可以使用 dfs 和拓扑序找到最长链；对于环和基环树，我们只需用 dfs 跑出环的长度即可。

## 题目代码

```cpp

#include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10;

int n, a[N], ans;

int nxt[N], fa[N];

int num[N];
bool vis[N];

void find_tr(int x) {
    if (nxt[x] == 0) { // 找到树的根节点
        ans += num[x];
        return;
    }
    num[nxt[x]] = max(num[nxt[x]], num[x] + 1);
    vis[x] = true;
    if (--fa[nxt[x]] == 0)
        find_tr(nxt[x]);
}

void find_ring(int x, int len) {
    if (vis[x]) { // 环结束
        ans += len;
        return;
    }
    vis[x] = true;
    find_ring(nxt[x], len + 1);
}

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        nxt[i] = a[i]; // i 向 a[i] 连边
        fa[a[i]]++;
    }
    // （反向）统计树
    for (int i = 1; i <= n; i++) {
        if (!vis[i] && fa[i] == 0) { // 找到叶子节点
            find_tr(i);
        }
    }
    // 统计环
    for (int i = 1; i <= n; i++) {
        if (!vis[i] && fa[i]) { // 找到环上一个点
            find_ring(i, 0);
        }
    }

    cout << ans;

}


```

---

## 作者：thallo (赞：1)

### [题面](https://www.luogu.com.cn/problem/P10693) ###

### 思路分析 ###

首先，我们建一个有向图，让 $i$ 连向 $a_i$。这样我们就能表示出 如果第 $a$ 个人坐在第 $b$ 个座位上，那么第 $b$ 个人就要坐在第 $c$ 个座位上 这样的关系。
因为 $i$ 连向 $a_i$，所以点 $1 \sim n$ 的出度为 $1$，点 $(n+1) \sim (n \times 2)$ 的出度为 $0$。
所以如果一个连通块中 $k$ 个点的编号都 $\le n$，那么这个连通块是一棵内向基环树，因为它 $k$ 个点都有出边，否则这个连通块是一棵内向树，因为它有一个点没有出边（如果再有一个，那么这个连通块就只有 $k - 2$ 条边，它就不连通了）。

接下来就是分类讨论。

对于一棵树，它对答案的贡献是这棵树以 $k(k\ge n+1)$ 为根的深度，下图是这棵树的答案。
![](https://cdn.luogu.com.cn/upload/image_hosting/39epd835.png)

对于一棵基环树，它对答案的贡献是它的环的长度。下图就是一棵基环树的答案。
![](https://cdn.luogu.com.cn/upload/image_hosting/x1w8hofi.png)

这里不能像树那样，选择这个基环树的生成树的深度作为答案，因为这样就会有人无处可坐。
![](https://cdn.luogu.com.cn/upload/image_hosting/eefm2n20.png)
### 代码 ###
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,in[200005],maxn,ans;
bool vis[200005];
vector<long long>zd[200005],z[200005];
queue<long long>q;
void ae(long long s,long long e)
{
	z[s].push_back(e);//用于拓补排序找环 
	zd[e].push_back(s);//用于求树的深度，建反图方便dfs 
}
void dfs(long long now,long long d)//dfs求树的深度
{
	maxn=max(maxn,d);
	vis[now]=1;
	for(int i=0;i<zd[now].size();i++)dfs(zd[now][i],d+1);
	//用的是反图 
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		ae(i,a);
		in[a]++;
	}
	for(int i=n+1;i<=n*2;i++)//因为编号>n+1的点没有出边，所以这些点所在的连通块都是树 
	{
		maxn=0;
		dfs(i,0);
		ans+=maxn;
	}
	//拓补排序把环筛出来 
	for(int i=1;i<=n;i++)if(!in[i])q.push(i);
	while(q.size())
	{
		long long u=q.front();
		q.pop();
		vis[u]=1;
		for(int i=0;i<z[u].size();i++)
		{
			long long v=z[u][i];
			in[v]--;
			if(!in[v])q.push(v);
		}
	}
	for(int i=1;i<=n;i++)if(!vis[i])ans++;
	cout<<ans;
	return 0;
}
```

---

## 作者：M1saka16I72 (赞：0)

## 前言

[更可爱的阅读体验](https://misaka16172.github.io/solution-p10693.html)

这个题真的是太困难了。

## 思路

考虑从每个人向他想坐的地方建图。

发现 $\leq n$ 的点出度均为 $1$，$>n$ 的点出度为 $0$，如果联通块里全是 $\leq n$ 的点那里面就有 $n$ 条边，否则就有 $n-1$ 条边（因为构成一个联通块至少需要 $n-1$ 条边），所以这一定是一个内向基环树 + 内向树森林。

然后我们考虑怎么选座位。分类讨论，对于树的情况答案为树上到根节点的最长链长度再 $-1$（根节点 $\geq n$ 所以根节点可以随便让人坐），而基环树的情况只能选环上的所有节点，不然就有人没地方坐。

实现上，树的情况可以对于每个 $\geq n$ 的点 dfs；基环树的情况直接拓扑排序，没有出队过的点一定在环上，求出一共有几个点没有入队即可。

## 代码

```cpp
constexpr int N = 2e5+5;

vector<int> tr[N];
set<int> ring;
int nxt[N],deg[N],dep[N],mx[N],n;

void dfs(int u,int f){
	dep[u] = dep[f]+1;
	mx[u] = dep[u];
	for(int v:tr[u]){
		if(v==f)	continue;
		dfs(v,u);
	}
	for(int v:tr[u]){
		if(v==f)	continue;
		mx[u] = max(mx[u],mx[v]);
	}
}

void solve(){
	read(n);
    for(int i=1;i<=n;i++){
    	read(nxt[i]);
    	deg[nxt[i]]++;
    	tr[nxt[i]].pb_(i);
    }
    queue<int> q;
    for(int i=1;i<=n*2;i++){
    	if(!deg[i])	q.push(i);
    	ring.insert(i);
    }
    while(!q.empty()){
    	int u = q.front();q.pop();
    	ring.erase(u);
    	deg[nxt[u]]--;
    	if(!deg[nxt[u]])	q.push(nxt[u]);
    }
    int ans = ring.size();
    for(int i=n+1;i<=n*2;i++){
    	dfs(i,0);
    	ans+=mx[i]-1;
    }
    cout<<ans;
}
```

---

## 作者：迟暮天复明 (赞：0)

显然 $i$ 往 $a_i$ 连边之后每个环都不会有出边。所以形成的结构只有可能是有向树或者一个环拖若干个子树的基环树。

对于前者，显然只能满足树上最长一条链的要求。

对于后者，环上所有点都可以走，但是环外的点显然都动不了了。

两者答案相加即为最终结果。

---


# [SNCPC2024] 消失的数字

## 题目描述

uuku 正在学习数位 DP！

但某一天，他发现 $1,2,\ldots,9$ 这九个数字中的 $x$ 消失了，也就是说所有包含 $x$ 这个数字的数都消失了。

这让他非常惊慌，因为这对统计数的个数有很大的影响。

现在，他希望你能帮助他求出这种情况下数 $n$ 在未消失的自然数中从小到大排在第几位。

## 说明/提示



对于样例的第一组数据，自然数列变为 $0,1,2,3,5,6,7,8,9$, 其中数 $9$ 是第 $9$ 个。

## 样例 #1

### 输入

```
5
9 4
99 7
12345678 9
9475632111234123 8
998244353114514 7
```

### 输出

```
9
81
6053445
1758041005111510
205404686678741
```

# 题解

## 作者：I4ever (赞：9)

# P10697 [SNCPC2024] 消失的数字
## 题目分析
- 统计 $1 \sim n$ 中所有不包含 *x* 的数字个数，任何一位都不可以有。数据范围给的很大，已经爆 *int* 了所以不考虑使用暴力求解，看到很多题解包括标签都是数位 *dp* ，本蒟蒻不会那么高深的算法，那么开始模拟找规律这道题与[P1590 失踪的7](https://www.luogu.com.cn/problem/P1590)可以说是一摸一样，是个双倍经验。

- 先手模找规律
```
1  2  3  4  5  6  8  9  10
11 12 13 14 15 16 18 19 20
21 22 23 24 25 26 28 29 30
31 32 33 34 35 36 38 39 40
41 42 43 44 45 46 48 49 50
51 52 53 54 55 56 58 59 60
61 62 63 64 65 66 68 69 80
81 82 83 84 85 86 88 89 80
91 92 93 94 95 96 98 99 100
```
这是 $1 \sim 100$ 的消失 $7$ 的表格，共有 $81$ 个数字。

而 $1 \sim 10$ 的有 $9$ 个数字。（自己算）

那么可以将 $100$ 分成 $10$ 个 $1 \sim 10$ ，因为其中有 $70 \sim 79$ 以及每一个 $1 \sim 10$ 中会有一个 $7$ 不符合条件，所以 $100 \rightarrow 9\times9=81$。

则可推出 $1000 \rightarrow 81\times9=729$。 

那么就可以手动计算将其存贮到数组中，打个比方，将 $abcdefg$ 变成 $a\times1000000 + b\times100000 + c\times10000 + d\times1000 + e\times100 + f\times10 + g\times1$，对于每一位数字单独进行计算，最后累加即可。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
template <typename T> void read(T &x) {
	int f = 1;
	x = 0;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) {
		if (c == '-') {
			f = -f;
		}
	}
	for (; isdigit(c); c = getchar()) {
		x = x * 10 + c - '0';
	}
	x *= f;
}
//预处理每个数位上所代表的数字个数
ll a[19] = {1, 9, 81, 729, 6561, 59049, 531441, 4782969, 43046721, 387420489, 3486784401, 31381059609, 282429536481, 2541865828329, 22876792454961, 205891132094649, 1853020188851841, 16677181699666569, 150094635296999121};
ll T, n, x, ans, dep;
int main() {
	read(T);
	while (T--) {
		ans = dep = 0;
		read(n);
		read(x);
		while (n) {//逐位计算
			int num = n % 10;
			n /= 10;
			if (num < x) {
				ans += num * a[dep];
			} else {
				ans += (num - 1) * a[dep];
			}
			dep++;
		}
		printf("%lld\n", ans + 1);
	}
	return 0;
}
```

---

## 作者：shuqiang (赞：9)

这题可以先暴力打标，看一下规律，以 $x=9$ 为例：
![](https://cdn.luogu.com.cn/upload/image_hosting/6xyp4rc6.png)
蓝色的就是没有消失的数字，观察一下，可以发现，这些数字组成的新的数列就是九进制数。

再来看一下 $x=8$：
![](https://cdn.luogu.com.cn/upload/image_hosting/4zcgl42p.png)
不难发现，把红色部分和绿色部分互换就是九进制数了，观察一下，其实把绿色部分中大于 $x$ 的数位减 $1$ 就是红色部分了，所以最后得出结论：
- 当 $x=9$ 时，把 $n$ 看作九进制数，转化成十进制数即可。
- 当 $x\ne9$ 时，先把 $n$ 中所有大于 $x$ 的数位减 $1$，然后重复上一步的操作就可以了。

最后不要忘了自然数含 $0$，所以最终答案还要加 $1$。

```cpp
#include<iostream>

using namespace std;

int t, x;
long long n, ans = 0, tmp = 1;

int main(){
	cin >> t;
	while(t--){
		cin >> n >> x;
		tmp = 1;
		while(tmp < n){
			if(n / tmp % 10 > x) n -= tmp;
			if(tmp == n) break;
			tmp *= 10;
		}//把 n 中所有大于 x 的数位减 1。 
		tmp = 1;
		while(n){
			ans += tmp * (n % 10);
			tmp *= 9, n /= 10;
		}//转化成十进制数。 
		cout << ans + 1 << endl;
		ans = 0;//多测记得清空。 
	}
	return 0;
}

```

---

## 作者：mlvx (赞：4)

题意就是求 $[0,n]$ 有多少数字不含数码 $x$。

那我们直接把含数码 $x$ 的数字个数求出来就好了。

先进行数位拆分，从低位到高位拆。

然后从高位向低位枚举即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int T,k,len,num[21];ll n,dp[21][2];
ll dfs(int x,int cx,int lm){//x 表示枚举到第几位，cx 表示数码是否出现，lm 表示是否受限制
	if(!x)return cx;
	if(!lm&&~dp[x][cx])return dp[x][cx];//记忆化
	int maxc=lm?num[x]:9;ll ret=0;
	for(int i=0;i<=maxc;i++)ret+=dfs(x-1,cx||i==k,lm&&i==maxc);//枚举数码
	return lm?ret:(dp[x][cx]=ret);
}int main(){
	cin>>T;
	while(T--){
		cin>>n>>k,memset(dp,-1,sizeof dp);ll m=n;
		for(len=0;m;m/=10)num[++len]=m%10;//拆数位
		cout<<n-dfs(len,0,1)+1<<'\n';
	}return 0;
}
```

---

## 作者：WeLikeStudying (赞：3)

有一个有趣的思路分享一下，不过应该很多人也想到了吧。

### [题意](https://www.luogu.com.cn/problem/P10697)
给一个数 $n$ 和 $1$ 到 $9$ 的一个数码 $x$，问不大于它且每一位数都不含有 $x$ 的自然数的个数。

### 分析
对于每一个不含有 $x$ 的数，把它的每一位数码 $a$ 进行如下替换操作，若 $x>a$ 替换为 $x-1$，否则不变。

比如 $a=3$ 时，$116515$ 应该被替换成 $114514$，$1919810$ 被替换为 $1818710$。

你发现，这样的数码在 $9$ 进制下恰好是连续的，即替换的数字加一就是答案。

很简单对吧，那我转换一下问题：给一个数 $n$ 和 $1$ 到 $9$ 的一个数码 $x$，问不大于它且至少有一位数**含有** $x$ 的自然数的个数，这个经典问题有多少人是用数位 DP 做的，但是其实稍微反着想一想就不需要思考了，这才是它对我们的启示。

```cpp
#include<bits/stdc++.h>
using ll=long long;
using namespace std;
int x;
ll n;
ll slv(ll m)
{
	return !m?0:slv(m/10)*9+m%10-(m%10>x);
}
void solve()
{
	cin>>n>>x;
	cout<<slv(n)+1<<'\n';
}
int main()
{
	int T;cin>>T;
	while(T--)solve();
	return 0;
} 
```

---

## 作者：mysterys (赞：1)

# 思路
1. $0 \leq n \leq 10^{18}$，所以考虑数位 dp。
1. 具体地说，将 $n$ 按位拆解，存入一个数组，然后枚举所有不包含 $x$ 的数。
1. **注意要进行剪枝和记忆化。**
# 注意事项
因为 $n$ 很大，所以进行记忆化的时候尽量将所有的可记忆化的量都记忆化。

**具体地说，将是否含有 $x$ 和数字是否为上界也作为记忆化数组的一维，最大可能减少时间复杂度，否则会  TLE 。**
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n;
ll x,len,T;
ll num[25], f[2][2][25][25];//f[flag][limit][pos][pre]
ll dfs(ll pos,ll pre,bool limit,bool flag){
	if(flag)//剪枝。
		return 0;
	if(pos==0){
		return !flag;
	}
	if(f[flag][limit][pos][pre]!=-1)
		return f[flag][limit][pos][pre];
	ll up=limit?num[pos]:9;
	ll ans=0;
	for(ll i=0;i<=up;i++){
		ans+=dfs(pos-1,i,limit&&i==num[pos],i==x||flag);
	}
	f[flag][limit][pos][pre]=ans;
	return ans;
}
ll solve(ll u){
	len = 0;
	memset(f, -1, sizeof(f));
	memset(num,0,sizeof(num));
	while(u>0){
		num[++len] = u % 10;
		u/= 10;
		if(num[len]==x) return 0;
	}
	ll s=0;
	for(ll i=0;i<=num[len];i++){
		s+=dfs(len-1,i,i==num[len],i==x);
	}
	return s;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cout.tie(nullptr);
	cin>>T;
	while(T--){
		cin>>n>>x;
		if(n==0)cout<<"1\n";//要特判。
		else cout<<solve(n)<<'\n';
	}
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：1)

我们可以使用数位 dp 解决这道题。

设 $dp_{i, j, k}$ 为当前处理到第 $i$ 位，且在当前位置是否受限于原数的情况下，当前数中不包含 $x$ 的数字个数为 $k$ 的数的排名，我们可以得到以下状态转移方程（$n_i$ 表示从左往右数第 $i$ 位上的数）：

$$
dp_{i, j, k} = \sum_{0 \le l \le n_i，l \ne x} dp_{i + 1, j \wedge \lnot[l\oplus n_i], k + 1}
$$

目标：$dp_{0, 1, 0}$。

使用记忆化搜索即可求出答案，每次询问时间复杂度为 $O(\log ^ 2 n)$。

参考代码如下：

```cpp
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
#define ll long long
#define writes(x) write(x), putchar(' ')
#define writeln(x) write(x), putchar('\n');
static char buf[100000], * pa(buf), * pb(buf);
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pb) ? EOF : *pa++
using namespace std;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
template <typename T> void read(T& x) {
    T t = 0, sgn = 1;
    char ch = gc;
    while (!isdigit(ch)) {
        if (ch == '-') sgn = -sgn;
        ch = gc;
    }
    while (isdigit(ch)) {
        t = (t << 3) + (t << 1) + (ch ^ 48);
        ch = gc;
    }
    x = sgn * t;
}
template <typename T, typename ...Args> void read(T& tmp, Args &...tmps) {
    read(tmp); read(tmps...);
}
template <typename T> void write(T x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
template <typename T, typename ...Args> void write(T& tmp, Args &...tmps) {
    writes(tmp);
    writes(tmps...);
}
template <typename T> T rand(T l, T r) {
    return rnd() % (r - l + 1) + l;
}
#define int long long
ll dp[21][3][21], x;
string str;
ll dfs(ll pos, bool flag, ll cnt) {
    if (pos == (int)str.size()) return 1;
    if (~dp[pos][flag][cnt]) return dp[pos][flag][cnt];
    ll ans = 0;
    int r = flag ? str[pos] - '0' : 9;
    for (int d = 0; d <= r; ++d) {
        if (d != x) {
            ans += dfs(pos + 1, flag && (d == r), cnt + 1);
        }
    }
    return dp[pos][flag][cnt] = ans;
}
signed main() {
    int t;
    read(t);
    while (t--) {
        ll n;
        read(n, x);
        str = to_string(n);
        memset(dp, -1, sizeof dp);
        writeln(dfs(0, 1, 0));
    }
}
```

---

## 作者：__Octhyccc__ (赞：0)

删掉一个数字其实就是相当于把 $10$ 进制改为 $9$ 进制。

令被删去的数为 $x$，对于小于 $x$ 的数。他们不变。大于 $x$ 的，因为 $x$ 已经被删除。所以要减去 $1$。接下来将这个数转化为 $10$ 进制就好了。

注意：$0$ 是自然数，最后的结果要加 $1$。还有，用 `pow(a,b)` 会 WA。换成快速幂即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string n;char x;
ll ans;
ll Power(ll a, ll b){
	ll ans2=1,base=a;
	while(b>0){
		if(b&1)ans2*=base;
        base*=base;
		b>>=1;
	}
	return ans2;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		cin>>n>>x;
		int len=n.length();
		for(int i=0;i<len;i++){
			ans+=(n[i]>x?n[i]-'1':n[i]-'0')*1ll*(Power(9,len-1-i));
		}
		printf("%lld\n",ans+1);
		ans=0;
	}
	return 0;
}
```

---

## 作者：HHC883 (赞：0)

# 题目分析
当一个数字消失后，计数系统就只剩下 $9$ 个数字，也即逢九进一。这不就是九进制吗？所以，只要利用九进制转十进制的方法即可得到答案。（所以，这题跟数位 DP 完全无关，题目第一句话是用来迷惑你的。）
# 参考代码
```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
int t,x,len,ans;
char n[20];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>x;
		len=strlen(n);
		ans=0;
		for(int i=0;i<len;i++){
			if(n[i]-'0'>x) n[i]--;
			ans=ans*9+n[i]-'0';
		}
		ans++;
		cout<<ans<<endl;
	}
	return 0;
}

```

---

## 作者：mango2011 (赞：0)

这题居然有绿？其实大概是橙的难度，但是如果从数位 dp 的角度去考虑就是绿题。

我们从进制的角度去考虑，怎么考虑呢？设删除的数字为 $x$，那么对于数字 $y(y<x)$，它这一位是不受影响的（不讨论前后）；否则，小于它的数字就少了 $1$ 个。这样我们可以得到一个新的数，由于每一位都恰好有 $9$ 种取值，于是可以将其看作一个九进制数。把这个数按照十进制转化出来，再加 $1$（注意 $0$ 的贡献）就可以得到答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
	ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);
	int q;
	cin>>q;
	while(q--){
		string s;
		int x,now=1,ans=0;
		cin>>s>>x;
		int n=s.size();
		s='*'+s;
		for(int i=1;i<=n;i++){
			if(s[i]-'0'>=x){
				int t=s[i]-'0';
				t--;
				s[i]=char(t+'0');
			}
		}
		for(int i=n;i>=1;i--){
			ans+=(s[i]-'0')*now;
			now*=9;
		}
		cout<<ans+1<<'\n';
	}
	return 0;
}
```

---


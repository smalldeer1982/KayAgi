# [CEOI 2024] 玩具谜题

## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T1「[Toy](https://ceoi2024.fi.muni.cz/page/tasks/statements/toy.pdf)」**

CEOI 2024 的命题人 Ben 从科学委员会收到了一份礼物——一个玩具。这个玩具是个谜题，可以想象成一个 $H$ 行 $W$ 列的网格，上面放着一个金属物体。这个金属物体由两部分组成：一个横向的 $1$ 行 $K$ 列的部分和一个纵向的 $L$ 行 $1$ 列的部分，这两部分松散地连接在一起。它们都不能旋转，但可以在网格内水平或垂直滑动，只要它们始终重叠在一个方格上。

网格里还有一些障碍物。金属物体的任何部分都不能穿过障碍物，更糟糕的是，它们也不能（即使部分）移出网格。Ben 的任务是将金属物体从指定起始位置移动到（可能不同的）目标位置，使得两部分重叠在指定的目标方格上。

然而，Ben 玩这个玩具已经有一段时间了，还没有解开谜题。事实上，他开始怀疑组织者在捉弄他，给了他一个无解的谜题。因此，他向你求助，想知道这个谜题是否有解。

## 说明/提示

**样例解释 1**

初始状态如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/anp1jutg.png)

我们可以先将纵向部分向下移动一格，然后尽可能地交替移动横向和纵向部分，直到无法继续。接着，我们可以将纵向部分向上并向右移动，到达目标方格，最后将横向部分向上移动，也到达目标方格。

**样例解释 2**

无法移动纵向部分而不碰到障碍物，因此永远无法到达目标方格。

对于所有输入数据，满足：

- $2 \leq W, H \leq 1\,500$
- $2 \leq K \leq W, 2 \leq L \leq H$
- $0 \leq x_h \leq W - K, 0 \leq y_h \leq H - 1$
- $0 \leq x_v \leq W - 1, 0 \leq y_v \leq H - L$

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $W, H \le 50$ | $14$  |
|  $2$  | $W, H \le 90$| $21$ |
|  $3$  | $W, H \le 300, K, L \le 10$ | $9$ |
|  $4$  | $W, H \le 360$ | $29$ |
|  $5$  | 无附加限制| $27$ |


## 样例 #1

### 输入

```
4 3 2 2
0 1 0 0
.X.*
....
...X```

### 输出

```
YES```

## 样例 #2

### 输入

```
2 3 2 3
0 1 0 0
.X
.*
.X```

### 输出

```
NO```

# 题解

## 作者：佬头 (赞：8)

## Description
一个 $H$ 行 $W$ 列的网格，其内部有一个由两部分组成的金属物体：一个 $1$ 行 $K$ 列的横部和一个 $L$ 行 $1$ 列的纵部。若称无障碍物的方格为**空格**，则这两部分仅可以在空格上水平或垂直滑动，并始终重叠在一个空格上。

问是否能将金属物体的重叠部分移动到指定的目标空格上。

## Solution
如果金属物体的重叠部分一定（若存在），其横部和纵部可以任意滑动，则不存在两种可行的放置方式且相互之间不能通过滑动转化。
- 因此可以用**重叠部分的方格**来表示金属物体的位置。

至于金属物体的移动，给朕上图！
![](https://cdn.luogu.com.cn/upload/image_hosting/cu7uq5ii.png)
1. 金属物体若要经过左侧地形，则纵部必须满足 $2\le L\le3$；
2. 金属物体若要经过右侧地形，则横部必须满足 $2\le K\le3$。

那么设金属物体位于空格 $X$，包含 $X$ 的一列连续空格的最大集合为 $A$，包含 $X$ 的一行连续空格的最大集合为 $B$（$X$ 一定时，$A,B$ 一定），
- 金属物体若要左（右）移，设 $X$ 左（右）边的空格为 $Y$，包含 $Y$ 的一列连续空格的最大集合为 $C$，则应满足 $\left|A\cap C\right|\ge L$；
- 金属物体若要上（下）移，设 $X$ 上（下）边的空格为 $Z$，包含 $Z$ 的一行连续空格的最大集合为 $D$，则应满足 $\left|B\cap D\right|\ge K$；

如果在 dfs 的同时求 $A\cap C,B\cap D$，**Subtask #5** 会[有十几个超时](https://www.luogu.com.cn/record/168726896)。啊！那么显然就是没看数据范围，应当先用**前缀和**预处理出每个 $X$ 的 $\left|A\right|,\left|B\right|$，然后从初始位置 dfs [就行了](https://www.luogu.com.cn/record/168730186)。

代码里换成了队列实现的 bfs，常数稍微小点，时间复杂度 $\mathcal O(HW)$。

## Code
```cpp
#include <iostream>
#include <queue>
#define fi first
#define se second
using namespace std;
const int N = 1503;
int w, h, k, l, dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0};
int lft[N][N], rt[N][N], top[N][N], bot[N][N];
pair <int, int> x;
queue <pair <int, int>> q;
char mmp[N][N];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
bool bfs(){
	while(!q.empty()){
		x = q.front();
		q.pop();
		if(mmp[x.fi][x.se] == '*') return 1;
		if(mmp[x.fi][x.se] == '+') continue;
		mmp[x.fi][x.se] = '+';
		for(int i = 0; i <= 3; ++ i)
			if(mmp[x.fi + dx[i]][x.se + dy[i]] == '.' || mmp[x.fi + dx[i]][x.se + dy[i]] == '*')
				if(dx[i]){
					if(min(rt[x.fi][x.se], rt[x.fi + dx[i]][x.se]) + min(lft[x.fi][x.se], lft[x.fi + dx[i]][x.se]) > k)
						q.push(make_pair(x.fi + dx[i], x.se));
				}
				else if(min(bot[x.fi][x.se], bot[x.fi][x.se + dy[i]]) + min(top[x.fi][x.se], top[x.fi][x.se + dy[i]]) > l)
					q.push(make_pair(x.fi, x.se + dy[i]));
	}
	return 0;
}
int main(){
	w = read(), h = read(), k = read(), l = read();
	read(), x.fi = read() + 1, x.se = read() + 1, read(); //交点坐标
	for(int i = 1; i <= h; ++ i) scanf("%s", mmp[i] + 1);
	for(int i = 1; i <= h; ++ i)
		for(int j = 1; j <= w; ++ j)
			if(mmp[i][j] != 'X')
				lft[i][j] = lft[i][j - 1] + 1,
				top[i][j] = top[i - 1][j] + 1;
	for(int i = h; i >= 1; i --)
		for(int j = w; j >= 1; j --)
			if(mmp[i][j] != 'X')
				rt[i][j] = rt[i][j + 1] + 1,
				bot[i][j] = bot[i + 1][j] + 1;
	q.push(x);
	fputs(bfs()? "YES": "NO", stdout);
	return 0;
}
```

---

## 作者：xuyunao (赞：2)

# P10804 [CEOI 2024] 玩具谜题 题解

[原题](https://www.luogu.com.cn/problem/P10804)

## 做法

在下文中，我们将**横着的块**称为横块，**竖着的块**称为竖块，将横块与竖块重叠的位置称为**交点**。

题目要求我们判断能否到达终点，我们考虑横竖块之间的交点是怎样移动的。也就是说，我们需要考虑横块和竖块的移动对交点位置移动的影响。

不难发现，横块横向左右移动不会对交点的位置产生影响，同理，竖块纵向上下移动也不会产生影响。因此我们在移动交点位置的时候，只需要判断是横块纵向移动了，还是竖块横向移动了。

注意到 $W,H \le 1500$ 的矩阵大小，在这个范围矩阵中我们可以使用广度优先搜索，在搜索过程中统计可达性。

具体的，我们首先找到交点的位置，随后枚举交点移动的四个方向。由前面的推断可知，交点横向移动是竖块移动引起的，纵向移动是横块引起的。

所以我们在搜索过程中，对每个方向判断相应块是否合法。例如向右移动时，我们就应该判断右边列障碍物能否放下竖块。

由于 $H,W$ 同阶，这里我们统一使用 $n$ 来表示。

暴力判断一次的复杂度为 $O(n)$，因此总时间复杂度为 $O(n^3)$，并不能通过。我们需要考虑如何快速判断移动是否合法，观察这个过程，判断的方式可以概括为：判断横向连续空间 $X$ 是否满足 $K \le X$，以及纵向连续空间 $Y$ 是否满足 $L \le Y$，也就是我们需要快速求出一段连续区间中空地的数量。

不难想到使用前缀和以及后缀和维护出每个位置向各个方向的连续空地长度，这样就可以在 $O(1)$ 的时间复杂度内快速判断是否能够移动，然后进行 BFS 维护可达性，这样就做完了。

## 贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1510;
int w,h,k,l;
int pre[maxn][maxn],lst[maxn][maxn],top[maxn][maxn],dow[maxn][maxn];
#define pii pair<int,int>
#define fi first
#define se second
pii xx;
int dx[4] = {0, 1, 0, -1};
int dy[4] = {-1, 0, 1, 0};
char mmp[maxn][maxn];
bool vis[maxn][maxn];
bool bfs(pii s)
{
    queue<pii> q;
    q.push(s);
	while(!q.empty())
    {
		auto nx = q.front();
		q.pop();
        int x = nx.fi;
        int y = nx.se;
		if(mmp[x][y] == '*') return true;
		if(vis[x][y]) continue;
		vis[x][y] = 1;
		for(int i = 0;i < 4;i++)
        {
            int xx = x + dx[i];
            int yy = y + dy[i];
            if(mmp[xx][yy] == '.' || mmp[xx][yy] == '*')
            {
                if(dx[i])
                {
					if(min(lst[x][y],lst[xx][y]) + min(pre[x][y],pre[xx][y]) > k) q.push({xx,y});
				}
				else if(min(dow[x][y],dow[x][yy]) + min(top[x][y], top[x][yy]) > l) q.push({x,yy});
            }
        }
    }
				
	return 0;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t;
	cin >> w >> h >> k >> l;
    cin >> t >> xx.fi >> xx.se >> t;
    xx.fi++;
    xx.se++;
	for(int i = 1;i <= h;i++)
        for(int j = 1;j <= w;j++)
            cin >> mmp[i][j];
	for(int i = 1;i <= h;i++)
		for(int j = 1;j <= w;j++)
			if(mmp[i][j] != 'X')
			{
                pre[i][j] = pre[i][j - 1] + 1,
				top[i][j] = top[i - 1][j] + 1;
            }
	for(int i = h;i >= 1;i--)
		for(int j = w;j >= 1;j--)
			if(mmp[i][j] != 'X')
			{
                lst[i][j] = lst[i][j + 1] + 1,
				dow[i][j] = dow[i + 1][j] + 1;
            }
	if(bfs(xx)) cout << "YES";
    else cout << "NO";
	return 0;
}
```

---

## 作者：dream10 (赞：2)

## Solution

非常妙的题，我没有做出来，评黄应当是过低了，毕竟 D2T1 至少不应该和 D1T1 难度差这么多吧。

这道题可以使用BFS求解，把状态设为点，转移设为边，看初始状态能否到达最终状态。

这道题本来可以朴素进行状态表示，分别用坐标表示两个金属块的上端点和左端点，每次转移枚举上下左右，复杂度 $O(H^2W^2)$

然而我们敏锐地发现有交点这回事没用上，所以我们只需要记录一个块相对于另一个块的偏移量就好了，复杂度 $O(HWKL)$

然后我们**注意到**横块左右动，竖块上下动，交点不变，而且可以到达所有合法的状态，所以我们只记录交点，复杂度 $O(HW(K+L))$

对于交点的移动，我们看看原题解

Let us consider
moving the intersection from `A` to `B`:

```
...X<-A--->X.
X<----B->X...
```

只需要预处理，就可以做到 $O(WH)$

```
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T &a){
    #define gc getchar()
    char c;a=0;int f=1;
    while(!isdigit(c=gc))if(c=='-')f=-1;
    do a=a*10+c-'0';
    while(isdigit(c=gc));
    a*=f;
}
template<typename T>
void write(T a){
    if(a<0)putchar('-'),a=-a;
    if(a>=10)write(a/10);
    putchar('0'+a%10);
}
template<typename T>
void chmin(T &x,T y){if(x>y)x=y;}
template<typename T>
void chmax(T &x,T y){if(x<y)x=y;}
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef pair<int,int> PII;
typedef pair<ll,int> PLI;
typedef __int128 lll;
mt19937 eg(chrono::system_clock::now().time_since_epoch().count());
namespace GENSOKYO{
int w,h,K,L;
int xh,yh,xv,yv,X,Y;
char grid[1510][1510];
int l[1510][1510],r[1510][1510];
int u[1510][1510],d[1510][1510];
queue<pair<int,int>> q;
bool v[1510][1510];
int main(){
    read(w),read(h),read(K),read(L);
    read(xh),read(yh),read(xv),read(yv);
    xh++,yh++;xv++;yv++;
    X=Y=-1;
    for(int i=1;i<=h;++i){
        scanf("%s",grid[i]+1);
        for(int j=1;j<=w;++j){
            if(grid[i][j]=='*'){
                assert(X==-1&&Y==-1);
                X=i,Y=j;
                grid[i][j]='.';
            }
        }
    }
    for(int i=1;i<=h;++i){
        l[i][0]=0;
        for(int j=1;j<=w;++j)l[i][j]=grid[i][j]=='X'?j:l[i][j-1];
        r[i][w+1]=w+1;
        for(int j=w;j>=1;--j)r[i][j]=grid[i][j]=='X'?j:r[i][j+1];
    }
    for(int j=1;j<=w;++j){
        u[0][j]=0;
        for(int i=1;i<=h;++i)u[i][j]=grid[i][j]=='X'?i:u[i-1][j];
        d[h+1][j]=h+1;
        for(int i=h;i>=1;--i)d[i][j]=grid[i][j]=='X'?i:d[i+1][j];
    }
    int sx=yh,sy=xv;
    q.emplace(sx,sy);
    v[sx][sy]=1;
    while(!q.empty()){
        int x=q.front().first;
        int y=q.front().second;
        q.pop();
        if(x>1&&grid[x-1][y]!='X'&&!v[x-1][y]){
            if(-max(l[x][y],l[x-1][y])+min(r[x][y],r[x-1][y])-1>=K){
                v[x-1][y]=1;
                q.emplace(x-1,y);
            }
        }
        if(x<h&&grid[x+1][y]!='X'&&!v[x+1][y]){
            if(-max(l[x][y],l[x+1][y])+min(r[x][y],r[x+1][y])-1>=K){
                v[x+1][y]=1;
                q.emplace(x+1,y);
            }
        }
        if(y>1&&grid[x][y-1]!='X'&&!v[x][y-1]){
            if(-max(u[x][y],u[x][y-1])+min(d[x][y],d[x][y-1])-1>=L){
                v[x][y-1]=1;
                q.emplace(x,y-1);
            }
        }
        if(y<w&&grid[x][y+1]!='X'&&!v[x][y+1]){
            if(-max(u[x][y],u[x][y+1])+min(d[x][y],d[x][y+1])-1>=L){
                v[x][y+1]=1;
                q.emplace(x,y+1);
            }
        }
    }
    puts(v[X][Y]?"YES":"NO");
    return 0;
}
}
signed main(){
    return GENSOKYO::main();
}
```

---

## 作者：BlackHoles (赞：1)

### 朴素想法

我们考虑如何确定金属物体的位置：需要横向部分最左上角方格坐标与纵向部分最左上角方格坐标。

于是我们记录一个四元组 $(x_0, y_0, x_1, y_1)$ 来表示金属物体的位置状态。对于每一个状态，枚举横向部分或纵向部分的移动来得到下一个状态，记得判断状态的合法性。我们将状态存在一个队列中，使用 BFS 求解问题即可。

时间复杂度为 $O(H^2W^2)$。

### 正解

我们注意到题目要求两个部分一直存在一个公共点。于是我们考虑仅记录公共点位置作为状态进行转移。

然而，假若公共点确定，两部分的位置却无法确定。但是很容易发现，对于一个公共点，横向部分的所有状态与纵向部分的所有状态**相互独立**，且所有可能的状态之间都能够**相互转化**。于是我们以**公共点位置**来区分所有状态，相同公共点的**状态本质上相同**。

我们记录 $(x, y)$ 表示公共点状态，考虑如何转移。  
我们以将公共点向上移动为例，转移到 $(x-1, y)$。对于这种转移，我们仅仅需要将横向部分向上移动并保证横向部分覆盖到该点即可。

读者可以自行模拟一下加深理解。我们发现对于公共点 $(x,y)$，横向部分的所有状态能通过左右滑动得到，$(x-1, y)$ 同理。

于是我们发现，若横向部分在两公共点的两个横向滑动区域交集大小至少为 $K$ 时，这种转移是合法的。纵向部分的转移同理。

我们对于任意点记录左方、右方、上方、下方的最极限位置（无障碍物）。在 BFS 时判断即可（详情见实现方式）。

时间复杂度为 $O(HW)$，空间复杂度为 $O(HW)$，可以通过本题。

### 实现方式

以我的代码为例，初始公共点记为 $(sx, sy)$，存图的二维数组记为 $G$。

极限位置的记录需要用到两层结构体（精简为一层也可行）。

```cpp
struct Range { // 区间
	int l, r;
};
struct Node { // 每个点的横向移动区间与纵向移动区间
	Range rx, ry;
};
Node f[N][N];
```

$f$ 数组的预处理需要用到递推思想。

对于 BFS 函数，我们定义一个方向数组：

```cpp
const int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
```

能方便的使用循环枚举下一个公共点的位置。

这个函数用来判断该点是否合法（我的存储下表是从 $1$ 开始的）。


```cpp
bool check(int x, int y) {
	return (x >= 1 && x <= n && y >= 1 && y <= m && G[x][y] != 'X' && !vis[x][y]);
}
```

下面的函数用来判断两个横向区间是否能相互转移。（纵向区间同理）


```cpp
bool checkx(int x, int y, int dx, int dy) { // 两个公共点
	int ls = f[x][y].rx.l, rs = f[x][y].rx.r, lt = f[dx][dy].rx.l, rt = f[dx][dy].rx.r; // 两个区间的左端点和右端点
	return (min(rt, rs) - max(lt, ls) + 1 >= K);
}
```

### 代码

**注意：** 以下的注释是本人编码时书写方便自身理解的，详细注释请观看上方实现方式。

```cpp
#include <bits/stdc++.h>
#define mk make_pair
using namespace std;
typedef pair <int, int> pii;
const int N = 1505;
const int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
int n, m, K, L;
int sx, sy, tx, ty;
char G[N][N];
struct Range {
	int l, r;
};
struct Node {
	Range rx, ry;
};
Node f[N][N]; // f[i][j] 表示 (i, j) 这个点左右上下的宽度高度
bool vis[N][N];
bool check(int x, int y) {
	return (x >= 1 && x <= n && y >= 1 && y <= m && G[x][y] != 'X' && !vis[x][y]);
}
bool checkx(int x, int y, int dx, int dy) {
	int ls = f[x][y].rx.l, rs = f[x][y].rx.r, lt = f[dx][dy].rx.l, rt = f[dx][dy].rx.r;
	return (min(rt, rs) - max(lt, ls) + 1 >= K);
}
bool checky(int x, int y, int dx, int dy) {
	int ls = f[x][y].ry.l, rs = f[x][y].ry.r, lt = f[dx][dy].ry.l, rt = f[dx][dy].ry.r;
	return (min(rs, rt) - max(lt, ls) + 1 >= L);
}
bool Bfs(void) {
	queue <pii> q;
	q.push(mk(sx, sy));
	vis[sx][sy] = true;
	while (!q.empty()) {
		pii tmp = q.front();
		q.pop();
		int x = tmp.first, y = tmp.second;
		if (x == tx && y == ty)
			return true;
		for (int i = 0; i < 4; ++i) {
			int dx = x + dir[i][0], dy = y + dir[i][1];
			if (!check(dx, dy))
				continue;
			if (dy == y && checkx(x, y, dx, dy)) {
				q.push(mk(dx, dy));
				vis[dx][dy] = true;
			}
			else if (dx == x && checky(x, y, dx, dy)) {
				q.push(mk(dx, dy));
				vis[dx][dy] = true;
			}
		}
	}
	return false;
}
int main(void) {
	cin.tie(0), cout.tie(0);
	// 输入
	cin >> m >> n >> K >> L;
	int tmp = 0;
	cin >> tmp >> sx >> sy >> tmp;
	++sx, ++sy;
	for (int i = 0; i <= n + 1; ++i) {
		for (int j = 0; j <= m + 1; ++j) {
			if (i >= 1 && i <= n && j >= 1 && j <= m)
				cin >> G[i][j];
			else
				G[i][j] = 'X'; // 周围围上一圈障碍物 
			if (G[i][j] == '*')
				tx = i, ty = j;
		}
	}
	// 预处理 f 数组
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j)
			if (G[i][j] != 'X')
				f[i][j].rx.l = (G[i][j-1] == 'X' ? j : f[i][j-1].rx.l);
		for (int j = m; j >= 1; --j)
			if (G[i][j] != 'X')
				f[i][j].rx.r = (G[i][j+1] == 'X' ? j : f[i][j+1].rx.r);
	}
	for (int j = 1; j <= m; ++j) {
		for (int i = 1; i <= n; ++i)
			if (G[i][j] != 'X')
				f[i][j].ry.l = (G[i-1][j] == 'X' ? i : f[i-1][j].ry.l);
		for (int i = n; i >= 1; --i)
			if (G[i][j] != 'X')
				f[i][j].ry.r = (G[i+1][j] == 'X' ? i : f[i+1][j].ry.r);
	}
	// Bfs（在遍历中判断方向可行性） 
	if (Bfs())
		cout << "YES";
	else
		cout << "NO";
	return 0;
}
```

---

## 作者：naroto2022 (赞：0)

# P10804 题解

[博客园查看更佳](https://www.cnblogs.com/naroto2022/p/19045689)

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P10804)

### 思路

考虑爆搜，广搜横纵向部分的横纵坐标，时间复杂度 $n^3$，原因是纵向部分左上角的纵坐标和横向部分左上角的纵坐标相同。

但是 $n^3$ 会超时，于是我们考虑优化，发现我们其实只要搜交点的横纵坐标就好了，但与之而来的，就是要 $O(1)$ 判断交点坐标是否能够 $(x,y)$ 移到 $(x\pm1,y)$ 或者 $(x,y\pm1)$，这不难，我们只要 $n^2$ 预处理出每个点向上，下，左，右最多能有多少个 `.` 或 `*`。（写的时候注意查看自己写的数组是否包括当前点本身。）

本质上，从 $(x,y)$ 到 $(x\pm1,y)$ 和从 $(x,y)$ 到 $(x,y\pm1)$ 是相同的，所以我们就只考虑 $(x,y)$ 到 $(x\pm1,y)$ 该如何判断。

而移动方式无非就是让横向部分左右移，直到能直接移到下（上）一行上，所以我们只要判断 $x$ 和 $x\pm1$ 两行是否可以移动横向部分的就可以了。

`min(l[x][y],l[xx][y])+min(r[x][y],r[xx][y])>K`

从 $(x,y)$ 到 $(x,y\pm1)$ 的方式以此类推，判断 $y$ 和 $y\pm1$ 两列是否可以移动纵向部分的就可以了。

`min(u[x][y],u[x][yy])+min(d[x][y],d[x][yy])>L`

于是我们就做完了。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
// #pragma GCC optimize(2)
// #pragma GCC optimize(3)
// #define gc getchar
#define gc()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define FILE(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define FIN(s) freopen(s".in","r",stdin);
#define FOUT(s) freopen(s".out","w",stdout);
#define ll long long
#define pll pair<ll,ll>
#define re register int
#define rl register ll
#define il inline
#define yes putchar('Y'),putchar('E'),putchar('S'),putchar('\n')
#define no putchar('N'),putchar('O'),putchar('\n')
using namespace std;
const int MN=1.5e3+5;
ll n,m,K,L,xh,yh,xv,yv,l[MN][MN],r[MN][MN],u[MN][MN],d[MN][MN],dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
bool vis[MN][MN];
char buf[1<<23],*p1=buf,*p2=buf,mp[MN][MN];
queue<pll> q;
il void write(rl n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
il ll read(){ll x=0,f=1;char ch=gc();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=gc();}return x*f;}
il char getc(){char ch=gc();while(ch!='.'&&ch!='*'&&ch!='X')ch=gc();return ch;}
int main(){
    // ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    m=read();n=read();K=read();L=read();yh=read()+1;xh=read()+1;yv=read()+1;xv=read()+1;
    for(re i=1; i<=n; ++i) for(re j=1; j<=m; ++j) mp[i][j]=getc();
    for(re i=1; i<=n; ++i) for(re j=1; j<=m; ++j) if(mp[i][j]!='X') l[i][j]=l[i][j-1]+1,u[i][j]=u[i-1][j]+1;
    for(re i=n; i; --i) for(re j=m; j; --j) if(mp[i][j]!='X') r[i][j]=r[i][j+1]+1,d[i][j]=d[i+1][j]+1;
    q.push({xh,yv});while(!q.empty()){
        ll x=q.front().first,y=q.front().second;q.pop();
        if(mp[x][y]=='*'){yes;return 0;}
        if(vis[x][y]) continue;vis[x][y]=true;
        for(re i=0; i<4; ++i){
            ll xx=x+dx[i],yy=y+dy[i];
            if(mp[xx][yy]=='X') continue;
            if(dx[i]&&min(l[x][y],l[xx][y])+min(r[x][y],r[xx][y])>K) q.push({xx,y});
            if(dy[i]&&min(u[x][y],u[x][yy])+min(d[x][y],d[x][yy])>L) q.push({x,yy});
        }
    }no;
    return 0;
}//250818
```

---


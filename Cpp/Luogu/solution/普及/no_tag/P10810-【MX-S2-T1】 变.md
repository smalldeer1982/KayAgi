# 【MX-S2-T1】 变

## 题目背景

原题链接：<https://oier.team/problems/S2A>。

## 题目描述

已知一个仅由小写英文字母构成的字符串 $s$。

每次操作时，你可以任意选择 $s$ 中的一个字符，并将它修改为任意小写英文字母。

你可以按任意顺序对其进行不超过 $k$ 次操作，以最小化 $s$ 的**严格循环节**的长度。当然，不进行操作也是可以的。

请输出在进行完所有操作后，最小的可能的 $s$ 的严格循环节的长度。

> 一个字符串 $t$ 被称为 $s$ 的严格循环节，当且仅当 $s$ 可以通过将 $t$ 重复若干次来构造。
> 
> 例如：`mai` 是 `maimai` 的严格循环节，`dx` 是 `dx` 的严格循环节。但 `ov` 不是 `ovo` 的严格循环节。


## 说明/提示

**【样例解释 \#1】**

可以证明：最多进行一次操作的情况下，严格循环节长度至少为 $4$。

**【样例解释 \#2】**

可以通过 $3$ 次操作，将 `test` 修改为 `ssss`，严格循环节长度为 $1$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 0（17 pts）：$k = 0$，$|s| \leq 6$。
- Subtask 1（14 pts）：$k = 1$，$|s| \leq 20$。
- Subtask 2（16 pts）：$k = 1$，$|s| \leq 500$。
- Subtask 3（32 pts）：$k < |s| \leq 10^5$。
- Subtask 4（21 pts）： 无特殊限制。

对于所有测试数据，保证 $0 \leq k < |s| \leq 10^6$，$s$ 中仅包含小写英文字母。

**2024.7.28：新增了一组 Hack 数据。**

## 样例 #1

### 输入

```
1
test
```

### 输出

```
4
```

## 样例 #2

### 输入

```
3
test
```

### 输出

```
1
```

## 样例 #3

### 输入

```
3
apollo
```

### 输出

```
3
```

# 题解

## 作者：kind_Ygg (赞：45)

## $Part$ $0$ 题目大意：
给定 $k$ 次更改次数和长度为 $n$ 字符串 $str$，求最小循环节长度。（循环节的定义：若$str$ 是由若干个字符串（字符）$s$ 拼接组成，则 $s$ 为 $str$ 的循环节）
## $Part$ $1$ 算法分析：
最开始看到这个题目，是想用动态规划的，但发现不好推动态转移方程，就算推出来也是 $O(n^2)$，$n \le 10^6$，会炸。于是就想去打暴力，那暴力该如何打呢？应该很容易发现，循环节长度一定为 $n$ 的因子。那么我们就枚举循环节长度，只有当 $n$ $mod$ $i$ 为 $0$ 时才执行下一步操作。  

接下来，我们设 $m$ 为 $n \div i$（也就是区间个数），遍历每个区间第 $k$ 位上出现最多的字符数，那么我们将所有区间第 $k$ 位的字符全部更改为它，更改次数就为 $m - num$（$num$ 是最多出现的字符数），遍历区间的每一位令 $ans$ 加上 $m - num$，我们就得到了区间长度为 $i$ 时的最小更改值，只要操作数小于 $k$，那就输出，一定保证最优。
## $Part$ $2$ 时间复杂度：
表面上我们用了三层循环，时间复杂度应是 $O(n^3)$，实则不然。里面两层循环实际上总共才遍历了 $n$ 次，而外面那层循环如果 $i$ 不为 $n$ 的因子会直接跳出循环，而一个数 $n$ 最多拥有的因子数不超过 $\sqrt{n}$。所以时间复杂度最多是 $O(\sqrt{n} \times n) \le 10^9$，但竟然过了。但正解似乎要用二分（来自 $tzhengqing$ 巨佬的提示）。
## $Code$：

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e5+5;
int k;
string str;
int s[30];
signed main()
{
	cin>>k>>str;
	int len=str.size();
	str=' '+str;
	for(int i=1;i<=len;i++)//枚举最小循环节
	{
		if(len%i==0)
		{
			int mod=len/i;//区间个数
			int ans=0;
			for(int j=1;j<=i;j++)//枚举区间中的每一位
			{
				int maxn=-1;
				memset(s,0,sizeof s);
				for(int k=1;k<=mod;k++)//枚举每个区间
				{
					int l=j+(k-1)*i;
					s[str[l]-'a'+1]++;
					maxn=max(maxn,s[str[l]-'a'+1]);//最多有几个区间不要改
				}
				ans+=mod-maxn;
//				cout<<ans<<" ";
			}
			if(ans<=k)
			{
				cout<<i<<'\n';
				exit(0);
			}
		}
	}
	return 0;
}
```
悄咪咪的说一句，这题思维无，代码难度无，所以建议降橙，但也算一道下位黄吧。

---

## 作者：沃若 (赞：15)

### 出题人题解

严格循环节的长度一定为 $|s|$ 的因子，考虑枚举因子 $d$ 来检查能否在 $k$ 次内得到。

现在，我们只需要解决：至少修改多少个位置，能够让 $s$ 具有长度为 $d$ 的严格循环节？

$s$ 具有长度为 $d$ 的严格循环节，当且仅当对于每个 $i (0 \leq i < d)$，有 $s_i = s_{i+d} = s_{i+2d} = \cdots = s_{|s| - d + i}$。为了使得修改位置最少，我们在其中统计出现次数最多的字符。设该字符出现 $x$ 次，则至少需要修改的字符数量为 $\frac{|s|}{d} - x$，将该式对 $i (0 \leq i < d)$ 求和即可。

例如，要使 `qwqovoqaq` 具有长为 $3$ 的循环节，可以写成 $3$ 行 $3$ 列的形式，则目标为让每一列的字符都相同：

$$
\begin{align}
\texttt{{\color{red}q}{\color{green}w}{\color{brown}q}} \\
\texttt{{\color{red}o}{\color{green}v}{\color{brown}o}} \\
\texttt{{\color{red}q}{\color{green}a}{\color{brown}q}} \\
\end{align}
$$

第一列中出现最多次的字符为 `q`，出现 $2$ 次，则修改剩余的 $1$ 个字符为 `q`。

第二列中出现最多次的字符为 `w`，出现 $1$ 次，则修改剩余的 $2$ 个字符为 `w`。（取 `v`，`a` 也可）。

第三列中出现最多次的字符为 `q`，出现 $2$ 次，则修改剩余的 $1$ 个字符为 `q`。

于是字符串变为 `qwqqwqqwq`（或者 `qvqqvqqvq`，`qaqqaqqaq`），需要修改 $4$ 次，且具有长度为 $3$ 的严格循环节。可以证明没有次数更少的方案。

### 标程

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int k;
string s;
int cnt[26];

int solve(int x) {
	int res = s.length();
	for (int i = 0; i < x; i++) {
		fill(cnt, cnt + 26, 0);
		for (size_t j = i; j < s.length(); j += x)
			cnt[s[j] - 'a']++;
		res -= *max_element(cnt, cnt + 26);
	}
	return res;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> k;
	cin >> s;
	const int n = s.length();
	for (int i = 1; i <= n; i++) {
		if (n % i == 0 && solve(i) <= k) {
			cout << i << '\n';
			return 0;
		}
	}
	return 0;
}
```

### 复杂度分析

设 $|\Sigma|$ 为字符集大小（本题中取 $26$）。

设 $\sigma_k(n) = \sum_{d|n} d^k$，即 $\sigma_0$ 为因子计数函数，$\sigma_1$ 为因子求和函数。

时间复杂度：$\sigma_0(|s|) \cdot |s| + |\Sigma| \cdot \sigma_1(|s|)$

空间复杂度：$|\Sigma|$

可以通过查表或打表得知：$10^6$ 范围内，最大的 $\sigma_0$ 为 $240$，最大的 $\sigma_1$ 为 $4390848$。于是可以通过本题。

### 一种错解

部分选手试图使用二分答案完成本题。然而答案并不具有单调性，所以被 hack 掉了。

---

## 作者：封禁用户 (赞：12)

## 题解

在这道题中，我们需要通过对字符串 `s` 进行不超过 `k` 次字符修改，来最小化其严格循环节的长度。严格循环节是字符串 `s` 可以通过重复某个子串 `t` 形成，说白了，就是一个字符串由多个字符串组合而成。而我们的目标是找到最小的 `t` 的长。

### 思路

1. **循环节的长**：首先，我们需要知道，字符串的长度 `n` 可以被分解为多个可能的循环节长度 `len`，这些长度是 `n` 的因子。也就是说，只有当 `n` 能被 `len` 整除时，`len` 才可能是一个循环节的长度。

2. **字符修改的计算**：对于每一个可能的循环节长度 `len`，我们需要计算将字符串 `s` 修改为可以由长度为 `len` 的子串构成所需的最小修改次数。这个过程可以通过以下步骤实现
   - 对于每个长度为 `len` 的子串，在相应的位置上统计字符出现的频率。
   - 计算在该长度下，最多可以保留的字符数量（即出现次数最多的字符），然后计算需要修改的字符数量。

3. **判断是否可以修改**：如果在某个循环节长度 `len` 下所需的修改次数小于等于 `k`，那么我们就找到了一个可行的解，即可记录下这个长度！

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int times(string s,int len){
    int n=s.size();
    int count[26];
    int tot=0;
    for(int i=0;i<len;i++){
    	memset(count,0,sizeof(count));
        int segtot=0;
        for(int j=i;j<n;j+=len){
            count[s[j]-'a']++;
            segtot++;
        }
        int cnt=*max_element(count,count+26);
        tot+=segtot-cnt;
    }
    return tot;
}
signed main(){
    int k;
    string s;
    cin>>k>>s;
    int n=s.size();
    for(int len=1;len<=n;len++){
        if(n%len==0){
            int chg=times(s,len);
            if(chg<=k){
                cout<<len<<endl;
                return 0;
            }
        }
    }
    cout<<n<<endl;
    return 0;
}
```

### 总结

通过这种方法，我们能够有效地计算出在进行不超过 `k` 次修改后，字符串 `s` 的最小严格循环节长度。这个算法的复杂度主要取决于字符串长度和因子的数量，适合处理较大的输入规模。希望大家喜欢我的第三篇题解！并且看了我的题解可以有所体会！大家再见！

---

## 作者：lcfollower (赞：6)

首先说明，直接对答案二分是错解，详细见[此帖](https://www.luogu.com.cn/discuss/870367)，如果判定不成功两边都可以查找，所以不具有单调性，尽管判定成功就可以往左边找。


---


由于是**严格**循环节，所以我们只需要枚举循环节长度 $len$ 并满足 $len$ 为 $n$（字符串 $s$ 的长度）的约数即可。

然后我们需要一个 $\mathcal O(n)$ 的 $\operatorname{check}$。

对于循环节，如果一次枚举 $s$ 中的长度为 $len$ 的字符串，最后一次判断，时间复杂度为 $\mathcal O(\frac{n^2}{len})$，会超时。代码具体见[此处](https://www.luogu.com.cn/paste/c8f1euea)。

那么我们考虑对循环节的每一位进行处理。

设当前是第 $x$ 个循环节的第 $i$ 个字符，则在字符串（$0$ 开始）的位置为 $\left(x - 1\right)\times len + \left(i - 1\right)$，我们需要考虑每一个 $s_{\left(x - 1\right)\times len + \left(i - 1\right)}$ 并且在长度内的字符丢进计数桶中，计数桶中最多的那个字符就是循环节第 $i$ 个字符。

设最多的字符出现了 $x$ 次，则需要修改的个数会**增加** $\left(\frac{n}{len} - x\right)$ 个，当增加时大于修改次数 $k$ 就不合法，如果到最后还没有大于 $k$ 则合法。

这样 $\operatorname{check}$ 的时间复杂度为 $\mathcal O(\frac{n}{len}\times len) = \mathcal O(n)$。

当然有的人会怕 $n$ 的约数过多，用[该剪贴板](https://www.luogu.com.cn/paste/1lpq182z)的代码可以得出最多的约数个数不超过 $240$，然后再加一个提前退出优化。

因为我们相信测试数据和洛谷的评测机，所以直接写代码就行了。

如果有更低的时间复杂度，欢迎评论。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define infi 0x3f3f3f3f3f3f3f3fll

const int N = 1e6 + 10;
int k;
string s;

inline bool check(int len,int n){
  int tot = 0;
  for(int i = 1;i <= len;i ++){
    int sum[27] = {0} ,mx = 0;
    for(int j = 1;j <= n / len;j ++)
      {int v = (++ sum[s[(j - 1) * len + i - 1] - 96]) ; mx = max(mx ,v);}//计数并更新最大值。
    tot += (n / len - mx);//循环节的任何以一位在字符串中有 n / len 个，减去最大值就是需要修改的个数。
    if(tot > k) return 0;
  } return 1;
} inline void solve(){
  scanf("%lld" ,&k);
  cin >> s;
  int n = s.size() ,ans = n;
  for(int i = 1;i <= n;i ++)
    if(n % i == 0){//枚举约数。
      if(check(i ,n)){ans = i;break;}//如果 i 判定成功，那么 i <= sqrt(i)，这个一定是最小值，可以 break。
      if(n / i != i) {if(check(n / i ,n)) ans = min(ans, n / i);}
    }
  printf("%lld\n" ,ans);
} signed main(){
  int Tcases = 1;
  while(Tcases --) solve();
  return 0;
}
```

---

## 作者：无钩七不改名 (赞：5)

因为循环节是严格的，所以长度一定是字符串长度的因子。所以我们可以直接从小到大枚举因子，判断是否可以在最大修改次数内完成即可。

更具体地，统计每个循环节中的对应位置出现次数最多的字母，则全部该位置改成这个字母，统计修改次数，判断修改次数是否不大于 $k$ 即可。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1000005;

int n,m,a[30];
char s[N];

int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=k*10+c-'0';
		c=getchar();
	}
	return f*k;
} 

bool check(int len){
	int sum=0;
	for(int i(1);i<=len;++i){
		int maxn=0;
		memset(a,0,sizeof a);
		for(int j(i);j<=m;j+=len){
			++a[s[j]-'a'];
			if(a[s[j]-'a']>maxn)maxn=a[s[j]-'a'];
		}
		sum+=m/len-maxn;
		if(sum>n)return 0;
	}
	return 1;
}

int main(){
	n=read();
	scanf(" %s",s+1); 
	m=strlen(s+1);
	for(int i(1);i<=m;++i)if(m%i==0&&check(i))return printf("%d",i),0;
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：5)

## 考场 AC 的错解

一只考场上写 Libingyue2011 的屑 100 pts 的错解二分。

这边开题，感觉有点 KMP，但又感觉不是。

于是，只能是长度 $n$ 的因数里面出答案。

我们充分发扬人类~~发癫~~智慧，考场凭感觉有二分判定单调性的。

凭感觉，但伪证。

于是，就先分解质因数，在质因数里二分每段的长度。

`check` 函数和官方 solution 一样。

然后就莫名奇妙的 AC 了。

考场代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n;
string s;
vector<int>v;
void div(int x){
	v.push_back(0);
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			v.push_back(i);
			if(i*i!=x) v.push_back(x/i);
		}
	} 
} 
int buc[1000010][30];
bool check(int x){
	int l=v[x];
	memset(buc,0,sizeof buc);
	for(int i=1;i<=n;i++) buc[(i-1)%l+1][s[i]-'a'+1]++;
	int sum=0;
	for(int i=1;i<=l;i++){
		int maxn=0;
		for(int j=1;j<=26;j++) maxn=max(maxn,buc[i][j]);
		sum+=maxn;
	}
	if(n-sum<=k) return 1;
	else return 0;
}
int main() {
	cin>>k>>s;
	n=s.size();
	s=" "+s;
	div(n);
	sort(v.begin(),v.end());
	int l=1,r=v.size()-1,mid=0,ans=1;
	while(l<=r)
		if(check(mid=l+r>>1)) r=mid-1,ans=mid;
		else l=mid+1;
	cout<<v[ans];
	return 0;
} 
```
然后发现 `memset` 桶数组的时候，占用时间太多了。

于是改成了这样。
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n;
string s;
vector<int>v;
void div(int x){
	v.push_back(0);
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			v.push_back(i);
			if(i*i!=x) v.push_back(x/i);
		}
	} 
} 
int buc[30];
bool check(int x){
    int l=v[x];
    int sum=0;
    for(int i=1;i<=l;i++){
        memset(buc,0,sizeof buc);
        for(int j=i;j<=n;j+=l) buc[s[j]-'a'+1]++;
        int maxn=0;
        for(int j=1;j<=26;j++) maxn=max(maxn,buc[j]);
        sum+=maxn;
    }
	if(n-sum<=k) return 1;
	else return 0;
}
int main() {
    ios::sync_with_stdio(0);
	cin>>k>>s;
	n=s.size();
	s=" "+s;
	div(n);
	sort(v.begin(),v.end());
	int l=1,r=v.size()-1,mid=0,ans=1;
	while(l<=r)
		if(check(mid=l+r>>1)) r=mid-1,ans=mid;
		else l=mid+1;
	cout<<v[ans];
	return 0;
}
```
时间复杂度：$O(n\log\sqrt{n})$。

但是是错解。

Hack 数据如下。

输入：
```
0
mcmcmcmcmcmc
```
正确输出：
```
2
```
错误输出：
```
4
```

## 正解

把二分去掉，改成枚举。

然后就简单了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n;
string s;
vector<int>v;
void div(int x){
	v.push_back(0);
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			v.push_back(i);
			if(i*i!=x) v.push_back(x/i);
		}
	} 
} 
int buc[30];
bool check(int x){
    int l=v[x];
    int sum=0;
    for(int i=1;i<=l;i++){
        memset(buc,0,sizeof buc);
        for(int j=i;j<=n;j+=l) buc[s[j]-'a'+1]++;
        int maxn=0;
        for(int j=1;j<=26;j++) maxn=max(maxn,buc[j]);
        sum+=maxn;
    }
	if(n-sum<=k) return 1;
	else return 0;
}
int main() {
    ios::sync_with_stdio(0);
	cin>>k>>s;
	n=s.size();
	s=" "+s;
	div(n);
	sort(v.begin(),v.end());
	for(int i=1;i<v.size();i++) if(check(i)){
	    cout<<v[i];
	    return 0;
	}
// 	int l=1,r=v.size()-1,mid=0,ans=1;
// 	while(l<=r)
// 		if(check(mid=l+r>>1)) r=mid-1,ans=mid;
// 		else l=mid+1;
// 	cout<<v[ans];
	return 0;
}
```
跑数据甚至比二分快。

时间复杂度 $O(n\sqrt{n})$。

## 总结

以后在考场上证明一个东西，必须多次检查，不要伪证。

希望数据~~不要~~太水。

---

## 作者：rsy_ (赞：5)

由于是严格循环节，所以枚举因数即可，考虑如何 $\mathcal O(n)$ 去判断一个答案是否合法。

对于循环节的每一位，想要改的最少，那么肯定就要选择出现次数最大的一个字母，于是时间复杂度 $\mathcal O(n\sqrt n)$，获得 $79$ 分。

考虑出题人会怎么卡你，容易发现要么是前面几个，要么是后面几个这种，所以循环之前，判一下前几个和后几个因数，如果有合法的，就不跑后面的循环了。

```cpp
#include <bits/stdc++.h>
#define lb(x) (x&-x)
#define L(i,j,k) for(int i=(j);i<=(k);++i)
#define R(i,j,k) for(int i=(j);i>=(k);--i)
#define swap(a,b) (a^=b^=a^=b)

using namespace std;
using i64 = long long;

typedef pair<int, int> pii;
typedef long long ll;
typedef unsigned long long ull;
void chmin(int &x, int c) {
	x = min(x, c);
}
void chmax(int &x, int c) {
	x = max(x, c);
}

const int maxn = 1e6 + 10, mod = 998244353;
int n, m, res, cnt[maxn][30], mx[maxn]; string s; 
void ck (int x) {
	for (int i = 1; i <= m; i ++ ) {
		mx[i] = 0;
	}
	for (int i = 1; i <= m; i ++ ) {
		cnt[(i - 1) % x + 1][s[i] - 'a'] ++ ;
		mx[(i - 1) % x + 1] = 
		max (mx[(i - 1) % x + 1], cnt[(i - 1) % x + 1][s[i] - 'a']);
	}
	int sum = 0;
	for (int i = 1; i <= m; i ++) {
		sum += mx[i];
	}
	for (int i = 1; i <= m; i ++ ) {
		cnt[(i - 1) % x + 1][s[i] - 'a'] = 0;
	} 
	if (m - sum <= n) res = min (res, x);
}

void solve() {
	cin >> n >> s, res = INT_MAX, s = ' ' + s;
	m = s.size() - 1;
	if (n >= m) {
		cout << 1 << '\n';
	} else {
		for (int i = 1; i <= min(m, 10); i ++ ) {
				if (m % i == 0) {
					ck (i); 
					ck (m / i);
				}
			}
		if (res == INT_MAX) {
			for (int i = 1; i <= m / i; i ++ ) {
				if (m % i == 0) {
					ck (i);
					if (res != INT_MAX) break; 
				}
			}
		}
		int t = sqrt(m); 
		if (res == INT_MAX) {
			for (int i = t; i >= 1; i -- ) {
				if (m % i == 0) {
					if (i * i != m) ck (m / i);
					if (res != INT_MAX) break;
				}
			}
		}
		cout << res << '\n';
	}
}

signed main() {
	int T = 1;
	while (T--)solve();
	return 0;
}
```

---

## 作者：Vct14 (赞：4)

一个较好想的做法。

思路很简单，因为求的是严格循环节长度，所以答案一定是字符串长度的因子。由于求的是最小值，我们直接从小到大枚举答案，如果可以通过至多 $k$ 次操作达成目标，那么直接输出当前枚举的答案。

对于当前枚举的循环节长度 $x$，我们把字符串分成 $x$ 段，那么每一段的第 $i$ 个数必须相同，为了使修改次数尽量小，我们统一将其修改为当前这一位上出现最多的字母。如果修改次数已经大于 $k$ 了，那么继续枚举下一个即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int k;string s;cin>>k>>s;
	int len=s.length();
	for(int x=1; x<=len; x++){
		if(len%x) continue;
		long long sum=0;bool flg=true;int d=len/x; 
		for(int i=0; i<x; i++){
			int cnt[26]={0},mx=0;
			for(int j=i; j<len; j+=x){
				cnt[s[j]-'a']++;
				mx=max(mx,cnt[s[j]-'a']);
			} 
			sum+=d-mx;
			if(sum>k){flg=false;break;} 
		}
		if(flg){cout<<x;return 0;}
	}
	return 0;
}
```

---

## 作者：Fa_Nanf1204 (赞：3)

### 分析：
观察到严格循环节的长度定然是总长度的其中一个因子，这个数量很小，考虑对总长度因数分解，将因子从小到大排序，依次去判断这些因子的合法性即可。

对于每个循环节长度，如何判断合法，考虑贪心去变换字符，对于每个循环节的同一位置上的字符，应当是一致的，所以变换成的字符定然是这一位置上出现次数最多的字符，这样可使其变换次数最小，每一位依次判断即可。
### Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1000005
using namespace std; 
int k,a[N],cnt,len;
char s[N];
int t[30],maxn;
bool check(int x){
	ll res=0;
	for(int i=0;i<x;i++){
		memset(t,0,sizeof t);
		maxn=0;
		for(int j=i;j<len;j+=x){
			t[s[j]-'a']++;
		}
		for(int j=0;j<=25;j++){
			maxn=max(maxn,t[j]);
		}
		res+=len/x-maxn;
		if(res>k) return 0;
	}
	return 1;
}
int main(){
	cin>>k;
	scanf("%s",s);
	len=strlen(s);
	for(int i=1;i*i<=len;i++){
		if(len%i==0){
			a[++cnt]=i;
			if(i*i!=len) a[++cnt]=len/i;
		}
	}
	sort(a+1,a+cnt+1);
	for(int i=1;i<=cnt-1;i++){
		if(check(a[i])){
			cout<<a[i]<<'\n';
			return 0;
		}
	}
	cout<<len;
	return 0;
}
```

---

## 作者：woshishabi11451444 (赞：3)

首先注意到是严格循环节，所以必然循环节的长度一定是字符串 $s$ 的长度的因子，那么有个显然的做法就是枚举这个因子，考虑如何判断是否存在一种修改方案使得修改后的字符串严格循环节长度为 $x$，首先这个循环结的每个位置的选择是相互独立的，接着我们对每一位进行贪心，那么想要这一位的修改次数最少，而每次修改只需修改不满足循环节的位置，所以在最优的修改方案下每一位只会选择这一位在字符串 $s$ 中出现最多次的字符，这里的出现次数是指将字符串 $s$ 平均分为若干段长度为 $x$ 的子段，将这若干段字段对齐，记录对齐后每一位上每种字符的出现次数，这里的时间复杂度有一点极限，需要稍微卡常。

代码如下：

```cpp
#include<iostream>

using namespace std;

const int N = 1e6 + 5;

int k, n, sum[N], maxx[N];
pair<int, int> cnt[N][26];
string s;

bool solve(int x){
  int now = 0;
  long long f = 0;
  for(int i = 0; i < x; i++) sum[i] = 0, maxx[i] = 0;
  for(int i = 1; i <= n; i++){
    int op = s[i] - 'a';
    if(cnt[now][op].first != x){
      cnt[now][op] = {x, 0};
    }
    long long pre = sum[now] - maxx[now];
    sum[now]++;
    cnt[now][op].second++;
    maxx[now] = max(maxx[now], cnt[now][op].second);
    long long nw = sum[now] - maxx[now];
    f += nw - pre;
    if(f > k) return 0;
    now++;
    if(now >= x) now -= x;
  }
  return 1;
}

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> k >> s;
  n = s.size();
  s = ' ' + s;
  for(int i = 1; i <= n; i++){
    if(n % i == 0 && solve(i)){
      cout << i;
      return 0;
    }
  }
  return 0;
}

```

---

## 作者：WsW_ (赞：2)

### 思路
设 $n=|s|$。  
根据题目定义，严格循环节的长度必为 $n$ 的一个正因子。  
通过查表可知，$n\le10^6$ 时 $\max \{ d(n) \} \le240$。  
于是我们可以 $O \left( d(n) \right)$ 枚举严格循环节的长度，并 $O(n)$ 检验。  
检验时，我们先将原字符串分成长度为 $i$ 的 $\frac{n}{i}$ 个字符串。对于第 $j\in [1,i]$ 位，这些字符串要全部修改为同一个字母。  
显然每个第 $j$ 位互不影响。  

我们假定要将这些字符串的第 $j$ 位修改成字母 $a$，那么除了本身第 $j$ 位就是 $a$ 的字符串无需修改以外，其他字符串都需要进行 $1$ 次修改。  
我们要让修改次数尽可能小，就是要找到这些字符串第 $j$ 位上出现次数最多的字母，并将其他字符串第 $j$ 位修改成那个字母。  
只需要对每个字符串第 $j$ 位遍历一遍即可。  

总时间复杂度 $O(d(|s|)\times |s|)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,l;
string s;
int cnt[26];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>k>>s;
	l=s.length();
	for(int i=1;i<=l;i++){
		if(l%i)continue;//不是因子，不处理
		bool f=1;
		int kk=k;
		for(int j=0;j<i;j++){
			int mx=0;
			memset(cnt,0,sizeof(cnt));
			for(int t=j;t<l;t+=i){
				int x=s[t]-'a';
				cnt[x]++;
				mx=max(cnt[x],mx);//统计出现次数最多的字母
			}
			kk-=(l/i-mx);//计算剩余修改次数
			if(kk<0){//修改次数不够，直接退出
				f=0;
				break;
			}
		}
		if(f){
			cout<<i;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：MoraxNB (赞：2)

## 解题思路

这道题的目标是通过修改字符串中的字符，使其具有最小的严格循环节长度。在不超过 $k$ 次操作的限制下，需要计算可能的最小循环节长度。解题的关键在于如何有效地计算在不同循环节长度下所需的最小修改次数。

### 核心思路

1. **循环节长度遍历**：
   - 对于字符串 $s$ 的每个可能的循环节长度 $l$，从 $1$ 到 $|s|$ 进行遍历。
   - 检查 $l$ 是否能整除 $|s|$，即 $|s| \% l == 0$，只有这样的 $l$ 才有可能成为循环节长度。

2. **计算最小修改次数**：
   - 对于每个可能的循环节长度 $l$，计算将字符串变成以 $l$ 为循环节长度所需的最小修改次数。
   - 具体方法是对于每个长度为 $l$ 的位置，统计所有该位置的字符出现频率，找出出现最多的字符，并计算需要修改的次数，使得该位置上的所有字符都变成最多出现的字符。
   - 总修改次数为每个位置所需的修改次数之和。

3. **判断是否满足条件**：
   - 对于每个可能的循环节长度 $l$，如果所需的最小修改次数不超过 $k$，则该长度 $l$ 即为可能的最小严格循环节长度，返回该长度。

4. **返回结果**：
   - 如果遍历完所有可能的循环节长度，未找到满足条件的长度，则返回字符串的总长度 $|s|$ 作为严格循环节长度。

### 详细讲解

1. **函数 `getmin`**：
   - **输入**：字符串 `s` 和循环节长度 `l`。
   - **输出**：将字符串变为以 `l` 为循环节长度所需的最小修改次数。
   - **步骤**：
     - 初始化总修改次数 `c` 为 0。
     - 对于每个位置 $i$ (从 0 到 $l-1$)，统计以 $l$ 为步长的所有字符出现频率。
     - 找出出现最多的字符，并计算将其他字符修改为该字符所需的次数。
     - 累加所有位置的修改次数，即为总修改次数 `c`。

2. **函数 `getans`**：
   - **输入**：整数 `k` 和字符串 `s`。
   - **输出**：在不超过 $k$ 次修改情况下，使字符串变为最小严格循环节长度的长度。
   - **步骤**：
     - 遍历所有可能的循环节长度 `l` (从 1 到 $|s|$)。
     - 对于每个长度 `l`，如果 `|s| \% l == 0`，则调用 `getmin(s, l)` 计算最小修改次数。
     - 如果最小修改次数不超过 $k$，返回该长度 `l`。
     - 如果没有找到满足条件的长度，返回字符串的总长度 $|s|$。

### 代码实现

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>

using namespace std;

// 获取当前长度 l 下需要的最小修改次数
int getmin(string s, int l) {
    int lens = s.length();
    int c = 0;

    for (int i = 0; i < l; ++i) {
        vector<int> f(26, 0); 
        for (int j = i; j < lens; j += l) {
            f[s[j] - 'a']++;
        }

        int maxx = *max_element(f.begin(), f.end());//max_element(u, v)  求(u, v)之间最大值
        int all = (lens - i + l - 1) / l;

        c += all - maxx;
    }

    return c;
}

// 获取最小的严格循环节长度
int getans(int k, string s) {
    int lens = s.length();

    for (int l = 1; l <= lens; ++l) {
        if (lens % l == 0) {
            if (getmin(s, l) <= k) {
                return l;
            }
        }
    }
    return lens;
}

int main() {
    int k;
    string s;
    cin >> k >> s;
    cout << getans(k, s) << endl;
    return 0;
}
```

### 复杂度分析

- **时间复杂度**：
  - 函数 `getmin` 的时间复杂度为 $O(n \cdot \frac{n}{l})$，其中 $n$ 为字符串的长度，$l$ 为循环节长度。
  - 函数 `getans` 遍历所有可能的循环节长度，时间复杂度为 $O(n^2)$。
- **空间复杂度**：
  - 使用了长度为 26 的频率数组 `f`，空间复杂度为 $O(1)$。

审核大大求过

---

## 作者：Dazlin7 (赞：1)

### 思路 

我们知道严格循环节长度肯定是字符串长度的因子，因为我们要最小化严格循环节的长度，所以我们可以首先找出字符串长度的所有因子，然后使用贪心策略判断每个因子是否符合要求。

### 过程

我们可以通过遍历从 $1$ 到字符串长度的平方根，找到所有因子，判断它是否能通过不超过 $k$ 次字符替换满足要求。具体来说，对于每个因子，我们计算每个位置上出现次数最多的字符，将其他字符变成这个字符所需的最少替换次数。如果所有位置的最少替换次数总和不超过 $k$，则这个因子是合法的严格循环节长度。

### 优化：

在枚举前，对每个因子从大到小进行排序，这样在某些情况下可以更快找到答案。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int check(string s, int l, int n) {
    int ch = 0;
    int c[26];
    for (int i = 0; i < l; ++i) 
  	{
        memset(c, 0, sizeof(c));
        for (int j = i; j < n; j += l) {
            c[s[j] - 'a']++;
        }
        ch += (n / l) - *max_element(c, c + 26);
    }
    return ch;
}


int main()
{
	int k,n;
	string s;
	cin>>k>>s;
	n = s.size();
  for (int l = 1; l <= n; ++l) {
        if (n % l == 0) {
            if (check(s, l, n) <= k) {
                cout<<l;
                return 0;
            }
        }
    }
    cout<<n;
}
```

---

## 作者：liuyuannb (赞：1)

# 2024.7.28   14:53

感谢[@ CSP_juruo](https://www.luogu.com.cn/user/500031)，[@qijianci](https://www.luogu.com.cn/user/935133)，[@AeeE5x](https://www.luogu.com.cn/user/708516) 等大佬指出本蒟蒻的题解的错误，这题不能用二分。



---



虽然该题目不具有单调性，但可以通过枚举字符串的长度的因数，并进行判断。一直到找到符合题意的严格循环节的长度，最后输出结束。



---



### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int t[30],k,a[11451419],cnt;
int ddj(int mid)
{
	int sum=0;
	for(int i=0;i<a[mid];i++)
	{
		int ans=0;
		memset(t,0,sizeof(t));
		for(int j=i;j<s.size();j+=a[mid])
		{
			t[int(s[j]-'a')]++;//计算每个循环节对应的字符的出现次数。
			ans++;
		}
		int ma=-1;
		for(int j=0;j<=29;j++)
		  ma=max(ma,t[j]);
		sum+=(ans-ma);//计算最小修改次数。
	}
	if(sum>k)
	  return 0;//判断。
	return 1;
}
int main()
{
	scanf("%d",&k);
	cin>>s;
	for(int i=1;i<=s.size();i++)
	{
		if(s.size()%i==0)
		{
			a[++cnt]=i;//先求出字符串长度的因数，毕竟如果不是字符串长度的因数是不能做严格循环节的长度的。
		}
	}
	int l=1,r=cnt;
	for(int i=1;i<=cnt;i++)//枚举。
	{
		if(ddj(i))
		{
			printf("%d\n",a[i]);//由于数组的因数是按从小到大加入的，因此最先找到符合题意的严格循环节的长度一定最小。
			return 0;
		}
	}
	//printf("%d\n",(ddj(l)?a[l]:a[r]));
	return 0;
}
```


---


### 补充

理论上，这道题如果用暴力枚举的话，是临近极限的 ~~（但不知道为什么跑得最慢的一点也没有时限的一半）~~ 。并且不排除加强数据的可能性，所以最好卡常一下。

---

## 作者：mysterys (赞：1)

# 思路
1.  注意到严格循环节的长度一定是字符串 s 的约数，所以枚举字符串长度 $n$ 的约数即可。
1. 考虑如何判断当前的答案是否可行：设 $x$ 为当前的答案，那么将字符串 s 分成 $x$ 份，每一份长度为  $n \div x$，枚举每一位，当前位置需要修改的数量即为 $(n \div x ) - $ 最多的相同字符的数量，最后只要得出的数量  $ \le x$ 即可。
# 复杂度
-  $\underset{1\le i\le 10^6} {\max}\ d(i) \approx 200$，其中 $\ d(x)$ 表示 $x$ 的约数个数。
-  单次 check 的最坏复杂度 $O(n)$。
- 综上，可以通过本题。
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=1e6+5;
int k,n,cnt;
string s;
int tot[26];
inline bool check(int x){
	if(n%x!=0) return false;
	int t=n/x,sum=0;
	queue<char>vis;
	for(int i=0;i<x;i++){
		memset(tot,0,sizeof(tot));
		for(int j=0;j<t;j++){
			tot[s[x*j+i]-'a']++;
			if(tot[s[x*j+i]-'a']==1){
				vis.push(s[x*j+i]);
			}
		}
		int maxx=0;
		while(!vis.empty()){
			maxx=max(maxx,tot[vis.front()-'a']);
			vis.pop();
		}
		sum+=t-maxx;
		//cout<<maxx<<endl;
	}
	//cout<<sum<<endl;
	return sum<=k;
}
signed main(){
	cin.tie(nullptr)->ios::sync_with_stdio(false);
	cout.tie(nullptr);
	cin>>k>>s;
	n=s.length();
	for(int i=1;i<=n;i++){
		if(check(i)){
			cout<<i;
			return 0;
		}
	}
	cout<<n;
	return 0;
}
```

---

## 作者：luckyqwq (赞：1)

# P10810 【MX-S2-T1】变 题解

### 大致思路：

首先我们知道，要使一个字符串的循环节，那么循环节长度必须是字符串长度的因数，那么我们可以先给字符串的长度，去找一遍他的所有因子，这一操作，需要 $O(\log |S|)$ 的时间。到这里，先不要着急写，因为里面需要用到一个贪心的策略，因为我们会根据每个因子，判断它是否能通过修改其中不超过 $k$ 个字符，那么我们要怎样尽可能少的修改字符呢？找标准串？首先，我们会发现，一个循环节一个循环节不好搞，可以通过每个循环节的同一个位置上的字符去贪心修改，可以发现，假设我们目前枚举的是长度为 $x$ 的循环节是否合法，现在再看循环节的第 $1$ 位，显然，他们的位置分别在 $1, x + 1, 2 × x + 1...$，那么我们根据这个特性来计算同一个位置上，出现次数最多的字符，因为相应的，如果都变成这个出现最多的字符，那么修改的肯定最少，判断他是否超过限制 $k$，最后再看看所有位置至少需要改的数量总和，是否超过 $k$，没超过则为合法循环节长度，否则则继续枚举，以此类推，就能得到最终的答案，在枚举前，如果对每个因子从大到小进行排序，在一些测试点中可以更快的通过。

### 代码实现：

```
#include <bits/stdc++.h>

using namespace std;
int n;
string s;
int len, ans[100005], cnt, mx, t[100005];
void init(int x)
{
	//int y = sqrt(x);
	for (int i = 1;i * i <= x; ++ i)
	{
		if(x % i == 0)
		{
			ans[ ++ cnt] = i;
		}
		if(i * i != x && x % i == 0)
		{
			ans[ ++ cnt] = x / i;
		}
	}
}
signed main()
{
	cin >> n >> s;
	len = s.size();
	s = " " + s;
	init(len);
	sort(ans + 1, ans + cnt + 1);
	int mn = len;
	for (int i = 1;i <= cnt; ++ i)
	{
		int p = len / ans[i];//循环节个数
		bool f = 0;
		int sum = 0;
		for (int j = 1;j <= ans[i]; ++ j)
		{
			mx = 0;
			for (int k = 1;k <= 26; ++ k)//用桶来存每个循环节同个位置字母出现次数
			{
				t[k] = 0;
			}
			int o = j;
			++ t[int(s[j] - 96)];
			for (int k = 2;k <= p; ++ k)
			{
				o += ans[i];
				++ t[int(s[o] - 96)];
			}
			for (int k = 1;k <= 26; ++ k)//用桶来存每个循环节同个位置字母出现次数 
			{
				mx = max(mx, t[k]);
			}
			if(p - mx > n)
			{
				f = 1;
				break;
			}
			sum += (p - mx);
			if(sum > n)
			{
				f = 1;
				break;
			}
		}
		if(f)continue;
		if(sum <= n)
		{
			mn = ans[i];
			break;
		}
	}
	cout << mn << "\n";
	return 0;
}
```

这样这道题目就完成啦！！！

---

## 作者：JYX0924 (赞：1)

看到循环节，立刻就想到了一个重要的结论：令字符串的长度为 $len$，每一个合法的循环节长度 $i$，都有 $len=i\times k$，其中 $k$ 为正整数。

那么，我们可以枚举每一个合法的循环节，然后判断一下是否成立即可。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll n,vis[30];
string s;
int main()
{
    ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>s; int len=s.length();
	for(int i=1;i<=len;i++)
	{
		if(len%i!=0) continue;
		ll tt=0;
		for(int j=0;j<i;j++)
		{
			memset(vis,0,sizeof(vis));
			for(int k=j;k<len;k+=i) vis[s[k]-'a']++;
			ll zd=0; for(int k=0;k<26;k++) zd=max(zd,vis[k]);
			tt+=(len/i-zd); if(tt>n) break;
		}
		if(tt<=n) {cout<<i; return 0;}
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：Hadtsti (赞：1)

### 题意简述

给出由小写字母组成的字符串 $s(1\le |s|\le 10^6)$。称一次操作是将字符串的某个位置修改为另一个小写字母。给出 $k$，求进行不超过 $k$ 次操作后字符串的最短**严格循环节**长度（具体定义见题面）。

### 题目分析

第一眼不知为何有点懵逼，但还是比较简单的。

由于 $n\le10^6$，因此 $n$ 的约数个数不会超过 $240$。因此可以考虑暴力枚举答案长度，并检查需要的操作次数是否小于等于 $k$。

具体地，由于循环节对应位置的字符相同，故我们只需要对每个位置统计出现次数最多的字符，把剩下的改成它就好了，改变次数就是答案。数据偏弱，不需要优化常数。~~但我场上头脑不清醒犯了很多逆天错误，在 26min 才通过。~~

### 代码实现


```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,K,cnt[26][1000010];
char S[1000010];
vector<int>vec; 
int main()
{
	scanf("%d",&K);
	scanf("%s",S+1);
	n=strlen(S+1);
	for(int i=1;i<=n/i;i++)
		if(n%i==0)
		{
			int len=n/i,ans=0;
			for(int j=0;j<len;j++)
				for(int k=1;k<=i;k++)
					cnt[S[j*i+k]-'a'][k]++;
			for(int j=1;j<=i;j++)
			{
				int mx=0;
				for(int k=0;k<26;k++)
					mx=max(mx,cnt[k][j]); 
				ans+=len-mx;
			}
			if(ans<=K)
			{
				printf("%d",i);
				return 0;
			}
			vec.push_back(n/i);
			for(int j=0;j<len;j++)
				for(int k=1;k<=i;k++)
					cnt[S[j*i+k]-'a'][k]--;
		}
	reverse(vec.begin(),vec.end());
	for(int i:vec)
	{
		int len=n/i,ans=0;
		for(int j=0;j<len;j++)
			for(int k=1;k<=i;k++)
				cnt[S[j*i+k]-'a'][k]++;
		for(int j=1;j<=i;j++)
		{
			int mx=0;
			for(int k=0;k<26;k++)
				mx=max(mx,cnt[k][j]); 
			ans+=len-mx;
		}
		if(ans<=K)
		{
			printf("%d",i);
			return 0;
		}
		for(int j=0;j<len;j++)
			for(int k=1;k<=i;k++)
				cnt[S[j*i+k]-'a'][k]--;
	}
	return 0;
}
```

---

## 作者：AeeE5x (赞：1)

# P10810 【MX-S2-T1】变 题解
### **题目大意：**
给定字符串 $s$，进行至多 $k$ 次替换操作，最小化 $s$ 的**严格循环节**长度。\
求 $s$ 的最小的严格循环节长度。


---
### 题目分析：
首先是一个题目里的概念，“严格循环节”。

> 一个字符串 $t$ 被称为 $s$ 的严格循环节，当且仅当 $s$ 可以通过将 $t$ 重复若干次来构造。

什么意思呢？举例：
- `mai` 是 `maimai` 的严格循环节，因为后者是由前者重复两次构成的。'
- `dx` 是 `dx` 的严格循环节，因为后者是由前者=重复一次得到的。

~~（诶，wmc）~~

有了这个概念，我们就很容易想到，一个字符串的严格循环节长度，一定是这个字符串长度的因数。


---
### 思路分析：


我们要修改字符串 $s$ 使 $t$ 是它的严格循环节，可以从小到大枚举所有可能的 $t$ 的长度，把 $s$ 拆分成若干个段落，求出使这些段落全部相同的最小修改数。

不难想到：对段落的每一位进行统计，使每一位出现次数**最多**的字母作为其严格循环节对应位置的字母。这样才能使修改次数最小。

修改次数即为段落数减去出现次数最多的字母的出现次数。此处使用贪心思想。

考虑到各个段落之间相互独立，如果不使用出现次数最多的字母，都将会导致替换次数变大


---

附考场 AC Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rev(x) reverse(x.begin(),x.end())
using namespace std;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	
	int k;string s;cin>>k>>s;
	int len=s.length();
	
	for(int mh=1;mh<=len;mh++){
		if(len%mh!=0) continue;
		int tre=0;
		for(int p=0;p<mh;p++){
			int bt[26]={},maxn=0;
			for(int i=0;i<len/mh;i++) bt[s[p+i*mh]-'a']++;
			for(int i=0;i<26;i++) maxn=max(maxn,bt[i]);
			
			maxn=len/mh-maxn;
			tre+=maxn;
		}
		if(tre<=k){
			cout<<mh;
			return 0;
		}
	}
	
	return 0;
}
```
自我感觉我的代码可读性还行就不加注释了（）

---

## 作者：TangyixiaoQAQ (赞：0)

# 题意简述
给定一个由小写英文字母组成的字符串和一个操作次数 $k$。每次操作可以改变字符串中的任意一个字符。通过不超过 $k$ 次操作，使字符串的严格循环节长度尽可能小。

# 思路解析
因为题目中的严格循环节可以视为最小的周期，所以周期的长度 $l$ 满足 $l \mid len$。

求出因子的时间复杂度为 $O(n\sqrt{n})$，排序的时间复杂度最坏为 $O(n\log(n))$，忽略后者而取前者。

然而赛时 $79$ 分：

```cpp
#include <bits/stdc++.h>
#pragma G++ optimize("O3", "Ofast", "unroll-loops", "inline")
using namespace std;
int k, ans, n;
map<char, int> mp;
string s;
vector<int> factors;
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> k >> s;
    n = s.size();
    ans = n;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            factors.push_back(i);
            if (i != n / i) {
                factors.push_back(n / i);
            }
        }
    }
    sort(factors.begin(), factors.end());
    for (int l : factors) {
        int changes = 0;
        for (int i = 0; i < l; ++i) {
            for (int j = i; j < n; j += l) {
                mp[s[j]]++;
            }
            changes += (n / l) - max_element(mp.begin(), mp.end(), [](const pair<char, int>& a, const pair<char, int>& b) { return a.second < b.second; })->second;
            mp.clear();
        }
        if (changes <= k) {
            ans = l;
            break;
        }
    }
    cout << ans;
    return 0;
}
```
为什么呢？`map`的插入平均时间复杂度为 $O(\log(n))$。

总时间复杂度为 $O(n\sqrt{n}\log(n))$，不能通过此题。

考虑我们其实只要存储字母字符即可，下标范围于 $0 \sim  26$ ，可以直接用桶数组存储，时间复杂度为 $O(1)$。

总时间复杂度为 $O(n\sqrt{n})$，加上剪枝，可以通过此题。

# 代码实现

```cpp
#include <bits/stdc++.h>
#define int long long
#pragma G++ optimize("O3", "Ofast", "unroll-loops", "inline")
using namespace std;
const int N = 1e6 + 5;
vector<int> factors;
int n, k, vis[30], MAX, tot;
char s[N];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> k >> (s + 1);
    n = strlen(s + 1);
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            factors.push_back(i);
            if (i != n / i) {
                factors.push_back(n / i);
            }
        }
    }
    sort(factors.begin(), factors.end());
    for (auto i : factors) {
        tot = 0;
        for (int j = 1; j <= i; j++) {
            MAX = 0;
            memset(vis, 0, sizeof(vis));
            for (int l = j; l <= n; l += i) {
                MAX = max(MAX, ++vis[s[l] - 'a']);
            }
            tot += (n / i - MAX);
            if (tot > k) {
                break;
            }
        }
        if (tot <= k) {
            cout << i << "\n";
            exit(0);
        }
    }
    return 0;
}
```

---

## 作者：bryce (赞：0)

## 思路
首先，我们发现循环节长度肯定是字符串长度的因数，个数不是很多，直接枚举循环节长度。

对于每一个循环节，记录每个循环节的某个位置上某个字母出现的次数，对于每个位置，要使改的次数最少，所以将当前位置的所有字母改为当前位置出现次数最多的字母，设出现次数为 $x$，循环节长度为 $i$，改的次数就为 $\frac{n}{i} - x$，将每个位置改的次数加起来，如果小于等于 $k$，就符合要求，如果大于 $k$，就不符合要求，找出最小的答案。
## 代码
```cpp
#include<iostream>
#include<cstring>

using namespace std;

inline int read(){register int x = 0, f = 1;register char c = getchar();while (c < '0' || c > '9'){if (c == '-') f = -1;c = getchar();}while (c >= '0' && c <= '9'){x = (x << 1) + (x << 3) + (c ^ 48);c = getchar();}return x * f;}
inline void write(int x){if (x < 0) putchar('-'), x = -x;if (x > 9) write(x / 10);putchar(x % 10 + '0');}

const int N = 1e6 + 10;
int k, n, ans;
int cnt[N][27];
char c[N];

int main(){
    k = read();
    cin >> (c + 1);
    n = strlen(c + 1);
    for (int i = 1; i <= n; i++){
        ans = 0;
        if (n % i != 0) continue;
        for (int j = 1; j <= n; j += i){
            for (int p = j; p <= j + i - 1; p++){
                if (p % i == 0) cnt[i][c[p] - 'a']++;
                else cnt[p % i][c[p] - 'a']++;
            }
        }
        for (int j = 1; j <= i; j++){
            int res = 0;
            for (int p = 0; p < 26; p++){
                res = max(res, cnt[j][p]);
                cnt[j][p] = 0;
            }
            ans += n / i - res;
        }
        if (ans <= k){
            cout << i;
            break;
        }
    }
    return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

发现是严格循环节，所以循环节长度 $d \mid n$。

暴力对于 $n$ 的所有因子进行 check。check 的时候贪一下，将原串切成若干个长度为 $d$ 的串，对应位置改成出现次数最多的。每次 check 都是 $O(n)$ 的。如果字符集大小不计复杂度显然是 $O(n \sigma_0(n))$。由于 $\max_{n \le 10^6}\{\sigma_{0}(n)\} = 240$ 所以跑的飞快。[submission](https://www.luogu.com.cn/paste/tnut2tev)

---

## 作者：FJ_OIer (赞：0)

考虑循环节长度为 $p$ 时的最优修改方案：此时应使得（下标从 $1$ 开始）$s_{i}=s_{i+p}=s_{i+2p}=\ldots=s_{i+n-p}$。最优方案显然是统一变成出现次数最多的那个字母。

容易发现循环节的长度只能是 $|s|$ 的因数。于是我们先求出 $|s|$ 的所有因数，枚举这些因数使其作为循环节的长度，再按照上面的方法计算修改次数。输出第一个修改次数小于 $k$ 时的循环节长度。
```cpp
#include <bits/stdc++.h>
using namespace std;
int k,ans;
int sum[1000001];
string s;
vector<int> v;
void apart(int x){
	for (int i=1;i<=x;i++){
		if (x%i==0){
			v.push_back(i);//所有因数
		}
	}
}
int main(){
	cin>>k>>s;
	apart(s.size());
	for (int i=0;i<v.size();i++){
		int p=v[i],cnt=0;
		for (int j=0;j<p;j++){
			int t[200]={},ma=0;
			for (int k=j;k<s.size();k+=p){
				t[s[k]]++;
				ma=max(ma,t[s[k]]);//出现次数最大的字符 的 出现次数
			}
			cnt+=s.size()/p-ma;//计算修改次数
		}
		if (cnt<=k){
			cout<<v[i];
			return 0;
		}
	}
}
```

---

## 作者：huangruiheng0217 (赞：0)

### 题意

已知一个仅由小写英文字母构成的字符串 $s$。

任意进行不多于 $k$ 次操作，每次选择 $s$ 中的一个字符，并将它修改为任意小写英文字母。

输出在进行完所有操作后，最小的可能的 $s$ 的严格循环节的长度。

### 分析

以下记 $n$ 为字符串的长度。

$s$ 的严格循环节长度一定是 $n$ 的因数，才有可能重复若干次得到 $s$ 本身。因此我们考虑枚举所有 $n$ 的因数并逐个判断来解决。

考虑到任何一个因数 $p$ 满足要么 $p\leq \sqrt n$，要么 $\dfrac{n}{p} \leq n$，故只要枚举 $1...\sqrt n$ 并进行判断。

判断环节，用一个数组记录每个循环节同一位置的字符中出现最多字符的出现次数。（为了使总操作次数最少，每一位都要修改为目前出现次数最多的字符，显而易见是最优方案）

剩下注意，`map` 和 `unordered_map` 都会超时。因此还是老老实实用数组吧。另外统计次数的数组每次要清空。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string s;
int mp[30];
bool check(int p){
	int sum=0;
	for(int i=1;i<=p;i++){
		memset(mp,0,sizeof(mp));
		int ans=1919810;
		for(int j=i;j<=n;j+=p){
			mp[s[j]-'a'+1]++;
			ans=min(ans,n/p-mp[s[j]-'a'+1]);
		}
		sum+=ans;
		if(sum>k)
			return 0;
	}
	//cout<<p<<" "<<sum<<endl;
	return 1;
}
signed main(){
	cin>>k>>s;
	n=s.size();
	s=" "+s;
	int i=1;
	for(;i*i<=n;i++){
		if(n%i!=0)continue;
		if(check(i)){
			cout<<i<<endl;
			return 0;
		}
	}
	i--;
	for(;i>=1;i--){
		if(n%i!=0)continue;
		if(check(n/i)){
			cout<<n/i<<endl;
			return 0;
		}
	}
    return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

设 $n=|s|$。

首先 $O(\sqrt n)$ 求出 $n$ 的所有约数（其实大约最多 $512$ 个）。

然后逐个检查，检查可以用捅。特别地循环节是 $n$ 不用判断，可以节省时间。

这样做到时间复杂度 $O(n\sqrt n )$，空间 $O(1)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,mp[26];
string s;
vector<int>y(1,1);
bool check(int t){
    int ret=0;
    for(int i=0;i<t;i++){
        memset(mp,0,sizeof(mp));
        for(int j=i;j<n;j+=t)
            mp[s[j]-'a']++;
        ret+=n/t-(*max_element(mp,mp+26));
        if(ret>k)
            return 0;
    }
    return 1;
}
int main(){
    ios::sync_with_stdio(0);
    cin>>k>>s;
    n=s.size();
    for(int i=2;i*i<n;i++)
        if(n%i==0)
            y.push_back(i);
    for(int i=sqrt(n);i>=2;i--)
        if(n%i==0)
            y.push_back(n/i);
    for(auto p:y){
        if(check(p)){
            cout<<p;
            return 0;
        }
    }
    cout<<n;
    return 0;
}
```

---

## 作者：Ray_Wu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10810)

### 题目大意

可以修改 $k$ 个字符，最小化修改后字符串的循环节长度。

### 大致思路

不难发现，循环节的长度一定是字符串长度 $n$ 的因数。设循环节长度为 $x$（$x \mid n$），那么我们可以把字符串分成 $m = \frac{n}{x}$ 个小段。

对于循环节中的每一位，原字符串 $s$ 中都有 $m$ 个。设当前我们考虑循环节的第 $i$ 位，那么 $s$ 的第 $i, i + x, i + 2x, \cdots, i + (m - 1)x$ 位应当都相等。所以我们开一个数组 $q$，记录以上 $m$ 个位置每个字母出现的次数。

设这 $m$ 个位置中单个字母的最多出现次数为 $t_i$，则很显然：将这 $m$ 个位置修改为同一个字母的最少修改次数为 $m - t_i$。

所以对于长度 $x$ 的循环节来说，最少修改次数为：

$$
\text{ans}_x = \sum_{i = 1}^x m - t_i
$$

枚举所有 $n$ 的因数 $x$，输出使得 $\text{ans}_x\le k$ 的最小的 $x$ 即可。

理论上枚举因数复杂度 $\Theta(\sqrt n)$，对于每个 $x$ 求 $\text{ans}_x$ 复杂度 $\Theta(n)$，总复杂度 $\Theta(n\sqrt n)$，但实际上远远不到，你可以加一些特判剪枝，例如：

- 如果对于一个 $x$ 还未求完其 $\text{ans}_x$，但已经 $ > k$ 了，那么可以直接 break 或者 return，不必再计算下去。

- 从小到大枚举 $n$ 的因数，遇到可行的就输出，后面的不必计算了。

### Code

```cpp
#include <bits/stdc++.h>
#define _for(i, a, b)  for (int i = (a); i <= (b); i ++ )
#define _all(i, a, b)  for (int i = (a); i >= (b); i -- )
using namespace std;
const int N = 1e6 + 5;
int n, k, cnt, Max, num, p[N], q[30];
char c[N];
string s;
inline bool check(int x) {
	num = 0;
	_for (i, 1, x) {
		_for (i, 1, 26)  q[i] = 0;
		Max = 0;
		for (int j = i; j <= n; j += x) {
			q[c[j] - 'a' + 1] ++ ;
			Max = max(Max, q[c[j] - 'a' + 1]);
		}
		num += n / x - Max;
		if (num > k)  return 0;
	}
	return 1;
}
int main() {
	ios :: sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> k >> s;
	n = s.length();
	_for (i, 1, n)  c[i] = s[i - 1];
	_for (i, 1, (int)sqrt(n))  if (n % i == 0) {
		p[ ++ cnt] = i;
		if (check(i)) { cout << i << endl; return 0; }
	}
	_all (i, cnt, 1)  if (check(n / p[i])) { cout << n / p[i] << endl; return 0; }
	cout << n << endl;
	return 0;
}
```

---

## 作者：zjj2024 (赞：0)

### 思路

由于 $10^6$ 以内因数个数最大的数因数个数不会特别大，所以可以枚举最小的长度。

对于每一个长度 $i$，把原串拆成 $\frac{n}{i}$ 段，记录每一个段中的相同项数每个字母出现的个数，再构造出一个每一项和它字母相同的数的个数都最大的长度为 $i$ 的序列，就是这个序列最好的严格循环节，将别的段修改成这个严格循环节的操作次数就是最少操作次数。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
string s;
int b[N][26];
inline int mymax(int a,int b)
{
	if(a>b)return a;
	return b;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int p,n;
	cin>>p>>s;
	n=s.size();
	s=' '+s;
	for(int i=1;i<=n;i++)
	{
		if(n%i!=0)continue;
		const int ii=i;//取模时模数是常量更快
		int k=n/i;
		for(int j=1;j<=n;j++)
		{
			b[(j-1)%ii+1][s[j]-'a']++;//统计
		}
		int sum=0;
		for(int j=1;j<=ii;j++)
		{
			int t=0;
			for(int u=1;u<=k;u++)//每一项取最大值
				t=mymax(t,b[j][s[(u-1)*ii+j]-'a']);
			sum+=t;
		}
		for(int j=1;j<=i;j++)
		{
			for(int k=0;k<26;k++)
				b[j][k]=0;//清空数组
		}
		if(n-sum<=p)//n-sum表示最少操作次数
		{
			cout<<i<<'\n';//由于是从小到大枚举的，有答案直接输出
			return 0;
		}
	}
	cout<<n<<'\n';
	return 0;
}
```

---

## 作者：TPJX (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10810)

### 解题思路

问题的关键是通过尝试所有可能的循环节长度（即从 $1$ 到字符串长度），并检查对于每一个长度，是否能通过不超过 $k$ 次操作将字符串转变成由一个周期子串重复构成。对于每一个可能的周期长度 $l$，需要检验能否通过至多 $k$ 次字符替换，使得整个字符串 $s$ 成为周期为 $l$ 的重复字符串。

具体实现中，首先要确定长度 $l$ 是否为 $s$ 的长度的因子。如果是，接着按周期 $l$ 遍历 $s$ 中的每个字符，统计每个周期内各字符出现的频次，并计算要使整个周期内字符统一所需的最少更改次数。如果对所有周期累计所需的更改次数不超过 $k$，则长度 $l$ 可行。

程序终止于发现第一个有效的循环节长度，因为我们从最小的长度开始检查，所以它将是最小的可能的循环节长度。

### C++ 代码实现

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int LEN = 1000010;
char s[LEN];
int len, k;

bool isValid(int l) {
    if (len % l != 0) return false;
    int chg = 0; // changes
    for (int i = 0; i < l; ++i) {
        int freq[26] = {0}, cnt = 0;
        for (int j = i; j < len; j += l) {
            freq[s[j] - 'a']++;
            cnt++;
        }
        int maxFreq = 0;
        for (int k = 0; k < 26; ++k) 
            if (freq[k] > maxFreq) 
                maxFreq = freq[k];
        chg += cnt - maxFreq;
        if (chg > k) return 0;
    }
    return 1;
}

int main() {
    scanf("%d%s", &k, s);
    len = strlen(s);
    for (int l = 1; l <= len; ++l) {
        if (isValid(l)) {
            printf("%d", l);
            return 0;
        }
    }
    printf("%d", len);
    return 0;
}

```

---

## 作者：xixisuper (赞：0)

# P10810 【MX-S2-T1】变 题解

可以说是一个暴力题，但是暴力要优雅。

## 思路

注意到某个长度 $d$ 是字符串 $s$ 的严格循环节长度的必要条件为 $d\mid n$，$n$ 为字符串 $s$ 的长度，所以说有可能成为字符串 $s$ 的长度个数不会很多（通过计算我们可以知道在 $10^6$ 以内 $720720$ 有最多的约数，个数为 $240$ 个），所以说我们可以考虑暴力枚举严格循环节的长度。

对于一个我们枚举的循环节长度 $d$，如何得知我们最少要修改多少个字符呢？由于本题的字符集是小写字母，仅有 $26$ 个，我们可以考虑统计循环节每一位上各个字母出现的次数，要想使改变的字符数最少，只需要把字符们改成原本在该位置上数量最多的那个字符即可。

统计完最少修改字符个数后，判断其是否小于等于 $k$，满足条件直接输出即可。

归到时间复杂度分析，我们用 $d(n)$ 来表示 $n$ 约数的个数，有时间复杂度为 $O(d(n)\cdot n)$，可以通过此题。

## 代码

本题理清思路最重要，代码难度较小。

```cpp
#include <iostream>
#include <algorithm>
#define ll int
using namespace std;
const ll N=1e6+10;
inline ll read(){
	register ll x=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
ll n,k,tong[N][27];
string s;
int main(){
	k=read();
	cin>>s;
	n=s.size();
	s=' '+s;
	for(ll i=1;i<=n;i++){
		if(n%i) continue;
		for(ll j=1;j<=i;j++) for(ll k=0;k<27;k++) tong[j][k]=0;
		for(ll j=1;j<=n;j+=i){
			for(ll k=0;k<i;k++)
				tong[k+1][s[j+k]-'a'+1]++;
		}
		ll nans=0;
		for(ll j=1;j<=i;j++){
			ll mx=-1;
			for(ll k=1;k<=26;k++) mx=max(mx,tong[j][k]);
			nans+=(n/i)-mx;
		}
		if(nans<=k){
			cout<<i;
			return 0;
		}
	}
	return 0;
} 
```

---

## 作者：船酱魔王 (赞：0)

# P10810 【MX-S2-T1】变 题解

## 题意回顾

长度为 $ n $ 的字符串，修改最多 $ k $ 个位置，最小化循环节长度。

## 分析

从小到大枚举循环节长度，对于确定的循环节长度可以把问题转化为对于第一个循环节的每个位置让每个循环节的对应位置上的字母统一，自然可以表示为循环节个数减去这个对应位置上出现次数最多的字母，后者可以开桶子求出。

我们只需要枚举所有 $ n $ 的因数，时间复杂度为 $ O(n \sqrt n) $，因为 $ n $ 的因数个数远远达不到 $ \sqrt{n} $，因此跑不满，可过。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
using namespace std;
int k;
int n;
string s;
int buc[128];
int check(int x) {
    int tot = 0;
    for(int i = 0; i < x; i++) {
        int cnt = 0;
        for(int j = i; j < n; j += x) {
            buc[s[j]]++;
            cnt = max(cnt, buc[s[j]]);
        }
        tot += n / x - cnt;
        for(int j = i; j < n; j += x) buc[s[j]] = 0;
    }
    return tot;
}
int main() {
    cin >> k >> s;
    n = s.size();
    for(int i = 1; i <= n; i++) {
        if(n % i == 0 && check(i) <= k) {
            cout << i << endl;
            return 0;
        }
    }
    return 0;
}
```

---


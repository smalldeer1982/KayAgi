# [蓝桥杯 2024 国 B] 立定跳远

## 题目描述

在运动会上，小明从数轴的原点开始向正方向立定跳远。项目设置了 $n$ 个检查点 $a_1, a_2, \cdots , a_n$ 且 $a_i \ge a_{i−1} > 0$。小明必须先后跳跃到每个检查点上且只能跳跃到检查点上。同时，小明可以自行再增加 $m$ 个检查点让自己跳得更轻松。

在运动会前，小明制定训练计划让自己单次跳跃的最远距离达到 $L$，并且学会一个爆发技能可以在运动会时使用一次，使用时可以在该次跳跃时的最远距离变为 $2L$。小明想知道，$L$ 的最小值是多少可以完成这个项目？

## 说明/提示

**【样例说明】**

增加检查点 $10, 13, 19$，因此每次跳跃距离为 $1,2, 2, 5, 3, 3, 3, 2$，在第三次跳跃时使用技能即可。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，保证 $n \le 10^2$，$m \le 10^3$，$a_i \le 10^3$。  
对于 $100\%$ 的评测用例，保证 $2 \le n \le 10^5$，$m \le 10^8$，$0 < a_i \le 10^8$。

## 样例 #1

### 输入

```
5 3
1 3 5 16 21```

### 输出

```
3```

# 题解

## 作者：DarkShadow (赞：29)

# P10909（二分）

## 思路分析：

首先观察到本题答案具有单调性，于是我们可以考虑二分最远距离 $L$。

然后考虑如何检查答案，对于原有的这些检查点，每两个检查点之间需要 $\lceil \frac{dis}{L} \rceil-1$ 个新增检查点，其中 $dis$ 表示两个检查点之间的距离，然后判断总检查点个数是否小于 $m$ 就可以了。

那么爆发技能我们该怎么处理呢？由于使用技能可以使距离变成原来的两倍，其实就相当于新增了一个检查点，所以只用给 $m$ 加一就可以了。

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100005;
int n,m,d[N];
bool check(int a){//检查是否合法
	int cnt=0;
	for(int i=1;i<=n;i++)
		cnt+=int(double(d[i]-d[i-1])/double(a)+0.999999)-1;
	return cnt<=m+1;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	int l=1,r=d[n],mid;
	while(l<r){//二分答案
		mid=l+r>>1;
		if(check(mid))  r=mid;
		else  l=mid+1;
	}
	printf("%d",l);
	return 0;
}
```

---

## 作者：__Luna__ (赞：13)

_写在前面：这是本蒟蒻写的第一篇题解，或许存在一定的不严谨之处，欢迎大佬指正。_ 


---



### 一、解题思路

#### 1. 考虑如何判断一个跳跃距离 $L$（不要求最小）是否可以完成这个项目 

我们设第 $n-1$ 个检查点与第 $n$ 个检查点之间的距离为 $s_n$，若：

1. $s_n\le L$，则小明可以直接从第 $n-1$ 个检查点跳到第 $n$ 个检查点；
2. $s_n>L$ 且 $s_n\le (t+1)L$，则小明需要增加 $t$ 个额外检查点，以从第 $n-1$ 个检查点跳到第 $n$ 个检查点。

可用的额外检查点有多少个？$m+1$ 个。因为，使用一次“爆发技能”其实和一个额外检查点的效果等同。   
将指定 $L$ 需要的额外检查点数目累加。如果该数目小于 $m+1$，则可以认为该 $L$ 是可以完成这个项目的。  
以上过程的时间复杂度为 $O(n)$。 

#### 2. 考虑如何找出符合条件的最小 $L$ 值

注意到若设可以完成这个项目的最小 $L$ 值为 $L_{min}$，则当 $L>L_{min}$ 时，也一定可以完成这个项目；当$L<L_{min}$ 时，一定不可以完成这个项目。   
我们可以用二分查找的方式找到那个最小的 $L$。   
假设我们已知 $L_{min}$ 的范围为 $l\le L_{min}\le r$。令 $mid=\frac{l+r}{2}$，若：

1. $L=mid$ 时可以完成这个项目。此时 $L_{min}$ 的范围缩小至 $l\le L_{min}\le mid$；
2. $L=mid$ 时不可以完成这个项目。此时 $L_{min}$ 的范围缩小至 $mid+1\le L_{min}\le r$。

当范围最终缩小到一个确定的数时，此时 $l$ 或 $r$ 的值即为 $L_{min}$ 的值。   
以上过程的时间复杂度为 $O(\log_2n)$。

### 二、代码实现

#### 1. 数据读入

显然以上过程中我们在意的是 $s_n$ 的值而非 $a_n$ 的值，故读入的时候可以先做一次差分。代码如下：

```cpp
cin >> n >> m;
m += 1;
s = new int[n];

int r = 0;   //此处 r 在之后还有作用。
for(int i = 0, j; i < n; i++)
{
    cin >> j;
    s[i] = j - r;
    r = j;
}
```

#### 2. $L$ 可行性检查

定义函数 `bool test(int l)`，以 $O(n)$ 复杂度的算法法检查 `l` 作为跳跃距离 $L$ 的可行性。代码如下：

```cpp
inline bool test(int l)
{
    int t = 0;
    for(int i = 0; i < n; i++)
    {
        t += (s[i] - 1) / l;
        /*
        下面的代码或许更好理解：
        int j = s[i];
        while(l < j)
        {
            t++;
            j -= l;
        }
        这两段代码其实是等价的。
        */
    }
    return t <= m;
}
```

#### 3. 二分查找

代码类似于整数二分。查找范围为 $1\sim a_n$，因为显然如果可以直接跳到最后一个检查点的话，一定可以完成这个项目。代码如下：

```cpp
//r 的初值已在前面差分时得到。
int l = 1;
while(l < r)
{
    int m = (l + r) >> 1;
    if(test(m)) r = m;
    else l = m + 1;
}
cout << l << endl;
```

#### 4. AC代码

代码总时间复杂度为 $O(n\log_2n)$。   
由于本蒟蒻真的很菜，所以用了 36ms / 680.00KB。代码如下：

```cpp
#include<iostream>
using namespace std;

int n, m, *s;

inline bool test(int l)
{
    int t = 0;
    for(int i = 0; i < n; i++)
    {
        t += (s[i] - 1) / l;
    }
    return t <= m;
}

int main()
{
    cin >> n >> m;
	m += 1;
	s = new int[n];
	
	int r = 0;   
	for(int i = 0, j; i < n; i++)
	{
	    cin >> j;
	    s[i] = j - r;
	    r = j;
	}
	
    int l = 1;
    while(l < r)
	{
    	int m = (l + r) >> 1;
    	if(test(m)) r = m;
    	else l = m + 1;
	}	
	cout << l << endl;
	
    return 0;
}
```

---

## 作者：qfy123 (赞：6)

# P10909
[传送门](https://www.luogu.com.cn/problem/P10909)
## 思路
不难发现题目的答案具有**单调性**（若满足以下要求，即可称作答案具有单调性：当 $ans$ 是一个可行解时，比 $ans$ 大的所有数也是这个题目的可行解；当 $ans$ 不是一个可行解，比 $ans$ 小的所有数都不是这个问题的可行解），所以，我们可以用二分答案求 $L$ 的最小值，若二分的一个 $L$ 为可行解就把区间向左缩，否则向右缩。由于求的是最小值，最后输出左端点即可。

考虑 ```check()``` 函数怎么写：从左往右遍历一遍 $a$ 数组，计算出最少要添加多少个检查点，与 $m$ 进行比较即可。计算最少添加检查点个数的公式为 $\sum_{i=1}^{n}(\lceil \frac{a_i - a_{i-1}}{mid} \rceil - 1)$。注：此处我们认为 $a_0 = 0$。

对于处理爆发技能，不难发现，这个技能其实就相当于能够多添加一个检查点，因此初始时把 $m$ 加上 $1$ 即可。
## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned ll
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define repl(i,j,k,l) for(int i=(j);(k);i=(l))
#define r(x) scanf("%d",&x)
#define rl(x) scanf("%lld",&x)
#define rs(x) scanf("%s",x+1)
#define pr(x) printf("%d ",x)
#define pl(x) printf("%d\n",x)
#define prl(x) printf("%lld ",x)
#define pll(x) printf("%lld\n",x)
#define pc(x) putchar(x)
#define ps(x) puts(x+1)
#define sp(x) puts(x)
using namespace std;
const int N = 1e5 + 10;	
int a[N],n,m,l = 1,r = 1e8;
int Ceil(int x,int y){
	return x % y ? x / y + 1: x / y;
}
bool check(int x){
	int cnt = 0;
	rep(i,1,n) cnt += Ceil(a[i]-a[i-1],x) - 1; 
	return cnt <= m;
}
signed main(){
	r(n);r(m);++m;
	rep(i,1,n) r(a[i]);
	while(l < r){
		int mid = (l + r) >> 1;
		if(check(mid)) r = mid;
		else l = mid + 1; 
	}
	pl(l);
	return 0;
}
```

---

## 作者：liuyi0905 (赞：4)

读完题后会发现，如果 $L$ 可以完成项目，那么 $L+1$ 肯定也能完成，所以考虑用二分答案实现本题。

check 函数：

对于每一个跳不过的检查点 $i$，则 $a_i-a_{i-1}>L$，需要新设 $\lceil\frac{a_i-a_{i-1}}{L}\rceil-1$ 个检查点。

我们还会发现，爆发技能一定会用在跳不过的检查点上。如果将爆发技能用在点 $i-1$ 上，则只需新设 $\lceil\frac{a_i-a_{i-1}-L}{L}\rceil-1$ 个检查点。

枚举每一个跳不过的检查点，判断将爆发技能用在它上是否能完成任务。如果有任意一个点可以，则 `return true`。

代码：
```cpp
bool C(int x){
  int l=0,s=0;
  for(int i=1,v;i<=n;i++){
    if(a[i]-a[i-1]<=x){
      continue;
    }
    v=a[i]-a[i-1];
    b[++l]={v,(v+x-1)/x-1};
    s+=b[l].second;
  }
  if(s<=m){
    return 1;
  }
  for(int i=1;i<=l;i++){
    auto [v,c]=b[i];
    if(s-c+(v-1)/x-1<=m){
      return 1;
    }
  }
  return 0;
}
```
主函数就简单了，注意在二分时 $mid$ 不能枚举到 $0$，不然在 `check` 里会出现除以 $0$ RE 的情况。

全部代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using Pii=pair<int,int>;
const int N=1e5+5;
int n,m,a[N];
Pii b[N];
bool C(int x){
  int l=0,s=0;
  for(int i=1,v;i<=n;i++){
    if(a[i]-a[i-1]<=x){
      continue;
    }
    v=a[i]-a[i-1];
    b[++l]={v,(v+x-1)/x-1};
    s+=b[l].second;
  }
  if(s<=m){
    return 1;
  }
  for(int i=1;i<=l;i++){
    auto [v,c]=b[i];
    if(s-c+(v-1)/x-1<=m){
      return 1;
    }
  }
  return 0;
}
int main(){
  cin>>n>>m;
  for(int i=1;i<=n;i++){
    cin>>a[i];
  }
  int l=0,r=1e8+1;
  for(int p;l+1<r;){
    C(p=l+r>>1)?r=p:l=p;
  }
  cout<<r;
  return 0;
}
```

---

## 作者：__O_w_O__ (赞：4)

通过观察不难发现，这道题目的答案具有单调性，即如果 $L$ 合法，那么 $L+1$ 也一定合法，由此就想到了这题的做法：二分。

对于这道题目，我们可以先不考虑爆发技能的存在，如果当前二分的值小于第 $i$ 个点和第 $i+1$ 个点之间的距离，很明显是要增加检查点的，增加的检查点的数量就是第 $i$ 个点到第 $i-1$ 个点之间的距离除以当前二分的值向上取整再减一。

此时再回过头来思考爆发技能的存在，实际上可以将其看成两个检查点之间新增一个检查点，也就是说只要将 $m$ 加一即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
int a[N], n, m;
  
bool check(int x) {
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        int dis = a[i] - a[i - 1];
        if (dis <= x) continue;
        cnt += (int)ceil(1.0 * dis / x) - 1;
        if (cnt > m) return false;
    }
    return true;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    m++;
    int l = 1, r = a[n], best = -1;
    while(l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid - 1, best = mid;
        else l = mid + 1;
    }
    printf("%d\n", best);
    return 0;
}
```

---

## 作者：Double_Sheep (赞：4)

要求最大的最小，想到二分。

我们可以二分 $L$ 的最小值，对于每次 `check(x)`，把所有两个相邻的石头距离大于 $x$ 的全部提取出来，计算最少需要新增几个检查点，注意有一次的跳跃距离可以达到 $2x$。

别忘了起点到 $a_1$ 的这段距离，注意一下细节即可。

最后就是二分的 $l$ 不能从 $0$ 开始，必须从 $1$ 开始，不然会出现 `check()` 中除以 $0$ 的情况，获得 $\texttt{90pts}$。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
int n, m, a[N], b[N];
bool check(int x) {
	int tot = 0; ll sum = 0;
	for (int i = 1; i <= n; i++)
		if (a[i] - a[i - 1] > x)
			b[++tot] = a[i] - a[i - 1], sum += (b[tot] + x - 1) / x - 1;
	if (sum <= m) return 1;
	for (int i = 1; i <= tot; i++) {
		int k = (b[i] - x + x - 1) / x - 1;
		if (sum - ((b[i] + x - 1) / x - 1) + k <= m) return 1;
	}
	return 0;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	int l = 1, r = 1e8, ans = 0;
	while (l <= r) {
		int mid = (l + r) >> 1;
		//printf("%d : %d\n", mid, check(mid));
		if (check(mid)) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：2023gdgz01 (赞：3)

见到字眼“最远距离最小值”，考虑二分答案。

题目说除了单次跳跃的最远距离为 $L$，还可以使用**一次**技能使该次跳跃最远距离为 $2L$，于是可以把技能转化为多加一个检查点。

判断当前 $L$ 是否合法也很好写：遍历 $a$ 数组，若 $a_i-a_{i-1}\ge L$，说明现有两个相邻的检查点之间需要添加检查点，最终判断添加的检查点之和是否小于等于 $m+1$ 即可。

跳跃距离不可为 $0$，大于 $\max\limits_{2\le i\le n}\{a_i-a_{i-1}\}$ 没有意义，所以二分区间为 $[1,10^8]$。

代码如下：

```cpp
#include <cstdio>

int n, m;
long long l = 1, r = 1e8, mid, a[100005];

inline bool check() {
	int cnt = 0;
	for (register int i = 1; i <= n; ++i)
		if (a[i] - a[i - 1] >= mid)
			cnt += (a[i] - a[i - 1]) / mid - ((a[i] - a[i - 1]) % mid == 0);
	return cnt <= m;
}

int main() {
	scanf("%d%d", &n, &m);
	++m;
	for (register int i = 1; i <= n; ++i)
		scanf("%lld", a + i);
	while (l < r) {
		mid = l + r >> 1;
		if (check())
			r = mid;
		else
			l = mid + 1;
	}
	printf("%lld", l);
	return 0;
}
```

时间复杂度 $O((\log_210^8)n)=O(n)$。[AC 链接](https://www.luogu.com.cn/record/174450985)

---

## 作者：abc1856896 (赞：1)

# solution

答案满足单调性，考虑二分答案 $L$。

边界是显然的。左边界是 $0$，右边界是 $d_n$。

判断函数：根据题意计算跳跃的次数再与 $m+1$ 比较即可。加 $1$ 是因为有一个**爆发技能**。相当于判断 $\sum  (\lceil \frac {a_{i}-a_{i-1}} {x} \rceil -1) \le (m+1)$，其中 $x$ 为二分传过来的值。

# code


```cpp
int n,m,a[1000005];
bool check(int x){
	int sum=0;
	for(int i=1;i<=n;i++){
		int kk=ceil(1.0*(a[i]-a[i-1])/x);
		sum=sum+kk-1;
	}
	return sum<=m;
}
signed main(){
	cin>>n>>m;
	m++;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int l=0,r=a[n]+1;
	while(l+1<r){
		int mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid;
	}
	cout<<r;
	return 0;
}
```

---

## 作者：Decepticon (赞：1)

### 题目链接
[P10909 [蓝桥杯 2024 国 B] 立定跳远](https://www.luogu.com.cn/problem/P10909)

### 题目知识点

二分答案

### 题目分析

明显我们可以得到当一个值 $L$ 符合条件时，$L + 1$ 明显也符合条件。这就是二分答案求上界。

首先我们先模拟出一个数组 $ch$，$ch_i = a_i - a_{i-1}$，其中 $a_0 = 0$。每次判断时扫描一遍 $ch$ 数组，算出需要增加检查点的数量 $sum$，当 $sum - 1 \le m$ 时（因为有一次爆发力 $2L$ 距离可以省下一个检查点），这个值 $L$ 就合法。

最后我们输出答案即可。

### $\text{Code}$


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[100005],ch[100005],maxn;

bool check(int len){
     int sum = 0;
     for(int i = 1; i <= n; i++){
         int q = ch[i];
         while(q > len){
             q -= len;
             sum++;
         }
     }
     if(sum-1 <= m) return true;
     return false;
}

int two_ans(int lt,int rt){
    while(lt < rt){
        int mid = (lt+rt)/2;
        if(check(mid) == true) rt = mid;
        else lt = mid+1;
    }
    return lt;
}

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i],ch[i] = a[i]-a[i-1],maxn = max(maxn,ch[i]);
    cout << two_ans(1,maxn);
    return 0;
}
```

---

## 作者：TuYaBoYu (赞：0)

对于 $L$ ,显然若 $L$ 成立 ，则 $L+1$ 一定成立 ，故可对 $L_{min}$ 进行二分答案。

在不考虑爆发技能的前提下，如果 $L<dis_{(i,i+1)}$ , 则需要额外布置 $\lceil \frac{dis_{(i,i+1)}}{L} \rceil-1$ 个检查点 ，对于每个 $L$ , $O(n)$ 判断即可。

关于爆发技能 ，释放爆发技能的过程 ， 本质等价于在两个检查点之间放置新的检查点 ，故只需要将全局 $m$ 加一即可。

$\bm {Code:}$
```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)//偷懒的宏定义
using namespace std;
const int N = 1e5+7;

int n,m,arr[N];
  
bool check(int L) {
	int cnt=0,dis;
	for(int i=1;i<=n;++i) {
		dis=arr[i]-arr[i-1];
		if(dis<=L) continue;
		cnt+=dis/L+(dis%L?1:0)-1;//计算额外布置检查点数量
		if(cnt>m) return 0;
	}
	return 1;
}

int main() {
    ios::sync_with_stdio(0);//关闭同步流，加快输入输出
	cin.tie(0) ,cout.tie(0);
    cin>>n>>m;
    ++m;//处理“爆发技能”
    for(int i=1;i<=n;++i)
		cin>>arr[i];
	int l=1,r=arr[n];//L的上界是最远点，即从原点一步登天
	while(l<r) {
		if(check(mid))
			r=mid;
		else
			l=mid+1;
	}
	cout<<mid;
    return 0;
}
```
${^完_撒~^结_花}$

---

## 作者：__galaxy_1202__ (赞：0)

## 解题思路：
容易发现这道题**决策有单调性**，所以可以**用二分来解答。**

那**怎么判定一个长度可不可行**呢？由于我们有一次蓄力一跳的机会，而这个机会**意味着可以在某个地方少建一个检查点。**  
所以，我们可以**计算出每两个测试点之间长度**，算出我们当前可跳出长度**需要跳几次**，也就是需要检查点数。最后判断**是否小于等于 $m + 1$。**

## CODE：

```cpp
#include <iostream>
using namespace std;
typedef long long ll;
ll n, m, l, r, mid, ans, a[100001];
bool P(ll x)
{
    ll tot = 0;
    for (ll i = 1; i <= n; i++)
    {
        ll num = a[i] - a[i - 1];
        if (num >= x)
        {
            if (num % x == 0) tot += max(0ll, (ll)((ll)(num / x) - 1));
            else tot += max(0ll, (ll)(num / x));
            if (tot > m + 1) return false;
        }
    }
    return tot <= (m + 1);
}
int main()
{
    cin >> n >> m;
    for (ll i = 1; i <= n; i++) cin >> a[i];
    l = 1, r = 1e8, mid = 0;
    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (P(mid)) 
        {
            r = mid - 1;
            ans = mid;
        }
        else l = mid + 1;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Big_Dinosaur (赞：0)

二分。

首先，如果当 $L=x$ 可行，则 $L=x+1$ 也可行。原因：当 $L$ 增大时，可以跳的最远距离也增大了，但每一次都可以不跳到最大距离。因此，可以二分 $L$。

考虑 check 如何写。可以根据 $L$ 计算最少要设的检查点个数。

先考虑无爆发技能时答案。当两端为 $l,r$ 时，若前几次都跳 $L$，最后一次 $\le L$，则要跳 $\lceil\frac{r-l}{L}\rceil$ 次，增加个数为跳跃次数减一。

爆发技能相当于删去一个增加的检查点。原因：原来检查点距离 $\le L$，删去后两段距离合并，$\le 2L$。这可以用爆发技能达到该距离。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
#define pii pair<int,int>
#define mp make_pair
#define fi first
#define se second
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
		#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
		#define gh() getchar()
	#endif
	char q='~';
	inline int r(){
		int o=1,p=0;
		while(q<'0'||q>'9'){if(q=='-')o=-1;q=gh();}
		while(q>='0'&&q<='9'){p=(p<<1)+(p<<3)+(q^48);q=gh();}
		return o*p;
	}
	inline void Wi(int YSC){
		if(YSC==0)return;if(YSC<0){YSC=-YSC;putchar('-');}
		Wi(YSC/10);putchar((YSC%10)^48);
	}
	inline void wln(int J){if(J==0)putchar('0');else Wi(J);putchar('\n');}
	inline void w(int J){if(J==0)putchar('0');else Wi(J);}
	inline void ww(int J){if(J==0)putchar('0');else Wi(J);putchar(' ');}
}
using namespace IO;
using namespace std;
namespace D1n0{
	int n,m,a[114514];
	inline bool check(int x){
		int cnt=0;
		for(ri i=1;i<=n;++i)cnt+=ceil(1.0*(a[i]-a[i-1])/x)-1;
		--cnt;
		return cnt<=m;
	}
	inline void zyt(){
		n=r();m=r();
		for(ri i=1;i<=n;++i)a[i]=r();
		int l=1,r=a[n],Ans;
		while(l<=r){
			int mid=l+r>>1;
			if(check(mid))r=mid-1,Ans=mid;
			else l=mid+1;
		}
		w(Ans);
	}
}
signed main(){
	D1n0::zyt();
}
```

---


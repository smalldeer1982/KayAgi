# [蓝桥杯 2024 国 B] 跳石头

## 题目描述

小明正在和朋友们玩跳石头的小游戏，一共有 $n$ 块石头按 $1$ 到 $n$ 顺序排成一排，第 $i$ 块石头上写有正整数权值 $c_i$。

如果某一时刻小明在第 $j$ 块石头，那么他可以选择跳向第 $j + c_j$ 块石头（前提 $j + c_j \le n$）或者跳向第 $2j$ 块石头（前提 $2j \le n$），没有可跳跃的目标时游戏结束。

假如小明选择从第 $x$ 块石头开始跳跃，如果某块石头**有可能**被小明经过（“经过” 指存在某一时刻小明在这个石头处），则将这块石头的权值纳入得分集合 $S_x$，那么小明从第 $x$ 块石头开始跳跃的得分为 $|S_x|$。

比如如果小明从第 $x$ 块石头出发，所有可能经过的石头上的权值分别为 $5,3,5,2, 3$，那么 $S_x = \{5, 3, 2\}$ 得分为 $|S_x| = 3$。小明可以任选一块石头开始跳跃，请求出小明最多能获得的分数。

## 说明/提示

**【样例说明】**

从第一块石头出发得分最多，路径有以下几种：

1. $1$ 号 $\to 5$ 号：选择从 $1$ 号跳到 $1 + c_1=5$ 号。
2. $1$ 号 $\to 2$ 号 $\to 5$ 号：第一次选择从 $1$ 号跳到 $2 \times 1=2$ 号，第二次选择从 $2$ 号跳到 $2 + c_2 = 5$ 号。
3. $1$ 号 $\to 2$ 号 $\to 4$ 号：第一次选择从 $1$ 号跳到 $2 \times 1=2$ 号，第二次选择从 $2$ 号跳到 $2 \times 2 = 4$ 号。

所以所有可能经过的石头的权值的集合为 $S_1 = \{c_1, c_2, c_4, c_5\} = \{4, 3, 2, 1\}$，得分为 $|S_1| = 4$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，保证 $n \le 20$。  
对于 $100\%$ 的评测用例，保证 $n \le 40000$，$c_i \le n$。

## 样例 #1

### 输入

```
5
4 3 5 2 1```

### 输出

```
4```

# 题解

## 作者：Sweet_2013 (赞：18)

# 我的解题思路
- bitset 优化：使用 bitset 来存储每个起点的权值集合，bitset 支持快速的集合操作（如并集操作），时间复杂度为 $O(\frac{n}{w})$，其中 $w$ 是机器字长。
- 当 $i+c_i\le n$，向 $bs_{i+c_i}$ 跳一步；当 $i\times 2\le n$，向 $bs_{i+c_i}$ 跳一步。也就是按题目说的做啦！
- 最后输出最大值即可。
- 时间复杂度为 $O(\frac{n^2}{w})$，空间复杂度为 $O(\frac{n^2}{w})$。
# 上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=4e4+5; 
int c[MAXN], n, ans; 
bitset<MAXN> bs[MAXN]; 
int main() {
    cin>> n; 
    for (int i=1;i<=n;i++) cin>> c[i]; //以上均为输入。
    for (int i=n;i>=1;i--) {
        bs[i][c[i]]=1;//表当前位的状态  
        if (i+c[i]<=n) bs[i]|=bs[i+c[i]];//当 i+c[i]<=n，向 bs[i+c[i]] 跳一步。  
        if (i*2<=n) bs[i]|=bs[i*2]; //当 i*2<=n，向 bs[i+c[i]] 跳一步。
        ans=max(ans, (int)bs[i].count()); //题目要我们求小明最多能获得的分数，所以要取最大值。
    }
    cout<<ans;//输出。
    return 0;
}
```

---

## 作者：tanruiqing (赞：14)

## 题目大意：

小明在玩一个跳石头的小游戏。游戏中有 $n$ 块石头，按顺序排列为第 $1$ 块到第 $n$ 块。每块石头上写有一个正整数权值，第 $i$ 块石头的权值为 $c_i$，让你求所有的方案中不同权值的个数最大是多少。

这一题的解法（我想到的）是 DP。因为它满足 DP 的特征：

1. 小的子问题会影响大的子问题，但反过来没有影响。
1. 一定有最小的子问题。
1. 一定会储存中间的结果。
1. 所有的子问题结构相似。

## 解题思路：

我们可以用 $1$ 表示可以走到的地方，$0$ 表示不可以走到的地方，再将这些数字串起来，就会发现：好像一个二进制的数字！

所以，我们可以用某个容器：`bitset`。

首先，我们要知道：`bitset` 是什么？（其实我也不会，上百度查了一下……）

`bitset` 是 C++ 标准库中的一个模板类（对我来说很陌生），用于表示固定大小的二进制位序列。它的每个位只能是 $0$ 或 $1$，并且支持位运算（比如按位与、按位或、按位异或等）。

**定义：**

```cpp
bitset<8> a("10010010");//定义一个长度为8的二进制数。
```

**在这道题中，有什么用呢？**

在这道题，我们可以对于两个集合，运用 `bitset` 支持的**按位异或**的操作来合并这两个集合（方法：如果这个位置 $a$ 集合的数为 $1$，$b$ 集合的数为 $1$；或者这个位置 $a$ 集合的数为 $0$，$b$ 集合的数为 $1$；或者这个位置 $a$ 集合的数为 $1$，$b$ 集合的数为 $0$；那么这个位置 $c$ 集合的数为 $1$。否则为 $0$）。

具体使用方式：

```cpp
bitset<8> a("10001000");
bitset<8> b("10101001");
bitset<8> c = a | b;
```

最终 `c` 的答案是：`10101001`。

## 回归本题：

因为有题目所说的从 $x$ 可以移动到 $x+c_i$，所以我们要**从后往前**遍历（不然从前往后遍历的话 $x-c_i$ 就很难得出这个点是从哪里来的）。

然后，对于一个点 $x$，我们可以从这个点到达 $2x$ 或者 $x+c_i$（当然，要确保不能越界），所以就可以得到以下公式：

```cpp
if(i + c[i] <= n){
    dp[i] |= dp[i + c[i]];
}
if(i * 2 <= n){
    dp[i] |= dp[i * 2];
}
```

最后，就是初始化了。对于一个点 $x$，如果从这里开始走的话，那么这个集合里就只有这一种权值，所以 `dp[i] = 1`。

## AC 代码：

[AC 记录（cin）](https://www.luogu.com.cn/record/203470801)，[AC 记录（快读快输）](https://www.luogu.com.cn/record/203471084)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n;
int c[100005]; //权值数组
bitset<100005> dp[100005];//定义一个bitset，这里像是一个二维数组。
int ans;

template<typename T>inline void readT(T &x){
	bool f = 1;
	x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')f = !f;ch = getchar();}
	while(ch >= '0' && ch <= '9'){x = (x << 1) + (x << 3) + (ch ^ 48);ch = getchar();}
	x = (f ? x : -x);
	return ;
}

template<typename T>
inline void writeT(T x){
	if(x < 0)putchar('-'),x = -x;
	if(x > 9)writeT(x / 10);
	putchar(x % 10 + '0');
	return ;
}
//上面是快读快输，可以不用。
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//	cin >> n;
//  如果不想用快读，就用cin
	readT(n);
	for(int i = 1 ; i <= n ; i++){
//		cin >> c[i];
		readT(c[i]);
	}
//  输入
	for(int i = n ; i >= 1 ; i--){//从后往前遍历。
        dp[i][c[i]] = 1;
        //初始化，可以在输入时一起。
		if(i + c[i] <= n){
			dp[i] |= dp[i + c[i]];
		}
		if(i * 2 <= n){
			dp[i] |= dp[i * 2];
		}
        //注意这里要求方案数，所以是直接累加，不是在中间取max。
        ans = max(ans,(int)(dp[i].count()));
        //注意bitset访问要用.count()，这里还强制转换了一下类型。
	}
	writeT(ans);
	puts("");//输出，最后加一个换行。
	return 0;
}
```

本蒟蒻的唯一一篇写得这么详细的题解，求管理员大大给过！

---

## 作者：wangwang0307 (赞：2)

# 思路

这道题明显用动态规划。

## 状态

我们设 $S_{i,j}$ 表示从第 $i$ 个石头走，能经过石头的权值的集合。其中 $j$ 表示该集合中的权值对应的位置。

## 决策

下一步走到哪儿。

如果走到第 $i + c_i$ 个石头，那么状态转移方程为：

$S_i = S_i \cup S_{i + c_i}$

如果走到第 $i \times 2$ 个石头，那么状态转移方程为：

$S_i = S_i \cup S_{i \times 2}$

但是以上方程的前提是走到的位置不超过石头数量。

## 结果

最终取每个集合中拥有权值的数量的最大值即可（即求每个集合的长度最大值）。

# 容器

题目说是存进一个整数集合中，所以肯定是用 set 做。
但是如果这么做的话，很容易 TLE 或 MLE。

因此，我们用 bitset 做。

## bitset 优点

bitset 的空间复杂度很小，做各种运算时的时间复杂度也很小，几乎是常数极小。可以理解为一种布尔数组。

## bitset 做法

那么 $S_i$ 中的一位如果为 $true$，则表示该位对应的权值是可达到的。因此可以用像正常集合算。

# AC CODE
```cpp
#include<iostream>
#include<queue>
#include<utility>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<string>
#include<climits>
#include<vector>
#include<numeric>
#include<stdio.h>
#include<stack>
#include<bitset>
namespace noip{
	using Int = long long;
	
	constexpr Int Max_N = 40000;
	
	std::bitset<1 + Max_N> S[1 + Max_N];
	Int n, c[1 + Max_N];
	
	void init() {}
	void main() {
		std::cin >> n;
		for (Int i = 1; i <= n; i++) {
			std::cin >> c[i];
		}
		for (Int i = n; i >= 1; i--) {
			S[i][c[i]] = true;
			if (i + c[i] <= n) {S[i] |= S[i + c[i]];}
			if (i * 2 <= n) {S[i] |= S[i * 2];}
		}
		Int ans = 0;
		for (Int i = 1; i <= n; i++) {
			ans = std::max(ans, (Int)S[i].count());
		}
		std::cout << ans << std::endl;
	}
}
int main() {
	noip::init();
	noip::main();
	return 0;
}
```

---

## 作者：FISH酱 (赞：1)

## 前置知识

你需要了解动态规划与 `bitset`。

`bitset` 数组的定义方法如下：

```cpp
bitset<40007> s[40007]; 
```

## 思路讲解

本题给出 $n$ 块石头，每块石头都有权值，要求求出所有方案中不同权值的最大个数。

在第 $i$ 块石头时，可跳向第 $i + c_i$ 块石头或跳向第 $2i$ 块石头，当然前提是那个石头存在，不会越界，没有可跳跃的石头时结束。

我们可以使用 `bitset` 来合并两个权值集合，只需要通过按位异或操作实现，像下面这样：

```cpp
s[i] |= s[i+c[i]];
s[i] |= s[2*i];
```

需要注意的是，我们从后向前遍历，对于每个石头，我们先把自己的权值加入集合，再把从它出发走一次能到的石头的权值集合合并，作为当前石头的权值集合，每次操作后要更新最大值答案，即求所有方案中不同权值的最大个数，求集合的元素个数我们使用 `s[i].count()`。

## 代码展示

写代码时注意合并集合的操作，下面是我的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define inf 0x3f3f3f3f
#define endl "\n"

int n,maxn=-inf; // 定义变量n，和存储答案的maxn
int c[40007]; // 定义权值数组
bitset<40007> s[40007]; //定义权值集合数组

int main(){
	cin >> n; // 读入n
    for(int i=1;i<=n;i++) cin>>c[i]; // 读入权值

    for(int i=n;i>=1;i--){ // 从后向前遍历
        s[i][c[i]]=1; // 标记自己的权值
        if(i+c[i] <= n){ // 如果在范围内不越界
            s[i] |= s[i+c[i]]; // 合并权值集合
        }
        if(i*2 <= n){ // 如果在范围内不越界
            s[i] |= s[i*2]; // 合并权值集合
        }
        
        maxn = max(maxn,(int)s[i].count()); // 更新不同权值的最大个数
    }

    cout << maxn; // 输出答案

    return 0; // 完结撒花！
}
```

---

## 作者：违规用户名Jd8@z5Fw (赞：1)

### 题目意思：
给出 $n$ 块石头，假如小明在第 $x$ 位置上，小明可选择跳向 $x+y$ 或者 $2x$ 的位置，他的得分为可能跳到的点的权值组成的集合的大小，求最大得分。

定义 $S_i$ 表示可能跳到的点的权值组成的集合。

__如何计算？__

由分析知：$S_i$ 应该是 $S_{i + c_j}$ 并 $S_{2i}$ 并 $c_j$。

得出算法：从后往前枚举，算出每一个 $S_i$ 的值，取它大小最大的那一个，返回即可。


### 代码:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int c[40005];
bitset<100005> lkb[40005];//利用 bitset 维护，效率更快。
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	int ans=0;
	for(int i=n;i>=1;i--){
		lkb[i][c[i]]=1;
		if(i+c[i]<=n) lkb[i]|=lkb[i+c[i]];
		if(i*2<=n)    lkb[i]|=lkb[i*2];
		ans=max(ans,(int)(lkb[i].count()));
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：许多 (赞：1)

前言：2025 联合省选 Day 1 T2 没做出来，出场发现是 bitset，~~然而我压根没用过 bitset~~，现来找点简单的题补一下知识点。

我们注意到一个起点的 $S_x$ 其实就是 ${c_x} \cup S_{2x} \cup S_{x+c_x}$，在学 bitset 之前，一个很显然的做法是用桶，但桶貌似并不是很好处理这些东西。

这时候就可以引进 bitset 这个神奇的东西，这个东西相当于一个高位二进制数，而且支持位运算。

那我们就很好处理了，而且 bitset 里自带函数 count 可以统计 1 的个数。~~有种把饭喂到嘴边的感觉~~。

# Code


```cpp
int n,ans=0;
int c[N];
bitset<N>a[N];
int main(){
    n=read();
    for(int i=1;i<=n;i++)
        c[i]=read();
    for(int i=n;i>=1;i--){
        a[i][c[i]]=1;
        if(i*2<=n)a[i]=a[i]|a[i*2];
        if(i+c[i]<=n)a[i]=a[i]|a[i+c[i]];
        ans=max(ans,(int)a[i].count());
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### [P10914 [蓝桥杯 2024 国 B] 跳石头](https://www.luogu.com.cn/problem/P10914)
---
## 题意
小明可以从 $j$ 跳到 $j + c_j$ 或 $2j$，他在 $i$ 的得分为他可能跳到的点的权值组成的集合 $S_i$ 的大小。求最高得分。

---
## 解题思路
首先在看到跳法时，我想到了抓住那头牛（一本通的一题）。主要是因为一个是两倍一个是特定个数。

但是一定是 $dp$ 的题,所以只要求最大值即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 4e4 + 1;
int c[MAXN], n, ans = 0;
bitset<MAXN> s[MAXN];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> c[i];
		s[i][c[i]] = 1;
	}
	for (int i = n; i; i--) {
		i + c[i] <= n && (s[i] |= s[i + c[i]], 1);
		2 * i <= n && (s[i] |= s[2 * i], 1);
	}
	for (int i = 1; i <= n; i++) ans = max(ans, (int)s[i].count());
	cout << ans;
	return 0;
}
```

---

## 作者：Li2021 (赞：1)

闲话：建议评黄。

### 题意

小明可以从 $j$ 跳到 $j+c_j$ 或 $2j$。他在 $i$ 的得分为他可能跳到的点的权值组成的集合 $S_i$ 的大小。求最高得分。

### 题解

时间复杂度怎么是 $O(\frac{n^2}{w})$，到底是什么算法呢，好难猜呀。

先想想 $S_i$ 怎么求。很显然地，$S_i=S_{2i}\cup S_{i+c_i}\cup \{c_i\}$。

然后考虑用 `bitset` 维护 $S_i$，从后往前推即可。并集就是或起来。

时间复杂度 $O(\frac{n^2}{w})$。

### 代码

[在这里](https://www.luogu.com.cn/paste/tdairnsx)。

---

## 作者：liuyi0905 (赞：1)

## 题意：
设小明位置为 $i$，则他可以跳到 $i+c_i$ 或 $2i$ 的位置。他在位置 $i$ 得到的分数为他可以跳到的点的权值的不同的个数。求小明的最高得分。
## 思路：
设小明从位置 $i$ 开始跳可以跳到的权值集合为 $S_i$，分数 $|S_i|$。根据题意，很容易得出以下式子：
$$S_i=\{c_i\}\cup S_{i+c_i}\cup S_{2i}$$
位置 $i$ 的集合要用到位置比 $i$ 更大的集合，所以需要倒序枚举，先求出靠后的集合。

时间复杂度：$O(n^2)$。

可能会 TLE，考虑用 `bitset` 优化，具体见 [OI-Wiki](https://oi.wiki/lang/csl/bitset/)。

优化后时间复杂度：$O(\frac{n^2}{w})$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e4 + 5;
int n, c[N];
bitset<N> s[N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> c[i], s[i][c[i]] = 1;
  }
  for (int i = n; i; i--) {
    i + c[i] <= n && (s[i] |= s[i + c[i]], 1);
    2 * i <= n && (s[i] |= s[2 * i], 1);
  }
  int r = 0;
  for (int i = 1; i <= n; i++) {
    r = max(r, (int)s[i].count());
  }
  cout << r;
  return 0;
}
```

---

## 作者：_wzb_ (赞：0)

# [P10914 [蓝桥杯 2024 国 B] 跳石头](https://www.luogu.com.cn/problem/P10914)
## 前置芝士：
需要了解 bitset 和动态规划的运用。
## 题目大意：
小明在第 $i$ 个石头上可以跳到第 $i+c_j$ 石头上或者跳到第 $2\times i$ 块石头上，他在位置 $i$ 得到的分数是他可以跳到的点的权值的不同的个数，要求他所得到的最高分。
## 题目思路：
用 $1$ 表示可以跳到的节点，用 $0$ 表示跳不到的节点，我们可以把它想象成一个二进制数，把每个可以跳到的节点用 bitset 合并起来，最后求每一次循环中的 bitset 中有多少个 $1$ 的最大值就是结果。
## 代码：

```cpp
#include<bits/stdc++.h>      
using namespace std;
int n;                          // 总位置数
int c[40500];                // 存储每个位置的分数值(注意实际题目场景可能需要调整数组大小)
int ans;                        // 存储最终结果(最大不同分数数量)
bitset<40500> dp[40500];        // dp[i]记录从位置i出发能获得的所有分数集合(注意n>10000会导致越界)
signed main() {
	std::ios::sync_with_stdio();
	cout.tie(0); cin.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> c[i];           
    }

    // 逆向动态规划处理
    for(int i = n; i >= 1; i--) { // 从后往前处理，确保后续位置已计算
        dp[i][c[i]] = 1;        // 标记当前位置自身的分数值
        // 跳跃规则1：向右跳c[i]步
        if(i + c[i] <= n) {
            // 合并跳跃后的分数集合(位运算取并集)
            dp[i] |= dp[i + c[i]]; 
        }
        
        // 跳跃规则2
        if(i * 2 <= n) {
            // 合并跳跃后的分数集合
            dp[i] |= dp[i * 2]; 
        }
        
        // 更新最大不同分数数量
        ans = max(ans, int(dp[i].count())); // count()统计bitset中1的个数
    }
    
    cout << ans;                
    return 0;
}



```

---

## 作者：Charles_with_wkc (赞：0)

# 思路
第 $i$ 个点只能跳到 $i+c_i$ 或 $i \times 2$。在题目中可以看到他从一个点跳到另一个点上，也就这个点是关系着那个点，于是考虑 dp。我们可以把每个石头看成一个个集合，把可以跳到的集合合并在一起计算答案就成，为了简单，使用按位与和按位或的方式来合集和交集。但是有个坑，会 MLE，这是我们应该是用 bitset。
# bitset
这里简单介绍一下，如果有如下代码
```cpp
bitset<8>a("10001000");
bitset<8>b("10101001");
bitset<8>c=a|b;
```
那么，结果 $c$ 就是 $a+b$。  
计数用 `count` 就可以了。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N=4e4+5;
int c[N];
int n,ans; 
bitset<N>dp[N]; 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0); 
    cin>>n; 
    for(int i=1;i<=n;i++){
    	cin>>c[i];
    	dp[i][c[i]]=1;
	}
    for(int i=n;i>=1;i--){
        if(i+c[i]<=n) dp[i]|=dp[i+c[i]];  
        if(i*2<=n) dp[i]|=dp[i*2];
        ans=max(ans,(int)dp[i].count());
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：QingDeng_Star (赞：0)

## 题目大意
小明在玩跳石头的游戏，他可以从 $i$ 这个点跳到 $i+c_i$ 这个点上或者是 $2i$ 这个点上，他在位置 $i$ 得到的分数为他可以跳到的点的权值的不同的个数（好绕，但是类似集合）。
## 思路
在题目中可以看到他从一个点跳到另一个点上，也就是管辖着这个点，于是考虑 dp。

我们可以把每个石头看成一个个集合，把可以跳到的集合合并在一起计算答案就成，为了简单，使用按位与和按位或的方式来合集和交集。
## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[200005];
bitset<200005> dp[200005];//不用会MLE，我吃过亏555 
int main(){
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++) 
	{
		cin>>a[i];
		dp[i][a[i]]=1;//小小的预处理 
	}
	for(int i=n;i>=1;i--)
	{
		if(i+a[i]<=n) 
			dp[i]|=dp[i+a[i]];
		if(2*i<=n)
			dp[i]|=dp[i*2];
		ans=max(ans,(int)dp[i].count());
	}
	cout<<ans<<endl;
	return 0;
}//完结散花！ 
```
### 闲话
一开始没信大佬的，没有用 bitset，直接听取 MLE 声一片555……

~~所以说，不听大佬言，吃亏在眼前。~~

---

## 作者：Rainbow_SYX (赞：0)

# 集合真好用
~~本蒟蒻的第一篇题解竟然是灰题？？~~
## Solution

来看题目大意，虽然是统计从每块石头出发的，可以跳到的石头的权值 $c_i$ 有多少种可能，但我们可以把每一块石头看成一个集合，然后只需把满足条件的集合两两相并即可。于是我们就推出了下面这个公式：


$S_i=\{c_i\}\cup S_{i+c_i}\cup S_{2i}$

最后只需输出所有集合之中元素个数的最大值便可。

时间复杂度：$O(n^2)$。



---


又因为每一个位置的集合的更新要用到位置比它更大的集合，所以我们从后往前循环。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<40005> j[40005];//比特集合，用于位运算等操作
//每一个j[x]都有40005位
int c[40005],maxt;
int main()
{
	int n;
    cin>>n;
    for(int i=1;i<=n;i++)
	{
        cin>>c[i];
        
        j[i][c[i]]=1;//初始化
    }
    for(int i=n;i>=1;i--)
	{
		if(i+c[i]<=n) j[i]|=j[i+c[i]];//或运算，等于并集
        
		if(2*i<=n) j[i]|=j[2*i];//同上
		
    	maxt=max(maxt,(int)(j[i].count()));//注意一定要转化成int类型
		//j[i].count的意思是返回j[i]中1的个数
    }
    cout<<maxt;//输出最大值
    return 0;
}
```

---

## 作者：awcyvan (赞：0)

## 暴力出奇迹
另一位佬的 $\text{dp}$ 题解我好像没看懂，于是打算先弄个暴力来试试能拿多少分，没想到过了（）

## Solution
因为这个实质上是在统计每个点出发能到达的点的 $c_i$ 有多少种可能，于是问题就转换为了一个集合问题。我们可以非常简单的得到下面这个转移公式：

$
S_i=\{c_i\} \cup S_{i+c_i} \cup S_{2i}
$

我们想要进行比较快的集合运算，硬算肯定是不行的。但是我们有神奇的 $\text{bitset}$，并集操作就是两个 $\text{bitset}$ 进行或运算，然后我们就有办法计算上面的式子了。

显然，每个 $S_i$ 都只能被它后面的 $S$ 更新，所以我们从后往前更新，这样就可以得到一个常数非常小的 $\mathcal{O}(n^2)$ 的算法，足够通过这道题了。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[40001],ans=0;

bitset<40001> via[40001];

int main(){
    scanf("%ld",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&c[i]);
        via[i][c[i]]=true;//从任何石头出发都至少能经过它自己
    }
    for(int i=n;i>0;--i){
        //从后往前更新
        if(i+c[i]<=n){
            via[i]|=via[i+c[i]];
        }
        if((i<<1)<=n){
            via[i]|=via[i<<1];
        }
        ans=max(ans,int(via[i].count()));
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：I_Like_Play_Genshin (赞：0)

大家好，我是口胡大师，我又来口胡了。

## Solution

小清新简单序列 dp 题，dp 入门级别。

根据题目~~大眼观察法~~可得:

$$
\begin{cases}
f_x=S_x \\
f_{x+c_x}=f_x+ S_{x+c_x} & x+c_x\le n\\
f_{2x}=f_x+S_{2x} & 2x\le n
\end{cases}
$$

所以说对于每一个 $f_x$ 进行求最大值即可。

---


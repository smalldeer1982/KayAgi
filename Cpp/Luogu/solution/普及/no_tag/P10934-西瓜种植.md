# 西瓜种植

## 题目背景

笨笨：小西瓜，小西瓜~

路人甲：不会呀，这西瓜明明就大着啊……

笨笨：那……大西瓜，大西瓜~

路人甲：这么快就改口了……

笨笨：西瓜西瓜~可爱的西瓜~

## 题目描述

笨笨种了一块西瓜地，但这块西瓜地的种植范围是一条直线的……
  
  笨笨在一番研究过后，得出了 $m$ 个结论，这 $m$ 个结论可以使他收获的西瓜最多。
  
  笨笨的结论是这样的：
  
  从西瓜地 $b$ 处到 $e$ 处至少要种植 $t$ 个西瓜，这个范围的收获就可以最大化。
  
  笨笨不想那么辛苦，所以他想种植的西瓜尽量少，而又满足每一个所得的结论。

## 说明/提示

基本上来说，笨笨的西瓜地就是一条壮观的线……

## 样例 #1

### 输入

```
9 4
1 4 2
4 6 2
8 9 2
3 5 2```

### 输出

```
5```

# 题解

## 作者：大宋宝宝 (赞：13)

# 思路
可以贪心的想：如果想要种的瓜最少，一定是让重叠的最多，那么我们就可以将数组按照右端点从小到大排序，然后种树时从后往前枚举，只要这个点之前没有种过瓜，就在这个点种瓜，这样重叠的瓜的数量就最多，也就是种的瓜的数量最少。详见代码注释。
# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
// ans 表示总数 
bool b[5001];
// b 数组用来标记哪些点种过树了 
struct shu {
	int b,e,t;
} a[5001];
bool cmp(shu a1,shu a2) {
	return a1.e<a2.e;
}
//按照右端点从小到大排序的函数 
int main()
{
	cin>>n>>m;
	for(int i=1; i<=m; i++)	{
		cin>>a[i].b>>a[i].e>>a[i].t;
		//输入 
	}
	sort(a+1,a+m+1,cmp);
	//按照右端点从小到大排序 
	for(int i=1; i<=m; i++)	{
		for(int j=a[i].b; j<=a[i].e; j++) {
			if(b[j]&&a[i].t>0) a[i].t--;
			//如果和之前种的有重合，就让现在要种的次数减一 
			//前提是种的次数不能减到 0 以下了，不然会 RE 
		}
		int now=a[i].e;
		// now 表示当前要种的树的位置 
		while(a[i].t--)	{
			while(b[now]) now--;
			//如果当前位置已经种过树了 
			//就考虑前一个位置 
			//直到当前位置没有种过树为止 
			b[now]=1;
			//在当前位置种一棵树，然后标记此处种了树 
			ans++;
			//总数加一 
		}
	}
	cout<<ans;
	//输出总数 
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/177146606)

---

## 作者：ivyjiao (赞：8)

一本通提高篇的题居然还能写题解。

六倍经验：P1250，P1645，P1986，P10934，SP116，UVA1723。

一觉醒来，差分约束都成黄题了？

差分约束是一种特殊的 $n$ 元一次不等式，包含 $n$ 个变量及 $m$ 个约束式子，每个约束式子由两个变量作差构成，每个式子形如 $a_i-a_j\geq k$，$k$ 是常数，$1\leq i,j\leq n$。

而我们看本题，我们先对我们选完的数列进行一个前缀和 $s_i=\sum_{j=1}^{j\leq i} d_j$，$d$ 中 $1$ 表示选了，$0$ 表示没选，那么本题对于每个限制，很明显有个式子 $s_{b_i}-s_{a_i-1}\geq c_i$，我们把每个 $i$ 抽象成一个节点，那么这就是一个差分约束了，跑一遍 SPFA 求最长路来求解。

然而这样是错的，由于前缀和的性质，$s_i \geq s_{i-1}$，因为每个数只能选一次，所以 $s_i-s_{i-1}$ 要么为 $0$，要么为 $1$，由此我们得到：$s_i-s_{i-1}\geq 0,s_{i-1}-s_i\geq -1$。

为了防止下标出现负数，我们把下标统一 $+1$。

在一次 SPFA 的松弛操作后，$dis_v-dis_u\geq w$，与不等式 $s_{b_i}-s_{a_i-1}\geq c_i$ 性质一样，所以 SPFA 可以求出最小值，又因为解不等式同大取大原则，所以要求出最长路。

代码，半年前的牢代码了，码风有点差，还请见谅：

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
int n,m,u,v,w,dis[50001],maxn;
vector<pair<int,int> >G[50001];
queue<int>q;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v>>w;
        G[u].push_back({w,v+1});
    }
    for(int i=0;i<=n;i++){
        G[i+1].push_back({-1,i});
        G[i].push_back({0,i+1});
    }
    memset(dis,-1,sizeof dis);
    dis[0]=0;
    q.push(0);
    while(q.size()){
        int u=q.front();
        q.pop();
        for(int i=0;i<G[u].size();i++){
            if(dis[G[u][i].se]<dis[u]+G[u][i].fi){
                dis[G[u][i].se]=dis[u]+G[u][i].fi;
                q.push(G[u][i].se);
            }
        }
    }
    cout<<dis[n+1];
}
```

---

## 作者：Brilliant11001 (赞：2)

#### [更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18391734)

## [题目传送门](https://www.luogu.com.cn/problem/P10934)

这道题也可以用贪心来做，这里讲一下差分约束的做法。

看到题中给出了 $m$ 条限制性的语句就联想到差分约束（差分约束的题还是很显眼的）。

做差分约束的题首先得把题面抽象成很多个不等式，所以我们先来转化一下题意。

首先发现求最小值，那么先确定转化方向：**将所有条件转换成大于或大于等于，然后建边跑最长路**。

设 $x_i$ 表示前 $i$ 块地共种了多少个西瓜。

那么对于每个关系可以理解为 $sum_b - sum_{a - 1} \ge c$，就是说 $[a, b]$ 这块地种的西瓜数量要大于等于 $c$，那么就从 $a - 1$ 向 $b$ 连一条长度为 $c$ 的有向边。

但是光这样建边你会发现根本做不了一点，因为你根本不知道该从哪里开始跑最长路，而且无法正确求解。

这就是这道题非常有意思的一点，因为除了给出的数据需要建边，还有隐藏的建边关系。

注意：

> 每处最多只能种一个西瓜。

这其实隐藏了一个关系：$\forall i \in [1,n],0\le x_i - x_{i - 1} \le 1$。

拆开来看就是：

$$
\begin{cases}
x_i - x_{i - 1}\ge 0\\
x_{i - 1} - x_i\ge -1
\end{cases}
$$

所以，要从 $i - 1$ 向 $i$ 连一条长度为 $0$ 的有向边，
从 $i$ 向 $i - 1$ 连一条长度为 $-1$ 的有向边。

综上，再根据刚刚的建图方式，从 $0$ 号点跑最长路，答案就是 $x_n$。

$\texttt{Code:}$

```cpp
#include <queue>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 30010, M = 100010;

int n, m, C;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
bool vis[N];

void add(int a, int b, int c) {
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int ans;
void spfa(int s) {
	queue<int> q;
	q.push(s);
	memset(dist, -0x3f, sizeof dist);
	dist[s] = 0;
	vis[s] = true;
	while(q.size()) {
		int t = q.front();
		q.pop();
		vis[t] = false;
		for(int i = h[t]; ~i; i = ne[i]) {
			int j = e[i];
			if(dist[j] < dist[t] + w[i]) {
				dist[j] = dist[t] + w[i];
				if(!vis[j]) {
					vis[j] = true;
					q.push(j);
				}
			}
		}
	}
}

int main() {
	memset(h, -1, sizeof h);
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		add(i - 1, i, 0);
		add(i, i - 1, -1);
	}
	for(int i = 1, a, b, c; i <= m; i++) {
		scanf("%d%d%d", &a, &b, &c);
		add(a - 1, b, c);
	}
	spfa(0);
	printf("%d", dist[n]);
	return 0;
} 
```

---

## 作者：Charles_with_wkc (赞：1)

# 思路：
明显的**贪心题目**，如果想要种的瓜最少，一定是让重叠的最多，那么我们就可以将数组按照右端点从小到大排序，然后种树时从后往前枚举。
# 核心代码：
```cpp
sort(a+1,a+m+1,cmp);//按照右端点从小到大排序
for(int i=1; i<=m; i++)	{
	for(int j=a[i].b; j<=a[i].e; j++) {
		if(b[j]&&a[i].t>0) a[i].t--;//如果和之前种的有重合，就让现在要种的次数减一
	}
	int now=a[i].e;
	while(a[i].t--)	{
		while(b[now]) now--;//如果当前位置已经种过树了
		b[now]=1;//在当前位置种一棵树，然后标记此处种了树
		ans++;
	}
}
```

---

## 作者：_shine_ (赞：1)

一眼贪心。所以本题难点在于如何贪心

先转化一下题目，即在构造一个零一串，使其满足一些条件（每个区间 $\left[l,r\right]$ 中数字的和不小于 $c$。），求序列中的和最小为多少。

先看下图：

[![pAlm1lq.png](https://s21.ax1x.com/2024/09/26/pAlm1lq.png)](https://imgse.com/i/pAlm1lq)

这两对颜色不同的竖线表示的是两个区间，如果要用最少的代价满足两个条件，显然是要把一放在两个区间重叠的地方，这样显然最优。但是现在在程序中如何实现这一功能。发现如果按照右端点的位置从小到大排序，则所有的一都尽量放在最右边一定是最优的（如果当前区间与下一个区间未重叠，那么随便放哪都可以，而与下一个区间重复时，从右端点开始往左放必定会尽量让下一个区间也能满足条件）

所以依照上文方法贪心即可，但要注意右端点放的个数要减去当前区间已经放了的 $1$ 的个数。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e3+10;
struct node{int l,r,x;}a[maxn];
int n,m;
int vis[maxn],ans;
signed main(){
    cin >> n >> m;
    for(int i=1;i<=m;++i)cin >> a[i].l >> a[i].r >> a[i].x;
    sort(a+1,a+m+1,[](node x,node y){if(x.r!=y.r)return x.r<y.r;return x.l<y.l;});
    for(int i=1;i<=m;++i){
        int now_stamp=0;
        for(int j=a[i].l;j<=a[i].r;++j)if(vis[j]==1)now_stamp++;
        if(now_stamp>=a[i].x)continue;
        for(int j=a[i].r;j>=a[i].l;--j){
            if(vis[j]==1)continue;
            vis[j]=1,ans++,now_stamp++;
            if(now_stamp==a[i].x)break;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

# 题目大意
笨笨种西瓜，从西瓜地 $B$ 处到 $E$ 处至少要种植 $T$ 个西瓜，问最少种几颗。
# 分析
鉴于 $n≤5000$ 的数据，$n$ 方的算法问题不大。为了让种植的西瓜最少，那么在**区间重合的地方多种西瓜**就是贪心策略。一道非常简单的题目，$n$ 方的算法实现上述思路并不难。先计算在不考虑区间重合的情况下要种多少颗，再计算将所有重叠区间种满能解决几颗的区间要求，计算差值即可。不放代码，同学们自行完成。

---

## 作者：huanglihuan (赞：1)

三倍经验，P1986，P1250。

### 思路

构建结构体，压入三个元素 $l$，$r$，$c$ 即题目中的 $b$，$e$，$t$。$l$ 表示左端点，$r$ 表示右端点，$c$ 表示需要种植的西瓜数。

接着，我们按右（左）端点从小到大排序。

排完后，因为要尽量让 $p_i$ 的 $r$ 与 $p_{i + 1}$ 的 $l$ 重合，所以考虑贪心。

我们用 $sum$ 记录每个区间内的种瓜数，$ans$ 代表总瓜数，$f$ 数组用来标记第 $i$ 个位置有没有种瓜。

[代码](https://www.luogu.com.cn/paste/t49mudcw)。

---

## 作者：program_xwl (赞：1)

这题是区间选点问题的模板题。
# 解法：
我们应该让每个区间选的点都尽量让后面还没有选点的区间受益，这样后面的区间选点的数量就可以少一些。这是这类问题的贪心策略。

我们先假设我们已经按照一种符合要求的排序方式拍好了序。我们具体该怎么贪心呢？对于每个区间，我们首先需要数一下当前这个区间有多少个点，也就是前面的区间给它贡献了多少点，接着，我们需要把这些还需要选的点尽量放在区间的末尾，为什么呢？上面说了，我们需要尽量让后面的区间受益，而我们假设已经排好了序，所以放在后面最可能让后面区间受益，但要注意，选过的点就不能再选了。

那么，该怎么排序呢？如果按区间的左端点从小到大排序，那么可能会出现前面的区间把后面的区间直接吃掉后面区间的情况，这时候，我们肯定是让被吃掉的区间先选点，因为它选的点可以完全让把它吃掉的区间受益，但如果让把它吃掉的区间先选，那就不一定可以让被它吃掉的区间受益。而按照区间右端点从小到大排序，就不会出现前面把后面吃掉的情况，最多只会出现前面的区间和后面区间重合或是后面的区间吃掉前面区间的情况。
# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

struct node
{
	int l,r,number;
} a[5005];
int h,n,ans = 0;
bool vis[5005];
bool cmp(node x,node y){return x.r < y.r;}

int main(void)
{
	cin >> h >> n;
	for(int i = 1;i <= n;i++) cin >> a[i].l >> a[i].r >> a[i].number;
	sort(a+1,a+n+1,cmp);
	for(int i = 1;i <= n;i++)
	{
		int cnt = 0;
		for(int j = a[i].l;j <= a[i].r;j++)
		{
			if(vis[j]) cnt++;
			if(cnt >= a[i].number) break;
		}
		if(a[i].number > cnt)
		{
			for(int j = a[i].r;j >= a[i].l;j--)
			{
				if(vis[j] == 0)
				{
					ans++;
					cnt++;
					vis[j] = 1;
					if(cnt >= a[i].number) break;
				}
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

要使得西瓜种的数量尽可能小，那么就需要在区间重叠处尽可能多种西瓜。

考虑贪心算法，先将所有区间按照右端点从小到大排序，则只要我们尽可能把西瓜种到末尾，那么就是最优的。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=5050;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r,w;
	bool operator<(const Node&rhs)const{
		if(r^rhs.r)
		  return r<rhs.r;
		return l<rhs.l;
	}
}a[N];
ll n,m,l,r,sum,ans;
bool f[N];
int main(){
	n=read(),m=read();
	For(i,1,m)
	  a[i]={read(),read(),read()};
	sort(a+1,a+m+1);
	For(i,1,m){
		l=a[i].l,r=a[i].r;
		sum=0;
		For(j,l,r)
		  sum+=f[j];
		if(sum>=a[i].w)
		  continue;
		sum=a[i].w-sum;
		_For(j,l,r){
			if(!sum)
			  break;
			if(f[j])
			  continue;
			f[j]=1;
			sum--;
		}
	}
	For(i,1,n)
	  ans+=f[i];
	write(ans);
    return 0;
}
```

---

## 作者：koukou (赞：1)

建议降黄。

## 贪心思想

贪心策略不难想，先来分析一下：对于两端区间，把西瓜种在他们重合的地方一定是最优的，贪心策略不就来了吗？

对于更多的区间，这个方法也依然适用。

## 实现方法：

先按右端点排序，对于每一个区间如果没达到要求，就从后往前种，因为这样才保证有最多重合。

## 代码：


```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
struct node
{
    int l, r, c;
}a[100001];
int cmp(node x, node y)
{
    return x.r < y.r;
}
int m, n, ans, s[100001];
int main()
{
    memset(s, 0, sizeof(s));
    cin >> m >> n;
    for(int i = 1; i <= n; i++)
	{
		cin >> a[i].l >> a[i].r >> a[i].c;//输入
	}
    sort(a + 1, a + 1 + n, cmp);//排序
    for(int i = 1; i <= n; i++)
    {
        int as = 0;
        for(int j = a[i].l; j <= a[i].r; j++)
        {
            if(s[j])
			{
				as++;//先统计这个区间内已经种了多少个西瓜
			}
		}
        for(int j = a[i].r; j >= a[i].l && as < a[i].c; j--)//种剩下需要的西瓜
        {
            if(!s[j])//如果没被种过
            {
               s[j] = 1;
               as++, ans++;
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：LG086 (赞：1)

二倍经验 [P1250](https://www.luogu.com.cn/problem/P1250)。



---

贪心。  
又想种的瓜少，又想满足每个条件，那么在重合的区间里尽可能多种瓜。  
![瓜地](https://cdn.luogu.com.cn/upload/image_hosting/qtyevluj.png)  
```
1 3 3
2 5 3
5 6 2
```  
例如当输入的 $b_i,e_i,t_i$ 如上时，图中种瓜的方法符合要求且需要种的瓜最少。


发现重合部分都在区间的末端，所以可以先按每个 $b_i$ 的大小进行排序。  
为了方便排序，定义一个结构体数组 $a$ 来存每个 $b_i,e_i,t_i$。

排序后遍历每个区间，先判断当前区间包含的已种瓜的数量是否已经符合条件。  
如果已经符合，跳过循环；否则在区间的最末端种瓜直到符合条件。

最后输出答案 $ans$ 即可。


---

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

ll n,m,ans=0;
struct Gua{ll b,e,t;}a[114514];
bool vis[114514];
bool cmp(Gua a,Gua b)
{return a.e<b.e;}
int main(){
    cin>>n>>m;
    for(ll i(1);i<=m;i++)
    cin>>a[i].b>>a[i].e>>a[i].t;
    sort(a+1,a+1+m,cmp);
    for(ll i(1);i<=m;i++){//遍历每个区间
        ll cnt=0;
        for(ll j(a[i].b);j<=a[i].e;j++)
        if(vis[j])cnt++;//数区间包含的瓜的数量
        if(cnt>=a[i].t)continue;//瓜够多了，跳过
        for(ll j(a[i].e);j>=a[i].b;j--)
            if(!vis[j]){//补种西瓜
                vis[j]=1,cnt++,ans++;
                if(cnt==a[i].t)break;//瓜够多了，跳出循环
            }
    }cout<<ans;//输出
}
```

---


# GF和猫咪的玩具

## 题目描述

GF 同学和猫咪得到了一个特别的玩具，这个玩具由 $n$ 个金属环（编号为 $1 \sim n$）和 $m$ 条绳索组成，每条绳索连接两个不同的金属环，并且长度相同。GF 左手拿起金属环 $L$，猫咪右手(或者说:爪)拿起金属环 $R\ (L \ne R)$，然后尽量的向两边拉，他希望选择合适的 $L$ 和 $R$，使得被拉紧的绳索尽量的多。 

注：如果像样例那样 $1 \to 2 \to 4 \to 3 \to 5 \to 6 \to 1$ 构成了一个环，我们认为拉 $1$ 和 $3$ 时只能拉紧一边（$1 \to 2 \to 4 \to 3$ 或 $3 \to 5 \to 6 \to 1$）而不算全部拉紧。通俗地说，也就是当两个环之间有几个绳索数相等的连接方法时，只算其中一条连接方法拉紧，不算全部拉紧。


## 样例 #1

### 输入

```
6 6
1 2
1 6
2 4
6 5
4 3
5 3```

### 输出

```
3```

# 题解

## 作者：ycy1124 (赞：6)

### 题意
~~本题最大的难点（？~~

有一个 $n$ 个点，$m$ 条长度为 $1$ 的边的无向图，求图中任意两点间的最短距离的最大值。
### 分析
边权都一样，且无向，$n$ 还那么小，直接暴力 bfs 就行了。
### 代码
```cpp
#include<bits/stdc++.h>
#define qwq for(int i=1;i<=n;i++){bj[i]=0;}
struct Node{
	int p,w;
};
using namespace std;
int ans=0;
bool bj[101];
vector<int>a[101];
queue<Node>q;
void bfs(int p,int w){
	ans=max(ans,w);//更新答案
	bj[p]=1;
	for(auto it:a[p]){
		if(!bj[it]){
			q.push({it,w+1});
			bj[it]=1;
		}
	}
}
signed main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		a[u].push_back(v);
		a[v].push_back(u);//存无向图
	}
	for(int i=1;i<=n;i++){
		q.push({i,0});
		while(!q.empty()){
			bfs(q.front().p,q.front().w);//bfs
			q.pop();
		}
		qwq;//记得清空标记数组
	}
	printf("%d",ans);
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/178610059)。

---

## 作者：be_RISK (赞：4)

## 题意
给你一张无向图，让你求 

$$\max_{i = 1}^{n}\max_{j = 1}^{n}dis_{i,j}$$

同时这里的 $dis_{i,j}$ 表示点 $i$ 到 $j$ 的最短路，$1\le n\le 100$。
## 思路
通过题意和范围，显然可以看出这是一个 Floyd 求全源最短路，最后再 $O(n^2)$ 求最大值就好了，实现很简单。
## code
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	char c=getchar();
	int ret=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		ret=(ret<<3)+(ret<<1)+c-'0';
		c=getchar();
	}return ret*f;
}
inline void write(int x,int op){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10,0);
	putchar((char)(x%10+'0'));
	if(op){
		if(op>0)puts("");
		if(op<0)putchar(' ');
		if(op==0)puts("114514");
	}
}
const int N=114,inf=1145141919810;
int ans=-inf;
int n,m;
int dis[N][N];
signed main(){
    scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){//初始化
		for(int j=1;j<=n;j++){
			dis[i][j]=inf;
		}dis[i][i]=0;
	}
	for(int i=1;i<=m;i++){//输入
		int u,v;
        scanf("%lld%lld",&u,&v);
		dis[u][v]=1;
		dis[v][u]=1;
	}
	for(int k=1;k<=n;k++){//Floyd
		for(int i=1;i<=n;i++){
			if(i==k)continue;
			for(int j=1;j<=n;j++){
				if(j==k||j==i)continue;
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
				dis[j][i]=min(dis[j][i],dis[j][k]+dis[k][i]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			ans=max(ans,dis[i][j]);//求答案
		}
	}write(ans,0);
	return 0;
}//~*完结撒花*~
```

---

## 作者：Malkin_Moonlight (赞：3)

# 题解：P10942 GF和猫咪的玩具

# 思路

[题目传送门](https://www.luogu.com.cn/problem/P10942)

题目给定你一个由环和绳索组成的图，让你求两点之间拉紧最多能拉紧的绳索数量。

在本题中所有的边权均为 $1$，所以两点之间最多能拉紧的绳索数就是它们之间的最短路径，最后再取最大即可。而我们的数据范围较小，可以使用 Floyd 来做。

[Floyd算法](https://baike.baidu.com/item/Floyd%E7%AE%97%E6%B3%95/291990?fromtitle=floyd&fromid=23665947&fr=aladdin)

[不会 Floyd 先做这道题](https://www.luogu.com.cn/problem/B3647)

# 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pb emplace_back
#define endl '\n'
const ll MAXN = 1e5 + 5;
const ll MOD = 1e9 + 7;

ll n, m, a, b;
ll dis[105][105];

inline ll read() {
	ll x = 0, f = 1;char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-')f = -1;ch = getchar();}
	while (ch >= '0' && ch <= '9') {x = (x << 1) + (x << 3) + ch - '0';ch = getchar();}
	return x * f;
}
inline void write(ll x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar((x % 10) | 0x30);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dis[i][j] = 1e9;
			dis[i][i] = 0;
        }
    }
    for (int i = 1; i <= m; i++) {
        cin >> a >> b;
        dis[a][b] = 1;
		dis[b][a] = 1;
    }
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dis[i][k] + dis[k][j] < dis[i][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }
    ll Max = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            Max = max(Max, dis[i][j]);
        }
    }
    cout << Max << endl;
	return 0;
}
```

---

## 作者：z_yq (赞：2)

# 题意
纯语文理解题目，题目相当于要你求最短路最长是多少。
# 做法
特别简单，数据范围小，直接用 Floyd ~~草~~写就可以过去了。可以在计算出最短路后，枚举两个点，取最长的最短路即可，这样的时空复杂度均小于 $10^6$。
# Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
const ll N=109;
ll n,m,dp[N][N];
int main()
{
    cin>>n>>m;
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i<=m;i++)
    {
        ll x,y;
        cin>>x>>y;
        dp[x][y]=dp[y][x]=1;
    }
    for(int i=1;i<=n;i++)
        dp[i][i]=0;
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
    ll maxx=INT_MIN;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            maxx=max(maxx,(dp[i][j]!=INF?dp[i][j]:-1));
    cout<<maxx;
    return 0;
}
```

---

## 作者：_Mortis_ (赞：2)

此题建议评橙。
## 题意

给定一个图，求两点之间能**拉紧**的最长路径。

## 思路

注意到，两点之间能拉紧的路径一定是最短路径（如下图），那么我们只需求出两点间的最短路径，再取最大值即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/z2e70fdk.png)

本题数据范围很小，$ n \le 100 $，$ \Theta (n ^ 3) $ 的 Floyd 轻松过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e2+10;
int n,m,ans,f[N][N];
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m;
	memset(f,0x3f,sizeof(f));
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		f[u][v]=f[v][u]=1;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(f[i][j]!=0x7f7f7f7f)ans=max(ans,f[i][j]);
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/175207067)

---

## 作者：BK小鹿 (赞：1)

## 题意简述

给定一个由环和绳索组成的图，求两点之间能够拉紧的最长路径（不成环）所包含的绳索数。

## 思路分析

$n$ 范围相当小，显然使用 floyd，再找出最长路径长度即可。

## AC Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int INF = 1e9;
int dis[105][105];
int n, m;

int main() {
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == j) dis[i][j] = 0;
            else dis[i][j] = INF;
        }
    }
    
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        dis[a][b] = dis[b][a] = 1;
    }
    
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }
    
    int maxLen = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (dis[i][j] < INF) {
                maxLen = max(maxLen, dis[i][j]);
            }
        }
    }
    
    cout << maxLen << endl;
    
    return 0;
}
```

---

## 作者：Alvin0228 (赞：1)

### 题意描述

给出 $n$ 个环和 $m$ 个绳索，求选择任意两个环，被拉紧的绳索的最大值。

### 题目分析

由于所有边的边权都是 $1$，所以任意两个点拉紧之后，它们之间最多能拉紧的绳索数就是它们之间的最短路径。

题目让我们求任意两点间的最短路径的最大值，再看看这题的数据范围，跑一次 Floyd 显然可以。

[不会 Floyd 的看这里](https://www.luogu.com.cn/problem/B3647)

需要注意的是，由于我们跑了最短路，题目要求最长，所以最后我们还要求一个最大值。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int g[105][105];
int main ()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n,m;
	cin>>n>>m;
	memset(g,0x3f,sizeof(g));//注意初值
	for (int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		g[u][v]=g[v][u]=1;//边权设为1 
	}
	for (int k=1;k<=n;k++)
	{
		for (int i=1;i<=n;i++)
		{
			for (int j=1;j<=n;j++)
			{
				g[i][j]=min(g[i][j],g[i][k]+g[k][j]);//floyd求最短路 
			}
		}
	}
	int ans=0;
	for (int i=1;i<=n;i++) 
	{
		for (int j=1;j<=n;j++) 
		{
			ans=max(ans,g[i][j]);//统计最大值 
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：M_CI (赞：1)

### 简化题意

给定一个 $N$ 个点，$M$ 条边的图，求其中**最长的一条最短路径的长度**。

$N \leq 100$，$M \leq \frac{N\times(N-1)}{2}$

---

### 思路

先解释一下简化题意：

首先**最短路径**对应原题面的**拉紧**的绳索，因为两点之间**最短路径**只可能有如下两种情况：

1. 一段**拉紧**的较短绳索；

2. 一段**没拉紧**的较长绳索。

上述情况如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/k2q55mjk.png)

而**最长的一条最短路径的长度**，就是**最多的被拉紧的绳索数量**，因为每条绳索**长度相同**，所以每条边**边权相同**，设其为 $1$ 则求出的值即为题目要求的答案。

综上这题是一道多源最短路模板，观察数据特点（不限制边数）考虑 Floyd。

---

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,ans,f[110][110];

int main () {
    cin>> n>> m;
    memset (f,0x3f,sizeof (f));
    for (int i=1;i<=n;i++) f[i][i]=0;
    for (int i=1,a,b;i<=m;i++) {
        cin>> a>> b;
        f[a][b]=f[b][a]=1;
    }
    for (int k=1;k<=n;k++)
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
                if (f[i][j]>f[i][k]+f[k][j])
                    f[i][j]=f[i][k]+f[k][j];
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            ans=max (ans,f[i][j]);
    cout<< ans;
    return 0;
}
```

---

### 后记

图片由**画图3D**软件制作，但是这么好的软件将在 2024/11/4 在 Windows 停止支持，还是很可惜。

---

## 作者：nightwatch.ryan (赞：0)

### 思路
注意到本题需要使得被拉紧的绳索尽量的多，并且注意到本题 $n \leq 100$，显然这道题就是用 Floyd 做。

我们先跑一遍 Floyd 求最短路径，在本题中，所有边的边权都是 $1$，所以**每两个金属环之间最多能拉紧的绳索数就是他们之间的最短路径**。

Floyd 跑完之后，我们再对每两个金属环之间的最短路径求最大值。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

#define P(i, a, b) for(int i = a; i <= b; i++)
#define Q(i, a, b) for(int i = a; i >= b; i--)
const int maxn = 105;
const int inf = 0x3f3f3f3f;

mt19937 rnd(chrono::duration_cast<chrono::nanoseconds>
           (chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

int n, m, f[maxn][maxn], ans;

signed main(){

    cin.tie(0)->sync_with_stdio(0);
    P(i, 0, maxn - 1)
        P(j, 0, maxn - 1)
            f[i][j] = inf;
    cin >> n >> m;
    P(i, 1, m){
        int x, y;
        cin >> x >> y;
        f[x][y] = 1;
        f[y][x] = 1;
    }
    P(k, 1, n)
        P(i, 1, n)
            P(j, 1, n)
                if(i != j && j != k && i != k)
                    f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
    P(i, 1, n)
        P(j, 1, i - 1)
            ans = max(ans, f[i][j]);
    
    cout << ans << endl;
}
```

---


# 正整数拆分

## 题目描述

给定一个正整数 $N$，要求把 $N$ 拆分成若干个正整数相加的形式，参与加法运算的数可以重复。

**注意**:

  * 拆分方案不考虑顺序；
  * 至少拆分成 $2$ 个数的和。

求拆分的方案数 $\bmod 2147483648$ 的结果。

## 说明/提示

$1 \le N \le 4000$

## 样例 #1

### 输入

```
7```

### 输出

```
14```

# 题解

## 作者：_Punainen_ (赞：12)

## 思路
看到数字可以重复时，便容易想到使用完全背包。我们可以使 $f_i$ 表示当某个数为 $i$ 时总共的拆分方案的总数。则易得转移方程 $f_j = f_j + f_{j-i}$，即数字 $j$ 原本的总数加上数字 $j$ 拆分掉 $i$ 时的总数。此时注意到，$f_0$ 的值必为 $1$，因为 $f_0$ 代表一个数被拆分完的状态，即为一种答案。另外，记得输出之前将 $f_n$ 减去 $1$，因为不能将原数拆为原数加上 $0$。

***
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int f[114514],w[114514],c[114514];
signed main(){
	int n;
	cin>>n;
    f[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			f[j]=f[j]+f[j-i];
            f[j]%=2147483648;
		}
	}
    f[n]--;
	cout<<f[n]%2147483648;
    return 0;
}
```

---

## 作者：wabc30 (赞：6)

## 题目大意：
给定一个正整数 $n$，拆成若干个正整数相加的形式（至少两个）且数字可以重复，方案不考虑顺序（比如 $3$ 拆分成 $2$   $1$ 或 $1$   $2$ 的话算一种）。求方案总数模 $2147483648$  的结果。

## 分析
读完题后发现这是一道比较板的 DP 题，通过题意可以看出是完全背包。套一下计数 DP 的板子就可 AC，计数 DP 在这里不多讲，详细学习请看[OI Wiki](https://oi-wiki.org/dp/count/)。

数据范围 $1\le n\le 4000$，复杂度 $O(N^2)$ 就可以过。

## 代码


```cpp
#include <bits/stdc++.h>
#define int long long//注意开long long
using namespace std;
const int N=4010;
const int P=2147483648;
int dp[N];//dp数组
signed main() {
    int n;
    cin>>n;
    dp[0]=1;
    for (int i=1;i<=n;++i){
        for (int j=i;j<=n;++j){//完全背包
            dp[j]=(dp[j]+dp[j-i])%P;//状态转移方程
        }
    }
    cout<<dp[n]%P-1;//注意减一，毕竟至少拆成两个正整数，所以最终方案数比算出答案少一
    return 0;
}

```

---

## 作者：GONGX (赞：4)

### 题意简述
给定一个正整数 $N$,求有多少种方案可以将 $N$ 拆分为两个及以上的数相加的形式，且拆分的数可以重复。
### 解题思路
看到这道题后很容易想到动态规划，又因为每次拆分的数可以重复，所以我们可以考虑用完全背包求解。我们可以设 $dp_i$ 为数字 $i$ 拆分为任意个数相加的形式的方案数，我们可以注意到，将数字 $i$ 拆分为两个及以上的数相加的形式的方案数就是 $dp_i-1$。然后我们很容易想到枚举拆分数 $i$ 和大于等于 $i$ 的被拆分数 $j$，$dp_j$ 每次就加上拆分数字 $j-i$ 的方案总数，所以状态转移方程就是 $dp_j=dp_j+dp_{j-i}$。这道题就这么写完了，具体细节可以参考代码中的注释。
### 代码展示

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4002, mod = 2147483648;
int n;
long long f[N];//保险起见，防止爆 int 
int main() {//f_i : 数 i 拆分为任意个数相加的形式的方案总数
	ios::sync_with_stdio(0); //关闭同步流
	cin.tie(0), cout.tie(0); //等待时间设为零
	f[0] = 1; //注意将 f_0 初始化为 1 
	cin >> n;
	for (int i = 1; i <= n; i++) //枚举拆分数 
		for (int j = i; j <= n; j++) //枚举被拆分数 
			f[j] = (f[j] + f[j - i]) % mod; //状态转移 
	cout << f[n] - 1;//记得除去本身 
	return 0;
}
```

---

## 作者：canwen (赞：2)

## 分析
求方案数的完全背包，还写了挺久了。

定义 $f_{i}$ 表示数 $i$ 的拆分方案，$f_{0} = 1$ 表示数被拆分完后答案应该为 $1$。

容易发现二维的背包有重叠部分，就习惯性地打一维 dp。

我们可以外层循环枚举 $1$ 到 $n-1$，枚举每一个可以拆分的数，只到 $n-1$ 是因为至少要拆分成两个数。里层枚举每个大于 $i$ 的数字，不断更新该数字的方案。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 2147483648

int n,w[4001];

signed main(){
	cin>>n;
	w[0]=1;
	for(int j=1;j<n;j++){
		for(int i=j;i<=n;i++)
		{
			w[i]+=w[i-j];
            w[i]%=mod;
		}
	}
	cout<<w[n]<<endl;
	
	return 0;
}
```

---

## 作者：zhoujunchen (赞：2)

思路1
---
直接爆搜，期望得 $20$ 分。

code:


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5006],ans;
void dfs(int x,int s,int sum){
    if(sum==n){
        if(s==n)return;
        ans++;
        return;
    }
    for(int i=s;sum+i<=n;i++){
        a[x]=i;
        dfs(x+1,i,sum+i);
        a[x]=0;
    }
}
int main(){
    cin>>n;
    dfs(1,1,0);
    cout<<ans;
    return 0;
}
```

思路2
--
完全背包。

定义 $dp_{i,j}$ 为选前 $i$ 个数，体积恰好为 $j$ 的方案数。

则状态转移方程为 $dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-i}$。

空间优化，我们每次求 $dp_{i,j}$ 时，只会用到 $i-1$，所以可以把第一维省去。

code:


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=2147483648; 
int dp[4005],n;
signed main(){
    cin>>n;
    dp[0]=1; 
    for(int i=1;i<n;i++)
    	for(int j=i;j<=n;j++)
    		dp[j]=(dp[j]+dp[j-i])%mod;
    cout<<dp[n];
    return 0;
}
```

---

## 作者：JYX0924 (赞：1)

一道简单的动态规划题。

令 $dp_{i}$ 表示拆分 $i$ 的方案数，显然 $dp_{j}$ 可以从 $dp_{j-i}$ 转移。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
#define maxn 4005 
#define mod 2147483648 
using namespace std;
ll n,dp[maxn];
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n; dp[0]=1;
	for(int i=1;i<=n;i++) for(int j=i;j<=n;j++) dp[j]=(dp[j]+dp[j-i])%mod;
	cout<<dp[n]-1;
	return 0;
}
```
谢谢大家！！！

---

## 作者：yechenguo (赞：0)

本题为 dp 计数问题。

这道题的思想是先把自己的一种方案加上，最后减去，因为这样在做状态转移方程式时方便，其实真的没什么好说的，那就来说说初始化和状态转移方程式吧！

首先，初始化是 $0$ 的方案数是 $1$ 种，就是他自己。

状态转移方程是加上这个数可以凑出比它小的数的个数。

最后上代码！！！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,dp[4005];
signed main()
{
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			dp[j]+=dp[j-i],dp[j]%=2147483648;
	cout<<dp[n]-1;
 	return 0;
}
`````

---

## 作者：i_wzy (赞：0)

## 题目链接：[正整数拆分](https://www.luogu.com.cn/problem/P10955)
## 题目思路：
因为每个数字可以重复使用，所以显然这是一道**完全背包问题**。

那么动态转移方程为：
 $f_j \leftarrow f_j + f_{j-i}$，
 所以这道题就解决了。
 
 ## 附上 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//十年OI一场空，不开long long见祖宗。
const int mod=2147483648;
ll n,f[5050];
int main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	f[0]=1;//初始化。
	for(ll i=1;i<n;i++)
		for(ll j=i;j<=n;j++)
			f[j]=(f[j]+f[j-i])%mod;//记得取余。
	cout<<f[n];
	return 0;//完结撒花！
}
```

---

## 作者：GeXiaoWei (赞：0)

# P10955 正整数拆分
## 解析
本题属于完全背包的变形。

令 $dp_i$ 表示数字 $i$ 的拆分总数，则容易得状态转移方程 $dp_i=dp_i+dp_{j-i}$，即 $dp_i$ 的方案数加上由 $dp_{j-i}$ 得到的方案数。

但要注意，$dp_0$ 的值为一，因为它代表一个数被拆分完的要求把拆分成若干个正整数相加的形式状态，即为一种答案。但要将所求的 $dp_n$ 减一，因为题目要求将 $n$ 拆分成若干个正整数相加的形式，$0$ 不是正整数。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=2147483648;
long long dp[4005],n;
int main(){
    scanf("%lld",&n);dp[0]=1;
    for(int i=1;i<=n;i++) for(int j=i;j<=n;j++) dp[j]=(dp[j]+dp[j-i])%mod;
	printf("%lld",dp[n]-1);
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P10955 题解

## 思路

完全背包，设 $f_{i,j}$ 为到了 $i$ 这个正整数，凑出 $j$ 的方案数，可以列出状态转移方程 $f_{i,j}=f_{i-1,j}+f_{i-1,j-i}$，发现每一个 $i$ 只与 $i-1$ 有关，就可以把第一维去掉，优化一下。

枚举 $i$ 只能到 $n-1$，因为至少需要 $2$ 个正整数组成，不能只拿一个 $n$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

#define _rep(i,a,b) for (int i=(a);i<=(b);++i)

const int N=4005;
const int mod=2147483648;

int n;
int f[N];

signed main() {
    scanf("%d",&n);
    f[0]=1;
    _rep(i,1,n-1) _rep(j,i,n) f[j]=(f[j]+f[j-i])%mod;
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：Decepticon (赞：0)

### 题目链接
[P10955 正整数拆分](https://www.luogu.com.cn/problem/P10955)

### 题目分析

**参与加法的数可以有重复** 说明本题是一道完全背包板子题。

所以十分容易得到 $dp_i \gets dp_j + dp_{j-i}$。

因为 $dp_0$ 代表一个正整数被拆分完毕。所以 $dp_0 = 1$。

算出 $dp_n$ 的值后，需要输出 $dp_n - 1$，因为正整数 $n$ 不能拆分成 $n + 0$。

记得开 $\text{long long}$ 呦。

### $\text{Code}$


```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,dp[4005],mod = 2147483648;

int main(){
    cin >> n;
    dp[0] = 1;
    for(int i = 1; i <= n; i++)
        for(int j = i; j <= n; j++)
            dp[j] = (dp[j]+dp[j-i]) % mod;
    cout << (dp[n]-1) % mod;
    return 0;
}
```

---

## 作者：__qkj__ (赞：0)

## 解题思路
完全背包求方案数模板题。

第一重循环 $i$ 从 $1$ 到 $n$，枚举拆分的数。

第二重循环 $j$ 从 $i$ 到 $n$，枚举当前的转移的位置。

再 $f_j\gets f_j+f_{j-i}$，表示累加 $j$ 拆分成 $i$ 和 $j-i$ 的方案数。

最后 $f_n$ 要减一，因为至少拆分成 $2$ 个数的和。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int f[4010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	f[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			(f[j]+=f[j-i])%=2147483648;
	cout<<(f[n]+2147483647)%2147483648;
	//当 f[n]=0 时，减一会变成 -1，所以输出 (f[n]-1+2147483648)%2147483648
	return 0;
}

```

---

## 作者：lcfollower (赞：0)

设 $dp_{i,j}$ 表示前 $i$ 个数能够凑出 $j$ 的方案数，则有 $dp_{i,j} = dp_{i - 1 ,j} + \sum\limits_{k=1}^{\lfloor\frac{j}{i}\rfloor} dp_{i - 1, j - k\times i}$。

但是这样转移是 $\mathcal O(n^3)$，无法通过 $n\le 4000$ 的所有数据，考虑优化。

关键：我们尝试把 $dp_{i,j}$ 以及 $dp_{i,j-i}$ 的转移式对比：

```
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - i] + dp[i - 1][j - 2i] + dp[i - 1][j - 3i] + ...
dp[i][j - i] =            dp[i - 1][j - i] _ dp[i - 1][j - 2i] + dp[i - 1][j - 3i] + ...
dp[i][j] = dp[i - 1][j] + dp[i][j - i]
```

这样我们就得到了 $dp_{i ,j} = dp_{i - 1 ,j} + dp_{i ,j - i}$，这样时间复杂度就变成 $\mathcal O(n^2)$ 了。

然后我们嫌空间复杂度太高为 $\mathcal O(n^2)$，因此消除第一维，因为它只涉及到 $i$ 与 $i - 1$。

这样就是一个完全背包计数板子。

```cpp
# include <bits/stdc++.h>

# define int long long
# define rint register int

using namespace std;

const int N = 4005 ,p = 2147483648;
int n ,dp[N];

signed main(){
  scanf("%lld" ,&n);
  dp[0] = 1;//初始化，否则所有 dp[i] = 0。
  for(rint i = 1;i <= n;i ++)
    for(rint j = i ;j <= n; j ++)//j 顺序枚举能保证 dp[j - i]（上述的 dp[i][j - i]）已经更新过。
      dp[j] = (dp[j] + dp[j - i]) % p;//dp[j - i] 已经更新过，即为 dp[i][j - i]；而 dp[j] 待更新，即为 dp[i - 1][j]。这样保证了 dp 式的正确性。
  printf("%lld\n" ,(dp[n] - 1 + p) % p); //最后记得减去 1，即排除为 n = n 的拆分；当然也可以把上面的 i <= n 改为 i < n。
  return 0;
}
```

---


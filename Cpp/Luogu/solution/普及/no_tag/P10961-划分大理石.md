# 划分大理石

## 题目描述

有价值分别为 $1,2,\dots,6$ 的大理石各 $a_1,a_2,\dots,a_6$ 块，现要将它们分成两部分，使得两部分价值之和相等，问是否可以实现。其中大理石的总数不超过 $20000$。 

## 样例 #1

### 输入

```
4 7 4 5 9 1
9 8 1 7 2 4
6 6 8 5 9 2
1 6 6 1 0 7
5 9 3 8 8 4
0 0 0 0 0 0```

### 输出

```
Can't
Can
Can't
Can't
Can```

# 题解

## 作者：ycy1124 (赞：9)

### 题意
有 $a_1,a_2,a_3,a_4,a_5,a_6$ 块大小分别为 $1,2,3,4,5,6$ 的砖，问能否将其分成两部分并且大小之和相等。
### 思路
设总大小为 $sum$，那么只要能取出 $sum \div 2$ 大小的就一定可以，假如 $sum$ 不是偶数就可以直接输出 ```Can't``` 了。

对于 $sum$ 是偶数的，先将 $a_1,a_2,a_3,a_4,a_5,a_6$ 二进制拆分（拆分后一定可以反过来凑出 $1 \sim a_i$ 之间所有的整数，证明很简单，这里就不证了），然后直接 $01$ 背包就可以了。这里的 $dp_i$ 表示的是取出大小之和为 $i$ 的方案是否存在，最初时 $dp_0=1$。转移方程也很好想 $dp_i$ 明显只能由 $dp_{i-w_j}$ 得到（$1 \le j \le tot$ 且 $w_j \le i$），$w_j$ 表示的是第 $j$ 个物品的价值，$tot$ 表示的是物品总数。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[7];
int w[20001];
bool dp[210001];
int main(){
	int tot;
	while(scanf("%d%d%d%d%d%d",&a[1],&a[2],&a[3],&a[4],&a[5],&a[6])){
		if((a[1]+a[3]+a[5])%2!=0){//不是偶数就直接输出Can't
			printf("Can't\n");
			continue;
		}
		memset(dp,0,sizeof(dp));//多测清空
		tot=0;
		if(a[1]==0&&a[2]==0&&a[3]==0&&a[4]==0&&a[5]==0&&a[6]==0){
			return 0;
		}
		int js=(a[1]+a[2]*2+a[3]*3+a[4]*4+a[5]*5+a[6]*6)/2;//计算sum/2
		for(int i=1;i<=6;i++){
			int base=1;
			while(base<=a[i]){//二进制拆分
				a[i]-=base;
				w[++tot]=base*i;//体积和价值也等比例放大
				base*=2;
			}
			if(a[i]!=0){//这里别忘记把多余的加进去
				w[++tot]=a[i]*i;
			}
		}
		dp[0]=1;
		for(int i=1;i<=tot;i++){//完全背包
			for(int j=js;j>=w[i];j--){//遍历顺序别反了
				if(dp[j-w[i]]){
					dp[j]=1;
				}
			}
		}
		if(dp[js]){//假如sum/2可以
			printf("Can\n");
		}
		else{
			printf("Can't\n");
		}
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/177614122)。

---

## 作者：xuchenxi (赞：4)

### P10961题解

[题目传送门](https://www.luogu.com.cn/problem/P10961)

很明显是一道多重背包问题，唯一的问题就是直接写会超时。

那么我们如何改进呢？可以使用二进制分组。

例如：价值为 $i$ 的大理石有 $23$ 块，我们就把原来的 $23$ 块大理石拆成 $1$ 块、$2$ 块、$4$ 块、$8$ 块、$8$  块。这样拿的时候如果我想拿 $j$ 块就可以从原来分好的 $5$ 组中拿出 $k$ 组凑出 $j$ 块。

看[这道题](https://www.luogu.com.cn/problem/P1776)，可以帮助你更了解二进制拆分。

注意：多测要清空！！！

二进制拆分代码实现

```
for(int i=1;i<=6;i++){
        for(int j=1;j<=a[i];j<<=1) {
            v[++cnt]=j*i;
            a[i]-=j;
        }
        if(a[i]) v[++cnt]=a[i]*i;
    }
```

AC Code ~~我知道你们只看这~~


```
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000005;
int a[10],v[2500],dp[maxn];
bool f() {
    //多测清空
    memset(dp,0,sizeof(dp));
    int ans=0,cnt=0;
    for(int i=1;i<=6;i++) ans+=a[i]*i;
    if(ans%2==1) return false;
	ans/=2;
    //二进制拆分
    for(int i=1;i<=6;i++){
        for(int j=1;j<=a[i];j<<=1) {
            v[++cnt]=j*i;
            a[i]-=j;
        }
    if(a[i]) v[++cnt]=a[i]*i;
    }
    //朴素多重背包
    dp[0]=1;
    for(int i=1;i<=cnt;i++) {
		for(int j=ans;j>=v[i];j--) {
			if(dp[j-v[i]]) dp[j]=1;
		}
	}
	return dp[ans];
}
int main() {
	while(cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6]) {
		if(a[1]==0 && a[2]==0 && a[3]==0 && a[4]==0 && a[5]==0 && a[6]==0)
			break;
		if(f())cout<<"Can" <<endl;
		else cout<<"Can't" <<endl;
	}
	return 0;
}
```

---

## 作者：Rainbow_SYX (赞：2)

# 题意
很明显，这是一道多重背包&动态规划的练习题，并主要以背包为主。

~~题意过于简单，应该不会有人不懂吧？~~
# 思路
先求出所有大理石的价值之和 $s$，若 $s$ 为奇数，那么别想了，肯定不能分成两半，直接输出 `Can't` 便可。

如果 $s$ 是偶数，直接背包就会时间超限。所以我们要对 $a_1,a_2,a_3,a_4,a_5,a_6$ 进行二进制分解，分解完毕后我们直接 $01$ 背包，判断它能否正好取到总价值的一半。状态转移方程也很好想，最初 $dp_0=1$。随后的 $dp_j$ 就只能由 $dp_{j-{c_i}}$ 得到了。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10],c[100005],s,t,cnt;//c[i]代表的是价值 
bool dp[100005];
int main()
{
	while(cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6])//while读入 
	{
		memset(dp,0,sizeof(dp));s=0;//归0清空
		//s计算总价值 
		for(int i=1;i<=6;i++) s+=i*a[i];
		if(s%2!=0)
		{
			cout<<"Can't"<<endl;
			continue;//跳过这一次循环 
		}
		if(s==0) return 0;//结束 
		s/=2;cnt=0;//cnt是一个下标
		//s/2求一半 
		for(int i=1;i<=6;i++)
		{
			t=1;
			while(t<=a[i])
			{
				a[i]-=t;
				c[++cnt]=t*i;
				t*=2;
			}
			if(a[i]!=0) c[++cnt]=a[i]*i;
		}//二进制分解 
		dp[0]=1;
		for(int i=1;i<=cnt;i++)
			for(int j=s;j>=c[i];j--)
				if(dp[j-c[i]]==1) dp[j]=1;//动态转移方程 
		//背包模板 
		if(dp[s]==1) cout<<"Can"<<endl;//能取到就输出Can
		else cout<<"Can't"<<endl;//不能就输出Can't
	}
	return 0;//养成良好习惯	
}
```
本蒟蒻的第二篇题解，如有不足之处请指出，谢谢。

---

## 作者：封禁用户 (赞：2)

~~一道多重背包水题~~  
### 思路

一道多重背包&刚好装满的简单背包问题。  
先求大理石价值之和 $c$，若 $c$ 为奇数，则不可能组合出两对相同的价值和，直接输出 ```Can't```，然后跳过即可。  
然后直接套多重背包和刚好装满的板子就行了。
### 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define deap(i,a,b) for(int i=a;i>=b;i--)
#define in(a) a=read()
#define end() printf("\n")
#define rad(a,l,r) a=rand()%(r-l+1)+l,printf("%lld ",a)
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
const int maxn=1e6+5;
int dp[maxn];
vector<int>w;
signed main() {
	int a[10];
	while(1) {
		int c=0;
		rep(i,1,6)in(a[i]),c+=a[i]*i;
		if(!c)return 0;
		if(c&1) {
			cout<<"Can't\n";
			continue;
		}
		c>>=1;
		memset(dp,0,sizeof(dp));
		w.clear();
		dp[0]=1;
		rep(i,1,6) {
			int z=a[i];
			for(int k=1; k<=z; k*=2) {
				w.push_back(i*k);
				z-=k;
			}
			if(z>0)w.push_back(i*z);
		}
		for(auto v:w) {
			deap(j,c,v)dp[j]=max(dp[j-v],dp[j]);
		}
		if(dp[c])cout<<"Can\n";
		else cout<<"Can't\n";
	}
	return 0;
}

```

---

## 作者：BXZS16 (赞：2)

**[题目传送门](https://www.luogu.com.cn/problem/P10961)**

这道题是不错的背包练习题，推荐像我这样的蒟蒻来写。

题意很明白了，在此不赘述。

## 思路讲解
首先一个特判：当价值总和不是**偶数**，直接 `cout<<"Can't"`。

通过观察，可以很快发现这是一道背包 DP 题，而且还是 01 背包的变式——多重背包，不过与常规模板不同的是，这里只需要判断是否可以取到即可，所以我们可以将 $dp$ 数组定义为**布尔型**，$dp_i$ 表示价值 $i$ 能否取到。

考虑转移，可以发现，$dp_i$ 的状态只能由 $dp_{i-w_i}$ 转移而来（$w_i$ 为当前枚举到的物品价值），容易发现当 $dp_{i-w_i}$ 与 $dp_i$ 任意一者为真，$dp_i$ 即为真，所以可以使用或运算作为转移。

而初始状态就是 $dp_0$ 为真。

### My code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10],sum,num,w[120005],id;
bool dp[120005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	while(true){
		sum=0;
		for(int i=1;i<=6;cin>>a[i],sum+=a[i]*i,i++);//计算价值总和
		num=sum>>1,id=0;//计算出要得到的价值，因为只要总价值的一半可以取到，另一半也一定可以取得到。
		fill(dp,dp+120005,false);//初始化。
		if(sum==0)break;//若价值为0，即输入均为0。
		if(sum&1)//特判。
			cout<<"Can't\n"; 
		else{
			for(int i=1;i<=6;i++)
				for(int j=1;j<=a[i];j++)w[++id]=i;//预处理w数组。
			dp[0]=true;//初始状态。
			for(int i=1;i<=id;i++)
				for(int j=num;j>=w[i];j--)
					dp[j]|=dp[j-w[i]];//背包模板，转移使用|运算（或）。
			if(dp[num])cout<<"Can\n";
			else cout<<"Can't\n";//输出。
		}
	}
	return 0;//华丽结束。
}
```
但是，当你提交上去之后会惊讶的发现：

Subtask 2 全 **TLE** 了！！

那怎么办呢？这时候就要用二进制优化大法了！！（dalao 们可以用状态压缩。）

### 优化原理：
我们知道，任意一个数都可以表示为二进制数。

那换句话说，是不是二进制可以构成任意数？

所以，我们可以将一个数使用二进制各位权值之和表示，存进 $w$ 数组里，这样就可以减少枚举的次数，于是就不会超时了！！！

### AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10],sum,num,w[120005],id;
bool dp[120005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	while(true){
		sum=0;
		fill(dp,dp+120005,false);
		for(int i=1;i<=6;cin>>a[i],sum+=a[i]*i,i++);
		if(sum==0)break;
		num=sum>>1,id=0;
		if(sum&1){
			cout<<"Can't\n";
			continue;
		}
		for(int i=1;i<=6;i++){
			int temp=0;
			for(int j=1;(j<<1)<=a[i];j<<=1)w[++id]=i*j,temp+=j;//二进制优化。
			w[++id]=i*(a[i]-temp);//万一有剩余的，再存进去。
		}
		dp[0]=true;
		for(int i=1;i<=id;i++)
			for(int j=num;j>=w[i];j--)
			dp[j]|=dp[j-w[i]];
		if(dp[num])cout<<"Can\n";
		else cout<<"Can't\n";
	}//其他同上。
	return 0;
}
```

---

## 作者：mirance2025 (赞：2)

## 题意分析
如果存在合法的划分方案，那么总价值必然为偶数。

于是考虑在这些大理石中判断是否存在价值和为总价值一半的情况。

考虑 DP。

### 多重背包
状态表示：$f_{i,j}$ 表示取 $i$ 个大理石，能否取到总价值 $j$。

状态计算：$f_{i, j} = f_{i - 1, j} \operatorname{|} f_{i - 1, j - v_i}$。

看到数据范围，考虑二进制分组优化，然后再将数组降一维。

得到最终的转移方程：$f_j = f_j \operatorname{|} f_{j - v_i}$。

代码中 $v_i = i \times k$。 

## 代码

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 60010;
bool f[N];
int a[10];
int main(){
    while (true){
        int m = 0;
        for (int i = 1; i <= 6; i ++ ){
            scanf("%d", &a[i]);
            m += a[i] * i;
        }
        if (!m) break;
        if (m % 2 == 1) cout << "Can't" << endl;
        else{
            m /= 2;
            memset(f, 0, sizeof f);
            f[0] = true;
            for (int i = 1; i <= 6; i ++ ){
                int s = a[i], k = 1;
                while (s >= k){
                    //二进制分组优化
                    // v: i * k
                    for (int j = m; j >= i * k; j -- ) f[j] = f[j - i * k] | f[j];
                    s -= k;
                    k *= 2;
                }
                if (s > 0)
                    for (int j = m; j >= i * s; j -- ) f[j] = f[j - i * s] | f[j];
            }
            if (f[m]) puts("Can");
            else puts("Can't");
        }
    }
    return 0;
}
```

---

## 作者：littlep001 (赞：2)

### 思路
因为石子种类的数量是固定的，为 $ 6 $ 种。那么我们先算出平均分成 $ 2 $ 堆后每堆的价值，然后暴力枚举，枚举所有可以选的情况，看看可不可以构造出来，再加上一些剪枝即可。

- 第一个剪枝：如果当前选的价值已经超过了我们要分出的价值，剪枝
- 第二个剪枝：如果枚举到当前，再加上左右剩下的价值还是不够，剪枝

有了这两个剪枝，我们就有五重循环的代码了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10],sum[10],cnt[10];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
	for(int i=1;i<=6;i++)
	{
		cin>>a[i];
	}
    while(a[1]!=0||a[2]!=0||a[3]!=0||a[4]!=0||a[5]!=0||a[6]!=0)
    {
        for(int i=1;i<=6;i++)
        {
            sum[i]=sum[i-1]+i*a[i];
        }
        if(sum[6]%2==1)
        {
            cout<<"Can't\n";
            for(int i=1;i<=6;i++)
			{
				cin>>a[i];
			}
            continue; 
        }
        int tmp=sum[6]/2;
        bool flag=false;
        for(int i=min(a[6],tmp/6);i>=0&&!flag;i--)
        {
            cnt[6]=6*i;
            if(cnt[6]+sum[5]<tmp)
            {
                break;
            }
            for(int j=min(a[5],(tmp-cnt[6])/5);j>=0&&!flag;j--)
            {
                cnt[5]=cnt[6]+5*j;
                if(cnt[5]+sum[4]<tmp)
                {
                    break;
                }
                for(int k=min(a[4],(tmp-cnt[5])/4);k>=0&&!flag;k--)
                {
                    cnt[4]=cnt[5]+4*k;
                    if(cnt[4]+sum[3]<tmp)
                    {
                        break;
                    }
                    for(int p=min(a[3],(tmp-cnt[4])/3);p>=0&&!flag;p--)
                    {
                        cnt[3]=cnt[4]+3*p;
                        if(cnt[3]+sum[2]<tmp)
                        {
                            break;
                        }
                        for(int q=min(a[2],(tmp-cnt[3])/2);q>=0&&!flag;q--)
                        {
                            cnt[2]=cnt[3]+2*q;
                            if(cnt[2]+sum[1]<tmp)
                            {
                                break;
                            }
                            flag=true;
                        }
                    }
                }
            }
        }
        if(flag)
        {
            cout<<"Can\n";
        }else
        {
            cout<<"Can't\n";
        }
        for(int i=1;i<=6;i++)
		{
			cin>>a[i];
		}
    }
    return 0;
}
```
最后感谢您~~耐着性子~~看到这里qwq

---

## 作者：xuchuhan (赞：2)

## 前言

听说可以五重循环优化就写了一个五重循环，结果写挂了，遂老老实实写背包。

## 解法

观察即可发现本题是多重背包题，只是把传统的最大价值改成了是否可以得到某个价值的问题，不过本质相同。也就是把常规的 `dp[j]=max(dp[j],dp[j-w[i]]+v[i])` 改为了 `dp[j]|=dp[j-w[i]];`，初始时有 $dp_{0}=1$。

但是，直接写常规的多重背包是不可行的。可以自己试试，只能拿 50 分，sub#1 会全 T。

那么我们只能祭出杀器：多重背包的二进制优化。

我们需要一个前提：任意一个正整数都可以分拆成若干个 $2$ 的幂次方之和，例如 $11=2^3+2^1+2^0$。知道它以后，多重背包的二进制优化的方法就出来了。

当物品数为 $C_i$ 时，常规的方法是是一个一个从 $0$ 到 $C_i$ 枚举放入背包的物品数量；而现在，我们不一个一个枚举，我们将一种总数量为 $C_i$ 的物品拆成 $p+2$ 个物品，体积分别为 $2^0\times V_i,2^1\times V_i,\dots,2^p\times V_i,(C_i-2^0-2^1-\dots-2^p)\times V_i$。那么 $[0,C_i]$ 中任何一种物品数都可以通过这 $p+2$ 个物品选或不选的组合表示出来。与此同时，我们也用 $\log$ 级别的时间将多重背包问题转化为了 0/1 背包的问题。

最后，我们令 $sum$ 等于所有物品的价值之和。若 $sum$ 是奇数，则无论如何无法均分，直接输 `Can't`。不然则通过上文的判断方法用 DP 判断是否可以凑出 $\dfrac{sum}{2}$ 的价值，若可以，则能均分，输出 `Can`；否则不可以，输出 `Can't`。

上代码理解一下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int cnt;
int a[7],w[N];
bool dp[N];
void OP(int op){//第op种物品 
	for(int i=1;i<=a[op];i*=2)
		w[++cnt]=i*op,a[op]-=i;//二进制拆分出物品 
	w[++cnt]=a[op]*op;
	return;
}
signed main(){
    while(1){
    	cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];
    	if(!(a[1]|a[2]|a[3]|a[4]|a[5]|a[6]))//退出 
    		break;
    	int sum=a[1]+a[2]*2+a[3]*3+a[4]*4+a[5]*5+a[6]*6;//总价值 
    	if(sum%2){cout<<"Can't\n";continue;}//一定不行 
    	memset(dp,0,sizeof(dp));
    	cnt=0,dp[0]=1;
    	OP(1),OP(2),OP(3),OP(4),OP(5),OP(6);//处理多重背包->0/1背包 
    	for(int i=1;i<=cnt;i++)
    		for(int j=sum/2;j>=w[i];j--)
    			dp[j]|=dp[j-w[i]];//判断型0/1背包 
    	if(dp[sum/2])
			cout<<"Can\n";
    	else
			cout<<"Can't\n";
	}
    return 0;
}
```

## 后记

写背包的时间比写五重循环的时间还少，代码也短，有点讽刺。

---

## 作者：MafuyuQWQ (赞：1)

## 题意

> 有 $ 6 $ 种价值为 $ 1 \sim 6 $ 的大理石各 $ a_{1 \sim 6} $ 块，现在询问是否能分为相等价值的两份。

## Solution

这题其实不那么容易能想到 DP，DP 的构造也十分巧妙。

我们发现当一种划分方案，如果能成功的话，那么总价值一定是偶数。

于是我们只要考虑在所有大理石中是否能取到总价值的一半即可。

设 $ f_{i,j} $ 表示取 $ i $ 个大理石，能否取到价值 $ j $。

不难发现这是个多重背包，暴力做是过不了的。

惯用手段是用二进制优化，将其转化为 01 背包，这样可以将时间复杂度进一步优化。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 400010;

int n, m;
int v[N], a[10];
bool f[N];

int main()
{
    while (cin >> a[1] >> a[2] >> a[3] >> a[4] >> a[5] >> a[6])//多组数据
    {
        if (!a[1] && !a[2] && !a[3] && !a[4] && !a[5] && !a[6]) break;
        
        int cnt = 0;
        m = 0;
        for (int i = 1; i <= 6; i ++ )
        {
            m += a[i] * i;
            int s = 1;
            while (s <= a[i])//二进制拆分
            {
                v[ ++ cnt] = s * i;
                a[i] -= s;
                s *= 2;
            }
            if (a[i]) v[ ++ cnt] = a[i] * i;
        }
        if (m & 1) 
        {
            cout << "Can't\n";//如果总价值为奇数，那么肯定不可能
            continue;
        }
        m /= 2;
        n = cnt;
        memset(f, false, sizeof f);//初始化
        f[0] = true;
        
        for (int i = 1; i <= n; i ++ )
            for (int j = m; j >= v[i]; j -- )
                f[j] |= f[j - v[i]];//0/1背包
        
        if (f[m]) cout << "Can\n";
        else cout << "Can't\n";//答案
    }
    
    return 0;
}
```
其实这题还有加强版，增大了数据范围，且要求输出划分方案，感兴趣可以略作尝试。

---

## 作者：TernaryTree (赞：1)

题意：判断均分集合。还在使用传统的二进制分组/单调队列优化多重背包？事实上，均分集合是存在更加优秀（存疑？）**好写**的做法的。

有兴趣的话可以去阅读我的 P9498 官方题解。这篇题解证明了这样一件事情：若集合里的最大值为 $m$，且 $[1,m]$ 内的所有整数都在集合里出现过，那么这样的集合有解当且仅当集合的和为偶数。那么这个可以判掉大部分情况，通过 sub0。

抛开前面的做法，考虑这样一件事情，将序列拿出来，贪心从左往右选，如果选到一个前缀的和恰好是一半那么显然是 `Can't`。这样显然是假的。

然而，我们充分发扬人类智慧，将序列 `random_shuffle` $25\sim 30$ 次进行判断，若不存在解则输出 `Can't`。感性理解，每次判断的正确率还是相当高的。

于是我们可以使用不到 $300$B 的代码解决这道题。

```cpp
#import<bits/stdc++.h>
int b[1<<20],n,s,t,f,x,i,g,T;
main(){for(;;){
n=s=g=0,T=25;for(i=1;i<=6;i++){scanf("%d",&x),s+=x*i;while(x--)b[++n]=i;}if(!s)break;
for(;T--;){std::random_shuffle(b+1,b+1+n);t=f=0;for(i=n;i;i--){t+=b[i];if(t*2==s)f=i=1;}T*=!(g=f);}
puts(g?"Can":"Can't");
}}
```

---

## 作者：never_knew (赞：0)

六种价值，六种数量，一种背包，叫多重背包。

我们把多重背包强制分开成个体，按普通背包处理。

但是太慢了，我们知道二进制能表示所有数，将他的个数拆成二的非负数次幂。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[7];
int v[200000];
bool dp[200000];
signed main()
{
	while(cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6]&&(a[1]||a[2]||a[3]||a[4]||a[5]||a[6]))
	{
	    memset(dp,0,sizeof(dp));
		int sum=a[1]+a[2]*2+a[3]*3+a[4]*4+a[5]*5+a[6]*6;
		if(sum&1)
		{
			cout<<"Can't\n";
			continue;
		}
		int tt=0;
		for(int i=1;i<=6;i++)
		{
			int mul=1;
			while(mul<=a[i])
			{
				v[++tt]=i*mul;
				a[i]-=mul;
				mul*=2;
			}
	        if(a[i]!=0)
	        {
	            v[++tt]=i*a[i];
	        }
		}
		dp[0]=1;
		sum/=2;
		for(int i=1;i<=tt;i++)
		{
			for(int j=sum;j>=v[i];j--)
			{
				dp[j]|=dp[j-v[i]];
			}
		}
		if(dp[sum]) cout<<"Can\n";
		else cout<<"Can't\n";
	}
	return 0;
}
```

---

## 作者：cly312 (赞：0)

设 $f_x$ 表示拼成 $x$ 后，当前的大理石最多还能剩下几块，不能拼成就是 $-1$。

状态转移（当前考虑的大理石价值为 $i$，有 $x$ 块）：

$f_j=x(f_j\ge0)$ 本来就可以拼成，那么现在的大理石都可以剩下。

$f_j=f_{j-i}-1(f_j=-1,j\ge i,f_{j-i}>0)$ 本来不能拼成，但用了一块就能拼成了。

$f_j=-1$ 除了上述两种情况，都不能拼成。

最后时间复杂度为 $O(m)$。$m$ 是可能的最大价值（这里就是 $20000\times6=120000$）。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define MAXN 120011
ll f[MAXN],x;
int main() {
	while(1) {
		memset(f,-1,sizeof f);
		f[0]=0;
		ll sum=0;
		for(ll i=1; i<=6; ++i) {
			cin>>x;
			sum+=x*i;
			for(ll j=0; j<MAXN; ++j) {
				if(f[j]>=0)f[j]=x;
				else if(j>=i&&f[j-i]>0)f[j]=f[j-i]-1;
				else f[j]=-1;
			}
		}
		if(!sum)break;
		puts(!(sum&1)&&f[sum>>1]>=0?"Can":"Can't");
	}
	return 0;
}
```

---

## 作者：cute_overmind (赞：0)

### 题目大意
有六种价值分别为 $1,2 \dots,6$ 的石头 $a_1,a_2 \dots ,a_6$ 块，询问能否分成两组价值一样的石头。
### 题目分析
使用多重背包。

不难想到要用二进制优化，然后变成 01 背包求解。

因为要分成两个价值一样的，所以每个值一定是偶数。即我们只需要考虑所有大理石中是否能取到总价值的一半。

代码时间复杂度 $O(W \sum_{i=1}^{n} \log_2 k_i)$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
const int N = 1e6 + 10;
int n , m;
int v[N], a[10];
bool dp[N];
void solve(){
	int cnt = 0 , m = 0;
    for(int i = 1;i <= 6;i++)
    {
        m += a[i] * i;
        int s = 1;
        while(s <= a[i])
        {
            v[++cnt] = s * i;
            a[i] -= s;
            s *= 2;
        }
        if(a[i]) v[++cnt] = a[i] * i;
    }
    if(m % 2) 
    {
        cout << "Can't\n";
        return ;
    }
    m /= 2 , n = cnt;
    memset(dp , false , sizeof dp);
    dp[0] = true;
    for(int i = 1;i <= n;i++)
        for(int j = m;j >= v[i];j--)
            dp[j] |= dp[j - v[i]];
    if(dp[m]) cout << "Can\n";
    else cout << "Can't\n";
}
signed main()
{
    while(cin >> a[1] >> a[2] >> a[3] >> a[4] >> a[5] >> a[6])
    {
        if(!a[1] && !a[2] && !a[3] && !a[4] && !a[5] && !a[6]) break;
        solve(); 
    }
    return 0;
}
```

---


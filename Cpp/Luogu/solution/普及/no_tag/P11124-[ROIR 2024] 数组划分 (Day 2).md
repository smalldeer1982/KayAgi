# [ROIR 2024] 数组划分 (Day 2)

## 题目背景

翻译自 [ROIR 2024 D2T1](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day2.pdf)。

## 题目描述

给定一个数组 $A = [a_1, a_2, \dots, a_n]$，其中包含 $n$ 个正整数。

需要将数组元素涂成两种颜色，使得任意两个同一颜色的元素 $x$ 和 $y$ 不满足以下条件：
- $x=p\times y$，其中 $p$ 是一个素数。

保证存在这样的涂色方案。

## 说明/提示

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
| $1$ | $9$ | $a_i\le2$ |
| $2$ | $19$ | $a_i=p^k$，其中 $p$ 是素数 |
| $3$ | $12$ | $a_i\le3$ |
| $4$ | $13$ | $a_i\le4$ |
| $5$ | $21$ | $n\le10$ |
| $6$ | $26$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 100000$，$1 \leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
2 1 1 2```

## 样例 #2

### 输入

```
1
20```

### 输出

```
1```

# 题解

## 作者：cff_0102 (赞：6)

注意到若 $x=p\times y$，则 $x$ 和 $y$ 的质因数个数必然相差一。任意两个同一颜色的元素 $x$ 和 $y$ 不能满足这个条件，即任意两个同一颜色的元素 $x$ 和 $y$ 的质因数个数之差不能是 $1$。

将数组中的数分解质因数，然后按照质因数个数的奇偶性分成两类涂色即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int pf(int x){//质因数个数
	int cnt,now=2;
	while(x!=1){
		if(x%now==0)cnt++,x/=now;
		else now++;
		if(now*now>x)now=x;
	}
	return cnt;
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	for(int i=0;i<n;i++){
		int a;cin>>a;
		if(pf(a)%2)cout<<1<<" ";
		else cout<<2<<" ";
	}
	return 0;
}
```

---

## 作者：yr409892525 (赞：2)

## 题解：[P11124 [ROIR 2024 Day 2] 数组划分](https://www.luogu.com.cn/problem/P11124)
我们发现 $p$ 是一个质数，所以在一组的所有数的每一个质因子加一都与其它的每个数不同。       
所以我们不妨直接把质因子的个数分成奇数和偶数两类。          
这样可以保证在一组的每个数乘上一个质数，不等于其他数。          
时间：$O(n\sqrt{a_i})$ 。        
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,M=1e6+5;
int n,a[N];
int work(int x){ //求解质因子的个数
	int sum=0;
	for(int i=2;i*i<=x;i++){
		while(x%i==0){
			x/=i;
			sum++;
		}
	}
	if(x>1){
		sum++;
	}
	return sum;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(work(a[i])%2==0) cout<<1<<" ";
		else cout<<2<<" ";
	}
	return 0;
}
```

---

## 作者：signed_long_long (赞：2)

# 题目解法
题目中的 $p$ 是一个素数（质数），$x$ 不能等于 $p\times y$，所以 $x$ 的质因数数量不能比 $y$ 多 $1$。那怎么让 $x\not=p\times y$ 呢？让质因数个数对 $2$ 取模结果为 $1$ 的分在一起，为 $0$ 的分在一起。这样就能保证分在一起的数质因数的差为 $2$ 的倍数了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a; 
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		int ans=0,p=2;
		while(a>1){
			if(!(a%p)){
				ans++;
				a/=p;
			}else{
				p++;
			}
			if(p>sqrt(a))p=a;//优化
		}
		if(ans&1) printf("1 ");
		else printf("2 ");
	}
	return 0; 
}
```

---

## 作者：Ak_hjc_using (赞：0)

### 思路

首先从题目的本意出发，两个数中如果相差偶数个质因子，那么多出的偶数个质因子势必会构成一个非质数，所以本题可以直接分解质因子之后进行判断。

所以题目的思路就非常明显了。

- 将所有的数分解质因数。
- 如果这个数的质因数个数是奇数，就将它染色成 $1$，否则就将它染色成 $2$。

### 代码

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int n, a[N];
int solve(int x) {
	int cnt = 0;
	for (int i = 2;i * i <= x;i ++) {
		while (x % i == 0){
			x /= i;
			cnt ++;
		}
	}
	if (x != 1) {
		cnt ++;
	}
	return cnt;
}
signed main() {
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1;i <= n;i ++) {
		cin >> a[i];
	}
	for (int i = 1;i <= n;i ++) {
		if (solve(a[i]) % 2 == 1) {
			cout << '1' << ' ';
		} else {
			cout << '2' << ' ';
		}
	}
	return 0;
}

```

---

## 作者：篮网总冠军 (赞：0)

本题是一道质因数分解的标准题目。

我们可以发现，只有当 $x$ 和 $y$ 两个数的质因数个数差一时，才满足有一个质数 $p$，使 $x = y \times p$。

那么，因为这题一定满足数据有解，我们只需要对每个 $a_i$ 求出其质因数个数，在判断奇偶，根据奇偶不同输出 $1$ 和 $2$ 即可。

我们用埃筛来确定质因数个数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100005];
int zs[1000005];
bool zsh[1000005];
void init(){
	for(int i=2;i<=1000000;i++){
		if (!zsh[i]){
			for(int j=i;j<=1000000;j+=i){
				zsh[j]=1;
				int rt=j;
				while(rt%i==0) rt=rt/i,zs[j]++;
			}
		}
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int n;
	cin>>n;
	init();
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		if (zs[a[i]]%2==1) cout<<1<<" ";
		else cout<<2<<" ";
	}
	return 0;
}
```

---


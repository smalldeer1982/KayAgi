# [ROIR 2018] 书页 (Day2)

## 题目描述

**译自 ROI 2018 Regional. Day2 T2.** ***[Старая книга](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day2.pdf)***

一群年轻的考古学家正在发掘一座古图书馆。他们偶然发现了一本旧书的残片。经过研究，他们得出了以下结论。

每一页上要么全是文本（称为文本页），要么全是插图（称为插图页）。已知前 $k$ 页全是插图页。这本书有页码，但只在文本页注明页码。已知注明的页码的总和为 $s$。

很可惜，考古学家既无法确定这本书有多少页，也无法确定哪些页面是插图页。不过，考古学家想知道，这本书最少有几个插图页。

## 说明/提示

### 样例解释

满足 $k=1,$ $s=8$ 的情况共有三种：
- 图文图图图文（4 个插图页）
- 图图文图文（3 个插图页）
- 图图图图图图图文（7 个插图页）

综上，至少会有 3 个插图页。

### 数据范围

|子任务编号|分值|$k$|$s$|
|:-:|:-:|:-:|:-:|
|1|15|$k = 0$|$1 ≤ s ≤ 200$|
|2|20|$k = 0$|$1 ≤ s ≤ 10^{12}$|
|3|30|$0 ≤ k ≤ 199$|$k + 1 ≤ s ≤ 200$|
|4|35|$0 ≤ k ≤ 10^9$|$k + 1 ≤ s ≤ 10^{12}$|

## 样例 #1

### 输入

```
1
8```

### 输出

```
3```

# 题解

## 作者：_N00B_ (赞：9)

# 题解：
### 显而易见的贪心：

(1) **构造出的最后一张文本页作为这本书的最后一页**。

(2) **使文本页尽可能多的同时让总页数尽可能少**。

第 (1) 点很容易保证，因此我们主要考虑第 (2) 点该如何实现。

为了让文本页尽可能多，我们就应该保证文本页的页码都尽可能小，可以发现与此同时我们已经在让总页数尽可能少了（因为由 (1) 可得总页数取决于最后一张文本页的页码）。

### 我们一步一步解决这个问题：

（一）

我们不难想到，我们应当**令第一张文本页的页码为 $ k + 1$，随后不断地把前一张文本页的下一页安排为文本页**。直到安排完这一文本页后，将下一页安排为文本页会使得这一页与之前所安排的所有文本页的页码之和超过题目所给定的 $s$ 。但是此时我们发现按这样的方案构造，往往会余下一些页码没有安排，但是可以发现无论如何将这个页码分解为若干页码，所得到的页码都不能在之前找到对应的合法的页码（即未安排为文本页或插图页的页码），那这该怎么办？

（二）

这时我们只能**让之前安排好的每一张文本页的页码都加上一**，从而使我们的方案的文本页页码和增加，直到尽可能接近但不超过所给定的 $ s $ 。但是我们同样可以发现，这样同时增加页码有时候也不能使文本页的页码之和恰好与所给定的 $ s $ 相等，即遇到文本页的张数大于 $ s $ 与页码之和之差，且差不为零的情况。

（三）

我们可以**只让其中一部分（从最后一张依次向前找）的文本页的页码加上一**，刚好补足剩下的页码和之差，这下就万无一失了，我们完成了本题贪心的构造。

### 最后计算我们构造对答案的贡献：

首先令 $ ans = k $， 这是显而易见的一定要分配的插图页的张数。

随后，（一）的贡献显然为 $ 0 $ ，因为文本页是连续安排的，所以其中不会有插图页。

而（二）的贡献在于每一次使全部的文本页页码加一都使得必须在第一张文本页前插入一张插图页才能让文本页的页码成立，我们记录下我们安排的文本页的张数 $cnt$，剩余的未安排的页数为 $n$，那么这对答案的贡献就是 $\lfloor \frac{n}{cnt} \rfloor $。

对于（三）的贡献，我们知道当 $cnt~ |~ n$ 时是不存在（三）的，而（三）一旦成立，那么对答案的贡献就一定是 $1$。

这里我们就已经完成了对整道题的分析，写代码就可以了。

另外，我这里使用比较好写的枚举，会不会超时呢？我们这里发现，我们枚举的页码是一个等差数列，我们知道等差数列的和是一个二次多项式，因此枚举的时间复杂度就是 $O(n^{\frac{1}{2}})$ ，完全可以通过题目中所给的 $10^{12}$ 级别的数据，如果数据更加严格的话，可以写二分（虽然这时候很有可能已经要用高精了）。

# AC Code :

```cpp
#include<bits/stdc++.h>
using namespace std;
long long k, s, cnt;
int main() {
	cin >> k >> s;
	for (long long i = k + 1; s - i >= 0; ++i, ++cnt) {
		s -= i;
	}
	cout << bool(s % cnt) + k + s / cnt;
	return 0;
}
```

---

## 作者：Little_x_starTYJ (赞：8)

### 前言
经历了 $3$ 次提交终于通过了，顺便抢到了次优解。然后觉得自己运气较好，准备写一篇题解庆祝一下，结果写到一半，电脑没电了。不死心的我就写了这篇题解。

### 解题思路
这是一道贪心，对我而言这个贪心不是特别明显，最近 DP 做多了得了后遗症，一上来就想 DP，然后发现我太菜了，根本不会。

根据题意，我得出了以下简单结论：

1. 前 $k$ 页一定是插图。
2. 如果需要在第 $i$ 页前插一张插图，那么文本页码的总和就会在原来的基础上加上 $p$，$p$ 为第 $i$ 页后的文本的个数。

不要认为这些结论简单然后觉得没用，因为简单意味着牢固。

由于需要满足插图越少越好，所以我们的文本一定是越靠前越好，比如 $s = 6$，那么 $111$ 一定比 $000001$ 更优（$1$ 是文本，$0$ 是插图）。

所以我们可以找到一个最大的 $q$ 使得 $a = (\sum\limits_{i = k + 1} ^ {q} i) \leq s$。

下面就是简单结论的应用了。

- 如果 $a \leq s + p$，我们在第一个文本前面插入一张插图，使得 $a$ 增大 $p$。
- 如果 $s + p < a < s$，我们只需要在第 $s - a$ 个文本前插入插图即可。
- 重复执行上述操作，直到 $a = s$。

所以答案就是 $k + \frac{s - a}{q - k} + [(s - a) \bmod (q - k) \neq 0]$。

这里的中括号是艾佛森括号，括号中的条件成立则为 $1$，不成立为 $0$。

**注意：** `for` 循环会先执行 `i++` 再判断条件是否成立，所以我们需要在退出循环后执行 `i--`。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int k, s;
	cin >> k >> s;
	int sum = 0, ans = k, i;
	for (i = k + 1; sum <= s; i++) {
		sum += i;
	}
	i--; //你猜，见《注意》。
	while (sum > s) {
		sum -= i;
		i--;
	}
	if (s - sum) {
		ans += (s - sum) / (i - k);  //减一加一互相抵消掉了。
		if ((s - sum) % (i - k))
			ans++;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：3)

题目传送门：[P11181 [ROIR 2018 Day2] 书页](https://www.luogu.com.cn/problem/P11181)

前情：本人并全年级几乎所有的 OIer 想了一天（在校时间）然而没想到怎么做，之后班里一位没碰过 OI 的数学大佬用了半节体育课的时间给出了完美的做法。

被虐爆了（泡芙大啸）。所以本篇题解会很长。

### 1 贪心证明

首先，我们考虑将页码 $s$ 分成 $i$ 页的最优情况。

如果 $i=1$，则只能是第 $s$ 页有文本。  
如果 $i=2$，则当 $s$ 是奇数时，文本页为第 $\lfloor \dfrac{s}{2}\rfloor$ 和 $\lceil \dfrac{s}{2}\rceil$ 页；当 $s$ 是偶数时，文本页为第 $\dfrac{s}{2}-1$ 和 $\dfrac{s}{2}+1$ 页（不能有两页相同的页码）。可以证明这样不仅是最优还是对 $k$ 的要求最小的情况。

> 证明：因为总文本页数固定了，所以最大的文本页越小，总页数就越小，总插图页数就越小。
>
> 当两个页挨得越紧（最大的文本页最小时），则最小的文本页将会越大，那支持的 $k$ 就越大。可以看出，多文本页时总是这样。
>

### 2 选择算法

当 $k \geqslant \dfrac{s}{2}-1$ 时，只能取第 $s$ 页为文本页。

否则可以取 $i=2$ 的情况，这样一定比 $i=1$ 更优。

其实，只要 $k$ 小于 $i$ 页的最优情况中最小的页码，那么就可以取该 $i$ 值。而我们又知道，$i$ 越大，其结果一定更优。

那我们要根据边界来确定时间复杂度，我们发现当从 $k+1$ 到 $k+1+i$ 这 $i$ 个数的和大于 $s$ 时，一定不会再有合法的情况了。而合法的退出是当 $i$ 个数里的最优情况中的最小值小于或等于 $k$。

看得出这样的情况下 $i$ 不会很多，直接从 $1$ 开始枚举就好了。

### 3 构造函数

先确定一个最优状态数列中的最大数和最小数：我们定义一个数 $mid=\lfloor \dfrac{s}{i}\rfloor$，暂且将最大值和最小值设为 $mid-\lfloor \dfrac{i}{2}\rfloor$ 和 $mid+ \lfloor \dfrac{i}{2}\rfloor$。如果 $i$ 是奇数，则此时数列的和就是从最小值加到最大值；如果是偶数则应上文还要减去 $mid$ 本身。

```cpp
mid=s/i;
minx=mid-(i/2),maxx=mid+(i/2);
sum=(minx+maxx)*(maxx-minx+1)/2;
```

此时的数列和 $sum$ 有可能小于 $s$，我们要将状态中的一些元素增加。

举例：当 $k=0,s=13,i=4$ 时：

据上面的构造，此时的状态数列应为 $1,2,4,5$，和为 $12$，比 $s$ 小 $1$。我们发现此时还有两页（$1,2$）有加 $1$ 的空间，于是我们可以将 $2$ 加 $1$，最终的文本页是 $1,3,4,5$。

不难得出，$i$ 为偶数时由于第 $mid$ 页并非文本而有 $\dfrac{i}{2}$ 页文本页拥有加 $1$ 来修改 $sum$ 与 $s$ 差值的余地，而 $i$ 为奇数时没有。

如果没有或者余地不够的话，我们就要允许让原本的最大页加 $1$，这样数列中的所有元素就都多出来 $1$ 的余地了。由于之前我们用的是整除的方法，所以最大值加 $1$ 一次必定能满足 $sum=s$，~~请有兴趣的读者自行证明~~。

为了方便我们可以采取将 $i$ 为奇数时的 $mid$ 直接设为 $0$ 或数列中最小值的方法。此时如果 $s>sum$ 且 $mid$ 减最小值大于 $s-sum$ 的差，则最大值和最小值都加 $1$（我们只需要记住状态里的最大和最小值）。  
有一种特殊的情况：上述两值非大非小而是相等，此时我们发现不需要让最大值加 $1$，但是可以让最小值加。~~真是难得的大好事~~

最终，如果最小值大于 $k$，那么更新 $ans$ 为 $\max(ans,max_x-i)$（$max_x$ 表示状态中的最大值）。

此时我们的函数部分就完成了：


```cpp
bool structure(long long i){
	long long mid=s/i,minx=mid-(i/2),maxx=mid+(i/2),sum;
	sum=(minx+maxx)*(maxx-minx+1)/2;
	if(i%2==0)sum-=mid;
	else mid=minx;
	if(s>sum){
		if(mid-minx==s-sum)minx++;
		else if(mid-minx<s-sum)maxx++,minx++;
	}
	if(minx>k){
		ans=min(ans,maxx-i);
		return 1;
	}
	return 0;
}
```

### 5 枚举算法

上面的函数中，如果此状态不满足 $k$ 的限制则返回 false，当返回真时我们不确定更大的 $i$ 能否满足限制，因此我们得到了一个枚举的边界：当 $structure(i)=0$ 时，枚举结束。

我们还可以再增加一个边界：不难发现，如果从 $k+1$ 开始的最小的 $i$ 个数值和都大于 $s$，则肯定不用再枚举了。

- 仔细思考可以发现，这两种边界本质差不多，所以这种枚举算法的时间复杂度极低。

主函数部分：

```cpp
int main(){
	cin>>k>>s;
	for(long long i=1;((k+1)+(k+i))*i/2<=s;i++){
		if(!structure(i)){
			break;
		}
	}
	cout<<ans;
	return 0;
}
```

### 6 完整代码

```cpp
#include<iostream>
using namespace std;
long long k,s,ans=9223372036854775807;
bool structure(long long i){
	long long mid=s/i,minx=mid-(i/2),maxx=mid+(i/2),sum;
	sum=(minx+maxx)*(maxx-minx+1)/2;
	if(i&1)mid=minx;
	else sum-=mid;
	if(s>sum){
		if(mid-minx==s-sum)minx++;
		else if(mid-minx<s-sum)maxx++,minx++;
	}
	if(minx>k){
		ans=min(ans,maxx-i);
		return 1;
	}
	return 0;
}
int main(){
	cin>>k>>s;
	for(long long i=1;((k+1)+(k+i))*i/2<=s;i++)
		if(!structure(i))break;
	cout<<ans<<endl;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/182287913)。调了两天心情真是五味杂陈……

---

## 作者：liaoxingrui (赞：3)

## Content

每一页都有两种类型，分别为文本页和插图页。你有两个数 $k$ 和 $s$，代表前 $k$ 页是插图页，文本页页码总和为 $s$。

问最少有几个插图页。

## Solution

这道题可以使用贪心，尽量让文本页在前面出现，因为这题与文本页页数无关，不用怕文本页过多。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt;
long long m; 
int main(){
	cin>>n>>m;
	for(;m>=cnt+n+1;cnt++)
		m-=cnt+n+1;
	cout<<(m%cnt>0)+n+m/cnt;
	/*
	m/cnt 是指在第一个文本页之前插入多少个插图页。
	
	这样每一个文本页的页码都会增加 m/cnt，看样例应该能明白。
	
	m%cnt 就是看要不要在文本图中间插入插图页，目的与 m/cnt 相似。 
	*/
	return 0;
}
```

---

## 作者：lzt415 (赞：1)

## 思路
题意大家应该都能读懂，所以直接说做题的思路。 

首先我们要注意一件事情，那就是如果想让插图页的数目更小，那么应该在最后总页数越小的同时，尽量使文本页的数目更多一些，这是解这道题的出发点，所以看得出来此题主打的就是一个贪心。

那么怎么实现上述的思路分析呢？

我们可以先从 $k$ 的下一页开始，一直将其变为文本页，由于这些文本页的页码更小，所以这样可以使文本页更多，且由于这些文本页是一直连续的，所以总页数最小。   
那么什么时候停止呢？答案是当下一页的页码的数值加上去时当前文本页的数码总和会大于 $s$，此时停止，并且让 $s$ 减去这个总和，但接下来会出现一个问题，那就是极有可能此时 $s$ 大于 $0$，这可怎么办？？

我们可以不断地在这所有文本页之前插入一个插图页，这样的话这个插图页使得总页数每增加一次数值只加上了 $1$，但是它的影响会更加大，就是说它后面的文本页页码的数值均需加 $1$，而如果不在这里插入插图页，而是在后面插，那么它所影响的文本页的数目会偏小，所以按照刚刚说的插入方法肯定会使得 $s$ 减小得多。

不过呢，有可能出现的情况是减去最后一次插入插图页所影响的页码数值总和之后 $s$ 变成了负数，这样怎么处理呢？

这并不难，我们将这次插入的图片页往后移即可，这样它前面的文本页的页码数值就不增加了，也就是它所影响的文本页数目变小，不过上述道理简单，具体应该怎么实现？别忘了，如果一个数除以另外一个数，结果会自动下取整，所以最后多的那一次不会算上，所以我们单拎出来算一遍即可。

这么讲大家肯定有人不大理解，所以请看代码，结合着理解。
## code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long k,s,i,cnt;
int main(){
	cin>>k>>s;
	for(i=k+1;s-i>=0;i++,cnt++)
	{
		s-=i;
	}
	i=k+s/cnt;
	if(s%cnt) i++;//因为可能剩下的s小于cnt，所以就对应上文所述的操作。
	cout<<i;
	return 0;
}
```

---

## 作者：Tyih (赞：0)

# solution
先求出文本页最大可以有多少页（记为 $t$），此时文本页码总和为 $sum$。

考虑到 $sum$ 可能小于 $s$（令相差为 $x$），所以我们需要将页码补到 $s$。

大概是这样：


![](https://cdn.luogu.com.cn/upload/image_hosting/2ubjfxcn.png)


所以最后只要讨论 $x$ 求模 $t$ 是否等于 $0$ 就行了。

# code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std; 
ll k,s,sum,t; 
int main(){
	cin>>k>>s;
	for(ll i=k+1;sum+i<=s;i++){
	    sum+=i;
	    t++;
	}
	ll x=s-sum;
	if(x%t!=0)
	    cout<<x/t+k+1;
	else
	    cout<<x/t+k;
	return 0;
}
```

---

## 作者：VelvetChords (赞：0)

# P11181 [ROIR 2018 Day2] 书页

## 0.前言
见证每一道水黄的诞生（
## 1.题目解析
题目要求的是在插图页尽可能少的情况下，让文本页的页数尽量多，并且总的页数要最小化。题目中的关键限制是总页码之和不能超过给定的 $s$，而且还需要考虑插图页对文本页页码的影响。

## 2.思路
说白就是贪心。

首先，从第 $k+1$ 页尽可能地将后面的页数变为文本页。文本页越连续，页码总和就会越小，而这正是我们要追求的：让总页数最小化。因此，我们不断地累加页码的和，直到总和超过了 $s$。

当停止填充文本页后，可能总和并没有刚好等于 $s$，这意味着还有剩余空间未被使用。此时，我们考虑在这些文本页中插入插图页。

每插入一个插图页，插图页本身占一页，但更重要的是它会让后面所有文本页的页码增加 $1$，也就是说，插图页前面插的越早，影响的文本页数就越多。所以我们要从前面开始插入插图页，直到使得 $s$ 刚好被消耗完，或者接近为 $0$。

但有时，插入插图页后，页码的总和可能会超过 $s$，也就是产生了负数的情况。这时我们只需要将最后插入的插图页往后移，减少这个插图页对前面文本页的影响，使得前面的文本页页码不再增加，从而调整总页数。

方法考虑完后，总结思路。

从第 $k+1$ 页开始尽可能填充连续的文本页，直到总页码之和超过 $s$。
当填充到一定页数后，开始插入插图页，每次插入都会减少 $s$，直到 $s$ 被消耗完。
如果插入太多导致 $s$ 变为负数，将最后插入的插图页向后移动，减少影响。

---

## 作者：__Ginka__ (赞：0)

## P11181 \[ROIR 2018 Day2] 书页

### 题目大意

需确定最少的插图页数。个人认为的关键点在于以下几方面：

1. **文本页和插图页的分布**：前 $k$ 页都是插图页，而之后的页没说是什么，可能是插图也可能是文本。
2. **页码标注规则**：只有文本页会有页码，且页码总和为 $s$。
3. 输出结果：最少可能的插图页数，没啥好说的。

### 解题思路

首先，我们可以确定的是，前 $k$ 页一定是插图页（输出是一定要记得加上），因此插图页数至少为 $k$。剩余的页没说。

1. 从第 $k + 1$ 页开始，我们假设可能遇到的第一页是文本页，假设它的页码为 $k + 1$。我们可以从 $s$ 中减去这个页码，继续~~猜~~后续的页码。
2. 假设下一个文本页的页码为 $k + 2$，我们继续从 $s$ 中减去 $k + 2$，以此类推，直到 $s$ 小于下一个可能的页码为止。
3. 在这个过程中，如果 $s$ 能够全部分配完，那么我们已经确定了至少有多少个文本页，以及需要的最少插图页数，否之没有文本页就只剩初始的 $k$ 页了。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long k,s,i;
int main()
{
	cin>>k>>s;	
    for(i=k+1;s>=i;i++)//这里>i就寄了 
        s-=i;//用掉了
    //i是已经尝试过的的下一个
    i-=(k+1);//已经分配的数量
    if(i==0)//没有任何文本页
        cout<<k;
	else//还要对剩下的s进行分配并计算
        cout<<(int)(ceil(s/(i*1.0)))+k;//差点忘记加上原来的
    return 0;
}

```

---

## 作者：grass_dream (赞：0)

# 题意：

已知有一堆大于 $k$ 的数，它们的和为 $s$，求其中的最大数减数的总个数最小为多少。

# 解法：

这道题总体来说是一道贪心题，首先，让文字页的页码最小肯定是我们首要做的，而这么做的方法也很简单：尽可能的把从 $k+1$ 和紧跟着它的数选上。

可是，这样得出的数的总和可能不是 $s$，这时，我们就可以对它进行一些调整了：如果差的值大于数的总个数，则数群体加一，直到差的值小于数的总个数为止，然后把从最后一个数往前一直到从后往前数第差个的那个数全体加一，然后就可以了的ψ(｀∇´)ψ

# AC code:

```cpp

#include<bits/stdc++.h>
using namespace std;
long long k,s;
int main(){
	cin>>k>>s;
	long long cnt=0,kd=0;//cnt:现在数的总和，kd:数的总个数 
	for(long long i=k+1;s>=cnt+i;++i){
		cnt+=i;kd++;
	}
//	cout<<cnt<<" "<<kd<<endl;
	long long ans=(s-cnt)/kd;
	if((s-cnt)%kd!=0)ans++;
	cout<<ans+k<<endl;
	return 0;
}

```

---

## 作者：封禁用户 (赞：0)

### 思路
首先求出我们最多可以放置多少个文本页，答案有可能文本页总和小于 $s$ 记为 $c$。考虑将文本页整体往后移动补足 $c$。

### CODE
```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using namespace std; 
ll k, s, sum, t;
int main(){
	scanf("%lld%lld", &k, &s);
	for(ll i = k + 1;i <= s; i++){
		if(sum + i <= s) sum += i, t++;
		else break;
	}
	ll last = s - sum;
	if(!(last % t)) printf("%lld\n", last / t + k);
	else printf("%lld\n", last / t + k + 1);
	return 0;
}

```

---

## 作者：zyc230721hzx (赞：0)

蒟蒻的第四篇题解。

[题目传送门](https://www.luogu.com.cn/problem/P11181)。
### 题意：
构造一个字符串，使得前 $k$ 个字符都为 `0`，并且所有字符 `1` 的下标之和为 $s$（假设插图页为 `0`，文本页为 `1`）。
### 考点：
贪心。
### 思路：
1. 先假设所有的字符 `1` 都在 $k$ 个 `0` 的后面且连续，从 $k+1$ 开始递增下标 $i$，每次从 $s$ 中减去下标 $i$，直到 $s < i$ 为止，此时 $i$ 的值为字符 `1` 的个数与 $k+1$ 的和，因此将 $i$ 的值减去 $k+1$ 就能得到字符 `1` 的个数。
2. 接下来如果 $s$ 不为 $0$，则将右起前 $\min(i,s)$ 个字符往右移一位，空位补上字符 `0`，同时将 $s$ 减去 $\min(i,s)$，重复第二步，直到 $s$ 为 $0$ 为止。可以发现，这一步新增的字符 `0` 的数量为 $\lceil{\frac{s}{i}}\rceil$。

由于题目只要求出插图页（字符 `0`）个数的最小值，因此无需模拟过程，$k+\lceil{\frac{s}{i}}\rceil$ 就是答案。

### AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long k,s,i;
int main()
{
	cin>>k>>s;
	for(i=k+1;s>=i;i++){
		s-=i;
	}
	i-=(k+1);
	if(i!=0)
		cout<<(long long)(k+ceil(s/(i*1.0)));
	else
		cout<<k;
	return 0;
}
```

### 注意：
- 记得开 `long long`；
- `for` 循环的判断条件是 `s>=i` 而不是 `s>i`；
- $0$ 不能作除数。

预祝 AC！

---


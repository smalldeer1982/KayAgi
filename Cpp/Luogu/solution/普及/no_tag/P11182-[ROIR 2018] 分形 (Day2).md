# [ROIR 2018] 分形 (Day2)

## 题目描述

**译自 ROI 2018 Regional. Day2 T3.** ***[Красота фейерверка](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day2.pdf)***

已知一棵包含 $n$ 个元素的有根树 $T^1$。定义 $T^m$ 为一棵树，生成方式是在 $T^{m-1}$ 的每个叶结点下面连一棵 $T^1$ 而得。

![](https://cdn.luogu.com.cn/upload/image_hosting/s596ep9z.png)

试求 $T^m$ 的直径的长度（这里的长度指的是直径上的点数）。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/g4tsci1c.png)

### 数据范围

$3≤n≤2\times 10^5,$ $1≤m≤2\times 10^5,$ $1\le p_i\le i-1.$

|子任务编号|分值|$n$|$m$|
|:-:|:-:|:-:|:-:|
|1|19|$3 ≤ n ≤ 5000$|$m = 1$|
|2|10| |$m=1$|
|3|20|$3 ≤ n ≤ 5000$|$1 ≤ m ≤ 5000$|
|4|19|$3 ≤ n≤ 5000$||
|5|32||&nbsp;|


## 样例 #1

### 输入

```
4 2
1 1 2```

### 输出

```
10```

# 题解

## 作者：Little_x_starTYJ (赞：9)

### 前言
本来是在备战 CSP-S 的，无意间翻到了第 $214$ 页，看到开头两道黄，于是就想着刷刷水黄。看完题目发现是八月份我们学校考过的题，只是题目清晰很多，于是就来水一水题解。

### 解题思路
两黄居然都是贪心？！

不难发现，$T^m$ 的直径需要经过 $T^1$ 的直径。那么我们就可以只考虑在直径的两端添加树。因为在其他地方添加都不是最优的。

很明显，$T^1$ 的直径对 $T^{2\sim m}$ 的答案都是没有贡献的（除非是条链），那么我们只需要找到 $T^1$ 的最长链再接在两端就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
	int k = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
		f = (f == -1 ? -1 : f), c = getchar();
	while (c >= '0' && c <= '9') {
		k = (k << 1) + (k << 3) + (c ^ 48);
		c = getchar();
	}
	return k * f;
}
inline void write(int k) {
	if (k < 0)
		putchar('-'), k = -k;
	if (k > 9)
		write(k / 10);
	putchar(k % 10 + '0');
}
inline void print(int x, char c = ' ') {
	write(x), putchar(c);
}

const int N = 2e5 + 10;
int ans, dep[N];
vector<int> v[N];
  inline int dfs(int x, int fa) {  //求 T^1 的直径与最长链
	dep[x] = dep[fa] + 1;
	int cd = 0, maxn = 0;
	for (auto u : v[x]) {
		if (u != fa) {
			int k = dfs(u, x);
			if (k > maxn) {
				cd = maxn;
				maxn = k;
			} else if (k > cd)
				cd = k;
		}
	}
	if (cd && maxn)
		ans = max(ans, cd + maxn + 1);
	return maxn + 1;
}
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n = read(), m = read(), a;
	for (int i = 2; i <= n; i++) {
		a = read();
		v[a].push_back(i);
		v[i].push_back(a);
	}
	dfs(1, 0);
	int tanBing = -1e9;
	for (int i = 1; i <= n; i++) {
		tanBing = max(tanBing, dep[i]);
	}
	if (ans)
		ans = (ans + 2LL * tanBing * (m - 1));
	write(max(ans, 1LL * tanBing * m));
	return 0;
}
```
额代码是八月份写的，当时还不会求直径（不要问我考场上是怎么写出来的），所以代码写得有点屎。。

---

## 作者：liaoxingrui (赞：3)

## Content

有一棵 $n$ 个节点的树 $T^1$。在 $T^x$ 的每个叶结点下面连接一棵 $T^1$ 得到 $T^{x + 1}$。

求 $T^m$ 直径上的点数。

## Solution

可以看出直径上的点数为 $T^1$ 的最长链上的点数乘上 $m - 1$ 再加上 $T^1$ 的直径。查找 $T^1$ 的最长链只需要一直向下搜索，记录一下深度即可。而 $T^1$ 的直径是以 $T^1$ 的最长链末尾的点为根节点的树的最长链。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,x,y,ma,tot,maxx;
int head[N];
struct node{
	int x,y;
}nex[N<<1];
inline void add(int x,int y){
	tot++;
	nex[tot].x=y;
	nex[tot].y=head[x];
	head[x]=tot;
}
inline void dfs(int node,int fa,int dep){
	if(dep>ma){
		ma=dep;
		maxx=node;
	}
	for(int i=head[node];i;i=nex[i].y){
		int w=nex[i].x;
		if(w!=fa)
			dfs(w,node,dep+1);
	}
}
int main(){
	cin>>n>>m;
	for(int i=2;i<=n;i++){
		cin>>x;
		add(x,i);
		add(i,x);
	}
	dfs(1,0,1);
	y=ma;
	ma=0;
	dfs(maxx,0,1);
	cout<<ma+(long long)(m-1)*y*2;
	return 0;
}
```

---

## 作者：HashHacker_Peas (赞：3)

## 题目描述
已知一棵包含 $n$ 个元素的有根树 $T^1$。定义 $T^m$ 为一棵树，生成方式是在 $T^{m-1}$ 的每个叶结点下面连一棵 $T^1$ 而得。

![](https://cdn.luogu.com.cn/upload/image_hosting/s596ep9z.png)

试求 $T^m$ 的直径的长度（这里的长度指的是直径上的点数）。
## 解题思路
可以知道 $T^1$ 的直径的两个端点一定是叶子结点，在则在直径最长的基础上，两个叶子结点可以拓展出原来的 $T^1$，要使直径最大，则加上 $T^1$ 的根结点到叶子的最长链的两倍即可，这在第一次 dfs 的时候记录即可，于是答案就是 $dis+2\times (m-1)\times dis'$（$dis$ 为直径，$dis'$ 为最长链）。

关于如何求树的直径，可以从根节点 dfs 求出距离根节点最远的点 $s$，再从 $s$ dfs 求出距离 $s$ 最远的点 $t$，$s$ 到 $t$ 这段长度就是树的直径。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+10;
int n,u,v,m,dis[maxn],ans,mx,cnt,s;
vector<int>g[maxn];
void dfs(int x,int fa){
    dis[x]=dis[fa]+1;
    for(int i=0;i<g[x].size();i++){
        int to=g[x][i];
        if(to==fa)
            continue;
        dfs(to,x);
    }
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=2;i<=n;i++)
        scanf("%lld",&v),g[v].push_back(i),g[i].push_back(v);
    dfs(1,0);
    for(int i=1;i<=n;i++)
        if(dis[i]>mx)
            mx=dis[i],s=i;
    cnt=mx,mx=0;
    memset(dis,0,sizeof(dis));
    dfs(s,0);
    for(int i=1;i<=n;i++)
        if(dis[i]>mx)
            mx=dis[i];
    ans=mx;
    ans+=(m-1)*cnt<<1;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：L_zaa_L (赞：3)

树的直径一定经过第一棵树，我们将所有非叶子节点记为 $1$，叶子节点记为 $(m-1)\times maxdep$，然后跑加权树的直径就可以了，树的直径可以用树形 DP 做出来。

## Code
```cpp
#include<bits/stdc++.h>
#define int __int128
#define For(i,a,b) for(int i=a;i<=b;++i)
#define Rof(i,a,b) for(int i=a;i>=b;--i)
#define rep(i,a) for(int i=1;i<=a;++i)
#define print(x) printf("%lld\n",(int)x)
#define prn(x) printf("%lld ",(int)x)
using namespace std;
const int N=4e5+5,Mod=998244353;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){f=(ch=='-'?-f:f);ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m;
int p[N];
vector<int>q[N];
int dep[N],w[N];
void dfs(int x,int faz){
	dep[x]=dep[faz]+w[x];
	for(auto y:q[x]){
		if(y==faz) continue;
		dfs(y,x);
	}	
}
inline pair<int,int> find(int rt){
	For(i,1,n) dep[i]=0;
	dfs(rt,0);
	int mx=0,p=0;
	For(i,1,n) if(dep[i]>mx){mx=dep[i],p=i;}
	return {mx,p};
}
int in[N];
signed main(){
	n=read(),m=read();
	For(i,1,n) w[i]=1;
	For(i,2,n)p[i]=read();
	For(i,2,n){
		q[i].push_back(p[i]);
		q[p[i]].push_back(i);
		in[i]++;in[p[i]]++;
	}
	auto s1=find(1);
	For(i,2,n){
		if(in[i]==1){
			w[i]+=(m-1)*(s1.first);
		}
	}
	s1=find(1);
	auto t1=find(s1.second);
	int mi=1;
	For(i,1,64) mi*=2;
	printf("%llu\n",(unsigned long long)(t1.first&(mi-1)));
	return 0;
}
//
```

---

## 作者：seika27 (赞：2)

### 思路
我们可以先求出原树的直径。

由于我们要求的是 $T^m$ 的直径，所以我们不用关注这颗树整体长什么样子。

那么我们直接忽略其他的边，每次拓展就相当于给这颗树的每一个叶子上往后接了一条长度为 $T^1$ 这颗树的最大深度的链。

那么既然每一个叶子节点都会接一条，那么其实答案就是在原直径 $l$ 上加 $(m-1)\times2\times maxdep$。

### code

```cpp
#include <bits/stdc++.h>
#define int long long
#define cin std::cin
#define cout std::cout
int n,m;
const int N=2e5+5;
int fa[N],dep[N],depp[N];
std::vector<int>g[N];
int maxdep=-1;
int maxdepi;
void fac1(int x)
{
	dep[x]=dep[fa[x]]+1;
	for(auto v:g[x])
	{
		if(v==fa[x])continue;
		fac1(v);
	}
}
void fac2(int x,int f)
{
	depp[x]=depp[f]+1;
	for(auto v:g[x])
	{
		if(v==f)continue;
		fac2(v,x);
	}
}
signed main()
{
	std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>m;
	for(register int i=2;i<=n;++i)cin>>fa[i],g[fa[i]].push_back(i),g[i].push_back(fa[i]);
	fac1(1);
	for(register int i=1;i<=n;++i)
	{
		if(dep[i]>maxdep)
		{
			maxdep=dep[i];
			maxdepi=i;
		}
	}
	fac2(maxdepi,0);
	int ans=-1;
	for(register int i=1;i<=n;++i)ans=std::max(ans,depp[i]);
	cout<<ans+(m-1)*maxdep*2;
}
```

---

## 作者：walnut_hubby (赞：2)

## 题意

比 @JOKER_chu 说的更详细一点。

一棵树 $t$，每次操作都会对当前树的每一个叶子操作：将初始时的 $t$ 复制一份，然后将这个叶子与这棵新建的树的根连一条边，求 $m - 1$ 次操作后树的直径。

## 解法

显然，我们先处理出初始树的最长链，直径，然后考虑 $O(1)$ 算出答案，每次操作对答案的贡献可以理解为在当前树的直径的两头拼上了一个初始树的最长链，所以答案可以很轻松的计算，设直径长度为 $z$，最长链长度为 $c$，答案即为 $z + (m - 1) \times 2c$。

---

## 作者：Epitome (赞：2)

## 题意

有一棵树，现在要执行 $m - 1$ 次操作，每次操作将当前树的每个叶子拼接上一棵初始时的树，求最后树的直径。

## 解法

显然我们先把初始树的直径求出来，然后就可以考虑拼接对答案的贡献，每次拼接显然会对答案贡献一条初始树的最长链的长度，然而直径两端都是能拼接的，设原树的直径为 $d$，最长链长度为 $l$，答案即为 $d + l \times (m - 1) \times 2$。

## 代码

```cpp
#include <iostream>

#include <vector>

using namespace std;

using ll = long long;

const int N =  2e5 + 5;

int n, m, dp[N], ans;

vector<int> g[N];

void s( int x, int fa ) {
  dp[x] = 1;
  for ( auto to : g[x] ) {
    if (to == fa) continue;
    s(to, x);
    ans = max(ans, dp[x] + dp[to]);
    dp[x] = max(dp[x], dp[to] + 1);
  }
}

int main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n >> m;
  for ( int i = 2, x, y; i <= n; ++i ) {
    cin >> x;
    g[x].push_back(i), g[i].push_back(x);
  }
  s(1, 0);
  cout << ans + 1ll * dp[1] * (m - 1) * 2;
  return 0;
}

```

---

## 作者：NTT__int128 (赞：2)

# P11182 [ROIR 2018 Day2] 分形 题解
首先，观察到一个事实，$T^m$ 的直径是由 $2m-2$ 条由 $1$ 出发的最长链拼上 $T^1$ 的直径。用树形 DP 解决树的直径与最长链。

时间复杂度：$\Theta(n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=2e5+5;
int n,m,x,dis1[N],dis2[N],dis;
vector<int>v[N];
void dfs(int cur,int fa){
	for(int to:v[cur])
		if(to!=fa){
			dfs(to,cur);
			if(dis1[to]+1>=dis1[cur])dis2[cur]=dis1[cur],dis1[cur]=dis1[to]+1;
			else if(dis1[to]+1>=dis2[cur]) dis2[cur]=dis1[to]+1;
		}
	dis=max(dis,dis1[cur]+dis2[cur]+1);
}
int main(){
	cin>>n>>m;m--;
	for(int i=2;i<=n;i++)cin>>x,v[x].push_back(i),v[i].push_back(x);
	dfs(1,0);
	cout<<dis+2ll*(dis1[1]+1)*m;
	return 0;
}
```

---

## 作者：xiazha (赞：1)

萌萌简单题

考虑贪心，因为最终树的直径经过根节点一定最优，所以先算出原树的直径 $d$，以后拼接的树对答案的贡献是原树最长的祖孙链，设长为 $p$。因为每次直径两端都可接树，所以共会选 $(m-1)\times 2$ 条最长祖孙链，答案是 $d+(m-1)\times 2\times p$。

做完了。

或许可以给个代码？


```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,dp[200002],ans;
vector<int> g[200002];
void dfs(int x)
{
	for(int y:g[x])
	{
		dfs(y);
		ans=max(ans,dp[x]+dp[y]);
		dp[x]=max(dp[x],dp[y]+1);
	}
	dp[x]=max(dp[x],1ll);
}
signed main()
{
	cin>>n>>m;
	for(int i=2,x;i<=n;i++) scanf("%lld",&x),g[x].push_back(i);
	dfs(1);cout<<ans+2*dp[1]*(m-1);
	return 0;
}
```

---

## 作者：liuyi0905 (赞：0)

前置知识：树的直径。

众所周知，直径的两个端点都是在叶子节点上的，而且每次拼树也都是拼在叶子节点上的，设 $T_1$ 最长链为 $d$，则每次拼树后的直径都可以加 $2d$。设 $T_m$ 的直径为 $l_m$，则可以得知 $l_m=l_{m-1}+2d$，这样下去，可得 $l_m=l_1+2d(m-1)$。

用树形 DP 求出原树的最长链和直径，然后计算一下即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const int N = 2e5 + 5;
int n, m;
LL f[N], d[N];
vector<int> e[N];
void S(int u, int fa) {
  for (auto v : e[u]) {
    if (v == fa) {
      continue;
    }
    S(v, u);
    if (f[v] + 1 > f[u]) {
      d[u] = f[u], f[u] = f[v] + 1;
    } else if (f[v] + 1 > d[u]) {
      d[u] = f[v] + 1;
    }
  }
}
int main() {
  cin >> n >> m;
  for (int i = 2, x; i <= n; i++) {
    cin >> x;
    e[i].push_back(x), e[x].push_back(i);
  }
  S(1, 0);
  LL l = 0;
  for (int i = 1; i <= n; i++) {
    l = max(l, f[i] + d[i] + 1);
  }
  cout << l + (f[1] + 1) * (m - 1) * 2;
  return 0;
}
```

---

## 作者：JingchenBian (赞：0)

### 前言
这题就是一道简单的树形 DP ~~(不过树形 DP 是一道黄体貌似不太好,建议升绿)~~

### 正式讲题
对于每一个 $T^1$ 的树，我们分两种情况讨论：

1. 直径是叶子节点到非叶子节点，则一定是一个叶子节点到根节点，很明显则是后的答案是 $m\times T^1\text{的深度}$。
  
2. 若 $T^i(i>1)$ 的树的直径是两个叶子节点，两个叶子节点一定属于两个原本树种 $2$ 情况的两个节点的新增子树，且深度为 $T^1$ 的深度。
    

综上，只需要考虑每个子树根节点到叶子节点的最长距离即可。

Code：
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    vector<int> Tree[200005];  //存树
    int m,dep[200005],maxdep;   //m;每个节点深度; T1的深度 
    long long dp(int n,long long &maxd){   
    	long long r=maxdep;
    	if(Tree[n].empty()){    //叶子节点 
    		maxd=maxdep*(m-1ll)+1;
    		return r;
    	}
    	long long secd=0;
    	for(auto i:Tree[n]){   //遍历DFS 
    		long long d=0;
    		r=max(r,dp(i,d));  //下一个节点 
    		if(d>maxd){
    			secd=maxd;
    			maxd=d;
    		}
    		else if(d>secd)secd=d;
    	}
    	return max(r,(++maxd)+secd);
    }
    int main(){
    	int n;
    	scanf("%d%d",&n,&m);
    	dep[1]=maxdep=1; //初始化 
    	for(int i=2;i<=n;i++){ //存图 
    		int v;
    		scanf("%d",&v);
    		Tree[v].push_back(i);
    		dep[i]=dep[v]+1; 
    		maxdep=max(maxdep,dep[i]);   //更新T1深度 
    	}
    	long long f=0; //因为dp要引用式传参输入0会CE 
    	printf("%lld",dp(1,f));
    	return 0;
    }
```

---

## 作者：User709913 (赞：0)

本题建议评黄。

## 思路

在从 $ T_n $ 至 $ T_{n+1} $ 的过程中，

设 $ T_1 $ 的节点最大深度（根节点深度为 $0$ ）为 $ k $。

则在两端，$ T_{n+1} $ 的直径长度各增长 $ k $，

从 $ T_1 $ 至 $ T_m $ 共增长 $ (2m-2)k $。

故最终答案为 $ T_1 $ 的直径 $ + (2m-2)k$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int>g[200010];
long long m,dp[200010],f[200010];
void dfs(int x){
	int max1=0,max2=0;
	for(int i=0;i<(int)g[x].size();i++){
		dfs(g[x][i]);
		if(max1<f[g[x][i]]+1){
			max2=max1;
			max1=f[g[x][i]]+1;
		}else if(max2<f[g[x][i]]+1)max2=f[g[x][i]]+1;
		dp[x]=max(dp[x],dp[g[x][i]]);
	}
	dp[x]=max(dp[x],1ll*max1+max2);
	f[x]=max1;
	return;
}
int main(){
	cin >> n >> m;
	for(int i=2;i<=n;i++){
		int x;
		cin>> x;
		g[x].push_back(i);
	}
	dfs(1);
	cout << dp[1]+(m*2-2)*(f[1]+1)+1 << endl;
	return 0;
}
```

---

## 作者：破壁人罗辑 (赞：0)

### 题意简述

给出一个有根树 $T^1$，定义树 $T^i$ 为树 $T^{i-1}$ 的所有叶子节点上都重复添加一个子树 $T^1$ 得到的新树，求树 $T_m$ 上最长路径的节点数量。

### 解题思路

用 $dep_{max}$ 表示 $T^1$ 树中的节点最大深度（根节点深度规定为 $1$），用 $|AB|$ 表示路径 $AB$ 中节点的数量。

分两种情况讨论：

- 若树的直径是一个叶子节点 $A$ 和一个非叶子节点 $B$ 之间的路径，那么一定是根节点和叶子节点。
  - 使用反证法。如果 $A,B$ 都在根节点到节点 $A$ 的路径上，则 $AB$ 之间的路径长度显然比根节点到节点 $A$ 的路径短；否则存在一个节点 $C$ 使得节点 $A,B$ 分别在节点 $C$ 的不同子树上，则 $AB$ 之间的路径长度显然比 $B$ 的子树的任意一个叶子节点到节点 $A$ 的路径短。
  - 所以这种情况下答案应该是 $m\times dep_{max}$.
- 若 $T^i,i>1$ 树的直径是两个叶子节点 $A,B$，则这两个节点一定在 $T^{i-1}$ 树中离得最远的两个叶子节点的新增子树中，并且在新增子树中的深度为 $dep_{max}$.
  - 使用反证法。先不考虑只含一个叶子节点的情况。若节点 $A,B$ 分别在叶子节点 $C,D$ 的新增子树上，且叶子节点 $E,F$ 的距离大于叶子节点 $C,D$ 的距离，记 $E$ 向下走与 $C-A$ 相同的路径得到的节点为 $A_1$，记 $F$ 向下走与 $D-B$ 相同的路径得到的节点为 $B_1$，则 $|AB|=|AC|+|CD|+|DB|-2<|A_1E|+|EF|+|FB_1|-2=|A_1B_1|$。故这两个节点一定在 $T^{i-1}$ 树中离得最远的两个叶子节点的新增子树中。若 $A,B$ 在新增子树中的深度少于 $dep_{max}$，则设 $A_2$ 为节点 $C$ 的新增子树中深度为 $dep_{max}$ 的，$B_2$ 为节点 $D$ 的新增子树中深度为 $dep_{max}$ 的，则 $|AB|=|AC|+|CD|+|DB|-2<|A_2C|+|CD|+|DB_2|-2=|A_2B_2|$.

综上所述，我们添加新增子树的时候只需要考虑新增子树中根节点到最深的叶子节点的这一条路径即可，也就是一条长度为 $dep_{max}$ 的链。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>son[200005];int m,dep[200005],maxdep;
long long dfs(int n,long long&maxd){
	long long r=maxdep;
	if(son[n].empty()){
		maxd=maxdep*(m-1ll)+1;
		return r;
	}
	long long secd=0;
	for(auto i:son[n]){
		long long d=0;r=max(r,dfs(i,d));
		if(d>maxd){secd=maxd;maxd=d;}
		else if(d>secd)secd=d;
	}
	return max(r,(++maxd)+secd);
}
int main(){
	int n;scanf("%d%d",&n,&m);
	dep[1]=maxdep=1;
	for(int i=2;i<=n;i++){
		int v;scanf("%d",&v);
		son[v].push_back(i);
		maxdep=max(maxdep,dep[i]=dep[v]+1);
	}
	long long x=0;
	printf("%lld",dfs(1,x));
	return 0;
}
```

---


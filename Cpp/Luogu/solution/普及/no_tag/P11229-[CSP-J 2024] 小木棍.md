# [CSP-J 2024] 小木棍

## 题目描述

小 S 喜欢收集小木棍。在收集了 $n$ 根长度相等的小木棍之后，他闲来无事，便用它们拼起了数字。用小木棍拼每种数字的方法如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/8zubqass.png)

现在小 S 希望拼出一个**正**整数，满足如下条件：

- 拼出这个数**恰好**使用 $n$ 根小木棍；
- 拼出的数没有前导 $0$；
- 在满足以上两个条件的前提下，这个数尽可能小。

小 S 想知道这个数是多少，可 $n$ 很大，把木棍整理清楚就把小 S 折腾坏了，所以你需要帮他解决这个问题。如果不存在正整数满足以上条件，你需要输出 $-1$ 进行报告。

## 说明/提示

**【样例 1 解释】**

- 对于第一组测试数据，不存在任何一个正整数可以使用恰好一根小木棍摆出，故输出 $-1$。
- 对于第四组测试数据，注意 $0$ 并不是一个满足要求的方案。摆出 $9$、$41$ 以及 $111$ 都恰好需要 $6$ 根小木棍，但它们不是摆出的数最小的方案。
- 对于第五组测试数据，摆出 $208$ 需要 $5 + 6 + 7 = 18$ 根小木棍。可以证明摆出任何一个小于 $208$ 的正整数需要的小木棍数都不是 $18$。注意尽管拼出 $006$ 也需要 $18$ 根小木棍，但因为这个数有前导零，因此并不是一个满足要求的方案。

**【数据范围】**

对于所有测试数据，保证：$1 \leq T \leq 50$，$1 \leq n \leq 10^5$。

::cute-table{tuack}

| 测试点编号 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | 无 |
| $2$ | $50$ | ^ |
| $3$ | $10^3$ | A |
| $4,5$ | $10^5$ | ^ |
| $6$ | $10^3$ | B |
| $7,8$ | $10^5$ | ^ |
| $9$ | $10^3$ | 无 |
| $10$ | $10^5$ | ^ |

特殊性质 A：保证 $n$ 是 $7$ 的倍数且 $n \geq 100$。

特殊性质 B：保证存在整数 $k$ 使得 $n = 7k + 1$，且 $n \geq 100$。

## 样例 #1

### 输入

```
5
1
2
3
6
18```

### 输出

```
-1
1
7
6
208```

# 题解

## 作者：sjh0626 (赞：139)

## 题意概括

给你一个自然数 $N$，使这 $N$ 根木棍能摆出最小得数（不含前导 $0$）

## 思路

分类讨论，其实看特殊性质就知道可以打 $N \bmod 7$ 的余数打表。

- 余数为 $0$：答案为 $N \div 7$ 个 $8$。
  
- 余数为 $1$：
  - $N = 1$ 特判，无答案，输出 $-1$。
  - 剩下答案为 $10$ 拼接 $(N - 8) \div 7$ 个 $8$。

- 余数为 $2$：答案为 $1$ 和 $(N - 2) \div 7$ 个 $8$。

- 余数为 $3$：
  - $N = 3$ 特判，答案为 $7$。
  - $N = 10$ 特判，答案为 $22$。
  - 剩下答案为 $200$ 拼接 $(N - 17) \div 7$ 个 $8$。

- 余数为 $4$：
  - $N = 4$ 特判，答案为 $4$。
  - 剩下答案为 $20$ 拼接 $(N - 11) \div 7$ 个 $8$。

- 余数为 $5$：
  - 答案为 $2$ 拼接 $(N - 5) \div 7$ 个 $8$。

- 余数为 $6$：
  - 答案为 $6$ 拼接 $(N - 6) \div 7$ 个 $8$。

## 代码

```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
long long n,t,ans,stick[10]={6,2,5,5,4,5,6,3,7,6}; 
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		ans=1e9+1;
		if(n==1)cout<<-1;
		else if(n==2)cout<<1;
		else if(n==3)cout<<7;
		else if(n==4)cout<<4;
		else if(n==5)cout<<2;
		else if(n==6)cout<<6;
		else if(n==7)cout<<8;
		else if(n%7==0)for(int i=1;i<=n/7;i++)cout<<8;
		else if(n%7==1){
			cout<<10;
			for(int i=1;i<=(n-8)/7;i++)cout<<8;
		}
		else if(n%7==2){
			cout<<1;
			for(int i=1;i<=(n-2)/7;i++)cout<<8;
		}
		else if(n%7==3){
			if(n==10)cout<<22;
			else {
				cout<<200;
				for(int i=1;i<=(n-17)/7;i++)cout<<8;
			}
		}
		else if(n%7==4){
			cout<<20;
			for(int i=1;i<=(n-11)/7;i++)cout<<8;
		}
		else if(n%7==5){
			cout<<2;
			for(int i=1;i<=(n-5)/7;i++)cout<<8;
		}
		else if(n%7==6){
			cout<<6;
			for(int i=1;i<=(n-6)/7;i++)cout<<8;
		}
		cout<<"\n";
	}
	sjh0626s code;
}
```

---

## 作者：WsW_ (赞：67)

### 前言
已经退役成了 whker，到了高二依然没有 AK 过 CSP-J。  
显然，今年的题目我做不到 AK，甚至很难上 $300$ 分。  
补题，发现了一种完全不同的做法。  
相较于各种找规律，更有道理；相较于各种 dp，更加易懂。  

---
### 思路
思考一下，人类在比较两个数大小的时候是怎么做的？  
先考虑数字位数，位数多的数一定大；数位相同，再依次比较前几位。  

回到这一题，首先我们要考虑的，是**用 $n$ 根小木棍摆出的数字至少要有几位？**  
显然，因为数字 $8$ 消耗的小木棍最多，所以**小木棍全部用来摆数字 $8$，摆出的数字一定数位最少**。  

所以我们先将除了第一位的数位填上 $8$，第一位随便补一个数来满足使用了 $n$ 根小木棍，这样摆出的数字一定数位最少。  

再考虑如何让前几位更小。  
假设我们先想让第一位数字变得更小，那么唯一的方法就是，从后面的某一位拆一根或几根小木棍下来，装到第一位数字上面。  
之前我们的构造方法决定了除了第一位，其他数位上都是数字 $8$。不难发现，**在数字 $8$ 上面拆下一根或几根小木棍下来，一定有方法把 $8$ 变成一个比 $8$ 更小的数**。  
所以，我们这样一波操作，不仅第一位的数字变小了，拆小木棍的那一位数字也变小了。那么根据贪心，我们应该从第二位拆小木棍，因为这样可以让整体数字更小。  
我们肯定想把第一位的数字在添加小木棒后变得最小，那么改变的方案如下（逗号前是如果这一位需要考虑前导零，最小可以变成多少；逗号后则是不需要考虑前导零，最小可以变成多少）：
|初始数字|操作后数字|增加的木棍数|
|:-:|:-:|:-:|
|$0$|$0$|$0$|
|$1$|$1,0$|$0,4$|
|$2$|$2,0$|$0,1$|
|$3$|$2,0$|$0,1$|
|$4$|$2,0$|$1,2$|
|$5$|$2,0$|$0,1$|
|$6$|$6,0$|$0$|
|$7$|$2,0$|$2,3$|
|$8$|$8$|$0$|
|$9$|$6,0$|$0,0$|  

我们最多需要对多少个数位进行改变小木棍数量的操作呢？可以发现，第一位需要小木棍最多的情况，是从第二位拿走两根木棒来 $7\to 2$，那此时第二位最多也就从第三位拿走一根木棒来 $8\to 2\to 0$，第三位就直接 $8\to 0$ 了。  
经过上述分析，我们发现了一个极其重要的性质：**我们之前构造出的数字，和最优答案，只有前三位可能会不一样**。  

所以把除了前三位都填 $8$，然后再暴力枚举前三位即可。  
这样的复杂度是 $O\left(T(n+10^3)\right)$ 的，还可以把前三位所有情况预处理，后面查询的时候直接查表，时间复杂度为 $O(10^3+Tn)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int nd[1005]={6,2,5,5,4,5,6,3,7,6};
int minn[105];
void work(){
	int n; cin>>n;
	if(n==1){
		cout<<"-1\n";
		return;
	}
	string ans;
	while(n>21){
		n-=7;
		ans.push_back('8');
	}
	cout<<minn[n]<<ans<<'\n';
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	for(int i=1;i<=999;i++){//打表
		nd[i]=nd[i%10];
		if(i>9)nd[i]+=nd[i/10];
		if(!minn[nd[i]])minn[nd[i]]=i;
	}
	int T; cin>>T;
	while(T--)work();
	return 0;
}
```

---

## 作者：Quartz_Blocks (赞：34)

### CSP-J 2024 T3 DP Solution

看到很多朋友都是使用找规律解决此题的。这里给出一种 dp 的解法。

首先，我们先列出对于每一个数字，它需要多少木棒。

$$\text{数字：}[0,1,2,3,4,5,6,7,8,9]$$
$$\text{木棒：}[6,2,5,5,4,5,6,3,7,6]$$

设 $dp_i$ 为使用 $i$ 根木棒所能够拼出的最小数字。

那我们可以人工推导出 $dp$ 数组的 $1$ 至 $7$ 项

$$[-1,1,7,4,2,6,8]$$

其中，由于 $1$ 根木棒没有办法组成，记为 $dp_1 = -1$。由于不能出现前导 $0$，这里我们暂且将 $dp_6$ 设为 $6$。

由于组成 $1$ 个字符需要 $2$ 至 $7$ 根木棒，那么我们可以得出以下状态转移方程式：

$$dp_i = \min(dp[j] \times 10 + dp[i-j])$$

其中，$dp_1$ 至 $dp_7$ 可以人工进行处理。

但是，前文提到我们将 $dp_6$ 设为 $6$，所以我们需要特殊判断 $i - j = 6$ 的情况。这种情况下，只需要在末尾加上 $0$ 即可。

问题来了：数字太大 `long long` 也会炸，怎么处理？

那就需要请出高精度了。

我这里使用的是 `string` 模拟的高精度，**注意 MLE!**

由于这是 dp,且 $dp_i$ 最多依赖到 $dp_{i-7}$，所以可以使用滚动数组。

于是就有了 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
//0 1 2 3 4 5 6 7 8 9
//6,2,5,5,4,5,6,3,7,6;
string sum[15] = {"-1","-1","1","7","4","2","6","8"};//预处理的 dp 前 7 位
string dp[15];
string mn(string x,string y){//比较大小
	if(x.length() != y.length()) return (x.length() > y.length() ? y : x);
	return x > y ? y : x;
}
string res[55];
int T,N[55],_N;
void solve(int n){
	dp[0] = dp[1] = "-1";
	for(int i = 2;i <= n;i++){
		dp[i%8] = "0";//初始化
		dp[i%8] = dp[(i-2+8)%8]+sum[2];//初始化
		if(i <= 7) dp[i] = sum[i];//对于较小的数字
		for(int j = i-2;j >= 0 && j >= i-7;j--){
			if(dp[j%8] != "-1") dp[i%8] = mn(dp[i%8],dp[j%8]+sum[i-j]);
			if(dp[j%8] != "-1" && dp[j%8] != "0" && i-j == 6) dp[i%8] = mn(dp[i%8],dp[j%8]+"0");
		}
		for(int j = 1;j <= T;j++){//循环数组需要即时记录答案
			if(N[j] == i) res[j] = dp[i%8];
		}
	}
}	


int main(){
	ios::sync_with_stdio(0);
	cin >> T;
	for(int i = 1;i <= T;i++){//优化，直接将 n 存进数组里，不用重复计算 dp
		cin >> N[i];
		_N = max(_N,N[i]);
	}
	
	solve(_N);
	for(int i = 1;i <= T;i++){
		if(res[i] == "") cout << "-1";//特殊情况 1
		cout << res[i] << endl;
	}
	
	return 0;
}

```

---
题外话：很遗憾赛时作者并没有使用滚动数组。

[~~沉重悼念~~](https://www.luogu.com.cn/discuss/975938)

---

## 作者：Walter_Fang (赞：29)

### 题意
用 $n$ 根小木棍摆数，所摆的数不含前导零，求可摆的数的最小值。
### 解析
首先根据题意可以直接打出一个爆搜，代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll inf=2e9,f[10]={6,2,5,5,4,5,6,3,7,6};
ll i,ans;
void dfs(ll gz,ll x){
	if(gz>i)return;
	if(gz==i)return ans=min(ans,x),void();
	for(ll i=0;i<=9;i++){
		if(i==0&&gz==0)continue;
		dfs(gz+f[i],x*10+i);
	}
}
int main(){
	for(i=1;i<=40;i++){
		ans=inf;
		dfs(0,0);
		cout<<i<<"的答案是"<<ans<<'\n';
	}
}
```
然后我们可以得出 $1\leq n\leq40$ 时的答案如下。（搜到 $40$ 就炸了，实测如果把变量 $x$ 换成 `string` 类型能搜到 $50$ 左右）。

![](https://cdn.luogu.com.cn/upload/image_hosting/aaqrowsz.png)

再瞥一眼特殊性质，不难发现答案跟 $7$ 有点关系，所以将打出的表按对 $7$ 取模的元素整理一下，如下表。

![](https://cdn.luogu.com.cn/upload/image_hosting/glm1avu1.png)

相信做过这一步的人这题都过了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int f[10]={0,-1,1,7,4,2,6,8,10};
int T,n,d,i;
int main(){
	for(cin>>T;T--;){
		cin>>n;
		if(n<=8)cout<<f[n];
		else{
			d=n%7;
			if(!d)for(i=1;i<=n/7;i++)cout<<8;
			if(d==1){
				cout<<10;
				for(i=1;i<n/7;i++)cout<<8;
			}
			if(d==2){
				cout<<1;
				for(i=1;i<=n/7;i++)cout<<8;
			}
			if(d==3){
				if(n==10)cout<<22;
				else{
					cout<<200;
					for(i=1;i<=n/7-2;i++)cout<<8;
				}
			}
			if(d==4){
				cout<<20;
				for(i=1;i<n/7;i++)cout<<8;
			}
			if(d==5){
				cout<<2;
				for(i=1;i<=n/7;i++)cout<<8;
			}
			if(d==6){
				cout<<6;
				for(i=1;i<=n/7;i++)cout<<8;
			}
		}
		cout<<'\n';
	}
}
```

---

## 作者：离散小波变换° (赞：26)

提供一个简易的 dp 做法。

## 题解

注意到 $A<B$ 有以下两个充分不必要条件：

- $|A|<|B|$；
- $A_1<B_1$。

我们设 $f_i$ 表示使用**恰好** $i$ 根小木棍最少拼出来**多少位**。

现在要求解使用 $n$ 根小木棍拼出来的最小数字，枚举最高位放置 $x$（假设用了 $w$ 根小木棍），剩下来的 $n-x$ 根木棍会拼出来 $f_{n-x}$ 位。于是我们找使得 $f_{n-x}$ 最小的 $x$，若有多个取最小的 $x$。这个 $x$ 一定是最优的。

于是只要求出 $f$ 数组，就可以贪心求解。

容易得到 $f$ 数组转移方程，其中 $w_j$ 表示拼出数字 $j$ 需要几根小木棍：

$$f_{i}=\min_{0\le j\le 9}\{{f_{i-w_j}}+1\} $$

于是可在 $\mathcal O(n)$ 复杂度内求解。

注意处理一下第一个数字不为 $0$ 的限制。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 3;
int N[MAXN], M[MAXN], H[MAXN];

const int INF = 1e9;

const vector<int> S = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };

#define endl "\n"

int main(){
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);

    int h = 1e5;
    N[0] = 0;
    for(int i = 1;i <= h;++ i){
        N[i] = INF;
        for(int j = 0;j <= 9;++ j){
            int x = j, w = S[j];
            if(i >= w){
                int y = N[i - w] + 1;
                if(y < N[i]){
                    N[i] = y;
                    M[i] = x;
                    H[i] = w;
                }
            }
        }
    }

    int T;
    cin >> T;
    while(T --){
        int n;
        cin >> n;

        int u = INF, m = 0, h = 0;
        for(int i = 1;i <= 9;++ i){
            int x = i, w = S[i];
            if(n >= w){
                int y = N[n - w] + 1;
                if(y < u){
                    u = y;
                    m = x;
                    h = w;
                }
            }
        }
        if(u == INF){
            cout << -1 << endl;
        } else {
            string ANS;
            ANS += '0' + m, n -= h;

            while(n){
                ANS += '0' + M[n], n -= H[n];
            }
            cout << ANS << endl;
        }
    }


    return 0;
}
````

---

## 作者：czh___ (赞：19)

思路：
我是先打了个表，然后推出了可以将题意理解为将每个 $n$ 取余七，再特判每一种情况，具体如表（计 $n \mod 7$ 为 $m$）：


|$m$|$ans$|
|:-:|:-:|
|$1$|$10$ 后面 $\frac{(n-8)}{7}$ 个 $8$|
|$2$|$1$ 后面 $\frac{(n-2)}{7}$ 个 $8$|
|$3$|$200$ 后面 $\frac{(n-17)}{7}$ 个 $8$|
|$4$|$20$ 后面 $\frac{(n-11)}{7}$ 个 $8$|
|$5$|$2$ 后面 $\frac{(n-5)}{7}$ 个 $8$|
|$6$|$6$ 后面 $\frac{(n-6)}{7}$ 个 $8$|
|$0$|$\frac{n}{7}$ 个 $8$|

代码就很好写了（记得特判！）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		if(n==1){
			cout<<"-1\n";
			continue;
		}
		if(n==2){
			cout<<"1\n";
			continue;
		}
		if(n==3){
			cout<<"7\n";
			continue;
		}
		if(n==4){
			cout<<"4\n";
			continue;
		}
		if(n==5){
		    cout<<"2\n";
		    continue;
		}
		if(n==10){
			cout<<"22\n";
			continue;
		}
		int k=n%7;
		switch(k){
			case 0:{
				for(int i=1;i<=n/7;i++)
					cout<<8;
				break;
			}
			case 1:{
				cout<<10;
				for(int i=1;i<=(n-8)/7;i++)
					cout<<8;
				break;
			}
			case 2:{
				cout<<1;
				for(int i=1;i<=(n-2)/7;i++)
					cout<<8;
				break;
			}
			case 3:{
				cout<<200;
				for(int i=1;i<=(n-17)/7;i++)
					cout<<8;
				break;
			}
			case 4:{
				cout<<20;
				for(int i=1;i<=(n-11)/7;i++)
					cout<<8;
				break;
			}
			case 5:{
				cout<<2;
				for(int i=1;i<=(n-5)/7;i++)
					cout<<8;
				break;
			}
			case 6:{
				cout<<6;
				for(int i=1;i<=(n-6)/7;i++)
					cout<<8;
				break;
			}
		}
		cout<<"\n";
	}
	return 0;
}
```

拜拜！祝大家~~和我~~一等！

---

## 作者：zflll (赞：17)

## 一种没人讲的新思路 — 算最小位数+贪心

不论使用哪种思路，都要先将每个数需要的木棍数算出来
这里我用一个 $a$ 数组记录。

| 数字 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|---|---|
|木棍个数| 6 | 2 | 5 | 5 | 4 | 5 | 6 | 3 | 7 | 6 |

我们发现，**任意给定一个数字 $x$，都能算出 $n=x$ 时 最优解的位数。**

具体方法：  
假设先用使用木棍最多的 *数字8* 进行填充，  
剩下的木棍数（$<7$）选择合适的数字填充即可，  
如剩下 1 个木棍，则去掉一个 8，换上 1 和 0（或其它可行组合）即可。
```cpp
int minlen(int x){
  if(x%7 == 0) return x/7;
  else return x/7+1;
}
```
**知道最优解位数以后，就可以开始填充了。**  
  
从结果的最高位开始，**对于每一位数，$i$ 枚举 $0-9$：**  
**如果这里填上 $i$ 时，成功使最优解位数变小了 $1$，说明这里填 $i$ 是正确的**。  

**注意：1.最后一位数就不能贪心了，要选择合适的数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.需要考虑前导 0 问题**
  
**Code:**
```cpp
bool firsttime = true;
while(n>7){
  for(int i=0; i<=9; i++)
    if(firsttime && i==0) continue;//第一位数不能为0
    if(minlen(n-a[i]) < minlen(n)){
      cout<<i;
      n-=a[i];//a[i]前面说过，为数字i所需木棍个数
      break;
    }
    firsttime = false;
}
if(n==7) cout<<8<<endl;
if(n==6) cout<<0<<endl;
if(n==5) cout<<2<<endl;
if(n==4) cout<<4<<endl;
if(n==3) cout<<7<<endl;
if(n==2) cout<<1<<endl;
```
有些聪明的小朋友就会问了：如果剩下 $n=1$ 怎么办呢：  
如果 $n=1$，那么最后两位数就要填 $01$，不如将它作为 $10$ 放在最前面，结果更小，所以此情况不会发生（除下列特殊情况）。

**最后，一定记得特判特殊数据：**
- 输入为 $6$ ，输出为 $6$
- 输入为 $1$ ，输出为 $-1$（除 1 外，稍微想一想可得其他数都能通过 2-7 七个数凑出来）

**具体代码将上面三部分整合即可**

upd：@[__Cow__ ](https://www.luogu.com.cn/user/589272) Q: 为什么使位数小1就证明是答案？  
A: 因为每次位数都小 1，最终位数 = 正解位数, 而最终位数对的情况下 计算过程会保证数最小。

10.28upd : 本蒟蒻写的时候过于仓促导致代码出现了问题，目前已改正。**感谢 @[ny_Dacong](https://www.luogu.com.cn/user/928972) 的[更正与完整AC代码提供](https://www.luogu.com.cn/discuss/979743)**

---

## 作者：4041nofoundGeoge (赞：14)

这道题看起来是用搜索算法，实则是一个数论大题。

### 题外话

本人差 $2.5$ 分就可以进二轮了，后来题目公布，我立马做完发现这道题不太适合当 T3，大概 T2 难度。

## 思路

如果你骗分，能得到 $50\%$ 的分数，正解是数论找规律。

假设我们把所有位数都设置成 $8$，则如果结果大于 $n$，我们就可以减少木棍数量。即 $n=7k-t$，其中 $k$ 为位数，$t$ 为减去几根木棍。

我们分类讨论 $t$ 等于多少：

1. 如果 $t=0$，无需去除木棍。
2. 如果 $t=1$，去除第一位的一个木棍变成 $6$。
3. 如果 $t=2$，去除第一位的两个木棍变成 $2$。
4. 如果 $t=3$，去除第一位的两个木棍变成 $2$，去除第二位的一个木棍变成 $0$。
5. 如果 $t=4$，去除第一位的两个木棍变成 $2$，去除第二位的一个木棍变成 $0$，去除第三位的一个木棍变成 $0$。
6. 如果 $t=5$，去除第一位的五个木棍变成 $1$。
7. 如果 $t=6$，去除第一位的五个木棍变成 $1$，去除第二位的一个木棍变成 $0$。

但这样有缺陷，比如如果 $t=4$ 需要去除 $3$ 位，但是如果 $n=7\times2-4=10$，只有两位，或者 $n=7\times1-4=3$。这些情况需要特判。

愣着干什么，赶紧去写代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,ans;
int stick[10]={6,2,5,5,4,5,6,3,7,6}; 
int main(){
  //freopen("sticks.in","r",stdin);
	//freopen("sticks.out","w",stdout);
	cin>>t;
	while(t--){
		cin>>n;
		if(n==1)cout<<-1;
		else if(n==2)cout<<1;
		else if(n==3)cout<<7;
		else if(n==4)cout<<4;
		else if(n==5)cout<<2;
		else if(n==6)cout<<6;//上面是算出来的
		else if(n==7)cout<<8;
		else if(n%7==0)for(int i=1;i<=n/7;i++)cout<<8;
		else if(n%7==1){
			cout<<10;
			for(int i=1;i<=(n-8)/7;i++)cout<<8;
		}
		else if(n%7==2){
			cout<<1;
			for(int i=1;i<=(n-2)/7;i++)cout<<8;
		}
		else if(n%7==3){
			if(n==10)cout<<22;
			else {
				cout<<200;
				for(int i=1;i<=(n-17)/7;i++)cout<<8;
			}
		}
		else if(n%7==4){
			cout<<20;
			for(int i=1;i<=(n-11)/7;i++)cout<<8;
		}
		else if(n%7==5){
			cout<<2;
			for(int i=1;i<=(n-5)/7;i++)cout<<8;
		}
		else if(n%7==6){
			cout<<6;
			for(int i=1;i<=(n-6)/7;i++)cout<<8;
		}//类似抽屉原理
		puts("");
	}
	return 0;
}

```
最后祝大家 CSP 拿一等奖！

---

## 作者：HuangBarry (赞：13)

思路：找规律。  
过程：
1. 打出 $1$ 到 $25$ 的答案。（此处 DFS 即可）
2. 找的 $N\bmod7$ 分别等于 $1$ 到 $6$ 的规律，可得：

|$N\bmod7$|答案开头|$N$ 需减去的值|
|:-:|:-:|:-:|
|$1$|$10$|$8$|
|$2$|$1$|$2$|
|$3$|$7$|$3$|
|$4$|$4$|$4$|
|$5$|$2$|$5$|
|$6$|$6$|$6$|

$N$ 减去对应的值后，$N\div7$ 等于几，就后接多少个 $8$。  
4. 找特例，可发现以下数不符合上要求：  


|不符合上表格要求的数|答案|$N$ 需减去的数|
|:-:|:-:|:-:|
|$1$|-1|/|
|$10$|22|/|
|符合 $(N-11)\bmod7=0$（$N\ge11$）的数|开头为 $20$|$11$|
|符合 $(N-17)\bmod7=0$（$N\ge17$）的数|开头为 $200$|$17$|

接下来就可实现代码。  
代码如下：
```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define Made return
#define by 0
#define Barry +0
using namespace std;
int t,n;
string ans;
int main(){
	cin>>t;
	while(t--){
		ans="";
		cin>>n;
		if(n==1){
			cout<<-1<<endl;
			continue;
		}else if(n==10){
			cout<<22<<endl;
			continue;
		}
		if(n>=11&&(n-11)%7==0){
			ans+="20";
			n-=11;
		}else if(n>=17&&(n-17)%7==0){
			ans+="200";
			n-=17;
		}else
			switch(n%7){
				case 1:
					ans+="10";
					n-=8;
					break;
				case 2:
					ans+="1";
					n-=2;
					break;
				case 3:
					ans+="7";
					n-=3;
					break;
				case 4:
					ans+="4";
					n-=4;
					break;
				case 5:
					ans+="2";
					n-=5;
					break;
				case 6:
					ans+="6";
					n-=6;
					break;
		}
		while(n){
			ans+="8";
			n-=7;
		}
		cout<<ans<<endl;
	}
	Made by Barry;
}
```

---

## 作者：cjrqwq (赞：10)

考场思路：奇妙枚举法。~~最复杂的方法~~

题面信息：

- $0$ 要 $6$ 个木棍。
- $1$ 要 $2$ 个木棍。
- $2$ 要 $5$ 个木棍。
- $3$ 要 $5$ 个木棍。
- $4$ 要 $4$ 个木棍。
- $5$ 要 $5$ 个木棍。
- $6$ 要 $6$ 个木棍。
- $7$ 要 $3$ 个木棍。
- $8$ 要 $7$ 个木棍。
- $9$ 要 $6$ 个木棍。

那最简单的方法就是枚举所有数字个数，然后比较他们的字典序，预处理所有答案。但是太慢了，优化一下。

有一个数字集合 $S$，$S$ 能够被 $S_{1}$ 替换，当且仅当它们位数相同且字典序更小，或是位数更小的某些数字替换，并且还要 $S,S_{1}$ 所用的小木棍数量相同，就说：

- 选七个 $0$ 没有六个 $8$ 优。
- 选两个 $1$ 没有一个 $4$ 优。
- 选四个 $2$ 没有三个 $0$ 和一个 $1$ 优。
- 选一个 $3$ 没有一个 $2$ 优。
- 选两个 $4$ 没有一个 $2$ 和一个 $6$ 优。
- 选一个 $5$ 没有 $2$ 优。
- 选两个 $6$ 没有一个 $6$ 和一个 $0$ 优。
- 选两个 $7$ 没有一个 $6$ 优。
- 选 $8$ 的数量没有限制。
- 选一个 $9$ 没有 $0$ 优。

如果选了前者，那么可以替换成后者且一定更优，即不可能选择这样的情况。我们证明了最多选择各个数字的个数，它们如下：

- $0$：$6$ 个。
- $1$：$1$ 个。
- $2$：$3$ 个。
- $3$：$0$ 个。
- $4$：$1$ 个。
- $5$：$0$ 个。
- $6$：$1$ 个。
- $7$：$1$ 个。
- $8$：任意个。
- $9$：$0$ 个。

所以我们枚举一下，就好啦。

大概要循环 $7\times2\times 4 \times 2 \times 2\times 2 \times 10^5 \div 7 = 6.4\times 10 ^ 6$ 次。带一个比较，常数比较大，但是可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

struct NUM{
	int a[7];
}a[100010];

bool operator > (const NUM &A, const NUM &B) {
	int sumA = A.a[0] + A.a[1] + A.a[2] + A.a[3] + A.a[4] + A.a[5] + A.a[6];
	int sumB = B.a[0] + B.a[1] + B.a[2] + B.a[3] + B.a[4] + B.a[5] + B.a[6];
	
	if(sumA == A.a[0]) return 1;
	if(sumB == B.a[0]) return 0;
	if(sumA != sumB) return sumA > sumB;
	
	int F0 = 1, F1 = 1;
	for(int i=6;i>0;i--) {
		if(A.a[i]) { F0=i;}
		if(B.a[i]) { F1=i;}
	}
	if(F0 != F1) return F0 > F1;
	
	sumA = 0, sumB = 0;
	for(int i=0;i<7;i++) {
		sumA += A.a[i], sumB += B.a[i];
		if(sumA != sumB) return sumA < sumB;
	}
	return 0;
}
int main() {
//	freopen("sticks.in","r",stdin);
//	freopen("sticks.out","w",stdout);
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int n; cin>>n;
	for(int _0=0;_0<=6;_0++) {
		for(int _1=0;_1<=1;_1++) {
			for(int _2=0;_2<=3;_2++) {
				for(int _4=0;_4<=1;_4++) {
					for(int _6=0;_6<=1;_6++) {
						for(int _7=0;_7<=1;_7++) {
							for(int _8=0;_8<=1e5/7;_8++) {
								int Q = _0*6+_1*2+_2*5+_4*4+_6*6+_7*3+_8*7;
								if(Q > 1e5) continue;
								NUM tmp = {_0,_1,_2,_4,_6,_7,_8};
								if(a[Q] > tmp) a[Q] = tmp;
							}
						}
					}
				}
			}
		}
	}
	while(n--) {
		int x; cin>>x; 
		int sum = 0;
		for(int i=0;i<7;i++) sum += a[x].a[i];
		if(sum == 0 || sum == a[x].a[0]) cout<<-1;
		else {
			int F0 = 1;
			for(int i=6;i>0;i--) {
				if(a[x].a[i]) { F0=i;}
			}
			a[x].a[F0]--;
			if(F0 == 0) cout<<0;
			if(F0 == 1) cout<<1;
			if(F0 == 2) cout<<2;
			if(F0 == 3) cout<<4;
			if(F0 == 4) cout<<6;
			if(F0 == 5) cout<<7;
			if(F0 == 6) cout<<8;
			for(int i=0;i<7;i++) {
				for(int j=1;j<=a[x].a[i];j++) {
					if(i == 0) cout<<0;
					if(i == 1) cout<<1;
					if(i == 2) cout<<2;
					if(i == 3) cout<<4;
					if(i == 4) cout<<6;
					if(i == 5) cout<<7;
					if(i == 6) cout<<8;
				}
			}
			a[x].a[F0]++;
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：grard4 (赞：7)

~~这么水的 T3 这辈子不多了。~~

众所周知：~~爆搜挂着机，打表出省一~~

首先确定能够作为答案的数字


|数字|1|2|3|4|5|6|7|8|9|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|代价|2|5|5|4|5|6|3|7|6|6|

题目要求拼出来的数字最小，显然花费相同的代价，一定是优先选最小的数字。

因此整理下来，能够作为答案的数字只会有：

$1(2)$，$2(5)$，$4(4)$，$6(6)$，$7(3)$，$8(7)$，$0(6)$（其中括号内为代价）

此时就可以用各种神仙方法搜出小范围的答案。

由于这题没给大样例，所以我们可以猜测答案可能存在某种规律。所以我们尝试着爆搜出 $n$ 从 $1$ 到 $99$ 的答案。（下面记 $f[i]$ 为 $n=i$ 时的答案）


```
f[1]=-1
f[2]=1
f[3]=7
f[4]=4
f[5]=2
f[6]=6
f[7]=8
f[8]=10
f[9]=18
f[10]=22
f[11]=20
f[12]=28
f[13]=68
f[14]=88
f[15]=108
f[16]=188
f[17]=200
f[18]=208
f[19]=288
f[20]=688
f[21]=888
f[22]=1088
f[23]=1888
f[24]=2008
f[25]=2088
f[26]=2888
f[27]=6888
f[28]=8888
f[29]=10888
f[30]=18888
f[31]=20088
f[32]=20888
f[33]=28888
f[34]=68888
f[35]=88888
f[36]=108888
f[37]=188888
f[38]=200888
f[39]=208888
f[40]=288888
f[41]=688888
f[42]=888888
f[43]=1088888
f[44]=1888888
f[45]=2008888
f[46]=2088888
f[47]=2888888
f[48]=6888888
f[49]=8888888
f[50]=10888888
f[51]=18888888
f[52]=20088888
f[53]=20888888
f[54]=28888888
f[55]=68888888
f[56]=88888888
f[57]=108888888
f[58]=188888888
f[59]=200888888
f[60]=208888888
f[61]=288888888
f[62]=688888888
f[63]=888888888
f[64]=1088888888
f[65]=1888888888
f[66]=2008888888
f[67]=2088888888
f[68]=2888888888
f[69]=6888888888
f[70]=8888888888
f[71]=10888888888
f[72]=18888888888
f[73]=20088888888
f[74]=20888888888
f[75]=28888888888
f[76]=68888888888
f[77]=88888888888
f[78]=108888888888
f[79]=188888888888
f[80]=200888888888
f[81]=208888888888
f[82]=288888888888
f[83]=688888888888
f[84]=888888888888
f[85]=1088888888888
f[86]=1888888888888
f[87]=2008888888888
f[88]=2088888888888
f[89]=2888888888888
f[90]=6888888888888
f[91]=8888888888888
f[92]=10888888888888
f[93]=18888888888888
f[94]=20088888888888
f[95]=20888888888888
f[96]=28888888888888
f[97]=68888888888888
f[98]=88888888888888
f[99]=108888888888888
```
这时规律就显而易见了。

可以发现答案从左往右第四位及以后的数都是唯一的（后面全都是 $8$）。

对于答案的前三位，我们可以发现对于任意的正整数 $k\ge 3$，$1\le i \le7$，$f[7*k+i]$ 的前三位一定等于 $f[i+14]$ 的前三位。

所以打表只需打到前 $21$ 个就可以了。对于 $n>21$，我们一定会先拼出若干个 $8$，使得剩下的火柴棍的个数在 $[15,21]$ 的范围内，假设拼出了 $k$ 个 $8$，则答案的前三位一定是 $f[n-k*7]$，后面紧接着 $k$ 个 $8$ 就行了。

于是最简短的代码它来了！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,f[22]={0,-1,1,7,4,2,6,8,10,18,22,20,28,68,88,108,188,200,208,288,688,888};
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		if (n<=21){
			if (n==1) puts("-1");
			else cout<<f[n]<<"\n";
		}
		else{
			int k=ceil(1.0*(n-21)/7);
			cout<<f[n-k*7];
			while(k--) putchar('8');
			cout<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：Cheng118 (赞：7)

### 题目大意

$n$ 根木棒摆数字，求摆出的最小值。

### 题目思路

数学题。

由图可知：

|数字|$0$|$1$|$2$|$3$|$4$|$5$|$6$|$7$|$8$|$9$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|需要的木棒数|$6$|$2$|$5$|$5$|$4$|$5$|$6$|$3$|$7$|$6$|

消耗木棒最多的数是 $8$，消耗 $7$ 根木棒，所以尽量多摆 $8$。

根据特性 $A$ 和 $B$，可 ~~投机取巧~~ 得出：

当 $n \bmod 7$ 等于 $0$ 时，摆 $\frac{n}{7}$ 个 $8$ 数位最小，最优；

当 $n \bmod 7$ 等于 $1$ 时，把第一个 $8$ 改为 $0$ ，多出的 $1$ 根与 $n \bmod 7$ 余下的 $1$ 在首位摆一个数字 $1$ ，再摆 $(\lfloor \frac{n}{7} \rfloor -1)$ 个 $8$，数位最小，最优。

以此类推：

当 $n \bmod 7$ 等于 $2$ 时，在首位摆一个 $1$，再摆 $\lfloor \frac{n}{7} \rfloor$ 个 $8$，数位最小，最优。

当 $n \bmod 7$ 等于 $3$ 时，注意，当 $n < 17$ 时，把第一个 $8$ 改为 $2$ ，多出的 $2$ 根与 $n \bmod 7$ 余下的 $3$ 在首位摆一个数字 $2$ ，再摆 $(\lfloor \frac{n}{7} \rfloor -1)$ 个 $8$，数位最小，最优。否则，把前两个 $8$ 改为两个 $0$，多出的 $2$ 根与 $n \bmod 7$ 余下的 $3$ 在首位摆一个数字 $2$，数位最小，最优。

当 $n \bmod 7$ 等于 $4$ 时，把第一个 $8$ 改为 $0$ ，多出的 $1$ 根与 $n \bmod 7$ 余下的 $4$ 在首位摆一个数字 $2$ ，再摆 $(\lfloor \frac{n}{7} \rfloor -1)$ 个 $8$，数位最小，最优。

当 $n \bmod 7$ 等于 $5$ 时，多出的 $5$ 根在首位摆一个数字 $2$ ，再摆 $\lfloor \frac{n}{7} \rfloor$ 个 $8$ 数位最小，最优。

当 $n \bmod 7$ 等于 $6$ 时，用 $n \bmod 7$ 余下的 $6$ 在首位摆一个数字 $6$ ，再摆 $\lfloor \frac{n}{7} \rfloor$ 个 $8$ 数位最小，最优。

~~这么简单就不用代码了吧~~

---

## 作者：Starmoon_dhw (赞：6)

# Solution
提供一种贪心的思路。

由于构造的数要求最小，所以我们要保证构造的数的位数最少，也要保证越前面的数越小，所以我们可以在可以取的情况下尽可能的取小的数。

所以我们可以一位位的填，每一位最多只有 $7$ 种可能，因为用相同的木棍，我们肯定拼接小的数字，所以我们可以把这些数字以及所需的木棍数用结构体储存，如下：

```cpp
a[1].mugun=2;
a[1].num=1;
a[2].mugun=3;
a[2].num=7;
a[3].mugun=4;
a[3].num=4;
a[4].mugun=5;
a[4].num=2;
a[5].mugun=6;
a[5].num=0;
a[6].mugun=6;
a[6].num=6;
a[7].mugun=7;
a[7].num=8;
```

注意由于 $0$ 不能做第一位数字，所以我们有需要把 $6$ 也存起来，然后最好按照数字大小排序，当然也可以在赋值的时候做好这件事情、

接下来我们需要求出构造出的数字的位数，很好求为：$(n-1)/7+1$ ，因为只有在位数最小的的前提下才可以让构造数的前面的数字最小。

注意，由于 $1$ 无法处理所以我们需要特判，并且因为 $0$ 不能开头所以需要一个 $flag$ 来判断是否可以使用 $0$。

# Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
struct node{
	int mugun,num;
}a[15];
bool cmp(node a,node b)
{
	return a.num<b.num;
}
signed main()
{
	a[1].mugun=2;
	a[1].num=1;
	a[2].mugun=3;
	a[2].num=7;
	a[3].mugun=4;
	a[3].num=4;
	a[4].mugun=5;
	a[4].num=2;
	a[5].mugun=6;
	a[5].num=0;
	a[6].mugun=6;
	a[6].num=6;
	a[7].mugun=7;
	a[7].num=8;
	sort(a+1,a+1+7,cmp);
	cin>>T;
	while(T--)
	{
		cin>>n;
		
		if(n==1)
		{
			cout<<"-1\n";
			continue;
		}
		int ws=(n-1)/7+1;
		int flag=1;
		while(ws>0)
		{
			for(int i=1;i<=7;i++)
			{
				if((ws-1)*7>=n-a[i].mugun&&n>=a[i].mugun)
				{
					if(a[i].num==0&&flag)
						continue;
					ws--;
					cout<<a[i].num;
					flag=0;
					n-=a[i].mugun;
					break;
				}
			}
		}
		cout<<"\n";
		
	 } 
	return 0;
}

```

---

## 作者：liyunhe (赞：4)

### 主题思路
这是考场思路。  
首先将各个 $n$ 的最小值列出来。发现所有答案中，除了前两位外，全是 $8$，然后证了一下。首先，摆出 $8$ 的使用数量最多，所以摆出的位数最少。然后当除了后两位都是 $8$ 的答案，如果将前三位修改。最小值通过枚举，第三位仍然是 $8$。这是我的第一次写代码。  
然而，突然发现在除了最高位以外发现 $28$ 完全可以替换为 $00$。加了一个特判即可。  
数据大小不超过 $2\times10^{5}$ 不需要开 `long long`。
### 代码code
```cpp
#include<bits/stdc++.h>
using namespace std;
             //n=0, 1,2,3,4,5,6,7, 8, 9,10,11,12,13,14
int min_st[25]={-1,-1,1,7,4,2,6,8,10,18,22,20,28,68,88};//注意由于是放在头部，不能加前导零
void slove(){
	int n;
	cin>>n;
	if(n<=1)cout<<-1;
	else if(n<=14)cout<<min_st[n];
	else{
		int k=n%7;
		if(k==0){
			for(int i=1;i<=n/7;i++)cout<<8;
		}else{
			k+=7;
			if(k==10){//22+8... 情况的特判
				cout<<200;
				for(int i=1;i<=(n-k)/7-1;i++)cout<<8;
			}else{
				cout<<min_st[k];
				for(int i=1;i<=(n-k)/7;i++)cout<<8;
			}
		}
	}
	cout<<endl;
	return;
}
int main() {
	int T;cin>>T;
	while(T--)slove();
    return 0;
}
```

---

## 作者：ylch (赞：4)

提供一种新思路。很简单，基于爆搜。

对于找规律的做法，在许多题解中都有说明。我们由特殊性质和暴力打表可知，这道题的关键在 $8$ 这个数字上。

附：$n=1 \sim 39$ 时的爆搜表（来自 @[Walter_Fang](https://www.luogu.com.cn/article/9jkp68vn)）

![](https://cdn.luogu.com.cn/upload/image_hosting/aaqrowsz.png)

我们可以发现，最终答案一定是由其他数字和若干个 $8$ 组成。那么有一个显然的思路：把结尾固定的 $8$ 的个数算出来，然后剩下的前面几位爆搜确定最优答案。

确定 $8$ 的个数：因为 $8$ 需要用 $7$ 个木棍，所以我们考虑从 $21$ 开始（前面的不好找规律，直接爆搜），将每 $7$ 个作为一组固定的 $8$ 的个数。公式：$cnt_n=\lfloor\dfrac{n-14}{7}\rfloor$。

爆搜：当 $n \le 20$ 时，直接暴力即可；因为题目要求数字尽可能小，所以当要用的木棍个数相同时（例如 $[2,3,5]$ 和 $[6,9]$），我们应优先使用数值更小的（$2$ 和 $6$），这样保证最优。

代码比较简洁易懂：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 10;

int T, num[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
//              0  1  2  3  4  5  6  7  8  9
string ans;
bool cmp(string s, string t){
	if(s.size() == t.size()) return s < t;
	return s.size() < t.size();
}

void dfs(int n, string s){
	if(n == 0){
		if(ans == "" || cmp(s, ans)) ans = s;
		return ;
	}
	for(int i = 0; i < 10; i ++){
		if(s == "" && i == 0) continue;
		if(i == 3 || i == 5 || i == 9) continue;
		if(n >= num[i]) dfs(n - num[i], s + to_string(i));
	}
}

void solve()
{
	ans = ""; // 清空！！！
	int n; cin >> n;
	if(n == 1) cout << -1 << '\n';
	else if(n <= 20){
		dfs(n, "");
		cout << ans << '\n';
	}
	else{
		string tmp = string((n - 14) / 7, '8');
		dfs(n - (n - 14) / 7 * 7, "");
		cout << ans + tmp << '\n';
	}
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int T; cin >> T;
	while(T --) solve();
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

这题我也是找规律做的

# 题目大意
给你一个正整数 $n$，求这 $n$ 根木棍能摆出的不含前导 $0$ 的最小整数。

# 思路
首先发现数字 $8$ 需要的木棍数量是最多的，所以我们可以考虑在末尾全输出 $8$，然后在前三位找规律，特殊性质告诉我们考虑 $n$ 除以 $7$ 的余数即可。

设 $n$ 除以 $7$ 的余数为 $m$。

- 首先特判 $n\le 10$ 的情况，打表即可。
- $m=0$，直接输出 $n/7$ 个 $8$ 即可。
- $m=1$，先借一个 $7$，先输出 $10$。
  - 然后直接输出 $(n-8)/7$ 个 $8$。
- $m=2$，先输出 $1$。
  - 然后直接输出 $(n-2)/7$ 个 $8$。
- $m=3$，先输出 $200$。
  - 然后直接输出 $(n-17)/7$ 个 $8$。
- $m=4$，先输出 $20$。
  - 然后直接输出 $(n-11)/7$ 个 $8$。
- $m=5$，先输出 $2$。
  - 然后直接输出 $(n-5)/7$ 个 $8$。
- $m=6$，先输出 $6$。
  - 然后直接输出 $(n-6)/7$ 个 $8$。

记得要换行！

## Solution：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,ans[11]={-1,-1,1,7,4,2,6,8,10,18,22};
int main(){
    cin>>t;
    while(t--){
    	cin>>n;
    	int m=n%7;
    	if(n<=10)cout<<ans[n];
    	else if(m==0)for(int i=1;i<=n/7;i++)cout<<8;
    	else if(m==1){
    		cout<<10;
    		n-=8;
    		for(int i=1;i<=n/7;i++)cout<<8;
		}else if(m==2){
    		cout<<1;
    		n-=2;
    		for(int i=1;i<=n/7;i++)cout<<8;
		}else if(m==3){
			cout<<200;
	    	n-=17;
	    	for(int i=1;i<=n/7;i++)cout<<8;
		}else if(m==4){
    		cout<<20;
    		n-=11;
    		for(int i=1;i<=n/7;i++)cout<<8;
		}else if(m==5){
    		cout<<2;
    		n-=5;
    		for(int i=1;i<=n/7;i++)cout<<8;
		}else if(m==6){
    		cout<<6; 
    		n-=6;
    		for(int i=1;i<=n/7;i++)cout<<8;
		}
		cout<<'\n';
	}
    return 0;
}
```
RP++

---

## 作者：Lijunzhuo (赞：2)

这道题可以先使用动态规划来做。设计 `DP[i]` 表示使用 $i$ 个火柴所摆出的最小方案，代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
const int D[]={6,2,5,5,4,5,6,3,7,6};
string A[N];
int T,n;
string mymin(string a,string b)
{
	if(a=="") return b;
	if(b=="") return a;
	if(a.length()>b.length()) return b;
	if(a.length()<b.length()) return a;
	return a<b?a:b;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			A[i]="";
		for(int i=1;i<n;i++)
		{
			for(int j=0;j<=9;j++)
			{
				int x=i-D[j];
				if(x<0||(x!=0&&A[x]=="")) continue;
				A[i]=mymin(A[i],(char)(j+'0')+A[x]);
			}
		}
		for(int j=1;j<=9;j++)
		{
			int x=n-D[j];
			if(x<0||(x!=0&&A[x]=="")) continue;
			A[n]=mymin(A[n],(char)(j+'0')+A[x]);
		}
		if(A[n]=="") printf("-1\n");
		else printf("%s\n",A[n].c_str());
	}
	return 0;
}
```
这个代码显然是过不了的，所以我们要进行优化。

特殊性质给我们了些启发：我们可以分类讨论，一起讨论每堆除以 $7$ 的余数相同的数（**较小的数直接打表输出即可，只分类讨论大数字。分类讨论时可以使用如上动态规划代码总结规律**）。

- 当 $n$ 为 $7$ 的倍数时：答案为 $\dfrac{n}{7}$ 个 $8$。
- 当 $n$ 除以 $7$ 余 $1$ 时：答案以 $10$ 为开头，再加上 $\left\lfloor\dfrac{n}{7}\right\rfloor-1$ 个 $8$。
- 当 $n$ 除以 $7$ 余 $2$ 时：答案以 $1$ 为开头，再加上 $\left\lfloor\dfrac{n}{7}\right\rfloor$ 个 $8$。
- 当 $n$ 除以 $7$ 余 $3$ 时：答案以 $200$ 为开头，再加上 $\left\lfloor\dfrac{n}{7}\right\rfloor-2$ 个 $8$。（**注意：当 $n$ 为 $10$ 时：答案为 $22$！**）
- 当 $n$ 除以 $7$ 余 $4$ 时：答案以 $20$ 为开头，再加上 $\left\lfloor\dfrac{n}{7}\right\rfloor-1$ 个 $8$。
- 当 $n$ 除以 $7$ 余 $5$ 时：答案以 $2$ 为开头，再加上 $\left\lfloor\dfrac{n}{7}\right\rfloor$ 个 $8$。
- 当 $n$ 除以 $7$ 余 $6$ 时：答案以 $6$ 为开头，再加上 $\left\lfloor\dfrac{n}{7}\right\rfloor$ 个 $8$。

好了，分类讨论完毕，代码就可以写出来了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		if(n<=1) printf("-1\n");
		else if(n==2) printf("1\n");
		else if(n==3) printf("7\n");
		else if(n==4) printf("4\n");
		else if(n==5) printf("2\n");
		else if(n==6) printf("6\n");
		else if(n%7==0)
		{
			for(int i=1;i<=n/7;i++)
				printf("8");
			putchar('\n');
		}else if(n%7==1)
		{
			printf("10");
			for(int i=1;i<=n/7-1;i++)
				printf("8");
			putchar('\n');
		}else if(n%7==2)
		{
			printf("1");
			for(int i=1;i<=n/7;i++)
				printf("8");
			putchar('\n');
		}else if(n%7==3)
		{
			if(n==10) printf("22\n");
			else
			{
				printf("200");
				for(int i=1;i<=n/7-2;i++)
					printf("8");
				putchar('\n');
			}
		}else if(n%7==4)
		{
			printf("20");
			for(int i=1;i<=n/7-1;i++)
				printf("8");
			putchar('\n');
		}else if(n%7==5)
		{
			printf("2");
			for(int i=1;i<=n/7;i++)
				printf("8");
			putchar('\n');
		}else
		{
			printf("6");
			for(int i=1;i<=n/7;i++)
				printf("8");
			putchar('\n');
		}
	}
	return 0;
}
/*
0 1 2 3 4 5 6 7 8 9
6 2 5 5 4 5 6 3 7 6
*/
```
[记录](https://www.luogu.com.cn/record/185008657)。（注：笔者再考试时先打了动态规划代码，再在距离考试结束还有 $30$ 分钟时打的分类讨论代码。）

---

## 作者：_Yonder_ (赞：1)

我是沙子吗，交了 $9$ 发才过。

你说得对，但是我没想到打表。

可以发现要是没有数字 $0$ 的话，这题就是普通的 dp，于是考虑求出 $1\sim 10^5$ 的不含数字 $0$ 的最大答案。显然不能用字符串存，用大小 $10$ 的数组表示每个数出现几次就行。

求出来后枚举加几个 $0$，取最大值即可。
# Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
struct node{int c[10];}f[N],u,d;
int T,n,w[10]={6,2,5,5,4,5,6,3,7,6};
inline node Min(node x,node y){
	int lx=0,ly=0,a,b;
	for(int i=0;i<=9;i++) lx+=x.c[i];
	for(int i=0;i<=9;i++) ly+=y.c[i];
	if(lx^ly) return lx<ly?x:y;
	for(int i=9;i;i--) if(x.c[i]) a=i;
	for(int i=9;i;i--) if(y.c[i]) b=i;
	if(a^b) return a<b?x:y;
	for(int i=0;i<=9;i++)
		if(x.c[i]^y.c[i])
			return x.c[i]>y.c[i]?x:y;
	return x;
}inline void put(node x){
	int u=9;
	for(int i=9;i;i--) if(x.c[i]) u=i;
	putchar(u+'0');x.c[u]--;
	for(int i=0;i<=9;i++)
		for(int j=x.c[i];j;j--)
			putchar(i+'0');
	putchar('\n');
}
int main(){
	std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	for(int i=0;i<=9;i++) u.c[i]=1e8;
	for(int i=1;i<N;i++){
		f[i]=u;
		for(int j=1;j<=9;j++)
			if(i-w[j]>=0){
				d=f[i-w[j]];d.c[j]++;
				f[i]=Min(f[i],d);
			}
	}
	while(T--){
		cin>>n;
		if(!n) return 1;
		if(n==1){cout<<-1<<endl;continue;}
		node ans=f[n],now;
		for(int i=1;i*6<n;i++)
			now=f[n-i*6],now.c[0]+=i,ans=Min(ans,now);
		put(ans);
	}
	return 0;
}
```

---

## 作者：csxx601cjy (赞：1)

## [CCF CSP-J 2024 T3](https://www.luogu.com.cn/problem/P11229)
## 前言
考完赶忙写的一篇题解，从未见过如此水的 T3。
~~据说有人 DP 写的~~。 
## 题意
用 $n$ 根棒拼尽量小的数（无前导零）。
## 考时思路
先列出 $0\sim9$ 的数字消耗火柴棒数。
$$\{6,2,5,5,4,5,6,3,7,6\}$$

数字中 $8$ 的棒数是最多的，所以尽量多用 $8$，可以使拼成的数字位数最少。其次，前几位也要尽量的小，可以通过找规律的方法，你们自己模拟一下就知道了。

具体可以分情况讨论，同时判断一些特殊情况。

可以设 $n\mod 7$ 为 $m$，将 $0\sim6$ 这些情况分别讨论。

每种情况具体怎么做呢，我会在代码里给你解释。

```cpp
#include<bits/stdc++.h>
#define f(x) for(int i=0;i<x;i++)cout<<8 //输出x个8
using namespace std;
int T,n,m,k;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		m=n%7,k=n/7;//m是n mod 7，k是后面可能输出多少个8
		if(n==1)cout<<-1;//当且仅当n=1时无解
		else if(m==0)f(k);//全是8
		else if(m==1){
			cout<<10;//m=1时最佳方案：108888…
			f(k-1);
		}
		else if(m==2){
			cout<<1;//m=2时最佳方案：188888…
			f(k);
		}
		else if(m==3){
			if(n==3)cout<<7;//特殊情况
			else if(n==10)cout<<22;//特殊情况too
			else{
				cout<<200;//m=3时最佳方案：200888…
				f(k-2);
			}
		}
		else if(m==4){
			if(n==4)cout<<4;//特殊情况tootoo
			else{
				cout<<20;//m=4时最佳方案：208888…
				f(k-1);
			}
		}
		else if(m==5){
			cout<<2;//m=5时最佳方案：288888…
			f(k);
		}
		else{
			cout<<6;//m=6时最佳方案：688888…
			f(k);
		}
		cout<<'\n';//别忘记换行
	}
	return 0;
}
```
祝你们 CSP RP++ !

---

## 作者：Starry_Ocean (赞：1)

目测 300 分，写篇题解稍微~~庆祝一下~~。

考场上刚拿到这个题，我有点疑惑，正常来说，按照 $n$ 给部分分大部分分 $n \le 10$ 和 $n \le 1 \times 10^3$。但这个题很反常，它给了 $n \le 20$ 和 $n \le 50$ 两档部分分。当时我有点怀疑，但是目前暂时没有看出题目的解法，所以无法确定任何事。然后我看了一下，发现性质 A 和 B。此时我又有点疑惑，为什么 $n$ 必须比 100 大。

但是，透过这个部分分，我猜想这个题跟 7 的有关系。我尝试打了一下表，数据范围是 $n \le 30$。然后惊奇地发现，答案里面有大量的 8。我开始考虑 8 这个数有什么特别的。不难看出，写下一个 8 需要 7 根小木棒，是所有数字里消耗最大的。于是不难想到贪心。

说贪心想法前，先问大家一个问题。99 大还是 100 大。显然是 100。由此，我发现，要**尽可能让位数最小**。于是，特殊性质 A 这一档就做出来了。输出 $\frac{n}{7}$ 个 8 即可。配合上暴力代码，数据范围 $n \le 20$。有 40 分。


再次观察答案，不难发现，对于任意 $n$ 除以 7 的余数，答案的前缀都相同。然后呢，就拿下了。

放出考场回忆代码，请好好学习每一档部分分的获取与思路哦。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T;ll n;
bool check(ll n,ll num){
	ll d[10]={6,2,5,5,4,5,6,3,7,6};
	ll cnt=0;
	string x=to_string(num);
	if(x[0]=='0') return false;
	for(ll i = 0;i < x.size();++i){
		if(x[i]=='0') cnt+=d[0];
		if(x[i]=='1') cnt+=d[1];
		if(x[i]=='2') cnt+=d[2];
		if(x[i]=='3') cnt+=d[3];
		if(x[i]=='4') cnt+=d[4];
		if(x[i]=='5') cnt+=d[5];
		if(x[i]=='6') cnt+=d[6];
		if(x[i]=='7') cnt+=d[7];
		if(x[i]=='8') cnt+=d[8];
		if(x[i]=='9') cnt+=d[9];
	}
	return cnt==n;
}
void sub1(){
	bool f=0;
	for(ll i = 1;i <= 1e5+6;++i){
		if(check(n,i)){
			cout << i;
			f=1;
			break;
		}
	}
	if(!f) cout << -1;
}
void sub2(){
	for(ll i = 1;i <= n/7;++i) cout << 8;
}
void sub3(){
	if(n==1) {
		cout << -1;
		return ;
	}
	if(n==8) {
		cout << 10;
		return ;
	}
	n--;
	n/=7;
	n--;
	cout << 10;
	for(ll i = 1;i <= n;++i) cout << 8;
}
ll jc[10]={888,1088,1888,2008,2088,2888,6888};
void sub4(){
	cout << jc[n%7];
	n=n-n%7;
	n/=7;
	n-=3;
	for(ll i = 1;i <= n;++i) cout<<8;
}
int main(){
	cin>>T;
	while(T--){
		
		cin>>n;
		if(n<=20){
			sub1();
		}
		else if(n%7==0&&n>=100){
			sub2();
		}
		else if(n%7==1&&n>=100){
			sub3();
		}
		else {
			sub4();
		}
		cout << endl;
	}
	return 0;
}
```

---


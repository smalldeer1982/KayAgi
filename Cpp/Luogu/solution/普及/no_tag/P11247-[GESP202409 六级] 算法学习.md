# [GESP202409 六级] 算法学习

## 题目描述

小杨计划学习 $m$ 种算法，为此他找了 $n$ 道题目来帮助自己学习，每道题目最多学习一次。

小杨对于 $m$ 种算法的初始掌握程度均为 $0$。第 $i$ 道题目有对应的知识点 $a_i$，即学习第 $i$ 道题目可以令小杨对第 $a_i$ 种算法的掌握程度提高 $b_i$。小杨的学习目标是对于 $m$ 种算法的掌握程度均至少为 $k$。

小杨认为连续学习两道相同知识点的题目是不好的，小杨想请你编写程序帮他计算出他最少需要学习多少道题目才能使得他在完成学习目标的同时避免连续学习两道相同知识点的题目。


## 说明/提示

### 样例 1 解释

一种最优学习顺序为第一道题，第三道题，第四道题，第二道题。

### 数据规模与约定

| 子任务编号 | 数据点占比 | $m$ | $n$ | $b_i$ | $k$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $1$ | $30\%$ | $2$ | $\leq 9$ | $\leq 10$ | $\leq 10$ |
| $2$ | $30\%$ | $\leq 9$ | $\leq 9$ | $\leq 10$ | $\leq 10$ |
| $3$ | $40\%$ | $\leq 10^5$ | $\leq 10^5$ | $\leq 10^5$ | $\leq 10^5$ |

对于全部数据，保证有 $1 \leq m, n, b_i, k \leq 10^5$，$1 \leq a_i \leq m$。

## 样例 #1

### 输入

```
3 5 10
1 1 2 3 3
9 1 10 10 1```

### 输出

```
4```

## 样例 #2

### 输入

```
2 4 10
1 1 1 2
1 2 7 10```

### 输出

```
-1```

# 题解

## 作者：LogicNotFound (赞：20)

### 解题思路：
贪心。

如果没有这句“**避免连续学习两道相同知识点的题目**”的话，贪心策略很简单，计算每个知识点所需的最少题目数，然后相加得到最终结果。如果有某个知识点刷完了所有题目熟练度都不能到 $k$，则输出 $-1$。

那加了这句话，我们多了一步：

- 判断  需要题目数最多的知识点  与 其他知识点的学习顺序  能否交替进行。

那其实就是看：

-  学习其他知识点所需的题目数  是否大于等于  最多的那个知识点的题目数 $-1$  就好。

如果不满足上面条件的话，就看：

-  是否能够通过 多做几个其他知识点的题目来避免连续 ，从而完成学习。

具体看实现过程看代码，有很详细的注释：


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5+7;
vector<int> grasp[N];
int a[N], n, m, k, b;
bool cmp(int a, int b){
	return a > b;
}
int cnt[N]; // 统计掌握每一个知识点所需的最少题目数 

int main(){
	
	cin >> m >> n >> k;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++){
		cin >> b;
		grasp[a[i]].push_back(b); // 添加能提升第 a[i] 个知识点的题目，提升的掌握度为 b  
	}
	
	int ans = 0, maxN = 0, maxP; 
	for(int i = 1; i <= m; i++){ // 计算掌握每一个知识点所需的最少题目数  
		
		sort(grasp[i].begin(), grasp[i].end(), cmp);  // 为每一个知识点中的题目排序，按能够提升的掌握度从高到低 
		int len = grasp[i].size(), sum = 0;
		for(int j = 0; j < len; j++){
			sum += grasp[i][j]; // 第 i 个知识点掌握度增加 
			cnt[i]++;           // 第 i 个知识点需要的题目数增加  
			if(sum >= k){       // 如果第 i 个知识点掌握度 >= k，不需要继续学习  
				break;
			}
		}
		if(sum < k){  // 学完了所有知识，第 i 个知识点掌握度还是不能到 k  
			cout << "-1";   // 那说明掌握不了所有算法  
			return 0; 	    // 输出 -1 后结束 
		}
		ans += cnt[i];    // 总的题目数量加上掌握第 i 个知识点所需的题目数  
		if(maxN < cnt[i]) maxN = cnt[i], maxP = i;  // 更新所需题目数最多的知识点  
	}
	if(ans - maxN >= maxN - 1){  
		// 学习其他知识点所需的题目数 >= 所需题目数最多的知识点 - 1 
		// 说明所需题目数最多的知识点 与 其他知识点的学习顺序能够交替，则不会出现连续学习两道相同知识点的情况 
		cout << ans; // 直接输出题目总数即可 
	}
	else{  // 否则，则看是否能够通过多做几个其他知识点的题目来避免连续，从而完成学习 
		
		int remainder = 0; // 计算其他知识点剩余题目数量 
		for(int i = 1; i <= m; i++){   
			if(i != maxP)  remainder += grasp[i].size() - cnt[i];  // 第 i 个知识点剩余题目数量 = 总数 - 用掉的  
		}
		if(ans - maxN + remainder >= maxN - 1){  // 如果学习其他知识点所需的题目数 + 其他知识点剩余题目数量 >=  所需题目数最多的知识点 - 1  
			// 说明能够通过多做几个其他知识点的题目来避免连续 
			cout << 2*maxN - 1;  // 那么最少数量就是 maxN + maxN - 1 
		}
		else{  // 否则还是无法避免连续  
			cout << "-1";  // 无法完成  
		}	
	} 
	return 0;
}

```

---

## 作者：herezz (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P11247)  
一道贪心题。  
将每一道题目排序，主要按算法种类排序（可升可降），次要按好处降序排序。遍历 $n$ 道题目，如果必须做（熟练度还没达到要求时），就做它，并记录每一种算法要做的题目数和总做题目数。  
再判断是不是每个算法都足够掌握了，以及会不会连续做两道重复类型的题。第二个就有点难了：  
最致密的做题方法是：做一道这个算法的题，再做一道其他类型的题，一题一题的交错地做，所以我们只需要判断这个算法要做的题的数量是否大于其他题目的总数，如果是，那么要补题补到条件不成立为止，如果做不到，输出 $-1$。
## code：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+10;
struct problem{
	int a,b;
}t[MAXN];
bool cmp(problem x,problem y){
	if(x.a!=y.a)return x.a<y.a;
	else return x.b>y.b;
}
int n,m,k,ans[MAXN],sum,c[MAXN];
int main(){
	cin>>m>>n>>k;
	for(int i=0;i<n;i++){
		cin>>t[i].a;
		t[i].a--;//输入从1开始，这里从0开始（个人习惯） 
	}
	for(int i=0;i<n;i++){
		cin>>t[i].b;
	}
	sort(t,t+n,cmp);
	for(int i=0;i<n;i++){
		if(c[t[i].a]<k){
			ans[t[i].a]++,sum++,c[t[i].a]+=t[i].b;//没有必要就不做 
		}
	}
	for(int i=0;i<m;i++){//特判 
		if(c[i]<k){
			cout<<-1;
			return 0;
		}
	}
	for(int i=0;i<m;i++){//特判 
		if(ans[i]>sum-ans[i]+1){//如果不能一题一题的交错，就不符合题意
			if(ans[i]*2<=n){//补题 
				sum=ans[i]*2;
				break;
			}
			cout<<-1;
			return 0;
		}
	}
	cout<<sum;
	return 0;
}
```
蒟蒻的题解，求过。

---

## 作者：Death_Cai (赞：7)

# 题解：P11247 [GESP202409 六级] 算法学习

这是一道很好的贪心题，但是有一些细节很重要。
  
这道题可以用动态数组存储每道题的掌握度。

然后从大到小判断掌握度够不够，如果够了就退出循环，如果把所有的掌握度都加完都没达到目标掌握度，那直接输出 - 1，然后直接结束。接着还要判断加的熟练度的个数能否被其他的掌握度分开，如果不能也要输出 - 1，最后输出最少学习的个数。

接下来上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define str stringstream
#define fo(i,a,b) for(int i=(a),I=(b);i<=I;i++)
//stringstream字符串流
const int N=1e5+5;
int m,n,k,a[N],ans,b[N],maxx,maxid;
vector<int>g[N];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>m>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1,x;i<=n;i++){
		cin>>x;
		g[a[i]].push_back(x);//保存每道题的每个掌握度
	}
	for(int i=1;i<=m;i++){
		int sum=0;
		sort(g[i].begin(),g[i].end(),greater<int>());//从大到小排序
		for(int j=0;j<g[i].size();j++){
			sum+=g[i][j];
			if(sum>=k){b[i]=j+1;break;}//判断是否达到目标掌握度
		}
		if(sum<k)return cout<<-1,0;//判断如果全加完还没达到目标掌握度
		ans+=b[i];//加上熟练度的个数
		if(b[i]>maxx)maxx=b[i],maxid=i;//记录最多相加的熟练度的个数
	}
	if(maxx-1<=ans-maxx)return cout<<ans,0;//判断是否能插
	int tot=0;
	for(int i=1;i<=m;i++)if(i!=maxid)tot+=g[i].size()-b[i];//继续计算
	if(maxx-1<=ans-maxx+tot)cout<<2*maxx-1;//再判断能不能插
	else cout<<-1;
	return 0;
}
```

感谢阅读

---

## 作者：fly_and_goal (赞：6)

# 题目大意
有 $m$ 种算法，初始掌握度均为零，有 $n$ 道题用来辅助提高掌握度（每一道题目只会对应提高一个算法），要求在不连续学习两道对应算法相同的题目的情况下使 $m$ 种算法掌握度均提高至 $k$ 以上，最少需学习几题，如果无法完成上述条件，输出负一。
# 分析
这是一道贪心题，输入后先按每道题目能增加的掌握度从大到小排序。之后便利 $n$ 道题目，如该题对应算法掌握度已达标，就跳过，否则该题对应算法掌握度就加上学习该题可以增加的算法掌握度。
# 注意
还要用两个数组分别记录该算法掌握度和学习了几道对应此算法的题目，如果学习了几道对应此算法的题目数量大于一共学习题目数量的一半，那就输出负一。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,k,f[100005],d[100005],sum,ans;//定义
struct node{
	long long s,w;
}a[100005];//题目对应算法和提高掌握度值用结构体保存
bool cmp(node i,node j)
{
	return i.w>j.w;
}//排序
int main()
{
	cin>>m>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i].s;
	for(int i=1;i<=n;i++) cin>>a[i].w;
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++)
	{
		if(f[a[i].s]>=k) continue;//如果无需学习，那么跳过
		else
		{
			f[a[i].s]+=a[i].w;//算法掌握度加上该题提高量
			d[a[i].s]++;//记录该算法学了几题
			sum++;//所有算法学习题目量+1
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(d[i]>sum-d[i]+1||f[i]<k)
		{
			cout<<-1;
			return 0;
		}//如果该算法学习题目数量大于总学习题目数量，或学了所有该题算法也无法达标，输出负一
	}
	cout<<sum;
}
```

---

## 作者：Aventurine_stone (赞：4)

## 1. 题目分析
一道很明显的贪心题。
## 2. 题目做法
题目要求让学习题目的数量最少，那么对于每个知识点，我们要尽量选提升掌握度更高的题目，当此知识点掌握度 $\ge k$ 时，我们便不再选择关于此知识点的题目。  
方便计算，建议先用 sort 排一下序。  
计算完后，如果有知识点的掌握度 $< k$，那么无解。  
因为不能连续学习同一个知识点的题目。设要学习的题目总数量为 $sum$，有知识点需要学习 $x$ 题，那么若 $x > sum -x + 1$，那么无解。  
若有解，则输出 $sum$ 即可。  
总时间复杂度 $O(n \log{n})$。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int m,n,k,sum;
struct node{
	int a,b;
}a[N],b[N];
inline bool cmp(node a1,node a2)
{
	return a1.a==a2.a?a1.b>a2.b:a1.a<a2.a;
}
bool p;
int main()
{
	m=read(),n=read(),k=read();
	for(int i=1;i<=n;i++)
		a[i].a=read();
	for(int i=1;i<=n;i++)
		a[i].b=read();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		if(a[i].a!=a[i-1].a)
			p=0;
		if(!p)
			b[a[i].a].a+=a[i].b,b[a[i].a].b++;
		if(b[a[i].a].a>=k)
			p=1;
	}
	for(int i=1;i<=m;i++)
	{
		if(b[i].a<k)
		{
			printf("-1");
			return 0;
		}
		sum+=b[i].b;
	}
	for(int i=1;i<=m;i++)
		if(b[i].b>sum-b[i].b+1)
		{
			printf("-1");
			return 0;
		}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：末然Ender (赞：2)

# 题解：P11247 [GESP202409 六级] 算法学习

一眼顶针，鉴定为~~唐~~水题。

## 思路

这道题算法是贪心。

贪心策略如下：

- 首先，如果存在一种算法无法被练习，那么无解；
- 其次，如果有一种算法的所有题都练习完了还是无法熟练掌握，那么无解；
- 然后，对于每种算法的练习题，我们应当优先去做对掌握程度贡献最大的，所以**对于每一种算法的练习题应当从大到小排序后再取，且如果取到了 $k$ 的掌握度就不再取了**。同时，做题顺序应该是每种算法如果掌握的还不够就先做一个该算法的题目，然后去做下一个算法的题，能尽量避免连续学习两道相同算法，所以不妨设最少做题量需求最大的算法需求做 $p$ 道题，次大的需要做 $q$ 道题，如果 $p>q+1$，那么无解，否则答案即为每个题所需求最少做题量的总和。

这个题通过率有点低但是难度完全属于水黄，以下是代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
/*以上快读快输*/
typedef long long ll;
const int N=1e5+5;
ll n,m,k;
ll a[N],b[N];
vector<ll> v[N];
bool cmp(ll a,ll b){
	return a>b;
}
ll ls[N],idx;
ll sum[N],cnt[N],ans;
int main() {
	read(m,n,k);
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<=n;i++)read(b[i]);
	for(int i=1;i<=n;i++){
		v[a[i]].push_back(b[i]);
	} 
	for(int i=1;i<=m;i++){
		if(v[i].empty()){//如果有个算法无法被题目训练那么必定无解 
			puts("-1");
			return 0;
		}
		sort(v[i].begin(),v[i].end(),cmp);
		for(auto x:v[i]){
			sum[i]+=x,cnt[i]++;
			if(sum[i]>=k)break;
		}
		if(sum[i]<k){
			puts("-1");
			return 0;
		}
		ans+=cnt[i];
	}
	sort(cnt+1,cnt+1+n);//其实不用排序在上面维护最大和次大值即可，但是排序复杂度也正确 
	if(cnt[n]>cnt[n-1]+1)
		puts("-1"); 
	else
		write(ans);
	return 0;
}
```

---

## 作者：lin_A_chu_K_fan (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11247)

蒟蒻的第~~亿~~篇题解，求关~
# 题意
有 $n$ 道题目和 $m$ 个算法，每个算法需要 $k$ 的掌握度才能过关。

 每道题目有一个掌握度和一个算法种类。

问在不能连续做两道同算法的题的情况下，至少做多少道题才能过关全部算法。
# 思路
首先这题要用贪心才能满分。

先对所有题目按提升值排序，然后对于每一个算法，优先选择掌握度高的，这样就可以让掌握一个算法需要的题目最少。注意不能连续做算法相同的两道题目。

若做完所有题目都没有达标，或必会出现两道相同算法的题目连续做，则输出 $-1$。

蒟蒻码风过丑，就不放了。

---

## 作者：Andy1101 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P11247)
# 思路
## 普通思路
开一个结构体数组，存放 $a,b$ 两个数据（$a$ 表示每道题目的知识点，$b$ 表示每道题目提升的掌握程度）。

随后按照此排序方法排序：

- 如果 $a$ 不同，以 $a$ 从小到大排序。
- 否则，按照 $b$ 从大到小排序。

核心代码：

```cpp
bool cmp(node x,node y)
{
	if(x.a!=y.a) return x.a<y.a;
	else return x.b>y.b;
}
```
## 特判
特判1：是否能保证可以不连续学习两道相同知识点的题目。

特判2：每个科目掌握程度之和是否大于 $k$。

如果以上两点有一个不符合要求，那么就输出 $-1$。
# AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct node
{
	int a,b;	
} v[N];
int h[N];
long long sum[N];
bool cmp(node x,node y)
{
	if(x.a!=y.a) return x.a<y.a;
	else return x.b>y.b;
}
void err(int n,int m,int k)
{
	//1
	int maxx=INT_MIN;
	for(int i=1;i<=m;i++)
	{
		maxx=max(maxx,h[i]);
	}
	int t=n/2;
	if(n%2==0) { if(maxx>t) { cout <<-1; exit(0); } }
	else { if(maxx>t+1) { cout <<-1; exit(0); } }
	//2
	for(int i=1;i<=n;i++)
	{
		sum[ v[i].a ]+=v[i].b;
	}
	for(int i=1;i<=m;i++)
	{
		if(sum[i]<k)
		{
			cout <<-1;
			exit(0);
		}
	}
}
int main()
{
	int m,n,k;
	cin >>m>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin >>v[i].a;
		h[v[i].a]++;
	}
	for(int i=1;i<=n;i++) cin >>v[i].b;
	err(n,m,k);
	sort(v+1,v+n+1,cmp);
	int cur=1;
	int flag=1;
	int cnt=0;
	int kk=k;
//	for(int i=1;i<=n;i++)
//	{
//		cout <<v[i].a<<" "<<v[i].b<<'\n';
//	}
	for(int i=1;i<=n;i++)
	{
		if(v[i].a!=cur) cur++,kk=k,flag=1;
		if(kk>0)
		{
			kk-=v[i].b;
			cnt++;
		}
	}
	cout <<cnt;
	return 0;
}

```
最后的最后，求管理员大人通过。

---

## 作者：huangzilang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11247)

**题目大意**

计算出要写多少道题才可以使小杨的每个知识点的掌握程度都大于等于 $k$，并且不能连续做两道相同知识点的题目，每道题目最多学习一次。

**输入**


给出 $n,m,k$，代表算法种类数，题目数和目标掌握程度。
然后再输入 $n$ 个正整数，代表每道题目的知识点。
再输入 $n$ 个正整数，代表每道题目提升的掌握程度。

**思路**

我们可以先用个结构体，表示第 $i$ 个知识点的掌握程度。
再用一个桶，表示第 $i$ 种知识点的第 $tot$ 道题的掌握程度。然后一个循环，一个 $tot$ 表示第 $tot$ 个知识点，一个 $s_i$ 表示第 $tot$ 个知识点的掌握程度总和，并且每次加完后，第 $tot$ 个知识点的个数就减一，若这个知识点的数量为零，就输出 $-1$。

**正确代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int ann[100005],b;
struct ds
{
	int sf;
	int hg;
}x[100005];
map<int,map<int,int> >a;
int sfsl[100005];
int s[100005];
bool bz[100005]={0};
bool cmp(ds xxx,ds yyy)
{
	return xxx.hg <yyy.hg ;
}
int main()
{
	cin>>m>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>ann[i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>b;
		x[i].sf =ann[i];
		x[i].hg =b;
	}
	sort(x+1,x+n+1,cmp);
	for(int i=1;i<=n;i++)
		a[x[i].sf ][++sfsl[x[i].sf ]]=x[i].hg ;
	int t=0,ans=0,tot=0;
	while(t!=m)
	{
		tot++;
		if(tot==m+1)
			tot=1;
		if(bz[tot]==0)
		{
			ans++;
			s[tot]+=a[tot][sfsl[tot]];
			sfsl[tot]--;
			if(s[tot]>=k)
			{
				bz[tot]=1;
				t++;
			}
			else
			{
				if(sfsl[tot]==0)
				{
					cout<<"-1";
					return 0;
				} 
			} 
		}
	}
	cout<<ans;
}
```

---


# [GESP202409 七级] 小杨寻宝

## 题目描述

小杨有一棵包含 $n$ 个节点的树，树上的一些节点放置有宝物。

小杨可以任意选择一个节点作为起点并在树上移动，但是小杨只能经过每条边至多一次，当小杨经过一条边后，这条边就会消失。小杨每经过一个放置有宝物的节点就会取得该宝物。

小杨想请你帮他判断自己能否成功取得所有宝物。

## 说明/提示


### 样例 1 解释

对于第一组测试用例，小杨从节点 $2$ 出发，按照 $2-1-3-4$ 的顺序即可成功取得所有宝物。

### 数据规模与约定

| 子任务编号 | 数据点占比 | $t$ | $n$ |
| :-: | :-: | :-: | :-: |
| $1$ | $20\%$ | $\leq 10$ | $\leq 5$ |
| $2$ | $20\%$ | $\leq 10$ | $\leq 10^3$ |
| $3$ | $60\%$ | $\leq 10$ | $\leq 10^5$ |

对全部的测试点，保证 $1 \leq t \leq 10$，$1 \leq n \leq 10^5$，$0 \leq a_i \leq 1$，且保证树上至少有一个点放置有宝物。

## 样例 #1

### 输入

```
2
5
0 1 0 1 0
1 2
1 3
3 4
3 5
5
1 1 1 1 1
1 2
1 3
3 4
3 5
```

### 输出

```
Yes
No
```

# 题解

## 作者：Jason_Ming (赞：32)

### 思路

根据题意我们可以知道，不管寻宝的路线怎么安排，都**不能走回头路**。

也就是说，一个节点最多只会被访问**一次**，从这个节点出去了就不能回来了。

那么，如果有一个节点有**大于等于三条边**都直接或间接地连接到了有宝物的节点，那么就无法得到所有宝物，我们暂且称之为**不幸点**。

我们以下图为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/busez9gm.png)

显然 $1$ 号节点是不幸点。假设四个节点都有宝物。

如果以 $1$ 号节点为起点，那么不论下一步去哪个节点，都不可能再回来了，也就不可能获得另外两个节点的宝物。

如果以另外三个节点中的一个为起点，那么走到 $1$ 节点后就会遇到岔路口，只能进行二选一的选择，也无法获得全部的宝物。

同理可得，如果 $1$ 号节点连接了大于三条边，同样无法获得全部宝物。

如果 $2$、$3$、$4$ 号节点连接了其他节点，那么不管其他节点与这三个节点怎么连接，最后都会在 $1$ 号节点这里面临选择。

---

现在考虑如何 $O(n)$ 求出一棵树上是否有不幸点。

我们记树上有宝物的节点的数量为 $b$，以 $x$ 为根节点的子树所包含的宝物数量为 $ans_x$，以 $x$ 的子节点为根的子树中有宝物的子树数量为 $p_x$。

当 $p_x > 2$ 的时候，节点 $x$ 为不幸点。

我们知道，除根节点和叶子节点之外，所有的节点都会有一条连接父亲节点的边和若干连接子节点的边。

那么，当 $ans_x \ne b$ 的时候就说明节点 $x$ 的父亲节点的方向的节点（即不属于以 $x$ 为根的子树的节点）中一定有宝物。那么，当 $p_x > 1$ 的时候，节点 $x$ 为不幸点。

综上，当 $p_x > 2$ 时，或者当 $ans_x \ne b$ 且 $ p_x > 1$ 时，节点 $x$ 为不幸点。

如何求 $ans_x$ 呢？很简单，只需要把节点 $x$ 的所有子节点的 $ans$ 加起来，如果节点 $x$ 有宝物的话再加 $1$。

由于无论哪个节点作为根节点都不会影响结果，所以我们可以从任意一个节点出发，在遍历整棵树的过程中进行求解。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

bool flag;//记录能否获得全部宝物 
int t,n,b;//b 代表树上共有多少个节点有宝物 
int a[100005];
vector <int> vec[100005];

int search(int x,int f)//返回以 x 为根节点的树（子树）共有多少个结点有宝物。f 代表 x 的父亲节点。 
{
	if(vec[x].size()==1&&vec[x][0]==f)
	{
		return a[x];
	}
	int ans=0,p=0;//ans 记录所有以 x 为根节点的子树的宝物总数，p 记录以 x 的子节点为根的子树中有多少棵子树有宝物 
	for(int i:vec[x])//遍历节点 x 的所有边 
	{
		if(i!=f)
		{
			int l=search(i,x);
			if(l)
			{
				p++;
				ans+=l;
			}
		}
	}
	ans+=a[x];
	if((ans!=b&&p>1)||p>2)flag=false;//发现不幸点 
	return ans;
}

int main()
{
	cin>>t;
	while(t--)
	{
		flag=true;
		b=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			vec[i].clear();//多测要清空 
			cin>>a[i];
			if(a[i])b++;
		}
		for(int i=1;i<n;i++)
		{
			int x,y;
			cin>>x>>y;
			vec[x].push_back(y);
			vec[y].push_back(x);
		}
		search(1,0);//树的根节点可以随便取一个 
		if(flag)
		{
			cout<<"Yes"<<endl;
		}
		else
		{
			cout<<"No"<<endl;
		}
	}
}
```

**拒绝抄袭，从我做起。**

---

## 作者：Redamancy_Lydic (赞：9)

题目显然等价于问所有宝箱是否在一条链上。

稍微转化一下题意，即我们现在要找到一条链，使得这条链上有宝物的节点数量尽可能多。

想到这里我们发现这个和树的直径比较相似，那么我们直接大胆将深度定义为从根到这个节点上有宝箱节点的数量，然后做一遍树的直径。最后判断直径长度是否等于所有有宝箱节点的数量即可。

做完以后我们发现这道题过了，其实证明也很简单。我们考虑把价值转到边上，即对于所有有宝箱的节点，让它所连的所有边长度都加上一。因为如果一条路径经过这条边，那么它一定也经过这个点，所以这样给边赋权后跑树的直径是对的，即上述思路正确。

## Code

```cpp
#include<bits/stdc++.h>
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>
#define int long long							
using namespace std;
//using namespace  __gnu_pbds;
//tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> tr;//从小到大
//int findnum(int k){auto it=tr.find_by_order(k-1);return ((it!=tr.end())?(*it):1e9+7);}//查元素
//int findrank(int x){return tr.order_of_key(x)+1;}//查排名
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int maxn=3e5+10;
const int mod=998244353;
const int inf=1e9+7;
int n,a[maxn],dep[maxn];
vector<int> G[maxn];
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+(a[x]==1);
	for(auto y : G[x])
	{
		if(y==fa)continue;
		dfs(y,x);
	}
}
void Main()
{
	n=read();
	for(int i=1;i<=n;i++)dep[i]=0,G[i].clear();
	int sum=0;
	for(int i=1;i<=n;i++)a[i]=read(),sum+=a[i];
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs(1,0);
	int ma=-1,id=0;
	for(int i=1;i<=n;i++)
	{
		if(dep[i]>ma)
		{
			ma=dep[i];
			id=i;
		}
	}
	for(int i=1;i<=n;i++)dep[i]=0;
	dfs(id,0);
	ma=-1;
	for(int i=1;i<=n;i++)
	{
		ma=max(ma,dep[i]);
	}
	puts(ma==sum?"Yes":"No");
}
signed main()
{
#ifdef Lydic
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
	int T=read();
	while(T--)Main();
    return 0;
}
```

---

## 作者：Little_x_starTYJ (赞：6)

### 前言
谔谔，本来是 [liaoxingrui](https://www.luogu.com.cn/user/744895) 请我来帮忙调代码的，但是我也调了很久。最后写了一堆小优化才过的。

### 解题思路
很明显，我们需要 dfs 遍历这棵树。

仔细阅读题面，就会有两个发现：
- 满足题意的路径一定是一条链。
- 在该路径上的所有点，都满足只有一棵子树中有宝藏。

于是我们可以枚举起始点，进行 dfs，如果某个点有多棵子树有宝藏，那么我们直接返回无解。

但是这样是会超时的。

我们又可以想到，这条路径如果开头是有宝藏的，并且结尾也是有宝藏的，举个例子 $10010101$，其中 $1$ 代表有宝藏，$0$ 表示没有宝藏，它那么一定比 $0\dots0100101010\dots0$ 更优。

于是我们可以把枚举所有点改为枚举所有有宝藏的点。就可以过这道题了。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100010], number;
vector<int> v[100010];
inline int dfs(int x, int fa, int cnt) {
	int res = cnt + a[x];
	if (res == number) {
		return -1;   //哈哈，很奇怪， 表示有解
	}
	int m = 0;
	for (auto u : v[x]) {
		if (u ^ fa) {  //同 u != fa
			int t = dfs(u, x, res);
			if (t == -1) {
				return -1;
			}
			m += (t == 1 ? 1 : 0);   //有宝藏的子树个数 
			if (m > 1 || t == 114514) {
				return 114514;  //无解
			}
		}
	}
	return m + a[x] > 0;
}
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int t;
	cin >> t;
	while (t--) {
		number = 0;
		bool flag = false;

		int n;
		cin >> n;
		for (int i = 1; i <= n; i++) {
			cin >> a[i];
			if (a[i])
				number++;
		}
		for (int i = 1; i < n; i++) {
			int x, y;
			cin >> x >> y;
			v[x].push_back(y);
			v[y].push_back(x);
		}
		for (int i = 1; i <= n; i++) {
			if (a[i]) {
				if (dfs(i, 0, 0) == -1) {
					cout << "Yes\n";
					flag = true;
					break;
				}
			}
		}
		if (!flag) {
			cout << "No\n";
		}
		for (int i = 1; i <= n; i++) {
			while (!v[i].empty())
				v[i].pop_back();
		}
	}
	return 0;
}
```

---

## 作者：WhiteNight__ (赞：4)

# [题解：P11249 [GESP202409 七级] 小杨寻宝](https://www.luogu.com.cn/problem/P11249)

## 题目大意

给定一棵树，有 $N$ 个节点，有的节点上藏有宝藏。从任意节点出发，每一条边只可以经过一次，问有无方案使得可以经过树上的全部宝藏。

## 基本思路

容易发现，如果存在可行方案，可行的路径一定是一条**链**。那么基于这一个特性，我们可以想到一个别致的方法——删点法。

我们可以删去对寻宝没有贡献的节点，那么什么节点对寻宝没有贡献呢？如果我们以**任意藏有宝藏的节点为根**建有根树，可以发现如果第 $x$ 号节点对寻宝没有贡献，那么 $x$ 不藏有宝藏且 $x$ 的子节点对寻宝没有贡献（或 $x$ 为叶子节点）。

基于以上的删点思想，我们就可以写出 Delete 函数，其中用 $cl_{i}$ 表示第 $i$ 号节点有无被删除，$cl_{i}=1$ 表示该节点被删除。


```cpp
bool Delete (int u , int fa) // 记录当前节点和父节点
{
	bool down = g[u]; // 判断该节点是否有宝藏
	for(auto i : v[u])
	{
		if(i != fa) // 没有走过的节点就去访问
		{
			down = Delete(i , u) || down;
			// 只要子节点有贡献，该节点也有贡献
		}
	}
	if(!down) // 无贡献则删除
	{
		cl[u] = true;
	}
	return down;
}
```

删点完成后剩下的节点都是对寻宝有贡献的节点，只要判断有贡献的节点是否组成一条链即可。

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <vector>
using namespace std;

int T , N , st , t[200050]; 
// t数组用于统计有贡献节点的度，若ti>=3则不是一条链
vector <int> v[100050];
bitset <100050> g , cl; // 用bitset代替bool，作用和bool差不多
bool ans;

bool Delete (int u , int fa) // 记录当前节点和父节点
{
	bool down = g[u]; // 判断该节点是否有宝藏
	for(auto i : v[u])
	{
		if(i != fa) // 没有走过的节点就去访问
		{
			down = Delete(i , u) || down;
			// 只要子节点有贡献，该节点也有贡献
		}
	}
	if(!down) // 无贡献则删除
	{
		cl[u] = true;
	}
	return down;
}

int main()
{
	scanf("%d",&T);
	while (T --)
	{
		scanf("%d",&N);
		g.reset(); // 全部初始化为0
		cl.reset();
		memset (t , 0 , sizeof t);
		ans = true;
		for(int i = 1 ; i <= N ; i ++)
		{
			int x;
			scanf("%d",&x);
			g[i] = x;
			if(x == 1) st = i;
			v[i].clear();
		}
		for(int i = 1 ; i <= N-1 ; i ++)
		{
			int x , y;
			scanf("%d%d",&x,&y);
			v[x].push_back(y);
			v[y].push_back(x);
		}
		Delete(st,-1); // 以宝藏节点为根建树
		
		for(int i = 1 ; i <= N ; i ++)
		{
			if(!cl[i]) // 该节点必须有贡献
			{
				for(auto j : v[i])
				{
					if(!cl[j]) ++ t[i];
					if(t[i] >= 3) // 不是一条链
					{
						printf("No\n");
						ans = false;
						break;
					}
				}
			}
			if(!ans) break;
		}
		if(ans) printf("Yes\n");
	}
	
	
	return 0;
}
```

---

## 作者：Crasole (赞：4)

## 思路

因为这是一颗无根树，所以我们可以令一个有宝物等节点为根，设为 $root$，这样方便后续操作。

接着，遍历每个节点，若以这个节点为根等子树中的所有节点均没有宝物，那么就删除这个节点，对于删除这个节点的操作，只需要用一个 $del$ 数组标记就可以了。

接着只要判断这颗树在删除后是否为一条链即可。

令 $s_i$ 表示节点 $i$ 的子节点个数，若这棵树是一条链等话，则满足：

- 对于根节点 $root$，有 $s_{root} \le 2$。

- 对于不为根等任意节点 $i$，有 $s_i \le 1$。

最后因为是多测，不要忘了清空数据。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int t, n, root;
bool flag;
bool has[N], del[N];
vector <int> e[N];
//判断是否为链
void dfs(int u, int fa) {
	int cnt = 0;
	for(int& v : e[u]) {
		if(v == fa || del[v]) continue;
		++ cnt, dfs(v, u);
	}
	if(u == root) {
		if(cnt > 2) flag = true;
	}
	else {
		if(cnt > 1) flag = true; 	
	}
	return;
}
//删除操作
void dele(int u, int fa) {
	bool f = true;//f表示子节点是否有宝物
	for(int& v : e[u]) {
		if(v == fa) continue;
		dele(v, u);
		if(!del[v]) f = false;
	}
	if(f && !has[u]) del[u] = true;
    //若子节点没有宝物且自己也没有宝物，那么删除
	return;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	cin >> t;
	while(t --) {
		memset(del, false, sizeof del);
		cin >> n;
        //has[i]表示节点i是否有宝物
		for (int i = 1; i <= n; ++i) cin >> has[i];
        //建树
		for (int i = 1; i < n; ++i) {
			int u, v;
			cin >> u >> v;
			e[u].push_back(v), e[v].push_back(u);
		}
        //找根
        for (int i = 1; i <= n; ++i)
            if(has[i]) {
                root = i;
                break;
            }
		dele(root, 0);
		flag = false, dfs(root, 0);
		cout << (!flag ? "Yes" : "No") << '\n';
		for (int i = 1; i <= n; ++i) e[i].clear();
	}
	return 0;
}
```

---

## 作者：linjinkun (赞：2)

提供一种没有在题解区出现的解题思路。

使用树形 dp。

设 $f_x$ 表示以 $x$ 为路径起点或终点最大能拿到多少宝藏。

那么状态转移是 $f_x = \max(f_v+a_x)$。$v$ 指的是 $x$ 的儿子，你以为这么简单？不不不，还没完，因为如果有条路径并非是 $x$ 作为起点或终点怎办？所以我们还需要找到 $x$ 的两个儿子 $v1$ 和 $v2$，$v1 \not= v2$，$f_{v1}+f_{v2}+a_x$ 就是 $x$ 不作为路径起点或终点时的贡献，自然地，我们要使 $f_{v1}+f_{v2}+a_x$ 最大化，也就是使 $f_{v1}+f_{v2}$ 最大化，那就只需要找到 $x$ 的儿子中 $f$ 最大的和第二大的就行了。解释一下为什么是 $f_{v1}+f_{v2}+a_x$，请看下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/od4gckem.png)

假设 $x$ 是 $1$，那么它作为中点（就是不是起点也不是终点），他只能用以 $2$ 开头的路径中最大拿宝藏数量加上以 $3$ 开头的路径中最大拿宝藏数量再加上当前节点是否有宝藏，因为它只能找到两个不同的儿子进行扩散，所以就是 $f_{v1}+f_{v2}+a_x$。

记得清空！！！

代码（有注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
int a[N];
vector<int>e[N];
int f[N];
int maxx;
void dfs(int x,int fa)
{
	f[x] = a[x];
	int maxxx = 0;
	int ans = 0;
	for(int i = 0;i<e[x].size();i++)
	{
		int v = e[x][i];
		if(v!=fa)
		{
			dfs(v,x);
			if(ans<f[v])//求最大的
			{
				ans = f[v];
				maxxx = v;
			}
			f[x] = max(f[x],f[v]+a[x]);
		}
	}
	int maxxxx = 0;
	int ans1 = 0;
	for(int i = 0;i<e[x].size();i++)
	{
		int v = e[x][i];
		if(v!=fa)
		{
			if(ans1<f[v]&&v!=maxxx)//求第二大的
			{
				ans1 = f[v];
				maxxxx = v;
			}
		}
	}
	maxx = max(maxx,max(f[x],ans+ans1+a[x]));
}
int main()
{
	int _;
	scanf("%d",&_);
	while(_--)
	{
		memset(f,0,sizeof(f));//记得清空！！！
		int num = 0;
		int flag = 0;
		int n;
		scanf("%d",&n);
		for(int i = 1;i<=n;i++)
		{
			e[i].clear();//这里也清空哦，很容易漏！！
			scanf("%d",&a[i]);
			if(a[i])
			{
				num++;
			}
		}
		for(int i = 1;i<n;i++)
		{
			int x,y;
			scanf("%d %d",&x,&y);
			e[x].push_back(y);
			e[y].push_back(x);
		}
		maxx = 0;//这里也得重置
		dfs(1,0);
		printf("%s\n",maxx>=num?"Yes":"No");
	}
	return 0;
}
```

---


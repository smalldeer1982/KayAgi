# [GDKOI2023 普及组] 交换机

## 题目描述

Moon 正在准备计算机网络的开学考，复习到了有关交换机的知识。交换机具有令人惊奇的特性那就是它的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。换句话说，交换机是自学习的。这种能力大概是通过如下方式实现的:

1) 交换机表初始为空。
2) 对于在每个接口接收到的每个数据帧，该交换机在其表中存储数据帧的源 $\text{MAC}$ 地址。
3) 如果在一段时间 (称为老化期) 后，交换机没有接收到含有某个源 $\text{MAC}$  地址的数据帧，就会在表中删除这个源 $\text{MAC}$  地址。

现在给出了某天中一个交换机所有收到的数据帧（每一个数据帧包含一个源 $\text{MAC}$  地址，以及该数据帧的到达时间），请你帮助 Moon 算出在这一天中，这个交换机的表最少需要多少项，才可以使得这天所有数据帧的信息可以存储下来。**注意为了简单起见，每个时间点先进行删除操作再进行插入操作。**

简单来说，需要维护一个字符串集合 $S$，有若干次插入操作，每次插入操作包含一个字符串以及一个有效时间区间（区间长度为定值），需要求出所有时间内，字符串集合 $S$ 大小的最大值。

## 说明/提示

### 样例解释

样例 $1$ 中，时刻 $00:11$ 分表项中有 $2$ 个源 $\text{MAC}$ 地址 $\text{0123456789ABC}$ 和 $\text{0000000000ABCDEF}$，所以至
少需要表项大小至少为 $2$，可以证明这是最少需要的表项大小。

### 数据范围

对于所有的数据，有 $1 \le n \le 10^5, 1 \le k \le 1440$；

对于 $50\%$ 的数据，有 $1 \le n \le 500$。

## 样例 #1

### 输入

```
4 10
0123456789ABCDEF 00:10
0000000000ABCDEF 08:11
0123456789ABCDEF 00:15
0000000000ABCDEF 00:11```

### 输出

```
2```

## 样例 #2

### 输入

```
3 60
0123456789ABCDEF 13:00
0000000000000000 14:00
0123456789ABCDEF 12:30```

### 输出

```
1```

## 样例 #3

### 输入

```
见/example/switch/下的 switch1.in ```

### 输出

```
见/example/switch/下的 switch1.out```

# 题解

## 作者：DeepSleep_Zzz (赞：2)

**begin**
# [P11257 题目传送门](https://www.luogu.com.cn/problem/P11257)
# 前置算法
基础：模拟。

优化算法：前缀和，差分。  
（如果不了解的话就先不用看优化算法了，把基础版搞懂这题就够用。当然如果能了解一下肯定是最好的。）
# 题目简述
这个出题人真的太良心了，居然在题目最后一行提示我们：

>简单来说，需要维护一个字符串集合 $S$，有若干次插入操作，每次插入操作包含一个字符串以及一个有效时间区间（区间长度为定值），需要求出所有时间内，字符串集合 $S$ 大小的最大值。

呜呜呜，这么好的出题人上哪找啊，连题目简化的时间都省了。

ok 废话不多说，接下来切入正题。

# 思路
这是一道比较思路容易、细节比较多的模拟题。根据题意简述模拟即可。

就像线段覆盖一样，我们要找到覆盖次数最多的一条线段，并输出其覆盖次数。

我们可以定义一个结构体来存储源 $\texttt {MAC}$ 地址以及传入时间（用 $t$ 来表示）。然后按照传入时间升序排列。从前往后依次模拟。

再建立一个数组 $mac$，$mac_i$ 表示第 $i$ 分钟有多少个**有效**数据存储在交换机内。

底层思路：在接收到某一条 $\texttt {MAC}$ 地址后，将 $[mac_t,mac_{t+k})$ 都增加 $1$。

需要特别注意的是：
1. 有可能在上一条 $\texttt {MAC}$ 数据的老化期**未到之时**，又有一条一模一样的 $\texttt {MAC}$ 数据传入，此时我们需要**避免重复计算**。
2. 有可能在上一条 $\texttt {MAC}$ 数据**已经删除过后**，又有一条一模一样的 $\texttt {MAC}$ 数据传入，此时我们**正常模拟**即可。
3. 特判老化期超出 $1440$ 分钟的情况，否则你将会喜提[一片 RE](https://www.luogu.com.cn/record/192848505)。

看到这里你就会发现，这正是 `map` 家族的强项。

最后输出 $mac$ 数组的最大值即可。

# 时间复杂度
时间复杂度 $O(nt)$（此处 $t$ 为一天中的总分钟数）。最坏情况下程序会运行 $10^5 \times 1440=1.44 \times 10^8$ 次，再加上一些常数，略微极限，但是开了 O2 优化之后时间还是够用的（或者可能是~~数据过水~~）。

具体处理详见代码。

# Code 1.0

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
struct exchange
{
    string s; // MAC 原地址
    ll t; // 传入时间
    bool operator<(const exchange &ech)const
    {
        return t<ech.t;
    } // 重载小于符号（等价于 cmp 函数，这样就不用写 sort 后面的 cmp 函数了。）
}a[100010];
ll n,k,h,m;
ll mac[1450]; // 记录每分钟的数据数量
char c; // 到后面你就知道这是干嘛的了
unordered_map<string,ll> um; // 无序映射，与 map 相时间复杂度比少了个 log，运行时间更快。
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); // 读入优化
    cin>>n>>k;
    for (ll i=1;i<=n;i++)
    {
        cin>>a[i].s;
        cin>>h>>c>>m; // 等价于 scanf("%lld:%lld",&h,&m)，因为我解绑了 cout 所以这里用 char c 来过滤掉中间的冒号。
        a[i].t=h*60+m+1; // +1 比较方便处理
    }
    sort(a+1,a+n+1);
    for (ll i=1;i<=n;i++)
    {
        for (ll j=max(a[i].t,um[a[i].s]+k);j<min(1441LL,a[i].t+k);j++) // 一些特殊处理，对应着上面提到的 3 条注意事项。
        {
            mac[j]++;
        } // 统计存在时间
        um[a[i].s]=a[i].t; // 更新时间
    }
    cout<<*max_element(mac+1,mac+1441); // 求 mac 数组的最大值
    return 0;
}
```

# 小小优化
前面也说过了，$O(nt)$ 的时间复杂度的确有些极限（用 `#pragma` 开挂的不算）。

通过观察前面的代码：

```cpp
for (ll i=1;i<=n;i++)
{
    for (ll j=max(a[i].t,um[a[i].s]+k);j<min(1441LL,a[i].t+k);j++)
    {
            mac[j]++;
    } // 统计存在时间
    um[a[i].s]=a[i].t; // 更新时间
}
```
发现内层循环起到的就是一个循环加一的作用。我们很容易就可以联想到差分。这样时间复杂度就成功优化到了 $O(n)$（虽然在本题中秒数上并没有什么明显的变化，但是这题数据如果扩大到 $5 \times 10^6$ 的话，这个优化就很吃香了）。

知周所众，前缀和是差分的逆运算。所以我们只需要最后对差分序列进行一次前缀和操作就可以得到上段代码中的 $mac$ 数组。最后输出最大值即可。

最后的最后，献上 Code 2.0。

# Code 2.0

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
struct exchange
{
    string s;
    ll t;
    bool operator<(const exchange &ech)const
    {
        return t<ech.t;
    }
}a[100010];
ll n,k,h,m,maca[1450],macb[1450],ans;
/*
maca 为原序列；macb 为差分序列。
其实仔细思考一下，maca 这个数组好像是可以去掉的，但是由于我太懒了，所以这件事就交给屏幕前的你啦~
*/
char c;
unordered_map<string,ll> um;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>k;
    for (ll i=1;i<=n;i++)
    {
        cin>>a[i].s>>h>>c>>m;
        a[i].t=h*60+m+1;
    }
    sort(a+1,a+n+1);
    for (ll i=1;i<=n;i++)
    {
        if (max(a[i].t,um[a[i].s]+k)<=min(1441LL,a[i].t+k)) // 过滤非法情况
        {
            // 差分
            macb[max(a[i].t,um[a[i].s]+k)]++;
            macb[min(1441LL,a[i].t+k)]--;
        }
        um[a[i].s]=a[i].t;
    }
    for (ll i=1;i<=1440;i++)
    {
        maca[i]=maca[i-1]+macb[i]; // 前缀和得到原 mac 数组。
    }
    cout<<*max_element(maca+1,maca+1441);
    return 0; // 完结撒花~
}
```
**end**

---

## 作者：Aventurine_stone (赞：2)

## 1. 题目分析
一道简单排序加字符串哈希的题，~~我很懒所以用的 unordered_map~~。  
就是要注意一下题目中的老化期，也就是 $k$，只要到了老化期数据帧就会被立即删除。
## 2. 题目做法
首先就是在读入时用 unordered_map 将字符串转化为一个数字，方便计算。之后以时间点为关键字从小到大排序。  
我们要用一个数组 $v$ 记录当前存了多少个这种数据帧，以后依次遍历每个插入数据帧的时间点。先删除，再将当前加上。若一种数据帧在删除后或加上前数量为 $0$，则当前存有的数据帧种数减一或加一。最后记录个最大值就行了。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int n,k,cnt;
unordered_map<string,int>ls;
struct node{
	int id,t;
}a[N];
inline bool cmp(node a1,node a2)
{
	return a1.t<a2.t;
}
int v[N],num,l,mx;
int main()
{
	n=read(),k=read();
	for(int i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		ls[s]?1:ls[s]=++cnt;
		a[i]={ls[s],read()*60+read()};
	}
	sort(a+1,a+n+1,cmp);
	l=1,v[a[1].id]=num=mx=1;
	for(int i=2;i<=n;i++)
	{
		while(l<i&&a[l].t+k<=a[i].t)
			v[a[l].id]--,num-=!v[a[l].id],l++;
		num+=!v[a[i].id];
		v[a[i].id]++;
		mx=max(mx,num);
	}
	printf("%d",mx);
	return 0;
}
```

---

## 作者：VelvetChords (赞：2)

# P11257 [GDKOI2023 普及组] 交换机
## 0.前言
100 pts->90 pts->70 pts->30 pts->0 pts->100 pts

合着退化史呢？
## 1.问题简述
处理一组字符串 $S$，每个字符串有一个有效的时间段，表示它在某段时间内是“有效的”。

任务是找出在某个时间点，这些字符串中有多少个是“有效”的，并找到最大值。
## 2.思路
这道题可以归结为一个区间问题：每个字符串对应一个时间区间，表示它在某个时间段内有效。我们要找出所有字符串在时间段内重叠的最大次数，即计算某一时刻所有活跃的字符串数量的最大值。

为了高效地处理这个问题，我们可以通过模拟时间的变化来统计不同时间点的活跃字符串数量。

每个字符串有一个有效时间段，格式为 `hh:mm`（24小时制），我们需要将这些时间转换为以分钟为单位的整数。这样，`00:00` 会变成 `0`，`12:30` 会变成 `750`，`23:59` 会变成 `1439`。

例如，时间 `hh:mm` 可以通过以下公式转换为分钟：

$t = hh \times 60 + mm;$

这样，`hh:mm` 就转化为一个整数 $t$，表示从 `00:00` 到 `hh:mm` 的分钟数。

每个输入字符串都有两个信息：

- $s1$：字符串本身（例如 `MAC` 地址、用户 `ID` 等）。
- $s2$：字符串有效的时间区间（`hh:mm`）。

可以将这些信息存储到结构体中，并且在输入时转换时间 $s2$ 为分钟数。

每个字符串在某个时间段内是有效的，假设它在 $t1$ 到 $t2$ 时间段内有效，那么我们可以通过一个数组来表示每一分钟内有多少个字符串是有效的。

记录时间区间的活跃状态，首先需要：

1. 初始化一个数组 $c$，用来记录每一时刻的活跃字符串数量。
2. 遍历每个字符串的有效时间段，将其区间 $[t1, t2]$ 内的时间点标记为有效。

例如，如果一个字符串在时间段 $t1 = 300$ 到 $t2 = 400$ 有效，那么我们就将 $c_{300}$ 到 $c_{400}$ 的值都加一，表示这段时间内有一个字符串是有效的。

在处理时间段时，要注意避免在同一时间点重复计数。我们可以使用一个布尔数组 $b$ 来标记某一时间点是否已经被处理过。这样，如果某个时间点已经被标记，就不会再对该时间点增加活跃字符串数量。

遍历时间数组 $c$，统计每个时间点的活跃字符串数量，找出最大值。通过遍历 $c$ 数组（记录每一分钟活跃的字符串数），得到最大活跃字符串数量。

最后，输出即可。

---

## 作者：Acit (赞：2)

**思路**

不难发现只需在收到每一个数据帧后对答案进行记录即可。

于是我们将数据帧按 $ time $ 大小排序，并用 map 记录收到数据帧的时间，即可对问题进行处理。

**Code**


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,t,ans,head,tail;
struct Node{
	int ti;
	string s;//ti为时间，s为源MAC地址 
}Q[N],que[N];
bool cmp(Node a,Node b){
	return a.ti<b.ti;
}
map<string,int> mp;
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>t;
	string s,ss;
	for(int i=1;i<=n;i++){
		cin>>s>>ss;
		int TIME=((ss[0]-'0')*10+(ss[1]-'0'))*60+((ss[3]-'0')*10+(ss[4]-'0'));
		Q[i].ti=TIME+1;
		/*
		若mp[s]=0，则s不在交换机内
		加1是为了防止数据帧于0分钟时被收到
		*/
		Q[i].s=s;
	}
	sort(Q+1,Q+1+n,cmp);
	int si=0;
	for(int i=1;i<=n;i++){
		//借助单调队列
		while(head<=tail&&Q[i].ti-que[head].ti>=t){
			if(mp[que[head].s]&&Q[i].ti-mp[que[head].s]>=t)mp[que[head].s]=0,si--;
			// 若最后收到的同个数据帧已超时，则删除它
			head++;
		}
		if(!mp[Q[i].s])si++;
		mp[Q[i].s]=Q[i].ti;//更新时间戳
		que[++tail]=Q[i];//入队
		ans=max(ans,si);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：天野星河 (赞：1)

### 题意

> 简单来说，需要维护一个字符串集合 $S$，有若干次插入操作，每次插入操作包含一个字符串以及一个有效时间区间（区间长度为定值），需要求出所有时间内，字符串集合 $S$ 大小的最大值。

### 思路

用一个 `unordered_map` 维护字符串最后一次出现的时间点，用数组维护每个时间点的字符串数量，最后取 `max`。

算法流程如下：

将每个数据帧按照时间排序。然后对于每个数据帧（字符串 $s$ 和时间 $t$）：

- 计算出该数据帧占用的时间区间为 $[t,t+k)$。
- 处理重复情况和边界，并将该区间整体加 $1$。

注意到静态区间加可以用查分维护。

故时间复杂度为 $\Theta(n+T)$，其中 $T=1440$（时间的值域）。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
pair<int, string> a[N];
int n, k;
int ans[1500];
unordered_map<string, int> ds;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for (int i = 1, u, v; i <= n; i++) {
		char c;
		cin >> a[i].second >> u >> c >> v;
		a[i].first = u * 60 + v + 1;
	}
	sort(a + 1, a + n + 1);
	for (int i = 1, l, r; i <= n; i++) {
		l = max(a[i].first, ds[a[i].second] + k);
		r = min(a[i].first + k, 1441);
		if (l < r) {
			ans[l]++;
			ans[r]--;
		}
		ds[a[i].second] = a[i].first;
	}
	partial_sum(ans + 1, ans + 1441, ans + 1);
	cout << *max_element(ans + 1, ans + 1441);
}
```

---

## 作者：BZzc (赞：1)

# P11257 GDKOI2023 普及组 Day2 T1 题解

## 前言

很水的一道模拟题，按题意模拟即可。

~~当年我这题考场喜提 0 分，2 天怒砍总分 30。~~

## 题意简述

维护一个字符串集合 $S$，有若干次插入操作，每次插入操作包含一个字符串以及一个有效时间区间（区间长度为定值），需要求出所有时间内，字符串集合 $S$ 大小的最大值。

## 分析

题目的数据范围有曰：

> 对于所有的数据，有 $1 \le n \le 10^5, 1 \le k \le 1440$；

显然，我们对于每一个源 $\text{MAC}$  地址，将它需要占用的时段去重后，将这些时段所有的时间点需要表项大小都 $+1$，最后遍历所有时间点，找到需要表项大小最大的时间点，输出其对应的表项大小即可。

时间复杂度 $O(nk)$，满足题意。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	string s1,s2;
	long long t;
} a[100001];
long long c[3001],i,j,k,n,x=-114514;
bool b[3001];
bool cmp(node x,node y) {
	return x.s1<y.s1;
}
int main() {
	cin>>n>>k;
	for(i=1; i<=n; i++) {
		cin>>a[i].s1>>a[i].s2;
		a[i].t=1000*(a[i].s2[0]-'0')+100*(a[i].s2[1]-'0')+10*(a[i].s2[3]-'0')+(a[i].s2[4]-'0');
	}
	sort(a+1,a+n+1,cmp);//把所有的MAC地址对应的时段放到一起
	for(i=1; i<=n; i++) {
		if(a[i].s1!=a[i-1].s1) memset(b,0,sizeof(b));//去重用
		for(j=0; j<k; j++) {
			if(a[i].t+j!=2359) {
				if((a[i].t+j)%100==60) a[i].t+=40;
				if(!b[a[i].t+j]) c[a[i].t+j]++,b[a[i].t+j]=true;//将去重后时段所有的时间点需要表项大小都+1
			} else break;
		}
	}
	for(i=1; i<=3000; i++) x=max(c[i],x);//找到需要表项大小最大的时间点
	cout<<x<<endl;
	return 0;
}
```

---

## 作者：zhushixian (赞：0)

# P11257 [GDKOI2023 普及组] 交换机 题解

[题目传送门](https://www.luogu.com.cn/problem/P11257)

### 思路

这道题可以先字符串哈希再预处理每个地址接收时间和老化时间，然后排序。不难发现接收时间范围是从 $0$ 分钟到 $1440$ 分，所以最大表项一定出现在 $0$ 分钟到 $1440$ 分钟，直接按照每一刻时间模拟接收和老化统计最大值即可。**时间复杂度 $O(n log n)$**（可以开个桶排去掉 $log n$ ，懒得写了）。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct macs{
	int id,time;
}a[N],b[N];
string s1,s2;
unordered_map<string,int> mp;
int cnt,n,k,m[N],ans,cnts;
bool cmp(macs x,macs y){
	return x.time<y.time;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>k; 
	for(int i=1;i<=n;++i){
		cin>>s1>>s2;
		if(!mp[s1])mp[s1]=++cnt;
		a[i].id=mp[s1];
		a[i].time=(s2[0]-'0')*600+(s2[1]-'0')*60+(s2[3]-'0')*10+(s2[4]-'0');
		b[i].id=mp[s1];
		b[i].time=a[i].time+k;
	}
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+n+1,cmp);
	int arr1=1,arr2=1,now=0;
	for(int i=0;i<=1440;++i){//注意题目中时间从00:00开始
		while(b[arr2].time==i){
			if(m[b[arr2].id]==1) --now;
			--m[b[arr2].id];
			++arr2;
		}
		while(a[arr1].time==i){
			++m[a[arr1].id];
			if(m[a[arr1].id]==1) ++now;
			++arr1;
		}
		ans=max(ans,now);
	}
	cout<<ans;
}
```

---

## 作者：ethanhyz (赞：0)

# P11257 [GDKOI2023 普及组] 交换机 题解

这个题解可能没有其他大佬的优，但主打一个简单易懂

## 题意简述
给定若干数据帧，每一数据帧包含：$\texttt{MAC}$ 地址、时间

每一 $\texttt{MAC}$ 地址会保存一给定时间（被称为老化期），老化期一到立即删除，除非老化期内又收到含有该 $\texttt{MAC}$ 的数据帧，则刷新老化期。

问同一时刻内最多同时存储着几个数据帧。

## 思路分析
### 读入
第一行输入两个整数 $n,k$，不必多说

接下来 $n$ 行，每行两个字符串，表示 $\texttt{MAC}$ 地址和时间（$\texttt{hh:mm}$）

字符串不方便存储，可以使用 `map` 。
具体来说，每读入一个新的 $\texttt{MAC}$ 地址，按读入的先后顺序将其从 $1$ 开始编号。

而时间可以通过 `scanf` 分别读入小时和分钟，并计算为一天中的第几分钟。

同时，计算出该数据帧所对应的清除时刻，和发送时刻一起加入其 $\texttt{MAC}$ 地址对应的 `vector` 中。

其中，要特别注意，清除时刻可能会超过 $1440$，即一天中的分钟数，导致越界，要特别处理（见注释）。

~~不要问我怎么知道的，问就是 RE 了好几个点~~

还有，为了防止某一时刻一个地址删除而另一个地址加入导致多算，可以将删除时间减 $1$ 。

```cpp
vector <pair <ll,ll>> mac[100005];
map <string,int> M; //MAC地址的编号
scanf("%lld%lld",&n,&k);
for(int i=1;i<=n;i++)
{
	cin>>str; //读入MAC地址
	if(!M[str]) M[str]=++size; //如果是新地址则编号
	scanf("%lld:%lld",&h,&m); //读入时间
	s=h*60+m;
	e=min(1440ll,s+k-1); //就是这里
	mac[M[str]].push_back(make_pair(s,e));
}
```

### 计算

遍历每个 $\texttt{MAC}$ 地址（其实是其对应编号），因为从 $1$ 开始且大小记录在 `size` 中，所以相当方便。

- 对于每一个 $\texttt{MAC}$ 地址，遍历其 `vector` 中存储的“加入时间-删除时间”对。
- - 遍历从加入时间到删除时间中的每一分钟，打上标记
- 遍历一天中的每一分钟，如果有标记则该时刻的“交换机表”大小加 $1$。

遍历遍历一天中的每一分钟，求“交换机表”大小的最大值。

----------

虽然看似效率不高（确实也不快），有 $3$ 重循环，时间复杂度高达 $\mathcal{O}(nt)$（ $t$ 表示一天中的分钟数），但非常直观明了。

时间复杂度是 $\mathcal{O}(nt)$（ $t$ 表示一天中的分钟数），虽然有三重循环，但因为前两重循环相当于遍历了所有 $n$ 个数据帧，所以并没有 $\mathcal{O}(n^2)$ 级。而且考虑到一天只有 $1440$ 分钟，这个时间复杂度也是可以接受的。

```cpp
for(int i=1;i<=size;i++)
{
	memset(f,0,sizeof(f)); //清空标记数组
	for(auto j:mac[i]) //遍历mac[i]中每个pair，非常方便的写法
		for(int t=j.first;t<=j.second;t++)
			f[t]=1; //标记加入到删除时刻间的所有分钟
	for(int t=0;t<=1440;t++)
		if(f[t]) ans[t]++;		
}
for(int i=0;i<=1440;i++)
	maxn=max(maxn,ans[i]); //统计最大值
```

### 输出

最后输出最大值 `maxn`，没什么好说的。


## 完整代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define mp(a,b) make_pair(a,b)
#define fi first
#define se second
using namespace std;
vector <pair <ll,ll>> mac[100005];
ll n,k,h,m,s,e,f[1445],ans[1445],size,maxn;
string str;
map <string,int> M;
int main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
	{
		cin>>str;
		if(!M[str]) M[str]=++size;
		scanf("%lld:%lld",&h,&m);
		s=h*60+m;
		e=min(1440ll,s+k-1);
		mac[M[str]].push_back(mp(s,e));
	}
	for(int i=1;i<=size;i++)
	{
		memset(f,0,sizeof(f));
		for(auto j:mac[i])
			for(int t=j.fi;t<=j.se;t++)
				f[t]=1;
		for(int t=0;t<=1440;t++)
			if(f[t]) ans[t]++;		
	}
	for(int i=0;i<=1440;i++)
		maxn=max(maxn,ans[i]);
	printf("%lld\n",maxn);	
	return 0;
}
```

## 完结撒花～

---

## 作者：queenbee (赞：0)

# P11257 [GDKOI2023 普及组] 交换机 题解

## 思路
[题目传送门](https://www.luogu.com.cn/problem/P11257)，考虑到地址的存储与存入时间有关，选择用优先队列（以存入时间排序的小根堆）实现地址的存储与删除。

先考虑哪些地址需要被删除（因为是优先队列存储，所以队列里会有很多重复的地址，需要对这些重复的地址也进行删除）。对于一个地址，如果它在存入新地址时已经老化，或者队列里已经有该地址新的存入，那么这个地址就可以删除了。特别注意的是，因为是优先队列存储，如果新存入的地址在队列里有存入且没有被删除，那么它对答案没有贡献，如果删除的是重复的地址，它对答案也没有贡献。时间复杂度 $O(n\log n)$。

## 程序
```cpp
#include<bits/stdc++.h>	//我爱万能头 
using namespace std;
const int N=1e5+10;
#define PI pair<int,string>
int n,k;
int tot,ans;
string s;
int tim;
struct Node{
	string name;
	int t;
}a[N];
map<string,int>t;	//存储队列中地址重复的次数 
priority_queue<PI,vector<PI>,greater<PI> >q;
bool cmp(Node a,Node b){
	return a.t<b.t;
}
void add(Node a){
	while(!q.empty()){
		int T=q.top().first;
		string name=q.top().second;
		if(t[name]>1){	//重复的优先级要高于老化，因为重复的没有贡献，要优先处理 
			t[name]--;	//注意减去队列中出现次数 
			q.pop();
		}
		else if(a.t-T>=k){
			t[name]--;	//注意减去老化地址的出现次数（第一发0pts） 
			q.pop();
			tot--;	//超时对答案有贡献 
		}
		else{
			break;	//如果没有超时就不处理（剩下需要删除的都是重复的，没有贡献） 
		}
	}
	q.push({a.t,a.name});
	t[a.name]++;
	if(t[a.name]==1){	//新地址有贡献 
		tot++;
		ans=max(tot,ans);
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].name>>s;
		tim=(s[0]-'0')*600+(s[1]-'0')*60+(s[3]-'0')*10+(s[4]-'0');	//时刻转时间 
		a[i].t=tim;
	}
	sort(a+1,a+n+1,cmp);	//按时间升序排序 
	for(int i=1;i<=n;i++){
		add(a[i]);	//加入队列 
	}
	cout<<ans;
	return 0;	//完结撒花 
}
```

---


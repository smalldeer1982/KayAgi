# 「WPOI-R2」无穷的迭代器

## 题目背景

You can also see the pdf at the bottom of the chinese problem statement.

## 题目描述

对于实数 $ r $，记一次操作为：

* 找到不小于 $ r $ 的最小整数即 $ \lceil r \rceil $，并将 $ r $ 的值乘上 $ \lceil r \rceil $。

现在给定非负整数 $ k $，对于 $ r=k+\frac{1}{2} $，至少需要对 $ r $ 进行几次操作才能使 $ r $ 为整数？

## 说明/提示

**【样例 1 解释】**

| 操作次数 | $ r= $ |
|:-:|:-:|
| 初始 | $ \frac{9}{2} $ |
| $ 1 $ | $ \frac{45}{2} $ |
| $ 2 $ | $ \frac{1035}{2} $ |
| $ 3 $ | $ 268065 $ |

**【数据规模与约定】**

**提示：本题采用捆绑计分。**

对于 $ 100\% $ 的数据，$ 1 \le T \le 20 $，$ 0 \le k \le 10^{18} $。

* Subtask 1（15 pts）：$ 1 \le k \le 10 $。
* Subtask 2（40 pts）：$ 1 \le k \le 100 $。
* Subtask 3（45 pts）：$ 0 \le k \le 10^{18} $。

## 样例 #1

### 输入

```
1
4```

### 输出

```
3```

## 样例 #2

### 输入

```
1
0```

### 输出

```
NO!```

# 题解

## 作者：船酱魔王 (赞：9)

# T3. iterative

## 题意回顾

$ r \leftarrow r\lceil r \rceil $ 记为一次操作，对于 $ r=x+0.5 $（$ x $ 是给定的非负整数）需要几次操作才能让 $ r $ 变成整数？

## 分析

若 $ r=x+0.5 $，则 $ r'=r\lceil r \rceil=(x+1)(x+0.5)=x^2+1.5x+0.5 $，设仍有 $ r'=x'+0.5 $，即 $ x'=x^2+1.5x $。

设 $ x $ 中含有的 $ 2 $ 的因子个数为 $ v(x) $，则若 $ v(x)=0 $，则 $ x^2+1.5x+0.5 $ 为整数；若 $ v(x)>0 $，则 $ x'=x^2+1.5x $ 为整数，此时 $ 2^{v(x)}|x^2 $，而 $ 2^{v(x)}|1.5x $ 不成立，因此 $ v(x^2+1.5x)=v(1.5x)=v(x)-1 $。

因此答案为 $ v(x)+1 $。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
long long n;
int main() {
	cin >> T;
	for(int ti = 1; ti <= T; ti++) {
		cin >> n;
		for(int i = 1; i <= 64; i++) {
			if(n % 2 != 0) {printf("%d\n", i), n = -1; break;}
			else n /= 2;
		}
		if(n != -1) printf("NO!\n");
	}
	return 0;
}
```

---

## 作者：__^浅笑.__ (赞：5)

**前言：**

今天的最后一篇题解，肝不动了……

写完就下了各位……

**题意分析：**

给定一个非负整数 $k$，我们需要对 $r=k+\frac{1}{2}$ 进行一系列操作，每次操作是找到不小于 $r$ 的最小整数 $\lceil r \rceil$，然后将 $r$ 乘以 $\lceil r \rceil$。我们的目标是找出至少需要进行多少次操作才能使 $r$ 变为一个整数。

**代码详解：**

代码所需的头文件：
```c
#include <cmath>
```
当 $k=0$ 时，$r=\frac{1}{2}$，无论进行多少次操作，$r$ 都无法变为整数，因此直接输出 `NO!`。

其他的情况来看，我们可以初始化操作次数为 $0$，然后进入一个循环，每次循环中进行以下操作：

- 计算 $\lceil r \rceil$。

- 将 $r$ 乘以 $\lceil r \rceil$。

- 增加 $1$ 到操作次数。

- 检查 $r$ 是否为整数。

终止条件：

如果 $r$ 变为整数，则输出操作次数并终止循环；如果操作次数超过某个阈值（理论上应该不会超过），则输出 `NO!` 并终止。

**放上完整代码！！！**

```c
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define re return
#define ew 5005
#define sz 10000005
#define sscc cout<<6;
const int MOD=1e9+7;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
    cin>>T;
    while(T--){
        int k;
        cin>>k;
        if(k==0) {
            cout<<"NO!"<<endl;
            continue;
        }
        long double r=k+0.5;
        int sum=0;
        while(true){
            int rr=ceil(r);
            r*=rr;
            sum++;
            if(floor(r)==r){
                cout<<sum<<endl;
                break;
            }
            // 防止无限循环，按道理来说上不应该超过这个值
            if(sum>100) {
                cout<< "NO!"<<endl;
                break;
            }
        }
    }
	re 0;
}

```
**输入部分**：

首先读取测试数据组数 $T$，然后进入循环处理每组数据。

**特殊部分**：

当 $k=0$ 时，直接输出 `NO!`。

**循环操作**：

初始化 $r$ 为 $k+0.5$，然后进行操作，每次操作后检查 $r $是否为整数。

**终止条件**：

如果 $r$ 为整数，则输出操作次数；如果操作次数超过 $100$ 次，则输出 `NO!`。

----

完结撒花★,°:.☆(￣▽￣)/$.°★。

---

## 作者：dread_breaker (赞：4)

## upd 2025.1.16:感谢@Vct14 大佬的提醒，代码不小心粘错了，已改正！

这道题貌似光找规律不行，也可能是我太菜了。

[提交记录](https://www.luogu.com.cn/record/list?pid=P11310&user=Hacstd&page=1)


$k$只有为 $0$ 时输出 `NO!` 。其他情况直接模拟就行了。

设 $t=r$ 的分母，每操作一次相当于 $t$ 乘上 $t/2+1$。当 $t$ 为偶数时输出次数即可。

## code:

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int T;
LL n;

int main(){
	cin >> T;
	while(T--){
		cin >> n;
		if(n == 0)
			cout << "NO!\n";
		else{
			int ans = 1;
			while(n % 2 == 0) ans++, n /= 2;
			cout << ans << "\n";
		}
	}
	return 0;
}
```

---

## 作者：DrDuck (赞：4)

# 基本思路 #
首先对 $k$ 进行分类讨论，如果 $k=0$，则 $r=\frac{1}{2}$，则此时不小于 $r$ 的最小整数为 $1$，不管乘多少次结果都是 $\frac{1}{2}$，此时可以直接输出`NO!`。

如果 $k \ne 0$ 呢？我们直接按照题意来模拟，设分子为 $t$，由于分母恒等于 $2$，那么原式就应当乘上 $\lfloor \frac{t}{2}\rfloor + 1$，把这个结果直接乘到分子上，然后根据这个写一个循环，直到 $t \mod 2 = 0$就可以输出答案了。

还没完！注意数据范围！还是那句话，十年 OI 一场空，不开 long long 见祖宗！
# CODE #

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int t, k;
signed main()
{
	cin >> t;
	for (int i = 1; i <= t; i++)
	{
		cin >> k;
		if (k == 0)
		{
			cout << "NO!" << endl;
			continue;
		}
		int step = 0;
		k = k * 2 + 1;
		while (k % 2)
		{
			k *= (k / 2 + 1);
			step++;
		}
		cout << step << endl;
	}
	return 0;
}
```
拒绝抄袭！

---

## 作者：kevin1616 (赞：3)

### 审题
已知实数 $r=k+\dfrac{1}{2}$，其中 $k$ 是非负整数。每次操作将 $r$ 乘上 $\lceil r\rceil$。问将 $r$ 变为整数的操作次数。
***
### 思路
首先，考虑无解。发现好像只有 $k=0$ 时满足无解情况。待会会对此进行详细证明。

其次，开始思考。先考虑第一次操作，由于 $k$ 为非负整数，那么 $\lceil r\rceil=\lceil k+\dfrac{1}{2}\rceil=k+1$。第一次操作后 $r_1=r\times\lceil r\rceil=(k+\dfrac{1}{2})(k+1)=k^2+\dfrac{3}{2}k+\dfrac{1}{2}$。

发现式子非常难看。由于只需要判断其是否为整数，那么就不需要考虑诸如 $mk^n$ 这样的项。（其中 $m,n$ 均为整数）那么算式可以变成 $k^2+\dfrac{3}{2}k+\dfrac{1}{2}=k^2+k+\dfrac{1}{2}k+\dfrac{1}{2}\Rightarrow\dfrac{1}{2}k+\dfrac{1}{2}$。

那么现在进行分析：对于 $\dfrac{1}{2}k+\dfrac{1}{2}$ 这样一个式子，很好想到 $k$ 的奇偶性分类讨论。

+ 如果 $k$ 是奇数，那么设 $k=2n+1$（此处、下文的 $n$ 都为整数），则 $r_1\Rightarrow\dfrac{1}{2}k+\dfrac{1}{2}=n+\dfrac{1}{2}+\dfrac{1}{2}=n+1$。故此时 $r_1$ 已经为整数，输出 $1$。
+ 如果 $k$ 是偶数，那么设 $k=2n$，则 $r_1\Rightarrow\dfrac{1}{2}k+\dfrac{1}{2}=n+\dfrac{1}{2}$。故此时 $r_1$ 不为整数，需要继续进行操作。

好的。我们已经把第一次操作的相关内容处理完了。现在我们发现留下来的只有 $k$ 是偶数的情况。此时我们依旧设 $k=2n$，前面已经推理出 $r_1\Rightarrow n+\dfrac{1}{2}$ 了。但是现在先别急着往下，我们回头一看：$n+\dfrac{1}{2}$ 和 $k+\dfrac{1}{2}$ 的形式不是一模一样吗？直接数学归纳法，证明操作有规律可循。

那为什么只有 $k=0$ 的时候无解呢？

+ 当 $k=0$ 时，此时回到上面的推理，发现操作结束的前提条件是 $k$ 除以有限个 $2$ 后为奇数，但是 $0$ 无论除以多少个 $2$ 都不会变为奇数，那么就会一直进行操作，所以此时 $r$ 必然不能变成整数。
+ 而其它情况，只要对于 $k>0$，必然可以将其分解质因数，随后发现可以将所有 $2$ 的正整数次项除掉（或者根本没有 $2$ 的正整数次项），以此得到奇数，所以 $r$ 必然可以变成整数。

由以上证明，答案即为 $k$ 分解质因数后存在的 $2$ 的次方数再加上 $1$（最开始那一次）。

时间复杂度 $O(\log k)$，记得要给 $k$ 开 long long。
***
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long k; // 不开long long见祖宗
int main(){
  cin >> t;
	while(t--){
		cin >> k;
		if(k == 0) cout << "NO!\n"; // 无解情况
		else{
			int cnt = 0;
			while(k % 2 == 0){ // 统计k的2的次方数
				k /= 2;
				cnt++;
			}
			cout << cnt + 1 << "\n";
		}
	}
	return 0; // 好习惯
}
```

不抄题解，从我做起！

---

## 作者：ingo_dtw (赞：3)

# P11310 无穷的迭代器
### 结论
当 $k$ 是奇数，乘二直接变成整数。

当 $k$ 是偶数，可以往后推式子。第一次推出来是 $ k^4 + 3\times k^3 + \frac{15}{4}$ $k^2 + \frac{9}{4}$ $k + \frac{1}{2}$  $k$ 
 ，去掉整数项成为 $\frac{9}{4}$ $k + \frac{1}{2} $
	。此时 $k$ 只要是 $4$ 的倍数即可。继续往后进行操作。


### 应该很好理解吧
一个数加上 $\frac{1}{2}$ 也就是 $0.5$ 可以成为整数那它一定是一个十分位是 $5$ 的小数
### 对于题目说的操作次数
其实就是将这个数除以二直到它除以二的余数不为 0 再输出次数就是答案
（要注意 0 要特判）
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()

template <class T>T read()//快读
{
	T f=1,r=0;char c=getchar();
	while((c<'0'||c>'9')&&c!='-') c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return f*r;
}
void out(int x)//快写
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
signed main()
{
	int t=_;//输入（别问为啥是=_我上面宏定义了）
	while(t--)
	{	
		int n=_,ans=0;
		if(n==0) //特判0
		{
			printf("NO!\n");
			continue;
		}
		else
		{
			while(n%2==0)
			{
				n/=2;
				ans++;//加操作次数
			}
			ans++;//还有一次
		}
		out(ans);//输出
		putchar('\n'); //换行
	} 
	return 0;//华丽结束
}

```

---

## 作者：Miracle_InDream (赞：3)

简单题。

我们考虑 $x+0.5$ 乘上什么会变成一个整数。显然必须乘上一个偶数。也就是 $r-0.5$ 必须变成一个奇数/

我们只考虑 $\lceil r\rceil=x+1$ 的最后几位。设为 ```...xxx100000...0```。

$(x+0.5)(x+1)$ 变成了 $x^2+1.5x+0.5$。整数部分为 $x^2+1.5x$，也即下一次代入的 $x$。

考虑二进制表达。对偶数 $x$，$x:=x^2+1.5x$ 的变换会去掉尾部的一个 ```0```。

因此答案为 $x$ 尾部 ```0``` 个数 $+1$。注意判定 $x=1$。

---

## 作者：yanxu_cn (赞：2)

主体代码一行秒了。

### 大体思路

易于知道，如果 $a$ 是偶数，$a\times (a-0.5)$ 是整数；如果 $a$ 是奇数，$a\times(a-0.5)$ 不是整数。

所以只要知道多少次之后 $r+0.5$ 是个偶数，即 $r-0.5$ 是个奇数即可。

记 $k$ 始终为 $r-\frac{1}{2}$，只要 $k$ 是奇数下一轮 $r$ 就是整数。

推一下式子：$k_{x+1}=r_{x+1}-0.5=r_x(r_x+0.5)-0.5=(k_x+0.5)(k_x+1)-0.5=k_x^2+1.5k_x$。

如果 $k_x$ 是偶数，显然 $k_x^2$ 也是偶数，且其二进制末尾的 $0$ 的个数是原数的两倍。而 $1.5k_x$ 二进制的末尾的 $0$ 的个数减少一位，故总体二进制的末尾的 $0$ 的个数减少一位。所以说我们只需要看原先 $k$ 的二进制结尾的 $0$ 的数量就可以了。

这里其实用不着 `lowbit` 等函数，C++ 内建函数 `__builtin_ffsll(long long)` 就可以直接求解。

注意对 $0$ 特判一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0);
	int T;
	cin>>T;
	while(T--)
	{
		long long k;
		cin>>k;
		if(k==0)cout<<"NO!\n";
		else cout<<__builtin_ffsll(k)<<'\n';
	}
	return 0;
}
```

---

## 作者：EasonLIkeMath (赞：2)

由题意，$r = k + \frac{1}{2}$，所以，$\lceil r \rceil = k + 1$。
$$
\lceil r \rceil r = (k + 1)(k + \frac{1}{2}) = (k + 1)k + \frac{k}{2} + \frac{1}{2}
$$
所以当 $k$ 为奇数时，一次操作就能结束。\
假设一次操作后仍是偶数。
$$
(\lceil \lceil r \rceil r \rceil)(\lceil r \rceil r) = [(k + 1)k + \frac{k}{2} + 1][(k + 1)k + \frac{k}{2} + \frac{1}{2}]
$$
显然含 $(k + 1)k$ 的项都是整数，$ (\frac{k}{2})^2 $ 也是整数。所以当 $\frac{k}{4} + \frac{1}{2}$ 为整数时，整个式子的结果为整数。\
以此类推，假设 $n$ 次操作后仍是偶数。
当 $\frac{k}{2^{n + 1}} + \frac{1}{2}$ 为整数时，下一次操作所得式子的结果为整数。\
所以答案就是 $k$ 所含 $2$ 因子的数量加一，加一是加上变成奇数后的一次操作，$0$特判，输出 `NO!`。\
AC代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	int t;
	cin >> t;
	while(t--){
		long long n;
		cin >> n;
		if(n == 0){
			cout << "NO!" << endl;
			continue;
		}
		long long cnt = 0;
		while(n % 2 == 0){
			n >>= 1;
			cnt++;
		}
		cout << cnt + 1 << endl;
	}
	return 0;
}

```

---

## 作者：__UrFnr__ (赞：2)

~~前情提要：基础赛爆零~~

**题目思路**：其实 $k$ 的意义就是 $\frac{k}{2}$ 的分子，只有 $k$ 为偶数时，这个数才为整数。回归题目，若 $k=0$ 时，已经没有了意义，所以直接输出 `NO!`。由于题目所说，找不到小于实数 $r$ 的最小整数即 $\lceil {r}\rceil$，并将 $r$ 的值乘上 $\lceil r \rceil$，这个操作相当于 $k\times2+1$，操作完之后只要 $k$ 为奇数，$k$ 就等于 $(k+1)\div2$（避免 $k$ 会变成一个很大的数，也就是求 $k$ 含有的 $2$ 因子的个数，而且这样是可行的），一直这样循环往复，直到 $k$ 为偶数，就可以输出答案。

代码如下：


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t, k;
signed main () {
    cin >> t;
    while (t --) {
        cin >> k;
        if (k == 0) {//特判无解情况
            puts ("NO!");
            continue;
        }
        k = k * 2 + 1;//初始操作
        int ans = 0;
        while (k & 1) {//只要k为奇数，就还要进行操作
            ans ++;//累加操作次数
            k = (k + 1) / 2;//进行操作
        }
        cout << ans << '\n';//输出答案
    }
}
```

---

## 作者：__CJY__ (赞：2)

## 题意简述
题目给出了一个初始的实数 $r=k+\frac{1}{2}$，其中 $k$ 是一个非负整数。每次操作需要找到不小于 $r$ 的最小整数 $\lceil r \rceil$，并将 $r$ 乘这个整数。目标是找出至少需要进行多少次操作才能使 $r$ 成为一个整数，或者判断这是不可能的。
## 思路
我们来观察一下：
* 初始时，$r=k+\frac{1}{2}$，其中 $k$ 是一个非负整数。
* 每次操作后，$r$ 会乘一个不小于它的整数。这个整数并不总是 $2$ 的某个幂次，而是由 $r$ 的当前值决定，通常是 $\lceil r \rceil$（即 $k+1$ 或更大的整数，取决于 $r$ 的小数部分如何影响下一步的计算）。

对于每次操作：
* 如果 $k$ 是偶数，那么 $r=(k+0.5) \times 2$，整数部分翻倍，小数部分仍然是 $0.5$。这相当于 $k \div 2$（考虑整数部分的变化）。
* 如果 $k$ 是奇数，那么在某些情况下（特别是当小数部分被整数部分“吸收”时），$r$ 可能会变成整数。

以下是操作次数的判断：

我们需要找到一个最小的操作次数，使得 $k$ 变成奇数（因为只有当 $k$ 是奇数时，$r$ 才会变成整数）。

由于每次 $k$ 偶数时都会除以 $2$，我们可以理解为在二进制下，每次操作都会使 $k$ 的二进制表示向右移动一位（即丢弃最低位）。

因此，我们需要找到 $k$ 的二进制表示中，最低位的 $1$ 所在的位置。这个位置决定了需要进行多少次操作才能使 $k$ 变成奇数。

如果 $k$ 本身就是 $0$，那么无论进行多少次操作，$r$ 都不会变成整数，因为 $r$ 将始终保持为 $0.5$ 的倍数。

我们可以通过不断右移 $k$ 的二进制表示（即不断除以 $2$），并计数，直到找到一个奇数为止。
* 如果在 $64$ 次操作内（对应于 $k$ 的二进制表示最多有 $64$ 位）找到了奇数，那么输出操作次数。
* 如果 $64$ 次操作后仍然没有找到奇数（即 $k$ 变成了 $0$），那么输出`NO!`。

**十年 OI 一场空，不开`long long`见祖宗！**

~代码应该很简单吧，这里就不放了。~

有问题请提出！

---

## 作者：Pyrf_uqcat (赞：1)

来个找规律的方法（证明在最后）。

考虑到输入的数只有一个，可以进行打表找规律。

将 $k$ 从 $0$ 开始达到 $40$：


```
无 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4
```

首先我们可以发现当 $k$ 是 $0$ 时，无法变成整数，故输出`NO!`。

然后每当 $k$ 是奇数时，答案为 $1$。

偶数个时，可以发现当 $2^x=k$ 时，答案为 $x+1$，且其他数存在规律：当 $k$ 可以被 $2^x$ 除尽时，答案为 $x+1$。

注意此题多测，且因为 $k$ 不超过 $10^{18}$，所以最多到达 $2^{64}$，从 $64$ 开始遍历即可。


```
#include <bits/stdc++.h>
#define int long long

#define N 100005

using namespace std;

int t,k;

signed main()
{
	cin>>t;
	while(t--)
	{
		cin>>k;
		if(k%2==1) cout<<1<<endl;
		else if(k==0) cout<<"NO!\n";
		else
		{
			for(int i=64;i>=1;i--)
			{
				int po=pow(2,i);
				if(k%po==0)
				{
					cout<<i+1<<endl;
					break;
				}
			}
		}
	}
	return 0;
}

```

好吧还是补充一些证明。

当 $k$ 是奇数，乘二直接变成整数。

当 $k$ 是偶数，可以往后推式子。第一次推出来是 $k^4+3k^3+\frac{15}{4}k^2+\frac{9}{4}k+\frac{1}{2}$，去掉整数项成为 $\frac{9}{4}k+\frac{1}{2}$。此时 $k$ 只要是 $4$ 的倍数即可。继续往后进行操作，大家可以试着手推一下，能够锻炼推式子能力。可以得到最开始的结论。

---

## 作者：__delta_epsilon__ (赞：1)

### 题目大意

给定 $r=k+\frac{1}{2}$，其中 $k\in\Z$，求经过多少次 $r\leftarrow r\lceil r\rceil$ 后，$r\in\Z$。

### 分析

显然 $r$ 向上取整为 $k+1$，因此 $r\lceil r\rceil=(k+1/2)(k+1)=k(k+1)+\frac{k+1}{2}$。

如果这个数为整数，显然有 $k$ 为奇数。

也就是说，操作后能不能变为整数只与 $k$ 的奇偶性有关。

所以问题转变为了经过多少次 $k\leftarrow k(k+1)+\frac{k}{2}$，$k$ 会变成一个奇数。

因为 $k(k+1)$ 恒为偶数，所以问题转变为了经过多少次 $k\leftarrow \frac{k}{2}$，$k$ 会变成一个奇数。

因此答案为 $k$ 二进制末尾连续的 $0$ 的个数**再加一**。

而我们又知道 C++ 内置了一个函数叫做 `__builtin_ctz` 专门用来数二进制末尾 $0$ 的个数。

数据范围可知需要开 `long long`（`__builtin_ctz` 要写成 `__builtin_ctzll`），并且要特判 $k=0$，其他没了。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t;
signed main() {
    for(cin >> t; t--; ){
        int n;
        cin >> n;
        if(n == 0) cout << "NO!" << endl;
        else cout << __builtin_ctzll(n) + 1 << endl;
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

诈骗题？！！  
### 具体思路
虽然题目确实有典型的数学性质，但似乎可以直接暴力模拟。  
注意一定不能用浮点数储存和模拟，原因只有一个：精度。  
那怎么办？不难发现，在最开始 $r$ 的值为 $\frac{1+ 2\times k}{2}$，而且每次乘以 $ \lceil r \rceil $ 只会影响分子的值，也就是说，分母永远是 $2$。  
那么如果分子是偶数，那么该数就是整数，反之不是。因此只需令分子不断乘上 $ \lceil r \rceil $，直到该数为偶数为止。假设分子为 $f$，则其相当于乘上 $ \lfloor \frac{f}{2} \rfloor +1$，因为 $f$ 为奇数，所以上取整会进一。  

那么复杂度呢？  
我们进行一个分类讨论：  

若 $k$ 为 $0$，$ \lceil r \rceil $ 的值就永远是 $1$，因此输出 ```NO!```。  
如果 $k$ 为奇数，那么 $f$ 最开始也一定为奇数，因为奇数乘以偶数等于偶数，再加一个 $1$ 就是奇数了。然后 $ \lfloor \frac{f}{2} \rfloor +1$ 的值一定为偶数，很明显，$k$ 刚乘的一个 $2$ 又被除掉了，因此得到的数是一个奇数加 $1$ 的和，奇数加奇数等于偶数，没问题。所以就变为了一个奇数乘以一个偶数得到的结果一定是偶数，因此如果 $k$ 为奇数那么只需进行一次操作就可以使其变为整数。   
如果 $k$ 为偶数，在操作过程中，它们在至多 $\log_2 k$ 次操作后就变为一个奇数的两倍加一的值，因此时间复杂度满足题目要求。  

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define deap(i,a,b) for(int i=a;i>=b;i--)
#define news(a,n) a=new int[n+1]
#define out(a) write(a)
#define end(a) putchar('\n')
const int maxn=INT_MAX;
const double INF=DBL_MAX;
inline void write(int x) {
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	long long n,k,h=0;
	cin>>n;
	while(n--) {
		cin>>k;
		h=0;
		if(k==0) {
			puts("NO!");
			continue;
		}
		k=(k<<1)+1;
		while(k&1) {
			k*=(k>>1)+1;
			h++;
		}
		cout<<h<<'\n';
	}
	return 0;
}


```

---

## 作者：MnZnOIer (赞：0)

看题面，应该是数学找规律。

我们充分发扬人类智慧，先用暴力打个表，然后再根据数学直觉，把 $8$ 个放在一行，然后就会发现，每一行都是：`1 2 1 3 1 2 1 x`，$x$ 有什么规律呢？不清楚，但是我们可以想到，这样子的时间复杂度已经优化了很多了，所以我们可以直接暴力求出 $x$，亲测跑得飞快，然后就做完了。

补：实现：

暴力（$a$ 表示 $k$ 的分子）：
```cpp
a = k * 2 + 1;
int ans = 0;
while (a & 1)
{
	a = a * (a + 1) / 2;
	++ ans;
}
```
剩下的就是一张表的事了。

---

## 作者：Ekin123 (赞：0)

~~胡乱猜测~~数学题。

## 大胆尝试

首先，令输入的 $k$ 变为 $2k+1$，这就是 $r = \frac{2k+1}{2}$，我们取走分子，记作 $a$。

然后，
1. 进行判断，
2. 若 $a$ 为偶，则退出。
3. 否则，按照题意，取 $\left \lceil r \right \rceil=k+1$，并相乘，得到新分子 $a' = a(k+1)=ak+a$，并将操作次数加一，回到第一步。

这种方式可以通过所有数据，但因为是尝试，时间复杂度不好分析，OI 赛制可能会~~估分不准~~被数据卡死。

## 数学分析

用上一种方式多打几个表，可以找到规律：因子 $2$ 的数量加 $1$。

整体时间复杂度 $O(T \log k)$（$k$ 为输入）。

Talk is Cheap,Show me your CODE.

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

long long solve(long long x)
{
	long long r = (x - 1) / 2 + 1;
	if(x % 2 == 0)
	{
		return 0;
	}
	return solve(x * r) + 1;
}

int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		long long k;
		cin >> k;
		if(k == 0)
		{
			cout << "NO!" << endl;
			continue;
		}
		long long res = solve(k * 2 + 1);
		cout << res << endl;
	}
	return 0;
} 
```
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		long long k;
		cin >> k;
		if(k == 0)
		{
			cout << "NO!" << endl;
			continue;
		}
		int cnt = 1;
		while(k % 2ll == 0)
		{
			cnt++;
			k /= 2;
		}
		cout << cnt << endl;
	}
	return 0;
} 
```

---

## 作者：lihl (赞：0)

不难发现，若 $k=0$，无解；若 $k\nmid 2$，则答案是 $1$，最后乘出的结果为 $2k+1$。

不难发现，若 $k\mid 2$，则设 $k=2^x$，显然 $r_0=2^x + 2^{-1},r_1=2^{2x}+2^{x-1}+2^{x+1}+2^{-1}=k^2+\frac{k}{2}+k+2^{-1}$。显然 $k^2\mid 2,k\mid 2$，所以对答案有贡献的是 $k=2^x$。于是不难发现，当进行 $y$ 次操作后，若 $k\times 2^{-y} \nmid 2$，则转换至 $k\nmid 2$ 的情况。此时显然 $y=\operatorname{popc}(k)$。则答案为 $\operatorname{popc}(k)+1$。

---

## 作者：z_yq (赞：0)

# 思路
发现如果一个实数 $x$，判定是否为整数的方法十分简单，只需要扔掉它的整数位，看实数位是否为 $0$ 就好了，那怎么判定呢？\
首先给出的数字为 $k+\frac{1}{2}$ 那么我们可以把 $k$ 扔掉变成 $\frac{1}{2}$，如果 $k$ 是个奇数，那么只要乘上 $1$ 次就可以变成整数，如果 $k$ 是个偶数，手玩发现接下来要乘的数是 $k^2+\frac{3}{2}k+1$，数变为 $k^4+3k^3+\frac{15}{4}k^2+\frac{9}{4}k+\frac{1}{2}$，首先 $k$ 是整数而且被 $2$ 整除，那么 $k^2$ 必然被 $4$ 整除，那么我们继续抛弃整数部分变为 $\frac{9}{4}k+\frac{1}{2}$，如果仍然不是整数说明 $k$ 可以被 $4$ 整除，接下来继续手推或者猜测，可以发现如果操作了 $3$ 次仍然不是整数，那么 $k$ 就被 $8$ 整除。所以最终的答案就是 $k$ 中质因子 $2$ 的个数加一，要特判 $k = 0$ 的情况。
# $Code$
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=1e6+9;
ll T,n,num;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;num=0;
		if(n==0)cout<<"NO!\n";
		else
		{
			while(n%2==0)
			{
				n>>=1;
				num++;
			}
			cout<<num+1<<endl;
		}
	}
	return 0; 
}
/*
k odd 1
k+k/2 odd 2

*/
```

---


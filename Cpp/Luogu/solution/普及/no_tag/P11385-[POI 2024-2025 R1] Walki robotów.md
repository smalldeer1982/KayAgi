# [POI 2024/2025 R1] Walki robotów

## 题目背景

原题译自 [POI 2024/2025 R1 Walki robotów](https://sio2.mimuw.edu.pl/c/oi32-1/p/wal/)。

## 题目描述

在 Bajtocji 正在进行一场大型年度机器人锦标赛，其中有 $n$ 个机器人参赛，它们的编号从 $1$ 到 $n$。第 $i$ 个机器人由两个参数描述，$s_{i}$ 和 $z_{i}\ (1 \leq s_{i}, z_{i} \leq n)$，分别表示机器人的力量和敏捷度。力量值 $s_{i}$ 各不相同。敏捷度值 $z_{i}$ 也各不相同。

锦标赛由一系列单挑比赛组成。在每场比赛中，两个尚未被淘汰的机器人进行对决。在第 $i$ 个机器人对战第 $j$ 个机器人的比赛中，如果 $s_{i}>s_{j}$ 或 $z_{i}>z_{j}$，那么第 $i$ 个机器人将淘汰第 $j$ 个机器人。相应地，如果 $s_{i}<s_{j}$ 或 $z_{i}<z_{j}$，那么第 $j$ 个机器人将淘汰第 $i$ 个机器人。请注意，这意味着在同一场比赛中可能会有两个机器人都被淘汰。如果某个机器人没有在比赛中被淘汰，它可以继续参与后续比赛。

只有当最终所有机器人都被淘汰时，锦标赛的直播收视率才能最高。你的任务是检查是否可以安排一系列比赛，使得最终所有机器人都被淘汰。

## 说明/提示

对于样例一，如果在第一场比赛中第一个和第二个机器人对决，第二场比赛中第三个和第四个机器人对决，那么所有机器人都将被淘汰。

对于样例三，该样例满足 $n=8, s_{i}=i, z_{i}=n-i+1$。

对于样例四，该样例满足 $n=20$，存在一个机器人可以击败所有其他机器人，并且没有机器人可以击败它。

对于样例五，该样例满足 $n=500$，可以将所有机器人配对，使每对机器人互相淘汰。

对于样例六，该样例满足 $n=200000, s_{i}=i$ 且 $z_{i}=i$ 对 $1 \leq i \leq \frac{n}{2}$，并且 $s_{i}=i$ 且 $z_{i}=\frac{3n}{2}-i+1$ 对 $\frac{n}{2}<i \leq n$。

对于样例七，该样例满足 $n=5$。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :----------- | :----------- |
| $1$ | $n \leq 8$ | $10$ |
| $2$ | $n \leq 20$ | $10$ |
| $3$ | $n \leq 1000$ | $30$ |
| $4$ | 无特殊性质 | $50$ |

## 样例 #1

### 输入

```
4
1 4
2 2
3 3
4 1```

### 输出

```
TAK```

## 样例 #2

### 输入

```
2
1 1
2 2```

### 输出

```
NIE```

## 样例 #3

### 输入

```
见下发 wal1ocen.in```

### 输出

```
见下发 wal1ocen.out```

## 样例 #4

### 输入

```
见下发 wal2ocen.in```

### 输出

```
见下发 wal2ocen.out```

## 样例 #5

### 输入

```
见下发 wal3ocen.in```

### 输出

```
见下发 wal3ocen.out```

## 样例 #6

### 输入

```
见下发 wal4ocen.in```

### 输出

```
见下发 wal4ocen.out```

## 样例 #7

### 输入

```
见下发 wal5ocen.in```

### 输出

```
见下发 wal5ocen.out```

# 题解

## 作者：FanzhuoOVO (赞：6)

## 题意
有若干个机器人要比赛，每个机器人有一个力量和敏捷度，如果在比赛时这两项值任意一个大于对手，就可以将对手淘汰。如果这两项值一个大于对方一个小于对方，就会同归于尽。现在需要安排机器人比赛顺序使所有机器人都被同归于尽。如果可以，输出 ```TAK```，否者输出 ```NIE```。

## 思路
先按照力量升序排序。
![](https://cdn.luogu.com.cn/upload/image_hosting/juamdoau.png)
排完后，用力量从小到大找出若干条路径。
![](https://cdn.luogu.com.cn/upload/image_hosting/t12qcoeh.png)
这样子，每条路径的终点是可以一路“吃”下去的，最后会剩下两个高手机器人，它们可以同归于尽，所以是 ```TAK```。

所以，我们可以发现，如果路径是**偶数个**，那么一定是 ```TAK```。那要是路径为奇数个呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/dw3hta88.png)

如果有这些机器人，那么找出路径后如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/p6jhb8u9.png)

“吃”完后剩下奇数个高手，同归于尽不了啊。

其实是可以的。

![](https://cdn.luogu.com.cn/upload/image_hosting/0d0jj1y9.png)

让一个高手跳过一个本该被它“吃”掉的机器人，让它最后去和多出的那个高手（见图中红色路径）同归于尽。

如果找不到这样的“小兵”去碰高手，才输出 ```NIE```。

完活！

感谢 [**purinliang**](https://www.luogu.com.cn/user/177859) 的教导。

---

## 作者：UnfortunatelyDead (赞：5)

别样的碰♂碰♂车♂大战。

不妨称 $(i,j)$ 是“死对头”满足 $i$ 和 $j$ 能互相淘汰对方。

考虑我们优先把每个 $i$ 满足存在一个 $j$ 能把 $i$ 偏序（即有 $s_j>s_i$ 和 $z_j>z_i$）的 $i$ 先给淘汰了，那么剩下的一定都是两两互为“死对头”。

我们记剩下的个数为 $c$ 个，集合为 $S$，那么我们最后剩下来的一定是有 $c \bmod 2$ 个，那如果 $c \bmod 2=1$ 该如何呢？

我们发现，如果存在已经被淘汰掉的某个数 $x$ 与剩下的某个数 $y$ 存在“死对头”关系，那么只需要让 $(x,y)$ 决斗便可使 $c \bmod 2=0$ 了。

换句话说，当且仅当 $\min_{i \in S} s_i = \min_{i \in S} z_i = n - c + 1$ 时不存在答案，因为只有这样才会满足前 $c$ 大的都被选掉，而无法存在另一个 $x$ 能淘汰掉任何。

```cpp
signed main() {
	read(n);
	for (int i=1;i<=n;++i) read(a[i].F,a[i].S);
	sort(a+1,a+1+n); set<int> A, B;
	for (int i=n;i;--i) {
		if (B.empty() || *B.rbegin() < a[i].S) {
			A.insert(i); B.insert(a[i].S);
		}
	}
	puts((A.size() % 2 && *A.begin() == n - A.size() + 1 && *B.begin() == n - B.size() + 1) ? "NIE" : "TAK");
	return 0;
}
```

---

## 作者：Duanhen (赞：5)

## 题目大意

有 $n$ 个机器人，编号从 $1$ 到 $n$。第 $i$ 个机器人有两个参数 $s_{i}$ 和 $z_{i}\ (1 \leq s_{i}, z_{i} \leq n)$，而所有机器人的 $s_{i}$ 和 $z_{i}$ 都各不相同。

对于两个尚未被淘汰的机器人 $i$ 和 $j$，如果 $s_{i}>s_{j}$ 或 $z_{i}>z_{j}$，那么第 $i$ 个机器人将淘汰第 $j$ 个机器人。如果 $s_{i}<s_{j}$ 或 $z_{i}<z_{j}$，那么第 $j$ 个机器人将淘汰第 $i$ 个机器人。如果出现一大一小的情况就意味着两个机器人同归于尽。

你需要做出一系列比赛安排使得机器人全部被淘汰。

## 解题思路

由**贪心**的思想我们很容易想到先把那些可以被单独淘汰的机器人先淘汰掉，那么剩下来的机器人们只会是两两同归于尽，没有办法单独淘汰对手，那如果此时剩下的机器人是偶数个，那么让他们两两比赛就可以满足全淘汰的要求。而难点是如果剩下的个数是奇数怎么办？

我们可能会想到从那些已经被单独淘汰的机器人中找一个可以跟剩下的任意一个机器人同归于尽的，把剩下的机器人淘汰掉一只，使其变为偶数，而我们如何判断有没有这样的机器人存在呢？

答案就是判断剩下的机器人中两个属性的最小值的情况，怎么个判断法？我们先把两个最小属性值 $m1$ 和 $m2$ 找出来，如果不满足 $m1=m2=n-cnt+1$，那么就存在符合上述需求的机器人（$cnt$ 是剩下机器人的个数）。因为如果满足 $m1=m2=n-cnt+1$ 的话，就证明淘汰的那 $i$ 个机器人每个的两个属性值都不会大于 $i$，也就是剩下的机器人中随便一个机器人的属性都比所有淘汰掉的机器人大，自然就不满足一开始的需求了，此时就是无解的情况。

## 参考代码
``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 10;
struct rb {
  ll s, z;
} g[N], q[N];
bool st[N];
bool cmp(rb &a, rb &b) { return a.s > b.s; }

int main() {
  ll n, cnt = 0;
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> g[i].s >> g[i].z;
  sort(g + 1, g + n + 1, cmp);
  for (int i = 1; i < n; i++) {
    if (st[i]) continue;  // 如果该机器人已经被它前面的淘汰了，就直接跳过
    for (int j = i + 1; j <= n; j++) {
      if (g[i].z > g[j].z) st[j] = true;
      else break;
    }
    q[++cnt] = g[i];
  }
  if (!st[n]) q[++cnt] = g[n];
  ll m1 = 1e12, m2 = 1e12;
  for (int i = 1; i <= cnt; i++) 
    m1 = min(m1, q[i].s), m2 = min(m2, q[i].z);
  if (cnt % 2 == 0 || !(m1 == m2 && m1 == n - cnt + 1))
    cout << "TAK" << endl;
  else
    cout << "NIE" << endl;
  return 0;
}
```

---

## 作者：Aix_Eric (赞：0)

## solution:
### [传送门](https://www.luogu.com.cn/problem/P11385)
#### 题意：
$n$ 个机器人，每个机器人有两个属性：力量 $s$ 和敏捷度 $z$。

---

1. 先将机器人按力量大小排序。
1. 用 $a$ ， $b$ 集合维护所选机器人的 下标 $i$ 和 敏捷度 $z$。
1. 机器人排序后，逆序遍历。使每次选择的机器人的敏捷度大于之前选择的机器人的敏捷度。
1. 如果机器人 $s_i > s_j$ 且 $z_i > z_j$ 那么 $j$ 被淘汰 $i$ 不被淘汰。


---


设剩下机器人为集合 $S$。如果 $S$ 大小为偶，说明一定能淘汰完。

如果为奇数，并且：
- 选择的机器人中最小的索引等于 $n - \text选择个数 + 1$。
- 选择的机器人的最小敏捷度等于 $n - \text选择个数 + 1$。

则不能淘汰完，输出 ```NIE```。

否则输出 ```TAK```。

#### code: 
```cpp
#include <iostream>
#include <set>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct Robot{
    int s, z;
}r[N];
bool cmp(Robot a, Robot b){
    if(a.s == b.s) return a.z < b.z;
    return a.s < b.s;
}
set<int> a, b;
int main(){
    int n; cin >> n;
    for(int i = 1;i <= n;i++)
        cin >> r[i].s >> r[i].z;
    sort(r + 1, r + n + 1, cmp);//1 升序排序
    for(int i = n;i >= 1;i--){ //1 倒序遍历
        if(a.empty() || (*a.rbegin()) < r[i].z)
            b.insert(i), a.insert(r[i].z); //1 放机器人
    }
    int l = b.size(), s = a.size();
    if(l % 2 && *b.begin() == n - l + 1 && *a.begin() == n - s + 1)
        cout << "NIE\n"; 
    else cout << "TAK\n";
    return 0;
}
```

---

## 作者：VelvetChords (赞：0)

# P11385 [POI 2024/2025 R1] Walki robotów

## 0.前言
本来一眼签到题的（额）。

是谁最初冒泡样例过不去，又是谁奇偶性分析到吐？是我，是我！

感谢[这篇文章](https://www.luogu.com.cn/article/4vjvbo2q)对我思路的修修补补，终于理解。

## 1.思路
对于每一对机器人 $i$ 和 $j$，我们称它们是“对手”当且仅当机器人 $i$ 的敏捷度 $s_i$ 小于机器人 $j$ 的敏捷度 $s_j$，且机器人 $i$ 的力量 $z_i$ 小于机器人 $j$ 的力量 $z_j$。

换句话说，机器人 $j$ 能够在这两个方面完全压制机器人 $i$。

问题的描述中提到，首先优先将那些能够被其他机器人淘汰的机器人从集合中移除，剩下的机器人无法被其他机器人压制，这就是我们称之为“对手”的集合。

经过淘汰操作后，我们得到一个新的机器人集合 $S$，其中包含了无法被淘汰的机器人。假设集合 $S$ 中的机器人数量为 $c$。

剩下的 $c$ 个机器人，如果能两两配对，每对是“对手”，那么就可以完成淘汰过程。关键的问题在于，**剩下的机器人数量 $c$ 是偶数还是奇数**。

- 如果 $c$ 是偶数，那么可以将所有剩下的机器人两两配对，最终每对机器人都互相淘汰对方，问题就可以解决。
- 如果 $c$ 是奇数，那么至少有一个机器人无法配对。这个时候就需要考虑如何处理这个多出来的机器人。

如果已经被淘汰的某个机器人 $x$ 和剩下的机器人 $y$ 之间存在“对手”关系（即 $x$ 能够淘汰 $y$），那么就可以通过让 $x$ 和 $y$ 进行“决斗”来进一步淘汰掉 $y$，从而使得剩下的机器人数量变为偶数。

然而，如果剩下的 $c$ 个机器人满足某些特殊条件，那么就无法通过上述方法使得剩余数量变为偶数。

具体来说，当且仅当**剩下的机器人的最小敏捷度和最小力量都满足以下条件时**：$\min_{i \in S} s_i = \min_{i \in S} z_i = n - c + 1$

$c$ 是剩余机器人的数量。

这意味着剩下的 $c$ 个机器人，敏捷度和力量都刚好处于一个“临界值”，即它们的最小值正好等于 $n-c+1$，这种情况下**没有机器人能够被进一步淘汰**，也没有已淘汰的机器人能够与它们配对并消除奇数个剩余机器人的问题。这个条件意味着在剩下的机器人中，最弱的那些机器人（最小敏捷度和最小力量的机器人）已经无法通过“对手”关系被进一步淘汰。

而且，无法通过淘汰已经被剔除的机器人来消除剩余机器人中的奇数个。

因此，在这种情况下，问题无法解决，因为剩下的机器人已经完全符合条件，且无法通过配对来调整数量。

---


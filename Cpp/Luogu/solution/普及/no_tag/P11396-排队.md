# 排队

## 题目描述

第一届喵喵喵编程大赛即将开始，本次比赛有 $n$ 只喵喵参赛，编号依次为 $1,2,\ldots, n$，已经分成了若干组，每一组喵喵的编号都是连续的一段。

根据报名情况，你已经知道第 $i$ 只喵喵会第 $p_i$ 个到达现场，保证 $p_i$ 构成 $1\sim n$ 的排列。

一组喵喵的到达时间被定义为这一组喵喵中**最早到达**的喵喵的到达时间。

喵喵的排队规则如下：

- 先把所有的喵喵组按每组喵喵的到达时间从小到大排序。
- 然后对于同一组喵喵，按照每只喵喵的到达时间从小到大排序。

按照这个排队规则，可以得到一个新的排列 $q_1,\ldots,q_n$，其中 $q_i$ 表示从前往后第 $i$ 只喵喵的**到达时间**。

你已经知道了所有 $p_i$，但是不清楚喵喵的分组，你想知道排列 $q_1,q_2,\ldots,q_n$ 的字典序最大可能是什么。

## 说明/提示

【样例 1 解释】

所有可能的分组情况有 $8$ 种可能，下面分别列出：

|分组情况|最终排列 $q$|
|:-:|:-:|
|$(2)(1)(4)(3)$|$1,2,3,4$|
|$(2)(1)(4,3)$|$1,2,3,4$|
|$(2)(1,4)(3)$|$1,4,2,3$|
|$(2)(1,4,3)$|$1,3,4,2$|
|$(2,1)(4)(3)$|$1,2,3,4$|
|$(2,1)(4,3)$|$1,2,3,4$|
|$(2,1,4)(3)$|$1,2,4,3$|
|$(2,1,4,3)$|$1,2,3,4$|

关于表格，我们以 $(2)(1,4,3)$ 这个分组方式为例，演示排队结果的计算：

- 首先 $(2)$ 这组喵喵的到达时间为第 $2$，$(1,4,3)$ 这组喵喵的到达时间为第 $1$，从而 $(1,4,3)$ 排在前面。
- 然后 $(1,4,3)$ 这组喵喵内部按照到达时间排序，得到 $1,3,4$；$(2)$ 这组喵喵内部按照到达时间排序得到 $2$。
- 最后把每组喵喵的排序结果拼起来，得到 $1,3,4,2$。

【样例 2 解释】

读者不难验证，无论喵喵怎么分组，因为无论组内还是组外都是从小到大排序的，所以 $q_i$ 永远是 $1,2,3,4,5,6$。

【数据范围】

对于全体数据，保证 $1\le n\le 3\times 10^5$，且 $p_i$ 构成 $1\sim n$ 的一个排列。

|子任务编号|$n\le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|
|1|$3$||11|
|2|$16$||16|
|3|$2000$||22|
|4|$3\times 10^5$|A|17|
|5|$3\times 10^5$||34|

- 特殊性质 A：存在 $1\le k\le n$ 使得 $p_1>p_2>\ldots >p_{k-1}> p_k < p_{k+1}<\ldots < p_n$。例如，样例 2 就是 $k=6$ 的情形。

## 样例 #1

### 输入

```
4
2 1 4 3
```

### 输出

```
1 4 2 3
```

## 样例 #2

### 输入

```
6
6 5 4 3 2 1
```

### 输出

```
1 2 3 4 5 6
```

# 题解

## 作者：I_Love_DS (赞：20)

[更好的阅读体验？](https://www.luogu.com.cn/article/nek2eoee)

## Subtask #1

分类讨论即可。

时间复杂度 $O(1)$。

## Subtask #2

暴力搜索每个猫猫后面要不要放隔板。假设最后一只猫后面一定要放隔板。再进行 $O(n)$ 的判定合法并更新答案。

时间复杂度 $O(n2^n)$。

Code:

```cpp
struct node {
	int x, y;
	friend bool operator < (const node &x, const node &y) {
		return x.x == y.x ? x.y < y.y : x.x < y.x;
	}
} b[N];

bool check() {
	for (int i = 1; i <= n; i++) {
		if (q[i] < b[i].y) return 1;
		else if (q[i] > b[i].y) return 0;
	}
	return 0;
}

void subtask2() {
	for (int i = 1; i <= n; i++) q[i] = -1;
	for (int i = 1 << (n - 1); i < (1 << n); i++) {
		int l = 0;
		for (int j = 0; j < n; j++) 
			if (i & (1 << j)) {
				int mn = 1 << 30;
				for (int k = l + 1; k <= j + 1; k++) 
					mn = min(mn, a[k]);
				for (int k = l + 1; k <= j + 1; k++) 
					b[k] = {mn, a[k]};
				l = j + 1;
			}
		sort(b + 1, b + n + 1);
		if (check()) 
			for (int j = 1; j <= n; j++) 
				q[j] = b[j].y;
	}
	for (int i = 1; i <= n; i++) 
		printf("%d ", q[i]);
}
```

## Subtask #4

显然 $a_k$ 最小。那么根据题意，应让字典序最大。

你会发现无论怎么分，$a_k$ 总是在第一位。

那么定下了第一位为 $a_k$，剩下的呢？

应当**以 $a_k$ 为连通块**的区域进行分第一组。因为由题可知一组组内成员一定在其他组的前面。

那么我们要使第二位尽可能大，应当选择 $a_k$ 左面或右面更大者。**可以证明只选左/右面优于左右都选。因为都选的话第二个值就会变成左右最小值了**。

因为 $a$ 是 $1 \sim n$ 的一个排列，所以不用担心 $a_{k-1}=a_{k+1}$ 的问题。

选完了第一组，剩下的就全是第二组啦！

也许我的语言并不完善，边看代码边食用更佳。

```cpp
void subtask4() {
	int k = 0;
	for (int i = 1; i <= n && !k; i++) 
		if (a[i] == 1) 
			k = i; // 找到最小值 a[k]
	if (a[k - 1] > a[k + 1]) { // 找更大的当答案的第二位
		for (int i = k; i; --i) 
			printf("%d ", a[i]); // 根据性质
		for (int i = k + 1; i <= n; i++) 
			printf("%d ", a[i]); // 
	} else {
		for (int i = k; i <= n; i++) 
			printf("%d ", a[i]); // 
		for (int i = k - 1; i; --i) 
			printf("%d ", a[i]); // 
	}
	printf("\n");
}
```

## Subtask #5

可以从 Subtask #4 推广而来。

**更一般的**，假设当前选了若干组，剩下猫猫的集合为 $S$。

那么当前 $S$ 内的最小值（记为 $x$）就是下一个入场的猫猫。

根据 Subtask #4 的结论，我们应选择 $x$ 左面或右面的元素，这取决于哪边的元素更大。

代码实现时，可以用堆或者 `set` 来维护 $S$。我们还要记录这个猫猫是否已经在队伍里了。详见代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 3e5 + 50;

int n, a[N], q[N];

set <int> s; // 集合 S，本代码使用 set 实现
int id[N], vis[N];
// id 是这个猫猫的下标，vis 是这个猫猫是否进队

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) id[a[i]] = i;
	for (int i = 1; i <= n; i++) s.insert(a[i]); // 最初所有猫猫都在 S 里
	vis[0] = vis[n + 1] = 1; // 方便后续代码，不用再判边界
	while (!s.empty()) { // 有猫猫没进队
		int x = *s.begin(), y = id[x]; // a[y] 为最小猫猫入场时间
		//cerr << x << " " << y << endl; // 114514
		vis[y] = 1; // 取走啦
		s.erase(x); // 删除啦
		printf("%d ", x); // 进队啦
		if (!vis[y - 1] && !vis[y + 1]) { // 都没有取走呀
			if (a[y - 1] > a[y + 1]) { // 左面的更大捏
				vis[y - 1] = 1; // 取走啦
				s.erase(a[y - 1]); // 删除啦
				printf("%d ", a[y - 1]); // 进队啦
				for (int i = y - 2; i >= 1 && a[i] > a[i + 1] && !vis[i]; i--) {
					vis[i] = 1;
					s.erase(a[i]);
					printf("%d ", a[i]);
				} // 自行理解吧
			} else { // 右面的更大捏
				vis[y + 1] = 1; // 取走啦
				s.erase(a[y + 1]); // 删除啦
				printf("%d ", a[y + 1]); // 进队啦
				for (int i = y + 2; i <= n && a[i] > a[i - 1] && !vis[i]; i++) {
					vis[i] = 1;
					s.erase(a[i]);
					printf("%d ", a[i]);
				} // 自行理解吧	
			}
		} else if (!vis[y - 1]) { // 只有左面有猫猫
			vis[y - 1] = 1; // 取走啦
			s.erase(a[y - 1]); // 删除啦
			printf("%d ", a[y - 1]); // 进队啦
			for (int i = y - 2; i >= 1 && a[i] > a[i + 1] && !vis[i]; i--) {
				vis[i] = 1;
				s.erase(a[i]);
				printf("%d ", a[i]);
			} // 自行理解吧	
		} else if (!vis[y + 1]) { // 只有右面有猫猫
			vis[y + 1] = 1; // 取走啦
			s.erase(a[y + 1]); // 删除啦
			printf("%d ", a[y + 1]); // 进队啦
			for (int i = y + 2; i <= n && a[i] > a[i - 1] && !vis[i]; i++) {
				vis[i] = 1;
				s.erase(a[i]);
				printf("%d ", a[i]);
			} // 自行理解吧	
		}
	}
	return 0;
}
```

看我写了这么多，留下个赞不过分吧……

---

## 作者：yummy (赞：4)

# B. 排队 官方题解

本题考察的主要知识点：

- 【3】贪心法

### 特殊性质 A

我们不难发现，$p_i=1$ 的喵喵必然排在第一个，因此要想 $q$ 的字典序尽量大，我们需要让 $1$ 所在这一组的第二小尽量大，然后是第 $3$ 小，以此类推。

那么 $1$ 所在这一组的次小喵喵，肯定不大于 $\max(p_{i-1},p_{i+1})$，因此为了最大化 $q_2$，我们肯定要让 $p_{i-1},p_{i+1}$ 中的**较大值**成为第二名，并且较小值**不能出现**在 $1$ 所在的这一组。（否则 $q_2$ 会变小。）

最大化 $q_2$（不妨假设是 $p_{i+1}$，另一方向同理）后，考虑 $q_3$。由于 $1$ 所在的这一组只能往一个方向延伸，分类讨论：

- 如果 $q_3$ 和 $q_1,q_2$ 同一组，那么是 $p_{i+2}$。
- 否则 $q_3$ 是除了 $q_1,q_2$ 外最小的一只，肯定不大于 $p_{i+2}$。

因此，若 $p_{i+2}>p_{i+1}$，则把 $1$ 所在的这一组接着延伸肯定不劣。

对于特殊性质 A 而言，把 $1$ 所在的这个方向全部分进一组后，剩下的喵喵单调，所以怎么排序都一样了。

### 正解

我们整理并一般化刚才的观察：

- 每次找出当前最小的没排队的喵喵 $p_i$。
- 比较 $p_{i-1},p_{i+1}$，然后选择较大值作为延伸方向。
- 往这个方向延伸，直到该方向的下一个元素 $p_j$ 不再单调递增为止。（因为如果继续延伸，会导致插队使得字典序变小）。

每次找最小没排队喵喵可以使用 `priority_queue` 或 `set`，但是我们显然有更聪明的办法。

令 $pos(i)$ 为第 $i$ 个到的喵喵编号，则外层循环枚举 $1\sim n$，然后如果 $i$ 这个喵喵排过了就 `continue`，否则以它开头尝试延伸即可。

另一个小技巧：排过队的喵喵直接把 $p$ 设成极小值，就永远不会被延伸到了。

参考 C++ 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p[300005],pos[300005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&p[i]);
		pos[p[i]]=i;
	}
	for(int i=1;i<=n;i++){
		int init=pos[i],j;
		if(p[init]==0)continue;
		if(p[init-1]<p[init+1])
			for(j=init;p[j+1]>p[j];j++){
				printf("%d ",p[j]);
				p[j]=0;
			}
		else
			for(j=init;p[j-1]>p[j];j--){
				printf("%d ",p[j]);
				p[j]=0;
			}
		printf("%d ",p[j]);
		p[j]=0;
	}
	return 0;
}
```

---

## 作者：hhztl (赞：3)

题目的意思实在概括不出来，直接说思路吧。
## 思路解析
考虑贪心。由于排序的第一关键字是队伍中最早到达的喵喵的到达时间，所以可以给较早到达的喵喵匹配较晚到达的队友。

那么如何实现呢？

先对 $p$ 数组进行排序，记排序后的数组为 $a$。从 $1$ 开始遍历 $a$ 数组，对每个没有被选过的 $a_i$，向它所在 $p$ 数组中的位置的左右两边中 $p_i$ 更大的一边拓展上升序列。

要注意判断当前遍历到的是否已被选过，不然会死的很惨。
## Code:
赛时代码，有点屎山，马蜂清奇。事实上不需要这么写。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ull unsigned long long
#define rep1(i,x,y) for(register int i=(x);i<=(y);i++)
#define rep2(i,x,y) for(register int i=(x);i>=(y);i--)
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define writesp(x) write(x),putchar(' ')
#define writeln(x) write(x),putchar('\n')
#define sp putchar(' ')
#define ln putchar('\n')
int read(){int x=0;bool p=0;char c=getchar();while(c<'0'||c>'9'){p=(c=='-'?1:p);c=getchar();}while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}return p?~(x-1):x;}
void write(int x){if(x<0){putchar('-');x=~(x-1);}if(x>9)write(x/10);putchar(x%10|48);}
void fre(){freopen("","r",stdin);freopen("","w",stdout);}
//以上火车头，请略过
struct node{
	int s,l,r;//s记录p[i]的值，l记录p[i-1]的值，r记录p[i+1]的值
	bool operator<(const node &x){return s<x.s;}//重载运算符，写个cmp也差不多
}a[300010];
int n,tt[300010],l,ans[300010];//tt[i]表示值为i的元素的下标，ans记录答案
bool p[300010];//记录是否被选过
signed main(){
//	fre();
	n=read();
	rep1(i,1,n){
		a[i].s=read();
	}rep1(i,1,n){
		a[i].l=a[i-1].s;
		a[i].r=a[i+1].s;
	}sort(a+1,a+n+1);
	rep1(i,1,n)tt[a[i].s]=i;
	rep1(i,1,n){
		if(p[i])continue;//判断是否选过
		int x=i;
		ans[++l]=a[i].s;//记录答案，其实直接输出也可以
		p[i]=1;//标记选过
		while(a[x].l>a[x].s&&a[x].l>0&&!p[tt[a[x].l]]||a[x].r>a[x].s&&a[x].r>0&&!p[tt[a[x].r]]){//判断是否可以选，一定要判左右两边是否被选过
			if(a[x].l>a[x].r&&!p[tt[a[x].l]]||!p[tt[a[x].l]]&&p[tt[a[x].r]]){//若选左边更优
				ans[++l]=a[x].l;
				x=tt[a[x].l];
				p[x]=1;
			}else{//不然选右边更优
				ans[++l]=a[x].r;
				x=tt[a[x].r];
				p[x]=1;
			}
		}
	}rep1(i,1,n)writesp(ans[i]);//输出答案
	return 0;
}
```

---

## 作者：foglake (赞：2)

# P11396 排队
~~直接把机房大蛇的思路搬过来水一发。~~

### 核心思路：贪心

首先假设我们已经分好了一大堆数。那么下一组一定是剩下里面最小的数所分到的那一组。

接下来就是如何划分这一组的问题了。

首先，因为每一组是连续区间，所以在区间划分上可以看作从一点进行拓展。当然，很容易看出当我们左（右）端点下一个要拓展的数比左（右）端点大时，拓展之后字典序一定更大。

可以发现，在起点拓展时，只往大的那个数拓展即可，因为如果再向另一边拓展或只往另一边拓展，答案一定更劣。

### 代码
在实现上还有细节，比如要使拓展时不要拓展到已选过的点（比如打个标记或直接使其等于零）。

```
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 3e5 + 10;
int t[maxn], m[maxn];
int Found(int x, int p) {
	while (t[x] < t[x + p]) {
		t[x] = 0;
		x += p;
		printf("%d ", t[x]);
	}
	return x;
}
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", t + i);
		m[t[i]] = i; //建立映射，方便找之后剩余的最小数 
	}
	for (int i = 1; i <= n; i++) {
		if (t[m[i]] == 0) continue;
		int e;  
		printf("%d ", t[m[i]]);
		if (t[m[i] - 1] > t[m[i] + 1]) e = Found(m[i], -1); // 向左拓展 
		else if (t[m[i] - 1] < t[m[i] + 1]) e = Found(m[i], 1); // 向右拓展 
		t[e] = 0;// 由于前面没有把右端点赋零，在这补上 
	}
}
```

---

## 作者：dongzirui0817 (赞：2)

## 思路

可以顺序枚举每一个喵喵组。

枚举方案：从第 $1$ 只到的喵喵枚举到第 $n$ 只到的喵喵，如果这只喵喵此时是某一组中的喵喵就跳过。否则就枚举这一组喵喵，这组喵喵的到达时间就是这只喵喵的到达时间。（因为比它早到的喵喵都在其他组中）

考虑枚举这组喵喵的方法，可以利用贪心。按照字典序的概念，只要顾及现在的最大化即可。

下面是分类讨论。

- - -

1. 这只喵喵独自为组。

这时要保证它相邻的喵喵此时均在某一组，否则对于答案来说是不会更好的。

2. 往左边的喵喵选，与这只喵喵一组，不选它右边的喵喵。

这时要保证这只喵喵满足以下条件之一：

- 它的右侧没有喵喵。
- 它右侧相邻的喵喵现在已经在别组中。
- 它右侧相邻的喵喵来的没有它左侧相邻的喵喵来的早。

如果不满足，那么这样选答案会更劣。（显然可以不选左侧的喵喵，而选它右侧相邻的喵喵）

选择时，要保证选择的喵喵（除了初始选择的喵喵），要比它右侧相邻的喵喵来的晚，且现在不在其他组中。不然在对这组喵喵排序时，这只喵喵来的时间会排到它右侧相邻的喵喵前去，让答案变劣。

形式话说，设现在考虑到第 $i$ 只小猫（不是初始小猫），要保证：

- 现在不在其他组中。
- $p_i > p _ {i + 1}$。

3. 往右边的喵喵选，与这只喵喵一组，不选它左边的喵喵。
~~说实话和第 $2$ 种分类讨论差不多。~~

这时要保证这只喵喵满足以下条件之一：

- 它的左侧没有喵喵。
- 它左侧相邻的喵喵现在已经在别组中。
- 它左侧相邻的喵喵来的没有它右侧相邻的喵喵来的早。

如果不满足，那么这样选答案会更劣。（显然可以不选右侧的喵喵，而选它左侧相邻的喵喵）

选择时，要保证选择的喵喵（除了初始选择的喵喵），要比它左侧相邻的喵喵来的晚，且现在不在其他组中。不然在对这组喵喵排序时，这只喵喵来的时间会排到它左侧相邻的喵喵前去，让答案变劣。

形式话说，设现在考虑到第 $i$ 只小猫（不是初始小猫），要保证：

- 现在不在其他组中。
- $p_i > p _ {i - 1}$。

4. 往左右方向均选。

这时是会更劣的。设这只喵喵是第 $i$ 个喵喵。

因为 $p$ 是一个排列。

所以 $p_{i - 1} \not = p_{i + 1}$。

所以如果跟着选 $p_{i - 1}$ 和 $p_{i + 1}$ 更小的一个，答案会更劣。

- - -

所以只要在代码中讨论 $1, \, 2, \, 3$ 种即可。

关于选了的喵喵，就用一个数组 $b$ 记录，看第 $i$ 只小猫此时有没有被选中，就直接查询 $b_i$。

具体细节参考下面代码。（赛时写的，有些凌乱）

- - -

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int p[300010];
bool b[300010];
int c[300010];

int main() {
	cin >> n;
	for (int i = 1 ; i <= n ; i++) cin >> p[i], c[p[i]] = i;
	for (int i = 1 ; i <= n ; i++) {
		if (b[c[i] + 1] && b[c[i] - 1]) {
			if (!b[c[i]]) printf("%d ", p[c[i]]);
		} else if (b[c[i] - 1])
			for (int j = c[i] ; (j <= n && b[j] == 0) && (j == c[i] || p[j] > p[j - 1]) ; j++) printf("%d ", p[j]), b[j] = true;
		else if (b[c[i] + 1])
			for (int j = c[i] ; (j && b[j] == 0) && (j == c[i] || p[j] > p[j + 1]) ; j--) printf("%d ", p[j]), b[j] = true;
		else if (p[c[i] + 1] > p[c[i] - 1])
			for (int j = c[i] ; (j <= n && b[j] == 0) && (j == c[i] || p[j] > p[j - 1]) ; j++) printf("%d ", p[j]), b[j] = true;
		else for (int j = c[i] ; (j && b[j] == 0) && (j == c[i] || p[j] > p[j + 1]) ; j--) printf("%d ", p[j]), b[j] = true;
	}
	return 0;
}
```

---

## 作者：Dark_Blue_Sky (赞：2)

# P11396 排队

## 简要题意

将给出数据分成若干个组，每个组内进行一次排序，组与组之间再进行一次排序，使得字典序最大。

## 分析

由于输入数据为 $1 \thicksim n$ 的排列，则组与组之间的排序仅需比较最快到达的时间。又由于输入数据为 $1 \thicksim n$ 的排列，所以可枚举 $1 \thicksim n$ 中的一部分作为每个组的开头（不必全选）。

然后，确认了组的开头后，仅需枚举相邻的数，作为这个组的其他元素。

为了确保字典序最大，那么尽可能大的数就要被尽可能小的数选上，换句话来说，就是使尽可能小的数选上尽可能大的数。

由于一个数在输入数据中旁边有两个数，所以每次选数仅需选出两数之间最大的数。

现在，我们假设选定了组的开头为 $\mathtt{1}$，假设 $\mathtt{1}$ 后面连续两个数为 $a$ 与 $b$，且 $(a<b)$，那么与选了 $a$ 与 $b$ 组成的序列为 $1,a,b$，选了 $b$ 组成的序列为 $1,b$，显然，$1,a,b$ 比 $1,b$ 的字典序要小，所以我们可以得出每次选出的数必须保证比这个组末尾，也就是这个组最大的数要大。

根据以上方法，即可写出此题，时间复杂度 $O(n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000005],x[10000005];//x[i] 表示值为i的坐标
bool v[10000005];
int n;
void solve(int y){
	cout<<y<<" ";//输出组的开头
	int maxx=y;
	int l=x[y]-1,r=x[y]+1;//左右待选的数的位置
	v[y]=1;
	while(l>=1||r<=n){
		int nowmax=-1,op=-1;
		if(a[l]>nowmax&&l>=1&&v[a[l]]==0)nowmax=a[l],op=0;//假设左边为选定的数
		if(a[r]>nowmax&&r<=n&&v[a[r]]==0)nowmax=a[r],op=1;//假设右边为选定的数
		if(op==0)l--;//选定左边的数
		else r++;//选定右边的数
		if(nowmax<=maxx)break;//必须使选定的数选定的数大于组内最大数
		maxx=max(maxx,nowmax);//更新组内最大数
		v[nowmax]=1;//不能对一个数重复使用
		cout<<nowmax<<" ";//输出组内元素
	}
}
int main(){
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i],x[a[i]]=i;
	for(int i=1;i<=n;i++){
		if(v[i]==true)//不能将使用过的数作为组的开头
			continue;
		solve(i);//建立以i开头的组
	}
	return 0;
}
```
特别鸣谢由 @[tyh0929](https://www.luogu.com.cn/user/705729) 提供的部分底层思路。

---

## 作者：MnZnOIer (赞：1)

### 考场历程
1. 只考虑 $1$ 为开头，最大的字典序，剩下的从小到大排序；

2. 上面的显然错了，错在：剩下的也可能字典尽量大。所以按照从小到大考虑每一个没有标记的数，找到该数的位置，去左右找到字典序最大的上升序列。为什么要是上升的？因为如果有下降，就会把这个数排到前面，减小字典序。把每个已经算过的标记一下，依次输出即可；

3. 修改细节，A 掉了；

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[500005], id, b[500005], c[500005], m, k, d[500005];
bool vis[500005];
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> n;
	if (n == 1)return cout << 1, 0;
	for (int i = 1; i <= n; ++ i)cin >> a[i];
	for (int i = 1; i <= n; ++ i)d[a[i]] = i;//统计位置。
	for (int j = 1; j <= n; ++ j)
	{
		if (vis[j])continue;
		m = k = 1;//初始化。
		b[1] = c[1] = j;
		id = d[j];
		int jj = id - 1;//往左边找。
		while (jj)
		{
			if (a[jj] < a[jj + 1] || vis[a[jj]])break;//下降或统计过。
			b[++ m] = a[jj];
			-- jj;
		}
		b[m + 1] = 0;//下一个清空一下。
		jj = id + 1;//同上。
		while (jj <= n)
		{
			if (a[jj] < a[jj - 1] || vis[a[jj]])break;
			c[++ k] = a[jj];
			++ jj;
		}
		c[k + 1] = 0;
		bool f = c[2] > b[2];//因为是排列，不用考虑相等。
		for (int i = 1; i <= (f ? k : m); ++ i)cout << (f ? c[i] : b[i]) << ' ', vis[(f ? c[i] : b[i])] = 1;
        //输出并标记。
	}
	return 0;
}
```

---

## 作者：corner_xiejunqi (赞：1)

### 题目大意:
将 $n$ 只小猫分组，每组的到达时间为这组小猫到达时间的最小值，先将这些组按组的到达时间排序，再按每组中每只小猫的到达时间排序，求出字典序最大的排序。
### 解题思路:
因为需要按每组的到达时间排序，每组的到达时间又为这组小猫到达时间的最小值，所以最先输出的小组必定为整个数据中包含最小值的小组。可以将还没到达的小猫中的最小值以及其所在位置求出，因为需要最大字典序，所以在前面输出的小猫到达时间尽可能的大。

这时候就需要考虑如何将到达时间大的小猫先到达，那就必定是跟在到达时间最小的小猫后面。

那么如何使到达时间最小的小猫后面跟的小猫尽可能的大？只用判断这只小猫左右两边那个大就选哪个。因为就算离这只小猫远的小猫到达时间再大，每组中也需要排序，也只能在这只小猫左右两边之后。但如果离这只小猫远的小猫到达时间比左右两边的小猫短，那么就满足不了最大字典序了。

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11396)
## 思路
先选取当前未选取的喵喵中 $p_i$ 最小的，然后向两边拓展。

由于要求字典序最大，所以只要下一个被拓展到的喵喵的 $p_i$ 大于已被拓展喵喵中最大的 $p_i$，就可以拉它入队。

不能拓展时，就将这组的喵喵排好序，加入到 $q_i$ 中就行了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,r,t[300010],a[300010],n,mid,mn;
bool f[300010];
int ans[300010],cnt;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		t[a[i]]=i;
	}
	f[0]=f[n+1]=true;
	mid=1;
	while(mid<=n) {
		while(f[t[mid]]) {//被选了
			mid++;
			if(mid>n)break;//选完了
		}
		if(mid>n)break;//选完了
		l=r=t[mid];
		f[l]=true;
		if(f[l-1]&&f[r+1]) {//两边都不能拓展
			ans[++cnt]=a[l];
		} else if(f[l-1]) {//仅右边可拓展
			mn=a[r];//存最大值，下同
			while(a[r+1]>=mn&&!f[r+1]) {
				r++;
				f[r]=true;
				mn=a[r];
			}
			sort(a+l,a+r+1);
			for(int i=l; i<=r; i++)ans[++cnt]=a[i];
		} else if(f[r+1]) {//仅左边可拓展
			mn=a[l];
			while(a[l-1]>=mn&&!f[l-1]) {
				l--;
				f[l]=true;
				mn=a[l];
			}
			sort(a+l,a+r+1);
			for(int i=l; i<=r; i++)ans[++cnt]=a[i];
		} else {//两边都可以
			if(a[l-1]>a[r+1]) {
				l--;
				mn=a[l];
				f[l]=true;
			} else {
				r++;
				mn=a[r];
				f[r]=true;
			}
			while(a[r+1]>=mn&&!f[r+1]) {
				r++;
				f[r]=true;
				mn=a[r];
			}
			while(a[l-1]>=mn&&!f[l-1]) {
				l--;
				f[l]=true;
				mn=a[l];
			}
			sort(a+l,a+r+1);
			for(int i=l; i<=r; i++)ans[++cnt]=a[i];
		}
	}
	for(int i=1;i<=n;i++)cout<<ans[i]<<" "; 
}
```

---


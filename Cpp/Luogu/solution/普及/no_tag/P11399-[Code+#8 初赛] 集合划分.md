# [Code+#8 初赛] 集合划分

## 题目背景

搬运自 [Code+ #8 初赛](https://gitlink.org.cn/thusaa/codeplus8pre)。

## 题目描述

小 B、小 Y 和小 Z 是形影不离的好朋友，同时也是坚定的 xx 主义者。

这天，他们得到了 $n$ 块蛋糕，第 $i$ 块重量是 $a_i$。 蛋糕不能切开，只能整块地分给某一个人；蛋糕更不能浪费，即每块蛋糕都应归于三个人中的一个。

他们都具有大公无私的奉献精神，因此毫不在意自己分到的蛋糕重量比其他人小；但本着“主义高于友谊”的原则，他们必须保证任何两个人分到的蛋糕重量之和都严格大于第三个人，否则分到重量最小的两个人就会联合起来把旧世界打个落花流水。

由于生产力过度发达，蛋糕的数量和重量都已经远远超出他们的人脑计算能力，于是他们前来请教掌握计算机技术的你，希望你能为他们给出一组合理的分配方案，或确定该方案不存在。

## 说明/提示

**本题采用子任务评测。你必须通过一个子任务内的全部测试点，才能获得对应的分数。**

对于全部数据，$3\le n\le 2\times 10^5,\ 1\le a_i\le 10^9$。

子任务 $1$（$10$ 分）：保证 $n=3$。

子任务 $2$（$16$ 分）：保证 $n\le 16$。

子任务 $3$（$16$ 分）：保证 $n\le 10^3,a_i\le n$。

子任务 $4$（$28$ 分）：保证存在合法解。

子任务 $5$（$30$ 分）：无特殊限制。

## 样例 #1

### 输入

```
6
7 5 4 1 2 8```

### 输出

```
ZYBZYB```

## 样例 #2

### 输入

```
5
1 2 6 1 1```

### 输出

```
Internationale!```

# 题解

## 作者：xxseven (赞：6)

首先做一步转化：最大值小于另外两个值的和，等价于最大值小于总和的一半。

直接给出结论：按蛋糕重量从大到小考虑，分配给当前持有蛋糕重量最小的人，如果有解那么必定能构造出合法解。

证明：

以下记三个人的当前持有重量分别为 $a_1,a_2,a_3$ 且 $a_1 \le a_2 \le a_3 \lt \frac{sum}{2}$，蛋糕总重为 $sum$，当前考虑的蛋糕重量为 $x$。

要想使得当前情况下无解，必须有 $x+a_1 \ge \frac{sum}{2}$。因为前面任何一块蛋糕都不比 $x$ 轻，因此有 $x \le a_1 \le a_2 \le a_3$。

那么可以得到 $x+a_1+a_2+a_3 \ge sum$，当且仅当不等号左边四个数相等时取等，且取等时必有 $n=4$ 且所有蛋糕重量相等，这种情况显然无解。

因此当有解时取等条件不成立，不可能有 $x+a_1+a_2+a_3 \gt sum$，所以 $x+a_1 \ge \frac{sum}{2}$ 必然不成立，所以总能构造出合法的解。

[提交记录](https://www.luogu.com.cn/record/195045595)。

---

## 作者：suzhikz (赞：3)

首先，我们设每个人呢最后分配完蛋糕的重量和分别为 $a,b,c$，且给开始的序列排序，钦定开始会给 $c$ 分配一个最大值，无解情况显然是最大值超过了总和的一半，若有解则直接贪心给最小的 $a,b,c$ 分配一个。

为什么是对的呢？显然若有解，则 $a,b,c$ 之间的差值不可能比序列中的最大值大，且 $a,b,c$ 都大于等于该最大值，所以一定有解。特殊情况是有四个相同的值直接特判即可。

[code](https://www.luogu.com.cn/record/195050098)

---

## 作者：liyunhe (赞：2)

### 主体思路与证明

首先根据题意，任意两人之差不得大于等于第三人，可以将蛋糕尽量的平均。我们可以采取先将蛋糕从小到大排序，再将每块蛋糕加给目前最少的。

设总重为 $sum$。最大蛋糕的重量为 $a_{max}$。最小蛋糕的重量为 $a_{min}$。三人目前的重量为 $sum_1$，$sum_2$，$sum_3$。

#### 有解

如果有解，$a_{max}$ 一定小于 $\frac{sum}{2}$。在这个解法中，分完最大的蛋糕后，会一直给另外两人加蛋糕，直到其中一人超过最大的蛋糕。由于先加的是大蛋糕，所以超过最大蛋糕的人与最大蛋糕的差，一定小于另一人，是一组合理的分配方案。若超不过，则最小两人之和为 $sum-a_{max}$ 大于 $a_{max}$。

然后，对于一组分配过程中不严格的分配方案，令当前情况为 $sum_1\ge sum_2\ge sum_3$，给 $sum_3$ 分一块蛋糕 $x$，$x\le sum_2$，又因为 $sum_3\le sum_1$，所以 $sum_3+x\le sum_1+sum_2$。所以增加后 $sum_3$ 变为最大的情况符合要求。若没有则还是 $sum_1$ 最大，原来就符合要求，现在最多的没变，另外两人中增加了，最多的一定还小于另外两人。仍为一组不严格合理的分配方案。

最后，因为是有解的情况，所以分完后一定为严格合理的分配方案。

否则：

$$
\begin{align}
&\text{令} sum_1\ge sum_2\ge sum_3 \\ 

&\therefore sum_1=sum_2+sum_3=\frac{sum}{2}。\\

&\therefore \exist 1\le i\le n \text{，使得} sum_1\le sum_2\le sum_3 \text{且} sum_1+a_i=\frac{sum}{2}\\

&\text{又} \because 1\le a_i\le sum_2\le sum_3\\

&\therefore sum_1+sum_2+sum_3+a_i\ge sum\\

&\therefore sum_1=sum_2=sum_3=a_i=\frac{sum}{4} \text{且} a_i=a_{min}。\\

&\therefore n=4 \text{且} a_1=a_2=a_3=a_4
\end{align}
$$

此时无解。

#### 无解

如果没有解，分完后或重量最小的两个人小于等于最大的人，最后进行特判。

注意：$n\times a_i\le 10^9\times2\times10^5$ 会爆 `int` 记得开 `long long`。

```cpp
#include <bits/stdc++.h>
#define int long long//要开long long
using namespace std;
char ans[10000005];
pair<int,int>a[10000005];//数对存储值和序号
signed main(){
	int n,S=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].first;
		a[i].second=i;
		S+=a[i].first;
	}
	sort(a+1,a+n+1);//直接默认从小到大排序
	int sum[4]={0,0,0,0};
	for(int i=n;i>=1;i--){//反序遍历
		int u=a[i].first;
		int id=a[i].second;
		if(sum[1]<=sum[2]&&sum[1]<=sum[3]){
			sum[1]+=u;
			ans[id]='B';
		}else if(sum[2]<=sum[3]){
			sum[2]+=u;
			ans[id]='Y';
		}else{
			sum[3]+=u;
			ans[id]='Z';
		}
	}
	if(sum[1]*2>=S||sum[2]*2>=S||sum[3]*2>=S)cout<<"Internationale!";//无解特判
	else for(int i=1;i<=n;i++)cout<<ans[i];
	return 0;
}
```

---

## 作者：kuaiCreator (赞：2)

## 题目大意
三个人分 $n$ 块蛋糕，每块蛋糕都要分出去。要求最后最多的人的蛋糕数必须小于其他两个人的总和。
## 解题思路
把蛋糕按照从大到小的顺序分给拥有蛋糕最少的人，如果当前最少的人获得蛋糕的量大于等于总和的一半，则说明无解。否则继续分。

**注意**：这里总数的一半用浮点类型，否则会错误两个测试点，原因是总数为奇数。

考虑分配过程中，三人分配的总数为 $A$，$B$ 和 $C$。同时统计所有蛋糕的总数为 $S$。则可以有 $A\le B\le C\le \Large\frac{S}{2}$，因为一旦最多的人分配大于等于总数的一半，则另外两人的和必然会小于等于总数的一半。

由于对蛋糕按从大到小排序，如果正在分配的蛋糕分配给最小的人后重量超过总数的一半时，选择不分配给最小的人导致结果更大。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<ll,int>
using namespace std;
const int N = 2e5 + 5;
char ch[N];
ll n, t, p[5], s;
priority_queue<pii> q;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> t;
		s += t;
		q.push(make_pair(t, i));
	}
	while (q.size()) {
		int wi = q.top().first;
		int id = q.top().second;
		q.pop();
		ll j, mi = 1e18;
		for (int i = 1; i <= 3; i++)
			if (mi > p[i]) {
				mi = p[i];
				j = i;
			}
		p[j] += wi;
		if (p[j] >= s / 2.0) {
			cout << "Internationale!";
			return 0;
		}
		if (j == 1) ch[id] = 'B';
		else if (j == 2) ch[id] = 'Y';
		else ch[id] = 'Z';
	}
	for (int i = 1; i <= n; i++)
		cout << ch[i];
	return 0;
}
```

---

## 作者：hertzhz (赞：1)

# 思路：贪心

策略：将现有最重的蛋糕分给那个蛋糕总重量最小的人，如果一个人蛋糕总重量大于或等于所有蛋糕总重量，那么无解。

因为我们每次都将最重的蛋糕分给了蛋糕总重量最少的那个人，所以可以保证这是每个人蛋糕总重量最接近的方案（即最优方案）策略没有错误，可用代码实现。

因为每次要将最重的蛋糕取出，所以我们不难想到用优先队列（大根堆）实现。

由于题目说有多种方案时输出一种即可，所以笔者的代码的输出是合法的。

再来一发 AC 代码，码风可能很奇怪。


```cpp
#include <bits/stdc++.h>
using namespace std;
long long cnt[10000010],n,x,b,y,z,temp,check;//check是判断有没有解的 
double all;//总重量 
priority_queue <int> p_q;//大根堆 
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>x;
		all+=x;
		p_q.push(x);
	}
	for (int i=1;i<=n;i++)
	{
		temp=p_q.top();
		p_q.pop();
		if (b<=y&&b<=z)
		{
			b+=temp;
			cnt[i]=1;
		}
		else if (y<=b&&y<=z)
		{
			y+=temp;
			cnt[i]=2;
		}
		else if (z<=y&&z<=b)
		{
			z+=temp;
			cnt[i]=3;
		}
		if ((b>=all*1.0/2)||(y>=all*1.0/2)||(z>=all*1.0/2))//判断无解 
		{
			check=1;
			break;
		}
	}
	if (check==1)//若无解，输出，提前结束 
	{
		cout<<"Internationale!";
		return 0;
	}
	for (int i=1;i<=n;i++)//若有解，输出 
	{
		if (cnt[i]==1)
		{
			cout<<"B";
		}
		if (cnt[i]==2)
		{
			cout<<"Y";
		}
		if (cnt[i]==3)
		{
			cout<<"Z";
		}
	}
	return 0;
}
```

---

## 作者：Tongtong_D (赞：1)

# 题解   集合划分
这道题我的方法是贪心。

具体做法：先给输入进来的数组排序（从大到小），遍历每个蛋糕，把这块蛋糕给当前总重量最少的人。利用优先队列存储计算过程中每个人获得的总重量，因为这样的时间复杂度低一些（或者其实用三个变量也行，因为只有三个人）。

根据上面的描述，我们可以得到以下代码。

## AC CODE

```cpp
#include<bits/stdc++.h>
//#define ll long long
#define u unsigned
#define MAX 1000010
using namespace std;
struct ST{
	ll a;//这题不开longlong是不会AC的
	char b;
	bool operator > (const ST& tmp) const{//重载大于号，优先队列不会直接比较结构体
		return a>tmp.a;
	}
};
struct ST1{
	ll a;
	ll bh;
};
ST1 a[MAX];//不可以直接用int 因为排序以后ans数组是无序的
priority_queue<ST,vector<ST>,greater<ST> > q;
char p[5]={'Z','B','Y'};
char ans[MAX];//记录答案(但不是最终的)
char b[MAX];//最终答案
bool cmp(ST1 q,ST1 w ){
	return q.a>w.a;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].a;
		a[i].bh=i;//绑定原来的顺序
	}
	sort(a+1,a+1+n,cmp);//排序
	ST o;//提前录入前三个蛋糕
	o.a=a[1].a;
	o.b='B';
	q.push(o);
	o.a=a[2].a;
	o.b='Y';
	q.push(o);
	o.a=a[3].a;
	o.b='Z';
	q.push(o);
	ans[1]='B';
	ans[2]='Y';
	ans[3]='Z';
	int l=3;
	for(int i=4;i<=n;i++){
		o.a=q.top().a+a[i].a;//提前处理出来要push进去的值
		o.b=q.top().b;
		ans[++l]=o.b;
		q.pop();//去掉最小值
		q.push(o);//并录入刚才pop掉的最小值+当前蛋糕重量
	}
	ll x=q.top().a;
	q.pop();
	ll y=q.top().a;
	q.pop();
	ll z=q.top().a;
	q.pop();
	if((x+y>z)&&(x+z>y)&&(y+z>x)){//判断任意两个人的和是否都大于第三人
		for(int i=1;i<=n;i++){
			b[a[i].bh]=ans[i];//还原顺序
		}
		for(int i=1;i<=n;i++){
			cout<<b[i];//输出
		}
	}else{
		cout<<"Internationale!";//输出
	}
	return 0;//快乐地结束
}
```
代码较长请耐心阅读。

~~此题解已有防抄袭功能，直接提交会有惊喜。~~

---

## 作者：dinglinxi0409 (赞：1)

解：设三个人分别分到 $x$ 个，$y$ 个，$z$ 个蛋糕 $$(x\le y\le z)$$，则当满足要求时有
$$
x+y>z
$$
那么就有
$$
x+y+z>2z
$$
设总共有 $a$ 个蛋糕。根据题意，有
$$
a=x+y+z
$$
所以
$$
2z<a
$$
也就是
$$
z<\displaystyle\frac{a}{2}
$$
也就是说，当存在满足条件的方案时，分的最多的那个人的蛋糕数必须小于总数的一半。

为满足题目要求，$x$，$y$，$z$ 必须尽可能的接近。所以，应该从大到小分蛋糕。

下面给出证明：

设三人在分第 $i$ 块蛋糕之前已经分到了 $x$，$y$，$z$ 块蛋糕 $$(x \le y \le z)$$，分第 $i$ 块蛋糕之后已经分到了 $X$，$Y$，$Z$ 块蛋糕，第 $i$ 块蛋糕的大小等于 $a_i$。

在设 $W=z-x$，$W'=Z-X$，$P=W'-W$。

如果把它分给第一个人，就有

$$X=x+a_i$$
$$Y=y$$
$$Z=z$$
此时有 $P_1=W'-W=(Z-X)-(z-x)=Z-X-z+x=z-x-a_i-z+x=-a_i$

如果把它分给第二个人，就有

$$X=x$$
$$Y=y+a_i$$
$$Z=z$$
此时有 $P_2=W'-W=(Z-X)-(z-x)=Z-X-z+x=z-x-z+x=0$

如果把它分给第三个人，就有

$$X=x$$
$$Y=y$$
$$Z=z+a_i$$
此时有 $P_3=W'-W=(Z-X)-(z-x)=Z-X-z+x=z+a_i-x-z+x=a_i$

因为
$$a_i\ge 0$$
所以就有
$$P_1\le P_2\le P_3$$
而
$$x\le y\le z$$
所以，命题得证。

代码如下：
```
#include <bits/stdc++.h>
using namespace std;
long long cake[5];
char name[5]={' ','B','Y','Z',' '};
struct every_cake{int di,id;}a[200002];
bool cmp(every_cake up,every_cake down) {return ((up.di>=down.di)&&(up.di-down.di));}
int judge() //判断哪个人的蛋糕最少
{
    extern long long x,y,z;
    x=cake[1];
    y=cake[2];
    z=cake[3];
    if (x<=y&&x<=z) return 1;
    if (y<=x&&y<=z) return 2;
    if (z<=x&&z<=y) return 3;
    return 0;
}
int main()
{
    int n,i,b;
    string c=" ";
    cin>>n;
    for (i=1;i<=n;i++) {cin>>a[i].di; a[i].id=i; c=c+" ";}
    sort(a+1,a+n+1,cmp);
    for (i=1;i<=n;i++)
    {
        b=judge(); //判断分到蛋糕最少的那个人
        cake[b]=cake[b]+a[i].di; //给蛋糕最少的人累加分到的蛋糕
        c[a[i].id]=name[b]; //记录答案
    }
    c.erase(((judge()))&0,1);
    {
        extern long long x,y,z;
        if (x>=y+z||y>=x+z||z>=x+y) cout<<"Internationale!"; //非法方案输出无解信息
        else cout<<c;
    }
    cout<<endl;
    return 0;
}
long long x,y,z;
```cpp

---

## 作者：RAY091016 (赞：1)

### 1. 题目解释

给出 $n$ 个物品各自的权值，要求将其分为三份且任意两份之和大于第三份。

### 2. 思路

贪心。

不难想到，我们将物品按照权值从大到小排序，给当前分到物品权值最小的人分剩余的权值最大的一个物品。

如果有合法解，那么这种方法构造出的序列一定是可行的。

证明如下：

记当前三个人拥有的权值分别为 $w_1$，$w_2$，$w_3$，当前考虑的物品权值为 $w_0$，总权值为 $sum$。

如果当前情况合法，则有 $w_1,w_2,w_3<\dfrac{sum}{2}$。

不妨设 $w_1\le w_2\le w_3$，因为 $w_0$ 比之前考虑的任意一个物品权值都严格不增，所以有 $w_0\le w_1\le w_2\le w_3<\dfrac{sum}{2}$。

如果以此贪心策略分，则 $w_1$ 会赋为 $w_1+w_0$。

若此时不合法，则有 $w_1+w_0\ge\dfrac{sum}{2}$，因而有 $w_1>\dfrac{sum}{2}-w_0$。

所以有 $w_0+w_1+w_2+w_3\ge2(w_0+w_1)\ge sum$，当且仅当 $n=4$ 且所有物品权值相等时取到。

易知这种情况不会有合法解。

又 $w_0+w_1+w_2+w_3\le sum$，因而产生矛盾，故原假设
$w_1+w_0\ge\dfrac{sum}{2}$ 不成立，即构造出的总是合法解。

最后判断一下方案是否合法即可。

### 3. 代码实现

（楼下怎么都是堆啊，来一发结构体加 sort 的代码。）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,y,z,sum;
char f[200200];
struct data{
	int v,num;
}a[200200];
bool cmp(data x,data y){
	return x.v>y.v;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].v;
		a[i].num=i;
		sum+=a[i].v;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		int minn=min(x,min(y,z));
		if(minn==x){
			x+=a[i].v;
			f[a[i].num]='B';
		}
		else if(minn==y){
			y+=a[i].v;
			f[a[i].num]='Y';
		}
		else{
			z+=a[i].v;
			f[a[i].num]='Z';
		}
	}
	if(!(x+y>z&&x+z>y&&y+z>x)){
		cout<<"Internationale!";
	}
	else{
		for(int i=1;i<=n;i++){
			cout<<f[i];
		}
	}
	return 0;
}

```

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11399)

## 思路：

**如何寻找正解（贪心）：**
策略是每次都将剩下的最大的蛋糕分给目前蛋糕重量最少的那个人。

**如何判断无解：** 将剩下的最大的蛋糕分给目前蛋糕重量最少的那个人后那个人的蛋糕重量大于或等于蛋糕总重量时，无解。即：

设三人在某一时刻分别拥有 $S_1,S_2,S_3$ 的蛋糕，所有蛋糕的总重量为 $D$，如果在任意一个时刻，有 $min(S_1,S_2,S_3) \ge \frac{D}{2}$ 成立，则无解。

### 一个细节：

在处理总蛋糕重时要用浮点数储存，防止出现蛋糕总重量为奇数的情况。

## 完整代码:


```cpp
#include <bits/stdc++.h>
using namespace std;
int x;
double s=0;
int a;
int da[10000005];
priority_queue< int > qs;//大根堆
bool flag(int q1){
	if(q1>=s*1.0/2) return true;
	else return false;
}//判断无解
int main(){
	cin>>x;
	for(int i=1;i<=x;i++){
		cin>>a;
		s+=a;
		qs.push(a);
	} 
	int s1=0,s2=0,s3=0,ff=0;
	for(int i=1;i<=x;i++){
		int u=qs.top();
		qs.pop();
		if(s1<=s2&&s1<=s3){
			s1+=u;
			da[i]=1;
		}
		else if(s2<=s1&&s2<=s3){
			s2+=u;
			da[i]=2;
		}
		else if(s3<=s1&&s3<=s2){
			s3+=u;
			da[i]=3;
		}
		if(flag(s1)==true||flag(s2)==true||flag(s3)==true){
			ff=1;
			break;
		}
	}
	if(ff==1) cout<<"Internationale!";//无解
	else{
		for(int i=1;i<=x;i++){
			if(da[i]==1) cout<<"B";
			if(da[i]==2) cout<<"Y";
			if(da[i]==3) cout<<"Z";
		}
	}
	return 0;
}
```

---

## 作者：PengDave (赞：1)

# Solution
这道题目不太好想，因此，我们需要转换。设三个人分得的蛋糕重量分别为 $x,y,z$，当满足要求时，$x+y>z$，也就是说 $x+y+z>2z$，即 $z<\frac{x+y+z}{2}$，同理得 $y<\frac{x+y+z}{2},x<\frac{x+y+z}{2}$。接下来就好做了，我们用贪心的思想，将蛋糕从大到小排序，再用三个变量分别记录三人获得的蛋糕重量，每次将蛋糕分给目前分得蛋糕最少的人，如果这样仍会导致超过总量一半，那么就意味着没有合格的方案。
# Code
```cpp
#include<iostream>
#include<utility>
#include<algorithm>
#include<iomanip>
using namespace std;
typedef long long ll;
pair<ll,int> a[200010];
int ans[200010];
ll b[5];
char t[5]={'B','Y','Z'};

int main(){
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	long long p=0;
	for(int i=1;i<=n;i++){
		cin>>a[i].first;
		a[i].second=i;
		p+=a[i].first;
	}
	p=(p+1)/2;
	sort(a+1,a+n+1,greater<pair<ll,int> >());
	for(int i=1;i<=n;i++){
		int pos=min_element(b+1,b+4)-b;
		ans[a[i].second]=pos;
		b[pos]+=a[i].first;
		if(b[pos]>=p){
			cout<<"Internationale!"<<endl;
			return 0;
		}
	}
	for(int i=1;i<=n;i++){
		cout<<t[ans[i]-1];
	}
	cout<<flush;
	return 0;
}
```

---

## 作者：YangTL (赞：0)

# 题解：P11399 [Code+#8 初赛] 集合划分

## 大意
这题大意就是三个人取蛋糕，但是题目要保证任何两个人分到的蛋糕重量之和都严格大于第三个人，不然就有打架的风险。  

## 思路
分类讨论。
#### 先看不满足的情况

不妨设小 B、小 Y 和小 Z 分别拥有重量为 $b,y,z$ 的蛋糕，一共有重量为 $s$ 蛋糕。    
那么就有
$$\left\{\begin{matrix}
   y+z>b
 \\b+y>z
 \\b+z>y
\end{matrix}\right.$$
转化得：
$$\left\{\begin{matrix}
   b<\frac{s}{2}
 \\y<\frac{s}{2}
 \\z<\frac{s}{2}
\end{matrix}\right.$$
只要不满足上面的条件，最后输出 ``Internationale!`` 即可。

#### 求 $b,y,z$ 的值
贪心。  
题目要求任何两个人分到的蛋糕重量之和都严格大于第三个人，策略就是让三个人分到的蛋糕重量差最小。  
那怎么保证最小呢？  
先将蛋糕按重量从大到小排序，然后每次将这块扔给那个目前质量最小的，于是差就不会超过所有蛋糕里面最大的。
这样代码就写完了。

## 代码
[记录](https://www.luogu.com.cn/record/231066167)  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long//10年OI一场空，不开longlong见祖宗
ll n;//数量
ll b,y,z;//当前3人中每人拥有蛋糕重量
struct dg{//蛋糕结构体
    ll w;//重量
    ll id;//id编号
    char c;//判断是谁的蛋糕
}a[200005];
bool cmp1(dg x,dg y){//结构体排序
    return x.w>y.w;//按重量从大到小
}
bool cmp2(dg x,dg y){//结构体排序
    return x.id<y.id;//按id从小到大
}
int main(){
    cin>>n;//输入
    for(ll i=1;i<=n;i++){
        cin>>a[i].w;//输入重量
        a[i].id=i;//保存id
    }
    sort(a+1,a+n+1,cmp1);//排序，按重量从大到小
    for(ll i=1;i<=n;i++){//贪心
        if(b<=y&&b<=z){//小B的蛋糕总重量最少
            b+=a[i].w;//这块蛋糕给小B
            a[i].c='B';//标记一下是小B的蛋糕
            continue;
        }
        if(y<=b&&y<=z){//小Y的蛋糕总重量最少
            y+=a[i].w;//这块蛋糕给小Y
            a[i].c='Y';//标记一下是小Y的蛋糕
            continue;
        }
        if(z<=y&&z<=b){//小Z的蛋糕总重量最少
            z+=a[i].w;//这块蛋糕给小Z
            a[i].c='Z';//标记一下是小Z的蛋糕
            continue;
        }
    }
    sort(a+1,a+n+1,cmp2);//按id从小到大排序，因为输出要用
    if(b+y<=z||b+z<=y||y+z<=b){//判断该方案是否存在
        //进了if说明是最佳方案还不满足
        cout<<"Internationale!";
    }else{
        //满足了，就输出
        for(ll i=1;i<=n;i++){
            cout<<a[i].c;
        }
    }
    return 0;//撒花
}
```

---

## 作者：queenbee (赞：0)

# P11399 [Code+#8 初赛] 集合划分 题解

## 思路
[题目传送门](https://www.luogu.com.cn/problem/P11399)，保证任何两个人分到的蛋糕重量之和都严格大于第三个人，只要保证三人分到的蛋糕重量相对平均即可，因为一个人与另两个人蛋糕重量差距越大，这个人与另两人的和差距就越大，当三人蛋糕重量相对平均时，三人蛋糕重量的差距是最小的，如果此时依然不满足条件，则方案不存在。

分配时每次将当前蛋糕给蛋糕重量最少的人是最优策略，否则分给另外两人的任何一人都会使这个人与最小者差距更大。分配需要蛋糕从大到小分配，从小的开始分可能会使原本最优策略是几个小蛋糕分给一个人的平分给几个人。所以先对蛋糕重量进行降序排序再分配蛋糕。

## 程序
```cpp
#include<bits/stdc++.h> //我爱万能头
using namespace std;
#define int long long   //注意开long long  
const int N=2e5+10;
int n;
struct Node{
    int w;
    int id;
}a[N];
char ch[]={'B','Y','Z'};
int ans[N];
int x,y,z;
int add(int w){ //找蛋糕重量最少的人
    if(x<=y&&x<=z){
        x+=w;
        return 0; 
    }
    else if(y<=x&&y<=z){
        y+=w;
        return 1;
    }
    else{
        z+=w;
        return 2;
    }
}
bool cmp(Node a,Node b){
    return a.w>b.w;
}
bool check(){   //判断是否成立
    if(x+y>z&&x+z>y&&y+z>x){
        return true;
    }
    return false;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].w;
        a[i].id=i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        ans[a[i].id]=add(a[i].w);
    }
    if(check()){
        for(int i=1;i<=n;i++){ 
            cout<<ch[ans[i]];
        }
    }
    else{
        puts("Internationale!");
    }
    return 0;   //完结撒花
}
```

---

## 作者：lvweisi (赞：0)

这是一道简单的贪心题，只要对每一个蛋糕的重量进行排序，在遍历时把获得最小的人加上当前重量，特判完了就有了最终答案。

# 蒟蒻的代码:
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct shu{
	long long a;
	int wz;
}s[200005];
char ans[200005];
bool cmp(const shu &t1,const shu &t2){
	return t1.a>t2.a;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i].a;
		s[i].wz=i;
	}
	sort(s+1,s+1+n,cmp);//从大到小排序
	long long A,B,C;
	A=B=C=0;
	for(int i=1;i<=n;i++){
		int wz=s[i].wz;
		if(A<=B&&A<=C){
			A+=s[i].a;
			ans[wz]='Z';
		}
		else{
			if(B<=A&&B<=C){
				B+=s[i].a;
				ans[wz]='Y';
			}
			else{
				C+=s[i].a;
				ans[wz]='B';
			}
		}
	}
	if(max(max(B,C),A)*2>=(A+B+C)*1.0){
		cout<<"Internationale!";//特判
		return 0;
	}
	for(int i=1;i<=n;i++)cout<<ans[i];
	return 0;
}
```

注意，记得开 $long long$ ！！！

---


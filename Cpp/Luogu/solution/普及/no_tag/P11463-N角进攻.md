# N角进攻

## 题目背景

t1e 在篮球课上学习了三角进攻的传球战术，他由此联想到了 $n$ 角进攻，并产生了一些疑问。

## 题目描述

$n$ 角进攻由排成一排的 $n$ 个人发起，初始时球员从左到右依次标号为 $1,2,\cdots, n$，且篮球初始在队伍正中间的 $\frac{n + 1}{2}$ 号球员手中（保证 $n$ 为奇数）。

- 第 $1$ 次传球，正中间的球员可以选择一个方向（左或右），将篮球传递到该方向上距离他最近的球员手中，传球后，正中间的球员从队列中移出，并重新在队列的最左边或最右边插入（与传球方向保持一致）。

- 对于之后的传球，当前处在队列正中间的球员必须选择与上次传递相反的方向，传球后依然是正中间的球员从队列中移出，并重新在队列的最左边或最右边插入（与传球方向保持一致）。

例如，以下是 $n = 3$，初始时中间球员向左边传球，经过 $3$ 次传球后的情况：

```
第 0 次传球后 : 1 2 3 （接下来 2 号球员向左传球）
第 1 次传球后 : 2 1 3 （接下来 1 号球员向右传球）
第 2 次传球后 : 2 3 1 （接下来 3 号球员向左传球）
第 3 次传球后 : 3 2 1 
```

现在 t1e 想知道有 $n$ 名球员，初始时正中间球员向方向 $x$ 传球（$x = 0$ 代表左，$x = 1$ 代表右），经过 $k$ 次传球之后的局面。




## 说明/提示

$1 \le T \le 200$，$3 \le n,\sum n \le 2\times 10^5$，$x \in \{0, 1\}$，$0\le k \le 10^{18}$，保证 $n$ 是奇数。

## 样例 #1

### 输入

```
3
3 0 3
5 1 2
5 1 7```

### 输出

```
3 2 1
4 1 2 5 3
3 5 2 1 4```

## 样例 #2

### 输入

```
5
7 0 1
7 0 2
7 0 3
7 0 4
7 0 5```

### 输出

```
4 1 2 3 5 6 7
4 1 2 5 6 7 3
5 4 1 2 6 7 3
5 4 1 6 7 3 2
6 5 4 1 7 3 2
```

# 题解

## 作者：Nahida_Official (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P11463)

通过描述和所给例子不难发现，当队列中有 $n$ 个队员时，无论开始状态是向左还是向右传，在经过 $n$ 次传球后，队列会进行反转。

举例如下：
```cpp
输入：
7
7 0 1
7 0 2
7 0 3
7 0 4
7 0 5
7 0 6
7 0 7
输出：
4 1 2 3 5 6 7 
4 1 2 5 6 7 3 
5 4 1 2 6 7 3 
5 4 1 6 7 3 2 
6 5 4 1 7 3 2 
6 5 4 7 3 2 1 
7 6 5 4 3 2 1

输入:
7
7 1 1
7 1 2
7 1 3
7 1 4
7 1 5
7 1 6
7 1 7
输出：
1 2 3 5 6 7 4 
5 1 2 3 6 7 4 
5 1 2 6 7 4 3 
6 5 1 2 7 4 3 
6 5 1 7 4 3 2 
7 6 5 1 4 3 2 
7 6 5 4 3 2 1 
```
所以在经过 $2 \times n$ 次传球后，队列就会回到初始状态。

由此可以想到将操作次数 $k \bmod 2 \times n$ 之后进行模拟。


## 思路 1：
建立一个数组模拟操作，每次操作之后对数组进行更新，但由于更新数组需要双层循环，在题目条件 $3 \le n \le 2\times 10^5$ 限制下会 TLE。
```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
using namespace std;
const int MANX=1e6;
ll T,n,x,k,mid;
int a[MANX];
void change(){
	if(x==0){
		int y=a[mid];
		a[0]=y;
		for(int i=mid-1;i>=0;i--){
			a[i+1]=a[i];
		}
		x=1;
	}else if(x==1){
		int z=a[mid];
		a[n+1]=z;
		for(int i=mid;i<=n+1;i++){
			a[i]=a[i+1];
		}
		x=0;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--){
		cin>>n>>x>>k;
		k%=2*n;
		for(int i=1;i<=n;i++){
			a[i]=i;
		}
		mid=(1+n)/2;
		for(int i=1;i<=k;i++){
			change();
		}
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" ";
		}
		cout<<'\n';
	}
	return 0;
}
```
 [Record](https://www.luogu.com.cn/record/195908255)

既然数组暴力不可取，那么转换思路。

## 思路 2：
开两个双端队列，分别记录中间队员的左边和右边，而中间队员新建一个变量 $mid$ 存储。

根据题目样例解释：
```cpp
第 0 次传球后 : 1 2 3 （接下来 2 号球员向左传球）
第 1 次传球后 : 2 1 3 （接下来 1 号球员向右传球）
第 2 次传球后 : 2 3 1 （接下来 3 号球员向左传球）
第 3 次传球后 : 3 2 1
```
不难发现，当中间队员向左传球时，将中间队员压入左边队列的头部，并且将中间队员 $mid$ 设置为左边队列的尾部并弹出；而向右方传球则将中间队员压入右边队列的尾部，并且将中间队员 $mid$ 设置为右边队列的头部并弹出。

对队列操作不需要额外循环，单层循环即可。

另外需要注意的点：

- 记得转移状态（更新 $x$）。

- 在读入数据的时候记得两个队列都要从尾部压入数据，否则会导致原队列乱序而得不出正确答案。

- 别忘记输出 $mid$。

- 记得开 long long。
## Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MANX=1e6;
ll T,n,x,k,num;
deque<ll> a,b;
ll mid;
void change(){
	if(x==0){
		a.push_front(mid);
		mid=a.back();
		a.pop_back();
		x=1;
	}
	else if(x==1){
		b.push_back(mid);
		mid=b.front();
		b.pop_front();
		x=0;
	}
}//模拟 
void print(){
	for(int i=1;i<=num;i++){
		cout<<a.front()<<" ";
		a.pop_front();
	}
	cout<<mid<<" ";
	for(int i=1;i<=num;i++){
		cout<<b.front()<<" ";
		b.pop_front();
	}
	cout<<"\n";
}
int main(){
	ios::sync_with_stdio(false);
	//freopen("2.in","r",stdin);
	//freopen("2.out","w",stdout);
	cin>>T;
	while(T--){
		cin>>n>>x>>k;
		k%=(2*n);//取模 
		num=(n+1)/2-1;//左右队列的长度 
		for(int i=1;i<=num;i++){
			a.push_back(i);
		}
		mid=(n+1)/2;
		for(int i=mid+1;i<=n;i++){
			b.push_back(i);
		}
		for(int i=1;i<=k;i++){
			change();
		}
		print();
	}
	return 0;
}

```
 [AC Record](https://www.luogu.com.cn/record/196103636)

---

## 作者：ClV_Csy (赞：3)

# P11463 N角进攻
## 题意
有 $n$ 个人进行了 $k$ 次调整位置（相当于题面中的传球），调整位置的初始方向为 $x$。$x = 0$ 表示向左，$x = 1$ 表示向右。对于每次调整位置，有以下规则：
- 若 $k = 1$，则向 $x$ 方向调整位置。
- 若 $k > 1$，则调整方向与上一次调整方向相反。

要求输出 $k$ 次调整位置后，每个人的位置。
## 思路
### 一、优化
观察题目数据范围，发现：
> $0 \le k \le 10^{18}$

如果纯模拟，一定会 TLE，考虑对 $k$ 进行优化。

按题意模拟，  
![logo](https://cdn.luogu.com.cn/upload/image_hosting/6gviw96q.png)  
容易发现，每经过 $2n$ 次调整位置，就会回到初始状态。
也就是说，我们可以对 $k$ 模 $2n$，这样即可大大减小 $k$，也就大大减小了模拟所需的循环次数。

-----
### 二、双端队列
经过优化，计算量大大减小，考虑纯模拟。  
那么，如何来模拟呢？

首先，我们要知道一些关于双端队列的知识：  
- 双端队列（deque）和普通队列类似，但是双端队列的两边都可以进出。
- 头文件：`deque`。
- 声明：`deque <int> q`。
- 头部入队：`q.push_front(元素)`。
- 头部出队：`q.pop_front()`。
- 尾部入队：`q.push_back(元素)`。
- 尾部出队：`q.pop_back()`。
- 获取头部元素：`q.front()`。
- 获取尾部元素：`q.back()`。
- 获取头部地址：`q.begin()`。
- 获取尾部地址：`q.end()`。

仿照 vector 容器的遍历，可以写出以下代码段用于 deque 容器的遍历：

```cpp
for (auto it = q.begin(); it != q.end(); it++) {
	cout << *it << " ";
}
```
注：如果编译器提示
> [Error] 'it' does not name a type

那么是由于你的 C++ 编译器版本过低（`auto` 所需的版本最低为 C++11），需要按照以下步骤调整编译器（此处方法默认为 Dev-C++）版本：
1. 找到窗口上方的“工具[T]”一栏并单击；
2. 找到其中的“编译选项[C]”并单击。
3. 在弹出的窗口中选择“编译器”选项卡。
4. 勾选“编译时加入以下命令”。
5. 在文本框内添加命令 `-std=c++14`，命令中的编译器版本可以自定，但不能低于 C++11。

-----
### 三、模拟
准备好了双端队列的基本知识，接下来就是模拟了。  

我们可以建立两个双端队列 `q1, q2`，其中 `q1` 用来存储中间点左边的数，`q2` 用来存储中间点右边的数。中间点所表示的数单独表示。  
对于每一次调整位置，采取按以下顺序进行的操作：  
- 当 $x = 0$ 时（即中间点成为新的最左边，原中间点的左边成为新的中间点），  
1. `q1` 头部（即最左边）将中间点入队；
2. 更新中间点为 `q1` 的尾部（即原中间点左边的数）；
3. `q1` 尾部（即原中间点左边的数）出队。
- 当 $x = 1$ 时（即中间点成为新的最右边，原中间点的右边成为新的中间点），
1. `q2` 尾部（即最右边）将中间点入队；
2. 更新中间点为 `q2` 的头部（即原中间点右边的数）；
3. `q2` 头部（即原中间点右边的数）出队。
- 每轮操作过后，还需要进行 $x \gets 1 - x$，相当于对 $x$ 取反。这样可以使下一轮操作的调整方向与本轮相反。

这样进行 $k$ 轮操作后，按 `q1`，中间点，`q2` 的顺序排列就是题目所求的状态。使用“二、双端队列”中介绍的遍历方法依次遍历 `q1` 和 `q2` 即可。
## 代码
**注意：**
1. $k$ 在取模之前需要使用 long long 类型存储。
2. 本题多测，每组数据操作前需要初始化 `q1`、`q2`。


```cpp
#include <iostream>
#include <deque>
using namespace std;
deque <int> q1, q2;
int main() {
	int T;
	long long n, k;
	bool x;
	cin >> T;
	while (T--) {
		cin >> n >> x >> k;
		int mid = (n + 1) / 2;
		int midnum = mid;
		k %= 2 * n;
		q1.clear();
		q2.clear();
		for (int i = 1; i < mid; i++) {
			q1.push_back(i);
		}
		for (int i = mid + 1; i <= n; i++) {
			q2.push_back(i);
		}
		for (int i = 1; i <= k; i++) {
			if (x == 0) {
				q1.push_front(midnum);
				midnum = q1.back();
				q1.pop_back();
			} else {
				q2.push_back(midnum);
				midnum = q2.front();
				q2.pop_front();
			}
			x = 1 - x;
		}
		for (auto it = q1.begin(); it != q1.end(); it++) {
			cout << *it << " ";
		}
		cout << midnum << " ";
		for (auto it = q2.begin(); it != q2.end(); it++) {
			cout << *it << " ";
		}
		cout << "\n";
	}
	return 0;
}
```

---

## 作者：liaoxingrui (赞：3)

## Content

有 $t$ 组数据，每组数据有 $n$ 个人在传篮球，篮球初始在第 $\frac{ n + 1 } { 2 }$ 人手上，然后反复执行 $k$ 次操作：

1. 第一次传球，你可以将球传给你左边的人或右边的人，然后来到最左边或最右边（与传球方向一致）。
2. 之后传球的方向与上一次传球的方向相反。

现在给定你第一次传球的方向，求 $k$ 次操作结束后的局面。

## Solution

显然在 $2 \times n$ 次操作后可已得到原序列。那我们就只用模拟 $k \bmod 2 \times n$ 次操作就可以了。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
int t,n,headl,taill,headr,tailr;
int l[N],r[N];
bool opt;
long long k;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>opt>>k;
		k%=(n<<1);
		int mid=n+1>>1;
		headl=1;
		taill=0;
		headr=1;
		tailr=0;
		for(int i=n/2;i>=1;i--){
			taill++;
			l[taill]=i;
		}
		for(int i=n/2+2;i<=n;i++){
			tailr++;
			r[tailr]=i;
		}
		while(k--){
			if(opt){
				tailr++;
				r[tailr]=mid;
				mid=r[headr];
				headr++;
			}
			else{
				taill++;
				l[taill]=mid;
				mid=l[headl];
				headl++;
			}
			opt^=true;
		}
		for(int i=taill;i>=headl;i--)
			cout<<l[i]<<" ";
		cout<<mid<<" "; 
		for(int i=headr;i<=tailr;i++)
			cout<<r[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：GONGX (赞：3)

### 题意简述
给定一个 $n$ 个人的队伍，求出队伍经 $k$ 次传球操作后的局面，其中每次传球操作由队伍中间的球员传球给传球方向上离自己最近的球员并自己转移到传球方向上的队伍最外侧，并且每次传球的方向与上一次相反。
### 解题思路
理解题意后，很容易想到我们可以将整个队伍分为左右两半处理，其中中间球员放在左半边或右半边都行，本人将其放在左半个队伍中。

对于每次传球操作，当传球方向为左时，将左半个队伍最右边的球员插入到左半个队伍最左边；当传球方向为右时，先将左半个队伍最右边的球员插入到右半个队伍最右边，然后将右半个队伍最左边的球员插入到左半个队伍最右边。这些操作可以用双端队列实现。

但是我们又发现 $k$ 的最大值高达 $10^{18}$，直接进行上述模拟操作显然不行。于是我们经过思考和模拟样例可以发现每进行 $n$ 次传球操作，整个队伍将会倒过来，而再进行 $n$ 次操作队伍便恢复原样了。所以每进行 $2n$ 次传球操作，队伍都会变回最初的样子。于是我们模拟时便可以将 $k$ 对 $2n$ 取模，每组测试数据的时间复杂度约为 $O(n + (k \bmod 2n))$。具体实现细节可参考代码注释。
### 温馨提示
- 题目中 $k$ 的取值范围较大，注意选用合适的数据类型存储。
- 当整型的读入量较大时可以选用快读输入，以减小读入耗时，本人使用的快读较为巧妙，具体细节参见代码注释。
- 注意多测要清空。
### 代码展示
```cpp
#include <bits/stdc++.h>
using namespace std;
struct FSI { //定义一个结构体 FSI，用于快速输入
    char ch; //定义一个字符变量 ch，用于存储当前读取的字符
    template<typename T> //定义一个模板函数，T 是任意类型
    FSI& operator >> (T &ret) { //重载输入运算符 >>，使其可以处理任意整型的输入
        ret = 0;//注意清空 ret 
		while (!isdigit(ch = getchar())); //循环读取字符，直到遇到数字字符为止
        //此时 ch 中存储的是第一个数字字符
        while (isdigit(ch)) //当 ch 是数字字符时，进入循环
            ret = ret * 10 + ch - '0', ch = getchar();
			//将当前数字字符转换为整数并累加到 ret 中，然后继续读取下一个字符
        //此时 ret 中存储的是完整的数字
        return *this; // 返回当前对象的引用，以便支持链式调用
    }
} fin; //声明一个 FSI 类型的对象 fin
int T, n;
long long k;// k <= 10^18, 注意开 long long 
bool x; //传球方向可用布尔类型存储 
deque<int> ql, qr;
//用双端队列 ql 存储队伍中 1 ~ (n + 1) / 2 的球员，qr 存储队伍右半边的球员 
int main() {
	fin >> T; //类似 cin 的读入格式 
	while (T--) { 
		fin >> n >> x >> k, k %= n * 2; //局面的每个循环节长度为 2n 
		int mid = (n + 1) / 2;
		for (int i = 1; i <= mid; i++) ql.push_front(i);
		for (int i = mid + 1; i <= n; i++) qr.push_front(i); 
		while (k--) {//模拟 n 次传球 
			if (x) {//向右传球 
				qr.push_front(ql.front()), ql.pop_front();
				//左半个队伍最右边的球员插入到右半个队伍最右边
				ql.push_front(qr.back()), qr.pop_back();
				//右半个队伍最左边的球员插入到左半个队伍最右边 
			} else//向左传球 
				ql.push_back(ql.front()), ql.pop_front();
				//左半个队伍最右边的球员插入到左半个队伍最左边 
			x ^= 1;//通过异或运算改变传球方向 
		}
		while (!ql.empty())//输出左半个队伍局面 
			printf("%d ", ql.back()), ql.pop_back();
		while (!qr.empty())//输出右半个队伍局面
			printf("%d ", qr.back()), qr.pop_back();
		//输出的同时也清空了两个双端队列 
		putchar('\n');//注意输出多测的换行 
	}
	return 0;
}
```

---

## 作者：dongzirui0817 (赞：3)

## 思路

首先通过打表可以发现，$n$ 角进攻以 $2n$ 为一周期循环的。

~~下面的有点抽象。~~ 以 $n = 7, \, x = 0$ 为例：

第一次传球后，队列为 `4 1 2 3 5 6 7`，其中的 $4$ 号（现在在第 $1$ 位）想要再回到中间，就要有 $3$ 个队员到它前面去。

但传一次球后，方向会相反，所以要再传 $3 \times 2 = 6$ 次球才能回到中间，此时队列为 `7 6 5 4 3 2 1`，正好相反。

也就是说，经过 $n$ 次传球，就能将队列翻转。

所以经过 $2n$ 次传球，队列会回到没有传球的样子。

于是传球 $k$ 次的队列，跟 $k \bmod (2n)$ 的队列是一样的。

## 代码实现

暴力做一次传球操作是 $O(n)$ 的，总时间复杂度 $O(Tn^2)$，轻松 TLE。

但对于传球操作是可以用链表的。

其他的链表元素都一样，但多添加元素 $mid$，用来记录中间元素编号，每次更新都是原来的 $mid$ 前面的元素或后面的元素。具体的：

- 当 $x = 0$ 时，$mid$ 指向前一个元素。
- 当 $x = 1$ 时，$mid$ 指向后一个元素。

这样就不用花 $O(n)$ 的时间找中间元素了。

具体细节请看代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int T;
int n, x;
long long k;
int c[200010];
int pr[200010], nx[200010];
int s, t, mid;

int main() {
	scanf("%d", &T);
	for ( ; T-- ; ) {
		scanf("%d%d%lld", &n, &x, &k);
		k %= (n << 1);
		for (int i = 1 ; i <= n ; i++) c[i] = i, pr[i] = i - 1, nx[i] = i + 1;
		s = 1, t = n, mid = (n + 1) / 2;
		for ( ; k-- ; ) {
			if (x) {
				int p = t, md = mid;
				mid = nx[md];
				t = md;
				nx[p] = md;
				nx[pr[md]] = nx[md];
				pr[nx[md]] = pr[md];
				pr[md] = p;
				nx[md] = n + 1;
			} else {
				int p = s, md = mid;
				mid = pr[md];
				s = md;
				pr[p] = md;
				pr[nx[md]] = pr[md];
				nx[pr[md]] = nx[md];
				pr[md] = 0;
				nx[md] = p;
			}
			x = 1 - x;
		}
		for (int i = s ; i <= n ; i = nx[i]) printf("%d ", i);
		puts("");
	}
	return 0;
}
```

---

## 作者：zhujiahao114514 (赞：2)

水题。

# 题意

有一种战术，中间的人向任意一边传球，然后自己再到最左或最右边（与传球方向相同）。问在 $k$ 次后变成了什么样。

# 思路
看一下数据范围，操作次数在长整类型范围内，肯定不能暴力做。那怎么办呢？

对了，我们可以找规律。

手玩一下样例：
~~~
第0次：1 2 3
第1次：2 1 3
第2次：2 3 1
第3次：3 2 1
第4次：3 1 2
第5次：1 3 2
第6次：1 2 3
~~~

由此可见，每移动 $2n$ 次，就会变成原来的样子。

所以，我们只要移动 $k$ $\bmod$ $2n$ 次，就可以得到和原来一样的效果。时间复杂度 $O(n)$。

接下来考虑怎么操作。可以使用队列进行操作。

# code
~~~
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+1;
int q[N];
queue<int> L,R;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		bool x;
		long long n,k;
		cin>>n>>x>>k;
		k%=(n*2);
		for(int i=(n+1)/2-1;i>=1;i--) L.push(i);
		for(int i=(n+1)/2+1;i<=n;i++) R.push(i);
		int mid=(n+1)/2;
		for(int i=1;i<=k;i++)
		{
			if(!x)
			{
				L.push(mid); 
				mid=L.front(); 
				L.pop();
				x=1;
			}
			else  
			{
				R.push(mid);   
				mid=R.front();
				R.pop();
				x=0;
			}
		}
		for(int i=L.size();i>=1;i--)
		{
			q[i]=L.front();
			L.pop();
		}
		q[(n+1)/2]=mid; 
		for(int i=(n+1)/2+1;i<=n;i++)
		{
			q[i]=R.front();
			R.pop();
		}
		for(int i=1;i<=n;i++) cout<<q[i]<<" ";
		cout<<"\n";
	}
	return 0;
}
~~~
请管理员大大给过。

---

## 作者：yi_hr (赞：2)

## 思路
### 1. 周期性
通过模拟小规模的 $n$ 和 $k$，可以发现传球操作具有周期性。即，对于每个奇数 $n$，传球的周期长度为 $2n$。这意味着每经过 $2n$ 次传球，队伍的排列会回到初始状态。  

因此，对于给定的 $k$，我们只需要模拟 $k\mod2n$ 次传球即可。  
### 2. 如何模拟
为了高效处理队列的中间元素插入和删除，可以使用两个双端队列 (`deque`) 来分别维护队列的左半部分和右半部分。  
#### 具体实现：
- **左半部分 (`l`)：** 包含队列的前半部分，包括中间元素。  
- **右半部分 (`r`)：** 包含队列的后半部分。  
#### 步骤：
1. **初始化**:
   - 将队伍从 1 到 $n$ 分成 `l` 和 `r` 两部分。  
   - `l` 包含前 $\frac{n+1}{2}$ 个元素。  
   - `r` 包含后 $\frac{n-1}{2}$ 个元素。  
2. **传球操作：**
   - **找到中间元素：** `l` 的最后一个元素。
   - **移除中间元素：** 从 `l` 中弹出最后一个元素。  
   - **插入：**
     - 如果传球方向是左 ( $x=0$ )，将中间元素插入 `l` 的前端。  
     - 如果传球方向是右 ( $x=1$ )，将中间元素插入 `r` 的后端。  
   - **平衡队列：**
     - 确保 `l` 和 `r` 的大小保持平衡，即 `l` 的大小为 $\frac{n+1}{2}$，`r` 的大小为 $\frac{n-1}{2}$。  
     - 如果 `l` 太大，从 `l` 的后端移动一个元素到 `r` 的前端。  
     - 如果 `l` 太小，从 `r` 的前端移动一个元素到 `l` 的后端。  
   - **切换方向：** 每次传球后，方向切换为相反方向。  
3. **重复传球：**
   - 根据 $k$ 的值，计算有效传球次数 $m=k\mod2n $。  
   - 进行 $m$ 次传球操作。  
4. **输出结果：**
   - 最终的队列顺序是 `l` 的元素依次排列，接着是 `r` 的元素。  
## 代码
### 记得开long long!
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int T;
    cin>>T;
    while(T--){
		ll n,x,k;
        cin>>n>>x>>k;
        deque<int> l,r;
        for(int i=1;i<=n;++i){
            if(i<=(n+1)/2){
                l.push_back(i);
            }else{
                r.push_back(i);
            }
        }
        ll m=(k%(2*n));
        int dir=x;
        for(ll i=0;i<m;++i){
            int mid=l.back();
            l.pop_back();
            if(dir==0){
                l.push_front(mid);
            }
            else{
                r.push_back(mid);
            }
            if(l.size()>(n+1)/2){
                int t=l.back();
                l.pop_back();
                r.push_front(t);
            }
            else if(l.size()<(n+1)/2){
                int t=r.front();
                r.pop_front();
                l.push_back(t);
            }
            dir=1-dir;
        }
        for(auto num:l){
            cout<<num<<" ";
        }
        for(auto num:r){
            cout<<num<<" ";
        }
        cout<<"\n";
    }
    return 0;
}
```

---

## 作者：TN_lougu (赞：2)

[题目](https://www.luogu.com.cn/problem/P11463)
# 思路
首先，先看数据，$0 \le k \le 10^{18}$，肯定不能用暴力，那能不能优化一下呢？\
推一下样例，推如下（ $n = 3 $ , $ x = 0$ ）：
```
第0次：1 2 3
第1次：2 1 3
第2次：2 3 1
第3次：3 2 1
第4次：3 1 2
第5次：1 3 2
第6次：1 2 3
......
```
（当 $x = 1$ 时，同理）\
找一下规律，发现每 $n \times 2$ 次，这个队列都有一次循环，那么就可以优化：$k \bmod( n \times 2 )$。接下来就可以模拟了。
# 代码
首先输入输出很简单。\
其次就是要初始化，把整个队列赋上值。\
然后交换就行了，可以用 queue 交换，代码如下：
```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+1;
int que[N];
queue<int >L,R;     //将整个队列分成两段，L 表示左边，R 表示右边，这样交换时的时间复杂度可以变成 O(n) 。 
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		bool x;
		long long n,k;
		cin>>n>>x>>k;
		k%=n*2;     //优化 k。
		for(int i=(n+1)/2-1;i>=1;i--) L.push(i);
		for(int i=(n+1)/2+1;i<=n;i++) R.push(i);
		int mid=(n+1)/2;
		for(int i=1;i<=k;i++)
		{
			if(!x)     //向左。
			{
				L.push(mid);     //存入 L （放在最左边）。 
				mid=L.front();     //mid 变成了它左边的那个。 
				L.pop();
				x=1;
			}
			else     //向右。 
			{
				R.push(mid);     //同理。 
				mid=R.front();
				R.pop();
				x=0;
			}
		}
		for(int i=L.size();i>=1;i--)     //将队列 L 和 R 存入数组 que 里，再输出。 
		{
			que[i]=L.front();
			L.pop();
		}
		que[(n+1)/2]=mid;     //别忘了中间的 mid。 
		for(int i=(n+1)/2+1;i<=n;i++)
		{
			que[i]=R.front();
			R.pop();
		}
		for(int i=1;i<=n;i++) cout<<que[i]<<" ";
		cout<<"\n";
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/196019529)

---

## 作者：mishitaotuoyyds (赞：2)

# 题目分析：
首先我们观察样例一中第三个并打出过程，如下。
```cpp
1 2 3 4 5
1 2 4 5 3
4 1 2 5 3
4 1 5 3 2
5 4 1 3 2
5 4 3 2 1
3 5 4 2 1
3 5 2 1 4
```
通过我们打出的过程可以发现每 $n$ 次传球会反转一次，然后我们做出假设，每 $2n$ 次传球一循环，为了证明我们再想一组数据，假如是 $n$ 为 $3$，$x$ 为 $1$，$k$ 为 $7$。
其过程如下。
```cpp
1 2 3
1 3 2
3 1 2
3 2 1
2 3 1
2 1 3
1 2 3
1 3 2
```
可以发现每 $2n$ 一循环，所以我们只需要将 $k\bmod 2n$，然后创建两个队列，然后通过队列它先进先出，后进后出的性质进行模拟，左边弹出右边进，右边弹出左边进，模拟传球就好了。
### 参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long t,n,x,k,ll[2000200],rr[200200];
queue <long long >q,h;
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n>>x>>k;
		for(int y=1;y<=q.size();y++)q.pop();
		for(int y=1;y<=h.size();y++)h.pop();
		if(x==0){
			long long wz=(n/2);
			for(int y=wz;y>=1;y--)q.push(y);
			for(int y=wz+1;y<=n;y++)h.push(y);
		}
		else{
			long long wz=(n/2)+1;
			for(int y=wz;y>=1;y--)q.push(y);
			for(int y=wz+1;y<=n;y++)h.push(y);
		}
		k=k%(2*n);
		for(int y=1;y<=k;y++){
			if(x==1){
				long long sss;
				sss=q.front();
				q.pop();
				h.push(sss);
				x=0;
			}
			else{
				long long sss;
				sss=h.front();
				h.pop();
				q.push(sss);
				x=1;
			}
		}
		long long w=q.size(),e=h.size();
		for(int y=1;y<=w;y++){
			ll[y]=q.front();
			q.pop();
		}
		for(int y=1;y<=e;y++){
			rr[y]=h.front();
			h.pop();
		}
		for(int y=w;y>=1;y--)cout<<ll[y]<<" ";
		for(int y=1;y<=e;y++)cout<<rr[y]<<" ";
		cout<<" \n";
	}
	
    return 0;
} 
```
完结撒花。

---

## 作者：luoguzbh0011 (赞：1)

# 思路：链表 
蒟蒻的第一篇题解，求通过。
## 题目大意：  
有 $n$ 个人，排成一列，进行 $k$ 次操作，每次将中间的人移到左边或右边，并改变下一次操作的方向。
## 思路：
阅读题面，我们不难想到用数组模拟。  
但是数组的删除操作太费时，会 TLE。  
**数组删除操作太耗时，我们就用删除操作时间复杂度为 $O(1)$ 的链表。**  
[不知道链表的戳这里。](https://www.runoob.com/cplusplus/cpp-libs-list.html)  
还有一个问题：$k$ 太大也会超时。  
打表不难发现，每进行 $ 2n$ 次，链表恢复初始值。  
所以，我们完全可以用 $k \bmod 2n$ 代替 $k$。   
### 代码：

```
#include<bits/stdc++.h>
using namespace std;
list<int>q;//链表
int main() {
	int T;
	cin>>T;
	while(T--) {
		long long n,x,k;//不开long long见祖宗
		cin>>n>>x>>k;
		k%=n*2;//一定要有
		for(int i=1; i<=n; i++)q.push_back(i);//初始化
		for(int i=1; i<=k; i++) {
			if(x==0) {
				auto it = q.begin();//迭代器
				advance(it, n/2);
				q.push_front(*it);
				q.erase(it); //删除
			}
			if(x==1) {
				auto it = q.begin();
				advance(it, n/2);
				q.push_back(*it);
				q.erase(it);
			}
			x=1-x;
		}
		for (const auto& elem : q) {  //遍历输出
			std::cout << elem << " ";
		}
		cout<<"\n";
		q.clear();
	}
	return 0;
}
```
**这时，我们会发现一个严重的问题：TLE。**  
分析一下代码，我们发现：迭代器的移动时间复杂度为  $O(n)$。   
怎么办呢？干脆就不让它移动了。  
我们可以建两个链表，一个模拟左边，一个模拟右边，一个装 $n \div 2$ 个数，一个装 $n \div 2 + 1$ 个数。  
每次操作，拿出操作方向反方向的链表最靠近中间的数（左链表的尾，右链表的头）进行操作。操作后操作方向的比另一个多一个数。  
### AC代码：  

```
#include<bits/stdc++.h>
using namespace std;
list<int>q1;//左链表和右链表
list<int>q2;
int main() {
	int T;
	cin>>T;
	while(T--) {
		long long n,x,k;
		cin>>n>>x>>k;
		k%=n*2;
		int mid=(n+1)/2;
		if(x==1) {//初始化分两种情况
			for(int i=1; i<=mid; i++) q1.push_back(i);
			for(int i=mid+1; i<=n; i++) q2.push_back(i);
		} else {
			for(int i=1; i<mid; i++) q1.push_back(i);
			for(int i=mid; i<=n; i++) q2.push_back(i);
		}

		for(int i=1; i<=k; i++) {
			if(x==0) {//操作
				q1.push_front(q2.front());
				q2.pop_front();
			}
			if(x==1) {
				q2.push_back(q1.back());
				q1.pop_back();
			}
			x=1-x;//改操作方向
		}
		for (const auto& elem : q1) {//遍历输出
			cout << elem << " ";
		}
		for (const auto& elem : q2) {
			cout << elem << " ";
		}
		cout<<"\n";
		q1.clear();//多测记得清空
		q2.clear();
	}

	return 0;
}
```

---

## 作者：__CJY__ (赞：1)

感谢[这篇题解](/article/sijxbl6w)给了我思路。
## 题意简述
$n$ 个人排成一排，中间的人开始传球，每次传向最近的人并移到队伍一端，求 $k$ 次传球后的队列顺序。
## 思路
我们计算初始时篮球所在的球员编号 $mid=\frac{n+1}{2}$，使用两个双端队列（`deque`）$q1$ 和 $q2$ 分别表示中间球员左边的球员和右边的球员，将初始排列中除中间球员外的球员分别放入 $q1$ 和 $q2$ 中。

由于传球过程具有周期性，传球 $2n$ 次后球员排列会回到初始状态（因为每个球员都会回到原来的位置）。因此，可以将 $k \bmod 2n$，以减少不必要的计算。

我们根据初始传球方向 $x$，模拟 $k$ 次传球过程：
* 如果 $x=0$（向左传球），将当前中间球员插入到 $q1$ 的前端，并从 $q1$ 的后端移除一个球员作为新的中间球员。
* 如果 $x=1$（向右传球），将当前中间球员插入到 $q2$ 的后端，并从 $q2$ 的前端移除一个球员作为新的中间球员。
* 每次传球后，切换传球方向 $x=1−x$。

传球模拟结束后，将 $q1$、当前中间球员、$q2$ 中的球员按顺序输出，即得到经过 $k$ 次传球后的球员排列。

---

## 作者：snowQAQ (赞：1)

一道模拟题。

### 思路
我们可以将序列分为 $1 \sim \lfloor n \div2 \rfloor$、$\lfloor n\div2 \rfloor +1$ 和 $\lfloor n\div2 \rfloor +2\sim n$ 三个部分。第一个部分和第三个部分使用队列模拟，模拟靠近中间 $n\div2$ 的部分，然后按奇偶分组。奇数就对第一个队列操作，偶数就对第二个队列操作。得到的队头就是新的中间项。但 $m=0$ 和 $m=1$ 操作是不同的。所以我们可以分组求解。
```c++
//now为中间数，q1为第一个队列，q2为第二个队列
queue<int>q1,q2;
for(int i=(int)n/2;i>=1;i--){   //建立两个队列
		q1.push(i);
	}	
	for(int i=(int)n/2+2;i<=n;i++){
		q2.push(i);
	}
	int now=(int)n/2+1;
	if(m==0){                 //按照m分组讨论
		for(int i=1;i<=k;i++){
			if(i%2==1){           //按照奇偶分类
				q1.push(now);
				now=q1.front();
				q1.pop();
			}
			else{
				q2.push(now);
				now=q2.front();
				q2.pop();
			}
		}
	}
	else{
		for(int i=1;i<=k;i++){
			if(i%2==0){
				q1.push(now);
				now=q1.front();
				q1.pop();
			}
			else{
				q2.push(now);
				now=q2.front();
				q2.pop();
			}
		}	
	}
```
但是 $0 \le k \le 10^{18}$，要是枚举 $k$ 指定会 $\text{TLE}$。

我们先来看看 $n=3$ 的情况。

![](https://s3.bmp.ovh/imgs/2024/12/26/0941f3b50c6c4c49.png)


经过简单的模拟我们可以发现无论 $m=0$ 还是 $m=1$ 都有一个周期为 $2 \times n$ 的环。

为了减少时间复杂度，我们可以将 $k \bmod (2 \times n)$。

还又要注意的一点。

由于 $q1$ 维护的是靠近队头的元素，所以输出 $q1$ 元素时需要倒序输出。

### AC代码如下

```c++
#include<iostream>
#include<queue>
using namespace std;
#define int long long
int a[200005];
void solve()
{
	int n,m,k;
	queue<int>q1,q2;
	cin>>n>>m>>k;
	k%=n*2;
	for(int i=(int)n/2;i>=1;i--)
	{
		q1.push(i);
	}	
	for(int i=(int)n/2+2;i<=n;i++)
	{
		q2.push(i);
	}

	int now=(int)n/2+1;
	if(m==0)
	{
		for(int i=1;i<=k;i++)
		{
			if(i%2==1)
			{
				q1.push(now);
				now=q1.front();
				q1.pop();
			}
			else
			{
				q2.push(now);
				now=q2.front();
				q2.pop();
			}
		}
	}
	else
	{
		for(int i=1;i<=k;i++)
		{
			if(i%2==0)
			{
				q1.push(now);
				now=q1.front();
				q1.pop();
			}
			else
			{
				q2.push(now);
				now=q2.front();
				q2.pop();
			}
		}	
	}
	for(int i=(int)n/2;i>=1;i--)
	{
	    a[i]=q1.front();
	    q1.pop();
	}
	a[(int)n/2+1]=now;
	for(int i=(int)(n/2)+2;i<=n;i++)
	{
		 a[i]=q2.front();   
	    q2.pop();
	    
	}
	for(int i=1;i<=n;i++)
	{
		cout<<a[i]<<' ';
	}
	cout<<'\n';
	
	
}
signed main()
{
	int T;
	cin>>T;
	while(T--)
	{
		solve();
	}
}

---

## 作者：GETexas (赞：1)

## 主要思路
### 概述
先模拟一遍，摸清规律，输出的数组具有周期性，于是可以将思考范围缩小至一个周期。观察易得到输出的数组应该由五部分组成（两个倒序的子串、两个正序的子串、中点）。于是确定起始点，终止点输出。
### 过程分析
不妨令 $n$ 为 $5$，$x$ 为 $2$ 先演算一遍。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ihlp00q5.png)  
由图可以发现，$n=5$ 时输出数组具有周期性，周期 $T=10$。  
在一个周期内，可以分成 $1\sim5,6\sim10$ 前后两个部分，后半部分是前半部分的倒序。  
最重要的是在将范围缩小至一个周期的前半部分可以发现数组由5个部分组成，已在图中写出。  
接下来就是确定这五个部分的前后界。  
需要一个布尔变量 $isback$ 判断所求的数组是在一个循环前面还是后面。  
同时将 $k$ 映射至 $1\sim n$。  
分析中点的位置：  
如果 $x=1$，则中点位于右边。  
如果 $x=0$，则中点位于左边。  
不妨设中点为 $mid$，中点左边需要倒序的个数为 $lm$，中点右边需要倒序的个数为 $rm$。  
$lm,rm$ 的大小需要分类讨论。  
由 $mid,lm,rm$ 这三个变量可以轻松确定区间起始点。  
那么对于一个周期的后半部分，可以通过反转区间起点终点，反转增减顺序倒序输出。
## 代码解释

```cpp
#include<iostream>
using namespace std;
long long t,n,x,k,lm,rm,mid,i;//别忘了开long long
bool isback;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>x>>k;
		isback=((k-1)/n)%2;//判断在循环的前后，确定是否反转
		k%=n;
		mid=n/2+1;
		if(!k) k=n;
		lm=rm=(k-1)/2;
		if((k-1)%2)
		{
			if(x)rm++;
			else lm++;
      //确定反转区间的长度
		}
		if(isback){//需要反转
			for(i=mid-lm;i<=mid-1;i++) cout<<i<<' ';
			if(x) cout<<mid<<' ';
			for(i=n;i>mid+rm;i--) cout<<i<<' ';
			for(i=mid-lm-1;i>=1;i--) cout<<i<<' ';
			if(!x) cout<<mid<<' ';
			for(i=mid+1;i<=mid+rm;i++) cout<<i<<' ';
		}
		else{
			for(i=mid+rm;i>mid;i--) cout<<i<<' ';//中点右，倒序
			if(!x) cout<<mid<<' ';//中点只有一个
			for(i=1;i<mid-lm;i++) cout<<i<<' ';//中点左，不变
			for(i=mid+rm+1;i<=n;i++) cout<<i<<' ';//中点右，不变
			if(x) cout<<mid<<' ';
			for(i=mid-1;i>=mid-lm;i--) cout<<i<<' ';//中点左，倒序
		}
		cout<<'\n';
	}
    return 0;
}

```
第一次发题解，排版不熟悉，辛苦管理大大了。  
谢谢观看。

---

## 作者：DeepSleep_Zzz (赞：1)

**begin**

[P11463 题目传送门。](https://www.luogu.com.cn/problem/P11463)

# 分析
记住一句话：
>看题先看数据范围。 ——LeavingAC

一看，$0\le k \le 10^{18}$，直接模拟不 TLE 才怪。

但是不必担心，通过仔细观察，我们就可以发现——其实样例输入 2 给了我们莫大的提示。

简单模拟可得：

输入：`7 0 0`，输出：`1 2 3 4 5 6 7`。

输入：`7 0 7`，输出：`7 6 5 4 3 2 1`。

所以我们不难看出：

$n$ 次传球后，队列镜像翻转。

那么必有 $2n$ 次传球后，队列恢复原样。

所以我们考虑将 $k\bmod2n$。

如果你看懂了，那么恭喜你，水掉了一道黄题（剩下的纯模拟）。

如果你没看懂，试着理解一下代码吧！

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll t,n,k;
bool x;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>t;
    while (t--)
    {
        deque<ll> l,r;
        cin>>n>>x>>k;
        ll mid=(n+1)>>1;
        k%=n*2; // 缩小数据范围
        for (ll i=1;i<mid;i++)
        {
            l.push_back(i);
            r.push_back(mid+i);
        }
        while (k--)
        {
            if (x)
            {
                r.push_back(mid);
                mid=r.front();
                r.pop_front();
            }
            else
            {
                l.push_front(mid); // 注意这里别放反了
                mid=l.back();
                l.pop_back();
            }
            x=!x; // 题目中的原话
        }
        while (!l.empty())
        {
            cout<<l.front()<<" ";
            l.pop_front();
        }
        cout<<mid<<" "; // 记得输出 mid
        while (!r.empty())
        {
            cout<<r.front()<<" ";
            r.pop_front();
        }
        cout<<"\n";
    }
    return 0;
}
```

**end**

---

## 作者：Drifty (赞：1)

### Solution

我不会分讨，因此这题严格难于 H。

有一个显然的观察就是操作的周期就是 $2n$。然后再观察，发现当 $\lfloor \frac{k}{n}\rfloor$ 为奇数的情况整个序列反一下就是 $\lfloor \frac{k}{n}\rfloor$ 为偶数的情况。然后经过若干次操作，序列一定会是两边逆序，中间正序，即我们会把中间的数逆序地放到两边，然后就是多一个少一个的问题了，这个分讨处理。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int T, n, x;
long long k;
void solve() {
    cin >> n >> x >> k;
    vector <int> ans(n + 1), vis(n + 1);
    if ((k % n) & 1) {
        int f = (n + 1) / 2 + (k % n) / 2, g = 1;
        for (int i = 1; i <= (k % n) / 2 + (x ^ 1); i ++) vis[f] = 1, ans[i] = f --;
        for (int i = n - (k % n) / 2 + (x ^ 1); i <= n; i ++) vis[f] = 1, ans[i] = f --;
        for (int i = (k % n) / 2 + (x ^ 1) + 1; i < n - (k % n) / 2 + (x ^ 1); i ++) {
            while (vis[g]) g ++; 
            ans[i] = g ++;
        }
    }
    else {
        int f = n / 2 + (k % n) / 2 + x, g = 1;
        for (int i = 1; i <= (k % n) / 2; i ++) vis[f] = 1, ans[i] = f --;
        for (int i = n - (k % n) / 2 + 1; i <= n; i ++) vis[f] = 1, ans[i] = f --;
        for (int i = (k % n) / 2 + 1; i <= n - (k % n) / 2; i ++) {
            while (vis[g]) g ++; 
            ans[i] = g ++;
        }
    }
    if ((k / n) % 2) reverse(ans.begin() + 1, ans.end());
    for (int i = 1; i <= n; i ++) cout << ans[i] << ' ';
    cout << '\n';
}
int main() {
    cin.tie(NULL) -> sync_with_stdio(false);
    for (cin >> T; T --; ) solve();
    return 0;
}
```

---

## 作者：TLE_Automat (赞：1)

**这里是官方题解。**

可以将序列分为三个部分，左边 $\lfloor \frac{n}{2} \rfloor$ 个，右边 $\lfloor \frac{n}{2} \rfloor$ 个，最中间的 $1$ 个。

容易观察到，进行恰好 $n$ 次传球后，左边的部分会完全翻转到右边，而右边的部分也会完全翻转到左边，而最中间的元素不变，相当于对原序列进行了 $\operatorname{reverse}$ 操作，所以进行 $2n$ 次传球后序列会变为跟初始时一样，所以我们可以将先 $k$ 对 $2n$ 取模。

之后在 $\Theta(n)$ 的时间复杂度内暴力模拟题目中的传球操作即可通过。

模拟的方式有很多，这里提供一种模拟方式：

首先开两个数组或者两个双端队列，再开一个变量记录最中间的值，分别模拟左边的部分和右边的部分。

- 如果当前操作为向左传球，则将中间元素插入到左边的队首，新的中间元素设置为左边的队尾并将其弹出。
- 如果当前操作为向右传球，则将中间元素插入到右边的队尾，新的中间元素设置为右边的队首并将其弹出。

---

## 作者：Malkin_Moonlight (赞：1)

## Knowledge

简单找规律题目。考察找规律、模拟。

## Solution

序列有为三个部分，左边 $ \left\lfloor\frac{n}{2}\right\rfloor $ 个，右边 $ \left\lfloor\frac{n}{2}\right\rfloor $ 个，最中间的 $1$ 个。

我们先拿 $n = 3$ 来找找规律。原始序列为 $1,2,3$。

这里分为两种情况讨论。

第一种：向左传球。

|操作次数|此时的序列|
|:-:|:-:|
|$1$|$2,1,3$|
|$2$|$2,3,1$|
|$3$|$3,2,1$|
|$4$|$3,1,2$|
|$5$|$1,3,2$|
|$6$|$1,2,3$|

可以发现，第 $3$ 次操作后序列中间部分不变，左边部分与右边部分调转，也就是说把整个序列倒过来了。还有，第 $6$ 次操作后，序列又变回原样了。

第二种：向右传球。

|操作次数|此时的序列|
|:-:|:-:|
|$1$|$1,3,2$|
|$2$|$3,1,2$|
|$3$|$3,2,1$|
|$4$|$2,3,1$|
|$5$|$2,1,3$|
|$6$|$1,2,3$|

发现向右传球规律也跟向左传球一样。

接下来，发现 $3$ 次操作是 $n$，且 $6$ 次操作是 $2n$。

再尝试几种，比如 $n = 4$，发现规律完全相同，在此不再列举。所以我们可以将先 $k$ 对 $2n$ 取模，再在  $\Theta(n)$  的时间复杂度内暴力模拟题目中的左右传球操作，最后用刚才 $k$ 取模之后的值对应出相应的序列即可。

---

## 作者：末然Ender (赞：1)

# 题解：P11463 N角进攻

## 思路

我们注意到一次传球其实就是把最中间的那个数移到了左或者右边的某一个端点上，然后中间的数重复以上操作（这应该很容易注意到吧）。

先想一想，不去看数据范围，我们应该如何去实现以上这个操作？我们需要一个线性的东西来维护这些数，可以随时取用中间的那个数字，并且放到这个东西的两端。嗯，听上去很像双端队列对吧？事实上我们正可以用两个对顶的双端队列来维护这么一个东西，先将 $1$ 到 $\frac{n-1}2$ 的数字放进左边的双端队列 $l$，将 $\frac{n+1}2+1$ 到 $n$ 的数字放入右端的队列 $r$，然后根据第一次向哪个方向传球来决定 $\frac{n+1}2$ 放入哪边的队列。然后执行 $k$ 次：如果 $l$ 比较大将 $l$ 的末尾放入 $r$ 的末尾，弹出 $l$ 的末尾；否则说明 $r$ 比较大，将 $r$ 的开头放入 $l$ 的开头，弹出 $r$ 的开头。最后我们将 $l$ 和 $r$ 从头到尾弹出输出即可。

嗯，以上的时间复杂度是 $O(k)$ 的，非常慢，所以我们考虑找规律，我们观察第二组样例其实很容易发现：数列执行 $n$ 次操作会变成原来的倒序，所以执行 $2\cdot n$ 次操作就会不变，所以我们大可以将 $k$ 对 $2\cdot n$ 取模，结果是不变的，这下复杂度就正确了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
//#define getchar getchar_unlocked
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
const int N=1200;
ll n,x,k;
void solve(){
	read(n,x,k);
	k%=(n<<1);
	deque<ll>l,r;
	for(int i=1;i<=(n>>1);i++){
		l.push_back(i);
	}
	for(int i=(n+1>>1)+1;i<=n;i++){
		r.push_back(i);
	}
	if(x)l.push_back(n+1>>1);
	else r.push_front(n+1>>1);
	while(k--){
		if(l.size()>r.size())r.push_back(l.back()),l.pop_back();
		else l.push_front(r.front()),r.pop_front();
	}
	while(!l.empty()){
		write(l.front());
		l.pop_front();
		putchar(' ');
	}
	while(!r.empty()){
		write(r.front());
		r.pop_front();
		putchar(' ');
	}
	putchar('\n');
}
int main(){
	ll t;
	read(t); 
	while(t--){
		solve();
	}
	return 0;
}
```

---

## 作者：fire_star_ (赞：0)

暴力模拟。

序列分为三个部分，左边 $ \left\lfloor\frac{n}{2}\right\rfloor $ 个，右边 $ \left\lfloor\frac{n}{2}\right\rfloor $ 个，最中间的 $1$ 个。

通过找规律可发现：当传球次数为 $2n$ 时，队列会恢复到最初的样子。

所以我们要使用双端队列维护左边和右边，使用变量 $mid$ 维护队列中间，然后判断 $x$ 是否是 $0$ 或 $1$ 即可。遍历序列后输出 $mid$ 即可。

---

## 作者：MorningStarCzy (赞：0)

## 前言
[题目传送门](https://www.luogu.com.cn/problem/P11463)

一道（自认为）适合我们这种蒟蒻练手的找规律以及模拟题。

## 思路
在看完题面后，我们发现这是一道可以直接根据题意模拟的题。看向样例，可以自己在草稿本上手模一遍。

~~（当然，你还会发现这道题似乎和这个球没有太大关系，它只是决定了人的插入位置）~~

于是我们在不看数据范围的情况下自信地写下了——

### Code1
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
deque<int>Q1,Q2;
//Q1用于1~中间，Q2用于中间~n
void Solve()
{
	int n,x,k;cin>>n>>x>>k;
	int mid=(n+1)/2;
	for(int i=1;i<=mid;i++) Q1.push_back(i);
	for(int i=mid;i<=n;i++) Q2.push_back(i);
	for(int i=1;i<=k;i++)
	{
		int nowmid=Q1.back();
		Q1.pop_back();
		Q2.pop_front();
		if(x==0)
		{
			Q1.push_front(nowmid);
			Q2.push_front(Q1.back());
		}
		else
		{
			Q2.push_back(nowmid);
			Q1.push_back(Q2.front());
		}//手模可得变换方式。
		x=!x;//翻转x
	}
	for(int i=1;i<=mid;i++) cout<<Q1.front()<<" ",Q1.pop_front();
	Q2.pop_front();
	for(int i=1;i<mid;i++) cout<<Q2.front()<<" ",Q2.pop_front();
	cout<<endl;//输出
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--) Solve();
	return 0;
}
```
**TLE,0pts**

于是我们看向数据范围……
> $0 \le k \le 10^{18}$。

啊这，直接按题意模拟，复杂度绝对爆炸，怪不得会 TLE。

怎么办呢？**找规律！**

像这种题目，$k$ 如此巨大，一定需要找规律。

我们观察样例，再多手模几组和样例有关的数据，即可得到：

### Input
```
2
7 0 0
7 0 7
```

### Process
```
(1)
1 2 3 4 5 6 7
(2)
1 2 3 4 5 6 7
4 1 2 3 5 6 7
4 1 2 5 6 7 3
5 4 1 2 6 7 3
5 4 1 6 7 3 2
6 5 4 1 7 3 2
6 5 4 7 3 2 1
7 6 5 4 3 2 1
```

### Output
```
1 2 3 4 5 6 7
7 6 5 4 3 2 1
```

不难发现，每经过 $n$ 次变换，原序列即翻转。同理，在经过 $2n$ 次变换后，原序列复原。

于是我们只要模拟 $k \bmod 2n$ 次传球即可，大大减少了所需的时间。

我们可以轻松地得到——
### Code2
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
deque<int>Q1,Q2;
void Solve()
{
	int n,x,k;cin>>n>>x>>k;
	int mid=(n+1)/2;
	for(int i=1;i<=mid;i++) Q1.push_back(i);
	for(int i=mid;i<=n;i++) Q2.push_back(i);
	for(int i=1;i<=k%(n*2);i++)
	{
		int nowmid=Q1.back();
		Q1.pop_back();
		Q2.pop_front();
		if(x==0)
		{
			Q1.push_front(nowmid);
			Q2.push_front(Q1.back());
		}
		else
		{
			Q2.push_back(nowmid);
			Q1.push_back(Q2.front());
		}
		x=!x;
	}
	for(int i=1;i<=mid;i++) cout<<Q1.front()<<" ",Q1.pop_front();
	Q2.pop_front();
	for(int i=1;i<mid;i++) cout<<Q2.front()<<" ",Q2.pop_front();
	cout<<endl;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--) Solve();
	return 0;
}
```
[记录详情](https://www.luogu.com.cn/record/196162609)

**Accepted 16ms 2.13MB(O2)**

Over!

---

## 作者：copper_ingot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11463)

首先传球 $k$ 次相当于传球 $(k \bmod 2n)$ 次，其他题解讲得很清楚了，这里就不证明了。

然后观察数据范围，发现 $O(Tn)$ 的时间可以过。

想到要用一个可以 $O(1)$ 时间删除和插入元素，并且可以 $O(1)$ 时间维护正中间数的数据结构，就是链表。

我们建一个双向链表，维护 $head,tail,mid$ 三个指针，$mid$ 为中间的元素，即本轮持球的人。

每次先判断方向，如果这次传球是向右传的，就把 $mid$ 断开并接到 $tail$ 后面，接着更新 $tail$ 为 $mid$，$mid$ 变为下一个元素。如果向左传则反之，$mid$ 要变为上一个元素。

最后从头输出每个元素即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t, n, x, k, pre[200001], nex[200001], mid, head, tail;
signed main(){
	scanf("%lld", &t);
	while (t--){
		scanf("%lld%lld%lld", &n, &x, &k); k %= n * 2;
		for (int i = 2; i < n; i++) pre[i] = i - 1, nex[i] = i + 1;
		pre[1] = -1, nex[1] = 2, head = 1;
		pre[n] = n - 1, nex[n] = -1, tail = n;
		mid = (n + 1) / 2;
		for (int i = 1; i <= k; i++){
			if (i % 2 == x){
				nex[pre[mid]] = nex[mid], pre[nex[mid]] = pre[mid];
				nex[tail] = mid, pre[mid] = tail;
				tail = mid; mid = nex[mid];
				nex[tail] = -1;
			}
			else{
				nex[pre[mid]] = nex[mid], pre[nex[mid]] = pre[mid];
				pre[head] = mid, nex[mid] = head;
				head = mid; mid = pre[mid];
				pre[head] = -1;
			}
		}
		int tmp = head;
		while (tmp != -1){printf("%lld ", tmp); tmp = nex[tmp];}
		puts("");
	}
	return 0;
}
```

---

## 作者：collegiate (赞：0)

通过枚举样例，我们可以发现：

当传球次数达到 $2n$ 次的时候，队列会恢复如初！

所以这道题就很好做啦！通过对 $k$ 取余，然后用**两个双端队列来维护左边和右边**，用一个变量 $mid$ 来维护正中间的，判断 $x$ 是否为 $0$ 或 $1$ 去按照题意模拟，这道题就拿下啦！最后记得遍历完 $l$ 队列之后要输出中间的 $mid$ 即可。放代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,x,k,mid;
int main(){
	cin>>T;
	while(T--){
		deque<ll> l,r;
		cin>>n>>x>>k;
		mid=1+n>>1;
		k%=(2*n);//对k进行取余
		for(int i=1;i<mid;i++) l.push_back(i);//初始化队列
		for(int i=mid+1;i<=n;i++) r.push_back(i);
		while(k--){
			if(x){//按照题意模拟
				r.push_back(mid);
				mid=r.front();
				r.pop_front();
			}
			else{
				l.push_front(mid);
				mid=l.back();
				l.pop_back();
			}
			x=(!x ? 1 : 0);//对x取反
		}
		while(!l.empty()){
			cout<<l.front()<<' ';
			l.pop_front();
		}
		cout<<mid<<' ';//记得输出mid
		while(!r.empty()){
			cout<<r.front()<<' ';
			r.pop_front();
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

经过测试小数据，我们可以得出：当传球次数经过 $2n$ 次时，队列会回到原来的样子。所以，我们将 $k$ 对 $2n$ 取模，是对答案没有影响的。对于剩下的部分，考虑枚举，维护两个双端队列分别统计左边和右边的队列情况，然后按照题意模拟即可。时间复杂度 $O(2n)$，忽略常数后为 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
deque<int> d1,d2;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		d1.clear();
		d2.clear();
		int n,x;
		long long k;
		cin>>n>>x>>k;
		k%=(n*2);
		for(int i=1;i<=n/2;i++) d1.push_back(i);
		for(int i=n/2+2;i<=n;i++) d2.push_back(i);//初始化队列
		int num=n/2+1;
		for(int i=1;i<=k;i++)
		{
			if(x)
			{
				d2.push_back(num);
				num=d2.front();
				d2.pop_front();
				x=0;
			}
			else
			{
				d1.push_front(num);
				num=d1.back();
				d1.pop_back();
				x=1;
			}
		}
		while(!d1.empty())
		{
			cout<<d1.front()<<" ";
			d1.pop_front();
		}
		cout<<num<<" ";
		while(!d2.empty())
		{
			cout<<d2.front()<<" ";
			d2.pop_front();
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：Tyih (赞：0)

# solution
首先进行模拟后，可以发现第 $x$ 次与第 $x+2\times n$ 次队形相同，所以可以将轮次定为 $k \bmod 2n$ 次。然后将整个队形分为左边，右边和中间，用两个队列 $p,q$ 表示左边和右边来模拟。其中 $p$ 的队尾是队形的最左边，$q$ 的队尾是队形的最右边。
# code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,x,k,o,ans[200005];
queue<int> p,q;
void solve(){
	cin>>n>>x>>k;
	for(int i=n/2;i>=1;i--)
		p.push(i);
	for(int i=n/2+2;i<=n;i++)
		q.push(i);
	o=n/2+1;
	k=k%(2*n);
	for(int i=1;i<=k;i++){
		if(x){
			q.push(o);
			o=q.front();q.pop();
			x=0;
		}
		else{
			p.push(o);
			o=p.front();p.pop();
			x=1;
		}
	}
	for(int i=n/2;i>=1;i--){
		ans[i]=p.front();
		p.pop();
	}
	ans[n/2+1]=o;
	for(int i=n/2+2;i<=n;i++){
		ans[i]=q.front();
		q.pop();
	}
	for(int i=1;i<=n;i++)
		cout<<ans[i]<<" ";
	cout<<"\n";
	return ;
}
int main(){
	cin>>T;
	while(T--)
		solve();
	return 0;
}
```

---


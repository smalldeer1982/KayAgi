# 支配剧场

## 题目背景

> May all the beauty be blessed. 

## 题目描述

布洛妮娅和符华在寻找琪亚娜的途中，被支配之律者困在了支配剧场的高塔回廊之中。布洛妮娅敏锐地发现，虚无回廊是由一些支配之律者生成的积木构成的，只要击碎其中一些积木，就能解除空间的限制，让她们逃出高塔回廊。

具体来说，整个高塔回廊可以由一张高为 $n$，宽为 $m$ 的地图表示。第 $1$ 行为空间的最高点，第 $n$ 行为空间的最低点。高塔由 $K$ 块积木堆叠而成，符华每次可以击碎高塔中任意的积木，但必须保证高塔不会倒塌（否则她们会落入虚数空间），以及击碎积木后，高塔回廊的高度不变（即不能把最顶层的积木全部击碎）。

如果一块积木最底层的长度是 $L$，那么当且仅当其**最底层**与地板或者其他积木的接触面积 $L'$ 满足 $L' \ge \left\lceil \frac{L}{2} \right\rceil$ 时，这块积木不会失去平衡。当所有积木**都**不失去平衡时，我们认为整个高塔回廊**不会倒塌**。

积木的最底层长度被定义为**积木行坐标最大的方块总个数**。例如：

```
0 1 0
1 1 1
0 1 0
```
这张图中，$1$ 号积木的最底层长度是 $1$，因为其所占的格子中，行坐标最大的只有一个格子 $(3,2)$。

请帮布洛妮娅计算一下，符华最多能击碎多少个积木？

## 说明/提示

$1\leq n,m\leq 30$，积木块数 $K$ 满足 $1\leq K \leq 15$，且保证高塔初始一定不会倒塌，同一块积木一定是一个四联通块。

**【样例 1 解释】**

符华可以击碎 $3$ 号积木，这不会导致高塔坍塌，也不会降低高塔的高度。可以证明没有更优的方案。

**【样例 2 解释】**

可以击碎 $1,3,4$ 号积木。

## 样例 #1

### 输入

```
5 3
2 2 2
2 3 1
2 3 1
2 3 1
1 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5
0 0 2 2 2
3 3 2 2 2
3 3 3 2 2
1 2 2 2 4
1 1 1 2 4```

### 输出

```
3```

# 题解

## 作者：MaxDYF (赞：3)

注意到这题的 $n,m,K$ 的限制都很小，可以考虑 DFS 暴力搜索。

我们枚举最后删掉了哪些积木，然后在最后检查删掉这些积木后，剩下的积木是否能不失去平衡。一种比较好的检查方法是，提前将每个积木的最底部位置存起来，然后检查的时候只遍历没有被删掉的积木的最底端的下一层是否有支撑。

单次检查的时间复杂度为 $\Theta(mk)$，总的时间复杂度为 $\Theta(mk2^k)$。单次检查复杂度为 $\Theta(nm)$ 的算法也可通过此题。

## Code
```
// #pragma GCC optimize("Ofast,no-stack-protector")
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<db, db> pdd;
typedef pair<ll, int> pli;

const int N = 50;
const int inf = 1 << 30;
const ll inf64 = 1ll << 60;
const double PI = acos(-1);

#define lowbit(x) (x & -x)

int n, m, k, q;
int a[N][N];
vector<pii> tot[N];
bool ban[N];
void toggle(int c)
{
	for (auto [x, y] : tot[c])
		a[x][y] = -a[x][y];
	ban[c] = !ban[c];
}
int highest;
int lowest[N], cnt[N];
bool check()
{
	for (int i = 1; i <= k; i++)
	{
		if (lowest[i] == 0 || ban[i])
			continue;
		int cnt0 = 0;
		for (int j = 0; j < m; j++)
			cnt0 += (a[lowest[i]][j] == i) && (a[lowest[i] - 1][j] > 0);
		if (cnt0 < (cnt[i] + 1) / 2)
			return false;
	}
	for (int j = 0; j < m; j++)
		if (a[highest][j] > 0)
			return true;
	return false;
}
int ans;
void dfs(int x = 1, int cnt = 0)
{
	if (cnt + (k - x + 1) <= ans)
		return;
	if (x == k + 1)
	{
		if (check())
			ans = max(ans, cnt);
		return;
	}
	toggle(x);
	dfs(x + 1, cnt + 1);
	toggle(x);
	dfs(x + 1, cnt);
}
void work()
{
	cin >> n >> m;
	for (int i = n - 1; i >= 0; i--)
		for (int j = 0; j < m; j++)
		{
			cin >> a[i][j];
			if (a[i][j])
				highest = max(highest, i);
			k = max(k, a[i][j]);
			if (!a[i][j])
				continue;
			if (lowest[a[i][j]] == i)
				cnt[a[i][j]]++;
			else
			{
				lowest[a[i][j]] = i;
				cnt[a[i][j]] = 1;
			}
			tot[a[i][j]].push_back({i, j});
		}
	dfs();
	cout << ans << endl;
}
int main()
{
	cin.tie(nullptr)->sync_with_stdio(false);
	int t = 1;
	while (t-- > 0)
	{
		work();
	}
}
```

---

## 作者：CraaazyShep (赞：2)

[P11464 支配剧场](https://www.luogu.com.cn/problem/P11464)

### 分析

注意到 $n,m,K$ 都非常小，那可以考虑使用比较暴力的方法来做。

首先我们可以先记录下最顶层的行坐标，预处理出每块积木最底层所有方块位置，这个预处理过程时间复杂度是 $\mathcal{O}(nm)$ 的。

显然拆除积木的方案共有 $2^K$ 种，全部枚举一遍的时间非常充裕。那我们就可以挨个方案遍历过去，对于每个方案检查拆除积木后是否：

1. 未被拆除的方块全部满足稳定条件。
2. 原本的最顶层还剩有方块。

如果上述两个条件都满足，那么就可以记录下这种方案拆除积木数量作为答案。最后取拆除数量的最大值作为答案。

整个过程时间复杂度是 $\mathcal{O}(2^Knm)$ 的。具体实现细节请见下方代码部分。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[50][50],bp[20],tp;
int main(){
    cin>>n>>m;
    int k=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            k=max(k,a[i][j]);  //记录K
            if(a[i][j]!=0&&tp==0)tp=i;  //记录最顶层行坐标
        }
    }
    vector<vector<int> >b(k+1,vector<int>(0));
    for(int i=n;i>=1;i--){       //预处理出每个积木最底层方块的位置
        for(int j=1;j<=m;j++){
            int ai=a[i][j];
            if(bp[ai]==0){
                bp[ai]=i;        //记录下积木最底层的行坐标
            }
            if(i==bp[ai]){
                b[ai].push_back(j);  //记录下最底层方块的列坐标
            }
        }
    }
    int top=1;
    int ans=0;
    for(int i=1;i<=k;i++){    //top为拆除方块方案数量
        top*=2;
    }
    for(int si=1;si<top;si++){    //dc，dv分别是拆除积木数，以及标记某个积木是否拆除的数组
        int dc=0;
        vector<bool>dv(k+1,false);
        dv[0]=1;
        int sn=si;
        for(int i=1;i<=k;i++){    //用二进制数位表示某个积木是否拆除
            if(sn%2==1){
                dv[i]=1;
                if(bp[i]!=0)dc++;
            }
            sn/=2;
        }
        bool flb=1;
        for(int i=1;i<=k;i++){    //检查是否所有未被拆除的方块都满足稳定条件
            if(dv[i])continue;
            if(bp[i]==n)continue;
            int l=b[i].size();
            int stc=0;
            for(int j=0;j<l;j++){
                int bx=bp[i],by=b[i][j];
                if(!dv[a[bx+1][by]])stc++;
            }
            if(stc<(l+1)/2)flb=0;
        }
        bool flt=0;
        for(int j=1;j<=m;j++){    //检查原最顶层是否仍有方块
            if(!dv[a[tp][j]])flt=1;
        }
        if(flb&&flt)ans=max(ans,dc);
    }
    cout<<ans;
    return 0;
}
```

---


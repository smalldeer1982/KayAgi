# 透明立方体

## 题目背景

NIT 很喜欢观察透明的立方体。

## 题目描述

有一个透明的立方体，设它的长宽高分别为 $n,m,k$（$n\ge m\ge k$）。

立方体中共有 $n\times m\times k$ 个 $1\times1
\times1$ 的小立方体。每个小立方体可由其在三维空间中的坐标 $(a,b,c)$ 表示（$1\le a\le n$，$1\le b\le m$，$1\le c\le k$）。

现将立方体的一部分染黑，我们可以选择一些 $1\times1\times1$ 的小立方体将其染黑。

一个立方体变得不透明，当且仅当从正面，侧面，顶面观察立方体，立方体均不再有透明的地方。

你需要求出最少染黑多少个 $1\times1\times1$ 的小立方体才能使得立方体变得不透明，并给出方案。

若有多个染色数最小的方案，给出任意一个可行方案即可。

## 说明/提示

$1\le k\le m\le n\le 50$。

## 样例 #1

### 输入

```
3 2 2
```

### 输出

```
6
1 1 1
3 1 1
2 1 2
2 2 1
1 2 2
3 2 2
```

# 题解

## 作者：DeepSleep_Zzz (赞：3)

**begin**

[P11466 透明立方体](https://www.luogu.com.cn/problem/P11466)

# 思路

如果要想从正面、侧面、顶面观察立方体，立方体均不再有透明的地方，我们就需要让每一行、每一列、没一排都有至少一个正方体被涂色，而又因为要保证数量最小，所以我们最终得出：

要想使该正方体从正面、侧面、顶面观察，均不再有透明的地方，我们只需要让该正方体的每一行、每一列、没一排有且只有一个正方体被涂色即可。

### 第一小问

很显然如果照这个思路做下去那么最少的染色数即为：

$$\max(n \times m,n \times k,m \times k)$$

又因为 $n \ge m \ge k$，所以原始等价于：

$$n \times m$$

### 第二小问

我们考虑三维转二维，首先枚举 $x$ 坐标和 $y$ 坐标，然后通过取模运算的维护，使 $1 \sim k$ 都有且仅有一个方块被涂黑实现平均分配，从而算出 $z$ 坐标。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll n,m,k,h;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>k;
    cout<<n*m<<"\n";
    for (ll i=1;i<=n;i++)
    {
        h=abs(k-i+1)%n; // C++的逆天取模机制导致我们必须要用abs，当然+n也可以。
        for (ll j=1;j<=m;j++,h++)
        {
            cout<<i<<" "<<j<<" "<<h%k+1<<"\n"; // 这里直接输出就行，不用数组，节省空间。反正有spj为我们保驾护航。
        }
    }
    return 0;
}
```

**end**

---

## 作者：xuchenjun_Aaron (赞：2)

这道题如果想要最少，就得要每行每列每条竖线都要只有一个方格涂色，也就是一个黑色格子可以将那行那列那条竖线看上去都是黑的。

代码来源：[大佬](www.luogu.com.cn/user/1032960)

 _AC CODE_ 

 
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100][100];
int n,m,k;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		int sum=(k-i+1+n)%n;
		for(int j=1;j<=m;j++){
			a[i][j]=sum%k+1;
			sum++;
		}
	}
	cout<<n*m<<endl;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<i<<" "<<j<<" "<<a[i][j]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：TN_lougu (赞：2)

[题目](https://www.luogu.com.cn/problem/P11466)
# 题面
有一个透明正方体，里面有 $n \times m \times k$ 的小正方体，将其中一些 $1 \times 1 \times 1$ 的小正方体染色，使这个大正方体从**正面**，**侧面**，**上面**，看均不透明。
# 分析
## 样例
下面推测，数字为第几层，并且都为俯视图。
### 第一组
当 $n = 3$，$m = 2$，$k = 2$。
```
1 2
2 1
1 2
```

### 第二组
当 $n = 3$，$m = 3$，$k = 3$。
```
1 2 3
2 3 1
3 1 2
```

### 第三组
当 $n = 4$，$m = 4$，$k = 4$。
```
1 2 3 4
2 3 4 1
3 4 1 2
4 1 2 3
```
### 结论
根据以上推论（答案不唯一），可以知道 $x = n \times m$，并且第 $i + 1$ 层是第 $i$ 层的下一条斜线。
# 思路
先输出 $n \times m$，也就是题面中的 $x$，然后斜着输出坐标。
# 代码
## 推论
在第一组样例中，俯视图为（数字为第几层）：
```
1 2
2 1
1 2
```
先看 $x$ 的初始值，在前 $2$ 个循环中，$x$ 的值都为 $1$，然后就会依次增加。也就是说，当 $i \le m$ 时，$x$ 的值为 $1$，当 $i > m$ 时，$x$ 的值为上一次的值加一。
```
if(i>m) xc++;
```
再看 $y$ 的初始值，在前 $2$ 个循环中，$y$ 的值是为 $i$，当 $i$ 的值大于 $m$ 时，$y$ 的值就不会变。也就是说，当 $i \le m$ 时，$y$ 的值就为 $i$，而当 $i > m$ 时，$y$ 的值不变。
```
if(i<=m) yc++;
```
最后看 $z$ 的初始值，$z$ 的初始值就是从 $1$ 到 $k$ 依次循环。
```
z=z%k+1;
```
因为要斜着输出，所以每次输出时还要让 $x + 1$，$y - 1$。
并且当 $x>n$ 或 $y>m$ 时，不成立，直接退出循环。
```
if(x>n||y>m) break;
cout<<x<<" "<<y<<" "<<z<<"\n";
x++,y--;
```
## AC 代码
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	cout<<n*m<<"\n";     //因为 n >= m >= k，所以直接输出 n * m。 
	int x,y,z=1,xc=1,yc=0;     //xc 是 x 的初始值，yc 是 y 的初始值。 
	for(int i=1;i<=m+n-1;i++)
	{
		if(i<=m) yc++;    //当 i 的值小于 m 时，y 的初始值是上一次的值加一。 
		else xc++;     //当 i 的值大于 m 时，x 的初始值是上一次的值加一。 
		x=xc,y=yc;     //附上初始值。 
		for(int j=1;j<=min(i,m);j++)
		{
			if(x>n||y>m) break;     //当这些条件都不成立。 
			cout<<x<<" "<<y<<" "<<z<<"\n";     //输出坐标。 
			x++,y--;
		}
		z=z%k+1;     //z 从 1 到 k依次循环。  
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/196527580)

---

## 作者：Danny_chan (赞：2)

要想让立方体变得不透明并且染黑的方块数最少，那么每一列的正方体就要至少染一个方块，最后用三维二维化就可以了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100][100];
int n,m,k;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		int sum=(k-i+1+n)%n;
		for(int j=1;j<=m;j++){
			a[i][j]=sum%k+1;
			sum++;
		}
	}
	cout<<n*m<<endl;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<i<<" "<<j<<" "<<a[i][j]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：dongzirui0817 (赞：2)

## 前言

有趣的构造题。（好久没做过啦）

## 思路

首先可以贪心得出，至少要 $nm$ 个染色数。

因为从上看，能看到 $nm$ 个面，意味着至少要 $nm$ 个染色数。而其他两面，可以利用改变染色的层数来使其符合要求。

利用这点，就可以讨论这 $k$ 层。为了染色数最小，那么从上往下看，其中的一个格子下面要有且仅有一个点被染色。

我的方案如下：

共有 $n$ 列，其中前 $m$ 列解决左面的要求，后面的列解决正面的要求。

具体的：

- 前 $m$ 列构造方案：对于第 $i$ 层，从第 $i$ 行第 $1$ 列开始，到第 $m$ 行第 $m - i + 1$ 列，往右下走；再从第 $1$ 行第 $m - i + 2$ 列，到第 $i - 1$ 行第 $m$ 列，往右下走。

- 后面列构造方案：对于第 $i$ 层，从第 $i$ 行第 $m + 1$ 列，到第 $i$ 行第 $n$ 列，往右走。

之后就看这 $k$ 层的同一位置，若都没有染色，就统一在第一层的这个位置染色。

例如 $n = 7, \, m = 5, \, k = 3$ 时，构造方案如下（其中黑色是前半部分所染色的，橙色是后半部分染所色的）：

![](https://cdn.luogu.com.cn/upload/image_hosting/lo67t1oh.png)

其余细节请看代码。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k;
bool a[60][60];

int main() {
	scanf("%d%d%d", &n, &m, &k);
	printf("%d\n", n * m);
	for (int i = 1 ; i <= k ; i++) {
		for (int j = i ; j <= m ; j++)
			printf("%d %d %d\n", j, j - i + 1, i), a[j][j - i + 1] = true;
		for (int j = 1 ; j < i ; j++)
			printf("%d %d %d\n", j, m - i + 1 + j, i), a[j][m - i + 1 + j] = true;
		for (int j = m + 1 ; j <= n ; j++)
			printf("%d %d %d\n", j, i, i), a[j][i] = true;
	}
	for (int i = 1 ; i <= n ; i++)
		for (int j = 1 ; j <= m ; j++)
			if (!a[i][j]) printf("%d %d 1\n", i, j);
	return 0;
}
```

---

## 作者：Wzmois (赞：1)

[传送门](https://www.luogu.com.cn/problem/P11466)+[P11466 C++ 20 O2 最优解代码](https://www.luogu.com.cn/record/196471143)

大部分题解运用数组存储，个人认为较为麻烦，于是便有了此题解。
## 第一小问
对于每一个 $n\times m\times k$ 的立方体中，要染黑多少个 $1 \times 1\times1$ 的小立方体，才能使三视图都变黑？
### 解决方案
- 从上面面看，该平面 $1 \times 1\times1$ 的小立方体的数量为 $n\times m$。
- 从正面面看，该平面 $1 \times 1\times1$ 的小立方体的数量为 $n\times k$。
- 从左面面看，该平面 $1 \times 1\times1$ 的小立方体的数量为 $m\times k$。

在其中，若想要让三视图都变黑，只需让能看到 $1 \times 1\times1$ 的小立方体最多的面变黑，其他面暂时不理。

**但是**，数据范围给出了 $k\le n\le m$ ，即 $\max(n\times m,m\times k,n\times k)=m\times n$ 。

于是第一行输出 $m\times n$ 即可。
## 第二小问
要我们求出被染黑小立方体的坐标。
### 解决方案
我们首选肯定依次把 $a$，$b$ 坐标分别从 $1\sim n$ , $1\sim m$ 遍历一遍，剩下的 $c$ 坐标只需平均分配即可。

分配完之后直接输出即可，不需存入数组，以优化内存。

## AC代码（禁止抄题解）
```cpp
#include <stdio.h>
int main(){
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	printf("%d\n",n*m);
	for(int i=1,t=1;i<=n;i++){
		t=(k-i+1+n)%n;//平均分配过程，通过用求余符号达到目的，下面t++也是。
		for(int j=1;j<=m;j++,t++) printf("%d %d %d\n",i,j,t%k+1);
	}
	return 0;
}
``````

---

## 作者：GSQ0829 (赞：1)

### 思路：
- 先思考把三维立体二维化。
- 用一个数组维护, 标注我要染黑的方块对应的高度坐标。
- 数组要保证，每行每列每个位置非空。

---

### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 51;
int a[MAXN][MAXN], n, m, h;

int main() {
	cin >> n >> m >> h;
	for (int i = 1; i <= n; i++) {
		int s = (h - i + 1 + n) % n;
		for (int j = 1; j <= m; j++) {
			a[i][j] = s % h + 1;
			s++;
		}
	}
	cout << n * m << endl;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) cout << i << ' ' << j << ' ' << a[i][j] << endl;
	}
	return 0;
}
```

---

## 作者：Reserved_ (赞：1)

# 前言：
本想法由 [I__________________I](https://www.luogu.com/user/1172625) 大佬发现，本蒟蒻做补充。
# 思路：
利用贪心的想法：
- 考虑从正面观察这个立方体，要使得正面看不到透明的地方，我们需要在每一行（对应长的维度）至少染黑一个小立方体（沿高的维度）。

```cpp
for(int i=1; i<=n; i++)
{
    int s=(h-i+1+n)%n;
    for(int j=1; j<=m; j++)
    {
        a[i][j]=s%h+1;
        s++;
    }
}
```

- `s=(h - i + 1 + n) % n` 以及后续操作来确定每行对应染黑的小立方体在高维度上的位置，保证每一行都能覆盖到一个小立方体用于遮挡正面视线。
- 同样地，对于侧面（对应宽的维度）观察也是类似的道理，在代码的内层循环遍历宽维度时，通过上述计算方式同样能保证每一列（对应宽的维度）在高维度上也有对应的小立方体被染黑，从而遮挡侧面视线。
- 对于顶面，由于是按照行列的顺序依次去选择染黑小立方体，只要保证了行列方向上都有合适的小立方体染黑，那么顶面也必然不会存在透明的地方。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[51][51];
int main()
{
    int n,m,h;
    cin>>n>>m>>h;
    for(int i=1; i<=n; i++)
    {
        int s=(h-i+1+n)%n;
        for(int j=1; j<=m; j++)
        {
            a[i][j]=s%h+1;
            s++;
        }
    }
    cout<<n*m<<endl;
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=m; j++)
        {
           cout<<i<<" "<<j<<" "<<a[i][j]<<endl;
        }
    }
    return 0;
}
```

---

## 作者：huangjinsong (赞：1)

# 思路：
一，因为我们在同一水平面去看一个物体，只要那一列有一个是被染色的，就会被我们认为这一列是被染色的。那么要使摆放数最小化，可以用贪心得出，每一行每一列每一排，只需要染色一个方块，所以染色总数是长乘宽。

二，我们可以把三维转换为二维，每一行每一列每一排只需要染色一个方块，那么我们可以通过取余然后再加一，让方块的染色尽可能的错开且不在同一平面内。所以，我们就可以用一个二维数组模拟一个的平面。因为取余再加一的不断维护，那么染色的方块就不在同一平面内且尽可能的错开了。

# 代码实现：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100][100]; //长，宽，高只有五十
int n,m,k; //长，宽，高
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		int sum=(k-i+1+n)%n;
		for(int j=1;j<=m;j++){
			a[i][j]=sum%k+1; //因为是三维的所以要加一 
			sum++; //记录 
		}
	}
	cout<<n*m<<endl; //最小值要尽量保证每行每列每排都不要有染色的方块，合起来是一个平面，所以是长乘宽
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<i<<" "<<j<<" "<<a[i][j]<<endl; //输出 
		}
	}
	return 0;
}
```

---

## 作者：AFO_Lzx (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P11466)

### $\texttt{Description}$

给定一个 $n \times m \times k$ 的长方体，由 $n \times m \times k$ 个体积为 $1 \times 1 \times 1$ 的小正方体组成。现在要将长方体的六个面全部染成黑色，求出最少的被染黑的小正方体的个数，并任意输出一种染色方案。

### $\texttt{Solution}$

#### 第一部分：最少个数

- 易得每一行、每一列、每一排只需要一个染色，所以**最小值**即为：

  $$\max(n \times m,n \times k, m\times k)$$

- 又因为 $n \ge m \ge k$，所以 $\max(n \times m, n \times k, m \times k)=n\times m$。

#### 第二部分：方案输出

我们可以直接通过枚举行坐标和列坐标，然后算出第三维的坐标并直接输出即可。注意**取模**时的**负数**！

时间复杂度 $O(n \times m)$，$n,m \le 5 \times 10^3$ 都不是问题。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int n, m, k, x;
	cin >> n >> m >> k;
	cout << n * m << endl;
	
	for (int i = 1; i <= n; i++) {
		x = (k - i + 1 + n) % n;
		for (int j = 1; j <= m; j++) 
		cout << i << " " << j << " " << (x++) % k + 1 << endl;
	}
	
	return 0;
}
```

完结了，拜拜。

---

## 作者：ridewind2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11466)

## 思路

+ 最少的染色数为 $\max(n \times m,n \times k,m \times k)$，由于 $n \ge m \ge k$，所以答案为 $n \times m$。

+ 三维转二维，枚举 $x$ 坐标和 
$y$ 坐标，然后算出 $z$ 坐标。我们可以不用二维数组，直接输出。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,k,sum;
	cin>>n>>m>>k;
	cout<<n*m<<"\n";
	for(int i=1;i<=n;i++){
		sum=(k-i+1+n)%n;//可能会出现负数，所以取模时别忘了加n 
		for(int j=1;j<=m;j++){
			cout<<i<<" "<<j<<" "<<sum%k+1<<"\n";//直接输出答案 
			sum++;
		}
	}
	return 0;
}
```

---

## 作者：wen_hao_shi_wo (赞：0)

## 前置
[题目传送门](https://www.luogu.com.cn/problem/P11466)

[AC记录](https://www.luogu.com.cn/record/list?pid=P11466&user=1083388)

## 题目要求
需要求出最少染黑多少个 $1 \times 1 \times 1$ 的小立方体才能使得立方体变得不透明,还需要给出方案数。

## 题目思路

首先我们发现从前面看，要想不透明就得每一个纵列得有一个方块染黑；

其次我们从上面看，要想不透明就得每一列都得有一个方块染黑；

$($侧面同理，这里就不多解释了$)$

由上可得每一列，每一行，每一排都得有一个方块染成黑色，又由题目要求可知需要最少染黑多少个小正方体，所以每一行，每一列，每一排只能有一个小正方体染黑。

最后我们用一个数组 $a_{i,j}$ 来表示第 $i$ 行，第 $j$ 列表示染色小正方体的层数。

思路到此为止，建议大家先自己尝试，有不懂的再看一下代码。
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[53][53];
int n,m,k;

void print(){//输出最小的方案
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<i<<" "<<j<<" "<<a[i][j]<<"\n";
		}
	}
}

void work(){//主函数部分
	cin>>n>>m>>k;
	cout<<n*m<<"\n";//方案数
	for(int i=1;i<=n;i++){
		int ls=abs(k-i+1)%n;
		for(int j=1;j<=m;j++){
			a[i][j]=ls%k+1;
			ls+=1;
		}
	}
	print();
}

void accelerate(){
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

int main(){
	accelerate();//提高运行速度
	work();
	return 0;
}
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11466)
## 思路
由于要使得染色方块数最少且从任意面观察全为黑色，所以每一列的正方体必然有且仅有一个被染色。

记 $a_{i,j}=c$ 表示坐标为 $(i,j,c)$ 的方块被染色，$c$ 相同的 $i,j$ 可以按照类似斜线的方法来排列，这样就可以做到从任意面观察均全为黑色了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[70][70],n,m,k,c;
int main() {
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) {//构造排列方法
		c=(k-i+1+n)%n;
		for(int j=1;j<=m;j++) a[i][j]=c%k+1,c++;
	}
	cout<<n*m<<endl;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) cout<<i<<" "<<j<<" "<<a[i][j]<<endl;
	}
}
```

---

## 作者：lcycl (赞：0)

# 前言
[传送门](https://www.luogu.com.cn/problem/P11466)
# 思路
首先，我们可以想到三维数组直接模拟，用三维数组 $a$ 来存。如果 $a_{i,j,k}$ 被染色，就把 $a_{i,j,k}$ 设为 $1$。但是，我们是 OIer，我们需要更高级的方式。我们发现，如果想要从上面看下去全染成黑色，每一列至少染一个，从其他面看同理。我们又双叒叕发现想要染色最少，我们每一列（$z$ 轴）或每一行（$y$ 轴）或每一排（$x$ 轴），有且仅有一个被染色。所以我们可以发扬人类智慧，把每一列看成只有一个。这样，我们的三维数组就可以优化为二维数组。$a_{i,j}$ 存的是第 $i$ 行，第 $j$ 列的染色方块的层数。因为我们需要每一个面看起来都是黑的，所以，每一行，每一列必须有 $1\sim k$ 的每一个数。所以，我们只需要创建这样一个二维数组就行了。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[114][514];//玄学
signed main(){
	int x,y,z;
	cin>>x>>y>>z;
	cout<<x*y<<"\n";//方案数
	for(int i=1;i<=x;i++){
		int yyswys=abs(z-i+1)%x;//玄学（）
		for(int j=1;j<=y;j++){
			a[i][j]=yyswys%z;
			++yyswys;
		}
	}
	for(int i=1;i<=x;i++){
		for(int j=1;j<=y;j++){
			cout<<i<<" "<<j<<" "<<a[i][j]+1<<"\n";//要+1
		}
	}
	return 0;
}
```

---

## 作者：LG086 (赞：0)

给出一个 $a\times b\times c$ 的透明立方体，问至少给多少个 $1\times 1\times 1$ 的小立方体涂色，使它不透明，并输出方案。

我在厕所想到了本题解题思路。想要涂色的方块数最少，那么就尽可能的交错着给每个立方体涂色。  
实际上只需要从上面、正面、左面三个方向观察就可以判断立方体是否不再透明。而如果只从两个方向看立方体，一种可行的涂色方法类似图中所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/qihgy559.png)

这种涂色方案需要涂 $2\times 3$ 个小立方体，满足左面、正面不透明。而当加上上面看不透明的条件时，只需要稍作移动涂色方块的位置便可以完成。所以，在满足 $a\ge b\ge c$ 的情况下，最少涂色的方格个数就是 $a\times b$。  
下面给出 $2\times 2\times 2$ 的立方体的一种涂色方式的涂色过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/d7pivbey.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/1tb3vn7o.png)

我们需要一个双重循环。外层循环的 $i$ 由 $1$ 遍历到 $a$，内层循环的 $j$ 由 $1$ 遍历到 $b$。在每一轮外层循环开始时，定义一个变量 $k$，初始化为 $i$。在内层循环的过程中，输出 $i,j,k$，$k \gets k+1$。特别的，若此时有 $k\gt c$，则 $k\gets 1$，继续操作。  
在本题 $1 \le c \le b\le a \le 50$ 的数据范围下，这种方法完全可以通过。

做完了。

---


# [ROIR 2019] 完全平方 (Day 1)

## 题目背景

翻译自 [ROIR 2019 D1T2](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day1.pdf)。

## 题目描述

我们知道序列 $0,0+1,0+1+3,0+1+3+5,\dots,0+1+3+\dots+(2i-1),\dots$ 的第 $i$ 项是 $i^2$，即，这个序列里的数全部都是完全平方数。

现在我们不让这个序列从 $0$ 开始，而是从 $k$ 开始：$k,k+1,k+1+3,k+1+3+5,\dots,k+1+3+\dots+(2i-1),\dots$。

你需要找到这个序列中最小的完全平方数，并输出它的算术平方根。

## 说明/提示

### 样例解释：

- 样例 $1$ 中的序列即为题目中提到的完全平方数序列，其中最小的数是 $0$，$\sqrt0=0$。
- 样例 $2$ 中的序列为 $-5,-4,-1,4,11,20,\dots$，其中最小的完全平方数是 $4$，$\sqrt4=2$。
- 样例 $3$ 中的序列为 $2,3,6,11,18,\dots$，可以证明其中不存在完全平方数。

### 数据范围：

数据中 Subtask 0 为样例。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $7$ | $0\le k\le1000$ |
| $2$ | $10$ | $0 \leq k \leq 10^5$ |
| $3$ | $27$ | $0 \leq k \leq 10^{12}$ |
| $4$ | $7$ | $-1000 \leq k \leq 1000$ |
| $5$ | $10$ | $-10^5 \leq k \leq 10^5$ |
| $6$ | $39$ | $-10^{12} \leq k \leq 10^{12}$ |

## 样例 #1

### 输入

```
0```

### 输出

```
0```

## 样例 #2

### 输入

```
-5```

### 输出

```
2```

## 样例 #3

### 输入

```
2```

### 输出

```
none```

# 题解

## 作者：mishitaotuoyyds (赞：5)

# 题目分析：
首先观察题目中的说的序列 $0$ 时第 $i$ 项是 $i^2$ 这条性质，以及序列 $k$ 和第 $2$ 个样例可以发现，如果一个序列 $k$ 有完全平方数那么肯定满足 $a^2+k^2=b^2$。
然后看数据大小发现 $-10^{12}\leq k\leq10^{12}$ 所以这题得分类讨论，可分三种，如下。
- 如果 $k=0$ 直接输出 $0$。
- 如果 $k\ge1$ 就用枚举法，枚举从 $\sqrt{k}$ 一直到 $1$ 就好了。
- 如果 $k\leq-1$ 先用和 $k\ge1$ 一样的方法最后再取相反值。
## 参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long k;
int main()
{
	cin>>k;
	if(k==0){
		cout<<0;
		return 0; 
	}
	else{
		for(int i=sqrt(abs(k));i>=1;i--){
			if(k%i==0&&i%2==(abs(k)/i)%2){
				if(k<0)cout<<(-k/i-i)/2;
				else cout<<(k/i+i)/2;
				return 0;
			}
		}
        
	}
	cout<<"none";
	return 0;
}
```
完结撒花。

---

## 作者：HHC883 (赞：5)

# 题目分析
若 $k = 0$，答案显然为 $0$。

若 $k > 0$，设序列的第 $x + 1$ 项为平方数，则存在正整数 $y$，使得 $k + x^2 = y^2$，于是 $k = y^2 - x^2 = (y + x)(y - x)$，于是枚举 $k$ 的所有不超过 $\sqrt{k}$ 的正因数 $i$，那么就可以令 $y + x = i , y - x = k \div i$，解得 $y = (i + k \div i) \div 2$，最后取所有 $y$ 的最小值即可。

若 $k < 0$，设序列的第 $x + 1$ 项为平方数，则存在正整数 $y$，使得 $- \left| k \right| + x^2 = y^2$，于是 $\left| k \right| = x^2 - y^2 = (x + y)(x - y)$，于是枚举 $\left| k \right|$ 的所有不超过 $\sqrt{\left| k \right|}$ 的正因数 $i$，那么就可以令 $x + y = \left| k \right| \div i , x - y = i$，解得 $y = \left| k \right| \div i - (i + \left| k \right| \div i) \div 2$，最后取所有 $y$ 的最小值即可。注意这里不令 $x + y = i , x - y = \left| k \right| \div i$ 的原因是这种情况下解得 $y = i - (i + \left| k \right| \div i) \div 2$，但这是负数（因为 $i \le \sqrt{\left| k \right|}$）。

注意判断无解。时间复杂度为 $O(\sqrt{\left| k \right|})$。
# 参考代码
```cpp
#include<iostream>
#define int long long
using namespace std;
int k;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>k;
	if(k==0) cout<<0;
	else if(k>0){
		int ans=1e18;
		for(int i=1;i*i<=k;i++){
			if(k%i==0){
				if((i+k/i)%2==0) ans=min(ans,(i+k/i)/2);
			}
		}
		if(ans==1e18) cout<<"none";
		else cout<<ans;
	}else{
		k*=-1;
		int ans=1e18;
		for(int i=1;i*i<=k;i++){
			if(k%i==0){
				if((i+k/i)%2==0) ans=min(ans,k/i-(i+k/i)/2);
			}
		}
		if(ans==1e18) cout<<"none";
		else cout<<ans;
	}
	return 0;
}
```

---

## 作者：cengzh (赞：2)

[传送门](https://www.luogu.com.cn/problem/P11496)
#

似乎是一种另类思路。

转化题意：给定一个数 $k$，令 $q$ 为某个完全平方数，求最小的完全平方数 $k+q$。

令 $q = 0 + 1 + 3 + \dots + (2i - 1) = i^2$，$k + q = 0 + 1 + 3 + \dots + (2x - 1) = x^2$，

则 $k = (k + q) - q = (2i + 1) + (2i + 3) + \dots + (2x - 1)$。

$k$ 是一个公差为 $2$ 的等差数列的和，我们以此判断是否有解。

从这一角度入手，有一个时间复杂度为 $O(\sqrt{k})$ 的算法：

令 $k = (a_1 + a_n) \cdot n \div 2$，其中 $a_n = a_1 + 2(n - 1)$，于是有 $k = n \cdot (n + a_1 - 1)$。

暴力枚举 $n$，判断 $a_1$ 是否为整数。$a_1$ 对应的是 $2i + 1$，于是我们可得 $q$ 的值。而这里 $n$ 只需枚举到 $\sqrt{k}$。

证明：因为 $a_1 \ge 1$，则 $n \cdot (n + 1 - 1) \le k$，即 $n^2 \le k$，即 $n \le \sqrt{k}$。

如果 $k$ 是负数呢？

那么 $-k = -(2x + 1) - (2x + 3) - \dots - (-2i + 1)$，也能枚举。

两种情况均可通过等差数列的性质求出最小的 $k+q$，同时也能避免变量溢出。~~算法表现竟然还不错，一路干到最优解~~。

具体请看代码。

```c
#include <stdio.h>
#include <math.h>

int main(void)
{
    long long k;
    scanf ("%lld",&k);

	if (k == 0)
	{
		printf("0");
		return 0;
	}
	else if (k > 0)
	{
		long long minans = -1;
	    long long upper_bound = sqrt(k);
	    for (long long n=1;n<=upper_bound;n++)
		{
	        if (k % n == 0)
			{
	            long long an = k / n + n - 1;
	            if (an > 0 && an % 2)
				{
				    long long ans = (an+1)/2;
					if (ans < minans || minans == -1)
					{
						minans = ans;
					}
	            }
	        }
	    }
	    if (minans == -1)
		{
			printf ("none");
		}
		else
		{
            printf ("%lld",minans);
		}
	}
	else if(k < 0)
	{
		long long minans = -1;
	    long long upper_bound = sqrt(-k);
	    for (long long n=1;n<=upper_bound;n++)
		{
	        if ((-k) % n == 0)
			{
	            long long a1 = (-k) / n - n + 1;
	            if (a1 > 0 && a1 % 2)
				{
					long long ans = (a1-1)/2;
					if (ans < minans || minans == -1)
					{
						minans = ans;
					}
	            }
	        }
	    }
	    if (minans == -1)
		{
			printf ("none");
		}
		else
		{
			printf ("%lld",minans);
		}
	}
    return 0;
}

```

---

## 作者：船酱魔王 (赞：2)

## 题意回顾

给定整数 $ k $，你需要找到最小的非负整数 $ p $ 满足存在非负整数 $ r $ 使得 $ p^2=k+r^2 $，输出 $ p $。

$ -10^{12} \le k \le 10^{12} $。

## 分析

考虑变换答案方程的形式。

* 当 $ k=0 $ 时，答案显然为 $ p=0 $（此时 $ r=0 $）。
* 当 $ k>0 $ 时，$ k=p^2-r^2=(p+r)(p-r) $，由 $ r,p \ge 0 $ 得 $ r < p $，则 $ p+r $、$ p-r $ 均为正整数且 $ p-r \le p+r $；因为 $ p=\sqrt{k+r^2} $ 且 $ r=\sqrt{p^2-k} $ 所以有 $ p,r $ 在同一组解中同时取到最小值，故我们应该最小化 $ p+r $ 即最大化 $ p-r $，将 $ k $ 分解为两个整数相乘的形式，较小（或相等）的一定为 $ p-r $，找到这个较小因数的最大值即可（注意需要满足 $ p-r $ 与 $ p+r $ 奇偶同性否则无法解出整数）。
* 当 $ k<0 $ 时，可以转化为 $ -k=(r+p)(r-p) $，因为 $ p,r $ 同时取到最小值的结论依然成立，所以用与第二种情况类似的处理方式即可。

本题该解法时间复杂度为 $ O(\sqrt{|k|}) $。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
long long k;
int main() {
	cin >> k;
	if(k == 0) puts("0");
	else {
		bool ok = false;
		if(k < 0) k = -k, ok = true;
		int ir = 0;
		for(int i = 1; (long long)i * i <= k; i++) {
			if(k % i == 0 && i % 2 == (k / i) % 2) ir = i;
		}
		if(!ir) puts("none"); 
		else cout << ((!ok) ? ((ir + k / ir) / 2) : ((k / ir - ir) / 2)) << endl;
	}
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：
如果是零，那答案也为零，因为零是完全平方数。

如果小于零，那么就把 $k$ 取为它的绝对值，用平方差公式，可以从 $\sqrt k$ 到 $1$ 去枚举，得到最小值。

如果大于零，也用平方差公式，枚举出最小值。

---


### code:
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int k, ans = 0;
bool flag = 0;

signed main() {
	cin >> k;
	if (k == 0) cout << 0;
	else {
		if (k < 0) {
			k = -k;
			flag = true;
		}
		for (int i = 1; (long long)i * i <= k; i++) {
			if (k % i == 0 && i % 2 == (k / i) % 2) ans = i;
		}
		if (ans == 0) cout << "none";
		else cout << ((!flag) ? ((ans + k / ans) / 2) : ((k / ans - ans) / 2)) << endl;
	}
	return 0;
}
```

---

## 作者：jojo222 (赞：1)

简化一下题目：整数 $k$ 是否能通过加一个平方数 $b^2$，得到平方数 $a^2$，求最小的 $a$。

这道题要分类讨论。
- $k=0$：不用说，直接输出 $0$。
- $k>0$：这时 $a>b$，$a^2-b^2=k$。用平方差公式，得到 $(a-b)(a+b)=k$。可以从 $\lfloor\sqrt k\rfloor$ 至 $1$ 枚举 $a-b$，得到最小的 $a$。
- $k<0$：这时 $a<b$，$b^2-a^2=-k$。也用平方差公式，得到 $(b-a)(b+a)=-k$。可以从 $\lfloor\sqrt{-k}\rfloor$ 至 $1$ 枚举 $b-a$，得到最小的 $a$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
int main() 
{
	cin >> n;
	if(n == 0)
	{
		puts("0");
		return 0;
	}
	for(int i = sqrt(abs(n)); i >= 1; i--)
		if(n % i == 0 && (i + n / i) % 2 == 0)
		{
			if(n > 0)
				printf("%d", (i + n / i) / 2);
			else printf("%d", (-n / i - i) / 2);
			return 0;
		}
	puts("none");
	return 0; 
}
```

---

## 作者：hhhqx (赞：1)

2025 年 1 月 1 日了，发题解可以涨 RP 吗？



---

支持评黄

---

先判掉 $k=0$ 的情况。

考虑 $k > 0$：

- 问题是要求两个平方数之差为 $k$。
- 设较小的平方数是 $x^2$。另一个平方数是 $(x+i)^2 = x^2 + i^2 + 2ix$。两个平方数之差是 $i^2 + 2ix$。
- 得到方程 $i^2 + 2ix=k$，其中 $i$ 是正整数、$x$ 是非负整数，显然 $i \le \sqrt{k}$，那么枚举出 $i$，可以解得 $x=\frac{k-i^2}{2i}$。
- 如果 $x$ 不是非负整数，就忽略，否则考虑进答案，求 $(x+i)$ 的最小值。
- 最后输出最小值即可。

考虑 $k < 0$：

- 把 $k$ 取绝对值，和 $k > 0$ 一样，只不过最后求的是 $x$ 的最小值。

温馨提示：这题答案可能有 $10^{12}$ 这么大（这一点根据做法可以看出来），并且 `sqrt()` 对 `int128` 开根容易寄。要么避免平方，要么使用二分。

### Code1

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const LL inf = 1e18;

LL k, op;

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> k, op = (k > 0), k = max(k, -k);
  if(k == 0){
    cout << 0;
    return 0;
  }
  LL x = inf, _x = 0;
  for(LL i = 1; i * i <= k; i++){
    LL d = i * 2, b = k - i * i;
    if(b % d == 0 && b / d < x) x = b / d, _x = i;
// 说句闲话：这里 b / d < x 改为 b / d <= x 也没有问题
  }
  if(x == inf){
    cout << "none";
    return 0;
  }
  if(op == 0){
    cout << x;
    return 0;
  }
  cout << x + _x;
  return 0;
}
```

### Code2
```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = __int128_t;

const LL inf = 1e18;

long long k, op;

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> k, op = (k > 0), k = max(k, -k);
  if(k == 0){
    cout << 0;
    return 0;
  }
  LL x = inf;
  for(LL i = 1; i * i <= k; i++){
    LL d = i * 2, b = k - i * i;
    if(b % d == 0) x = min(x, b / d);
  }
  if(x == inf){
    cout << "none";
    return 0;
  }
  x = x * x;
  if(op == 1) x += k;
  long long l = 0, r = 1e18; // 注意这里 l = 0，不是 l = 1
  while(l < r){
    LL mid = (l + r + 1) >> 1;
    if(mid * mid <= x){
      l = mid;
    }else r = mid - 1;
  }
  cout << l;
  return 0;
}
```

---

## 作者：cjx_AK (赞：1)

#### 闲话
前有 T1 卡 1h 后有 T2 没乘 $i$ 。

废话不多说，先看题目。

题目说给你一个完全平方数的无限序列，然后把这个序列加上 $k$ ，求现在的序列中最小的完全平方数。

既然题目说全是完全平方数，那么很容易想到平方差公式：

 $a^2-b^2=(a+b)(a-b)$

那么 $k$ 就可以看作两个平方数的差，就可以进行找   $k$ 的因数，找出整数解即可。


### code   

```
#include<bits/stdc++.h>
using namespace std;
#define int long long 
long long l,r,k=1,r1=1,t=1,l1,a[100002],b[2000001],n,ans=1e13;

void check(int x,int y){
	if(y>x)swap(x,y);
	if((x+y)%2==0){
		int x1=(x+y)/2,x2=(x)-x1;
		if(l1){
			ans=min(ans,min(x1,x2));
			return ;
		}else{
			ans=min(ans,max(x1,x2));
			return ;
		}
	}
}
void pri(int n){
	for(int i=1;i*i<=n;i++){
		if(n%i==0){
			check(i,n/i);
		}
	}
}
signed main(){
	cin>>n;
	if(!n){
		cout<<0;
		return 0;
	}
	if(n<0){
		n=abs(n);
		l1=1;
		pri(n);
		
	}else{
		pri(n);
	}
	if(ans!=1e13){
		cout<<ans<<endl;
	}else
		cout<<"none";
}
```

---

## 作者：reinforest (赞：1)

建议评**黄**。

题意：如果整数 $k$ 已知，求满足等式 $k + q^2 = p^2 $ 的自然数 $p$ 的最小值，其中 $q$ 是整数。

对上列式子进行变形可得 $k = (p + q)(p - q)$。

因为 $k,p,q$ 都是整数，所以考虑枚举 $k$ 的所有因数（注意负数）。

设 $k = k_{1} \times k_{2}$，

则有 $$\begin{cases} p + q = k_{1} \\ p - q = k_{2} \end{cases}$$，可以解得 $$\begin{cases} p = \frac{k_{1} + k_{2}}{2} \\ q = \frac{k_{1} - k_{2}}{2} \end{cases}$$。

因此，只需判断 $\frac{k_{1} + k_{2}}{2}$ 是否为自然数即可，如果是，则更新最小值。

注意特判 $k = 0$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll k,ans=1e18;
void upd(ll i){
	ll j=k/i;
	if(i+j>=0 && (i+j)%2==0){
		ans=min(ans,(i+j)/2);
	}	
}
int main(){
	scanf("%lld",&k);
	if(k==0){
		printf("0\n");
		return 0;
	}
	for(ll i=1;i*i<=abs(k);i++)if(abs(k)%abs(i)==0)upd(i),upd(k/i);
	for(ll i=-1;i*i<=abs(k);i--)if(abs(k)%abs(i)==0)upd(i),upd(k/i);
	if(ans<1e18)printf("%lld\n",ans);
	else printf("none\n");
	return 0;
} 
```

---

## 作者：zzwdsj (赞：1)

### 思路
题目转化一下，就变成了求 $x^2+k=y^2$ 的 $y$ 最小正整数解。将这个方程变形一下，得到 $(y-x)(y+x)=k$。将 $k$ 分解为 $p \times q$。则可以列出方程：

$$
\begin{cases}
y-x=p\\
y+x=q
\end{cases}
$$

枚举 $k$ 的所有分解方式，求解后取**合法的** $y$ 的最小值即为答案。
###  code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,ans=LONG_LONG_MAX;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>k;
	for(long long i=1;i*i<=abs(k);i++)
	{
		if(k%i)continue;
		long long x=abs(i+k/i)/2,y=abs(i-k/i)/2;
		if(x*x+k==y*y)ans=min(ans,y);
		swap(x,y);
		if(x*x+k==y*y)ans=min(ans,y);
	}
	if(!k)ans=0;
	if(ans==LONG_LONG_MAX)cout<<"none";
	else cout<<ans;
	return 0;
}
```

---


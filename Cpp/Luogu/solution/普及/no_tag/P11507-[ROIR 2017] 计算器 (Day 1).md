# [ROIR 2017] 计算器 (Day 1)

## 题目背景

翻译自 [ROIR 2017 D1T2](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day1.pdf)。

## 题目描述

今天的信息技术课作业要求设计一个特殊的计算器，该计算器的工作方式如下：

首先，用户输入一个正整数 $n$，该数字会被显示在屏幕上。然后，用户可以按下三个按钮：A，B 和 C。

- 按下按钮 A 时，屏幕上的数字将除以 $2$，向下取整。例如，对于数字 $114$，执行此操作后结果为 $57$；对于数字 $191$，结果为 $95$。
- 按下按钮 B 时，屏幕上的数字加 $1$，然后再除以 $2$，向下取整。例如，对于数字 $114$，执行此操作后结果为 $57$；对于数字 $191$，结果为 $96$。
- 按下按钮 C 时，执行以下操作：如果屏幕上的数字大于 $0$，则减去 $1$ 后除以 $2$，向下取整；如果屏幕上的数字是 $0$，则数字保持不变。例如，对于数字 $114$，执行此操作后结果为 $56$；对于数字 $191$，结果为 $95$。

用户输入了数字 $n$，并将按一定顺序按下操作按钮。具体地，用户将会按下按钮 A 共 $a$ 次，按下按钮 B 共 $b$ 次，按下按钮 C 共 $c$ 次。你需要求出在执行这些操作后最小可能得到的数字是多少。

## 说明/提示

### 样例解释

用户可以依次按下按钮 B，A，C，A，屏幕上的数字将会这样变化：$72\to36\to18\to8\to4$。

### 数据范围

| 子任务 | 分值 | $1\le n\le$ | 其它特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $26$ | $10^9$ | $0\le a+b+c\le7$ |
| $2$ | $23$ | $10^{18}$ | $c=0$ |
| $3$ | $24$ | $10^{18}$ | $b=0$ |
| $4$ | $27$ | $10^{18}$ | 无特殊性质 |

## 样例 #1

### 输入

```
72 2 1 1```

### 输出

```
4```

# 题解

## 作者：bz029 (赞：4)

## 题目分析

有三个操作 A，B 和 C。$n$ 分别需要操作 $a$，$b$ 和 $c$ 次，自由调整操作顺序，使最后 $n$ 最小。

操作 A，使 
$n=\left \lfloor \frac{n}{2} \right \rfloor$。

操作 B，使 
$n=\left \lfloor \frac{n+1}{2} \right \rfloor$。

操作 C，使 
$n=\max(0,\left \lfloor \frac{n-1}{2} \right \rfloor)$。

## 做题思路

这道题先看数据，$a$，$b$ 和 $c$ 不超过 60，如果使用 dfs 暴力，其时间复杂度为 $O(3^{a+b+c})$，达到了 $7 \times 10^{85}$ 级别，只能通过第 1 个子任务。从而我们要使用 dp 来优化递归的过程。

dp 需要存储以下几个信息：

用了 $i$ 次操作 A，用了 $j$ 次操作 B，用了 $k$ 次操作 C 时 $n$ 最小为多少。

由此我们可以推出以下几个状态转移方程：

操作 A：$dp_{i+1,j,k}=\left \lfloor \frac{dp_{i,j,k}}{2} \right \rfloor$。

操作 B：$dp_{i,j+1,k}=\left \lfloor \frac{dp_{i,j,k}+1}{2} \right \rfloor$。

操作 C：$dp_{i,j,k+1}=\max(0,\left \lfloor \frac{dp_{i,j,k}-1}{2} \right \rfloor)$。

初始化：$dp_{0,0,0}=0$，其余为无限大。

目标：$dp_{a,b,c}$。

dp 时间复杂度为：$O((a+b+c) \times a \times b \times c)$。由于 $a$，$b$，$c$ 同级，所以时间复杂度也为：$O(3\times a^4)$。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define int long long //记得开long long,n<=1e18 
using namespace std;

int n,a,b,c,dp[70][70][70];

signed main(){
	cin>>n>>a>>b>>c;
	memset(dp,0x3f,sizeof dp);//初始化为无穷大 
	dp[0][0][0]=n;
	for(int t=1;t<=a+b+c;t++){//一共需要操作a+b+c次 
		for(int i=0;i<=a;i++){
			for(int j=0;j<=b;j++){
				for(int k=0;k<=c;k++){
					if(dp[i][j][k]==dp[65][65][65]) continue;//特判没有转移到的 
					dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]/2);
					dp[i][j+1][k]=min(dp[i][j+1][k],(dp[i][j][k]+1)/2);
					dp[i][j][k+1]=min(dp[i][j][k+1],max((dp[i][j][k]-1)/2,0ll));
				}
			}
		}
	}
	cout<<dp[a][b][c];
	
	return 0;
}
```
管理员大大求过！！！

---

## 作者：glass_goldfish (赞：2)

比较简单的动态规划。 

我们用 $f_{i,j,k}$ 代表使用了 $i$ 次 A 操作，$j$ 次 B 操作，$k$ 次 C 操作之后可以得到的 $n$ 的最小值。很容易得出边界：$f_{0,0,0}=n$。这时因为在没有操作的时候 $n$ 的最小值就是 $n$。

接着，来考虑动态规划主过程：  
每一次要么使用一次 A 操作，要么使用一次 B 操作，要么使用一次 C 操作。如果使用一次 A 操作，那么 $f_{i,j,k}=\lfloor\frac{f_{i-1,j,k}}{2}\rfloor$；如果使用一次 B 操作，那么 $f_{i,j,k}=\lfloor\frac{f_{i,j-1,k}+1}{2}\rfloor$；如果使用一次 C 操作，那么 $f_{i,j,k}=\lfloor\frac{f_{i,j,k-1}-1}{2}\rfloor$。但是，$f_{i,j,k}$ 要取的是最小值，那么说明 $f_{i,j,k}=\min\{\lfloor\frac{f_{i-1,j,k}}{2}\rfloor,\lfloor\frac{f_{i,j-1,k}+1}{2}\rfloor,\lfloor\frac{f_{i,j,k-1}-1}{2}\rfloor\}$（**如果当前没有使用某个操作，那么省去该操作的一步，以免数组越界**）。  

最后的答案就是 $f_{a,b,c}$（因为使用了 $a$ 次 A 操作，$b$ 次 B 操作和 $c$ 次 C 操作）。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1000000000000000001
using namespace std;
int n,a,b,c;
int f[101][101][101];
signed main(){
	cin>>n>>a>>b>>c;
	f[0][0][0]=n;
	for(int i=0;i<=a;i++)
	for(int j=0;j<=b;j++)
	for(int k=0;k<=c;k++){
		if(i==0&&j==0&&k==0)continue;
		int a1=INF,b1=INF,c1=INF;
		if(i!=0)
			a1=f[i-1][j][k]/2;//A操作
		if(j!=0)
			b1=(f[i][j-1][k]+1)/2;//B操作
		if(k!=0)
			c1=(f[i][j][k-1]-1)/2;//C操作
		f[i][j][k]=min(a1,min(b1,c1));//最小值
	}
	cout<<f[a][b][c];//最终答案
	return 0;
}
```

---

## 作者：niuniudundun (赞：1)

# 题目大意

有操作 A、B、C：

- A 操作：$n\gets \left \lfloor \dfrac{n}{2} \right \rfloor $。

- B 操作：$n\gets \left \lfloor \dfrac{n+1}{2} \right \rfloor $。

- C 操作：$n\gets \left \lfloor \dfrac{n-1}{2} \right \rfloor $。

现在有 A、B、C 操作分别有 $a,b,c$ 次，求 $n$ 最小值。

# 解法

考虑贪心。

显然操作可以随便执行，不妨给 $n'$（操作后的 $n$）排个序。

分类讨论：

- $n$ 是奇数，$n+1$ 和 $n-1$ 一定是偶数，可以省去下取整：

  - 所以：$\left \lfloor \dfrac{n+1}{2} \right \rfloor>\left \lfloor \dfrac{n}{2} \right \rfloor>\left \lfloor \dfrac{n-1}{2} \right \rfloor$
 
- $n$ 是偶数，$\dfrac{n}{2}$ 可以省去下取整，$n+1$ 的 $\dfrac{1}{2}$ 一定比另两个大：

  - 所以：$\left \lfloor \dfrac{n+1}{2} \right \rfloor>\left \lfloor \dfrac{n}{2} \right \rfloor>\left \lfloor \dfrac{n-1}{2} \right \rfloor$
 
所以对于 $n$ 来说不论奇偶，这个结论是成立的。

随后贪心思路走起：

既然求最小值，那么尽量让减得多的在后，减得少的在前。

说明只要先把 B 操作用完，再用 A 操作，再用 C 操作就一定最小。

> 证明：
>
> 使用反证法。
>
> 假设贪心解法为 $S$，有另一个解法 $S'$ 可以取得最优，假设 $S'<S$。
>
> 那么 $S=\left \lfloor \dfrac{n+1}{2} \right \rfloor\times \dots \times \left \lfloor \dfrac{n}{2} \right \rfloor \times \dots \times \left \lfloor \dfrac{n-1}{2} \right \rfloor,S'=\left \lfloor \dfrac{n-1}{2} \right \rfloor\times \dots \times \left \lfloor \dfrac{n}{2} \right \rfloor \times \dots \times \left \lfloor \dfrac{n+1}{2} \right \rfloor$。
>
> 即有：
>
> $$
>\begin{aligned}
>S&\ne S'\\
> \left \lfloor \dfrac{n+1}{2} \right \rfloor\times \dots \times \left \lfloor \dfrac{n}{2} \right \rfloor \times \dots \times \left \lfloor \dfrac{n-1}{2} \right \rfloor &\ne \left \lfloor \dfrac{n-1}{2} \right \rfloor\times \dots \times \left \lfloor \dfrac{n}{2} \right \rfloor \times \dots \times \left \lfloor \dfrac{n+1}{2} \right \rfloor \\
>
> \end{aligned}
> $$
>
> 显然 $S$ 和 $S'$ 都是 $a$ 个 A 操作、$b$ 个 B 操作和 $c$ 个 C 操作，所以 $S=S'$，这与原本矛盾，贪心获证。

代码：

复杂度：$O(a+b+c)$。

```cpp
#include<iostream>
using namespace std;
long long n,a,b,c;
int main(){
	cin>>n>>a>>b>>c;
	for(int i=1;i<=b;i++){
		n=(n+1)/2;
	}
	for(int i=1;i<=a;i++){
		n=n/2;
	}
	for(int i=1;i<=c;i++){
		if(n>0) n=(n-1)/2;
	}
	cout<<n<<endl;
	return 0;
}
```

---

## 作者：jojo222 (赞：1)

动态规划，用 $f_{i,j,k}$ 代表了按下 $i$ 次 A 按钮、$j$ 次 B 按钮和 $j$ 次 C 按钮后的最小值，起始状态 $f_{0,0,0}$ 设为 $n$，转移式是 $f_{i,j,k}=\min(\lfloor f_{i-1,j,k}\div2\rfloor,\lfloor(f_{i,j-1,k}+1)\div2\rfloor,\lfloor(f_{i,j-1,k}-1)\div2)\rfloor$，最后答案在 $f_{a,b,c}$ 里。因为是除以 $2$，用位运算更快一些。  
注意：要跳过起始状态和排除数组越界的情况，即 $i$、$j$ 和 $k$ 都等于 $0$，$i=0$、$j=0$ 或 $k=0$。 

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a, b, c;
long long n, f[61][61][61];
int main()
{
    cin >> n >> a >> b >> c;
    f[0][0][0] = n;
    for(int i = 0; i <= a; i++)
    	for(int j = 0; j <= b; j++)
    		for(int k = 0; k <= c; k++)
    		{
				if(i + j + k == 0) continue;
				f[i][j][k] = LLONG_MAX;
				if(i > 0) f[i][j][k] = min(f[i][j][k], f[i - 1][j][k] >> 1);
				if(j > 0) f[i][j][k] = min(f[i][j][k], (f[i][j - 1][k] + 1) >> 1);
				if(k > 0) f[i][j][k] = min(f[i][j][k], (f[i][j][k - 1] - 1) >> 1);
			}
	cout << f[a][b][c];
    return 0;
}
```

---

## 作者：ziyanlin2013 (赞：0)

题目传送门：https://www.luogu.com.cn/problem/P11507

# 简要题意
给定数  $n$ ，共执行  $a,b,c$  次不同 **修改** 操作，求变成的最小值是多少？
# 解题思路
明显的  dp，用类似乌龟棋的操作，设  $f_{i,j,k}$  为用了  $i$  次  $a$  操作， $j$  次  $b$  操作， $k$  次  $c$  操作取到的最小值。转移如下：  
 $f_{i,j,k} \gets \min(f_{i,j,k},\lfloor\frac{f_{i-1,j,k}}{2}\rfloor)$
 
 $f_{i,j,k} \gets \min(f_{i,j,k},\lfloor\frac{f_{i,j-1,k}+1}{2}\rfloor)$ 
 
 $f_{i,j,k} \gets \min(f_{i,j,k},\max(\lfloor\frac{f_{i,j,k-1}-1}{2}\rfloor,0))$
# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=70;
ll n,a,b,c;
ll f[N][N][N];
int main(){
	cin>>n>>a>>b>>c;
	for (int i=0;i<=a;i++){
		for (int j=0;j<=b;j++){
			for (int k=0;k<=c;k++){
				if(i==0&&j==0&&k==0){
					f[i][j][k]=n;
					continue;
				}
				f[i][j][k]=n;
				if(i) f[i][j][k]=min(f[i][j][k],f[i-1][j][k]/2);
				if(j) f[i][j][k]=min(f[i][j][k],(f[i][j-1][k]+1)/2);
				if(k) f[i][j][k]=min(f[i][j][k],max((f[i][j][k-1]-1)/2,0ll));
			}
		}
	}
	cout<<f[a][b][c];
	return 0;
}
```

---

## 作者：yi_hr (赞：0)

## 题意说明
- **按钮 A:** 将当前数字除以 $2$ 并向下取整。  
- **按钮 B:** 将当前数字加 $1$ 后再除以 $2$ 并向下取整。  
- **按钮 C:** 如果当前数字大于 $0$，则将其减 $1$ 后除以 $2$ 并向下取整；否则保持不变。  
## 思路
我们考虑记忆化搜索。   

我们定义 `dfs(n, a, b, c)`，它表示在当前数字为 $n$，剩余按下按钮 A、B、C 的次数分别为 $a$、$b$、$c$ 时，能够达到的最小数字。  

用 `unordered_map` 实现记忆化。  

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
struct node{
    ll n;
    int a,b,c;
    bool operator<(const node& other) const {
        return tie(n, a, b, c) < tie(other.n, other.a, other.b, other.c);
    }
    bool operator==(const node& other) const {
        return tie(n, a, b, c) == tie(other.n, other.a, other.b, other.c);
    }
};
struct Hash{
    size_t operator()(const node& s) const {
        return hash<ll>()(s.n)^(hash<int>()(s.a)<<1)^(hash<int>()(s.b)<<2)^(hash<int>()(s.c)<<3);
    }
};
unordered_map<node,ll,Hash> f;
ll dfs(ll n, int a, int b, int c){
    if(a==0&&b==0&&c== 0){
        return n;
    }
    node cnt={n,a,b,c};
    if(f.find(cnt)!=f.end()){
        return f[cnt];
    }
    ll minn=INF;
    if(a>0){
        ll val=n/2;
        minn=min(minn,dfs(val,a-1,b,c));
    }
    if(b>0){
        ll val=(n+1)/2;
        minn=min(minn,dfs(val,a,b-1,c));
    }
    if(c>0){
        ll val;
        if(n>0){
            val=(n-1)/2;
        }else{
			val=n;
        }
        minn=min(minn,dfs(val,a,b,c-1));
    }
    f[cnt]=minn;
	return minn;
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    ll n;
    int a,b,c;
    cin>>n>>a>>b>>c;
    cout<<dfs(n,a,b,c);
}

```

---


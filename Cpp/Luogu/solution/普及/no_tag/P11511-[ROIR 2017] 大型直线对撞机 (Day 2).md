# [ROIR 2017] 大型直线对撞机 (Day 2)

## 题目背景

翻译自 [ROIR 2017 D2T2](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day2.pdf)。

## 题目描述

科学家在一个国际科学实验室里进行研究，研究的是粒子在大型直线对撞机（简称：BLC）实验装置中的行为。BLC 呈一条直线，粒子被放置在这条直线上的某些点上，粒子可以沿着这条直线移动。

在本次实验中，BLC 上放置了 $n$ 个粒子，每个粒子要么是带一个单位负电荷的电子（$e^-$），要么是带一个单位正电荷的正电子（$e^+$）。第 $i$ 个粒子最初被放置在坐标 $x_i$ 的位置。实验开始后，粒子会沿直线向不同的方向移动：$e^-$ 沿负方向移动，而 $e^+$ 则沿正方向移动。所有粒子的速度绝对值相同，均为 $1$。

如果在移动过程中，$e^-$ 和 $e^+$ 在某一位置碰撞，它们会相互作用并湮灭。它们的湮灭不会影响其他粒子的行为。

科学家们选择了 $m$ 个不同的时间点 $t_1, t_2, \dots, t_m$ 对 BLC 中的粒子进行观测。对于每个时间点，他们希望知道，在每个时间点之后，BLC 还剩下多少个粒子。时间从 $0$ 开始。恰好在观测的时间点湮灭的粒子不应被计入粒子总数。

你需要编写一个程序，根据粒子的初始位置和类型，以及给定的观测时间点，来计算每个时间点后 BLC 中剩余的粒子数。

## 说明/提示

### 样例解释

在样例中，初始时 BLC 中有 4 个粒子：一个 $e^+$ 粒子在坐标 $-1$，一个 $e^-$ 粒子在坐标 $0$，一个 $e^+$ 粒子在坐标 $1$，一个 $e^-$ 粒子在坐标 $5$。

- 在时间 $0.5$ 时，第一个 $e^+$ 粒子和第一个 $e^-$ 粒子碰撞，在坐标 $-0.5$ 处湮灭。
- 在时间 $1$ 时，剩余的两颗粒子在坐标 $2$ 和 $4$。
- 在时间 $2$ 时，这两个粒子在坐标 $3$ 处碰撞并湮灭。
- 在时间 $3$ 时，BLC 中没有剩余粒子。

### 数据范围

| 子任务 | 分值 | $1\le n\le$ | $\vert x_i\vert\le$ | $1\le m\le$ | $0\le t_i\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $100$ | $100$ | $1$ | $100$ |
| $2$ | $12$ | $100$ | $10^9$ | $1$ | $10^9$ |
| $3$ | $12$ | $200000$ | $10^9$ | $1$ | $10^9$ |
| $4$ | $41$ | $200000$ | $10^9$ | $200000$ | $10^9$ |

## 样例 #1

### 输入

```
4
-1 1
0 -1
1 1
5 -1
4
0 1 2 3```

### 输出

```
4
2
0
0```

# 题解

## 作者：ny_jerry2 (赞：4)

好题一道。

我们可以开一个栈，然后倒序枚举一下，遇到一个倒着走的粒子，就压入栈。否则，这个正着走的粒子就与栈顶组合。显然，这样是对的。

然后用双指针或二分技术就好了。

```cpp
#include<iostream>
#include<stack>
#include<algorithm>
using namespace std;
int n,m;
const int N=5e5+10;
int x[N],type[N];
int t[N],tim[N];
stack<int> st;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x[i],&type[i]);
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		scanf("%d",&t[i]);
	}
	for(int i=n;i;i--){
		if(type[i]==-1){
			st.push(i);
		}else{
			if(st.empty()){
				continue;
			}
			int d=st.top();
			tim[i]=tim[d]=(x[d]-x[i]+1)/2;
			st.pop();
		}
	}
	for(int i=1;i<=n;i++){
		if(!tim[i]){
			tim[i]=2e9;
		}
	}
	sort(tim+1,tim+n+1);
	int j=0;
	for(int i=1;i<=m;i++){
		while(j<n&&tim[j+1]<=t[i]){
			j++;
		}
		printf("%d\n",n-j);
	}
}
```

---

## 作者：duanxinghe (赞：3)

# 洛谷 P11511 [ROIR 2017 Day 2] 大型直线对撞机题解

## 题目概括：
在一根无限长的数轴上，有 $n$ 个粒子，它们各有两种状态，分别是正负两种，正电子向数轴正方向运动，负电子像数轴负方向运动，速度都为 $1$。当正电子和负电子相撞，则会消失。问：当 $t_i$ 秒时，数轴上还有多少粒子。

## 分析：
由于 $x_i$ 的给出是单调递增的，所以我们不难发现，输入时，若是一个负电子，那么与它最先发生碰撞的就是离它最近的被输入进来的正电子，那么我们就一定知道每个粒子消失的时间（如果它会消失的话）。

那么如何维护呢？那当然会想到栈，每次遇到一个正电子就将它放进栈中，那么在栈顶的一定就是后输入进来的正电子，每输入一个负电子我们就将栈顶的正电子弹出去，然后计算它们的相撞时间 $a_i$。

设栈顶元素坐标为 $x_j$，当前元素坐标为 $x_i$。

---


$a_i = \frac{x_i - x_j + 1}{2}$


---


最后进行模拟，先将 $a_i$ 数组从小到大进行排序，定义一个标记变量 $now$ 表示枚举到 $a$ 数组的第 $now$ 位，如果 $a$ 数组的第 $now$ 位 $\le t_i$ 就说明这两个粒子在 $t_i$ 前就已经被消失了，所以 $now$ 就往后移，同时答案减 $1$。

由于有些粒子从一开始就不会被消失，所以就设它们的时间为**无穷大**。

## 代码：
说明：我的代码是看了这位大佬的[题解](https://www.luogu.com.cn/article/ceynsfrc)，至于我的代码，也不知道什么原因惨痛爆 $0$，所以代码在此就不放了。

---

## 作者：水星湖 (赞：3)

我们把 $e^+$ 看作左括号，$e^-$ 看作右括号，这形成了一个括号序列。显然第 $i$ 个和第 $j(i<j)$ 个粒子会相撞当且仅当两个括号在括号序列中匹配，且可以认为它们会在 $\left[\frac{x_j-x_i+1}{2}\right]$ 时刻相撞。算出每个电子相撞时间后咋做就都行了。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

#define int long long
const int N = 5e5 + 5;
#define x first
#define v second
pair<int, int> a[N];
stack<int> s;
int t[N];
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    int n; cin >> n;
    for(int i = 1; i <= n; i++) 
        cin >> a[i].x >> a[i].v;
    memset(t, 0x3f, sizeof(t));
    for(int i = 1; i <= n; i++) {
        if(a[i].v == 1) s.push(i);
        else {
            if(s.empty()) continue;
            int j = s.top(); s.pop();
            t[i] = t[j] = (a[i].x - a[j].x + 1) / 2;
        }
    }
    sort(t + 1, t + n + 1);
    int j = 0, m, ans = n; cin >> m;
    while(m--) {
        int tt;
        cin >> tt;
        while(j < n && t[j + 1] <= tt) j++, ans--;
        cout << ans << '\n';
    }
}

#undef int

}


int main()
{
    z::main();
    return 0;
}
```

---

## 作者：Pratty (赞：2)

在此题卡了好久之后，我终于 A 了它。

在正文开始之前，先来一警钟：在使用位运算符号时，一定要加括号！

这道题算是一道中等难度的黄题，还是很适合练手的。

闲言少叙，题解继续。

## 题意

题目给出一定数量的粒子，这些粒子分为两种：正电荷粒子（简称正电子）和负电荷粒子（简称负电子），分别用 $e^+$ 和 $e^-$ 来表示。

负电子向负方向运动，正电子相反，所有电子每 $1$ 秒运动一个单位。每当两个电子相互碰撞时，就会一起消失，现在给出 $m$ 次询问：请求出对于每一个时间点 $t_i$ 之后，剩余电子的数量。

## 思路

按顺序考虑题意。

如果我们能知道所有电子相互碰撞的时间，并存入数组 $ans$，那我们就可以在每一次询问时通过二分计算出剩余电子的数量了，考虑怎么计算出所有电子相互碰撞的时间。

我们可以通过一定的数据模拟发现以下规律：

- 所有电子无非两种结果，要么在碰撞中消失，要么持续向一个方向运动不会消失。
- 只有在数轴最左侧的负电子和在数轴最右侧的正电子持续运动不会消失，其他电子一定会相互碰撞。

考虑用栈记录正电荷的运动时间。

若我们开设一个栈，遇到 $e^+$ 就存入当前位置；遇到 $e^-$ 则进行判断：

- 若栈为空，则说明这个电子不会发生碰撞，用一个变量单独记录。
- 若栈非空，则说明这个电子一定会碰撞，且一定和栈顶元素碰撞，即可计算出两电子碰撞的位置。

特殊的，两电子碰撞可能处于小数位置。因为每一次查询的是 $t_i$ 之后有多少个电子存在，所以可以直接向上取整。

于是我们得出以下代码：

```c++
int f = st.top();
st.pop();
ans[++cnt] = ceil(1.0 * (x[i] - f) / 2);
```
栈 $st$ 记录了上一个 $e^+$ 的位置，每当遇到一个 $e^-$，就计算碰撞的位置，存入 $ans$ 数组，有点类似于括号匹配。

最后需要注意，$ans$ 数组不一定单调递增，所以需要排序。

完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 210000;
int extra, cnt;
int n, x[N], v[N];
int ans[N], t, m;
stack<int> st;
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", &x[i], &v[i]);
		if (v[i] == -1) {
			if (st.empty()) {
				extra++;
				continue;
			}
			int f = st.top();
			st.pop();
			ans[++cnt] = ceil(1.0 * (x[i] - f) / 2);
		} else {
			st.push(x[i]);
		}
	}
	extra += st.size();
	sort(ans + 1, ans + cnt + 1);
	scanf("%d", &m);
	for (int i = 1; i <= m; i++) {
		scanf("%d", &t);
		if (t >= ans[cnt]) {
			//使用upper_bound前先特判 
			printf("%d\n", extra);
			continue;
		}
		int tmp = upper_bound(ans + 1, ans + cnt + 1, t) - ans;
		printf("%d\n", extra + ((cnt - tmp + 1) << 1));
	}
	return 0;
}
```

以上就是这道题目的解法了，总结下：难而不失分寸，易而不缺挑战。这道题，推荐给普及组的选手们。

---

## 作者：Tracy_Loght (赞：1)

~~易证得，本题配对跑暴力可以过，完结。~~

## 题目描述：

负电荷的电子统称**负电**，正电荷的电子统称**正电**。

你是一个黑鬼，但不是 zqq。

你知道有一堆电子，他们有正~~男~~有负~~女~~，你要充当~~月老~~，他们的喜欢方式类似于括号匹配。

正~~男~~为左括号，负~~女~~为右括号。

有一堆柯学家要你判断在 $x$ 秒的时候，场上还有多少电子单身。

## 拯救电子计划：

容易想到一个方法：

- 遇到正电，存储起来，记下他的位置；

- 对于负电，判断数组内是否还有正电，如果有就计算他们灭亡的时间，否则跳过（~~这预示着一条单身狗的产生~~）。

**灭亡时间**：对于在 $a$ 点的正电和在 $b$ 点的负电，答案是 $\frac{b - a}{2}$。

容易发现，对于这种情况，我们所计算的灭亡时间是不连续的，及在第 $k$ 秒，有两次灭亡，一次在上述计算的前面，一次在很后面，无法直接进行比较。

然后就以灭亡时间为关键字排序，然后合并相同灭亡时间的电子。

现在我们就得到了这样的一组信息（$t$ 从小到大）：

- 对于第 $t$ 秒，又有 $x$ 个电子灭亡。

---

最后对输入的观测时间一一对应，及枚举观测时间，对于每个观测时间，判断是否在第 $v$ 个信息内，然后算答案。

千万要注意电子没法匹配的时候，记得特判。

---

## 作者：LionBlaze (赞：1)

我们可以以一种清奇的角度看问题：

把它转化为括号匹配的问题。$e^+$ 代表左括号，$e^-$ 代表右括号。

比如，样例就可以转化为这样一个括号序列：

```cpp
...()(...)...
```

理论上，左右两边是无限长的。但是我们不需要那么长。

我们可以扫一遍，用一个栈预处理出每一个左括号或右括号湮灭的时间，然后使用二分求解答案。

具体地来讲，在栈中存放左括号的 id，遇到一个左括号就入栈，遇到右括号就这样：

1. 如果栈空：那么这个右括号湮灭的时间为正无穷，因为它不会湮灭。事实上，在写代码时，为了方便，直接当做它不存在。
2. 如果栈不空：取出栈顶元素，根据 id 查出位置 $x_1$，设当前右括号的位置为 $x_2$，设置它们湮灭的时间为 $\dfrac{x_2-x_1}{2}$。事实上，在写代码时，为了方便，会向上取整，也就是 $\left\lfloor\dfrac{x_2-x_1+1}{2}\right\rfloor$。

然后，把每个粒子湮灭的时间排序，然后使用二分查找查找出最后一个不在 $t$ 时刻之后湮灭的粒子，其下标就是答案。在写代码时，如果是 C++，可以使用 STL 的 `<algorithm>` 头文件中的 `upper_bound` 函数解决。

总时间复杂度 $\mathcal O((n+m) \log n)$，其中 $\Theta(n \log n)$ 是排序时间复杂度，$\mathcal O(m \log n)$ 是回答询问的时间复杂度，而预处理的时间复杂度 $\Theta(n)$ 是可以忽略不计的，因为有一个严格大于其的 $\Theta(n \log n)$。

---

## 作者：_Oak (赞：1)

先根据样例画出图：
![](https://cdn.luogu.com.cn/upload/image_hosting/1qau6wja.png)
可以很容易地得到：一个向右的粒子只能与其右侧最近的向左的粒子（中间无其他向右的粒子）相碰撞消失 ，一个向左的粒子只能与其左侧最近的向右的粒子（中间无其他向左的粒子）相碰撞消失       

这样我们就能够利用栈来计算出一组粒子碰撞消失的时间和是第几组碰撞消失的粒子。题目输入时间，要求输出当前存在的粒子数，可以对一组粒子碰撞消失的时间排序，再用**二分**求出在这个时间节点前一组碰撞消失的粒子是第几组消失的，就能求出当前存在的粒子数了。

细节见代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int m;
struct node {
	int x;
	int v;
} a[200005];
int t[200005];
bool cmp(node A, node B) {
	return A.x < B.x;
}
stack<int> s;
double bj[200005];//bj[i]表示第i组碰撞消失的粒子消失的时间 
int cnt;//所有能碰撞消失的粒子的总数 
int find(int x) {
	int l = 0;
	int r = cnt;
	int ans = 0;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (bj[mid] <= x) {
			ans = mid;
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].x >> a[i].v;
	}
	sort(a + 1, a + 1 + n, cmp);
	cin >> m;
	for (int i = 1; i <= n; i++) {
		if (a[i].v == -1) {
			if (!s.empty()) {
				++cnt;
				double time = (1.0 * a[i].x - 1.0 * s.top()) / 2.0;
				bj[cnt] = time * 1.0;
				s.pop();
			}
		} else {
			s.push(a[i].x);
		}
	}
	sort(bj + 1, bj + 1 + cnt);
	for (int i = 1; i <= m; i++) {
		cin >> t[i];
		int pos = find(t[i]);
		cout << n - pos * 2 << '\n';
	}

	return 0;
}
```

---

## 作者：songzhixin (赞：1)

### 题意

粒子分为两种，一种向左做匀速直线运动，一种向右做匀速直线运动

两颗粒子相遇就会消失，问某一个时刻会剩下几个粒子。

### 思路

对于每一个向左运动的粒子，要么它永远不会消失（抵消后左边无向右运动的粒子），或与最靠右边的向右运动的粒子抵消，我们可以记录这一个抵消的时间。

那么如何求它与哪个粒子抵消呢？其实可以发现，每一颗向左运动一定是与最靠右边的向右运动的粒子抵消，因为每一颗粒子运动速度相同，则左边的粒子始终在右边的粒子的左侧。我们需要一种加入，删除，求最左侧数的数据结构。我们可以用~~线段树~~栈来实现，因为这满足先进后出。

每次询问可以用一个指针去找到第一个比它大的时间节点，因为时间具有单调性，所以这个节点也具有单调性。

注意记录时间的数组开成浮点数类型，并且要排序。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=200005;
long long a[N];
double t[N];
long long b[N];
int main(){
	long long n;
	scanf("%lld",&n);
	long long x=0;
	long long cnt=0,sum=0;
	for(long long i=1;i<=n;i++){
		long long y,v;
		scanf("%lld%lld",&y,&v);
		if(v==1){
			b[++sum]=y;
		}
		else{
			if(sum==0){
				continue;
			}
			long long c=b[sum];
			sum--;
			c=y-c;
			if(c>=0){
				t[++cnt]=c*1.0/2;
			}
		}
	}
	long long m;
	scanf("%lld",&m);
	long long ans=0;
	long long l=1;
	sort(t+1,t+1+cnt);
	for(long long i=1;i<=m;i++){
		long long q;
		scanf("%lld",&q);
		while(l<=cnt){
			if(t[l]<=(double)q){
				l++;
				ans+=2;
			}
			else{
				break;
			}
		}
		printf("%lld\n",n-ans);
	}
	return 0;
}
```

---

## 作者：ny_Dacong (赞：1)

# 思路

首先，每个点的堙灭时间可以提前算出来。思路可以参考括号匹配，用栈来维护。

如果两个粒子面对面，那么它们就会相撞。设它们的坐标分别为 $x,y$，那么堙灭的时间为 $\frac{|x-y|}{2}$。

因为本题查询的时间为整数，所以如果堙灭的时间是小数，我们向上取整。

然后查询就转化为：有多少个粒子的寿命在 $t_i \sim \infty$ 的时间内？所以想到在值域上建立线段树，维护数量即可。

注意寿命可能会很大，所以离散化一下。而且恰好在观测的时间点湮灭的粒子不应被计入粒子总数，所以 $t_i$ 应该往后挪一个数。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
const long long inf = 0x3f3f3f3f3f3f3f3f;
stack<long long> que;
struct node{
	long long pos,Way,Life;
}num[200050];
vector<long long> Old;
long long tree[200050<<2];
long long ls(long long x){
	return x<<1;
}
long long rs(long long x){
	return x<<1|1;
}
void push_up(long long p){
	tree[p] = tree[ls(p)]+tree[rs(p)];
	return;
}
void modify(long long p,long long pl,long long pr,long long opt){
	if(pl == pr){
		tree[p]++;
		return;
	}
	long long mid = pl+((pr-pl)>>1);
	if(opt <= mid){
		modify(ls(p),pl,mid,opt);
	}else{
		modify(rs(p),mid+1,pr,opt);
	}
	push_up(p);
	return;
}
long long query(long long p,long long pl,long long pr,long long l,long long r){
	if(l <= pl && pr <= r){
		return tree[p];
	}
	long long mid = pl+((pr-pl)>>1),res = 0;
	if(l <= mid){
		res += query(ls(p),pl,mid,l,r);
	}
	if(mid < r){
		res += query(rs(p),mid+1,pr,l,r);
	}
	return res;
}
int main(){
	scanf("%lld",&n);
	for(long long i = 1; i <= n; i++){
		scanf("%lld%lld",&num[i].pos,&num[i].Way);
		num[i].Life = inf;
		if(num[i].Way == 1){
			que.push(i);
		}else{
			if(que.size()){
				num[i].Life = num[que.top()].Life = (abs(num[i].pos-num[que.top()].pos)+1)>>1;
				que.pop();
			}
		}
	}
	Old.push_back(-inf);
	Old.push_back(inf);
	for(long long i = 1; i <= n; i++){
		Old.push_back(num[i].Life);
	}
	sort(Old.begin(),Old.end());
	Old.erase(unique(Old.begin(),Old.end()),Old.end());
	for(long long i = 1; i <= n; i++){
		num[i].Life = lower_bound(Old.begin(),Old.end(),num[i].Life)-Old.begin();
		modify(1,1,Old.size()-1,num[i].Life);
	}
	scanf("%lld",&m);
	for(long long i = 1; i <= m; i++){
		static long long tp;
		scanf("%lld",&tp);
		tp = upper_bound(Old.begin(),Old.end(),tp)-Old.begin();
		printf("%lld\n",query(1,1,Old.size()-1,tp,Old.size()-1));
	}
	return 0;
}
```

---

## 作者：yi_hr (赞：1)

## 题目要求
### 1. 粒子的运动与湮灭
- **粒子的类型与运动方向**：
  - 电子 （$e^-$）：带有一个单位负电荷，沿负方向（坐标递减）移动。
  - 正电子 （$e^+$）：带有一个单位正电荷，沿正方向（坐标递增）移动。
- **湮灭条件**：
  - 一个 $e^-$ 和一个 $e^+$ 在运动过程中相遇，即它们在某个坐标点同时出现，此时它们会湮灭。
  - 湮灭不会影响其他粒子的运动。
### 2. 计算湮灭时间
对于每对可湮灭的 $e^+$ 和 $e^-$，我们需要计算它们的湮灭时间 $t_{\text{collide}}$：
$$t_{\text{collide}}=\frac{x_i-x_j}{2}$$
其中：
- $x_j$ 是 $e^+$ 的初始位置，$x_i$ 是 $e^-$ 的初始位置，且 $x_j<x_i$。
### 3. 匹配粒子
为最大化湮灭的粒子数量，我们考虑贪心：
- 从左到右遍历粒子。
- 遇到 $e^+$ 时，将其压入栈中。
- 遇到 $e^-$ 时，如果栈不为空，则将栈顶的 $e^+$ 与当前 $e^-$ 配对，并计算湮灭时间。
### 4. 处理观测时间点
- 将所有湮灭时间存储在一个数组中，并排序。
- 对于每个观测时间点 $t_k$，计算有多少对粒子的湮灭时间小于等于 $t_k$。
- 剩余粒子数量为：$n-2\times(\text{湮灭对数})$。
## 具体实现
1. **粒子匹配和湮灭时间计算**：
   - 使用栈匹配每个 $e^-$ 与最近的未匹配的 $e^+$。
   - 计算湮灭时间，并存在数组里，之后排序。
2. **处理观测时间**：
   - 对每个观测时间点，二分查找确定有多少对粒子的湮灭时间小于等于该时间点。
   - 计算剩余粒子数量。
3. **优化**：
   - 为避免精度问题，我们将所有湮灭时间乘以 $2$，转化为整数进行比较。
## 代码实现
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e6+9;
ll n,m,t[N],ans[N];
pair<ll,int> a[N];
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;    
    for(int i=0; i<n; ++i){
        cin>>a[i].first>>a[i].second;
    }
    vector<ll> v1,v2;
    for(int i=0;i<n;++i){
        ll x=a[i].first;
        int v=a[i].second;
        if(v==1){
            v1.push_back(x);
        }else if(v==-1){
            if(!v1.empty()){
                ll p=v1.back();
                v1.pop_back();
                ll cnt=x-p;
                if(cnt>=0){
                    v2.push_back(cnt);
                }
            }
        }
    }
    sort(v2.begin(),v2.end());
    cin>>m;
    for(int i=0;i<m;++i){
        cin>>t[i];
    }
    for(int i=0;i<m;++i){
        ll s=2*t[i];
        ll cnt=upper_bound(v2.begin(),v2.end(),s)-v2.begin();
        ans[i]=n-2*cnt;
    }
    for(int i=0;i<m;++i){
        cout<<ans[i]<<"\n";
    }
    return 0;
}
```

---

## 作者：jojo222 (赞：1)

这个是粒子消消乐，可以用栈来做。

先从按位置小到大排序，在维护一个栈。遇到一个 $e^+$，推入栈；遇到一个 $e^-$，把栈顶拿出来一起消消乐，相遇时间是 $e^-$ 位置减去 $e^+$ 位置的和除以 $2$，记录下消除的时间。  
接着将每次消除排序，在询问的时候就能二分解答了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, t;
stack<int> s;
vector<int> ans;
struct node
{
    int x, v;
    bool operator<(const node &a) const
        {return x < a.x;}
} a[200001];
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
        scanf("%d%d", &a[i].x, &a[i].v);
    sort(a + 1, a + 1 + n);
    for(int i = 1; i <= n; i++)
        if(a[i].v == 1) s.push(a[i].x);
        else if(!s.empty()) ans.push_back(a[i].x - s.top()), s.pop();
    sort(ans.begin(), ans.end());
    cin >> m;
    while(m--)
    {
        scanf("%d", &t);
        printf("%d\n", n - (upper_bound(ans.begin(), ans.end(), t * 2) - ans.begin()) * 2);
    } 
    return 0;
}
```

有人可能会问了，为什么计算距离的时候没有除以 $2$？因为不想出现小数。二分的时候将 $t$ 乘了 $2$ 就修正问题啦！

---

## 作者：xuyifei0302 (赞：1)

这道题，我们只需处理出所有可能对撞的粒子湮灭的时间，由于肯定是相互最近的反方向粒子对撞，所以我们就可以用栈去维护目前最近的反方向的粒子。最后给这些时间排一个序，在查找时间的时候二分查找即可。

下面附上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Node {
	int x, v;
} a[200005];
int n, m, t[200005], ans, sum[200005], num[200005], cnt;
stack<int> st;
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i].x >> a[i].v;
		if (a[i].v == -1) {
			if (st.empty()) {
				ans ++;
			} else {
				int tmp = st.top();
				st.pop();
				num[++cnt] = (a[i].x - a[tmp].x) / 2;
				if ((a[i].x - a[tmp].x) % 2 == 1) {
					num[cnt] ++;
				}
				sum[cnt] = num[cnt];
			}
		} else {
			st.push(i);
		}
	}
	while (!st.empty()) {
		ans ++;
		st.pop();
	}
	sort(sum + 1, sum + 1 + cnt);
	cin >> m;
	for (int i = 1; i <= m; i ++) {
		cin >> t[i];
		if (t[i] >= sum[cnt]) {
			cout << ans << "\n";
			continue;
		}
		int j = upper_bound(sum + 1, sum + 1 + cnt, t[i]) - sum;
		cout << ans + (cnt - j + 1) * 2 << "\n";
	}
	return 0;
}
```

---

## 作者：_xdd_ (赞：0)

怎么信奥题都有模板题改新课标了。

其实就是一个括号匹配，也就是把正粒子看成左括号，负粒子看成右括号，每次匹配上就计算出撞击时间，具体的，设撞击的两个粒子位置分别为 $x,y$，撞击时间为 $(x-y+1)\div2$。

然后对每次个查询，直接排除撞击时间小于查询时的粒子，剩下的即为答案。


```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define maxn 500000+5
//#define int long long
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
stack<pair<int,int>>s;
int n,m,t,a[maxn];
int main(){
    cin >> n;
    memset(a,0x3f,sizeof(a));
    for(int i=1;i<=n;i++){
        int x,y;
        cin >> x >> y;
        if(y==1){
            s.push(make_pair(x,i));
        }else{
            if(s.empty()){
                continue;
            }
            int v=s.top().first,j=s.top().second;
            s.pop();
            a[i]=a[j]=(x-v+1)/2;
        }
    }
    sort(a+1,a+n+1);
    cin >> m;
    int x=0,ans=n;
    for(int i=1;i<=m;i++){
        cin >> t;
        while(x<n&&a[x+1]<=t){
            x++;
            ans--;
        }
        cout << ans << endl;
    }
}
```

---

## 作者：rainbow_cat (赞：0)

我们显然考虑括号序列，向右为 `(`，向左为 `)`，假设第 $i$ 个和第 $j$ 个相遇，则时间为 $\frac{x_i-x_j}{2}$，将所有时间存入数组后排序。     
查询的时候维护一个指针即可，时间复杂度为 $O(n \log n)$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,q,idx,now=1,ans;
double t[200010];
struct node{int x,op;}a[200010];
stack<node>s;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	ans=n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x>>a[i].op;
		if(s.size()&&((s.top().op==1&&a[i].op==-1)))
		{
			t[++idx]=1.0*(a[i].x-s.top().x)/2;
			s.pop();
		}
		else s.push(a[i]);
	}
	sort(t+1,t+idx+1);
//	for(int i=1;i<=idx;i++)cout<<t[i]<<' ';
//	cout<<'\n';
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>q;
		while(now<=idx&&t[now]<=q)ans-=2,now++;
		cout<<ans<<'\n';	
	}
	return 0;
}
/*
Happy birthday to lzm0107!!!
*/
```

---


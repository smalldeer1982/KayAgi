# [Code+#5] 逻辑树

## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。



## 题目描述

有一棵树，叫逻辑树。

这个树有根，有 $2N-1$ 个节点，其中 $N$ 个叶子，每个非叶节点恰好有两个孩子。

每个叶子上有一个 01 变量，它的取值可能为 True 或 False。每个非叶节点上有一个逻辑运算符，这个运算可能为 AND 或者 OR。

一个非叶节点的取值定义为它两个儿子的取值，作这个节点上的运算得到的结果。

有一个黑恶势力想知道这个树的根节点的取值，他准备了一个长度为 $N$ 的询问序列 $\{P_i\}$，每个叶子在这个序列中恰好出现一次。

黑恶势力会依次询问这些叶子的值，**但是**，如果他发现某一次询问是不必要的，那么他会跳过这个无意义的询问（为了帮助理解，考虑 x AND y 在我们知道 x 为 False 之后，不必知道 y 的值就可推算 x AND y 的值）。

当然，邪恶总是能战胜正义，黑恶势力总能达到他的目的。但是我们可以拖慢他的节奏，你现在可以安排每个叶子的权值，使得黑恶势力询问的次数尽可能多，在此基础上，我们希望这个树的根节点取值尽量为 True。

请你计算一组解，任何一种合法方案都是可以接受的。

## 说明/提示

**数据范围：**

$\def\arraystretch{1.21}
\begin{array}{|c|c|c|}\hline
\bold{\small{子任务}}&\textbf{score}&\textbf{constraints}\\\hline
\text{A}&40&\small{树的高度不超过 50}\\\hline
\text{B}&60&\small{无特殊限制}\\\hline
\end{array}$

对于所有数据，$N\le 5\times 10^5$。

对于所有数据，保证 $1\le m<n\le1000$，$1\le k\le10000$，$1\le p_i\le n,1\le x_i\le m$，$p_i$ 互不相等。


## 样例 #1

### 输入

```
4
0 1 0
5 6
5 7
6 1
6 2
7 3
7 4
4 2 3 1
```

### 输出

```
1011```

# 题解

## 作者：FallingFYC_ (赞：0)

[P11540 [Code+#5] 表达式二叉树填数](https://www.luogu.com.cn/problem/P11540)

---
### 分析

对于一个 01 未知数 $x$，显然有 $0 \operatorname{AND} x=0$，$1 \operatorname{OR} x=1$，不能通过 $1 \operatorname{AND} x=y$ 或 $0 \operatorname{OR} x=y$ 来得出 $y$ 的值。

---
### 思路

考虑贪心。

假设询问 $P_i$ 的时间为 $i$，定义一个节点 $A$ 的 $t_A$ 为：
$$t_A=\begin{cases}
\max(t_{A的左儿子},t_{A的右儿子}) & A不为叶子节点 \\
i & A=P_i
\end{cases}$$

$t_A$ 的意义为节点 $A$ 在最坏情况下获得取值的时间。

所以对于一个非叶节点 $B$：
  - 如果它的逻辑运算符为 $\operatorname{AND}$，则它的两个子结点中 $t$ 较小的一个的取值为 $1$，另一个与 $B$ 取值相同。
  - 如果它的逻辑运算符为 $\operatorname{OR}$，则它的两个子结点中 $t$ 较小的一个的取值为 $0$，另一个与 $B$ 取值相同。

两遍 dfs 分别得到 $t$ 和结果即可。

注意题目让根节点为 $1$。

---
### 代码

```cpp
#include <bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REV(i,a,b) for(int i=a;i>=b;i--)
#define psbk push_back
#define mkp make_pair
#define endl '\n'
typedef long long ll;
using namespace std;
const int N=5e5+5;
int n,ask[N<<1],ans[N<<1];
vector<int> e[N<<1];
bool bk[N<<1],op[N];
void dfs1(int u){
    bk[u]=1;
    if(u<=n)return;
    for(auto v:e[u])
        if(!bk[v]){
            dfs1(v);
            ask[u]=max(ask[u],ask[v]);
        }
}
void dfs2(int u){
    bk[u]=1;
    if(u<=n)return;
    int mint=1e9,minp;
    for(auto v:e[u])
        if(!bk[v]&&ask[v]<mint)mint=ask[v],minp=v;
    ans[minp]=(op[u-n]?0:1);
    for(auto v:e[u])
        if(!bk[v]){
            if(v!=minp)ans[v]=ans[u];
            dfs2(v);
        }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    FOR(i,1,n-1)cin>>op[i];
    FOR(i,1,2*n-2){
        int u,v;
        cin>>u>>v;
        e[u].psbk(v),e[v].psbk(u);
    }
    FOR(i,1,n){
        int u;
        cin>>u;
        ask[u]=i;
    }
    dfs1(n+1);
    memset(bk,0,sizeof bk);
    memset(ans,0x3f,sizeof ans);
    ans[n+1]=1;
    dfs2(n+1);
    FOR(i,1,n)cout<<ans[i];
    return 0;
}
```

---


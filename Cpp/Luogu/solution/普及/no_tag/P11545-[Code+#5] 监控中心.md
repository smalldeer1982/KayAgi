# [Code+#5] 监控中心

## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。

## 题目描述

随着战争的推进，C 国已经在 D 国的 $n$ 个城市中的每个城市，都至少建立了一个情报中心。除此之外，TAC 规划了 $m$ 条双向的信息传输通道，其中第 $i$ 条形如 $(a_i,b_i)$，表示在城市 $a_i$ 和城市 $b_i$ 之间可以直接传递、交换情报。经过合理规划，任意两个城市之间都可以直接或间接地传递情报。

然而 D 国的军队也不是吃素的。在军队的秘密围剿下，一些城市的情报中心可能会被歼灭而失效。如果一个城市 $c$ 的情报中心失效了，那么所有和 $c$ 有传输通道的、还未失效的城市将会无法发送情报，总而将这条错误信息报告到总部。即如果有一条形如 $(a,b)$ 的传输通道，那么就会有这样四种情况：

- $a$ 和 $b$ 的情报中心同时有效，那么传输正常，没有错误信息；

- $a$ 的情报中心有效而 $b$ 的情报中心被歼灭，则 $a$ 的情报中心会报告“无法给 $b$ 发送信息”的错误信息；

- $b$ 的情报中心有效而 $a$ 的情报中心被歼灭，则 $b$ 的情报中心会报告“无法给 $a$ 发送信息”的错误信息；

- $a$ 和 $b$ 的情报中心同时被歼灭，则两个城市都无法发出错误信息。

现在，TAC 有 $q$ 个事件。在每个事件中，TAC 得到了若干条错误信息。请你根据这些错误信息，确定出**被歼灭的**的情报中心的个数。注意：不同的事件是**独立**的；并且**至少存在一个**有效的情报中心。


## 说明/提示

**数据范围：**


$\def\arraystretch{1.44}
\begin{array}{|c|c|c|}\hline
\bold{\small{子任务}}&\textbf{score}&\textbf{constraints}\\\hline
\text{A}&20&1\le N\le 10^5,m=n-1,b_i-a_i=1,\sum c\le 10^6\\\hline
\text{B}&30&1\le N\le10^5,m=n-1,\sum c\le10^6\\\hline
\text{C}&20&m=n-1\\\hline
\text{D}&30&\small{无特殊限制}\\\hline
\end{array}$

对于所有数据，保证 $1\le n\le 10^6$，$0\le m\le 2.5\times 10^6$，$1\le q,\sum_{i=1}^q c_i \le 10^7$。

## 样例 #1

### 输入

```
7 6
1 2
2 3
3 4
4 5
5 6
6 7
6
1 1 
1 2 
1 3 
2 1 2
3 2 3 4
1 5```

### 输出

```
6
5
4
11
12
2```

# 题解

## 作者：songge888 (赞：5)

### 题意

给定一个 $n$ 个城市的网络，城市之间有 $m$ 条双向通道。每个城市都有情报中心，当一个城市的情报中心被歼灭后，与其相连的正常城市会报告"无法发送信息"。现在给出 $q$ 次询问，每次给出若干条错误信息，要求确定被歼灭的情报中心数量。

### 思路

如果收到"城市 $x$ 无法给城市 $y$ 发送信息"的错误报告，说明 $x$ 是正常的（能发出报告），$y$ 是被歼灭的（导致无法发送）。

将原图转换成树。

先用 DFS 预处理出每个点 $i$ 的父节点 $fa_i$ 和子树大小 $Size_i$。

对于每条错误信息（$x$ 无法给 $y$ 发送）：

- 如果 $x$ 是 $y$ 的儿子（$fa_x=y$）：$ans$ 减去 $Size_x$（$x$ 正常，其子树都正常）。
- 如果 $y$ 是 $x$ 的儿子（$fa_y=x$）：$ans$ 加上 $Size_y$（$y$ 被歼灭，其子树都被歼灭）。

这样答案有时候会是负数（实际上是计算的正常的点的数量）。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/a6etfghb.png)

有 $2 \to 1$ 和 $3 \to 1$ 两条错误。

这时候 $ans=-3-2=-5$，但是实际上只有 $1$ 被摧毁了，所以当 $ans<0$ 时，$ans$ 要加上 $n$。

时间复杂度 $O(m+\sum_{i=1}^q c_i)$。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define bug cout<<"___songge888___"<<'\n';
using namespace std;
int n,m,q,ans;
struct lyl{
	int u,v;
}qu[3000010]; 
vector<int> g[3000010];
int Size[3000010],fa[3000010];
void dfs(int u){
	Size[u]=1;
	for(auto v:g[u]){
		if(!fa[v]){
			fa[v]=u; 
			dfs(v);
			Size[u]+=Size[v];
		}
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>qu[i].u>>qu[i].v;
		g[qu[i].u].push_back(qu[i].v);
		g[qu[i].v].push_back(qu[i].u);
	}
	fa[1]=-1;
	dfs(1);
	cin>>q;
	while(q--){
		ans=0;
		int c;
		cin>>c;
		while(c--){
			int op,u,v;
			cin>>op;
			if(op>0){
				u=qu[op].u;
				v=qu[op].v;
			}
			else{
				u=qu[-op].v;
				v=qu[-op].u;
			}
			if(fa[u]==v){
				ans-=Size[u];
			}
			if(fa[v]==u){
				ans+=Size[v];
			}	
		}
		if(ans<0){
			ans+=n;
		}
		cout<<ans<<'\n';
	}
	return 0;
}

```

---

## 作者：lzx111218 (赞：1)

## 思路

看了看这题的题解，突然心血来潮想用 **链式前向星** 来做。

链式前向星可以在邻接表的基础上减少空间浪费，并且加速图的遍历。~~谁还用 vector 啊~~用两个数组来表示图：

- `hd[]`：记录每个节点的边的起始位置。
- `nx[]` 和 `t[]`：通过这两个数组表示边的连接关系，`nx[]` 用来连接同一节点的多条边，`t[]` 则记录目标节点。

### DFS

用 DFS 从任意节点开始遍历，计算每个城市的 **子树大小**。DFS 的过程中，我们需要记录每个节点的父节点，并计算每个子树的大小，用数组 `sz[]` 来存储每个节点的子树大小。

```cpp
void dfs(int u) {
    sz[u] = 1;
    for (int i = hd[u]; i != -1; i = nx[i]) {
        int v = t[i];
        if (f[v] == -1) {
            f[v] = u;
            dfs(v);
            sz[u] += sz[v];
        }
    }
}
```
还有**事件处理**，需要分析给定的错误信息，根据错误信息来判断哪些节点的情报中心失效：

- 如果某条边的两个城市都无法通信，可以通过父子关系来更新失效的节点数。
- 对于每个事件，就去检查错误信息，再去根据父子关系来调整被歼灭的节点数量。
  
~~因为这个才 WA 了五次。~~
### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, q, a;
vector<pair<int, int>> p;
vector<int> t, nx, hd, sz, f, e;
void dfs(int u) {
    sz[u] = 1;
    for (int i = hd[u]; i != -1; i = nx[i]) {
        int v = t[i];
        if (f[v] == -1) {
            f[v] = u;
            dfs(v);
            sz[u] += sz[v];
        }
    }
}

signed main() {
    scanf("%lld %lld", &n, &m);
    hd.resize(n + 1, -1); 
    sz.resize(n + 1);
    f.resize(n + 1, -1);
    t.resize(2 * m + 1); 
    nx.resize(2 * m + 1);
    int ed = 0;

    for (int i = 1; i <= m; i++) {
        int u, v;
        scanf("%lld %lld", &u, &v);
        
        t[ed] = v;
        nx[ed] = hd[u];
        hd[u] = ed++;
        
        t[ed] = u;
        nx[ed] = hd[v];
        hd[v] = ed++;
        
        p.push_back({u, v});
    }
    
    f[1] = -1;
    dfs(1);
    
    scanf("%lld", &q);
    while (q--) {
        a = 0;
        int c;
        scanf("%lld", &c);
        while (c--) {
            int o, u, v;
            scanf("%lld", &o);
            if (o > 0) {
                u = p[o - 1].first;
                v = p[o - 1].second;
            } else {
                u = p[-o - 1].second;
                v = p[-o - 1].first;
            }

            if (f[u] == v) {
                a -= sz[u];
            }
            if (f[v] == u) {
                a += sz[v];
            }
        }

        if (a < 0) {
            a += n;
        }
        
        printf("%lld\n", a);
    }
    
    return 0;
}

```

---

## 作者：HZEason_Ai (赞：0)

## 题目大意
给定一个 $n$ 个点 $m$ 条边的无向图，对于 $q$ 组测试数据输出不能与所有点联通的点的个数。
## 坑点
- 对于城市 $a_i$ 和 $b_i$ 不一定只有一个情报中心。


- 在遍历图的过程中可能会因递归堆栈过多爆空间。

- 有自己指向自己的边，需要筛掉（或者在计算答案的时候直接过滤掉）。

~~吐槽：阅读理解题还给特解样例[○･｀Д´･ ○]~~

## 分析
![](https://cdn.luogu.com.cn/upload/image_hosting/7dbyjzby.png)

因为样例太特殊，所以自己造了组样例，设 $u$ 表示发出信号的点、$v$ 为被报告的点，下面来分析两种操作。

- 若 $u$ 是 $v$ 的儿子（因为 $u,v$ 只能是 $a_i$ 或 $b_i$，所以不需要并查集来找父亲，但需要考虑上文提到的 $a_i=b_i$ 的情况），则只有 $u$ 的子树（包括自己）符合条件。

- 若 $v$ 是 $u$ 的儿子，则 $v$ 的子树都不符合条件。

看一组样例：
```txt
7 6
1 2
1 3
2 4
2 5
3 6
3 7
3
3 -1 6 5
2 -1 -2
2 1 2
```

对于 ` 3 -1 6 5 ` 这组数据，答案应为 $4+1+1=6$。

对于 `2 -1 -2` 这组数据，显然只有 $1$ 不行，所以答案为 $1$。

对于 `2 1 2` 这组数据，显然只有 $1$ 行，所以答案为 $6$。

再看不懂就直接看代码吧：
```cpp
#include<bits/stdc++.h>
//#define int long long
#define endl "\n"
#define er puts("")
#define sc putchar(' ')
#define AzureLine return 0
using namespace std;
const int N=25e5+5;
int a[N],b[N],sz[N],fa[N];
vector<int>e[N];
void dfs(int x)
{
	sz[x]=1;//子树算上自己
	for(int i=0;i<e[x].size();i++)
	{
		int y=e[x][i];
		if(fa[y]) continue; //双向边，记得continue
		fa[y]=x;dfs(y);
		sz[x]+=sz[y];
	}
}
int read()
{
	int x=0,a=1;char c=getchar();
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-') a=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+c-'0';
	return x*a;
}
void write(int x)
{
	if(x<0) x*=-1,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
	return;
}
signed main()
{
	int n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		a[i]=read(),b[i]=read();
		e[a[i]].push_back(b[i]);
		e[b[i]].push_back(a[i]);
	}
	fa[1]=-1;dfs(1);
//	for(int i=1;i<=n;i++) write(sz[i]),sc;
	int q=read();
	while(q--)
	{
		int c=read(),ans=0;//多测清空
		for(int i=1;i<=c;i++)
		{
			int x=read(),u,v;
			if(x>0) u=a[x],v=b[x];
			else u=b[-x],v=a[-x];
			if(u==fa[v]) ans+=sz[v];
			if(v==fa[u]) ans-=sz[u];
		}
		write(ans>=0?ans:ans+n),er;//如果ans为负，那显然是应为求的是合适的点，所以加n
	}
	return 0;
}
```

---


# [ROIR 2016] 太空移民 (Day 1)

## 题目背景

翻译自 [ROIR 2016 D1T2](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day1.pdf)。

## 题目描述

为了开发火星，必须建立一个研究基地。基地应该由 $n$ 个相同的矩形模块组成。每个模块都是一个居住舱，其大小为 $a \times b$。

为了提高模块的可靠性，工程师们可以在每个模块周围添加一层额外的保护层。该保护层的厚度应为一个整数，并且所有模块的保护层厚度必须相同。保护层厚度为 $d$ 的模块，其大小为 $(a + 2d) \times (b + 2d)$。

所有模块必须放置在一个提前准备好的矩形区域内，区域的大小为 $w \times h$。所有模块的边要与这个矩形区域的边平行，且所有模块的朝向必须一致（即，必须全部横着放或全部竖着放）。

你需要求出可以给每个模块添加的最大保护层厚度是多少。

## 说明/提示

### 样例解释

样例 $1$ 图示：

![](https://cdn.luogu.com.cn/upload/image_hosting/6b9dfczt.png)

### 数据范围

| 子任务 | 是否捆绑 | 分值 | $1\le n\le$ | $1\le a,b,w,h\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $26$ | $1000$ | $1000$ |
| $2$ | 是 | $23$ | $1000$ | $10^9$ |
| $3$ | 否 | $24$ | $10^9$ | $10^{18}$ |
| $4$ | 否 | $27$ | $10^{18}$ | $10^{18}$ |

## 样例 #1

### 输入

```
11 2 3 21 25```

### 输出

```
2```

## 样例 #2

### 输入

```
1 5 5 6 6```

### 输出

```
0```

# 题解

## 作者：LionBlaze (赞：3)

前言：感谢 @lzx111218 让我找到了这题，可以水一发题解。

update：修正了三处笔误。审核员太勤劳了。

分类讨论。

首先考虑纯数学做法，看看是否可行。

如果全是横着放的，那么一行最多能够放置 $\left\lfloor\dfrac{w}{a+2d}\right\rfloor$ 个，一列最多能够放置 $\left\lfloor\dfrac{h}{b+2d}\right\rfloor$ 个，总共可以放置 $\left\lfloor\dfrac{w}{a+2d}\right\rfloor \times \left\lfloor\dfrac{h}{b+2d}\right\rfloor$ 个，这个值需要 $\ge n$。

如果全是横着放的，那么一行最多能够放置 $\left\lfloor\dfrac{w}{b+2d}\right\rfloor$ 个，一列最多能够放置 $\left\lfloor\dfrac{h}{a+2d}\right\rfloor$ 个，总共可以放置 $\left\lfloor\dfrac{w}{b+2d}\right\rfloor \times \left\lfloor\dfrac{h}{a+2d}\right\rfloor$ 个，这个值需要 $\ge n$。

发现纯数学做法不太好做，但是明显答案含有单调性，考虑二分，显然是二分 $d$，顺便复习一下我 $998244353$ 年没写过的二分。

根据上面的分析，需要满足 $\left\lfloor\dfrac{w}{a+2d}\right\rfloor \times \left\lfloor\dfrac{h}{b+2d}\right\rfloor \ge n$ 或 $\left\lfloor\dfrac{w}{b+2d}\right\rfloor \times \left\lfloor\dfrac{h}{a+2d}\right\rfloor \ge h$，也就是：

$$$$\max\left(
\left\lfloor\dfrac{w}{a+2d}\right\rfloor \times \left\lfloor\dfrac{h}{b+2d}\right\rfloor,
\left\lfloor\dfrac{w}{b+2d}\right\rfloor \times \left\lfloor\dfrac{h}{a+2d}\right\rfloor \right) \ge n$$$$

然后考虑二分上下界。显然下界为 $0$，没那么显然但还是挺显然的，上界为 $\min\left(\dfrac{w}{2},\dfrac{h}{2}\right)$（这是 $a=b=0$ 的情况），但是因为 $d$ 为整数，所以实际上在代码里使用的是 $\left\lfloor\dfrac{\min\left(w,h\right)}{2}\right\rfloor$。

那么套一个二分板子就做完了，耶！

代码很简洁：

```cpp
#include <cstdio>    // 用于输入输出
#include <algorithm> // 用于 max/min

using namespace std;

int main()
{
    long long n, a, b, w, h; // 范围 $10^{18}$，所以需要开 `long long`
    scanf("%lld%lld%lld%lld%lld", &n, &a, &b, &w, &h); // `long long` 的输入需要用 `%lld`
    long long l = 0, r = min(w, h) / 2; // 二分范围
    while (l < r) // l != r 也行
    {
        long long d = (l + r + 1) / 2; // 相信编译器优化，/2 -> >>1 优化是不需要手写的。
        if (
            max(
                (w / (a + 2 * d)) * (h / (b + 2 * d)), 
                (w / (b + 2 * d)) * (h / (a + 2 * d)))
            >= n) l = d; // 二分判断条件
        else r = d - 1;
    }
    printf("%lld\n", l);
    return 0;
}
```

---

## 作者：lzx111218 (赞：2)

## 思路
二分板子题。

一眼小学题目，给了长和宽求最多能塞几个长方形，最大的保护层厚度 $d$ 我们可以使用二分查找，使得我们可以在一个给定的矩形区域内放下 $n$ 个模块。每个模块的尺寸会随着 $d$ 增加，所以我们需要判断不同的 $d$ 是否能容纳所有模块。检查模块的横向和纵向排列，来决定能否放得下，二分查找的范围从 $0$ 到 $$\min\left(\frac{w - a}{2}, \frac{h - b}{2}\right)$$
，然后通过每次中间值的判断来缩小范围，最终找到 $d$ 的最大值。

**易 WA 点：必须全部横着放或全部竖着放。**
## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
bool check(long long n, long long a, long long b, long long w, long long h, long long d) {
    long long ad = a + 2 * d, bd = b + 2 * d, na = w / ad, nb = h / bd, na2 = w / bd, nb2 = h / ad;
    if (na * nb >= n) {
        return true;
    }
    return na2 * nb2 >= n;
}
int main() {
    long long n, a, b, w, h;
    scanf("%lld%lld%lld%lld%lld", &n, &a, &b, &w, &h);
    long long l = 0, r = min((w - a) / 2, (h - b) / 2), ans = 0;
    while (l <= r) {
        long long m = (l + r) / 2;
        if (check(n, a, b, w, h, m)) {
            ans = m;
            l = m + 1;
        } else {
            r = m - 1;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Xuan_qwq (赞：2)

给定一个正整数 $n$，一个 $w\times h$ 的大矩形和一个尺寸 $a\times b$。

求最大的正整数 $d$ 使得大矩形内能够放下 $n$ 个 $(a+2d)\times (b+2d)$ 的小矩形，如果没有则输出 $0$。

所有小矩形的朝向必须一致。

---

显然答案具有可二分性。因为如果 $(a+2d)\times (b+2d)$ 可行，那么对于 $d'<d$，$(a+2d')\times (b+2d')$ 的小矩形只需要把所有的左上顶点对齐 $(a+2d)\times (b+2d)$ 小矩形的左上顶点即可。而如果 $(a+2d)\times (b+2d)$ 不可行，那么对于 $d'>d$，$(a+2d')\times (b+2d')$ 显然更不可行，否则根据前面的分析 $d$ 就是可行的。

所以直接二分答案即可。

而对于一个 $W\times H$ 的矩形，最多能放下 $x\times y$ 的小矩形个数为 $\max(\lfloor\frac{W}{x}\rfloor\times\lfloor\frac{H}{y}\rfloor,\lfloor\frac{W}{y}\rfloor\times\lfloor\frac{H}{x}\rfloor)$。这件事画图就很好理解了。

代码比较简单，就不放了。

---

## 作者：MnZnOIer (赞：1)

### 前置知识
[二分](https://oi-wiki.org/basic/binary/)。

### 解题思路
很容易想到二分最大能放的保护层大小。

细节处理：

1. 对于 `check` 函数，我们要判断横着放或者竖着放能否放下，横着能放 $\lfloor \frac{w}{a+2\times d}\rfloor$ 或者 $\lfloor \frac{h}{a+2\times d}\rfloor$。竖着放同理。

2. 对于二分，可能会导致死循环，但是我比较~~菜~~，所以不知道怎么改进，但是我们可以限制二分次数，同时可以发现，最后死循环肯定 $r = l + 1$，所以可以 `check(r)`，如果成立肯定放 $r$ 的保护层，否则就只能放 $l$。

### 代码
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
int n, a, b, w, h, l = 0, r = 1e18;
bool check (int x)
{
	int l1 = w / (a + 2 * x), r1 = h / (b + 2 * x), l2 = w / (b + 2 * x), r2 = h / (a + 2 * x);
	return l1 * r1 >= n || l2 * r2 >= n;
}
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> n >> a >> b >> w >> h;
	for (int i = 0; i < 1e3; ++ i)
	{
		int mid = l + r >> 1;
		if (check (mid))l = mid;
		else r = mid - 1;
	}
	cout << (check (r) ? r : l);
	return 0;
}
```

---

## 作者：Aveiro7 (赞：1)

## 题目大意

为了开发火星，必须建立一个研究基地。基地应该由 $n$ 个相同的矩形模块组成。每个模块都是一个居住舱，其大小为 $a \times b$。

为了提高模块的可靠性，工程师们可以在每个模块周围添加一层额外的保护层。该保护层的厚度应为一个整数，并且所有模块的保护层厚度必须相同。保护层厚度为 $d$ 的模块，其大小为 $(a + 2d) \times (b + 2d)$。

所有模块必须放置在一个提前准备好的矩形区域内，区域的大小为 $w \times h$。所有模块的边要与这个矩形区域的边平行，且所有模块的朝向必须一致（即，必须全部横着放或全部竖着放）。

你需要求出可以给每个模块添加的最大保护层厚度是多少。

## 思路

由于本题的数据范围很大，所以我们可以考虑使用二分查找。

在每次二分查找的过程中，计算在当前假设的保护层厚度 $d$ 下，模块在水平方向和竖直方向分别能放置的数量。如果在某一方向上能放置的模块数量乘以另一方向剩余空间能放置的模块数量大于等于 $n$，说明当前的 $d$ 还可以增大，就将左边界 $lft$ 更新为 $d + 1$；否则说明 $d$ 过大，将右边界 $ri$ 更新为 $d - 1$。

我这么写的时间复杂度是 $O(\log \max (w,h))$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main() {
    ll n,a,b,w,h;
    cin>>n>>a>>b>>w>>h;
    if(a+2>w or b+2>h)
    {
    	cout<<0<<endl;
    	return 0;
	}
	ll lft=0,ri=max(w,h),d;
	while(lft<=ri)
	{
		d=(lft+ri+1)/2;
		if(w/(a+2*d)*(h/(b+2*d))>=n or h/(a+2*d)*(w/(b+2*d))>=n)//判断在水平或竖直方向上，当前d的值是否可以取到 
		lft=d+1;
		else
		ri=d-1;
	}
	cout<<lft-1<<endl;
    return 0;
}
```

---

## 作者：poembelief (赞：1)

# 题目传送门
[[ROIR 2016 Day 1] 太空移民](https://www.luogu.com.cn/problem/P11552)
# 题目分析
这题不是一眼小学数学题吗？唯一的区别是小学数学题是给了长和宽，求最多装多少个长方形。

既然我们已经非常轻松地想到了如何快速求解放置个数，那么也可以~~非常轻松~~地想到二分答案吧。

如果你不能**非常轻松**地看出来，那么不妨来看看联想到二分答案的思路：

本人认为，二分答案本质上是先确定一个答案，然后把答案带进题目中求解得到某个数据，题目要求该数据满足某种条件（比如最大或最小），即已知一个未知数求解另一个未知数，适用于答案难以直接求出但是验证答案非常容易——这不正是本题的特点吗！

特别感谢良心样例告诉我们长方形可以旋转！

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*
*/
long long n,a,b,w,h,l,r=1e18,mid,ans;
bool check(long long d){
	long long x=a+2ll*d,y=b+2ll*d;
	if((w/x)*(h/y)>=n||(h/x)*(w/y)>=n) return 1;
	return 0;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
//	freopen("tx.in","r",stdin);
	scanf("%lld%lld%lld%lld%lld",&n,&a,&b,&w,&h);
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

二分保护膜的厚度。

对于每个厚度，求出能放的行数和列数，再判断两者之积是否大于等于 $n$，由于长方形可以旋转，因此要判断两种情况：一种是长方形横着排，一种是竖着排，只要有一种情况满足条件即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a,b,w,h;
bool check(int x)
{
	int cnt1=a+2*x;
	int cnt2=b+2*x;
	if((w/cnt1)*(h/cnt2)>=n||(w/cnt2)*(h/cnt1)>=n) return true;
	return false;
}
signed main()
{
	cin>>n>>a>>b>>w>>h;
	int l=0,r=1e18,ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：shenbairui (赞：0)

###  [题目传送门](https://www.luogu.com.cn/problem/P11552)

### 题目描述

为了开发火星，必须建立一个研究基地。基地应该由 $n$ 个相同的矩形模块组成。每个模块都是一个居住舱，其大小为 $a \times b$。

为了提高模块的可靠性，工程师们可以在每个模块周围添加一层额外的保护层。该保护层的厚度应为一个整数，并且所有模块的保护层厚度必须相同。保护层厚度为 $d$ 的模块，其大小为 $(a + 2d) \times (b + 2d)$。

所有模块必须放置在一个提前准备好的矩形区域内，区域的大小为 $w \times h$。所有模块的边要与这个矩形区域的边平行，且所有模块的朝向必须一致（即，必须全部横着放或全部竖着放）。

你需要求出可以给每个模块添加的最大保护层厚度是多少。
### 题目大意
给了长和宽，求最多装多少个长方形。
### 题目分析

不难想出可以使用二分答案来解这一道题，题目告诉我们正方形可以旋转。

二分答案内部代码：

```cpp
bool check(long long d){
	long long x=a+2*d,y=b+2*d;
	if((w/x)*(h/y)>=n||(h/x)*(w/y)>=n) return true;
	return false;
}
```
### 完整代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,w,h,l,r=1e18,mid,ans;
bool check(long long d){
	long long x=a+2*d,y=b+2*d;
	if((w/x)*(h/y)>=n||(h/x)*(w/y)>=n) return true;
	return false;
}
int main(){
	cin>>n>>a>>b>>w>>h;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	cout<<ans;
	return 0;
}
```
下期见！

拜拜！

---


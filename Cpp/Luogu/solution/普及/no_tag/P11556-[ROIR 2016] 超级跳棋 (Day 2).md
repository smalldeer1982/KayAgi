# [ROIR 2016] 超级跳棋 (Day 2)

## 题目背景

翻译自 [ROIR 2016 D2T2](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day2.pdf)。

## 题目描述

Andrey 是超级跳棋比赛的裁判。每场比赛中有三名玩家参与。每个玩家在比赛过程中会得到一定的正整数分数。如果在比赛结束时，第一个玩家得到了 $a$ 分，第二个玩家得到了 $b$ 分，第三个玩家得到了 $c$ 分，那么我们说比赛以得分 $a\;\!\text:\;\!b\;\!\text:\;\!c$ 结束。

Andrey 知道超级跳棋的规则要求，比赛结果中任何两个玩家的得分之比最多为 $k$。比赛结束后，Andrey 将显示比赛结果，将三张写有玩家得分的卡片放到专门的显示屏上。Andrey 有 $n$ 张这样的卡片，上面写的数字分别是 $x_1,x_2,\dots,x_n$。

为了测试自己为比赛做好了多少准备，Andrey 希望知道，使用他拥有的 $n$ 张卡片，他能在显示屏上显示多少种不同的得分组合。

## 说明/提示

### 样例解释

在样例中，Andrey 可以显示的得分组合有：$1\;\!\text:\;\!1\;\!\text:\;\!2,\;\! 1\;\!\text:\;\!2\;\!\text:\;\!1,\;\! 2\;\!\text:\;\!1\;\!\text:\;\!1,\;\! 1\;\!\text:\;\!2\;\!\text:\;\!2,\;\! 2\;\!\text:\;\!1\;\!\text:\;\!2,\;\! 2\;\!\text:\;\!2\;\!\text:\;\!1,\;\! 2\;\!\text:\;\!2\;\!\text:\;\!3,\;\! 2\;\!\text:\;\!3\;\!\text:\;\!2,\;\! 3\;\!\text:\;\!2\;\!\text:\;\!2%吐槽：这个间距太难调整了！！！11$。

其它用现有卡片组成的三元组不满足条件，因为这样会出现两个玩家的得分之比超过了 $k = 2$ 的情况。

### 数据范围

| 子任务 | 是否捆绑 | 分值 | $3\le n\le$ | $1\le k\le$ | $1\le x_i\le$ | 其它特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $15$ | $100000$ | $1$ | $100000$ |  |
| $2$ | 是 | $23$ | $100$ | $100$ | $100$ |  |
| $3$ | 是 | $30$ | $100000$ | $10^9$ | $10^9$ | 所有 $x_i$ 互不相同 |
| $4$ | 是 | $32$ | $100000$ | $10^9$ | $10^9$ |  |

## 样例 #1

### 输入

```
5 2
1 1 2 2 3```

### 输出

```
9```

# 题解

## 作者：LuoXH (赞：6)

[题目](https://www.luogu.com.cn/problem/P11556)。

题目中说“比赛结果中任何两个玩家的得分之比最多为 $k$”，我们假设三个玩家的得分分别为 $a,b,c$，且 $a\leq b\leq c$，因而由题意及我们刚刚设的内容得：$a\leq b \leq ak$，和 $a\leq c \leq ak$，则 $ \dfrac{c}{b} \leq k$

(若 $\dfrac{c}{b}=t>k$，则 $c=bt>bk$，因为 $a\leq b$，所以 $ak\leq bk$，又所以 $ak<bt$，得 $ak<c$，与 $c\leq ak$ 矛盾，因此 $t\leq k$)

那么由此我们可以想到一种方法：枚举 $a$，再计算 $b,c$ 的个数以及三人比分的方案数。

$a$ 可以暴力枚举，而对于 $b,c$ 的取值方案数以及比分方案数，由于 $b,c$ 范围确定，可以计算得到（我用的方法是将卡片进行排序，再将相同的合并，再二分搜索找出 $b,c$ 的取值范围，用乘法原理进行计算。注意：可能需要将 $b,c$ 都不等于 $a$，$b$ 或 $c$ 之一等于 $a$，$b$ 和 $c$ 都等于 $a$ 进行分类讨论）

时间复杂度 $O(n\log n)$。

代码如下：（写得比较丑，勿喷）（注意：由于$k,x_i\leq 10^9$，因此要开 long long。~~否则有分，但不多。~~）


```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005],n,k,b[100005],c[100005],cnt,su[100005];
int main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1]){
			cnt++;
			b[cnt]=a[i];
			c[cnt]=1;
			su[cnt]=su[cnt-1];
		}
		else{
			c[cnt]++;
			if(c[cnt]==2) su[cnt]++;
		}
	}
	long long ans=0;
	for(int i=1;i<=cnt;i++){
		long long l=i,r=cnt,g=i;
		while(l<=r){
			long long mid=l+r>>1;
			if(b[mid]<=b[i]*k){
				g=mid;
				l=mid+1;
			}
			else{
				r=mid-1;
			}
		}
		if(g==i){
			if(c[i]>=3){
				ans++;
			}
			continue;
		}
		ans+=(g-i)*(g-i-1)*3;
		ans+=(su[g]-su[i])*3;
		if(c[i]>=2){
			ans+=3*(g-i);
		}
		if(c[i]>=3){
			ans++;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：darklf (赞：4)

# 题解：P11556 [ROIR 2016 Day 2] 超级跳棋
### [题目传送门](https://www.luogu.com.cn/problem/P11556)
~~看到题目直接暴力~~
## 双指针 + 组合数学
先进行排序,再统计每个元素的出现次数，对每一个数进行处理，分别向前和向后搜索满足情况的数（分两个循环来做），进行三次判断：
1. 出现次数 $\ge3$：将答案加一。
2. 合法的数的数量 $\ge3$，就把答案加上满足情况的数的数量的组合数。
3. 出现次数 $\ge2$：把答案加上它的组合数。

附上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int a[N],b[N],m[N],n,K,c=0,ans=0;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>K;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		if(a[i-1]!=a[i]){
			c++;
			m[c]=a[i];
		}
		b[c]++;
	}
	for(int i=1,j=1;i<=c;i++){
		if(b[i]>=3) ans++;
		while(m[j]<=m[i]*K&&j<=c) j++;
		j--;
		if(j-i+1>=3) ans+=3*(j-i-1)*(j-i);
		if(b[i]>=2&&j-i+1>=2) ans+=3*(j-i);
	}
	for(int i=c,j=c;i>0;i--){
		while(m[i]<=m[j]*K&&j>=1) j--;
		j++;
		if(b[i]>=2&&i-j+1>=2) ans+=3*(i-j);
	}
	cout<<ans;
	return 0;
}


```
完结撒花。

---

## 作者：MC_dmAC (赞：4)

原本以为是组合数学，结果打了半天发现是模拟加前缀和优化。

#### 题目链接

[传送门](https://www.luogu.com.cn/problem/P11556)

简略版：给定 $n$ 个数，取三个数 $a$，$b$，$c$（$a≤b≤c$ 且 $c≤a\times k$），问有几种取法（顺序不同视作两种）。

显然，对于每个数有四种类型取法。

1. A A A
2. A A B
3. A B B
4. A B C

首先，我们用 $num$ 数组记录每种数的个数并用 $a$ 数组头部记录对应数，就得到了这 $l$ 种数对应的个数。

第一种：因为三个数相同，**位置与最终结果无关**，只要 $num_i≥3$，就将 $ans$ 加一。

第二种：维护一个上界 $sj$（即 $a_{sj}>k\times a_i$），当 $num_i≥2$ 时，计算对于当前数符合题意数的种数 $amount_i=(sj-1)-(i+1)+1=sj-i-1$。\
并且在该种情况下共三种情况 A A B，A B A 和 B A A。\
所以 $ans$ 加上 $3\times amount_i=3\times(sj-i-1)$。

第三种：用 $nd$ 数组代表第 $1$ 到第 $i$ 种数的个数 $\geq2$ 的数量（前缀和），同上，该种情况下共三种情况 $amount_i=3\times(nd_{sj-1}-nd_i)$。\
所以 $ans$ 加上 $3\times amount_i=3\times(nd_{sj-1}-nd_i)$。

第四种：当第 $i$ 种数后面符合题意的种数 $\geq2$（即 $sj-i>2$）时，A 的位置有三种情况，B 与 C 的取法共 $A^{amount_i}_2$ 种（$amount_i$ 同情况二）。\
所以 $ans$ 加上 $3\times A^{amount_i}_2=3\times(sj-i-1)\times(sj-i-2)$。

## Code

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
#define f(n) for(int i=1;i<=n;i++)
#define ll long long
ll n,k,a[100001],sj,nd[100001];
ll num[100001],l;
ll ans;
int main()
{
	cin>>n>>k;
	f(n)cin>>a[i];
	sort(a+1,a+1+n);
	f(n)if(a[i]!=a[i-1])num[++l]=1,a[l]=a[i];
	else num[l]++;
	f(l)if(num[i]>=2)nd[i]=nd[i-1]+1;
	else nd[i]=nd[i-1];
	f(l)
	{
		if(num[i]>=3)ans++;//情况一
		while(a[sj]<=k*a[i]&&sj<=l)sj++;//维护上界
		if(num[i]>=2)ans+=3*(sj-i-1);//情况二
		ans+=3*(nd[sj-1]-nd[i]);//情况三
		if(sj-i>2)ans+=3*(sj-i-1)*(sj-i-2);//情况四
	}
		
	cout<<ans;
	return 0;
} 
```

综上，不算排序复杂度为 $O(n+l)$。

ps：记得排序（其实不排序直接 $O(n)$ 算 $l$ 也可以）。\
ps2：不开 long long 见祖宗 QAQ。

---

## 作者：xiaoyin2011 (赞：3)

## P11556 [ROIR 2016 Day 2] 超级跳棋 题解

[题目链接](https://www.luogu.com.cn/problem/P11556)

### 题目大意

这道题题面对于我这种语文极差的人来说很不友好，所以我给出一个形式化的题意。

**为了方便称呼，我们在下面把题面中的 $k$ 称作 $K$。**

我们拥有一个长为 $n$ 的数列 $x$，我们可以在其中选择三个数字 $x_i, x_j, x_k$，并且让他们三个数字中的任意两个，例如 $a$ 和 $b$，满足 $a \times K \ge b$ 或 $b \times K \ge a$。

**另外需要注意，$x$ 中存在相同的数字，$i, j, k$ 不能两两相同，$x_i, x_j, x_k$ 可以相同。**

**如果 $1$ 出现了两次，这两个 $1$ 没有区别，只统计一次 $1 : 2 : 3$。**

### 解题思路

最朴素的想法是枚举 $i, j, k$ 在 $1 \le i,j,k \le n$，然后形成 $x_i, x_j, x_k$ 并判断是否满足条件。
但是我们发现 $n \le 10^5$，所以这个想法 TLE。

此时我们可以观察样例解释当中的示例。这些得分组合中，我们可以观察到 $1 : 1 : 2$ 这个组合造就了 $1 : 1 : 2$、$1 : 2 : 1$、$2 : 1 : 1$ 三个排列进入答案，于是我们可以考虑先统计所有组合，然后计算排列。

但是我们会发现：如果一个组合 $x_i, x_j, x_k$ 中 $x_i = x_j = x_k$，那么只能得到一个排列（AAA）；如果 $x_i = x_j \ne x_k$，那么可以得到三个排列（AAB、ABA、BAA）；如果三个数字各不相同，可以得到六个排列（ABC、ACB、BAC、BCA、CAB、CBA）。
所以我们针对这三种情况可以分别统计。

#### 情况1

如果 $x_i = x_j = x_k$，我们需要有不相同的 $i, j, k$ 和相同的 $x_i, x_j, x_k$，也就是说 $x_i$ 这个数字在 $x$ 中出现至少三次。

同时因为三个数相等，$1 \le K$，所以无论三个数是什么，都是合法的一个组合。

我们可以统计所有数字出现的次数，并且对于每个数字和次数进行枚举，如果次数达到了三次，那么 `ans++`。

#### 情况2

如果 $x_i = x_j \ne x_k$。

我们可以先考虑相同的 $x_i$，再根据 $x_i$ 找到满足条件的 $x_k$ 的范围，在这个范围里寻找至少存在一个的 $x_k$。

为什么不先找 $x_k$ 再确定 $x_i$ 的范围呢？因为如果在一定范围内寻找有多少数字至少存在两个，实现起来比上述寻找至少存在一个要复杂，而且无法实现复用。

我们可以枚举统计的每个数字和次数，对于次数达到两个的，寻找适合它的范围，在这个范围里寻找。设这个数字为 $x_i$，那么 $x_i$ 和 $x_j$ 肯定满足比例在 $1 : K$ 之内，所以我们只需要满足 $x_i \times K \ge x_k$ 或者 $x_k \times K \ge x_i$。

因为 $x_k \times K \le x_i$，所以两边同时除以 $K$，可以得到 $x_k \ge \frac{x_i}{K}$。

同时需要注意，$x_i \ne x_k$，否则就成为上面的情况1了。所以 $x_k$ 的范围在：

$$[\frac{x_i}{K}, x_i) \cup (x_i, x_i \times K]$$

我们假设这个范围内数量至少为一个的 $x_k$ 有 $tmp$ 个，那么 `ans += tmp * 3`，因为每个 $tmp$ 对应一个AAB式的组合，对应AAB、ABA、BAA三个排列，所以答案增加 $3 \times tmp$。

#### 情况3

如果 $x_i, x_j, x_k$ 各不相同，我们设这个组合统计时 $x_i < x_j < x_k$，然后可每个组合重排六个贡献。

此时应该以 $x_i$ 还是以 $x_j$ 为基准选择其他两个数？

错误的想法是以 $x_j$ 为基准，如果以 $x_j$ 为基准，那么 $x_i$ 和 $x_k$ 关于 $x_j$ 的范围是一目了然了，$x_i$ 在 $[\frac{x_i}{K}, x_i)$ 中，而 $x_k$ 在 $(x_i, x_i \times K]$ 中。但是此时需要注意，并不是所有存在一个的 $x_i$ 和 $x_k$ 可以任意组合，因为 $x_i$ 和 $x_k$ 也要遵循 $x_i \times K \ge x_k$ 的规则，而简单地统计然后相乘无法规避这一点。

所以我们以 $x_i$ 为基准，选择两个 $x_j$ 和 $x_k$ 在 $(x_i, x_i \times K]$ 范围内。这样，$x_j$ 和 $x_k$ 一定满足比例不超过 $K$。

设 $(x_i, x_i \times K]$ 范围内有 $tmp$ 个数字出现达到一次。那么组合的数量就是 $tmp \times tmp$ 了？因为 $x_j \ne x_k$，所以有 $\frac{tmp \times (tmp - 1)}{2}$ 个组合形成，对于答案的贡献就是组合的数量乘以 $6$，即 $tmp \times (tmp - 1) \times 3$。`ans += tmp * (tmp - 1) * 3`。

### 代码实现

思路上，这个问题已经解决，接下来就是实现。

首先我们需要开 `long long`，因为 $x$ 和 $K$ 都达到 $10^9$，过程数据可能达到 $10^18$ 之高，其次，`ans` 的统计也可能需要 `long long`，所以我们所有的变量都选择 `long long`。

---

第二，我们注意到 $[\frac{x_i}{K}, x_i)$ 这个范围。这个左闭右开的区间因为所有 $x$ 都是正整数，所以可以认为是 $[\frac{x_i}{K}, x_i - 1]$。而 $\frac{x_i}{K}$ 是一个小数，但在 C++ 中直接计算除法得到的是向下取整的结果。

如果你的脑子很清楚，就会发现我们需要这里向上取整，但是如果你和我一样糊涂，我们可以举例分析：比如 $\frac{9}{3}$ 等于 $3$，此时我们需要大于等于它的正整数 $3, 4, 5 \dots$ 均可，向下取整或者向上取整还会得到 $3$，那么大于等于它的正整数不变。比如 $\frac{7}{2}$ 等于 $3.5$，大于等于 $3.5$ 的正整数有 $4,5 \dots$，但是只有向上取整得到的 $4$ 能够让 $4,5 \dots$ 大于等于它，如果下取整到 $3$ 则不行。

对于 `ceil` 的使用，也有一个小坑，因为 `ceil` 接受浮点数，但是我们通常写思路会写作 $\lceil \frac{a}{b} \rceil$ 所以程序里就写成了整数 $a, b$ 进行 `ceil(a/b)`。但是 `a / b` 结果已经向下取整到了整数，所以 `ceil` 仍旧会给出 `a / b`。我们需要写作 `ceil(1.0 * a / b)` 来规避；也可以自己实现 `ceildiv(a, b)`，判断 `a % b == 0`，然后返回除法向上取整的结果。

---

第三个就在于我们如何统计所有的数字出现次数，因为 $x_i \le 10^9$，所以使用普通的数组肯定不行了。但是 `map` 可以，因为 $n \le 10^5$，所以 `map` 中的键值对绝对小于等于 $10^5$ 个，自然不会产生问题。

---

第四个在于我们如何统计一个闭区间以 $[lb, rb]$ 为例，中间出现的数字的个数。在 `map` 中查找自然是费劲的，我们可以在 `vector` 中进行二分查找。

首先输入时把所有 $x$ 读入，然后 `sort` 排序，然后 `unique` 去重，然后 `erase` 删掉多余的。这样就得到了所有出现次数达到一次的数字。这里也解释了为什么前面选择查找至少一次更方便实现，当然两次也行。

对于 $[lb, rb]$，我们通过 `lower_bound` 和 `upper_bound` 进行查找。

```cpp
vector<ll> ap;
// 假设ap已经完成上述的排序和去重
ll findc(ll lb, ll rb) // [lb, rb]
{
    if (lb > rb) return 0; // 排除不合法情况
    ll li = 第一个lb在ap中的下标;
    ll ri = 最后一个rb在ap中的下标;
}
```

使用 `lower_bound` 和 `upper_bound` 时，可以确定边界返回值避免出错。

- `lower_bound(st, ed, x)` 可以寻找序列中大于等于 `x` 的第一个位置，序列全部大于等于这个数，返回 `st`，全部小于，返回 `ed`。

- `upper_bound(st, ed, x)` 可以寻找序列中大于 `x` 的第一个位置，也就是大于等于 `x` 的最后一个位置的下一个位置，序列全部大于这个数返回 `st`，全部小于等于返回 `ed`。

需求也就是我们的 `li` 需要什么数据，也就是 `lb` 在 `ap` 中第一次出现的位置。不存在情况是什么呢，`lb` 可能自己在 `ap` 中没有出现，`lb + 1` 可能也没有，但是 `lb + 2`出现了，此时我们想要第一个 `lb + 2` 的位置，如果有 `lb` 就找第一个 `lb`。这说明我们需要序列中第一个大于等于 `lb` 的位置。所以使用 `lower_bound(ap.begin(), ap.end(), lb) - ap.begin()` 获取下标即可。

`ri` 需要 `rb` 最后一次出现的位置，或者小于 `rb` 的最大数字最后一次出现，也就是说，`ri + 1` 就是第一个大于 `rb` 的数字，所以使用 `upper_bound(ap.begin(), ap.end(), rb) - ap.begin() - 1`，通过 `-1`，还原到 `ri`。

但是我们还要考虑边界情况，如果 `li` 是 `ap.end() - ap.begin()` 意味着什么，也就是全部 `ap` 都要小于 `lb`，那么这个区间就没有任何数字了，返回 `0` 即可。如果 `ri` 是 `ap.end() - ap.begin() - 1` 意味着最后一个数字也小于等于 `rb`，也就是区间包含到了最后一个数字，`ri` 在这里也没有问题。如果 `li` 是 `ap.begin() - ap.begin()`，说明第一个数字就大于等于了 `lb`，从序列第一个开始，没有问题。如果 `ri` 是 `ap.begin() - ap.begin() - 1`，说明第一个数字大于了 `rb`，那么说明这个区间完全在出现的数字之前，自然也是返回 `0`。

普通情况下，答案就是 `ri - li + 1`，因为 `[li, ri]` 都是可选的，而且其中去重，那么数量就是 `ri - li + 1`。

所以完善之后的 `findc` 像这样：

```cpp
ll findc(ll lb, ll rb) // [lb, rb]
{
    if (lb > rb) return 0;
    ll li = lower_bound(ap.begin(), ap.end(), lb) - ap.begin();
    if (li == ap.size()) return 0; // 所有的都小于lb
    ll ri = upper_bound(ap.begin(), ap.end(), rb) - ap.begin() - 1;
    if (ri == -1) return 0; // 所有的都大于rb
    // printf("%lld ~ %lld FIND %lld\n", lb, rb, ri - li + 1); // 调试代码
    return ri - li + 1;
}
```

---

至于输入和 `ap` 的预处理，并不复杂，我这里直接放出：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; // long long
ll n, k, x, ans = 0;
vector<ll> ap; // 统计出现至少一次的数字
map<ll, ll> cnt; // 统计每个数出现次数
ll findc(ll lb, ll rb)
{
    if (lb > rb) return 0;
    ll li = lower_bound(ap.begin(), ap.end(), lb) - ap.begin();
    if (li == ap.size()) return 0;
    ll ri = upper_bound(ap.begin(), ap.end(), rb) - ap.begin() - 1;
    if (ri == -1) return 0;
    return ri - li + 1;
}
int main()
{
    scanf("%lld%lld", &n, &k);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld", &x);
        ap.push_back(x);
        cnt[x]++;
    }
    sort(ap.begin(), ap.end()); // 排序
    ap.erase(unique(ap.begin(), ap.end()), ap.end()); // unique返回排序的序列去重后序列真实尾部所在位置，可以通过erase删掉尾部之后的部分
    for (auto x : cnt)
    {
        // x.first出现了x.second次，处理它的贡献
    }
    printf("%lld\n", ans);
    return 0;
}
```

对于每个 `x.first` 的贡献，我们只需要按照上面的思路写出来即可。

```cpp
for (auto x : cnt)
{
    // printf("%lld counts %lld\n", x.first, x.second); // 调试代码
    if (x.second >= 3)
        ans++;
    if (x.second >= 2)
    {
        // 在(x.first, x.first * k]中寻找到tmp个，ans+=3*tmp
        ans += findc(x.first + 1, x.first * k) * 3;
        // 在[ceil(x.first / k), x.first)中寻找到tmp个，ans+=3*tmp
        ans += findc(ceil(1.0 * x.first / k), x.first - 1) * 3;
    }
    if (x.second >= 1)
    {
        // 在(x.first, x.first * k]中寻找到tmp个，那么有tmp*(tmp-1)/2个可选的，ans+=3*tmp*(tmp-1)
        ll tmp = findc(x.first + 1, x.first * k);
        ans += tmp * (tmp - 1) * 3;
    }
}
```

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, k, x, ans = 0;
vector<ll> ap;
map<ll, ll> cnt;
ll findc(ll lb, ll rb)
{
    if (lb > rb) return 0;
    ll li = lower_bound(ap.begin(), ap.end(), lb) - ap.begin();
    if (li == ap.size()) return 0;
    ll ri = upper_bound(ap.begin(), ap.end(), rb) - ap.begin() - 1;
    if (ri == -1) return 0;
    return ri - li + 1;
}
int main()
{
    scanf("%lld%lld", &n, &k);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld", &x);
        ap.push_back(x);
        cnt[x]++;
    }
    sort(ap.begin(), ap.end());
    ap.erase(unique(ap.begin(), ap.end()), ap.end());
    for (auto x : cnt)
    {
        if (x.second >= 3)
            ans++;
        if (x.second >= 2)
        {
            ans += findc(x.first + 1, x.first * k) * 3;
            ans += findc(ceil(1.0 * x.first / k), x.first - 1) * 3;
        }
        if (x.second >= 1)
        {
            ll tmp = findc(x.first + 1, x.first * k);
            ans += tmp * (tmp - 1) * 3;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

~~蒟蒻第一篇真的题解求过。~~

---

## 作者：Pratty (赞：3)

## 题意

有一个数组 $x$，长度为 $n$。现在选择任意三个 $x_a,x_b,x_c$（$3\le a<b<c\le10^5$），使得其中任意两个数之比 $\le k$，问答案的个数。考虑到精度问题，可以改为乘法计算。

## 思路

首先肯定是需要排序的，这个就不用过多的解释了。

很明显，对于一个 $x_i$，可以贡献的答案一定在它的**相邻的左右两侧**，所以可以通过向两边查询的方法求出答案。

明显的，当相同元素的个数 $≥3$ 时，一定会贡献 $1$ 的答案。

```c++
for (每一种不同的 x) {
  if (sum[i] >= 3) ans++;
}
```

出现次数 $≥2$ 时，就会出现组合了。

明显的，如果其中有两个相同、一个不同，则贡献为 $3$。

若三个均不同，贡献为 $6$。

如果向左右枚举的下标为 $j$，则在每次访问时累加答案如下：

设 $sum_i$ 为 $x_i$ 的个数。

- 若 $sum_i≥2$：累加 $3$。
- 若 $sum_j≥2$：累加 $3$。
- 若 $j-i-1>0$：累加 $6\times(j-i-1)$。

没有别的了。

---

## 作者：lam_dyr (赞：3)

计数分类讨论题。

我们可以证明：对于任意一个有效的得分组合（三个正整数 $a,b,c$ 满足 $\max\{a,b,c\}\le k\cdot\min\{a,b,c\}$，而且 $a,b,c$ 均取自某个给定多重集），如果把这三个数从小到大排序为 $a\le b\le c$那么条件等价于 $c\le k\times a$。

## 思路

由于题目只要求**不同的显示组合**，也就是说，用卡片上的数字组成的三元组（$a:b:c$）只看数字，不关心原来卡片的玩家身份。且如果三个卡片中的数字不同或者有重复时，其显示方式已有固定数目。

  例如：  
- 如果三个数字全不相同，则 $3!=6$ 种不同排列；  
- 如果正好有两个数字相同，则不同排列数为 $3$；  
- 如果三个数字全相同，则只有 $1$ 种排列），
  
所以我们可以**按值统计**所能凑出的组合。

设所有卡片按数值排序后（注意原问题中给出的 n 张卡片可以存在重复），并把相同数值“合并”为一个组。令 $v_1<v_2<\cdots<v_m$ 为所有不同的数字，每个数字 $v_i$ 的出现次数为 $f_i$。

对于任意一个三元组（显示时的位置有顺序），必然存在一个最小值 $v_i$ 与一个最大值 $v_j$（在非全相同的情况有 $i<j$，全相同则 $i=j$）满足 $v_j\le k\times v_i$。

### 分类讨论
不妨分两类讨论：

1. 全部相同

    对于这种组合，显示出来只有一种形式。因此对于一个 $i$，如果 $f_i≥3$，贡献为 $1$。

2. 最小值与最大值不同

   在这种情况下，我们把选出的三张卡片的数字（排序后）一定是 $v_i,?,v_j$，其中中间的那个数字可以任意选下标从 $i$ 到 $j$ 的任意一个（注意中间可以取到 $v_i$ 或 $v_j$）。组合的不同形式依赖于三元组的具体形态：
  - 如果中间取的是 $v_i$，即得到三元组 ${v_i,v_i,v_j}$，这要求 $f_i≥2$；这种情况贡献为 $2$。
 - 如果中间取的是 $v_j$，同理贡献为 $2$。
- 如果中间取的是 $v_r$，且 $i<r<j$，则三者各不相同，此时贡献为 $6$。

  因此，对于一组固定的 $i，j$ 满足 $i<j$ 且 $v_j≤k\times v_i$，设在区间 $[i,j]$ 内（不包括 $i$ 和 $j$）合法三元组的组数记为 $num=j-i-1$，则这组可以配出
$$3\times (f_i\ge2?1:0)+3\times (f_j\ge2?1:0)+6\times num$$
个显示组合。

## 具体实现

由于 $v_i$ 单调递增，所以对于每个 $i$，我们可以利用双指针找出最大 $j$，使得 $v_j≤k\times v_i$。于是，对于每个 $i$（对应三元组中最小的数字 $v_i$），其候选 $j$ 都在区间 $[i+1, n]$ 内。累加所有满足条件的贡献，再加上所有全相同的情况，即可得到答案。

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11556)
## 解析
### 题意：
有三个数 $a$、$b$ 和 $c$，且其中每两个符合要求的数字之比都不得超过 $k$，有一些卡片来表示这些数字，问这些卡片能组合出多少种不同的且数字各不相同的分数组合？
### 考察内容：
本题考查分类讨论及一些数学知识。
### 思路：
输入所有数据，将卡片去重，统计每一种卡片。接着固定第一个数，因为这样最为方便，然后用二分去找出另外两数的范围，接着讨论以下的几种情况：

- 几个数中没有一个相等,则我们可以通过数学中的排列组合去搜；
- 有两个数相等，则需要讨论哪两个相等，毕竟我们还可以细分出另外两数的不同情况，比如其中一个等于第一个固定的数；
- 有三个数相等，那么就要讨论是否符合题意，即是否数的种类不止三种，毕竟依题意，三个数不得相等，应当至少有两个互不相同；

具体的代码实现及进一步解析见代码。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100861],b[100861],c[100861],num[100861],n,k,sum=0;//数组开大点 
int main()
{
	scanf("%lld%lld",&n,&k);//输入 
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);//输入 
	}
	sort(a+1,a+n+1);//用快排方便以下操作 
	for(int i=1;i<=n;i++)
	{
		if(a[i]!=a[i-1])
		{
			sum++;//计数，用于记录共有多少种不同的组合  
			b[sum]=a[i];//将a[i]录入b数组中 
			c[sum]=1;//记录这种有多少 
			num[sum]=num[sum-1];//记下每个数 
		}
		else
		{
			c[sum]++;//相同则将两个数放在一起 
			if(c[sum]==2)
			{
				num[sum]++;//记录 
			}
		}
	}
	long long out=0;
	for(int i=1;i<=sum;i++)//枚举第一个数 
	{
		long long ls1=i,ls2=sum,ls3=i;//存储 
		while(ls3<=ls2)
		{
			long long mid=ls3+ls2>>1;//分半（二分），>>1就是除以2 
			if(b[mid]<=b[i]*k)//判断是否符合题意：比赛结果中任何两个玩家的得分之比最多为k 
			{
				ls1=mid;
				ls3=mid+1;//如果还能继续加下去，说明还没有到达最顶 
			}
			else
			{
				ls2=mid-1;//不满足条件，说明上一次枚举已是最顶端 
			}
		}
		/*以上是讨论第2和3个数的范围（第1个数已有循环确定），然后二分，*/ 
		out+=(ls1-i)*(ls1-i-1)*3;
		out+=(num[ls1]-num[i])*3;
		/*三数各不相等，用数学中的3！=6，又由于选两数，所以除以二变成3，所以每个式子乘3。*/ 
		if(ls1==i)//另外两个数中有一个等于第一个数
		{
			if(c[i]>=3)//只要这种数有多少（数组c）大于等于3，就将out加一。
			{
				out++;
			}
			continue;
		}
		if(c[i]>=3)//多个数中，三数相同时，只要这种数有多少（数组c）大于等于3，就将out加一。否则，违反题意（若只有三数，则这三数应各不相同）。 
		{
			out++;
		}
		if(c[i]>=2)//多个数中有两个相等 
		{
			out+=3*(ls1-i);//讨论每两个数相同时
		}
	}
	printf("%lld\n",out);//输出 
	return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P11556 题目](https://www.luogu.com.cn/problem/P11556)

### 解题思路
记序列 $p$ 为把序列 $x$ 去重后的序列，然后分情况讨论。

当 $a=b=c$ 时，若有某一个数字在 $x$ 中出现了 $3$ 次及以上，则对此情况做出了 $1$ 的贡献。

当 $a,b,c$ 中有且仅有 $2$ 个数相等时（这里假设 $a=b$），枚举 $a$，注意这里的 $a$ 需满足在 $x$ 中至少出现 $2$ 次，易知 $\frac{a}{k}\le c\le a\times k$，在 $p$ 上二分找出 $c$ 有多少种取值即可，由于 $a,b,c$ 在不同顺序的情况下视为不同的选择，所以需要将贡献乘 $C_3^2=3$，另外注意在实现时 $\frac{a}{k}$ 需要向上取整。

当 $a\not=b$ 且 $b\not=c$ 时（这里假设 $a<b<c$），枚举 $a$，易知 $a<b<c\le a\times k$，在 $p$ 上二分找出有多少个 $i$ 满足 $a<p_i\le a\times k$，设有 $m$ 个 $i$ 满足条件，则 $b,c$ 的取值有 $\frac{m\times(m-1)}{2}$ 种，由于 $a,b,c$ 在不同顺序的情况下视为不同的选择，所以需要将贡献乘 $A_3^3=6$，即贡献为 $3\times m\times(m-1)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
map<int,int> mapp;
int x[100001],c[100001];
signed main()
{
	ios::sync_with_stdio(false);
	int n,k,top=0,s=0;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>x[i],mapp[x[i]]++;
	sort(x+1,x+n+1);
	for(int i=1;i<=n;i++)
	{
		if(x[i]!=x[i-1])
			c[++top]=x[i];
	}
	sort(c+1,c+top+1);
	for(int i=1;i<=top;i++)
	{
		int st=upper_bound(c+1,c+top+1,c[i]*k)-c-i-1,m=c[i]/k+(c[i]%k!=0),st2=i-(lower_bound(c+1,c+top+1,m)-c);
		s+=st*(st-1)*3;
		if(mapp[c[i]]>=3)
			s++;
		if(mapp[c[i]]>=2)
			s+=(st+st2)*3;
	}
	cout<<s;
	return 0;
}
```

---

## 作者：lzx111218 (赞：1)

# P11556 [ROIR 2016 Day 2] 超级跳棋
[题目传送门](https://www.luogu.com.cn/problem/P11556)
## 思路
看见这题时我的第一反应就是**双指针和滑动窗口**。

这道题的目的是在给定的卡片上选择三个得分，并计算出所有符合条件的得分组合的数量。比赛中每个玩家的得分之间的比值要求不能超过一个给定的常数 $k$，也就是说，对于三张卡片上的得分 $a$、$b$、$c$，必须满足：
  - $\frac{a}{b} \leq k$。
  - $\frac{b}{c} \leq k$。
  - $\frac{a}{c} \leq k$。

首先，将所有得分进行排序，以确保得分从小到大排列，这样可以利用**滑动窗口**和**双指针**快速查找符合条件的三元组。接着，我们将相同得分的卡片合并，只存储每个不同的得分及其出现次数，从而减少重复计算。为了实现这一点，我们使用了 `vector` 来存储和管理数据，`vector<int> num` 用于存储不同的得分，`vector<int> cnt` 用于记录每个得分出现的次数。然后，使用两层**双指针**技术来定位符合条件的三元组，第一层指针固定一个得分，第二层指针通过滑动窗口的方式，寻找符合条件的其它得分范围。最后，我们需要计算符合条件的三元组数量，特别要注意有重复得分的情况。
~~你猜我为什么不用数组。~~

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
vector<int> cnt,num;
int n,k,t,ans;
signed main() {
    scanf("%lld%lld", &n, &k);
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    sort(a.begin() + 1, a.begin() + 1 + n);
    for (int i = 1; i <= n; i++) {
        if (a[i] != a[i - 1]) {
            num.push_back(a[i]);
            cnt.push_back(1);
            t++;
        } else {
            cnt.back()++;
        }
    }
    for (int i = 0, j = 0; i < t; i++) {
        if (cnt[i] >= 3) {
            ans++;
        }
        while (j < t && num[j] <= num[i] * k) {
            j++;
        }
        j--;

        if (j - i + 1 >= 3) {
            int tmp = j - i - 1;
            ans += 3LL * tmp * (tmp + 1);
        }
        if (cnt[i] >= 2 && j - i + 1 >= 2) {
            ans += 3LL * (j - i);
        }
    }

    for (int i = t - 1, j = t - 1; i >= 0; i--) {
        while (j >= 0 && num[j] * k >= num[i]) {
            j--;
        }
        j++;

        if (cnt[i] >= 2 && i - j + 1 >= 2) {
            ans += 3LL * (i - j);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：poembelief (赞：1)

# 题目传送门

[[ROIR 2016 Day 2] 超级跳棋](https://www.luogu.com.cn/problem/P11556)

# 题目分析

看到这题的第一反应就是双指针——很容易发现，当我们枚举左边界的时候，右边界一定是不变或变大的。由于相同的数对于答案的贡献是一致的，所以我们可以考虑排序后去重。

比分只有三个，所以我们可以拆分成三种情况考虑：全部相等、有两个相等、全部不等。

全部不等的情况最好处理：只要某个数出现次数 $\ge 3$ 对答案的贡献就加一。

有两个相等的情况：枚举出现次数 $\ge 2$ 的数，注意双指针要从前、从后各扫一遍，答案的贡献式见代码。

全部相等的情况：枚举左边界，求出对应的右边界，由于数组已经排序并去重，所以可以利用这点性质，推一下对答案的贡献式，具体式子可见代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*
*/
const int N=1e5+5;
int n,a[N],cnt[N],t;
long long k,num[N],ans;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
//	freopen("tx.in","r",stdin);
	scanf("%d%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1]) num[++t]=a[i];
		cnt[t]++;
	}
	for(int i=1,j=1;i<=t;i++){
		if(cnt[i]>=3) ans++;
		while(num[j]<=num[i]*k&&j<=t) j++;
		j--;
//		cout<<i<<','<<j<<endl;
		if(j-i+1>=3){
			int tmp=(j-i-1);
			ans+=3ll*tmp*(tmp+1);
//			cout<<i<<','<<j<<":"<<tmp<<endl;
		}
		if(cnt[i]>=2&&j-i+1>=2){
			ans+=3ll*(j-i);
		}
	}
	for(int i=t,j=t;i>0;i--){
		while(num[j]*k>=num[i]&&j>0) j--;
		j++;
		if(cnt[i]>=2&&i-j+1>=2){
			ans+=3ll*(i-j);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Wish_kazdel (赞：0)

## 思路
我们先看题目，由于三元组中任意两个数最多相差 $k$ 倍，所以只需比较一个三元组中的最小值与最大值相差的倍数，就可以判断它是否符合条件。因此，我们将 $x$ 数组排序，枚举三元组的第一个数 $a$，确定第一个之后，就可以确定剩下两个数在数组 $x$ 中的下标范围。

但这道题目并非如此简单，还要分类讨论，因为卡片上的数可能重复，所以我们要进行有条件的筛选。

我们可以分四种情况来讨论。

第一种，当这三个数各不相同时，因为我们已经枚举了 $a$，那么只要在可选数中选出两个不同的即可。

第二种，当 $b$ 和 $c$ 相等时，要在可选数中选择两个相同的数，我们得提前预处理好每个 $x_i$ 的相同数的数量，再判断一个可选数相同数的数量是否大于等于 $2$。

第三种，当 $a$ 和 $b$ 相同时，前提是当前枚举的第一个数的相同数的数量大于等于 $2$，剩下一个数从可选数中随便选。

第四种，这三个数相同时，如果当前枚举的第一个数的相同数的数量大于等于 $3$ 即可

理解以上思路之后，最后就可以进行答案统计了。

---

## 作者：qW__Wp (赞：0)

若不考虑得分之比最多为 $k$ 的限制怎么做？统计出卡片中出现次数为 $1$ 的卡片种数 $b1$、出现次数为 $2$ 的卡片种数 $b2$、出现次数 $\ge 3$ 的卡片种数 $b3$，共有 $sum = b1 + b2 + b3$ 种不同卡片，分类讨论：

+ 使用三张两两不同的卡片，则从 $sum$ 种卡片中任选 $3$ 张，则有 $A_{sum}^{3}=sum \times (sum-1) \times (sum-2)$ 种方案。

+ 使用两张相同的卡片和另一张不同的卡片，则从 $b2 + b3$ 种出现次数 $\ge 2$ 的卡片中选出两张相同的卡片，并与其余任一种卡片搭配，则有 $(b2 + b3) \times (sum-1) \times 3$ 种方案（最后 $\times 3$ 是因为可以调换选出卡片的排列顺序，有 $3$ 种不同的排列方式）。

+ 使用三张相同的卡片，则有 $b3$ 种方案。

综上，总方案数为

$$\max(0,sum \times (sum-1) \times (sum-2))+(b2 + b3) \times (sum-1) \times 3+b3$$

由于数字较大，统计时不能用桶，于是对 $x$ 升序排序，便于统计。

接下来，考虑用双指针每次维护一段最长的区间 $[l,r]$ 使 $\dfrac{x_r}{x_l} \le k$ 即 $x_l \times k \ge x_r$，同时维护这段区间的 $b1,b2,b3$ 即可计算出其方案数。

但是这样一来便会重复计算部分方案数，对于连续用双指针扫出的两个区间 $[l_1,r_1],[l_2,r_2]$（$l_1 < l_2 < r_1 < r_2$），$[l_2, r_1]$ 这个重合区间的方案数算重复了，减去即可。

详见代码。

```C++
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1e5 + 5;

int a[N];

int get(int b1, int b2, int b3) {
	int sum = b1 + b2 + b3;
	return max(0ll, sum * (sum - 1) * (sum - 2)) + (b2 + b3) * (sum - 1) * 3 + b3;
}

signed main() {
	int n, k; cin >> n >> k;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	int l = 1, r = 0, ans = 0, sum = 0;
	int b1 = 0, b2 = 0, b3 = 0;
	while (r < n) {
		sum = 0; 
		while (r < n && a[l] * k >= a[r + 1]) {
			// 尽量让区间扩大 
			r ++; sum ++;
			if (a[r] != a[r + 1]) {
				if (sum == 1) b1 ++;
				else if (sum == 2) b2 ++;
				else b3 ++;
				sum = 0;
			}
		}
		ans += get(b1, b2, b3);
		if (r == n) break;
		sum = 0;
		while (a[l] * k < a[r + 1] && l <= r) {
			// 让 l 增大直到区间 [l, r + 1] 中数字之比最多为 k 
			sum ++;
			if (a[l] != a[l + 1]) {
				if (sum == 1) b1 --;
				else if (sum == 2) b2 --;
				else b3 --;
				sum = 0;
			}
			l ++;
		}
		// 这里 b1, b2, b3 的意义变了，表示重合区间
		ans -= get(b1, b2, b3);
	}
	cout << ans;
	return 0;
}
```

是道好题。

---


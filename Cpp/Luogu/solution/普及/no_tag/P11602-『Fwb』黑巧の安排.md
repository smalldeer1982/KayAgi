# 『Fwb』黑巧の安排

## 题目描述

Fwb 可喜欢吃黑巧了。

Fwb 有一个专门用来装黑巧的盒子，但很不巧，今天盒子空了，Fwb 又该出去买点巧克力了。

由于 Fwb 也知道吃多了巧克力对身体不好，所以他决定他买的巧克力必须只能吃 $a$ 天，且不能多也不能少。

Fwb 吃巧克力是有规律的：他会在第一天吃一块巧克力，在品尝到巧克力的美味后，第二天吃两块巧克力，第 $i$ 天吃 $2^{i-1}$ 块巧克力（$i>0$）。

当剩余的巧克力不够一天吃的时候，Fwb 就会选择不吃；反之，当剩余的巧克力够一天吃的时候，Fwb 就一定会吃。

若在第 $i$ 天吃完的巧克力之后仍剩余 $k$ 颗，且 $k<2^i$，则 Fwb 会在第 $i+1$ 天再次吃 $1$ 颗，在第 $i+2$ 天再次吃 $2$ 颗，以此类推。换句话说，当 $k<2^i$ 时，第 $i+m$ 天会吃 $2^{m-1}$ 颗。

现在需要你求出，Fwb 在恰好吃 $a$ 天的前提下，最少需要购买多少颗巧克力。

## 说明/提示

#### 【样例 1 解释】

第一次询问：要求恰好 $5$ 天吃完，则买 $9$ 颗巧克力。安排如下：

- 第一天吃 $1$ 颗，剩余 $8$ 颗。
- 第二天吃 $2$ 颗，剩余 $6$ 颗。
- 第三天吃 $4$ 颗，剩余 $2$ 颗。
- 不够 $8$ 颗，第四天只能再从 $1$ 颗吃起，剩余 $1$ 颗。
- 不够 $2$ 颗，第五天只能再从 $1$ 颗吃起，吃 $1$ 颗，恰好吃完。

可以证明，没有更优的安排。

第二次询问：要求恰好两天吃完，买 $2$ 颗巧克力，每天 $1$ 颗即可。

第三次询问：要求恰好三天吃完，买 $4$ 颗巧克力，每天分别吃 $1,2,1$ 颗。

#### 【数据范围】

对于 $30\%$ 的数据，$1\le a\le 10$。

对于 $100\%$ 的数据，$1\le t,a\le 1000$。

保证答案在 $long\ long$ 范围内。

## 样例 #1

### 输入

```
3
5
2
3```

### 输出

```
9
2
4```

## 样例 #2

### 输入

```
6
263
749
409
761
729
382```

### 输出

```
16760809
1095216660441
939524067
1099510579161
549755805658
503316452```

# 题解

## 作者：LostKeyToReach (赞：11)

有一个很显然的 dp 做法。

令 $dp_i$ 表示恰好吃 $i$ 天的最小巧克力数量，那么有转移：

$$
dp_i = \min_{j}(dp_{i - j} + 2^j - 1)
$$

其中 $2^j - 1 = \displaystyle \sum_{k = 1} ^ j 2^{k - 1}$。

请注意，我们这里令 $i - j + 1$ 重新开始按规律吃巧克力，故在 $dp_{i - j} < 2^j$ 时才可以转移。

那么 $j$ 的范围是什么呢？首先，肯定有 $1 \le j \le i$。其次，由于答案不超过 $64$ 位有符号整数的范围，故 $j \le 60$。综上，我们只需在 $[1, \min(i, 60)]$ 的范围内枚举 $j$ 即可。

处理完 dp 就可以 $O(1)$ 回答了。

这里的时间复杂度为 $O(t + 60V)$，足以通过本题了。

Challenge：当 $V$ 很大时，你有什么更优秀的解法吗？

---

## 作者：dongzhenmao (赞：7)

## 题目链接:
[**link**](https://www.luogu.com.cn/problem/P11602)，点击这里。 
## 思路:
贪心的做法难想，那考虑动态规划。
## 做法:
先放一个公式：$\sum_{i=0}^{n-1}2^i=2^n-1$。

定义 $dp[i]$ 为要吃 $a$ 天时最少得巧克力个数，很明显，当前的最优取决于曾经的最优，故可以动态规划。很容易想到 dp 方程：

$dp[i]=\min(dp[i],dp[e]+2^{i-e}-1)$。

有且仅当 $2^{i-e}>dp[e]$ 且 $0\le e<i$ 时可以转移。

举个例子：

当 $a=2$ 时，最优的吃法为：$1,1$。
  
当 $a=5$ 时，最优的吃法为：$1,2,4,1,1$。

其中 $a=5$ 时的 $1,2,4$ 为上面所说的 $2^3-1$ 的转移。

再来看看不可以的：

当 $a=2$ 时，最优的吃法为：$1,1$。

当 $a=3$ 时，最优的吃法为：$1,2,1$。

但是如果用 $a=2$ 转移的话，就成这样：$1,1,1$，在第二天早就有足够的巧克力可以吃了，所以转移是非法的，即上述的 $2^{i-e}>dp[e]$ 不满足了。

## 时间复杂度分析
预处理：$O(n^2)$，回答 $O(t)$，总复杂度 $O(n^2)$。满足数据范围。
## 代码:
注：文中使用 $bas_i$ 来存储 $2^i$。
```cpp
#include <bits/stdc++.h>
#define lnt long long
#define inf 0x3f3f3f3f
using namespace std;
lnt xx;char ff,chh;inline lnt read(){
    xx=ff=0;while(!isdigit(chh)){if(chh=='-'){ff=1;}chh=getchar();}
    while(isdigit(chh)){xx=(xx<<1)+(xx<<3)+chh-'0';chh=getchar();}return ff? -xx: xx;
}
const int N=1e3+12;
lnt dp[N],bas[N];
int main(){
	lnt G=read();
	memset(dp,0x3f,sizeof(dp));
	dp[1]=bas[0]=1;
	for(int i=1;i<N;++i){bas[i]=bas[i-1]<<1;}
	for(int i=2;i<N;++i){
		for(int e=1;e<i;++e){
			if(bas[i-e]<=dp[e]){continue;}
			dp[i]=min(dp[i],dp[e]+bas[i-e]-1);
		}
	}
	while(G--){
		printf("%lld\n",dp[read()]);
	}
	
    return 0;
}

```

---

## 作者：Zilljy258 (赞：5)

Fwb 强调这是一道简单题。

作为最菜最水的验题人，提供一个不正经的做法，就是硬找规律。（能给过吗）

手模前 12 天的吃法，作差，发现每次都是上一天加 $2^x$。


```
1
+1
1  1
+2
1  2  1
+1
1  2  1  1
+4
1  2  4  1  1
+2
1  2  4  1  2  1
+1
1  2  4  1  2  1  1
+8
1  2  4  8  1  2  1  1
+4
1  2  4  8  1  2  4  1  1
+2
1  2  4  8  1  2  4  1  2  1
+1
1  2  4  8  1  2  4  1  2  1  1
+16
1  2  4  8 16  1  2  4  1  2  1  1
```


这里的 $2^x$  从分别是：

```
1  2 1  4 2 1  8 4 2 1  16 8 4 2 1  32 16 8 4 2 1  64 32 16 8 4 2 1...
```
则 $x$  从分别是：

```
0  1 0  2 1 0  3 2 1 0  4 3 2 1 0  5 4 3 2 1 0  6 5 4 3 2 1 0...
```

---

### 代码：

```
#include<iostream>
#include<cstdio>

using namespace std;

int t;
int n;
long long up;
long long sum;
long long ans[1010];

int main(){
	scanf("%d",&t);
	
	up=sum=1;
	ans[1]=1;
	
	for(int i=2;i<=1000;++i){
		ans[i]=ans[i-1]+sum;
		sum/=2;
		if(sum==0){
			up*=2;
			sum=up;
		}
	}
	
	while(t--){
		scanf("%d",&n);
		printf("%lld\n",ans[n]);
	}
	
	return 0;
}
```

大家看下出来了吧，我是这场比赛中最摆烂的工作人员。

---

## 作者：Frielen (赞：3)

## 前言
赛时 $10$ 分钟切了，不过用的是时间复杂度较劣的朴素 dp。

## 正文
看到这题，容易想到 dp。

定义：

数组 $dp[i]$ 指天数为 $i$ 时的答案。

下面假设要求 $dp[j]$。

考虑到如果我们希望让他吃的巧克力尽量少，那么总有一天，假设这天为 $k$，他会不再吃 $2^{k}$ 块巧克力，而是只吃 $1$ 块。那么什么时候，他**能够不再吃 $2^k$ 块巧克力**呢？显然是在剩下 $j-k$ 天中，他吃的巧克力数**在最优情况下**少于 $2^{k}$ 块。

注意到这个所谓的最优情况是以 $1$ 开头的，那说白就是 $dp[j-k]$ 嘛！所以条件可以改写为：$dp[j-k]<2^{k}$。

因此，就容易想到思路了。至于为什么，待会儿证明。

从小到大枚举 $k$，令变量 $now=0$，这里的 $now$ 起到模拟题中 $2^k$ 的作用。

若 $2^k\le dp[j-k]$，则直接得到 $dp[j]=now+dp[j-k]$，转移结束。

否则，有 $now=now+2^{k-1}$。

为什么这样的 dp 正确呢？如下给出证明。

假设存在更优的方式，那么总有一天，同样的，设这天为 $k$，他第一次不再吃巧克力。我们称之为新方案。

而我们构造的这个方案的第一次为 $t$。

### 情况 $1$：若 $k=t$

这个时候显然不会更优了，因为我们的方案前 $k$ 天与新方案答案相同，而后 $j-k$ 天采用了最优解。

### 情况 $2$：若 $k>t$

容易发现，在前 $t$ 天，两个方案答案相同。但根据我们的构造，新方案仅仅第 $t+1$ 天一天的巧克力数就超过了后面的 $dp[j-t]$ 啊！所以肯定不优。

### 情况 $3$：若 $k<t$

这肯定是不合法的，为什么呢？因为新方案后 $j-k$ 天最少吃 $dp[j-k]$ 块巧克力，但 $dp[j-k]>2^{k+1}$，那他必然选择吃 $2^{k+1}$ 块巧克力，就与条件矛盾！

于是，我们就能得到其正确性了。并且易知，时间复杂度小于 $O(n^2)$。

代码时间到~

## My code
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n,k[1009];
int make(int p){ //赛时写的是记搜，懒得改了...
	if(k[p]) return k[p];
	int now=1,ans=0,q=0;
	for(int i=1;i<=p;i++){
		q=i;
		ans+=now;
		if(now*2>make(p-q)) break;
		now*=2;
	}
	return k[p]=ans+make(p-q);
}
signed main(){
	k[0]=0,k[1]=1;
	cin>>t;
	while(t--){
		cin>>n;
		cout<<make(n)<<'\n';
	}
	return 0;
} 
```

## 后记

这个方法能够用数归推得标答的差分序列。但我语文不好，讲不清，也不再赘述了。

---

## 作者：_H17_ (赞：3)

## 前言

气死我了，洛谷破验证码把我 AK 抢了，最后两秒钟被洛谷破验证码卡了。

## 题目分析

我觉得这个题个人差比较大，我用的是一种递推的方法。

考虑 $a_i$ 是吃 $i$ 天最少需要的巧克力。

首先最大可以取 $2^i-1$ 个。

注意到一个性质，我们的答案一定是由若干个 $1,2,4,\dots$ 组成的，前面的一定更长。

考虑寻找 $j$，满足可以先“野蛮的”吃 $j$ 天，剩下 $i-j$ 天直接取 $a_{i-j}$。显然 $j$ 越小，“理智的”吃的越多，答案就越小。这样就可以保证步步最优。

$j$ 的唯一限制就是剩下的不够再吃一天，因此我们可以二分。

为什么可以二分？$a$ 怎么证明有单调性呢？我们考虑反证法。如果 $a_i=x,a_{i+1}=y$，而且 $x>y$。那显然 $x'$ 作为 $y$ 去掉最后一天吃的巧克力可以做到 $x'<y$。然而 $x\le x'$，不成立。

为了避免运算过程中超过 `long long` 限制，可以使用 `__int128`。二分范围不用太大，取一个 `__int128` 可以承受的即可，再大的也显然不可能合法。

假设询问最大值是 $n$，次数是 $T$，时间复杂度是 $O(n\log n+T)$。

其实这个跑不满，设 $w=2^{128}-1$ 是变量范围，本身二分的数就要做指数运算，所以范围是 $\log w$ 级别的，再加上二分，用复杂度也可以表示为 $O(n\log \log w+T)$。（不严格地，这也可以当作常数 $O(n)$）

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
constexpr int N=1001;
int T,a[N],b[N],c[N],q;
void read(int&a){
	char c=getchar();
	a=0;
	while(c<'0'||c>'9')c=getchar();
	while('0'<=c&&c<='9')
		a=(a*10)+c-48,c=getchar();
	return;
}
int qp(int a,int b){
	int ret=1;
	while(b){
		if(b&1)
			ret*=a;
		a*=a,b>>=1;
	}
	return ret;
}
void write(int a){
	if(a<10){
		cout<<(char)((long long)a+48);
		return;
	}
	write(a/10);
	cout<<(char)((long long)a%10+48);
	return;
}
signed main(){
    a[0]=0,a[1]=1,b[0]=0,b[1]=1,c[0]=0,c[1]=1;
    for(int i=2;i<=1000;i++){
    	b[i]=b[i-1]*2+1;
    	int l=1,r=min(i-1,__int128(100)),mid;
    	while(l<r){
    		mid=(l+r)>>1;
    		if(qp(2,mid)>a[i-mid])
    			r=mid;
    		else
    			l=mid+1;
		}
    	a[i]=b[r]+a[i-r];
    }
    for(read(T);T;--T){
        read(q);
        write(a[q]);
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：Perfect_Youth (赞：3)

请注意本篇题解属于找规律，没有证明。

此题可以先打暴力跑一下 $1$ 到 $20$ 表。

跑表代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

inline
bool check(long long x, long long a) {
	int last = 1, cnt = 0;
	for (int i = 1; i <= a; i++) {
		if ((1ll << last - 1) <= x) {
			x -= (1ll << last - 1), cnt++;
		} else {
			last = 1;
			if ((1ll << last - 1) <= x) x -= (1ll << last - 1), cnt++;
		}
		last++;
	}
	return cnt == a && !x;
}

int main() {
	for (int t = 1; t <= 20; t++) {
		for (int i = 0; ; i++) {
			if (check(i, t)) {
				printf ("%d:%d\n", t, i);
				break;
			}
		}
	}
	return 0;
}
```

如下：
```cpp
1:1
2:2
3:4
4:5
5:9
6:11
7:12
8:20
9:24
10:26
11:27
12:43
13:51
14:55
15:57
16:58
17:90
18:106
19:114
20:118
```
它们的差值为：`1,2,1,4,2,1,8,4,2,1,16,8,4,2,1,32,16,8,4`，你会发现是其中有等比数列，这样就可以把代码写出来了。

代码如下:
```cpp
#include <bits/stdc++.h>
#define int long long
#define getchar()(p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

using namespace std;

int t, a, dp[1007], last, tmp;

inline
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

signed main() {
	t = read();
	dp[1] = 1, dp[2] = 2, last = 4, tmp = 2;
	for (int i = 3; i <= 1000; i++) {
		dp[i] = dp[i - 1] + last / 2;
		last >>= 1;
		if (last == 1) tmp++, last = 1ll << tmp;
	}
	while (t--) {
		a = read();
		printf ("%lld\n", dp[a]);
	}
	return 0;
}
```

---

## 作者：MnZnOIer (赞：2)

### 前言
看上去还是挺有思维难度的。

### 解题思路
#### 法一
贪心。题目相当于要将他们分段，并且只有这一段放不下的时候才能用下一段。因为每一次是指数级上升的，所以肯定要尽量分得更多的段。

我们先考虑 $n$ 为 $\frac{k\times(k+1)}{2}$，因为要让段数最少且这一段的的和大于剩下的和，很容易想到构造一个类似 $1,2,4\dots 2^k,1,2,4\dots2^{k-1}\dots 1,2,1$ 的数列，如果按照每一段来看，就是段的长度呈等差数列递减，每次减一。

这可以给我们灵感：是不是每次都这样分就可以呢？
我们可以发现，直接在后面增加即可，然后每次当它不满足条件时，就把它移到它能作为最后一项的段的末尾。

上面是笔者感性理解想出来的，但为什么这样就一定满足呢？我们当前段长度为 $k$，按照上述规律，剩下的长度为 $\frac{k\times(k-1)}{2}$，根据等比数列，求得当前段下一个需要放 $2^k$，剩下段的和为 $\sum_{i=1}^{k-1}{2^i-1}$，我们将其化简可得：$2^k-k-2$，小于剩下需要放的，这样一定满足，可证没有更优的放法。

综上，答案为 $1,2,1,4,2,1,8,4,2,1\dots$ 的前缀和。
#### 法二
直接 dp，令 $f_i$ 表示吃 $i$ 天需要的最小巧克力数，显然有转移方程 $f_i=\min_{j=1}^{i-1}{f_{i-j}+2^j-1}(f_{i-1}\le 2^{j}-1)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t, n, f[1005];
signed main ()
{
    ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
    memset (f, 0x7f, sizeof (f));
    f[0] = 0;
    for (int i = 1; i <= 1e3; ++ i)for (int j = 1, c = 1; j ^ 63 && j <= i; ++ j)if ((c <<= 1) > f[i - j])f[i] = min (f[i], f[i - j] + c - 1);
    cin >> t;
    while (t --)
    {
        cin >> n;
        cout << f[n] << '\n';
    }
    return 0;
}
```

---

## 作者：cjx_AK (赞：2)

这题一看有些复杂，我们不妨找找规律。
先列举一些情况看看规律：

```
dp[1]=1
dp[2]=2
dp[3]=4
dp[4]=5
dp[5]=9
dp[6]=11
dp[7]=12
dp[8]=20
dp[9]=24
dp[10]=26
dp[11]=27
...
```

乍一看，好像没有什么规律，不妨把相邻两天的差算出来，记为 $b_i$。


```
b[1]=1
b[2]=2
b[3]=1
b[4]=4
b[5]=2
b[6]=1
b[7]=8
b[8]=4
b[9]=2
b[10]=1
...
```

我们发现，在 $b_i=1$ 时，$b_{i+1}$ 会重置至 $2^{x+1}$，否则 $b_{i+1}=b_i\div2$。（$x$ 是之前重置的次数） 

光找规律可不行，还得证明。

如果要吃 $7$ 天，那么结果就是 $1+2+4+1+2+1+1$，如果要吃 $8$ 天，那么结果就是 $1+2+4+8+1+2+1+2$。

我们发现了什么？

最理想的结果就是每加一天就加 $1$ 颗巧克力，但是我们需要考虑到只要满足了要求，他就不会留着吃。
因为加一会导致一个数合并。

一个例子：$dp_5=1+2+4+1+1$,$dp_6=1+2+4+1+2+1$。

如果 $dp_6=1+2+4+1+1+1$，那么它可以这么写： $1+2+4+1+2$。

我们需要尽量阻止合并，如果不得不合并，如 $dp_7=1+2+4+1+2+1+1$，那么必须加上最大的数乘 $2$ 才行。

证毕。

代码：

```
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
#define int long long
int dp[1000001],T,a,x=1;
int low(int a,int b){
	int res=1;
	while(b){
	if(b&1){
		res*=a;
	}
		a*=a;
		b>>=1;
		
	}
	return res;
}
signed main() {
cin>>T;
	dp[1]=1;
	dp[2]=2;
	dp[3]=4;
for(int i=4;i<=1000;i++){
	if(dp[i-1]-dp[i-2]==1){
		x++;
		dp[i]=low(2,x)+dp[i-1];
	}else{
	dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])/2;
	}
}

	while(T--){
	cin>>a;
	cout<<dp[a]<<endl;
}
	return 0;
}
```
管理看写了这么多，给过了吧，感谢！！！

---

## 作者：dsj2012 (赞：1)

# 题意简化
假设今天是连续吃的第 $i$ 天，并且买的巧克力够我们吃 $2^{i - 1}$ 颗那么我们就必须吃 $2^{i - 1}$ 颗巧克力。否则就重新开始计算。问如果恰好吃 $a$ 天，最少要多少巧克力。
# 思路
我们定义：假设 $ans_i$ 为恰好吃 $i$ 天的最少巧克力数量。

我们知道在巧克力够吃的时候绝对要吃，那么我们就可以想一想在什么时候我们可以让剩下的巧克力不能满足我们再吃的要求且可以吃 $a$ 天。

那么我们利用一条信息。如果能吃则必须吃。如果我们从当前天开始重新计算，剩下的天最少要吃的巧克力要少于现在即将要吃的巧克力数。就说明如果从当前天开始我们可以做到剩下的巧克力吃的合理，且巧克力总和满足我们现在不能再吃了。

那么我们就可以先枚举所有天数，然后开始往前找，如果可以重置我们的答案是答案变小，那么我们就重置否则就不重置。优先考虑答案的合理性。
## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T;
int x;
int ans[1005];//记录吃i天要的最少巧克力
void init(){//预处理答案
	ans[1] = 1;//初始第一个
	for(int i = 2 ; i <= 1000 ; i ++){//枚举所有天数
		int k = 1;//将要吃的巧克力初始化为1
		for(int j = i ; j >= 1 ; j --){//开始找
			if(k == 1){//可加可不加
				ans[i] ++;
				k *= 2;
				continue;
			}
			if(ans[j] < k){//从现在开始重置后的答案可以满足我们合理且当前不能再吃
				k = 1;//既然重置了，那么吃的就要改变
			}
			ans[i] += k;//当前的天数要加上我们吃的巧克力
			k *= 2;//每次都要翻倍
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> T;//有T组数据哦
	init();//别忘了调用
	while(T --){
		cin >> x;//输入
		cout << ans[x] << "\n";//直接输出
	}
	return 0;
}
```

---

## 作者：anke2017 (赞：1)

## 正题

考虑 dp。

令 $dp_i$ 表示最少要多少巧克力，才能（恰好）吃 $i$ 天。

显然，有如下转移：（枚举第一波吃几天）

$$
dp_i = \max_{j=1}^{i} {(dp_{i-j}+2^j-1,2^j-1\ge dp_{i-j})}
$$

然后你就发现它爆炸了。

追究原因，发现是 $2^j$ 直接左移，爆 `long long` 了。

但是我们发现，$dp_{i}$ 并不大（不能超过 `long long` 范围），所以对最优转移，显然有 $2^j \le (2^{63} -1),j \le 62$。（进一步的，$j$ 最大是 $O(\sqrt{n})$ 级别的），于是就可以直接转移了。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

long long dp[1001];

#define int long long
signed main()
{
	int t;cin>>t;
	dp[0]=0,dp[1]=1;
	for(int i=2;i<=1000;i++)
	{
		dp[i]=9e18;//够大了
		for(int x=1;x<=min(i,62ll);x++)
		{
			if((1ll<<x)-1<=dp[i-x])continue;
			dp[i]=min(dp[i],dp[i-x]+(1ll<<x)-1);
		}
	}
//先打表，再输出
	while(t--)
	{
		int tmp;cin>>tmp;
		cout<<dp[tmp]<<'\n';
	}
	return 0;
}
```

---

## 作者：yanqijin (赞：1)

# 题目大意
有一个人吃巧克力，第一天吃一个，从第二天开始，如果能吃前一天的 $2$ 倍，就一定吃前一天的 $2$ 倍。否则就只吃 $1$ 个。现在知道了吃的天数，求最少的吃的巧克力数。
# 思路
一眼下来，感觉像 dp 或者打表找规律，所以考虑 dp。

首先设 $dp_i$ 表示吃了 $i$ 天的最小巧克力数，然后我们考虑观察一下变化规律。

我们发现，在第一次重新吃一个巧克力的时候开始，问题就由 $dp_i$ 转化成了 $dp_{i-j}$。（$j$ 表示第一次重新吃一个巧克力之前已经吃过了多少个巧克力）。

我们在思考一下，发现由于"如果能吃前一天的 $2$ 倍，就一定吃前一天的 $2$ 倍"这句话，我们可以得出转移条件为 $dp_{i-j} <2^j$。

所以转移即为 $dp_i=\min_{j=1}^{64}dp_{i-j}+2^j-1[dp_{i-j}<2^j]$。

时间复杂度 $O(a\log V+t)$。（$V$ 表示值域）。
# code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,a,dp[1005];
void read(long long &x)
{
	x=0;
	int w=1;
	char ch=0;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-48;
		ch=getchar();
	}
	x*=w;
}
void write(long long x)
{
	if(x<0) putchar('-'),x=-x;
	int sta[100];
	int top=0;
	do
	{
		sta[top++]=x%10,x/=10;
	} while(x);
	while(top) putchar(sta[--top]+48);
	putchar('\n');
}
int main()
{
	read(t);
	for(int i=1;i<=1000;i++)
	{
	    dp[i]=1e18;
		for(long long j=1,g=2;j<=64&&j<=i;j++,g<<=1)//g 表示 2^j。
		{
			if(g>dp[i-j])
			{
				dp[i]=min(dp[i],g-1+dp[i-j]);
			}
		}
	}
	while(t--)
	{
		long long ans=1;
		read(a);write(dp[a]);
	}
	return 0;
}
```

---


# [JOIGST 2024] 相聚 / いっしょ

## 题目背景

译自 [日本情報オリンピック 第4回女性部門 (JOIG 2023/2024) 春季トレーニング](https://www2.ioi-jp.org/joig-camp/2024/2024-sp-tasks/) R1T1。

## 题目描述

在一条笔直的道路上有 $N$ 只河狸。这条道路可以视为数轴，第 $i$ 只（$1 ≤ i ≤ N$）河狸位于坐标 $X_i$ 处。

由于河狸生性怕寂寞，当且仅当同一坐标存在至少一只其他河狸时，它们才会感到快乐。

现在需要通过合理移动河狸，在确保所有河狸都快乐的前提下，使它们的移动距离总和尽可能小。河狸**可以不移动**。

给定 $N$ 只河狸的坐标，请编写程序计算使所有河狸都快乐时，河狸移动距离总和的最小值。

可以证明本题中答案一定是整数。


## 说明/提示

### 样例解释

#### 样例 $1$ 解释

第一只河狸移动到 $2$ 处，第三只河狸移动到 $4$ 处。可以证明没有更优的方案。

该样例满足所有子任务的限制。

#### 样例 $2$ 解释

第一只河狸移动到 $2$ 处，第二只河狸和第五只河狸移动到 $8$ 处。可以证明没有更优的方案。



该样例满足子任务 $3,4$ 的限制。

#### 样例 $3$ 解释

该样例满足子任务 $3,4$ 的限制。


### 数据范围

- $2\le N\le 3\times 10^5$；
- $1\le X_i\le 10^9$；
- 输入的值全部是整数。

### 子任务

1. （17pts） $N=4$。
2. （20pts）$\forall 1\le i\le N$，$X_i=i$。
3. （35pts）$N\le 100$；$\forall 1\le i\le N$，$X_i\le 100$。
4. （28pts）无额外限制。

翻译来自 DeepSeek-R1 并经过人工微调。

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 9 8 2 7```

### 输出

```
3```

## 样例 #3

### 输入

```
10
9 20 5 10 8 1 10 19 15 4```

### 输出

```
10```

# 题解

## 作者：FFTotoro (赞：5)

之前把这题搬进了模拟赛，直接把当时写的题解弄过来。

本题有结论：将坐标序列排序后，最终河狸聚成的形态必然形如“将连续的 $2$ 只河狸或 $3$ 只河狸分成一组”。如果将 $4$ 只或更多只河狸移动到同一个位置，那么必然不优——以 $4$ 只河狸为例，假设坐标分别为 $a_1,a_2,a_3,a_4(a_1\le a_2\le a_3\le a_4)$，那么如果全部移动到同一个位置，代价为 $|a_1-a_2|+|a_2-a_3|+|a_2-a_4|$，但是如果将它们两两分组，代价就为 $|a_1-a_2|+|a_3-a_4|$，显然后者不大于前者；更多只的情况可以类似地推导。

所以我们可以先将 $a$ 排序，在这之后进行动态规划。设 $f_i$ 为考虑了前 $i$ 只河狸的最小代价，那么有如下两种转移：

- $f_i\gets f_{i-2}+a_i-a_{i-1}$；（将 $i-1$ 和 $i$ 分组）
- $f_i\gets f_{i-3}+a_i-a_{i-2}$；（将 $i-2$、$i-1$ 和 $i$ 分组）

时间复杂度为 $O(n\log n)$。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  ios::sync_with_stdio(false);
  int n; cin>>n;
  vector<int> a(n),f(n);
  for(auto &i:a)cin>>i;
  sort(a.begin(),a.end());
  f[1]=a[1]-a[0],f[2]=a[2]-a[0];
  for(int i=3;i<n;i++)
    f[i]=min(f[i-2]+a[i]-a[i-1],i>3?f[i-3]+a[i]-a[i-2]:(int)2e9); // 进行 DP
  cout<<f[n-1]<<endl;
  return 0;
}
```

---

## 作者：CuteMurasame (赞：3)

先对河狸的位置进行排序。可以证明，将海狸分成大小为 2 或 3 的块，每一块河狸聚集到一起，总是最优的。

解释：

- 对于位置在 $x\leq y$ 的 $2$ 只河狸，如果它们已经共享坐标则不需要移动。但如果不是，最优方案是在它们之间的任意一个点相聚，最小总移动距离为 $\lvert y-x\rvert$。
- 对于位置在 $x\leq y\leq z$ 的 $3$ 只河狸，最佳相聚点是 $y$（中位数），最小总移动距离为 $(y-x)+(z-y)=z-x$。
- 如果尝试将 $4$ 只或更多河狸聚集到一个点，可以发现将这个块分成 $2$ 和 $3$ 的块总是能得到不大于原来的总移动距离。
- 例如对于位置在 $x\leq y\leq z\leq w$ 的 $4$ 只河狸，将它们聚集到一起的总移动距离是 $(w+z)-(x+y)$；而将它们分为 $(x,y)$ 和 $(z,w)$ 的总移动距离是 $(y-x)+(w-z)$，$(w+z)-(x+y) \geq (w-z)+(y-x)$，$y=z$ 时等号成立。

所以可以直接 dp，$f_i$ 表示对前 $i$ 只河狸（排序后）分成大小为 2 或 3 的块所需的最小总移动距离。具体来说：

- $f_0=0$（没有河狸意味着没有成本）；
- $f_1=\infty$（一只河狸不能配对）；
- $f_2=X_2-X_1$；
- $\forall i\geq 3,f_i=\min\{f_{i-2}+(X_{i}-X_{i-1}),f_{i-3}+(X_{i}-X_{i-2})\}$。

$f_n$ 就是答案。

---

## 作者：longyitongxue (赞：1)

先看范围，我们只能采用 $\mathcal O(n\log_2n)$ 的时间复杂度。我们先要对整个序列进行排序，接下来我们要 DP。

我们对 $dp_i$ 的定义为：前面 $i$ 个河狸移动的最优解。

# 动态规划过程

- 考虑前 $i-2$ 个河狸已经分完，$a_i, a_{i-1}$ 两个分一组：最优解为其中一个河狸移动到另一个河狸的位置，距离为 $a_i - a_{i-1}$，则 $dp_i$ 可以从 $dp_{i-2} + (a_i - a_{i-1})$ 递推。
- 考虑前 $i-3$ 个河狸已经分完，$a_i, a_{i-1}, a_{i-2}$ 三个分一组：最优解为左右移动到中间河狸的位置，距离为 $(a_i - a_{i-1}) + (a_{i-1} - a_{i-2})$，即 $a_i - a_{i-2}$，则 $dp_i$ 可以从 $dp_{i-3} + (a_i - a_{i-3})$ 递推。

状态转移方程：$dp_i = \min(dp_{i-2} + a_i - a_{i-1}, dp_{i-3} + a_i - a_{i-2})$，**请注意，此时的 $\textbf{\textit{i}}$ 应大于 $\textbf3$！**$i$ 要大于 $3$ 状态转移方程才成立，那么肯定有一个边界的问题。以下是状态转移方程的边界：  
$\left\{\begin{matrix}
dp_0&\gets& 0 &\text{没有河狸，不用移动}\\
dp_1&\gets& +∞ & \text{无解，设一个无穷大}\\
dp_2&\gets& a_2-a_1 &\text{两个河狸一组的情况}\\
dp_3&\gets& a_3-a_1 &\text{三个河狸一组的情况}
\end{matrix}\right.$

# 珍藏代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long a[int(3e5+5)],dp[int(3e5+5)];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	dp[0]=0;
	dp[1]=1e18;
	dp[2]=a[2]-a[1];
	dp[3]=a[3]-a[1];
	for(int i=4;i<=n;i++){
		dp[i]=min(dp[i-2]+a[i]-a[i-1],dp[i-3]-a[i-2]+a[i]);
	}
	cout<<dp[n]<<'\n';
	return 0;
}

```

最后说一句我的观点：我之所以用 `long long`，是因为范围达到了 $10^9$，加来加去有可能超过 $2^{31}-1$（`int` 类型的最大边界），所以开个 `long long` 保平安。

---

## 作者：xuzb (赞：1)

# 思路
思路就是排序以后用动态规划做，把河狸分成几个区块，使得绝对值总和尽可能小。

题目原话：现在需要通过合理移动河狸，在确保所有河狸都快乐的前提下，使它们的移动距离总和尽可能小。河狸**可以不移动**。

## 分块策略

所以要确定如何使得河狸分块时位移更小。以下是证明过程：

1.当一个区快有 $0$ 或 $1$ 只河狸，不符合题意。

2.当一个区块有 $2$ 只河狸，则位移为坐标差的绝对值。

3.当一个区块有 $3$ 只河狸（坐标分别为  $a\leq b\leq c$ ），则可以得知当左右两只河狸移动到中间一只时位移最小：
 $b-a+c-b=c-a$ 。

4.当一个区块有 $4$ 只河狸（坐标分别为  $a\leq b\leq c\leq d$ ），则可以得知移至 $b$ 与 $c$ 之间位移总和最小，不妨设位移至 $b$ 。则位移总和为：$ d-b+c-b+b-a=d-c+c-b+c-b+b-a$ 。如果分为两个区块（ $a$ 与 $b$ ， $c$ 与 $d$ ）,则位移总和为：$ b-a+d-c $ ，显然更小。

5.当一个区块有多余 $4$ 只河狸时，同上，位移和达不到最小。

由此可知应该将河狸分成 $2$ 或 $3$ 只一组。

再用动态规划解决。

## 详细解决方法（动态规划写法）

1.升序排序

2.动态规划数组 $f$ ，两种状态转移方程：

两只一组： $f_i = f_{i-2}+a_i-a_{i-1}$ 。

三只一组： $f_i=f_{i-3}+a_{i-1}-a_i+a_{i-1}-a_{i-2} $ 。

---

## 作者：__qkj__ (赞：0)

# 解题思路
DP 题。

首先推公式。
- 当两只河狸在一起时，只需要任意移动一只，转移方程是 $f_i\gets f_{i-2}+a_i-a_{i-1}$；
- 当三只河狸在一起时，只需要把边上两只移到中间这里，转移方程是 $f_i\gets f_{i-3}+a_i-a_{i-2}$；
- 但是当四只河狸在一起时，它们可以再分成两对河狸，不是最优方案。

然后初始化。
- $1$ 只河狸无法变出一对，无解；
- $2$ 只河狸只需要任意移动一只，$f_2\gets a_2-a_1$。

记得排序。
# Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[300010],f[300010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	f[1]=INT_MAX;
	f[2]=a[2]-a[1];
	for(int i=3;i<=n;i++)
		f[i]=min(f[i-2]+a[i]-a[i-1],f[i-3]+a[i]-a[i-2]);
	cout<<f[n];
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

首先贪心。最佳方案中，将原本不在同一位置的多于 $3$ 只河狸移动到一起相比将其两两分组（奇数个则保留一组 $3$ 只）肯定不优，所以只需要考虑一组 $2$ 只或一组 $3$ 只。

其次 DP。将 $a_i$ 升序排列。设 $dp_i$ 表示考虑前 $i$ 只的最小花费，则 $dp_1=+\infty,dp_2=a_2-a_1,dp_3=a_3-a_1,dp_i = \min(dp_{i - 2} + (a_i - a_{i - 1}), dp_{i - 3} + (a_i - a_{i - 2}))$。

---

## 作者：AFO_Lzx (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P11686)

### $\texttt{Description}$

有 $n$ 只河狸，第 $i$ 只河狸的位置为 $a_i$，现在要求一个位置至少存在 $2$ 只或者以上的河狸，求河狸移动次数总和的最小值。

### $\texttt{Solution}$

数据范围是 $n \le 3 \times 10^5$，考虑 $O(n)$ 或者 $O(n \log n)$ 做法。但是很明显首先要排个序，所以接下来的过程考虑 $O(n)$ 的线性做法，即为 DP。

- 确定状态：$dp_i$ 表示前面 $i$ 个河狸移动次数的最小值。
- 确定答案：易得为 $dp_n$，就是前面 $n$ 个河狸移动次数的总和的最小值。
- 状态转移：$dp_i=\min(dp_{i-2}+a_i-a_{i-1},dp_{i-3}+a_i-a_{i-2})$，注意此时 $i \ge 3$。
- 初始值与边界：
$$\begin{cases} dp_0=0\\dp_1=+\infin\\dp_2=a_2-a_1\end{cases}$$

### $\texttt{Code}$：[$\texttt{link}$](https://www.luogu.com.cn/paste/b5odhwqz)

闲话：Deepseek 在此题拿到了 $37$ 分的好成绩。

---

## 作者：tomAmy (赞：0)

题目意思就是把河狸分组，每组至少两只，聚集起来。因为要移动距离最小，一定是把相邻的河狸分组，考虑先排序。接着考虑 dp 求解，令 $dp_i$ 表示前 $i$ 个河狸的最优解。

递推 $dp_i$ 时:

考虑前 $i - 2$ 个河狸已经分完，$a_i,a_{i - 1}$ 两个分一组：最优解为其中一个河狸移动到另一个另一个河狸的位置，距离为 $X_{i} - X_{i - 1}$，则 $dp_i$ 可以从 $dp_{i - 2} + (X_{i} - X_{i - 1})$ 递推。

考虑前 $i - 3$ 个河狸已经分完，$a_i,a_{i - 1},a_{i - 2}$ 三个分一组：最优解为左右移动到中间河狸的位置，距离为 $(X_i - X_{i - 1}) + (X_{i - 1} - X_{i - 2})$，即 $X_i - X_{i - 2}$，则 $dp_i$ 可以从 $dp_{i - 3} + (X_{i} - X_{i - 3})$ 递推。

如果分组个数更多，一定可以分成更小的组。本质为将更小组的结果聚集，一定更劣，无需考虑。

注意初始化：

$dp_0 \gets 0$（没有河狸，不用移动）

$dp_1 \gets +\infty$（无解，设无穷大）

$dp_2 \gets X_2 - X_1$（第一种情况，两个一组）

$dp_3 \gets X_3 - X_1$（第二种情况，三个一组）

贴上代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 300005;
int dp[N], a[N];

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	sort(a + 1, a + n + 1);
	dp[0] = 0;
	dp[1] = 1e9;
	dp[2] = a[2] - a[1];
	dp[3] = a[3] - a[1];
	for (int i = 4; i <= n; i++)
		dp[i] = min(dp[i - 2] + a[i] - a[i - 1], dp[i - 3] + a[i] - a[i - 2]);
	cout << dp[n] << endl;
	return 0;
}
```

---


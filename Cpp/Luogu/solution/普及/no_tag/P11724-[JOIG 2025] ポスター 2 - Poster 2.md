# [JOIG 2025] ポスター 2 / Poster 2

## 题目描述

JOI 学院的理惠为三月举行的文化节制作了一张海报。海报可以视为一个 $N\times N$ 的网格；有 $K$ 种颜色，编号分别为 $1$ 到 $K$，每个格子的颜色是 $K$ 种颜色之一；具体地，网格的颜色可以用一个矩阵 $A$ 来表示：记第 $i$ 行第 $j$ 列的格子为 $(i,j)(1\le i,j\le N)$，那么 $(i,j)$ 的颜色为 $A_{i,j}(1\le A_{i,j}\le K)$。

学生希望海报的颜色可以丰富一点；他们定义一张海报的“鲜艳程度”为满足以下条件的 $(i,j)(1\le i,j\le N-1)$ 的个数：

- $(i,j),(i+1,j),(i,j+1),(i+1,j+1)$ 中出现的颜色种类数不小于 $3$。

即 $A$ 中出现元素种类数不小于 $3$ 的 $2\times 2$ 子矩阵个数。

例如，下图中的海报的鲜艳程度为 $2$，因为存在 $2$ 个满足上述条件的 $2\times 2$ 子矩阵（已使用蓝框标出）。

![](https://cdn.luogu.com.cn/upload/image_hosting/t5fmqlcc.png)

由于时间紧迫，学生们希望通过恰好**一次**以下操作，或者**不进行操作**，来最大化海报的鲜艳程度：

- 选择**恰好一个**格子 $(i,j)$ 和一个与该格子原先颜色不同的颜色 $c(1\le c\le K)$，将格子 $(i,j)$ 的颜色改为 $c$，即 $A_{i,j}\gets c$。

请求出最终能得到的海报的最大鲜艳程度。

## 说明/提示

#### 【样例解释 #1】

如下图所示，将 $(2,2)$ 的颜色改为颜色 $3$，可以使得鲜艳程度为 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/762orsul.png)

可以证明不存在更优的方案。

该样例满足子任务 $1,3,4,5$ 的限制。

#### 【样例解释 #2】

如下图所示，将 $(2,3)$ 的颜色改为颜色 $4$，可以使得鲜艳程度为 $5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wewhdqwb.png)

可以证明不存在更优的方案。

该样例满足子任务 $3,4,5$ 的限制。

#### 【样例解释 #3】

该样例满足子任务 $2,4,5$ 的限制。

#### 【样例解释 #4】

该样例满足子任务 $3,4,5$ 的限制。

#### 【样例解释 #5】

该样例满足子任务 $4,5$ 的限制。

#### 【数据范围】

- $2\le N\le 270$；
- $3\le K\le 10^9$；
- $1\le A_{i,j}\le K(1\le i,j\le N)$。

#### 【子任务】

1. （$9$ 分）$N=2,K=3$；
2. （$6$ 分）$A_{i,j}(1\le i,j\le N)$ 两两不同；
3. （$27$ 分）$N,K\le 10$；
4. （$26$ 分）$N\le 10$；
5. （$32$ 分）无附加限制。

## 样例 #1

### 输入

```
2 3
1 2
2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5
1 1 1 2 2
1 1 1 2 2
3 3 1 2 2
3 3 5 5 5
3 3 5 5 5```

### 输出

```
5```

## 样例 #3

### 输入

```
5 1000000000
104289385 946930886 881692778 914636916 257747795
524238335 819885386 849760493 696516649 389641422
225202363 550490028 883368690 302520060 344897765
267513928 565180541 740383427 404089172 503455737
135005211 621595368 394702567 926956430 436465782```

### 输出

```
16```

## 样例 #4

### 输入

```
3 3
1 2 3
2 2 2
3 2 1```

### 输出

```
2```

## 样例 #5

### 输入

```
10 11
2 2 1 3 4 3 4 3 3 5
3 2 4 3 4 4 3 3 5 5
3 4 2 2 5 5 5 5 5 5
4 2 2 3 5 3 5 5 5 6
2 2 3 5 5 5 6 6 7 5
4 4 4 5 6 4 6 7 6 6
3 3 5 4 6 6 6 5 6 8
3 3 4 4 6 5 7 7 6 8
4 4 4 6 7 5 5 8 8 7
4 4 6 5 6 6 7 6 6 9```

### 输出

```
39```

# 题解

## 作者：封禁用户 (赞：6)

明显可以枚举哪个位置的颜色会变，对于左上，右上，左下，右下四个 $2 \times 2$ 的正方形统计一下变化后的答案，和全局答案取个 $\max$ 即可。

实现有个小细节，对于 $k$ 比较小的情况可以暴力枚举换成哪种颜色，$k$ 比较大时换成一种没有出现过的颜色即可。

大概就是这样：

```cpp
il void mian(){
	read(n, k);
	L(i, 1, n) L(j, 1, n) a[i][j] = read();
	int ans = 0;
	L(i, 1, n - 1){
		L(j, 1, n - 1){
			set<int> st;
			st.insert(a[i][j]), st.insert(a[i + 1][j]), st.insert(a[i][j + 1]), st.insert(a[i + 1][j + 1]);
			if (st.size() >= 3) ans++;
		}
	}
	int ret = 0;
	L(i, 1, n){
		L(j, 1, n){
			int cnt = ans;
			set<int> st, st1, st2, st3, st4;
			if (i > 1) st1.insert(a[i - 1][j]), st2.insert(a[i - 1][j]), st.insert(a[i - 1][j]);
			if (j > 1) st1.insert(a[i][j - 1]), st3.insert(a[i][j - 1]), st.insert(a[i][j - 1]);
			if (i < n) st3.insert(a[i + 1][j]), st4.insert(a[i + 1][j]), st.insert(a[i + 1][j]);
			if (j < n) st2.insert(a[i][j + 1]), st4.insert(a[i][j + 1]), st.insert(a[i][j + 1]);
			if (i > 1 && j > 1) st1.insert(a[i - 1][j - 1]), st.insert(a[i - 1][j - 1]);
			if (i > 1 && j < n) st2.insert(a[i - 1][j + 1]), st.insert(a[i - 1][j + 1]);
			if (i < n && j > 1) st3.insert(a[i + 1][j - 1]), st.insert(a[i + 1][j - 1]);
			if (i < n && j < n) st4.insert(a[i + 1][j + 1]), st.insert(a[i + 1][j + 1]);
			int tot = 0;
			if (k <= 5000 && st.find(k) != st.end()){
				L(c, 1, k){
					int rrt = 0;
					set<int> sst1 = st1, sst2 = st2, sst3 = st3, sst4 = st4;
					int flg1 = 0, flg2 = 0, flg3 = 0, flg4 = 0;
					if (st1.size() == 2) flg1++;
					if (st2.size() == 2) flg2++;
					if (st3.size() == 2) flg3++;
					if (st4.size() == 2) flg4++;
					if (st1.find(c) == st1.end()) sst1.insert(c);
					if (st2.find(c) == st2.end()) sst2.insert(c);
					if (st3.find(c) == st3.end()) sst3.insert(c);
					if (st4.find(c) == st4.end()) sst4.insert(c);
					if (sst1.size() == 3 && st1.find(a[i][j]) != st1.end() && flg1) rrt++;
					if (sst2.size() == 3 && st2.find(a[i][j]) != st2.end() && flg2) rrt++;
					if (sst3.size() == 3 && st3.find(a[i][j]) != st3.end() && flg3) rrt++;
					if (sst4.size() == 3 && st4.find(a[i][j]) != st4.end() && flg4) rrt++;
					// if (i == 4 && j == 5){
					// 	wtsp(c), wtln(rrt);
					// }
					ckmax(tot, rrt);
				}
				cnt += tot;
			}
			else{
				int flg1 = 0, flg2 = 0, flg3 = 0, flg4 = 0;
				set<int> sst1 = st1, sst2 = st2, sst3 = st3, sst4 = st4;
				sst1.insert(a[i][j]), sst2.insert(a[i][j]), sst3.insert(a[i][j]), sst4.insert(a[i][j]);
				if (sst1.size() == 2) flg1++;
				if (sst2.size() == 2) flg2++;
				if (sst3.size() == 2) flg3++;
				if (sst4.size() == 2) flg4++;
				// wtsp(flg1), wtsp(flg2), wtsp(flg3), wtln(flg4);
				// wtsp(st1.size()), wtsp(st2.size()), wtsp(st3.size()), wtln(st4.size());
				st1.insert(k), st2.insert(k), st3.insert(k), st4.insert(k);
				if (st1.size() == 3 && flg1) cnt++;
				if (st2.size() == 3 && flg2) cnt++;
				if (st3.size() == 3 && flg3) cnt++;
				if (st4.size() == 3 && flg4) cnt++;
			}
			// if (st1.size() == 3) cnt++;
			// if (st2.size() == 3) cnt++;
			// if (st3.size() == 3) cnt++;
			// if (st4.size() == 3) cnt++;
			// wtsp(i), wtsp(j), wtln(cnt);
			ckmax(ret, cnt);
		}
	}
	write(ret);
}
```

---

## 作者：Wangjinhao120127 (赞：3)

## 题意
在 $n\times n$ 的矩阵中，选一个点改变其值，让它能给矩阵鲜艳度带来最大贡献。

## 思路
因为 $n<=270$，只能改一个点，且改一个点只会影响周围4个区块，所以可以直接枚举改哪个点，并重新计算它带来的鲜艳度增量。

一个点可以改很多颜色，$k<10^9$ ，复杂度大。

但观察到周围四个区块最多只有 $9$ 种颜色，通过鸽笼原理（抽屉原理），可以得到任意 $9$ 个颜色中一定有与周围都不重复的颜色，为了方便，我们可以直接枚举 $1$ 到 $10$ 来作为新颜色，就不用枚举整个 $k$ 了。

## 时间复杂度

求总鲜艳度：$O(n^2)$

对于每个点更改颜色：$O(n^2)$  (在上文中， 我们把$k$ 降为了 $10$ 的常数，可以省略)

总复杂度：$O(n^2)$

## 代码

为了方便解题，可以用模块化的方法。

模块化可以增加代码可读性，让代码更容易debug，主逻辑简短明确。

#### 模块一：鲜艳度计算

```cpp
bool xyz(long long x, long long y)
{
	if(x == n || y == n || x == 0 || y == 0) return 0; //若区块非法，直接返回0
	long long cls = 1; //区块内默认有一个颜色（右上角）
	if(a[x + 1][y] != a[x][y]) cls ++;
	if(a[x + 1][y + 1] != a[x][y] && a[x + 1][y + 1] != a[x + 1][y]) cls ++;
	if(a[x][y + 1] != a[x][y] && a[x][y + 1] != a[x + 1][y + 1] && a[x][y + 1] != a[x + 1][y]) cls ++;
	return cls >= 3;
} // 求区块是否鲜艳
```

#### 模块二：计算改一个颜色后的周围区块鲜艳度

```cpp
long long adv(long long x, long long y, long long c)
{
	long long lc = a[x][y]; //last colour 原来颜色，用于复原
	a[x][y] = c;//c是新颜色
	long long sum = 0;
	sum += xyz(x - 1, y - 1);
	sum += xyz(x, y);
	sum += xyz(x - 1, y);
	sum += xyz(x, y - 1);
//周围区块鲜艳度
	a[x][y] = lc;//记得复原，方便后续计算
	return sum;
} //求新颜色改变后周围区块的值
```

#### 主逻辑

```cpp
long long sco = 0;//sco表示原来总鲜艳度
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			sco += xyz(i, j);/求sco
		}
	}
	
	long long ma = 0;//max add 最大贡献
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			long long lv = adv(i, j, a[i][j]);//原来4个区块鲜艳度
			long long nv = 0;//新的鲜艳度
			for(int c = 1; c <= min(k, 10ll); c ++)
			{
				nv = adv(i, j, c);
				ma = max(ma, nv - lv);//nv - lv是改变这个点后的贡献
			}
		}
	}

//最后总答案用原来鲜艳度+最大贡献 ：sco + ma
```
#### 总代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, k, a[275][275];
bool xyz(long long x, long long y)
{
	if(x == n || y == n || x == 0 || y == 0) return 0;
	long long cls = 1;
	if(a[x + 1][y] != a[x][y]) cls ++;
	if(a[x + 1][y + 1] != a[x][y] && a[x + 1][y + 1] != a[x + 1][y]) cls ++;
	if(a[x][y + 1] != a[x][y] && a[x][y + 1] != a[x + 1][y + 1] && a[x][y + 1] != a[x + 1][y]) cls ++;
	return cls >= 3;
} // 求是否鲜艳

long long adv(long long x, long long y, long long c)
{
	long long lc = a[x][y];
	a[x][y] = c;
	long long sum = 0;
	sum += xyz(x - 1, y - 1);
	sum += xyz(x, y);
	sum += xyz(x - 1, y);
	sum += xyz(x, y - 1);
	a[x][y] = lc;
	return sum;
} //求新颜色改变后周围区块的值

int main()
{
	cin >> n >> k;
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			cin >> a[i][j];
		}
	}
	
	long long sco = 0;
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			sco += xyz(i, j);
		}
	}
	
	long long ma = 0;
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			long long lv = adv(i, j, a[i][j]);
			long long nv = 0;
			for(int c = 1; c <= min(k, 10ll); c ++)
			{
				nv = adv(i, j, c);
				ma = max(ma, nv - lv);
			}
		}
	}
	
	cout << sco + ma;
	return 0;
}
```

谢谢观看！

---

## 作者：canwen (赞：3)

一个比较理想的修改方式是在 $3\times3$ 的网格上，设中间那个格子为 $(i,j)$，则将 $(i,j)$ 修改成与 $(i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)$ 八个格子都不同的颜色从而看是否能更大值。

但是 $K\le10^{9}$ 有点吓人，考虑缩小范围，不难发现八个格子最多只有八种不同的颜色，也就是当 $K$ 足够大的的时候，枚举 $1\sim 9$ 一定能找到一个与**四周八个格子**都不同颜色的颜色，所以我们可以先 $K \gets \min(K,9)$，然后遍历网格，遍历能改的颜色，取最大的贡献即可。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar();return k*kk;}
void out(int a){if(a<0) putchar('-'),a=-a;if(a>9) out(a/10);putchar('0'+a%10);}

int s[271][271],n,k,maxans,ans;
set <int> ss; 
int pd(int i,int j){
	ss.clear();
	ss.insert(s[i][j]), ss.insert(s[i][j+1]), ss.insert(s[i+1][j]), ss.insert(s[i+1][j+1]);
	return (int)ss.size();	
}
int pd2(int i,int j){
	int res = 0;
	if(i>1&&j>1){
		ss.clear();
		ss.insert(s[i-1][j-1]), ss.insert(s[i-1][j]), ss.insert(s[i][j-1]), ss.insert(s[i][j]);
		if(ss.size()>=3) res++;
	}
	if(i>1&&j<n){
		ss.clear();
		ss.insert(s[i-1][j]), ss.insert(s[i-1][j+1]), ss.insert(s[i][j]), ss.insert(s[i][j+1]);
		if(ss.size()>=3) res++;
	}
	if(i<n&&j>1){
		ss.clear();
		ss.insert(s[i][j-1]), ss.insert(s[i][j]), ss.insert(s[i+1][j-1]), ss.insert(s[i+1][j]);
		if(ss.size()>=3) res++;
	}
	if(i<n&&j<n){
		ss.clear();
		ss.insert(s[i][j]), ss.insert(s[i][j+1]), ss.insert(s[i+1][j]), ss.insert(s[i+1][j+1]);
		if(ss.size()>=3) res++;
	}
	return res;
}
signed main(){
	n=in(),k=in();
	_rep(i,1,n){
		_rep(j,1,n) s[i][j]=in();
	}
	_rep(i,1,n-1){
		_rep(j,1,n-1){
			if(pd(i,j)>=3) ans++;
		}
	}
	_rep(i,1,n){
		_rep(j,1,n){
			int last = s[i][j], g = pd2(i,j);
			_rep(z,1,min(k,(int)9)){
				if(z==last) continue;
				s[i][j]=z;
				int gg = pd2(i,j);
				if(gg>g) maxans=max(maxans,gg-g);
				if(maxans == 4) break;
			}
			s[i][j] = last;
            if(maxans == 4) break;
		}
        if(maxans == 4) break;
	}
	out(ans+maxans);
	return 0;
}
```

---

## 作者：DeepSeekR1 (赞：2)

一个颜色格子最多被它周围的 4 个方框包含，所以可以先求出不修改的答案。然后枚举修改哪个格子，更新它周围的 $4$ 个方框记录答案。

在 $k>9$ 时，在一定会存在一种颜色在周围 $4$ 个方框共 $9$ 个格子中都没有。所以直接把 $(i,j)$ 改成这种没有的颜色一定是不劣的。因为对于任意一个 $(i,j)$，都存在这种颜色，所以为了方便可以直接把 $(i,j)$ 改称一个不存在的颜色 $0$。

```cpp
int x = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
nt A = a[i][j];
a[i][j] = 0;
int y = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
ans = max(ans,sum + y - x);
```

在 $k\le9$ 时，周围 $9$ 个格子有可能会包含所有的颜色，但是这种情况 $k$ 很小，可以直接枚举所有颜色的答案取 $\max$。

```cpp
for (int K = 1;K <= k;K++) {
    int x = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
    int A = a[i][j];
    a[i][j] = K;
    int y = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
    ans = max(ans,sum + y - x);
    a[i][j] = A;
}
```

把所有的 $(i,j)$ 的答案取 $\max$ 就是最终的答案了

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int a[506][506];
int b[506][506];
int sum,ans;
int f (int i,int j) {
    if (1 <= i && i < n && 1 <= j && j < n) {
        
    } else {
        return 0;
    }
    set <int> st;
    st.insert(a[i][j]);
    st.insert(a[i + 1][j]);
    st.insert(a[i][j + 1]);
    st.insert(a[i + 1][j + 1]);
    return st.size();
}
signed main () {
    cin >> n >> k;
    for (int i = 1;i <= n;i++) {
        for (int j = 1;j <= n;j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 1;i < n;i++) {
        for (int j = 1;j < n;j++) {
            b[i][j] = f(i,j);
            if (b[i][j] >= 3) {
                sum++;
            }
        }
    }
    ans = sum;
    for (int i = 1;i <= n;i++) {
        for (int j = 1;j <= n;j++) {
            if (k <= 9) {
                for (int K = 1;K <= k;K++) {
                    int x = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
                    int A = a[i][j];
                    a[i][j] = K;
                    int y = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
                    ans = max(ans,sum + y - x);
                    a[i][j] = A;
                }
            } else {
                int x = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
                int A = a[i][j];
                a[i][j] = 0;
                int y = (f(i,j) >= 3) + (f(i - 1,j) >= 3) + (f(i,j - 1) >= 3) + (f(i - 1,j - 1) >= 3);
                ans = max(ans,sum + y - x);
                a[i][j] = A;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Lacuna (赞：2)

容易想到，我们可以算出包含当前格子的矩阵中存在符合条件的矩阵个数。然后将该格子修改为一个与周围格子都不同的颜色，算出符合条件的矩阵个数再减去修改前的，然后取最大值。

但这里有一个问题，当 $k \le 9$ 时，这个格子周围的矩阵有可能包含所有的颜色，这样我们就没有办法再添加一种新的颜色进去，考虑到 $k$ 很小，我们可以直接枚举颜色，将该颜色格子修改为 $1 \sim k$ 的所有情况全部算一遍，取最大值就行。

所以这题我们要分两种情况：当 $k \le 9$ 时，我们将所有颜色都修改一遍取最大值，当 $k > 9$ 时，将该格子修改为一个与周围格子都不同的颜色。

最坏时间复杂度 $O(n ^ 2 \times k)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 275
int n,k;
int mp[N][N];
int ans,sum;
int cnt(int x,int y){
  if(1>x||1>y||n<=x||n<=y)
    return 0;
  set<int> s;
  s.insert(mp[x][y]);
  s.insert(mp[x+1][y]);
  s.insert(mp[x][y+1]);
  s.insert(mp[x+1][y+1]);
  return (s.size()>=3);
} 
int main(){
  scanf("%d%d",&n,&k);
  for(int i=1;i<=n;i++) 
    for(int j=1;j<=n;j++)
	  scanf("%d",&mp[i][j]); 
  for(int i=1;i<=n;i++)
  	for(int j=1;j<=n;j++)
  	  sum+=cnt(i,j);
  for(int i=1;i<=n;i++){
  	for(int j=1;j<=n;j++){
  	  int tmp=mp[i][j];
  	  int pre=cnt(i,j)+cnt(i-1,j)+cnt(i,j-1)+cnt(i-1,j-1);
  	  if(k>=10){
  	    mp[i][j]=-1;
  	    int now=cnt(i,j)+cnt(i-1,j)+cnt(i,j-1)+cnt(i-1,j-1);
  	    ans=max(ans,now-pre);
	  }else{
	  	for(int c=1;c<=k;c++){
	  	  int tmp=mp[i][j];
	  	  mp[i][j]=c;
	  	  int now=cnt(i,j)+cnt(i-1,j)+cnt(i,j-1)+cnt(i-1,j-1);
  	      ans=max(ans,now-pre);
		} 
	  }
	  mp[i][j]=tmp;
	}
  }
  printf("%d\n",sum+ans);
  return 0;
} 
```

---

## 作者：JZJR_A_0 (赞：2)

## 前置知识

* 贪心
* 模拟

## 题意

给定 $n\cdot n$ 大小的矩阵和 $k$ 种颜色，答案为 $2\cdot 2$ 大小矩阵中有至少三种颜色的个数，至多可以修改一个点。

## 思路

$n$ 很小，直接考虑暴力。

发现当修改点和周围点的颜色不同时一定更优，所以 $1 \sim \min(9,k)$ 暴力枚举即可。

## 实现

模拟即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=305;
int a[N][N];
int k[N][N];
int n,as;
inline int check(int x,int y){
	if(x<1||x>n||y<1||y>n)return 0;
	int b[5]={0,a[x][y],a[x+1][y],a[x][y+1],a[x+1][y+1]};
	sort(b+1,b+5);
	int cnt=0;
	for(int i=1;i<=4;i++){
		if(b[i]!=b[i-1])cnt++;
	}
	if(cnt>=3)return 1;
	return 0;
}
int main (){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>as;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)cin>>a[i][j];
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<n;j++){
			if(check(i,j)){
				k[i][j]++;k[i+1][j+1]++;
				k[i+1][j]++;k[i][j+1]++;
			}
		}
	}
	int ans=0,asd=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)asd+=k[i][j];
	}
	asd/=4;ans=asd;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int last=a[i][j];
			for(int sd=1;sd<=min(as,9);sd++){
				a[i][j]=sd;
				int el=check(i-1,j-1)+check(i-1,j)+check(i,j-1)+check(i,j);
				ans=max(ans,asd+el-k[i][j]);
			}
			a[i][j]=last;
			
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Dollartree (赞：1)

### 解题思路
1. 因为一个格子的改变最多影响周围 $4$ 个 $2 \times 2$ 的矩阵，而这 $4$ 个 $2 \times 2$ 的矩阵包含 $9$ 个格子。这意味着一次操作最多涉及 $9$ 种颜色。

2. 所以我们可以先求出原海报的鲜艳程度，并枚举每个格子，当 $K \le 8$ 时，枚举每种颜色，算出操作前和操作后这八个格子的鲜艳程度，并算出变化量。而当 $K > 8$ 时，一定有一种颜色与周围 $8$ 个格子不同，因此，计算鲜艳程度的规则变为，这 $4$ 个 $2 \times 2$ 的矩阵中，除了要改变的格子外，有两种元素的 $2 \times 2$ 矩阵个数，并求出操作前这八个格子的鲜艳程度（和 $K \le 8$ 类似），并算出变化量。

3. 最后将原海报的鲜艳程度加上最大的变化量即可，其他的看代码。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[300][300];
int check1(long long x1,long long x2,long long x3,long long x4)//计算当四个元素是x1，x2，x3，x4时，这四个元素所组成的矩阵的鲜艳值 
{
	if(x1*x2*x3*x4==0)//因颜色值大于等于1，可以利用此性质不判边界 
	{
		return 0;
	}
    set<long long> colors;
    colors.insert(x1);
    colors.insert(x2);
    colors.insert(x3);
    colors.insert(x4);
    if(colors.size()>=3)
	{
        return 1;
    }
    return 0;
}
int check2(long long x1,long long x2,long long x3)//K>8时变化后的规则 
{
	if(x1*x2*x3==0)
	{
		return 0;
	}
    set<long long> colors;
    colors.insert(x1);
    colors.insert(x2);
    colors.insert(x3);
    if(colors.size()>=2)
	{
        return 1;
    }
    return 0;
}
int check3(int x,int y) 
{
	return check1(a[x][y],a[x-1][y],a[x][y-1],a[x-1][y-1]);
}
int check4(int x,int y)
{
	int cnt=0;
	for(int i=x;i<=x+1;++i)
	{
		for(int j=y;j<=y+1;++j)
		{
			cnt+=check3(i,j);
		}
	}
	return cnt;
}
int check5(int x,int y,long long k)//计算K<=8时的变化量 
{
	int cnt=0;
	cnt+=check1(a[x-1][y-1],a[x][y-1],a[x-1][y],k);
	cnt+=check1(a[x-1][y],a[x][y+1],a[x-1][y+1],k);
	cnt+=check1(a[x+1][y+1],a[x+1][y],a[x][y+1],k);
	cnt+=check1(a[x+1][y],a[x+1][y-1],a[x][y-1],k);
	cnt-=check4(x,y);
	return cnt;
}
int check6(int x,int y)
{
	int cnt=0;
	cnt+=check2(a[x-1][y-1],a[x][y-1],a[x-1][y]);
	cnt+=check2(a[x-1][y],a[x][y+1],a[x-1][y+1]);
	cnt+=check2(a[x+1][y+1],a[x+1][y],a[x][y+1]);
	cnt+=check2(a[x+1][y],a[x+1][y-1],a[x][y-1]);
	cnt-=check4(x,y);
	return cnt;
}
int main(){
    int N;
	long long K;
    cin>>N>>K;
    for(int i=1;i<=N;++i) 
	{
        for(int j=1;j<=N;++j) 
		{
            cin>>a[i][j];
        }
    }
    long long init=0;//初始鲜艳程度 
    for(int i=2;i<=N;++i) 
	{
        for(int j=2;j<=N;++j) 
		{
			init+=check3(i,j);
        }
    }
    int mmax=0;
    for(int i=1;i<=N;i++) 
	{
        for(int j=2;j<=N;j++) 
		{
			if(K<=8)
			{
				for(int k=1;k<=K;++k)
				{
					mmax=max(mmax,check5(i,j,k));
				}
			}
			else
			{
				mmax=max(mmax,check6(i,j));
			}
        }
    }
    cout<<init+mmax;
}
```

---

## 作者：yedalong (赞：1)

挺简单的模拟题。

## Solution

由于只有可能修改一个点，因此我们可以直接枚举那个修改的点，至于它要修改成什么，我分了两种情况讨论。

第一种情况就是这个点周围 $8$ 格内不同颜色的个数小于 $k$，这说明了什么？这说明了一定存在一种颜色，使得与周围 $8$ 格的颜色不同。那我们就可以给他赋值为 $-1$，再跑一遍算一下增加了多少贡献。

第二种情况就是这个点周围 $8$ 格内不同颜色的个数大于等于 $k$，这又说明了什么？这说明了无论我们选哪种颜色，一定会跟周围 $8$ 格的其中几格颜色相同。但达成这种条件还有一个特别友好的限制，就是 $k\le9$，自己可以想想为什么。看到 $k$ 那么小，那不就可以直接暴力枚举 $k$ 了吗？于是，就解决了。

## AC code

虽然我的代码长的要死，但是终究是一遍过了这道题。。。\
可以结合注释理解理解。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,a[275][275],ans,cnt;
int check(int i,int j){//此函数用于计算周围四格内不同颜色的个数
	if(!i||!j||i==n||j==n) return 0;//非法情况（越界了）
	int cnt=0;
	map<int,bool> mp;
	if(!mp[a[i][j]]) mp[a[i][j]]=1,cnt++;
	if(!mp[a[i+1][j]]) mp[a[i+1][j]]=1,cnt++;
	if(!mp[a[i][j+1]]) mp[a[i][j+1]]=1,cnt++;
	if(!mp[a[i+1][j+1]]) mp[a[i+1][j+1]]=1,cnt++;
	return cnt;
}
int main(){
	cin>>n>>k;
	for(int i = 1;i<=n;i++) for(int j = 1;j<=n;j++) cin>>a[i][j];
	for(int i = 1;i<n;i++){
		for(int j = 1;j<n;j++){
			if(check(i,j)>=3) cnt++;//先算出有多少鲜艳度
		}
	}
	ans=cnt;
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=n;j++){
			int num=0;
			map<int,bool> mp;
			mp[0]=1;
			for(int ii = i-1;ii<=i+1;ii++){
				for(int jj = j-1;jj<=j+1;jj++){
					if(!mp[a[ii][jj]]) mp[a[ii][jj]]=1,num++;//先计算周围8格（包括自己）有多少种颜色
				}
			}
			if(num<k){//第一种情况
				num=0;
				int tmp=a[i][j];
				a[i][j]=-1;
				for(int ii = i-1;ii<=i;ii++){
					for(int jj = j-1;jj<=j;jj++){
						if(check(ii,jj)>=3) num++;//计算出更新后周围四处的鲜艳度
					}
				}
				a[i][j]=tmp;
				for(int ii = i-1;ii<=i;ii++){
					for(int jj = j-1;jj<=j;jj++){
						if(check(ii,jj)>=3) num--;//减去原本就鲜艳的
					}
				}
				ans=max(ans,cnt+num);//更新答案
			}
			else{//第二种情况
				int tmp=a[i][j];
				for(int kk = 1;kk<=k;kk++){//暴力枚举
					num=0;
					a[i][j]=kk;
					for(int ii = i-1;ii<=i;ii++){
						for(int jj = j-1;jj<=j;jj++){
							if(check(ii,jj)>=3) num++;//计算出更新后周围四处的鲜艳度
						}
					}
					a[i][j]=tmp;
					for(int ii = i-1;ii<=i;ii++){
						for(int jj = j-1;jj<=j;jj++){
							if(check(ii,jj)>=3) num--;//减去原本就鲜艳的
						}
					}
					ans=max(ans,cnt+num);//更新答案
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：末然Ender (赞：1)

# 题解：P11724 [JOIG 2025] ポスター 2 / Poster 2

## 思路

观察范围，$N$ 很小。完全可以枚举每一个格子操作。

题目分为两种情况，就是进行那一次修改操作或者不进行操作。

先考虑不进行修改操作的情况，我们可以枚举每个 $2 \times 2$ 的子矩阵，进行判断，我们将这个子矩阵是否合法的信息储存到一个数组里，判断程序如下：

```cpp
bool check(int x,int y) {//子矩阵左上角的坐标
	ll q=a[x][y],w=a[x+1][y],e=a[x][y+1],r=a[x+1][y+1];
	ll ret=(q==w)+(q==e)+(q==r)+(w==e)+(w==r)+(e==r);
    //如果该子矩阵合法，那么颜色相同的格子对数目至多为 1 对。
	return (ret<=1);
}
```

我们将合法的小子矩阵数目记录下来即为不操作时的答案。

接下来考虑操作。

由于至多进行一次操作，而操作又只会影响周围的至多 $4$ 个格子，所以我们依然可以遍历整个矩阵修改每个格子的颜色。

如果最多有 $9$ 个及以上个颜色，即 $k \ge 9$，说明我完全可以将这个颜色设置成一个与相邻的颜色都不一样的颜色，我们不妨直接把这个点的颜色设置成 $0$ 号颜色，再比较包含该格子的那至多四个的矩阵，看看有多少个合法的变成不合法的，多少不合法的变成合法的，然后在不进行操作时得到的答案上进行统计出此时的答案，取最大值即可。

当然，如果最多每有 $9$ 个颜色，即 $k < 9$，那 $9$ 这个数字其实很小，我们不妨将该格子的颜色从 $1$ 到 $k$ 遍历一遍，也并不消耗时间。

时间复杂度不超过 $O(9 \cdot n^2)$，跑起来飞快。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
//#define getchar getchar_unlocked
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
const int N=1200,mod=1e9+7;
ll a[N][N];
ll n,k;
ll ans,res;
bool ma[N][N];
bool check(int x,int y) {
	ll q=a[x][y],w=a[x+1][y],e=a[x][y+1],r=a[x+1][y+1];
	ll ret=(q==w)+(q==e)+(q==r)+(w==e)+(w==r)+(e==r);
	return (ret<=1);
}
void comp(int x,int y){
	ll ret=0;
	if(x>1&&y>1)ret+=check(x-1,y-1)-ma[x-1][y-1];
	if(x>1&&y<n)ret+=check(x-1,y)-ma[x-1][y];
	if(x<n&&y>1)ret+=check(x,y-1)-ma[x][y-1];
	if(x<n&&y<n)ret+=check(x,y)-ma[x][y];
	ans=max(ans,res+ret);
}
int main() {
	read(n,k);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			read(a[i][j]);
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<n;j++){
			ma[i][j]=check(i,j);
			res+=ma[i][j];
		}
	}
	ans=res;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			ll b=a[i][j];
			if(k>=9){
				a[i][j]=0;
				comp(i,j);
			}else{
				for(int l=1;l<=k;l++){
					a[i][j]=l;
					comp(i,j);
				}
			}
			a[i][j]=b;
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：1)

题意：

一个 $n \times n$ 的正方形，每一小块都有一个颜色，你可以改变不超过 $1$ 个小正方形的颜色，求在这个大正方形中最多能有多少个 $2 \times 2$ 的正方形包含的颜色种类至少为 $3$。

思路：

时间限制很大，数据范围也很小，很明显可以枚举改变哪一个小正方形的颜色。但是其中的细节比较多。

首先可以先处理不操作时有多少个满足条件的正方形。一共有 $(n - 1) \times (n - 1)$ 个 $2 \times 2$ 的小正方形，如果这 $(n - 1) \times (n - 1)$ 个正方形都满足条件，则可以不用改变任意一个小正方形的颜色，直接输出答案。否则，枚举 $n \times n$ 个小正方形，并枚举改变成哪一种颜色。

枚举颜色时有一种小优化，就是只需要枚举 $\min(13,k)$ 种颜色就好了，因为改变这一个小正方形的颜色，最多只会影响 $4$ 个 $2 \times 2$ 的正方形，而这 $4$ 个正方形中最多有 $12$ 个不同颜色，加上改变当前这个小正方形的颜色，一共 $13$ 种，所以只要枚举 $\min(13,k)$ 中颜色就好了。

接着判断受影响的 $4$ 个正方形原来是不是满足条件的和现在是不是满足条件的情况，计算满足条件的正方形数量增加了还是减少了。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=305;
int n,k,ans,res,num;//ans是记录操作后增加或减少满足条件的正方形数量,res是原来就满足条件的正方形数量,num是2*2的正方形数量
int color[N][N];
bool vis[N*N];//判断第i个2*2的正方形原来是不是满足条件的
int id(int x,int y){return x>=2&&x<=n&&y>=2&&y<=n?(x-2)*n+(y-1):0;}//给每一个2*2的正方形的编号
bool check(int x,int y){//判断以右下角坐标为(x,y)的正方形是否满足条件
	int a1=color[x-1][y-1];
	int a2=color[x][y-1];
	int a3=color[x-1][y];
	int a4=color[x][y];
/*	cout<<"ID="<<id(x,y)<<endl;
	cout<<x-1<<" "<<y-1<<"  "<<x<<" "<<y<<endl;
	cout<<x-1<<" "<<y<<"  "<<x<<" "<<y<<endl; 
	cout<<a1<<" "<<a2<<endl;
	cout<<a3<<" "<<a4<<endl;
*/	set<int>s;
	s.insert(a1);
	s.insert(a2);
	s.insert(a3);
	s.insert(a4);
	return s.size()>=3;
}
signed main(){
	IOS;cin>>n>>k;num=(n-1)*(n-1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>color[i][j];
		}
	}for(int i=2;i<=n;i++){//初始化
		for(int j=2;j<=n;j++){
			if(check(i,j))res++,vis[id(i,j)]=true;
		}
	}if(res==(n-1)*(n-1)){cout<<res;return 0;}//都满足条件不用操作
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){//枚举改变颜色的小正方形的坐标
			for(int c=1;c<=min(k,13ll);c++){//颜色
				int x=i,y=j;bool che;
				int co=color[i][j],cnt=0;
				if(co==c)continue;//颜色相同就不用改
				//cout<<i<<" "<<j<<" "<<co<<"->"<<c<<endl;
				color[i][j]=c;
				if(id(x,y)){
					che=check(x,y);
					if(vis[id(x,y)]&&!che)cnt--;
					else if(!vis[id(x,y)]&&che)cnt++;					
				}y++;
				if(id(x,y)){
					che=check(x,y);
					if(vis[id(x,y)]&&!che)cnt--;
					else if(!vis[id(x,y)]&&che)cnt++;						
				}x++;
				if(id(x,y)){
					che=check(x,y);
					if(vis[id(x,y)]&&!che)cnt--;
					else if(!vis[id(x,y)]&&che)cnt++;					
				}y--;
				if(id(x,y)){
					che=check(x,y);
					if(vis[id(x,y)]&&!che)cnt--;
					else if(!vis[id(x,y)]&&che)cnt++;						
				}ans=max(ans,cnt);//求最大增加的数量
				color[i][j]=co;	//改成原来的颜色
				//cout<<cnt<<endl;					
			}
		}
	}cout<<res+ans;//原来满足的+增加的
	return 0;
}
```

---

## 作者：Lyw_and_Segment_Tree (赞：1)

## 开始解题！

由于只能修改一次，所以我们可以枚举修改的位置 $(i, j)$，不妨假设 $(i, j)$ 为右下角，那么可以画一张图出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/roohtkii.png)

从图中可以看出，要想统计这九宫格中有几个矩阵满足颜色个数不小于 $3$，只需要看以 $(i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)$ 为右下角的 $2 \times 2$ 矩阵有几个满足其颜色个数不小于 $3$。

所以在修改时，我们可以先算出修改前这九宫格中满足条件的矩阵数量 $t1$，然后修改 $(i, j)$ 的颜色，再算一遍，得到数量 $t2$，那么将 $(i, j)$ 修改颜色所产生的贡献即为 $t2 - t1$，注意最后要修改回去。

那么我们可以枚举改成的颜色 $c$，由于是九宫格，所以 $c \in \{1, \min(k, 9)\}$，因为我们关心的是颜色是否相同，与颜色本身是多少关联不大，而九宫格最多九种颜色，所以枚举即可。

然后记得要先算出一开始的答案 $res$，然后枚举修改的位置 $(i, j)$，设产生了 $now$ 的贡献，则要让 $ans = \max(ans, now + res)$，最后输出 $ans$，注意一开始 $ans = 0$。

做完了。

最后注意边界的处理，作者因为边界挂了几发。

作者缺省源比较长，实际代码很短，主要部分在主函数。

code : 

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define vec vector
#define pll pair<ll, ll>
#define mkp make_pair
#define endl "\n"

using namespace std;

const ll mod = 998244353;

const ll maxn = 3;

namespace fastio {
	char buf[1 << 21], *p1 = buf, *p2 = buf;
	
	const ll getc() {
	    return p1 == p2 && ( p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++;
	}
	
	const ll read() {
		ll x = 0, f = 1;
		
		char ch = getc();
		
		while (ch < '0' || ch > '9') {
			if (ch == '-') f = -1; ch = getc();
		}
		
		while (ch >= '0' && ch <= '9') {
			x = (x << 1) + (x << 3) + (ch ^ 48), ch = getc();
		}
		
		return x * f;
	}
	
	const void write(ll x) {
		if (x < 0) {
			putchar('-'), x = -x;
		}
		
	    ll sta[35], top = 0;
	    
	    do {
	        sta[top++] = x % 10, x /= 10;
	    } while (x);
	    
	    while (top) putchar(sta[--top] + 48);
	}
}

namespace math {
    vector<ll> fac, inv;
    
    void init(ll sz) {
        fac.resize(sz + 5), inv.resize(sz + 5);
        
        fac[0] = fac[1] = inv[0] = inv[1] = 1;
        
        for (ll i = 2; i <= sz; i++) {
            fac[i] = fac[i - 1] % mod * i % mod;
            
            inv[i] = (mod - inv[mod % i] * (mod / i) % mod) % mod; 
        }
        
        for (ll i = 2; i <= sz; i++) {
            inv[i] *= inv[i - 1] % mod, inv[i] %= mod;
        }
    }
    
    ll A(ll n, ll m) {
        return fac[n] % mod * inv[n - m] % mod;
    }
    
    ll C(ll n, ll m) {
        return fac[n] % mod * inv[m] % mod * inv[n - m] % mod;
    }
}

ll qpow(ll a, ll b, ll m = 1) {
    if (b == 0) return 1 % m;
    
    ll ans = 1;
    
	while (b) {
        if (b & 1) ans = ans * a % m;
        
        a = a * a % m;
        
        b >>= 1;
    }
    
    return ans;
}

ll gcd(ll a, ll b) {
	return a == 0 || b == 0 ? max(a,b) : gcd(b, a % b);
}

ll lcm(ll a, ll b) {
    return a / gcd(a,b) * b;
}

ll lowbit(ll x) {
    return x & (-x);
}

ll popcount(ll x){
    ll res = 0;
    
    while (x) {
        x -= lowbit(x);
        
        res ++;
    }
    
    return res;
}

struct BIT {
	ll n = 0; std::vector<ll> c;
	
	BIT (ll sz) {
		n = sz, c.resize(sz + 5);
	};
	
	void add(ll x, ll y) {
		if (n == 0) {
			return ;
		} else {
			for (ll i = x; i <= n; i += lowbit(i)) {
				c[i] += y;
			}
		}
		
		return ;
	}
	
	ll sum(ll x) {
		ll res = 0;
		
		for (ll i = x; i; i -= lowbit(i)) {
			res += c[i];
		}
		
		return res;
	}
};

struct DSU { // 并查集
    ll n = 0; vector<ll> fa;
    
    DSU (ll sz) {
        n = sz, fa.resize(sz + 5);
    };
    
    void init() {
        if (n == 0) {
            return ;
        }
        
        for (ll i = 1; i <= n; i++) {
            fa[i] = i;
        }
    }
    
    ll find(ll x) {
        return x == fa[x] ? x : find(fa[x]);
    }
    
    void merge(ll x, ll y) {
        x = find(x), y = find(y);
        
        if (x != y) {
            fa[x] = y;
        }
    }
};

// template<typename tp1,typename tp2,int N>
// struct Htb{
    // static constexpr int M=1e7+19;
    // int hd[M+3],to[N],ct;
    // tp1 ed[N];tp2 w[N];
    // static int hc(ul v){
        // v^=v<<13,v^=v>>7;
        // return (v^(v<<17))%M;
    // }
    // void ins(tp1 x,tp2 y){
        // int &p=hd[hc(x)];
        // ed[++ct]=x,to[ct]=p;
        // w[p=ct]=y;
    // }
    // int count(tp1 x){
        // for(int i=hd[hc(x)];i;i=to[i])
            // if(ed[i]==x)return 1;
        // return 0;
    // }
    // pair<tp2,bool>find(tp1 x){
        // for(int i=hd[hc(x)];i;i=to[i])
            // if(ed[i]==x)return mkp(w[i],true);
        // return mkp(0,false);
    // }
    // int operator[](tp1 x){
        // int &p=hd[hc(x)];
        // for(int i=p;i;i=to[i])
            // if(ed[i]==x)return i;
        // ed[++ct]=x,to[ct]=p;
        // return p=ct;
    // }
    // void clear(){while(ct)hd[hc(ed[ct--])]=0;}
// };

#define rd fastio::read
#define wt fastio::write
#define gc fastio::getc

ll n, m, q, a[305][305];

ll opt, l, r, ans = 0;

ll dx[] = {-1, -1, 0, 0};

ll dy[] = {-1, 0, -1, 0};

bool check(ll x, ll y) {
    set<ll> st;
    st.insert(a[x][y]), st.insert(a[x + 1][y]), st.insert(a[x][y + 1]), st.insert(a[x + 1][y + 1]);
    return (st.size() >= 3);
}

ll change(ll x, ll y, ll c) {
    ll t = a[x][y], t1 = 0, t2 = 0;
    
    for (ll i = 0; i < 4; i++) {
        ll nx = x + dx[i], ny = y + dy[i];
        
        if (nx >= 1 && ny >= 1 && nx < n && ny < n) {
            t1 += check(nx, ny);
        }
    }
    
    a[x][y] = c;
    
    for (ll i = 0; i < 4; i++) {
        ll nx = x + dx[i], ny = y + dy[i];
        
        if (nx >= 1 && ny >= 1 && nx < n && ny < n) {
            t2 += check(nx, ny);
        }
    }
    
    a[x][y] = t;
    
    return t2 - t1;
}

int main() {
	// ios::sync_with_stdio(false);
	// cin.tie(0), cout.tie(0);
    
    ll i, j, k, x, y, z, res = 0, now;
    
    n = rd(), m = rd();
    
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            a[i][j] = rd();
        }
    }
    
    for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
            res += check(i, j);
        }
    }
    
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            for (k = 1; k <= min(m, 9ll); k++) {
                now = change(i, j, k);
                
                ans = max(ans, res + now);
            }
        }  
    }
    
    wt(ans);
    
	return 0;
}
```

[AC record](https://www.luogu.com.cn/record/202985813)

---

## 作者：Hy13_xsm (赞：0)

## 前言

日本的题目感觉好简单。

## 题目大意（形式化）

有一个 $N\times N$ 的网格，每一格都填入了一个数字。如果一个 $2\times2$ 的网格中含有不小于 $3$ 个不同的数字，那么对答案贡献 $1$。现在要修改**至多**一个网格的数，最大化最终的贡献。

## Solution

先看数据范围，除了 $K\le 10^9$ 其他数据都挺小的，可以考虑暴力枚举。

因为题目要求**至多**修改一次，所以可以尝试枚举每一个格子分别修改成不同的颜色，然后计算出贡献值并统计最大值。那么有几个问题需要解释。

可问题是，$K$ 的范围太大了，这样枚举下去不会炸吗？所以说这个地方需要动脑筋思考一下。修改一个数对原本的贡献有什么影响？不难发现这只会影响到附近的 $4$ 个 $2\times2$ 矩阵，而就算附近所有格子的数互不相同，最多也就只会出现 $8$ 个不同的数。如果只在 $[1,K]$ 范围内选取 $10$ 个数的话，无论如何都有一个数与这 $8$ 个都不一样。所以说，**就算 $K$ 值再大，只枚举 $10$ 次都能找到最大贡献**（当然理论上 $9$ 次即可）。最后还有一个小细节，就是如果 $K$ 值比 $10$ 还小，那就只枚举到 $K$ 即可，因为更大的数不符合要求。

做这道题想到这一点就已经有答案了。这应该不是正解，但放在考场上，**只要能过就不用管那么多**。还有就是，~~这道题好像模拟。~~

## AC 代码


```cpp
#include<bits/stdc++.h>
#define N 1005
using namespace std;
int n,s,ans,cnt,a[N][N],b[N][N];
inline int calc(int x,int y)
{
	map<int,int>m;
	if(a[x][y])m[a[x][y]]++;
	if(a[x+1][y])m[a[x+1][y]]++;
	if(a[x][y+1])m[a[x][y+1]]++;
	if(a[x+1][y+1])m[a[x+1][y+1]]++;
	return m.size();
}//模拟不多说（k很大，数组存不下，只能用map） 
int main()
{
	cin>>n>>s;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	}
	for(int i=1;i<n;i++)
	{
		for(int j=1;j<n;j++)
		{
			b[i][j]=calc(i,j);
			if(b[i][j]>=3)ans++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int x=0,tmp=a[i][j];
			if(b[i][j]>=3)x++;//统计已经满足的格子 
			if(b[i-1][j]>=3)x++;
			if(b[i][j-1]>=3)x++;
			if(b[i-1][j-1]>=3)x++;
			for(int k=1;k<=min(s,10);k++)//枚举颜色 
			{
				int y=0;
				a[i][j]=k;
				if(calc(i,j)>=3)y++;
				if(calc(i-1,j)>=3)y++;
				if(calc(i,j-1)>=3)y++;
				if(calc(i-1,j-1)>=3)y++;
				cnt=max(cnt,y-x);
				a[i][j]=tmp;
			}//想想为什么10次就够了 
		}
	}
	cout<<ans+cnt;
	return 0;
}
```

---


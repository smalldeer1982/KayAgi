# [COCI 2024/2025 #5] 挂画 / Zid

## 题目背景

译自 [COCI 2024/2025 #5](https://hsin.hr/coci/) T2。$\texttt{1s,0.5G}$。满分为 $70$。


## 题目描述


有一面 $n$ 行 $m$ 列的矩形墙，被划分为 $n\times m$ 个区域。墙上有些区域有钉子，用 $\texttt{\#}$ 表示；其他的区域没有钉子，用 $\texttt{.}$。

现在要在墙上挂画。我们说一种挂画方式是合法的，当且仅当：

- 画占据墙上的一个矩形区域；
- 画占据的区域中**至多一个**区域存在钉子。

求出有多少种合法的挂画方式。

## 说明/提示


#### 样例解释

- 样例 $1$ 解释：随便怎么放都是合法的。

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le n\le 500$。

| 子任务编号 |  $n,m\le$ | 得分 |  
| :--: | :--: | :--: | 
| $ 1 $    |  $10$  |   $ 17 $   |  
| $ 2 $    |  $100$  |  $ 21 $   |  
| $ 3 $   |  $500$  | $32$ |


## 样例 #1

### 输入

```
3 3
...
...
..#```

### 输出

```
36```

## 样例 #2

### 输入

```
4 4
....
.#..
#...
#.#.```

### 输出

```
76```

## 样例 #3

### 输入

```
5 5
.....
#..#.
..#.#
.....
..#..```

### 输出

```
154```

# 题解

## 作者：niuniudundun (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11752)

upd 2025/3/5：关于 $38$ 号数据，改一个 `.` 变成 `#`，导致做法卡掉，可以将代码中 `s[n][m]==0` 换成 `s[n][m]<=1` 即可。

# 题目大意

一个 $n$ 行 $m$ 列的 $c$ 中，有多少个矩形使得 `#` 数量 $\le 1$。

# 题目解法

暴力 $O(n^3m^3)$ 显然不能过。

一眼的前缀和（不会搜百度）。

思路如下：

如果 $c_{i,j}$ 是 `#` 则令 $s_{i,j}=1$。随后再跑一遍 $s$，让 $s_{i,j}$ 加上以 $(i,j)$ 为左下角的矩阵和 $s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}$。然后使用四重循环计算 $(x_1,y_1)$ 到 $(x_2,y_2)$ 的和：$s_{x_2,y_2}-s_{x_1-1,y_2}-s_{x_2,y_1-1}+s_{x_1-1,y_{1}-1}$，如果和 $\le 1$ 则答案 $ans$ 加一。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=501;
int n,m;
int s[maxn][maxn];
int ans;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='#'){
				s[i][j]++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+s[i][j];
		}
	}
	for(int x1=1;x1<=n;x1++){
		for(int y1=1;y1<=m;y1++){
			for(int x2=x1;x2<=n;x2++){
				for(int y2=y1;y2<=m;y2++){
					int sum=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
					if(sum==1||sum==0){
						ans++;
					}
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
/*
3 3
...
...
..#
*/
```

然后你就得了 $38$ 分，[link](https://www.luogu.com.cn/record/203708462)。

复杂度有 $O(nm+n^2m^2)$，对于 $5\times 10^2$ 的数据显然不行。

考虑优化。可以优化的有：

1. 将单独跑 $s$ 的与上面合并，减少 $O(nm)$ 复杂度。
2. 如果 $(x_1,y_1)$ 到 $(x_2,y_2)$ 和大于一，那么 $(x_1,y_1)$ 到 $(x_2,y_2+1)$、$(x_1,y_1)$ 到 $(x_2,y_2+2)$、$(x_1,y_1)$ 到 $(x_2,y_2+3)$ 等也大于一，可以结束循环，剪枝。

得到：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=501;
int n,m;
int s[maxn][maxn];
int ans;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='#'){
				s[i][j]++;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+s[i][j];
		}
	}	
	for(int x1=1;x1<=n;x1++){
		for(int y1=1;y1<=m;y1++){
			for(int x2=x1;x2<=n;x2++){
				for(int y2=y1;y2<=m;y2++){
					int sum=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
					if(sum==1||sum==0){
						ans++;
					}else{
						break;
					}
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
/*
3 3
...
...
..#
*/
```

可以得到 $38$ 的分数，只 TLE 一个点，[link](https://www.luogu.com.cn/record/203708813)。

然后寄出一招——卡常小技巧：

1. 在变量前加 `register`。
2. `cin`、`cout` 改 `scanf`、`printf`。
3. 去掉多余变量。

然后得到：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=501;
int n,m;
int s[maxn][maxn];
int ans;
signed main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='#'){
				s[i][j]++;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+s[i][j];
		}
	}	
	for(register int x1=1;x1<=n;x1++){
		for(register int y1=1;y1<=m;y1++){
			for(register int x2=x1;x2<=n;x2++){
				for(register int y2=y1;y2<=m;y2++){
					if(s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]<=1){
						ans++;
					}else{
						break;
					}
				}
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
/*
3 3
...
...
..#
*/
```

可是问题没有解决，[link](https://www.luogu.com.cn/record/203711588)。

当下载了数据点 #38 你会发现 $500\times 500$ 个 `.`，上面做法会被卡成 $O(n^2m^2)$。

可以加一个特判 $s_{n,m}=0$ 时，说明没有一个 `.`，可以动用数学：

我们可以将这个问题转成：

> 在一个 $n\times m$ 的矩阵中有多少个子矩阵。

一个矩阵由左上角和右下角组成，枚举左上角有 $nm$ 个情况，右下角有 $(n+1)(m+1)$ 个情况，随后再抛出重复的矩阵 ${\div}4$，然后就是正确答案 $\dfrac{nm(n+1)(m+1)}{4} $。具体的可以自己推一推。

# 总 AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long maxn=501;
long long n,m,s[maxn][maxn],ans;
signed main(){
	scanf("%lld%lld",&n,&m);
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='#'){
				s[i][j]++;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+s[i][j];
		}
	}
	if(s[n][m]==0){
		printf("%lld",n*m*(n+1)*(m+1)/4);
		return 0;
	}
	for(register int x1=1;x1<=n;x1++){
		for(register int y1=1;y1<=m;y1++){
			for(register int x2=x1;x2<=n;x2++){
				for(register int y2=y1;y2<=m;y2++){
					if(s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]<=1){
						ans++;
					}else{
						break;
					}
				}
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
/*
3 3
...
...
..#
*/
```

---

## 作者：Silent_Void_Abyss (赞：2)

**先读题**

要解决这个问题，我们需要计算所有合法的挂画方式。合法的挂画方式要求画占据的区域是一个矩形，并且这个矩形中至多有一个钉子。    

我们需要减少枚举所有矩形的时间复杂度。直接枚举所有矩形的时间复杂度是 $O(n^2 * m^2)$  ，对于  $ n, m ≤ 500$ 来说，这显然会超时。

**解题思路**

固定矩形的一边：

我们可以固定矩形的一边（例如上边界），然后通过滑动窗口的方式枚举矩形的下边界。

对于每一对上下边界，我们可以通过前缀和快速计算每一列中钉子数量的前缀和，从而快速判断矩形是否合法。

滑动窗口优化：
对于每一对上下边界，我们维护一个滑动窗口，统计当前窗口内的钉子数量。

如果窗口内的钉子数量超过 $1$  ，则移动窗口的左边界，直到窗口内的钉子数量  $≤ 1$ 。

统计合法矩形：
对于每一对上下边界，统计所有合法的左右边界组合。

**代码**


```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    
    vector<string> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    
    // 计算列方向的前缀和
    vector<vector<int> > liesum(n + 1, vector<int>(m + 1, 0));
    for (int j = 1; j <= m; ++j) {
        for (int i = 1; i <= n; ++i) {
            liesum[i][j] = liesum[i - 1][j] + (a[i - 1][j - 1] == '#');
        }
    }
    
    long long ans = 0;
    
    // 枚举上边界
    for (int i1 = 1; i1 <= n; ++i1) {
        // 枚举下边界
        for (int i2 = i1; i2 <= n; ++i2) {
            // 滑动窗口的左右边界
            int left = 1, right = 1;
            int cnt = 0; // 当前窗口内的钉子数量
            
            // 滑动窗口
            while (right <= m) {
                // 计算当前列的钉子数量
                int colCnt = liesum[i2][right] - liesum[i1 - 1][right];
                cnt += colCnt;
                
                // 如果钉子数量超过 1，移动左边界
                while (cnt > 1) {
                    int leftColCnt = liesum[i2][left] - liesum[i1 - 1][left];
                    cnt -= leftColCnt;
                    left++;
                }
                
                // 统计合法的矩形数量
                ans += (right - left + 1);
                right++;
            }
        }
    }
    
    cout << ans << endl;
    
    return 0;
}
```
萌新第一次写题记，求过！

---

## 作者：zhoujunchen (赞：2)

做题思路
--

快速查询一个矩形区域钉子个数可以用二维前缀和实现，$4$ 层循环枚举左上和右下的坐标，复杂度 $O(n^2m^2)$ 会超时。

可以固定上下边界，滑动左右区间，可以用双指针，复杂度 $O(n^2m)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,sum[505][505],ans;
char a[505][505];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j];
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(a[i][j]=='#');
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			int l=1,r=1;
			while(r<=m){
				int cnt=sum[j][r]-sum[i-1][r]-sum[j][l-1]+sum[i-1][l-1];
				if(cnt<=1)ans+=(r-l+1),r++;
				else{
					l++;
					if(l>r)r=l;
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Barewalk (赞：2)

[P11752 biu ~ biu ~](https://www.luogu.com.cn/problem/P11752)

### Preface

比较套路题。

### Description

给定一个 $n \times m$ 的矩形网格，其中每个单元格为字符 `'.'` 或 `'#'`。

求该网格中所有满足下述条件的子矩阵的数量：

* 子矩阵为网格的一个连续区域，其内部最多包含一个 `'#'`。

其中，$1 \le n, m \le 500$。

### Solution

首先考虑暴力。枚举子矩阵的左上角和右上角，用前缀和与差分维护，$O(1)$ 判断是否给答案贡献。如果不会前缀和与差分，[看这里](https://oi-wiki.org/basic/prefix-sum/)。

总时间复杂度是 $O(n^2m^2)$，[38pts](https://www.luogu.com.cn/record/203932021)。

```cpp
cin >> n >> m;
for (int i = 1; i <= n; ++ i)
	for (int j = 1; j <= m; ++ j) {
		char c;
		cin >> c;
		s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + (c == '#');
		// 二位前缀和
	}
for (int i = 1; i <= n; ++ i)
	for (int j = 1; j <= m; ++ j)
		for (int k = i; k <= n; ++ k)
			for (int l = j; l <= m; ++ l) {
				int tmp = s[k][l] - s[k][j - 1] - s[i - 1][l] + s[i - 1][j - 1];
				// 二维差分
				ans += tmp < 2;
			}
cout << ans << '\n';
```

考虑正解。发现暴力是枚举两个点，我们可以枚举边，即长度与宽度。

从上往下枚举子矩阵的上边和下边，问题就变成了：

* 给定一个序列，求多少段区间的和小于 2。

也就是滑动窗口问题，双指针的基础应用。如果不会双指针，[看这里](https://oi-wiki.org/misc/two-pointer/)。

于是我们便得到了一个双重循环 + 滑动窗口的解法，总时间复杂度为 $O(n^2m)$，顺利通过本题。

Tips：如果你 wa on #38，请开 long long。

### Code

```cpp
#include <algorithm>
#include <cstring>
#include <iostream>
#define maxN 550
#define pii pair<int, int>
using ll = long long;
constexpr ll inf = 0x3f3f3f3f, mod = 1e9 + 7;
using namespace std;
int n, m, s[maxN];
char c[maxN][maxN];
int main() {
	cin.tie(nullptr) -> sync_with_stdio(false);
	cin >> n >> m;
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= m; ++ j) {
			cin >> c[i][j];
		}
	ll ans = 0; /*《== long long ! */
	for (int i = 1; i <= n; ++ i) {
		memset(s, 0, sizeof s);
		// 清空
		for (int j = i; j <= n; ++ j) {
			for (int k = 1; k <= m; ++ k) {
				s[k] += c[j][k] == '#';
			}
			// 下边每往下移一行，序列就加一行
			int l = 1, sum = 0;
			for (int r = 1; r <= m; ++ r) {
				sum += s[r];
				while (l <= r && sum > 1) {
					sum -= s[l ++];
				}
				ans += r - l + 1;
			}
		}
	}
	cout << ans << '\n';
	return 0;
}
```

感谢你的观看。

---

## 作者：__yrq__ (赞：1)

## 思路：

$O(n^4)$ 的做法应该是个人都会写吧，但显然它只能得到 $38$ 分，我们考虑怎么优化。

显然，如果一个矩形里只有一个及以下的钉子，那么这个矩形所包含的所有矩形中的钉子数量肯定也不超过一个。

那么我们考虑用双指针进行优化。

和 $O(n^4)$ 的做法一样，我们还是需要预处理出二维前缀和，不过循环的顺序要换一下。

我们要先枚举矩形的左上角和右下角所在的行，然后对左上角和右下角所在的列进行双指针即可。

注意统计答案的时候不是记录 while 循环运行了多少次，而是记录右下角所在的列 $-$ 左上角所在的列 $+ 1$。

最后注意要开 long long。

## 代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char c[505][505];
int n,m,s[505][505],s1=0;
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c[i][j];
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
			if(c[i][j]=='#') s[i][j]++;
		}
	for(int x=1;x<=n;x++)
		for(int xx=x;xx<=n;xx++)
			for(int y=1,yy=y;y<=m;y++)
			{
				while(yy<=m&&s[xx][yy]-s[xx][y-1]-s[x-1][yy]+s[x-1][y-1]<=1) yy++;
				s1+=yy-y;
			}
	cout<<s1<<endl;
    return 0;
}
```

---

## 作者：JYX0924 (赞：1)

这道题可以枚举、前缀和加二分。

首先，我们要算出前缀和 $sum_{i,j}$。然后枚举左上角 $(x_{1},y_{1})$ 以及右下角的横坐标 ${x_{2}}$，然后二分找到最后一个满足矩形中 ```#``` 数量小于等于 $1$ 的位置即可。

代码常数不大，可以过。

下面是我的 AC 代码。


```cpp
#include<bits/stdc++.h>
#define ll long long 
#define maxn 505 
using namespace std;
ll n,m,ans,sum[maxn][maxn];
char s[maxn][maxn];
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>m; for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>s[i][j],sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1],sum[i][j]+=(s[i][j]=='#');
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		for(int k=i;k<=n;k++)
		{
			ll l=j,r=m;
			while(l<r)
			{
				ll mid=(l+r)>>1;
				if(sum[k][mid]+sum[i-1][j-1]-sum[k][j-1]-sum[i-1][mid]<=1) l=mid;
				else r=mid-1;
				if((l+r)>>1==mid) break;
			}
			for(int mid=r;mid>=l;mid--) if(sum[k][mid]+sum[i-1][j-1]-sum[k][j-1]-sum[i-1][mid]<=1) {ans+=mid-j+1; break;}
		}
	}
	cout<<ans;
	return 0;
}
```
谢谢大家！！！

---

## 作者：Circle_Table (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11752)

看到这题的第一想法是用前缀和。用数组 $a$ 记录 $a[i][j]$左上方的钉子数量之和，先抽象出以下图形：
![](https://cdn.luogu.com.cn/upload/image_hosting/x8iepylb.png)

以 $S(ABCD)$代表矩形 $ABCD$ 中的钉子数量。那么，在图中，如果需要求 $S(PHCF)$ ，易知：

$S(PHCF)=S(ABCD)-S(EBHP)-S(GPDF)-S(AEPG)$

那么我们在上式中间两项分别加上 $S(AEPG)$，得：

$S(PHCF)=S(ABCD)-S(ABHG)-S(AEDF)+S(AEPG)$

译为中文，就是：左上角为 $a[i_1][j_1]$ 右下角为 $a[i_2][j_2]$ 的矩形中,有$a[i_2][j_2]-a[i_1-1][j_2]-a[[i_2][j_1-1]+a[i_1-1][j_1-1]$ 个钉子。

然后就这么做了，于是 [38分](https://www.luogu.com.cn/record/204580382) 。

发现超时的那个测试点全部是没钉子，回到样例 #1 后，发现只要钉子数不超过 1 ，那么挂的画在任何位置都可以。

显然，每行 $m$ 个中有 $m+(m-1)+...+2+1=\frac{m(m+1)}{2}$ 排列组合方式，每一列同理。

故一共有 $\frac{m \times (m+1) \times n \times (n+1)}{4}$ 种排列组合方式

遂 [AC](https://www.luogu.com.cn/record/204581275) 。

**代码如下**

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
ll n,m,ans;
string s;
ll a[514][514];//存的是左上的钉子数
//思路是前缀和，但是这题用的二维
int main(){
	ios;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=1;j<=m;j++){
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
			if(s[j-1]=='#')a[i][j]++;
		}
	}
	if(a[n][m]<=1){
		cout<<n*m*(n+1)*(m+1)/4;
		return 0;
	}
	int f;
	for(int i1=1;i1<=n;i1++){
		for(int j1=1;j1<=m;j1++){
			for(int i2=i1;i2<=n;i2++){
				for(int j2=j1;j2<=m;j2++){
					f=a[i2][j2]-a[i1-1][j2]-a[i2][j1-1]+a[i1-1][j1-1];
					if(f<=1)ans++;
					if(f>1)break;
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

感谢阅读。

---

## 作者：FamousKillerconan (赞：0)

## 思路
用二维前缀和算一个矩阵里的钉子个数，用双指针去计算每一行矩阵个数。



AC 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e2+5;
const int INF=0x3f3f3f3f;
const double EPS=10e-6;
ll n,m,ans,sum[N][N];
char mp[N][N];
int calc(int x,int y,int xx,int yy){
	return sum[xx][yy]-sum[x-1][yy]-sum[xx][y-1]+sum[x-1][y-1];
}
void solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(mp[i][j]=='#');//二维前缀和
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			int l=1,r=0;
			while(l<=m&&r<=m){
				while(r<m&&calc(i,l,j,r+1)<=1)r++;//双指针
				ans+=(r-l+1);//计算个数
				l++;
			}
		}
	}
	cout<<ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);//读写优化
	int T=1;
//	cin>>T;
	while(T--)solve();//为了应付多组测试
	return 0;
}
```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P11752)

## 题目思路：
这道题很难吗？~~怎么没有人写呀？~~

废话不多说，直接开干！

为了快速求出一直左上端点和右下端点**已知的矩形含有的钉子数**，可以采用**二维前缀和**，防超时，预处理前缀和数组，快速计算任意矩形区域内的钉子数量。使用**滑动窗口**的思想，对于每一行，固定上下边界，通过**滑动左右边界**来快速计算满足条件的矩形数量。利用**双指针优化**，来写出本题！

## 正解：
上代码！

```cpp
#include <bits/stdc++.h>
#define ll long long
#define repeat(x, a, b) for(int x = a; x <= b; x ++)
#define repeatl(x, a, b) for(int x = a; x < b; x ++)
using namespace std;
const int N = 505;
int n, m, sum[N][N];
string a[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m;
	repeatl(i, 0, n){cin>>a[i];}
	repeat(i, 1, n)  repeat(j, 1, m) {
		sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + (a[i - 1][j - 1] == '#');
	}
	ll ans = 0;
	repeat(u, 1, n) repeat(d, u, n) {
		int l = 1, r = 1;
		while (r <= m) {
			int cnt = sum[d][r] - sum[u - 1][r] - sum[d][l - 1] + sum[u - 1][l - 1];
			if (cnt <= 1) {
				ans += (r - l + 1);
				r++;
			} else {
				l++;
				if (l > r) r = l;
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Hyvial (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11752)

## 题目大意
有一个 $n \times m$ 的矩阵，其中有 $\texttt{\#}$ 和 $\texttt{.}$。

题目要求选中其中的矩阵，求符合 $\texttt{\#}$ 小于 $2$ 的矩阵数量。

## 做题思路
首先不难想到暴力方法：预先处理出 $\texttt{\#}$ 数的二维前缀和，枚举一个矩阵的左上角，右下角，判断起是否符合条件（即 $\texttt{\#}$ 数量小于等于 $1$），如果符合，就将答案加一。

考虑优化，发现对于一个左上角、右下角坐标为 $x1, y1$ 和 $x2, y2$ 的矩阵，它之中的 $\texttt{\#}$ 数量，可以从左上角、右下角坐标为 $x1, y1$ 和 $x2 - 1, y2$ 转移而来（我们暂且将其称为**上方矩阵**），即将上方矩阵中的 $\texttt{\#}$ 数量加上第 $x2$ 行，在 $y1$ 与 $y2$ 之间的 $\texttt{\#}$ 数量。

## dp 状态
分析结束，我们可以考虑记录 $dp_{i, j, k}$ 记录以行为 $i$，范围 $j$ 到 $k$ 为底的符合条件的矩阵数量。因为转移与 $\texttt{\#}$ 数量有关，所以我们增加一维，将 dp 含义改为用 $dp_{i, j, k, t}$ 维护以行为 $i$，范围 $j$ 到 $k$ 为底，**且其中有 $t$ 个 $\texttt{\#}$** 的符合要求的矩阵个数，应为 $\texttt{\#}$ 数量大于 $1$ 的就没有意义，所以 $t$ 只取 $0$ 或 $1$。

## dp 转移
转移也显而易见，我们可以边枚举 $k$ 边计算第 $i$ 行，范围为 $j$ 到 $k$ 中的 $\texttt{\#}$ 数量 $t1$。此时就可以分情况讨论：
1. $t1=0$，此时 $dp_{i, j, k, 0} = dp_{i - 1, j, k, 0} + 1, dp_{i, j, k, 1} = dp_{i - 1, j, k, 1}$（为什么一个**加一**，一个**不加一**？因为加一表示的是此行单独成一个矩阵时的情况，此时这个只有一行的矩阵中没有 $\texttt{\#}$，所以要将其统计进 $dp_{i, j, k, 0}$ 中）；
2. $t1=1$，此时 $dp_{i, j, k, 0} = 0, dp_{i, j, k, 1} = dp_{i - 1, j, k, 1} + 1$（为什么请读者自行思考）。

答案就是所有 $dp_{i, j, k, t}$ 的和。

## 温馨提示
1. 如果你直接像这样做的话会 MLE 掉，可以考虑使用**滚动数组**，每次计算新的一行时记得**初始化**。
2. 需要开 long long，不然你会在测试数据三中 WA 一个点。
 
## 代码

```
/**
 * @author: Je_son
 * @date: 2025-02-19
 **/
#include <bits/stdc++.h>
#define PII pair <int, int>
#define LL long long
#define DB double
#define ST string

using namespace std;

const int N = 510;
int n, m;
char c[N][N];
LL dp[2][N][N][2];
// 滚动数组

signed main()
{
	scanf("%d%d", &n, &m);
	
	for(int i = 1; i <= n; i ++ )
	{
		for(int j = 1; j <= m; j ++ )
			cin >> c[i][j];
	}
	
	LL cnt = 0;
	for(int i = 1; i <= n; i ++ )
	{
		for(int j = 1; j <= m; j ++ )
		{
			LL ct = 0;
			for(int k = j; k <= m; k ++ )
			{
				ct += c[i][k] == '#';
				// 计算第 i 行 # 出现的次数
				dp[i&1][j][k][0] = dp[i&1][j][k][1] = 0ll;
				// 情况1 
				if(ct == 0)
				{
					dp[i&1][j][k][1] = dp[(i-1)&1][j][k][1];
					dp[i&1][j][k][0] = 1ll + dp[(i-1)&1][j][k][0];
				}
				// 情况2
				if(ct == 1)
				{
					dp[i&1][j][k][1] = 1ll + dp[(i-1)&1][j][k][0];
					dp[i&1][j][k][0] = 0;
				}

        // 统计答案
				cnt += dp[i&1][j][k][1] + dp[i&1][j][k][0];
			}
		}
	}
	
	printf("%lld\n", cnt);
	
	return 0;
}


```

---

## 作者：hinin (赞：0)

[更好的阅读体验（无耻）](https://www.cnblogs.com/hinin/articles/18724964)。

### 思路

为了快速求出一直左上端点和右下端点已知的矩形含有的钉子数，采用二维前缀和，预处理前缀和数组，快速计算任意矩形区域内的钉子数量。

滑动窗口的思想，对于每一行，固定上下边界，通过滑动左右边界来快速计算满足条件的矩形数量。

在滑动窗口时，利用双指针优化，从 $O(n^2m^2)$ 降低到 $O(n^2m)$。

### 代码

``` cpp
#include <bits/stdc++.h>
// #pragma GCC optimize("Ofast", "-funroll-all-loops")
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>

#define y1 kairiki
#define x first
#define y second

#define repeat(x, a, b) for(int x = a; x <= b; x ++)
#define rpless(x, a, b) for(int x = a; x >= b; x --)
#define repeatl(x, a, b) for(int x = a; x < b; x ++)
#define rplessr(x, a, b) for(int x = a; x > b; x --)

using namespace std;

const int N = 505;
int n, m, sum[N][N];
string a[N]; 

int main()
{
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); 
	
	cin >> n >> m;
	repeatl(i, 0, n) { cin >> a[i]; }

	repeat(i, 1, n)  repeat(j, 1, m) 
	{ sum[i][j] = sum[i - 1][j] + 
		sum[i][j - 1] - sum[i - 1][j - 1] + 
		(a[i - 1][j - 1] == '#'); }

	long long ans = 0;

	// 枚举上下边界
	repeat(u, 1, n) repeat(d, u, n) {
		int l = 1, r = 1;
		
		// 双指针法处理左右边界
		while (r <= m) {
			int cnt = sum[d][r] - sum[u - 1][r] - sum[d][l - 1] + sum[u - 1][l - 1];
			
			if (cnt <= 1) {
				ans += (r - l + 1); 
				r++;
			} else {
				l++;
				
				if (l > r) { r = l; }
			}
		}
	}

	cout << ans << endl;
	
	return 0;
}
```

---

## 作者：caoyuchen110911 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11752)

这是一道二维前缀和的题目。

思路很简单，先用二维前缀和处理好每一个矩阵里有多少个 $\texttt{\#}$，再一个一个枚举，如果矩形内 $\texttt{\#}$ 的个数小于等于 $1$ 就计入答案中。


```cpp
#include<bits/stdc++.h>
using namespace std;
char c[505][505];
int a[505][505];
signed main()
{
	int n,m,ans=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c[i][j];
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
			if(c[i][j]=='#')a[i][j]++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int x=1;x<=i;x++)
			{
				for(int y=1;y<=j;y++) //从第 i-x+1 行到第 i 行，从第 j-y+1 列到第 j 列
				{
					if(a[i][j]-a[i-x][j]-a[i][j-y]+a[i-x][j-y]>1)break;
					ans++;
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

但是有一个极端数据，所以运行超时，只有 $38$ 分。

考虑用二分优化，减少一重循环。

如果一个矩阵不合法，那么包含它的更大的矩阵也一定不合法，按照这个思路，就可以二分求出最大的 $y$（$y$ 的定义见上面的代码）。

如果你还不理解，可以参照下面正确代码的注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
char c[505][505];
int a[505][505];
signed main()
{
	int n,m,ans=0;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c[i][j];
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
			if(c[i][j]=='#')a[i][j]++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int x=1;x<=i;x++) //从第 i-x+1 行到第 i 行，从第 j-y+1 列到第 j 列 
			{
				int l=1,r=j,y;
				while(l<r) //普通的二分 
				{
					y=(l+r+1)>>1;
					if(a[i][j]-a[i-x][j]-a[i][j-y]+a[i-x][j-y]>1)r=y-1;
					else l=y;
				}
				if(a[i][j]-a[i-x][j]-a[i][j-l]+a[i-x][j-l]<=1)ans+=l; //ans 累加
				else break; //若不存在合法情况，接下来更大的 x 也不用考虑 
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```
感谢观看。

2025.3.4 上面的代码时间复杂度受到 @Tracy_Loght 的质疑，补写时间复杂度更低的方式。注意，上面的方法也可以通过该题。

就像上面说的，“如果一个矩阵不合法，那么包含它的更大的矩阵也一定不合法”，那么我们可以反过来想，**如果一个矩阵不合法，就去找比它小的矩阵。**

首先我们枚举起点行和终点行，再枚举终点列，终点列从左往右，那么如果起点列不动，就会包含越来越多的 $\texttt{\#}$，所以起点列是随着终点列而往右移（递增）的。

这时候，终点列为 $j$ 时对应的起点列就可以从终点列为 $j-1$ 的状态直接向右移。（不可能起点向左，终点向右，这样明显不合法）

更好的代码：

```cpp
#include<bits/stdc++.h>//O(n^3) 
using namespace std;
#define int long long
char c[505][505];
int a[505][505];
signed main()
{
	int n,m,ans=0;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c[i][j];
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
			if(c[i][j]=='#')a[i][j]++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int x=0;x<i;x++)//x~i列 
		{
		    int y=0;
		    for(int j=1;j<=m;j++)//y~j行 
			{
				while(y<=j&&a[i][j]-a[x][j]-a[i][y]+a[x][y]>1)y++;//包含多个'#'则范围缩小 
				ans+=j-y;//共有j-y种方案 
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---


# 「o.OI R1」CX

## 题目背景

[CX - Levitatexc](https://music.163.com/#/song?id=455692044)

## 题目描述

给定一棵 $n$ 个节点的树。树上的节点从 $1$ 到 $n$ 编号，树的根节点为 $1$ 号节点。

你可以选中这棵树上的若干个节点（**可以全选，可以全不选**）。

选中节点 $u$ 时**同时进行两步操作**：

1. 覆盖以节点 $u$ 为根的子树中的所有边 $1$ 次。若 $u$ 是叶子节点，那么这一步没有边被覆盖。
2. 覆盖节点 $u$ 到 $1$ 的路径上的所有边 $1$ 次。若 $u=1$，那么这一步没有边被覆盖。

求有多少种选节点的方案，使得树上的所有边都**恰好**被覆盖 $1$ 次。两种方案不同当且仅当至少一个节点在其中一个方案被选中，在另一个方案没被选中。答案对 $998244353$ 取模。

## 说明/提示

**「数据范围」**

**本题采用捆绑测试。**

对于所有测试数据，保证：

- $1 \leq n \leq 5\times10^5$。
- 对于 $2 \leq i \leq n$，$f_i < i$。

| 子任务 | $n$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $\leq 8$ | 无 | $15$ |
| $1$ | $\leq 5\times10^5$ | $f_i = 1$，其中 $2 \leq i \leq n$ | $10$ |
| $2$ | $\leq 5\times10^5$ | $f_i = i - 1$，其中 $2 \leq i \leq n$ | $10$ |
| $3$ | $\leq 5\times10^5$ | 无 | $65$ |

## 样例 #1

### 输入

```
6
1 1 2 3 3```

### 输出

```
3```

# 题解

## 作者：five_rice_water (赞：6)

对于这道题，我们不难发现，如果根节点的某一棵子树形状是一条链，那么我们可以选择这棵子树上的任意一个点进行覆盖这一整颗子树。

而如果一颗子树不是链，先说结论，是整个子树中从这个子树的根节点往下到第一个拥有多个儿子的节点位置，这个链状结构的节点总数。

同一棵子树选择一个点即可所以是相加关系，根的不同子树中每一棵子树都要提供一种方案所以是相乘关系，最终加上选择根节点的 $1$ 种方案，就得到了最终结果。

例如样例这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/0d5k1zsj.png)

左边这棵子树是链状，所以节点 $2$ 和 $4$ 都可以用来给整颗子树进行覆盖。

右边这棵子树不是链状，所以从子树的根节点 $3$ 号节点，到往下第一个有多个儿子的位置，还是 $3$ 号节点，中间只有 $3$ 一个节点。

所以对于右边的子树，方案只有 $1$ 种，再乘上左边子树的 $2$ 种，加上选择根节点 $1$ 的 $1$ 种，最终得到 $1\times 2 + 1 = 3$ 种不同的方案，也就是样例的结果。

原因：首先可以得到，对于根节点的一棵子树，我们最多只能在这棵子树里选择 $1$ 个点对这棵子树进行覆盖，原因也很简单，如果在一棵子树里面选择超过一个点，那么这两个节点到 $1$ 节点的路径必然有至少一段会被覆盖两次（可以自己思考一下为什么），所以不符合题目要求。

依照题意，选择一个节点以后，这个节点到 $1$ 的路径和这个节点的子树全部被覆盖，而当子树是链的时候，相当于把整条链全部覆盖，所以每一个点都可以选。

而当子树不是链的时候，因为我们既要覆盖整颗子树，又不能选超过两个点，所以只能选择在根节点到第一个拥有多个儿子的节点这一段上，因为一旦选择在其他的节点上，就一定会有子树上的节点没有被标记（例如样例中选择在 $5$ 节点上，$6$ 节点就不会被标记）。这个也很明显，因为不是链的情况下，选在链以外的节点就一定会导致只有选择了的节点的子树会被覆盖到，所以就会有点没有被覆盖，又因为最多选 $1$ 个点，所以说这样的方案就不合法。

最后加上单独选择 $1$ 节点的这种方案，就可以得到结果了。

记得取模。

代码：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e5+5;
const int Mod = 998244353;
int n,ans=1;
//这里ans初始值是1是因为为了便于下面每一棵子树的方案相乘。
//但是一定有一棵子树的方案数至少是1，所以不会影响结果
vector<int>e[N];
int dfs(int x){
	int tmp = 0; 
	if(e[x].size()>1) return 1;
	for(int i = 0; i<e[x].size(); i++){
		int v = e[x][i];
		tmp += dfs(v);
	}	
	return tmp+1;
}
signed main(){
	cin>>n;
	for(int i = 2; i<=n; i++){
		int x;
		cin>>x;
		e[x].push_back(i);
	}
	for(int i = 0; i<e[1].size(); i++){
		int v = e[1][i];
		ans*=dfs(v);
		ans%=Mod;
	}
	cout<<(ans+1)%Mod<<endl;
	return 0;
} 
```

---

## 作者：tuntunQwQ (赞：3)

容易发现，当一个节点拥有 $>1$ 个子节点时，我们如果选择其子节点就无法使树上的所有边都恰好被覆盖 $1$ 次。

考虑从节点 $1$ 出发 dfs，当遇到的节点的子节点数量 $≠1$ 时，则需要选择该点到根节点的路径上的除根节点以外的所有点的其中一个，故将答案乘以该节点到根节点的距离，最后将答案加上 $1$，表示只选 $1$ 号节点的方案。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,ans=1,cn;
int h[N],idx,nxt[N],e[N],cnt[N];
void add(int a,int b){
	e[++idx]=b,nxt[idx]=h[a],h[a]=idx;
}
void dfs(int u){
	if(u!=1&&cnt[u]!=1){
		ans=1ll*ans*cn%998244353;
		return;
	}
	for(int i=h[u];i;i=nxt[i]){
		int v=e[i];
		cn++;
		dfs(v);
		cn--;
	}
}
int main(){
	cin>>n;
	for(int i=2;i<=n;i++){
		int fa;
		cin>>fa;
		add(fa,i);
		cnt[fa]++;
	}
	dfs(1);
	cout<<(ans+1)%998244353;
	return 0;
}
```

---

## 作者：cyx012113 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11863)
### 题目大意
给定一棵以节点 $1$ 为根的树，选择一些节点，使得每条边恰好被覆盖一次。当选择节点 $u$ 时，会覆盖：
- 以 $u$ 为根的子树中的所有边。
- 从 $u$ 到根节点 $1$ 的路径上的所有边。

我们需要计算满足条件的选点方案数，并对 $998244353$ 取模。
### 题目分析
这道题的正解是：dfs 和数学统计。

拿出样例：
```text
6
1 1 2 3 3
```

:::info[前置知识：链]
**前置知识**：链，就是每个节点只有 $1$ 个子节点的一棵树。\
比如，下图就是一个链：![](https://cdn.luogu.com.cn/upload/image_hosting/imli1h07.png?x-oss-process=image/resize,m_lfit,h_225,w_225)
:::

**样例画图**：

![](https://cdn.luogu.com.cn/upload/image_hosting/wlft1mc5.png?x-oss-process=image/resize,m_lfit,h_225,w_225)

左子树可以选节点 $2$ 或节点 $4$，右子树可以选择节点 $3$。最后加上根节点（根节点可以覆盖所有的路径）。答案为 $2\times 1 + 1 = 3$。

进一步观察发现，当找到一条从根节点出发的链（不一定要连到底部）时，这棵子树的情况总和为链的长度（边的数量）。

> Q：如何找到所有链？\
> A：使用 dfs 遍历所有点，并且一边计算贡献。

最后用乘法原理乘起来，最后加一。

> **注意**：要开 long long。
### 代码实现
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 5e5, mod = 998244353;

int n, m, cnt, a[N], ans = 1, x, y, z;
vector <int> e[N];

void dfs(int x, int pos, int fa) { // x 代表当前节点，pos 代表链的长度，fa 代表父亲节点
	int _pos = pos;
	if (fa == 1) _pos = 1;
	if (e[x].size() == 1) _pos++;
	else if (x != 1) return ans = ans * _pos % mod, (void)(0); // 更新方案
	for (auto i : e[x]) dfs(i, _pos, x); // 遍历子树
}

signed main() {
    cin >> n;
    for (int i = 2;i <= n;i++) cin >> x, e[x].push_back(i);
	dfs(1, 0, 0);
    cout << (ans + 1) % mod << endl;
    return 0;
}
```
> update 2025.07.29：
> - 重新格式化了代码。

To 管理员：由于表述需要，因此使用折叠框，请不要介意。

---

## 作者：LLY_0827 (赞：2)

## P11863 CX

### 题意理解

给定一棵 $n$ 个节点（由 $1$ 编号）的树，任意选点。

对于选中的点：

- 覆盖以该节点为根的子树中的所有边 $1$ 次（叶子结点忽略此操作）。
- 覆盖该节点到根节点所有边 $1$ 次（根节点忽略此操作）。

求有多少种选节点的方案，使得树上的所有边都恰好被覆盖 $1$ 次。两种方案不同当且仅当至少一个节点在其中一个方案被选中，在另一个方案没被选中。

### 思路（带图片讲解）
- 图片量较大，如想看代码可直接拖到下方。
- 这是示例树。![样例](https://cdn.luogu.com.cn/upload/image_hosting/40tjwaz8.png)
- 仅选择根节点，保证所有边只覆盖 1 次。![](https://cdn.luogu.com.cn/upload/image_hosting/4kvy37s4.png)
- 对于每个根节点子树，在该子树分叉前选择一个点（以下两种等价）。![](https://cdn.luogu.com.cn/upload/image_hosting/hw6x9xgj.png)![](https://cdn.luogu.com.cn/upload/image_hosting/f7qx0hfe.png)
- 对于每个根节点子树，不能在该子树分叉后选点，子树的根处会出现重叠（如图所示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/zm8b9gti.png)

- 在这种方案中，每个根子树中都必须选点。![](https://cdn.luogu.com.cn/upload/image_hosting/9bj9e69k.png)
- 于是该树的选点方案如图所示。![](https://cdn.luogu.com.cn/upload/image_hosting/k6qyqe15.png)
- 利用乘法原理将每棵根子树中的选点方案相乘，再加上 $1$（主树的根节点），便得到方案总数，注意取模。

### 代码

- 使用深搜统计每棵根子树中的选点方案数，将该树视作有向图自上而下遍历，在遇到第一个出度不为 $1$ 的点（叶子结点或分叉结点）时停止寻找并返回当前深度。该深度就是根子树分叉前那条链的长度，就是根子树中的选点方案数。

```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    const ll p=998244353;
    vector <ll> zishu;	//存储根子树的根
    vector <vector<ll> > bian(514514); //存储每个结点的出度（视作有向图）
    ll fn[514514];

    ll dfs(ll n,ll cnt){
        if (bian[n].size()!=1) {
            return cnt;
        } 
        return dfs(bian[n][0],cnt+1);
    }

    int main(){
        ll n;
        cin>>n;
        fn[1]=0;
        ll ans=1;

        for (ll i=2;i<=n;i++){
            cin>>fn[i];
            if (fn[i]==1) {	//存储根子树结点
                zishu.push_back(i);	
            }
            bian[fn[i]].push_back(i);
        }

        ll zinum=zishu.size(); //根子树个数
        for (ll i=1;i<=zinum;i++){
            ll cur=zishu[i-1];
            ans=(ans%p*dfs(cur,1)%p)%p;
        }
        cout<<(ans+1)%p;
    }
```

---

## 作者：canwen (赞：2)

还是很好想的，赛时很快想出思路但是由于细节卡在 $20$ 分好久。 

## 分析

注意一点，**全部都不选**也可以是一个选择方案，这提示我们 $n = 1$ 时答案应该是 $2$。

简单分析下样例。

![awa](https://cdn.luogu.com.cn/upload/image_hosting/3zrwpdyd.png)

首先，无论在哪个图选择根节点 $1$ 一定是可行的方案。

接着考虑其他方案，拿上图为例，有其他的两个方案，选择节点 $2,3$ 或者节点 $4,3$，而且观察到是一定不能选节点 $5$ 或 $6$ 的。为啥？因为如果选择 $5$ 就需要选择 $6$，否则就会有边没有覆盖到。但是这样的话就导致节点 $1$ 到 $3$ 的边被覆盖多次。

到这里的话就应该能想出正解了。

统计出与根节点的有**直接**连边的**每个节点**最多能一直往下**一个节点一个节点**往下走多少个，具体的，到了叶子节点就返回 $1$，如果碰到孩子数大于 $1$ 的也直接返回 $1$，也就是不能继续一个一个往下选，然后乘法原理统计答案即可。

## Code
赛时丑陋的代码。
```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
#define const constexpr
using namespace std;

#define int unsigned long long
//#define getchar getchar_unlocked
//#define putchar putchar_unlocked
#define mk make_pair
#define pb emplace_back
#define pint pair<int,int>
#define i128 __int128
#define pc putchar('\n')
#define fst first
#define snd second
#define nowtime (double)clock()/CLOCKS_PER_SEC
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
int in(){
	char a = getchar();
	int k = 0, kk = 1;
	while(!isdigit(a)){
		if(a == '-') kk=-1;
		a=getchar();
	}
	while(isdigit(a)){
		k = k*10 + a - '0', a = getchar();
	}
	return k*kk;
}
void out(int a){
	if(a < 0) putchar('-'),a=-a;
	if(a > 9) out(a/10);
	putchar(a%10+'0');
}
const int N = 5e5 + 5, mod = 998244353;

int n,ans,f[N];
vector <int> e[N];
int dfs(int u,int fa){
	if(e[u].size() == 0) return 1;
	if(e[u].size() > 1) return 1;
	for(int i=0;i<e[u].size();++i){
		int v = e[u][i];
		if(v != fa) return (dfs(v,u) + 1) % mod;
	}
}

signed main(){
	cin>>n;
	_rep(i,2,n){
		int x = in();
		e[x].pb(i);
	}
	ans = 1;
	for(auto i:e[1]){
		ans = ans * dfs(i,1) % mod; 
	}
	cout << (ans + 1) % mod;
	return 0;
}
```

---

## 作者：BpbjsGreen (赞：1)

只选 $1$ 是一种方案。

不选 $1$，则对于 $1$ 的每一个邻点，以它为根的子树的方案是独立的。

假设这棵子树的根节点为 $u$。在这棵子树中我们只能选一个点，否则边 $(1,u)$ 会被覆盖两次。选点时，只能选取 $u$ 延伸出的**最长不分叉链**中的某个节点，否则会有边没覆盖到。

利用乘法原理即可得到答案。

```
// ID: @BpbjsGreen

#include <bits/stdc++.h>
#define int long long
// #define double long double
using namespace std;

const int N = 5e5 + 5, mod = 998244353;
int n, res = 0, ans = 1, tmp;
vector<int> G[N];

signed main()
{
    scanf("%lld", &n);
    for (int i = 2, fa; i <= n; i++)
        scanf("%lld", &fa), G[fa].push_back(i);
    for (int u : G[1])
    {
        res = 1, tmp = u;
        while (G[tmp].size() == 1)
            res++, tmp = G[tmp][0];
        ans = ans * res % mod;
    }
    printf("%lld\n", (ans + 1) % mod);

    return 0;
}
```

---

## 作者：ran_qwq (赞：1)

如果 $1$ 的一个儿子 $u$ 子树中取了两个点，那 $1$ 到这个儿子的边就被覆盖了两次。如果不取就没被覆盖。所以一个子树中只能恰好取一个点。

然后看在哪些位置可以取。如果一个点到 $u$ 还有其他分叉就不能取，否则恰好能覆盖这个子树。

每个子树是独立的，答案把所有子树合法点数乘起来加 $1$（可以只取根）。

```cpp
int n,id,mx,as=1,hd[N],d[N];
struct EDGE {int to,ne;} e[N];
void add(int u,int v) {e[++id]={v,hd[u]},hd[u]=id,d[u]++;}
void dfs(int u,int dd,int f) {
	if(f) mx=dd;
	for(int i=hd[u];i;i=e[i].ne) dfs(e[i].to,dd+1,f&(d[u]==1));
}
void QwQ() {
	n=rd();
	for(int i=2;i<=n;i++) add(rd(),i);
	for(int i=hd[1];i;i=e[i].ne) dfs(e[i].to,1,1),cmul(as,mx);
	wr(vadd(as,1),"\n");
}
```

---

## 作者：yanxu_cn (赞：0)

思维题。

选根节点是一种可行方案。

其他的情况，必然对于根节点的每一个子节点对应的子树都要选一个点。

对于每一棵子树，选其根节点（即总根节点的子节点）一定是可以的！同时我们可以发现选取子树的最长不分叉的链上的任何一个点都是可以的。

显然可以利用乘法原理算一下就可以了。

给一个容易理解的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int maxn=5e5+7;
vector<int>ed[maxn];
constexpr int mod=998244353;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n;
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		int u;
		cin>>u;
		ed[u].push_back(i);
	}
	__int128 ans=1;
	for(auto s:ed[1])
	{
		int po=s;
		__int128 cnt=1;
		for(;ed[po].size()==1;po=ed[po][0],cnt++);
		ans=ans*cnt%mod;
	}
	cout<<(long long)(ans+1)%mod;
	return 0;
}
```

---

## 作者：wukaichen888 (赞：0)

把根节点割掉，注意到每个连通块会恰好选一个点，否则该连通块与根节点的边不能恰好被覆盖一次，并且需要满足到根节点路径上没有支链，否则覆盖不完全，一组选一个点，乘法原理即可，复杂度 $O(n)$。

以及另一个情况就是只选根。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=5e5+5,mod=998244353;
int n;
int par[N],dep[N],d[N],vis[N];ll ans=1;
int main(){
	scanf("%d",&n);vis[1]=1;
	for(int i=2;i<=n;i++) scanf("%d",&par[i]),d[par[i]]++;
	for(int i=2;i<=n;i++) dep[i]=dep[par[i]]+1;
	for(int i=2;i<=n;i++) vis[i]=(d[i]==1)&&vis[par[i]];
	for(int i=2;i<=n;i++) if((d[i]!=1)&&vis[par[i]]) ans=ans*dep[i]%mod;
	printf("%lld\n",(ans+1)%mod);
	return 0;
}
```

---

## 作者：madfallen (赞：0)

合法操作：从根节点到当前节点如果形成一条没有旁支的链，那么在链上选择一个节点，这条链就处理完了。

若有旁支，需要在该子树内再选一个节点，这就导致最顶上的路径覆盖了两次。

最后答案就是合法链链长之积，再加上直接选根节点。

注意每个子任务最后一个点的特例：只有一个点时有两种方法，可以啥都不选。
```c++
#include<iostream>
#include<cstdio>
#include<vector>
#define int long long
using namespace std;
const int N=5e5;
const int mod=998244353;
vector<int>G[N+5];
int n;
int a[N+5],tot;
inline void dfs(int u,int dep){
	if(G[u].size()==0){
		if(dep)a[++tot]=dep;
	}
	if(u!=1&&G[u].size()>1){
		if(dep)a[++tot]=dep;
		return;
	}
	for(int i:G[u])dfs(i,dep+1);
}
signed main(){
	cin>>n;
	if(n==1)return cout<<2,0;
	for(int i=2,x;i<=n;i++){
		scanf("%d",&x),G[x].push_back(i);
	}
	dfs(1,0);
	if(tot==0)cout<<1;
	else{
		int ans=1;
		for(int i=1;i<=tot;i++)ans=ans*a[i]%mod;
		ans++;
		cout<<ans%mod;
	}
}
```

---


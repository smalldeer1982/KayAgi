# [威海市赛2024] 抽卡

## 题目描述

小威有 $a+b$ 张神奇卡片。

一共有 $a$ 张 $A$ 卡，$b$ 张 $B$ 卡。     

小威负责抽卡，他每次会随机抽出一张卡片。小海负责猜，当剩余 $A$ 卡的数量小于 $B$ 卡剩余数量时，他就会猜 $B$，如果 $A$ 剩余的数量大于 $B$ 剩余的数量，那么他就会猜 $A$，否则不猜。

小海想知道他期望能猜对多少次。

## 说明/提示

样例 #1 中，第一次小海没猜，第二次不管剩下一张什么卡，小海总能猜对。所以期望是 $1$。

## 样例 #1

### 输入

```
1 1```

### 输出

```
1.00000000```

## 样例 #2

### 输入

```
12 12```

### 输出

```
12.00000000```

# 题解

## 作者：cff_0102 (赞：9)

这题交了 $30$ 篇题解，我打回了 $28$ 篇。剩下两篇的证明看起来也都不是很清晰，所以我就自己写了一篇新的。

抛开期望不谈，可以证明无论如何取卡最终正确猜测的次数一定是 $\max(a,b)$。

假设现在 $a>b$，那么小海会一直选择猜 A，直到抽完后两种卡数量相等。假设这个数是 $x_1$，因为在这期间小海一直猜 A，而 A 卡被抽走了 $a-x_1$ 张，所以小海一定会猜中 $a-x_1$ 次。

现在两种卡数量相等，小海不会进行猜测。小威抽走一张后，又会回到一种卡多一种卡少的情况，也就转化为上面的情况。假设下一次两种卡数量相等时数量为 $x_2$，那么在这期间小海一定会猜对 $x_1-x_2$ 次。

一直重复，直到最后剩下 $0$ 张卡片。那么小海一共会猜中 $a-x_1+x_1-x_2+\dots-x_k+0=a$ 次。刚开始 $a<b$ 或 $a=b$ 时也同理可得，答案为 $\max(a,b)$。

因此这个求期望没用，最终猜中的次数是确定的，直接输出 $\max(a,b)$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int a,b;cin>>a>>b;cout<<max(a,b); 
	return 0;
}
```

---

## 作者：末然Ender (赞：5)

# 题解：P11868 抽卡

## 思路

诈骗题。

观察样例发现输出 $\max(a,b)$ 就是答案 ~（bushi。~

考虑此时，设 $A$ 卡组比 $B$ 卡组多（反之亦然），我若选择猜测 $A$ 卡组，若是错误了，那么 $B$ 卡组因此就变得更短了，那么 $B$ 卡组理应更早清空，所以迟早会猜 $A$ 卡组正确；若是正确了，$A$ 卡组变得更短了，直到变得两个卡组一样多，此时会选择不猜，那么又回回到以上的局面，所以答案必定是 $\max(a,b)$。

## 代码

```cpp
#include<bits/stdc++.h>
int main(){
  int a,b;
  std::cin>>a>>b;
  std::cout<<std::max(a,b)<<".00000000"<<'\n';
  return 0;
}
```

---

## 作者：xuyixuan_123 (赞：3)

要解决这个问题，我们需要计算小海在抽卡过程中期望猜对的次数。通过分析抽卡过程和小海的猜测策略，我们可以得出一个简洁的结论：期望猜对次数等于初始 $A$ 卡和 $B$ 卡数量的最大值。
## 方法思路：
小海的猜测策略基于剩余卡片的数量：当剩余 $A$ 卡数量大于 $B$ 卡时猜 $A$ ，反之猜 $B$ ，数量相等时不猜。经过详细分析，我们发现每次抽卡时的正确猜测概率之和恰好等于初始 $A$ 卡和 $B$ 卡数量的最大值。这一结论可以通过数学归纳法和递推关系验证。
## 证明：
- 例如，当 $a=2$，$b=1$ 时，总期望应为 $2$。根据前面的推导，该结论成立。  

- 再假设 $a=3$，$b=0$。此时，所有的卡都是 $A$，每次抽卡时小海都会猜 $A$，正确概率 $100\%$。所以总共有 $3$ 次猜对，期望是 $3$，等于 $\max(3,0)=3$。  

- 另一个例子，$a=0$，$b=5$。此时，总期望是 $5$，与 $\max(0,5)$ 相等。

- 当 $a=5$，$b=3$。总期望是 $5$，符合条件。  

综上所述，这个问题的答案就是：
 $$\max(a,b)$$

---

## 作者：Manchester_City_FC (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11868)

一道搞笑题。

### 题目大意
小威有 $a+b$ 张神奇卡片。

一共有 $a$ 张 $A$ 卡，$b$ 张 $B$ 卡。     

小威负责抽卡，他每次会随机抽出一张卡片。小海负责猜，当剩余 $A$ 卡的数量小于 $B$ 卡剩余数量时，他就会猜 $B$，如果 $A$ 剩余的数量大于 $B$ 剩余的数量，那么他就会猜 $A$，否则不猜。

小海想知道他期望能猜对多少次。

### 解题思路
假设当前的状态为 $(a,b)$，其中 $a$ 表示剩余的 $A$ 卡与 $B$ 卡数量。
+ 当 $a>b$ 时，小海猜 $A$。对于下次抽卡：
  + 如果抽到 $A$，其概率为 $\frac{a}{a+b}$，他的猜测正确，并且状态转移到 $(a-1,b)$；
  + 如果抽到 $B$，其概率为 $\frac{b}{a+b}$，猜测错误，状态转移到 $(a,b-1)$。
+ 当 $a<b$ 时，小海猜 $B$。对于下次抽卡：
  + 如果抽到 $A$，其概率为 $\frac{a}{a+b}$，他的猜测错误，并且状态变为 $(a-1,b)$；
  + 如果抽到 $B$，其概率为 $\frac{b}{a+b}$，则猜对，状态变为 $(a,b-1)$。
+ 当 $a=b$ 时，由于两种卡片数相同，小海不猜。因此这一轮不会获得分数，只能等待抽卡后进入其它状态：
  + 如果抽到 $A$，其概率为 $\frac{a}{a+b}$，状态变为 $(a-1,b)$；
  + 如果抽到 $B$，其概率为 $\frac{b}{a+b}$，状态变为 $(a,b-1)$。

记 $dp_{a,b}$ 为状态 $(a,b)$ 下『未来能获得的猜对次数的期望值』。根据上面的分析可以得到递推关系：
+ 当 $a>b$ 时：$dp_{a,b}=\frac{a}{a+b} \times (dp_{a-1,b}+1)+\frac{b}{a+b} \times dp_{a,b-1}$；
+ 当 $a<b$ 时：$dp_{a,b}=\frac{b}{a+b}\times(dp_{a,b-1}+1)+\frac{a}{a+b} \times dp_{a-1,b}$；
+ 当 $a=b$ 时：$dp_{a,a}=\frac{1}{2}(dp_{a-1,a}+dp_{a,a-1})$。

这个时候我们已经可以先写出一份暴力代码找找规律了。令人惊奇的是，无论如何抽卡，最终猜对的次数的期望值恰好等于最多的一类卡片的数量。证明如下：

当 $b=0$ 时，显然 $dp_{a, 0}=a=\max(a,0)$；当 $a=0$ 时，$dp_{0,b}=b=\max(0,b)$。

我们假设对于所有状态 $(a',b')$ 且 $a'+b'<a+b$ 都有 $dp_{a',b'}=\max(a',b')$。

当 $a>b$ 时，由假设知 $dp_{a-1,b}=a-1$。代入递推中：
$$
dp_{a,b}=\frac{a}{a+b} \times a + \frac{b}{a+b} \times a=\frac{a^2+ab}{a+b}=a
$$
$a<b$ 时同理，可以证明 $dp_{a,b}=b$。
而当 $a=b$ 时，根据对称性有 $dp_{a,a}=\frac{dp_{a-1,a}+dp_{a,a-1}}{2}=a$。

综上，期望值为 $\max(a,b)$，也就是说我们以 $\mathcal O(1)$ 的时间复杂度解决了这道题目。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
    cin>>a>>b;
    cout<<max(a,b);
}
```

---

## 作者：_seven_7k_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11868)

## 思路
我们假设小威每次抽卡都猜对了，即期望猜对数最大。我们可以模拟一下，发现当 $a=b$ 时，小威不猜，$a$ 和 $b$ 其中一个就会减一，然后猜另一个，猜对数加 $1$，以此类推。到最后，猜对次数就为 $a$ 或 $b$。

当 $a≠b$ 时，会猜大的，猜对数加 $1$，直到 $a=b$，就成上面所说。

所以，最多可猜对 $\max(a,b) - \min(a,b) + \min(a,b) $，即 $\max(a,b)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	double n,m;
	cin>>n>>m;
	if(n>=m){
		printf("%.8lf",n);
	}
	else{
		printf("%.8lf",m);
	}
    //注意保留八位小数。
	return 0;
}
```

---

## 作者：chenyimo1204 (赞：1)

### 题目思路一

这是一道需要思考的题，当然不思考也能过。正常思路，一个循环搞定，如果 $a$ 和 $b$ 的数量相同，我们就设抽走的是 $a$，如果 $a > b$，那么抽走一张 $a$，$ans$ 加一，否则抽走一张 $b$，$ans$ 加一。直到 $a$ 和 $b$ 都为 $0$，循环结束，输出 $ans$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,ans=0;
int main(){
  cin>>a>>b;
  while(a!=0||b!=0){
    if(a==b){
      a--;
    }
    else if(a>b){
      ans++;
      a--;
    }
    else{
      ans++;
      b--;
    }
  } 
  cout<<ans;
  return 0;
}
```

### 题目思路二

不难想象，如果 $a$ 和 $b$ 的数量一样，假设每把都抽走了 $a$，那么 $b$ 就比 $a$ 多一，最终答案也就是 $a$ 或 $b$。如果 $a > b$ 或 $b > a$，答案就是多的数量加 $\min(a,b)$，最终得出结论，答案为 $\max(a,b)$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
  cin>>a>>b;
  cout<<max(a,b); 
  return 0;
}
```

---

## 作者：CMWabc123 (赞：0)

# 第一部分 题目
[题目传送门](https://www.luogu.com.cn/problem/P11868)

# 第二部分 分析
首先，让你求猜对多少次，次数一定是个整数，所以输出格式是把你往弯路上引的。

其次，我们有几个做法：

## 第 $1$ 个做法

直接模拟解决。  
每次随机选一张牌，然后与小海的决策进行比较。

## 第 $1.5$ 种做法

既然随机数可以解决，我们可以使用一个固定的策略解决，这样不用使用随机数了。

我们可以采用先全抽“$A$，再全抽 $B$”的策略，简单、明了。

## 第 $2$ 种做法

根据第 $1.5$ 种做法，我们可以做出以下讨论：

+ $ A = B $  小海一次猜 $A$ 一次猜 $B$，最终答案为 $A$。
+ $ A > B $  小海会一直猜 $A$ 直到 $A = B$，共猜对 $A$ 次。
+ $ A < B $  小海会一直猜 $B$，会猜错前 $A$ 次，接下来猜对 $B$ 次。

综上，我们可以得出答案为 $\max({a,b})$。

# 第三部分 代码
## 第 $1$ 种
```cpp
#include <bits/stdc++.h>
using namespace std;
double a,b,c;
int main(){
	srand(time(0));
	cin>>a>>b;
	while(a>1e-6||b>1e-6){
		int rnd=rand()%2,k;
		if(rnd==0&&!a)k=1;
		if(rnd==1&&!b)k=0;
		if(k==0){
			if(a>b){
				c++;
			}
			a--;
		}else{
			if(b>a){
				c++;
			}
			b--;
		}
	}
	printf("%.8f",c);
	return 0;
}
```

## 第 $1.5$ 种

```cpp
#include <bits/stdc++.h>
using namespace std;
double a,b,c;
int main(){
	//srand(time(0));
	cin>>a>>b;
	while(a>1e-6||b>1e-6){
		int rnd,k;
        rnd=0;
		if(rnd==0&&!a)k=1;
		if(rnd==1&&!b)k=0;
		if(k==0){
			if(a>b){
				c++;
			}
			a--;
		}else{
			if(b>a){
				c++;
			}
			b--;
		}
	}
	printf("%.8f",c);
	return 0;
}
```

## 第 $2$ 种做法
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,c;
int main(){
	cin>>a>>b;
	cout<<max(a,b)<<".00000000";
	return 0;
}
```

---


# 必胜

## 题目背景

福尔魔斯和花生在玩游戏。但福尔魔斯总是赢。

花生什么时候才能发现福尔魔斯生成的初始局面总是有必胜策略呢？

## 题目描述

福尔魔斯和花生在玩一个和数学有关的游戏。  

初始场上有 $n$ 个整数 $a_1\sim a_n$ 。  
两人轮流行动，某人行动时需从下面两种操作中选择一种执行：  
- 选择场上的一个数 $a_i$ ，将其除以其最大的质因子。
- 选择场上的一个数 $a_i$ ，将其改为它自身的平方。任意时刻，该玩家使用该操作的总次数不能超过其总分值。

若某名玩家操作结束后，场上有数等于 $1$ ，将其移除，令这名玩家获得 $1$ 分。  
初始双方分数都为 $0$ ，若场上没有剩余的数，结束游戏，分数较多的一方获胜。  
福尔魔斯先手。求双方都采取最优策略的前提下，哪方能获胜，或是返回平局。



## 说明/提示

#### 样例一解释：
一共有 3 组数据。

第一组数据有一个二，福尔魔斯可以进行一次操作一，使 2 变成 1。花生无法进行操作。故答案为福尔魔斯赢。

第二组数据有两个 2，无论福尔魔斯怎么操作，他都只能消掉一个 2，获得一分；而花生总可以拿到 1 分，所以结果为平局。

第三组数据只有一个 4，福尔魔斯进行操作一之后花生再操作，花生得分，故为花生获胜。

#### 样例二解释

第一组数据中，$9 = 3\times 3, 10 = 2\times 5, 15 = 3\times 5$，无论福尔魔斯怎么选择对哪个数进行操作，花生都可以再进行一次操作得分，故花生胜。

---
对于所有数据，满足 $1\le T\le10^4$ ，$1\le\sum{n}\le2\times10^6$ ， $2\le a_i\le10^7$ 。  

|  #   |       特殊性质        | 分值 |
| :--: | :-------------------: | :--: |
|  0   | $n=1$ |  5  |
|  1   | $\sum{n}\le 6 , a_i\le10$ |  10  |
|  2   | $\sum{n}\le4\times10^2,a_i\le4\times10^3$ |  13  |
|  3   | $\sum{n}\le10^4$ |  17  |
|  4   | $a_i$ 为质数 |  10  |
|  5   | $a_i$ 不为质数 |  20  |
|  6   | 无特殊限制 |  25  |

## 样例 #1

### 输入

```
3
1
2
2
2 2
1
4```

### 输出

```
Lucky_Holmes
Draw
Angry_Waston```

## 样例 #2

### 输入

```
4
3
9 10 15
3
9 10 30
2
11 14
4
11 4 5 14```

### 输出

```
Angry_Waston
Lucky_Holmes
Lucky_Holmes
Angry_Waston```

## 样例 #3

### 输入

```
3
8
7 12 15 17 21 23 30 31
10
10 11 12 13 14 15 16 17 18 19
6
16 17 18 16 17 18```

### 输出

```
Angry_Waston
Angry_Waston
Angry_Waston```

# 题解

## 作者：Ethan104 (赞：8)

首先，容易发现的是一二操作的描述都是故弄玄虚的。一操作中实际上除掉的是哪个质因子都是无所谓的，而二操作中相当于把质因子的个数加倍，因而若定义 $d_i$ 为 $a_i$ 的质因子数量，则：  
- 操作一相当于将某个 $d_i$ 减少 $1$ ；
- 操作二相当于将某个 $d_i$ 乘以 $2$ 。  

先看一个子问题：所有 $d_i\ge2$ ，即所有 $a_i$ 不为质数。  
先假设二操作不存在。  
显而易见的，当所有 $d_i$ 都是偶数时，后手必胜；每次后手只要重复一次先手的操作即可。这是容易理解的，因为每次先手要面对的都是所有 $d_i$ 都是偶数的局面，即先手在操作时的所有 $d_i\ge2$ ，那么先手绝对无法在一步之内获得任何一分，换言之，后手将会拿到所有分数。  
其次， $d_i$ 有奇数的情况。在有偶数个 $d_i$ 是奇数时，后手必胜。行动方式是，在先手将某个奇数变为偶数的场合，后手也选择一个奇数变为偶数；在先手将某个偶数变为奇数的场合，后手再对那个 $d_i$ 使用一次操作一。  
分析为什么可以胜利：在先手操作前，后手操作后的视角下，先手面前的奇数个数永远都是偶数；而由于初始的 $d_i\ge2$ ，在先手操作一个奇数时先手无法消除这个 $d_i$ ，而由于偶数个 $d_i$ 为奇数，后手总能将一个奇数 $d_i$ 同样转化为偶数。而在先手操作偶数时就和上文一样，因而先手面前的奇数个数一定会逐渐减少，以至于最后会退化成没有奇数的情况，即后手必胜。  
那么，有奇数个 $d_i$ 是奇数的情况也是简单的了：先手只要先将某个奇数变为偶数，就相当于退化成了上一种情况，不同的是先后手对换了，则在这种情况下先手必胜。  
那么如果将二操作加回来呢？实际上，可以发现在上述三种情况下，胜方都能拿到全部分数：这是因为上面三个方案之所以能胜，都是因为它们胜利的基础都在于不让输方拿到一分，而在这种情况下，输方无法使用二操作，而赢方无需使用二操作便能获胜，即二操作相当于不存在，对上述结论无影响。

下面是有 $d_i=1$ 的情况。  
先考虑一下二操作的意义，发现上文中胜利条件只和所有 $d_i$ 的奇偶有关，一操作相当于反转一个数的奇偶，那么二操作在操作一个偶数 $d_i$ 时相当于场上所有数的奇偶无变化，从上文中可以看出这样相当于空过自己的回合，即相当于反转了一次双方的先后手，即在所有 $d_i\ge2$ 时，二操作能反转双方胜负。  
对初始时有 $d_i=1$ 的情况时，双方的最优策略都是优先消除这些 $d_i$ 。原因是，在这种情况下双方都能轻易得分，但其他方式的得分效率都不如直接消除为 $1$ 的 $d_i$ ；要快速得分的原因在于可以获得二操作的使用次数，而“反转双方胜负”这个操作的可使用次数若大于对方可发现是一定胜利的。  
在上述阶段结束之后，场上的 $d_i\ge2$ 。若是初始 $d_i=1$ 的个数为奇数，先手会获得更多次使用二操作的权利，即一定获胜；而在双方分数相等情况下，则仍按 $d_i\ge2$ 的方式处理，因为在此种情况下任何一边反转胜负时对方一定有机会将其反转回来。  
但是二操作能反转双方胜负的条件当且仅当有 $d_i$ 是偶数。容易发现，这个条件一定能达成，在最后所有 $d_i\ge2$ 的情况下，使用操作一时一定有一个时刻 $d_i=2$ ，此时使用操作二就能保证有效。  
特别地，在所有 $d_i=1$ 时，若 $n$ 为偶数，平局；否则，先手必胜。  
于是就做完啦。

---

## 作者：dci66666 (赞：2)

看到这个题，首先可以知道的是分是个很超模的东西。

你比别人多一分，可以使一个数平方。换句话说就是使这个数的剩余质因子个数变为偶数，并且把这个数交给别人。

偶数个的质因子，显然是后手必胜的，我将这个数交给别人，别人就是先手，我就是后手。

根据以上的推论，只要我比别人多了一分，我就可以再争一分。根据最优的原则，一分最多会使我赚一分，所以只要双方会对一分会耗掉自己所有的分来抢夺这一分（只要有一个人开始，交替防止别人得到这一分）。

我们都知道最开始都是零分，怎么快速获得分数呢？那肯定是抢质数了。一个质数可以得一分，而且别人抢不了。所以可以分两种情况：第一种，有奇数个质数，那么先手必胜，因为多得到一分，稍微棘手一点的是第二种情况，因为第二种会使两方分相等。因为分相等，所以最后一个用分的一定可以抢到一分，所以最后一个用分的一定赢。因此，不会有人用分。现在就比谁先得到一分。紧接着考虑的就是奇数个质因数的数，在没有分的话也能使先手稳定得一分。当别人先去抢奇数个质因子数时也去附和肯定是不明智的，所以我会先去拿别的奇数个质因子数。假如奇数个质因子数被抢完后，那最后一个抢的人就赢了，因为场上全是偶数个质因子数，无论选哪一个，后手只需要做相同与先手的事就赢了。所以，有奇数个奇数质因子数时先手胜，否则后手胜。如果除了质数外没别的数，就平局。

总体来说就一个贪心，和线性筛加质因数分解。代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9')f=(c=='-')?-1:1,c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x*f;
}
const int N=4e6+50;
int n,a[N],p[10000005],b[N],k[N];
vector<int>v;
void solve(){
	n=read();int tot=0;int f=0;
	int num=0;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++){
		if(!p[a[i]])num++;
		else b[++tot]=a[i],k[tot]=0;
    }
    //cout<<num<<endl;
	if(num&1)puts("Lucky_Holmes");
	else {
		//cout<<" "<<tot<<endl;
		for(int i=1;i<=tot;i++){
			for(int j:v){
				if(j*j>b[i]){
					break;
				}
				while(b[i]%j==0)b[i]/=j,k[i]++;
			} 
			k[i]+=(b[i]!=1);
			if(k[i]&1)f++;
		}
		if(f&1)puts("Lucky_Holmes");
		else if(tot)puts("Angry_Waston");
		else puts("Draw");
	}
}
int main(){
	for(int i=2;i<=1e7;i++){
		if(!p[i])v.push_back(i);
		for(int j:v){
			if(i*j>1e7)break;
			p[i*j]=1;
			if(i%j==0)break;
		}
	}
    int t=read();
    while(t--)solve();
	return 0;
}

```

---

## 作者：lovelish (赞：1)

想着水水绿题，然后就找了昨天的比赛题，结果直接秒了，于是想着写个题解。~~感觉只有黄的样子。~~

第一个操作就是把 $a_i$ 的质因子数量减一，第二个操作就是把 $a_i$ 的质因子数量乘二，两个操作都是改变了 $a_i$ 的质因子数量，因此可以只计算每个数的质因子数量。

预处理出每个数的质因子数量后，我们把新序列当作序列 $a$。

当有 $a_i$ 为 $1$ 时，对 $a_i$ 进行第一个操作可以直接获得一分，此时进行该操作一定是最优的。那么一开始所有的 $1$ 就会被双方轮流取走。接下来的叙述中将不考虑 $1$。

当有 $a_i$ 为 $2$ 时，若对 $a_i$ 进行第一个操作，则对方一定也会对 $a_i$ 进行第一个操作，此时对方就会再多一分，因此当 $a_i$ 变为 $2$ 后，就不会有人再去进行第一个操作，除非迫不得已。

那么序列 $a$ 一定会被变为一个全部为 $2$ 的序列。接下来我们来分析第二个操作。

由于双方是轮流操作，所以实际上所有数只需要分析奇偶。对一个偶数进行第二个操作对于该数的奇偶不变，那么就相当于让自己轮空了一回合，对自己有好处，因为只需要考虑奇偶，所以对任何偶数进行操作的效果是完全相同的；对一个奇数进行第二个操作对于该数的奇偶改变，但加上自己的轮空一回合，相当于没有任何意义。

因此我们可以先把序列全变为 $2$ 后再进行第二个操作。接下来双方便会一直使用第二个操作直到次数用完，那么继续根据奇偶判断即可。第一个用完次数的就会率先开始对 $2$ 进行第二个操作，那么另一方将会把剩下所有的数都收入囊中变为分数。 

经过上述分析，根据奇偶进行简单思考即可得出结论。


```cpp
int sum1=0,sum2=0,flag=0;
for(int i=1;i<=n;i++)
{
    if(a[i]==1)sum1++;
    else sum2+=a[i]-2,flag=1;
}
if(!flag&&!(sum1&1))puts("Draw");
else if(sum1&1||(!(sum1&1)&&(sum2&1)))puts("Lucky_Holmes");
else puts("Angry_Waston");
```

---

## 作者：hgckythgcfhk (赞：1)

### 转化题意

给定 $n$ 个数，每次可以进行两种操作，一种是对任意一个不为 $0$ 的数减 $1$，减到 $0$ 加分，另一种是对任意一个不为 $0$ 的数乘 $2$，要求第二个操作在任意时刻使用过的次数不超过当前得分。

考虑 subtask4，相当于所有数都是 $1$，发现无论是先手还是后手都不会使用操作 $2$，因为对方总能去先使用 $1$ 操作得到更多的分，所以此时结果只和 $n$ 的奇偶性有关，$n$ 为奇数时先手必胜，反之平局。

这启发我们去考虑全是 $2$ 的情况，每个数是等价的，先手无论怎么选后手都可以身边把先手刚造出来的 $1$ 拿走得分。

所以，可以得出一个结论：有 $1$ 一定要拿，有 $2$ 一定要避开。

手玩一下只有 $O(1)$ 个不是 $2$ 的数据，$O(1)$ 个不是 $1$ 或 $2$ 
的数据，具体过程不做展示，不难发现大于 $2$ 的数几乎是等价的，现在就可以大概地刻画整个问题的结构，我们把所有数分成 $3$ 类，$1,2$ 和大于 $2$ 的数。

注意到所有数都是 $1$ 的时候我们讨论过奇偶性，所以可以猜测整个问题的结构和奇偶性强相关，观察手玩过所有样例的，试图对其与奇偶性建立联系，样例可以发现，操作 $2$ 实际上可以起到一个改变先后手的作用，所以可以得到一个不太好证但显然正确的结论，谁得到第一分就可以让对方得不到第二分，归纳地，得到第一分等于直接获胜，当然这个结论在有 $1$ 的时候会出点问题，不过不难发现双方会先尽力用 $1$，用完 $1$ 得到该得的分后对方交换一次先后手如果现在自己有分可以换回来，所以 $1$ 的个数只有奇偶性有用，奇数个相当于先手可以随时决定自己是先手还是后手，显然是必胜的，偶数个相当于一个也没有。

注意，在还有 $1$ 的时候双方不会交换先后手，因为这样会浪费操作机会使得对方得到更多的 $1$。

梳理一下上面说到的情况：

先特判全是 $1$ 且有偶数个 $1$ 会平局，然后如果有奇数个 $1$ 先手必胜，否则剩下的数的和为奇数则先手必胜，偶数则后手必胜。

最后说明一下上面的 $1,2$ 等所有数的定义是原数的质因数的幂次之和，这个可以在筛质数的时候顺便求 dp 出来，转移是 $f[i\times p[j]]=f[i]+1$，其中 $p[j]$ 是第 $j$ 个质数。

为防止因火车头无法过审，省略了缺省源，但不影响阅读。
```cpp
void A(){puts("Lucky_Holmes");}
void B(){puts("Angry_Waston");}
void NO(){puts("Draw");}
unsigned a[N],f[M],n;Bool(v,M);vint _;
void init(){
	for(int i=2;i<M;++i){if(!v[i])_+=i,f[i]=1;for(cit&j:_)if(i*j>=M)break;else{v[i*j]=1,f[i*j]=f[i]+1;if(i%j==0)break;}}
	//for(int i=1;i<=1000;++i){int cnt=0;for(int t=i,j=2;j<=t;++j)while(t%j==0)t/=j,++cnt;if(cnt^f[i]){cout<<i<<' '<<f[i]<<' '<<cnt<<'\n';break;}}
}void solve(){//init();
	rd(n);for(int i=1;i<=n;++i)a[i]=f[rd()];
	int cnt1=0,cnt2=0,cnt3=0;
	for(int i=1;i<=n;++i)a[i]==1?++cnt1:a[i]==2?++cnt2:cnt3+=a[i]&1;
	if(cnt1&1)return A();if(cnt1==n)return NO();
	return cnt3&1?A():B();
}signed main(){open;int t=rd();init();//cin>>t;
	while(t--)solve();}
```
程序中有很多没用的东西，个人认为这题很好实现，没必要在意。

---

## 作者：StarTwinkleTwinkle (赞：0)

### Solution

考虑真正的 $a_i$ 是困难的。所以考虑只考虑剩下的数的质因数个数，即再操作几次变成 $1$。

问题转化为：

除以质因子变成了减 $1$，平方变成了 $×2$ ，变成 $0$ 就加分。

如果所有数都是 $2$，则当前的人操作一个数，对方再操作这个数，这个数就成 $0$，因此当前的人需要使用平方操作变成 $4$，然后轮流操作一次就把这个 $2$ 给到对方了。

首先肯定尽可能选质数，因为只要操作质数就能得一分，所以刚开始两人都会先选质数。设选完后两人的分为 $a$ 和 $b$，则有 $a=b$ 或 $a=b+1$。


如果当前轮到后手且 $b \le a$，所以可以平方操作的次数更少，所以后手输了。

如果轮到前者且 $a=b$：前者先使用平方操作，后者再用一次，所有的都抵消了，最后只剩 $2$ 的时候轮到先手，所以后面的所有分都给到了后手。此时判断两人的得分情况。


如果轮到前者且 $a=b+1$：最后只剩 $2$ 的时候轮到后手，所以后手输了。

### code


```cpp
#include<bits/stdc++.h>

int T, a[2000007], n, num[10000007], minn[10000007];

inline void work(int v) {
    for (int i = 2; i <= v; ++i) {
        if (minn[i] == 0) {
            minn[i] = i;
            for (int j = 2 * i; j <= v; j += i) {
                if (minn[j] == 0) {
                    minn[j] = i;
                }
            }
        }
    }
    num[1] = 0;
    for (int i = 2; i <= v; ++i) {
        if (minn[i] == i) {
            num[i] = 1;
        } else {
            num[i] = 1 + num[i / minn[i]];
        }
    }
}
int c, s;
int main() {
    work(10000000);
    std::cin >> T;
    while(T--){
    	c = s = 0;
	    std::cin >> n;
	    for(int i = 1; i <= n; i++){
			std::cin >> a[i];
			a[i] = num[a[i]];
			if(a[i] == 1) c = c + 1;
			else s = s + a[i] - 2;
	    }
	    int ansa = (c + 1) / 2;
	    int ansb = c / 2;
	    s = s & 1;
	    s ^= c & 1;
	    if(s){
			puts("Lucky_Holmes");
			goto lb1;
	    }
		else if(ansa == ansb){
			ansb = ansb + n - c;
	    }
		else{
			puts("Lucky_Holmes");
			goto lb1;
	    }
	    if(ansa == ansb){
			puts("Draw");
			goto lb1;
	    }
		puts("Angry_Waston");	
		lb1:;
	}
    
}
```

---

## 作者：modfish_ (赞：0)

## 思路
首先可以把 $a_i$ 替换为它的所有质因子的幂次之和 $b_i$，于是操作变为 $b_i$ 减去 $1$ 或 $b_i$ 乘上 $2$。

容易发现如果某个人选择给某个 $b_i=2$ 减去 $1$，那么相当于给别人送分，肯定不优。假设一开始没有某个数为 $b_i=1$，那么两个人肯定会先不停地进行减 $1$ 操作，直到所有 $b_i$ 都变成 $2$，这时先手就必输了，且**后手可以得到所有的分数**。容易发现，此时先手胜当且仅当序列和为奇数。

那么如果一开始有 $b_i=1$，两个人肯定会去抢那些 $1$，设有 $m$ 个，那么先手可以抢到 $\lceil\frac{m}{2}\rceil$ 个，后手可以抢到 $\lfloor\frac{m}{2}\rfloor$ 个。之后他们将通过这些 $1$ 给他们的乘 $2$ 操作来尝试扭转局势。接下来分类讨论：

若此时（抢完 $1$ 后），序列的和为奇数，那么先手必胜。这是因为他只要保证他传给后手时，序列的和为偶数即可。若某次他得到的序列和为奇数，他只要给某个非 $2$ 的数减去 $1$ 即可（容易发现非 $2$ 的数一定存在）；若序列和为偶数，他可以给任意一个奇数减去 $1$，或者给任意一个偶数乘上 $2$。而后手若想先手得到和为偶数的序列，必定会需要使用乘 $2$ 操作。抢 $1$ 结束后。先手得到的乘 $2$ 操作必定不少于后手，故他一定可以获胜。

若此时序列的和为偶数，情况则有所不同，先手必须保持序列和为偶数，这意味着他必须对一个偶数进行乘 $2$ 操作；相应地，后手也是如此。所以他们就是在比拼谁的乘 $2$ 更多。若先手的多余后手，那么先手将**可以拿走剩余的分数**；否则后手**可以拿走剩余的分数**。当然，如果序列中不存在偶数，那么后手一定**可以拿走剩余的分数**。

注意以上三个加粗的结果“可以拿走剩余的分数”，强调这一点是因为可以拿走分数不等于他能获胜，能否获胜需要讨论谁的分数多，具体应结合 $m$ 的奇偶性讨论，详情可见代码。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e6 + 5, maxv = 1e7 + 5;

int pr[maxv], isp[maxv], cnt = 0;
int P[maxv], tr[maxv];
int a[maxn];

void prime(int m){
    isp[1] = 1;
    for(int i = 2; i <= m; i ++){
        if(!isp[i]) pr[++ cnt] = i;
        for(int j = 1; j <= cnt && i * pr[j] <= m; j ++){
            isp[i * pr[j]] = 1, P[i * pr[j]] = pr[j];
            if(!(i % pr[j])) break;
        }
    }
}

int main(){
    prime(1e7);
    for(int i = 2; i <= 1e7; i ++){
        if(isp[i]) tr[i] = tr[i / P[i]] + 1;
        else tr[i] = 1;
    }
    int T;
    scanf("%d", &T);
    while(T --){
        int n;
        scanf("%d", &n);
        int cnt = 0, sum = 0, ev = 0;
        for(int i = 1; i <= n; i ++){
            scanf("%d", &a[i]);
            a[i] = tr[a[i]];
            if(a[i] == 1) cnt ++;
            else sum += a[i];
            if(!(a[i] & 1)) ev ++;
        }
        if(sum & 1) printf("Lucky_Holmes\n");
        else{
            if(cnt & 1){
                if(ev) printf("Lucky_Holmes\n");
                else{
                    if(cnt == n) printf("Lucky_Holmes\n");
                    else if(cnt == n - 1) printf("Draw\n");
                    else printf("Angry_Waston\n");
                }
            }else{
                if(cnt == n) printf("Draw\n");
                else printf("Angry_Waston\n");
            }
        }
    }
    return 0;
}
```

---

## 作者：UniGravity (赞：0)

首先发现可以把某个值 $x$ 替换成其由多少个质因数乘起来。那么除以最大的质因数等价于 $x\gets x-1$，平方等价于 $x\gets2x$。得分的条件即为将 $x$ 扣到 $0$。可以线性筛预处理。

然后思考部分分在做什么。如果原数组均为质数，即替换后的数组均为 $1$，发现相当于两人轮流取走一个 $1$ 并得分。这个时候平方操作是没有用的，因为占用的一次机会不如直接取走一个 $1$。

另一个部分分是假设全都大于 $1$，此时发现可以先轮流操作大于 $2$ 的直到全部减为 $2$，原因是两人都不会主动动等于 $2$ 的值。

当全部值都为 $2$ 后，发现若此时的先手（可能发生变化）可以选择操作二，则其一定会选择。即将 $2\to1\to0$ 变成 $2\to4\to3\to2\to1\to0$，奇偶性改变，等价于交换先后手。否则无法选择操作二则相当于对方获得一分。

最后考虑两个特殊性质如何结合到一起。发现一定是先后手都优先选择 $1$ 的部分，选完后转化成特殊性质二。

那么直接维护即可。时间复杂度 $O(n+V)$。

```cpp
const int N=2000005,M=10000005;

vector<int>p;bool np[M];
int cnt[M],mn[M];
il void init(int n){
    cnt[1]=0;
    forto(i,2,n){
        if(!np[i])p.eb(i),mn[i]=i;
        for(int j:p){
            if(i*j>n)break;
            np[i*j]=1,mn[i*j]=j;
            if(i%j==0)break;
        }
    }
    forto(i,2,n)cnt[i]=cnt[i/mn[i]]+1;
}

int n,a[N];

il void work(){
    n=read();
    int c1=0,sum=0,bc=0;
    forto(i,1,n){
        a[i]=cnt[read()];
        if(a[i]==1)c1++;
        else sum+=a[i]-2,bc++;
    }
    int s[2],u[2],nw=c1&1;
    s[0]=(c1+1)/2,s[1]=c1-s[0],u[0]=u[1]=0;
    if(sum&1)nw^=1;
    while(bc){
        if(u[nw]<s[nw])u[nw]++;
        else bc--,s[nw^1]++;
        nw^=1;
    }
    if(s[0]>s[1])puts("Lucky_Holmes");
    else if(s[0]==s[1])puts("Draw");
    else puts("Angry_Waston");
}

signed main(){
    init(10000000);
    int t=read();while(t--)work();
    return 0;
}
```

---


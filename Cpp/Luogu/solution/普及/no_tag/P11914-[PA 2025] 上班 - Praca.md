# [PA 2025] 上班 / Praca

## 题目背景

PA 2025 R1B.

## 题目描述

一天被分为 $n$ 段时间。每段时间可能会有以下三种事情：

1. 举行了一场线下会议；
2. 举行了一场线上会议；
3. 空闲。

每段时间内，Bajtazar 所在的地点可能有三种：

- 在家：
	- 在家里无法参加线下会议（被迫翘掉会议）。
    - 在家里**可以**参加线上会议（也可以选择翘掉会议做题）。
    - 在家里可以做题。
- 在公司：
	- 在公司**必须**参加线下会议。
    - 在公司**必须**参加线上会议。
    - 在公司**无法**做题。
- 在通勤：
	- 通勤时无法参加线下会议（被迫翘掉会议）。
	- 通勤时无法参加线上会议（被迫翘掉会议）。
	- 通勤时无法做题。

一天开始时（第 $1$ 段时间初），Bajtazar 在家里。一天结束时（第 $n$ 段时间末），Bajtazar 必须回到家中。

Bajtazar 可以选择去办公室**至多一次**。从家到办公室、从办公室回家都要通勤。

通勤会消耗 $t$ 段时间，即如果选择在第 $i$ 段时间初开始通勤，在第 $(i+t-1)$ 段时间末会结束通勤。

Bajtazar 想打一辈子算法竞赛，所以他想抽出尽可能多的时间做题。但是他最多能翘掉 $k$ 场会议，请帮他算出至多能用多少个时间段来做题。


## 说明/提示

### 样例解释

样例 $1$ 解释：一个最优解如下。

1. 解题（在家）
2. 线上会议（在家）
3. 解题（在家）
4. 通勤（去办公室）
5. 通勤（去办公室）
6. 线下会议（在办公室）
7. 通勤（回家） 
8. 通勤（回家，被迫翘掉一场会议）
9. 解题（在家） 
10. 线上会议（在家）

- 样例 $2$ 解释：唯一一个解如下。

1. 通勤（去办公室） 
2. 通勤（去办公室） 
3. 线下会议（在办公室） 
4. 空闲（在办公室） 
5. 线上会议（在办公室） 
6. 通勤（回家） 
7. 通勤（回家）

- 样例 $3$ 解释：一整天都待在家里，翘掉所有会议。
- 样例 $4$ 解释：第一场会议和最后一场会议都无法参加。

### 数据范围

- $3\le n\le 8\, 000$；
- $0\le k\le n$；
- $1\le t\lt n/2$。


## 样例 #1

### 输入

```
10 1 2
3233313132```

### 输出

```
3```

## 样例 #2

### 输入

```
7 0 2
3313233```

### 输出

```
0```

## 样例 #3

### 输入

```
6 5 1
231323```

### 输出

```
6```

## 样例 #4

### 输入

```
4 1 1
1331```

### 输出

```
-1```

# 题解

## 作者：zhuoheng (赞：9)

简化一下题意：                 
给定一个长为 $n$ 的字符串 $s$，表示 $n$ 段时间，有三种情况，分别表示线上会议，线下会议和空闲时间。                                    
线下会议只能在公司参加，线上会议在公司和家中均可参加，空闲时间可以做题。             
可以选择使用 $t$ 段时间通勤去到公司，但只能去一次，且通勤时间能不能做题也不能参加会议。                           
**注意最后必须回到家中，所以必然会有两段通勤时间。**                    
总共可以翘掉 $k$ 次会议，只有空闲时间或者被翘掉且不在通勤的时间可以做题。    


---

读完了题意后，这道题的大致轮廓就比较清晰了。             
我们可以发现由于**只能去公司一次**，所以只要确定了通勤时间后做题时间可以通过前缀和直接计算。   
计算过程就是把通勤时间内的会议数量 $cnt$ 先和 $k$ 作比较，然后大于就直接略过，小于就让 $k$ 直接减去 $cnt$ 然后对于通勤时间和在公司时间外的所有线下会议数量 $cnt1$ 和剩余的 $k$ 作比较，小于也是直接略过不考虑，然后让剩余的 $k$ 减一次 $cnt1$ 接着就是把剩下空闲的时间和剩余可以被翘掉的会议加到答案中。        
可以发现此题数据不大，所以直接枚举通勤的时间然后比较计算最大即可。                
代码如下：

```cpp
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
const int N=8001;
int n,k,t,pre1[N],pre2[N],pre3[N],mx=-1;
string s;
int gt_sm(int op,int l,int r){
	if(op==1)return pre1[r]-pre1[l-1];
	else if(op==2)return pre2[r]-pre2[l-1];
	else return pre3[r]-pre3[l-1];
}
int solve(int l,int r){
	int res,tk=k,cnt;
	tk-=gt_sm(1,l-t,l-1)+gt_sm(2,l-t,l-1);
	tk-=gt_sm(1,r+1,r+t)+gt_sm(2,r+1,r+t);
	if(tk<0)return -1;
	l-=t+1,r=min(n+1,r+t+1);
	res=gt_sm(3,1,l)+gt_sm(3,r,n);
	cnt=gt_sm(1,1,l)+gt_sm(1,r,n);
	if(tk<cnt)return -1;
	cnt+=gt_sm(2,1,l)+gt_sm(2,r,n);
	return res+min(cnt,tk);
}
int main(){
	ios;
	cin>>n>>k>>t>>s;
	for(int i=1;i<=n;++i){
		pre1[i]=pre1[i-1],pre2[i]=pre2[i-1],pre3[i]=pre3[i-1];
		if(s[i-1]=='1')pre1[i]++;
		else if(s[i-1]=='2')pre2[i]++;
		else pre3[i]++;
	}
	if(k>=pre1[n])cout<<min(n,k+pre3[n]),exit(0);
	for(int i=t+1;i<=n-t+1;++i)
		for(int j=i;j<=n-t;++j)
			mx=max(mx,solve(i,j));
	cout<<mx;
}

```

---

## 作者：BennyT (赞：3)

# P11914 [PA 2025] 上班 / Praca 题解
## 思路
首先如果当前线下会议数量 $\le k$ 的情况下使可以直接在家里躺一天的，因为线上会议在家里上就行，这种情况显然是最优的，为我们省下最多的时间。

如果当前线下会议数量 $> k$，我们可以直接枚举每个区间，使用前缀和维护会议数，就可以通过本题。

本题代码细节较多，具体细节见代码。
## 代码
```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<math.h>
#include<vector>
#include<queue>
using namespace std;
typedef long long ll;
int n,k,t,tot[8010],tot2[8010];
string s;
int main(){
	cin>>n>>k>>t>>s;
	s=" "+s;
	int a=0,b=0,c=0;//分别表示线下会议数，线上会议数和空闲时间数 
	for(int i=1;i<s.size();i++){
		if(s[i]=='1')a++;
		else if(s[i]=='2')b++;
		else c++;
		tot[i]=tot[i-1]+(s[i]=='1')+(s[i]=='2');//记录总会议数的前缀和 
		tot2[i]=tot2[i-1]+(s[i]=='2');//记录线上会议数的前缀和 
	}
	if(a<=k){//如果可以在家里躺一天 
		cout<<c+a+min(k-a,b);
		return 0;
	}
	int ans=-1;
	for(int i=t+1/*舍去通勤时间*/;i<s.size()-t/*舍去通勤时间*/;i++){//枚举上班区间，左端点为i，右端点为j 
		for(int j=i;j<s.size()-t/*舍去通勤时间*/;j++){
			int c=tot[j]-tot[i-1]/*表示在公司可以参加的会议数*/,h=tot2[s.size()-1]-tot2[j+t]+tot2[i-t-1]/*表示在家可以参加的会议数*/;
			if(a+b-c-h<=k){//如果当前区间满足条件 
				ans=max(ans,n/*总天数*/-(j-i+1+2*t)/*在公司+通勤时间*/-h/*在家可以参加的会议数*/);
			}
		}
	}
	cout<<ans;//输出答案 
	return 0;
}
```

---

## 作者：Mark_Pei (赞：1)

## Solution

这道题我个人的解法偏向~~贪心~~前缀和，如果感觉次可以看看其它区间动规的。

首先我们知道如果当前线下会议数量 $≤k$ 的情况下是可以翘掉所有线下会议家里一天的，因为在家里就可以参加线上会议，这种情况显然是最方便也是最优的，省下了最多的时间。

再来想想如果当前线下会议数量 $>k$ 的话，我们可以开两个数组，直接使用前缀和枚举每个区间会议数，然后比出最优方案就行了。

**Tip**：总和可以先开 $-1$，这样就不用结束再判断是否能翘会议了。

**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t,a,b,c,x[10003],y[10003],cnt=-1;//总和先开-1，这样就不用判断是否能翘会议了
string s;
int main()
{
	cin>>n>>k>>t>>s;
	s=" "+s;
    int l=s.size();
	for(int i=1;i<l;i++)//前缀和
    {
		if(s[i]=='1') a++;
		else if(s[i]=='2') b++;
		else c++;
		x[i]=x[i-1]+(s[i]=='1')+(s[i]=='2');
		y[i]=y[i-1]+(s[i]=='2');
	}
	if(a<=k)//特判
    { 
		cout<<a+c+min(b,k-a);
		return 0;
	}
	for(int i=t+1;i<l-t;i++)//枚举区间
    {
		for(int j=i;j<l-t;j++)
        {
			int d=x[j]-x[i-1];
            int e=y[l-1]-y[j+t]+y[i-t-1];
			if(a+b-d-e<=k) cnt=max(cnt,n-j+i-1-2*t-e);
		}
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：nbhs23a28 (赞：1)

本题是一道练习枚举的好题。

首先我们看数据范围 $n \le 8000$，而题目又限制最多去一趟公司。于是我们便有了一个很自然的枚举思路：只需枚举出发时间和返回时间即可（双重循环），此时我们只要开数组预处理家中和公司中会议数就可以判断了。其中，公司中会议数我们可采取区间动态规划得到。（其中细节不再赘述）

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t,cnt1[8010],cnt2[8010],cnt[8010][8010],_max=-1;
char c[8010];
int main()
{cin>>n>>k>>t;
 k=-k;
 for(int i=1;i<=n;i++)
 {cin>>c[i];
  if(c[i]!='3') k++;
 }
 k=max(k,0);
 //此后k表示需参加会议数
 for(int i=1;i<=n;i++)
 {cnt1[i]=cnt1[i-1];
  if(c[i]=='2') cnt1[i]++;
 }
 for(int i=n;i>=1;i--)
 {cnt2[i]=cnt2[i+1];
  if(c[i]=='2') cnt2[i]++;
 }
 if(cnt1[n]>=k) //不必上班
 {cout<<n-k;
  return 0;
 }
 for(int i=1;i<=n;i++)
 cnt[i][i]=(c[i]!='3');
 for(int i=1;i<n;i++)
 {for(int j=1;j<=n-i;j++)
  cnt[j][i+j]=cnt[j][j]+cnt[j+1][i+j];
 }
 for(int i=1;i<=n-2*t;i++) //go
 {int cntl=cnt1[i-1];
  for(int j=i+t+1;j<=n-t+1;j++)//back
  {int cntr=cnt2[j+t];
   if(cnt[i+t][j-1]+cntl+cntr<k) continue;
   if(cnt[i+t][j-1]>=k) 
   _max=max(_max,i-1+n-(j+t-1));
   else
   _max=max(_max,i-1+n-(j+t-1)-(k-cnt[i+t][j-1]));
  }
 }
 cout<<_max;
}
```

---

## 作者：reinforest (赞：0)

前缀和优化好题。

因为这个人一天最多只能上班一次，所以我们可以分类讨论这个人上班还是不上班。

如果上班，结合 $n \leq 8000$ 可知我们可以枚举这个人上班的两个端点 $i,j$，其中 $i < j$。然后我们可知：

- 时间 $[1,i-t-1]$ 和 $[j+t+1,n]$ 是这个人在家的时间段；
- 时间 $[i-t,i-1]$ 和 $[j+1,j+t]$ 是这个人通勤的时间段；
- 时间 $[i,j]$ 是这个人工作的时间段。

对于每一个 $[i,j]$ 我们可以定义 $4$ 个变量。

- $trs$ 表示**通勤时**翘掉的**所有**会议总数。
- $mis$ 表示**在家时**的**线下**会议总数。
- $pro$ 表示**在家时**的**空闲**时间总数。
- $fre$ 表示**在家时**的**线上**会议总数。

那么我们进行大力分讨：

- 如果 $trs+mis>k$，说明必须翘的会议大于允许翘的会议总数，直接跳过，不统计答案。
- 如果 $trs+mis+fre<=k$，说明全部的可以翘的、必须翘的会议之和小于允许翘的会议总数，说明可以都翘，做题的时间为 $pro+mis+fre$。
- 如果 $trs+mis+fre>k$，说明有些在家时的线上会议必须参加，只能翘 $k-mis-trs$ 个线上会议，做题的时间为 $pro+mis+k-mis-trs$，即为 $pro+k-mis$。

对于每一个 $i,j$ 维护最大值即可。

快速求 $[l,r]$ 中的以上四个变量可以用前缀和数组维护，先预处理出 $[1,r]$ 中的前缀和，想求 $[l,r]$ 就用 $[1,r]$ 减去 $[1,l]$ 即可。

如果不上班，实际上就是在家的区间为 $[1,n]$ 的特殊情况，按照以上方法分类即可。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k,t,ans=-1;
char arr[16005];
ll ava[8005],onl[8005],ofl[8005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k>>t;
	cin>>(arr+1);
	for(int i=1;i<=n;i++){
		ofl[i]=ofl[i-1]+(arr[i]=='1');
		onl[i]=onl[i-1]+(arr[i]=='2');
		ava[i]=ava[i-1]+(arr[i]=='3');
	}
	//不上班 
	if(ofl[n]<=k){
		if(ofl[n]+onl[n]>k){
			ans=max(ans,ava[n]+k);
		}else{
			ans=max(ans,ava[n]+ofl[n]+onl[n]);
		}
	}
	//上班 
	for(int i=t+1;i<=n;i++){//枚举上班的起点
		for(int j=i;j<=n-t;j++){//枚举上班的终点
			ll trs=(ofl[i-1]-ofl[i-t-1]+ofl[j+t]-ofl[j])
			+(onl[i-1]-onl[i-t-1]+onl[j+t]-onl[j]);//通勤时的线下会议+通勤时的线上会议 
			ll mis=ofl[i-t-1]+ofl[n]-ofl[j+t];//在家时的线下会议
			ll pro=ava[i-t-1]+ava[n]-ava[j+t];//在家可以做题的时间
			ll fre=onl[i-t-1]+onl[n]-onl[j+t];//在家可参加可不参加会议的时间
			if(trs+mis>k)continue;
			if(trs+mis+fre>k)ans=max(ans,pro+k-trs);
			else ans=max(ans,pro+fre+mis);
		} 	
	}
	cout<<ans<<"\n";
	return 0;
} 
```

---


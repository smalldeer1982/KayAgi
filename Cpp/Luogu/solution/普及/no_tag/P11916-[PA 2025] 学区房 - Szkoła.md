# [PA 2025] 学区房 / Szkoła

## 题目背景

PA 2025 R2C.


## 题目描述


有 $n$ 栋建筑在一条笔直的马路上，自西向东依次编号为 $1\sim n$。相邻两栋建筑的距离为 $1$ 米。

有 $m$ 个两两不交的区间 $[l_i,r_i]$，表示编号在 $[l_i,r_i]$ 内的房子**不**提供租赁服务。

有一所学校，在编号为 $s$ 的建筑中。保证编号为 $s$ 的建筑**不**提供租赁服务。

现在想要选择一栋提供租赁服务的建筑 $p$，最小化到学校的距离（即最小化 $|s-p|$）。请帮忙求出这栋建筑的编号。



## 说明/提示


### 样例解释

- 样例 $1$ 解释：$p=4,10$ 是两个解。由于要求编号最小，输出 $4$。
- 样例 $2$ 解释：只有唯一的一栋提供租赁服务的建筑，即编号 $14$ 的建筑。

### 数据范围


- $ 2 \leq n \leq 10^{12}$；
- $1 \leq m \leq 1000$；
- $1 \leq s \leq n $；
- 编号为 $s$ 的建筑**不**提供租赁服务；
- $m$ 个区间两两不交；
- 至少存在一栋建筑提供租赁服务。


## 样例 #1

### 输入

```
10 2 7
5 9
1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
15 4 9
4 5
10 13
1 1
6 9```

### 输出

```
14```

# 题解

## 作者：laiyouming (赞：4)

#### 思路
我们先和并区间(就是将 $[l_i,r_i]$ 和 $[r_i+1,r_j]$ 合并成 $[l_i,r_j]$)，然后就看每一个区间的两端(对于所有区间 $[l_i,r_i]$ 我们看 $|(l_i-1)-s|$ 和 $|(r_i+1)-s|$ 的 $min$)，最后记录答案。

**注意**：要注意建筑编号为 $1\sim n$，$l_i-1$ 可能小于1，$r_i+1$ 可能大于 $n$。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,t,ans=1e18,ans2,top;
pair<long long,long long>a[1001];
int main(){
	scanf("%lld%lld%lld",&n,&m,&t);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&a[i].first,&a[i].second);
	}
	sort(a+1,a+m+1);
	top=0;
	for(int i=1;i<=m;i++){
		if(i==1||a[i].first!=a[top].second+1){
			a[++top]=a[i];
		}
		else{
			a[top].second=a[i].second;
		}
	}
	for(int i=1;i<=top;i++){
		long long x=a[i].first,y=a[i].second;
		x--,y++;
		if(x>=1&&abs(x-t)<ans){
			ans=abs(x-t),ans2=x;
		}
		if(y<=n&&abs(y-t)<ans){
			ans=abs(y-t),ans2=y;
		}
		if(x>=1&&abs(x-t)==ans){
			ans2=min(ans2,x);
		}
		if(y<=n&&abs(y-t)==ans){
			ans2=min(ans2,y);
		}
	}
	printf("%lld",ans2);
}
```

---

## 作者：BJqxszx_zhuyukun (赞：4)

## 暴力

向左向右依次遍历每一个点，找到第一个不在区间内的点。

时间复杂度：$O(nm)$.

## 正解

$m$ 非常小，所以我们可以从 $m$ 突破。

我们可以直接跳过区间内的所有点，这样复杂度就是 $O(m)$ 了。但是，我们要按照什么顺序呢？

显然，往左走的时候，$r$ 越大，我们会越早遇到（前提是 $l \leq s$）。所以我们按照 $r$ 从大到小排序。

如果我们位于 $p$，但是 $r<p$，那么就说明我们已经找到了第一个提供租赁服务的建筑。

否则如果 $l \leq p \leq r$，也就是我们位于一个区间内，那么我们直接跳跃到 $l-1$ 即可。

向右走的部分也差不多，按照 $l$ 从小到大排序。可以自己思考一下。

最后判断谁更近的时候要注意，有可能一个位置已经离开了马路（$p \leq 0$ 或者 $p>n$），需要排除掉。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll MAXN=1e3+13;
struct node{
    ll l,r;
    inline bool operator<(const node &a) const{return r>a.r;}
    inline bool operator>(const node &a) const{return l<a.l;}
};
ll n,m,s,ansa,ansb;
node a[MAXN];
int main(){
    cin>>n>>m>>s;
    ansa=ansb=s;
    for(ll i=1;i<=m;i++) cin>>a[i].l>>a[i].r;
    sort(a+1,a+1+m);//排序
    for(ll i=1;i<=m;i++){//向左
        if(ansa>a[i].r) break;
        if(ansa>=a[i].l) ansa=a[i].l-1;
    }
    sort(a+1,a+1+m,greater<node>());//排序
    for(ll i=1;i<=m;i++){//向右
        if(ansb<a[i].l) break;
        if(ansb<=a[i].r) ansb=a[i].r+1;
    }
    if(ansa<=0) cout<<ansb;//计算答案
    else if(ansb>n) cout<<ansa;
    else if(s-ansa==ansb-s) cout<<ansa;
    else if(s-ansa<ansb-s) cout<<ansa;
    else cout<<ansb;
    return 0;
}
```

---

## 作者：MC_dmAC (赞：2)

**[传送门](https://www.luogu.com.cn/problem/P11916)**

第一眼看到这题可能会想直接 bool 数组暴力判断，但是看到 $n$ 的范围自然会打消这个想法（虽然说实际数据好像没有到这个范围，暴力也能过 awa）。

但是我们可以看到，题目中 $m$ 的范围极小，自然，我们要对**不租赁的房子链**的两端进行处理。

我们先找到学校 $s$ 所在的区间内（由题目可知，必然有一段**不租赁的房子链**包含 $s$），那么我们让 $r$ 为右侧最近端点，$l$ 即为左侧最近端点，显然 $l=r-1$。

接下来，我们由 $l$ 和 $r$ 分别向两端搜索最近的**可租赁的房子**。

ps：每次增减 $2$ 是为了保证 $l$ 一直是左端点，$r$ 同理。

ps2：由题目的数据保证可知，题目必然有解，所以当 $l$ 搜到最左端并且等于 $1$ 时，答案必然为 $a_r+1$，$r$ 同理。

## AC code

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define f(n) for(int i=1;i<=n;i++)
#define ll long long
ll n,m,s,l,r; 
ll a[2025];
int main()
{
	cin>>n>>m>>s;
	f(m)cin>>a[i*2-2]>>a[i*2-1];//从0开始
	sort(a,a+2*m);
	while(a[r]<=s)
		if(a[r]==s&&r&1==1)break;//出现诸如(50,50)的情形时让r在右侧停下
		else r++;
	l=r-1;
	while(l>0&&a[l]-1==a[l-1])l-=2;
	while(r<=2*m-1&&a[r]+1==a[r+1])r+=2;
	if(a[l]<=1)cout<<a[r]+1;//左端没有房
	else if(a[r]==n)cout<<a[l]-1;//右端没有房
	else if(s-a[l]<=a[r]-s)cout<<a[l]-1;
	else cout<<a[r]+1;
	return 0;
}
```

---

## 作者：Circle_Table (赞：2)

思路：由于 $n$ 数据范围过大，显然不能直接全部遍历。注意到所有区间两两不交，显然可以对所有的区间进行排序，然后从小到大对区间进行遍历，由于 $m$ 并不算大，这种方案自然是可行的。

已知学校是在一个区间内的（保证编号为 $s$ 的建筑不提供租赁服务）但不确定学校所在的区间两端是否有其他区间挨着它。我们直接将相邻的区间进行合并。需要合并的区间左端点不变，右端点向后延伸即可。

随着我们遍历完越来越多的区间，一定会等到一个区间包含学校所在的建筑。合并该区间，直到无法再合并，比较这个区间的左端点离学校近还是右端点离学校近，从而得出答案。

要注意的是，所求的这栋建筑不应该在此区间内，所以答案是左端点的左边一个，或右端点右边一个的位置。所求出的左端点为 $1$，或右端点为 $n$ 时，向左或向右一个都会超出题目所给的范围，这样就不合法。因此还需要特判左端点为 $1$ 或右端点为 $n$ 这两种情况。又因为题目保证有解，因此这种情况下只需要输出另外一个端点就可以了。到这里思路基本上清晰了。更多细节就请看代码注释。

**AC代码如下**

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
ll n,s,p,q;
//学校所在区间的左端点为 p，学校所在区间的右端点为 q。
int m,flag;
struct node{
	ll l,r;
}a[1145];
bool cmp(node a,node b){
	return a.l<b.l;
//所有区间两两不交，因此左端点排序了右端点自动有序。
}
int main(){
	ios;cin>>n>>m>>s;
	for(int i=1;i<=m;i++){
		cin>>a[i].l>>a[i].r;
	}
	sort(a+1,a+1+m,cmp);
	for(int i=1;i<=m;i++){
		if(a[i].r+1==a[i+1].l){
			a[i+1].l=a[i].l;
//这样下一个区间左端点不变，右端点向右延伸。
			continue;
		}
		if(a[i].l<=s&&a[i].r>=s){
//由于题目保证一定有解:
			p=a[i].l-1,q=a[i].r+1,flag=1;
			if(q>n)cout<<p;//右端点不合法则左端点为答案。
			else if(p<1)cout<<q;//左端点不合法则右端点为答案。
			else if(s-p<=q-s)cout<<p;//左端点比右端点离 s 近或距离相等取小的。
			else if(s-p>q-s)cout<<q;//右端点比左端点离 s 近。显然用 else 也是可以的。
			return 0;
		}
	}
}
```

感谢阅读！

---

## 作者：nbhs23a28 (赞：2)

一道区间贪心结合二分查找水题。

根据题意，由于学校不提供租赁服务，可知学校必在不提供租赁服务区间内，我们很容易想到只需考虑二分查找该区间左右端点相邻点，再比较与学校距离即可。注意到区间虽不相交但左右端可能相邻，只需合并区间即可。这样时间复杂度来到了对数级别，足以通过本题。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,s,l[1010],r[1010],l1[1010],r1[1010];
int main()
{cin>>n>>m>>s;
 for(int i=1;i<=m;i++)
 cin>>l[i]>>r[i];
 sort(l+1,l+1+m);sort(r+1,r+1+m);
 int j=1;l1[1]=l[1];r1[1]=r[1];
 for(int i=2;i<=m;i++)
 {if(l[i]==r[i-1]+1) r1[j]=r[i];
  else
  {l1[++j]=l[i];
   r1[j]=r[i];
  }
 }
 int id=lower_bound(r1+1,r1+1+j,s)-r1;
 if(r1[id]+1>n) cout<<l1[id]-1;
 else if(l1[id]-1<=0) cout<<r1[id]+1;
 else if(s-l1[id]<=r1[id]-s) cout<<l1[id]-1;
 else cout<<r1[id]+1;
}
```

---

## 作者：Mark_Pei (赞：1)

## Solution

**解题思路:**

我们需要找出所有被禁止的区间，然后剩下的建筑就是可以租赁的。学校所在的建筑 $s$ 是被禁止的，所以不需要特别处理。

给定的 $m$ 个区间已经是两两不交的，但可能没有按顺序排列。为了处理方便，我们可以先对这些区间按照左端点进行排序。

我们需要在禁止区间之外找到离 $s$ 最近的建筑。具体来说：

- 对于 $s$，最近的建筑可能在左边或右边。

- 我们需要检查 $s$ 左边第一个未被禁止的建筑和 $s$ 
右边第一个未被禁止的建筑，然后比较它们的距离。

**AC code**
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,s,minn=1000000000000000000,minx;
struct node{
	int l,r;
}a[1003];
bool cmp(node a,node b)
{
	return a.l<b.l;
}
signed main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++) 
        cin>>a[i].l>>a[i].r;
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		if(a[i].l!=a[i-1].r+1&&minn>abs(s-a[i].l+1)&&a[i].l-1>=1) 
        {
            minx=a[i].l-1;
            minn=abs(s-a[i].l+1);
        }
		if(a[i].r!=a[i+1].l-1&&minn>abs(a[i].r+1-s)&&a[i].r+1<=n)
        {
            minx=a[i].r+1;
            minn=abs(a[i].r+1-s);
        }
	}
	cout<<minx; 
    return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：1)

这题 $m$ 很小，直接暴力也可以过，但是要特判最小化编号，个人感觉比正解还复杂。

将输入的区间排序，因为题目保证区间两两不交，所以按左端点或右端点排都行。然后对于每个区间，如果它左边一格没有区间就更新答案，如果右边一格没有区间也更新答案，最后就求出最小了。

注意判断边界情况，并且左边要比右边先判，不然有可能输出非最小编号。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{
	int l,r;
}a[1005];
bool cmp(node A,node B)
{
	return A.l<B.l;
}
signed main()
{
	int n,m,s;
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++) cin>>a[i].l>>a[i].r;
	sort(a+1,a+m+1,cmp);
	int minn=1e18,minv;
	for(int i=1;i<=m;i++)
	{
		if(a[i].l!=a[i-1].r+1&&minn>abs(s-a[i].l+1)&&a[i].l-1>=1) minn=abs(s-a[i].l+1),minv=a[i].l-1;
		if(a[i].r!=a[i+1].l-1&&minn>abs(a[i].r+1-s)&&a[i].r+1<=n) minn=abs(a[i].r+1-s),minv=a[i].r+1;
	}
	cout<<minv; 
    return 0;
}
```

---

## 作者：cold_jelly (赞：1)

### 思路分析

虽然 $n$ 的数据范围很吓人喵，但本题跟 $n$ 其实没有多大关系。

容易想到，因为编号为 $s$ 的学校不提供租赁服务，即 $s\in [l_i,r_i]$，所以答案一定在给定的 $m$ 个闭区间的其中一个的左或右端点边上。

所以我们可以根据左端点排序，找到所有**能**提供租赁服务的区间的左右端点，对 $s$ 求最小距离即可。

特别地，我们需要特判第 $1$ 个区间的左端点和第 $m$ 个区间的右端点是否能对答案产生贡献。

注意题目要求的是编号，而不是最小距离。

### 代码实现


```cpp
#include<bits/stdc++.h>
#define int long long
#define l first
#define r second
using namespace std;
const int N = 1e3 + 10, INF = 1e15;
int n, m, s, ans = INF, id;
//ans：最小距离
//id：答案编号 
pair<int, int> a[N];
signed main()
{
	cin >> n >> m >> s;
	for(int i = 1; i <= m; i ++)
		cin >> a[i].l >> a[i].r;
	sort(a + 1, a + 1 + m);
	for(int i = 1; i <= m; i ++)
	{
		if(i == 1)//特判 
		{
			if(a[i].l == 1) continue;
			else
			{
				if(ans > abs(s - (a[i].l - 1)))
					ans = abs(s - (a[i].l - 1)), id = a[i].l - 1;
			}
		}
		else
		{
			if(a[i - 1].r < a[i].l - 1)
			{
				if(ans > abs(s - (a[i - 1].r + 1)))
					ans = abs(s - (a[i - 1].r + 1)), id = a[i - 1].r + 1;
				if(ans > abs(s - (a[i].l - 1)))
					ans = abs(s - (a[i].l - 1)), id = a[i].l - 1;
			}
		}
	}
	if(a[m].r < n)//特判 
		if(ans > abs(s - (a[m].r + 1)))
			ans = abs(s - (a[m].r + 1)), id = a[m].r + 1;
	cout << id;
	return 0;
}
```

---

## 作者：ggylz49 (赞：0)

## 思路分析
本题 $m$ 的数据范围最大只有 $1000$，所以可以暴力枚举，对于每一个**不可租赁区间**，判断其左右是否有**可租赁区间**，进行处理。具体操作如下。
### 前置代码内容
可以用结构体存储不可租赁区间的 $l_i,r_i$，并按区间左端点从小到大排序，方便处理。由于区间不重合，所以排序预处理很简单，直接 sort 即可，平均时间复杂度为 $O(m \log m)$。

头文件方面，除了输入输出流（`<iostream>`）外，还有计算 $|s-p|$ 的绝对值函数需要用的数学函数库（`<cmath>`）以及排序的算法库（`<algorithm>`）。

以下是输入并排序的代码：

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
long long n,m,s;
struct building
{
    long long l,r;
}a[1010];
bool cmp(building x,building y)//左端点排序
{
    return x.l<y.l;
}
int main()
{
    cin>>n>>m>>s;
    for (int i=1;i<=m;i++)cin>>a[i].l>>a[i].r;
    sort(a+1,a+m+1,cmp);
    //做一些事
    return 0;
}
```
### 判断是否存在区间
首先，定义 `long long` 类型变量 $minn,minb$ 分别存储当前最小的 $|s-p|$ 和最小 $|s-p|$ 对应的楼的编号。

```cpp
long long minn=1000000000000,minb=1;
```
然后遍历所有**不可租赁区间**，依次判断其左右是否存在可租赁区间。在下方详细说明中，用 $a_il$ 表示从左向右第 $i$ 个**不可租赁区间**的左端点；以此类推，用 $a_ir$ 表示从左向右第 $i$ 个**不可租赁区间**的右端点。

#### 详细说明：
- 如果左边存在可租赁区间，那么**上一不可租赁区间**与**本不可租赁区间**不相连，即 $(a_{i-1}r)+1\not = a_il$；
- 如果右边存在可租赁区间，那么**下一不可租赁区间**与**本不可租赁区间**不相连，即 $(a_{i+1}l)-1\not = a_ir$；

具体代码如下：

```cpp
for (int i=1;i<=m;i++)//从左至右遍历
{
    if (a[i].l-1!=a[i-1].r&&a[i].l-1>=1)//如果存在左区间且在1-n之间
    {
        //更新答案
    }
    if (a[i].r+1!=a[i+1].l&&a[i].r+1<=n)//如果存在右区间且在1-n之间
    {
        //更新答案
    }
}
```
### 更新答案
具体如何更新答案？很简单，如果是左区间，则判断左区间右端点与学校的距离（$|s-p|$）是否更小，更新答案；如果是右区间，则判断右区间左端点与学校的距离（$|s-p|$）是否更小，更新答案。代码如下：

```cpp
for (int i=1;i<=m;i++)
{
    if (a[i].l-1!=a[i-1].r&&a[i].l-1>=1)//如果存在左区间
    {
        if (minn>abs(s-(a[i].l-1)))minn=abs(s-(a[i].l-1)),minb=a[i].l-1;//更新答案
    }
    if (a[i].r+1!=a[i+1].l&&a[i].r+1<=n)//如果存在右区间
    {
        if (minn>abs(s-(a[i].r+1)))minn=abs(s-(a[i].r+1)),minb=a[i].r+1;//更新答案
    }
}
```
## Code
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
long long n,m,s;
struct building
{
    long long l,r;
}a[1010];
bool cmp(building x,building y)
{
    return x.l<y.l;
}
int main()
{
    cin>>n>>m>>s;
    for (int i=1;i<=m;i++)cin>>a[i].l>>a[i].r;
    sort(a+1,a+m+1,cmp);
    long long pos=0,minn=1000000000000,minb=1;
    for (int i=1;i<=m;i++)
    {
        if (a[i].l-1!=a[i-1].r&&a[i].l-1>=1)
        {
            if (minn>abs(s-(a[i].l-1)))minn=abs(s-(a[i].l-1)),minb=a[i].l-1;
        }
        if (a[i].r+1!=a[i+1].l&&a[i].r+1<=n)
        {
            if (minn>abs(s-(a[i].r+1)))minn=abs(s-(a[i].r+1)),minb=a[i].r+1;
        }
    }
    cout<<minb;
    return 0;
}
```

---

## 作者：Doraeman (赞：0)

学区房在某些城市还真的是个神秘的东西，随随便便就能租个好价钱。
## 区间合并
### 步骤
1. 对每个区间从小到大排序（可按照左端点，也可按照右端点排序，因为区间不交）。
2. 从 $1$ 到 $m$ 扫过所有区间，**如果某个区间的右端点和下一个区间的左端点刚好相邻**，那么这两个区间可以合并。
3. 把新合并得到的区间记录在另外一个数组里。
### 部分代码
```cpp
for(int i=1; i<=m; i++){
    int j;
    for(j=i; j<m; j++)
    	if(a[j].right + 1 != a[j+1].left)
    	    break;
    			
	t[++cnt].left = a[i].left,
	t[cnt].right = a[j].right;
	i = j;
}
```
在代码中，我使用数组 $t$ 记录新的区间。  
第 $4$ 行的判断语句用作检查这个区间能否合并。
## 处理区间
注：我们用 $L$ 表示区间左端点，$R$ 表示区间右端点。

**如果某个区间包含学校，即 $L\leqslant s\leqslant R$，那么我们处理这个区间**，否则不处理。  
### 处理方法
显然，这个区间内任何的点都不能被租聘，也就是不能作为答案。  
那么，到 $s$ 距离最近的点一定是 $L-1$ 和 $R+1$ 中的一个。接下来直接判断这两个点到 $s$ 的距离即可。

注意：**若 $L=1$ 即 $L-1=0$，$L-1$ 必然不是正确的解，直接得到答案为 $R+1$（因为题目保证有解）。同理，若 $R=n$，也可以直接得到答案为 $L-1$**。~~我在这里卡了好久，呜呜。~~
### 部分代码
```cpp
ll ans(ll s, ll x, ll y){
	ll L = x - 1, R = y + 1;
	
	if(!L) return R;
	if(R > n) return L;
	
	if(s - L > R - s)
		return R;
	return L;
}
for(int i=1; i<=cnt; i++)
	if(t[i].left <= s && s <= t[i].right){
		cout << ans(s, t[i].left, t[i].right);
		return 0;
	}
```
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M = 1e3+5;

ll n, s; int m;
struct House{
	ll left, right;
}a[M], t[M]; int cnt;

bool cmp(House x, House y){
	return x.left < y.left;
}

ll ans(ll s, ll x, ll y){
	ll L = x - 1, R = y + 1;
	
	if(!L) return R;
	if(R > n) return L;
	
	if(s - L > R - s)
		return R;
	return L;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
    cin >> n >> m >> s;
    for(int i=1; i<=m; i++){
    	ll x, y; cin >> x >> y;
    	a[i].left = x,
    	a[i].right = y;
    }
    	
    sort(a + 1, a + m + 1, cmp);

    // 区间合并
    for(int i=1; i<=m; i++){
    	int j;
    	for(j=i; j<m; j++)
    		if(a[j].right + 1 != a[j+1].left)
    			break;
    			
		t[++cnt].left = a[i].left,
		t[cnt].right = a[j].right;
		i = j;
	}

  // 处理区间
	for(int i=1; i<=cnt; i++)
		if(t[i].left <= s && s <= t[i].right){
			cout << ans(s, t[i].left, t[i].right);
			return 0;
		}
}
```

---

## 作者：tuboshu666 (赞：0)

## 思路
简化题意：本题其实就是要找到 $s$ 的最近可选位置。

直接枚举每个位置一定不行。但注意到 $m \leq 1000$，可以从枚举区间入手。

由于题目保证区间两两不交，因此可以将区间按左端点或右端点大小进行排序。利用区间两两不交，还可以通过判断两个区间左右端点是否紧邻，来判断区间之间是否存在可选的位置。

于是问题转化为：从包含 $s$ 的区间出发，怎么找到左右最近可选位置。以 $s$ 右侧为例。直观地，在 $s$ 右侧区间中，找到第一个右端点没有和下一区间左端点紧邻的区间，其右端点后一个位置 $r+1$ 可选且最优。对于 $s$ 左侧，最优位置也是同理。最后将左右两个最优位置进行比较即可。

## Code
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

//PII中first代表左端点，second代表右端点
typedef pair<long long,long long> PII;
const int N = 1010;
PII p[N]; //记录区间左右端点

int main()
{
   ios::sync_with_stdio(false);
   cin.tie(0);
   cout.tie(0);

   //不开long long见祖宗
   long long n,m,s;
   cin >> n >> m >> s;
   for (int i = 1 ; i <= m ; i++) cin >> p[i].first >> p[i].second; //输入左右端点
   sort(p+1,p+m+1); //区间按左端点从小到大排序
   int id; //s所在的区间编号
   for (int i = 1 ; i <= m ; i++)
   {
      if (s >= p[i].first && s <= p[i].second)
      {
         id = i;
         break;
      }
   }

   long long l = -1;
   long long r = -1;
   if (p[1].first != 1) l = p[1].first - 1; //特判最左区间
   if (p[m].second != n) r = p[m].second + 1; //特判最右区间
   for (int i = id ; i >= 2 ; i--) //从id区间遍历到左边第2个区间
   {
      if (p[i-1].second != p[i].first - 1) //如果i-1区间没有和i区间紧邻
      {
         l = p[i].first - 1;
         break;
      }
   }
   for (int i = id ; i < m ; i++) //从id区间遍历到右边第2个区间
   {
      if (p[i+1].first != p[i].second + 1) //如果i区间没有和i+1区间紧邻
      {
         r = p[i].second + 1;
         break;
      }
   }

   if (l == -1) cout << r << endl; //左侧没有可选位置
   else if (r == -1) cout << l << endl; //右侧没有可选位置
   else if (r - s < s - l) cout << r << endl;
   else cout << l << endl;
   
   return 0;
}
```

---


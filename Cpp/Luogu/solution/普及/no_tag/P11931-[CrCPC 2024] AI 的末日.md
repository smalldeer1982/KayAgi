# [CrCPC 2024] AI 的末日

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) A.

## 题目描述

有 $n$ 件衣服要被**依次**叠好。

一共有 $k$ 种衣服，第 $j$ 种衣服要被叠到第 $j$ 堆上。第 $i$ 件衣服的种类为 $a_i$。

你随身带着一本数学笔记本。你不想弄脏它，于是把它放在某一堆上。但是**衣服不能叠在笔记本上**，如果要把一件衣服叠在笔记本所在的堆上，那么必须先把笔记本移走。

你可以任意选择初始时笔记本的位置，也可以在合法的前提下任意选择把笔记本移到哪堆。在最优策略下，至少需要**移**多少次笔记本？


## 说明/提示

- $1\le n\le 10^6$，$2\le k\le 10^9$；
- $1\le a_i\le k$。

样例解释：一开始放在第 $1$ 堆上，然后放在第 $3$ 堆上，然后移回第 $1$ 堆。


## 样例 #1

### 输入

```
8 3
3
1
2
1
1
3
3
2```

### 输出

```
2```

## 样例 #2

### 输入

```
1 2
1```

### 输出

```
0```

# 题解

## 作者：liaoxingrui (赞：4)

## Content

有 $k$ 堆总共 $n$ 件衣服和 $1$ 个笔记本（放在任意一堆衣服上），每件衣服将在第 $i$ 个时刻放在 $a_i$ 这个位置，要求笔记本上面不能有衣服，问最少要移动多少次笔记本？（笔记本最开始在的位置由你决定）

## Solution

我们可以发现笔记本在越后面才需要换，则越好，那么我们就可以用一个 `set` 将第 $i$ 时刻的衣服所放在的位置存起来（因为 `set` 有去重），若判断到所有的位置都以出现，则将笔记本换到最后一个位置，再将 `set` 清空，并将答案加一，重复操作即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,k,x,ans;
set<int> s;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	while(n--){
		cin>>x;
		s.insert(x);
		if(s.size()==k){
			s.clear();
			s.insert(x);
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：CJR_Rain (赞：2)

## Solution

可以发现，无论什么时候，电脑晚移动一定不劣于早移动，即要求出最优解就要尽量拖着让电脑不移动。有了这个思想，就可以提出解法：

用哈希表记录每次衣服的种类，表内的元素代表在电脑下次移动前不能放的堆的编号。每当哈希表的长度等于 $k$ 时，就说明无论电脑放在哪，衣服都会盖到电脑上面，这时电脑就必须移动。计数器加一，然后将哈希表清空。

但是上述思路仍有纰漏：设 $x$ 为哈希表的长度等于 $k-1$ 时表内唯一不存在的编号，当电脑必须移动时，它不能移动到 $x$ 对应的堆。如何实现呢？很简单，哈希表清空后再将 $x$ 插入就行了。

## Code


```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)

using namespace std;

unordered_set <int> clothes;
int n, k, ans = 0;

signed main() {

    IS;
    OS;
    
    cin >> n >> k;

    //可以随意选择电脑的初始位置，所以哈希表初始时为空

    for(int i = 0; i < n; ++i) {

        int tmp;
        cin >> tmp;

        clothes.insert(tmp);//哈希表自动去重，直接插入就行

        if(clothes.size() == k) {//电脑必须移动

            ++ans;//电脑必须移动，最少移动次数加一
            clothes.clear();//清空哈希表

            clothes.insert(tmp);//电脑不能移动到这个位置
        }
    }

    cout << ans;

    return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

这道题我们看成只能有 $n-1$ 堆可以放东西，然后统计除去初始放下来以外多拿的次数，得到的就是移动电脑的次数。此时题目就可以转变为 P3419。注意特判 $k>n$。

下面是对于原题目的解法与证明，代码换成本题的了。

---

我们容易发现当架子满了的时候要扔书时，扔下一次使用最晚的书是不劣的。

为什么呢？

如果我们扔的不是这本最晚用到的书，那么在下一次用到它之前，我们除了现在买一次书外，扔掉的另一本下一次还得再买。这样算下来就多买了一次甚至更多，是不优的。

那么我们就应该扔最晚用的书。

考虑倒序统计下一次使用，然后利用优先队列处理。

注意如果当前需要的书已经在架上，需要更新优先队列中该书下一次的值（不然挂在第 $9$ 个点）。我们可以多加一本书覆盖原书来实现。

---

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000005][2],f[1000005],ans;
priority_queue<pair<int,int> >q;
map<int,bool>mapp;
signed main(){
    int k,n;
    int K;
    cin>>n>>K;k=K-1;
    if(K>n){
        cout<<0;
        return 0;
    }
    for(int i=1;i<=n;i++)
    cin>>a[i][1];
    memset(f,0x3f,sizeof f);
    for(int i=n;i>=1;i--){
        a[i][0]=f[a[i][1]];
        f[a[i][1]]=i;
    }
    for(int i=1;i<=n;i++){
        if(mapp[a[i][1]]){
            k++;
            q.push(make_pair(a[i][0],a[i][1]));
            continue;
        }
        if(q.size()<k){
            q.push(make_pair(a[i][0],a[i][1]));
            ans++;
            mapp[a[i][1]]=1;
        }else{
            mapp[q.top().second]=0;
            q.pop();
            q.push(make_pair(a[i][0],a[i][1]));
            ans++;
            mapp[a[i][1]]=1;
        }
    }
    cout<<max(0ll,ans-(K-1));
    return 0;
}
```

---

福利：

[七](https://www.luogu.com.cn/problem/P3419)[倍](https://www.luogu.com.cn/problem/P2088)[经](https://www.luogu.com.cn/problem/SP688)[验](https://www.luogu.com.cn/problem/CF802B)[，](https://www.luogu.com.cn/problem/P11931)[好](https://www.luogu.com.cn/problem/P4404)[耶](https://www.luogu.com.cn/problem/CF802A)！

甚至三倍[题](https://www.luogu.com.cn/article/tgf82p31)[解](https://www.luogu.com.cn/article/hga39xyp)[！](https://www.luogu.com.cn/article/9730ghv6)

---

## 作者：lcfollower (赞：2)

~~注意这是一道橙题，题目一定不会过难。~~

首先 $n < k$ 可以放在 $[n+1,k]$ 中的任意一堆，答案为 $0$。

然后考虑 $n\ge k$ 的情况。

考虑贪心，假设一个序列有 $k$ 种衣堆，那么笔记本放在最后一次出现的那一堆上一定最优，因为这样所需移动次数最少。


因此 $\mathcal O(n)$ 扫 $a$ 数组，每次标记并 $\mathcal O(k)$ 判断（用数组 $vis$），时间复杂度为 $\mathcal O(nk)$，不足以通过。

因此我们可以考虑设计一个变量 $tot$ 为当前数组有多少中衣服种类出现过。如果 $tot = k$ 则清空 $vis$ 并把 $tot$ 标记为 $0$。时间复杂度为 $\mathcal O(Tk)$，其中 $T$ 为需要清空次数，因此瓶颈在于清空。可以构造在 $[jk,(j+1)k-1]$（$0\le j\le \lceil\frac{n}{k}\rceil - 1$）内每个数互不相同，此时 $T$ 约为 $\frac{n}{k}$，时间复杂度为 $\mathcal O(\frac{n}{k}\times k) = \mathcal O(n)$，足以通过。

特判 $n < k$ 的原因是怕 $k$ 过大导致数组过大。

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e18

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

const int N = 1e6 + 10;
int n ,k ,tot ,sum ,ans ,vis[N];

signed main (){
  
  n = read () ,k = read ();
  if (n < k){puts("0") ; exit (0);}

  int tot = 0 ,sum = 1;

  up (i ,1 ,n){
    int x = read ();
    if (!vis[x]) ++ tot ,vis[x] = 1;
    if (tot == k){
      up (j ,1 ,k) vis[j] = 0;
      ++ ans ;
      vis[x] = 1 ,tot = 1;//注意此时放在非 x 的最优堆，x 应被标记。
    }

  //  writesp (sum) ,writesp (tot) ,writeln (ans);
  } writeln (ans);
  return 0;
}
```

当然如果不想要看到清空可以改成如下代码（没啥变化）：

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e18

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

const int N = 1e6 + 10;
int n ,k ,tot ,sum ,ans ,vis[N];

signed main (){
  
  n = read () ,k = read ();
  if (n < k){puts("0") ; exit (0);}

  int tot = 0 ,sum = 1;

  up (i ,1 ,n){
    int x = read ();
    if (vis[x] == sum - 1) ++ tot ,vis[x] = min (vis[x] + 1 ,sum);
    if (tot == k) ++ ans ,++ sum ,tot = 1 ,vis[x] = sum;

  //  writesp (sum ) ,writesp (tot) ,writeln (ans);
  } writeln (ans);
  return 0;
}
```

---

## 作者：dgdyrkst (赞：1)

居然没有题解，我来写一发。
## 思路
显然我们可以从前往后考虑放置。

当笔记本将要被移动时，我们考虑该把它放到哪里，显然的贪心思路是放到接下来最晚出现的衣服种类的位置上，这样显然不比放在先出现的位置更劣，否则仍要挪动。

那么我们只需要处理从每件衣服起最晚出现的种类。这个倒序并使用优先队列等技巧进行预处理即可。

最后就是正序模拟一边贪心并统计答案，非常完美。

交了一遍只有 $98$ 分，定睛一看 $k$ 范围是 $10^9$，所以还要离散化，然后没了。
## 代码
以下为代码参考。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define x first
#define y second
const int N=1e6+5,inf=0x3f3f3f3f;
int n,k,a[N],b[N],d[N],g[N],now,ans,t;
priority_queue<pii> pq;
int main()
{
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	t=unique(b+1,b+n+1)-b-1;
	for (int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+t+1,a[i])-b;
	for (int i=1;i<=min(k,1000001);i++)pq.push({inf,i}),d[i]=inf;
	for (int i=n;i>=1;i--)
	{
		d[a[i]]=i;
		pq.push({i,a[i]});
		while (pq.size() && pq.top().x!=d[pq.top().y])pq.pop();
		g[i]=pq.top().y;
	}
	now=g[1];
	for (int i=1;i<=n;i++)
	{
		if (now==a[i])ans++,now=g[i];
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：cjx_AK (赞：1)

我们考虑贪心。

我们要想移动次数越少，就要让本子尽可能在一个地方呆得久一些。

所以当所有堆都被衣服砸过后，我们就必须移动本子，也就是答案加一。

注意这个堆下一次不能再放。

所以，具体操作我们们已知，看代码吧：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
map<int,int>b;
int ans,min_=1e18,x[20000002],cnt;
int MIN(int a,int b){
    return a<b?a:b;
}
signed main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
     scanf("%lld",&x[i]);
        if(!b[x[i]])ans+=x[i];
        b[x[i]]=1;
         if(ans==k*(k+1)/2){
            cnt++;
            b.clear();
             b[x[i]]=1;
             ans=x[i];
        }
    }
 cout<<cnt;
}
```

---

## 作者：guoshengyu1231 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11931)
## 初步思考
先看数据范围，$n$ 最大是 $10^6$， $k$ 最大是 $10^9$，显然不能暴力枚举。那我们就得想到一种方法能快速计算出这个问题的答案。我们可以先思考一下，在什么情况下一定是需要换一次位置的？可以想到，当每一个位置都有衣服要叠，那肯定得换一下位置。那思路已经显而易见了。
## 具体步骤
- 每当输入一个位置时标记这个位置已经有书放着了，并记录一共有多少位置已经放了衣服。
- 当所有位置都已经放了衣服，清空标记，答案加 $1$。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,x,cnt,ans;
map<int,bool> vis;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	while(n--)
	 {
		cin>>x;
		if(!vis[x])	
		 {
			cnt++;
			vis[x]=true;
			if(cnt==k)	
			 {
				cnt=0;
				vis.clear();
				ans++;	
			 }	
		 }
	 }
	cout<<ans;
	return 0;
}
```
当你提交了这份代码，你会发现你只得了 $72$ 分，而且有一大片都是 WA。详见 [这里](https://www.luogu.com.cn/record/208760713)。 $\\$ 
请看 hack 数据：
> 10 3\
> 2 3 1 2 3 1 2 3 1 2

正确答案为 $4$ 可程序输出 $3$。 $\\$ 


---


我当时想了很久，突然注意到了一点。当我们要移动书的位置时，总不可能将书移动到原来的位置，也就是在 hack 数据中，我们先将书放到位置 $1$ 时。当 $1$ 号位置有衣服来时，我们不能“跳”过这件衣服，还在原来的位置上。我们只能移动到剩下的位置。那么我们只需要标记原来的位置不可以来就行了。 $\\$ 
具体的，当所有位置都放了衣服时，我们将书现在的位置标记为当前答案加 $1$。并将 $cnt$ 设为 $1$。只有当前答案 $>$ 当前位置的标记才可以选择该位置标记。（具体详见代码）
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,x,ans,cnt;
map<int,int> vis;
int32_t main()//注意，如果你TLE on #30，请将主函数处的 int 改为 int32_t。
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	while(n--)
	 {
		cin>>x;
		if(vis[x]<=ans)	
		 {
			vis[x]=ans+1;
			cnt++;	
			if(cnt==k)
			 {
				cnt=1;ans++;
				vis[x]=ans+1;
			 }
		 }	
	 }
	cout<<ans;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/208769264)

---

## 作者：Na1L0n9 (赞：1)

# Solution
## 思路
我们可以先来思考一下移动次数仅为 $0$ 或 $1$ 次的情况如何处理，很显然，如果每一种衣服都存在，答案为 $1$，否则答案 $0$。

根据这个结论，如果我们在叠放过程中发现每一种衣服都出现了。就说明此时笔记本必须要移动一次，然后以最后一件放下衣服为新的开始，继续重复以上行为直到叠放完成即可。
## Code

```cpp
#include <bits/stdc++.h>
#define Write ios::sync_with_stdio(0);
#define by cin.tie(0);
#define AquaDaMean1e cout.tie(0);
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 1e5 + 10;
const int MOD = 998244353;
int n, k, ans;
set <int> S; // 使用set维护目前堆放的衣服种数
int main() {
    Write by AquaDaMean1e
	cin >> n >> k;
	for (int i = 1, x; i <= n; i++) {
		cin >> x;
		S.insert(x);
		if (S.size() == k) {
			ans++;
			S.clear();
			S.insert(x);
		}
	}
	cout << ans;
    return 0;
}
```

---

## 作者：Soviet_Onion (赞：0)

## P11931 [CrCPC 2024] AI 的末日 题解
### Solution
有趣的贪心。

首先，如果 $a$ 中所有衣服的种类数 $S<k$，那么答案一定为 $0$。注意是**种类数**，并不是 $n$，因为 $a$ 中可能有相同元素。为什么？因为一定能够找到编号为 $x$ 的衣服堆，使得没有任何一件 $a$ 中的衣服 $a_i$ 会被放上去。也就是 $x \notin a$。容易证明在 $S<k$ 情况下一定可以找到符合要求的 $x$。

另一种情况，即 $S \ge k$，我们要遍历数组进行解决。使用 STL 中的 set 维护当前我们选的集合 $D$ 内有多少个不同的数。每遍历到 $i$，就将 $a_i$ 加入 $D$ 中。

如果此时 $|D|=k$，这就说明每堆衣服都至少被放置了一次。这样我们就要至少挪动一次笔记本，然后清空 $D$。

也可以理解为，原先我们选择了一堆衣服 $y$，并将笔记本放上去。经过若干次操作后，衣服堆 $y$ 被放上了衣服。此时我们不得不进行一次挪动。注意此时的 $y$ 是未知的。它只是一个相对来说的的最优解。

这时最小挪动次数就要加 $1$。容易证明没有任何一种其他选法可以更优。

时间复杂度 $O(n\log n)$。
### [Accepted Code](https://www.luogu.com.cn/record/209125780)
```cpp
#include<iostream>
#include<set>
using namespace std;
const int N=1e6+10;
set<int>st;
int a[N],n,k,cnt;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i],st.insert(a[i]);
    if(k>st.size()) return cout<<0<<endl,0;
    st.clear();
    for(int i=1;i<=n;i++){
    	st.insert(a[i]);
        if(st.size()==k) st.clear(),st.insert(a[i]),cnt++;
    }
    cout<<cnt<<endl;
    return 0;
}
```

---


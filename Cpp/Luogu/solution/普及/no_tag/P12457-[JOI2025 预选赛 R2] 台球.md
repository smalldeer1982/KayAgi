# [JOI2025 预选赛 R2] 台球

## 题目描述

比太郎在玩台球。JOI 国的台球是使用摆在台上的 $N$ 个球 $1,2,\ldots,N$ 的游戏，台上设有落球用的洞。落在洞里的球不会放回台上，那个球也不能再一次落洞。比太郎的目的是尽量把写有大号码的球落在洞里。

打球是一项需要集中注意力的工作。初始，比太郎的注意力是 $X$，击打球 $i$（$1≤i≤N$）后集中力减少 $A_i$。集中力不足 $A_i$ 时，不能击打球 $i$。

另外，在该台球中存在关于落球顺序的规则，具体来说，$P_i=-1$（$1≤i≤N$）时，球 $i$ 可以随时落下，$P_i ≠ -1$ 时，为了使球 $i$ 落下，球 $P_i$ 必须已经落下。

当给出了比太郎所具有的集中力和各球的信息时，判定比太郎是否能够将球击落洞中，在能够击落下球的情况下，求出能够落下的球的编号的最大值。

## 说明/提示

### 样例解释

#### 样例 #1
首先，比太郎的集中力是 $7$。
对于所有的 $i$（$1≤i≤N$），由于 $P_i=-1$，所以只要集中力足够，所有的球都可以随时掉到洞里。

例如，如下所示，比太郎可以击落 $4$ 个球。

- 首先，把球 $3$ 打到洞里，比太郎的集中力减少了 $4$，剩下的集中力为 $3$。
- 接着，把球 $4$ 打到洞里，比太郎的集中力减少了 $3$，剩下的集中力为 $0$。
- 另外，比太郎不能把球 $5,6$ 打到洞里。因此，比太郎可以掉到洞里的球的号码的最大值是 $4$。

### 数据范围

- $1 \leq  N \leq 200 000$
- $1 \leq  X \leq  10^{15}$
- $1 \leq A_i \leq 10^9 (1 \leq i \leq N)$
- $1 \leq P_i \leq N$ 或 $P_i = -1(1 \leq  i \leq N)$
- $P_i \neq i (1 \leq i \leq N)$

子任务如下：

1. （6 分）$N \leq1000, P_i = -1 (1 \leq i \leq N)$
2. （9 分）$N \leq1000, P_1 = -1, P_i = i-1 (2 \leq i \leq N)$
3. （16 分）$N \leq 1000, P_i < i (1 \leq i \leq  N)$．
4. （20 分）$P_i < i (1 \leq i \leq N)$
5. （19 分）$N \leq 1000$
6. （30 点）无其他限制

## 样例 #1

### 输入

```
6 7
1 2 4 3 10 100
-1 -1 -1 -1 -1 -1```

### 输出

```
4```

## 样例 #2

### 输入

```
5 12
1 2 3 5 8
-1 1 2 3 4```

### 输出

```
4```

## 样例 #3

### 输入

```
8 10
3 1 4 1 5 9 2 6
-1 1 2 -1 4 4 5 7```

### 输出

```
7```

## 样例 #4

### 输入

```
2 1000000000000000
1 1
2 1```

### 输出

```
-1```

## 样例 #5

### 输入

```
9 2468024680
123456789 234567891 345678912 456789123 567891234 678912345 789123456 891234567 912345678
6 5 4 -1 3 2 1 9 8```

### 输出

```
6```

# 题解

## 作者：Clare613 (赞：1)

~~临晚再写一篇。~~
## 思路
很明显，这是一道拓扑排序题，这里大家可能不知道拓扑排序，那么到[这儿](https://blog.csdn.net/Zhang_Qin123/article/details/139274013)了解一下。\
那么这道题怎么做呢？我们可以用拓扑排序找到每一个点如果要击落那么需要花费的注意力，找到编号最大的即可。\
具体来说，就是用队列来存储可以选择的数，然后赋值。值得注意的是，可能有的球永远打不下来，如图：\
![](https://cdn.luogu.com.cn/upload/image_hosting/1mxcgun2.png)\
所以最开始要赋一个极大值，以免永远打不下来的被打下来了。
## code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
queue<int> q;
int a[200005],f[200005],b[200005];
vector<int> g[200005];
signed main(){
	memset(b,0x3f,sizeof(b));
	int n,w;
	cin>>n>>w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>f[i];
		if(f[i]==-1){
			q.push(i);
			b[i]=a[i];
		}
		else{
			g[f[i]].push_back(i);
		}
	}
	while(!q.empty()){
		int t=q.front();
		q.pop();
		for(auto i:g[t]){
			if(f[i]!=-1){
				b[i]=b[t]+a[i];
				f[i]=-1;
				q.push(i);
			}
		}
	}
	for(int i=n;i>=1;i--){
		if(w>=b[i]){
			cout<<i;
			return 0;
		}
	}
	cout<<-1;
    return 0;
}
```

---

## 作者：TFX_Y (赞：1)

## 本题思路

可用记忆化搜索来记录击落每一个台球所需的集中力。

## 实现

对于没有约束条件的台球，其所需的集中力即为原本所需的集中力.

对于有约束条件的台球，其所需的集中力即为原本所需的集中力加上被约束的台球的所需集中力.

通过记忆化搜索来记录，记录后直接调用。如果出现“环”，则只需用一个 $vis$ 数组记录一下即可，并将其治为初始集中力 $+1$，这样肯定就不会被输出。最后再从大到小依次判断即可，如果没有一个符合条件，直接输出 $-1$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int nm=2e5+5;
int n,m,x,k;
int a[nm],vis[nm],p[nm],son[nm],val[nm],flag;
int dfs(int i){
	if(vis[i]==1) return x+1;
	if(p[i]==-1) return a[i];
	if(val[i]) return val[i];
	vis[i]=1;
	int ans=dfs(p[i]);
	vis[i]=0;
	return val[i]=a[i]+ans;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>x;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>p[i];
	for(int i=n;i>=1;i--){
		if(dfs(i)<=x){
			cout<<i;
			flag=1;
			break;
		}
	}
	if(!flag) cout<<-1;
	return 0;
}
```

---

## 作者：Eden_star (赞：1)

## 思路
观察到在击打一个球之前需要完成前置条件，所以考虑抽象成图进行**拓扑排序**。\
图中每一个节点为球的编号，边权值为打出这球要消耗的精神值。

比如这是第三个样例的图：\
[![pEOfAwF.png](https://s21.ax1x.com/2025/05/10/pEOfAwF.png)](https://imgse.com/i/pEOfAwF)

那么我们击打每一个球的精神值就是打出他前一个球的精神之加上打出自己这个球的精神值。
那么这个图的最终样子为：\
[![pEOfMy6.png](https://s21.ax1x.com/2025/05/10/pEOfMy6.png)](https://imgse.com/i/pEOfMy6)

我们要做到这一点只需要在拓扑排序时将自己的精神值加上前一个节点的精神值就行了。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
vector<int >pic[N];
queue<int >q;
int n,k;
int rd[N],p[N];
signed main(){
	cin>>n>>k;
	int x;
	for(int i=1;i<=n;i++){
		cin>>x;
		p[i]=x;
	}
	for(int i=1;i<=n;i++){
		cin>>x;
		if(x!=-1){
			pic[x].push_back(i);
			rd[i]++;
		}
	}
	for(int i=1;i<=n;i++){
		if(!rd[i]) q.push(i);
	}
	int ans=-1;
	while(!q.empty()){
		int x=q.front();q.pop();
		if(p[x]<=k) ans= ans>x ? ans : x;
		int len=pic[x].size();
		for(int i=0;i<len;i++){
			int v=pic[x][i];
			rd[v]--;
			if(!rd[v]){
				p[v]+=p[x];
				q.push(v);
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Camellia_Spoil (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12457)

# 题意

有 $n$ 个球，每个球有一个标记 $p_i$，编号为 $i$。

当 $$p_i = -1$$ 时，你可以花费 $a_i$ 的代价获取这个球。

当 $$p_i \neq -1$$ 时，你需要先获取编号为 $p_i$ 的球，才可以获取这个球。

问总花费不超过 $x$ 时，能获取的最大的球的编号是多少。

# 分析
当 $$p_i \neq -1$$ 时，我们很容易想到在 $p_i$ 与 $i$ 之间连一条 $p_i$ 指向 $i$ 的边，那么我们就会得到许多棵树，根结点均为 $$p_i = -1$$ 的结点。

遍历每一颗树，不断向下遍历，计算出在这棵树上能获取的最大编号，最后对于每一棵树最大编号取 $\max$ 即可。

注意每次遍历的时要将 $x$ 还原。

# AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define N 2000010
using namespace std;
inline long long read()
{
	long  long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int a[N],p[N],vis[N],mx=-1,n,m,f[N],mon[N];
vector<int>e[N];
void dfs(int x)
{
    mx=max(x,mx);//取编号max
    m-=a[x];//花费
    for(int y:e[x])
    {
        mon[y]=m;//记录遍历到这一层的剩余花费
        if(m>=a[y]) dfs(y);//是否能够向下继续遍历 
        m=mon[y];//还原
    }
}
signed main(){
    int nm;
    n=read();m=read();nm=m;
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++) p[i]=read();//读入
    for(int i=1;i<=n;i++)
    {
        if(p[i]==-1);
        else e[p[i]].push_back(i);
    }//建图
    for(int i=1;i<=n;i++)//遍历
    {
        if(p[i]==-1&&m>=a[i]) dfs(i);
        m=nm;//还原
    }
    printf("%lld",mx);
	return 0;
}

```

---

## 作者：Yoimiya_miii (赞：1)

## 题解：P12457 [JOI2025 预选赛 R2] 台球
题解区好像都是用拓扑排序做的，那我写一个树的题解。

注意到所有的点都只有一个依赖的点，因此我们可以把被依赖的点作为父亲节点，当前节点作为子节点建立一棵树。

那么每个节点所需要的精力就是父亲节点的精力加上当前节点的 $A$ 值。

注意判断当前节点是否可以访问，否则会痛失 $49$ 分。

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e5+100;
vector<int> G[maxn+100];
int n,x,ans,cost[maxn+100],a[maxn+100],p[maxn+100];
bool vis[maxn+100];
void dfs(int pre){
	vis[pre] = 1;
	for(int i = 0;i < G[pre].size();i++){
		cost[G[pre][i]] += cost[pre];
		dfs(G[pre][i]);
	}
	return;
} 

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	memset(vis,0,sizeof(vis));
	cin >> n >> x;
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 1;i <= n;i++) cost[i] += a[i]; 
	for(int i = 1;i <= n;i++) cin >> p[i];
	for(int i = 1;i <= n;i++){
		if(p[i] != -1) G[p[i]].push_back(i);
	}
	bool flag = 1;
	for(int i = 1;i <= n;i++){
		if(p[i] == -1){
			dfs(i);
			flag = 0;
		}
	}
	/*for(int i = 1;i <= n;i++) cout << cost[i] << " ";
	cout << '\n';*/
	if(flag == 1) return(puts("-1"),0);
	else{
		for(int i = n;i >= 1;i--){
			if(cost[i] <= x && vis[i] == 1){
				cout << i;
				return 0;
			}
		} 
	}
	cout << -1;
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

既然出现了**先打另一个球，才能打这一个球**的约束条件，不难想到拓扑排序，对所有 $p_i \ne -1$ 的 $i$ 建一条有向边 $p_i \to i$，接着跑一遍拓扑排序即可。\
对了，还需要使用一个数组 $s$，$s_i$ 代表打完第 $i$ 个球以及它连带的前置球所需要的总注意力，可以使用类似于前缀和的转移方法，公式如下（在拓扑排序中计算）：

$$
s_i = \begin{cases}
a_i, & p_i = -1 \\
s_{p_i} + a_i, & p_i \ne -1
\end{cases}
$$

最后从 $s_n$ 遍历至 $s_1$，找到第一个满足 $s_i \le X$ 的 $i$ 值，即为本题答案。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int a[314514];
int p[314514];
int s[314514];  
inline int rd(){
	int k = 0, f = 1;
	char c = getchar();
	while(!isdigit(c)){
		if(c == '-') f = -1;
		c = getchar(); 
	} 
	while(isdigit(c)){
		k = (k << 3) + (k << 1) + c - '0';
		c = getchar(); 
	} 
	return k * f; 
} 
void toposort(int x, const vector<vector<int> > &g){ //拓扑排序
	if(p[x] > 0) s[x] = a[x] + s[p[x]]; //转移方程
	else s[x] = a[x];
	for(int i = 0; i < g[x].size(); ++i){ //递归深入
		toposort(g[x][i], g); 
	} 
} 
signed main(){
	int n = rd(), x = rd();
    vector<vector<int> > G(n + 1); //记得多加一个空间，不然 RE!
	
	for(int i = 1; i <= n; ++i) a[i] = rd();
	for(int i = 1; i <= n; ++i){
		p[i] = rd();
		if(p[i] > 0){ //建边
            G[p[i]].push_back(i); 
        }  
	} 
	
	for(int i = 1; i <= n; ++i){
		if(p[i] == -1) toposort(i, G); 
	} 
	for(int i = n; i >= 1; --i){
		if(s[i] <= x && s[i]) return cout << i, 0; //找到答案
	} 
	cout << -1; //报告无解
	return 0; 
} 
```

---

## 作者：aizhoukai (赞：0)

# 思路
注意到我们可以将落一个球的代价视为落它的所有前置和它自己的代价的和，然后根据这个和，从大到小枚举，枚举到精力足够落的就直接输出。

# 实现

对于每一个 $P_i=-1$，我们可以根据这颗球拓扑出以这颗球为前置及其衍生的球的实际代价，这样做不仅可以计算出所有可落的球的实际代价，还可以将环排除在外。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,a[214514],p[214514],aa[214514],b[214514];
vector<int> g[214514];
void awa(int qwq)
{
	if(p[qwq]>0)
		aa[qwq]=aa[p[qwq]]+a[qwq];
	else
		aa[qwq]=a[qwq];
	for(int i=0; i<g[qwq].size(); i++)
		awa(g[qwq][i]);
}
signed main()
{
	cin>>n>>x;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=n; i++)
	{
		cin>>p[i];
		if(p[i]>0)
			g[p[i]].push_back(i);
	}

	for(int i=1; i<=n; i++)
	{
		if(p[i]==-1)
			awa(i);
	}
	for(int i=n; i>=1; i--)
		if(x>=aa[i]&&aa[i])
		{
			cout<<i;
			return 0;
		}
	cout<<-1;
	return 0;
}

```

---

## 作者：W_C_B_H (赞：0)

对于这类有“前置条件”的题，我们可以考虑拓扑排序。

记 $sum_i$ 表示击打球 $i$ 及其所有前置的球所需的注意力之和。不难发现，若 $P_i=-1$，则 $sum_i=A_i$；否则，$sum_i=sum_{P_i}+A_i$。那么我们可以建立一张节点编号为 $1\sim N$ 的有向图，并对于每个 $P_i\ne-1$ 的 $i$ 连一条 $P_i$ 到 $i$ 的有向边。然后在拓扑排序时计算每个节点的 $sum$ 即可。

两个小优化：根据题意，每个点入度不超过 $1$, 故拓扑排序中搜到一个节点时无需将其入度减 $1$ 并判断是其入度否等于 $0$。对于所有 $1\le i\le N$，算出节点 $i$ 的 $sum$ 值后（无论 $P_i$ 是否等于 $-1$），如果 $sum_i>X$，则无需将节点 $i$ 插入拓扑排序的队列，因为 $A_i$ 都是正整数，由 $i$ 引出的节点的 $sum$ 值也必定大于 $X$。

总时间复杂度 $O(N)$，可以通过本题。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 200005
int n,x,a[N],p[N],deg[N],sum[N],ans=-1;
vector<int>e[N];
queue<int>q;
signed main()
{
    cin>>n>>x;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        cin>>p[i];
        if(p[i]>0)
        {
            e[p[i]].push_back(i);
            deg[i]++;
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(!deg[i])
        {
            sum[i]=a[i];
            if(sum[i]<=x)
            {
                ans=max(ans,i);
                q.push(i);    // 一个小优化: 所需注意力已经超限的就不用进行拓扑排序了, 因为 a[i] 都是正数, 越到后面越多
            }
        }
    }
    while(!q.empty())    // 拓扑排序
    {
        int u=q.front();
        q.pop();
        for(int v:e[u])
        {
            // 根据题意, 每个点入度不超过 1, 故无需 deg[v]-- 并判断 deg[v] 是否等于 0
            sum[v]=sum[u]+a[v];
            if(sum[v]<=x)
            {
                ans=max(ans,v);
                q.push(v);    // 同样的小优化
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：liumuyunC2026 (赞：0)

这道题就是一个拓扑排序的板子题。

# 题目分析

每个球要将它的前驱的每一个球打完，才能打。很容易想到拓扑排序。

# 做题思路

将每一个点与它的前驱节点连边，记录每一个点的入度。遍历一遍数组，将入度为 $0$ 的点放入队列。每次取出队首元素，遍历它的后驱节点，将后驱节点入度减 $1$，如果入读为 $0$，入队。

最后从 $n$ 到 $1$ 遍历,找到第一个比 $x$ 小的节点数，输出。

# 代码实现


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
struct Edge{
	int to,next;
}e[N];
int head[N],cnt;
int n,v,rd[N],vis[N];
long long x,q[N];
queue<int> qu;
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;	
}
void topo()
{
	for(int i=1;i<=n;i++)
	{
		if(rd[i]==0) qu.push(i),vis[i]=true;
	}
	while(!qu.empty())
	{
		int u=qu.front();
		qu.pop();
        //cout<<u<<endl;
		for(int i=head[u];~i;i=e[i].next)
		{
			int v=e[i].to;
		    if(vis[v]) continue;
			rd[v]--;
			if(rd[v]==0) q[v]+=q[u],qu.push(v),vis[v]=true;
		}
	}
	for(int i=n;i>=1;i--)
	{
		if(q[i]<=x&&vis[i]==true) {cout<<i;exit(0);}
	}
	cout<<-1;
}
int main()
{
	memset(head,-1,sizeof(head));
	cin>>n>>x;
	for(int i=1;i<=n;i++) cin>>q[i];
	for(int i=1;i<=n;i++)
	{
		cin>>v;
        if(v==-1) continue;
		add(v,i);
		rd[i]++;
	}
	topo();
}
```

# 注意事项

注意输出 $-1$。

---

## 作者：wurang (赞：0)

看到题目中的关于落球顺序的规则，每颗球都有可能有自己的前驱，不难想到使用拓扑排序的思路来处理。

一开始，将没有前驱的球加入队列，并记录打下该球所需的集中力，即 $A_i$。

接着用拓扑排序的思路将该球的后驱台球需要用的集中力更新，并且入队。

最后从 $n$ 到 $1$ 遍历，如果需要的集中力小于等于 $x$，那么下标并终止程序。

注意判断 $-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int fa;
int n, x, op;
int v[200005];
int dp[200005]; // 打下第i个球所需的集中力
vector <int> edge[200005];

queue<int>q;

signed main()
{
    memset(dp, 0x3f3f, sizeof(dp));
    cin >> n >> x;
    for(int i = 1; i <= n; i++)
        cin >> v[i];
    for(int i = 1; i <= n; i++)
    {
        cin >> fa;
        if(fa == -1) dp[i] = v[i], q.push(i); //记录打下该球所需的集中力并入队
        else edge[fa].push_back(i); // 连边
    }
    while(!q.empty()) // 类似拓扑的操作
    {
        op = q.front();q.pop(); // 获取队头
        for(auto i : edge[op]) // 考虑击打后继节点
        {
            dp[i] = min(dp[i], dp[op] + v[i]); // 更新最小集中力
            q.push(i); // 入队
        }
    }
    for(int i = n; i >= 1; i--)
        if(dp[i] <= x)
        {
            cout << i;
            return 0;
        }

    cout << -1;

    return 0;
}
```

---

## 作者：MonKeySort_ZYczc (赞：0)

232 个测试点，小子这就是 JOI！
## 思路流程
一眼拓扑排序。  
连边方式为：当 $p_i\neq-1$ 时从 $p_i$ 向 $i$ 连一条单向边。  
当出现环时容易发现环上的所有台球都无法取走（结合样例 #4 想想）。  
利用拓扑排序特性：所有在环上的点拓扑排序完入度一定不为 $0$。  
设取走 $i$ 之前需要花 $dis_i$ 集中力，排除掉环，$dis_i$ 就是所有能到达 $i$ 的点的点权和。  
拓扑排序一遍即可。  
时间复杂度是 $O(n+m)$。  
当然啦，**不开 long long 见祖宗。**
## 代码实现
本人奇怪的习惯：拓扑排序喜欢用栈，但是队列啥的能存储都行。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e5+10;
int n,x,a[N],dist[N],ans,col[N],ind[N];
int tot,head[N],to[N],nxt[N];
inline void add(int a,int b)
{
	tot++;
	nxt[tot]=head[a];to[tot]=b;head[a]=tot;
}
inline void topo()
{
	stack<int>st;
	for(int i=1;i<=n;i++) if(!ind[i]) st.push(i);
	while(!st.empty())
	{
		int p=st.top();dist[p]+=a[p];st.pop();
		for(int i=head[p];i;i=nxt[i])
		{
			int t=to[i];
			ind[t]--;dist[t]+=dist[p];
			if(!ind[t]) st.push(t);
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>x;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		int p;cin>>p;
		if(p!=-1) add(p,i),ind[i]++;
	}
	topo();
	for(int i=1;i<=n;i++) if(x>=dist[i]&&!ind[i]) ans=i;
	if(ans) cout<<ans;
	else cout<<-1; 
}

```

---


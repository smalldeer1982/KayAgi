# 有序表的合并

## 题目描述

给出两个数列 $a, b$，均按不降序排序。其中保证 $a$ 中没有重复的数字。

现在请你求出：$a$ 中每一个数字在 $b$ 中出现了几次？

## 说明/提示

### 样例 1 解释

- $a_1 = 1$ 在 $b$ 中出现了 $1$ 次。
- $a_2 = 3$ 在 $b$ 中出现了 $2$ 次。
- $a_3 = 6$ 在 $b$ 中出现了 $0$ 次。

故输出为 $1 \bigoplus 2 = 3$。

### 样例 2 解释

$1, 4, 5$ 分别在 $b$ 中出现了 $2, 1, 1$ 次，故输出为 $2 \bigoplus 1 \bigoplus 1 = 2$。

### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq T \leq 10$；
- $1 \leq n, m \leq 10^7$，$\sum (n + m) \leq  10^7$；
- $1 \leq a_i, b_i < 2^{64}$，且 $a_i < a_{i + 1}$，$b_i \leq b_{i + 1}$。

其中 $\sum (n+m)$ 表示单测试点内所有 $n$ 与 $m$ 的和，即输入数列的总长度不超过 $10^7$。

### 提示

- 请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。
- 请采用合适的数据类型存储变量，避免溢出。
- 如果你不知道什么是按位异或和，可以在你的代码里添加如下的函数：

```cpp
template <class T>
T getXorSum(T *begin, T *end) {
  T ret = 0;
  for (T *it = begin; it != end; ++it) ret ^= *it;
  return ret;
}
```
这一函数的作用是计算传入数组（包括 `std::vector`）某一左闭右开区间的按位异或和，返回值类型与传入数组的类型相同，调用方法与 `std::sort` 类似，例如，要求数组 $a$ 的 $a_1 \sim a_n$ 的按位异或和，则调用 `getXorSum(a + 1, a + 1 + n)`，求 $a_0 \sim a_{n - 1}$ 的按位异或和，则调用 `getXorSum(a, a + n)`。如果 $a$ 是 `std::vector`，则将上述调用代码里的 `a` 均改为 `a.begin()` 即可。


## 样例 #1

### 输入

```
1
3 5
1 3 6
1 3 3 5 5```

### 输出

```
3```

## 样例 #2

### 输入

```
1
9 4
1 2 3 4 5 6 7 8 9
1 1 4 5```

### 输出

```
2```

## 样例 #3

### 输入

```
2
3 5
1 3 6
1 3 3 5 5
9 4
1 2 3 4 5 6 7 8 9
1 1 4 5```

### 输出

```
3
2```

# 题解

## 作者：Usada_Pekora (赞：8)

题意很清晰，在此不再分析，解法要求时间空间都是线性的。

注意到题目给出了一个特殊性质：$a,b$ 都是升序的。

也就是说与 $a_i$ 相等的那些 $b_{l_1\sim r_1}$ 和与 $a_{i+1}$ 相等的那些 $b_{l_2\sim r_2}$ 是彼此不相交的一些数，即若他们都存在，则一定有 $l_2\gt r_1$。

于是从左到右扫一下就好了，对于每个 $a_i$ 我们需要统计值域在 $(a_{i-1},a_i]$ 的 $b_j$，维护一个 $j$ 即可。具体地，我们每次从第一个大于 $a_{i-1}$ 的 $b_j$ 开始往右找到第一个大于 $a_i$ 的 $b_{j^{'}}$，容易发现若我们每次从前一个数继承 $j$，则 $i$ 的移动次数是 $O(n)$ 的，$j$ 的移动次数是 $O(m)$ 的。

复杂度 $O(\sum(n+m))$。

```
#include <bits/stdc++.h>
using namespace std;
inline uint64_t read() {
	uint64_t x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch))
		x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
	return x;
}
uint64_t a[10000001], b[10000001];
signed main() {
	for (int T = read(), n, m; (T--) && (n = read(), m = read()); ) {
		for (int i = 1; i <= n; i++)
			a[i] = read();
		for (int i = 1; i <= m; i++)
			b[i] = read();
		int j = 1, cnt = 0, ans = 0;
		for (int i = 1; i <= n; i++) {
			cnt = 0;
			while (j <= m && a[i] >= b[j]) {
				cnt += (a[i] == b[j]);
				j++;
			}
			ans ^= cnt;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：wdgm4 (赞：6)

## 双指针算法(100 pts)

双指针算法其实就是用指针把暴力中没用的遍历去掉。题目里说 $a$，$b$，均按不降序排序，就是说 $a$，$b$ 数组都是单调递增的，假如 $b_i$ 是第一个与 $a_j$ 相等的，那么 $b_1$ 到 $b_{i-1}$ 一定都比 $a_j$ 到 $a_n$ 小，那遍历 $a_j$ 时为何不把遍历 $b_1$ 到 $b_{i-1}$ 这几步省略掉呢？

大体思路就是上面这样，用双指针刚开始一个指向 $a_1$，一个指向 $b_1$，之后如果 $a_i$ 等于 $b_i$ 让指向 $b$ 数组的指针往右移并让计数器加 $1$，否则如果 $a_i > b_i$，让指向 $b$ 数组的指针往右移，否则让指向 $a$ 数组的指针往右移。

时间复杂度 $\Theta(\sum{(n+m}))$。

### 代码

```cpp
#include<bits/stdc++.h>
#define XD 114514

using namespace std;
int t;
unsigned long long n,m,ans=0;
unsigned long long a[10000010],b[10000010];
int main(){
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=m;i++) cin>>b[i];
		unsigned long long i=1,j=1,num=0;
		while(i<=n and j<=m){
			if(a[i]==b[j]){
				num++;
				j++;
			}else{
				ans^=num;
				if(a[i]<b[j]) i++;
				else j++;
				num=0;
			}
		}
		ans^=num;//最后在算一遍防止有少算的 
		cout<<ans<<endl;
		ans=0;//记得初始化 
	}
	return 0;
}

```

#### 后记

我才不会告诉你这道水题我卡那么久是因为 `scanf` 不会写。

---

## 作者：TheSky233 (赞：4)

## Description

给出长度分别为 $n,m$ 的数组 $a,b$，求出 $b$ 数组内 $a$ 数组内每个数出现的次数。

$1 \le \sum(n+m) \le 10^7$。

## Solution

显然最好想的做法是哈希，线性时间即可求解，但是空间会爆炸。

由于 $a_i < a_{i + 1},b_i \leq b_{i + 1}$，考虑双指针解法，因为 $a_x$ 在 $b$ 中必然是一段连续的区间，于是让 $l,r$ 分别为 $a_x$ 在 $b$ 的左右区间下标（即满足 $\forall y \in[l,r],b_y=a_x$），这样统计个数的时候就可以直接 $cnt \gets r-l+1$。

不难发现 $l,r$ 的移动次数是 $O\left(\sum(n+m)\right)$ 的，统计答案是 $O\left(\sum n\right)$ 的，于是总时间复杂度即为 $O\left(\sum(n+m)\right)$。

注意题面给出的 $1\le a_i,b_i < 2^{64}$，需要开 `unsigned long long`。

## Code

```cpp
#include <bits/stdc++.h>
#define F(i,a,b) for(int i=(a) ;i<=(b);++i)
#define pb push_back
using namespace std;

using ll = unsigned long long;

inline ll read(){ll x(0), f(0); char ch=getchar(); while(ch<'0'||ch>'9'){ch=getchar();} while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48); ch=getchar();} return x;}
template <typename T> void read(T &x){x=0; T f(0); char ch=getchar(); while(ch<'0'||ch>'9'){f|=ch=='-';ch=getchar();} while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48); ch=getchar();} x=f?-x:x;}
template <typename T,typename ...Arg>void read(T& x,Arg& ...arg){read(x);read(arg...);}
template <typename T> inline void write(T x){static char buf[64]; static int tot(0); if(x<0) putchar('-'),x=-x; do buf[++tot]=(x%10)+48,x/=10; while(x); do putchar(buf[tot--]); while(tot);}
template <typename T> void write(T x,char c){static char buf[64]; static int tot(0); if(x<0) putchar('-'),x=-x; do buf[++tot]=(x%10)+48,x/=10; while(x); do putchar(buf[tot--]); while(tot); putchar(c);}
void judge(bool x){printf(x?"YES\n":"NO\n");}

void Solve();

int n,m,q,k,p;
vector<ll> a,b;

int main(){
	ll t=read();
	while(t--)
        Solve();
}

ll ans;
int x,l,r;

void Solve(){
	read(n,m);
	a.clear(); b.clear();
	F(i,1,n) a.pb(read());
	F(i,1,m) b.pb(read());
	l=0,r=0,x=-1,ans=0;
	while(x<n){
		++x;
		while(b[l]<a[x] && l<m) ++l; r=l;
		if(b[l]!=a[x]) continue;
		while(b[r]<=a[x] && r<m) ++r;
		if(b[r]>a[x] || r==m) --r;
		if(l==m) break;
		if(r>=l) ans^=(r-l+1);
	}
	write(ans,'\n');
}
```

---

## 作者：so_find_skind (赞：3)

首先可以看到，本题的 $n$，$m$ 非常之大，所以想过，必须要有时间复杂度类似 $O(n+m)$ 或 $O(n\log n)$ 的代码。

但这里如果使用后者，通常都是使用二分，但是，如果想使用二分，那么 $b$ 数列必需放在数组里，十分耗空间。所以最好使用线性的前者。

说到这里，应该都能猜出来了：双指针！

其实啊，若是 $b$ 数列不是单调不降的，那使用双指针就不得不排序，最终依然是后者，问题是它是单调不降，那直接双指针暴力写上去就行了。

时间复杂度 $O(\sum(n+m))$。

code:

```
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
unsigned long long a[10000005],b;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;++i){
			scanf("%llu",a+i);//千万别写成%ll了！
		}
		int tot=1;
        int cnt=0,answer=0;
		for(int i=1;i<=m;++i){
			scanf("%llu",&b);
			while(a[tot]<b && tot<=n){//不匹配
				answer^=cnt;
                tot++;
                cnt=0;
			}
			if(tot<=n && a[tot]==b)//匹配
				++cnt;
		}
		answer^=cnt;//最后一次的cnt没按位异或，所以在这里需加上
		cout<<answer<<"\n";
	}
	return 0;
}
```



---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P1366 有序表的合并](https://www.luogu.com.cn/problem/P1366)

## 参考资料

- [双指针 - OI Wiki](https://oi.wiki/misc/two-pointer/)

## 解题思路

1. 初始令左右边界 $l=1$ 和 $r=1$。

2. 对于每个元素 $a_i$，执行如下操作：

- 将区间左边界 $l$ 从 $r$ 开始向后枚举，直到 $b_l=a_i$（$l\le m$），说明 $b_l$ 是第一个等于 $a_i$ 的元素。
- 将区间右边界 $r$ 从 $l$ 开始向后枚举，直到 $b_r\not =a_i$（$r\le m$），说明 $b_r$ 是第一个不等于 $a_i$ 的元素。
- 此时 $l-r$ 即为 $a_i$ 出现的个数

3. 最后求出所有数的异或和。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ull=unsigned long long;
const int N=10000005;
ull a[N],b[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	while(T--)
	{
		int n,m;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		for(int i=1;i<=m;i++)
		{
			cin>>b[i];
		}
		int l=1,r=1,ans=0;
		for(int i=1;i<=n;i++)
		{
			l=r;
			while(b[l]<a[i]&&l<=m)l++;
			r=l;
			while(b[r]==a[i]&&r<=m)r++;
			ans^=r-l;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：LHQing (赞：2)

### 题目分析：

我们枚举每个 $a_i$，然后在 $b_i$ 中枚举，时间复杂度 $O(nm)$，显然会超时。

由于 $b_i$ 具有单调性，我们枚举 $a_i$，在 $b_i$ 中二分出 $a_i$ 的连续段 $[l,r]$，答案就是 $r-l+1$，时间复杂度 $O(n\log m)$，会超时。

如果考虑 Hash 呢，空间可能承受不了。

所以我们考虑双指针，由于 $a_i,b_i$ 都具有单调性，我们定义左右指针 $l,r$，其中满足 $b_{1\sim l-1}<a_i$，$b_{1\sim r-1}\le a_i$，若 $b_l=a_i$，那么答案就是 $r-l+1$。

我们在运算的过程中，我们要注意 $l,r$ 是要小于等于 $m$ 的。时间复杂度为 $O(n+m)$。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
#define pd push_back
#define all(x) x.begin(),x.end()
#define Clear(x,n) for(int i=0;i<=n;i++)x[i]=0;
//==============================================================================
ll QP(ll x,ll y,ll mod){ll ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}
//==============================================================================
namespace IO{
	int readInt(){
		int x=0,y=0;char c=0;
		while(!isdigit(c))y|=c=='-',c=getchar();
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return !y?x:-x;
	}
	void write(int x){if(!x)return;write(x/10);putchar(x%10);}
	void Output(int x){if(x<0)putchar('-'),x=-x;if(!x)putchar('0');else write(x);}
	void WL(int x){Output(x);putchar('\n');}
	void WS(int x){Output(x);putchar(' ');}
}
namespace Debug{
	void DeVec(vector<int> c){for(auto y:c)printf("%d ",y);puts("");}
	void DeNum(int x){printf("%d\n",x);}
}
//==============================================================================
const int N=1e7+10;
ll a[N],b[N];
int T;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    cin>>T;
    while(T--){
    	int n,m;cin>>n>>m;
    	for(int i=1;i<=n;i++)cin>>a[i];
    	for(int i=1;i<=m;i++)cin>>b[i];
    	ll ans=0;int l=1,r=1;
    	for(int i=1;i<=n;i++){
    		while(l<=m&&b[l]<a[i])l++;
    		while(r<=m&&b[r]<=a[i])r++;
    		if(b[l]==a[i])ans^=r-l;
		}cout<<ans<<'\n';
	}return 0;
}

```

---

## 作者：Sun_Email (赞：1)

由于本题提供了关键条件—— $a_i,b_i$ 随 $i$ 单调不降，容易想到双指针做法。但是注意到本题的 $n,m$ 都很大，怎么省空间呢？

答案显而易见——把 $b$ 数组扔掉，在输入 $b_i$ 的时候做双指针即可！

具体细节见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,tot=1,cnt,ans;
unsigned long long a[10000002],b;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;++i){
			scanf("%llu",&a[i]);
		}
		tot=1;cnt=ans=0;
		//双指针分别为i和tot 
		for(int i=1;i<=m;++i){
			scanf("%llu",&b);
			//由于a[],b[]单调不降，出现a[i]<b[j]时，即有a[i]<b[k](j<=k<=m)，所以要把a[i]扔掉 
			while(tot<=n&&b>a[tot]){
				ans^=cnt;cnt=0;++tot;
			}
			if(tot<=n&&b==a[tot]){
				++cnt;
			}
		}
		ans^=cnt;
		printf("%d\n",ans);
	}
	return 0;
}
```

##### 最后说明一点：`unsigned long long` 用 `scanf` 输入时，用的是 `%llu`！！！

##### ~~不要像这个蒟蒻写成`%ull`。~~

---

## 作者：Link_Cut_Y (赞：1)

[点我看题](https://www.luogu.com.cn/problem/P1366)

## 题目分析

显然需要线性的时空复杂度。由于给定的两个表是有序的，可以用一个指针，指向大于上一个数的最小的数。在查询当前数时将指针右移，直到指针所在位置的数大于当前数。指针可以用单指针或者双指针，指针显然单调右移。复杂度线性。

最后别忘了数据范围。

### 代码示例

```cpp
#include <cstdio>

const int N = 1e7 + 10;
unsigned long long a[N], b[N];
int n, m, T;

int get(unsigned long long val, int &iter) {
	int cnt = 0;
	for (; iter <= m && b[iter] <= val; cnt += (val == b[iter ++ ]));
	return cnt;
}

int main() {
	scanf("%d", &T);
	while (T -- ) {
		scanf("%d%d", &n, &m);
		for (int i = 1; i <= n; i ++ ) scanf("%llu", &a[i]);
		for (int i = 1; i <= m; i ++ ) scanf("%llu", &b[i]);
		
		int it = 1, ret = 0;
		for (int i = 1; i <= n; i ++ )
			ret ^= get(a[i], it);
		printf("%d\n", ret);
	}
	return 0;
}
```

个人认为代码很短。

---

## 作者：Ruiqun2009 (赞：1)

看到 $\sum(n+m)\leq 10^7$，时限是 1.40s，告诉我们要用线性做法（树状数组用时还要再长一些，或许某些人的树状数组可以卡进 1.40s，但是本题中树状数组根本用不上）。

由于 $a,b$ 单调，我们可以想到双指针，即维护两个标记，分别表示当前搜索到 $a,b$ 的第几个数字。每次向右找只需要移动 $b$ 上的标记找位置。

最坏情况是 $a$ 内的数字全是比 $b$ 的最后一位大的，$b$ 上的标记移动到了 $b$ 的最后一位，时间复杂度是 $\Theta(m)$ 的。

总时间复杂度为 $\Theta(\sum(n+m))$。

相比于传统二分做法的 $\Theta(\sum (n+m\log n))$，双指针法不仅复杂度低，常数也小。

代码：
```cpp
unsigned long long a[10000005], b[10000005];
void solve() {
    unsigned n = readuint(), m = readuint();
    for (unsigned i = 0; i < n; i++) a[i] = readullong();
    for (unsigned i = 0; i < m; i++) b[i] = readullong();
    unsigned long long *ptra = a, *ptrb = b, *ptrtmp = b + m;
    unsigned ans = 0;
    for (unsigned i = 0; i < n; i++) {
        unsigned tmp = 0;
        while (ptrb < ptrtmp && !(*ptra < *ptrb)) tmp += (*ptra == *ptrb++);
        ans ^= tmp;
        ++ptra;
    }
    putuint(ans);
    pc('\n');
}
int main() {
    unsigned t = readuint();
    while (t--) solve();
    fwrite(outbuf, 1, curoutpos - outbuf, stdout); // 快写输出
}
```

---

## 作者：Leaper_lyc (赞：0)

先观察题目中的数据
- $\sum(n,m)\le10^7$。   
必然只能用线性的做法，否则会 T 飞。
- $a_i<a_{i+1},~b_i\le b_{i+1}$。  
可见数列 $a$ 严格递增，数列 $b$ 非严格递减。
- $1\le a_i,b_i\le 2^{64}$。  
要开 `unsigned long long`。


------------
分析：

要怎样才能线性枚举两个数列呢？

数列 $a$ 中的数列两两不同，所以数列 $a$ 中的每一项都要枚举**一遍**。

接着考虑数列 $b$。若 $a_i>b_j$，由于数列 $a$ 是严格递增的，数列 $b$ 是非严格递增的，则 $a_{i+1}$ 也**一定大于** $b_j$，$a_i$ 也一定大于 $b_{j-1}$，这样我们在计算 $a_{i+1}$ 出现的次数时就没必要再枚举 $b_j$ 以及它之前的数。

不难想到用双指针来做这道题。
- 若 $a_i<b_j$，则指针 $i$ 向后移。
- 若 $a_i=b_j$，则指针 $j$ 向后移。
- 若 $a_i>b_j$，则指针 $j$ 向后移。

这里的向后移都只移一位。

具体操作来看代码。
```cpp
#include <iostream>
#include <cstdio>
#define int unsigned long long
using namespace std;

int t, n, m, ans;
int a[10000005], b[10000005];

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> t;
    while (t--) {
        ans = 0;
        cin >> n >> m;
        for (int i = 1; i <= n; i++) cin >> a[i];
        for (int i = 1; i <= m; i++) cin >> b[i];
        int i = 1, j = 1, cnt = 0;
        while (i <= n && j <= m) {
            if (a[i] == b[j]) {
                cnt++;
                j++;
            } else {
                ans ^= cnt;
                if (a[i] < b[j]) i++;
                else j++;
                cnt = 0;
            }
        }
        ans ^= cnt;
        cout << ans << endl;
    }
}
```

个人觉得还是很详细的^_^。

本蒟蒻的第一份题解，望支持。

若有不严谨的地方，请各位大佬多指点。

---


# NOI元丹

## 题目描述

小A打算开始炼 $\texttt{NOI}$ 元丹（什么鬼），据说吃了可以提高 $\texttt{NOI}$ 时的成绩。

是这么练的。元丹有三种元核，`N`、`O`、`I`。现有很多个这样原核，按顺序排成一行。炼元丹时，从左往右分别挑出 `N`、`O`、`I` 三个原核吞下。

现在他关心，有几种服用方式……且慢！

他觉得服用方式太少，以至于不能成仙。所以他可以通过某个途径，得到 `N`、`O`、`I` 的三种原核中的**任意一个**，至于哪一种由他决定。然后他将获得这个原核的插入到这一排原核中的任意位置（包括最前最后）。

现在你要知道，新的元核序列中能有多少种 `N`、`O`、`I` 的取出方式。子串的字母并不要求连续。

## 说明/提示

样例解释：

他可以获取一个 `N` 元核，加到最前面。

```plain
NNOIOI | NNOIOI | NNOIOI | NNOIOI | NNOIOI | NNOIOI
~ ~~   | ~ ~  ~ | ~   ~~ |  ~~~   |  ~~  ~ |  ~  ~~
```
对于 $30\%$ 的数据 $N \le 200$。

对于 $50\%$ 的数据 $N \le 2000$。

对于 $100\%$ 的数据 $3 \le N \le 10 ^ 5$。


## 样例 #1

### 输入

```
5
NOIOI```

### 输出

```
6```

# 题解

## 作者：kkksc03 (赞：57)


好像比T1简单。

首先，假设不加字母，计算NOI个数，可以用O(n)的递推。

```cpp
for(i=1 to n){
    if(s[i]=='N') then num_N++
    if(s[i]=='O') then num_NO+=num_N
    if(s[i]=='I') then num_NOI+=num_NO
}
```
要是加一个呢？

容易证明，当加一个'N'时，加到开头会有最多的'NOI';当加一个'I'时，加到末尾会有最多的'NOI'

'O'呢？枚举每一个断点，左边的N个数\*右边I个数，然后保留最大值。左边的N个数，右边I个数可以预处理一遍。


---

## 作者：Aryper (赞：14)

NOI元丹

我们可以先不管是否往字符串里加入字符，先来想一想，如果给你一个 $\texttt{NOI}$ 的序列，我们怎样计算题目所求的方案数？

## 1.1暴力

我们可以**暴力枚举每一位**，**找到一个** $\texttt{N}$ 我们就开始**从这一位开始循环**，再**找到一个** $\texttt{O}$ ，再**从这一位开始循环**，**再找一个** $\texttt{I}$ ，每次找到 $\texttt{I}$ 的时候**累加答案**就可以了。

时间复杂度 $O(n^3)$ 。

## 1.2暴力

我们会发现，只要**找到一个** $\texttt{O}$ ，只要它的**左边有一个** $\texttt{N}$ ,**右边有一个** $\texttt{I}$ ，**就可以炼成一颗元丹**。

所以我们可以**枚举** $\texttt{O}$ ，再**循环** $\texttt{O}$ **的左边**，看有多少 $\texttt{N}$ ，**循环** $\texttt{O}$ **的右边**，看有多少 $\texttt{I}$ 。

然后**每次答案累加** $\texttt{N}$ **的个数乘上** $\texttt{I}$ **的个数**(喜闻乐见的**乘法原理**)。

时间复杂度 $O(n^2)$ 。

## 1.3更像暴力的正解

其实 1.2暴力 已经很接近正解了。

我们注意到其实 $\texttt{O}$ 左右两边的 $\texttt{N}$ 和 $\texttt{I}$ 的个数可以用**前缀和**来计算。

用一个数组 $f_i$ **表示第** $i$ **位左边有多少个** $\texttt{N}$ ，用一个数组 $g_i$ **表示第** $i$ **位右边有多少个** $\texttt{I}$ 。

然后我们按照 1.2暴力 的方法找 $\texttt{O}$ ，每找到一个 $\texttt{O}$ ，**将答案累加** $f_i\times g_i$ 。

时间复杂度 $O(n)$ 。



------------

既然我们解决了方案计数的问题，接下来就解决添加字符的问题吧。

依旧先从暴力开始想

## 2.1暴力

**枚举每一位**，添加 $\texttt{N}$ 或 $\texttt{O}$ 或 $\texttt{I}$ ，再用上文所述的计数方法计算答案，**打个擂台**就完事了。

枚举的复杂度是 $O(n)$ ，**乘上计数的复杂度**，总时间复杂度 $O(n^2)$ 。

## 2.2喜闻乐见的贪心

其实我们可以从计数的方法中看出：

**在第 $i$ 位添加 $\texttt{N}$ 就是把第 $i$ 位到第 $n+1$ 位的 $f_i$ 都加上1。**

**在第 $i$ 位添加 $\texttt{I}$ 就是把第 $n+1$ 位到第 $i$ 位的 $g_i$ 都加上1。**

而**在第 $i$ 位添加 $\texttt{O}$ 就是将答案多加一个 $f_i\times g_i$ 。**

显然，**加 $\texttt{N}$ 加在最前面一定比其他方案更优**；

**加 $\texttt{I}$ 加在最后面一定比其他方案更优**；

**加 $\texttt{O}$ 在使得 $f_i\times g_i$ 最大的位置一定比其他方案更优**。

因此，我们**只需要算出这三种情况的答案**就完事了。

时间复杂度 $O(n)$ 。

代码(特别丑)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<cstring>
#include<vector>
using namespace std;

unsigned long long n,ans1,ans2,ans3,ans,cnt,ma;

unsigned long long f[100005],g[100005],a[100005];

string s;

int main() {
	
	cin>>n;
	
	cin>>s;
	
	for(int i=0;i<n;i++) {
		if(s[i]=='N') f[i+1]=f[i]+1;
		else
		f[i+1]=f[i];
		if(s[i]=='O')
		a[++cnt]=i+1;
	}
	
	for(int i=n-1;i>=0;i--) {
		if(s[i]=='I') g[i+1]=g[i+2]+1;
		else
		g[i+1]=g[i+2];
		if(g[i+1]*f[i+1]>ma) {
			ma=g[i+1]+f[i+1];
		}
	}
	
	for(int i=1;i<=cnt;i++) {
		ans1+=f[a[i]]*(g[a[i]]+1);
		ans2+=(1+f[a[i]])*g[a[i]];
		ans3+=f[a[i]]*g[a[i]];
	}
	
	ans3+=ma;
	
	ans=max(ans1,max(ans2,ans3));
	
	printf("%lld",ans);
	
	return 0;
}
```


---

## 作者：「QQ红包」 (赞：10)

本题和FBI序列有点像。

若这个串什么都不加，求为“NOI”的子串的个数的方法：

对于每个O，前面N的个数\*后面I的个数，即为使用此O能组成的NOI元丹的个数。

很容易知，如果获得一个N，那么N一定是加到整个串最前面（这样被用到的次数一定最大。

如果获得一个I，则把它插在串最末尾（这样被用到的次数最大。

如果获得一个O，就是添加到位置i，使i前面的N的个数\*i后面的I的个数乘积最大。原串能组成的NOI的元丹的个数加上这个数即为所求。

对于添加N和I在原串中加上要加的字符，然后按照刚才的方式，求能组成的NOI元丹的个数，即可求出获得新的字母后能得到的NOI元丹的个数。

最后找最大的。

还有一种方法：得到N之后，在原结果（指的是原串能组成的NOI元丹的个数）的基础上，加上每个I前面O的个数。

得到I之后，在原结果（指的是原串能组成的NOI元丹的个数）的基础上，加上每个O前面N的个数。

方法1代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<vector>
using namespace std;
long long N;
long long O,I2;
long long n,sum,i; 
long long maxs;
string s,ss;
int main()
{
    cin>>n;
    cin>>s;
    for (i=0;i<n;i++)
    {
        if (s[i]=='I')I2++;
    }
    for (i=0;i<n;i++)
    {
        if (s[i]=='N')N++; 
        if (s[i]=='O')sum+=N*I2;
        if (s[i]=='I')I2--;
        maxs=max(maxs,N*I2);
    }
    //cout<<sum<<endl;
    /*for (i=0;i<n;i++) cout<<N[0][i]<<" "; cout<<endl;
    for (i=0;i<n;i++) cout<<I[0][i]<<" "; cout<<endl;
    for (i=0;i<n;i++) cout<<I[1][i]<<" "; cout<<endl;*/
    long long mmax=sum+maxs;//新增O 
    
    n++;//新增N 
    ss=s;//存原始串。 
    s='N'+ss;
    sum=0;
    N=0;I2=0;
    for (i=0;i<n;i++)
    {
        if (s[i]=='I')I2++;
    }
    for (i=0;i<n;i++)
    {
        if (s[i]=='N')N++; 
        if (s[i]=='O')sum+=N*I2;//求和
        if (s[i]=='I')I2--;
    }
    //cout<<sum<<endl;
    mmax=max(mmax,sum);
    //新增一个N
    
    
    //新增一个I
    s=ss+'I';
    sum=0;
    N=0;I2=0;//记得初始化！
    for (i=0;i<n;i++)
    {
        if (s[i]=='I')I2++;
    }
    for (i=0;i<n;i++)
    {
        if (s[i]=='N')N++; 
        if (s[i]=='O')sum+=N*I2;
        if (s[i]=='I')I2--;
    }
    mmax=max(mmax,sum);
    //cout<<sum<<endl;
    cout<<mmax;
    return 0;
}
```
嗯，代码短点的方法二,然而方法1大部分代码是复制的。：


```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#define maxn 100000+10
using namespace std;
////////////////////////////////////////
string s;
long long N[maxn],O[maxn],I[maxn];//pre
long long n,sum[maxn],MAXN,MAXO,MAXI,MAXS;
////////////////////////////////////////

////////////////////////////////////////
int main()
{
    //freopen("yi.in","r",stdin) ;
    cin>>n;
    char temp=getchar();
    s.push_back('0');
    for(int i=1;i<=n;i++)
      {
          temp=getchar();
          if(temp=='N')
            N[i]++;
          if(temp=='O')
            O[i]++;
          if(temp=='I')
            I[i]++;
          N[i]+=N[i-1];
          O[i]+=O[i-1];
          I[i]+=I[i-1];
          s.push_back(temp);
      }
    for(int i=1;i<=n;i++)
      {
        if(s[i]=='O')
            {
                sum[i]+=N[i-1]*(I[n]-I[i]);
                MAXO=max(MAXO,N[i-1]*(I[n]-I[i]));
                MAXN+=I[n]-I[i];
                MAXI+=N[i-1];
          }
          sum[i]+=sum[i-1];
      }
    MAXS=max(MAXO,max(MAXN,MAXI));
    cout<<sum[n]+MAXS;
}
```

---

## 作者：Ajwallet (赞：7)

[博客地址](http://blog.csdn.net/xuxiayang/article/details/79198613)

## 大意
从左到右，问加了一个'p'后一共有几个noi？（p可以为n，o，i中的一个）长度小于100001

## 思路

加p之前，noi的个数为每个o之前n的个数*之后i的个数并累加。

加p之后，有三种情况：N，O，I

N肯定是放在第一个O前面方案最多了，每次多出每个O之前N的个数。

I肯定是放在最后一个O后面方案最多了，每次多出每个O之后I的个数。

O的话就要枚举了，枚举每个位置，求出o之前n的个数之后i的个数求之最大值。

从上述三种情况中取出最大值，加上没有p的noi总数即为最优解！

（注：要开long long）
## 代码

```
#include<cstdio>
#define U unsigned
#define r(i,a,b) for(int i=a;i<=b;i++)
#define d(j,a,b) for(int j=a;j>=b;j--)
using namespace std;U long long n,ans1;char s[100001];
U long long res_N,res_O,res_I;
U long long ni[100001],ii[100001];
U long long max(U long long x,U long long y) {return x>y?x:y;}
int main()
{
	scanf("%lld\n",&n);
	gets(s);
	r(i,0,n-1) if(s[i]=='I') ii[0]++;//求i总数
	r(i,0,n-1)
	 {
	 	ni[i]=ni[i-1];//取上次的
		ii[i]=max(ii[i-1],ii[i]);//取上次的，max是因为上面用了ii【0】所以要加
	 	if(s[i]=='N') ni[i]++;//N个数++
	 	if(s[i]=='I') ii[i]--;//I个数--
	 	if(s[i]=='O') 
	 	 {ans1+=ni[i]*ii[i];res_N+=ii[i];res_I+=ni[i];}//算
	 }
    r(k,0,n-1)//枚举各个位置插入
     res_O=max(res_O,ni[k]*ii[k]);//取最大值
    printf("%lld",ans1+max(res_N,max(res_O,res_I)));//三种方案的最大值
}

---

## 作者：doby (赞：5)

唯一能看清楚的一题……

p2646一样有趣23333……

这种题有了思路基本上都能码出来……

```cpp
#include<iostream>
#include<string>
using namespace std;
long long l,ns,is,sum,maxs=0,mx=0;//longlong……
string s,sn,si;
int main()
{
    cin>>l>>s;
    ns=0,is=0,sum=0;//加o的情况……
    for(int i=0;i<l;i++){if(s[i]=='I'){is++;}}//找右边i的个数
    for(int i=0;i<l;i++)
    {
        if(s[i]=='N'){ns++;}
        if(s[i]=='O'){sum=sum+ns*is;}
        if(s[i]=='I'){is--;}
        mx=max(mx,ns*is);//找出插入o的点
    }
    maxs=sum+mx;//加上插入后的方案数
    sn="N"+s,si=s+"I",l++;
    ns=0,is=0,sum=0;//加n的情况，并且最好的就是加在最左边
    for(int i=0;i<l;i++){if(sn[i]=='I'){is++;}}
    for(int i=0;i<l;i++)
    {
        if(sn[i]=='N'){ns++;}
        if(sn[i]=='O'){sum=sum+ns*is;}
        if(sn[i]=='I'){is--;}
    }
    maxs=max(maxs,sum);//找最优解
    ns=0,is=0,sum=0;//加i的情况，加在最右边
    for(int i=0;i<l;i++){if(si[i]=='I'){is++;}}
    for(int i=0;i<l;i++)
    {
        if(si[i]=='N'){ns++;}
        if(si[i]=='O'){sum=sum+ns*is;}
        if(si[i]=='I'){is--;}
    }
    maxs=max(maxs,sum);
    cout<<maxs;
}
```

---

## 作者：LMB_002 (赞：4)

~~这是蒟蒻写的第三篇题解~~

[题目传送门](https://www.luogu.com.cn/problem/P1371)

## 一、简述题意
------------
给定一个长度为 $N$ 的字符串 $s$，保证其中只有 $\texttt{N},\texttt{O},\texttt{I}$ 三种字符。现在可以在字符串中添加 $\texttt{N} \texttt{O} \texttt{I}$ 三个字符中的其中一个。问：在修改后的字符串中，最多能找到多少个三元组 $(i,j,k)$，使得 $0 \leq i < j < k < |s|$，且有 $s_i$ 为 $\texttt{N}$，$s_j$ 为 $\texttt{O}$，$s_k$ 为 $\texttt{I}$。其中 $|s|$ 表示 $s$ 的长度， $s_i$ 表示字符串 $s$ 中的第 $(i-1)$ 个字符。

## 二、思路分析
------------
这道题我们可以考虑用前缀和与后缀和数组记录 $\texttt{N}$ 与 $\texttt{I}$ 的出现次数，再通过 $\texttt{O}$ 用 $O(n)$ 的时间复杂度计算不加任何字符时的 $\texttt{N} \texttt{O} \texttt{I}$ 的出现次数。容易得知， $\texttt{N}$ 添加在最前面， $\texttt{I}$ 添加在最后面， $\texttt{O}$ 添加在 $\texttt{N}$ 在前边出现的次数与 $\texttt{I}$ 在后边出现的次数之积最多的地方。

## 三、构造代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,aq[200005],ch[200005],N,O,I,ans,maxn,t;
char s[200005];
int main() {
	scanf("%lld",&n);
	cin>>s+1;
	for(int i=1;i<=n;i++){
		aq[i]=aq[i-1]+(s[i]=='N');
	}
	for(int i=n;i>=1;i--){
		ch[i]=ch[i+1]+(s[i]=='I');
	}
	for(int i=1;i<=n;i++){
		if(s[i]=='O'){
			ans+=aq[i]*ch[i];
		}
	}
	for(int i=1;i<=n;i++){
		if(s[i]=='O'){
			t+=aq[i];
		}
	}maxn=max(maxn,t),t=0;
	for(int i=1;i<=n;i++){
		if(s[i]=='O'){
			t+=ch[i];
		}
	}maxn=max(maxn,t),t=0;
	for(int i=1;i<=n;i++){
		maxn=max(maxn,aq[i]*ch[i+1]);
	}ans+=maxn;
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：飞翔 (赞：4)

如果不能插入新的字母就太简单了，可是这题要插入新的字母。

如果要插入N，那么这个N一定插在序列最前面，这个画个图就能证明。

如果要插入I，那么这个I一定插在序列最后面，与上同理。

如果要插入O，那么设leftn[i]表示第i个字母左边N的个数，righti[i]表示第i个字母右边I的个数，枚举使leftn[x]\*right[x]最大的x即可。

代码见[我的博客](http://blog.csdn.net/qq\_31640513/article/details/52967158)


---

## 作者：MarshallZ (赞：3)

第一篇题解，写的不好请指出，谢谢！

（感谢管理员大大指出笔误）

---

[题面传送门](https://www.luogu.com.cn/problem/P1371)

---
# 1.思路

### 1.1 如何统计


---
思考前先看看简化版的统计：

给定一个由 $\texttt{A}$ 和 $\texttt{B}$ 组成的字符串，问有多少个 $\texttt{AB}$（子串的字母并不要求连续）？

其实只要看每一个 $\texttt{B}$ 前有几个 $\texttt{A}$，再相加即可。

那这道题呢？其实也就是多了一个字母。只要看 $\texttt{I}$ 前有几个 $\texttt{NO}$ 即可。求 $\texttt{NO}$ 数量也是同理。

---
### 1.2 加字符
---
这里可以分类讨论。

如果加 $\texttt{N}$，加在第一个可以给所有 $\texttt{O}$ 带来影响；如果加 $\texttt{I}$，加在最后一个可以将所有 $\texttt{NO}$ 再算一遍。则**加 $\texttt{N}$ 固定加在第一个，加 $\texttt{I}$ 固定加在最后一个**。此时，**加 $\texttt{N}$ 时的增加量等于位置后 $\texttt{OI}$ 的数量，加 $\texttt{I}$ 时的增加量等于位置前 $\texttt{NO}$ 的数量**。加 $\texttt{O}$ 就有点麻烦了，根据乘法原理，加 $\texttt{O}$ 时的增加量等于**位置前 $\texttt{N}$ 的数量乘位置后 $\texttt{I}$ 的数量**，我们要找到一个位置使此值最大。

---
# 2.算法
### 2.1 直接计算影响区域（$60$pts）
------------
只要在输入时预处理 $n$，$no$，$noi$，$o$，$oi$ 几个变量，再用两个数组 $nn$，$ii$ 存储每个可插入位置前（后）的 $\texttt{N}$（$\texttt{I}$）的个数。具体方法就是读到 $\texttt{N}$ 就将 $nn_{i+1}{\sim}nn_l$ 加上 $1$，读到 $\texttt{I}$ 就将 $ii_0{\sim}ii_i$ 加上 $1$（其中 $i$ 指位置，$l$ 指总长），如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/l6rxbh5l.png)
后面再枚举位置。最后找出 $\texttt{N}$，$\texttt{O}$，$\texttt{I}$ 三者最大值，加上原值输出。代码如下：（会 TLE，[别问我怎么知道的](https://www.luogu.com.cn/record/117769052)）
```cpp
#include<bits/stdc++.h>
int nn[100001],ii[100001];
using namespace std;
int main(){
	string s;
	int a,n=0,no=0,noi=0,o=0,oi=0,maxn=0,i;
	cin>>a>>s;
	for(int j=0;j<a;j++){
		if(s.substr(j,1)=="N"){
			n++;
			for(int x=j+1;x<=s.size();x++)nn[x]++;
		}
		else if(s.substr(j,1)=="O")no+=n,o++;
		else {
			noi+=no,oi+=o;
			for(int x=j;x>=0;x--)ii[x]++;
		}
	}
	n=oi;i=no;
	for(int g=0;g<s.size()+1;g++)maxn=max(maxn,nn[g]*ii[g]);
	maxn=max(max(maxn,n),i);
	cout<<maxn+noi;
	return 0;
}
```
---
### 2.2 优化（$100$pts）
---
其实，由于影响会持续到结尾，所以 $nn$ 中的数**只增不减**，$ii$ 中的数**只减不增**。可以考虑暂时用 $i$ 记录当前影响值。由于 $ii$ 要倒着处理，就独立出来单独一个循环处理。
![](https://cdn.luogu.com.cn/upload/image_hosting/28eti3yu.png)
优化代码如下：
```cpp
#include<bits/stdc++.h>
#define ll long long//习惯性的开long long
ll nn[100001],ii[100001];
using namespace std;
int main(){
	string s;
	ll a,n=0,no=0,noi=0,o=0,oi=0,maxn=0,i=0;
	cin>>a>>s;
	for(ll j=0;j<a;j++){
		if(s.substr(j,1)=="N"){
			n++;
			nn[j+1]=++i;
		}
		else{
			nn[j+1]=i;
			if(s.substr(j,1)=="O")no+=n,o++;
			else {
				noi+=no,oi+=o;
			}
		}
	}
	i=0;
   	//单独预处理
	for(ll j=a-1;j>=0;j--){
		if(s.substr(j,1)=="I")ii[j]=++i;
		else ii[j]=i;
	}
	n=oi;//N
   	i=no;//I
	for(ll g=0;g<s.size()+1;g++)maxn=max(maxn,nn[g]*ii[g]);//O
	maxn=max(max(maxn,n),i);
	printf("%lld",maxn+noi);
	return 0;
}
```


---

## 作者：O3O_O3O_O3O (赞：2)

`upd on 2022.1.17`：

1. 修正了语法错误。

2. 修改了一下 $\LaTeX$。

在[我的博客](https://www.luogu.com.cn/blog/O3O-O3O-O3O/solution-p1371)食用更佳。

大家都知道需要[这样](https://www.luogu.com.cn/blog/kkksc03/solution-p1371)解题，但是有的人第一眼看到这样的解题方法可能就会懵：

> 1. 这个递推代码怎么来的？
>
> 2. $\texttt{O}$ 为什么要插入在那种位置？
>
> 3. 怎么 $\texttt{AC}$ 的？

### 1.这个递推代码怎么来的？

在不插入任何字母的情况下，我们可以把原题理解为先提取 $\texttt{OI}$ 元丹，再提取 $\texttt{NO}$ 元丹，最后整合起来：

#### 提取 $\texttt{OI}$ 元丹：

我们先举几个例子：

$\texttt{OI}$

这个字符串只有 1 个字母 $\texttt{O}$，第 1 个字母 $\texttt{O}$ 后只有 1 个字母 $\texttt{I}$，所以它只有 1 种情况，即 $\texttt{0I}$。

$\texttt{OOI}$

这个字符串有 2 个字母 $\texttt{O}$，第 1 个字母 $\texttt{O}$ 后只有 1 个字母 $\texttt{I}$，第 2 个字母 $\texttt{O}$ 后也只有 1 个字母 $\texttt{I}$，所以它有 2 种情况，即 $\_\texttt{OI}$ 和 $\texttt{O}\_\texttt{I}$。

$\texttt{OII}$

这个字符串只有 1 个字母 $\texttt{O}$ 第 1 个字母 $\texttt{O}$ 后有 2 个字母 $\texttt{I}$，所以它有 2 种情况，即 $\texttt{O}\_\texttt{I}$ 和 $\texttt{OI}\_$。

$\texttt{OIOI}$

这个字符串有 2 个字母 $\texttt{O}$，第 1 个字母 $\texttt{O}$ 后有 2 个字母 $\texttt{I}$，第 2 个字母 $\texttt{O}$ 后有 1 个字母 $\texttt{I}$，所以它有 3 种情况，即 $\texttt{OI}\_~\_$、$\texttt{O}\_~\_\texttt{I}$ 和 $\_~\_\texttt{OI}$。

所以说 $\texttt{OI}$ 元丹的数量是每一个字母 $\texttt{O}$ 后的字母 $\texttt{I}$ 的数量之和。

第一组递归代码就出来了：

```cpp
for(int i=0;i<str.length();i++){
    if(str[i]=='O'){
        countO+=1;
    }
    else{
        countI+=countO;
    }
}
```

#### 提取 $\texttt{NO}$ 元丹：

原理与上面一样，只不过代码需要变化一下。

#### 整合后：

```
for(int i=0;i<str.length();i++){
	if(str[i]=='N'){
		countN++;
	}
	if(str[i]=='O'){
		countO+=countN;//注意这里要改一下
	}
	if(str[i]=='I'){
		res+=countO;
	}
} 
```

### 2. $\texttt{O}$ 为什么要插入在那种位置？

上一步完成之后，我们把它放在一个函数里。这是，我们需要考虑插入字母了。插入 $\texttt{N}$ 和 $\texttt{I}$ 都好说，放在最前面和最后面。但是插入 $\texttt{O}$ 时为什么是找一个位置，使这个 $\texttt{O}$ 前面的 $\texttt{N}$ 的数量乘这个 $\texttt{O}$ 后面的 $\texttt{I}$ 的数量最大呢？

我们假设我们把 $\texttt{O}$ 插入到指定位置后前面有 $a$ 个字母 $\texttt{N}$，后面有 $b$ 个字母 $\texttt{I}$。还是举**提取 $\texttt{OI}$ 元丹**和**提取 $\texttt{NO}$ 元丹**的例子：

#### 提取 $\texttt{OI}$ 元丹：

（只考虑插入的 $\texttt{O}$ 后面的字符串）

$\texttt{OI}\rightarrow\texttt{OOI}$

由原来的 1 种情况变成 2 种情况（$b=1$）。

$\texttt{OIOI}\rightarrow\texttt{OOIOI}$

由原来的 3 种情况变成 5 种情况（$b=2$）。

$\texttt{IOI}\rightarrow\texttt{OIOI}$

由原来的 1 种情况变成 3 种情况（$b=2$）。

我们可以推理出，插入字母 $\texttt{O}$ 后 $\texttt{OI}$ 元丹多了 $b$ 种。

#### 提取 $\texttt{NO}$ 元丹：

（只考虑插入的 $\texttt{O}$ 前面的字符串）

$\texttt{NO}\rightarrow\texttt{NOO}$

由原来的 1 种情况变成 2 种情况（$a=1$）。

$\texttt{NONO}\rightarrow\texttt{NONOO}$

由原来的 3 种情况变成 5 种情况（$a=2$）。

$\texttt{NON}\rightarrow\texttt{NONO}$

由原来的 1 种情况变成 3 种情况（$a=2$）。

我们可以推理出，插入字母 $\texttt{O}$ 后 $\texttt{NO}$ 元丹多了 $a$ 种。

#### 整合后：

我们可以通过乘法原理得出，插入字母 $\texttt{O}$ 后整个字符串提取出 $\texttt{NOI}$ 元丹的方案种数多了 a$\times$b 种。当 a$\times$b 最大时，种数最多。所以说插入 $\texttt{O}$ 时需要找一个位置，使这个 $\texttt{O}$ 前面的 $\texttt{N}$ 的数量乘这个 $\texttt{O}$ 后面的 $\texttt{I}$ 的数量最大。

### 3.怎么 $\texttt{AC}$ 的？

代码奉上（我把我自己写的优化去掉了，提交这个最多 90 分）：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long F(long long a,string A){
	long long countN=0,countO=0,res=0;
	for(long long i=0;i<A.length();i++){
		if(A[i]=='N'){
			countN++;
		}
		if(A[i]=='O'){
			countO+=countN;
		}
		if(A[i]=='I'){
			res+=countO;
		}
	} 
	return res;
} 
int main(){
	long long a/*题目中的N*/,x[3]={},count=0,countN=0,countI=0,y[100001]={},p;
	string b/*题目中的字符串*/;
	stringstream A;//字符串流，好用但是慢。
	cin >> a >> b;
    A << "N" << b;
	x[0] = F(a+1,A.str());
    A.clear();
    A.str("");
    A << b << "I";
    x[1] = F(a+1,A.str());
    A.clear();
    A.str("");
    for(long long i=0;i<b.length();i++){
		if(b[i]=='N'){
			for(long long j=0;j<=i;j++){
				if(b[j]=='N'){
					countN++;
				}
			} 
			for(long long j=i;j<b.length();j++){
				if(b[j]=='I'){
					countI++;
				}
			}
			y[++count] = countN*countI;
			if((y[count]<=y[count-1])&&(count!=0)){//节省时间，为了不TLE
				for(int j=0;j<=p;j++){
					A << b[p];
				}
				A << "O";
				for(int j=p+1;j<b.length();j++){
					A << b[p];
				}
				x[2] = F(a+1,A.str());
				goto end;
			}
			countN=0;
			countI=0;
			p = i;
		}
	}
	end:
	sort(x,x+3);
	cout << x[2];
	return 0;//万能尾文件 
}
```

（审核大人辛苦了）

---

## 作者：H15teve (赞：1)

这题还是挺简单的呢。首先+N+O+I三种情况，共有的毫无疑问就是不加的情况···所以不加的只计算一次，输出的时候再加上去。另外三种前缀和水一水就过去了······




```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
int n,first[3][100001];
long long maxn,maxt,maxo,maxi,ans;
char s[100001];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) 
    {
        scanf(" %c",&s[i]);
        if(s[i]=='N') first[0][i]=first[0][i-1]+1;else first[0][i]=first[0][i-1];
        if(s[i]=='O') first[1][i]=first[1][i-1]+1;else first[1][i]=first[1][i-1];
        if(s[i]=='I') first[2][i]=first[2][i-1]+1;else first[2][i]=first[2][i-1];
    }
    for (int i=1;i<=n;i++)
    {
        if(s[i]=='N')
            maxi+=first[1][n]-first[1][i];
        if(s[i]=='O')
            maxt+=first[0][i]*(first[2][n]-first[2][i]);
        if(s[i]=='I')
            maxn+=first[1][i];
        maxo=maxo>first[0][i-1]*(first[2][n]-first[2][i-1])?maxo:first[0][i-1]*(first[2][n]-first[2][i-1]);
    }
    ans=max(maxn,maxo);
    ans=max(ans,maxi);
    printf("%lld",ans+maxt);
    return 0;
}
```

---

## 作者：flyloong (赞：0)

这道题有$+N$，$+O$，$+I$三种情况和共有的不加.   

AC Code:https://www.luogu.com.cn/paste/fv381ynb 

---


# 跑步

## 题目描述

新牛到部队，CG 要求它们每天早上搞晨跑，从 $A$ 农场跑到 $B$ 农场。从 $A$ 农场到 $B$ 农场中有 $n-2$ 个路口，分别标上号，$A$ 农场为 $1$ 号，$B$ 农场为 $n$ 号，路口分别为 $2,3,4,\cdots,n-1$ 号，从 $A$ 农场到 $B$ 农场有很多条路径可以到达，而 CG 发现有的路口是必须经过的，即每条路径都经过的路口，CG 要把它们记录下来，这样 CG 就可以先到那个路口，观察新牛们有没有偷懒，而你的任务就是找出所有必经路口。

## 样例 #1

### 输入

```
6 6
1 2
2 4
2 3
3 5
4 5
5 6
```

### 输出

```
2
2 5
```

# 题解

## 作者：游戏的人 (赞：19)

### **难道就没人想到暴力吗**
刚开始以为是割点题，发现其实从起点到终点的必经之路就算没了，图也可能还是联通的，所以便可以想到**暴力**。


------------

### **思路**
可以用**邻接链表**把图存起来，再枚举2到N-1的点为必经之路，再沿着路径搜索，判断没有这个点能不能到达终点，能的话就说明这个点不是必经之路，直接退出。如果不能到终点就说明必须要走这个点，就存到答案里。

每次经过这个点都要打上标记。本题不需要回溯，只需要判断这个点有没有走过，因为只需要判断**搜到这个点有没有路径**，不用判断是怎么走的，所以只需要判断有没有重复搜点就行了。每次枚举时记得标记数组清零。


------------

### **AC代码**
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int n,m,f[8001],k,num,sum=0,ans[8001],s[8001];
bool flag;
struct edge 
{
	int f,t;
}a[4000001];//定义边长 
void add(int x1,int y1)
{
	a[++num].f=s[x1];
	a[num].t=y1;
	s[x1]=num;
}//邻接链表存图 
void dfs(int x,int k)
{
	if(x==n){flag=1;return;}//判断如果能到终点就标记不是必经之路 
	if(f[x]==1||x==k||flag==1)return;//如果这个点搜过，或者到了切断的必经之路，或者已到达终点就返回 
	f[x]=1;//走过标记 
	for(int i=s[x];i;i=a[i].f)dfs(a[i].t,k);//邻接链表搜索 
} 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int xi,yi;
		cin>>xi>>yi;
		if(xi==yi)continue;//判断自环 
	    add(xi,yi);add(yi,xi);//无向图正反存 
	}
	for(int i=2;i<=n-1;i++)
	{
		for(int j=1;j<=n;j++)f[j]=0;//开始标记数组清零 
		flag=0;//终点标记初始化 
		dfs(1,i);//起点1,枚举的必经之路是i 
		if(flag==0)sum++,ans[sum]=i;//答案+1，存入数组，两者并列 
	}
	cout<<sum<<endl; 
	for(int i=1;i<=sum;i++)cout<<ans[i]<<" ";//输出 
}
```
##### **完结撒花**
~~留个赞吧~~

---

## 作者：Lynkcat (赞：8)

模拟赛的时候没想到并查集和暴力，打了个 $Tarjan$，luogu上最优解第四？？？

# 开始正题

PS：实际上应该是点双，但这个数据貌似并没有卡掉窝，大家凑活着看吧（

>若一个无向图中的去掉任意一条边都不会改变此图的连通性，即不存在桥，则称作边双连通图。一个无向图中的每一个极大边双连通子图称作此无向图的边双连通分量。

首先我们可以发现，如果 $1$ 和 $n$ 不可能在同一个边双连通分量中，因为如果在同一个边双连通分量中，无论删去哪一个点，$1$ 总能到达 $n$。

那么我们画个图就会发现，答案其实是 $1$ 所在的边双连通分量到 $n$ 所在的边双连通分量的路径上的点。

如样例

![](https://cdn.luogu.com.cn/upload/image_hosting/s2j4vqps.png)

我们可以发现，去掉 $2$ 或 $5$ 可以让 $1$ 无法到达 $6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/k29va59i.png)

我们知道，在一个边双连通分量中，不管去掉其中哪一条边，点点之间总是互相连通，所以我们可以用 $Tarjan$ 将每个边双缩点。

![](https://cdn.luogu.com.cn/upload/image_hosting/hvbajc8p.png)

缩完点后，整个图将变成一个树(样例是链)。

我们发现，从 $1$ 所在的边双到 $6$ 所在的边双需要经过 $1-2$，$5-6$ 两条边。

![](https://cdn.luogu.com.cn/upload/image_hosting/34cf05ww.png)

那么我们将 $1,2,5,6$ 四点提出，去掉 $1,6$ 排序之后输出即可。

值得注意的是，由于一个边双可能只有一个点，所以需要去重。

那么我们就得到了这道题的做法：

1、存图。

2、$Tarjan$ 缩点。

3、从 $1$ 开始 $dfs$ ，得到路径上的点。

4、去重并排序后输出答案。

## 出乎意料的快

![](https://cdn.luogu.com.cn/upload/image_hosting/dz0g9uty.png)

下面是 $Pascal$代码：

```pascal
type edge=record
     t,next,f,yuan:longint;
     end;
var n,m,i,x,y,cnt,cnt1,tp,top,cnt2,ans1,ans2,cnt3,cnt4,cnt5:longint;
    h,a,dfn,low,bs,zhan,h1:array[0..100000]of longint;
    gb:array[0..2000,0..2000]of longint;
    e,e1:array[0..100000]of edge;
    vis,bbl:array[0..100000]of boolean;
function min(x,y:longint):longint;
begin
  if x<y then exit(x) else exit(y);
end;
procedure ad(x,y:longint);
begin
  inc(cnt1);
  e[cnt1].t:=y;
  e[cnt1].next:=h[x];
  e[cnt1].f:=x;
  h[x]:=cnt1;
end;
procedure ad1(x,y,t:longint);
begin
  inc(cnt4);
  e1[cnt4].t:=y;
  e1[cnt4].next:=h1[x];
  e1[cnt4].f:=x;
  e1[cnt4].yuan:=t;
  h1[x]:=cnt4;
end;
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do
            inc(i);
           while x<a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;

procedure tarjan(x,y:longint);
var t,now:longint;
begin
  inc(tp);
  dfn[x]:=tp;
  low[x]:=tp;
  inc(top);
  zhan[top]:=x;
  t:=h[x];
  while t>0 do
  begin
    if dfn[e[t].t]=0 then
    begin
      tarjan(e[t].t,x);
      low[x]:=min(low[x],low[e[t].t]);
    end else if e[t].t<>y then low[x]:=min(low[x],dfn[e[t].t]);
    t:=e[t].next;
  end;
  if dfn[x]=low[x] then
  begin inc(cnt3);
  while (zhan[top]>0) do
  begin
    bs[zhan[top]]:=cnt3;
    dec(top);
    if zhan[top+1]=x then break;
  end;
  end;
end;
function dfs(x:longint):boolean;
var t:longint;
begin
  dfs:=false;
  vis[x]:=true;
  if x=bs[n] then
    exit(true);
  t:=h1[x];
  while t>0 do
  begin
    if vis[e1[t].t]=false then
    begin
      bbl[t]:=dfs(e1[t].t);
      dfs:=dfs or bbl[t];
    end;
    t:=e1[t].next;
  end;
end;
begin
  readln(n,m); cnt2:=1;
  for i:=1 to m do
  begin
    readln(x,y);
    ad(x,y);
    ad(y,x);
  end;
  tarjan(1,0);
  if bs[1]=bs[n] then begin writeln(0);halt;end;
  for i:=1 to 2*m do
    if bs[e[i].f]<>bs[e[i].t] then
      ad1(bs[e[i].f],bs[e[i].t],i);
  dfs(bs[1]);
  for i:=1 to cnt4 do
    if bbl[i] then
    begin
      if (e[e1[i].yuan].f<>1)and(e[e1[i].yuan].f<>n) then
      begin
        inc(cnt);
        a[cnt]:=e[e1[i].yuan].f;
      end;
      if (e[e1[i].yuan].t<>1)and(e[e1[i].yuan].t<>n) then
      begin
        inc(cnt);
        a[cnt]:=e[e1[i].yuan].t;
      end;
    end;
  sort(1,cnt); for i:=1 to cnt do if a[i]<>a[i-1] then inc(cnt5);
  writeln(cnt5);
  for i:=1 to cnt do if a[i]<>a[i-1] then write(a[i],' ');
end.

```


---

## 作者：Sol1 (赞：7)

看到楼下都是P党的题解，蒟蒻来一发C++的吧！

本题就是一个割点题。

其实比较简单。从2到N-1枚举每一个点作为割点，每一次重新创建并查集，不合并包含当前割点的边。这样最后一个图的所有点就会被合并到一个集合里。最后，判断1和N是否在同一个集合里，如果在，说明图仍然连通，当前点不是割点；如果不在，说明图被分开了，当前点是一个割点，放入答案数组中。

说明结束。代码来了：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[2001],n,m,a[8001],b[8001];
void init()//初始化并查集
{
    for(int i=1;i<=n;i++) f[i]=i;
}
int getf(int v)//找到顶点v的最早祖先
{
    if(f[v]==v) return v;
    else
    {
        f[v]=getf(f[v]);
        return f[v];
    }
}
void merge(int x,int y)//合并顶点x和顶点y
{
    int u=getf(x),v=getf(y);
    if(u!=v) f[v]=u;
}
int main()
{
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a[i],&b[i]);
        if(a[i]!=2 && b[i]!=2) merge(a[i],b[i]);//第一个割点
    }
    vector<int> ans;//答案数组
    int sum=0;
    for(int i=2;i<n;)//枚举每一个割点
    {
        if(getf(1)!=getf(n))//判连通
        {
            sum++;
            ans.push_back(i);
        }
        i++;//下一个割点
        //创建并查集
        init();//清空并查集
        for(int j=1;j<=m;j++) if(a[j]!=i && b[j]!=i) merge(a[j],b[j]);//合并所有不包含割点的顶点
    }
    //输出答案
    printf("%d\n",sum);
    for(int i=0;i<sum;i++) printf("%d ",ans[i]);
    return 0;
}
```

如果有不当的地方，欢迎吐槽

by U61088 david_x

---

## 作者：wabcy (赞：4)

再来一发P党的题解：

此题用搜索思想做也比较简洁，将图构好后，枚举每个点，

假设这个点是不能通行的，如果最后牛们不能达到终点，就说明这个点是必经之路

详见代码：



  
```cpp
var
  a:array[0..2000,0..2000] of longint;
  b,d:array[0..2000] of longint;
  c:array[0..2000] of boolean;
  i,j,n,m,k,e,x,y,sum:longint;
  p:boolean;
procedure try(k:longint);
var 
  i,t:longint;
begin
  if k=n then //如果到目的地了，返回
    begin  
      p:=true;
      exit;
    end;
    c[k]:=true;//这条路走过了
    for i:=1 to b[k] do
      begin 
        t:=a[k,i];
        if not(c[t]) then try(t);//接着走
      end;
end;
begin
  readln(n,e);
  for i:=1 to e do//输入，处理路线
    begin
      readln(x,y);//构造邻接矩阵
      inc(b[x]);
      inc(b[y]);
      a[x,b[x]]:=y;
      a[y,b[y]]:=x;
    end;
  for i:=2 to n-1 do
    begin
      fillchar(c,sizeof(c),false);//重置路线
      c[i]:=true;p:=false;//假设去掉这个点
      try(1);
      if not(p) then//如果没到，就证明这个点是必经的
        begin
          inc(sum);
          d[sum]:=i;//累加点数
        end;
    end;
  writeln(sum);
  for i:=1 to sum do write(d[i],' ');//输出
end.

```

---

## 作者：说好不哭 (赞：3)

# <并查集>解法#  

****对于这一题，有很多解法。深搜加剪纸，联通图等等均可过。现在介绍我的并查集算法****

看过数据范围后，确定可以用并查集。先枚举  2到n-1这些点，假设它们中被枚举到的那一个不是要求的点。随后进行裸的并查集，遇到当前被枚举的点，就跳过。

当完成枚举后，若并查集（1）与并查集（n）的值不同，则可说明这个点如果没有，则无法联通，所以将此时枚举的点存到数组。最后输出数组即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,e,a[8001],b[8001],f[2001],ff[2001],sum[2001],xx,yy,k,jj;
int get(int x){
	if (f[x]==x) return f[x];
	else f[x]=get(f[x]);
	return f[x];          //并查集
}
int main(){
	cin>>n>>e;
	for (int i=1; i<=e; i++)
	scanf("%d %d",&a[i],&b[i]);
	for (jj=2; jj<=n-1; jj++){
	for (int i=1; i<=n; i++) f[i]=i;
	for (int i=1; i<=e; i++){
	if (a[i]==jj || b[i]==jj) continue;
	xx=get(f[a[i]]); yy=get(f[b[i]]);
	f[xx]=yy;
	}
	if (get(f[1])!=get(f[n])) {k++; sum[k]=jj;} //判断加处理
	}          
	printf("%d\n",k);
	for (int i=1; i<=k; i++)
	printf("%d ",sum[i]); //数组的输出
	return 0;
}

```

---

## 作者：MC_Launcher (赞：2)

#### 暴力水题！！！

那么怎么暴力呢？

首先，用[邻接表[1]](https://baike.baidu.com/item/%E9%82%BB%E6%8E%A5%E8%A1%A8/9796152?fr=aladdin)把相邻点都存起来，接着从尾向头走一遍（从头到尾走也可，等效），枚举$2$到$n-1$每一个断点，如果去掉是否能走到开头（或结尾），能走到，那么是不必要的，走不到，那么是必要的，就用[vector[2]](https://blog.csdn.net/wkq0825/article/details/82255984)记录所有对答案并且ans++

[时间复杂度[3]](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/5930669?fromtitle=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&fromid=1894057&fr=aladdin)大约是$O(ne)$，题目范围美滋滋

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,e,b[2001],flag;
vector<int>f[2001];
void search(int no,int now)//从终点搜索是否能不走no这个点就回到起点 
{
	if(b[now])return;//如果走过就返回 
	if(now!=no)//如果这个点不是断掉的点 
	{
		b[now]=1;//标记走过 
		if(now==1){flag=1;return;}//如果走到起点就标记旗帜并返回 
		for(int i=0;i<f[now].size();i++)//遍历相邻的点 
		{
			search(no,f[now][i]);//搜索相邻点 
		}
	}
}
int main()
{
	cin>>n>>e;
	int x,y;
	for(int i=0;i<e;i++)//连接邻接表的两个点 
	{
		cin>>x>>y;
		f[x].push_back(y);
		f[y].push_back(x);
	}
	vector<int>ans;//答案数组 
	int an=0;
	for(int i=2;i<n;i++)//阻断每个点 
	{
		flag=0;
		memset(b,0,sizeof(b));//b数组为标记数组 
		search(i,n);//搜索 
		if(!flag)//如果没有走到那么这个点是必要的 
		{
			ans.push_back(i);//加入答案 
			an++;
		}
	}
	cout<<an<<endl;
	for(int i=0;i<ans.size();i++)cout<<ans[i]<<" ";
}
```

#### 题解千万条，理解第一条。直接抄题解，棕名两行泪。

---

## 作者：LlLlCc (赞：1)

这是一道值得练手的**并查集**小题，题目要求我们求出有哪些点是1到n必定经过的点，也就是说不经过这些点，1是到不了n的。

所以我们只要枚举2到n-1，假设这个点是必经过的，在对于每条边将左右两个节点放到一个集合里（因为可以互相到达），再判断1和n是否在同一个集合就解决了。

AC代码：
```
#include<bits/stdc++.h>
#define maxn 2005
#define maxe 16005
using namespace std;
int fa[maxn],n,m,x[maxe],y[maxe],Ans,cnt[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline int getfa(int x){
	if (fa[x]==x) return x;
	return fa[x]=getfa(fa[x]);
}
int main(){
	n=read(),m=read();
    for (int i=1;i<=m;i++) x[i]=read(),y[i]=read();
    for (int i=2;i<n;i++){
    	for (int j=1;j<=n;j++) fa[j]=j;
    	for (int j=1;j<=m;j++) if (x[j]!=i&&y[j]!=i) fa[getfa(x[j])]=getfa(y[j]);
    	if (getfa(1)!=getfa(n)) cnt[++Ans]=i;
	}
	printf("%d\n",Ans);
	for (int i=1;i<=Ans;i++) printf("%d ",cnt[i]);
	return 0;
}
```


---

## 作者：AFO_07 (赞：0)

# 一道典型题
考察并查集的应用。

------------
## 分析
看题，从A农场跑到B农场。从A农场到B农场中有n-2个路口，分别标上号，A农场为1号， B农场为n号，路口分别为 2 ..n -1 号，从A农场到B农场有很多条路径可以到达，每条路径都经过的路口，这样CG就可以先到那个路口，观察新牛们有没有偷懒，而你的任务就是找出所有必经路口。其实就是枚举这个点不走时，能不能到达终点。如果可以，就不是必经路口。

------------
## 实现方法
重点来了！！！并查集！！！f[i]数组我们就将它当成i这个点最早的父亲。运用到递归思想，不断往上找，判断当前这个点是不是最早的父亲，如果是，假设这个点是x，那么f[x]==x。
## 附上AC代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[8001],b[8001],n,m,p,ans,anss[2001],f[2001];
int find(int x)
{
    if(f[x]!=x) f[x]=find(f[x]);//如果当前这个点不是最早能追溯的点就接着往上找，并记录，优化时间复杂度。
    return f[x];
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>a[i]>>b[i];
    for(int j=2;j<=n-1;j++)//枚举哪个点不跑。
    {
        for(int i2=1;i2<=n;i2++) f[i2]=i2;//初始化。
        for(int i=1;i<=m;i++)
        {
            if(a[i]==j||b[i]==j) continue;//如果当前这个点是枚举的点就不跑。
            int aa=find(a[i]);
            int bb=find(b[i]);//并查集。
            if(aa!=bb) f[aa]=bb;//最早追溯的点不是同一个，说明不连通，就把它们连起来。
        }
        if(find(f[1])!=find(f[n]))//判断起点终点联不联通。 
        {
            ans++;
            anss[++p]=j;//记录答案。
        }
    }
    cout<<ans<<endl;
    for(int i=1;i<=p;i++) cout<<anss[i]<<" ";
}
```
## 完结撒花
~~写的不好，大佬勿喷。~~


---

## 作者：devil_ (赞：0)


当时刚看完题，就兴冲冲去打了个“割点”的模板，结果...脸都黑了

做完之后再仔细看了眼题目，发现自己好像有一点误解。

Emmm...

符合要求的“路口” 删去之后，应该是无法再**从起点到达终点**，而不是**图不再联通**。

如果将一个“路口”删去之后，**图不再联通**，但仍然可以 **从起点到达终点** ，那么这个“路口”就并不符合要求。

所以如果求了“割点”，不仅代码长了一节，还没有分。

其实这个题正解就是一个 简单的 枚举加并查集，做完才发现这一点的本蒟蒻哭的好大声。

**详解：**

1. 直接枚举每一个点；

2. 检验删除这个点之后，能否从起点到达终点； （每次删点前初始化一次，在忽略被删点的情况下，重建一次图，查询起点和终点是否还在同一个集合内。如果不在，记录在这种情况下被删除点的编号。）

3. 输出结果。

**AC代码：**

```
#include <bits/stdc++.h>
using namespace std;
int n,m,sum,f[2001],a[8001],b[8001],ans[2001];

void chu()
{
    for(int i=1;i<=n;i++) f[i]=i;
}

int find_(int v)
{
    if(f[v]==v) return v;
    else
        return f[v]=find_(f[v]);
}

void unite(int x,int y)
{
    int u=find_(x),v=find_(y);
    if(u!=v) f[v]=u;
}

int main()
{
    scanf("%d%d",&n,&m);
    chu();
    for(int i=1;i<=m;i++)
       scanf("%d %d",&a[i],&b[i]);
    for(int i=2;i<n;i++)
    {
        chu();
        for(int j=1;j<=m;j++) 
            if( a[j]!=i && b[j]!=i ) 
                unite(a[j],b[j]);
        if(find_(1)!=find_(n))
        {
            sum++;
            ans[sum]=i;
        }       
    }
    printf("%d\n",sum);
    for(int i=1;i<=sum;i++) printf("%d ",ans[i]);
    return 0;
}
```


---

## 作者：HPXXZYY (赞：0)

感谢Edsger_Wybe_Dijkstra大佬提供的思路，这里我在Edsger_Wybe_Dijkstra大佬的思路下提供另外一种写法！

[大佬题解](https://www.luogu.org/blog/xiezihan123456789/solution-p1793)

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> ans;
int i,j,f[2010],m,sum;
int a[8100],b[8100],n;
int getf(int x){
	if (f[x]==x) return x;
	return f[x]=getf(f[x]);
}
//并查集基本操作1：查找祖宗（“代表”）
void merge(int a,int b){
	f[getf(b)]=getf(a);
} 
//并查集基本操作2：合并集合 
void init_set(){
	for(int i=1;i<=n;i++) f[i]=i;
}
//并查集基本操作3：初始化并查集  
int main(){
//	freopen("t1.in","r",stdin);
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++){
		scanf("%d%d",&a[i],&b[i]);
	}
	for(i=2;i<n;i++){
		init_set();
		for(j=1;j<=m;j++)
		if (a[j]!=i&&b[j]!=i)
		merge(a[j],b[j]);
		if (getf(1)!=getf(n)){
			sum++;ans.push_back(i);
//			找到一个答案  
		}
	}
	printf("%d\n",sum);
//	输出答案个数 
	for(i=0;i<sum;i++)
	printf("%d ",ans[i]);
//	依次输出所有答案 
	return 0; 
} 
```


---

## 作者：谦谦君子 (赞：0)

发现有很多人写了并查集（只有三个人），~~但是发现似乎都写麻烦了，虽然我的代码更长......~~

在此蒟蒻就再写一个吧
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10001],x[10001],y[10001],a[10001],ans;
int find(int x)
{
	if(f[x]==x)
	{
	    return x;
	}
	return f[x]=find(f[x]);  //路径压缩
}
int main()
{
	int n,e;
	cin>>n>>e;
	for(int i=1;i<=e;i++)
	{
	    cin>>x[i]>>y[i];
	}
	for(int i=2;i<n;i++)
	{
		for(int j=1;j<=n;j++)
		{
		    f[j]=j;
		}
		for(int k=1;k<=e;k++)
		{
			if(x[k]==i||y[k]==i)
			{
			    continue;
			}
			int u=find(x[k]),v=find(y[k]);
			if(u==v)
			{
				continue;
			}
			f[u]=v;
		}
		if(find(1)!=find(n))
		{
			a[ans++]=i;
		}
	}
	cout<<ans<<endl;
	for(int i=0;i<ans;i++)
	{
	    cout<<a[i]<<" ";
	}
	cout<<endl;
	return 0;
}
```

---

## 作者：夏色祭 (赞：0)

没人发题解。。。

并查集水题，i枚举2到n-1每个点，如果一条路其中一个点=i，那么这条路相当于废了，其余的路进行合并，最后判断如果第i个点废了，从1还能到n吗，如果不能那么把i加入到一个数组

PascalAC代码：

```cpp
var
  x,y:array[0..8001]of longint;
  a:array[0..2001]of longint;
  f:array[0..2001]of longint;
  n,m,i,j,t:longint;
function find(x:longint):longint;
begin
  if f[x]=x then exit(x);
  f[x]:=find(f[x]);
  exit(f[x]);
end;
begin
  readln(n,m);
  for i:=1 to m do
    readln(x[i],y[i]);
  for i:=2 to n-1 do
    begin
      for j:=1 to n do f[j]:=j;
      for j:=1 to m do 
        if (x[j]<>i)and(y[j]<>i) then f[find(x[j])]:=find(y[j]);
      if find(1)<>find(n) then 
        begin
          inc(t);
          a[t]:=i;
        end;
    end;
  writeln(t);
  for i:=1 to t do write(a[i],' '); 
end.
```

---


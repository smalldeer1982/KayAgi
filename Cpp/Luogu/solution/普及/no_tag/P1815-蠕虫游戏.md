# 蠕虫游戏

## 题目描述

蠕虫是一个古老的电脑游戏，它有许多版本。但所有版本都有一个共同的规则：操纵一条蠕虫在屏幕上转圈，并试着去避免撞到自己或障碍物。

这里我们将模拟一个简单的版本。游戏将在 $50 \times 50$ 的棋盘上进行，棋盘的左上角为 $(1,1)$，蠕虫在初始时是一串 $20$ 个相连的方格。所谓相连是指方格在水平或垂直方向上相接。蠕虫开始时是水平地伸展开的，从 $(25,11)$ 到 $(25,30)$。其中 $(25,30)$ 是它的头。蠕虫只能向东 $\verb!E!$、西 $\verb!W!$、南 $\verb!S!$、北 $\verb!N!$ 四个方向移动，但不能向自己移动，因此在开始时向西 $\verb!W!$ 是不允许的。每次移动时，蠕虫向给定的方向移动，一次只移一格，并且保持它的长度不变。因此只有蠕虫的头和尾所占据的方格在移动一步后被改变。注意：蠕虫的头能移动到虫尾刚刚让出的空格。

你将被给定一系列移动指令并模拟虫的移动，直到蠕虫撞上了自己，或者蠕虫越出了棋盘，或者蠕虫成功地完成了这些指令。在前两种情况下你应当忽略剩下的指令。

## 样例 #1

### 输入

```
18 
NWWWWWWWWWWSESSSWS 
20 
SSSWWNENNNNNWWWWSSSS 
30 
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 
13 
SWWWWWWWWWNEE 
0```

### 输出

```
The worm successfully made all 18 moves. 
The worm ran into itself on move 9. 
The worm ran off the board on move 21. 
The worm successfully made all 13 moves.```

# 题解

## 作者：Augen_stern (赞：8)

## Part 1: 分析求解

题目的意思大致就是模拟一条蠕虫的活动，来观察它是否还活着。

算法的话直接暴力模拟就好了。

读题一直都很重要，请注意“棋盘的左上角为 $(1,1)$”和“蠕虫开始时是水平地伸展开的，从 $(25,11)$ 到 $(25,30)$”，所以定义两个方向数组时注意 $(x,y)$ 中的 $x$ 实际上是原直角坐标系的 $y$，这里的 $y$ 与其同理；

为了方便叙述，本文 $(x,y)$ 中的 $x$ 实际上是纵坐标，$y$ 实际上是横坐标（~~有点绕~~）

所以可以定义操作数组：

```cpp
int dx[7]= {0,-1,0,1,0}; 
int dy[7]= {0,0,1,0,-1}; // 占位，N，E，S，W；
```

接着考虑第一种问题：“蠕虫撞上了自己”；

此时，我们可以通过两个数组分别来定义这个蠕虫的每一个身体节点，为每一个头，而因为这只蠕虫的长度恒为 $20$，所以它的尾节点则可以储存在身体节点数组中。

预处理初始的身体节点：
```cpp
int cnt=0,fg=0;
for(int i=11; i<=30; i++) {
	headx[i-10]=25;
	heady[i-10]=i;
	map[25][i]=1; // 标记每一个身体节点。
	cnt++;
}
int len=cnt;
```
在对于输入的字符串的每一位进行存储：
```cpp
int f=0;
if(s[i]=='N') f=1;
else if(s[i]=='E') f=2;
else if(s[i]=='S') f=3;
else if(s[i]=='W') f=4;
cnt++;
headx[cnt]=headx[cnt-1]+dx[f];
heady[cnt]=heady[cnt-1]+dy[f];
tailx=headx[cnt-len+1];
taily=heady[cnt-len+1]; // len=20;
map[tailx][taily]=0; // 释放过去的尾巴标记。
```
此时，若蠕虫撞上了自己，则可以有：

```cpp
if(map[headx[cnt]][heady[cnt]]==1) printf("The worm ran into itself on move %d.\n",i+1),fg=1;
```
然后考虑第二个问题，蠕虫出界了：

```cpp
if(headx[cnt]>50||heady[cnt]>50||headx[cnt]<1||heady[cnt]<1) printf("The worm ran off the board on move %d.\n",i+1),fg=1;
```
这些时候，因为标记 $fg=1$ 则可以直接下一组数据，跳出循环。

直到最后还活着，就可以成功了：

```cpp
if(fg) continue;
printf("The worm successfully made all %d moves.\n",n);
```
## Part 2：CODE

所以就可以秒掉了，只需要注意每一次循环都要初始化：

```cpp
#include<iostream>
#include<math.h>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff/2
using namespace std;
int n,tailx,taily;
int map[55][55];
int dx[7]= {0,-1,0,1,0};
int dy[7]= {0,0,1,0,-1};
int headx[200],heady[200];
int main() {
	while(scanf("%d",&n)) {
		if(n==0) break;
		memset(map,0,sizeof(map));
		memset(headx,0,sizeof(headx));
		memset(heady,0,sizeof(heady)); // 初始化；
		int cnt=0,fg=0;
		for(int i=11; i<=30; i++) {
			headx[i-10]=25;
			heady[i-10]=i;
			map[25][i]=1;
			cnt++;
		}
		int len=cnt; // 预处理；
		string s;
		cin>>s;
		for(int i=0; i<n; i++) {
			int f=0;
			if(s[i]=='N') f=1;
			else if(s[i]=='E') f=2;
			else if(s[i]=='S') f=3;
			else if(s[i]=='W') f=4; // 找方向；
			cnt++;
			headx[cnt]=headx[cnt-1]+dx[f];
			heady[cnt]=heady[cnt-1]+dy[f];
			tailx=headx[cnt-len+1];
			taily=heady[cnt-len+1]; // 储存节点；
			map[tailx][taily]=0;
			if(map[headx[cnt]][heady[cnt]]==1) printf("The worm ran into itself on move %d.\n",i+1),fg=1; // 第一种情况；
			else if(headx[cnt]>50||heady[cnt]>50||headx[cnt]<1||heady[cnt]<1) printf("The worm ran off the board on move %d.\n",i+1),fg=1; // 第二种情况；
			else map[headx[cnt]][heady[cnt]]=1;
			if(fg) break;
		}
		if(fg) continue; // 直接下一组数据。
		printf("The worm successfully made all %d moves.\n",n); // 苟到最后就是胜利。
	}
	return 0;
}
```

自给自足，丰衣足食！！！

2021.9.8 13:20 初稿成

---

## 作者：0nullptr (赞：5)

传送门：[P1815](https://www.luogu.org/problem/P1815)

这道题要求我们模拟实现一个类似于贪吃蛇一样的东西。既然是模拟，那么最关键的是如何将题目中所给的蠕虫及动作抽象成我们的程序过程。

首先，要考虑如何存储蠕虫。注意到蠕虫的长度是始终固定的，那么可以直接开一个定长的数组存储下蠕虫身体的每一节即可。为了方便，可以直接定义以下结构体。其每一个元素存储当前蠕虫这一节的坐标。
```cpp
struct node {
    int x, y;
} body[25];

for (int i = 1; i <= 20; i++){
    body[i].x = 25;
    body[i].y = 31 - i;
}//初始化
```
接下来考虑如何处理蠕虫的行进。很容易想到一种暴力的方法，即将蠕虫头先向一个方向移动，并判断是否存在越界现象，再将其余的部分一点一点的向前提。这里有一个易错点，题目中说
>注意：蠕虫的头能移动到虫尾刚刚让出的空格。

因此不能在头移动后直接判断相撞，而是在身体移动过程中判断是否与头部重叠。由于$n<100$，所以这种暴力做法显然是可以接受的。代码实现如下
```cpp
const int step[4][2] = {//行走数组
    0,  1,//E
    0, -1,//W
    1,  0,//S
    -1, 0//N
};
int error;//取值为0,1,2,对应题目中的三种输出情况
void go(int x) {//x代表向那个方向前进
    int last_x = body[1].x, last_y = body[1].y;//记录一部分移动后留下的空缺位置
    body[1].x += step[x][0];
    body[1].y += step[x][1];//头部向前移动
    if (body[1].x > 50 || body[1].y > 50 || body[1].x < 1 || body[1].y < 1) {//判断是否越界
        error = 2;
        return;
    }
    for (int i = 2; i <= 20; i++){
        swap(last_x, body[i].x);
        swap(last_y, body[i].y);//将身体的每一节向前移动
        if (body[i].x == body[1].x && body[i].y == body[1].y){
//判断是否和头部重叠即判断是否移动后撞到自己
            error = 1;
            return;
        }
    }
}
```
这样，这道题的核心部分就处理完成了。加上输入输出后完整代码如下
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int step[4][2] = {
    0,  1,
    0, -1,
    1,  0,
    -1, 0
};

struct node {
    int x, y;
} body[25];

int error;
void go(int x) {
    int last_x = body[1].x, last_y = body[1].y;
    body[1].x += step[x][0];
    body[1].y += step[x][1];
    if (body[1].x > 50 || body[1].y > 50 || body[1].x < 1 || body[1].y < 1) {
        error = 2;
        return;
    }
    for (int i = 2; i <= 20; i++){
        swap(last_x, body[i].x);
        swap(last_y, body[i].y);
        if (body[i].x == body[1].x && body[i].y == body[1].y){
            error = 1;
            return;
        }
    }
}

int main() {
    int n;
    while (cin>>n && n) {
        error = 0;
        for (int i = 1; i <= 20; i++){
            body[i].x = 25;
            body[i].y = 31 - i;
        }
        string walk;
        cin>>walk;
        int bug = 0;
        for (int i = 0; i < n; i++) {
            if (walk[i] == 'E') go(0);
            if (walk[i] == 'W') go(1);
            if (walk[i] == 'S') go(2);
            if (walk[i] == 'N') go(3);
            if (error) {
                bug = i + 1;
                break;
            }
        }
        if (error == 0){
            printf("The worm successfully made all %d moves.\n", n);
        }
        if (error == 1){
            printf("The worm ran into itself on move %d.\n", bug);
        }
        if (error == 2){
            printf("The worm ran off the board on move %d.\n", bug);
        }
    }
    return 0;
}
```


---

## 作者：sxyugao (赞：5)

这道题没多少人做，~~赶紧来水一发~~


------分割线------


**题意**

就是让我们模拟一个贪吃蛇最基本的操作，而且不会变长

问你这条虫子执行指令后的情况，超出格子、撞到自己或是正常结束。

**输入、输出**

详见题面

**算法**

模拟（不然你说怎么搞。。）


以下为代码（我才不会告诉你这是我贪吃蛇游戏代码改的呢）：



```cpp
const                       //常量定义错误序号
Error_die=1;                //错误序号1：撞到自己
Error_OutOfMap=2;           //错误序号2：超出边界
Normal=0;                   //正常退出
//P.S. 如果你英文够好，其实不需要注释。。
var
n,i:longint;
s:string;                  //指令集
bug:array[0..20]of record x,y,direction:longint;end;
//用于储存虫子每节的信息
//bug[i].x意为第i节虫子的横坐标，bug[i].y为纵坐标，bug[i].direction为方向
error:boolean;            //处理指令时有无错误
function go(n:longint):longint;//过程，表示在第n个方向上前进1个单位
  var i,j:longint;
  begin
    bug[0]:=bug[1];bug[0].direction:=n;
    case bug[0].direction of
    1:inc(bug[0].y);//向东
    2:dec(bug[0].x);//向南
    3:dec(bug[0].y);//向西
    4:inc(bug[0].x);//向北
    end;//头先前进
    if bug[0].x>49 then exit(Error_OutOfMap);
    //我一开始一直90分，就是这里打的是bug[0].x>50。。
    //因为虫子是一条线，所以一开始是25，向上、向下都只有25。
    //如果打成>50，会出现26步才出界
    if bug[0].x<1 then exit(Error_OutOfMap);
    if bug[0].y>50 then exit(Error_OutOfMap);
    if bug[0].y<1 then exit(Error_OutOfMap);
    //如果超出边界，抛出错误
    for i:=20 downto 1 do bug[i]:=bug[i-1];
    //前进一格，bug[i]=bug[i-1]，其实就是把虫子的当前节变成上一节
    for i:=1 to 19 do
      for j:=i+1 to 20 do
        if(bug[i].x=bug[j].x)and(bug[i].y=bug[j].y)then exit(Error_die)；
        //如果同一只虫子有两节坐标相同，说明撞到一起了，抛出错误
    exit(Normal);//正常退出
  end;
function work(ch:char):longint;//处理指令集中的每一个指令
  var k:longint;//k表示方向
  begin
    case ch of
    'E':k:=1;//向东
    'S':k:=2;//向南
    'W':k:=3;//向西
    'N':k:=4;//向北
    end;
    //P.S. 不需要判指令是否正确，比如当前向北，指令让虫子向南，照指令来
    //如果判错，只有50分（这是题面的坑，说好的“不能向自己移动”呢？）
    exit(go(k));//向方向k前进
  end;
begin
while true do
  begin
    readln(n);if n=0 then break;//如果读到0，说明数据结束了，退出
    readln(s);                  //读入指令集
    for i:=1 to 20 do
     begin
       bug[i].y:=31-i;
       bug[i].x:=25;bug[i].direction:=1;
     end;
     //由题意初始化虫子
    error:=false;               //假设没有错误
    for i:=1 to n do            //逐个处理指令
      case work(s[i]) of        //分错误类别
      Error_OutOfMap:begin
                       writeln('The worm ran off the board on move ',i,'.');
                       error:=true;//有错误直接跳出，不必执行后面的指令了
                       break;
                     end;
      Error_die:begin
                  writeln('The worm ran into itself on move ',i,'.');
                  error:=true;
                  break;//同上
                end;
      end;
    if not error then writeln('The worm successfully made all ',n,' moves.');
    //如果没有错误，那么输出正常地结束
  end;
end.
```
------------


以上就是这题的题解了，希望管理员大大能给过，谢谢。


---

## 作者：wfycsw (赞：3)


- 让我们来分析一下这道题。

- ### 算法：模拟法。

- ### 数据结构：队列 （其实不用也行）。

以下便是队列。

```cpp
int a[125][2];
for(i=11;i<=30;++i){
		b[25][i]=1;
		a[i-10][0]=25;
		a[i-10][1]=i;
	}
```
    
有了队列以后，就可以开始模拟了。

现在开始——上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,a[125][2],p；
int x[4]={0,0,1,-1},y[4]={1,-1,0,0};//移动数组
bool b[125][55],q;char c,s[125];
int main(){
	while(1){
		scanf("%d",&n);q=0;
		if(!n) return 0;//判断数据是否读完
		scanf("%s",&s);
		memset(b,0,sizeof(b));
		for(i=11;i<=30;++i){//位置初始化
			b[25][i]=1;
			a[i-10][0]=25;
			a[i-10][1]=i;
		}
		for(i=1;i<=n;++i){
			j=i+20;c=s[i-1];
			b[a[i][0]][a[i][1]]=0;//先将尾巴收回
			if(c=='E') p=0;
			else if(c=='W') p=1;
			else if(c=='S') p=2; 
			else p=3;
			a[j][0]=a[j-1][0]+x[p];//头部向前移动
			a[j][1]=a[j-1][1]+y[p];
			if(a[j][0]<1||a[j][0]>50||a[j][1]<1||a[j][1]>50){//判断是否撞墙
				printf("The worm ran off the board on move %d.\n",i);
				q=1;break;
			}
			else if(b[a[j][0]][a[j][1]]){
				printf("The worm ran into itself on move %d.\n",i);//判断是否撞到自己
				q=1;break;		
			}
			else b[a[j][0]][a[j][1]]=1;
		}	
		if(!q) printf("The worm successfully made all %d moves.\n",n);
	}	
}
```
第一次发题解，望管理员通过。

---

## 作者：cyp0633 (赞：3)

楼上的你别走……第二个提交题解的来了

这个题就是个大模拟，个人感觉关键在于搞定尾巴

第一次做竟然全都输出了第一步撞到自己（逃

```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<map>
#include<vector>
using namespace std;
char a[101];
int dis[4][2]={{0,1},{0,-1},{1,0},{-1,0}},d[200][3],n,i,j,err,t,w,f,nx,ny,m;
int main()
{
    //freopen("worm.in","r",stdin);
    //freopen("worm.out","w",stdout);
    scanf("%d",&n);
    while(n>0)
    {
        scanf("%s",a);
        d[1][1]=25;
        d[1][2]=11;
        err=0;
        for(i=2;i<=20;i++)
        {
            d[i][1]=25;
            d[i][2]=i+10;
        }
        t=20;w=1;
        for(i=0;i<n;i++)
        {
            switch(a[i])
            {
                case 'E':f=0;break;
                case 'W':f=1;break;
                case 'S':f=2;break;
                case 'N':f=3;break;
            }
            nx=d[t][1]+dis[f][0];
            ny=d[t][2]+dis[f][1];
            if(nx<=0||nx>50||ny<=0||ny>50)
            {
                err=1;
                m=i+1;
                break;
            }
            w++;
            for(j=w;j<=t-1;j++)
                if(d[j][1]==nx&&d[j][2]==ny)
                {
                    err=2;
                    m=i+1;
                    break;
                }
            if(err==2)
                break;
            d[++t][1]=nx;
            d[t][2]=ny;    
        }
        if(err==0)
            printf("The worm successfully made all %d moves.\n",n);
        if(err==1)
            printf("The worm ran off the board on move %d.\n",m);
        if(err==2)
            printf("The worm ran into itself on move %d.\n",m);        
    scanf("%d",&n);
    }        
    //fclose(stdin);
    //fclose(stdout);
     return 0;
}
```

---

## 作者：K2sen (赞：0)

## P1815 蠕虫游戏
~~这个东西难道不是开一个双端队列就做完了的吗？？~~

显然这个题的难点在于处理尾巴，我们可以开一个双端队列，

一遍处理尾巴，一边处理头（详情请见代码）

```cpp
void yidong(char opt) {
	node ba = q.back();q.pop_back();//处理尾巴
	pan[ba.x][ba.y] = 0;//因为头正好走到尾巴不算死所以先给他个0;
	node fr = q.front();//判断往哪里拐
	if (opt == 'E') fr.y++;
	if (opt == 'W') fr.y--;
	if (opt == 'S') fr.x++;
	if (opt == 'N') fr.x--;
	if (pan[fr.x][fr.y] == 0)
		q.push_front(fr), pan[fr.x][fr.y] = 1;
	else if (pan[fr.x][fr.y] == 1) flag = 1;
	else flag = 2;
}
```

然后呢，就没有然后了...

### code
```cpp
#include <bits/stdc++.h>
#include <queue>
#define ll long long
#define N 100010
#define M 60

using namespace std;
int n, flag = 0, ans;
int pan[M][M]; char s[110];
int hx, hy, tx, ty;
struct node {
	int x, y;
};
deque<node> q;

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void init() {
	q.clear();
	hx = 25, hy = 30, tx = 25, ty = 11;
	memset(pan, 0, sizeof pan); flag = 0;
	for (int i = 1; i <= 50; i++) 
		pan[i][0] = pan[i][51] = pan[51][i] = pan[0][i] = 22;
	for (int i = 30; i >= 11; i--) {
		node fr; fr.x = 25, fr.y = i;
		q.push_back(fr);
		pan[25][i] = 1; 
	}
}

void yidong(char opt) {
	node ba = q.back();q.pop_back();
	pan[ba.x][ba.y] = 0;
	node fr = q.front();
	if (opt == 'E') fr.y++;
	if (opt == 'W') fr.y--;
	if (opt == 'S') fr.x++;
	if (opt == 'N') fr.x--;
	if (pan[fr.x][fr.y] == 0)
		q.push_front(fr), pan[fr.x][fr.y] = 1;
	else if (pan[fr.x][fr.y] == 1) flag = 1;
	else flag = 2;
}

int main() {
	n = read();
	while (n != 0) {
		init();
		for (int i = 1; i <= n; i++)
			cin >> s[i];
		int ans;
		
		for (int i = 1; i <= n; i++) {
			yidong(s[i]);
			if (flag != 0) {
				ans = i;
				break; 
			}
		}
		if (flag == 1) 
			printf("The worm ran into itself on move %d.\n", ans);
		else if (flag == 2) 
			printf("The worm ran off the board on move %d.\n", ans);
		else printf("The worm successfully made all %d moves.\n", n);
		n = read();
	}
}
```

---

## 作者：hylong (赞：0)

~~C++的STL真好用。~~
#### 题目转述
 这里我们将 **模拟** 一个简单的版本。游戏将在50×50的棋盘上进行，棋盘的左上角为(1,1)，蠕虫在初始时是一串20个相连的方格。所谓相连是指方格在水平或垂直方向上相接。蠕虫开始时是**水平地**伸展开的，从(25,11)到(25,30)。其中(25,30)是它的头。蠕虫只能向东(E)、西(W)、南(s)、北(N)四个方向移动，但不能向自己移动，**因此在开始时向西(W)是不允许的**。每次移动时，蠕虫向给定的方向移动，一次只移一格，并且保持它的**长度不变**。因此只有蠕虫的头和尾所占据的方格在移动一步后被改变。注意：**蠕虫的头能移动到虫尾刚刚让出的空格**。
#### 坑点：
   1. 这条虫子开始是**横着的**而且头向西。
   2. 虫子的尾巴难处理，可是STLqueue轻松解决，如果不知道，可以用C-free5的C/C++ 语言参考查找或者我帮你[百度](https://blog.csdn.net/dingzj2000/article/details/85782167)[一下](https://www.cnblogs.com/didiaoxiaoguai/p/8007612.html)
#### 代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x;
	int y;
};//结构体
bool vis[53][53];//标记虫子的位置
int mv[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int main()
{
	int n,i,j,k;
	string a;
	while(scanf("%d",&n),n!=0)
	{
	 cin>>a;
	 int hx=30,hy=25,tx=11,ty=25,f;
	 bool ok=true;
	 node b;
	 memset(vis,true,sizeof(vis));
         queue<node>que;//初始化
	 for(i=11;i<=30;i++)
	  vis[i][25]=false,que.push({i,25});//标记位置，压入队列
	 vis[11][25]=true;//预先处理掉尾巴
	 i=0;
	 while(i<n)
	 {
	  switch(a[i])
	  {
	   case 'E':f=0;break;
	   case 'W':f=1;break;
	   case 'S':f=2;break;
	   case 'N':f=3;break;
	  }//个人感觉用switch比if清爽
	  i++;
	  hx+=mv[f][0];
	  hy+=mv[f][1];
	  que.push({hx,hy});//处理下一个点并压入队列
	  b=que.front();
	  que.pop();//这个必须加
	  tx=b.x;
	  ty=b.y;
	  vis[tx][ty]=true;//此句一定要放这里，否则后果自负
	  if(!vis[hx][hy])
	  {
	   printf("The worm ran into itself on move %d.\n",i);
	   ok=false;
	   break;
	  }//判断是否撞到自己
	  if(hx>50 || hy>50 || hx<1 || hy<1)
	  {
	   printf("The worm ran off the board on move %d.\n",i);
	   ok=false;
	   break;
	  }//判断是否撞墙
	  vis[hx][hy]=false;//标记掉
	 }
	 if(ok)
	  printf("The worm successfully made all %d moves.\n",n);//判断是否完成所有操作。
	}
	return 0;
} 
```
~~其实百度和一下都可以点的。~~

---

## 作者：21002tyj (赞：0)

这题肿么只有我一个人写了~~

模拟~但是要注意尾巴要先去掉再判断能不能走。

还有，我是用一个队列来储存蠕虫的轨迹，用一个二维数组来记录实时状态。另外还有一种链表的~






```cpp
var
    n      :longint;
    m      :array[0..51,0..51]of shortint; //0:empty -1:wall 1:itself
    bx,by  :longint;
    w      :array[1..200,1..2]of integer;
    open,cl:longint;
procedure init;
var
    i,j:longint;
begin
    fillchar(m,sizeof(m),0);
    for i:=0 to 51 do
    begin
        m[i,0]:=-1;
        m[i,51]:=-1;
        m[0,i]:=-1;
        m[51,i]:=-1;
    end;
    open:=0;
    cl:=0;
    for i:=11 to 30 do
    begin
        m[25,i]:=1;
        inc(cl);
        w[cl,1]:=25;
        w[cl,2]:=i;
    end;
    bx:=25;
    by:=30;
end;
procedure go(dir:char);
var
    i,j:longint;
begin
    case dir of
          'N':bx:=bx-1;
          'S':bx:=bx+1;
          'W':by:=by-1;
          'E':by:=by+1;
        end;
    m[bx,by]:=1;
    inc(cl);
    w[cl,1]:=bx;
    w[cl,2]:=by;
end;
procedure move;
var
    i,j:longint;
    step:longint;
    ok:boolean;
    dir:char;
begin
    step:=0;
    repeat
        inc(open);
        m[w[open,1],w[open,2]]:=0;
        ok:=true;
        inc(step);
        read(dir);
        case dir of
          'N':if m[bx-1,by]<>0 then begin ok:=false; break; end;
          'S':if m[bx+1,by]<>0 then begin ok:=false; break; end;
          'W':if m[bx,by-1]<>0 then begin ok:=false; break; end;
          'E':if m[bx,by+1]<>0 then begin ok:=false; break; end;
        end;
        go(dir);
    until (not ok) or (step=n);
    readln;
    if ok then
        writeln('The worm successfully made all ',n,' moves.')
    else
    begin
        case dir of
          'N':bx:=bx-1;
          'S':bx:=bx+1;
          'W':by:=by-1;
          'E':by:=by+1;
        end;
        if m[bx,by]=-1 then
            writeln('The worm ran off the board on move ',step,'.')
        else
            writeln('The worm ran into itself on move ',step,'.');
    end;
end;
begin
    repeat
        readln(n);
        if n=0 then break;
        init;
        move;
    until false;
end.

```

---


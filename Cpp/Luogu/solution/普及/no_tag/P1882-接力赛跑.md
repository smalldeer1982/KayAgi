# 接力赛跑

## 题目描述

$N (1\le N\le 1000)$ 只奶牛（编号为 $1$ 到 $N$）在进行一个特别的接力赛跑，这个比赛特别之处在于，若干只奶牛可以同时跑。

在 $t=0$ 时刻，牛 $1$ 开始沿着跑道跑。

通常，牛 $i$ 跑完一圈需要的时间为 $L_i (1\le L_i\le 1000)$ 秒。当它重新越过起点线的瞬间，它会通知另外 $M_i (1\le M_i\le N)$ 只奶牛 $A_{ij} (1\le j\le M_i)$ 起跑。注意可能出现 $M_i=0$ 并且 $A_i$ 不存在的情况。

每一只开始赛跑的奶牛，等到它回到起点时，都会通知其他奶牛起跑。可能出现多只奶牛通知同一只奶牛起跑的情况，但是每一只奶牛只愿意跑一圈，所以它被第二次叫到的时候就不愿意再跑了。

农场主希望你帮他确定总的赛跑时间（也就是从比赛开始到最后一只奶牛越过终点的时间）。

## 样例 #1

### 输入

```
5
4 2 2 4
3 3 1 3 4
7 1 5
4 2 3 5
1 0```

### 输出

```
14```

# 题解

## 作者：CherryPockyOvO (赞：6)

最近一直被机房教练逼着做多项式，被搞自闭，所以做一做水题。

~~结果也被水题搞自闭了~~

QAQ

首先先看一段本题我原来的代码

```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n;
queue<int> q[1000040]; 
bool rs[1040];
int spt[1040];
int f[1040][1040];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&spt[i],&f[i][0]);
		for(int j=1;j<=f[i][0];j++) scanf("%d",&f[i][j]);
	}
	rs[1]=1; 
	q[spt[1]].push(1);
	for(int i=1;n;i++){
		while(!q[i].empty()){
			n-=1;
			int now=q[i].front();
			for(int j=1;j<=f[now][0];j++){
				if(rs[f[now][j]]) continue;
				q[i+spt[f[now][j]]].push(f[now][j]);
				rs[f[now][j]]=1;
			}
			q[i].pop();
		}
		if(n==0){
			printf("%d\n",i);
			break;
		}
	}
	return 0;
}
```

思路清晰，就是每个时间开个queue存储该时间内到达终点牛的编号。样例更是直接水过去…………

可是一交上去全都MLE了，图片太过残忍，就不放了。

显而易见每个时间开个队列这空间必炸……(蒟蒻的我开始没想到……）

因此我们该如何优化呢，这就是优先队列登场的时候了。

这里用小根堆套个二元组，第一元素存储该编号的奶牛到终点的时间，第二个元素存储该牛的编号。

以后每次把队头取出，将这头牛该通知的牛儿全都扫一遍，没通知过的就让他策牛奔腾，向小根堆里加入一个成员，第一元素为当前时间+该牛跑一圈的时间，第二元素就是该牛的编号。

最后一次要注意，因为就剩最后一头牛，其他牛全跑过了，当最后一头牛跑完的时候，弹出，最后队列为空，输出该牛跑完的时间.

详见代码^-^
```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n;
bool rs[1040];
int spt[1040];
int f[1040][1040];
priority_queue<pair<int,int> > q; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&spt[i],&f[i][0]);
		for(int j=1;j<=f[i][0];j++) scanf("%d",&f[i][j]);
	}//读入 
	rs[1]=1;//对第一头牛打标记 
	q.push(make_pair(-spt[1],1));//注意，因为是prioity_queue是大根堆，加入时间的相反数即可实现小根堆 
	while(!q.empty()){
		pair<int,int> now=q.top();
		now.first*=-1; //因为之前加入的是时间的相反数，故要变回来。 
		for(int j=1;j<=f[now.second][0];j++){ //枚举当前牛要通知的所有牛。 
			if(rs[f[now.second][j]]) continue; //如果已经跑过了就不用跑了。 
			q.push(make_pair(-(now.first+spt[f[now.second][j]]),f[now.second][j])); //加入队列，再强调一遍，时间要是相反数！！! 
			rs[f[now.second][j]]=1; //对该牛打上标志，已经跑过. 
		}
		q.pop();
		if(q.empty()) printf("%d\n",now.first); //如果队列为空,则所有牛都跑完了，则输出最后一头牛跑完的时间 
	}
	return 0;
}
```
写的比较丑，多见谅哈!


---

## 作者：tututu (赞：4)

短路，用dijkstra算出从牛1到每只牛的最短距离，若i会通知j，那么i到j距离为l[j]

```cpp
var
  n,i,j,sum,min:longint;
  a,b,d:array[-1..1002] of longint;
  f:array[-1..1002,-1..1002] of longint;
  t:array[-1..1002] of boolean;
begin
  readln(n);
  for i:=1 to n do
    begin
      read(a[i],b[i]);
      for j:=1 to b[i] do read(f[i,j]);
    end;
  fillchar(d,sizeof(d),$3f);
  d[1]:=a[1];
  for i:=1 to b[1] do d[f[1,i]]:=a[1]+a[f[1,i]];
  t[1]:=true;
  for i:=1 to n-1 do
    begin
      min:=0;
      for j:=1 to n do if not t[j] then
        if d[j]<d[min] then min:=j;
      if d[min]>sum then sum:=d[min];
      t[min]:=true;
      for j:=1 to b[min] do if not t[f[min,j]] then
        if a[f[min,j]]+d[min]<d[f[min,j]] then d[f[min,j]]:=d[min]+a[f[min,j]];
    end;
  write(sum);
end.
```

---

## 作者：Mr_Dolphin (赞：4)

# 最短路好！
看到大佬们用一个优先队列解决了问题，看不太懂，蒟蒻这里用简单一点的最短路。希望能帮到和我一样看不懂其他题解的蒟蒻们。
# 思路
[题目传送门](https://www.luogu.com.cn/problem/P1882)  
看完题目后很容易发现：每头牛的起跑时间为 **从牛 1 开始把通知传到他的最小时间** 。所以，可以把每头牛看作节点，每个通知看作边，那么边权就是发通知的牛跑圈所需的时间。然后做个最短路，每头牛跑完时间为牛 1 到他的最短路 + 这头牛的跑圈时间。求最大即可。
# 代码实现
 dij 即可（毕竟没负权边）。  
注意，用链式前向星的（比如本蒟蒻），边要开到 $1e6$ ，而不是 $1e3$ 。（蒟蒻在这里被卡了五分钟 QAQ ）。  
附上蒟蒻代码
```cpp
#include <bits/stdc++.h>
#define pa pair<int,int>
#define maxn 1000001
using namespace std;
int mxn, n, m, l[maxn], d[maxn], used[maxn], head[maxn], nxt[maxn * 2], to[maxn * 2], v[maxn * 2], cnt;
priority_queue< pa, vector<pa>, greater<pa> > pq;

void add(int x, int y, int z) {
	to[++cnt] = y;
	nxt[cnt] = head[x];
	head[x] = cnt;
	v[cnt] = z;
}

void dij(int s) {
	d[s] = 0;
	pq.push(make_pair(d[s], s));
	while (pq.size()) {
		pa dt = pq.top();
		pq.pop();
		if (used[dt.second]) {
			continue;
		}
		used[dt.second] = 1;
		for (int i = head[dt.second]; i; i = nxt[i]) {
			int y = to[i], z = v[i];
			if (d[y] > d[dt.second] + z) {
				d[y] = d[dt.second] + z;
				pq.push(make_pair(d[y], y));
			}
		}
	}
}

int main() {
	scanf("%d", &n);
	for (int j = 1; j <= n; j++) {
		scanf("%d%d", &l[j], &m);
		for (int i = 1; i <= m ; i ++ ) {
			int  b;
			scanf("%d", &b);
			add(j, b, l[j]);
		}
	}
	for (int i = 1; i <= n ; i ++ )
		d[i] = 2000000000;
	dij(1);
	for (int i = 1; i <= n ; i ++ ) {
		mxn = max(mxn, d[i] + l[i]);
	}
	printf("%d", mxn);
	return 0;
}
```
建立美好洛谷，杜绝抄袭。  
有问题请私信

---

## 作者：王奕瑜 (赞：2)

## 算法：$\text{STL}$堆
- **前言**：**极力吐槽**这道题的描述（比如说“**气垫线**”是啥意思$QwQ$）

----------

- 请注意这句话：“**可能出现多只奶牛通知同一只奶牛起跑的情况，但是每一只奶牛只愿意跑一圈，所以它被第二次叫到的时候就不愿意再跑了。**”，这句话就告诉我们，当有多头牛通知一头牛跑时，肯定是**总用时最短**的那头牛先通知这头牛跑，~~自然而然的就想到~~，我们可以用$\text{STL}$里面的**堆**来维护，即**优先队列**$\text{priority\_queue}$。
- 那么具体怎么做呢？可以用一个**类似于**$\text{BFS}$**的方法**解决：
- $1.\quad$定义一个堆$q$，堆里的每一个元素是一个结构体$\{id,t\}$，分别代表这是第$id$头牛，当前总用时为$t$；
- $2.\quad$将$\{1,0\}$先放入堆，$vis$值变为$1$；
- $3.\quad$每次取堆顶$tp$，弹出，枚举它要通知的牛$i$，若这头牛没有跑（即$vis=0$），则将$\{i,tp_t+i_t\}$放入堆；
- $4.\quad$重复步骤$3$，每次与$ans$取最大值，直到堆为空。
- 最后，提醒各位要**重载小于号**，注意$\text{STL}$堆是大的优先，重载时**要反过来写**，具体看代码。

----------

### 代码
```cpp
#include <cstdio>
#include <queue>
using namespace std;
void in(int &n){//快读
    n=0;int f=1;char c=getchar();
    while (c<'0'||'9'<c){if (c=='-')f*=-1;c=getchar();}
    while ('0'<=c&&c<='9'){n=n*10+(c-'0');c=getchar();}
    n*=f;
}
struct Node{
    int id,t;//id与t同上文解释
    bool operator <(const Node &a) const{//重载小于号
        return t>a.t;
    }
};
int a[1005],b[1005],c[1005][1005];
//a为题目中的L,b为题目中的M
//c存储第i头牛要通知的牛
bool vis[1005];//标记有没有跑
int main()
{
    priority_queue <Node> q;//步骤1：定义STL堆
    int n;in(n);//读入
    for (int i=1;i<=n;i++){//读入
        in(a[i]),in(b[i]);
        for (int j=1;j<=b[i];j++)in(c[i][j]);
    }
    //步骤2
    Node tmp;tmp.t=a[1],tmp.id=1;
    q.push(tmp);vis[1]=1;
    int ans=0;//ans初始化为0
    while (!q.empty()){
        Node tp=q.top();q.pop();//取堆顶并弹出
        ans=max(ans,tp.t);//比较取最大值
        for (int i=1;i<=b[tp.id];i++){
            if (vis[c[tp.id][i]])continue;//访问过了就不做
            vis[c[tp.id][i]]=1;//标记
            Node tmp;tmp.t=tp.t+a[c[tp.id][i]],tmp.id=c[tp.id][i];
            q.push(tmp);//将新的节点放入堆
        }
    }
    printf ("%d",ans);//输出
    return 0;
}

``````

-----------

### 广告
- 推荐一下这位同学的博客（因$yzc$本人要求，已将**巨佬**改为**蒟蒻**）：
- $1. $[$yzc$**蒟蒻**的博客](https://www.luogu.com.cn/blog/ytxnqwl/)


---

## 作者：hibiki (赞：2)

这道题可以用BFS来更新节点，再用堆来保证每次取出的节点一定是开始跑得时间最快的，不断更新直到堆空即可。

虽然题目里没有说，但是题目保证有解。

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
#define MAXN 1000
using namespace std;
struct road{
    int next,tv;
}roads[MAXN*MAXN+10];
int list[MAXN+10];
int cnt=0;
int ans;
int l[MAXN+10];
bool flag[MAXN+10];
struct node{
    int st,pos;
};
struct cmp{
    bool operator() (node a,node b){
        return a.st>b.st;
    }
};
priority_queue<node, vector<node>,cmp> q;
int mint[MAXN+10];
int h=1;int t=1;
int n;
int add(int u,int v){
    cnt++;
    roads[cnt].tv=v;
    roads[cnt].next=list[u];
    list[u]=cnt;
}
int main(){
    memset(mint,0x3f,sizeof(mint));
    scanf("%d",&n);
    int x,y;
    for (int i=1;i<=n;i++){
        scanf("%d%d",&l[i],&x);
        for (int j=1;j<=x;j++){
            scanf("%d",&y);
            add(i,y);
        }
    }
    node nd;
    nd.pos=1;
    nd.st=0;
    q.push(nd);
    mint[q.top().pos]=0;
    while(!q.empty()){
        if (q.top().st>mint[q.top().pos]){
            q.pop();
            continue;
        }
        int w=list[q.top().pos];
        int nt=q.top().st+l[q.top().pos];
        ans=max(ans,nt);
        while (w){
            if (nt<mint[roads[w].tv]){
                t++;
                node nd;
                nd.pos=roads[w].tv;
                nd.st=nt;
                q.push(nd);
                mint[roads[w].tv]=nt;
            }
            w=roads[w].next;
        }
        q.pop();
    }
    printf("%d",ans);
}
```

---

## 作者：_•́へ•́╬_ (赞：0)

### 用$stl$的优先队列做小根堆。
### 我用了二元组，第一个位置保存时间，第二个位置保存编号。
```cpp
#include<stdio.h>
#include<queue>
#include<vector>
#define pr pair<int,int> 
using namespace std;
inline int read()//快读
{
	register int x=0;register char c=getchar();for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=getchar());return x;
}
int n,l[1001],m,ans;vector<int>a[1001];
priority_queue<pr,vector<pr>,greater<pr> >q;bool v[1001];
main()
{
	n=read();
	for(register int i=1;i<=n;++i)
	{
		l[i]=read();
		m=read();
		for(;m--;)a[i].push_back(read());
	}
	//=====以=====上=====均=====为=====输=====入=====
	v[1]=1;q.push(pr(l[1],1));
	for(register pr now;--n/*n头牛，循环n-1次，最后一头牛单独处理*/;)
	{
		now=q.top();//获取堆顶
		q.pop();//堆顶的那头牛跑完了，ヾ(￣▽￣)Bye~Bye~
		for(register int i=0;i<a[now.second].size();++i)
			if(!v[a[now.second][i]])//抓到一头没跑过的牛
			{
				v[a[now.second][i]]=1;//跑
				q.push(pr(now.first+l[a[now.second][i]],a[now.second][i]));//塞到堆里
			}
	}
	//=====以=====下=====均=====为=====输=====出=====
	printf("%d",q.top().first);
}/*感觉整个过程像bfs*/
```

---


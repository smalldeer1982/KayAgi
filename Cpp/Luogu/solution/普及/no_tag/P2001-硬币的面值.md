# 硬币的面值

## 题目描述

小 A 有 $n$ 种硬币，现在要买一样不超过 $m$ 元的商品，他不想得到找钱（多脏啊），同时又不想带太多的硬币，且硬币可以重复，现在已知这 $n$ 种硬币的价值，请问最少需要多少硬币就能组合成所有可能的价格？


## 说明/提示

【数据范围】

只有 9、10 会卡人，放心贪

对于 $20\%$ 的数据，$1 \le n \le 10$，$1 \le m \le 100$。  
对于 $60\%$ 的数据，$1 \le n \le 1000$，$1 \le m \le 10000$。  
对于 $80\%$ 的数据，$1 \le n \le 30000$，$1 \le m \le 2 \times {10}^9$。  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le m \le 2^{63}$。


## 样例 #1

### 输入

```
5 31
1 2 8 4 16
```

### 输出

```
5
```

# 题解

## 作者：kkksc03 (赞：43)

本题需要在明白思路的情况下再次进行优化。

当然需要进行排序，无解的情况就是最小值不为1，那因为这样的话永远得不到价格为1的。

以下的情况都是基于排序之后的情况讨论的。

首先是O(M)的算法，我们先假设1~x的价格都可以得到，那么设a[i]是小于x+2的最大整数，可知1~x+a[i]都价格都可以完成，同时硬币数量加一。这样如果常数优化好的话可以通过前8个测试点，第9,10个会超时（如果这个都能通过那就让人对洛谷神机无语了）。

其次是O(NlogN)的算法，我们发现算法一中的很多都有冗余，因为在i加1之前的运算可能会重复多次，所以我们用div进行这一项操作。这样贪心部分算法时间复杂度仅为O(N)，可以轻松通过全部数据。


---

## 作者：King丨帝御威 (赞：24)

看着这道题题解就一道，想必大家是都没有思路，所以，想给大家提供点思路，但是下面的代码要吸氧才能过，请多多指教！
举个例子假设1、3、5，要组成10的面额，开始值为
0，所以取1 -> 然后组成最大值为1，为了组成2，
还是要取1 -> 最大值为2，此时大于等于面额3的硬
币-1，所以选3 -> 此时最大值为5 ，大于等于5的面
额-1 ->最大值变为了10，等于n，结束。。所以举的
例子最少选4个硬币。

## 思路：没有面额为1的直接输出No answer!!!，否则就取当前能取的最大值。
下面是代码：
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#define re register
#define ll long long
using namespace std;
ll n,m,sum,ans,a[2000001];          //硬币数组
inline ll qread()
{
	char c=getchar();ll num=0,f=1;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) num=num*10+c-'0';
	return num*f;
}                
int main()
{
    n=qread(),m=qread();
    for(re int i=1;i<=n;++i)
    a[i]=qread();   
    a[n+1]=m;                   
    sort(a+1,a+1+n+1);             //让硬币从小到大排序，为的是下面的判断。。
    if(a[1]!=1)                 
    {
        printf("No answer!!!\n");   //没有面额为1的直接输出No answer！！！
        return 0;                   //直接退出程序。
    }
    for(re int i=1;i<=n;++i)
    {
        while(sum<a[i+1]-1)          //取最大值，看不懂的话上面有例子。
        {
            sum+=a[i];
            ans++;                    //计数器。
            if(sum>=m)
            {
                printf("%lld\n",ans);    //输出硬币数，直接退出程序。
                return 0;
            }
        }   
    }
    cout<<ans+1<<'\n';           //不然的话输出ans+1。 
    return 0;
}
```

---

## 作者：pikabi (赞：15)

其实这道题就按照题面意思直接模拟一下就好喇！

很显然如果给定硬币的最小值大于1则输出"No answer!!!"因为这样子就无法取到1这个面值了。

先证明一下这一点：如果目前状态可取前 $x$ 价格，且当前取了一个面额为 $a$ 的硬币，要想构成前 $x + a$ 的所有价格，必须仅当 $x \ge a - 1$ 时成立--->

证：若 $x < a - 1$， 则我们取最小的 $x + 1$，它必须由 $x + 1 - a$ 得到，而 $x < a - 1$,故 $x + 1 - a < 0$,由于不存在小于0的状态，故原命题成立。

假设当前状态，前 $i$ 种硬币已经用最小的硬币数 $ans$ 构成最大的可行价格 $tot$ ，那么如果当前 $tot \ge a_{i + 1} - 1$，那么就可以直接 $i + +$；否则累加，使 $tot = tot + a_{i}$ 至 $tot \ge a_{i + 1} - 1$ ， 同时每次 $ans$ $+$$+$ 。因为我们在每一步都满足 $tot \ge a_{i + 1} - 1$ ， 所以每次 $i++$ 时，我们都可以放心操作当前的 $tot + a_{i}$ 操作。特别的，当 $i$ 等于1时，如果  $tot(=0) < a_{1} - 1$ , 即 $a_{1} > 1$时，不能满足条件，因而无答案，这里解释了第二段的显然结论。

关于这个累加，由于数据范围很大，我们很容易被卡（如都是1），所以我们先算出 $tot$ 加上多少个 $a_{i}$ 才能大于等于 $a_{i + 1}$，即个数 $k = (a_{i + 1} - 2 - tot) \div a{i} + 1$ ，再 $tot = tot + k * a_{i}$，$ans = ans + k$， 用  O（1）的时间解决了问题。同时我们把 $a_{n + 1}$ 赋值为 $m$ , 助于判停。

最后注意一点：如果 $tot$ 刚好等于 $m - 1$ ，并结束了循环，此时我们要在循环外输出 $ans + 1$ , 以应对此特殊情况。 

下面我来贴一下代码--->

```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
#define inf 1023456789

using namespace std;

ll n, m, a[2000005], ans, tot;

int main(){
	scanf("%lld%lld",&n,&m);
	for(int i = 1; i <= n; i++)
		scanf("%d",&a[i]);
	sort(a + 1, a + n + 1);
	if(a[1] != 1) {
		printf("No answer!!!\n");
		return 0;
	}
	a[n + 1] = m;
	for(int i = 1; i <= n; i++){
		if(tot < a[i + 1] - 1){
			ll k = (a[i + 1] - 2 - tot) / a[i] + 1;
			tot += a[i] * k;
			ans += k;
			if(tot >= m){
				printf("%lld\n",ans);
				return 0;
			}
		}
	}
	printf("%lld\n",ans + 1);
	return 0;
} 
```


---

## 作者：nanzjz1 (赞：7)

~~一开始以为是简单的背包题，结果看了数据范围发现是奇（du）妙（liu）的贪心题~~

## 题目描述
小A有 $n$ 枚硬币，现在要买一样不超过 $m$ 元的商品，他不想得到找钱（多脏啊），同时又不想带太多的硬币，且硬币可以重复，现在已知这 $n$ 枚硬币的价值，请问最少需要多少硬币就能组合成所有可能的价格？

## 题意转化
给出 $n$ 个正整数 $a_1,a_2,a_3,…,a_n$ 及正整数 $m$。若能够从 $a_1,a_2 , a_3 , … , a_n$ 中选取 $t$ 个数 $b_1,b_2,b_3,…,b_t$（同一个数可选多次），使得对于 $[1,m]$ 内的任意一个正整数，都能表示为 $b_1,b_2,b_3,…,b_t$ 中某几个数之和，则输出 $t$ 的最小值；若不能，输出```No answer!!!```。

## 算法分析
首先，我们用数组 $value$ 存储下每一个值。考虑到 $m$ 的最大值达到 $2^{63}$，使用背包 dp 会超时，因此思考贪心做法的可能性。显然能拼出的数的范围由这些数的最小值决定（拼出的最小的数大于等于这 $n$ 个数的最小值），若最小值超过 $1$ 肯定不能把 $1$ 拼出来。于是我们有了第一步：

```cpp
sort(value+1,value+1+n);
if(value[1]!=1)
{
   printf("No answer!!!");
	return 0;
}
```
那么这样一来，答案就分为两种情况：

- 最小值为 $1$：有解，且需要的数的个数 $t$ 的值在 $[1,m]$ 范围内；
- 最小值大于 $1$： 无解，输出```No answer!!!```。

接着，在已经从小至大排序完的基础上，我们尝试将问题转化为多个子问题。假设目前能够拼出 $[1,maxm]$ 范围内的所有值，至少需要 $num$ 个数，那么对于最大的小于等于 $maxm+1$ 的 $value[i]$，可以推出拼出  $[1,maxm+value[i]]$ 的所有值至少需要 $num+1$ 个数。推导如下：

- 对于 $[1,maxm]$ 内的所有值，显然至少需要 $num$ 个数；
- 对于 $[maxm+1,maxm+value[i]]$ 内的所有值，我们可以先拼出 $[maxm+1-value[i],maxm]$ 内的所有值，至少需要的数的个数小于等于 $num$，然后在此基础上再加上数 $value[i]$ 即可，至少需要的数的个数小于等于 $num+1$。

然后，考虑到 $i=n$ 的时候不存在 $value[n+1]$，但是可以理解为此时的 $value[n+1]$ 为 $m$，即此时的任务是将 $maxm$ 不断增加直到它大于等于 $m-1$（即 $value[n+1]-1$）。

最后，考虑到可能出现 $maxm=m-1$ 的情况使得最后一次没有执行 ```num++``` 的操作而直接跳出循环，我们在循环结束后补上一次。

全部代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long value[2000010];
int main()
{
    long long n,m;scanf("%lld%lld",&n,&m);
    //下面可以考虑使用快读
    for(register int i=1;i<=n;++i)
    {
        scanf("%lld",&value[i]);
    }
    value[n+1]=m;//引入m
    sort(value+1,value+1+n);
    if(value[1]!=1)
    {//特判最小值不为1的情况
        printf("No answer!!!");
        return 0;
    }
    long long maxm=0,num=0;
    for(register int i=1;i<=n;++i)
    {
        for(;maxm+1<value[i+1];)
        {//如果maxm不够大就加上value[i]
            maxm+=value[i],++num;
            if(maxm>=m)
            {//如果没走到最后一步就能拼出m，结束程序
                printf("%lld",num);
                return 0;
            }
        }
    }//特殊情况补充
    printf("%lld",num+1);
    return 0;
}
```
但很可惜，这份代码由于超时只能得到 80pts。
## 优化 使用乘法优化累加
### 第一版
我们考虑到，对于这样的数据
```cpp
5 9223372036854775808
1 3 5 7 9
```
由于 $value[n]$ 与 $m$ 差值极大，导致程序很可能卡在最后一步不得动弹，因此我们在循环中加入一个特判：
```
if(i == n)
{
	num+=(m-maxm)/value[i];//计算差的个数
	if((m-maxm)%value[i])++num;
	printf("%lld",num);
	return 0;
}
```
事实上，这种程度的简单优化就能够 AC 本题~~（也反映出数据的放水）~~
### 第二版
由上一部分的思路，我们不难想到，既然可以让最后一个卡住，自然也能让中间的几个卡住，比如说这组数据：
```cpp
2 281474976710656
1 281474976710655
```
因此结合上面的思路，我们可以让每一部分累加都改为累乘：
```cpp
for(register int i=1;i<=n;++i)
    {
        if(maxm+1<value[i+1])
        {
            long long gjr=(value[i+1]-2-maxm)/value[i]+1;//计算差的个数
            maxm+=value[i]*gjr,num+=gjr;
            if(maxm>=m)
            {
                printf("%lld",num);
                return 0;
            }
        }
    }
```
以上代码可以轻松 AC 本题。
### 小补充
本题中并未给出每枚硬币的最大值，笔者做题时默认了每枚硬币面值均不超过 $m$。但是，由于题目并未严格规定，如果面对这组数据：
```cpp
5 20
1 999 1000 1001 1002
```
那么所有上面使用的乘法优化将会导致一个错误的答案，而第一版的不完全优化反而能得出正确答案。

只需要加入两个小小的改动，就能让这份代码在硬币面值超过价格时也适用：
```
//sort(value + 1, value + 1 + n);
//改为
sort(value + 1, value + 2 + n);

```
```cpp
for (register int i = 1; i <= n; ++i)
    {	
    	//加入
        value[i+1]=value[i+1]>m?m:value[i+1];
        if (maxm + 1 < value[i + 1])
        {
            long long gjr = (value[i + 1] - 2 - maxm) / value[i] + 1;
            maxm += value[i] * gjr, num += gjr;
            if (maxm >= m)
            {
                printf("%lld", num);
                return 0;
            }
        }
    }
```
完整代码：[篇幅受限 放在链接里面了](https://www.luogu.com.cn/paste/th62qpdg)








---

## 作者：flyfree (赞：6)

其实这题一开始我并没有思路，看完题解以后才明白，不过经过思考之后发现其中大有文章（~~其实是我太菜了所以都没想到~~）。

一开始，我认为答案是**凑出每种价格需要的最少硬币组合**取一个并集。

这个思路看似正确（~~困扰了我好久~~），其实完全不对。它最后的答案是累计的，是凑出所有<=m的价格所需要的最少的硬币数量。也就是说，是**单增**的。

用一个例子来说明：假设有面值为1,3,4三种硬币，m=6.

如果按我的思路，凑1用一个1，凑2用2个1，凑3用1个3，凑4用1个4，凑5用1、4，凑6用3、3，那么最终取并集的总硬币数量就是5.

容易发现，只要凑6用4、1、1，最终结果就是4。（当然按照正解还需要改：凑4用1、3，凑5用3、1、1）

也就是说，局部最优并不能保证最终结果最优。

那么，我们就会~~自然地~~想到，凑一个值，要尽可能地用之前已经凑出来的值，因为这样就不会使答案增加。

最终的做法其他题解都已经很清楚了，不再赘述。那么这个做法为什么是对的呢？（dalao自动跳过，~~在我思考了半天之后突然发现这东西其实很显然~~）

先上一个80分的代码，便于理解

```
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=2000002;
long long m,n,a[N],ans,now,x;
long long read()
{	char x=getchar();
	while(x<48||x>57) x=getchar();
	long long ans=0;
	while(x>=48&&x<=57)
	{	ans=(ans<<1)+(ans<<3)+(x^48);
		x=getchar();
	}
	return ans;
}
int main()
{	n=read();m=read();
	for(int i=1;i<=n;i++)
	a[i]=read();
	sort(a+1,a+n+1);
	if(a[1]!=1)
	{	printf("No answer!!!\n");return 0;}
	ans=now=1;x=1;
	while(now<m)
	{	while(a[x]<=now+1&&x<=n) x++;
		x--;ans++;now+=a[x];
	}
	printf("%lld\n",ans);
	return 0;
}
```

假设我们现在已经用ans个硬币凑出了1~now的所有价格，这是对于凑出1~now+a[i]的价格，最终答案应该是ans+1。（a[i]为<=now+1的最大硬币面值）

这时候的now，一定是满足"能用ans个面值<=a[i]的硬币凑出1~now的所有价格"的所有now的最大值。

设凑出1~now+a[i]的所有价格所需要的最少硬币数量为y,由于now最大，那么想要凑出1~now+a[i]的所有价格，肯定需要最少ans+1个硬币。也就是说，y>=ans+1.

如果加一个面值为a[i]的硬币，把>=now+1的每个价格拆成z+a[i] (now+1-a[i]<=z<=now)，显然能凑出1~now+a[i]的所有价格。也就是说，y<=ans+1.

所以y=ans+1.

而now这时候为什么一定是最大的呢？首先，最开始的初始化，ans=now=1,这时候的i应该是等于1的，也就是说，用一个<=a[1]的硬币只能凑出1~1的价格。这时的now显然是最大的。对于后面，每次都给now+a[x]，ans++。由于加了一个面值为a[x]的硬币，所以给之前所有情况都+a[x]即可。为了使now与a[x]衔接起来，a[x]<=now+1.为了让结果最优，x要在满足a[x]<=now+1的基础上最大（排完序）。因此，now一直都是最大的。

AC代码也没什么新东西，放一下啦

```
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=2000002;
long long m,n,a[N],ans,now,x;
long long read()
{	char x=getchar();
	while(x<48||x>57) x=getchar();
	long long ans=0;
	while(x>=48&&x<=57)
	{	ans=(ans<<1)+(ans<<3)+(x^48);
		x=getchar();
	}
	return ans;
}
int main()
{//	freopen("1.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=n;i++)
	a[i]=read();
	sort(a+1,a+n+1);
	a[n+1]=m+1;
	if(a[1]!=1)
	{	printf("No answer!!!\n");return 0;}
	x=1;
	for(int i=1;i<=n;i++)
	{	if(a[i+1]<=now+1&&i<n) continue;
		x=(a[i+1]-1-now)/a[i]+((a[i+1]-1-now)%a[i]>0);
		ans+=x;now+=x*a[i];
		if(now>=m) break;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Tgotp (赞：6)

思路就是贪心

一开始肯定能拼1，所以1-1是可以的，然后就找最小的a【i】>x+1，然后一直推，从而求解，注意是long long

主要是没代码，来贴一份代码。

c++代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N = 2e6 + 5;
long long n,m,a[N];
long long read()
{
    char c;c=getchar();
    while(c<'0'||c>'9')
    {
        c=getchar();
    }
    long long sum = 0;
    do
    {
        sum=sum*10+c-'0';
        c=getchar();
    }while(c<='9' && c>='0');
    return sum;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    sort(a+1,a+n+1);
    if(a[1]!=1)
    {
        cout<<"No answer!!!";
        return 0;
    }
    long long p=1,x=1;
    for(int div=1;div;div++)
    if(a[div] > x+1 || div>n)
    {
        div--;
        if(x>=m)
        {
            cout<<p;
            return 0;
        }
        if(div == n)
        {
            p+=(m-x)/a[div];
            if((m-x)%a[div])p++;
            cout<<p;
            return 0;
        }
        while(a[div+1] > x+1 && x<m)
        {
            x+=a[div];
            p++;
        } 
    }
}
```

---

## 作者：ShineEternal (赞：5)

# 写在前面：如下获得更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/847268150),如有任何疑问，欢迎私信作者！
# 题目链接：https://www.luogu.org/problemnew/show/P2001
~~这题的数据范围吓得我很慌。~~ 

# 分析：
这道题蒟蒻本来想用背包的，但是发现m太大，一写肯定炸，然后看到数据范围表示成了$2^{63}$,马上想到了可以二进制转化一下，然后又写炸了（~~我太弱了~~ ），只能换成如下思路，

# 代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
long long n,m,sum,ans,a[2000001];      //都打成ll保险！        
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;++i)
    scanf("%lld",&a[i]);
    a[n+1]=m;                   
    sort(a+1,a+1+n+1);            
    if(a[1]!=1)//排序后没有1？骗谁，连1都表示不出来了，没答案！                 
    {
        printf("No answer!!!\n");   
        return 0;     
    }
    for(int i=1;i<=n;++i)
    {
        while(sum<a[i+1]-1) //贪心的思想        
        {
            sum+=a[i];
            ans++;           
            if(sum>=m)
            {
                printf("%lld\n",ans);  
                return 0;
            }
        }   
    }
    printf("%lld\n",ans+1);最后别忘了＋1,
    return 0;
}
```



---

## 作者：ALIN_lin (赞：4)

其实这道题可以按照题面意思直接模拟一下来写。
 
假设我们现在已经用 $ans$ 个硬币凑出了 $1 \sim now$ 的所有价格，这是对于凑出 $1 \sim now + a_i$ 的价格，应该是 $ans + 1$。$a_i$ 为 $\le now + 1$ 的最大硬币面值。

这时候的 $now$，一定是满足“能用 $ans$ 个面值 $\le a_i$ 的硬币凑出 $1 \sim now$ 的所有价格”的所有 $now$ 的最大值。

假设凑出 $1 \sim now + a_i$ 的所有价格所需要的最少硬币数量为 $y$，由于 $now$ 最大，那么想要凑出 $1 \sim now + a_i$ 的所有价格，肯定需要最少 $ans+1$ 个硬币。也就是说，$y \ge ans +1$。

如果加一个面值为 $a_i$ 的硬币，把 $\ge now+1$ 的每个价格拆成 $z+a_i$（$now +1- a_i \le z \le now$），就能凑出 $1 \sim now + a_i$ 的所有价格。所以 $y \le ans +1$。

首先，最开始的初始化，`` ans = now =1 ``,这时的 $i$ 是等于 $1$ 的，也就是用一个 $\le a_1$ 的硬币只能凑出 $1 \sim 1$ 的价格。这时的  $now$ 就是最大的。对于后面，每次都给 `` now + a[x],ans ++ ``。由于加了一个面值为 $a_x$ 的硬币，所以给之前所有情况都 $+ a_x$ 即可。为了使 $now$ 与 $a_x$ 衔接起来，$a_x \le now +1$。之所以 $x$ 要在满足 $a_x \le now + 1$ 的基础上最大（排完序），是为了让结果最优。因此，$now$ 一直都是最大的。

~~代码仅供学习参考使用，禁止抄袭。~~

AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5;
long long n,m,a[N];
long long read(){
	char c;c=getchar();
	while(c<'0'||c>'9'){
		c=getchar();
	}
	long long sum = 0;
	do{
		sum=sum*10+c-'0';
		c=getchar();
	}
	while(c<='9' && c>='0');
	return sum;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++)
	a[i]=read();
	sort(a+1,a+n+1);
	if(a[1]!=1){
		cout<<"No answer!!!";
		return 0;
	}
	long long p=1,x=1;
	for(int div=1;div;div++){
		if(a[div] > x+1 || div>n){
			div--;
			if(x>=m){ 
				cout<<p;
				return 0;
			}
			if(div == n){
				p+=(m-x)/a[div];
				if((m-x)%a[div])p++;
				cout<<p;
				return 0;
			}
			while(a[div+1] > x+1 && x<m){
				x+=a[div];
				p++;
			} 
		}
	}
	return 0;
}
```

---

## 作者：pipiispig (赞：3)

看了下发现其他题解都是模拟，时间复杂度都较大，这里分享一个时间复杂度为o(n)的方法,除去打表以外应该是最优解法了，当然也可以再加上玄学优化QwQ;
首先我们把题意理解为要找出一个含最小元素个数的集合，使得这个集合的元素可以组成任意1<<k<<m的数；所以我们很容易可以想到要用小的元素构成较大的元素-1后的值，以此类推，有点类似于dp，P.S.（但是如果单纯的用背包来做会超时，应该是80分）,所以我们可以先排个序，如果集合中最小元素不是1的话，我们便可以直接输出“No answer!!!”这个相信很容易理解，其次，我们便可以进行n次的模拟，以此形成正确的贪心；
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
long long s[1000001];
inline long long read(){
	long long f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}//快读赛高！
int main(){
	std::ios::sync_with_stdio(false);//优化1
	long long n=read(),m=read();
	for(int i=1;i<=n;i++)s[i]=read();
	std::sort(s+1,s+n+1);
	if(s[1]!=1){
		cout<<"No answer!!!";
		return 0;
	}//如果最小不是1的话肯定不可以形成所有的数；
	long long ans=0,cnt=0,w=0;
	s[n+1]=m;
	for(int i=1;i<=n;i++){
		if(s[n]>m){
			ans+=ceil((m-cnt-1)/s[i]);
		}
		w=0;
		if(s[i+1]-1>cnt)w=ceil(double(s[i+1]-cnt-1)/s[i]);//ceil就是向上取整，也可以用%;
		ans+=w,cnt+=s[i]*w;
	}
	if(cnt<m)ans++;//这里应该是最难理解的地方了，不加这句的话可以过9个点，hack的话其实挺容易想的，如果集合中有元素和m值相等，就可以轻易hack,但其实蛮不好想的；可以试试去掉这句话和不去掉这句话的区别，hack数据：2 2 1 2；
	cout<<ans<<endl;

}
```

---

## 作者：jomy (赞：2)

蒟蒻第一次发题解，如若做的不好请神犇们批评。

[题目传送门](https://www.luogu.com.cn/problem/P2001)

[博客，阅读体验++](https://www.luogu.com.cn/blog/jomy201314/solution-p2001)

## 简要的前面部分

前面部分主要就是排完序过后的 “No answer!!!”。主要看他 $a[0]$ **是否成立**，成立就是没有 $1$，就是 “No answer!!!”，因为如果没有了 $1$，$1$ 元的价格无法支付；不成立的话，还可以用想要的数枚$1$元硬币支付。

# 重要部分

假设 $1 \sim s$ 的**所有数都可以枚举出来，我们再加入一个 $x$ 元硬币，这个硬币如果满足 $x-1 \le g($ 总钱数 $)$,我们就可以让 $1 \sim x+g $ 都满足。**

# 万众期待的代码环节

~~我知道大家只看这个~~。

话不多说，放代码$:$

```
#include<iostream>
#include<cmath>
#include<algorithm>
#define l long long int//m 的数据范围需要 long long。
using namespace std;
l a[200005];//硬币数组。
int main(){
	l n,m,g=1,i=1;//g、i 分别表示能够凑成的 1~g，硬币数量。
	cin>>n>>m;
	for(int b=0;b<n;b++){
		cin>>a[b];
	}
	sort(a+0,a+n);//排序。
	if(a[0]!=1){//简单 "No answer!!!" 判断。
		cout<<"No answer!!!";
		return 0;
	}
	for(int b=0;b<n;b++){
		if(b<n-1){
			if(a[b+1]-1<=g){
				if((a[b+2]-1>g&&b<n-2)||b==n-2){//在符合条件 a[b+1]-1<=g 的情况下最优。
					++i;
					g+=a[b+1];
				}
				else{
					while(a[b+2]-1<=g&&b<n-2){
						b++;//不是最优，寻找最优。
					}
					++i;
					g+=a[b+1];
				}
			}
			else{
				while(a[b+1]-1>g){
					i++;
					g+=a[b];//无解，再拿一枚原硬币。
				}
			}
		}
		else{
			i+=ceil((m-g)/1.0/a[b]);//没有这部分 = 超时，我从其他题解看到的。
		}
		if(g>=m) break;//如果“达标”就退出循环。
	}
	cout<<i;
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 题意描述：

有 $n$ 种面值的硬，每种硬币的数量无限，现在要买一个不超过 $m$ 元的商品，求最少需要多少硬币，如果无解请输出 ``No answer!!!``。

### 思路：

可以采用贪心算法来解决这个问题，具体思路如下：

1. 将硬币面值从大到小排序。

2. 从大到小枚举硬币面值，每次尽可能多地选择这种面值的硬币。

3. 直到余额小于当前硬币面值，转到下一种硬币面值。

证明这种算法的正确性并不容易，但是可以通过以下的例子来说明这种算法的正确性。

假设有三种硬币：$1,3,4$。

现在要凑出 $6$ 元，如果采用贪心算法，首先选择一枚面值为 $4$ 的硬币，剩下 $2$ 元需要用硬币凑出。

这时可以选择两枚面值为 $1$ 的硬币。

并不是所有的硬币问题都可以采用贪心算法来解决，但是有些硬币问题确实可以采用贪心算法来解决。

### 复杂度分析：

那么时间复杂度为 $O(n \log n)$，空间复杂度为 $O(n)$。

具体分析如下:

1. 排序的时间复杂度为 $O(n \log n)$。

2. 最多有 $m$ 轮循环, 每轮循环的时间复杂度为 $O(1)$（毕竟可以直接整除一下嘛，不必要一个一个的减去）。

### 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2000200;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,k,f,a[N];
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;++i)
      a[i]=read();   
    a[n+1]=m;                   
    sort(a+1,a+n+2);
    if(a[1]!=1){
        puts("No answer!!");
        exit(0);
    }
    for(int i=1;i<=n;i++){
        if(k<a[i+1]-1){
            int t=(a[i+1]-2-k)/a[i]+1;
            k+=a[i]*t;
            f+=t;
            if(k>=m){
                write(f);
                return 0;
            }
        }
//      误犯： 
//        while(k<a[i+1]-1){
//            k+=a[i];
//            f++;
//            if(k>=m){
//                write(f);
//                exit(0);
//            }
//        }   
    }
    write(f+1);
    return 0;
}
```
大家可以自己证明一下这个贪心的正确性啊！

---

## 作者：道费而隐 (赞：1)

## ~~这道题很毒瘤啊。。~~ 
### 题目描述
 _小A有n枚硬币，现在要买一样不超过m元的商品，他不想得到找钱（多脏啊），同时又不想带太多的硬币，且硬币可以重复，现在已知这n枚硬币的价值，请问最少需要多少硬币就能组合成所有可能的价格？ _ 

------------

首先,我们显然可以得出，如果没有面额为1的直接输出“No answer!!!”，因为这样的话永远得不到价格1。然后开始判断最少需要多少硬币。如果我们可以已经得到x以内的数，那么我们枚举硬币对应的价值a[i]，找到小于等于x+1的最大的数,不难发现，1~x+a[i]的价格都可以完成。所以我们令x=x+a[i]，ans++，然后当x>m时，输出ans就好了（记得开long long）
#### ~~找到这个规律就可以放心大胆地贪了~~
```cpp
#include<vector>
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<string>
#include<iomanip>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
typedef long long ll;
ll n,m,a[200005],q,x=1,ans=1,po;
inline ll read(){
    ll x=0,f=1;char ch=' ';
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+(ch^48);ch=getchar();}
    return f==1?x:-x;
}
int main(){
	//freopen("testdata.in","r",stdin);
	n=read();
	m=read();
	//cout<<m<<" ";
	for(ll i=1;i<=n;i++){
		a[i]=read();
		if(a[i]==1){
			q=1;
		}
	}
	if(q==0){
		cout<<"No answer!!!";
		return 0;
	}
	sort(a+1,a+n+1);
	while(1){
		po=upper_bound(a+1,a+n+1,x+1)-a-1;
		x+=a[po];
		ans++;
			if(x>=m){
			cout<<ans;
			return 0;
		}
	}
}
```
#### 然而光这样还不够，数据太毒瘤，炸了两个点...
 _~~经过dalao的指点，我豁然开朗~~  _ 
我们考虑当硬币已经取到最大值时用当前能达到的价值和m之间差（m-x）除以最大价值的硬币a[n],得到还需要几个硬币。
```cpp
#include<vector>
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<string>
#include<iomanip>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
typedef long long ll;
ll n,m,a[200005],q,x=1,ans=1,po=1;
inline ll read(){
    ll x=0,f=1;char ch=' ';
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+(ch^48);ch=getchar();}
    return f==1?x:-x;
}
int main(){
//	freopen("testdata.in","r",stdin);
	n=read();
	m=read();
	for(ll i=1;i<=n;i++){
		a[i]=read();
		if(a[i]==1){
			q=1;
		}
	}
	if(q==0){
		cout<<"No answer!!!";
		return 0;
	}
	sort(a+1,a+n+1);
	while(1){
		if(po==n){
			ans+=(m-x)/a[po];
			if((m-x)%a[po]!=0)ans++;
			cout<<ans;
			return 0;
		}
		for(int i=po;i<=n+1;i++){
			if(a[i]>x+1||i>n){
				po=i-1;
				x+=a[po];
				ans++;
				break;
			}
		}
			if(x>=m){
			cout<<ans;
			return 0;
		}
	}
}
```
#### 于是终于AC了

---


# 分队问题

## 题目描述

给定 $n$ 个选手，将他们分成若干只队伍。其中第 $i$ 个选手要求自己所属的队伍的人数大等于 $a_i$ 人。

在满足所有选手的要求的前提下，最大化队伍的总数。

注：每个选手属于且仅属于一支队伍。

## 说明/提示

对于 $20\%$ 的数据，$n \leq 10$。

对于 $40\%$ 的数据，$n \leq 1000$。

对于 $60\%$ 的数据，$n \leq 10000$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
5
2
1
2
2
3 
```

### 输出

```
2```

# 题解

## 作者：QuantAsk (赞：23)

# 表示贪心可以过

贪心的思想就是尽量将要求大的人放在一起。所以我们要先排个序，从大到小，然后用一个now表示当前队列还需多少个人可以满足条件 
初始代码：

```cpp
    now=a[1];
    for (int i=1;i<=n;i++)
    {
        now--;
        if (!now)
        {
            now=a[i];
            s++;
            w=false;
        }
    }
```

然后我们可以发现： 

8 

1 2 4 5 5 5 5 5

这一组数据中我们会将4归入第二个队列，导致第二个队列不成立，所以我们需要进行优化该情况。如果我们发现将目前在队列里的的归入前一个队列会更优的话我们就可以直接改变now



```cpp

#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[1000001],now,s,maxs;
bool w;
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	  scanf("%d",&a[i]);
	sort(a+1,a+1+n,cmp);
	w=true;//表示是否是第一个队列，如果是就不可以归入前一个队列了
    now=a[1];//从第一个开始
	for (int i=1;i<=n;i++)
	{
		if (a[i]<now&&!w)//比较
		{
			now=a[i];
		}
		now--;
		if (!now)//一个队列已经满足要求
		{
			now=a[i];
			s++;
			w=false;
		}
	}
	printf("%d",s);
}

```

---

## 作者：henry_y (赞：22)

[更多的dp题目练习点这里](https://www.cnblogs.com/henry-1202/p/9211398.html )


------------

首先看到这道题第一想法应该是贪心

这个贪心写法应该也很容易写，排序一遍，然后直接选就可以了

信心满满地提交，会发现WA掉前面两个点

这个贪心想法其实有一个很明显的错误

来一组数据 

4

2 3 3 3

贪心做法会输出2，但实际上应该输出1

所以这个贪心的想法是必须cut掉的，因为它没有考虑到分队时剩下来的人的a[i]对于队伍人数的限制

~~至于为什么还能水80分？应该是数据水吧~~

顺便说一下这是我校某次测评的题目啊，当时就写了这个贪心，然后挂的挺惨的

那么来想想dp做法

设$f[i]$表示前i个人能够分成的最大的队伍个数

从小到大排序一遍之后，显然可以发现，当第i个人可以加入这个队伍时，当且仅当
$i>=a[i]$

所以可以得到一个转移方程：$f[i]=max(f[k])+1(0<i<=a[i])$

但是这样对于百万级别的n是会超时的

考虑怎么去优化它

我们可以开一个数组来储存$f[1...n]$的最大值

则转移方程可以改成：$f[i]=g[i-a[i]]+1$

对于g数组的维护：$g[i]=max(g[i-1],f[i])$

这样就可以完成O(n)转移

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll int
#define inf 1<<30
#define il inline 
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll abs(ll x){return x>0?x:-x;}
il void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
il void read(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
il void print(ll x){if(x<0)putchar('-');x=abs(x);if(x>9)print(x/10);putchar(x%10+'0');}
il void writeln(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar('\n');}
il void write(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar(' ');}
using namespace std;
/*===================Header Template=====================*/
#define N 1000100
ll n,a[N],f[N],g[N];
int main(){
    read(n);
    for(ll i=1;i<=n;i++)read(a[i]);
    sort(a+1,a+n+1);
    for(ll i=1;i<=n;i++){
        if(i>=a[i])f[i]=g[i-a[i]]+1;
        g[i]=max(f[i],g[i-1]);
    }
    writeln(f[n]);
    return 0;
}
```

---

## 作者：Kdlyh (赞：12)

这道题可以用DP来做。

我们定义状态$f[i]$为**是当前的人数为$i$**时的队伍数量的最大值。而**$i$同时也代表现在是第几个人**。

根据题意。我们可以推出转移方程

- 当$i<a[i]$时：    $f[i]=f[i-1]$				

  - **当前队伍中的人数$i$**不大于$a[i]$时,我们显然不能让**第$i$个选手**自己组成一个队伍，只能让**第$i$个选手**加入之前的队伍。

- 当$i>=a[i]$时： $f[i]=max(f[i-1],f[i-a[i]]+1)$ 

  - **当前队伍中的人数$i$**比$a[i]$大时,就出现了两种情况。第一种仍是让**第$i$个选手**加入之前的队伍，第二种则是让**第$i$个选手**自成一个队伍，而这样的话自然得从$f[i-a[i]]$中转移而来，因为**第$i$个选手**自成一个队伍的条件是必须满足有至少$a[i]$个人。

  上面两个转移方程显然都是**从$i$之前转移而来的**，所以循环顺序是顺序。 

  **而且因为循环中$i$是递增的，所以要先排序$a$数组。 **

  此时有些人可能觉得: **排序了之后$i$和$a[i]$就不是对应的了。**

  当然跟原来的数据来比不是对应的了，但是:**这个做法跟$i$的顺序完全没有关系 **，只要保证排完之后还有这$i$个$a[i]$就行了。这个性质也方便了上面的转移方程 （**上面的做法直接默认排完之后的$a[i]$和$i$是对应的了**)


### AC代码

```cpp
#include <cstdio>
#include <algorithm>

#define max(a,b) (a)>(b)?(a):(b)

const int N = 1e6+10;

int n;
int a[N];
int f[N];

void Input() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {
		scanf("%d",&a[i]);
	}
}

void Solve() {
	std::sort(a+1,a+n+1);
	for(int i=1; i<=n; i++) {
		if(i >= a[i]) {
			f[i]=max(f[i-1],f[i-a[i]]+1);
		} else {
			f[i]=f[i-1];
		}
	}
	printf("%d",f[n]);
}

int main(void) {
	Input();
	Solve();
	return 0;
}
```

写得非常详细了，望管理大大给过。

---

## 作者：Adolfo_North (赞：9)

**首先，这是一道动态规划的题目！！！**

$\text{DP}$ 的题最好别用贪心做，除非实在想不出来。

我们废话不多说，切入正题：

- 状态的定义：定义 $\text{f}$ 数组，$f_i$ 表示第 $i$ 个人队伍数量的最大值。

- 分析题目：第 $i$ 个选手要求自己所属的队伍的人数大于等于 $a_i$ 人。这是题目的关键,由此我们可以定义出两种形态。

1. 当  $i<a_i$  时：显然现在还不构成一个队伍，$a_i$ 选择继承 $f_{i-1}$ 。

2. 当 $i \geqslant a_i$ 时又有两种情况：

	1. $i$ 自成一队。

	2. $i$ 加入到旧的队伍中。

由此可得状态转移方程：

`f[i]=max(f[i-1],f[i-a[i]]+1);`

$\text{max}$ 中的 $f_{i-1}$ 是情况 $2$。$f_{i-a_i}+1$ 是情况 $1$，加 $1$ 是指多了一个队伍。

为了方便后面的计算，要把输入的 $a$ 数组排序一遍，但是有会提出疑问：那 $a$ 数组不就乱了吗？

请看样例

未排序的状态：

队伍 $1$，数字 $2$ 和 $1$。队伍 $2$，数字 $2$,$2$ 和 $3$。

排序后的状态：

队伍 $1$，数字 $1$ 和 $2$。队伍 $2$，数字 $2$,$2$ 和 $3$。

由此可见，排序只是将元素位置换了一下而已。

**最后，上代码！**
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[1000005],f[1000005];
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){ if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}//快读函数 
int main() 
{
	int n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
	}
	sort(a+1,a+1+n);//快排，时间复杂度nlogn,头文件 algorithm
	f[1]=1;//初始化 
	for(int i=2;i<=n;i++)//由于已经初始化f数组，所以循环从1开始 
	{
		if(i>=a[i])
		{
			f[i]=max(f[i-1],f[i-a[i]]+1);//状态转移方程 
		}
		else
		{
			f[i]=f[i-1];//选择继承 
		}
	}
	cout<<f[n];
	return 0;
}
```
第一篇题解，求过！

---

## 作者：redegg (赞：4)

贪心题，从大到小排序，先考虑满足最大的值。

简单的贪心肯定WA了前面两个点，为什么呢？

样例4 4 4 3 1 1，最大考验是3，而简单的贪心是2。

为什么？ 如果我们把 4 4 4 3 1 1 改成 4 4 4 2 1 1 呢？算出来的答案就会正确了！

原因很简单，如果A[ i ]与A[ i-1 ]只差大于1了，说明把Ai给并入前面的组的答案会更优，为什么呢？因为如果Ai与Ai-1只差大于了1，则选Ai会比选Ai-1多用掉一个名额，同样的组数却多用了名额，明显是不优秀的。

所以我们只需要判断如果A[ i ]与A[ i-1 ]的差是否大于1，如果大于我们就不考虑A[ i ]了。

但是判断也有个前提！如果A[ i ]是第一个数呢？那么答案就会不考虑第一个数，但是明显第一个数是必须考虑的，特判一下即可！

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1000500];
int ans=0;
int n;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    sort(a+1,a+1+n);
    while(1)
    {
        if(n<=0)
        {
            break;
        }
        if(a[n]-a[n-1]>1&&ans>0)
        {
            n--;
            continue;
        }
        if(n-a[n]>=0)
        {
            ans++;
            n-=a[n];
        }
        else
        {
            n--;
        }
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：issue_is_fw (赞：4)

贪心，从小到大排序。

要满足每个人都有组，**首先$a[n]$到$a[n-a[n]+1]$一定是一组的**

这是一个大前提，也就是怎么分这些人都会在一组。

然后就可以从$1$到$n-a[n]+1$开始贪心了

我们只负责分成最多组，没分到的放到最开始的那组一定满足的

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000009],n;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)	scanf("%d",&a[i]);
	sort(a+1,a+1+n);
	int r=n-a[n],cnt=1,maxn=a[1],ans=1;
	for(int i=2;i<=r;i++)
	{
		if(cnt>=maxn)
		{
			cnt=1,ans++;
			maxn=a[i];
		}
		else	cnt++,maxn=a[i];//更新最大的maxn 
		if(i==r&&cnt>=maxn)	ans++;
	}
	cout<<ans;
} 
```


---

## 作者：落花月朦胧 (赞：3)

## P2062 分队问题 题解


### 题目大意

有 $N$ 名选手， 现在要把他们分到若干队，每个选手要求他的队伍的人数必须要大于等于 $a_i$, 求最多可以分多少个队伍。

### 确定算法

#### 贪心思想
这道题没有标签，差评，初次看题没有任何思路，看到最大化队伍数量就想到了贪心,。

在打代码的过程中发现贪心会发生错误， **每次贪心后并没有考虑到后面的人对队伍的限制，没有满足最优决策**。 ~~兴致勃勃的证明了半天贪心错误， 题解里有人证出来了？？？？~~

#### DP思想

话说贪心和DP总是在一起的，既然贪心错误那就DP！

首先考虑定义的状态，用 $f{[i]}$ 表示前 $i$ 个人中最大的队伍数量。

那么阶段就是 $1$ 到 $N$。
答案就是 $f[n]$。

### 使用DP解决这道题目

首先我们要进行排序， 保证决策的正确（~~这不就是贪心吗？~~）

可以先特判一下， 如果要求的最大的人数都大于了总人数，直接输出 $0$。

分 $2$ 种情况讨论， 第一种情况是当前人数不大于 $i$，另外一种是人数大于等于 $i$。

当前的 $a[i]$ 不大于 $i$ ， 就只有一个决策

$$f[i] = f[i - 1]$$

反之当前的 $a_i \leq i$ 了，即有 $2$ 个决策, 要么加， 要么不加。

转移方程就是

$$f[i] = max(f[i- 1], f[i - a[i] + 1)$$

~~应该很好推吧~~

### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') f |= ch == '-' ? 1 : -1, ch = getchar();
	while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x;
}
inline void print(int x){
	char P[105];int w=0;if(x==0){putchar('0');return;}
	if(x<0) putchar('-'),x=-x;
	while(x) P[++w]=x%10+'0',x/=10;
	for(int i=w; i>=1; i--) putchar(P[i]);
}

const int N = 1e6;
int n, a[N + 1], ans, f[N + 1];
int main() {
	n = read();
	for (int i = 1; i <= n; i++) a[i] = max(1, read());
	sort(a + 1, a + n + 1);
	if (a[n] > n) {
		puts("0");
		return 0;
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] > i) f[i] = f[i - 1];
		else f[i] = max(f[i - 1], f[i - a[i]] + 1);
	}
	print(f[n]);
	return 0;
}

```



---

## 作者：Timothy (赞：2)

用a[i]表示第i个人所在组的最小人数；

用f[i]表示前i个人（包括第i个人）最多组成几组；

用fmax[i]表示前i个人（不一定包括第i个人）最多组成几组；

将a[]从小到大排序，容易得到递推式：

1.如果已经满足a[i]入组的条件，f[i]=fmax[i-a[i]]+1

2.如果不满足a[i]入组的条件，f[i]=0

```cpp

#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int a[1000001],n,f[1000001],fmax[1000001];
int main ()
{
    scanf ("%d",&n);
    for (int b=1;b<=n;++b)scanf ("%d",&a[b]);
    sort(a+1,a+n+1);
    for (int b=1;b<=n;++b)
    {
        if (b>=a[b])f[b]=fmax[b-a[b]]+1;
        else f[b]=0;
        fmax[b]=max(f[b],fmax[b-1]);
    }
    printf ("%d",f[n]);
    return 0;
}

fmax[i]=max(f[i],fmax[i-1])

```

---

## 作者：attack (赞：1)

楼下已经有人讲到了dp的做法，但他维护了一个前缀最小值g，实际上这个g是不用维护的，直接从$i - a[i]+1$转移而来即可。

证明很显然：我们把所有人都选一定会比空下一个人不选更优
```cpp

// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#define LL long long 
using namespace std;
const int MAXN = 1e6 + 10;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N;
int a[MAXN], f[MAXN];
int main() {
    N = read();
    for(int i = 1; i <= N; i++) a[i] = read();
    sort(a + 1, a + N + 1);
    int res = N, ans = 0;
    for(int i = 1; i <= N; i++) {
        if(a[i] <= i) f[i] = 1;
        if((i - a[i] >= 1))
            f[i] = max(f[i], f[i - a[i]] + 1);
        ans = max(ans, f[i]);
    }
    printf("%d", ans);
    return 0;
}
/*
4
2 3 3 3
*/
```


---

## 作者：0_0_0_ (赞：0)

第一次写题解

我主要思想如下：

先按一般的贪心，从大到小排序。
从第二组开始，对于每一组，不考虑能不能做到每个人有分组，只考虑最多能分几组，剩下没有分组的一定是在本组中最大的，把这些人直接丢到第一组去。

代码如下：（能AC但是数据听说好像很水）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int a[1000009];
int ans=0;
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d",a+i);
	} 
	sort(a+1,a+n+1);
	for (int i=n-a[n];i>0;i-=a[i])//n-a[n]是从第二组开始
	{
		int cnt=i-a[i]+1;
		if (cnt<=0)
		{
			cnt=1;
		}
		int anse=0;//求这一组中最多能分成几个小组，不考虑每个人都要分组
		while (cnt<=i)
		{
			bool flg=false;
			int minr=a[cnt];//这组至少要多少人
			for (int j=1;j<=minr;j++)
			{
				minr=a[j+cnt-1];//更新最少需要的人数
				if (j+cnt-1>i)//跑到别的组就退出
				{
					flg=true;
					break;
				}
			}
			if (flg)
			{
				break;
			}
			anse++;
			cnt+=minr;
		}
		ans+=anse;
	}
	printf("%d",ans+1);//+1是算上第一组
	return 0;
} 
```


希望有大佬能来证明或者推翻一下，因为本人比较弱不会证明。。。

---

## 作者：木木！ (赞：0)

一篇过了目前所有hack数据的题解

先排序，然后`dp[i]`表示之前都满足要求，选到第i个人之后的可能总数。思路是选第i个人的时候，有两种可能，一种是其归属于上一队，此时就是`dp[i+1]`，另一种是其自成一队，此时就是`dp[i+ai[i]]`。

然而在选第一个人的时候，他已经不可能归属上一队了，因此`dp[1]=dp[1+ai[1]]`

时间效率和空间效率$O(n)$

代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int dp[1000005];
int ai[1000005];

bool cmp(int a,int b)
{
	return a>b;
}

int max(int a,int b)
{
	return a>b?a:b;
}

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",ai+i);
	}

	sort(ai+1,ai+1+n,cmp);

	for(int i=n; i>=2; --i)
	{
		if(i+ai[i]-1 > n)
		{
			dp[i] = dp[i+1];//此时不可能自成一队
		}
		else
		{
			dp[i] = max(dp[i+1],dp[i+ai[i]]+1);
		}
	}
	dp[1] = dp[1+ai[1]]+1;

	printf("%d\n",dp[1]);

	return 0;
}
```

---

## 作者：tjer (赞：0)

# 思路
### [题链](https://www.luogu.com.cn/problem/P2062)
这题刚看到确实很容易想到贪心。

因为题目要求将分出的队伍数最大化,所以我们可以将所有人的要求进行降序排序。

为什么可行？

无论如何，一个需求较大的人的的要求肯定是会被满足的，而进行排序后，如果我们根据当前处理的人要求进行处理下标的跳跃（当前下标加上此人要求数），那么那些被跳跃过的人的要求就也一定会被满足，从而最优。

例：
```cpp
5
2 3 4 1 4
```
对于这组样例,降序排序后为
```cpp
5
4 4 3 2 1
```
按照上述的贪心思路，初始时下标为 $1$ ，第一个人要求为 $4$ ，则将下标调至 $5$ ，发现结果为 $2$ ，即正解。

在正常的跳跃结束后，如果剩下的人数不为 $0$ ，队数自增 $1$ ，为什么可以这样？

人数不为 $0$ ，说明还可以进行分队,所以队数自增 $1$ 。

那剩下的人数已经不足以进行跳跃了呢？

因为之前我们的分队已经最优了,所以可以将当前要求不被满足的人放到之前的队伍里去，下标超过总人数则退出。

但打完贪心后你会发现前两个点会被卡掉，于是开始排错。

在分队过程中，应将要求为 $1$ 的人自己和自己一队。

为什么可以这样？

题目中说保证数据一定有解，所以当我们将要求为一的从所有人当中去掉时，剩下的人即使无法满足要求也可以忽略不计。

将这些要求为一的人的要求修改为 $0$ ，并在我们记录剩余人数和记录退出条件（初始为总人数）的变量中减去 $1$ 。

在遍历处理中，如果发现要求为 $0$ 的人（即在输入处理前要求为 $1$ 的人），应直接结束遍历，避免后面进行了无意义的运算。

经过这一番修改，此时的贪心就完全正确了。

上正解！ヾ(≧▽≦*)o

# code
```cpp
#include<bits/stdc++.h>
#define maxn 10000005 //宏定义
using namespace std;
int n,v,person,sum,num=1;
int a[maxn];
int main () {
    cin >>n;
    person=n;
    v=n;
    memset(a,101,sizeof(a));
    //填充不为0的数
    for(int i=1;i<=n;i++){
        cin >>a[i];
        if(a[i]==1){
            sum++;
            a[i]=0;
            v--;person--;
        }
    }
    sort(a+1,a+1+n,greater<int>());
    //降序排序 用 greater<int>() 代替自定义一个 cmp 函数
    for(register int i=1;i<=n;i++){ //寄存器省时间
        if(!a[num]) break;
        person-=a[num];
        num=num+a[num];//正常跳跃
        if(person>=0) sum++;//剩下的人数>=0 
        if(num>v||!a[num]) break;
        //重点！
        while(a[num]>person) {
            num++; 
            if(num>v) break;
            person-=1;
        }//不满足要求时的跳跃
    }
    cout <<sum;//输出答案
    return 0;//蕐骊的结束
}
```
最后安利一下我的[博客](https://www.luogu.com.cn/blog/cjiajia2233/)


---

## 作者：zyy121212 (赞：0)


排序后先给**被要求人数多的同学**组队就可以了

**注意：**

1. 被要求人数为1的同学自己组队
1. 剩下的人数无法满足正在处理的同学安排到上一组排好的队 
1. **对于自动组队后，剩下的人数无法满足正在处理的同学且没有已经排好的队**，如：7 2 1 1 1 1 1，一定是第一个人的问题，谈判即可。

特判如下（主代码没有）：
```
if(a[m]>m)
{
	ans=ans-(a[m]-m)+1;
	cout<<ans;
    return 0;
}
```
**主代码:**
```
#include<bits/stdc++.h>
using namespace std;
int n,a[1100100],ans,p,num;
int main()
{
    cin>>n;//输入人数
    int m=n;//m是n的替身
    for(int i=1;i<=n;i++）
    {
        cin>>p;//第i个同学的人数要求
        if(p==1)ans++,m--;//如果 p为一 自动组队
        else a[++num]=p;//否则 等待入队
    }
    sort(a+1,a+m+1);//排序
    //没有特判继续AC，可见数据之水。。。
    while(m>0)//m为剩余人数
    {
        if(m<a[m])m--;//如果剩下的人数无法满足 正在处理的同学 安排到上一个 排好的队
        else
        {
            m-=a[m];//否则减去队数
            ans++;
        }
    }
    cout<<ans;
//}(￣▽￣)"

```


---


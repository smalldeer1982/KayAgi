# 数字对

## 题目描述

对于一个数字对 $(a,b)$，我们可以通过一次操作将其变为新数字对 $(a+b,b)$ 或 $(a,a+b)$。

给定一正整数 $n$，问最少需要多少次操作可将数字对 $(1,1)$ 变为一个数字对，该数字对至少有一个数字为 $n$。

## 说明/提示

样例解释：

$$(1,1)  \to  (1,2)  \to  (3,2)  \to  (5,2)$$


---


对于 $30\%$ 的数据，$1 \le n \le 1000$。

对于 $60\%$ 的数据，$1 \le n \le 20000$。

对于 $100\%$ 的数据，$1 \le n \le 10^6$。

## 样例 #1

### 输入

```
5```

### 输出

```
3```

# 题解

## 作者：Lyrics (赞：14)

给一个数字对(a,b)，考虑如何把它还原成(1,1)

我们想：

若a>b那么(a,b)->(a-b,b);

若b>a那么(a,b)->(a,b-a);

若a==b

若(a==b==1)那么我们就还原成功了！

否则,(a,b)->(a,0)/(0,b),无法还原到(1,1),不满足条件。

如何加速这个过程呢？

我们感觉这个东西和gcd（辗转相除法）很像

若a>b,则(a,b)->(a mod b,b),步数+a/b;

若b>a,同理可得。

对于给定的n，枚举所有的i，还原(n,i),取最小步数为解

时间复杂度O(n\*logn)

所以，CODE:

```cpp
#include<bits/stdc++.h>
#define LL long long
#define NAME "numpair"
#define setfile() freopen(NAME".in","r",stdin),freopen(NAME".out","w",stdout)
#define closefile() fclose(stdin),fclose(stdout)
LL inf=1e9,n,ans=1e9;
using namespace std;
LL calc(LL a,LL b){
    if (b==1) return a-1;
    if (!b) return inf;
    return a/b+calc(b,a%b);
}
int main(){
    setfile();
    scanf("%lld",&n);
    for (int i=1;i<n;i++)
        ans=min(ans,calc(n,i));
    printf("%lld\n",ans);
    closefile();
    return 0;
}
```

---

## 作者：HsKr (赞：11)

**爆搜使人快乐**，

**搜爆使人绝望**。

按题意BFS

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<map>
using namespace std;
int n,ans=0x3f3f3f3f;
struct node{
	int x,y,step;
};
queue<node> q;
map<pair<int,int>,int> m;
int bfs(){
	q.push((node){1,1,0});
	m[make_pair(1,1)]=1;
	while(!q.empty()){
		node tmp=q.front();
		q.pop();
		if(tmp.x==n||tmp.y==n){
			return tmp.step;
		}
		if(tmp.step>ans) continue;//最优性剪枝 
		if(tmp.x>n || tmp.y>n) continue;//可行性剪枝 
		if(!m[make_pair(tmp.x+tmp.y,tmp.y)]){
			q.push((node){tmp.x+tmp.y,tmp.y,tmp.step+1});
			m[make_pair(tmp.x+tmp.y,tmp.y)]=1;
		}
		if(!m[make_pair(tmp.x,tmp.x+tmp.y)]){
			q.push((node){tmp.x,tmp.x+tmp.y,tmp.step+1});
			m[make_pair(tmp.x,tmp.x+tmp.y)]=1;
		}
	}
}
int main(){
	cin>>n;
	cout<<bfs()<<endl;
	return 0;
}
```

TLE30分。

上述代码又臭又长，还不如一个精简的DFS呢。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int n,ans=0x3f3f3f3f;
int dfs(int x,int y,int step){
	if(x==n||y==n){
		ans=min(ans,step);
	}
	if(x+y<=n){
		dfs(x+y,y,step+1);
		dfs(x,x+y,step+1); 
	}
	return ans;
}
int main(){
	cin>>n;
	cout<<dfs(1,1,0)<<endl;
	return 0;
}

```

当然还是TLE了，60分。

~~我前面是怎么写的BFS~~

可以考虑：令$step(1,1,n,x)$为从$(1,1)\Rightarrow(n,x)$步数的最小值，那么$step(1,1,n,x)=step(n,x,1,1)=step(x,n,1,1)$，从尾往头搜即可。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<map>
using namespace std;
int n,ans=0x3f3f3f3f;
void dfs(int x,int y,int step){
	if(step>ans) return;
	if(x==1&&y==1){
		ans=min(ans,step);//记录最小步数
		return;
	}
	if(x==y) return;//(x,x)休想到(1,1) 
	dfs(x-(x>y?y:0),y-(y>x?x:0),step+1);//如果x>y就搜(x-y,y)，否则搜(x,y-x)，由玄学得知如果两个数差太大，减成(1,1)次数会比凑在一起一减减一堆要多。
}
int main(){
	cin>>n;
	for(int i=1;i<n;i++){//枚举x 
		dfs(i,n,0);
	}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：山川万古作伴 (赞：10)

### ~~蒟蒻第一次提交题解~~

看下面dalao的辗转相除法受到了启发...

基本思路：因为这一题是要求 (1,1)到(n,i)的最少步数    _(可证i<=n，因为当i1>=n时一定会可以在前一步或几步中出现过(n,i2)中i2<=n的情况)_    ，因此我们可以枚举i从1到n，当出现一种正确的情况时与当前最小次数比较，保留较小的次数。

这一题我是用递归做的，因此还需要考虑边界的问题。分析可知当(x,y)中x==y时可以返回步数的值。x与y相等时又分两种:

(1)如果其中一个是1，说明还原成功了，直接返回步数

(2)如果其中一个不是1，那么一定无法继续还原得到(1,1)，返回一个大数

如果在还原过程中第一个数小于第二个数咋办?

好办，不用交换，将大数一直减去小数直到这个数比原来的小数还要小即可；这时我们还需要考虑步数，还原的步数其实就是大数减去小数的次数，加到下一个递归里就可以了。

递归程序要什么参数？

~~显而易见~~分析可得，需要保存三个参数 ~~我没细想~~ 两个是数对中存的数，一个是步数。

可能有人会问了:为什么要一直减而不用%呢？（~~因为我%的时候递归炸了~~）

那么我们就可以设计两个函数(~~应该可以合并成一个，我没细想~~)，一个专门减数，一个记录次数(~~两个函数雷同2333~~)

（附：如果前面i从1枚举到n-1，那么n==1时需要进行特判(~~提交后好像慢了~~)）

上ac代码

```
#include<bits/stdc++.h>
using namespace std;
int n,mi=0x7f7f7f7f;      //0x7f7f7f7f是一个很大的数，int在正数里的最大值 
int jian(int x,int y)	  //进行取模运算的函数 
{
	while(x>y)
	{
		x-=y;
	}
	return x;
}
int ci(int x,int y)		  //计算次数的函数 
{
	int cii=0;
	while(x>y)
	{
		x-=y;
		cii++;
	}
	return cii;
}
int dfs(int a,int b,int step)
{
	if(a>b)dfs(jian(a,b),b,step+ci(a,b));
	else if(a<b)dfs(a,jian(b,a),step+ci(b,a));
	else if(a==b&&a!=1)return 0x7f7f7f7f;//如果还原不了就返回一个大数 
	else return step;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)				//从1到n的枚举 
	{
		mi=min(mi,dfs(n,i,0));			//取最优答案 
	}
	cout<<mi;
}
```

当然有更好的解法，只不过本蒟蒻~~没细想~~水平有限并且这种方法思维难度相对比较小，所以我在机房同仁的鼓动下来发题解了......

最后祝大家早日ac！

---

## 作者：MC_Launcher (赞：6)

#### 发一弹题解biu!biu!biu!

题意：~~开局两个1，运算全靠拼~~，咳咳，给你一个初始数字对（1,1），你可以将（a，b）这个数字对变成（a+b,b）或（a，a+b）问最少用多少次其中一个数字能变成给定的数字n

第一眼一看，水题，一个dfs+剪枝就行，提交后，~~60分的好成绩~~

数据范围$10^6$，啊这，深搜要出多少分枝啊

那么怎么办呢？该优化的都优化了，$O^2$也开了。

于是咱们可以倒着搜

由（1,1）能变换到（i，n）同样也能从（i，n）变换成（1,1），只是把加变成减，但是这个i我们没有啊！怎么办？枚举呗，枚举1~n-1就行，为什么不枚举到n以及n以上呢，因为如果是两个n肯定相减得零，不成立啊。大于n可以转换成（i，m-n）这还多了一步呢。

于是乎咱们写一个倒推回去的函数，每次用大数减去小数，直到两个数都变成1或者有一个小于1时return。

复杂度$(nlogn)$，循环n次，推回去logn

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
void oper(int a,int b,int time)//对数对进行一次操作 
{
	if(a==1&&b==1)//如果成功返回到数对（1,1）那么更新最小步数 
	{
		ans=min(time,ans);
		return;
	}
	if(a<1||b<1)//如果有一个小于1肯定不成立 
	{
		return;
	}
	if(a<b)oper(a,b-a,time+1);//对数对进行如题反变换 
	else
	{
		oper(a-b,b,time+1);
	}
} 
int main()
{
	cin>>n;
	ans=n-1;//这里，因为（1,1）数对用一个1一直加另一个加n-1次肯定能得到答案 
	for(int i=1;i<n;i++)oper(n,i,0);//便利 
	cout<<ans;//输出 
}
```

还有个问题请教一下，我这玩意放我电脑上运行大于40000就算不出来，怎么你谷可以评测呢？？？

### 题解千万条，理解第一条。直接抄题解，棕名两行泪。

---

## 作者：Itache (赞：5)

这题可用搜索，如果直接从头搜到尾只有50分，所以借鉴了一下楼下的方法，枚举到n时另一个数的每一种情况，从后往前搜，再加上剪枝，即可AC。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int minn=2000000000;
void search(int x,int y,int r){//X：第一个数；y：二；r:次数 
    if(r>minn)
        return ;//最优性剪枝 
    //printf("%d %d %d\n",x,y,r);
    if(x==1&&y==1){
        minn=min(minn,r);
        return ;
```
}//更新
    if(x<1||y<1)
```cpp
        return ;//边界 
    if(x>y)
        search(x-y,y,r+1);
    else if(y>x)search(x,y-x,r+1);//这两步很重要，可以使一棵
    //2叉树变为一条链 
}
int main(){
    int n;
    scanf("%d",&n);
    for(int i=2;i<n;i++)//枚举每一种情况 
        search(i,n,0);
    printf("%d",minn);
    return 0;
}

```

---

## 作者：love_saber (赞：4)

这道题，很明显是个搜索，但是大家都写的好臃肿啊，我来提供一个短小的写法

### 先说思路

首先直接搜索肯定是不好写的，两个数的加法变数太多了（~~单纯懒得想~~）

一般这种时候，就要考虑逆向思维，如果我们知道最后的结果，反过来，是不是很容易就能算出要多少步就可以得到？

所以，我们倒着搜索，用类似gcd的方法处理

**先放一个dfs函数出来：**
```c
int dfs(int a,int b){
	return (a==1||b==1)?a+b-2:a/b+dfs(b,a%b);
}
```
**短小精悍**

emmm，压行了，其实和这个一样

```c
int dfs(int a,int b){
	if(a==1||b==1)return a+b-2;
	else return a/b+dfs(b,a%b);
}
```
详细讲一下我这个短小的dfs

首先，如果a或者b之中有一个为1了，那么这种状态就是由$(1,1)$,直接转来的，直接$return$就行

为什么$return$ $a+b-2$ 因为每次增长1，总共增长了$(a+b-1-1)$(~~神犇请忽略我的废话~~)

否则，大的数肯定是由旁边小的数加上来的

所以，下一步搜索$(b,a\%b)$,就像gcd函数一样

这步消耗的步数就是$a/b$

**完整的代码**

```c
#include<bits/stdc++.h>
using namespace std;

int dfs(int a,int b){
	return (a==1||b==1)?a+b-2:a/b+dfs(b,a%b);
}

int main(){
	int n,ans=1e9;cin>>n;
	for(int i=1;i<=n;i++){
		if(__gcd(n,i)==1)ans=min(ans,dfs(n,i));
	}
	cout<<ans<<endl;
	return 0;
}
```
$gcd$函数的意义是因为最后的两个数必定是互质的

---

## 作者：tryrtj (赞：4)

看到各位大佬在用辗转相除法，但是这题搜索也能过，不过当n==1时，有些题解就会，正着搜当然TLE，需要倒着模拟不过要注意

当两个数相等但不是1时，需要直接return；

此时双手奉上打表代码

```
#pragma GCC optimize(2)
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int step;
int minn;
void asd(int a,int b,int q){
    if(a==q||b==q){
        if(minn>step){
            minn=step;
        }
        return;
    }
    if(step>=minn)return;
    //if(step%2==0){
    if(a+b<=q){
    	step++;
    	asd(a+b,b,q);
    	step--;
	}
    if(a+b<=q){
    	step++;
    	asd(a,a+b,q);
    	step--;
	}
   // }
    /*if(step%2==1){
    if(a+b<=q){
    	step++;
    	asd(a,a+b,q);
    	step--;
	}
    if(a+b<=q){
    	step++;
    	asd(a+b,b,q);
    	step--;
	}
    }*/
    return;
}
int main(){
    int n;
    //cin>>n;
    //freopen("1.txt","w",stdout);
    for(int i=1;i<=1000000;i++){
    	step=0;
		minn=40;
		asd(1,1,i);
		cout<<minn<<',';
	}
    //if(minn==99999999)cout<<-1<<endl;
    
    return 0;
} 
```
别想了，大约需要2000个小时才能打完。。。。

以下为正解

```
#include<iostream>
using namespace std;
int minn;
int step;
int minnn=999;
void asd(int g,int h){
    if(g==h&&h==1){
        if(minn>step)minn=step;
        return;
    }
    step++;
    if(step>minn){
        step--;
        return;
    } 
    if(g==h){
        step--;
        return;
    }
    if(g>h){
        asd(g-h,h);
        step--;
    }
    if(g<h){
        asd(g,h-g);
        step--;
    }
    return;
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        minn=999;
        step=0;
        asd(i,n);
        if(minn<minnn)minnn=minn;
    }
    cout<<minnn<<endl;
    return 0;
}
```

顺便交上本题最优解 @Katoumegumi 神仙解法？（hack数据：40000,40001）

```
#include<stdlib.h>
#include<stdio.h>
#include<time.h>
#include<math.h>
#include<algorithm>
#define T_min 1e-9
#define delta 0.9
#define ll long long
using namespace std;
ll ans=31237987812983LL;
double T=100;
ll assess;

//43424
void dfs2(ll x,ll y,ll step) {
    if(T<T_min) return;
    if(step>ans) return ;
    if(x==1&&y==1) {
        ans=min(ans,step);
        return ;
    }
    if(x<1||y<1) return ;
    if(x>y) dfs2(x-y,y,step+1);
    else if(y>x) dfs2(x,y-x,step+1);
    assess++;
    if(log(-assess/T)>=rand()%100/(double)101) T*=delta;
}

void dfs1(ll x,ll y,ll step) {
    if(step>ans) return ;
    if(x==1&&y==1) {
        ans=min(ans,step);
        return ;
    }
    if(x<1||y<1) return ;
    if(x>y) dfs1(x-y,y,step+1);
    else if(y>x) dfs1(x,y-x,step+1);
}

ll n;
int main() {
//	freopen("numpair.in","r",stdin);
//	freopen("numpair.out","w",stdout);
    srand(time(NULL));
    scanf("%lld",&n);
    if(n==900039||n==900064||n==900075||n==900177||n==900213||n==900250||n==900261||n==900340||n==900376) {
        puts("29");
        return 0;
    }
    if(n==900045||n==900327||n==900342||n==900354||n==900360||n==900444||n==900447||n==900470) {
        puts("31");
        return 0;
    }
    if(n>=800000&&n<=1000000) {
        puts("30");
        return 0;
    }
    if(n>=600000&&n<=800000) {
        puts("30");
        return 0;
    }
    if(n>=400000&&n<=600000) {
        puts("28");
        return 0;

    }
    ans=n-1;
    if(n>300000) {
        if(rand()%2) puts("27");
        else puts("28");
        return 0;
    }
    if(n>50000&&n<=300000) {
        putchar('2');
        printf("%d",rand()%7+3);
        return 0;
    }
    if(n>43424&&n<=50000) {
        putchar('2');
        printf("%d",rand()%2+3);
        return 0;
    }
    if(n>40000&&n<=43424) for(ll i=2; i<n; i++) assess=1,T=100,dfs2(i,n,0LL);
    else if(n<40000) for(ll i=2; i<n; i++) dfs1(i,n,0LL);
    printf("%lld",ans);
    return 0;
}

```
顺便说一句：本人代码1700ms，吸氧1100ms

---

## 作者：Da_un (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P2090)
## 思路
考虑一次操作的过程，实际上相当于辗转相减法的逆运算。

即 $\gcd(a,b)=\gcd(a-b,b)(a\geqslant b)$

当 $a,b>1$ 时，显然有 $a\ne b$。

此时若假设 $a>b$，数字对 $(a,b)$ 只能由数字对 $(a-b,b)$ 得到，我们可以用辗转相除法倒推计算从 $(1,1)$ 不断操作得到 $(x,y)$ 的操作次数，值得注意的是，数字对 $(1,1)$ 再往前还原一步是 $(1,0)$，$x,y$ 要满足互质。

最终得到的数字对 $(n,x)$ 中的 $x$ 显然要小于 $n$，若大于 $n$ 就相当于在已经得到 $n$ 的基础上又额外耗费了操作次数，显然并不是最优解。

因此我们可以直接枚举 $x(1\leq x<n)$，让它和 $n$ 做辗转相除，取所有与 $n$ 互质的 $x$ 中操作次数的最小值。

上述方法的时间复杂度并不高，可以轻松过掉此题。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define MAXN 0x3f3f3f3f
using namespace std;
int n,ans=MAXN;
int F_min(int x,int y)
{
    return x>y?x=y:x;
}//求x,y中的最小值 
void my_gcd(int x,int y,int t)//辗转相除 
{
    if(!y){//y==0
          if(x==1)
	    ans=F_min(ans,t);//完毕 
	  return;
    }
    my_gcd(y,x%y,t+x/y);//没到此方案最优，继续 
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        my_gcd(n,i,0);//枚举每一次 
    //辗转相除求的是还原到(1,0)的操作次数，最后还要减一 
    printf("%d\n",ans-1); 
    return 0;
}
```
完结撒花~~

---

## 作者：Tyw_ei (赞：3)

如果这个题你选择正着推的话,那么除了dfs就没有什么后续了

那么考虑从答案入手:

1.最后的答案一定满足(n,i)(i<=n);

2.从这一状态到以前的状态,可以很好的表示,(maxn-mini,mini)-->(mini,maxn)

一定是大的减去小的;

3.如果maxn是mini的倍数,则要通过取模来加速;

4.由三可知一个新的问题就是如何判断他们最后是从(1,1)转移过来?

答案是两个数必须互质;如果他们有相同的因子,最后减出来的一定是这个因子的倍数或0;

5.与gcd的联系:因为辗转相减就是求gcd的手段,当一个数为0的时候,另一个数就是原数对的最大公约数

而题目又在他们互质的时候才能转移,显然a==1的时候才可以


```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#define INF 2147483647
using namespace std;

int ans=INF,n;

void check(int a,int b,int step){
    if(b==0){
        if(a==1)ans=min(ans,step);
        return;
    }
    if(a<b)swap(a,b);
    check(b,a%b,step+a/b);
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
        check(n,i,0);
    printf("%d",ans-1);
    return 0;
}
```

---

## 作者：lczx (赞：3)

不难看出对于一个状态(x,y)(不妨假设x>y>0)仅可以由(x-y,y)这个状态推出。那么枚举(1,n),...,(n,n)，每个状态往前推即可，时间复杂度O（n log n）。


AC代码：


```cpp

#include <cstdio>
int n,ans=1<<29;

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int x=i,y=n,step=0;
        while(1){
            if(x<y){
                int t=x;x=y;y=t;
            }
            if(!y) break;
            else if(y==1){
                step+=x-1;
                ans=step<ans?step:ans;
                break;
            }
            step+=x/y;
            x%=y;
        }
    }
    printf("%d",ans);
    
    return 0;
}

```

---

## 作者：AirCnt (赞：2)

### ~~蒟蒻第一次交题解~~

[AC证明](https://www.luogu.com.cn/record/37614712)

题意：对于一个数字对 $(a,b)$，每一步你可以把它变成 $(a+b,b)$或 $(a,a+b)$。现在你有一个数字对 $(1,1)$，问将其中至少一个数变为 $n$ 的最少步数。

看到这题的第一反应就是一道简单的搜索题。

先写了一个深搜剪枝：
```cpp
void search(int a,int b,int r)
{
	if(r>ans||a>n||b>n)
		return;
	if(a==n||b==n)
		ans=min(ans,r);
	if(a<=b)
		search(a+b,b,r+1);
	else if(b<=a)
		search(a,a+b,r+1);	
}
```
得0 pts。

于是我输出了 $(a,b)$，发现最后搜出来的数大于 $n$，没有搜出等于 $n$的情况。

现在有两种方法：

1. 逆搜，模拟所有搜到 $n$ 的情况，试图搜到1；

2. 仍然选择正搜，让深搜搜出更多情况，试图搜到 $n$。

我选择了第二种（~~不然早就有人交了第一种思路的题解了）~~。

对于 $abs(a-b)\le7000$的情况，我们两种都搜。

再加上O2优化，AC。

### AC Code
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int ans=20000000,n;
void search(int a,int b,int r)
{
	if(r>ans||a>n||b>n)	//剪枝，若有更小的答案或a,b中的任意一个超过n则结束搜索
		return;
	if(a==n||b==n)
	{
		ans=min(ans,r);
		return;
	}
	if(abs(a-b)<=7000)	//对于abs(a-b)<=7000的情况，我们两种都搜
	{
		search(a+b,b,r+1);
		search(a,a+b,r+1);
	}
	else if(a<b)	//否则，我们搜能让a,b更接近的情况，能减少很多搜索量
		search(a+b,b,r+1);
	else if(a>b)
		search(a,a+b,r+1);
}
int main()
{
	ios::sync_with_stdio(false);	//优化，取消cin,cout与scanf,printf之间的绑定
	cin.tie(0);	//优化，取消cin与cout之间的绑定
	cin>>n;
	search(1,1,0);
	cout<<ans;
	return 0;	//愉快的结束程序~
}
```


---

## 作者：SteinsGate0 (赞：2)

先宝搜把最打出来嘛，发现跟辗转相处很像哦！就可以开始混沌了；

枚举（i，n）,用改过的gcd跑跑就可以了。

改动看代码

```cpp
#include<cstdio>
using namespace std;
int n,i,cnt,ans,c;
void Calc(int a,int b){
  cnt=0;
  while ((b>1)&&(cnt<ans)){
    c=a%b;
    cnt=cnt+(a-c)/b;
    a=b;
    b=c;
  }
  if (b==1)
    if (cnt+a-1<ans)
      ans = cnt+a-1;
}
int main() {
   scanf("%d", &n);
  ans = n-1;
  for (i=2; i<=n-1;i++)
    Calc(n,i);
  printf("%d\n", ans);
}

```

---

## 作者：_WinY (赞：1)

我的代码并不是gcd解法，大佬可以主动跳过

看到几位大佬都在打剪枝，本蒟蒻打了一个dfs

暴搜是个好东西~~骗分的好东西~~

放代码
```cpp
#include<bits/stdc++.h>//万能头（陋习）
using namespace std;
int n,ans=1e7+15;//三年OI一场空，不初始化见——
int a,b;//ans要定义一个较大的数，不然爆0
void dfs(int a,int b,int r)//暴搜开始，重要的开始le
{
    if(a>n||b>n||r>ans)
    {
        return;//超过范围，返回
    }
    if(a==n||b==n)
    {
        ans=min(ans,r);//符合题意时（也就是a与b其中一个等于n）ans就要取最小（题中要求最小次操作）
        return;
    }
    if(abs(a-b)<=7000)//两种情况都要搜（注意要用绝对值）
    {
        dfs(a+b,b,r+1);//第一种给a+
        dfs(a,a+b,r+1);//第二种给b+）
    }
    else if(a<b)
    {
        dfs(a+b,b,r+1);//如果大于7000的话a,b取小的加上另一个（不这样会炸）
    }
    else if(a>b)
    {
        dfs(a,a+b,r+1);//同上
    }
}
int main()
{
    scanf("%d",&n);
    dfs(1,1,0);//第一个1是a（数字对中第一个），第二个1是b（数字对中第二个），第三个0是次数（r）
    printf("%d",ans);
    return 0;//程序的结束，AC的开始
}
```
暴搜还是很简单的，只要不要想得太麻烦

把每种情况都枚举出来在判断就行了


再给大家放一个我30pts的代码~~第一次交就拿了三十分~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,ans=1e7+15;
int a,b;
void dfs(int a,int b,int r)
{
    if(a>n||b>n||r>ans)
    {
        return;
    }
    if(a==n||b==n)
    {
        ans=min(ans,r);
    }
    if(abs(a-b)<=7000)
    {
        dfs(a+b,b,r+1);
        dfs(a,a+b,r+1);
    }
    if(a<b)
    {
        dfs(a+b,b,r+1);
    }
    if(a>b)
    {
        dfs(a,a+b,r+1);
    }
}
int main()
{
    scanf("%d",&n);
    dfs(1,1,0);
    printf("%d",ans);
    return 0;
}

```
我太弱了（祝自己这次whk大考能过&&csp也能过）

rp++

感谢各位大佬观看 好管理给过吧



---


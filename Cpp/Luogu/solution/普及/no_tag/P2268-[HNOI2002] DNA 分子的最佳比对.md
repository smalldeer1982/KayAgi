# [HNOI2002] DNA 分子的最佳比对

## 题目描述

$\operatorname{DNA}$ 分子是人类遗传信息的载体，它间接地指导蛋白质的合成。$\operatorname{DNA}$ 分子是由四种核苷酸组成的长链，这四种核苷酸分别是腺嘌呤核苷酸（用 $\operatorname{A}$ 代表）、鸟嘌呤核苷酸（用 $\operatorname{G}$ 代表）、胞嘧啶核苷酸（用 $\operatorname{C}$ 代表）和胸腺嘧啶核苷酸（用 $\operatorname{T}$ 代表）。习惯上用一个字符集为 $\{\operatorname{A,T,C,G}\}$ 的字符串来表示一个 $\operatorname{DNA}$ 分子序列，如 $\operatorname{CGTTAGA}$。

在生物进化过程中，$\operatorname{DNA}$ 分子可能发生各种各样的突变。这种突变形成了生物遗传信息的改变，从而使生物得以分化，构成了生物的多样性。

主要的突变有三种：

1. 在一个 $\operatorname{DNA}$ 序列中插入一个新的核苷酸，
2. $\operatorname{DNA}$ 序列中丢失了一个核苷酸，
3. $\operatorname{DNA}$ 序列中的某个核苷酸被另一个核苷酸所取代。

所谓两个 $\operatorname{DNA}$ 序列的一个比对是寻找一种排列方式，使得两个 $\operatorname{DNA}$ 序列在同样的位置上有相同的核苷酸，而若在同样的位置上两个 $\operatorname{DNA}$ 序列的核苷酸不同，则是由三种突变之一得到。例如，对两个 $\operatorname{DNA}$ 序列 $T_1 =\operatorname{ATCAG}$，$T_2 =\operatorname{ACTAG}$，可以按如下方式比对：（$-$ 表示空白）

比对一：

| $T_1$ | $T_2$ |
| :----------- | :----------- |
| $\text A$ | $\text A$ |
| $\text T$ | $-$ |
| $\text C$ | $\text C$ |
| $-$ | $\text T$ |
| $\text A$ | $\text A$ |
| $\text G$ | $\text G$ |

也可以按如下方式比对：

比对二：

| $T_1$ | $T_2$ |
| :----------- | :----------- |
| $\text A$ | $\text A$ |
| $\text T$ | $\text C$ |
| $\text C$ | $\text T$ |
| $\text A$ | $\text A$ |
| $\text G$ | $\text G$ |

如果两个 $\operatorname{DNA}$ 序列在相同的位置上有越多相同的核苷酸对，则表明它们之间越相似，即它们存在功能上的相似性和进化史上的亲缘关系。

对于两个 $\operatorname{DNA}$ 序列的一个比对，规定如下得分方式：

1. 一个同样的位置上有相同的核苷酸对，则可得 $1$ 分；
2. 一个同样的位置上有不同的核苷酸对，则得 $0$ 分；
3. 如果在某个位置上一个序列有核苷酸，而另一个序列在该位置上为 $-$，则得 $-2$ 分。

例如，比对一的得分是 $0$ 分，比对二的得分是 $3$ 分。

问题是：对于两个 $\operatorname{DNA}$ 序列，寻找一种比对方式，使得它们的得分最高。

## 样例 #1

### 输入

```
Atcag
Actag
```

### 输出

```
3```

# 题解

## 作者：ctq1999 (赞：16)

[传送门](https://www.luogu.org/problem/P2268)

## 题意简述

给你两个字符串

让你插入一个空格、更改一个字符、插入一个新的字符来使这两个字符串有最大匹配数

其中若一个下标上完全匹配加$1pts$，不同加$0pts$，若两者中有空格，加$-2pts$

## 思路

考虑动态规划

第一个字符串用$s1$来表示，第二个用$s2$表示

$f[i][j]$表示$s1$前i个字符和$s2$前$j$个字符最大得分

则动态转移方程：

```c++
f[i][j] = max(f[i - 1][j - 1] + (s[i - 1] == s[j - 1]), f[i][j - 1] - 2, f[i - 1][j] - 2);
```

- $f[i - 1][j - 1] + (s[i - 1] == s[j - 1])$ 表示$s1$第$i$个字符与$s2$第$j$个字符比较（因为循环是从$1$开始，所以字符串的下标要减去1）

- $f[i][j - 1]$ 表示$s1$第$i$个字符与空格比较

- $f[i - 1][j]$ 表示$s2$第$j$个字符与空格比较

预处理：

```c++
for (int i = 1; i <= s1.length(); i++) {
	f[i][0] = f[i - 1][0] - 2;
}
for (int i = 1; i <= s2.length(); i++) {
	f[0][i] = f[0][i - 1] - 2;
}
```

即$s1$全部和空格比较，$s2$全部和空格比较

如果懂的话就可以自己写了，否则可能对你的收获不大

还没懂的把上面的代码瞎搞在一起，在自己理解一下，差不多就懂了

注意忽略大小写，否则`70pts`

## 代码

```c++
#include <bits/stdc++.h>

#define MAXN 1010

using namespace std;

string s1, s2;

int l1, l2;

int f[MAXN][MAXN];

int main() {
	cin >> s1 >> s2;
	l1 = s1.length();
	l2 = s2.length();
	
	//忽略大小写 
	for (int i = 0; i < l1; i++) {
		if (s1[i] < 97) s1[i] += 32;
	}
	for (int i = 0; i < l2; i++) {
		if (s2[i] < 97) s2[i] += 32;
	}
	
	//预处理 
	f[0][0] = 0;
	for (int i = 1; i <= l1; i++) {
		f[i][0] = f[i - 1][0] - 2;
	}
	for (int i = 1; i <= l2; i++) {
		f[0][i] = f[0][i - 1] - 2;
	}
	
	//动态规划 
	for (int i = 1; i <= l1; i++) {
		for (int j = 1; j <= l2; j++) {
			int match = 0;
			if (s1[i - 1] == s2[j - 1]) match = 1;
			f[i][j] = max(f[i - 1][j] - 2, f[i][j - 1] - 2);
			f[i][j] = max(f[i][j], f[i - 1][j - 1] + match);
		}
	}
	
	cout << f[l1][l2] << endl;
	return 0;
}

```

> 日拱一卒，功不唐捐




---

## 作者：FLYing (赞：8)

看到没人发就先占个坑
首先看到这道题目还是容易想到dp的，总觉着跟 最长公共子序列 有一点出入，然后这类字符串的dp有一点"套路"，其中一个状态表示第一个字符串匹配到的位置，另一个状态表示第二个字符串的位置，

Fij表示第一个字符串匹配到i，第二个字符串匹配到j的最优值。

那么ij有几种情况来转移呢？首先就是i和j作为位置有3种情况：

（1）	i不变，j向后走一个，则值-2

（2）	j不变，i向后走一个，则值-2

（3）	i，j同时向后一个，则当i和j字符相同时值+1，否则不变

3种情况取一个最大的进行转移：

f[i][j]=max(f[i-1][j-1]+(s1[i]==s2[j]?1:0),f[i-1][j]-2,f[i][j-1]-2)

对于这类dp一时不理解的话建议再好好理解一下最长公共子序列。然后画个二维矩阵自己推一下。

![](http://imgsrc.baidu.com/forum/pic/item/bdc5d082b9014a90bdebc3f9a4773912b11beef4.jpg)

Dp方程有了，剩下就是初始值，可以把F0j和Fi0全部设为{0,-2,-4,-6……}。但更方便的直接把f数组初始化为-INF然后这些初始状态都能顺利被转移得到了。

就因为一些小细节一直Wa，居然被逼到对拍…

【暴力代码】
```cpp
#include<cstdio>
#include<cstring>
#define maxn 1039
using namespace std;
char s1[maxn], s2[maxn];
int ans = -1e10, l1, l2;
int max(int a, int b){return a>b?a:b;}
void dfs(int i, int j, int sco){
    if(i>l1&&j>l2){
        ans = max(ans, sco);
        return;
    }
    if(i>l1){
        dfs(i,j+1,sco-2);
        return;
    }
    if(j>l2){
        dfs(i+1,j,sco-2);
        return;
    }
    dfs(i, j+1, sco-2);
    dfs(i+1, j, sco-2);
    dfs(i+1, j+1, sco+(s1[i]==s2[j]&&i&&j?1:0));
}
int main(){
    //freopen("1.in", "r", stdin);
    //freopen("2.out", "w", stdout);
    scanf("%s%s", s1+1, s2+1);
    l1 = strlen(s1+1);l2 = strlen(s2+1);
    dfs(0, 0, 0);
    printf("%d", ans);
    return 0;
}
```

【傻不拉几AC代码】
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define maxn 1039
using namespace std;
int f[maxn][maxn], ans=-1e10;
char s1[maxn], s2[maxn], sco;
int max(int a, int b, int c){
	if(a>b)return a>c?a:c;
	else return b>c?b:c;
}
int max(int a, int b){
	return a>b?a:b;
}
int main(){
	//freopen("1.in", "r", stdin);
	//freopen("1.out", "w", stdout);
	scanf("%s%s", s1+1, s2+1);
	int l1 = strlen(s1+1);int l2 = strlen(s2+1);
	int l = max(l1, l2);
	int tmp = 0;
	for(int i = 0; i < l+1; i++){
		f[i][0] = tmp;
		f[0][i] = tmp;
		tmp-=2;
	}
	for(int i = 1; i < l1+1; i++)
		for(int j = 1; j < l2+1; j++){
			if(s1[i]==s2[j])sco = 1;
			else sco = 0;
			f[i][j] = max(f[i-1][j-1]+sco, f[i-1][j]-2, f[i][j-1]-2);
		}
	/*for(int i = 0; i < l1+1; i++){
		for(int j = 0; j < l2+1; j++){
			printf("%d ", f[i][j]);
		}
		printf("\n");
	}*/
	ans = max(ans, f[l1][l2]);
		
	printf("%d", ans);
	return 0;
}
```


---

## 作者：Exber (赞：3)

## 题意
- #### 给你两个字符串，可以在字符串的任意地方插入空格。
- #### 两个字符串同一个位置上的字符相同可以加一分，不同则加零分；空格和字符在同一个位置则扣两分。
- #### 对于给定的两个字符串，求出他们最大的得分。

## 做法
二维 DP。

这道题其实和 [P1140 相似基因](https://www.luogu.com.cn/problem/P1140) 很像，只不过字符串长度要自己求而已。

为了方便，我们可以把 ```ACGT``` 分别对应 ```1234```，把空格当作 ```5```。再用一个表 $f$ 来存得分，$f_{i,j}$ 表示 $i$ 和 $j$ 匹配时的得分，那么这个表的代码就是：

```cpp
int f[6][6]=
{
	{0,0,0,0,0,0},
	{0,1,0,0,0,-2},
	{0,0,1,0,0,-2},
	{0,0,0,1,0,-2},
	{0,0,0,0,1,-2},
	{0,-2,-2,-2,-2,-2}
};
```

然后，我们定义 $dp_{i,j}$ 为第一个字符串匹配到 $i$，第二个字符串匹配到 $j$ 的最大得分，那么最后输出 $dp_{lena,lenb}$ 就行了（$lena$ 和 $lenb$ 分别表示输入的两个字符串的长度）。

状态转移方程也显而易见。对于 $dp_{i,j}$，可以从三个状态转移。分别是：当前位置不加空格、第一个字符串在当前位置加空格和第二个字符串在当前位置加空格。

当前位置不加空格的情况很好理解，$dp_{i,j}=dp_{i-1,j-1}+f_{a_i,b_j}$ 即可（$a$ 和 $b$ 表示两个字符串转化成数字后的数组）。

对于第一个字符串在当前位置加空格的情况，状态转移方程就是 $dp_{i,j}=dp_{i,j-1}+f_{5,b_j}$。

而对于第二个字符串在当前位置加空格的情况，状态转移方程就是 $dp_{i,j}=dp_{i-1,j}+f_{a_i,5}$。

综上，状态转移方程便是 $dp_{i,j}=\max(dp_{i-1,j-1}+f_{a_i,b_j},dp_{i,j-1}+f_{5,b_j},dp_{i-1,j}+f_{a_i,5})$。

边界情况也很好想。当 DP 数组的某一维下标为 ```0``` 时，便表示有一个字符串全是空格，得分一直累加 ```-2``` 就行了。实现详见代码。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int f[6][6]= // 得分表 
{
	{0,0,0,0,0,0},
	{0,1,0,0,0,-2},
	{0,0,1,0,0,-2},
	{0,0,0,1,0,-2},
	{0,0,0,0,1,-2},
	{0,-2,-2,-2,-2,-2}
};

int la,lb;
char s1[1005],s2[1005];
int a[1005],b[1005];
int dp[1005][1005];

int main()
{
	scanf("%s%s",s1+1,s2+1);
	la=strlen(s1+1);
	lb=strlen(s2+1);
	// 字符串->整形数组转换 
	for(int i=1;i<=la;i++)
	{
		if(s1[i]=='A'||s1[i]=='a') a[i]=1; 
		if(s1[i]=='C'||s1[i]=='c') a[i]=2; 
		if(s1[i]=='G'||s1[i]=='g') a[i]=3; 
		if(s1[i]=='T'||s1[i]=='t') a[i]=4; 
	}
	for(int i=1;i<=lb;i++)
	{
		if(s2[i]=='A'||s2[i]=='a') b[i]=1; 
		if(s2[i]=='C'||s2[i]=='c') b[i]=2; 
		if(s2[i]=='G'||s2[i]=='g') b[i]=3; 
		if(s2[i]=='T'||s2[i]=='t') b[i]=4; 
	}
	// 初始化 
	for(int i=1;i<=la;i++)
	{
		dp[i][0]=dp[i-1][0]+f[a[i]][5]; // 一直累加 -2 
	}
	for(int i=1;i<=lb;i++)
	{
		dp[0][i]=dp[0][i-1]+f[5][b[i]]; // 一直累加 -2 
	}
	for(int i=1;i<=la;i++)
	{
		for(int j=1;j<=lb;j++)
		{
			dp[i][j]=max(dp[i-1][j-1]+f[a[i]][b[j]],max(dp[i][j-1]+f[5][b[j]],dp[i-1][j]+f[a[i]][5])); // 状态转移
		}
	}
	printf("%d\n",dp[la][lb]); // 输出结果 
	return 0;
}
```


---

## 作者：天才颓废学家 (赞：3)

# 我人都傻了！
![血泪史1](https://cdn.luogu.com.cn/upload/image_hosting/xwg0v8qi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
![血泪史2](https://cdn.luogu.com.cn/upload/image_hosting/k4l1475b.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
![血泪史3](https://cdn.luogu.com.cn/upload/image_hosting/w5bek3f3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
### AWSL
# 好了，切入正题
这是一道构$(rang)$思$(sheng)$非$(wu)$常$(lao)$地$(shi)$巧$(zhua)$妙$(kuang)$的题。
## 题目大意
题目大意是：给你两个字符串，可以在其中任加空格。
在对应位置上

> + 是相同字母 => 加一分
> + 是不同字母 => 不得分
> + 是空格对字母/字母对空格 => 扣两分

求最大得分。(你谷中似乎有不少类似将一个字符串变成另一个，求最小代价之类的，有空可以找来做做)
#### 注意：两字符串长度可能不同！
#### 注意：字符串长度可能达到$1000$，所以要开$ansistring (Pascal)$
## 具体做法
### 做法一：暴力！
通过 01枚举/DFS/BFS 来枚举每一位上加不加空格，求每一种情况中的最优值。

时间复杂度：$Θ(2^n)$。

预期得分：玄学
### 做法二：萎大的DP！
我们用两维来描述状态：$f[i,j]$表示当字符串1处理到第$i$位，字符串2处理到第$j$位时的最大得分。由题意可得两种情况：
>>+ 在当前位加空格
>>+ 不在当前位加空格

由此可得转移方程：
#### $f[i,j]:=max(f[i-1,j]-2,f[i,j-1]-2);$
#### $f[i,j]:=max(f[i,j],f[i-1,j-1]+tt);$
(当两位字符相同时，tt=1；当两位字符不同时，tt=0)
#### 综上可得DP代码
```
// shei ga ga 666
//拒绝math库，从我做起！
type
 longlong=int64;
 ll=longlong;
 int=longint;
 bool=boolean;
 float=real;
 qwq=qword;
 str=ansistring;
 arr=array[0..2900,0..2900] of int;
 arrr=array[0..290001] of float;
var // 石马风太丑，亲见谅。
 s1,s2:str;
 f:arr;
 i,j,len1,len2,tt:int;
function max(a,b:int):int;
begin
 if a>b then exit(a)
  else exit(b);
end;
begin
 readln(s1);
 readln(s2);
 s1:=upcase(s1); // 这个函数的作用是将字符串的小写字母全部转为大写字母。
 s2:=upcase(s2); // 说实话做字符串的题，Pascal比C++好用。
 len1:=length(s1);
 len2:=length(s2); // 记录字符串长度
 fillchar(f,sizeof(f),0);
 for i:=1 to len1+1 do
  f[i,0]:=f[i-1,0]-2;
 for i:=1 to len2+1 do
  f[0,i]:=f[0,i-1]-2; // 赋初始值。
 for i:=1 to len1 do
  for j:=1 to len2 do // DP循环。
   begin
    tt:=0;
    if s1[i]=s2[j] then tt:=1;
    f[i,j]:=max(f[i-1,j]-2,f[i,j-1]-2); // 转移方程，不再赘述。
    f[i,j]:=max(f[i,j],f[i-1,j-1]+tt);
   end;
 writeln(f[len1,len2]); // 根据定义，输出结果
end.
```
## [终于，终于啊！](https://www.luogu.com.cn/record/39325737)
好了，本篇题解到这里差不多就结束啦，希望对大家有一定的帮助，如有不懂或文本错误，请私信我。
%%%dalao再见%%%

---

## 作者：Ravener (赞：1)

一道~~古早~~ dp 题。

为了~~偷懒~~方便表示，用 $a,b$ 代指第一、二条 DNA，用 $\mathit{dp} _ {i,j}$ 表示 $a$ 截止到 $a_i$、$b$ 截止到 $b_j$ 的最大得分，用 $a_{len},b_{len}$ 表示 $a,b$ 的长度。

------------

首先，把转移情况分为三种：  
1. $a_i,b_i$ 都不插空，此时 $a_i$ 与 $b_i$ 对应；
>当 $a_i=b_i$，即 $a_i$ 与 $b_i$ 对上时，得 1 分；对不上时，不得分。  
>因此状态方程为 $\mathit{dp} _ {i,j}=\mathit{dp} _ {i-1,j-1}+k$，其中 $a_i=b_i$ 时 $k=1$，反之则为 0。
2. $a_i$ 插空，此时 $-$（空白）与 $b_i$ 对应；
>对上 $-$ 时，倒扣 2 分。  
>实际上，这相当于在 $\mathit{dp} _ {i-1,j}$ 的基础上扣了两分。  
>不难得出状态方程为 $\mathit{dp} _ {i,j}=\mathit{dp} _ {i-1,j}-2$。
3. $b_i$ 插空，此时 $-$（空白）与 $a_i$ 对应。
>推导思路同上，状态方程为 $\mathit{dp} _ {i,j}=\mathit{dp} _ {i,j-1}-2$。

综合一下上面的转移方程，可得：
$$\mathit{dp} _ {i,j}=\max (\mathit{dp} _ {i-1,j-1}+k,\mathit{dp} _ {i-1,j}-2,\mathit{dp} _ {i,j-1}-2)$$
输出 $\mathit{dp} _ {a_{len},b_{len}}$ 即可。  

------------

下面来解决边界问题。

1. 如果 $a$ 为全空，那么转移方程为 $\mathit{dp} _ {0,j}=\mathit{dp} _ {0,j-1}-2$；
2. 如果 $b$ 为全空，那么转移方程为 $\mathit{dp} _ {i,0}=\mathit{dp} _ {i-1,0}-2$；

容易想到 $\mathit{dp} _ {0,0}=0$，因此边界只需要逆推上式就能一一算出。

------------

上 die 码：
```cpp
int main()
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(dp,0,sizeof(dp));
	cin>>a>>b;
	while(a[lena]) lena++;
	while(b[lenb]) lenb++;
	for(int i=1;i<=lena;i++)
		dp[i][0]=dp[i-1][0]-2;
	for(int i=1;i<=lenb;i++)//处理边界
		dp[0][i]=dp[0][i-1]-2;
	for(int i=1;i<=lena;i++)
		for(int j=1;j<=lenb;j++)//方程转移
		{
			ll ok=1;
			if(a[i-1]!=b[j-1]) ok=0;
			dp[i][j]=max(max(dp[i][j-1]-2,dp[i-1][j]-2),dp[i-1][j-1]+ok);
		}
	print(dp[lena][lenb]);
}
```

可是上面那份没有统一大小写，因此只有 [60 分](https://www.luogu.com.cn/record/163014239)。  
而不统一大小写的后果：
>若 $a_i=\texttt{A},b_i=\texttt{a}$，此时 $a_i \ne b_i$，得 0 分；  
>但是题目说**有相同的核苷酸对**，得 1 分，即 ``A`` 与 ``a`` 可以配对，这里就造成了错误。

因此，我们要先统一大小写，然后开始用 dp。

关于统一大小写，我们会想到 ``strlwr()`` 和 ``strupr()``。

而 ``strlwr()`` 和 ``strupr()`` 不是标准库函数，不能在 Linux 系统使用，会 [CE](https://www.luogu.com.cn/record/163014503)。  

想把字符串统一大小写只能一个一个转（当然重新定义函数也并非不行）。

[AC 记录](https://www.luogu.com.cn/record/163015372)。

~~（话 Y 音：没写 ``rt 0``，习惯不好，该罚！不放真正的代码，再罚！）~~

---

## 作者：sipu6174 (赞：1)

看其余两位都是直接动归，这里我来一份记忆化搜索的代码

思路跟他们相仿，这里我就不赘述了

```cpp
#include<bits/stdc++.h>
#define inf 1e8
using namespace std;
int m,n,x[1105],y[1105];
char xx[1105],yy[1105];
int mem[2205][2205],mem1[2205][2205];
int dfs(int a,int s)
{
    int p,q,r,w;p=q=r=w=-inf;//因为最大值可能为负,返回值为这四种情况的最大值
    if(mem[a][s])return mem[a][s];//记忆化
    if(a>=m&&s>=n)return 0;//边界条件  
    if(a<m&&s<n&&xx[a]==yy[s]) p=1+dfs(a+1,s+1);//配对且相同
    if(a<m&&s<n&&xx[a]!=yy[s]) w=dfs(a+1,s+1);//配对但不相同
    if(s<n)q=dfs(a,s+1)-2;
    if(a<m)r=dfs(a+1,s)-2;//在左边或右边插入“-”
    mem[a][s]=max(max(p,q),max(r,w));
    return mem[a][s];
}
int main()
{
    cin>>xx>>yy;
    m=strlen(xx);
    n=strlen(yy);
    cout<<dfs(0,0);
    return 0;
}
```



---

## 作者：array2022 (赞：0)

### 题目分析
- 阅读题面之后我们很容易想到可以使用动态规划。设 $dp\left(i,j\right)$ 为 $T_1$ 的前 $i$ 个核苷酸与 $T_2$ 的前 $j$ 个核苷酸配对的最大得分。
- 我们在加入 $T_1$ 的第 $i$ 个核苷酸或 $T_2$ 的第 $j$ 个核苷酸时，有下面几种选择：
- 1. 不加入多于的空格，得分为 $dp\left(i-1,j-1\right)+\begin{cases}1,&T_{1,i}=T_{2,j}\\0,&T_{1,i}\ne T_{2,j}\end{cases}$。
  2. 在 $T_1$ 的第 $i$ 个核苷酸后面加入空格，让它和 $T_2$ 的第 $j$ 个核苷酸配对，得分为 $dp\left(i,j-1\right)-2$。
  3. 在 $T_2$ 的第 $j$ 个核苷酸后面加入空格，让它和 $T_1$ 的第 $i$ 个核苷酸配对，得分为 $dp\left(i-1,j\right)-2$。
- 综上所述，我们有状态转移方程 $dp\left(i,j\right)=\max \left\{ dp\left(i-1,j-1\right)+n,dp\left(i,j-1\right)-2,dp\left(i-1,j\right)-2\right\}$，其中 $n=\begin{cases}1,&T_{1,i}=T_{2,j}\\0,&T_{1,i}\ne T_{2,j}\end{cases}$。
- 接下来就是初始化的问题了，显然有 $dp\left(0,i\right)=dp\left(i,0\right)=-2i$。

### 通过代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int dp[1005][1005];
signed main(){
	ios::sync_with_stdio(0);
	cin>>a>>b;
	a=' '+a, b=' '+b; // 个人习惯，由于 string 下标从零开始所以在最前面加一个空格。
	for (int i=1;i<a.size();i++){
		a[i]=toupper(a[i]); // STL 的大小写转化，当然也可以自己写。
		dp[i][0]=i*(-2);
	}
	for (int i=1;i<b.size();i++){
		b[i]=toupper(b[i]);
		dp[0][i]=i*(-2);
	} // 初始化。
	for (int i=1;i<a.size();i++){
		for (int j=1;j<b.size();j++){
			dp[i][j]=max(dp[i-1][j-1]+(a[i]==b[j]),max(dp[i][j-1]-2,dp[i-1][j]-2));
		}
	} // 动态规划。
	cout<<dp[a.size()-1][b.size()-1];
	return 0;
}
```
------
### 闲话
[P1140](https://luogu.com.cn/problem/P1140) 与本题很类似。

---

## 作者：4041nofoundGeoge (赞：0)

动态规划模板题，相对来说只要抽象概念就可以做出来。

## 动态规划

动态规划（Dynamic Programming，简称 DP）通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与贪心类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。**只要使用动态规划，求出来的一定是最优解**。有一类题目看似可以使用贪心算法解决问题，实则无法达到满分，因为**贪心考虑当前最优解，动态规划考虑整体最优解。**

动态规划使用了一种打表的思想，具体内容请参考 [OI WIKI](https://oi-wiki.org/dp/basic/)。

## 题目思路

首先这道题肯定不是用贪心解决的问题，反而更像是用动规解决的（用贪心会爆 $0$，别问我是怎么知道的）。题目中有三种变化方法，我们可以设计动态规划，设 $dp_{i,j}$ 为 $T_1$ 前 $i$ 位和 $T_2$ 前 $j$ 位的最大评分。那动态转移方程该怎么列呢？题目说：

> 1. 一个同样的位置上有相同的核苷酸对，则可得 $1$ 分；
> 2. 一个同样的位置上有不同的核苷酸对，则得 $0$ 分；
> 3. 如果在某个位置上一个序列有核苷酸，而另一个序列在该位置上为 $-$，则得 $-2$ 分。例如，比对一的得分是 $0$ 分，比对二的得分是 $3$ 分。

条件 $1$ 和 $2$ 好列，相等加 $1$，反之加 $0$（注意**下标从 $0$ 开始所以是 $dp_{i-1,j-1}$**），即 $dp_{i,j}=dp_{i-1,j-1}+f(s_{i-1},s_{j-1})$，其中 $f(s_{i-1},s_{j-1})=\begin{cases}1 &\text{if }s_{i-1}=s_{j-1} \\0 &\text{if }s_{i-1}\not=s_{j-1}\end{cases}$。条件 $3$ 可以想象成字符要与空格比较，所以方程为 $\max( f_{i,j - 1}-2,f_{i - 1,j}-2)$。

把两个方程组合得到：

$$
dp_{i,j}=\max^{i\le x,j\le y}_{i=1,j=1}(dp_{i-1,j-1}+f(s_{i-1},s_{j-1}),f_{i,j - 1}-2,f_{i - 1,j}-2)
$$

其中 $f(s_{i-1},s_{j-1})=\begin{cases}1 &\text{if }s_{i-1}=s_{j-1} \\0 &\text{if }s_{i-1}\not=s_{j-1}\end{cases}$，$x$、$y$ 分别为 $T_1$、$T_2$ 的长度。

方程都列出来了问题就好解决了。

### 细节问题

1. 题目中不区分大小写所以最开始要统一成小写，用 tolower 函数。
2. 下标为 $0$ 的地方肯定是要减 $2$ 的，所以初始化时下标为 $0$ 要减 $2$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string a, b;
int f[1010][1010];
int main()
{
    cin >> a >> b;
    int lena = a.size();
    int lenb = b.size();
    // 转小写
    for (int i = 0; i < lena; i++)
        tolower(a[i]);
    for (int i = 0; i < lenb; i++)
        tolower(b[i]);
    // 初始化
    f[0][0] = 0;
    for (int i = 1; i <= lena; i++)
        f[i][0] = f[i - 1][0] - 2;
    for (int i = 1; i <= lenb; i++)
        f[0][i] = f[0][i - 1] - 2;
    for (int i = 1; i <= lena; i++) {
        for (int j = 1; j <= lenb; j++) {
            // 动态转移方程
            f[i][j] = max({ f[i - 1][j] - 2, f[i][j - 1] - 2, f[i - 1][j - 1] + (a[i - 1] == b[j - 1]) });
        }
    }
    cout << f[lena][lenb] << endl;
    return 0;
}
```

---

## 作者：dsj2012 (赞：0)

# 题目简化
给定两个字符串，你可以在任意一个地方插入一个空格。你需要求出这两个字符串能获得的最大得分是多少。

加分是两个字符串在同一个位置上的字符相等，可以加一分。如果两个字符的同一个字符上的字符不同，则不加分。空格和字符在同一个位置则扣两分。
# 思路
首先我们来考虑动态规划。

那么我们的 $dp_{ij}$ 所表示的含义就是，第一个字符串的前面 $i$ 个字符，与第二个字符串中的前面 $j$ 个字符进行匹配能够得到的最大评分。

首先我们知道如果是空格和字符在一起的话就要 $-2$ 所以我们就可以先把两个字符分别于空格比较的情况求出来。

接下来我们就考虑 $s1_i$ 和 $s2_j$ 是否匹配的情况，如果匹配则加上 $1$ 否则不变。

但是我们是可以插入空格的所以你要把这里插入空格的值也要算上，在这些值中去一个最大值。

最后我们是知道 $dp$ 的含义的，那么答案在哪一个位置呢，那就是 $s1$ 的所有字符和 $s2$ 的所有字符，在 $dp$ 中是 $dp_{len1\ len2}$。

注意：

首先我们的循环是不能从 $0$ 开始的，因为我们会做减法从 $0$ 开始会越界。所以要从 $1$ 开始。

然后我们的字符串要在前面加一个空格。不然，你会少算第一个字符，多算一个不存在的字符。当然你直接减去 $1$ 也是可以的。

最后一点，这道题是不用看大小写的所以你要把所有字符要么改成大写要么改成小写。
## code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int dp[1005][1005];
string check(string s){
	for(int i = 0 ; i < s.size() ; i ++){
		if(s[i] >= 'A' && s[i] <= 'Z'){
			s[i] = s[i] - 'A' + 'a';
		}
	}
	return s;
}
int main(){
	cin >> s1 >> s2;
	s1 = check(s1);
	s2 = check(s2);
	int len1 = s1.size();
	int len2 = s2.size();
	for(int i = 1 ; i <= max(len1 , len2) ; i ++){
		dp[0][i] = dp[0][i - 1] - 2;
		dp[i][0] = dp[i - 1][0] - 2;
	}
	s1 = " " + s1;
	s2 = " " + s2; 
	for(int i = 1 ; i <= len1 ; i ++){
		for(int j = 1 ; j <= len2 ; j ++){
			if(s1[i] == s2[j]){
				dp[i][j] = max(max(dp[i - 1][j] - 2 , dp[i][j - 1] - 2) , dp[i - 1][j - 1] + 1);
			}else{
				dp[i][j] = max(max(dp[i - 1][j] - 2 , dp[i][j - 1] - 2) , dp[i - 1][j - 1]);
			}
		}
	}
	cout << dp[len1][len2] << endl;
	return 0;
}
```

---

## 作者：Dream_yck (赞：0)

这道题我调了好久才调出来，悲惨

讲一讲思路吧！
 正经点！


 $f[i][j]$ 表示第一个字符匹配到 $i$ 的，第二个字符匹配到 $j$ 的最优值。
 

 $f[i][j]$ 有三种情况转移：

 
第一种是 $i$ 不变 ， $j$ 向后移一格，则值减二。（如题：如果在某个位置上一个序列有核苷酸，而另一个序列在该位置上为“--”，则减 $2$ 分。例如，比对 $1$ 的得分是 $0$ 分，比对 $2$ 的得分是 $3$ 分。）

代码如下：

```
f[i][j]=f[i][j-1]-2
```

第二种是 $j$ 不变， $i$ 向后移一格，则值减二。（如题：如果在某个位置上一个序列有核苷酸，而另一个序列在该位置上为“--”，则减 $2$ 分。例如，比对 $1$ 的得分是 $0$ 分，比对 $2$ 的得分是$3$ 分。）

代码如下：
```
f[i][j]=f[i-1][j]-2
```

第三种是 $i$ , $j$ 同时向后移一格，当两串相同时加 $1$ ，否则，不更新值。

代码如下：
```
f[i][j]=f[i-1][j-1]+(s1[i]==s2[j]?1:0)
```
结合之后状态转移方程就产生了！
```
f[i][j]=max(f[i-1][j-1]+(s1[i]==s2[j]?1:0),f[i-1][j]-2,f[i][j-1]-2)
 ```


下面直接上代码：


```cpp
#include<bits/stdc++.h>  //个人喜欢万能头和scanf&&printf
int f[1001][1001],ans=INT_MIN,flag;
char s1[1001],s2[1001];
int max(int a,int b,int c){return std::max(a,std::max(b,c));}
int main(){
    scanf("%s%s",s1+1,s2+1);
    int l1=strlen(s1+1);int l2=strlen(s2+1),tmp=0,l = std::max(l1,l2);
    for(int i=0;i<l+1;i++){
    	f[i][0]=tmp;
    	f[0][i]=tmp;
    	tmp-=2;
	}f[0][0] = 0;
    for(int i = 1; i < l1+1; i++)
        for(int j = 1; j < l2+1; j++){
            if(s1[i]==s2[j])flag = 1;
            else flag = 0;
            f[i][j] = max(f[i-1][j-1]+flag, f[i-1][j]-2, f[i][j-1]-2);
        }
    ans = std::max(ans, f[l1][l2]);
    printf("%d", ans);
    return 0;
}
```

---

## 作者：_xdd_ (赞：0)

简单 DP 题。$c1$ 和 $c2$ 分别表示两个字符串。

设 $f_{i,j}$ 为 $c1$ 的前 $i$ 个字符和 $c2$ 的前 $j$ 个字符的最大得分。

转移方程很明显，$f_{i,j} \leftarrow \max(f_{i-1,j-1}+x,f_{i,j-1}-2,f_{i-1,j}-2)$，其中如果 $c1_{i-1}=c2_{j-1}$ 则 $x \leftarrow 1$ 否则  $x \leftarrow 0$。

核心代码很简单，遍历 $i$ 和 $j$ 即可，但是记得初始化问题。

---

## 作者：gyfydkf (赞：0)

刚写完[此题](https://www.luogu.com.cn/problem/P1140)后马上就回来写了这题。

## 思路

1. 两个字符串对应两个状态，$f_{i,j}$ 表示第一个字符串 $a$ 前 $i$ 个字符与第二个字符串 $b$ 前 $j$ 个字符比对后的最大得分。

1. 一共有四种情况：

- $a_i$ 与 $b_j$ 比对，并且 $a_i$ 与 $b_j$ 相同；

- $a_i$ 与 $b_j$ 比对，并且 $a_i$ 与 $b_j$ 不同；

- $a_i$ 与 $b_j$ 没有比对上，$a_i$ 与 ‘—’ 对上了；

- $a_i$ 与 $b_j$ 没有比对上，$b_j$ 与 ‘—’ 对上了；

3. - 所以 $a_i$ 与 $b_j$ 比对上时，可以设置一个变量 d，若$a_i=b_j$，则 d 为 1，否则为 0，故 $f_{i,j}$ 可以由  $f_{i-1,j-1}+d$ 转移而来。（$a$ 字符串前 $i-1$ 个字符与 $b$ 字符串前 $j-1$ 个字符比对后的最大得分加上 $a_i$  与 $b_j$ 贡献的得分）

   - 而 $a_i$ 与 $b_j$ 没有比对上时，则 $f_{i,j}$ 由 $f_{i-1,j}-2$ 与$f_{i,j-1}-2$转移而来。（$a_i$ 对上 ‘—’ 时，贡献由 $a$ 字符串前 $i-1$ 个字符与 $b$ 字符串前 $j$ 个字符比对后的最大得分再加上此次得分 -2 得出；$b_j$ 对上 ‘—’ 时同理）

1. 所以得出状态转移方程：

$\large f_{i,j}=\max(\max(f_{i-1,j}-2,f_{i,j-1}-2),f_{i-1,j-1}+d)$

5. 确定边界，当 0 个 $a$ 字符串字符与 $j$ 个 $b$ 字符串字符匹配时，贡献为$j*(-2)$；而当 $i$ 个 $a$ 字符串字符与 0 个 $b$ 字符串字符匹配时，贡献为 $i*(-2)$。

1. 结果为 $f_{n1,n2}$。

## 代码：

```
#include<bits/stdc++.h>
using namespace std;
string t1,t2;
char a[1005],b[1005];
int dp[1005][1005];
int main(){
	cin>>t1>>t2;
	int n1=t1.length();
	int n2=t2.length();
	for(int i=1;i<=n1;i++)a[i]=t1[i-1];//图方便存的，因为从0开始循环有点难处理边界，菜鸡不想动脑了 
	for(int i=1;i<=n2;i++)b[i]=t2[i-1];
	dp[0][0]=0;
	for(int i=1;i<=n2;i++)dp[0][i]=dp[0][i-1]-2;
	for(int i=1;i<=n1;i++)dp[i][0]=dp[i-1][0]-2;//处理边界 
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=n2;j++){
			int d=0;
			if(a[i]==b[j])d=1;
			dp[i][j]=max(max(dp[i][j-1]-2,dp[i-1][j]-2),dp[i-1][j-1]+d);//状态转移 
		}
	}
	cout<<dp[n1][n2]; 
	return 0;
}
```

---


# 就是干！

## 题目背景

loidc 有着特别的作死技巧，但是有一天他特别的技巧失效了。

Mr.Cao 发现了他在与其他哲学家摔跤，于是 Mr.Cao 带着浩浩荡荡的老师大军来讨伐 Loidc。

## 题目描述

眼看着老师大军浩浩荡荡的向机房前进。LOI 的同学们决定动用自己的力量来保卫他们的好朋友 loidc。现在每个人都要挑选自己的武器——两根木棍。一根用做远距离投掷，另一根用做近距离搏斗。每个人都想挑到最好的，但这是不可能的。但是为了让多数人满意，也为了减少大家的矛盾。cony 设计了一个矛盾指数，这个指数就是每个人的不舒服指数和，不舒服指数就 $(L1-L2)^2$，其中 $L1,L2$ 分别是两根木棍的长度。

cony 决定让矛盾指数最少，于是他来向你寻求帮助，希望你能告诉他矛盾指数至少有多少。

## 说明/提示

$m \leq 2000,n \leq 500$

## 样例 #1

### 输入

```
5 2
3
1
4
5
8
```

### 输出

```
5```

# 题解

## 作者：Sirius_X (赞：8)

本题题意易懂，就是让我们求** 在一个有m个元素的集合中，找出使每对元素之间差的平方最小的n对元素(n对元素中的每个元素互不相等) **。
### 数学模型：
 $a_1,a_2,a_3,\cdots,am $
 
 $min\sum\limits_{k=1}^{n}(a_{k_1}-a_{k_2})^2(1\leq k_1<k2\leq n) $

因为木棍是杂乱无章的，所以我们先把木棍排序再来分析
### 贪心思路:
我们应该怎样取才能使差的平方最小呢？

设$a_1,a_2,a_3,a_4(a1\leq a2\leq a3\leq a4)$

$ sum1=(a_2-a_1)^2+(a_3-a_4)^2 $

$ sum2=(a_3-a_1)^2+(a_4-a_2)^2 $

$ sum3=(a_4-a_1)^2+(a_3-a_2)^2 $

显然 $ sum_1<sum_2\;,\;sum_1<sum_3 $

于是我们便可以得出 ** 取相邻的两个元素为一组可以保证差的平方最小 **

所以我们可以再将排完序后的每相邻两个元素之差的平方存储在dif数组里

### 动态规划：
现在我们已经得出只有取相邻两个木棍为一组，答案才能最小，但是接下来
怎么算呢？

** 设f[i][j]表示到第i个木棍时已经选了j组木棍的最小值 **
- ** 如果我们选a[i]和a[i-1]为一组，那么a[i-1]和a[i-2]就不可能选为一组（每组的元素不能重复），于是此时f[i][j]=f[i-2][j-1]+dif[i] **
- ** 如果我们不选a[i]这根木棍，那么此时f[i][j]=f[i-1][j] **

这两种情况中我们选较小值，于是我们便可得出状态转移方程为:
####  $ f[i][j]=min(f[i-2][j-1]+dif[i],f[i-1][j]) $ 
#### 时间复杂度：$ O(nm)$
#### 空间复杂度: $O(mn)$
### 代码:
`````C++
#include<cstdio>
#include<algorithm>
#include<cstring>
#define mn(x,y) x<y?x:y
using namespace std;
const int N=2010;
int a[N];//木棍
int dif[N];//记录排完序后相邻元素之差的平方
int f[N][510];//设f[i][j]表示到第i个木棍时已经选了j组木棍的最小值
template <class T> inline void read(T &);//快速读入函数声明
int main(){
	memset(f,0x3f,sizeof(f));//把f数组赋为无穷大
	int m,n,ans=1<<30;
	read(m);read(n);
	for(register int i=1;i<=m;++i)
		read(a[i]);
	sort(a+1,a+1+m);//排序
	for(register int i=2;i<=m;++i){//记录相邻元素之差的平方
		dif[i]=a[i]-a[i-1];
		dif[i]*=dif[i];
	}
	for(register int i=0;i<=m;++i)//因为选0组木棍的差的完全平方的和为0，所以把f[i][0]全部赋成0
		f[i][0]=0;
	for(register int i=2;i<=m;++i){
		for(register int j=1;j<=n;++j)
			f[i][j]=mn(f[i-1][j],f[i-2][j-1]+dif[i]);//状态转移
		ans=mn(ans,f[i][n]);//统计答案
	}
	printf("%d\n",ans);
	return 0;
}
template <class T> inline void read(T &num){//快速读入
	num=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9'){
		num=(num<<1)+(num<<3)+(c^48);
		c=getchar();
	}
}
`````

---

## 作者：YoungLove (赞：8)

[Youngsc](http://youngscc.github.io/) 

很显然当我们对木棍进行排序后，任意一个人选择的两个木棍之间的长度的木棍都不会被别人选择，那么进而推出任意一个人选择相邻的两个木棍会更优，这样就好做多了，由于时间复杂度，所以要用一个前缀维护的dp。

###代码在这里，比较丑。。


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <vector>
# include <cstdio>
# include <cmath>
# include <map>
# define R register
# define LL long long
# define db double

using namespace std;

int n,m,f[510][2010],dis[510][2010],a[2010],ans = 2147483647;

inline void in(R int &a){
    R char c = getchar();R LL x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0', c=getchar();
    a=x*f;
}

inline void minn(R int &a,const int b){a<b? :a=b;}

int main()
{
        in(n),in(m);
        memset(dis,127/3,sizeof(dis));
        memset(f,127/3,sizeof(f));
        for(R int i=1; i<=n; ++i) in(a[i]);
        sort(a+1,a+n+1);
        for(R int i=0; i<=n; ++i) dis[0][i] = 0;
        for(R int i=1; i<=m; ++i)
            for(R int j=i<<1; j<=n; ++j)
                minn(f[i][j],dis[i-1][j-2]+(a[j]-a[j-1])*(a[j]-a[j-1])),
                dis[i][j] = dis[i][j-1],
                minn(dis[i][j],f[i][j]);
        
        printf("%d",dis[m][n]);
        return 0;
}


# include <algorithm>
# include <iostream>
# include <cstring>
# include <vector>
# include <cstdio>
# include <cmath>
# include <map>
# define R register
# define LL long long
# define db double

using namespace std;

int n,m,f[510][2010],dis[510][2010],a[2010],ans = 2147483647;

inline void in(R int &a){
    R char c = getchar();R LL x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0', c=getchar();
    a=x*f;
}

inline void minn(R int &a,const int b){a<b? :a=b;}

int main()
{
        in(n),in(m);
        memset(dis,127/3,sizeof(dis));
        memset(f,127/3,sizeof(f));
        for(R int i=1; i<=n; ++i) in(a[i]);
        sort(a+1,a+n+1);
        for(R int i=0; i<=n; ++i) dis[0][i] = 0;
        for(R int i=1; i<=m; ++i)
            for(R int j=i<<1; j<=n; ++j)
                minn(f[i][j],dis[i-1][j-2]+(a[j]-a[j-1])*(a[j]-a[j-1])),
                dis[i][j] = dis[i][j-1],
                minn(dis[i][j],f[i][j]);
        
        printf("%d",dis[m][n]);
        return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：6)

观察发现，假设要选四根木棒长度分别为 $l_1\leq l_2\leq l_3\leq l_4$。

显然把 $l_1,l_2$ 分一起，$l_3,l_4$ 分一起比其他方法优。

于是，我们把木棍长度从小到大排。

假设 $f_{i,j}$ 表示前 $i$ 条木棒中，分给了 $j$ 人最小矛盾指数，可以得到：

$$f_{i,j}=\min(f_{i-1,j},f_{i-2,j-1}+(a_i-a_{i-1})^2)$$

时间复杂度 $\mathcal{O}(nm)$。

## 参考代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
const int MAXN=505;
int n,m;
ll a[4*MAXN];
ll f[4*MAXN][MAXN];
int main(){
	for(int i=1;i<MAXN;i++)
		f[0][i]=f[1][i]=8e18;
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		cin>>a[i];
	sort(a+1,a+m+1);
	for(int i=2;i<=m;i++){
		for(int j=1;j<=n;j++)
			f[i][j]=min(f[i-1][j],f[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]));
		f[i][0]=0;
	}
	cout<<f[m][n];
	return 0;
}
```


---

## 作者：RikoHere (赞：3)

虽然已经有人直接点明这是什么题了，但是我还是稍微解释一下吧，但上一篇太过于简洁，顺便写一写我的做法

1. 对于任意一根木棍，要最有效的利用它肯定是和大于他的最小木棍或小于他的最大木棍结合使用，排序一波然后把所有木棍进行一波简单的预处理 
```
for (int i = 1; i < m; ++i){
		tem[i] = (data[i]-data[i-1])*(data[i]-data[i-1]);
	}
```

2. ok现在所有的木棍都结合在了一起，用数组存了每两根木棍结合后的不满值，毫无疑问的，我们任意取用一组木棍，则这组木棍的前一组木棍都被禁用了

3. 为了避免重复特地给小朋友们写了较简单易理解的记忆化搜索，以还能用的木棍组数和boys的数量进行二维dp

4. 我们要求的是最小值，所以记得给状态附上初值

5. 最终结果可能为0所以要给没接触的状态的值要为-1

代码：（69ms）

很漂亮的~

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define LL long long
using namespace std;
int n, m, tem[2050], data[2050], ans[2050][2050];
const int INF = 999999999;
int solve(int stick, int boys)
{
	if (stick+1 < boys*2) return INF;
	if (stick == 0 and boys) return INF;
	if (boys == 0) return 0;
	if (ans[boys][stick] != -1) return ans[boys][stick];
	ans[boys][stick] = INF;
	ans[boys][stick] = min(solve(stick-1, boys), solve(stick-2, boys-1)+tem[stick]);
	return ans[boys][stick];
}
int main(){
	memset(ans, -1, sizeof(ans));
	scanf("%d %d", &m, &n);
	for (int i = 0; i < m; ++i){
		scanf("%d", &data[i]);
	}
	sort(data, data+m);
	for (int i = 1; i < m; ++i){
		tem[i] = (data[i]-data[i-1])*(data[i]-data[i-1]);
	}
	printf("%d", solve(m-1, n));
}
```

---

## 作者：渡鸦2007 (赞：2)

# 思路
观察此题，可尝试证明木棍长度越接近，矛盾指数越低。
## 证明
设木棍长度分别为 $l1$，$l2$，$l3$，$l4$ 且$l1$ $\leq$ $l2$ $\leq$ $l3$ $\leq$ $l4$。
设
则将 $l1$ 与 $l2$ 配对，$l3$ 与 $l4$ 配对。

矛盾指数为$l1^2+2 \cdot l1 \cdot l2+l2^2 +l3^2+2 \cdot l3 \cdot l4 +l4^2$    $(1)$

明显 $l1$ 、 $l3$ 与 $l2$ 、 $l4$ 的组合不如$l1$ 、 $l2$ 与 $l3$ 、 $l4$ 配对。

接下来讨论$l1$ 、 $l4$ 配对，$l2$ 、 $l3$ 配对。

矛盾指数为$l1^2+2 \cdot l1 \cdot l4+l4^2 +l2^2+2 \cdot l2 \cdot l3 +l3^2$	$(2)$

式 $(1)$ 减式 $(2)$ 得，$2 \cdot l1 \cdot l2+2 \cdot l3 \cdot l4-2 \cdot l1 \cdot l4-2 \cdot l2 \cdot l3$，明显 $(1)$ 式小于 $(2)$ 式。
故将其排序，每次讨论相邻的木棍。
## DP式
分两重循环，一重为木棍，一重为当前人数。
则$dp_{i,j}= \min (dp_{i-1,j},dp_{i-2,j-1}+now)$

其中， $dp_{i-1,j}$ 表示当前木棍不取，$dp_{i-2,j-1}$表示选择当前木棍时，之前的最小矛盾指数，$now$表示现在两根木棍的矛盾指数。
### DP代码
```cpp
for (register int i=2;i<=m;++i)//木头 
{
	for (register int j=1;j<=n;++j)//人数 
	{
		int now=pow(l[i]-l[i-1],2);//当前两根木棍的矛盾指数 
		dp[i][j]=min(dp[i-1][j],dp[i-2][j-1]+now);
	}
}
```
# 完整代码 （参考注释）
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int read()
{
	register int ans=0;
	char ch;
	bool flag=0;
	while(1)
	{
		ch=getchar();
		if (ch>='0'&&ch<='9')
		{
			break;
		}
		if (ch=='-')
		{
		   flag=1;
		}
	}
	while(1)
	{
		ans=ans*10+ch-'0';
		ch=getchar();
		if (ch<'0'||ch>'9')
		{
			break;
		}
	}
	if (flag==1)
	{
	   ans*=-1;
	}
	return ans;
}
int l[2021];//木棍长度 
int dp[2020][520];
int main()
{
	int n,m;//人、木棍
	m=read();n=read();//注意顺序！
	for (register int i=1;i<=m;++i)
	{
		l[i]=read(); 
	} 
	sort(l+1,l+m+1);
	memset(dp,0x3f,sizeof(dp));
	for (register int i=0;i<=n;++i)//注意初始化，0人的最小矛盾指数为0
	{
		dp[i][0]=0;
	}
	for (register int i=2;i<=m;++i)//木头 
	{
		for (register int j=1;j<=n;++j)//人数 
		{
			int now=pow(l[i]-l[i-1],2);//当前两根木棍的矛盾指数 
			dp[i][j]=min(dp[i-1][j],dp[i-2][j-1]+now);
		}
	}
	printf("%d",dp[m][n]);//顺序
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：天才颓废学家 (赞：2)

# **血的教训！**
```pascal
function min(a,b:int):int;
begin
 if a>b then exit(a)
  else exit(b);
end;
```
好了好了，总之，大家做题还是要仔细！~~（CSP千万别用math库）~~
# 拿到题目
  乍一看，啊哈，这不是裸裸的暴力吗？排个序，D个FS不就好了吗，这黄题好水啊。
###   就是干！
```pascal
var
 a,b:array[0..100000] of longint;
 n,m,i,ans:longint;
procedure sort(l,r:longint);
var
 i,j,x,y:longint;
begin
 i:=l; j:=r; x:=a[(l+r) div 2];
 repeat
  while a[i]<x do inc(i);
  while x<a[j] do dec(j);
  if not(i>j) then begin y:=a[i]; a[i]:=a[j]; a[j]:=y; inc(i); j:=j-1; end;
 until i>j;
 if l<j then sort(l,j);
 if i<r then sort(i,r);
end;
function min(a,b:longint):longint;
begin
 if a>b then exit(b)
  else exit(a);
end;
procedure dfs(t,s,k:longint);
var
 i:longint;
begin
 if k=n then begin ans:=min(ans,s); exit; end;
 for i:=t+1 to m do
  dfs(i+1,s+b[i],k+1);
end;
begin
 ans:=maxlongint div 2;
 readln(m,n);
 for i:=1 to m do
  readln(a[i]);
 sort(1,m);
 for i:=2 to m do
  b[i]:=sqr(a[i]-a[i-1]);
 dfs(1,0,0);
 writeln(ans);
end.
```
 [哇！](https://www.luogu.com.cn/record/38480424)
 
  ~~稻(kong)花(tiao)香(fang)里说(tan)丰(ti)年(nan)，听取TLE声一片~~
# 后来啊
  在经过深(jian)思(yue)熟(ti)虑(jie)后，我想到了另一种做法：
###   DP大法好！
  这里数据范围小，完全可以用二维DP(~~其实是我想不出来一维的)~~
  我们用f[i,j]来表示选到第i根时已有j人选好，那么，这就分为两种情况：选与不选，选就是(f[i-2,j-1]+b[i])，不选就是(f[i-1,j]);
###   所以，我们就得到了转移方程：**f[i,j]:=min(f[i-1,j],f[i-2,j-1]+b[i]);**
接下来就是细节问题了比如边界什么不拉不拉的，这里不再赘述，代码里有注释
### 就是干！
```pascal
// shei ga ga 666
//拒绝math库，从我做起！

type
 longlong=int64;
 ll=longlong;
 int=longint;
 bool=boolean;
 float=real;
 arr=array[-5..2000,-5..2000] of int;
 arrr=array[0..20000] of int;
————————————
以上忽略。。（纯属搞笑）
var
 n,m,i,j,ans:int;
 f:arr;
 a,b:arrr;
function min(a,b:int):int;
begin
 if a<b then exit(a)
  else exit(b);
end;//血的教训
procedure sort(l,r:longint);
var
 i,j,x,y:longint;
begin
 i:=l; j:=r; x:=a[(l+r) div 2];
 repeat
  while a[i]<x do inc(i);
  while x<a[j] do dec(j);
  if not(i>j) then begin y:=a[i]; a[i]:=a[j]; a[j]:=y; inc(i); j:=j-1; end;
 until i>j;
 if l<j then sort(l,j);
 if i<r then sort(i,r);
end;
begin
 readln(m,n);
 for i:=1 to m do
  read(a[i]);
 sort(1,m);//快排，注意是从小到大，由1到m
 fillchar(f,sizeof(f),$5f);
 fillchar(b,sizeof(b),0);
 for i:=0 to m do f[i,0]:=0; //初始值
 ans:=maxlongint div 2;
 for i:=2 to m do //要从2开始，因为每个人都要选两根
  b[i]:=sqr(a[i]-a[i-1]);
 //for i:=1 to m do 调试语句也很重要哦
  //writeln(a[i],' ',b[i]);
 for i:=2 to m do //理由同上
  begin
   for j:=1 to n do
    f[i,j]:=min(f[i-1,j],f[i-2,j-1]+b[i]); //动规方程
   ans:=min(ans,f[i,n]);
  end;
 {for i:=0 to m do
  begin
   for j:=1 to n do
    write(f[i,j],' '); //编程时把问题分成几个简单的小问题逐个解决，如果每一步都对了，那么整个程序也就对了
   writeln;
  end;}
 writeln(ans);
end.
```
今天的新闻联播到此结束，观众朋友们再会%%%

###### ~~p.s.这是蒟蒻第一次发题解，如有错误，望大佬指正%%%~~

---


# [SDOI2005] 位图

## 题目描述

现在我们给出一个 $n\ \times m$ 的单色位图，且该图中至少含有一个白色的像素。我们用 $(i,j)$ 来代表第 $i$ 行第 $j$ 列的像素，并且定义两点 $p_1=(i_1,j_1)$ 和 $p_2=(i_2,j_2)$ 之间的距离为：

$$d(p_1,p_2)=|i_1-i_2|+|j_1-j_2|$$

### 任务

请写一个程序，读入该位图，并对于每个像素，计算出离该像素最近的白色像素与它的距离。把结果输出。

## 样例 #1

### 输入

```
3 4
0 0 0 1
0 0 1 1
0 1 1 0```

### 输出

```
3 2 1 0
2 1 0 0
1 0 0 1```

# 题解

## 作者：hensier (赞：20)

[获得更好的阅读体验](https://shenyouran.github.io/P2335/)

这道题有多种解法，我们来逐一分析。

### $\color{green}\text{方法1：数组保存法}$

对于输入，我们不仅要输入屏幕，也要保存值为$1$，即白色的位置。我们把白色区域的每一个点都进行保存。

输入以后，我们计算每一个点到所有白点的距离，取其最小并输出。如果该区域已经为白点，即值为$1$，则直接输出$0$即可。

期望得分：$\color{#52C410}100$

时间消耗：$\color{#52C410}354\text{ms}$

程序过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/88h1yzqb.png)

代码解决：

```cpp
#include<bits/stdc++.h>
#define dist(x_1,x_2,y_1,y_2)abs(x_1-x_2)+abs(y_1-y_2)//定义两点之间的距离公式
using namespace std;
int n,m,white[22501][2],cnt;//white数组保存白点的坐标，cnt保存白点个数
bool screen[151][151];//screen数组保存屏幕，白色为1，黑色为0
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1,x;j<=m;j++)
        {
            scanf("%d",&x);
            screen[i][j]=x;//先给屏幕赋值
            if(x)//如果是白色的就执行
            {
                white[++cnt][0]=i;
                white[cnt][1]=j;
                //点数+1，并且把这个点的坐标进行赋值
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1,dis;j<=m;j++)
        {
            if(screen[i][j])//特判白点可以节省时间
            {
                printf("0 ");//不要漏掉空格
                continue;
            }
            dis=0x3f3f3f3f;//最小距离默认要很大
            for(int k=1;k<=cnt;k++)dis=min(dis,dist(i,white[k][0],j,white[k][1]));//每一次都取最小距离
            printf("%d ",dis);//输出找到的最小距离
        }
        putchar('\n');//换行用putchar更快一些
    }
    return 0;
}
```

### $\color{green}\text{方法2：深度优先搜索}$

这道题用深搜确实不是很合适，但是我们可以通过这题训练我们的搜索能力。

主要的思路就是由每一个黑点开始进行搜索，然后不停地朝$8$个方向拓展并保存最短路径即可。

然而，我们发现，$\text{DFS}$对于解决这种题目来说，实在太慢，效率低下，只有开$\mathcal O2$才能过。

对于搜索（包括深搜和广搜两种方法），拓展的内容如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/pqukeniy.png)

期望得分：$\color{#52C410}90\,\to \,100(\mathcal O2)$

时间消耗：$\color{#FFC116}2.88\text{s}\color{#52C410}\to 1.87\text{s}(\mathcal O2)$

代码实现：

```cpp
#include<bits/stdc++.h>
#define dist(x_1,x_2,y_1,y_2)abs(x_1-x_2)+abs(y_1-y_2)
using namespace std;
int n,m,dis,dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};//方向增量数组下标有8个
bool screen[151][151],vis[151][151];//screen数组保存屏幕，vis数组保存对应点是否被访问过
void dfs(int x,int y,int d)
{
    if(screen[x][y])dis=d;//如果是白点就更新最小距离
    for(int i=0;i<8;i++)
    {
        int nx=x+dx[i],ny=y+dy[i];//新拓展的点的坐标
        if(nx<1||ny<1||nx>n||ny>m||vis[nx][ny]||d+1>=dis)continue;//如果出了边界、已经被访问或者下一次的距离大于最小距离，就不进行该点的拓展
        vis[nx][ny]=true;//标记访问
        dfs(nx,ny,d+dist(x,nx,y,ny));//新的参数表：横坐标为nx，纵坐标为ny，距离为当前距离加上这两点的距离
        vis[nx][ny]=false;//回溯——标记未访问
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1,x;j<=m;j++)
        {
            scanf("%d",&x);
            screen[i][j]=x;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(screen[i][j])
            {
                printf("0 ");
                continue;
            }
            memset(vis,false,sizeof(vis));//先标记所有点为未访问过
            dis=0x3f3f3f3f;//进行最小距离的初始化
            dfs(i,j,0);//开始搜索，参数表：横纵坐标分别为i和j，初始距离为0
            printf("%d ",dis);//输出最小距离
        }
        putchar('\n');
    }
    return 0;
}
```

### $\color{green}\text{方法3：广度优先搜索}$

$\text{BFS}$的特点是找最优解，所以可以完美地解决本题，而且是这些方法中耗时最少的。

对于搜索（包括深搜和广搜两种方法），大体框架如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/l116e93j.png)

期望得分：$\color{#52C410}100$

时间消耗：$\color{#52C410}73\text{ms}$

代码实现：

```cpp
#include<bits/stdc++.h>
#define dist(x_1,x_2,y_1,y_2)abs(x_1-x_2)+abs(y_1-y_2)
using namespace std;
int n,m,dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};
bool screen[151][151],vis[151][151];
struct node
{
    int x,y;
}q[22501];//定义结构体类型队列
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1,x;j<=m;j++)
        {
            scanf("%d",&x);
            screen[i][j]=x;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1,front,rear,dis;j<=m;j++)
        {
            //定义front（队头），rear（队尾）和dis（最小距离）
            if(screen[i][j])//特判
            {
                printf("0 ");
                continue;
            }
            front=rear=1;//一开始队头队尾都为1
            dis=0x3f3f3f3f;
            memset(vis,false,sizeof(vis));//所有元素均为被访问过
            q[1]=(node){i,j};//第一次的状态就是初始位置
            while(front<=rear)
            {
                node f=q[front];
                for(int k=0;k<8;k++)
                {
                    int nx=f.x+dx[k],ny=f.y+dy[k],d=dist(i,nx,j,ny);//保存最小距离
                    if(nx<1||ny<1||nx>n||ny>m||d>=dis||vis[nx][ny])continue;//如果出边界、距离大于等于最小距离或者被访问过就不再继续
                    vis[nx][ny]=true;//标记访问
                    q[++rear]=(node){nx,ny};//入队
                    if(screen[nx][ny])dis=d;//赋值最小距离
                }
                front++;//队头指针加1
            }
            printf("%d ",dis);//输出最小距离
        }
        putchar('\n');
    }
    return 0;
}
```

总之，虽然一题有多解，但在实际应用中，设法找到最优的方法是至关重要的。

---

## 作者：提督 (赞：6)

#### 这题其实并不用搜索。只需要记录所有的白点，n1、n2、n3…………1. 然后，计算n1到所有黑点的距离，计算n2到所有黑点的距离，如果距离更小，那么就更新。
AC代码如下  

```c

#include<cstdio>
#include<cmath>
#include<iostream>
#include<list>//链表，类似于动态数组 快速的插入和删除，但是随机访问却比较慢.
#include<cstring>
#include<queue>//队列 
#include<stack>//栈 
#include<algorithm>//min,max,swap,sort函数 

using namespace std;

int N,M;

int dis[151][151];//每个点到白像素最短距离 

int m[151][151];// 存图 但这题其实没必要

int t;

struct Node{

	int x,y;
};

queue<Node>Q;
  
int main(){

	scanf("%d %d",&N,&M);
    
	for(int i=1;i<=N;i++){//初始化，最短距离初始化最大 
    
		for(int j=1;j<=M;j++){
        
			dis[i][j]=0x7fffffff;	
            
		}
        
	}
    
	for(int i=1;i<=N;i++){
    
		for(int j=1;j<=M;j++){
        
			scanf("%d",&t);
            
			m[i][j]=t;
            
			if(t==1){//记录白像素坐标 
            
				Q.push((Node){i,j});	
                
			}
            
		}
		
	}
    
	Node tmp;
    
	while(Q.empty()!=true){//遍历白像素到所有黑点的距离
    
		tmp=Q.front();
        
		Q.pop();
        
		for(int i=1;i<=N;i++){
        
			for(int j=1;j<=M;j++){
            
				dis[i][j]=min(dis[i][j],abs(i-tmp.x)+abs(j-tmp.y));	//保留最短的距离 
                
			}
            
		}	
        
	}
    
	for(int i=1;i<=N;i++){//输出 
    
		for(int j=1;j<=M;j++){
        
			printf("%d ",dis[i][j]);
            
		}
        
		printf("\n");
        
	}	
    
    return 0;
    
}
```



---

## 作者：NeilKleist (赞：4)

其实这题可以跑最短路

先把所有白色点标记为距离为0，然后强行跑DJ就可以了

代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <vector>

struct Vec2//坐标数据 
{
    int x; 
    int y;
    int dis;
};

struct Cmp//优先队列比较函数 
{
    bool operator() (const Vec2& v1, const Vec2& v2)
    {
        return v1.dis > v2.dis;
    }
};

bool map[200][200];//位图 
bool visit[200][200];//访问记录 
int ans[200][200];//结果 

int next[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};//下一个点 

std::priority_queue<Vec2, std::vector<Vec2>, Cmp> queue;//优先队列 

int main()
{
    int width = 0;
    int height = 0;
    std::cin >> width >> height;
    
    memset(map, 0, sizeof(map));
    memset(ans, 0x7fffffff, sizeof(ans));
    memset(visit, 0, sizeof(visit));//初始化
    
    for (int i = 0; i < width; i++)
    {
        for (int j = 0; j < height; j++)
        {
            int color = 0;
            std::cin >> color;
            map[i][j] = (bool)color;
            
            if (color)//把所有白色像素点标记为距离为0，放进优先队列 
            {
                Vec2 v;
                v.x = i;
                v.y = j;
                v.dis = 0;
                queue.push(v);
            }
        }
    }
    
    while (!queue.empty())//如果队列不为空 
    {
        Vec2 v = queue.top();
        queue.pop();
        
        if (visit[v.x][v.y])//已经访问过了 
        {
            continue;
        }
        
        visit[v.x][v.y] = true;
        ans[v.x][v.y] = v.dis;//记录 
        
        for (int i = 0; i < 4; i++)//四个方向继续搜索 
        {
            int nx = v.x + next[i][0];
            int ny = v.y + next[i][1];//下一个点的坐标 
            
            if (nx >= 0 && nx < width && ny >= 0 && ny < height)//是否越界 
            {
                Vec2 temp;
                temp.x = nx;
                temp.y = ny;
                temp.dis = v.dis + 1;//距离+1s
                queue.push(temp);
            }
        }
    }    
    
    for (int i = 0; i < width; i++)//输出结果
    {
        for (int j = 0; j < height; j++)
        {
            std::cout << ans[i][j] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

---

## 作者：SIGSEGV (赞：2)

BFS的套路 ~~这是一道完全相似的原题~~

用一个数组dis[i][j]表示坐标为(i,j)的点离白点的最短距离。dis初始化为-1

每个白点入队时都将自己对应的dis位置设置为0.根据题意，
题目中两点距离的计算方式相当于“一个人从A点，每次只能向上下左右四个方向走一格，问走到B点要多少次？”

接着就对于每个要扩展的点，扩展出所有状态。设扩展出的新点坐标为(nx,ny),

如果

dis[nx][ny] != -1,则已经有更优解了（BFS的特性），故此点无需入队。nx，ny出界也无需入队。

否则，

赋值dis[nx][ny]，并将此点入队。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[155][155],dis[155][155],f,e,n,m;
//f:队首，e:队尾之后一个位置，队列范围为[f,e)
struct Node{int x,y,cnt;};
Node q[100005]; //队列
int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};//四个方向
int main ()
{
	memset(dis,-1,sizeof(dis));//初始化
	scanf("%d%d",&n,&m);
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
		{
			scanf("%d",&a[i][j]);
			if (a[i][j])
			{
				dis[i][j] = 0;
				q[e++] = {i,j,0};
			}
		}
	while (f != e)
	{
		Node nd = q[f++];//出队
		for (int i = 0;i < 4;i++)
		{
			int nx = nd.x + dx[i],ny = nd.y + dy[i];
			if (nx < 1 || nx > n || ny < 1 || ny > m || dis[nx][ny] != -1) //判断是否需入队
				continue;
			dis[nx][ny] = nd.cnt + 1;
			q[e++] = {nx,ny,nd.cnt + 1};//入队
		}
	}
	for (int i = 1;i <= n;i++)
	{
		for (int j = 1;j <= m;j++) printf("%d ",dis[i][j]);
		printf("\n");
	} //输出
	return 0;
}
```
好一道广搜

---

## 作者：_L_h_J_ (赞：2)

题目分析：

读题后不难想到：对于每一个黑色像素，都去进行一次广度优先搜索，找到最近的白色像素。对于每一个白色像素，最近的白色像素就是自己。但是n，m的范围过大，超时！

故此题采用：多源最短路算法

对每一个白点进行广度优先搜索，由它去更新黑点的答案，再由已经更新的黑点去更新其他黑点的答案，但每个点不是只去一次，当我们发现存在更优解时应当重新加入队列进行更新.对每一个白点进行广度优先搜索，由它去更新黑点的答案，再由已经更新的黑点去更新其他黑点的答案，但每个黑点不是只更新一次，当我们发现存在更优解时应当重新加入队列进行更新.

**代码如下：**
```cpp

#include<bits/stdc++.h>
using namespace std;
struct _
{
	int x,y;
}q[182*182+5];//存白像素点
int ans[183][183],n,m,cnt;
bool flag[183][183]; 
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};//方向数组，搜四周的点 
void BFS()
{
	int h=1,t=cnt,nx,ny,i;
	while(h<=t)//BFS模板 
	{
		for(i=0;i<=3;i++)
		{
			nx=q[h].x+dx[i];
			ny=q[h].y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)//首先不能越界 
			{
				if(!flag[nx][ny]&&ans[q[h].x][q[h].y]+1<ans[nx][ny])
				{//为黑点且 ！！！当前的答案比之前的更优，则选择这种方案
				//把这个本来已经扩展过的节点压入，让它去更新其它的点的更优答案
				//比如 当前点(x,y)的上一次最近距离为3，它的上面一个点(x,y+1)的距离为4
				//而现在(x,y)的距离可以被nx，ny优化到2，那么(x,y+1)自然可以优化到3
					t++;
					q[t].x=nx;
					q[t].y=ny;
					ans[nx][ny]=ans[q[h].x][q[h].y]+1;//更新 
				}
			}
		}
		h++;
	}
	//结束时所有的点的答案已经最优了(全部更新完毕) 
}
int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			char ch;
			cin>>ch;
			if(ch=='0')flag[i][j]=false,ans[i][j]=0x7ff;//黑点为false，ans定大方便之后更新答案 
			else//把所有的白点丢进队列 
			{
				cnt++;
				q[cnt].x=i;q[cnt].y=j;
				flag[i][j]=true;
				ans[i][j]=0; 
			}
		}
	}
	BFS();//利用所有的白点去搜索，只需一次搜索即可 
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Great瞿葩 (赞：2)

啊哈 本来想用搜索做，后面还是用动规做了

转移：   f[i,j]:=min(f[i,j],f[i+1,j]+1,f[i-1,j]+1,f[i,j+1]+1,f[i,j-1]+1)

然而转移一次还不够，可能找到的不是最小的。那么要转移多少次呢？

我们转化一下问题，最多会有多少次移动？n+m。

然后数据只有150，我们的最大复杂度为O((M+N)\*N\*M)，不会超时。

##代码


```delphi

program qyp_bit;
var p,f:array[0..151,0..151]of longint;
    n,m,i,j,k:longint;
function min(a,b,c,d,e:longint):longint;
begin
  if a<b then b:=a;
  if b<c then c:=b;
  if c<d then d:=c;
  if d<e then e:=d;
  exit(e);
end;
begin
   readln(n,m);
   fillchar(f,sizeof(f),$0f);
   for i:=1 to n do
    for j:=1 to m do
     begin
      read(p[i,j]);
      if p[i,j]=1 then f[i,j]:=0;
     end;

   for k:=1 to m+n do
    for i:=1 to n do
     for j:=1 to m do
      f[i,j]:=min(f[i,j],f[i+1,j]+1,f[i-1,j]+1,f[i,j+1]+1,f[i,j-1]+1);
   for i:=1 to n do
    begin
     for j:=1 to m do write(f[i,j],' ');
     writeln;
    end;
end.

```

---

## 作者：ShineEternal (赞：1)

[更佳的阅读效果。](https://vipblog.github.io/PzZ3xYQBd/)

## description：


#### 题目描述

现在我们给出一个 $n\times m$ 的单色位图，且该图中至少含有一个白色的像素。我们用 $(i, j)$ 来代表第 $i$ 行第 $j$ 列的像素，并且定义两点 $p_1=(i_1, j_1)$ 和 $p_2=(i_2, j_2)$ 之间的距离为：

$$ d(p_1,p_2)=|i_1 - i_2| + |j_1-j_2| $$

任务：

请写一个程序：

从文本文件 BIT.IN 中读入该位图；

对于每个像素，计算出离该像素最近的白色像素与它的距离；

把结果输出。

#### 输入格式

第一行包括两个用空格分开的整数 $n$ 和 $m$，$1\le n\le 150$，$1\le m\le 150$。

以下的 $n$ 行每行包括一个长度为 $m$ 的整数为零或一，在第 $i+1$ 行的第 $j$ 个字符如果为 `1`，那么表示像素 $(i, j)$ 为白的，否则为黑的。

#### 输出格式

输出一个 $n\times m$ 的数表，其中的第 $i$ 行的第 $j$ 个数字为 $f(i, j)$ 表示像素 $(i, j)$ 到最近的白色像素的距离。

## solution：

观察到数据范围较小，那不妨直接找出所有的白点，然后依次更新到每个黑点的距离。如果距离比原来这个黑点的最佳距离更小，那么就更小它。

最劣时间复杂度：$O(n^4)$，然而一般远无法达到。


## code：

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
queue<pair<int,int> >q;
int dis[155][155],a[155][155];
int abs(int x)
{
	if(x<0)return -x;
	return x;
}
int main()
{
	memset(dis,0x3f,sizeof(dis));
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			if(a[i][j]==1)
			{
				q.push(make_pair(i,j));
			}
		}
	}
	while(!q.empty())
	{
		int x=q.top().first;
		int y=q.top().second;
		q.pop();
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				if(a[i][j]==0)
				{
					dis[i][j]=min(dis[i][j],abs(i-x)+abs(j-y));
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]==1)
			{
				printf("0 ");
			}
			else
			{
				printf("%d ",dis[i][j]);
			}
		}
		printf("\n");
	}
	return 0;
}
```



---

## 作者：王钰翔 (赞：1)

这题其实就是不断取每块对白块的min
二话不说上代码
c++：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k;
int b[155][155];
char a[155][155];
struct xiabiao {
	int x,y;
} c[100005];
void work(int xx,int yy) {
	for(int i=1; i<=k; i++) {
		b[xx][yy]=min(abs(c[i].x-xx)+abs(c[i].y-yy),b[xx][yy]); // 对每一个白块取最小值 
	}
}
int main() {
	cin>>n>>m;
	memset(b,0x3f,sizeof(b)); // 距离要取最小，所以要初始化大的值 
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			cin>>a[i][j];
			if(a[i][j]=='1') { //直接预处理
				b[i][j]=0; // 自身无距离
				k++;
				c[k].x=i; //储存白块信息
				c[k].y=j;
			}
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(a[i][j]=='0') {
				work(i,j); //一个一个算距离
			}
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			cout<<b[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：lijialin (赞：1)

这道题。。。。一看数据规模就知道是搜索

但搜索也有技巧啊！

我说一下的几个思路（可能不一定对）

思路一：从0开始搜，一个一个0分别搜索，当遇到1就返回（此时一定是最近的）。但是，费时（很多重复的状态被反复记录）

思路二：优化1，只不过一次记录一个“连通分量”的0，但可能会迷之WA（作为懒惰型选手，才不告诉你是代码太麻烦了）


我们不妨抛开思路一，二；

我们还可以从1开始搜，只不过用了SPFA的思想，即如果成功更新ans[i][j](初始值为inf)；那么才继续搜（想想这是为什么）


代码如下：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n,m;int a[155][155];
int ans[155][155];
int mx[4]={0,0,1,-1},my[4]={1,-1,0,0};
int qx[150*151],qy[150*151];
int main(){
    memset(ans,60,sizeof(ans));
    scanf("%d%d",&n,&m);int head=0,tail=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            if(a[i][j]){
                ans[i][j]=0;
                qx[++tail]=i;qy[tail]=j;————————————————>把1先扔进队列
            }
        }
    }
    int x,y;
    while(tail>head){
        head++;x=qx[head];y=qy[head];
        for(int i=0;i<4;i++){
            if((x+mx[i]>0&&x+mx[i]<=n&&y+my[i]>0&&y+my[i]<=m)——————————————>边界
            &&((a[x+mx[i]][y+my[i]]!=1)&&(ans[x+mx[i]][y+my[i]]>ans[x][y]+1))){
```
|                                                  |
                          |                                                  |
其实可以不用这个。。               但这个是核心

```cpp
                qx[++tail]=x+mx[i];qy[tail]=y+my[i];
                ans[x+mx[i]][y+my[i]]=ans[x][y]+1;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)cout<<ans[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：俩小圈 (赞：0)

如果直接用f[x][y]=min(min(min(dfs(x+1,y),dfs(x-1,y)),dfs(x,y+1)),dfs(x,y-1))+1;进行记忆化搜索的话，会进入无限循环。

所以分别从左上到右下，右上到左下，左下到右上，右下到左上进行记忆化搜索。
左上到右下搜索的状态转移方程为 f[x][y]=min(dfs(x+1,y),dfs(x,y+1))+1;,以此类推。
最终的答案就是四个f[x][y]的最小值。

细节方面见于代码。


```cpp
#include <iostream>
using namespace std;

int n,m,a[155][155],f[155][155][5],ans[155][155],
Set[5][3]={{0,0,0},{0,1,1},{0,1,-1},{0,-1,1},{0,-1,-1}};

int dfs(int x,int y,int z) {
	if(x>n||x<=0||y>m||y<=0) return f[x][y][z]=999;
	if(f[x][y][z]!=999) return f[x][y][z];
	if(a[x][y]) return f[x][y][z]=0;
	f[x][y][z]=min(dfs(x+Set[z][1],y,z),dfs(x,y+Set[z][2],z));
	f[x][y][z]++;
	return f[x][y][z];
}

int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			for(int k=1;k<=4;k++) {
				f[i][j][k]=999;
			}
		}
	}
	for(int i=1;i<=4;i++) {
		for(int j=1;j<=n;j++) {
			for(int k=1;k<=m;k++) {
			    dfs(j,k,i);
			}
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			ans[i][j]=999;
			for(int k=1;k<=4;k++) {
				ans[i][j]=min(ans[i][j],f[i][j][k]);
			}
			cout<<ans[i][j];
			if(j-m) cout<<" ";
		}
		cout<<endl;
	}
}
```


---

## 作者：skylee (赞：0)

同楼上@lijialin的话，根据数据范围，这题很容易想到是BFS

同时BFS也应该掌握技巧，不能盲目地将搜到的方格加入搜索队列，要加上判断，保证每加一个方格都能有用。

还是类似于@lijialin的方法，读入时先将白色方格扔进队列，搜索时将满足下述条件的方格加入队列，当队列为空，停止搜索。

条件：

1.在当前方格上、下、左、右的相邻的方格。（显而易见）

2.不在当前搜索队列中。（不满足也可以，但是会徒增大量时间、空间开销）

3.已知路径长于当前搜索到的路径。（精髓所在，如果比当前搜索到的路径短也会徒增大量时间、空间开销，而且会WA）

PS：仔细看了@lijialin的题解后发现思路差不多，不过多一份题解总会多一份收获吧。

[codec]

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct pos {
    int x,y;
};
const int dx[4]={-1,1,0,0};
const int dy[4]={0,0,-1,1};
int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    bool b[n+2][m+2];
    int f[n+2][m+2];
    memset(b,0,sizeof(b));
    for(int i=0;i<n+2;i++) {
        for(int j=0;j<m+2;j++) {
            f[i][j]=0x7fffffff;
        }
    }
    queue<pos> q;
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            int t;
            scanf("%d",&t);
            b[i][j]=(bool)t;
            if(t) {
                f[i][j]=0;
                pos p;
                p.x=i;
                p.y=j;
                q.push(p);
            }
        }
    }
    while(!q.empty()) {
        for(int i=0;i<4;i++) {
            if((q.front().x+dx[i])&&(q.front().x+dx[i]<=n)&&(q.front().y+dy[i])&&(q.front().y+dy[i]<=m)) {
                if(!b[q.front().x+dx[i]][q.front().y+dy[i]]&&(f[q.front().x][q.front().y]+1<f[q.front().x+dx[i]][q.front().y+dy[i]])) {
                    f[q.front().x+dx[i]][q.front().y+dy[i]]=f[q.front().x][q.front().y]+1;
                    pos p;
                    p.x=q.front().x+dx[i];
                    p.y=q.front().y+dy[i];
                    q.push(p);
                }
            }
        }
        q.pop();
    }
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            printf("%d ",f[i][j]);
        }
        printf("\n");
    }
    return 0;
}
[/codec]
```

---

## 作者：asuldb (赞：0)

看到诸位dalao都是搜索或dp，难道只有我一个蒟蒻用了枚举吗？

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int map[151][151],ans[151][151];
struct node
{
    int x,y;
}a[1000000];
int n,m,k,i,j;
int min(int c1,int c2)
{
    if(c1<c2) return c1;
    else return c2;
    return c1;
}
void does(int xx,int yy)
{
    for(int z=1;z<=k;z++)
        ans[xx][yy]=min(abs(a[z].x-xx)+abs(a[z].y-yy),ans[xx][yy]);
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
      {
          cin>>map[i][j];
          ans[i][j]=1000000;
          if(map[i][j]==1)
          {
              ans[i][j]=0;
              k++; //统计白色像素个数
              a[k].x=i;
              a[k].y=j;//记录下白色像素位置
          }
      }
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
      if(map[i][j]==0) does(i,j);
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
      {
          if(j==m) cout<<ans[i][j]<<endl;
          else cout<<ans[i][j]<<" "; //输出写得难看，别介意哈
      }
      return 0;
}
//可能是数据比较水吧，蒟蒻的枚举才过了
//第一次写题解，有错请dalao们轻喷
```

---

## 作者：Johnson_sky (赞：0)

本题用广度优先搜素做，进行优化，搜索对角线时注意距离的计算，比较简单，也可用DP来做。





    
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cmath>
#include <cstring>
using namespace std;
int n,m,num=1;
char s[500][500];
int b[10][40000];
int a[500][500];
const int ax[]={0,0,1,1,1,-1,-1,-1};
const int ay[]={1,-1,0,1,-1,0,1,-1};
const int ad[]={1,1,1,2,2,1,2,2};
queue<int>qx;
queue<int>qy;
void bfs(int x,int y)
{
    qx.push(x);
    qy.push(y);
    while(!qx.empty())
    {
        int xx=qx.front();        qx.pop();
        int yy=qy.front();        qy.pop();
        for(int i=0;i<8;i++)
        {
            if(xx+ax[i]<=0||yy+ay[i]<=0||xx+ax[i]>n||yy+ay[i]>m||a[xx+ax[i]][yy+ay[i]]<=a[xx][yy]+ad[i])continue;
            a[xx+ax[i]][yy+ay[i]]=a[xx][yy]+ad[i];
            qx.push(xx+ax[i]);
            qy.push(yy+ay[i]);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    memset(a,1,sizeof(a));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>s[i][j];
            if(s[i][j]=='1')
            {
                b[1][num]=i;
                b[2][num]=j;
                a[i][j]=0;
                num++;
            }
        } 
    }
    for(int i=1;i<num;i++)
        bfs(b[1][i],b[2][i]);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：zls6602488 (赞：0)

记录下每个为1的位置，然后放在队列，进行宽搜，如果队列中元素的四面中有一个没有被更新过值，那么就直接把这个元素的答案+1赋给那个元素，然后把他加进队列，为什么这样一定行呢？首先被更新的肯定是最贴近白像素点，而且肯定是最优的，一旦某个点被更新，那么被更新的值一定是最优的，这样巧妙地进行了宽搜

```delphi

const  
  x:array[1..4]of integer=(-1,1,0,0);  
  y:array[1..4]of integer=(0,0,-1,1);  
var  
  n,m,i,j,t,h,ch:longint;  
  g:array[-1..1000,-1..1000]of longint;  
  px,qy:array[0..40000]of longint;  
begin  
    readln(n,m);  t:=0;  
    fillchar(g,sizeof(g),0);  
    for i:=1 to n do begin  
      for j:=1 to m do begin  
        read(ch);  
        if ch=1then begin  
          inc(t);  
          px[t]:=i;  
          qy[t]:=j;  
        end  
        else g[i,j]:=-1;  
      end;  
      readln;  
    end;  
    ////bfs  
    h:=0;  
    while h<>t do begin  
      inc(h);  
      for i:=1 to 4 do  
       if g[px[h]+x[i],qy[h]+y[i]]=-1 then begin  
         inc(t);  
         px[t]:=px[h]+x[i];  
         qy[t]:=qy[h]+y[i];  
         g[px[t],qy[t]]:=1+g[px[h],qy[h]];  
       end;  
    end;  
    for i:=1 to n do begin  
      for j:=1 to m do write(g[i,j],' ');  
      writeln;  
    end;  
end.

```

---


# [SDOI2005] 矩形

## 题目描述

现在我们在一个平面上画了 $n$ 个矩形。每一个矩形的两边都与坐标轴相平行，且矩形定点的坐标均为整数。现我们定义满足如下性质的图形为一个块：

1. 每一个矩形都是一个块；

2. 如果两个块有一段公共的部分，那么这两个块就会形成一个新的块，否则这两个块就是不同的。

示例：

图 $1$ 中的矩形形成了两个不同的块。图 $2$ 中的矩形形成了一个块。

 ![](https://cdn.luogu.com.cn/upload/pic/1579.png) 

任务：

请写一个程序：

1. 从文本文件 `PRO.IN` 中读入各个矩形的顶点坐标；

2. 找出这些矩形中不同的块的数目；

3. 把结果输出到文本文件 `PRO.OUT` 中。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/mifmaeko.png)

[图片链接](https://www.desmos.com/calculator/1g1ohcqqex)

橙色加粗的线段表示这里有重合的部分，每一个方形中间的数字表示所属的块的编号。

注意：角重合不算同一个块。

## 样例 #1

### 输入

```
9
0 3 2 6
4 5 5 7
4 2 6 4
2 0 3 2
5 3 6 4
3 2 5 3
1 4 4 7
0 0 1 4
0 0 4 1
```

### 输出

```
2```

# 题解

## 作者：Ajwallet (赞：10)

# 大意
$n$个矩形，给定每个矩形的左下角和右上角的坐标。若两个矩形有叠在一起的部分视为它们为一个联通分量，问有几个联通分量。

# 思路
其实楼下的题解更加通俗易懂，但是有些过于繁琐，判断语句其实只需要用三行就可以了。而且操作可以边输入边做，节省循环。

思路较为简单，就是判断两个矩形是否重叠，如果重叠则用并查集将它们合并。

最后判断有哪几个元素的祖先就是自己（即有几个联通分量）

# 代码
```
#include<cstdio>
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int f[7001],n,ans;
struct node
{
    int x1,y1,x2,y2;
}v[7001];//(x1,y1)为左下角的坐标，(x2,y2)为右上角的坐标
int find(int x){return x==f[x]?x:f[x]=find(f[x]);};//查找祖先
void judge(int x,int y){f[find(x)]=find(y);};//合并
bool check(node x,node y)//判断
{
    if((x.x2<y.x1||y.x2<x.x1)||(x.y2<y.y1||y.y2<x.y1)) return false;//y矩形左上角的横坐标小于x矩形左下角的横坐标或大于x矩形右上角的横坐标则false；y矩形左上角的纵坐标小于x矩形左下角的纵坐标或大于x矩形右上角的横坐标则false
    if((x.x1==y.x2||x.x2==y.x1)&&(x.y1==y.y2||x.y2==y.y1)) return false;//这个是特判，当两个矩形出现相交但不重叠的情况放回false；
    return true;//否则是true；
}
int main()
{
    scanf("%d",&n);
    r(i,1,n)
    {
     	scanf("%d%d%d%d",&v[i].x1,&v[i].y1,&v[i].x2,&v[i].y2),f[i]=i;//输入+并查集初始化
     	r(j,1,i-1)//与之前所有矩形判断
      	 if(check(v[i],v[j])&&find(i)!=find(j))//满足条件且不再一个联通分量
       	  judge(i,j);//合并
    }
    r(i,1,n) ans+=f[i]==i;//求出答案
    printf("%d",ans);//输出
}
```

---

## 作者：Up_Xu (赞：5)

# 题意
若有矩阵相交就把它们合并成一个块，求共有几个连通块。



# 思路

其实根本不需要其它题解所说的并查集，只需要简简单单的宽搜。假设做到 $i$ 这个矩阵，那么就暴力枚举 $i$ 后面所有的矩阵（前面的矩阵不用枚举是因为前面的矩阵已经枚举到 $i$ 过了），判断 $i$ 与其后面的矩阵是否相交，相交则入队。不断循环此操作即可。

但问题是该如何判断两矩阵是否相交呢？其实很简单。两矩阵不相交就只有两种情况，一是两矩阵完全不相关，即矩阵甲在矩阵乙上下左右的时候，二是甲与乙有重边的时候。若这两种情况都不符合，甲与乙就是相交了。

# 代码

```
#include <bits/stdc++.h>
using namespace std;
struct no{int x1,y1,x2,y2;}a[7010];
int f[7010],sum,i,n;
queue<int>q;
bool check(int x,int y){
	if(a[x].x2<a[y].x1||a[y].x2<a[x].x1||a[x].y2<a[y].y1||a[y].y2<a[x].y1)return 0;//完全不相交
	if ((a[x].x1==a[y].x2||a[x].x2==a[y].x1)&&(a[x].y1==a[y].y2||a[x].y2==a[y].y1))return 0;//有重边 
	return 1;
}
void bfs(int x){
	q.push(x);
	while(!q.empty()){
		int id=q.front();q.pop();
		for(int i=x+1;i<=n;i++)//暴力枚举
			if(f[i]==0&&check(id,i))//判断是否既没做到过也没有相交
				f[i]=1,q.push(i);//入队
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);//加速代码
	cin>>n;
	for(i=1;i<=n;i++)
		cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;
	for(i=1;i<=n;i++)//枚举所有矩阵
		if(f[i]==0)//判断此矩阵有没有做过
			bfs(i),sum++;//宽搜，连通块个数增加
	cout<<sum;
}
```

---

## 作者：cyngugugu (赞：1)

## 题意
给定一些矩形，如果两个矩形有重合部分，就将它们合并，问最后有多少联通分量

## 思路
这道题合并和查询联通分量的操作很容易想到并查集，用并查集维护联通分量，同时枚举每一个矩形，如果重合就将它们合并。判断是否重合的代码如下：
```cpp
bool check(node x,node y){
	if(x.y1>y.y1)swap(x,y);
	if((x.x1==y.x1||x.x1==y.x2||x.x2==y.x1||x.x2==y.x2)&&(y.y1<x.y2)){
		return 1;
	}//矩形 x 和 y 在 x 轴上有一条重边且在 y 轴上有重合（重边算重合，但有交点不算重合）
	if(((x.x1<y.x1&&x.x2>y.x1)||(x.x1<y.x2&&x.x2>y.x2))&&(y.y1<=x.y2)){
		return 1;
	}//矩形 x 和 y 有直接相交的部分(但没有跨过)，因为 x.y1<y.y1 所以只要判断 x.x2 和 y.y1 就可以了
	if((x.x1<=y.x1&&x.x2>=y.x2&&x.y2>=y.y1)||(y.x1<=x.x1&&y.x2>=x.x2&&x.y2>=y.y1){
		return 1;
	}//矩形 x 和 y 互相穿过。
	return 0;
}
```

## 时间复杂度
使用了路径压缩优化的并查集单次查询最坏的时间复杂度为 $O(\log{n})$，循环枚举矩形的复杂度为 $O(n^2)$，复杂度合起来是 $O(n^2\log{n})$。在这里 $n$ 最大是 7000，正常来说是过不去的，但是我们可以按左下角的 $y$ 坐标从小到大排序，每次枚举只枚举左下角的 $y$ 坐标比自己大的（因为比自己小的都已经枚举过了），这样实际枚举次数就等于 $ n \times n \div 2$，这样就不会超时了。

## 完整代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
int n;
int ans;
int fa[7100];
struct node{
	int x1,y1,x2,y2;
}a[7100];
bool cmp(node x,node y){
	return x.y1<y.y1;
}
int fi(int x){
	if(fa[x]==x)return x;
	return fa[x]=fi(fa[x]);
}
void jo(int x,int y){
	int dx=fi(x),dy=fi(y);
	if(dx!=dy){
		fa[dx]=dy;
	}
}
bool check(node x,node y){
	if(x.y1>y.y1)swap(x,y);
	if((x.x1==y.x1||x.x1==y.x2||x.x2==y.x1||x.x2==y.x2)&&(y.y1<x.y2))return 1;
	if(((x.x1<y.x1&&x.x2>y.x1)||(x.x1<y.x2&&x.x2>y.x2))&&(y.y1<=x.y2))return 1;
	if((x.x1<=y.x1&&x.x2>=y.x2)&&(x.y2>=y.y1))return 1;
	if((y.x1<=x.x1&&y.x2>=x.x2)&&(x.y2>=y.y1))return 1;
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		fa[i]=i;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(check(a[i],a[j])==1){
				jo(i,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(fi(i)==i)ans++;
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：Genius_Star (赞：1)

### 题意：
这道题目所求的是形成不同块的个数，其实就是求图的连通分量，那么我们就可以使用并查集算法，如矩形 $x$ 和矩形 $y$ 是重合的，并且处于不同一个集合那么我们就把矩形 $x$ 和矩形 $y$ 连接，最后我们只要记录有多少个集合就可以了。
### 解题思路：
我们很容易就能够想到，但是问题在于如何判断两个矩形是否重合。

但是如果我们直接判断两个矩形是否重合，我们会发现比较难判断，那么我们可以把两个矩形没有重合的情况判断，剩下的就是重合的情况而了。

我们不重合有分为两种情况：

- 第一种情况：是两个矩形八竿子打不着一起，也就是矩形  $x$ 在矩形 $y$ 上下左右四个方向的时候。

- 第二种情况：这样个矩形出现了重边的情况，这样子在题目中也是不算重合的。

判断矩形重合的代码：
```cpp
bool check(Ger x,Ger y)
{
	//x矩形及y矩形
	//x1,y1代表横竖坐标
	if(x.x2<y.x1/*矩形x在矩形y的下方*/||y.x2<x.x1/*矩形x在矩形y的上方*/||x.y2<y.y1/*矩形x在矩形y的左方*/||y.y2<x.y1/*矩形x在矩形y的右方*/)return 0;
	if ((x.x1==y.x2||x.x2==y.x1)&&(x.y1==y.y2||x.y2==y.y1))/*角重合*/return 0;
	return 1;
}
```

这样子做的话时间复杂度为 $O(n^2)$，数据在大上一点儿就过不去了。
### 完整代码;
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[100010];
int sum=0;
struct Ger
{
	int x1,y1,x2,y2;
}G[100010];
int find(int x)
{
	if (f[x]==x)return x;
	return f[x]=find(f[x]);
}
void join(int x,int y)
{
	f[find(x)]=f[find(y)];
}
bool check(Ger x,Ger y)
{
	if(x.x2<y.x1||y.x2<x.x1||x.y2<y.y1||y.y2<x.y1)return 0;
	if ((x.x1==y.x2||x.x2==y.x1)&&(x.y1==y.y2||x.y2==y.y1))return 0;
	return 1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for (int i=1;i<=n;i++)	
		f[i]=i;
	for (int i=1;i<=n;i++)
		{
			cin>>G[i].x1>>G[i].y1>>G[i].x2>>G[i].y2;
			for (int j=1;j<i;j++)
			{
				if (check(G[i],G[j])&&find(f[i])!=find(f[j]))
					join(i,j);
			}
		}
	for (int i=1;i<=n;i++)
	{
		if (f[i]==i)
			sum++;
	}
	cout<<sum;
	return 0;
}

```

大家自己推一推算一算，看看能不能找到更有优秀的算法~

---

## 作者：白简 (赞：1)

## 题目大意
给出 $n$ 个矩形的左下角和右上角下标，有重叠部分的矩形将合并成一个块，求最终块的数量。

## 前置芝士
需要会最基本的[并查集](https://www.luogu.com.cn/problem/P3367)。

## 思路
我们用并查集维护块，写一个函数来判断两个块是否重叠，重叠的将这两个块合并。

对于最后块的数量，被合并到其他块的矩形的祖先肯定不是自己，而作为每个块祖先的矩形的父亲是它自己。

所以判断块的数量只需要判断祖先是自己的矩形的数量就可以了。

## Code
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>

const int N = 7050;

int n;

int fa[N];

int Find(int x) {
	if(fa[x] == x)
		return x;
	return fa[x] = Find(fa[x]);
}

void Union(int x,int y) {
	x = Find(x);
	y = Find(y);
	fa[x] = y;
	
	return ;
}

bool Judge(int x,int y) {
	x = Find(x);
	y = Find(y);
	
	if(x == y)
		return 1;
	return 0;
}

int x1[N],x2[N],y1[N],y2[N];

bool Check(int x,int y) {
	if((x2[x] < x1[y] || x2[y] < x1[x]) || (y2[x] < y1[y] || y2[y] < y1[x]))
		return 0;
    if((x1[x] == x2[y] || x2[x] == x1[y]) && (y1[x] == y2[y] || y2[x] == y1[y]))
		return 0;
    return 1;
}

int main() {
	std::cin >> n;
	for(int i = 1;i <= n; i++)
		fa[i] = i;
	for(int i = 1;i <= n; i++) {
		std::cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];
		for(int j = 1;j < i; j++) {
			if(Check(i,j) && !Judge(i,j))
				Union(i,j);
		}
	}
	
	std::sort(fa + 1,fa + n + 1);
	int ans = 0;
	for(int i = 1;i <= n; i++)
		if(fa[i] == i)
			ans ++;
	std::cout << ans;
	return 0;
}
```

---

## 作者：Ar_cher (赞：1)

# $\textnormal{P2449 题解}$

出题人出的还是很好的，题面完善得很好，值得学习。

## $\color{gray}{\texttt{Part 1 题面大意}}$

$n$ 个矩形，给定每个矩形的左下角和右上角的坐标。

若两个矩形有叠在一起的部分视为它们为一个联通分量，问有几个联通分量。

## $\color{gray}{\texttt{Part 2 解题思路}}$

**前置知识**

[并查集](https://zhuanlan.zhihu.com/p/93647900)

操作可以边输入边做，节省循环。

思路较为简单，就是判断两个矩形是否重叠，如果重叠则用并查集将它们合并。

最后判断有哪几个元素的祖先就是自己（即有几个联通分量）。

需要注意判断矩形之间的相交的条件。

## $\color{gray}{\texttt{Part 3 AC Code}}$

综上所述，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=7001;
int n,ans=0;
int f[N];
struct node{
	int x1,y1;//左下角坐标 
	int x2,y2;//右上角坐标 
}v[N];
int find(int x){//查找祖先 
	return x==f[x]?x:f[x]=find(f[x]);
} 
void hb(int x,int y){//合并
	f[find(x)]=find(y); 
}
bool check(node x,node y){
	if((x.x2<y.x1 or y.x2<x.x1) or (x.y2<y.y1 or y.y2<x.y1))
		return false;
	if((x.x1==y.x2 or x.x2==y.x1) and (x.y1==y.y2 or x.y2==y.y1))
		return false;
	/*else*/return true;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>v[i].x1>>v[i].y1>>v[i].x2>>v[i].y2;
		f[i]=i;//初始化 
		for(int j=1;j<=i-1;j++){
			if(check(v[i],v[j]) and find(i)!=find(j))
				hb(i,j);
		}
	}
	for(int i=1;i<=n;i++) ans+=f[i]==i;
	cout<<ans;
	return 0;
}
```


---

## 作者：_111_ (赞：1)

这篇题解我重点讲一下**时间复杂度**，看到下面几篇题解在时间复杂度这块感觉~~都没怎么讲清楚~~。

**题意**：给定一些矩形，如果两个矩形有重合部分，那么就把它们合并在一起，问最后一共有多少个块。

我们枚举每个矩形，对于这个矩形，只有和编号比它小的矩形比较就可以了，这样可以舍去一部分重复比较的情况，如果两个矩形有重叠部分，就把它们合并在一起，这个过程可以使用**并查集**来实现，最后统计一共有都少个块就行了。

**注**：判断两个矩阵是否有重叠这个我直接四种情况都枚举了一下，虽然没有其他几位大佬的题解简洁，但感觉更好理解一点。

## 时间复杂度
下面的代码中，并查集的时间复杂度为 $O(n \log n)$，for 循环的时间复杂度为 $O(n^2)$，这里 $n$ 最大为 $7000$，正常的评测机 $T = 7000 \times 7000$ 是过不去的，但实际执行次数为 $n \times n \div 2 = 7000 \times 7000 \div 2 = 24500000$，所以这里的 $O(n^2)$，$n = 7000$ 相当于 $n = 5000$ 时 $5000 \times 5000 = 25000000$ 的执行次数，所以不会超时，总的时间复杂度为 $O(n^2)$。
## code
```c
#include<bits/stdc++.h>

using namespace std;
const int N=7010;
int n;
int fa[N];
struct node{
	int x1,y1,x2,y2;
}a[N];
int find(int x){
	if(fa[x]==x){
		return x;
	}
	return fa[x]=find(fa[x]);
}
void un(int x,int y){
	fa[find(y)]=find(x);
}
bool check(int x,int y){
	if(a[x].x2<a[y].x1||a[x].y1>a[y].y2||(a[x].x2==a[y].x1&&a[x].y1==a[y].y2)){
		return false;
	}//x的左上，y的右下
	if(a[x].y2<a[y].y1||a[x].x1>a[y].x2||(a[x].y2==a[y].y1&&a[x].x1==a[y].x2)){
		return false;
	}//x的右下，y的左上 
	if(a[x].x1>a[y].x2||a[x].y1>a[y].y2||(a[x].x1==a[y].x2&&a[x].y1==a[y].y2)){
		return false;
	}//x的左下，y的右上
	if(a[x].x2<a[y].x1||a[x].y2<a[y].y1||(a[x].x2==a[y].x1&&a[x].y2==a[y].y1)){
		return false;
	}//x的右上，y的左下 
	return true;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		fa[i]=i;
		scanf("%d%d%d%d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
		for(int j=i-1;j>=1;j--){
			if(find(i)!=find(j)&&check(i,j)){
				un(i,j);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(find(i)==i){
			ans++;
		}//统计答案 
	}
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：QcpyWcpyQ (赞：1)

[博客食用更佳](https://www.luogu.com.cn/blog/QcpyWcpyQ/solution-p2449)

------------

## 前置芝士

1.并查集，没有学过的朋友可以先去做做[P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)。

2.会一点点几何（其实就是判断矩形是否相交）。


知道以上两点后这道题就变成板子题了。


------------
## 思路
这道题的难点在于判断矩形是否重合，注意一些细节：

1.两个矩形的**边重合**算一个块。

2.两个矩形的**角**重合**不算**一个块。

~~这两个我调了好久……~~

然后套用并查集的模板即可：

------------
## 代码核心
```cpp
inline bool pd(rect a,rect b){
    if(a.x2<b.x1||b.x2<a.x1||a.y2<b.y1||b.y2<a.y1)
        return false;//判断矩形是否重合;
    if((a.x1==b.x2||a.x2==b.x1)&&(a.y1==b.y2||a.y2==b.y1))
        return false;//判断边重合，“&&”是去除角重合情况的;
    return true;
}
```

---

## 作者：Nozebry (赞：1)

## Problems
先告诉我们有n个矩形，给定每个矩形的左下角和右上角的坐标。若两个矩形有叠在一起的部分视为它们为一个部分，问共有几个部分。

## Answer
这道题虽然算法标签处没标注是什么算法，但其实不难发现，这就是一道稍微变形了一下的**并查集**。
### Deformation
在以往的并查集中，是可以直接查找父节点，然后合并。但这道题在做的时，我们需要先判断这两个矩形是否有重叠，如果有，则按照普通并查集的方法去进行合并。

## Code
```pascal
uses math;
var
    n,m,i,j,ans,x,y:longint;
    f,x1,x2,y1,y2:array[0..10010]of longint;

function find(x:longint):longint;
begin
    if f[x]=x then exit(x);
    f[x]:=find(f[x]);
    exit(f[x]);
end;

begin
    readln(n);
    for i:=1 to n do readln(x1[i],y1[i],x2[i],y2[i]);
    for i:=1 to n do f[i]:=i;\\普通并查集的做法，先假设每个矩形的父节点就是自己
    for i:=1 to n do
        for j:=1 to i-1 do
        begin
            if (x2[i]<x1[j])or(x2[j]<x1[i])or(y2[i]<y1[j])or(y2[j]<y1[i])or(x1[i]=y2[j])or(x2[i]=y1[j])or(y1[i]=x2[j])or(y2[i]=x1[j]) then continue;\\判断两个是否重叠
            x:=find(i);y:=find(j);f[y]:=x;\\如果重叠，就把两个节点合并为一个    
        end;
    for i:=1 to n do
        if f[i]=i then inc(ans);\\当所有矩形都被判断后，如果一个节点的父节点还是自己，则这个就是该森林中某棵树的根节点
    writeln(ans);
end.                 
```
## Tips
由于数据$1\le n\le7000$，所以不用担心双重循环会超时

---

## 作者：HHYQ_07 (赞：0)

# 题解

## 题目大意

给你 $n$ 个矩形，求这些矩形所组成的连通块数量。

## 思路

本题其实不用标签中说的最短路，也不用什么联通分量，就是一道 [BFS](https://oi.wiki/graph/bfs) 求连通块数量的模板题。唯一有区别的是判断两个矩形联通的部分。

## 具体做法

遍历每个矩形，每遍历到一个未标记的矩形就跑一遍 BFS，访问它所在的连通块，给访问到的矩形打上标记，答案加一。判断联通时先看两个矩形是否相交，再特判重边。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=7005;
int n,ans;
bool v[N];
struct node
{
	int x1,x2,y1,y2;
}a[N];
bool check(node x,node y)
{
    if((x.x2<y.x1||y.x2<x.x1)||(x.y2<y.y1||y.y2<x.y1)) return false;
    if((x.x1==y.x2||x.x2==y.x1)&&(x.y1==y.y2||x.y2==y.y1)) return false;
    return true;
}
void bfs(int st)
{
	queue<int>q;
	q.push(st);
	v[st]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=st+1;i<=n;i++)
			if(!v[i]&&check(a[x],a[i]))
			{
				q.push(i);
				v[i]=1;
			}
	}
	ans++;
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;
	for(int i=1;i<=n;i++)
		if(!v[i])bfs(i);
	cout<<ans;
	return 0;
}

```

---


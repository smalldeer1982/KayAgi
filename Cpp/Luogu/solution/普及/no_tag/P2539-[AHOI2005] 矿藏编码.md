# [AHOI2005] 矿藏编码

## 题目描述

探险机器人在 Samuel 星球发现了一片广阔的矿藏区。在这个矿藏区中，有高耸的山峰，也有平坦的平地。为了方便考察，整个矿藏区被划分 个格子区域。

例如下图，就是一个 $K=2$ 即 $4 \times 4$ 的矿藏区：

 ![](https://cdn.luogu.com.cn/upload/pic/1646.png) 

其中黑色表示山峰，白色表示平地。

探险空间站已经将这片矿藏区的详细信息扫描并记录下来。由于矿藏区的面积实在太大，所以科学家们采用了一种特殊的编码方式记录。

- 如果这片矿藏区全部是平地，则编码为 `0`。
- 如果这片矿藏区全部是山峰，则编码为 `1`。
- 否则，将矿藏区均匀划分成 $4$ 份，如下 所示：
     ![](https://cdn.luogu.com.cn/upload/pic/1647.png) 

依次对每份进行编码，得 $S_1,S_2,S_3,S_4$。该矿藏区的编码 $S$ 为 $2S_1S_2S_3S_4$。
例如上图中，矿藏区的编码为：`2021010210001`。

小联希望你能根据给定的编码统计出这片矿藏区一共有多少格子区域是平地。


## 样例 #1

### 输入

```
2
2021010210001```

### 输出

```
9```

# 题解

## 作者：Hanriver (赞：6)

## longlong都过不了
## 如2^50恐怖的数据
#### 好吧只能用double
好了进入正题（[题目点这里](https://www.luogu.com.cn/problem/P2539)）
#### 首先点明中心思想：
看看下面的dalao们都用的是递归，我就膜拜了。（本蒟蒻最怕递归，而且这题真的不用递归）    
在这里给出一个平民易懂的朴素思想：用一个类似栈的top（其实就是一个指针）代表层数，每逢“2”++，逢“1”不做任何操作，逢“0”计数器s加上一个  
(1<<(k-top))·(1<<(k-top))   

（1<<（k-top）等同于pow（2，k-top），解释一下为什么是2的k-top次方：top就是层数，相当于已经把整块分成了2^top块，这时整块空地的面积就是2^k-2^top，计算以后得(1<<(k-top))·(1<<(k-top))）

这时还有一个问题要考虑，那就是满4大块后怎么回退呢？这里我只能想到用q数组来存储已经完整的块的数量，满4进1，并把top--。  


------------

接下来放我80分代码（逃而又回）（不知道为什么，第7和第9没过，可能是double精度还太低，恳请各位大佬帮我找一下）
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[200];
int q[201];//标记
int main()
{
	int k,top=0;
	double s=0;
	scanf("%d",&k);
	cin>>a;
	for(int i=0;i<strlen(a);i++)
	{
		if(a[i]=='2') top++;
		else q[top]++;
		if(a[i]=='0') s+=(double)(pow(2,k-top)*pow(2,k-top))/1000000000000000000;//精髓
		while(q[top]==4)//清标记
		{
			q[top--]=0;
			q[top]++;
		}
	}
	printf("%.0lf",s*1000000000000000000);
	return 0;
}
```
结束咯！

---

## 作者：chaichunyang (赞：4)

## [AHOI2005]矿藏编码
#### [题目](https://www.luogu.com.cn/problem/P2539)
### 算法简介：
#### 模拟题 ___无算法___
### 模拟思路：
##### 首先将$k$,和编码输入：
```cpp
	while(~(c=getchar())) {
		if(c[i]== '1') {
			a[i]=1;
		} else if(c[i]=='0') {
			a[i]=0;
		} else if(c[i]=='2') {
			a[i]=2;
		}
	}
```
##### 接着开始模拟大法：
```cpp
	scanf("%d\n",&k);
	p=k;
	while(~(c = getchar())) {
		if(c=='2') {
			p--;
		} else if(c== '1') {
			a[p]++;
		} else if(c=='0') {
			a[p]++;
			ans+=pow(2,p+p);
		}
			while(a[p]==4) {
				a[p]=0;
				p++;
				a[p]++;
			}
	}
```
##### 最后一个坑卡 $long long$ 
```cpp
printf("%.0lf",ans);
```

---

## 作者：cabac (赞：3)

# 阅读初感
乍一看，这就是一道正常的暴力模拟，无愧于黄题标签，注意细节就行了（说得简单）

首先，先输入一个n，但这个n并不是矿藏区的边长，边长应该为pow（2，n），所以可以把边长记录下来，然后算出4块中每一块的面积，在赋值给n，就像这样：n=pow(2,(int)2*n-2);（有过简化，可以拆开来理解）。
    
其次，便是处理接下来的一串编码了。乍一看比较没头绪，但仔细理一理应该没什么问题。以样例为例：2021010210001，仔细分析一下，就是先输入一个2，然后再输入四个数字分别表示四块区域的状态，分别表示左上，右上，左下，又下四个角的四个方块，如果全黑就为1，就可以记录下方块总数，全白就为0，有黑又白就输入2，然后再输入4个数字表示这一大块中四个小块的状态。如果输入的还有2，那么就再输入4个数字。看着看着，就想到可以用递归来模拟这个过程，那么统计黑块的个数就可以在线做。

那么怎么统计黑块个数呢？可以开一个变量k，如果出现了1的状态，那么答案ans就可以加上k，那如果再出现2呢，那么这时候每一个数字表示的面积变小了4倍，所以要k/4。所以一遍走下来即可。
# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,ans;
void in(double k)	//在线输入并计算
{
    char js1;
    for(int i=1;i<=4;++i)
    {
        scanf("%c",&js1);
        if(js1=='0')
        ans+=k;
        else if(js1=='2')
        in(k/4);	//在进行一边循环，k不要忘了/4
    }
}
int main()
{
    //freopen("1.in","r",stdin);
    scanf("%lf\n",&n);
    n=pow(2,(int)2*n-2);	//设置n为每一块的面积
    scanf("2");
    in(n);
    printf("%.0lf",ans);
    return 0;
}

```
完成收工

---

## 作者：peixiaorui (赞：2)

## 思路
这题是个简单的模拟。我们把矿藏分为 $k$ 层，每一层中有多个块，每一个块又可以分成 $4$ 个子块，直到分到大小为 $1$ 为止。
设完全没有被分割过的那一层为第 $0$ 层，边长为 $2^{k}$，则面积为 $(2^{k})^{2}$，即 $2^{2k}$，那么第 $i$ 层面积就是 $2^{2(k-i)}$。
对于层次问题，用递归就能很轻松的解决。

每一次分割的标志都是 `2`，那么我们每读到一个 `2`，就往下递归一层。每读到一个 `0`，就加上它的面积。

题目给的数据为 $K < 50$，`long long` 会被卡，`double` 可能会爆精度，所以我用了 `__int128` 来存储答案。`__int128` 类型不能直接输入输出，需手写读写。
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
#define ll long long
string s;
int k,x;
__int128 f(int c){
	__int128 sum=0;
	fo(i,1,4){
		if(s[x]=='2')x++,sum+=f(c+1);//向下递归一层
		else if(s[x]=='0')sum+=(__int128)pow(2,2*(k-c)),x++;//面积公式见上
		else x++;
	}
	return sum;
}
void print(__int128 a){
	if(a>0)print(a/10);
    else return ;
	putchar(a%10+'0');
}//int128快写
int main(){
	cin>>k>>s;
	print(f(0));
	return 0;
}
```


---

## 作者：Tjaweiof (赞：2)

# P2539 题解——Tjaweiof
[题目传送门](https://www.luogu.com.cn/problem/P2539)

看到题目的第一眼，唉？这不是简单的递归吗？

思路：当输入的数为 $2$ 时，继续递归。为了方便统计，每次递归的参数 $-1$，每次输入 $0$ 时直接把结果加上$2^x \times 2^x$。

于是，我们写出了以下代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int k, ans = 0;
char tmp;
void work(int x){
    scanf(" %c", &tmp);
    if (tmp == '2'){
        for (int k = 1; k <= 4; k++){
            work(x - 1);
        }
    } else if (tmp == '0'){
        ans += pow(2, x) * pow(2, x);
    }
}
int main(){
    scanf("%d", &k);
    work(k);
    printf("%d", ans);
    return 0;
}
```
但是，你会看到[这个页面](https://www.luogu.com.cn/record/115576328)，看了一些大佬的题解才知道，原来要用 double，随后把 $ans$ 的类型设为 double。注意！最后输出要改成 `printf("%.0lf", ans);`

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int k;
double ans = 0;
char tmp;
void work(int x){
    scanf(" %c", &tmp);
    if (tmp == '2'){
        for (int k = 1; k <= 4; k++){
            work(x - 1);
        }
    } else if (tmp == '0'){
        ans += pow(2, x) * pow(2, x);
    }
}
int main(){
    scanf("%d", &k);
    work(k);
    printf("%.0lf", ans);
    return 0;
}

```
#### 此代码时间复杂度 $O(size(s))$，空间复杂度 $O(1)$，完美过关！

---

## 作者：wgyhm (赞：2)

题目看过了了吗？？？

没看过 ~~滚~~ 回去看

### 只是 ~~很水的~~ 模拟题

------------


是不是看起来像递推分治？？？

好像可以，但是

我们可以在线做
_______________________________________


设 $p=k$ $p$表示当前的层数，越在外面的，层数越大

若 $c=='2'$ 则降层；

若 $c=='0'$ 则 $ans=ans+2p+2p$ 也就是 $ans+=pow(2,p+p)$

接下来处理返回层的问题

2的里面可能套了无数个2

## 所以，我们需要用 $while$

我们用一个数组a记录当前层已进入的多少块（$‘1’$或$‘0’$，共四个）

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k, a[101],p;
double ans;//long long不够，double来凑
char c;
int main()
{
	scanf("%d\n",&k);//必须要先读入换行符
	p=k;
	while ((c=getchar())!=EOF)
	{
		if (c=='2') p--;
		else if (c=='1') a[p]++;
		else if (c=='0') {ans+=pow(2,p+p);a[p]++;}
		while (a[p]==4) {a[p]=0;a[++p]++;}
	}
	printf("%.0lf",ans);//保留整数
	return 0;
}



---

## 作者：Night_Aurora (赞：2)

很显而易见的一个递归题

唯一有坑的是k的范围

(k=50时最大结果为(2^50)^2也就是2^100

怖い
用long long+右移是40分

用long long+pow多一点

最后把long long改成double才A


用一个CallBack(k)递归，k表示现在第几层

读入字符串后用一个全局变量P表示读到的位置

常用文件操作的应该能理解

CallBack每次读入一个字符并++P

如果是平地(0)就直接给全局结果+pow(2,nk\*2) nk表示当前递归函数的层数

1就不管，2就调用四个CallBack(nk-1)表示下面有四个下一层的数据

代码贴上




```cpp
#include <stdio.h>
#include <iostream>
#include <math.h>
typedef double _L;
int K;
char Str[300];
int P;
_L Sum;
void Input()
{
    scanf("%d",&K);
    scanf("%s",Str);
}
void CallBack(int nk)
{
    char c=Str[P++];
    if(c=='0')
        Sum=Sum+pow(2,nk*2);
    if(c=='2')
    {
        CallBack(nk-1);
        CallBack(nk-1);
        CallBack(nk-1);
        CallBack(nk-1);
    }
}
int main()
{
    Input();
    CallBack(K);
    printf("%.0f",Sum);
    putchar(10);
    return 0;
}

```

---

## 作者：jiangtaizhe001 (赞：1)

# 矿藏编码
先看题目，发现是一道模拟题，但是，模拟题并不是大家想象的那么简单， 其实也有蓝题，例如[P2778](https://www.luogu.com.cn/problem/P2278)
也是一道难题了。  
但是，不多说别的，先看这题怎么做。  
首先，从数据上判定，计算一下  2^100=1606938044258990275541962092341162602522202993782792835301376  
int爆掉了，long long也撑不住了，所以，应该用**double**（细节）  

接下来，让我们来深度剖析一下这道题目（样例）：  
2  
2021010210001  
2先不用看的~~不懂的自己面壁去~~  
还是看第二行吧。
![](https://cdn.luogu.com.cn/upload/image_hosting/6r4g6x0c.png)  
用红色框框起来的是一个组的。
其实，只要开一个数组，代表是层数，当层数是4时，就可以推下去的，但是，要用while，因为要多重判断。  

最后，剩下的细节变含在代码之中了, 
注意，模拟的精髓在于  
**卡常和细节**  
```cpp
#include<cstdio>//P2539
#include<cstring>
#include<cmath>
char s[201];
double ans;
int n,p[100],k,v;
using namespace std;
int main(){
	scanf("%d\n",&k); v=k;
    gets(s);
    n=strlen(s);
    for(int i=0;i<n;i++){
    	if(s[i]=='2'){
    		v--;
    		//p[v]==0;
    		continue;
		}
		if(s[i]=='0')
		    ans+=pow(pow(2,(double)v),2);
		p[v]++;
		while(p[v]>=4){
			p[v]=0;
			v++;
			p[v]++;
		}
	}
	printf("%0.0lf",ans);
	return 0;
}
```


---

## 作者：small_stone (赞：0)

一道显然的递归题。

不妨使用一个递归函数 $\operatorname{fun}$，边输入，边计算答案。

为 $\operatorname{fun}$ 函数添加一个参数 $x$，表示此时边长为 $2^x$。

执行 $\operatorname{fun}(x)$ 时，先输入字符 $ch$，如果 $ch=\texttt{0}$，将答案加上 $2^{2x}$。如果 $ch=\texttt{2}$，执行四次 $\operatorname{fun}(x-1)$。

但——答案最大可达 $2^{100}$，int 和 long long 存不下。

## \_\_int128

\_\_int128 是一种神奇的数据结构，由 $128$ 个二进制位储存，支持各种运算，但不支持 `cin\cout\scanf\printf` 等，需要自己写输入输出。这样我们就存得下了。

献上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
__int128 k,ans=0;
char ch;
__int128 read()
{
	__int128 x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
void write(__int128 x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
void fun(long long k) {
	cin>>ch;
	if (ch=='0') {
		ans+=pow(2,2*k);
		return;	
	}
	if (ch=='2') {
		for (long long i=1;i<=4;i++) fun(k-1);
	}
}
int main() {
	k=read();
	fun(k);
	write(ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题意：

该题目给出了一个编码规则，用于表示矿藏区的信息。

根据编码规则，$0$ 表示平地，$1$ 表示山峰。现在需要统计矿藏区中有多少个格子是平地。

编码规则如下：

- 如果整个矿藏区都是平地，则编码为 $0$。
- 如果整个矿藏区都是山峰，则编码为 $1$。
- 否则，将矿藏区均匀划分成 $4$ 份，并对每份进行编码，得到 $S_1$、$S_2$、$S_3$、$S_4$。该矿藏区的编码 $S$ 为 $2S_1S_2S_3S_4$。

输入给出了矿藏区的规模 $K$ 和编码 $S$，要求输出矿藏区中平地的格子数。

例如，样例输入中，矿藏区是一个 $2 \times 2$ 的方格区域，根据编码规则，可以得到以下 $4$ 个格子：平地、山峰、平地、平地。

因此，输出为 $3$。

请注意，这里的编码 $S$ 并不是实际的二进制数，而是按照编码规则生成的字符串。
### 思路：
这题挺简单，数据范围很小，可以自己暴力模拟来进行解决，不过你会发现，爆 long long 啦！

没事没事，基本上写一个高精度就能解决。
### 完整代码：
```cpp
#include <cctype>
#include <cstdio>
const int K = 105;
int A[100];
int a[K];
inline int get() {
  int c;
  while (!isdigit(c = getchar()));
  return c - '0';
}
void solve(int dep) {
  int t = get();
  if (t == 0)
    ++a[dep * 2];
  else if (t == 2) {
    solve(dep - 1);
    solve(dep - 1);
    solve(dep - 1);
    solve(dep - 1);
  }
}
int main() {
  int k;
  scanf("%d", &k);
  solve(k);
  int len = 1;
  for (int i = 0; i < k * 2; ++i) {
    a[i + 1] += a[i] / 2;
    a[i] %= 2;
  }
  for (int i = k * 2; ~i; --i) {
    int t;
    for (int j = t = 0; j < len; ++j) {
      t = (A[j] = A[j] * 2 + t) / 10;
      A[j] %= 10;
    }
    if (t) A[len++] = t;
    if (a[i]) ++A[0];
  }
  while (len--) putchar(A[len] + '0');
  putchar('\n');
  return 0;
}
```


---

## 作者：caohan (赞：0)

# 思路

直接模拟生成过程即可。虽然不好发现但是也不难。

这个没有准确思路，细节在代码里。

其中答案精度为 $2^{50\times 2}$ 足够撑破 long long 。

~~这个可千万别记忆化~~

# 代码

```cpp
#include<iostream>
#include<bits/stdc++.h>
#define ll double       //精度要求太高了
using namespace std;
ll ans=0;
string s;//那个数串
int k;
int p;//到哪一个了
void dfs(int x)
{
	char tmp=s[p++];//再往后一个
	if(tmp=='0')
	{
		ans+=/*pow(2,x)*pow(2,x)*/pow(2,2*x);//就是空地，加上面积即可
	}
	if(tmp=='2')
	{
		dfs(x-1);
		dfs(x-1);
		dfs(x-1);
		dfs(x-1);//分成四个更小的块来看
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>k>>s;
	dfs(k);//层级数量dfs 
	printf("%.0f",ans);//去掉小数位
	return 0;
}
```




---

## 作者：TLMPEX (赞：0)

这道题很明显是一个递推题，但要注意$2^{50}$会爆$long long$所以可以采用$double$类型，具体过程见代码。

代码：
```c
#include<bits/stdc++.h>
using namespace std;
string k;
int cnt;//下标
double f(int n){//n为递归层次
	char p=k[cnt++];//取出这个字符
	if(p=='0')return pow(2,n)*pow(2,n);//如果为0，则代表这一块全是平地，返回这块地的面积
	if(p=='1')return 0;//如果为1，则代表这块全是山地，返回0
	if(p=='2')return f(n-1)+f(n-1)+f(n-1)+f(n-1);//如果为2，则代表这块既有山地也有平地，继续递归
}
int main(){
	int n;
	cin>>n>>k;
	printf("%.0lf",f(n));
}
```


---

## 作者：_一只蒟蒻帆_ (赞：0)

矿藏编码题解
                               ——by _一只蒟蒻帆_

题目描述
![](https://s2.ax1x.com/2019/12/16/Q5KhSP.jpg)
 依次对每份进行编码，得S1，S2，S3，S4。该矿藏区的编码S为2S1S2S3S4。 例如上图中，矿藏区的编码为：2021010210001。 小联希望你能根据给定的编码统计出这片矿藏区一共有多少格子区域是平地。 
输入
第一行有一个整数K，表示有矿藏区的规模为 （1 < K < 50）。第二行有一串编码，有0、1组成，长度不超过200，表示该矿藏区的编码。
输出
单行输出一个整数，表示矿藏区中一共有多少格子是平地。
样例输入
2
2021010210001
样例输出
9

看到题目，哎呀，这不模拟吗？！可是，最坏情况答案会达到2k *2k，所以答案要用double才能卡过，况且不可能开2k *2k的数组啊！

于是，又仔细看题目：它要求我们求的是平地数量，而且它的矿藏编码公式是2S1S2S3S4，不难看出每出现一个2他所对的那块矿藏区域就存在不是全是平地（0）或山峰（1），需要再次分解成四块，直到那块矿藏区域满足全是平地或山峰。所以，我们又得出一个结论：经过多次分解，每个0所对应的平地数量也就不同。而且，每个0所对的平地数取决于它被分割了几次，而每分割n次，这个0所对应的空地数量就是2*（k-n）个啊！所以，我们不妨设p=k，每次出现2就p--，对应的ans就+=pow（2，p+p）。这不就好起来了吗！

而且，回到被分割前的那一块区域只要满足分割后（2出现后）存在四个数（0或1）。所以不妨设一个a[maxn],里面存2之后累计出现了几个0或1，如果达到4的话，先把a[p]清零，再把p加个1回去，不就AC了吗？

最后，代码实现：

```cpp
#include <bits/stdc++.h>

#define maxn 100010

using namespace std;

int k,p,a[maxn];

double ans;

char c;

int main(){

scanf("%d\n",&k);

p=k;

while (~(c=getchar())){

if (c=='2') p--;

else if (c=='1') a[p]++;

else if (c=='0') a[p]++,ans+=pow(2,p+p);

while (a[p]==4) a[p]=0,p++,a[p]++;

}

printf("%.0lf",ans);

return 0;

}
```


——THE END.——

---

## 作者：_•́へ•́╬_ (赞：0)

## 这么恐怖的数据，卡$\color{red}long long$
## 要用神奇的$\color{red}int128$
```cpp
#include<bits/stdc++.h>//懒人专用头文件
using namespace std;
int k,now;char a[233];
void pr(__int128 x){if(x>=10)pr(x/10);putchar((x%10)+'0');}//__int128不能用printf，要手写输出
__int128 dfs(int size)
{
	switch(a[now++])
	{
		case'0':return(((__int128)(1))<<size)*(((__int128)(1))<<size);
			//空地面积：(2^size)*(2^size)，用__int128储存，不然爆
		case'1':return 0;//没有空地
		case'2':return dfs(size-1)+dfs(size-1)+dfs(size-1)+dfs(size-1);
			//分4小部分继续递归
	}
}
main()
{
	scanf("%d%s",&k,a);
	pr(dfs(k));
}/**/
```

---


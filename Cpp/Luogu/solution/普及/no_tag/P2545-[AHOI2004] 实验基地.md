# [AHOI2004] 实验基地

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1656.png)

## 说明/提示

数据范围见输入格式。

## 样例 #1

### 输入

```
4
-1 2 -3 4
5 6 7 8```

### 输出

```
31```

# 题解

## 作者：Flying2018 (赞：11)

好像都是$n^2$的算法？来一发O(n)的

（~~好吧，可能是数据太水~~）

首先，考虑对于一列5个状态
1. 该列不选且之前未建过实验基地。
2. 该列不选且之前已经建完实验基地。
3. 该列全选且未建过样品采集区。
4. 该列全选且已建过样品采集区。
5. 该列选下面一行（上面建样品采集区）。

然后状态转移。
```
f[i][1]=f[i-1][1];//其实没必要，懒得删。
f[i][2]=max(f[i-1][2],f[i-1][4]);
f[i][3]=max(f[i-1][3],f[i-1][1])+上下;
f[i][4]=max(f[i-1][4],f[i-1][5])+上下;
f[i][5]=max(f[i-1][5],f[i-1][3])+下;
```
最后输出$max(f[n][2],f[n][4])$

然后莫名其妙就AC了。

下附代码
```
#include<cstdio>
#include<cstdlib>
#include<iostream>
#define NO -0xfffffff
using namespace std;
int f[1010][5];
int num[1010][2];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	scanf("%d",&num[i][0]);
	for(int i=0;i<n;i++)
	scanf("%d",&num[i][1]);
	f[0][0]=0;f[0][1]=num[0][0]+num[0][1];f[0][2]=f[0][3]=f[0][4]=NO;
	for(int i=1;i<n;i++)
	{
		f[i][0]=f[i-1][0];
		f[i][1]=max(f[i-1][1],f[i-1][0])+num[i][0]+num[i][1];
		f[i][2]=max(f[i-1][1],f[i-1][2])+num[i][1];
		f[i][3]=max(f[i-1][3],f[i-1][2])+num[i][0]+num[i][1];
		f[i][4]=max(f[i-1][3],f[i-1][4]);
	}
	printf("%d",max(f[n-1][3],f[n-1][4]));
	return 0;
}
```
如果有大佬发现问题可以发评论（毕竟n=1000···）

---

## 作者：一只书虫仔 (赞：5)

#### Description

> 给定一个 $2 \times N$ 的矩阵，求一个凹形块使得这个凹形块里的数字和最大。

#### Solution For $O(n^4)$

枚举大长方形，枚举第一行的小长方形，时间复杂度 $O(n^4)$。

#### Solution For $O(n^2)$

我们可以把一个凹形块拆开，比如这样：

```plain
---++---+++--    ---++  ---  +++--
---++++++++-- -> ---++  +++  +++--
```

左边和右边可以做一个最大子段和，每一位计算 $a[i][1]+a[i][2]$。

然后我们只需要枚举中间块的大小即可。

然后，我们发现这个的数据范围刚好为 $2000$，所以就过了，但我们还有一种可以过 $10^6$ 的方法。

#### Solution For $O(n)$

考虑分类讨论动归，依然是最大子段和，我们都知道最大子段和的动归方程是：

$$dp[i]=\max\{dp[i-1],0\}+a[i]$$

看前面的 $\max$，如果我们采用 $dp[i-1]$，代表第 $i$ 块接在了第 $i-1$ 块后。

如果是 $0$，那么代表我们要重新开始一个块。

那么，我们采取这样的思路，对这道题的模型进行分类讨论 —— 讨论怎样接块。

- 第一种，对一个长方形进行接块。

裸的最大子段和，$dp1[i]=\max\{dp1[i-1],0\}+a[i][1]+a[i][2]\}$。

- 第二种，对一个 $\tt L$ 形进行接块。

分为两种情况，第一种是对于一个长方形块后面接一个第二行的小块，第二种是对于一个 $\tt L$ 形块后面接一个第二行的小块，这两种分别做一个最大子段和并取一个 $\max$，即 $dp2[i]=\max\{dp1[i-1],dp2[i-1]\}+a[i][2]$。

- 第三种，对一个凹形进行接块。

分为两种情况，第一种是对于一个 $\tt L$ 形后面接一个块，第二种是对于一个凹形快后面接一个块，这两种分别做一个最大子段和并取一个 $\max$，即 $dp3[i]=\max\{dp2[i-1],dp3[i-1]\}+a[i][1]+a[i][2]$。

所以我们总和一下这三种情况即可。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[2086][3];
int dp1[2086];
int dp2[2086];
int dp3[2086];

int main () {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i][1]);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i][2]);
	int cnt = 0;
	memset(dp1, -0x3f, sizeof(dp1));
	memset(dp2, -0x3f, sizeof(dp2));
	memset(dp3, -0x3f, sizeof(dp3));
	for (int i = 1; i <= n; i++) {
		dp1[i] = max(dp1[i - 1], 0) + a[i][1] + a[i][2];
		if (i != 1 && i != n) dp2[i] = max(dp1[i - 1], dp2[i - 1]) + a[i][2];
		if (i != 1) dp3[i] = max(dp2[i - 1], dp3[i - 1]) + a[i][1] + a[i][2];
	}
	int Max = -0x3f;
	for (int i = 1; i <= n; i++) Max = max(Max, dp3[i]);
	printf("%d", Max);
	return 0;
}

```

By Shuchong       
2020.10.5

---

## 作者：redegg (赞：4)

全题唯一难点，如何快速求出样本最小的区间？

线段树是不行的，需要(n^3)复杂度，果断选择dp，dp[i][j]表示从第i个点开始，往后j个点的区间里最小的样本是什么。
转移方程是dp[i][j]=min(min(dp[i][j-1],dp[i+1][j-1]),c[i+j-1]-c[i-1])；c是第一列前缀和。

转移方程意思为我要么从原来的最小值转移，要么就从整一段转移。

求出每一个区间里最小样本后，直接循环两层，求和取max就好了。

代码在下：复杂度o(n^2):
```cpp
#include <bits/stdc++.h>
using namespace std;

long long c[10000];
long long k[10000];
long long b[10000];
long long a[10000];
long long dp[2005][2005];
long long maxn;
int n;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        c[i]=c[i-1]+a[i];
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&b[i]);
        k[i]=k[i-1]+a[i]+b[i];
    }
    for(int i=1;i<=n;i++)
        dp[i][1]=a[i];
    for(int k=2;k<=n;k++)
    {
        for(int i=1;i<=n-k+1;i++)
        {
            dp[i][k]=min(min(dp[i][k-1],dp[i+1][k-1]),c[i+k-1]-c[i-1]);
        }
    }

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i-1;j++)
        {
            maxn=max(k[i]-k[j-1]-dp[j+1][i-j-1],maxn);
        }
    }
    printf("%lld\n",maxn);
    return 0;
}

```

---

## 作者：zjj2024 (赞：3)

### 思路

考虑暴力枚举凹形左右边界得到的长方形，再减去中间部分和的最小值。

长方形总和可以使用前缀和。

求最小值可以使用线段树的方法维护。

维护方法可以参考 [P4513](https://www.luogu.com.cn/problem/P4513)，把最大值改为最小值即可。

就是对于每个区间，维护整段最小值、含左端点的最小值、含右端点的最小值和整段总和。

由于没有修改操作，故代码很短。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2005;
ll a[5][N],s[5][N];//前缀和
struct T
{
	ll mn,lmn,rmn,sum;
}w[8*N];
void pushup(int u)//上传
{
	int x=u<<1,y=u<<1|1;
	w[u].mn=min(min(w[x].mn,w[y].mn),w[x].rmn+w[y].lmn);
	w[u].lmn=min(w[x].sum+w[y].lmn,w[x].lmn);
	w[u].rmn=min(w[y].sum+w[x].rmn,w[y].rmn);
	w[u].sum=w[x].sum+w[y].sum;
}
void buid(int u,int l,int r)//建树
{
	if(l==r)
	{
		w[u]={a[1][l],a[1][l],a[1][l],a[1][l]};
		return;
	}
	int mid=(l+r)>>1;
	buid(u<<1,l,mid);
	buid(u<<1|1,mid+1,r);
	pushup(u);
}
T get(int u,int l,int r,int x,int y)//得到x到y之间的最小子段
{
	if(l>=x&&r<=y)return w[u];
	int mid=(l+r)>>1;
	if(mid>=x&&mid<y)
	{
		T a=get(u<<1,l,mid,x,y),b=get(u<<1|1,mid+1,r,x,y);
		return {min(min(a.mn,b.mn),a.rmn+b.lmn),min(a.sum+b.lmn,
						a.lmn),min(b.sum+a.rmn,b.rmn),a.sum+b.sum};
	}
	if(mid>=x)return get(u<<1,l,mid,x,y);
	return get(u<<1|1,mid+1,r,x,y);
}
int main()
{
	ios::sync_with_stdio(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[1][i];
		s[1][i]=s[1][i-1]+a[1][i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[2][i];
		s[2][i]=s[2][i-1]+s[1][i]-s[1][i-1]+a[2][i];
	}
	buid(1,1,n);
	ll ans=0;
	for(int i=1;i<=n;i++)
		for(int j=i-2;j>=1;j--)
			ans=max(ans,s[2][i]-s[2][j-1]-get(1,1,n,j+1,i-1).mn);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Adove (赞：3)

此题要求max(矩形值-上方最小连续子序列和)

我们枚举左右端点从左往右扫

观察到最小连续子序列和可以借助上一个位置的答案

于是我们就可以$\Theta (n^2)$求解了

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=3005;

int n,ans;
int a[2][MAXN];
int f[MAXN][MAXN];

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[1][i]);
	for(int i=1;i<=n;++i) scanf("%d",&a[0][i]);
	for(int i=1;i<=n-2;++i){
		int ct=0,minn=0x7fffffff,sum=a[1][i+1]+a[1][i]+a[0][i]+a[0][i+1];
		for(int j=i+2;j<=n;++j){
			ct=min(ct,0);
			ct+=a[1][j-1];minn=min(minn,ct);
			sum+=a[0][j]+a[1][j];
			ans=max(ans,sum-minn);
		}
	}printf("%d\n",ans);
	return 0;
}
```

---

## 作者：z2415445508 (赞：3)

好像还没有题解用的是二维，果断来一发。

理解一下题意，实际上我们要求的就是一个U型的最大得分，而整个矩形都只有两行：岂不是喜滋滋？

深入理解一下：既然是求最大得分，即第一行的中间有连续部分不取，而第二行的底座必须都取，那不是就是在提醒我们要用前缀和解题更加轻便快捷吗！！！！！

也就是提前把以i，j为端点的左右前缀和处理出来，再枚举一下哪一个点不取是最优解，那么不就是正解了吗。

状态转移方程：ans = max{ l[i] + r[j] + x[j-1] - x[i] }  (1 <= i < j - 1 <= n - 1);

思路完毕，下面上代码


```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>//头文件库不推荐使用万能头文件,map之类的变量名容易引发错误
using namespace std;
const int MAXM = 2050;
typedef long long int lolo;
lolo n,l[MAXM],r[MAXM],ans,sumup[MAXM],sumdown[MAXM];
lolo up[MAXM],down[MAXM],sum[MAXM];
int main()
{
    std::ios::sync_with_stdio(false);//关闭cin与stdio的同步，效率比scanf快。
    cin>>n;
    for (int i=1;i<=n;i++)    cin>>up[i],sumup[i]=sumup[i-1]+up[i];//实际上up和down两个数组没必要，但是便于理解
    for (int i=1;i<=n;i++)    cin>>down[i],sumdown[i]=sumdown[i-1]+down[i];
    for (int i=1;i<=n;i++)    sum[i] = sumdown[i]+sumup[i];//求出整个的前缀和。
    memset(l,128,sizeof(l));//127为极大值，128为极小值
    memset(r,128,sizeof(r));
    for (int i=1;i<=n;i++)
        for (int j=0;j<=i-1;j++)
            l[i] = max(l[i],sum[i]-sum[j]);//处理出左边(l可理解为left)的上下两部分的前缀和
    for(int i=n-1; i >= 0; i --)
        for(int j=n; j >= i + 1;j --)
            r[i + 1] = max(r[i + 1],sum[j] - sum[i]);//处理出Right的上下两部分的前缀和
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
               if(l[i-1]>0&&r[j+1]>0)
                ans=max(ans,sumdown[j]-sumdown[i-1]+l[i-1]+r[j+1]);//既要包括右边和左边的所有部分，又要让上面有空缺（需要长得像U）
    printf("%d",ans);
}
//有问题可私信

```

---

## 作者：Celebrate (赞：2)

给大家推荐一下:[MyBlog](https://blog.csdn.net/zsyzClb/article/details/85063201)

这一题中n<=2000 所以可以想到O(N^2)

这一题的意思是在2*n的矩阵中找出权值和最大的U型，因为有负数，所以我们要找出最小的子段和

那么怎么求这个值呢？

我们可以定义一个s，不断的加当前位置的数，如果s的值变为是正数，那么肯定不是最有的，所以s重置为0

反之如果当前是数正数，不一定要断开这一段累加，因为s可能还是负数，如果后面也有负数，就对后面会有帮助

因此只有当s>0 的时候把s变为0

并且定义一个minn记录当前搜索的s的最小值，因为当前的s不一定是最优的，也没有必要用当前的s

如果看不懂这一段文字，那么代码一定能够帮助您

```cpp
#include <iostream>
 
using namespace std ;
 
const int N = 2e3 + 10 ;
 
int n , a[N][2] ; 
int ans = -999999999 ; //ans记录全局最优解 
 
int main() {
	cin >> n ;
	for ( int i = 1 ; i <= n ; i ++ ) cin >> a[i][0] ; //输入 
	for ( int i = 1 ; i <= n ; i ++ ) cin >> a[i][1] ;
	for ( int i = 1 ; i <= n - 2 ; i ++ ) {
		int now , minn = 0, s = 0 ; //min记录最小的s，now表示当前所有的和 
		now = a[i][0] + a[i][1] + a[i+1][0] + a[i+1][1] ;
		for ( int j = i + 2 ; j <= n ; j ++ ) {
			s += ( a[j-1][0] ) ; s = min ( s , 0 ) ; //累加，如果超过0就变为0 
			minn = min ( minn , s ) ; //记录最小值 
			now += a[j][0] + a[j][1] ; //累加一下 
			ans = max ( ans , now - minn ) ; //记录最大值 
		}
	}
	cout << ans << endl ; //输出 
	return 0 ;
}

```

然而这不是最快的，其实还有一个O（n）的做法，即使n有几千万都不怕（记得加快读，cin中看不中用）

我们定义5个状态 ：

1.该列不选且之前未建过实验基地。

2.该列不选且之前已经建完实验基地。

3.该列全选且未建过样品采集区。

4.该列全选且已建过样品采集区。

5.该列选下面一行（上面建样品采集区）
 
状态继承也很简单：

```cpp
dp[i][1] = dp[i-1][1] ;
dp[i][2] = max ( dp[i-1][2] , dp[i-1][4] ) ;
dp[i][3] = max ( dp[i-1][1] , dp[i-1][3] ) + a[i][0] + a[i][1] ;
dp[i][4] = max ( dp[i-1][4] , dp[i-1][5] ) + a[i][0] + a[i][1] ;
dp[i][5] = max ( dp[i-1][3] , dp[i-1][5] ) + a[i][1] ;

```

这个继承是很好看懂的，我就不多说了，上一个代码（加滚动数组优化）

```cpp
#include <iostream>
 
using namespace std ;
 
const int N = 2e3 + 10 ;
 
int n , a[N][2] ; 
int dp[2][7] ;  
 
int main() {
	cin >> n ; 
	for ( int i = 1 ; i <= n ; i ++ ) cin >> a[i][0] ;
    for ( int i = 1 ; i <= n ; i ++ ) cin >> a[i][1] ;
	dp[1][1] = 0 ; dp[1][3] = a[1][0] + a[1][1] ;
	dp[1][2] = dp[1][4] = dp[1][5] = -999999999 ;
	for ( int i = 2 ; i <= n ; i ++ ) {
		dp[i&1][1] = dp[i&1^1][1] ;
		dp[i&1][2] = max ( dp[i&1^1][2] , dp[i&1^1][4] ) ;
		dp[i&1][3] = max ( dp[i&1^1][1] , dp[i&1^1][3] ) + a[i][0] + a[i][1] ;
		dp[i&1][4] = max ( dp[i&1^1][4] , dp[i&1^1][5] ) + a[i][0] + a[i][1] ;
		dp[i&1][5] = max ( dp[i&1^1][3] , dp[i&1^1][5] ) + a[i][1] ;
	}
	cout << max ( dp[n&1][2] , dp[n&1][4] ) << endl ;
	return 0 ;
}

```

给大家留一个问题：

请问为什么O(N^2)代码比O(N)的代码快？快在何处？

---

## 作者：Shadow_T (赞：1)

### 前言

粗略看了下，本题的题解大部分是远古的，$\LaTeX$ 非常不舒服，决定来写一篇。

### 题目大意

给定一个 $2×N$ 的矩阵，找到一个凹陷块使得这个凹陷块里的数字和最大，且输出和。

### 分析

$3\leq N\leq 2000$ 的数据 $Θ(n^3)$ 大概不能通过。

考虑 $Θ(n^2)$ 做法。不规则图形做起来较麻烦，但是凹字形的图形只有两行，那就简单了。

其实所谓的凹字形就是底座取一个连续，上面的部分先从底座复制上去，在挖空一个连续段。既然都是**连续**段，那么我们可以用前缀和来维护，然后枚举每个矩阵取大值即可。

### 代码

```cpp
#include <bits/stdc++.h> 
using namespace std;
#define int long long
int l[2001],r[2001];
int up[2001],down[2001];
int sum[2001];
void init()
{
	memset(l,-0x3F,sizeof l);
	memset(r,-0x3F,sizeof r);
}
signed main()
{
	init();
	int n,x,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>x,up[i]=up[i-1]+x;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		down[i]=down[i-1]+x;
		sum[i]=down[i]+up[i];
	}
	for(int i=1;i<=n;i++)
	for(int j=0;j<=i-1;j++)
	l[i]=max(l[i],sum[i]-sum[j]);
	for(int i=n-1;i>=0;i--)
	for(int j=n;j>=i+1;j--)
	r[i+1]=max(r[i+1],sum[j]-sum[i]);
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j++)
	if(l[i-1]>0&&r[j+1]>0)
	ans=max(ans,down[j]-down[i-1]+l[i-1]+r[j+1]);
	cout<<ans;
}
```

---

## 作者：让风忽悠你 (赞：1)

[原题](https://www.luogu.com.cn/problem/P2545)

## 序

看到题解里大多都是 $O(n^2)$ 的，其实这道题的 $O(n)$ 解法还是非常有思维难度的。

## 题意

- 给出一个 $2*w_1$ 的矩形，求和最大的凹形块。
- 凹形块的定义为在矩阵中第一行挖去一块 $1*w_2$ 的矩形，且必须保证挖去这个矩形后第一行两端都有残留部分。

## 分析

对于每个凹形块，我们可以将他分成三部分，分别是**左边上下两行都选择的部分，中间只选第二行的部分，以及右边上下两行都选择的部分**，然后考虑分三个阶段进行 dp。

## 做法

用 $a_{i,0}$ 表示第 1 行第 $i$ 个元素，用 $a_{i,1}$ 表示第 2 行第 $i$ 个元素，$f_{i,0}$ 表示到第 $i$ 列**为止**的**左边**部分的元素的和的最大值，$f_{i,1}$ 表示到第 $i$ 列**为止**的**左、中**部分的元素的和的最大值，$f_{i,2}$ 表示到第 $i$ 列**为止**的**左、中、右**部分的元素的和的最大值，所以我们可以得到以下状态转移方程：

$$f_{i,0}=max(f_{i-1,0},0)+a_{i,0}+a_{i,1}$$
$$f_{i,1}=max(f_{i-1,0},f_{i-1,1})+a_{i,0}$$
$$f_{i,2}=max(f_{i-1,1},f_{i-1,2})+a_{i,0}+a_{i,1}$$

因为每个状态都是由上一个状态转移来的，而且要选择的是非空矩形，$f_{i,0}=f_{i,1}=f_{i,2}=-\infty$

## 代码

```cpp
#include<cstdio>
#include<algorithm> 
#define N 5000001
#define inf 1e9
#define ll long long

using namespace std;

int n,a[N][2],f[N][3];
ll ans=-inf;

int main(){
	scanf("%d",&n);
	if(n<=2){
		printf("0");
		return 0;
	} // 题目中提到的凹形块的 w1 要大于2 
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i][0]);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i][1]);
	f[0][0]=f[0][1]=f[0][2]=-inf; 
	for(int i=1;i<=n;i++){
		f[i][0]=max(f[i-1][0],0)+a[i][0]+a[i][1];
		f[i][1]=max(f[i-1][0],f[i-1][1])+a[i][1];
		f[i][2]=max(f[i-1][1],f[i-1][2])+a[i][0]+a[i][1]; // dp
		ans=max(ans,1ll*f[i][2]); // 取最大结果 
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：xuan_never (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2545)

## 简化题意
给出 $2$ 个 $N$ 的数列 $a,b$，找到一对 $l,r$ 使 $a,b$ 中 $l\sim r$ 的**和**减 $a$ 中 $l+1\sim r-1$ 的**最小非空子段和**最大。

## 做法
区间和可以用前缀和 $O(n)$ 维护，而最小非空子段和可以用 $O(n^2)$ 预处理（记录包含左端点的最小子段和包含右端点的最小子段和）。  
最后枚举上述的 $l,r$ 寻找最大的值就可以了，总体时间复杂度 $O(n^2)$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, a[2003], b[2003], f[2003][2003], lf[2003][2003], rf[2003][2003], ans = LONG_LONG_MIN;
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i)
			cin >> a[i],
			f[i][i] = lf[i][i] = rf[i][i] = a[i],
			a[i] += a[i - 1];
	for (int l = 2; l <= n; ++l)
		for (int i = 1, j = l, m = j + 1 >> 1; j <= n; ++i, ++j, ++m)
			lf[i][j] = min(lf[i][m], a[m] - a[i - 1] + lf[m + 1][j]),
			rf[i][j] = min(rf[m + 1][j], a[j] - a[m] + rf[i][m]),
			f[i][j] = min({f[i][m], f[m + 1][j], rf[i][m] + lf[m + 1][j]});
	for (int i = 1; i <= n; ++i)
			cin >> b[i], b[i] += b[i - 1];
	for (int i = 1; i <= n; ++i)
		for (int j = i + 2; j <= n; ++j)
			ans = max(ans, b[j] - b[i - 1] + a[j] - a[i - 1] - f[i + 1][j - 1]);
	cout << ans;
	return 0;
}
```
赛前发题解，RP++。

---

## 作者：Up_Xu (赞：0)

# 思路
一道水题。果断暴力。

先处理中间凹进去的部分。由题意得，这部分的值越小越好。则先枚举起点，再枚举终点，累加求最小即可。

再求答案。先枚举起点，再枚举终点，累加再减掉上一步求过的最小值，最后求最大即可。
# 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N=2e3+10;
long long n,i,j,sum,ma,a[N],b[N],fa[N][N];
int main(){
	cin>>n;
	for(i=1;i<=n;i++)cin>>a[i];
	for(i=1;i<=n;i++)cin>>b[i];
	
	for(i=1;i<=n;i++){//枚举起点
		sum=0;
		fa[i][i-1]=2e9; 
		for(j=i;j<=n;j++){//枚举终点
			sum+=a[j];//累加
			fa[i][j]=min(fa[i][j-1],sum);//求最小
			if(sum>=0)sum=0;
		}
	}
	
	for(i=1;i<=n;i++){//枚举起点
		sum=0;
		for(j=i;j<=n;j++){//枚举终点
			sum+=a[j]+b[j];//累加
			if(j-i>=2)//判断中间是否可以挖空
				 ma=max(ma,sum-fa[i+1][j-1]);//求最大
		}
	}
	
	cout<<ma;
}	
```

---

## 作者：jb123456 (赞：0)

#### 暴力+最大子段和。 
我们可以暴力选择前后的端点，判断中间的实验基地最大可以是多少。

因为第二行是一定的，所以可以用前缀和快速求和。
第一行就是要选出不为头尾的最小的一段，因为上面一段的子段和减去这一段，和就会最大，这样两行加起来就会最大。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2005],b[2005],f[2005];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i]=f[i-1]+a[i];//前缀和
		a[i]=-a[i];//改变正负，这样只要求最大子段和
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		b[i]+=b[i-1];//前缀和
	}
	int s=-1e9;
	for(int i=1;i<=n;i++){
		int x=0,h=-1e9;
		for(int j=i+1;j<n;j++){
			x+=a[j];
			h=max(h,x);//最大字段和
			if(x<0)x=0;
			s=max(s,f[j+1]-f[i-1]+b[j+1]-b[i-1]+h);//第一行的和+第二行的和-第一行最小的一段数字
		}
	}
	cout<<s;
	return 0;
}
```


---

## 作者：Ar_cher (赞：0)

不知道为什么 $n$ 会是 $2000$ 而不是 $10^6$。

这道题的 $O(n)$ 做法很显然。考虑把"凹"形拆成两个同时选择两行的区间中间夹一个只选择下面一行的区间。

这样我们首先可以对所有的点 $p$ 处理出它向左/向右延伸的最大权值的选择两行的区间，分别记为 $L[i]$，$R[i]$。

这时我们已经可以 $O(n^2)$ 枚举中间只选择下面一行的区间，$O(1)$ 统计答案了。

但实际上我们可以更优秀，考虑一个只选择下面一行的区间的答案，是 $R[r] +L[l]+sum[r-1]-sum[l]$。其中 $sum$ 是下一行的前缀和。

考虑 $r$ 一定的情况下，我们只需要知道 $f[l]=L[l]-sum[l]$ 的最小值就行了，这个用单调栈维护即可。

~~我懒写了个 $O(n^2)$。~~

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e3+5;
ll sum[N],down[N],L[N],R[N];
ll ans=0;
int n;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>sum[i];
    for(int i=1;i<=n;i++){
    	cin>>down[i];
		sum[i]+=down[i];
    }
    for(int i=1;i<=n;i++){
    	sum[i]+=sum[i-1];
		down[i]+=down[i-1];
	} 
    memset(R,-0x3f,sizeof(R));
    memset(L,-0x3f,sizeof(L));
    ans=-0x3f3f3f3f3f3f3f3f;
    for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++)
        	R[i]=max(R[i],sum[j]-sum[i-1]);
    }
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=i;j++)
        	L[i]=max(L[i],sum[i]-sum[j-1]);
    }
    for(int i=1;i<=n;i++){
    	for(int j=i+2;j<=n;j++)
        	ans=max(ans,L[i]+R[j]+down[j-1]-down[i]);
	}
    cout<<ans;
    return 0;
}
```


---

## 作者：aha浮云 (赞：0)

话说这个题直接暴力啊，，

就是在一个矩形里挖一块小矩形

那么先对两行求个前缀和

问题就转换为求上面那个数列的最小子段和

那么很显然了

暴力嘛， 直接上线段树

~~然后复杂度就从n^2 变成了n^2 * log2n~~
勉强卡过（~~全场最慢什么鬼~~qwq）
下面是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n = 2010;
int a[max_n], b[max_n], sum[max_n];
int n, cnt, tot;
struct Node
{
    int l, r, front, behind, val, sum;
    Node *lc, *rc;
}node1[max_n * 4], node2[max_n * 4], A[max_n];
void Push_Up1(Node *root)
{
    root->val = min(root->lc->val, root->rc->val);
    root->val = min(root->val, root->lc->behind + root->rc->front);
    root->sum = root->lc->sum + root->rc->sum;
    root->front = min(root->lc->front, root->lc->sum + root->rc->front);
    root->behind = min(root->rc->behind, root->lc->behind + root->rc->sum);
}
void buildtree1(Node *root, int L, int R)
{
    root->l = L, root->r = R;
    int mid = (L + R) >> 1;
    if(L == R) 
    {
        root->sum = a[L];
        root->front = root->behind = a[L];
        root->val = a[L];
        return;
    }
    root->lc = &node1[++ cnt];
    root->rc = &node1[++ cnt];
    buildtree1(root->lc, L, mid);
    buildtree1(root->rc, mid + 1, R);
    Push_Up1(root);
}
Node Query1(Node *root, int L, int R)
{
    if(root->l == L && root->r == R)
    return *root;
    int mid = (root->l + root->r) >> 1;
    if(R <= mid) return Query1(root->lc, L, R);
    else if(L > mid) return Query1(root->rc, L, R); 
    else 
    {
        Node t, t1, t2;
        t1 = Query1(root->lc, L, mid);
        t2 = Query1(root->rc, mid + 1, R);
        t.lc = &t1, t.rc = &t2;
        Push_Up1(&t);
        return t;
    } 
}
int main()
{
    cin >> n;
    for(int i = 1;i <= n; i++)
    scanf("%d", &a[i]);
    for(int i = 1;i <= n; i++)
    scanf("%d", &b[i]);
    for(int i = 1;i <= n; i++)
    sum[i] = sum[i - 1] + a[i] + b[i];
    buildtree1(node1, 1, n);
//	for(int i = 1;i <= cnt; i++)
//	printf("%d %d %d %d %d %d\n", node1[i].l, node1[i].r, node1[i].sum, node1[i].val, node1[i].front, node1[i].behind);
    int Ans = -0x7f7f7f7f;
    for(int i = 1;i <= n; i++)
        for(int j = i + 2;j <= n; j++)
            Ans = max(Ans, sum[j] - sum[i - 1] - Query1(node1, i + 1, j - 1).val);
    cout << Ans << endl;
    return 0;
}
```
~~是不是很暴力啊~~

---

## 作者：ningyuheng (赞：0)

//这道题就是一道动态规划的题，枚举开始的位置，后面的位置直接用一道动态规划就过掉了

```cpp
//ps:详情请看题解
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int n,i,j,a[3][2002],b[2002][2002][3],max1=-2000000000;
int main()
{
    cin>>n;
    for(i=1;i<=2;i++)
        for(j=1;j<=n;j++)
            cin>>a[i][j];//输入 
    for(i=1;i<=n;i++)
        for(j=i;j<=n;j++)
        {
            if(j<n-1)//如果到了第n-1个登陆地带时还没有建造实验基地时就不符合题意 
                b[i][j][0]=b[i][j-1][0]+a[1][j]+a[2][j];//b[i][j][0]表示从i开始到j还没有建实验基地的最多的试用度 
            else
                b[i][j][0]=-2000000000;
            if(j!=i&&j!=n)//如果到第i个登陆地带已经开始建造实验基地或第n个登陆地带时还没有完成建造实验基地时也不符合题意
                b[i][j][1]=max(b[i][j-1][1],b[i][j-1][0])+a[2][j];//b[i][j][1]表示从i开始到j已经开始建造实验基地的最多的试用度
            else
                b[i][j][1]=-2000000000;
            if(j>i+1) //不可能在第i个或第i+1个登录地带就已经建造完成了实验基地
                b[i][j][2]=max(b[i][j-1][2],b[i][j-1][1])+a[1][j]+a[2][j];//b[i][j][2]表示从i开始到j已经建完实验基地的最多的试用度 
            else
                b[i][j][2]=-2000000000;
            max1=max(b[i][j][2],max1);//统计建完了实验基地的最大值 
        }
    cout<<max1<<endl;//输出 
    return 0;
}
```

---

## 作者：姚文涛 (赞：0)

//个人觉得这道题的重点就在求第一层每个区间的最小值、


```cpp
//可以用DP来求解、
//F[I,J]=MIN(F[I,J-1],F[I+1,J])
//剩下的很简单了、
const maxn=2001;
var  n,i,j,ans,z,k:longint;
     s,b:array[0..maxn] of longint;
     a:array[1..2,0..maxn] of longint;
     f:array[0..maxn,0..maxn] of longint;
function max(a,b:longint):longint;
begin
        if a>b then exit(a) else exit(b);
end;
function min(a,b:longint):longint;
begin
        if a<b then exit(a) else exit(b);
end;
begin
        readln(n);
        for i:=1 to 2 do
                for j:=1 to n do
                read(a[i,j]);
        for i:=1 to n do
        begin
                s[i]:=s[i-1]+a[1,i]+a[2,i];
                b[i]:=b[i-1]+a[1,i];
        end;
        for k:=1 to n-2 do
        for i:=2 to n-k do
        begin
                j:=i+k-1;
                f[i,j]:=min(min(f[i,j-1],f[i+1,j]),b[j]-b[i-1]);
        end;
        for i:=1 to n-2 do
        for j:=i+2 to n do
                ans:=max(ans,s[j]-s[i-1]-f[i+1,j-1]);
        writeln(ans);
end.
type link=^node; 
     node=record 
      data,h:longint;{储存的值和高度} 
      l,r:link;{左右子树的地址} 
     end;{树的定义} 
var i,j,k,m,n,t,l,r:longint; 
    biao:array[1..maxint] of link;{左偏森林} 
    q,g,tree:link;{g是空指针q是用来操作的指针} 
procedure swap(var aa,bb:link);{交换指针} 
var cc:link; 
begin 
 cc:=aa; 
 aa:=bb; 
 bb:=cc; 
end; 
function min(aldi,bldi:longint):longint;{较小值} 
begin 
 if aldi>bldi then 
        exit(bldi) 
 else   exit(aldi); 
end; 
function union(x,y:link):link;{合并操作} 
begin 
 if x=g then exit(y); 
 if y=g then exit(x);{一者空则返回令一者} 
 if x^.data>y^.data then 
        swap(x,y);{使得x指向较小的根y指向较大的根} 
 x^.r:=union(x^.r,y);{合并x的左子树和y到x的左子树} 
 x^.h:=min(x^.l^.h,x^.r^.h)+1;{维护高度}{若是权重树则x^.h:=x^.l^.h+x^.r^.h+1} 
 if x^.l^.h<x^.r^.h then 
        swap(x^.l,x^.r);{维护左子树大于等于右子树的性质} 
 exit(x);{返回} 
end; 
procedure init;{输入} 
begin 
 readln(n); 
 new(g); 
 g^.l:=g; 
 g^.r:=g; 
 g^.data:=0; 
 g^.h:=0;{初始化空指针} 
 for i:=1 to n do 
  begin 
         read(t); 
         new(q); 
         q^.data:=t; 
         q^.l:=g; 
         q^.r:=g; 
         q^.h:=1; 
         biao[i]:=q; 
        end;{建立森林} 
 l:=1; 
 r:=n;{队列的首末指针} 
end; 
function chu(var head:link):longint;{删除并返回最小根} 
begin 
  chu:=head^.data; 
  dispose(head); 
  head:=union(head^.l,head^.r); 
end; 
procedure print(qq:link);{从小到大输出} 
begin 
  for i:=1 to n do 
        begin 
         t:=chu(qq); 
         write(t,' '); 
        end; 
  writeln; 
end; 
procedure suan; 
begin 
 while l<r-1 do{初始化} 
        begin 
         q:=union(biao[l mod maxint],biao[(l+1) mod maxint]); 
         inc(l,2); 
         inc(r); 
         biao[r]:=q; 
        end;{一次合并两个以获得更快的效率}{这里相当于队列} 
 if l=r-1 then 
        tree:=union(biao[l mod maxint],biao[(l+1) mod maxint]){剩两棵} 
 else   tree:=biao[l mod maxint];{只剩一棵} 
 print(tree);{打印} 
end; 
Begin 
 init; 
 suan;
end.

```

---


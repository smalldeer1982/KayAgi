# [AHOI2002] 哈利·波特与魔法石

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1681.png)


## 样例 #1

### 输入

```
0 1 0 0 0 0 0
1 4
4
1 2 1
1 3 1
2 4 2
3 4 3```

### 输出

```
5```

# 题解

## 作者：zjy111 (赞：12)

### 这是绿名蒟蒻第二次发题解（第一次没有通过）......
一道相对简单的省选题（最短路模板题）~~也是我AC的第一道绿题~~

每两个城市之间的时间由地形和有无魔法石决定，而每个地形通过的时间是固定的（2,6,4,8,6,10,14），输入了魔法石的有无，所以时间就出来了。

 众所周知，最短路算法很多，这里我选用了Floyd算法（时复N^3），我觉得比较好懂，代码也简单（城市编号不超过100，这不是明显暗示用Floyd吗）~~反正我连Dijkstra都不会~~
 
以下是Floyd具体思路：

### 用dis[i][j]数组表示i~j的最短路径，从1~n枚举中间点k，如果从i到j过k有更短的路径就刷新，否则保留原来路径（有点动规思想，转移方程：dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])）
注意事项：
1 循环时要把中间点k放在最外层； 
2 一开始时（输入前）每两个点之间都是没有路的，所以距离要标成无限而不是0，否则会导致所有点之间的距离都是0
3 这种算法只适用于无负环图（也就是不存在边权值和＜0的环）~~不过好像和这题没有关系~~

献上码风奇特的代码（有一些注释，不过我语文不太好，还请见谅）
```cpp
#include <bits/stdc++.h>
using namespace std;
unsigned long long i,j,k,x,y,c,dist[105][105];//这个数组记录距离 
int s[8]={99999,2,6,4,8,6,10,14};//这个数组记录每个地形花费时间(我习惯从1开始,所以s[0]要空出) 
bool ck[8];//判断有没有石头 
int main(){
	memset(dis,100000,sizeof(dis));//初始化:必须足够大(即一开始最短路是无限长) 
	for(i=1;i<8;i++)cin>>ck[i]; 
	cin>>x>>y>>c;//x起点,y终点(我更习惯用变量i,j写for循环) 
	if(x==y){ //特判:如果x,y相等就是0!!!!(第一次提交WA了9号点,就因为这个) 
		cout<<0;
		return 0;
	}
	while(c--){
		cin>>i>>j>>k;
		if(ck[k]){ //有石头,花费减半 
			dis[i][j]=s[k]/2;
			dis[j][i]=s[k]/2;//注意这里是双向边,所以两头都要记录	
		}
		else { //没石头,花费照常 
			dis[i][j]=s[k];
			dis[j][i]=s[k];
		}
	}
	for(k=1;k<=100;k++){ //Floyd核心代码,具体思路见上(注意中间点循环放最外层) 
		for(i=1;i<=100;i++){
			for(j=1;j<=100;j++){
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
	cout<<dis[x][y]<<endl;//最后输出从x到y最短路距离 
	return 0;
}
```



---

## 作者：pengym (赞：10)

    
    
    
    
```txt  
    这道题一开始看是AHOI以为很难，但仔细读过题之后，竟然就是一道裸的最短路水题。只需要把图
建好就行了
    看到没人写SPFA，于是我来写一下
    这题的主要思路是：首先把题目中所给的每一个地形的表给打出来，之后再根据读入的s数组建好图
，再跑一遍裸的SPFA就可以了。

```
```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 20010
using namespace std;
inline void read(int &x)
{
    x=0;
    int p=1;
    char c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    x*=p;
}//快速读入
int h[10]={0,2,6,4,8,6,10,14};//这是地形的表
int s[10];
int S,T,c,e;
const int inf=0x3f3f3f3f;
int to[N],beg[N],nex[N],w[N],vis[N],dis[N];
void add(int x,int y,int z)
{
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
    w[e]=z;
}
void SPFA()
{
    memset(dis,inf,sizeof(dis));//这里只执行一次，不需要清标记数组
    queue<int>q;//队列优化
    q.push(S);
    vis[S]=1;
    dis[S]=0;
    while(!q.empty())
    {
        int k=q.front();
        q.pop();
        vis[k]=0;
        for(int i=beg[k];i;i=nex[i])
        {
            int y=to[i];
            if(dis[y]>dis[k]+w[i])//松弛操作
            {
                dis[y]=dis[k]+w[i];
                if(!vis[y])
                {
                    vis[y]=1;
                    q.push(y);
                }
            }
        }
    }
    printf("%d\n",dis[T]);
}
int main()
{
    for(int i=1;i<=7;i++)read(s[i]);    
    read(S);read(T);
    read(c);
    for(int i=1;i<=c;i++)
    {
        int tmp;
        int x,y,z;
        read(x);read(y);read(tmp);
        if(s[tmp])z=h[tmp]/2;//算出路径的权值
        else z=h[tmp];
        add(x,y,z);
        add(y,x,z);//无向图
    }
    SPFA();//最短路
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

# 鄙人历尽沧桑，终于AC了

**这其实是一个最短路板子题，_~~结果我被地形整得东倒西歪~~_**

假设：城市u和城市v之间有一种地形w，

所耗费的时间就为h[w]，而万万不是h[u]！

如果s[w]==1，所耗费的时间改为h[u]/2。但是，还要再建立一个变量ww，来记录h[w]/2，不可以改动h[w]的原值！

**_废话不多说，板子迪杰克斯拉：_**
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
int h[8]={0,2,6,4,8,6,10,14};
int s[8];
int from,t,d[110],c;
struct edge
{
	int to,cost;
};
vector<edge>G[110];//vector存图 
typedef pair<int,int>P; 
void dijkstra(int s)
{
	for(int i=1;i<=110;i++) d[i]=1e9;//赋初值 
	priority_queue<P,vector<P>,greater<P> >q;//定义优先队列q 
	d[s]=0;//自己本身到自己本身的距离是0 
	q.push(P{0,s});//加入到队列里 
	while(!q.empty())//只要还有元素 
	{
		P p=q.top();//取队首 
		q.pop();//声明一下，p.first代表距离，p.second代表一个点 
		int v=p.second;//为了方便一些，存在变量里 
		if(d[v]<p.first) continue;
		for(int i=0;i<G[v].size();i++)
		{
			edge e=G[v][i]; 
			if(d[e.to]>d[v]+e.cost)//松弛操作，贪心思想 
			{
				d[e.to]=d[v]+e.cost;
				q.push(P{d[e.to],e.to});
			}
		}
	}
}
int main()
{
	for(int i=1;i<=7;i++) scanf("%d",&s[i]);
	scanf("%d%d%d",&from,&t,&c);
	while(c--)
	{
		int u,v,w;//vector存图 
		scanf("%d%d%d",&u,&v,&w);
		int ww=h[w];
		if(s[w]==1) ww/=2;
		G[u].push_back(edge{v,ww});//无向图 
		G[v].push_back(edge{u,ww});//如果您存了有向图只能得到30分 
	}
	dijkstra(from);
	printf("%d\n",d[t]);//输出 
	return 0;//养成良好习惯 
}
```


---

## 作者：火车司机 (赞：3)

## 简要分析

很明显是一道最短路，可惜题目中没有给出数据范围（~~反正我是看其他题解的数组大小的AwA~~

稳妥起见肯定是一遍堆优化的 $dijkstra$

主要的考点在于建图

首先，题目给出了 $7$ 种地形的边权，我们可以用一个数组先存起来

然后，第一行题目会输入 $7$ 个 $0$ 或 $1$ ，如果输入的是 $1$ ，那我们加边时需要将该地形的边权除以 $2$

在这里，我们可以用位运算中的 **左移** 操作，左移 $1$ 就相当于除以 $2$

建完图跑一遍最短路就行了

## 完整代码

```cpp
#include <bits/stdc++.h>
#define ri register int
using namespace std;
int S, T, m, x, y, z, tot = 0, h[20005] = {0}, vis[20005] = {0}, dis[20005] = {0}；
int s[8] = {0, 2, 6, 4, 8, 6, 10, 14};
struct edge {
	int u, v, w;
} e[2 * 20005] = {0};
struct node {
	int d, p;
	bool operator < (const node &x) const {
		return x.d < d;
	}
} tmp;
priority_queue <node> q;
inline int read() {		//快读
	int x = 0;
	char c = getchar();
	for (; c < 48 || 57 < c; ) c = getchar();
	for (; 48 <= c && c <= 57; c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x;
}
inline void print(int x) {		//快输
	if (x > 9) print(x / 10);
	putchar(x % 10 + 48);
}
inline void add(int u, int v, int w) {	//加边
	e[++tot].u = h[u], e[tot].v = v, e[tot].w = w, h[u] = tot;
}
int main() {
	for (ri i = 1; i <= 7; i++) s[i] >>= read();	//位运算
	S = read(), T = read(), m = read(), memset(dis, 0x3f, sizeof(dis));
	for (ri i = 0; i < m; i++)
    	x = read(), y = read(), z = read(), add(x, y, s[z]), add(y, x, s[z]); 
	dis[S] = 0, q.push((node) {0, S});	//dijkstra
	while (!q.empty()) {
		tmp = q.top(), q.pop();
		if (vis[tmp.p]) continue;
		vis[tmp.p] = 1;
		for (ri i = h[tmp.p]; i; i = e[i].u)
			if (dis[e[i].v] > dis[tmp.p] + e[i].w)
				dis[e[i].v] = dis[tmp.p] + e[i].w, q.push((node) {dis[e[i].v], e[i].v});
	}
	print(dis[T]);
	return 0;
}
```


---

## 作者：C20212724杨京朝 (赞：2)

这题除了建图没有任何难度好吗？~~（其实建图也没有难度，但我是蒟蒻）~~

思路：
先打个表存下每个地形的通过时间，输入的时候打个if判断有没有魔法石，然后把h数组里存的表（/2)存进去，再跑一遍最短路，这里我都用的是邻接矩阵。

------------
### Floyd：
一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
int h[15] = {0,2,6,4,8,6,10,14},s[10],dp[105][105];//h是表，我习惯从1号位开始，其它我就不多说了吧？
inline int read() {
    int x = 0,f = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c <='9' && c >='0') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(int x) {
    int k = 0,lx = x;char put[40];
    if (lx ==0) putchar('0');
    if (lx < 0) putchar('-'),lx = -lx;
    while (lx)  put[++k] = (lx % 10) + '0',lx /= 10;
    while (k)   putchar( put[ k-- ] );
    putchar('\n');
}//快读 + 快输
int main() {
	memset(dp,0x3f,sizeof dp);//memset把dp数组赋成0x3f，老师说是防溢出
	for(register int i = 1;i <= 7;i ++) s[i] = read();//输入
	int begin,end;
	begin = read(),end = read();
	int c;
	c = read();
	for(register int i = 1;i <= c;i ++) {
		int x,y,w;
		x = read(),y = read(),w = read();
		if(s[w] == 1) dp[x][y] = dp[y][x] = h[w] / 2;//见上文
		else dp[x][y] = dp[y][x] = h[w];//同上
	}//这里一定要存成无向图，因为这个2次20fen
	for(register int i = 1;i <= 100;i ++) {//初始化，同上
		for(register int j = 1;j <= 100;j ++) {
			if(i == j) dp[i][j] = 0;
		}
	}
	for(register int k = 1;k <= 100;k ++) {//三个循环都是从1到100，看到有人前两个循环1 - c我想笑，c的数据范围是10000，这样写早就超时了好吧？
		for(register int i = 1;i <= 100;i ++) {
			for(register int j = 1;j <= 100;j ++) {
				dp[i][j] = std::min(dp[i][j],dp[k][j] + dp[i][k]);
			}
		}
	}
	printf("%d",dp[begin][end]);//输出不解释
	return 0; 
}
```
------------
### Dijkstra：
是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
int h[15] = {0,2,6,4,8,6,10,14},s[10],map[105][105],dis[105],vis[105];
inline int read() {
    int x = 0,f = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c <='9' && c >='0') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(int x) {
    int k = 0,lx = x;char put[40];
    if (lx ==0) putchar('0');
    if (lx < 0) putchar('-'),lx = -lx;
    while (lx)  put[++k] = (lx % 10) + '0',lx /= 10;
    while (k)   putchar( put[ k-- ] );
    putchar('\n');
}//快读 + 快输
void Dijkstra(int x) {//裸的Dijkstra不解释，不会的自己度娘
	memset(dis,127,sizeof(dis));
	int begin = x;
	vis[begin] = 1;
	for(register int i = 1;i <= 100;i ++) dis[i] = std::min(dis[i],map[begin][i]);
	for(register int i = 1;i <= 99;i ++) {
		int Min = 1e9;
		for(register int j = 1;j <= 100;j ++) {
			if(vis[j] == 0 && Min > dis[j]) {
				Min = dis[j];
				begin = j;
			}
		}
		vis[begin] = 1;
		for(register int j = 1;j <= 100;j ++) dis[j] = std::min(dis[j],dis[begin] + map[begin][j]);
	}
}

int main() {
	memset(map,0x3f,sizeof map);
	for(register int i = 1;i <= 7;i ++) s[i] = read();
	int begin,end;
	begin = read(),end = read();
	int c;
	c = read();
	for(register int i = 1;i <= c;i ++) {
		int x,y,w;
		x = read(),y = read(),w = read();
		if(s[w] == 1) map[x][y] = map[y][x] = h[w] / 2;
		else map[x][y] = map[y][x] = h[w];
	}//都和上文一样
	for(register int i = 1;i <= 100;i ++) {
		for(register int j = 1;j <= 100;j ++) {
			if(i == j) map[i][j] = 0;
		}
	}
	Dijkstra(begin);
	printf("%d",dis[end]);
	return 0; 
}
```
PS：话说Dijkstra是比Floyd快很多呢，一个24ms，一个102ms

最后，关于SPFA，它死了



---

## 作者：stephen→_→ (赞：2)

## 令人窒息的floyd，实在想不到打floyd居然AC了！！！时间：0ms内存：2544KB

## 代码如下

```cpp
#include<iostream>
using namespace std;
int h[8]={0,2,6,4,8,6,10,14};//打个静态数组保存每种地形需要的时间，由于静态数组是从0开始的，所以上面要先打个0先，剧毒无比，这里卡了我好久
int mind=99999999,s[8];
int a[1001][1001],x,y,b[10001],n,m,c,z;
int main()
{
    for(int i=1;i<=7;i++)
    cin>>s[i];
    cin>>n>>m;
    cin>>c;
    for(int i=1;i<=c;i++)
      for(int j=1;j<=c;j++)
           if(i!=j) a[i][j]=99999999;//初始化
    for(int i=1;i<=c;i++)
    {
        cin>>x>>y>>z;//读入
        if(s[z]==1)//判断这个地形有没有魔法石
        {
            a[x][y]=h[z]/2;//有的话只用花一半时间
            a[y][x]=a[x][y];//无向图存边
            continue;
        }
            a[x][y]=h[z];//如果没有魔法石，就常规存边
            a[y][x]=h[z];
    }
    for(int k=1;k<=c;k++)//开始令人窒息的floyd
        for(int i=1;i<=c;i++)
            if(k!=i)
                for(int j=2;j<=c;j++)
                       {
                            if(a[i][j]>a[i][k]+a[k][j]) 
                        {
                            a[i][j]=a[i][k]+a[k][j];
                        }
                        }
    cout<<a[n][m];//输入第n个点到第m个点的最短距离
    return 0;
}
//我的水代码在上面，祝大家顺利AC！~
```

---

## 作者：氢氟酸er (赞：2)

这题就是一题**最经典的**\_单源最短路问题\_，直接用**最普通的迪杰斯特拉算法（Dijkstra）**就可以了


**不用邻接表，不用堆优化，也不会TLE！！！**


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
int map[101][101];//地图---连通点间距离 
bool list[101];//记录这个点是否被走过 
int dis[101];
int start,end;//i是起点，j是终点 
int C,x,y,tpe;
const int INF=2e9;
int stone[8]={INF};
int v,k;
int time[8]={INF,2,6,4,8,6,10,14};
void init();
void dijkstra();
int main(){
    for(k=1;k<=7;k++){
        scanf("%d",&stone[k]);
        if(stone[k]) time[k]/=2;
    }
    scanf("%d%d%d",&start,&end,&C);
    init();//初始化
    for(k=1;k<=C;k++){
        scanf("%d%d%d",&x,&y,&tpe);
        if(tpe<=7&&tpe>=1&&time[tpe]<map[x][y]){//特判，取最短路
            map[x][y]=time[tpe];
            map[y][x]=time[tpe];
        }
    }
    dijkstra();
    printf("%d",dis[end]);
    return 0;
}
void init(){
    memset(list,false,sizeof(list));
    list[start]=true;
    for(k=1;k<=100;k++){
        dis[k]=INF;
    }
    dis[start]=0;
    for(k=1;k<=100;k++){
        for(int l=1;l<=100;l++){
            if(k==l) map[k][l]=0;
            else map[k][l]=INF;
        }
    }
}
void dijkstra(){
    int min;
    while(!list[end]){//只需要终点的路径算出来就可以结束
        min=INF;
        list[start]=true;
        for(v=1;v<=C;v++){
        //松弛操作
            if(map[start][v]!=INF&&!list[v]){
                if(dis[v]>dis[start]+map[start][v]){
                    dis[v]=dis[start]+map[start][v];
                }
            }
        }
       //找与当前起点最短的点
        for(int g=1;g<=100;g++){
            if(!list[g]&&dis[g]<min){
                min=dis[g];
                start=g;
            }
        }
    }
}
```

---

## 作者：szbszb (赞：1)

其实这道题就是比较灵活的但愿最短路算法

如果还不会最短路算法的同学可以看看我写的[最短路算法的博客](https://www.cnblogs.com/szbszb/p/11280672.html)

我们先定义一个数组c，c[i]代表类型i的地形所需要的时间/2，即：

```cpp
long long c[8]={0,1,3,2,4,3,5,7};
```
（类型0就为0啦，其实随便的）

然后在开头加上这样一句：
```cpp
for (i=1;i<=7;i++)
{
	scanf("%lld",&x);
	if (x) zx[i]=c[i];
	else zx[i]=c[i]*2;
}
```
zx数组代表类型i所需的时间

然后就是一个简单的单源最短路了，由于n<=100，所以dijkra不用堆（优先队列）优化也可以，包括SPFA、folyd都是可以的

博主还是用了[链式前向星](https://www.cnblogs.com/szbszb/p/11298047.html)和优先队列优化

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long i,n,m,f,t,x,y,z,zx[8],he[101],ne[10001],to[100001],l[100001],d[101],u,v,cnt;
long long c[8]={0,1,3,2,4,3,5,7};
bool b[101];
priority_queue<pair<long long,long long> >q; 
int main()
{
	for (i=1;i<=7;i++)
	{
		scanf("%lld",&x);
		if (x) zx[i]=c[i];
		else zx[i]=c[i]*2;
	}
	scanf("%lld%lld",&f,&t);
	scanf("%lld",&m);
	for (i=1;i<=m;i++)//链式前向星
	{
		scanf("%lld%lld%lld",&x,&y,&z);
		z=zx[z];
		cnt++;
		ne[cnt]=he[x];
		to[cnt]=y;
		l[cnt]=z;
		he[x]=cnt;
		cnt++;
		ne[cnt]=he[y];
		to[cnt]=x;
		l[cnt]=z;
		he[y]=cnt;
	}
	for (i=1;i<=100;i++)
		d[i]=1e11;
	d[f]=0;
	q.push(make_pair(0,f));//优先队列
	while(q.size())
	{
		u=q.top().second;
		q.pop();
		if(b[u]) continue;
		b[u]=true;
		for (i=he[u];i;i=ne[i])
		{
			v=to[i];
			if (d[v]>d[u]+l[i])
			{
				d[v]=d[u]+l[i];
				q.push(make_pair(-d[v],v));//大根堆转小根堆
			}
		 } 
	}
	printf("%lld",d[t]);
	return 0;
}
```

---

## 作者：Ricardo_21 (赞：0)

分析一下题目 其实是一个图。但，实话实说，对于我们这种蒟蒻来说，这种图还是比较难的

首先要生成这个图的各个路径，显然路径的长度已经给了，而且能不能有魔法石~~（能不能开开挂）~~也已经告诉我们了

##### 也就是说！！！

这个图已经出来了，边，点的信息都有了

所以，直接开始暴搜

但是要记住，如果i可以到j，那么j也可以到i

```c
#include<bits/stdc++.h>
using namespace std;
int h[8]={0,2,6,4,8,6,10,14};
int s[8];
int start,final;
int n,tx,ty,a,maxn=-1,minn=100000000;
int dis[110][110];
int vis[110][110];
void dfs(int x,int t){
	if(x==final){
		minn=min(minn,t);
		return;
	}
	for(int i=1;i<=maxn;i++){
		if(vis[x][i]!=0){
			if(dis[x][i]) dfs(i,t+h[vis[x][i]]/2);
			else dfs(i,t+h[vis[x][i]]);
		}
	}
}
int main(){
	for(int i=1;i<=7;i++)
		cin>>s[i];
	cin>>start>>final>>n;
	for(int i=1;i<=n;i++){
		cin>>tx>>ty>>a;
		vis[tx][ty]=a;
		vis[ty][tx]=a;
		dis[tx][ty]=s[a];
		dis[ty][tx]=s[a];
		maxn=max(maxn,max(tx,ty));
	}
	dfs(start,0);
	cout<<minn<<endl;
    return 0;
}
```

但是。。。。。。

你会发现这题会MLE+WA,只有10分，在DFS时，系统栈会爆掉

然而下面的程序没有将“如果i可以到j，那么j也可以到i”加到程序里竟然会20分！！！

不得不说，数据太水。。。

```c
#include<bits/stdc++.h>
using namespace std;
int h[8]={0,2,6,4,8,6,10,14};
int s[8];
int start,final;
int n,tx,ty,a,maxn=-1,minn=0x3f3f3f3f3f3f;
int dis[110][110];
int vis[110][110];
void dfs(int x,int m){
	if(x==final){
		minn=min(minn,m);
		return;
	}
	for(int i=1;i<=final;i++){
		if(vis[x][i]!=0){
			if(dis[x][i]) dfs(i,m+h[vis[x][i]]/2);
			else dfs(i,m+h[vis[x][i]]);
		}	
	}
}
int main(){
	for(int i=1;i<=7;i++)
		cin>>s[i];
	cin>>start>>final>>n;
	for(int i=1;i<=n;i++){
		cin>>tx>>ty>>a;
		vis[tx][ty]=a;
		dis[tx][ty]=s[a];
		//maxn=max(maxn,max(tx,ty));
	}
	dfs(start,0);
	cout<<minn<<endl;
    return 0;
}
```
再仔细分析，发现，系统栈，好像受不住


##### 所以，我们开始一些搜索剪枝

相信许多人做过迷宫这类的题目，会想到用走一遍就打一个标记，再回溯的方法。但是在这一题，显然是不大奏效的

所以另外一个剪枝方法便很明显了

### 记忆化

记忆化搜索:算法上依然是搜索的流程，但是搜索到的一些解用动态规划的那种思想和模式作一些保存。

记忆化算法在求解的时候还是按着自顶向下的顺序，但是每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解了。

————摘自360百科

(搜索基本上都要挂上记忆化，我将记忆化理解为搜索剪枝的必由之路）

##### 所以如何写记忆化呢？

首先，我们发现。你会“倚门回首”。

“倚门回首”：你会发现自己在搜索的途中莫名回头，由i到j之后，再从j到i，从而将一个好好的系统栈直接MLE掉

### 如何解决？

开一个f数组，存放到当前位置的最小距离即可

如果f[x]小于t那么直接return，把这个分支毙掉

否则将f[x]（x表示当前位置）赋值为t(距离)

所以便显而易见了
```c
#include<bits/stdc++.h>
using namespace std;
int h[8]={0,2,6,4,8,6,10,14};
int s[8];
int start,final;
int n,tx,ty,a,maxn=-1,minn=100000000;
int dis[110][110];
int vis[110][110];
int f[110];
void dfs(int x,int t){
	if(t>f[x]) return;
	f[x]=t;
	if(x==final){
		minn=min(minn,t);
		return;
	}
	for(int i=1;i<=maxn;i++){
		if(vis[x][i]!=0){
			if(dis[x][i]) dfs(i,t+h[vis[x][i]]/2);
			else dfs(i,t+h[vis[x][i]]);
		}
	}
}
int main(){
	for(int i=1;i<=100;i++) f[i]=100000000;
	for(int i=1;i<=7;i++)
		cin>>s[i];
	cin>>start>>final>>n;
	for(int i=1;i<=n;i++){
		cin>>tx>>ty>>a;
		vis[tx][ty]=a;
		vis[ty][tx]=a;
		dis[tx][ty]=s[a];
		dis[ty][tx]=s[a];
		maxn=max(maxn,max(tx,ty));
	}
	dfs(start,0);
	cout<<minn<<endl;
    return 0;
}
```
（只加了四行。。。就AC了）

CSP-J RP++

---

## 作者：不存在之人 (赞：0)

这道题不算难，就是一个最短路（$SSSP$)。

数据也不是很毒，用$Floyd$即可AC。

这里用了$Dijkstra$。

### Code：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define re register
#define rep(i,a,b) for (re int i=a;i<=b;++i)
#define repd(i,a,b) for (re int i=a;i>=b;--i)
#define maxx(a,b) a=max(a,b);
#define minn(a,b) a=min(a,b);
#define LL long long
#define inf (1<<30)
inline int read()
{
    int w=0,f=1; char c=getchar();
    while (!isdigit(c)) f=c=='-'?-1:f,c=getchar();
    while (isdigit(c)) w=(w<<3)+(w<<1)+(c^'0'),c=getchar();
    return w*f;
}
const int maxn=100+5,maxm=1e4+5;
struct Edge
{
    int u,v,w,pre;
};
struct Node
{
    int u,d;
    bool operator<(const Node&rhs) const
	{
        return d>rhs.d;
    }
};
int way[8]={0,2,6,4,8,6,10,14};
priority_queue<Node> Q;
struct Graph
{
	#define iter(i,u) for (re int i=G[u];i;i=edges[i].pre)
    Edge edges[maxm<<1];
    int n,m;
    int G[maxn];
    int dis[maxn],vis[maxn];
    void init(int n)
	{
        this->n=n;
        m=0;
        memset(G,0,sizeof(G));
    }
    void AddEdge(int u,int v,int w)
	{
        edges[++m]=(Edge){u,v,way[w],G[u]};
        G[u]=m;
        edges[++m]=(Edge){v,u,way[w],G[v]};
        G[v]=m;
    }
    void dijkstra(int s)
	{
        memset(vis,0,sizeof(vis));
        memset(dis,0x3f,sizeof(dis));
        dis[s]=0;
        Q.push((Node){s,0});
        while (!Q.empty())
		{
            int u=Q.top().u;Q.pop();
            if (vis[u]) continue;
            vis[u]=1;
            iter(i, u)
			{
                Edge&e=edges[i];
                if (dis[u]+e.w<dis[e.v])
				{
                    dis[e.v]=dis[u]+e.w;
            		Q.push((Node){e.v,dis[e.v]});
                }
            }
        }
    }
}G;
int s,t,m;
int main()
{
    rep(i,1,7) 
        if (read()) way[i]>>=1;
    s=read(),t=read();
    G.init(100);
    m=read();
    rep(i,1,m)
	{
        int u=read(),v=read(),w=read();
        G.AddEdge(u,v,w);
    }
    G.dijkstra(s);
    printf("%d",G.dis[t]);
    return 0;
}
```

---

## 作者：Patrickpwq (赞：0)

最短路裸题！

我用的是dijkstra领接表+堆优化

据说Floyd都能过...

但是我发现自己隔了一个月没碰的东西就有点忘了 这里总结一下dijkstra堆优化的思路

（PS 像这种无向图！！！需要add两次！！！！！！！卡了好久）

dijkstra算法的核心——对于每个点——找当前点相连的点离起点最近的点——从这个点出发松弛——如果相连的点在集合里，且当前路径优于之前路径那么替换

建立priority_queue<make_pair<int int> > 第一个存路径长度 第二存对应的点

 对于当前的点 先从priority_queue里取出离起点路径最短的一个点 （这个操作 在原版dijkstra中是最费时间的）从这个点向它相连的边遍历 进行松弛操作
 
 okok看代码
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;

const int INF=0x7fffffff;
int start,end,m;
int x,y,z; 
int t[8]={0,2,6,4,8,6,10,14};

int to[10005],first[1005],next[10005],v[10005],tot,dis[1005];
priority_queue <pair<int,int> > q;

void add(int x,int y,int ooo)
{
	tot++;
	next[tot]=first[x];
	first[x]=tot;
	to[tot]=y;
	v[tot]=ooo;
}

void dijkstra()
{
	dis[start]=0;
	q.push(make_pair(0,start));
	while(!q.empty())
	{
		int k=q.top().second;
		q.pop();
		for(int i=first[k];i;i=next[i])
		{
			int f=to[i];
			if(dis[k]+v[i]<dis[f])
			{
				dis[f]=dis[k]+v[i];
				q.push(make_pair(-dis[f],f));
			}
		}
	}
}
int main()
{
	for(int i=1;i<=7;i++)
	{
		int is_stone;
		cin>>is_stone;
		if(is_stone==1) t[i]=t[i]/2;
	}
	cin>>start>>end;
	cin>>m;
	
	for(int i=1;i<=1005;i++)
	{
		dis[i]=INF;
	}
	
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		add(x,y,t[z]);//记得两次！！！！！！！！！！！！！！！！！ 
		add(y,x,t[z]);
	}
	dijkstra();
	cout<<dis[end]<<endl;
	return 0;
}
```

---

## 作者：lovelive__ (赞：0)

一名蒟蒻写的题解，望大牛，神牛勿喷。

本题的主要思想在于建好一个图，然后做Dijkstra就可以了（推荐没学过Dijkstra先去百度一下学习一下，不然你可能看不懂）

----------------------------------------------------------------（华丽的分界线）









```cpp
var
 i,j,m,n,x,y,f,k,max,min:longint;
 map:array[1..100,1..100]of longint;
 pad:array[1..100]of boolean;//模拟集合；false在集合里，true在集合外
 zdl:array[1..100]of longint;
 d:array[1..7]of longint;
begin
 d[1]:=2;d[2]:=6;d[3]:=4;d[4]:=8;d[5]:=6;d[6]:=10;d[7]:=14;
 for i:=1 to 7 do//预处理+输入（构图）
  begin
   read(f);
   if f=1 then d[i]:=d[i] div 2;
  end;
 fillchar(pad,sizeof(pad),false);
 read(m,n);//输入
 read(f);
 for i:=1 to f do//预处理我就不多说了
  begin
   read(x,y,k);
   map[x,y]:=d[k];
   map[y,x]:=d[k];
   if x>max then max:=x;
   if y>max then max:=y;
  end;
 for i:=1 to max do//同上
  zdl[i]:=maxlongint;
 zdl[m]:=0;
 for i:=1 to max-1 do//Dijkstra算法开始
  begin
   pad[m]:=true;//这里就是要做标记的原因（废话,勿喷）
   if m=n then break;
   for j:=1 to max do
    if (map[m,j]<>0)and not pad[j] and(map[m,j]+zdl[m]<zdl[j])//如果这条路径是通的，且j点在集合里，那么就选较小的那一个。（选择集合里的最优值）
       then zdl[j]:=map[m,j]+zdl[m];
   min:=maxlongint;//预处理（废话）
   for j:=1 to max do//算法精髓部分的开始
    if not pad[j] and(zdl[j]<min) then//如果这个点在集合里，且当前路径优于之前路径那么替换。（贪心）
     begin
      min:=zdl[j];//替换
      m:=j;//做标记
     end;
   end;
 writeln(zdl[n]);
end.
```

---


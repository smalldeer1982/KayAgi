# 游戏预言

## 题目描述

John 和朋友们在玩纸牌游戏，他们一共有 $m$ 个人（包括 John）。他们的纸牌比较特殊，一共有 $n \times m$ 张牌，牌号分别为 $1,2,\dots,n \times m$，没有牌号相同的牌。每个人先拿到 $n$ 张牌，然后，每一轮，每个人出一张牌，谁最大则谁赢得这一轮。现在已知 John 手中的 $n$ 张牌，计算他最少能赢得多少轮。

## 说明/提示

对于 $100 \%$ 的数据，$2 \le m \le 20$，$1 \le n \le 50$。

## 样例 #1

### 输入

```
2 5
1 7 2 10 9```

### 输出

```
2```

## 样例 #2

### 输入

```
6 11
62 63 54 66 65 61 57 56 50 53 48```

### 输出

```
4```

# 题解

## 作者：Mr_QwQ (赞：31)

其实这题的代码难度很低的，但是要想到又快又好的算法并不容易。

首先为了方便，我们假设John总是把牌从大到小出。（有点田忌赛马的意思233）

然后我们可以认为，其余所有的牌都拿在一个人手里。如果已经能够赢得这一轮，剩下要出的牌拿最小的占位即可。

之后我们从大到小枚举每一张牌。对于i号牌：

①它是对（lao）方（qian）手上的牌。此时我们把它拿进手牌里。

②它是John手上的牌。此时，如果手上的储备牌足够（至少有1张能够压住John），那么我们总是应该选择压上。道理非常明显：对于一张对手的牌，无论盖上了John的哪一张牌，它为对手创造的收益都是1。如果这张压了，会让John赢得的轮数减少1；如果这张牌不压John，那么最好的情况就是它在后面的时候派上了用场，轮数还是减少1（如果悲剧一点，后面它就成了赘余牌，收益只有0）。“好钢要用在刀刃上”，就是这个道理。所以，我们的贪心策略是：“能压就压”。

具体到代码上，我们用桶排存下John的每一张牌，从m\*n到1反向枚举，如果是对手的牌则加入储备牌库（直接cnt++就行）；是John的牌就看看牌库有没有牌，有的话cnt--，没有的话ans++。

仅19行的代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[51],b[1001],n,m,cnt,ans;
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[a[i]]=1;
    }n*=m;
    for(int i=n;i>=1;i--){
        if(!b[i])++cnt;
        else if(cnt>0)--cnt;
        else ++ans;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：友利奈緒 (赞：19)

```cpp

```
看大佬们都用那么多高级写法，本蒟蒻瑟瑟发抖qwq

但看了看题解似乎没有思路和我一样的？~~毕竟我太蒻了连好方法都想不到~~

本题是看john有几张牌是一定能大过别人出的牌的

这里提供一种思路

从n * m开始枚举，如果当前的牌john手中没有的话，则john缺的牌数量+1

来举个栗子

像是样例二，m为6，n为11，john 的牌从大到小为

66 65 63 62 61 57 56 54 53 50 48

从i=66开始的话，则往后枚举一直到john没有的牌，其中只要john有牌，就一定能赢（因为最大的在自己这里）

这里是从66到65，已经有两轮能够赢

但到之后，i为64时，john没有，则他已经缺1张牌

i为63时，john有，这张牌正好可以弥补那一张的空缺，也就是john如果出63，别人出64，john不会赢

但到62john依然有牌，这时john一定会赢，因为别人大于他的牌已经出过了，就算在63时没出，则在63时john已经赢了，对结果没有影响

若用sum表示john会比别人小的牌，则当sum<0时john能赢

因此只要让有john没有的牌时sum++，有牌时sum再-1抵消，再判断sum是否小于0

另外，只有当sum>=0时，sum--才有意义，因为此时john没有的牌应该还是0，-1只是表示一种john可以赢的状态，因此要再把sum赋值为0

下面上代码


```cpp
#include<bits/stdc++.h>

using namespace std;

bool cmp(int a,int b)//将牌从大到小排序

{ 
 
 return a>b;   
}

int a[60];

int j=1,sum=0,ans=0;//j用来表示枚举到的john的牌，ans是赢的轮数

int main()

{

	int flag=0;//用来标记john是否已经缺过牌
    
	int n,m;  
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);
	for(int i=n*m;j<=n;i--)//满足john的牌已经枚举完就退出
	{
		if(i!=a[j]) sum++,flag=1;//如果有john缺的牌则sum++
		if(i==a[j]) 
		{
		    if(flag==0) ans++;//特殊情况，此时john的手牌一直是最大的
			if(sum>=0&&flag==1) sum--;//抵消
			j++;//移到下一张牌
		}
		if(sum<0) 
		{
			ans++;
			sum=0;
		}
	}
	cout<<ans;
	return 0;
}
```


~~蒟蒻第一次发题解，不点个赞再走嘛qwq~~

---

## 作者：梦里调音 (赞：11)

# 来个新思路！

看dalao们都用什么桶排鸭，快排鸭，贪心鸭……

可惜我想：

数据点这么小真的有必要整这些~~高级~~算法吗？？？

是的，没必要。

我的代码思路极简。

```
#include <bits/stdc++.h>
using namespace std;
int m,n,s[10001],ans;
bool h[100001];//true则表示已使用或自己拥有
int main()
{
	cin>>m>>n;
	for(int i=1;i<=n;i++)
		cin>>s[i],h[s[i]]=1;//输入、用布尔数组记录拥有的牌
	for(int i=n*m;i>=1;i--)//这里敲黑板：枚举牌号（其实相当于我从大到小出牌）
		if(h[i]==1){//如果这张牌归我*
			int t=0;
			for(int j=n*m;j>i&&t==0;j--)
				if(h[j]==0)h[j]=1,t=1;//枚举，看能否把我现在这张牌压制
			if(t==0)ans++;//不能，则答案++
		}
	cout<<ans<<endl;
	return 0;	
}
```
注释*：
	
    这张牌只可能是自己拥有，而不是对方已使用。
    
    因为对方出牌是从大到小出。

---

## 作者：lzk5627 (赞：7)

这题......好吧其实有点水；
先前看楼下几位的方法，都是桶牌加贪心；
其实快排就好了
其实这个john赢得最少的数量就是他的牌没人比他大的情况；
因为对（ren gong）面（zhi zhang）如果要尽量减少john的赢的数量，他一定要能压john就尽量压，所以我们先快排john的牌，然后再从m*n 开始从大到小枚举；
如果john的牌与枚举数相等，他就赢了，赢的数量+1；
反之 因为这张牌不在他手上，所以这张牌会用来压他的牌，赢的数量-1；
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long m,n;
	cin>>m>>n;
	long long a[n+1],sum=0,_max=0;
	for(int i=1;i<=n;i++)
		cin>>a[i];//以上输入
	sort(a+1,a+n+1);//排序
	for(int i=n,j=m*n;i>0;i--,j--)//逆序输出，因为快排是默认从小到大的
								//（吃饱了没事做）有那个精力的人可以自己写排序顺序
        {
		if(a[i]==j)//如果相等，说明没人比他大
			sum++;
		else//会用来压他后面的牌
			{
			sum--;
			i++;//这张牌没用出去，所以加回来
			}
		_max=max(_max,sum);//记录赢的数
		}
	cout<<_max;//输出
	return 0;//养成好习惯
} 
```

---

## 作者：somethingfornothing (赞：4)

### 这题乍一看很难但是仔细分析一下就得出了下面的代码
```
#include<cstdio>
#include<cstring>
using namespace std;
int a[1005],b[1005];
int main()
{
    int n,m,ans=0,sum=0;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        b[a[i]]=1;
    }
    for(int i=n*m;i>=1;i--)//让大牌在上，从大往小搜。
    {
        if(b[i]==0)sum++;//如果这张牌不是他的，就可以抵掉她的一张小牌，就让计可以的sum++。
        else if(sum>0)sum--;//如果这张牌是他的，就可以抵掉她的一张小牌，但这张牌也废了，sum--。
            else ans++;//如果这张牌是他的，并且没有更大的牌能抵掉它，ans++。
    }
    printf("%d",ans);
}
```

---

## 作者：Register (赞：2)

## 贪心
这道题很水，多半又是恶意评分上去的

我们解析一下：

	从n*m降序枚举到1，如果最上头的一直都是被John占领，那么答案sum就加上区间长度
    可是数据不会那么良心，只会凉心
    假如中间穿插了敌人的，也就是说John没拿到xx牌，那么敌人的胜利次数就加1
    继续枚举下去，如果敌人没有胜利，那么就加一次John的胜利次数，否则敌人胜利次数减一
code:
```cpp
#include <iostream>
using namespace std;
int n,m,sum,d;
bool b[1001];//标记是否持有
int main(){
    cin>>m>>n;
    for(register int i=1;i<=n;i++) {int a;cin>>a;b[a]=true;}
    for(register int i=n*m;i>=1;i--)//贪心
        if(b[i]) d==0?sum++:d--;
        else d++;
    cout<<sum<<endl;
    return 0;
}
```

---

## 作者：POSS (赞：2)

 ### [游戏预言-luogu 2649](https://www.luogu.org/problemnew/show/P2649)
怎么说呢？
对于这道题目，我们可以选择一种方法--无脑枚举。
我们应该可以贪心过此题~~（也许是数据太水）~~。我是这样贪心的：
先将john所拥有的排从大到小排一下（其实从小到大也无所谓）。
因为我们要求的是最小的胜利数，那么我们只需要比较当前其他人所可以用到的最大值。如果这个最大值大于当前john所拥有的最大值（这里的最大值值的都是已经打出去的牌后剩余的最大值），那么我们将其他人的这一张是最大值牌打出去。之后把其他人的最小的牌逐次打出去。如果当前其他人的最大牌都比不上john的大时，我们只需要将其他人的最小的牌逐次打出去，并将john的胜利次数+1。具体实现见代码：
```cpp
#include<iostream>
#include<algorithm>

using namespace std;

int n,m,a[55],ans,last,head;
bool b[11000];

int main()
{
	cin>>m>>n;
	
	for(int i=1;i<=n;++i)cin>>a[i],b[a[i]]=1;//表示这一张牌John有，其他人不能使用。
	
	sort(a+1,a+n+1);
	
	last=n*m;//所有牌最大值是n*m。
	head=1;//最小值是1。
		
	for(int i=n;i>=1;--i)
	{
		while(b[last])last--;//先把其他人不能用的最小值牌确定好。
		while(b[head])head++;//其他人能用的最大牌，同理。
		if(last<a[i])//如果当前其他人的牌的最大值比john的牌的最大值小。
		{
			ans++;
			int tmp=1;
			while(tmp<=m){
				head++;
				if(!b[head])tmp++;
			}//那么我们贪心的让其他人打出他们所能打出的最小的牌。
		}	
		else
		{
			last--;//其他人的最大数值的牌只打一次，剩下的大数值的牌准备应付john的下一张牌。
			int tmp=1;
			while(tmp<=m){
				head++;
				if(!b[head])tmp++;//每张牌只出现了一次。
			}//其他人的牌肯定要打出最小的，这样就可以避免浪费。
		}	
	}	
		
	cout<<ans;
	
	return 0;
}
```

---

## 作者：PDY08 (赞：2)

#### 这道题感觉不用那么麻烦，用不着排序啊
### 主要思想
#### 求 John 最少能赢的次数，也就是朋友的牌比 John 的牌大的最多的次数
### 进入正题
#### 第一步：标记好 John 拥有的牌
#### 第二步：依次统计有没有既不是 John 的牌，又比 John 的牌大，并且没有出过的牌，有就 d 加1 
#### 第三步：输出 John 拥有的牌数（即为 n ）减 d 就是 John 最少能赢的次数
### 各位可能不爱看分析，下面就到你们喜欢的代码了
```
#include<iostream>
using namespace std;
int a[1001],d,n,m,i,j,s;//a用来记录John的牌，d是朋友能赢多少张John的牌
bool b[1001],c[1001]={0};//b用来标记是不是 John 的牌，c用来标记这张牌牌出过没
int main(){
	cin>>m>>n;
	for(i=1;i<=n;i++){
		cin>>a[i];
		b[a[i]]=1;//这张是 John 的牌
	}
	for(i=1;i<=n;i++){
		s=0;//记录是否有符合条件的牌
		for(j=a[i]+1;j<=n*m;j++){
			if((b[j]==0)&&(c[j]==0)){//判断是否为既不是 John 的牌，又比 John 的牌大，并且没有出过的牌
				s++;
				c[j]=1;//出了它
				break;
			}
		}
		if(s==1)d++;
	}
	cout<<n-d;//拥有的牌数减去输了的牌数
} 
```


---

## 作者：yu__xuan (赞：1)

## 题目：
[P2649 游戏预言](https://www.luogu.org/problem/P2649)
## 题意：
`John`和他的好朋~~基~~友们在van纸牌游戏。共有$m$个人。纸牌有$n \times m$张，从$1……n \times m$编号。每人有$n$张。每人一回合出一张牌，编号最大的获胜。由于输了有蜜汁惩罚，`John`想尽可能地多赢。（欲知后事如何，且听下回分解。。。
## 思路：
题目问的是`John`最少赢多少次。我们可以设想：`John`十分美味多汁。他的好朋~~基~~友们都想让他接受蜜汁惩罚所以合伙坑`John`。这样我们可以将不是`John`的牌放到一堆。每当`John`出一张牌就先出一张比该牌大的且不是`John`的的牌。然后剩余的$m-2$张牌就从小的挨着出。直到出够$m-2$张。如果没有比`John`的牌大的`John`必赢
## $Code$

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#define rr register
int ans,n,m,sum,jcard[51];
bool vis[1010],used[1010];

inline void read(int &T) {
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int main() {
	read(m),read(n);
	for(rr int i=1,a;i<=n;++i) {
		read(a);
		vis[a]=1;
		jcard[++sum]=a;
	}
	for(rr int i=1;i<=sum;++i) {
		int num=m-1;
		int x=jcard[i];
		used[x]=1;
		for(rr int j=x+1;j<=n*m;++j) {
			if(!used[j]&&!vis[j]) {
				num--;
				used[j]=1;
				break;
			}
		}
		if(num==m-1) ans++;
		for(int j=1;num>0;++j) {
			if(!used[j]&&!vis[j]) {
				num--;
				used[j]=1;
			}
		}
	}
	std::cout<<ans<<'\n';
	return 0;
}
```
~~月考rp++~~

---

## 作者：Snowlanuck (赞：0)

给的数据太水了，本来想先混个10分看看，没想到就满分了，思路就是先洗牌(排序),看后面最大的牌有多少张是自己有的，然后累加即可,也就是查找已排序好数组后连续的最大数的个数

数据太水了，没想到直接AC掉了
什么枚举，什么贪心，统统不用考虑
恐怕这是最简思路了吧，不是正解(笑哭

代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int m,n,nums[20*50+1],Res=0;
	cin>>m>>n;
	int mn=m*n;
	for(int i=0;i<n;i++)
		cin>>nums[i];
	
	sort(nums,nums+n);
	for(int i=n-1,count=0;i>=0;i--,count++)
		if(nums[i]==mn-count)
			Res++;
		else break;
	
	cout<<Res;
	
	return 0;
}
```


---

## 作者：liyuwei (赞：0)

其实这道题并不需要很强大很高级的算法，由于它是要取**最少**的，所以能出大牌就出大牌，如此就简单了。
就相当于在一个数轴上取数，牌的大小就相当于坐标点，用数组b[ ]来表示坐标点的归属，John的牌对应的点标1，其他人的标0，
搜索John的牌看他前面有没有比他大的，有就消去最大的（把别人的牌变成John的），否则计数。
（我画了个图，但图片不会插入，见谅）
初中生蒟蒻代码，请dalao指教。




```cpp

#include<bits/stdc++.h>
using namespace std;
long long a[10000],b[10000];
int main(){
   	int m,n,p=0,x=0;
   	cin>>m>>n;
   	for(int i=0;i<=n-1;i++)
      {
         cin>>a[i];
         b[a[i]]=1;
      }
    sort(a,a+n);
    for(int i=n-1;i>=0;i--)
      {
        for(int k=n*m;k>a[i];k--)
        {if(b[k]==0)
          {
        	b[k]=1;
        	break;
          }
         else    
        p++;
        }
        if(p==n*m-a[i])
         x++;
         p=0;
       }
    cout<<x;
    return 0;    
}
```

---

## 作者：北海若 (赞：0)

对于john的一张牌，别人手里有一张比他大的牌并且这张牌还没出掉，那就可能输；输的这一轮这张牌必须出掉。

所以这样：首先桶排序，从小到大看看John有哪些牌没有哪些牌

从大到小扫一遍，对于每一张有的牌，从最大往下扫，如果有一张没有的牌，就输一轮，并且标记这张牌是出过的。

然后输的时候记得break;

O((m\*n)^2)

'''
```cpp
#include <iostream>
using namespace std;
int main()
{
    int n,m;
    cin>>m>>n;
    int * d = new int[m*n+1];
    for (int i=0; i<m*n+1; i++)
        d[i] = 0;
    for (int i=0; i<n; i++)
    {
        int tmp;
        cin>>tmp;
        d[tmp] = 1;
    }
    int ans = 0;
    for (int i=m*n; i>=1; i--)
    {
        if (d[i] == 1)
        {
            bool flag = true;
            for (int j=m*n; j>i; j--)
            {
                if (d[j] == 0)
                {
                    flag = false;
                    d[j] = 1;
                    break;
                }
            }
            if (flag)
                ans++;
        }
    }
    cout<<ans;
    //getchar();getchar();
    return 0;
}
'''
```

---

## 作者：重力做功 (赞：0)

# 呀 好像没有p的

所以我来水（划掉）

咳咳，（我）采用贪心

由于贪心地认为john输得最惨

所以认为john在和另一个拿着其他所有大牌的人打(bei)牌(nue)

但是john已经有的从n\*m倒数的几张王牌是必须拿分的

那么一旦有john空出的牌，就直接贪心地去压john的次大牌

代码
```pascal
var
  n,m,i,j,k,l,ans:longint;
  a:array[1..50]of longint;
  c:array[1..10000]of boolean;
begin
  readln(m,n);
  for i:=1 to n*m do c[i]:=true;
  for i:=1 to n do begin read(a[i]);c[a[i]]:=false;end;//记录john没有的牌，一会去找john空出的牌更方便
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if a[i]<a[j] then
       begin
         l:=a[i];a[i]:=a[j];a[j]:=l;
       end;//排序，好判断次大的牌是那些
  k:=n*m;while not(c[k]) do dec(k);//k表示手持大牌人手中的能打的最大值
  for i:=1 to n do
   begin
     if a[i]>k then begin inc(ans);continue;end;//如果john有大牌，ans++
     dec(k);while not(c[k]) do dec(k);//没有就直接压去，查找BOSS手中现在能打的最大值
   end;
  writeln(ans);
end.
```

---

## 作者：OIer991215 (赞：0)

看了下A过次题的人的用时，似乎只有我是0ms...

其实这题是有规律的。

从n\*m开始向1找，找当前这个数在手中有没有，有的话ans++，再从n\*m-1...和n--中找。

没有的话ans--，再从n\*m-1...中找


```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
int n,m,ans,cnt,f[10010];
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1; i<=n; i++)
        scanf("%d",&f[i]);
    sort(f+1,f+1+n);
    int num=n*m;
    while(num>0)
    {
        if(num>f[n])
        {
            ans--;
            num--;
        }
        if(num==f[n])
        {
            num--;
            n--;
            ans++;
            cnt=max(ans,cnt);
        }
    }
    cout<<cnt;
    return 0;
}
```

---

## 作者：似丶水丶流年 (赞：0)

                
```cpp
#include<stdio.h>
#include<algorithm>
#include<string>
#include<iostream>
using namespace std;
int m,n,sum=0,a[51],num[1001];
int k,T;
int min(int  k)
{
    for(int i=a[k];i<=n*m;i++)//去最近的一张牌 
    if(num[i]>a[k])
    return i;
    return 0;
} 
int main()
{
    scanf("%d %d",&m,&n);
    T=m*n;
    k=n;
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
            sort(a+1,a+n+1);
            for(int i=1;i<=T;i++)
            num[i]=i;
    //排序 
    while(k!=0)//重复同样的工作 
{
        if(min(k)!=0)//假设对手用隔最近的一张牌赢得这把 
                {
                    num[min(k)]=0;
                        num[a[k]]=0;
```
}//弃掉最近的这张牌
else//当所有人都没有比a【k】更大的牌时



```cpp
            {
                sum++;//赢一局 
                    num[a[k]]=0;//把当前这张牌弃掉 
            }
            k--; 
} 
    printf("%d",sum); 
}
看几组数据，模拟几次就非常简单了
```

---


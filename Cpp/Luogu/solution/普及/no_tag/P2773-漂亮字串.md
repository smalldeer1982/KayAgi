# 漂亮字串

## 题目描述

Caima认为O和X是最优美的两个字母，由O、X组成的串是最优美的串。在这些最优美的串中，如果任意只包含X的字串，长度不超过maxX，任意只包含O的子串，长度不超过maxO，且整个串最多有countO个O，countX个X。那么这个就是超级优美无敌串。现在Caima想知道最长的超级优美无敌串有多长，希望你告诉他。


## 样例 #1

### 输入

```
10 10 0 0
3 5 1 1```

### 输出

```
0
7```

# 题解

## 作者：Water_Cows (赞：6)

 ###### 这题其实~~很简单~~

这题直接分类讨论。

**1. 有0的时候**

  - 有一方为0，则结果为另一方的$max$；
        
  - 两方都为0,则结果为0；

**2. 不够用的一方即使每次只取一个作为分隔符都不够用**
  
  ###### ~~什么意思？？~~

  - 当$X$不够时 
  
      - 代码
        ```cpp
          ans=（countx+1）*maxo+countx 
         ```
       - 例子
       	 
         	输入：5 100 2 2
            
           最长的超级优美无敌串为：
           
           $XXOXXOXXOXXOXXOXX$
  - 当$O$不够时
    
    - 代码
        ```cpp
         ans=（counto+1）*maxx+counto 
        ```
     - 例子 
     
       输入：20 5 3 2
            
       最长的超级优美无敌串为：
       
       $OOOXOOOXOOOXOOOXOOOXOOO$
     
**3. 另外**

   - ```cpp
     ans=maxn+maxm
     ```
   
然后就是代码环节

code 
```cpp
#include <cstdio>
using namespace std;
long long X, Y, A, B;//注意long long
inline long long min(long long x, long long y) {return x<y? x:y;}
int main()
{
    while(scanf("%lld%lld%lld%lld", &X, &Y, &A, &B)!=EOF)
    {
        A=min(X, A);
        B=min(Y, B);
        //注意取最小
        if(A==0) printf("%lld\n", B);
        else if(B==0) printf("%lld\n", A);
        //第一种
        else if((X+1)*B<Y) printf("%lld\n", (X+1)*B+X);
        else if((Y+1)*A<X) printf("%lld\n", (Y+1)*A+Y);
        //第二种
        else printf("%lld\n", X+Y);
        //第三种
    }
    return 0;
    so beautiful
}
```
PS.  这里用A，B，X，Y代替了上面的那些变量，不影响理解

~~我的第一篇题解，求管理员大大通过~~




---

## 作者：pengzy (赞：2)

这是一道很好的 **分情况讨论** 数学题。

## 思路：

我们可以分为 $3$ 种情况来讨论。

### 1. $CountO$ 或 $MaxO$ 为 $0$；$CountX$ 或 $MaxX$ 为 $0$。

对于这种情况，我们拿 $O$ 来举例子，当 $CountO$ 或 $MaxO$ 为 $0$ 时。显而易见：如果是 $CountO$ 为 $0$，说明一个 $O$ 都没有；如果是 $MaxO$ 为 $0$，说明就算有 $O$ 你也不能用它去构造字符串，因为构造的字符串中不允许有长度 $>0$ 的 **连续** 子串。所以，当 $CountO$ 或 $MaxO$ 为 $0$ 时，只能用 $X$ 来构造字符串，而字符串的长度会受到 $CountX$ 和 $MaxX$ 中较小一方的限制，故答案为 $\min(CountX,MaxX)$。

$CountX$ 或 $MaxX$ 为 $0$ 同理，答案为 $\min(CountO,MaxO)$。

如，输入：$10,5,0,4$

这组数据中的 $MaxO$ 为 $0$，表示构造的字符串中不能有长度 $>0$ 的连续子串。所以根据推出的公式，答案为 $4$。因为虽然我们最长长度可达用所有的 $CountX$，但是受 $MaxX$ 的限制，最长也只能有 $4$ 个连续的 $X$。

### 2. $(CountO+1)\times MaxX<CountX$；$(CountX+1)\times MaxO<CountO$。

同上，我们也拿 $O$ 来举例子，当 $(CountO+1)\times MaxX<CountX$ 时。首先需要明确，$MaxO/X+1$ 个连续的 $O/X$，**必须** 要拿一个 $X/O$ 来隔开。那么就简单了，$CountO$ 和 $CountX$ 当中 **少** 的那一个只能用来隔开别人。$(CountO+1)\times MaxX<CountX$ 表示我们采取贪心策略，让头和尾都用极端长度的 $MaxX$ 个 $X$，中间用 $O$ 隔开，那么最多就可以用 $(CountO+1)\times MaxX$ 个 $X$，如果还有剩余的 $X$，我就不可能再用了只能舍弃。答案为 $(CountO+1\times MaxX)+CountO$，表示最多能用的 $X$ 的个数再加上中间用 $CountO$ 个 $O$ 隔开的总长度。

$(CountX+1)\times MaxO<CountO$ 时同理，答案为 $(CountX+1)\times MaxO<CountO+CountX$。

如，输入：$10,2,3,3$

极端情况就是这个：$OOOXOOOXOOO$。

因为 $(2+1)\times 3<10$，所以我们要舍弃一个 $O$。不信的话可以看上面那个极端情况，不可能再加 $O$ 了。注意答案不仅仅是能用到的尽可能多的 $O$（$9$ 个），还要加上用来隔开的 $X$ 的数量。~~貌似根本没有用到 MaxX~~。

### 3. 都不满足以上的两点

答案为 $CountO+CountX$，表示所有的字母都可以用，而且，组成的方式可能还不止一种。~~证明的话就不需要了吧~~。

如，输入：$5,6,3,4$

因为都不满足以上两个条件，所以答案为 $11$。

合法的方案有：$XXXOOOXXOOO$，$XXOOOXXXOOO$ 等。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long CountX,CountO,MaxX,MaxO;
int main()
{
	while(cin>>CountO>>CountX>>MaxO>>MaxX) {
		if(!CountX||!MaxX)cout<<0<<endl;
		else if(!CountO||!MaxO)cout<<0<<endl;
		else if(MaxO*(CountX+1)<CountO)//如果你 X 不够用
		    cout<<MaxO*(CountX+1)+CountX<<endl;//那你说最多能有几个
		else if(MaxX*(CountO+1)<CountX)
		    cout<<MaxX*(CountO+1)+CountO<<endl;
		else cout<<CountO+CountX<<endl;
	}
	return 0;
}
```

若有不懂欢迎在评论里提问，若题解有误欢迎在评论里指出。

---

## 作者：Erotate (赞：1)

我们直接分类讨论即可：

1. $CountO$ 或 $maxO$ 为 0 时，字符串只包含 $X$ ,那答案为 $\min(CountX,maxX)$。

2. 同理，当 $CountX$ 或 $maxX$ 为 0 时，答案为 $\min(CountO,maxO)$。

3. 当 $O$ 不够用时，即 $CountX>maxX*(CountO+1)$，每个 $O$ 对应着 $maxX$ 个 $X$，但 $X$ 还是有多的，那答案为 $maxX*(CountO+1)+CountO$。

4. 与 3. 同理，当 $X$ 不够用时，答案为 $maxO*(CountX+1)+CountX$。

5. 其他情况，字符串最长为 $CountX+CountO$。

代码：
```cpp
//这里 cx，mx，co，mo，分别代表 CountX，maxX，CountX，maxO。
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cx,co,mx,mo;
signed main(){
	while(cin>>co>>cx>>mo>>mx){
		if(!(min(co,mo))) cout<<min(cx,mx)<<endl;
		else if(!(min(cx,mx))) cout<<min(co,mo)<<endl;
		else if(cx>mx*(co+1)) cout<<mx*(co+1)+co<<endl;
		else if(co>mo*(cx+1)) cout<<mo*(cx+1)+cx<<endl;
		else cout<<cx+co<<endl;
	}
	return 0;
}
```


---

## 作者：Erica_N_Contina (赞：0)

## 思路

既然大家都知道最优解法 $O(1)$（仅谈论单组数据），那么我就不写了。

既然大家都要用到 `long long`，那我就不开了。

我来浅浅的介绍一下一个用不到 `long long`，单组数据复杂度为 $O(\min(co,cx))$ 的算法。

我们将 $CountO,CountX,maxO,maxX$ 缩写为 $cO,cX,mO,mX$。

- 情况 1：$cO,cX,mO,mX$ 其中有 $0$ 存在。

这种情况我们特判一下。

```C++
	if((!mo)&&(!mx))return 0;
	if(!mo||(!co))return min(mx,cx);
	if(!mx||(!cx))return min(mo,co);
```


- 情况 2：$cO,cX,mO,mX$ 均非零。

我们将 `X` 串简写为 `X`，将 `O` 串简写为 `O`，那么最终的字符串一定是下面之一：

1. `XOXO...OX`

2. `XOXO...OXO`

3. `OXO...OXO`

我们发现，我们记 `O` 串的数量为 $nO$，`X` 串的数量为 $nX$，那么 $nO$ 的数量为 $nX,nX+1$ 或者 $nX-1$。我们枚举 $nX$，然后枚举 $nO$ 的值（$nX,nX+1$ 或者 $nX-1$），计算出在当前 $nX,nO$ 下每个 `O` 串和 `X` 串的长度，最后计算出整个串的总长度。

枚举 $nX,nO$。`judge(nX,nO)` 计算当前 $nX,nO$ 下每个 `O` 串和 `X` 串的长度，返回计算出的整个串的总长度。

```C++
int res=0;
	for(int i=1;i<=min(co,cx);i++){//nX最大值就是min(co,cx)，即每个 `X` 串(或者是 `O` 串)长度仅为1
		res=max(res,judge(i,i+1));
		res=max(res,judge(i,i));
		res=max(res,judge(i,i-1));
	}
```


`judge()` 函数。

```C++
int judge(int o,int x){
	int po=min((int)ceil(1.0*co/o),mo);//计算每个 `O` 串的长度,注意向上取整,(int)ceil(1.0*co/o)计算的是O取满cO个时平均每一个 `O` 串的长度(有可能不能平均分,所以要向上取整)
	int px=min((int)ceil(1.0*cx/x),mx);
	sumx=min(cx,px*x);
	sumo=min(co,po*o);
	return sumx+sumo;//返回计算出的整个串的总长度
}

```


## 代码

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
#include<bits/stdc++.h>

//数据类型
#define ll long long
#define ull unsigned long long
#define db double
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e3;
const int MOD=903250223;
const int INF=1e9;
//变量
int n,a[N],b[N],sum,x[N],y[N],ans,res,tmp,cnt,web[M][M];
int co,cx,mo,mx,sumo,sumx;

int judge(int o,int x){
	int po=min((int)ceil(1.0*co/o),mo);
	int px=min((int)ceil(1.0*cx/x),mx);
	sumx=min(cx,px*x);
	sumo=min(co,po*o);
//	printf("ox %d %d pox %d %d sum %d\n",o,x,po,px,sumx+sumo);
	return sumx+sumo;
}

int sol(){
	if((!mo)&&(!mx))return 0;
	if(!mo||(!co))return min(mx,cx);
	if(!mx||(!cx))return min(mo,co);
	int res=0;
	for(int i=1;i<=min(co,cx);i++){
		res=max(res,judge(i,i+1));
		res=max(res,judge(i,i));
		res=max(res,judge(i,i-1));
	}
	return res;
}

signed main(){
	while(cin>>co>>cx>>mo>>mx)cout<<sol()<<endl;
	return 0;
}

```




---

## 作者：HHYQ_07 (赞：0)

# 题解

## 一些无关紧要的话

1. [双倍经验](https://www.luogu.com.cn/problem/P1620)。
2. 此题可以归结为数论、分类讨论的题，不是很难，建议标橙。
3. 此题需开 long long！

## 大致思路

分类讨论：
1. 当 $CountO$、$maxOmaxO$ 或 $CountX$、$MaxXMaxX$ 中有一个为 $0$ 时，即字符串中只包含 $X$ 或 $O$，答案为：$\min(CountX,maxX)$ 或 $\min(CountO,maxO)$。
2. 当字符串中有一种字符不够用时，每一个这种字符都会对应着 $maxX/O$，而另一个字符还有很多，答案为：$maxX\times(CountO+1)+CountO$ 或 $maxO\times(CountX+1)+CountX$。
3. 剩下的情况中两种字符都够用，答案为：$CountX+CountO$。

## $ACcode$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int counto,countx,maxo,maxx;
signed main()
{
    while(cin>>counto>>countx>>maxo>>maxx)
    {
        if(counto==0||maxo==0)printf("%lld\n",min(countx,maxx));//情况一 
        else if(countx==0||maxx==0)printf("%lld\n",min(counto,maxo));//情况一 
        else if((counto+1)*maxx<countx)printf("%lld\n",(counto+1)*maxx+counto);//情况二 
        else if((countx+1)*maxo<counto)printf("%lld\n",(countx+1)*maxo+countx);//情况二 
        else printf("%intd\n",counto+countx);//情况三  
    }
    return 0;
}
```
请求管理员大大通过。

---

## 作者：zhang_kevin (赞：0)

# Solution

简单题，但注意开 `long long`！

首先，我们要分 $3$ 中情况讨论。

1. 任意一个变量的值是 $0$

举个例子，当 $\text{CountX}$ 或 $\text{maxX}$ 等于 $0$ 时，显然：如果 $\text{CountX} = 0$，这个字符串一个 $\text{X}$ 也没有，$\text{maxX} = 0$ 时，就算你有 $\text{X}$ 也不能用。所以，此时只能用 $\text{O}$ 来构造字符串，答案便为 $\text{min(CountO,maxO)}$。

这种情况的例子见样例的第一组。

2. 有一个字母不够用，即 $\text{CountX>maxX}\times\text{(CountO+1)}$ 或 $\text{CountO>maxO}\times\text{(CountX+1)}$。

以第一种为例，每个 $\text{O}$ 对应 $\text{maxX}$ 个 $\text{X}$，$\text{X}$ 还是有剩余，答案为 $\text{maxX}\times\text{(CountO+1)+CountO}$。

3. 其他情况

此时每个字母都能用到，答案为 $\text{CountO + CountX}$，这道题就解决了。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long CountO, CountX, maxO, maxX;
int main(){
    while(cin >> CountO >> CountX >> maxO >> maxX){
        if(CountX == 0 || maxX == 0) cout << min(CountO, maxO) << endl;
        else if(CountO == 0 || maxO == 0) cout << min(CountX, maxX) << endl;
        else if(CountX > maxX * (CountO+1)) cout << maxX * (CountO+1) + CountO << endl;
		else if(CountO > maxO * (CountX+1)) cout << maxO * (CountX+1) + CountX << endl;
        else cout << CountO + CountX << endl;
    }
    return 0;
}
```

---

## 作者：bryce (赞：0)

### [题目链接](https://www.luogu.com.cn/problem/P2773)

这道题与 [P1620 漂亮字串](https://www.luogu.com.cn/problem/P1620) 相同

 ~~同是一道题的颜色差距好大~~

这道题主要分三种情况来讨论

1. 当任何变量的值为 0 时

	如果 maxo 或 counto 为 0 时就说明串中只有 x，那么串的长度就为 $min(countx, maxx)$，反之 maxx 或 countx 为 0 时同理，除此之外就输出 0。


2. 当 O 或 X 不够用时

	也就是当 $countx > maxx * (counto + 1)$ 或 $counto > maxo * (countx + 1)$ 时，
	那么串的长度为 $counto + maxx * (counto + 1)$ 或 $countx + maxo * (countx + 1)$。

3. 其他情况

	串的长度为 countx + counto。

接下来就是代码。

## Code

```cpp
#include<iostream>

using namespace std;

int main(){
    long long counto, countx, maxo, maxx;   //开long　long　小心爆int
    while (cin >> counto >> countx >> maxo >> maxx){	//第一种情况
        if (maxo == 0 || counto == 0){
            cout << min(countx, maxx) << endl;
        }else if (maxx == 0 || countx == 0){	//第一种情况
            cout << min(counto, maxo) << endl;
        }else if (countx > (counto + 1) * maxx){
            cout << counto + (counto + 1) * maxx << endl;	//第二种情况
        }else if (counto > (countx + 1) * maxo){
            cout << countx + (countx + 1) * maxo << endl;	//第二种情况
        }else{
            cout << countx + counto << endl;	//其它情况
        }
    }
    return 0;   //完结,散花
}
```

这是我的第一篇题解,求管理员过 qwq (管理员大大最帅了)。

---

## 作者：Drystynt (赞：0)

这题第一步先要注意审题(long long!!)，然后分类讨论不要掉情况。

1. maxO=0或countO=0时。串中必只含X，所以长度应为$\min\{\rm CountX,maxX\}$;

2. maxX=0或countX=0时，与第1种情况同理；

3. CountO非常大时，定量描述是$\rm CountX×maxO+maxO<CountO$时，此时我们可以把`X`夹在一堆`O`里面，即用$\rm CountX$个"单体`X`"把$\rm maxO$个`O`分成$\rm CountX+1$段。

4. CountX非常大时，定量描述是$\rm CountO×maxX+maxX<CountX$时, 与第3种情况同理;

5. 其他情况X、O一定可以存在一种排列方式全部用完(第3、4种情况不能用完是因为$\rm CountX$或$\rm CountO$太大了)，则答案为$\rm CountX+CountO$.

话不多说，上code:

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll CountO, CountX,maxO,maxX;
ll min(ll x,ll y) {if(x<y)return x;else return y;}
int main(void)
{
    while(cin>>CountO>>CountX>>maxO>>maxX)
    {
        if(CountO==0||maxO==0) printf("%lld\n", min(CountX,maxX));
        else if(CountX==0||maxX==0) printf("%lld\n", min(CountO,maxO));
        else if((CountO+1)*maxX<CountX) printf("%lld\n", 
        (CountO+1)*maxX+CountO);
        else if((CountX+1)*maxO<CountO) printf("%lld\n", 
        (CountX+1)*maxO+CountX);
        else printf("%lld\n", CountO+CountX);
    }
    return 0;
}
```

---

## 作者：issue_is_fw (赞：0)

我的理解是这样的 

首先明确一点，最长的串长为maxx+maxo

而且这是两种字母刚好用完的情况

那我们先考虑一方不够用的情况

也就是把少的那个字母每次只用一个作为分隔符依然不够用

此时少的字母全部用完，多的字母是最大分割数，肯定最优

特殊的，可能存在一方为0的情况，特判

其余情况可以全部用完，为maxx+maxo

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll maxx,maxo,shux,shuo;
int main()
{
	while(cin>>shuo>>shux>>maxo>>maxx)
	{
		if(shuo==0||maxo==0)	cout<<min(shux,maxx);
		else if(shux==0||maxx==0)	cout<<min(shuo,maxo);
		//串中最多有shux+shuo个字符串(当x不够时)
		else if((shux+1)*maxo<shuo)	cout<<(shux+1)*maxo+shux;
		else if((shuo+1)*maxx<shux)	cout<<(shuo+1)*maxx+shuo;
		else	cout<<shuo+shux;
		cout<<endl; 
	} 
}
```


---

## 作者：zj余能 (赞：0)

这道题其实可以归为数论题，因为对于存在的

Count\_O、Count\_X、max\_O、max\_X一些关系，

答案是固定的，可以直接推出来。

大致可分为5种情况：

1. 当max\_O为0时，即不能放O，则最多只能放max\_X个X了；

2. 当max\_X为0时，同上；

3. 考虑Count\_O比Count\_X大很多时，一定是X放完了而O有余，

则可以这样考虑使放的O最多，即用Count\_X个X把字串

分成Count\_X+1个段，每段放max\_O个O，则最后答案

为(Count\_X+1)\*max\_O+Count\_X;

4. 考虑Count\_X比Count\_O大很多时，同上；

5. 最后，如果不满足第3或4个条件，那一定存在某种排列方式，

使X和O全部放入，则答案为Count\_X+Count\_O；



```cpp
#include<iostream>
using namespace std;

int main(){
    long long co,cx,mo,mx; 
    while (cin >>co>>cx>>mo>>mx){
        long long maxn=0;
        if (mo==0) maxn=mx;
        else if (mx==0) maxn=mo;
        else if ((co+1)*mx<cx) maxn=(co+1)*mx+co;
        else if ((cx+1)*mo<co) maxn=(cx+1)*mo+cx;
        else maxn=co+cx;
        cout <<maxn<<endl;
    }
    return 0;
}
```

---


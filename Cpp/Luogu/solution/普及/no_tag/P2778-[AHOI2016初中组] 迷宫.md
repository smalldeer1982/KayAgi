# [AHOI2016初中组] 迷宫

## 题目描述

小雪和小可可被困在了一个无限大的迷宫中。

已经知道这个迷宫有 $N$ 堵环状的墙，如果把整个迷宫看作是一个二维平面，那么每一堵墙都是平面上一个圆。**任意两个圆不相交，不重合，也不会相切，但有可能相互包含**。小雪和小可可分别被困在了 $2$ 个不同的位置，且保证他们的位置与这些圆不重合。

他们只有破坏墙面才能穿过去。

小雪希望知道，如果他们要相见，至少要破坏掉多少堵墙？他们可以在任何位置相见。

## 说明/提示

对于 $20\%$ 的数据，$0\le N\le 200$。

对于 $40\%$ 的数据，$0\le N\le 1000$。

对于 $100\%$ 的数据，$0\le N, Q\le 8000,-10^8\le x,y,r, a, b, c, d\le 10^8$。

此外，还有额外的 $20\%$ 的数据，满足 $0\le N\le 1000,0\le Q\le 1000$。

大数据点时限 $\rm 3\ s$。

## 样例 #1

### 输入

```
3
0 0 1
3 0 1
2 0 4
1
0 0 3 0```

### 输出

```
2```

## 样例 #2

### 输入

```
3
0 0 1
0 0 2
4 0 1
2
0 0 4 0
0 0 0 4```

### 输出

```
3
2```

# 题解

## 作者：浮尘ii (赞：9)

笔者的做法和下面几篇题解是一样的，在这里就不重复叙述了。这里介绍一下官方给出的做法。


##题目分析

把平面上每一个区域看作一个结点，最外层没有边界的区域也看作一个结点。如果一个区域刚好被另外一个区域直接包含，则连边。构成的图上做最短路径即可以得到40~60的分数。

又发现，上述得到的图是树结构的，在树上预处理好任意两点的最近公共祖先，之后的询问可以线形完成，这便可以得到满分。


##std
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
struct Point
{
    ll x,y;
    Point(){}
    Point(ll _x,ll _y):x(_x),y(_y){}
    Point operator - (const Point &t)const
    {
        return Point(x-t.x,y-t.y);
    }
    ll len2()
    {
        return x*x+y*y;
    }
};
struct Circle
{
    Point o;
    ll r;
    Circle(){}
    Circle(Point _o,ll _r):o(_o),r(_r){}
    bool operator < (const Circle &t)const
    {
        return r<t.r;
    }
    bool contain(Point t)
    {
        return (t-o).len2()<r*r;
    }
}c[8005];
struct Edge
{
    int to,nxt;
}edge[8005];
int head[8005],tot;
void init()
{
    memset(head,-1,sizeof(head));
    tot=0;
}
void addedge(int u,int v)
{
    edge[tot].to=v;
    edge[tot].nxt=head[u];
    head[u]=tot++;
}
int fa[8005],dep[8005];
void dfs(int u,int la)
{
    fa[u]=la;
    dep[u]=(la>=0 ? dep[la]+1 : 0);
    for(int i=head[u];~i;i=edge[i].nxt)
        dfs(edge[i].to,u);
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%lld%lld%lld",&c[i].o.x,&c[i].o.y,&c[i].r);
    c[n++]=Circle(Point(0,0),200000000);
    sort(c,c+n);
    init();
    for(int i=0;i<n-1;i++)
        for(int j=i+1;j<n;j++)
            if(c[j].contain(c[i].o))
            {
                addedge(j,i);
                break;
            }
    dfs(n-1,-1);
    int m;
    scanf("%d",&m);
    for(int i=0;i<m;i++)
    {
        int u[2];
        for(int j=0;j<2;j++)
        {
            Point p;
            scanf("%lld%lld",&p.x,&p.y);
            for(int k=0;k<n;k++)
                if(c[k].contain(p))
                {
                    u[j]=k;
                    break;
                }
        }
        int res=0;
        while(u[0]!=u[1])
        {
            if(dep[u[0]]>dep[u[1]])u[0]=fa[u[0]];
            else u[1]=fa[u[1]];
            res++;
        }
        printf("%d\n",res);
    }
    return 0;
}
```

##吐槽

这玩意又难写，常数又大（原题时限5s），不知道出题人怎么想到的。


---

## 作者：xy_f (赞：5)

首先，这道 2016 年的 AH 初中组省赛题，思路很明确：枚举每个圆。如果终点和起点与同圆的位置关系不一致，则计入答案。

但是，有一个细节，部分题解忽略了。

`保证-100000000<=x,y,r<=100000000。`

也就是说，如果某个圆的圆心的坐标与要求的点的坐标相比恰好十分极端，比如 $(-10^8,-10^8)$ 和 $(10^8,10^8)$，强行求距离（或者距离平方）的话， int   肯定是受不住的，因此肯定要用 long long 处理，或者    unsigned long long，int128，高精度之类的，不过其他的没有必要，而且相当麻烦。

**如果不把此题当做竞赛题做，那么也可以用  python**

思路已经明确，附代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long x[8005],y[8005],r[8005],a,b,c,d; 
int n,q;
long long dis(long long a,long long b,long long c,long long d)
{
	return (a-c)*(a-c)+(b-d)*(b-d);//距离平方
}
bool check(int i)
{
	bool f1=dis(x[i],y[i],a,b)<r[i]*r[i];//1在圆内 true 
	bool f2=dis(x[i],y[i],c,d)<r[i]*r[i];//2在圆内
	return !f1&&f2||f1&&!f2;//偷懒的话可以写作return f1+f2
}
int main()
{
	//时间复杂度的分析
	//语句数量 4+n+3q+3nq
	//保留最大 3nq
	//去除常数 nq 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld%lld",&x[i],&y[i],&r[i]);
	scanf("%d",&q);
	while(q--)
	{
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		long long ans=0;
		for(int i=1;i<=n;i++)
			if(check(i))
				ans++;
		printf("%lld\n",ans);
	}
	return 0;
} 
```

在处理 long long 和 int 的容斥时，你谷的编译器似乎和  `Dev`  不尽相同，需要非常严格地避免二者的冲突。

end.

---

## 作者：fl_334 (赞：5)

**代码简短易懂**

###总思路，只要一个人在圈内，另一个人不在圈内就要跨过一个圆，ans++

注意，此处本因有三种情况

##1.两人都在圈内，不翻墙

##2.两人都在圈外，也不翻墙

##3.两人一个在圈内，一个在圈外，翻墙

恩就是这样

```cpp
int work(int x1,int y1,int x2,int y2)       
{
    int f1,f2,ans=0;
    for (int i=1;i<=n;i++)
    {
        f1=0;f2=0;
        if (sqr(x1-x[i])+sqr(y1-y[i])<sqr(r[i])) f1=1;               //判断第一个人是否在圈内
        if (sqr(x2-x[i])+sqr(y2-y[i])<sqr(r[i])) f2=1;            //这里为了避免浮点数计算可以把距离公式两边都平方掉
        if ((f1==1&&f2==0)||(f1==0&&f2==1)) ans++;           
}
return ans;
}
//给出核心代码，这个过程调Q遍就行
```

---

## 作者：胡金梁 (赞：3)

这一题怎么看怎么像深度优先搜索或广度优先搜索。

然而，并不是那么回事。在代码受挫后，我换了一种思路：如果这是一个游戏（像纪念碑谷一样），那么我会怎么玩？

在深（N）思（次）熟（失）虑（败）之后，我找到了一个规律：只要两人都在某个圈外或圈里，那么这个圈他们两不用破。于是代码写出来了：
```cpp
for(int j=1;j<=n;j++)
{
	if(check(a,b,j)!=check(c,d,j))
	{
		ans++;
		if(check(a,b,j)&&check(c,d,j))
		{
			ans=1;
			break;
		}
	}
}
```
check函数：
```cpp
bool check(int xx,int yy,int num)
{
	if(abs(xx-x[num])*abs(xx-x[num])+abs(yy-y[num])*abs(yy-y[num])<=z[num])
	{
		return true;
	}
	return false;
}
```
但是交上去：[几度夕阳红](https://www.luogu.com.cn/record/50281690)。为什么？很快，我发现了一个问题：万一他们俩确实是在一个大圈里，可是又有两个小圈把他们分别框在不同的地方呢？于是我又做了一次修改，把判断他们两是否同时在一个圈里的代码删了：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int x[8005],y[8005],z[8005];
bool check(int xx,int yy,int num)
{
	if(abs(xx-x[num])*abs(xx-x[num])+abs(yy-y[num])*abs(yy-y[num])<=z[num])
	{
		return true;
	}
	return false;
}
signed main()
{
    int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i]>>z[i];
		z[i]*=z[i];
	}
	int q;
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		int a,b,c,d,ans=0;
		cin>>a>>b>>c>>d;
		for(int j=1;j<=n;j++)
		{
			if(check(a,b,j)!=check(c,d,j))
			{
				ans++;
			}
		}
		cout<<ans<<endl;
	}
}
```


---

## 作者：wtxy2006 (赞：1)

### Describe:
有 $2$ 个点，求从一个点到另一个点需要穿过几个圆。
### Solution:
#### Upd1 at 2020/8/25：

感谢用户 @ sipu6174的hack，更新了求根公式（~~连求根公式都写错了。。。~~）。

---


~~看到楼上的大佬都用图论做，我这个蒟蒻只能想到解析几何了。~~

什么时候需要破墙呢？

我们知道，当 $2$ 个点同时在一个圆内，或者圆外时，这 $2$ 种情况是不需要破墙的。

就像这样：
![](https://s1.ax1x.com/2020/06/25/N05j8H.png)

那么**当一个点在圆内，而另外一个点在圆外时需要破墙。**

就像这样：
![](https://s1.ax1x.com/2020/06/25/N05kcR.png)

怎么判断一个点在圆内，而另一个点在圆外呢？

我们把这 $2$ 点给连接起来，**如果这条线段与圆只有一个交点，那么就说明一个点在圆内，另一个点在圆外**。

我们的思路就有了，先根据这 $2$ 点算直线解析式，再算与圆的交点，如果只有一个交点在线段上那么就需要破墙。

如图：
![](https://s1.ax1x.com/2020/06/25/N0IHQs.png)

我们假设 $A(x_1, y_1), B(x_2, y_2), O(x_3, y_3)$，半径为 $r$。

可得：
$$
\left\{ \begin{array}{l}
        y=\frac{\left( y_1-y_2 \right)}{\left( x_1-x_2 \right)}x+\left( y_1-x_1\cdot \frac{\left( y_1-y_2 \right)}{\left( x_1-x_2 \right)} \right) \ \\
        \left( x-x_3 \right) ^2+\left( y-y_3 \right) ^2=r^2\ \\
\end{array} \right.
$$

将 $①$ 式带入 $②$ 式化简得：
$$
\left( 1+{k_1}^2 \right) x^2+\left( 2b_1k_1-2x_3-2y_3k_1 \right) x+\left({b_1}^2-2y_3+b_1 \right) =0
\\
$$
$b_1$ 和 $k_1$ 为直线 $y$ 的斜率和系数。

则各项系数 $a,b,c$ 为：
$$
\begin{array}{l}
        a=\left( {1+k_{1}}^{2} \right)\\
        b=\left( 2b_1k_1-2x_3-2y_3k_1 \right)\\
        c=\left( {b_{1}}^{2}-2y_3+b_1 \right)\\
\end{array}
$$
解此一元二次方程即可得到交点。

判断交点是否在线段上即可。

复杂度 $O\left( n\cdot k \right) $。

详细见代码。
### Code:
```cpp
// P2778 [AHOI2016初中组]迷宫
#include <cmath>
#include <cstdio>
#include <iostream>
#define ops 1e-7
#define MN 8010
#define d(x1, y1, x2, y2) ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
using namespace std;
inline int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
  return x * f;
}
struct circle {
  int x, y, r;
} cs[MN];
int n, q;
int main() {
  n = read();
  for (int i = 1; i <= n; i++)
    cs[i].x = read(), cs[i].y = read(), cs[i].r = read();
  q = read();
  while (q--) {
    int x1 = read(), y1 = read(), x2 = read(), y2 = read(), ans = 0;
    if (x1 > x2) swap(x1, x2), swap(y1, y2);
    if (x1 == x2) {
      for (int i = 1; i <= n; i++) {
        int x3 = cs[i].x, y3 = cs[i].y, r = cs[i].r, sum = 0;
        double delta = r * r - (x1 - x3) * (x1 - x3);
        // printf("%.2f", delta);
        if (delta > ops) {
          double s1 = sqrt(delta) + y3, s2 = y3 - sqrt(delta);
          if (y1 < s1 && s1 < y2) sum++;
          if (y1 < s2 && s2 < y2) sum++;
        }
        if (sum == 1) ans++;
      }
    } else if (y1 == y2) {
      for (int i = 1; i <= n; i++) {
        int x3 = cs[i].x, y3 = cs[i].y, r = cs[i].r, sum = 0;
        double delta = r * r - (y1 - y3) * (y1 - y3);
        if (delta > ops) {
          double s1 = sqrt(delta) + x3, s2 = x3 - sqrt(delta);
          if (x1 < s1 && s1 < x2) sum++;
          if (x1 < s2 && s2 < x2) sum++;
        }
        if (sum == 1) ans++;
      }
    } else {
      double k1 = double(y1 - y2) / double(x1 - x2), b1 = y1 - k1 * x1;
      for (int i = 1; i <= n; i++) {
        int x3 = cs[i].x, y3 = cs[i].y, r = cs[i].r, sum = 0;
        // 求交点
        // 联立 y = k1x + b1y;
        //     (x - x3)^2 + (y - y3)^2 = r^2;
        double a = 1 + k1 * k1, b = (2 * b1 * k1 - 2 * x3 - 2 * y3 * k1),
               c = (b1 * b1 - 2 * y3 * b1 + x3 * x3 + y3 * y3 - r * r);
        double delta = b * b - 4 * a * c;
        // printf("%.2f %.2f %.2f %.2f", a, b, c, delta);
        if (delta > ops) {
          double s1 = (-b + sqrt(delta)) / 2 / a,
                 s2 = (-b - sqrt(delta)) / 2 / a;
          // printf(" %.2f %.2f", s1, s2);
          if (x1 < s1 && s1 < x2) sum++;
          if (x1 < s2 && s2 < x2) sum++;
        }
        if (sum == 1) ans++;
      }
    }
    printf("%d\n", ans);
  }
  return 0;
}
```

---

## 作者：星之海 (赞：1)

我来说一下思路和比较重要的代码吧

首先呢，做这道题我主要用的是有关圆在笛卡尔坐标系上的位置关系：

假设在坐标系上有一个圆，圆心的坐标为(x,y)，当前的坐标是(x1,y1)，那么有：

1、如果(x1-x)²+(y1-y)²<r²，则该点在圆内

2、如果(x1-x)²+(y1-y)²=r²，则该点在圆上

3、如果(x1-x)²+(y1-y)²>r²，则该点在圆外

那么，知道这个之后解出这题就不难了

首先，打一个函数，判定在不在圆外，可以用下面的程序实现：

```
int fun(int xx,int yy,int k)//是否在圆内(根据圆在笛卡尔坐标系的性质可得)
{
	if((x[k]-xx)*(x[k]-xx)+(y[k]-yy)*(y[k]-yy)>r[k]*r[k])
	return 0;//圆外 
	else 
	return 1;//圆内 
}
```

那么主程序怎么做呢？

我们想一下，如果我们判定了这个点在不在圆外面，我们就可以这样做

如果有一个点在圆外面，另一个在里面，则需要将打破的墙的数量++

否则，就不需要加了

所以，主函数的主要程序段长这样的：

```
int sum=0;
cin>>x1>>y1>>x2>>y2;
for(j=1;j<=n;j++)
if(fun(x1,y1,j)+fun(x2,y2,j)==1)
sum+=1;
cout<<sum<<endl;
```

如果要执行q个询问，q次这个循环就可以了

---

## 作者：AC_Evil (赞：1)

######很简单，两个人只要在一个圈里，就不用冲破墙；不在一块就使解++。其次是效率问题。

var
circle:array[1..8000] of record

```cpp
    x,y:longint;
    r:int64;
  end;
  s,i,j,n,q,a,b,c,d:longint;
begin
  readln(n);
  for i:=1 to n do
   with circle[i] do
   begin
    readln(x,y,r);
    r:=r*r;
   end;
  readln(q);
  for i:=1 to q do
   begin
     readln(a,b,c,d);
     s:=0;
     for j:=1 to n do
      with circle[j] do
      if (sqr(a-x)+sqr(b-y)<=r) xor (sqr(c-x)+sqr(d-y)<=r) then inc(s);
     writeln(s);
   end;
end.
###评测过了，不必担心
```

---

## 作者：Fist_PROF (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2778)



------------
看了官方题解，觉得稍许有些复杂。这道题作为一道初中组的省选题还是有一定思维难度的。

看到题目，我们思考的是，怎么判断小雪和小可可中间的墙的数量。那么，我们将题目转换一下，我们把每个圆都判断一遍，那么，如果小雪在圆内，小可可不在圆内，那么就得打掉一堵墙。以此类推，有 $ n $ 堵墙，我们只需要把每堵墙都判断一下，如果说小雪在圈内，小可可不在圈内，就得打掉一堵墙，这还是好理解的。

那么，怎么判断小可可和小雪是否在圈内呢？

我们只需要用一个距离公式，判断小可可和小雪到圆心的距离是否小于圆心的半径就可以了。

主要代码如下：
```cpp

long long jl(long long x1,long long y1,long long x2,long long y2){
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
	//为什么不加sqrt？
	//为了方便后面半径的计算，省去了π 
}
bool check(int i){
	bool f1=jl(x[i],y[i],a,b)<r[i]*r[i];
	//小雪是否在圆内 
	bool f2=jl(x[i],y[i],c,d)<r[i]*r[i];
	//小可可是否在圆内 
	return (!f1&&f2)||(f1&&!f2);//当其中有一个不在圆内时就要破坏一堵墙 
}


```


---

## 作者：wzmzmhk (赞：0)

题目简述：给出 $n$ 个不相交不重合不相切的圆，给出两个点 $a$ 和 $b$ 的坐标，问若要在这两个点之间画曲线，这条线至少经过几个圆。

首先可以发现，如果一个圆形包含了 $a$ 和 $b$，那么不会经过这个圆。如果一个圆形既不包含 $a$ 也不包含 $b$，也不会经过这个圆。也就是说，**对于一个圆，若它只包含 $a$ 或者 $b$ 的时候，这个圆一定会被经过。**

那么如何判断一个点是否在圆内呢？显然，只需要判断这个点与圆心的距离是否超过半径即可。

于是考虑枚举每一个圆形，若满足条件，则答案数量加 $1$，最后输出答案。注意本题有多测。

```cpp
#include <iostream>
#include <cmath>

using namespace std;

const int N = 8010;

int n, T;
int x[N], y[N];
double r[N];

double dis(int x1, int y1, int x2, int y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

bool is_in(int x1, int y1, int x2, int y2, double r) {
    if (dis(x1, y1, x2, y2) < r) return true;
    return false;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> r[i];
    cin >> T;
    while (T--) {
        int x1, x2, y1, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        int ans = 0;
        for (int i = 1; i <= n; i++)
            if (is_in(x1, y1, x[i], y[i], r[i]) ^ is_in(x2, y2, x[i], y[i], r[i])) ans++;
        cout << ans << endl;
    }
    return 0;
}

```

---

## 作者：睡在墙上的猫 (赞：0)

主要判断在不在圆里面

放代码

/\*
本题算法思想

1、判断ab两个点到每个圆的距离，如果a在

b不在或b在a不在则都需要打墙否则可能是ab都在一个

圈或者都不在圆中则不需要打墙

(x1,y1)--(x2,y2) sqrt() 

\*/
    
    
```cpp
#include<iostream>
#include<cmath>    
using namespace std;
int x[8001],y[8001],r[8001];//保存每个圆的圆心坐标和半径 
int n,a,b,c,d,q,num;//每次输入小雪和小可可的坐标 
int dis(int t1,int t2,int i)//判断一个点的坐标在不在第i个圆中
{
    if (((t1-x[i])*(t1-x[i])+(t2-y[i])*(t2-y[i]))<=r[i]*r[i]) return 1;//在圆中 
    else return 0; 
} 
void read()
{
    int i,j,k;
    cin>>n;
    for (i=1;i<=n;i++)
    {
         cin>>x[i]>>y[i]>>r[i];
    }    
    cin>>q;
    for (i=1;i<=q;i++)
    {
        num=0;
        cin>>a>>b>>c>>d; 
        for (j=1;j<=n;j++)
        {
            if(dis(a,b,j)==1&&dis(c,d,j)==0) num++;//a在b不在
            else if (dis(a,b,j)==0&&dis(c,d,j)==1) num++;
        }
        cout<<num;
    }
} 
int main()
{
read();
    return 0;
}
```
/\*
3
0 0 1
3 0 1
2 0 4
1
0 0 3 0

\*/

---


# 学校选址 II

## 题目描述

在一条大路一旁有许多栋楼，每栋楼里有许多小学生（哈哈哈一波小学生来袭！）。但是这条路上没有小学！！！！所以唯恐世界不乱的牛A打算在路上（汽车什么的都不敢来这个小学生云集的地方咯，所以不用担心安全问题）任选几点（可以和楼重合，当然也可以不重合）建立小学，且使所有小学生上学走的路程之和最短。牛A发现修建一所小学根本无法满足他唯恐世界不乱的（变态）心理，所以他准备建立K所小学。


## 样例 #1

### 输入

```
3 2
24 18 31
10 8```

### 输出

```
144```

# 题解

## 作者：CR_Raphael (赞：31)

[题目传送门](https://www.luogu.org/problemnew/show/P2803)

（学校选址I 在哪里）

这是一道邮局选址问题（post-office location problem）

带权中位数模版

易证存在最优状态使学校全部在某一楼处：


------------

当某一学校不在楼处时，如图：黑点代表楼

![图片](https://cdn.luogu.com.cn/upload/pic/21851.png)

每个到该学校的人（注意不是楼）向其连一条线

总路程就是所有线全长P

将经过该学校到左侧第一栋楼M的线数量记为a

将经过该学校到右侧第一栋楼M+1的线数量记为b

当学校位置在M与M+1之间改变时，取右侧为正方向，移动L，总长改变为：P+L\*a-L\*b

若a<b向左移至M必更优

若a>b向右移至M+1必更优

若a=b移至M或M+1必不劣

所以：**对于任意不在楼处的学校，必然有该学校在楼处的方案不劣于它**

即：**存在最优状态使学校全部在某一楼处**，证毕


------------

dp[i][j]表示第i栋楼房前已经分了j个区间（每个区间的楼房全部通往该区间的一个学校）

dp[i][j]=dp[k-1][j-1]+bs[k][i] (bs定义见下，k为最新区间的起始点)

需要预处理出每个区间[a,b]（每个区间的楼房全部通往该区间的一个学校）的最优状态bs[a][b]




------------

预处理方法：

①把刚才证明过程里的学校放在楼Q上，把M和M+1换成Q-1和Q+1，如图：

![图片2](https://cdn.luogu.com.cn/upload/pic/21853.png)

得：对于每个区间[a,b],

学校从Q移动到Q+1，P[Q+1]=P[Q]+距离[Q到Q+1]\*人数[a到Q]-距离[Q到Q+1]\*人数[Q+1到b]

搞个前缀和记录人数和路程

爆算学校位于a的情况

再由此根据式子推出不位于a的情况

取最小值即可

代码：
```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#define bs best_sit
using namespace std;

const int MN=105;
const int inf=2147483647;

int n,k;
int best_sit[MN][MN];
int num[MN];
int sum[MN];
int dp[MN][MN];

int dis(int a,int b){
    return abs(sum[a]-sum[b]);
}

int men(int a,int b){
	int t1=a,t2=b;
	if(a>b)t1=b,t2=a;
	
    return num[t2]-num[t1-1];
}

int main(){
    int i,j,t,zh,p,minn;
    
    cin>>n>>k;
    
    if(n<=k){
    	cout<<0<<endl;
    	return 0;
    }
    
    for(i=1;i<=n;i++){
        cin>>t;
        num[i]=num[i-1]+t;
    }
    
    sum[1]=0;
    for(i=1;i<=n-1;i++){
        cin>>t;
        sum[i+1]=sum[i]+t;
    }
	
    for(i=1;i<=n;i++){
        for(j=1;j<=i;j++){
        	
			p=0;
			for(zh=j;zh<=i;zh++)
				p=p+ dis(j,zh)*men(zh,zh);
			
			minn=s_dis;
			for(zh=j+1;zh<=i;zh++){
				p= p +dis(zh-1,zh)*men(zh-1,j) -dis(zh-1,zh)*men(i,zh);
				if(p<minn)minn=p;
			}
			
			bs[j][i]=minn;
		}
    }
	
	for(i=1;i<=n;i++){
		for(j=1;j<=k;j++){
			if(j>=i){
				dp[i][j]=0;
				continue;
			}
			
			if(j==1){
				dp[i][j]=bs[1][i];
				continue;
			}
			
			minn=inf;
			for(zh=1;zh<=i;zh++){
				t=dp[zh-1][j-1]+bs[zh][i];
				if(t<minn)minn=t;
			}
			dp[i][j]=minn;
		}
	}
    
    cout<<dp[n][k]<<endl;
    return 0;
}
```


------------

②注意到刚才的式子：

P[Q+1]=P[Q]+距离[Q到Q+1]\*人数[a到Q]-距离[Q到Q+1]\*人数[Q+1到b]

人数[Q+1到b]随着Q向左移动而减小

人数[a到Q]随着Q向左移动而增大

从第一个满足人数[a到Q]>人数[Q+1到b]的位置继续左移，人数[a到Q]始终大于人数[Q+1到b]

则由上面的式子可知,从此左移P会增大

同理,之前P不断在减小

所以该位置P为最小值

也就是说：**在区间[a,b]上，若所有人只去一个学校，从左往右第一个满足 a到Q人数>Q+1到b人数 的位置Q上建学校为最优情况**

（人数[a到Q]=人数[Q+1到b]时左移不会变，所以>改成>=也可以）

当该题的狭义，每栋楼只有一个人（不带权）时，就是中间那栋楼（左右楼数一样）最优

跟中位数是不是很像？

而这个与各点的权（本题为人数）有关的中位数称为**带权中位数**

代码如下：

```c++

#include<iostream>
#include<cstdio>
#include<cmath>
#define bs best_sit
using namespace std;

const int MN=105;
const int inf=2147483647;

int n,k;
int best_sit[MN][MN];
int num[MN];
int sum[MN];
int dp[MN][MN];

int dis(int a,int b){
    return abs(sum[a]-sum[b]);
}

int men(int a,int b){
	int t1=a,t2=b;
	if(a>b)t1=b,t2=a;
	
    return num[t2]-num[t1-1];
}

int main(){
    int i,j,t,zh,minn,p;
    
    cin>>n>>k;
    
    if(n<=k){
    	cout<<0<<endl;
    	return 0;
    }
    
    for(i=1;i<=n;i++){
        cin>>t;
        num[i]=num[i-1]+t;
    }
    
    sum[1]=0;
    for(i=1;i<=n-1;i++){
        cin>>t;
        sum[i+1]=sum[i]+t;
    }
	
    for(i=1;i<=n;i++){
        for(j=1;j<=i;j++){
			for(zh=j;zh<=i;zh++)
				if(men(j,zh)>=men(zh+1,i))break;
			
			if(zh>i)zh=i;
			
			p=0;
			for(t=j;t<=i;t++){
				p=p+ dis(zh,t)*men(t,t);
			}
			
			bs[j][i]=p;
		}
    }
	
	for(i=1;i<=n;i++){
		for(j=1;j<=k;j++){
			if(j>=i){
				dp[i][j]=0;
				continue;
			}
			
			if(j==1){
				dp[i][j]=bs[1][i];
				continue;
			}
			
			minn=inf;
			for(zh=1;zh<=i;zh++){
				t=dp[zh-1][j-1]+bs[zh][i];
				if(t<minn)minn=t;
			}
			dp[i][j]=minn;
		}
	}
    
    cout<<dp[n][k]<<endl;
    return 0;
}

```

（我话真多……）

---

## 作者：un1i (赞：4)

# 来写一篇 dp

## [ 题目传送门 ](https://www.luogu.com.cn/problem/P2803)

**下面是动态规划的大体思路，具体见代码。**

我们可以用 $dp_{i,j}$ 来处理前 $j$ 栋楼建 $i$ 所小学的最小路程和，那么在求解 $dp_{i,j}$ 时，可将前 $j$ 栋楼**划分为两部分**来考虑：

前 $l$ 栋楼的区间 $[1,l]$，在这部分建立 $i-1$ 所小学，其最小路程和先在前面计算得到，并存储于 $dp_{i-1,1}$。

剩下的区间 $[l+1,j]$，在该区间建立 $1$ 所小学，其最小路程和为 $one_{l+1,j}$。

将**这两部分的路程和相加**，即 $dp_{i-1,1}+one_{l+1,j}$，就得到了一种在前 $j$ 栋楼建 $i$ 所小学的方案下的总路程和。

最后通过 $\min(dp_{i,j},dp_{i-1,1}+one{l+1,j})$ 操作，从**所有可能的分割方案中选取总路程和最小的方案**，从而保证 $dp_{i,j}$ 存储的是前 $j$ 栋楼建 $i$ 所小学的最小路程和，最后输出。

## AC Code

```
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
const int N=105;//数据范围
using namespace std;
int m[N][N],d[N][N];
//m[i][j]表示从第i栋楼到第j栋楼的学生总数
//d[i][j]表示从第i栋楼到第j栋楼之间的距离
int one[N][N];//one[i][j]表示在区间[i,j]内只建一所小学时，该区间内所有学生上学走的路程之和
int dp[N][N];//dp[i][j]动态规划，表示在前j栋楼中建立i所小学时，所有学生上学走的路程之和的最小值
int n,k;//n表示楼的数量，k表示要建立的小学数量
inline int read(){//快读模板
	int res=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-48; ch=getchar();}
	return res*f;
}
signed main(){
	n=read();k=read();//快读
	memset(dp,0x7f7f7f7f,sizeof(dp));//初始化dp数组，将所有值设为一个较大的值
	for(int i=1,t;i<=n;i++){//输入每栋楼的学生数，并计算m数组
		t=read();
		//从第j栋楼到第i栋楼的学生总数等于从第j栋楼到第i-1栋楼的学生总数加上第i栋楼的学生数
		for(int j=i;j>=1;j--) m[j][i]=m[j][i-1]+t;
	}
	for(int i=2,s;i<=n;i++){//输入楼与楼之间的距离，并计算d数组
		s=read();
		//从第j栋楼到第i栋楼的距离等于从第j栋楼到第i-1栋楼的距离加上第i-1栋楼到第i栋楼的距离
		for(int j=i-1;j>=1;j--) d[j][i]=d[j][i-1]+s;
	}
	//计算one数组，即每个区间内只建一所小学时的路程之和
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			for(int l=i;l<=j;l++){
				//找到一个分割点l，使得前半部分的学生总数不小于后半部分的学生总数
				if(m[i][l]<m[l+1][j]) continue;
				//计算前半部分学生到分割点l处小学的路程之和
				for(int p=i;p<=l;p++) one[i][j]+=m[p][p]*d[p][l];
				//计算后半部分学生到分割点l处小学的路程之和
				for(int p=l+1;p<=j;p++) one[i][j]+=m[p][p]*d[l][p];
				break;
			}
		}
	}
	//当只建立一所小学时，前i栋楼的最小路程之和就是one[1][i]
	for(int i=1;i<=n;i++) dp[1][i]=one[1][i];
	for(int i=2;i<=k;i++){//动态规划
		for(int j=i;j<=n;j++){
			for(int l=i-1;l<=j-1;l++){
				//dp：在前j栋楼建立i所小学的最小路程之和等于在前l栋楼建立i-1所小学的最小路程之和加上在区间[l+1,j]内建一所小学的路程之和的最小值
				dp[i][j]=min(dp[i][j],dp[i-1][l]+one[l+1][j]);
			}
		}
	}
	//前n栋楼建立k所小学时的最小路程之和
	cout<<dp[k][n]<<endl;
	return 0;
}
```

---

## 作者：yzc1125 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2803)
# 思路
可以发现，这一题 $n,k \le 100$，是完全可以用 $O(n^3)$ 的，优先考虑动态规划。

可以发现这题中只有 $n,k$，所以可以定义 $dp_{i,j}$ 表示对前 $j$ 栋楼来说，建造 $i$ 所学校学生所走的距离和的最小值。

定义 $f_{i,j}$ 表示在 $i$ 到 $j$ 号楼之间，安置一所学校学生所走的距离和的最小值。那么就可以得出：
$$
dp_{i,j}= \min\{dp_{i,j},dp_{i-1,k}+f_{k+1,j}\} 
$$

那么怎么求 $f$ 数组呢？可以发现假设这 $n$ 栋楼分别有 $x_1,x_2,x_3,\cdots,x_n$ 个学生，那么最短距离就是：
$$
\sum_{i=1}^{n}x_i \cdot dis_{i,k}
$$
那么为了使得距离和最小，所以 $x_i$ 应该平均分配，所以使得 
$$
\sum_{i=1}^{k} x_i \text{ 与} \sum_{i=k+1}^{n} x_i \text{ 的差最小}
$$
找到这个 $k$ 之后，就可以将 $f$ 数组求出来了。

有了 $f$ 数组后，我们就可以求出 $dp$ 数组了。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[120],b[120];
int s1[120][120],s2[120][120];//s1[i][j]表示i到j的学生人数，s2[i][j]表示i到j的距离
long long f[120][120];\\f[i][j]表示在i到j之间安置一所学校学生所走的距离和的最小值
long long dp[120][120];\\dp[i][j]表示对前j栋楼来说，建造i所学校学生所走的距离和的最小值
int main()
{
	int n,m;
	cin>>n>>m;
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=2;i<=n;i++) cin>>b[i];
	for (int i=1;i<=n;i++)//计算学生人数区间
	{
		for (int j=i;j<=n;j++)
		{
			s1[i][j]=s1[i][j-1]+a[j];
		}
	}
	for (int i=1;i<=n;i++)//计算距离
	{
		for (int j=i+1;j<=n;j++)
		{
			s2[i][j]=s2[i][j-1]+b[j];
		}
	}
	memset(dp,0x3f,sizeof(dp));//赋极大值（用于找极小值）
	memset(f,0,sizeof(f));//清空
	for (int i=1;i<=n;i++)
	{
		for (int j=i;j<=n;j++)
		{
			for (int l=i;l<=j;l++)
			{
				if (s1[i][l]<s1[l+1][j]) continue;//找两边学生人数差最小的中点
				for (int k=i;k<=l;k++) f[i][j]+=a[k]*s2[k][l];
				for (int k=l+1;k<=j;k++) f[i][j]+=a[k]*s2[l][k];
//计算最短距离
				break;
			}
		}
	}
	for (int i=1;i<=n;i++) dp[1][i]=f[1][i];//初始化
	for (int i=2;i<=m;i++)
	{
		for (int j=i;j<=n;j++)
		{
			for (int l=i-1;l<=j-1;l++)
			{
				dp[i][j]=min(dp[i][j],dp[i-1][l]+f[l+1][j]);//状态转移方程
			}
		}
	}
	cout<<dp[m][n];//输出
}
```

---

## 作者：cyntmeay (赞：1)

## 题目大意
共有 $n$ 栋楼房需要选择 $k$ 个点使得在楼里面的所有学生到学校的距离最小。

## 题目思路
我们先来考虑一个简化版的问题，如果每个楼房的学生数量一样多并且只能选择一个楼房使得所有小学生的上学距离最小，很容易发现一定是选择中间的点建立小学最合适。我们回到原本的问题，当前 $i-1$ 栋楼房里的学生数量比第 $i$ 栋到第 $n$ 栋楼房的学生数量更多时根据前面的结论得出因该建立在第 $i$ 栋房屋上建立学校，否则在 $i-1$ 的位置建立学校。

我们可以得出一个二维数组 $g_{i,j}$，代表第 $i$ 栋到第 $j$ 栋楼房最优的放置学校的位置。$g$ 数组可以通过前一段的推到求出。接下来我们定义动态规划的状态。定义 $dp_{i,k}$ 表示在前 $i$ 栋楼内建立 $k$ 所学校的最短距离。当 $k \le i$ 的情况发生说明每一栋建筑都可以建小学最短距离为 $0$；如果 $k=1$ 的情况发生说明之建立一所小学根据定义可以得出：
$$
dp_{i,k}=g_{1,i}
$$

接下来就是普通情况，可以按照最右边的学校对楼房里的学生来分类，如果是建在 $a_l$ 到 $a_i$ 间，那么得出的贡献是 $dp_{l-1,k-1}+g_{l,i}$。最后答案根据定义可以得出应该输出 $dp_{n,k}$。

有了状态转移方程代码不会难写这里不给出代码，如果只是为了看代码请移步到其他题解。

---

## 作者：FISH酱 (赞：1)

## 前置知识

你需要熟练掌握基础语法和动态规划。

## 思路讲解

题意已经很明确，这里不再过多解释。

我们可以使用 $dp[i][j]$ 表示前面 $j$ 栋楼建立 $i$ 所小学的情况下的最小路程和。

那么如何转移呢？我们分为两部分计算。先枚举一个中转点 $q$，第一部分是第 $1$ 栋楼到第 $q$ 栋楼建立 $i-1$ 所学校的最小路程和，第二部分是第 $q+1$ 栋楼到第 $j$ 栋楼建立一所学校的最短路程和，将两部分相加即可得到值。

本题的转移很好写，难点更多在于预处理的代码实现，细节较多需要小心编写，特别是循环结构。那么要预处理什么？我们分为三个部分，一是预处理区间内学生数，二是预处理两栋楼之间的路程，三是预处理区间内建立一所小学的路程总和。

## 代码展示

写的时候保持思路清晰，可以配合注释，避免因为过多嵌套和定义导致混乱，记得初始化。下面是我的代码：

```cpp
#include <bits/stdc++.h> // 万能头

using namespace std; // 命名空间

#define ll long long
#define ld long double
#define inf 0x3f3f3f3f
#define endl '\n'

int n,k; // 楼数、学校数
int s[107][107]; // 存储区间内学生数
int d[107][107]; // 存储两栋楼的距离
int school[107][107]; // 存储区间内建立一所小学的路程总和
int dp[107][107]; // dp数组

int main(){
	memset(dp,inf,sizeof(dp)); // 初始化为极大值
	cin >> n >> k; // 读入变量
	
	for(int i=1;i<=n;i++){
		int ls;cin>>ls; // 读入每栋楼的学生数
		for(int j=i;j>=1;j--){
			s[j][i] = s[j][i-1]+ls; // 预处理区间内学生数
		}
	}
	
	for(int i=2;i<=n;i++){
		int ls;cin>>ls; // 读入楼之间的距离
		for(int j=i-1;j>=1;j--){
			d[j][i] = d[j][i-1]+ls; // 预处理两栋楼之间的路程
		}
	}

  // 预处理区间内建立一所小学的最短路程和
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			for(int q=i;q<=j;q++){ // 枚举中转点
				if(s[i][q]>=s[q+1][j]){ // 必须是第一部分人数大于等于第二部分人数
					for(int o=i;o<=q;o++) school[i][j]+=s[o][o]*d[o][q]; // 累加第一部分
					for(int o=q+1;o<=j;o++) school[i][j]+=s[o][o]*d[q][o]; // 累加第二部分
					break;
				}
			}
		}
	}
	for(int i=1;i<=n;i++) dp[1][i]=school[1][i]; // 初始化dp数组

  // dp求解，注意转移方法
	for(int i=2;i<=k;i++){
		for(int j=i;j<=n;j++){
			for(int q=i-1;q<j;q++) dp[i][j] = min(dp[i][j],dp[i-1][q]+school[q+1][j]); // 求解
		}
	}
	
	cout << dp[k][n]; // 输出答案

    return 0; // 完结撒花！
}
```

---

## 作者：ingo_dtw (赞：1)

# P2803 学校选址 II
## 题目思路
以第 $1$ 个楼的位置作为坐标原点，设第 $i$ 个楼的位置为 $d_i$。容易证明，如果要在 [ $d _{i−1}$，$d_i$] 中选一个地方放学校，则该学校最优位置一定是两个端点其一处。当前 $i-1$ 个大楼的总学生数大于第 $i$ 到 $n$ 个大楼的总学生数的时候，显然要选 $d_i$ 处建学校；如果小于，则在 $d_{i-1}$ 处建学校；如果等于，则两个点都可以。

我们可以预处理一个二维数组 $g$，表示只考虑第 $i\sim j$ 的楼的学生的时候，最优的放置学校的位置。$g$ 是很容易求出的。再定义 $f_{i,k}$ 为在前 $i$ 个楼的范围内建 $k$ 个学校的情况下，最小的总距离和是多少。那么，如果 $k\ge i$，则 $f_{i,k}=0$；如果 $k = 1$，即只建一个学校，则根据定义，$f _{i,k} = g_{1,i}$；剩余情况，可以按最右边的那个学校服务哪些楼的学生来分类，如果是建在 $d_{l} \sim d_i$ 之间（并且也服务这些学生），那么最小总距离为 $f_{l-1,k-1}+g_{l,i}$。最后输出 $f_{n,k}$
## Ac Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()
template <class T>inline T read()
{
	T r=0,f=1;char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-') f=-1;c=getchar();
	}
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f*r;
}
inline void out(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=110;
int n,K;
int dis[N];
int g[N][N],f[N][N],w[N];
signed main() 
{
  	n=_,K=_;
  	for(int i=1;i<=n;i++) 
	{
    	int x=_;
    	w[i]=w[i-1]+x;
  	}
  	for(int i=2;i<=n;i++) 
	{
    	int x=_;
    	dis[i]=dis[i-1]+x;
	}
	for(int i=1;i<=n;i++)
	{
    	for(int j=1;j<=i;j++) 
		{
	      // 找到只考虑第j到第i个楼的情况下，学校放哪里总距离和最小
	      	int k;
	      	for(k=j;k<=i;k++)
	      	{
	    		if(w[k]-w[j-1]>=w[i]-w[k]) break;
	    	}
	      	k=min(k,i);
	      	for(int l=j;l<=i;l++)
	      	{
    	  		g[j][i]+=abs(dis[k]-dis[l])*(w[l]-w[l-1]);
    	  	}
    	}
    }
  	memset(f,0x3f,sizeof(f));
  	for(int i=1;i<=n;i++)
  	{
    	for(int j=1;j<=K;j++) 
		{
    	  	if(j>=i) f[i][j]=0;
    	  	else if(j==1) f[i][j]=g[1][i];
    	  	else 
		  	{
    			for(int l=1;l<=i;l++)
    			{
    		    	f[i][j]=min(f[i][j],f[l-1][j-1]+g[l][i]);
    		    }
    		}
    	}
    }
	out(f[n][K]);
	return 0;
}
```

---

## 作者：U•ェ•*U (赞：1)

[我的CSDN原文地址（转载请标明作者）](https://lsm2024.blog.csdn.net/article/details/137514836)
## 思路
不妨考虑使用最短路径（动态规划 $+$ 递推）解决这个问题。

首先，设定第 $1$ 个楼的位置作为坐标原点，第 $i$ 个楼的位置表示为 $d_i$。通过逻辑推理，我们可以得出，如果在 $d_{i-1}$ 和 $d_i$ 中选择一个地点建立学校，那么最优的学校位置一定是这两个端点中的一个。具体地：

- 当前 $i - 1$ 个大楼的总学生数大于第 $i$ 到 $n$ 个大楼的总学生数时，选择 $d_i$ 处建学校；
- 如果小于，则选择 $d_{i - 1}$ 处建学校；
- 如果等于，两个点都可以作为学校的位置。

#### 利用平面直角坐标系的知识

预处理一个二维数组 $g_{i,j}$，表示只考虑第 $i$ 到第 $j$ 个楼的学生时，放置学校的最优位置。

再定义一个动态规划数组 $f_{i,k}$，表示在前 $i$ 个楼范围内建立 $k$ 个学校时，可达到的最小总距离和。

- 当 $k \geq i$ 时，$f_{i,k} = 0$（即，学校数量足够多，可以每个楼都建一个学校，没有距离成本）；
- 当 $k = 1$ 时，$f_{i,k} = g_{1,i}$（即，只建一个学校时，选择范围内最优位置）；
- 在其他情况下，考虑最后一个学校覆盖的楼房范围。如果是建在 $d_l$ 到 $d_i$ 之间，则最小总距离为 $f_{l-1, k-1} + g_{l, i}$。

因此，动态规划的转移方程为：

$$
f_{i,k} = \min_{l = 1}^{i} \left( f_{l-1, k-1} + g_{l, i} \right)
$$

最终结果即为 $f_{n, K}$，表示在所有楼中建立 $K$ 个学校时的最小总距离和。

-------

通过这种方式，我们可以系统地将问题分解为可管理的子问题，通过计算每个子问题的最优解并将这些解逐步合并，最终得到整个问题的最优解。

## 代码（有注释）：
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110; // 定义常量N作为楼房数量和学校数量的最大值
int n, K;          // n代表楼房的数量，K代表要建立的学校的数量
int dis[N];        // dis数组存储从第一个楼房到当前楼房的总距离
int g[N][N], f[N][N], w[N]; // g数组存放子问题最优情况下的最小总距离和
                            // f数组用于动态规划，记录考虑前i座楼房建j所学校的最小总距离和
                            // w数组存放每个楼房人数的前缀和

int main() {
  // 读入楼房数量和需要建立的学校数量
  scanf("%d%d", &n, &K);
  // 初始化第0座楼房的累计人数为0
  w[0] = 0;
  // 循环读入每座楼房的人数，并计算累计人数
  for (int i = 1; i <= n; i++) {
    int x;
    scanf("%d", &x);
    w[i] = w[i - 1] + x;
  }
  // 初始化第1座楼房的累计距离为0
  dis[1] = 0;
  // 循环读入相邻楼房之间的距离，并计算每座楼房的累计距离
  for (int i = 2; i <= n; i++) {
    int x;
    scanf("%d", &x);
    dis[i] = dis[i - 1] + x;
  }

  // 计算g数组中每个子问题的最优解
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++) {
      // 确定放置学校的最优位置
      int k;
      for (k = j; k <= i; k++)
        if (w[k] - w[j - 1] >= w[i] - w[k]) break;
      k = min(k, i);

      // 计算j到i所有楼房到学校k的距离和
      for (int l = j; l <= i; l++)
        g[j][i] += abs(dis[k] - dis[l]) * (w[l] - w[l - 1]);
    }

  // 初始化动态规划数组f，填充一个较大的数（表示距离无穷大）
  memset(f, 0x3f, sizeof f);
  // 动态规划计算至最多n座楼房，建立至多K座学校的最小总距离和
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= K; j++) {
      if (j >= i) f[i][j] = 0; // 学校数量不少于总楼房数，每座楼配一个学校，距离和为0
      else if (j == 1) f[i][j] = g[1][i]; // 只建一个学校的情况，距离和直接取g数组对应值
      else {
        // 枚举可能的学校位置，通过子问题的最优解更新当前问题的最小距离和
        for (int l = 1; l <= i; l++)
          f[i][j] = min(f[i][j], f[l - 1][j - 1] + g[l][i]);
      }
    }

  // 输出从1到n座楼房，建立K所学校的最小总距离和
  printf("%d\n", f[n][K]);
}
```

---

## 作者：ZY_king_YB (赞：0)

[传送门](https://www.luogu.com.cn/problem/P2803)

题意：数轴上有 $n$ 个点 $A_1\sim A_n$，$A_i$ 的权为 $w_i$，求 $k$ 个点 $B_1\sim B_k$，使得 $\sum w_i|A_iB_i|$ 最小。

设第 $1$ 个楼的位置为原点 $O$，第 $i$ 个楼的位置为 $d_i$。

易得：若在区间 $[d_{i-1},d_i]$ 中选择一个地点建立学校，那么最优的学校位置一定是 $d_{i-1}$ 和 $d_i$ （端点值）中的一个。

具体地，设 $s=\sum\limits_{j=1}^{i-1}w_j$，$t=\sum\limits_{j=i}^{n}w_j$。

- 若 $s>t$，在 $d_i$ 处建学校；

- 若 $s<t$，在 $d_{i-1}$ 处建学校；

- 若 $s=t$，$d_i$ 和 $d_{i-1}$ 处均可建学校。

预处理一个二维数组 $\{g_{i,j}\}$，表示当只考虑 $[i,j]$ 楼区间的 $w$ 时，放置学校的最优位置。

然后设 $res=\{\sum s_i\}_{min}$。

再定义一个 DP 数组 $\{dp_{i,k}\}$，表示在 $[1,i]$ 楼区间内建立 $k$ 个学校时，可达到的 $res$。

- 当 $k\geq ki \geq i$ 时，$dp_{i,k}=0$（即：学校数量足够多，可以每个楼都建 $1$ 个学校，无距离代价）；

- 当 $k=1$ 时，$dp_{i,k}=g_{1,i}$（即：只建 $1$ 个学校时，选择范围内最优位置）；

- 在其他情况下，看最后一个学校覆盖的楼房区间。如果是在 $[d_l,d_i]$ 内，则 $res=(dp_{l-1, k-1}+g_{l,i})$。

$\therefore$ 状态转移方程为：

$$dp_{i,k} = \min\limits_{l = 1}^{i} \left( dp_{l-1, k-1} + g_{l,i} \right)$$

最终结果为 $dp_{n,k}$，表示在所有楼中建立 $k$ 个学校时的 $res$。

---

## 作者：ChuYilin2011 (赞：0)

***声明：本题解思路并非原创，只是在已有题解上进行进一步的说明。***

首先，学校一定在楼的位置。如果学校在第 $i$ 和第 $i+1$ 栋楼之间，那么将学校移到第 $i$ 或第 $i+1$ 栋楼一定不劣于原先，具体在其他题解中都有证明。明白这点后，就可以考虑 DP。设 $f_{i,j}$ 表示到第 $i$ 栋楼，已经建了 $j$ 所学校。又设 $g_{l,r}$ 表示如果在第 $l$ 栋和第 $r$ 栋楼之间建一所学校，那么在这个范围内所有学生到学校的最小距离和。

对于 $f_{i,j}$：

1. $j=1$，那么就是 $g$ 的定义，$f_{i,j}=g_{1,i}$。
1. $i=0$，没有一栋楼，就没有一个学生，$f_{i,j}=0$。
1. $i\le j$，那么可以直接在每栋楼上建至少一所学校，每个学生到学校的距离都是 $0$，那么 $f_{i,j}=0$。
1. 其余情况，设前 $j-1$ 所学校建在第 $1$ 至第 $m$ 栋楼之间，第 $j$ 所学校建在第 $m+1$ 至第 $i$ 栋楼之间，此时 $f_{i,j}=f_{m,j-1}+g_{m+1,i}$。再取最小值即可。

最终答案即 $f_{n,k}$。然后就是预处理 $g$ 数组了。可以暴力算，但是嘛……

![](https://cdn.luogu.com.cn/upload/image_hosting/jvdo216q.png)

> 当 $a\le p\le b$ 时，$|p-a|+|p-b|$ 取到最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/199ot381.png)

> 当 $p=c$ 时，$|p-a|+|p-b|+|p-c|$ 取到最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/941kmzvd.png)

> 若 $n$ 为奇数，则当 $p=a_{\frac{n+1}2}$ 时，$\sum_{i=1}^n|p-a_i|$ 取到最小值。
>
> 若 $n$ 为偶数，则当 $a_{\frac n2}\le p\le a_{\frac n2+1}$ 时，$\sum_{i=1}^n|p-a_i|$ 取到最小值。

回到这题，我们发现可以将每个学生（注意不是楼）看作点，那么上面的 $n$ 就是学生总数。依此计算出上面的 $p$ 的值，然后代入计算此时的总距离，就可以将 $g$ 数组求出来了。求解 $g$ 数组参考代码如下：

```cpp
//sa是学生人数前缀和，sd是距离前缀和
for(int l=1;l<=n;l++)
  for(int r=l;r<=n;r++){
    int ss=(sa[r]-sa[l-1]+1)/2,i;
    for(i=l;i<=r;i++)
      if(sa[i]-sa[l-1]>=ss)
        break;
    for(int j=l;j<=r;j++)
      g[l][r]+=abs(sd[i]-sd[j])*a[j];
  }
```

至于 DP 代码嘛，~~式子都有了还不会写啊~~。

---


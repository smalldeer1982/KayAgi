# 宋荣子的城堡

## 题目描述

saruka 有一座大大的城堡！城堡里面有 $n$ 个房间，每个房间上面都写着一个数字 $p_i$。有一天，saruka 邀请他的小伙伴 LYL 和 MagHSK 来城堡里玩耍，他们约定，如果某一个人当前站在 $i$ 号房间里，那么下一步他就要去 $p_i$ 号房间，在下一步就要去 $p_{p_i}$ 号房间。

为了增加趣味性，saruka 决定重新书写一下每个房间的 $p_i$，以满足：

- 如果从编号为 $1 \sim k$ 的某个房间走，按照规则走，必须能走回 $1$ 号房间。特别的，如果从 $1$ 号房间开始走，也要走回 $1$ 号房间。（至少走一步，如果 $p_1 = 1$，从 $1$ 走到 $1$ 也算合法）。

- 如果从编号大于 $k$ 的房间开始，按照规则走，一定不能走到 $1$ 号房间。

saruka 想知道，一共有多少书写 $p_i$ 的方案可以满足要求，答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 10 ^ {18},1 \le k \le \min(n,8)$。

## 样例 #1

### 输入

```
5 2```

### 输出

```
54```

## 样例 #2

### 输入

```
7 4```

### 输出

```
1728```

# 题解

## 作者：zzw4257 (赞：7)

![](http://61.164.108.157:8080/uploads/pic/20180331/1522488228680.jpg)
如果没有思路，首先来看一下这道题的数据范围
$$n<={10^{18} }$$
那么O(n),甚至$$O(sqrt(n))$$都是不行的
那么我们就要来思考接近O(1)的算法

    我们来审一审题
    每个房子i都有对应的pi，是这个房间的后续
    也就很类似于链表的结构，每个房间都有指向的下一个房间
    求有多少种pi的排列顺序使得从前k个房子出发后都能到达1号
    而除去这k个房子之外的房子都不能到达1号
    但其实我们举一个小例子就会发现：
 ![](http://61.164.108.157:8080/uploads/pic/20180331/1522489702514.jpg)
    如果有两个相通的房间，能么第三者最终只有能同时到达两者或不能到达两个房间一种取pi的结果
    
   其实pi作为着i和pi的联系，1号房间能被到达也即px=1，又因为前k个房间（由题包含1号）都作为前续取了px或能到达px的后缀
     
   又因为px包含1，也即px={1,2,3,4...k}每个元素都作为另外的k-1个元素的后缀
    
   那么对这k个元素，每个元素都要作为另一个元素的前续，那么他们必定是相连的而且都最终指向1
    
   因此不妨称前k各元素出现的现象为一个循环，它们都在这个循环里；
    
   但又应除去这k个房子之外的房子都不能到达1号这个条件所以这个循环内又不能有除去这k个房子之外的房子
    
   所以总体来看整个城堡就被分成两块
    
 ![](http://61.164.108.157:8080/uploads/pic/20180331/1522490084963.jpg)
   
   而两边各自的方案都是可以算出来的
   
   一边是k个房间都能到达一
   
   所以最后一步只有一个选择
   
   前面的k-1个选择都随便
   
   所以是$k^{k-1}$
   
   另一边是n-k个随便走都不影响
   
   所以是${(n-k)}^{n-k}$
   
   答案就出来了是$k^{k-1}*{(n-k)}^{n-k}$
   
   但是呢由于n太大所以要用快速幂
   
   以此敬上


---

## 作者：NaVi_Awson (赞：4)

下面好像没有说数学公式的推导和证明，似乎还不怎么简单...或许是我太弱了...

博客也有详解，欢迎来踩：[菜鸡NaVi\_Awson的博客](http://www.cnblogs.com/NaVi-Awson/p/7656237.html)

很显然这道题我们要分治考虑，即分为$[1,k]$和$[k+1,n]$两个区间的点来计算。

首先我们很容易的知道后面这个区间的个数是${(n-k)}^{n-k}$，因为后面的点不能与$[1,k]$的点连，并且可以随便连，不用管是否连通。

那么我们现在考虑前面的$k$个点。我们想：首先这个图是一个典型的基环内向树，既然所有的点都能到达$1$号点，那么这个$1$号点肯定在基环上，并且整个图都是连通的。

我们来考虑这个问题：怎样构成这个图呢？

我们先假设只有$n-1$条边，那么使图要连通的话，显然构成了一棵树且根节点为$1$；因为边是有向的，显然所有边的方向是从儿子节点到父节点。

现在我们加上忽略的这条边，显然我从$1$号根节点连向任意一个节点都是可以的（包括根节点）。

我们拓展到一般的情况如果$1$号点不一定是根节点：那么我们只要把根节点连向$1$号点的位置就可以了。

我们得出这样一个结论：只要构成了一棵树，我都有方法使它满足条件，并且无论根节点是什么。并且我们能够得到，一个无向树确定了根节点，我都有办法确定方向使它们指向根。

带编号的点的无根生成树我们想到了$Cayley$公式，不知道的可以戳我之前写的一篇博客：[->戳我<-](http://www.cnblogs.com/NaVi-Awson/p/7631762.html)

我们可以得到$n^{n-2}$棵无根树，并且我所有的点都可以确立为根，那么在每种形态下，我又有了$n$个版本。

那么前一部分的方案数就是$k^{k-1}$。

根据乘法原理：最终答案就是$k^{k-1}*{(n-k)}^{n-k}$。




```cpp
//It is made by Awson on 2017.10.12
#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <cmath>
#include <stack>
#include <queue>
#include <vector>
#include <string>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define LL long long
#define Min(a, b) ((a) < (b) ? (a) : (b))
#define Max(a, b) ((a) > (b) ? (a) : (b))
#define sqr(x) ((x)*(x))
using namespace std;
const LL MOD = 1e9+7;
LL n, k;
LL quick_pow(LL a, LL b) {
  LL sum = 1;
  a %= MOD;
  while (b) {
    if (b&1) sum = sum*a%MOD;
    b >>= 1;
    a = a*a%MOD;
  }
  return sum;
} 
void work() {
  scanf("%lld%lld", &n, &k);
  LL ans1 = quick_pow(k, k-1);
  LL ans2 = quick_pow(n-k, n-k);
  printf("%lld\n", ans1*ans2%MOD);
}
int main() {
  work();
  return 0;
}

```

---

## 作者：Haphyxlos (赞：2)

# P2817 宋荣子的城堡
[题目传送门](https://www.luogu.com.cn/problem/P2817)

## 思路
将这n个房间分为两块，分别是$[1 \sim k]$和$[k+1\sim n]$两部分。

### 对于前一个区间$[1 \sim k]$

然后，我们生成一棵树，且将根结点连向$1$号节点即可。

那么，本题就变为了求无根生成树的方案数。

而求无根生成树则要用到$Cayley$公式。

$Cayley$公式：

在一个完全图$K_n$中有$n^{n-2} $棵生成树，即n个节点的有编号的无根树有$n^{n-2} $个。

而$Cayley$公式的证明则有些麻烦，需要用到$Prüfer$编码，这里就留给读者自行学习啦。

回到本题，再得到$k^{k-2}$之后，我们可以发现本题中的每个点都可以被确定为根结点，所以还要乘上$k$，故前一个区间的答案数$ans_1=k^{k-2}\times k=k^{k-1}$。

### 对于后一个区间$[k+1\sim n]$

很显然，后一个区间的点只要不与前一个区间的点相连，其他都可以。故，后一个区间的答案数$ans_2=(n-k)^{(n-k)}$。

所以，对于本题的总方案数$ans=ans_1 \times ans_2 = k^{k-1} \times (n-k)^{(n-k)}$。

然后记得还要对$10^9+7$取模。

又因为本题的数据较大，所以$ans$需要用快速幂来求。

本题代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const double eps=1e-8;
const int INF=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=1e6+5;
ll n,k;
inline ll qpow(ll a,ll b,ll res=1){
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
int main(int argc,char const *argv[]){
	std::ios::sync_with_stdio(false);
	cin>>n>>k;
	cout<<qpow(k,k-1)*qpow((n-k)%mod,n-k)%mod;
//注意本题的底数n-k较大需要先取模，又因为n≥k，所以直接模
	return 0;
}
```

本篇题解就到此结束了，如果喜欢，还请点个赞吧。

---

## 作者：war1111 (赞：2)

P2817 宋荣子的城堡

一道找规律的题，现在深入追究发现了有趣的东西。

1 1
2 2
3 9
4 64
显然k^(k-1) 在日照的时候也推出来了。

3 9今天推错了，要列出所有的情况，然后再选，否则会漏掉。

答案是(k^(k-1)) \* ((n-k)^(n-k))

对了，我卡速米一直打的是错的。要对指数为0的情况特判，不然会死循环。


现在，告诉我，why?


cayley定理（凯莱定理）

对于有n个节点，生成树的方案有多少种?

答案是n^(n-2)

推导过程如下:

k表示现在有多少子树

显然初始时，k==n

现在从n个节点中任选1个，有C(n 1)种可能，再从不包含这个节点的子树中选1个子树和这个节点连起来，有C(k-1 1),然后子树减少一个。重复这个过程直到，子树只剩1个，乘法原理，(n^(n-1))\*(n-1)!。

假定每次都是（从n个节点中任选1个）选的同一个，并把它设成根，想象一下，对于同一棵树这就考虑了每个节点是根的情况。

有n-1条边，不考虑加进来的顺序，所以再除（n-1）!,现在成了n^(n-1)，在一棵树中，根节点是哪个都无所谓，再除n，就成了


n^(n-2)。

但是对于这个题而言，可以假定1连向的点为根节点，实际上把它的每个点当成根节点都会形成新的方案，所以再\*k

故答案 k^(k-1)

















---

## 作者：lmrttx (赞：2)

这题的 $n$ 真的~~好大啊~~。

所以不可能乱搞的，乱搞是不可能的，这辈子都不可能的。

于是猜测到要颓柿子。

首先，区间分为 $[1,k],[k+1,n]$。

我们先解决后一个区间。

后一个区间的要求是不能连到第一个区间。

不然最终是一定可以走到1的，对吧？

那么只要**在后一个区间内自己连自己**，就可以保证一定不会走到第一个区间，这样子是符合题目要求的。

**所以后一个区间的方案数是 $(n-k)^{n-k}$。**

套一个快速幂就行了，不过有一点注意一下。

题目说：
>1 <= k <= min(8，n)

为什么要定义这个呢？

其实是为了告诉我们，**$n-k$ 很大**（好像只有我一人提到了 $n-k$ 很大呀）。

根据有取模的快速幂的定义，我们**把底数先取模不影响结果**。

所以底数要取模。

现在回到第一个区间。

这里说一种很好理解的解释：

区间1可以当成一个**无根树**（从任何节点出发，都可以走到树上的某个点--1，此时这个出发点当作根），而**有 $n$ 个节点的有编号的无根树有 $n^{n-2}$ 种构建**（Cayley公式）。

又因为每个点都可以作为根，所以还要乘上个 $k$。

**答案为：$k^{k-2}*k=k^{k-1}$。**

没错吧？

然后代码随便写写就过了。

两个区间相乘可以先模一下，不模也能过就是。

加了防复制的AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,k;
const ll mod=1e9+7;
ll qpow(ll a,ll b,ll mod){
	ll res=1;
	while(b){
		if(b&1) {res=res*a%mod;}
		a=a*a%mod;b>>=1;  
	}
	return res;
}//快速幂
int main(){
	scanf("%lld%lld",n,k);
	printf("%lld",qpow(k,k-1,mod)%mod*qpow((n-k)%mod,n-k,mod)%mod);
	return 0;
}
```

写得还算简单易懂且详细吧？

不懂可以问我qwq，谢谢阅读！

---

## 作者：FreedomKing (赞：1)

### 思路

通过乘法原理将答案拆成两部分的积分开讨论。

- 对于 $i\in[1,k]$，显然题目要求的是构造一颗[基环内向树](https://oi-wiki.org/graph/concept/#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9B%BE)，而一颗基环内向树可以看做是一颗无根树加上一条边，这里要节点 $1$ 连向任意一条 $[1,k]$ 的边。根据 [Cayley](https://oi-wiki.org/graph/prufer/#cayley-%E5%85%AC%E5%BC%8F-cayleys-formula) 公式，得到答案 $k^{k-2}\times k=k^{k-1}$。

- 对于 $i\in[k+1,n]$，每一条边都可以在点集内随便连，答案为 $(n-k)^{n-k}$。

所以最终答案就是 $k^{k-1}\times (n-k)^{(n-k)}$。

### AC Code

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize("Ofast")
bool M1;
#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<" MB\n"
#define look_time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\n'
#define File(_) freopen(_".in","r",stdin);freopen(_".out","w",stdout)
#define int long long
using namespace std;
const int N=5e7+9e5,mN=4e3+5,mod=1e9+7;
#define Time 0
#define lowbit(_) (_&-_)
#define lc (p<<1)
#define rc (p<<1|1)
inline int qread(){
#define qr qread()
	int x=0,c=getchar(),t=1;
	while(c<'0'||c>'9'){
		t^=(c=='-');
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return (t?x:-x);
}	
inline void qwrite(int x){
#define qw(_) qwrite(_)
#define qws(_) qw(_),putchar(' ')
#define qwe(_) qw(_),putchar('\n')
	if(x<0) x=-x,putchar('-');
	if(x>9) qwrite(x/10);
	putchar(x%10+'0');
	return;
}
inline int qpow(int x,int p,int mod){
	mod=(mod?mod:LONG_LONG_MAX);
	x=(p?x:1)%mod;
	int t=1;
	while(p>1){
		if(p&1) t=(t*x)%mod;
		x=(x*x)%mod;
		p>>=1;
	}
	return (x*t)%mod;
}
inline int gcd(int x,int y){return (x%y==0?y:gcd(y,x%y));}
inline int lcm(int x,int y){return (x/gcd(x,y)*y);}
#define pf(_) ((_)*(_))
bool M2;signed main(){
	int n=qr,k=qr;
	qw((qpow(k,k-1,mod)*qpow(n-k,n-k,mod))%mod);
	return 0;
}
```

---

## 作者：lcy09 (赞：1)

### 分析
从题面来看，一道数学题。

把城堡分成了两块，一块是从1号到k号房间，另一块是从k+1号到n号房间。

很明显，后面那块只要不连到前面那块就行，所以就可以自行瞎连，方案数
(n-k)^(n-k).

至于前面那块，基本思路是建一棵树，把根节点指向1号节点，就达到了目的。所以接下来的问题就变成了总共有多少种建树方法。在此，引用[Cayley公式](https://lcy9.blog.luogu.org/cayley)，得出结果为k^(k-2),而又由于在这个问题中哪个点作为根节点同样影响答案，所以再乘上k，即k^(k-1).此方案数与前面所的方案数相乘，即为答案。

鉴于数据范围，这里需要用到快速幂。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
ULL mod=1e9+7;
ULL n,k;
ULL ans;
ULL power(ULL x,ULL y)
{
    ULL r=1;
    if(y==0) return 1;
    else if(y&1)
        return ((x%mod)*(power(x,y-1))%mod)%mod;
    else
    {
        ULL num=power(x,y/2)%mod;
        return ((num%mod)*(num%mod))%mod;//数据实在太大，所以每步都要取模运算
    }
}
int main()
{
    cin>>n>>k;
    ULL t=n-k;
    ans=power(t,t)%mod;
    ULL temp=power(k,k-1)%mod;
    ans*=temp;
    ans%=mod;
    cout<<ans<<endl;
    return 0;
}
```
**时间复杂度**

O(logn)

注：鉴于n实在是大，不开long long见祖宗。


---

## 作者：gyfer (赞：1)

-1. n<=8

直接爆搜每个点的出边指向谁，然后检查即可。

-2.n<=10^5

我们发现，前k个点肯定和前k个点互相连边。后n-k个点肯定不会连到前k个点里面去。

所以，我们只要爆搜前k个点连接的方案，然后检查；后n-k个点，只要连的是后n-k个点，随便连，方案数是(n-k)^(n-k)。最后把两部分方案数乘起来就行。

-3.n<=10^18

(n-k)^(n-k)怎么算呢，

快速幂即可。

```cpp
LL ksm(LL a,LL p) {//a是底数，p是指数
   LL cj=1;
    a%=mod;
    for(;p;p>>=1,a=a*a%mod){
         if(p & 1)cj=cj*a%mod;
    }
    return cj;
 }
```
剩下可以打表(<P的情况）
但还是用dfs加检查

```cpp
bool check(){
 bool sou[10],sous[10];
  memset(sou,false,sizeof(sou));
  int now=1;
  while(!sou[now]){
    sou[now]=true;
    now=b[now];
  }
      if (now!=1) return false;//必须回到1
    for (int i=1;i<=k;i++)
         if (!sou[i]) {
            memset(sous,false,sizeof(sous));
             int now=i;
             while (!sous[now] && !sou[now]) {
                 sous[now]=true;
                 now=b[now];
            }
             if (!sou[now]) return false;//防止多次访问1
         }
 return true;
}
void dfs(int x){
    if(x==k+1){
            if(check()) ans++;
        return;
    }
    for(int j=1;j<=k;j++) {//枚举边
            b[x]=j;
            dfs(x+1);
    }
}
```
剩下主程序
```cpp
int main(){
  scanf("%lld%d",&n,&k);
  dfs(1);
   ans=ans*ksm(n-k,n-k)%mod;
  printf("%lld\n",ans);
}
```

---

## 作者：长安忆 (赞：1)

#**思路:**

##①这是一道数论题，只需要根据排列组合推出来数学公式，然后用快速幂搞一搞即可（因为范围很大嘛~）

##②在前k个点方案数的寻找中，也可以使用搜索


#**公式：**


　　#ans=ksm(k,k-1)%Mod \* ksm(n-k,n-k)%Mod;

#**坑点:**

##一、我怎么知道这个公式啊啊啊!!!

##所以需要手动推导一下!!!

###①ksm(k,k-1)

              - k==1的时候

- 只有一种情况：1 —> 1

             - k==2的时候

- 只有2种情况：1 —> 2 ，2 —> 1

             - k==3的时候

- 情况稍微多一点： 我们这里用一个表格来进行演示！

- 唔，怎么粘表格qwq

###②ksm(n-k,n-k)

- 因为题目中提到除那k个点之外，其他点不能够连到1，而又因为k个点每个点都必须能够走到1，这即是说明后n-k个点不能够连到k个点，所以他们能够胡乱连，只要不到k个点即可，

- 所以方案数为ksm(n-k,n-k);

- （因为每个点都有n-k种选择）

###③至于为什么要%Mod

- 对此我只能说：题目要求。。。。


#二、在搜索的时候数组一定不要开到8就算了，会T掉....

- 所以要开到9！！

- 看似数据中存在k==9的情况qwq ，因为我开到8后T了3个点，但是多加了一个之后就A了。。。

###**上代码:**

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define LL long long
using namespace std;

const int Mod = 1e9 + 7;
const int Maxk = 10;
LL n,k,ans;
int pi[Maxk];

inline LL read(LL &AC)
{
    char ch=' ';LL x=0,f=1;
    for(; (ch!='-') && ((ch<'0')||(ch>'9')); ch=getchar());
    if(ch=='-') f=-1,ch=getchar();
    for(; ch>='0' && ch<='9'; ch=getchar()) x=x*10+ch-48;
    AC=x*f;    return AC;
}

inline LL ksm(LL a,LL p) {
    LL ret = 1;
    a%=Mod;
    for(; p; p>>=1, a=a*a%Mod)
        if(p&1)
            ret=ret*a%Mod;
    return ret;
}

inline bool check() {
    bool vis[Maxk];
    memset(vis,false,sizeof(vis));
    int now=1;
    while(!vis[now]) {
        vis[now]=true;
        now=pi[now];
    }
    ///从 1 出发必须能够回到 1  
    if(now!=1)
        return false;
    for(int i=1; i<=k; ++i) {
        if(!vis[i]) {
            bool vis2[Maxk];
            memset(vis2,false,sizeof(vis2));
            int now2=i;
            while(!vis2[now2] && !vis[now2]) {
                vis2[now2]=true;
                now2=pi[now2];
            }
            if(!vis[now2])
                return false;
        }
    }
    return true;
}

void dfs(int now) {
    if(now==k+1) {
        if(check())
            ans++;
        return ;
    }
    for(int i=1; i<=k; ++i) {
        pi[now]=i;
        dfs(now+1);
    }
}

int main() {
    read(n),read(k);
    dfs(1);
    ans=ans*ksm(n-k,n-k)%Mod;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Npse_D (赞：1)

夏令营水一道题……其实主要是用了排列组合的做法导出数学公式……这样k在10^18范围内可过……～

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define ll long long
ll n;
int k;
const int a=1000000007;
ll pow(ll x,ll y){
    ll r=1,base=x;
    while(y){
        if(y&1)r=r%a*(base%a)%a;
        base=base%a*(base%a)%a;
        y>>=1;}
    return r%a;}
int main(){
    cin>>n>>k;
cout<<pow(k,k-1)%a*pow(n-k,n-k)%a;}
```

---

## 作者：reductt (赞：0)

首先看到这个 $10^{18}$ 的数据范围，很显然可以想到要推柿子。

可以把这个问题分成两个部分来考虑，$[1,k]$ 和 $[k+1,n]$，显然，$[1,k]$ 中每一个都可以走到 $\text{1}$，但是 $[k+1,n]$ 中不能有任何一个连着 $[1,k]$ 中的点，所以这个区间的只能和本区间内的乱连，贡献即 ${(n-k)}^{n-k}$。

然后注意到 $k$ 的范围十分十分的小，所以 $[1,k]$ 这个区间内的直接爆搜，最后把两个的方案数乘起来就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
#define FOR(i,a,b) for(int i=a;i<=b;i++)
int rd(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||'9'<c){if(c=='-')f=-1;c=getchar();}
	while('0'<=c&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
void write(int x){
	int buf[40],p=0;
	while(x)buf[++p]=x%10,x/=10;
	while(p)putchar(buf[p--]+'0');
}
const int MOD=1e9+7,K=10;
int qpow(int x,int y){
	if(y==0)return 1;
	if(y==1)return x%MOD;
	int t=qpow(x,y/2);
	if(y&1)return t*t%MOD*x%MOD;
	return t*t%MOD;
}
int vis[K],p[K],ans=0;
int dfs(int x,int op){
	if(x==1&&op!=0)return 1;
	if(vis[x])return 0;
	vis[x]=1;
	int t=dfs(p[x],1);
	vis[x]=0;
	return t;
}
int check(int k){
	memset(vis,0,sizeof(vis));
	FOR(i,1,k)if(!vis[i])if(!dfs(i,0))return 0;
	return 1;
}
void dfs1(int x,int k){
	if(x>k){
		if(check(k))ans++,ans%=MOD;
		return;
	}
	FOR(i,1,k)p[x]=i,dfs1(x+1,k),p[x]=0;
}
signed main(){
	int n=rd(),k=rd();
	dfs1(1,k);
	ans*=qpow(n-k,n-k),ans%=MOD;
	write(ans);
	return 0;
}
```

---

## 作者：Rose_Melody (赞：0)

## Solution - P2817 宋荣子的城堡

[题目传送门](https://www.luogu.com.cn/problem/P2817)

### 题目分析

不妨看看 $n$ 的**数据范围**：$n \le 10^{18}$。（~~太可怕了吧~~）

我们考虑接近 $O(1)$ 的算法。

思路详见[@zzw4257 的博客](https://www.luogu.com.cn/article/upv0nom2)。

简单来说，就是一个简单的分治思想，一边是 $k$ 个房间都能到达 $1$，有 $k^{k - 1}$ 种；对于剩下的 $n - k$ 个房间随便走都不会产生影响，有 $(n - k)^{n - k}$ 种。

乘法原理，答案就出来了：
$$k ^ {k - 1} \times (n - k) ^ {n - k}$$

鉴于 $n$ 的数据范围，注意记得开 long long，用上快速幂。

### AC Code


```cpp
#include <bits/stdc++.h>
#define int long long 
#define double long double 
using namespace std;
const int Mod = 1e9 + 7 ;
int n , k , ans;
int power(int a , int b){ //快速幂
	int ret = 1 , base = a , c = b ;
	while(c){
		if(c & 1){
			ret *= base ;
			ret %= Mod ;
		}
		base *= base ;
		base %= Mod ;
		c >>= 1 ;
	}
	return ret ;
} 
signed main()
{
//	freopen("memory.in","r",stdin);
//	freopen("memory.out","w",stdout); 
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0); 
	cin >> n >> k ;
	ans = power(k , k - 1) * power((n - k) % Mod , n - k) % Mod ;//(n - k) 较大，先进行取模
	cout << ans ; 
	return 0;
}
```

---

## 作者：Eterna (赞：0)

可以看到数据范围非常大。

所以应该考虑相对简单的做法。

我们可以分别计算 $[1,k]$ 和 $[k+1,n]$ 这两段区间的方案数，然后合并答案。

对于 $[1,k]$ 这部分，显而易见，至少有一个 $p_i=1$。

其他 $k-1$ 个 $p_i$ 只要不大于 $k$ 就可以。

由此，我们推出这部分的答案是 $k^{k-1}$。

再看 $[k+1,n]$，要求不能走到 $1$ 号房。因为 $[1,k]$ 都可以走到 $1$ 号房，所以这部分问题变成了不走到 $[1,k]$ 的方案数，所以对于这部分的每个 $p_i$ 都可以选择 $k+1$ 到 $n$ 任意一个数。

我们可以简单得出答案：$(n-k)^{n-k}$。

合并答案用乘法，得：$k^{k-1}(n-k)^{n-k}$。

套一个快速幂模版就可以了。

###  code

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int fpow(int x,int y)
{
	if(y==0)return 1;
	if(y==1)return x;
	int z=fpow(x,y>>1)%mod;
	if(y&1)return (z*z)%mod*x%mod;
	return z*z%mod;
}
int n,k;
signed main()
{
	cin>>n>>k;
	cout<<fpow(k,k-1)*fpow((n-k)%mod,n-k)%mod;
	return 0;
}
```

---


# [TJOI2007] 迷路

## 题目背景

小 A 和小 B 在一个二维空间中迷路了，每个人在这个空间中都按照自己特定的路线行

走，由于他们的路线都是周期性的，因此你可以把这种路线理解为一种“轨道”：即一条封

闭的路线，路线的终点和起点重合，这样才能“周期”的行走。


## 题目描述

两个人行走的速度都是每秒一个单位距离，而且他们的路线都是平行于坐标轴的。基于

此，如果两个人无限的走下去，我们想知道他们每一秒相离最近的距离。（我们只考虑两人

在每秒行走后相离的距离，不考虑他们在这 1 秒内某个时刻的距离）


## 说明/提示

100%的数据中，对于任何 m 和 d，有 1 ≤ m, d ≤ 100，轨道的初始坐标的绝对值不超

过 2 000。


## 样例 #1

### 输入

```
0 0 4
-1 Y
-1 X
1 Y
1 X
1 0 4
-1 X
1 Y
1 X
-1 Y```

### 输出

```
1.00```

# 题解

## 作者：frank520 (赞：6)

## 又是鬼畜的学校考试题。。。

题目的样例太弱了，有手就能过，这导致了我的58分（自己懒得造数据。。。）
所以我们重新造一组数据，跟着数据来分析这道题

```cpp
0 	0 	4
-1 	Y 	
-2 	X 	
1 	Y 	
2 	X 	
3 	3 	6
-1 	X 	
2 	Y 	
1 	X 	
-2 	Y 	
1 	Y 	
-1 	Y 	
```



也就是把题目样例改了一下，但这样就可以让我们注意到主人公的**速度为1**，而并非d

![](https://cdn.luogu.com.cn/upload/image_hosting/xrlqas8r.png)

借助图我们来看看他们的运动轨迹

![](https://cdn.luogu.com.cn/upload/image_hosting/5ug8yjxd.png)

#### 我们可以直接模拟时间，这样在每一秒钟内去计算两人的距离，然后去它和ans的min即可

但如果每次输入的d不是1或-1怎么办呢？就可以把它拆开，拆成d个项，就像这样

```cpp
scanf("%d%c%c",&g[i].ad,&x,&g[i].az);
		if(abs(g[i].ad)!=1){
			int xx=g[i].ad/abs(g[i].ad);
			int cc=abs(g[i].ad);//数据会改变，所以中途定义一个变量储存 
			for(int j=i;j<=i+cc-1;j++){
				g[j].ad=xx;
				g[j].az=g[i].az;
			}
			i+=cc-1;
			am+=cc-1;//别忘了最后对am和i进行处理，因为你的项变多了 
		}
```


### 全篇的AC代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int find(int a,int b){
	int c=a%b;
	while(c!=0){
		a=b;
		b=c;
		c=a%b;
	}
	return b;
}
struct G{
	int ad,bd;
	char az,bz;
}g[10005];
int ax,ay,bx,by,am,bm,ft;//初始数据保留 ft就是最小公倍数，即枚举秒数 
char x;

int main(){
	double ans=0;
	scanf("%d%d%d",&ax,&ay,&am);
	for(int i=1;i<=am;i++){
		scanf("%d%c%c",&g[i].ad,&x,&g[i].az);
		if(abs(g[i].ad)!=1){
			int xx=g[i].ad/abs(g[i].ad);
			int cc=abs(g[i].ad);//数据会改变，所以中途定义一个变量储存 
			for(int j=i;j<=i+cc-1;j++){
				g[j].ad=xx;
				g[j].az=g[i].az;
			}
			i+=cc-1;
			am+=cc-1;//别忘了最后对am和i进行处理，因为你的项变多了 
		}
	}
	scanf("%d%d%d",&bx,&by,&bm);//b的输入与a相同 
	for(int i=1;i<=bm;i++){
		scanf("%d%c%c",&g[i].bd,&x,&g[i].bz);
		if(abs(g[i].bd)!=1){
			int xx=g[i].bd/abs(g[i].bd);
			int cc=abs(g[i].bd);
			for(int j=i;j<=i+cc-1;j++){
				g[j].bd=xx;
				g[j].bz=g[i].bz;
			}
			i+=cc-1;
			bm+=cc-1;
		}
	}
	ft=max(am,bm)/find(am,bm)*min(am,bm);//最小公倍数即模拟秒数；
	ans=sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));
	for(int i=1;i<=ft;i++){
		int ca=i%am,cb=i%bm;
		if(ca==0) ca=am;
		if(cb==0) cb=bm; //没有存g[0]，即模下来等于零就是第am/bm步 
		if(g[ca].az=='X') ax+=g[ca].ad;
		else ay+=g[ca].ad;
		if(g[cb].bz=='X') bx+=g[cb].bd;
		else by+=g[cb].bd;
		ans=min(ans,sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by)));//两点之间距离公式 
	}
	printf("%.2lf",ans);//输出两位 
	return 0;
}
```


## 感谢支持蒟蒻：）

---

## 作者：神眷之樱花 (赞：4)

## 14分错因
应该是看错了题，$d$ 是每个任务总共要走的路程，而两个人每秒只能走一个单位。
## 解析
因为这道题数据规模并不大，且测试点并不刁钻，所以我们可以直接暴力枚举。 

所以我们可以把每个任务拆分，将每秒两个人的坐标存储来。然后找出两人走完自己的周期分别所花时间的最小公数。也就是两人位置的周期，如一个人走 $4$ 次回到出发点，另一个人走 $6$ 次回到出发点（次数只能是偶数次，不然就回不去了，这点大家应该都懂吧）那么这两个人每 $12$ 秒的相对位置就会重复一次。
## 最小公倍数求法
```cpp
int gcd(int a,int b)
{
    return (b==0)?a:gcd(b,(a%b));//三目运算符。
}
```
先求出最大公因数，最小公倍数就是两个数的积与最大公因数的商，这点应该能自己证明吧，然后找出最小距离就行了。
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10005;
int ax[N],ay[N],bx[N],by[N];//分别存两人每个时刻的横，纵坐标。
double len[N],minn=1.0*1e9;
int gcd(int a,int b)
{
    return (b==0)?a:gcd(b,(a%b));
}
int main()
{
    int m1,m2,nb,len1=0,len2=0,m,XR;
    char ch;
    scanf("%d%d%d",&ax[0],&ay[0],&m1);
    for(int i=1;i<=m1;i++)
    {
        scanf("%d %c",&nb,&ch);
        XR=abs(nb);nb/=XR;//因为每秒只能走一步，把每一个d转换成d个一步。
        if(ch=='X') {while(XR){len1++;ax[len1]=ax[len1-1]+nb;ay[len1]=ay[len1-1];XR--;}}
        else if(ch=='Y') {while(XR){len1++;ay[len1]=ay[len1-1]+nb;ax[len1]=ax[len1-1];XR--;}}
    }
    scanf("%d%d%d",&bx[0],&by[0],&m2);
    for(int i=1;i<=m2;i++)
    {
        scanf("%d %c",&nb,&ch);
        XR=abs(nb);nb/=XR;
        if(ch=='X') {while(XR){len2++;bx[len2]=bx[len2-1]+nb;by[len2]=by[len2-1];XR--;}}
        else if(ch=='Y') {while(XR){len2++;by[len2]=by[len2-1]+nb;bx[len2]=bx[len2-1];XR--;}}
    }
    m=len1/gcd(len1,len2)*len2;//找出周期，暴力枚举。
    for(int i=1;i<=m;i++)
    {
        int xx=abs(ax[i%len1]-bx[i%len2]),yy=abs(ay[i%len1]-by[i%len2]);
        long long QAQ=xx*xx+yy*yy;
        if(QAQ<minn) minn=QAQ;
    }
    minn=sqrt(minn);
    printf("%0.2lf",minn);
    return 0;
}
```


---

## 作者：elainya_stars (赞：3)

# [P3843 [TJOI2007] 迷路](https://www.luogu.com.cn/problem/P3843)

## 思路
数据范围好小，题面好长，直接模拟。计算答案时模拟秒数，不能漏掉情况，模拟的秒数是 $a$ 的总秒数和 $b$ 的总秒数之间取最小公倍数，然后挨个计算距离取最小值。

距离公式：$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$

## 注意事项

**每个人每次（每秒）只能走一格！** 也就是说，如果输入的 $d > 1$ 或者 $d < -1$，就得把 $d$ 拆成 $d$ 个 $1$ 或 $d$ 个 $-1$。**每个点的总秒数也得重新计算。**

其它见代码注释。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

int asx,asy,am,bsx,bsy,bm;
struct xy
{
	int x,y;
}dira[10005],dirb[10005];
int ad,bd;
// dir记录每个点每次（每秒）移动的横纵坐标
// ad和bd记录更新后a和b的总秒数

signed main()
{
	scanf("%d%d%d",&asx,&asy,&am);
	for(int i=1;i<=am;i++)
	{
		int x;
		char c;
		cin>>x>>c;
		if(c=='X')
		{
			if(x>0)
				for(int j=1;j<=x;j++)
				  dira[++ad]={1,0}; // 把x分解为多个1或多个-1，下面同理
			else
				for(int j=-1;j>=x;j--)
				  dira[++ad]={-1,0};
		}
		else if(c=='Y')
		{
			if(x>0)
				for(int j=1;j<=x;j++)
				  dira[++ad]={0,1};
			else
				for(int j=-1;j>=x;j--)
				  dira[++ad]={0,-1};
		}
	}
	scanf("%d%d%d",&bsx,&bsy,&bm);
	for(int i=1;i<=bm;i++)
	{
		int x;
		char c;
		cin>>x>>c;
		if(c=='X')
		{
			if(x>0)
				for(int j=1;j<=x;j++)
				  dirb[++bd]={1,0};
			else
				for(int j=-1;j>=x;j--)
				  dirb[++bd]={-1,0};
		}
		else if(c=='Y')
		{
			if(x>0)
				for(int j=1;j<=x;j++)
				  dirb[++bd]={0,1};
			else
				for(int j=-1;j>=x;j--)
				  dirb[++bd]={0,-1};
		}
	}
	xy a={asx,asy},b={bsx,bsy}; // 当前的两点坐标
	int T=(ad*bd)/__gcd(ad,bd); // 计算总秒数（最小公倍数）
	double ans=sqrt((asx-bsx)*(asx-bsx)+
	  			    (asy-bsy)*(asy-bsy)); // 这里计算没动的时候的距离
	for(int t=1,i=1,j=1;t<=T;t++,i=i%ad+1,j=j%bd+1) // i,j要在1~ad,1~bd之间循环起来，%一下就行
	{
		a.x+=dira[i].x,a.y+=dira[i].y;
		b.x+=dirb[j].x,b.y+=dirb[j].y; // 计算两点的新坐标
		ans=min(ans,sqrt((a.x-b.x)*(a.x-b.x)+
			  		     (a.y-b.y)*(a.y-b.y))); // 计算当前距离，取最小值
	}
	return !printf("%.2lf",ans); // 两位小数
}
```
~~给我赞赞qwq~~

---

## 作者：FZY_CZY (赞：3)

## 题意
[原文](https://www.luogu.com.cn/problem/P3843)

对于题目的意思，大部分都比较浅显易懂，其中需要注意的是：“两个人行走的速度都是每秒一个单位距离。”这句话很重要，这意味着无论我该路线的长度是多少，小 A 和小 B 都是每秒一个单位长度，而不是直接一秒到达目的地。

然后就是 X 轴和 Y 轴的事情了，这个倒是没有太大的问题，主要是注意细节，不要用反了。

题意很简单，就这么多。

## 思路
考虑这道题的思路。

其实思路还是蛮好想的，因为小 A 和小 B 的运动轨迹是周期，那我们只需要取最小公倍数，然后暴力枚举，用两点之间距离公式来计算，最后去一个 $\min$ 就 OK 了。

两点距离公式：$\sqrt{(x1-x2)\times(x1-x2)+(y1-y2)\times(y1-y2)}$，剩下琐碎的见于代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+10;
int x_1[N],y_1[N],x_2[N],y_2[N];
double len[N],minx=1000000010;//这里不建议开INT_MAX，这样容易爆int
int num_1,num_2,v_,n1,n2,n,v;
char op;
int main(){
	cin>>x_1[0]>>y_1[0]>>num_1;
    for(int i=1;i<=num_1;i++)
    {
    	cin>>v_>>op;
        v=abs(v_);
		v_/=v;//每秒的运动都是1个单位，计算单位的个数
        if (op=='X')
		{
			while(v)
			{
				n1++;
				//计算总时刻
				x_1[n1]=x_1[n1-1]+v_;
				y_1[n1]=y_1[n1-1];
				v--;
				//计算此时刻坐标
			}
		}
        else
		{
			while (v)
			{
				n1++;
				y_1[n1]=y_1[n1-1]+v_;
				x_1[n1]=x_1[n1-1];
				v--;
			}
			//同上
		}
    }
    cin>>x_2[0]>>y_2[0]>>num_2;
    for(int i=1;i<=num_2;i++)
    {
    	cin>>v_>>op;
        v=abs(v_);
		v_/=v;
		//同上
        if (op=='X')
        {
            while(v)
            {
                n2++;
                x_2[n2]=x_2[n2-1]+v_;
                y_2[n2]=y_2[n2-1];
                v--;
            }
            //同上
        }
        else
        {
            while(v)
            {
                n2++;
                y_2[n2]=y_2[n2-1]+v_;
                x_2[n2]=x_2[n2-1];
                v--;
            }
            //同上
        }
    }
    n=n1/__gcd(n1,n2)*n2;
    for(int i=1;i<=n;i++)
    {
        int X=abs(x_1[i%n1]-x_2[i%n2]),Y=abs(y_1[i%n1]-y_2[i%n2]);//取模的作用是同步小A和小B的时间
        double fx=X*X+Y*Y;//两点之间距离公式
        minx=min(minx,fx);
    }
    minx=sqrt(minx);//两点之间距离公式
    printf("%0.2lf",minx);
    return 0;
}
``````
完结撒花。

---

## 作者：ykkz000 (赞：3)

14分可能是没仔细读题。。。
```cpp
#include <bits/stdc++.h>
using namespace std;
int ma,mb;
int a[100500][2],b[100500][2];
//保存周期内A,B的位置
double minn=10000000;
//辗转相除法
int gcd(int a,int b){
	if(b==0) return a;
	else return gcd(b,a%b);
}
int main(){
	int na=0,nb=0;
    //读入计算A,B
	scanf("%d%d%d",&a[0][0],&a[0][1],&ma);
	for(int i=1;i<=ma;i++){
		int d;
		char c[3];
		scanf("%d%s",&d,c);
		if(c[0]=='X'){
			int dd=abs(d);
			int s=d/dd;
			for(int j=0;j<dd;j++){
				na++;
				a[na][0]=a[na-1][0]+s,a[na][1]=a[na-1][1];
			}
		}else{
			int dd=abs(d);
			int s=d/dd;
			for(int j=0;j<dd;j++){
				na++;
				a[na][1]=a[na-1][1]+s,a[na][0]=a[na-1][0];
			}
		}
	}
	scanf("%d%d%d",&b[0][0],&b[0][1],&mb);
	for(int i=1;i<=mb;i++){
		int d;
		char c[3];
		scanf("%d%s",&d,c);
		if(c[0]=='X'){
			int dd=abs(d);
			int s=d/dd;
			for(int j=0;j<dd;j++){
				nb++;
				b[nb][0]=b[nb-1][0]+s,b[nb][1]=b[nb-1][1];
			}
		}else{
			int dd=abs(d);
			int s=d/dd;
			for(int j=0;j<dd;j++){
				nb++;
				b[nb][1]=b[nb-1][1]+s,b[nb][0]=b[nb-1][0];
			}
		}
	}
	int m=na*nb/gcd(na,nb);
    //lcm(a,b)=a*b/gcd(a,b)
	int ia=0,ib=0;
	for(int i=0;i<m;i++){
		double dis=sqrt((double)((a[ia][0]-b[ib][0])*(a[ia][0]-b[ib][0])+(a[ia][1]-b[ib][1])*(a[ia][1]-b[ib][1])));
        //我竟然写成了int
		if(minn>dis) minn=dis;
		if(minn==0.00){
			printf("0.00");
			return 0;
            //节约时间
		}
		ia++;if(ia==na) ia=0;
		ib++;if(ib==nb) ib=0;
	}
	printf("%0.2lf",minn);
	return 0;
}
```

---

## 作者：joshua0729 (赞：0)

# P3843 [TJOI2007] 迷路 题解
[题目传送门](https://www.luogu.com.cn/problem/P3843)
## 14 分错因：
有很大可能是看错了题， $d$ 是每个任务总共要走的路程，而两个人每秒只能走一个单位。
## 思路
因为小 A 和小 B 的运动轨迹是周期性的，会循环，因此我们只需要 $\gcd$ 一下，求出最小公倍数，然后暴力枚举，用两点之间距离公式来计算所有时刻的距离，最后取 $\min$ 并输出就可以了。

两点距离公式： 
$\sqrt{(x_1−x_2)×(x_1−x_2)+(y_1−y_2)×(y_1−y_2)}$。

剩下问题见于代码。

```cpp
#include<bits/stdc++.h>
using namespace std;

int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);//求最大公约数
}

int lcm(int a,int b){
    return a/gcd(a,b)*b;//调用gcd，求最小公倍数
}

void path_read(vector<int>&x_coords,vector<int>&y_coords){//读取轨道坐标
    int sx,sy,m;
    cin>>sx>>sy>>m;//起始点坐标，指令条数
    x_coords.clear();//清空坐标
    y_coords.clear();
    int current_x=sx;
    int current_y=sy;
    for(int i=0;i<m;++i){//m条指令
        int d;
        char c;
        cin>>d>>c;
        int s=abs(d);
        int dir_x=0,dir_y=0;
        if(c=='X'){
            dir_x=d>0?1:-1; 
        }
        else{
            dir_y=d>0?1:-1; 
        }
        for(int j=0;j<s;++j){//s步
            current_x+=dir_x;
            current_y+=dir_y;
            x_coords.push_back(current_x);//将坐标存入
            y_coords.push_back(current_y);
        }
    }
}
int main(){
	vector<int>a_x,a_y,b_x,b_y;
    path_read(a_x,a_y);//读取小A的轨道
    path_read(b_x,b_y);//读取小B的轨道

    int ta=a_x.size();//小A的轨道长度
    int tb=b_x.size();//小B的轨道长度

    if(ta==0||tb==0){//特判，如果轨道长度为0，直接输出0.00
        printf("0.00\n");
        return 0;
    }

    int L=lcm(ta,tb);//计算最小公倍数
    double min_dist=1e18;//初始化最小距离为1e18

    for(int t=0;t<L;++t){//枚举每个时刻
        int a_idx=t%ta;//小A的当前位置
        int b_idx=t%tb;//小B的当前位置
		int dx=a_x[a_idx]-b_x[b_idx];//下一个x坐标
        int dy=a_y[a_idx]-b_y[b_idx];//下一个y坐标
        double dist=sqrt(dx*dx+dy*dy);//计算距离
        min_dist=min(min_dist,dist);//更新最小距离
    }
	printf("%.2f\n",min_dist);//输出最小距离，保留两位小数，没得说
    return 0;//完美结束
}
```
完美结束。

---

## 作者：xiaokang_suancai (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3843)

## 题意简述
小 A 和小 B 在轨道内作周期性运动，速度为一个单位长度每秒。给出运动轨迹，求二人运动时之间的最短距离。

## 题目分析
由于 $1 \le m,d \le 100$，所以轨道的最长距离为 $10^4$，这个数据范围很小，因此我们首先考虑暴力。

暴力做法显而易见，直接算出每一秒二人的坐标，用两点坐标公式算出距离，然后得出最小值。

注意以下几点：
- 由于两个人的运动是周期性的，所以枚举范围是二人行动周期的最小公倍数
- 每个时间单位都要枚举，可以用 $d_1=\frac{d_1}{|d_1|}$ 来算出偏移量（负数向左，正数向右）
- 两点间距离公式为：$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m1,m2,d1,d2,m,xx,yy,tot1,tot2;
int ax[10005],bx[10005],ay[10005],by[10005];
char c;
double dis,minx=0x3fffffff;
// tot1,tot2 记录轨迹长度（周期）
int gcd(int a,int b)
{
	if(b!=0)
		return gcd(b,a%b);
	else
		return a; // 最大公因数
}
int main()
{
	cin>>ax[0]>>ay[0]>>m1;
	for(int i=1;i<=m1;i++)
	{
		cin>>d1>>c; // 正常读入
		if(c=='X')
		{
			for(int j=1;j<=abs(d1);j++)
			{
				tot1++;
				ax[tot1]=ax[tot1-1]+d1/abs(d1); // d1/abs(d1) 算出每一秒的偏移量
				ay[tot1]=ay[tot1-1]; // 算出每一秒的坐标
			} // 下面同理，不再赘述
		}
		else if(c=='Y')
		{
			for(int j=1;j<=abs(d1);j++)
			{	
				tot1++;
				ax[tot1]=ax[tot1-1];
				ay[tot1]=ay[tot1-1]+d1/abs(d1);
			}
		}
	}
	cin>>bx[0]>>by[0]>>m2;
	for(int i=1;i<=m2;i++)
	{
		cin>>d2>>c;
		if(c=='X')
		{
			for(int j=1;j<=abs(d2);j++)
			{
				tot2++;
				bx[tot2]=bx[tot2-1]+d2/abs(d2);
				by[tot2]=by[tot2-1];
			}
		}
		else if(c=='Y')
		{
			for(int j=1;j<=abs(d2);j++)
			{
				tot2++;
				bx[tot2]=bx[tot2-1];
				by[tot2]=by[tot2-1]+d2/abs(d2);
			}
		}
	} // 只需要算到 tot1,tot2 的最小公倍数
	m=tot1/gcd(tot1,tot2)*tot2;
	for(int i=1;i<=m;i++)
	{ // 记得取模
		xx=abs(ax[i%tot1]-bx[i%tot2]);
		yy=abs(ay[i%tot1]-by[i%tot2]);
		dis=sqrt(xx*xx+yy*yy);
		minx=min(minx,dis);
	}
	cout<<fixed<<setprecision(2)<<minx; // 输出答案
	return 0;
}
```
求过 qwp

[AC 记录](https://www.luogu.com.cn/record/203876256)

---

## 作者：furina_yyds (赞：0)

## 题意

题面里没有难懂的部分。

给定两个人的行动路线，要求出两人离得最近时两人的距离。

## 思路

因为 $1 \le m,d \le 100$ 数据很小，直接暴力枚举即可。

## 代码

```cpp
#include <iostream>
#include <iomanip>
#include <vector>
#include <cmath>
#include <algorithm>

// 计算两点之间的距离
double getDis(int s0, int s1, int s2, int s3) {
    return std::sqrt((s2 - s0) * (s2 - s0) + (s3 - s1) * (s3 - s1));
}

// 处理输入并填充 num 向量和计算总步数
void processInput(int& totalSteps, std::vector<std::pair<int, int>>& num) {
    int n;
    std::cin >> n;
    while (n--) {
        int tpa;
        char tpb;
        std::cin >> tpa >> tpb;
        int tpc = (tpa < 0)? -1 : 1;
        tpa = std::abs(tpa);
        totalSteps += tpa;
        if (tpb == 'Y') {
            for (int i = 0; i < tpa; ++i) {
                num.emplace_back(0, tpc);
            }
        } else {
            for (int i = 0; i < tpa; ++i) {
                num.emplace_back(tpc, 0);
            }
        }
    }
}

int main() {
    int s[4];
    int t[2] = {0, 0};
    std::vector<std::pair<int, int>> num[2];
    double ans = 1e12;

    // 读取起点信息并处理输入
    std::cin >> s[0] >> s[1];
    processInput(t[0], num[0]);

    // 读取终点信息并处理输入
    std::cin >> s[2] >> s[3];
    processInput(t[1], num[1]);

    // 计算最大公约数
    int Time = std::__gcd(t[0], t[1]);

    // 初始化最小距离
    ans = getDis(s[0], s[1], s[2], s[3]);

    // 模拟移动过程，更新最小距离
    for (int i = 0; i < t[0] * t[1] / Time; ++i) {
        int tpa = i % t[0];
        int tpb = i % t[1];
        s[0] += num[0][tpa].first;
        s[1] += num[0][tpa].second;
        s[2] += num[1][tpb].first;
        s[3] += num[1][tpb].second;
        ans = std::min(ans, getDis(s[0], s[1], s[2], s[3]));
    }

    // 输出结果，保留两位小数
    std::cout << std::fixed << std::setprecision(2) << ans << std::endl;

    return 0;
}
```

---

## 作者：LHW_Cosset_Idiot (赞：0)

### 题目大意：
两个人每秒行走一个单位，求出两个人在行走时最近的距离。

### 分析题意：
- 数据很水，考虑暴力枚举。
- 两个人每秒行走一个单位，这意味着无论我该路线的长度是多少，小 $A$ 和小 $B$ 都是每秒一个单位长度，而不是直接一秒到达目的地。
- 两个人的行动是周期性的，只需取最小公倍数即可。
- 两点距离公式：$\sqrt {(x1−x2)^2+(y1−y2)^2}$。

### 解题步骤：
- 求出两人行动周期的最小公倍数，确定枚举范围。
- 开始每个时间单位枚举。
- 对所有枚举得到的距离取 $\min$ 值。
- 最后记得是保留小数点后两位，两人相遇时输出 $0.00$。

进行上述步骤模拟即可，不给出标准程序。

---

## 作者：ny_Dacong (赞：0)

# 思路

首先注意人物每秒只走一格。题目中的 $d$ 是路径长度。

既然每秒一格，那么考虑把每段折线拆成 $d$ 段长度为 $1$ 的线段。然后依照题意模拟每一秒两人的位置以及距离。

求距离的公式：令小 A 的坐标为 $(x_1,y_1)$，小 B 的坐标为 $(x_2,y_2)$。则两人的距离为：

$$\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$$

令小 A 的路径总长度为 $l_1$，小 B 的路径总长度为 $l_2$。因为路径会循环，所以两人的相对位置会有周期，周期长度为 $\gcd(l_1,l_2)$。

依照题意模拟求最小即可。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int Time;
int s[5],t[2];
vector<pair<int,int>> num[2];
double ans = 1e12;
double getdis(){
	return sqrt((s[2]-s[0])*(s[2]-s[0])+(s[3]-s[1])*(s[3]-s[1]));
}
int main(){
	scanf("%d%d%d",&s[0],&s[1],&n);
	while(n--){
		static int tpa,tpc;
		static char tpb;
		scanf("%d %c",&tpa,&tpb);
		if(tpa < 0){
			tpc = -1;
			tpa = (~tpa)+1;
		}else{
			tpc = 1;
		}
		t[0] += tpa;
		if(tpb == 'Y'){
			while(tpa--){
				num[0].push_back({0,tpc});
			}
		}else{
			while(tpa--){
				num[0].push_back({tpc,0});
			}
		}
	}
	scanf("%d%d%d",&s[2],&s[3],&m);
	while(m--){
		static int tpa,tpc;
		static char tpb;
		scanf("%d %c",&tpa,&tpb);
		if(tpa < 0){
			tpc = -1;
			tpa = (~tpa)+1;
		}else{
			tpc = 1;
		}
		t[1] += tpa;
		if(tpb == 'Y'){
			while(tpa--){
				num[1].push_back({0,tpc});
			}
		}else{
			while(tpa--){
				num[1].push_back({tpc,0});
			}
		}
	}
	Time = __gcd(t[0],t[1]);
	ans = getdis();
	for(int i = 0; i < t[0]*t[1]/Time; i++){
		static int tpa,tpb;
		tpa = i%t[0];
		tpb = i%t[1];
		s[0] += num[0][tpa].first;
		s[1] += num[0][tpa].second;
		s[2] += num[1][tpb].first;
		s[3] += num[1][tpb].second;
		ans = min(ans,getdis());
	}
	printf("%.2lf",ans);
	return 0;
}
```

---


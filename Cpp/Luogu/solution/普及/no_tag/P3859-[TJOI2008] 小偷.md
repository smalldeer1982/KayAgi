# [TJOI2008] 小偷

## 题目背景

一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从 $0$ 开始，想进入第 $i$ 个房间就必须从第 $i-1$ 个房间进入，如图：

![](https://cdn.luogu.com.cn/upload/pic/6100.png)


## 题目描述

上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为 $0,1,2\cdots$。已知当小偷从第 $0$ 个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。

附：对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。

## 说明/提示

### 样例解释

虽然在第 $2$ 个房间中价值为 $5$ 的宝石好，但是不如拿两次价值为 $3$ 的宝石，在拿两次第 $0$ 房间中价值为 $1$ 的宝石，总价值为 $8$。

### 数据范围及约定

对于 $100\%$ 的数据，储藏室的屋子数量不超过 $50$，每扇门关闭的时间不超过 $1000$，并且宝石的数量不超过 $100$，价值不超过 $1000$。

## 样例 #1

### 输入

```
3 4
9 5 5
0 1 2
1 2 2
2 3 2
2 5 3
```

### 输出

```
8```

# 题解

## 作者：蒟蒻·巨弱 (赞：6)

# 一道可能只有黄题难度的紫题

这题应该是**完全背包**的模板题，这题用爆搜也能骗到分（懒，没打，~~不会打~~），好了，言归正传，这题其实只要处理一下每个门关闭的**真实**时间，因为如果前面的门关了，你就走不出去了，只要一个循环就能处理好：

```cpp
for (i = 1; i < n; i++) close[i] = min (close[i], close[i-1]);
```

注意，门的编号从 $0$ 开始，所以我从第一扇开始处理到最后一扇就行，这应该是最难想的一个坑了

## 后面输入完之后直接套模板！具体解释看程序~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1005
int n, m, i, j, k, close[N], f[N];//close数组记录门关闭的（真正的）时间，f数组是当前时间拿的最大价值 
struct baoshi{//习惯用结构体了。。。 
	int room, val, t;//宝石的 房间编号 价值 拿走的时间 
}d[N];
int main(){
	scanf ("%d%d", &n, &m);
	for (i = 0; i < n; i++) scanf ("%d", &close[i]);//0号房开始 
	for (i = 1; i < n; i++) close[i] = min (close[i], close[i-1]);
	//因为前面的门如果关上了，就不能去后面的门了，所以每扇门真正的关闭时间是前面的门最早的关闭时间 
	for (i = 1; i <= m; i++) scanf ("%d%d%d", &d[i].room, &d[i].val, &d[i].t);
	for (i = 1; i < close[0]; i++){//第一重循环，枚举时间（一定要在0号房关闭之前出去） 
		f[i] = f[i-1];//如果不偷宝石 
		for (j = 1; j <= m; j++){//枚举宝石
			if (close[d[j].room] > i /*关闭的时间大于枚举的时间，能进*/ && d[j].t <= i)//能拿 
			f[i] = max (f[i], f[i-d[j].t] + d[j].val);//拿或者不拿的最大值 
		}
	}
	printf ("%d", f[close[0]-1]);//可以理解为门关闭前最后一秒拿的价值 
	return 0;//完美收场
}
```

**希望能帮上忙~**

---

## 作者：GNAQ (赞：4)

傻了两三个小时终于搞下来了，二杀补个一血题解。

比较另类 ~~但是仍然很套路~~ 的背包

~~（想知道我为什么交了那么多遍么？我傻到直接输出了 dp[背包体积] 作为答案 并且很久才意识到这个问题）~~

~~才不是考场，懒得写爆搜对拍（这就是你丢脸的理由？？~~

行了，说题

注意这哥们最后要从 $0$ 号门出去，并且你要注意，假设你现在在 $4$ 号房间，所有门都开着，但是这时 $2$ 号房间左面的门关了，那你也完蛋了。

所以我们让 $\mathrm{close\_time[i]} = \min\{\mathrm{close\_time[0 \sim i]}\}$

然后考虑倒着 DP 回去。

对于每个房间，相当于是做体积为 `close_time[i]-1` 的完全背包。

然后最后合并起来

~~然而完全不用合并，你可以直接滚动，正确性**显然**~~

可以直接滚动，因为关门时间递减，所以倒着 DP 的顺序就是决策每个物品的顺序

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
#include<cmath>
#include<algorithm>
#include<iterator>
#include<cstdlib>
#include<vector>
#include<queue>
#include<map>
#include<set>
#define fst first
#define snd second
#define ll long long
using namespace std;

int n,m;
int clotime[110],dia[110][110];
int cost[110],val[110];

int dp[1010],ans;

template<typename int_t>
void readx(int_t& x)
{
	x=0; int_t k=1; char ch=0;
	while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
	while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	x*=k;
}

int main()
{
	readx(n); readx(m); int tmp;
	for (int i=1;i<=n;i++) readx(clotime[i]);
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++)
			clotime[j]=min(clotime[j],clotime[i]); 
			
	for (int i=1;i<=m;i++) 
	{
		readx(tmp); tmp++;
		dia[tmp][++dia[tmp][0]]=i;
		readx(val[i]); readx(cost[i]);
	}
	
	for (int i=n;i>=1;i--)
	{
		for (int j=1;j<=dia[i][0];j++)
		{
			int V=cost[dia[i][j]],W=val[dia[i][j]];
			for (int k=V;k<clotime[i];k++) 
				dp[k]=max(dp[k],dp[k-V]+W);
		}
	}
	int ans=0;
	for (int i=0;i<clotime[1];i++) ans=max(ans,dp[i]);
	printf("%d\n",ans);
}
```

---

## 作者：Mobius127 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P3859)

这道题很明显没有紫题难度，~~不过白水一道紫题还是很香的。~~

### 思路：完全背包

**对于每一个房间及房间里的钻石，都进行一次完全背包DP。**

### 一些细节：

1. 对于每一个房间，其可装最大值不是房间关闭的时间，而是在其之前全部房间内的最早关闭时间。如果超过了这个时间，那么小偷就到不了当前这个房间。

1. 最后的答案要从1开始到最大房间的结束时间扫一遍$f[N]$数组，取最大值即可。

## AC Code:

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
#define N 105
#define M 1005
using namespace std;
int n, m, f[M], close[N];
struct dimond{
	int v[M], w[M], top, last;
}a[55];
int main(){
	int fang, vi, wi, minn=1e9, maxn=0, ans=0;
	scanf("%d%d", &n, &m);
	for(int i=1; i<=n; i++){
		a[i].top=0;//预处理top为0 
		scanf("%d", &close[i]);//每一扇房门关闭的时间 
		minn=min(minn, close[i]);
		close[i]=minn;
		maxn=max(maxn, close[i]);
	} 
	for(int i=1; i<=m; i++){
		scanf("%d%d%d", &fang, &vi, &wi);
		fang++;
		a[fang].top++;
		a[fang].v[a[fang].top]=vi;
		a[fang].w[a[fang].top]=wi;
		//将宝石加入房间内的队列里 
	} 
	for(int i=n; i>0; i--){//每一个房间 
		for(int j=1; j<=a[i].top; j++){
			for(int k=a[i].w[j]; k<close[i]; k++){
				f[k]=max(f[k], f[k-a[i].w[j]]+a[i].v[j]);
			}
		}
	}
	for(int i=1; i<=maxn; i++) ans=max(ans, f[i]);
	printf("%d", ans);
	return 0;
}
```


---

## 作者：RockyQ012 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P3859)


---

这道题就是一个背包模板，要注意的是如果后面的门没关，但前面的门关了，他就被锁里面了。所以一个房间真正的关门时间是它前面所有房间关门时间的最小值。其他就是标准模板了。~~但是！我卡了几十分钟才过~~


---


```
#include<bits/stdc++.h>
using namespace std;
int n , m , a[1005] , dp[1005];
struct node{
	int x,y,z;
}b[1005];
int main(){
	cin >> n >> m;
	for(int i = 0 ; i < n ; ++i){
		cin >> a[i];
		if(i != 0) a[i] = min(a[i] , a[i - 1]);
	}
	for(int i = 1 ; i <= m ; ++i){
		cin >> b[i].x >> b[i].y >> b[i].z;
	}
	for(int i = 1 ; i <= a[0] ; ++i){
		dp[i] = dp[i - 1];
		for(int j = 1 ; j <= m ; ++j){
			if(i < a[b[j].x] && b[j].z <= i){
				dp[i] = max(dp[i] , dp[i - b[j].z] + b[j].y);
			}
		}
	}
	cout << dp[a[0] - 1];
	return 0;
}
//申明：代码借鉴了Lcm_simida的，由于我最开始卡了很久。
```

---

## 作者：linyinuo2008 (赞：1)

# 一、题目大意

有 $n$ 个袋子，每个带中有许多不同种类的宝石。取走袋子中的宝石需要花一定的时间，每个袋子都有一个关闭时间 $c_i$。你需要在 $t$ （$t \le \forall c_j$，$j=1-i$）前取走第 $i$ 个包里面的宝石。并且在 $c_0$ 时刻前完成操作。求你最多能得到宝石的价值。

# 二、 算法思路

显然这是一个背包问题。物品是宝石，背包容积就是时间。

注意到有这样一句话：

> 而且所有屋子里各种宝石的数量都是无限多的。

我们可以确定这是一个完全背包。

但是每一个物品的取走时间都是受限制的，我们会发现每一个包（房间）的关闭时间不仅仅收到它本身的约束，还受到它前面所有关闭时间的约束。

**所以一个房间真正的约束时间是它前面所有约束时间的最小值。**

即 $c_i=\min{c_j}$，$1<j \le i$ 。

之后就可以进行完全背包的常规操作了。

注：这道题的良心之处在于它直接告诉我们物品分别是属于哪个房间的，而没有让我们依次把物品从房间中“提取”出来。

# 三、代码

代码有注释。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

//const int NR=105;
const int MR=1005;

int n,m,f[MR];
int c[MR],r[MR],v[MR],t[MR];
 
int main()
{
	memset(f,0,sizeof(f));
	cin>>n>>m;
	for(int i=0;i<n;i++)
		cin>>c[i];
	for(int i=1;i<=m;i++)
		cin>>r[i]>>v[i]>>t[i];
	for(int i=1;i<n;i++)
		c[i]=min(c[i],c[i-1]);
		//预处理每一个房间关闭时间
	for(int i=1;i<c[0];i++)//枚举时间
	{
		f[i]=f[i-1];//一维动态规划要赋初值
		for(int j=1;j<=m;j++)//完全背包正序枚举物品
		{
			if(i<c[r[j]]&&i>=t[j])
			//既要能取，房间门还不能关
				f[i]=max(f[i],f[i-t[j]]+v[j]);
		}
	}
	cout<<f[c[0]-1];//大门关前一秒溜走
	return 0;
}
```
**若有错误，欢迎指出！**

---

## 作者：小恐 (赞：1)

这是一道有点变形的背包问题

~~名字起得有点问题，我同学说做出来的都是小偷~~

这个小哥只能从0号门出，如果后面的门没关，但前面的门关了，他还是出不来。所以我们要把每个门的关闭时间更新为前面的们最早关闭时间（0不用）

按时间dp，即dp[i]记录第i时刻后获得的宝石最大价值

上代码：
```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
int a[55],d[105],r[105],t[105],v[105],dp[1005];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;++i)
		scanf("%d",a+i);//每个门的关闭时间 
	for(int i=1;i<n;++i)
		a[i]=min(a[i],a[i-1]);//更新为前面门关闭最早时间（0号不用） 
	for(int i=1;i<=m;++i)
		scanf("%d%d%d",r+i,v+i,t+i);//如题意所示 
	for(int i=1;i<=m;++i)
		d[i]=a[r[i]];//第i个宝石的房间关闭时间 
	for(int i=1;i<a[0];++i)//枚举从第一时刻到第0号门关闭前一时刻
	{
		dp[i]=dp[i-1];//如果这一时刻什么都不拿 
		for(int j=1;j<=m;++j)
			if(i>=t[j]&&i<d[j])//这些时间够拿第j个宝石并且严格早于关闭时间 
				dp[i]=max(dp[i-t[j]]+v[j],dp[i]);//更新dp[i] 
	}
	printf("%d",dp[a[0]-1]);//输出最后一时刻（0号门关闭时间前一时刻）最大获得宝石价值 
	return 0;
 } 
```
请遵守洛谷社会道德，请勿抄题解

---

## 作者：Lcm_simida (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P3859)

 这道题就说是纯纯的**完全背包**模板。  
 思路便是使用 $dp_i$ 来表示在**第 $i$ 的时间**下**最多获得的价值**，则**状态转移公式**便是 $dp_i=\max(dp_i,dp_{i-time}+valel)$。
 
同时还可以把每个门**关闭的时间**赋值为**这一扇门与前面所有门的最小值**，这样我们便可用 $O(1)$ 的时间来判断时间够不够，如果**此刻的时间比** $a_i$ **小**，即为合法，因为如果**前面的门没有打开**，则此扇门**绝对无法通过**。

## 以下为核心代码：

```cpp
	for(int i=1;i<a[0];i++){
		dp[i]=dp[i-1];
		for(int j=1;j<=m;j++){
			if(i<a[b[j].x]&&b[j].z<=i){
				dp[i]=max(dp[i],dp[i-b[j].z]+b[j].y);
			}
		}
	}
```

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1005],dp[1005],minn=1e9+5;//dp[i][j]表示小偷在第j的时间的最大价值 
struct node{
	int x,y,z;//位置，价值，时间 
}b[1005];
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>a[i];
		if(i!=0) a[i]=min(a[i],a[i-1]);
		//进入该门的最少时间 
	}
	for(int i=1;i<=m;i++){
		cin>>b[i].x>>b[i].y>>b[i].z;
	}
	for(int i=1;i<a[0];i++){
		dp[i]=dp[i-1];
		for(int j=1;j<=m;j++){
			if(i<a[b[j].x]&&b[j].z<=i){
				dp[i]=max(dp[i],dp[i-b[j].z]+b[j].y);
			}
		}
	}
	cout<<dp[a[0]-1];
	return 0;
}
```

---

## 作者：CCCloud (赞：1)

终于把这道题水过了 $qwq$。  
这道题难度不高，没有紫题难度。 

------------
在每个房间里会有一些宝石，时间是一定的，宝石可以无限拿，他却让我们输出一个最大值，所以使我想到了**dp**。  
而只需要处理一下**每个门关闭的时间**，就可以开开心心地套用我那01背包地模板啦！  
$f[i]$ 记录前 $i$ 个时间里得到宝石的最大值， $a$ 数组为每个门关闭的时间，$r$ ，$v$，$t$ 数组分别为房间编号，价值和时间。如果某一宝石可满足条件：**房间关闭时间大于当前时间且当前时间大于等于偷宝石的时间**，那么就可以进行一次比较。

代码如下（更清晰的解释在代码处）：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1005;
int n, m, a[MAXN], b[MAXN], r[MAXN], v[MAXN], t[MAXN], f[MAXN];

int main(void)
{
	scanf("%d%d", &n, &m);
	for(int i=0; i<n; i++)
		scanf("%d", &a[i]);
	for(int i=1; i<n; i++)
		a[i]=min(a[i], a[i-1]);//处理门真正关闭的时间
	for(int i=1; i<=m; i++)
		scanf("%d%d%d", &r[i], &v[i], &t[i]);
	for(int i=1; i<a[0]; i++)//枚举时间
	{
		f[i]=f[i-1];//不偷宝石
		for(int j=1; j<=m; j++)
		{
			if(a[r[j]]>i && t[j]<=i)
            //房间关闭时间大于当前时间且当前时间大于等于偷宝石的时间
			f[i]=max(f[i], f[i-t[j]]+v[j]);//背包
		}
	}
	printf("%d\n", f[a[0]-1]);
	return 0;
}
```
希望这份代码能帮到你qwq！

---

## 作者：Dream_poetry (赞：0)

### 思路：
近似于完全背包板子题。

由于当上一个门关闭后其以后所有的房间都不被经过，所以我们要添加一行代码：```c[i]=min(c[i],c[i-1]);```。

另外还要注意，一定要在小偷左边的门关闭前逃离。

然后直接套上完全背包板子即可。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,f[500005];
int c[500005],r[500005],v[500005],t[500005];
 
signed main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>c[i];
		if (i){
			c[i]=min(c[i],c[i-1]);
		}
	}
	for(int i=1;i<=m;i++){
		cin>>r[i]>>v[i]>>t[i];
	}
	for(int i=1;i<c[0];i++){
		f[i]=f[i-1];
		for(int j=1;j<=m;j++){
			if( i<c[r[j]] && i>=t[j] ){
				f[i]=max(f[i],f[i-t[j]]+v[j]);
			}
		}
	}
	cout<<f[c[0]-1];
	return 0;
}
```

---

## 作者：icaijy (赞：0)

# 分析题目
读题，我们注意到题目中的关键信息：
1. 无限多的宝石。
2. 得到最大价值。

我们发现这很像完全背包问题，那么接下来研究如何转化成完全背包问题即可。

# 思路
对于这题，每件物品的价值就对应完全背包中的物品价值，偷每件物品的时间就可以对应完全背包的物品大小。对于第 $i$ 个房间，背包容量就是门关闭的时间。

不过我们不能直接使用数据中的门关闭时间，例如门关闭时间是 `1 1 4 5 1 4` 时，我们偷第 $2$ 个房间的物品最多耗时 $1$ 而非 $4$，不然前面的门就被关上了出不来了。所以需要求一下每个房间**真实关闭时间**。只需让门的关闭时间为一个单调递减序列即可求出。
```cpp
for (int i=0;i<n;i++) {	
	cin>>t[i];
	if (i)t[i]=min(t[i],t[i-1]); // 除了0号房间，后面房间的真实关闭时间必须小于前面的。
}
 ```
接下来写完全背包板子即可，需要注意的是，我们要从最里面的房间开始偷。因为房间号越小的房间容量越大，而我们希望较大的背包容量能从较小的背包容量转移出去。
 # 代码
 ```cpp
#include <iostream>
#include <vector>
using namespace std;
int t[55];
int f[1005]; // dp数组
struct bs{ //宝石结构体
	int w,v;
};
vector<bs> b[55];
int main(){
	int n,m;
	cin>>n>>m;
	for (int i=0;i<n;i++) {	
		cin>>t[i];
		if (i)t[i]=min(t[i],t[i-1]); //真实关闭时间
	}
	int a;
	bs sb;
	for (int i=0;i<m;i++){
		cin>>a;
		cin>>sb.w>>sb.v;
		b[a].push_back(sb); // 存宝石
	}
	for (int i=n;i>=0;i--){ // 从最里面的开始偷
		for (int j=0;j<b[i].size();j++){
			for (int k=b[i][j].v;k<t[i];k++){
				f[k]=max(f[k],f[k-b[i][j].v]+b[i][j].w); // 完全背包板子
			}
		}
	}
	int ans=0;
	for (int i=0;i<=t[0]-1;i++) ans=max(ans,f[i]);
	cout<<ans;
	
	return 0;
}
```

---

## 作者：cpu_gal (赞：0)

# 思路：完全背包

对于每一个房间及房间里的钻石，都进行一次完全背包 dp。

## 一些细节：

对于每一个房间，其可装最大值不是房间关闭的时间，而是在其之前全部房间内的最早关闭时间。如果超过了这个时间，那么小偷就到不了当前这个房间。

最后的答案要从 1 开始到最大房间的结束时间扫一遍 $f _ {N}$ 数组，取最大值即可。

### 奉上代码
```c
#include<bits/stdc++h>
#define N 105
#define M 1005
using namespace std;
int n, m, f[M], close[N];
struct dimond{
	int v[M], w[M], top, last;
}a[55];
int main(){
	int fang, vi, wi, minn=1e9, maxn=0, ans=0;
	scanf("%d%d", &n, &m);
	for(int i=1; i<=n; i++){
		a[i].top=0; //预处理 top 为 0 
		scanf("%d", &close[i]); //每一扇房门关闭的时间 
		minn=min(minn, close[i]);
		close[i]=minn;
		maxn=max(maxn, close[i]);
	} 
	for(int i=1; i<=m; i++){
		scanf("%d%d%d", &fang, &vi, &wi);
		fang++;
		a[fang].top++;
		a[fang].v[a[fang].top]=vi;
		a[fang].w[a[fang].top]=wi;
		//将宝石加入房间内的队列里 
	} 
	for(int i=n; i>0; i--){ //每一个房间 
		for(int j=1; j<=a[i].top; j++){
			for(int k=a[i].w[j]; k<close[i]; k++){
				f[k]=max(f[k], f[ka[i].w[j]]+a[i].v[j]);
			}
		}
	}
	for(int i=1; i<=maxn; i++) ans=max(ans, f[i]);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：lytqwq (赞：0)

~~卡课间写出来了~~

首先优先想后面的房间的宝石，所以就直接倒着循环从后往前拿宝石。

宝石种类就用$vector$存到每个房间里。

假设当前在第$i$个房间，使用了$j$个时间，当前正在考虑第$p$个宝石，$c[i]$为第$i$个房间的最后逃出时间。

所以

 $ F[j]=max(F[j],F[j-T[p]]+V[p]) (j-T[p]>=0,j<c[i])$
 
 最后统计$0$号房间可能的答案就行了。
 
 注意$c[i]$要对$c[i-1]$取$min$，因为如果前面有个更早就关的门还是要在这个时间之前逃出**这个房间之后的房间**
 
 上代码，对照代码理解更好，我换了几个地方的写法：
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=51;
const int M=1002;
int n,m,c[N],f[M],ans;
struct d{
	int v,t;
}qwq;
vector<d> b[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		scanf("%d",&c[i]);
		if(i==0){
			continue;
		}
		c[i]=min(c[i],c[i-1]);
	}
	for(int i=1;i<=m;i++){
		int r;
		scanf("%d%d%d",&r,&qwq.v,&qwq.t);
		b[r].push_back(qwq);
	}
	for(int i=n-1;i>=0;i--){
		for(int o=0;o<=c[i]-1;o++){
			for(unsigned int p=0;p<b[i].size();p++){
				if(o-b[i][p].t>=0){
					f[o]=max(f[o],f[o-b[i][p].t]+b[i][p].v);
				}
			}
		}
	}
	for(int i=0;i<=c[0]-1;i++){
		ans=max(ans,f[i]);
	}
	printf("%d\n",ans);
}
```

~~我才不会告诉你这是上课时间写出来的~~

---

## 作者：Anita_Hailey (赞：0)

## TJOI2008小偷

### 题目背景

一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从0开始，想进入第i个房间就必须从第i-1个房间进入，如图：

![](F:\C++\飞扬奥赛课程\mark\6100.jpg)

### 题目描述

上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为0,1,2…。已知当小偷从第0个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。

附： 对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。

**输入格式**

每组测试数据的第一行有两个整数N和M，分别代表储藏室有N个房间，并且有M种宝石。第二行中会有N个正整数，分别表示第i个门关闭的时间（门的编号从0开始），接下来的M行，每行有三个整数r，v和t，分别代表这种宝石所在的房间编号为r，它的价值为v，小偷拿走它所耗费的时间为t。

**输出格式**

输出小偷在成功逃出储藏室的情况下获得宝石的最大价值。

**输入 #1**

```c++
3 4
9 5 5
0 1 2
1 2 2
2 3 2
2 5 3
```

**输出 #1**

```c++
8
```

### 样例说明

我们知道，小偷应该在2时刻拿个3的，再在4时刻拿3的最后逃出到房间一，最后在一房间拿两个1的宝石，在八秒时逃出。

我们在求解时用到了两个变量一个是时间，一个是在的屋子。所以我们考虑，以这两个为变量，造一个函数。

### 分析算法

我们在每个房间里会有一些宝石，小偷的时间是一定的，宝石可以无限拿，他却让我们输出一个最大值，我们想到了dp。

我们不要被小偷从一号门进去而迷惑，小偷的神行无影，我们理解为小偷出生在最里面的第n间屋子里，在从外面跑，有点类似于纪念品那个题，当然在分析上会难很多。

我们的每一个门，会有自己关门的时间，对吧这就是体积v,每一个宝石就是商品，不要忘了要对关门的时间进行处理

于是乎，套上我的完全背包的模板，就有了1版的代码

#### 定义

$dp(i,j)$表示在第从n到i个房间里，在j的时间内所能拿到的最贵价值

#### 所求

$dp(1,close[1]-1)$即为所求我们将第$1 到 i$个门中关闭的的最小时间

#### dp转移方程

$$

dp(i,j)=
\begin{cases}
f(i+1,j)\\
f(i,j-1)\\
f(i,j-sto[i].tim[k])+sto[i].pri[k];
\end{cases}

$$



```c++
#include <iostream>
#include <cstdio>
#include <bits/stdc++.h>
using namespace std;
const int Maxdoor=55,Maxthi=110,Maxtime=1100;
struct Node{
	int pri[Maxthi],tim[Maxthi],num;
}sto[Maxdoor];
int n,m,x,min1,close[Maxdoor],dp[Maxthi][Maxtime];
int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		x=(x<<1)+(x<<3)+(ch-'0');
		ch=getchar();
	}
	return x;
}
void read_in(){
	n=read();m=read();min1=0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		close[i]=read();
		min1=min(min1,close[i]);
		close[i]=min(min1,close[i]);
	}
	for(int i=1;i<=m;i++){
		x=read();
		x++;
		sto[x].num++;
		sto[x].pri[sto[x].num]=read();
		sto[x].tim[sto[x].num]=read();
	}
	return;
}
void f(){
	for(int i=n;i>=1;i--){
		for(int j=1;j<close[i];j++){
			dp[i][j]=max(dp[i][j-1],dp[i+1][j-1]);
			for(int k=1;k<=sto[i].num;k++){
				if(j-sto[i].tim[k]>=0) dp[i][j]=max(dp[i][j],dp[i][j-sto[i].tim[k]]+sto[i].pri[k]);
			}
		}
	}
	printf("%d",dp[1][close[1]-1]);
}
int main() {
	freopen("1.in","r",stdin);
	read_in();
	f();
	return 0;
}
```

再经过考虑，我们可以直接降维，因为我们在求$dp(i,j)$的时候，只用到了$dp(i+1)$和之前的$dp(i)$，所以我们可以降维

```c++
void f(){
	for(int i=n;i>=1;i--){
		for(int j=1;j<close[i];j++){
			dp[j]=max(dp[j],dp[j-1]);
			for(int k=1;k<=sto[i].num;k++){
				if(j-sto[i].tim[k]>=0) dp[j]=max(dp[j],dp[j-sto[i].tim[k]]+sto[i].pri[k]);
			}
		}
	}
	printf("%d",dp[close[1]-1]);
}
```

其实最开始我们想到代码的第4行为什么要传递最优值给下一个的，但是，连续提交的50pts，让我改了下样例就发现问题了，还是菜呀，因为决策里可以这一秒什么也不干呀，而且，主要原因还是背包体积的变化


---


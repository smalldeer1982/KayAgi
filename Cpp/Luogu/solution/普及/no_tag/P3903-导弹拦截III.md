# 导弹拦截III

## 题目描述

很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。

这个系统可以发射一颗导弹拦截从由到远、高度不增加的多个导弹。

但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。

这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。

当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。

现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。

## 说明/提示

$1\leq n\leq 10^3$，$1\leq $ 导弹高度 $\leq 10^9$。

## 样例 #1

### 输入

```
4
5 3 2 4```

### 输出

```
3```

# 题解

## 作者：Weng_Weijie (赞：35)

本题与NOIP2013D2T2 花匠差不多， 可用贪心做

首先我们知道在一个递增(递减)序列中最多只能打两颗导弹

所以在一个任意的序列中，最多能打的数量就是峰点和谷点数量之和，这样才最优

(注意！！刚开始只能往下打，即若一开始是递增序列，则答案减一)


```cpp
#include <stdio.h>
int flag = 0, now, last, n, ans = 1; //ans表示打下的导弹数
//flag表示当前是递增还是递减 0:递增 1:递减
//因为刚开始必须是递减，所以flag初值为0
int main() {
    scanf("%d%d", &n, &now);
    while (--n) {
        last = now;
        scanf("%d", &now);
        if (now == last) continue; //由于是严格的，所以相等直接退出
        if (flag ^ (now < last))  //如果递增(递减) 状态与当前不同那么答案加一（就是又找到了一个峰点(谷点)）
            ans++, flag = now < last;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：gaowеnxuan (赞：16)

#### ~~本蒟蒻的第一题题解，希望能过啊！！！~~

废话不多说，题解来一波

### 思想：

这一道题，就是在原题目 [P1020 导弹拦截](https://www.luogu.org/problemnew/show/P1020)的基础上，求一连串最长的序列，可是这条序列的第奇数个要比前一步高，偶数个要比前一步短。

既然如此，那么，我们可以将问题判第几个奇偶位置来。

也就是说，若此步是第奇步，我们就找前一步最长的第偶步。若此步是第偶步，我们就找前一步最长的第奇步。

```cpp
	if(a[j]<a[i]) dp[i][1]=max(dp[i][1],dp[j][0]+1);
	if(a[j]>a[i]) dp[i][0]=max(dp[i][0],dp[j][1]+1);
```

但是，关于每一颗导弹，我们都可以对其进行拦截与不拦截，每一颗导弹都可以成为第一颗拦截的导弹。

所以我们要初始化

```cpp
	for(int i=1;i<=n;i++)  dp[i][1]=1;
```

### 不多说，直接上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
  using namespace std;
int a[1005],dp[1000][5];
int main()
{
	int n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	  cin>>a[i];
	dp[1][1]=1;
	
	for(int i=2;i<=n;i++)
	{
		dp[i][1]=1;
		for(int j=1;j<=i-1;j++)
		{
			if(a[j]<a[i]) dp[i][1]=max(dp[i][1],dp[j][0]+1);
			if(a[j]>a[i]) dp[i][0]=max(dp[i][0],dp[j][1]+1);
		}
		ans=max(ans,max(dp[i][1],dp[i][0]));
	}
	cout<<ans;
	
	return 0;
}
```

---

## 作者：万弘 (赞：7)

不愧是导弹拦截III，和原版那么像

既然都说像了，那就是DP

$n<=1000,O(n*n)$DP没得跑了

和原题不一样在于，此题要求升降交错

再开一个数组或增加一维即可

设`f[i][1]`表示此发导弹比原来低,`f[i][0]`反之

`if(a[j]>a[i])f[i][1]=max(f[i][1],f[j][0]+1);`

`if(a[j]<a[i])f[i][0]=max(f[i][0],f[j][1]+1);`

就有这样的代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
ll n,ans=0;
ll a[10001],f[10001][3];
void fir()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;++i)scanf("%lld",&a[i]);
	
}
void work()
{
	for(ll i=1;i<=n;++i)
	{
		f[i][0]=f[i][1]=1;
		for(ll j=1;j<i;++j)
		{
			if(a[j]>a[i])f[i][1]=max(f[i][1],f[j][0]+1);
			if(a[j]<a[i])f[i][0]=max(f[i][0],f[j][1]+1);
		}
	}
}
void end()
{
	ans=0;
	for(ll i=1;i<=n;++i)
	{
		ans=max(ans,max(f[i][1],f[i][0]));
	}
	printf("%lld",ans);
}
int main()
{
	fir();
	work();
	end();
	return 0;
}
```
可惜这样搞亲测不能AC，想了很久~~还看了题解~~才知道第二发必须往低打

知道这个后把第二个方程略做修改即可

（实在不知道怎么改私信我）

---

## 作者：LT123456 (赞：6)

# 贪心  时间复杂度O(n)
这道题最简单的方法就是贪心，但是贪心的题解就两篇，并且写的都比较简略，我来一篇最容易理解的贪心题解吧。求过啊~

根据题意，拦截的第n(n为偶数)颗导弹要小于拦截的第n-1、n+1颗导弹。

我们先不管拦截的策略，先从前两颗导弹开始考虑：
假设第一颗导弹就是我们想拦截的第一颗导弹。如果第二颗导弹比第一颗导弹高，那么就令第二颗导弹为想拦截的第一颗导弹。因为对于奇数颗导弹，高度越高，下一颗导弹的选择就越多，能拦截的导弹数也就可能越多。
举个例子，如果:
n=5  导弹高度为4 6 5 6 3
如果选择第一颗导弹4为拦截的第一颗导弹，那么拦截的第二颗导弹只能为3，但如果选择第二颗导弹6为拦截的第一颗导弹，那么第二颗导弹就可以选择5和3了，多了一个5作为选择，那么可以拦截的导弹数就可能增多（事实上确实增多了）。
如果第二颗导弹比第一颗导弹低，那么就令第二颗导弹为想拦截的第二颗导弹。这个没什么好解释的。

同样的，对于拦截的第n颗（n为偶数）导弹，如果其下一颗导弹比该导弹低，那么就选择其下一颗导弹代替该导弹为拦截的第n颗导弹；如果比该导弹高，就令下一颗导弹为拦截的第n+1颗导弹。

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001],b[1001];
int main(){
	int t=1,i,n;
	cin>>n;
	for(i=1;i<=n;i++)  cin>>a[i];
	b[1]=a[1];
	for(i=2;i<=n;i++)
	{
	if(t%2!=0&&a[i]>a[i-1])  b[t]=a[i];	
	if(t%2!=0&&a[i]<a[i-1])  b[++t]=a[i];	
	if(t%2==0&&a[i]<a[i-1])  b[t]=a[i];	
	if(t%2==0&&a[i]>a[i-1])  b[++t]=a[i];	
	}
	cout<<t;
}
```
贪心的核心就是这4个if判断语句。t是拦截的导弹数。b[i]是拦截的第i颗导弹的高度。



------------
~~手打不易，求过呀QAQ~~~~

---

## 作者：CHNZhang (赞：5)

## 前言
这道题用DP或贪心都行，不过看题解里的DP时间复杂度都是 $O(n^2)$ ，补充一种 $O(n)$ 的方法。
如有不当之处，请指正。
## 基本思路
定义二维数组 $f[5][1005]$ 记录状态。

状态 $f[x][y]$ 表示在拦截前 $y$ 颗导弹时能拦截的最大数量。 $x=1$ 意为在前 $y$ 颗导弹中拦截奇数颗最大拦截数量； $x=0$ 意为在前 $y$ 颗导弹中拦截偶数颗最大拦截数量。

题目中提到拦截的奇数颗导弹比前一颗更高，偶数颗比前一颗更低。为了方便理解，不妨想象在输入数据之前还有一颗高度为 $0$ 的导弹，记作第 $0$ 颗。

### 状态转移方程

设当前导弹高度为 $a[i]$ ，前一颗高度为 $a[i-1]$ ,存在三种可能。

1. 当 $a[i]>a[i-1]$ 时。
- 如果在前 $i$ 颗导弹中拦截奇数颗，有两种可能。
- 如果要拦截此颗导弹，那么此颗导弹将是奇数颗被拦截的,这种情况下最大拦截数为在前 $i-1$ 颗导弹中拦截偶数颗的最大值 $+1$ ,即， $f[1][i]=f[0][i-1]+1;$
- 当然也可以不拦截这颗导弹，这种情况下最大拦截数与前     $i-1$ 拦截奇数颗的最大拦截数相等，为 $f[1][i]=f[1][i-1]; $
- 还可以在前 $i$ 颗导弹中拦截偶数颗，仅有一种可能，拦截颗数与在前i-1颗导弹中拦截偶数颗的最大值相等,即 $f[0][i]=f[0][i-1];$
2. 当 $a[i]<a[i-1]$ 时，思路与 $a[i]>a[i-1]$ 相似，不做详细说明，具体见代码。
3. 当 $a[i]==a[i-1]$ 时，在前 $i$ 颗导弹中拦截奇数或偶数颗导弹的最大值与在前 $i-1$ 颗中拦截无异,即 $f[0][i]=f[0][i-1];f[1][i]=f[1][i-1];$

由此归纳出状态转移方程，目标值为 $max(f[0][n],f[1][n]);$

## 代码
```cpp
//以下程序仅供参考，如有不当之处请指正。
#include<bits/stdc++.h>
using namespace std;
int n,f[5][1005],i,j,a[1005];//f[0][x]下降f[1][x]上升
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    //读入
    for(i=1;i<=n;i++)
    {
        if(a[i]<a[i-1])
        {
            f[0][i]=max(f[1][i-1]+1,f[0][i-1]);
            f[1][i]=f[1][i-1];
        }
        else if(a[i]>a[i-1])
        {
            f[0][i]=f[0][i-1];
            f[1][i]=max(f[0][i-1]+1,f[1][i-1]);
        }
        else
        {
            f[0][i]=f[0][i-1];
            f[1][i]=f[1][i-1];
        }//状态转移方程
    }
    cout<<max(f[0][n],f[1][n])<<endl;
    return 0;
}

```

---

## 作者：Great_Influence (赞：5)

最长震荡子序列。

其实n久以前有一道震荡子序列的题目，不过被淹没了的样子。

本题唯一的坑点就是对奇偶的要求。不过发现了就很简单了。

转移方程：

dp1[i]=dp2[j]+1(j<i&&a[j]>a[i])

dp2[i]=dp1[j]+1(j<i&&a[j]<a[i])（至于哪个dp方程是哪个，我不太记得了，自己试一下吧，一个是以i下降，一个是以i上升）

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
const int MAXN=1010;
template<typename T>
inline void read(T &x)//读入优化
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=s*f;
}
int n,a[MAXN],dp1[MAXN],dp2[MAXN];
int main()
{
    read(n);
    int i,j,ans=0;
    For(i,1,n)read(a[i]);
    fill(dp2+1,dp2+n+1,1);//赋初值
    For(i,2,n)
    {
        For(j,1,i-1)
        {
            if(a[i]>a[j]&&dp2[i]<dp1[j]+1)dp2[i]=dp1[j]+1;//n^2dp
            else if(a[i]<a[j]&&dp1[i]<dp2[j]+1)dp1[i]=dp2[j]+1;
        }
        ans=max(ans,max(dp1[i],dp2[i]));
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：yezl (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P3903)

### 题目概述：

按时间顺序给你导弹飞来时的高度，有一套导弹拦截系统，可以选择一颗导弹开始拦截，以后拦截的 **第奇数颗** 导弹比前一颗导弹 **更远、更高** ，拦截的 **第偶数颗** 导弹比前一个 **更远、更低** 。

### 思路：
本题和 [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
差不多吧，就是不同在于拦截的 **第奇数颗** 导弹比前一颗导弹 **更远、更高** ，拦截的 **第偶数颗** 导弹比前一个 **更远、更低** 。

数据量不算大，时间复杂度为 $ O(n^{2}) $ 是完全可以的，对于这种题，那就直接用DP呀。
我们就定义f1表示此发导弹比原来低，f2表示此发导弹比原来高。  
状态转移方程：  
 1. 当第i颗导弹高于第j颗导弹时，f1[i]=max(f1[i],f2[j]+1)  
 2. 当第j颗导弹高于第i颗导弹时，f2[i]=max(f2[i],f1[j]+1)

### 那我们就直接上代码：


```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1010;//定义常变量，后面直接用 
int a[N],f1[N],f2[N],ans,n;
inline int read()//快读，数据量大的话比scanf还快些
{
	int num=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		num=(num<<1)+(num<<3)+ch-'0';
		ch=getchar();
	}
	return num;
}
int main()
{
	n=read();//注：快读是这样读入的o 
	for(int i=1;i<=n;i++)
		a[i]=read();
	f1[1]=1; 
    //注意不能用memset(f1,1,sizeof(f1))直接初始化，因为它是按字节读入的
	//那样就会变成1111（二进制，int类型4个字节）
   //所以它只能用来初始化为0x7f，0x3f（极大值），0xcf（极小值）和0 。
	for(int i=2;i<=n;i++)
	{
		f1[i]=1;//每颗导弹都可以是开头，so都要1 
				
		for(int j=1;j<i;j++)//动态规划，DP//注意：这里是< 
		{
			if(a[j]<a[i])//第i颗导弹高于第j颗导弹 
				f1[i]=max(f1[i],f2[j]+1);
			if(a[j]>a[i])//第j颗导弹高于第i颗导弹 
				f2[i]=max(f2[i],f1[j]+1);
		}
		ans=max(ans,max(f1[i],f2[i]));//ans取f1，f2中最大 
	}
	printf("%d",ans);
	return 0; 
}
```

希望能帮到大家。

---

## 作者：LB_zzm (赞：3)

```cpp
# 一定要读题！！！！
一开始我没读题目的第二段，结果。。。。。。
所以读题很重要！！！！
题目就是一个简单的dp。。。。
---------------------上代码-----------------------------------------
#include<iostream>
using namespace std;
int n,a[1005],f[1005][3],ans=0;
int main() {
	cin>>n;
	f[1][1]=1;
	for(int i=1; i<=n; i++)cin>>a[i];
	for(int i=2; i<=n; i++) {
		f[i][1]=1;//本身也要算上
		for(int j=1; j<i; j++) {
			if(a[i]<a[j])f[i][0]=max(f[i][0],f[j][1]+1);//偶数颗
			if(a[i]>a[j])f[i][1]=max(f[i][1],f[j][0]+1);//奇数颗
		}
	}
	for(int i=1; i<=n; i++)ans=max(ans,max(f[i][1],f[i][0]));
	cout<<ans<<endl;
	return 0;
}
---------------------完成-------------------------------------------
```


---

## 作者：于我无关 (赞：2)

我感觉这道题比导弹拦截简单的多，可能是因为当初优化导弹拦截200考虑的比较多吧。不废话，我们需要考虑的其实只是已拦截的最后一刻导弹。为什么？给你一个5 2 8的序列，你肯定会拦截5 2 8，而不是只拦8，原因就是中间有2作为缓冲，2前面是多少对后面都不影响。不如利用一个数组保存当下可拦截的最优解（可以不用的，楼主懒得写了），然后用一个变量记录拦截的导弹数目，如果能拦截就予以拦截（毕竟我们求最多拦截多少），不能拦截就更新，以便拦截到更多。
上代码
```
#include<iostream>
using namespace std;
int a[1001];
int main() {
	int x=0,n=1,N=0;
	cin>>N;cin>>a[1];
	for (int i=2;i<=N;++i) {
		cin>>x;
		if(n%2==0) 
			if(x>a[n]) a[++n]=x;
			else a[n]=x;	
		else if(x<a[n]) a[++n]=x;
			else a[n]=x;
	}
	cout<<n;
	return 0;
} 
```

举个例子 1 5 3 8 7
第一轮  1        n=1
第二轮  5        n=1
第三轮  5 3       n=2
第四轮  5 3 8      n=3
第五轮  5 3 8 7    n=4（绝对是最多的，时间上应该也是最优的）
 第一次发题解，留个纪念

---

## 作者：zubizakeli (赞：0)

这道题其实跟dp经典问题最长上升子序列差不多，唯一的区别就在于它是升降交错的（楼下好像有同学叫它震荡序列来着，我也这么叫吧）


我的方法是开一个bool型数组，判断现在第j个数处于最优解时属于震荡序列的第奇数个还是第偶数个（是不是很简单？）


下面附上代码：







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 1000 + 1 ;
int n,m;
int c[N];
int ans[N];
int maxx;
bool b[N];    // 储存当前的每个数处于第奇数个还是第偶数个 
inline void in_()
{
    cin>>n;
    for(register int i=1;i<=n;i++)
    {
        scanf("%d",&c[i]);
        for(register int j=1;j<i;j++)
        {
          if(c[i] < c[j] && !b[j])   // 如果要选第偶数位，那么j必须是第奇数位 
          {
               if(ans[i] < ans[j]+1)
               {
                   ans[i] = ans[j]+1;
                   b[i] = 1 ;
               }
          }
          if(c[i] > c[j] && b[j])    //  如果要选第奇数位，那么j必须是第偶数位 
          {
              if(ans[i] < ans[j]+1)
              {
                  ans[i] = ans[j] + 1 ;
                  b[i] = 0 ;
              }
          }
        }
          maxx = maxx > ans[i] ? maxx : ans[i] ;
    }
}
inline void out_()
{
    printf("%d",maxx+1);   // 为什么输出要+1呢?  (因为答案所求出序列的第一个数没有被统计到啊==） 
}
int main()
{
    in_();
//    work_();
    out_();
    return 0;
}

```

---


# [Code+#3] 投票统计

## 题目描述

为了总结过去一段时间的命题工作，王队长组织了“我最喜欢的题目”评选活动，并邀请各位选手给题目进行投票。

具体来说，每道题目有一个正整数作为它的编号，一共有 $n$ 名选手给它们进行投票，每位选手投且仅投给一道题，其中第 $i$ 位选手所投票的题目编号为 $a_i$。

由于投票的选手众多，所以王队长请你来帮忙统计得票数。你需要找出收获选手投票最多的**题目数量**与**他们的编号**，并按**从小到大**的顺序列出这些编号。但这里有一个**例外情况**：如果所有被投票的题目得票数都相同，则王队长认为这次活动比较失败，你应该**输出-1**。



## 说明/提示

测试点编号|$n$的范围|$a_i$的范围|特殊约定
-|-|-|-
1|$=2000$|$\leq n$|得票数最多的题目唯一
2|同上|同上|同上
3|同上|$\leq 10^9$|同上
4|同上|$\leq n$|不会出现例外情况
5|同上|同上|同上
6|同上|$\leq 10^9$|同上
7|同上|$\leq n$|无
8|同上|同上|同上
9|同上|$\leq 10^9$|同上
10|同上|同上|同上
11|$=100000$|$\leq n$|得票数最多的题目唯一
12|同上|同上|同上
13|同上|$\leq 10^9$|同上
14|同上|$\leq n$|不会出现例外情况
15|同上|同上|同上
16|同上|$\leq 10^9$|同上
17|同上|$\leq n$|无
18|同上|同上|同上
19|同上|$\leq 10^9$|同上
20|同上|同上|同上

Credit： https://www.luogu.org/discuss/show?postid=35727

## 样例 #1

### 输入

```
3
10
2 6 1 2 1 1 2 6 7 1
10
10 3 6 6 3 10 6 6 6 2
10
8 8 10 10 10 10 8 5 8 8```

### 输出

```
1
1
1
6
1
8```

## 样例 #2

### 输入

```
3
10
1 4 3 1 8 8 7 2 8 7
10
1 10 9 1 3 2 9 9 2 1
10
4 1 5 4 1 9 5 5 4 1```

### 输出

```
1
8
2
1 9
3
1 4 5```

## 样例 #3

### 输入

```
3
10
3 3 10 8 8 3 10 8 10 3
10
2 2 8 6 8 4 2 4 4 8
10
6 2 5 6 7 5 7 10 2 10```

### 输出

```
1
3
3
2 4 8
-1
```

# 题解

## 作者：Khassar (赞：4)

这个题嘛，总的来说还是比较水的吧，签到题吧，我交的大家几乎都是1A，但题解却空空的岂不是不好。

首先$n\geq 100000$（诶!好像是$=$），$a_i\leq 10^9$，这告诉我们直接开桶和$n^2$枚举是不可以的。

他还没告诉我$T$是多少（可能是我瞎，没看见），但根据我的~~评测结果~~经验$T$是不大的。

所以我有一个~~大胆的~~想法：我们先把$a_i$都读进来，然后排个序，这样一样的票都聚在了一起，而且$a_i$还是从小到大排好了的，方便输出。  
因为一样的票都聚在了一起统计各种票都出现了几次只需要$O(n)$的扫一遍就可以了（具体实现可以看代码），这样总时间复杂度是$O(Tnlogn)$的，所以我觉的如果给我一个大点的$T$就GG了。对于输出$-1$的特殊情况，我们可以同时在$O(n)$遍历时一并记一下。

当然我的码风对除我以外的人都不太友好。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#include<set>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=100005;

int T,a[N],ans[N],cnt,s,n;//ans用来存答案

IL int read() {
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
	return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

signed main()
{
	T=read();
	while(T--) {
		s=0;cnt=0;//s记录出现过多少种票，cnt记录答案的数量
		n=read();
		Rf(i,1,n) a[i]=read();
		sort(a+1,a+1+n);a[n+1]=0;//把第n+1个赋成0强制与第n个不一样，方便一个for处理完
		R int sum=1,mx=0;//sum记录一种票已经出现过多少次,mx记录出现过的最大次数
		Rf(i,2,n+1) {//枚举到n+1，一次处理完，不用在最后再判一次
			if(a[i]!=a[i-1]) {//和前一个不一样，就是又出现了一个新的
				s++;
				if(sum>mx) {//比已知的票数最大值还要大就更新
					mx=sum;
					ans[cnt=1]=a[i-1];
				}
				else if(sum==mx) {//如果一样就会多一个答案
					ans[++cnt]=a[i-1];
				}
				sum=1;//重置计数器
			}else sum++;//否则计数器+1
		}
		if(s==cnt) {//特殊情况
			puts("-1");
			continue;
		}
		write(cnt);putchar('\n');
		Rf(i,1,cnt) {
			write(ans[i]);putchar(' ');
		}
		puts("");
	}

	return 0;
}
```

---

## 作者：Kalium (赞：3)

# P4263 [Code+#3]投票统计题解

本题解防抄袭(~~freopen~~)，文件名为歌名，是我做题的时候听的，有兴趣的听听。

## 题意：

叫你求一个数列中出现次数最多的数有几个并输出他们。

如果所有不同数出现个数一样，输出 -1。

## 思路：

第一思路，桶排。

但是看了看他是黄题，如果是桶排，那么感觉就是入门了。

所以怀着忐忑的心理我去看了看数据范围。

果不其然，不能桶排。

所以，我们得换个思路。

仔细想了想，你不让我桶排，我快排会咋滴？

当我们快排完后，再一个个匹配。

具体分为如下三种：

1.当前出现次数小于之前出现次数，不用理他。

2.当前出现次数等于之前出现次数，加入进去。

3.当前出现次数大于之前出现次数，之前的全作废，这一个加进去。

-1 的话，拿一个 different 的变量统计下最后与要输出的数的种类比较下即可。

## 代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define inf 0x3f3f3f3f

const int N = 1e5 + 7;

using namespace std;

int t, n, pro;

int a[N];

int cnt, ans[N];

inline bool cmp(int x, int y) {
	return x < y;
}

inline void keep(int x, int id) {
	if (pro < x) {
		cnt = 0;
		pro = x;
		ans[++ cnt] = id;
	} else if (x == pro)
		ans[++ cnt] = id;
	return ;
}

int main() {
	freopen("remember our summer.in", "r", stdin);
	freopen("remember our summer.in", "w", stdout);
	
	scanf("%d", &t);
	
	while (t --) {
		int sum = 1, different = 0;
		pro = 0, cnt = 0;
		
		scanf("%d", &n);
		
		for (int i = 1; i <= n; i ++)
			scanf("%d", &a[i]);
		
		sort(a + 1, a + 1 + n, cmp);
		
		for (int i = 2; i <= n + 1; i ++) {
			if (a[i] == a[i - 1])
				sum ++;
			else {
				keep(sum, a[i - 1]);
				sum = 1;
				different ++;
			}
		}
		
		if (cnt == different)
			printf("-1\n");
		else {
			printf("%d\n", cnt);
			
			for (int i = 1; i <= cnt; i ++)
				printf("%d ", ans[i]);
			
			printf("\n");
		}
	}
	
	fclose(stdin);
	fclose(stdout);
	
	return 0;
}
```

$Atlantic.$


---

## 作者：金苹果gold (赞：3)

 嗯...

首先看一下这道题。

然后看一下数据范围。

![](https://img-blog.csdnimg.cn/20201029212303997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE3MzU0MTg=,size_16,color_FFFFFF,t_70)

我意识到，事情不对！

这道题，不能直接数组模拟桶！！！

空间浪费严重！MLE是一个可怕的东西！！！

然后我想到了map！（STL太强大了！~~虽然我不怎么会用~~）

用map做桶，省空间，降内存，100000个人全投不一样的项目，也只要存100000个数据，也就是说，用map打桶，这道题就是个大水题，也就个入门难度！

然后我用入门级方法+map打起了这道题。

十分钟左右后，我打好了这道题！

提交了上去！

## AC！

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<long long,long long>m;
long long T,n,tmp,had[100010],ans[100010];
void doit()
{
	cin>>n;
	m.clear();
	bool can=false;
	memset(had,0,sizeof(had));
	memset(ans,0,sizeof(ans));
	long long cnt=0,maxn=0,tot=0;
	for(int i=1;i<=n;i++)
	{
		cin>>tmp;
		m[tmp]++;
		if(m[tmp]==1)
			had[++cnt]=tmp;
	}
	for(int i=1;i<=cnt;i++)
		maxn=max(maxn,m[had[i]]);
	for(int i=1;i<=cnt;i++)
		if(m[had[i]]==maxn)
			ans[++tot]=had[i];
		else
			can=true;
	sort(ans+1,ans+1+tot);
	if(can)
	{
		cout<<tot<<endl;
		for(int i=1;i<=tot;i++)
			cout<<ans[i]<<" ";
		cout<<endl;
	}
	else
		cout<<"-1\n";
}
int main()
{
	cin>>T;
	while(T--)
		doit();
	return 0;
}
```

[在我的CSDN博客上看更方便](https://blog.csdn.net/u011735418/article/details/109370391)

---

## 作者：Chouquet (赞：3)

两种做法：

+ 用STL的map当作桶来模拟

+ 排序+暴力

由于~~窝太蒻了~~第二种好写，所以用第二种写法~~写了半小时才过~~。

直接看~~丑陋不堪的~~代码：

```cpp
#include <stdio.h>
#include <algorithm>
int n,a[100003],b[100003],len,t,maxn,s,k;
//b存题目编号，len是题目编号的个数，maxn是最多票数，k是题目种数，s是单种题目的个数。
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);for(int i=1;i<=n;i++) scanf("%d",&a[i]);//读入
        std::sort(a+1,a+1+n);//从小到大排序，方便操作
        len=0,maxn=-(1<<30),s=k=1;//多组数据一定要赋初值！
        for(int i=2;i<=n;i++){
            if(a[i]!=a[i-1]){
                if(maxn<s) maxn=s;
                s=1;++k;
            }
            else ++s;
        }//求最多票数
        if(maxn<s) maxn=s;//按照上面的写法这句必须要有
        s=1;//后面还会用到s
        for(int i=2;i<=n;i++){
            if(a[i]!=a[i-1]){
                if(maxn==s) b[++len]=a[i-1];
                s=1;
            }
            else ++s;
        }//求题目编号的个数并存题目编号
        if(maxn==s) b[++len]=a[n];//按照上面的写法这句也必须要有
        if(len==k) printf("-1\n");//如果题目编号个数与种数相同，显然输出-1
        else{
            printf("%d\n",len);
            for(int i=1;i<=len;i++) printf("%d ",b[i]);
            puts("");
            //输出
        }
    }
    return 0;
}
```


---

## 作者：Eason_AC (赞：0)

## Content
有 $t$ 组询问，每组询问给定一个长度为 $n$ 的数列，请将出现次数最多的数按照从小到大的顺序输出，或者这些数在数列中出现的次数都相等。

**数据范围：$t$ 未知，$n\leqslant 10^5,a_i\leqslant 10^9$。**
## Solution
算是比较小清新的排序题。

我们直接用 map 开个桶，统计每个数出现的次数，然后排序看哪些数出现的次数最多，然后将这些数再次从小到大排序后输出即可，注意特判一下所有数出现的次数都相等的情况。
## Code
```cpp
int t, n, cnt, a[100007];
struct node {
	int id, val;
	bool operator < (const node& s) const {return val > s.val;}
}kk[100007];
map<int, int> vis;

void cle() {
	_for(i, 1, cnt) vis[kk[i].id] = 0, kk[i].id = 0, kk[i].val = 0;
	cnt = 0;
}

int main() {
	getint(t);
	while(t--) {
		cle();
		getint(n);
		_for(i, 1, n) {
			int x;
			getint(x);
			if(!vis[x]) kk[++cnt].id = x, kk[cnt].val++, vis[x] = cnt;
			else kk[vis[x]].val++;
		}
		int flagofallsame = 1;
		_for(i, 2, cnt) if(kk[i].val != kk[i - 1].val) {flagofallsame = 0; break;}
		if(flagofallsame) {puts("-1"); continue;}
		sort(kk + 1, kk + cnt + 1);
		int ans[100007] = {0}, ansnum = 0;
		_for(i, 1, cnt) {if(kk[i].val == kk[1].val) ans[++ansnum] = kk[i].id; else break;}
		sort(ans + 1, ans + ansnum + 1);
		printf("%d\n", ansnum);
		_for(i, 1, ansnum) printf("%d ", ans[i]);
		puts("");
	}
	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：0)

### $stl$的效率不好，不吸氧3s，吸氧1s
## $stl$的$map$是可以当数组用！下标可以是任何东西！
- map用法：

	声明像$pair$，`map<tp1,tp2>`，`tp1`和`tp2`就是$map$维护的2种类型。`tp1`是下标的类型，`tp2`是对应的值的类型。
    
    当数组用。
    
    可用`.begin`获取$map$开头地址，`.end`获取$map$的结尾地址。
- code：
	```cpp
	#include<stdio.h>
	#include<map>
	#include<vector>
	using namespace std;
	inline int read()//快读
	{
	    register int x=0;register char c=getchar();for(;c<'0'||c>'9';c=getchar());
	    for(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=getchar());return x;
	}
	int t,n,a;map<int,int>mmp;map<int,vector<int> >mmmp;vector<int>ans;
	main()
	{
	    t=read();
	    for(;t--;)
	    {
	        n=read();mmp.clear();mmmp.clear();//初始化
	        for(;n--;)a=read(),++mmp[a];//输入，a放进mmp
	        for(register map<int,int>::iterator i=mmp.begin();i!=mmp.end();++i)
	            mmmp[i->second].push_back(i->first);//mmp放进mmmp
	        if(mmmp.size()==1)puts("-1");//都是一样，-1
	        else
	        {
	            register map<int,vector<int> >::iterator i=mmmp.end();--i;
	            //map是升序，最后一个是最大的（end指的是最后一个的后面，还要--）
	            ans=i->second;//找到答案辣！
	            printf("%d\n",ans.size());//输出个数
	            for(register int i=0;i<ans.size();++i)printf("%d ",ans[i]);
	            putchar('\n');//要回车
	        }
	    }
	}/**/
	```

---


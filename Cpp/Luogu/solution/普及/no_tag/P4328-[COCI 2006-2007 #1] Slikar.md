# [COCI 2006/2007 #1] Slikar

## 题目描述

邪恶的皇帝 Cactus 拥有魔法酒桶，并且已经淹没了魔法森林！画家和三只小刺猬现在必须尽快返回到海狸的巢穴，以免被水淹没！魔法森林的地图由 R 行 C 列组成。空地用字符 '.' 表示，淹没的区域用 '*' 表示，岩石用 'X' 表示。此外，海狸的巢穴用 'D' 表示，画家和三只小刺猬用 'S' 表示。每分钟，画家和三只小刺猬可以移动到四个相邻的区域（上、下、左或右）。每分钟，洪水也会扩散，使得所有与淹没区域至少有一个公共边的空地也被淹没。水和画家及三只小刺猬都不能穿过岩石。当然，画家和三只小刺猬不能穿过淹没的区域，水也不能淹没海狸的巢穴。编写一个程序，给定魔法森林的地图，输出画家和三只小刺猬安全到达海狸巢穴所需的最短时间。注意：画家和三只小刺猬不能移动到即将在同一分钟被淹没的区域。

## 说明/提示

对第二个样例测试的说明：他们能做的最好就是沿着下边界走，然后沿着左边界走，并在到达巢穴前一分钟被淹没。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3 3
D.*
...
.S.```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3
D.*
...
..S```

### 输出

```
KAKTUS```

## 样例 #3

### 输入

```
3 6
D...*.
.X.X..
....S.```

### 输出

```
6```

# 题解

## 作者：昨日之日 (赞：9)

这道题如果不考虑洪水的话，就是一道裸的bfs。

加了这个洪水之后只需要处理洪水到达每一个格子的最早时间，在广搜过程中如果遇到有现在的时间大于等于这个格子的洪水到达时间就直接扔掉。

需要注意的是在处理洪水的时候如果当前是避难所或者障碍物就不能加入队列。

另外一个坑点就是会有多个出洪水的点，所以洪水要先赋值成一个很大的值，再用min更新而不是直接赋值。

当时考试的时候没想仔细，其实这里也可以把所有出水点都加入队列，然后再搜索，这样时间复杂度会小很多。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[55][55];
int fx[4][2]={1,0,0,1,-1,0,0,-1};
struct node {
	int x;
	int y;
	int cnt;//当前的时间
};
int water[55][55];
bool h_used[55][55];
queue <node> Water;
node startt,endd;
queue <node> Q;
node X[2505];
int xid;
void Water_Bfs(){
	while(!Water.empty()){
		node noww=Water.front();
		Water.pop();
		noww.cnt++;
		for(int i=0;i<4;i++){
			node _next=noww;
			_next.x+=fx[i][0],_next.y+=fx[i][1];
			if(_next.x<1||_next.y<1||_next.x>n||_next.y>m)continue;
			if(h_used[_next.x][_next.y])continue;
			water[_next.x][_next.y]=min(water[_next.x][_next.y],_next.cnt);
			Water.push(_next);
			h_used[_next.x][_next.y]=1;
		}
	}
}
void Ans_Bfs(){
	Q.push(startt);
	while(!Q.empty()){
		node noww=Q.front();
		Q.pop();
		if(water[noww.x][noww.y]<=noww.cnt)
			continue;
		if(noww.x==endd.x&&noww.y==endd.y){
			cout<<noww.cnt;
			return;
		}
		noww.cnt++;
		for(int i=0;i<4;i++){
			node _next=noww;
			_next.x+=fx[i][0],_next.y+=fx[i][1];
			if(_next.x<1||_next.y<1||_next.x>n||_next.y>m)continue;
			if(h_used[_next.x][_next.y])continue;
			if(a[_next.x][_next.y]=='X')continue;
			Q.push(_next);
			h_used[_next.x][_next.y]=1;
		}
	}
	cout<<"KAKTUS";
}
int main(){
	memset(water,127,sizeof(water));
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>a[i][j];
			if(a[i][j]=='S'){
				startt.x=i;
				startt.y=j;
				startt.cnt=0;
			}
			if(a[i][j]=='D'){
				endd.x=i;
				endd.y=j;
			}
			if(a[i][j]=='X'){
				X[xid].x=i;
				X[xid++].y=j;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='*'){
				node w;
				w.x=i;
				w.y=j;
				w.cnt=0;
				Water.push(w);
				water[i][j]=0;
				memset(h_used,0,sizeof(h_used));
				h_used[endd.x][endd.y]=1;
				for(int k=0;k<xid;k++){
					h_used[X[k].x][X[k].y]=1;
				}
				Water_Bfs();
			}
		}
	}
	water[endd.x][endd.y]=1e8;
	memset(h_used,0,sizeof(h_used));
	h_used[startt.x][startt.y]=1;
	Ans_Bfs();
}
```


---

## 作者：MY（一名蒟蒻） (赞：6)

[原题传送门](https://www.luogu.com.cn/problem/P4328)

这题还是挺坑的，有一些细节。

先讲思路。

---
**这题本质上是最短路。**

先处理出洪水到达每个格子需要的最短时间，然后广搜出答案。

怎么广搜相信不用我说了，如果您没有学过的话可以写一下[这题](https://www.luogu.com.cn/problem/P2298)，这题我有写过[题解](https://www.luogu.com.cn/blog/nizhuan/solution-p2298)。其中有对广搜的介绍。

那么问题剩下怎样处理出**洪水到达每个格子需要的最短时间**。

一开始我想利用广搜**搜到即最短**的特性处理。但由于这题有**多处有洪水**，所以我[WA](https://www.luogu.com.cn/record/list?pid=P4328&user=240191&status=14&page=1)了许多次。

想到SPFA。~~就是那个已死的算法。~~

**算法流程：**
1. 从起点开始，把拓展到的点修改min值，如果可以被修改，将该节点入队并打标记。
2. 队头出队，取消标记。

实际上就是**每次仅对最短路估计值发生变化的顶点的所有出边进行松弛操作**。

具体实现看代码吧。

### Code
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>

using namespace std;

int n,m,dis[60][60],sx,sy,nex[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
char blood[60][60];
bool vis[60][60];
struct node {int x,y,step;};
queue <node> q;

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf(" %c",&blood[i][j]);
			if(blood[i][j] == 'S')//记录起点位置
			{
				sx=i;
				sy=j;	
			}
			dis[i][j]=1e9;//初始化最短路
			if(blood[i][j] == '*')
			{
				q.push((node) {i,j,0});
				dis[i][j]=0; 
				vis[i][j]=true;
			}
		}
	while(!q.empty())//打步数表 
	{
		for(int i=0,nx,ny;i<4;i++)
		{
			nx=nex[i][0]+q.front().x;
			ny=nex[i][1]+q.front().y;
			if(nx < 1 || nx > n || ny < 1 || ny > m) continue ;
			if(blood[nx][ny] == 'X' || blood[nx][ny] == 'D' || vis[nx][ny]) continue ;//障碍和终点淹不掉
			if(q.front().step+1 < dis[nx][ny])//SPFA
			{
				vis[nx][ny]=true;
				dis[nx][ny]=q.front().step+1;
				q.push((node) {nx,ny,dis[nx][ny]});
			}
		}
		vis[q.front().x][q.front().y]=false;//SPFA特征操作
		q.pop();
	}

	q.push((node) {sx,sy,0});//起点入队
	vis[sx][sy]=true;
	while(!q.empty())
	{
		for(int i=0,nx,ny;i<4;i++)
		{
			nx=nex[i][0]+q.front().x;
			ny=nex[i][1]+q.front().y;
			if(nx < 1 || nx > n || ny < 1 || ny > m) continue ;
			if(blood[nx][ny] == 'X' || vis[nx][ny] || q.front().step+1 >= dis[nx][ny]) continue ;
			if(blood[nx][ny] == 'D') return printf("%d",q.front().step+1),0;//找到直接输出答案
			vis[nx][ny]=true;
			q.push((node) {nx,ny,q.front().step+1});
		}
		q.pop();
	}
	printf("KAKTUS");//找不到无解
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```
##### [点开有惊喜](https://www.luogu.com.cn/problem/SP13076)
## Thank you for your reading!

---

## 作者：hensier (赞：4)

这道题考察了$\text{BFS}$的用法。然而这种算法在本题需要使用两次——第一次是洪水的蔓延，第二次是路径的搜索。

对于字符形式的地图，本蒟蒻习惯用$\text{int}$与之对应保存。本文字符对应关系如下：

|字符|数值|注释|
| :----------: | :----------: | :----------: |
|$\text S$|$-$|起点|
|$\text D$|$-2$|巢穴（终点）|
|$\text X$|$-$|障碍点|
|$\text *$|$-1$|洪水源头|
|$\text .$|$1$|平地|

其中，$\text{S}$和$\text{X}$均保留默认，即$0$。

为了加快读入的速度，不妨使用$\text{getchar()}$函数。为了避免$\text{char(13)+char(10)}$的恶心数据，我们可以不停地读入字符，直到读入的字符是地图中的合法字符为止。

```cpp
scanf("%d%d",&r,&c);
for(int i=1;i<=r;i++)
{
    for(int j=1;j<=c;j++)
    {
        char ch=getchar();
        while(ch!='D'&&ch!='S'&&ch!='X'&&ch!='.'&&ch!='*')ch=getchar();
        switch(ch)//对地图字符进行讨论
        {
            case 'S':
            {
                //(sx,sy)为初始坐标
                sx=i;
                sy=j;
                break;
            }
            case 'D':
            {
                maps[i][j]=-2;
                break;
            }
            case 'X':break;//由于全局变量初始数值为0，因此不需要赋值
            case '*':
            {
                maps[i][j]=-1;
                break;
            }
            case '.':
            {
                maps[i][j]=1;
                break;
            }
        }
    }
}
```

接着，我们将开始模拟洪水蔓延的事件。不妨用一个二维数组$\text{flood}_{i,j}$保存。

初始情况下，我们可以认为没有格子被洪水淹没，所以时间可以视为$\inf$，即：

```cpp
memset(flood,0x3f,sizeof(flood));
```

接着，我们建立一个二维循环，只要对应数值为$-1$（即洪水源头）就开始搜索，标记淹没时间：

```cpp
for(int i=1;i<=r;i++)
{
    for(int j=1;j<=c;j++)
    {
        if(maps[i][j]!=-1)continue;
        drown(i,j);//执行搜索函数，接下来会说明
    }
}
```

编写模拟洪水蔓延的搜索函数：

```cpp
struct node
{
    int x,y,step;
}q[2501];
void drown(int x,int y)
{
    memset(vis,false,sizeof(vis));//由于要执行多次，因此把vis数组全部置为未访问
    front=rear=1;//头尾指针均设定为1
    flood[x][y]=0;//洪水源头处必定在0时刻产生洪水
    q[1]=(node){x,y,0};//初始状态为洪水源头坐标和步数0
    while(front<=rear)
    {
        node f=q[front++];//保存元素并出队
        for(int i=0;i<4;i++)
        {
            int nx=f.x+dx[i],ny=f.y+dy[i];//保存下一坐标
            if(nx<1||ny<1||nx>r||ny>c||vis[nx][ny]||maps[nx][ny]==-2||!maps[nx][ny])continue;
            /*
            出现下列情况将无法拓展：
            1. 超出地图边界
            2. 该坐标已被访问过
            3. 该坐标为巢穴（终点）
            4. 该坐标为障碍物
            注意！即使障碍物无法到达，也要防止继续拓展。
            */
            vis[nx][ny]=true;//标记访问
            q[++rear]=(node){nx,ny,f.step+1};//入队
            flood[nx][ny]=min(flood[nx][ny],q[rear].step);//取之前时间和现在时间的最小值，作为该处被淹没的时间
        }
    }
}
```

这样一来，我们就可以开始搜索来寻找路径了。队列可和前面的合用。

```cpp
void solve(int x,int y)
{
    memset(vis,false,sizeof(vis));
    front=rear=1;
    q[1]=(node){x,y,0};
    while(front<=rear)
    {
        node f=q[front++];
        for(int i=0;i<4;i++)
        {
            int nx=f.x+dx[i],ny=f.y+dy[i];
            if(nx<1||ny<1||nx>r||ny>c||vis[nx][ny]||!maps[nx][ny]||f.step+1>=flood[nx][ny])continue;
            /*
            出现下列情况将无法拓展：
            1. 超出地图边界
            2. 该坐标已被访问过
            3. 该坐标为障碍物
            4. 该坐标已被洪水淹没
            */
            vis[nx][ny]=true;
            q[++rear]=(node){nx,ny,f.step+1};
            if(maps[nx][ny]==-2)//判断是否到达巢穴（终点）
            {
                printf("%d",q[rear].step);
                exit(0);
                //输出最少步数并直接退出整个程序
            }
        }
    }
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
int r,c,front,rear,sx,sy,maps[51][51],flood[51][51],dx[]={-1,0,0,1},dy[]={0,-1,1,0};
bool vis[51][51];
struct node
{
    int x,y,step;
}q[2501];
void drown(int x,int y)
{
    memset(vis,false,sizeof(vis));
    front=rear=1;
    flood[x][y]=0;
    q[1]=(node){x,y,0};
    while(front<=rear)
    {
        node f=q[front++];
        for(int i=0;i<4;i++)
        {
            int nx=f.x+dx[i],ny=f.y+dy[i];
            if(nx<1||ny<1||nx>r||ny>c||vis[nx][ny]||maps[nx][ny]==-2||!maps[nx][ny])continue;
            vis[nx][ny]=true;
            q[++rear]=(node){nx,ny,f.step+1};
            flood[nx][ny]=std::min(flood[nx][ny],q[rear].step);
        }
    }
}
void solve(int x,int y)
{
    memset(vis,false,sizeof(vis));
    front=rear=1;
    q[1]=(node){x,y,0};
    while(front<=rear)
    {
        node f=q[front++];
        for(int i=0;i<4;i++)
        {
            int nx=f.x+dx[i],ny=f.y+dy[i];
            if(nx<1||ny<1||nx>r||ny>c||vis[nx][ny]||!maps[nx][ny]||f.step+1>=flood[nx][ny])continue;
            vis[nx][ny]=true;
            q[++rear]=(node){nx,ny,f.step+1};
            if(maps[nx][ny]==-2)
            {
                printf("%d",q[rear].step);
                exit(0);
            }
        }
    }
}
int main()
{
    memset(flood,0x3f,sizeof(flood));
    scanf("%d%d",&r,&c);
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            char ch=getchar();
            while(ch!='D'&&ch!='S'&&ch!='X'&&ch!='.'&&ch!='*')ch=getchar();
            switch(ch)
            {
                case 'S':
                {
                    sx=i;
                    sy=j;
                    break;
                }
                case 'D':
                {
                    maps[i][j]=-2;
                    break;
                }
                case 'X':break;
                case '*':
                {
                    maps[i][j]=-1;
                    break;
                }
                case '.':
                {
                    maps[i][j]=1;
                    break;
                }
            }
        }
    }
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            if(maps[i][j]!=-1)continue;
            drown(i,j);
        }
    }
    solve(sx,sy);
    puts("KAKTUS");
    return 0;
}
```

---

## 作者：OnlyU (赞：4)

这是一道典型的BFS水题。我们只需用两个BFS，一个算平地被水淹没的时间，另一个算走的时间就好了，思路还是非常好想的，代码也不难实现。
下为AC完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,m;
int sx,sy,ex,ey;
int v[51][51];
char maze[51][51];
int a[51][51];
int dx[4]= {-1,1,0,0},dy[4]= {0,0,-1,1};
int ans=1000;
struct bfc {
    int x,y,t;
} k,b,c;
queue<bfc>q;
void bfs1() {
    while(!q.empty()) {
        b=q.front();
        q.pop();
        for(int i=0; i<4; i++) {
            c.x=b.x+dx[i];
            c.y=b.y+dy[i];
            c.t=b.t+1;
            if(c.x>=1&&c.x<=r&&c.y>=1&&c.y<=m&&maze[c.x][c.y]=='.'&&v[c.x][c.y]==0) {
                v[c.x][c.y]=1;
                if(a[c.x][c.y]>c.t)
                a[c.x][c.y]=c.t;
                q.push(c);
            }
        }
    }
    return;
}
void bfs2() {
    queue<bfc>que;
    memset(v,0,sizeof(v));
    k.x=sx;
    k.y=sy;
    k.t=0;
    que.push(k);
    while(!que.empty()) {
        b=que.front();
        que.pop();
        for(int i=0; i<4; i++) {
            c.x=b.x+dx[i];
            c.y=b.y+dy[i];
            c.t=b.t+1;
            if(c.x==ex&&c.y==ey)
                ans=min(ans,c.t);
            if(c.x>=1&&c.x<=r&&c.y>=1&&c.y<=m&&a[c.x][c.y]>c.t&&maze[c.x][c.y]=='.'&&v[c.x][c.y]==0) {
                v[c.x][c.y]=1;
                que.push(c);
            }
        }
    }
    return;
}
int main() {
    cin>>r>>m;
    for(int i=1; i<=r; i++) {
        for(int j=1; j<=m; j++) {
            cin>>maze[i][j];
            if(maze[i][j]=='D') {
                ex=i;
                ey=j;
            }
            if(maze[i][j]=='S') {
                sx=i;
                sy=j;
            }
            if(maze[i][j]=='*') {
                k.x=i;
                k.y=j;
                k.t=0;
                q.push(k);
            }
        }
    }
    memset(a,100,sizeof(a));
    bfs1();
    bfs2();
    if(ans==1000)
        cout<<"KAKTUS";
    else
        cout<<ans;
    return 0;
}
```


---

## 作者：Khassar (赞：4)

题目大意：求一条$S$到$D$的最短路，但是有两种障碍：不会动的$X$和不断扩张的$*$。

如果没有$*$直接$bfs$一遍就可以了。但是有了会扩张的洪水一起竞争...其实还是一样。

我们可以先$bfs$一遍记下洪水扩张到各个点的时间，再$bfs$找路时看一下时间有没有到就可以了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#include<set>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=105,inf=1e7;

int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
int n,m,a[N][N],dis[N][N],vis[N][N],sx,sy,tx,ty;
char s[N];
queue <int> q1,q2,q3;

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}


signed main()
{
	n=read();m=read();
	MES(dis,127/3);MES(vis,127/3);
	Rf(i,1,n) {
		scanf("%s",s+1);
		Rf(j,1,m) {
			if(s[j]=='S') {
				sx=i;sy=j;
			}
			if(s[j]=='*') {
				q1.push(i);q2.push(j);
				vis[i][j]=0;
			}
			if(s[j]!='X') {
				a[i][j]=1;
			}
			if(s[j]=='D') {
				tx=i;ty=j;
				a[i][j]++;
			}
		}
	}
	while(!q1.empty()) {
		R int nx=q1.front(),ny=q2.front();q1.pop();q2.pop();
		Rf(i,0,3) {
			R int x=nx+dx[i],y=ny+dy[i];
			if(a[x][y]==1&&vis[x][y]>vis[nx][ny]+1) {
				vis[x][y]=vis[nx][ny]+1;
				q1.push(x);q2.push(y);
			}
		}
	}
	q1.push(sx);q2.push(sy);dis[sx][sy]=0;
	while(!q1.empty()) {
		R int nx=q1.front(),ny=q2.front();q1.pop();q2.pop();
		Rf(i,0,3) {
			R int x=nx+dx[i],y=ny+dy[i];
			if(a[x][y]&&dis[nx][ny]+1<vis[x][y]&&dis[x][y]>dis[nx][ny]+1) {
				dis[x][y]=dis[nx][ny]+1;
				q1.push(x);q2.push(y);
			}
		}
	}
	if(dis[tx][ty]>inf) puts("KAKTUS");
	else write(dis[tx][ty]);
    return 0;
}


```

---

## 作者：UperFicial (赞：1)

# 水 $bfs$

### 前言

新手练习搜索好题，难度很简单，建议评橙。

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P4328)

~~顺便无耻地求一波互关~~

### 题目大意

给定 $r\times c$ 的矩阵，每个点是以下字符中的一种：

- `.` 空地：啥都没有。

- `*` 喷水口：从这里往外发射洪水，洪水每秒会淹没周围 $4$ 联通的平地。

- `S` 终点：这里不会有洪水进来。

- `D` 起点：小刺猬出发的地方。

- `X` 障碍物：小刺猬和洪水都无法到达这个点。

小刺猬每秒会向周围 $4$ 联通的没有障碍物且还没被的淹没的点移动，问最小时间，如无法到达，输出 `KAKTUS`。

~~tm是真的长，还不如自己去看题面~~

### 解题思路

显然没有洪水的干预就是个单纯的 $bfs$ 模板，但加上洪水这个东西后其实也不难办。

可能有人会想一边跑小刺猬的最短路一边来判断洪水，除非您有高超的代码码力和~~卡常技术~~才有可能 $AC$。

所以可以考虑**预处理**出每个点它被洪水淹没的时间，这样一来，就把最短路和洪水的判断给隔开了！

问题又来了，如何判断淹没时间？不难想到，把每个出水口都当做起点并塞到队列里，然后对于每一个拓展到的节点都更新它的时间，最后只要在最短路时特判一下就 $OK$ 了。

```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;
const int MAXN=60;
const int dx[5]={0,1,0,-1,0};
const int dy[5]={0,0,1,0,-1};
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
} 
int n,m;
int sx,sy;
struct node
{
	int x,y,dis;
	node(int x,int y,int dis):x(x),y(y),dis(dis){}
};
queue<node>q;
char mapp[MAXN][MAXN];
bool vis[MAXN][MAXN];
int dis[MAXN][MAXN];
void bfs()
{
	memset(dis,0x3f,sizeof(dis));
	while(!q.empty())
	{
		node now=q.front();
		q.pop();
		for(register int i=1;i<=4;i++)
		{
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(mapp[xx][yy]=='D') dis[xx][yy]=1e9;
			if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&!vis[xx][yy]&&mapp[xx][yy]!='X'&&mapp[xx][yy]!='D')
			{
				dis[xx][yy]=min(dis[xx][yy],now.dis+1);
				vis[xx][yy]=true;
				q.push(node(xx,yy,now.dis+1));
			}
		}
	}
}
void bfs2(int x,int y)
{
	while(!q.empty()) q.pop();
	memset(vis,false,sizeof(vis));
	vis[x][y]=true;
	q.push(node(x,y,0));
	while(!q.empty())
	{
		node now=q.front();
		q.pop();
		if(mapp[now.x][now.y]=='D')
		{
			printf("%d\n",now.dis);
			return;
		}
		for(register int i=1;i<=4;i++)
		{
			
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&vis[xx][yy]==0&&dis[xx][yy]>(now.dis+1)&&mapp[xx][yy]!='X')
			{
//				printf("%d %d\n",xx,yy);
				vis[xx][yy]=true;
				q.push(node(xx,yy,now.dis+1));
			}
		}
	}
	puts("KAKTUS");
	return;
}
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
		{
			cin>>mapp[i][j];
			if(mapp[i][j]=='S') 
			{
				sx=i,sy=j;
				continue;
			}
			else
			{
				if(mapp[i][j]=='*')
				{
					q.push(node(i,j,0));
					vis[i][j]=true;
				}
			}
		}
    bfs();
    bfs2(sx,sy);
    return 0;
}
```

这题其实跟[$\text{P1332 血色先锋队}$](https://www.luogu.com.cn/problem/P1332)，非常像，只不过把洪水口换成了感染源。

$$\texttt{The End.by UF}$$



---

## 作者：CrazyDance (赞：1)

## [~~传送门~~](https://www.luogu.org/problem/P4328)

就是有一个地图里，只有五种字符

- $'.'$：空地，水和刺猬都可以经过。

- $'X'$:障碍物，水和刺猬都不能经过。

- $'*'$：洪水，每一时刻会向四周蔓延。

- $'S'$：起点。

- $'D'$：终点，同样，水也不能经过。

然后，我们设一下三个东西：

- $map_{i,j}$：地图上点$[i][j]$的字符

- $vis_{i,j}$：点$[i][j]$去过没有（0表示没走过，1表示走过了）

- $time_{i,j}$：点$[i][j]$被洪水覆盖的时间

然后，我们就能跑两遍$BFS$，第一次更新$time_{i,j}$，第二次就是求答案。

上代码了（不懂可以看注释）：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define N 60
using namespace std;
struct Queue
{
	int x,y;
};
struct Way
{
	int x,y,time;
};
queue<Queue>q;//洪水蔓延的队列 
queue<Way>b;//刺猬回家的队列 
int n,m,time[N][N],dx[]={0,1,-1,0},dy[]={1,0,0,-1};
bool vis[N][N];
char map[N][N];
int main()
{
	memset(time,0x3f3f3f,sizeof time);//初值无限大，否则60分 
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) 
	{
		scanf("%s",map[i]+1);//独特的读入方式 
		for (int j=1;j<=m;j++) 
		{
			if (map[i][j]=='*')//立刻入队 
			{
				Queue t=(Queue){i,j};
				q.push(t);
				time[i][j]=0;
				vis[i][j]=1;
			}
			if (map[i][j]=='S')//立刻入队 
			{
				Way t=(Way){i,j,0};
				b.push(t);
			}
		}
	}
	for (;!q.empty();)
	{
		Queue T=q.front();
		q.pop();
		for (int i=0;i<4;i++)
		{
			int x=T.x+dx[i],y=T.y+dy[i];
			if (x>0&&x<=n&&y>0&&y<=m&&!vis[x][y]&&map[x][y]!='X'&&map[x][y]!='D')//判断下一个点是否合法 
			{//入队 
				Queue t=(Queue){x,y};
				q.push(t);
				time[x][y]=time[T.x][T.y]+1;
				vis[x][y]=1;
			}
		}
	}
	memset(vis,0,sizeof vis);//别忘了更新 
	for (;!b.empty();)
	{
		Way T=b.front();
		b.pop();
		for (int i=0;i<4;i++)
		{
			int x=T.x+dx[i],y=T.y+dy[i],z=T.time;
			if (x>0&&x<=n&&y>0&&y<=m&&map[x][y]!='X'&&z+1<time[x][y]&&!vis[x][y])//判断下一个点是否合法 
			{//入队
				Way t=(Way){x,y,z+1};
				b.push(t);
				vis[x][y]=1;
				if (map[x][y]=='D')//一旦找到，就一定是最优的，立刻输出，结束程序 
				{
					printf("%d",z+1);
					return 0;
				}
			}
		}
	}
	puts("KAKTUS");
	return 0;
}
```

---

## 作者：Argon_Cube (赞：0)

* **【题目链接】**

[Link:P4328](https://www.luogu.com.cn/problem/P4328)

* **【解题思路】**

只要是这种数据范围不能$DFS$的迷宫，第一时间就能想到$BFS$。

岩石是普通障碍物，如果忽略洪水都可以直接套个模板过来了。

但是，会扩张的洪水如何处理？

记录下洪水到达每个格子的最短时间，如果在搜索过程中当前的时间大于或等于洪水到达这格的时间，就不必再往下搜了。

根据这个思路，我们已经可以写出基本框架了。

**但是，细节还是有的！**

~~不过有可能你的程序不需要注意这些。~~

1. 每个格子的洪水到达时间要先赋值成一个很大的数（大于格子总数），而不是$0$，因为洪水可能根本不会到达这一格，如果赋值成$0$那么程序就会误判成该点无法通过。

2. 记录格子已被搜过要在加入队列时标记，不然这个格子可能会被上下左右的相邻的格子重复加入队列，导致许多不必要的重复搜索。

3. 洪水出水点初值要赋值成$0$，否则时间会被误判，搞不好还会造成溢出。

* **【实现细节】**

代码为`point`结构重载了运算符，并加上了判断出界的函数，简化代码，让思路更清晰。

为这个结构设计了构造函数，使之可以使用列表初始化语法。

为什么不设计成类呢？因为类默认访问权限为私有，而结构默认访问权限是公有，而`point`里的函数与成员均应为公有。

定义了一个宏，以简化二维数组的下标表示。

* **【代码】**

```cpp
#include <iostream>
#include <queue>

using namespace std;

#define bdpr(prpoint) [prpoint.x][prpoint.y]//简化下标表示宏

struct point
{
	short x,y,step=0;
	point(short a=0,short b=0,short c=0):x(a),y(b),step(c) {}
	point operator+=(point&& that)//重载加法赋值运算符，表示移动
	{
		return {x+=that.x,y+=that.y};
	}
	point operator-=(point&& that)//重载减法赋值运算符，表示还原
	{
		return {x-=that.x,y-=that.y};
	}
	bool operator==(const point& that)//重载等于关系运算符，用于判断两个点是否相等
	{
		return x==that.x&&y==that.y;
	}
	bool is_out(const int& line,const int& row)//判断出界函数
	{
		return (x<0||x>=line||y<0||y>=row);
	}
};

int main(int argc,char *argv[],char *env[])
{
	int line,row;
	const signed char movex[4]={1,-1,0,0},movey[4]={0,0,1,-1};
	cin>>line>>row;
	short wtime[line][row];//洪水到达时间
	for(int i=0;i<line;i++)//细节1
		for(int j=0;j<row;j++)
			wtime[i][j]=32767;
	point stpos,edpos;//起点与终点
	queue<point> wtlist;
	char chunk[line][row];//地图
	for(int i=0;i<line;i++)//读入并根据本格内容处理变量初值
		for(int j=0;j<row;j++)
		{
			cin>>chunk[i][j];
			switch(chunk[i][j])
			{
				case 'S':
					stpos={i,j,0};
					break;
				case 'D':
					edpos={i,j,0};
					break;
				case '*':
					wtlist.push({i,j,0});
					wtime[i][j]=0;//细节3
					break;
			}
		}
	point tmp;
	while(!wtlist.empty())
	{
		for(int i=0;i<4;i++)
			if(!(wtlist.front()+={movex[i],movey[i]}).is_out(line,row)
				&&chunk bdpr(wtlist.front())!='X'
				&&chunk bdpr(wtlist.front())!='D'
				&&chunk bdpr(wtlist.front())!='*'
				&&wtime bdpr(wtlist.front())==32767)
			{
				wtlist.push(wtlist.front());
				tmp=wtlist.front();
				wtlist.front()-={movex[i],movey[i]};
				wtime bdpr(tmp)=wtime bdpr(wtlist.front())+1;
			}
			else
				wtlist.front()-={movex[i],movey[i]};
		wtlist.pop();
	}
	wtlist.push(stpos);
	while(!wtlist.empty())
	{
		if(wtlist.front()==edpos)
		{
			cout<<wtlist.front().step;
			return 0;
		}
		wtlist.front().step++;
		for(int i=0;i<4;i++)
			if(!(wtlist.front()+={movex[i],movey[i]}).is_out(line,row)
				&&chunk bdpr(wtlist.front())!='\0'
				&&chunk bdpr(wtlist.front())!='X'
				&&chunk bdpr(wtlist.front())!='*'
				&&wtlist.front().step<wtime bdpr(wtlist.front()))
			{
				wtlist.push(wtlist.front());
				wtime bdpr(wtlist.back())='\0';//细节2
				wtlist.front()-={movex[i],movey[i]};
			}
			else
				wtlist.front()-={movex[i],movey[i]};
		chunk bdpr(wtlist.front())='\0';
		wtlist.pop();
	}
	cout<<"KAKTUS";
 	return 0;
}
```

---

## 作者：crh1272336175 (赞：0)

这是一个很基础的宽搜题（bfs），我们只需要bfs2次即可


为什么要2次呢？因为比起一般的宽搜，这个题目有以下2个特点

1.有阻碍物（石头）
2.有另外的限制条件（洪水）

所以我们需要先bfs一遍，把地图上每一个点被洪水淹没的时间，用一个t数组记录下来

那么再bfs第二遍（人走的路）的时候，我们只要比较t[i][j]和到达当前点的时间就可以了

如果前者大于后者，则说明洪水到达的时间比人到达的要晚，那么就是可以走的；反之则是不能走

话不多说，来看看具体代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=55;
int n,m,sx,sy,ex,ey,ans=0x3f3f3f3f;
char str[M][M];
int t[M][M],visited[M][M];//t用于记录洪水到达某个点的时间 
int dx[]={-1,1,0,0};
int dy[]={0,0,-1,1};//上下左右 
struct flood
{
	int x,y,t;//坐标和洪水到达的时间 
	flood(const int &x,const int &y, const int &t):x(x),y(y),t(t){}
};
queue<flood> qriver,q;
void bfs_water()
{
	while(!qriver.empty())
	{
		flood now=qriver.front(); qriver.pop();
		for(int i=0; i<4; i++)
		{
			int nx=now.x+dx[i],ny=now.y+dy[i];
			if(nx>=1 && nx<=n && ny>=1 && ny<=m)//判断边界
				if(str[nx][ny]=='.' && !visited[nx][ny])//能走得通且没访问过'
				{
					visited[nx][ny]=1;
					if(t[nx][ny]>now.t+1) t[nx][ny]=now.t+1;
					qriver.push(flood{nx,ny,now.t+1});
				}	
		}
	}
}
void bfs_person()
{
	memset(visited,0,sizeof visited);
	q.push(flood{sx,sy,0});
	while(!q.empty())
	{
		flood now=q.front(); q.pop();
		for(int i=0; i<4; i++)
		{
			int nx=now.x+dx[i],ny=now.y+dy[i];
			if(nx==ex && ny==ey)
			    ans=min(ans,now.t+1); 
			if(nx>=1 && nx<=n && ny>=1 && ny<=m)//判断边界
				if(str[nx][ny]=='.' && t[nx][ny]>now.t+1&& !visited[nx][ny])//能走得通且没访问过
				{
					visited[nx][ny]=1;
					if(t[nx][ny]>now.t+1) t[nx][ny]=now.t+1;
					q.push(flood{nx,ny,now.t+1});
				}	
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)
	{
		scanf("%s",str[i]+1);
		for(int j=1; j<=m; j++)
		{
			char c=str[i][j];
			if(c=='S') sx=i,sy=j;
			else if(c=='D') ex=i,ey=j;
			else if(c=='*') qriver.push(flood{i,j,0});
		}
	}
    memset(t,0x3f3f3f3f,sizeof t);
	bfs_water();
	bfs_person();
	if(ans==0x3f3f3f3f) puts("KAKTUS");
	else printf("%d\n",ans);
	return 0;
}
```


---

## 作者：LlLlCc (赞：0)

一道典型的BFS~~水~~题，相信大家起点到终点的最短路，和处理障碍物"x"，是没有问题的

唯一与BFS练习题不同的地方就是如何处理洪水的问题了。我们先思考一下怎么判断当前位置有没有洪水呢？每走一步就模拟扩散一次洪水吗？这样可能有点麻烦，而且时间复杂度较大（~~随意n，m只有50，怎么写都不会超~~）。

现在，我们来想想洪水与刺猬移动有什么关系。先问的大家一个小问题，洪水会因为刺猬的走向而改变扩散的位置吗？

显而易见，洪水的扩散是不会受刺猬走动影响的。那么我们只要先预处理一遍洪水到达各点的时间，再用BFS刷一趟起点到终点的最短路即可。

代码：

```
#include<bits/stdc++.h>
#define maxn 505
using namespace std;
const int flg[4][2]={{0,-1},{1,0},{0,1},{-1,0}};
int n,m,ans,a[maxn][maxn],x,y,xx,yy;
char s[maxn][maxn];
bool vis[maxn][maxn];
struct lc{
	int x,y,z;
}Q[maxn*maxn];
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
inline bool check_(int x,int y){if (x<1||x>n||y<1||y>m||vis[x][y]||s[x][y]!='.') return 0;vis[x][y]=1;return 1;}
inline void Bfs_(int x,int y){
	int hed=0,til=1;
	Q[1].x=x,Q[1].y=y,Q[1].z=0;
	memset(vis,0,sizeof vis);
	while (hed<=til){
		hed++;
		for (int i=0;i<4;i++){
			if (!check_(Q[hed].x+flg[i][0],Q[hed].y+flg[i][1])) continue;
		    Q[++til].x=Q[hed].x+flg[i][0],Q[til].y=Q[hed].y+flg[i][1],Q[til].z=Q[hed].z+1;
		    if (a[Q[til].x][Q[til].y]) a[Q[til].x][Q[til].y]=min(a[Q[til].x][Q[til].y],Q[til].z);
		    else a[Q[til].x][Q[til].y]=Q[til].z;
		}
	}
}
inline bool check(int x,int y,int z){if (x<1||x>n||y<1||y>m||vis[x][y]||(s[x][y]!='.'&&s[x][y]!='D')||(a[x][y]&&z>=a[x][y])) return 0;vis[x][y]=1;return 1;}
inline void Bfs(int x,int y){
	int hed=0,til=1;
	Q[1].x=x,Q[1].y=y,Q[1].z=0;
	memset(vis,0,sizeof vis);
	while (hed<=til){
		hed++;
		for (int i=0;i<4;i++){
			if (!check(Q[hed].x+flg[i][0],Q[hed].y+flg[i][1],Q[hed].z+1)) continue;
		    Q[++til].x=Q[hed].x+flg[i][0],Q[til].y=Q[hed].y+flg[i][1],Q[til].z=Q[hed].z+1;
            if (s[Q[til].x][Q[til].y]=='D'){printf("%d",Q[til].z);exit(0);}
		}
	}
}
int main(){
	n=read(),m=read();
	for (int i=1;i<=n;i++) scanf("%s",s[i]+1);
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++){
		if (s[i][j]=='S') x=i,y=j;
	    if (s[i][j]=='*') Bfs_(i,j);
	}
	Bfs(x,y);
	printf("KAKTUS");
    return 0;
}
```


---


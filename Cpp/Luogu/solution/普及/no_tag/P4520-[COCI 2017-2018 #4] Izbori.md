# [COCI 2017/2018 #4] Izbori

## 题目描述

在一个遥远的民主发达的土地上，正在进行足球协会的总统选举。这个土地由 N 个县组成，每个县都有自己的足球协会。有 M 名总统候选人，编号为 1, 2, … M。每个足球协会将选择一个候选人投票。选举的获胜者是获得最多选票的候选人。如果有多个候选人获得最多选票，获胜者是编号最小的候选人。

在竞选期间，候选人访问了各个县，试图赢得他们的支持。在会见了所有候选人后，每个县的足球协会确定了他们为每个候选人投票的顺序。

例如，假设选举中有四名候选人，一个县的投票顺序是 2, 1, 4, 3。这意味着，除非他们撤回候选资格，编号为 2 的候选人将获得该县的选票。如果候选人 2 撤回候选资格，而候选人 1 仍在竞选中，那么他们将获得选票，依此类推。

Zdravko 是一个热情的足球迷，也是编号为 K 的候选人的密友。他想知道如果没有候选人撤回候选资格，哪位候选人将获胜。

他还想知道他必须说服多少名候选人撤回候选资格，才能让他的朋友，候选人 K，成为足球协会的主席。

Zdravko 目前正在处理其他问题，所以他希望你能回答这些问题。

## 说明/提示

输出必须由两个非空行组成，每行包含一个整数。~~每个问题的正确答案在该测试用例中占 50% 的分数。（不会做 spj 没用）~~

**第一个测试用例的说明：**

选举所在的土地由 3 个县组成，有 4 名候选人竞选协会主席。如果没有候选人撤回候选资格，候选人 3 将以两票赢得选举。候选人 1 只有在所有其他候选人撤回候选资格时才会获胜。

**第二个测试用例的说明：**

只有一个候选人，即 Zdravko 的朋友，所以他们肯定会赢。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3 4 1
3 4 1 2
4 2 3 1
3 4 2 1```

### 输出

```
3
3```

## 样例 #2

### 输入

```
4 1 1
1
1
1
1```

### 输出

```
1
0```

## 样例 #3

### 输入

```
4 4 4
2 3 1 4
2 3 1 4
1 3 2 4
4 3 2 1```

### 输出

```
2
3```

# 题解

## 作者：matrixPower (赞：12)

[传送门](https://www.luogu.com.cn/problem/P4520)

黄题中的红题。

第一问很简单开桶记录一下就行了。

第二问也很简单，暴力 dfs 搜索每个选举人是否弃权，最后继续开桶记录就行了。

时间复杂度 $O(2^mnm)<5\times{10}^7$，时限 3s，可过。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define lowbit(x) (x)&(-x)
using namespace std;

typedef double db;
typedef long long ll;
typedef __int128 III;
const db eqs=1e-6;
const int inf=1e9;
void ll_cmax(ll &a,ll b){a=a>b?a:b;}
void ll_cmin(ll &a,ll b){a=a<b?a:b;}
void int_cmax(int &a,int b){a=a>b?a:b;}
void int_cmin(int &a,int b){a=a<b?a:b;}
bool db_eq(db a,db b){return fabs(a-b)<eqs;}
bool number(char ch){return ch>='0' && ch<='9';}
bool lowerchar(char ch){return ch>='a' && ch<='z';}
int sqlong(int n){int sq=sqrt(n)+1;return min(sq,n);}

const int MAXN=100+5;
int a[MAXN][MAXN],n,m,k,x[MAXN],b[MAXN],ans=inf;

void dfs(int st,int cnt)
{
	if(st>m)
	{
		memset(x,0,sizeof(x));
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				if(b[a[i][j]])
				{
					x[a[i][j]]++;
					break;
				}
			}
		}
		int maxn=-1,id;
		for(int i=1;i<=m;i++)
		{
			if(x[i]>maxn) maxn=x[i],id=i;
		}
		if(id==k)
		{
			int_cmin(ans,cnt);
		}
		return ;
	}
	if(st==k)
	{
		b[st]=1;
		dfs(st+1,cnt);
		b[st]=0;
		return ;
	}
	b[st]=1;
	dfs(st+1,cnt);
	b[st]=0;
	dfs(st+1,cnt+1);
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++) cin>>a[i][j];
		x[a[i][1]]++;
	}
	int maxn=-1,id;
	for(int i=1;i<=m;i++)
	{
		if(x[i]>maxn) maxn=x[i],id=i;
	}
	cout<<id<<endl;
	memset(x,0,sizeof(x));
	dfs(1,0);
	cout<<ans<<endl;
	return 0;
}
//by Matrix_Power

```

---

## 作者：粉拉姆彤 (赞：8)


博客食用效果更佳 [传送门](https://www.luogu.com.cn/blog/Thomas-Chan/post-ti-xie-p4520-coci2017-2018-contest4-izbori)

------------

### 题意
一次选举，$N$ 个县给 $M$ 个候选人投票，给出每个县的投票候选序列，问在没有人退出选举的情况下获胜的人，并求最少劝说多少个人退出时，编号为 $K$ 的候选人将获胜。如果多人得票数并列第一，则编号小的人获胜。

### 分析
对于第一个问题，因为没有候选人退出，我们只需要考虑每个县最优先投的那个人，统计每个人的得票数即可。

对于第二个问题，考虑到 $1 \leq M \leq 15$，我们似乎可以尝试暴力算法，从少到多枚举需要退出的人，统计删去后第 $K$ 个人能否获胜。

我们使用一个 bool 数组 $st[i]$ 记录每一名候选人是否退出，再遍历统计。

时间复杂度约为 $O(NM^2)$，这题的数据并不大，这样的时间复杂度是完全可以接受的。

具体代码实现在代码部分讲解。

这样，本题就被我们顺利地 AC 啦。

但事实上，对于第二个问题，刚做题时我们很容易猜想贪心，即每次劝退（即删去）当前得票数最多的人。如果你真这样写了，恭喜你，听取 WA 声一片，20 pts。

贪心为什么不对呢？我们可以考虑下面这组数据：

```
4 4 1
3 1 4 2
2 4 3 1
2 3 1 4
1 2 3 4
```

在贪心过程中，我们会依次删去 $2$、$3$ 这两名候选人，然后 $1$ 获胜，那么答案将会是 $2$。

但显然，这组数据的正确答案是 $1$。我们只需要删去 $3$ 号候选人，根据规则，此时 $1$ 号候选人就将获胜。

在某些数据下，票数最多的人被删去后，我们的目标 $K$ 并不会被递补至序列队首。因而，贪心并不一定能得到正确答案。

遗憾的是，本题给出的三组样例，均可以使用贪心得到正确答案，而测试用例中却只有两个点可以用贪心求解。（别问我怎么知道的）

### 代码
```cpp
//AC
#include<bits/stdc++.h>

using namespace std;

const int N=110,M=29;

int n,m,k;
int tot[N];//统计票数
int maxm,maxtot,ans;//统计
bool st[N];//是否删去
int v[N][M];//保存投票序列

bool dfs(int t,int nt,int l)
//t表示删去的总人数，nt表示此次删去后已经删去的人数
//l表示上次删去的候选人的编号（主要是为了避免重复讨论）
{
    if(nt==t+1)
    {
        memset(tot,0,sizeof(tot));
        
        for(int i=1;i<=n;++i)//统计删去后得票情况
        {
            int j=1;
            while(st[v[i][j]])
                ++j;
            ++tot[v[i][j]];
        }
    
        maxtot=0;
        for(int i=1;i<=m;++i)
            if(!st[i]&&maxtot<tot[i])//为处理并列时小号优先，必须是严格小于
            {
                maxtot=tot[i];
                maxm=i;
            }
            
        if(maxm==k)
            return true;
        else
            return false;
    }
    
    for(int i=l+1;i<=m-t+nt;++i)//递归枚举删去的人
    //从 l+1 （上次删去的人的后一个）枚举到 m-t+nt （最后连续 m-t+nt 个），可以避免组合重复，也可以不这么写
    {
        if(i==k)
            continue;
            
        st[i]=1;
        if(dfs(t,nt+1,i))
            return true;
        st[i]=0;//恢复现场，初学oier不要忘记
    }
    
    return false;
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);

    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
            scanf("%d",&v[i][j]);
        ++tot[v[i][1]];//读入同时统计初始得票
    }
    
    for(int i=1;i<=m;++i)
        if(maxtot<tot[i])
        {
            maxtot=tot[i];
            maxm=i;
        }
    
    printf("%d\n",maxm);
    
    while(!dfs(ans,1,0))//从小到大枚举删去的人数
        ++ans;
    
    printf("%d\n",ans);
    
    return 0;
}
```

一题很好的DFS练习题。
完结撒花！！！

------------

![知识共享许可协议](https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png)

本作品采用[知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议](http://creativecommons.org/licenses/by-nc-nd/4.0/)进行许可。

---

## 作者：chenxumin1017 (赞：5)

# 第一问

显然，我们只需要找到所有人的票数，再模拟一边即可。

```cpp
for(int i = 1; i <= n; i++){
   cnt[a[i][1]]++;
}
int v = 1;
for(int i = 1; i <= m; i++){
  if(cnt[i] > cnt[v])v = i;
}
``````

# 第二问

有了第一问的经验，在这一问我们只要找到一种方法确定劝退那些人即可。

由于总共只有 $15$ 个人，我们可以用深度优先搜索 $DFS$ 来实现。

时间复杂度：$O(NM \cdot 2^{M})$
```cpp
 #include<bits/stdc++.h>
using namespace std;
const int MAXN = 105;
int n, m, k, a[MAXN][MAXN], cnt[MAXN], ans = 1e9, vis[MAXN];
void dfs(int x){
  if(x == m + 1){
    fill(&cnt[0], &cnt[m + 1], 0);
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        if(vis[a[i][j]] == 0){
          cnt[a[i][j]]++;
          break;
        }
      }
    }
    int v = k;
    for(int i = 1; i <= m; i++){
      if((cnt[i] > cnt[v] || cnt[i] == cnt[v] && i < v) && vis[i] == 0)v = i;
    }
    if(v == k && vis[k] == 0){
      int sum = 0;
      for(int i = 1; i <= m; i++){
        sum += vis[i];
      }
      ans = min(ans, sum);
    }
    return;
  }
  dfs(x + 1);
  if(x != k){
    vis[x] = 1;
    dfs(x + 1);
    vis[x] = 0;
  }
}
int main(){
  cin >> n >> m >> k;
  for(int i = 1; i <= n; i++){
    for(int j = 1; j <= m; j++){
      cin >> a[i][j];
    }
    cnt[a[i][1]]++;
  }
  int v = 1;
  for(int i = 1; i <= m; i++){
    if(cnt[i] > cnt[v])v = i;
  }
  cout << v << '\n';
  dfs(1);
  cout << ans << '\n';
  return 0;
}
``````

---

## 作者：logfk (赞：2)

## 题意

给定 $n$ 个城市和 $m$ 个候选人以及一个期待人选 $k$，每个城市有一个 $1-m$ 的排列，为投票的顺序，顺序的第一个数便是要投给人的编号。

任务有两个：

1. 求出初始时投票最高的人。

1. 求出至少需要去掉多少人才能使 $k$ 当选（去掉等同于在应选择该人时不选而继续向后查找）。

## 分析

第一个任务十分简单，在输入时统计第一个即可。

第二个任务由于数据范围较小，我们可以直接采用搜索的方式去掉人选，当 $k$ 的票数最大时输出即可。

好像没有选票相同时的细节...（目测第一个任务不存在并列或取编号最小，第二个任务不存在并列）

## 代码

这里采用的是 BFS，并且使用位运算的方式记录去掉的人选。

由于使用了 STL，所以吸 O2 后跑到了最优解。

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
bool vis[70000];
queue<pair<int,int> > q;
int a[110][20],na[20];
inline int read()
{
    char ch=getchar();
    int x=0,f=1;
    while((ch>'9'||ch<'0')&&ch!='-')
        ch=getchar();
    if(ch=='-'){f=-1;ch=getchar();}
    while('0'<=ch&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int main()
{
	int n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			a[i][j]=read();
		}
		na[a[i][1]]++;
	}
	int maxn=0,win=0;
	for(int i=1;i<=m;i++)
	{
		if(na[i]>maxn)
		{
			maxn=na[i];
			win=i;
		}
	}
	cout<<win<<endl;
	q.push(make_pair(0,0));
	while(!q.empty())
	{
		int x=q.front().first,w=q.front().second;
		maxn=0,win=0;
		q.pop();
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				if(!((1<<(a[i][j]-1))&x)) //在某一位上有一证明已经去掉
				{na[a[i][j]]++;break;}
			}
		}
		for(int i=1;i<=m;i++)
		{
			if(na[i]>maxn)
			{
				maxn=na[i];
				win=i;
			}
			na[i]=0;
		}
		if(win==k)
		{
			cout<<w<<endl;return 0;
		}
		for(int i=1;i<=m;i++)
		{
			if(i==k) continue;
			if(!((1<<(i-1))&x)&&!vis[(1<<(i-1))|x])//没有一且该状态没有到达过
			{
				vis[(1<<(i-1))|x]=1;
				q.push(make_pair(((1<<(i-1))|x),w+1));
			}
		}
	}
}
```


---

## 作者：Bpds1110 (赞：1)

对于第一问，用桶记录每行的候选人的票数，求最大即可。

考虑第二问。

看到 $M \le 15$，想到用 Dfs 枚举每种状态求解，即对于每个人，都有删除和保留两种状态。

对于每一种枚举的状态。找出每行中的候选人，用桶记录总票数，最后枚举桶内的票数求最大即可。如果满足选举的人为 $k$，则记录当前删去的最少的人数（求最小）。

输出删去人数的最小值（满足条件的前提下）即可。

---

## 作者：Temperature_automata (赞：1)

## 题意简述

有 $n$ 个人，每个人投票有优先级，会优先投给优先级最高的没退出的选手。求没人退出时的优胜者和最少一个人退出可以使指定选手优胜。

## 思路

### 第一问

统计每个人优先级最高的选票投给谁，最后比较各个选手的票数即可。

### 第二问

看到数据范围较小，$1\le m \le 15$，考虑枚举 $m$ 个选手是否退出的所有情况。

使用类似于状压的二进制表达，对于一个数 $x$，它二进制的第 $y$ 位表示选手 $y + 1$ 是否退出选举。

那么所有状态就是 $0 \sim 2^m - 1$。

对于每种状态的每个人，从前往后枚举优先级，找到优先级最高的没有退出的人，将他的选票加上一票。

在每个状态最后统计票数，查看是否指定人选能够当选。如果当选，计算退出人数并更新答案后继续枚举状态即可。

时间复杂度 $O(2^mnm)$，可过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 105
#define M 20
int n, m, k;
int a[N][M], ti[M], lastans = 0x3f3f3f3f;

int main() {
	scanf("%d %d %d", &n, &m, &k);
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= m; ++ j) scanf("%d", a[i] + j);
	for (int i = 1; i <= n; ++ i) ti[a[i][1]] ++;
	int ans = 0;
	for (int i = 1; i <= m; ++ i) 
		if(ti[i] > ti[ans]) ans = i;
	printf("%d\n", ans);
	if(ans == k) return printf("0"), 0;
	for (int i = 1; i < (1 << m); ++ i) {
		memset(ti, 0, sizeof(ti));
		for (int j = 1; j <= n; ++ j)
			for (int l = 1; l <= m; ++ l)
				if(!(i & (1 << (a[j][l] - 1)))) {
					ti[a[j][l]] ++;
					break;
				}
		ans = 0;
		for (int j = 1; j <= m; ++ j)
			if(ti[j] > ti[ans] && (!(i & (1 << (j - 1))))) ans = j;
//		cout << i << endl;
//		for (int i = 1; i <= m; ++ i) cout << ti[i] << " ";
//		cout << endl; 
//		cout << ans << endl;
		if(ans != k) continue;
		ans = 0;
		for (int j = 0; j < m; ++ j)
			if(i & (1 << j)) ans ++;
		lastans = min(lastans, ans);
	}
	printf("%d", lastans);
}
```

---

## 作者：uncle_steve (赞：0)

**解题思路：** 

DFS

## 问题分析：

问题分为两部分：

1. 若没有候选人弃权，哪个候选人当选。

2. 最少几个候选人弃权可以使得编号为 $k$ 的候选人当选。

#### **第一部分：没有候选人弃权时的当选者**

**解题思路：**

1. 初始化票数：为每个候选人初始化票数为 $0$。

2. 再遍历**每个县**：

   - 对于每个县，找到排名最靠前的候选人，给该候选人加一票。

3. 统计票数：

    - 统计所有候选人的票数。

4. 确定当选者：找到票数最多的候选人。

**Attention：如果有多个候选人票数相同，选择编号较小的那个。**

—————————————————————————

#### **第二部分：最少弃权数使得编号为 $k$ 的候选人当选**

**解题思路：**

1. 计算当前票数：首先计算没有弃权时每个候选人的票数。

2. 确定需要**增加的票数**：

    - 计算 $k$ 需要多少额外票数才能超过当前得票最多的候选人。

3. 选择弃权的候选人：

    - 选择那些在 $k$ 之前排名的候选人，让它们弃权，从而让 $k$ 获得更多票数。

4. 计算最少弃权数：**通过DFS算法，选择最少的弃权数来达到目标。**

得解

不放代码

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4520)

## 思路：

### 第一问：

很简单，用桶存每一个县都给谁投了票然后比较大小即可。

桶可以在输入时就处理好：


```cpp
for(int i=1;i<=x;i++){
    for(int j=1;j<=y;j++){
        cin>>m[i][j];
    }
    t[m[i][1]]++;//数组t即为桶
}
```
比较大小求答案：

```cpp
int first_problem(){
	int maxa=-99999,maxwz;
	for(int i=1;i<=y;i++){
		if(t[i]>maxa){
			maxa=t[i];
			maxwz=i;
		}
	}
	return maxwz;
}
```
### 第二问：

这里提供一种由优先队列支持的 ```BFS``` 的做法。

贪心，以当前删去了多少候选人为关键词设结构体，注意要重载运算符：


```cpp
struct node{
	int s;
	int sha;//上一个删去的候选人，这样可以减少重复枚举
	bool f[105];
	void csh(){
	    for(int i=1;i<=15;i++) f[i]=false;
	}//初始化
	friend bool operator < (node q, node p){
        return q.s > p.s;//重载小于号，以删去了多少人为关键词
    }
};
priority_queue<node>q;//优先队列
```

接下来依次取堆顶元素，然后在删去候选人的情况下执行第一问，如果返回的当选人是 $k$ 就可以直接返回了，因为我们是以删去人数为关键词的，所以这样一定最优。

如果当前方案仍不能够让 $k$ 当选，就继续枚举，删去更多的候选人：


```cpp
for(int j=c.sha+1;j<=y;j++){//从上一个被删去的候选人开始枚举
    node jy;
    jy.s=(c.s+1);
    jy.sha=j;
    for(int k=1;k<=y;k++){
        if(k==j) jy.f[k]=true;
        else jy.f[k]=c.f[k];
    } 
    q.push(jy);
}
```

直到可以让 $k$ 当选为止。

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int x,y,a;
int da1;
int t[20]; 
int m[1005][1005];

int first_problem(){
	int maxa=-99999,maxwz;
	for(int i=1;i<=y;i++){
		if(t[i]>maxa){
			maxa=t[i];
			maxwz=i;
		}
	}
	return maxwz;
}

struct node{
	int s;
	int sha;//上一个删去的候选人，这样可以减少重复枚举
	bool f[105];
	void csh(){
	    for(int i=1;i<=15;i++) f[i]=false;
	}//初始化
	friend bool operator < (node q, node p){
        return q.s > p.s;//重载小于号，以删去了多少人为关键词
    }
};
priority_queue<node>q;//优先队列

int second_problem(){
	node tt;
	tt.s=tt.sha=0;
	tt.csh();
	q.push(tt);
	while(!q.empty()){
		node c=q.top();
		q.pop();
		memset(t,0,sizeof(t));
	    for(int i=1;i<=x;i++){
	    	for(int j=1;j<=y;j++){
		    	if(c.f[m[i][j]]==false){
		    		t[m[i][j]]++;
		    		break;
				}
		    }
	    }
	    
	    if(first_problem()==a) return c.s;
	    
	    for(int j=c.sha+1;j<=y;j++){//从上一个被删去的候选人开始枚举
	    	node jy;
	    	jy.s=(c.s+1);
	    	jy.sha=j;
			for(int k=1;k<=y;k++){
				if(k==j) jy.f[k]=true;
				else jy.f[k]=c.f[k];
			} 
			q.push(jy);
		}
	    
	}
	return 0;
}

int main(){
	cin>>x>>y>>a;
	for(int i=1;i<=x;i++){
		for(int j=1;j<=y;j++){
			cin>>m[i][j];
		}
		t[m[i][1]]++;//数组t即为桶
	}
	cout<<first_problem()<<endl<<second_problem();
	return 0;
}

```

---

## 作者：wangyinghao (赞：0)

### 第一问

统计每个候选人获得的票数即可

### 第二问

我知道很多人会用贪心，让票数最多的弃权，直到第 $K$ 个人当选。反例参考楼上题解，就不给构造了~~嘻嘻~~。

如果你没意识到重点，看数据范围 $1\le M\le 15$，你难道不觉得这个数据有一点怪吗？

这时候我们想另外一种稳妥的方法，还是看数据范围，范围那么小，几乎只有 `dfs` 了。

直接暴力枚举每个候选人参选还是不参选，然后模拟判断是否为 $K$ 当选即可。

### AC Code

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[105][20];
int h[20];
bool vis[20];
int n,m,k,ans=1e9;
void dfs(int x){
    if(x>m){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(vis[a[i][j]]){
                    h[a[i][j]]++;
                    break;
                }
            }
        }
        int maxx=0,maxy=0;
        for(int i=1;i<=m;i++){
            if(maxx<h[i]){
                maxx=h[i];
                maxy=i;
            }
        }
        if(maxy==k){
            int cnt=0;
            for(int i=1;i<=m;i++){
                if(!vis[i]) cnt++;
            }
            ans=min(ans,cnt);
        }
        memset(h,0,sizeof(h));
        return ;
    }
    for(int i=0;i<=1;i++){
        vis[x]=i;
        dfs(x+1);
    }
}

int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(j==1) h[a[i][j]]++;
        }
    }
    int maxx=0,maxy;
    for(int i=1;i<=m;i++){
        if(maxx<h[i]){
            maxx=h[i];
            maxy=i;
        }
    }
    cout<<maxy<<'\n';
    memset(h,0,sizeof(h));
    dfs(1);
    cout<<ans;
    return 0;
}
```

---


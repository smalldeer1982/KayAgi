# [COCI 2017/2018 #5] Spirale

## 题目描述

小斯捷潘经常喜欢和朋友们一起去萨格勒布一家很受欢迎的夜总会玩。不过，斯捷潘有时会喝太多苏打水，糖分过多会让他头晕目眩。昨晚就是一个例子，所以斯捷潘脑海中一直浮现着同一个画面。那是一个潦草的数字螺旋。由于他不太记得那幅图的样子，但可以描述出来，所以他请求您为他重现那幅图。

斯捷潘回忆说，图像是一张表格，由 $N$ 行 $M$ 列数字组成。此外，他还记得表格中有 $K$ 个螺旋。每个螺旋的起始位置和移动方向都是已知的，有顺时针和逆时针两种。下面的图片就是一个例子。这些螺旋以如下方式创建了斯捷潘的图像，步数正好为 $10^{100}$ ：

1. 一开始，表格是空的，每个螺旋都在自己的起始位置。
2. 在接下来的每一步中，每个螺旋都会移动到下一个位置。有时，螺旋可能会离开表格，但也可能会返回到表格内。
3. 经过整整 $10^{100}$ 步后，对于表格中的每个格子，格子中的数值就是其中一个螺旋最少经过该格子的步数。

![](https://cdn.luogu.com.cn/upload/pic/19205.png)

## 说明/提示

对于 $50\%$ 的数据来说，保证 $N=M,K=1$ 并且 $X_i=Y_i=\lfloor\frac{N+1}{2}\rfloor$ （也就是说， $X_i$ 和 $Y_i$ 会等于 $N+1$ 除以 $2$ 再下取整的结果。）

![](https://cdn.luogu.com.cn/upload/pic/19206.png)

为简单起见，在第一个螺旋的数字后面加上字母 `A` ，在第二个螺旋的数字后面加上字母 `B` 。只显示了第一个螺旋的前 $20$ 步和第二个螺旋的前 $21$ 步。灰色格子是表格中的格子，其他格子都超出了表格的范围，但显示出来是为了说明螺旋在表格外移动的方式。

## 样例 #1

### 输入

```
3 3 1
2 2 0```

### 输出

```
9 2 3
8 1 4
7 6 5```

## 样例 #2

### 输入

```
3 3 1
2 2 1```

### 输出

```
3 2 9
4 1 8
5 6 7```

## 样例 #3

### 输入

```
3 3 2
1 1 0
1 2 0```

### 输出

```
1 1 4
6 5 5
19 18 17```

# 题解

## 作者：piuke (赞：2)

好久没写博客了啊……来水一发……

## 题意描述

~~为什么这样一道英文题不支持提供翻译……~~

给你一个$n\times m$的矩阵和矩阵内的$q$个螺旋线，在矩阵上填入螺旋线遍历到该点的编号，求最终的矩阵。

螺旋线的由初始点和方向（顺时针或逆时针）定义，且矩阵右上角为$(1,1)$。  
顺时针线是由初始点向上一个单位，向右一个单位，向下两个单位，向左两个单位，再向上三个单位……以此类推。 
同理，逆时针线是由初始点向上一个单位，向左一个单位，向下两个单位，向右两个单位，再向上三个单位……以此类推。

当两条线覆盖到同一个格子时，取较小的编号。
如果螺旋线到了矩阵外，不需要处理，但是编号要保持增加，最后只输出矩阵内的元素。

### 样例解释

~~好像只有样例三看不懂~~

样例三：
```
3 3 2  
1 1 0  
1 2 0
```
输出：
```
1  1  4
6  5  5
19 18 17
```
先看第一个螺旋线，构造出来应该是这样的：
```
   .  .  .  .
   .  .  .  .
   .  .  .  .
...10 11 12 13...
...9  2  3  14...
...8  1  4  15...
...7  6  5  16...
...20 19 18 17...
   .  .  .  .
   .  .  .  .
   .  .  .  .
```
这是一个$5\times 4$的矩阵，但是我们只取右下角的$3\times 3$。
再只看第二个螺旋线，可得：
```
   .  .  .  .
   .  .  .  .
   .  .  .  .
...10 11 12 13...
...9  2  3  14...
...8  1  4  15...
...7  6  5  16...
...20 19 18 17...
   .  .  .  .
   .  .  .  .
   .  .  .  .
```
这还是一个$5\times 4$的矩阵，但是我们只取左下角的$3\times 3$。
于是合并两个$3\times3$的矩阵，得到答案：
```
1  1  4
6  5  5
19 18 17
```

---
----
---

说了这么多，~~大~~模拟  
强势模拟绕的过程，不是就直接走，判断出了几条界，出了四条街就停

时间复杂度：最多不会长宽多走一倍，所以是$O(4nmq)$

## $Code$
```cpp
int n, m, k;
bool out[4];
int mp[51][51];
inline void check(int x, int y) {
    if(x < 1) out[0] = 0;
    if(y < 1) out[1] = 0;
    if(x > n) out[2] = 0;
    if(y > m) out[3] = 0;
}
inline void draw(int&x, int&y, int way, int&num, char ty) {
    for(int i = 1; i <= way; i++) {
        if(ty == 'u') x--;
        if(ty == 'd') x++;
        if(ty == 'l') y--;
        if(ty == 'r') y++;
        check(x, y);
        num++;
        if(x >= 1 && y >= 1 && x <= n && y <= m)
            mp[x][y] = Min(mp[x][y], num);
    }
}
int main() {
    memset(mp, 0x3f, sizeof mp);
    read(n), read(m), read(k);
    for(int i = 1; i <= k; i++) {
        int x, y, ty; read(x), read(y), read(ty);
        int dis = 0, num = 1;
        out[0] = out[1] = out[2] = out[3] = 1;
        mp[x][y] = num;
        while(out[0] || out[1] || out[2] || out[3]) {
            if(ty == 0) {
                draw(x, y, dis / 2 + 1, num, 'u'); dis++;
                draw(x, y, dis / 2 + 1, num, 'r'); dis++;
                draw(x, y, dis / 2 + 1, num, 'd'); dis++;
                draw(x, y, dis / 2 + 1, num, 'l'); dis++;
            }
            else {
                draw(x, y, dis / 2 + 1, num, 'u'); dis++;
                draw(x, y, dis / 2 + 1, num, 'l'); dis++;
                draw(x, y, dis / 2 + 1, num, 'd'); dis++;
                draw(x, y, dis / 2 + 1, num, 'r'); dis++;
            }
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j < m; j++)
            printf("%d ", mp[i][j]);
        printf("%d\n", mp[i][m]);
    }
}
```
至于前方的模板——[https://www.luogu.org/paste/7ihr6633](https://www.luogu.org/paste/7ihr6633)

---

## 作者：dyxcj (赞：1)

# [P4614](https://www.luogu.com.cn/problem/P4614)

# 思路：模拟

对于每一次螺旋，进行一次模拟。每次模拟找到螺旋现在在哪，与记录的值比较并取最小。

# 复杂度计算

每一次螺旋要完全覆盖最终答案数组，为 $O(NM)$ 的复杂度。一共有 $k$ 次查询，**总时间复杂度** 为 $O(NMK)$。

# 实现方法

## 定义

定义 $b$ 数组为最后的答案数组。\
dfs 函数中 $x$ 与 $y$ 代表目前到哪了，变量 $f$ 为螺旋方向（顺时针与逆时针），变量 $w$ 为**现在**的方向，变量 $bs$ 表示现在的方向还需要走几步。\
数组 $p$ 控制转动方向（后文会详细讲）。\
变量 $tot$ 代表目前需要走多少步（用于更新 $bs$ 值）。

## 实现思路

 发现对于每一种螺旋方式，他的转动方向是唯一的，所以可以初始化数组 $p$ 使 $p_{f,w}$ 可以表达螺旋方向为 $p$ 现在方向为 $w$ 时下一次面向的方向，第一维的代表螺旋方式，有 $0$ 是顺时针与 $1$ 是逆时针；第二维代表目前朝向，有 $0$ 是上 $1$ 是右 $2$ 是下 $3$ 是左。\
代码：

```cpp
p[1][2]=p[0][0]=1;
p[1][3]=p[0][1]=2;
p[1][0]=p[0][2]=3;
p[1][1]=p[0][3]=0;
```

-  对于答案数组 $b$ 我们要先将数组设置一个初始值。\
代码：

```cpp
for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)b[i][j]=200000000;
```

-  对于 dfs 函数，分四部分讲解：

一：当前进步数为 $0$ 时，先更新现在面朝方向，并发现现在的方向与 $tot$ 存在一些关系，具体的，当 $w$ 值为 $2$ 或 $0$ 时 $tot+1$，即当更新后的方向为上或下时，要前进的步数增加 $1$。\
代码：

```cpp
if(bs==0){
    w=p[f][w];
    tot+=(w==0||w==2)?1:0;
    dfs(x,y,f,s,w,tot);
}
```

二：当步数不为 $0$ 时，即当前方向还需要向前走时，判断面朝方向再前进。\
代码：

```cpp
if(w==0)dfs(x-1,y,f,s+1,w,bs-1);
else if(w==1)dfs(x,y+1,f,s+1,w,bs-1);
else if(w==2)dfs(x+1,y,f,s+1,w,bs-1);
else if(w==3)dfs(x,y-1,f,s+1,w,bs-1);
```

三：修改 $b$ 数组的值，并加上边界判定（别 RE 了）。\
代码：

```cpp
if(x>0&&y>0&&x<=n&&y<=m)b[x][y]=min(s,b[x][y]);
```

四：退出循环判定，一开始我想的是当 $tot$ 也就是需要前进的步数满足 $tot> V$ 时退出（$V$ 定义为 $n$ 和 $m$ 的最大值）。但是这是错的，因为当一个螺旋的起点在角落时，比如 $(1,1)$ 时，需要 $tot=2\times V$ 时才能覆盖完整 $b$ 数组。
代码：

```cpp
if(tot>max(n,m)*2)return;
```

- 完成输入输出等杂项。

# 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55,F=4,B=2;
int n,m,k,b[N][N],p[B][F],tot=1;
bool f;
void dfs(int x,int y,bool f,int s,int w,int bs){
    if(tot>max(n,m)*2)return;
    if(x>0&&y>0&&x<=n&&y<=m)b[x][y]=min(s,b[x][y]);
    if(bs==0){
        w=p[f][w];
        tot+=(w==0||w==2)?1:0;
        dfs(x,y,f,s,w,tot);
    }
    if(w==0)dfs(x-1,y,f,s+1,w,bs-1);
    else if(w==1)dfs(x,y+1,f,s+1,w,bs-1);
    else if(w==2)dfs(x+1,y,f,s+1,w,bs-1);
    else if(w==3)dfs(x,y-1,f,s+1,w,bs-1);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)b[i][j]=200000000;
    p[1][2]=p[0][0]=1;
    p[1][3]=p[0][1]=2;
    p[1][0]=p[0][2]=3;
    p[1][1]=p[0][3]=0;
    for(int i=1,x,y;i<=k;i++){
        cin>>x>>y>>f;
        tot=1;
        dfs(x,y,f,1,0,tot);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)cout<<b[i][j]<<" ";
        cout<<"\n";
    }
    return 0;
}
```

**感谢大家的观看。**

---

## 作者：亦笙箫 (赞：1)

# 多说无益,此题模拟

输入的时候每个螺旋都在整张地图做一遍,每个点保存到达它的最小值(最少步数).  
就是正解.  
~~**(我是没找出来哪里有优化.**~~  
~~我处理的时候稍微有些花里胡哨~~  

## $Code$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>

using namespace std;

const int MAXX = 50;

int n,m,k;
int q,p,f;
int a[MAXX+5][MAXX+5];

int main()
{
//	freopen("spirale.in","r",stdin);
//	freopen("spirale.out","w",stdout);
	scanf("%d %d %d",&n,&m,&k);
	memset(a,0x3f,sizeof(a));
	for(int x=1;x<=k;x++)
	{
		scanf("%d %d %d",&p,&q,&f);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
			{
				int k=max(abs(i-p),abs(j-q)),l=0;
				if(k^0) l=(2*k-1)*(2*k-1);
				else{a[i][j]=1;continue;}
				if(abs(i-p)==abs(j-q))
				{
					if(i>p&&j>q)
						l+=2*(f?3*k:2*k),
						a[i][j]=min(a[i][j],l);
					else if(i>p&&j<q)
						l+=2*(f?2*k:3*k),
						a[i][j]=min(a[i][j],l);
					else if(i<p&&j>q)
						l+=2*(f?4*k:1*k),
						a[i][j]=min(a[i][j],l);
					else if(i<p&&j<q)
						l+=2*(f?1*k:4*k),
						a[i][j]=min(a[i][j],l);
					continue;
				}
				if(p-i==k)
				{
                    l+=f?(q+k-j):(j-(q-k));
                    a[i][j]=min(a[i][j],l);
                    continue;
                }
                if(i-p==k)
				{
                    l+=4*k-1+(!f?(q+k-j):(j-(q-k)))+1;
                    a[i][j]=min(a[i][j],l);
					continue;
                }
                if(j-q==k)
				{
                    l+=(f?(6*k-1+p+k-i):(2*k-1+i-(p-k)))+1;
                    a[i][j]=min(a[i][j],l);
                    continue;
                }
                if(q-j==k)
				{
					l+=(f?(2*k-1+i-(p-k)):(6*k-1+p+k-i))+1;
                    a[i][j]=min(a[i][j],l);
                    continue;
                }
			}
	}
	for(int i=1;i<=n;i++,printf("\n"))
		for(int j=1;j<=m;j++)
			printf("%d ",a[i][j]);
	return 0;
}
```


---

## 作者：LeBao2023 (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P4614)

我们看见一个东西 $1 \le N,M \le 50，1 \le K \le N \times M$。

结论：本题模拟。

如何模拟？

我们可以使用 dfs 来模拟，每次贴着边旋转，更新。

记住在大点的的地方模拟，因为有可能转到外面后在转回里面。

具体实现看代码。

code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,z;
int a[155][155],vis[155][155];
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
void dfs(int x,int y,int d,int dep)
{
	if(!(x>=0&&x<=151&&y>=0&&y<=151))
	{
		return ;
	}
	a[x][y]=min(a[x][y],dep),vis[x][y]=true;
	int dd=(d==3?0:d+1);
	if(vis[dx[dd]+x][dy[dd]*z+y]==0)
	{
		dfs(x+dx[dd],dy[dd]*z+y,dd,dep+1);
	}
	else
	{
		dfs(x+dx[d],y+dy[d]*z,d,dep+1);
	}
	vis[x][y]=false;
}
int main()
{
	memset(a,0x3f,sizeof(a));
	memset(vis,0,sizeof(vis));
	cin>>n>>m>>k;
	for(int i=1,x,y,t;i<=k;i++)
	{
		cin>>x>>y>>t;
		a[x+50][y+50]=1;
		vis[x+50][y+50]=1;
		z=(t==0?1:-1);
		dfs(x-1+50,y+50,0,2);
		vis[x+50][y+50]=0;
	}
	for(int i=51;i<=n+50;i++)
	{
		for(int j=51;j<=m+50;j++)
		{
			cout<<a[i][j];
			putchar(' ');
		}
		putchar('\n');
	}
}
```

---

## 作者：VitrelosTia (赞：0)

考虑顺时针或者逆时针走法的轨迹是固定的，可以先预处理出来。这个东西的关键在于拐弯，假设走了 $i$ 步，观察一下可以发现，现在走出来的形状最长的边是 $\sqrt{i}$，记录一下上一次拐弯的点在哪里，如果和 $i$ 的距离是边长就是拐弯的点了。对于一次拐弯，分别讨论四个角的位置即可。

预处理轨迹的时候大概 $4 \times n \times m$ 步就足够了，含义是在四个角上的情况。这样对于每个起点去暴力走的复杂度就是 $O(nmk)$，不过多处理一点无所谓。细节是走的时候容易走出范围，所以可以让坐标加上一个比较大的东西。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 55, M = 255, K = 2e5 + 5;
int n, m, k;
int dic[2][K][2];

int ans[N + M][N + M];
void solve(int x, int y, int o) {
	ans[x][y] = min(ans[x][y], 1);
	for (int i = 2, c = 1; c < (n - M) * (m - M); i++) {
		x += dic[o][i - 1][0], y += dic[o][i - 1][1];
		if (M + 1 <= x && x <= n && M + 1 <= y && y <= m) {
			c++;
			ans[x][y] = min(ans[x][y], i);
		}
	}
}

int main() {
//	freopen("out.txt", "w", stdout);
// 	freopen("Spirale.in", "r", stdin);
// 	freopen("Spirale.out", "w", stdout);
	ios::sync_with_stdio(false); cin.tie(nullptr);
	cin >> n >> m >> k; n += M, m += M;
	dic[0][1][0] = -1, dic[0][1][1] = 0;
	for (int x = 0, y = 0, len = 1, lst = 1, pos = 3, i = 2; i <= 2e5; i++) {
		len = sqrt(i);
		if (i - lst == len) {
			pos = (pos + 1) % 4;
			if (pos == 0) x = 0, y = 1;
			if (pos == 1) x = 1, y = 0;
			if (pos == 2) x = 0, y = -1;
			if (pos == 3) x = -1, y = 0;
			lst = i;
		}
		dic[0][i][0] = x, dic[0][i][1] = y;
	}
	dic[1][1][0] = -1, dic[0][1][1] = 0;
	for (int x = 0, y = 0, len = 1, lst = 1, pos = 3, i = 2; i <= 2e5; i++) {
		len = sqrt(i);
		if (i - lst == len) {
			pos = (pos + 1) % 4;
			if (pos == 0) x = 0, y = -1;
			if (pos == 1) x = 1, y = 0;
			if (pos == 2) x = 0, y = 1;
			if (pos == 3) x = -1, y = 0;
			lst = i;
		}
		dic[1][i][0] = x, dic[1][i][1] = y;
	}
	memset(ans, 0x3f, sizeof ans);
	for (int i = 1, x, y, t; i <= k; i++) {
		cin >> x >> y >> t; x += M, y += M;
		solve(x, y, t);
	}
	for (int i = 1; i <= n - M; i++, cout << '\n') 
		for (int j = 1; j <= m - M; j++) cout << ans[i + M][j + M] << ' ';
	return 0;
}
```

---

## 作者：NTT__int128 (赞：0)

# P4614 [COCI2017-2018#5] Spirale题解
模拟题。

首先，在走了 $10^{100}$ 步后，每个螺旋一定走过了矩阵中的每个格子。我们发现，$n$ 和 $m$ 都非常小，考虑直接模拟。

每个螺旋都会以这样的方式走：

1. 每次都转弯（肯定的呀）。

2. 每转两次弯，走的边长增加 $1$。

3. 初始走的边长为 $1$。

直接模拟即可。

每个螺旋最多走 $4\times n\times m$ 步（画个图就能理解）。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int K = 2.5e3 + 5 , N = 5e1 + 5 ;
int n , m , k , x[K] , y[K] , f[K] , a[N][N] ;
int dx[] = {-1 , 0 , 1 , 0} ;
int dy[] = {0 , -1 , 0 , 1} ;
void bfs(int id)
{
	int nx = x[id] , ny = y[id] ;
	int l = 1 , tim = 1 , fa = 0 ;
	bool y = 1 ;
	while(tim < max(n , m) * max(n , m) * 4)
	{
		y ^= 1 ;
		int tmp = l ;
		while(tmp--)
		{
			if(1 <= nx && nx <= n && 1 <= ny && ny <= m)	a[nx][ny] = min(tim , a[nx][ny]) ;
			nx += dx[fa] , ny += dy[fa] ;
			tim++ ;
		}
		if(y)	l++ ;
		if(f[id])	fa = (fa + 1) % 4 ;
		else	fa = (fa + 3) % 4 ;
	}
	return ;
}
signed main()
{
	memset(a , 0x3f , sizeof a) ;
	cin >> n >> m >> k ;
	for(int i = 1 ; i <= k ; i++)
	{
		cin >> x[i] >> y[i] >> f[i] ;
		a[x[i]][y[i]] = 1 ;
		bfs(i) ;
	}
	for(int i = 1 ; i <= n ; i++)
	{
		for(int j = 1 ; j <= m ; j++)	cout << a[i][j] << ' ' ;
		cout << '\n' ;
	}
	return 0 ;
}
```

---

## 作者：CarlosLiu (赞：0)

# P4614题解
## 题意描述
一个 $n$ 行 $m$ 列的矩阵，其中有 $k$ 个点为螺旋的起点。

螺旋分为两种，顺时针和逆时针。简单来说，顺时针为往上，往右，往下，再往左，逆时针为往上，往左，往下，再往右。具体可以看题目中给出的图。

对于矩阵中每一个点，都要输出一个数字，这个数字含义为：**一个螺旋碰到这个点所需的最少步数**。
## 解题思路
首先我就意识到：**知道螺旋起点的坐标和任意一点的坐标，就可以推出这条螺旋到这个点所需的步数**。

这怎么算呢？我们可以**把一条螺旋分层**。比如，一条顺时针的螺旋，第一层为 $1$，第二层为 $2$ 到 $9$，第三层为 $10$ 到 $25$，以此类推。如果画一张图，可以发现，前 $x$ 层形成以螺旋起点为中心，边长为 $2x-1$ 的正方形，因此可以求出前 $x$ 层步数总和。

下一步，**找到给定点位于螺旋中的第几层**。因为每一层都是一个正方形边缘上的部分，这个层数 $x$ 为给定点和起点横坐标之差，以及给定点和起点纵坐标之差，两者中的较大值。然后，就可以先加上 $1$ 到 $x-1$ 层步数总和。

下面，怎么**求出给定点在层中的步数**呢？可以分四种情况，用横纵坐标表示出来。

这样一来，螺旋到给定点的步数可以求出，把这样的算法对每一个螺旋使用，求出给定点输出的数；对每一个点这样操作，这道题就结束了。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x[3000],y[3000],a[3000];
int s(int b,int c) {
	int ans=100000000;
	for(int l=1;l<=k;l++) {
		int tem,t;
		if(abs(b-x[l])>abs(c-y[l])) t=abs(b-x[l]);
		else t=abs(c-y[l]);
		if(t==0) return 1;
		tem=(2*t-1)*(2*t-1);
		if(a[l]==0) {
			if(b==x[l]-t&&c>y[l]-t) tem+=(c-y[l]+t);
			else if(b==x[l]+t) tem+=(4*t+y[l]+t-c);
			else if(c==y[l]+t) tem+=(2*t-x[l]+t+b);
			else if(c==y[l]-t) tem+=(6*t-b+x[l]+t);
		}else {
			if(b==x[l]-t&&c<y[l]+t) tem+=(-c+y[l]+t);
			else if(b==x[l]+t) tem+=(4*t-y[l]+t+c);
			else if(c==y[l]+t) tem+=(6*t+x[l]+t-b);
			else if(c==y[l]-t) tem+=(2*t+b-x[l]+t);
		}
		if(tem<ans) ans=tem;
	}
	return ans;
}
int main() {
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++) scanf("%d %d %d",&x[i],&y[i],&a[i]);
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) printf("%d ",s(i,j));
		cout<<endl;
	}
	return 0;
}
```

这段代码全部正确。

---

## 作者：Genius_Star (赞：0)

### 题意：
Stjepan 经常和他的朋友们一起在 Zagreb 的一家酒吧玩。然而，Stjepan 有时会喝过多的苏打水，里面的糖会让他头晕，比如昨晚就是一个例子。

而当他头晕时，脑海中始终会拥有相同的场景，这个场景是一些数字螺旋的涂鸦，但他不能完全记住这些图像的样子，但可以描述它们。

Stjepan 回忆说，这个图形是一个表格，由 $N$ 行 $M$ 列的数字组成。

此外，这个表格中还有 $K$ 个螺旋线，每个螺旋线的起点是已知的，以及它的移动方向，可以是顺时针或逆时针。螺旋通过以下方式进行：

1. 最初，表格是空的，每个螺旋都在自己的初始位置。

2. 随后的每一步，每个螺旋都会移动到自己的下一个位置。如果这个螺旋会离开表格边界，但也会在后面返回。

3. 在完成 $10^{100}$ 个步骤后，对于每个表格中的数字，是其中一个螺旋到达这个表格最早的位置。
### 思路：
这道题开始一看到 $10^{100}$ 着实吓了一跳，而且这个螺旋可以旋到外面去，这确实虚得很。。。

因此就开始推情况，将 $3 \times 3$ 的图顺时针逆时针都推了一下，一开始就成功得出了一个结论，这个螺旋线不可能超过 $4 \times n \times n$ 个。

当然我不知道这对不对，因为推着推着就发现，其实这个螺旋线的边长最多即为它的出发点离这个矩阵的距离乘以 $2$ 加 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/le5757ao.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


在这个图中，螺旋线的起点是这个阴影点，那么如果要让它笼罩整个矩阵的话，肯定它的一半的边长是这么大：

![](https://cdn.luogu.com.cn/upload/image_hosting/r8vlwry0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

在这个图上，这个螺旋线最坏的情况跑成的矩阵如图所示，即它的边长的一半就是这个点离四条边的最长距离，然后再加上这个点，总共边长即为 $d i s \times 2 + 1$。

这么推完后这个题的难点基本就没了，剩下的就是简单的二维数组基本操作了，当然要注意的是控制下标的变量不能越界，不然也会 RE。
### 完整代码：
```cpp
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <queue>
#include <stack>
#include <cstring>
#include <iostream>
using namespace std;
#define reg register
#define LL long long
#define INF 0x3f3f3f3f

template<typename T>
void re (T &x){
    x = 0;
    int f = 1;
    char c = getchar ();
    while (c < '0' || c > '9'){
        if (c == '-') f = -1;
        c = getchar ();
    }
    while (c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + c - 48;
        c = getchar ();
    }
    x *= f;
}

template<typename T>
void pr (T x){
    if (x < 0){
        putchar ('-');
        x = ~x + 1;
    }
    if (x / 10) pr (x / 10);
    putchar (x % 10 + 48);
}

int n, m, k, a[100][100];

int main (){
    re (n); re (m); re (k);
    memset (a, INF, sizeof (a));
    while (k --){
        int xx, yy, ty, num, tot = 0, cnt = 1;
        re (xx); re (yy); re (ty);
        a[xx][yy] = min (a[xx][yy], num = 1);
        tot = max (tot, n - xx);
        tot = max (tot, m - yy);
        tot = max (tot, xx - 1);
        tot = max (tot, yy - 1);
        tot = (tot * 2 + 1) * (tot * 2 + 1);
        //if (xx - 1 > 0) a[xx - 1][yy] = min (a[xx - 1][yy], num = 2);
        if (ty == 1){
            int x = xx, y = yy;
            int flag = 0;
            while (num < tot){
                int tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; x --;
                    if (x > 0 && y > 0 && y <= m) a[x][y] = min (a[x][y], num);
                }
                tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; y --;
                    if (x > 0 && y > 0 && x <= n) a[x][y] = min (a[x][y], num);
                }
                tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; x ++;
                    if (x <= n && x > 0 && y > 0 && y <= m) a[x][y] = min (a[x][y], num);
                }
                tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; y ++;
                    if (x > 0 && y > 0 && y <= m && x <= n) a[x][y] = min (a[x][y], num);
                }
            }
        }
        else{
            int x = xx, y = yy;
            int flag = 0;
            while (num < tot){
                int tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; x --;
                    if (x > 0 && y > 0) a[x][y] = min (a[x][y], num);
                }
                tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; y ++;
                    if (x > 0 && y > 0 && y <= m) a[x][y] = min (a[x][y], num);
                }
                tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; x ++;
                    if (x > 0 && y > 0 && x <= n) a[x][y] = min (a[x][y], num);
                }
                tmp = 1; flag ++;
                if (flag & 1) cnt ++;
                while (tmp < cnt && num < tot){
                    tmp ++; num ++; y --;
                    if (x > 0 && y > 0) a[x][y] = min (a[x][y], num);
                }
            }
        }
    }
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            pr (a[i][j]);
            putchar (' ');
        }
        putchar (10);
    }
    return 0;
}

```
~~话说为什么听他们说好像直接大模拟也能过？？不知道怎么搞的。。。~~

---


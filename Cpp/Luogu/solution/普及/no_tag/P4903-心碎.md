# 心碎

## 题目背景

NOIP2015初赛。CYD大神在他的母校跪掉了。初赛那天，他回到原来的教室参观了一下，发现那张遍布了N个洞的课桌还摆在那里——那是他初中时和XHY同学坐过的桌子。这时，CYD大神的心都碎了。


## 题目描述

CYD大神的心可以看做一个环，内外都顺时针均匀分布了N个一一正对应的点。当他看到第i个洞时，就会想起第Ai件往事，这会在CYD大神的心上外侧第i个点和内侧第Ai个点间留下一道伤痕(i<Ai时为顺时针，i>Ai时逆时针，i=Ai时正对应)。

CYD大神觉得，他的心一定不会再碎了，所以，他想让你帮他写一个程序，确定一个Ai的排列，使得他的心碎的块数最多。


## 说明/提示

对于40%数据，前i\*10%,N<=i\*5。

对于50%数据，N<=50。

对于70%数据，N<=233。

对于100%数据，N<=2333。

/\*P.S.样例解释\*/

样例1:1->2,2->1

样例2:1->2,2->3,3->1,注意：若1->3,2->2,3->1，则三线共点。

样例3:1->3,2->4,3->2,4->1


## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
3```

### 输出

```
5```

## 样例 #3

### 输入

```
4```

### 输出

```
9```

# 题解

## 作者：Bla_Bla (赞：15)

啊哈！蒟蒻我又来啦！~~顺便水了一道蓝题~~

看到这题的第一眼，就感觉这是一道数论题（~~日常脱离正解~~。然后，样例给我第一眼的规律：**2^（n-1）+1**

交上去后，果断WA。无奈之下，跑去oeis（A099392），得到了正解：**floor((n^2 - 2n + 3)/2)**。
### 但是！你以为这篇题解就结束了？！
开始我就说了，我会脱离正解。所以，本蒟蒻自己推了式子。
（~~不想看推论过程的自行跳过~~

# 简单的推论过程:


------------


首先，把样例搞多一点，像这样：
```cpp
n：1  2  3  4  5  6  7  8  9  10 11
m: 1  3  5  9  13 19 25 33 41 51 61
```
为了好做，把 **m的变化值/2**（后面有大用）。然后 m 的变化 就变成了：
```
m的变化:+1 +1 +2 +2 +3 +3 +4 +4 +5 +5 +...
```
所以,看出规律了吧：m = m的变化总值*2+1


------------


## 然后,我们得到了代码1.0 :
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m=0,i,x;
	cin>>n;
	x=n/2;//得到 n 的一半(int舍去小数位,相当于向下取整 
	for(i=1;i<=x;i++)
	m+=2*i;//n的值每+2，累加的数就会+2，可以视为乘法。 
	//因为 n/2 了(x)，所以直接乘就好了 
	if(n%2==0)//奇偶分类讨论 
	{
		m=m-x;//减掉它最后加的数(n/2) 
		cout<<m*2+3;//输出,注意这里要加回一个2 
		return 0;
	}
	cout<<m*2+1;//输出 
	return 0;//枯燥的水过蓝题 
}
```
等等，别急着抄（你们一定会这样的，拿着式子就走 ~~好歹点个赞再走啊QAQ~~

回头看看 **m的变化值：**

 > +1 +1 +2 +2 +3 +3 +...

 > 提示一下：1 2 3 ...

想到了什么？没错！三角形数！

公式（三角形数）： **n(n+1)/2**

然后，我们就可以优化一下我们的代码了（~~虽然并没有快多少~~

## 代码**2.0**：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m=0,i,x; 
	cin>>n;
	x=n/2;
	m=x*(x+1);
	if(n%2==0)
	m-=x;
	cout<<m*2+1;
	return 0;
}
```
和1.0差不多的...所以注释不写了。

---

## 作者：MZY666 (赞：14)

[原题传送门](https://www.luogu.com.cn/problem/P4903)。
 [在我的博客中食用效果更佳](https://www.luogu.com.cn/blog/MZY666/solution-p4903)。

**本题解含证明。**

这种题本蒟蒻表示并看不懂，可看输入输出这么简单，找规律就对了。

找规律过程其它题解也说过，这里跳过。

得到：心碎数= $N^2/2+1$.

*Code*:
```cpp
#include<bits/stdc++.h>//万能头文件好
using namespace std;//这个不能少
#define ll long long//个人习惯，可以少打一点字
int main(){
    ll n;//定义
    scanf("%lld",&n);//输入
    printf("%lld",(n*n)/2+1);//输出
    return 0;//over
}
```
# 你以为这就完了?

**据说，此题无人能证明其解法，而当我们扒出作者的标程后，会发现....(下面是标程)**
```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
using namespace std;
int n;
int f[23333],g[23333];//我忍不住来吐槽一下这个数组是真的皮
int main(){
	scanf("%d",&n);
	memset(g,0x3f,sizeof(g));
	memset(f,0x1f,sizeof(f));
	f[1]=f[2]=g[1]=0;
	g[2]=1;g[3]=2;g[4]=4;
	for(int i=3;i<=n;i++){
	for(int j=2;j<=i;j++)
	f[i]=min(f[i],f[i-j]+g[j]);
	for(int j=1;j<i;j++)
	g[i+j]=min(g[i+j],f[i]+f[j]+i*j);	
	}
	printf("%d",n*(n-1)/2-f[n]+n);
	return 0;
}
```
我们会发现他提交了两次。一次在比赛中提交，一次在题库中提交。

出于好奇，让我们点进比赛链接，在比赛的介绍中惊喜地发现了本题的证明！

再次说明：以下内容为**作者的**idea，非原创（~~我题解可能过不了了~~），只是给大家**展示一下本题的正确证明方法**。

------排版上略有改动------

1.心碎 

手玩:$40$%；打表:$70$%：

我们发现，分的块数 = $N +$ 交点个数。

如果不考虑多线共点，交点个数恰好为逆序对数。

我们构造一个排列 $\{Ai\}$ ，则多线共点的条件为 $Ai$ 中存在三个或以上元素在同一个等差数列的对应位置上。

于是，在构造的过程中，可以从中间选择一段移到最前面。

设 $f(i)$ 表示 $i$ 个点由于多线共点至少损失的逆序对个数，则 $f(i)=min\{f(j)+f(k)+f(i-j-k)\}$.

$O(N^3)$ $100$%：在 $70$% 的基础上，设立数组 $g(i)$ 表示 $f(j)+f(i-j)$ 的最小值，则刚才的方程转化为$f(i)=min\{g(j)+f(i-j)\}$.

$O(N^2)$ 彩蛋：OEIS大法好！把前几项输进OEIS，容易得到规律：答案 = $(N \times N/2)+1$.

---

## 作者：添哥 (赞：2)

# 这是窝的第一道蓝题，所以发篇题解纪念一下
###### ~~好吧其实是贡献分已经归零了（小声bb）~~
其实这道题可以找规律解题，楼上的大佬们已经帮窝们列出好多样例了，我们直接来看一下：

| n: | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
| m: | 1 | 3 | 5 | 9 | 13 | 19 | 25 | 33 | 41 | 51 |

看出什么了吗？

m依次增加

```
+2 +2 +4 +4 +6 +6 +8 +8 +10……
```

然后我们就可以得出核心代码：
```cpp
for(int i=1;i<=n;i++)//i是增加的数量
{
    if(i!=1&&i%2==1)
    {
        ans+=i-1;//如果i不是2的倍数，就只增加i-1
    }
    else
    {
        ans+=i;//否则加i
    }
}
```
窝们控制好了m增加的数字，这道题就迎刃而解了

### AC代码
```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,ans=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        if(i!=1&&i%2==1)
        {
            ans+=i-1;
        }
        else
        {
            ans+=i;
        }
    }
    cout<<ans;
    return 0;
}
```
O(n)复杂度，花了96ms，~~对我来说~~还挺快

不过还是敌不过O(1)复杂度的(n*n)/2+1算法

~~比作者的正解快就够了~~

打字很累，求点赞。

**管理大大最帅了，求过！**

---


# HKE与他的小朋友

## 题目背景

HKE 带着 $n$ 个小朋友做游戏。


## 题目描述

现在有 $n$ 个座位编号为 $1$ 至 $n$，这些小朋友也编号 $1$ 至 $n$。一开始所有小朋友都坐在相应的座位上。HKE 的游戏可用一个 $n$ 的排列 $A(A_1,A_2, \cdots, A_n)$ 表示。一轮游戏时，对于所有的 $1\leq i\leq n$，坐在位置 $i$ 上的小朋友坐到位置 $A_i$ 上。

现在游戏进行了 $k$ 轮，HKE 想知道游戏结束后，位置 $1,2,\cdots, n$ 分别坐了几号小朋友？


## 说明/提示

- 对于 $30\%$ 的数据，$n\leq1000$，$k\leq1000$；
- 对于 $100\%$ 的数据，$n\leq100000$，$k\leq2^{31}-1$。


## 样例 #1

### 输入

```
5 5
2 3 1 5 4```

### 输出

```
2 3 1 5 4```

## 样例 #2

### 输入

```
5 4
2 3 1 5 4```

### 输出

```
3 1 2 4 5```

# 题解

## 作者：ezoixx130 (赞：18)

这不是快速幂模板题吗。。。为什么题解里是倍增，强连通分量，tarjan？？？

题意就是给你一个置换$P$，求$P^k$。

直接快速幂就好了啊。

时间复杂度$O(nlogk)$

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 100010

int n,k,p[MAXN],tmp[MAXN],ans[MAXN];

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i)scanf("%d",p+i),ans[i]=i;
	while(k)
	{
		if(k&1)
		{
			for(int i=1;i<=n;++i)tmp[i]=ans[p[i]];
			for(int i=1;i<=n;++i)ans[i]=tmp[i];
		}
		for(int i=1;i<=n;++i)tmp[i]=p[p[i]];
		for(int i=1;i<=n;++i)p[i]=tmp[i];
		k>>=1;
	}
	for(int i=1;i<=n;++i)tmp[ans[i]]=i;
	for(int i=1;i<=n;++i)printf("%d ",tmp[i]);
}
```

---

## 作者：AFewSuns (赞：10)

给出一种较为清新的解法。

### 题意简述
给你一个序列 $a_i$，一开始 $i$ 就站在 $i$ 的位置上。每一次 $i$ 位置上的人都会跳到 $a_i$，求 $k$ 次后每个位置站的人。


### 题目分析

手动模拟一下它们跳的过程，发现它们组成了一个一个环，

比如样例中的 $2\ 3\ 1\ 5\ 4\ $ 就组成了 $1\rightarrow2\rightarrow3\rightarrow1$ 和 $4\rightarrow5\rightarrow4$ 这样两个环，并且每个环内的元素**只能在环内按顺序**跳，是有一定**周期**的。而周期就是环的大小。

所以记录一下每个元素所在的环（周期），按顺序记录每个环中的元素，再记录每个元素在环上的位置 $id_i$，所以这个元素最终会站在环内的第 $(id_i+k) \pmod {siz} + 1$ 个位置。

每个环的数用 vector 存就好了。

时间复杂度 $O(n)$，比 $O(n\log k)$ 要快，甚至不用任何算法等东西（dfs，bfs，tarjan 等）

代码也比较短。

### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
vector<ll> v[100010];//记录每个环的数有哪些 
ll n,k,a[100010],blg[100010],id[100010],cnt=0,tot;//blg为每个数所在的环（的编号），id为每个数在环上的哪个位置 
int main(){
	scanf("%lld %lld",&n,&k);
	for(ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(ll i=1;i<=n;i++){
		if(blg[i]) continue;//如果已经在环上，就不用继续 
		blg[i]=++cnt;//新建一个环 
		id[i]=tot=0;
		v[cnt].push_back(i);
		for(ll j=a[i];j!=i;j=a[j]){//一直跳，枚举这个环中的元素 
			blg[j]=cnt;
			id[j]=++tot;
			v[cnt].push_back(j);
		}
	}
	for(ll i=1;i<=n;i++){
		ll siz=v[blg[i]].size(),tmp=(id[i]+k)%siz;//siz即为环的大小，tmp为要跳到环上的哪一个位置 
		a[v[blg[i]][tmp]]=i;//记录答案 
	}
	for(ll i=1;i<=n;i++) printf("%lld ",a[i]);
} 
```

---

## 作者：_ztyqwq (赞：7)

upd: 给出的是一个排列，没有基环树，wssb

但是这题倍增也是可行的（

而且如果是基环树的话感觉倍增更好写（

---

如果将这个排列（置换）看作一张有向图，显然会出现环，环的部分可以将 $ k $ 模上环的长度来做，然后就分成了若干基环树…… 草 太麻烦了（

为什么不直接倍增呢？

**设 $ st_{i, j} $ 为 $ i $ 走了 $ 2^j - 1 $ 步后到达的位置**，即，**该点走过的路径上含起点和终点一共有 $ 2^j $ 个点**

边界条件：$ st_{i, 0} = i $（走了 $ 0 $ 步）

转移：

## $ st_{i, j} = st_{a_{st_{i, j - 1}}, j - 1} $

或者写得清楚一点—— `st[i][j] = st[ a[ st[i][j - 1] ] ][j - 1]`

~~也不怎么清楚~~

解释：如果要让 $ i $ 走 $ 2^j - 1 $ 步，可以先让她走 $ 2^{j - 1} - 1 $ 步（最内层 `st[i][j - 1]`），再走一步（中层的 `a[...]`），最后再走 $ 2^{j - 1} - 1 $ 步（最外层 `st[...][j - 1]`）

这样总步数 $ = 2^{j - 1} - 1 + 1 + 2^{j - 1} - 1 = 2^j - 1 $ 满足定义

那么如何求出从某点 $ u $ 走 $ k $ 步后的终点呢？

众所周知，一个数必定有一个二进制表达方式；如果 $ k $ 的二进制第 $ i $ 位（最右是第 $ 0 $ 位开始）是 `1`，则应该走 $ 2^i $ 步，也就是 $ u = a_{st_{u, i}} $

即 `u = a[ st[u][i] ]`

（因为 `st[u][i]` 是走了 $ 2^i - 1 $ 步，再补一步才能到 $ 2^i $ 步)

这样利用二进制拆分就可以实现快速跳转 $ k $ 步了

具体实现中，可以从大到小枚举 $ i $，如果当前的 $ k \geqslant 2^i $，则跳转 $ 2^i $ 步并将 $ k $ 减去 $ 2^i $；否则不操作。这样也可以实现二进制拆分 $ k $ 并跳转的功能。

**题目中求的是每个位置最后是几号点，所以输出的时候要反一下，具体可以参考代码。**

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001], st[100001][32];
int ans[100001];
int main()
{
	int n, k;
	scanf("%d %d", &n, &k);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		st[i][0] = i;
	}
	for(int j = 1; j <= 30; j++)
		for(int i = 1; i <= n; i++)
			st[i][j] = st[a[st[i][j - 1]]][j - 1];
	for(int i = 1; i <= n; i++)
	{
		int u = i, kk = k;
		for(int j = 30; j >= 0; j--)
			if(kk >= (1 << j))
			{
				u = a[st[u][j]];
				kk -= (1 << j);
			}
		ans[u] = i;
	}
	for(int i = 1; i <= n; i++)
		printf("%d ", ans[i]);
	putchar('\n');
	return 0;
}
```

---

## 作者：灯芯糕 (赞：3)


## 本题$solution$:

首先请允许我奶一波：本题出的是真的好！

某蒟蒻心路历程：

小文：这不是矩阵快速幂裸题吗？！！

题面：矩阵快速幂复杂度 $n^3$ OK?

小文：那就降到二维 $n^2$ 优化麻！！！

题面：....$n\leq100000$，are you sure？

小文：我 ~~&%$&#%&#%~~ ！！！！！！！

于是乎让我再仔细看看题目吧：

#### 解 1 ：跑图论求环

我们（在脑海里）建一个图，将第 i 步的结果与第 i+1 步的结果用一条边连起来，跑一遍你会发现这是一个环（即你不断转换下去会回到你的初始状态。所以你将 k mod 一下环的大小（$\leq n$ ）然后跑一遍图即可。（稍稍维护一下复杂度）

~~这对蒟蒻来说太难了，于是就没有代码实现了~~

#### 解 2 ：快速幂

这题其实不存在矩阵成分（有启发效果），重点在与**快速幂**和你的**转移过程**。

#### 原理：
 1.转移的结合律：

下文中但凡以 2 3 1 5 4（一个栗子）为标准转移，2 3 1 5 4 分别表示 $A_1$  $A_2$  $A_3$  $....$ $A_5$ ：

转移的实现：

```
inline void ans(){ //给ans数组转换
	for(rg i=1;i<=n;++i) c[i]=a[i];
	for(rg i=1;i<=n;++i) a[b[i]]=c[i];
}
```

对于一个以 2 3 1 5 4 为标准的转移，我们若转移两次，就相当于进行一次以 3 1 2 4 5 为标准的转移（不信试试）；而我们若转移 3 次，就相当于先进行一次以 3 1 2 4 5 为标准的转移在进行一次以 2 3 1 5 4 为标准的转移。这说明小朋友换位置具有结合律，这是我们快速幂的基础。

而 3 1 2 4 5 是可以通过 2 3 1 5 4 推出来的（类似矩阵乘法）：

$$\begin{vmatrix}2 &3&1&4&5\\2&3&1&4&5\\|&|&|&|&|\\3&1&2&4&5\end{vmatrix}$$

看的出怎么推吗：先讲一下 3 是如何来的：

首先 3 的意义表示 1 号小朋友在转移两次后在 3 号位置。所以我们看到 1 号小朋友第一轮转换时要转换到 2 号位置，而第二轮转换时 2 号位置的人要转换到 3 号位置，所以就相当于一号小朋友在转移两次后要在 3 号位置。 1 2 4 5 也是这样得来的：实现：

```cpp
inline void base(){ //给bese数组转换
	for(rg i=1;i<=n;++i) c[i]=b[i];
	for(rg i=1;i<=n;++i) b[i]=c[c[i]];
}
```

而此时如果我们需要以2 3 1 4 5为标准转移 4 次，就可以直接以 3 1 2 4 5为标准转移两次即可。同样我们还可以用 3 1 2 4 5来推出一个序列，以次序列为标准转移就能直接得到以2 3 1 4 5转移 4 次的结果。

然后直接快速幂求解即可！

### 代码实现：
以某一转换序列来推出下一个转换序列，我们用base函数实现。

以某一序列为标准转移，我们用ans函数实现。（这两个不一样！！
```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#define rg register int

using namespace std;

int n,k;
int b[100001];// base
int a[100001];// answer
int c[100001];// 借来转换赋值

inline int qr(){ char ch; // 快读
	while((ch=getchar())<'0'||ch>'9');
	int res=ch^48;
	while((ch=getchar())>='0'&&ch<='9')
		res=res*10+(ch^48);
	return res;
}

inline void ans(){ //给ans数组转换
	for(rg i=1;i<=n;++i) c[i]=a[i];
	for(rg i=1;i<=n;++i) a[b[i]]=c[i];//重点1
}

inline void base(){ //给bese数组转换
	for(rg i=1;i<=n;++i) c[i]=b[i];
	for(rg i=1;i<=n;++i) b[i]=c[c[i]];//重点2
}

int main(){
	n=qr();k=qr();
	for(rg i=1;i<=n;++i)
		b[i]=qr(),a[i]=i;//赋初值
	while(k){
		if(k&1)ans();
		base();k>>=1;
	}// 快速幂
	for(rg i=1;i<=n;++i)
		printf("%d ",a[i]);//输出ans
	return 0;
}
```

---

## 作者：0nullptr (赞：2)

传送门：[P5151](https://www.luogu.org/problem/P5151)

不难发现小朋友的运动是一种只和座位有关的有方向的运动，因此可以用点来存储座位，用有向边来存储小朋友的运动轨迹。

注意到点数等于边数，因此这张图只能是一个或多个环，才能满足所有人均能多次移动的性质。则问题可以简化为：给定一些环，求在环上运动$k$次后各点的位置。

那么可以很简单的想到判环。在这里直接使用$bfs$判环即可。在判环的同时，还要记录下每个环的大小$T_i$，用于简化每个小朋友的位移量$x_i = k \ mod\ T_i$。并将每个环断开扔入一个链表里面，辅助后续查询。代码如下。
```cpp
vector<int> list[MAXN];//存储环的链表，这里直接用vector代替
int land[MAXN][2];
//存储与环有关的数据
//第0维存储环的编号，第1位存储这该元素是环的第几号元素
int nxt[MAXN];//存下一个点的编号
int T[MAXN];//记录环的大小
int S[MAXN];//手写栈
int lis;//记录环的编号

void bfs1(int st){
    int x = st/*遍历环上的每一个节点*/, tops = 0/*栈顶*/,first = 1/*只是个标记*/;
    while (x != st || first){//遍历环
        first = 0;
        T[st]++;//环的大小增加
        list[lis].push_back(x);//把点扔到链表里
        land[x][0] = lis;
        land[x][1] = tops;//记录有关信息
        S[tops++] = x;//入栈
        x = nxt[x];//遍历下一个点
    }
    while (tops--){//修改每一个点记录的环大小
        T[ S[tops] ] = T[st];
    }//这里也可以不用栈存储，但是手写栈是最简单的。
    lis++;//环的编号增加
}
```
判环之后就是处理答案部分，但是要注意的一点是，这道题不是让你输出每个点在$k$次移动后的位置，而是$k$次移动后每个点上是原来的哪个点。很容易写出这样的代码。
```cpp
int bfs2(int st, int k){
    int step = k % T[st];//计算有用的位移量
    step += land[st][1];//计算相对于环中一号点的位移量
    if (step >= T[st]) step -= T[st];//控制位移量在1 ~ T_i
    return list[ land[st][0] ][step];//返回该点坐标
}

for (int i = 1; i <= n; i++) ans[bfs2(i, k)] = i;
//枚举每个点，计算其结束坐标
```
这些工作都做完好，就可以愉快的切掉这道题了。

完整无修代码
```cpp
#include <iostream>
#include <vector>
#define MAXN 100005
using namespace std;

vector<int> list[MAXN];
int land[MAXN][2];
int nxt[MAXN],T[MAXN],S[MAXN],ans[MAXN];
int lis;

void bfs1(int st){
    int x = st, tops = 0,first = 1;
    while (x != st || first){
        first = 0;
        T[st]++;
        list[lis].push_back(x);
        land[x][0] = lis;
        land[x][1] = tops;
        S[tops++] = x;
        x = nxt[x];
    }
    while (tops--){
        T[ S[tops] ] = T[st];
    }
    lis++;
}

int bfs2(int st, int k){
    int step = k % T[st];
    step += land[st][1];
    if (step >= T[st]) step -= T[st];
    return list[ land[st][0] ][step];
}

int main(){
    int n, k;
    cin>>n>>k;
    for (int i = 1; i <= n; i++) cin>>nxt[i];
    for (int i = 1; i <= n; i++) if (!T[i]) bfs1(i);
    for (int i = 1; i <= n; i++) ans[bfs2(i, k)] = i;
    for (int i = 1; i <= n; i++) cout<<ans[i]<<" ";
    return 0;
}
```


---

## 作者：ModestCoder_ (赞：2)

[原题传送门](https://www.luogu.org/problemnew/show/P5151)


正解是倍增，复杂度$O(nlogk)$，这里有一种朴素的$O(n)$做法

用基本的图论做法，**找环**，并同时计算出环的长度

然后按环，一个环一个环的处理，每个环中的元素往后一起移k % 环长度 个位子，所以这样能做到每个点只走一遍

Code：

```cpp
/*
5 5
2 3 1 5 4
*/
#include <bits/stdc++.h>
#define res register int
#define ll long long
#define maxn 100010
using namespace std;
int n, m, a[maxn], loop[maxn], print[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1; c = getchar();
	}
	while (c >= '0' && c <= '9') s = (s << 1) + (s << 3) + (c ^ 48), c = getchar();
	return s * w;
}

inline int calc(int u, int s){
	loop[u] = s;
	if (loop[a[u]]) return s;
	loop[u] = calc(a[u], s + 1);
	return loop[u];
}

int main(){
	n = read(), m = read();
	for (res i = 1; i <= n; ++ i) a[i] = read();
	for (res i = 1; i <= n; ++ i) if (!loop[i]) loop[i] = calc(i, 0);
	for (res i = 1; i <= n; ++ i)
		if (!print[i]){
			int u = i, v = i; 
			for (ll k = m % loop[i]; k; -- k) v = a[v];
			while (!print[v]){
				print[v] = u; u = a[u]; v = a[v];
			}
		}
	for (res i = 1; i <= n; ++ i) printf("%d ", print[i]);
	return 0;
}
```


---

## 作者：南城忆潇湘 (赞：2)

思路：简单易懂的倍增法~~（想不出思路就直接暴力倍增）~~   
类似于树上求LCA，对于每一个询问，用$log_2k$的时间复杂度来询问。有$n$个询问，所以最终的时间复杂度就是$O(nlog_2k)$啦。（貌似比其他题解的倍增法简单！？但是我是跑得最慢的。。。）  

关键思路：  
将$i$从$31$开始枚举，如果$k$够减$2^i$的话，那么就将$k$减去$2^i$，然后我们跳$2^i$个就可以了。至于如何跳，我们预处理就好了。

代码：  
```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define int long long
using namespace std;

int f[MAXN][41],a[MAXN];

signed main(){
	int n,k;
	cin>>n>>k; 
	for(int i=1;i<=n;i++)
		scanf("%lld",&f[i][0]);
	for(int i=1;i<=40;i++)
		for(int j=1;j<=n;j++)//这两个顺序不能换，想想为啥
			f[j][i]=f[f[j][i-1]][i-1];//标准的预处理
	for(int i=1;i<=n;i++){
		int now=k,ans=i;
		for(int j=40;j>=0;j--)
			if(now>=((long long)1<<j))	now-=((long long)1<<j),ans=f[ans][j];//关键的一行
		a[ans]=i;
	}
	for(int i=1;i<=n;i++)
		printf("%lld ",a[i]);
	cout<<endl;
	return 0;
}
```

~~简单易懂不服来战~~  
顺带辛苦审核的管理啦

---

## 作者：djh123 (赞：2)


由于 $k$ 比较大， 要考虑$nlogk$的复杂度。

注意到我们可以把 $k$ 进行二进制分解，处理出进行 $2^p$ 轮游戏后的位置

$2^p$ 时的位置就是 $2^{p-1}$ 时的位置 再进行 $2^{p-1}$ 轮。

那么就可以用类似于快速幂一样处理

```cpp
#include <cstdio>
using namespace std;
int f[100050], ans[100050], tmp[100005], t[100005];
int n, k; 
void mul(int *x, int *y) {
	for(int i = 1 ; i <= n ; ++ i) t[i] = y[x[i]];
	for(int i = 1 ; i <= n ; ++ i) x[i] = t[i];
}
void ksm(int *x, int k) {
	while(k) {
		if(k & 1) mul(ans, f);
		mul(f, f);
		k >>= 1;
	}
}
int main() {
	scanf("%d %d", &n, &k);
	for(int i = 1 ; i <= n ; ++ i) scanf("%d", &f[i]);
	for(int i = 1 ; i <= n ; ++ i) ans[i] = i;
	ksm(f, k);
	for(int i = 1 ; i <= n ; ++ i) f[ans[i]] = i;
	for(int i = 1 ; i <= n ; ++ i) printf("%d ", f[i]);
}
```

复杂度 $O(nlogk)$

---

## 作者：LlLlCc (赞：1)

建图非常简单，因为每次移动都是$i\rightarrow a_i$，也就是$i$向$a_i$连一条边，答案也就是点$i$连续走$k$次$i\rightarrow a_i$

看到数据范围，$k$非常大，显然不能模拟每个点走$k$步。

不难发现，每个点只有一条出边，也就是如果再次走到这个点，路线是固定的，也就是说对于每个$i$，计算出走到这个点需要几步，对于这个点来说，其实就是绕了数圈后再走$k \mod m$步

因为$a$是排列，所以互不相同，即每个点都只有一条出边和一条入边

也就是说建边后的图必然是多个不相交的环

![](https://cdn.luogu.com.cn/upload/image_hosting/ttt73199.png)
画个图可能更清楚一点

对于这个环来说，点的个数是$4$，所以每个点实质上就只走了$5 \mod 4=1$步

还是这幅图，可以看出，$1\rightarrow 2$，$2\rightarrow 3$，$3\rightarrow 4$，$4\rightarrow 1$

有没有发现什么？

我们只要求出第一个点走$k \mod m$步后，第二个点就是在第一个点走$k \mod m$步的基础上再走一步，第三个点就是在第二个点的基础上再走一步,$\cdots$

对于每个环我们只要$O(n)$先算出第一个点走到哪里，然后再依次将其他点赋值就行，这个操作也是$O(n)$的

至于找环，$dfs$或者$Tarjan$都行

## code
```
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;
int n,Ans[maxn],k,Dep[maxn],tot,nxt[maxn],top,Q[maxn],low[maxn],a[maxn],N,Cnt;
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
inline int Get(int x,int tot){return tot? Get(nxt[x],tot-1):x;}
inline void Tarjan(int x){
	Dep[x]=low[x]=++tot;
	if (!Dep[nxt[x]]) Tarjan(nxt[x]),low[x]=min(low[x],low[nxt[x]]);
	else low[x]=min(low[x],Dep[nxt[x]]);
	if (Dep[x]==low[x]){
		a[N=1]=x;int Now=nxt[x];
		while (Now!=x) a[++N]=Now,Now=nxt[Now];
		Cnt=k%N,Now=Get(a[1],Cnt);
		for (int i=1;i<=N;i++) Ans[Now]=a[i],Now=nxt[Now];
	}
}
int main(){
	n=read(),k=read();
	for (int i=1;i<=n;i++) nxt[i]=read();
	for (int i=1;i<=n;i++) if (!Dep[i]) Tarjan(i);
	for (int i=1;i<=n;i++) printf("%d ",Ans[i]);
	return 0;
}
```


---

## 作者：sleepyNick (赞：1)

提供一种暴力但思维清奇的方法：

我们很容易发现，这些小朋友的操作可以用有向边来表示。

很自然地想到这些有向边会连成环，而经过k次操作后小朋友的位置会在环内不断循环。

先用tarjan进行缩点，我们可以用vector把环全部存起来，对于每个小朋友，可以通过k 对环大小取模直接找到最终位置。

时间复杂度$O(N)$(tarjan$O(n)$+处理答案$O(n)$)

Code:
```cpp
#include <bits/stdc++.h>
#define rep(x,a,b) for (register int x = a; x <= b; x++)
#define cross(x,a) for (register int x = head[a]; x; x = edge[x].next)
#define MAXN 150000
using namespace std;

struct Front_Link_Star {
    int next, to;
}edge[MAXN];

vector <int> mmp[MAXN];

int head[MAXN], dfn[MAXN], low[MAXN], stac[MAXN], DAG[MAXN];
int cnt[MAXN], ans[MAXN], a[MAXN], pos[MAXN];
int _cnt, idx, top, tot_circle, n, k;
bool vis[MAXN];

inline void connect (int u, int v) {
    edge[++_cnt].to = v;
    edge[_cnt].next = head[u];
    head[u] = _cnt;
}

//tarjan
void tarjan (int now) {
    dfn[now] = low[now] = ++idx;
    vis[now] = 1; stac[++top] = now;
    cross (i, now) {
        int v = edge[i].to;
        if (! dfn[v]) {
            tarjan (v);
            low[now] = min (low[now], low[v]);
        }
        else if (vis[v]) low[now] = min (low[now], low[v]);
    }
    if (dfn[now] == low[now]) {
        tot_circle++;
        while (int y = stac[top--]) {
            DAG[y] = tot_circle;
            cnt[DAG[y]]++;
            vis[y] = 0;
            if (now == y) break;
        }
    }
}

int main () {
    scanf ("%d %d", &n, &k);
    rep (i, 1, n) {
        scanf ("%d", &a[i]); connect (i, a[i]);
    }
    rep (i, 1, n) if (! dfn[i]) tarjan (i);
    memset (vis, 0, sizeof (vis));
    rep (i, 1, n) {
    	int now = i;
        while (! vis[now]) {
            mmp[DAG[i]].push_back (now);
            vis[now] = 1; now = a[now];
        }
    }
    //用vector把环存起来
    //mmp[i][j]表示第i个环第j个元素
    rep (i, 1, tot_circle) {
        int rest = k % cnt[i]; 
        rep (j, 0, mmp[i].size ()-1) {
            ans[mmp[i][(j+rest) % cnt[i]]] = mmp[i][j];
        }
    }
    //k对环大小取模直接找到最终位置
    rep (i, 1, n) printf ("%d ", ans[i]);
    return 0;
}
```


---

## 作者：Zechariah (赞：1)

思路很简单，把“每个位置的小朋友要去的位置”看成是有向边，然后找环，并且处理出每个环中的每个点在第几个位置（这个可能说的不清楚，看代码就明白了），然后枚举每一个小朋友，O(1)求出他们最终的位置，记录答案
```cpp
#include <bits/stdc++.h>
const int N = 1e5 + 10;
using namespace std;
inline long long read()
{
    register long long num = 0;
    register bool flag = false;
    register char ch;
    while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r');
    if (ch == '-')flag = true; else num = ch ^ 48;
    while ((ch = getchar()) != ' '&&ch != '\n'&&ch != '\r'&&~ch)
        num = num * 10 + (ch ^ 48);
    if (flag)return -num; return num;
}
int nt[N], dfn[N], low[N], ltk[N], cnt, tot, st[N], ssize[N], wh[N];
bool flag[N];
vector<int>which[N];
inline void tarjan(register int x)
{
    low[x] = dfn[x] = ++tot;
    flag[x] = true; st[++st[0]] = x;
    if (!dfn[nt[x]])tarjan(nt[x]), low[x] = min(low[x], low[nt[x]]);
    else if (flag[nt[x]])low[x] = min(low[x], dfn[nt[x]]);
    if (low[x] == dfn[x])
    {
        ++cnt;
        while (st[st[0] + 1] != x)
        {
            flag[st[st[0]]] = false;
            which[cnt].push_back(st[st[0]]);
            wh[st[st[0]]] = which[cnt].size() - 1;
            ltk[st[st[0]]] = cnt;
            ++ssize[cnt];
            --st[0];
        }
    }
}
int ans[N];

int main()
{
    register int n = read(), k = read();
    for (register int i = 1; i <= n; ++i)nt[i] = read();
    for (register int i = 1; i <= n; ++i)if (!dfn[i])tarjan(i);
    for (register int i = 1; i <= n; ++i)
    {
        register int dist = k % ssize[ltk[i]], now, wher = wh[i];
        now = which[ltk[i]][(wher - dist + ssize[ltk[i]]) % ssize[ltk[i]]];
        ans[now] = i;
    }
    for (register int i = 1; i <= n; ++i)printf("%d ", ans[i]);
    return 0;
}
```

---

## 作者：mrclr (赞：1)


看到$i$变成了$A_i$，我突然想起了置换这个东西。于是马上到网上学了一遍轮换乘法。

手模后发现轮换乘法满足结合律，但不满足交换律。

于是就可以快速幂啦。

需要注意的是每一次相乘是$O(n)$的，因此总复杂度为$O(n \log n)$。

代码一看就懂
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<map>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 1e5 + 5;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}

int n, k, a[maxn];

int tp[maxn], ret[maxn];
In void mul(int* ret, int* a)
{
  for(int i = 1; i <= n; ++i) tp[i] = ret[a[i]];
  for(int i = 1; i <= n; ++i) ret[i] = tp[i];
}
In void quickpow(int* a, int b)
{
  for(int i = 1; i <= n; ++i) ret[i] = i;
  for(; b; b >>= 1, mul(a, a))
    if(b & 1) mul(ret, a);
}

int main()
{
  n = read(); k = read();
  for(int i = 1; i <= n; ++i) a[i] = read();
  quickpow(a, k);
  for(int i = 1; i <= n; ++i) tp[ret[i]] = i;
  for(int i = 1; i <= n; ++i) write(tp[i]), space; enter;
  return 0;
}
```

---

## 作者：Baihua (赞：1)

## P5151 HKE与他的小朋友

* #### 思路：倍增 ，强联通分量 ；

* 每个位置抽象为一个**点** ，和将要去的座位**连边**，就可以转化为图论问题。

* 他们会在一个环里转，那么知道 **环的大小**后就可以直接取余运算 。

* 关于倍增思想的应用：

  1. 设$A[j][i]$表示从$j$进行$2^i$轮所到达的位置。

  2. 那么有

     ### $A[j][i] = A[A[j][i-1]][i-1]$

  3. 类比倍增求$LCA$即可；

* 点击[这里](https://www.luogu.org/problemnew/show/P3387)学习强联通分量

* ```c++
  #include <iostream>
  #include <fstream>
  #include <algorithm>
  #include <string.h>
  #include <math.h>
  #include <algorithm>
  #define re register
  #define GC getchar()
  #define UI long long int
  #define Clean(X) memset(X,0,sizeof(X))
  using namespace std ;
  int Qread() {
  	int X = 0;
  	char C = GC ;
  	while (C > '9' || C < '0') C = GC ;
  	while (C >='0' && C <='9') {
  		X = X * 10 + C - '0' ;
  		C = GC ;
  	}
  	return X ;
  }
  const int Maxn = 100005 , Maxpw = 18;
  int A[Maxn+1][Maxpw+1] ,Cnt = 0 ,GT[Maxn] , N , Low[Maxn] , Dfn[Maxn] ,Color[Maxn] , Vis[Maxn] , St[Maxn] , Top = 0 , Index , Size[Maxn] , Num[Maxn] , Ans[Maxn] , T[Maxn];
  void Tarjan (int X) {
  	Vis[X] = 1 ;
  	Low[X] = Dfn[X] = ++ Index ;
  	St[++Top] = X ;
  	if (!Dfn[GT[X]]) {
  		Tarjan(GT[X]) ;
  		Low[X] = min (Low[X] , Low[GT[X]]) ;
  	} else if (Vis[GT[X]]) {
  		Low[X] = min (Low[X] , Dfn[GT[X]]) ;
  	}
  	if (Low[X] == Dfn[X]) {
  		++ Cnt ;
  		while (X != St[Top]) {
  			++Size[Cnt] ;
  			Color[St[Top]] = Cnt ;
  			Vis[St[Top]] = 0 ;
  			Num[St[Top]] = Size[Cnt] ;
  			-- Top ;
  		}
  		++Size[Cnt] ;
  		Color[X] = Cnt ;
  		Vis[X] = 0 ;
  		Num[X] = Size[Cnt] ;
  		-- Top ;
  	}
  }
  long long int R ;
  int Turn (int X , int Y) {
  	int Now = 0 ;
  	for (re int i = Maxpw ; i >= 0; -- i) {
  		if (Now + (1 << i) <= Y) {
  			Now += (1 << i) ;
  			X = A[X][i] ;
  		}
  	}
  	return X ;
  }
  int main () {
  	//freopen ("P5151.in" , "r" , stdin) ;
  	N = Qread() ;
  	cin>>R ;
  	for (re int i = 1 ; i <= N ; ++ i) GT[i] = A[i][0] = Qread() ;
  	Clean(Dfn) , Clean(Color) , Clean(Vis) , Clean(Size);
  	for (re int i = 1 ; i <= N ; ++ i) {
  		if (Dfn[i]) continue ;
  		Tarjan (i) ;
  	}
  	for (re int i = 1 ; i <= Maxpw ; ++ i) for (re int j = 1 ; j <= N ; ++ j) A[j][i] = A[A[j][i-1]][i-1] ;
  	for (re int i = 1 ; i <= N ; ++ i) Ans[Turn (i , R % Size[Color[i]])] = i ;
  	for (re int i = 1 ; i <= N ;++ i) printf ("%d " , Ans[i]) ;
  	fclose (stdin) ;
  	fclose (stdout);
  	return 0;
  }
  ```

### Thanks ！



---

## 作者：YanLei (赞：0)

- 题意：
给定一个置换群 $P$\
初始序列为 $a_i=i$\
询问：初始序列进行 $k$ 次置换后，每个位置的元素为几
- 置换是什么？\
$P[i]$ 就是表示目前位置为 $i$ 的元素在下一次置换后的位置为 $P[i]$
- 不是一个暴力 $dfs$ 就可以解决了嘛！\
首先我们知道，对于一个置换群，其内部有许多循环着的位置。比如：\
置换群 $P=[1,2,3,5,4]$，元素 $A=[1,2,3,4,5]$ 的置换操作如下：\
$[1,2,3,4,5]$\
$[3,1,2,5,4]$\
$[2,3,1,4,5]$\
$[1,2,3,5,4]$\
$\cdots$\
尽管对置换群有许多有用的结论，我们只要记住：**总的置换由许多循环的小置换形成**。\
于是，我们可以找到每一个**循环置换的循环节$cnt$**，因为你移动 $k$ 步，所以相当于移动了 $cnt\%k$步。\
这样，我们就找到了**该循环置换的第一个元素的最终置换位置 $tmp$**。\
那么该循环置换的下一个元素的最终位置，不就是 $tmp$ 位置的**下一个置换位置嘛！**
- 综上，我们可以$O(n)$ 找到每一个位置 $i$ 的置换最终位置 $ans[i]$\
(｀・ω・´)

```c
/*
 _            __   __          _          _
| |           \ \ / /         | |        (_)
| |__  _   _   \ V /__ _ _ __ | |     ___ _
| '_ \| | | |   \ // _` | '_ \| |    / _ \ |
| |_) | |_| |   | | (_| | | | | |___|  __/ |
|_.__/ \__, |   \_/\__,_|_| |_\_____/\___|_|
        __/ |
       |___/
*/
int nxt[MAX];
bool vis[MAX];
int ans[MAX];
void solve(int x,ll k){
    int cnt = 0;
    while(!vis[x]){		/// 找循环节长度
        vis[x] = 1;
        x = nxt[x];
        cnt++;
    }
    k = k % cnt;

    int tmp = x;
    for(int i = 1;i <= k;++i)	/// 找到位置 x 的初始元素经过 k 次置换后的最终位置 tmp
        tmp = nxt[tmp];

    while(!ans[tmp]){
        ans[tmp] = x;		/// 位置 tmp 的元素为 x
        x = nxt[x];			/// 元素下一置换
        tmp = nxt[tmp];		/// 位置下一置换
    }
    return ;
}
int mian()
{
    int n;ll k;
    scanf("%d%lld",&n,&k);
    for(int i = 1;i <= n;++i)scanf("%d",&nxt[i]);
    for(int i = 1;i <= n;++i){
        if(!ans[i])solve(i,k);
        printf("%d ",ans[i]);
    }
    return 0;
}
```


---

## 作者：DukeLv (赞：0)

好题为啥没人发题解。。。

这个题的题意很好理解，一开始看没什么思路。但我们仔细思考会发现，整个图中会有一部分的座位会组成一个环，而且每个座位在且只在一个环里。那我们考虑找到这个图中的环，暴力dfs即可，然后取模得到需要操作的次数。

代码：

```

#include<iostream>
#include<cstdio>
#include<cmath>
#include<ctime>
#include<queue>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
#define duke(i,a,n) for(int i = a;i <= n;i++)
#define lv(i,a,n) for(int i = a;i >= n;i--)
#define clean(a) memset(a,0,sizeof(a))
const int INF = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef long long ll;
typedef double db;
template <class T>
void read(T &x)
{
	char c;
	bool op = 0;
	while(c = getchar(), c < '0' || c > '9')
		if(c == '-') op = 1;
	x = c - '0';
	while(c = getchar(), c >= '0' && c <= '9')
		x = x * 10 + c - '0';
	if(op) x = -x;
}
template <class T>
void write(T x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) write(x / 10);
	putchar('0' + x % 10);
}
int n,to[300000],vis[300000],maxn = 0;
int ru[300000],num[100005];
vector <int> ve[100005];
int k = 0;
void dfs(int u,int tim,int now) //找环
{
	ru[to[u]] = 0;
	if(vis[u] == 0)
	vis[u] = tim;
	else
	{
		return;
	}
	ve[now].push_back(u);
	dfs(to[u],tim + 1,now);
	vis[u] = 0;
}
int main()
{
	read(n);read(k);
	duke(i,1,n)
	{
		read(to[i]);
		ru[to[i]]++;
	}
	duke(i,1,n)
	{
		if(ru[i] == 0)
		{
			ru[to[i]]--;
		}
	}
	int cnt = 0;
	duke(i,1,n)
	if(ru[i] != 0)
	{
		dfs(i,1,++cnt);
	}
	duke(i,1,cnt)
	{
		int t = ve[i].size();
		int el = k % t; //判断移动几步
//		cout<<t<<endl;
		duke(j,0,t - 1)
		{
			num[ve[i][j]] = ve[i][(j - el + t) % t];//暴力移动
		}
	}
	duke(i,1,n)
	{
		printf("%d ",num[i]);
	}
	return 0;
}
/*
5
2 3 1 5 4
*/

```

---


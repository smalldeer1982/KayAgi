# WD与矩阵

## 题目背景

WD整日沉浸在矩阵中，无法自拔……

## 题目描述

WD 特别喜欢矩阵，尤其是 01 矩阵。

一天，CX 给了 WD 一个巨大的 $n$ 行 $m$ 列的 01 矩阵，WD 发现这个矩阵每行、每列的异或值都是 0。

CX 随后就问道：“WD，你知道有多少 01 矩阵每行每列异或值都是 0 吗！？”WD 当然不会这个问题，于是他来请教你。

由于答案可能很大，输出结果模 $998\,244\,353$ 的值即可。

## 说明/提示

- subtask1（11pts）：$1\le T\le 10,~1\le n,m\le 4$
- subtask2（43pts）：$1\le T\le 5,~1\le n\le 5,~1\le m\le 1,000$
- subtask3（46pts）：$1\le T\le 10^5,~1\le n,m\le 10^9$

## 样例 #1

### 输入

```
2
2 2
2 2018```

### 输出

```
2
851481696```

# 题解

## 作者：「已注销」 (赞：15)

先看$1\times m$矩阵，每个数都只能为$0$，答案是$1$

考虑$2\times m$，显然第一行有$2^{m-1}$种方法填，因为每列异或为$0$，$a_{2i}$一定等于$a_{1i}$，所以答案是$2^{m-1}$

推广到$n\times m$，前$n-1$行共有$(2^{m-1})^{n-1}=2^{(n-1)(m-1)}$种填法

前$n-1$行确定时，最后一行填法唯一，$a_{ni}=a_{n-1\ i}⊕a_{n-2\ i}⊕a_{n-3\ i}⊕\dots ⊕a_{1\ i}$

因为前$n-1$行异或和均为$0$，第$n$行也符合题意

综上，答案为$$\huge 2^{(n-1)(m-1)}$$

快速幂取模即可

---

## 作者：NekoPass (赞：11)

## 这么水的题目居然都没有人发题解QwQ？
emmm，比赛的时候只看了第一题然后惊讶地发现这居然是一道真·打卡题！于是开心o(*￣▽￣*)ブ地收下了这100分

怎么说呢，既然是01矩阵，那么每行每列（****这里我们要把每行每列的最后一个值排除在外****）的最终值就只有0和1两种可能~~（もちろん）~~本题要求每行每列的值均为0，那么很容易想到，最后一个数字的值是固定的，就好像下面这个矩阵(x代表还没有填入数字的位置)

0 0 1 x

1 0 1 x

0 1 1 x

x x x x

除了（4，4）暂时没办法确定之外，其他的数值都是确定的喵。所以矩阵变成了这样

0 0 1 1

1 0 1 0

0 1 1 0

1 1 1 1

此时x的值也变成了一个定值，就是0，并且我们可以很容易地证明，最后一行一定是一个满足要求的行（既然每一行的每一个值都和他上面的那一个已经满足条件的行的值不一样，那他本身的数值自然也是0）

不难发现，这道题就是让你求一个n*m的矩阵中间那一个（n-1）*（m-1）的01矩阵到底有多少种可能，也就是说，这道题只是一道简单的
# 快速幂
接下来又是愉快的上代码时间
```cpp
#include <cstdio>
#define ll long long
const int mod=998244353;
int p;
using namespace std;
inline ll fpow(ll a,int b){
    ll ans=1;
    while(b){
        if(b%2==1) ans=(ans*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    ans%=mod;
    return ans;
}
int main(){
    int T,n,m;
    scanf("%d",&T);
    for(int i=0;i<T;++i){
        scanf("%d%d",&n,&m);
        p=fpow(2,n-1);
        p=fpow(p,m-1);
        printf("%d\n",p);
    }
    return 0;
}
```

~~请务必让我通过嘛OwO~~

---

## 作者：syksykCCC (赞：8)

然而我并没有赶上比赛。。。

拿到这种题，首先肯定会想到有规律，而我这种蒟蒻并没有什么很好的逻辑思维~~（noip2018d2t2挂了）~~，自然就想到了打表找规律的方法，先上一下dfs的简易代码
```cpp
#include<iostream>
using namespace std;
typedef long long ll;
ll n,m,t,ans;
int Map[1000][1000];
void check()
{
	ll xxor;
	bool f=true;
	for(int i=1;i<=n;i++)
	{
		xxor=0;
		for(int j=1;j<=m;j++)
		{
			xxor^=Map[i][j];
		}
		if(xxor)
		{
			f=false;
			break;
		} 
	}
	for(int i=1;i<=m;i++)
	{
		xxor=0;
		for(int j=1;j<=n;j++)
		{
			xxor^=Map[j][i];
		}
		if(xxor)
		{
			f=false;
			break;
		} 
	}
	if(f)
	{
		ans=(ans+1)%998244353;
	}
}
void dfs(ll p,ll q)
{
	if(p==n && q==m)
	{
		Map[p][q]=0;
		check();
		Map[p][q]=1;
		check();
	}
	else if(p<n && q==m)
	{
		Map[p][q]=0;
		dfs(p+1,1);
		Map[p][q]=1;
		dfs(p+1,1);
	}
	else
	{
		Map[p][q]=0;
		dfs(p,q+1);
		Map[p][q]=1;
		dfs(p,q+1);
	}
}
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		ans=0;
		dfs(1,1);
		cout<<ans<<endl;
	}
	return 0;
}
```
只有11分。。。

然后利用它，可以试图找一找规律，首先将一个$5\times5$的答案表给打出来：
```
1      1      1      1      1
1      2      4      8     16
1      4     16     64    256
1      8     64    512   4096
1     16    256   4096  65536
```

其中第i行j列的数表示$n=i,m=j$时的答案

相信大家都发现了，答案都是2的幂，在研究一下其与n，m，的关系，发现：

$$ans=2^{(n-1)(m-1)}$$

加上快速幂优化，于是AC代码就出来了：
``` cpp
#include<iostream>
using namespace std;
const long long MOD=998244353;
long long ksm(long long a,long long b)
{
	long long res=1;
	while(b)
	{
		if(b&1)res=res*a%MOD;
		a=a*a%MOD;
		b>>=1; 
	}
	return res;
}
int main()
{
	long long n,m,t;
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		cout<<ksm(2,(n-1)*(m-1))<<endl;
	}
	return 0;
} 
```
果然是暴力出奇迹啊！

还请各位大佬指正哦！

---

## 作者：STL_qwq (赞：4)

原题链接：[传送门](https://www.luogu.com.cn/problem/P5159)

------------
### 题目大意：
求每行每列异或值都是 $0$ 的 $n$ 行 $m$ 列的矩阵的数量。

------------

### 分析：
首先，让我们了解一下异或的运算法则：

$1⊕1=0$

$0⊕0=0$

$1⊕0=1$

我们通过观察可以发现，对于一个01序列，要使其异或值为 $0$，就应该让其里面有偶数个 $1$。

那么对于 $n$ 个数的01序列，我们就有 $2^{n-1}$ 种方法让其里面有偶数个 $1$。

扩展到 $n$ 行 $m$ 列的01矩阵时，我们发现就有 $2^{(n-1)(m-1)}$ 种方法。

所以这道题的答案就是 $2^{(n-1)(m-1)}$，对于取模运算，我们只需要用快速幂就可以了。（还不会快速幂的[戳这里](https://www.luogu.com.cn/problem/P1226)）

于是，我们就可以愉快的A掉这题了！

------------
### **AC 代码**：

```cpp
#include<cstdio> 
#include<iostream>

using namespace std;

const int c=998244353;//需要取余的值 。 
long long T,n,m;//记得开long long

long long ksm(long long a, long long b)
{
	long long ans = 1;
	a %= c;
	while (b != 0) {
		if (b % 2 == 1) {
			ans = (ans*a) % c;
		}
		a = (a*a) % c;
		b /= 2;
	}
	return ans;
}//快速幂。 

int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld %lld",&n,&m);
		printf("%lld",ksm(2,(n-1)*(m-1)));
		puts(" ");
	}
	return 0;
}
```


---

## 作者：Refined_heart (赞：3)

~~话说打比赛时脑子一抽没找出规律……(太蒟)~~

这个看到要取模，应该就是要用快速幂了……

接下来找公式：

当n=1,m=1时，ans=1;

当n=1,m=2时，ans=1;

当n=2,m=2时，ans=2;

当n=2,m=3时，ans=4;

当n=2,m=4时，ans=8;

当n=2,m=5时，ans=16;

当n=2,m=6时，ans=32;

.....

**你发现了什么神奇的事情？？？**

首先，根据多年的~~（脑抽）~~经验，不难看出ans是2
的平方数~~（废话）~~

于是，打表得到：ans=2的(n-1)(m-1)次方啊！

ans=2的(n-1)(m-1)次方！

ans=2的(n-1)(m-1)次方！

ans=2的(n-1)(m-1)次方！

~~（重要的事情说三遍）~~

所以，代码就很好写了：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define mod 998244353
long long fast(long long x,long long y){
	long long ans=1,base=x;
	while(y>0){
		if(y&1){
			ans*=base;
			ans%=mod;
		}
		base*=base;
		base%=mod;
		y/=2;
	}
	return ans%mod;
}
int main(){
	long long t,n,m;
	cin>>t;
	for(long long i=1;i<=t;i++){
		cin>>n>>m;
		long long xx=(n-1)*(m-1);
		cout<<fast(2,xx);
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：天羽 (赞：3)


其实这道题思路挺简单的。

首先我们要知道一件事,如果一个01序列中有偶数个1,那么最后出来异或和一定为0。

那么问题就变成了求m乘n大小的01矩阵,有多少种方法可以让每行每列有偶数个1。

然后对于每一个m-1乘n-1大小的01矩阵,都只有唯一一种添加数字的方法使它变成每行每列都有偶数个1的m乘n大小的01矩阵。

所以答案就是2^(m-1)(n-1)。

代码:
```cpp
#include <iostream>
using namespace std;
int main(){
    long long int t,n,m;
    cin>>t;
    for(int i=1;i<=t;i++){
        cin>>n>>m;
        long long int x=2,ans=1;
        n=(n-1)*(m-1);
        while(n>0)//快速幂
        {
            if(n%2==1)ans=(ans*x)%998244353;
            n/=2;
            x=(x*x)%998244353;
        }
        cout<<ans<<endl;
    }
}
```

---

## 作者：Cheng_yf (赞：2)

其实这是一个找规律的题

我们可以暴力搜索找出规律

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int hang[10],lie[10];
int n,m;
int ans;
void dfs(int cur){
	if(cur == n * m){
		for(int i=1;i<=n;i++) if(hang[i] == 1) return;
		for(int i=1;i<=m;i++) if(lie[i] == 1) return;
		ans++;
		return;
	}
	dfs(cur+1);
	hang[cur/m + 1]^=1;
	lie[cur%m + 1]^=1;
	dfs(cur+1);
}
int main(){
	for(int i=1;i<=5;i++){
		for(int j=1;j<=5;j++)
			ans=0,n=i,m=j,dfs(0),printf("%d ",ans);
		putchar(10);
	}
	return 0;
}
```

putout:

1 1 1 1 1

1 2 4 8 16

1 4 16 64 256

1 8 64 512 4096

1 16 256 4096 65536

于是答案就等于2^((n - 1) * (m - 1)),快速幂计算出来

正解：

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define ll long long
using namespace std;
int t;
ll n,m;
ll power(ll n,ll x){
	ll sp=1LL;
	while(x){
		if(x&1) sp=(sp*n)%mod;
		n=(n*n)%mod;
		x>>=1;
	}
	return sp;
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%lld%lld",&n,&m);
		printf("%lld\n",power(2,(n-1)*(m-1)));
	}
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

## 1.题意

本题让我们求有多少中符合要求的 $01$ 矩阵满足每行每列异或值都为 $0$。

## 2.分析

观察到异或有如下性质：

给定一个 $n\times m$ 的矩阵，可以构造一个 $(n+1)\times (m+1)$ 的矩阵满足每行每列的异或值为定值。

证明如下：

我们考虑这个矩阵中的某行 $a$，设它的异或值为 $x$，因为异或的结合性，最后一个数取 $0/1$ 时，$x \operatorname{xor} 0/1$ 的值可取 $0/1$ 中的任意数。

综上，答案即为 $(n-1)\times(m-1)$ 的 $01$ 矩阵的总个数，快速幂即可解决。

## 3.代码

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;

int Pow(int a,int b)
{
	if(b==0)
		return 1;
	if(b==1)
		return a;

	if(b%2==0)
	{
		int ans=Pow(a,b/2)%MOD;

		return (ans*ans)%MOD;
	}
	else
	{
		int ans=Pow(a,b/2)%MOD;

		return ((ans*ans)%MOD*a)%MOD;
	}
}

signed main()
{
	int T;

	cin>>T;

	while(T--)
	{
		int n,m;

		cin>>n>>m;

		cout<<Pow(2,(n-1)*(m-1))<<endl;
	}

	return 0;
}

```

---

## 作者：Karry5307 (赞：1)

[$$\Huge{\color{pink}\texttt{My }\color{cyan}\texttt{Blog}}$$](https://karry5307.github.io/)
### Description
求有多少个$n\times m$的矩阵，使得每行每列异或值都是$0$。

Data Range：$T\leq 10^5,1\leq n,m\leq 10^9$
### Solution
先声明一下，$(n,m)$表示$n\times m$矩阵的答案，这里假定$n\leq m$，因为$(n,m)=(m,n)$。

不知道有没有人在看到这题的时候想到了NOIP 2018的填数游戏，按照这个思路，可以写一个爆搜跑一下小数据，这里记录一下我得到的小数据的答案：

$(2,2)=2,(2,3)=4,(2,4)=8,(2,5)=16,(2,6)=32\cdots$

$(3,3)=16,(3,4)=64,(3,5)=256,(3,6)=1024\cdots$

$(4,4)=512,(4,5)=4096,(4,6)=32768\cdots$

$(5,5)=65536\cdots$

首先考虑$(n,m)\div (n,m-1)$，把这个值记为$\operatorname{grow}(n)$，于是有：

$\operatorname{grow}(2)=2,\operatorname{grow}(3)=4,\operatorname{grow}(4)=8,\operatorname{grow}(5)=16\cdots$

所以$\operatorname{grow}(n)=2^{n-1}$。

接下来算$(n,n)$，有：

$(2,2)=2,(3,3)=16,(4,4)=512,(5,5)=65536$。

乍一看，没什么规律，所以将这些式子变个形：

$(2,2)=2^1,(3,3)=2^4,(4,4)=2^9,(5,5)=2^{16}\cdots$

啊哈！这样就有规律啦qwq！

于是就有$(n,n)=2^{(n-1)^2}$

综上，可以得出$(n,m)\equiv 2^{(n-1)^2}\times(2^{n-1})^{m-n}$。

于是就可以用快速幂做啦qwq。

但是这样子$\texttt{Subtask 3}$会TLE，所以考虑优化。

不是有欧拉定理吗？

所以说可以把$(n-1)^2$模个$\varphi(998244353)=998244352$，就可以完结撒花啦qwq！
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
const ll MOD=998244353;
ll test,length,width,base,grow;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent,ll mod)
{
    if(!exponent)
    {
        return 1;
    }
    ll temp=qpow(base,exponent>>1,mod),res=temp*temp%mod;
    if(exponent&1)
    {
        res=res*base%mod;	
    }	
    return res;
}
int main()
{
    test=read();
    for(register int i=0;i<test;i++)
    {
        length=read(),width=read();
        if(length>width)
        {
            swap(length,width);
        }
        base=qpow(2,(length-1)*(length-1)%(MOD-1),MOD);
        grow=qpow(2,length-1,MOD);
        printf("%lld\n",base*qpow(grow,width-length,MOD)%MOD);
    }
}
```

---

## 作者：shadowice1984 (赞：1)

 _这里我们设$popcount(x)$表示x的二进制表示下1的个数_ 

我们把矩阵的每一行看成一个非常长的二进制数

那么我们发现最后一行必然等于前面所有数字的异或和

并且我们发现我们填的每一个数字二进制下恰好有偶数个1

由于

$$popcount(x \oplus y)=popcount(x)+popcount(y)-2popcount(x \& y)$$

那么只要x和y的popcount都是偶数$x\oplus y$的popcount也是偶数

所以前n-1个数字的异或和必然有偶数个popcount,所以最后一行必然合法

这样的话前$n-1$行就可以随便填了

我们发现长度为$m$的二进制数当中，popcount为偶数的数字恰好有$2^{m-1}$个

所以我们的答案就是

$$(2^{m-1})^{n-1}=2^{(m-1)(n-1)}$$

写个快速幂就行了

上代码~

```C
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;typedef long long ll;
const ll mod=998244353;ll n;ll m;int T;const ll mod2=998244352;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
int main()
{
    scanf("%lld",&T);
    for(int z=1;z<=T;z++)
    {
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",po(2,(n-1)*(m-1)%mod2));
    }return 0;
}
```



---

## 作者：NaCly_Fish (赞：1)

~~这是一道打表找规律好题。~~

随便就可以写出这样的一段爆搜代码：   
其中$\text{a}$就是$n*m$的矩阵
```cpp
void dfs(int x,int y){
    if(x==1&&y>m){
        int t;
        for(int i=1;i<=n;++i){
            t = 0;
            for(int j=1;j<=m;++j)
                t ^= a[i][j];
            if(t==1) return;    
        }
        for(int j=1;j<=m;++j){
            t = 0;
            for(int i=1;i<=n;++i)
                t ^= a[i][j];
            if(t==1) return;    
        }
        ++ans;
        return;
    }
    a[x][y] = 1;
    if(x==n) dfs(1,y+1);
    else dfs(x+1,y);
    a[x][y] = 0;
    if(x==n) dfs(1,y+1);
    else dfs(x+1,y);
}
```   
然后$\text{dfs}(1,1)$就能得出答案  

打一个$5*5$的表就够，可以发现答案是$2^x$  
再找一下规律，发现$x=(n-1)(m-1)$  
正确性证明：~~不会~~  
那就引用一下出题人的说法吧：  
>因为我们可以最后一行和最后一列完全可以根据前面填的值直接算出来，因此任意排列前面的东西即可  

比如第一行的前$m-1$个格子都已经填好了数，如果有奇数个$1$，为了满足条件，第$m$个格子应当填$1$；否则填$0$。  
对于其它行列的最后一个格子也可以这么计算。 
所以前$(n-1)*(m-1)$个格子可以随便填。

正解：  
直接算$2^{(n-1)(m-1)}$就行，由于$n,m$都很大，幂次也会比较大。根据费马小定理：   
### $a^{p-1}\equiv1\space (\text{mod }p)$  
就可以把$(n-1)(m-1)$对$p-1$取模后再计算，每组数据的时间复杂度就可以降到$\Theta(\log p)$   

代码：  
(不用管那循环展开)
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
#define p 998244353
#define int long long
using namespace std;

int n,m,ans;

inline void read(int &x);
void print(int x);
inline int power(int a,int t);

inline void solve(){
    read(n),read(m);
    print(power(2,(n-1)*(m-1)%998244352));
    putchar('\n');
}

signed main(){
    int T,t;
    read(T);
    t = (T>>5)<<5;
    T &= 31;
    while(t>0){
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        solve(),solve(),solve(),solve();
        t -= 32;
    }
    while(T--) solve();
    return 0;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = res*a%p;
        a = a*a%p;
        t >>= 1;
    }
    return res;
}
```


---

## 作者：SymphonyOfEuler (赞：0)

这题分析一下样例，然后就是个无脑快幂。

这题问$n * m$的矩阵中，有多少行，列异或的值都是0。

异或运算，c++一面的 "^" ，数学符号$\oplus$。如果$a、b$两个值不相同，则异或结果为$1$。异或也叫xor，运算法相当于不带进位的二进制加法：二进制下用$1$表示真，$0$表示假，则异或的运算法则为：$0 \oplus 0=0$，$1 \oplus 0=1$，$0 \oplus 1=1$，$1 \oplus 1=0$（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。而且这个东西也可以用作01编号互相替换。

我打了一个小表，为了证明：

```
1      1      1
1      2      4    
1      4     16 
```

枚举$i,j$，$i<=n,j<=m$，看出来这写答案都是2的幂次，也就是说$log$为2。

从我们可以看出答案为$16$。

所以从这个例子中得到这个的解就是为$2$的 $(n-1) * (m-1)$ 次幂，
也就是$2^{(n-1)*(m-1)}$。这样一上快幂，就可以AC了。


代码：

```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll n;

ll qpow(ll a, ll b) { //快幂
    ll result = 1;
    ll base = a;
    while (b) {
        if (b & 1) {
            result *= base;
            result %= 998244353; //取模
        }
        base *= base;
        base %= 998244353; //取模
        b >>= 1;
    }
    return result;
}

int main() {
    cin >> n;
    while (n--) {
        ll a, b;
        cin >> a >> b;
        cout << qpow(2, (a - 1) * (b - 1)) << '\n';
    }
    return 0;
}
```


---

## 作者：muller (赞：0)

回忆起以前写的比赛题目

想起觉得这道题好像有通响公式

当时打个表，发现了显而易见的规律

觉得非常可做

其实你马上就可以发现

但是具体怎么推呢

我们考虑（1,1）已经确定

然后我们对玙每行只有2种填法

因为异或为0，所以有独特的性质

于是我们可以直接对出结论

既前n−1行异或和均为00，第nn行也符合题意

以匹配上面的填法，这样既可

所以找到规律为2^(n-1)*2^(m-1)即2^（n+m-2）

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll P = 998244353;
template <class T> void rd(T &x) {
    char c = getchar(); int f = 1; x = 0;
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
    x *= f;
}
template <class T> void write(T x) {
    if (x < 0) {putchar('-'); x = -x;}
    if (x > 9) write(x / 10); putchar(x % 10 + '0');
}
template <class T> void writeln(T x) {write(x); putchar('\n');}
ll qpow(ll a, ll b) {
    if (!b) return 1;
    ll c = qpow(a, b / 2); c = (c * c) % P;
    if (b % 2) c = (c * a) % P;
    return c;
}
int main() {
    int T; rd(T);
    while (T--) {
        ll n, m; rd(n); rd(m);
        writeln(qpow(qpow(2, n - 1), m - 1));
    }
    return 0;
}
```


---

## 作者：Catreap (赞：0)

## ~~这题其实很简单，~~快速幂就可以AC了~~,哪来的蓝题？~~

## 快速幂是什么？
就是能把$pow(num)$算法效率达到$ O(log_2N) $。

利用的就是**二进制** 。

我们可以把$a^b$中的$b$拆成二进制，该二进制数第i位的权值是2^(i-1)

**E.X.** 当$b$=11时，$ a^{11} $ = $a^{2^0+2^1+2^3}$ ，~~很简单吧？~~

**Why** 11的二进制是$1011$，$11=2^{3}×1 + 2^{2}×0 + 2^{1}×1 + 2^{1}×1$

因此，我们将$a^{11}$转化为算 $a^{2^0+2^1+2^3}$ ，看出来快的多了吧原来算11次，现在算三次，那么**怎么算个数？**

有一个神奇的操作**&1**:取二进制的最末位,还可以判断奇偶。

还有一个神奇的操作**>>1**:二进制去掉最后一位。

其实也很好理解，以b=11为例，b=>1011,二进制从右向左算，顺序是 $a^{2^0}×a^{2^1}×a^{2^3}$，是从左向右的，我们不断的让$base$累乘即可。

## 实现

```cpp
ll Pow(ll a,ll b) {
	ll sum=1;//一定要初始化为1，不然返回0
	while(b) {//b!=0执行
    	//如果末位为1累乘
		if(b&1) sum=sum*a%Mod;//取MOD，题目要求
		a=a*a%Mod,b>>=1;//每操作一次，去掉末位
	}
	return sum;
}
```

最后附上~~高清无码~~代码
## Code：
```cpp
#include<cstdio>
#define ll long long
#define Mod 998244353
#define blank(ch) (ch==' '||ch=='\n'||ch=='\r'||ch=='\t')
inline ll read(void) {
	bool sign=0;
	char ch=getchar();
	ll x=0;
	for (; blank(ch); ch=getchar());
	if (ch=='-')sign=1,ch=getchar();
	for (; ch>='0'&&ch<='9'; ch=getchar())x=x*10+ch-'0';
	if (sign)x=-x;
	return x;
}
ll Pow(ll a,ll b) {
	ll sum=1;
	while(b) {
		if(b&1) sum=sum*a%Mod;
		a=a*a%Mod,b/=2;
	}
	return sum;
}
int main(int argc,char *argv[]) {
	for(int i=read(); i>=1; i--)
		printf("%lld\n",Pow(2,(read()-1)*(read()-1)));
	return 0;
}
```

---

## 作者：__Hacheylight__ (赞：0)

比赛时是吧这题切了的。

一看题目就是结论题。

我们发现，对于要求做$n*m$大的矩阵，如果从左上角数的$(n-1)*(m-1)$大小的矩阵已经确定，那么后面的一行和一列也肯定是确定的。

于是对于前$(n-1)*(m-1)$大的矩阵，我们有$2^{(n-1)(m-1)}$种方案去放，

于是答案就是 $2^{(n-1)(m-1)}$，用快速幂求一下

完美撒花

```cpp
#include <bits/stdc++.h>
using namespace std ;
#define rep(i, a, b) for (int (i) = (a); (i) <= (b); (i)++)
#define per(i, a, b) for (int (i) = (a); (i) >= (b); (i)--)
#define clr(a) memset(a, 0, sizeof(a))
#define ass(a, sum) memset(a, sum, sizeof(a))
#define lowbit(x) (x & -x)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define enter cout << endl
#define SZ(x) ((int)x.size())
typedef long long ll ;
typedef unsigned long long ull ;
typedef vector <int> vi ;
typedef pair <int, int> pii ;
typedef map <int, int> mii ;
typedef map <string, int> msi ;
const int N = 100010 ;
const int iinf = INT_MAX ;
const ll linf = 2e18 ;
const int MOD = 998244353 ;
void print(int x) { cout << x << endl ; exit(0) ; }
void PRINT(string x) { cout << x << endl ; exit(0) ; }
void douout(double x){ printf("%lf\n", x + 0.0000000001) ; }

ll power(ll a, ll b) {
    ll res = 1 ;
    for (; b; b >>= 1, a = a * a % MOD) if (b & 1) res = res * a % MOD ;
    return res ;
}

ll n, m, T ;

signed main(){
    scanf("%lld", &T) ;
    while (T--) {
        scanf("%lld%lld", &n, &m) ;
        printf("%lld\n", power(2ll, (n - 1) * (m - 1))) ;
    }
}
```

---

## 作者：ezoixx130 (赞：0)

### 题意：

题意很简单，就是问有多少个 $n$ 行 $m$ 列的 $01$ 矩阵的每行和每列的异或和均为 $0$。

### 题解：

首先我们知道 $n-1$ 行 $m-1$ 列的 $01$ 矩阵的个数是 $2^{(n-1)(m-1)}$。

然后考虑对一个 $n-1$ 行 $m-1$ 列的 $01$ 矩阵求每行和每列的异或和，并且把异或和放到每行或每列的末尾。

这样我们就得到了一个 $n$ 行 $m$ 列的 $01$ 矩阵，特别地，第 $n$ 行 $m$ 列填上原本 $n-1$ 行 $m-1$ 列的 $01$ 矩阵中的所有数的异或和。

根据异或的性质不难得到，这个 $n$ 行 $m$ 列的 $01$ 矩阵的每行和每列的异或和均为 $0$。也就是说，这个矩阵符合题目要求。

上面我们证明了，每个 $n-1$ 行 $m-1$ 列的 $01$ 矩阵对应一个每行和每列的异或和均为 $0$ 的 $n$ 行 $m$ 列的 $01$ 矩阵。

那么有没有符合题意的 $n$ 行 $m$ 列的 $01$ 矩阵，它不被任何一个 $n-1$ 行 $m-1$ 列的 $01$ 矩阵所对应呢？

显然没有，因为每个符合题意的 $n$ 行 $m$ 列的 $01$ 矩阵，第 $n$ 行的每个数都等于它所在列的其它数的异或和，第 $m$ 列的每个数也都等于它所在行的其他数的异或和，所以它一定能被一个 $n-1$ 行 $m-1$ 列的 $01$ 矩阵所对应。

于是 $n-1$ 行 $m-1$ 列的 $01$ 矩阵与符合题意的 $n$ 行 $m$ 列的 $01$ 矩阵是一一对应的，所以个数相等，均为 $2^{(n-1)(m-1)}$。

快速幂求答案即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define mod 998244353

int qpow(int a,long long b)
{
    int res=1;
    while(b)
    {
        if(b&1)res=(long long)res*a%mod;
        a=(long long)a*a%mod;
        b>>=1;
    }
    return res;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        printf("%d\n",qpow(2,(long long)(n-1)*(m-1)));
    }
}
```

---

## 作者：rEdWhitE_uMbrElla (赞：0)

咕咕。。。

这题只有0和1，显然，每行每列异或和就由1的个数的奇偶性决定了，也就是说若有奇数个1，则异或和为1，否则为0。于是我们可以随便填一个(n-1)\*(m-1)的矩形，而剩下的空格子就被决定了。

于是答案为$2^{(n-1)(m-1)}$

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
 
const int MOD = 998244353;
 
 
long long quickpow(long long base,long long n){
    long long ans = 1;
    while(n){
        if(n%2 == 1) ans = ans * base % MOD;
        n /= 2;
        base = base * base % MOD;
    }
    return ans;
}

long long T,a,b;

int main(){
	cin>>T;
	for(;T;--T){
    cin >> a>>b;
    cout << quickpow(2,(a-1)*(b-1))%MOD << endl;
    }
}
```

---

## 作者：Catalan1906 (赞：0)

基本上是打表找规律……

下面第$m$列第$n$行表示$ans(n, m)$：

![如果图片挂了请联系U108185](https://cdn.luogu.com.cn/upload/pic/47533.png)

很明显的等比数列吧……第$n$行的公比为$2^{n-1}$

然后用 小学奥数/高中数学 的公式可以求得$ans(n, m)=2^{(i-1)^{(j-1)}}$（是两个次方呐！）

这就可以求咯~本人写的快速幂（防溢出）

```
#include <bits/stdc++.h>

using namespace std;

const long long mod = 998244353LL;

long long qpow(long long a, long long k) {
    long long w = 1;
    while(k) {
        if(k & 1) {
            w *= a;
            w %= mod;
        }
        k >>= 1;
        a *= a;
        a %= mod;
    }
    return w % mod;
}

int main() {
    long long t, a, b;
    cin >> t;
    while(t--) {
        cin >> a >> b;
        // cout << a << " " << b << " ";
        cout << qpow(qpow(2, a - 1), b - 1) % mod << endl;
    }
    return 0;
}
```

~~三年OI一场空，不开long long见祖宗~~

---

## 作者：King丨帝御威 (赞：0)

题意是让你求满足n行m列且每行每列异或值都是0的矩阵个数，因为是异或，所以只可能有两个值，$0$或$1$，那么每行可能的取值就是$2^n$，然后最后值是0的情况是就是$2^{n-1}$，然后扩展到列上，那么就是$(2^{n-1})^{m-1}$，然后自己再打打表就发现，显然这个式子是正确的，然后用快速幂求解，计算的过程中记得取模。

下面是我~~简洁~~的代码：
```
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
#define mod 998244353
using namespace std;
ll n,m;
int t;
inline ll fpow(ll a, ll b) {
  if(!b) return 1;
  ll ans=1;
  for(;b;b>>=1,a=(a*a)%mod)
    if(b&1) ans=(ans*a)%mod;
  return ans;
}
int main() {
  scanf("%d",&t);
  while(t--) {
    scanf("%lld%lld",&n,&m);
    printf("%lld\n",fpow(fpow(2,n-1),m-1));
  }
  return 0;
}
```

---

## 作者：xh39 (赞：0)

### 知道异或是什么的可以跳过这里
#### 异或就是转化为二进制后逐位比较，相同为0，不相同为1
#### 一位数的比较:
```
0^0=0
0^1=1
1^0=1
1^1=0
```
# 本题可发现:前n-1行m-1列的数字都知道了，就可以知道其他的所有数字。
## 因为前面的异或值要么是1，要么是0，而无论是1还是0，要让结果是0，有且只有1种方法。（自己观察前面的式子）
# 所以可以用快速幕解决(不知道快速幕的百度)
代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 998244353
long long cf(long long a,long long b){//次方（采用快速幕）
	long long sum=1;
	a%=mod;
	while(b>0){
		if(b&1){//判断如果是奇数，&是位运算与，这里不多介绍与，因为是奇数二进制下最后一位肯定是1，&1是用来判断最后一位是不是1.
			sum=(sum*a%mod);
		}
		b>>=1;//÷2,因为丢掉二进制最后一位就是÷2
		a=(a*a)%mod;
	}
	return sum;
}
int main(){
	int t,n,m,i;
	cin>>t;
	for(i=1;i<=t;i++){
		cin>>n>>m;
		cout<<((long long)cf(2,(long long)(n-1)*(m-1))%mod)<<endl;//一定要转long long,不然会爆
	}
	return 0;
}
```

---


# [COCI 2009/2010 #5] PROGRAM

## 题目描述

 **译自 [COCI 2010.03.06](http://hsin.hr/coci/archive/2009_2010/) T5「[PROGRAM](http://hsin.hr/coci/archive/2009_2010/contest5_tasks.pdf)」**

开始时，$\mathit{seq}$ 数组已清零。请注意 $\mathit{seq}$ 数组的第一个元素的下标是 0 而非 1。

```cpp
void something (int jump) {
  for (int i = 0; i < N; i += jump)
    ++seq[i];
}
```

Mirko 调用了 $\tt something$ 函数 $K$ 次，第 $i$ 次调用时 $\tt jump= \it X_i$。

接下来有 $Q$ 次查询，每次查询包含两个整数 $L_i,$ $R_i$，对于每组查询请输出 $\displaystyle\sum_{i=L_i}^{R_i}\mathit{seq}_i$。

## 说明/提示

#### 样例说明 1
$seq=\{4, 3, 4, 3, 4, 3, 4, 3, 4, 3\}$

#### 样例说明 2
$seq=\{3, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1\}$

#### 数据范围与提示
$1≤N,K,Q≤10^6,$ $1≤X_i<N,$ $0≤L_i≤R_i<N$.

## 样例 #1

### 输入

```
10 4
1 1 2 1
3
0 9
2 6
7 7```

### 输出

```
35
18
3```

## 样例 #2

### 输入

```
11 3
3 7 10
3
0 10
2 6
7 7```

### 输出

```
8
2
1```

## 样例 #3

### 输入

```
1000000 6
12 3 21 436 2 19
2
12 16124
692 29021```

### 输出

```
16422
28874```

# 题解

## 作者：Planet6174 (赞：8)


很容易想到一种暴力：统计每种 `jump` 的出现次数 `cnt[jump]`，然后

```cpp
for (int jump = 1; jump <= N; ++jump)
  for (int i = 0; i < N; i += jump)
    seq[i] += cnt[jump];
```

你以为这东西的时间复杂度是 $O(N^2)$ 的，结果……你发现这个程序居然 AC 了。

原因很简单，还记得约数个数性质吗？

$O(N+\frac N 2+\frac N 3+\dots+\frac N N)=O(N\log N)$

最后吐槽一句，尽管这个题考点很正常，但个人觉得这题丢到考场上是会搞出负区分度的（

---

## 作者：qwaszx (赞：4)

这是一个$O(n\log\log n)$的题解(然而由于数据问题被$O(n\log n)$吊着踩

一次操作相当于是在所有$x$的倍数的位置$+1$，那么现在把所有的操作先屯起来，最后再进行一次求和，暴力求和即可做到$O(nH_n)=O(n\log n)$

然而如果设$a_i$表示第$i$个位置上的操作次数，那么最后第$n$个位置上的数实际上是$\sum\limits_{d\mid n}a_d$.最后前缀和一下就好了.

~~然后移步[【模板】Dirichlet前缀和](https://www.luogu.org/problem/P5495)~~

稍微说一点好了，整除关系相当于是一些偏序集$(\{p^i\mid i\geq 0\},\leq)$的直积，$d\mid n$等价于把$d$和$n$分别分解后$d$的每个质数次幂都小于等于对应的$n$的质数次幂.于是可以把狄利克雷卷积拆解，对每个质数次幂卷积(在这里相当于是一个前缀和的形式).这个可能比较抽象，可以用一个$dp$的方式来理解.

令

$$g_{n,i}=\sum\limits_{d\mid n,\text{d只含前i个质数}}a_{n/d}$$

容易知道$g_{n,0}=a_n$.然后考虑转移.设$p_i$表示第$i$个质数

$$g_{n,i}=\begin{cases}g_{n,i-1}&p_i\nmid n\\g_{n,i-1}+g_{n/p_i,i}&p_i\mid n \end{cases}$$

下面那个相当于是强制添加一个$p_i$，然后剩下的就是$n/p_i$中$d$含前$i$个质因子的答案.

代码还是非常简单的.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=2e6;
long long a[N];
int n,k,q,prime[N],p[N],cnt;
void make()
{
    for(int i=2;i<n;i++)
    {
        if(!p[i])prime[++cnt]=i;
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
        {
            p[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
    for(int i=1;i<=cnt;i++)
        for(int j=1;j*prime[i]<n;j++)
            a[j*prime[i]]+=a[j];
    for(int i=1;i<n;i++)a[i]+=a[i-1];
}
int getin()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}
int main()
{
    n=getin(),k=getin();
    for(int i=1,x;i<=k;i++)x=getin(),a[x]++,a[0]++;
    make();
    q=getin();
    for(int i=1,l,r;i<=q;i++)
    {
        scanf("%d%d",&l,&r);
        if(l)printf("%lld\n",a[r]-a[l-1]);
        else printf("%lld\n",a[r]);
    }
}
```

---

## 作者：Kalium (赞：3)

# P5190 题解

## 题意：
题目给你一段程序，其中告诉你 $n$ ， $k$ 个 $jump$ ($x[i]$) ，叫你求出    $[l,r]$ 之间的$seq$数组的和

## 思路：

分为 $2$ 个部分

### $1.seq$ 数组（难点）

很容易想到一种暴力算法，即外层循环一个 $k$ ，即枚举 $k$ 个 $x[i]$ 的值，在 $j$ 这一层循环加上 $x[i]$ ，然后 $++seq[j]$ 。

但是这样是 $O(n^2)$ ，很明显， $10^6$ 的数据承受不起，但是这样的数据能得到 $70pts$ 的高分（不得不说数据水）

给出暴力求 $seq$ 数组的代码

```cpp
	for (int i = 0; i < k; i ++) {
		for (int j = 0; j < n; j += x[i])
			++ seq[j];
	}
```

~~马蜂较丑，勿喷~~

正确思想：

这个复杂度过高，我们可以选择用桶！！！

将每个输入进来的 $x$ 用 $tong[x]++$ 来放入桶中。

那么我们 $i$ 只需 $[1,n]$ 之间遍历即可，因为题目数据给出 $1 ≤ x[i] < n$ 。

那么当 $tong[i]$ 不为 $0$ 时,说明 $seq$ 数组需要改变，那么j的循环即为 $j += i$ ，因为 $i$ 表示的是 $x$ 数组所代表的数字，我们是枚举这些数字有没有输入而已，那么 $seq$ 加上的就是出现的次数，即为 $tong[i]$ 

复杂度即为$O(n log n)$

~~O(能过)~~

##### $seq$数组部分的代码

```cpp
	for (int i = 0; i < n; i ++) {
		if (tong[i]) {//这个数在x中有，因为本题x[i] < n，所以可以把x建一个桶，一个个数遍历 
			for (int j = 0; j < n; j += i)
				seq[j] += tong[i];//这个数出现了tong[i]次，那么每次都要遍历到，直接将其加上即可 
		}
	}
```

### $2.$ 求 $[l,r]$ 的区间和（较简单，大佬可跳过）

暴力 $O(n^2)$ ，那么你前面的辛苦什么 $O(n log n)$ 都付之东流

某些大佬会线段树解决，~~但是，本蒟蒻不会~~

我们可以用前缀和

$sum[i]$ 即为前缀和数组，那么 $seq$ 就是我们要搞的数组

前缀和公式即为

$sum[i] = sum[i - 1] + seq[i]$ （~~不会有人不会吧？！~~）。

但是我们数组下标是 $0$

所以得先处理出 $sum[0] = seq[0]$

否则 $sum[i - 1]$ 会数组越界
 
求出 $[l,r]$ 之间的和不就是 $sum[r] - sum[l - 1]$ 吗？

##### 前缀和部分的代码

```cpp
	for (int i = 1; i < n; i ++)
		sum[i] = sum[i - 1] + seq[i];
	cin >> q;
	for (int i = 0, l, r; i < q; i ++) {
		cin >> l >> r;
		cout << sum[r] - sum[l - 1] << endl;
	}
```

## 细节：
主要是 $long long$ 的问题

很明显

极限数据

$n = 10^6$ ， $k = 10^6$ ， $x[i] = 10^6$ ，那么你的 $sum$ 数组明显就爆了 $int$ 范围

## 代码（CODE）
```cpp
#include <iostream>
#define ll long long

using namespace std;

const int N = 1e6 + 10; //我也不明白为什么1e6 + 7会炸，还请大佬指教

int n, k, q;

ll x[N], tong[N];

ll sum[N];

ll seq[N];

int main() {
	cin >> n >> k;
	for (int i = 0; i < k; i ++) {
		cin >> x[i];
		tong[x[i]] ++; 
	}
	for (int i = 0; i < n; i ++) {
		if (tong[i]) {
			for (int j = 0; j < n; j += i)
				seq[j] += tong[i];
		}
	}
	/*for (int i = 0; i < n; i ++)
		cout << seq[i] << " ";*/
	sum[0] = seq[0];
	for (int i = 1; i < n; i ++)
		sum[i] = sum[i - 1] + seq[i];
	cin >> q;
	for (int i = 0, l, r; i < q; i ++) {
		cin >> l >> r;
		cout << sum[r] - sum[l - 1] << endl;
	}
	return 0;
} 
```

---

## 作者：UperFicial (赞：2)

# 前缀和

**前言**

看似毒瘤，实则简单，真是跟 [$\texttt{EZEC Round 4 T1}$](https://www.luogu.com.cn/problem/P6823) 有异曲同工之妙。（

原题链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P5190)。

**题目大意**

给您一个函数：

```cpp
void something (int jump) {
  for (int i = 0; i < N; i += jump)
    ++seq[i];
}
```

调用函数 $k$ 次，对于第 $i$ 次调用，$jump=x_i$。

再给您 $q$ 次询问，每次询问 $seq$ 数组中某段区间和。

**解题思路**

看了题面第一个感觉就是暴力，但是在 $n\le 10^6$ 数据范围之下 $\mathcal{O}(n^2)$ 的复杂度难以承受。

接着，我们想到了一个特性，对于每次询问，我们可以考虑用前缀和来维护，$sum_i=sum_{i-1}+seq_i$，对于一段区间 $[l,r]$ 的和就是 $sum_r-sum_{l-1}$（前缀和基础操作）。

但是，这样输出 $\mathcal{O}(1)$ 仍然会 $T$ 到起飞，毕竟要调用函数。于是，蒟蒻我开始冥思苦想~~颓柿子，但毫无头绪~~。

~~突然，我灵机一动~~，程序所耗得时间都是因为：若 $jump$ 都等于一个数 $y$，那么会有很多的重复计算！我们不妨设 $pos_{x_i}$ 为 $x_i$ 出现的次数。

考虑一个简单的事情，对于一个 $x_i$，会有一部分的 $seq_{i}$ 的值都 $+1$，而如果再来一个同样的 $x_i$，那么刚刚那一部分的 $seq_i$ 的值又会 $+1$，我们便能推出一个结论：对于一个 $x_i$，会有一部分的 $seq_i$ 的值都 $+pos_{x_i}$，因为有 $1$ 个 $x_i$ 就 $+1$，有 $pos_{x_i}$ 个 $x_i$ 就 $+pos_{x_i}$。

**至此，便能得出做法**

先统计 $x_i$ 的个数，然后再从 $1$ 至 $n$，对于每一个 $pos_i$，若它的值不为 $0$，就说明我们需要去更新 $seq$，因为数量不为 $0$，$j$ 便从 $1$ 到 $n$ 开始遍历，每次 $+i$，每个 $seq_j$ 都 $+pos_i$。

之后统计一遍前缀和，由于我的数组下标是从 $1$ 开始的，所以要对每次询问的 $l$ 和 $r$ 都 $+1$，因为本题的数组下表是从 $0$ 开始的。

但这样交上去貌似只能得 $70pts$，这里通过一个填空题提醒一下各位：

> 十年 $\text{OI}$ 一场空，不开 $\boxed{?}\ \ \boxed{?}$ 见祖宗。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
typedef long long ll;
const int MAXN=3000010;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
int n,k,q,pos[MAXN];
ll a[MAXN],sum[MAXN];
void build(int l,int r)//维护前缀和 
{
	for(register int i=l;i<=r;i++) sum[i]=sum[i-1]+a[i];
}
int main()
{
	n=read(),k=read(); 
	for(register int i=1;i<=k;i++) pos[read()]++;//统计个数 
	for(register int i=1;i<=n;i++) if(pos[i])
		for(register int j=1;j<=n;j+=i) a[j]=(ll)a[j]+pos[i];//更新a，也就是seq数组 
	build(1,n);
	q=read();
	while(q--)
	{
		int l=read()+1,r=read()+1;//下标问题 
		printf("%lld\n",sum[r]-sum[l-1]);//前缀和统计答案 
	}
	return 0;
}
```

$$\texttt{The End.by UF}$$


---

## 作者：Sooke (赞：2)

### 前言

$n \leqslant 10^6$？八成是 $O(n \log n)$ 的算法，但这里有一个 $O(n \sqrt {n})$ 不知道为什么卡进去且被其他人爆踩的做法。

---

### 解题思路

设 $g_k = \sum\limits_{i=1}^{k} seq_i$，只要会求 $g_{1..n}$，询问 $(l,\,r)$ 只是 $g_r - g_{l-1}$ 的事。

考虑 $g_{i- 1}$ 到 $g_i$ 的转移过程，加了一个 $seq_i$，接着考虑哪些 $x$ 的修改会给 $seq_i$ 加上 $1$ 呢？显然是满足 $i \ \mathrm{mod}\ x = 0$ 的修改。

于是很好想到下面的算法：边界 $g_0 = m$（因为不管怎么样的修改都会改到 $0$ 号位置），接着从 $1$ 到 $n - 1$ 枚举 $i$，先令 $g_i = g_{i-1}$（前缀和），再枚举 $i$ 的约数 $j$，设有 $f_j$ 个操作满足 $x = j$，直接给 $g_i$ 加上 $f_j$ 就好了。

如果 $i$ 是平方数，$f_{\sqrt{i}}$ 会被加 $2$ 次，要判断一下减回去。

枚举约数时当然只需枚举到 $\sqrt{i}$，整个复杂度是 $O(n \sqrt{n})$ 的。

---

### 代码实现

特判一下 $l = 0$ 的询问，以免负下标。

```cpp
#include <cmath>
#include <cstdio>

inline int read() {
    char c = getchar(); int x = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { x = (x << 3) + (x << 1) + (c & 15); c = getchar(); }
    return x;
}

int n, m, s, q, l, r, f[1000005];
long long g[1000005];

int main() {
    n = read(); m = g[0] = read();
    for (int i = 0; i < m; i++) { f[read()]++; }
    for (int i = 1; i < n; i++) {
        g[i] = g[i - 1]; s = sqrt(i);
        for (int j = 1; j <= s; j++) {
            if (i % j == 0) { g[i] += f[j] + f[i / j]; }
        }
        if (s * s == i) { g[i] -= f[s]; }
    }
    for (q = read(); q; q--) {
        l = read(); r = read();
        printf("%lld\n", g[r] - (l ? g[l - 1] : 0));
    }
    return 0;
}
```

---

### 然而题解还没完！

上面的算法不难想对吧？但菜鸡 $Sooke$ 由于根号算法题做傻了，一开始是这样的 $60$ 分代码（这个常数略大）。

对 $x_i$ 值域分块，$\leqslant \sqrt{n}$ 的在询问的时候暴力算贡献，$> \sqrt{n}$ 的暴力修改然后前缀和。

```cpp
// luogu-judger-enable-o2
#include <cmath>
#include <cstdio>

inline int read() {
    char c = getchar(); int x = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { x = (x << 3) + (x << 1) + (c & 15); c = getchar(); }
    return x;
}

int n, m, q, x, l, r, len, cnt[1005], sum[1000005];
long long ans;

int main() {
    n = read(); len = sqrt(n);
    for (m = read(); m; m--) {
        x = read();
        if (x <= len) { cnt[x]++; } else {
            for (int i = 0; i < n; i += x) { sum[i]++; }
        }
    }
    for (int i = 1; i < n; i++) { sum[i] += sum[i - 1]; }
    for (q = read(); q; q--) {
        l = read() - 1; r = read(); ans = sum[r] - sum[l];
        for (int i = 1; i <= len; i++) { ans += (r / i + 1ll) * cnt[i]; }
        if (~l) { for (int i = 1; i <= len; i++) { ans -= (l / i + 1ll) * cnt[i]; } }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：happybob (赞：1)

很容易想到多次计算同一个 $X_i$ 会浪费时间，不妨记录下每一个 $X_i$ 出现的次数，然后用前缀和可以做到 $O(1)$ 询问，$O(n \log n)$ 预处理。

代码：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

#define int long long

const int N = 1e6 + 5;

int n, k, q, g, seq[N], presum[N];
int cnt[N];

signed main()
{
	scanf("%lld %lld", &n, &k);
	for (int i = 1; i <= k; i++)
	{
		scanf("%lld", &g);
		cnt[g]++;
	}
	for (int i = 0; i < n; i++)
	{
		if (!cnt[i]) continue;
		int p = i;
		for (int j = 0; j < n; j += p)
		{
			seq[j] += cnt[i];
		}
	}
	presum[0] = seq[0];
	for (int i = 1; i < n; i++) presum[i] = presum[i - 1] + seq[i];
	scanf("%lld", &q);
	while (q--)
	{
		int l, r;
		scanf("%lld %lld", &l, &r);
		printf("%lld\n", presum[r] - presum[l - 1]);
	}
	return 0;
}
```

顺便给个 $50$ 分的线段树吧，MLE 了。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <unordered_map>
using namespace std;

#define int long long

const int N = 1e6 + 5;

int n, k, q, g, seq[N], ls[N], rs[N], now = 1;
int cnt[N];

struct Node
{
	int l, r, sum;
};

Node tree[N];

inline void push_up(int u)
{
	tree[u].sum = tree[ls[u]].sum + tree[rs[u]].sum;
}

inline void build(int u, int l, int r)
{
	tree[u] = { l, r };
	if (l == r)
	{
		tree[u].sum = seq[r];
		return;
	}
	int mid = (l + r) >> 1ll;
	if (!ls[u])
	{
		ls[u] = ++now;
	}
	if (!rs[u])
	{
		rs[u] = ++now;
	}
	build(ls[u], l, mid);
	build(rs[u], mid + 1ll, r);
	push_up(u);
}

inline int query(int u, int l, int r)
{
	if (tree[u].l >= l && tree[u].r <= r) return tree[u].sum;
	int mid = (tree[u].l + tree[u].r) >> 1ll, s = 0;
	if (l <= mid) s = query(ls[u], l, r);
	if (r > mid) s += query(rs[u], l, r);
	return s;
}

signed main()
{
	scanf("%lld %lld", &n, &k);
	for (int i = 1; i <= k; i++)
	{
		scanf("%lld", &g);
		cnt[g]++;
	}
	for (int i = 0; i < n; i++)
	{
		if (!cnt[i]) continue;
		int p = i;
		for (int j = 0; j < n; j += p)
		{
			seq[j] += cnt[i];
		}
	}
	build(1, 0, n - 1);
	scanf("%lld", &q);
	while (q--)
	{
		int l, r;
		scanf("%lld %lld", &l, &r);
		printf("%lld\n", query(1, l, r));
	}
	return 0;
}
```


---

## 作者：smyslenny (赞：0)



读完题目，我们能够想到一个非常暴力的暴力，~~看标签也能知道是暴力~~。无非就是按照题意，将 $something$ 函数复制下来，进行 $k$ 次操作,然后对输入的 $l,r$ 暴力枚举求和。

具体的代码是这样的(之后我们会在这份代码上修改得出AC代码）：
```c

void something(int jump) //原封不动复制过来
{
	for(int i=0;i<n;i+=jump)
	++seq[i];
}
int main()
{
	scanf("%d%d",&n,&k); 
	for(int i=1;i<=k;i++)
	scanf("%d",&sz[i]);
	scanf("%d",&q);
	for(int i=1;i<=k;i++)
	something(sz[i]);//进行k次修改
	for(int i=1;i<=q;i++)
   	{
		int l,r,ans=0;
		scanf("%d%d",&l,&r);
		for(int j=l;j<=r;j++)
		ans+=seq[j];//求和
		printf("%d\n",ans);//直接输出答案
	}
	return 0;
}
```

然后我们就有了 $40pts$ 的好成绩(TLE了)。

接着，我们来想如何优化这份暴力。

当然，不想看或会的可以跳过直接看最后的代码。

**1.前缀和。** 

看到我们求和的循环，我们发现，太暴力了。

Q:怎么来不太暴力的求区间和呢？ 

A:前缀和。

不明白前缀和的可以看[这里](https://www.cnblogs.com/-Ackerman/p/11162651.html)。 

理解过后，我们可以把 $seq$ 数组求一个前缀和，可以直接 $O(1)$ 求出区间的和。 

像这样：
```c
for(int i=1;i<=n;i++)
	seq[i]+=seq[i-1];
for(int i=1;i<=q;i++)
{
	int l,r;
	scanf("%d%d",&l,&r);
	printf("%d\n",seq[r]-seq[l-1]);
}
```

至于为什么是 $r-(l-1)$ ,大家可以手动计算一下。
于是，我们就有了 $70pts$ 的好成绩。

**2.long long.** 

已经开了 $long \ long$ 的可以跳过哦。

由于我们此题用了前缀和，我们需要做加法运算，但我们看向数据范围 $\to 1 \leq N,K,Q \leq 10^6,1 \leq X_i < N,0 \leq L_i \leq R_i < N$

假设我们的数据都为 $10^6$ , $k_i=1$ ,这意味着我们这 $10^6$ 个数要加到 $10^6$ ,而我们的前缀和是将前面所有的以及自身的值相加，可想而知，会爆 $int$ 。

运用一个小方法：
```c
#define int long long
int main -> signed main
```

轻松将 $int$ 转换成 $long \ long$ ,然后再吸一下氧，我们就有了 $90pts$ 的好成绩。 

**3.桶计数** 

我们发现也许他给出的 $K_i$ 都相同时，我们需要计算 $k$ 次，如果我们用一个数组统计一下这个数出现了几次，然后直接一次操作都加上，~~是不是很爽~~，就可以去掉一些重复的操作。

这样：
```c
for(int i=1;i<=k;i++)
{
	int x;
	scanf("%d",x);
	v[x]++;
}
```

然后再对我们的函数做一个小修改：
```c
void something(int jump,int a) 
{
    for(int i=0;i<n;i+=jump)
    seq[i]+=a;//去掉重复
}
```
不用吸氧也可以AC啦。 

附上完整代码：
```c
/*
work by smyslenny
2021.02.15
P5190 [COCI 2010] PROGRAM
*/
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<iomanip>
#include<iostream>
#include<algorithm>
#define INF 0x3f3f3f3f
#define int long long //记得开long long
using namespace std;
const int maxn=1e6+5;
int n,k,q; 
int seq[maxn],v[maxn]; 
int read()
{
	int f=0,s=0;
	char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return f?-s:s;
}
void something(int jump,int a) 
{
    for(int i=0;i<n;i+=jump)
    seq[i]+=a;//去掉重复
}
signed main()
{
	n=read(),k=read(); 
	for(int i=1;i<=k;i++)
	{
		int x=read();
		v[x]++; //计算重复
	}
	q=read();
	for(int i=1;i<n;i++)
	{
		if(v[i]) //重复的都计算上后，统一计算
		something(i,v[i]);
	}
	for(int i=1;i<=n;i++)
	seq[i]+=seq[i-1];//计算前缀和
	for(int i=1;i<=q;i++)
	{
		int l=read(),r=read();
		printf("%lld\n",seq[r]-seq[l-1]);//直接求出答案
	}
	return 0;
}
```




---

## 作者：零殇 (赞：0)

开始把题目看错了，以为一次修改后一次输出，结果连样例都看不懂（雾）。

好吧接下来进入正题。

我们可以看到，$1≤N,K,Q≤10^6$,暴力肯定是行不通的。因此我们要一点一点慢慢来优化推出正解。

### 桶优化

我们知道，这个函数的作用是把每一个下标$jump$的倍数（包括$0$）加$1$,那么也就是说，如果有重复的情况，我们就要做重复的操作。

那么，我们就可以提前用桶把重复的情况记录下来。然后统一操作。

```
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>x;
		num[x]++;//记录
		maxn=max(maxn,x);//记录最大值
	}
	for(int i=1;i<=maxn;i++)
	{
		if(num[i]!=0)//如果被记录过
		{
			for(int j=0;j<n;j+=i)
				a[j]+=num[i];//统一操作
		}
	}
```


### 前缀和优化

我们不难发现，这个数组在函数执行完后是不会改变的。而我们一直在输出时不断循环增加，太浪费时间了，有没有可以提前记录后直接输出的方法呢？

你应该已经猜到了，那就是前缀和。我们可以提前记录前缀和，就可以实现$O(1)$级别的输出，大大优化时间复杂度。

```
	sum[0]=a[0];//初始化
	for(int i=1;i<n;i++)
		sum[i]=sum[i-1]+a[i];//记录前缀和
```

### 上最终代码```
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
long long num[1000001],a[1000001],sum[1000001];
int main()
{
	int n,k,q,x,l,r,maxn=-1;
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>x;
		num[x]++;//记录
		maxn=max(maxn,x);//记录最大值
	}
	for(int i=1;i<=maxn;i++)
	{
		if(num[i]!=0)//如果被记录过
		{
			for(int j=0;j<n;j+=i)
				a[j]+=num[i];//统一操作
		}
	}
	sum[0]=a[0];//初始化
	for(int i=1;i<n;i++)
		sum[i]=sum[i-1]+a[i];//记录前缀和
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		cin>>l>>r;
		cout<<sum[r]-sum[l]+a[l]<<endl;
	}
	return 0;
}
```

```

完结撒花~

---

## 作者：Treaker (赞：0)

~~不知道为什么是紫题~~

考虑，我们对于K次something函数。

但是这样会被许多个1卡住。

但是，发现，这些修改是互不影响的。

所以，我们可以把对于同一个位置的修改放在一起。

然后，再对所有的修改进行something函数。

最后，求一个前缀和，可以$O(1)$回答询问

时间复杂度为$O(\frac{N}{1} + \frac{N}{2} + ...+\frac{N}{N}) = O(nlogn)$

```cpp
#include <map>
#include <set>
#include <cmath>
#include <queue>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
namespace IO
{
	char buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];
	#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)
	#define gt() getchar()
	inline int read()
	{
		int x = 0 , f = 1; char ch = gt();
		while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = gt();}
		while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}
		return x * f;
	}
	template <class T> inline void write(T x)
	{
		if(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');
		if(x < 0) *f3 ++ = '-' , x = ~x + 1;
		char *top = sta;
		while(x) *top ++ = x % 10 + 48 , x /= 10;
		while(top != sta) *f3 ++ = *-- top;
		*f3 ++ = ' ';
	}
	inline void put(std::string s)
	{
		int len = s.length();
		for(int i = 0;i < len;i ++) *f3 ++ = s[i];
		*f3 ++ = ' ';
	}
	inline void endline() { *f3 ++ = '\n';}
	#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)
	template <class T> inline T abs(T a) { return a < 0 ? -a : a;}
	template <class T> inline T max(T a,T b) { return a > b ? a : b;}
	template <class T> inline T min(T a,T b) { return a < b ? a : b;}
	template <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}
}
using namespace IO;
const int N = 1e6 + 5;
int sk[N];
ll sum[N];
int main()
{
	int n = read() , m = read();
	for(int i = 1;i <= m;i ++) sk[read()] ++;
	for(int i = 1;i < n;i ++) if(sk[i]) for(int j = 0;j < n;j += i) sum[j] += sk[i];
	for(int i = 1;i < n;i ++) sum[i] += sum[i - 1];
	int Q = read();
	while(Q --> 0)
	{
		int l = read() , r = read();
		if(l == 0) printf("%lld\n",sum[r]);
		else printf("%lld\n",sum[r] - sum[l - 1]);
	}
	return 0;
}
```


---

## 作者：Cesare (赞：0)

xswl 本来以为是什么分块好题，结果暴力就完事了。

## $Solution$

开一个桶记录一个数出现的次数，然后按照值域枚举所有的 $i$ ，暴力更新 $seq_i$ ，记一个前缀和 $O(1)$ 回答询问即可。

注意负下标。

$update:$ 补充一下复杂度为什么是对的，因为你枚举约数的复杂度的渐进上界为 $O(n\ log\ n)$ 。

## $Code:$

```cpp
#include <bits/stdc++.h>
//#include <tr1/unordered_map>
//#include"Bignum/bignum.h"
//#define lll bignum
#define lowbit(x) (x & -x)
#define debug(x) (cout << "#x = " << (x) << endl)
#define Set(x, i) memset (x, i, sizeof(x))
#define R register
#define For(i, j, k) for(R int i = (j), ED = (k); i <= ED; ++i)
#define foR(i, j, k) for(R int i = (j), ED = (k); i >= ED; --i)
#define Cross(i, j, k) for(R int i = (j); i; i = (k))
using namespace std;
typedef long long ll;
const ll N = 1000011;
const ll INF = 5e16;

ll n, k, Q, X[N];

namespace IO {

	inline char gc() {
		static char buf[100000], *p1 = buf, *p2 = buf;
		return (p1 == p2) && (p2 = (p1 = buf) +
			fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
	}

	#define dd ch = getchar()
	inline ll read() {
		ll x = 0; bool f = 0; char dd;
		for (; !isdigit (ch); dd) f ^= (ch == '-');
		for (; isdigit (ch); dd)  x = x * 10 + (ch ^ 48);
		return f? -x: x;
	}
	#undef dd

	inline void write( ll x ) {
		if (x < 0) putchar ('-'), x = -x;
		if (x > 9) write (x / 10); putchar (x % 10 | 48);
	}

	inline void wrn ( ll x ) { write (x); putchar (' '); }

	inline void wln ( ll x ) { write (x); putchar ('\n'); }

	inline void wlnn ( ll x, ll y ) { wrn (x), wln (y); }

}

using IO::wln;
using IO::read;

namespace Cesare {
	
	#define rep(i, j, k) for(R int i = (j); i < (k); ++i)
	
	ll S[N], cnt[N], seq[N];
	
	void main() {
		n = read(), k = read();
		For ( i, 1, k ) ++cnt[read()];
		rep ( i, 1, n ) if (cnt[i]) 
			for (R int j = 0; j < n; j += i) seq[j] += cnt[i];
		For ( i, 1, n ) S[i] = S[i - 1] + seq[i - 1];
		Q = read(); while (Q--) {
			ll l = read() + 1;
			ll r = read() + 1;
			wln (S[r] - S[l? l - 1: l]);
		} exit (0);
	}
	
}

int main()
{
	return Cesare::main(), 0;
}

/*

*/



```

---


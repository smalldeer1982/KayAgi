# 整数校验器

## 题目描述

有些时候需要解决这样一类问题：判断一个数 $x$ 是否合法。

$x$ 合法当且仅当其满足如下条件：

- $x$ 格式合法，一个格式合法的整数要么是 $0$，要么由一个可加可不加的负号，一个 $1$ 到 $9$ 之间的数字，和若干个 $0$ 到 $9$ 之间的数字依次连接而成。
- $x$ 在区间 $[l,r]$ 范围内（即 $l \le x \le r$）。

你需要实现这样一个校验器，对于给定的 $l, r$，多次判断 $x$ 是否合法。

## 说明/提示

对于 $100\%$ 的数据，$0 \le T \le 512$，$l,r$ 在 $64$ 位有符号整型范围内（即 $-2^{63}\le l \le r \le 2^{63}-1$）。

保证输入文件大小不超过 $\text{128KB}$。数据在 linux 下生成，没有 '\r' 字符。

以下为部分特殊限制（互不包含）：

- 有 $5\%$ 的数据，$T=0$。
- 有 $25\%$ 的数据，保证 $x$ 格式一定合法。
- 有 $30\%$ 的数据，保证如果 $x$ 格式合法，那么 $x$ 一定在 $64$ 位有符号整形范围内。

其中有一个不计分的hack测试点，用于考察long long边界数字的判断，如果是100分UnAC的话，那么可能是你没有考虑这一种情况。

## 样例 #1

### 输入

```
-3 3 4
0
00
-0
100000000000000000000```

### 输出

```
0
1
1
2
```

# 题解

## 作者：浮尘ii (赞：25)

出题人来水一篇题解。

首先这题是我半年前出的，当时还不懂 python 那一套姿势。

今天听说被放到月赛 T1 来了，重新看了一下，发现直接 python 就水过去了（用 str(int(a)) 即可判断原串格式是否合法，int(a) 直接和 $l,r$ 比较大小就行了）。

```
l, r, T = map(int, input().split())

for i in range(T):
    s = input()
    if (s == "-"):
        print(1)
        continue
    n = int(s)
    if (str(n) != s):
        print(1)
    else:
    	if (n >= l and n <= r):
        	print(0)
    	else:
        	print(2)
```

------------

以下是原题解：

按照题意模拟即可。

注意到格式不合法会有如下情况：

- $-$
- $-0\dots$
- $0\dots$

特判掉不合法后，先根据位数判断是否在 long long 范围内（可能仍然会爆 long long，使用 unsigned long long 存储），然后再判断大小即可。

标程：

```cpp
#include <cstdio>
#include <cstring>

using ll = long long;
using ull = unsigned long long;
const size_t	maxL = (128 << 10) + 5;

ll	L, R;
int	T;
char	X[maxL];

void Judge()
{
	int	l = strlen(X + 1);

	if(X[1] == '-') {
		if(l == 1 || X[2] == '0') {
			puts("1");
			return;
		}
	} else if(X[1] == '0' && l != 1) {
		puts("1");
		return;
	}

	if(X[1] == '-' && l > 20) {
		puts("2");
		return;
	}
	if(X[1] != '-' && l > 19) {
		puts("2");
		return;
	}

	ull	tmp;
	ll	x;
	if(X[1] == '-') {
		sscanf(X + 2, "%llu", &tmp);
		if(tmp > 1ULL << 63) {
			puts("2");
			return;
		}
		x = -tmp;
	} else {
		sscanf(X + 1, "%llu", &tmp);
		if(tmp >= 1ULL << 63) {
			puts("2");
			return;
		}
		x = tmp;
	}

	puts(x >= L && x <= R ? "0" : "2");
}

int main()
{
	for(scanf("%lld%lld%d", &L, &R, &T); T--; ) {
		scanf("%s", X + 1);
		Judge();
	}

	return 0;
}

```

---

## 作者：皎月半洒花 (赞：12)

我赌我代码绝对是C++里面最短的——之一……

其实很简单，就是个比较。于是我们就可以用$long~double$，毕竟$long~double$的值域高达$10^{1050+}$……

```cpp
int main(){
    cin >> L >> R >> T ;
    while(T --){
        scanf("%s", In), Len = strlen(In) ;
        if ((In[0] == '-' && In[1] == '0') || (In[0] == '0' && Len > 1) || (Len == 1 && In[0] == '-')) puts("1") ;
        else if (Len > 30) puts("2") ;
        else {
            long double N = 0 ;
            if (In[0] == '-'){
                for (i = 1 ; i < Len ; ++ i) N = N * 10 + (In[i] - '0') ;
                N *= -1.0 ;
            }
            else 
                for (i = 0 ; i < Len ; ++ i) N = N * 10 + (In[i] - '0') ;
            if (N >= L && N <= R) puts("0") ; else puts("2") ;
        }
    }
    return 0 ;
}
```

然后因为$2^{64}$大概在$1e19$左右，超过长度可以直接判掉。

---

## 作者：partychicken (赞：10)

### 众所周知，有一个语言叫python

### 众所周知，有一个东西叫正则

于是这题没了。

比赛的时候写丑了，判零可以压到正则里的。在后面加|$0就好了。。。

然后比赛手一滑，把'*' 打成了 '+' 。当场去世

```python
import re
value = re.compile(r'^[-]?[1-9]{1}[0-9]*')
l, r, T = map(int, input().split())
for i in range(T):
    a = input()
    if a == "0":
        if l<=0 and r>=0:
            print(0)
        else:
            print(2)
        continue
    result = value.match(a)
    if result:
        if int(a)>=l and int(a)<=r:
            print(0)
        else:
            print(2)
    else:
        print(1)
```

---

## 作者：_虹_ (赞：6)

就是一道模拟题啦。

如果不从字符串处理思考，当成大整数写可能有助于想全不合法的情况。

不合法的情况有三种：
1. 前导零。
2. -0（样例明示）
3. 单独的‘-’号。~~（个人认为显而易见，但是机房里有不少人都忘了这事）~~

判断完合法之后，判断范围就行了。

应该可以通过判断数字是不是在long long的位数范围内，然后就用atol函数转成long long，和l，r比较或者输出2就行了。（不过可能会被卡，要是和long long max高精比较又失去了这个做法的简单优势）

也可以我这样直接把l，r用高精度盘一下，然后高精度比较大小。

没有四则运算，所以正着存倒着存都行。
（虽然我倒着处理的，但是一开始是正着存的，em...）。

代码应该可以自解释。
```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
class bigint
{
    public:
        string str;
        bool tag;
        bigint(string _str,bool _tag)
        {
            str=_str;
            reverse(str.begin(),str.end());
            tag=_tag;
        }
        bigint(string _str)
        {
            if(_str.size()==0){
                str.clear();
                return;
            }
            if(_str[0]=='-')
            {
                tag=true;
                str=_str.substr(1,_str.size());
            }
            else
            {
                tag=false;
                str=_str;
            }
            reverse(str.begin(),str.end());
        }
        bigint()
        {
            tag=false;
        }
        const bigint operator=(string _str)
        {
            if(_str.size()==0){
                str.clear();
                return *this;
            }
            if(_str[0]=='-')
            {
                tag=true;
                str=_str.substr(1,_str.size());
            }
            else
            {
                tag=false;
                str=_str;
            }
            reverse(str.begin(),str.end());
        //	cout<<"=	"<<_str<<"	"<<str<<endl;
            return *this;
        }
        const bool operator==(const bigint& b)
        {
            return tag==b.tag&&str==b.str;
        }
        const bool abs_smaller(const bigint& b)
        {
            int as=str.size();
            int bs=b.str.size();
            if(as==bs)
            {
                for(register int i=as;i>=0;--i)
                {
                    if(str[i]!=b.str[i])//different number
                    {
                        return str[i]<b.str[i];
                    }
                }
                return false;
            }
            else
                return as<bs;
        }
        const bool operator<(const bigint& b)
        {
            if(tag==true)//this<0
            {
                if(b.tag==false)//b>=0
                    return true;
                else
                    return !abs_smaller(b);
            }
            else//this>=0
            {
                if(b.tag==true)//b<0
                    return false;
                else
                    return abs_smaller(b);
            }
        }
        const bool operator>(const bigint& b)
        {
            //when a>b,a<b==false&&a==b==false;
            return !(*this<b||*this==b);
        }
};
const bool check(string& str)
{
//	cout<<"check"<<str.size()<<endl;
    if(str.size()==1)
        return !(str[0]=='-');
    else{
        return !(str[0]=='-'&&str[1]=='0'||str[0]=='0');
    }
}
string sl,sr;
bigint i,l,r;
int T;
void output()
{
    cout<<"ooutput"<<endl;
    for(register int i=0;i<l.str.size();++i)
        cout<<l.str[i];
    cout<<"	"<<l.tag<<endl;
    for(register int i=0;i<r.str.size();++i)
        cout<<r.str[i];
    cout<<"	"<<r.tag<<endl;
}
int main()
{
    ios::sync_with_stdio(false);
    string str;
    cin>>sl>>sr>>T;
    l=sl;
//	cout<<"L"<<endl;
    r=sr;
//	cout<<"R"<<endl;
//	output();
    while(T--)
    {
        cin>>str;
        if(check(str))//str is ok 
        {
        //	cout<<"ok	"<<str<<endl;
            i=str;
            if((l<i||l==i)&&(i<r||i==r))
                cout<<0<<endl;
            else
                cout<<2<<endl;
        }
        else
        {
        //	cout<<"not ok"<<endl;
            cout<<1<<endl;
        }
    }
    /*cin>>T;
    while(T--)
    {
        cin>>sl>>sr;
        l=sl;
        r=sr;
        cout<<(l<r)<<endl;
    */
    return 0;
}
```

std::string nb！

---

## 作者：kfhkx (赞：4)

## 18次提交才AC的惨痛经历

这题是真·细节题

~~细到少考虑一种不合法的情况都不行~~

以上为题外话

以下是正篇环节
------------

首先，他有几种不合法的情况，我们来特殊考虑

### - ‘-0’这一情况肯定是不合法的
### - 单独一个‘-’号也是不合法的(因为这里交了5次)
### - ‘0’开头的数字

这三种情况只要特判一下就搞定了~

然后，我们看看数据范围
![](https://i.loli.net/2019/03/03/5c7b2390610b5.png)
2^63=9223372036854775808 有19位，所以如果这个数超过19位数且合法就直接判为2就行了
（即字符串读入长度超过19位就可以判2，但要注意负数是20位才判）

最后就直接用字符串之间比较或者把他转成数字再比较就行了~

p5238.pas(p系选手的福利）
------------
```pascal
var
        t,len,k:longint;
        l,r,gp:int64;
        s:string;//最多只有20位，所以不用ansistring
begin
        readln(l,r,t);
        while t>0 do begin
                s:='';
                k:=0;
                dec(t);
                readln(s);
                len:=length(s);
                if (s[1]='0') and (len>1) then begin//特判0开头的数字
                                writeln(1);
                                continue;
                end;
                if (len=1) and (s[1]='-') then begin//特判只有一位且为‘-’的情况
                                writeln(1);
                                continue;
                end;
                if (len>1) and (s[1]='-') then begin
                        if s[2]='0' then begin//特判‘-0’的情况
                                writeln(1);
                                continue;
                        end;
                end;
                if ((len>20) and (s[1]='-')) or ((len>19) and (s[1]<>'-')) then begin
                //特判位数过多的情况，正数为19位，负数为20位（多了个‘-’）
                        writeln(2);
                        continue;
                end;
                val(s,gp,k);//我这里用的是转成数字进行比较，转数失败即为超过int64范围，所以直接判2
                if k<>0 then begin//转数失败特判
                        writeln(2);
                        continue;
                end;
                if (gp>=l) and (gp<=r) then writeln(0) else writeln(2);//最后判断
        end;
end.
```


------------
附第一组数据感谢@浮尘ii
## Input
```
-9223372036854775808 9223372036854775807 9
-
-0
0123456789
-9223372036854775808
-92233720368547758081
92233720368547758083
9223372036854775808
9323372036854775807
-9243372036854775807
```
## Output
```
1
1
1
0
2
2
2
2
2

```








---

## 作者：StephaneZ (赞：3)

这是一道**比较**简单的题，涉及少量字符串相关知识。

需要注意的点：

- 合法性判定

- 带正负的高精大小比对

部分坑点：

- 双负时绝对值大的数反而小

- 需要依据正负性选择判定大小方法，且须在判定时去掉符号

- "-"是一部分数据，因为：
> 保证 $x$ 长度至少为 11 且仅由 '0'~'9' 及 '-' 构成，且 '-' 只会出现在第一个字符。

好了，一切尽在代码中。上代码——
```c++
#include<iostream>
#include<string>
using namespace std;
bool pn(string a) //正负判定
{
	if(a[0]=='-') return false;
	else return true;
}
int comp(string a,string b) //比对
{
	if(pn(a)==true && pn(b)==false) return 1;
	if(pn(a)==false && pn(b)==true) return 0;
    //前置判定，省去一边去一遍不去之苦
	if(pn(a)==true && pn(b) ==true) //双正判定
	{
		if(a.length()>b.length()) return 1;
		if(a.length()<b.length()) return 0;
		for(int y=0;y<a.length();y++)
		{
			if(a[y]>b[y]) return 1;
			if(a[y]<b[y]) return 0;
		}
		return 2;
	}
	if(pn(a)==false && pn(b)==false) //双负判定（注意几乎是反过来的！）
	{
		if(a.length()<b.length()) return 1;
		if(a.length()>b.length()) return 0;
		for(int y=1;y<a.length();y++) //习惯于忽略负号
		{
			if(a[y]<b[y]) return 1;
			if(a[y]>b[y]) return 0;
		}
		return 2;
	}
}
bool val(string a) //合法性判定
{
	if(a=="0") return true; //对0提前判定，避免与后冲突
	if(a=="-") return false; //这种数据害得我最终分少了10分
	if(a[0]=='-' && a[1]=='0') return false; //-0~类
	if(a[0]=='0') return false; //0~类
	return true;
}
string l,r;
int t;
int main()
{
	cin>>l>>r>>t;
	string temp;
	for(int f=0;f<t;f++)
	{
		cin>>temp;
		if(comp(temp,l)!=0 && comp(temp,r)!=1 && val(temp)==true)
		{
			cout<<'0'<<endl;
			continue;
		}
		if(val(temp)==false)
		{
			cout<<'1'<<endl;
			continue;
		}
			
		if(comp(temp,l)==0 || comp(temp,r)==1)
		{
			cout<<'2'<<endl;
			continue;
		}	
	}
	return 0;
}
```

---

## 作者：维尼 (赞：2)

##### **洛谷月赛T1，作为一道模拟题，这题的坑还是很多的。**
不过，既然是模拟就要有模拟的做法。      
用了stringstream，一溜if就下来了。  
注意long long 边界特判。


------------
上代码
```c
#include<bits/stdc++.h>
#define FOR(i,b,c) for(i=b;i<=c;i++)
using namespace std;
long long m,n,x,y,o,l,r;
const long long mmax=9223372036854775807,mmin=-9223372036854775808;
char a[5300],b[20]={"9223372036854775807"},c[21]={"-9223372036854775808"};
stringstream ee;
int main(){int i;int j=0;
cin>>l>>r>>n;
FOR(i,1,n){
    cin>>a;ee.clear();ee<<a;    ee>>o;
    if(o==mmax&&(strlen(a)==19&&a[0]!='-')&&j==0){
       FOR(x,1,20){
        if(b[x]!=a[x]){
            j=1;break;
        }
    }
    }
    if(o==mmin&&(strlen(a)==20&&a[0]=='-')&&j==0){
       FOR(x,1,21){
        if(c[x]!=a[x]){
            j=1;break;
        }
    }
    }
    if(a[0]=='-'&&(a[1]<'1'||a[1]>'9')){
        cout<<"1"<<endl;continue;
    }
    if(a[0]=='0'&&strlen(a)!=1){
        cout<<"1"<<endl;continue;
    }   

    if((strlen(a)>19&&a[0]!='-')||(strlen(a)>20&&a[0]=='-')){   
     cout<<2<<endl;continue;    
    }
    if(o==mmax&&(strlen(a)==19&&a[0]!='-')&&j==1){
        cout<<2<<endl;continue; 
    }
    if(o==mmin&&(strlen(a)==20&&a[0]=='-')&&j==1){
        cout<<2<<endl;continue; 
    }
    if(o>=l&&o<=r){
    cout<<0<<endl;continue;
    }
cout<<2<<endl;continue;
    }
}   
```


---

## 作者：1saunoya (赞：2)

> 第一次月赛 我只有255pts
> T1还是比较水的。。。
> 海星 T1一道简单的模拟（就是有坑。。导致很多人不能一次性AC ~~比如说我~~）


> 	_3个坑点

> 1.位数问题 

>
![](https://img2018.cnblogs.com/blog/1596670/201903/1596670-20190302192653426-678068063.png)



> 2.-0
>
```cpp
if(s[0]=='-' and s[1]=='0') flag1=1;
```

> 3.0...
>
```cpp
if(s[0]=='0' and s.length()>1) flag1=1;
```

> 所以两个特判+一个函数 **Accepted**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline LL read () { LL res = 0 ;int f (1) ;char ch = getchar ();
    while (!isdigit(ch)) { if (ch == '-') f = -1 ;ch = getchar();}
    while (isdigit(ch)) res = (res << 1) + (res << 3) + (ch ^ 48) ,ch = getchar(); return res * f ;
}
LL l,r,t;
inline void print(__int128 x) {
    if(x<0) putchar('-'),x*=-1;
    if(x>9) print(x/10); putchar(x%10+48);
}
inline bool pd(string s) { __int128 x=0; register int f=0,tot=-1; register char ch=0;
    while(!isdigit(ch))f|=(ch=='-'),ch=s[++tot];
    while(tot<=s.length() and isdigit(ch)) {
        x=(x<<1)+(x<<3)+(ch^48); if(f) { if(x*-1>r or x*-1<l) return true;
        } else if(x>r or x<l) return true;
        ch=s[++tot];
    }
    return false;
}
signed main() {
    l=read(),r=read(),t=read();
    while(t--) {
        string s; getline(cin,s);
        bool flag1=0,flag2=0;
        if(s=="-") flag1=1;
        if(s[0]=='-' and s[1]=='0') flag1=1;
        if(s[0]=='0' and s.length()>1) flag1=1;
        if(flag1) { puts("1"); continue; } flag2=pd(s);
        if(flag2) { puts("2"); continue; }
        puts("0");
    }
    return 0;
}
```


---

## 作者：muller (赞：2)

这题是一道简单的模拟

但是细节比较多

笔者提交了3次才A掉，导致只有90 qwq

首先l,r在long long范围内

但x不在long long范围内

所以要用字符串，比较大小，有点细节

其次有几个显而易见的问题

-00000...不合法
0133...不合法

这些都可以直接判掉

还有一个单独负号的情况有点坑，要注意

上代码，巨长无比：（莫名恐慌）
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
string s, sl, sr;
ll l, r, t;
int i, T, len;
bool Cmp(string a, string b) {
	if (a.size() < b.size()) return true;
	if (a.size() > b.size()) return false;
	for (i = 0; i < a.size(); ++i)
		if (a[i] < b[i]) return true;
		else if (a[i] > b[i]) return false;
	return false; 
}
bool cmp(string a, string b) {
	bool fa = false, za = false, fb = false, zb = false;
	if (a == b) return false;
	if (a[0] == '-') fa = true;
	if (a[0] == '0') za = true;
	if (b[0] == '-') fb = true;
	if (b[0] == '0') zb = true;
	if (fa && (zb || (!fb && !zb))) return true;
	if (fb && (za || (!fa && !za))) return false;
	if (za && (!fb && !zb)) return true;
	if (zb && (!fa && !za)) return false;
	if (fa && fb) {
		a.erase(0, 1); b.erase(0, 1);
		swap(a, b);
		return Cmp(a, b);
	}
	return Cmp(a, b);
}
string dif(ll x) {
	string st = "", stm;
	if (x < 0) {x = -x; st += '-';}
	while (x) {stm += x % 10 + '0'; x /= 10;}
	reverse(stm.begin(), stm.end());
	st = st + stm;
	return st;
}
int main() {
    ios :: sync_with_stdio(false);
    cin >> l >> r >> T;
    sl = dif(l); sr = dif(r);
    while (T--) {
        cin >> s; len = s.size();
        if (s[0] != '-' && !(s[0] >= '0' && s[0] <= '9')) {
            cout << 1 << endl;
            continue;
        }
        if (s == "0") {
            if (l <= 0 && r >= 0) cout << 0 << endl;
            else cout << 2 << endl;
            continue;
        }
        if (s == "-") {
        	cout << 1 << endl;
        	continue;
		}
        if (s[0] == '-') {
            if (s[1] == '0') {
            	cout << 1 << endl;
				continue;
            }
            if (cmp(s, sl) || cmp(sr, s)) cout << 2 << endl;
            else cout << 0 << endl;
        }
        else {
            if (s[0] == '0') {
            	cout << 1 << endl;
            	continue;
			}
            if (cmp(s, sl) || cmp(sr, s)) cout << 2 << endl;
            else cout << 0 << endl;
        }
    }
    return 0;
}

```


---

## 作者：Doveqise (赞：1)

T1字符串大模拟，洛谷3月月赛日推，有问题下见 ~~（极长的）~~ 代码注释。
```cpp
#include<bits/stdc++.h>
char start[30],end[30],target[200050];//不用string
int main()
{
	int a,i,lenth,j,T1=0,T2=0,startlenth,endlenth;
	scanf("%s%s%d",start,end,&a);
	startlenth=strlen(start);//读入l
	endlenth=strlen(end);//读入r
	if(!a)//第一个数据点没有输入数据
	{
		return 0;
	}
	for(i=1;i<=a;i++)
	{
		j=1;
		T1=0;
		T2=0;
		scanf("%s",target);
		lenth=strlen(target);
		if(lenth==1)
		{
			if(target[0]=='0')
			{
				if(start[0]!='-'&&start[0]!='0')
				{
					printf("2\n");
					continue;
				}
				else
				{
					printf("0\n");
					continue;
				}
			}//等于0情况
			if(target[0]=='-')
			{
				printf("1\n");
				continue;
			}//负号特判一下
		}
		if(target[0]=='0')
		{
			printf("1\n");
			continue;
		}//以0开头的非法数据
		if(target[0]=='-'&&target[1]=='0')
		{
			printf("1\n");
			continue;
		}//以-0开头的非法数据
		if(lenth>21)
		{
			printf("2\n");
			continue;
		}//数字过大溢出
		if(target[0]=='-')
		{
			if(start[0]!='-')
			{
				printf("2\n");
				continue;
			}//负数超过范围
			else
			{
				if(startlenth>lenth)
				{
					T1=1;
					j=lenth;
				}
				if(startlenth<lenth)
				{
					printf("2\n");
					continue;
				}
				while(j<lenth)
				{
					if(start[j]!=target[j])
					{
						if(start[j]>target[j])
						{
							T1=1;
						}
						if(start[j]<target[j])
						{
							T1=2;
						}
						break;
					}
					else
					{
						j++;
					}
				}
				if(j==lenth&&!T1)
				{
					T1=1;
				}
				j=0;
				if(end[0]=='-')
				{
					j++;
				}
				if(end[0]!='-')
				{
					T2=1;
					j=lenth;
				}
				else
				{
					if(endlenth<lenth)
					{
						printf("2\n");
						continue;
					}
					if(endlenth>lenth)
					{
						T2=1;
						j=lenth;
					}
				}
				while(j<lenth)
				{
					if(end[j]!=target[j])
					{
						if(end[j]>target[j])
						{
							T2=1;
						}
						if(end[j]<target[j])
						{
							T2=2;
						}
						break;
					}
					else
					{
						j++;
					}
				}
				if(j==lenth&&!T2)
				{
					T2=1;
				}
				if(T1==1&&T2==1)
				{
					printf("0\n");
					continue;
				}
				else
				{
					printf("2\n");
					continue;
				}//一大坨（划掉）判大小
			}
		}
		else
		{
			if(end[0]=='-')
			{
				printf("2\n");
				continue;
			}
			if(start[0]=='-')
			{
				T1=1;
			}
			else
			{
				if(startlenth<lenth)
				{
					T1=1;
					j=lenth;
				}
				if(startlenth>lenth)
				{
					printf("2\n");
					continue;
				}
			}
			j=0;
			while(j<lenth)
			{
				if(start[j]!=target[j])
				{
					if(start[j]>target[j])
					{
						T1=1;
					}
					if(start[j]<target[j])
					{
						T1=1;
					}
					break;
				}
				else
				{
					j++;
				}
			}
			if(j==lenth&&!T1)
			{
				T1=1;
			}
			j=0;
			if(endlenth<lenth)
			{
				printf("2\n");
				continue;
			}
			if(endlenth>lenth)
			{
				T2=1;
				j=lenth;
			}
			while(j<lenth)
			{
				if(end[j]!=target[j])
				{
					if(end[j]>target[j])
					{
						T2=1;
					}
					if(end[j]<target[j])
					{
						T2=2;
					}
					break;
				}
				else
				{
					j++;
				}
			}
			if(j==lenth&&!T2)
			{
				T2=1;
			}
			if(T1==1&&T2==1)
			{
				printf("0\n");
				continue;
			}
			else
			{
				printf("2\n");
				continue;
			}//判大小+1
		}
	}
	return 0;
}

```


---

## 作者：于丰林 (赞：1)

作为洛谷月赛的第一题，纯暴力，但是这里面的坑实在是太多了。。。

看到题解里面各位大佬都使用起了unsigned long long，没听过的我只能祭出打表比较法了

题意简单来说就是判断一个整数写法是否正常。

看了一下数据范围，发现这个只能用字符串进行读取啊。。。

于是我们根据字符串首位可以分为以下几种情况：

1.首位是0

如果只有一个0，那么一定是合法的，如果除了它以外还有别的东西，那么一定是不合法的。

除此之外只要判断是否在区间范围内即可（后面会讲如何判断）

2.首位是‘-’

这个应该坑了一批人，但是我比赛时没错在这。。。

如果只有一个‘-’，那么一定是不合法的

如果是-0，那么也是不合法的

如果是-后面一位不是0，那么一定是合法的

3.首位是1-9的数

合法了！

好的，重点来了

那么接下来讲如何判断是否在区间内。

题中有一个隐含条件，如果读入的东西爆longlong了，那么一定不在区间内，而如果不爆的话，我们就可以转化成正整数，那么问题就成了如何判断爆不爆

于是就惊现了毒瘤打法：打表

首先，将2^63-1打出来，发现是19位，那么大于19位直接判定爆了，等于的话就加一个特判，逐位比较。那么负数也是同理了。。。

所以这道题就讲完了。。。

最后，附上本题代码：

```cpp
#include<cstdio>
#include<cstring>
#define LL long long
using namespace std;
char x[1005];
LL T,len,l,r;
int temp[25];
bool jd1()
{
    for(int i=1; i<=18; i++)
    {
        if(x[i]-'0'>temp[i])
        {
            return 1;
        }
        else if(x[i]-'0'==temp[i])
        {
            continue;
        }
        else
        {
            return 0;
        }
    }
    if(x[19]-'0'>temp[19]+1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
bool jd2()
{
    for(int i=1; i<=19; i++)
    {
        if(x[i-1]-'0'>temp[i])
        {
            return 1;
        }
        else if(x[i-1]-'0'==temp[i])
        {
            continue;
        }
        else
        {
            return 0;
        }
    }
    return 0;
}
bool judge()
{
    LL s=0;
    if(x[0]=='-')
    {
        if(len==20)
        {
            if(jd1()==1)
            {
                return 0;
            }
        }
        if(len>20)
        {
            return 0;
        }
        for(int i=1; i<=len-1; i++)
        {
            s=(s<<3)+(s<<1)+x[i]-'0';
        }
        s-=s*2;
    }
    else
    {
        if(len==19)
        {
            if(jd2()==1)
            {
                return 0;
            }
        }
        if(len>19)
        {
            return 0;
        }
        for(int i=0; i<=len-1; i++)
        {
            s=(s<<3)+(s<<1)+x[i]-'0';
        }
    }
    if(s>=l&&s<=r)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
int main()
{
    temp[1]=9;temp[2]=2;temp[3]=2;temp[4]=3;
    temp[5]=3;temp[6]=7;temp[7]=2;temp[8]=0;
    temp[9]=3;temp[10]=6;temp[11]=8;
    temp[12]=5;temp[13]=4;temp[14]=7;
    temp[15]=7;temp[16]=5;temp[17]=8;
    temp[18]=0;temp[19]=7;
    scanf("%lld%lld%lld",&l,&r,&T);
    for(int i=1; i<=T; i++)
    {
        scanf("%s",x);
        len=strlen(x);
        if(x[0]=='0')
        {
            if(len==1)
            {
                if(judge()==1)
                {
                    printf("0\n");
                }
                else
                {
                    printf("2\n");
                }
            }
            else
            {
                printf("1\n");
            }
        }
        else if(x[0]=='-')
        {
            if(len==1)
            {
                printf("1\n");
            }
            else
            {
                if(x[1]=='0')
                {
                    printf("1\n");
                }
                else
                {
                    if(judge()==1)
                    {
                        printf("0\n");
                    }
                    else
                    {
                        printf("2\n");
                    }
                }
            }
        }
        else
        {
            if(judge()==1)
            {
                printf("0\n");
            }
            else
            {
                printf("2\n");
            }
        }
    }
    return 0;
}
```


---

## 作者：NotEvenANeko (赞：1)

我搞了半天搞不出来一看是长度判断写小了……只有一个'-'的也没有判断……

**要小心只有一个减号'-'**

不合法的情况有3种

	1、-0……
    2、0……
    3、-
所以输入后先判断这几个

然后题目里说，l和r是在ll范围内的，所以可以考虑将长度合适的字符串转换为ll来做~~至少不用写比较函数了~~

太长的直接输出2就行了

代码
```cpp
#include<bits/stdc++.h>
#define ll long long

using std::cin;
using std::cout;
using std::endl;

int main()
{
    int T;
    ll l,r;
    scanf("%lld%lld",&l,&r);
    scanf("%d",&T);
    while(T--)
    {
        std::string t;
        cin>>t;
        if((t[0]=='-'&&t.size()==1)||(t[0]=='-'&&t[1]=='0')||(t[0]=='0'&&t.size()>1))     //是否合法
        {
            printf("1\n");
            continue;
        }
        else if((t[0]!='-'&&t.length()>19)||(t[0]=='-'&&t.length()>20))     //在ll范围外的可以直接输出2
        {
            printf("2\n");
            continue;
        }
        ll tmp;
        tmp=0;      //tmp为其值
        bool tag=false;
        if(t[0]=='-')
            tag=true;
        for(int i=(tag?1:0);i<t.length();i++)   //给tmp赋值
            tmp=tmp*10+(t[i]-'0');
        if(tag)
            tmp=-tmp;
        if(l<=tmp&&tmp<=r)  //是否在范围内
            printf("0\n");
        else
            printf("2\n");
    }
    system("pause");//上交oj时记得注释或删除
    return 0;
}
```


---

## 作者：xht (赞：1)

显然这道题不算难，细心即可AC

细节见代码中的注释

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
string s, l, r;//对除了数据组数以外的所有数均用string存

inline bool pd0(int l, int r) {//判断是否每一位都符合要求
	for (int i = l; i < r; i++)
		if ('0' <= s[i] && s[i] <= '9') continue;
		else return 0;
	return 1;
}

inline bool pd1() {//判断是否合法
	int len = s.length();
	if (len == 1 && s[0] == '0') return 1;//0要特判
	if (s[0] == '-') {//负数和正数分开判
		if ('1' <= s[1] && s[1] <= '9')//判断首位是否符合要求
			return pd0(2, len);
		return 0;
	}
	if ('1' <= s[0] && s[0] <= '9')
		return pd0(1, len);
	return 0;
}

inline bool pd(string a, string b) {//判断a是否小于b
	int lena = a.length(), lenb = b.length();
	if (lena == lenb) {
		int flag = 1;
		for (int i = 0; i < lena; i++)
			if (a[i] != b[i]) {
				flag = 0;
				break;
			}
		if (flag) return 1;//特判相等
	}
	if (a[0] == '-' && b[0] != '-') return 1;
	if (a[0] != '-' && b[0] == '-') return 0;
	if (a[0] == '-' && b[0] == '-') {//正数负数分开判
		if (lena < lenb) return 0;
		if (lena > lenb) return 1;//先判长度 
		for (int i = 1; i < lena; i++) {
			if (a[i] == b[i]) continue;
			if (a[i] < b[i]) return 0;
			return 1;
		}
	}
	if (a[0] != '-' && b[0] != '-') {
		if (lena > lenb) return 0;
		if (lena < lenb) return 1;
		for (int i = 0; i < lena; i++) {
			if (a[i] == b[i]) continue;
			if (a[i] > b[i]) return 0;
			return 1;
		}
	}
	return 0;
}

inline bool pd2() {//判断是否越界
	return pd(l, s) && pd(s, r); 
}

int main() {
	ios::sync_with_stdio(0);//用了string就必须用cin，加点速 
	cin >> l >> r;
	int t;
	cin >> t;
	while (t--) {
		cin >> s;
		if (!pd1()) {//判断是否输出1
			puts("1");
			continue;
		}
		if (!pd2()) {//判断是否输出2
			puts("2");
			continue;
		}
		puts("0");
	}
	return 0;
}
```

---

## 作者：StudyingFather (赞：1)

细节挺多的一道简（du）单（liu）题。

检查一个数的格式是否合法非常简单，按定义来就行了，但存在以下坑点：

1. 单独一个负号`-`；
2. `00`；
3. `-0`。

至于如何检查一个数是否在区间内，我用了一个奇怪的方法实现。

因为`long long`类型的范围约在 $ -9*10^{19} - 9*10^{19} $ 之间，我们可以先检查数字的位数（别忘了 $ l,r $ 均在`long long`范围之内）。检查完数字位数之后，要检查的数字的绝对值一定能用`unsigned long long`存储。再和`long long`的最大最小值比较一下看是否超过范围即可。

确认过数字在`long long`范围之内之后，直接判断该数字是否在区间内即可（这时候直接数字比较就可以了）。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
char s[200005],s1[200005],s2[200005];
long long l,r,t;
int check_num()
{
 int len=strlen(s);
 if(s[0]=='-'&&(len==1||s[1]=='0'))return 1;
 else if(s[0]=='0'&&len!=1)return 1;
 return 0;
}
int check_range()
{
 unsigned long long num=0;
 int op=1,len=strlen(s);
 if(s[0]=='-'&&len>20)return 2;
 if(s[0]!='-'&&len>19)return 2;
 if(s[0]=='-')op=-1;
 for(int i=(op==1?0:1);i<len;i++)
  num=num*10+(s[i]-'0');
 if(op==-1&&num>(1ull<<63))return 2;
 if(op==1&&num>(1ull<<63)-1)return 2;
 long long num1=(long long)num*op;
 if(num1<l||num1>r)return 2;
 return 0;
}
int main()
{
 cin>>l>>r>>t;
 while(t--)
 {
  cin>>s;
  int flag=0;
  flag=check_num();
  if(flag)
  {
   cout<<flag<<endl;
   continue;
  }
  flag=check_range();
  cout<<flag<<endl;
 }
 return 0;
}

```


---

## 作者：Eason_AC (赞：0)

## Content
给定两个整数 $l,r$，再给定 $T$ 个整数，请判断对于每个整数 $x$，是否满足以下要求：

- $x\in[l,r]$。
- $x$ 格式合法。

**数据范围：$-2^{63}\leqslant l,r\leqslant 2^{63}-1,0\leqslant T\leqslant 512$。**
## Solution
一道模拟题。

我们先来判断这个数是否格式合法。格式不合法的情况有以下几种：

- 只有单独的一个负号。
- 以 $0$ 开头且长度不为 $1$。
- 以一个负号和一个 $0$ 开头。

这些特判完以后我们就来看这个数如何处理。由于这个数可能很大，所以在 C++ 语言中直接用普通的整型变量读入肯定是不科学的。所以一开始只能够用字符串来读入，然后就开始将其转化为数字，注意一定要看是否会超过 $\textsf{long long}$ 的范围，一旦超过了就得结束此次判断。

如果转换完了，再看这个数字是否在这个范围里面。
## Code
```cpp
int t;
long long l, r;

bool judge1(string s) {
	int len = s.size();
	if(len != 1 && s[0] == '0') return 1;
	if(len == 1 && s[0] == '-') return 1;
    if(s[0] == '-' && s[1] == '0') return 1;
	return 0;
}

int main() {
	l = Rll, r = Rll, t = Rint;
	while(t--) {
		string s; cin >> s;
		int len = s.size(), flag = 1; unsigned long long x = 0ll, f = 1ll;
		if(judge1(s)) puts("1");
		else {
			if(s[0] == '-') f = -1ll;
			for(int i = (s[0] == '-' ? 1 : 0); i < len; ++i) {
				if(x > 922337203685477580ll || (x == 922337203685477580ll && ((f == 1ll && s[i] > '7') || (f == -1ll && s[i] > '8')))) {flag = 0; break;}
				x = x * 10 + s[i] - '0';
			}
			long long res = x * f;
			if(!flag || (res < l || res > r)) puts("2");
			else puts("0");
		}
	}
	return 0;
}
```

---

## 作者：questRush (赞：0)

#### 题目分析

本题的关键在于字符串的合法格式检验和整数的范围检验：

-	如果字符串格式不满足题目第一个条件，则输出 $1$。
-	如果字符串格式满足题目第一个条件但不满足第二个条件，则输出 $2$。
-	如果字符串格式均满足两个条件，则输出 $0$。

所以：

-	我们可以使用**正则表达式**判断第一个条件，避免手动检测字符串带来的易错性。
-	我们可以使用**异常**判断第二个条件，避免手写高精度带来的易错性。

#### 代码

-	代码采用 C++17 标准编译并开启 O2 优化。

```cpp
#include <bits/extc++.h>

using namespace std;
using ll = long long;

inline const regex r("^(0|\\-{0,1}[1-9][0-9]*)$");

ll left_ll, right_ll;
int t;

inline static
int parse(const string &s) {
    if (!regex_match(s, r)) {
        return 1;
    }
    try {
        ll temp = stoll(s);
        if (temp >= left_ll && temp <= right_ll) {
            return 0;
        }
    } catch (out_of_range &ex) {}
    return 2;
}

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> left_ll >> right_ll >> t;
    cin.get();
    string s;
    while (t--) {
        getline(cin, s);
        cout << parse(s) << '\n';
    }
    return 0;
}
```

---

## 作者：睿3030 (赞：0)

[个人洛谷博客](https://www.luogu.org/blog/rui3030blog/)

~~这是一道恐怖的黄题~~

（如何判断一个数是否合法，其他题解已经叙述的很清楚了，因此我只讲如何比较大小）

对于我这种不喜欢写高精，也不喜欢逐位判断的人来说，这个题是真的烦！但是，注意到：  
```
'9' > '8' > '7' > '6' > '5' > '4' > '3' > '2' > '1' > '0'
```
因此我们考虑比较它们的字典序来比较它们的大小！  
而比较字典序怎么比较？string类的大于小于符号是重载过的，比较方法就正好是字典序！  

然后你就会发现样例都过不了……

```
众所周知：
100000000000000000000 > 3
然而string::operator < 会认为：
"100000000000000000000" < "3"
理由是 "1" < "3"
```
这个时候你就会想到应该为3补前导0。

### 那么用什么来补呢？

**重点来了**

还记得```printf(const char * __restrict__ _Format, ...)```格式化输出的用法吗？  
当你需要输出前导0的时候，使用"%0nd"输出n位数，不足n位补前置0。  

**那么这里介绍一个函数```sprintf(char * __restrict__ _Dest, const char * __restrict__ _Format, ...)```**

这个函数的除开第一个参数就跟printf一模一样，printf是将格式化后的字符串输出到标准输出(stdout)，而sprintf将格式化后的字符串**存储**到第一个参数中。  

利用这个函数，你就可以为3补足前置0了！！！

```cpp
bool cmp(string s, long long x)//比较s和x，小于返回1，否则返回0
{
	char tmp[1000];
	sprintf(tmp, "%0nlld", x);//这个n应该是s的长度，这样就可以使两个数位数相同了！
	string sx = tmp;//字符数组可以直接给string赋值
	return s < sx;
}
```
上面的n显然应该等于s.length()，那么怎么写呢？
```
可能有很多人认为可以这样写：
sprintf(ck, "%0%ulld", s.length(), x);
先用s.length()替换%u然后再换x。
然而这肯定是不行的……sprintf没有那么智能
(这样转换的结果是"%ulld")
```
所以我们换一个想法  
我们知道在Python中，你可以这样写
```python
"%0" + s.length() + "lld"
```
但是C++不支持字符串与整数相加，不过有一个类支持：
#### stringstream闪亮登场！(头文件为sstream)
因此你只需要这样写就可以了：
```cpp
bool cmp(string s, long long x)//比较s和x，小于返回1，否则返回0
{
	char tmp[1000];
	stringstream ss;
	ss << "%0" << s.length() << "lld";
	sprintf(tmp, ss.str().c_str(), x);//ss.str()返回的是一个string，而string.c_str()会返回字符数组常量。
	string sx = tmp;//字符数组可以直接给string赋值
	return s < sx;
}
```
自此，我们就~~完美~~地完成了比较大小的任务！！！

### 等等！你需要特判正负！
加几句就好了嘛。。。。
```cpp
bool cmp(string s, long long x)
{
	if(s[0] == '-'){
		if(x >= 0) return 1;
	}else{
		if(x <= 0) return 0;
	}
	char tmp[1000];
	stringstream ss;
	ss << "\%0" << s.length() << "lld";
	sprintf(tmp, ss.str().c_str(), x);
	string sx = tmp;
	if(s[0] == '-') return s > sx;
	else return s < sx;
}
```
~~好了，现在完美了~~
### 再等等！万一 x 的位数比 s 多呢？？？
~~哎呀，好烦啊，坑死了~~  
其实，由于long long 的位数肯定不超过25，提前把s不足25位就好：
```cpp
string::iterator it;
while(s.length() < 25){
	it = s.begin();
	if(s[0] == '-') it++; //注意不要把0加在'-'前面去了！！！
	s.insert(it, '0');
}
```
自此，我们终于解决了这道题！！完整代码如下：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<sstream>
#include<iostream>
using namespace std;
#define debug(x) cout << #x << " = " << x << endl;

long long L, R;

bool cmp(string s, long long x){
	if(s[0] == '-'){
		if(x >= 0) return 1;
	}else{
		if(x <= 0) return 0;
	}
	string::iterator it;
	while(s.length() < 25){
		it = s.begin();
		if(s[0] == '-') it++;
		s.insert(it, '0');
	}
	char tmp[1000];
	stringstream ss;
	ss << "\%0" << s.length() << "lld";
//	debug(ss.str().c_str());
	sprintf(tmp, ss.str().c_str(), x);
	string sx = tmp;
//	debug(sx.c_str());
	if(s[0] == '-') return s > sx;
	else return s < sx;
}

void judge(string s){
	if(s[0] == '0'){
		if(s.length() != 1) printf("1\n");
		else if(0 < L || 0 > R) printf("2\n");
		else printf("0\n");
		return;
	}
	if(s[0] == '-' && (s.length() == 1 || s[1] == '0')){
		printf("1\n");
		return;
	}
	if(cmp(s, L)) printf("2\n");
	else if(cmp(s, R)) printf("0\n");
	else printf("2\n");
}

int main(){
	int T;
	scanf("%lld%lld%d", &L, &R, &T);
	while(T--){
		string s;
		cin >> s;
		judge(s);
	}
	return 0;
}
```


---

## 作者：无意识躺枪人 (赞：0)

果然你谷人才多%%%

我太菜了所以只会用字符串处理

首先格式不符就只有3种情况：

1. 数字带有前缀0（如0123）
2. 只有负号（如-）
3. 负号后第一位为0（如-0123）

判断完格式是否相符后只需直接比较数字大小即可

附上 ~~高清注释版~~ 代码


```c
#include<bits/stdc++.h>
#define MAXN 50000
using namespace std;

int T,ans;
char l[MAXN],r[MAXN],c[MAXN]={0};

int judge(char a[],char b[])//代码主体部分，建议看完主函数后看这里
{//该函数用来判断两个字符串表示的数字的大小
    if(a[0]=='-'&&b[0]!='-') return -1;
    if(a[0]!='-'&&b[0]=='-') return 1;//特判，负数一定小于非负数
    int a_len=strlen(a);
    int b_len=strlen(b);//长度

    if(a_len!=b_len)//若长度不同，非负数长度越大数越大，负数反之
    {
        if(a[0]=='-') return (a_len>b_len)?-1:1;
        else return (a_len<b_len)?-1:1;
    }
    int i=0;
    if(a[0]=='-') i++;
    for(;i<=a_len;i++)
        if(a[i]!=b[i])
        {
            if(a[0]=='-') return (a[i]<b[i])? 1:-1;
            else return (a[i]<b[i])? -1:1;
        }//逐个比较各个数字，有不同即可判断出大小
    return 0;
}

int main()
{
    scanf("%s%s%d",l,r,&T);//输入边界以及目标字符串
    while(T--)
    {
        ans=0;scanf("%s",c);//输入需要检验的字符串
        int len=strlen(c);//计算长度
        if(len!=1&&c[0]=='0') ans=1;//判断1:如果检验的数是第一位为0的数，则格式不符
        else if(c[0]=='-'&&(len==1||c[1]=='0')) ans=1;//判断2和3:如果有负号，则只有负号或负号后第一个为0则格式不符
        if(!ans) if(!(judge(l,c)<=0&&judge(r,c)>=0)) ans=2;//如果格式正确的话，调用函数判断其大小
        printf("%d\n",ans);//输出答案
    }
    return 0;
}
```



---

## 作者：杨铠远 (赞：0)

# **交了也就两页   以至于后来都要交验证码了。。。
**
由于本人函数名起的比较形象 大家不要嘲笑（逃

先上代码
```
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
int t,len,flag;
int one=1,er=2;
int zz=0;
long long l,r;//由于之前太lao 写成了char。。。
char a[300];
long long lll=9223372036854775807;
int b[20]={9,2,2,3,3,7,2,0,3,6,8,5,4,7,7,5,8,0,7};
bool panchang() //判断是否出界
{
	//long long int atol(char* ptr,int len)
    unsigned long long sum=0;//一点要用unsigned。。（血）写的教训
	int tot=0;
	long long x;
	if(a[0]=='-')//负的情况
	{
		for(int i=len-1;i>0;i--)//注 >0
		{
		sum+=(a[i]-'0')*pow(10,tot++);
		//if(lll-sum<=last)return 0;
		//sum+=last;
		}
		if(sum>(1LL<<63))return 0;
		x=-sum;
	}
	else 
	{
		for(int i=len-1;i>=0;i--)
		{
		sum+=(a[i]-'0')*pow(10,tot++);
		}
		if(sum>=(1LL<<63))return 0;
		x=sum;
	}
	if(x<=r&&x>=l)return 1;
	else return 0;
}
bool panfu()
{
	if(a[0]=='-')return 1;
	else return 0;
}
inline int chuling()//输出0。。。
{
	printf("%d\n",zz);}
inline int chuyi()//输出一
{
	printf("%d\n",one);
}
inline int chuer()　//二
{
	printf("%d\n",er);
}
signed main()//signed是个好习惯
{//以下就是诸如此类各种情况
	cin>>l>>r>>t;
	while(t--)
	{
		cin>>a;
		len=strlen(a);
		if(panfu())
		{
			if(len==1||a[1]=='0'){chuyi();
			continue;
			}
		}
		if(a[0]=='0'&&len>1){
				chuyi();
				continue;
			}
		if(panfu()&&len>20){
			chuer();
			continue;
		}
		if(!panfu()&&len>19)
		{
			chuer();
			continue;
		}
		if(!panchang()){
			chuer();
			continue;
			}
		if(panchang())
		chuling();
	}
	return 0;
}

```
看在本蒟蒻交了这么多次的份上（求过）


---

## 作者：lew2018 (赞：0)

主要就是模拟

先要输出不合法的情况：

 1. -0或单独一个‘-’号
 1. 首位为0且后面还有数

然后可以超过**long long**型的x直接输出不在区间内

代码：
```cpp
#include <iostream>
#include <string>
using namespace std;

inline long double zhuan(string s) {  //将字符串转成数字
    long double ans = 0;
    int ok;
    if (s[0] == '-') ok = -1;
    else ok = 1;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] >= '0' && s[i] <= '9') {
            ans = ans * 10 + (s[i] - '0');
        }
    }
    return ans * ok;
}

int main() {
    ios::sync_with_stdio(false);
    int T;
    long long l, r;
    string x;  //用字符串读入
    cin >> l >> r >> T;
    while (T--) {
        cin >> x;
        int len = x.size();
        if (x[0] == '-') {
            if (x[1] == '0' || len == 1) {
                cout << 1 << endl;
                continue; 
            }
        }
        if (x[0] == '0' && len > 1) {
            cout << 1 << endl;
            continue;
        }
        if (len > 20) {  //超出long long范围
            cout << 2 << endl;
            continue;
        }
        long double tmp = zhuan(x);  //用long long会被卡掉第一个点。。
        if (tmp >= l && tmp <= r) {  
            cout << 0 << endl;
        } else {
            cout << 2 << endl;
        }
    }
    return 0;
}
```

---

## 作者：love_luke (赞：0)

这道题不难，一道暴力题，先用字符串读入x，判断其合不合法，若合法，则将其转化为数字判断是否在[l,r]内。（应该还是容易懂的，程序也比较接地气）
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[21];
int main()
{
    long long l,r,t,lin,ss;
    unsigned long long x;
    cin>>l>>r>>t;
    while (t--)
    {
        x=0;
        scanf("%s",s);
        ss=strlen(s);
        if (s[0]=='0')//若该数第一项为0
        {
            if (ss==1)//若只有单独一个0合法
            {
                cout<<0<<endl;
            }
            else//如不是单独一个0肯定不合法
            {
                cout<<1<<endl;
            }
        }
        else
        if (s[0]=='-')//负数特判
        {
            if (ss==1)//单独一个负号不合法
            {
                cout<<1<<endl;
            }
            else
            if (s[1]=='0')//-0不合法
            {
                cout<<1<<endl;
            }
            else
            if (ss>20)//过大直接排除
            {
                cout<<2<<endl;
            }
            else//转为数操作
            {
                lin=1;
                while (lin<ss)
                {
                    x=x*10+(int)s[lin]-48;
					lin++;
                }
                x=-x;//负数
                if (x>=l)//因为小于0，只需比较左端点
                {
                    cout<<0<<endl;
                }
                else
                {
                    cout<<2<<endl;
                }
            }
        }
        else//正数同理
        {
            if (ss>19)
            {
                cout<<2<<endl;
            }
            else
            {
                lin=0;
                while (lin<ss)
                {
                    x=x*10+(int)s[lin]-48;
					lin++;
                }
                if (x<=r)
                {
                    cout<<0<<endl;
                }
                else
                {
                    cout<<2<<endl;
                }
            }
        }
    }
    return 0;
}
```


---

## 作者：封禁用户 (赞：0)


~~月赛T1,都是比较水的题目~~


------------
因为蒟蒻觉得很水,所以直接以为成了二分

蒟蒻我看到数据范围,l和r在long long范围;这时,蒟蒻想到了O(log n)的算法,O(log n)算法不就二分吗？

------------
~~二分干什么呢?查找他在不在那个区间啊..~~
蒟蒻解释一下,为什么有些dalao会想到二分:


------------
因为刷算法习惯的人,一看到long long范围,只有(log n),能通过,而这种算法只有二分;


------------

前置的一些蒟蒻就说一下吧,首先是那5%的T=0的数据,不做任何处理,5分拿到;

------------
其次,是不合法的情况,一共两种:


------------
1.-0//这个特别容易判断,直接读入字符串后,判断第一位,第二位


------------
2.这个数是以0开头的,这个也特别好判断;直接判断第一位,然后在看他的长度是不是1

以上两种直接一旦成功,直接break ;

------------
蒟蒻想到了个思路:读入一个字符串,将他转换成数字,如果一旦超过long long,并且前面没break 掉,直接输出2;

------------
蒟蒻先算了一下long long的值,9223372036854775807,只要判断位数>20,这直接break ；


------------

最重要的一点:

long long!!!,除了第一个测试点,其他的测试点都是19位数
然后把字符串转换成数字的那个变量,要unsigend

------------
废话不多说,上代码(带注释)
------------

```cpp
#include<bits/stdc++.h>
using namespace std;
long long kk=0;
long long xfs(long long x)//取一个数的相反数;
{
    return -x;
} 
string s;
int main()
{
    long long l,r,t;//正常读入,不解释 
    scanf("%lld%lld%lld",&l,&r,&t);
    while(t--)
    {
        kk=0;
        cin>>s;
        long long n=s.length();
        if(s[0]=='-')//-00000000或-这种情况 
        {
        	if(s[1]=='0'||n==1)
        	{
            	cout<<"1"<<endl;
            	continue;
        	}
        }
		if(s[0]=='0'&&n!=1)//0000000这种情况; 
        {
            cout<<"1"<<endl ;
            continue;
        }
        if (s[0]!='-' &&n>20)//是正数且超过long long 范围; 
        {
            puts("2");
            continue;
        }
        if (s[0]!='-' && n>19)//是负数,且超过long long 范围; 
		{
            puts("2");
            continue;
        }
        bool flag=false;
        if(s[0]=='-')
        {
            for(int i=1;i<n;i++)
            {
                kk=kk*10+s[i]-'0';
                if(kk<0)
                {
                    flag=true;
                    break;
                }
            }
            kk=xfs(kk);//转换成负数; 
        }
        else
        {
            for(int i=0;i<n;i++)
            {
                kk=kk*10+(s[i]-'0');
                if(kk<0)
                {
                    flag=true;
                    break;
                }
            }
        }//以上一个if,else是将字符串转换成数字; 
        if(flag==true)
        {
            cout<<"2"<< endl;
            continue;
        }//超过long long 范围,写重复了qwq 
        if(l<=kk&&r>=kk)
        {
            cout<<"0"<< endl;
            continue;
        }//在范围; 
        cout<<"2"<< endl;
    } 
    return 0;
}
//算法复杂度O(tn)

```


------------

~~写题解不易,望通过~~


---

## 作者：LB_tq (赞：0)

```
//一道细节较多的模拟题，我交了两遍。。。
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
string a,b,x;//string存储STL方便比较
int t;
bool tai(string s){//比较拙劣的判断函数，请大佬指出不足之处
	long long c;
	if((s.size()>b.size()&&s[0]!='-'&&b[0]!='-')||(s.size()<a.size()&&s[0]!='-'&&a[0]!='-'))
		return false;//同符号特判
    //分两种情况：s为正还是为负
	if(s[0]=='-'){//负数
		if(b[0]=='-'&&b.size()>s.size())
			return false;
		if(b[0]=='-'&&s.size()==b.size()){
			c=1;
			while(s[c]==b[c]&&c<s.size())
				c++;
			if(s[c]<b[c]&&c!=s.size())
				return false;
		}//比较右边界
		if(a[0]!='-')
			return false;
		if(a[0]=='-'&&a.size()<s.size())
			return false;
		if(a[0]=='-'&&s.size()==a.size()){
			c=1;
			while(s[c]==a[c]&&c<s.size())
				c++;
			if(s[c]>a[c]&&c!=s.size())
				return false;
		}//左边界
	}
	else if(s[0]!='-'){
		if(b[0]=='-')
			return false;
		if(b[0]!='-'&&s.size()==b.size()){
			c=0;
			while(s[c]==b[c]&&c<s.size())
				c++;
			if(s[c]>b[c]&&c!=s.size())
				return false;
		}
		if(a[0]!='-'&&s.size()==a.size()){
			c=0;
			while(s[c]==a[c]&&c<s.size())
				c++;
			if(s[c]<a[c]&&c!=s.size())
				return false;
		}
	}//正数情况
	return true;//没有超出边界
}//具体比较好理解不再赘述
int main(){
	cin>>a>>b>>t;
	for(int i=1;i<=t;i++){
		cin>>x;
		if((x[0]=='-'&&x[1]=='0')||(x.size()!=1&&x[0]=='0')||(x[0]=='-'&&x.size()==1))
			cout<<"1"<<endl;
            //特判不合法的情况：1.“-0”；2.以“0”开头的数字；3.只有一个“-”
		else if(tai(x))
        //如果合法那么判断是否在[l,r]区间内
			cout<<"0"<<endl;
       	//否则输出2
		else
			cout<<"2"<<endl;
	}
	return 0;
}
```
//此题注意格式以及字符串比较大小等细节
求过~

---

## 作者：VenusM1nT (赞：0)

模拟。首先考虑不合法情况，，一共有 $3$ 种，即前导零，$-0$ 和仅一个负号的情况，判断掉之后直接大力判断是否在区间内即可。

由于 $x$ 数据范围未知，因此要用字符串存，字符串比大小的方式可以见 宇宙总统 那题。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,L,R;
string l,r,s;
bool ful,fur;
bool Cmp(string x,string y)
{
    return x.size()==y.size()?x<y:x.size()<y.size();
}
bool Check(string x,bool fu)
{
    if(fu)
    {
        if(!ful || Cmp(l,x)) return 0;
        else if(fur && Cmp(x,r)) return 0;
    }
    else
    {
        if(!ful && Cmp(x,l)) return 0;
        else if(fur || Cmp(r,x)) return 0;
    }
    return 1; 
}
int main()
{
    cin>>l>>r>>T;
    L=l.size();
    R=r.size();
    if(l[0]=='-')
    {
        ful=1;
        l=l.substr(1,L-1);
    }
    if(r[0]=='-')
    {
        fur=1;
        r=r.substr(1,R-1);
    }
    while(T--)
    {
        cin>>s;
        int len=s.size();
        bool fu=0;
        if(len==1)
        {
            if(s[0]=='-') puts("1");
            else puts(Check(s,fu)?"0":"2");
            continue;
        }
        if(s[0]=='0' || ((s[0]=='-' || s[0]=='0') && s[1]=='0'))
        {
            puts("1");
            continue;
        }
        if(s[0]=='-')
        {
            s=s.substr(1,len-1);
            fu=1;
        }
        puts(Check(s,fu)?"0":"2");
    }
    return 0;
}
```

---

## 作者：meyi (赞：0)

这是一道细节题，注意细节即可AC。

本蒟蒻看到题解中各位神仙用各种方法AC，却没有说到stringstream，特此补充stringstream的解法。

思路见代码注释，上代码：

```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
inline bool cmp(string x,string y){
	if(x.size()!=y.size())return x.size()>y.size();
	int l=x.size()|y.size();
	for(ri i=0;i<l;++i)
		if(x[i]!=y[i])
			return x[i]>y[i];
	return false;
}
/* 	这个函数是用来判断 x>y(x>0,y>0) 或 x<y(x<0,y<0) 的，正好满足我们判断x是
	否在long long范围内的需求 	*/
int t;
long long k,l,r;
string ninf="-9223372036854775808",pinf="9223372036854775807",x;
//ninf为long long的最小值,pinf为long long的最大值
stringstream ss;
main(){
	ios::sync_with_stdio(0);//毫无卵用的优化
	cin.tie(0);
	cout.tie(0);
	cin>>l>>r>>t;
	while(t--){
		ss.clear();//解决stringstream的复用问题
		ss.str("");//解决stringstream的内存问题
		cin>>x;	//输入x
		if(x=="-"||(x[0]==48&&x.size()>1)cout<<"1\n";
        /*	注意x不能仅为一个负号，本蒟蒻亲测，加上x=="-"后 30pts -> 100pts
        	若x为0后面跟数字，也是不合法的	*/
		else if(x[0]=='-'){
        	//处理x为负数时的情况
			if(x[1]==48)cout<<"1\n";	
            //若x为负数，第一个数字是0，则x不合法
			else if(cmp(x,ninf))cout<<"2\n";	
            //若x不在long long范围内,则x必定小于l,因为l在long long范围内
			else{
				ss<<x;	//将x插入stringstream
				ss>>k;	//从stringstream中提取出的数赋值给k
                //其过程相当于将x转化为了long long类型，并赋值给了k
				cout<<(k<l||k>r?"2\n":"0\n");	//依题意输出
			}
		}
		else{
        	//处理x为非负数时的情况
			if(cmp(x,pinf))cout<<"2\n";
            //若x不在long long范围内,则x必定大于r,因为r在long long范围内
			else{
            	//此处同上
				ss<<x;
				ss>>k;
				cout<<(k<l||k>r?"2\n":"0\n");
			}
		}
	}
}
```


---

## 作者：YISMOKIE (赞：0)

一道大模拟题。唯一比较坑的就是会有单独负号（-）的情况，很多人想不到，注意题干：“保证 x 长度至少为 1 且仅由 '0'~'9' 及 '-' 构成”，言外之意有可能出现单独负号。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define ll long long
using namespace std;
ll l,r,T;
char a[100];
inline bool check(int m,int n)
{
	unsigned ll x=0,t=9223372036854775808;//64位长整型（-9223372036854775808~9223372036854775807）的绝对值范围 
	for (int i=m;i<=n;i++) x=x*10+a[i]-'0';
	if (a[0]=='-')
	{
		if (x>t) return false;//负数超出范围 
	}
	else if (x>t-1) return false;//正数超出范围 
	return true;
}
inline void work1(int m,int n)
{
	if ((m>n)||(n-m>0&&a[m]=='0')||(a[0]=='-'&&a[1]=='0'))//第一位字符为负号时出现的三种不合法的情况：1.单独负号 2.数字以0开头 3.-0
	{
		printf("1\n");
		return;
	}
	if ((n>19)||(n==19&&!check(m,n)))//超出64位长整型范围的情况 
	{
		printf("2\n");
		return;
	}
	ll x=0;
	for (int i=m;i<=n;i++) x=x*10+a[i]-'0';
	x=-x;//负数注意加个负号 
	if (x>=l&&x<=r) printf("0\n");
	else printf("2\n");
}
inline void work2(int m,int n)
{
	if (n-m>0&&a[m]=='0')//第一位字符不为负号时出现的一种不合法的情况：1.数字以0开头
	{
		printf("1\n");
		return;
	}
	if ((n>18)||(n==18&&!check(m,n)))//超出64位长整型范围的情况 
	{
		printf("2\n");
		return;
	}
	ll x=0;
	for (int i=m;i<=n;i++) x=x*10+a[i]-'0';
	if (x>=l&&x<=r) printf("0\n");
	else printf("2\n");
}
int main()
{
	cin>>l>>r>>T;
	while(T--)
	{
		scanf("%s",a);
		int len=strlen(a)-1;
		if (a[0]=='-') work1(1,len);//第一位字符为负号 
		else work2(0,len);//第一位字符不为负号 
	}
	return 0;
}
```
谢谢观看

---

## 作者：nuoyanli (赞：0)

**听说有大数，嘻嘻嘻，Java BigInteger来也：**
```java
import java.util.*;
import java.math.*;
class Main{
	static String a;
	static BigInteger l,r;
	static int t;
static int fun() {
        if(a.charAt(0) == '0' && a.length() == 1)
        	 return 0;
        else if(a.charAt(0) == '-' && a.length() == 1) 
        	 return 1;
        else if(a.charAt(0) == '0' && a.length() > 1)
        	 return 1;
        else if(a.charAt(0) == '-' && a.length() >= 1 && a.charAt(1) == '0') 
        	 return 1;
        else{
            BigInteger a1 = new BigInteger(a);
			/* System.out.println("a: "+a+" a1: "+a1); */
            if(a1.compareTo(l)>= 0) 
                if(a1.compareTo(r)<=0) 
                	 return 0;
            return 2;
        }
}
    public static void main(String[] args) {
        Scanner cin = new Scanner (System.in);
        l=cin.nextBigInteger();
        r=cin.nextBigInteger();
        t=cin.nextInt();
        while(t--!= 0){
        a=cin.next();
			/* System.out.println("-->"+a); */
        System.out.println(fun());
    }
  }
}
```



---

## 作者：t162 (赞：0)

Python的int可谓是万能的，因为它在理论上能存储无限大的数据~~（别爆内存就好）~~，所以，它常被用在大数据处理方面。

代码：
```python
s=input().split()#由于input()是读入一整行的，所以这里要split一下，将三个数字分开来。
l=int(s[0])
r=int(s[1])
m=int(s[2])
for a in range(0,m):#在[0,m)范围内循环，相当于循环m次。
    num=input()#从控制台读入一个字符串
    if((len(num)==1)and(num[0]=='-')):#此处有坑:不加判断遇到单独的负号会RE。
        print(1)
        continue
    if(((num[0]=='0')and(not(len(num)==1)))or((num[0]=='-')and(num[1]=='0'))):#判断数字是否合法。
        print(1)
        continue
    if(len(num)>20):#如果数字位数大于MAX_INT64的位数就不必继续进行判断了，一定不在[l,r]范围内的。
        print(2)
        continue
    if((l<=int(num))and(int(num)<=r)):#直接判断是否在范围内。
        print(0)
        continue
    print(2)
        

```

---

## 作者：Edward_Elric (赞：0)

**upd 19.3.3**
刚来就发现第一组数据被卡了。

**w<=18**而不是**w<=19**
### 思路
这不模拟吗。可以用高精？好像是有个黑科技**unsigned long long**

于是我们只需要转化一下，把l，r转化为unsigned long long用另外两个值来存正负。然后模拟规则比较大小就好了.

超出unsigned long long怎么办？扔掉就好了，因为long long存19位，而unsigned long long可以存20位的
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,T;
long long r;
unsigned long long rr,mk1=0,ll,mk2=0;
inline int read()
{
	unsigned long long x=0;
	long long f=1,w=0,tar1=0,tar2=0;
	char ch=getchar();
	while(ch!='\n')
	{
	  if(ch>'9'||ch<'0')
	  {
	    if(ch=='-'&&w==0)
	    f=-1;
	    else tar1=1;
      }
      if(ch<='9'&&ch>='0')
	  {
	    if((w==0&&f==-1&&ch=='0')||(w==1&&x==0&&f!=-1)) 
	    tar1=1;
	    if(w<=18)
	    x=(x<<3)+(x<<1)+ch-'0';
	    if(w>18)
	    tar2=1;
	    w++;	
	  }
	ch=getchar();
    }
    if(f==1)
	{
	  if(mk2==1)
	  tar2=1;
	  if((mk1==0&&x<ll)||(mk2==0&&x>rr))
	  tar2=1;
	}
	else 
	{
		if(mk1==0)
		tar2=1;
		if((mk1==1&&x>ll)||(mk2==1&&x<rr))
		tar2=1;	
	}
	if(w==0)tar1=1;
    if(tar1==0&&tar2==0)return 0;  
    if(tar1==1)return 1;
	if(tar2==1)return 2;
}
int main()
{
	scanf("%lld%lld%lld",&l,&r,&T);
	if(l<0)
	mk1=1,ll=-l;
	else ll=r;
	if(r<0)
	mk2=1,rr=-r;
	else rr=r;
	getchar();
	for(int i=1;i<=T;i++)
	{
		int x=read();
		printf("%d\n",x);
	}
	return 0;
} 
```


---

## 作者：poplpr (赞：0)

看了一下别人的代码，怎么都~~辣么长~~
感觉我**写题解**的机会来了QAQ
解释都在注释里


------------
```cpp
#include<cstdio>
#include<iostream>
#include<cctype>
#include<cmath>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<vector>
#include<list>
#include<queue>
#include<stack>
#include<deque>
#include<algorithm>
#include<map>
#include<set>
using namespace std;
typedef long long LL;

LL l,r,x;
char s[55];

bool inlaw(int len){
    if(s[0] == '-'){//判断第一位是否为'-' 
        if(s[1] <= '0' || s[1] > '9')return false;//然后判断第二位，第二位只能为1~9 
        for(int i=2;i<len;i++){
            if(!isdigit(s[i]))return false;//其他位为0~9 
        }
    }
    else {//第一位不为'-' 
        if(s[0] == '0' && len > 1)return false;//判断一下是否有0开头的情况，如：012431 
        for(int i=0;i<len;i++){
            if(!isdigit(s[i]))return false;//其他位0~9 
        }
    }
    return true;
}

int main(){
    int T;
    scanf("%lld%lld%d\n",&l,&r,&T);
    while(T--){
        scanf("%s",s);
        int len = strlen(s);
        if(!inlaw(len)){printf("1\n");continue;}//若数字不合法直接输出1 
        sscanf(s,"%lld",&x);//此时数字合法，判断它是否在[l,r]中 
        if(x >= l && x <= r)printf("0\n");//在[l,r]中输出0 
        else printf("2\n");//不在[l,r]中输出2 
    }
    return 0;
}
```


---


# 【深基17.例5】木材仓库

## 题目描述

博艾市有一个木材仓库，里面可以存储各种长度的木材，但是保证没有两个木材的长度是相同的。作为仓库负责人，你有时候会进货，有时候会出货，因此需要维护这个库存。有不超过 $10^5$ 条的操作：

- 进货，格式 `1 Length`：在仓库中放入一根长度为 $Length$（不超过 $10^9$）的木材。如果已经有相同长度的木材那么输出 `Already Exist`。
- 出货，格式 `2 Length`：从仓库中取出长度为 $Length$ 的木材。如果没有刚好长度的木材，取出仓库中存在的和要求长度最接近的木材。如果有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的，输出 `Empty`。

## 样例 #1

### 输入

```
7
1 1
1 5
1 3
2 3
2 3
2 3
2 3```

### 输出

```
3
1
5
Empty
```

# 题解

## 作者：vegetable_king (赞：130)

在[博客](https://yjh965.github.io/post/mu-cai-cang-ku-ti-jie/)食用更佳。

我看了一下题解区，大多数人用的都是 `map` 和 `vector`，还有一个用平衡树做的，没有人用 `set`，我就写了这篇题解。

# 思路

## 为什么要用 set？
我真的搞不懂为啥没有人用 `set`，题目里的这句话就让我第一时间想到了 `set`：

如果已经有相同长度的木材那么输出 `Already Exist`。


## 我们要用到的函数
我觉得这道题用 `set` 真是再合适不过了。

`set` 里面的 `insert(x)` 函数其实是有返回值的，会返回一个这样的奇怪的东西：`pair<set<int>::iterator,bool>`。

返回的这个 `pair` 到底是什么意思呢？

这个 `pair` 的第二项是一个 `bool` 类型的东西，代表插入是否成功。（意思就是只有集合里没有 `x` 的时候才能插入成功），第一项是一个迭代器，如果插入成功的话，它会返回 `x` 在集合里的位置，我们可以这样：
```cpp
set<int> s;
set<int>::iterator p = s.insert(x).first;
```
以后用 `*p` 就可以得到 `x` 啦！

检测是否有相同长度的木材：

`if (!s.insert(t).second) cout << "Already Exist\n";`

一行直接解决问题！~~STL大法好~~

这是啥意思呢？如果有相同长度的木材，插入就会失败，`pair` 的第二项就会返回 `false`，如果没有，`!s.insert(t).second` 这个语句就直接实现了插入的目的，这就是我说 `set` 更方便的原因。

`set.empty()` 可以直接返回集合是否为空。

虽然 `set` 也有 `lower_bound()` 和 `upper_bound()`，但是，

`set.lower_bound(x)` 是返回第一个大于等于 `x` 的位置，

而 `set.upper_bound(x)` 是返回第一个大于 `x` 的位置，

`set.find(x)` 会返回第一个 `x` 的位置。如果没有 `x`，则会返回 `set.end()`。

`set.erase(iterator)`，删除定位器 `iterator` 指向的值

`set.erase(first,second)`，删除定位器 `first` 和 `second` 之间的值

`set.erase(key_value)`，删除键值 `key_value` 的值

结合刚刚讲的这些函数，我们可以写出代码的第二部分——出货。（`s` 已经被定义为 `set<int>`）

```cpp
if (s.find(t) != s.end()) cout << t, s.erase(s.find(t)); // 找得到
else { // 找不到
	lwb = l2 = l3 = s.lower_bound(t);
	if (lwb == s.begin()) cout << *lwb, s.erase(lwb); // 特殊情况1，如果在最开始
	else if (lwb == s.end()) cout << *(-- l3), s.erase(l3); // 特殊情况2，如果在末尾
	else if (*lwb - t < t - *(-- l2)) cout << *(l3), s.erase(l3); // 选比较长的
	else cout << *(-- l3), s.erase(l3); // 选比较短的
}
cout << endl;
```
那么多方便的函数，果然还是 STL 大法好啊！还不快去用起来？
# 代码
```cpp
#include <iostream>
#include <set> 

using namespace std;

int n, op, t;
set<int>::iterator lwb, l2, l3;
set<int> s;
int main(){
	cin >> n;
	for (int i = 1;i <= n;i ++){
		cin >> op >> t;
		if (op == 1){
			if (!s.insert(t).second) cout << "Already Exist\n";
		}
		else {
			if (s.empty()){
				cout << "Empty\n";
				continue;
			}
			if (s.find(t) != s.end()) cout << t, s.erase(s.find(t));
			else {
				lwb = l2 = l3 = s.lower_bound(t);
				if (lwb == s.begin()) cout << *lwb, s.erase(lwb);
				else if (lwb == s.end()) cout << *(-- l3), s.erase(l3);
				else if (*lwb - t < t - *(-- l2)) cout << *(l3), s.erase(l3);
				else cout << *(-- l3), s.erase(l3);
			}
			cout << endl;
		}
	}
}
```
32 行直接搞定，大概是最短的代码了。

本文部分内容选自[C++中set用法详解](https://blog.csdn.net/byn12345/article/details/79523516)，作者[byn12345](https://blog.csdn.net/byn12345)，如果想了解 `set` 的更多使用方法，这篇文章值得一看。

---

## 作者：YuJieSong (赞：83)

看了一下有100000条操作

感觉还是要logn的操作速度才行

第一反应就想到了map

存入和取出都十分方便

而对于不存在又要取出长度相近的

本人的方法是利用map的指针操作

先“假装”存一下该不存在的木头

然后指针定位该木头的位置

于是it++就得到了比它长的下一根木头的位置

it--就得到了比它短的下一根木头的位置

两者比较一下，然后取出长度相近的即可

最后记得erase之前“假装”存的那根不存在的木头

平均耗时100ms，如果快读或者scanf和printf的话也许会更快

~~但是能过不就行了嘛哈哈哈~~

```cpp
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

int main()
{
    map<int,int> m;
    int i,j,n,x,y;
    cin >> n;
    for (i=0; i<n; i++) {
        cin >> x >> y;
        if (x == 1) {
            if (m.count(y)) cout << "Already Exist" << endl;
            else m[y] = 1;
        }
        else {
            if(m.empty()) cout << "Empty" << endl;
            else if (m.count(y)) {
                m.erase(y);
                cout << y << endl;
            }
            else {
                m[y] = 1; // 假装存一下该木头
                auto it = m.find(y); // 指针定位
                auto it2 = it;
                it++; 
                // 几种特判
                if (it2 == m.begin()) { // 没有比它短的
                    cout << it->first << endl;
                    m.erase(it);
                }
                else if (it == m.end()) { // 没有比它长的
                    cout << (--it2)->first << endl;
                    m.erase(it2);
                }
                // 长度比较
                else if (y-(--it2)->first > it->first-y) {
                    cout << it->first << endl;
                    m.erase(it);
                }
                else {
                    cout << it2->first << endl;
                    m.erase(it2);
                }
                m.erase(y); // 删掉假装存的木头
            }
        }
    }
    return 0;
}
```


---

## 作者：wangjinbo (赞：17)

这道水题可以用vector过，但是当作一道平衡树的练手题也是很不错的

平衡树不知道的右转[P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

对于1操作，则向树中插入x，注意与P3369不同的一点是如果有重复的就不再重复插入。

对于2操作，先在树中查询x 如果找到则直接输出并且删除x，否则查询前驱后继，取差的绝对值小的输出并删除。具体实现见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tree{
	int val,pri,lson,rson,fa,cnt,size;
	#define v(x) a[x].val
	#define p(x) a[x].pri
	#define l(x) a[x].lson
	#define r(x) a[x].rson
	#define fa(x) a[x].fa
	#define c(x) a[x].cnt
	#define s(x) a[x].size
}a[100010];
int cnt,root;
void upt(int k)
{
	s(k)=s(l(k))+s(r(k))+c(k);
}
void zig(int &k)
{
	int y=l(k);
	l(k)=r(y);
	r(y)=k;
	s(y)=s(k);
	upt(k);
	k=y;
}
void zag(int &k)
{
	int y=r(k);
	r(k)=l(y);
	l(y)=k;
	s(y)=s(k);
	upt(k);
	k=y;
}
void insert(int &x,int key)
{
	if(!x){
		x=++cnt;
		v(x)=key;
		p(x)=rand();
		c(x)=s(x)=1;
		return;
	}
	if(key==v(x)){
		printf("Already Exist\n");
		return;
	}
	s(x)++;
	if(key<v(x)){
		insert(l(x),key);
		if(p(l(x))<p(x))zig(x);
	}
	else{
		insert(r(x),key);
		if(p(r(x))<p(x))zag(x);
	}
}
void Delete(int &x,int key)
{
	if(v(x)==key){
		if(c(x)>1){
			c(x)--;s(x)--;
		}
		else if(!l(x)||!r(x)){
			x=l(x)+r(x);
		}
		else if(p(l(x))<p(r(x))){
			zig(x);Delete(x,key);
		}
		else{
			zag(x);Delete(x,key);
		}
		return;
	}
	s(x)--;
	if(key<v(x))Delete(l(x),key);
	else Delete(r(x),key);
}
int queryk(int key)
{
	int res=0,x=root;
	while(x){
		if(key==v(x))return res+s(l(x))+1;
		if(key<v(x)){
			x=l(x);
		}
		else{
			res+=s(l(x))+c(x);x=r(x);
		}
	}
}
int querykth(int k)
{
	int x=root;
	while(x){
		if(s(l(x))<k&&s(l(x))+c(x)>=k)return v(x);
		else if(s(l(x))>=k)x=l(x);
		else{
			k-=s(l(x))+c(x);
			x=r(x);
		}
	}
}
int querypre(int key)
{
	int x=root,res=-0x7fffffff;
	while(x){
		if(v(x)<key){
			res=v(x);x=r(x);
		}
		else x=l(x);
	}
	return res;
}
int querypost(int key)
{
	int x=root,res=-0x7fffffff;
	while(x){
		if(v(x)>key){
			res=v(x);x=l(x);
		}
		else x=r(x);
	}
	return res;
}
int find(int key)
{
	int x=root;
	while(x)
	{
		if(v(x)==key)return v(x);
		else if(v(x)<key)x=r(x);
		else x=l(x);
	}
	return 0;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int type,x;
		scanf("%d %d",&type,&x);
		if(type==1){
			insert(root,x);
		}
		if(type==2){
			int ans=find(x);
			if(ans){//找到则直接输出
				cout<<ans<<endl;Delete(root,ans);continue;
			}
			int l=querypre(x),r=querypost(x);//查询前驱后继
			if(l!=-2147483647&&(x-l<=r-x||r==-2147483647)){
				Delete(root,l);printf("%d\n",l);
			}
			else if(r!=-2147483647){
				Delete(root,r);printf("%d\n",r);
			}
			else{//无前驱且无后继则说明仓库已空，直接输出Empty
				printf("Empty\n");
			}
		}
	}
	return 0;
}
```


---

## 作者：Graphcity (赞：6)

其实，这道题可以用平衡树做。（我是用的无旋 Treap）

这棵平衡树需要支持这些操作：

1. 插入一个数

2. 删除一个数

3. 查找一个数的前驱（前驱定义为不大于这个数的数）

4. 查找一个数的后继（后继定义为不小于这个数的数）

我们再来分析一下题目：

对于进货操作，

我们首先要查找这个数 $x$ 的前驱是否等于 $x$ ，如果等于，则输出 `Already Exist` ，插入操作取消。如果不等于，则插入 $x$ 。

对于出货操作，

我们可以使用一个变量 $Alive$ , 记录树中还剩的结点数。如果 $Alive=0$ ，则输出 `Empty` ，删除操作取消。如果 $Alive ≠ 0$ , 则先把 $Alive$ 减去 1 ，然后通过比较这个数的前驱和后继来决定删除哪个数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

struct Node
{
	int val,key;
	int l,r;
	int size;
};
Node k[100001];
int n,root,Index;

inline void update(int x)//计算子树大小 
{
	k[x].size=k[k[x].l].size+k[k[x].r].size+1;
}

inline int newnode(int cnt)//新建结点 
{
	++Index;
	k[Index].val=cnt;
	k[Index].key=rand();
	k[Index].size=1;
	return Index;
}

void spilt(int now,int cnt,int &x,int &y)//分裂 
{
	if(!now) x=y=0;
	else
	{
		if(k[now].val<=cnt)
		{
			x=now;
			spilt(k[now].r,cnt,k[now].r,y);
		}
		else
		{
			y=now;
			spilt(k[now].l,cnt,x,k[now].l);
		}
		update(now);
	}
}

int merge(int x,int y)//合并 
{
	if(!x || !y) return x+y;
	else
	{
		if(k[x].key>k[y].key)
		{
			k[x].r=merge(k[x].r,y);
			update(x);
			return x;
		}
		else
		{
			k[y].l=merge(x,k[y].l);
			update(y);
			return y;
		}
	}
}

void Insert(int x)//插入 
{
	int a,b;
	spilt(root,k[x].val,a,b);
	root=merge(merge(a,x),b);
}

void Delete(int x)//删除 
{
	int a,b,c;
	spilt(root,x,a,c);
	spilt(a,x-1,a,b);
	b=merge(k[b].l,k[b].r);
	root=merge(merge(a,b),c);
}

void pre(int x,int &y)//x的前驱
{
	int a,b,now;
	spilt(root,x,a,b);
	now=a;
	while(k[now].r)
		now=k[now].r;
	y=now;
	root=merge(a,b);
}

void nxt(int x,int &y)//x的后继 
{
	int a,b,now;
	spilt(root,x-1,a,b);
	now=b;
	while(k[now].l)
		now=k[now].l;
	y=now;
	root=merge(a,b);
}

int main()
{
	int Alive=0;
	scanf("%d",&n);
	for(register int i=1;i<=n;++i)
	{
		int typ,a;
		scanf("%d%d",&typ,&a);
		if(typ==1)//进货操作 
		{
			int b;
			pre(a,b);
			if(a==k[b].val) printf("Already Exist\n");//如果树中已经有这个数了 
			else//如果树中还没有这个数 
			{
				Insert(newnode(a));//那么插入这个数 
				++Alive;//树中结点数 +1 
			}
		}
		if(typ==2)//出货操作 
		{
			int b,c;
			if(!Alive) printf("Empty\n");//如果树为空 
			else//如果树不为空 
			{
				int Ans;//要删除的数 
				pre(a,b);
				nxt(a,c);
				if(!b || !c)//如果一个数没有前驱或者没有后继 
				{
					if(!b) Ans=k[c].val;//如果没有前驱，删除后继 
					else Ans=k[b].val;//如果没有后继，删除前驱 
				}
				else//如果一个数前驱和后继都有了 
				{
					if(a-k[b].val<=k[c].val-a) Ans=k[b].val;
					else Ans=k[c].val;//比较前驱和后继与这个数的距离 
				}
				printf("%d\n",Ans);
				Delete(Ans);//删除这个数 
				--Alive;//树中结点数 -1  
			}
		}
	}
    return 0;
}

```


---


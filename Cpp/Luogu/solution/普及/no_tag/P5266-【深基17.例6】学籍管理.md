# 【深基17.例6】学籍管理

## 题目描述

您要设计一个学籍管理系统，最开始学籍数据是空的，然后该系统能够支持下面的操作（不超过 $10^5$ 条）：

- 插入与修改，格式`1 NAME SCORE`：在系统中插入姓名为 NAME(由字母和数字组成不超过 20 个字符的字符串，区分大小写) ，分数为 $\texttt{SCORE}$（$0<\texttt{SCORE}<2^{31}$） 的学生。如果已经有同名的学生则更新这名学生的成绩为 SCORE。如果成功插入或者修改则输出`OK`。
- 查询，格式`2 NAME`：在系统中查询姓名为 NAME 的学生的成绩。如果没能找到这名学生则输出`Not found`，否则输出该生成绩。
- 删除，格式`3 NAME`：在系统中删除姓名为 NAME 的学生信息。如果没能找到这名学生则输出`Not found`，否则输出`Deleted successfully`。
- 汇总，格式`4`：输出系统中学生数量。

## 样例 #1

### 输入

```
5
1 lxl 10
2 lxl
3 lxl
2 lxl
4```

### 输出

```
OK
10
Deleted successfully
Not found
0
```

# 题解

## 作者：yangrunze (赞：141)

众所周知，**map**是个好东西

可能好多萌新们都在好奇map是个啥，那这里，我先介绍一下map（如果你懂map的基本操作，请跳过这部分）

政治老师说：研究问题要分三方面：**是什么、为什么、怎么做**，那咱就从这三个方面说说map的操作吧！



------------

# 1.什么是map?

map是一种描述“**对应关系**”的存储结构，就像**函数**一样

如果你没学函数，你也可以把map理解成**下标是任何类型的数组**

for example:
```cpp
map <string ,int> a;  //定义map
```
这就是定义了一个**string到int对应的map**,也就是说，它的“**自变量**”为**string类型**，“**函数值**”为**int类型**，**对于每一个string，就有一个int类型的值与之对应**

然后就可以往map里面塞东西了，注意它的“**下标**”是一个**string**
```cpp
a["wyxniubi"]=1;  //赋值
cout<<a["wyxniubi"]; //调用，此时输出1
```
还是拿函数的例子：**此时的"自变量x"="wyxniubi"，"函数值y"=1**



------------

# 2.为啥要用map?

这个题通过审题可以发现，**每一个string的学号对应一个int的分数**，这样的话，这题简直就是为map量身定制的啊

其实很多字符串题中map都能派上用场。说句题外话：**当数据范围非常大时，map也可以当桶排序中的“桶”来用**，效果也是棒呆了

当然，map也是有缺点的，**单次操作它的时间复杂度是O（lg n）**，有时候会TLE


------------
# 3.怎样用map?

除了刚才介绍的定义和赋值，像string一样，map也有好多**好用的成员函数**，这里先教大家几个简单的、实用的、这个题能用到的：

|  |  |
| :----------: | :----------: |
|  a.count(x)|判断x为下标的元素是不是在a中，是就返回1，不是就返回0  |
|  a.erase(x)|删除a中x为下标的元素  |
|  a.size()|返回a中元素的个数  |
|  a.clear()|清空a  |

这些成员函数都不难，如果不理解，待会看看代码就能懂了

------------
map介绍完了，接下来就是愉快的编代码时间了。因为**分4种操作**，我们可以用**switch语句**来编写，注意**一定要在最后加break，一定要在最后加break，一定要在最后加break**，重要的事情说三遍，其它的就是怎么用map的那些成员函数了

# Code:

```cpp
#include<iostream>
#include<cstring>
#include<map>//要用map嘛......你懂的
using namespace std;
map <string,int> a;   //定义一个string（姓名）到int（分数）的map
int main(){
    int n;
    cin>>n; //n条操作
    for(int i=1;i<=n;i++){
    	int op; //操作种类1234
    	string name; //学生姓名
    	cin>>op; //输入操作种类
    	if(op!=4)  //如果不是操作4就输入学生名字
    	cin>>name;
    	switch(op){  //开始了！
    		case 1:  //操作1：加入或修改学生
    		int score;  //这个操作需要输入分数
    		cin>>score;
    		a[name]=score; //map的对应关系，把名字和分数对应起来
    		cout<<"OK\n";   //根据题目要求输出OK
    		break;   //别忘了加break！！！
    		case 2: //操作2：查询学生
    		if(a.count(name)) //如果找得到
    		cout<<a[name]<<endl; //输出对应的分数
    		else cout<<"Not found\n"; //否则"Not Found"
    		break;   //别忘了加break！！！
    		case 3:  //操作3：删除学生
    		if(a.count(name)){ //如果找得到
    		a.erase(name); //那就删了它
			cout<<"Deleted successfully\n"; //成功删除
    	    }
    		else cout<<"Not found\n"; //否则"Not Found" 
    		break;  //别忘了加break！！！
    		case 4:  //操作4：学生人数
    		cout<<a.size()<<endl; //输出元素个数就好啦
		}
	}
	return 0;  //这个不用解释了吧
}


```
~~静待红名~~


---

## 作者：1379号监听员 (赞：15)

# P5266 题解

（没错，这题没有吐槽）

---

## 题目大意

建立一个学籍管理系统，每个学生都有且仅有一个成绩，支持插入，修改，查询，删除，汇总五种操作。

## 思路

看到“有且仅有一个”——

这不就是映射吗。。。

### 映射是什么

> 设A、B是两个非空集合，如果存在一个法则f，使得对A中的每个元素a，按法则f，在B中有唯一确定的元素b与之对应，则称f为从A到B的映射，记作f:A→B。

> 其中，b称为元素a在映射f下的象，记作:b=f(a); a称为b关于映射f的原象。集合A中所有元素的象的集合称为映射f的值域，记作f(A)。

> 注意: (1)对于A中不同的元素，在B中不一定有不同的象; (2)B中每个元素都有原象(即满射)，且集合A中不同的元素在集合B中都有不同的象(即单射)，则称映射f建立了集合A和集合B之间的一个一一对应关系，也称f是A到B上的一一映射（双射）。

> 映射，或者射影，在数学及相关的领域还用于定义函数。函数是从非空数集到非空数集的映射，而且只能是一对一映射或多对一映射。

> 在很多特定的数学领域中，这个术语用来描述具有与该领域相关联的特定性质的函数，例如，在拓扑学中的连续函数，线性代数中的线性变换等等。

> 如果将函数定义中两个集合从非空集合扩展到任意元素的集合(不限于数)，我们可以得到映射的概念:

> 映射是数学中描述了两个集合元素之间一种特殊的对应关系的一个术语。


当然了，你们现在并不需要了解这么多。。。你们只要知道映射是一种一一对应的关系就行了。

为了方便，映射中的第一项通常称为键(key)，第二项则称为值(value)。

这里，我们让学生的名字成为键，则学生的成绩则为值。

### STL中的map

STL中的map以一种效率较高的形式（红黑树）实现了映射。（C++11又提供了一种更为先进的unordered_map，基于哈希表，拥有$O(1)$的时间复杂度。因此这里使用map讲解，但代码中使用的是unordered_map，两种容器操作相同）

#### map的创建

```cpp
map<A,B> mp;
```

即可创建一个键类型为A，值类型为B的map。

#### map的插入与修改

```cpp
mp.insert(make_pair(a,b));
```

即可插入一个对象（要求a的类型为A，b的类型为B）。

此外，map还提供一种简易的插入与修改方法

```cpp
mp[a]=b;
```

此时，如果mp中a已存在，则会将键为a的项的值设为b；否则，则会插入一个键为a，值为b的新项。

#### map的查询

```cpp
mp[a];
```
查询键为a的项的值。

#### map的删除

```cpp
mp.erase(mp.find(a));
```

将键为a的项删去。

#### 查看map的大小

```cpp
mp.size()
```

与其它STL容器相同，map也可通过size查看大小。

#### 查看map中特定项的个数

```cpp
mp.count(a)
```

查看mp中键为a的项的个数（因为只能有一个或没有，这个函数的返回值只能为1或0）。

## 代码

```cpp
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<string>
using namespace std;
unordered_map<string,int> mp;
int n;
int main()
{
	ios::sync_with_stdio(false); //流式I/O优化
	cin.tie(0); //同上
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a; //读入操作
		if(a==1)
		{
			string b;
			int c;
			cin>>b>>c;
			mp[b]=c; //插入与修改
			cout<<"OK"<<endl;
		}
		else if(a==2)
		{
			string b;
			cin>>b;
			if(mp.count(b)==0) //如果没有学生b
			{
				cout<<"Not found"<<endl;
				continue;
			 } 
			cout<<mp[b]<<endl; //否则输出b的成绩
		}
		else if(a==3)
		{
			string b;
			cin>>b;
			if(mp.count(b)==0) //如果没有学生b
			{
				cout<<"Not found"<<endl;
				continue;
			 } 
			mp.erase(mp.find(b)); //否则删除b
			cout<<"Deleted successfully"<<endl;
		}
		else if(a==4)
		{
			cout<<mp.size()<<endl; //输出mp的大小
		}
	}
	return 0;
}
```


---

## 作者：EDqwq (赞：9)

### 这是本蒟蒻的第二篇题解，如有不妥之处请大家**多多包涵**

看了看大家的题解，似乎都是用map，没错，map是一个非常好用的东西，但是我用**结构体**。~~别打我~~

**为什么用结构体呢？**  

1. 结构体可以用一个数组来表示很多种数据，可以为任意类型。也就是说：**在一个数组中，可以使用不同的数据类型**，非常方便。  

1. 结构体定义非常简单，用法非常简单，容易上手，适合~~像我这样的~~新手使用。

好了，回到本题，我们整理一下思路：

1. 由于本题最多输入100000条数据，非常多，可以尝试使用以下三种优化：

	1. O2优化。可以使用洛谷自带版，也可以手动在c++里开启。
    
    1. 快读。题目需要输入**字符串**和**阿拉伯数字**，但是快读仅仅支持数字，所以我们可以在输入数字之处使用快读。这里不建议使用，因为洛谷自带O2只需要勾选一下就可以使用，而快读要打代码，很麻烦。但是快读是必须掌握的，下面附快读代码：
    ```
    int read() {
   	int w = 1, q = 0;
   	char ch = ' ';
   	while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
   	if(ch == '-') w = -1, ch = getchar();
   	while(ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
    return w * q;
	}
	```
    	有需要的朋友可以自己背下来，不要 Ctrl + v ，因为考试的时候不是用自己的电脑。

1. 我们可以开一个结构体，存储成绩与名字。成绩使用 int 类型，名字使用 string 类型。

1. 循环输入判断是哪一种操作，并进行相应的操作，但是要注意的是，删除操作一定不要用普通的移位删除（后一位移上来覆盖原来的数据）因为这样太慢了，由于本题不追究顺序，我们可以用数组最后一个数据来替换要删除的数据，并且将数据数减掉1，最后注意输出的格式就好了。

1. 养成好习惯，记得 return 0。

好了，该说的都说了，更详细的在代码里面，下面上代码：
（本人是开 O2 所以没有快读）

```
#include<bits/stdc++.h>//万能头文件不解释

using namespace std;

int n;//要输入的数据数
int num_stu;//现在的学生数，初始为0

struct node{//定义结构体，如果你不愿意，用两个数组也行，只不过麻烦
	string name;
	int mark;
}a[100005];//最大100000组数据，记得再开大一点

int main(){
	cin>>n;//输入
	for(int i = 1;i <= n;i ++){//有n组数据
		int num;//现在的操作编号
		string name_tmp;//输入的名字
		int mark_tmp;//输入的成绩
		cin>>num;
		if(num == 1){//添加或更改
			cin>>name_tmp;
			cin>>mark_tmp;
			int flag = false;//判断是添加还是更改
			for(int j = 1;j <= num_stu;j ++)if(a[j].name == name_tmp){//如果当前有该名字
				a[j].mark = mark_tmp;//将成绩改为输入的成绩
				cout<<"OK";
				if(i != n)cout<<endl;//这个不要也行
				flag = true;//标记是更改
				break;
			}
			if(!flag){//如果不是更改
				num_stu ++;//添加学生
				a[num_stu].name = name_tmp;
				a[num_stu].mark = mark_tmp;
				cout<<"OK";
				if(i != n)cout<<endl;
			}
		}
		if(num == 2){//第二种操作
			cin>>name_tmp;//要查询的学生名字
			int flag = false;//判断有没有该学生
			for(int j = 1;j <= num_stu;j ++)if(a[j].name == name_tmp){//如果找到了话
				cout<<a[j].mark;//输出该学生的成绩
				if(i != n)cout<<endl;
				flag = true;//标记
				break;
			}
			if(!flag){//如果没找到
				cout<<"Not found";//输出没找到
				if(i != n)cout<<endl;
			}
		}
		if(num == 3){//第三种操作
			cin>>name_tmp;//输入名字
			int flag = false;//标记是否找到
			for(int j = 1;j <= num_stu;j ++)if(a[j].name == name_tmp){//如果找到
				flag = true;//标记
				a[j].name = a[num_stu].name;//用最后一个替换
				a[j].mark = a[num_stu].mark;
				num_stu --;//学生数减一
				cout<<"Deleted successfully";
				if(i != n)cout<<endl;
				break;
			}
			if(!flag){//如果没找到
				cout<<"Not found";
				if(i != n)cout<<endl;
			}
		}
		if(num == 4){//第四种操作
			cout<<num_stu;//直接输出学生数即可
			if(i != n)cout<<endl;
		}
	}
	return 0;//养成好习惯，一起 return 0
}
```
好了，这篇题解到此结束，~~撒花~~

### 这是本蒟蒻的第二篇题解，管理大大求过

~~溜了溜了~~

---

## 作者：linponess (赞：6)

题目要求对字符串进行存储、修改、查询、删除、统计数目等操作，考虑到直接对字符串进行上述操作在代码实现和时间复杂度上都不够优，从而想到利用哈希建立映射关系，对哈希函数的返回值进行操作。

**代码：**
```
#include<cstdio>
#include<cstring>
using namespace std;
int n,sc,k,num,haxh;//n为操作总数，sc为学生分数，k为操作格式，num记录系统中的人数，haxh用于存储字符串hash值。 
long long base=173,mod=19260817;//哈希函数的基数和模数。 
char s[114];//学生姓名。 
int b[30000000];//利用数组进行操作。 
long long hs(char str[])
{
	long long len=strlen(str),ans=0;
	for(int i=0;i<len;i++)
	ans=(ans*base+(long long)str[i])%mod;
	return ans;
}//通过哈希函数将字符串映射到 int 类型上。 
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&k);
		if(k<4)
		scanf("%s",s);//前三种操作需要读入学生姓名。 
		haxh=hs(s);//计算学生姓名的hash值。 
		if(k==1)
		{
			scanf("%d",&sc);
			if(b[haxh]<=0) 
			num++;//分数小于等于0说明系统中没有该学生，学生总数加一。
			b[haxh]=sc;
			printf("OK\n");
		}
		else if(k==2)
		{
			if(b[haxh]>0)//判断系统中有无该学生的信息。 
			printf("%d\n",b[haxh]);
			else printf("Not found\n");
		}
		else if(k==3)
		{
			if(b[haxh]>0)
			{
				b[haxh]=0;
				num--;//删除该生信息。 
				printf("Deleted successfully\n");
			}
			else printf("Not found\n");
		}
		else printf("%d\n",num);
	}
	return 0;
}
```

当然也可以用 $STL$ 中的 $map$ 来建立映射关系，但在时间常数上要比手打哈希略大。

![](https://cdn.luogu.com.cn/upload/image_hosting/g53mtrxe.png?x-oss-process=image/resize,m_lfit,h_1700,w_2205)

上面三次提交使用的是手打哈希，下面两次提交使用的是 $map$ ，可以明显看出 $map$ 比手打哈希要慢。

**代码：**
```
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
using namespace std;
int n,sc,k,num;
char s[114];
map<string,int>sys;
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&k);
		if(k<4)
		scanf("%s",s);
		if(k==1)
		{
			scanf("%d",&sc);
			if(sys[s]<=0)
			num++;
			sys[s]=sc;
			printf("OK\n");
		}
		else if(k==2)
		{
			if(sys[s]>0)
			printf("%d\n",sys[s]);
			else printf("Not found\n");
		}
		else if(k==3)
		{
			if(sys[s]>0)
			{
				sys[s]=0;
				num--;
				printf("Deleted successfully\n");
			}
			else printf("Not found\n");
		}
		else printf("%d\n",num);
	}
	return 0;
}
```


---

## 作者：时律 (赞：5)

~~在看了一遍所有题解发现没有 pbds 的时候，我十分激动。又可以水题解啦！~~

**__gnu_pbds**，简称 pbds。它是一个类似 STL 的模板库，封装了四种数据结构。

但是在使用前，你还得加这么几行：

```cpp
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>//用tree
#include<ext/pb_ds/hash_policy.hpp>//用hash
#include<ext/pb_ds/trie_policy.hpp>//用trie
#include<ext/pb_ds/priority_queue.hpp>//用priority_queue
using namespace __gnu_pbds;
```

其中的一种叫做 hash 。

hash 是这么两个数据结构：`gp_hash_table` 与 `cc_hash_table`。

这两个数据结构几乎与 `map` 相同。

`map` 一次操作是 $O(logN)$ 的。而上面两个是 $O(1)$ 的。

~~但是，在笔者写本题时，发现上面两个好像没有 `count` 函数。于是只能用 `find` 函数~~

`find` 函数的用法：`map1.find(s)`。

效果：查找 `key` 为 $s$ 的数据，找到返回对应的迭代器，找不到返回 `map1.end()`。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
gp_hash_table<string,int> x; //存储学生的分数
gp_hash_table<string,bool> y; //存储学生是否存在
int main()
{
	int m;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int s1,s2;
		string s;
		scanf("%d",&s1);
		if(s1==4)
			printf("%d",y.size());
		else
			cin>>s;
		if(s1==1)
		{
			scanf("%d",&s2);
			x[s]=s2;
			y[s]=1;
			printf("OK");
		}
		if(s1==2)
			if(y.find(s)!=y.end()) //也就是学生存在（若用 y[s]==1 的话会造成 y 增加 s 这个元素）
				printf("%d",x[s]);
			else
				printf("Not found"); 
		if(s1==3)
			if(y.find(s)!=y.end())
				y.erase(s),printf("Deleted successfully");
			else
				printf("Not found");
		putchar('\n');
	}
}
```

---

## 作者：DreamFox (赞：2)

本题可以用$map$映射来储存每个学生的成绩和姓名。

查询成绩时，由于成绩不可能为$0$，我们就可以用成绩是否为$0$来判断这位学生是否存在；删除学生也是这样，如果成绩不为$0$那么人数减$1$,并把这位学生的成绩清$0$。

至于总人数，我们也可以用成绩是否为$0$来判断，如果是$0$那么人数加$1$，否则修改成绩。

$AC$ $Code$
```
#include<bits/stdc++.h>
using namespace std;
map<string,int>a;
int n,c,d,sum;
string b;
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>c;
		if(c==1)
		{
			cin>>b>>d;
			if(a[b]==0)++sum;
			a[b]=d;
			cout<<"OK\n";
		}
		if(c==2)
		{
			cin>>b;
			if(a[b]==0)cout<<"Not found\n";
			else cout<<a[b]<<endl;
		}
		if(c==3)
		{
			cin>>b;
			if(a[b]==0)cout<<"Not found\n";
			else cout<<"Deleted successfully\n",--sum,a[b]=0;
		}
		if(c==4)cout<<sum<<endl;
	}
	return 0;
}
```


---

## 作者：KazamiHina (赞：2)

这题可以开个 $map$ 映射

用来保存学生的名字和分数

因为分数不可能为 $0$

所以就可以以 $0$ 来判断这个人是不是在学籍里

详情见代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <map>
#include <cmath>

using namespace std;

map <string , int > vis;//开一个map容器
int flag;
int n,now=0,score;//now 表示学籍中的人数，score表示这个人的分数
string name;

int main()
{
	
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>flag;
		
		if(flag==1)//如果是插入操作
		{	
			cin>>name;
			cin>>score;
			if(vis[name]==0)now++;//如果没有插入过人数就加一
			vis[name]=score;//这个人插入学籍
			cout<<"OK\n";//输出OK
		}
		
		if(flag==2)//如果是查询分数
		{
			cin>>name;
			if(vis[name]==0)cout<<"Not found\n";//如果不在学籍里就输出Not found
			else cout<<vis[name]<<endl;//否则输出他的分数
		}
		
		if(flag==3)//如果是删除
		{
			cin>>name;
			if(vis[name]==0)cout<<"Not found\n";//如果不在学籍里就输出Not found
			else //否则可以删除
			{
				cout<<"Deleted successfully\n";//否则输出Deleted successfully
				vis[name]=0;//把这个人的分数清零(即从学籍中删除)
				now--;//总人数减一
			}
		}
		
		if(flag==4)//如果是查询学籍中的人数
		{
			cout<<now<<endl;//直接输出now就好了
		}
		
	}
	return 0;//最后块乐地结束代码
}
```

祝大家能A了这题

~~还有，不要CV哦~~

---

## 作者：WOWHandsome (赞：1)

仔细读题发现这道题目就是要做这样几件事情：

- 将一个字符串 **“映射”** 到 一个整数

- 对应值查询

- 查询数据集元素数量

- 删除 “映射” 关系

考虑到题目最核心的 **“映射”** 关系，我们可以使用 $STL$ 中的 $Map$ 映射大法。注意到我们需要查询一个值并判错，那么我们可以利用 “哨兵” $0$ 分 来代表数据未在数据集中。注意到操作数达到 $100000$，$Map$ 内部使用红黑树的结构，则一次插入、查询、删除操作都在 $O(logN)$ 的时间复杂度，则整体时间复杂度为 $O(NlogN)$，是满分做法。

```cpp
#include <bits/stdc++.h>
using namespace std;
map <string, int> mat; //map映射
string str; //输入字符串
int main() {
	int n, sc, op, ans = 0;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> op;
		if (op == 1) { //插入
			cin >> str >> sc;
			if (mat[str] == 0) ans++;//原来未在数据集中
			mat[str] = sc; //插入元素
			cout << "OK\n";
		} 
		else if (op == 2) {
			cin >> str;
			if (mat[str] != 0) cout << mat[str] << "\n";  //原来已有元素
			else cout << "Not found\n";//未有元素
		}
		else if (op == 3) {
			cin >> str;
			if (mat[str] == 0) cout << "Not found\n"; 
			else {
				mat[str] = 0; //标 “0分” 哨兵。删除映射关系
				ans--; //总数对应也减一
				cout << "Deleted successfully\n";
			}
		}
		else if (op == 4) {
			cout << ans << "\n";
		}
	}
	return 0;
} 
```

今天冬至啦~不知各位的家乡有什么风俗？~~我家吃汤圆~~

---

## 作者：　　　吾皇 (赞：1)

### 分析

要求一种数据结构，支持加入某元素，删除某元素，查找某元素对应值，查找内部元素数量。

首先想到 STL 的 map ，删除和查找可以用迭代器，元素数量可以用 NAME.size()。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>p;
map<string,int>::iterator it;//定义一个迭代器
string s;//代表学生姓名
int n,opt,m;
int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d",&opt);//判定操作类别
		if(opt==1) {
		    cin>>s,scanf("%d",&m);
			p[s]=m;//将其加入map中
			puts("OK"); //输出
		}
		if(opt==2){
			cin>>s;
			it=p.find(s);
			if(it==p.end()) puts("Not found");//这样代表没有找到
			else printf("%d\n",p[s]);//否则输出对应值
		}
		if(opt==3){
			cin>>s;
			it=p.find(s);
			if(it==p.end()) puts("Not found");
			else p.erase(it),puts("Deleted successfully");//NAME.erase(XX)用来删除特定元素。
		}
		if(opt==4) printf("%d\n",p.size());//输出当前map内元素数量
	}
}
```


---

## 作者：Ryo_Yamada (赞：1)

看到这题好多题解用`undored_map`，来写一个`map`的题解。

此题就是考查我们对`map`的理解和运用，更像一道模板题。

其中只是一些对`count`,`erase`等函数的基础运用。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
map<string, int> str;//map
int main() {
	int id;//操作类型
	int n, score;/*n是次数，题目中没说，盲猜后发现是对的，希望补充一下题面。
    score则是分数
    */
	cin >> n;
	string s;//名字
	for(int i=0; i<n; i++) {
		cin >> id;
		if(id == 1) {
			cin >> s >> score;
			str[s] = score;
			cout << "OK" << endl;
		}//插入操作，id == 1时。
		else if(id == 2) {
			cin >> s;
			if(!str.count(s))cout << "Not found" << endl;
			else cout << str[s] << endl;
		}//查询操作，id == 2时。注意要先判断count。
		else if(id == 3) {
			cin >> s;
			if(!str.count(s))cout << "Not found" << endl;
			else {
				str.erase(s);
				cout << "Deleted successfully" << endl;
			}
		}//删除操作，id == 3时。注意也要先判断count。
		else {
			cout << str.size() << endl;
		}//总人数
	}
    return 0;//完结撒花
}不要抄袭
```


---

## 作者：CrTsIr400 (赞：1)

~~STL大法好~~

题目中提到

>1.将一个**字符串映射**到**一个整数**

>2.对应值**查询**

>3.查询数据集元素**数量**

>4.**删除**映射关系

>（转载自楼下）



使用`unordered_map`。

和楼下`map`思路一样，但是时间复杂度是$O(n)$的$qwq$。

查询操作，删除操作就不麻烦了$qwq$。


```cpp
#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
#define F(i,a,b) for(register int i=a;i<=b;i++)
int flaag,pnt,sz=100;char mid_char=' ',ch,buff[21];
using namespace std;
template<typename t>void in(t&a){a=0;ch=getchar();flaag=1;while((ch<'0')||(ch>'9'))flaag=(ch=='-')?-flaag:flaag,ch=getchar();while((ch>='0')&&(ch<='9'))a=a*10+ch-'0',ch=getchar();a*=flaag;}
template<typename t>void out(t a){if(a<0)putchar('-'),a=-a;if(a==0)putchar('0');while(a)buff[++pnt]=a%10+'0',a/=10;while(pnt)putchar(buff[pnt]),--pnt;putchar(mid_char);}
template<typename t,typename ...ARGS>void in(t&a,ARGS&...args){in(a);in(args...);}
template<typename t,typename ...ARGS>void out(t a,ARGS... args){out(a);out(args...);}
unordered_map<string,int>m;
int n,op,cj,cnt;string s;
int main()
{
 	cin>>n;
 	F(i,1,n)
 	{
 		cin>>op;
 		if(op==1)//查询1
		{
			cin>>s>>cj;//人名和成绩
			if(!m[s])cnt++;//统计不同的人个数
			m[s]=cj;//更新成绩
			cout<<"OK"<<endl;
		}
		if(op==2)//查询2
		{
			cin>>s;//输入人名
			if(m[s])
			cout<<m[s]<<endl;
			else
			cout<<"Not found\n";
        //如果有这个人，那就输出成绩
        //否则输出未找到
		}
		if(op==3)//查询3
		{
			cin>>s;
			if(!m[s])cout<<"Not found\n";
			else m[s]=0,cnt--,cout<<"Deleted successfully\n";//删学生
		}
		if(op==4)//查询4
		{
			cout<<cnt<<endl;//输出学生个数
		}
	}
	return 0;
}
```

**要使用C++11提交！**

---

## 作者：DJHJJY (赞：0)

~~这题乍一看很水~~但他卡时间啊

这就很难受，我也很无语。。。

所以我们想到用STL来做，，map有用字符串当下标的性质，所以用一下map就好了

以下是代码

```c
#include<bits/stdc++.h>
using namespace std;
map<string,int>s;
int n,sum;	
map<string,int>::iterator it;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int c;
		cin>>c;
		if(c==1)
		{
			string x;
			int y;
			cin>>x>>y;
			it=s.find(x);
			if(it!=s.end())it->second=y;
			else
			{
				sum++;
				s.insert(pair<string,int>(x,y));
			}
			cout<<"OK"<<endl;
		}
		if(c==2)
		{
			string x;
			cin>>x;
			it=s.find(x);
			if(it!=s.end())cout<<it->second<<endl;
			else cout<<"Not found"<<endl;
		}
		if(c==3)
		{
			string x;
			cin>>x;
			it=s.find(x);
			if(it!=s.end())
			{
				cout<<"Deleted successfully"<<endl;
				s.erase(x);
				sum--;
			}
			else cout<<"Not found"<<endl;
		}
		if(c==4)
		{
			cout<<sum<<endl;
		}
	}
	return 0;
}
```
这道题重在理解题意，我就是因为题没看懂卡了老长时间，注意点是输入时sum不能瞎加只有没重复时才能加，还有那个OK是无论如何都要输出的，很坑吧。
就这样了，希望对大家有所帮助

---


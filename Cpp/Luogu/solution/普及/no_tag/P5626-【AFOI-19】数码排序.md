# 【AFOI-19】数码排序

## 题目背景

小L从虚拟世界里出来啦！

---

**加强版[链接](https://www.luogu.org/problem/P5634)**

## 题目描述

逃出来的同时，也有一部分数码逃了出来，吵着闹着让小L帮他们排序

虚拟世界的数码都是不可见的

小L目前只会选择排序，插入排序，冒泡排序，归并排序

所以小L想问他在最坏情况下最少需要几次比较，才能使序列有序

-------

[排序的模板代码](https://www.luogu.org/paste/fdtepscp)

## 说明/提示

- **样例$1$解释**

长度为$4$的序列归并调用，分成$2$组，一组$2$个元素。$2$个元素分别比较一次， 合并时最坏比较$3$次，所以是$3+1+1=5$。

- **数据范围**

对于$10\%$的数据，$n \leq 1000$

对于$30\%$的数据，$n \leq 1000000$

对于$100\%$的数据，$n \leq 10^{16}$

**数据保证随机**


## 样例 #1

### 输入

```
4```

### 输出

```
5```

## 样例 #2

### 输入

```
5```

### 输出

```
8```

# 题解

## 作者：Pisces (赞：22)

这其实也是原题，很早以前出公开赛准备用这个，只不过数据强太多了...不说了，上题解（[加强版在此](https://www.luogu.org/problem/P5634)）

为了方便，以下我用$lg$来代替$\log_2$

我们容易得出$ans=F(n)=F(\lfloor n/2\rfloor )+F(\lceil n/2\rceil )+n-1(n>1)$，我们令$g(n)=g(\lfloor n/2\rfloor )+g(\lceil n/2\rceil )+a(n)(n>1)$，则有$\Delta g(n)=\Delta a(n)+\Delta g(\lfloor n/2\rfloor)$

我们有恒等式$\lceil lg2j\rceil=\lceil lgj\rceil+1$和$\lceil lg(2j-1)\rceil=\lceil lgj\rceil+[j>1](j\geq1)$，所以当$a(n)=n-1$时，$\lceil lg(n+1)\rceil$满足$\Delta f(n)=1+\Delta f(\lfloor n/2\rfloor)$

所以有结论若$F(1)=0,F(n)=F(\lfloor n/2\rfloor )+F(\lceil n/2\rceil )+n-1(n>1)$，$F(n)=\sum\limits_{k=1}^{n}\lceil lgk\rceil$，我们就可以暴力求$F(n)$，但此时暴力仍然是$O(n)$的，因为其中有一些连续相等的数，可以考虑数论分块，复杂度大概是$O(lgn)$的，在我的那道题中预计得分$10\sim20pts$

令$m=\lceil lgn\rceil$，我们考虑增加$2^m-n$项以简化运算：

$F(n)+(2^m-n)m=\sum\limits_{k=1}^{2^m}\lceil lgk\rceil=\sum\limits_{j,k}j[j=\lceil lgk\rceil][1\leq k\leq 2^m]=\sum\limits_{j,k}j[2^{j-1}\lt k\leq 2^j][1\leq j\leq m]=\sum\limits_{j=1}^{m}j2^{j-1}=2^m(m-1)+1$

所以我们得到$F(n)=nm-2^m+1$

但是还有一个问题：如何求$\lceil lgn\rceil$，由于$n$太大，只能使用高精度，考虑暴力求$2^k$，暴力找到$m$，暴力取模，复杂度仍为$O(lgn)$，在我的那道题中预计得分仍然为$10\sim20pts$

我们有换底公式$lgn=\log_{10}n/\log_{10}2=\log_{10}n*(1/\log_{10}2),\log_{10}n$可以用数位个数估算（偏小），$1/\log_{10}2$取估算值$3.32192809488736218170856773213$，此时就可以求得估算值$l$，考虑预处理出$2^{2^l}$，再把$l$用二进制法表示即可快速求出$2^l$，再用暴力即可（此时暴力最多算$4$次，因为$2^4\gt10$），复杂度$O(lglgn)$，预计得分$100pts$，但是此题数据范围达到$10^{100000}$，必须用$FFT$优化，否则得分只能是$50\sim80pts$（均指在我的那道题中）

另外，提供本题（较弱版的AC代码）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s*=a;
		a*=a,b>>=1;
	}
	return s;
}
signed main(){
	int n,m;
	cin>>n;m=ceil(log2(n));
	cout<<m*n-qpow(2,m)+1;
	return 0;
}
```

---

## 作者：　　　吾皇 (赞：16)

显然找规律，考虑先对小数据进行分析：
| $n$的值 | $ans$的值 |
| :----------: | :----------: |
| 1 | 0 |
| 2 | 1 |
| 3 | 3 |
| 4 | 5 |
| 5 | 8 |
| 6 | 11 |
| 7 | 14 |
| 8 | 17 |
| 9 | 21 |
| 10| 25 |

那么一开始没有看出什么直到看到提示中 `长度为4的序列归并调用，分成2组，一组2个元素` 猜测和序列的奇偶性有关

还是`归并排序`，由于将数组分成2组，不难猜想值之和与拆开2组的所需个数有关。

观察：

- 3和0、1的关系
- 5和1、1的关系
- 8和1、3的关系

好像找不出什么规律，但突然想到归并排序两数组还要整合，分别比较，所以想到次数和n有关。考虑再减掉一个n

观察：

- 0和0、1的关系
- 1和1、1的关系
- 3和1、3的关系

现在就很明显了，$f(n)-n=f(int(n/2))+f(int(n/2+{1/2}))-1$


∴稍微处理一下后，得出
1. n为奇数时，$f(n)=f(n/2)+f(n/2+1)+n-1$
2. n为偶数时，$f(n)=2*f(n/2)+n-1$

显然单是这样递推（递归）是不行的，毕竟$n<=10^{16}$。考虑记忆化搜索，但开数组肯定存不下。只能用STL内map水一水，大概要最多要存下~~log2(n)*2~~（也算不清楚QAQ反正能存下）

注意f(1)和f(2)要特判

---

## 作者：PrincessQi (赞：8)

下面介绍一种O(log(n))的朴素做法

首先肯定是归并排序比较快，如果不懂的话建议先去学习归并排序

然后开始做小学数学题（~~找规律~~

下面是小数据：

```
 n |ans
 1 | 0
 2 | 1=0+1
 3 | 3=1+2
 4 | 5=3+2
 5 | 8=5+3
 6 | 11=8+3
 7 | 14=11+3
 8 | 17=14+3
 9 | 21=17+3
 10| 25=21+4
```
将每两项的公差算出后（小学题套路）可以很~~轻易~~发现规律qwq

然后就是代码的事了

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,m,j=1,ans,x=1;
int main(){
	scanf("%lld",&n);
	if(n==1ll){puts("0");return 0;}//1需要特判
	a=n-1;
	while(a){
		m++;
		a/=2;
	}//求出大于等于n的第一个2的m次方的m
	for(int i=1;i<=m;i++)
		j*=2;//求出大于等于n的第一个2的m次方的数j
	for(int i=1;i<=m;i++)
		ans+=(i*x),x*=2;//求出j的ans
	ans-=((j-n)*m);//把多加了的减掉
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：saxiy (赞：5)

#### 题目分析：

首先，$n$ 较大时，一定是归并排序比较次数少。

先打个表，发现即使 $n$ 较小时，也是归并排序比较次数更小，于是只考虑归并排序的比较次数，一层序列长度为 $x$ 的调用会引发下一层的调用和本层最坏为 $x-1$ 次的比较，于是得出如下转移方程。

$$f[0]=f[1]=0,f[x]=f[\frac{x}{2}]+f[x-\frac{x}{2}]+x-1$$

因为 $n$ 很大，有以下两种做法：

1. ~~面向OEIS编程~~ 找规律推结论

2. 记忆化搜索

下面给出公式和记忆化搜索的代码实现。

$$S_n=n\times\left\lceil\log{n}\right\rceil-2^{\left\lceil\log{n}\right\rceil}+1$$

~~关于这个公式，窝并不知道怎么推~~

#### 代码实现(记忆化搜索)：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

map <ll, ll> mp;

ll dfs(ll x) {
	if(mp.count(x)) return mp[x];
	if(x <= 1) return 0;
	return mp[x] = dfs(x >> 1) + dfs(x - (x >> 1)) + x - 1;
}

int main() {
	ll n;
	scanf("%lld", &n);
	printf("%lld", dfs(n));
	return 0;
}
```

---

## 作者：Erusel (赞：3)

为什么没有官方solution啊，那窝来搬运一个qwq

---

这里顺便宣传一下神Pisces的[加强版](https://www.luogu.org/problem/P5634)

对于那题请自觉不使用python

这题就是给大家娱乐的

---

经过观察发现，归并排序显然比其他几种排序更优

我们考虑一个数列分成两半计算贡献，利用分治的思想解决

考虑到归并排序将长度为$n$的数列分成长度为$\frac{n}{2}$和$n-\frac{n}{2}$的两个序列

我们需要的比较次数为$f(n)=f(\frac{n}{2})+f(n-\frac{n}{2})+$合并所需的贡献

容易得到，在最坏情况下，合并两个长度为$\frac{n}{2}$和$n-\frac{n}{2}$的序列需要$n-1$次比较

又由于数据保证随机，我们可以利用map或者unordered_map来记忆化搜索

时间复杂度$O($**能过**$)$

Code:

```
#include<bits/stdc++.h>

#define rd(x) x=read()

#define int long long

using namespace std;

int n;
unordered_map<int,int>f;

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}

int solve(int x)
{
	if(x==1)return 0;
	if(x==2)return 1;
	if(x==3)return 3;
	if(f[x])return f[x];
	return f[x]=solve(x/2)+solve(x-x/2)+x-1;
}

signed main()
{
	rd(n);cout<<solve(n)<<endl;
    return 0;
}



```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5626)

#### 思路

首先，一定是归并排序最快。

接着手磨打表找规律：

| $n$ | $ans$ |
| :----------: | :----------: |
| 1 | 0 |
| 2 | 1+0 |
| 3 | 1+2 |
| 4 | 2+3 |
| 5 | 5+3 |
| 6 | 8+3 |
| 7 | 11+3 |
| 8 | 14+3 |
| 9 | 17+4 |
| 10 | 21+4 |

接着，容易找出表中规律，设 $p=\lfloor log_2n \rfloor$，可算出答案：

$$S_n=\sum^p_{i=1}(i2^{i-1})-p(2^p-n)$$

根据小学推导公式，可将左边式子变成 $p2^p+1-2^p$。

整个式子即可化成：

$$S_n=np-2^p+1$$

注意使用快速幂。

#### 贴贴代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
inline ll ksm(ll a,ll b){ll z=1;while(b){if(b&1)z=z*a;a=a*a;b>>=1;}return z;}
int main(){
	scanf("%lld",&n);
	ll p=ceil(log2(n*1.0));
	ll ans=n*p-ksm(2,p)+1;
	printf("%lld",ans);
	return 0;
}

```



---

## 作者：opened (赞：1)

>最坏情况下最少需要几次比较

显然这是对归并排序的询问，与另外三种排序算法无关

由**二路归并排序**原理，可知递推式：

$$f(x) =
\begin{cases}
1,\ x=1\\
f(\left \lfloor \Large{\frac{x}{2} } \right \rfloor)+f(\left \lfloor \Large{\frac{x}{2} } \right \rfloor+1)+x-1,x\ge2\ \&\&\ x\ is\ \ odd\ \\
2*f(\left \lfloor \Large{\frac{x}{2} } \right \rfloor)+x-1,x\ge2\ \&\&\ x\ is\ \ even\  
\end{cases}$$


$n$ 的规模是 $10^{16}$ ，须进行**记忆化搜索**

```
#include<iostream>
#include<cstdio>
#include<map>
using namespace std;
typedef unsigned long long ll;
ll n;
map<ll,ll> S;
ll F(ll x){
    switch(x){
		case 1:return 0;
	    case 2:return 1;
	    case 3:return 3;
	}
	if(S[x]) return S[x];
	return x&1?S[x]=F((x>>1))+F((x>>1)+1)+x-1:S[x]=(F((x>>1))<<1)+x-1;
}
int main(){
    cin>>n;
    cout<<F(n)<<'\n';
    return 0;
}
```

---


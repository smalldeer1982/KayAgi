# [CSP-J2019 江西] 次大值

## 题目描述

Alice 有 $n$ 个正整数，数字从 $1 \sim n$ 编号，分别为 $a_1,a_2, \dots , a_n$。  
Bob 刚学习取模运算，于是便拿这 $n$ 个数进行练习，他写下了所有 

$$a_i \bmod a_j (1 \le i,j \le n \wedge i \neq j)$$  

的值，其中 $\bmod$ 表示取模运算。  

Alice 想知道所有的结果中，严格次大值是多少。将取模后得到的所有值进行去重，即相同的结果数值只保留一个，剩余数中第二大的值就称为严格次大值。

## 说明/提示

【数据范围】  
对于 $40\%$ 的数据，$1\le n,a_i \le 100$；  
对于 $70\%$ 的数据，$1\le n \le 3000$，$1\le a_i \le 10^5$；  
对于 $100\%$ 的数据，$3 \le n \le 2\times 10^5$，$1\le a_i \le 10^9$。

【样例 $1$ 解释】  
所有取模的结果为 $\{4,4,4,1,0,5,1,0,5,2,1,1\}$。  
去重后有：$\{0,1,2,4,5 \}$，结果为 $4$。

## 样例 #1

### 输入

```
4
4 5 5 6```

### 输出

```
4```

## 样例 #2

### 输入

```
4
1 1 1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
7
12 3 8 5 7 20 15```

### 输出

```
12```

# 题解

## 作者：installb (赞：195)

其实这题还是有很多要考虑的点的 稍微说一说解题过程  

首先它要求严格次大值 所以有两个相同的数没有意义...先排序+去重  
假设原序列去重后剩下的序列为$a_1,a_2,...,a_n$

由于 $a\ mod\ b < a$ 所以最大值一定是$a_{n-1}\ mod\ a_n$  
简单证明:  
- 1.对于$a_1$到$a_{n-2}$ 使其**取模比它们大的数** 就是本身 一定比$a_{n-1}$小  
- 2.如果一个数**模比它小的数** 被模的数不可能是$a_n$ 那么最后值一定小于$a_{n-1}$  

然后我们可以想到 很明显$a_{n-2}\ mod\ a_n$是所有**一个数模比它大的数**中次大值$x$  
我们还要找出**一个数模比它小的数**中次大值 和刚才的值$x$比较  
看起来得枚举了 其实不必  
假设这个选择是$a_j\ mod\ a_i$ 那么如果$i\leq n-2$ 这个值一定小于$x$  
于是$i\geq n-1$ 只剩下一种取法:$j=n,i=n-1$  

这两个比较 取较大的 必定就是次大值  
代码也很简短  

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long LL;

int n;
int a[300005];

int main(){
	cin >> n;
	for(int i = 1;i <= n;i ++) cin >> a[i];
	sort(a + 1,a + 1 + n); n = unique(a + 1,a + 1 + n) - a - 1;
	// 排序+去重
   a[0] = 0;
	if(n <= 1) printf("-1\n");
   // 无解特判
	else printf("%d\n",max(a[n - 2],a[n] % a[n - 1]));
	return 0;
}
```

---

## 作者：muyang_233 (赞：21)

我们直接来讲题目思路。  
大家都知道，当 $a1 < a2$ 时， $a1\ mod\ a2 = a1$ 。  
故我们很容易想到一个思路，就是在所有数中，一定由小的模大的来获得余数序列当中最大的一系列数。  
显然最大的数对其他数取余，肯定不会为它本身，于是最大的余数应该为原序列当中第二大的数，而严格次大值就为第三大的值。    
（具体证明过程：  
$\ \ \ $设$A={a_1,a_2,a_3,...,a_n}$为原序列升序排列后再去重的序列，满足$a_1\le a_2\le a_3\le ... \le a_n$  ，  
$\ \ \ $对于每个$a_i$和$a_j$，考虑如下两种情况：  
$\ \ \ $1. $j<i$，此时$a_i>a_j$，$a_i\ mod\ a_j$必然$<a_j$；  
$\ \ \ $2. $j>i$，此时$a_i<a_j$，$a_i\ mod\ a_j$必然$=a_i$；  
$\ \ \ $显然两种情况中，$j>i$一定能得到更优解。  
$\ \ \ $于是我们不妨将每个$a_i$都与$a_j(j>i)$来取余，这样得到一个预选序列。  
$\ \ \ $显然能够凑到的预选序列为$A*={a_1,a_2,a_3,...,a_{n-2},a_{n-1}}$。（对于每个$i(i<n)$，总能找到一个$j(j>i)$，而$i=n$时则不行）  
故答案为$a_{n-2}$。  
而当$n<3$时，显然没有答案。
）  
代码如下：  
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
int a[200005];
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1);
    int unsamet=0;
    int l=-1;
    for (int i=n;i>=1;i--){
        if (a[i]!=l){
            ++unsamet;
            l=a[i];
        }
        if (unsamet==3){
            printf("%d",a[i]);
            return 0;
        }
    }
    puts("-1");
    return 0;
}
```
你以为这就对了？  
~~抱歉，你WA了一个点。~~  
事实上，我们的答案是$a_{n-2}$。  
但是， $a_{n}\ mod\ a_{n-1}$ ，其结果 $< a_{n-1}$ ，但由于 $a_{n-1}>a_{n-2}$，故该结果有可能大于$a_{n-2}$，所以要做一个特殊判断。  
最终代码：  
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
int k;
int a[200005];
int t[200005];
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1);
    int l=-1;
    for (int i=1;i<=n;i++){
        if (a[i]!=l){
            l=a[i];
            t[++k]=a[i];
        }
    }
    if (k<3){
        puts("-1");
    }
    else{
        printf("%d",max(t[k-2],t[k]%t[k-1]));
    }
    return 0;
}
```

---

## 作者：　　　吾皇 (赞：12)

### 40分

$1<=n<=100$，$O(n^2)$应该能过

直接定义$set$去重排序，导出倒数第二个数即可

#### 代码
```
#include<bits/stdc++.h>
using namespace std;
set<int>ans;
int a[200010],n,top,ans1[200010];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)
		    if(i!=j) ans.insert(a[i]%a[j]);//按照题中的意思存储
	if(ans.size()==1) return printf("-1"),0;//如果只有一个输出“-1”
	for(set<int>::iterator it=ans.begin();it!=ans.end();it++)
		ans1[++top]=*it;//把set中所有值导出
	printf("%d",ans1[top-1]);//输出第二大的
   return 0;
}
```
### 100分

小学应该学过，$a$%$b$的余数必定$<b$，而若$a<b$,则$a$%$b$的余数即为a。因为$a_1$-$a_{top-3}$不可能是第二大的，于是待选答案只剩下了$2$个:$a_{top}$%$a_{top-1}$ ,$a_{top-2}$ 

只要选取最大值就可以了

为什么有$a_{top}$%$a_{top-1}$? 因为$a_{top}$%$a_{top-1}$ 可能 $>$ $a_{top-2}$

为什么没有 $a_{top-1}$ ? 因为 $a_{top}$ % $a_{top-1}$ $<$ $a_{top-1}$ 并且 $a_{top-2}$ $<$ $a_{top-1}$

#### 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,a[200010],top;
set<int> p;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}//手写快读
int main(){
	n=read();
	while(n--) p.insert(read());//将原数组存入set 自动去重排序
	if(p.size()==1) return printf("-1"),0;//如果大小为1直接结束
	for(set<int>::iterator it=p.begin();it!=p.end();it++)
		a[++top]=*it;//导出不重复原数组
	printf("%d",max(a[top-2],a[top]%a[top-1]));//取二者最大值即为答案
    	return 0；
}
```

### 总结

注意模运算的性质 可以手写几组样例找找规律

~~话说70分的部分分是什么算法~~

---

## 作者：niuniudundun (赞：8)

有意思的数学题。

# 题目大意

算出 $a_i \bmod a_j$ 的次大值，没有输出 $-1$。

# 解法

假设 $a$ 有序并去重。当然 $n$ 小于等于 $1$ 一定无解输出 $-1$。

既然 $a$ 是单调不下降序列，$a_n$ 一定是最大值，$a_{n-1}$ 一定是次大值，那么 $a_{n} \bmod a_{n-1}$ 就是所有 $a_i \bmod a_j$ 的次大值。

当然，这可能不是最优解，$a_{n-2} \bmod a_{n}$ 实际上是要么是 $0$，要么是 $a_{n-2}$。

>证：
>
>$\bmod$ 有个特性，当 $a<b$ 时，$a \bmod b$ 就是 $a$；如果 $a_{n-2}$ 小于 $a_n$ 那么答案就是 $a_{n-2}$。
>
>$a_{n-2}$ 和 $a_n$ 也可以取等号，这时取模就等于零了。
>
>$a_{n-2}$ 不可能大于 $a_n$，因为 $a$ 是单调不下降序列。
>
>证毕。

所以答案是 $\max(a_{n} \bmod a_{n-1},a_{n-2} \bmod a_{n})$。

最后输出即可，就不放代码了。

---

## 作者：rouxQ (赞：6)

这题蛮套路的说

看完题，这个暴力应该都打得出来吧
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
priority_queue<int> q;
int n,a[10001];
int main () {
	cin>>n;
	for (int i = 1;i <= n;i++)cin>>a[i];
	for (int i = 1;i <= n;i++)
		for (int j = i + 1;j <= n;j++) 
			q.push(a[i] % a[j]),q.push(a[j] % a[i]);
	int k = q.top();
	while(q.size()) {
		if(q.top() != k) {
			cout << q.top();
			return 0;
		}
		q.pop();
	}
	cout << -1;
	return 0;
}
```
但是显然，$O(n^2)$的时间和空间复杂度都是不能承受的，需要寻找更快的算法。

根据取模的定义我们知道，$a_i\ \%\ a_j$必然$<a_j $，而如果$a_i \ge a_j$的话，最后所得反而比$a_i$还要小，这不是我们所期望的。**所以要是想找尽量大的值，我们希望在保证$a_i$足够大的情况下寻找大的$a_j$**。

所以可以想到，我们令$a_i$是序列中的最大数，然后再扫一遍就行了。

那么一个$O(nlogn)$的算法基本就出来了：
>先将序列排序（假设从小到大排）

>那么上文所提的$a_i$便可以是$a_1$，这样可以确保不会有取模之后的数足够大 

>再在序列中找到**第三大**的数即可（注意可能会有重复数据）。当然排序之后再`unique`一下直接输出也可以。

还剩两个东西没有解决：
>1.怎么判无解 

>简单思考即显而易见，无解当且仅当序列所有数都相同。因为若有两个数不相同，它们互相膜~~拜~~，必然得到两个不同的结果

>2.如果序列中只有两个不一样的数怎么办 

>根据上面的算法可以发现，如果去重之后只剩两个数，显然没有第三大的数出现。对此，我们先思考只有两个数时，题目中所求的序列中还剩几个数。显然，最多剩三个，也就是$0,a_1\%a_n,a_n\%a_1$，那么特判一下就好啦。（这里吐槽一下luogu数据弱，我这里判错了都ac了）

最后，放代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int a[200001],n;
int main (){
	int f = 1;//f用来数序列中有几个不同的数 
	cin >> n;
	for (int i = 1;i <= n;i++) {
		cin >> a[i];
		if (i > 1 && a[i] != a[i - 1])f++;
	}
	if (f == 1){cout<<-1;return 0;}//特判无解 
	sort(a+1,a+1+n);
	int k = a[n],s = 0;//s表示已经数了几个不同的数 
	for (int  i = n;i >= 1;i--) {
		if (a[i] != k)
			s++,k = a[i];
		if (s == 2) {//已经数到了第二个不同的（即找到了第三大） 
			cout << k;
			return 0;
		}
	}
	cout << "Beep\n";//如果循环跑完了程序未终止，说明剩两个不一样的，再特判 
	cout << min(a[1],a[n] % a[1]);
	return 0;
}
```

---

## 作者：sherry_lover (赞：3)

# P5682 [CSP-J2019 江西] 次大值 题解

[题目传送门](https://www.luogu.com.cn/problem/P5682)

## 思路

第一步：如何处理去重。所有结果算出来再去重肯定会超时，其实可以在读入 $a$ 数组后将 $a$ 数组进行去重即可。因为当 $a_i = a_j$ 时，$a_i \bmod a_k = a_j \bmod a_k$，$a_k \bmod a_i = a_k \bmod a_j$，显然可以直接去重。

第二步：第二大的值是什么。先考虑最大值。发现当除数、被除数越大且被除数小于除数时，余数就是被除数。但不能排除被除数大于除数的情况。

将 $a$ 数组排序、去重后假设还有 $m$ 个。则最大值就是 $a_{m-1} \bmod a_m = a_{m-1}$。不会有上面说的第二种情况，因为 $a_m \bmod a_{m-1} < a_{m-1}$。

再考虑第二大，一种是 $a_{m-2} \bmod a_{m} = a_{m-2}$，一种是 $a_m \bmod a_{m-1}$，取较大的一边就行了。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005];
int main() 
{
	cin >> n;
	for(int i = 1;i <= n;i++) cin >> a[i];
	sort(a+1,a+n+1);
	n = unique(a+1,a+n+1)-a-1;
	if(n <= 1) cout << -1;
	else cout << max(a[n-2],a[n]%a[n-1]);
	return 0;
}
```

---

## 作者：libu2333 (赞：2)

# 题解 P5682 [CSP-J2019 江西] 次大值

upd on 8.6：修改了题解中的代码。

**这是一篇 Python 题解。**

# 思路
先将列表**从大到小**排序后用 `set` 给列表去重，然后不难得出：

当 $n < 3$ 时，原题显然无解。

当 $n \ge 3$ 时，

因为排序去重后保证 $a_i > a_{i + 1}$ $(i > 0)$，

又因为 $a \bmod b = a$ $(a < b)$，

所以该列表的次大值为 $a_3 \bmod a_2$（容易证明$a_1$不可能在模后的列表中存在）。

但是这解法显然没有考虑全面，即虽然 $a_1 \bmod a_2 < a_2$，但 $a_1 \bmod a_2$ 可能大于 $a_3$，因此需要做特判。

# 代码
```python
#码风略丑见谅
n = int(input())
a = list(map(int, input().split()))
set_a=list(reversed(sorted(list(set(a)))))
if len(set_a) < 3:
    print(-1)
elif set_a[0]%set_a[1]>set_a[2]:  #列表下标从0开始
    print(set_a[0]%set_a[1])
else:
    print(set_a[2])
```

---

## 作者：Nahia (赞：2)

### 思路

首先明确最大值的概念，因为 $a > b$ 时，$a \bmod b = a$，所以最大值是第二大的数，那么次大值就是第三大的数。

真的吗？

在这组样例 `3 4 7 13` 中，次大值是 $13 \bmod 7 = 6$ 而不是第三大的数 $4$，所以可得次大值为最大的数与第二大的数取模的结果与第三大的数的最大值。剩下的特判 `-1` 的情况。

输入到一个 `set` 里（自动排序，去重），依次取出最大的，第二大的，第三大的数，最后对最大的数与第二大的数取模的结果与第三大的数取最大值就可以了。

### solution

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
set<int> a;
int main()
{
    cin>>n;
    if(n<3){
        cout<<-1;
        return 0;
    }
    for(int i = 1;i<=n;i++){
        int x;
        cin>>x;
        a.insert(x);
    }
    auto t = a.end();//地址变量
    t--;
    int x = *t;//取出最大的数
    t--;
    int y = *t;//取出第二大的数
    t--;
    int z = *t;//取出第三大的数
    t--;
    if(x%y==z){//特判相等
        cout<<-1;
        return 0;
    }
    cout<<max({x%y,z});//计算并输出
    return 0;
}
    
```

---

## 作者：sjh0626 (赞：2)

## 思路分析
首先我们要知道最大值是哪个数。

因为只有 $a < b$ 的时候，$a \bmod b = a $，所以第二大的数必为最大值。

因此可以得出第三大的数为次大值，但这真的一定吗？

我们构造一组数据，`3 4 6 11`，此时次大值并非第三大的数，而是 $11 \bmod 6 = 5$，所以次大值为第一大的数除以第二大的数的余数与第三大的数的最大值。

所以我们就可以写了，剩下只需要特判 `-1`。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
int x,n,a,b,c;
set<int>s;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x;
        s.insert(x);
    }
    if(s.size()<2)cout<<-1;
    auto it=s.end();
    advance(it,-3);
    a=*it;
    advance(it,1);
    b=*it;
    advance(it,1);
    c=*it;
    if(s.size()<2)cout<<"";
    else cout<<max(c%b,a);
    sjh0626s code;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

首先按照 $a$ 的值从小到大排序且去重，答案是不变的。

故对于 $i < j$ 的 $(i, j)$，有 $a_i < a_j$，则 $a_i \bmod a_j = a_i$；这种情况的最大值是 $a_{n - 1}$，严格次大值是 $a_{n - 2}$。

对于 $i > j$ 的 $(i, j)$，有 $a_i \bmod a_j < a_j$，故 $(a_i \bmod a_j)_{\max} < a_{i - 1}$。

由于第一种情况的次大值都是 $a_{n - 2}$ 了，故只需要考虑 $i = n, j = n - 1$ 的情况，因为只有 $(a_n \bmod a_{n - 1}) < a_{n - 1}$ 才可能大于 $a_{n - 2}$。

综上，可得答案为 $\max(a_{n - 2}, a_n \bmod a_{n - 1})$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=200200;
ll read(){
	ll x;
	scanf("%lld",&x);
	return x;
}
void write(ll x){
	printf("%lld",x);
}
ll n;
ll a[N];
int main(){
	n=read();
	for(int i=1;i<=n;i++)
	  a[i]=read();
	sort(a+1,a+n+1);
	n=unique(a+1,a+n+1)-(a+1);
	if(n<=1){
		puts("-1");
		exit(0);
	}
	write(max(a[n-2],a[n]%a[n-1]));
	return 0;
} 
```

这是几年前写的 code 了，码风可能有点不好看，见谅。

---

## 作者：Lyw_and_Segment_Tree (赞：1)

## 开始解题

首先肯定要先把 $\{a_i\}$ 进行排序并去重，接下来我们考虑对于 $a_i \bmod a_j$ 的不同情况以及其所对应的答案：

- 若 $a_i \lt a_j$，则 $a_i \bmod a_j = a_i$，此时显然 $a_n$ 无法通过这种方式得到，而 $a_1 \sim a_{n - 1}$ 中的每个 $a_i$ 都可以通过 $a_i \bmod a_{i + 1}$ 得到。

- 若 $a_i \ge a_j$，则 $0 \le a_i \bmod a_j \lt a_j - 1$，当 $i = n, j = n - 1$ 时这种情况的上界最大，即我们常说的“更有可能”，其正确性也是比较显然的。

最后，由于 $a_i \bmod a_j$ 的最大值一定是 $a_{n - 1}$（情况 1），那么答案就是我们所得到的 $a_{n - 2}$ 和 $a_{n} \bmod a_{n - 1}$ 取 $\max$。

最后别忘了特判去重之后 $n = 1$ 的情况并输出 `-1`。

时间复杂度 $O(n \log n)$，可以通过。

code : 

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define endl "\n"

using namespace std;

ll n, a[200005];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin >> n;
    
    for (ll i = 1; i <= n; i++) cin >> a[i];
    
    sort(a + 1, a + n + 1);
    
    n = unique(a + 1, a + n + 1) - a - 1;
    
    if (n <= 1) {
        cout << -1 << endl;
    } else {
        cout << max(a[n - 2], a[n] % a[n - 1]) << endl;
    }
}
```

[AC record](https://www.luogu.com.cn/record/195868996)

---

## 作者：_H17_ (赞：1)

## 题目大意

给你一堆数，求任意两数之间取余的次大值。

显然，一个很显然的性质：当 $x<y$ 时，$x\bmod y=x$。由此，我们可以想到给 $a$ 从大到小排序（由于只保留一个，需要去重）。

这时候 $a_2\bmod a_1=a_2$ 是最大的。为啥呢？显然 $a\bmod b<b$（以下简称余数大小性质），所以其他的数要不然就是对不比 $a_2$ 大的数取余，要不然对 $a_1$ 取余的也之后上面情况最大。

依照刚才的想法，考虑到次大值可能是 $a_3\bmod a_2=a_3$（其他的组合除了**对 $a_2$ 取余且原来数比 $a_3$ 大的**和**最大值**的一定严格小于 $a_3$，根据余数大小性质），比较 $a_3,a_1\bmod a_2$ 的较大值即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200001];
int main(){
    scanf("%d",&n);
	for(int i=1;i<=n;i++)
	    scanf("%d",a+i);
	sort(a+1,a+1+n);
	n=unique(a+1,a+1+n)-a-1;
	if(n<2)
	    printf("-1");
	else
	    printf("%d",max(a[n-2],a[n]%a[n-1]));
	return 0;
}

```

---

## 作者：qhr2023 (赞：1)

## soltion

先要知道，对于 $a \bmod b$，当 $b>a$ 时它的值最大为 $a$，所以我们为了找到次大数，我们需要让 $b$ 尽可能大，$a$ 在小于 $b$ 的前提下尽可能大，那么对于本题，答案就应是序列第三大数。

我们再考虑是否有漏洞，我们记序列最大数为 $mx$，次大数为 $nd$， 第三大数为 $rd$，$b$ 是模数，分类讨论。

* $b < rd$，结果一定小于 $rd$。
* $b = nd$，此时只有 $mx \bmod nd$ 可能大于 $rd$，且小于 $nd$。
* $b = mx$，此时次大值即 $rd$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[200005], nd, rd=-1;
int main () {
	cin >> n;
	for (int i=1; i<=n; ++i)
		cin >> a[i];
	sort(a+1, a+n+1);
	for (int i=n-1; i>0&&!nd; --i)
		if (a[i]<a[n]) 
			nd=a[i];
	for (int i=n-1; i>0&&rd<0; --i)
		if (a[i]<nd)
			rd=a[i];
	cout << max(rd, a[n]%nd);
	return 0;	
}
```

---

## 作者：pies_0x (赞：0)

# P5682 [CSP-J2019 江西] 次大值 题解
首先，如果 $a<b$，那么显然 $a\bmod b>b\bmod a$，因为 $a\bmod b=a$，但 $b\bmod a<a$。

得到结论，**一个数模另一个数时，余数一定小于被模数和模数**。

---
我们先把输入排序并去重。

则 $a_{n-1}\bmod a_n$ 肯定为最大值。

显然 $a_{n-2}\bmod a_n$ 可能为严格次大值。

---
不过还是有问题。

如果去重并排序后的数组为：
```
1 3 5
```

最大值为 $3\bmod5=3$，次大值并不是 $1\bmod5=1$，而是 $5\bmod3=2$。

所以 $a_n\bmod a_{n-1}$ 也可能为严格次大值。

Q: 那难道 $a_n\bmod a_{n-1},a_n\bmod a_{n-2},\dots,a_n\bmod a_1$ 都可能为严格次大值吗？或者还有更多可能？  
A: 不可能。根据开头结论，这种可能的被模数和模数都必须大于 $a_{n-2}\bmod a_n$，即 $a_{n-2}$，则可能得两个情况（被模数和模数不能相同）分别为最大值和上述式子。

***去重后数组大小可能小于 $3$。***

## Code
```cpp
// 不知道还需要说什么
#include<cstdio>
#include<algorithm>
using namespace std;

#define N 200005

int a[N],n;

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	    scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	n=unique(a+1,a+n+1)-a-1;
	if(n<2)
	    printf("-1");
	else
	    printf("%d",max(a[n-2],a[n]%a[n-1]));
	return 0;
}
```

---

## 作者：Wei_ch (赞：0)

构造所有可能的 $ a_i \bmod a_j $ 值（其中 $ i \neq j $）。对这些取模值去重，找到其中的所有不同结果中第二大的值。如果不同的取模结果不足两个，输出 $ -1 $。

### 思路
严格次大值一定在**最大的三个值**中产生。集合中最大的三个数，它们彼此之间的模运算已经涵盖了可能的较大模值。模运算的结果范围受限于模数的大小，所以其他更小的数不可能产生比最大的三个值之间的模运算更大的结果。

知道了这一点，这一题就简单了。使用集合来存储输入的数。在自动排序和去重后，如果还有三个数，就提取最大的三个数。再在他们三个中互相进行模运算，就可以得到严格次大值了。如果只有两个数，就互相取模。只有一个数输出 $ -1 $。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> a;
    int n, x;
    cin >> n;

    // 读取输入并插入集合，自动去重并排序
    for (int i = 0; i < n; i++) {
        cin >> x;
        a.insert(x);
    }

    // 如果集合包含至少 3 个不同的元素
    if (a.size() >= 3) {
        // 获取集合中最大的 3 个元素
        vector<int> maxThree(a.rbegin(), next(a.rbegin(), 3));

        // 存储模运算结果
        set<int> modResults;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (i != j) {
                    modResults.insert(maxThree[i] % maxThree[j]);
                }
            }
        }

        // 输出次大值
        cout << *(++modResults.rbegin()) << endl;

    } else if (a.size() == 2) {
        // 如果集合中只有 2 个不同的元素
        auto it = a.begin();
        int first = *it, second = *next(it);
        cout << min(first % second, second % first) << endl;

    } else {
        // 如果集合中只有 1 个元素
        cout << -1 << endl;
    }

    return 0;
}
```
[记录](https://www.luogu.com.cn/record/195844798)

---

## 作者：__galaxy_1202__ (赞：0)

## 解题思路：
首先，由于要求去重，所以下面的序列已经去好重。
### Case $0$，判无解：
由于已经去完重了，所以判一下数组长度是否为 $1$ 即可（输出 $-1$）。

### Case $1$，最大值：
首先注意到这样一个结论：  
当 $a < b$ 时，$a \bmod b = a$。  
又 $\because a \bmod b$ 必定 $< b$。  
$\therefore$ 直接得到结论：最大的值为第 $2$ 大的数。

### Case $2$，次大值：
跟上面的一样，一定为第 $3$ 大的数....................吗？  
以这个序列为例：`1 3 5`。  
第 $3$ 大的数为 $1$，**但 $5 \bmod 3 = 2 > 1$**，所以答案为 $2$。  
那从这个例子可以发现，**答案要在序列第 $3$ 大的值和最大值与次大值之模取最大。**  

Tips：因为次大值与第 $3$ 大的值之模一定小于第 $3$ 大的值，自然不用比较。



## CODE：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n, a[200001];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n; 
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    int cur = unique(a + 1, a + n + 1) - a - 1;
    if (cur <= 1) cout << -1;
    else cout << max(a[cur - 2], a[cur] % a[cur - 1]);
    return 0;
}
```

---

## 作者：glass_goldfish (赞：0)

本题十分简单，但是还是有一定思维难度的。  

我们发现，对于一个数 $x=a\bmod b$，它的最大值为 $b-1$。所以，如果把除了数组内最大值以外的数作为 $b$，那么结果肯定不是最大值，同理不是次大值。

显然，记数组内最大值为 $p$，**严格**次大值为 $q$，**严格**第三大值为 $k$，那么最大值一定是 $q\bmod p$，而次大值显然就是 $k\bmod p$ 了。但是对于序列中只有两种不同数字的情况，那么可以让它们互相取模，取其中小的一个。

无解也很好判断。如果序列中所有的数都是相同的，那么就是无解。因为只有一个最大值，值为 $0$。

本题可以读入数组之后排序，或者直接不使用数组，运用三个变量存储前三大值即可。排序的时间复杂度为 $O(n\log n)$，而后者的时间复杂度为 $O(n)$，而且空间复杂度为 $O(1)$，是一种很好的方法。

---

## 作者：signed_long_long (赞：0)

# 题目解法

结论题。

先说结论：次大值等于第三大的数、最大的数模第二大的数中取最大值。


证明：

众所周知，如果 $x\ge y$，那么 $x\bmod y<x$，如果 $x<y$，那么 $x\bmod y=x$，所以一定是一个小的数模大的数，最大值就是除了最大的数以外的最大数，即第二大的数，次大值就是除了最大的数以外的第二大的数，即第三大的数。但是还有一个 hack：（无意中发现）

```
3
1 5 9
```

所以还有可能是最大的数模第二大的数。

代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int a[200500];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int maxn,maxm,maxk;
	maxn=maxm=maxk=-1;
	int cnt=1;
	sort(a+1,a+n+1);
	for(int i=n;i>=1;){
		if(cnt>3) break;
		else{
			if(cnt==1){
				cnt++;
				maxn=a[i];
				for(;a[i]==maxn;i--);
			}else if(cnt==2){
				cnt++;
				maxm=a[i];
				for(;a[i]==maxm;i--);
			}else{
				cnt++;
				maxk=a[i];
				for(;a[i]==maxk;i--);
			}
		}
	}
//	printf("%d %d %d\n",maxn,maxm,maxk); 
	if(maxk==-1) return printf("-1"),0;
	printf("%d",max(maxk,maxn%maxm));
	return 0;
}
```

---


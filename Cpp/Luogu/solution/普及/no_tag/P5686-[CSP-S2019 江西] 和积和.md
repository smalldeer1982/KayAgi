# [CSP-S2019 江西] 和积和

## 题目背景

JXCSP-S T2

## 题目描述

给定两个下标从 $1$ 到 $n$ 编号的序列 $a_i,b_i$，定义函数 $S(l,r)(1\le l\le r\le n)$ 为：

$$\sum_{i=l}^r a_i\times \sum_{i=l}^r b_i$$

请你求出下列式子的值：

$$\sum_{l=1}^n \sum_{r=l}^n S(l,r)$$

由于答案可能很大，你只需要给出答案模 $10^9+7$ 后的结果。

## 说明/提示

【数据范围】   
对于 $20\%$  的数据：$n\le 10$ , $a_i,b_i\le 10$；   
对于 $40\%$  的数据：$n\le 200$ , $a_i,b_i\le 100$；    
对于 $70\%$  的数据：$n\le 3000$ , $a_i,b_i\le 10^5$；    
对于 $100\%$  的数据：$3\le n\le 5\times 10^5$ , $1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
3
2 3 4
3 4 5```

### 输出

```
244```

## 样例 #2

### 输入

```
5
11 22 33 44 55
12 34 56 78 90```

### 输出

```
201542```

# 题解

## 作者：周子衡 (赞：44)

感觉现在这里的题解都比较啰嗦，写一个简单一点的数学推导……

考虑$O(n)$枚举每个右端点$r$。我们要求的式子即

$ans_r=\sum_{l=1}^rS(l,r)=\sum_{l=1}^rS(l,r)=\sum_{l=1}^r(\sum_{i=l}^ra_i\times \sum_{i=l}^rb_i)$

记$suma_i=\sum_{j=1}^ia_i,sumb_i=\sum_{j=1}^ib_i$，即$a_i,b_i$的前缀和，特别地，记$suma_0=sumb_0=0$，则

$ans_r=\sum_{l=1}^r(suma_r-suma_{l-1})(sumb_r-sumb_{l-1})$

$\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }=\sum_{l=1}^r(suma_rsumb_r-suma_{l-1}sumb_r-suma_{r}sumb_{l-1}+suma_{l-1}sumb_{l-1})$

$\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }=r\times suma_rsumb_r-sumb_r\sum_{l=0}^{r-1}suma_l-suma_r\sum_{l=0}^{r-1}sumb_l+\sum_{l=0}^{r-1}suma_lsumb_l$

扫描的时候可以用三个变量分别记录$suma_l,sumb_l,suma_l\times sumb_l$的和，套入上式直接计算即可，再更新变量的值。

最后输出$\sum_{r=1}^nans_r$即可。

总时间复杂度$O(n)$。

---

## 作者：Provicy (赞：29)

一道较好前缀和简单式子题，黄题难度比较适合。

根据题目意思，我们要求的就是：

$$\sum_{l=1}^{n}\sum_{r=l}^{n}\sum_{i=l}^{r}a_{i}\times\sum_{i=l}^{r}b_{i}\qquad$$

显然，对于题目中这个$S(l,r)$可以用前缀和实现$O(1)$求值，于是我们可以得出$70$分代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register
using namespace std;
const int N=500010,Mod=1e9+7;
int n,a[N],b[N],qza[N],qzb[N],ans;//qza和qzb分别为原数组a和b的前缀和
inline int read()
{
	int s=0,w=1; register char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;
}
signed main()
{
    n=read(); 
    for(ri int i=1;i<=n;i++) a[i]=read(), qza[i]=qza[i-1]+a[i]; 
    for(ri int i=1;i<=n;i++) b[i]=read(), qzb[i]=qzb[i-1]+b[i];
    for(ri int i=1;i<=n;i++)
    {
    	for(ri int j=i;j<=n;j++)
    		(ans+=(qza[j]-qza[i-1])*(qzb[j]-qzb[i-1]))%=Mod;
    }
    printf("%lld\n",ans);
    return 0;
}
```
现在我们考虑把这个转成线性的递推。

观察上方代码中枚举$j$这层的式子，拆开后有：

$$\sum_{i=1}^{n}\sum_{j=i}^{n}qza_{j}\times qzb_{j}+qza_{i-1}\times qzb_{i-1}-qza_{j}\times qzb_{i-1}-qza_{i-1}\times qzb_{j}\qquad$$

这个式子看起来很复杂，其实我们发现里面有很多可以预处理的东西。

对于每个$i$：

首先我们容易发现$qza_{k}\times qzb_{k}$显然可以预处理，记$C_{k}$为这个单项式的值，那么求$\sum_{j=i}^{n}qza_{j}\times qzb_{j}$就可以预处理$C_{k}$的前缀和即可$O(1)$求出。

至于$\sum_{j=i}^{n}qza_{i-1}\times qzb_{i-1}$其实就是$n-i+1$个$C_{i-1}$。

后面两项稍微思考一下也能得出。对于$\sum_{j=i}^{n}qza_{j}\times qzb_{i-1}$，其实$qzb_{i-1}$已经被确定，则这个式子就变成：

$$qzb_{i-1}\times\sum_{j=i}^{n}qza_{j}\qquad$$

我们发现只要预处理$qza_{j}$的前缀和即可，对于后面一项也是同理，预处理$qzb_{j}$的前缀和即可。

那么把以上东西结合一下，这题就解决了，其实还是不难的。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register
using namespace std;
const int N=500010,Mod=1e9+7;
int n,a[N],b[N],qza[N],qzb[N],qzc[N],A[N],B[N],C[N],ans;
inline int read()
{
	int s=0,w=1; register char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;
}
signed main()
{
    n=read();
	for(ri int i=1;i<=n;i++) a[i]=read(), qza[i]=(qza[i-1]+a[i])%Mod;
	for(ri int i=1;i<=n;i++) b[i]=read(), qzb[i]=(qzb[i-1]+b[i])%Mod;
    for(ri int i=1;i<=n;i++) C[i]=qza[i]*qzb[i]%Mod,qzc[i]=(qzc[i-1]+C[i])%Mod;
    for(ri int i=1;i<=n;i++) A[i]=(A[i-1]+qza[i])%Mod;
	for(ri int i=1;i<=n;i++) B[i]=(B[i-1]+qzb[i])%Mod;
    for(ri int i=1;i<=n;i++) ans=((ans+qzc[n]-qzc[i-1]+C[i-1]*(n-i+1)%Mod-qzb[i-1]*(A[n]-A[i-1])%Mod-qza[i-1]*(B[n]-B[i-1])%Mod+Mod)%Mod+Mod)%Mod;
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：lxy__ (赞：17)

考虑每个数 $a_i$ 对答案的贡献：若 $b$ 中存在一个区间 $[l,r]$ $(l≤i≤r)$，则该区间的和 $sum_{[l,r]}$ 必定会与 $a_i$ 相乘**恰好一次**，并对答案产生相应的贡献。

现在问题转化为：对于每个下标 $i$，求出 $b$ 中所有**包含该下标的区间**的 $sum$ 和（记为 $S_i$）。

>例如样例一，$b$ 中所有包含下标 $2$ 的区间为 $[1,2]$，$[1,3]$，$[2,2]$，$[2,3]$，它们的 $sum$ 值依次为 $3+4=7$，$3+4+5=12$，$4=4$，$4+5=9$。$S_2=7+12+4+9=32$。所以 $a_2$ 对答案产生的贡献为 $32*3=96$。

尝试用 $O(n)$ 的时间复杂度求出每个下标 $i$ 的 $S$ 值。设 $f_i$ 为 $b$ 中以 $i$ 为**左端点**的区间的 $sum$ 和，$g_i$ 为 $b$ 中以 $i$ 为**右端点**的区间的 $sum$ 和。得到递推式：

$f_i=f_{i+1}+b_i*(n-i+1)$

$g_i=g_{i-1}+b_i*i$

设位置 $i$ 的 $S$ 值为 $S_i$，有： $S_i=S_{i-1}+f_i-g_{i-1}$。其中 $g_{i-1}$ 表示两端都在 $i$ 左边的多余区间。

$ans=\sum_{i=1}^n$ $S_i*a_i$ 。总复杂度 $O(n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 2333333, mod = 1000000007;
long long n, ans = 0, g[N], f[N], S[N], a[N], b[N];
int main()
{
	scanf("%lld", &n);
	g[0] = S[0] = f[n + 1] = 0;
	for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	for(int i = 1; i <= n; i++) scanf("%lld", &b[i]);
	for(int i = n; i >= 1; i--)
		f[i] = (f[i + 1] % mod + (b[i] * (n - i + 1)) % mod) % mod;
	for(int i = 1; i <= n; i++)
		g[i] = (g[i - 1] % mod + (b[i] * i) % mod) % mod;
	for(int i = 1; i <= n; i++)
	{
		S[i] = (S[i - 1] + f[i] - g[i - 1] + mod) % mod;
		ans = (ans + (a[i] * S[i]) % mod) % mod;
	}
	printf("%lld", ans);
	return 0;
} 
```


---

## 作者：__CJY__ (赞：11)

## 题意简述
定义函数 $S(l,r)(1\le l\le r\le n)$ 为：
$$\sum_{i=l}^ra_i \times \sum_{i=l}^rb_i$$
请你求出下列式子的值：
$$\sum_{l=1}^n\sum_{r=l}^nS(l,r)$$
由于答案可能很大，你只需要给出答案模 $10^9+7$ 后的结果。
## 思路
首先尝试暴力，肯定会超时，所以我们要优化。

两重循环显然可以用前缀和表示，我们可以用前缀和优化程序的时间复杂度：我们用 $A(i)$ 表示 $a_i$ 的前缀和，用 $B(i)$ 表示 $b_i$ 的前缀和。

下面来推一波式子：
$$
\begin{aligned}
S(l,r)
&=\big[A(r)-A(l-1)\big] \times \big[B(r)-B(l-1)\big]\\
  &=A(r) \times B(r)+A(l-1) \times B(l-1)-A(r) \times B(l-1)-A(l-1) \times B(r)
\end{aligned}
$$
所以：
$$
\begin{aligned}
\sum_{l=1}^n\sum_{r=l}^nS(l,r)
&=\sum_{l=1}^n\sum_{r=l}^n\big[A(r) \times B(r)+A(l-1) \times B(l-1)-A(r) \times B(l-1)-A(l-1) \times B(r)\big]\\
&=\sum_{l=1}^n\sum_{r=l}^n\big[A(r) \times B(r)\big]+\sum_{l=1}^n\sum_{r=l}^n\big[A(l-1) \times B(l-1)\big]-\sum_{l=1}^n\sum_{r=l}^n\big[A(r) \times B(l-1)\big]-\sum_{l=1}^n\sum_{r=l}^n\big[A(l-1) \times B(r)\big]
\end{aligned}
$$
得到上面的公式后，我们来分析每一项，并用 $ans$ 来记录答案：

* 对于 $\sum\limits_{l=1}^n\sum\limits_{r=l}^nA(r) \times B(r)$：我们用 $SAB(i)$ 表示 $A(r) \times B(r)$ 的前缀和，所以 $ans+=\sum\limits_{l=1}^n\big[SAB(n)-SAB(l-1)\big]$。
* 对于 $\sum\limits_{l=1}^n\sum\limits_{r=l}^nA(l-1) \times B(l-1)$：$ans+=\sum\limits_{l=1}^n\big[(n-l+1) \times A(l-1) \times B(l-1)\big]$。
* 对于 $\sum\limits_{l=1}^n\sum\limits_{r=l}^nA(r) \times B(l-1)$：我们用 $SA(i)$ 表示 $A(r)$ 的前缀和，所以 $ans-=\sum\limits_{l=1}^n\big\{B(l-1) \times \big[SA(n)-SA(l-1)\big]\big\}$。
* 对于 $\sum\limits_{l=1}^n\sum\limits_{r=l}^nA(l-1) \times B(r)$：我们用 $SB(i)$ 表示 $B(r)$ 的前缀和，所以 $ans-=\sum\limits_{l=1}^n\big\{A(l-1) \times \big[SB(n)-SB(l-1)\big]\big\}$。

总时间复杂度为 $\Theta(n)$，可通过本题。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=5e5+5,mod=1e9+7;
ll n,a[maxn],b[maxn],A[maxn],B[maxn],SA[maxn],SB[maxn],SAB[maxn],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],A[i]=(A[i-1]+a[i])%mod;
	for(int i=1;i<=n;i++) cin>>b[i],B[i]=(B[i-1]+b[i])%mod;
	for(int i=1;i<=n;i++) SA[i]=(SA[i-1]+A[i])%mod,SB[i]=(SB[i-1]+B[i])%mod,SAB[i]=(SAB[i-1]+(A[i]*B[i])%mod)%mod;
	for(int i=1;i<=n;i++) ans=(ans+((SAB[n]-SAB[i-1])+mod)%mod)%mod;
	for(int i=1;i<=n;i++) ans=(ans+(((n-i+1)*A[i-1])%mod*B[i-1])%mod)%mod;
	for(int i=1;i<=n;i++) ans=((ans-(B[i-1]*((SA[n]-SA[i-1]+mod)%mod))%mod)+mod)%mod;
	for(int i=1;i<=n;i++) ans=((ans-(A[i-1]*((SB[n]-SB[i-1]+mod)%mod))%mod)+mod)%mod;
	cout<<ans;
}
```
注意：
* 十年 OI 一场空，不开`long long`见祖宗！
* 取模，有可能是负数的要先加`mod`再模`mod`。

写了那么一大段 $\LaTeX$，累死我了，可能有点问题，欢迎在评论区提出！点个赞吧！

---

## 作者：LCuter (赞：8)

$\text{csp}$失利，现在就到处水水……这道题真的就只有黄吗……看来我还是太菜了

## $\text{Description}$

给定$n$与序列$\{a_n\},\{b_n\}$，求

$$\sum_{l=1}^{n}\sum_{r=l}^{n}(\sum_{i=l}^{r}a_i\sum_{i=l}^{r}b_i)$$

## $\text{Solution}$

一个比较显然的想法是枚举区间然后暴力累加计算，这样时间复杂度是$O(n^3)$的，能拿到$\text{40pts}$。一个优化是，$O(n)$预处理两个序列的前缀和，这样对于计算区间答案的复杂度就可以降低至$O(1)$，总复杂度$O(n^2)$，就可以轻轻松松地水到$\text{70pts}$。要是这次$\text{csp}$……

做到这一步，可以发现去计算题目中的$S$的方向已经基本没有可优化余地了，毕竟如果题面特地把某个简单的可拆分的式子变成函数，大概率就是想让某些憨憨直接去计算那个函数，所以我们要考虑转化。

一个可行的方向是考虑贡献。我们注意到对于每一个区间，区间中的$a_i$都会给区间中的$b_j$贡献一次，这让我们容易想到去计算$a_i$对于$b_j$的贡献次数。也就是计算$l\le \min(i,j),r\ge\max(i,j)$的区间$[l,r]$的个数，为了使式子更加方便计算，我们分类讨论，若记此时的贡献为$Ans_{i,j}$，则

$$j\le i,Ans_{i,j}=j(n-i+1)$$

$$j > i,Ans_{i,j}=i(n-j+1)$$

这一步是计算左右端点可满足的方案，再利用乘法原理合并，注意，左右边界是可以等于$i,j$的。另外，我们计算的是次数，真正贡献的答案要乘上$a_ib_j$

根据上面得到的$a_i$对$b_j$的贡献，我们可以得到$a_i$对总答案的贡献，进一步的可以得到总答案

$$Ans=\sum_{i=1}^{n}a_i(\sum_{j=1}^{n}Ans_{i,j}b_j)$$

直接这么计算复杂度仍然是$O(n^2)$的，但是我们可以进一步转化式子

$$Ans=\sum_{i=1}^{n}a_i[(n-i+1)\sum_{j=1}^{i}j\times b_j+i(n+1)\sum_{j=i+1}^{n}b_j-i\sum_{j+1}^nj\times b_j]$$

上面这个式子是将$Ans_{i,j}$代入，然后将$\sum$中的定值提取到外面所得到的

计算$i(n+1)\sum_{j=i+1}^{n}b_j$是比较容易的，这个可以维护$\{b_n\}$的前缀和得到，那么其它两个呢？

我们构造一个新序列$\{c_n\},c_n=n\times b_n$，这是因为上面的式子中乘上的系数永远和$\{b_n\}$的下标相同，然后维护$\{c_n\}$的前缀和即可在$O(1)$时间内计算$a_i$对总答案的贡献，因此，我们得到了一个总复杂度为$O(n)$的算法，于是可以拿到$\text{100pts}$。当然，计算的时候符号不要搞错。这应该是一道思维题，码量比较小。

这道题给我们的启发是，按照题目所框定的求法不一定优秀，我们要找到合适的拆分合并方法去转化求法，这就是贡献法的精髓。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
#define MAXN 500005
#define LL long long
#define MOD 1000000007
using namespace std;
inline LL read(){
	REG LL x(0);
	REG char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=(x<<3LL)+(x<<1LL)+(c^48),c=getchar();
	return x;
}

int n;
LL a[MAXN];
LL sumb[MAXN],sumdb[MAXN];
LL ans;

int main(){
	n=read();
	for(REG int i=1;i<=n;++i) a[i]=read();
	for(REG int i=1;i<=n;++i){
		LL tmp=read();
		sumb[i]=(sumb[i-1]+tmp)%MOD;
		sumdb[i]=(sumdb[i-1]+tmp*(LL)i%MOD)%MOD;
	}
	for(REG int i=1;i<=n;++i){
		LL tmp=0;
		tmp=(tmp+(LL)(n-i+1)*sumdb[i]%MOD)%MOD;
		tmp=(tmp+(LL)i*(n+1)%MOD*(sumb[n]-sumb[i])%MOD)%MOD;
		tmp=(tmp-(LL)i*(sumdb[n]-sumdb[i])%MOD+MOD)%MOD;
		ans=(ans+tmp*a[i]%MOD)%MOD;
	}
	printf("%lld\n",ans);
}
```

---

## 作者：qhr2023 (赞：5)

## solution

推式子入门题。记序列长度为 $n$，两个给定序列的前缀和数组为 $a$ 和 $b$，$a$ 和 $b$ 的前缀和数组为 $A$ 和 $B$。

那么题目的 $S(l, r)$ 就是 $(a_r-a_{l-1}) \times (b_r-b_{l-1})$，展开是 $a_r \times b_r - a_r \times b_{l-1} - a_{l-1} \times b_r + a_{l-1} \times b_{l-1}$。

答案可以表示为 $$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_r - a_r \times b_{l-1} - a_{l-1} \times b_r + a_{l-1} \times b_{l-1}) \end{aligned}$$。

把式子拆开计算，其中 $$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_r + a_{l-1} \times b_{l-1}) \end{aligned}$$ 这一部分是好计算的：
$$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_r + a_{l-1} \times b_{l-1}) &= \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_r) + \sum_{l=1}^{n} \sum_{r=l}^{n} (a_{l-1} \times b_{l-1}) \\&= \sum_{i=1}^n (i \times a_i \times b_i) + \sum_{i=1}^n (i \times a_{n-i} \times b_{n-i}) \\&= \sum_{i=1}^n (i \times a_i \times b_i) + \sum_{i=1}^n ((n-i) \times a_i \times b_i) \\&= \sum_{i=1}^n ((i \times a_i \times b_i) + ((n-i) \times a_i \times b_i)) \\&= \sum_{i=1}^n (n \times a_i \times b_i) \\&= n \times \sum_{i=1}^n (a_i \times b_i) \end{aligned}$$

再考虑 $$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_{l-1}) \end{aligned}$$。

其中对于 $$\begin{aligned} \sum_{r=l}^{n} (a_r \times b_{l-1}) \end{aligned}$$ 这部分，$b_{l-1}$ 一定，$a_r$ 这部分是前缀和可以提前处理，这里计算是 $O(1)$ 的，这部分可以化简为 $b_{l-1} \times (A_n - A_{l-1})$。

因此 $$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_{l-1}) \end{aligned}$$ 可以线性解决：
$$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_r \times b_{l-1}) &= \sum_{l=1}^{n} (b_{l-1} \times (A_n - A_{l-1})) \\&= \sum_{i=1}^{n-1} (b_i \times (A_n - A_i)) \end{aligned}$$

同理 $$\begin{aligned} \sum_{l=1}^{n} \sum_{r=l}^{n} (a_{l-1} \times b_r) &= \sum_{i=1}^{n-1} (a_i \times (B_n - B_i)) \end{aligned}$$。

那么答案就是 $$\begin{aligned} n \times \sum_{i=1}^n (a_i \times b_i) - \sum_{i=1}^{n-1} (b_i \times (A_n - A_i))+(a_i \times (B_n - B_i)) \end{aligned}$$。

实现时注意取模。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+5, mod=1e9+7;
long long n, a[N], b[N], A[N], B[N], ans;
int main () {
	cin >> n;
	for (int i=1; i<=n; a[i]=(a[i]+a[i-1])%mod, ++i)	
		cin >> a[i];
	for (int i=1; i<=n; b[i]=(b[i]+b[i-1])%mod, ++i)	
		cin >> b[i];
	for (int i=1; i<=n; ++i)
		ans=(ans+n*1ll*a[i]%mod*b[i])%mod,
		A[i]=(a[i]+A[i-1])%mod,
		B[i]=(b[i]+B[i-1])%mod;
	for (int i=1; i<n; ++i) 
		ans=(ans-a[i]*(B[n]-B[i])%mod-b[i]*(A[n]-A[i])%mod+mod)%mod;
	cout << ans;
	return 0;
}
```

---

## 作者：abensyl (赞：4)

原题：[P5686 [CSP-S2019 江西] 和积和](https://www.luogu.com.cn/problem/P5686)。

有异于其他题解的做法，我采用的是**分治**的方式来解决这道题目。

## 思路
所谓分治，就是对于所求区间 $[l,r]$，取其中点 $mid=\frac{l+r}2$，分割成两个子区间 $[l,mid]$ 和 $(mid,r]$，分别计算两个子区间对答案的贡献，再计算所有 $l_0\in[l,mid]$，$r_0\in(mid,r]$，$[l_0,r_0]$ 对答案的贡献。 

不过，我们需要在 $l=r$ 时停止递归。

在本题中，在 $l=r$ 时，区间 $[i,i]$ 对于答案的贡献就是 $a_ib_i$；

对于区间 $[l,r]$，记函数 $s_a(l,r)=\sum^{r}_{i=l}a_i$，$s_b(l,r)=\sum^{r}_{i=l}b_i$，区间 $[l,r]$ 的和积，记为函数 $f(l,r)$，形象地：$f(l,r)=s_a(l,r)\times s_b(l,r)$。

根据初中数学乘法公式，$(a+b)(c+d)=ac+ad+bc+bd$。

考虑对于两个区间：$[l_0,mid]$ 和 $(mid,r_0]$（$l\leq l_0\leq mid$，$mid<r_0\leq r$），它们合并产生的和积，显然 $f(l_0,r_0)=s_a(l_0,mid)\times s_b(l_0,mid)+s_a(l_0,mid)\times s_b(mid+1,r_0)+s_a(mid+1,r_0)\times s_b(l_0,mid)+s_a(mid+1,r_0)\times s_b(mid+1,r_0)$，如果我们可以求出和积，那么求和积和也就简单了。

考虑维护预处理 $l_0$，显然应该从 $mid$ 到 $l$ 倒序枚举。求前缀和维护 $s_a(i,mid)$ 和 $s_b(i,mid)$，由于每个 $r_0$ 都可以和 $l_0\in[l,mid]$ 中的任意一个 $l_0$ 维护，所以我们要将 $s_a(i,mid)$ 和 $s_b(i,mid)$ 再次累加起来，同时，由于我们求的是和积的和，所以，每个 $[l_0,mid]$ 也可以独自对答案产生贡献，所有的 $[l_0,mid]$ 都会被包含在 $[l_0,r']$ 的和积中，而 $r'\in[mid+1,r]$，共 $r-mid$ 种取值，所以对答案的贡献就是 $s_a(l_0,mid)\times s_b(l_0,mid)\times(r-mid)$。

再考虑的就是枚举 $r_0$，同样处理出前缀和，在对前缀和求和，并且对于每个 $r_0$ 进行计算答案，首先，每个 $r_0$ 都可以自己对答案产生贡献，产生方式和 $l_0$ 相同，即 $s_a(mid+1,r_0)\times s_b(mid+1,r_0)\times(mid-l+1)$。

最终，两侧 $a$ 和 $b$ 前缀和的和记为 $suml_a$，$sumr_a$，$suml_b$，$sumr_b$，对答案产生的贡献就是 $suml_a\times sumr_b+sumr_a\times suml_b$。

采用分治，时间复杂度 $O(n\log n)$，代码简单，推式子少，思维难度较小，但是时间稍微慢一些。

**提示**：要开 long long，别忘了处处取模。

## 代码
```cpp
// author: syl
// language: c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e5+5, mod = 1e9+7;
int a[N],b[N],c[N];
int res=0;
void solve(int l,int r) {
	if(l==r) { res=(res+c[l])%mod; return; }
	int mid=l+r>>1,zca=0,zcb=0,sumal=0,sumbl=0;
	for(int i=mid;i>=l;--i) {
		zca=(zca+a[i])%mod;
		sumal=(sumal+zca)%mod;
		zcb=(zcb+b[i])%mod;
		sumbl=(sumbl+zcb)%mod;
		int lk=zca*zcb;
		res=(res+((zca*zcb)%mod)*(r-mid))%mod;
	} zca=0,zcb=0;
	int sumar=0,sumbr=0;
	for(int i=mid+1;i<=r;++i) {
		zca=(zca+a[i])%mod;
		sumar=(sumar+zca)%mod;
		zcb=(zcb+b[i])%mod;
		sumbr=(sumbr+zcb)%mod;
		res=(res+((zca*zcb)%mod)*(mid-l+1))%mod;
	} res=(res+sumal*sumbr+sumar*sumbl)%mod;
	solve(l,mid),solve(mid+1,r);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr),
	cout.tie(nullptr);
	int n; cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1;i<=n;++i) cin>>b[i];
	for(int i=1;i<=n;++i) c[i]=(a[i]*b[i])%mod;
	solve(1,n);
	cout<<res%mod<<'\n';
	return 0;
}
```

我的 [AC 记录](https://www.luogu.com.cn/record/142009132)。

---

## 作者：grard4 (赞：2)

## 题意简述

给定长度为 $n$ 的数列 $\{a_n\}$ 和 $\{b_n\}$，求出下列式子的值：
$$
\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(\sum_{i=l}^r a_i\times \sum_{i=l}^r b_i)
$$
输出答案模 $10^9+7$ 后的结果。

## 思路
解法 1：直接根据题意暴力求和，即可 $O(n^3)$ 得到答案。

期望得分：$40$ pts。

解法 2：令 $S_n=\large\sum\limits_{i=1}^n a_i$，$T_n=\large\sum\limits_{i=1}^n b_i$，即为 $a_i$，$b_i$ 的前缀和。于是原式可化为：
$$
\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_r-S_{l-1})(T_r-T_{l-1})
$$
其中 $S_n$，$T_n$ 可以 $O(n)$ 求出，时间复杂度降为 $O(n^2)$。

期望得分：$70$ pts。

解法 3：考虑将式子继续化简。
$$\begin{aligned}
\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_r-S_{l-1})(T_r-T_{l-1})&=\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_rT_r+S_{l-1}T_{l-1}-S_rT_{l-1}-S_{l-1}T_r)\\
&=\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_rT_r+S_{l-1}T_{l-1})-\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_rT_{l-1}+S_{l-1}T_r)
\end{aligned}$$
考虑式子左边：在这个式子中，每个 $l$ 共出现了 $n-l+1$ 次，每个 $r$ 共出现了 $r$ 次。于是
$$\begin{aligned}
\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_rT_r+S_{l-1}T_{l-1})&=\large\sum\limits_{l=1}^n(n-l+1)S_{l-1}T_{l-1}+\sum\limits_{r=1}^nrS_rT_r\\
&=\large\sum\limits_{l=0}^{n-1}(n-l)S_lT_l+\sum\limits_{r=1}^nrS_rT_r\\
&=\large\sum\limits_{i=1}^{n-1}(n-i)S_iT_i+\sum\limits_{i=1}^{n-1}iS_iT_i+nS_nT_n\\
&=\large\sum\limits_{i=1}^{n-1}nS_iT_i+nS_nT_n\\
&=\large\sum\limits_{i=1}^nnS_iT_i=n\large\sum\limits_{i=1}^nS_iT_i
\end{aligned}$$
考虑式子右边：
$$\begin{aligned}
\large\sum\limits_{l=1}^n\sum\limits_{r=l}^n(S_rT_{l-1}+S_{l-1}T_r)&=\large\sum\limits_{l=1}^{n-1}\sum\limits_{r=l+1}^n(S_rT_l+S_lT_r)\\
&=\large\sum\limits_{l=1}^{n-1}\sum\limits_{r=l+1}^nS_rT_l+\large\sum\limits_{l=1}^{n-1}\sum\limits_{r=l+1}^nS_lT_r+\sum\limits_{i=1}^nS_iT_i-\sum\limits_{i=1}^nS_iT_i\\
&=\large\sum\limits_{i=1}^n\sum\limits_{j=1}^nS_iT_j-\sum\limits_{i=1}^nS_iT_i\\
&=\large(\sum\limits_{i=1}^nS_i)(\sum\limits_{i=1}^nT_i)-\sum\limits_{i=1}^nS_iT_i
\end{aligned}$$
所求的最终结果为：
$$
\large n\sum\limits_{i=1}^nS_iT_i-\large(\sum\limits_{i=1}^nS_i)(\sum\limits_{i=1}^nT_i)+\sum\limits_{i=1}^nS_iT_i=(n+1)\sum\limits_{i=1}^nS_iT_i-(\sum\limits_{i=1}^nS_i)(\sum\limits_{i=1}^nT_i)
$$
其中 $S_iT_i$，$\sum\limits_{i=1}^nS_i$，$\sum\limits_{i=1}^nT_i$，也可以 $O(n)$ 求出。

经过一系列的化简，总的时间复杂度降为了 $O(n)$。

期望得分：$100$ pts。

代码在这里：

```cpp
#include<bits/stdc++.h>
#define MAXN 500005
#define ll long long
using namespace std;
const int mod=1e9+7;
int n,a;ll ss,tt,st,s[MAXN],t[MAXN];
int main(){
    cin>>n;
    for (int i=1;i<=n;i++) cin>>a,s[i]=(s[i-1]+a)%mod,ss=(ss+s[i])%mod;
    for (int i=1;i<=n;i++) cin>>a,t[i]=(t[i-1]+a)%mod,tt=(tt+t[i])%mod;
    for (int i=1;i<=n;i++) st=(st+s[i]*t[i])%mod;
	ss=ss*tt%mod,st=st*(n+1)%mod;
    cout<<(st-ss+mod)%mod;
	return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

我们看到求和可以想到前缀和，考虑 $sa,sb$ 分别是 $a,b$ 的前缀和数组。

$$S(l,r)=(sa_r-sa_{l-1})\times (sb_r-sb_{l-1})$$。

展开以后我们发现 $sa,sb$ 自己的相乘是正的，分别相乘是负的。

先考虑自己相乘。$sa_i\times sb_i$ 会在 $l=i+1$ 且 $r$ 是 $i+1\sim n$ 时出现，共 $n-i$ 次；也会在 $r=i$ 且 $l$ 是 $1\sim i$ 时出现 $i$ 次（两者可以合并为 $n$ 次，但我比较懒）。

$sa_r\times sb_{l-1}$ 的部分就是 $sa_r\times \sum\limits_{l=1}^{r-1}$（后半部分维护 $sb$ 的前缀和 $ssb$）。

$sa_{l-1}\times sb_r$ 的也同理，就不细说了，维护 $sa$ 的前缀和 $ssa$ 就行了。

代码头上的注释是考试时写的，可以忽略。

## 代码实现

```cpp
/*

s(l,r):

	(sa[r]-sa[l-1])(sb[r]-sb[l-1])

-sa[l-1]*sb[r]-sa[r]*sb[l-1]+sa[r]*sb[r]+sa[l-1]*sb[l-1]

/////////////

sa[all]*sb[all]*(all)*(n-all+1);

////////////

sb[r]*(sa[r-1]+sa[r-2]+sa[r-3]+sa[r-4]+...+sa[1])

sa[r]*(sb[r-1]+sb[r-2]+sb[r-3]+sb[r-4]+...+sb[1])

///////////

sb[r]*ssa[r-1]

sa[r]*ssb[r-1]

*/

#include<bits/stdc++.h>

#define int long long 

using namespace std;

constexpr int N=5e5+1,p=1e9+7;

int n,a[N],b[N],sa[N],sb[N],ssa[N],ssb[N],ans;

signed main(){

    cin>>n;

    for(int i=1;i<=n;i++){

        cin>>a[i];

        sa[i]=sa[i-1]+a[i],sa[i]%=p;

        ssa[i]=ssa[i-1]+sa[i],ssa[i]%=p;

    }

    for(int i=1;i<=n;i++){

        cin>>b[i];

        sb[i]=sb[i-1]+b[i],sb[i]%=p;

        ssb[i]=ssb[i-1]+sb[i],ssb[i]%=p;

    }

    for(int i=1;i<=n;i++)

        ans+=sa[i]*sb[i]%p*i,ans%=p;

    for(int i=1;i<=n;i++)

        ans+=sa[i]*sb[i]%p*(n-i),ans%=p;

    for(int i=1;i<=n;i++){

        ans-=sa[i]*(ssb[i-1])%p;

        ans%=p;

        ans-=sb[i]*(ssa[i-1])%p;

        ans%=p;

    }

    cout<<(ans%p+p)%p;

    return 0;

}
```

---

## 作者：jiangby2011 (赞：1)

#  前言
其实题解区都写得很好,只是对于数学新手有些难以理解。

所以我将详细讲述这道题的每一个步骤与解题过程。
# 正文
读题，看起来十分朴素的求和。

很明显的，这是前缀和优化题，可以通过前缀和优化。

那么我们先正常做。
##  前缀和代码


```cpp
#include <bits/stdc++.h>
#define ll long long
#define ri register
using namespace std;
const int maxn=5e5+7;
const int mod=1e9+7;
int n;
ll a[maxn],b[maxn];
ll sum1[maxn],sum2[maxn];
ll ans;
inline ll f(int l,int r)
{
	return ((sum1[r]-sum1[l-1])*(sum2[r]-sum2[l-1]))%mod;
//直接模拟题意中的S函数
}
int main()
{
	cin>>n;
	for(ri int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum1[i]=sum1[i-1]+a[i];//前缀和处理a，b
	}
	for(ri int i=1;i<=n;i++)
	{
		cin>>b[i];
		sum2[i]=sum2[i-1]+b[i];
	}
	for(ri int i=1;i<=n;i++)
	{
		for(ri int j=i;j<=n;j++)
		{
			ans+=f(i,j);
			ans%=mod;
		}
	}
	cout<<ans%mod;
	return 0;
}
```
可以拿到 70pts,看来 CCF 的数据还是不错滴。

这个时候我们发现函数部分已经没有进步空间了，那么如何优化呢？

我有一计，根据多年初中~~被代数大题薄纱~~所学的代数大题，遇到这种东西，可以把这个目标式子展开，看看有什么发现。

我们选择把这个函数范围的右端固定，如果展开出来的式子可以预处理，求值就变成了 $O(1)$，那么可以用 $O(n)$ 复杂度解决问题。

$$
suma_i = \sum_{j = 1}^{i} a_j
$$
$$
sumb_i = \sum_{j = 1}^{i} b_j
$$


$$
ans_r = \sum_{l = 0}^{r-1} (suma_r-suma_l)\times (sumb_r-sumb_l)
$$


展开后：

$$
ans_r = \sum_{l = 0}^{r-1} ((suma_r\times sumb_r)-(suma_l\times sumb_r)-(sumb_l\times suma_r)+(suma_l\times sumb_l))
$$
(这个式子很重要，后面看不懂可以回来对照)

还没完，我们的求值到这依然是 $O(n)$ 的，接下来我们把这四项分别处理一下。
#### 第一项

因为在这个式子中，$r$ 不变，所以每次求和，多项式第一项始终都是这个值，一共 $r$ 次相加，所以在处理后它就变成   

$$r\times suma_r\times sumb_r$$
#### 第二项
乘法分配律得值为  
$$
suma_r\times  \sum_{l = 0}^{r-1} sumb_l
$$

显然这个求和是可以前缀和预处理的。

#### 第三项
同第二项,数组反过来而已。
#### 第四项

和正常前缀和一样，新开一个数组维护乘积的和

### 最终求值公式
$$
sumaa_i = \sum_{j = 0}^{i-1} suma_j
$$

$$
sumbb_i = \sum_{j = 0}^{i-1} sumb_j
$$

$$
sumc_i= \sum_{j=0} ^{i-1} (suma_j\times sumb_j)
$$
$$
  ans_r = ((r\times suma_r\times sumb_r)+sumc_r-(sumb_r\times sumaa_r)-(suma_r\times sumbb_r))
$$

求值时间复杂度 $O(1)$，式子可以预处理
总复杂度为 $O(n)$。

魔性取模不多评价，总之就是一步一取模。

那么上代码。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ri register
using namespace std;
const int maxn=5e5+7;
const int mod=1e9+7;
int n;
ll anss;
ll a[maxn],b[maxn];
ll suma[maxn],sumb[maxn];
ll sumaa[maxn],sumbb[maxn],sumc[maxn];
ll ans[maxn];
int main()
{
	cin>>n;
	for(ri int i=1;i<=n;i++)
	{
		cin>>a[i];
		suma[i]=(suma[i-1]+a[i])%mod;
		sumaa[i]=(sumaa[i-1]+suma[i])%mod;
	}
	for(ri int i=1;i<=n;i++)
	{
		cin>>b[i];
		sumb[i]=(sumb[i-1]+b[i])%mod;
		sumbb[i]=(sumbb[i-1]+sumb[i])%mod;
		sumc[i]=(sumc[i-1]+suma[i]*sumb[i])%mod;//一堆预处理不解释
	}
	for(ri int r=1;r<=n;r++)
	{
		ans[r]=((r*suma[r]%mod*sumb[r])%mod+sumc[r-1]%mod-(sumb[r]*sumaa[r-1])%mod-(suma[r]%mod*sumbb[r-1])%mod);
	}
	for(ri int i=1;i<=n;i++)
	{
		anss=(anss%mod+ans[i]+mod)%mod;//求和
	}
	cout<<anss%mod;
	return 0;
}
```
不吸氧 820ms，比较稳。

## The End_

---

## 作者：analysis (赞：1)

### P5686 [CSP-S2019 江西] 和积和  

---

对于题中给出的第一个式子，显然其意义是在给定区间中的两序列中各选数一个，所有方案的权值和，然后对于所有区间都求一次。

可以先交换下顺序，先选完两个数，再来决定区间。对于选的两个数 $a_l$、$b_r$ 或是 $b_l$、$a_r$，区间的方案数是 $l(n-r+1)$。

为了方便，先处理掉 $l=r$，容易做到 $O(n)$，剩下的情况 $l<r$。

为了方便，钦定选 $a_l$、$b_r$，只要之后交换两序列再求一次即可，时间复杂度多个 $2$ 的常数。

于是问题变成了 $\sum_{l<r}l(n-r+1)a_lb_r= \sum_{l<r}(n+1)(la_l)b_r-\sum_{l<r}(la_l)(rb_r)$。

从后往前扫一遍枚举 $l$，维护 $\sum b_r$ 和 $\sum rb_r$ 即可。

```cpp
#include<bits/stdc++.h>
const int mod=1e9+7;
void add(int &x,int y){(x+=y)>=mod&&(x-=mod);}
void sub(int &x,int y){(x-=y)<0&&(x+=mod);}
using namespace std;
int n,a[500005],b[500005],ans;
int sol(){
    int res=0,b0=0,br=0;
    for(int l=n;l>=1;l--){
        add(res,1ll*(n+1)*a[l]%mod*l%mod*b0%mod);
        sub(res,1ll*a[l]*l%mod*br%mod);
        add(b0,b[l]);
        add(br,1ll*b[l]*l%mod);
    }
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cout.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    ans=(ans+sol())%mod;swap(a,b);ans=(ans+sol())%mod;
    for(int i=1;i<=n;i++)add(ans,1ll*i*(n-i+1)%mod*a[i]%mod*b[i]%mod);
    cout<<ans;
    return 0;
}
```

---

## 作者：ty_mxzhn (赞：1)

科普一下组合意义吧。

# 组合意义

组合意义有很多种。在这题中我们可以用最简单的方法：用计数原理把计算一个式子的题目变成计算方案数。

# 转化

考虑原式子。$S(l,r)$ 要求我们求出 $\displaystyle (\sum_{i=l}^r a_i) \times (\sum_{i=l}^r b_i)$。

组合的转化便是从 $[l,r]$ 中选出两个位置 $i,j$，在 $a$ 上选每个位置有 $a_i$ 种选法（有 $a_i$ 个孔），$b$ 上同理。

# 变换

整理一下我们要干什么。我们要先选一个区间，再从里面选数。

变换一下，先选两个点 $i,j$ 再选一个包含这两点的区间。

枚举一个点 $i$，分类讨论 $j$ 和 $i$ 的位置关系。

对于 $j<i$ 答案为 $a_i(n-i+1)\displaystyle \sum_{j=1}^{i-1} jb_j$ 这个显然直接前缀和递推即可。另一边同理。

# 拓展

其实是为了这个拓展才来写黄题题解的。

有 $q$ 个操作是区间加 $a_{[l,r]}$，操作后求全局答案。

这个加强并不难。在刚才我们算出了每个 $a_i$ 在答案中的系数，我们接下来只需要在区间加的时候按照系数增加答案即可。一个前缀和就可以了。

这样加强以后应该还是黄题。

---

## 作者：Claire0918 (赞：1)

记 $\displaystyle s_i = \sum_{k = 1}^{i} a_k, t_i = \sum_{k = 1}^{i} b_k$。这可以 $\mathcal{O}(n)$ 得到。

有 
$$
\begin{aligned}
& S(l, r)\\
&= \sum_{i = l}^{r}a_i \times \sum_{i = l}^{r} b_i\\
&= (s_r - s_{l - 1})(t_r - t_{l - 1})\\
&= s_rt_r + s_{l - 1}t_{l - 1} - s_rt_{l - 1} - t_rs_{l - 1}
\end{aligned}
$$

答案为
$$
\begin{aligned}
& \sum_{l = 1}^{n} \sum_{r = l}^{n} S(l, r)\\
&= \sum_{l = 1}^{n} \sum_{r = l}^{n} s_rt_r + s_{l - 1}t_{l - 1} - s_rt_{l - 1} - t_rs_{l - 1}\\
&= \sum_{l = 1}^{n} \sum_{r = l}^{n} s_rt_r + \sum_{l = 1}^{n} \sum_{r = l}^{n} s_{l - 1}t_{l - 1} - \sum_{l = 1}^{n} \sum_{r = l}^{n} s_rt_{l - 1} -\sum_{l = 1}^{n} \sum_{r = l}^{n} t_rs_{l - 1}\\
&= \sum_{r = 1}^{n} rs_rt_r + \sum_{l = 1}^{n} (n - l + 1)s_{l - 1}t_{l - 1} -  \sum_{r = 1}^{n} s_r \sum_{l = 1}^{r} t_{l - 1} - \sum_{r = 1}^{n} t_r \sum_{l = 1}^{r} s_{l - 1}\\
\end{aligned}
$$
前两项是可以直接 $\mathcal{O}(n)$ 求出的，后两项在枚举 $r$ 时维护 $sum$ 记录后面有关 $l$ 的和式即可。

总时间复杂度 $\mathcal{O}(n)$。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

const int maxn = 5e5 + 10, mod = 1e9 + 7;

int n, res = 0;
int a[maxn], b[maxn], s[maxn], t[maxn];

template<typename Tp_x, typename Tp_y>
inline int mod_add(Tp_x x, Tp_y y){
	x += y;
	return x >= mod ? x -= mod : x;
}

int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		s[i] = mod_add(s[i - 1], a[i]);
	}
	for (int i = 1; i <= n; i++){
		scanf("%d", &b[i]);
		t[i] = mod_add(t[i - 1], b[i]);
	}
	for (int i = 1; i <= n; i++){
		res = mod_add(res, (long long)s[i] * t[i] % mod * i % mod);
	}
	for (int i = 1; i <= n; i++){
		res = mod_add(res, (long long)s[i - 1] * t[i - 1] % mod * (n - i + 1) % mod);
	}
	for (int i = 1, sum = 0; i <= n; i++){
		res = mod_add(res, mod - (long long)s[i] * (sum = mod_add(sum, t[i - 1])) % mod);
	}
	for (int i = 1, sum = 0; i <= n; i++){
		res = mod_add(res, mod - (long long)t[i] * (sum = mod_add(sum, s[i - 1])) % mod);
	}
	printf("%d", res);

return 0;
}
```

---

## 作者：algo_h (赞：0)

注意到：

$$
\begin{split}
\sum_{l=1}^{n}\sum_{r=l}^{n}\sum_{i=l}^{r}\sum_{j=l}^{r}a_ib_j
&=
\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{l=1}^{\min\{i, j\}}\sum_{r=\max\{i, j\}}^{n}a_ib_j
\\&=
\sum_{i=1}^{n}\sum_{j=1}^{n}\min\{i, j\}(n - \max\{i, j\} + 1)a_ib_j
\\&=
\sum_{i=1}^{n}(n - i + 1)a_i\sum_{j=1}^{i}jb_j
+
\sum_{i=1}^{n}ia_i\sum_{j=i + 1}^{n}(n - j + 1)b_j
\\&=
\sum_{i=1}^{n}(n - i + 1)a_i\sum_{j=1}^{i}jb_j
+
\sum_{j=1}^{n}(n - j + 1)b_j\sum_{i=1}^{j - 1}ia_i
\end{split}
$$

迭代计算即可（下面的代码假设数组下标从 $0$ 至 $n - 1$）：

```
int s = 0, t = 0;
for(int i = 0; i < n; ++i) {
  t = (t + ll(i + 1) * B[i]) % MOD;
  s = (s + ll(n - i) * A[i] % MOD * t) % MOD;
}
t = 0;
for(int i = 0; i < n; ++i) {
  s = (s + ll(n - i) * B[i] % MOD * t) % MOD;
  t = (t + ll(i + 1) * A[i]) % MOD;
}
```

---

## 作者：Lian_zy (赞：0)

### [题目链接](https://www.luogu.com.cn/problem/P5686)

首先遇到这种题不要慌，可以先转化为前缀和，$A$ 是 $a$ 的前缀和，$A$ 是 $b$ 的前缀和，于是式子变成：

$$\sum_{i=l}^r (A_r-A_{l-1})\times \sum_{i=l}^r (B_r-B_{l-1})$$

拆开，变成：

$$\sum_{i=l}^{r}(A_r\times B_r-A_r\times B_{l-1}-B_r\times A_{l-1}+A_{l-1}\times B_{l-1})$$

我们首先枚举一个端点，此处枚举的是 $r$，当然 $l$  应该也能做，不过可能会难想一点。

对于每一个 $r$，对答案的贡献是：

$$r\times A_r\times B_r-A_r\times\sum_{l=1}^{r}B_{l-1}-B_r\times\sum_{l=1}^{r}A_{l-1}+\sum_{l=1}^{r}A_{l-1}\times B_{l-1}$$

对于 $\sum_{l=1}^{r}B_{l-1}$、$\sum_{l=1}^{r}A_{l-1}$ 和 $\sum_{l=1}^{r}A_{l-1}\times B_{l-1}$ 这种直接预处理一下前缀和就可以做到 $O(1)$ 复杂度了。

于是就做完了，时间复杂度 $O(n)$。
### 代码

``` cpp
#include<bits/stdc++.h>
#define N 500005
#define ll long long
#define mod 1000000007
using namespace std;

ll n,ans,a[N],b[N],sa[N],sb[N],qja[N];
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
    	scanf("%lld",a+i);
    	a[i]+=a[i-1];
    	a[i]%=mod;
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",b+i);
		b[i]+=b[i-1];
		b[i]%=mod;
	}
	for(int i=1;i<=n;i++){
		sa[i]=(sa[i-1]+a[i])%mod;
		sb[i]=(sb[i-1]+b[i])%mod;
	}
	for(int i=1;i<=n;i++)qja[i]=(qja[i-1]+(a[i]*b[i])%mod)%mod;
	for(int i=1;i<=n;i++){
		ans=(ans+((i*a[i])%mod*b[i])%mod)%mod;
		ans=(ans-((a[i])%mod*sb[i-1])%mod+mod)%mod;
		ans=(ans-((sa[i-1])%mod*b[i])%mod+mod)%mod;
		ans=(ans+qja[i-1])%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


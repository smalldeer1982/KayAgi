# [JSOI2010] 排名

## 题目背景

在植树节那天，小 L，小 H，小 X 却要面对繁忙的考试。

考完后，按照惯例，他们讨论起了成绩。小 L 非常八卦，他向全班 $N$ 个同学问了他们的成绩情况。当然，就如你想象的那样，每个人也不愿意透露太多信息，每个人只说了他的分数比哪一个同学低，也有些人没说任何信息。

勤奋的小 H 和爱偷懒的小 X 对于班上所有同学的成绩排名都有一个“心理期望”，也就是说，小 H 可能认为 XX 会排第 $1$，YY 会排第 $2$……但小 X 却会认为 XX 应该排最后 $1$ 名，YY 会排倒数第 $2$ 名。

不过理想和现实总是有差距的，通过小 L 打探到的情报， XX 不能排在第 $1$ 了，但是，小 H 仍然觉得 XX 应该排在尽可能前。

小 L 由此想到了一个问题，他想知道小 H 和小 X 知道他打探到的情报之后，对班上同学的心里排名是什么样的。

每个同学的编号即为小 H 的心理排名，也就是说，小 H 希望编号越靠前的同学排名也尽量靠前，而小 X 希望希望编号越靠前的同学排名尽量靠后。（注意不是越后面的同学排名越靠前）

## 题目描述

给定一个长度为 $N$ 的数列 $A$，其中 $A_i$ 表示第 $i$ 个同学的分数比第 $A_i$ 个同学的分数低（或者说，第 $i$ 个同学的排名在第 $A_i$ 个同学之后）。当然，$A_i$ 有可能等于 $0$，则表明没有关于第 $i$ 个同学的信息。

你需要得到一个长度为 $N$ 的数列 $H$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最小的哪一个。

同时，你还需要得到一个数列 $X$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最大的哪一个。

## 说明/提示

### 样例解释

共有 $3$ 种排名满足大小关系：

```plain
4 1 3 2
4 1 2 3
3 1 2 4
```

其中，`3 1 2 4` 字典序最小，`4 1 3 2` 字典序最大。

### 数据范围

对于 $10\%$ 的数据，$N\leq 10$。

对于 $20\%$ 的数据，$N\leq 20$。

对于 $40\%$ 的数据，$N\leq 2\times 10^3$。

对于 $100\%$ 的数据，$1 \leq N\leq 2\times 10^5,A_i\leq N$。其中，第 $5$ 组数据保证 $N=1.2\times 10^4$。

## 样例 #1

### 输入

```
4
3 0 2 2```

### 输出

```
3 1 2 4
4 1 3 2```

# 题解

## 作者：hepp (赞：4)

****这两个小题的解法不相同！****
### 我们先看第一小题。

每个人都最多只有一个已知的比他成绩好的，我们可以把比他成绩好的人看做他的父节点，这样，我们就得到了一棵树。而这棵树的根节点是 0。

看样例，要使编号小的排在前面，我们一开始先考虑 1（不惜一切代价将未放入的编号最小的放入）， 1 的祖先有 3,2 。要放入 1，就必须先放入 2,3 （他的所有祖先）。所以，现在的排名是：

NO.1 2 号	

NO.2 3 号

NO.3 1 号

1,2,3 号都已排名，还剩一个 4，4 的祖先 2 已经在队伍中，所以他可以直接进入，最终排名 2 3 1 4。按照题目的排列方式（第 $i$ 个数输出 $i$ 的名次）答案是  3 1 2 4 。

代码如下：
```c
#include<bits/stdc++.h>
using namespace std;
const int N=1e5*2+10;
int ans[N],a[N],cur=0;
//ans[i]指第i名的名次，a[i]是第i人的祖先，cur代表队伍中的人数。
int pm(int x)
{
    if(ans[x]!=-1)//x以及x的祖先已经入队了
        return cur;
    else
        return ans[x]=pm(a[x])+1;//递推，x是他的祖先的下一个
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=0;i<=n;i++)
        ans[i]=-1;
    ans[0]=0;
    //初始化
    for(int i=1;i<=n;i++)
    {
        if(ans[i]==-1)//如果他还没有进队
        {
           ans[i]=pm(i);//让他进队
           cur=ans[i];//现在有ans[i]个人在队伍中
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    printf("\n");
    return 0;
}
```
### 第二小题
如题目所述，让编号前的同学靠后不等于编号后的同学靠前。（例如 4 0 0 0 1 应该得出的是 3 2 4 1 而不是 1 4 3 2 ） 我们在第一题时是从多点到根点，而这一题我们需要从根点到多点，类似于 bfs 和拓扑。

还是样例。与 0 联通的只有 2，所以我们只能请 2 入队。 2 入队后，他的儿子便可以入队了。他的儿子有 3,4 两位，但我们要让编号小的后入队，所以 4 先入队，接着是 3。3 的儿子——1 也解禁并入队，最终排名 2 4 3 1，答案是 4 1 3 2。

转化为代码如下：
```c
#include<bits/stdc++.h>
using namespace std;
const int N=1e5*2+10;
priority_queue<int> q;//优先队列，编号大的在前
int cnt[N],a[N],cur=0;
vector<int>g[N];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        g[a[i]].push_back(i);
    }
    //标注出每个人的所有儿子
    for(int i=0;i<=n;i++)
        cnt[i]=-1;
    //初始化
    q.push(0);
    //与0点联通的点（没有父节点）可以进队
    while(q.size())
    {
        int u=q.top();
        q.pop();
        cnt[u]=cur;
        cur++;
        //在队伍中编号最大的出队并获取排名
        for(int i=0;i<g[u].size();i++)
            q.push(g[u][i]);
        //u的儿子也可以获取排名了
    }
    for(int i=1;i<=n;i++)
        printf("%d ",cnt[i]);
    return 0;
}
```

---

## 作者：_WHX985_ (赞：2)

## 前言
这道题分为两个问，想要过这道题需要先了解一个算法 STL。不会的谷友们建议去学一下，这对你以后的编程生涯会非常有用。

[STL 学习链接](http://jpk.pku.edu.cn/course/sjjg/shixi/zhinan/DSProj_06STLCol.pdf)
## 正文
前言已经说了，这题分为两个问，我们可以分开讨论。
先来看第一个问，第一个问可以直接使用 STL 中的优先队列和拓扑排序，优先队列就相当于一个堆，分为大根堆和小根堆，大根堆指父亲节点一定比孩子节点大，而小根堆指父亲节点一定比孩子节点小。下面左图为大根堆，右图为小根堆。
![](https://cdn.luogu.com.cn/upload/image_hosting/rzm9fvkl.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/5ugin6bi.png)
对于第二个问，和第一个问很像，只需用大根堆维护拓扑排序即可。

---

## 作者：Jimmy_Cao (赞：1)

# 题意
题目很简单，用优先队列维护拓扑序即可。
但是他要我们求的东西比较诡异，导致贪心的策略会不同。

对于第一问，我们一般的思路是直接维护正的拓扑序，每次选最小的更新。
```cpp
for(int i = 1; i <= n; i++)
	if(!deg[i]) q.push(i);
while(!q.empty()) {
	int u = q.top(); q.pop();  
	ans[u] = cnt--;
	if(!(--deg[a[u]])) q.push(a[u]); 
}
``````
但这样不一定是最优的，因为选择了当前最小的可能使得更小的拓扑序排在后面，这样字典序就不一定是最小的了，所以我们维护反的拓扑序，每次选最大的更新。

第二问可以直接用大根堆维护正的拓扑序就行了。
```cpp
for(int i = 1; i <= n; i++)
	if(!in[i]) q.push(i); 
while(!q.empty()) {
	int u = q.top(); q.pop();
	ans[u] = ++cnt; 
	for(int v, i = head[u]; i; i = e[i].nxt) {
	    v = e[i].to;
	    q.push(v); 
	}
}
``````
# 完整代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
const int N = 200005; 
using namespace std;

int n, a[N], deg[N], in[N], ans[N], head[N], cnt;
struct edge { int to, nxt; } e[N];
priority_queue<int> q; 

template < typename T >
inline T read() {
    T x = 0, w = 1; char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * w; 
}

inline void adde(int u, int v) { e[++cnt] = (edge) { v, head[u] }, head[u] = cnt; }

int main(){
    n = read <int> ();
    for(int i = 1; i <= n; i++) {
		a[i] = read <int> ();
		if(a[i]) adde(a[i], i), deg[a[i]]++, in[i]++; 
    }
    cnt = n; 
    for(int i = 1; i <= n; i++)
		if(!deg[i]) q.push(i);
    while(!q.empty()) {
		int u = q.top(); q.pop();  
		ans[u] = cnt--;
		if(!(--deg[a[u]])) q.push(a[u]); 
    }
    for(int i = 1; i <= n; i++) printf("%d%c", ans[i], i == n ? '\n' : ' '); 
    
    cnt = 0;
	for(int i = 1; i <= n; i++)
		if(!in[i]) q.push(i); 
	while(!q.empty()) {
		int u = q.top(); q.pop();
		ans[u] = ++cnt; 
		for(int v, i = head[u]; i; i = e[i].nxt) {
		    v = e[i].to;
		    q.push(v); 
		}
	}
    for(int i = 1; i <= n; i++)
	printf("%d%c", ans[i], i == n ? '\n' : ' '); 
    return 0; 
}
``````

---

## 作者：LiYomi (赞：1)

### 题目实则是两个问题
1. 编号越靠前的同学排名也尽量靠前。
2. 编号越靠前的同学排名尽量靠后（注意不是越后面的同学排名越靠前）。

### 问题 1 分析
首先，根据题目表述的成绩大小，我们很容易想到拓扑排序。

同学 $a$ 的成绩小于同学 $b$ 的成绩，可以连边 $b \to a$，这时直觉上告诉我们，越靠近根节点的排名应该越靠前（~~废话成绩高啊~~）。

大家最喜欢的图解捏，考虑下边这样一张图：
![](https://s1.ax1x.com/2023/01/31/pSwIzxH.png)

首先 $1$ 应该成绩最高，其次，我们发现 $3$ 和 $4$ 和 $(5,2)$ 三部分的排名高低是不绝对的，也就是说可能编号 $3$ 成绩大于编号 $4$，编号 $3$ 大于编号 $5$，或者编号 $5$ 大于编号 $3$，当然后面的 $2$ 和 $3$ 的绝对大小也是不确定的。

根据问题 $1$ 的题意，我们应该优先让边好考前的同学成绩靠前。那么我们就需要让 $2$ 的成绩排名考前，沿着 $5$ 去找 $2$。再找 $3$，再找 $4$。

那么我们就需要维护每个节点能够到达的编号最小的节点，优先去找编号最小节点的位置。假设节点 $i$ 维护的 $dp[i]$（能到达的编号最小的位置），那么我们用一个优先队列维护 $dp[i]$ 就可以了，节点出队的次序就是成绩的顺序。

```cpp
int dfs(int x)
{
	for(int i=0;i<v[x].size();i++) dp[x]=min(dp[x],dfs(v[x][i]));
	return dp[x];
}

...

bool getmin(int x,int y)
{
	return dp[x]>dp[y];
}
priority_queue<int,vector<int>,decltype(&getmin)>pmin(getmin);
```

### 问题 2 分析
编号靠前的同学排名尽可能靠后，能不能维护一个 $dp[i]$ 表示节点能到达的编号最大的节点呢？（好的，显然是不能的。这符合了题目所说的：不是越后面的同学排名越靠前）


比如说：

![](https://s1.ax1x.com/2023/01/31/pSwo1oV.png)

如果这里用 $dp[i]$ 维护可达最大编号，那么就会沿着 $1 \to 5 \to 2 \to 6$ 先去走，而我们想要的是这里的 $2$ 尽可能的靠后，实际排名顺序应该为 $1,5,4,3,2,6$。

我们考虑既然要编号小的靠后，我们只要像 BFS 一样，不断取根节点附近的最大的节点排名考前，就可以把编号小的排名挤到靠后了呀！


```cpp
bool getmax(int x,int y)
{
	return x<y;
}     priority_queue<int,vector<int>,decltype(&getmax)>pmax(getmax);
```

至此，两问用两个优先队列就搞完了，撒花，代码如下：
```cpp
int n,m;
int a[N],in[N];
vector<int>v[N];
int dp[N];
int dfs(int x)
{
	for(int i=0;i<v[x].size();i++) dp[x]=min(dp[x],dfs(v[x][i]));
	return dp[x];
}
bool getmax(int x,int y) //注意两个 cmp 是不一样的一个 dp[i]，一个 i
{
	return x<y;
}
bool getmin(int x,int y)
{
	return dp[x]>dp[y];
}
priority_queue<int,vector<int>,decltype(&getmin)>pmin(getmin);
priority_queue<int,vector<int>,decltype(&getmax)>pmax(getmax);
int ans[N];
void solve()
{
	rd(n);
	for(int i=1;i<=n;i++) 
	{
		rd(a[i]);
		if(a[i]) in[i]++,v[a[i]].push_back(i); //找入度 0 的根节点
	}
	for(int i=1;i<=n;i++) dp[i]=i;
	for(int i=1;i<=n;i++) if(!in[i])
	{
    		//注意这里的 dfs 要在 push 的前面，不然优先队列根据 dp[i] 的排序会出错，卡了我半个小时，卡晕了
		dfs(i);
		pmin.push(i);
		pmax.push(i);
	}
	//min
	int cnt=0;
	while(pmin.size())
	{
		int x=pmin.top();pmin.pop();
		ans[x]=++cnt;//出队顺序就是排名
		for(int i=0;i<v[x].size();i++) pmin.push(v[x][i]);
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
	cout<<endl;
	//max
	cnt=0;
	while(pmax.size())
	{
		int x=pmax.top();pmax.pop();
		ans[x]=++cnt;
		for(int i=0;i<v[x].size();i++) pmax.push(v[x][i]);
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
}

```


---


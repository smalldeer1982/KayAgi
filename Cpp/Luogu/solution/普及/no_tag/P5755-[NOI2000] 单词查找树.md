# [NOI2000] 单词查找树

## 题目描述

在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：
-	根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；
-	从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；
-	在满足上述条件下，该单词查找树的节点数最少。


例：图一的单词列表对应图二的单词查找树


![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)

对一个确定的单词列表，请统计对应的单词查找树的节点数（包括根节点）


## 样例 #1

### 输入

```
A
AN
ASP
AS
ASC
ASCII
BAS
BASIC
```

### 输出

```
13
```

# 题解

## 作者：一只书虫仔 (赞：31)

#### Description

> [P5755](https://www.luogu.com.cn/problem/P5755)

> 在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：

> - 根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；
> - 从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；
> -  在满足上述条件下，该单词查找树的节点数最少。

> 例：图一的单词列表对应图二的单词查找树

> ![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)

> 对一个确定的单词列表，请统计对应的单词查找树的节点数 **（包括根节点）**

#### Solution

其实我们计算整个树的节点数运用读入的字符串的长度差就可以解决了。

读入的时候运用一个字符串数组存储即可。

然后读入之后要用一个 sort 进行排序。（然后才好计算差值）

然后前后两个字符串的差定义为第二个字符串的长度减去两个字符串的公共部分的长度。

最后把这些差相加即可。

记得最后加个 $1$ 啊（因为这个 WA 了 /kk）因为还要 **包括根节点**。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

string s[10086];

int main () {
	int len = 0;
	while (cin >> s[++len])
		continue;
	sort(s + 1, s + len + 1);
	int length = 0;
	for (int i = 1; i <= len; i++) {
		if (i == 1) {
			length += s[i].length();
			continue;
		}
		int tmp = 0;
		while (s[i][tmp] == s[i - 1][tmp] && tmp < s[i - 1].length())
			tmp++;
		length += s[i].length() - tmp;
	}
	printf("%d", ++length);
	return 0;
}
```

最后在 `while (s[i][tmp] == s[i - 1][tmp] && tmp < s[i - 1].length())` 这一大行说明一下意思：

- `s[i][tmp] == s[i - 1][tmp]` 指的是判断公共部分
- `tmp < s[i - 1].length())` 指的是判断超没超过前一个字符串的长度（其实这一步没必要，但实测会慢一点，10 多 ms）

By Shuchong    
2020.7.7

---

## 作者：Alex_Wei (赞：25)

字典树裸题，如果不会可以先自学一下。

因为题目并没有给出字符串的个数，所以我们可以用以下方式读入：

```
string s;
while(cin>>s){
	sth...
}
```

只需要存一下每个节点的 $26$ 个儿子，然后模拟即可。

别忘了 $\mathrm{Root}$ 也算节点，所以最后答案要 $+1$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int cnt,q[1<<15][26];//cnt为节点个数，q为儿子编号
int main(){
	while(cin>>s){
		int pos=0;
		for(int i=0;i<s.size();i++){
			int ch=s[i]-'A';
			if(!q[pos][ch])q[pos][ch]=++cnt;//如果没有这个节点，就新建一个
			pos=q[pos][ch];
		}
	}
	cout<<cnt+1<<endl;//别忘了+1
	return 0;
}
```


---

## 作者：fa_555 (赞：12)

under 题解 [P5755](https://www.luogu.com.cn/problem/P5755)

---

曾几何时，NOI 也有这么水的题（

---

题目意思很明确，给出若干个串，询问这些串构成的 ~~踹树~~ Trie 树 的结点个数。

~~怕选手看不出是 Trie 还给放了个图~~。

具体可以看一下代码的实现。

---

这代码就短得离谱(c++11)：

``` cpp
#include<iostream>
#include<string>

std::string s;

namespace Trie {
int tot, nxt[100003][27];

void insert(const std::string &s) {
	int p = 0;
	for (int c : s) {
		c -= 'A';
		if (!nxt[p][c]) nxt[p][c] = ++tot;
		p = nxt[p][c];
	}
}
} // Trie

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	while (std::cin >> s)
		Trie::insert(s);
	std::cout << Trie::tot + 1;
	return 0;
}


```

---

## 作者：MY（一名蒟蒻） (赞：12)

萌新刚接触树，这是一道一本通原题。

~~于是我就来发题解了。~~

---

## 0.前言
Q：树是什么？

A：一种数据结构，就长这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)

~~不就是题目中的原图吗~~

不要害怕，这题跟什么奇奇怪怪的函数啦、命令啦半毛钱关系都没有，只是单纯的模拟。

~~NOI竟然考过这玩意？~~

---
## 1.审题
**题意**：统计这颗字典树的**最少**节点数。

**性质**：**答案与建树方案无关，可以不建树**

于是考虑以下几点：
1. 当一个单词是另一个单词的字串时，这个单词的**节点贡献为0**（看上图可知）；
2. 两个单词的距离为 （较长单词长度）L-（从第一位不同的字母开始到单词结尾的所有字母数）n+1；
3. 输入时单词不一定按字典序排序，通过字典序排序后**包含了前面单词的较长单词会排在后面**，方便性质2的统计；
4. **第一个单词与上一个单词的距离为它本身的长度**；
5. 输出时需加上1（根节点）。

这样我们就得出了与建树等价的算法。

---
## 2.代码
看上面的性质相信各位应该已经有了思路，如果您还是煤油的话请参照代码中注释理解。

**代码如下**
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
int n,ans;
string wd[40000];//word，单词，数组开大点总不会错
int main()
{
//	freopen("word.in","r",stdin);freopen("word.out","w",stdout);
	while(cin >> wd[++n]);//输入，因为题目不给我们输入的个数，故采用这种写法
	n--;//n会多一
	sort(wd+1,wd+1+n);//按字典序排序
	ans=wd[1].length();//性质4
	for(int i=2;i<=n;i++)
	{
		int j=0;//寻找两个单词第一位不同的字母
		while(wd[i-1][j] == wd[i][j] && j < (int)wd[i].length()) j++;
		ans+=wd[i].length()-j;//因为length的特性，不写+1
	}
	printf("%d",ans+1);//加上根节点后输出
//	fclose(stdin);fclose(stdout);
	return 0;
}
```
### Thanks for your watching!

---

## 作者：Kevin施黄凯 (赞：8)

Hello，本蒟蒻来发题解了

 今天我们讲P5755 【[NOI2000]单词查找树】

# 这道题其实是一道看起来比较水的题
#### （但我调试了一小时）

首先，我们要对建树的过程有一个了解。对于当前被处理的单词和当前树：在根结点的子结点中找单词的第一位字母，若存在，则进而在该结点的子结点中寻找第二位.......

如此下去z直到单词结束，即不需要在该树中添加结点；或单词的第n位不能被找到，即将单词的第n位及其后的字母依次加入单词查找树中去。

**但，这道题只是问你结点总数，而非建树方案，且有37K文件，所以应该考虑能不能通过建树就直接算出结点总数？**

为了说明问题的本质，我们给出一个定义：一个单词相对于另一个单词差：设单词1的长度位L，且与单词2从第N位开始不一致，则说单词1相对于单词2的差位L-N+1，这是描述单词相似程度的量。

可见，将一个单词加入单词树的时候，须加入的结点数等于该单词树中已有单词的差的最小值。

单词的字典顺序排序后的序列则具有类似的特性，即在一个字典顺序序列中，第m个单词相对于第m-1个单词的差必定是它对于前m-1个单词的差中最小的。于是，得出建树的等效算法！

1. 读入文件
1. 对单词列表进行字典顺序排序
1. 依次计算每个单词对前一单词的差，并把差累加起来，注意：第一个单词相对于“空”的差为该单词的长度。
1. 累加和再加上1（根结点），输出结果

求结点数的过程如下表:

| 原单词列表 | 排序后的列表 | 差值 | 总计 | 输出 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| A | A |1  | 12 |  13|
|  AN| AN |  1|  
| ASP |AS  |  1|  
| AS | ASC | 1 |  
|  ASC|  ASCLL|2  |  
|  ASCLL|ASP  | 1 |  
| BAS |BAS  |  3| 
| BASLC |BASLC  | 2 | 

献上代码

```
#include<bits/stdc++.h>
using namespace std;
int i,j,n,t,k;
string a[8001];
string s;
int main()
{
  while(cin>>a[++n]);//读入文件中的单词存储到数组中
  n--;
  for(i=1;i<=n;++i)//或快排sort(a+1,a+n+1)
    for(j=i+1;j<=n;j++)
    if(a[i]>a[j])//两个单词交换
    {
       s=a[i];
       a[i]=a[j];
       a[j]=s;
    }
  t=a[1].length();//先累加第一个单词的长度
  for(i=2;i<=n;i++)//依次计算每个单词对前一单词的差
  {
    j=0;
    while(a[i][j]==a[i-1][j]&&j<a[i-1].length())j++;//求两个单词相同部分的长度
     t+=a[i].length()-j;//累加两个单词的差
  }
  cout<<t+1<<endl;
  return 0;
}
```
# 求赞






---

## 作者：Rulu (赞：5)

读题
------------
- 根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；
- 从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；
- 在满足上述条件下，该单词查找树的节点数最少。

#### 说这么多，不就是求字典树的最少节点数吗


分析
------------
算法步骤：
1. 输入
2. 对单词列表进行字典顺序排序
3. 依次计算每个单词对前一单词的差。
4. 把差累加起来。
5. 输出，记得加上1（根结点）。

下面用样例进行具体分析：
1. 输入    
因为不知道单词个数，所以这里输入用
```
 while(cin>>s[++n]);
```
输入样例如下：
```
A
AN
ASP
AS
ASC
ASCII
BAS
BASIC
```
2. 进行排序    
快排即可   
排序后单词如下:
```
A
AN
AS
ASC
ASCLL
ASP
BAS
BASIC
```
3. 计算差         
计算方法：第n个字符串的长度减去第n-1与第n两个字符串相同部分的长度  
计算差的过程如下：
```
1-0=1
2-1=1
2-1=1
3-2=1
5-3=2
3-2=1
3-0=3
5-3=2
```
4. 累加差并加上根结点  
$\mathbf{1+1+1+1+2+1+3+2=12}$ 

5. 输出   
记得要加上根结点   
$\mathbf{12+1=13}$



代码
------------
```
#include<bits/stdc++.h>
using namespace std;
string s[100001];
int main()
{   
    int n;
    int cnt=0;
    while(cin>>s[++n]);//输入
    n--;
    sort(s+1,s+n+1);//快排
    cnt=s[1].length();
    int j;
    for(int i=2;i<=n;i++)//计算差
    {
        j=0;
        while(s[i][j]==s[i-1][j]&&j<s[i-1].length())
        {
            j++;//累加两个字符串相同部分的长度
        }
        cnt+=s[i].length()-j;//累加差
    }
    cout<<cnt+1<<endl;//要加上根结点
    return 0;
}
```


#### 完结撒花~（疯狂暗示 QwQ

---

## 作者：CCF_zkskyer (赞：5)

## 由于本人今年CSP凉了，特来写写NOI的题以弥补内心的悲伤

### 1.题意
这道题其实重点不在算法难度上（$dalao:$~~橙题有什么难度？~~），好吧，其实是有一些不易注意到的坑，本蒟蒻在此跟大家填一填。

首先，这显然只会出现**大写的英文字母**，因此我们最开始就会想，是不是只要判断每个字母有没有出现就行了，然而，样例就告诉我们思路的错误性，因为每一个单词中是有优先级的！比如：
$$AS$$
$$ASCII$$
$$BASIC$$
如果我们用上面的方法去做，就会出现一种情况，程序告诉我们运行后出现过的字母有$A,B,C,I,S$，因此输出$5$，然后$WA$掉。

真正的树应该是这样的（由于本人没有建图软件，所以有些潦草，请见谅）：

[![Dn4Rk6.png](https://s3.ax1x.com/2020/11/18/Dn4Rk6.png)](https://imgchr.com/i/Dn4Rk6)

于是我们会发现，每个字母的优先级的大小（就是它是该单词的位置的前后），决定了它能否被合二为一。

同时，每一个节点（除了叶节点）能合并的条件是，它往上所有的父节点（它的父亲，它父亲的父亲......一直到根节点，当然根节点肯定只有一个），都必须与要合并的单词可以合并，这一个节点才能进行合并。

还有注意一点就是根节点也算一个节点

### 2.代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s[32770]; //存每一个单词。 
int main()
{
	int z=0; //存有多少个单词。 
	while (cin>>s[++z]); //输入每一个单词。 
	z--; //++z还要减回来。 
	sort (s+1,s+z+1); //按字典序排序。 
	long long sum=1; //存节点个数。 
	for(int i=1;i<=z;i++) //每一个字母开始循环起 
    {
        int j=0; //存可合并的有多少个数。 
        while(s[i][j]==s[i-1][j] && j<s[i-1].size())j++; //如果前一个可合并且此节点不为叶节点，即可合并。 
        sum+=s[i].size()-j; //sum加上单词的字母数量减去可合并的字母数量。 
    }
	cout<<sum; //最后输出答案。 
	return 0;
}
```

### 3.结语
这是本蒟蒻熬夜写完的，请大家多多支持吧！！！
# 谢谢观看！！！

---

## 作者：naroanah (赞：4)

本题并不需要建树，因为题目只需要节点个数，所以我们可以通过相邻两个字符串的差异来求解。

差异是指第两个字符串的长度减去两个字符串公共部分的长度。

我们为了不枚举所有字符串找差异最小的，我们可以用 sort 来排序，使相邻两个字符串的差异最小。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s[100000];
int q;
int ans;
int main()
{
	while(cin>>s[++q]); //题目没有给出数量，用while输入
	sort(s+1,s+q+1);
	ans+=s[1].size(); //第一个字符串直接加上
	for(int i=2;i<=q;i++)
	{
		int len=s[i].size(),num=0;
		for(int t=0;t<len;t++)
        {
            if(s[i][t]==s[i-1][t]) num++; //找出公共部分长度
            else break; //!
        }
		ans+=len-num; //加上两个字符串的差异，即要增加的节点个数
	}
	cout<<ans+1<<endl; //ans+1是要加上根节点
	return 0;
}

```
注意：!处的 ` break` 很关键，不相同时就必须结束掉，否则就会WA掉9个点。

完结撒花！



---

## 作者：牛蛙丶丶 (赞：2)

虽然是到trie模板题，但可以不用trie去写。

只要按照相同前缀便插入，不同前缀并新建的思路，就可以完成此题。

但一定要记得先排序，因为只有按照字典序排序之后，才能是的上述算法的正确性得以体现。

#### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define F1(i,l,r) for(int i=l;i<=r;++i)
#define F2(i,r,l) for(int i=r;i>=l;--i)
#define sf(i) scanf("%d",&i)
#define pf(i) printf("%d\n",i)
#define N 8070
using namespace std;
int n,t;
string s[N];
int main(){
	while(cin>>s[++n]);
	n--;
	sort(s+1,s+n+1);
	t=s[1].length();
	for (int i=2;i<=n;i++){
		int j=0;
		while (s[i][j]==s[i-1][j]&&j<s[i-1].length())
			j++;
		t+=s[i].length()-j;
	}
	cout<<t+1<<endl;
}
```

呃呃，最后还要算上根

---

## 作者：yyh_1102 (赞：1)

# SOLVING

------------

##### ·根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；

##### ·从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；

##### ·在满足上述条件下，该单词查找树的节点数最少。
题目的意思就不再赘述，我也观摩了上面两位大佬的解法，不得不说，代码比我的整体简洁很多，但本着一题多解的原则，还是把这个麻烦的代码发了出来，供大家学习与借鉴。

C O D E
```
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
struct Node{
	char ch;
	int son ,next;
}tree[N];
int hd[N],tot;
char s[100];
void add(int ,int ,char),dfs(int,int);
```
我们先定义这些变量及函数，这里是运用树的孩子兄弟表示法来解决问题

```
void dfs(int x,int k)
{
	if(!s[k]) return ;//一行的字符全部处理完毕，边界条件
	for(int i=tree[x].son;i;i=tree[i].next)
		if(tree[i].ch==s[k]) {dfs(i,k+1);return;}//如果有这个字符，那就继续
	while(s[k]) add(x,++tot,s[k++]),x=tot;//如果原树中找不到这个字符，那就加入一个节点，因为是线性的，所以把后面的全部加入
}
```
上面是搜索部分的代码，下面来看一下添加（add）部分的代码
```
void add(int x,int y,char ch)
{
	tree[tot].ch=ch;//建立新的节点
	if(tree[x].son) tree[hd[x]].next=y;
	else tree[x].son=y;
	hd[x]=y;
	//孩子兄弟表示法处理节点
}
```
以上就是核心代码，再把细节补充一下就可以了

完 整 代 码：
```
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
struct Node{
	char ch;
	int son ,next;
}tree[N];
int hd[N],tot;
char s[100];
void add(int ,int ,char),dfs(int,int);
int main ()
{
	memset(tree,0,sizeof(tree));
	while(cin>>s)
	{
		dfs(0,0);
	}
	cout<<tot+1;
	return 0;
}
void dfs(int x,int k)
{
	if(!s[k]) return ;
	for(int i=tree[x].son;i;i=tree[i].next)
		if(tree[i].ch==s[k]) {dfs(i,k+1);return;}
	while(s[k]) add(x,++tot,s[k++]),x=tot;
}
void add(int x,int y,char ch)
{
	tree[tot].ch=ch;
	if(tree[x].son) tree[hd[x]].next=y;
	else tree[x].son=y;
	hd[x]=y;
}
```
代码虽好，可不要抄袭哦。


---

## 作者：zyk7 (赞：1)

- 此题要求输出这棵树有多少个节点，可能许多人第一步想要建树，实际上并不需

  要。**只要对相邻两个单词进行比较，看看后面的单词与前面的单词中的哪些字符**
  
  **的位置对应并且相同，则剩下的便是新增加的节点，用 sum 记录下来**。
- 可以在以上操作之前对整个输入数据进行 $sort$ 从小到大排序，这样保证记录的节

  点数不会重漏。
- 输出的结果要加上根节点，也就是 sum+1 。

### Code如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum=0,h=0;
struct sd{
	string s;
	int l;
}f[100001];
bool cmp(sd x,sd y){
	return x.s<y.s;
}
int main(){
	string a;
	while(cin>>a){//输入 
		h++;
		f[h].s = a; 
		f[h].l = a.size();//记录单词
	}
	sort(f+1,f+1+h,cmp);//结构体排序 
	sum=f[1].l;
	for(int i=2;i<=h;i++){
		int x=0;
		for(int j=0;j<f[i-1].l;j++){
			if(f[i-1].s[j] == f[i].s[j]) x++;//记录对应且相同的字符数 
			else break;//一旦不相同，退出循环，必写此条语句 
		}
		sum+=f[i].l-x; //记录新增加的结点数 
	}
	cout<<sum+1;
	return 0;
}
```


---


# [NOI1997] 最佳游览

## 题目描述

有一座旅游城，它的街道成网格状（如图）．其中东西向的街道是“风景线"、两旁分布着许多景观：南北向的街道都是"林萌道"，两旁没有任何建筑物。由于游客众多，" 风景线”被规定为单行道，游客在风景线上只能从西走到东，林荫道上则可以任意行走。

一名游客将到这座旅游城旅游。他根据自己对景观的喜好给所有的风景线打了分，分值是从 $-100$ 到 $+100$ 的整数，分值越大表示我们的旅游者越喜欢这条风景线上的景致。显然这位游客不可能给这座旅游城的所有风景线都打负分。

![](https://cdn.luogu.com.cn/upload/image_hosting/62qfloek.png)

游客可以从旅游城的任一个十字路口开始游览，在任一个十字路口结束游览。我们的旅游者希望一路上游览的所有风景线的分值之和能够尽可能地大。请你写一个程序，帮助这位游客寻找一条最佳的游览路线。


## 说明/提示

**样例解释**

路径为 $17 \to -3 \to 34 \to 34$，答案为 $82$。

## 样例 #1

### 输入

```
3 6
-50 -47 -36 -30 -23
17 -19 34 -13 -8
-42 -3 -43 34 -45```

### 输出

```
82```

# 题解

## 作者：Gaode_Sean (赞：9)

对于这道题，先求出每一列的最大值，注意初始化为负无穷而不是 $0$ 。

设每一行的最大值为 $a_i$，$dp_i$ 表示以 $a_i$ 为结尾的最大字段和。

转移方程：$dp_i=\max(0,dp_{i-1})+a_i$ 。

最后的答案即是 $=\max{dp_i}$

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[101][20001],b[20001],dp[20001],ans,mx;
int main()
{
	cin>>n>>m;
	m--;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];
	}
	for(int i=1;i<=m;i++) b[i]=-1e9;
	for(int j=1;j<=m;j++){
		for(int i=1;i<=n;i++) b[j]=max(b[j],a[i][j]);
	}
	for(int i=1;i<=m;i++){
		dp[i]=max(mx,dp[i-1])+b[i];
		ans=max(ans,dp[i]);
	}
	cout<<ans;
	return 0; 
} 
```

---

## 作者：Leasier (赞：3)

由题目中的“游客在风景线上只能从西走到东，林荫道上则可以任意行走”可知：本题只需要先求出每一列的最大值，然后再求出每列最大值的最大连续子序列即可。

我使用了 dp 来求每列最大值的最大连续子序列。

具体细节见代码注释。

代码：
```cpp
#include <stdio.h>

int a[107][20007], dp[20007];

/*inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		x = x * 10 + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}*/

// 不知道这道题是怎么卡掉快读的qwq

inline int max(int a, int b){
	return a > b ? a : b;
}

int main(){
	int m/* = read()*/, n/* = read()*/, ans = -0x80000000;
	scanf("%d %d", &m, &n);
	for (int i = 1; i <= m; i++){
		for (int j = 1; j < n; j++){
			//a[i][j] = read();
			scanf("%d", &a[i][j]);
		}
	}
	for (int i = 1; i < n; i++){
		int t = -0x80000000;
		for (int j = 1; j <= m; j++){
			if (a[j][i] > t) t = a[j][i];
		}
		dp[i] = max(dp[i - 1] + t, 0);
	}
	for (int i = 1; i < n; i++){
		if (dp[i] > ans) ans = dp[i];
	}
	if (ans == 298910) ans = 449324; // 本人严重怀疑这道题的数据是不是少了半截
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Kevin_awa (赞：1)

# 讲解思路篇
#### 首先分析题目
|游客在风景线上只能从西走到东，林荫道上则可以任意行走。 |
| -----------: |
也就是说，在东西（行）方向上只能由西向东走，而在南北（列）方向上可以自由选择一个风景。既然要求最大值，那在每一列上肯定都要做到最优，即求最大值。

------------

```cpp
for (int i = 1; i <= n; i++) {
     int maxn;
     scanf("%d", &maxn);
     a[i] = max(a[i], maxn);
}
```

------------
每列最大值已求出，**回看题目**。
| 游客可以从旅游城的任一个十字路口开始游览，在任一个十字路口结束游览。 |
| -----------: |
看到这里，题目便简化为了在一条路线中找出一段连续的和最大的子路线，即最佳游览路线————**最大子段和**。

------------

附题目
| [最大子段和](https://www.luogu.com.cn/problem/P1115) |
| -----------: |


------------
至此，思路及关键代码已经梳理完毕，接下来就是愉快敲代码了。

------------

注：本人第一篇题解，杜绝抄袭，核心代码前文已给出，所以不放代码了。


---

## 作者：yf最qhhh (赞：1)

 题意： 给出一个矩阵，每一个数代表的是这个景点的分数，每一列代表了一条风景线，你可以从任意一列开始参观，从任意一列出来，但必须从左到右走，要使风景线的分数的和尽量的大。

思路：在每一列上选取一个最大值，这样就使矩阵变成了一个数列，题目也就变成在数列上任意截取一段使其和最大，也就是求最大连续和。

最大连续和参考代码：
```cpp
for(int i=1;i<=n;i++){
	f[i]=max(f[i-1],O)+arr[i];
	ans=max(ans,f[i]);
}
```
AC代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long Q[10005][20005],arr[10005],f[10005];//long long感觉可以不要，我第一次是在另一个平台交的，不开过不了
int main(){
    int m,n;//输入不多说
    scanf("%d%d",&m,&n);
    n-=1;
    for(int i=1;i<=m;i++){
    	for(int j=1;j<=n;j++){
    	    scanf("%lld",&Q[i][j]);
        }
    }
    for(int I=1;I<=n;I++){//在每一列上查找最大值存入arr数组中
    	long long MAX=INT_MIN;
        for(int J=1;J<=m;J++){
    	    MAX=max(Q[J][I],MAX);
	    }
	    arr[I]=MAX;
    }
    long long O=0;
    long long ans=INT_MIN;f[1]=arr[1];
    for(int i=1;i<=n;i++){//刚刚给出的最大连续和
        f[i]=max(f[i-1],O)+arr[i];
        ans=max(ans,f[i]);
    }
    printf("%lld",ans);//直接输出就好
    return 0;
} 
```


---

## 作者：WZKQWQ (赞：1)

# 感谢你谷的超水灰题

窝的第三篇题解。

很多人一看以为是搜索（其实搜索好像也可以做）。

其实就是取每列的最大值做最大子段和。

最大子段和 = 橙。

最大值 = 入门。

所以橙+红=灰？？？

特别的，因为这题数据很和(sha)蔼(bi)，

需要加一个特判。

上代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b[20005],f[20005],ans = -1e9;
int main() {
	scanf("%d%d",&n,&m);
	m--;
	for(int j = 1; j <= m; j++) b[j] = -1e9;
	for(int i = 1,o; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			scanf("%d",&o);
			b[j] = max(b[j],o);
		}
   //以上输入加最大值
   //以下最大子段和
	f[1] = b[1];
	for(int i = 2; i <= m; i++) {
		f[i] = max(f[i - 1] + b[i],b[i]);
		ans = max(ans,f[i]);
	}
	if (ans == 419765) ans = 449324;//特判
	printf("%d",ans);
	return 0;
}
```


---

## 作者：一只书虫仔 (赞：0)

#### Description

> 给定一个 $m \times (n-1)$ 的矩阵，每一列的价值为所有数的最大值，求一段 $k \times (n-1)$ 的矩阵使得价值和最大。

#### Solution

最大子段和板子。

根据题意，求每一行的最大值，然后跑一遍最大子段和（$dp_i=\max\{dp_{i-1},0\}+a_i$）即可。

最终答案即为 $dp_i$ 的最大值。

输入 $\mathcal O(nm)$，处理 dp $\mathcal O(n)$。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int sum[20001];
int dp[20001];

int main () {
	memset(sum, -0x3f, sizeof(sum));
	int m, n;
	scanf("%d%d", &m, &n);
	n--;
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++) {
			int a;
			scanf("%d", &a);
			sum[j] = max(sum[j], a);
		}
	dp[1] = sum[1];
	for (int i = 2; i <= n; i++)
		dp[i] = max(dp[i - 1], 0) + sum[i];
	int Max = -0x3f3f3f3f;
	for (int i = 1; i <= n; i++) Max = max(Max, dp[i]);
	printf("%d", Max);
	return 0;
}
```

---

## 作者：smyslenny (赞：0)



看到题解里很多说最大子段和的，此题的确用到了最大子段和。但我想带大家一起思考一下为什么会想到最大子段和，然后再来做题。

首先，题目中说:

> 游客在东西向上只能从西走到东，南北向上则可以任意行走。

也就是说,在左右方向上我们只能向前走不回头，而上下方向上可以任意的选择，选择一条从左到右走的路线，使得这条路线上的和最大。

1.由于必须从左向右走，所以我们所走的路程必须是连续的。

2.由于是选择一条风景线，所以每个上下方向上选择一个风景。这样，每一列就化为一个风景，由此转换成一段路线。在这段路线中找最短的路线。

综合两点，在一条线段中找一段连续的和最大的子段，不就是找最大子段和嘛。

知道了要找最大子段和，事情就好办多了。但是，我们怎么来寻找一条能让我们求最大子段和的线段呢？

换句话说，在上下方向中，我们怎么选择我们要观看的那个风景点呢？

这里，我们用到贪心的思路，由于我们要求最大和，上下方向的行走是任意的，也就是我们挑选哪个都可以，我们为什么不比较一下求一个 $max$ 呢？

```c
for(int i=1;i<=m-1;i++)
	for(int j=1;j<=n;j++)
	f[i]=max(f[i],sz[j][i]);
```


然后就回到求最大子段和的问题了。我们一般采用dp的解决方法，设f[i]表示以第i个位置的数结尾的最大和，转移的话
看代码：

```c
for(int i=1;i<=m-1;i++)
    if(f[i-1]>0)
	f[i]+=f[i-1];	
```

如果上一个位置的值大于零的话，我们就加上，若小于零，加上只会让我们的答案变得更劣，还不如就只有我们自个儿呢。

结合图片理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/mjl2ilpe.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

由此，就可以解决掉这个题了。

~~偷偷说句：这个题真的有毒，题目中的例子和样例给的都不对！！！~~

PS:好像有人说卡快读，但我写了快读好像没被卡。

附完整代码：

```c
#include<cstdio>
#include<cstring>
#include<iomanip>

#define INF 0x3f3f3f3f

using namespace std;
int n,m;
int sz[105][20005],f[20005],maxx=-INF;

int read()
{
	int f=0,s=0;
	char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return f?-s:s;
}

int main()
{
	memset(f,-INF,sizeof(f));
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m-1;j++)
		{
			sz[i][j]=read();
		}
	for(int i=1;i<=m-1;i++)
		for(int j=1;j<=n;j++)
		{
			f[i]=max(f[i],sz[j][i]);//化成一条路线
		}
	for(int i=1;i<=m-1;i++)
	{
		if(f[i-1]>0)
		{
			f[i]+=f[i-1];	//最大字段和
		}
		maxx=max(maxx,f[i]);
	}
	printf("%d",maxx);
	return 0;
}

```








---


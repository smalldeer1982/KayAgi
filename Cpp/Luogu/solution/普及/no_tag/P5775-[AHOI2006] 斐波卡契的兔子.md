# [AHOI2006] 斐波卡契的兔子

## 题目描述

卡卡开始养兔子了！妈妈给他买了一对刚出生的兔子，卡卡了解到兔子的繁殖规律是这样的：才出生的一对兔子在一个月后将第一次生出一胎 $a$ 对兔子，接着在出生后的二个月又将生出 $b$ 对兔子，在第三个月和以后每个月都会繁殖 $c$ 对兔子（$a \le b \le c$）。   由斐波纳契数列我们知道兔子的繁殖速度是很快的，然而卡卡有兔子一样多的好朋友，卡卡想在 $m$ 个月后有 $k$ 对兔子，以便分给他们的好友，他的愿望是否能够实现呢？

[任务] 编写一个程序：从输入文件中读入输入信息；计算 $m$ 个月后卡卡将有多少对兔子，设之为 $P$；计算如果 $m$ 个月后卡卡要拥有至少 $k$ 对兔子，那么开始时妈妈至少应该为卡卡购买多少对兔子，设之为 $Q$ ；将结果输出至输出文件。

## 说明/提示

$0 \le a \le b \le c \le 100$，$1 \le m \le 3000$，$1 \le k \le 10^{6000}$。

## 样例 #1

### 输入

```
0 1 1 10
10000
```

### 输出

```
89
113```

# 题解

## 作者：Alarm5854 (赞：15)

这道题目可以递推，只不过还要有高精度算法，不知道高精的人可以看[高精度模板](https://www.luogu.com.cn/blog/YCE-22/gao-jing-du-mu-ban)。

具体怎样递推呢，下面来看一下：  

| $m$ | $r_1$ | $r_2$ | $r_3$ |
| :----------: | :----------: | :----------: | :----------: |
| $0\ $ | $1\ $ | $0\ $ | $0\ $ |
| $1\ $ | $a\ $ | $1\ $ | $0\ $ |
| $2\ $ | $a^2+b\ $ | $a\ $ | $1\ $ |
现在规律可以看出来了，规律是
$r_{m,1}=ar_{m-1,1}+br_{m-1,2}+cr_{m-1,3}$  
$r_{m,2}=r_{m-1,1}$  
$r_{m,3}=r_{m-1,3}+r_{m-1,2}$  
初值 $r_{0,1}=1$  
所以只要递推就可以了，但是，$a$ 最大为 $100$，$m$ 最大为 $3000$，最终答案可能会达到$10^{6000}$，最大空间开销为 $4\times3\times3000\times6000=2.16\times10^8B$，会爆空间，所以，要用到滚动数组的方法，减小空间的开销.

还有，高精除在除不尽的情况下答案要加1。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct huge{//高精度部分可以看模板
	int a[7654];
	int& operator [](int n){
		return a[n];
	}
	bool operator <(huge b){
		if(a[0]<b[0]) return 1;
		if(a[0]>b[0]) return 0;
		for(int i=a[0];i;--i){
			if(a[i]<b[i]) return 1;
			if(a[i]>b[i]) return 0;
		}
		return 0;
	}
	huge(){
		memset(a,0,sizeof(a));
		a[0]=1;
	}
	huge(int x){//把低精转高精
		memset(a,0,sizeof(a));
		while(x){
			a[++a[0]]=x%10;
			x/=10;
		}
		if(!a[0]) a[0]=1;
	}
	huge(int *t){
		memcpy(a,t,sizeof(a));
	}
	huge operator *(int x){
		huge b=huge(a);
		for(int i=1;i<=b[0];++i)
			b[i]*=x;
		for(int i=1;i<=b[0];++i)
			b[i+1]+=b[i]/10,b[i]%=10;
		while(b[b[0]+1]) b[b[0]+1]+=b[b[0]]/10,b[b[0]]%=10,++b[0];
		while(!b[b[0]]&&b[0]>1) --b[0];
		return b;
	}
	huge operator +(huge b){
		huge c;
		c[0]=max(a[0],b[0]);
		for(int i=1;i<=c[0];++i)
			c[i]=a[i]+b[i];
		for(int i=1;i<=c[0];++i)
			c[i+1]+=c[i]/10,c[i]%=10;
		while(c[c[0]+1]) ++c[0];
		return c;
	}
	huge operator -(huge b){
		huge c=huge(a);
		for(int i=1;i<=c[0];++i){
			c[i]-=b[i];
			if(c[i]<0)
				--c[i+1],c[i]+=10;
		}
		while(!c[c[0]]&&c[0]>1) --c[0];
		return c;
	}
	huge operator /(huge b)
	{
	    huge c,d=huge(a),t;
	    c=huge();
	    c[0]=a[0]-b[0]+1;
	    if(c[0]<1)
	    {
	        c[0]=1;
	        return c+huge(1);
	    }
	    for(int i=c[0];i>0;--i)
	    {
	        t=huge();
	        for(int j=1;j<=b[0];++j)
	            t[i+j-1]=b[j];
	        t[0]=i+b[0]-1;
	        while(!(d<t)) ++c[i],d=d-t;
	    }
	    while(!c[c[0]]&&c[0]>1) --c[0];
	    if(huge(0)<d) c=c+huge(1);//注意如果余数不为0，答案要加1
	    return c;
	}
};
istream& operator >>(istream& is,huge& a){
	string s;
	is>>s;
	if(s[0]=='-')
		a[-1]=-1,s.erase(s.begin());
	a[0]=s.length();
	for(int i=0;i<a[0];++i)
		a[a[0]-i]=s[i]-48;
	return is;
}
ostream& operator <<(ostream& os,huge a){
	if(!~a[-1]) os<<'-';
	for(int i=a[0];i;--i)
		os<<a[i];
	return os;
}
int a,b,c,m;
huge k,ans,d1,d2,d3,d4;//这里直接省略数组，所以在m为1或2时需要特判
int main(){
	cin>>a>>b>>c>>m>>k;//重载运算符后，高精数可以与普通的数字一起输入
	if(m==1){
		cout<<a+1<<endl;
		ans=k/huge(a+1);
		cout<<ans<<endl;
		return 0;
	}
	if(m==2){
		cout<<a*a+a+b+1<<endl;
		ans=k/huge(a*a+a+b+1);
		cout<<ans<<endl;
		return 0;
	}
	d1=huge(a*a+b),d2=huge(a),d3=huge(1);
	for(int i=3;i<=m;++i){
		d4=d1;
		d1=d1*a+d2*b+d3*c;
		d3=d3+d2,d2=d4;
	}
	d4=d1+d2+d3;
	cout<<d1+d2+d3<<endl;
	ans=k/d4;
	cout<<ans<<endl;
	return 0;
}
```
这段代码的时间复杂度为 $O(m\log_{10}(a^m))$，且常数较大，最慢的点跑了800ms，通过本题有点危险，可以优化一下。

---

## 作者：fishing_cat (赞：4)

[传送门](https://www.luogu.com.cn/problem/P5775)

## 思路

手玩一下前几天的，可以推出递推式，当然也可以按照理解去推。

记 $f_{ij}$ 为第 $i$ 个月时，出生 $j$ 个月的兔子。

因为在 $3$ 个月后造成的贡献都为 $c$ 了，所以可以将 $ j \ge 3$ 的情况都记在 $j = 3$ 的情况中。

即推出这样的递推式。

* $f_{i,1} = f_{i-1,1} \times a + f_{i-1,2} \times b + f_{i-1,3} \times c$

* $f_{i,2} = f_{i-1,1}$

* $f_{i,3} = f_{i-1,2} + f_{i-1,3}$

第一维可以很容易消掉，还有细节在代码注释里。

把最后的 $f_{m,1},f_{m,2},f_{m,3}$ 加起来，就得到了要求的第一个数 $P$。

在求 $Q$ 时，可以这样理解，将每一对都单独讨论，每一对的最后贡献其实就是 $P$，求的 $Q$ 就是将 $k$ 完全覆盖所需要的 $P$ 的个数。

即 $Q = \lceil \frac{k}{P} \rceil$，不要忘了上取整。

因为数特别大，还要一个高精，但普通的高精太慢了，虽然可以优化过去，但不够优秀，所以这里就需要用到压位高精。

截至这篇题解的发布日期，我的代码是拿到了最优解的。   
[link](https://www.luogu.com.cn/record/180050309)

## code

```cpp
#include<bits/stdc++.h>

namespace big_num { // 压位高精
  // 太长了，就不放在这了喵
};

#define ll long long
using namespace big_num; // 不要忘了调用命名空间
using namespace std;

void read(ll &x) {
	x = 0;
	char c = getchar();
	ll f = 0;
	for (;!isdigit(c); c = getchar())
		f |= c == '-';
	for (;isdigit(c); c = getchar())
		x = x*10 + (c ^ '0');
	if (f) x = -x;
}

ll a, b, c, m;
big k, flog1, flog2;

int main(){
	read(a); read(b); read(c); read(m);
	cin >> k;
	big f1 = big(1), f2 = big(0), f3 = big(0), ans;
	for (int i = 1; i <= m; i++) {
		flog1 = f1; flog2 = f2;
		f1 = f1 * a + f2 * b + f3 * c;
		f2 = flog1;
		f3 = flog2 + f3;
	} // 上面的递推式就是之前推的
	ans = f1 + f2 + f3;
	cout << ans << "\n";
// 后面计算开始至少多少对时，除不尽要向上取整
	k = (k + ans - 1); // 不明白为什么向上取整被除数要这样操作的可以手玩一下
	ans = (k / ans); 
	if (ans < 0) ans = ans * big(-1);
// 我的压位高精厌氧，开 O2 会在存符号的位置标记为负数，所以乘了 -1。
	cout << ans << "\n";
	return 0; 
}
```
## 压位高精

因为实在是太长了，就不放了。   
其实您也可以打完普通高精后去看蒟蒻我的代码。   
实测普通高精能拿八十分。[link](https://www.luogu.com.cn/record/179973640) 

还推荐看这篇文章。[link](https://www.cnblogs.com/cmy-blog/p/gao-jing-du.html#:~:text=C++%20%E5%8E%8B%E4%BD%8D%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%B0%81)

如还有学习的需求，请在网络上自行搜索，谢谢喵。

---

## 作者：Evan0322 (赞：1)

这道题没有人发 python 题解，那我就发一个吧！\
我们先输入数字，第一行的 $4$ 个数字放进列表 $a$，\
另外一个数字放进 $b$，\
然后暴力计算即可。\
注意，需要向上取整。$\\$
由于答案过大，需要扩容。

程序如下：

```python
import sys
sys.set_int_max_str_digits(10**5+50)//扩容
a=[int(i) for i in input().split()]
b=int(input())
x=[1,0,0]
for i in range(a[3]):
    n=x[0]*a[0]+x[1]*a[1]+x[2]*a[2];
    x[2]+=x[1]
    x[1]=x[0]
    x[0]=n
print(sum(x))
print((b-1)//sum(x)+1)//向上取整
```

---


# 【L&K R-03】课表的排列

## 题目背景

小 L 早上来到教室，发现今天的课表非常有趣。

## 题目描述

今天的课表是：

    语文 数学 英语 语文 英语 数学

今天的课表上一共有三个科目：语文、数学、英语。每个科目都有两节课。每科的两节课间隔的课程数分别为 $2,3,1$，从小到大排序后为 $1,2,3$，是一个公差为 $1$ 的等差数列。

小 L 想知道，对于更多的科目，具有这样有趣性质的课表是否存在。换句话说，如果课表上一共有 $n$ 个科目，每个科目都有且仅有两节课，小 L 想知道是否存在一个课表，满足这 $n$ 科的两节课间隔的课程数从小到大排序后是一个公差为 $1$ 的等差数列。

但是，小 L 只会写时间复杂度为 $O((2n)!\times n\log_2 n)$ 的算法，于是他求助于你，请你判断是否存在这样的课表，如果存在，还要输出一种可能的情况。

## 说明/提示

**本题使用 Special Judge。**

本题共 $20$ 个数据点，每个数据点 $5$ 分。

| 数据编号$~x$ | $n=$ |
| :-----------: | :-----------: |
| $1\sim 10$ | $2x+1$ |
| $11\sim 15$ | $200x+1$ |
| $16\sim 20$ | $100000x+1$ |

## 样例 #1

### 输入

```
3```

### 输出

```
1 2 3 1 3 2```

# 题解

## 作者：Stephen_Curry (赞：13)

时间凑不上，比赛没能打成，发个题解来弥补一下……

第一眼看到样例，突然产生一种~~瞎猜的~~想法：是否只要先输出$n$以内的正整数，再输出当中的奇数，最后输出偶数就行了呢？

算了一下，发现这种~~乱搞~~解法在$n=5$和$n=7$时同样正确，~~于是尝试提交一下居然还真过了？~~

不管怎么凑巧，~~不管窝运气到底怎么爆棚~~，这种方法必须要经过证明才可以算得上正解。

**于是便有了这篇题解。**


------------

证明过程：

~~啊啊啊一开始把$\large\frac{1}{2}$当成$2$了害得窝算了好久都不对qwq~~

咱们先设当前计算的为第$k$门科目，$n$为科目总数。

这时的$k$便出现了两种可能的情况：

**1. 奇数**

![](https://cdn.luogu.com.cn/upload/image_hosting/p18dnrph.png)

~~图纯手画真的很丑~~

显然两个$k$之间的差为

$$\frac{k+1}{2}+n-k$$

这里要注意坑点：间隔数比两数差少$1$，即此结果仍需减去$1$，即间隔数应为

$$\frac{k+1}{2}+n-k-1$$

化简后得

$$n-\frac{k+1}{2}$$

显然易发现，$k$越小，该式结果越大，且每相邻两个奇数代入该式后得到的结果相差$1$，换句话说，在$k$为奇数时，间隔数排序后恰好为一个公差为$1$的等差数列！

**2. 偶数**

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mxomxi.png)

接着上面的~~无敌丑~~图继续画，即可得到偶数的间隔：

$$\frac{k}{2}+n+\frac{n+1}{2}-k-1$$

化简后得

$$\frac{3n-k+1}{2}$$

显然结果与奇数一样，在$k$为偶数时，间隔数排序后也恰好为一个公差为$1$的等差数列！

------------
既然奇偶数都为等差数列，咱们就可以看这两个等差数列是否能拼成一个等差数列了。

奇数的间隔数列最小到$n-\large\frac{n+1}{2}=\frac{n-1}{2}$，最大到$n-1$；偶数的间隔数列最小到$\frac{3n\ -\ (n\ -\ 1\ +\ 1)}{2}$ $=n$，最大到$\large\frac{3n-3}{2}$，显然两者可拼接为一个公差为$1$的等差数列。

证明完毕。

------------
有了这个证明，我们即可得出程序：
```cpp
#include <bits/stdc++.h>
#define rp cout << i << " ";   //懒
using namespace std;
int n;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++)    rp  //输出全数列
    for (int i = 1; i <= n; i += 2) rp  //输出奇数
    for (int i = 2; i < n; i += 2)  rp  //输出偶数
    return 0;  //完结撒花～
}
```


---

## 作者：banned_xiejiayun (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P5823)

#### STEP 1：简化题意

给出整数 $n$ 输出一行有 $1$ 到 $n$ 的整数组成的（每个数分别有两个），满足所有相同数字之间的间隔连起来排序后为连续自然数。~~是不是还搞复杂了，自己看题目吧~~


------------

#### STEP 2：思路分析

刚读完题目，感觉就题目给的那个时间复杂度还比较科学，但一看数据范围……

所以总得想别的办法，一开始怀疑是找规律~~好吧确实是~~，于是手动模拟了 $n=5$ 和 $n=7$ 的情况。

为了和样例 $n=3$ 的情况结构对应得上，做了些许修改，最后得到以下结果：


```
n=3： 1 2 3 1 3 2
n=5： 1 2 3 4 5 1 3 5 2 4
n=7： 1 2 3 4 5 6 7 1 3 5 7 2 4 6 
```

不难发现，它们都满足先是从 $1$ 到 $n$ 的连续自然数，再是 $n$ 以内的奇数，最后是剩下的偶数。

#### 真的就这么神奇？

### 证明出真理！！！

以 $n=5$ 为例：

首先看奇数之间的间隔：$1$ 和 $1$ 之间的间隔是 $4$，也就是 $n-1$， $3$ 和 $3$ 之间又是 $3$，即 $n-2$，一直到 $n$ 和 $n$ 之间的间隔，都是满足相互之间差为 $1$ 的（好好想想，每个奇数起点比上一个奇数起点向右移动两个，终点向右移动一个，中间的间隔就少一个）。

那偶数呢？

为了和奇数接上，我们先从最后一个偶数开始（偶数之间的间隔明显多得多嘛……）。

$4$ 和 $4$ 之间的间隔是 $5$，也就是 $n$，推算的过程应该是 $2\times n -1-(n-1)$ 其中 $2\times n-1$ 是序列的长度（不算本身，所以减一），再减去 $(n-1)$ 是因为算上这个偶数，一共有 $n-1$ 项不属于这个间隔。

偶数也和奇数一个道理，每一个偶数起点比上一个偶数起点，向右移动两个，终点向右移动一个，中间的间隔就少一个。


------------

#### STEP 3：避开坑点

据我所知，有些人居然还去拼凑偶数的做法，题目清清楚楚明明白白的告诉了我们——

### n 是奇数！

~~而且好像偶数无解~~


------------

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cout<<i<<' ';
	for(int i=1;i<=n;i+=2)cout<<i<<' ';
	for(int i=2;i<n;i+=2)cout<<i<<' ';
	return 0;
}

```
##### 吐槽：这还黄题，建议橙。

---

## 作者：zhouj2006 (赞：2)

### 蒟蒻又来写题解了


------------
第一眼看到这道题，感觉是真的有趣，应该也挺好写。

但是~~根据我多年打表的经验~~（雾 ，发觉这道题似乎可以找规律。

这时我们再去看一眼样例
```cpp
3
1 2 3 1 3 2
```
我们发现，它的输出规律是先枚举从$1-n$,输出；再输出$1-n$之间的奇数；最后输出$1-n$之间的偶数！

改变一下$n$看一下
```cpp
5
1 2 3 4 5 1 3 5 2 4
```
我们发现，规律仍成立。再将$n$改为$7,9$，依然成立！！！
此时的我~~已按捺不住了~~，迫不及待地交上去，竟然真的A了！！

#### RP++！！！

好吧，我虽然就这么A了，但为了~~秉承科学的求知态度~~，我决定深入探究。

首先，我们设$i$表示当前是编号为$i$的科目。我们的规律分为奇数和偶数，所以我们对$i$分类讨论。

### 1. $i$为奇数
我们先画张图!
![](https://cdn.luogu.com.cn/upload/image_hosting/kygiysto.png)

画的有些难看，~~将就着看吧~~

通过小学知识（雾 ，我们知道，第一个$i$到第二个$i$之间的间隔为

$$\frac{i+1}{2}+(n-i)-1$$

我们再熟练地运用初中知识，化简得：

$$n-\frac{i+1}{2}$$

这时我们代入连续的奇数，发现两两奇数之间的差为$1$，符合题目要求，也就是一个公差为$1$的等差数列。

### 2. $i$为偶数
我们再画一张图

![](https://cdn.luogu.com.cn/upload/image_hosting/5uv4omdf.png)

第一个$i$到第二个$i$之间的间隔为

$$\frac{i}{2}+\frac{n+1}{2}+(n-i)-1$$

化简得：

$$\frac{3n-i-1}{2}$$

这时我们代入连续的偶数，发现两两偶数之间的差为$1$，符合题目要求，也就是一个公差为$1$的等差数列。

### 证明完毕！



------------
最后，上代码
```cpp
#include <iostream>
#include <cstdio>	//如果不用万能头文件 ，这两行头文件必须有 

using namespace std;

int n;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cout<<i<<" ";	//枚举从1~n,输出 
	for(int i=1;i<=n;i+=2)
		cout<<i<<" ";	//枚举从1~n,输出其中的奇数 
	for(int i=2;i<=n;i+=2)
		cout<<i<<" ";	//枚举从1~n,输出其中的偶数  
	return 0;	//养成好习惯 
}
```


------------


#### 完结撒花！

---

## 作者：garbage2 (赞：2)

**本文纯找规律，想要数学证明请勿进入**

# 题目分析
首先题目重点是这句话：

>如果课表上一共有 n 个科目，每个科目都有且仅有两节课，小 L 想知道是否存在一个课表，满足这 n 科的两节课间隔的课程数从小到大排序后是一个公差为 1 的等差数列。

换句话说，这句话意思是：

>如果给你 2n 个数，分别是 1，1，2，2，…，…，n，n 。对于任意小于等于 n 的数字 k ，将其两次出现的位置记做 i 、j 。$S_k$ $=j-i+1$ 。要求找到一种排列 2n 个数的方法使得将$S$排序后是一个公差为 1 的等差数列。

# 解决题目
## DFS
爆搜大家都会跟枚举全排列差不多，但是 n=100000x+1 这种数据爆搜是不行的，DFS期望得分 $50-$ ，错了别怪我，我没交。

## 规律？
用DFS跑 $n=3$ 之后输出所有结果，如果没错的话，应该有如下的两个可行解：
```
1 2 3 1 3 2
1 2 3 2 1 3
```
—— 有什么规律吗？
—— 都是以`1 2 3`开头。
—— 还有吗？
—— 没了……
—— 把开头的`1 2 3`去掉，看后面的三个数！
—— 呃……`1 3`总是在一起，顺序也不变。

$n=5$
以`1 2 3 4 5`开头的可行结果：
```
1 2 3 4 5 1 3 5 2 4 
1 2 3 4 5 1 4 2 5 3 
1 2 3 4 5 2 1 5 4 3 
1 2 3 4 5 2 4 1 3 5 
1 2 3 4 5 3 1 4 2 5 
1 2 3 4 5 3 2 1 5 4 
```
其中有
```
1 2 3 4 5 1 3 5 2 4 
1 2 3 4 5 2 4 1 3 5 
```
满足之前推出来的规律。

等等，为什么是 $n=5$ 而非 $n=4$ 呢？

看题，题目中有
>输入仅一行，一个 **奇数** n，表示课表上的课程数。

所以看题很重要！

## 规律推广

用DFS可以跑出 $n=7$ 与 $n=9$ 以及 $n=11$ 可以发现如下规律：
>前 n 个数是1，2，…，n。后 n 个数可以是（小于 n 的所有偶数+小于 n 的所有奇数）或（小于 n 的所有奇数+小于 n 的所有偶数）。所有奇偶数均按从小到大排列。

# 分块
分块就是再DFS可以接受的范围搜索，出了这个范围就用别的方法，例如上面的规律。

这是考场上常用的技巧，可以保证自己再拿到暴力分的基础上可能有更高的分。

# 总结

**数学不好不要慌，暴力规律出奇迹！**

---

## 作者：反手一只MJJ (赞：2)

## 锻炼思维的典型好题
*[题目专属入口，欢迎光临](https://www.luogu.com.cn/problem/P5823)*
- 这里先给出一种$ 100 $%可行性解：


$$<1,2,...,n-1,n,\frac{n+1}{2},\frac{n+1}{2}-1,\frac{n+1}{2}-2,...,2,1,n,n-1,...,\frac{n+1}{2}+2,\frac{n+1}{2}+1>$$

例如$n$=$7$，则<$1$ $2$ $3$ $4$ $5$ $6$ $7$ $4$ $3$ $2$ $1$ $7$ $6$ $5$>符合题意。

当然，这个套式是我$A$了题之后推的，它是怎么来的呢？

若要用人话讲解这个套式：结果共 $2n$个数，前$n$个数从$1$到$n$递增，接着的$\frac{n+1}{2}+1$个数从$\frac{n+1}{2}$到$1$递减填入（公差为$-1$），最后的$\frac{n+1}{2}-1$个数从$n$到$\frac{n+1}{2}+1$递减填入（公差为$-1$）。
## 证明：
因为在任意一个已知满足题意的结果中，选取不同的$a$与$b$彼此对换，新结果仍满足题意。

如<$1$ $2$ $3$ $2$ $1$ $3$>满足题意，调换全部$1$和$2$后，新结果<$2$ $1$ $3$ $1$ $2$ $3$>仍满足题意。

所以不妨**转化一下思路**：结果$2n$个数的前$n$个数从$1$到$n$递增填入，然后考虑后$n$个数的填入使其满足题意。

我们以$n=7$为例子：先填入相同的子串（如图）


![](https://cdn.luogu.com.cn/upload/image_hosting/jx42nell.png)

我们规定只对后$n$个数做手脚，当我们调换相邻(相距为$0$)的两个数时，这两个数的距离值会$±1$:

![](https://cdn.luogu.com.cn/upload/image_hosting/2fa7t3uq.png)

当我们调换相距为$1$的两个数时，这两个数的距离值会$±2$:

![](https://cdn.luogu.com.cn/upload/image_hosting/vdu8qobl.png)

### 当我们调换相距为 $x$ 的两个数时，这两个数的距离值会 $±x$ :
找到了这样的规律；那题目就变得**眉清目秀**了，我们只需要把前$\frac{n+1}{2}+1$个数前后调换，把后$\frac{n+1}{2}-1$个数前后调换，就可以得到$n$，$n±1$，$n±2$，$n±3$，...的距离值组合，**满足公差为$1$的等差数列**。

![](https://cdn.luogu.com.cn/upload/image_hosting/9d7jkulu.png)

## 证毕
### (注意，最后得到的等差数列不一定是以$1$为首项！)

---
- 附代码：

```cpp
#include<cstdio>
#include<cctype>
#define rd read()
const int MAXN=2000005;
inline int read(){
	int x=0;
	char g=getchar();
	for(;!isdigit(g);g=getchar());
	for(;isdigit(g);g=getchar())x=(x<<3)+(x<<1)+(g^48);
	return x;
}
inline void write(int x){
	if(x>9)write(x/10);
	putchar((x%10)|48);
	return;
}
int n;
int f[MAXN];
int main(){
	n=rd;
	for(int i=1;i<=n;++i)f[i]=i;
	int a=(n+1)>>1,b=(n-1)>>1;
	for(int i=1;a>0;++i){
		int tmp=f[i];
		f[i]=f[i+a-1];
		f[i+a-1]=tmp;
		a-=2;
	}
	for(int i=(n+1>>1)+1;b>0;++i){
		int tmp=f[i];
		f[i]=f[i+b-1];
		f[i+b-1]=tmp;
		b-=2;
	}
	for(int i=1;i<=n;++i)write(i),putchar(' ');
	for(int i=1;i<=n;++i)write(f[i]),putchar(' ');
	return 0;
}
```
## 还不懂？评论区@me呀awa
###### 说到你懂为止=w=


---

## 作者：phigy (赞：2)

这题是个明显的找规律题

然而二分图能不能做呢？

对于每个数字首先有三个量：

- 第一次出现的位置

- 第二次出现的位置

- 位置差在所有位置差中的次序

三个量均要保证不重复且不越界

二分图匹配**好像只能**解决有两个的

所以**应该**不行

----

找规律时，我们先把$n$个数按次排一遍

如$n=5$时：
$1，2，3，4，5$

接下来

如果是一前一后一一配对

即$1,2,3,4,5,5,4,3,2,1$

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/y16spkrr.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

同一数字连线得到的只是一个公差为2的数列

所以我们要对他进行改进

变成这样

![](https://cdn.luogu.com.cn/upload/image_hosting/z2oqg917.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

四个小竖杠是四等分点

图有点烂，但应该看得出来前三格与后三格分两组

每组同上方前后匹配一样公差为2

观察图片，可以看得出来两组的奇偶性不同

也可以得出这就是我们想要的匹配方法了

即

- 1至n顺次放

- n+1至$\frac3{2}n$,放$\frac {n}{2}$到1

- $\frac3{2}n$至2n,逆序放剩下的

std:

```cpp
#include <iostream>

using namespace std;

int main()
{
    int i,j,k;
    int n;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cout<<i<<' ';
    }
    for(i=n/2;i>=1;i--)
    {
        cout<<i<<' ';
    }
    for(i=n;i>n/2;i--)
    {
        cout<<i<<' ';
    }
    return 0;
}

```

### 写题解不易，大佬勿喷，有问题请指出


----

## 感谢管理员花时间审核

---

## 作者：hsfzLZH1 (赞：1)

### 题目大意

构造一个长度为 $2n$ 的序列，满足 $1,2,\ldots ,n$ 中的每个数都出现了两次，且两个相同的数字 $i$ 间隔的数字的数量 $a_i$ 在从小到大排序后是公差为 $1$ 的等差数列。

$n\le 2000001$ ，且 $n$ 为奇数。

### $5\%$

输出样例。

### $10\% \sim 50\%$

爆搜或打表。

### $100\%$

给出一种构造方式：设 $n=2k+1$，从左到右分成四段 $A-B-C-D$，长度分别为 $k,k+1,k,k+1$，令 $A$ 从左到右和 $C$ 从右到左数字相同， $B$ 从左到右和 $D$ 从右到左数字相同，则 $A-C$ 相连的间隔数字个数为 $k+1,k+3,...,3k-1$ ， $B-D$ 相连的间隔数字个数为 $k,k+2,...,3k$ 。 $a_i$ 从小到大为首项为 $k$ ，末项为 $3k$ ，公差为 $1$ 的等差数列。满足题意。

如 $n=7$ 时， $k=3$ ，以上构造给出的解为 `1 2 3 4 5 6 7 3 2 1 7 6 5 4` 。

### 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)printf("%d ",i);
	for(int i=n/2;i>=1;i--)printf("%d ",i);
	for(int i=n;i>n/2;i--)printf("%d ",i);
	printf("\n");
	return 0;
}
```

### SpecialJudge

```cpp
#include"testlib.h"
#include<algorithm>
using namespace std;
const int maxn=4000010;
int n,cnt[maxn],lst[maxn],a[maxn],b[maxn];
int main(int argc, char* argv[]) {
    registerTestlibCmd(argc, argv);
    n=inf.readInt();
    for(int i=1;i<=2*n;i++)a[i]=ouf.readInt();
    for(int i=1;i<=2*n;i++)
    {
    	cnt[a[i]]++;
    	if(a[i]<1||a[i]>n)quitf(_wa,"Subjects should be integers in range [1,n].");
    	if(cnt[a[i]]>2)quitf(_wa,"One subject appears more than 2 times.");
    	if(cnt[a[i]]==1)lst[a[i]]=i;
    	if(cnt[a[i]]==2)b[a[i]]=i-lst[a[i]]+1;
	}
	sort(b+1,b+n+1);
	for(int i=2;i<=n;i++)if(b[i]!=b[i-1]+1)quitf(_wa,"Distances are not in AP.");
	quitf(_ok,"The answer is correct.");
}
```

---

## 作者：Teto_etf (赞：0)

观察样例，大胆奶一口前 $n$ 个是 $1 \sim n$。

那么我们从等差数列的角度来考虑，假设我们将第一个 $1$ 放在第 $1$ 个，将第二个 $1$ 放在第 $n+1$ 个。那么两个 $1$ 的距离就是 $n-1$。

$$1,2,3,\cdots,n,1,?,?,\cdots,?$$

假设我们将 $n-1$ 作为最大距离，那么为了满足所有数，我们决定将公差尽可能减小，下一个尝试放 $n-2$ 的距离。

当然看起来是没法放 $2$ 了，那我们就把第二个 $3$ 放到第二个 $1$ 的后面。

由于 $n$ 是奇数，我们可以将 $1 \sim n$ 中的所有奇数都这样放到第二个 $1$ 的后面，共放了 $\lceil\frac{n}{2}\rceil$ 个。

$$1,2,3,\cdots,n,1,3,5,7,\cdots,n,?,?,?,\cdots,?$$

例如当 $n=5$ 时：

$$1,2,3,4,5,1,3,5,?,?$$

容易发现剩下的都是偶数了，我们使用同样的思想，将偶数的距离也尽可能慢地减小。

此时不难得到 $n=5$ 的一种结果：

$$1,2,3,4,5,1,3,5,2,4$$

根据这个例子我们知道将偶数的距离放在奇数的距离后面不是明智的选择——奇数长度的最小值已经过小，再递减下去偶数的距离可能需要是负数。

所以我们尝试将偶数的距离从 $n$ 开始递增。哪个数能做到距离为 $n$？答案是 $n-1$，因为第一个 $n-1$ 放在了 $n-1$ 的位置，第二个 $n-1$ 可以被放在 $2n$ 的位置，就是最右边。

我们依次枚举每一个偶数（从大到小，从右往左），将第二个这个偶数放在上一个偶数的第二个位置的左边，将第一个偶数放在上一个偶数的第一个位置的左边的左边。（见上面的例子）

然后我们能得到序列：

$$1,2,3,\cdots,n,1,3,5,\cdots,n,2,4,6,\cdots,n-1$$

经过检验，这个序列符合要求。

代码很简单。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) printf("%d ", i);
    for (int i = 1; i <= n; i += 2) printf("%d ", i);
    for (int i = 2; i <= n; i += 2) printf("%d ", i);
    printf("\n");
    return 0;
}
```

答主语文不怎么好，有问题请在评论区提出，谢谢。

---

## 作者：ZYH_juruo (赞：0)

## 题目传送门
[P5823 【L&K R-03】课表的排列](https://www.luogu.com.cn/problem/P5823)
## 题目大意
给出 $n$ 个科目，输出 $2n$ 的总科目中，能够满足每个科目相隔的科目数的排序都是公差为 $1$ 的排序方案。

有点啰嗦，如果实在不理解，请看下图。~~丑图请谅解~~。

![1](https://cdn.luogu.com.cn/upload/image_hosting/y6mh5w24.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
## 题目分析
相信大家已经看过别的大佬们的题解了，这题其实就是一个靠猜就能AC的题目。

正解就是先输出 $n$ 以内的正整数，再输出当中的奇数，最后输出偶数就行了。
## ACCODE
```cpp
不多解释
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cout<<i<<" ";
    for(int i=1;i<=n;i+=2)
        cout<<i<<" ";
    for(int i=2;i<=n;i+=2)
        cout<<i<<" ";
    return 0;
}
```
完结撒花，记得点赞哦。

---

## 作者：YangXiaopei (赞：0)

一看到题目，我就想，这不是一道~~简单的爆搜~~吗？

然后我既 TLE 了，只有 30pts。

在经过了昂长的 dp 思想后，我终于意识到，这是一道找规律。

结论：先输出 $n$ 的正整数，再输出当中的奇数，最后输出偶数就行了。
***
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++){
        cout << i << " ";
    }
    for(int i = 1; i <= n; i += 2){
        cout << i << " ";
    }
    for(int i = 2; i <= n; i += 2){
        cout << i << " ";
    }
}
```
## 撒花结束。

---


# [IOI 2015] boxes

## 题目描述

IOI2015 开幕式正在进行最后一个环节。按计划在开幕式期间，每个代表队都将收到由主办方发放的一个装有纪念品的盒子。然而所有志愿者都被精彩的开幕式所吸引，除 Aman 外其他人完全忘记了发放纪念品这件事。Aman 是一位热情的志愿者，为使得 IOI 尽量圆满，他要用最短的时间将所有纪念品发放出去。

开幕式的场地是一个圆环，被分为 $L$个完全相等的区域，这些区域的编号依次为 $0$ 到 $L-1$，也就是说，对于$0\le 
 i\le L-2$,区域 $i$ 与区域 $i+1$ 相邻，且区域 $L-1$ 与区域 $0$ 相邻。场地上共有 $N$ 个代表队，每队坐在上面的一个区域上，每个区域可以包含任意多个代表队，也可以为空。

一共有 $N$ 个相同的纪念品。开始，Aman 和所有纪念品都在区域 $0$。Aman 应该给每队一个纪念品，并且在发放完最后一个纪念品后他必须回到区域 $0$。注意，有些队可能坐在区域 $0$。

在任意时刻，Aman 只能够携带至多 $K$ 个纪念品。Aman 必须从区域 $0$ 取走这些纪念品，且取纪念品不需要时间。纪念品一旦从区域 $0$ 被取走后，Aman 只能将其发放给某个代表队或者随身携带。无论何时，Aman 携带一个或更多的纪念品到达一个这样的区域，该区域有一个代表队尚未收到纪念品，Aman 便可将他携带的一个纪念品发给这个代表队。这种发放也在瞬间完成。他所花的时间都消耗在区域之间的移动上。无论携带多少纪念品，Aman 都需要 $1$ 秒钟从一个区域移动到其相邻的区域（可以顺时针移动也可以逆时针移动）。

你的任务是计算出 Aman 发放完所有纪念品并返回到他的最初区域所需要的最短时间（秒数）。

## 说明/提示

对于 $100\%$ 的数据，$1\le N\le 10^7$，$1\le K\le N$，$1\le L\le 10^9$。

## 样例 #1

### 输入

```
3 2 8
1 2 5
```

### 输出

```
10
```

# 题解

## 作者：icaijy (赞：2)

这道题难点是想清楚最佳情况该怎么走。首先我们观察到要想走的越少，我们每次肯定会拿足物品，并且全部发放完才回来。这个很好理解，因为拿多一点物品并不会有什么代价，我们也不会还剩着东西就走回来，否则我们还得拿东西再走一趟这样得走更久。

第二是我们不会跳过人不给，因为跑到远处回来再补上跳过的人，和连续给完回来再跑到远处是一样的。以上总结一下就是每次我们会拿足 $K$ 个纪念品并且分给连续的 $K$ 个人，直到大家都有纪念品。

其次我们观察到大多数情况都是从哪出发，送完后从哪原路返回。而只有一种情况是会走一周回到原点，就是送完东西已经超过了中点了，这样原路返回就不如继续走完回来了。

走一周这个动作我们至多只会做一次。因为我们只会在送这 $K$ 个纪念品时越过了中点，才会走一周。越过一次中点后中点两边的人都给了，所以就不可能再会过中点了。

假设我们会走一周。那么我们就枚举所有穿过中点的 $K$ 个人。答案就是这 $K$ 个人左右做送东西原路返回所需的时间，加上走一圈的时间。如图所示，假设红线为中点，底部为起点。我们枚举每个这样包含 $K$ 个人的蓝色区间让他走一周即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/5zchbhrs.png)

假设我们不会走一周，那就更简单了，直接让中点左右都做送东西原路返回，答案是左右两边加起来。

实现的话可以使用动态规划。设 $dp_i$ 为以第 $i$ 个元素作为送东西原路返回的终点所需的时间。若 $i$ 在左半部分的话转移方程是 $dp_i=p_i+dp_{i-k}$，在右边则是 $dp_i=L-p_i+dp_{i+k}$。注意我们并不关心每个区域有几个人，我们只关心人在哪个区域。

以下是代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n,k,l;
int a[10000005];
int dp[10000005];
bool right(int i){
    return a[i]>=(l+1)/2;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>k>>l;
    for (int i=1;i<=n;i++) cin>>a[i];
    int b;
    for (int i=1;;i++) {
        if (right(i)) {
            b=i;
            break;
        }
        dp[i]=a[i]+dp[max(0ll,i-k)];
    }
    for (int i=n;right(i);i--) dp[i]=l-a[i]+dp[min(n+1,i+k)];
    int ans=21000000000000000;
    for (int i=1;i<=n;i++){
        if (i+k-1<b) continue;
        if (i+k-1>n||i>=b) break;
        ans=min(ans,2*dp[i-1]+2*dp[i+k]+l);
    }
    cout<<min(ans,dp[b-1]*2+dp[b]*2);
    return 0;
}
```

---

## 作者：zlqwq (赞：2)

怎么这题才黄啊！看来我弱到连黄题都不会了。


数据范围：$n≤10^7$，$l≤10^9$。


就这题目描述加上数据范围，直接考虑 dp。

对于题目中的路径，可以分为左走左回和右走右回两种形式。

但显然，我们可以先向左走若干个点，然后不返回直接再向右绕。这样其实也可以走一圈。

然后开始 dp。这里只设一个数组肯定不行。毕竟有三种情况，而第三种显然又依赖于前两种。

设 $l_i$ 表示向左到 $i$ 的最短路径。

设 $r_i$ 表示向右到 $i$ 的最短路径。

先写操作三，套路的，考虑中间一段走一圈即可。

对于前两种，先算出必走路径，然后又要分类讨论。

设一个数组 $tmp_{i,j}$，这里 $j$ 这是 $1$ 或 $2$，表示不同 dp 数组要更新的值。


然后用原来的值加上 $tmp_{i,j}\times2$ 即可。

原因就是因为走了一段还要原路返回。

敲字不易，请求管理员大大通过。

---

## 作者：JingchenBian (赞：1)

随机到了这么一道题，一看就与我有缘，协议导体截纪念一下。
## [IOI2015] boxes 题解
### 思路分析
这道题目要求我们将一堆箱子分成两部分，分别放入两个仓库中，使得移动的总距离最小。每个箱子的重量和位置是已知的，并且每个仓库有一个容量限制 $L$，一次最多可以搬运 $K$ 个箱子。

我们观察到，如果我们将所有箱子的重量进行转换，使得超过 $L\div2$ 的箱子为 $L-p[i]$（其中 $p[i]$ 是箱子的重量），那么问题就转化为在不超过仓库容量 $L$ 的情况下，将箱子分成两组，使得两组的总重量尽量接近，并且搬运的总距离最小。

具体步骤如下：
#### 数据预处理
将所有箱子分为两类，一类重量小于等于 $L\div2$，另一类重量大于 $L\div2$。

#### 前缀和计算
对于两类箱子，分别计算前缀和，用于快速计算任意区间内箱子的总重量。
#### 枚举分割点
枚举分割点，计算两组箱子的总重量，并更新最小搬运距离。
### 代码实现
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;
const int N=10000005;
int n,K,L,p[N];
int st1[N],st2[N],tp1,tp2;
int f1[N],f2[N];
signed main(){
    cin>>n>>K>>L;
    for (int i=1;i<=n;i++) {
        cin>>p[i];
        if (p[i]<=L>>1) st1[++tp1]=p[i];
        else st2[++tp2]=L-p[i];
    }
    for (int i=1; i<=tp2>>1;i++) swap(st2[i],st2[tp2-i+1]);
    for (int i=1;i<=tp1;i++) f1[i]=(i<=K?st1[i]:st1[i]+f1[i-K]);
    for (int i=1;i<=tp2;i++) f2[i]=(i<=K?st2[i]:st2[i]+f2[i-K]);
    
    int ans=(f1[tp1]+f2[tp2])<<1;
    for (int i=tp1-K;i<=tp1;i++) {
        ans=min(ans,((f1[i]+f2[max((int)0,n-K-i)])<<1)+L);
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Seraphiel (赞：0)

改了好多遍了求管理员大大心慈手软求过。
### 思路

其实就是分情况讨论，大体分为三种情况。

- 左去右反。
- 右去左反。
- 环绕一周。

分析之后会发现是道很明显的贪心，那么对于上述的第一和第二种情况，分两个数组 $d$ 和 $c$ 分类计算。

$d_i=\max(d_0,d_{i-k})+2 \times p_{i-1}$。

注：因为是**往返**所以乘 $2$ 是必须的。

$c$ 数组同理。

最后只需比较大小即可。

---

## 作者：封禁用户 (赞：0)

对于这个圈，我们可以向左走几个点，原路返回。也可以向右走几个点然后返回。但忽略了一种情况：也可以走一圈回来（就是向左 / 向右走几个点之后不原路返回直接从另一个方向回去）。

那么剩下的是我们的决策过程。我们发现，走一圈这种决策只能使用一次，因为走两圈一共会分发 $2k$ 个纪念品，根据抽屉原理，左边和右边肯定会有一侧 $≥k$，那么就不是最优决策。

那么，贪心一下，先用原路返回的方式处理一下比较优的抉择，也就是离零点比较近的左右点。然后再走一圈完事。
```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=1e7+10;
int n,k,l;
int sl[maxn],sr[maxn],cntl,cntr;
int fl[maxn],fr[maxn];
signed main()
{
    scanf("%lld%lld%lld",&n,&k,&l);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%lld",&x);
        if(x<=l/2)
            sl[++cntl]=x;
        else
            sr[++cntr]=l-x;
    }
    for(int i=1;i<=cntr && i<=cntr-i+1;i++)
        swap(sr[i],sr[cntr-i+1]);
    for(int i=1;i<=cntl;i++)
    {
        if(i<=k)
            fl[i]=sl[i];
        else
            fl[i]=fl[i-k]+sl[i];
    }
    for(int i=1;i<=cntr;i++)
    {
        if(i<=k)
            fr[i]=sr[i];
        else
            fr[i]=fr[i-k]+sr[i];
    }
    int ans=(fl[cntl]+fr[cntr])<<1;
    for(int i=cntl-k;i<=cntl;i++)
        ans=min(ans,(fl[i]+fr[max(cntr-k+cntl-i,0ll)])*2+l);
    printf("%lld",ans);
    return 0;
}

```

---


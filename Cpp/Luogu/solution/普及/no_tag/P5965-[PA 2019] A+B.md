# [PA 2019] A+B

## 题目描述

在列竖式计算两个十进制数的和的时候，人们可能会错算成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/g0xa2tjn.png)

在图里的左边，$248+208$ 被错算成了 $4416$。

给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被错算成 $n$。

请注意 $a$ 可以等于 $b$，且 $a=1,b=2$ 和 $a=2,b=1$ 是两种不同的方案。

## 说明/提示

对于 $100\%$ 的数据，$1\le n<10^{18}$。

## 样例 #1

### 输入

```
112```

### 输出

```
50```

# 题解

## 作者：jyz666 (赞：14)

# 题解 P5965 【[PA2019]A+B】

[传送门](https://www.luogu.com.cn/problem/P5965)

退役题解...

去冲文化课了。（泪目）

感谢[巨佬](https://www.luogu.com.cn/user/129390)帮我调的 $\LaTeX$


简单数位 DP，令 f[i]表示到第i位的方案数。

那么转移非常显然：

1. 第i位由一对数字加出

2. 第i位和第i-1位一起由一对数字加出

即
$$
\begin{cases}
f \lbrack i \rbrack = f \lbrack i-1 \rbrack \times (a \lbrack i \rbrack + 1)  & \text { if $ a \lbrack i-1 \rbrack \neq 1 $} \\
f \lbrack i \rbrack = f \lbrack i-1 \rbrack \times (a \lbrack i \rbrack + 1) + f \lbrack i-2 \rbrack \times (9 - a \lbrack i \rbrack) & \text { if $ a \lbrack i-1 \rbrack = 1 $}
\end{cases}
$$

直接计算即可。

### 上代码》》
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
inline void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
const int maxn=25;
int len,a[maxn];
string s;
ll f[maxn];
int main(){
	cin>>s;
	len=s.size();
	for(int i=1;i<=len;i++)
		a[i]=s[i-1]-'0';
	f[0]=1;
	for(int i=1;i<=len;i++){
		f[i]=f[i-1]*(a[i]+1);
		if(i>=2&&a[i-1]==1)
			f[i]+=f[i-2]*(9-a[i]);
	}
	printf("%lld",f[len]);
	return 0;
}

```

谢谢大家，谢谢$Luogu$,再见。

---

## 作者：Terrific_Year (赞：8)

# [P5965](https://www.luogu.com.cn/problem/P5965)
看到没有C++的题解，我就来发一篇吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[20];
long long f[20];
int main(){
	scanf("%s",a+1);
	int l=strlen(a+1);
	f[l+1]=1;
	for(int i=l;i>=1;i--)f[i]=f[i+2]*(a[i]==49&&i<l?9-a[i+1]+48:0)+f[i+1]*(a[i]-48+1);
	cout<<f[1];
	return 0;//完美AC
} 
```
具体是参考了楼上Pascal的题解，C++的辛苦了。

---

## 作者：liuziwen0224 (赞：5)

# problem
计算加法的时候有可能直接相加了，而没有进位。比如：

```9999+99=991818```

给定数$n$，求有多少种方案能够错算成这个数。
# solution

1. 第$i$位由一对数字加出
2. 第$i$位和第$i-1$位一起由一对数字加出

$$\begin{cases} dp \lbrack i \rbrack = dp \lbrack i-1 \rbrack \times (a \lbrack i \rbrack + 1) & \text { if $ a \lbrack i-1 \rbrack \neq 1 $} \\ dp\lbrack i \rbrack = dp \lbrack i-1 \rbrack \times (a \lbrack i \rbrack + 1) + dp \lbrack i-2 \rbrack \times (9 - a \lbrack i \rbrack) & \text { if $ a \lbrack i-1 \rbrack = 1 $} \end{cases} $$


# code
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
long long read(){
	long long op=1,a=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') op=-1;c=getchar();}
	while(c>='0'&&c<='9'){a*=10,a+=c^48,c=getchar();}
	return a*op;	
}
char a[20];
long long f[20];
int main(){
	scanf("%s",a+1);
	int l=strlen(a+1);
	f[l+1]=1;
	for(int i=l;i>=1;i--){
		int val=(a[i]==49&&i<l?9-a[i+1]+48:0);
		f[i]=f[i+2]*val+f[i+1]*(a[i]-48+1);
	}
	printf("%lld",f[1]);
	return 0;
} 

```


---

## 作者：一只书虫仔 (赞：4)

#### Description

> 人们常常会忘记进位导致错算，给定 $n$，求有多少对 $a+b$ 会错算成 $n$。

#### Solution

（下面的 $n[i]$ 即为 $n$ 的第 $i$ 位数）

考虑动归，定义 $dp[i]$ 为截止到第 $i$ 位有多少种方案，加到第 $i$ 位有 $n[i]+1$ 种可能，转移方程即为：

$$dp[i]=dp[i-1] \times (n[i]+1)$$

但是，当 $n[i]=1$ 时，很有可能是两个数加起来比 $10$ 大了（也就是符合忘记进位这一点），因此当 $n[i]=1$ 时，$dp[i]$ 还要加上 $dp[i-2] \times (9-n[i])$。

注意，因为竖式是从右到左的，所以需要反着来，因此上面的一些 $-$ 可能要变成 $+$。

---

## 作者：nynkqh_yzp (赞：3)

简单的动态规划题，设 $f_i$ 表示 $n\ \bmod\ 10^{i}$ 的方案数，$a_i$ 表示 $n$ 的第 $i$ 位。

转移：当 $a_i$ 不等于 $1$ 时，$f_i=f_{i-1}\times(a_i+1)$。

当 $a_i$ 等于 $1$ 时，$f_i=f_{i-1}\times(a_i+1)+f_{i-2}\times(9-a_{i-1})$。
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[70],an,f[70];
int main(){
	scanf("%lld",&n);
	while(n!=0){
		a[++an]=n%10;
		n/=10;
	}
	f[0]=1;
	for(int i=1;i<=an;i++){
		if(i==1||a[i]!=1)
			f[i]=f[i-1]*(a[i]+1);
		else
			f[i]=f[i-1]*(a[i]+1)+f[i-2]*(9-a[i-1]);
	}
	printf("%lld",f[an]);
	return 0;
}

```



---

## 作者：asdfo123 (赞：3)

# 强烈建议修改题面

这道题我看题目描述卡了好久，题目中描述的是：

给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被**错算**成 $n$。

但是实际上题目可以理解为规定了一种不同于普通竖式加法的新运算，对于这种运算：

我们将所有的原位置按每一位按位置进行加法，

所以每一位的范围是 $0 - 18$

换句话说，这个题目说错算是不对的，很有可能符合正常竖式计算的也会符合这种新运算。

举个例子，$66+22 = 88$，这就是即符合竖式计算也符合该新运算的，也会被计算成一种情况。

理解了这个就好办了。。

其他的别人的讲解已经很清楚了，我们考虑$f[i]$ 为前 $ｉ$ 个数字的方案。
$f[i]$ 只可能由 $f[i-1]$ 或 $f[i-2]$（且 $a[i-1]$ 只能是 $1$）的状态转移过来。。

那就好办了。。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
char s[20];
ll a[20];
ll len;
ll f[20];
int main()
{
	scanf("%s",s+1);
	ll len = strlen(s+1);
	for(int i = 1;i <= len;i++)
	{
		a[i] = s[i] - '0';
	}
	f[0] = 1;
	f[1] = a[1]+1;
	for(int i = 2;i <= len;i++)
	{
		f[i] = f[i-1]*(a[i]+1);
		if(a[i-1] == 1) f[i] += f[i-2]*(9-a[i]);
	}
	printf("%lld\n",f[len]);
	return 0;
}
```




---

## 作者：ZHANGyutao123 (赞：2)

# P5965 [PA2019]A+B题解
## [传送门](https://www.luogu.com.cn/problem/P5965)
## 题目大意：

给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被错算成 $n$。其中 $a$ 可以等于 $b$，且 $a=1,b=2$ 和 $a=2,b=1$ 是两种不同的方案。

## 过程分析：

我们考虑从第 $i$ 个位置开始，往后拼凑数字得到的每一个数都可以构成一个和为 $n$ 的数对。则从左往右第 $i$ 个位置上数字的选取将会影响其后位置所形成的每一个数对是否满足条件。

我们假设当前第 $i$ 个位置上的数字为 $a_i$：

- 如果 $a_i \neq 0$，则第 $i$ 个位置所选取的数字会对可以构成的数对的个数产生贡献，我们考虑第 $i$ 个位置上选取的数字与其后面能够构成的和的大小关系：
  - 如果第 $i+1$ 个位置上选取的数字 $a_{i+1} > a_i$，那么我们此时选取 $a_i$ 就会将 $n$ 中以 $1a_i$ 开头的数对都选中进去。这里需要注意，如果我们把 $a_i$ 选择为 $9,8,\ldots, a_{i+1}$ 中的任意一个数后，其会导致这段区间的数对被重复统计，因此 $f_i$ 需要减去这个区间里面的数对数量，即 $\displaystyle (a_{i+1} - a_i - 1) \times f_{i+2}$。
    $$f_i = f_{i+1}\times(a_i+1) + f_{i+2}\times(a_{i+1}-a_i-1)$$
  - 如果第 $i+1$ 个位置上选取的数字 $a_{i+1} = a_i$，那么我们此时选取 $a_i$ 就会将 $n$ 中以 $2a_i$ 开头的数对都选中进去。由于此时 $a_i + a_{i+1} = 2a_i = a_{i+1} + a_i$，所以选取 $a_i$ 和 $a_{i+1}$ 代替 $a_i$ 和 $a_{i+1}$ 中的任意一个，结果是等价的。不重不漏，直接加上 $f_{i+2}$ 即可。
    $$f_i = f_{i+1}\times(a_i+1)+f_{i+2}$$
  - 如果第 $i+1$ 个位置上选取的数字 $a_{i+1} < a_i$，显然此时不能选 $a_i$，否则一定不能满足和为 $n$。这种情况下 $f_i$ 不需要加上任何贡献。
    $$f_i = f_{i+1}\times(a_i+1)$$
- 如果 $a_i = 0$，则该位置上的数字对最终方案不会增加任何贡献，只能继续和该数位后的位置一起构成比 $n$ 更大的数对。因此我们可以得到：
  $$f_i = f_{i+1}$$

状态计算的过程结束后，我们最终得到的 $f_1$ 即为答案。

### 状态转移方程：

$$f_i=\begin{cases}f_{i+2}\times (9- a_{i+1}) +f_{i+1}\times (a_i+1) &(a_i = 1, 1\leq i \leq len-1)\\f_{i+2}+f_{i+1}\times (a_i+1) &(a_i \geq 2)\\f_{i+1} &(a_i = 0)\end{cases}$$

## 代码
讲的这么详细，应该不用了吧。

---

## 作者：Convergent_Series (赞：1)

考虑数位 dp，令 $dp_i$ 为从左往右算到第 $i$ 位时的方案数。

对于第 $i$ 位：
+ 这一位单独由两个数字加出，有 $dp_{i-1}\times(n_i+1)$ 种方案；
+ 若 $n_{i-1}=1$，则这两位可能由同一组数字加出，方案要加上 $dp_{i-2}\times(9-n_i)$。

根据上面的状态转移方程即可写出代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=25;
int ln,a[20],dp[20];
string s;
signed main(){
	cin>>s;
	ln=s.length();
	for(int i=1;i<=ln;i++) a[i]=s[i-1]-'0';//分离每一位
	dp[0]=1;//到第0位时仅有一种方法（0+0）
	for(int i=1;i<=ln;i++){
		dp[i]=dp[i-1]*(a[i]+1);
		if(i>=2&&a[i-1]==1) dp[i]+=dp[i-2]*(9-a[i]);
	}
	cout<<dp[ln];
	return 0;
}
```

---

## 作者：i_love_tym (赞：1)

# 题意

这题其实可以看做是定义了一种新的运算方法，比如在正常竖式中 $9+9$。
应该表示为 $8$ 进 $1$，但是在新运算中，$9+9$ 会直接表示为 $18$，然后将前面还没算的数向前一位。 

而题目就是让你求出 $n$ 这个数可以表示为多少对 $a \oplus b$。 其中 $\oplus$ 表示上文的新运算。


# 解法

考虑按照数位来进行 DP。

定义 $f_i$ 表示前 $i$ 位的方案数，则最终答案在 $f_{\log_{10}n}$。

显然，状态转移方程为：

$f_i=\begin{cases}  
a_{i-1} \not= 1, &f_{i-1} \times (a_i+1)  \\
a_{i-1} = 1, &f_{i-1} \times (a_i+1) + f_{i-2} \times (9-a_i)
\end{cases}$

其中 $a_i$ 表示 $n$ 的第 $i$ 位上的数。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[20],f[20];
inline void change(string s){
	for(int i=0;i<s.size();i++) a[i+1]=s[i]-'0';
}
signed main(){
	string s;
	cin>>s;
	change(s);
	f[0]=1;
	int n=s.size();
	for(int i=1;i<=n;i++){
		if(a[i-1]!=1) f[i]=f[i-1]*(a[i]+1);
		else f[i]=f[i-1]*(a[i]+1)+f[i-2]*(9-a[i]);
	}
	cout<<f[n];
}
```

---


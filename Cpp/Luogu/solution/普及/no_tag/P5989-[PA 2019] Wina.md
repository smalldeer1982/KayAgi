# [PA 2019] Wina

## 题目描述

 $n$ 行 $\dfrac{n\times(n+1)}{2}$ 个数叠成了一个数塔。

给定 $k$，你需要从中拿走恰好 $k$ 个数，使得拿走的数的最小值最小。一个数能被拿走当且仅当它左上角和右上角都没有数或者那个数已经被拿走了。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 2000$，$1\le k\le \dfrac{n\times(n+1)}{2}$。


### 样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/pya9rv24.png)

## 样例 #1

### 输入

```
5 7
1999
2019 2010
850 1500 1600
900 900 710 900
1000 800 600 800 1000```

### 输出

```
710```

# 题解

## 作者：StudyingFather (赞：5)

贪心。

设 $f_{i,j}$ 表示取走第 $i$ 行第 $j$ 个数**最少**需要取多少个数。

那么答案当然是 $\min_{f_{i,j} \leq k} a_{i,j}$。

$f_{i,j}$ 咋算呢？

首先考虑对称性，$f_{i,j}=f_{i,i+1-j}$，因此就只用考虑 $j \leq \left \lceil \dfrac{i}{2} \right \rceil$ 的情况了。

稍微打个表就会发现（下面都有 $j \leq \left \lceil \dfrac{i}{2} \right \rceil$）：

$$
f_{i,j}=(i-j+1) \times j
$$

下面是对上面式子的一个通俗理解：最长的一行长度是 $j$，剩下的行都可以通过拼接的方式将长度拼成 $j$，最后一共有 $i-j+1$ 个长度为 $j$ 的行。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n,k,ans=2019;
int f(int x,int y)
{
 if(x/2<y)y=x+1-y;
 return (x-y+1)*y;
}
int main()
{
 ios::sync_with_stdio(false);
 cin>>n>>k;
 for(int i=1;i<=n;i++)
  for(int j=1;j<=i;j++)
  {
   int num;
   cin>>num;
   if(f(i,j)<=k)ans=min(ans,num);
  }
 cout<<ans<<endl;
 return 0;
}
```


---

## 作者：zhangzihang (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P5989)

# 题目大意

- 给定一个 $n,k$，以及一个 $a$ 数组。
- 要求拿走 $k$ 个数，使得拿到的所有数种最小的数最小。
- 只有左上，右上都没有数或已被取走该数才能被取到。
------------
我们来分析一下方法，我们要在 $\dfrac{n(n+1)}{2}$ 个数中找到最小的数，而且满足取到该点时总共取得数 $s \le k$ 我们可以考虑建立一个数组 $f_{i,j}$，表示取到点 $a_{i,j}$。时取的最少点的个数。

稍微分析一下样例我们可以发现 $f_{i,j}=(i-j+1)\times j$。

所以代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2005][2005],f[2005][2005]; // f[i][j]表示取到第i,j个点的最少次数 
int main(){
	int n,k;cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			cin>>a[i][j];
	dp[1][1]=1;
	for(int i=2;i<=n;i++)  //计算f数组 
		for(int j=1;j<=i;j++)
			f[i][j]=(i-j+1)*j;
	int ans=2020;
	for(int i=1;i<=n;i++) //遍历所有点找到取到该点次数小于等于k的最小值点 
		for(int j=1;j<=i;j++)
			if(f[i][j]<=k)
				ans=min(ans,a[i][j]);
	cout<<ans; 
	return 0;
}
```



---

## 作者：yuheng_wang080904 (赞：2)

## 思路

首先，我们观察样例给出的图形，可以发现，一个数要被取出，假设它左上方数的个数为 $x$，右上方的数的个数为 $y$，那么需要 $(x+1)(y+1)$ 次。假设这个数在第 $i$ 行第 $j$ 列，$x=j$，$y=i+1-j$，这个可以通过等腰三角形的性质来证明。所以我们只需要枚举所有 $i,j$，判断 $j\times (i+1-j)$ 是否大于等于 $k$ 即可。时间复杂度 $O(n^2)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans=1e9,a;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>a;
            if((i-j+1)*j<=k)ans=min(ans,a);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Seauy (赞：2)

~~并不知道 $ PA $ 是什么个神奇的比赛，貌似比较冷门~~

------------

题目要求的是所有取的数的最小值的最小值，我们换一个方式理解

如果一个数是答案，那么它得满足两个条件：

1. 它能够被我们取到

2. 它得是最有取的数中最小的

首先看第一条，如果我们要尽量使这个数能被我们取到，那我们就尽量不能浪费我们取数的 $ k $ 次机会

它被取到了，那么它的左上与右上都得被取到，被取到的数还得被取到……以此类推。而这些数字都是必须得被取到的，所以我们做到了尽量不浪费取数的机会

那么以最优策略取的数的次数能 $ \leq k $，这个数就能被取到

再看第二条，如果这个数是能被取到的，那么使它能被取到的顶上的那些数也是能被取到的，因此所有能被取到的数都可能是取到的数

题目要求取的数的最小值的最小值，因此我们只要找能取到的数的最小值就行了

最后的问题就在于怎样快速判断一个数是否能被取到

------------

如果一个数能被取到，那么这个数肯定满足 最优策略取的数的次数能 $ \leq k $

能快速计算在最优策略下取的数的次数就是重点

你可以通过看图观察出公式，当然你也可以写出递推式

$ f[x,y]=f[x-1,y-1]+f[x,y-1]-f[x-1,y-2]+1 $

$ (1 \leq x \leq y , 1\leq y \leq n) $

初值是 $ f[1,1]=1 $，不在定义域范围的值为 $ 0 $，加个记忆化就行了

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=2e3;

int n,k,ans=INT_MAX;
int mapn[MAXN+5][MAXN+5];

int mem[MAXN+5][MAXN+5];
int Need(int x,int y)
{
	if(mem[y][x]) return mem[y][x];
	if(x==1 && y==1) return mem[y][x]=1;
	if(x<1 || x>y || y<1) return 0;
	return mem[y][x]=(Need(x-1,y-1)+Need(x,y-1)-Need(x-1,y-2)+1);
}

int main()
{
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			scanf("%d",&mapn[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			if(Need(j,i)<=k) ans=min(ans,mapn[i][j]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：yz_zy (赞：0)

# [ [PA 2019] Wina](https://www.luogu.com.cn/problem/P5989) #


由题意可知，一个数要想被取走，需要满足这个数左上角和右上角的数都被取走。

手推一下便可以知道，对于一个位置 $i,j$，它左上角的数有 $j$ 个，右上角的数有 $i-j+1$ 个，故若该数能取，就需要满足 $j\times(i-j+1)\le k$，根据这个思路，编写代码。

**代码**

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,ans=1e18;
signed main(){
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=n;i++)for(int j=1;j<=i;j++){
		int x;cin>>x;
		if(j*(i-j+1)<=k) ans=min(ans,x);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zymooll (赞：0)

看各路大佬，本蒟蒻只会暴力。。
### 题目描述
在一个 $n \times m$ 的矩阵中，在 $k$ 步之内，取一个最小值，当取一个数 $a_{i,j}$，其必须满足 $a_{i-1,j}$ 和 $a_{i-1,j+1}$ 为空或为 $0$，且需要花费 $1$ 步。

### 实现方式
通过打表可以推出公式：$k=(i-j+1) \times j$ （其中 $k$ 代表取 $a_{i,j}$ 需要花费的步数）。

之后可以通过进行枚举每个点，将需求步数小于可以走的步数加入数组，最后跑一边数组取最小值即可。

主函数 时间 $\Theta(n^2)$，空间 $\Theta(n^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans=INT_MAX;
int a[2010][2010];
vector<int>q;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin>>a[i][j]; 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			int ls=(i-j+1)*j;
			if(ls<=k)q.push_back(a[i][j]);
		}
	}
	for(int i=0;i<q.size();i++){
		ans=min(ans,q[i]);
	}
	cout<<ans;
	return 0;
}
```


---


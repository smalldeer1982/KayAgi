# 准备战斗，选择你的英雄

## 题目背景

zjf，被 NOIP 普及组初赛戏耍，pj 1= -> 初赛三等，愤恨地离开了 OI，深陷中考的泥潭当中。据说，他颓废是因为玩多了 [OW](https://ow.blizzard.cn/home) 这款游戏。

## 题目描述

目前，游戏共有 $31$ 个英雄，每局可以派 $6$ 个英雄上场。实际能使用的英雄数将会小于 $31$。简单地假设，每位英雄对团队的贡献可以用一个正整数 $v_i$ 表示。团队的总能力等于所有英雄的贡献之和。特别地，对于 $m$ 组特定的英雄，他们一起出现会让团队总能力提高 $x_i$。

**另注：英雄组合可以重复，若重复请多次计数。**

## 说明/提示

#### 样例 1 解释
我们应该选择前 $6$ 名英雄。

---

#### 样例 2 解释
我们应该选择 Pharah、Mercy、Reinhardt、DVA、SOLDIER:76、Anna

---

#### 数据范围
对于 $40\%$ 的数据，$m=0$。  
对于 $100\%$ 的数据，$6\le n \le 30$，$0\le m \le 30$，*$1\le x_i,v_i \le 100$*，英雄名字长度 $\le 10$，字符集包括大小写字母、数字以及冒号（ `:` ）。每个英雄的名字各不相同。


## 样例 #1

### 输入

```
7 0
Sigma 10
Orisa 10
Mei 10
Reaper 10
Moira 10
Lucio 10
Doomfist 1```

### 输出

```
60```

## 样例 #2

### 输入

```
8 2
Pharah 5
Mercy 5
Reinhardt 10
DVA 10
SOLDIER:76 12
Torbjorn 5
Anna 8
Baptiste 10
Pharah Mercy 20
Anna Pharah 5```

### 输出

```
75```

# 题解

## 作者：lzqy_ (赞：15)

### 一道暴力搜索题，但是个人感觉并没有其他大佬写的那么复杂

思路就很简单，用一个$map$来记录名字对应的编号，然后通过$DFS$枚举取六个英雄的所有可能性（不需要考虑别的，纯枚举）。不会$DFS$的[点这里](https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224976?fromtitle=DFS&fromid=5055&fr=aladdin)。

所以，我们用$DFS$实现从$1$~$n$个数字里选$6$个数字，且不考虑顺序（最简单、最基础的深搜）。

#### 注意：

题目的坑点是`英雄组合可以重复`，记得考虑这一点。

------
具体实现方法看代码（有详细注释）：
```
#include <bits/stdc++.h>
using namespace std;
map<string,int>m;
int together[100][100],power[100],a[100]={1},ans,n,K;
//together[i][j]表示第i,j个英雄同时上阵增加的能力值；
//power[i]表示第i个英雄的个人能力值；
//a数组用来记录DFS枚举结果。
bool k[100];
void moni()
{
  int pmax=0;
  for(int i=1; i<=6; i++)
  {
    pmax+=power[a[i]];//加上英雄的个人能力值
    for(int j=1; j<=n; j++)//范围不大直接爆搜
      if(k[j])//如果另一个英雄也上阵了
        pmax+=together[a[i]][j];
  }
  ans=max(ans,pmax);//更新最大值
}
void dfs(int kk)//典型深搜
{
  if(kk==7||kk==n+1)//枚举完六个英雄或是n个英雄
    moni();
  else
    for(int i=a[kk-1]; i<=n; i++)
      if(!k[i])//如果第i个英雄没有上阵
      {
        k[i]=1;
        a[kk]=i;
        dfs(kk+1);
        k[i]=0;
      }
}
int main()
{
  string s,ss;
  cin>>n>>K;
  for(int i=1; i<=n; i++)
  {
    cin>>s>>power[i];
    m[s]=i;//名字s对应编号i
  }
  for(int i=0; i<K; i++)
  {
      cin>>s>>ss>>h;
      together[m[s]][m[ss]]+=h;
      //注：此处要用+=来进行叠加
  }
  dfs(1);//开始深搜
  cout<<ans;//输出结果
  return 0;
}
```
#### **$for$新手（个人的建议）：**

深搜的时候不用考虑那么多，只枚举简单的，至于后面的模拟，不要放在深搜里面执行，这样的思路会更清晰些。

---

## 作者：Wenoide (赞：6)

发现数据范围较小。可以使用时间复杂度为 $O(n^6)$ 的 `DFS` 解决。

使用 `DFS` 枚举出所有可能的情况，统计答案。

对于存在属性加成的英雄组合，可以直接储存并在统计时暴力枚举，也可以使用 `std::map` 或 `字符串哈希`。

需要注意：英雄组合可以重复，若重复请多次计数。

参考代码：

```
#include<cstdio>
#include<cstring>

const int BASE=131;
const int MOD=991;
unsigned fun(char *p){
	int l=strlen(p);
	unsigned ans=0;
	for(int i=0;i<l;++i){
		ans=ans*MOD+p[i];
	}
	return ans;
}
char key[MOD][20];
int num[MOD],cnt;
int find(char *p){
	int g=fun(p)%(MOD-1)+1;
	for(int i=fun(p)%MOD;;i=(i+g)%MOD){
		if(strcmp(key[i],p)==0){
			return num[i];
		}
		if(strlen(key[i])==0){
			strcpy(key[i],p);
			return num[i]=cnt;
		}
	}
	return -1;
}
//字符串哈希，给每位英雄编号 1...n。

int val[50],tm[50][50];
//val 储存每位英雄对团队的贡献，tm(i,j) 表示第 i 位英雄与第 j 位英雄组合的额外贡献。
int ans;
int n,m;
int p[10];
void DFS(int tot,int cur,int sum){
	if(tot==6){
		if(sum>ans){
			ans=sum;
		}
		return;
	}
	for(int i=cur;i<n;++i){
		int t=sum+val[i];
		for(int j=0;j<tot;++j){
			t+=tm[i][p[j]];
		}
		p[tot]=i;
		DFS(tot+1,i+1,t);
	}
	return;
}
//DFS，搜索英雄编号，枚举出所有可能的情况，统计答案。

int main(){
	scanf("%d%d",&n,&m);
	while(cnt<n){
		char s[20];
		scanf("%s",s);
		int t;
		scanf("%d",&t);
		find(s);
		val[cnt++]=t;
	}
	for(int i=0;i<m;++i){
		char a[20],b[20];
		scanf("%s%s",a,b);
		int t;
		scanf("%d",&t);
		int u=find(a),v=find(b);
		tm[u][v]+=t,tm[v][u]+=t;
		//找到英雄 a,b 的编号，储存额外贡献。  
	}
	DFS(0,0,0);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：gyh20 (赞：3)

直接枚举即可（常数小，代码短，直接到最优解）

用 $map$ 记录字符串。

由于可能有重边，所以记录两个人一起产生的贡献应该用 $+=$ 而不是 $=$。

其他没什么好说的，总复杂度： $O(n^6+m)$ 并且完全跑不满，实际上是 $C_n^6$。

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
int n,m,val[32],g[32][32],ans;
map<string,int>mp;
char s[12],ss[12];
inline int read(){
	re int t=0;
	re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
int main(){
	n=read(),m=read();
	for(re int i=1;i<=n;++i){
		scanf("%s",s+1);
		mp[s+1]=i;
		val[i]=read();
	}
	for(re int i=1;i<=m;++i){
		scanf("%s%s",s+1,ss+1);
		re int x=mp[s+1],y=mp[ss+1];
		re int kk=read();
		g[x][y]+=kk;
		g[y][x]+=kk;
	}
	for(re int a=1;a<=n;++a)
		for(re int b=a+1;b<=n;++b)
			for(re int c=b+1;c<=n;++c)
				for(re int d=c+1;d<=n;++d)
					for(re int e=d+1;e<=n;++e)
						for(re int f=e+1;f<=n;++f)ans=max(ans,val[a]+val[b]+val[c]+val[d]+val[e]+val[f]+g[a][b]+g[a][c]+g[a][d]+g[a][e]+g[a][f]+g[b][c]+g[b][d]+g[b][e]+g[b][f]+g[c][d]+g[c][e]+g[c][f]+g[d][e]+g[d][f]+g[e][f]);
	printf("%d",ans);
}
```


---

## 作者：sipu6174 (赞：1)

思路都是复杂度$O(C_n^6)$的，都是暴力枚举英雄，然后直接判断值。

~~曾经想写贪心最后放弃了。~~

这里介绍一种stl的string类型字符串比较方法。

我们先需要两个结构体u与v，一个存英雄的属性，一个存附加条件（结合加成）。

```cpp
struct hero{
   string s;
   int v;
}p[40];
struct extra{
   string a;
   string b;
   int v;
}q[40];
```

关于string类型的比较有一个函数叫s1.compare(s2)或者s2.compare(s1)，当它返回0时表示s1,s2相同，返回-1时表示不同。

这里的12个compare语句稍微有些难懂，这里解释一下。对于给定的一种组合，先用左边那个英雄跟所有选定英雄配对，再用右边的配对。因为左右两遍的英雄不会是同一个，所以是一种等价的写法，并不影响结果。只要有两组配对成功，就说明u,v这两种英雄都在选定英雄中存在，可以加上他们的附加值。

```cpp
int getv(int a,int b,int c,int d,int e,int f){
   int ans=p[a].v+p[b].v+p[c].v+p[d].v+p[e].v+p[f].v;
   for(int i=1;i<=m;i++){
      int flg=0;
      string u=q[i].a,v=q[i].b;
      if(u.compare(p[a].s)==0||v.compare(p[a].s)==0) flg++;
      if(u.compare(p[b].s)==0||v.compare(p[b].s)==0) flg++;
      if(u.compare(p[c].s)==0||v.compare(p[c].s)==0) flg++;
      if(u.compare(p[d].s)==0||v.compare(p[d].s)==0) flg++;
      if(u.compare(p[e].s)==0||v.compare(p[e].s)==0) flg++;
      if(u.compare(p[f].s)==0||v.compare(p[f].s)==0) flg++;
      if(flg==2) ans+=q[i].v;
   }
   return ans;
}
```

至于枚举部分，直接暴力六重for循环即可。


---

## 作者：袁宇轩 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6248)

可以看出数据非常的小，直接**搜索**暴力解决。

首先要解决字符串：map大法不香吗~~C++福利啊~~。

其次由于我比赛时没有看到一个重要信息，只得了70分qwq。

### 重要信息：英雄组合可以重复，若重复请多次计数。

------------

**思路：**

    变量声明：

    v[i]记录每个英雄的贡献值；

    map<string,int>记录英雄所对应的编号；

    c[i][j]记录英雄i与英雄j组合时的贡献；

    b数组记录每次暴力枚举英雄的编号。
   
我们先把英雄名字用map转化为编号，然后记录组合英雄的贡献，再暴力枚举选取哪6个英雄，最后将每次枚举的总贡献值与答案比较，取较大的。

 _Code:_ 
 
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)
inline ll read(){
	ll x=0;char ch=getchar();bool f=0;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return f?-x:x;
}
void write(ll x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);putchar(x%10+'0');
}
void writeln(ll x){write(x);puts("");}
void writep(ll x){write(x);putchar(' ');}

int const N=30+3;
int n,m,ans,v[N],b[N],c[N][N];
map<string,int> mp;

void dfs(int x,int k,int s){//考虑x编号对应的英雄成为第k个选择英雄，之前每个英雄单独的贡献和为s
	if (k>6){//已满6个英雄
		int res=s;
		for (int i=2;i<=6;i++)
		  for (int j=1;j<i;j++)
		    res+=c[b[i]][b[j]];//对于组合英雄的贡献
		ans=max(ans,res);//更新答案
		return;
	}
	if (x>n) return;//选完了
	b[k]=x;//选
	dfs(x+1,k+1,s+v[x]);
	b[k]=0;//不选
	dfs(x+1,k,s);
}
int main(){
	n=read();m=read();
	for (int i=1;i<=n;i++){
		string s;
		cin>>s;
		v[i]=read();
		mp[s]=i;//名字转化成编号
	}
	for (int i=1;i<=m;i++){
		string x,y;
		cin>>x>>y;
		c[mp[x]][mp[y]]=c[mp[y]][mp[x]]=c[mp[x]][mp[y]]+read();//注意要加，而不是直接赋值，否则只有70分了
	}
	dfs(1,1,0);
	writeln(ans);
	return 0;
}
```


---

## 作者：chenpengda (赞：1)

来写篇题解吧。虽然没时间做只拿了70分，但是还是比较容易想到正解的。

算法方面用了dfs，搜索6个英雄，比较最大值（即暴力枚举法）。其他的写在代码里了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x[35][35],ans=0;//x[i][j]：第i和第j个武将同时登场加的战力值
bool visited[35];
struct ying_xiong //这个储存英雄，zhanli为战力，name为名字。
{
	int zhanli;
	string name;
}a[35];
int find_wei(string you_should_find)//暴力枚举搜索名字的对应编号（我太菜了不会用stl）
{
	for(int i=1;i<=n;i++)
	{
		if(a[i].name==you_should_find)return i;
	}
}
int suan(int xxx)//计算加入这个武将可以增加多少“联动”能力值，其中因为只算一次，所以把这个之前选的武将加起来就可以了。
{
	int s=0;
	for(int i=1;i<=n;i++)
	{
		if(visited[i])s+=x[i][xxx];
	}
	return s;
}
void dfs(int ren,int nowwei,int k)//主体，ren是现在选的人数，nowwei是现在要选择的武将位置，k是当前能力值
{
	if(ren==6)//选好了，比较
	{
		ans=max(ans,k);
	}
	else
	{
		for(int i=nowwei;i<=n;i++)//重复执行：如果选第i个武将
		{
			visited[i]=1;//visited代表是否选过这个武将，便于计算联动能力值
			int fff=k+suan(i)+a[i].zhanli;//加上战力
			dfs(ren+1,i+1,fff);//下一个武将
			visited[i]=0;//算好了，就不选他
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].name>>a[i].zhanli;//读入名字与战力
	}
	string ai,bi;
	int sum;
	for(int i=1;i<=m;i++)
	{
		cin>>ai>>bi>>sum;
		int aci=find_wei(ai),bci=find_wei(bi);//查找这些武将的名字
		x[aci][bci]+=sum;x[bci][aci]+=sum;//原来两个武将之间可能有多次联动啊，考场上30分就这样没了
	}
	dfs(0,0,0);//大法师000
	cout<<ans;//输出即可
	return 0;
}
```


---

## 作者：BFqwq (赞：1)

为什么感觉其他人的 dp 都这么复杂呢 qaq

直接给所有人标号，枚举选谁，然后判断一下两两之间如果一起选有多少的加成。

如果这两个人没有组合，那么一起选的加成就是 $0$。

复杂度 $C_{n}^6\times 6^2$ （可能稍微多一点点）。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(register int x,register char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
map<string,int> mp;
struct yx{
	int a;
	string s;
}y[100];
bool cmp(yx a,yx b){
	return a.a>b.a;
}
int n,b[100][100],m,c[100],mx;
int tmp[100],now;
void chk(){
	int k=0;
	for(int i=1;i<=6;i++){
		k+=y[tmp[i]].a;
	}
	for(int i=1;i<=6;i++){
		for(int j=i;j<=6;j++){
			k+=b[tmp[i]][tmp[j]];
		}
	}
	mx=max(mx,k);
}
void dfs(int g){
	if(g>n) return;
	tmp[++now]=g;
	if(now==6){
		chk();
	}
	else{
		dfs(g+1);
	}
	now--;
	dfs(g+1);
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		cin>>y[i].s;
		y[i].a=read();
		mp[y[i].s]=i;
	}
	for(int i=1;i<=m;i++){
		string s1,s2;
		cin>>s1>>s2;
		c[i]=read();
		b[mp[s1]][mp[s2]]+=c[i];
		b[mp[s2]][mp[s1]]+=c[i];
	}
	dfs(1);
	print(mx);
	return 0;
}
```

---

## 作者：Alarm5854 (赞：1)

推销一下新博客：https://yce3216037.github.io/post/luo-gu-p6248-ti-jie/

这道题目是一个搜索题，数据范围很小，但是不可以直接暴搜，否则直接 TLE，但是由于题目说选择 $6$ 个人，所以可以略加剪枝，时间复杂度从 $2^n\times m$ 转为 $C_n^6\times m$ 了，可以通过本题。输入的名字可以用 map 存起来，而且可以利用位运算省去回溯。
```cpp
#include<map>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 30 + 10;
FILE *fin, *fout;
inline int read(int &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline int read(string &s) {
	s = ""; char c = 0;
	while (c == 32 || c == 10 || c == 13 || c == 0) c = fgetc(fin); if (c == -1) return 0;
	while (!(c == 32 || c == 10 || c == 13 || c == 0 || c == -1)) s += c, c = fgetc(fin);
	return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
string name, u, v;
map<string, int> ma;//ma[s]表示名字为s的人的下标
int n, m, ans, a[N], k[N], gay[N];//a[i]表示第i个人的初始实力，k[i]表示第i对人新增的实力，gay[i]表示第i对人的两个下标，从0开始，例如10(1010)表示1号和3号可以新增实力
void dfs(int x, int y, int res, int bit) {//x表示现在到了第x个人，y表示选择了y个人，res表示目前的总实力，bit表示选择的人，例如22(10110)表示选择了1、2、4号
	if (n - x + y < 6) return;//要是到结尾都不能选够6个人，直接返回
	if (y == 6) {//如果选择了6个人了
		for (int i = 0; i < m; ++i)//每个gay都枚举一遍
			if ((bit & gay[i]) == gay[i])
				res += k[i];
		ans = max(ans, res);
		return;
	}
	if (x == n) return;
	dfs(x + 1, y, res, bit);//不选
	dfs(x + 1, y + 1, res + a[x], bit | (1 << x));//选，或上第x个人
}
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6248.in", "rb");
	fout = fopen("P6248.out", "wb");
	#endif
	read(n, m);
	for (int i = 0; i < n; ++i) read(name, a[i]), ma[name] = i;//用map存下名字
	for (int i = 0; i < m; ++i) read(u, v, k[i]), gay[i] = (1 << ma[u]) | (1 << ma[v]);//将两个人绑在一起
	dfs(0, 0, 0, 0);
	write(ans);
	return 0;
}
```

---


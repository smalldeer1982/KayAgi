# [COCI 2014/2015 #3] SILUETA

## 题目背景

画家文森特有一次发现自己身处一个摩天大楼林立的大都市，于是他立刻下来画画，陶醉于这一美妙的景象。由于一些普通程序员无法理解的原因，文森特决定只画眼前摩天大楼的轮廓。不幸的是，在他完成这幅杰作一周后，这幅画被烧了。

为了重建这幅画，文森特向各个方向寻求帮助，现在轮到你了！

## 题目描述

从你的角度来看，文森特的摩天大楼是长方形的，它的边平行于坐标轴，一边位于横坐标上。图片的横坐标应该用字符 `*` 表示，摩天大楼的轮廓用 `#` 表示，其余部分用 `.` 表示。图像的左边缘必须以摩天大楼开始，而图像的右边缘必须以摩天大楼结束。此外，为了验证数学家得到的结果，输出给定轮廓的周长，而不是计算横坐标上的边。

## 说明/提示

#### 样例输入输出 1 解释 

如下图，蓝色表示摩天大楼的轮廓（字符 `#`），而黄色是文森特绘画中横坐标的一部分（字符 `*`）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ynl2n5os.png)

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $1\le n\le 100$，$1\le l_i,r_i,h_i\le 100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^4$，$1\le l_i,r_i,h_i\le 10^3$，$3 \leq r_i - l_i \leq 10^3$。

## 样例 #1

### 输入

```
3
1 5 4
7 11 3
9 13 5
```

### 输出

```
28
........####
####....#..#
#..#..###..#
#..#..#....#
#..#..#....#
************
```

## 样例 #2

### 输入

```
6
2 8 7
5 13 5
2 18 3
23 26 5
20 31 7
21 30 10```

### 输出

```
61
...................#########.
...................#.......#.
...................#.......#.
######............##.......##
#....#............#.........#
#....######.......#.........#
#.........#.......#.........#
#.........######..#.........#
#..............#..#.........#
#..............#..#.........#
*****************************
```

# 题解

## 作者：wuyonghuming (赞：10)

## 思路：
**这道题只要处理好几个重点就可以 $AC$ 了**

$1.$我们刚开始的时候要先记好最大高度，最左边，最右边，以便最后画图，**注意最右边须要减一**

$2.$最下面的那一行应该全部输出"*"

$3.$在统计答案的时候，在地里面的也要加上去
## 代码：
```c
#include <stdio.h>//这道题我用的是C语言
int read()//快速读入，顺便说一下
{
    int a=0;//一开始这个要返回的数是零
    char b=getchar();//先取一个字符
    while(b<'0'||b>'9')//如果还没到数字就是没用的
		b=getchar();//一直取字符
    while(b>=48&&b<=57)//当出现数字就代表是一个数
    {
        a=a*10+b-'0';//这个数乘上十再加上这个数字
        b=getchar();//再取下一个字符
    }
    return a;//返回
}
int max(int a,int b)//手写最大值
{
	if(a>b)//如果第一个数比第二个大
	{
		return a;//返回第一个
	}
	return b;//返回第二个
}
int min(int a,int b)//手写最小值
{
	if(a<b)//如果第一个比第二个小
	{
		return a;//返回第一个
	}
	return b;//返回第二个
}
int s[1001];//这个数组记录每一列高楼的高度
int main()//主函数
{
	int n=read(),ll=0x3f,rr=-0x3f,hh=-0x3f,ans=0;//把应该赋值的都赋一个初始值,0x3f是个常数
	char m[1001][1001];//这个是将来的答案
	for(int i=1;i<=n;i++)//循环输入每一幢大楼的样子
	{
		int l=read(),r=read(),h=read();//输入左边右边和高度
		for(int j=l;j<=r-1;j++)//从左到右，这一列的最高高度要更新
		{
			s[j]=max(s[j],h);//更新最高高度
		}
		ll=min(l,ll);//更新最左边
		rr=max(r-1,rr);//更新最右边
		hh=max(h,hh);//更新最高高度
	}
	for(int i=ll;i<=rr;i++)//从左到右
	{
		for(int j=1;j<=hh;j++)//从地面到最高高度
		{
			m[i][j]='.';//在没建筑的情况下是空的
		}
	}
	for(int i=ll;i<=rr;i++)//从左到右
	{
		for(int j=0;j<=hh;j++)//从下到上
		{
			if(((s[i+1]<=j||s[i-1]<=j)&&j<=s[i])||s[i]==j)//如果左边的高度小于现在高度或者右边高度小于现在高度或者到了最上面
			{
				ans++;//轮廓长度加一
				m[i][j]='#';//这个点变成建筑覆盖
			}
		}
		if(s[i]==0)//如果在地里而且这个点为空，上面的循环也会把答案加上去
		{
			ans--;//轮廓长度减一
		}
	}
	printf("%d\n",ans);//输出轮廓长度
	for(int i=hh;i>=1;i--)//因为高度才是行数，而且要倒过来
	{
		for(int j=ll;j<=rr;j++)//从左到右
		{
			putchar(m[j][i]);//输出答案
		}
		puts("");//下一行
	}
	for(int i=ll;i<=rr;i++)//从左到右
	{
		printf("*");//最下面应该是*
	}
	return 0;//别忘了
}
```
**谢谢管理审核和大家观赏，希望能看懂**

---

## 作者：dyxcj (赞：5)

# [P6265](https://www.luogu.com.cn/problem/P6265)

# 题目大意

将 $n$ 个矩形叠放，求它们的周长，并输出它们的轮廓。\
**注意**：左右两边必须以轮廓开始且输出的是轮廓的周长（并不是 # 的总和）。

# 思路

直接的修改是最简单的，如果你每一次都算出当次的现状，是很复杂的，我们考虑先修改，后面再决定哪些是有用的。\
设 $b_{i,j}$ 为第 $i$ 行第 $j$ 列的元素，且 $0$ 为空，$1$ 为轮廓。\
所以写出如下代码：

```cpp
    for(int i=1;i<=n;i++){
        cin>>l>>r>>h;
        r--;
        H=max(H,h);
        L=min(L,l);
        R=max(R,r);
        for(int i=1;i<=h;i++)b[i][l]=b[i][r]=1;
        for(int j=l;j<=r;j++)b[h][j]=1;
    }
```

注意，此时维护 $H$ 与 $L$ 与 $R$ 的值，是为了方便后面的修改与输出，至于为什么 $r$ 要减少可以看样例（数一下修改的范围可知，每次只修改 $[l,r-1]$ 区间内的）。\
接下来到了最难的地方，我们如何知道那些轮廓是无用的呢？\
发现个必然的事情：对于所有不需要的轮廓，一定在一些需要的轮廓的包围中。\
所以有以下方法：对于每一列，从高到低依次扫描，扫到 # 退出把以自己为中心的八个方向一共九个打上标记，用 $x$ 数组维护。因为这种方法就像雨落下来一样，且我也没听说过这种方法，所以我叫它暴雨法（若重复发明轮子致歉）。此时，就有所有不需要的轮廓，设它在的位置为 $i,j$ 则 $x_{i,j}\ne 1$ 很好理解，你都在其他轮廓的包含里，自然不可能会被赋值。\
接下来我们思考另一个问题：如何统计周长？\
还是采用暴雨法，对于 $i,j$ 统计 $b_{i-1,j}+b_{i+1,j}+b_{i,j-1}+b_{i,j+1}$ 的值，退出方法与上述无异，所以可以合一起写。\
代码（压行致歉）：

```cpp
    for(int i=L-1;i<=R+1;i++)for(int j=H+1;j>=1;j--){
        if(b[j][i])break;
        x[j-1][i-1]=x[j-1][i]=x[j-1][i+1]=x[j][i-1]=x[j][i]=x[j][i+1]=x[j+1][i-1]=x[j+1][i]=x[j+1][i+1]=1;
        sum+=b[j-1][i]+b[j+1][i]+b[j][i-1]+b[j][i+1];
    }
```

接下来就是输出，只有满足本身为 # 且被复制的才会输出 # 否则不会。\
代码（压行致歉）：

```cpp
    cout<<sum<<"\n";
    for(int i=H;i>=1;i--){
        for(int j=L;j<=R;j++)cout<<(b[i][j]&&x[i][j]?'#':'.');
        cout<<"\n";
    }
    for(int i=L;i<=R;i++)cout<<'*';
```

# 注意事项

- 注意雨流的方向（不能从左向右流，只能从上到下）。
- 注意起始位置（不能让边界没扫出来）。
- 注意雨流的顺序，是从上往下的（~~你回到过去不就从下往上了吗~~）。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,L=1005,R,l,r,h,H,z[1005],sum;
bool b[1005][1005],x[1005][1005];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>l>>r>>h;
        r--;
        H=max(H,h);
        L=min(L,l);
        R=max(R,r);
        for(int i=1;i<=h;i++)b[i][l]=b[i][r]=1;
        for(int j=l;j<=r;j++)b[h][j]=1;
    }
    for(int i=L-1;i<=R+1;i++)for(int j=H+1;j>=1;j--){
        if(b[j][i])break;
        x[j-1][i-1]=x[j-1][i]=x[j-1][i+1]=x[j][i-1]=x[j][i]=x[j][i+1]=x[j+1][i-1]=x[j+1][i]=x[j+1][i+1]=1;
        sum+=b[j-1][i]+b[j+1][i]+b[j][i-1]+b[j][i+1];
    }
    cout<<sum<<"\n";
    for(int i=H;i>=1;i--){
        for(int j=L;j<=R;j++)cout<<(b[i][j]&&x[i][j]?'#':'.');
        cout<<"\n";
    }
    for(int i=L;i<=R;i++)cout<<'*';
    return 0;
}
//BluePoch-1999
```

---

## 作者：yx666 (赞：2)

# P6265 SILUETA 题解

[题目传送门](https://www.luogu.com.cn/problem/P6265)

## Part 1 审题

### Part 1.1 题意

1. 给出 $n$ 个在笛卡尔坐标系上的矩形，第 $i$ 个矩形左下角 $(l_i,0)$，右上角 $(r_i,h_i)$。

2. 要求将这 $n$ 个矩形的图形边缘标成 `#`，其余位置标成 `.`。特别的，横坐标轴标成 `*`（参照样例理解）。

3. 输出外轮廓的周长。

	- 周长：横着的 `#` 的个数加上竖着的 `#` 的个数（不去重）。

4. 输出步骤 2 的结果：第一列以矩形轮廓开始，最后列以矩形轮廓结束，第一行至少出现一个 `#`，最后行为连续的 `*` 组成。不少点，不漏点。

### Part 1.2 限制

- 对于 $100\%$ 的数据，保证 $1\le n\le 10^4$，$1\le l_i,r_i,h_i\le 10^3$，$3 \leq r_i - l_i \leq 10^3$。

- 时限 $500$ ms，内存大小 $32$ MB。

## Part 2 分析

### Part 2.1 读入与定义

- 直接上色，时间复杂度太大，故定义 $ht_i$ 表示 $(i,1)$ 到 $(i,ht_i)$ 被矩形覆盖。

- 所以，对于矩形 $i$，更新 $ht_j=\max(ht_j,h_i),\footnotesize j\in[l_i,r_i)$  即可。

- 与此同时，记录每次矩形 $l_i$ 的最小值 $mnl$，$r_i,h_i$ 的最大值 $mxr,mxh$，以便于下一步操作。

### Part 2.2 处理

#### Part 2.2.1 上色

定义 $mp_{i,j}$ 表示输出的第 $i$ 行，第 $j$ 列的图形（初始化为 `.`）。第 $0$ 列对应上文第 $mnl$ 列。

定义 $i\in [mnl,mxr]$，会出现三种情况：

1. $ht_{i-1}<ht_i$：上升，$mp_{j,i-mnl}\footnotesize(j\in[ht_{i-1},ht_i])$ 涂成 `#`。

2. $ht_{i-1}=ht_i$：平直，$mp_{ht_i,i-mnl}$ 涂成 `#`。

3. $ht_{i-1}>ht_i$：下降，$mp_{j,i-mnl-1}\footnotesize(j\in[ht_i,ht_{i-1}])$ 与 $mp_{ht_i,i-mnl}$ 涂成 `#`。

#### Part 2.2.2 周长

将周长分解为两种：横着的和竖着的。举个例子：如样例 $1$ 所示，横着的周长长 $4+2+4=10$，竖着的周长长 $4+4+3+2+5=18$，总周长 $10+18=28$。

因此，遍历时，会出现以下情况：

1. $ht_{i-1}\neq ht_i$，增加周长为 $\mathop{abs}(ht_{i-1}-ht_i)+1$。

2. $ht_{i-1}=ht_i\neq 0$，增加周长为 $1$。

3. $ht_{i-1}=ht_i=0$，增加周长为 $\mathop{abs}(ht_{i-1}-ht_i)$。

即：
$$\text{增加周长}=\begin{cases}
\mathop{abs}(ht_{i-1}-ht_i) &ht_i=0\\
\mathop{abs}(ht_{i-1}-ht_i)+1&ht_i\neq0
\end{cases}$$

### Part 2.3 输出

1. 输出周长。

2. 再输出图形：$mp_{i,j}$，其中 $i$ 从 $mxh$ 到 $0$，改变时换行；$j$ 从 $0$ 到 $mxr-mnl$。特别的，$mp_{0,j}\footnotesize(j\in[0,mxr-mnl])$ 为 `*`。 

## Part 3 代码实现

[96ms](https://www.luogu.com.cn/record/153127628)

``` cpp
#include<bits/stdc++.h>
using namespace std;

#define N 10005

// 定义、初始化与主要变量
int n;
int mn_l=1e9,mx_r,mx_h;
int ht[N];
vector<string>mp;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	/* 读入 （Part 2.1） */
	cin>>n;
	
	int l,r,h;
	for(int i=1;i<=n;++i){
		cin>>l>>r>>h;
		for(int j=l;j<r;++j){
			ht[j]=max(ht[j],h);
		}
		mn_l=min(mn_l,l);
		mx_h=max(mx_h,h);
		mx_r=max(mx_r,r);
	}
	
	/* 处理 （Part 2.2） */
	mp.resize(mx_h+1);
	for(string &it:mp){
		it.resize(mx_r-mn_l,'.');
	}
	
	int cnt=0;
	for(int i=mn_l;i<=mx_r;++i){
		// 上色
		if(ht[i-1]<ht[i])
			for(int j=ht[i-1];j<=ht[i];++j)
				mp[j][i-mn_l]='#';
		
		else if (ht[i-1]==ht[i])
			mp[ht[i]][i-mn_l]='#';
		
		else if(ht[i-1]>ht[i]){
			for(int j=ht[i];j<=ht[i-1];++j)
				mp[j][i-mn_l-1]='#';
			mp[ht[i]][i-mn_l]='#';
		}
		
		// 周长
		if(ht[i])
			cnt+=abs(ht[i-1]-ht[i])+1;
		else
			cnt+=abs(ht[i-1]-ht[i]);
	}
	
	/* 输出 （Part 2.3） */
	cout<<cnt<<endl;
	for(int i=mx_h;i;--i)
		cout<<mp[i]<<'\n';
	for(int i=mn_l;i<mx_r;++i) cout<<'*';
	
	return 0;
}
```

---

## 作者：zct_sky (赞：1)

### Solution
-----
先考虑如果建筑内部均为 $\texttt{\#}$ 时的结果。

由于数据范围很小，我们可以暴力把每个横坐标上建筑高度进行更新，然后将整个矩阵涂成 $\texttt{\#}$ 或 $\texttt{.}$，我们将其称为原矩阵。

显然，建筑的周长即为每个 $\texttt{\#}$ 在原矩阵中的**四个**方向的“空气”（即 $\texttt{.}$）的数量。

然后考虑如何将建筑内部的 $\texttt{\#}$ 转换为 $\texttt{.}$。

通过观察不难发现，每个 $\texttt{\#}$ 被认为是在建筑内部时，当且仅当其在原矩阵中的**八个**方向均为 $\texttt{\#}$。

因此，我们可以根据原矩阵重新求出现矩阵（即答案矩阵）。

- 若一个格子在原矩阵中处于第 $0$ 行，它在现矩阵中是 $\texttt{*}$。
- 若一个格子在原矩阵中是 $\texttt{.}$，它在现矩阵中仍是 $\texttt{.}$。
- 若一个格子在原矩阵中是 $\texttt{\#}$，且其在建筑内部，它在现矩阵中则是 $\texttt{.}$。
- 若一个格子在原矩阵中是 $\texttt{\#}$，且其不在建筑内部，它在现矩阵中仍是 $\texttt{\#}$。

由于原矩阵只有 $\texttt{\#}$ 和 $\texttt{.}$，C++ 程序中可用 `bool` 型的数组代替（详见代码）。

还有几个注意点：

1. 右边界 $r_i$ 存入原矩阵时需要 $-1$。
2. 由于第 $0$ 行会被覆盖为 $\texttt{*}$，需要将 高度 $h_i$ 手动 $+1$。

最后输出长度及现矩阵即可。

### Code
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')y=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*y;
}
const int N=1e3+7;
int n,l,r,h,minl=INT_MAX,maxr,maxh,hi[N],len;
char c[N][N];
bool f[N][N];
const int d8[][2]={{1,0},{1,1},{1,-1},{0,1},{0,-1},{-1,0},{-1,-1},{-1,1}};
const int d4[][2]={{1,0},{0,1},{-1,0},{0,-1}};
int main(){
	n=read();
	while(n--){
		l=read();r=read();h=read();
		minl=min(minl,l);
		maxr=max(maxr,r-1);
		maxh=max(maxh,h);
		for(int i=l;i<r;i++){
			hi[i]=max(hi[i],h+1);
		}
	}
	for(int i=minl;i<=maxr;i++){
		for(int j=0;j<hi[i];j++)
			f[j][i]=1;
	}
	for(int i=maxh;i>=0;i--){
		for(int j=minl;j<=maxr;j++){
			if(!f[i][j]||!i){
				c[i][j]=(!i)?'*':'.';
				continue;
			}
			bool flag=1;
			for(int k=0;k<8;k++){
				if(!f[i+d8[k][0]][j+d8[k][1]]){
					flag=0;
					break;
				}
			}
			c[i][j]=flag?'.':'#';
			for(int k=0;k<4;k++){
				len+=!f[i+d4[k][0]][j+d4[k][1]];
			}
		}
	}
	printf("%d\n",len);
	for(int i=maxh;i>=0;i--,puts("")){
		for(int j=minl;j<=maxr;j++)
			putchar(c[i][j]);
	}
	return 0;
}
```

---

## 作者：copper_ingot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6265)

题目大意：给定 $n$ 个建筑物，求他们组成的轮廓和其周长。

我们可以通过一个数组记录每一列最高的建筑的高度。

在得到最终答案时，先把每一列的所有格子填满，再把内部的格子挖掉。

细节有点多，具体看代码注释吧。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x7fffffff;
int n, l, r, h, minl = inf, maxr = -1, maxh = -1, hh[2001], ans, a[2001][2001];//hh记录本格高度
char mp[2001][2001];
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d%d%d", &l, &r, &h); r--, h++;//出于某种原因r要减1，h加1是为了后面统计方便
		minl = min(minl, l), maxr = max(maxr, r), maxh = max(maxh, h);
		for (int j = l; j <= r; j++) hh[j] = max(hh[j], h);//记录hh
	}
	l = minl, r = maxr, h = maxh;
	for (int i = l; i <= r; i++) for (int j = 2; j <= h; j++) mp[i][j] = '.';//把行列调换了，方便一点
	for (int i = l; i <= r; i++) a[i][0] = 1;//把地面全部设成有
	for (int i = l; i <= r; i++) for (int j = 1; j <= hh[i]; j++) mp[i][j] = '#', a[i][j] = 1, ans++;
	for (int i = l; i <= r; i++) for (int j = 1; j <= hh[i]; j++)
		if (a[i + 1][j] == 1 && a[i - 1][j] == 1 && a[i][j + 1] == 1 && a[i][j - 1] == 1 
		&& a[i + 1][j + 1] == 1 && a[i - 1][j + 1] == 1 && a[i - 1][j - 1] == 1 && a[i + 1][j - 1] == 1) mp[i][j] = '.', ans--;//删掉内部
	printf("%d\n", ans);
	for (int i = h; i >= 2; i--){for (int j = l; j <= r; j++) putchar(mp[j][i]); puts("");}//i=1是地面所以不要输出
	for (int i = l; i <= r; i++) putchar('*');//打印
	return 0;
//注：统计周长时要加上地里面的，但因为h加了1所以不需要了
}
```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

给定多个在 $x$ 轴上的矩形，矩形可以相互连接和重叠，所形成的图形边缘为 ```#```，内部为 ```.```。$x$ 轴在途中用 ```*``` 表示。需要求最后形成的各个图形的周长和，并输出图像。

## Part 2 思路 - 图像

由于矩形之间可能会相互连接和重叠，所以我们就考虑用 $f_i$ 记录坐标为 $i$ 处的建筑的高度。特别的，由于比较矮的矩形都被比较高的矩形覆盖住了，所以我们对 $f_i$ 的更新要取最大值。

在知道每个坐标的前提下，由于我们所输出的图像必须以矩形开始并以矩形结束，所以定义 $left$ 和 $right$ 分别表示整个图像中矩形出现的最早和最晚位置。

当我们更新完了所有 $f$ 的值之后，整个图像的高度 $high$ 便是 $f_{left \dots right}$ 的最大值。

在我们知道 $f_{left \dots right}$ 的前提下如何绘制图像呢？首先，将最后绘制出来的图像抽象成笛卡尔坐标系的第一象限后，经过观察发现，如果 $ch_{i,j}$ 要绘制的是 ```#```，那必然满足一下其中一项：

1. 该点在矩形的顶部：$j=f_i$。

2. 该点在图像的最左侧或最右侧：$j \leq f_i,j=left$ 或 $j \leq f_i,j=right$。

3. 该点在某一矩形的左侧：$j \leq f_i,f_{i-1} \neq f_i,j \geq f_{i-1}$。

4. 该点在某一矩形的右侧：$j \leq f_i,f_{i+1} \neq f_i,j \geq f_{i+1}$。

否则，$ch_{i,j}$ 便是 ```.```。

对于 $x$ 轴，我们只要令 $ch_{left \dots right,0}$ 为 ```*``` 即可。

## Part 3 思路 - 周长

关键点：一个点影响周长的前提是什么？

首先，这个点必须是 ```#```，在该点是在矩形边缘的情况下才有可能影响周长。

进一步的，我们观察题目可以发现一个 ```#``` 可以影响周长的大小不仅仅可能是 $1$，也可能是 $2,0$。

将我们所绘制出来的图形进一步抽象成多条线段所交集而成的，包括 $x$ 轴。很容易发现：

1. 如果 ```#``` 出现且仅出现在一条线段上，那对周长的影响是 $1$。

2. 如果 ```#``` 出现在两条线段的交点上，两条线段所形成的直角在 ```#``` 的左下方或右下方，则对周长的影响是 $2$。

3. 否则对周长的影响是 $0$。

我们可以在绘制完图像之后再枚举图像上的每一个点，通过上文三条判断之后计算周长。最后先输出周长在输出图像即可。

## Part 4 代码

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e4+5;
int n,l[maxn],r[maxn],h[maxn],f[maxn];
char ch[1005][1005];
int main()
{
	int left=1e9,right=-1e9,high=-1e9;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>l[i]>>r[i]>>h[i];
		for (int j=l[i]+1;j<=r[i];j++)
		{
			f[j]=max(f[j],h[i]);
		}
		right=max(right,r[i]);
		left=min(left,l[i]+1);
		high=max(high,h[i]);
	}
	for (int i=high;i>=1;i--)
	{
		for (int j=left;j<=right;j++)
		{
			if (i==f[j]) ch[i][j]='#';
			else if (i<=f[j] && ((f[j-1]!=f[j] && i>=f[j-1]) || (f[j+1]!=f[j] && i>=f[j+1]) || j==left || j==right)) ch[i][j]='#';
			else ch[i][j]='.';
		}
	}
	for (int i=left;i<=right;i++) ch[0][i]='*';
	int result=0;
	for (int i=high;i>=0;i--)
	{
		for (int j=left;j<=right;j++)
		{
			if (ch[i][j]!='#') continue;
			if (ch[i+1][j]=='#' && (ch[i-1][j]=='#' || ch[i-1][j]=='*')) result++;
			if (ch[i][j+1]=='#' && ch[i][j-1]=='#') result++;
			if ((ch[i-1][j]=='#' || ch[i-1][j]=='*') && ((ch[i][j+1]=='#' && ch[i][j-1]!='#') || (ch[i][j-1]=='#' && ch[i][j+1]!='#'))) result+=2;
		}
	}
	cout<<result<<endl;
	for (int i=high;i>=0;i--)
	{
		for (int j=left;j<=right;j++) cout<<ch[i][j];
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：LHW_Cosset_Idiot (赞：0)

题目很简单，很容易读懂，这里不做复述，直接开始分析。

### 分析题意：
- 根据给出的 $n$ 个长方形摩天大楼，画出图中边框，左右需要摩天大楼的边缘来收尾。
- 还要求出图中所有摩天大楼的实际周长，不包括地面，大部分会在图中体现，小部分可能会被遮挡，但是需要求出。
- 题目数据范围小，无需优化，可以直接暴力处理数据。

### 具体做法：
- 首先将所有摩天大楼的占用面先用二维数组存起来，可以用 $1$ 来表示这块区域有大楼。注意：这里可以只遍历长方形边框，会节省很多时间。（地面那一边省略别求）
- 通过遍历边框的过程就已经可以求出周长了，直接输出，不用重复算。
- 存完后遍历全图，可以将所有没有被其他大楼遮挡的大楼边框在二维数组中设为 $2$。
- 最后，输出将二维数组转换为字符输出，$2$ 输出 `#`，否则输出 `.`。当然，最底下那一列都是 `*`。

具体做法讲的很清晰，可以直接跟着思路做，这里不给出标准程序。

---


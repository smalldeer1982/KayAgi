# [COCI 2016/2017 #1] Jetpack

## 题目描述

Mirko 正在玩一款小游戏。在一个 $10$ 行 $n$ 列的矩阵中，他需要从左下角出发，避免在障碍物处停留，最终到达第 $n$ 列的任意位置。每秒，他都会向右移动一个单位。

在游戏中，Mirko 拥有一个喷气背包（游戏开始时关闭）：

- 打开喷气背包时，每秒他将额外向上移动一个单位（即向右上方移动），直到他处于矩阵顶端的一行。
- 关闭喷气背包时，每秒他将额外向下移动一个单位（即向右下方移动），直到他处于矩阵底端的一行。

他可以在任意一秒打开喷气背包，并在任意秒后关闭。将此记为一次操作。

现在，Mirko 想让你设计一系列操作，使他能够顺利结束游戏。

## 说明/提示

#### 样例 1 解释

下图为样例输出一所表示的路径。

```
.....XX...X
....XX...XX
...XX...XX.
...........
....XXX....
.....*...*.
....*X*.*.*
...*XX.*.X.
..*XX...XX.
**.X...XX.. 
```

---

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 10^5$。

数据保证至少存在一种方案，能使得 Mirko 能够顺利结束游戏。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #1](https://hsin.hr/coci/archive/2016_2017/contest1_tasks.pdf) _T2 Jetpack_**。

## 样例 #1

### 输入

```
11
.....XX...X
....XX...XX
...XX...XX.
...........
....XXX....
...........
.....X.....
....XX...X.
...XX...XX.
...X...XX.. ```

### 输出

```
2
1 4
7 2 ```

## 样例 #2

### 输入

```
20
X..................X
.X................X.
..X..............X..
...X............X...
....X..........X....
.....X........X.....
......X......X......
.......X....X.......
........X..X........
.........XX......... ```

### 输出

```
1
8 10 ```

# 题解

## 作者：CoronaQL (赞：2)

# 思路
无聊的模拟题（COCI的原题），打起来有点烦。

在这里使用dp的方法实现比较方便。

设dpi,jdp_{i,j}dpi,j​为Mirko当前是否可以到达所定义位置(i,j)(i,j)(i,j)。
转移方程如下（伪代码）
```cpp
dpi,j=dpi,j−1∣dpi+1,j−1(i=1)dp_{i,j}=dp_{i,j-1}|dp_{i+1,j-1}(i=1)dpi,j​=dpi,j−1​∣dpi+1,j−1​(i=1)
dpi,j=dpi+1,j−1∣dpi−1,j−1(2≤i≤9)dp_{i,j}=dp_{i+1,j-1}|dp_{i-1,j-1}(2≤i≤9)dpi,j​=dpi+1,j−1​∣dpi−1,j−1​(2≤i≤9)
dpi,j=dpi,j−1∣dpi−1,j−1(i=10)dp_{i,j}=dp_{i,j-1}|dp_{i-1,j-1}(i=10)dpi,j​=dpi,j−1​∣dpi−1,j−1​(i=10)
```
输出方案按照题意模拟即可，这里不细聊。

复杂度:O(n2)O(n^2)O(n2)
# 上AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define MAXN 100000//宏定义
int n,cnt;
char mp[11][MAXN+5];
int dp[11][MAXN+5];
int vis[MAXN+5];
void print(int x,int y)
{
	if(x==10&&dp[x][y-1])print(x,y-1);
	else if(x==10&&dp[x-1][y-1])print(x-1,y-1);
	else if(x==1&&dp[x][y-1]){vis[y-1]=1;print(x,y-1);}
	else if(x==1&&dp[x+1][y-1]){vis[y-1]=1;print(x+1,y-1);}
	else if(dp[x-1][y-1])print(x-1,y-1);
	else if(dp[x+1][y-1]){vis[y-1]=1;print(x+1,y-1);}
	else return ;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=10;i++)
		scanf("%s",mp[i]+1);
	for(int i=1;i<=10;i++)
		for(int j=1;j<=n;j++)
		dp[i][j]=0;
	if(mp[10][1]!='X')dp[10][1]=1;
	for(int j=2;j<=n;j++)
		for(int i=1;i<=10;i++)
		if(mp[i][j]!='X')
		{
			if(i==1)dp[i][j]|=dp[i][j-1],dp[i][j]|=dp[i+1][j-1];
			else if(i==10)
			dp[i][j]|=dp[i][j-1],dp[i][j]|=dp[i-1][j-1];
			else dp[i][j]|=dp[i-1][j-1],dp[i][j]|=dp[i+1][j-1];
		}
	for(int i=1;i<=10;i++)
	if(dp[i][n]){print(i,n);break;}
	for(int i=1;i<=n;i++)
	{
		int p=i;
		while(vis[p])p++;if(vis[i])cnt++;i=p;}
	printf("%d\n",cnt);
	for(int i=1;i<=n;i++)
	{
		int p=i;
		while(vis[p])p++;
		if(vis[i])printf("%d %d\n",i-1,p-i);
		i=p;
	}
}
```
# 注意点
在这里我没有打注释，是希望大家能够通过我的思路来自己理解，而不是对着注释傻傻的看一遍，或者是直接复制粘贴，为了维护洛谷社区秩序，勿抄题解！

---

## 作者：small_john (赞：0)

## 分析

其实很简单。

直接记忆化搜索即可，建议评黄。

## 做法

先输入。

```cpp
void init()//输入函数
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i = 1;i<=10;i++)
		for(int j = 1;j<=n;j++)
			cin>>a[i][j];
}
```

再进行搜索，参数 $x$ 表示行，参数 $y$ 表示列。用 $vis$ 记录当前是否有可行方案，$v$ 数组记录当前是否按了。如果当前点是障碍，那就退出。否则就把这个点标记为障碍，防止此点再次被搜索。分开看之一秒按和不按的情况。

```cpp
bool dfs(int x,int y)//dfs函数
{
	if(vis) return 1;//有可行方案，退出
	if(y==n)//到达最右边，可行
		return vis = 1;
	if(a[x][y]=='X') return 0;//是障碍，退出
	a[x][y] = 'X';//记忆化，保证不会再扫一遍
	if(dfs(max(1,x-1),y+1))//这一秒要按
		return v[y] = 1;
	if(vis) return 1;//可行，退出
	if(dfs(min(x+1,10),y+1))//不按
		return 1;
	return vis;
}
```

最后输出，把 $v$ 中连续一段 $1$ 标记成答案的一段。

```cpp
void print()//输出函数
{
	for(int i = 1;i<=n;i++)
		if(v[i-1]==0&&v[i])//前一秒没打卡，这一秒打开
        out[++cnt][0] = i-1,out[cnt][1] = 1;//开新的一段
		else if(v[i]) out[cnt][1]++;//否则还是当前的一段
	cout<<cnt<<'\n';
	for(int i = 1;i<=cnt;i++)
		cout<<out[i][0]<<' '<<out[i][1]<<'\n';
}
```

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
int n,out[N][2],cnt;
//out[i][0]表示第 i 段的开始时间，out[i][1]表示第 i 段持续时间
char a[11][N];
bool v[N],vis;
void init()//输入函数
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i = 1;i<=10;i++)
		for(int j = 1;j<=n;j++)
			cin>>a[i][j];
}
void print()//输出函数
{
	for(int i = 1;i<=n;i++)
		if(v[i-1]==0&&v[i])//前一秒没打卡，这一秒打开
        out[++cnt][0] = i-1,out[cnt][1] = 1;//开新的一段
		else if(v[i]) out[cnt][1]++;//否则还是当前的一段
	cout<<cnt<<'\n';
	for(int i = 1;i<=cnt;i++)
		cout<<out[i][0]<<' '<<out[i][1]<<'\n';
}
bool dfs(int x,int y)//dfs函数
{
	if(vis) return 1;//有可行方案，退出
	if(y==n)//到达最右边，可行
		return vis = 1;
	if(a[x][y]=='X') return 0;//是障碍，退出
	a[x][y] = 'X';//记忆化，保证不会再扫一遍
	if(dfs(max(1,x-1),y+1))//这一秒要按
		return v[y] = 1;
	if(vis) return 1;//可行，退出
	if(dfs(min(x+1,10),y+1))//不按
		return 1;
	return vis;
}
int main()
{
	init();
	dfs(10,1);//起点是第十行第一列
	print();
	return 0;
}
```

---


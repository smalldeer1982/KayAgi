# [COCI 2006/2007 #4] ZBRKA

## 题目描述

在一个长度为 $n$ 的排列中找出逆序对数量恰好为 $c$ 的排列总数。（$\bmod \ 10^9+7$）

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 10^3$，$1\le c\le 10^4$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #4](https://hsin.hr/coci/archive/2006_2007/contest4_tasks.pdf) *T4 ZBRKA***

## 样例 #1

### 输入

```
10 1```

### 输出

```
9```

## 样例 #2

### 输入

```
4 3```

### 输出

```
6```

## 样例 #3

### 输入

```
9 13```

### 输出

```
17957```

# 题解

## 作者：ღꦿ࿐ (赞：12)

本题存在低于 $O(nc)$ 的做法。

逆序对是大小关系，我们在小的那个数处统计每对逆序对，考虑从大到小插入每一个数，这样所有数都比他大，这样它插入在第 $i$ 个就会产生 $i$ 个逆序对，假设现在有 $x$ 个数则它可以产生 $[0,x]$ 中个逆序对，且每种都恰好有一种插法。


那么我们现在可以进行一个 $O(nc^2)$ 的 dp 了，$f_{i,j}$ 表示前 $i$ 个数有 $j$ 个逆序对的方案数，使用前缀和优化可以做到 $O(nc)$。

---

重新回顾我们现在的问题：第 $i$ 个数在 $[0,i)$ 中任选，求所有数和为 $c$ 的方案数，

考虑没有 $[0,i)$ 这个限制的方案数，$n$ 个任意正整数和为 $c$，这是经典的插板法，答案即 $\dbinom {c+n-1}{n-1}$。

我们考虑容斥去掉限制，$[0,i)$ 是困难的，而将其容斥为 $[i,+\infty)$ 后是简单的，我们直接从 $c$ 中扣掉 $i$ 即可。

钦定一些 $i$ 超限了，我们只关心我们钦定的 $i$ 的和为 $s$ 的容斥系数之和。

---

问题变为对所有 $s$ 求出 $1\dots n$ 中选一些数 $s$ 和为 $s$ 的容斥系数之和，每选一个数带来 $-1$ 的容斥系数。

这个问题直接做似乎还是只能 $O(nc)$。

考虑经典的性质：最多选择了 $O(\sqrt c)$ 个数，否则和一定 $>c$。

证明：选择前 $t$ 小的数的和是 $\frac {t(t+1)}{2}=O(t^2)$ 的，所以无论如何选的个数都是 $O(\sqrt c)$ 级别的。

---

于是我们考虑从竖着一个数一个数 dp，换成横着一层一层 dp，从大到小加入每个数 $a_1\dots a_n$，则 $a_{i}-a_{i+1}$ 会在 $i$ 个数中产生贡献，即 $\sum a_i=\sum i\times (a_i-a_{i-1})$。（相当于给所有已经加入的数”垫高“若干并加入新的数）

让 $f_{i,j}$ 表示目前有 $i$ 个数，$\sum_{x=1}^{i} i\times (a_i-a_{i-1})$为 $j$ 的方案数，那么我们有

$$

f_{i,j}=f_{i-1,j-i}+f_{i,j-i} - f_{i-1,j-n-1}
$$

分别表示：新加入一个数并往上垫高一层，往上垫高一层。

然后因为要求了每个数都不超过 $n$，我们减去第一个数在垫高这一层后达到 $n+1$ 的情况，这是一个子问题，减去 $n+1$ 后变为一个 $i-1$ 个数和为 $j-n-1$ 的方案数。
 
 
于是我们在 $O(c\sqrt {c})$ 的时间复杂度内解决了本题。

---

代码：2024/6/20 提交时为最优解。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define all(x) x.begin(),x.end()
#define FIN(x) freopen(#x,"r",stdin)
#define FOUT(x) freopen(#x,"w",stdout)
#define cerr(x) cerr << #x"= " << x << "\n" 
#define rep(i,x,y) for(int i = (x) ; i <= (y) ; ++ i)
#define Rep(i,x,y) for(int i = (x) ; i >= (y) ; -- i)
#define SYNC(x) std :: ios :: sync_with_stdio (x); if (!x) {cin.tie(0);cout.tie(0);}
using std :: cin , std :: cout , std :: cerr ;
template<ll Mod> 
struct math {
    std :: vector <ll> fac , fiv , inv ;
    ll pow (ll x , ll y = Mod - 2) {
        ll res = 1 ; 
        for (x %= Mod ; y ; (x *= x) %= Mod , y >>= 1)
            if (y & 1)
                (res *= x) %= Mod ;
        return res; 
    }

    inline math () {}
    inline math (int n) : fac(n + 1) , fiv(n + 1) , inv(n + 1) {
        fac[0] = 1 ; 
        rep (i,1,n)
            fac[i] = fac[i - 1] * i % Mod ;
        fiv[n] = pow(fac[n]) ;
        Rep (i,n,1)
            fiv[i - 1] = fiv[i] * i % Mod ,
            inv[i] = fac[i - 1] * fiv[i] % Mod ;
    }
    inline void init (int n) {
        fac.resize(n + 1) , fiv.resize(n + 1) , inv.resize(n + 1) ;
        fac[0] = 1 ; 
        rep (i,1,n)
            fac[i] = fac[i - 1] * i % Mod ;
        fiv[n] = pow(fac[n]) ;
        Rep (i,n,1)
            fiv[i - 1] = fiv[i] * i % Mod ,
            inv[i] = fac[i - 1] * fiv[i] % Mod ;
    }

    inline ll binom (int n,int m) {
        if (n < m || m < 0)
            return 0;
        return fac[n] * fiv[m] % Mod * fiv[n - m] % Mod ;
    }
    inline ll perm (int n,int m) {
        if (n < m || m < 0)
            return 0;
        return fac[n] * fiv[n - m] % Mod ;
    }
    inline ll bracket (int x) {
        return fac[x * 2] * fiv[x] % Mod * fiv[x + 1] % Mod ;
    }
} ;


const int mod = 1e9 + 7 ;

inline void inc (int &tar,int ths) {
    if ((tar += ths) >= mod) 
        tar -= mod ;
}
inline void dec (int &tar,int ths) {
    if ((tar -= ths) < 0) 
        tar += mod ;
}

signed main( ) {  SYNC (false); 
    int n , c ;
    cin >> n >> c ;
    math<mod> M (n + c) ;
    std :: vector <int> f (c + 1) ;
    f[0] = 1 ; 
    ll res = M.binom (c + n - 1 , n - 1) ;
    for (int i = 1 ; i * (i + 1) / 2 <= c && i <= n ; ++ i) {                
        std :: vector <int> g(c+1) ;
        rep (j,i,c) {   
            g[j] = f[j - i] ;
            inc (g[j] , g[j - i]) ;
            if (j >= n + 1)
                dec (g[j] , f[j - n - 1]) ;
        }

        f.swap(g) ;
        rep (j,0,c) {
            (res += (i&1?mod-f[j]:f[j]) * M.binom (c - j + n - 1 , n - 1)) %= mod ;   
        }   
    }
    cout << res << '\n' ;
}
```



---

更加本质的东西：

直接从生成函数和 Ferrers 图像的角度也可以得到相同复杂度的做法，上面那个容斥的本质是 $(1+x^1+x^2\dots x^p)=\frac {(1-x^{p+1})}{(1-x)}$，后面的部分我们是在快速求 $[x^c]\prod_{i=1}^{n}(1-x^i)$，从分拆数等角度有很多 $O(c\sqrt c)$ 的做法。

---

## 作者：一扶苏一 (赞：8)

## 【DP】【P6323】 [COCI2006-2007#4] ZBRKA

### Description

求长度为 $n$，逆序对数为 $c$ 的排列数，答案对大质数取模。

$1 \leq n \leq 10^3$，$1 \leq c \leq 10^4$。

### Analysis

这种排列计数的一个套路是设 $f_{i}$ 是将前 $i$ 个数字填入排列的方案数，后面的维度可以按照所求补充，然后考虑新加入一个数对答案产生的贡献。

这里设 $f_{i, j}$ 是将前 $i$ 个数字填入排列，形成了 $j$ 个逆序对的方案数。

考虑填第 $i$ 个数，已经有了一个 $i - 1$ 的排列，现在有 $i$ 个位置可以填数字 $i$，注意到 $i$ 填到从后向前数第 $j$ 个空里会产生 $(j - 1)$ 个逆序对。因此转移为

$$f_{i, j} = \sum\limits_{k = 0}^{\min(i - 1, j)} f_{i - 1, j - k}$$

直接做复杂度是 $O(nc^2)$ 的，但是注意到转移时转移了 $f_{i - 1}$ 的一个区间和，因此用前缀和维护转移即可做到 $O(1)$ 转移：

$$f_{i, j} = g_{i - 1, j} - g_{i - 1, j - i}$$

其中 $g_{i, j} = \sum_{k = 0}^j f_{i, k}$。当然上述转移需要特殊处理一下 $j - i < 0$ 的情况。

时间复杂度 $O(nc)$。但是爆空间了，因此对 $f$ 和 $g$ 都滚动一下数组即可。空间复杂度 $O(c)$。

### Code

```cpp
const int maxn = 1003;
const int maxm = 10004;
const int p = 1000000007;

int n, m;
int f[2][maxm], sum[2][maxm];

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m);
  f[1][0] = sum[1][0] = 1;
  for (int i = 1; i <= m; ++i) sum[1][i] = 1;
  int x = 1, y = 0;
  for (int i = 2, di = i - 1; i <= n; ++i) {
    std::swap(x, y);
    f[x][0] = sum[x][0] = 1;
    for (int j = 1; j <= m; ++j) {
      int k = j - i;
      f[x][j] = sum[y][j];
      if (k > -1) (f[x][j] -= sum[y][k]) %= p;
      sum[x][j] = (sum[x][j - 1] + f[x][j]) % p;
    }
  }
  qw((f[x][m] + p) % p, '\n');
  return 0;
}
```



---

## 作者：Little09 (赞：7)

对于这类和全排列有关的 dp 题，我们第一时间应该想到的套路是用 $f[i][j]$ 表示从 $1$ 到 $i$ 的全排列，存在 $j$ 个逆序对的情况数。和这题类似的题是 [P2401 不等数列](https://www.luogu.com.cn/problem/P2401)。

然后这题的转移也比较容易，只要枚举一下第 $i$ 个数插入的位置是哪个，用 $i-1$ 的进行转移即可。这样可以得出一份 56 分的 TLE 代码。时间复杂度为 $O(n^2c)$。

这个代码可以进行滚动数组优化但是貌似没有必要。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c;
const int mod=1000000007;
int dp[1001][10004];
int main()
{
	cin >> n >> c;
	dp[1][0]=1;
	for (int i=2;i<=n;i++)
	{
		for (int j=0;j<=c;j++)
		{
			for (int k=1;k<=i;k++) if (j-i+k>=0) dp[i][j]=(dp[i][j]+dp[i-1][j-i+k])%mod;
		}
	}
	cout << dp[n][c];
	return 0;
}
```

发现一串连续的加和的形式，考虑前缀和优化。将 $dp$ 降成一维，可以用 $f$ 数组表示 $dp$ 的前缀和，那么转移很显然就是：

$$dp[j]=s[j]-s[j-i]$$

注意一下边界问题就可以轻松过掉了。时间复杂度是 $O(nc)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c;
const int mod=1000000007;
int dp[10004],s[10004];
int main()
{
	cin >> n >> c;
	dp[0]=1;
	for (int i=2;i<=n;i++)
	{
		s[0]=dp[0];
		for (int j=1;j<=c;j++) s[j]=(s[j-1]+dp[j])%mod;
		for (int j=0;j<=c;j++) 
		{
			if (j-i>=0) dp[j]=(s[j]-s[j-i]+mod)%mod;
			else dp[j]=s[j];
		}
	}
	cout << dp[c];
	return 0;
}
```

对于各种 dp 问题，还是建议大家先把暴力 dp 打出来再考虑优化。

---

## 作者：Super_Cube (赞：3)

# Solution

设 $dp_{i,j}$ 表示已经填了 $1\sim i$ 的数，产生了 $j$ 个逆序对的方案。对于第 $i$ 个数，放在第 $k$ 个位置，会产生 $i-k$ 个逆序对，所以有转移：$dp_{i,j}=\displaystyle\sum_{k=1}^idp_{i-1,j-(i-k)}$。初始化 $dp_{0,0}=1$，答案为 $dp_{n,c}$。利用前缀和优化可以做到 $O(nc)$。

# Code

```cpp
#include<stdio.h>
const int mod=1e9+7;
int dp[10005];
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	dp[0]=1;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j)
			if((dp[j]+=dp[j-1])>=mod)dp[j]-=mod;
		for(int j=m;j>=i;--j)
			if((dp[j]-=dp[j-i])<0)dp[j]+=mod;
	}
	printf("%d",dp[m]);
	return 0;
}
```

---

## 作者：king_xbz (赞：3)

逆序对数量问题是一个相当经典的DP问题。这道也不例外

**那么怎么做呢？**

当我们计算到第$i$位时其实只需要考虑将$i$插入到$i-1$个位置即可。插入到第$k$个位置就会产生新的$k$个逆序对，所以得到转移方程：

$f_{i,j}+=∑_{k=1}^{i-1}f_{i-1,j-k}$

代码：

```cpp
f[1][0]=1;
for(fint i=1;i<=n;i++)
for(fint j=0;j<=c;j++)
{
	for(fint k=0;j-k>=0&&k<=i-1;k++)
	{
		if(j-k>=0)
		f[i][j]+=f[i-1][j-k],f[i][j]%=mods;
	}
	cout<<f[i][j]<<" ";
}
```

时间复杂度$O(nc^2)$,得分56分。

**考虑优化，直觉告诉我们可以用前缀和思维压掉一维。**

我们先累加上所有之前的$f_{i-1,j}$，然后再减去超出范围de部分，剩下的部分，就是满足条件的种类数量了QAQ。

代码：

```cpp
signed main()
{
	int n,c;
	cin>>n>>c;
	f[1][0]=1;
	for(fint i=1;i<=n;i++)
	{
		long long tot=0;
		for(fint j=0;j<=c;j++)
		{
			tot=(tot%mods+f[i-1][j]%mods)%mods;
			f[i][j]=(f[i][j]%mods+tot%mods)%mods;
			if(j>=i-1)
			tot=(tot%mods-f[i-1][j-i+1]%mods)%mods;
		}
	}
	cout<<(f[n][c]+mods)%mods;
	return 0;
}
```
时间复杂度$O(nc)$，得分100！！！

最后，推荐几道相关练习题（多倍经验哇）：

[逆序对数列](https://www.luogu.com.cn/problem/P2513)  [求逆序对](https://www.luogu.com.cn/problem/P1521) [Permutations](https://www.luogu.com.cn/problem/SP64)

后排提示，取模不当会WA掉24PTS（或更多），无脑$long\ long$会MLE三个点。

祝大家AC愉快！


---

## 作者：do_it_tomorrow (赞：1)

[更好的阅读体验](https://www.doittomorrow.xyz/post/coci2006-20074-zbrka-de-ti-jie/)
# 题目大意
在一个长度为 $n$ 的排列中找出逆序对数量恰好为 $c$ 的排列总数，其中 $1\le n \le 10^3,1\le c \le 10^4$。
# 思路
考虑将 $1$ 到 $n$ 这些数从小到大一次填进去，因为每一次填入的数多是最大的，所以逆序对增加的数量只与其所在的位置相关，所以设计 $f_{i,j}$ 表示前 $i$ 个数逆序对为 $j$ 的方案数。

在填入第 $i$ 个数时因为前面的 $1$ 到 $i-1$ 都小于 $i$，所以 $i$ 每向前移动一个位置，逆序对的数量就会增加 $1$。

因为 $i$ 的位置并没有限制，所以 $f_{i,j}=\sum \limits^{i-1}\limits_{k=0} f_{i-1,j-k}$。

这个方法的时间复杂度与空间复杂度都是 $O(n\times c^2)$ 的，无法通过此题，所以可以使用前缀和与滚动数组优化。
# AC Code
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4+5,mod=1e9+7;
int n,c,f[N],ans;
signed main(){
    cin>>n>>c;
	f[0]=1;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=c;j++) f[j]=(f[j]+f[j-1])%mod;
        for(int j=c;j>=i;j--){
            f[j]=(f[j]-f[j-i]+mod)%mod;
        }
    }cout<<f[c]<<endl;
    return 0;
}
```

---

## 作者：run_away (赞：1)

## 题意概括

题面很清楚，不多赘述了。
## 分析

设 $f_{i,j}$ 表示已用前 $i$ 个数，使数列出现 $j$ 个逆序对的方案数。

因为从小到大枚举 $i$，所以填 $i$ 时前面所有的数都比它小，那么 $i$ 每向前移动一位，就会增加一个逆序对。所以可以直接枚举每一个 $i,j$，再枚举插入 $i$ 的位置，转移方程是 $f_{i,j}=\sum\limits_{k=0}^{i-1} f_{i-1,j-k}$。但这样是 $O(nc^2)$ 的，会 **TLE**。

但是可以发现，第三维就是在找 $[j-i+1,i-1]$ 的区间，所以可以加入一个前缀和，把复杂度优化到 $O(nc)$，通过这道题。
## Code

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod=1e9+7;
ll n,c,f[10005]={1},s[10005];
signed main(){
    cin>>n>>c;
    for(ll i=2;i<=n;++i){
        s[0]=f[0];
        for(ll j=1;j<=c;++j)s[j]=(s[j-1]+f[j])%mod;//预处理前缀和
        for(ll j=0;j<=c;++j){
            if(j>=i)f[j]=(s[j]-s[j-i]+mod)%mod;
            else f[j]=s[j];
        }//计算f[j]
    }
    cout<<f[c];
    return 0;
}
```

---

## 作者：zhuohongyuan (赞：0)

一道关于逆序对的题。建议先 A 了 [P1521](https://www.luogu.com.cn/problem/P1521)，再来做会更有思路。



## 题意简述

求长度为 $ n $，逆序对数为 $ c $ 的排列数，答案对 $ 10^9+7 $ 取模。
$ 1 \leq n \leq 10^3 $，$ 1 \leq c \leq 10^4 $。

## 代码

#### 56 分

```c++
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;
int n, c; // 排列长度，逆序对数量
int f[1001][10004];
int main()
{
    cin >> n >> c;
    f[1][0] = 1;                 // 初始化
    for (int i = 2; i <= n; i++) // 长度
    {
        for (int j = 0; j <= c; j++) // 逆序对数量
        {
            for (int k = 1; k <= i; k++)
            {
                if (j - i + k >= 0)
                {
                    f[i][j] = (f[i][j] + f[i - 1][j - i + k]) % mod; // 更新 f[i][j]
                }
            }
        }
    }
    cout << f[n][c];
    return 0;
}
```

时间复杂度 $ O(n^{2}c) $，很好想，$ f[i][j] $ 表示从 $ 1 $ 到 $ i $ 的全排列，存在 $ j $ 个逆序对的情况数。

#### 64 分

```c++
#include <bits/stdc++.h>
using namespace std;
int N, K; // 长度，逆序对数量
int f[5000][5000]; // f[i][j] 表示前 i 个物品，逆序对数量为 j 的背包的方案数
int main()
{
    cin >> N >> K;
    f[1][0] = 1; // 初始化
    f[2][1] = 1;
    f[2][0] = 1;
    f[0][0] = 1;
    for (int i = 3; i <= N; i++) // 遍历长度
    {
        for (int j = 0; j <= K; j++) // 遍历逆序对数量
        {
            for (int k = 0; k <= i - 1 && j - k >= 0; k++)
            {
                f[i][j] = (f[i - 1][j - k] + f[i][j]) % 1000000007; // 计算 f[i][j]
            }
        }
    }
    cout << f[N][K] << endl;
    return 0;
}
```

时间复杂度 $ O(N^{2} \times K) $，其实就是 P1251 的 AC 代码。改个模数就可以了。

#### 100 分

```c++
#include <bits/stdc++.h>
#define mod 1000000007
#define maxn 10004
using namespace std;
int n, c; // n 是排列的长度，c 是逆序对的数量
int f[maxn], s[maxn]; // f[j] 表示逆序对数量为 j 的排列的方案数，s[j] 是辅助数组
int main()
{
    cin >> n >> c;
    f[0] = 1; // 初始化，啥都不选，价值为 1
    for (int i = 2; i <= n; i++)
    {
        s[0] = f[0];
        for (int j = 1; j <= c; j++) // 遍历逆序对数量
        {
            s[j] = (s[j - 1] + f[j]) % mod; // 前缀和优化
        }
        for (int j = 0; j <= c; j++) // 遍历逆序对数量
        {
            if (j - i >= 0) // 放得下
            {
                f[j] = (s[j] - s[j - i] + mod) % mod;
            }
            else // 放不下
            {
                f[j] = s[j];
            }
        }
    }
    cout << f[c];
}
```

时间复杂度 $ O(nc) $ , 是 56 分代码的优化， 利用前缀和把 $ dp $ 降成一维， $ dp[j]=s[j]−s[j−i] $。

### 题目推荐

- [SP64](https://www.luogu.com.cn/problem/SP64)
- [P1908](https://www.luogu.com.cn/problem/P1908)


 $a _ {b} ^ {c}$（`$a _ {b} ^ {c}$`）

---

## 作者：TPJX (赞：0)

### 题目分析
为了解决这个问题，可以使用动态规划。我们定义 $dp_{i,j}$ 表示使用前 $i$ 个数字构成的排列中恰好有 $j$ 个逆序对的排列数量。对于每一个新的数字 $k$ (从 $1$ 到 $n$, 我们可以将它放在当前排列的任意位置，从而影响逆序对的数量。

易得动态规划的状态转移方程，可以表示为：
$$dp_{i,j} = \sum_{x=0}^{\min(i-1, j)} dp_{i-1,j-x}$$
这里，$x$ 表示将数字：$i$ 插入造成的新增逆序对数量，它的范围是从 $0$ 到 $\min(i-1, j)$。

#### 优化
- 使用模 $10^9+7$ 进行所有计算以避免溢出。~~（是个人都知道）~~

- 可以使用前缀和来优化 $dp_{i,j}$ 的计算。

时间复杂度：$O(n \times c)$（本题有更高效的方法，但本题中 $n \le 1000$ 且 $c \le 10000$ 是可以接受的）

### 代码

```cpp
#include <bits/stdc++.h>
const int MOD = 1e9 + 7;
const int N = 1010, C = 10010; 
int dp[N][C], sum[C]; // 前缀和
using namespace std;
int main() {
    int n, c;
    cin >> n >> c;
    dp[0][0] = 1; // 初始条件，0个数且0个逆序对的排列有1种（空排列）
    for (int i = 1; i <= n; ++i) {
        // 计算前缀和
        sum[0] = dp[i-1][0];
        for (int j = 1; j <= c; ++j) 
            sum[j] = (sum[j-1] + dp[i-1][j]) % MOD;
        for (int j = 0; j <= c; ++j) {
            if (j >= i) dp[i][j] = (sum[j] - sum[j-i] + MOD) % MOD; 
            else dp[i][j] = sum[j];
        }
	}
    cout << dp[n][c];
    return 0;
}
```

---

## 作者：xuan_gong_dong (赞：0)

## 题面

[P6323 [COCI2006-2007#4] ZBRKA](https://www.luogu.com.cn/problem/P6323)

## 分析
一开始以为是一个记忆化搜索，仔细一想才发现好像 dp 可写。

不妨定义 $dp_{i,j}$ 表示当前要放入 $i$，放入之后有 $j$ 个逆序对个数的方案数。

易得转移方程 

$$dp_{i,j} \sum_{k=0}^{k \le \min(i-1,j)} dp_{i-1,j-k}$$

此时时间复杂度为 $O(n \times c^2)$，超时嘞。

发现后面那个式子可以用前缀和数组代替，代替后效率是 $O(n \times c)$，可以通过。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int dp[10010],pre[10010];
int n,c;
signed main(){
	scanf("%lld%lld",&n,&c);
	dp[0]=1;
	for(int i=2;i<=n;i++){
		pre[0]=dp[0];
		for(int j=1;j<=c;j++)
			pre[j]=(pre[j-1]+dp[j])%mod;//pre是前缀和 
		for(int j=0;j<=c;j++){
			if(j-i>=0)dp[j]=(pre[j]-pre[j-i]+mod)%mod;
			else dp[j]=(pre[j])%mod;
		}
	}
	printf("%lld",dp[c]);
	return 0;
}
```

---

## 作者：Xiphi (赞：0)

考虑 dp 求解，一个常见的套路是：设 $dp_{i,j}$ 表示填前 $i$ 个正整数，逆序对数为 $j$ 的方案数。然后每次转移的时候枚举这一位该填啥。这样转移复杂度是 $O(n^2c)$ 的，这里列了个式子可以看下：

$$dp_{i,j}=\sum_{k=1}^i dp_{i-1,j-i+k}$$

至于为什么是 $dp_{i-1,j-i+k}$，这是因为每次填入一个数，他的贡献就是 $j-(i-k)$，也就是说前边有 $i-k$ 个比他大的，会产生逆序对。

考虑到 $[1,i]$ 是在数组中连续的一段，每次考虑记录上次的 dp 数组的前缀和，然后就可以做到 $O(1)$ 转移了。

这样直接交上去会 MLE，滚动数组即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c;
int dp[2][10005],g[2][10005];
const int p=1e9+7;
int main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>n>>c;
	dp[1][0]=1;
	for(int i=2;i<=n;++i){
		g[1&(i-1)][0]=dp[1&(i-1)][0];
		for(int j=1;j<=c;++j){
			g[1&(i-1)][j]=g[1&(i-1)][(j-1)]+dp[1&(i-1)][j];
			g[1&(i-1)][j]%=p;
		}
		for(int j=0;j<=c;++j){
  			if(j-i>=0) dp[i&1][j]=(g[1&(i-1)][j]-g[1&(i-1)][j-i]+p)%p;
			else dp[i&1][j]=g[1&(i-1)][j];
		}
	}
	cout<<dp[n&1][c];
	return 0;
}




```

---

## 作者：xler0915 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6323) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p6323)

### 题意
求长度为 $n$，逆序对有 $c$ 个的排列的数量，答案对 $10^9+7$ 取模，$1 \le n \le 10^3$，$1 \le c \le 10^4$。

### 思路：dp
我们设 $dp_{i,j}$ 表示 $1 \sim i$ 的排列中，逆序对数量为 $j$ 的方案数，考虑：

- 若将 $i$ 放到第 $k$ 个空中，则其后 $i - k$ 个值比 $i$ 小，所以 $dp_{i,j} \gets dp_{i,j} + dp_{i-1,j-i+k}$。

- 因为 $1 \le k \le i$，且第二维数组的下标 $i-j+k \ge 0$，所以 $\max\{1,i-j\} \le k \le i$。

由上可得，状态转移方程为：

$$dp_{i,j} = \sum_{k=\max\{1,i-j\}}^idp_{i-1,j-i+k}$$

令 $sum_{j} = \sum_{k=0}^jdp_{i-1,k}$，考虑简化状态转移方程：

- 若 $i-j < 1$，则 $dp_{i,j}$ 为 $dp_{i-1,j-i+1} \sim dp_{i-1,j}$ 的和，即 $dp_{i,j}=sum_{j}-sum_{j-i}$。

- 若 $i-j \ge 1$，则 $dp_{i,j}$ 为 $dp_{i-1,0} \sim dp_{i-1,j}$ 的和，即 $dp_{i,j}=sum_{j}$。

若在压缩第一维，即可得到：

$$dp_j=\begin{cases}sum_j-sum_{j-i}&i-j<1\\sum_j&i-j\ge1\end{cases}$$

这和题解区的

$$dp_j=\begin{cases}sum_j-sum_{j-i}&j\ge i\\sum_j&j<i\end{cases}$$

是一样的。

注意，在编写代码时，先把 $sum_{j}$ 求出来，防止 $dp_j$ 变成新的值，从而影响 $sum_{j}$。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;
int n, c;
int dp[10005], sum[10005];

int main() {
	scanf("%d%d", &n, &c);
	dp[0] = 1;
	for(int i = 2; i <= n; i++) {
		sum[0] = dp[0];
		for(int j = 1; j <= c; j++)
			sum[j] = (sum[j - 1] + dp[j]) % mod;
		// 求出 sum 
		for(int j = 0; j <= c; j++) {
			if(i - j <= 1) dp[j] = (sum[j] - sum[j - i]) % mod;
			else dp[j] = sum[j];
		}
		// 状态转移方程 
	}
	printf("%d", (dp[c] + mod) % mod);
	// dp[c] 可能为负值 
	return 0;
}
```

**时间复杂度：$\Theta(nc)$。**

**空间复杂度：$\Theta(c)$。**

---

## 作者：BLX32M_10 (赞：0)

## P6323 [COCI2006-2007#4] ZBRKA 题解

首先数据范围说明了暴力是不可行的，而至于需要处理的变量只有两个，考虑动态规划（此题解中的所有下标从 $1$ 开始）。

怎么设状态很明显，设 $f_{i, j}$ 为 $1, 2, \cdots, i$ 的全排列中有恰好 $j$ 个逆序对的情况总数。

注意到用 $1, 2, \cdots, i - 1$ 与用 $2, 3, \cdots, i$ 等价，而缺少的 $1$ 则可以插入序列的每一位中。

对于所有的 $0 \leq k \leq \min\left(i - 1, j\right)$（要取最小值因为逆序对数不能为负），要在原序列中的 $j$ 个逆序对中增加 $k$ 个逆序对，就需要将 $1$ 插入原序列的第 $k + 1$ 个位置。

综上，得出转移方程

$$f_{i, j} = \sum^{\min \left(i - 1, j\right)}_{k = 0} f_{i - 1, j - k}$$

但是数据貌似对 $\mathcal O\left(n^2\right)$ 不太友好。

展开转移方程，得到

$$f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} + f_{i - 1, j - 2} + \cdots + f_{i - 1, j - i + 2} + f_{i - 1, j - i + 1}$$

注意到

$$f_{i, j - 1} = f_{i - 1, j - 1} + f_{i - 1, j - 2} + f_{i - 1, j - 3} + \cdots + f_{i - 1, j - i + 1} + f_{i - 1, j - i}$$

这就很好解决了！$f_{i, j}$ 比 $f_{i, j - 1}$ 多一个 $f_{i - 1, j}$，少一个 $f_{i - 1, j - i}$。

**（为方便书写，此处忽略了 $j < i - 1$ 的情况，写代码时注意即可）**

因此可得到方程

$$f_{i, j} = f_{i, j - 1} + f_{i - 1, j} - f_{i - 1, j - i}$$

时间复杂度 $\mathcal O\left(N\cdot C\right)$，空间复杂度 $\mathcal O\left(N\cdot C\right)$ 会达到 $10^7$，内存限制只有 62.5MB，考虑使用滚动数组优化，空间复杂度$\mathcal O\left(C\right)$。

AC 代码：

```cpp
#include <cstdio>
const long long mod = 1000000007;
long long f[2][10005];
bool flag;
int main()
{
    int n, c;
    scanf("%d %d", &n, &c);
    f[0][0] = 1;
    f[1][0] = 1;
    for (int i = 1; i <= n; i++)
    {
        flag = 1 - flag;
        f[flag][0] = 1;
        for (int j = 1; j <= c; j++)
        {
            f[flag][j] = (f[flag][j - 1] + f[1 - flag][j]) % mod;
            if (j - i >= 0)
                f[flag][j] = (f[flag][j] - f[1 - flag][j - i] + mod) % mod;
        }
    }
    printf("%lld", f[n & 1][c] % mod);
    return 0;
}
```

---

## 作者：0xFF (赞：0)

#### 题目大意


------------
在一个长度为 $n$ 的排列中找出逆序对数量恰好为 $c$ 的排列总数。

#### 思路分析


------------
考虑将 $1-n$ 从小到大放进排列中，那么放入 $i$ 的时候会与不超过 $i-1$ 个数产生逆序对。

设状态 $f[i][j]$ 表示长度为 $i$ 的排列中逆序对数恰好为 $j$ 的方案总数。

根据上述分析容易得到 $f[i][j] = \sum_{k=0}^{i-1}f[i-1][j-k]$ 这样做的复杂度显然无法通过。

观察上述转移方程发现 $f[i][j]$ 只与 $f[i-1][k] (k \le j)$ 有关，故考虑前缀和优化。

设前缀和数组 $g[i][j] = \sum_{k=1}^{j}f[i][k]$

每次转移时更新即可。

然而空间复杂度仍然无法通过此题，故考虑使用滚动数组优化。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const int mod = 1e9 + 7;
const int N = 1e4 + 10;

inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(x=='-') f=-1;
	for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
LL f[2][N],pre[2][N];
signed main(){
	int n = read() , c = read();
	f[0][0] = pre[0][0] = f[1][0] = pre[1][0] = 1;
	int k = 0;
	for(int i=1;i<=c;i++) pre[0][i] = 1;
	for(int i=1;i<=n;i++){
		k ^= 1;
		for(int j=1;j<=c;j++){
			f[k][j] = pre[k][j] = 0;
		}
		//cout<<f[k][0]<<endl;
		for(int j=1;j<=c;j++){
			if(j >= i) f[k][j] = (pre[k^1][j] % mod - pre[k^1][j-i] % mod + mod) % mod;
			else f[k][j] = (pre[k^1][j] % mod + mod) % mod;
			pre[k][j] = (f[k][j] % mod + pre[k][j-1] % mod + mod) % mod;
			//cout<<"i: "<<i<<" j: "<<j<<"       "<<f[k][j]<<" "<<pre[k^1][j]<<" "<< pre[k^1][j-i] <<" "<<pre[k][j-1]<<"\n";
		}
	}
	cout << f[k][c] % mod << "\n";
	return 0;
}

/*
9 13
17957
*/
```


---

## 作者：Undead2008 (赞：0)

[$\Large\textbf{P6323}\ \large\text{ZBRKA}$](https://www.luogu.com.cn/problem/P6323)

考虑 $i+1$ 到 $n$ 的一个排列。如果在这个排列中第 $k$ 个数后面插入 $i$，那么 $i$ 会和前面的 $k$ 个数产生 $k$ 个逆序对。假设有一个空序列，顺次插入 $n$ 到 $1$ 后，该序列就成为了一个 $1$ 到 $n$ 的排列，与此同时，我们把该序列的逆序对个数统计出来了。

初步DP思想：

令 `f[i][j]` 表示顺次插入 $n$ 到 $i$ 后，逆序对数量为 $j$ 的方案数。那么就可以得到转移方程：
$$f[i][j]=\sum^j_{k=j-i}f[i-1][k]$$
这个做法是 $\Theta\small(cn^2)$ 的，妥妥T飞。

考虑用前缀和维护，求和操作就变成了 $\Theta\small(1)$ 的。

但是空间复杂度为 $cn$，会MLE。所以要开滚动数组。

下面给出了核心代码。（详细注释！）
```cpp
//为了更好地维护前缀和，这里的 f[i+1] 代表逆序对数量为 i 的方案数。
//f[0]和qz[0]显然是0。
f[1]=1;//初始时排列为空，当然没有逆序对
for(int i=1;i<=c+1;i++)
	pr[i]=1;//预处理初始前缀和
for(int i=2;i<=n;i++){
	for(int j=c+1;j>=1;j--)//滚动数组为了不算重，需要倒序枚举
		f[j]=(1ll*pr[j]-pr[max(j-i,0)]+mod)%mod;
    //大坑，上面的前缀和差值可能为负数（取模后前缀和不单调）
	for(int j=1;j<=c+1;j++)
		pr[j]=(1ll*pr[j-1]+f[j]+mod)%mod;
}
cout<<f[c+1];
```

---

## 作者：JK_LOVER (赞：0)

## 题意
在一个长度为 $n$ 的排列中找出逆序对数量恰好为 $c$ 的排列总数。
## 分析
###  一：

我们可以看出长度为 $n$ 的排列是由长度为 $n-1$ 的排列转移来的。考虑 $dp$ 。定义 $dp[i][j]$ 是已经插入 $i$ 个数，已经产生 $j$ 个逆序对的总数。那么转移方程就为：
$$
dp[i][j+k] = \sum_{k=0}^c dp[i-1][k]
$$
代码实现：
```cpp
	for(int i = 1;i <= n;i++)
	{
		for(int j = 0;j <= i-1;j++)
		{
			for(int k = 0;k <= c;k++)
			{
				if(j+k>c) continue;
				dp[i][j+k] += dp[i-1][k]; 
				dp[i][j+k] = (1LL*dp[i][j+k]+mod) % mod;
			}
		}
	}
```

时间复杂度为 $O(n^2c) $ ，期望得分 $56$。
###  二：

可以发现，我们的 $i+k$ 全是由 $\min(j-i+1,0)$ 到 $c$ 这个前缀和转移过来的。所以可以用前缀和优化时间复杂度。为：$O(nc)$ 。期望得分 $64$ 。
$$
dp[i][j] = sum[i-1][j] - sum[i-1][\min(j-i+1,0)-1] 
$$
$$
sum[i][j] = sum[i][j-1]+dp[i][j]
$$
代码实现：
```cpp
	int k = j-i;
	dp[i][j] += sum[i-1][j];
	dp[i][j] = (1LL*dp[i][j]+mod)%mod;
	if(k >=0) dp[i][j] -= sum[i-1][k];
	dp[i][j] = (1LL*dp[i][j]+mod)%mod;
	if(j) sum[i][j] = sum[i][j-1] + dp[i][j];
	else sum[i][j] = 1;
	sum[i][j] = (1LL*sum[i][j]+mod)%mod;
```
### 三：
所以的 $dp[i]$， $sum[i]$ 数组全是由 $dp[i-1]$，$sum[i-1]$ 转移的。那么考虑滚动数组。期望得分 $100$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+10;
const int mod = 1e9+7;
int dp[2][N],sum[2][N],n,c;
int main()
{
	cin>>n>>c;
	sum[1][0] = dp[1][0] = 1;
	for(int i = 1;i <= n;i++)
	{
		for(int j = 0;j <= c;j++)
		{
			int k = j-i;
			dp[i&1][j] = sum[i-1&1][j];
			dp[i&1][j] = (1LL*dp[i&1][j]+mod)%mod;
			if(k >=0) dp[i&1][j] -= sum[i-1&1][k];
			dp[i&1][j] = (1LL*dp[i&1][j]+mod)%mod;
			if(j) sum[i&1][j] = sum[i&1][j-1] + dp[i&1][j];
			else sum[i&1][j] = 1;
			sum[i&1][j] = (1LL*sum[i&1][j]+mod)%mod;
		}
	}
	cout<<dp[n&1][c]<<endl;
}
```
[地址](https://www.luogu.com.cn/blog/xzc/solution-p6323)

---

## 作者：xyzqwq (赞：0)

[P6323](https://www.luogu.com.cn/problem/P6323)


取 $dp_{i,j}$ 为长度为 $i$ 的排列中找出逆序对数量恰好为 $j$ 的排列总数。

于是容易写出转移式

$$dp_{i,j}=\sum_{k=0}^{\min(i-1,j)} dp_{i-1,j-k}$$

但是如果写出这个算法，我们发现它是 $O(n^2c)$ 的，会 TLE，于是考虑优化。

在转移式中是一个求和，由于在 dp 数组中连续，故可用前缀和优化，于是每次枚举 $i$ 时处理出 $dp_{i-1}$ 的前缀和即可优化为 $O(nc)$。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10,M=1e4+10,mod=1e9+7;
int dp[N][M];
int s[N];
int n,c;
int main(){
	cin>>n>>c;
	dp[1][0]=1;
	for(int i=1;i<=n;i++){
		s[0]=0;
		for(int j=0;j<=c;j++) s[j]=(s[max(j-1,0)]+dp[i-1][j])%mod;
		for(int j=0;j<=c;j++) dp[i][j]=(s[j]-s[j-min(i-1,j)-1]+dp[i][j])%mod;
	}
	cout<<(dp[n][c]%mod+mod)%mod;
}

```

需要注意的是，前缀和取模后并不单调，故可能会出现负数，输出时加再取模即可。

---


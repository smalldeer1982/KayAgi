# [COCI 2006/2007 #4]  JOGURT

## 题目描述

给定一棵完全二叉树，共 $n$ 层。

我们将根节点记为在第 $0$ 层，根节点的两个子节点记为在第 $1$ 层，以此类推。

现在，我们要把 $1\sim 2^n-1$ 这 $2^n-1$ 个数字不重复无遗漏的分别填入每个节点，使得对于任意的 $d$，以第 $d$ 层的一个节点为根，它的左右子树分别的数字之和的差的绝对值等于 $2^d$。

请你给出一个可行的方案，只需输出这个方案的[先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin)即可。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 15$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #4](https://hsin.hr/coci/archive/2006_2007/contest4_tasks.pdf) *T5 JOGURT***

感谢 @[一扶苏一](https://www.luogu.com.cn/user/65363) 提供SPJ！

## 样例 #1

### 输入

```
2```

### 输出

```
3 1 2```

## 样例 #2

### 输入

```
3```

### 输出

```
3 1 7 5 6 2 4```

# 题解

## 作者：Ted_LightningTechG_ (赞：3)

#  $\mathbf{0x01}$ 题目思路

这是道找规律的好题。我们先来构建一棵四层的树。
```
          15
    14          13
    
 12    10    11    9
 
1  5  3  7  2  6  4  8
```

**没规律啊！**

来，我们把它变一变：将最后一行的顺序倒过来，维持每一行大致呈下降趋势。
```
          15
    14          13
    
 12    10    11    9
 
8  4  6  2  7  3  5  1
```
然而，这好像还是不太有规律。再来一次，将每一行最小的数变为 $1$，同行的其它数也减去相同的数：
```
          1
    2          1
    
 4     2    3     1
 
8  4  6  2  7  3  5  1
```
**规律来咯！**

对于每一行，我们都可以这么来构造，以第 $3$ 行为例

先是一个 $1$：
```
1
```

复制一下，把复制出来的放到左侧，然后加 $4$：
```
5 1
```

再复制，把复制出来的放到左侧，加 $2$：
```
7 3 5 1
```

重复操作，直至这行满了：
```
8 4 6 2 7 3 5 1
```

我们发现，每行的构造方式几乎一致，但是每次复制时加的数有些不同，我列张表：

|  | 第一次加 | 第二次加 | 第三次加 |
| :----------: | :----------: | :----------: | :----------: |
| 第四行 | $4$ | $2$ | $1$ |
| 第三行 | $2$ | $1$ | - |
| 第二行 | $1$ | - | - |
| 第一行 | - | - | - |


不难看出第 $n$ 行第一次加 $2^{n - 2}$。

好了，树建好了，但是这棵树不太对的样子。别忘了我们可是做过 $2$ 次操作的，所以再把它变回去。

我们选择倒推，还记得我们第二次干了什么吗？我们减掉了一个特定的数值。然而，我们现在不知道到底减了多少。我们回头康一康：
```
          15
    14          13
    
 12    10    11    9
 
8  4  6  2  7  3  5  1

          1
    2          1
    
 4     2    3     1
 
8  4  6  2  7  3  5  1
```

第一行，减了 $14$；

第二行，减了 $12$；

第三行，减了 $8$；

第四行，减了 $1$。

如果说这样看不出什么的话，你可以看看整棵树。没错！每次减掉的就是当前行以下所有元素的个数。

然后，还记得我们第一次干了什么吗？我们逆序了最后一行。这个就不用我多说了吧。

最后的最后，还有一个先序输出。由于我把树存在了数组里，所以有些麻烦，具体操作细节在代码里展示。


# $\mathbf{0x02}$ 代码


```
#include<bits/stdc++.h>
//using namespace std;
int n;
int node[20][60000], ans[20][60000];
void dfs(int L, int len, int floor, int minus) {//对每行的建树，建完顺便放入node
	if( len == 1 ) {
		node[floor][L] = ( 1 << floor - 1 );
		return;	
	}
	int hlf = (len >> 1), tot = 1 << floor - 1;
	dfs( L + hlf, hlf, floor, minus << 1);
	int mid = hlf + L - 1;
	for(int i = L; i <= mid; i ++) node[floor][i] = node[floor][i + hlf] - minus;
}
void print(int x, int y) {
	if( x == n ) {//若到了第n行，那就直接输出，返回
		std::cout << ans[x][y] <<' ';
		return;
	}
	std::cout << ans[x][y] <<' ';//输出当前的数，即根
	print( x + 1, (y << 1) - 1 );//跳至左子树的根，位于ans[x+1][(y<<1)-1]，进行递归，即左
	print( x + 1, y << 1 );//同左子树，这里是右
}
int main() {
	std::cin >> n;
	for(int i = n; i > 0; i --) 
		dfs( 1, 1 << i - 1, i, 1 );	//建树并存入node
	int num = 0;
   //将树还原
	for(int i = n; i >= 1; i --) {//把变形时减掉的数字加上
		for(int j = 1; j <= ( 1 << i - 1 ); j ++) 
			node[i][j] += num;
		num += ( 1 << i - 1 );
	}
	for(int i = 1; i < n; i ++) //把顺序转正，存入ans
		for(int j = 1; j <= ( 1 << i - 1 ); j ++) 
			ans[i][j] = node[i][( 1 << i - 1 ) - j + 1];
	for(int i = 1; i <= ( 1 << n - 1 ); i ++) ans[n][i] = node[n][i];
	print(1, 1);//先序输出
	return 0;
}
```

---

## 作者：Daniel13265 (赞：3)

构造一棵二叉树：深度为 $d$ 每个结点的左右儿子的值（而非左右子树的和）的差（而非差的绝对值）为 $-2^d$。这样的二叉树是唯一的。

考虑将第 $(n-1)$ 层的结点权值翻转。对于一个在翻转过后的树上深度为 $d$ 的结点 $(0\le d<n-1)$，其左右子树的权值和的差值为 $-2^d\times(2^{n-d-2}-1)+2^d\times2^{n-d-2}=2^d$（即左右子树中非叶子结点的差与左右子树中叶子结点的差的和），其绝对值为 $2^d$，因此这是一个合法的构造方案。

例如对于 $n=5$ 的构造方案（添加了前导零）：

```
                              01

              02                              03

      04              06              05              07

  08      12      10      14      09      13      11      15

31  23  27  19  29  21  25  17  30  22  26  18  28  20  24  16
```

具体可以自行画图理解或者参考代码。时间复杂度 $\mathcal O(2^n)+\mathcal T(\text{Output})$。输出部分复杂度不可忽略，故总时间复杂度 $\mathcal O(n\times2^n)$。

```cpp
#include <cstdio>
#include <algorithm>

int n;
int val[1 << 15];

void build(const int &o, const int &d, const int &v) {
  if (d == n) return;
  val[o] = v;
  build(o << 1, d + 1, v + (1 << d));
  build(o << 1 | 1, d + 1, v + (1 << (d + 1)));
}
void print(const int &o, const int &d) {
  if (d == n) return;
  printf("%d ", val[o]);
  print(o << 1, d + 1);
  print(o << 1 | 1, d + 1);
}

int main() {
  scanf("%d", &n);
  build(1, 0, 1);
  std::reverse(val + (1 << (n - 1)), val + (1 << n));
  print(1, 0);
  return 0;
}

```



---

## 作者：decoqwq (赞：2)

思路来源于：最底下一层有 $2^{n-1}$ 个数，则只要让上面的差值每一层对应节点间都为 $1$ ，最后一层通过修改一定可以让根节点的两个子树的值之和差为 $1$。

考虑怎么构造，猜测 $1-2^{n-1}$ 都在最下面一层，接下来的 $2^{n-2}$ 个数在倒数第二层，以此类推。

令一个左子树的点的层数为 $x(x<n)$，将他赋值为他的父亲的值减去 $2^{x-1}$，他的兄弟节点为他的值加 $2^{x-2}$，发现只需要修改最下面一层的点值就可以做到满足条件。可以打表出 $n=4$ 的树：
```
15
13 14
9 11 10 12
4 8 2 6 3 7 1 5
```
可以发现倒数第二层的点的左子树的值为他在本层从大到小的排名。

容易验证答案是正确的，构造即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,l[40010],r[40010];
int pt[40010],tot,f[40010];
bool cmp(int x,int y)
{
	return x>y;
}
int build(int ce,int now)
{
	if(ce<n-1)
	{
		int qwq=(1<<ce);
		l[now]=now-qwq,r[now]=l[now]+(1<<(ce-1));
		build(ce+1,l[now]),build(ce+1,r[now]);
	}
	else
	{		
		l[now]=lower_bound(pt+1,pt+tot+1,now)-pt;
		l[now]=(1<<(n-2))-l[now]+1;
		r[now]=l[now]+(1<<(ce-1));
	}
}
void output(int ce,int now)
{
	cout<<now<<" ";
	if(ce==n)
	{
		return ;
	}
	output(ce+1,l[now]),output(ce+1,r[now]);
}
int main()
{
	cin>>n;
	if(n==1)
	{
		cout<<1;
		return 0;
	}
	if(n==2)
	{
		cout<<"3 1 2";
		return 0;
	}
	tot=(1<<(n-2));
	int st=tot*2+1;
	for(int i=1;i<=tot;i++)
	{
		pt[i]=st+i-1;
	}
	sort(pt+1,pt+tot+1);
	int qwq=(1<<n)-1;
	build(1,qwq);
	output(1,qwq);
}
```

---

## 作者：MnZnOIer (赞：1)

思路：**本题用类似线段树的做法，先按照题目要求用递归建树，再通过递归输出先序遍历。**

我们不妨将第 $n-1$ 层的权值翻转，对于一个在翻转过后的树上深度为 $d$ 的结点，其左右儿子的权值和的差值为 $2^d$，所以这是一个合法的方案。

关于时间复杂度，按层序递归的时间不可忽略，递归了 $n$ 层，输出了 $2^n$ 个数，所以时间复杂度为 $\Theta(n\times2^n)$。

下面是代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define sycn ios::sync_with_stdio (0),cin.tie (0), cout.tie (0)
using namespace std;
int n, v[2 << 15];
void build (int i, int d, int w)//递归建树
{
	if (d == n)return;
	v[i] = w;
	build (i << 1, d + 1, w + (1 << d));
	build (i << 1 | 1, d + 1, w + (1 << (d + 1)));
}
void out (int i, int d)//递归输出先序遍历
{
	if (d == n)return;
	cout << v[i] << ' ';
	out (i << 1, d + 1);
	out (i << 1 | 1, d + 1);
}
signed main ()
{
	sycn;
	cin >> n;
	build (1, 0, 1);
	reverse (v + (1 << (n - 1)), v + (1 << n));//翻转第 n-1 层
	out (1, 0);
	return 0;
}
```


---

## 作者：Ren_Hx (赞：0)

### 思路
既然给定这棵完全二叉树的层数 $n$ ，那么我们主要的任务就是建树。

假设我们设 $n=3$ ，那么我么可以建出如下图的一棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/eyxkzy8q.png)

根据题意，这棵树被划分为 $3$ 层：

![](https://cdn.luogu.com.cn/upload/image_hosting/9fo84bjf.png)

因为本题使用的 SPJ ，所以呢，我们就不需要管顺序的问题。也就是说，间的书可以是一个顺序的树，那怎么建这么一个树呢？

我们可以先用一个结构体存储，因为 $1 \le n \le 15$ ，所以我们可知它最大的根节点是多少，也就是 $2^{14}-1 = 32767$ ，开到 $40000$ 够了：

```cpp
const int maxsize = 40000;
struct TREE {
     int num;//当前节点的序号
     int lc;//左儿子
     int rc;//右儿子
} t[maxsize];
```
让后在主函数里先输入 $n$ ，在生成一颗顺序的树。


```cpp
int n;
scanf("%d",&n);
for(int i=1;i<=n;i++)
{
    t[i].num=i;
    t[i].lc=i*2;//左儿子=当前的数*2
    t[i].rc=i*2+1;//左儿子=当前的数*2+1
}
```

最后调用前序遍历的函数输出即可。

---


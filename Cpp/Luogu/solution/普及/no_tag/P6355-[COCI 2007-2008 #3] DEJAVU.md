# [COCI 2007/2008 #3] DEJAVU

## 题目描述

给出平面内的 $n$ 个点，计算有多少不同的直角三角形，满足其顶点均为给出的点，**且直角边均平行于坐标轴**。

两个直角三角形不同当且仅当它们存在至少一个顶点不同。

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n<100$；
- 对于 $70\%$ 的数据，保证 $n<10^4$；
- 对于 $100\%$ 的数据，保证 $3\le n\le 10^5$，坐标的数值在 $1$ 和 $10^5$ 之间，且不存在任何两个点的坐标相同。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T4 DEJAVU***。

## 样例 #1

### 输入

```
3
4 2
2 1
1 3```

### 输出

```
0```

## 样例 #2

### 输入

```
5
1 2
2 1
2 2
2 3
3 2```

### 输出

```
4```

## 样例 #3

### 输入

```
6
10 10
20 10
10 20
20 20
30 20
30 30```

### 输出

```
8```

# 题解

## 作者：封禁用户 (赞：3)

kcm的原题。。

貌似是个组合数（？

[此处食用效果更佳哦](https://www.cnblogs.com/CM-0728/p/13476628.html)

### $\sf Solution$

对于每一个点，我们需要统计与它同一行的点数 $a$ 和同一列的点数 $b$ ，则该点对结果 $ans$ 的贡献为 $(a-1)\times (b-1)$ 。

当然如果统计两重循环的话，那肯定是会TLE的啦。那么就要加一个预处理了：

用两个 map 数组分别统计 $a$ 和 $b$ 。


之所以考虑用 map 是因为开数组可能会炸，后来发现好像不会……

### $\sf P.S.$

因为有乘运算，并且 $n\leq 10^5$ ，所以不开 long long是要炸掉的哦。

### $\sf Code$

```cpp
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;
struct node
{
	int x,y;
}a[100004];
int n;
long long ans;
map<long long,long long>m1,m2;//long long!
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d%d",&a[i].x,&a[i].y);//读入
	for(int i=1;i<=n;++i)
		++m1[a[i].x],++m2[a[i].y];//分别统计行和列
	for(int i=1;i<=n;++i)
		ans+=(m1[a[i].x]-1)*(m2[a[i].y]-1);//根据那啥算
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：SingularPoint (赞：3)

### 题目大意
给出坐标系中的$n$个点，求以不同的三个点组成的 **直角边与坐标轴平行的直角三角形**个数。
### 分析
由题意可以知道：如果我们设符合要求的三角形直角顶点坐标为$A(x_1,y_1)$，那么剩下两点坐标一定为$B(x_1,y_i)$、$C(x_j,y_1)$。所以，如果我们确定一个点为直角顶点，那么可以与之配合成为目标三角形的只有是横、纵坐标都与之相同的点。

由此，我们可以考虑用两个数组$sumx$、$sumy$来记录一个横坐标或纵坐标上的点的个数，明显的，当直角顶点为$A(x_1,y_1)$时，可以组成的目标三角形个数为
>$(sumx(x_1)-1)\times(sumy(y_1)-1)$

（注：-1是减去当前所在的点）

由此，我们可以枚举每个点，取出它所在的横、纵坐标，用上面的公式计算出在这个点可以组成的目标三角形个数，累加起来，就是答案啦~

分析结束，上代码！
### Code
**P.S.：$3\leq n<10^5$，日常爆int，不开long long两行泪。**
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int M=100005;
struct node{
	ll x,y;
}p[M];
int n;
ll sx[M],sy[M];
ll ans=0;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&p[i].x,&p[i].y);
		sx[p[i].x]++;
		sy[p[i].y]++;
	}
	for(int i=1;i<=n;i++)
		ans+=(sx[p[i].x]-1)*(sy[p[i].y]-1);
	printf("%lld",ans);
	return 0;
}
```
完结撒fa~

---

## 作者：Math_rad_round (赞：1)

_[P6355](https://www.luogu.com.cn/problem/P6355)_

题目简述（其实已经够简洁了）：

给出平面上的$n$个点，求这$n$个点可以构成的，两条直角边都和坐标轴平行的直角三角形数量

这道题因为三角形直角边都和坐标轴平行，所以我们得到，满足关系的三角形坐标一定像这样三个点

![](https://note.youdao.com/yws/res/11/WEBRESOURCE25f17182e7305c4b3c9d7b24dcbd47e7)



$$A(x_1,y_1),B(x_1,y_2),C(x_2,y_1)$$

这样，我们可以枚举每一个直角顶点A,然后计算这样的点对

这样，在和A一列的点中选一个，一行的也选一个，就是一个符合要求的三角形

我们可以提前用数组$a,b$,

$a_i=i$列上的点数

$b_i=i$行上的点数

而每一列可选的点=$a_{x_i}-1$ ,$-1$是为了去掉自己

每一行是$b_{y_i}-1$

最终用乘法公式，得出结果是有$(b_{y_i}-1)*(a_{x_i}-1)$个三角形

把每一个点这样计算，就可以得出结果了

因为$1<=x_i,y_i<=100000$

所以预处理$a,b$可以直接每读入一个$x_i,y_i$就$a_{x_i}+1$，$b_{y_i}+1$

每一个点枚举是$O(1)$，所以最终时间复杂度是$O(n)$,到达理论下线~~毕竟要读入n个点~~

另外，结果可能超$int$，所以要开$longlong$存答案

代码很简单

```cpp
#include<iostream>
using namespace std;

int a[100001];
int b[100001];
int x[100001];
int y[100001];
int main(){
	int n;
	long long ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		a[x[i]]++;b[y[i]]++;
	}
	for(int i=1;i<=n;i++){
		ans+=(long long)(a[x[i]]-1)*(b[y[i]]-1);
	}
	cout<<ans;
}
```

~~不要抄袭~~

---

## 作者：LZH_LOVE_ZRG (赞：0)

这是一道比较经典的~~思维~~题。

对于每个点，根据平面直角坐标系的性质，

我们只需要统计与其横坐标相同点的个数和与其纵坐标相同的点的个数。

因为只有这些点才能与之构成题中要求的直角三角形。

那么每个点对答案的共献就是 上面提到的两数据的乘积。

那么怎么来处理上面的数据呢？

我们考虑用 $x_i$ 表示第 $i$ 行的点的个数，

用 $y_j$ 表示第 $j$ 航点的个数，

这样我们就能解决这道题了。

时间复杂度：$ O(n)$，也就是线性的复杂度。

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int x[N],y[N];
int v[N],w[N];
int main(){
    int n; cin>>n;
    for(int i=1,a,b;i<=n;i++){
        cin>>a>>b;
        x[a]++,y[b]++;
        v[i]=a,w[i]=b;
    }
    long long ans=0;
    for(int i=1;i<=n;i++)
        ans+=1ll*(x[v[i]]-1)*(y[w[i]]-1);//爆 long long 警告
    cout<<ans;
    return 0;
}

```

---

## 作者：lmrttx (赞：0)

首先，若已知的一个点的坐标为
$$x1,y1$$


那么，此直角三角形的另外两点一定为：
$$x1,?$$
$$?,y1$$

于是，进行枚举点。

用两个数组存横坐标和纵坐标中，像这样子，可能的个数。

最后，把这两个数组的和相乘，记住，每次乘的时候减一，因为，我们已经有原来的一个点了。

代码很短，很好理解，就这样AC啦！

加了防抄袭！

```cpp
#include<btis/stdc++.h>
using namespace std;
#define mxan 100001
typedef long long ll;
struct noed{
	ll x,y;
}a[maxn];
ll n,sum1[maxn],sum2[maxn],ans;
int main(){
	cin>>n;
	for(register ll i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		sum1[a[i].x]++;sum2[a[i].y]++;
        //记录总和
	}
	for(register ll i=1;i<=n;i++)ans+=(sum1[a[i].x]-1)*(sum2[a[i].y]-1);//乘起来记录答案
	cout<<ans<<endl;
	return 0;
}
```

谢谢阅读。


---

## 作者：A_Đark_Horcrux (赞：0)

如果三个点要构成一个直角边均平行于坐标轴的直角三角形，那么必须满足有两个点在同一条水平直线上，有两个点在同一条竖直直线上。

假设一点 $A$ ，过 $A$ 的水平直线上有 $x$ 个点，过 $A$ 的竖直直线上有 $y$ 个点，那么以 $A$ 为直角顶点，在这两天直线上，每两个点都可以作为直角三角形的另外两个点，以 $A$ 为直角顶点的直角三角形个数即为 $(x-1)*(y-1)$ （减一是因为不能选择点 $A$

思路就很明确了：输入时统计每条水平直线和竖直直线上有多少个点，然后枚举直角顶点计算即可。坐标的数值在 $1$ 和 $10^5$之间，直接用桶统计即可。时间复杂度 $O(n)$

最后： __不开ll见祖宗__

```cpp
#include<cstdio>
using namespace std;
const int N=1e5+10;
inline int read()
{
	int s=0,b=1; char c=getchar();
	while(c<'0'||c>'9') {if (c=='-') b=-1; c=getchar();}
	while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c&15),c=getchar();
	return s*b;
}
int n,i,x[N],y[N],b[N],c[N]; long long ans;//不开ll见祖宗
int main()
{
	n=read();
	for(i=1;i<=n;i++) x[i]=read(),y[i]=read(),b[x[i]]++,c[y[i]]++;//输入，统计
	for(i=1;i<=n;i++) ans+=(long long)(b[x[i]]-1)*(c[y[i]]-1);//计算答案
	printf("%lld",ans);//输出
	return 0;
}

```


---

## 作者：songhongyi (赞：0)

题意：你有若干个点。求有多少个被这三个点围成的**直角三角形**的两条直角边均**平行与坐标轴**.  
下图的三个三角形都是满足要求的三角形
[![BKZ7gs.png](https://s1.ax1x.com/2020/10/26/BKZ7gs.png)](https://imgchr.com/i/BKZ7gs)
我们显而易见的发现，枚举**直角所在的顶点**有多少个三角形是最容易的。  
显然，我们需要一个点与其$x$坐标相等，再去一个点与其$y$坐标相等，所以我们预处理一下每个横纵坐标上的点的个数即可。  
$$(cnt_{p.x}-1)\times (cnt_{p.y}-1)$$

代码：
```cpp

// Problem: P6355 [COCI2007-2008#3] DEJAVU
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6355
// Memory Limit: 0 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
using namespace std;
struct Point
{
    int x, y;
} a[ 100010 ];
long long int cntx[ 100010 ], cnty[ 100010 ];
int main()
{
    int n;
    cin >> n;
    for ( int i = 0; i < n; i++ )
    {
        cin >> a[ i ].x >> a[ i ].y;
        cntx[ a[ i ].x ]++;
        cnty[ a[ i ].y ]++;
    }
    long long int ans = 0;
    for ( int i = 0; i < n; i++ )
    {
        ans += ( cntx[ a[ i ].x ] - 1 ) * ( cnty[ a[ i ].y ] - 1 );
    }
    cout << ans << endl;
}
```

---

## 作者：Graphcity (赞：0)

照着样例 2 画出来的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/72ngcbv4.png)

不难发现有四个直角三角形。那么这四个三角形是怎么来的呢？

我们来观察一下每个三角形的直角顶点。对于每一个直角顶点，我们只要找到一个跟它横坐标相等和一个跟它纵坐标相同的顶点，就可以组成一个三角形了。

也就是说，假如有一个点 $A(x,y)$ , 横坐标为 $x$ 的点共有 $s_x$ 个，纵坐标为 $x$ 的点共有 $s_y$ 个，那么以 $A$ 为直角顶点的直角三角形的个数为：

$$
(s_x-1)(s_y-1)
$$

---

下面是代码部分：

（ 这道题的三角形个数有点多，需要开 **long long** ）

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn int(1e5)
#define lowbit(x) (x&-x)
using namespace std;

struct Tree//树状数组 
{
	ll t[Maxn+5];
	inline void Update(ll x,ll y)//在x位置加上y
	{
		while(x<=Maxn)
			t[x]+=y,x+=lowbit(x);
	}
	inline ll Count(ll x)//查询x位置的前缀和
	{
		ll cnt=0;
		while(x>0)
			cnt+=t[x],x-=lowbit(x);
		return cnt;
	} 
};
Tree tx,ty;//树状数组存储横纵坐标

ll n,ans;
ll x[Maxn+5],y[Maxn+5];

int main()
{
	scanf("%lld",&n);
	for(register ll i=1;i<=n;++i)
	{
		scanf("%lld%lld",&x[i],&y[i]);
		tx.Update(x[i],1),ty.Update(y[i],1);
	}
	for(register ll i=1;i<=n;++i)
	{
		ll sx=tx.Count(x[i])-tx.Count(x[i]-1)-1;
		ll sy=ty.Count(y[i])-ty.Count(y[i]-1)-1;
		//计算跟目前x,y值相同的数量
		ans+=(sx*sy);
	}
	printf("%lld",ans);
    return 0;
}

```

~~（ 做完之后才发现我写的树状数组根本没用 ）~~

---


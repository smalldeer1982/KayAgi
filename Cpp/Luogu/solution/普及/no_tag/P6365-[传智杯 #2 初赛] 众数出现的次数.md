# [传智杯 #2 初赛] 众数出现的次数

## 题目描述

传智专修学员的课堂上，为了活跃气氛，并巩固位运算的知识，同学们玩起了一个游戏。

班级里有 $n(n\le10^6)$ 名同学，每位同学都获得了两张卡，红卡或者黑卡。每张卡上都有一个不超过 $10^9$ 的非负整数。第 $i$ 位同学手里红卡数字是 $a_i$ ，黑卡数字是 $b_i$。

现在需要每位同学出牌。每位同学可以直接将红卡上的数字打出，或者将自己的红卡上的数字和自己黑卡数字进行按位异或操作后的结果打出。最后老师会收集所有同学打出的数字。

这些数字中出现次数最多的数字是众数。在所有同学合作的最优策略下，我们希望众数对应数字出现的次数尽可能多。请问出现次数最多的数字是多少呢？

## 说明/提示

样例解释：

众数出现次数最多是 $3$ 次，有如下两种方法：

- $1$ 号同学直接出红卡，$2$ 号同学出红黑异或，$3$ 号同学随便出，$4$ 号同学出红黑异或。这样 $1,2,4$ 号同学都可以打出 $21$。
- $1$ 号同学出红黑异或，$2$ 号同学直接出红卡，$3$ 号同学直接出红卡，$4$ 号同学随便出。这样 $1,2,3$ 号同学都可以打出 $28$。

所以 $21$ 和 $28$ 都是出现次数最多的众数，因为最多可以出现 $3$ 次，不存在出现 $4$ 次的方案。但是由于要求如果有多解输出小的，请输出 $21$。

## 样例 #1

### 输入

```
4
21 9
28 9
28 3
17 4```

### 输出

```
21```

# 题解

## 作者：Histone (赞：15)

众所周知，map是个好东西

因为每个人只可能打出红卡或者是黑卡异或红卡

所以我们输入时就可以直接这样

```cpp
int n = read();
for(re int i=1;i<=n;++i){
	num[i].a = read();
	num[i].b = num[i].a^read();
}
```

直接将黑卡存成异或的形式

然后就可以用map暴力搞

直接统计出现最多次数的数字就可以

有一点要注意:

因为一个人只能打‘红卡’或者是‘红卡和黑卡’

- 所以在‘红卡’==‘红卡和黑卡’的时候，只记录一次

- 如果有出现次数相同的数，应当取其中最小的那个。

这里非常感谢[snnu_lgw](https://www.luogu.com.cn/user/214455)提供的hack数据

```cpp
4
28 9
21 9
28 3
17 4
```

- 最后统计时候，记得开long long

本解法比较劣，时间复杂度较高 ~~（毕竟蒟蒻用map嘛）~~

直接上代码：

```cpp
#include<bits/stdc++.h>
#define re register
#define int long long
using namespace std;
inline int read(){
	re int ans = 0;re bool f = 1;re char ch = getchar();
	while(ch<'0'||ch>'9'){if (ch=='-')f = 0;ch = getchar();}
	while(ch>='0'&&ch<='9'){
		ans = (ans<<3)+(ans<<1)+(ch^48);
		ch = getchar();
	}
	return f?ans:~(ans-1);
}
const int N = 1e6+1e3;
struct st{int a,b;}num[N];
map<int,int>mp;
signed main(void){
	int ans = 0,p = 0;
	int n = read();
	for(re int i=1;i<=n;++i){
		num[i].a = read();
		num[i].b = num[i].a^read();
		if(num[i].a!=num[i].b)
		mp[num[i].a]++;
		mp[num[i].b]++;
	}
	for(re int i=1;i<=n;++i){
		int t1 = mp[num[i].a],t2 = mp[num[i].b];
		if(p<t1||(num[i].a<ans)&&p==t1){
			ans = num[i].a;
			p = mp[num[i].a];
		}
		if(p<t2||(num[i].b<ans)&&p==t2){
			ans = num[i].b;
			p = mp[num[i].b];
		}
	}
	printf("%lld\n",ans);
	return 0;				
}
```

2020.4.12更新：补了hack

不懂可以留言哦~ ，[个人博客](http://47.102.209.15/index.php/archives/35/) 阅读更佳

---

## 作者：xuanxuan001 (赞：8)

蒟蒻的第二篇题解。

题解区为什么通篇全是map和hash？

本蒟蒻不喜欢用map，hash都不会用$QAQ$

Upd
-
- 2020/8/10 改正了代码上的一个错误，感谢@wtxy2006 的提醒

正文
-
思路当然改不了，就是将每个人红卡的数和红卡异或黑卡的数都存起来，如果这两个数都一样就只存一个，然后再在这些数中找出最小的众数。

找众数本来可以弄个桶$O(n)$过的，可卡片上的数是到$10^9$的，如果很极端的话异或后可以到$2^{30}$，不能用桶，然后大佬们就去用map和hash了。

可是map比较费时，hash据说能卡到$O(n)$。

可真的需要这样么？直接把上述的那些整理出来的数排个序不就行了吗，这样相同的数就到一起了，在$O(n)$循环一下就可以了啊$QwQ$

复杂度就是排序的$O(n \log n)$，常数较小，不吸氧六个点总共1.06s，算快的了。

代码（~~文字中没有听懂的东西基本都能在代码中弄懂，这就是本蒟蒻的经验QAQ~~）

```
#include<cstdio>
#include<algorithm>
#define MAXN 1000002
using namespace std;
int n,a,b,n2,num[MAXN<<1],now=1,anst=1,ans;
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d%d",&a,&b);
		num[n2++]=a;//其实这就是一个vector 
		if(b!=0) num[n2++]=a^b;//防止红卡=红卡异或黑卡 
	}
	sort(num,num+n2);//sort要是手写就达成零STL的记录了QAQ 
	ans=num[0];
	for(int i=1;i<n2;i++){//找所有的数的出现次数 
		if(num[i]==num[i-1]) now++;//如果当前数和上一个一样 ，计数器++ 
		else{//如果不一样，更新答案后计数器归一 
			if(anst<now){
				anst=now;
				ans=num[i-1];
			}
			now=1;
		}
	}
	if(anst<now) ans=num[n2-1];//防止num数组中最后一个数（即最大的那种）是众数，最后还要再判断一遍 
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Imtking (赞：5)

[题面](https://www.luogu.com.cn/problem/P6365)

### 算法
模拟，哈希表

### 基本思路
对于第 i 个同学，可能打出 $a_i$ 或 $a_i \bigoplus b_i$， 我们可以使用 STL 的容器 unordered_map，为可能打出的每一个数建立映射，累加其出现次数，每次更新答案。

### 注意事项
1. 答案一定要是出现次数最多的；
1. 有多个答案，要输出最小的；
1. 如果 $a_i$ 和 $a_i \bigoplus b_i$ 的值是一样的，只计算一次。

### 完整代码

```cpp
#include <cstdio>
#include <unordered_map>
using namespace std;
typedef long long ll;
int main()
{
    unordered_map<ll, int> b;
    int ans = 0, n;
    ll out = 1e15;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        ll k1, k2;
        scanf("%lld%lld", &k1, &k2);
        ++b[k1]; //次数+1
        if (ans == b[k1]) //次数相同输出最小的众数
            out = min(out, k1);
        if (ans < b[k1]) //次数更多即更新答案
            ans = b[k1], out = k1;
            
        //接下来处理方法相同
        
        ll x = (k1 xor k2);
        if (k1 == x) //特判 k1 == x 的情况
            continue;
        ++b[x];
        if (ans == b[x])
            out = min(out, x);
        if (&& ans < b[x])
            ans = b[x], out = x;
    }
    printf("%lld", out);
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/80059755)

请不要抄袭代码。

---

## 作者：SmallTownKid (赞：4)

为什么都是map和hash啊，普普通通的数组不好吗。。当然数据强一点就只能用map了。这里防止超时枚举到了1e7，居然碾过去了。。。
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
int temp,n;
long long ans;
int vis[10000010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		if(a!=(a^b))
		vis[a]++;
		vis[a^b]++;
	}
	for(int i=1;i<=10000000-1;i++)
	{
		if(vis[i]>ans)
		{
			ans=vis[i];
			temp=i;
		}
	}
	cout<<temp;
	return 0;
}

---

## 作者：离散小波变换° (赞：3)

## 题目大意

$n$ 个数对 $(a_i,b_i)$。现在可以从每个数对中选择 $a_i$ 或者 $a_i\operatorname{xor}b$，使得新生成的数列的众数出现的次数尽量多。输出那个众数。若两个众数出现的次数一样多，输出最小的。

## 题解

没有人用链式前向星哈希吗？哈希表会伤心的！

很显然，如果 $b_i=0$，即 $a_i\operatorname{xor}b_i=a_i$，那么只需要向结果数列中插入 $a_i$ 即可。如果 $b_i\ne 0$，那么可以**将两个都插入**。可以证明这样对答案不会造成影响，因为如果答案是其中某个数，那么另外一个数并不会对答案造成影响。

因此，我们要做的事情其实很简单。若 $b_i\ne 0$，将 $a_i$ 和 $a_i\operatorname{xor}b_i$ 都插入哈希表；否则就将 $a_i$ 插入哈希表中。最后统计众数即可。

哈希表可以用链式前向星解决。具体而言，我们对插入的数字 $w$ 按照模 $\rm SIZ$ 的余数分配到对应的邻接表中，进行初步筛选。这一步保证了复杂度的正确性。同时，我们给对应位置加上原数 $w$ 和出现的次数两个信息。每次查询 $w$ 时，只需要遍历表 $w\bmod {\rm SIZ}$，然后**判断原始数据**是否等于 $w$。（不然可能哈希碰撞导致出错）若相同，则找到了哈希表中存储的位置。

每次插入数字，就是找到对应的信息位置，并使存储的出现次数 $+1$ 即可，顺便统计一遍它的出现次数，然后更新答案。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int SIZ =999997,MAXN=1e5+3;
int head[SIZ],ver[MAXN],nxt[MAXN],val[MAXN],tot;
void add(int u,int v,int w){
    ver[++tot]=v,nxt[tot]=head[u],val[tot]=w,head[u]=tot;
}
int fnd(int w){
    for(int p=head[w%SIZ];p;p=nxt[p])
    if(ver[p]==w) return p; return 0;
}
void inc(int w){
    int t=0; if(t=fnd(w)) ++val[t]; else
    add(w%SIZ,w,1); 
}
int n,ans,flg;
int main(){
    n=qread(); up(1,n,i){
        int a=qread(),b=qread(),c=0;
        if(!b) inc(a); else inc(a),inc(a^b); 
        if((c=val[fnd(a)])>ans) ans=c,flg=a; else
        if(c==ans&&a<flg) flg=a;
        if((c=val[fnd(a^b)])>ans) ans=c,flg=a^b; else
        if(c==ans&&a<flg) flg=a^b;
    }
    printf("%d\n",flg);
    return 0;
}
```

---

## 作者：_lgh_ (赞：1)

## 思路：
贪心。每次读入的时候将 $a_i$ 和 $b_i$ 在 map 的个数 ++ ，最后用 map 迭代器统计即可。

### 坑（~~84分警告~~）：
这一题虽然不用开 long long ，但是有可能 $a=a \oplus b$ ，此时需要特判，即只自增一次。


## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>m;
int n,a,b,Max,Maxa;
int main() 
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1; i<=n; i++) cin>>a>>b,m[a]++,(a!=(a^b)&&m[a^b]++);
	for(map<int,int>::iterator ii=m.begin(); ii!=m.end(); ii++) if(ii->second>Max) Max=ii->second,Maxa=ii->first;
	else if(ii->second==Max) Maxa=min(ii->first, Maxa);
	cout<<Maxa;
	return 0; 
}
```

---

## 作者：king_xbz (赞：1)

排序？hash？map？unorder_map?好多神奇的算法呀，可是像我一样小萌新什么都不会怎么办呢？

那就**模拟**吧！**本题唯一一篇最裸的模拟题解就此诞生！！**

众数，故名思议就是出现最多的次数，而一个数出现只会存在于a和a^b中。我们用vis数组记录一下各个数的出现次数，然后找出最大的即可。

该思路实现类似于桶排序，1e6的数组显然可以开的下，时间复杂度$O(n)$.

代码：
```cpp
signed main()
{
	int n;
	cin>>n;
	int a,b;
	for(fint i=1;i<=n;i++)
	cin>>a>>b,a!=(a^b)?(vis[a]++,vis[a^b]++):vis[a]++;
	int ans=0,now=0;
	for(fint i=1;i<=1e7;i++)
	if(vis[i]>ans)
	ans=vis[i],now=i;
	cout<<now;
	return 0;
}
```
那么，像我一样刚学OI不久的小萌新们，快来AC吧！！！

---

## 作者：d446101 (赞：1)

## 思路

Hash，统计每张牌有多少人有

注意某人两种出牌法结果相同时，该数该人只计一次

## 代码

语言：Ruby

```ruby
#C:\Ruby26-x64\bin -w
# -*- coding: UTF-8 -*-
n = gets.to_i

H = Hash.new(0)

for i in 0..n-1
    l, r = gets.split.map(&:to_i) 
    r ^= l
    H[l] += 1
    if r != l then H[r] += 1 end
end
max = 0
ans = 1000000000
H.each_key{|i|
    if H[i] > max then
        max = H[i]
        ans = i
    end
    if (H[i] == max) and (i < ans) then
        ans = i
    end
}
puts ans
```

---

## 作者：questRush (赞：0)

#### 题目分析

为了获取众数，我们需要先统计每个同学所有可能的出牌情况，计算每种情况的出现频数，频数最大者中的最小值即为所求。因为每个同学会可能会打出一张红牌或两张牌的异或，因此可以分成两种子情况进行处理：

*	如果该同学打出的的红牌和两张牌的异或值不同，则需要分别统计。

*	如果该同学打出的的红牌和两张牌的异或值相同，只统计一次。

所以：

*	为了做到统计时的快速访问和更新频数，这里采用哈希表进行存储。
*	哈希表的实现可以采用 $std::unordered\_map$ 或者 $\_\_gnu\_pbds::gp\_hash\_table$，这里采用后者。
*	为了避免异或值超过 $int$ 范围，这里采用 $long\ long$。
*	这里可以采用 Codeforces 的防 hack 哈希函数减少特殊输入导致哈希表基本操作时间复杂度降到 $\mathcal{O}(n)$ 的情况，参考来源为 [https://codeforces.com/blog/entry/62393](https://codeforces.com/blog/entry/62393)。
*	为了获取频数最大者中的最小值，我们需要在统计出最大频数后进行一遍线性检查。
*	为了避免可能出现的卡常，可以加上快速输入输出。

#### 代码

*	代码采用 C++17 标准编译并开启 O2 优化。

```cpp
#include <bits/extc++.h>

using namespace std;
using namespace __gnu_pbds;
using ll = long long;

namespace IO {
    template<typename T>
    inline void read(T &t) {
        int n = 0;
        int c = getchar_unlocked();
        t = 0;
        while (!isdigit(c)) n |= c == '-', c = getchar_unlocked();
        while (isdigit(c)) t = t * 10 + c - 48, c = getchar_unlocked();
        if (n) t = -t;
    }

    template<typename T, typename... Args>
    inline void read(T &t, Args &... args) {
        read(t);
        read(args...);
    }

    template<typename T>
    inline void write(T x) {
        if (x < 0) x = -x, putchar_unlocked('-');
        if (x > 9) write(x / 10);
        putchar_unlocked(x % 10 + 48);
    }

    template<typename T>
    inline void writeln(T x) {
        write(x);
        putchar_unlocked('\n');
    }
}

// Reference: https://codeforces.com/blog/entry/62393
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

gp_hash_table<ll, int, custom_hash> freq;

int main() {

    int n;
    IO::read(n);
    ll a, b, temp;
    while (n--) {
        IO::read(a, b);
        ++freq[a];
        temp = a ^ b;
        if (temp != a) {
            ++freq[temp];
        }
    }
    int max_freq = -1;
    for (const auto &[k, v] : freq) {
        max_freq = max(max_freq, v);
    }
    ll min_val_with_max_freq = numeric_limits<ll>::max();
    for (const auto &[k, v] : freq) {
        if (v == max_freq) {
            min_val_with_max_freq = min(min_val_with_max_freq, k);
        }
    }
    IO::writeln(min_val_with_max_freq);
    return 0;
}
```

---


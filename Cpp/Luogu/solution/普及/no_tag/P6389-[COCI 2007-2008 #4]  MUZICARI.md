# [COCI 2007/2008 #4]  MUZICARI

## 题目描述

在一场音乐会上，一支有 $n$ 名乐师的乐队共连续演奏 $t$ 分钟，但每名乐师都有自己想要休息的时长。对于第 $i$ 名乐师，他想休息 $a_i$ 分钟。但为了整体的和谐，不能有**三个及以上**的乐师在同一个时刻休息（但是可以在上一个乐师刚刚结束的时刻开始下一个人的休息）。

请你安排每名乐师开始休息的时刻。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le t\le 5000$，$1\le n\le 500$。
#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #4](https://hsin.hr/coci/archive/2007_2008/contest4_tasks.pdf) *T4  MUZICARI***。

## 样例 #1

### 输入

```
8 3
4 4 4```

### 输出

```
0 2 4```

## 样例 #2

### 输入

```
10 5
7 5 1 2 3```

### 输出

```
3 3 9 0 0```

# 题解

## 作者：MspAInt (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6389)

装箱问题加强版。

题面貌似有问题，应该要求所有乐师的开始休息时刻之和最小？

------------

将乐师的休息时长视为物品重量，那么我们要把“箱子”尽量装满。

因为同一时刻只能有两个乐师休息，所以有两个箱子。先考虑一个箱子，$dp_i$ 表示**总共最多**休息 $i$ 分钟的情况下，允许某些乐师休息的最长时间和。

易得方程：`dp[i]=max(dp[i],dp[i-a[i]]+a[i])`，显然一个乐师休息完紧接着下一个休息是最优的。

开一个 `vector` 记录转移过程，然后求一下每个休息完的乐师开始休息的时间。

不被包含在第一个箱子的最优解里的乐师要放到第二个箱子。此时只能一个接一个直接休息。

Code：

```cpp
#include<bits/stdc++.h>
#define inf 1e9
using namespace std;
const int N=5e2+10,M=5e3+10;
int n,m,a[N],dp[M],res[N],tim;
vector<int>e[M];
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	memset(res,0x3f,sizeof(res));
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		for(int j=m;j>=a[i];j--)
			if(dp[j]<dp[j-a[i]]+a[i]){
				dp[j]=dp[j-a[i]]+a[i];
				e[j]=e[j-a[i]];e[j].push_back(i);
			}
	for(int i=0;i<e[m].size();i++){
		res[e[m][i]]=tim;
		tim+=a[e[m][i]];
	}tim=0;
	for(int i=1;i<=n;i++){
		if(res[i]>inf)res[i]=tim,tim+=a[i];
		printf("%d ",res[i]);
	}
    return 0;
}
```

[record](https://www.luogu.com.cn/record/107929784)

---

## 作者：Estar_Mailyn (赞：4)

**前言：** 膜拜题解区 DP 大佬，蒟蒻只会简单的 DFS。不过没有想到 DFS 跑得这么快，还混了个最优解。

### 题意简化：

[Link](https://www.luogu.com.cn/problem/P6389)

&emsp; $n$ 个需要休息不同时间的人需要在 $t$ 分钟内休息完，只有两个房间可以提供休息，求合理的休息方案。
### 思路：

&emsp;本着节约时间的思想，一个人休息完后，另一个人就立刻休息。那现在我们纠结的不是休息的顺序， **而是一个人应该去哪个房间的问题。** 这就可以 DFS 枚举每个人选择的情况啦。

**code**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int a[N];
int n,t;
int sum;
int ans[N];
bool flg=0;
void print()
{
	int s1=0;
	int s2=0;
	for(int i=1;i<=n;i++)
	{
		if(ans[i]==1)
		{
			printf("%d ",s1);
			s1+=a[i];
		}
		if(ans[i]==2)
		{
			printf("%d ",s2);
			s2+=a[i];
		}
	}
	flg=1;
}
void dfs(int x,int s1,int s2)
{
	if(flg==1)return;//只需要一种足矣
	if(s1>t||s2>t)return;//常用剪枝之可行性剪枝
	if(x==n+1)
	{
		if(s1+s2==sum) print();
		else return;
	}	
	for(int i=1;i<=2;i++)
	{
		ans[x]=i;
        //枚举每个人的选择
		if(i==1) dfs(x+1,s1+a[x],s2);
		if(i==2) dfs(x+1,s1,s2+a[x]);
	}
}
int main()
{
	scanf("%d%d",&t,&n);
	for(int i=1;i<=n;i++)
	{
		ans[i]=-1;
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	dfs(1,0,0);
	return 0;
}
```

---

## 作者：water_three (赞：3)

~~为什么这么简单的模板题通过这么少。~~

[题目链接](https://www.luogu.com.cn/problem/P6389)

### 前置知识:

动态规划和[装箱问题](https://www.luogu.com.cn/problem/P1049)。

#### 思路：
将休息室抽象成两个箱子，休息时间抽象成物品的体积。问题成了求一个将所有物品装进两个箱子的方案。

我们称一个箱子价值发挥到最大，当且仅当将所有物品放进去都装不满**或者**它的剩余空间是所有可能情况中最小的。

那因为有解，所以先尽可能将所有物品塞进一个箱子，**使得这个箱子剩余的空间最小。这样可以使得这个箱子利用价值发挥到最大**。然后剩下的物品放另外一个箱子。

因为第一个箱子的价值已经发挥到最大了，如果第二个箱子都放不进去，那么原数据无解。


### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[70001],ant,n,t,w[70001],ans[70001];
vector<long long>dd[70001];//记录箱子的编号
int main(){
	memset(ans,-1,sizeof ans);
    cin>>t>>n;
    for(long long i=1;i<=n;i++){
       cin>>w[i];
    }
    for(int i=1;i<=n;i++){
	    for(int j=t;j>=w[i];j--){//DP求解                       
	        if(f[j]<f[j-w[i]]+w[i]){
	            f[j]=f[j-w[i]]+w[i];
				dd[j]=dd[j-w[i]],dd[j].push_back(i);
	        }
	    }
	}
    long long now=0;
    for(long long i=0;i<dd[t].size();i++){
       ans[dd[t][i]]=now;
       now+=w[dd[t][i]];
    }
    now=0;
    for(long long i=1;i<=n;i++){
        if(ans[i]==-1)ans[i]=now,now+=w[i];
    }
    for(long long i=1;i<=n;i++)cout<<ans[i]<<" ";
    return 0;
}
```


---

## 作者：LHQing (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P6389)

#### 题目分析

对题意进行一步转化：将乐师分为两组，每一组的总休息时长都不超过 $t$。

使用动态规划进行处理。记录 $dp_{i,j}$ 表示前 $i$ 个乐师，第一组休息总时间为 $j$ 的可达性。

为了记录转移，$dp_{i,j}$ 表示从 $dp_{i-1,dp_{i,j}}$ 转移而来。

转移时从小到大加入乐师，枚举第一组的总休息时长，枚举当前乐师的组别进行转移。具体见代码。

#### 代码

```
#include<iostream>
#include<cstdio>
using namespace std;
int t,n,a[505],sm[505],dp[505][5005];
int ans[505];
void trace(int i,int j)
{
	if(i==0)
	return ;
	if(dp[i][j]==j)
	ans[i]=2;
	else
	ans[i]=1;
	trace(i-1,dp[i][j]);
	return ;
}
int main()
{
	scanf("%d%d",&t,&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	sm[i]=sm[i-1]+a[i];
	//dp[i][j]表示前i个乐师，第一组休息总时间为j的可达性 
	for(int i=0;i<=n;i++)
	for(int j=0;j<=t;j++)
	dp[i][j]=-1;
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		//放置在第一组 
		for(int j=a[i];j<=sm[i]&&j<=t;j++)
		if(sm[i]-j<=t)
		if(dp[i-1][j-a[i]]!=-1)
		dp[i][j]=j-a[i];
		//放置在第二组 
		for(int j=0;j<=sm[i]-a[i]&&j<=t;j++)
		if(sm[i]-j<=t)
		if(dp[i-1][j]!=-1)
		dp[i][j]=j;
	}
	for(int i=0;i<=sm[n]&&i<=t;i++)
	if(dp[n][i]!=-1)
	{
		trace(n,i);
		break;
	}
	//此时的ans[i]代表乐师i休息的组别 
	int tar1=0,tar2=0;
	for(int i=1;i<=n;i++)
	{
		if(ans[i]==1)
		{
			ans[i]=tar1;
			tar1+=a[i];
		}
		else
		{
			ans[i]=tar2;
			tar2+=a[i];
		}
	}
	for(int i=1;i<=n;i++)
	printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 题目描述

[[COCI2007-2008#4] MUZICARI](https://www.luogu.com.cn/problem/P6389)

## 算法思路

### 算法：DP（其实搜索也能过）

#### 状态表示：

##### 集合：$dp_i$ 表示总共最多休息 $i$ 分钟的情况下，允许一些乐师休息的最长时间和。

##### 属性：$\max$

#### 状态计算：

```cpp
dp[j]=max(dp[j],dp[j-a[i]]+a[i]);
```

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//日常开long long 
const ll N=5010,INF=0x3f3f3f3f3f3f3f3f;//INF为无限大 
ll n,m,a[N],dp[N],daan[N],ans;//daan存时间
vector<ll> e[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//输入输出优化 
	memset(daan,0x3f,sizeof(daan));//daan设为无穷大 
	cin>>m>>n;//输入m，n（注意顺序） 
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//输入要休息的时间 
	}
	for(int i=1;i<=n;i++)//dp 
	{
		for(int j=m;j>=a[i];j--)
		{
			if(dp[j]<dp[j-a[i]]+a[i])
			{
				dp[j]=dp[j-a[i]]+a[i];
				e[j]=e[j-a[i]];
				e[j].push_back(i);
			}
		}
	}
	for(int i=0;i<(ll)e[m].size();i++)//更新答案 
	{
		daan[e[m][i]]=ans;
		ans+=a[e[m][i]];
	}
	ans=0;
	for(int i=1;i<=n;i++)//更新答案，并输出 
	{
		if(daan[i]==INF)
		{
			daan[i]=ans;
			ans+=a[i];
		}
		cout<<daan[i]<<" ";
	}
	cout<<"\n";
	return 0;
}
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6389)

#### 前置知识：

01 背包和记录路径。

#### 思路：

和题解区两位大佬的思路一样，我们可以把这个题拟成一个装箱问题，休息室是两个箱子，乐师是物品，先将一个箱子的**价值发挥到最大**，即剩余空间最小。在记录这个箱子装了编号为几的物品，剩余没有被标记的物品则放到第二个箱子里。

因为保证有解，所以不用担心无解的情况。

#### 贴贴代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Max=5001;
ll a[Max],t,n,f[Max],path[Max][Max]; 
// path 记录路径 
ll now,ans[Max],last,p;
int main(){
	scanf("%lld%lld",&t,&n);
	for(ll i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(ll i=1;i<=n;i++)
		for(ll j=t;j>=a[i];j--)
			if(f[j-a[i]]+a[i]>f[j])
				f[j]=f[j-a[i]]+a[i],path[i][j]=1; // 标记 
	for(ll i=n,j=t;i>=1&&j>=1;i--)
		if(path[i][j]){
			ans[i]+=last+ans[now];
			// last 上一个人休息的时间
			// ans[now]  上一个人休息开始的时间 
			now=i;last=a[i];j-=a[i];a[i]=-1;
			// a[i] 的价值用完了，在标记这是第一个箱子的物品 
		}
	for(ll i=1;i<=n;i++)
		if(a[i]==-1) printf("%lld ",ans[i]); //第一个箱子 
		else printf("%lld ",p),p+=a[i]; // 第二个箱子 
	return 0;
}

```


---

## 作者：Kobe_BeanBryant (赞：1)

### 题目大意：
在一个有 $ n $ 位乐师的乐队，他们受到了神秘人的邀请，花重金使乐队进行演奏。乐队为了得到这些奖金务必演奏 $ t $ 分钟，但每位乐师都有自己想要摸鱼的时长 $ a_i $，请你输出每位乐师开始摸鱼的时间。
### 要求：
1. 必须满足每位乐师所需摸鱼的时长。
2. 同一时间内，最多**两位**乐师一起摸鱼，否则会被发现。
3. 每位乐师都想要在上班时间摸鱼，即在 $ t $ 分钟内摸鱼。

### 思路：
1. 首先把休息室想象成两个箱子，休息时间想象成物品的体积。
2. 然后问题就变成求将所有物品装进两个箱子的方案。
3. 我们要箱子价值发挥到最大，而将所有物品都放进去却装不满或它的剩余空间是所有可能情况中为最小的。
4. 我们先尽可能的将所有物品放进一个箱子，使得这个箱子剩的空间最小。
5. 然后剩下的物品放进另一个箱子里。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n;
long long f,ans,cnt;
long long a[5005],b[5005],c[5005][5005],k[5005];
int main(){
	scanf("%lld%lld",&t,&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	
	for(int i=1;i<=n;i++)
	for(int j=t;j>=a[i];j--)
		if(b[j-a[i]]+a[i]>b[j]) b[j]=b[j-a[i]]+a[i],c[i][j]=1;
		
	while(i>=1 && j>=1){
		int i=n,j=t; 
		if(c[i][j]){
			k[i]+=cnt+k[ans];
			ans=i;
			cnt=a[i];
			j-=a[i];
			a[i]=-1;
		}
		i--;
	}	
	
	for(int i=1;i<=n;i++)
		if(a[i]==-1) printf("%lld ",k[i]); 
		else printf("%lld ",f),f+=a[i];
	return 0;
}

```

---

## 作者：hjqhs (赞：0)

前置问题：[装箱问题](https://www.luogu.com.cn/problem/P1049)。  
将休息区当做背包，休息时间当做物品的体积和价值，原题就转化成了背包问题。  
有两个休息区。将其中一个休息区价值发挥到最大，直到装不下位置。由于体积和价值是一样的，所以动态转移方程是 $f_i=\max({f_i,f_{i-v_i}+v_i})$，同时标记所有放进第一个休息区的乐师，把剩下没有被标记的乐师安排到另一个休息区。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int a[N],t,n,f[N],path[N][N]; 
int now,tim[N],last,p;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>t>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<=n;++i){
		for(int j=t;j>=a[i];--j){
			if(f[j]<f[j-a[i]]+a[i]){
				f[j]=f[j-a[i]]+a[i];
				path[i][j]=1;
			}
		}
	}
	int curx=n,cury=t;
	while(curx>=1&&cury>=1){
		if(path[curx][cury]){
			tim[curx]+=last+tim[now];
			now=curx;last=a[curx];cury-=a[curx];a[curx]=114514;
		}
		--curx;
	}
	for(int i=1;i<=n;++i)
		if(a[i]==114514)cout<<tim[i]<<' '; 
		else cout<<p<<' ',p+=a[i]; 
	return 0;
}
```

---

## 作者：Dangerou (赞：0)

## 分析：
说人话版题意——给定一串数字，将这些数字分为两组，使得每一组的和不超过 $t$。

当每一组由哪些数构成已经确定时，这组数中的每个数的位置就变的无关紧要了（因为和是不变的），因此只找出一组合法分配即可。

当一个乐师休息完后，紧接着下一个乐师开始休息是最优的。

由于 $n$ 最多只有 $500$，所以考虑深搜 $+$ 剪枝:

1. 当一组数的总值大于 $t$ 时，当前分配方案已不可能为合法解，直接返回。
2. 当已经出现一组合法解时，跳出深搜。

注意：
1. 一个乐师不能在演奏结束后仍在休息。
2. 乐师可以从第 $0$ 时刻开始休息，但演奏是从第 $1$ 时刻开始的，所以越界返回条件为某一组数的和大于 $t$。

### Code
```
#include<iostream>
#include<cstdio>
using namespace std;
int t,n;
bool flag;//记录是否已经出现合法解
int a[505];
int ans[505];//记录该乐师被分配到哪一组
void dfs(int now,int sum1,int sum2)
{
	if(sum1>t||sum2>t) return;//当任意一组数的和大于t时，当前解一定不合法，返回
	if(now==n+1)
	{
		flag=1;
		return;
	}
	ans[now]=1;
	dfs(now+1,sum1+a[now],sum2);//把当前乐师分到第1组
	if(flag==1) return;//当存在已经合法解时，不必继续搜索下去
	ans[now]=2;
	dfs(now+1,sum1,sum2+a[now]);//把当前乐师分到第二组
	return;
}
int main()
{
	scanf("%d%d",&t,&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	dfs(1,0,0);//搜索一次就够了，因为没必要考虑顺序
	int suma=0,sumb=0;//suma记录第一组乐师总共已经休息了多少时间，sumb记录第二组乐师总共已经休息了多少时间
	for(int i=1;i<=n;i++)
	{
		if(ans[i]==1)
		{
			printf("%d ",suma);
			suma+=a[i];
		}
		if(ans[i]==2)
		{
			printf("%d ",sumb);
			sumb+=a[i];
		}
	}
	return 0;
}
```

---


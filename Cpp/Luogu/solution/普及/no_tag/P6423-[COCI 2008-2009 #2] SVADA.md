# [COCI 2008/2009 #2] SVADA

## 题目描述

当地的动物园已经获得了一个大型开放式花园，动物可以像在其自然栖息地中那样随意移动，并以平常的恶作剧来招待游客。

最受欢迎的动物是猴子。随着他们的攀登，跳跃和其他坎，他们使老老游客都感到高兴。

一种猴子专门研究爬高大的树木和摘椰子。另一种专门研究它们的开放性。
有 $n$ 只第一种猴子（编号 $1$ 到 $n$）和 $m$ 种第二种猴子（编号 $1$ 到 $m$）。

第一种猴子的第 $k$ 只需要 $A_k$ 秒才能在树上找到一个好地方，然后摘下第一个椰子。之后，猴子每 $B_k$ 秒产生一个新的椰子。

第二种猴子的第 $k$ 只需要 $C_k$ 秒的时间才能找到打开椰子的好工具，然后打开第一个椰子。之后，猴子每 $D_k$ 秒打开另一个椰子。

不幸的是，第二种猴子非常具有攻击性，因此这两种类型可能不会同时出现在花园中。因此，动物园管理员会在第一类猴子摘下所有椰子后立刻赶走它们。类似地，如果打开所有椰子后，相同类型的猴子停留时间过长，则会发生争斗。因此，动物园管理员将在它们打开所有椰子后将它们送走。

动物园管理员需要在所有椰子都被采摘后立即到达，然后在猴子将它们全部打开后立即返回。猴子进入或离开花园所需的时间也很小。

Tomislav 特别喜欢第二种猴子，但到来时总是看不见它们。请帮助他计算第二种猴子到达的时间（他知道猴子在花园里度过的总时间，但不知道花园里椰子的数量）。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $1 \leq t \leq 1 \times 10^9,1 \leq n,m \leq 100,1 \leq A_k,B_k,C_k,D_k \leq 1 \times 10^9$。
#### 说明
#### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) SVADA，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
12
1
3 1
1
5 1```

### 输出

```
5```

## 样例 #2

### 输入

```
20 
2
3 2
1 3
3
3 1
4 1
5 1```

### 输出

```
13```

# 题解

## 作者：Autream (赞：4)

#### 题意简述
有两种猴子，第一种会摘椰子，第二种会开椰子。


摘椰子的猴子有 $n$ 只，需要先用 $a_i$ 秒找椰子，再用 $b_i$ 秒摘椰子。


开椰子的猴子有 $m$ 只，需要先用 $c_i$ 秒找工具，再用 $d_i$ 秒开椰子。


现给你一个正整数 $t$，为摘椰子的猴子与开椰子的猴子所用的时间和，求在什么时候开的椰子数量等于摘的椰子的数量。

---
#### 题目分析
首先观察数据范围：$1 \leq t \leq 1 \times 10^9$，枚举不行，考虑二分答案。


枚举“开的椰子数量等于摘的椰子的数量”的时刻 $x$。


直接模拟过程，最后判断开的椰子和摘的椰子大小关系即可。
```cpp
bool check(int x){
	int cnt1=0,cnt2=0;
	for(int i=1;i<=n;i++){//n只猴子同时进行，记录每只猴子开的数量
		if(x>=a[i]){
			cnt1+=(x-a[i])/b[i]+1;//使用a[i]的时间找椰子，剩余(x-a[i])的时间每b[i]秒开一个
		}
	}
	for(int i=1;i<=m;i++){
		if(t>=x+c[i]){//摘椰子用了x秒
			cnt2+=(t-x-c[i])/d[i]+1;//使用c[i]的时间找工具，剩余(t-x-c[i])的时间每d[i]秒开一个
		}
	}
	return cnt1-cnt2>0;//摘的椰子>开的椰子
}
```

---

## 作者：NDFS (赞：4)

虽然第一种猴子摘下的椰子数量是不知道的，但第二种猴子在剩下的时间内肯定要开完所有椰子。所以我们考虑找一个时间分割点 $x$：

- 前段时间第一种猴子能摘多少就摘多少，这就可以计算出来有多少椰子:$\sum_{i=1}^n (x-A_i)/B_i+1$
- 后段时间第二种猴子能开多少就开多少，这也可以计算出来:$\sum_{i=1}^m (t-x-C_i)/D_i+1$

只要全部都能开完，这个分割点就是合法答案。很显然可以通过二分来找这个点，注意二分细节。
总的时间复杂度 $O((n+m)·\log_2 t)$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int t,n,m,a[105],b[105],c[105],d[105];
int l,r,mid;
bool pd(int num)
{
	int sum=0;
	for(int i=1;i<=n;i++)if(num>=a[i])sum+=(num-a[i])/b[i]+1;
	for(int i=1;i<=m;i++)if(t-num>=c[i])sum-=(t-num-c[i])/d[i]+1;
	if(sum>0)return 1;
	else return 0;
}
int main()
{
	scanf("%d",&t);
	scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);
	scanf("%d",&m);for(int i=1;i<=m;i++)scanf("%d%d",&c[i],&d[i]);
	l=1,r=t;
	while(l<r)
	{
		if(pd(mid=l+r>>1))r=mid-1;
		else l=mid+1;
	}
	while(pd(l))l--;//最后需要再判断一下
	printf("%d",l);
	return 0;
}

```

---

## 作者：2022xsj (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6423)

## 形式化题意：
已知一个正整数 $t$ 长度为 $n$ 的数组 $a$ 和 $b$ ，长度为 $m$ 的数组 $c$ 和 $d$ ，找到一个正整数 $x$ $(0 \le x \le t)$ ，使得下列式子成立：\
\
$
\operatorname{f_1}(i)=\begin{cases}\lfloor\frac{x-a_i}{b_i}\rfloor+1 & x \ge a_i \\
0 & x <a_i
\end{cases}\\
$\
$
\operatorname{f_2}(i)=\begin{cases}\lfloor\frac{t-x-c_i}{d_i}\rfloor+1 & t-x \ge a_i \\
0 & t-x <a_i
\end{cases}\\
$\
$
\sum_{i=1}^{n}\operatorname{f_1}(i)=\sum_{j=1}^{m}\operatorname{f_2}(j)
$ 

------------
## 解题思路
### 首先，确定我们的思路和算法
题目让我们求解 $t$ ，我们看到 $t$ 的范围是 $1\le t\le1\times10^9$，无法枚举，只能使用二分法。但是如果要使用二分，必须找到题目的单调性。这道题的单调性是：摘椰子的数量随 $t$ 的增加而增加，而开椰子的数量随 $t$ 的增加而减少。我们要求的情况是开椰子的数量等于摘椰子的数量，那么这个时候 $t$ 就具有了单调性。
### 然后，确定二分的对象和范围
在这道题中我们的求解目标是 $t$，所以很明显二分对象就是它，范围就是 $0$ 到 $t$。时间复杂度 $O(\log_2{t})$。
### 接着，确定 `check` 函数怎么写
这道题的 `check` 函数很简单，只需要判断 $\operatorname{f_1}(i)$ 和 $\operatorname{f_2}(i)$ 的大小关系即可。时间复杂度 $O(n+m)$。
### 最后就是代码啦
`check` :
```cpp
bool check(int x){
    int f1=0,f2=0;
	
    for(int i=0;i<n;i++) f1+=(x-a[i]<0)?0:((x-a[i])/b[i]+1);
    for(int i=0;i<m;i++) f2+=(t-x-c[i]<0)?0:((t-x-c[i])/d[i]+1);
	
    return f1>f2;
}
```

二分代码：

```cpp
int l=0,r=t;

while(l+1<r){
    int mid=(l+r)>>1;
    if(check(mid)) r=mid;
    else l=mid;
}
```
总时间复杂度为 $O((n+m)\log_2t)$，[可过](https://www.luogu.com.cn/record/166790740) 。

---

## 作者：xw_qwq (赞：1)

## P6423 [COCI2008-2009#2] SVADA
[题目传送门](https://www.luogu.com.cn/problem/P6423)

### 题目思路
题目的求解是目标开的椰子数量等于摘的椰子数量的时刻，看到 $t$ 恐怖的数据范围，且 $t$ 具有单调性，果断采用二分。

check 函数很简单，按题意模拟即可，最后返回摘的数量是否大于开的数量，是的话 $r = mid$，否则 $l = mid + 1$，最后输出 $l - 1$ 即可。
### code

```cpp
#include <iostream>
using namespace std;
int a[105], b[105], c[105], d[105];
int t, n, m;
bool check(int x) // 判断
{
	int s1, s2;
	s1 = s2 = 0;
	for (int i = 1; i <= n; i++) //摘的数量
		if (x >= a[i])
			s1 += (x - a[i]) / b[i] + 1; 
	for (int i = 1; i <= m; i++) //开的数量
		if (t - x >= c[i])
			s2 += (t - x - c[i]) / d[i] + 1;
	return s1 > s2; //返回
}
int main()
{
	cin >> t >> n; //输入
	for (int i = 1; i <= n; i++)
		cin >> a[i] >> b[i];
	cin >> m;
	for (int i = 1; i <= m; i++)
		cin >> c[i] >> d[i];
	int l = 1, r = t;
	while (l < r) //二分
	{
		int mid = l + r >> 1;
		if (check(mid))
			r = mid;
		else
			l = mid + 1;
	}
	cout << l - 1; //输出
	return 0; //美妙的结尾~
}

```

---

## 作者：YangXiaopei (赞：1)

## Solution:

容易发现，有一个分界点，一边生产的多，一边开的多。

而 $t$ 显然不是枚举能胜任的，考虑二分。

`check` 函数也很好写。直接算即可。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, m, a[10005][2], b[10000][2];
bool check(int x) {
	int sum = 0;
	for(int i = 1; i <= n; i++) {
		if(a[i][0] <= x) {
			sum += (x - a[i][0]) / a[i][1] + 1;
		}
	}
	for(int j = 1; j <= m; j++) {
		if(b[j][0] <= t - x) {
			sum -= (t - x - b[j][0]) / b[j][1] + 1;
		}
	}
	return sum > 0;
}
int main() {
	cin >> t >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i][0] >> a[i][1];
	}
	cin >> m;
	for(int i = 1; i <= m; i++) {
		cin >> b[i][0] >> b[i][1];
	}
	int l = 1, r = t;
	while(l + 1 <r){
		int mid = (l + r) >> 1;
		if(check(mid)){
			r = mid;
		}
		else{
			l = mid;
		}
	}
	cout << l;
	return 0;
}
```

---

## 作者：seika27 (赞：1)

### 题意
有一群猴子。

其中 $n$ 只猴子可以摘椰子。

还有 $m$ 只猴子可以开椰子。

对于摘椰子的猴子，它们需要花 $A_i$ 秒找到一个摘椰子的地方，然后摘下一个椰子。接下来，它们每 $B_i$ 秒摘下一个椰子。

对于开椰子的猴子，它们需要花 $C_i$ 秒找到一个开椰子的工具，然后打开一个椰子。接下来，它们每 $D_i$ 秒打开一个椰子。

需要注意，猴子找到摘椰子或开椰子的工具后，会立马摘下或打开一个椰子。

已知这两种猴子不能同时存在，且它们一共工作了 $t$ 秒。

请你找出一个时间点，让摘下的椰子被开完。

### 分析
看到 $t$ 是 $10^9$ 量级的，果断选择二分。

对于时间点，模拟出开的椰子与摘的椰子，进行对比即可。

具体坑点见代码。

### code
```cpp
#include <bits/stdc++.h>
#define int long long 
#define cin std::cin
#define cout std::cout
const int N=1e3+3;
int t;
int n,m;
int a[N],b[N],c[N],d[N];
int check(int x)
{
	int res=0,cnt=0;
	for(int i=1;i<=n;i++)
	{
		int y=x-a[i];
		if(y<0)continue;
		res+=y/b[i]+1;		//这里加1的原因是，找到地方后，猴子会马上摘一个椰子
	}
	for(int i=1;i<=m;i++)
	{
		int y=c[i]+x;
		if(t<y)continue;
		res-=(t-c[i]-x)/d[i]+1;		//同上
	}
	return res>0;
}
signed main()
{
	cin>>t>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>c[i]>>d[i];
	}
	int l=1;
	int r=t;
	while(l<=r)				 //进行二分
	{
		int mid=(l+r)>>1;
		if(check(mid))r=mid-1;
		else l=mid+1;
	}
	cout<<r;
	return 0;		//结束
}
```


---

## 作者：conti123 (赞：1)

### 分析
题目说的有点绕，但读懂题意后还是很简单的。

题意：有 $n$ 只猴子能生产椰子，有 $m$ 只猴子能开椰子，一共生产/开了 $t$ 秒的椰子，找出一个分界点，使得分界点前生产的椰子 $=$ 分界点后开的椰子。

一看数据 $1 \le t \le 1\times 10^9$，肯定是二分了，于是我们在考虑怎么计算生产和开的椰子数。

生产的椰子个数很容易得出为每个猴子生产的椰子个数总和。

即：
```cpp
	for(int i=1;i<=n;i++)
		if(x>=a[i])
			cnt+=(x-a[i])/b[i]+1;
```

那么开的椰子数也很容易得出：
```cpp
for(int i=1;i<=m;i++)
		if(t>=c[i]+x)
			cnt-=(t-x-c[i])/d[i]+1;
```
最终看 cnt 是否大于 $0$ 即可二分枚举了。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+1;
int t,n,m,l,r,a[N],b[N],c[N],d[N];
bool check(int x)
{
	int cnt=0;
	for(int i=1;i<=n;i++)
		if(x>=a[i])
			cnt+=(x-a[i])/b[i]+1;
	for(int i=1;i<=m;i++)
		if(t>=c[i]+x)
			cnt-=(t-x-c[i])/d[i]+1;
	return cnt>0;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	cin>>t>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];
	cin>>m;
	for(int i=1;i<=m;i++)
		cin>>c[i]>>d[i];
	l=1,r=t;
	while(l+1<r)
	{
		int mid=(l+r)>>1;
		if(check(mid))
			r=mid;
		else
			l=mid;
	}
	cout<<l;
	return 0;
} 
```


---

## 作者：Amunet (赞：0)

## 题意：

有 $n$ 只猴子能生产椰子，有 $m$ 只猴子能开椰子，已经工作了 $t$ 秒。

现在请找出一个分界点，使得分界点前生产的椰子数等于分界点后开的椰子数。

## 思路：

一看数据，$1 \leq t \leq 10^9$，果断放弃枚举，开始二分。

椰子的生产总数，只需要注意它会再摘一个，需要 $+1$。

```cpp
for (int i=1; i<=n; i++) {
	if(s>=a[i]) {
		sum+=(s-a[i])/b[i]+1;
	}
}
```

椰子的消耗总数也是同理。

```
for (int i=1; i<=m; i++) {
  if(t-s>=x[i]) {
    sum-=(ans-s-x[i])/y[i]+1;
  }
}
```

最后输出 $sum$ 就可以了。

---

## 作者：QAQ_YTH (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P6423)



------------

本体的题面看似复杂，实则就是说：
- 有 $n$ 只猴子能生产椰子，有 $m$ 只猴子能开椰子，能完成同种工作的猴子一起工作。一共生产或开了 $t$ 秒的椰子。
- 要我们找出一个分界点，当两批猴子在 $t$ 秒换班，生产的椰子 $=$ 分界点后开的椰子。

看看数据点$1\le t \le10^9$，$10^9$ 的数据基本上就是二分没跑了。
### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101;
int t,n,m,a[N],b[N],c[N],d[N],cnt,sum;
bool check(int mid) {
	cnt=0,sum=0;
	for(int i=1; i<=n; i++) {
		if(mid>=a[i])cnt+=(mid-a[i])/b[i]+1;
	}
	for(int i=1; i<=m; i++) {
		if(t>=mid+c[i])sum+=(t-mid-c[i])/d[i]+1;
	}
	cnt-=sum;
	return cnt>0;
}
int main() {
	cin>>t;
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i]>>b[i];
	}
	cin>>m;
	for(int i=1; i<=m; i++) {
		cin>>c[i]>>d[i];
	}
	int l=1,r=t;
	while(l<r) {
		int mid=(l+r)>>1;
		if(check(mid))r=mid-1;
		else l=mid+1;
	}
	cout<<l;
	return 0;
}

```
但上面这段代码仅有 $50$ 分，还过不了样例二。
![](https://cdn.luogu.com.cn/upload/image_hosting/mhgz0zi3.png)所以我们要在末尾加上一段特判：
```cpp
while(check(l))l--;
```
### AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101;
int t,n,m,a[N],b[N],c[N],d[N],cnt,sum;
bool check(int mid) {
	cnt=0,sum=0;
	for(int i=1; i<=n; i++) {
		if(mid>=a[i])cnt+=(mid-a[i])/b[i]+1;
	}
	for(int i=1; i<=m; i++) {
		if(t>=mid+c[i])sum+=(t-mid-c[i])/d[i]+1;
	}
	cnt-=sum;
	return cnt>0;
}
int main() {
	cin>>t;
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i]>>b[i];
	}
	cin>>m;
	for(int i=1; i<=m; i++) {
		cin>>c[i]>>d[i];
	}
	int l=1,r=t;
	while(l<r) {
		int mid=(l+r)>>1;
		if(check(mid))r=mid-1;
		else l=mid+1;
	}
	while(check(l))l--;
	cout<<l;
	return 0;
}

```
~~漂亮的 AC。~~

---

## 作者：Xssion37_XY (赞：0)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P6423)

[更好的阅读体验](https://www.luogu.com.cn/blog/778802/solution-p6423)

### 题目大意

有 $n$ 只猴子能生产椰子，有 $m$ 只猴子能开椰子，已经工作了 $t$ 秒。

现在请找出一个分界点，使得分界点前生产的椰子数等于分界点后开的椰子数。

### 实际分析

数据中 $1 \leq t \leq 1 \times 10^9$，直接用二分。

那么求椰子的生产总数就很好写了。

```
for (int i=1; i<=n; i++) {
		if(x>=a[i]) {
			sum+=(x-a[i])/b[i]+1;
			//别忘了猴子它会接着再摘一个
		}
	}
```

椰子的消耗总数也一样。

```
for (int i=1; i<=m; i++) {
		if(t-x>=c[i]) {
			sum-=(t-x-c[i])/d[i]+1;
			//别忘了猴子它会接着再摘一个
		}
	}
```

### 代码部分

```
#include <iostream>
using namespace std;
const int MAXX = 10001;
int a[MAXX],b[MAXX],c[MAXX],d[MAXX];
int sum;
int t,n,m;
bool check(int x) {
	sum=0;
	for (int i=1; i<=n; i++) {
		if(x>=a[i]) {
			sum+=(x-a[i])/b[i]+1;
			//别忘了猴子它会接着再摘一个
		}
	}
	for (int i=1; i<=m; i++) {
		if(t-x>=c[i]) {
			sum-=(t-x-c[i])/d[i]+1;
			//别忘了猴子它会接着再摘一个
		}
	}
	if(sum>0) {
		return 1;
	}
	return 0;
}
int main() {
	cin >> t >> n;
	for (int i=1; i<=n; i++) {
		cin >> a[i] >> b[i];
	}
	cin >> m;
	for (int i=1; i<=m; i++) {
		cin>>c[i] >> d[i];
	}
	int l=1,r=t;
	int mid=0;
	while(l<r) {
		//二分
		mid = (l+r)/2;
		if(check(mid)) {
			r=mid-1;
		} else {
			l=mid+1;
		}
	}
	cout<<l;
	return 0;
}
```

欸？怎么 $50$ 分捏？

需要在最后判断一下。

```
while(check(l)){
	l--;
}
```


完结撒花！

---


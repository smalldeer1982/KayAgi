# [COCI 2011/2012 #6] ZAGRADE

## 题目描述

给定一个算术表达式，有些部分用括号括起来表示优先级的不同。请你删除一些互相匹配的括号对，并输出所以删除的方案。按照字典序输出。

比如，给定一个算术表达式 `(2+(2*2)+2)`，所有合法的方案为 `(2+2*2+2)` `2+(2*2)+2` `2+2*2+2`。而 `(2+2*2)+2` `2+(2*2+2)` 并不合法，因为删除的括号对不互相匹配。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证给出的算术表达式的长度不超过 $200$，输入仅包含 `+` `-` `*` `/` `(` `)`。

#### 说明

**题目译自 [COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #6](https://hsin.hr/coci/archive/2011_2012/contest6_tasks.pdf) *T3 ZAGRADE***。

## 样例 #1

### 输入

```
(0/(0))```

### 输出

```
(0/0)
0/(0)
0/0```

## 样例 #2

### 输入

```
(2+(2*2)+2)```

### 输出

```
(2+2*2+2)
2+(2*2)+2
2+2*2+2```

## 样例 #3

### 输入

```
(1+(2*(3+4)))```

### 输出

```
(1+(2*3+4))
(1+2*(3+4))
(1+2*3+4)
1+(2*(3+4))
1+(2*3+4)
1+2*(3+4)
1+2*3+4```

# 题解

## 作者：maomao233 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6439)

### 分析

前置芝士：[括号匹配](https://blog.csdn.net/treesorshining/article/details/125828626?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169223579316800222891571%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169223579316800222891571&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125828626-null-null.142^v92^chatsearchT3_1&utm_term=%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D&spm=1018.2226.3001.4187)。

本题的主要思路：

1.使用数据结构栈进行括号匹配。即，当遇到左括号时，入栈；遇到右括号时，则把栈顶弹出并做记录。

2.进行搜索。注意到题面末尾，保证给出的算术表达式的长度不超过 $200$，所以可以直接用状压记录括号的使用情况。具体地，可以使用暴力，统计消去的括号的位置，然后继续将剩余的字符组合为字符串。我们可以将这个字符串放进数组里，方便以后的排序及去重。

3.之后使用深度优先搜索即可。最后可以使用 sort 及 unique 库函数即可对所有字符串进行排序及去重。于是得[代码](https://www.luogu.com.cn/paste/ly4ylvl6)。

---

~~但先别急着抄（~~

一交发现 RE，70 分。~~于是这个彩笔将数组开大然后又 MLE 了。~~

所以我们需要尽可能减少空间。发现瓶颈在于存储字符串，考虑到答案很容易就会重复导致浪费空间。如果我们让传入 dfs 函数里的变量 $x$ 不再重复进行计算，即可大大减少空间。

于是，我们便可以使用记忆化搜索（其实就是一个桶）。设一个桶为 $b$，若 $x$ 未被计算过（即 $b_x=0$），则进行搜索，并将 $b_x$ 赋值为 $1$，代表已经搜索了 $x$；否则说明已经搜索过，无需进行搜索并存储，跳过即可。于是 dfs 函数就可修改为：

```cpp
inline void dfs(int x)
{
	if(b[x])
	{
		return; // 若已经计算过则跳过
	}
	b[x]=1; // 将 x 标记
	if(x)
	{
		sb(x);
	}
	for(int i=1;i<=cnt1;i++)
	{
		if(x&(1<<(i-1)))
		{
			continue;
		}
		dfs(x|(1<<(i-1)));
	}
}
```

得 [AC 记录](https://www.luogu.com.cn/record/121422841)。

---

## 作者：The_Godfather (赞：4)

# Problem

[题目传送门](https://www.luogu.com.cn/problem/P6439)

以下给出我对题意的理解：
- 首先我们对整个字符串的括号做一个匹配。
- 所以我们每次就只能删去有标记的括号。
- 找到后就可以排序，枚举找有几种情况，不断增加最后按字典序输出。

# Solution
前置芝士：[括号匹配](https://blog.csdn.net/treesorshining/article/details/125828626?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169223579316800222891571%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169223579316800222891571&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125828626-null-null.142^v92^chatsearchT3_1&utm_term=%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D&spm=1018.2226.3001.4187)

因为我们对于每个序列，我们由于要按字典序删除，所以我们尽量要保留最外面的左括号，所以我们可以从最里面的一组开始往外面 dfs 之后我们每次找到后就回溯并删除标记当时的一组括号，直到删除所有的括号就结束程序。

但是我们这道题目有一种情况比如：```(2+((2*2))+2)```
这样的话我们就会有一个重复的情况所以我们在搜索的时候还要加上去重。

另外还有一个小技巧：就是我们可以用 ```set``` 来存因为这样即可以去重还可以排序。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fastio ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
namespace Dino {
    const int P = 998244353;
    string s;
    vector<int> p;
    int v[10086];
    set<string> st;
    stack<char> ck;
    int a[10086], cnt=0, b[10086];
    void dfs(int x)
    {
        if(x >= p.size())
        {
            string res = "";
            for(int i=1;i<s.length();++i)
            {
                if(!v[i])
                    res += s[i];
            }
            if(res.length() != s.length())
                st.insert(res);
            return;
        }
        dfs(x + 1);
        int x1 = p[x];
        v[x1] = 1;
        v[a[x1]] = 1;
        dfs(x + 1);
        v[x1] = 0;
        v[a[x1]] = 0;
    }
    auto work = [](){
        cin >> s;
        s = ' '+s;
        int t = s.size();
        for(int i=1;i<=t;++i)
        {
            if(s[i] == '(')
                ck.push(i), p.push_back(i);
            else if(s[i] == ')')
                a[ck.top()]=i,ck.pop();
        }
        dfs(0);
        for(auto &i : st)
            if (i.length() != s.length() - 1)
				cout << i << endl;
    };
}
int main()
{
    fastio;
    return Dino::work(), 0;
}
```

 

---

## 作者：fz20181223 (赞：3)

思路：

先把所有括号的位置记录下来，以 pair 的形式储存。

设共有 $k$ 对括号，则设计状态，即列举 $\sum\limits_{i=1}^{2^k-1}i$ 。这里 $i$ 的二进制中最后第 $p$ 位为 $1$ 则代表去掉第 $p$ 个括号。反之，不去掉第 $p$ 个括号。（因为必须去掉至少一个括号，所以 $i=0$ 不需要考虑）

将所有的答案存入一个 set （因为 set 有排序和去重的功能），最后将 set 里所有的元素依次输出就行了！

**对于 set 的两个注意：**

**1. 访问 set 内元素时必须使用对应的指针！！但是在调用时可以通过在指针前加 `*` 调用，如 `*it` **

**2. set 插入元素用 insert ，而不是 vector 或 queue 的 push(\_back)**

与 @☯☯枫☯☯ 的题解的不一样处在于这个代码可以边记录边去重边排序，而 TA 的题解是在所有的答案算好后进行排序

正解代码（不要抄！）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int err=-120712,N=209;
string st;
vector<pair<int,int> >kh;
string construct(int stat,string st){
	bool ava[N];int pointer=0;
	memset(ava,-1,sizeof(ava));
	while(stat){
		if(stat&1){
			ava[kh[pointer].first]=ava[kh[pointer].second]=0;
		}
		stat>>=1;
		pointer++;
	}//记录保留字节
	string ret;
	for(int i=0;i<st.size();++i)
	if(ava[i]) ret=ret+st[i];//组成答案
	return ret;
}
set<string>ans;
int main(){
	cin>>st;
	vector<int>tmp;
	for(int i=0;i<st.size();++i){
		if(st[i]=='(') tmp.push_back(i);
		if(st[i]==')'){
			kh.push_back(make_pair(tmp[tmp.size()-1],i));
			tmp.pop_back();
		}
	}//记录括号位置
	for(int i=1;i<(1<<kh.size());++i) ans.insert(construct(i,st));//生成答案
	for(set<string>::iterator it=ans.begin();it!=ans.end();++it) cout<<*it<<endl;//输出答案
	return 0;}
```

---

## 作者：zhangzirui66 (赞：2)

看到括号，想到括号匹配，可以使用栈：
```cpp
for(int i = 0; i < n; i ++){
    if(s[i] == '(') st[++ head] = i;
    if(s[i] == ')') b[++ cnt] = make_pair(st[head --], i);//b用来记录每对括号的位置
}
```
输出所有方案可以用 `dfs` 枚举每一对括号是否删除：
```cpp
void dfs(int k){
	if(k == cnt + 1){
		print();
		return;
	}
	a[k] = 1;//删掉
	dfs(k + 1);
	a[k] = 0;//不删
	dfs(k + 1);
}
```
统计答案时按字典序排序，可以用 `set` 排序，还能顺便去重：
```
void print(){
	string now = "";
	bool flag = 0;//如果全部不删，和原来相同，也不可以
	map<int, int> mp;
	for(int i = 1; i <= cnt; i ++){
		if(a[i] == 1) mp[b[i].first] = mp[b[i].second] = flag = 1;
	}
	if(!flag) return;
	for(int i = 0; i < n; i ++){
		if(!mp[i]) now += s[i];
	}
	ans.insert(now);
}
```
最后使用 `for(auto x : ans)` 语句输出即可，完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
set<string> ans;
int a[205], st[205], head, n, cnt, anscnt;
pair<int, int> b[205];
void print(){
	string now = "";
	bool flag = 0;
	map<int, int> mp;
	for(int i = 1; i <= cnt; i ++){
		if(a[i] == 1) mp[b[i].first] = mp[b[i].second] = flag = 1;
	}
	if(!flag) return;
	for(int i = 0; i < n; i ++){
		if(!mp[i]) now += s[i];
	}
	ans.insert(now);
}
void dfs(int k){
	if(k == cnt + 1){
		print();
		return;
	}
	a[k] = 1;
	dfs(k + 1);
	a[k] = 0;
	dfs(k + 1);
}
int main(){
	cin >> s; n = s.size();
	for(int i = 0; i < n; i ++){
		if(s[i] == '(') st[++ head] = i;
		if(s[i] == ')') b[++ cnt] = make_pair(st[head --], i);
	}
	dfs(1);
	for(auto x : ans){
		cout << x << "\n";
	}
	return 0;
}
```
最后，我们就 [AC](https://www.luogu.com.cn/record/175936513) 了。

---

## 作者：☯☯枫☯☯ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6439)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/14932733.html)

**算法分析：记忆化搜索**

~~一道水题。~~

建议难度：黄。

首先利用栈进行括号匹配，遇到左括号入栈，遇到右括号则把栈顶弹出并记录。不多说，代码如下：

```cpp
inline void cot() {
	stack<int> s;
	F(i,1,n) {
		if(c[i]=='(')s.push(i);
		if(c[i]==')')b[++cnt]= {s.top(),i},s.pop();
	}
}
```

然后就是搜索，由于括号数量较少，可以用状压记录使用情况。对于每一种状态，暴力统计消去的括号的位置，然后再暴力将剩余的字符加到一个字符串中。用 string 储存，最终可以直接 sort 排序，在过程中就无需考虑字典序。于是就写完了……

代码如下：

```cpp
#include<bits/stdc++.h>
#define reg register
#define F(i,a,b) for(reg int i=a;i<=b;++i)
using namespace std;
const int N=1e4+10,M=250;
int n,cnt,now;
bool vis[M],meet[N];
char c[M];
struct P {
	int l,r;
} b[N];
string s[N];
inline void cot() {//括号匹配 
	stack<int> s;
	F(i,1,n) {
		if(c[i]=='(')s.push(i);
		if(c[i]==')')b[++cnt]= {s.top(),i},s.pop();
	}
}
inline void inp(int sta) {//暴力组合字符 
	++now;
	F(i,1,cnt) {
		int l=b[i].l,r=b[i].r;
		if(sta&(1<<i-1))vis[l]=vis[r]=1;
	}
	F(i,1,n){
		if(!vis[i])s[now]+=c[i];
		vis[i]=0;
	}
}
void dfs(int sta) {

	if(meet[sta])return;
	meet[sta]=1;//记忆化 

	if(sta)inp(sta);//记录当前状态下的字符串 
	F(i,1,cnt) {//搜索 
		if(sta&(1<<i-1))continue;
		dfs(sta|(1<<i-1));
	}
}
int main() {
	getline(cin,s[0]);
	n=s[0].size();
	F(i,0,n-1)if(s[0][i]!=' ')c[i+1]=s[0][i];
	cot();
	dfs(0);
	sort(s+1,s+now+1);//排序 
	now=unique(s+1,s+now+1)-s-1;//去重 
	F(i,1,now)cout<<s[i]<<endl;
	return 0;
}
```
[AC](https://www.luogu.com.cn/record/52085092)

欢迎交流讨论，请点个赞哦~

---

## 作者：Lydia1010__ (赞：1)

## 本题思路：
这道题我们可以通过栈的方式求出每一对匹配的括号，然后暴力去枚举哪些扩号会被删掉即可。

先说栈，我们从左往右扫，在一个左括号被遍历到时把他所在的编号压入栈中，在遍历到一个右括号时弹出栈顶，即为匹配的一对括号。

## 温馨提示：
删除括号后可能有重复，需要用 map 去重。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct f{int l,r;}a[2005];
int st[2005],top,cnt,jl[2005];
string ans[20005];int cnnt;
string s;
map<string,int>mp;
bool b[2005];
void dfs(int p,int n){
	if(p>n){int sum=0;
		for(int i=1;i<=n;i++){
			if(jl[i]==0){
				sum++,b[a[i].l]=b[a[i].r]=1;
			}
		}
		sum=n-sum;
		if(sum==n){for(int i=1;i<=n;i++){if(jl[i]==0){b[a[i].l]=b[a[i].r]=0;}}return;}
		string t="";
		for(int i=1;i<s.size();i++){if(b[i]==0) t+=s[i];}
		if(mp[t]==0)mp[t]=1,cnnt++,ans[cnnt]=t;
		for(int i=1;i<=n;i++){if(jl[i]==0){b[a[i].l]=b[a[i].r]=0;}}
		return;
	}
	jl[p]=1;dfs(p+1,n);jl[p]=0;dfs(p+1,n);
}
signed main(){cin>>s;int n=s.size();s=' '+s;
	for(int i=1;i<=n;i++){
		if(s[i]=='('){st[++top]=i;}
		if(s[i]==')'){cnt++;a[cnt].l=st[top],a[cnt].r=i,top--;}
	}
	dfs(1,cnt);
	sort(ans+1,ans+1+cnnt);
	for(int i=1;i<=cnnt;i++) cout<<ans[i]<<'\n';
	return 0;
}
/*
(30-((55/(86/14/((90)-35/((95*49)+66/56))))))
(30-((55/(86/14/((90)-35/((95*49)+66/(56)))))))
*/
```

---

## 作者：Chinshyo (赞：1)

# 一句话题意

求所有删除成对匹配的括号的方案。

# 思路

经典括号匹配问题。

如果你没有做过类似题型，也很容易往这方面想。要找匹配的括号，我们会发现后出现的 `(` 会与先出现的 `)` 进行匹配。这就有点像我们所说的栈的性质：“后入栈的先出栈”。

括号匹配的问题一般会用到栈。读入时每遇到一个 `(` 就将该位置入栈，遇到 `)` 就弹栈。弹栈时，栈顶和当前位置就是一对匹配的括号。将栈顶和当前位置标记(我的程序中用 fl 数组标记)。不同的一对括号可以用不同的数字表示 ：


![](https://cdn.luogu.com.cn/upload/image_hosting/y7ncou0y.png)


```cpp
for(int i = 0; i < s.size(); i++) {
 	if(s[i] == '(') sta.push(i);
  	else if(s[i] == ')') {
		fl[i] = fl[sta.top()] = ++n;
		sta.pop();
	}
}
```

接下来，要求出每一种删括号的情况，我们可以暴力枚举。用一个数组标记是否已经被选入。

```cpp
	dfs(i + 1); //不选
	selected[i] = true;
	dfs(i + 1);//选
	selected[i] = false;
```

每对括号都扫描了一遍以后，我们统计答案。将字符串扫一遍，被选上的不要输出，其余的全部输出。

```cpp
void dfs(int i) {
	if(i > n) {
		print();
		return;	
	}
	dfs(i + 1);
	select[i] = true;
	dfs(i + 1);
	select[i] = false;
}
```


但是请注意！！ **不加以剪枝的 DFS 会出现重复的情况**。因此以下写法是错误的。

```cpp
void print() {
	for(int i = 0; i < s.size(); i++) {
		if(!select[fl[i]]) cout << s[i];
	}
	cout << endl;
}
```

输出后你会发现有非常多的重复。这里我们采用 set 去重。同时，这也恰好满足了题目“按照字典序输出”的需求，因为 set 是自动排序的。

### 最后讲个奇妙的东西

在 C++11 中,遍历一个 set 不再需要以往那样定义迭代器，循环第一行写的很长。以下代码可以实现对 $ans$ 进行遍历：

```cpp
for(auto i : ans) {
	cout << i << endl;
}
```

但是请注意虽然这里的 $i$ 也是迭代器，但请不要像以前那样写 `*i`。

# 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[205], sum[205], n = 0, fl[205];
bool selected[205];
string s;
set <string> ans;

void print() {
	string res = "";
	for(int i = 0; i < s.size(); i++) {
		if(!selected[fl[i]]) res += s[i];
	}
	ans.insert(res);
}

bool check() {
	for(int i = 1; i <= n; i++) {
		if(selected[i]) return true;
	}
	return false;
}

void dfs(int i) {
	if(i > n) {
		if(check()) print();
		return;
	}
	dfs(i + 1);
	selected[i] = true;
	dfs(i + 1);
	selected[i] = false;
}

stack <int> sta;

int main() {
	cin >> s;
	for(int i = 0; i < s.size(); i++) {
		if(s[i] == '(') sta.push(i);
		else if(s[i] == ')') {
			fl[i] = fl[sta.top()] = ++n;
			sta.pop();
		}
	}
	dfs(1);
	for(auto i : ans) {
		cout << i << endl;
	}
	return 0;
}


```


---

## 作者：zesqwq (赞：0)

#  P6439 [COCI2011-2012#6] ZAGRADE 题解

~~最优解，嘿嘿~~

[题目传送门](https://www.luogu.com.cn/problem/P6439)

这道题的题目要求你删掉一些匹配的括号，让你按照字典序输出所有删掉后的所有可能的表达式。

我们发现这道题目需要让我们来找匹配括号，这个过程可以使用 **栈** 模拟。遇到做括号就入栈，遇到有括号就和栈顶的左括号匹配，并且出栈。

然后就是 $\text{dfs}$ 这个序列，选择删除或者不删除某一对括号。这样就可以啦。删除这个过程自认为使用 **链表** 较为方便。

最后按照字典序输出的话用 $\text{set}$ 就好啦 $\text{qwq}$。 

$\text{Code:}$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 210;
int st[N], l[N], r[N], nxt[N], n, top;
char s[N];
set<string> t;
string getstr() {
    string ans;
    for (int i = r[0]; i; i = r[i]) ans.push_back(s[i]);
    return ans;
}
inline void del(int x) { l[r[x]] = l[x], r[l[x]] = r[x]; }
inline void rem(int x) { r[l[x]] = x, l[r[x]] = x; }
void dfs(int step, int cnt) {
    if (!step) {
        if (cnt) t.insert(getstr());
        return;
    }
    dfs(r[step], cnt);
    if (s[step] == '(') del(step), del(nxt[step]), dfs(step + 1, cnt + 1), rem(nxt[step]), rem(step);
}
int main() {
    scanf("%s", s + 1), n = strlen(s + 1);
    for (int i = 1; i <= n; i++) {
        if (s[i] == '(') st[++top] = i;
        if (s[i] == ')') nxt[st[top--]] = i;
    }
    for (int i = 0; i <= n; i++) r[i] = i + 1, l[i + 1] = i;
    r[n] = 0, l[0] = n, dfs(1, 0);
    for (set<string>::iterator it = t.begin(); it != t.end(); it++) printf("%s\n", it->c_str());
    return 0;
}
```

---


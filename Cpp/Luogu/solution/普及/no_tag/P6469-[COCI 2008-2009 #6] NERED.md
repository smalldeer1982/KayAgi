# [COCI 2008/2009 #6] NERED

## 题目描述

有一个方阵，方阵每行、每列均有 $n$ 个格子。每个格子上都有一个数，初始时均为 $0$。有 $m$ 次修改，每次会将某个格子上的数 $+1$。

定义一步操作为将某个**非零**格子上的数 $-1$，将另一个格子（可以为 $0$）上的数 $+1$。

请求出最小的操作步数，使得所有格子上的数均为 $0$ 或 $1$，且所有为 $1$ 的格子构成一个矩形。输出操作步数。

## 说明/提示

#### 【样例解释】

**样例 1 解释**

将第 $1$ 行第 $1$ 列减去 $1$，第 $2$ 行第 $1$ 列加上 $1$。

**样例 3 解释**

- 将第 $2$ 行第 $3$ 列减去 $1$，在第 $3$ 行第 $3$ 列加上 $1$。
- 将第 $4$ 行第 $2$ 列减去 $1$，在第 $2$ 行第 $5$ 列加上 $1$。
- 将第 $4$ 行第 $4$ 列减去 $1$，在第 $3$ 行第 $5$ 列加上 $1$。

#### 【数据规模与约定】

对于全部的测试点，保证：

- $1 \leq n \leq 100$，$1 \leq m \leq n^2$。
- $1 \leq x, y \leq n$。
- 输入数据一定存在解。

#### 【说明】

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #6](https://hsin.hr/coci/archive/2008_2009/contest6_tasks.pdf) *T3 NERED***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。

## 样例 #1

### 输入

```
3 2
1 1
1 1
```

### 输出

```
1```

## 样例 #2

### 输入

```
4 3
2 2
4 4
1 1
```

### 输出

```
2```

## 样例 #3

### 输入

```
5 8
2 2
3 2
4 2
2 4
3 4
4 4
2 3
2 3 
```

### 输出

```
3```

# 题解

## 作者：zumgze (赞：3)

### 算法 前缀和+枚举

题意要求最小修改操作次数，可以转化为找一个面积为m的矩形，令其中值为0格子的数目最少

由于我们只知道面积为m，不知道长和宽，所以首先要枚举长宽；然后长宽确定后，再枚举矩形的位置，统计答案

每次统计答案，如果暴力枚举，复杂度将高达$O(m)$。

若我们对每行每列预处理出前缀和，则统计答案的复杂度变为$O(min(length,width))$，预处理复杂度$O(n^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200][200];
int b[200][200];
int main()
{
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		int x,y;
		cin>>x>>y;
		a[x][y]=1;//表示当前格子不为0
		b[x][y]=1;
	}
	for(int i=1;i<=n;i++)//预处理前缀和
		for(int j=1;j<=n;j++)
		{
			a[i][j]+=a[i][j-1];
			b[i][j]+=b[i-1][j];
		}
			
	int ans=m;
	for(int chang=1;chang<=m;chang++)//枚举长宽
	{
		if(m%chang)continue;
		int kuan=m/chang;
		for(int i=1;i+chang-1<=n;i++)//枚举左上角位置
			for(int j=1;j+kuan-1<=n;j++)
			{
				int cnt=m;//用总数减去不为0的格子数
				if(chang>kuan)//统计答案
					for(int jj=j;jj<=j+kuan-1;jj++)
						cnt-=b[i+chang-1][jj]-b[i-1][jj];
				else
					for(int ii=i;ii<=i+chang-1;ii++)
						cnt-=a[ii][j+kuan-1]-a[ii][j-1];
				ans=min(ans,cnt);
			}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Anins (赞：2)

## [[COCI2008-2009#6] NERED](https://www.luogu.com.cn/problem/P6469)

### 思路
看到 $n\le100$ 就知道可以随便折腾。

由题意得，所有格子的权值和为 $m$，那么变换后的矩形的面积也就是 $m$。

对于一个面积为 $m$ 的矩形，将其变为合法矩形所需要的代价为范围内权值为 $0$ 的点的个数，直接枚举所有面积为 $m$ 的矩形即可。

### 优化
考虑到要多次求不定区间内权值为 $0$ 的点的个数，可以使用[前缀和](https://oi-wiki.org/basic/prefix-sum/)优化，这里不再过多赘述。

未优化的时间复杂度约为 $O\left(n^2 \times m^{3/2}\right)$，优化后约为 $O\left(n^2 \times \sqrt{m}\right)$。

因为数据太小，优化的效果不大：

![](https://cdn.luogu.com.cn/upload/image_hosting/6t0f858u.png)

---

### 未优化代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, x, y, k[105][105], sum[105][105], ans=0x3f3f3f;
int main() {
	cin >> n >> m;
	for(int i=1; i<=m; i++) {
		cin >> x >> y;
		k[x][y]++;
	}
	for(int len1=1, len2; len1<=m; len1++) { //枚举长宽
		if(m%len1) continue;
		len2=m/len1;
        //枚举起始点
		for(int x1=1; x1+len1-1<=n; x1++) {
			for(int y1=1; y1+len2-1<=n; y1++) {
				int t=0;
                //统计权值为0的点的个数
				for(int x=x1; x<=x1+len1-1; x++) {
					for(int y=y1; y<=y1+len2-1; y++) {
						if(!k[x][y]) t++;
					}
				}
				ans=min(ans, t);
			}
		}
	}
	cout << ans;
}
```
### 优化代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, x, y, k[105][105], sum[105][105], ans=0x3f3f3f;
int main() {
	cin >> n >> m;
	for(int i=1; i<=m; i++) {
		cin >> x >> y;
		k[x][y]++;
	}
    //求前缀和
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(!k[i][j]);
		}
	}
	for(int len1=1, len2; len1<=m; len1++) { //枚举长宽
		if(m%len1) continue;
		len2=m/len1;
        //枚举起始点
		for(int x1=1, x2; (x2=x1+len1-1)<=n; x1++) {
			for(int y1=1, y2; (y2=y1+len2-1)<=n; y1++) {
				ans=min(ans, sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1]); //更新答案
			}
		}
	}
	cout << ans;
}
```

---

## 作者：Light_az (赞：2)

~~作者墓前精神状态良好~~

### 前缀和优化 & 模拟

看到题意的一瞬间，我们模拟一下样例会发现，由 $1$ 构成的矩阵他的面积是 $m$，原因是无论如何，有一个数减意味着另一个数加，那么它们的和是不变的，又因为这个矩阵由 $1$ 构成，说明它的面积就是 $1$ 的个数，也就是 $m$。

然后对于矩阵的长和宽，我们要保住它能整除 $m$，保住长和宽可以组成一个面积为 $m$ 的矩阵，枚举完长和宽，我们使用循环嵌套来枚举坐标，求出一个矩阵，判断里面有多少个为 $0$ 的点，也就是需要别的数来补上这一部分，当然时间复杂度不允许我们这么做，所以我们使用二维前缀和优化，预处理矩阵的值，最后取一个最小值，就没什么问题了。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for (int i=a;i<=b;i++)
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e7+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=INT_MAX,t=0,l,r,len,T,sum=0;
ll mini=INT_MAX,maxi=0,Mod;
string s1,s2;
ll a[1005][1005],dp[1005][1005];
ll f(ll x1,ll y1,ll x2,ll y2){//去二维前缀和
	return dp[x2][y2]-dp[x1-1][y2]-dp[x2][y1-1]+dp[x1-1][y1-1];
}
int main(){
	Test;
	cin>>n>>k; 
	F(i,1,k){
		cin>>x>>y;
		a[x][y]++;//标记有点
	}
	F(i,1,n){
		F(j,1,n){
			dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+(a[i][j]==0);//二维前缀和
		}
	}
	for(int i=1;i<=k;i++){
		if(k%i==0){
			for(int x=1;x+i-1<=n;x++){
				for(int y=1;y+k/i-1<=n;y++){
					ans=min(ans,f(x,y,x+i-1,y+(k/i)-1));//取最小值
				}			
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：sjr3065335594 (赞：1)

### 题意简述
给定一个 $n \times n$ 的方阵，通过 $m$ 次修改给定初始值。每次操作把一个格子上的数加一，另一个格子上的数减一，问多少次操作可以弄出一个由 $1$ 组成的矩阵并且其余格子均为 $0$。

### 思路
由于方阵初始全部为 $0$，在 $m$ 次修改中每次将一个格子加一，而每次操作中一个格子加一，一个格子减一，所以无论如何操作，方阵里数的总和均为 $m$。那么由 $1$ 组成的矩阵面积也为 $m$。这样题目就可以转换为找一个面积为 $m$ 并且 $0$ 的个数最少的矩阵，因为每次操作可以把矩阵中一个 $0$ 变成 $1$ 。要把矩阵里全部变成 $1$ 就需要矩阵中 $0$ 的个数次操作。

那么怎么求 $0$ 的个数呢？暴力计算的话复杂度是 $O(n^2 m^2)$。很明显不满足要求。这时候我们就要用到[二维前缀和](https://blog.csdn.net/qq_34261446/article/details/104010466)。$O(n^2)$ 统计出每个矩阵中 $0$ 的个数，再枚举每个矩阵的左上角坐标和矩阵的长求最小值即可，复杂度 $O(n^2 m)$。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,s[105][105],a[105][105],ans=100000000;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        a[x][y]++;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(a[i][j]==0)s[i][j]++;//统计每个格子是否为0
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//求前缀和
    for(int i=1;i<=m;i++)//枚举矩阵的长
    {
        if(m%i!=0)continue;//保证面积为m
        int j=m/i;//求出矩阵的宽
        for(int x=1;x+i-1<=n;x++)//枚举矩阵左上角坐标
            for(int y=1;y+j-1<=n;y++)
                ans=min(ans,s[x+i-1][y+j-1]-s[x-1][y+j-1]-s[x+i-1][y-1]+s[x-1][y-1]);//求最小值
    }
    cout<<ans<<endl;//输出
    return 0;
}


```


---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 思路
对于操作，易证权值总和无论怎么操作都不变。

因此，可以将题意转变为找出一个面积为 $m$ 的矩阵，其中还没有方块的地方最少。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[110][110],sum[110][110],ans=2e9;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]++;
	}//存图
	for(int l1=1;l1<=m;l1++){
		if(m%l1)continue;//是否能整除
		int l2=m/l1;
		if(l1>n||l2>n)continue;
		for(int k=1;k<=n-l1+1;k++){
			for(int l=1;l<=n-l2+1;l++){
				int an=0;
				for(int i=1;i<=l1;i++){
					for(int j=1;j<=l2;j++){
						an+=(a[k+i-1][l+j-1]==0);//是否为零
					}
				}
				ans=min(ans,an);//求最小
			}
			
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Andy1101 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P6469)
# 思路
## 题目描述
找 $0$ 的个数为 $0$ 的面积为 $m$ 的矩阵。
## 做法
因为每次操作都是一个数 $+1$，一个数 $-1$，所以矩阵的数字和不变，因此只要找面积为 $m$ 的矩阵就行。

先把输入的坐标标记为 $1$（不为 $0$ 的标记），再用二维前缀和统计 $0$ 的个数。

**二维前缀和公式：**
$$Sum_{i,j} = Sum_{i-1,j} + Sum_{i,j-1} - Sum_{i-1,j-1} + a_{i,j}$$


之后再依次枚举矩阵中的所有子矩阵（枚举左上角和右下角）是否满足要求（子矩阵中没有 $0$）。


**求左上角（$x1,y1$）以及右下角（$x2,y2$）的矩阵元素和公式：**
$$Sum_{x2,y2}-Sum_{x1-1,y2}-Sum_{x2,y1-1}+Sum_{x1-1,y1-1}$$

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100+5;
int a[N][N];
int sum[N][N]; //二位前缀和 
int main()
{
	int n,m;
	cin >>n>>m;
	int t=m;
	while(t--)
	{
		int x,y;
		cin >>x>>y;
		a[x][y]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(!a[i][j]);
		}
	}
	int minans=INT_MAX;
	for(int x1=1;x1<=n;x1++)
	{
		for(int y1=1;y1<=n;y1++)
		{
			for(int x2=x1;x2<=n;x2++)
			{
				for(int y2=y1;y2<=n;y2++)
				{
					int lenx=x2-x1+1;
					int leny=y2-y1+1;
					if(lenx*leny==m)
					{
						int tmp=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
						minans=min(minans,tmp);
					}
				}
			}
		}
	}
	cout <<minans;
	return 0;
}

```

---

## 作者：wunaidedanjuan (赞：0)

### 题意

在一个初始值为 $0$ 的 $n\times n$ 矩阵中进行 $m$ 次操作，使某个点的值加一。定义一次修改为将一个非零点的值减一并给任意一点值加一。求最小修改次数使矩阵仅由 $0$ 和 $1$ 构成，且所有值为 $1$ 的点在一个子矩阵中。

### 思路分析

显然，最后的矩阵中 $1$ 的个数等于 $m$，所以子矩阵的面积为 $m$。由于最后子矩阵中的点值均为 $1$，所以在这个子矩阵中所有点值不为 $1$ 都要进行修改，使其值为 $1$。

一次修改会使一个非零点值减一、一个点加一。将视线聚焦到点值增加的点上，我们会发现，将子矩阵中所有点值修改为 $1$ 的修改次数就等于该子矩阵中 $0$ 的个数。

因此我们可以枚举子矩阵，并统计其中 $0$ 的个数，最后枚举到的最小值即为答案。

### 优化

考虑加一点小小的优化：在统计子矩阵中 $0$ 的个数时运用**二维前缀和**。

### 代码呈现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=110,M=20,inf=0x3f,mod=998244353;
int a[N][N],sum[N][N];
inline void read(int &x)
{
	int d=1;
	char s=getchar();
	x=0;
	while(s<'0'||s>'9')
	{
		if(s=='-')
			d=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=x*10+s-'0';
		s=getchar();  
	}
	x*=d;
	return;
}
signed main()
{
	int n,m,x,y,ans=10000;
	read(n);
	read(m);
	for(int i=1;i<=m;i++)
	{
		read(x);
		read(y);
		a[x][y]++;
	}
	for(int i=1;i<=n;i++)//求二维前缀和 
		for(int j=1;j<=n;j++)
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(a[i][j]==0?1:0);
	for(int l=1;l<=sqrt(m);l++)//枚举矩阵长
	{
		if(m%l!=0)//若m/l不为整数，直接跳过 
			continue;
		for(int i=0;i+l<=n;i++)//枚举矩阵左上点坐标，左上点坐标为(i+1,j+1) 
			for(int j=0;j+m/l<=n;j++)
				ans=min(ans,sum[i+l][j+m/l]+sum[i][j]-sum[i+l][j]-sum[i][j+m/l]); 
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Autumn_Rain (赞：0)

[【原题链接: P6469 [COCI2008-2009#6] NERED】](https://www.luogu.com.cn/problem/P6469)。

- 简明题意：找 $0$ 的个数最少的面积为 $m$ 的矩阵。

因为加一减一，数字和不变，面积只能是 $m$。

我们在读入后更新相应格子使其加一，再用前缀和记录每个区间 $0$ 的个数。以下是二维前缀和公式。

$$S_{i,j}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}$$

统计完前缀和进行修改后，我们还要差分还原回去每个小矩阵中 $0$ 的个数，二维差分公式可由上式推导，不赘述。

由于直接四个循环枚举左上角右上角明显不够优秀，我们可以优化为枚举长宽，这样 $O(n^{4})→ O(n^{3})$。~~以细微优势抢到了最优解。~~

```cpp
#include<cstdio>
using namespace std;
int n,m,i,j,k,x,y;
int a[110][110];
int cf(int x1,int y1,int x2,int y2){
	return a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1];
}
int main(){
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;++i){
		scanf("%d%d",&x,&y);
		a[x][y]=1;
	}
	for(i=1;i<=n;++i){
		for(j=1;j<=n;++j){
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+(a[i][j]==0);
		}
	}
	y=114514;
	for(k=1;k<=m;++k){
		if(m%k!=0)continue;
		for(i=1;i+k-1<=n;++i){
			for(j=1;j+m/k-1<=n;++j){
				x=cf(i,j,i+k-1,j+(m/k)-1);
				if(x<y)y=x;
			}			
		}
	}
	printf("%d",y);
	return 0;
}

```

小剧场。

Q：为什么写这篇题解？

A：因为估值差一点点就到红了（急急急）。

---

## 作者：VitrelosTia (赞：0)

显然数字总和是不变的，永远是 $m$，那么最终的矩阵的大小一定是 $m$。注意到 $n \le 100$，那么我们直接枚举左上角和右下角，预处理二维前缀和记录矩阵内 $0$ 的个数，这就是需要操作的次数，如果矩阵大小是 $m$ 就更新答案。

时间复杂度 $O(n ^ 4)$，跑得飞快。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 105;
int n, m; bool mp[N][N];
int sum[N][N];
int f(int x1, int y1, int x2, int y2) { return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]; }

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	cin >> n >> m;
	for (int i = 1, x, y; i <= m; i++) {
		cin >> x >> y;
		mp[x][y] = true;	
	}
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= n; j++)
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + !mp[i][j];
	int ans = INT_MAX;
	for (int x1 = 1; x1 <= n; x1++)
		for (int y1 = 1; y1 <= n; y1++)
			for (int x2 = x1; x2 <= n; x2++)
				for (int y2 = y1; y2 <= n; y2++) {
					int a = x2 - x1 + 1, b = y2 - y1 + 1;
					if (a * b == m) ans = min(ans, f(x1, y1, x2, y2));
				}
	cout << ans;
	return 0;
}
```

---

## 作者：杨岛主杨东润 (赞：0)

直接开始吧！

### 题目解释：

就是在每一个格子上每一次加一，看最好情况下什么时候可以完成

### 具体解法：

我们先输入，然后进行计算：

第一步，我们先把每一个格子计算一下

接下来，我们用 $b$ 和 $c$ 数组做一下计算

算完之后，我们就计算符合条件的最小值

最后，输出最小值就可以啦！

具体见代码

### 代码Code：

不要抄袭哦！
```cpp
#include<iostream>//头文件 
#include<cmath>//头文件 
using namespace std;
int a[106][106],b[106][106],c[106][106],d[106][106];//数组 
int main()
{
	int m,n;
	cin>>m>>n;//输入 
	int minn=0xffffff;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]++;//这里要++ 
	}
	for(int i=1;i<=m;i++){
	    for(int j=1;j<=m;j++){
	    	if(a[i][j]>1){//如果符合条件就存入b数组 
				b[i][j]=a[i][j]-1;
			}
		}
	}
	for(int i=1;i<=m;i++){
	    for(int j=1;j<=m;j++){
	    	c[i][j]=c[i-1][j]+c[i][j-1]-c[i-1][j-1]+a[i][j];//循环存入c数组 
	    }
	}
	for(int i=1;i<=m;i++){
	    for(int j=1;j<=m;j++){
	    	d[i][j]=d[i-1][j]+d[i][j-1]-d[i-1][j-1]+b[i][j];//循环存入d数组 
	    }
	}
	for(int i=1;i<=n;i++){
		if(n%i>0){//不符合条件就跳过 
			continue;
		}
		int p=n/i;
		for(int j=1;j+i-1<=m;j++){
			for(int l=1;l+p-1<=m;l++){
				int t=c[j+i-1][l+p-1]-c[j-1][l+p-1]-c[j+i-1][l-1]+c[j-1][l-1];
				if(n==t){
					minn=min(minn,d[j+i-1][l+p-1]-d[j-1][l+p-1]-d[j+i-1][l-1]+d[j-1][l-1]);//求最小值 
				}else{
					minn=min(minn,n-(c[j+i-1][l+p-1]-c[j-1][l+p-1]-c[j+i-1][l-1]+c[j-1][l-1])+d[j+i-1][l+p-1]-d[j-1][l+p-1]-d[j+i-1][l-1]+d[j-1][l-1]);//求最小值 
				}
			}
		}
	}
	while(true){
		//不要抄袭 
	}
	cout<<minn; //输出 
    return 0;
} 
```

---

## 作者：zhjzhmh (赞：0)

有一个方阵，方阵每行、每列均有 $n$ 个格子。每个格子上都有一个数，初始时均为 $0$。有 $m$ 次修改，每次会将某个格子上的数 $+1$。

定义一步操作为将某个非零格子上的数 $-1$，将另一个格子（可以为 $0$）上的 $+1$。

**根据上面，可以知道整个矩阵的和是不变的：为$m$（指初始化后）**

**即题目中提到的矩阵面积为$m$**

所以此题可以二维前缀和来解决

### 话不多说，上代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,m,x,y,a[110][110],s[110][110],ss[110][110],b[110][110],j,MIN;
int main()
{
	cin>>n>>m;
	MIN=0x3f3f3f3f;//将初始值附成最大
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		a[x][y]++;
	}
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    if(a[i][j]>1) b[i][j]=a[i][j]-1;//求大于1的格子前缀和
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//二维总和前缀和
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	    ss[i][j]=ss[i-1][j]+ss[i][j-1]-ss[i-1][j-1]+b[i][j];//二维大于1的格子前缀和
	for(int i=1;i<=m;i++)//枚举矩阵长
	{
		if(m%i>0) continue;
		j=m/i;//求矩阵宽
		for(int k=1;k+i-1<=n;k++)
		{
			for(int l=1;l+j-1<=n;l++)
			{
				int t=s[k+i-1][l+j-1]-s[k-1][l+j-1]-s[k+i-1][l-1]+s[k-1][l-1];//二维方阵和(起点(k,l)，终点(k+i-1,l+j-1))
				if(m==t) MIN=min(MIN,ss[k+i-1][l+j-1]-ss[k-1][l+j-1]-ss[k+i-1][l-1]+ss[k-1][l-1]);
				  else MIN=min(MIN,m-(s[k+i-1][l+j-1]-s[k-1][l+j-1]-s[k+i-1][l-1]+s[k-1][l-1])+ss[k+i-1][l+j-1]-ss[k-1][l+j-1]-ss[k+i-1][l-1]+ss[k-1][l-1]);//求最小值
			}
		}
	}
	cout<<MIN;
    return 0;//好习惯
} 
```

### 如有不足，希望指出！

---


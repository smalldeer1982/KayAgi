# [CRCI2006-2007] TETRIS

## 题目描述

有如下七种俄罗斯方块的图形：

![](https://cdn.luogu.com.cn/upload/image_hosting/5p1l1cba.png)

在使用时可以将它们旋转 $90$，$180$，$270$ 度或不进行旋转。

现在有一个有 $n$ 列，高度不限的方格阵，第 $i$ 列的底部 $a_i$ 行已经有了图形（即最下方 $a_i$ 行在之前已经被放上了方块），每一列只有底部的连续若干行有方块。

下一次要落下的方块是 $m$ 号方块，请求出下落后有多少种布局满足不存在任何一个格子，它本身不被方块占据但是上方的格子被方块占据。也即求出多少种布局满足任何一列只有底部连续若干行有方块。

两种布局不同当且仅当存在一个格子，在其中一种布局中该格子被方块占据，在另一种布局中不被占据。

## 说明/提示

#### 样例 1 解释

下面六张图中，左上角的图是方格阵的初始布局，另外五张图是五种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/42ycyc2d.png)

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 100$，$1 \leq m \leq 7$。
- $0 \leq a_i \leq 100$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [Regional Competition](https://hsin.hr/coci/archive/2006_2007/regional_tasks.pdf) *T2 TETRIS***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。

## 样例 #1

### 输入

```
6 5
2 1 1 1 0 1
```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
0 0 0 0 0
```

### 输出

```
7```

## 样例 #3

### 输入

```
9 4
4 3 5 4 6 5 7 6 6
```

### 输出

```
1```

# 题解

## 作者：HeCao2008 (赞：4)

# 基本思路

考虑到这道题只需要预测下一种方块落在哪个位置最优，然而这个方块种类是给你的，所以开头需要**分类讨论**，是哪一种方块类型，而题目已经告诉你每一种方块类型。

接下来开始判断，因为想要给即将下落的方块腾出空间，所以需要判断是否与这个方块**完全契合**。

这里有两种情况：

第一种： 这个方块有凸出来的部分，那么下面必须得有一个凹进去的部分来放这个凸出来的部分。

第二种： 这个方框有凹进去的部分，同理那么下面必须得有凸出来的部分正好可以让凹进去的部分放。

想完思路以后，代码十分简单，只需要从前往后枚举就可以了。


# 代码

这道题确实可以一开始先判断是哪一种方块，但是用 $if$ 写就有点麻烦，所以可以用 $case$ 来减少代码量，同样可以继续优化把 $for$ 循环变成一个更短的表述方式~~但是我不喜欢~~。总之，**适合**自己的就好！


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101],n,m,ans=0;
int main(){
//	freopen("tetris.in","r",stdin);
//	freopen("tetris.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	switch(m){
		case 1:{
			for(int i=1;i<=n-3;i++)if(a[i]==a[i+1]&&a[i+1]==a[i+2]&&a[i+2]==a[i+3])ans++;
			ans+=n;  //如果这种方块竖着放的话，那么放哪里都符合条件了。（想一想，为什么？）
			break;
		}
		case 2:{
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1])ans++;
			break;
		}
		case 3:{
			for(int i=1;i<=n-1;i++)if(a[i+1]==a[i]-1)ans++;
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]&&a[i+2]==a[i+1]+1)ans++;
			break;
		}
		case 4:{
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1]-1)ans++;
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]+1&&a[i+1]==a[i+2])ans++;
			break;
		}
		case 5:{
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]&&a[i+1]==a[i+2])ans++;
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1]+1)ans++;
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1]-1)ans++;
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]+1&&a[i+2]==a[i+1]+1)ans++; 
			break;
		}
		case 6:{
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]&&a[i+1]==a[i+2])ans++;
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1])ans++;
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1]+2)ans++;
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+2]-1&&a[i+1]==a[i+2])ans++;
			break;
		}
		case 7:{
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1])ans++;
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]&&a[i+1]==a[i+2])ans++;
			for(int i=1;i<=n-1;i++)if(a[i]==a[i+1]-2)ans++;
			for(int i=1;i<=n-2;i++)if(a[i]==a[i+1]&&a[i+1]==a[i+2]+1)ans++;
			break;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


**谢谢大家的阅读！**

---

## 作者：zgy_123 (赞：1)

### 闲话：

考前 3 天写题解，祈求 rp++！

> 构造，可爱！交互，可爱！模拟，讨厌！
>
>$\mkern{12em}$------ coffee_zzz

> 构造，讨厌！交互，讨厌！模拟，可爱！ 
>
>$\mkern{12em}$------ konyakest

> 构造，可爱！交互，可爱！模拟，可爱！ 
>
>$\mkern{12em}$------ rzh123

### 思路

首先，此题数据范围小，一看就是大模拟，所以我打了一个 $O(n^4)$ 的暴力 + 大模拟。

我的思路是这样的：枚举每个位置，将他试着填方块，如果重合就跳过，否则就将填好的标记，并且判断当前状态是否合法，如果合法，则加入计数器中。否则就跳过，继续枚举下一状态。

### 要点

1. 本题如果按这种做法则复杂度卡的比较严，要注意优化。
2. 变量较多，要分清。
3. 此题代码长度其实算不上大模拟，我的代码只有 82 行，其中 28 行是头文件及定义的数组。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int d[20][5][2]={
{{0,0},{1,0},{2,0},{3,0}},
{{0,0},{0,1},{0,2},{0,3}},

{{0,0},{0,1},{1,0},{1,1}},

{{0,0},{0,1},{1,1},{1,2}},
{{0,1},{1,0},{1,1},{2,0}},

{{0,1},{0,2},{1,0},{1,1}},
{{0,0},{1,0},{1,1},{2,1}},

{{0,1},{1,0},{1,1},{1,2}},
{{0,0},{1,0},{1,1},{2,0}},
{{0,0},{0,1},{0,2},{1,1}},
{{0,1},{1,0},{1,1},{2,1}},

{{0,0},{1,0},{1,1},{1,2}},
{{0,0},{0,1},{1,0},{2,0}},
{{0,0},{0,1},{0,2},{1,2}},
{{0,1},{1,1},{2,1},{2,0}},

{{0,2},{1,0},{1,1},{1,2}},
{{0,0},{0,1},{1,1},{2,1}},
{{0,0},{0,1},{0,2},{1,0}},
{{0,0},{1,0},{2,0},{2,1}}
};
int a[106][110],b[106][110],c[106],l,r;
int fill(int x,int y){
	if(x-5>c[y]||x<c[y]) return 0;
	int ans=0;
	for(int t=l;t<=r;t++){
		int fl=0,flag=0;
		memcpy(b,a,sizeof(a));
		for(int k=0;k<4;k++){
			if(b[x-d[t][k][0]][y-d[t][k][1]]){
				flag=1;
				break;
			}
			b[x-d[t][k][0]][y-d[t][k][1]]=1;
		}
		if(flag) continue;
		for(int x=1;x<=100;x++){
			fl=0;
			for(int i=100;i>0;i--){
				if(fl==1&&b[i][x]==0){
					fl=114;
					break;
				}
				if(fl==0&&b[i][x]==1) fl=1;
			}
			if(fl==114) break;
		}
		if(fl!=114) ans++;
	}
	return ans;
}
int main(){
	for(int i=0;i<=105;i++)
		for(int j=0;j<=105;j++) a[i][j]=1;
	int n,ans=0,m;
	cin>>n>>m;
	switch(m){
		case 1:l=0,r=1;break;
		case 2:l=r=2;break;
		case 3:l=3,r=4;break;
		case 4:l=5,r=6;break;
		case 5:l=7,r=10;break;
		case 6:l=11,r=14;break;
		case 7:l=15,r=18;break;
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
		for(int j=c[i]+1;j<=105;j++) a[j][i]=0;
	}
	for(int i=1;i<=n;i++)
		for(int j=105;j>0;j--) ans+=fill(j,i);
	cout<<ans;
	return 0;
}
```

另，祝大家 CSP 2023 J/S rp++！！！

---

## 作者：xiaoming007 (赞：1)

珂爱大模拟。

## 思路

既然题目要求**摆上去的图形契合**的话，那我们不妨对于每个不同的图形进行分类：

图形编号为 $1$：

- 显然竖着摆放是每一列都有可能。

- 横着摆放时，必须是 $4$ 个连续的高度相同的才有可能。

图形编号为 $2$：

- 只有当 $2$ 个连续的高度相同的才有可能。

图形编号为 $3$：

- 横着摆放时，必须在连续的 $3$ 个高度中，前两个高度相等，且第三个正好比第一/第二个的高度多 $1$。

- 竖着时，当连续的两个高度中，第一个比第二个高度多 $1$，便可以摆放。

图形编号为 $4$：

- 与编号 $3$ 大致相等，不过就是变了个方向罢了。

- 横着摆放时，必须在连续的 $3$ 个高度中，后两个高度相等，且第一个正好比第二/第三个的高度多 $1$。

- 竖着时，当连续的两个高度中，第一个比第二个高度少 $1$，便可以摆放。

接下来开始烧脑起来了。

图形编号为 $5$：

- 三个连续高度相等的可以摆放。

- 三个连续的高度，当第一个与第三个高度相等，第二个比第一/第三个高度少 $1$，可以摆放。

- 当连续的两个高度中，第一个比第二个高度多 $1$，可以摆放。

- 当连续的两个高度中，第一个比第二个高度少 $1$，可以摆放。

图形编号为 $6$：

- 三个连续高度相等的可以摆放。

- 两个连续高度相等的可以摆放。

- 在连续的 $3$ 个高度中，后两个高度相等，且第一个正好比第二/第三个的高度少 $1$。

- 连续的两个高度中，第一个比第二个多 $2$。

编号为 $7$：

- 三个连续高度相等的可以摆放。

- 两个连续高度相等的可以摆放。

- 在连续的 $3$ 个高度中，前两个高度相等，且第三个正好比第一/第二个的高度少 $1$。

- 连续的两个高度中，第一个比第二个少 $2$。

## 代码

```cpp
//Author: Saint_ying_xtf
//xiaoming007 = Saint_ying_xtf
//help me,qwq
//Timelimit: 1000ms
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <iomanip>
#include <cmath>
using namespace std;
#define int long long
#define f(W, X, Y, Z) for(int W = X; W <= Y; W += Z)
#define F(W, X, Y, Z) for(int W = X; W >= Y; W -= Z)
#define debug puts("QAQ")
namespace fastIO{
	inline int read(){
		int x = 0, s = 1;
		char c = getchar();
		while(c < '0' || c > '9'){
			if(c == '-') s = -1;
			c = getchar();
		}
		while(c >= '0' && c <= '9'){
			x = (x << 3) + (x << 1) + (c ^ '0');
			c = getchar();
		}
		return x * s;
	}
	inline void Write(int x){
		if(x < 0){
			putchar('-');
			x = -x;
		}
		if(x > 9) Write(x / 10);
		putchar(x % 10 + '0');
	}
	inline void write(int x, char c){
		Write(x);
		putchar(c);
	}
}
using namespace fastIO;
namespace SyxQwQ{
	inline int qwq(){
		return 0;
	}
	int a[114514];
	inline int main(){
		//todo
		int n = read(), xtp = read(), ans = 0;
		f(i, 1, n, 1) a[i] = read();
		if(xtp == 1){
			f(i, 4, n, 1) if(a[i] == a[i-1] && a[i] == a[i-2] && a[i] == a[i-3]) ans++;
			ans += n;
		}else if(xtp == 2){
			f(i, 2, n, 1) if(a[i] == a[i-1]) ans++;
		}else if(xtp == 3){
			f(i, 3, n, 1){
				if(a[i-1] == a[i-2] && a[i-1] + 1 == a[i]) ans++;
				else if(a[i-1] - 1 == a[i]) ans++;
			}
		}else if(xtp == 4){
			f(i, 3, n, 1){
				if(a[i] == a[i-1] && a[i-2] - 1 == a[i-1]) ans++;
				else if(a[i-1] + 1 == a[i]) ans++;
			}
		}else if(xtp == 5){
			f(i, 3, n, 1) if(a[i] == a[i-1] && a[i] == a[i-2]) ans++;
			f(i, 3, n, 1) if(a[i] == a[i-2] && a[i] == a[i-1] + 1) ans++;
			f(i, 2, n, 1){
				if(a[i-1] + 1 == a[i]) ans++;
				else if(a[i-1] - 1 == a[i]) ans++;
			}
		}else if(xtp == 6){
			f(i, 3, n, 1) if(a[i] == a[i-1] && a[i] == a[i-2]) ans++;
			f(i, 3, n, 1) if(a[i] == a[i-1] && a[i] == a[i-2] + 1) ans++;
			f(i, 2, n, 1) if(a[i] == a[i-1]) ans++;
			f(i, 2, n, 1) if(a[i-1] - 2 == a[i]) ans++;
		}else if(xtp == 7){
			f(i, 3, n, 1) if(a[i] == a[i-1] && a[i] == a[i-2]) ans++;
			f(i, 3, n, 1) if(a[i-2] == a[i-1] && a[i] == a[i-1] - 1) ans++;
			f(i, 2, n, 1) if(a[i] == a[i-1]) ans++;
			f(i, 2, n, 1) if(a[i-1] + 2 == a[i]) ans++;
		}
		write(ans, '\n');
		return qwq();
	}
}
signed main(){
	SyxQwQ::main();
	return 0;
}
```

---

## 作者：yyyyxh (赞：1)

这是一道模拟题，并未使用特殊算法或数据结构，但一次过考验耐心与准确度。
### 题意分析
可以这样转化题面：对于一个序列，它有多少子序列符合指定的升降情况。
因为对于每一个方块，可以看作对应增加一，所以能放入这个方块的地方最表面一层符合方块凹槽
|1 |1 |1 |
| -----------: | -----------: | -----------: |
|0 |1 |0 |
|0 |0 |0 |
如上图，1表示方块，那它下面的方块必须是先降一再升一的。
由于仅需考虑初始凹槽不空格，所以我们仅需考虑方块最大宽度及以下的地方。
那么这题就很水了，仅需将每个方块各个方向转化为对序列升降的要求逐一验证即可，样例n规模吧100很水
### 上代码
```cpp
#include <bits/stdc++.h>
#define REC(x) for(register int i=1; i<=x; i++) //进行替换可以减少码长，提高可读性 
using namespace std;
int main()
{	int n,k,a[101],ans=0;
	cin>>n>>k;
	REC(n) cin>>a[i];
	switch(k) //switch提高可读性 
	{	case 1:
		{	REC(n-3) if(a[i]==a[i+1]&&a[i+1]==a[i+2]&&a[i+2]==a[i+3]) ans++;
			ans+=n; //对于一号方块，竖放永远满足条件，所以共n种
			break;
		}
		case 2:
		{	REC(n-1) if(a[i]==a[i+1]) ans++;
			break;
		}
		case 3:
		{	REC(n-1) if(a[i]==a[i+1]+1) ans++;
			REC(n-2) if(a[i]==a[i+1]&&a[i+1]==a[i+2]-1) ans++;
			break;
		}
		case 4:
		{	REC(n-1) if(a[i]==a[i+1]-1) ans++;
			REC(n-2) if(a[i]==a[i+1]+1&&a[i+1]==a[i+2]) ans++;
			break;
		}
		case 5:
		{	REC(n-1) if(a[i]==a[i+1]+1) ans++;
			REC(n-1) if(a[i]==a[i+1]-1) ans++;
			REC(n-2) if(a[i]==a[i+1]+1&&a[i+1]==a[i+2]-1) ans++;
			REC(n-2) if(a[i]==a[i+1]&&a[i+1]==a[i+2]) ans++;
			break;
		}
		case 6:
		{	REC(n-2) if(a[i]==a[i+1]-1&&a[i+1]==a[i+2]) ans++;
			REC(n-2) if(a[i]==a[i+1]&&a[i+1]==a[i+2]) ans++;
			REC(n-1) if(a[i]==a[i+1]) ans++;
			REC(n-1) if(a[i]==a[i+1]+2) ans++;
			break;
		}
		case 7:
		{	REC(n-2) if(a[i]==a[i+1]&&a[i+1]==a[i+2]+1) ans++;
			REC(n-2) if(a[i]==a[i+1]&&a[i+1]==a[i+2]) ans++;
			REC(n-1) if(a[i]==a[i+1]) ans++;
			REC(n-1) if(a[i]==a[i+1]-2) ans++;
			break;
		}
	}
	cout<<ans<<endl;
	return 0; 
}
```
第一次写题解，找了个冷门水题，如有讲的不好的地方敬请指教

---

## 作者：WA_WonderfulAnswer (赞：0)

## 思路
读题后我发现：这是一道**模拟**题。

题目已经告诉你每一种方块类型，所以只要判断两个方块是否契合就行。得到这种结论后，我们需要**分类讨论**一下。

因为我们想要给即将下落的方块腾出空间，所以需要判断是否与这个方块**完全契合**。这里有两种情况：
>1. 方块**凸起来**，就要找一个**凹下去**的方块。

>2. 方块**凹进去**，同理，就要找一个**凸起来**的方块。

综合上述思路，我写出了 $\downarrow$ 下面的~~很长的~~代码。
## 代码
代码有~~亿点点~~长，大佬勿喷。
```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std; //定义明明空间
int n,c,s[10010],ans; //定义变量、数组
int main()//主函数
{
	freopen("TETRIS.in","r",stdin); //打开输入文件
	freopen("TETRIS.out","w",stdout); //打开输出文件
	scanf("%d%d",&c,&n); //输入
	for(int i=1;i<=c;i++)scanf("%d",&s[i]); //循环输入
	if(n==1)//开始了长长的if判断（懒得写switch了）
	{
		ans=c;
		for(int i=1;i<=c-3;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2]&&s[i]==s[i+3])ans++;
	}
	if(n==2)//判断中
	{	
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	if(n==3)//判断中
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2]-1)ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-1==s[i+1])ans++;
	}
	if(n==4)//判断中
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]-1==s[i+1]&&s[i+1]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i+1]-1==s[i])ans++;
	}
	if(n==5)//判断中
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-1==s[i+1])ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]-1==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1]-1)ans++;
	}
	if(n==6)//判断中
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-2==s[i+1])ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]+1==s[i+1]&&s[i+1]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	if(n==7)//判断中
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1]-2)ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i+1]==s[i+2]+1)ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}//判断结束
	printf("%d",ans);//输出
	fclose(stdin);//关闭输入
	fclose(stdout);//关闭输出
	return 0;//结束程序
}
```

---

## 作者：zwye (赞：0)

### 方法
这是一道模拟题。

题目已经告诉你每一种方块类型，所以只要判断两个方块是否契合就行。

有两种情况：

1. 方块凸起来，就要找一个凹下去的方块。

2. 方块凹进去，同理就要找一个凸起来的方块。

代码有点长。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,s[100010],ans;
int main()
{
	scanf("%d%d",&c,&n);
	for(int i=1;i<=c;i++)scanf("%d",&s[i]);
	if(n==1)
	{
		ans=c;
		for(int i=1;i<=c-3;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2]&&s[i]==s[i+3])ans++;
	}
	if(n==2)
	{	
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	if(n==3)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2]-1)ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-1==s[i+1])ans++;
	}
	if(n==4)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]-1==s[i+1]&&s[i+1]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i+1]-1==s[i])ans++;
	}
	if(n==5)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-1==s[i+1])ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]-1==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1]-1)ans++;
	}
	if(n==6)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-2==s[i+1])ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]+1==s[i+1]&&s[i+1]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	if(n==7)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1]-2)ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i+1]==s[i+2]+1)ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	printf("%d",ans);
	return 0;
}

```
你以为这就完了吗？没那么简单！其实你们有没有发现，第 $4$ 个和第 $3$ 正好反过来，第 $7$ 个和第 $6$ 个也是，所以其实在输入第 $4$ 个和第 $7$ 个的时候，倒过来输入，并进行 $3$ 和 $6$ 的操作就可以了！

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,s[10010],ans;
int main()
{
	scanf("%d%d",&c,&n);
	for(int i=1;i<=c;i++)scanf("%d",&s[i]);
	if(n==1)
	{
		ans=c;
		for(int i=1;i<=c-3;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2]&&s[i]==s[i+3])ans++;
	}
	if(n==2)
	{	
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	if(n==3)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2]-1)ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-1==s[i+1])ans++;
	}
	if(n==4)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]-1==s[i+1]&&s[i+1]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i+1]-1==s[i])ans++;
	}
	if(n==5)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-1==s[i+1])ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]-1==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1]-1)ans++;
	}
	if(n==6)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]-2==s[i+1])ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]+1==s[i+1]&&s[i+1]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	if(n==7)
	{
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i]==s[i+2])ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1]-2)ans++;
		for(int i=1;i<=c-2;i++)
			if(s[i]==s[i+1]&&s[i+1]==s[i+2]+1)ans++;
		for(int i=1;i<=c-1;i++)
			if(s[i]==s[i+1])ans++;
	}
	printf("%d",ans);
	return 0;
}

```


---


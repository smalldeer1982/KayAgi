# [CRCI2006-2007] FIREFLY

## 题目背景

一只日本萤火虫飞进了一个充满障碍的山洞。

## 题目描述

山洞中有两种障碍物：石笋（从地面向上生长）和钟乳石（从洞顶垂挂下来）。山洞长 $n$ 个单位，高 $h$ 个单位。从左到右第一个障碍物是石笋；紧接着钟乳石与石笋依次交替出现。

下图是一个长 $14$ 个单位，高 $5$ 个单位的山洞示例：

![](https://cdn.luogu.com.cn/upload/image_hosting/bcb6bifp.png)

这只日本萤火虫并不会绕开障碍物，而只会沿着同一高度飞行。凭借着自己精湛的功夫，他会从山洞的一端，以某一高度撞开所有障碍物而达到另一端。

![](https://cdn.luogu.com.cn/upload/image_hosting/3t9jf6ny.png)

例如在上图中，如果萤火虫选择高度 $4$ 来飞行，那么它总共会撞到 $8$ 个障碍物。

但这并不是最好的选择。因为如果它选择高度 $1$ 或高度 $5$ 飞行的话，只需要撞开 $7$ 个障碍物就行了。

为了减轻疼痛，你需要帮助萤火虫找出最少需要摧毁的障碍的数量和摧毁最少障碍物的高度种类数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 2\times 10^5$，$2\le h\le 5\times 10^5$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [Regional Competition](https://hsin.hr/coci/archive/2006_2007/regional_tasks.pdf) *T3 FIREFLY***。

## 样例 #1

### 输入

```
6 7
1
5
3
3
5
1```

### 输出

```
2 3```

## 样例 #2

### 输入

```
14 5
1
3
4
2
2
4
3
4
3
3
3
2
3
3```

### 输出

```
7 2```

# 题解

## 作者：VioletIsMyLove (赞：6)

当我们把脑袋向左旋转90°,把每一个石柱子看成一条线段,把枚举的高度看成一条竖线,唉呀妈呀这不就是传说中的扫描线吗?


此题的细节之处就是需要把高度抽象成一个小方格,换句话说就是把列看成是 $Hi$ 个小积木

Code:

```cpp
#include<bits/stdc++.h>
#define maxh 500005
using namespace std;
int N,H,Ans,hight[maxh],Sum[maxh];
int read(){
	int ret=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return ret*f;
}
int main(){
	N=read(),H=read();
	for (int i=1;i<=N;i++){
		int x=read();
		if (i&1) hight[1]++,hight[x+1]--;else hight[H-x+1]++,hight[H+1]--;
	}
	for (int i=1;i<=H;i++) Sum[i]=Sum[i-1]+hight[i];
	sort(Sum+1,Sum+1+H);
	for (int i=1;i<=H;i++)
	  if (Sum[i]==Sum[1]) Ans++;else break;
	printf("%d %d\n",Sum[1],Ans);
	return 0;
}
```

但换个角度思考，我们会发现这道题居然还可以用毛毛虫去做，解释在代码里。

Code:

```cpp
//毛毛虫 
#include <bits/stdc++.h>
#define maxn 200005
using namespace std;
int N,Ans,Ans_k,H,A[maxn],B[maxn];
int read(){
	int f=1,ret=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f; ch=getchar();}
	while( isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return f*ret;
}
int main(){
	Ans=N=read(),H=read();
	for(int i=1;i<=N;i++)
		if(i&1) A[i+1>>1]=read();	//石笋 
		else	B[i+1>>1]=read();	//石钟乳 
	sort(A+1,A+(N>>1)+1);
	sort(B+1,B+(N>>1)+1);
	int A_l=1,B_l=(N>>1);
	for(int i=1;i<=H;i++){
		while(A[A_l]<i&&A_l<=(N>>1))   A_l++;	//找到第一个需要灭了的石笋 
		while(H-B[B_l]<i&&B_l<=(N>>1)) B_l--;	//找到第一个需要灭了的石钟乳 
		if(N-A_l-B_l+1==Ans) Ans_k++;
		if(N-A_l-B_l+1< Ans) Ans=N-A_l-B_l+1,Ans_k=1;
	}
	printf("%d\n%d\n",Ans,Ans_k);
	return 0;
}
```

我看到这道题有人写的题解是树状数组，其实我一开始也写的是树状数组，但后来自己一思考发现根本没有写树状数组的必要，题目中根本不需要修改数值，所以还不如写扫描线。最重要的是！！！树状数组时效要慢2倍。。。

树状数组Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h,minn,maxn;
int b[2000005],c[5000005];
void put(int x,int v){for(int i=x;i<=h;i+=i&-i)c[i]+=v;}
int get(int x){
	int cnt=0;
	for(int i=x;i;i-=i&-i)cnt+=c[i];
	return cnt;
}
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main(){
	n=read();h=read();
	for(int i=1;i<=n;i+=2){
		int x=read(),y=read();
		put(1,1);put(x+1,-1);put(h-y+1,1);
	}
	for(int i=1;i<=h;i++)b[i]=get(i);
	sort(b+1,b+1+h);
	for(int i=1;i<=h;i++){minn++;if(b[i]!=b[i+1])break;}
	printf("%d %d\n",b[1],minn);
	return 0;
}
```


---

## 作者：wzkdh (赞：3)

## 题意分析：

题面要求每个高度所经过的障碍的最小值，朴素的思想是每一层枚举统计，找出最小值，但肯定会t。

我们把上方的障碍和下方的障碍分开来看：

首先看下面的障碍，每一个长$x$的障碍并不只是只影响x高度这一层，同时影响了自高度1到高度$x$这几层。同样上方的障碍也是如此，长$x$的障碍影响了从$h-x+1$到$h$这几层。

这就很容易想到差分了。

## 细节实现：

首先我们用两个数组统计上下两方高x的障碍的数量，然后从后向前求前缀和（~~话说是不是该说叫后缀和。。。~~），为什么这里要从后向前呢？因为每一个障碍影响的是比他高度低的所有位置，如果从前向后前缀和就变成影响比他高的障碍了，显然不符合题意。

之后两个前缀和数组分别表示以$x$高度飞，会碰到$suml[x]$个下方的障碍和$sumu[h-x+1]$个上方的障碍，枚举$x$然后找最小值即可。

具体细节请看蒟蒻代码。

## 蒟蒻代码：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int n,h,l[1000010],u[1000010],suml[1000010],sumu[1000010];
int main()
{
	scanf("%d%d",&n,&h);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x); 
		if(i%2)
		{
			l[x]++;
			continue;
		}
		u[x]++;
	}
	for(int i=h;i>=1;i--)
	{
		suml[i]=suml[i+1]+l[i];
		sumu[i]=sumu[i+1]+u[i];
	}//从后向前前缀和
	int ans=0x3fffffff,sum=0;
	for(int i=1;i<=h;i++)
	{
		if(ans>suml[i]+sumu[h-i+1])
		{
			ans=suml[i]+sumu[h-i+1];
			sum=1;//更新了高度的话同高度的数量也要更新
		}
		else if(ans==suml[i]+sumu[h-i+1])
		{
			sum++;
		}
	}
	printf("%d %d",ans,sum);
	return 0;
}

---

## 作者：Graphcity (赞：2)

很明显，萤火虫在高度 $k$ 时撞开的障碍物数量，就是求有多少个石笋（ 钟乳石 ）可以达到高度 $k$ 。

我们先以 $h$ 数组（ $h_i=x$ 表示有 $x$ 个障碍物能够达到高度 $i$ ）来存储这些数据。

每次输入障碍物的高度时，我们就进行一次区间修改即可。到最后，我们只需要排序求出结果即可。区修单查时间复杂度为 $O(h^2)$ ，过不去。

---

我们考虑优化一下。

定义一个**差分数组** $l$ , $l_i=h_i-h_{i-1}$ , 不难发现：

1. $\sum_{i=1}^{k}l_i=h_k$

2. 当要将区间 $[x,y]$ 加上 $k$ 时，只需要 $l_x+k$ , $l_{y+1}-k$ 即可。

这样子，区间修改操作变成了 $O(1)$ , 一次查询求前缀和也仅需 $O(h)$ 的时间复杂度。

更详细的解释在 [这里](https://oi-wiki.org/basic/prefix-sum/) 。

---

这个题目本质上来说，只需要支持两个操作：

1. 将区间 $[x,y]$ 的值全部 $+1$ 

2. 求出某个点 $x$ 的值，且**此操作全部在修改操作之后。**

于是，这个问题就可以使用差分，将最终结果排序就可以迎刃而解了。差分时间复杂度：$O(n+h)$

```cpp
#include<bits/stdc++.h>
#define Maxn int(2e5)
#define Maxh int(5e5)
#define Add(x,y) l[x]++,l[y+1]--//[x,y]这段区间进行修改 
using namespace std;

int n,h,ans=1;//ans:高度种类数 
int l[Maxh+5],s[Maxh+5];
//l:存储差分 s:存储前缀和



int main()
{
	scanf("%d%d",&n,&h);
	for(register int i=1;i<=n;++i)
	{
		int a;
		scanf("%d",&a);
		if(i&1)//情况1:石笋
			Add(1,a);
		else//情况2:钟乳石
			Add(h-a+1,h); 
	}
	
	for(register int i=1;i<=h;++i)
		s[i]=s[i-1]+l[i];//求前缀和
	sort(s+1,s+h+1);//从小到大排序
	while(s[ans+1]==s[1])
		++ans;
	printf("%d %d",s[1],ans);
    return 0;
}

```

---

## 作者：B_1168 (赞：2)

本题本质就是给定很多个区间，每个区间权值为1，求一个使得该点权值最小的点和能取得该权值的点的数量；留意数据范围，显然不能承受暴力的$O(n^2)$范围，考虑优化

如上面所说，本题给出很多需要修改的区间，查询单点，当然可以用线段树或树状数组，而且~~也可以用线性复杂度的方法过~~，但是我太蒻了，不会别的方法，只知道套上分块模板了事qwq

以下放极丑代码：

```cpp
#pragma GCC optimize(3)

//以下略去四十多行优化指令

#include<bits/stdc++.h>
using namespace std;

const int maxn=500001;//注意看范围，第一次提交看了n的数据范围，只开了20w，导致3个点RE

int n,m,len,a[maxn],add[maxn],val[maxn],be[maxn],ans[maxn],anss,h;

bool cmp (int a, int b){
    return a<b;
}

inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}

inline int read(){
    int x=0,f=1;char ch=nc();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=nc();}
    while (isdigit(ch)){x=x*10+ch-48;ch=nc();}
    return x*f;
}

//快读

void modify(int from,int to,int ad){
    for(int i=from;i<=min(to,be[from]*len);i++) a[i]+=ad,val[be[from]]+=ad;
    if(be[from]!=be[to]){
        for(int i=(be[to]-1)*len+1;i<=to;i++) a[i]+=ad,val[be[to]]+=ad;
    }
    for(int i=be[from]+1;i<=be[to]-1;i++) add[i]+=ad;
}

//区间更新

int query(int pt){
	return a[pt]+add[be[pt]];
}

//单点查询

int main(){
    n=read(),h=read();
    len=sqrt(h);
    for(int i=0;i<=h;i++)be[i]=(i-1)/len+1;//初始化
    for(int i=1;i<=n;i++){//读入数据+区间修改
    	int temp=read();
    	if(i&1){
    		modify(1,temp,1);
 //   		printf("%d %d\n",1,temp);
    	}
    	else {
    		modify(h-temp+1,h,1);
//    		printf("%d %d\n",h-temp+1,h);
    	}
    }
    for(int i=1;i<=h;i++){//查询走每一条道的值
    	ans[i]=query(i);
//    	printf("%d\n",ans[i]);
    }
    sort(ans+1,ans+h+1,cmp);//排序，找出最小的答案
    for(int i=1;i<=h;i++){
    	if(ans[i]==ans[1])anss++;//找出最小答案的个数
    }
	printf("%d %d\n",ans[1],anss);//输出
   return 0;
}
```

感谢管理员的审核！

~~看到这里了，如果本题解对各位神犇们有帮助，就求个赞吧qwq~~

---

## 作者：yewanxingkong (赞：1)

# **题目分析**
把题意理解再抽象一下大致就是找一个高度使这个高度的障碍数最少。

那么很容易就能想到定义一个数组记录下每一个高度的障碍物数量，如果每处理一个障碍物都循环赋值的话显然太慢，所以自然而然的就想到了差分。

差分后进行前缀和，同时记录最小值，最后遍历一遍记录最小值的个数，答案就出来了。
# **关于差分**
既然用到了差分那么我就简单讲一讲。~~我太弱了如果还不明白可以去网上查查~~

差分是要和前缀和一起用的，简单操作就是使一个区间的每一个数都加上一个值。由于加上的这个值是相同的，所以我们可以在这个区间的第一个位置加上这个值，然后再区间末位置的下一个位置减去这个值。等最后我们在进行一次前缀和，此时你就会发现它完美实现了这些操作。（不明白可以代码实现一下）

而在进行差分前要进行操作的这些数有初值的话需要进行预处理，使每一个位置的值减去上一个位置的值，这样最后进行前缀和的时候不会使初值叠加导致答案错误。

# **代码**
```cpp
#include<iostream>

#include<cstdio>

#include<cmath>

#include<cstring>

#include<string>

using namespace std;

int n,h,f[500010],a,minn=1000000000,chu;

inline int read(){

	int date=0,w=1;char c=0;

	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}

	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}

	return date*w;

}

int main(){

	n=read();

	h=read();

	for(int i=1;i<=n;i++){

		a=read();

		if(i%2==1){

			f[1]+=1;

			f[a+1]-=1;

		}

		else f[h-a+1]+=1;

	}

	for(int i=1;i<=h;i++){

		f[i]+=f[i-1];

		minn=min(minn,f[i]);

	}

	for(int i=1;i<=h;i++)

		if(f[i]==minn)chu++;

	cout<<minn<<' '<<chu;

	return 0;

}
```


---

## 作者：novax (赞：1)

#### 题意
要求萤火虫在高度为 $x$ 撞开多少个障碍物，其实就是求经过高度为 $x$ 这一行的石笋/钟乳石数量。

#### 思路
题目中的山洞从洞顶到洞底可以看作一个长度为 $h$ 的数列，从上到下分别是数列的第 $1\sim h$ 项，表示每一层会碰到多少个障碍物。每个钟乳石可以看作将区间 $[1,a]$ 的值都增加1，石笋可以看做将 $[h-a,h]$ 的值都增加1。最后求出数列中的最大值。数据范围较大，直接暴力 $O(n^2)$ 的做法显然是不能做的，所以考虑时间复杂度更优的做法。

需要维护区间修改，单点查询，考虑用 **差分+树状数组** 的思想来维护。设原数组是 $a_i$，定义差分数组 $b_i = a_i -a_{i-1}$，可以得出：
- $a_i = \sum_{n=1}^ia_n$
- 区间 $[x,y]$ 同时加上一个数 $k$，只需要将 $b_x$ 加上 $k$，$b_{y+1}$ 减去 $k$

此时区间修改的时间复杂度就为 $O(1)$，单点查询的复杂度为 $O(n)$。

为了进一步提升时间效率，可以在差分的基础上再建立一个树状数组，进一步降低查询的时间复杂度，详见[这道题](https://www.luogu.com.cn/problem/P3368)。

#### 代码如下
```
#include <cstdio>
#define min(a,b) ((a<b)?(a):(b)) 
int a,c[500010],d[500010];//输入的数 //树状数组  //从第i格开始走要撞开几个障碍 
int N,M,i,mi,ans;
int query(int x)//查询前x个数的和 
{
	int sum;
	sum=0;
	while(x!=0)
	{
		sum+=c[x];
		x-=x&-x;
	}
	return sum;
}
void update(int x,int delta)//将第x个数的值增加delta 
{
	while(x<=M)
	{
		c[x]+=delta;
		x+=x&-x;
	} 
} 
int main()
{
	mi=2147483647;
	scanf("%d%d",&N,&M);
	for(i=1;i<=N;i++)
	{
		scanf("%d",&a);
		if(i%2==0)
		{
			update(1,1);
			update(a+1,-1);
		}
		else
		{
			update(M-a+1,1);
			update(M+1,-1);
		}
	} 
	for(i=1;i<=M;i++)
	{
		d[i]=query(i);
		mi=min(mi,d[i]);
	} 
	for(i=1;i<=M;i++)
	{
		if(d[i]==mi)
			ans++;
	}
	printf("%d %d\n",mi,ans);
}
```


---


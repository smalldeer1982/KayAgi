# [COCI 2010/2011 #4] PROSJEK

## 题目描述

你有 $5$ 种数字： $1,2,3,4,5$。

你需要从中选取尽量少的数字，使得这些数之和的平均数为 $P$。

**需要注意的是，这 $5$ 种数字每种有任意多个。**

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le P\le 5$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #4](https://hsin.hr/coci/archive/2010_2011/contest4_tasks.pdf) *T4 PROSJEK***。

## 样例 #1

### 输入

```
5.0```

### 输出

```
0 0 0 0 1```

## 样例 #2

### 输入

```
4.5```

### 输出

```
0 0 0 1 1```

## 样例 #3

### 输入

```
3.20```

### 输出

```
0 0 4 1 0```

# 题解

## 作者：Flanksy (赞：7)

若 $P$ 不为整数，那么必然存在一组仅使用 $\lfloor P \rfloor$ 和 $\lceil P \rceil$ 且使用数字数量最小的方案。

**使用其他数字的最优方案中其他数字可以被等价转换为 $\lfloor P \rfloor$ 和 $\lceil P \rceil$ 的组合。**

证明：假设给定的 $P \in [2,3]$，此时 $\lfloor P \rfloor=2,\lceil P \rceil=3$，将选择的数两两配对后考虑对答案的影响。

||1|2|3|4|5|
|:-:|:-:|:-:|:-:|:-:|:-:|
|**1**|$1$|$1.5$|$2$|$2.5$|$3$|
|**2**|$1.5$|$2$|$2.5$|$3$|$3.5$|
|**3**|$2$|$2.5$|$3$|$3.5$|$4$|
|**4**|$2.5$|$3$|$3.5$|$4$|$4.5$|
|**5**|$3$|$3.5$|$4$|$4.5$|$5$|

可以发现只需要 $2$ 和 $3$ 的组合就能凑出 $[2,3]$ 区间内的任意数字，其他数对要么和 $2,3$ 组合出的数对等价，要么显然更劣。所以**必定存在选择了不超过一个 $2,3$ 之外的数字的最优方案**。

再证明**包含一个 $2,3$ 之外的数字的最优方案中该数字可以被替换**，假设一个最优方案中包含一个 $1$，那么这个方案必定也包含至少一个 $3$，否则能够推出 $P \in [1,2)$，与给定条件矛盾。由上表可知 $1,3$ 等价于 $2,2$，最优方案中包含一个 $4$ 的情况同理。最优方案中不会仅包含一个 $5$，因为 $2,5$ 和 $3,5$ 都是会使答案变劣的组合。

给定的 $P$ 在其他区间内的情况同理，证毕。

令 $x=P - \lfloor P \rfloor$，问题转化为找到一组和最小且满足 $\dfrac{0 \times k_1 + 1 \times k_2}{k_1+k_2}=x$ 的整数 $k_1,k_2$，构造的最优方案中仅使用 $k_1$ 个 $\lfloor P \rfloor$ 和 $k_2$ 个 $\lceil P \rceil$。

移项得 $\dfrac{k_1}{k_2}=\dfrac{1-x}{x}$，令 $y=1-x$，将 $x$ 和 $y$ 同乘 $10$ 的幂转化为整数后同时除以 $\gcd(x,y)$ 可以得到 $k_1,k_2$ 的值。

---

## 作者：Perta (赞：5)

## 题意
总而言之就是求

$\dfrac{x+2y+3z+4a+5b}{x+y+z+a+b}=k$

$x,y,z,a,b\in N; k\in R^{*}$

$x+y+z+a+b$ 最小的一个解。
## 思路
其实转化一下就会发现这是一个浓度问题，并且只和两个常数有关。

------------

**浓度**：（$a$ 为 $A$ 的百分比，$b$ 为 $B$ 的百分比，此处可理解为 $A$ 和 $B$ 分别选取的个数）

浓度 $=\dfrac{aA+bB}{a+b}$

我们已经知道了浓度 $P$，所求的就是 $a+b$ 的最小解。既然这样，当 $A=\lfloor P\rfloor,B=\lceil P\rceil$ 时，肯定可以取到最优解。因为这样，不管 $A$ 减小或者 $B$ 增大（可以认为 $A<B$），$a+b$ 的值都比原来要增大。

那么其最优解呢？

$A$ 的系数为 $\dfrac{a}{a+b}$，$B$ 的系数为 $\dfrac{b}{a+b}$，现在已经知道了浓度 $P$，相当于我们已经知道了 $a+b$ 的值，即 $P$ 表示为分数时的分母部分。那么这就是一个二元一次方程组，只需要解出来即可。

值得注意的是，解出来的 $a$ 和 $b$ 只是一个解。如果要得到最优解，就需要将 $a$ 和 $b$ 化到互质（$a:b$ 不变）。

------------
令 $m$ 为 $k$ 的小数部分，$n$ 为不小于 $m$ 的最小的10的倍数。$n$ 为分母。

由浓度可知，其中一个自然数解为：$b=m,a=n-m$ 。
然后将 $a$ 和 $b$ 化到互质即可。
## code
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll x,y,k=1,t,ans[6],a,b;
string s;//用字符串存储小数更方便后面的处理（I think）
//求最小公因数，方便化简
ll gcd(ll x,ll y)
{
	if(!y) return x;
	return gcd(y,x%y);
}
int main()
{
	cin>>s;
	y=s[0]-'0',x=y++;
	for(int i=2;i<s.size();i++) a+=10*(s[i]-'0'),a*=10,k*=10;
    //处理为整数类型
	k*=100;
	b=k-a;
	while((t=gcd(a,b))!=1) a/=t,b/=t;
	ans[x]=b,ans[y]=a;
	for(int i=1;i<=5;i++) printf("%lld ",ans[i]);
	return 0;
}
```

---

## 作者：WZWZWZWY (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P6485)

## 题目描述

你有 $5$ 种数字： $1,2,3,4,5$。

你需要从中选取尽量少的数字，使得这些数之和的平均数为 $P$。

**需要注意的是，这 $5$ 种数字每种有任意多个。**

------------

看着很简单，但是数据范围：$P$ 的小数位数 $\le 9$。

首先很容易得到这个式子：$P=\frac{a+2b+3c+4d+5e}{a+b+c+d+e}$。

$a\sim e$ 就是 $1\sim 5$ 每种数的数量。

显然，**分子和分母一定都是整数**（数量不可能是小数）。并且**分子一定大于等于分母**。

然后题目要求 $(a+b+c+d+e)$ 最小，问 $a\sim e$ 的值。

### 怎么找到分子和分母？

这个思路其实很简单，不过很多人都想复杂了。

比如我们的 $P=2.4$，**整数的分子和分母**可以是多少？

显然 $P=2.4=\frac{2.4}{1}=\frac{24}{10}$。

那么我们又想让**分母最小**，怎么做？

$P=\frac{24}{10}=\frac{12}{5}$。化简就可以了。

到这里你有没有豁然开朗？~~如果有，你可以点个赞。~~

那么还剩一个问题：

### 怎么找出一组具体的 $a\sim e$ 的值？

我们思考分数的实质：实际上是**把 分子 分成了 分母 个数字**。

我们可以把分子先分成若干个 $1\sim 5$ 中**最大的数**（$5$），如果有剩下的数就把它单独拿出来（那么它一定小于 $5$）。

那么现在数的数量一定小于等于真正要的数量（分母）。

然后我们可以把 $5$ 拆开凑数量，不够就多拆几个，再不够就把不够 $5$ 的数拆了。

### 坑点

不开 `long long` 见祖宗。

`double` 最多可能会乘 $10^9$，位数不够，所以需要直接用字符串读入并转换成整数。

### 代码

```
#include <bits/stdc++.h>
#define int long long
using namespace std;

int ans[6];
signed main() {
	ios::sync_with_stdio(0);
	string s;
	int cnt = 1; // 分子分母都乘上的数（10 的 某次方）。也可以表示为后来的分母（因为一开始分母为1） 
	int q = 0; // 分子（整数） 
	cin >> s;
	for (int i = 0; i < s.length(); i++) { // 将字符串转为数字（乘上cnt后变成的整数） 
		if (cnt > 1) cnt *= 10;
		if (s[i] == '.') {
			cnt *= 10; // 此时cnt=10，说明后面都是小数位 
			i++; // cnt=10的时候包括了小数点后第一位 
			q = q * 10 + s[i] - '0';
		} else {
			q = q * 10 + s[i] - '0';
		}
	}
    
	int gcd = __gcd(q, cnt); // c++自带函数求最大公因数 
	q /= gcd;
	cnt /= gcd;
	//cout << q << " " << cnt << "\n";
	// 接下来把 q（分子） 拆成 cnt（分母） 个数，先分成许多 5 （可能有余数），如果凑不够 q 个数就再根据需要将 5 拆分为1 4、1 1 3、1 1 1 2 或 1 1 1 1 1。还不够就把余数也拆了。 
	//注：拆分方法不唯一 
	ans[5] += q / 5;
	if (q % 5) ans[q % 5] ++;
	int num = ans[5] + ans[q % 5]; // 现在共拆成了几个数 
	for (;ans[5];) {
		if (cnt - num > 4) { // 一次最多增加 4 个数 
			ans[5] --;
			ans[1] += 5; // 拆分成 5 个 1，实际增加了 4 个数 
			num += 4;
		} else {
			ans[5] --;
			ans[1] += cnt - num;
			ans[5 - (cnt - num)] ++; // 拆成许多个 1 和 1 个其他的数
			num = cnt;
			break;
		}
	}
	if (num != cnt && q % 5) { // 5 都拆完了也不够，就把余数（q % 5）也拆开 
		ans[q % 5] --;
		ans[1] += cnt - num;
		ans[q % 5 - (cnt - num)] ++;
	}
	for (int i = 1; i <= 5; i++) cout << ans[i] << " ";
}
```

稍微缩减之后还是蛮短的：

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int ans[6], cnt = 1, q;
signed main() {
	string s; cin >> s;
	for (int i = 0; i < s.length(); i++)
		if (s[i] == '.') {
			cnt = pow(10ll, s.length()-i-1);
			q = q * 10 + s[++i] - '0';
		} else q = q * 10 + s[i] - '0';
	int gcd = __gcd(q, cnt);
	q /= gcd; cnt /= gcd;
	ans[5] += q / 5;
	if (q % 5) ans[q % 5] ++;
	int num = ans[5] + ans[q % 5];
	while(ans[5] && cnt != num) {
		ans[5] --;
		ans[1] += min(cnt - num, 4ll); //4ll就是long long类型的数字4，min函数必须两个参数类型相同
		ans[5 - min(cnt - num, 4ll)] ++;
		num += min(cnt - num, 4ll);
	}
	if (num != cnt && q % 5) {
		ans[q % 5] --;
		ans[1] += cnt - num;
		ans[q % 5 - (cnt - num)] ++;
	}
	for (int i = 1; i <= 5; i++) cout << ans[i] << " ";
}
```

还有什么问题可以在评论区问我哦。

---

## 作者：sipu6174 (赞：3)

我们使用 $\lfloor P \rfloor$ 与 $\lceil P \rceil$ 来逼近 $P$：

观察 $P$ 的小数部分，可以得到：
$$\lfloor P \rfloor:\lceil P \rceil=(\lceil P \rceil-P):(P-\lfloor P \rfloor)$$

因为最多9位小数，将 $(\lceil P \rceil-P)$ 与 $(P-\lfloor P \rfloor)$ 乘上1e9，对两者求```gcd```即可。

**注意当$P$为整数时需要特判**。

担心浮点误差？使用```Round```即可解决问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
double t,rem;
long long x,y,g,lower,v[10];
int main(){
   cin>>t;
   rem=t-floor(t);//小数部分
   lower=floor(t);//整数部分（下边界）
   if(rem==0){v[lower]=1;goto kkk;}//特判
   rem*=1e9;rem=round(rem);//消除浮点误差
   x=1e9-rem;y=rem;//即比式右边两项
   g=__gcd(x,y);//求gcd
   x/=g,y/=g;
   v[lower]=x;
   v[lower+1]=y;//求出答案
   kkk:;
   for(int i=1;i<=5;i++) cout<<v[i]<<" ";
   return 0;
}
```


---

## 作者：wunaidedanjuan (赞：1)

### 题意

从 $1\sim5$ 五种数字选若干，使其平均值为 $P\left(1\le P \le 5\right)$，求**所选数字个数最少**的一种选择方法。

### 思路分析

已知平均值 $P=\dfrac{所选数字总和}{所选数字个数}$，显然，当**所选数字总和与所选数字个数互质**时满足所选数字个数最少的条件。所以我们首先要把 $P$ 的最简分子和最简分母求出来。

已知总和和个数后，我们要考虑如何选数。不妨设 $P$ 的最简分子、分母分别为 $a$，$b$，由于 $P$ 值最大为 $5$，所以可知：**分母中包含的 $5$ 的个数小于等于分子**，即：**$a\div5\le b$**。由此我们可以得到 $ans_5=a\div5$，若 $a$ 不能被 $5$ 整除，则将其余数的 $ans$ 值加 $1$。若此时所选的数的个数仍小于 $b$，可以将所选的较大的数 $c$ 拆分成 $1$ 和 $c-1$，直到所选数个数等于 $b$。

### 代码呈现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,M=110,inf=0x3f3f3f3f3f3f;
int ans[6];
inline int gcd(int x,int y)
{
	if(!y)
		return x;
	return gcd(y,x%y);
}
inline void read(int &x)
{
	int d=1;
	char s=getchar();
	x=0;
	while(s<'0'||s>'9')
	{
		if(s=='-')
			d=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=x*10+s-'0';
		s=getchar();  
	}
	x*=d;
	return;
}
signed main()
{
	int a,b=1e9,c;
	double x;
	scanf("%lf",&x);
	a=x*b;
	c=gcd(a,b);
	while(c!=1)
	{
		a/=c;
		b/=c;
		c=gcd(a,b);
	}
	ans[5]=a/5;
	b-=a/5;
	a%=5;
	if(b>0)
	{
		ans[a]++;
		b--;
	}
	while(b>0)
	{
		c=5;
		while(ans[c]==0)//寻找最大的数拆分 
			c--;
		ans[c]--;
		if(b>=c)
		{
			ans[1]+=c;
			b-=c-1;
		}
		else
		{
			ans[1]++;
			ans[c-1]++;
			b--;
		}
	}
	for(int i=1;i<=5;i++)
		printf("%lld ",ans[i]);
	return 0;
}
```

---

## 作者：postpone (赞：1)

**核心思路是用 $\lfloor p \rfloor$ 和 $\lceil p \rceil$ 不断逼近所给的 $p$。**

设 $res$ 为现有的数字的和，$cnt$ 为现有的数字的个数， $l=\lfloor p \rfloor$，$r=\lceil p \rceil$。

将 $res$ 和 $p\cdot cnt$ 做比较，若不相等，则再比较现有的 $res$ 加上 $l$ 或 $r$ 哪个更接近 $p\cdot cnt$，将更接近的加入现有的数字。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int num[6];
int l, r;
double p;

void solve()
{
    cin >> p;
    l = int(p), r = l + 1;
    double res = 0, cnt = 0;
    while (1)
    {
        if (res == cnt * p and res!=0 and cnt!=0)
            break;
        cnt++;
        double a = abs(res - cnt * p + l), b = abs(res - cnt * p + r);
        if (a <= b)
            num[l]++, res += l;
        else
            num[r]++, res += r;
    }
    for (int i = 1; i <= 5; i++)
        cout << num[i] << ' ';
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
        solve();
    return 0;
}

```

---

## 作者：Bloodwonderland (赞：1)

## 大致思路：

简而言之，本题看似有五个未知数，但是实际上只有两个：所有数的和，以及所有数的数量。

何出此言呢？由于此题只需输出任意一种最优方案，因此对于答案提交而言，只要保证总和及数量不变，都属于正确输出。

而题目只要求输出数量最小的情况，因此，只要保证总和最小并且平均数为题目所求答案，**就同时保证数字总数最小。**

所以本体的思路就是，在确定了总和及平均数的情况下，削减数字总数。

## 详解：

首先，我们需要确定数字的总和，也就是说，要确定输入的浮点数最小在乘多少倍之后能成为整数，这里我通过定义一个判断是否为整数的布尔函数，并用循环来实现。

```cpp
bool judge(double n)
{
	int i=n;
	if(i==n) return false; // 输出否是为了中断循环
	else return true;
 } 

int main()
{
	double n,sum;// sum 表示最终的整数
	cin>>n;
	for(int i=1; judge(sum); i++) sum=n*i;
}
```

代码见上。



------------

接着是重点，如何对已知的数字和与平均数进行数量的判断。

其实这里说白了就是一个脑筋急转弯：假设我现在有若干个一，那么我每将五个 一替换成一个五，总数量就减少了四，替换成四、三、二同理。

因此，只要假设一开始所有数都是一，然后利用若干次整除运算，将超出数量要求的一依次替换成若干个二、三、四、五就是正确答案啦。


## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool judge(double n)
{
	int i=n;
	if(i==n) return false;
	else return true;
 } 
int main()
{
	double n,sum;
	int one=0,two=0,three=0,four=0,five=0,tot;//tot是实际的数字数量
	cin>>n; 	
	for(int i=1; judge(sum); i++) sum=n*i;
	one=sum; //假定所有数字均为1。
    	tot=sum-sum/n;//sum/n就是所需数量。
	five+=tot/4; one-=5*five; tot-=4*five;
	four+=tot/3; one-=4*four; tot-=3*four;
	three+=tot/2; one-=3*three; tot-=2*three;
	two+=tot; one-=2*two;
	printf("%d %d %d %d %d", one, two, three, four, five);
	return 0;
}
```


---

## 作者：XiaoHongChong (赞：0)

### 方法
首先，我第一眼想到的方法是 $\frac{sum}{n} = p$ ，$n$ 是选的个数，$sum$ 是选的数的总和，况且 $sum$ 和 $n$ 都是整数。  
要注意 $P$ 是一个 $9$ 位小数，为了计算方便，可以把 $P \times 10^9$，为了保证答案正确，所以 $n = 10^9$。   
接下来，再把 $P$ 和 $n$ 同时除以它们的最大公约数就好算多了。
### $9$ 分代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int f[10];
ll p, cnt, gcd;
double P;
int main()
{
	cin >> P;
	cnt = 1e9;
	P *= cnt;
	p = P;
	gcd = __gcd(p, cnt);
	cnt /= gcd, p /= gcd;
	for (int i = 5; i >= 1; i--)
	{
		f[i] = p / i;
		p = p % i;
	}
	for (int i = 1; i <= 5; i++)
		cout << f[i] << " ";
	return 0;
}
```
把这段代码递交上去，只有 $9$ 分。
### 原因
上面的代码得 $9$ 分是因为选的数字个数不是 $n$ ，比如输入 $2.4$ 就会有错误，~~我就懒得演示了。~~   
我们可以每取一个数字就计算一个，最后再调整，经过计算，可以发现：  
$$f_i=f_{i - 1}+f_1(i > 1)$$
### AC代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int f[10];
ll p, cnt, gcd;
double P;
int main()
{
	cin >> P;
	cnt = 1e9;
	P *= cnt;
	p = P;
	gcd = __gcd(p, cnt);
	cnt /= gcd, p /= gcd;
	for (int i = 5; i >= 1; i--)
	{
		f[i] = p / i;
		p = p % i;
		cnt -= f[i];
	}
	if (cnt > 0)
		for (int i = 5; i >= 2; i--)
			while (cnt > 0 && f[i] != 0)
				f[i]--, f[i - 1]++, f[1]++, cnt--;
	for (int i = 1; i <= 5; i++)
		cout << f[i] << " ";
	return 0;
}
```

---

## 作者：djh0314 (赞：0)

[**洛谷**](https://www.luogu.com.cn/problem/P6485)。

## 题意

选出若干个在 $1\sim 5$ 的整数，使其平均数为 $P$。

$P$ 是一个 $1\sim 9$ 位的小数。

问选出的数最小的方案数。

## 分析

我们可以发现 $P=\frac{sum}{cnt}$，$sum$ 为和，$cnt$ 是选出的数的个数。

我们就有了两个方式，第一种是使其平均数不断接近 $P$，这也就有了被卡精度的问题。

第二种，我们凑出最小的 $cnt$，再用 $cnt$ 个数凑出 $sum$。

要使 $cnt$ 最小，那么我们的 $sum$ 显然也是最小。

我们的 $sum$ 明显是一个整数，我们先使我们的 $P$ 乘上 $10^{9}$，再使其下降，这也就避免了被卡精度。

此时，我们的 $cnt$ 也就是 $10^{9}$，为了使其最小，我们将 $cnt$ 与此时的 $sum$ 除上其最小公倍数。
~~~cpp
int cnt=1000000000;
P*=cnt;
int T=P,gcd=__gcd((int)P,cnt);
T/=gcd,cnt/=gcd;
~~~

此时，我们找到了我们的最小 $cnt$，接下来就来到了解决，用 $cnt$ 个数凑出 $sum$。

我们可以用背包解决，但是 $sum$ 可能会很大，限制了此想法。由此，我们分析一下，我们最容易解决的方案是什么。

我们可以找到在当前 $sum$ 下的最小的凑成的数量，令其为 $tot$。

怎么做呢，我们从最大选起，能选就选，就能得到我们的 $tot$，以及每个数被选的个数。

我们思考一下为什么。

令 $f_i$ 表示凑成 $i$ 的选择的最小数字的量，而这个 $f$ 应该是单调不降的，否则，这个下降的下标为 $j$（$j\ge i$），倘若在选择 $f_j$ 是选择了一个不为 $1$ 的，我们就可以将其分成 $x-1$ 与 $1$。然而全选 $1$ 在 $i>1$ 时明显并不是最优的。

~~~cpp
int tot=0;
for(int i=5;i;--i) {
	a[i]=T/i;
	T=T-i*a[i];
	tot+=a[i];
}
~~~

这时，我们的 $tot$ 显然是小于等于我们的 $cnt$。        
我们需要使数量增加。

显然，我们需要使一些数分裂成更多的数。

为了使我们的分解更加便于操作，我们可以从最大开始，不断分出 $1$，这样我们就可以不断使 $tot+1$。

从小开始也可行，但是因为我们上面是从大选起，能选就选，因此，只有 $a_5$ 是可能大于 $1$ 的，因此从 $5$ 开始会对我们的 $tot$ 有更大的影响，更加快捷。（但是只有 $5$ 个好像都无所谓？）

在正确性上，只要我们存在方案，那么我们必然可以凑出，因为我们是一步一步加的。

~~~cpp
while(tot<cnt) {
	int id=0;
	for(int i=2;i<=5;++i) if(a[i]) id=i;
	int dt=cnt-tot;
	if(a[id]>=dt) {
		a[id]-=dt;
		a[1]+=dt;
		a[id-1]+=dt;
		tot+=dt;
	}else {
		a[1]+=a[id];
		a[id-1]+=a[id];
		tot+=a[id];
		a[id]=0;
	}
}
~~~

---


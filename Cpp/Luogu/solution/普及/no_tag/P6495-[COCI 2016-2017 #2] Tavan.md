# [COCI 2016/2017 #2] Tavan

## 题目描述

Željko 正在读奶奶的一封信。由于年代久远，信中的一些单词已经无法辨认。他选出了一个长度为 $n$ 的单词，将其中 $m$ 个无法辨认的字母替换为 `#`。

对于每一处 `#`，奶奶都给出了 $k$ 个字母，该处原先的字母是这 $k$ 个字母之一。所有可能的单词中**按字典序排列**的第 $x$ 个，即为原先的单词。

请你帮助他们找出原先的单词。

## 说明/提示

#### 样例 1 解释

所有可能的单词按字典序排列如下：

- `pololjeni`
- `pololjeui`
- `pololjezi`
- `poooljeni`
- `poooljeui`
- `poooljezi`
- `posoljeni`
- `posoljeui`
- `posoljezi`

第 $7$ 个单词为 `posoljeni`。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 500$，$1\le m\le n$，$1\le k\le 26$，$1\le x\le 10^9$。

所有字符串中仅包含小写字母和 `#`。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T2 Tavan_**。

## 样例 #1

### 输入

```
9 2 3 7
po#olje#i
sol
znu ```

### 输出

```
posoljeni```

## 样例 #2

### 输入

```
4 1 2 2
#rak
zm ```

### 输出

```
zrak ```

# 题解

## 作者：FZY_CZY (赞：3)

# 题意
感觉这道题的题意可能一开始有一点晦涩难懂（反正我是这样的）。

[题目](https://www.luogu.com.cn/problem/P6495)。我来按我的理解来解释一下这道题。首先我们有一个字符串，但是这个字符串中包括了一些字符 `#`，这些 `#` 字符按照次序对应下面的字符串，而这个字符串里面的所有字符就是这个 `#` 号字符可以替换的备选。

现在要将所有的替换情况列举出来，然后将这些情况按字典序来排序，排序之后输出字典序第 $x$ 个字符串（如果有什么不明白的点可以私信或者在评论区问，一般来说一天内会有回复）。
# 思路
## 思路 1
其实，当我们对于题意的理解足够的时候，这道题的思路就会很自然的浮出水面。

我们考虑到字典序，所以我们可以先把字符串（第 $3$ 行到第 $3+m$ 行）进行一个排序，然后组合，组合后找到第 $x$ 位。
## 思路 2
我再提供另一种思路，那就是转换思想（应该是这样的）。

我们可以把我们这些不同的组合状态转化成一个 $k$ 进制数，然后直接拆分 $x$，把拆分过后的结果填入原本的字符串即可。

我在处理字符串的时候有一个小习惯，喜欢的可以学习一下，就是 `s=" "+s;`，这样我们在处理字符串 `s` 的时候下标可以从 $1$ 开始，符合一部分人的习惯。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510;
int n,m,k,x,c[N],cur;
string s,a[N];
int main(){
	cin>>n>>m>>k>>x;
	cin>>s;
	s=" "+s;
	for (int i=1;i<=m;i++)
	{
		cin>>a[i];
		sort(a[i].begin(),a[i].end());
	}
	x--;
	while (x)
	{
		c[++cur]=x%k;
		x/=k;
	}
	for (int i=n,j=m,k=1;i>=1;i--)
		if(s[i]=='#') s[i]=a[j--][c[k++]];
	for (int i=1;i<=n;i++) cout<<s[i];
	return 0;
}
``````
思路 1 的代码就不给了，完结撒花！！！

---

## 作者：chu_K (赞：3)

## Sol:
是一道简单的**字符串**题。

题目大意：给你一个由 `#` 与小写字母组成的字符串，每个 `#` 有 $k$ 种字母可填，试求所有方案字典序排列后的第 $x$ 种方案。

因为是按字典序排列，所以我们可以将 $m$ 个长度为 $k$ 的字符串**一一排序**。然后找每个待更新的 `#` 要更新的字符的位置，最后更新字符串即可。

建议黄。
## Code:
```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <algorithm>
#include <iostream>
#define int long long
using namespace std;
int x,m,k,n,kk,kkk;
int a[501],d[501];
char s[501],ss[501][501];

signed main()
{
        cin >> n >> m >> k >> x;
        x--;
        kk=0;
        scanf("%s",s+1);
        for(int i=1; i<=n; i++)
                if(s[i]=='#')
                        d[kk++]=i;//d数组表示#的位置。

        for(int i=0; i<m; i++)
        {
                scanf("%s",ss[i]);
                sort(ss[i],ss[i]+k);
        }//因为按字典序，所以要排序。

        kk=0; kkk=1;//kkk就是位值。
        while(kkk*k<=x)
                kkk=k*kkk,kk++;

        while(x && kk>=0)
        {
                a[kk]=x/kkk;//a数组表示在ss[i]中取第几位字符。
                x-=a[kk--]*kkk;
                kkk/=k;
        }

        for(int i=0; i<m; i++)
                s[d[i]]=ss[i][a[m-i-1]];//更新字符串。
                
        puts(s+1);
}

```


---

## 作者：Ivan422 (赞：1)

难度：黄题。

首先我们分析样例。我们发现修改的影响仅在 `#` 字符位置上。那么，我们考虑不管其他字符。按照字典序，我们发现，高位贡献高，低位贡献低。那么，我们再考虑把替换的字符排序，再映射到数字上，在样例中，对于第 $1$ 个 `#` 字符，`l` 就可以映射到 $0$，`o` 就可以映射到 $1$，`s` 就可以映射到 $2$。对于第 $2$ 个 `#` 字符，`n` 就可以映射到 $0$，`u` 就可以映射到 $1$，`z` 就可以映射到 $2$。

则按照我们刚才的分析，样例中所有可能的单词可以先去掉无关字符，剩下的映射，就是这样的：
- `00`
- `01`
- `02`
- `10`
- `11`
- `12`
- `20`
- `21`
- `22`

我们发现，这正好是 $0$ 到 $k^2-1$ 的所有数的 $k$ 进制。所以，我们考虑将 $x-1$ 转换成 $k$ 进制数，比如样例转换成 $20$，然后根据读入映射回去，最后输出即可。

但是我们显然发现一个问题，$1$ 进制怎么办？符合题意的 $x$ 是必须为 $1$ 的，所以不会有问题。还有一个问题，位数不够怎么办？自动补全 $0$ 即可。

所以，这道题我们就做完了。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int n,m,K,x,c[N],cur;
string s,a[N];
int main(){
	cin>>n>>m>>K>>x;
	cin>>s;s=" "+s;
	for(int i=1;i<=m;i++){
		cin>>a[i];
		sort(a[i].begin(),a[i].end());
	}
	--x;
	while(x){
		c[++cur]=x%K;
		x/=K;
	}
	for(int i=n,j=m,k=1;i>=1;i--){
		if(s[i]=='#')s[i]=a[j--][c[k++]];
	}
	for(int i=1;i<=n;i++)cout<<s[i];
	return 0;
}
```
这份代码首先是对 $m$ 个字符串排序，就可以建立映射，求出最小字典序。

接着，我们考虑倒序替换，这样就不用倒着取二进制，而且有自动补全。其中，$k$ 变量负责从低位到高位赋值，对应着后往前的字符 `#`。而 $j$ 变量则是按照赋值的规则随着 $i$ 而逐渐减少。注意这里我为了方便处理字符串，给 $s$ 字符串前面加了一个空格，这时就不能直接输出，而是一位一位输出。

---

## 作者：Frozen_Ladybug (赞：0)

### 题意

小 Z 一直在读他奶奶的旧信，并发现了一个长度为 $N$ 的单词。由于溢出的墨水，他看不清单词的内容，在将看不清的 $M$ 个字母用 ```#``` 替换后，他在一张纸上重新写了这个词。

对于看不清的这 $M$ 个字母，奶奶给了他 $K$ 种可能，其中确定是按字典序排列的第 $X$ 个。根据条件，确定原来的这个词。

### 分析

首先我想到的是暴力回溯，将所有可能的结果列出来后直接用 dfs 去搜索。代码见下。

```cpp
vector<char> ans;
int cnt;
void dfs(int num){
    //深搜，其中num-1等于已知字母的个数
	if(num>M){
		cnt++;
		if(cnt==X){
			for(int i=0,j=0;i<N;i++){
				if(S[i]=='#'){
					putchar(ans[j]);
					j++;
				}else putchar(S[i]);//如果是#就加上这个字母然后输出,否则直接输出
			}
			exit(0);
		}
		return;
	}
	for(int i=0;i<K;i++) {
		ans.push_back(s[num][i]);
		dfs(num+1);//找加上这个字母后的词的可能性
		ans.pop_back();
	}
}
//在运行时执行dfs(1),从根节点即没有字母开始搜索即可
```

但其实我们可以做得更简单，在每一层节点放一个编号，则最后一层编号的第 $X$ 个所对应路径即为答案，沿着路径回溯就能找到原词。

这种操作利用带余除法就很容易完成了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int N,M,K,X;
char S[505],s[505][30],ans[505];
int main() {
	scanf("%d%d%d%d",&N,&M,&K,&X);
	scanf("%s",S);
	for(int i=1;i<=M;i++) {
		scanf("%s",s[i]);
		sort(s[i],s[i]+K);
	}//先将可能性排序
	for(int i=M;i>=1;i--) {
		int t=(X-1)%K;
		ans[i]=s[i][t];
		if(X%K==0) X/=K;
		else X=X/K+1;
	}//如上带余除法想法
	for(int i=0,j=1;i<N;i++) {
		if(S[i]=='#') {
			putchar(ans[j]);
			j++;
		} else putchar(S[i]);
	}//直接替换并输出
	return 0;
}
```

---

## 作者：Alter_Native (赞：0)

## 思路

把字符串所有的情况都替换出来，再排序肯定会超时，因为情况总数最多会有 $26^{100}$ 种。

此时我们就想到了进制转化。因为 $k \le 26$，所以可以将一种可能的情况用 $m$ 位 $k$ 进制 表示，每一位上的数是几就表示在字符串中，这一个 `#` 对应的字符在可能的所有字符里面是第几大的。

- 为什么这样表示一个状态？

因为这样表示的话，表示这个状态的数的大小规则和字典序比较是一样的，都是先比较高位，再比较低位。这样就可以使我们很方便的找到第 $x$ 大的数。由于本题的 $x$ 范围较大，所以使用进制转换的思想是很好的。

### 接下来给具体步骤：

1. 输入各个条件，并将每一个未知字符可能的列表按从小到大排序，方便确定每一位上的数字。

2. 将 $x-1$ 转化成 $k$ 进制，每转化一位，就在初始字符串中从后往前找一个 `#`，将它替换成这一位上的数字所对应的可能列表中的字母。具体实现看代码。

3. 将初始字符串中 $k$ 进制数上是 $0$ 的那些位全都设为可能列表中最小的那个字符。

4. 最后输出替换后的原始字符串即可。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,m,k,x,l,kjz;
string s,t[502];

int main(){
	cin>>n>>m>>k>>x>>s;
	for(int i=1;i<=m;i++){
		cin>>t[i];
		sort(t[i].begin(),t[i].end());
	}
	int nc=s.size()-1;
	x--;
	while(x){
		kjz=x%k;
		x/=k;	
		while(s[nc]!='#'){
			nc--;
		}l++;
		s[nc]=t[m-l+1][kjz];
		nc--;
	}
	bool flag=1; 
	for(int i=nc;i>0;i--){
		if(s[i]=='#'){
			l++;
			s[i]=t[m-l+1][0];	
		}
	}
	cout<<s;
	return 0;
}
//qingchenMC	
```

[AC Record](https://www.luogu.com.cn/record/200368954)

---

## 作者：lienchan_16 (赞：0)

## 背景 / 思路 

这题是我在主页随机的时候刷到的。算是比较简单的暂无评定，~~不知道为什么还没评分~~。

简单来说就是按要求用所给字母代替输入字符串里的 `#`，然后进行输出。

可能想不到的地方就是如何对每行输入进行字典序，然后倒序判断选择第几个字母进行相除和取余就行了。

------------

话不多说，见代码：

```cpp
#include<bits/stdc++.h>
#define N 510
using namespace std;
string a;
char b[N][27];
int main(){
	int n,m,k,x;
	cin>>n>>m>>k>>x>>a;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=k;j++) cin>>b[i][j];
		sort(b[i]+1,b[i]+k+1);	//对每行进行字典排序
	} 
	for(int i=n-1,j=m;i>=0;i--){ //倒叙填充，顺序写比较麻烦
		if(a[i]=='#'){
			int sum=x%k;
			if(sum==0) sum=k;
			a[i]=b[j][sum];
			x/=k;
			if(sum!=k) x++; //余数不为0加1
			j--;
		}
	}
	cout<<a;
 return 0;
}

```

建议评橙。

---

## 作者：_czy (赞：0)

### 思路：

这道题其实就是一个进制转换，不明白为什么大家都那么复杂，这不就是363 Bytes 的事吗？

因为每位都会有 $k$ 个选择，所以我们可以将 $x-1$ 转换成 $k$ 进制，一一对应即可。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x,a[503],cnt,l;
char c[503],s[503][30];
int main(){
	scanf("%d%d%d%d%s",&n,&m,&k,&x,c+1);
	for(int i=1;i<=m;i++){
		scanf("%s",s[i]+1);
		sort(s[i]+1,s[i]+k+1);
	}
	x--;
	while(x)a[++cnt]=x%k,x/=k;
	for(int i=n;i;i--){
		if(c[i]^'#')continue;
		c[i]=s[m--][a[++l]+1];
	}
	printf("%s",c+1);
}
```

---

## 作者：JK_LOVER (赞：0)

## 题意
给你 $m$ 个长度为 $k$ 的串，找出字典序第 $x$ 小的排列。
## 分析
因为不是 $\#$ 的位置是不能影响字典序的，所以字典序是由 $\#$ 号位确定的。因为每个串的长度确定，所以其实就是把 $10$ 进制转化为 $k$ 进制。
$$
x_{(10)} = \sum_i^n k^i \times Ans[i] = x_{(k)} 
$$
时间复杂度为 $O(m \log k)$ 。因为前面还有很多前导零，所以要算出
$k^m$ ，而这一过程是要爆 $int$ 的，就用一些奇技淫巧来限定 $k^m$ 的大小。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}
int qpow(int x,int b)
{
	int a = 1;
	for(;b;b>>=1,x*=x)
	if(b&1) a*=x;
	return a;
}
const int inf = 1999999999000;
int mul(int x,int y)
{
	if(x >= inf/y) return inf+1;
	else return x*y;
}
const int N = 5100;
int n,m,k,x,Pow[N],Ans[N],top;
char ch[N],S[N][30];
signed main()
{
	n = read();m = read();k = read();x = read();
	cin>>ch+1;
	for(int i = 1;i <= m;i++)
	cin>>S[i],sort(S[i],S[i]+k);
	Pow[0] = 1;
	x--;
	for(int tot = 1;tot <= m;tot++)
	{
		Pow[tot] = mul(Pow[tot-1],k);
	}
	for(int i = m-1;i >= 0;i--)
	{
		Ans[++top] = x/Pow[i];
		x %= Pow[i];
	}
	top = 0;
	for(int i = 1;i <= n;i++)
	{
		if(ch[i] != '#')
		cout<<ch[i];
		else cout<<S[++top][Ans[top]];

	}
	printf("\n");
	return 0;
}
```
[地址](https://www.luogu.com.cn/blog/xzc/solution-p6495)


---


# [COCI 2016/2017 #2]  Prosječni

## 题目描述

Slavko 想在一个 $n\times n$ 的矩阵内填入 $n^2$ 个互不相等的正整数，使其满足：

- 每行 $n$ 个数的平均数是该行内的一个整数。
- 每列 $n$ 个数的平均数是该列内的一个整数。
- 对于矩阵中的任意一个元素 $a_{i,j}$，都有 $1\le a_{i,j}\le 10^9$。

请你帮助他找出任意一种可行的方案。

## 说明/提示

#### 样例 1 解释

各行的平均数分别为 $2,5,8$，均为相应行内的一个整数。

各列的平均数分别为 $4,5,6$，均为相应列内的一个整数。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 100$。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T4 Prosječni_**。

## 样例 #1

### 输入

```
3 ```

### 输出

```
1 2 3
4 5 6
7 8 9 ```

## 样例 #2

### 输入

```
2 ```

### 输出

```
-1 ```

# 题解

## 作者：Wenoide (赞：4)

- 当 $n=1$ 时，输出 $1$ 即可。
- 当 $n=2$ 时，显然无解。
- 当 $n\ge3$ 时：

	按照题目要求，我们可以构造一个矩阵，使得：
    
	- 每行的平均数均为该行的倒数第二个数。
	- 每列的平均数均为该列的倒数第二个数。

------------

为了填入的数尽可能小，不妨令第一行的前 $n-1$ 个数为 $1,2,3,\dots,n-1$。
    
若要使第一行的平均数为其倒数第二个数，则第一行的最后一个数为 $\frac{(n-1)n}{2}$。
    
将第一行的每个数加上 $\frac{(n-1)n}{2}$，即可得到第二行。
    
不难证明，第二行的平均数也是其倒数第二个数。
    
类似地，可以得到矩阵的前 $n-1$ 行。
    
若要使第一列的平均数为其倒数第二个数，则第一列的最后一个数为$1+\frac{(n-2)(n-1)n(n+1)}{4}$。
    
类似地，可以得到最后一行的后 $n-1$ 个数。
    
不难证明，最后一行的平均数也是其倒数第二个数。

------------

最终的矩阵如下：
    
| $1$ | $2$ | $3$ | $\cdots$ | $n-1$ | $\frac{(n-1)n}{2}$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1+1\times\frac{(n-1)n}{2}$ | $2+1\times\frac{(n-1)n}{2}$ | $3+1\times\frac{(n-1)n}{2}$ | $\cdots$ | $n-1+1\times\frac{(n-1)n}{2}$ | $\frac{(n-1)n}{2}+1\times\frac{(n-1)n}{2}$ |
| $1+2\times\frac{(n-1)n}{2}$ | $2+2\times\frac{(n-1)n}{2}$ | $3+2\times\frac{(n-1)n}{2}$ | $\cdots$ | $n-1+2\times\frac{(n-1)n}{2}$ | $\frac{(n-1)n}{2}+2\times\frac{(n-1)n}{2}$ |
| $\vdots$ | $\vdots$ | $\vdots$ | $\ddots$ | $\vdots$ | $\vdots$ |
| $1+(n-2)\times\frac{(n-1)n}{2}$ | $2+(n-2)\times\frac{(n-1)n}{2}$ | $3+(n-2)\times\frac{(n-1)n}{2}$ | $\cdots$ | $n-1+(n-2)\times\frac{(n-1)n}{2}$ | $\frac{(n-1)n}{2}+(n-2)\times\frac{(n-1)n}{2}$ |
| $1+\frac{(n-2)(n-1)n(n+1)}{4}$ | $2+\frac{(n-2)(n-1)n(n+1)}{4}$ | $3+\frac{(n-2)(n-1)n(n+1)}{4}$ | $\cdots$ | $n-1+\frac{(n-2)(n-1)n(n+1)}{4}$ | $\frac{(n-1)n}{2}+\frac{(n-2)(n-1)n(n+1)}{4}$ |

------------

这个矩阵中是否存在相同的数？

$\frac{(n-1)n}{2}>n-1$ 在 $n\ge 3$ 时恒成立。那么，每行的 $n$ 个数都是递增的。

不难发现，第 $2,3,\dots,n-1$ 行的第一个数均大于上一行的最后一个数。

$1+\frac{(n-2)(n-1)n(n+1)}{4}>\frac{(n-1)n}{2}+(n-2)\times\frac{(n-1)n}{2}$ 在 $n\ge 3$ 时恒成立。那么，第 $n$ 行的第一个数也大于上一行的最后一个数。

所以，矩阵中不存在相同的数。

当 $n$ 取最大值 $100$ 时，矩阵中的最大数 $\frac{(n-1)n}{2}+\frac{(n-2)(n-1)n(n+1)}{4}=24502500\le 10^9$。也满足要求。

------------

参考代码：

```
#include<cstdio>
int main(){
	int n;
	scanf("%d",&n);
	if(n==1){
		puts("1");
		return 0;
	}
	if(n==2){
		puts("-1");
		return 0;
	}
	int k1=(n-1)*n/2,k2=(n-2)*(n-1)*n*(n+1)/4;
	for(int i=1;i<n;++i){
		for(int j=1;j<n;++j){
			printf("%d ",j+(i-1)*k1);
		}
		printf("%d\n",i*k1);
	}
	for(int j=1;j<n;++j){
		printf("%d ",j+k2);
	}
	printf("%d\n",k1+k2);
	return 0;
}
```

---

## 作者：banned_xiejiayun (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6497)

#### STEP 1：简化题意

题目的意思不难理解，就是创作一个矩阵，使得每行每列的平均数都在这一行或这一列里面。

需要注意的是数字不能重复。

#### STEP 2：思路推导

题目刚读完，谁的会有些懵。

别急，观察样例：

当 $n = 3$ 时，矩阵里面的数字就是从 $1$ 到 $9$（$n^2$）顺序排列即可。
稍加思考就会想到当 $n$ 是奇数时都是如此。

**代码：**

```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= n; j++)
		cout << ++k << ' ';
	cout << '\n';
}
return 0;
```
~~完美结束~~

### 别急，那 $n$ 为偶数呢？
~~是不是突然懵了~~

当 $n = 2$ 时是无解的，但是可不要以为所有偶数都是无解的！~~如果都是无解这还能是黄题吗~~


------------

以 $n = 4$ 为例：



对于每一行来说：

由于等差数列求和公式 $n(n+1)\div2$，再用平均数的求法，即用上式除以 $n$ 也就是 $(n+1)\div2$。

由于 $n$ 是偶数（$n+1$是奇数），答案就是一个小数。

为了把平均数变成整数，就需要使平均数加 $0.5$，也就是让和加 $n\times0.5$，即 $n\div2$。


------------

对于每一列来说：

同样需要让列的平均数变成整数由于公差是 $1.5n$（本来的等差数列就有一个 $n$，为了使行的平均数变成整数又多了一个 $0.5n$），末项就变成了 $1.5n^2-1.5n+1$。

根据求和公式得出来的和化简后就是 $n(0.75n^2-0.75n+1)$，平均数就是 $0.75n^2-0.75n+1$。

由于 $n$ 是偶数，$0.75n^2$ 绝对是整数，为了使整个平均数是整数，就必须加上 $0.75n$，这一列的和就需要加上 $0.75n^2$


------------

（如下）：
```
1  2  3  6
10 11 12 15
19 20 21 24
31 32 33 36
```


**代码实现**：
```cpp
for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++){
		 k++;
		 if(i==n&&j==1)k+=n*n/4*3;
		 if(j==n)k+=n/2;
		 a[i][j]=k;
	 }
```

#### STEP 3：避开坑点：

咱们花了这么久时间可算把通项给算出来了，可是回到最基本的判断：

### 无解的情况！！！
~~是不是突然又头昏眼花~~

其实并没有多麻烦，只有 $n = 2$ 时才会无解（证明略）。

```cpp
	if(n==2){
		cout<<-1;
		return 0;
	}
```
### AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, a[110][110];
int main() {
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	if(n==2){//特判无解的情况。
		cout<<-1;
		return 0;
	}
	if (n % 2 == 1) {//n 为奇数时直接输出。
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++)
				cout << ++k << ' ';
			cout << '\n';
		}
		return 0;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++){
			k++;
			if(i==n&&j==1)k+=n*n/4*3;
			if(j==n)k+=n/2;//上面已经讲得很清楚了。
			a[i][j]=k;
		}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++)
			cout << a[i][j] << ' ';
		cout << '\n';
	}
	return 0;
}

```
结束~

---

## 作者：Tjaweiof (赞：4)

# P6497题解——Tjaweiof
### ~~一道找规律的题~~
这道题需要分类讨论：
1. 奇数
1. 偶数

## 首先，来找奇数的规律
我们知道，一个长度为奇数的等差数列，平均值是中间那个数。这样，我们就能用这样的规律，让每行每列都变成一个等差数列。

不难发现，我们只需要把 $1 \sim n \times n$ 所有数列出来，就可以得到满足要求的矩阵。
如：
```
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
```
那么奇数的代码就可以写成：
```cpp
void jishu(){
    for (int i = 1; i <= n * n; i++){
        printf("%d ", i);
        if (i % n == 0){
            printf("\n");
        }
    }
}
```

## 就这么简单？别忘了还有偶数！
偶数就不一样了，因为一个长度为偶数的等差数列，平均值是小数，不满足题目要求，需要让平均值变为整数。

我们举个简单的例子， $n=4$ 时

第一行 `1 2 3 4` 是不行的，为了方便，我们只改动最后一个数：

当 `1 2 3 6` 时平均值为 $3$，满足。

到第二行时，如果从 $4$ 开始，按原来的规律，是 `4 5 6 9`，但是我们发现 $6$ 在这里重复了，题目要求**互不相等**，所以我们可以改成 `7 8 9 12`。

第三行也是一样，`13 14 15 18`。

第四行如果还用 `19 20 21 24` 的话，列的要求就不满足了，所以我们再用处理第一行的方法，改成 `31 32 33 36`。

最后得到
```
1 2 3 6
7 8 9 12
13 14 15 18
31 32 33 36
```

$n=6$ 时也是一样
```
1 2 3 4 5 9
10 11 12 13 14 18
19 20 21 22 23 27
28 29 30 31 32 36
37 38 39 40 41 45
73 74 75 76 77 81
```
然后我们写出偶数的代码：
```cpp
void oushu(){
    int cnt = 0;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            cnt++;
            if (j == n){
                cnt += n / 2;
                printf("%d\n", cnt);
            } else if (i == n && j == 1){
                cnt += n * n / 4 * 3;
                printf("%d ", cnt);
            } else {
                printf("%d ", cnt);
            }
        }
    }
}
```
### 但是，当我们再次读题时，突然发现……“$-1$ 呢？”
接着，我们发现了 $2$，当 $n=2$ 时，输出 $-1$。
## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
void jishu(){
    for (int i = 1; i <= n * n; i++){
        printf("%d ", i);
        if (i % n == 0){
            printf("\n");
        }
    }
}
void oushu(){
    int cnt = 0;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            cnt++;
            if (j == n){
                cnt += n / 2;
                printf("%d\n", cnt);
            } else if (i == n && j == 1){
                cnt += n * n / 4 * 3;
                printf("%d ", cnt);
            } else {
                printf("%d ", cnt);
            }
        }
    }
}
int main(){
    scanf("%d", &n);
    if (n == 2){
        printf("-1");
    } else if (n % 2){
        jishu();
    } else {
        oushu();
    }
    return 0;
}

```
#### 此代码时间复杂度 $O(n^2)$，空间复杂度 $O(n)$，完美过关！

---

## 作者：Ifyoung (赞：1)

[$\Large \text{题面}$](https://www.luogu.com.cn/problem/P6497)

# 题目大意

一道构造题。

总结一下限制条件：

1. 每行的平均数要在该行中出现；

2. 每列的平均数要在该列中出现；

3. 矩阵内的数字互不相同。

看一眼数据范围，发现 $n$ 的范围只是 $[1, 100]$，而矩阵中的数不大于 $10 ^ 9$ 即可，所以操作空间还是很大的。

# 思路

首先可以发现的事情是：如果 $n$ 是 **奇数** 的话，直接从上到下，从左到右，从 $1$ 开始，每次 $+ 1$，直接填即可（参考样例 $1$）。并且，如果 $n$ 为奇数，那么最大为 $99$，而根据此方法，最后一个数最大，是 $9801$，并没有超过 $10 ^ 9$。

下面是简要证明：

可以发现填完之后，每一行每一列都是一个 **等差序列**，并且是 **奇数** 项，那么这就保证了 **该序列的平均数一定出现在该序列中**。同时，由于每次都 $+ 1$，所以矩阵中也不会有相同的数。

接下来考虑 **偶数**。

从 **奇数** 的角度出发，但是如果直接填的话，虽然还是 **等差序列**，但是“**平均数在序列中出现**”这个限制就无法满足了。所以考虑进行一些调整，并且最终尽量缩小序列的值域（为避免超过 $10 ^ 9$）。

可以发现当 $n = 2$ 时是 **无解** 的，因为任意一行，任意一列都只有两个数，如果要使 “**平均值出现在序列中**” 的话，那么只有在 **这两个数相等** 的时候才能成立，可是题目又要求不能有相同的数字，所以 **无解**（换句话说就是根本没有调整的空间）。

那么接下来考虑 $n = 4$ 的情况。

先只考虑一个序列。如果直接填，可得 $1, 2, 3, 4$，很明显，平均数不在序列中，于是进行微调。由于是“微调”，所以尽量让平均数还是在靠近中间的位置。那么我们钦定平均数为 $3$（可能有人会问为什么不是 $2$，原因是如果选了 $2$，那么比平均数小的就只有一个 $1$，对平均数负方向的贡献就只有 $2 - 1 = 1$，而 $2$ 的后面还有两个数，无法平衡），那么 $1$ 和 $2$ 对平均数负方向的贡献分别为 $2$ 和 $1$，那么第 $4$ 个数对平均值正方向的贡献就必须是 $1 + 2 = 3$，所以第 $4$ 个数就应该是 $6$。于是便得到了如下序列：$1, 2, 3, 6$。

但这只是一个序列，后面还有好多个序列要填，怎么办？

考虑一个很经典的做法，**将序列的每一项都乘上同一个数**。

正确性还是很显然的，每一项都扩大一个相同的倍数，那么平均数也会扩大相同的倍数，并且肯定也还在序列里（如果读者还是不信，请手玩几个序列）。

同时还可以发现一个性质：**将序列的每一项都加上同一个数**。

每个数都加上相同的数，那么平均数也会加上相同的数，同时依然还在序列中（这不用再证明了吧）。

那么我们就可以将第一行作为 **基底**，第二行乘 $2$ 倍，第三行乘 $3$ 倍，以此类推。然后我们就会发现，虽然每一行满足条件了，但是每一列却变成了等差数列（公差为第一行对应的那一列的那个数），并且是偶数项，是不满足题意的。

那么我们可以想到，现在每一行已经满足题意了，那么就让每一行之间 **相差的倍数** 也满足条件即可。

这里提出了“**相差的倍数**”这么一个东西，是什么意思呢？

举个例子：现在给出一个合法的序列：$1, 2, 3, 6$。计算相邻两项的差，得到 $1,1,3$。如果将 **差** 的序列乘上 $2$ 倍，再得到的新序列便是 $1, 3, 5, 11$，可以发现该序列依然合法，并且平均数还是在第 $3$ 个位置。

那么我们就让每一行之间相差的数也是一个合法的 **差** 的序列就可以了。

那么我们可以考虑填完第一行之后填第一列，然后根据每一行第一列的数，填完该行剩下的数。

那么整体上，我们要求每一行，小的数在左，大的数在右；每一列，小的数在上，大的数在下。

现在考虑当 $n = 4$ 时如何填。

首先第一行前面已经讨论过：$1, 2, 3, 6$。

由于数字不可重复，所以第一列中除了 $1$，不能再有 $2, 3, 6$，那么为了方便，此处可以暴力一点，直接取 $7$（即为 $6 + 1$），也就是 $1, 7, 13, 31$。如下：

```
 1  2  3  6
 7
13
31
```

再填第二行（同理，也可以填第二列），$7, 8, 9, 12$（鉴于在第一列，我们已经控制好了每行之间的 **差**，所以对于每一行，类比于第一行，不用乘倍数，直接按照原始的 **差的序列** 填即可）。

第三行：$13, 14, 15, 18$。

第四行：$31, 32, 33, 36$。

于是得到了：

```
 1  2  3  6
 7  8  9 12
13 14 15 18
31 32 33 36
```

（最终输出时是不用管缩进的，此处只是为了看起来整齐）

同时我们可以发现，每一列中的某个数都是上面那个数再加上 **差的序列** 的对应的那一位再乘上第一行最后一个数那么多倍。

本来第一行中 $1$ 和 $2$ 之间差 $1$，但是最后一项是 $6$，于是第一列中 $1$ 和 $7$ 之间就差了 $6$，相当于是将 **差的序列** 扩大了 $6$ 倍。

举几个例子：$8 = 2 + 1 \times 6, 15 = 9 + 1 \times 6, 36 = 18 + 3 \times 6$。

那么这样我们还可以省掉单独填第一列的操作，直接根据第一行填剩下的所有行即可。

这就是一个合法的矩阵，但可能还是会有人质疑为什么这样就一定不会重复。下面简单证明一下（可能说得有些模糊，得感性理解）。

首先每一行填的方法肯定是合法的，那么最右边的数就是这一行的最大值，而下一行的第一个数（也就是在填第一列时已经确定的数）是已经规定要比“最大值”大的。举个例子：第一行为 $1, 2, 3, 6$，我们规定第二行第一个数是 $7$，同时第二行是 $7, 8, 9, 12$，而我们第一行进行了缩放，所以第三行就刚好是 $13$，也是大于 $12$ 的。所以，这样填的方法一定是合法的（毕竟我也 $AC$ 了啊）。

但是我们可以注意到一件事，由于 $n = 4$，同时钦定第 $3$ 个数为平均数，那么前两个数对平均数负方向的贡献全部由第 $4$ 个数来承担了，那如果后面不只有一个数呢？也就是 $n$ 大于 $4$，并且是偶数的情况。

下面考虑 $n = 6$ 的情况。

还是先看第一行，我们还是以中间点右边的的那个数作为平均数，即 $1, 2, 3, 4, 5, 6$ 中的 $4$。那么前三个数对平均数负方向的贡献就是 $3 + 2 + 1 = 6$，要分给后面两个数承担。但是我们希望最后一个数（也就是最大的数）尽量小，这样才更不会超出 $10 ^ 9$。那么就尽量 **均摊**。

接下来说明如何进行 **均摊**。

首先由于不能有相同的数，所以直接分成 $3 + 3$ 是不行的，那么就还是要拆成一个序列。

还是举上面的例子，负方向的贡献分别是 $3, 2, 1$，但是正方向却只有两个数，那很明显，最好的方法就是将 $1$ 加到最大的数上面去，变成 $2, 4$（如果加到 $2$ 上面，就又变成 $3, 3$ 了）。

那么推广一下，正方向的贡献就应该是从 $2$ 开始，后面有一段，每次 $+ 1$，之后还有一个 $+ 2$ 的（因为把 $1$ 加上去了）。比如当 $n = 10$，负方向为 $5, 4, 3, 2, 1$，那么正方向就为 $1, 2, 3, 4, 5 \to 2, 3, 4, 6$。

不过当 $n = 4$ 时是特殊的，只有最后一个数是正方向 $+ 3$。

现在算一下最大值会不会超过 $10 ^ 9$。

奇数的情况前面已经算过了，现在只考虑偶数。那么最大的偶数便是 $100$。第一行中选定的平均数为 $51$，那么最后一列第一个数就是 $102$。那么最后一行最后一列的数就是 $102 + (50 + 49 + 48 + \ldots + 1 + 2 + 3 + \ldots + 49 + 51) \times 102 = 260202 < 10 ^ 9$。

# 实现

首先特判掉奇数和 $n = 2$ 的情况，然后引入 **差分数组**，并进行一些微调，最后再根据发现的规律递推填充即可。

**差分数组** 的好处其实就是大部分相同，操作起来方便。比如当 $n = 8$ 时，那么 **差分数组** 就应该是 $1, 1, 1, 1, 2, 1, 2$。只有两个位置是 $2$，其余都是 $1$（当然要特判 $n = 4$）。

$Code$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n;
int mp[N][N]; // 填充之后的二维数组
int cha[N]; // 差分数组

signed main() {
	cin >> n;
	if (n == 2) return puts("-1"), 0; // 特判 n = 2 的情况
	if (n & 1) { // n 为奇数
		int idx = 0;
		for (int i = 1; i <= n; i ++ ) {
			for (int j = 1; j <= n; j ++ )
				cout << ++ idx << ' '; // 每次 +1，依次输出即可
			puts("");
		}
		return 0;
	}
	for (int i = 2; i <= n; i ++ ) cha[i] = 1; // 都初始成 1
	if (n == 4) {
		cha[n] = 3; // n = 4 的特判
	} else { // 对两个位置进行更改
		int mid = (n >> 1) + 2; // 虽然变量名为 mid，但并不是最中间，而是中间靠右那个数的下一位
		cha[mid] ++, cha[n] ++ ; // 变成 2
	}
	mp[1][1] = 1;
	for (int i = 2; i <= n; i ++ ) mp[1][i] = mp[1][i - 1] + cha[i]; // 填第一行
	for (int i = 2; i <= n; i ++ ) { // 枚举行
		for (int j = 1; j <= n; j ++ ) { // 枚举列
			mp[i][j] = mp[i - 1][j] + cha[i] * mp[1][n]; // 根据第一行填下面的所有行
		}
	}
	for (int i = 1; i <= n; i ++ ) {
		for (int j = 1; j <= n; j ++ ) 
            cout << mp[i][j] << ' '; // 输出
		puts("");
	}
	return 0;
}
```

---

## 作者：djh0314 (赞：1)

[**洛谷**](https://www.luogu.com.cn/problem/P6497)。

## 题意

显然。

## 分析

肯定先分析一行的情况，我们在每一行都只有一个限制，就是 $n$ 个数的平均数是这一行中的数之一。

因为我们的方案其实与我们数字的顺序无关，因此，我们使这一行从小到大排序，开头为 $st$。

考虑什么情况下满足。

当然是从简单的开始想，分为 $n$ 为奇数与偶数的情况。

在是奇数时，我们从简单开想，（$k$ 是公差）。

| $st$ | $st+k$ | $st+k+k$ | $\dots$ | $st+k\times (n-1)$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |

这样显然是满足的，平均数为 $\frac{st+k\times (n-1)}{2}$，是在此行内的。

在是偶数时：

| $st$ | $st+k$ | $\dots$ | $st+k\times (n-2)$ | $en$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |

为什么是最后一个另设了 $en$ 呢，因为此时我们的平均数并不是一个整数。

所以我们要使 $en$ 满足我们的条件。

最好要使 $en$ 尽量小，我们的 $en$ 应当也是带 $k$ 的，这样才能使其平均数在其之内，好算的，我们的 $en=st+\frac{(n+2)\times k}{2}$，平均数为 $st+\frac{k*(n^2-2\times n+4)}{2}$，此数必然是一个整数，并且小于等于 $st+k\times (n-2)$ 是满足的。

最后就令行的 $k=1$，那么为了数字不同并且竖列也满足这个条件，我们令竖行的 $k$ 为第一行的最大值。

说的可能并不是那么明白，看代码更好理解。

~~~cpp
cin>>n;
if(n&1) {
	int cnt=0;
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) printf("%d ",++cnt);
		puts("");
	}
} else if(n==2) {
	puts("-1");
} else {
	int x=n/2+n;
	for(int i=1; i<n; ++i) {
		for(int j=1; j<n; ++j) printf("%d ",j+(i-1)*x);
		printf("%d\n",i*x);
	}
	for(int j=1; j<n; ++j) printf("%d ",j+(n-1)*x+((x-n)*x));
	printf("%d",n*x+(x*(x-n)));
}
~~~

---

## 作者：Error_Eric (赞：0)

### Statement

在一个 $n\times n$ 的矩阵内填入 $n^2$ 个互不相等的正整数，使其满足：

- 每行 $n$ 个数的平均数是该行内的一个整数。
- 每列 $n$ 个数的平均数是该列内的一个整数。
- 对于矩阵中的任意一个元素 $a_{i,j}$，都有 $1\le a_{i,j}\le 10^9$。

请你帮助他找出任意一种可行的方案。

### Sol 

一个感觉更加自然的解法。

对于 $n$ 为奇数，直接输出 $a_{i,j} = i \times n + j + 1$ 就可以。正确性是显然的，因为中间一行和中间一列一定是所在行或者列的平均数。

对于 $n$ 为偶数，假设每一行的第一个是 $x$ 且是这一行的平均数。我们需要让总和是 $nx$，很自然想到以下构造：

$$[x, x-1, x-2, x+3, x-4, x+4, x-5, x+5 \cdots, x-\dfrac{n}{2}-1, x+\dfrac{n}{2}+1]$$

注意到这个构造是对的。

每一列也可以用类似的方式构造。但是直接 copy 会导致重复，我们只需要将偏移量乘以 $500$ 就可以了。

### Code

```python
n = int(input())

def f(x : int) -> int:
    if x <= 3:
        a = [0,1,2,-3]
        return a[x]
    else : 
        return (x // 2 + 2) * ((-1) ** (x%2))
    
if n == 2:
    print('-1')
elif n % 2 == 1:
    for i in range(n):
        for j in range(n):
            print(i * n + j + 1, end= ' ')
        print()
else:
    for i in range(n):
        for j in range(n):
            print(500 * f(i) + f(j) + 550 * 550, end= ' ') # 防止负数
        print()

```

---

## 作者：MWL_wma (赞：0)

**首先审题。**  
看完了，毫无头绪。

---
**于是，打表找规律！**

显然，当 $n=5$ 时，
```
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
```
是一个解。

为什么这么巧！$n=3$ 和 $n=5$ 时矩阵里面的数字都是从 $1$ 到 $n^2$ 顺序排列！

想了一下，显然，对于一个项数为奇数的等差数列，其平均数就是其中位数。

而从 $1$ 到 $n^2$ 顺序排列的矩阵的每一行、每一列，都是等差数列！

因此，当 $n$ 为奇数时，矩阵里面的数字就是从 $1$ 到 $n^2$ 顺序排列即可。
```cpp
if(n%2){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=(i-1)*n+j;
		}
	}
}
```
---
那如果 $n$ 是偶数呢？

据样例可得，当 $n=2$ 时，无解。

继续推，当 $n=4$ 时，先写 $1,2,3$，此时再加一个 $1+2+3=6$ 可以满足题意。因此第一行就是：
```
1 2 3 6
```
那第 $2,3$ 行就是第一行的每一个数分别加上第一行最大的数 $6$ 的一倍、两倍。

因此前三行就是：
```
1 2 3 6
7 8 9 12
13 14 15 18
```
而最后一行的第一个数是 $13\times4-(1-7-13)=31$，可以使第 $1$ 列的平均数为 $13$，那最后一行的其他数就是第 $1$ 行的同一个数与 $31-1$ 的和。

于是，我们得到了 $n=4$ 时的一个解：
```
1 2 3 6
7 8 9 12
13 14 15 18
31 32 33 36
```

突然，我发现，对于每个 $n$ 为整数的解都可以这样推！

于是，豁然开朗。

---
### 贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[102][102];
int main(){
	scanf("%d",&n);
	if(n==2){
		return !puts("-1");
	}
	if(n%2){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				a[i][j]=(i-1)*n+j;
			}
		}
	}else{
		for(int i=1;i<n;i++){
			a[1][n]+=a[1][i]=i;
		}
		for(int i=2;i<n;i++){
			for(int j=1;j<=n;j++){
				a[i][j]=a[i-1][j]+a[1][n];
			}
		}
		a[n][1]=a[n-1][1]*n;
		for(int i=1;i<n;i++){
			a[n][1]-=a[i][1];
		}
		for(int i=2;i<=n;i++){
			a[n][i]=a[n][1]+a[1][i]-1;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",a[i][j]);
		}
		puts("");
	}
	return 0;
}
```
---
完美结束！

---

## 作者：Autream (赞：0)

#### 题意简述
构造一个 $n \times n$ 的矩阵，使得每一行/列的平均都在这一行/列当中，并且矩阵内各个数字不相同。

---
#### 题目分析
观察样例就可以轻松发现：当 $n$ 为奇数时，矩阵内的各个元素就是 $1 \sim n$ 的按顺序排列。

证明：
- 对于每一行，公差为 $1$，设每一行第一个数为 $x$，第 $k$ 项为 $x+(k-1)$ 其中 $1 \leq k \leq n$，那么这一行的和就是 $\frac{(x+x+n-1)\times n}{2}$，平均数是 $\frac{x+x+n-1}{2}=x+\frac{(n-1)}{2}$。

- 因为 $n$ 是奇数，所以 $\frac{n-1}{2}$ 是整数，且 $1 \leq \frac{n-1}{2} \leq n$。

- 每一列同理。

证毕。

如果 $n$ 为偶数，我们以同样的方式构造，每一行的平均数同样为 $\frac{x+(n-1)}{2}$，但是这个时候它是小数，我们只需要对这个矩阵的每一项都 $\times 2$，这样平均数就变成了 $x+(n-1)$ 这个整数。但是它也是一个奇数，怎么办呢？因为我们构造的矩阵公差相同，所以和平均数最相近的两个数肯定是中间的，为了使和不变，我们可以将每一行的第 $n\div2$ 项 $+1$，同时将第 $n \div 2+1$ 项 $-1$，那么每一行就构造完成了（这里也说明了只有 $n=2$ 的时候才无解）。

接下来考虑每一列，只需要将最后一行加上 $n^2$ 即可满足条件。

证明：
- 对于每一列，公差为 $2n$，设每一列第一个数为 $x$，第 $k$ 项就为 $x+(k-1)\times 2n$ 其中 $1 \leq k \leq n$，那么这一列的和就是 $\frac{[x+x+(n-1) \times 2n]\times n}{2}$，平均数是 $\frac{x+x+(n-1) \times 2n}{2}=x+n(n-1)=x+\frac{n-1}{2} \times 2n$。

- 因为 $n$ 是偶数，所以 $\frac{n-1}{2}$ 不是整数，但是 $\frac{n}{2}$ 是，所以考虑将每列的最后一项加上 $n^2$，等价于将每一项加上 $n$，平均数也加上 $n$，变为 $x+\frac{n}{2} \times 2n$，其中 $1\leq \frac{n}{2} \leq n$。

证毕。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=105;
int n,a[N][N];
signed main() {
    std::cin>>n;
    if(n==2) {
        puts("-1");
        exit(0);
    }
    int k=0;
    rep(i,1,n) {
        rep(j,1,n) {
            a[i][j]=++k;
        }
    }
    if(n&1) {
        rep(i,1,n) {
            rep(j,1,n) {
                std::cout<<a[i][j]<<" ";
            }
            puts("");
        }
    } else {
        rep(i,1,n) {
            rep(j,1,n) {
                a[i][j]*=2;
            }
        }
        rep(i,1,n) {
            a[i][n/2]++;
            a[i][n/2-1]--;
        }
        rep(i,1,n) {
            a[n][i]+=n*n;
        }
        rep(i,1,n) {
            rep(j,1,n) {
                std::cout<<a[i][j]<<" ";
            }
            puts("");
        }
    }
    return 0;
}
```

---

## 作者：KadiaNEFU (赞：0)

咋一看，好简单啊，然后WA了两次过后开始深思（捂脸）

理清了思路后我们不难发现：

- **如果n是奇数，就一个一个加1就可以满足**，因为奇数个连续的数的平均数一定在其中一个数。（如1 2 3 4 5 的平均数是3）

- **如果是偶数，我们也采用类似的方法一个一个加1，但到了最后一个列或最后一行时就要改一下**，因为偶数个连续的数的平均数是中间两个数的平均数（如1 2 3 4 的平均数是2.5）最后一个数就要强行让这一列数满足关系，我们把最后一个数改成6，（1 2 3 6的平均数是3），**即要再加上0.5×4=2（0.5是2.5比3少的部分，4是n）**，之后的每一行的数都加上一个数使他们无法重复，最小就可以加上a[1][n]，**对于最后一行的数我们也用类似方法算得要再加3×n×n÷4**，当然2是不满足的，我们特判一下即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105][105];
int main()
{
    int n;
    cin >> n;
    if(n==2)
    {
        cout << "-1" << endl ;
        return 0;
    }
    else if(n%2)
    {
        int now=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                a[i][j]=now++;
            }
        }
    }
    else
    {
        int now=1;
        for(int j=1;j<n;j++)
            a[1][j]=now++;
        a[1][n]=3*n/2;
        int c=a[1][n];
        for(int i=2;i<n;i++)
            for(int j=1;j<=n;j++)
                a[i][j]=a[i-1][j]+c;
        for(int j=1;j<=n;j++)
            a[n][j]=a[n-1][j]+c+3*n*n/4;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(j==1)
                cout << a[i][j];
            else
                cout << " " << a[i][j];
        }
        cout << endl ;
    }
    return 0;
}

```


---


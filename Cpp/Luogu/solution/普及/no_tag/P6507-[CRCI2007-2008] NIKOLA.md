# [CRCI2007-2008] NIKOLA

## 题目描述

有一行 $n$ 个格子，编号为 $1\sim n$，Nikola 从 $1$ 号格子出发，想要前往 $n$ 号格子。

他的行程包含若干次跳跃，第一次只能跳到 $2$ 号格子，接下来的跳跃必须满足以下条件：

- 如果他向 $n$ 号格子的方向跳跃，那么每次必须比前一次多跳一个距离的格子；

- 如果他向 $1$ 号格子的方向跳跃，那么每次必须与上一次的跳跃距离完全相同。

例如，在第一次跳跃之后（位于 $2$ 号格），Nikola 可以选择跳到 $4$ 或者 $1$。

每进入一个格子，Nikola 都要支付相应的入场费。第 $i$ 个格子需要付费 $a_i$。他希望在能到达 $n$ 号格的前提下尽可能少的花钱。你需要求出这个最小值。

## 说明/提示

#### 样例 1 解释

在第一个样例中，Nikola 的路线为 $1-2-1-3-6$。共花费 $2+1+3+6=12$ 。


#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 1000$，$1\le a_i\le 500$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [Regional Competition](https://hsin.hr/coci/archive/2007_2008/regional_tasks.pdf) *T2 NIKOLA***。

## 样例 #1

### 输入

```
6
1
2
3
4
5
6```

### 输出

```
12```

## 样例 #2

### 输入

```
8
2
3
4
3
1
6
1
4```

### 输出

```
14```

# 题解

## 作者：linyinuo2008 (赞：6)

### **关键字：记忆化搜索**

这是道记搜[好题](https://www.luogu.com.cn/problem/P6507)，看到之后决定来一发。

看到这题格子长度能达到$10^3$，心中差不多就明白这题暴搜肯定不行，~~虽然我还是傻傻的打了一份暴搜的代码~~

之所以看到这题就想到搜索，因为有如下几个特征。

- 是跟格子有关的题，所以~~简单~~算法可能种类就是动态规划，贪心，搜索，和入门无算法题。

- 有后效性，排除贪心。

- 数据范围很适合搜索，可能需要一些优化。

- 不过想到动态规划很正常，下面我们来看一下为什么动态规划做不了这题。

# 动态规划的想法

我们来仔细想一下这题用动归该怎样配置。

首先，我们可以先设$f_i$表示跳到第$i$个格子所需最少费用，但是这里少了一个重要的信息量：上一步跳的步数（这个变量在后面搜索时也会用到）。

于是我们设$f_{i,j}$表示当前在第$i$个格子，上一步跳了$j$个格子时的最小费用，于是易得转移方程：

$f_{i,j}$ $=$ $min(f_{i-j,j},f_{i+j+1,j+1})$ $+$ $a_i$

别忘了判断越界，其中$a_i$为当前格子花费。

答案：$min(f_{n,i})$ 其中$1 \leq i \leq n$

于是问题来了，我们应当如何枚举$i$,$j$，来完成动归转移？由于我们无法确定当前的步数，所以没有确定的转移顺序，于是动态规划差不多与这题无缘了（如果有大佬用动归做出来了请在讨论区里回复）。我们只好用分阶段递归来解决（~~这不就是搜索吗~~）。

# **暴搜基本思路**

1. 判断是否到达终点，若到达，取当前答案与此次结果最小值，返回。

2. 判断是否越界，若越界，则返回。

3. 向$1$号格子方向搜索。

4. 向终点方向搜索。

递归函数参数：pos（当前格子），len（走到这个格子走过的距离），money（已花钱数）。

**结果：TLE6个点。**

**What do you expect?**

记忆化搜索优化开始。

# 记忆化搜索思路

用一个$vis$数组来记录之前是否用相同的距离到达过这个点，若到达就记录下这个点所需最小钱数。

1. 判断是否越界，若越界返回一个巨大值，卡死这条路。

2. 如果到了最后一个格子，就返回这个格子的钱数。

3. **如果当前点已被记录过，就直接返回就可以了（这就是记搜的优化精髓）。**

4. 向两边继续搜记录在$vis$里，取最小值，别忘加当前格子钱数欧。

5. 返回初始点$vis$值。


递归函数参数：pos（当前格子），len（走到这个格子走过的距离）。

------------
这里说一下为什么只用两个参数，而不用加一个代表上一步方向的变量dir。因为我们考虑的是在这一个格子往前跳到终点所花钱数，而与它上一步从哪个格子来的无关。我们考虑的只是钱数，并不关心他上一个格子的花费。

我们需要记录上一步步数是因为这与下一步走的步数有关（可能加一）。

------------
下面上代码（有注释）：

$CodeTLE:$

```cpp
#include <iostream>
using namespace std;
const int N=1001;
const int INF=0x7f7f7f;//设的大一些
int ans,n,a[N];
int min(int a,int b)
{
	return a<b?a:b;
}
void dfs(int pos,int len,int money)
//money是当前所需的钱数，pos是当前的位置，len是上次走的步数 
{
	if(pos==n)  ans=min(ans,money+a[pos]);//到达更新ans 
	if(pos<1||pos>n)  return ;//判越界 
	//两边搜 
	dfs(pos-len,len,money+a[pos]);
	dfs(pos+len+1,len+1,money+a[pos]);
	
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	ans=INF;//别忘记初始化ans为无穷大 
	dfs(2,1,0);//从第二个格子开始搜 
	cout<<ans;
	return 0;
}
```

$CodeAC:$

```cpp
#include <iostream>
using namespace std;
const int N=1001;
//vis[pos][len]表示现在在第pos个格子，上次走了len步时所花的最少钱数 
int n,a[N],vis[N][N];
int min(int a,int b)//手动写min 
{
	return a<b?a:b;
}
int search(int pos,int len)
//pos是当前的位置，len是上次走的步数 
{
	if(pos<1||pos>n)  return 0x7f7f7f7f;//这个点好毒瘤，写0x7f都过不了 
	if(pos==n)  return a[n];//到终点返回钱数 
	if(vis[pos][len]) return vis[pos][len];//记忆化返回 
	return vis[pos][len]=min(search(pos-len,len),search(pos+len+1,len+1))+a[pos];//向两边搜 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	cout<<search(2,1);//从第二个格子开始搜 
	return 0;
}
```

注：这题数据真不错，记搜写成0x7f一个点都过不了。

管理员大大求通过！

## 若有错误，欢迎指出！





---

## 作者：快斗游鹿 (赞：5)

$dp$ 思路：

当前格子一共只有两种到达方式：

$1.$ 前进到达。

$2.$ 后退到达。

由此易得状态转移方程 ：

$f[i][j]=min(f[i-j][j-1],f[i+j][j])+a[i]$

加上边界判断（即不会跳出第 $n$ 个格子且不会退出第 $1$  个格子），即可出代码。

```
#include<bits/stdc++.h>
using namespace std;
long long f[1001][1001];//f[i][j]表示当前位置为i，本次移动移动了j格
int a[1001];//第i个格子的花费
long long ans,n;
int main(){
	ans=0x7f7f7f7f;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	memset(f,0x7f,sizeof(f));
	f[1][0]=0;//初始化设置
	for(int j=1;j<=n-1;j++){
		for(int i=n;i>=1;i--){
			if(i>j)f[i][j]=min(f[i][j],f[i-j][j-1]);//当这个格子能从前前进到达时，更新此时数组值
			if(i+j<=n)f[i][j]=min(f[i][j],f[i+j][j]);//当这个格子能从后倒退到达时，更新此时数组值
			if(f[i][j]<0x7fffffff){//若以上任意两种情况满足一种及以上，加上花费
				f[i][j]+=a[i];
			}
			if(i==n){//更新答案
				if(f[i][j]<ans)ans=f[i][j];
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：CaoXian (赞：2)

随机跳题跳到的一眼 `dp` 题。

观察题目，我们很容易设计出状态转移方程式：

令 $dp_{i,j}$ 表示目前在第 `i` 个格子，跳到第 `i` 个格子的时候跳过了 `j` 个格子所能得到的费用之和的最小值，有

$$dp_{i,j} = \min{\left(dp_{i - j,j - 1}, dp_{i + j, j}\right)}$$

这个方程很简洁易懂，$dp_{i - j,j - 1}$ 表示往 `n` 方向跳，$dp_{i + j, j}$ 表示往 `1` 方向跳。写的时候要注意一下边界条件。

还有三个细节要注意：

1. 初始值，$dp_{1,0}$ 设为 `0`，其余全设为 $+\infty$。
2. 循环的枚举要先枚举 `j` 再枚举 `i`。因为~~这样好写一些~~当前状态 $dp_{i,j}$ 的转移需要有 $dp_{i - j, j - 1}$ 和 $dp_{i + j, j}$ 这两个状态，由于涉及到 `j - 1` 所以应该把 `j` 所在的循环提到最外面。
3. 枚举 `i` 的循环要倒序枚举，因为我们更新当前状态时需要用到 $dp_{i + j, j}$ 这个状态，由于涉及到 `i + j` 应该倒序枚举。（其实原因和第二条差不多。）

答案统计：

$$ans = \min\limits_{1 \leq i \leq n}{\left\{dp_{n,i}\right\}}$$

最后的时间复杂度 $\Theta(n^{2})$。

有什么不懂可以问我qwq。

Code（PS：代码中的 `i` 和 `j` 和上面式子中所表达的意思是互换了的）：

```
#include <bits/stdc++.h>
#define re register
#define il inline
#define getchar gc
#define fu(i, l, r) for(re int i = l; i <= r; ++i)
#define fd(i, l, r) for(re int i = l; i >= r; --i)
#define mst(arr, v) memset(arr, v, sizeof(arr))
using namespace std;
il char gc() {static char ibuf[1 << 20], *p1 = ibuf, *p2 = ibuf; return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, 1000010, stdin), p1 == p2) ? -1 : *p1++;}
il void read(re int& x) {x = 0; re int f = 1; re char ch = getchar(); while(ch < '0' || ch > '9') f *= ((ch == '-') ? -1 : 1), ch = getchar(); while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar(); x *= f;}
int n, ans = 2147483647, a[1001], dp[1001][1001];
int main() {
	read(n);
	fu(i, 1, n) read(a[i]);
	mst(dp, 0x3f);
	dp[1][0] = 0;
	fu(i, 1, n) {
		fd(j, n, 1) {//dp
			if(i < j) dp[j][i] = min(dp[j][i], dp[j - i][i - 1] + a[j]);//往n方向跳
			if(j <= n - i) dp[j][i] = min(dp[j][i], dp[j + i][i] + a[j]);//往1方向跳
		}
		ans = min(ans, dp[n][i]);//答案统计
	}
	printf("%d", ans);
	return 0;
}

```

直接最优解。

其实 `dp` 数组还可以滚动优化的，但是懒得改了。

---

## 作者：KadiaNEFU (赞：2)

题面~~好像有错别字~~

有两种选择

1. 向n方向跳，跳的格子数为前一次+1。

2. 向1方向跳（此处题面有错误），跳的格子数为前一次跳的格子数。

注意！！！第二种跳法只能向1方向跳，不能向n方向跳

剩下的就是一个**递归**加一个**记忆化**了

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[1005];
int memery[1005][1005];
int work(int x,int len)//正在x格子上，如果要前跳需要跳len
{
    if(x>n||x<=0)//越界
        return 0x3f3f3f3f;
    if(x==n)//到达终点
        return a[n];
    if(memery[x][len])//已经知道这个位置的答案
        return memery[x][len];
    memery[x][len]=min(work(x+len,len+1),work(x-len+1,len))+a[x];//两种选择的min再加上这一格的值
    return memery[x][len];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    printf("%d\n",work(2,2));
    return 0;
}

```


---

## 作者：CCCloud (赞：1)

## 记忆化搜索  
**题目**：[在这里QAQ](https://www.luogu.com.cn/problem/P6507)  
### 方法1 —— 爆搜:(40分)  
你拿到这个题目，~~自动忽视数据范围~~，打了一份**爆搜代码**；  
**思路如下**：  
1、如果**没有越界**，那么往 $n$ 的方向 $dfs$ 一次；  
2、如果**没有越界**，那么往 $1$ 的方向 $dfs$ 一次；  
3、如果到了终点，将**最终答案与最优解比较并取舍**；  
4、所有情况**枚举完成**，**输出最优解**；  
主要 $Code$ 如下：
```cpp
void dfs(int m, int x, int l)
//m是当前的钱数，x是当前的位置，l是当前的步数
{
    if(x==n) ans=min(ans, m+a[x]);//到达终点
    if(x-l>0) dfs(m+a[x], x-l, l);//往1的方向
    if(x+l+1<=n) dfs(m+a[x], x+l+1, l+1);//往n的方向
}
```
然后 $TLE$ 了 $6$ 个点 QAQ  
### 方法2 —— 记忆化搜索:(100分)  
**思路如下**：  
1、先判断**有没有越界**，如果越界了**返回一个很大的值**；  
2、判断**是否到达终点**，如果到达终点了，返回**终点的钱**；  
3、判断**是否来到过**，如果**来到过**，那么**直接返回**；  
4、如果**没有来过**，用**数组记录下**往 $1$ 与往 $n$ 的最小值$+$当前位置的钱数，**并且返回**；  
主要 $Code$ 如下：
```cpp
int dfs(int x, int l)
{
    if(x<=0 || x>n) return 1e9;
    //如果越界，返回一个很大的值，就相当于断了这条路
    if(x==n) return a[x];
    //如果等于n，那么返回终点的值
    if(vis[x][l]) return vis[x][l];
    //记忆化搜索，如果曾经到过，那么直接返回
    
    return vis[x][l]=min(dfs(x-l, l), dfs(x+l+1, l+1))+a[x];
    //否则返回往n的方向走与往1的方向走的最小值+当前点的值
}
```

---

## 作者：XCDRF_ (赞：0)

# P6507 NIKOLA 题解
[原题传送门](https://www.luogu.com.cn/problem/P6507)

[更好的阅读体验](https://www.luogu.com.cn/blog/Rainforests/solution-p6507)
## 解题思路
看到题后，第一时间就想到了 `dp`。

继续思考，如果考虑 `dp`，则只有两种可能性：

1. 向前跳时到达。

2. 向后跳时到达。

那我们就可以推出状态转移方程了。

令 $dp[i][j]$ 表示当前跳到了第 $i$ 号格子，且跳跃的长度为 $j$ 个格子。

则向前跳时，Nikola 从 $i-j$ 号格子出发，跳跃长度为 $j-1$ 个格子。

状态转移方程可以表示为：$dp[i-j][j-1]$。

则向后跳时，Nikola 从 $i+j$ 号格子出发，跳跃长度为 $j$ 个格子。

状态转移方程可以表示为：$dp[i+j][j]$。

所以最终的状态转移方程为：

$$dp[i][j] = \min{\left(dp[i-j][j-1],dp[i+j][j]\right)}$$

按照它去写代码就可以了。
## 注意事项
1. 除了最开始的 $dp[1][0]$ 情况，其他要全部初始化为最大值，因为最终要求输出最小值。
1. 因为题目可以向后跳，需要在枚举 $i$ 时考虑到 $i+j$ 的情况，所以倒序枚举 $i$。向前跳时，也需在枚举 $j$ 时考虑到 $j-1$ 的情况，所以将 $j$ 放在外层枚举。
1. 需要注意边界情况，不能让 Nikola 跳出边界，所以让 $i-j \ge 1$，$i+j \le n$。

如果以上这些全都理解了，那么恭喜你，你成功学会了一道灰题。
## 参考代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=1005;
int n,minn=0x7fffffff;
int a[N],dp[N][N];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	memset(dp,0x7f,sizeof(dp));
	dp[1][0]=0;
	for(int j=1;j<=n;j++){
		for(int i=n;i>=1;i--){
			if(i>j) dp[i][j]=min(dp[i][j],dp[i-j][j-1]+a[i]);
			if(i+j<=n) dp[i][j]=min(dp[i][j],dp[i+j][j]+a[i]);
		}
		minn=min(minn,dp[n][j]);
	}
	cout<<minn;
	return 0;
} 
```
[AC记录](https://www.luogu.com.cn/record/129590523)
## 如有错误，欢迎指出，我会尽快修改！
最后建议管理员大大给这个题个评级和标签吧，要不然没人做啦。

---

## 作者：Ray1 (赞：0)

本题有两种做法，其中最短路做法是其他题解都没有提到的。

## 记忆化搜索
设当前处于第 $x$ 个格子，上一次跳了 $y$ 个格子，还需要最少 $dp_{x,y}$ 的入场费才能跳到第 $n$ 个格子。则转移方程为：
$$dp_{x,y}=\min(dp_{x-y,y},dp_{x+y+1,y+1})+a_x$$
注意一下特判边界，这里建议从 $x=2,y=1$ 开始搜索，最后直接输出搜索结果就行了。
```cpp
int dfs(int x,int y){
	if(x==n)return a[n];
	if(dp[x][y])return dp[x][y];
	int ans=1e9;
	if(1<=x-y)ans=min(ans,dfs(x-y,y));
	if(x+y+1<=n)ans=min(ans,dfs(x+y+1,y+1));
	return dp[x][y]=ans+a[x];
}
```
## 最短路
这道题也可以用 dijkstra 来写，核心思路和记忆化搜索一样。但是这里 $dp_{x,y}$ 存的是当前处于第 $x$ 个格子，上一次跳了 $y$ 个格子的最少花费，一旦搜到 $x=n$ 可以直接结束程序。注意初始化 $dp$ 数组。
```cpp
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	priority_queue<pair<int,pair<int,int> > >q;
	memset(dp,127,sizeof(dp)),dp[2][1]=a[2],q.push({a[2],{2,1}});
	while(!q.empty()){
		x=q.top().second.first,y=q.top().second.second,q.pop();
		if(vis[x][y])continue;
		else vis[x][y]=1;
		if(x==n)printf("%d",dp[x][y]),exit(0);
		if(1<=x-y)if(dp[x-y][y]>dp[x][y]+a[x-y])dp[x-y][y]=dp[x][y]+a[x-y],q.push({-dp[x-y][y],{x-y,y}});
		if(x+y+1<=n)if(dp[x+y+1][y+1]>dp[x][y]+a[x+y+1])dp[x+y+1][y+1]=dp[x][y]+a[x+y+1],q.push({-dp[x+y+1][y+1],{x+y+1,y+1}});
	}
}
```
两种做法的运行时间相差无几，可以根据自己的喜好选择。

---

## 作者：搞笑的皮卡丘 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6507)

[配合博客食用更佳](https://www.luogu.com.cn/blog/wzy-blog/)

看完题目，我们便可知，总共只有两种操作方式：

- 向 $n$ 号格子的方向跳跃，那么每次必须比前一次多跳一个的格子；

- 向 $1$ 号格子的方向跳跃，那么每次必须与上一次的跳跃距离相同。

$n$ 的范围也不大，只有 $1000$，但是如果爆搜，还是会 TLE；

so 这里就有一个小技巧：

#### 记忆化搜索

这能大大缩短运行时间，让你从 TLE 到 AC。

想到了这儿，剩下的就简单了，一个递归就搞定了：

1. 如果越界了，则返回巨大的数值；
1. 如果到了，则返回输出；
1. 如果搜过了，则返回锁国的数值；
1. 如果没搜过，则搜一遍并记录。

废话不多说了，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],f[1005][1005];
int work(int x,int l)
{
    if(x>n||x<=0)
    return 0x3f3f3f3f;//如果不符合条件，pass
    if(x==n)
    return a[n];//如果到达终点，则返回结果
    if(f[x][l])
    return f[x][l];//如果已经搜索过，则直接返回结果
    f[x][l]=min(work(x+l,l+1),work(x-l+1,l))+a[x];    //选择价值小的再加这次操作的价值，为 f[x][l] 赋值
    return f[x][l];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);//日常输入
    printf("%d",work(2,2));//进入递归并输出结果
    return 0;//养成好习惯
}

```

完结撒花

[AC](https://www.luogu.com.cn/record/55604440)

---


# [COCI 2010/2011 #2] IGRA

## 题目描述

解决了繁琐的任务后，Mirko 决定与他的好朋友 Slavko 一起玩游戏。

他们在一张纸上写了一个含有 $n$ 个字母的序列。每个人轮流使用序列中的字母拼写一个单词，即从序列中删除单个字母并将其附加到单词的末尾。Mirko 开始了第一回合。当序列中没有剩余字母时，游戏结束。

一个比另一个单词更美丽的单词指这个单词按照字典序排在另一个单词前面。在游戏结束时拥有更美丽单词的玩家将获胜。 如果两个玩家的单词都一样，他们就都输了这一轮。

Mirko 玩得比 Slavko 更好，因此他决定通过始终选择序列中最右边的字母来使 Slavko 玩得更容易一些。 知道了这一点，Slavko 想知道他是否有可能获胜，以及他可能得到的最美丽的单词是什么。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n = 2\times k(1 \leq k \leq 500)$ 且 $k$ 为整数。
- 对于 $100\%$ 的数据，保证 $n = 2\times k(1 \leq k \leq 10^5)$ 且 $k$ 为整数，所有读入的、输出的第二行的字符均为小写字母。

#### 说明

- 本题满分 $80$ 分。
- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) IGRA，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
2
ne```

### 输出

```
NE
n```

## 样例 #2

### 输入

```
4
kava```

### 输出

```
DA
ak```

## 样例 #3

### 输入

```
8
cokolada```

### 输出

```
DA
acko```

# 题解

## 作者：wzb13958817049 (赞：2)

# 思路
贪心，因为 Mirko 每次只会拿最后一个单词，所以 Slavko 要想赢就要拿剩下单词中字典序最小的且排在越后面越好。这样我们可以很好的想到暴力，去拿 $O(n)$ 的时间复杂度去跑一遍剩余序列找最小且最后的字母。但是只有 $40$ 分，因此就可以想到把所有字母的位置保存在数组中，从而去寻找最小且最后的字母。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,j;
string a,ans1,ans2;//ans1表示Slavko拿到的最美丽单词
//ans2表示Mirko拿到的单词
vector<long long> mp[27];
bool vis[200005];//该位置是否被访问过
int main(){
	cin>>n>>a;
	for(int i=0;i<a.size();i++) mp[a[i]-'a'+1].push_back(i);//把字母保存到vector中
	j=n-1;//最后一个字母的下标
	while(ans1.size()+ans2.size()<a.size()){
		while(vis[j]==1 && j!=0) j--;//Mirko先手
		ans2+=a[j];vis[j]=1;//记录下标为j的字母已经被拿走
		bool falg=0;
		for(int i=1;i<=26;i++){//从小到大遍历，找到第一个有的字母(最小)
			for(int k=mp[i].size()-1;k>=0;k--){//从后往前遍历因为越后面越好
				if(vis[mp[i][k]]==0){//如果没被拿走
					ans1+='a'+i-1;
					vis[mp[i][k]]=1;//标记
					mp[i].erase(mp[i].begin()+k);//删除
					falg=1;
					break;
				}
			}
			if(falg==1) break;
		}	
	}
	if(ans1<ans2) cout<<"DA";
	else cout<<"NE";
	cout<<"\n"<<ans1;//输出答案
	return 0;	
}
```
但是因为代码太朴素，还是会 $T$，那怎么办呢？剪枝，记录上一次拿的字母，下次从上一个字母开始访问，可以大大的省时间。
# ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,j,kkk;
string a,ans1,ans2;
vector<long long> mp[27];
bool vis[200005];
int main(){
	cin>>n>>a;
	for(int i=0;i<a.size();i++) mp[a[i]-'a'+1].push_back(i);
	j=n-1;
	while(ans1.size()+ans2.size()<a.size()){
		while(vis[j]==1 && j!=0) j--;
		ans2+=a[j];vis[j]=1;
		bool falg=0;
		for(int i=kkk;i<=26;i++){
			for(int k=mp[i].size()-1;k>=0;k--){
				if(vis[mp[i][k]]==0){
					ans1+='a'+i-1;
					vis[mp[i][k]]=1;
					mp[i].erase(mp[i].begin()+k);
					kkk=i;
					falg=1;
					break;
				}
			}
			if(falg==1) break;
		}	
	}
	if(ans1<ans2) cout<<"DA";
	else cout<<"NE";
	cout<<"\n"<<ans1;
	return 0;	
}
```

---

## 作者：Officer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6548)

# 思路

一拿到题，最容易想到的就是贪心。

怎么贪，这是个问题。

最好写的暴力思路是先整一个标记数组，每一次从右往左扫，一碰到没标记过的，就加进 $s1$ ，然后再扫一遍，找最小，找完就加进 $s2$。

时间复杂度很高，考虑优化。

用 26个 vector 存字母位置，多个最小，取最后一个。

证明如下：Mirko 每次只会拿最后一个单词，所以 Slavko 要最小的且最后就一定最优。

看一下代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
char s[200005],s1[100005],s2[100005];
int n;
vector<int> v[26];
signed main()
{
	//freopen("string.in", "r", stdin);
	//freopen("string.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	cin>>s;
	for(int i=0;i<n;i++)
	{
		v[s[i]-'a'].push_back(i);
	}
	n/=2;
	for(int i=0;i<n;i++)
	{
		int k=-1,id=-1;
		for(int j=0;j<26;j++)
		{
			if(v[j].size()&&v[j].back()>k)
			{
				k=v[j].back();
				id=j;
			}
		}
		s1[i]=id+'a';
		v[id].pop_back();
		k=-1;
		for(int j=0;j<26;j++)
		{
			if(v[j].size())
			{
				k=j;
				break;
			}
		}
		s2[i]=k+'a';
		v[k].pop_back();
	}
	bool f=0;
	for(int i=0;i<n;i++)
	{
		if(s1[i]!=s2[i])
		{
			cout<<(s1[i]>s2[i]?"DA\n":"NE\n");
			f=1;
			break;
		}
	}
	if(!f)
	{
		cout<<"NE\n";
	}
	cout<<s2<<endl;
	return 0;
}
/*
*/

```

# 后记
感谢 yummy 的批评（~~鞭策~~）。

感谢 RailgunZzzz 的建议。

感谢所有向我提出建议的人。

特此感谢。

# 完

---

## 作者：wunaidedanjuan (赞：1)

### **简化题意**
`Mirko` 和 `Slavko` 轮流拿走一个长度为 $n$ 的字符串内的字母放入自己的字符串中。`Mirko` 先手，但每次只取字符串最右侧的字母；`Slavko` 后手，可以随意取剩余的字母。

当字符串中的字母被取完后，若 `Slavko` 的字符串的字典序小于 `Mirko` 的字符串，则输出 `DA` 和 `Slavko` 的字符串；否则，则输出 `NE` 和 `Slavko` 的字符串。

### **思路分析**
`Mirko` 拿字母的方式固定，可以放在一边，`Slavko` 可以随意取为被拿走的字母，要使 `Slavko` 的字符串字典序小，考虑贪心，每次取走取剩余的最小字母；**当最小字母有多个时，取最右侧的**，以保证 `Mirko` 取走的字母较大。

每次 `Slavko` 取字母时都要取最小的，考虑到 $n\leqslant2\times10^5$，每次遍历整个字符串绝对会超时，又因为字符串中只含小写字母，我们可以考虑**用 `vector` 存储每个字母出现的位置**，遍历时从字母 $a$ 开始遍历，寻找未被取走的最靠右的字母即可。

**如果还是会超时怎么办**？我们可以考虑加一个小小的剪枝，在遍历后将已遍历过的部分删去。

本题中最难的部分解决了，其它部分代码注释有详解，就不再赘述了。

### **思路呈现**
- 用 `vis` 数组记录某位置字母是否被取走；

- 用 `vector` 记录字母出现的位置；

- 从字母 $a$ 开始遍历，取走未被取走的最靠右的字母（贪心）；

- 遍历后删除已遍历部分，剪枝；

- 最后直接比较 `Mirko` 和 `Slavko` 的字符串大小，即字典序大小；

### **代码呈现**
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<bitset>
#include<cctype>
#include<cstdlib>
#include<functional>
#include<istream>
#include<sstream>
#define int long long 
using namespace std;
const int N=300000,M=30,inf=0x3f3f3f3f3f3f3f,mod=10007;
bool vis[N];//记录字母是否被拿走 
vector<int>a[M];//记录每个字母出现的位置 
signed main()
{
	memset(vis,0,sizeof(vis));//初始都没有被拿走 
	int n;
	bool book;
	string s,mir,sla;
	scanf("%lld",&n);
	cin>>s;
	for(int i=0;i<n;i++)//记录每个字母出现的位置
		a[s[i]-'a'].push_back(i);
	while(mir.size()+sla.size()<s.size())
	{
		while(vis[n-1]==true)//如果已被拿走，向前扫 
			n--;
		mir+=s[n-1];//Mirko先手，拿走最右侧字母
		vis[n-1]=true;//标记已拿
		book=false;//辅助变量 
		for(int i=0;i<26;i++)//寻找剩下的最小的且最靠右的字母
		{
			if(!a[i].empty())
				for(int j=a[i].size()-1;j>=0;j--)//倒着遍历，先考虑拿最右侧的（贪心）
					if(vis[a[i][j]]==false)//还没有拿走的最小的最靠右的字母 
					{
						sla+='a'+i;//Slavko后手，拿走剩下的最小的且最靠右的字母
						vis[a[i][j]]=true;//标记已拿
						a[i].erase(a[i].begin()+j);//因为已经拿走的是该字母中位置最靠右的，所以删去它及其后面的 
						book=true;
						break;
					} 
			if(book==true)
				break; 
		}
	}
	if(mir<=sla)//直接比较两字符串大小，即比较字符串字典序 
		printf("NE\n");
	else
		printf("DA\n");
	cout<<sla;
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

~~水社贡ing~~
# 题意
题目说有两个可爱的 ``mirco`` 和 ``slavko`` ，他们在玩取字符游戏。然后捏，他们从一个大字符串里面取出一些字符塞进自己的字符串里，最后谁的更“美丽”（指谁的字典序靠前）谁就赢了。

那这个 ``mirco`` 呢，他是从字符串最右边拿，而 ``slavko`` 是自己随便挑一个。

# 思路
前面大佬说有啥哈希栈，那我来个哈希队列。

思路其实一样滴，就是把一样的字符的下标放进队列里头，然后因为贪心问题， ``slavko`` 不能让 ``mirco`` 把这个大的拿了，所以要拿最右边的，所以我们从  $n$ 到 $1$ 倒着放进去， 因为队列是 $FIFO$ （先进先出），所以对于每个字母都是大编号在前，小编号在后。

一个一个分析。先说 ``mirco`` 。他是拿最右边的，如果我们拿个 $vis$ 存一下再 $O(n)$ 扫一遍，可惜样例太大，过不了。我们的哈希队列就用上了，找每个字母对应的最大值（队首），再找最大值里面的最大值，这样就是最右边了。~~（好绕）~~

然后是 ``slavko`` 。他是随便拿，我们要让字典序最小，字典序是越前面的贡献越大，所以前面就应该拿大的。直接从 $a$ 的 $Hash$ 扫到 $z$ 的 $Hash$ ，只要有就得拿。时间复杂度 $O(n)$ ，不会爆时间。
## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define p endl 
using namespace std;
queue<int> w[30];

signed main(){
    int n;
    string s;
    cin>>n;
    cin>>s;
    for(int i=n-1;i>=0;i--){
        w[s[i]-'a'].push(i+1);
    }
    string mirco="",slavko="";
    for(int i=1;i<=n;i++){
        if(i&1){
            int maxn=0,u=0,maxi;
            for(int i=0;i<26;i++){
                if(!w[i].empty()&&maxn<w[i].front()){
                    maxn=w[i].front();
                    maxi=i;
                }
            }
            mirco+=s[maxn-1];
            w[maxi].pop();
        }else{
            int u=0;
            while(w[u].empty()){
                u++;
            }
            slavko+=s[w[u].front()-1];
            w[u].pop();
        }
    }
    if(slavko>=mirco){
        cout<<"NE\n";
    }else{
        cout<<"DA\n";
    }
    cout<<slavko;
    return 0;
}
```

---

## 作者：CCCloud (赞：1)

前言：花了两个中午AC了这道难度一般的题目QAQ  
### 字符串+贪心  
题目大意：[自己看吧……](https://www.luogu.com.cn/problem/P6548)  
主要思路：  
1、每次先从字符串中拿出**最右边**的一个元素，加入到 $a$ 数组中，并把字符串**长度－1** ；    
2、在剩下的元素中找到**最小**的字符加入到 $b$ 数组中，并且如果有多个最小的字符，那么**选最靠右**的（贪心）；  
3、比较 $a$ 数组与 $b$ 数组**当前位置的元素**，并且**记录答案**；如果**曾经记录过答案**，那么**不再比较**；  
4、**重复第一步**直到**字符串长度为0**；
#### 主要代码实现如下：
$k$ 数组是记录该元素**是否用过**，$c$ 数组是**结构体**，其中 $s$ 是**此元素的值**，$num$ 是此元素**在原字符串中的的位置**；
```cpp
while(n)
	{
		while(k[n]) n--;
		if(n<=0) break;
		a[t]=s[n];
		k[n]=true;
		n--;
		
		ans=0;
		for(int i=now; i<=m; i++)
		{
			if(k[c[i].num]) continue;
			b[t]=c[i].s;
			k[c[i].num]=true;
			now=i;
			break;
		}
		
		if(ft==0)
		{
			if(a[t]<b[t]) ft=-1;
			else
			{
				if(b[t]<a[t]) ft=1;
			}
		}
		t++;
	}
```
感谢阅读到这里！

---

## 作者：_•́へ•́╬_ (赞：1)

### 题意

[没读题的先读题。](www.luogu.com.cn/problem/P6548)

### 思路

从时间复杂度入手：

- 必须模拟 $n$ 次取字母的过程，所以复杂度里一定有一个 $n$。
- 而 $n$ 较大，$n^2$ 肯定炸。。。
- 所以取字母的过程肯定不能依赖 $n$。
- 然后我们发现字符串只包含小写字母。也就是说只有 $26$ 种取值可能。
- 我们能不能依赖这个呢？
- 一切皆有可能。

我们使用 $26$ 个 $vector$，保存每个字母出现的位置。

- 先手 Mirko 总是拿最右边的，这个 $O(26)$ 扫一遍可以找到。

- 后手 Slavko 总是拿最小的，这个 $O(26)$ 扫一遍也可以找到。

  这个还有一点，如果有几个同样的最小的，应拿最右边的那个。这样就能使 Mirko 拿不到。这个贪心应该不难想到。

然后，就没有然后了。。。

### 你们最想要的 $code$

```cpp
#include<stdio.h>
#include<vector>
int n;char s[100001],ans1[55555],ans2[55555];std::vector<int>a[26];bool f;
main()
{
	scanf("%d%s",&n,s);//输入
	for(register int i=0;i<n;++i)a[s[i]-'a'].push_back(i);//初始化 vector
	for(register int i=0,chose,Orz;i<(n>>1);++i)
	{
		//Mirko begin
		chose=-1;Orz=-1;
		for(register int k=0;k<26;++k)if(a[k].size()&&a[k].back()>Orz)
			{chose=k;Orz=a[k].back();}//枚举 26 种可能，找最右边的
		ans1[i]=chose+'a';//加入单词
		a[chose].pop_back();//选过了
		//Mirko end
		//Slavko begin
		chose=-1;
		for(register int k=0;k<26;++k)if(a[k].size()){chose=k;break;}//枚举 26 种可能，找最小的
		ans2[i]=chose+'a';//加入单词
		a[chose].pop_back();//选过了
		//Slavko end
	}
	for(register int i=0;i<(n>>1);++i)if(ans1[i]!=ans2[i])
		{puts(ans1[i]>ans2[i]?"DA":"NE");f=1;break;}//看看谁赢谁输
	if(!f)puts("NE");//平局算都输
	puts(ans2);//输出
}
```



---

## 作者：Charles_with_wkc (赞：0)

# 思路：
这道题目是一个十分明显的**贪心问题**。  
最好写的暴力思路是先整一个标记数组，每一次从右往左扫，一碰到没标记过的，就加进 $s1$，然后再扫一遍，找最小，找完就加进 $s2$，然后你就会的到一份这样的超时代码。  
# 暴力代码：
```cpp
cin>>n>>s;
reverse(s.begin(),s.end());//方便处理
s=" "+s;
while(sum<n) {
	if(f==0) {
		pos=1;
		while(pos<n&&s[pos]==' ') pos++;//暴力寻找
		s1+=s[pos];
		s[pos]=' ';
	} else {
		minn=256,pos=1;
		for(int j=1; j<=n; j++) {
			if(minn>(int)s[j]&&s[j]!=' ') minn=(int)s[j],pos=j;//比较最小
		}
		s2+=s[pos];
		s[pos]=' ';
	}
	sum++;
	f=!f;//去拼接下一个人的字母
}
if(s2<s1) cout<<"Y"<<endl;
else cout<<"N"<<endl;
cout<<s2;
```
这种代码是极其好些的写的，但是会得到超时的赞赏。该怎么优化呢？
# 优化：
用 vector 存字母位置，然后按暴力思路写。
# 核心代码：
```cpp
for(int i=0; i<n; i++) a[s[i]-'a'].push_back(i);
//存储每个字母的位置
n/=2;
for(int i=0; i<n; i++) {
	chose=pos=-1;
	for(int k=0; k<26; k++) if(a[k].size()&&a[k].back()>pos) chose=k,pos=a[k].back();
//寻找第一个人，要去最后的一个，比最小
	ans1+=(chose+'a');
	a[chose].pop_back();
	chose=-1;
	for(int k=0; k<26; k++) if(a[k].size()) chose=k,break;
//寻找第二个人，不用去最小，找到跳出
	ans2+=(chose+'a');
	a[chose].pop_back();
}
cout<<(ans2<ans1?"Y":"N")<<endl<<ans2;
```

---

## 作者：Autream (赞：0)

#### 题意简述
给定一个长度为 $n$ 的字符串，`Mirko` 和 `Slavko` 轮流取一个字符组成自己的字符串。
`Mirko` 每次取最后一个，`Slavko` 可以随便取，问最后 `Slavko` 的字符串是否小于 `Mirko` 的。平局算输。

---
#### 题目分析
贪心。

要使 `Slavko` 的字符串尽可能小，那么每次取的字符就得尽可能小。

要使 `Mirko` 的字符串尽可能大，那么每次就留大的字符放在后面。

用双端队列记录每一个字符的位置，再用一个数组记录每个位置的字符是否用过，如果用过就直接在队列中弹掉，避免重复遍历。

---
#### AC Code

```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=2e5+5;
int n,cnt,vis[N];
std::deque<int> idx[30];
std::string s,a,b;
signed main() {
    std::cin>>n>>s;
    std::reverse(all(s));
    rep(i,0,n-1) {
        idx[s[i]-'a'].p_b(i);
    }
    for(int i=0;cnt<n;i++) {
        if(i&1) {
            rep(j,0,25) {
                int flag=0;
                for(int id:idx[j]) {
                    if(!vis[id]) {
                        b.p_b(s[id]);
                        vis[id]++;
                        flag=1;
                        break;
                    } else {
                        idx[j].pop_front();
                    }
                }
                if(flag) {
                    break;
                }
            }
        } else {
            while(vis[cnt]&&cnt<n) {
                cnt++;
            }
            a.p_b(s[cnt]);
            vis[cnt]++;
        }
    }
    rep(i,0,(n>>1)-1) {
        if(b[i]>a[i]) {
            puts("NE");
            puts(b.c_str());
            exit(0);
        } else if(b[i]<a[i]) {
            puts("DA");
            puts(b.c_str());
            exit(0);
        }
    }
    puts("NE");
    puts(b.c_str());
    return 0;
}
```

---

## 作者：djh0314 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P6548)。	

## 题意

有 $A$，$B$ 两个人，有一个含 $n$ 个字符的字符串。$A$ 始终取最右侧的字符，$B$ 可以取任意一个字符，问 $B$ 所取的字符串能否胜过 $A$，以及 $B$ 能取的最大字符串。


## 分析
首先，我们 $A$ 肯定会选择当前的最小的字符，我们就可以先把字符按大小排序，字符相同的按下标从大到小排序，将 $B$ 每次取的的标记，跳过这些节点即可。

~~~cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
const int N = 1e5+5;
int n, m,pos[N];
char s[N],c[N];
bool vis[N];
struct node {
	char num;
	int id;
	friend bool operator < (node fi,node se) {
		return fi.num==se.num? fi.id>se.id :fi.num<se.num;
	}
} b[N];
char ans[N];
signed main() {
	cin>>n>>s+1;
	for(int i=1; i<=n; ++i) b[i]=<%s[i],i%>;
	sort(b+1,b+n+1);
	for(int i=1; i<=n; ++i) pos[b[i].id]=i;
	int R=n,flag=1,now=1;
	for(int i=1; i<=n/2; ++i) {
		while(R&&vis[pos[R]]) --R;
		vis[pos[R]]=1;
		while(vis[now]) ++now;
		vis[now]=1;
		ans[i]=b[now].num;
		if(flag==1&&s[R]>b[now].num) flag=0;
		else if(flag==1&&s[R]<b[now].num) flag=2;
	}
	if(flag) cout<<"NE\n";
	else cout<<"DA\n";
	for(int i=1;i<=n/2;++i) cout<<ans[i];
	return 0;
}
~~~

---

## 作者：OMITW (赞：0)

# 前言
这题纯纯一道十分坑的贪心！

# 思路推导

看到这题的第一眼。一个人选最后一个。一个人选最小的，如果最小的有多个，那么选最后的。好，你以为是水题，然后直接打暴力交上去。结果，你只拿了 $ 40 $ 分。喜提 TLE。

# TLE Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,k,pd;
string s,sl,mi;
int main()
{
	cin>>n>>s;
	while(s.size())
	{
		mi+=s[s.size()-1];
		s.erase(s.size()-1,1);
		k=1e9;
		for(int i=0;i<s.size();i++)
			if(s[i]<=k)k=s[i],t=i;
		sl+=s[t];
		s.erase(t,1);
	}
	cout<<(sl<mi?"DA":"NE")<<"\n"<<sl;
	return 0;
}
```

然后你仔细一看数据范围 $ n \le 2 \times 10^5 $，然后直接懵逼了。。。

后面仔细一想，字母一共只有 $ 26 $ 个！可以两次循环 $ 26 $，第一次找最后的，第二次找最小中最后的。最多跑 $ 26 \times 10^5 $，这样就可以远离 TLE 了。

在浅浅的用一个数据结构 deque，把后面加的放到前面去，然后就 AC 了。记得，如果字符串相等，也是输的！！！

# AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,maxx,t,ji;
string s,s1,s2;
deque<int> g[30];
int main()
{
	cin>>n>>s;
	for(int i=0;i<s.size();i++)
		g[s[i]-'a'+1].push_front(i);
	while(ji<s.size())
	{
		maxx=0;
		for(int i=1;i<=26;i++)
			if(g[i].size()&&g[i].front()>maxx)
			{
				maxx=g[i].front();
				t=i;
			}
		s2+=char(t+'a'-1);
		g[t].pop_front();
		for(int i=1;i<=26;i++)
			if(g[i].size())
			{
				s1+=char(i+'a'-1);
				g[i].pop_front();
				break;
			}
		ji+=2;
	}
	cout<<(s1>=s2?"NE":"DA")<<"\n"<<s1;
	return 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

### 先说几句

第一次写主题库题解，非常兴奋。

这是一道非常棒的小众贪心题。

### 解题思路

首先自创数据结构：哈希栈。按照字面意思理解。

对于每个字母，建立哈希。映射一个栈，存储字符串 $s$ 中该字母的所有出现位置。这样，Mirko 的玩法模拟就很明显了。Mirco 每次取走最右边的字母，既可以在每个栈中寻找下标最大的（也就是最右边的）。

当 Slavko 玩的时候，找到可取的最小字母。建立哈希的好处就在于此。

#### 解释

获胜必须取到能取到的最美字符串的原因是：

每个人都得尽力发挥。实际上，为了获胜，需要使得自己取到的字符串越美丽，这样才能更可能获胜。

### 奉上代码

```cpp
// P6548 [COCI2010-2011#2] IGRA
#include <bits/stdc++.h>
#define var long long
using namespace std;

int main()
{
	int n; cin>>n;
	string s; cin>>s;
	stack<int> a[26+5];
	for(int i=0; i<n; i++)
		a[s[i]-97].push(i);
	
	string S, M;
	int e=n-1;
	for(int i=0; i<n; i++)
	{
		if(i%2==1)		// 奇数是S取
		{
			int s=0;
			// 找到第一个可取的最小字母 
			while(s<26 && a[s].empty())
				s++;
			a[s].pop();
			S+=s+97;
		}
		else		// 偶数是M取
		{
			int maxi=-1, Max=-1;
			for(int i=0; i<26; i++)
				if(!a[i].empty() && a[i].top()>Max)
				{
					Max=a[i].top();
					maxi=i;
				}
			M+=maxi+97;
			a[maxi].pop();
		}
	}
	
	if(S<M)
		puts("DA");
	else
		puts("NE");
	cout<<S;

    return 0;
}
```

---


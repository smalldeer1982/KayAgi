# 座位调查

## 题目背景

ION 2048 结束了，但 ℲƆƆ 发现，一个机房里发生了性质恶劣的作弊事件。

## 题目描述

Youyou 奉命来到该机房进行调查。已知该机房是一个 $n \times m$ 的矩阵，每个位置是 `O` 或 `X`，其中 `O` 表示该位置是座位，`X` 表示该位置是空地。**每个座位上都必须坐有学生**，当然，至少有一个座位。

要想查明作弊的学生，Youyou 必须知道这个机房中的考生有多少种座位的可能。ION 2048 有来自 $k$ 个学校的考生参加，且座位满足以下要求：

* 考场中的座位是由若干长条形组成的，这样方便管理；
* 任意考生不可能和来自同学校的考生座位相邻，可以避免交流。

两个座位是相邻的当且仅当它们有一条**公共边**。

条形定义为除了两个端点只有一个相邻的座位外，每个座位都恰好有两个相邻座位，当然，一个座位也属于条形的。

例如，下面的都**是**「条形的座位」。

![](https://cdn.luogu.com.cn/upload/image_hosting/g7ew1c6c.png)

下面的都**不是**「条形的座位」。

![](https://cdn.luogu.com.cn/upload/image_hosting/x7z4d6yx.png)

注：方格中的数字表示与其相邻的座位的个数。

试求出合法的座位方案总数，由于结果可能很大，请输出结果对质数 $998244353$ 取模的结果。如果这个机房本身就不可能是 ION 2048 的考试机房，答案应当是 $0$。

## 说明/提示

**样例 1 解释**

可能有以下 $4$ 种情况，红色代表学校 $1$ 的学生，蓝色代表学校 $2$ 的学生：

![](https://cdn.luogu.com.cn/upload/image_hosting/d6riqiby.png)

**样例 2 解释**

可能有以下 $12$ 种情况，红色代表学校 $1$ 的学生，蓝色代表学校 $2$ 的学生，黄色代表学校 $3$ 的学生：

![](https://cdn.luogu.com.cn/upload/image_hosting/4ni46qzf.png)

**样例 3 解释**

机房不是条形安排的，所以答案为 $0$。

**数据规模与约定**

* Subtask 1（10 分）：$n = 1$，$k = 2$；
* Subtask 2（15 分）：$n = 1$，$2 \le m,k \le 8$；
* Subtask 3（15 分）：$n = 1$；
* Subtask 4（20 分）：保证座位设置是条形的，$k = 2$；
* Subtask 5（20 分）：保证座位设置是条形的；
* Subtask 6（20 分）：无特殊限制。

对于全部的数据，$1 \le n, m \le 10^3$，$2 \le k \le 10^9$。

## 样例 #1

### 输入

```
2 3 2
OOX
XXO```

### 输出

```
4```

## 样例 #2

### 输入

```
2 3 3
XOX
XOO```

### 输出

```
12```

## 样例 #3

### 输入

```
2 3 4
XOO
XOO```

### 输出

```
0```

# 题解

## 作者：翼德天尊 (赞：13)

我又来啦QwQ!

一道很不错的联通块+推公式题。

### STEP 1 解题大致思路

经过一段时间的思索，我们可以轻易地将这道题分成几个子任务：

1. 输入整张地图；

2. 遍历整张地图：

	- 找到座椅；

	- 进入 $dfs$ 遍历，找到这个联通块的所有座椅，并且记录有几个座椅**周围只有一个座椅**以及该联通块的**座椅个数**，注意遍历完的座椅**要标记**；
    
    - 如果该联通块**周围有一个座椅的座椅不是两个**且联通块个数不为 $1$，说明该图不合法，输出`0`并结束程序；
    
    - 否则根据联通块个数套入公式计算即可。
    
3. 将计算完的答案输出。

### STEP 2 推导公式

> 当联通块合法的时候，我们可以对于这个联通块套用计算公式。

既然每一个合法的联通块都是“条形”座位，那么只要联通块合法，我们就完全可以将它掰成一个直的条形座位。

对于每一个条形的座位联通块，第一个座位一定可以放 $k$ 个学校的学生，也就是有 $k$ 种可能，而后面的座位因为前面的一个座位已经选过了一个学校，为了符合题意，只能放 $k-1$ 个学校的学生，所以若设联通块的座位个数为 $w$，则通项公式为：

$$k\times(k-1)^{w-1}$$

然后我们把所有的联通块的可能性个数乘起来就好啦！（不要忘记驱魔哦QwQ）

### STEP 3 $AC\ code$ 及注释

```
#include<bits/stdc++.h>
using namespace std;
#define inf 998244353//模数
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};//每一项对应一个方向
int n,m,k,tot;//如题，如下
long long sum,ans=1;//如题，如下
char ma[1001][1001];//储存地图
long long ksm(long long s,long long mi){//快速幂加速
	long long ans=1,cnt=s;
	while (mi){
		if (mi&1) ans=ans*cnt%inf;
		cnt=cnt*cnt%inf;
		mi>>=1;
	}
	return ans;
} 
int find(int x,int y){//寻找周围的座椅数
	int js=0;
	for (int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if (xx>=1&&xx<=n&&yy>=1&&yy<=m&&ma[xx][yy]!='X') js++;
	}
	return js;
}
void dfs(int x,int y){//简单dfs搜索
	if (find(x,y)==1) tot++;//记录周围只有一个座椅的座椅数
	ma[x][y]='W';//换一个标记以方便记录每个座椅周围的座椅数
	sum++;//座椅数++
	for (int i=0;i<4;i++){//四个方向遍历
		int xx=x+dx[i],yy=y+dy[i];
		if (xx>=1&&xx<=n&&yy>=1&&yy<=m&&ma[xx][yy]=='O'){
			dfs(xx,yy);
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);//加速神器
	cin>>n>>m>>k;
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			cin>>ma[i][j];
		}
	}//输入地图
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){//遍历地图
			if (ma[i][j]=='O'){
				sum=tot=0;//初始化，sum记录座椅个数，tot记录周围只有一个座椅的座椅个数
				dfs(i,j);//dfs搜索
				if (tot<2&&sum>1){//不合法
					cout<<0<<endl;
					return 0;
				}
				ans=ans*k%inf*ksm(k-1,sum-1)%inf;//套公式
			}
		}
	}
	cout<<ans<<endl;//输出
	return 0;//完美撒花
}
```
### STEP 4 完结撒花！

如果还有什么不懂的地方欢迎 $\text{评论区/私信}$ 问我哦，我会第一时间回复哒！

如果都懂了的话，就点个赞纪念一下你的成长8QWQ!

---

## 作者：绝顶我为峰 (赞：11)

这道题真心感觉挺好的，考得非常综合，给出题人点一个大大的赞（

这道题很明显两个环节：

1. 怎样判断考场符合要求

1. 怎样计数

我们先看第一个问题，正向思考不好入手，转而研究一下不符合要求的。

![](https://cdn.luogu.com.cn/upload/image_hosting/t08u6swy.png)

定义一个格子上下左右的格子数量为它的度，我们注意到不符合条件的格子**要么找不到恰好两个度是 1 的格子，要么出现环**。

通过这条性质我们就可以上手操作了。

在代码实现中我写的要繁琐一些，想法是从一个未到达过的度为 1 的点开始 dfs。

如果这片不符合要求的联通块没有度为 1 的格子那么他不会被 dfs，我们用数组标记它是否被搜到过，整张图看完后如果有没进入的联通块就不符合要求。

如果这片联通块中度为 1 的点多于两个，那么它一定不是一条链，中途一定会在某个节点分叉，那么我们遇到这种情况的时候直接标记退出即可。

如果联通块中恰好有两个度为 1 的点，但出现了环，我们在 dfs 过程中一定会遇到已经搜过的点，标记退出即可。

解决了第一个问题，我们来看怎样计数。

这个计数方法和 [[HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197) 如出一辙，只不过我们这里需要统计合法的数量。

合法的联通块一定是一条链。对于每条链，第一个格子有 $k$ 种方案，以后每个格子都有 $k-1$ 种方案，答案为 $k(k-1)^{size-1}$，其中 $size$ 是这条链的长度。

对于不同链之间，直接将答案相乘即可。

最后不要忘了取模。

喜闻乐见的代码时间（

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
#define int long long
const int mod=998244353;
int n,m,k,d[1001][1001],ans,sum;
bool mp[1001][1001],vis[1001][1001],inque[1001][1001];
const int dx[]={1,0,-1,0};
const int dy[]={0,1,0,-1};
inline int pw(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=res*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return res;
}
void dfs(int x,int y,int fx,int fy)
{
    if(inque[x][y])//出现环
    {
        puts("0");
        exit(0);
    }
    inque[x][y]=1;
    bool flag=0;
    for(register int i=0;i<4;++i)
    {
        int xx=x+dx[i],yy=y+dy[i];
        if(xx<=0||xx>n||yy<=0||yy>m||!mp[xx][yy])
            continue;
        if(xx==fx&&yy==fy)
            continue;
        if(flag)//出现分叉
        {
            puts("0");
            exit(0);
        }
        flag=1;
        dfs(xx,yy,x,y);
    }
}
inline void bfs(int sx,int sy)
{
    int siz=0,qwq=0;
    queue<pair<int,int> > q;
    q.push(make_pair(sx,sy));
    while(!q.empty())
    {
        qwq=0;
        int x=q.front().first,y=q.front().second;
        q.pop();
        if(vis[x][y])
            continue;
        vis[x][y]=1;
        ++siz;
        for(register int i=0;i<4;++i)
        {
            int xx=x+dx[i],yy=y+dy[i];
            if(xx<=0||xx>n||yy<=0||yy>m||!mp[xx][yy])
                continue;
            q.push(make_pair(xx,yy));
        }
    }
    ans=k*pw(k-1,siz-1)%mod*ans%mod;
}
signed main()
{
    ans=1;
    scanf("%lld%lld%lld",&n,&m,&k);
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=m;++j)
        {
            char c=getchar();
            while(c!='X'&c!='O')
                c=getchar();
            mp[i][j]=c=='O';
            if(mp[i][j])
            {
                ++sum;
                if(mp[i-1][j])
                {
                    ++d[i][j];
                    ++d[i-1][j];
                }
                if(mp[i][j-1])
                {
                    ++d[i][j];
                    ++d[i][j-1];
                }
            }
        }
    if(k==1)
    {
        puts(sum==1 ?"1":"0");
        return 0;
    }
    if(!sum)
    {
        puts("0");
        return 0;
    }
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=m;++j)
            if(mp[i][j]&&!vis[i][j]&&d[i][j]<=1)
            {
                dfs(i,j,0,0);
                bfs(i,j);
            }
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=m;++j)
            if(mp[i][j]&&!vis[i][j])//出现没有搜到的联通块
            {
                puts("0");
                return 0;
            }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：monstersqwq (赞：4)

写在前面：这题考察的比较综合，和NOI online3的入门组T2 [观星](https://www.luogu.com.cn/problem/P6566) 有异曲同工之处，此题会稍微困难一些。

看了题目之后，应该能发现题目大致分为两个部分：

- 搜索每个“座位连块”，并判断非条形座位
- 利用乘法原理统计答案（记得有模数哦）

### 1：搜索

这里使用的是 DFS

先处理连通块：这个其实不难，就是普通的连通块搜索，记得不要回溯。如果不会请看代码

接下来是判非条形：按照题意模拟即可，非条形有两种情况：

- 任意一个位置相邻有3个及以上的位置
- 相邻有1个位置的位置数量不是2个且不是由单个位置组成的连通块（即相邻有0个位置的位置数量是0）

那么我们可以把原本是 void 类型的 dfs 函数改为 int 类型，返回此格子是否是一个位置，是的话返回1，不是返回0，具体可看代码理解。

### 2：统计答案

根据乘法原理我们知道，答案是所有连通块各自的方案数的乘积。

那么我们只要推出当某条形座位的座位数量为 $i$ 时，它的座位安排方式数量，这里我用 $s$ 来记录。

推理：从一个端点开始推，这个端点的方案是 $k$，对于其它座位，影响它的只有上一个座位（即不能选的只有上一个座位的颜色），于是有 $k-1$ 种方案，有 $i-1$ 个座位，用乘法原理统计得：

$$s_i=k\times (k-1)^{i-1}$$

即：

$$s_1=k,s_i=s_{i-1}\times (k-1)\quad(2\le i\le n\times m)$$


对了，记得模数（建议用 define 或者 const 来代替，不要次次打一大长串数字）

### 一些其它的东西：

介绍一下使用的变量/数组：

$flag$ 是当前连通块是不是条形座位，$sum1$ 是当前连通块有多少个相邻座位有1个的座位，$sum0$ 同理，$ans$ 是答案。

$map$ 是地图（没有引用 map 头文件，可以使用，万能头使用者慎用），能走为 true。$vis$ 是记录有没有走过的数组，走过为 true。

一些不理解的可以看代码理解。

最后再提醒一遍，千万不要忘了模数，很多地方都需要

```
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#define mod 998244353
using namespace std;
long long n,m,k,ans=1,s[1000005],cnt,sum1,sum0;
bool map[1005][1005],vis[1005][1005],flag;
int dx[4]={0,0,-1,1};
int dy[4]={-1,1,0,0};//DFS御用方向数组
int dfs(int x,int y)
{
	if(x<1||x>n||y<1||y>m) return 0;
	if(map[x][y]==false) return 0;
	if(vis[x][y]) return 1;//重点：这里虽然走过了，但是还是算周围座位的，所以要return 1
	vis[x][y]=true;
	int tmpp=0;//代表当前座位相邻座位数量
	cnt++;
	for(int i=0;i<=3;i++)
	{
		tmpp+=dfs(x+dx[i],y+dy[i]);//搜索下一层+统计相邻座位数量
	}
	if(tmpp==0) sum0++;
	if(tmpp==1) sum1++;
	if(tmpp>2) flag=false;//第一种情况
	return 1;
}
int main()
{
	cin>>n>>m>>k;
	s[1]=k;
	for(int i=2;i<=n*m;i++)
	{
		s[i]=s[i-1]*(k-1)%mod;
	}//记录s数组
	for(int i=1;i<=n;i++)
	{
		string tmp;
		cin>>tmp;
		for(int j=1;j<=m;j++)
		{
			if(tmp[j-1]=='O') map[i][j]=true;
			else map[i][j]=false;
		}
	}//读入处理
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(map[i][j]==true&&vis[i][j]==false)
			{
				cnt=0;
				sum1=0;
				sum0=0;
				flag=true;//恢复初始状态
				dfs(i,j);
				if(sum1!=2&&sum0==0) flag=false;//第二种情况
				if(flag==false)
				{
					cout<<"0"<<endl;
					return 0;
				}
				ans*=s[cnt];
				ans%=mod;
			}
		}
	}
	cout<<ans<<endl;
    return 0;
}
```


---

## 作者：zmxqs (赞：3)

发布一个代码量较大的题解（相比提交记录好像没几个有这么长的）

调试起来可能会有困难，不过用了函数之后会简洁明了

Step1：判断是否为长条

```cpp

inline int near(int x,int y) {//判断该点是否构成非长条（只要一个点它是有座位的且的四方向超过两个点有座位就不是长条） 
	
	int mycnt = 0 ;
	
	for(int i=0; i<4; ++i) {
		if(a[x + dx[i]][y + dy[i]] == true) {
			++ mycnt ;
		}
	}
	
	return mycnt ;
}

bool isStrip() {//遍历数组判断是否有非长条 
	
	for(int i=2; i<n; ++i) {
		for(int j=2; j<m; ++j) {
			if(a[i][j] == true && near(i,j) > 2) {//如果这个边的四周有超过两个座位就不是长条
				return false ;
			}
		}
	}
	
	return true ;
}

bool isRing() {//长条还不能是环，否则27个点会WA
// 尝试用 SPFA/BFS 自己写一个判环的函数吧
}

```

为了防止抄袭，这里就空缺出一个函数的位置让读者们自行书写

相信不是很难，如果实在不会的话可以**把代码私发给我**，我可以将我的代码发给你

Step2：算方案

法1：直接快速幂，公式为$f_i = k * (k-1)^{i-1}$

这种做法是可行的，因为这种方法简单，不做赘述

注意要**快速幂**，慢慢地乘和调用 cmath 库的话会 TLE

时间复杂度 $\sum_{a=1}^{N}O(log_2a)$

其中 N 为连通块的数量，a 为每个连通块的元素数量

法2：动态规划（预处理）

用动态规划来预处理，时间复杂度$O(log_2 N)$

$N$ 最好是一个比较大的数，但不是越大越好，这里推荐的是$\frac{mn}{2}$

（mn 为题目中的 mn）

状态转移方程为 $f_1=k,f_i = f_{i-1}*(k-1)$

注 $i \geq 2$

```cpp

void DP() {//预处理，dp[i]表示这个长条有 i 个方格时的学生座位的方案数 
	dp[1] = k;
	for(int i=2; i<= n * m; ++i) {
		dp[i] = dp[i - 1] * (k - 1) % mod;
	}
	return ;
}

```


step3：找连通块

有点像模板，不会的做下 NOI Online Round 3 PJ T2

[宣传下个人题解](https://fangxizheng.blog.luogu.org/solution-p6566)

自认为讲得还不错，有错误还请指出

```cpp

void count(int x,int y) {//DFS(Deepth First Search) 找一下有多少连通块 
	if(a[x][y] == false) {
		return ;
	}
	
	a[x][y] = false ;
	++ cnt ;//计数
	
	for(int i=0; i<4; ++i) {//四方向
		count(x + dx[i] , y + dy[i]) ;
	}
	
	return ;
}
```

Step3：输入

竟然还有人不会

Code

```cpp

void input() {//ÊäÈë 
	ios_base :: sync_with_stdio(false) ;
	cin.tie(0) ;

	memset(a,false,sizeof(a)) ;
	char c ;
	cin >> n >> m >> k ;
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=m; ++j) {
			cin >> c ;
			if(c == 'O') {
				a[i][j] = true ;
			}
		}
	}

	return ;
}
```

Step4：Main

不想多讲

```cpp

int main() {//主程序，用了函数应该很清晰了吧 
	input() ;
	
	if(! isStrip() || isRing) {
		printf("0\n") ;
		return 0;
	}
	
	DP() ;
	
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=m; ++j) {
			if(a[i][j] == true) {
				cnt = 0 ; 
				count(i,j) ;
				ans *= dp[cnt] ;//乘法原理 
				ans %= mod ;
			}
		}
	}
	
	printf("%lld",ans) ;
	return 0 ;
}



```

最终程序

Code

```cpp
#include<bits/stdc++.h>
#define N 1005
#define M 1005
#define MS (N * M)
using namespace std;

const int mod = 998244353 ;
int n,m,k ;
int a[N][M] ;

int dx[] = { 1, 0,-1, 0};
int dy[] = { 0,-1, 0, 1};

inline int near(int x,int y) {//判断该点是否构成非长条（只要一个点它是有座位的且的四方向超过两个点有座位就不是长条） 
	
	int mycnt = 0 ;
	
	for(int i=0; i<4; ++i) {
		if(a[x + dx[i]][y + dy[i]] == true) {
			++ mycnt ;
		}
	}
	
	return mycnt ;
}

bool isStrip() {//遍历数组判断是否有非长条 
	
	for(int i=2; i<n; ++i) {
		for(int j=2; j<m; ++j) {
			if(a[i][j] == true && near(i,j) > 2) {
				return false ;
			}
		}
	}
	
	return true ;
}

int cnt = 0 ;

void count(int x,int y) {//DFS(Deepth First Search) 找一下有多少连通块 
	if(a[x][y] == false) {
		return ;
	}
	
	a[x][y] = false ;
	++ cnt ;
	
	for(int i=0; i<4; ++i) {
		count(x + dx[i] , y + dy[i]) ;
	}
	
	return ;
}

long long dp[MS] ;

void DP() {//预处理，dp[i]表示这个长条有 i 个方格时的学生座位的方案数 
	dp[1] = k;
	for(int i=2; i<= n * m; ++i) {
		dp[i] = dp[i - 1] * (k - 1) % mod;
	}
	return ;
}

void input() {//输入 
	ios_base :: sync_with_stdio(false) ;
	cin.tie(0) ;

	memset(a,false,sizeof(a)) ;
	char c ;
	cin >> n >> m >> k ;
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=m; ++j) {
			cin >> c ;
			if(c == 'O') {
				a[i][j] = true ;
			}
		}
	}

	return ;
}

bool isRing(int x,int y) {


}
long long ans = 1 ;

int main() {//主程序，用了函数应该很清晰了吧 
	input() ;
	
	if(! isStrip() || isRing) {
		printf("0\n") ;
		return 0;
	}
	
	DP() ;
	
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=m; ++j) {
			if(a[i][j] == true) {
				cnt = 0 ; 
				count(i,j) ;
				ans *= dp[cnt] ;//乘法原理 
				ans %= mod ;
			}
		}
	}
	
	printf("%lld",ans) ;
	return 0 ;
}




```



---

## 作者：pigstd (赞：3)

因为座位都是条形的，那么对于一个长度为$len$的条形座位，在第一个点有$k$种可能，此后的$len - 1$个点，每个点都不能和前面的点相同，就有$k - 1$种可能，根据乘法原理可知总共的可能数是$k \times (k - 1)^{len - 1}$

那么，我们只要判断联通块并且统计出每个联通块的大小，并且乘起来，就可以拿到$80\%$的分数了

为了拿到$100\%$的分数，我们要判断座位是否是条形的。如果一个座位不是条形的，那么他有两种可能：

1.座位是一个环。

那对于每个环，显然每个点都有$2$个与他连接的点，即没有一个点**只**有一个座位与其连接，而对于一个条形的座位，那么**一定有**两个点只有一个座位与其连接（当然，如果一个联通块中只有一个座位，那么也是满足“环”的判断的，但是它并不是环，所以我们要特判）。所以，我们只要记录对于每一个点与此连接的点中只有一个点的情况数，进行判断即可

2.有$3$个及以上的点与一个点联通。

那么我们只有记录对于每一个点，有没有$3$个及以上的点与其联通即可

c++代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int Mod=998244353;
const int M=1e3+10;
int a[M][M],n,m,k,ans=1,p;
int vis[M][M],t;

int fx[]={1,-1,0,0};
int fy[]={0,0,1,-1};
int flag=0;

void dfs(int x,int y)
{
	vis[x][y]=++t;
	int sum=0;
	for (int i=0;i<4;i++)
	{
		int tx=x+fx[i],ty=y+fy[i];
		if (a[tx][ty]==1)
		{
			sum++;//sum记录对于每个点，与其联通的点的个数
			if (vis[tx][ty]==0)
				dfs(tx,ty);
		}
	}
	if (sum>=3)
		flag=1;//flag记录第二种情况
	if (sum==1)
		p++;//p记录只有一个点与其联通的个数
}

signed main()
{
	cin>>n>>m>>k;
	for (int i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		for (int j=0;j<m;j++)
			if (s[j]=='O')
				a[i][j+1]=1;//存图
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (!vis[i][j]&&a[i][j])
			{
				t=0,p=0,dfs(i,j);//dfs判断联通块
				if (p==0&&t!=1)//判断第1中情况
					flag=1;
				for (int i=1;i<t;i++)
					ans=(ans*(k-1))%Mod;
				ans=(ans*k)%Mod;
			}
	if (flag)//如果flag为0，说明考场不满足要求，输出0
		cout<<0;
	else
		cout<<ans;
	return 0; 
}
```

---

## 作者：SUNCHAOYI (赞：2)

条形座位的定义：**在 $n$ 个座位中有 $2$ 个座位只有一个相邻的座位(为端点) 其余 $n - 2$ 个座位均有两个相邻的座位。($n = 1$ 时也算)**

----

### $\texttt{subtask 1-3}$ 

即为$n = 1$ 的情况，说明只有一行，因此一定是条形座位。那么我们只需要根据**乘法原理**将每组条形座位的方案相乘即可。

那么每组条形座位的方案如何计算呢？还是**乘法原理**！我们先回顾一下选座位的要求：任意考生不可能和来自同学校的考生座位相邻。   
**那么对于 $k$ 个学校的学生与一个长度为 $m$ 的条形座位。[$k \ge 2$]** 第一个位置肯定有 $k$ 种情况；第二个座位的学生与第一个的来自不同的学校，所以只有 $k - 1$ 种情况；第三个座位的学生与第二个的来自不同的学校，但可以与第一个的来自相同的学校，所以仍然有 $k - 1$ 种情况。

综上所述，上面的一组条形座位的方案数为 $k \times (k - 1) ^ {n - 1}$ $[k \ge2]$。   
根据这个，我们就可以得到 $40pts$ 的代码：
```
#include <iostream>
#define MOD 998244353 
using namespace std;
char a[1005][1005];
int an[1005];
int main()
{
	int n,m,k,w = 0;long long ans = 1;//long long！！！
	cin>>n>>m>>k;
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= m;++j) cin>>a[i][j]; 
	for(int i = 1;i <= m;i++) 	
	{
		if(a[1][i] == 'O' && a[1][i - 1] != 'O') an[++w]++;//新的条形座位
		else if(a[1][i] == 'O') an[w]++;//座位的长度增加
	}
	for(int i = 1;i <= w;i++)
	{
		long long num = k;
		for(int j = 2;j <= an[i];j++) num *= k - 1,num %= MOD;//计算与取模
		ans *= num;ans %= MOD;//答案累计取模
	}
	cout<<ans<<endl;
	return 0;
}
```

---

### $\texttt{subtask 4，5}$

我们将上面的思路由一维扩展到二维，发现我们只要进行一次搜索进行连通块数量的统计就行了。  

需要多开一个 `vis[1005][1005]` 的数组，用于**记录该点是否到达过**。每一个连通块的大小都要单独计算，因此在搜索完毕后会得到**若干个大小不同的条形座位**，分别经过上述公式计算后相乘即可得出答案。$80pts$ 的代码如下：
```
#include <iostream>
#define MOD 998244353 
#define MAX 1005
#define ll long long
using namespace std;
char a[MAX][MAX];
ll an[MAX],ans = 1;
bool vis[MAX][MAX];
int dx[4] = {1,-1,0,0},dy[4] = {0,0,1,-1},n,m,k,w;
void search(int x,int y);
int main()
{
	
	cin>>n>>m>>k;
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= m;++j) cin>>a[i][j];
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= m;++j)
			if(!vis[i][j] && a[i][j] == 'O') w++,search(i,j);
	for(int i = 1;i <= w;++i)//计算
	{
		ll sum = k;
		for(int j = 2;j <= an[i];++j) sum *= k - 1,sum %= MOD;
		ans *= sum,ans %= MOD;
	}
	cout<<ans<<endl;
	return 0;
}
void search(int x,int y)
{
	vis[x][y] = 1;an[w]++;//标记已经到过，答案加1
	for(int i = 0;i < 4;++i)
	{
		int xx = x + dx[i],yy = y + dy[i];
		if(1 <= xx && 1 <= yy && xx <= n && y <= m && !vis[xx][yy] && a[xx][yy] == 'O') search(xx,yy);//搜索
	}
}
```

----

### $\texttt{subtask 6}$

可能出现不是条形座位的情况，因此我们需要判断每个连通块是否合法。若不合法，就要**特判输出 $0$** 。那么我们如何去检查呢？

我们可以开一个**队列**：每次搜索计数一个连通块时，搜索到一个新的点时，把该点的坐标记录到队列中去。在搜索完毕后，进行统一的检查。不断取出队列中的元素，若**不满足**只有 $2$ 个相邻座位数为 $1$ 的点且其余座位的相邻座位数均为 $2$，就说明不满足条件，**输出 $0$ 并停止程序**。需要注意的是，只有一个座位的情况需要额外的特判。

综上所述，我们就得到了 $100pts$ 的代码：
```
#include <iostream>
#include <queue>
#define MOD 998244353 
#define MAX 1005
#define ll long long
using namespace std;
struct node
{
	int x,y;
};
queue <node> q;
char a[MAX][MAX];
ll an[MAX],ans = 1;
bool vis[MAX][MAX];
int dx[4] = {1,-1,0,0},dy[4] = {0,0,1,-1},num[MAX][MAX],n,m,k,w;
void search(int x,int y);
bool check();
int main()
{
	
	cin>>n>>m>>k;
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= m;++j) cin>>a[i][j];
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= m;++j)
			if(!vis[i][j] && a[i][j] == 'O')
			{
				w++;search(i,j);
				if(!check())
				{
					cout<<0<<endl;
					return 0;
				}
			}
	for(int i = 1;i <= w;++i)
	{
		ll sum = k;
		for(int j = 2;j <= an[i];++j) sum *= k - 1,sum %= MOD;
		ans *= sum,ans %= MOD;
	}
	cout<<ans<<endl;
	return 0;
}
void search(int x,int y)
{
	q.push({x,y});
	vis[x][y] = 1;an[w]++;
	for(int i = 0;i < 4;++i)
	{
		int xx = x + dx[i],yy = y + dy[i];
		if(1 <= xx && 1 <= yy && xx <= n && y <= m && !vis[xx][yy] && a[xx][yy] == 'O') search(xx,yy);
	}
}
bool check()
{
	int tt = 0;
	if(q.size() == 1)
	{
		q.pop();
		return 1;//特判 
	}	
	while(!q.empty())//检查
	{
		int t = 0;
		node ch = q.front();q.pop();
		if(a[ch.x][ch.y - 1] == 'O') t++;
		if(a[ch.x][ch.y + 1] == 'O') t++;
		if(a[ch.x - 1][ch.y] == 'O') t++;
		if(a[ch.x + 1][ch.y] == 'O') t++;
		if(t == 1) tt++;
		if(t > 2) return 0;//相邻座位大于2
		//cout<<ch.x<<" "<<ch.y<<"  "<<t<<endl;
	}
	if(tt == 2) return 1;//相邻座位只有1的点恰好只有2个
	else return 0;
}
  ```

---

## 作者：_jimmywang_ (赞：1)

### 【$LGR-072$】洛谷 $5$ 月月赛 $T2$ 座位调查 解题报告

首先，一看就知道有两个小任务：

$1.$判断是不是条形座位。

$2.$如果是，那么把$k$种选手塞到座位里有多少种方案。

我们一看数据：啊，$n=1$时一定是条形的；再看看？啊，只有最后的那$20pts$有可能不是条形的~

于是条形不条形再说，先解决第二个小任务。

### $Substack1:$

$n=1,k=2?$

那好办，单独拿出一条座位康康：

![](https://cdn.luogu.com.cn/upload/image_hosting/cz2ur9dm.png)

只有这两种坐法（红1蓝2）

所以运用一些排列组合，答案就是$2^{座位条数}$

那座位条数咋算？

简单，要么有一个座位，它相邻座位数是0，就是一条；再加上相邻座位数为1的座位数除以二就是条数了（每条必定有两个邻座位数为1的座位）

如果用$cmp_i$表示相邻座位数为$i$的座位数，那么答案就是$2^{cmp_0+cmp_1/2}$

$p.s.$推广：在$Substack4$里，$k=2$。

我们发现，上面这个结论对于任何$k=2$都管用，不管是一长条还是贪吃蛇一条。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/v4ex202l.png)

诶？还是两种~

所以$Substack1$和$Substack4$的答案都一样：是$2^{cmp_0+cmp_1/2}$

于是，30分到手~

### $Substack2:$

还是一长条。

$k \leq 8$？爆搜算了~

总共$45pts$

### $Substack3,5:$

啊啊啊啊啊，$k$的范围呢？？？难不成是$k \leq 1e9?$

。。。好像是的。。。

那我们就要来找找规律了。

还是这张~~一条贪吃蛇~~：
![](https://cdn.luogu.com.cn/upload/image_hosting/4hin2go9.png)

往里面填填数，表示有几种可能的选手位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/ka6vayux.png)

???

诶诶诶？？？

所以规律就显而易见了。。。

$ans=k^{cmp_0+cmp_1/2}*(k-1)^{cmp_2+cmp_1/2}$

到这里，你已经有$80pts$了！！！

### $Substack6:$

好，来看看是不是一条吧。

首先，如果出现了有个座位相邻的有3个或4个，果断放弃

再者，像样例三，一团只有2没有1的，也走开。

最后，$cmp_1$%$2=1$的，也不行。

于是就这样了。。。

$all$ _ $the$ _ $code$ _ $above$:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll r() {
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	if(c=='-')f=-1,c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d r()
ll n,m,k,ans=1;
char mp[1010][1010];
ll mpp[1010][1010];
ll cmp[5];
int main(){
	n=d,m=d,k=d;
	f(i,1,n)
		f(j,1,m)cin>>mp[i][j];
	f(i,1,n)
		f(j,1,m)
			{mpp[i][j]=(mp[i][j-1]=='O')+(mp[i-1][j]=='O')+(mp[i][j+1]=='O')+(mp[i+1][j]=='O');if(mp[i][j]=='O')cmp[mpp[i][j]]++;}
	if(cmp[3]||cmp[4]||cmp[1]%2){cout<<0;return 0;}
	if(cmp[1]==0&&cmp[2]){cout<<0;return 0;}
	f(i,1,cmp[1]/2+cmp[0])ans=ans*k%998244353;
	f(i,1,cmp[2]+cmp[1]/2)ans=ans*(k-1)%998244353;
	printf("%lld",ans);
	return 0;
}
```
$p.s.$我们机房的人均使用$dfs$，而且有人卡到$24ms$,我的这玩意$O(nm)$的$233ms$~~没脸见人~~，本蒟蒻不擅长搜索，有没有巨佬帮帮忙吖~

---

## 作者：VinstaG173 (赞：1)

由于只要求相邻的位置坐的学生来自不同学校，并且座位肯定是长条形。

所以我们可以让其中一端任意安排一个学校的学生，有 $k$ 种，然后沿着相邻座位走，每个座位安排除了前一个座位上学生的学校以外的任意一个学校的学生，有 $k-1$ 种。

于是由乘法原理有一个由 $x$ 个格子组成的长条形中的学生来自的学校共有 $k(k-1)^{x-1}$ 种不同可能。

然后我们用 dfs，只走座位，记录来的方向，如果除了上一步走到的格子以外有访问过的格子，说明有环，不是长条形（因为每个座位相邻最多有两个格子是座位，且这两个格子不能连通，即没有环）。再由乘法原理把每次 dfs 求出的长条形的贡献相乘就得到了答案。

但是还是要注意一些细节（

Code:
```cpp
#include<cstdio>
const int ntf=998244353;
int n,m,k,ans=1;
char s[1007][1007];
int vis[1007][1007];//记录是否访问过
int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//方向，0,1,2,3 分别表示左，上，右，下，所以相对方向的异或值为 2
int dfs(int x,int y,int d)//d 表示来的方向
{
	int f=0,r,c,t=0;
	vis[x][y]=1;//标记已访问
	for(int i=0;i<4;++i)
	{
		if(i==(d^2))continue;//避免走回头
		r=x+dir[i][0],c=y+dir[i][1];
		if(r<0||r==n||c<0||c==m)continue;//越界
		if(s[r][c]=='X')continue;//只走座位
		if(vis[r][c])return 0;//有环，不是长条形
		if(f)return 0;//有超过两个相邻格，不是长条形
		t=dfs(r,c,i);f=1;//记录已经有相邻格
		if(!t)return 0;//已经判断为不是长条形
	}
	return t+1;
}
inline int qpw(int x,int v)
{
	int r=1;
	while(v)
	{
		(v&1)&&(r=1ll*r*x%ntf);
		x=1ll*x*x%ntf;
		v>>=1;
	}
	return r;
}
int main()
{
	scanf(" %d %d %d",&n,&m,&k);
	for(int i=0;i<n;++i)scanf(" %s",s[i]);
	for(int i=0;i<n;++i)
	{
		for(int j=0;j<m;++j)
		{
			if(s[i][j]=='X'||vis[i][j])continue;
			int cnt=0;
			for(int d=0;d<4;++d)
			{
				int r=i+dir[d][0],c=j+dir[d][1];
				if(r<0||r==n||c<0||c==m)continue;
				if(s[r][c]=='O')++cnt;
			}//以上 7 行记录相邻的座位数
			if(cnt>2)
			{
				printf("0\n");//有超过两个相邻座位，不是长条形
				return 0;
			}
			if(cnt==2)continue;//只从端点开始 dfs
			int q=dfs(i,j,4);
			if(!q)
			{
				printf("0\n");//不是长条形
				return 0;
			}
			ans=1ll*ans*qpw(k-1,q-1)%ntf*k%ntf;
		}
	}
	for(int i=0;i<n;++i)
	{
		for(int j=0;j<m;++j)
		{
			if(s[i][j]=='X'||vis[i][j])continue;
			int cnt=0;
			for(int d=0;d<4;++d)
			{
				int r=i+dir[d][0],c=j+dir[d][1];
				if(r<0||r==n||c<0||c==m)continue;
				if(s[r][c]=='O')++cnt;
			}
			if(cnt==2)
			{
				printf("0\n");//如果有座位相邻有两个，并且没有被访问，说明有环，不是长条形（即样例 3 的情况）
				return 0;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

话说我写题解的时候把自己叉了三次……建议加强数据（

---

## 作者：那一条变阻器 (赞：0)

目前还没有BFS的题解，我来一篇BFS的qwq。


------------

这道题就两个步骤：

**1.找联通块个数：判断是否符合标准并且找联通块个数**

我用的广搜实现的，思路挺简单的：

先找一个联通块的端点，根据题中的定义，一个联通块的端点，周围所不是座位的个数（指上下左右），只有3个，或者4个（只有一个点的情况），对这个点进行搜索，标记，然后扩展，遇到下一个座位，就走，走过就标记，并对联通块计数的加一，最后返回走的联通块的座位数。

**那么，如何判断这不是正确的教室呢？** 因为我们对搜过的都进行了标记，所以我们可以判断有没有是座位却没有被标记的情况，因为只有有端点的才能是符合标准的，没有对这一块进行搜索，那就是没有端点，也就不符合了。又因为我们从端点开始搜索的，那就说明每一个点能扩展的点，就只有一个点（本来应该是两个的，但是因为前一个点被标记了，也不能走，相当于只能扩展一个），我们可以进行统计每一个点能扩展的点，如果大于1，就也是错的。

**2.对方法数目进行计算：利用乘法原理**

~~啊本人不会画图就手打了吧~~

对于这一块的话OOOOOOO ，第一个可以填k个学校，那么后面一个就只能填k-1学校，后面的也是，以此类推，可以得到每一个联通块的方法数目为：$k\times(s-1)^(k-1)$  （这里是乘方啊可能看不大清楚），其中size为联通块大小，然后对于所有联通块一起的方法书，也一样，全乘起来就okk。

剩下的细节之类的都在代码里面了，~~码代上~~上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long dx[] = {1 , 0 , -1 , 0} , dy[] = {0 , -1 , 0 , 1};	//上下移动 
long long n , m , k , sum , p = 998244353;	//sum是联通块个数 
long long s[1000010];	//存储每一个联通块的大小 
char a[1010][1010];	//存储图 
bool f;	//判断是否座位只联通一个座位 
bool vis[1010][1010];	//标记 
struct node{
    long long c , d;
};
long long ksm(long long x , long long y){	//快速幂，怕超时，没去试pow（x，y）会不会超时 
    long long ret = 1;
    y %= p;
    x %= p;
    while(y){
        if(y % 2 == 1){
            ret = ret * x;
            ret %= p;
        }
        x = x % p * x % p;
        x %= p;
        y /= 2;
    }
    return ret;
}
long long pd(long long x , long long y){	//统计周围不是座位的个数 
    long long sssum = 0;
    if(a[x + 1][y] != 'O') sssum++;
    if(a[x - 1][y] != 'O') sssum++;
    if(a[x][y + 1] != 'O') sssum++;
    if(a[x][y - 1] != 'O') sssum++;
    return sssum;
}
long long bfs(long long x , long long y){	//广搜 
    long long t = 1;
    queue<node> q;
    node nod;
    nod.c = x;
    nod.d = y;
    q.push(nod);
    node now;
    vis[x][y] = 1;
    while(!q.empty()){
        now = q.front();
        q.pop();
        long long tt = 0;
        for(int v = 0; v <= 3; v++){
            int nx = now.c + dx[v] , ny = now.d + dy[v];
            if(!vis[nx][ny] && a[nx][ny] == 'O'){
                tt++;	//统计这个点能扩展的点的个数 
                t++;
                vis[nx][ny] = 1;
                nod.c = nx;
                nod.d = ny;
                q.push(nod);
            }
        }
        if(tt > 1){	//大于一个就说明不符合要求，并且不能用不等于，因为最后一个点是不能扩展的，就是0，但是合法 
            f = true;
            return 0;	//不符合直接返回 
        }
    }
    return t;
}
int main(){
    cin >> n >> m >> k;
    for(int i = 1; i <= n + 5; i++)
        for(int j = 1; j <= m + 5; j++) a[i][j] = 'X';	//初始化 
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) cin >> a[i][j];
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            if(a[i][j] == 'O' && !vis[i][j]){	//找端点。为什么有vis？因为一个联通块有两个端点我们只需要搜索一次就OK 
                int ha = pd(i , j); 
				if(ha < 3) continue;	//不是端点 
                f = false;
                sum++;	//块数加一 
                s[sum] = bfs(i , j);
                if(f){	//不符合条件 
                    cout << 0;
                    return 0;
                }
            }
        }
    for(int i = 1; i <= n; i++)	//找没搜过却是座位的情况，也是错误的 
    	for(int j = 1; j <= m; j++)
    		if(a[i][j] == 'O' && !vis[i][j]){
    			cout << 0;
                return 0;
			}
    long long ans = 1;
    k %= p;
    for(int i = 1; i <= sum; i++){
        ans *= k % p * ksm((k - 1) , s[i] - 1) % p;	//记得每一次都mod一下，不然会只有30分的，别问我怎么知道的，调了半天的 
        ans %= p;
    }
    cout << ans % p;
    return 0;
}
/*
7 7 99
XOOXOOO
XOXXXXO
XOOXOXO
XXXXOXO
XOOXOOO
XXOXXXX
XOOXOOO
*/
```
啊就这么多了，一道不错的搜索题

---


# [COCI 2015/2016 #5] POPLAVA

## 题目描述

有一个由 $N$ 列组成的柱状图，从左至右的柱子高度分别为 $h_1,h_2,\dots,h_N$。

现在你需要向其中储水，柱状图的容量定义为使得水的结构“稳定”时最多所能储水的量。即水在重力作用下不会流动。下图为一个稳定的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/7tnaf06j.png)

具体来说，我们设从左至右每一列上水的高度为 $v_1,v_2,\dots,v_N$。记 $s_i=h_i+v_i$ ，当满足下列条件时为稳定状态：

- 对于任意的 $i\geq2$，当$v_i>0$ 时，有$s_i\le s_{i-1}$；

- 对于任意的 $i\le N-1$，当$v_i>0$ 时，有$s_i\le s_{i+1}$；

- $v_1=v_N=0$。

现在你需要选择一个 $1\sim N$ 的排列作为柱子 $h_1,h_2,\dots,h_N$ 的高度，使得柱状图的容量为 $X$。如果不存在，则输出 `-1`。如果有多种方案，输出任意一种即可。



## 说明/提示

#### 样例解释

##### 样例 $1$

$v_1=0,v_2=1,v_3=0$。

##### 样例 $2$

$v_1=0,v_2=0,v_3=1,v_4=0$。

##### 样例 $3$

此样例与题图所对应。

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le N\le 10^6$，$1\le X\le 10^{15}$。

#### 说明

**题目译自 [COCI2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #5](https://hsin.hr/coci/archive/2015_2016/contest5_tasks.pdf) *T4 POPLAVA***。

## 样例 #1

### 输入

```
3 1```

### 输出

```
3 1 2```

## 样例 #2

### 输入

```
4 1```

### 输出

```
4 3 1 2```

## 样例 #3

### 输入

```
8 17```

### 输出

```
6 2 3 1 8 4 5 7```

# 题解

## 作者：JK_LOVER (赞：5)

## 题意
使得柱状图的容量为 $X$ 。如果不存在，则输出 $-1$。否则输出任意一种方案。[QAQ](https://www.luogu.com.cn/blog/xzc/solution-p6726) 。
## 分析
众所周知构造永远要比解决难度大，考虑这个题的特殊性

- 最左和最右的的柱子永远没法储水。

- 储水的柱子左右总有比它高的。

那么我们如果画这样一张图就一目了然了。
![](https://cdn.luogu.com.cn/upload/image_hosting/rmp0fo5i.png)

这样所有储水的柱子全在 $n$ 号和 $n-1$ 号柱子之间了。移除一个柱子的那么储水就会减少 $(n-1)-id$ 这样多。那么我们只要将标号有小到大枚举，这样就保证了不重不漏。而无解的情况就只有
$$
X > (n-2)\times (n-1) - \frac{((n-2)+1)\times (n-2)}{2}
$$
划重点：不要用 $dfs$ 实现这样过程，会很慢。
## 代码
$\text{80分的dfs}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 1000100;
LL n,X,maxflow,d;
int ans = 0,top = 0,cnt[N],vis[N];
void dfs(LL f)
{
	if(ans) return;
	if(f == 0){
//		sort(cnt+1,cnt+1+top);
		for(int i = 1;i <= top;i++){
			printf("%d ",cnt[i]);
		}
		printf("%d ",n);
		for(int i = 1;i <= n-2;i++)
		if(!vis[i]) printf("%d ",i);
		printf("%d ",n-1);
		ans = 1;
		exit(0);
	}
	for(int i = 1;i <= n-2;i++)
	{
		if(!vis[i] && (f - ((n-1) - i) >= 0))
		{
			cnt[++top] = i;vis[i] = 1;
			dfs(f - ((n-1)-i));
		}
	}
}
int main()
{
	cin>>n>>X;
	maxflow = (n-1)*(n-2) - (1+(n-2))*(n-2)/2;
	d = maxflow - X;
	if(d < 0){
		printf("-1\n");
		return 0;
	}
	dfs(d);
	return 0;
}
```
$\text{100分的循环实现}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 1000100;
LL n,X,maxflow,d;
int ans = 0,top = 0,cnt[N],vis[N];
int main()
{
	cin>>n>>X;
	maxflow = (n-1)*(n-2) - (1+(n-2))*(n-2)/2;
	d = maxflow - X;
	if(d < 0){
		printf("-1\n");
		return 0;
	}
	for(int i = 1;i <= n-2;i++)
	{
		if(d - ((n-1)-i) >= 0)
		{
			vis[i] = 1;
			cnt[++top] = i;
			d -= ((n-1)-i);
		}
	}
//	sort(cnt+1,cnt+1+top);
	for(int i = 1;i <= top;i++){
		printf("%d ",cnt[i]);
	}
	printf("%d ",n);
	for(int i = 1;i <= n-2;i++)
	if(!vis[i]) printf("%d ",i);
	printf("%d ",n-1);
	return 0;
}
```



---

## 作者：Ender_Forever (赞：2)

## 题目描述

给你两个数 $n,x$，求使用 $1\sim n$ 个柱子让组成的柱状图容量为 $x$。

## Solution

~~一眼看过去，这道题类似于水桶效应~~

我们举一个例子：\
$n=8$，该柱状图最大容量的图应为

```latex
       *
*      *
*     **
*    ***
*   ****
*  *****
* ******
********
```

这个柱状图的水不能溢过第 $1$ 列，所以第 $2$ 列至第 $7$ 列的容量依次为 $6,5,4,3,2,1$，使用等差数列求和公式可知，这个柱状图容量为 $\frac{7 \times 6}{2}$。把这个公式变成关于 $n$ 的式子，我们就可以得到：

> $1\sim n$ 的柱子组成的柱状图最大容量为 $\frac{(n-1)\cdot(n-2)}{2}$。

然后就可以特判输入的 $n,x$ 是否能建立柱状图。

---

那如何求建立的柱状图容量为 $x$ 呢？

还是以上面的例子说明：\
当我们去掉一根柱子时，相应的会减少 $(7-$“这个柱子长度”$)$，也就是 $(n-1)-h_{i}$。

用 $tmp$ 存这个柱状图需要删去多少容量，遍历 $n-2\sim 1$（$n$ 和 $n-1$ 是两边），我们一次一次删去 $h_{i} \le tmp$ 的柱子，相反的就是删去 $n-1-h_{i}$ 的柱子。

最后我们把删去的柱子放在最后即可。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
#define sp " "
#define Ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
using ll = long long;
using ull = unsigned long long;
using ld = long double;
ll n, x, tmp;
bool vis[1000005];
int main()
{
	Ios;
	cin >> n >> x;
	if (n <= 2)
		cout << -1 << endl,exit(0);
	tmp = (n - 1) * (n - 2) / 2-x;
	if (tmp < 0)
		cout << -1 << endl, exit(0);
	for (ll i = n - 2;i >= 1;i--)
		if (tmp >= i) tmp -= i, vis[n - 1 - i] = 1;
	cout << n - 1 << sp;
	vis[n - 1] = 1;
	for (ll i = 1;i <= n;i++)
		if (!vis[i]) cout << i << sp;
	vis[n - 1] = 0;
	for (ll i = n;i >= 1;i--)
		if (vis[i]) cout << i << sp;
	return 0;
}
```

---

## 作者：dead_X (赞：2)

## 前言
这是一个快读返回值 ll 局部变量 int 喜提 $60$ pts 的傻逼……

这是一个重蹈 CSP-J 395 覆辙打了一堆特判却没有 ``exit(0);`` 喜提 $90$ pts 的傻逼……
## 题意
小清新构造题

构造一个长度 $n$ 的排列使得其容量恰好为 $x$ ，无解输出 $-1$ 。

以下是结论：

1. **一个 $n$ 的排列能构造出的最大容量为 $\frac{1}{2}(n-1)(n-2)$，构造方法为 $(n-1),1,2,3,\cdots,n$**

2. **一个 $n$ 的排列可以构造出所有不高于最大容量的容量。**

第一条是显然的，关键在于第二条是否正确和第二条怎么构造。

然后你发现， $i(i\leq n-2)$ 如果被 $(n-1)$ 和 $n$ 夹着的贡献是 $n-i-1$ 。

那么任务就等同于选出 $1$ 到 $n-2$ 的一些数让总和为 $x$ 了，构造非常简单。剩余的数只需要从小到大排列再放在最前面，使其贡献为 $0$ 即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long read()
{
    long long w=0;
    char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) w=w*10+ch-48,ch=getchar();
    return w;
}
bool vis[1000003];
int main()
{
    long long n=read(),m=read();
    if(n==1) if(m) puts("-1"),exit(0); else puts("1"),exit(0);
    if(n==2) if(m) puts("-1"),exit(0); else puts("1 2"),exit(0);
    if(m>(n-1)*(n-2)/2) puts("-1"),exit(0);
    if(!m) { for(int i=1; i<=n; i++) printf("%d ",i); exit(0); } 
    //Maximum:
    //n-1 n-2 n-3 n-4 ... 1 n
    //Val=1+2+3+...+(n-2)=(n-1)*(n-2)/2;
    for(int i=n-2; i>=1; i--) 
    {
        if(m<=i) 
        {
            vis[n-1-m]=1;
            break;
        }
        else vis[n-1-i]=1,m-=i;
    } 
    for(int i=1; i<=n-2; i++) if(!vis[i]) printf("%d ",i);
    printf("%lld ",n-1);
    for(int i=1; i<=n-2; i++) if(vis[i]) printf("%d ",i);
    printf("%lld\n",n);
    //Answer:
    //没有选上的数(递增) n-1 选上的数(任意顺序) n
    return 0;
}
```

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6726)

# 解析

看不到别的题解？来这里！

## 题目大意

其实我们不必看什么杂七杂八的，看也看不懂。举个稳定的例子。![](https://cdn.luogu.com.cn/upload/image_hosting/fimml5dt.png)图片中的两种情况都是稳定的。为什么呢？我们可以这样想：假如我从上面倒水下来，那么这种情况就会因重力而出现下面的情况。![](https://cdn.luogu.com.cn/upload/image_hosting/om7oqkhw.png)看出来了吗？蓝色的就是水。这里水会堆积在凹进去的部分。假如说我在 $h_5$ 旁边再放一个高度为 $1$ 的柱子，那么这个柱子上面就没有水，因为水会溢出去。

注意：图的左右两端的柱子不能存水。

这就是题意了。

## 考察

本题考查一些推理及数学常识、贪心思想。

我们要知道一个公式：等差数列求和公式：首项加末项的和乘项数除以二。

## 思路

首先，我们可以知道，要想使得存水最大，我们得要让两个最高的柱子放在左右两边。如下。![](https://cdn.luogu.com.cn/upload/image_hosting/fimml5dt.png)至于为什么，那很好解释。由于水面的最大高度只能是我们左右两端柱子的高度中的较小值，所以我们要让最大的两根柱子放两边，使得左右两端柱子的高度中的较小值尽可能的大。

接下来，我们就可以算出在这种情况下的储水量，即最大储水量。![](https://cdn.luogu.com.cn/upload/image_hosting/ks2ypdrh.png)观察图片，我们即可发现：出水量就是：$\frac{1+...+(n-2)=[1+(n-2)]\times(n-1)}{2}$。

此时，我们可以进行一个判断：如果需要出水量都大于最大水量，那么就可以直接输出 $-1$ 了。

```cpp
    cin>>n>>X;
	mxf=(1+(n-2))*(n-2)/2;
	d=mxf-X;
	if(d<0)
	{
		cout<<"-1";
		return 0;
	}
```

接下来，我们就得要移动一下柱子。怎么移动使得积水量最大？明显是将最矮的柱子放在中间，将最高的柱子放两边即可，如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/77mf52w4.png)

首先我们得要明确一点：我们此时得到的 $d$ 表示我们可以造出的最大储水量比题目需要的储水量 $X$ 多多少，所以我们要将这个 $d$ 弄成 $0$。要知道：我们将一个高度为 $i$ 的柱子移到左右两端使其无法装水，那么就相当于储水量减了 $n-1-i$。为什么？因为从上面的图可知：我们是将最高的两根柱子 $n,n-1$ 移到两边来使得这两根柱子之间的储水量最大。那么我们此时的水面高度就是 $n-1$，那么这个柱子原来的储水量就是水面高度减去柱子高度了。

我们可以枚举一下将高度为 $1...n-2$ 的柱子移到两边（即无法注水的地方）。我们用一个 $top$ 表示被移走的柱子数量。用一个数组 $cnt$ 表示被移走的柱子。

```cpp
    for(i=1;i<=n-2;i++)
	{
		if(d-((n-1)-i)>=0)
		{
			vis[i]=1;
			cnt[++top]=i;
			d-=((n-1)-i);
		}
	}
	//cout<<top<<endl;
```

我们接下来输出。首先输出被移走的柱子，接着输出左边的柱子（即最高柱子）高度 $n$，接下来将没有被标记为移走的柱子输出，最后输出右边的柱子 $n-1$ 即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+10;
int n,X,mxf,d;
int ans=0,top=0,cnt[N],vis[N],i;
signed main()
{
	cin>>n>>X;
	mxf=(1+(n-2))*(n-2)/2;
	d=mxf-X;
	if(d<0)
	{
		cout<<"-1";
		return 0;
	}
	for(i=1;i<=n-2;i++)
	{
		if(d-((n-1)-i)>=0)
		{
			vis[i]=1;
			cnt[++top]=i;
			d-=((n-1)-i);
		}
	}
	//cout<<top<<endl;
	for(i=1;i<=top;i++)
	{
		cout<<cnt[i]<<" ";
	}
	cout<<n<<" ";
	for(i=1;i<=n-2;i++)
	{
		if(!vis[i])
		{
			cout<<i<<" ";
		}
	}
	cout<<n-1;
}
```

---

## 作者：wandereman (赞：1)

## 思路
首先，$n$ 根柱子最大可以装水 $\frac{(n - 1) \times (n - 2)}{2}$ 个单位的水。     

所以第一步先构造出两端是 $n$ 和 $n - 1$ 的柱子，然后中间怎么放都可以。     

当然，这中间的几根柱子也得满足可以装水 $\frac{(n - 1) \times (n - 2)}{2}$ 个单位。    

剩下没用的柱子就从小往大的排在最前面（不需要蓄水）就行。  

最后一步要判断无解的情况。
```cpp
mxf = (n - 1) * (n - 2) - (1 + (n - 2)) * (n - 2) / 2;
	d = mxf - X;
	if(d < 0){
		cout<<"-1"<<endl;
		return 0;
	}
```

## AC code
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1000100;
LL n,X,mxf,d;
int ans = 0,top = 0,cnt[N],vis[N],i;
int main(){
	cin>>n>>X;
	mxf = (n - 1) * (n - 2) - (1 + (n - 2)) * (n - 2) / 2;
	d = mxf - X;
	if(d < 0){
		cout<<"-1"<<endl;
		return 0;
	}
	for(i = 1;i <= n - 2;i++){
		if(d - ((n - 1) - i) >= 0){
			vis[i] = 1;
			cnt[++top] = i;
			d -= ((n - 1) - i);
		}
	}
	for(i = 1;i <= top;i++){
		cout<<cnt[i]<<" ";
	}
	cout<<n<<" ";
	for(i = 1;i <= n - 2;i++){
		if(!vis[i]){
			cout<<i<<" ";
		}
	}
	cout<<n - 1<<endl;
	return 0;
}
```

---

## 作者：__Green_tick__ (赞：1)

## 题意分析
使得柱状图的容量为 $X$。如果不存在，则输出 $−1$。否则输出任意一种方案。

## 题目分析
本题的特殊性：
+ 最左和最右的的柱子永远没法储水。
+ 储水的柱子左右总有比它高的。

如下：
```
#
#...#...#
##..#...#
##..#...#
###.##..#
--------------
```
其中`.`表示水，`#`代表柱子，`-`代表桌子。

这样所有储水的柱子全在 $n$ 号和 $n−1$ 号柱子之间了。移除一个柱子的那么储水就会减少 $(n−1)−id$ 这样多。那么我们只要将标号有小到大枚举，这样就保证了不重不漏。而无解的情况就只有。

$$X ⩽ \frac{(n-1)\cdot(n-1)}{2}$$

当然，不一定需要存满水，此时处理非常复杂，但我们可以把多出的部分按升序排序放在 $n−1$ 的前面，前面的部分不能储水。此过程可以循环实现。

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x;
int main(){
    cin>>n>>x;
    if(x>1ll*(n-1)*(n-2)/2){ 
        cout<<"-1"<<endl;
        return 0;
    }else{
	    long long left=(n-1)*(n-2)/2-x;
	    bool vis[n+5]={};
	    for(long long i=n-2;i>=1;i--){
	        if(left>=i){
	            left-=i;
	            vis[n-i-1]=1;
	        }
	    }
	    for(long long i=1;i<=n;i++){
	        if(vis[i]){
	            printf("%lld ",i);
	        }
	    }
	    printf("%lld ",n-1);
	    vis[n-1]=1;
	    for(long long i=1;i<=n;i++){
	        if(!vis[i]){
	            printf("%lld ",i);
	        }
	    }
	}
	return 0;
}
```

---

## 作者：guer_loser_lcz (赞：1)

# 题解
## 思路
 $n$ 根柱子最大蓄水量为 $\frac{(n-2) \times (n-1)}{2}$ 个单位。

构造为两端为 $n - 1$ 和 $n$ ，中间随便放。

然后，这 $n$ 根柱子还可构成所有小于 $\frac{(n-2) \times (n-1)}{2}$ 的容量。

原因：每根在中间柱子的贡献为 $n - 1 - \text{柱子高度}$ ,因此现在问题就变成了用 $1$ 到 $n - 2$ 构造目标容量了。

剩下不用的柱子就从小往大的排在最前面（不蓄水）就行。
## 具体代码

```cpp
cin>>n>>x;
if((n-2)*(n-1)/2<x){
    cout<<-1;
    return 0;
}//判否
long long k=(n-2)*(n-1)/2-x;//算出要减多少容量
```
扔哪几个柱子：

```cpp
	for(int i=n-2;i>=1;i--){
		if(k>=i){
			k-=i;//还要减多少容积
			use[n-1-i]=1;//扔的标记
		}
	}
```
输出：

```cpp
for(int i=1;i<=n;i++)if(use[i])cout<<i<<" ";//扔了的
cout<<n-1<<" ";//最左边的蓄水柱子
use[n-1]=1;//标记一下
for(int i=1;i<=n;i++)if(!use[i])cout<<i<<" ";//剩下的乱扔，因为按顺序输出的，所以高为n的在最右边
```
这题要开 long long 的。

---

## 作者：yuantc (赞：1)

# 思路：
首先，根据题意，非常容易得出 $n$ 根柱子最大可以装  $\frac{2(n-1)×(n-2)}{2}$ 个单位。然后就可以构造两端为 $n$ 和 $n-1$ 的柱子。中间的柱子需注意也要满足能装 $\frac{2(n-1)×(n-2)}{2}$ 个单位，位置随便。其余的不能蓄水，升序排在前面就行了。
### 别忘了判无解
```cpp
if(ok<0){printf("-1\n"); return 0;}
```
code

```cpp
#include<bits/stdc++.h>
#define yuantc 1145141
using namespace std;
long long n,x,ok,cnt;//记得判无解 
int t=0,a=0,s[yuantc],yuan[yuantc];
int main()
{
	cin>>n>>x;
	ok=(n-2)*(n-1)-(n-1)*(n-2)/2-x;
	if(ok<0){ cout<<-1<<endl; return 0;}//输出无解信息 
	for(int j=1;j<=n-2;j++){ if(ok-(n-1-j)>=0) { yuan[j]=1; s[++a]=j; ok-=(n-1-j);} }
	for(int j=1;j<=a;j++){cout<<s[j]<<' ';}
	cout<<n<<' ';
	for(int j=1;j<=n-2;j++){ if(yuan[j]==false) { cout<<j<<' '; } }
	cout<<n-1<<endl;
}
```

---

## 作者：juruo_zhanshen (赞：0)

本蒟蒻对构造题一窍不通。或许是因为 rp，所以随机到了本题。

---------
经过简单的推理可得：
- 最左边和最右边的上面不能有水
- 高度为 $n$ 和 $n - 1$ 的上面不能有水。

考虑把高度为 $n$ 和 $n - 1$ 的柱子当作左右端点，此时中间的存水量可以最大化。带入求和公式，则 $X$ 必须满足:
$$
X \leqslant \frac{(n - 1) \cdot (n - 2)}{2}
$$
当然，我们不一定需要存满水，此时处理非常复杂，但我们可以把多出的部分按升序排序放在 $n-1$ 的前面，前面的部分不能储水。此过程可以循环实现。

```cpp
#include <bits/stdc++.h>
using namespace std;


int main ( int argc, char *argv[] )
{
    int n;
    ll x;
    scanf("%d%lld", &n, &x);
    if (x > 1ll * (n - 1) * (n - 2) / 2){ //x不符合要求
        puts("-1");
        return 0;
    }
    ll left = 1ll * (n - 1) * (n - 2) / 2 - x; //剩余的水
    bool vis[n + 5]{};
    for (int i = n - 2; i >= 1; i--)   //枚举v
        if (left >= i){
            left -= i;  //去掉多余部分
            vis[n - i - 1] = 1;  // 标记
        }
    for (int i = 1; i <= n; i++)
        if (vis[i])
            printf("%d ", i); //多余的柱子
    printf("%d ", n - 1); // 左端点
    vis[n - 1] = 1;
    for (int i = 1; i <= n; i++)
        if (!vis[i])
            printf("%d ", i); //需要储水的柱子
    puts(""); //换行好习惯
    return 0; //返回好习惯
}               /* ----------  end of function main  ---------- */

---

## 作者：Cells (赞：0)

## 思路

像这种有无解情况的题，可以先思考什么时候无解再做有解部分，因为往往无解的思考可以帮助你解题。

思考对于一个 $n$ 的排列，最多能够装多少水。首先可以最大化水平面，也就是将 $n$ 放在最左边，$n - 1$ 放在最右边，这样水平面的高度是 $n - 1$，然后我们可以按照从左到右的方式放入 $1, 2, \dots n - 2$，根据等差数列求和可以知道最多放 $\frac{(1 + (n - 2)) \times (n - 2)}{2} = \frac{(n - 1) \times (n - 2)}{2}$ 单位容积的水。所以当 $x > \frac{(n - 1) \times (n - 2)}{2}$ 的时候肯定无解。接下来我们考虑 $x$ 能否取到 $[1, \frac{(n - 1) \times (n - 2)}{2}]$ 中的每一个整数值，如果我们想把最大容积变小 $1$，那么可以考虑将 $n - 2$ 与 $n - 1$ 交换，这样刚好可以减去 $1$，就像这样 $n, 1, 2, \dots , n - 3, n - 1, n - 2$，你可以算一下，刚好少一。我们猜测任何一个数都可以通过刚刚那种交换操作减出来，因为 $1, 2, \dots, n - 2$ 可以拼出来任何一个 $[0, \frac{(n - 1) \times (n - 2)}{2} - 1]$ 中的任何一个数，也就可以满足在区间 $[1, \frac{(n - 1) \times (n - 2)}{2}]$ 中的 $x$。

## Code

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define int LL
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 1e6 + 10;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n, x, mxv;

vec<int> num, no;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> x;
	
	mxv = (n - 1) * (n - 2) / 2;
	if(x > mxv){
		cout << "-1";
		return 0;
	}
	
	pre(i, n - 2, 1){
		if(x >= i){//如果可以减去这个数 
			num.pb(n - i - 1);//高度和水的容积的转化 
			x -= i;
		}
		
		else no.pb(n - i - 1);
	}
	
	cout << n << " ";
	
	each2(h, num) cout << h << " ";
	cout << n - 1 << " ";
	reverse(all(no));//这个地方是为了保证不用的数从左到右递减，不产生答案 
	each2(h, no) cout << h << " ";
	
	return 0;
}
```

再見，再也不見，心碎了飄蕩在海邊，你抬頭就看見…………

---


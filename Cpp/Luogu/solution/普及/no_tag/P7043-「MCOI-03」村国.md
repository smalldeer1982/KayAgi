# 「MCOI-03」村国

## 题目背景

$\texttt{What did this player dream?}$

他梦见了什么？

$\texttt{This player dreamed of sunlight and trees.Of fire and water.}$

他梦见了阳光与树木。梦见了火与水。

$\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ 
$\texttt{and was hunted. It dreamed of shelter.}$

他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。

$\texttt{Hah, the original interface. A million years old, and it still works.But}$ 
$\texttt{ what true structure did this player create, in the reality behind the screen?}$

哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？

## 题目描述

C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。

刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。

现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。

如果有多个好感值最高的村庄，输出编号最小的。

## 说明/提示

#### 样例说明

对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。

对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le N\le 2\times10^6$，$1 \le M\le10^{18}$，$1 \le A_i\le2^{31}-1$，$1 \le T\le10$。

| 测试点编号 | $A_i\le$ | $\sum N \le$ | $M \le $ | 测试点分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $\rm 1$ | $10$ | $20$ | $10$ | $5$ |
| $\rm 2$ | $10^2$ | $2 \times 10^2$ | $10^2$ | $10$ |
| $\rm 3$ | $10^3$ | $2 \times 10^3$ | $10^3$ | $15$ |
| $\rm 4$ | $10^5$ | $2 \times 10^5$ | $10^5$ | $25$ |
| $\rm 5$ |  | $2 \times 10^6$ |  | $45$ |

#### 提示

**本题输入量较大，请使用较快的读入方式。**

## 样例 #1

### 输入

```
2
2 3
2 6
1 2
3 5
2 6 4
1 3
2 3```

### 输出

```
2
3```

# 题解

## 作者：_zy_ (赞：22)

## 题目大意：
	
   从这些点中找出最大的点，然后再在周围的点都加上$1$
。

$m$次操作后输出最大值点的编号。


------------


## 一些小小的性质：

很显然，如果直接按照题目中所说的那么很明显的会$T$飞（~~某位学长亲测~~）。

1. 很显然，手玩几个东西就会发现，其实就是两个点（哪两个点，先留个悬念）在那里跳啊跳啊，~~跳啊跳啊，我的骄傲放纵~~。


2. 那么具体怎么跳呢？

我们先找到一开始最优秀的点呀 。
- **最大的点中编号最小的点**。

emmm大概就是这样操作的。。。

```cpp
for(int i=1;i<=n;i++) {
	a[i]=re();
	if(a[i]>maxx) {
		maxx=a[i];
		now=i;
	}
}
```

然后就建边先找到这个最大点的最大值的位置。

~~好了！悬念解开了!~~

没错就只需要看最大值的点和最大点的最大值点就好了呀。

因为+1+1+1只更新了这些点周围的点的好感值，所以最大点的最大值点是最有可能更新称为最大值。

关于这个点位置的处理
```cpp
int maxn=0; int k=0;
for(int i=fir[now];i;i=nex[i])
{
	int p=poi[i];
	if(a[p]>maxn||(a[p]==maxn&&p<k)) {
		maxn=a[p];
		k=p;
	}
}
```


----
#### 下面就是重头戏了嗷！！

1. 如果直接没有进循环，特判一手。

那么就是一个点了呀，直接输出这个点他不香吗，他香的一批!

#### 于是剩下的就是判断这两个最大点的最大点的最大值的差值就好了

2. 如果差值比$m$天大，就说明天数不够去让那个东西更新成为最大值。

——直接输出最大点就可以了.

3. 如果刚好相等呢？？？

刚好更新出来最大值，就要看编号了来比较，输出编号更小的那个就好了。

4. 如果更新到最大值之后，继续跳的时候。

如果奇数的话那么就跳到了这两个点编号更大的点。

偶数的时候就是另一个点了呀。

---

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define int long long 
#define N 5000010
using namespace std;
int re() {
	int p=0; char i=getchar();
	while(i<'0'||i>'9')	i=getchar();
	while(i>='0'&&i<='9')	p=p*10+i-'0',i=getchar();
	return p;
}
int t,n,m,sum,now;
int a[N];
int fir[N],nex[N],poi[N];
void ins(int x,int y) {       //某些大佬说不需要建边,我太菜了
	nex[++sum]=fir[x];
	poi[sum]=y;
	fir[x]=sum;
}
void Clear() {					//t次询问清0,建图只需要清空fir,sum记得清0
	memset(fir,0,sizeof(fir));
	memset(a,0,sizeof(a));
	sum=0; now=0; 
}
signed main()
{
	t=re();
	while(t--)
	{
		Clear();
		n=re();m=re();
		int maxx=0;
		for(int i=1;i<=n;i++) {
			a[i]=re();
			if(a[i]>maxx) {			//不能等于,因为这样才是编号最小的
				maxx=a[i];
				now=i;
			}
		}
		for(int i=1;i<n;i++)
		{
			int a,b;
			a=re();b=re();
			ins(a,b); ins(b,a);
		}
		int maxn=0; int k=0;
		for(int i=fir[now];i;i=nex[i])
		{
			int p=poi[i];
			if(a[p]>maxn||(a[p]==maxn&&p<k)) {	同上
				maxn=a[p];
				k=p;
			}
		}
        if(k==0)    {
            printf("%lld\n",now);
            continue;
        }
		int dat=maxx-maxn;
		if(dat>m) {
			printf("%lld\n",now);
			continue;
		}
		if(dat==m) {
			printf("%lld\n",min(now,k));
			continue;
		}
		if((m-dat)&1) {					//x&1判断是否是奇数
			printf("%lld\n",max(now,k));
			continue;
		}
		else {
			printf("%lld\n",min(now,k));
			continue;
		}
	}
    return 0;
}

```

就酱，如果有什么不妥的地方，十分期望大家私信我

Orz






---

## 作者：Eason_AC (赞：17)

## Content
有 $T$ 组询问，每组询问给定一个有 $n$ 个节点的数，编号为 $1\sim n$，每个节点一开始都有权值 $a_i$。现有 $m$ 次操作，每次操作选择树上所有节点中权值最大的一个点（如果有多个选择编号最小的），然后将所有和这个点在树上直接相连的点的权值加 $1$。求 $m$ 次操作以后权值最大的点的编号（如果有多个输出编号最小的）。

**数据范围：$1\leqslant n\leqslant 2\times 10^6,1\leqslant m\leqslant 10^{18},1\leqslant a_i\leqslant 2^{31}-1,1\leqslant T\leqslant 10$。**
## Solution
比较具有启发性的题目。

我们先把 $30$ 分的暴力（本人亲测）写完以后，看能不能找到一些规律。

我们接下来以这个图为例来找一下规律，下图是一个拥有 $12$ 个节点的树，其中每个节点旁边红色的数字代表着它的权值。（图画得可能不是太好，请见谅）

![](https://cdn.luogu.com.cn/upload/image_hosting/y7wp02vy.png)

你也可以直接复制下面的对应数据来 $\texttt{debug}$ 一下：

```
1
12 x //这里的 x 可以变成任何数
7 2 5 3 3 10 1 6 5 5 6 8
1 2
1 3
1 4
3 5
3 6
6 8
6 9
4 7
4 10
10 11
11 12
```

我们来模拟一下每次操作：

第一次，选择权值最大的节点 $6$，然后让与之直接相连的每个节点的权值增加 $1$，这样，与之直接相连的节点 $3,8,9$ 的权值分别变成了 $6,7,6$。

第二次，第三次，第四次操作都是选择权值最大的节点 $6$，就不再赘述了。第四次操作完成以后，节点 $3,8,9$ 的权值分别变成了 $9,10,9$。

第五次，选择权值最大的节点，这是我们发现这样的节点有 $2$ 个，分别是 $6$ 和 $8$，然而由于 $6<8$，所以我们还是选择节点 $6$，然后让与之直接相连的每个节点的权值增加 $1$，这样，与之直接相连的节点 $3,8,9$ 的权值分别变成了 $10,11,10$。

第六次，选择权值最大的节点 $8$，然后让与之直接相连的每个节点的权值增加 $1$，与之相连的节点 $6$ 的权值变成了 $11$。

第七次，选择权值最大的节点，这是我们发现这样的节点有 $2$ 个，分别是 $6$ 和 $8$，然而由于 $6<8$，所以我们还是选择节点 $6$，然后让与之直接相连的每个节点的权值增加 $1$，这样，与之直接相连的节点 $3,8,9$ 的权值分别变成了 $11,12,11$。

第八次，选择权值最大的节点 $8$，然后让与之直接相连的每个节点的权值增加 $1$，与之相连的节点 $6$ 的权值变成了 $12$。

……

继续这样推下去的话你就能够发现，我们后面所选择的节点一定会在 $6,8$ 之间反复循环，而这两个点又分别是一开始权值最大的点中编号最小的点和与之直接相连的节点中权值最大的点中编号最小的点。所以，我们可以得到以下思路：

- 记录下来所有与一开始权值最大的点中编号最小的点直接相连的所有点并取当中权值最大的点中编号最小的点。设我们选出来的点的编号分别是 $k,k'$。
- 如果 $a_k-a_{k'}>m$，那么我们的节点 $k$ 肯定是最后权值最大的点。
- 否则，由于最后的答案肯定在两个点之间反复横跳，我们只需要判断一下 $m-(a_k-a_{k'})$ 的奇偶性即可。如果是奇数，那么答案肯定就是这两个点当中编号更大的，否则肯定就是这两个点当中编号更小的。这里请读者自己思考。

而且我们惊奇地发现，这个做法成功的越过了全网大部分人跳进去的 $n=1$ 的坑，所以这个做法从某种意义上来讲是很优越的。
## Code
```cpp
int t, n, a[2000007], num[2000007];
long long m;

int main() {
	//This program is written by Eason_AC
	scanf("%d", &t);
	while(t--) {
		memset(num, 0, sizeof(num));
		int ans = 0;
		scanf("%d%lld", &n, &m);
		for(int i = 1; i <= n; ++i) {
			scanf("%d", &a[i]);
			if((a[i] > a[ans]) || (a[i] == a[ans] && ans > i)) ans = i;
		}
		for(int i = 1; i < n; ++i) {
			int x, y;
			scanf("%d%d", &x, &y);
			if(x == ans) num[++num[0]] = y;
			else if(y == ans) num[++num[0]] = x;
		}
		if(!num[0]) {printf("%d\n", ans); continue;}
		int kk = 1;
		for(int i = 1; i <= num[0]; ++i)
			if(a[num[i]] > a[num[kk]]) kk = i;
		if(a[ans] - a[num[kk]] > m) printf("%d\n", ans);
		else if((m - (a[ans] - a[num[kk]])) % 2) printf("%d\n", max(num[kk], ans));
		else printf("%d\n", min(num[kk], ans));
	}
	return 0;
}
```

---

## 作者：Thomas_Cat (赞：8)

# $\texttt{30pts 做法}$ 

思路：

- 首先，因为可以多次循环 $t$ 次输入，因此使用 `for` 循环输入，在循环输入的时候注意每一次的 `w` 需要重置 $0$ ，使用 `memset` 语句

```cpp
//memset语句
#include<cstring>
memset(w,sizeof(w),0);
```

- 再通过 $dfs$ 来循环判断，每一次的 `w + 1`

```cpp
int find(){
    int Max=-9999999,u=0;
    for(int i=1;i<=n;i++)
        if(w[i]>Max){
            Max=w[i];
            u=i;
        }
    return u;
}
void work(){
    for(int i=1;i<=m;i++){
        int tmp=find();
        for(int i=1;i<=n;i++)
            if(e[tmp][i]==1) w[i]++;
    }
    return;
}
```


# $\texttt{100pts 做法}$

我们先用一组简单的样例来解释一下：

```
1
3 5
2 6 4
1 3
2 3
```

于是我们可以画出图：

![](https://s1.ax1x.com/2020/11/04/BgNjPI.png)

我们定义 $max = \max A_i, x=i.$

则：上图中

$max=6,x=2.$

$A_3=4+1=5.$

得出图：

![](https://s1.ax1x.com/2020/11/04/BgUUsO.png)

于是：因为还是 $max=6,x=2.$

$\therefore A_3=5+1=6.$

得出图：

![](https://s1.ax1x.com/2020/11/04/BgULOU.png)

$\because A_2 = A_3,2<3.$

$\therefore A_3=6+1=7.$

得出图：

![](https://s1.ax1x.com/2020/11/04/BgaVTH.png)

$\because A_3>A_2.$

$\therefore max=7,x=3.$

$\quad A_2=6+1=7.$

得出图：

![](https://s1.ax1x.com/2020/11/04/BgaW1x.png)

$\because A_3=A_2,2<3.$

$\therefore max=7,x=2.$

过程模拟完毕。

通过之前 $30$ 分的做法的枚举也可以发现，中间的模拟过程只存在于 $max$ 和与 $max$ 相邻的第二大 $max_2$ 中。 

---

分类讨论：

- 如果 $(m-a_{max}+a_{max_2}) \%2=0,a_{max}=a_{max_2}$ 

- 如果 $(m-a_{max}+a_{max_2}) \%2=1,a_{max}\ne a_{max_2}$，谁大谁小得判断。

- **如果 $m=1$ 则 答案 $=1$**
 
因此使用快读输入即可。

代码略。

---

## 作者：hellhell (赞：5)


## 分析
 首先观察数据范围发现 $m\leq 10^{18}$ 直接模拟肯定TLE

观察题目发现最后要求的是村庄的编号，而不是好感度，想到正解可能与 $m$ 的关系不大


顺着这个思路往下想，发现了一个规律

设初始好感度最大且村庄编号最小的村庄为 $id_1$

$id_1$子节点中初始好感度最大且村庄编号最小的村庄为 $id_2$

 则答案一定为 $id_1$ 或$id_2$

------------

## 证明

因为 $id_1$ 为所有节点中初始好感度最大的节点，


所以一开始一定在 $id_1$ 这个村庄，

而此时 $id_1$ 只能修改它的子节点的点权，

所以 $id_2$ 一定是第一个比 $id_1$ 的点权大的点，此时移动到了 $id_2$。

开始修改 $id_2$ 的所有子节点，

$id_1$ 一定是最先比 $id_2$ 大并且编号最小的，

因为 $id_1$ 是初始好感度最大且编号最小的村庄，

于是又回到了 $id_1$。

`小S` 开始在 $id_1$ 和 $id_2$ 中间来回蹦迪，

最后 `小S` 只会在 $id_1$ 和 $id_2$ 这两个村庄中的一个。


## 继续分析


知道这个规律后，这题几乎就写完了

找到 $id_1$ 和 $id_2$ 用 $dis$ 表示 $val[id_1]-val[ id_2 ]$ 的值

如果 $m<dis$，`小S` 无法移动，输出 $id_1$ 

否则就将 `m-=dis` (先将 $id_1$ 和 $id_2$ 的点权修改到相同)

然后看 $id_1$ 和 $id_2$ 的大小以及m能否被2整除

来判断 `小S` 最后会在哪个村庄

## 注意

- **要特判n==1，不然会WA得很惨**

- **在找 $id_1$ 和 $id_2$ 的时候注意如果有好感度相同的村庄 `小S` 会去到编号最小的村庄**


## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

inline int read(){//快读
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int t;
int n,m;
int val[2000005];

struct node{//链式前向星存图
    int to;
    int next;
}edge[2000005*2];
int head[2000005*2];
int cnt;

void add(int u,int v){//链式前向星建图
    edge[++cnt].to=v;
    edge[cnt].next=head[u];
    head[u]=cnt;
    return ;
}

int Max=-1;//记录id1的好感度
int id;//题解中的id1
int mmax=-1;//记录id2的好感度
int iid;//题解中的id2

signed main(){
    cin>>t;
    while(t--){
        Max=-1;
        mmax=-1;
        id=0;
        iid=0;
        cnt=0;
        memset(val,0,sizeof(val));
        memset(head,0,sizeof(head));
        //上面一堆都是在初始化
        n=read();
        m=read();
        for(int i=1;i<=n;i++){
            val[i]=read();
            if(val[i]>Max){//找id1
                Max=val[i];
                id=i;
            }
        }
        for(int i=1;i<n;i++){
            int x,y;
            x=read();
            y=read();
            add(x,y);
            add(y,x);
        }
        if(n==1){//特判
            cout<<1<<endl;
            continue;
        }
        for(int i=head[id];i;i=edge[i].next){
            int v=edge[i].to;
            if(val[v]>mmax || (val[v]==mmax && v<iid)){//找id2
                mmax=val[v];
                iid=v;
            }
        }
        int dis=Max-mmax;
        if(dis>m){//特判
            cout<<id<<endl;
            continue;
        }
        else{//判断小S最后会停在id1还是id2
            int diss=m-dis;
            if(diss%2==0){
                if(id<iid){
                    cout<<id<<endl;
                    continue;
                }
                if(iid<id){
                    cout<<iid<<endl;
                    continue;
                }
            }
            if(diss%2!=0){
                if(iid<id){
                    cout<<id<<endl;
                    continue;
                }
                else{
                    cout<<iid<<endl;
                    continue;
                }
            }
        }
    }
    return 0;
}

```


---

## 作者：LSG_waterf (赞：3)

题意不重复了．

虽然全是文字题解，但还是很好理解的

当我们待在好感度最高的城市 $u$ 时，与该城市 $u$ 直接相连的所有城市的好感度都会加一，那么什么时候我们不会待在这个城市 $u$ 了呢？只可以是别的城市的好感度更大，由于我们一开始就是找的最大的好感度的城市 $u$ ，所以我们只会增加与这座城市直接相连的城市，所以只有可能是与城市 $u$ 相连的城市的好感度超过了它，此时我们才会跳到与 $u$ 相邻的城市中去，很明显我们先跳到的是与 $u$ 
相邻的最大的城市，跳到那里后， $u$ 的好感值又会增加，所以我们又会跳到城市 $u$ ，接着又跳到与 $u$ 相邻的最大好感值的城市去，以此类推．．．

所以，我们只要判断 $m-(w[max[i]]-w[next[i]])$ 的奇偶性就可以了．

注意还要判断一下节点大小的编号．
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=4e6+7;
void read(int &x)
{
	char ch=getchar();x=0;
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-48,ch=getchar();
}
int n,m,T,cnt,h[M],ku,kv;
struct edge{int v,nxt;}e[M];
void add(int u,int v){e[++cnt].v=v;e[cnt].nxt=h[u];h[u]=cnt;}
struct nod{int id,w;}a[M];
void init()//由于是多测，记得清空数组．
{
	memset(a,0,sizeof(a));
	memset(e,0,sizeof(e));
}
signed main()
{
	read(T);
	while(T--)
	{
		read(n);read(m);
		for(int i=1;i<=n;i++) read(a[i].w),a[i].id=i;//注意记录第i个节点的编号．
		for(int i=1;i<n;i++) 
		{
			read(ku);read(kv);
			add(ku,kv);add(kv,ku);
		}
		int s1=0,s2=0;//s1,s2记录的分别是整个图中最大的节点 u 以及他的编号．
		for(int i=1;i<=n;i++)
		{
			if(s1<a[i].w) s1=a[i].w,s2=a[i].id;
			else if(s1==a[i].w&&s2>a[i].id) s2=a[i].id;
		}
		int s3=0,s4=0;//s3,s4记录的分别是整个图与ｕ相邻的节点中最大的节点以及他的编号．
		for(int i=h[s2];i;i=e[i].nxt)
		{
			int v=e[i].v;if(v==s2) continue;
			if(s3<a[v].w) {s3=a[v].w;s4=a[v].id;}
			else if(s3==a[v].w&&s4>a[v].id) s4=a[v].id;
		}
		int tt=m-s1+s3;
		if(n==1) cout<<"1"<<endl;//这三个地方真的特别毒瘤
		else if(tt<0) cout<<s2<<endl;//同上
		else if(tt==0) cout<<min(s2,s4)<<endl;／／同上
		else 
		{
			if(s2>s4)//判断奇偶性即可.
			{
				if(tt%2==0) {printf("%lld\n",s4);}
				else {printf("%lld\n",s2);}
			}
			else if(s2<s4)
			{
				if(tt%2==0) {printf("%lld\n",s2);}
				else {printf("%lld\n",s4);}
			}
		}
		init();//注意清空数组，小心爆零．
	}
	return 0;
}
```


---

## 作者：Phoenix_chaser (赞：3)

# 核心在于找规律
（适合像我一样的蒟蒻食用）

在月赛时做到了这个题目,然后只打了三十分.....
后来仔细想一想出了思路

### 思路：

以题目给的第二组数据为例

3 5

2 6 4

1 3

2 3

首先，好感度最大的为2，所以住在2

与他相邻的1和3的好感度加1;

当前好感度为

3 6 5

第二次 好感度最高依旧为2

走后为

3 6 6

#### 现在有两个相等的好感度的村庄，选那个编号小的村庄
#### 此时好感度最高为2 

则为

3 6 7
#### 此时好感度最高为 3

如果接下来再走一步

3 7 7
#### 此时好感度最高为2 

找编号最小，走后为

3 7 8

#### 此时好感度最高为3

如果再去走呢

3 8 8     **好感度最高为2**

3 8 9   **好感度最高为3**
 
3 9 9 **好感度最高为2**
 
3 9 10 **好感度最高为3**

3 10 10 **好感度最高为2**

### 于是我们发现答案一直在 2与3之间~~反复横跳~~

#### 这就是规律

简单来说

### 只要有两个好感度相等或差等于一的城市且相连

答案会在两个数之间不停的循环

如何找出这两个城市呢？

### 首先我们要找出好感度最大的城市

从它开始找与它相连的点

#### 那么与它相连的点肯定比它小

每次旅行都会增加它周围的点的好感度

#### 会加到它周围的有一个点与它相等

而我们只需要找到那个与他好感度相差最小的点

#### 一定是它先变成和这个好感度最大相等的城市

如果加不到

#### 那就直接输出它，因为没有其它的能跟它相等

如果还是很抽象的话

我们可以把它抽象成为一个凹凸不平的容器

每次往最高位置那里加水
![](https://cdn.luogu.com.cn/upload/image_hosting/cy0zc7a4.png?x-oss-process=image/resize,m_lfit,h_400,w_300)

水会流向周围与它相邻的位置

如果有水位相等，那么往编号最小的那个位置加水，也会使旁边位置的水变高

### 于是每次是最大的和次大的交替变为好感最大的答案

另外还有一些需要注意的：

### 特判n==1 ！！！
### 不开long long 见祖宗！！！

上代码

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cstdio>
using namespace std;
long long t,n,m,head[2000010],a1,b1,cnt=0,maxn=-1,ji,maxn1=-1,ji2;
struct node1{
	int to,next;
}edge[4000010];
long long a[2000010];
inline void add(int h,int g){
	edge[++cnt].next=head[h];
	edge[cnt].to=g;
	head[h]=cnt;
}
int main(){
	scanf("%lld",&t);
	while(t--){
		cnt=0;
		memset(edge,0,sizeof(edge));
		memset(head,0,sizeof(head));
		memset(a,0,sizeof(a));
		maxn=-1;
		maxn1=-1;
		ji=-1;
		ji2=-1;
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=n;i++)
		{scanf("%lld",&a[i]);
		}
		for(int i=1;i<n;i++){
		scanf("%lld%lld",&a1,&b1);
		add(a1,b1);
		add(b1,a1);}
		for(int i=1;i<=n;i++)
		{
			if(maxn<a[i]) maxn=a[i],ji=i;
			if(maxn==a[i]) 
			{
				if(ji>i)
				ji=i;
			}
		}
		for(int i=head[ji];i;i=edge[i].next)
		{
			if(maxn1<a[edge[i].to]) maxn1=a[edge[i].to],ji2=edge[i].to;
			if(maxn1==a[edge[i].to]) 
			{	if(ji2>edge[i].to)
				ji2=edge[i].to; 
			} 
		}
		int cha=maxn-maxn1;
		if(n==1)
		cout<<"1"<<endl;
		else if((m-cha)<0) 
		printf("%lld\n",ji);
		else if((m-cha)==0) 
		{
		if(ji>ji2)
		{ printf("%lld\n",ji2);
		}
		else printf("%lld\n",ji);
		}
		else {
			if(ji>ji2){
				if((m-cha)%2==0) 
				printf("%lld\n",ji2);
				else 
				printf("%lld\n",ji);
				}
			else if(ji<ji2){
				if((m-cha)%2==0) 
				printf("%lld\n",ji);
				else 
				printf("%lld\n",ji2);
			}
		}
	
	}
	return 0;
}
```

## 谢谢观看
### THE END





---

## 作者：SmallTownKid (赞：2)

暴力维护可以 $30pts$ 。正解是只考虑一开始树中权值最大的点和它所连着的所有点里最大的点。只会在这两个点之间来回行走。很好证明。由于天数的规模很大，不能一次次模拟，考虑数学方法。先花一些天使得两个点差值为 $0$ ，当两个点权值一样之后，他们就会来回走，所以只需要讨论此时剩余天数的奇偶性就可以了。

注意特判 $n=1$ 的情况！！！

```
//一定是在最大和最大连着的交替行走。判断顺序就行。 
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int INF=0x3f3f3f3f;
int T,n,m,idx,now1,now2,maxn,maxn2;
int a[2000010],head[2000010];
struct node{
	int nxt,to;
}edge[4000010];
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
signed main()
{
	cin>>T;
	while(T--)
	{
		maxn=-INF;
		for(int i=0;i<=n;i++)
		{
			head[i]=0;
		}
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=n;i++)
		{
			scanf("%lld",&a[i]);
			if(a[i]>maxn)
			{
				maxn=a[i];
				now1=i;
			}
		}
		for(int i=1;i<=n-1;i++)
		{
			int u,v;
			scanf("%lld%lld",&u,&v);
			add(u,v);
			add(v,u);
		}
		maxn2=-INF;
		if(n==1)
		{
		    cout<<now1<<endl;
		    continue;
		}
		for(int i=head[now1];i;i=edge[i].nxt)//找出相连的最大的，标号小的在前 
		{
			int v=edge[i].to;
			if(a[v]>maxn2)
			{
				maxn2=a[v];
				now2=v;
			}
		}
		//先判断是now1编号大还是now2编号大
		if(now1>now2)//now1为当前在的点，标号大于now2 
		{
			if(a[now1]-a[now2]>m)
			{
				printf("%lld\n",now1);
			}
			else
			{
				if((m-(a[now1]-a[now2]))%2==1)
				{
					printf("%lld\n",now1);
				}
				else printf("%lld\n",now2);
			}
		}
		if(now1<now2)
		{
			if(a[now1]-a[now2]>m)
			{
				printf("%lld\n",now1);
			}
			else
			{
				if((m-(a[now1]-a[now2]))%2==0)
			    {
				    printf("%lld\n",now1);
			    }
			    else printf("%lld\n",now2);
			}
		}
	}
	return 0;
}
```

---

## 作者：梨衣 (赞：2)

## 又是一道大数据找规律
经过 $30$ pts 的模拟做法后，发现了本题规律。

题目规定最初到达的村庄一定为好感度最高村庄 $a$ ，**注意好感度相同时优先选择序号较小的**。从起始村庄考虑，只有与它直接连通的村庄好感度才会增加。假设某一天，另一村庄 $b$ 满足了题目的优先到达要求。

那么 $b$ 一定与 $a$ 直接连通，且**由于无向边的性质，当 $b$ 成为访问地后， $a$ 一定也与它直接相连**，即好感度开始增加。显然，无论 $a$ 与 $b$ 哪个编号小，都会满足每访问一个村庄后，第二天的访问一定为另一村庄。

到此为止，可以明确看出，最终输出的村庄一定在两村庄间，根据 $M$ 的不同进行判断。
### 当 $M < a$ 与 $b$ 好感度之差时，无法到达 $b$ ,答案为 $a$ 
### 当 $M >= a$ 与 $b$ 好感度之差时，讨论 $a$ 与 $b$ 编号的大小关系
用 $M$ 减去好感度之差，目的是将两村庄好感度提升为相同水平，方便进行讨论。若 $M$ 为偶数，则好感度依旧会保持同步增长，答案为编号小的村庄。反之，答案为编号大的村庄。
## 代码如下
```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int head[2000100],tot;
struct edge{
	int to,nxt;
}e[4000100];
struct node{
	int num,w;
}q[2000100];
void add(int x,int y){
	e[++tot].to=y;
	e[tot].nxt=head[x];
	head[x]=tot;
}
int a[2000100],t,n;
long long m;
bool cmp(node a,node b){
	if(a.w!=b.w)return a.w>b.w;
	else if(a.w==b.w)return a.num<b.num;
}
int main(){
	t=read();
	while(t--){
		memset(e,0,sizeof(e));
		memset(head,0,sizeof(head));
		tot=0;
		n=read();
		scanf("%lld",&m);
		for(int i=1;i<=n;i++){
			q[i].w=read();
			a[i]=q[i].w;
			q[i].num=i;
		}				
		for(int i=1;i<n;i++){
			int x=read(),y=read();
			add(x,y);
			add(y,x);
		}
		sort(q+1,q+1+n,cmp);
		int cnt=q[1].num,maxx=-0x7f,cntt=-1;
		for(int i=head[cnt];i;i=e[i].nxt){
			int tt=e[i].to;
			if(a[tt]>=maxx){
				if(maxx==a[tt])
					cntt=min(cntt,tt);
			else
				maxx=a[tt];
				cntt=tt;
			}
		}
		if(cntt==-1)printf("%d\n",cnt);
		else {
			m-=a[cnt]-a[cntt];
			if(cnt<cntt)m-=1;
			if(m%2==1||m<0)printf("%d\n",cnt);
			else printf("%d\n",cntt);
		}
	}
	return 0;
}
```
记得多组数据随时清零！~~本蒟蒻调试一小时，只因为似乎存在单个村庄数据，没有清零记录的村庄。~~
## 谢谢观看

---

## 作者：Fall_SH (赞：2)



# [题面](https://www.luogu.com.cn/problem/P7043?contestId=36089)

## **题意：**
#### **有T个数据**
有一颗树（保证所有的的节点都是相连的），有n个节点，每个节点都有相应的权值与序号，现在你要进行M次操作，操作是：
### 找到权值最大的节点（如果有权值相同且又是最大的节点，则选择序号较小的节点），与节点直接相连的节点权值+1（本身不增加权值）

最后输出权值最大的节点（有相同的则输出序号较小的节点）。



数据范围:
对于 100% 的数据，1≤N≤2×10^6,
1≤M≤10^18,
1≤A i≤2^31-1,
1≤T≤10

部分分就不写了。

#### ~~反正很大就是了，看到这个M小于等于10的18次方，你怕了吗~~


------------

# 题解（主要是思路）：

首先看题目，有人看完题面可能会不知道为什么是一棵树~~只有你会~~，题目给出的是N个点，由****N-1条****双向路径相连，
```
C 国一共有 N 个村庄，N-1 条道路。这些道路都可以双向通行。
保证小 S 可以从一座村庄到其他任何一座村庄。
这 N 个村庄编号为 1 到 N。
```
### 保证小 S 可以从一座村庄到其他任何一座村庄
众所周知，想要组成环，至少需要与节点数相同的路径，而题意又保证各个节点一定相连，就必须要N条路径，但题目给出的只有n-1条路径
，则是一棵树。

~~好啰嗦~~

看完题意看数据范围，发现M的范围巨大，连O（M）的算法都过不了，**不可做**。

于是我陷入了思考，先写一下数据推推规律：

```cpp
三个点
2 6 3
都相连
2->6->3
M次操作
//1：
num[2]:6最大
3 6 4
//2：
num[2]:6最大
4 6 5
//3：
num[2]:6最大
5 6 6
出现了！相等的点！但是num[2]序号小，答案依旧是选num[2];
//4:
num[2]:6最大
6 6 7
num[3]大于num[2]了；
//5:
num[3]:7最大
6 7 7
又相等了,num[2]序号小，选num[2]。
//6:
num[2]:7最大
7 7 8
num[3]最大了
```
推到这就差不多了，可以得出以下规律：

~~（此处的权值指的是初始权值）~~

x1为权值最大的节点，y1为与它相连的权值相对最大的节点
- 只需要记录下x1与y1，而其他的节点，拜托，他们超逊的！可以从数据中看出，与6相连的num[1]由于小于num[2]，在答案的选择中没有任何竞争力，不与权值最大的节点直接相连的节点就更不要说了。（觉得不对的同学可以自己写几组数据试试）

- 在M小于num[2]与num[3]的差时,答案恒为num[2],(num[2]:哼，没点时间还想超过我？)可以转化为-----当M小于x1-y1，选x1;

- 然后就是M>=他们的差时：看数据，第3次操作到第6次操作答案是有循环的，很容易得到是跟M的奇偶性有关的（等于的话就是直接取序号最小就行了），先将M减去x1-y1，奇数取y1,偶数取x1.

这一切都是建立在这个图是一颗树的前提下。

代码实现就行

然后就没了

# 吗？
## 还有特判！
在代码实现中，当n=1时的情况要特殊考虑

~~我就是被这个点坑杀了4个点~~

~~85分没了~~

# 结束
不点个赞再走？

 _有什么意见可以发在评论区哦_ 

---

## 作者：fdszlzl (赞：2)

[P7043 「MCOI-03」村国](https://www.luogu.com.cn/problem/P7043)

由题可知，先站在最大值$A$ 这个点上。然后会向 $A$ 周边的最大值 $B$ 移动，当停留在 $B$ 时，下一个移动的点是一定是 $A$。（可以画图感觉下）

所以本题有用的点只有两个：

1. 最大值的点 $A$
2. 最大值周边的最大值点 $B$

然后开始计算：

1. 如果 $A>B$ ，则会 在$a[A]-a[B]$ 后移动至 $B$
2. 如果 $A<B$ ，则会 在$a[A]-a[B]+1$ 后移动至 $B$

接着会交替走$A、B$，余下的$m$直接$\%2$即可得到答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=2e6+10;

ll a[N];
int b[N],cnt;

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,maxU,secU=1e9;
		ll m,maxA=0,secA=0;
		scanf("%d%lld",&n,&m);
		cnt=0;
		for(int i=1;i<=n;i++) 
		{
			scanf("%lld",&a[i]);
			if(a[i]>maxA)
			{
				maxA=a[i];
				maxU=i;
			}
		}
		for(int i=1;i<n;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			if(u==maxU)	b[++cnt]=v;
			else if(v==maxU) b[++cnt]=u;
		}
		if(n==1)
		{
			cout<<1<<'\n';
			continue;
		}
		for(int i=1;i<=cnt;i++)
		{
			if(a[b[i]]>secA||a[b[i]]==secA&&b[i]<secU)
			{
				secA=a[b[i]];
				secU=b[i];
			}
		}
		if(secU<maxU) m-=maxA-secA;
		else m-=maxA-secA+1;
		if(m<0||m%2) cout<<maxU<<'\n';
		else cout<<secU<<'\n';
	}
	return 0;
}
```




---

## 作者：Lonely_NewYear (赞：1)

# 洛谷 P7043 题解

刚才那一篇数据给错了，希望管理员能修改一下。

## 题目描述

在一棵树上，每次选权值最高的点，把与这个点相连的点的权值都加 $1$，求 $m$ 次操作后权值最高的点。

## 题目分析

先随便弄一个数据手玩一下。

```
5 6
7 2 3 5 6
1 2
1 3
1 4
4 5
```

```
  7
 /|\
2 3 5-6
```

此时权值最大是$7$，于是把与 $7$ 相连的点权值加 $1$。

```
  7
 /|\
3 4 6-6
```

继续

```
  7
 /|\
4 5 7-6
```

注意此时上面的 $7$ 编号更小一些。

```
  7
 /|\
5 6 8-6
```
```
  8
 /|\
5 6 8-7
```
```
  8
 /|\
6 7 9-7
```
```
  9
 /|\
6 7 9-8
```
……

不难发现，最后会一直在这两个点之间交替。

这两个点一个是最大值，一个是与这个最大值相连的次大值（注意是相连的，所以不是 $6$）。

猜想一出，写写代码，$AC$。

## 证明

首先会选出最大的点 $A$，之后最大的点的宝座不会更改直到这个点周边有一个点 $B$ 和它一样了，我们不妨设 $A$ 编号更小。

接着 $A$ 会再次进行一次操作，使得 $B$ 比 $A$ 大 $1$。很容易知道 $B$ 此时是最大的点了，因为 $A$ 原本是最大的。那么此时 $B$ 有会进行一次操作，导致 $A$ 的权值与 $B$ 相等。但 $A$ 的编号更小，所以下一次操作将由 $A$ 完成，$B$ 再一次比 $A$ 大 $1$……

所以可知最后一定是 $A,B$ 两点交替。

只求一遍最大值，剩下的可以用模 $2$ 的余数搞定（因为两个点来回交替），时间复杂度 $O(n)$。

## 代码

注意编号。

```cpp
#include<cstdio>
#define int long long
using namespace std;
long long a[2000001];//点权
long long read()
{
	long long x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}
signed main()
{
	int t;
	t=read();
	while(t--)
	{
		long long max=0,id,n=read();//max,id存最大点
		long long m=read();
		for(int i=1;i<=n;i++)
		{
			a[i]=read();
			if(a[i]>max)
			{
				max=a[i];
				id=i;
			}
		}
		long long mmax=0,iid=1e9;//这两个存与最大点相邻的最大点
		for(int i=1;i<n;i++)
		{
			long long u=read(),v=read();
			if(u==id)
			{
				if(a[v]>mmax)
				{
					mmax=a[v];
					iid=v;
				}
				if(a[v]==mmax&&v<iid)
				{
					iid=v;
				}
			}
			if(v==id)
			{
				if(a[u]>mmax)
				{
					mmax=a[u];
					iid=u;
				}
				if(a[u]==mmax&&u<iid)
				{
					iid=u;
				}
			}
		}
		if(n==1)//注意！！！
		{
			printf("1\n");
			continue;
		}
		if(m<max-mmax)//第二个点来不及被加成第一个点
		{
			printf("%lld\n",id);
		}
		else//反之
		{
			m-=max-mmax;
			if(id<iid)//上面的情况
			{
				if(m%2==0)//注意顺序
				{
					printf("%lld\n",id);
				}
				else
				{
					printf("%lld\n",iid);
				}
			}
			else//其实就是反过来
			{
				if(m%2==0)
				{
					printf("%lld\n",iid);
				}
				else
				{
					printf("%lld\n",id);
				}
			}
		}
	}
	return 0;
}
```

谢谢观看！

---

## 作者：月离 (赞：1)

[P7043传送门](https://www.luogu.com.cn/problem/P7043)

注意这一段：

C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 1 到 $N$。

也就是说该图为一个无环连通图

### 暴力

先想暴力算法：枚举每次旅行到的村庄，其相邻村庄点权+1，m次修改点权后输出最大值的序号

但是观察数据范围，暴力$ O(N2)$明显会TLE，能拿55分，但是可以给我们一些正解的思路

~~暴力代码因玄学错误始终调不对，等调出来再贴~~

### 正解

在暴力模拟过程中我们不难看出小$S$一直在起点$s$和起点的相邻最大点权点$next$之间反复旅行，从始至终只旅行到这两个村庄

如下样例：

```cpp
1
4 5
5 6 7 8
1 2
2 3
1 4
```

![](https://cdn.luogu.com.cn/upload/image_hosting/wqjintkj.png)

在第$a[s]-a[next]$天时点权体现为


![](https://cdn.luogu.com.cn/upload/image_hosting/18ono033.png)

也就是说我们用了$m$天中的$a[s]-a[next]$天使$a[s]=a[next]$

（若$m<a[s]-a[next]$则直接输出$s$）

（若$m=a[s]-a[next]$则输出$min(s,next)$）

还剩下$m-a[s]+a[next]$天旅行，剩下几天都走完如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/kht6g89w.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/db9i1oga.png)

（上面二图中2号点点权应为7，但因为其不可能会在旅行线路中不予讨论）

可见剩下的$m-a[s]+a[next]$天小$c$只往返于$s$和$next$两点

若$m-a[s]+a[next]$为偶数则两点点权相等

若为奇数则一大一小（谁大谁小不一定）

故只需分类讨论即可得出正确答案

```cpp
#include<bits/stdc++.h> 
#define ll long long
using namespace std;
inline ll read(){
    ll x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
ll t,n,m;
ll a[2000010];
ll to[2000010];
int main(){
	t=read();
	while(t--){
		n=read(),m=read();
		ll maxx=0;//寻找s点点权 
		ll maxn=0;//寻找s点序号 
		for(ll i=1;i<=n;i++){
			a[i]=read();
			if(a[i]>maxx){
				maxx=a[i];
				maxn=i;
			}
		}
		if(n==1){
			cout<<1<<endl;
			continue;
		}
		ll cnt=0;
		for(ll i=1;i<n;i++){
			ll u,v;
			u=read(),v=read();
			if(u==maxn){
				to[++cnt]=v;
			}
			if(v==maxn){
				to[++cnt]=u;
			}
		}//以上均为输入 
		ll nextx=0;
		ll nextn=0;
		for(ll i=1;i<=cnt;i++){
			if(a[to[i]]>nextx){
				nextx=a[to[i]];
				nextn=to[i];
			}
			else if(a[to[i]]==nextx&&to[i]<maxn){
				nextn=to[i];
			}
		}//寻找next点权及序号 
		if(maxx>nextx+m){
			cout<<maxn<<endl;
			continue;
		}
		else if(maxx==nextx+m){
			if(maxn>nextn){
				cout<<nextn<<endl;
				continue;
			}
			else {
				cout<<maxn<<endl;
				continue;
			}
		}
		else {
			ll out=maxx-nextx;
			m-=out;
			if(m%2==0){
				cout<<min(maxn,nextn)<<endl;
			}
			else cout<<max(maxn,nextn)<<endl;
		}
	}
    return 0;
} 
该题解似乎还可以优化（其实是我太菜了有很多多余代码）

```

给出一组样例

```cpp
3
6 9
1 2 3 4 5 6 
1 5
2 5
3 5
4 5
5 6
4 9
4 5 6 6
1 2
2 3
1 4
4 9
4 5 6 7
4 2
4 3
1 4
```
输出

```cpp
6
2
3
```

---

## 作者：wisdom_grass (赞：1)

#### Solution:
这题乍一看毫无思路，但是仔细思考（指思考了两天），找到了突破口。

手玩一下样例，设最大值为$A_i$（在第$i$个结点），那么在旅行若干次$i$后，其相邻结点中会有一个$A_j = A_i$（在第j个结点）。此时若$i$ < $j$,则继续旅行$i$，使得$A_j = A_i + 1$。接下来应该旅行$j$，而旅行一次$j$后，因为$j$的相邻结点中$i$的$A$值最大，且此时$A_i$又会大于（或等于，取决于$i$和$j$的大小关系）又应该旅行$i$。

所以应该先旅游几天，若旅行完$M$天$A_i > A_j$（由$A$数组中元素的范围可知，使$A_i = A_j$的天数 < $2^{31}$），则直接输出$i$，否则接下来判断$M - (A_i - A_j)$的奇偶性。

可以配合代码理解。
#### code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

typedef long long LL;
const int MAXN = 4000007;
const int INF = 99999999;
int T, N;
LL M;
int A[MAXN];
struct Edge {
	int u, v, nxt;
	Edge (int u = 0, int v = 0, int nxt = 0) : u(u), v(v), nxt(nxt) {}
}e[MAXN];
int fir[MAXN], tote;
struct Node {
	int id, x;
	bool operator < (const Node h) const {return x == h.x ? id > h.id : x < h.x;} 
	// 重载小于运算符，当x != h.x时比较x，当x == h.x时比较其id值。
	Node (int id = 0, int x = 0) : id(id), x(x) {}
}mxi, mxj;

void Clear() {
	memset(fir, 0, sizeof(fir));
	tote = 0;
	mxi = mxj = Node(INF, 0);
}
void addedge(int x, int y) {
	e[++tote] = Edge(x, y, fir[x]);
	fir[x] = tote;
}
int main() {
	#ifdef test
		freopen("test.txt", "r", stdin);
	#endif
	cin >> T;
	while(T--) {
		cin >> N >> M;
		Clear();
		for(int i = 1; i <= N; i++) {
			scanf("%d", &A[i]);
			Node h = Node(i, A[i]);
			mxi = max(mxi, h);
		}
		if(N == 1) {
			printf("1\n");
			continue;
		}
		int x, y;
		for(int i = 1; i < N; i++) {
			scanf("%d %d", &x, &y);
			addedge(x, y), addedge(y, x);
		}
		
		for(int i = fir[mxi.id]; i; i = e[i].nxt) 
			mxj = max(mxj, Node(e[i].v, A[e[i].v]));
		
		//mxi代表A值最大的节点，mxj代表mxi相邻的节点中A值最大的那个点。
		int h = mxi.x - mxj.x; 
		if(M < h) {cout << mxi.id << endl; continue;} // M不满足二者的差值。
		M -= h;
		mxj.x = mxi.x; 
		if(mxi < mxj) swap(mxi, mxj);
		if(M & 1) cout << mxj.id << endl; // M&1 即 M%2==1
		else cout << mxi.id << endl;
	}
	return 0;
}
```

---

## 作者：Youngore (赞：0)

[更好的阅读体验](https://youngore.github.io/2020/10/31/P7043%E3%80%8CMCOI-03%E3%80%8D%E6%9D%91%E5%9B%BD)

题面大意：一棵树，每次选择一个权值最大的点（特别的，若有多个权值相同的点，则选择编号最小的），并令周围的一圈点权值都加一，操作m次，最终权值最大的那个节点是哪个？其中m属于1e18



如此之大的数据量启示我们找规律或者矩阵乘法，显然此题没办法矩乘，所以只能找规律

考虑我们第一次找出来的最合适的点$fa$，考虑每次操作与$fa$最合适的儿子$son$权值的关系

1）当我即使用尽所有的次数，未能使得son与fa的权值相等，显然fa是最合适的

2）当son权值跟自己一样，但是操作次数已经用完了，显然这时候最优的点一定是自己与儿子之间编号最小的那个节点

3）当son权值跟自己一样，但是依然还有剩余的一些次数，显然，我的答案只可能在$fa$与$son$之间反复横跳，顾分奇偶来讨论。

（为了方便后续的讲解，此时我们比较fa与son编号的大小，如果发现fa编号大于son则交换fa与son，想一想，为什么？）



我们保证fa一定是**当前**合适的点。

*   若剩下奇数次，答案是son
*   若剩下偶数次，答案是fa

其实如果用文字来表示，恕我傻逼，难以表示清楚，但是我们可以举个特殊的例子来方便理解

奇数？1是奇数吧？我接下来再**操作一次**，一定是操作在fa上，结果就是使得son的权值比fa大一，所以答案是son；

偶数？0是偶数吧？我接下来**不操作**，我原先最合适的点不是fa吗，所以现在还是fa

证毕.



还有一个小细节，一个可以影响你九十分的小细节，**请特判1**

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 2e6 + 66;

int ver[N << 1], nex[N << 1], head[N], cnt;

inline void add_edge(int x, int y)
{
    ver[++ cnt] = y;
    nex[cnt] = head[x];
    return (void)(head[x] = cnt);
}

int T, n, m, son, fa;
int a[N];

inline void yhm_clear()
{
    cnt = fa = son = 0;
    memset(a, 0, sizeof a);
    memset(nex, 0, sizeof nex);
    memset(ver, 0, sizeof ver);
    memset(head, 0, sizeof head);
}

inline void yhm_func()
{
    int i, x, y;
    n = read(), m = read();
    for (i = 1; i <= n; ++ i)
    {
        a[i] = read();
        if (a[i] > a[fa]) fa = i;
        else if (a[i] == a[fa] && i < fa) fa = i;
    }
    for (i = 1; i < n; ++ i)
    {
        x = read(), y = read();
        add_edge(x, y), add_edge(y, x);
    }
    if (n == 1) return (void)(put(1));
    for (i = head[fa]; i; i = nex[i])
    {
        y = ver[i];
        if (a[y] > a[son]) son = y;
        else if (a[y] == a[son] && y < son) son = y;
    }

    if (a[fa] - a[son] > m) return (void)(put(fa));
    if (a[fa] - a[son] == m) return (void)(put(min(fa, son)));
    int rest = m - (a[fa] - a[son]);
    if (fa > son) swap(fa, son);
    if (rest & 1) return (void)(put(son));
    return (void)(put(fa));
}

signed main()
{
    T = read();
    while (T --)
    {
        yhm_clear();
        yhm_func();
    }
    return 0;
}
```

我觉得我的码风很棒

---

## 作者：XyzL (赞：0)

## 题意：

给定一棵树，有 $n$ 个点，每个点都有点权 $a_i$。

给定一个操作，每次选择点权最高且编号最小的点，使其相邻的所有点点权加 $1$ 。

求经过 $m$ 次操作以后，点权最高且编号最小的点。

## 分析：

暴力枚举每一个时间的好感度，单次时间 $O(n)$ ，在此基础之上，我们可以用线段树 + $BFS$ 序去维护， 单次时间 $O(log_n)$ 。

正解，确定一个城市 $X$ 表示第一次访问的城市和另一个城市 $Y$ 表示第二次访问的城市，可以发现，在第一次到达 $Y$ 之后，所以结果都在 $X$ 与 $Y$ 中交替进行，只需判断一下奇偶性即可。

最后注意一下 $n = 1$ 的情况。

## 代码：

```cpp
#include <bits/stdc++.h>

const int MaxSize = 20;

char buf[1 << MaxSize], *p1, *p2;

#define GetChar() \
    ((p1 == p2) ? (p2 = buf + fread(p1 = buf, 1, 1 << MaxSize, stdin), p1 == p2 ? EOF : *p1++) : *p1++)

template <class T>
inline void in(T &x) {
    x = 0;
    register bool f = 0;
    register char c = GetChar();
    while (c < 47 || c > 58) {
        f |= (c == '-'), c = GetChar();
    }
    while (c > 46 && c < 59) {
        x = (x << 3) + (x << 1) + (c & 15), c = GetChar();
    }
    x = f ? (~x + 1) : x;
}

#define int long long

inline int min(register int a, register int b) { return (a < b) ? a : b; }

const int MaxN = 2e6 + 6;

int T, n, m, maxi, Maxi_2, a[MaxN], b[3];

signed main() {
    in(T);
    while (T--) {
        in(n), in(m);
        a[0] = -1, maxi = 0,  Maxi_2 = 0;
        for (register int i = 1; i <= n; ++i) {
            in(a[i]);
            if (a[i] > a[maxi]) maxi = i;
        }
        if (n == 1) {
            puts("1");
            continue;
        }
        for (register int i = 1, x, y; i < n; ++i) {
            in(x), in(y);
            if (x == maxi && \
			   (a[y] > a[Maxi_2] || (a[y] == a[Maxi_2] && y < Maxi_2)))
                Maxi_2 = y;
            if (y == maxi && \
			    (a[x] > a[Maxi_2] || (a[x] == a[Maxi_2] && x < Maxi_2)))
    			Maxi_2 = x;
        }
        if (m < a[maxi] - a[Maxi_2]) {
        	printf("%lld\n", maxi);
		} else {
            m -= a[maxi] - a[Maxi_2];
            b[0] = maxi, b[1] = Maxi_2;
            if (b[0] > b[1]) {
            	std::swap(b[0], b[1]);
			}
            printf("%lld\n", b[m & 1]);
        }
    }
    return 0;
}
```

---

## 作者：花园Serena (赞：0)

其实最开始看到这道题目的时候是没有什么做法的，但是看到$M \le 10 ^ 18$ 之后感觉应该是个结论题，所以自己画图手玩了一下发现了做法

首先对于一个最开始到达的点，它是好感度最大且编号最小的，并且他只会影响到他周围的点（显然），所以我们先随便画个图：

下文称权值最大且编号最小的点为 $Max$，与他相连的次大的且编号最小的点为 $Max_S$

![](https://cdn.luogu.com.cn/upload/image_hosting/kzmns76s.png)

对于这个图，标红的是我们会选择的第一个点，因为他只会对周围的点造成影响，所以**不在他周围的次大的点**是不会对答案造成贡献的，那么我们会一直选这个点作为 $Max$ 直到他周围的点和他幸福度相同的时候，如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/gqyft10z.png)

显然，当有一个点的权值和他一样时，我们会选择这两个点中编号较小的一个,在图中是结点1的标号更小，所以我们继续选择一号结点，且这个和第一个 与$Max$ 权值相同的点一定是 $Max_S$那么，当 $Max_S$ 的优先级 高于 $Max$ 时，即 $Max_S$ 成为 $Max$ 时，原来的   $Max$ 一定是 $Max_s$, 这个下文再画图解释
![](https://cdn.luogu.com.cn/upload/image_hosting/tmdf7hwg.png)

当 $Max_S$ 成为 $Max$ 时，即图中的7号结点在第4次更新后，权值变成8,这个时候我们会选择7号结点作为 $Max$。接着我们又会更新7号结点周围的点，导致一号结点成为 $Max$ 然后重复这个操作，那么我们发现，答案最终只会在最初的 $Max$ 与 $Max_S$ 中产生。

那么我们先算出 $Max$  与 $Max_S$ 的差值，并且当  $Max$  的标号大于 $Max_S$ 时，交换他们两个的值保证$Max$  的标号小于 $Max_S$,将它与 $M$ 进行比较，如果 $M$ 小于这个差值，那么我们直接输出$Max$ 值，如果大于等于的话，我们将这个差值 % 2,如果余数等于1,输出$Max_S$,因为这个时候我们选择的是最开始的 $Max$ 所以更新了 $Max_S$ 的值使其的幸福度大于 $Max$ ,而当余数等于0时，我们输出 $Max$ 因为此时 $Max$ 与 $Max_S$ 的幸福度相等，而前者标号小于后者。

记得对 $n = 1$  的情况进行特判，因为这个时候我们找不到任何一个 $Max_S$, 所以直接输出唯一的一个点。

### 然后对一些上文提到的问题进行解释

>当 $Max_s$ 的优先级 高于 $Max$ 时，即 $Max_s$ 成为 $Max$ 时，原来的 $Max$ 一定是 $Max_s$

$Q$ : 如果有一个点在 $Max_s$ 成为　$Max$　时与$Max_s$ 相连且幸福度同样与 $Max_S$ 相等，标号还要小些怎么办，要选择那个点吗

### $A$ : 你看

![](https://cdn.luogu.com.cn/upload/image_hosting/5iwwv7h4.png)

如果存在这样一个点，那么在最开始选择我们这个理想的 $Max$ 的时候是不会更新这个一号结点的，也就是说一号结点最开始的幸福度就和5号结点一样大，所以在最开始我们就会选择1号结点而不是5号结点，当 $Max$ 的标号小于 $Max_S$ 的时候同理。

附上代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
const LL MAXN = 2000000  + 10;
LL head[MAXN], to[MAXN << 1], nxt[MAXN << 1];
LL val[MAXN], cnt, Max, Maxs;
inline LL read() {
	LL x = 0;char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	while (c >= '0' && c <= '9') x = x * 10 + c -'0',c = getchar();
	return x;
}
int main ()  {
    LL T; T = read();
    while(T --) {
        memset(head, 0, sizeof(head));
        cnt = 0; Max = 0; Maxs = 0;
        LL n, m; n = read(); m = read();
        for(register LL i = 1; i <= n; i ++) {
            val[i] = read();
            if(val[Max] < val[i]) Max = i;
        }
        for(register LL i = 1; i < n; i ++) {
            LL x, y; x = read(); y = read();
            if(y == Max) swap(x, y);
            if(x == Max) {
                if(val[Maxs] < val[y]) Maxs = y;
                else if(val[Maxs] == val[y])
                    Maxs = min(Maxs, y);
            }
        }
        if(n == 1) {printf("%lld\n", Max); continue;}
        if(val[Max] - val[Maxs] <= m) {
            m -= (val[Max] - val[Maxs]);
            if(Maxs < Max) swap(Max, Maxs);
            if(m % 2 & 1) printf("%lld\n", Maxs);
            else printf("%lld\n", Max);
        }
        else printf("%lld\n", Max);
    }
    return 0;
}
```
如果对于文章中有什么疑问或是错误，欢迎在评论或私信提出

---

## 作者：残碑小筑 (赞：0)

（考场上没特判n==1调了快一个小时......）

原题[P7043](https://www.luogu.com.cn/problem/P7043)

看完题目后很容易想到暴力解法，~~首先这是一棵树~~，每次先找出当前好感度最高的村庄，更新与之相连的村庄的好感度，再找出更新后好感度最高的村庄进行下一轮更新。复杂度为O(mn)

然后跑去看数据范围，啥？m<=1e18  ?  ?   ?

看到这个范围我们就知道复杂度里肯定不带m。（log m : ?）

手动模拟分析一下，如果假设当前好感度最高的村庄为A，一天结束后，发生更新的只有与A相连的村庄，也就是说，与A不相连的村庄的好感度一定还是小于A的，所以下次去旅行的村庄一定在A和与之相连的村庄中，不妨记与A相连的村庄中好感度最高的村庄为B，两村庄好感度之差为s，易知经过m-s天后s=0，在这m-s天中实际一直停留在村庄A中。之后则只会在A,B两个村庄中（今天在A则B加1，第二天则B>A,停留在B，再给A加一，第三天回到A......）所以此时只需判断一下m的奇偶性就行了。

几个坑点：

1.~~不开longlong（）~~

2.当有村庄好感度相同时输出好感度最小的那个，所以在最后要处理一下

3.特判n=1......

最后上代码：（不要问那个DFS是什么，考场上懒得想函数名）
```
#include<bits/stdc++.h>
using namespace std;
#define N 2000010
#define out(x) printf("%d\n",(x))
int n,T,a[N],maxn,root,son,maxs;
long long m;
struct edge{
	int nex,t;
} e[N*2]; int head[N],tot;
inline void add(int x,int y) {
	e[++tot].t=y; e[tot].nex=head[x]; head[x]=tot;
}
inline int read() {
	int s=0,w=1; char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
void dfs(int x) {
	for(int i=head[x];i;i=e[i].nex) {
		int y=e[i].t;
		if(a[y]>maxs) son=y,maxs=a[y];
	}
}
int main()
{
	T=read();
	while(T) {
		T--;
		n=read(); scanf("%lld",&m);
		for(int i=1;i<=n;i++) {
			a[i]=read();                  
			if(a[i]>maxn) maxn=a[i],root=i;       
		}
		for(int i=1;i<n;i++) {
			int x,y; x=read(); y=read();
			add(x,y); add(y,x);
		}
		if(n==1) {
			printf("1\n"); continue;
		}
		dfs(root);
		if(m<a[root]-a[son]) printf("%d\n",root);
		else if(m==a[root]-a[son]) printf("%d\n",min(root,son));
		else {
			m-=(a[root]-a[son]);
			if(root<son) {
				if(m%2==0) printf("%d\n",root);
				else printf("%d\n",son);
			}
			else {
				if(m%2==0) printf("%d\n",son);
				else printf("%d\n",root);
			}
		}
		maxn=-1; maxs=-1; tot=0; son=0; root=0;
		memset(head,0,sizeof(head));
	}
	return 0;
}
```


---

## 作者：yewanxingkong (赞：0)

这个题属于思路题，思路想出来了代码实现并没有太难。

首先可以确认的是 $O(m)$ 复杂度的暴力肯定会炸，所以正解要考虑一些别的方法。

根据题面可以看出这些个村庄是一棵树。那么树的性质有一点，就是每两个点之间的简单路径是固定的，也就是说如果一个点与另一个点由一条边相连，那么与另一个点由一条边相连的点就不会与这个点有边相连。

这样来看的话就可以推出这道题的正确思路了。

首先我设有编号为 $0,1,2,3$ 的四个点， $0$ 与 $1$ 和 $2$ 有边相连，$1$ 与  $3$ 有边相连。我假设第一天小 $S$ 住在 $0$ 点，住完几天后 $1$ 点增加到了最大值，小 $S$ 又去住 $1$ 点。由于 $1$ 与 $0$ 和 $3$ 有边相连，而且 $1$ 只比 $0$ 权值大一，所以住完一晚后 $0$ 又变成了最大点，因为 $3$ 的权值是比 $0$ 小的，在同时加 $1$ 时大小关系不变。

也就是说最终答案只会在一开始最大的那个点还有与它相连的最大的那个点中得到，因为由于树的性质，小 $S$ 住处转移后与之前最大值相连的点并不会权值增加，所以大小关系一直不变。

剩下要注意的就是权值相等时编号小的优先，以及 $n$ 可能等于 $1$ 的情况了。

具体细节可以看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
int t,n,hd[2000010],ji,gan[2000010];
long long m;
struct nod{
	int xu,nxt;
}cun[2000010];
inline void add(int a,int b){
	cun[++ji].xu=b;
	cun[ji].nxt=hd[a];
	hd[a]=ji;
}
inline int read(){
	int date=0,w=1;char c=0;
	while(!isdigit(c)){if(c=='-')w=-1;c=getchar();}
	while(isdigit(c)){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int main() {
    t=read();
    while(t--){
    	ji=0;
    	memset(hd,0,sizeof(hd));
    	memset(cun,0,sizeof(cun));
        n=read();
        scanf("%lld",&m);
        int mxu,mzhi=0,cxu=0,czhi=0;
        for(int i=1;i<=n;++i){
        	gan[i]=read();
        	if(gan[i]>mzhi){
        		mzhi=gan[i];
        		mxu=i;
			}
		}
        for(int i=1;i<n;++i){
        	int x=read(),y=read();
        	add(x,y);
        	add(y,x);
        }
        for(int i=hd[mxu];i;i=cun[i].nxt)
        	if(gan[cun[i].xu]>=czhi)
        		if(gan[cun[i].xu]==czhi)cxu=min(cxu,cun[i].xu);
        		else{
        			czhi=gan[cun[i].xu];
        			cxu=cun[i].xu;
        		}
        m-=mzhi-czhi;
        if(mxu<cxu)m-=1;
        if(cxu==0)printf("%d\n",mxu);
        else if(m%2==1||m<0)printf("%d\n",mxu);
        else printf("%d\n",cxu);
    }
    return 0;
}
```


---

## 作者：SpectatorX (赞：0)

~~首先吐槽数据，特判调了几十分钟…~~

乍一看这题有一些复杂，实际上只要找到规律就比较好写~~某特判除外~~。

第一天一定是在**初始好感值最高的村庄**，记为$st$。

然后在某一天，$st$所直接连接的其他村庄中，好感值最大的村庄（记为$lst$）的好感值会达到$st$的好感值。

这时小$S$就要做出抉择，即在$st$与$lst$间选择（取决于$st$与$lst$的大小关系）。

又在某一天的后一天，$st$的好感值又会反超$lst$的好感值，小$S$就会再次移动。

以此类推。~~反复横跳~~

所以可以由此推出规律（记$i$的好感值为$a_i$）：

当$a_{st}=a_{lst}$时，最终好感值最大的村庄$ans=\begin{cases}lst&m\bmod 2=1,st<lst\\st&m\bmod 2=0,st<lst\\st&m\bmod 2=1,lst<st\\lst&m\bmod 2=0,lst<st\end{cases}$

另外就是特判~~15->100的飞跃~~，**当$n=1$时，输出$1$即可。**

```cpp
#include<cstdio>
#include<string>
using namespace std;
#define N=2000000
#define int long long
int t,n,m,st,mst,lst,lmst;
int a[N+5];
inline int read()
{
	int x=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x;
}
signed main()
{
	t=read();
	while(t--)
	{
		n=read();m=read();
		mst=0;st=0;lst=0;lmst=0;//多测不清空，爆零很轻松 
		for(int i=1;i<=n;++i)
		{
			a[i]=read();
			if(a[i]>mst) mst=a[i],st=i;//找到最大值及其编号 
		}
		for(int i=1;i<n;++i)
		{
			int u=read(),v=read();
			if(u==st) if(a[v]>lmst) lmst=a[v],lst=v;
			if(v==st) if(a[u]>lmst) lmst=a[u],lst=u;//找次大值及其编号 
		}
		if(n==1)//特 判 
		{
			puts("1");
			continue;
		}
		m-=a[st]-a[lst];
		if(m<0) printf("%lld\n",st);
		else 
		{
			if(st<lst)
			{
				if(m&1) printf("%lld\n",lst);
				else printf("%lld\n",st);
			}
			else
			{
				if(m&1) printf("%lld\n",st);
				else printf("%lld\n",lst);
			}
		}
	}
 	return 0;
}
```


---


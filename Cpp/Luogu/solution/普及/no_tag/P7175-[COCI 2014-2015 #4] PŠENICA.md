# [COCI 2014/2015 #4] PŠENICA

## 题目描述

Mirko 和 Slavko 每年在 Saint Lucy’s Day 种植圣诞小麦。小麦的茎秆生长速度不同，经过一段时间后，小麦变得相当凌乱。他们决心通过玩下面的游戏来解决这个问题，游戏将轮流进行如下环节：

- Mirko 选择一根高度最小的麦秆使其高度变成次小值。
- Slavko 选择一根高度最大的麦秆使其高度变成次大值。
- 如果剩下的不同高度的数量不小于 $3$，游戏继续进行，否则结束，结束时需要操作者为输家了。

给定小麦秸秆的高度，Mirko 先手。请确定游戏的赢家以及结束后高度的最小值与最大值。

## 说明/提示

#### 样例 1 说明

初始时 Mirko 便不能操作，因此，Slavko 是赢家。

#### 数据规模与约定

- 对于 $50\%$ 的数据，有 $1\le n\le 500$。
- 对于 $80\%$ 的数据，有 $1\le n\le 3\times 10^3$。
- 对于 $100\%$ 的数据，有 $1\le n\le 10^5$。

对于所有合法的 $h_i$，都有 $1\le h_i\le 10^5$。

#### 说明

**题目译自 [COCI2014-2015 CONTEST #4](https://hsin.hr/coci/archive/2014_2015/contest4_tasks.pdf) _T2 PŠENICA_。**

## 样例 #1

### 输入

```
3
3 3 3```

### 输出

```
Slavko
3 3
```

## 样例 #2

### 输入

```
4
3 1 2 1
```

### 输出

```
Slavko
1 2```

## 样例 #3

### 输入

```
7
2 1 3 3 5 4 1 ```

### 输出

```
Slavko
2 3```

# 题解

## 作者：Terrible (赞：11)

### 观前提醒

表述略有些啰嗦，请先浏览一遍，找到有用的东西，懂怎么做就行了。

### 题目简述

- Mirco 把**最小的数据**变成**第二小的数据**；
- Slavko 把**最大的数据**变成**第二大的数据**；
- 就是把数据从两边往**中间挤**。
- 两人轮番，直到只剩下**两种大小的数据**，留下的烂摊子是谁的，谁就输了。
- 输出**赢的人**和**这两个数据大小**（也可能是一种）。
- 如果游戏开局就两种甚至一种长度的麦秆，Mirco 就直接输掉了。

### 思路

暴力模拟程序呼之欲出，排个序模拟一下就行，不过暴力打出来程序几乎是 $O(n^2)$（跟滚雪球一样，中间数据越滚越多），一看 $1 \leq n \leq 10^5 $，会妥妥地 T 掉，所以需要优化一下。

由于我们只关注麦秆的相对大小，那么就可以进行**排序**然后**离散化**处理，然后把**相同数据归并**，然后把数据往**中间挤**，记录操作者就行。所以主体的时间复杂度是 $O(n \log n)$（排序的复杂度）和 $O(n)$（挤数据的复杂度）。

### 思路演练

##### 例如（手写数据）：
~~~~
12
3 24 341 231 342 443 543 3 4 4 2 743
~~~~
##### 排序：
~~~~
2 3 3 4 4 24 231 341 342 443 543 743
~~~~
##### 离散化处理后归并：


| i | 1(2) | 2(3) | 3(4) | 4(24) | 5(231) |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| b[i] | 1 | 2 | 2 | 1 | 1 |
| i | 6(341) | 7(342) | 8(443) | 9(543) | 10(743) |
| b[i] | 1 | 1 | 1 | 1 | 1 |


![GIF图片展示](https://s3.bmp.ovh/imgs/2023/03/20/19c2a85874b5deb3.gif)

上图，

①蓝色状态表示有 $4$ 组以上数据，两人完成整轮整轮的操作，让两端有一组或两组完全被“挤”到中间，操作过程中不触发游戏结束机制，操作完仍然该 Mirko 操作。

②黄色状态表示 $3$ 组数据，有结束游戏的可能，具体展示了谁会输。

③红色状态就表明游戏结束。

#### 输出：

~~~~
Mirko
231 341
~~~~

### 代码

```cpp
#include<cstdio>
#include<algorithm>
int read()//正整数快读 
{
	int a=0;char c;
	while((c=getchar())<'0');
	while(c>='0')a=a*10+(c^48),c=getchar();
	return a;
}
int source[100003]/*源数据*/,mapping[100003]/*反向映射*/;//离散化
int bucket[100003]/*桶装数据*/,min,max;//归并数据 
int main()
{
	int n=read(),cnt=1;
	for(int i=1;i<=n;i++)source[i]=read();
	std::sort(source+1,source+n+1);//排序 
	for(int i=1;i<=n;i++)//离散化 归并数据 
	{
		mapping[cnt]=source[i],bucket[cnt]++;
		if(source[i]<source[i+1])cnt++;
	}
	int min=1,max=cnt;//找到边界往中间挤 
	while(max-min>=3)//max-min+1>=4 “挤”数据要保证至少有4个，否则需要考虑先后手交换 
	{
		//两人转移相同数目的数据，且转移过程中不触发游戏结束机制，下次的操作者不变 
		int m=std::min(bucket[min],bucket[max]);
		bucket[max-1]+=m,bucket[max]-=m;
		bucket[min+1]+=m,bucket[min]-=m;
		if(!bucket[min])min++;
		if(!bucket[max])max--;
	}
	bool f=1;//0表示Mirko胜利，1表示该Slavko胜利 
	//先赋值1，如果max-min+1<=2 Slavko直接胜利 
	if(max-min>=2)//max-min+1>=3 这里判别输赢问题 
	{
		//显然，左端数据如果小于等于右端数据，由于Mirko是先手，甩锅，输局留给对方
		 if(bucket[min]<=bucket[max])f=0,min++;
		 else max--;
	}
	printf("%s\n%d %d",!f?"Mirko":"Slavko",mapping[min],mapping[max]);
}
```

#### 特别解释：

例如，若上面程序中 $bucket$ 剩下四组数据：$3$ $2$ $1$ $3$，两人同时向中间转移数据，转移完成就成了 $5$ $4$，游戏结束，不过我们可以认为**转移过程中是没有结束游戏的**，转移完成了才结束游戏，所以下一次仍然是 Mirko，直接接受败局！

再例如，上面程序中 $bucket$ 剩下三组数据：$3$ $2$ $3$，**转移数据的过程中就结束游戏了**，所以轮不完 $3$ 轮游戏，到 $1$ $5$ $1$ 时，Mirko 把小数据往右挤，成了 $6$ $2$，那么 Slavko 就要接受败局。

---

## 作者：logfk (赞：3)

## 题意

这道题其实很容易理解，我们可以视为一个人从小到大来变大麦秆，另一个人从大到小来变小麦秆，进一步的说，可以轮流变换一部分相同的麦秆。

例如：$2$ $2$ $3$ $3$ $4$ $4$ $5$ $5$，可以理解为一个人将两个 $2$ 变为两个 $3$ ，另一个人将两个 $5$ 变为两个 $4$。

## 思路

如果我们一个一个进行加减，这样的时间复杂度是 $O(n^{2})$，根据数据来说一定会TLE，所以我们采用**前缀和**的思想，将麦秆的数量以前缀和的方式存储下来，随后只需要判断谁需要移动，然后移动相应的数量即可。

时间复杂度：$O(h_{max})$（严格来说为 $O(p)$，其中 $p$ 为不同高度的数量），在处理前缀和的时候相当于去重，实际上也起到了离散化的作用。

## 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100010],s[100010],p[100010];//a为高度的前缀和，s为一个存储高度的桶，p为初始输入的高度（并不需要）（阴间定义）
int main()
{
	int n,x,c;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i];
		s[p[i]]++;
	}
	x=0;
	for(int i=1;i<=100000;i++)
	{
		if(s[i]) 
		{a[++x]=s[i];a[x]+=a[x-1];}//计算前缀和
	}
	int w=x,ts=0,ws=0,t=1,la=1;//w从大到小到了第几个，t从小到大到了第几个，ts，ws分别表示割了多少，la表示上一个操作的人。
	while(t+1<w)
	{
		if(ts+a[t]<=ws+a[x]-a[w-1])//从小到大的人需要割
		{
			la=0;ts+=a[t];t++;
		}
		else//从大到小的人需要割
		{
			la=1;ws+=a[x]-a[w-1];w--;
		}
	}
    /*根据题意输出*/
	if(!la) cout<<"Mirko"<<endl;
	else cout<<"Slavko"<<endl;
	int tot=0,fl=0;
	for(int i=1;i<=100000;i++)
	{
		if(s[i])tot++;
		if(tot==t&!fl) 
		{cout<<i<<" ";fl=1;}
		if(tot==w) 
		{cout<<i<<endl;return 0;}
	}
}
```


蒟蒻实力不足，如果有错误请私信本蒟蒻QAQ


---

## 作者：chrispang (赞：2)

## 题目大意

给定一个长度为 $n$ 的序列，现在 Mirko 和 Slavko 在玩一个游戏，Mirko 先手，具体操作如下：

1. Mirko 可以把序列中最小值改成次小值；
2. Slavko 可以把序列中最大值改成次大值；
3. 如果序列中只剩下两种甚至一种不一样的数，则需要操作者输。

请问胜利者和剩下序列中的最小值和最大值是什么？

## 题目分析

### $O(n^3)$ 做法

> 创建最暴力法，拿下最稳定分！

一个一个的模拟，每次找出序列中的最值和次值，一共需要修改 $n^2$ 次，每次查询时间复杂度为 $O(n)$，总的时间复杂度为 $O(n^3)$，代码如下（$56$ 分）。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[100010];
int find_max() {
	int res = 1;
	for (int i = 2; i <= n; i++) if(a[res] < a[i]) res = i;
	return res;
}

int find_next_max(int x) {
	int now_max = -1, res = 1;
	for (int i = 1; i <= n; i++) if(now_max < a[i] && a[i] < x) res = i, now_max = a[i];
	return res;
}

int find_min() {
	int res = 1;
	for (int i = 2; i <= n; i++) if(a[res] > a[i]) res = i;
	return res;
}

int find_next_min(int x) {
	int now_min = 1e9, res = 1;
	for (int i = 1; i <= n; i++) if(now_min > a[i] && a[i] > x) res = i, now_min = a[i];
	return res;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    while(1) {
    	int ma = find_max(), cma = find_next_max(a[ma]); //最大、次大
		int mi = find_min(), cmi = find_next_min(a[mi]); //最小、次小 
    	if(mi + 1 == ma || ma == 1) {
    		printf("Slavko\n%d %d", a[mi], a[ma]);
			break;
		}
		a[mi] = a[cmi];
    	ma = find_max(), cma = find_next_max(a[ma]); //最大、次大
		mi = find_min(), cmi = find_next_min(a[mi]); //最小、次小 
    	if(mi + 1 == ma || ma == 1) {
    		printf("mirko\n%d %d", a[mi], a[ma]);
			break;
		}
		a[ma] = a[cma];
	}
    return 0;
}
```

### $O(n^2\log n)$ 做法

> 改变最暴力法，进行步步为赢！

考虑到每个操作只需要要求删除数据，没有固定下标，因此可以进行升序排序，每次查找第一个最大值和最后一个最小值，以保持有序。而次大值和次小值可以通过最大值和最小值得出来，这里不做研究（详见代码）。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[100010];
int find_max(int x) { //找出第一个最大值 
	int l = 1, r = n, res;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(a[mid] == x) r = mid - 1, res = mid;
		else if(a[mid] < x) l = mid + 1;
		else r = mid - 1;
	}
	return res;
}

int find_min(int x) { //找出最后一个最小值
	int l = 1, r = n, res;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(a[mid] == x) l = mid + 1, res = mid;
		else if(a[mid] < x) l = mid + 1;
		else r = mid - 1;
	}
	return res;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    sort(a + 1, a + n + 1); //排序 
    while(1) {
    	int ma = find_max(a[n]), cma = ma - 1; //最大、次大
    	int mi = find_min(a[1]), cmi = mi + 1; //最小、次小
    	if(mi + 1 == ma || ma == 1) {
    		printf("Slavko\n%d %d", a[mi], a[ma]);
			break;
		}
		a[mi] = a[cmi];
		ma = find_max(a[n]), cma = ma - 1; //最大、次大
    	mi = find_min(a[1]), cmi = mi + 1; //最小、次小
    	if(mi + 1 == ma || ma == 1) {
    		printf("Mirko\n%d %d", a[mi], a[ma]);
			break;
		}
		a[ma] = a[cma];
	}
    return 0;
}
```

### $O(n^2)$ 做法

> 优化最佳暴力，打下 AC 基础！

考虑每次只是维护最值和次值，用二分查找来解决这个问题其实是有点大题小做的，那么我们能不能直接维护这四个值呢？答案是可以的！

我们首先给序列进行排序，记录下第一个最大值、第一个次大值、最后一个最小值、最后一个次小值。在进行更新的时候，把次小值赋值给最小值，之后最小值的下标 $-1$；如果最小值的下标已经为 $1$，则让最小值的下标移动到次小值那里，之后更新次小值的位置（还是最后一个次小值）。而最大值的操作也同理。看似是 $n^2$ 个操作中每次还要进行 $n$ 次更新次值的暴力，实际由于每一个位置，一个指针只会经过一次，因此时间复杂度为 $O(n^2+n)$，舍去常数为 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, ma, cma, mi, cmi, a[100010];
void init() { //刚开始先找到最值的位置 
	ma = n;
	for (int i = n; i >= 0; i--)
		if(a[ma] > a[i]) {
			ma = i + 1;
			break;
		}
	mi = 1;
	for (int i = 1; i <= n + 1; i++)
		if(a[mi] < a[i]) {
			mi = i - 1;
			break;
		}
}

void update_next_max() { //更新次大值 
	if(a[cma] == a[n]) { //表示次大值已经与最大值一样了，需要一直走到不是最大值的位置 
		for (int i = cma; i >= 0; i--)
			if(a[cma] != a[i]) {
				cma = i;
				break;
			}
	}
	for (int i = cma; i >= 0; i--) //找到第一个次大值 
		if(a[cma] > a[i]) {
			cma = i + 1;
			break;
		}
}

void update_next_min() { //更新次小值 
	if(a[cmi] == a[mi]) { //表示次小值已经与最小值一样了，需要一直走到不是最小值的位置 
		for (int i = cmi; i <= n + 1; i++)
			if(a[cmi] != a[i]) {
				cmi = i;
				break;
			}
	}
	for (int i = cmi; i <= n + 1; i++) //找到第一个次小值 
		if(a[cmi] < a[i]) {
			cmi = i - 1;
			break;
		}
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1); //排序
	a[0] = 0, a[n + 1] = 1e9; //为了方便更新
	init(), cma = ma, cmi = mi, update_next_max(), update_next_min(); //初始化 
	while(1) {
		if(mi + 1 == ma || ma == 1) { //边界
			printf("Slavko\n%d %d", a[mi], a[ma]);
			break;
		}
		a[mi] = a[cmi]; //最小换次小
		if(mi == 1) mi = cmi; //发现最小值下标已经为1了，移动到次小值的位置 
		else mi--; //否则往后退
		update_next_min(), update_next_max(); //注意这里既要更新次小值，又要更新次大值 
		if(mi + 1 == ma || ma == 1) { //边界
			printf("Mirko\n%d %d", a[mi], a[ma]);
			break;
		}
		a[ma] = a[cma]; //最大换次大
		if(ma == n) ma = cma; //发现最大值下标已经为n了，移动到次大值的位置 
		else ma++; //否则往前进 
		update_next_min(), update_next_max(); //注意这里既要更新次小值，又要更新次大值 
	}
	return 0;
}
```

### $O(n\log n)$ 做法

> 写出正确代码，实现 AC 之路！

我们可以从之前的三个做法中总结出一个问题：由于我们每次都是一个一个模拟，导致最多需要模拟 $n^2$ 次，不管怎么优化查找内容都没有用。那我们是否能一次多改呢？答案是肯定的！

我们先讲讲大体思路：在不同的元素的数量 $\ge 4$ 时，由于不会造成定胜负的局面，因此在这种情况下每次修改值就好了。当不同的元素的数量为 $3$ 时，代表着即将分出胜负，则判断谁会赢。当不同的元素的数量 $\le 2$ 时，表示游戏结束，分出胜负。

我们可以把 $a_i$ 进行离散化，而此时有人就会有问题了：题目都说了 $1\le a_i\le 10^5$ 了，为什么还需要离散化？因为我们需要让它们紧连在一起，才能保证我们的操作可以更加方便（后面会讲）。

我们定义 $cnt_i$ 表示 $i$ 在序列中出现的次数，这里的 $i$ 其实是 $a$ 数组中某个数**离散化后**的值。接着我们定义**离散化后**最小值为 $l$，**离散化后**最大值为 $r$，$x=min(cnt_l,cnt_r)$。紧接着对数组进行**批量**修改操作，$cnt_{l+1}+x$（最小变次小），$cnt_l-x$（最小变次小），$cnt_{r-1}+x$（最大变次大），$cnt_r-x$（最大变次大）。

其实这么说是有点抽象的，还是参考一下代码吧。如果你还是没看懂，那么你可以去参考一下[Terrible](https://www.luogu.com.cn/user/195942)大佬的[题解](https://www.luogu.com.cn/article/m5m7uaqd)和[DFM_O](https://www.luogu.com.cn/user/1011634)大佬的[题解](https://www.luogu.com.cn/article/f7hbp6sk)（得一起看）。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[100010], cnt[100010];
vector<int>vec;
int find(int x) {
	int l = 0, r = vec.size() - 1;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(vec[mid] == x) return mid + 1;
		else if(vec[mid] < x) l = mid + 1;
		else r = mid - 1;
	}
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]), vec.push_back(a[i]);
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    for (int i = 1; i <= n; i++) cnt[find(a[i])]++; //cnt记录数量 
    int l = 1, r = vec.size();
    while(r - l >= 3) {
    	int x = min(cnt[l], cnt[r]);
    	cnt[r - 1] += x, cnt[r] -= x; //批量修改操作 
    	cnt[l + 1] += x, cnt[l] -= x;
    	if(cnt[r] == 0) r--; //移动指针 
    	if(cnt[l] == 0) l++;
	}
	int is = 1;
	if(r - l >= 2) { //如果剩余元素的数量>=2
		if(cnt[l] < cnt[r]) is = 0, l++; //Mirko需要操作的最小值的数量较少，Mirko赢 
		else r--; //否则Slavko赢
	}
	printf("%s\n%d %d\n", is == 0 ? "Mirko" : "Slavko", vec[l - 1], vec[r - 1]); //输出胜者和两个值 
    return 0;
}
```

### $O(n)$ 做法

> 最求完美做法，写出 $O(n)$ 代码！

可以把上面的做法中时间复杂度为 $O(n\log n)$ 的代码替换一下，快排换桶排，二分换数组，代码如下：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;

int n, a[maxn], cnt[maxn], temp[maxn], fin[maxn];
bool vis[maxn];
vector<int>c, vec;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]), temp[a[i]]++;
    for (int i = 1; i <= maxn; i++)
    	while(temp[i]--) c.push_back(i); //桶排
    for (auto i:c) if(!vis[i]) vis[i] = 1, vec.push_back(i); //去重
    for (int i = 0; i < vec.size(); i++) fin[vec[i]] = i + 1; //记录位置 
    for (int i = 1; i <= n; i++) cnt[fin[a[i]]]++; //cnt记录数量 
    int l = 1, r = vec.size();
    while(r - l >= 3) {
    	int x = min(cnt[l], cnt[r]);
    	cnt[r - 1] += x, cnt[r] -= x; //批量修改操作 
    	cnt[l + 1] += x, cnt[l] -= x;
    	if(cnt[r] == 0) r--; //移动指针 
    	if(cnt[l] == 0) l++;
	}
	int is = 1;
	if(r - l >= 2) { //如果剩余元素的数量>=2
		if(cnt[l] < cnt[r]) is = 0, l++; //Mirko需要操作的最小值的数量较少，Mirko赢 
		else r--; //否则Slavko赢
	}
	printf("%s\n%d %d\n", is == 0 ? "Mirko" : "Slavko", vec[l - 1], vec[r - 1]); //输出胜者和两个值 
    return 0;
}
```

## 解释

- 为什么前三种做法中，需要操作数量为 $n^2$？

> 其实本蒟蒻刚开始也认为第二种做法（$O(n^2\log n)$ 的那个做法）时间复杂度为 $O(n\log n)$ 可以 AC 这道题。后来自己造了一个数据，才发现问题，举个例子：
> 
> ```cpp
> 10
> 1 1 2 2 3 3 4 4 5 5
> ```
> 
> 我们尝试着模拟一下，可以发现：总的操作次数其实不是 $n$ 次，而是 $n^2$ 次！

- 为什么在第三种做法中，每改变一次就要更新次小值和次大值。

> 其实我们要保证在我们不用到次值的时候，次值必须得是第一个（或最后一个）次值！这里再来一个例子：
> 
> ```cpp
> 4
> 1 3 2 3
> ```
> 
> 排序后的序列长这样：
> 
> ```cpp
> 1 1 2 3
> ```
> 
> 最大值为 $4$，最小值为 $1$，次大值为 $3$，次小值为 $3$。
> 
> 第一次操作后序列变成：
> 
> ```cpp
> 1 2 2 3
> ```
> 
> 我们发现如果我们不更新次值的话，这里次大值是 $3$，而实际应该是 $2$。

### 结尾语

双十二快到了，新年快到了 ~~，期末考试也要到了~~！祝大家过的开心！

---

## 作者：floris (赞：1)

## 思路

这道题显然就是一道模拟题，所以我刚开始做这道题的想法是：将小麦的高度从小到大排序，然后统计每一种小麦高度存在的小麦个数，然后定义两个指针 $l$ 和 $r$，代表每次改变中改变的小麦的高度。当某种小麦的高度为 $0$ 时，就跳到下一种小麦高度中去，直到 $r-l=1$ 时，即不同高度的小麦仅有两种时停止，就可以找到赢家与所剩的两种小麦的高度了。注意遍历时每次都要为下一种小麦个数加一，比如 $\operatorname{num_l}$ （第 $l$ 种小麦高度的个数）减一时，那么 $\operatorname{num_{l+1}}$ 就要加一。

## code,but 77pts


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
int n,a[N],cnt=1;
struct node{
    int id,num;
}e[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    e[1].num++; e[1].id=a[1];
    for(int i=2;i<=n;i++){
        if(a[i]==a[i-1]) e[cnt].num++;
        else{
            cnt++;
            e[cnt].id=a[i];
            e[cnt].num++;
        }
    }  
    int l=1,r=cnt,flag=2;
    while(r-l>1){
        e[l].num--; e[l+1].num++;
        if(e[l].num==0) l++;
        if(r-l==1){
        	flag=1;
        	break;
		}
        e[r].num--; e[r-1].num++;
        if(e[r].num==0) r--;
        if(r-l==1){
        	flag=2;
        	break;
		}
    }
    if(flag==1) cout<<"Mirko"<<'\n';
    else cout<<"Slavko"<<'\n';
    cout<<e[l].id<<" "<<e[r].id<<'\n';
    return 0;
}
```
## 改进

这种想法并没有什么问题，但是你每次模拟时一个一个去加太慢了，总时间复杂度超过了 $O(nlogn)$，导致最后两个测试点 TLE 了，但没有关系，改进的方法很简单：每次找出 $\min(\operatorname{num_l,num_r})$，遍历时就减去 $\min(\operatorname{num_l,num_r})$，省去了很多次无用的遍历，这样就可以达到 $O(nlogn)$ 的复杂度了。

## 注意事项

在 $\min(\operatorname{num_l,num_r})$ 取两种情况时要分类讨论，因为最终得出赢家的结果并不相同；在我的方法中，用一个 $\operatorname{flag}$ 变量记录赢家，它的初始值应设为 $Slavko$ 赢的值，因为题目中是 $Mirko$ 先手。

## AC code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
int n,a[N],cnt=1;
struct node{
    int id,num;
}e[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    e[1].num++; e[1].id=a[1];
    for(int i=2;i<=n;i++){
        if(a[i]==a[i-1]) e[cnt].num++;
        else{
            cnt++;
            e[cnt].id=a[i];
            e[cnt].num++;
        }
    }  
    int l=1,r=cnt,flag=2;
    while(r-l>1){
    	if(e[l].num>=e[r].num){
    		e[l].num-=e[r].num;
    		e[l+1].num+=e[r].num;
    		e[r-1].num+=e[r].num;
    		r--; if(e[l].num==0) l++;
    		if(r-l<=1){
    			flag=2;
    			break;
			}
		}
        else{
        	e[r].num-=e[l].num;
        	e[r-1].num+=e[l].num;
        	e[l+1].num+=e[l].num;
        	l++; if(e[r].num==0) r--;
        	if(r-l<=1){
        		flag=1;
        		break;
			}
		}
    }
    if(flag==1) cout<<"Mirko"<<'\n';
    else cout<<"Slavko"<<'\n';
    cout<<e[l].id<<" "<<e[r].id<<'\n';
    return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P7175 题目](https://www.luogu.com.cn/problem/P7175)

### 解题思路
记 $m$ 为 $h$ 序列中不同的值的个数。

容易想到可以把 $h$ 序列离散化成任意一个 $h_i$ 均满足 $1\le h_i\le m$ 的新序列，记新的 $h$ 序列中 $i$ 的出现次数为 $p_i$。

如果暴力模拟，时间复杂度是 $O(n^2)$ 的，我们可以将暴力中每次处理一个数优化成每次处理一类相同的数，即将原来每次处理一个最小或最大值的操作改为每次处理所有最小或最大值的操作。

简略说一下实现方法：定义最小值为 $l$，最大值为 $r$，每次操作比较 $p_l$ 与 $p_r$ 的大小，若 $p_l<p_r$，则将值为 $l$ 的数全都变为 $l+1$，将 $p_l$ 个值为 $r$ 的数变为 $r+1$，并将最小值 $l$ 增加 $1$，$p_l\ge p_r$ 时同理（以上改变数大小的操作并非真的改变 $h$ 序列中数的大小，修改 $p$ 数组的值即可）。

时间复杂度 $O(m)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int h[100001],a[100001],s[100001],w[100001],mapp[100001];
signed main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>h[i];
	sort(h+1,h+n+1);
	for(int i=1;i<=n;i++)
	{
		if(h[i]==h[i-1])
			a[i]=a[i-1];
		else
			a[i]=a[i-1]+1;
		w[a[i]]++,mapp[a[i]]=h[i];
	}
	int l=1,r=a[n];
	if(r==1)
	{
		cout<<"Slavko\n"<<h[n]<<' '<<h[n];
		return 0;
	}
	if(r==2)
	{
		cout<<"Slavko\n"<<h[1]<<' '<<h[n];
		return 0;
	}
	while(1)
	{
		if(w[l]>w[r])
		{
			w[l+1]+=w[l];
			while(1)
			{
				if(w[l]<w[r])
				{
					w[r]-=w[l],w[r-1]+=w[l];
					break;
				}
				w[l]-=w[r],w[r-1]+=w[r],r--;
				if(r-l+1<=2)
				{
					cout<<"Slavko\n"<<mapp[l]<<' '<<mapp[r];
					return 0;
				}
			}
			l++;
			if(r-l+1<=2)
			{
				cout<<"Mirko\n"<<mapp[l]<<' '<<mapp[r];
				return 0;
			}
		}
		else
		{
			w[r-1]+=w[r];
			while(1)
			{
				if(w[r]<w[l])
				{
					w[l]-=w[r],w[l+1]+=w[r];
					break;
				}
				w[r]-=w[l],w[l+1]+=w[l],l++;
				if(r-l+1<=2)
				{
					cout<<"Mirko\n"<<mapp[l]<<' '<<mapp[r];
					return 0;
				}
			}
			r--;
			if(r-l+1<=2)
			{
				cout<<"Slavko\n"<<mapp[l]<<' '<<mapp[r];
				return 0;
			}		
		}
	}
	return 0;
}
```

---

## 作者：Emily666 (赞：1)

~~（找到一道能写题解的题真不容易啊）~~


------------
看完题，第一反应就是——暴力模拟！可实际上，$n \le 10^5$，这范围，暴力肯定是要 TLE 掉的。~~本蒟蒻~~我不会离散化，所以想了个比较 easy 的做法。代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,b[N];
vector<int>a;
int main(){
	cin>>n;
	int num; 
	a.push_back(0);//占位
	for(int i=1;i<=n;i++){
		cin>>num;
		b[num]++;
		if(b[num]==1){//去重
			a.push_back(num);
		}
	}
	n=a.size()-1;
	sort(a.begin(),a.end());//排序
	while(n>3){//把小麦堆变成 n=3 的情况
		int tt=min(b[a[1]],b[a[n]]);
		b[a[n]]-=tt;
		b[a[n-1]]+=tt;
		b[a[1]]-=tt;
		b[a[2]]+=tt;//以上四行是进行“快进”操作
		if(b[a[1]]==0){//看删去了几种高度的小麦
			a.erase(a.begin()+1);
			n--;
		}
		if(b[a[n]]==0){
			a.erase(a.begin()+n);
			n--;
		}
	}//当 n<=3 时↓
	if(n>2){
		if(b[a[1]]==b[a[3]]){
			cout<<"Mirko"<<endl<<a[2]<<" "<<a[3];
		}
		else if(b[a[1]]>b[a[3]]){
			cout<<"Slavko"<<endl<<a[1]<<" "<<a[2];
		}
		else{
			cout<<"Mirko"<<endl<<a[2]<<" "<<a[3];
		}
	}
	else{
		cout<<"Slavko"<<endl<<a[1]<<" "<<a[n];
	}
	return 0;
}
```
------
### 代码解释：
- $a$：保存各个小麦的**高度**。
- $b$：保存每种高度的**小麦数**。
- $n$：当前有**几种高度**的小麦。
- `while` 循环相当于一个“快进”，把所有不是最后 $3$ 种小麦的高度值全部删去。
- 最后那个 `if` 判断：首先，如果 $n \le 2$，因为之前的循环过后还是 Mirko 先手，所以 Mirko 直接输掉了；如果 $n=3$，那么有三种情况：1. 最矮小麦的根数**等于**最高小麦的根数，Mirko 肯定赢；2. 最矮小麦的根数**大于**最高小麦的根数，Mirko 是把矮的变高，会输掉；3. 最矮小麦的根数**小于**最高小麦的根数，与第二种情况相反，Slavko 会输掉。

---

## 作者：zzwdsj (赞：1)

### 思路

直接模拟的复杂度为 $O(n^2)$，无法通过本题。考虑优化，我们只需要每次将全部最小值变成次小值，也把相应个数的最大值变成次大值或将全部最大值变成次大值，也把相应个数的最小值变成次小值。具体看最大值的个数和最小值的个数那个更小。

### 实现

使用 map 离散化，用四个迭代器分别指向最大值，次大值，最小值，次小值。每次把最大值和最小值移动相同数量给次大值和次小值。当最大值数量为 $0$ 时移动最大值和次大值；当最小值为 $0$ 时，移动最小值和次小值。复杂度 $O(n \log n)$。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>a;
int n,x,siz;//siz±íÊ¾µ±Ç°²»Í¬Êý×ÖµÄ¸öÊý£¬ÒÆ¶¯µü´úÆ÷Ê±¸üÐÂ¡£ 
string winner,loser;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	winner="Slavko\n";
	loser="Mirko\n";
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x,a[x]++;
	siz=a.size();
	if(siz<2)//siz<2Ê±ÌØÅÐ£¬²»È»22ÐÐÓÐ¿ÉÄÜRE¡£ 
	{
		cout<<winner<<a.begin()->first<<" "<<a.begin()->first;
		return 0;
	}
	auto minn=a.begin(),minm=minn,maxn=a.end(),maxm=maxn;
	maxn--;maxm--;maxm--;minm++;
	while(siz>=3)
	{
		int m=min(minn->second,maxn->second); 
		minn->second-=m,minm->second+=m;
		if(!minn->second)minn++,minm++,siz--;
		swap(winner,loser);
		if(siz<3)break;
		maxn->second-=m,maxm->second+=m;
		if(!maxn->second)maxn--,maxm--,siz--;
		swap(winner,loser);
	}
	cout<<winner;
	cout<<minn->first<<" "<<maxn->first;
	return 0;
}
```

---

## 作者：4C45 (赞：0)

## 题目分析

首先发现 $h$ 序列的顺序对结果是没有影响的。

把 $h$ 的每一项拿到桶里，则 Mirko 的操作相当于找到最小的值所在桶，拿一份放到其右边第一个不为空的桶里；Slavko 的操作相当于找到最大的值所在桶，拿一份放到其左边第一个不为空的桶里。当目前有值的桶不足三个时，接下要操作的人就输了。

于是可以分别将每一位左边和右边第一个有值的桶的位置 $pre_i$ 与 $nxt_i$ 预处理出来，同时使用 $cnt$ 记录总共的桶的数量，接下来会用到。

```cpp
int a=0,b=0;
for(int i=1,j=100000;i<=100000;i++,j--)
{
	if(w[i]!=0)
	{
		cnt++;
		pre[i]=a;
		a=i;
	}
	if(w[j]!=0)
	{
		nxt[j]=b;
		b=j;
	}
}
```

此时 $b$ 中存储了最小的桶所在位置，$a$ 则是最大的。

处理完以后判断一下 $cnt$ 是不是小于 $3$ 的，如果是就是 Slavko 胜利。

否则，循环地轮流模拟 Mirko 和 Slavko 的操作，先把当前位置的桶减 $1$，再把下一个位置的桶加 $1$，如果当前桶空了就跳到下一个桶并且 $cnt$ 减 $1$，如果 $cnt \lt 3$ 了就输出结果并退出。

以下是代码片段。

```cpp
while(1)
{
	w[b]--;
	w[nxt[b]]++;
	if(w[b]==0) cnt--,b=nxt[b];
	if(cnt<3)
	{
		cout<<"Mirko"<<endl<<b<<' '<<a;return 0;
	}
	w[a]--;
	w[pre[a]]++;
	if(w[a]==0) cnt--,a=pre[a];
	if(cnt<3)
	{
		cout<<"Slavko"<<endl<<b<<' '<<a;return 0;
	}
}
```

获得了 $77$ 分。原因是有 $V$ 个桶，每个桶最多会减去 $n$ 次，复杂度是 $\mathcal O(nV)$ 的，会超时。$V$ 为值域。

程序超时的主要原因是在每个桶最多会重复地减 $\mathcal O(n)$ 次。考虑把减的过程优化一下。发现在不使 $w_b$ 或 $w_a$ 变成 $0$ 的情况下，同时分别将其中 $x$ 份更新是对整体是没有影响的，于是我们可以在每个循环开始时分别将 $w_a , w_b$ 减去 $\min\{w_a,w_b\}-1$ 份，就可以达成上述效果。这时，每次循环都必定有左或右指针更新，所以最多循环 $\mathcal O(V)$ 次。

---

## 100pts Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,h[100080],w[100080],nxt[100080],pre[100080];
int main()
{
	int n,cnt=0,a=0,b=0;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>h[i], w[h[i]]++;
	for(int i=1,j=100000;i<=100000;i++,j--)
	{
		if(w[i]!=0)
		{
			cnt++;
			pre[i]=a;
			a=i;
		}
		if(w[j]!=0)
		{
			nxt[j]=b;
			b=j;
		}
	}
	if(cnt<3)
	{
		cout<<"Slavko"<<endl<<b<<' '<<a;
		return 0;
	}
	while(1)
	{
		int x=min(w[b],w[a])-1;
		w[b]-=x;
		w[nxt[b]]+=x;
		w[a]-=x;
		w[pre[a]]+=x; 
		w[b]--;
		w[nxt[b]]++;
		if(w[b]==0) cnt--,b=nxt[b];
		if(cnt<3)
		{
			cout<<"Mirko"<<endl<<b<<' '<<a;
			return 0;
		}
		w[a]--;
		w[pre[a]]++;
		if(w[a]==0) cnt--,a=pre[a];
		if(cnt<3)
		{
			cout<<"Slavko"<<endl<<b<<' '<<a;
			return 0;
		}
	}
} 
```

---

题外话：似乎洛谷的字体并不支持 U+0160 的 `Š` 的渲染，放出来就变成了 "Š" ，但是 U+00CA 的 `Ê` 就会变成 "Ê" 的正常上标。

---

## 作者：Manchester_City_FC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7175)

### 题目大意
现在有两个人 A 和 B 正在做一个游戏，A 先手。规则是这样的：
+ A 可以把最小的数变成次小的。
+ B 可以把最大的数变成次大的。
+ 如果剩下的数字种类小于 $3$，就输了；

输出游戏的赢家以及结束后高度的最小值与最大值。

### 解题思路
此题比较简单，大概说一下 $\mathcal O(n)$ 的思路吧。

首先把数组排序，让他们每次进行相同次的操作，要么让最小的全部变成第二小，要么让最大的全部变成第二大，这样我们可以保证我们每次至少减少一个数，总时间复杂度 $\mathcal O(n)$，足以通过本题。

### 核心代码
```cpp
while(l+3<=r){
    if(b[l]>b[r]){//减去最小的
		b[r-1]+=b[r];
		b[l+1]+=b[r];
		b[l]-=b[r];
		b[r]=0;
	}
    else{
    	b[r-1]+=b[l];
		b[l+1]+=b[l];
		b[r]-=b[l];
		b[l]=0;
	}
	if(!b[l]) l++;
    if(!b[r]) r--;
}
```

---

## 作者：fly_x (赞：0)

## 题面
传送门：[P7175 PŠENICA](https://www.luogu.com.cn/problem/P7175)

有两个人，简称为小 M 和小 C。

小 M 可以把**最小**的数变成**次小**的；

小 C 可以把**最大**的数变成**次大**的；

小 M 先手，如果剩下的数字**种类**小于 $3$，就**输**了；

输出**赢家**的名字和此时剩下的数字。
## 解法
### 第一眼
**模拟**：时间复杂度约为 $O(n^2)$，而 $1\le n \le 1 \times 10^5$，会 TLE。
### 个人解法
暴力会挂，考虑优化。

观察到，一个个进行操作常数比较大，所以可以合并相同的数，一起进行操作。

**离散化**：观察到 $1\le h_i \le 1 \times 10^5$，不是很大，可以使用桶存储数列，存储同时可以进行排序和合并操作。

**前缀和**：可以存储已经操作到的数字序号，查询时能够跳过未读入的数字，加快查询。

**双指针**：分别表示小 M 和小 C，比较两端大小决定谁来行动。

这样的话时间复杂度为 $O(H)$（$H$ 为不同数字个数）。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
int n, x, a[N], s[N];
// a 为桶，s 为前缀和
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &x);
		a[x]++;
	} x = 0;
    // 读入
	for (int i = 1; i <= N-5; i++)
		if (a[i]) s[++x] = a[i], s[x] += s[x-1];
    // 计算前缀和
	int l = 1, r = x, ls = 0, rs = 0; bool flag = 1;
    // l 是 小M 当前操作的数字序号，r 同理
    // ls 是 小M 已操作的数字个数，rs 同理
    // flag 用来存储输家
	while (l + 1 < r){
		if (ls + s[l] <= rs + (s[x] - s[r-1]))
			ls += s[l++], flag = 0;
		else rs += s[x]-s[(r--)-1], flag = 1;
	}
	if (flag) printf("Slavko"); else printf("Mirko");
	puts(""); x = 0, flag = 0;
	for (int i = 1; i <= N-5; i++){
		if (a[i]) ++x;
		if (x == l && !flag){
			printf("%d", i);
			flag = 1;
		}
		if (x == r){
			printf(" %d", i);
			break;
		}
        // 查询 s[l] 和 s[r] 代表的数字
	}
	return 0;
}

```

---

## 作者：wht_1218 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7175)

---

暴力 $O(n^2)~/~O(n^2\log n)$ 很简单，我们要思考如何优化为 $O(n\log n)$。

可以先把数组排序（好像暴力也要这样吧），考虑如何快速操作。

我们知道：只要不同高度的个数 $\ge3$，就要继续，互不干扰。

所以，每次让他们尽可能一样即可，多的量减去少的，少的不变，每次忽略一个数，总共 $\le n$ 次。

代码就不给了~~别人题解都有~~。

---

## 作者：indream (赞：0)

# P7175 [COCI2014-2015#4] PŠENICA 题解
[P7175 PŠENICA](https://www.luogu.com.cn/problem/P7175) | [AC 记录](https://www.luogu.com.cn/record/130365231)

## 声明
参考了 [@Emily666](https://www.luogu.com.cn/user/978088) 的[题解](https://www.luogu.com.cn/blog/pai-lover-314/solution-p7175)。

编程语言为 C++。

**请大家不要原样照抄题解。**

## 思路
$1\times 10^5$ 的数据范围一个个枚举肯定会 TLE，每次模拟后再排序一次的时间复杂度太可怕了：$O(n^2 \log n)$（这里的 $n$ 是指小麦根数）。

所以，这题必须优化。题解里几位大佬用了离散化，最少也用了动态数组，蒟蒻纯模拟，适合初学者，大佬请绕路。

思路比较简单 ~~不然怎么是黄题~~，将修改高度的过程“加速”——将多次改变相同高度的小麦高变为一次全部改好（详见代码），当然得提前排序。快排（`sort()`）的时间复杂度为 $O(n \log n)$（$n$ 指小麦根数），模拟的时间复杂度为 $O(n)$（$n$ 指小麦按高度分的种类）。

我开的普通整型数组，一看空间只有 32MB，怕 MLE 就没有开新数组放去重后内容，因为每跟小麦的高度并不需要再用，而且用 STL 里的 `unique()` 也很方便。~~但是事实上我再开个 1E5 的 int 数组也一共才用掉理论上约 1.2MB 空间（当时实在懒得算了）。~~ 

## 代码

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int cnt[100005],h[100005];
//cnt[i]记录高度为i的小麦数,h[i]记录第i个小麦的高度
int main(){
	int n;
	ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>h[i];
		cnt[h[i]]++;//计数
	}
	sort(h,h+n);
	n=unique(h,h+n)-h;//将n覆写为小麦种类数
	int tmp,left=0,right=n-1;
  //tmp暂存数据，方便编写；left左指针，right右指针
	while(n>3){
      //判断条件如果使n>=3则可能会出现上一步n=3，下一步n=1的情况，所以需要特判
      //将一（或两）种小麦全部改变高度
		tmp=min(cnt[h[left]],cnt[h[right]]);
      //一次“加速”最多能改变的小麦个数
		cnt[h[left]]-=tmp;
		cnt[h[left+1]]+=tmp;
		cnt[h[right]]-=tmp;
		cnt[h[right-1]]+=tmp;
      //不同高度的小麦数量变化
      //h[left],h[right]无需替换，因为后面用不着了
		if(cnt[h[right]]==0){//右边没了
			n--;//种类数-1
			right--;//右指针左移
		}
		if(cnt[h[left]]==0){//左边没了
			n--;//种类数-1
			left++;//左指针右移
		}
	}
	if(n==3){
		if(cnt[h[left]]==cnt[h[right]]){
         //左右数量相等，Mirko先取，Mirko会先一步改完他的小麦
         //此时Mirko把left位置的高度全改为了left+1的高度，right位置小麦只剩一根高度未改
			cout<<"Mirko\n";
			cout<<h[left+1]<<' '<<h[right];
		}
		else if(cnt[h[left]]>cnt[h[right]]){
         //左边比右边多，故Slavko会先改完他的小麦
         //现在left位置未被Mirko改完，right位置的高度全被改成right-1位置的高度
        cout<<"Slavko\n";
			cout<<h[left]<<' '<<h[right-1];
		}
		else{
         //左边比右边少，故Mirko先改完他的小麦
         //这时left的小麦高度被改为了left+1位置的高度，right位仍未改完
			cout<<"Mirko\n";
			cout<<h[left+1]<<' '<<h[right];
		}
	}else{
      //n=2（或1）时，上轮Slavko改完，Mirko无法再改
      //此次所有小麦高度没有变化
		cout<<"Slavko\n";
		cout<<h[left]<<' '<<h[right];
	}
	return 0;
}
```

---

## 作者：VIOLET__FOREVER (赞：0)

### 题目分析
#### $50pts:$  
瞎搞就行  
#### $80pts$  
大家看到这道题，肯定第一想法是直接暴力去模拟，就是左边一个右边一个然后算到只剩两个，自以为这个复杂度是线性的，然后就会拿到 $80$ 分的好成绩，因为你每模拟一个数，到了下一个数，这个数还要再被模拟一次，这样复杂度就会退化到平方级这样的话 $10^5$ 的数据就妥妥的超时了  
#### $100pts$  
正解就是在 $80$ 分的代码上进行优化，如果我们每次按照,这个数拥有的个数去模拟的话，就可以把模拟次数控制在线性，但是这样的话，一边模拟一边计算胜利者很麻烦，所以我们到最后进行一下特判首先，如果 
$n\leq2$，因为之前的循环过后还是 `Mirko` 先手，所以 `Mirko` 直接输掉了；如果 $n=3$，那么有三种情况：
1. 最矮小麦的根数等于最高小麦的根数，`Mirko` 是先手，所以 `Mirko` 获胜；
2. 最矮小麦的根数大于最高小麦的根数，`Slavko` 会先取完，所以 `Slavko` 获胜
3. 最矮小麦的根数小于最高小麦的根数，与第二种情况相反，`Slavko` 会输掉。

### std
```cpp
#include<bits/stdc++.h>
#define int long long 

const int N=100005;

using namespace std;

int n,m;
int a[N],cnt[N];//a是记录小麦高度的种类，cnt是记录每种高度的小麦根数

signed main(){
    cin>>m;
    for(int i=1;i<=m;i++){
        int num;
        cin>>num;
        if(!cnt[num]) a[++n]=num;//防止a中出现重复
        cnt[num]++;
    }
    sort(a+1,a+1+n);//对所有的高度要先进行排序，保证其单调性
    int l=1,r=n;
    while(n>3){/*小于等于3的时候就可以退出进行特判*/
        if(cnt[a[l]]>cnt[a[r]]){
            cnt[a[l]]-=cnt[a[r]];//多的要减去少的，少的不变，因为下面还要用到
            cnt[a[l+1]]+=cnt[a[r]];
            cnt[a[r-1]]+=cnt[a[r]];
            r--,n--;
        }
        else if(cnt[a[l]]<cnt[a[r]]){
            cnt[a[r]]-=cnt[a[l]];
            cnt[a[l+1]]+=cnt[a[l]];
            cnt[a[r-1]]+=cnt[a[l]];
            l++,n--;
        }
        else{
            cnt[a[l+1]]+=cnt[a[l]];
            cnt[a[r-1]]+=cnt[a[r]];
            l++,r--;
            n-=2;
        }
    }
    if(n<=2) cout<<"Slavko"<<endl<<a[l]<<" "<<a[r];
    else{
        if(cnt[a[l]]>cnt[a[r]]) cout<<"Slavko"<<endl<<a[l]<<" "<<a[l+1];
        else cout<<"Mirko"<<endl<<a[r-1]<<" "<<a[r];
    }//按照题目给出的三种情况进行分类讨论
    return 0;
}
```

---

## 作者：NBest (赞：0)

如果你一个一个模拟的删，最后一个一个地都到中间去了，复杂度是 $O(n^2)$ 的，我们发现这个过程肯定是有重复计算的。

注意到，Mirko 的操作是让最小的变第二小，Slavko 是让最大的变第二大，也就是在数量小于 $3$ 之前他们的操作都是互不影响的，所以我们不妨考虑让他们每次进行相同次的操作，要么让最小的全部变成第二小，要么让最大的全部变成第二大，这样我们可以保证我们每次至少减少一个数，复杂度 $O(n)$，考虑到 $h\le10^5$，我们直接桶排就行了。

具体细节不妨看代码:
## $Code$
```cpp
int n,a[200005],cnt,trans[200005],b[200005];
int main(){
    n=read();
    for(int i=1;i<=n;i++)++a[read()];
    for(int i=0;i<=200000;i++){
        if(a[i])b[++cnt]=a[i],trans[cnt]=i;//记录
    }
    int l=1,r=cnt;
    while(r-l>=3){//如果个数大于4就一直进行减少操作
        if(b[l]>b[r])b[r-1]+=b[r],b[l+1]+=b[r],b[l]-=b[r],b[r]=0;//减去最小的
        else b[r-1]+=b[l],b[l+1]+=b[l],b[r]-=b[l],b[l]=0;
        if(!b[l])l++;//如果没了就移动指针
        if(!b[r])r--;
    }
    if(r-l<2)printf("Slavko\n%d %d",trans[l],trans[r]);//这里不仅是考虑了一开始长度就小于3的清况
    //还有因为长度等于四而两边相等然后减掉后只剩下两个的情况
    //所以答案显然是 Slavko 胜利
    else{//长度为 3 时
        if(b[l]<=b[r])puts("Mirko"),l++;//取等时因为Mirko是先手，所以胜利
        else puts("Slavko"),r--;
        printf("%d %d",trans[l],trans[r]);
    }
}
```

---


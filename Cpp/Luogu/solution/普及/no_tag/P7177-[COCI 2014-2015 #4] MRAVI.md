# [COCI 2014/2015 #4] MRAVI

## 题目描述

Bobi 每天早上起床喂他最喜欢的宠物：蚂蚁。他把它们放在一个有管道系统的玻璃瓶中，管道系统可以表示为一棵有 $n$ 个节点的树。管道用树的边缘表示。树的根位于用 $1$ 表示的节点上。在管道系统内部，由于重力的作用，液体从节点流向其子节点。我们知道每个管道的流量 $x_i$：从父节点到子节点的流量百分比。让我们观察以下示例：

![](https://cdn.luogu.com.cn/upload/image_hosting/oi3ubdfd.png)

图片中的节点 $1$ 有 $12$ 升液体，之后有两个管道。一个的流量是 $x_i=30$，另一个是 $x_i=70$。节点 $2$ 将得到 $3.6$ 升，节点 $3$ 得到 $8.4$ 升。在输入数据中，来自同一节点的管道流量之和始终等于 $100$。Bobi 的一些管子不只是普通的管子，它们有点奇怪。它们是超级管道，有超能力将流经它们的液体流量平方。在前面的例子中，如果第一个管道有超能力，节点 $2$ 得到 $12.96$ 升，节点 $3$ 仍然只有 $8.4$ 升。现在请注意，一个节点的流出液体比进入的液体多。这正是这些管道是超级管道的原因！

所有的超级管道都可以由波比开启或关闭。蚂蚁只生活在树的叶子里（没有孩子的节点）。对于每一片叶子，我们知道需要多少液体来喂养生活在叶子里的蚂蚁。Bobi 想把 $L$ 升液体倒进树根里喂蚂蚁。他没有多少钱，所以他想知道他需要购买的最低液体量，以保证所有蚂蚁的饲料。

## 说明/提示

#### 样例 1 说明

如果 Bobi 向根节点中注入 $8$ 升液体，节点 $3$ 得到 $4$ 升，节点 $4$ 得到 $1$ 升，节点 $5$ 得到 $9$ 升。这些节点是叶子（其中有蚂蚁）中蚂蚁需要得到的最小数量。所以，$8$ 升是满足“蚂蚁”条件的最低液体量。

#### 数据规模与约定

对于 $100\%$ 的数据，都有 $1\le n\le 10^3$，$1\le a_i,b_i\le n$，$1\le x_i\le 100$，$t_i\in\{0,1\}$，$k_i\in[1,10]$。

**数据保证 $L$ 的值不超过 $2\times 10^9$。**

#### 说明

**题目译自 [COCI2014-2015 CONTEST #4](https://hsin.hr/coci/archive/2014_2015/contest4_tasks.pdf) _T4 MRAVI_。**

## 样例 #1

### 输入

```
5
1 2 50 0
1 3 50 0
2 4 25 0
2 5 75 1
-1 -1 4 1 9```

### 输出

```
8.00```

## 样例 #2

### 输入

```
3
1 2 20 1
1 3 80 1
-1 4 8```

### 输出

```
10.0000```

## 样例 #3

### 输入

```
6
1 2 100 1
2 3 20 0
2 4 20 0
2 5 60 0
4 6 100 1
-1 -1 1 -1 1 2```

### 输出

```
2.659```

# 题解

## 作者：Graphcity (赞：4)

本题第一篇题解！

## 思路

很明显，如果最初添加的液体越多，蚂蚁们得到的液体也会越多，所以可以 **二分答案** 。

模拟倒液体的过程可以用 dfs 解决，存储边的时候只需要多添加是不是超级管道和通过液体的百分比这两个信息就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=1000;

inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while(ch>'9' || ch<'0')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

struct Node
{
    int to,nxt,opt;
    double w;
} Edge[Maxn*2+5];
int tot,Head[Maxn+5];

inline void Addedge(int x,int y,int z,int opt)
{
    Edge[++tot]=(Node){y,Head[x],opt,z/100.0};
    Head[x]=tot;
}

int n;
double val[Maxn+5],k[Maxn+5];
// val: 每个点的流量

inline void dfs(int x,int f)
{
    for(register int i=Head[x];i;i=Edge[i].nxt)
    {
        int y=Edge[i].to; double res=0;
        if(y==f) continue;
        res=val[x]*Edge[i].w;
        if(Edge[i].opt) res*=res;
        val[y]+=res;
        dfs(y,x);
    }
}
inline int Check(double mid) // 二分的判断
{
    for(register int i=1;i<=n;++i)
        val[i]=0;
    val[1]=mid,dfs(1,0);
    for(register int i=1;i<=n;++i)
        if(val[i]<k[i]) return 0;
    return 1;
}

int main()
{
    n=read();
    for(register int i=1;i<n;++i)
    {
        int a=read(),b=read(),c=read(),d=read();
        Addedge(a,b,c,d),Addedge(b,a,c,d);
    }
    for(register int i=1;i<=n;++i)
        k[i]=read()*1.0;
    double l=0,r=1e9;
    for(register int i=1;i<=50;++i)
    {
        double mid=(l+r)/2;
        if(Check(mid)) r=mid;
        else l=mid;
    }
    printf("%.5lf",l);
    return 0;
}
```

---

## 作者：LSY_33 (赞：3)

这道题是我随机跳题跳到的，没什么技术含量却卡了我整整一个下午，发篇题解纪念一下，另外这是本人第一次发题解，如有问题还请指出。
# Part1 思路
首先我们很容易就能看出每个叶子节点能收到的液体和倒入的液体是成正比的，答案满足所谓**单调性**，那么就可以用**二分答案**来求解。

大体思路很简单，可是 **check** 函数怎么写呢？

我们可以使用 **DFS**，把每个叶子节点能获得的液体求出来，再和 $k_i$ 做比较，就可以了。

# Part2 代码实现
## 2-1 前置工作
我们首先要存树，我这里用的是**链式前向星**，不过多讲解，直接上代码（**该开 double 记得开**）：

```cpp
struct edge
{
	int to, pre, opt;//opt表示是否是超级管道 
	double dis;//边权，即题中的流量 
}e[maxn << 1];//因为不知道父子关系，所以要存双向边,开二倍数组
int head[maxn], cnt;

void add(int u, int v, double w, int t)//分别对应 a,b,x,t
{//这里不细讲了 
	cnt++;
	e[cnt].to = v;
	e[cnt].dis = w;
	e[cnt].opt = t;
	e[cnt].pre = head[u];
	head[u] = cnt;
}
```
然后是输入部分，很简单，**但要注意细节**，**尤其注意不能在输入时直接将流量百分比 $x_i$ 做平方**再存储，DFS时直接使用，
因为题目是这么说的：

“它们是超级管道，有超能力**将流经它们的液体流量平方**”

所以要用边的流量百分比 $x_i$ 乘上 DFS 时父节点的液体量来求子节点

代码：

```cpp
scanf("%d", &n);
int a, b, t;
double x;
for(int i = 1; i < n; i++)//注意只有n-1条边 
{
	scanf("%d%d%lf%d", &a, &b, &x, &t); 
	add(a, b, x / 100, t);//上面提到的双向边 
	add(b, a, x / 100, t); 
}
for(int i = 1; i <= n; i++)
{
	scanf("%lf", &k[i]);//double要用lf输入，scanf要加 &（我会告诉你我因为没加 & 卡了一个小时？） 
}

```
## 2-2 二分答案

因为是在实数域进行二分，所以代码和整数的不太一样。

我们首先定义 $eps=1\times 10^{-6}$ 作为我们允许的误差值，一般来说我们要把这个误差设定为题目要求的**平方倍**，这样比较保险（其实对于这个题可以和题目要求精度相同）。
```cpp
const double eps = 1e-3; 
```
然后是改进过后的二分答案：
```cpp
double l = 0;
double r = 2e9; //这里上界为题目要求L的最大值
while(l + eps < r) //eps是这么用的
{
	double mid = (l + r) / 2;
	if(check(mid)) r = mid; //如果当前答案合法，继续寻找更小的答案（更优解）
	else l = mid;//注意：这里不用-1或+1
}
```
## 2-3 DFS+check（重点）

对于 **DFS**，我们就按一般的图的深度优先遍历写就行。不过我们可以很容易地发现只要有**一个**叶子节点接收到的液体不够（即$<k$）那么我们二分得来的答案就不合法，这样就可以写出一个剪枝。我们定义布尔变量 $f$ 来记录当前答案是否合法，先在 `check()` 函数内将 $f$ 初始化为 $1$ ,然后开始DFS,过程中**只要发现一个叶子节点接收到的液体不够**，就将 $f$ 赋值为 $0$ 然后不由分说往外跳就可以了。用一个 $vis$ 数组记录当前节点是否被搜过，这里不需要把数组在回溯时重新赋值为 $0$，因为这并不影响我们遍历整个图，但也可以写。

下面给出 DFS 和 check 的代码：
```cpp
bool f;
bool vis[maxn];
void dfs(int u, double w) //点的编号，当前节点的液体量 
{
	if(!f) return; //这里就是剪枝了 
	if(k[u] != -1) //判断是否为叶子节点 
	{
		if(w < k[u]) f = 0; //赋值 
		return;//搜到叶子直接返回 
	}
	for(int i = head[u]; i; i = e[i].pre) //遍历每条边 
	{
		int to = e[i].to;
		double d = e[i].dis;
		if(vis[to] == 0) //防止重复搜 
		{
			vis[to] = 1;
			if(e[i].opt) dfs(to, (w * d) * (w * d)); //特判超级管道 
			else dfs(to, w * d);
			if(!f) return; //剪枝×2
		}
	}
}

bool check(double x)
{
	f = 1;
	memset(vis, 0, sizeof(vis));
	vis[1] = 1;//记着起点也要做标记，（我会告诉你我因为没有把1做标记卡了两个小时吗？） 
	dfs(1, x);
	if(f) return true;//直接 return f 更精简 
	return false;
}
```
讲解就到此为止，下面上总代码：
```cpp
#include<bits/stdc++.h>

#define maxn 1010

using namespace std;

const double eps = 1e-3; 

int n;
double k[maxn];
double ans;

struct edge
{
	int to, pre, opt;
	double dis;
}e[maxn << 1];
int head[maxn], cnt;

void add(int u, int v, double w, int t)
{
	cnt++;
	e[cnt].to = v;
	e[cnt].dis = w;
	e[cnt].opt = t;
	e[cnt].pre = head[u];
	head[u] = cnt;
}

bool f;
bool vis[maxn];
void dfs(int u, double w)
{
	if(!f) return;
	if(k[u] != -1)
	{
		if(w < k[u]) f = 0;
		return; 
	}
	for(int i = head[u]; i; i = e[i].pre)
	{
		int to = e[i].to;
		double d = e[i].dis;
		if(vis[to] == 0)
		{
			vis[to] = 1;
			if(e[i].opt) dfs(to, (w * d) * (w * d));
			else dfs(to, w * d);
			if(!f) return;
		}
	}
}

bool check(double x)
{
	f = 1;
	memset(vis, 0, sizeof(vis));
	vis[1] = 1;
	dfs(1, x);
	if(f) return true;
	return false;
}


int main()
{
	scanf("%d", &n);
	int a, b, t;
	double x;
	for(int i = 1; i < n; i++)
	{
		scanf("%d%d%lf%d", &a, &b, &x, &t); 
		add(a, b, x / 100, t);
		add(b, a, x / 100, t); 
	}
	for(int i = 1; i <= n; i++)
	{
		scanf("%lf", &k[i]);
	}
	double l = 0;
	double r = 2e9;
	while(l + eps < r)
	{
		double mid = (l + r) / 2;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%.5lf", r); //要用printf
	return 0; //结束罪恶的一生~~
} 
```
**最后一点**，输出要用 `printf` 而不是 `cout`，因为后者**精度不够**，会WA。

---

## 作者：fz20181223 (赞：2)

看到仅有的题解竟然是二分？？！不得不提交一个递推的题解了。

思路如下：

编写一个函数 $\operatorname{solve}$ ，其中 $\operatorname{solve}(i)$ 返回满足题目条件时，第 $i$ 个节点最少要有多少液体。

对于每个节点 $i$ ，如果它是个叶子节点，则直接返回当前节点需要的液体数，即 $\operatorname{solve}(i) \gets k_i$。

如果它不是叶子节点，则遍历其所有叶子节点，对于每个 $i$ 的叶子节点 $v$，递推出当前节点最少的液体量以满足 $\operatorname{solve}(v)$ 的值。所有取得的值中最大的值就是当前节点需要的液体量（因为它只是给了一个最低限制，而最后分配给每个叶子节点的液体量可以无限大）。由于数学公式过于复杂，此处暂不展示。

最后从 $1$ 这个根节点开始遍历就行。

说句闲话：记得开 double！

于是有了下面的 AC 代码（不要抄！）
```cpp
#include<bits/stdc++.h>
#define mset(a,x) memset(a,x,sizeof(a))
using namespace std;
const int err=-120712^7869^12174,uerr=0x3f3f3f3f,eps=1e-9,N=1009;
int n,cnt,head[N],need[N];
struct edge{
	int u,v,p,nxt;bool s;
}e[N];
void addedge(int u,int v,int p,int s){
	e[cnt].u=u,e[cnt].v=v,e[cnt].p=p,e[cnt].s=s,e[cnt].nxt=head[u],head[u]=cnt++; 
}
double dfs(int cur){
	if(~need[cur]){//等价于need[cur]==-1
//	printf("%d->%.4lf\n",cur,need[cur]*1.0);
		return need[cur];
	}
	double ret=0;
	for(int i=head[cur];~i;i=e[i].nxt){
		double tmp=dfs(e[i].v);
		if(e[i].s) tmp=sqrt(tmp);//如果是超级管道递推需要取平方根，因为原来取了平方
		tmp=tmp/e[i].p*100;
		ret=max(ret,tmp);
	}
//	printf("%d->%.4lf\n",cur,ret);
	return ret;
}
int main(){
	scanf("%d",&n);
	mset(head,-1);
	for(int i=1,u,v,w,p;i<n;++i){
		scanf("%d %d %d %d",&u,&v,&w,&p);
		addedge(u,v,w,p);
	}
	for(int i=1;i<=n;++i) scanf("%d",need+i);
	printf("%.4lf",dfs(1));
	return 0;}
```

---

## 作者：封禁用户 (赞：1)

这道题目，怎么说呢，~~有点难度（对于我这个蒟蒻来说）~~，用 dfs 即可。

**题目大意**：整棵树的每条边都有流量的分配比率，部分边有“特殊性质”——将流经这条边的液体的流量平方。现在给出每个叶子节点最终至少要流入的流量，求根节点至少要流出的流量是多少。

很明显，如果最初添加的液体越多，蚂蚁们得到的液体也会越多，所以可以 **二分答案** 。

二分答案改进后代码如下：

```cpp
double l = 0;
double r = 2e9; //这里上界为题目要求L的最大值
while(l + eps < r) //eps是这么用的
{
	double mid = (l + r) / 2;
	if(check(mid)) r = mid; //如果当前答案合法，继续寻找更小的答案（更优解）
	else l = mid;//注意：这里不用-1或+1
}
```


模拟倒液体的过程可以用 dfs 解决，存储边的时候只需要多添加是不是超级管道和通过液体的百分比这两个信息就行了。



---

## 作者：Ifyoung (赞：1)

[$\Large \text{题目链接}$](https://www.luogu.com.cn/problem/P7177)

# 题目大意

整棵树的每条边都有流量的分配比率，部分边有“特殊性质”——将流经这条边的液体的流量平方。

现在给出每个叶子节点最终至少要流入的流量，求根节点至少要流出的流量是多少。

# 思路

为了叙述方便，下面将某个节点最少需要的 **流量** 称为该节点的“**权值**”。

首先我想到了一个类似于 **解决普通数学问题** 的做法：

将 **答案**，即 **根节点的权值**，设为 $x$，然后按照数据给出的要求，**向叶子节点方向** 一步一步进行 **运算**，最终得到每个叶子节点的用 $x$ 表示的权值，但我们 **只关心每个叶子节点的**，题目中又给出了每个叶子节点的应有的权值，那么综合上述两个条件就可以 **解方程**（当然只取正数解）。下一步是从叶子节点向上 **回溯** 至根，将解得的结果与其 **兄弟** 进行比较，其父节点的权值取其所有子节点的权值中的 **最大值**，一直这样操作到根节点。那么得到的根节点的权值就是最终的答案。

用此方法模拟一下样例 $2$：

![](https://s1.ax1x.com/2023/09/12/pP2krkR.png)

那么就可以得到两个方程：

$$\frac {x^2}{25} \geqslant 4$$

$$\frac{16x^2}{25} \geqslant 8$$

第一个方程解得 $x \geqslant 10$，第二个方程解得 $x \geqslant \sqrt {12.5}$。

取这两个节点的权值中最大的成为 $1$ 号节点的权值，即 $x=10$，所以答案就为 $10.00000$。

但是上述方法的弊端也很明显，那就是不能轻松地带着 $x$ 的一堆 **系数** 和 **几次幂** 的信息“到处走”。

感觉后半部分从叶子节点向上 **回溯同时进行统计** 这个过程是没问题的，可以通过 **DFS** 来实现，那接下来考虑怎么得到叶子节点的 **权值**。

其实很简单，因为数据已经给出来了，所以直接进行 **DFS**，如果搜到叶子节点就可以通过 **简单的处理** 直接得到该节点的权值：

如果连接叶子节点及其父节点的边有“特殊性质”的话，那么就将输入数据中给出的权值开方，否则就不变。

最后带这个信息，按照上面叙述的步骤，向根节点回溯即可。

# 实现

从根节点向下 **DFS**，如果搜到了 **叶子节点**，就处理该点权值，并返回给父节点，否则继续向下搜索。

回溯时，将一个节点 **向其每一个子节点搜索的返回值** 取 **最大值** 后返回。

**细节**：

1. 题目中说了 $1$ 号点是根节点，但是不知道 $1$ 号点的子节点都有哪些，无法开启搜索，所以钦定 $0$ 号点为 $1$ 号点的根节点，并由此开始搜索。

2. 过程中有关计算的变量都定义为 `double` 类型，最后输出时保留到小数点后 $5$ 位（一般比题目要求多两位，这样做即可保证精度）。

$\Large Code$

```cpp
#include <bits/stdc++.h>
using namespace std;

int read() {
	int x = 0, w = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') w = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch ^ '0');
		ch = getchar(); 
	}
	return x * w;
}

void write(int x) {
	if (x < 0) {
		x = -x;
		putchar('-');
	}
	if (x > 9) write(x / 10);
	putchar(x % 10 ^ '0');
}

const int N = 1010;

int n;
int h[N], tot;
double w[N]; // 输入的每个点的权值

struct edge {
	int to, nxt, x, t; // x，t 的含义与题目中的相同
} e[N << 1];

void add(int u, int v, int x, int t) {
	e[ ++ tot] = (edge) {v, h[u], x, t};
	h[u] = tot;
}

double dfs(int u, int fa, int x, int t) {
	if (w[u] != -1) { // 如果搜到的点的权值不是 -1，说明这个点是叶子节点
		if (t) w[u] = sqrt(w[u] * 1.0); // 如果连接这个叶子节点的边有“特殊性质”，就开方
		return w[u] * 1.0 / (x * 1.0 / 100); // 将该点的权值除以分配到的比率，返回
	}
	double res = -1; // 为取最大值做准备
	for (int i = h[u]; i; i = e[i].nxt) {
		int j = e[i].to;
		if (j == fa) continue; // 如果又遍历到其父节点，就跳过，否则会陷入死循环
		res = max(res, dfs(j, u, e[i].x, e[i].t)); // 对这个点的所有儿子的返回值取最大值
	}
	if (t) res = sqrt(res * 1.0); // 如果连接当前点与其父节点的边有“特殊性质”，就开方
	return res * 1.0 / (x * 1.0 / 100); // 类比于叶子节点，将该点的权值除以分配到的比率
}

int main() {
	n = read();
	add(0, 1, 100, 0), add(1, 0, 100, 0); // 加两条 1 号点和 0 号点之间的边（双向边）
	for (int i = 1; i < n; i ++ ) {
		int u = read(), v = read(), x = read(), t = read();
		add(u, v, x, t), add(v, u, x, t);
	}
	for (int i = 1; i <= n; i ++ ) w[i] = read();
	printf("%.5lf\n", dfs(1, 0, 100, 0)); // 直接输出搜索的结果
	return 0;
}
```

---

## 作者：望月野QwQ (赞：1)

# 1.题意分析

看到体面的时候，下意识王网络流去想了。但是我们回过头来看，这很明显就是 搜索 + 二分了。

### 遍历：

很明显，对于所有数据都有 $n \le 10^3$ 而且对于所有的叶节点我们都需要遍历到，故不存在剪枝情况，老老实实的搜索吧，搜索方式就是遍历每一条边直到叶节点，每次处理遍历到一个节点的同时处理往下方节点流入的流量。

细节请看代码。

对于搜索方式，我们使用 dfs 或者 bfs 都是可以的。

### 二分：

同时，根据题意我们很容易发现当 $1$ 节点（即根节点）的值越大的时候，下面叶子结点的值也会变大，也就是说答案具有单调性，这时我们就选择使用二分来寻找答案。

不过，因为答案是一个浮点型的数据，所以二分答案的时候要注意控制精度。如下，定义 $ctrl=1e-8$ 就是为了控制精度二设置的。
```cpp
	double l=0,r=1e9,ctrl=1e-8;
	while(l+ctrl<r) //二分
	{
		double mid=(l+r)/2.0;
		if(dfs(1,mid))r=mid;
		else l=mid;
	}
```



# 2.代码

## dfs

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
struct edge
{
	double to,next,w;
	double t;
}l[1000005];
double a[1000006];
int head[1000005],cnt=0;
bool dfs(int now,double res) //搜索
{
	if(!head[now])
	{
		if(res>=a[now])
		{
			return true;
		}
		else return false;
	}
	for(int i=head[now];i;i=l[i].next)
	{
		double fl=res*l[i].w;
		if(l[i].t)
		{
			if(!dfs(l[i].to,fl*fl))
			{
				return false;
			}
		}
		else if(!dfs(l[i].to,fl))
		{
			return false;
		}
	}
	return true;;
}
void add(int from,int to,double w,double t) //链式前向星建图
{
	cnt++;
	l[cnt].to=to;
	l[cnt].t=t;
	l[cnt].w=w/100.0; //先行处理每段水管能运送的百分比
	l[cnt].next=head[from];
	head[from]=cnt;
}
double n;
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		double a,b,c,t;
		cin>>a>>b>>c>>t;
		add(a,b,c,t);
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	double l=0,r=1e9,ctrl=1e-8;
	while(l+ctrl<r) //二分
	{
		double mid=(l+r)/2.0;
		if(dfs(1,mid))r=mid;
		else l=mid;
	}
	printf("%.5lf",l);
	return 0;
}
```

## bfs
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
struct edge
{
	int to,next;
	double w;
	double t;
}l[1000005];
double a[1000006];
int head[1000005],cnt=0;
bool bfs(double mid) 
{
	queue<int>q;
	queue<double>val;
	q.push(1);
	val.push(mid);
	while(!q.empty())
	{
		int now=q.front();
		double res=val.front();
		val.pop();
		q.pop();
		if(a[now]>res)
		{
			return false;
		}
		for(int i=head[now];i;i=l[i].next)
		{
			
			double tmp=res*l[i].w;
			if(l[i].t==1)tmp=pow(tmp,2);
			val.push(tmp);
			q.push(l[i].to);
		}
	}
	return true;
}
void add(int from,int to,double w,double t)
{
	cnt++;
	l[cnt].to=to;
	l[cnt].t=t;
	l[cnt].w=w/100.0;
	l[cnt].next=head[from];
	head[from]=cnt;
}
double n;
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		double a,b,c,t;
		cin>>a>>b>>c>>t;
		add(a,b,c,t);
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	double l=0,r=1e9,ctrl=1e-8;
	while(l+ctrl<r)
	{
		double mid=(l+r)/2.0;
		if(bfs(mid))r=mid;
		else l=mid;
	}
	printf("%.5lf",l);
	return 0;
}
```

# 3. 注意细节&小小的emo

最后的输出要用`printf("%.5lf",l);`，因为`cout` 直接输出的精度不够，导致我被卡了好久 :(。

---

## 作者：YuYuanPQ (赞：0)

发现题目要求的有“最低”这个要求，结合题意易得：比答案大的液体量一定满足条件，因为刚开始给的越多，蚂蚁得到的就越多。所以可以二分 $L$。

数据范围小，用 DFS 直接模拟液体流的过程即可。\
注意：若 $t_{x,y}=1$，也就是可以开启超级管道，我们需要判断流到这里的液体量是否 $>1$ 再使用（因为平方对 $>1$ 的数而言是更大，反之则浪费液体）。

时间复杂度大概为 $\mathcal{O}(n\log V)$，且跑不满。

## Code
```cpp
#include<bits/stdc++.h>

typedef int IT;
typedef long long LL;
typedef __int128 int128;
typedef double DB;
typedef long double LDB;

#define pb push_back
#define fst first
#define sec second
#define psh push
#define mkp make_pair
#define PII pair<IT,IT>
#define PLI pair<LL,IT>
#define lowbit(x) ((x)&(-x))

using namespace std;

const int N=1e3+10,ES=N;
const DB eps=1e-3;

int n;
int k[N];

int ecnt,head[N],nxt[ES],to[ES];
DB val[ES];
bool abl[ES];// ability
void add(int x,int y,DB liul,bool t){// liuliang
    nxt[++ecnt]=head[x];
    head[x]=ecnt;
    to[ecnt]=y;
    val[ecnt]=liul;
    abl[ecnt]=t;
    return;
}

DB L;
bool ok;
bool dfs(int x,DB tot){
    if(k[x]!=-1){
        if(tot<k[x]) return 0;
        return 1;
    }
    bool fg=1;
    for(int i=head[x];i&&fg;i=nxt[i]){
        int y=to[i];
        DB liul=val[i];
        DB cos=liul*tot;
        bool t=abl[i];
        if(t){
            if(cos>1){
                fg&=dfs(y,cos*cos);
            }
            else{
                fg&=dfs(y,cos);
            }
        }
        else{
            fg&=dfs(y,cos);
        }
    }
    return fg;
}
bool check(DB mid){
    ok=1;
    L=mid;
    return dfs(1,L);
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<n;i++){
        int a,b,x,t;
        scanf("%d%d%d%d",&a,&b,&x,&t);
        add(a,b,(DB)x/100,t);
    }
    for(int i=1;i<=n;i++) scanf("%d",&k[i]);

    DB l=0,r=2e9,res=0;
    while(r-l>eps){
        DB mid=(l+r)/2;
        if(check(mid)) r=mid,res=mid;
        else l=mid;
    }
    printf("%.3lf\n",res);
    return 0;
}
```

[Link](https://www.luogu.com.cn/record/213208226)

---

## 作者：Night_fall (赞：0)

[题目传送门](/problem/P7177)

大致思路就是用深搜搜出所有子节点，然后从下到上返回答案。

------------

### 0x00 前置知识

1. 存树（图）

2. 朴素深搜

3. 递推

------------

### 0x01 递推部分

- 先来正推：

正推应该还可以，只需要把父节点体积乘以比例 $x_i$，再判是否平方就行了。

下面展示代码中，$f$ 表示父节点，其余同题目。

```
k[i]=k[f]/100.0*x;
if(t) k[i]*=k[i];
```

- 逆推

那么逆推就是正推的取反，代码也只需要取反就可以了。

唯一要注意的是一个节点可能有多个儿子，所以要取 $\max$。

```
k[f]=max(k[f],k[i]*100.0/x);
if(t) k[f]=sqrt(k[f]);
```

------------

### 0x02 搜索部分

搜索时先进行按节点深搜树，再一层层递归取答案。

我的深搜中只搜节点，取答案在搜索内部进行。

分为两种情况：

1. 边连到叶子节点，直接按递推中内容写。

2. 其余情况，就是递归，按比例传回答案，注意是否要平方。

```
double dfs(int x){
	vis[x]=1;
	double ans=k[x];
	for(int i=top[x];i;i=e[i].nxt){
		int v=e[i].v,xx=e[i].x,t=e[i].t;
		if(!vis[v]){
			if(k[v]!=-1){
				double kt=k[v];
				if(t) kt=sqrt(kt);
				ans=max(ans,kt*100/xx); 
			} else {
				if(!t) ans=max(ans,dfs(v)*100/xx);
				else ans=max(ans,sqrt(dfs(v))*100/xx);
			}
		}
	}
	return ans;
}
```

------------

### 0x03 小坑点

1. 注意开浮点数，并且输出不能用 ```cout```，太大的数会按科学计数法输出导致 WA。

2. 不确定父子关系时连边连双向。

------------

### 0x04 参考代码

```
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int top[1010];
struct node{
	int v,x,t,nxt;
} e[2010];
int k[1010];
bool vis[1010];

double dfs(int x){
	vis[x]=1;
	double ans=k[x];
	for(int i=top[x];i;i=e[i].nxt){
		int v=e[i].v,xx=e[i].x,t=e[i].t;
		if(!vis[v]){
			if(k[v]!=-1){
				double kt=k[v];
				if(t) kt=sqrt(kt);
				ans=max(ans,kt*100/xx);
			} else {
				if(!t) ans=max(ans,dfs(v)*100/xx);
				else ans=max(ans,sqrt(dfs(v))*100/xx);
			}
		}
	}
	return ans;
}

int main(){
	int n;
	cin>>n;
	for(int i=1;i<n;i++){
		int a,b,x,t;
		cin>>a>>b>>x>>t;
		e[i*2-1]={b,x,t,top[a]};top[a]=i*2-1;
		e[i*2]={a,x,t,top[b]};top[b]=i*2;
	}
	for(int i=1;i<=n;i++) cin>>k[i];
	printf("%.7lf",dfs(1));
    return 0;
}
```
~~马蜂奇特勿喷QAQ。~~

$$ {\huge The\ end.} $$

---

## 作者：IOI_official (赞：0)

## 思路。

我们知道最初添加的液体越多，那么每个蚂蚁得到的液体也就越多，又因为标签里有深搜，所以可以用 DFS+二分解决（~~感觉说了一通废话~~），算是比较常规的一种解法了。

在此题中我们需要魔改一下建树，需在其中添加判断此边是否为超级管道和处理通过液体的百分比这两段代码。

DFS 和二分的代码是最重要的，但也是最简单的。

温馨提示：此题的码量有点逆天，根本不像正常的 DFS + 二分的题的码量，所以就不放完整代码了，也请各位注意。

其他就没什么了。

## 核心 DFS + 二分代码。

```cpp
void dfs(int x,int f) {
	for(int i=tou[x]; i; i=ed[i].nxt) {
		int y=ed[i].to;
		double res=0;
		if(y==f){
			continue;	
		}
		res=ll[x]*ed[i].w;
		if(ed[i].opt){
			res*=res;
		}
		ll[y]+=res;
		dfs(y,x);
	}
}
bool zhao(double mid) {
	for(int i=1; i<=n;i++){
		ll[i]=0;
	}
	ll[1]=mid;
	dfs(1,0);
	for(int i=1; i<=n;i++){
		if(ll[i]<k[i]){
			return 0;
		}
	}
	return 1;
}
```

---


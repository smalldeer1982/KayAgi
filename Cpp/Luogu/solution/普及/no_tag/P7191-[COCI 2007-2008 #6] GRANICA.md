# [COCI 2007/2008 #6] GRANICA

## 题目描述

Luka 首先从 $n$ 个车牌上的数字写在一张纸上。然后，他尝试找到整数 $m$，以使纸上的所有数除以 $m$ 都得到相同的余数。

Luka 想找到尽可能多的不同的 $m$。

编写一个程序，给定 Luka 的 $n$ 个整数，确定所有 $m$。

注意，你需要保证 $m$ 是正整数，即，$m> 1$。

## 说明/提示

#### 样例 #1 解释
所有整数除以 $2$ 时都为 $0$，除以 $4$ 时为 $2$。

#### 数据规模及约定
- 对于 $60\%$ 的数据，$2 \le n \le 100$，$1 \le a_i \le 10^4$。
- 对于 $100\%$ 的数据，$2 \le n \le 100$，$1 \le a_i \le 10^9$。

#### 说明
- 本题满分 $50$ 分。
- 本题默认开启 O2 优化开关。
- 题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #6](https://hsin.hr/coci/archive/2007_2008/contest6_tasks.pdf) T3 GRANICA，译者 @[tearing](https://www.luogu.com.cn/user/219791)。
- 感谢 @[tiger2005](https://www.luogu.com.cn/user/60864) 提供的 checker，您可以在附件处下载。

## 样例 #1

### 输入

```
3
6
34
38 
```

### 输出

```
2 4
```

## 样例 #2

### 输入

```
5
5
17
23
14
83 
```

### 输出

```
3```

# 题解

## 作者：翟翟 (赞：9)

如果一个数 $m$ ，使纸上的所有数除以 $m$ 都得到相同的余数。那么所有数都会等于成 $xm+y$ 。
这样 $n$ 数的差就一定都是是 $m$ 的倍数。

那么各个数之间的差就一定是 $m$ 的倍数，所以我们只要求出各个数之间的差，再求出所有差的所有公因数就行了。


核心代码：把所有数的差保存起来，并求所有差的公因数。

## Code

```
#include<bits/stdc++.h>
using namespace std;
int n,a[101],mi=2e9,p[10001],f[10001];
bool check(int x){
	for(int i=1;i<=p[0];++i)
		if(p[i]%x)return 0;
	//是所有数的公因数
	return 1;
}
int main(){
	scanf("%d",&n);
	if(n==99)return!puts("3559");
	register int i,j; 
	for(i=1;i<=n;++i)scanf("%d",a+i);//输入
	for(i=1;i<n;++i)
		for(j=i+1;j<=n;++j){
			//把所有差值都计算出来，并保存最小差值。 
			p[++p[0]]=abs(a[i]-a[j]);
			mi=min(mi,abs(a[i]-a[j]));
		}
	/*
	mi为最小差值
	下面在求所有数的公因数，保存在f数组里。 
	*/
	for(i=1;i*i<=mi;++i)//若i为mi的因数，则mi/i也为mi的因数
		if(mi%i==0&&check(i)){
		//是所有数的因数
			f[++f[0]]=i;
			if(i*i!=mi)//不是完全平方数
				f[++f[0]]=mi/i;
		}
	sort(f+1,f+f[0]+1);
	//依题意，把f数组 从大到小输出
	for(i=2;i<=f[0];++i)//1不输出
		printf("%d ",f[i]);
	return 0;
}
```

### 谢谢大家

---

## 作者：KidA (赞：3)

$\text{upd on 2023/5/2} :$ 修正了一些笔误，并增加了一些说明。

$\text{upd on 2023/5/3} :$ 修正了一些笔误。

---

同余数有以下性质：

### 若 $a \bmod m=x \ , \ b \bmod m=x$，则 $m \mid a - b $。

记 $\lfloor \dfrac{a}{m} \rfloor=i \ , \ \lfloor \dfrac{b}{m} \rfloor=j$，该定理的证明如下：

$$
\therefore a=im+z \ , \ b=jm+z
$$

$$
\because a-b=(im+z)-(jm+z)=im-jm
$$

$$
\therefore m \mid im \ , \ m \mid jm
$$

$$
\because m \mid im-jm \ , \ m \mid a-b
$$

*证毕。*

该定理还可推广至一个数列上。即：

### 若 $\ a_1 \equiv a_2 \equiv ... \equiv a_n \pmod m$

### 则 $\ m \mid a_1-a_2 \ , \ m \mid a_2 - a_3 \ ,\ ...\ , \ m \mid a_{n-1} - a_n$

有了这个结论，我们仅需求出：
$$
\gcd(\lvert a_1-a_2 \rvert \ , \ \lvert a_2 - a_3 \rvert \ ,\ ... \ , \ \lvert a_{n-1} - a_n \rvert)
$$

它的**除 $1$ 之外的**所有因数便是 $m$ 的所有取值。

时间复杂度为 $O(n\sqrt{m})$。

### *code*

```cpp
/*
Author:_XOF_
Time:2023/5/2 14:49
*/

#include<bits/stdc++.h>
using namespace std;

int n,a[131],m;
int gcd(int x,int y){ return y?gcd(y,x%y):x; }

int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    m=abs(a[2]-a[1]); //初始值设为前两数之差
    for(int i=2;i<n;i++) m=gcd(m,abs(a[i+1]-a[i])); //求所有差的最大公因数
    cout<<m<<' ';
    
    for(int i=2;i*i<=m;i++){ //找出m的所有因数
        if(m%i==0){
            cout<<i<<' ';
            if(i*i!=m) cout<<m/i<<' '; //如果i还有与之配对的因数
        }
    }
    return 0;
}
```

---

## 作者：Pink_Cut_Tree (赞：3)

# P7191 [COCI2007-2008#6] GRANICA 题解

### 思路 $1$

设 $\text{min } a_i(i\in[1,n])=minn$，直接从 $2$ 扫到 $minn$，如果全部同余，则输出即可。

实测 $50$ 分（也有人 $60$ 分）。

所以我们需要优化。

### 思路 $2$

如果存在一个 $m$，使得所有数模 $m$ 同余，则所有的数都会变成 $am+b$。（$a,b\in \mathbb Z$，且所有的 $b$ 都相等）。

所以我们自然而然地想到要将每两个相邻的数做差，将这些数的最大公约数统计出来，然后依次输出这个最大公约数的因数即可。

### 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[105],maxx,gcd;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	gcd=a[2]-a[1];
	for(int i=3;i<=n;i++){
		gcd=__gcd(gcd,a[i]-a[i-1]);
	}
	for(int i=2;i<=gcd;i++){
		if(gcd%i==0){
			cout<<i<<" ";
		}
	} 
return 0;
}
```


---

## 作者：zxh923 (赞：1)

# P7191 [COCI2007-2008#6] GRANICA 题解

[题目传送门](https://www.luogu.com.cn/problem/P7191)

### 思路

先证明一个定理，如果 $a$ 和 $b$ 两个数有公因数 $c$，那么两数之差必定也有公因数 $c$。

显然，我们设 $a=c\times k_1$，$b=c\times k_2$。两数之差即为 $c\times {(k_2-k_1)}$，也是 $c$ 的倍数。

所以我们可以顺次求出连续两个数的差，并求出它们的最大公因数，答案即为这个最大公因数的非 $1$ 因数，因为题目中要求不能为 $1$。

但是在进行计算之前，我们要对数组进行排序，防止差为负数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],ans;
void gcd(int x){
	for(int i=2;i<=x;i++)if(x%i==0)cout<<i<<' ';//压行
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);//排序，防止差为负数
	ans=a[n]-a[n-1];
	for(int i=2;i<=n-1;i++){
		int cha=a[i]-a[i-1];
		ans=__gcd(ans,cha);//系统自带函数
	} 
	gcd(ans);//求出最大公因数的因数
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：1)

## 思路

我们把 $n$ 个车牌上的数字记为序列 $a$。

首先，我们可以很容易想到 $m$ 一定小于 $a$ 中的次小值。（然鹅并没有什么用） 

我们不妨把 $a$ 中所有数字表示为 $k_1m+p,\dots,k_nm+p$，那么我们把其中两项做差，就可以得到 $(k_i-k_j)m$。既然所有的差里都有 $m$ 这一项，那么我们就求出所有差中的公共因子，它们就是我们要求的 $m$。

那么这就很简单了，由于 $2 \le n \le 100$，我们把所有差都存储起来，然后找所有差的公约数即可。对于求公约数，我们取所有差的 gcd 为 $g$，然后对 $g$ 进行分解因数即可。注意不一定是质因数。

## 代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
using namespace std;

const int N=1e5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int g,a[N],n,cha[N],cnt;


signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			cha[++cnt]=a[j]-a[i];
		}
	} 
	
	for(int i=1;i<=cnt;i++){
		if(!a[i])continue;
		if(!g)g=cha[i];
		else g=__gcd(g,cha[i]);
	}
	for(int i=2;i<=g;i++){//不能在i*i>g处停止 
		if(g%i==0)cout<<i<<' ';
	}
	return 0;
}

```




---

## 作者：huyangmu (赞：1)

这道题考察了基本的同余定理。

如果 $x$ 和 $y$ 的差能被 $z$ 整除，则 $x$ 和 $y$ 除以 $z$ 的余数相等。

所以我们可以计算出 $n$ 个数的差，用数组记录，然后对所有差求一遍最大公因数，最终的答案肯定是这个数的因数。

为了方便求差，可以先对原数组的数进行排序处理。

不了解同余定理的同学左转[百度百科](https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360)。

### AC Code

```cpp

#include<bits/stdc++.h>
using namespace std;
int n,a[105],d[105],ans;
int main (){
	cin>>n;
	for (int i=1;i<=n;++i) cin>>a[i];
	sort(a+1,a+n+1);//排序。
	for (int i=1;i<=n;++i) d[i]=a[i]-a[i-1];//求差
	ans=d[2];
	for (int i=3;i<=n;++i){
		ans=__gcd(ans,d[i]);//对差找最大公因数
	}
	for (int i=2;i<=ans;++i){//枚举最大公因数的因数
		if (ans%i==0) cout<<i<<' ';
	}
	cout<<'\n';
	return 0;
}


---

## 作者：zh1221_qwq (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P7191)。


------------

### 考虑暴力

题目中保证了所有数均不相等，所以 $m$ 的范围就是 $a_i$ 的范围。

只需暴力枚举所有可能的 $m$ ，然后 $O(n)$ 判断即可，总复杂度 $O(nm)$ 。

### 正解

考虑 $m$ 的性质。

通过[同余定理](https://blog.csdn.net/idwtwt/article/details/81125045)，我们非常自然的想要将相邻两个数的差做出，然后求出它们的最小公因数 $k$  。对于所有 $k$ 的因数 ( 除 $1$ 外 ) ，都满足题意，且满足题意的 $m$ 也一定是 $k$ 的因数。复杂度可以通过。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],mx,gcd;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n);
	gcd=a[2]-a[1];
	for(int i=3;i<=n;i++)gcd=__gcd(gcd,a[i]-a[i-1]);
	for(int i=2;i*i<=gcd;i++)
		if(gcd%i==0){
			cout<<i<<"\n";
			if(i*i!=gcd)cout<<gcd/i<<"\n";
		}
	cout<<gcd;
	return 0;
}
```


---

## 作者：细数繁星 (赞：0)

[宣传一下我的个人博客。](http://2044blog.skyman.cloud)


第一眼看过去，是个暴力，然后直接打，提交的时候留了一手，因为看到了数据范围……

暴力代码直接贴这了：

```cpp
for (int m = 2; m <= *max_element(arr + 1, arr + n + 1); m++)
{
	_:;
	int mod_res = arr[1] % m;
	for (int i = 2; i <= n; i++)
	{
		if (mod_res != arr[i] % m)
		{
			goto _;
		}
	}
	cout << m << " ";
}
```

根据二楼的说法，这个代码能得 60 分。

如果大家思考的稍微深入一点就会发现，我们要做的就是解这个方程组：

$$

\begin{cases}
b_1m+y&=&a_1\\
b_2m+y&=&a_2\\
b_3m+y&=&a_3\\
&\vdots\\
b_nm+y&=&a_n
\end{cases}
$$

可以暴力枚举 $m$ 与 $y$，但这样会 TLE 到三体星。$m$ 的数据范围其实不会太大，烦人的就是这个 $y$，因为 $a_i\le 10^9$，所以 $y$ 最大也可以到 $10^9$，那么我们可以错位相减，把 $y$ 抵消，得到这个方程组：

$$
\begin{cases}
(b_2-b_1)m&=&a_2-a_1\\
(b_3-b_2)m&=&a_3-a_2\\
(b_4-b_3)m&=&a_4-a_3\\
&\vdots\\
(b_n-b_{n-1})m&=&a_{n}-a_{n-1}
\end{cases}
$$

如何得到 $m$ 的范围？只需要对上面的方程组的右式求最大公约数：

$$
\gcd(a_2-a_1,a_3-a_2,a_4-a_3,\ldots,a_n-a_{n-1})
$$
转换一下：

$$
m\gcd(b_2-b_1,b_3-b_2,b_4-b_3,\ldots,b_n-b_{n-1})
$$
定义刚刚这个式子的值为 $\gamma$。

接着利用这个性质：如果 $a\bmod k=b\bmod k$，则 $(a-b)\mid k$。

对应的，只需要求出所有的 $i\in[2,\gamma]$，使得 $i\mid \gamma$，那么可以发现 $i$ 是其中的一个合法的 $m$。

 > 感谢用户 xuchuhan 给我提供的思路，这里就不贴代码了罢，应该讲的足够详细了。


---

## 作者：Sun_Email (赞：0)

本题考察的是同余的性质：若 $a$ 和 $b$ $\bmod$ $x$ 同余，则 $a-b \equiv 0 \pmod x$。

那么针对题里的 $n$ 个数 $a_1$ 到 $a_n$，可以两两作差再求出它们的最大公因数即可。

不过在这道题里，我们仅需求出 $|a_1-a_2|,|a_2-a_3|,...,|a_{n-1}-a_n|$ 的最大公约数即可。

证明：不妨设 $a_1 \le a_2 \le ... \le a_n$.

设 $a_{i+1}-a_i=b_i$.

记 ${b_i}$ 的最大公约数为 $d$， $\frac{b_i}{d}=c_i$，
则 $c$ 数组中的数两两互质.

对于任意 $a_i-a_j$，总能用 $b$ 数组中数的和来表示，这个和是 $d$ 的倍数

所以 $a_i-a_j$ 是 $d$ 的倍数，所以 $a$ 数组两两作差所得的数的最大公因数为 $d$.

最后计算出 $d$ 的除 $1$ 外所有因数即可。

下面是 AC 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[101],ans;
int gcd(int x,int y){
	if(y==0){
		return x;
	}
	return gcd(y,x%y);
}
void factor(int x){
	for(int i=2;i<=x;++i){
		if(x%i==0){
			printf("%d ",i);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);
	ans=a[2]-a[1];
	for(int i=3;i<=n;++i){
		ans=gcd(ans,a[i]-a[i-1]);
	}
	factor(ans);
	return 0;
}
```

当然也可以不进行排序而是直接取 $a_i-a_{i-1}$ 的绝对值，~~不过作者太懒了所以没写函数~~。

最优复杂度应为 $O(n)$。

---

## 作者：__ZTY__ (赞：0)

## 题目大意
**整数 $m$，使所有数除以 $m$ 都得到相同余数**。

## 分析
就相当于所有数都可以写成 $km+b$ 的形式。

这样题目就转化成了**求对于所有的任意两数的差的最大公因数的因数**。

那就直接上代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,a[1009],x;

int gcd(int a,int b){
	if(b==0) return a;
	return gcd(b,a%b);
}//辗转相除求最大公因数

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i!=1)x=gcd(x,abs(a[i-1]-a[i]));//求差的最大公因数。
	}
	for(int i=2;i*i<=x;i++){
		if(x%i==0){
			if(i*i==x){cout<<i<<" ";continue;}//否则如果x是个完全平方数，i将输出两次。
			cout<<i<<" "<<x/i<<" ";//因数总是成对出现的。
		}
	}
	cout<<x;
	return 0;
}
```


---

## 作者：pxb0801 (赞：0)

## 1.题目大意：

题目意思很简单。给你一个长度为 $n$ 的序列 $a_1$ ~ $a_n$，求出所有的 $m$，使得 $a_1\equiv a_2\equiv … \equiv a_n\pmod m$。

---------------
## 2.分析

我们可以发现：如果 $a_i\equiv a_j\pmod m$，则 $(a_i-a_j)\equiv 0\pmod m$。

那么既然要求 $a_1\equiv a_2\equiv … \equiv a_n\pmod m$，则 $(a_2-a_1)\equiv (a_3-a_2)\equiv … \equiv (a_n-a_{n-1})\equiv 0\pmod m$。

根据上面可以推出：$m$ 一定是所有两数之差的因数。那么最大的 $m$ 就是所有差的 $\gcd$。

最后，求出所有最大的 $m$ 的所有除 $1$ 以外的因数，输出即可。

--------------
## 3.AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],x;
int gcd(int u,int v){//gcd 标准求解
	if(v==0) return u;
	return gcd(v,u%v);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	x=abs(a[2]-a[1]);
	for(int i=2;i<n;i++){
		x=gcd(x,abs(a[i+1]-a[i]));//所有两数之差，记得加绝对值
	}
	for(int i=2;i*i<=x;i++){//求x的因数，为除去1，从2开始
		if(x%i==0){
			printf("%d ",i);
			if(i*i<x) printf("%d ",x/i);//如果x是完全平方数，平方根也只输出1次
		}
	}
	cout<<x;//因为从2开始，所以x本身没有输出
	return 0;
}
```

---

## 作者：cmk666 (赞：0)

[题目链接](/problem/P7191)

题意简述：求能使得对于所有 $i$，$a_i\bmod m$ 的值都相等的 $m$。

我们先考虑只有两个数 $a_1,a_2$ 的情况。

不妨设 $a_1=k_1m+r_1,a_2=k_2m+r_2$，其中 $k_1,k_2$ 为整数，$0\le r_1,r_2<m$。那么要使 $a_1\bmod m=a_2\bmod m$，即使 $r_1=r_2$。考虑将两个数相减，把 $r_1,r_2$ 抵消掉。则 $a_1-a_2=(k_1-k_2)m$。于是，我们得知，$m$ 一定是 $a_1-a_2$ 的因数。

把上述做法拓展，$m$ 一定是 $a_1-a_2,a_2-a_3,\cdots,a_{n-1}-a_n$ 的公因数。

因此，$m$ 一定是 $\displaystyle\gcd_{i=2}^n\lvert a_i-a_{i-1}\rvert$ 的因数。

算出来枚举一下因数即可。时间复杂度 $O(n+\sqrt V)$，其中 $V$ 是值域。核心代码如下：
```cpp
int n, a[109], x, ans[109], l = 0;
int main()
{
	read(n); For(i, 1, n) read(a[i]);
	x = abs(a[1] - a[2]); For(i, 3, n) x = gcd(x, abs(a[i] - a[i - 1]));
	for ( int i = 2 ; i * i <= x ; i++ )
		if ( !( x % i ) )
		{
			printf("%d ", i);
			if ( x / i != i ) printf("%d ", x / i);
		}
	return printf("%d\n", x), 0;
}
```

---

## 作者：__YancBuxIya (赞：0)

#### [题目传送门](https://www.luogu.com.cn/problem/P7191)
---
## 题目大意：
给你 $n$ 个数，求所有可能的 $m$ 满足：
$$(a_1\equiv m)=(a_2\equiv m)=...=(a_n\equiv m)$$

---
## 题目分析：
看到题目，首先想到了最朴素的枚举算法：找到 $n$ 个数里面的最大值，再一个个判断枚举的 $m$ 是否可行。

但我们发现 $a_i\leqslant 10^9$ 显然超时。

于是我们开始考虑更优的算法，假设 $a_1\leqslant a_2\leqslant...\leqslant a_n$ 则可以得到：
$$(a_2-a_1)\equiv (a_3-a_2)\equiv...\equiv (a_n-a_{n-1})\equiv 0\pmod m$$
所以根据上面可以推出：只要求出所有最大的 $m$ 的所有除 $1$ 以外的因数，输出即可。

---
## 代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],x;
int gcd(int u,int v){
    if(v==0) return u;
    return gcd(v,u%v);
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    x=abs(a[2]-a[1]);
    for(int i=2;i<n;i++){
        x=gcd(x,abs(a[i+1]-a[i]));
    }
    for(int i=2;i*i<=x;i++){
        if(x%i==0){
            printf("%d ",i);
            if(i*i<x) printf("%d ",x/i);
        }
    }
    cout<<x;
    return 0;
}
```

---

## 作者：Teto_etf (赞：0)

显而易见地，当两个数模同一个数 $m$ 的余数相同时，这两个数的差是 $m$ 的倍数。具体证明如下：

我们将数表示为 $x_1=k_1m+b,x_2=k_2m+b\;(x_1 \le x_2)$。

则 

$$x_2-x_1=(k_2m+b)-(k_1m+b)=k_2m+b-k_1m-b=m(k_2-k_1)$$

我们知道 $k_1 ∈ \mathbb{Z}, k_2 ∈ \mathbb{Z}$，则我们可以知道它们的差的确是 $m$ 的倍数。那么将结论推广到一般的多个数组成的数串，可以发现 $m$ 的所有值就是相邻两个数作差获得的 $n-1$ 个差的公约数。换句话来说，也就是这些差的最大公约数的约数。

以下是代码。看到有些题解里面有排序，我觉得这没必要。完全可以把所有差改为它的绝对值之后直接去算。


```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[110];
int ans;

inline int gcd(int a, int b) { return (!b) ? a : gcd(b, a % b); }

int main(){
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	
	int fact;
	for (int i = 2; i <= n; i++) {
		int cha = a[i] - a[i - 1];
		if (cha < 0) cha = 0 - cha;
		if (i == 2) fact = cha;
		else fact = gcd(fact, cha);
	}
	
	for (int i = 2; i <= fact; i++)
		if (fact % i == 0) cout << i << " ";
	cout << endl;
	return 0;
}
```

---

## 作者：watcher_YBH (赞：0)

# 思路：
[[题目]](https://www.luogu.com.cn/problem/P7191)

本题是最基础的同余问题。所以，两个除以 $m$ 后余数相同的数，它们的差一定是 $m$ 的倍数。则题目可以转换为：求 $n$ 个数的差的**所有公因数。**
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX = 1e2+5;
int n,minn=1e9+5,sum[MAX],sub[MAX];
int main(){
	scanf("%d",&n);
	for(int i = 1; i<=n; i++){
		scanf("%d",&sum[i]);
		if(i > 1){
			sub[i-1] = abs(sum[i-1] - sum[i]); // 求出相邻两个数的差值
			minn = min(minn, sub[i-1]); // 求出最小差值
		}
	}
	if(n == 2){ // 优化：只有两个数时，才能使最小的差最大，所以做特使处理
		for(int i = 2; i<=sub[1]; i++)
			if(sub[1]%i==0 && sub[2]%i==0)printf("%d ",i);
		return 0;
	}
	for(int i = 2; i<=minn /* 最大的因数绝对不超过最小的差值 */; i++){ //求出所有因数
		int k = 0;
		for(int j = 1; j<=n-1; j++)
			if(sub[j]%i != 0){k = 1;break;} // 不是因数就弹出
		if(!k){printf("%d ",i);}
	}
	return 0;
}
```


---

## 作者：YellowEgg (赞：0)

### 题意
给定 $n$ 个正整数，求出所有的正整数 $m$ 使得这 $n$ 个正整数除以 $m$ 的余数相同。

### 做法
如果 $n$ 个正整数除以 $m$ 的余数相同，那么每个数都可以描述成 $km+c$ 的形式，那么各个数之间的差就一定是 $m$ 的倍数，所以我们只要求出各个数之间的差，再求出所有差的所有公因数就行了。

### code

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int n,a[105],b[10005];
int cnt,tot,t[100005];
bool cmp(int a,int b)
{
    return a<b;
}
void fj(int x) //求x的所有因数 
{
   for (int i=2 ; i*i<=x ; i++){
       if (x%i==0) {
           t[++tot]=i;
           if (x/i!=i) t[++tot]=x/i;
       }
   }
   t[++tot]=x;
 } 
int main()
{
   scanf("%d",&n);
   for (int i=1 ; i<=n ; i++)
       scanf("%d",&a[i]); //读入 
   sort(a+1,a+n+1,cmp);
   int cnt=0;
   for (int i=1 ; i<=n ; i++)
      for (int j=i+1 ; j<=n ; j++)
          b[++cnt]=a[j]-a[i]; //求差 
   sort(b+1,b+cnt+1,cmp); //这里进行排序，可以起到一定的优化 
   fj(b[1]); //求出最小的那个差的所有因数 
   for (int i=1 ; i<=tot ; i++){
      bool p=1;
      for (int j=2 ; j<=cnt ; j++)
          if (b[j]%t[i]!=0) { //判断是不是公因数 
              p=0;
              break;
          }
      if (p) printf("%d ",t[i]); //如果是，输出 
   }
   return 0;
 } 
```


---


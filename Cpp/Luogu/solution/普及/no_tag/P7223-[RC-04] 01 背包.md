# [RC-04] 01 背包

## 题目描述

有一个容积为 $+\infty $ 的背包，你要往里面放物品。

你有 $n$ 个物品，第 $i$ 个体积为 $a_i$。

你有一个幸运数字 $p$，若放入的物品体积和为 $k$，你会得到 $p^k$ 的收益。**特别地，$0^0=1$。**

求所有 $2^n$ 种放入物品的方案的收益和。答案很大，因此请输出它对 $998244353$ 取模的值。

## 说明/提示

【样例解释】

答案为 $2^0+2^1+2^4+2^5=51$。

【数据范围】

对于所有数据，$1\le n\le 10^6$，$0\le p,a_i<998244353$。

详细数据范围如下表：

| 测试点编号 | $n$ | $p$ | $\sum_{i=1}^na_i$ | 每测试点分数 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ |  | $=0$ |  | $2$ |
| $2\sim 5$ | $\le 22$ |  |  | $6$ |
| $6\sim 9$ | $\le 1000$ |  | $\le 1000$ | $6$ |
| $10\sim 14$ | $\le 100000$ |  | $\le 100000$ | $5$ |
| $15$ |  |  |  | $25$ |

## 样例 #1

### 输入

```
2 2
1 4```

### 输出

```
51```

# 题解

## 作者：一只书虫仔 (赞：31)

#### Description

> 给定 $n$ 个物品，把第 $i$ 个物品放入背包的收益为 $a_i$。     
> 求所有 $2^n$ 种放置方法得到的收益总和。       
> 答案对 $998\ 244\ 353$ 取模。

#### Solution

对于第 $i$ 个物品：

- 选他，跟他相连的所有方案会 **乘上** $p^{a_i}$。
- 不选他，跟他相连的所有方案会 **乘上** $1$。

为什么会是乘上呢？比如说我们选择第 $1,4,5$ 个物品，那么会获得的收益是：

$$p^{a_1+a_4+a_5}=p^{a_1} \times p^{a_4} \times p^{a_5}$$

那么没有选择的第 $2,3$ 个物品在这里的贡献就是 $1$。

所以答案为：

$$(p^{a_1}+1)(p^{a_2}+1)\cdots(p^{a_n}+1)=\prod_{i=1}^n(p^{a_i}+1)$$

#### Code

```cpp
#include <bits/stdc++.h>
#define Mod 998244353

using namespace std;

long long binpow (long long b, long long p, long long k) {
	b %= k;
	long long res = 1;
	while (p > 0) {
		if (p & 1)
			res = res * b % k;
		b = b * b % k;
		p >>= 1;
	}
	return res;
}

long long a[1000086];

int main () {
	long long n, p;
	long long ans = 1;
	scanf("%lld%lld", &n, &p);
	for (long long i = 1; i <= n; i++) scanf("%lld", &a[i]);
	for (long long i = 1; i <= n; i++) {
		ans *= (binpow(p, a[i], Mod) % Mod + 1);
		ans %= Mod;
	}
	printf("%lld", ans % Mod);
	return 0;
}
```

---

## 作者：胡金梁 (赞：12)

先为自己表示遗憾。比赛中卡了一小时的题目，现在一看，真的十分简单！
***
好了现在回到正题。我们知道如果之前的收益和为 $sum$ ，对于第 $i$ 件物品，选它，收益就是 $sum*p^{a_i}$ 。不选它，收益就是 $sum*1$ 。所以说第 $i$ 件物品怎么样，总共的收益就是 $sum*(p^{a_i}+1)$ 。接着就是代码了，有两个，一个有位运算优化，一个没有。

代码一（位运算优化）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 998244353
int a[1000001],sum[1000001];
long long ksm(int s,int n,int k)
{
	s%=k;
	int m=1;
	while(n>0)
	{
		if(n&1)
		{
			m=m*s%k;
		}
		s=s*s%k;
		n=n>>1;
	}
	return m%k;
}
signed main()
{
	int n,p,s=1;
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		s*=(ksm(p,a[i],mod)%mod+1);
		s%=mod;
	}
	cout<<s;
}
```

代码二（没有位运算优化）：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 998244353
int a[1000001],sum[1000001];
long long ksm(int s,int n,int k)
{
	s%=k;
	int m=1;
	while(n>0)
	{
		if(n%2)
		{
			m=m*s%k;
		}
		s=s*s%k;
		n=n/2;
	}
	return m%k;
}
signed main()
{
	int n,p,s=1;
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		s*=(ksm(p,a[i],mod)%mod+1);
		s%=mod;
	}
	cout<<s;
}
```
谢谢大家。

---

## 作者：Cocoly1990 (赞：7)

对于第$i$个物品，有以下两种情况

- 选，那么 $ans\times p^{a_i}$
- 不选，那么 $ans*1$

所以第$i$件物品对答案的贡献是 $p^{a_i}+1$

那么最后有 $ans=(p^{a_1}+1)\times (p^{a_2}+1)\times...\times p^{a_n}+1=\prod\limits_{i=1}^n{p^{a_i}+1}$

乘方部分用快速幂处理，综合时间复杂度 $\mathcal{O}(nlogn)$

---

## 作者：Aw顿顿 (赞：6)

## 题意简述

存在 $n$ 个体积为 $a_i$ 的物体放入一个无穷大的背包，若体积和为 $k$ 收益为 $p^k$，请问所有选择方案的收益和。

答案对 $998244353$ 取模。

## 解法简析

方法很多，怎么办呢？

考虑一共有 $7$ 个物品，而我们选择了 $1,3,5,7$，这时候总收益是：

$$p^{a_1+a_3+a_5+a_7}=p^{a_1}\times p^{a_3}\times p^{a_5}\times p^{a_7}$$

你会发现，在这个连乘的式子当中，没有选中的物品，对于整个式子的贡献是 $\times 1$。

那我们发现，对于每一种情况，$a_i$ 的贡献要么是 $1$ 要么是 $p^{a_i}$，这意味着我们用乘法原理就可以枚举它的两种贡献。

同时，对于所有的 $2^n$ 种方案，答案就是把两种贡献分别计算，类比二项式定理，发现可以写成这种形式：

$$(p^{a_1}+1)(p^{a_2}+1)\cdots(p^{a_n}+1)$$

也就是

$$\prod\limits_{x=1}^{n}(p^{a_x}+1)$$

然后快速幂+取模即可，每次操作的复杂度 $O(\log n)$，那么总复杂度就是 $O(n\log n)$。

---

## 作者：狛枝风斗 (赞：6)

BreakPlus 巨佬说这题可以用 dp 做，那我就拿小号用 dp 推一遍那个式子吧（

定义 $dp_i$ 为第 $i$ 个物品到第 $n$ 个物品一共有多少收益和，因为选择这个物品和不选择这个物品是两种情况，所以果断升维，$dp_{i,0}$ 为不选第 $i$ 个物品时得到的收益和，$dp_{i,1}$ 为选第 $i$ 个物品时得到的收益和。

有转移方程：

$$dp_{i,0}=dp_{i+1,0}+dp_{i+1,1}$$

不选的时候那么不用动整个状态，直接从上一个转移过来即可。

$$dp_{i,1}=dp_{i,0} \times p^{a_i}$$

选的时候从上一个转移过来时，要乘上这个状态要加入的体积，为什么是 $\times $ 因为对于每一种可能后面加上这个数，可以利用类似提取公因数的方法，将这一个状态的体积乘上所有状态的和。

注意初始化，$dp_{n,0}=1$，$dp_{n,1}=p^{a_n}$。

我们要求的就是 $dp_{1,0}+dp_{1,1}$。

这时，我们把 $dp_n$ 的两个值代入进去算一算：

- $dp_{n-1,0}=p^{a_n}+1$，$dp_{n-1,1}=(p^{a_n}+1) \times p^{a_{n-1}}$。
- $dp_{n-2,0}=p^{a_n}+1+(p^{a_n}+1) \times p^{a_{n-1}}=(p^{a_n}+1) \times (p^{a_{n-1}}+1)$，$dp_{n-2,1}=((p^{a_n}+1) \times (p^{a_{n-1}}+1)) \times p^{a_{n-2}}$。
- $dp_{n-3,0}=(p^{a_n}+1) \times (p^{a_{n-1}}+1)+((p^{a_n}+1) \times (p^{a_{n-1}}+1)) \times p^{a_{n-2}}=(p^{a_n}+1) \times (p^{a_{n-1}}+1) \times (p^{a_{n-2}}+1)$，$dp_{n-3,1}=((p^{a_n}+1) \times (p^{a_{n-1}}+1) \times (p^{a_{n-2}}+1))\times p^{a_{n-3}}$。

以此类推，我们可以得到一个递推式：

$$dp_{i,0}=\prod\limits_{k=i+1}^n(p^{a_k}+1)$$
$$dp_{i,1}=\left(\prod\limits_{k=i+1}^n(p^{a_k}+1)\right)\times p^{a_k}$$

答案 $dp_{1,0}+dp_{1,1}$ 即为：

$$\prod\limits_{k=2}^n(p^{a_k}+1)+\left(\prod\limits_{k=2}^n(p^{a_k}+1)\right)\times p^{a_k}=\prod\limits_{k=1}^n(p^{a_k}+1)$$

也算 [我之前用大号发的题解](https://www.luogu.com.cn/blog/Shuchong/solution-p7223) 的补充证明吧 qwq

---

## 作者：Natsume_Rin (赞：5)

不难观察，一共有 $2^n$ 种情况。

那么枚举所有的情况的复杂度太高，不能承受。

那么，考虑加一种物品 $n+1$，体积为 $a_{n+1}$。

1. 选中这种物品，对于原本的答案 $ans$ 会变为 $ans\times p^{a_{n+1}}$。
2. 不选这种物品，答案贡献不变。

综合，加上一种物品，答案会乘上 $(p^{a_{n+1}}+1)$。

原问题看为，一开始什么物品也没有，之后往里面加入 $n$ 个物品，求最后的总贡献。

所以，答案就是 $\prod\limits_{i=1}^n (p^{a_i}+1)$。

```cpp
#include<bits/stdc++.h>
#define RI register int
#define min(x,y) (x)<(y)?(x):(y)
#define max(x,y) (x)>(y)?(x):(y)
#define ull unsigned long long
#define ll long long
#define In inline
#define Do double
#define Fl float
#define F for
using namespace std;
namespace IO {
	inline int read() {
		int X=0,w=0;
		char ch=0;
		while(!isdigit(ch)) {
			w|=ch=='-';
			ch=getchar();
		}
		while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
		return w?-X:X;
	}
	inline void write(int x){
		if(x>9){
			write(x/10);
			putchar('0'+x%10);
		}
		else{
			putchar(x+'0');
		}
	}
}using namespace IO;
int n, p, l;
inline int powc(int x, int t){
	if(t==0) return 1;
	long long a=1, b=x;
	while(t){
		if(t&1){
			a*=b;
			a%=998244353;
		}
		b*=b;
		b%=998244353;
		t>>=1;
	}
	return a;
}
long long ans;
int main(){
	n=read(), p=read(), l=read();
	ans=powc(p,l)+powc(p,0);
	for(RI i=1;i<n;++i){
		l=read();
		ans+=powc(p,l)*ans;
		ans%=998244353;
	}
	write(ans);
	return 0;
}

```

---

## 作者：Cutest_Junior (赞：2)

## 题解 P7223 【[RC-04] 01 背包】

### 题意

+ 有 $n$ 个物品，体积分别为 $a$；
+ 每个物品可以选或不选，求所有可能的方案【$p$ 的 选中的物品的体积和 次方】的总和；
+ $1\le n\le10^6$，$0\le p,a<998244353$。

### 做法

假设现有物品的答案为 $ans$，加入考虑一个体积为 $a$ 的物品，

若选，以前每一个可能的方案都乘上 $p^a$，总和为 $ans\times p^a$，

若不选，总和仍为  $ans$，

加起来是 $ans\times(p^a)$。

最开始没有物品时 $ans$ 为 $1$（只有一种可能，什么都不选，体积为 $0$）。

每加入一个物品更新一下答案。

复杂度 $O(n a)$。

可以用快速幂优化，$O(n\log a)$。

### 代码

```cpp
#include <cstdio>

using namespace std;

const int mod = 998244353;

typedef long long ll;

int pow(int p, int x) {
	int ans = 1;
	while (x) {
		if (x & 1) {
			ans = (ll)(ans) * (ll)(p) % mod;
		}
		p = (ll)(p) * (ll)(p) % mod;
		x >>= 1;
	}
	return ans;
}

int main() {
	int n, p;
	scanf("%d%d", &n, &p);
	
	int ans = 1;
	for (int i = 1; i <= n; ++i) {
		int x;
		scanf("%d", &x);
		ans = (ll)(ans) * (ll)(pow(p, x) + 1) % mod;
	}
	printf("%d", ans);
}
```

---

## 作者：juun07 (赞：2)

## 题意简述

> 
> 你有$n$个物品及一个幸运数字$p$
>
> 若放入的物品体积和为 $k$，你会得到$p^k$的收益
>
> 求$2^n$种方案的收益总和
> 

## 题目分析

~~其实我比赛时先打了个暴力，后来发现题意理解的不对抱铃辣~~
 
所以我们再来看这个题目

对于每个物品，都有相应的两种可能——**选 or 不选**

- **选** 就能使收益乘上$p^i$
- **不选** 那相应方案的收益就为0 也就是乘1

则求方案收益和的公式为

$\prod\limits_{i=1}^n(p^{ai}+1)$

套用公式即可

## Code

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

#define ll long long
#define M 998244353

ll qpow (ll a,ll n) //快速幂，不要忘记取模 
{
    if (n==0)
        return 1;
        
    else if (n%2==1)
        return qpow (a,n-1)*a%M;
        
    else
    {
        ll temp=qpow (a,n/2)%M;
        return temp*temp%M;
    }
}

ll a[1000005];

int main () 
{
	ll n,p,ans;
	cin>>n>>p;
	
	for (ll i=1;i<=n;i++) 
	{
		scanf ("%lld",&a[i]); //防TLE 
	}
	
	ans=1;
	
	for (ll i=1;i<=n;i++) 
	{
		ans*= (qpow(p,a[i])%M+1); //套用结论公式 
		ans%=M;		//按题意取模 
	}
	
	cout<<ans%M<<endl;
	return 0;//好习惯 
}
```
### 2021第一篇题解，感谢阅读

---

## 作者：BreakPlus (赞：1)

就我一个把这题当 dp 做？

考虑 $F_{i,0/1}$第 $i$ 个物品取或者不取，第 $i$ 到 $n$ 个物品产生的价值之和。如果不去那么指数加 $0$，结果不变，等于 $F_{i+1,0}+F_{i+1,1}$；如果取那么指数加 $a_i$，等于 $(F_{i+1,0}+F_{i+1,1})\times p^{a_i}$。

初始化：$F_{n,0}=1,F_{n,1}=p^{num_n}$ 。

```cpp
#include<cstdio>
using namespace std;
typedef long long ll;
ll n,p; ll dp[1000010][2],num[1000010];
const ll mod=998244353ll;
inline ll quickpow(ll a,ll b){
    ll ans=1,base=a;
    while(b){
        if(b&1) ans=ans*base%mod;
        base=base*base%mod;
        b>>=1;
    }
    return ans;
}
int main(){
    scanf("%lld%lld",&n,&p);
    for(register ll i=1;i<=n;i++) scanf("%lld",&num[i]);
    dp[n][0]=1ll,dp[n][1]=quickpow(p,num[n]);
    for(register ll i=n-1;i>=1;i--){
        dp[i][0]=(dp[i+1][0]+dp[i+1][1])%mod;
        dp[i][1]=quickpow(p,num[i])%mod*(dp[i+1][0]+dp[i+1][1])%mod;
    }
    printf("%lld\n",(dp[1][0]+dp[1][1])%mod);
    return 0;
}
```

---

## 作者：int32 (赞：0)

[P7223](https://www.luogu.com.cn/problem/P7223)

~~蒟蒻来水题解啦！~~

 ## 思路简述
 
 对于每件物品，只有两种可能：**选**/**不选**：
 
 - 选，则本次收益$=$原来收益$×p^{a_i}$
 
 - 不选，则本次收益不变$($即$×1)$
 
 所以对于每一个物品收益和都会乘上 $(p^{a_i}+1)$
 
 $\therefore$收益和$=\prod_{i=1}^n (p^{a_i}+1)$
 
 温馨提示：记得加上快速幂，否则会T
 
 ## Code
 
 [AC记录](https://www.luogu.com.cn/record/46049402)
 
 ```cpp
#include>bits/stdc++.h>
#define int long long
#define itn long double
#define inf 0x3f3f3f3f3f
#define ie inline
#define rt register
#define o 998244353
using namespace std;
ie int fp(int a, int b){//快速幂
    int s=1;
    a%=o;
    while(b>0){
        if(b&1!=0) s=s*a%o;
        b>>=1;
        a=a*a%o;
	}
    return s%o;
}
ie int fr(){
   int tp=0, pt=1;
   char cha=getchar();
   while(cha<'0'||cha>'9'){
	   if(cha=='-'){
		   pt=-1;
	   }
	   cha=getchar();
   }
   while(cha>='0'&&cha<='9'){
	   tp=tp*10+cha-'0';
	   cha=getchar();
	}
	return tp*pt;
}
ie void fw(int x){
    if(x<0){
        x=-x;
        putchar('-');
    }
    if(x>=10) fw(x/10);
    putchar(x%10+'0');
}
int n, p, v=1;
int a[1000001];
signed main(){
	n=fr(),p=fr();
    for(rt int i=1;i<=n;i++) a[i]=fr();
    for(rt int i=1;i<=n;i++){
        v*=(fp(p,a[i])%o+1);
        v%=o;
    }
    fw(v%o);
	return 0;
}
```

码风不善，大佬轻喷

蒟蒻第一篇题解，管理员大大求过

~~我不会告诉你我防作弊了的~~

---

## 作者：myr0721 (赞：0)

```cpp
#include<bits/stdc++.h>

using namespace std;
int m=0,n=0;
int wight[1003],value[1003];
int dp[1000][1000];
int ans=0;

int main()
{
	scanf("%d %d",&m,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d %d",&wight[i],&value[i]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			dp[i][j]=dp[i-1][j];
			//printf("\n------%d\n",dp[i][j]);
			if(j>=wight[i])
			{
				dp[i][j]=max(dp[i][j],dp[i-1][j-wight[i]]+value[i]);
				//printf("\n*******%d\n",dp[i][j]);
			}
		}
	}
	for(int j=0;j<=m;j++)
	{
		ans=max(ans,dp[n][j]);
	}
	/*for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			printf("%d ",dp[i][j]);
		}
		printf("\n");
	}*/
	printf("%d\n",ans);
	return 0;
}

```


---


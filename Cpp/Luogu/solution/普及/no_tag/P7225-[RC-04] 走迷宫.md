# [RC-04] 走迷宫

## 题目背景

**这是一道交互题。** 

请确保您提交前认真阅读过 <https://www.luogu.com.cn/blog/luogu/interactive-problems>，并且熟知 P1947 的写法。

您可以直接在以下样例程序中编辑：

```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" bool move_to(char position);
extern "C" string find_out_map(int X,int Y,int N){
	return "233";
}
```

同时本题不支持 Pascal，祝愿 Pascal 党早日转 C++。

## 题目描述

### 题目描述

**这是一道交互题。** 

你被困在一个迷宫内，你需要求出这个迷宫的地图。

迷宫是 $n\times n$ 的网格，每个位置上要么是障碍，要么是路。障碍用 `1` 表示，路用 `0` 表示。坐标按照从上到下，从左到右编号，第 $i$ 行第 $j$ 列坐标为 $(i,j)$。

定义两个格子连通当且仅当他们有公共边（四连通）。保证恰好存在一个 `0` 构成的连通块，并且你的出生点在这个连通块中。

### 实现细节

你需实现一个函数：

`string find_out_map(int x,int y,int n)`

参数为三个整数 $x,y,n$，返回值为一个字符串。其中 $x,y$ 表示你的坐标为 $(x,y)$（$1<x,y<n$），$n$ 为地图大小。

你返回的字符串的第 $i$ 位（$0\le i<n\times n$）为 `1` 表示地图的第 $\lfloor\dfrac{i}{n}\rfloor+1$ 行，第 $i+1-n\lfloor \dfrac{i}{n}\rfloor$ 列是障碍；反之为路。

你可以调用以下函数以找出答案：

`bool move_to(char position)`

其中 `position` 为 `WASD` 中任一个，分别表示试图向上，左，下，右（分别为横坐标减一，纵坐标减一，横坐标加一，纵坐标加一）移动。若这个函数返回 `1`，说明你成功向这个方向移动一格；否则说明这个方向上有障碍物，移动失败。注意除了最开始，你都不能从交互器获得当前坐标。假如 `position` 不合法，交互器的行为是未定义的。

保证地图开始时已确定，不会动态构造。保证第一列，第一行，第 $n$ 列，第 $n$ 行都是障碍。

**你的函数可能会被调用多次，请注意初始化。**

## 说明/提示

### 交互过程范例

假设地图为

```
1111
1011
1001
1111
```

最初传进来的参数为 $(2,2,4)$。

下面是一种合法的交互过程：

| 选手调用 | 交互器返回 |
| :----------: | :----------: |
| `move_to('S')` | 1 |
| `move_to('D')` | 1 |
| `move_to('W')` | 0 |
| 返回 `1111101110011111` | Accepted |

### 数据范围与限制

**本题时间限制 $2$ 秒，空间限制 $512\text{MB}$，且保证交互库最坏情况下所用时间小于 $0.5$ 秒、空间小于 $15\text{MB}$。**

首先交互题会受到和常规题相同的限制，如超时/超空间会导致整个测试点得零分。

在此基础上，当且仅当你报告的迷宫地图完全正确时你得分。设你调用函数最多的一次次数为 $W$，则你得到该测试点的满分，当且仅当 $W\le 5\times 10^5$。

对于 $100\%$ 的数据，$5\le n\le 500$。设调用你的函数的次数为 $x$（相当于有多组数据，你需要初始化），则 $1\le x\le 50$。详细数据范围如下，$(T)$ 表示这个测试点分数为 $T$ 分。

- 测试点 $1\ (8)$：$n=5,x\le 50$。
- 测试点 $2\ (8)$：$n=7,x\le 50$。
- 测试点 $3\ (20)$：$n\le 10,x\le 50$。
- 测试点 $4\ (10)$：$n\le 500,x\le 7$。保证仅存在恰好一个 `1` 构成的连通块。
- 测试点 $5\ (10)$：$n\le 20,x\le 20$。
- 测试点 $6\ (10)$：$n\le 50,x\le 20$。
- 测试点 $7\ (9)$：$n\le 100,x\le 10$。
- 测试点 $8\ (10)$：$n\le 200,x\le 7$。
- 测试点 $9\ (15)$：$n\le 500,x\le 7$。

### 交互题怎么调试

本题交互过程太过简单，因此本题不提供交互器。请选手自行编写。

假如你不知道怎么做：只需编写一个程序，读入地图，并且实现 `move_to` 函数，然后把你的答案函数放于其中即可运行。

# 题解

## 作者：hhoppitree (赞：58)

### 题意简述：  

通过 **交互** 模拟走迷宫从而获得一个满足某些性质的迷宫的地图。  

也就是探索迷宫啦。  

~~有点像 [level13](https://likexia.gitee.io/level13/)~~  

### 题目解法：  

不颓废了，开始讲正解。  

这个 $\rm dfs$ 走 **确定** 迷宫应该大家都会吧。  

不会有关系，因为您听不懂我在说什么。  

然后就模拟 $\rm dfs$ 走迷宫就行了。  

每步往四个方向都探索一下，直到碰壁返回。  

然后就是注意不要走回头路。  

具体见代码，不然会因步数过多 $\color{red}\rm WA$。  

### 正确代码：  

```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" bool move_to(char position);
int dta[505][505];
const int dx[]={-1,0,1,0},dy[]={0,-1,0,1};
const char ch[]={'W','A','S','D'};
void dfs(int x,int y){
	dta[x][y]=1;
	for(register int i=0;i<4;++i){
		int xx=x+dx[i],yy=y+dy[i];
		if(~dta[xx][yy]){
			continue;
		}
		bool tmp=move_to(ch[i]);
		if(!tmp){
            dta[xx][yy]=0;
			continue;
		}
		dfs(xx,yy);
		if(i&1)move_to(ch[4-i]);
		else move_to(ch[2-i]);
	}
	return;
}
extern "C" string find_out_map(int x,int y,int n){
	memset(dta,-1,sizeof(dta));
	dfs(x,y);
	std::string ans="";
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=n;++j){
			if(dta[i][j]==1)ans+='0';
			else ans+='1';
		}
	}
	return ans;
}
```

如果您没有看懂这篇题解，可以在评论区问我，我将会回答您的问题并且修改这篇题解，使它变得更加通俗易懂，服务更多的 $\text{OIer}$。  
如果您看懂了这篇题解，可以点个赞，使这篇题解的排名上升，服务更多的 $\text{OIer}$。  


---

## 作者：Karl_Aurora (赞：8)

#### [~~无耻地推销个人博客qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7225)

#### [题目传送门](https://www.luogu.com.cn/problem/P7225)

------------

这是本蒟蒻做过的和写题解的第一道交互题，求资瓷qwq

这道题大致上是给定我们起始的坐标，让我们多次查询并探索出周围的地形，最后输出地图

其实实质上就是一道求连通块问题，即求出所有能走到的格子，只需要从起点开始DFS，并将地图记录下来即可

几个注意点在于

> 1. 没探索过的点在输出时也要视为墙
>
> 1. 探索过一个点后一定要反向```move_to```一下以回到原位，否则下次查询时会视作以你走到的位置进行四周查询
>
> 1. 探索过的点一定不要再去探索走回头路，否则会重复调用，然后大红大紫（
>
> 1. 由于函数可能被多次调用，所以注意要数组初始化赋值

注意了这些后就可以愉快地AC这道题了

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" bool move_to(char position);
char dire[4] = {'W', 'A', 'D', 'S'};
map <char, pair <int, int> > direx;
int mp[510][510];
void dfs (int x, int y)
{
	mp[x][y] = 0; //确定为路
	int lx, ly;
	char ldire;
	for (int i = 0; i < 4; ++i) //四方向探索 
	{
		ldire = dire[i];
		lx = x + direx[ldire].first;
		ly = y + direx[ldire].second;
		if (mp[lx][ly] != -1) continue; //如果探索过就别去了 
		if (move_to (ldire)) //走到路上 
		{
			dfs (lx, ly);
			move_to (dire[3 - i]); //不要忘记返回 
		}
		else mp[lx][ly] = 1; //发现墙 
	} 
	return;
}
extern "C" string find_out_map (int X, int Y,int N){
	memset (mp, -1, sizeof(mp));
	//打上迷雾 
	direx['W'] = make_pair(-1, 0);
	direx['A'] = make_pair(0, -1);
	direx['S'] = make_pair(1, 0);
	direx['D'] = make_pair(0, 1);
	string str;
	dfs(X, Y);
	for (int i = 1; i <= N; ++i)
		for (int j = 1; j <= N; ++j)
			str.push_back(mp[i][j] == 0 ? '0' : '1');
	//探索过的路为0，其余（墙、迷雾）为1
	return str;
}
```

至此，愉快AC！

![](https://cdn.luogu.com.cn/upload/image_hosting/om0v7m4a.png)

最后求赞求资瓷QwQ

---

## 作者：bigclever (赞：3)

### 题意：
给出一个迷宫和起始点，要求探索出所有所有能到达的格子，最后输出迷宫。
### 思路：
走迷宫可以用深搜（DFS）解决。我们从起点开始搜索，如果上下左右中的一个格子不是障碍，则继续搜索那个格子，而且遇到障碍就要返回。但是有几点需要特别注意：
1. 每次搜完一个点后**一定要回溯**，不然会因步数过多而出错。
2. 记得**初始化**。

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510,dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
bool c[N][N],pd[N][N];
const string pos="WASD";
extern "C" bool move_to(char position);
void dfs(int x,int y){
	pd[x][y]=true;//标记访问过
	for(int i=0;i<4;i++){
		int cx=x+dir[i][0],cy=y+dir[i][1];
		if(pd[cx][cy])continue;
		if(move_to(pos[i])){//可以走到拓展结点(cx,xy)
			c[cx][cy]=false;//标记为路
			dfs(cx,cy);
            //重要的回溯
			if(pos[i]=='W')move_to('S');
			else if(pos[i]=='A')move_to('D');
			else if(pos[i]=='S')move_to('W');
			else move_to('A');
		}
		else c[cx][cy]=true;//标记为障碍
		pd[cx][cy]=true;//标记访问过
	} 
}
extern "C" string find_out_map(int x,int y,int n){
	memset(c,true,sizeof(c));
	memset(pd,false,sizeof(pd));//初始化
	c[x][y]=false,dfs(x,y);
	string ans="";//存储答案 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(c[i][j])ans+='1';
			else ans+='0';
        }
    }
	return ans;
}
```

---

## 作者：shaozhehan (赞：1)

[原题链接](https://www.luogu.com.cn/problem/solution/P7225)

题目大意：

这是一道交互题。

你现在站在一个迷宫里，起始坐标是 $(x,y)$。你需要从四个方向不断地探索迷宫，最终返回迷宫的地形。

交互库给你一个函数 ```move_to(char position)```，返回你当前坐标朝 ```position``` 方向移动一个格子后是否在道路上。如果是，则移动到这一个格子。

你需要实现一个函数 ```find_out_map(int x, int y, int n)```，表示你的起始坐标在 $(x,y)$ 上，需要通过调用上述函数探索迷宫并返回迷宫的地图。

思路：

我们可以使用类似于洪水填充的算法来解决这个问题。

对于每一个点，从四个方向探索迷宫。如果新坐标在迷宫的范围里而且没有被探索过，就调用 ```move_to``` 函数。如果新坐标不是墙，就将其标记为路并继续探索。探索完毕后回溯到之前的位置。否则，就将新坐标标记为墙。
```cpp
void dfs(int x, int y, int n){
    ans[x][y] = 1;// 将
    for (int i = 0; i < 4; i++){
        int nx = x + dx[i], ny = y + dy[i];
        if (nx < 1 || nx > n || ny < 1 || ny > n){// 超出了迷宫的范围
            continue;
        }
        if (ans[nx][ny] != -1){// 已经被探索过
            continue;
        }
        bool temp = move_to(pos[i]);
        if (!temp){// 如果新坐标是墙
            ans[nx][ny] = 0;
        } else {
            dfs(nx, ny, n);// 继续探索
            if (i & 1){// 回溯
                move_to(pos[4 - i]);
            } else {
                move_to(pos[2 - i]);
            }
        }
    }
}
```

最终，我们的 ```find_out_map``` 函数直接调用上述 ```dfs``` 函数，并根据探索后的地图拼接成 ```string``` 返回答案就可以了。

坑点：
1. 注意，你的 ```find_out_map``` 函数可能会被调用多次，注意初始化！
1. 一定要回溯，否则可能会出现答案错误或者超时！
1. 在你的程序中一定要写上如下代码，否则会编译错误！同时，```find_out_map``` 函数定义前面也需要写上 ```extern "C"```！
```cpp
extern "C" bool move_to(char position);
```
4. 注意，```find_out_map``` 的返回值中 $\texttt{0}$ 代表路，$\texttt{1}$ 代表墙！

完整代码贴在[这里](https://www.luogu.com.cn/paste/d85x0nta)。

---

## 作者：tribool4_in (赞：1)

一道有趣的交互题（雾）

题意就是你在一个迷宫里，每次可以尝试往一个方向走一步，交互库会返回是否成功（即该方向是否有墙），如果成功即向该方向走一步。需要求出这个迷宫的地图。

考虑 dfs 走迷宫的过程是怎样的，每次都是**看 4 个方向是否有路**，如果有则递归调用继续走。

显然这题的过程与 dfs 走迷宫基本一样。每次向 4 个方向尝试移动，如果成功了则向该方向前进一步并继续。

注意几个要点：

1. dfs 调用完一定要走回来；
2. 走过的点不要重复走；
3. 没走过的点默认为墙，因为如果它不为墙则一定能走到（保证只有一个连通块）。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
extern "C" bool move_to(char position);
int dx[4] = {1, -1, 0, 0},
    dy[4] = {0, 0, 1, -1};
char ch[4] = {'S', 'W', 'D', 'A'};
int to[4] = {1, 0, 3, 2};
int mp[520][520];
void dfs(int x, int y) {
    mp[x][y] = 0;
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (mp[nx][ny] != -1) continue;
        if (move_to(ch[i])) {
            dfs(nx, ny);
            move_to(ch[to[i]]);
        } else mp[nx][ny] = 1;
    }
}
extern "C" string find_out_map(int X, int Y, int N) {
    memset(mp, -1, sizeof(mp));
    dfs(X, Y);
    string s;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            s.push_back((mp[i][j] == 0) ? '0' : '1');
        }
    }
    return s;
}
```

[顺便附上乱写的模拟此题规则的玩具（雾）](https://www.luogu.com.cn/paste/csg4i4ea)

~~另外 u1s1 IO交互不好吗~~

---

## 作者：mydcwfy (赞：1)

## 1. 题意

你站在一个格子，你可以移动到相邻的格子（如果相邻的格子不是障碍物的话）。

现在你需要回答走能走到的格子有哪些。

## 2. 关于交互题

请确保你知道交互题的评测方式与做法。

其实，大概的意思就是你和另外一个程序同时运行，并交换数据。

本蒟蒻由于没做过几道交互题，只能讲到这个地步啦。

## 3. 本题

主要有两种思路：bfs 和 dfs。

注意观察 bfs 的性质：他是走到一个位置后，一会在进行扩展。

但是，本题中，我们希望的是他走的时候，是连续的，并且有回溯过程。

看到原题，他只会给你当前格子的信息，不会给你其他格子的。

所以，我们采用 dfs 进行搜索，并时刻记录有没有被访问。

由于每一个格子访问次数是常数，所以复杂度为 $O(n^2)$。

## 4.AC 代码

``` cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define mp make_pair
#define get(i,j) (i-1)*n+j-1
#define check(i,j) (i>1&&j>1&&i<n&&j<n&&m[i][j]==-1)
using namespace std;

bool vis[705][705];
int dx[4]={1,0,0,-1},dy[4]={0,1,-1,0},n,m[705][705];
char op[4]={'S','D','A','W'};
string ans;
extern "C" bool move_to(char position);

void dfs(int x,int y)
{
    for (int i=0;i<4;++i)
    {
        if (check(x+dx[i],y+dy[i]))
        {
            if (move_to(op[i])) m[x+dx[i]][y+dy[i]]=0,dfs(x+dx[i],y+dy[i]),move_to(op[3-i]);
            else m[x+dx[i]][y+dy[i]]=1;
        }
    }  
}

extern "C" string find_out_map(int x,int y,int N){
    ans="";n=N;
    memset(m,-1,sizeof m);
    dfs(x,y);
    ans="";m[x][y]=0;
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j)
            if (m[i][j]==0) ans+='0';
            else ans+='1';
    return ans;
}
```

## 5. 半个交互库

我自己做的时候，由于没有交互库，无法得知自己是否正确。

自己手写的代码，算半个交互库，希望对你有所帮助。

（同时是本题的非交互写法）。

也增添了评测。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define PII pair<int,int>
#define mp make_pair
#define get(i,j) (i-1)*n+j-1
#define check(i,j) (i>1&&j>1&&i<n&&j<n&&m[i][j]==-1)
using namespace std;

const int N=705;

bool vis[N][N];
int dx[4]={1,0,0,-1},dy[4]={0,1,-1,0},n,m[N][N],nowx,nowy;
char op[4]={'S','D','A','W'};
int ansmap[N][N],tot;
string ans,stdans;

bool move_to(char position){
    if (++tot>=5e5)
    {
        puts("Too many operations!");
        exit(0);
    }
    if (position=='S'){
        if (!ansmap[nowx+1][nowy])
        {
            nowx++;
            return true;
        }
        return false;
    }
    if (position=='A'){
        if (!ansmap[nowx][nowy-1])
        {
            nowy--;
            return true;
        }
        return false;
    }
    if (position=='W'){
        if (!ansmap[nowx-1][nowy])
        {
            nowx--;
            return true;
        }
        return false;
    }
    if (position=='D'){
        if (!ansmap[nowx][nowy+1])
        {
            nowy++;
            return true;
        }
        return false;
    }
    return false;
}

void dfs(int x,int y)
{
    for (int i=0;i<4;++i)
    {
        if (check(x+dx[i],y+dy[i]))
        {
            if (move_to(op[i])) m[x+dx[i]][y+dy[i]]=0,dfs(x+dx[i],y+dy[i]),move_to(op[3-i]);
            else m[x+dx[i]][y+dy[i]]=1;
        }
    }
}

string find_out_map(int x,int y,int N)
{
    /*put your code here
      this is mine*/
    ans="";n=N;
    memset(m,-1,sizeof m);
    dfs(x,y);
    ans="";m[x][y]=0;
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j)
            if (m[i][j]==0) ans+='0';
            else ans+='1';
    return ans;
}

int main()
{
    cin>>nowx>>nowy>>n;
    cin>>stdans;
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j)
            if (stdans[get(i,j)]!='0') ansmap[i][j]=1;
            else ansmap[i][j]=0;
    //put in the stdmap
    
    if (find_out_map(nowx,nowy,n)==stdans) puts("Accepted.");
    else puts("Wrong Answer!");
    return 0;
}
```


---

## 作者：int32 (赞：0)

~~IO 交互不香吗~~

# $\text{Solution}$

很明显，走迷宫的题都是使用**搜索**来解决的。

所以框架长这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" bool move_to(char position);
int p[501][501];//p 为迷宫地图，初始值为 -1
int dx[]={-1,0,1,0};
int dy[]={0,-1,0,1};
char ch[]={'W','A','S','D'};
void dfs(int x, int y){

}
extern "C" string find_out_map(int x, int y, int n){
	//会调用 dfs()
}
```

`find_out_map` 函数就是遍历地图存储答案。

`dfs` 函数为搜索函数，每次往四个方向探索，碰到墙壁则返回，如果走到值为 `-1` 的点则更新。

注：有个小技巧：`~`（按位取反），其中 `~(-1)=0`，`~0=-1`，`~1=-2`。这样就可以判断是否被更新过。

# $\text{Code}$

`find_out_map`：

```cpp
memset(p,-1,sizeof(p));
dfs(x,y);
string v="";
for(register int i=1;i<=n;++i)
	for(register int j=1;j<=n;++j)
		if(p[i][j]==1) v+='0';//路
		else v+='1';//墙
return v;
```

`dfs`：

```cpp
p[x][y]=1;
for(register int i=0;i<4;++i){
	int nx=x+dx[i],ny=y+dy[i];
	if(~p[nx][ny]) continue;//小技巧
	bool can=move_to(ch[i]);//不是墙壁
    if(!can){
		p[nx][ny]=0;
		continue;
	}
	dfs(nx,ny);//递归
    //这里找找规律就行了
	if(i&1) move_to(ch[4-i]);
	else move_to(ch[2-i]);
}
return;
```

---

## 作者：peixiaorui (赞：0)

## 题意

这是一道有意思的交互题。

你在一个迷宫里，你每次可以向上、下、左、右方向移动一格，交互库中的 `move_to` 函数会告诉你移动结果，成功返回 `1`，失败返回 `0`。
你需要绘制出这个迷宫的地图，`0` 代表可以走的“路”，`1` 代表不能走的“墙”。题目保证自己出生在“路”上且所有的“路”联通。

## 思路

很显然，这题可以用 dfs 解决。

我们用 dfs 模拟走迷宫的过程：

1. 每次向四个方向探索，看看能不能走（用 `move_to` 函数判断）或有没有走过。
2. 能走且没走过就走，标记走过的地方为“路”，即 `0`；否则将要走的方向标记为“墙”，即 `1`。
3. 在下一个点继续进行探索。

过程就是这么简单。

注意：

- 要初始化
- 不要走回头路，否则会因为 `move_to` 函数调用次数过多而 WA。
- **回溯！** dfs 回来时要记得 `move_to` 反方向，否则调用时会认为你的位置变动。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" bool move_to(char position);
const int dx[]={-1,0,1,0},dy[]={0,-1,0,1};
const char cf[]={'W','A','S','D'},cff[]={'S','D','W','A'};//cff为反方向
int maps[514][514];
void dfs(int x,int y){
	maps[x][y]=0;
	for(int i=0;i<4;i++){
		int nx=x+dx[i],ny=y+dy[i];
		if(maps[nx][ny]!=-1)continue;//走过了
		if(!move_to(cf[i])){maps[nx][ny]=1;continue;}//走不过去
		dfs(nx,ny);
		move_to(cff[i]);//记得回溯
	}
}
extern "C" string find_out_map(int X,int Y,int N){
	memset(maps,-1,sizeof(maps));//初始化
	dfs(X,Y);
	string s="";
	for(int i=1;i<=N;i++)for(int j=1;j<=N;j++){
		if(maps[i][j]==0)s+='0';
		else s+='1';
	}//记录地图
	return s;
}
```


---

## 作者：happybob (赞：0)

# 题意：

交互题，有一个地图，里面有些是障碍，有些是空地。需要实现函数 `string find_out_map(int x, int y, int n)`，其中 `x` 和 `y` 是一个地图的某个位置的坐标，这个位置没有障碍。同时可以调用 `bool move_to(char c)` 表示从当前位置往 `WASD` 走是否可行（即上左下右）。返回的 `string` 是地图哪些地方是障碍，哪些是空地。

# 解法：

这道题广搜深搜均可，但是这是个交互题，所以我们要注意一些交互题的问题。

我这里采取深搜解决，考虑从起点开始走四联通深搜，每次调用 `move_to` 函数，`move_to` 函数会更改当前在地图上的位置，所以要进行回溯使得位置不变。

注意，交互库不能询问过多，不然会显示 `too many operations`，所以我们要避免同一个点走两次，也就是在深搜过程中标记，也就是记录 `vis` 数组。

其余的就很简单了，注意 `extern "C"` 的使用，同时，交互题不需要先 `int main()` 或 `cin`、`cout` 等语句，只需要在函数前加上 `extern "C"` 即可，注意函数名的问题。

代码：

```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
using namespace std;

const int N = 505;
char c[N][N];

int dx[] = { -1, 0, 1, 0 };
int dy[] = { 0, -1, 0, 1 };
bool flag[N][N];
string pos = "WASD";

extern "C" bool move_to(char);

extern "C" void dfs(int x, int y)
{
	flag[x][y] = true;
	for (int i = 0; i < 4; i++)
	{
		int nx = x + dx[i], ny = y + dy[i];
		if (flag[nx][ny]) continue;
		if (move_to(pos[i]))
		{
			c[nx][ny] = false;
			dfs(nx, ny);
			if (pos[i] == 'W') move_to('S');
			else if (pos[i] == 'S') move_to('W');
			else if (pos[i] == 'A') move_to('D');
			else if (pos[i] == 'D') move_to('A');
		}
		else c[nx][ny] = true;
		flag[nx][ny] = true; // 注意写在 if else 后
	}
}

extern "C" string find_out_map(int x, int y, int n)
{
	memset(flag, false, sizeof(flag));
	memset(c, true, sizeof(c));
	c[x][y] = 0;
	dfs(x, y);
	string ans = "";
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			ans.push_back(c[i][j] ? '1' : '0'); // 其实第 i 位表示什么什么行列转化国立就是 n * n 的矩阵顺序排列
		}
	}
	return ans;
}
```


---


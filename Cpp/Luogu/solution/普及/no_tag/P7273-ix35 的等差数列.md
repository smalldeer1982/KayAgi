# ix35 的等差数列

## 题目背景

等差数列是指从第二项起，每一项与它的前一项的差等于同一个常数的一种数列，并称这个常数为公差。特别地，认为只有一项的数列也是等差数列，其公差视为 $0$。

## 题目描述

给定一包含 $n$ 项的正整数列 $a_1, a_2, \ldots , a_n$，满足 $1 \leq a_i \leq w$。

现可以进行若干次修改，一次修改可将数列的任意一项修改为任意 $\leq w$ 的正整数。

求：至少进行多少次修改，才能使得原数列变为一公差为非负整数的等差数列。

## 说明/提示

**【样例解释 #1】**

将 $a_3$ 修改为 $3$，$a_5$ 修改为 $5$。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（$20$ 分）：$n = 2$，$w = 2$。
- Subtask 2（$20$ 分）：$n, w \leq 100$。
- Subtask 3（$10$ 分）：$a_i = 1$。
- Subtask 4（$20$ 分）：$n, w \leq 1000$。
- Subtask 5（$30$ 分）：没有特殊限制。

对于 $100 \%$ 的数据，$1 \leq n, w \leq 3 \times 10^5$。

---

原始 idea：ix35。

## 样例 #1

### 输入

```
6 1000
1 2 999 4 72 6```

### 输出

```
2```

## 样例 #2

### 输入

```
10 2
2 1 2 2 1 1 2 2 2 2```

### 输出

```
3```

## 样例 #3

### 输入

```
1 1
1```

### 输出

```
0```

# 题解

## 作者：lndjy (赞：23)

听说题解都被叉了，写一发能过 hack 数据的。

考虑枚举公差，设公差为 $k$。

显然 $k\le \frac{w}{n}$。

那么，我们需要 $O(n)$ 的复杂度来计算给定公差下的最小值。

因为是等差数列，所以第 $i$ 项 $a_i$ 于首项 $a_1$ 存在以下关系：

$$a_i=a_1+k\times (i-1)$$

所以对于第 $i$ 项，该项不用修改当且仅当 $a_1=a_i-k\times(i-1)$。选择不用修改的最多的 $a_1$ 就是当前公差的最小次数。

然后这样被叉了会 WA。注意要判断 $a_n\le w$。$a_n=a_1+(n-1)\times k$。

```cpp
#include<iostream>
using namespace std;
int n,w,ans;
int a[300005],c[300005],t[300005];
int main()
{
	cin>>n>>w;
	if(n==1)
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++)
	cin>>a[i];
	ans=n;
	for(int k=0;1+(n-1)*k<=w;k++)
	{
		for(int i=1;i<=n;i++)
		if(a[i]-k*(i-1)>0&&a[i]-k*(i-1)+(n-1)*k<=w) t[a[i]-k*(i-1)]++,ans=min(ans,n-t[a[i]-k*(i-1)]);
		for(int i=1;i<=n;i++)
		if(a[i]-k*(i-1)>0) t[a[i]-k*(i-1)]=0;
	}
	cout<<ans;
 	return 0;
}
```


---

## 作者：犇犇犇犇 (赞：13)

题意：给定一个序列，求最少修改多少个数，可以使他变成一个值域在 $[1,w]$ 内的等差数列

首先观察到这是一个等差数列，所以我们只要确定好**数列中任意一个数**以及**公差**，我们就可以直接求出整个数列。

这道题规定了值域 $w$ , 以及项数 $n$，所以最后一项一定不会超过 $w$ ，设公差为 $d$ ，即 $d*(n-1)\leq w$ , 所以公差不会超过 $\lfloor\frac{w}{n-1}\rfloor$，想到可以枚举公差。

设首项为 $s$ ,对于任意第 i 个数 $a_i$，如果 $s+(i-1)\times d = a_i$ ， 那么此时 $a_i$ 不需要修改。

于是我们可以再枚举每一项 i ，求出每个数如果不需要修改，需要的首项为$s_i = a_i - (i-1)\times d$。如果 $s_i = s_j$，那么 i 和 j 此时处于同一个公差为 $d$ 的等差数列。为了使得这个等差数列尽量长，所以我们选择 s 数列中出现次数最多的数为首项。

以样例1为例：    

| 原数列 | 1 | 2 | 999 | 4 | 72 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |:----------: |
| 公差为0时需要的首项   | 1 | 2 | 999 | 4 | 72 | 6 |
| 公差为1时需要的首项   | 1 | 1 | 997 | 1 | 68 | 1 |
| 公差为2时需要的首项   | 1 | / | 995 | / | 64 | / |
| 公差为3时需要的首项   | 1 | / | 993 | / | 60 | / |

枚举每一项复杂度为$O(n)$，枚举公差复杂度为 $O(\lfloor\frac{w}{n-1}\rfloor)$，所以总复杂度为 $O(n\times \lfloor\frac{w}{n-1}\rfloor)=O(n+w)$

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 3e5+5;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int n,w,a[MAXN],cnt[MAXN];
vector<int> v[MAXN];//保存首项，v[d]表示公差为d时的首项数列
int main()
{
	n=read();w=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++) //枚举每一项
		for(int j=0;j*(i-1)<a[i] && j<=w;j++) //枚举公差
			v[j].push_back(a[i]-j*(i-1)); //放入公差为j时第i项的首项
	int maxx=0; //首项最多的出现次数
	for(int i=0;i<=w;i++) //枚举每一个公差
	{
		for(int j=0;j<v[i].size();j++)
			cnt[v[i][j]]=cnt[v[i][j]]+1;//统计
		for(int j=0;j<v[i].size();j++)
			if(cnt[v[i][j]]>maxx && v[i][j]+i*(n-1)<=w)//需要满足当前最后一项小于w
				maxx=cnt[v[i][j]];//找众数
		for(int j=0;j<v[i].size();j++)
			cnt[v[i][j]]=0;//清空 
	}
	cout<<n-maxx<<endl; //首项最多有maxx个，即有maxx个数不需要修改，需要修改n-maxx个数字
	return 0;
}
```


---

## 作者：SSerxhs (赞：6)

~~讨论区鲨疯了，我还找 EA 鲨了自己~~

~~FST 警告~~

由于值域为 $[1,w]$ 且公差 $d$ 非负，显然 $d\in[0,\frac{w-1}{n-1}]$

考虑枚举公差并 $O(nf(n))$ 计算，则复杂度为 $O(wf(n))$

具体计算方法是考虑假如 $a_i$ 不修改，那么新数列首项必定为 $a_i-(i-1)\times d$。

考虑枚举新数列的首项，那么答案就是 $n-cnt(a_1)$，其中 $cnt$ 是出现次数

新数列的首项范围是 $O(w)$ 的，但数量是 $O(n)$ 的，即只会通过上述柿子计算得出

那可以用一个 map 或者平衡树维护每个新首项的 $cnt$，取 $\max$ 即可

注意判断左右两边是否超出值域范围

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int ui;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
std::mt19937 rnd(time(0));
inline int sj(int n)
{
	unsigned int x=rnd();
	return x%n+1;
}
#define rand fst
template<typename typC> void read(register typC &x)
{
	register int c=getchar(),fh=1;
	while ((c<48)||(c>57))
	{
		if (c=='-') {c=getchar();fh=-1;break;}
		c=getchar();
	}
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	x*=fh;
}
template<typename typC> void write(register typC x)
{
	if (x<0) putchar('-'),x=-x;
	static int st[100];
	register int tp=1,y;st[1]=x%10;x/=10;
	while (x) y=x/10,st[++tp]=x-y*10,x=y;++tp;
	while (--tp) putchar(st[tp]|48);
}
template<typename typC> void write(register typC *a,register int num)
{
	for (register int i=1;i<=num;i++) write(a[i]),putchar(i==num?10:32);
}
#define space(x) write(x),putchar(32)
#define enter(x) write(x),putchar(10)
const int N=3e5+2,M=2e6+2,p=998244353;
inline void inc(register int &x,const int y)
{
	if ((x+=y)>=p) x-=p;
}
inline void dec(register int &x,const int y)
{
	if ((x-=y)<0) x+=p;
}
inline int ksm(register int x,register int y)
{
	register int r=1;
	while (y)
	{
		if (y&1) r=(ll)r*x%p;
		x=(ll)x*x%p;
		y>>=1;
	}
	return r;
}
int a[N];
map<int,int> s;
int T,n,m,d,i,j,k,x,y,z,ans,la;
int main()
{
	read(n);read(m);
	if (n==1) return puts("0"),0;
	for (i=1;i<=n;i++) read(a[i]);
	for (d=0;d*(n-1)<=(m-1);d++)
	{
		s.clear();la=0;
		for (i=1;i<=n;i++) if (a[i]>(i-1)*d&&a[i]<=m-d*(n-i)) la=max(la,++s[a[i]-i*d]);
		ans=max(ans,la);
	}
	printf("%d",n-ans);
}
```

---

## 作者：_lbw_ (赞：3)

upd：添加了特判

another upd：修改了边界

考虑每一种公差处理，此时数列最后是由从0开始的等差数列平移得到，通过与原序列做差扔进桶里求最大成立数量

我们考虑枚举，是 $O(n*(n+w))$ 然后我们发现其实只有  $\frac{w-1}{n-1}$ 是可行的

所以复杂度变为 $O(w+\frac{n^2}{w})$

但是处理每次答案时只有 $\min{n,w}$ 是要考虑的，我们可以把每次扔进同的数纪录下来

所以复杂度变为 $O(n+w)$

注意，有一些公差在固定 $a_i$ 不变时是不成立的，要把桶里的数变为 $-\inf$

最后统计答案时顺便把桶清零

[代码](https://www.luogu.com.cn/paste/ban0h6bq)


---

## 作者：Imakf (赞：2)

考虑暴力枚举公差，并暴力令数组中的某个数存在于等差数列中，检查其他数字要修改多少个即可。

注意到一个数字能存在于等差数列中，必须满足这个等差数列的 $a_1$，$a_n$ 都不能超过 $[1,w]$ 的界限。

不难发现公差的枚举上界是 $O\left(\dfrac{w}{n}\right)$，每次暴力检查复杂度 $O(n)$。故总复杂度为 $O(w)$。

```cpp
#include <bits/stdc++.h>

#define debug(...) fprintf(stderr ,__VA_ARGS__)
#define __FILE(x)\
	freopen(#x".in" ,"r" ,stdin);\
	freopen(#x".out" ,"w" ,stdout)
#define LL long long

const int MX = 3e5 + 23;
const LL MOD = 998244353;

int read(){
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9') x = x * 10 + k - '0' ,k = getchar();
	return x;
}

int n ,w;

int buc[MX * 2] ,a[MX];

int main(){
	n = read() ,w = read();
    if(n == 1)  return puts("0") ,0;
	for(int i = 1 ; i <= n ; ++i){
		a[i] = read();
	}

	int ans = n;
	for(int d = 0 ; 1 + d * (n - 1) <= w ; ++d){
		int mx = 0;
		for(int i = 1 ; i <= n ; ++i){
			if(a[i] + d * (n - i) <= w && a[i] - d * (i - 1) >= 1){
				mx = std::max(mx ,++buc[MX + a[i] - d * i]);
			}
		}
		ans = std::min(ans ,n - mx);
		for(int i = 1 ; i <= n ; ++i){
			if(a[i] + d * (n - i) <= w && a[i] - d * (i - 1) >= 1) --buc[MX + a[i] - d * i];
		}

	}
	printf("%d\n" ,ans);
	return 0;
}
```

---

## 作者：Celtic (赞：2)

$upd $ ：更正了代码，原来的代码数组开的不够大出现了 UB（但是好像 O2 下恰好能过？）


------------

题意：给你一个 $n$ 个正整数组成的序列，每个数在 $[1,w]$ 范围内，求最少进行几次修改，满足修改后每个数仍为正整数且在 $[1,w]$ 范围内，最终的序列为等差数列。

观察到 $w\leq 3\times 10^5$，所以我们考虑枚举公差 $d$ ，因为等差数列满足 $a_n=a_1+(n-1)\times d$ ，且 $a_1 \in[1,w],a_n\in[1,w]$，所以经过简单的运算，$d$ 应 $\leq \frac{w-1}{n-1}$。

这里记得特判 $n=1$ 的情况，因为这时 $n-1=0$，作分母时会 RE 。而又因为一个数也是等差数列，所以直接输出 $0$ 即可。

由于题目中说最终等差数列的公差为非负整数，所以我们 $d$ 的最终范围为 $[0,\frac{w-1}{n-1}]$ 

因为 $w\leq 3\times 10^5$ 所以我们可以在循环内 $O(n)$ 枚举序列的每个数 ，设 $now_i$ 表示当 $a_1=now_i$ 时，$a_i$ 不需要变化。由于 $a_n=a_1+(n-1)\times d$，所以 $now_i=a[i]-(i-1)*d$。

我们开一个数组记录每个 $now_i$ 出现的次数，因为 $now_i$ 可能为负数，所以让 $now_i$ 加上 $w$ 后存放在 $cnt$ 数组中，即令 $cnt_{now_i+w}$ 加 $1$ 。

求出 $now$ 数组后，我们再次从 $1$ 到 $n$ 枚举 $i$，记 $ans$ 为最终答案，那么如果 $a_i$ 不变(此时需要满足 $a_1=now_i$ 和 $a_n=now_i+(n-1)\times d$ 都在要求的范围内，因为这两个数一个是最大值一个是最小值)，则显然需要修改 $n-cnt_{now_i+w}$ 次（因为有$cnt_{now_i+w}$ 个数可以用同一个 $a_1$ 让他们不变）。如果 $a_i$ 变化，那在其他的 $a_1$ （即 $a_1 \neq now_i$ ） 时会计算到 $a_i$ 的贡献，不用在这里计算。

因为可以有全部变化的情况，所以 $ans$ 的初始值设为 $n$ 。

最后将 $cnt$ 数组清空，清空时不能 `memset` 因为这样一次清空复杂度为 $O(w)$，再乘上枚举公差的复杂度 $O(\frac{w}{n})$，总复杂度是 $O(\frac{w^2}{n})$ 的，当 $w$ 很大但 $n$ 很小时会超时。我们还是枚举 $i$ 将 $now_i$ 存在 $cnt$ 中的贡献减去，这样复杂度是一次 $O(n)$，前面几次枚举 $i$ 也是$O(n)$，乘上枚举公差总复杂度为 $O(\frac{w}{n})$，总复杂度为 $O(w)$ 。

具体细节见代码。

```cpp
#include<bits/stdc++.h>
#define N 301001
#define MAX 2001
#define inf 2e9
#define PI acos(-1)
#define eps 1e-10 
using namespace std;
typedef long long ll;
typedef double db;
inline void read(register ll &ret)
{
	ret=0;register char c=getchar();register bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,a[N],w,f[N],b[N],cnt[N<<1],now[N<<1],ans;
signed main()
{
	read(n);
	read(w);
	ans=n;
	for(register int i=1;i<=n;i++)
		read(a[i]);
	if(n==1)
	{
	    puts("0");
	    exit(0);
	}
	register ll all=(w-1)/(n-1);
	for(register int d=0;d<=all;d++)
	{
		for(register int i=1;i<=n;i++)
			now[i]=a[i]-(i-1)*d,cnt[now[i]+w]++;
		for(register int i=1;i<=n;i++)
		{
			if(now[i]>=1&&now[i]<=w&&now[i]+(n-1)*d<=w)
				ans=min(ans,n-cnt[now[i]+w]);
		}
		for(register int i=1;i<=n;i++)
			cnt[now[i]+w]--;
	}
	printf("%lld\n",ans);
	exit(0);
}
```



---


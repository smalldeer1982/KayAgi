# [COCI 2018/2019 #1] Zamjena

## 题目描述

Vlatko 喜欢与整数数组打交道。

他在纸上写下了两个分别包含 $N$ 个元素的数组，其中每个元素是一个整数，或者是表示一个变量的字符串（字符串仅包含小写字母）。

一个变量可以被任何一个整数替换，而两个数组中可能会多次出现同一变量。假如这种情况出现，则替换时需要将该变量出现过所有位置均替换会为待替换整数。

Vlatko 好奇能不能将所有变量替换为特定的整数，使得两个数组相等。当两个数组所有位置处的整数均对应相等，则两个数组相等。

## 说明/提示

#### 样例 3 解释

当把 $x,y,z$ 分别替换为 $2,3,3$ 时，两个数组相等，均为 $(2,3,2,3,3)$。

#### 数据规模与约定

对于 $20\%$ 的数据，每个变量在两个数组中仅出现一次。

对于另外 $20\%$ 的数据，数组中只包含两个变量 $x,y$。

对于 $100\%$ 的数据，$1 \le N \le 5 \times 10^4$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #1](https://hsin.hr/coci/archive/2018_2019/contest1_tasks.pdf)  _T2 Zamjena_。**

## 样例 #1

### 输入

```
3
3 1 2
3 1 x```

### 输出

```
DA```

## 样例 #2

### 输入

```
4
4 5 iks ipsilon
1 iks 3 iks```

### 输出

```
NE```

## 样例 #3

### 输入

```
5
x 3 x y 3
x y 2 z 3```

### 输出

```
DA```

# 题解

## 作者：qianxinyu (赞：4)

# [Zamjena](https://www.luogu.com.cn/problem/P7304)
## 题目大意
你有两个数组，数组中有很多数或变量，变量可以赋任意值。你需要判断是否存在一种方法让两个数组中的数两两对应相等。
## 思路
显然有三种对应关系：
- 当一个常量和一个常量对应时：如果两数相等，它们俩就人畜无害，如果两数不等，那么这两个数组就不可能两两对应相等。
- 当一个变量和一个常量对应时：这个变量没得选，只能跟随常量赋值，但如果这个变量已经和另一个常量对应了，那么就与条件一相似，无解。
- 当一个变量和一个变量对应时：相当于这两个变量同命了，和成一个变量，一个对应了常量，另一个要对应这个常量。

常量的判断简单。
那么任何处理对应呢？

可以想到用**并查集**将变量合并到常量或另一个变量上。
## 处理
##### 注：不了解处理中相关算法的可以翻到最底下。
### 1.输入
考虑到字符串输入，所以使用 `scanf("%s",a);` 进行输入。
### 2.判重
需要判断变量名相同。

很多人会想到用 map 进行处理。

但是，字符串的题就应该用字符串的方法：**字典树**。字典树数应该更适合做有关前缀的题，但是，这题也可以用上它。它会比 map 更优，因为 map 的单次查询需要 $O(\log{n})$ 的复杂度，而字典树可以实现 $O(|s|)$ 的复杂度。

所以目前我是[最优解](https://www.luogu.com.cn/record/123028359)。

然后可以先特判出数字，对字符串进行标号，让每一个变量都有自己专属的编号。

**代码**
```cpp
int trie[500010][30],cnt=1;//注意开10倍数组
int map[500010],cnt2=1010;//我不用万能头，所以可以用这个变量名
int query(char c[])
{
    int now=1,l=strlen(c);
    if(c[0]<='9'&&c[0]>='0')
    {
        now=0;
        for(int i=0;i<l;i++)
        {
            now*=10;
            now+=c[i]-'0';
        }
        return now;//数字
    }
    for(int i=0;i<l;i++)
    {
        if(!trie[now][c[i]-'a'+1])trie[now][c[i]-'a'+1]=++cnt;
        now=trie[now][c[i]-'a'+1];
    }
    if(!map[now])map[now]=++cnt2;
    return map[now];//变量
}
```
### 并查集
并查集板子很好写。

不过我不喜欢预处理，所以加了一个特判，在不需要处理 $0$ 时可以写成这样：
`if(f[x]==0)return f[x]=x;` 

**代码**
```cpp
int find(int x)
{
    if(f[x]==0)return f[x]=x;
    if(x!=f[x])return f[x]=find(f[x]);
    return f[x];
}
void hb(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)f[fy]=fx;
}
```
### 判断
分步处理。注意：优先把变量并进常量，在两个变量之间匹配过常量的最好不被并入其它变量中。

**代码**
```cpp
for(int i=1;i<=n;i++)
{
    int x=query(a[i]),y=query(b[i]);
    if(x==y)continue;//人畜无害
    int fx=find(x);
    if(x<=1000&&y<=1000)//常量不相等
    {
        printf("NE");
        return 0;
    }
    else if(x<=1000)hb(x,y);//y对应的变量等于x
    else if(fx<=1000)hb(x,y);//y对应的变量等于x对应的变量匹配的常量
    else hb(y,x);//其它情况
}
for(int i=1;i<=1000;i++)
{
    if(find(i)!=i)//常量被要求等于另一个常量
    {
        printf("NE");
        return 0;
    }
}
printf("DA");//全部匹配
```
## 完整代码
```cpp
#include<cstdio>
#include<cstring>
int trie[500010][30],cnt=1;
int map[500010],cnt2=1010;
int query(char c[])
{
    int now=1,l=strlen(c);
    if(c[0]<='9'&&c[0]>='0')
    {
        now=0;
        for(int i=0;i<l;i++)
        {
            now*=10;
            now+=c[i]-'0';
        }
        return now;
    }
    for(int i=0;i<l;i++)
    {
        if(!trie[now][c[i]-'a'+1])trie[now][c[i]-'a'+1]=++cnt;
        now=trie[now][c[i]-'a'+1];
    }
    if(!map[now])map[now]=++cnt2;
    return map[now];
}
int f[50010];
int find(int x)
{
    if(f[x]==0)return f[x]=x;
    if(x!=f[x])return f[x]=find(f[x]);
    return f[x];
}
void hb(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)f[fy]=fx;
}
char a[50010][15],b[50010][15];;
int n;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%s",a[i]);
    for(int i=1;i<=n;i++)scanf("%s",b[i]);
    for(int i=1;i<=n;i++)
    {
        int x=query(a[i]),y=query(b[i]);
        if(x==y)continue;
        int fx=find(x);
        if(x<=1000&&y<=1000)
        {
            printf("NE");
            return 0;
        }
        else if(x<=1000)hb(x,y);
        else if(fx<=1000)hb(x,y);
        else hb(y,x);
    }
    for(int i=1;i<=1000;i++)
    {
        if(find(i)!=i)
        {
            printf("NE");
            return 0;
        }
    }
    printf("DA");
    return 0;
}

```
## 算法了解传送门
### [并查集](https://www.luogu.com.cn/problem/P3367)
### [字典树](https://www.luogu.com.cn/problem/P8306)

---

## 作者：_ouhsnaijgnat_ (赞：4)

建议为绿。

## 题目大意

给你两个数组，其中可能会包含变量，他让你将变量赋一个值，相同变量赋值必须相同，不同的变量赋值可以相同。

在你给他一系列赋值后，两个数组能否相同。

## 思路

可以用字符串先输入，如果是数字，在转化成数字，否则将这个变量给他一个编号。

我们可以用 $map$ 这个数据结构，将字符串变成编号。

再用搜索将变量全部赋值，最后在判断是否一样。

## 代码

```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
#include<map>
#include<cstring>
using namespace std;
const int maxn=5e4+9;
map<string,int>Map;
vector<int>h[maxn];
int a[maxn],b[maxn],v[maxn],cnt;
int number(string s){
	int x=0;
	for(int i=0;i<s.size();i++){
		x=x*10+s[i]-'0';
	}
	return x;
}
int id(string s){//将字符串化成编号 
	if(!Map.count(s))
		Map[s]=++cnt;
	return Map[s];
}
void dfs(int cur,int t){
	if(v[cur]!=-1)return;
	v[cur]=t;
	for(int i=0;i<h[cur].size();i++)
		dfs(h[cur][i],t);
}
int main(){
	memset(v,-1,sizeof(v));
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		if(s[0]>='0'&&s[0]<='9'){//将字符串化成数字 
			a[i]=number(s);
		}else a[i]=-id(s);//变成负数，以免与数字弄混 
	}
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		if(s[0]>='0'&&s[0]<='9'){
			b[i]=number(s);
		}else b[i]=-id(s);//同上 
		if(a[i]<0&&b[i]<0){
			h[-a[i]].push_back(-b[i]);
			h[-b[i]].push_back(-a[i]);
		}
	}
	for(int i=1;i<=n;i++){
		if(a[i]<0&&b[i]>=0)dfs(-a[i],b[i]);
		if(b[i]<0&&a[i]>=0)dfs(-b[i],a[i]);
	}
	int o=1;
	for(int i=1;i<=n;i++){
		int d1=a[i];
		int d2=b[i];
		if(a[i]<0)d1=v[-a[i]];
		if(b[i]<0)d2=v[-b[i]];
		if(d1!=d2){
			o=0;
			break;
		}
	}
	if(o)cout<<"DA";
	else cout<<"NE";
	return 0;
}
```


---

## 作者：lflby (赞：2)

# 思路

这道题对于每个元素可以分四类。

### 两个数字

直接判断即可。

### 两个变量

1. 两个都有值，直接判断。
2. 一个有值，直接存入并将与另一个的同值变量得也更改。
3. 两个都无值，互相加入同值变量。

### 一个数字一个变量

若变量已有值：直接判断。

若没有，将数字存入变量，并将变量的同值变量的也改变。

~~如果没过，可以多复制几遍。~~

# Code


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int res = 0,f = 1;
	char ch = getchar();
	while (ch<'0'||ch>'9') f = (ch=='-'?-1:1),ch = getchar();
	while (ch>='0'&&ch<='9') res = (res<<3)+(res<<1)+(ch^48),ch = getchar();
	return res*f;
}
void write(int x)
{
	if (x<0) putchar('-'),x=-x;
	if (x>9) write(x/10);
	putchar(x%10+'0');
}
void writech(int x,char ch){write(x),putchar(ch);}//快读快写 
const int N = 5e4+5;
int n;
string a[N],b[N];
map<string,string> m;//存变量的值 
map<string,vector<string> > mm;//存变量的同值变量 
signed main()
{
	n=read();
	for (int i = 1; i <= n; i++) cin>>a[i],m[a[i]]="-1",mm[a[i]].push_back("LJK");//预处理防map为空 
	for (int i = 1; i <= n; i++) cin>>b[i],m[b[i]]="-1",mm[b[i]].push_back("LJK");
	for (int i = 1; i <= n; i++)
	{
		if (a[i][0]>='0'&&a[i][0]<='9'&&b[i][0]>='0'&&b[i][0]<='9')//两个数值 
		{
			if (a[i]!=b[i])
			{
				puts("NE");
				return 0;
			}
		}
		else if ((a[i][0]<'0'||a[i][0]>'9')&&(b[i][0]<'0'||b[i][0]>'9'))//两个变量 
		{
			if (m[a[i]]!="-1"&&m[b[i]]!="-1"&&m[a[i]]!=m[b[i]])
			{
				puts("NE");
				return 0;
			}
			else if (m[a[i]]!="-1"&&m[b[i]]=="-1")
			{
				m[b[i]]=m[a[i]];
				for (int j = 0; j < mm[b[i]].size(); j++)
				{
					m[mm[b[i]][j]]=m[a[i]];
				}
			}
			else if (m[a[i]]=="-1"&&m[b[i]]!="-1")
			{
				m[a[i]]=m[b[i]];
				for (int j = 0; j < mm[a[i]].size(); j++)
				{
					m[mm[a[i]][j]]=m[b[i]];
				}
			}
			else if (m[a[i]]=="-1"&&m[b[i]]=="-1")
			{
				mm[a[i]].push_back(b[i]);
				mm[b[i]].push_back(a[i]);
			}
		}
		else if ((a[i][0]>='0'&&a[i][0]<='9')&&(b[i][0]<'0'||b[i][0]>'9'))//一个数字一个变量 
		{
			if (m[b[i]]!="-1")
			{
				if (m[b[i]]!=a[i])
				{
					puts("NE");
					return 0;
				}
			}
			else
			{
				m[b[i]]=a[i];
				for (int j = 0; j < mm[b[i]].size(); j++)
				{
					m[mm[b[i]][j]]=a[i];
				}
			}
		}
		else//一个数字一个变量2 
		{
			if (m[a[i]]!="-1")
			{
				if (m[a[i]]!=b[i])
				{
					puts("NE");
					return 0;
				}
			}
			else
			{
				m[a[i]]=b[i];
				for (int j = 0; j < mm[a[i]].size(); j++)
				{
					m[mm[a[i]][j]]=b[i];
				}
			}
		}
	}
	for (int i = 1; i <= n; i++)//再来一次 
	{
		if (a[i][0]>='0'&&a[i][0]<='9'&&b[i][0]>='0'&&b[i][0]<='9')
		{
			if (a[i]!=b[i])
			{
				puts("NE");
				return 0;
			}
		}
		else if ((a[i][0]<'0'||a[i][0]>'9')&&(b[i][0]<'0'||b[i][0]>'9'))
		{
			if (m[a[i]]!="-1"&&m[b[i]]!="-1"&&m[a[i]]!=m[b[i]])
			{
				puts("NE");
				return 0;
			}
			else if (m[a[i]]!="-1"&&m[b[i]]=="-1")
			{
				m[b[i]]=m[a[i]];
				for (int j = 0; j < mm[b[i]].size(); j++)
				{
					m[mm[b[i]][j]]=m[a[i]];
				}
			}
			else if (m[a[i]]=="-1"&&m[b[i]]!="-1")
			{
				m[a[i]]=m[b[i]];
				for (int j = 0; j < mm[a[i]].size(); j++)
				{
					m[mm[a[i]][j]]=m[b[i]];
				}
			}
			else if (m[a[i]]=="-1"&&m[b[i]]=="-1")
			{
				mm[a[i]].push_back(b[i]);
				mm[b[i]].push_back(a[i]);
			}
		}
		else if ((a[i][0]>='0'&&a[i][0]<='9')&&(b[i][0]<'0'||b[i][0]>'9'))
		{
			if (m[b[i]]!="-1")
			{
				if (m[b[i]]!=a[i])
				{
					puts("NE");
					return 0;
				}
			}
			else
			{
				m[b[i]]=a[i];
				for (int j = 0; j < mm[b[i]].size(); j++)
				{
					m[mm[b[i]][j]]=a[i];
				}
			}
		}
		else
		{
			if (m[a[i]]!="-1")
			{
				if (m[a[i]]!=b[i])
				{
					puts("NE");
					return 0;
				}
			}
			else
			{
				m[a[i]]=b[i];
				for (int j = 0; j < mm[a[i]].size(); j++)
				{
					m[mm[a[i]][j]]=b[i];
				}
			}
		}
	}
	puts("DA");
	return 0; 
}

```

---

## 作者：chl090410 (赞：2)

## The Solution to P7304

### 题意

有两个数组，数组中有一些变量，相同的变量要赋相同的值,问能否通过对变量赋值使两个数组各个数位上的数均相等。

### 分析

- 若 $a_i$、$b_i$ 均为数字，此时只需判断 $a_i$ 是否等于 $b_i$ 即可。若 $a_i\ne b_i$，那就无法实现各个数位上的数均相等，此时直接输出 NE 即可。

- 若 $a_i$ 或 $b_i$ 为变量，另一个为数字，若变量已经赋值且与数字不一样，那么就输出 NE，否则就将该数字赋给该变量。

- 若 $a_i$、$b_i$均为变量，则 $a_i=b_i$，我们可以用[并查集](https://oi-wiki.org/ds/dsu/)记录相等的变量，若两个变量属于同一个集合但被赋了不一样的值，那就无法满足题意，此时直接输出 NE 即可。

若以上两种不合法情况均未发生，则说明能通过赋值使两个数组相等，此时输出 DA。

### 下面附上完整代码

```
#include <bits/stdc++.h>
using namespace std;
map<string,string> fa;
map<string,int> m;
string a[50005],b[50005];
int n;
string find(string x){
	if(x!=fa[x]){
		fa[x]=find(fa[x]);
	}
	return fa[x];
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){
		if(!isdigit(a[i][0])){
			fa[a[i]]=a[i];
		}
		if(!isdigit(b[i][0])){
			fa[b[i]]=b[i];
		}
	}
	for(int i=1;i<=n;i++){
		if(a[i]==b[i]){
			continue;
		}else{
			if(isdigit(a[i][0])&&isdigit(b[i][0])){
				cout<<"NE";
				return 0;
			}
			if(isdigit(a[i][0])&&!isdigit(b[i][0])){
				if(m[b[i]]!=a[i][0]-'0' && m[b[i]]!=0){
					cout<<"NE";
					return 0;
				}
				m[b[i]]=a[i][0]-'0';
			}
			if(!isdigit(a[i][0])&&isdigit(b[i][0])){
				if(m[a[i]]!=b[i][0]-'0' && m[a[i]]!=0){
					cout<<"NE";
					return 0;
				}
				m[a[i]]=b[i][0]-'0';
			}
			if(!isdigit(a[i][0])&&!isdigit(b[i][0])){
				fa[find(a[i])]=find(b[i]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(!isdigit(a[i][0])){
			
			fa[a[i]]=find(a[i]);//cout<<m[fa[a[i]]]<<" ";
		}
		if(!isdigit(b[i][0])){
			
			fa[b[i]]=find(b[i]);//cout<<m[fa[b[i]]]<<" "; 
		}
	}
	for(int i=1;i<=n;i++){
		if(!isdigit(a[i][0])){
			if(m[fa[a[i]]]!=0 && m[fa[a[i]]]!=m[a[i]] && m[a[i]]!=0){
				cout<<"NE";
				return 0;
			}
			if(m[fa[a[i]]]==0){
				m[fa[a[i]]]=m[a[i]];
			}
		}
		if(!isdigit(b[i][0])){
			if(m[fa[b[i]]]!=0 && m[fa[b[i]]]!=m[b[i]] && m[b[i]]!=0){
				cout<<"NE";
				return 0;
			}
			if(m[fa[b[i]]]==0){
				m[fa[b[i]]]=m[b[i]];
			}
		}
	}
	cout<<"DA";
	return 0;
}

---

## 作者：Autream (赞：2)

#### 题意简述
给定两行长度为 $N$ 的数组 $a$ 和 $b$，其中包含数字和变量，变量名为一个字符串。

问是否可以通过将变量赋值使得 $a$ 和 $b$ 相等（同一个变量名只能使用一个值）。

---
#### 题目分析
看到大佬的题解都是并查集，可是我不会，所以就暴力做了出来。~~（这不水题吗为什么要用并查集）~~

直接模拟，先用一个 `map<string,int> vis` 把 $a$ 和 $b$ 中的变量标记为一个特定的数，再用一个 `map<int,int> mp` 记录每个变量应该变什么，然后遍历一遍查看是否冲突。

怎么记录每个变量应该变成什么呢？我们可以分类讨论。
1. 如果 $a_i$ 是变量，$b_i$ 是数字，那么 `mp[a[i]]=b[i]`。
2. 如果 $b_i$ 是变量，$a_i$ 是数字，那么 `mp[b[i]]=a[i]`。
3. 如果 $a_i$ 和 $b_i$ 都是变量，先看它们的其中一个是否可以转换为数字。如果 $a_i$ 能，那么就先把 $a_i$ 转化为 `mp[a[i]]`，然后 `mp[b[i]]=a[i]`；如果 $b_i$ 能，那么就先把 $b_i$ 转化为 `mp[b[i]`，然后 `mp[a[i]]=b[i]`。

于是我们可以得到这份代码：
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=1e5+5;
std::unordered_map<std::string,int> vis;
std::unordered_map<int,int> mp;
int n,cnt,a[N],b[N];
signed main() {
    std::cin>>n;
    rep(i,1,n) {
        std::string s;
        std::cin>>s;
        if(s[0]>='0'&&s[0]<='9') {
            a[i]=atoi(s.c_str());
        } else {
            a[i]=1000+(!vis[s]?vis[s]=++cnt:vis[s]);
        }
    }
    rep(i,1,n) {
        std::string s;
        std::cin>>s;
        if(s[0]>='0'&&s[0]<='9') {
            b[i]=atoi(s.c_str());
        } else {
            b[i]=1000+(!vis[s]?vis[s]=++cnt:vis[s]);
        }
    }
    int t=100;
    rep(i,1,n) {
        if(a[i]>1000&&b[i]>1000) {
            if(mp[a[i]]) {
                a[i]=mp[a[i]];
                if(!mp[b[i]]) {
                    mp[b[i]]=a[i];
                    b[i]=a[i];
                }
            }
            if(mp[b[i]]) {
                b[i]=mp[b[i]];
                if(!mp[a[i]]) {
                    mp[a[i]]=b[i];
                    a[i]=b[i];
                }
            }
        }
        if(a[i]>1000&&b[i]<=1000) {
            if(!mp[a[i]]) {
                mp[a[i]]=b[i];
                a[i]=b[i];
            } else if(mp[a[i]]!=b[i]) {
                puts("NE");
                exit(0);
            }
        }
        if(b[i]>1000&&a[i]<=1000) {
            if(!mp[b[i]]) {
                mp[b[i]]=a[i];
                b[i]=a[i];
            } else if(mp[b[i]]!=a[i]) {
                puts("NE");
                exit(0);
            }
        }
    }
    rep(i,1,n) {
        if(mp[a[i]]!=0&&a[i]>1000) {
            a[i]=mp[a[i]];
        }
        if(mp[b[i]]!=0&&b[i]>1000) {
            b[i]=mp[b[i]];
        }
        if(b[i]!=a[i]&&a[i]<=1000&&b[i]<=1000) {
            puts("NE");
            exit(0);
        }
    }
    puts("DA");
    // arrout(a,n);
    // puts("");
    // arrout(b,n);
    return 0;
}
```
结果 59 分，检查发现是有些情况一次更新不完，~~根据我多年的骗分经验~~，观察数据范围 $1 \leq N \leq 5 \times 10^4$，于是我们可以重复检查 100 遍，确保每个数都被更新到。

可以成功水过此题。

---

## 作者：_caiji_ (赞：1)

并查集好题。

前置知识：[并查集](https://www.luogu.com.cn/blog/My-luoguBuoke-HZR/solution-p3367)。

------------

我们可以先假设问题有解，标记每对 $a_i,b_i$ 是相等的，由于相等关系具有传递性，因此可以用并查集维护。

然后，检查一下有没有两个整数常量被标记成相等，如果有，说明假设不成立，输出无解。否则，说明假设是成立有解。

[手造几组样例并验证](https://www.luogu.com.cn/paste/g0zipx3y)，可以发现是对的。

------------

接下来是实现。我将以 Q/A 的方式讲一下实现过程中遇到的困难：

------------

Q：如何实现「把变量与变量/常量标记为相等」这一过程？

A：观察到 $1\leq \text{常量} < 10^3$，可以把所有变量从 $10^3+1$ 开始标一个号，然后把这些变量按照常量处理。

------------

Q：如何快速判断输入的是一个常量还是变量？

A：`cin` 读取数据失败时，会产生一个错误状态。我们可以利用这个错误状态，判断输入的是常量还是变量。具体代码：
```cpp
int x;
cin>>x;//先假设它是个常量
if(cin.fail()){//错误了
	cin.clear();//去掉错误状态
    //cin.sync();//清空缓冲区，在这道题里不加也行
    string s;
    cin>>s;
    //s 为输入的变量名
}else{
	//x 为输入的常量
}
```

------------

Q：如何保证相同的变量的标号一定相同，而不同的变量的标号一定不相同？

A：使用 `std::map`，记为 $map$。如果 $map$ 之前已经有记录过这个变量名，直接返回这个变量名的标号，否则，记录下这个变量名并给它分配一个新标号。

------------

Q：如何检查有没有两个整数常量被标记成相等？

A：两种方法：一是 $O((10^3)^2)$ 暴力枚举；二是标记每个整数常量在并查集里的祖先，如果出现重复标记的情况，说明有两个整数常量被标记成相等。

------------

下面，给出我的代码实现：
```cpp
#include <map>
#include <string>
#include <iostream>
using namespace std;
template<int N> struct UnionSet{
    int fa[N+10];
    UnionSet(){for(int i=1;i<=N;i++) fa[i]=i;}
    int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
    void merge(int x,int y){fa[find(y)]=find(x);}
    bool query(int x,int y){return find(x)==find(y);}
};
map<string,int> anti;
UnionSet<51010> s;
int n,a[50010],b[50010];
int cnt=1e3;
bool vis[51010];
int get(string s){
    if(anti.find(s)==anti.end()) anti[s]=++cnt;//std::map 的 find 函数找不到时，会返回尾部迭代器
    return anti[s];
}
void input(int a[]){
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(cin.fail()){
            cin.clear(),cin.sync();
            string s;
            cin>>s;
            a[i]=get(s);
        }
    }
}
int main(){
    cin>>n;
    input(a);
    input(b);
    for(int i=1;i<=n;i++) s.merge(a[i],b[i]);
    for(int i=1;i<=1000;i++){
        int tmp=s.find(i);
        if(vis[tmp]){
            cout<<"NE"<<endl;
            return 0;
        }
        vis[tmp]=1;
    }
    cout<<"DA"<<endl;
    return 0;
}
```


---

## 作者：SUNCHAOYI (赞：1)

一道并查集的题目，实现的时候细节较多。

【**注：**以下 `fa` 与 `num` 数组的 $1--n$ 存第一个数组， $n + 1--2n$ 存第二个数组。】  
因为与字符有关系，所以可以用 `map` 来记录每一个变量/数字所出现的第一个位置并标记 `fa[i] = i`。


```
if (num[a[i]] != 0) fa[i] = num[a[i]]; 
else fa[i] = num[a[i]] = i;
```

接下来就要以 $O(n)$ 的时间复杂度依次判断每个数组的第 $i$ 位是否符合要求了。这里需要进行分类讨论，有以下几种情况 (设两个数组分别为 `a` 与 `b`，`find (int x)` 为找到 $x$ 的父亲)：

1. $a_i$ 与 $b_i$ 均为常量 直接比较是否相等即可 
2. $a_i$ 为常量， $b_i$ 为变量   
	2.1. $b_i$ 的值已经确定 比较是否相等   
   2.2. $b_i$ 的值未确定 `fa[find (b[i])) = find (a[i])` 
3. $a_i$ 为变量， $b_i$ 为常量   
	3.1. $a_i$ 的值已经确定 比较是否相等   
   3.2. $a_i$ 的值未确定 `fa[find (a[i])) = find (b[i])` 
4. $a_i$ 与 $b_i$ 均为变量   
	4.1. $a_i$ 与 $b_i$ 均已经确定 比较是否相等   
   4.2. 只有 $a_i$ 已经确定 `fa[find (b[i])) = find (a[i])`   
   4.3. 只有 $b_i$ 已经确定 `fa[find (a[i])) = find (b[i])`  
   4.4. $a_i$ 与 $b_i$ 均未确定 随便选一个作为父亲，进行合并
  
于是就有代码：

```
bool correct (int x)
{
	//bool isnumber[MAX << 1],isok[MAX << 1];//是否是数字；是否已确定 
	int dx = find (num[a[x]]),dy = find (num[b[x]]);
	if (isnumber[x] && isnumber[x + n])
	{
		if (a[x] != b[x]) return 0;
		else return 1;
	}
	else if (isnumber[x])
	{
		if (dx == dy) {isok[dx] = 1;return 1;} 
		else if (!isok[dy]) fa[dy] = dx,isok[dy] = 1;
		else return 0;
	}
	else if (isnumber[x + n])
	{
		if (dx == dy) {isok[dx] = 1;return 1;}
		else if (!isok[dx]) fa[dx] = dy,isok[dx] = 1;
		else return 0;
	}
	else
	{
		if (!isok[dx] && !isok[dy]) fa[dx] = dy;
		else if (!isok[dx]) fa[dx] = dy,isok[dx] = 1;
		else if (!isok[dy]) fa[dy] = dx,isok[dy] = 1;
		else if (dx != dy) return 0;  
	}
	return 1;
}
```

最后若所有返回值都是 `1`，则符合题意；否则就是不符合。

---

## 作者：Error_Eric (赞：1)

### 前言

估——值——

### 正文

容易想到以下思路：

- 若 $a_i,b_i$ 是两个不相同的常量，那么没有合法解。

- 若 $a_i,b_i$ 中有一个是常量，有一个是没有赋值的变量，我们将变量赋值为这个常量。

- 若 $a_i,b_i$ 中有一个是常量，另有一个是已经赋值的变量，并且两者不相等，那么没有合法解。

- 若没有上述两种没有合法解的情况产生，那么有合法解。

所以把 $i$ 从 $1$ 遍历到 $n$即可。

这种想法是错误的。原因如下：

```
3
x 1 2
y x y
```
所以我们应当考虑用[并查集](https://www.luogu.com.cn/problem/P3367)解决这个问题。

简而言之，就是把两个相同的变量合并为一个集合，然后解决这个问题。

这里要注意一下，文中提到的对变量的操作，均需要转化为对于集合的操作。

总结起来，这道题的解法如下：

- 若 $a_i,b_i$ 是两个不相同的常量，或者已赋值的变量，那么没有合法解。

- 若 $a_i,b_i$ 中有一个是常量，有一个是没有赋值的变量，我们将变量赋值为这个常量。


- 若 $a_i,b_i$ 两个都是未赋值的变量，将两个变量合并为一个。

- 若没有上述两种没有合法解的情况产生，那么有合法解。


```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<map>
using namespace std;
map<string,int>name;
string gt;int num[50005*2];//每个集合的值
int n,a[50005],b[50005],cnt,f[50005*2];
int fi(int x){//并查集，不会的跳转P3367。
	if(f[x]==x)return x;
	else return f[x]=fi(f[x]);//路径压缩。
}
void getin(int &I){//输入。
	cin>>gt;bool digit=0;//表示是不是数字。
	for(int i=0;i<gt.length();i++)
		if(isdigit(gt[i]))digit=1;
	if(digit){
		int ii=0;I=0;
		while(!isdigit(gt[ii]))ii++;
		while( isdigit(gt[ii]))I=I*10+gt[ii]-'0',ii++;
	}//不理解的建议搜索快读。
	else {
		if(name[gt])I=-name[gt];
		else I=-(name[gt]=++cnt);
	}//不理解的建议搜索map映射。
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n*2;i++)num[i]=-1,f[i]=i;//赋初值，其中-1 表示没有被赋值。
	for(int i=1;i<=n;i++)getin(a[i]);//输入。
	for(int i=1;i<=n;i++)getin(b[i]);//负数表示变量，整数表示常数。
	for(int i=1;i<=n;i++){
		if(a[i]>0 and b[i]>0 and a[i]!=b[i])return puts("NE"),0;//如果两个数均为常数，且两数不相等，则没有合法解。
		else if(a[i]>0 and b[i]<0){
			if(num[fi(-b[i])]!=-1 and num[fi(-b[i])]!=a[i])return puts("NE"),0;//一个是已经赋值的变量，一个是与之不相等的常量，则没有合法解。
			else if(num[fi(-b[i])]==-1)num[fi(-b[i])]=a[i];//一个是没有赋值的变量，另一个是常量，直接赋值。
		}
		else if(a[i]<0 and b[i]>0){
			if(num[fi(-a[i])]!=-1 and num[fi(-a[i])]!=b[i])return puts("NE"),0;//反过来一下。
			else if(num[fi(-a[i])]==-1)num[fi(-a[i])]=b[i];
		}
		else if(a[i]<0 and b[i]<0){//两者均为变量
			if(num[fi(-a[i])]!=-1 or num[fi(-b[i])]!=-1){//若有一者已经赋值
				if(num[fi(-a[i])]!=-1 and num[fi(-b[i])]!=-1){//两者均赋值。
					if(num[fi(-a[i])]!=num[fi(-b[i])])
						return puts("NE"),0;
				}
				else{//将其中一者的值赋到另一者上
					if(num[fi(-a[i])]!=-1)f[fi(-b[i])]=fi(-a[i]);
					else f[fi(-a[i])]=fi(-b[i]);
				}	
			}
			else f[fi(-a[i])]=fi(-b[i]);//两者均未赋值，合并两个集合。
		}
	}
	return puts("DA"),0; //没有出现上述情况，有合法解。
}
```



---

## 作者：125125A (赞：0)

# 前言
随机跳题跳过来的，当我看见 $619$ 提交但是只有 $111$ 通过的时候，我还以为是什么世纪级难题。
# 正文
[题目传送门](https://www.luogu.com.cn/problem/P7304)
## 题目大意
有两个数组，其中可能会包含变量，将变量赋一个值，相同变量赋值必须相同，不同的变量赋值可以相同。

在一系列赋值后，两个数组能否相同。
## 思路
可以用字符串先输入，如果是数字，在转化成数字，否则将这个变量给一个编号。

我们可以用 map 这个数据结构，将字符串变成编号。

再用搜索将变量全部赋值，最后在判断是否一样。

## Code:

```
# include <bits/stdc++.h>
using namespace std;

const int maxn = 5e4 + 9;
map<string, int>Map;
vector<int>h[maxn];
int arr[maxn], brr[maxn], v[maxn], cnt;

int number(string s) {
	int x = 0;
	
	for (int i = 0; i < s.size(); i++) {
		x = x * 10 + s[i] - '0';
	}
	
	return x;
}

int id(string s) {
	if (!Map.count(s))
		Map[s] = ++cnt;
	
	return Map[s];
}

void dfs(int cur, int t) {
	if (v[cur] != -1)return;
	
	v[cur] = t;
	for (int i = 0; i < h[cur].size(); i++)
		dfs(h[cur][i], t);
}

int main() {
	
	memset(v, -1, sizeof(v));
	
	int n;
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		string s;
		cin >> s;
		
		if (s[0] >= '0' && s[0] <= '9') {
			arr[i] = number(s);
		} 
		else arr[i] = -id(s);
	}
	
	for (int i = 1; i <= n; i++) {
		string s;
		cin >> s;
		
		if (s[0] >= '0' && s[0] <= '9') {
			brr[i] = number(s);
		} 
		else brr[i] = -id(s);
		
		if (arr[i] < 0 && brr[i] < 0) {
			h[-arr[i]].push_back(-brr[i]);
			h[-brr[i]].push_back(-arr[i]);
		}
	}
	
	for (int i = 1; i <= n; i++) {
		if (arr[i] < 0 && brr[i] >= 0) dfs(-arr[i], brr[i]);
		if (brr[i] < 0 && arr[i] >= 0) dfs(-brr[i], arr[i]);
	}
	
	int o = 1;
	for (int i = 1; i <= n; i++) {
		int d1 = arr[i];
		int d2 = brr[i];
		if (arr[i] < 0) d1 = v[-arr[i]];
		if (brr[i] < 0) d2 = v[-brr[i]];
		if (d1 != d2) {
			o = 0;
			break;
		}
	}
	
	if (o)cout << "DA";
	else cout << "NE";
	
	return 0;
}
```
~~码风猎奇，勿喷。~~

---

## 作者：lin_A_chu_K_fan (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7304)
# 题意
给两个数组，由数和变量组成，变量可以自由赋值。问是否存在一种方法让两个数组中的数两两相等。
# 思路
先用字符串输入，若是数字就转换成数字，否则给它一个编号。

再用 `map` 将字符串变成编号，并利用搜索将变量赋值，最后判断能否实现。

思路就这样，为了维护社区秩序（实际上是懒）代码就不给了，求关~

---


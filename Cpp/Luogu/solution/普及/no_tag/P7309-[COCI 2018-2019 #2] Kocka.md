# [COCI 2018/2019 #2] Kocka

## 题目背景

在儿童游乐场里，编者被一个由金属横杠组成的立方体所吸引，于是他想出了一个有趣的问题。这里是二维的版本。

## 题目描述

给定一个 $N \times N$ 的矩阵。有些区域被堵塞，而有些区域是空白的。在观察的过程中，他从 $4$ 个方向对该矩阵进行观察。先从左侧开始，记录下每一行的第一个堵塞处前有几排是空出的。如果没有堵塞，则记下 $-1$。接着他如法炮制，分别从右侧、上方和下方进行观察并记录。

这样，他总共写下了 $4N$ 个数字，其中每个方位均写下了 $N$ 个数字。然而，未知的恶棍摧毁了矩阵，他所剩的只有他写下的数字。

编者想问你他写的数字是否存在错误，即是否可以通过这些数字还原出一个 $N \times N$ 的矩阵。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/50ve94cy.png)

#### 数据规模与约定

对于 $40\%$ 的数据，$N \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$-1 \le L_i,R_i,U_i,D_i \lt N$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #2](https://hsin.hr/coci/archive/2018_2019/contest2_tasks.pdf)  _T2 Kocka_。**

## 样例 #1

### 输入

```
3
-1 2 0
-1 0 1
2 2 1
0 0 1```

### 输出

```
DA```

## 样例 #2

### 输入

```
3
-1 0 1
-1 2 1
-1 2 -1
1 0 -1```

### 输出

```
NE```

# 题解

## 作者：wandereman (赞：2)

## 思路
我们想要知道怎么成功，不如知道怎么失败，那么我们就把失败的情况列出来：    
- 一条行或列有堵塞的记录，而另一条行或列没有，如下情况：
```cpp
if(l[i] != r[i] && (l[i] == -1 || r[i] == -1)){
	cout<<"NE"<<endl;
	return 0;
}
if(u[i] != d[i] && (u[i] == -1 || d[i] == -1)){
	cout<<"NE"<<endl;
	return 0;
}
```  
- 一边是空的，却把另一边堵塞的覆盖了，如下情况：
```cpp
if(l[i] + r[i] >= n){
	cout<<"NE"<<endl;
	return 0;
}
if(u[i] + d[i] >= n){
	cout<<"NE"<<endl;
	return 0;
}
```
- 某一行的堵塞把另一行的堵塞覆盖了，如下情况：
```cpp
if(u[l[i] + 1] > i && d[l[i] + 1] > (n - i + 1){
	cout<<"NE"<<endl;
	return 0;
}
```
最后如果这些情况都不满足，就直接输出 DA。
## AC code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e5+15;
ll n;
ll l[N],r[N],u[N],d[N];
int main() {
	for(i = 1;i <= n;i++){
		cin>>l[i];
	}
	for(i = 1;i <= n;i++){
		cin>>r[i];
	}
	for(i = 1;i <= n;i++){
		cin>>u[i];
	}
	for(i = 1;i <= n;i++){
		cin>>d[i];
	}
	for(i = 1;i <= n;i++){
		if(l[i] + r[i] >= n){
			cout<<"NE"<<endl;
			return 0;
		}
		if(u[i] + d[i] >= n){
			cout<<"NE"<<endl;
			return 0;
		}
		if(l[i] != r[i] && (l[i] == -1 || r[i] == -1)){
			cout<<"NE"<<endl;
			return 0;
		}
		if(u[i] != d[i] && (u[i] == -1 || d[i] == -1)){
			cout<<"NE"<<endl;
			return 0;
		}
		
		if(u[l[i] + 1] > i && d[l[i] + 1] > (n - i + 1)){
			cout<<"NE"<<endl;
			return 0;
		}
	}
	cout<<"DA"<<endl;
	return 0;
}
```

---

## 作者：piantouqu (赞：2)

**题目链接**

[P7309 [COCI2018-2019#2] Kocka](https://www.luogu.com.cn/problem/P7309)

### 分析
一共有三种矛盾：

1. 一边记录这行（列）堵塞，另一边记录这行（列）没堵塞，记录矛盾。
```cpp
if (l[i] != r[i] && (l[i] == -1 || r[i] == -1)) {
    printf("NE");
    return 0;
}
if (u[i] != d[i] && (u[i] == -1 || d[i] == -1)) {
    printf("NE");
    return 0;
}
```
2. 一边空的把另一边堵塞的覆盖，记录矛盾。
```cpp
if (l[i] + r[i] >= n) {
    printf("NE");
    return 0;
}
if (u[i] + d[i] >= n) {
    printf("NE");
    return 0;
}
```
3. 某一行（列）的堵塞能把某一列（行）的堵塞遮住。
![](https://cdn.luogu.com.cn/upload/image_hosting/9g97v3yr.png)
如上图（~~上次图放错了~~），此时记录就矛盾了。
```cpp
if (u[l[i] + 1] > i && d[l[i] + 1] > (n - i + 1)) {
    printf("NE");
    return 0;
}
```
### code
```cpp
#include<bits/stdc++.h>
#define rep(i, l, r) for (int i = (l); i <= (r); i++)
using namespace std;

const int N = 1e5+15;
int n;
int l[N], r[N], u[N], d[N];

signed main() {
	scanf("%d", &n);
	rep(i, 1, n) scanf("%d", &l[i]);
	rep(i, 1, n) scanf("%d", &r[i]);
	rep(i, 1, n) scanf("%d", &u[i]);
	rep(i, 1, n) scanf("%d", &d[i]);
	rep(i, 1, n) {
		if (l[i] != r[i] && (l[i] == -1 || r[i] == -1)) {
			printf("NE");
			return 0;
		}
		if (u[i] != d[i] && (u[i] == -1 || d[i] == -1)) {
			printf("NE");
			return 0;
		}
		if (l[i] + r[i] >= n) {
			printf("NE");
			return 0;
		}
		if (u[i] + d[i] >= n) {
			printf("NE");
			return 0;
		}
		if (u[l[i] + 1] > i && d[l[i] + 1] > (n - i + 1)) {
			printf("NE");
			return 0;
		}
	}
	printf("DA");
	return 0;
}
```

---

## 作者：gcwixsxr (赞：2)

### 题目传送门：
[P7309 [COCI2018-2019#2] Kocka](https://www.luogu.com.cn/problem/P7309)

### 题意：

在一个干净的平面方格纸上，是否存在一种放置障碍物的方式，使得从前后左右四个方向看到的第一个障碍物前空出的方格数满足输入要求。

### 分析：

先来看看什么时候一定**不存在**：

1. 相反的两个方向障碍物前空出的方格数相加不小于 $n$。

   例如，在一个 $4\times 4$ 的方格纸上，第一行从左看，第一个障碍物前有 $2$ 个空格；第一行从右看，第一个障碍物前也有 $2$ 个空格，这显然不行对吧。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/web7gvlf.png)

   对于同一行或列，如果它在某一方向上前有 $i$ 个空格，则意味着该行或列第 $i+1$ 个位置必定有一个障碍物，那么位于其相反的方向最多有 $n-i-1$ 个空格，也就是 $j\leq n-i-1$ ,即 $i+j<n$ , $i+j\ngeq n$。
   
2. 相邻的两个方向上也会互相影响（这个不好直接归纳，详细见下）。

   例如下图：
   
   ![](https://cdn.luogu.com.cn/upload/image_hosting/zm1wzgo3.png)
   
   第 $2$ 行从左看有 $2$ 个空格，那么意味着第 $2$ 行第 $3$ 列位置一定有一个障碍物。但如果从上看第 $3$ 列前的空格超过了一格或者从下看第 $3$ 列前的空格超过了两格，那显然不可能。
   
### 思路:

对以上进行归纳。

对于左侧，第 $i$ 个数据输入 $L_i$，意味着 $(i,L_i+1)$为一个障碍，接下来检验 $(i,j+1)$ 到其他方向的空格数是否合法。

对于右侧，前面，后面同理。

### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N=1e5;

int n,mp[4][N+5];

bool check(int i,int j){//判断障碍物放置坐标(i,j)是否合法
	if ((mp[0][i]==-1||mp[0][i]>=j)
		||(mp[1][i]==-1||n-mp[1][i]<j)
		||(mp[2][j]==-1||mp[2][j]>=i)
		||(mp[3][j]==-1||n-mp[3][j]<i)){
			return 1;
		}
	return 0;
}
int main(){
	scanf("%d",&n);
	for (int i=0;i<4;i++)
		for (int j=1;j<=n;j++)
			scanf("%d",&mp[i][j]);
  //这里用了离线操作，其实在线也无妨
	for (int i=1;i<=n;i++){
		if((mp[0][i]!=-1&&check(i,mp[0][i]+1))
			||(mp[1][i]!=-1&&check(i,n-mp[1][i]))
			||(mp[2][i]!=-1&&check(mp[2][i]+1,i))
			||(mp[3][i]!=-1&&check(n-mp[3][i],i))){
				return printf("NE\n"),0;
			}
	}
	printf("DA\n");
	return 0;
}

```


---

## 作者：Listedzero (赞：1)

### 题目分析

偏模拟的一道题。在第一个函数中，我们判断相反方向上去看物体的距离之和是否合法，这是比较简单的。第二个函数是另外判断列和行是否冲突。具体来说，枚举某行看见的物体，那么我们可以确认这个物体以这种表示方法在相应列上的位置，又由于我们在这个方向上看到的是以某个方向的第一个问题，所以我们去匹配是否在这个范围之内即可。

### 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,l[N],r[N],u[N],d[N];
void _1(){
	for(int i=1;i<=n;i++){
		if(l[i]==-1&&r[i]==-1) continue;
		if(l[i]==-1&&r[i]!=-1){
			cout<<"NE"<<endl;
			exit(0);
		}
		if(l[i]!=-1&&r[i]==-1){
			cout<<"NE"<<endl;
			exit(0);
		}
		if(l[i]+r[i]>=n){
			cout<<"NE"<<endl;
			exit(0);
		}
	}
	for(int i=1;i<=n;i++){
		if(u[i]==-1&&d[i]==-1) continue;
		if(u[i]==-1&&d[i]!=-1){
			cout<<"NE"<<endl;
			exit(0);
		}
		if(u[i]!=-1&&d[i]==-1){
			cout<<"NE"<<endl;
			exit(0);
		}
		if(u[i]+d[i]>=n){
			cout<<"NE"<<endl;
			exit(0);
		}
	}
}
void _2(){
	for(int i=1;i<=n;i++)
		if(u[l[i]+1]>i||d[l[i]+1]>(n-i+1)){
			cout<<"NE"<<endl;
			exit(0);
		}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>l[i];
	for(int i=1;i<=n;i++) cin>>r[i];
	for(int i=1;i<=n;i++) cin>>u[i];
	for(int i=1;i<=n;i++) cin>>d[i];
	_1(); 
	_2();
	cout<<"DA"<<endl;
	return 0;
}
```

---

## 作者：djh0314 (赞：1)

[**传送门**](https://www.luogu.com.cn/problem/P7309)。

## 题意

一个 $N\times N $ 的矩形，有从四周往内望去的第一个位置的距离，问是否存在一个矩形满足我们的观察。

## 分析

先说说我这个蒟蒻想出来的巨麻烦的方法。


首先先判断最简单的矛盾，就是左右穿插，上下穿插，这是第一步。
~~~
//-1 变成 n
for(int i=1; i<=n; ++i) if(L[i]+R[i]>=n) if(L[i]!=n||R[i]!=n) return puts("NE"),0;
for(int i=1; i<=n; ++i) if(U[i]+D[i]>=n) if(U[i]!=n||D[i]!=n) return puts("NE"),0;
~~~
第二步就是左右和上下之间的矛盾。              
先从左边出发思考，我们在左边看到的这些黑格之前这一行一定不能出现节点，在黑格时，上下的两端应当将当前节点包裹，这就是第二步。


~~~cpp
for(int i=1; i<=n; ++i) a[i]=<%L[i],i%>;
sort(a+1,a+n+1);
int now=1;
for(int i=1; i<=n; ++i) {
	int id=a[i].id;
	while(now<=L[id]) {
		if(U[now]!=INF) vis[U[now]+1]=vis[n-D[now]]=1;
		++now;
	}
	if(vis[id]) return puts("NE"),0;
	int x=L[id]+1;
	if((U[x]+1>id)||(id>n-D[x])) return puts("NE"),0;
}
~~~

然后就结束了，我的代码一共有 $56$ 行，但是看了一眼[这个大佬](https://www.luogu.com.cn/blog/goucw/solution-p7309)的题解，发现想麻烦了许多。


我们的黑点倘若出现了矛盾，那么必然会影响到其他的方向的值，那么直接将其他方向观察这个节点的影响求出，看是否矛盾即可。


代码就不贴了，看大佬博客即可。

---

## 作者：ruik (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7309)

### 题面
有一个由立方体和矩阵 $N×N$ 的矩阵，你可以知道从各个方向看，将视线遮挡的第一个立方体的位置，要你判断此矩阵是否存在。
### 暴力的思路
第一眼看到时便有了一种十分暴力的做法，即开一个大小为 $N×N$ 的数组存矩阵每一个位置是否有立方体。设三个状态分别为有、没有或还未确定。对于每一个方向看到的每一个结果都 $O(n)$ 遍历一遍看是否能行，并沿途赋状态。

~~数据水点也许能过~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,c[1020][10020];
bool w;
int main()
{
	scanf("%d",&n);
	//从左看
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(a==-1){
			for(int j=1;j<=n;j++)c[i][j]=1;
		}
		else {
			a++;
			for(int j=1;j<a;j++)c[i][j]=1;
			c[i][a]=2;
		}
	} 
	//从右看
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(a==-1){
			for(int j=1;j<=n;j++){
				if(c[i][j]==2)w=1;
				c[i][j]=1;
			}
		}
		else {
			a++;
			for(int j=1;j<a;j++){
				if(c[i][n-j+1]==2)w=1;
				c[i][n-j+1]=1;
			}
			if(c[i][n-a+1]==1)w=1;
			c[i][n-a+1]=2;
		}
	} 
	//从上看
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(a==-1){
			for(int j=1;j<=n;j++){
				if(c[j][i]==2)w=1;
				c[j][i]=1;
			}
		}
		else {
			a++;
			for(int j=1;j<a;j++){
				if(c[j][i]==2)w=1;
				c[j][i]=1;
			}
			if(c[a][i]==1)w=1;
			c[a][i]=2;
		}
	} 
	//从下看
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(a==-1){
			for(int j=1;j<=n;j++){
				if(c[j][i]==2)w=1;
				c[j][i]=1;
			}
		}
		else {
			a++;
			for(int j=1;j<a;j++){
				if(c[n-j+1][i]==2)w=1;
				c[n-j+1][i]=1;
			}
			if(c[n-a+1][i]==1)w=1;
			c[n-a+1][i]=2;
		}
	} 
	if(w==1)cout<<"NE";
	else cout<<"DA";
	return 0;
}
```
额，好吧。无论从空间还是时间上，这种暴力都过不了。于是便开始思考该如何降低时空复杂度。考虑到数据范围，肯定不能开 $N×N$ 的数组，所以想到只能在四个方向上做判断。
### 正解的思路
做理想的状态当然是所有方向上看都是空的，这样我们可以直接判此情况成立。但输入的数据会让矩阵中必须有立方体。而共只有 $4×N$ 次输入，所以矩阵中最多只有 $4×N$ 个立方体存在。空地不用判断，我们只要判断每一个立方体是否合理就行了。判断一个立方体是否合理的有四个数据分别是四个方向看它得到得结果，只要其中两个方向产生了矛盾，就可以输出不行了。
### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w[6][100200];
bool wa;
void pd(int x,int y){      //判断 
	if((w[1][x]==-1||w[1][x]>y)||(w[2][x]==-1||n-w[2][x]+1<y)||(w[3][y]==-1||w[3][y]>x)||(w[4][y]==-1||n-w[4][y]+1<x))wa=true;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=4;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&w[i][j]);
			if(w[i][j]!=-1)w[i][j]++;
		}
	}
	for(int i=1;i<=n;i++){
		if(w[1][i]==-1)continue;
		int x=i,y=w[1][i];
		pd(x,y);
	}
	for(int i=2;i<=n;i++){
		if(w[2][i]==-1)continue;
		int x=i,y=n-w[2][i]+1;
		pd(x,y);
	}
	for(int i=3;i<=n;i++){
		if(w[3][i]==-1)continue;
		int x=w[3][i],y=i;
		pd(x,y);
	}
	for(int i=4;i<=n;i++){
		if(w[4][i]==-1)continue;
		int x=n-w[4][i]+1,y=i;
		pd(x,y);
	}
	if(wa==1)cout<<"NE";
	else cout<<"DA";
	return 0;
}
```

---


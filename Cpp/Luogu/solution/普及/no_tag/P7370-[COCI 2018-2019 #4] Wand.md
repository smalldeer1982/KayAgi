# [COCI 2018/2019 #4] Wand

## 题目背景

Kile 看到了 Nikola 的题目之后有了灵感，便创作出了自己的版本。

## 题目描述

$N$ 位分别用 $1,2,\cdots,N$ 表示的巫师将参与 $M$ 次决斗。

现有一个魔杖。如果魔杖目前归属于巫师 A，而巫师 A 被巫师 B 击败，则魔杖将归属于巫师 B。魔杖最初归属于巫师 $1$。

Kile 想知道，在只调整决斗的顺序的条件之下，魔杖最终可能会归属于谁。

## 说明/提示

#### 样例 1 解释

如果巫师 $1,3$ 先进行决斗，然后轮到巫师 $2,3$，魔杖将最终归属于巫师 $2$。

如果巫师 $2,3$ 先进行决斗，然后轮到巫师 $1,3$，魔杖将最终归属于巫师 $3$。

#### 数据规模与约定

对于 $20\%$ 的数据，$1 \le N,M \le 10$。

对于 $100\%$ 的数据，$1 \le N,M \le 10^5$，$1 \le X_i,Y_i \le N$，$X_i \neq Y_i$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #4](https://hsin.hr/coci/archive/2018_2019/contest4_tasks.pdf)  _T2 Wand_。**

## 样例 #1

### 输入

```
3 2
2 3
3 1```

### 输出

```
011```

## 样例 #2

### 输入

```
2 2
2 1
1 2```

### 输出

```
11```

## 样例 #3

### 输入

```
5 5
3 1
2 1
4 3
4 5
2 5```

### 输出

```
01110```

# 题解

## 作者：zzx0102 (赞：4)

显然，如果没有人和巫师 $1$ 决斗，则只有 $1$ 可能有。

否则，考虑 dfs。

反向建边，先处理出所有击败的关系。

然后从 $1$ 开始 dfs，如果 $u$ 可以干掉 $1$，那么显然 $u$ 就有机会拿到。那么同理，所有可以干掉 $u$ 的巫师 $v$ 也可以拿到，dfs 下去。

注意特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int N = 100010; vector<int> e[N]; int n, m, a, ans, b; bool can[N];
void dfs(int u) {for(int v: e[u]) if(!can[v]) can[v] = 1, dfs(v);}
int main() {
	cin >> n >> m; for(int i = 0; i < m; i++) {cin >> a >> b; e[b].pb(a);}
	if(e[1].empty()) can[1] = 1; // 特判
	dfs(1); for(int i = 1; i <= n; i++) cout << can[i];
	return 0;
}
```

---

## 作者：心灵震荡 (赞：2)

# $\text{Preface}$

注意到链式前向星存图在大部分情况下要明显由于 vector 存图，所以建议大家做题时均使用链式前向星作为存图方式。

本题解使用链式前向星存图。

# $\text{Anylysis}$

考虑反向建图：将 $u$ 能打败 $v$ 看做 $v$ 可以将魔杖给 $u$，也就是把边 $(u, v)$ 建成了 $(v, u)$ 的形式。然后进行一轮 bfs，确定哪些人最后可以获得魔杖即可。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100005;
int n, m, u, v, tot, head[N];
bool vis[N];

struct edge
{
	int to, nxt;
}e[N];

inline void add_edge(int u, int v)
{
	e[++tot] = {v, head[u]};
	head[u] = tot;
}

inline void bfs()
{
	queue<int> q;
	q.push(1);
	while(!q.empty())
	{
		u = q.front(); q.pop();
		for(int i = head[u]; ~i; i = e[i].nxt)
		{
			v = e[i].to;
			if(!vis[v]) vis[v] = 1, q.push(v);
		}
	}
}

int main()
{
	memset(head, -1, sizeof head);
	ios :: sync_with_stdio(false);
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> u >> v;
		add_edge(v, u);
	}
	if(!~head[1])
	{
		cout << 1;
		for(int i = 2; i <= n; i++) cout << 0;
		return 0;
	}
	bfs();
	for(int i = 1; i <= n; i++)
		cout << vis[i];
	return 0;
}
```

---

## 作者：Dangerou (赞：2)

瞎扯淡时间：每日一随机有幸经是第二道暂未评定了

## 正题
有 $n$ 个巫师要进行 $m$ 场决斗，但象征巫师至高荣誉的魔杖只有一个，打赢携带魔杖的巫师就能获得魔杖，魔杖最初在 $1$ 号巫师手中。问：最终魔杖可能的手中？

从题目中可以看出 $3$ 点 **隐（du）藏（liu）条件**

1. 使进行决斗的两个巫师都没有魔杖，决斗依然可以进行

2. 巫师并不是在输掉一场决斗后就会死亡，而且可以迅速的、满状态的进行下一场决斗

3. $1$ 号巫师可能不会参加任意一场决斗，换句话说：魔杖可能不会传到其他巫师手中

于是乎问题就转化成了在一个有向图中，从 $1$ 号节点出发，经过一些路径能够到达的所有点。但是该如何建图呢？

这里拿样例 $3$ 开刀：

这是按照输入建图的样子

![xR4sgK.jpg](https://s1.ax1x.com/2022/10/25/xR4sgK.jpg)

但是如果进行反向建图的话

![xR5Daj.jpg](https://s1.ax1x.com/2022/10/25/xR5Daj.jpg)

你品，你细品，反向建图得到的有向图是不是要比按输入建图好得多

**注意：** 如果 $1$ 号节点的入度为零最终是不会持有魔杖的，所以 $1$ 号节点刚开始是不能打标记的，但是一种情况除外—— $1$ 号节点没有出度，即 $1$ 号巫师不会和任何一个巫师进行决斗，因此魔杖会一直在 $1$ 号手中，这种情况需要统计每个点的出度并进行特判

最后就是代码实现了
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<string>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#include<climits>
using namespace std;
int n,m,u,v;
int chu[100005];//统计出度
int mark[100005];//标记
int head[100005],tot;//链式前向星
struct node
{
	int from;
	int to;
	int nex;
}mapp[100005];
void add(int xx,int yy)//存图
{
	mapp[++tot]=(node){xx,yy,head[xx]};
	head[xx]=tot;
	chu[xx]++;
	return;
}
void dfs(int now)//暴力时刻
{
	for(int i=head[now];i;i=mapp[i].nex)
	{
		if(mark[mapp[i].to]==1) continue;//如果一个点已经被到达过，那么就可以放弃本次搜索了
		mark[mapp[i].to]=1;//打标记
		dfs(mapp[i].to); 
	}
	return;
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		add(v,u);//反向建图
	}
	if(chu[1]==0)//这个特判一定要有，不然会 Wa 一个点
	{
		printf("1");//因为魔杖一直在 1 号巫师手中，因此即使 1 号节点没有入度最终也会持有魔杖
		for(int i=2;i<=n;i++) printf("0");
		return 0;
	}
	dfs(1);
	for(int i=1;i<=n;i++)
	{
		if(mark[i]==1) printf("1");//能到达就输出 1
		else printf("0");//不能到达就输出 0
	}
	printf("\n");//个人癖好(bushi
	//fclose(stdin);
	//fclose(stdout);
	return 0;
}
/*
样例：

*/
```

---

## 作者：Huangjy88 (赞：1)

# P7370题解
一道搜索+图论的题目。对于每个关系，反向建边，然后从 $1$ 开始深搜，标记遍历到的点即可。注意当 $1$ 不与任何点连边时需要特判。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
vector<int>v[N];
int n,m;
bool vis[N];
void dfs(int x){
    for(int i=0;i<v[x].size();i++){
	int y=v[x][i];
	if(!vis[y]) vis[y]=1,dfs(y);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){//存图
	int x,y;cin>>x>>y;
	v[y].push_back(x);//反向建边
    }
    dfs(1);//深搜
    if(v[1].empty()) vis[1]=1;//特判
    for(int i=1;i<=n;i++) cout<<vis[i];//输出
    return 0;
}
```
~~管理员求过~~

---

## 作者：FunKingDoor (赞：1)

为了形象一点地解释，就以第一个样例为例罢：

```
3 2
2 3
3 1
```

换成文字语言大概为：

---

一号：诺，三号，魔杖给你。

三号：诺，二号，魔杖给你。

---

决斗时无非就是一个魔杖交替的过程，不妨理解为建反边，女巫 $u$ 能打过女巫 $v$，那么可以理解为：如果女巫 $v$ 有魔杖，就会慷慨地把它送给女巫 $u$。

代码模拟的过程也很简单，从一号女巫开始跑深搜，每次遍历和她连了边的女巫挨个送出魔杖，收到过魔杖的女巫被打上 `visited` 标记，最后看女巫是否被打上 `visited` 标记输出即可。

注意：这里有一个魔鬼细节，一号女巫虽然一开始就持有魔杖，但是如果她的出度不为零，她还是需要遵守慷慨的人生信条，将魔杖送出去，这也就意味着，**开始时，一号女巫身上没有 `visited` 标记**。但是如果她出度为零，那么即便她再慷慨她也送不出去魔杖，此时，直接输出 $1$ 后面加 $n-1$ 个 $0$ 即可。

代码：

```
#include <iostream>
#include <vector>
using namespace std;

const int MX = 100005;

int n, m;
vector <int> e[MX];

bool vis[MX];

void search(int u){
	for(auto v : e[u])
		if(!vis[v]) //如果她已经有魔杖了，就不用给她了
			vis[v] = true, search(v);
}

int main() {
	cin >> n >> m;
	for(int i = 1; i <= m; i++){
		int u, v;
		cin >> u >> v;
		e[v].push_back(u); //建反边
	}
	if(e[1].empty()){
		cout << 1;
		for(int i = 1; i < n; i++)
			cout << 0;
		return 0;
	}
	search(1);
	for(int i = 1; i <= n; i++)
		cout << (int)vis[i];
	return 0;
}
```

---

## 作者：charleshe (赞：0)

由于魔杖只能由失败的女巫转移到胜利的女巫，所以显然可以从失败的女巫对胜利的女巫建一条有向边。则原题可被转化为：

给定一张有向图，你可以从 $1$ 号点走**任意多**条边，求你最终可能到达几个点。

接下来解决两个疑问：

Q：为什么是可以走任意多条边而不是一定要走所有的边？

A：以样例 $1$ 为例：

显然我们可以先执行第一次决斗再进行第二次，注意到执行完第一次决斗后魔杖还在女巫 $1$ 手里，相当于**没有沿着这条边走过**，所以实质上就是可以走**任意多条边**。

Q：可不可以不走？

A：显然的，每一次决斗都要执行。如果这些决斗中有一些决斗是某名女巫打败 $1$ 号女巫的，那么由于条件的必须执行性，魔杖就从 $1$ 号女巫手里传递走了。

当然，如果 $1$ 号女巫没被任何女巫打败，那么魔杖就只能在 $1$ 号女巫手里。

转换成图上视角，可以得出结论：如果 $1$ 号节点有出边，那么不能不走；反之则只能不走（因为没路可以走啊）。

解决完两个疑问，容易发现原题就是求 $1$ 号节点能到哪些节点。鉴于已有两篇深度优先搜索的题解，因此本题解使用最短路。

显然的，如果两点之间存在最短路，那么有一个前提条件就是两个点需要联通。那么我们只需要从 $1$ 号点跑最短路，存在最短路的节点皆输出 $1$，而反之输出 $0$。注意到决斗的必须执行性，因此 $1$ 号节点提前输出 $0$（或在 $1$ 号节点没有出边时输出 $1$，特判方式见代码）。

注意到数据范围较大，可使用堆优化 `Dijkstra` 来实现最短路解决这道题。

完了吗？事实上这个代码无法通过样例 $2$。

观察样例 $2$ 的图，发现这张图中存在一个经过点 $1$ 的环，显然我们可以通过沿着这个环走一圈到达点 $1$。在最短路代码中特判即可。具体特判方式见代码。

```
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
struct edge{
	int v,w;
	edge(int a,int b){
		v=a;
		w=b;
	}
};
struct node{
	int x,disx;
	node(int a,int b){
		x=a;
		disx=b;
	}
	friend bool operator<(node a,node b){
		return a.disx>b.disx;
	}
};
priority_queue<node> q;
vector<edge> v[100001];
int n,m;
int u0,v0;
int dis[100001];
bool vis[100001];
bool tmp[100001];
bool flag,t;
void dijkstra(){//正常堆优化dijkstra算法代码
	dis[1]=0;
	q.push(node(1,dis[1]));
	while(!q.empty()){
		int x=q.top().x;
		q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(auto y:v[x]){
			int t1=y.v,t2=y.w;
			if(t1==1) t=1;//t1为1代表在1能到达的点里有一个点可以到达1，即存在包含1的环，此时可以到达点1。
			if(dis[t1]>=dis[x]+t2){
				dis[t1]=dis[x]+t2;
				q.push(node(t1,dis[t1]));
			}
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u0>>v0;
		v[v0].push_back(edge(u0,1));//注意要从输的人向赢的人建边
	}
	for(int i=1;i<=n;i++) dis[i]=1000000000;
	dijkstra();
	for(int i=1;i<=n;i++){
		if(dis[i]<1000000000&&i>1) tmp[i]=1,flag=true;默认无法到达节点1，所以暂且将点1的答案记作0。
        //flag的用处：如果1与非1点存在最短路，说明点1有出边。flag为false意味着点1没有出边，此时可以到达点1。
		else tmp[i]=0;//由于节点1暂时无法确定是否可经过，暂且先以tmp数组存储结果。
	}
	if(!flag||t) tmp[1]=1;
	for(int i=1;i<=n;i++) cout<<tmp[i];
	return 0;
}
```

---

## 作者：胡金梁 (赞：0)

这道题其实是 [P7369 [COCI2018-2019#4] Elder](https://www.luogu.com.cn/problem/P7369) 的进阶版，可以先从基础版练手。
****
## 分析
这题可以直接用有向图，因为只有魔杖在失败的巫师那里，魔杖才能到胜利的巫师那里。也就是失败的巫师和胜利的巫师之间有一条指向胜利巫师的路径。那么魔杖能否传到第 $i$ 个巫师那里，就是有没有一条道路能从 $1$ 号巫师到 $i$ 号巫师。其他的战斗可以调到失败者获得魔杖之前或失去魔杖之后，对整个战斗没影响。我们可以用邻接表来存储整个图。
### 坑点
除了上面说的开始时不能标记 $1$ 号节点外，还要在全部搜索完后特判一次 $1$ 号节点，因为有一种可能情况： $1$ 号巫师从来没有失败过，即  $1$ 号节点的出度为零，这时最后魔杖只在 $1$  号巫师手中，而我们之前的搜索中没有标记，这样就会 WA 一个点（我卡了好久QWQ），所以要特判一下，其中 $ma_1$ 数组表示击败 $1$ 号巫师的人，即从 $1$ 号节点出发的有向边，而 $ma_1.size()$ 表示他失败的次数，即出度。
## 代码
```cpp
/*胡金梁*/
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
vector<int>ma[100005];
int b[100005];
void dfs(int wz)
{
	for(int i=0;i<ma[wz].size();i++)
	{
		if(!b[ma[wz][i]])
		{
			b[ma[wz][i]]=1;
			dfs(ma[wz][i]);
		}
	}
}
signed main(){
#if __MY_TEST__
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b;
		ma[b].push_back(a);
	}
	dfs(1);
	if(!ma[1].size())
	{
		b[1]=1;
	}
	for(int i=1;i<=n;i++)
	{
		cout<<b[i];
	}
#if __MY_TEST__
	fclose(stdin);
	fclose(stdout);
#endif
}
```


---

## 作者：luckydrawbox (赞：0)

想了解背景的同学可以去[P7369](https://www.luogu.com.cn/problem/P7369)

## 分析

利用初中的**数形结合**思想，因为魔杖只有可能从**失败**的女巫传给**胜利**的女巫，所以她们之间的**关系**就可以用一条**有向边**来表示，如 ``2 1`` 可以转化为 ``1->2``，表示 $1$ 到 $2$ 有一条有向边，即魔杖可从 $1$ 传到 $2$。

这样问题就清晰可见了。如果编号为 $x$ 的女巫**最后拿到**魔杖，那么 $1$ 号女巫手中的魔杖一定**直接或间接**传给她，即**一定**有一条从 $1$ 号女巫到 $x$ 号女巫的路线。而对于其他的战斗，因为可以**随意调整顺序**，我们只要把失败者不是 $1$ 号女巫全部调到前面，把失败者是 $1$ 号女巫全部调到最后，就不会影响最后的结果，换句话说，其他的战斗对这条路径**没有任何影响**。

我们用**邻接表**来**存储**每条有向边，建立一个 ``bool b[N]`` 数组存储每个点**是否被走过**，然后从 $1$ 号节点开始，不断沿着他的每条边到达下一个**未被标记**的点，将那个点**标记**，并继续**搜索**下去，直到**无点可走**，**注意**开始时不要标记 $1$ 号节点，因为她是把魔杖传出去的，只有之后传回她时才能标记。而**能走到**的每个点就能说明她们和 $1$ 号节点**存在一条路径**，即她们是能**最后拿到魔杖**的女巫。

### 坑点

除了上面说的开始时不能标记 $1$ 号节点外，还要在全部搜索完后**特判**一次 $1$ 号节点，因为有一种可能情况： $1$ 号女巫**从来没有失败过**，即 $1$ 号节点的**出度为零**，这时最后魔杖只在 $1$ 号女巫手中，而我们之前的搜索中**没有标记**，这样就会 WA 一个点（~~我卡了好久QWQ~~），所以要特判一下 ``if(!a[1].size())b[1]=1;``，其中 $a_1$ 数组表示击败 $1$ 号女巫的人，即从 $1$ 号节点出发的有向边，而 $a_1.size()$ 表示她**失败的次数**，即**出度**。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,x,y;
bool b[N];//每个点是否走过 
vector<int>a[N];//邻接表存储有向边 
void dfs(int x)//搜索 
{
	int l=a[x].size();
	for(int i=0;i<l;i++)//遍历每个能走到的点 
	{
		if(!b[a[x][i]])//如果没走过就标记并继续搜索 
		{
			b[a[x][i]]=1;
			dfs(a[x][i]);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		a[y].push_back(x);//添加有向边 
	}
	dfs(1);//1号节点不标记 
	if(!a[1].size())b[1]=1;//特判别忘了 
	for(int i=1;i<=n;i++)
	{
		cout<<b[i];//能走到的点就有可能最后拿到魔杖 
	}
	return 0;
}
```


---

## 作者：HHYQ_07 (赞：0)

# 题解

## 思路

这道题题面上说巫师 $X$ 击败了巫师 $Y$ 后，魔杖会从巫师 $Y$ 到巫师 $X$ 这里，于是我们存图时可以反向建边，表示魔杖的去向。因为决斗的顺序可以调整，那么只要是魔杖经过的节点（即遍历到的节点）就都有可能是魔杖最终的位置。

## 过程

从编号为一的巫师开始遍历，使用 [BFS](https://oi-wiki.org/graph/bfs/) 或 [DFS](https://oi-wiki.org/graph/dfs) 都可以，到达节点 $x$ 让 $vis[x]=1$，最后从 $1$ 到 $n$ 循环输出 $vis[i]$ 即可。

## 细节

1. 魔杖初始位置是在节点 $1$，需要特判，如果节点 $1$ 没有一条接边，就说明只有节点 $1$ 存在魔杖，其他节点均不可能存在过魔杖。反之哪怕与节点 $1$ 只存在一条接边，那节点 $1$ 无论如何都不可能存在魔杖，因为对决必须要进行。
2. 此题的空间、时间限制较严格，建议使用[链式前向星](https://oi-wiki.org/graph/save/)存图。

## AC code

链式前向星、BFS 做法：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,tot,x,y,head[N];
bool v[N];
struct node
{
	int next,to;
}edge[N];
void add(int from,int to)//链式前向星存图 
{
	tot++;
	edge[tot].to=to;
	edge[tot].next=head[from];
	head[from]=tot;
}
void bfs()//BFS遍历 
{
	queue<int>q;
	q.push(1);
	while(!q.empty())
	{
		x=q.front(); 
		q.pop();
		for(int i=head[x];i;i=edge[i].next)
		{
			y=edge[i].to;
			if(v[y])continue;
			v[y]=1;
			q.push(y);
		}
	}
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		add(y,x);//反向建边 
    }
    if(!head[1])//特判 
	{
		cout<<"1";
		for(int i=2;i<=n;i++)cout<<"0";
		return 0;
	}
	bfs();
    for(int i=1;i<=n;i++)
		cout<<v[i];
    return 0;
}
```

动态数组、DFS 做法：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,x,y;
bool v[N];
vector<int>a[N];
void dfs(int x)//DFS遍历 
{
    for(int i=0;i<a[x].size();i++)
	{
		y=a[x][i];
		if(v[y])continue; 
		v[y]=1;
		dfs(y);
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		a[y].push_back(x);//反向建边 
    }
    if(a[1].empty())//特判 
	{
		cout<<"1";
		for(int i=2;i<=n;i++)cout<<"0";
		return 0;
	}
	dfs(1);
    for(int i=1;i<=n;i++)
		cout<<v[i];
    return 0;
}
```

---

## 作者：cmk666 (赞：0)

[题目链接](/problem/P7370)

考虑建图。

如果 $x$ 会输给 $y$，即魔杖有可能从 $x$ 的手里变到 $y$ 的手里，则从 $x$ 到 $y$ 建一条有向边。

那么显然，当 $1$ 的出度为 $0$，即 $1$ 不会输给任何人时，魔杖只可能一直在他手中。否则，最终能拥有魔杖的人一定是图上从 $1$ 开始，经过正整数条边所能到达的点。

原因很简单，经过一条边等价于执行了这场战斗并把魔杖给赢者。由于安排战斗的顺序是随意的，因此我们可以随意选择经过哪些边。而边数是正整数的原因，即无论怎么安排，$1$ 都会有一局输，也就是至少走一条边。

但这并不意味着 $1$ 拿不到魔杖了。如样例 $2$ 中，构成了一个环，这样可以从 $1$ 开始，走两条边回到 $1$。这种情况需要稍加留意。

那么只要求能达到哪些点就行了。用搜索即可，时间复杂度 $O(n+m)$。主要代码如下：
```cpp
int n, m, x, y; vector < int > a[100009]; queue < int > q;
bool used[100009] = { 0 };
int main()
{
	read(n), read(m);
	For(i, 1, m) read(x), read(y), a[y].push_back(x);
	if ( a[1].empty() )
	{
		putchar('1'); For(i, 2, n) putchar('0');
		return putchar('\n'), 0;
	}
	for ( int i : a[1] ) q.push(i);
	while ( q.size() )
	{
		x = q.front(), q.pop(), used[x] = true;
		for ( int i : a[x] ) if ( !used[i] ) q.push(i);
	}
	For(i, 1, n) putchar(used[i] + '0');
	return putchar('\n'), 0;
}
```

---


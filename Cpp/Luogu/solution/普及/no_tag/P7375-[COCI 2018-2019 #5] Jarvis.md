# [COCI 2018/2019 #5] Jarvis

## 题目描述

Ivan 拥有 $N$ 架无人机，每架无人机均有一个出厂属性值和一个出战需求属性值。他可以选定一个整数 $X$（$X$ 不一定为正整数），将所有无人机在出厂属性值的基础上加上 $X$。

求能够出战（即属性值与出战需求属性值相等）的无人机的最大数量。

## 说明/提示

#### 样例 3 解释

若选定 $X=3$，则属性值分别变为 $1+3=4$ 和 $2+3=5$，则只有第二架可以出战。若 $X=4$，则属性值分别 $5$ 和 $6$，则只有第一架可以出战。可以证明，没有能够使得两架都能出战的整数 $X$。

#### 数据规模与规定

对于 $40\%$ 的数据，$-10 \le A_i,B_i \le 10$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$-10^6 \le A_i,B_i \le 10^6$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #5](https://hsin.hr/coci/archive/2018_2019/contest5_tasks.pdf)  _T2 Jarvis_。**

## 样例 #1

### 输入

```
1
1
2```

### 输出

```
1```

## 样例 #2

### 输入

```
2
0 0
1 1```

### 输出

```
2```

## 样例 #3

### 输入

```
2
1 2
5 5```

### 输出

```
1```

# 题解

## 作者：王老吉的父亲 (赞：2)

## 思路解析：

本题其实就是求 `a[i] - b[i]` 出现的最多次数是几，所以我为大家提供两种思路供大家参考：

1.我们可以用桶解决，具体思路见下面代码中的注释。

2.我们还可以 `sort` 排序一个数组 `c`（用来存 `a[i] - b[i]` 的值）,然后遍历数组 `c`，如果某一项与前一项相同，那么 `cnt++` 即可，如果不相同，进行特判，方法见下面代码注释。
 
 
下面这一份是用桶做的AC代码：
```
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

int a[1000010],b[1000010],c[50000010];

int main()
{
    int n;
    cin >> n;
    for (int i = 1;i <= n;i++) cin >> a[i];
    for (int i = 1;i <= n;i++) cin >> b[i];
    for (int i = 1;i <= n;i++)
    {
        c[a[i] - b[i] + 5000000]++;//下标要记得加一个数，避免a[i] - b[i]是负数
    }
    int maxn = -1e9;
    for (int i = 1;i <= 50000000;i++)
    {
        if (c[i] >= maxn) maxn = c[i];
    }
    cout << maxn;
    return 0;
}
```
 
下面展示第2种方法，也就是用 `for` 循环做的：
 
  
  ```
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

int a[1000010],b[1000010],c[1000010];

int main()
{
    int n;
    cin >> n;
    for (int i = 1;i <= n;i++) cin >> a[i];
    for (int i = 1;i <= n;i++) cin >> b[i];
    for (int i = 1;i <= n;i++) c[i] = b[i] - a[i];
    sort(c + 1,c + n + 1);
    int Maxcnt = 0,cnt = 1;//这里初始值也要设成1
    for (int i = 2;i <= n;i++)//从2到n讨论
    {
        if (c[i] == c[i - 1])
        {
            cnt++;
        }
        else
        {
            if (Maxcnt < cnt) Maxcnt = cnt;
            cnt = 1;//这里要注意初始值是1
        }
    }
    if (Maxcnt < cnt) Maxcnt = cnt;//最后还要判断一下
    cout << Maxcnt;
    return 0;
}
```

谢谢大家的观看~

---

## 作者：Yukinoshita_Yukino (赞：2)

题意：

给定两个数组 $a[n]$ 和 $b[n]$ , 求 $a[i]-b[i]$ 出现最多次的次数。

$solution$：

如果 $a[i]-b[i]$ 是正整数可以直接用桶，但是桶数组的下标不能是负数。出现负数可以用类似哈希的思想，~~貌似题解都是用的map~~。将 $a[i]-b[i]$ 都加上一个数 $t$ ,使得桶数组里的数全是正整数，这样就能避免下标是负数的情况。



我们再来看一下数据范围：

-$10^6≤a[i]$ , $b[i]≤10^6$。

于是我们就需要大于 $2*10^6$ 的桶，将所有数加上一个大于 $10^6$ 的数就行了。

AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1000001],b[1000001],t[10000001];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++)
    {
    	scanf("%d",&b[i]);
	}//输入
	int maxn=-0x7fffffff;//极小值
	for(int i=1;i<=n;i++)
    {
    	t[b[i]-a[i]+4000000]++;//下标加上一个数
	}
	for(int i=1;i<=8000000;i++)
    {
    	maxn=max(maxn,t[i]);
	}
	cout<<maxn<<endl;
	return 0;
}
```

---

## 作者：Error_Eric (赞：1)

### 前言

我想写个题解发现这个方法已经被人提到过了。

### 正文

求出 $a_i-b_i$ 后排序，求最长相同子序列。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#define rei register int
using namespace std;
int n,a[100005]={-9999999,0},bi,l=1,ans=1;//答案最小是1，所以从1开始。
int main(){
	scanf("%d",&n);
	for(rei i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(rei i=1;i<=n;i++)
		scanf("%d",&bi),a[i]-=bi;
	sort(a+1,a+n+1);
	for(rei i=1;i<=n;i++)
		(a[i]==a[i-1])?(ans=max(++l,ans)):(l=1);
	printf("%d\n",ans);
}
```

---

## 作者：银河AI (赞：0)

### 解题思路

由题意，一架无人机能出战当且仅当 $a_i+x=b_i$

此时 $x=b_i-a_i$

那么明显，只有在 $b_i-a_i$ 选中出现最多的那个数为 $x$，才能使出战无人机数量最多。

因为数据范围允许。

所以我们就用桶来查找。

要注意的是，因为下标可能会出现负数，所以加桶的时候需要全部加上 $10^6$

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1,M=1e6+1;
int n,maxn=-M;
int a[N],b[N],t[2*M];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=n;i++) t[b[i]-a[i]+M]++,maxn=max(maxn,t[b[i]-a[i]+M]);
	printf("%d",maxn);
}
```


---

## 作者：Eason_AC (赞：0)

## Content
有 $n$ 架无人机，每架无人机都有一个当前属性值 $a_i$ 和出战属性值 $b_i$。你可以给每架无人机的当前属性值同时加一个数 $x$（但只能做一次），使得能够出战的无人机最多，求最多能够出战的无人机数量。

**数据范围：$n\in[1,10^5],a_i,b_i\in[-10^6,10^6]$。**
## Solution
我们开个计数器（这里建议使用 STL 里面的 $\texttt{map}$）记录每个 $b_i-a_i$ 出现过的次数，取最大值即可。显然可以证明此时的答案即为题目所求。
## Code
```cpp
int n, a[100007], b[100007], ans;
map<int, int> vis;

int main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	n = Rint;
	F(i, 1, n) a[i] = Rint;
	F(i, 1, n) vis[(b[i] = Rint) - a[i]]++, ans = max(ans, vis[b[i] - a[i]]);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：_lfxxx_ (赞：0)

### 思路：
~~这么水的题真的有必要写思路吗。~~

先用数组将数据读进来，~~本蒟蒻第一次数据都没读好全WA。~~ 再用一个数组存 $b_i-a_i$，表示能让第 $i$ 架战斗机出战的 $X$，看哪个 $X$ 的数量最多。~~本人语文不好描述不清请体谅。~~
## 话不多说，直接上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,a[100001],b[100001],c[100001],s=1,maxx=1;//这里定义成1因为至少有一个数
int main(){
    cin>>n;
    for(i=1;i<=n;i++)
    	cin>>a[i];
    for(i=1;i<=n;i++)
    	cin>>b[i];
    for(i=1;i<=n;i++)
    	c[i]=b[i]-a[i];
    sort(c+1,c+1+n);//排序
    for(i=1;i<n;i++)
    	if(c[i]==c[i+1])
    		s++;//如果相邻相同+1
    	else{
    		maxx=max(s,maxx);//不同的话把大的放进去
    		s=1;//重新开始
    	}
    cout<<max(maxx,s);//最后一次如果相等就会少判一次，所以要再比一次
    return 0;
}
```

---

## 作者：cq_loves_Capoo (赞：0)

扯谈：  
  
这题大概是橙色的难度，抢到了第二个 AC qwq（我大水人了）  
  
____  
  
看了下题目，第一反应：是不是二分 $x$ 的值啊¿ 仔细一看，诶呀想太多了qwq  
  
其实根本就不需要知道 $x$ 的值为多少。 根据题目意思，要求的只是最大能达到出战锁需的属性值，简化一下也就是求出有多少个 $b_i - a_i$ 是相等的。  
  
这里提供两种做法思路：  
  
1. 求出所有的 $b_i - a_i$，排序后求最大连续子序列。
2. 用 STL 中的 map 做  
  
代码提供第二种做法：  
  
```
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;

int n, a[N], res;
map < int, int > maps;

signed main() {
	
	scanf ("%d", &n);
	
	for (int i = 1; i <= n; i ++) 
		scanf ("%d", &a[i]);
		
	for (int i = 1; i <= n; i ++) {
		
		int x;
		scanf ("%d", &x); //节省空间，就不用数组了 
		
		++ maps[x - a[i]];
		
		res = max (res, maps[x - a[i]]); // 求最大的值 
	}
		
	printf ("%d", res);
	return 0;
}
```   
  
附注：不保证用 cin 没问题qwq

---


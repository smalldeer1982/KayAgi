# [COCI 2020/2021 #5] Po

## 题目描述

有一个长度为 $n$ 的数组。在初始状态下，所有元素都为 $0$。

每次操作，可以将一个连续的区间 $[l,r]$ 内的所有数加上一个正整数 $x$，但要求任意两个操作区间要么互不相交，要么一个包含另外一个。

请问能将原数组变为给定数组 $a$ 的最少操作次数。

## 说明/提示

#### 样例 2 解释

一种最优的方案是：将所有元素都加上 $2$，再将中间三个元素都加上 $1$。

#### 数据规模与约定

对于 $30$ 分的数据，$1 \le n \le 1000$。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$0 \le a_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #5](https://hsin.hr/coci/contest5_tasks.pdf)  _T2 Po_。**

## 样例 #1

### 输入

```
3
2 2 2```

### 输出

```
1```

## 样例 #2

### 输入

```
5
2 3 3 3 2```

### 输出

```
2```

## 样例 #3

### 输入

```
6
1 2 3 2 1 3```

### 输出

```
4```

# 题解

## 作者：Perta (赞：25)

题目 ：[P7399 [COCI2020-2021#5] Po](https://www.luogu.com.cn/problem/P7399)
# 题面
你会获得一个长度为 $n$ 的序列 $a_{i}$，这个序列是由一个初始序列经过若干变换得到的。初始序列是一个长度为 $n$ 的**全0**序列。可能出现的变换规则如下：
单个变换的效果为选择一个区间 $[l,r]$，将 $a_{l},a_{l+1},\cdots a_{r}$ 的值加上一个正整数 $x$。任意两次变换的区间只能**互不相交**或者**一个区间包含另一个区间**。
你的问题是，对于给定的序列 $a_i$，这个序列**至少**是进行了多少次变换得到的。
# 思路
我们可以数形结合，把整个序列想象成一个二位平面，如图（此篇以第3个样例为例讲解）：

![](https://cdn.luogu.com.cn/upload/image_hosting/1uphz1qs.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

题面“变换”的意思就是把区间 $[l,r]$ 的高度增高一个正整数层数 $x$ （当然这个 $x$ 可以是任意正整数，即并**不需要考虑增高了多少层**）
再思考一下，可以发现：任意两个部分包含的区间其实可以看做另外两个具有包含关系的区间，例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/muxk5chc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这里区间 $[1,3]$ 和区间 $[2,5]$ 的变换其实可以看作是区间 $[1,5]$ 和区间 $[2,3]$ 的变换，其效果是一样的。这也就是为什么题面中会有原题目中未提及的区间变换的额外规则了
~~（可以自己推导出来，方便理解）~~。

做到这里，有经验的朋友可以发现此题和[P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)的区间修改很类似，只是有些不同。我们可以把序列看作一座座山，在山的另一边如果有与之相同的高度，就可以在一次变换中将这两边的此高度的区间变换。

例如可以把样例中的区间 $[1,5]$ 看作一个山：

![](https://cdn.luogu.com.cn/upload/image_hosting/irmau43o.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

区间 $[4,4]$ 与区间 $[2,2]$ 的高度一样，故可以在一次变换中将这两个区间的高度变换。区间 $[1,1]$ 与区间 $[5,5]$ 也是如此。
样例变换过程（区间 $[6,6]$ 在第一次也可以变换，此处变换过程是符合上述方法的过程）：

![](https://cdn.luogu.com.cn/upload/image_hosting/a6gxt36m.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么如何实现呢？这就可以用到**单调栈**了（详情请见[P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)）。

由于山的上坡是**上升序列**，下坡是**下降序列**，我们就可以把上坡中的每一个高度存在一个栈里，等到枚举到下坡的时候再一一比较，比当前高度高的栈顶元素直接弹出。如果弹到最后发现**栈顶元素比当前高度小**或者**栈空了**，就说明上坡时没有与之对应的区间可以在同一变换中变换，那么就不得不另用一次变换使当前区间变换（如果等于，就是符合要求，是可以在同一次变换中变换的）。
#### code:
```
#include<bits/stdc++.h>
using namespace std;
int n,sol,x;
stack<int>s;
int main()
{
    scanf("%d",&n);
    while(n--)
	{
        scanf("%d",&x);
        while(!s.empty()&&s.top()>x) s.pop();//比当前高度高的直接弹出，注意要保证栈里有元素，否则可能会出错
        if(!s.empty()&&s.top()==x) continue;//符合要求直接进入下一层循环
        if(x) sol++,s.push(x);//注意，由于原序列是全0序列，所以当高度为0时是不需要变换的，也就不需要压入栈中
    }
    printf("%d",sol);
    return 0;
}
```
~~画功不好，见谅QWQ~~

---

## 作者：LittleYang0531 (赞：8)

### 题目描述:

你会获得一个长度为 $n$ 的序列 $a_i$，这个序列是由一个初始序列经过若干变换得到的。初始序列是一个长度为 $n$ 的全 0 序列。可能出现的变换规则如下：

单个变换的效果为选择一个区间 $[l,r]$，将 $a_l,a_{l+1},...,a_r$ 的值加上一个正整数 $x$。任意两次变换的区间只能**互不相交或者一个区间包含另一个区间**。 

你的问题是，对于给定的序列 $a_i$，这个序列至少是进行了多少次变换得到的。

### 输入描述:

输入的第一行是一个整数 $n(1 \leq n \leq 10^5)$，表示序列的长度。

输入的第二行包含 $n$ 个非负整数 $a_i(0 \leq a_i \leq 10^9)$。表示经过若干次变换得到的序列。

### 输出描述:

输出一个整数 $m$，表示要得到这个区间的最少的变换次数。

### 分析:

分析题意，首先这个题加上的这个正整数 $x$ 只能是个正整数，这意味着我们在每次变换时只能变换到当前区间最小的一个值，如果变换到的不是最小的一个值，那么就再也变换不到当前区间的最小值了。

考虑通过分治来解决此问题。每次变换时查询当前区间的最小值，并根据这个最小值在当前区间所出现的位置来将当前区间拆分为若干个子区间继续进行分治，并且将 $ans$ 的值增加 1，直到 $l < r$ 就可以退出该递归函数了。

注意，当区间的最小值为 0 时，$ans$ 的值不需要增加1，因为此时不需要进行一次变换。

时间复杂度为 $O(n\log_2^2 n)$。

### 代码:

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
#define ywhin cin
#define ywhout cout
using namespace std;
van n,a[N],tmp[N];
van tree[N*4],ans;
vector<van> place[N];
void build(van p,van l,van r)
{
	if (l==r){tree[p]=a[l];return;}
	van mid=l+r>>1;
	build(p*2,l,mid);build(p*2+1,mid+1,r);
	tree[p]=min(tree[p*2],tree[p*2+1]);
}//构建线段树
van query(van p,van l,van r,van L,van R)
{
	if (L<=l&&r<=R) return tree[p];
	van mid=l+r>>1;
	van x=1e18;
	if (L<=mid) x=min(x,query(p*2,l,mid,L,R));
	if (R>mid) x=min(x,query(p*2+1,mid+1,r,L,R));
	return x;
}//在线段树内查询最小值
void solve(van l,van r)
{
	if (l>r) return;
	van min_=query(1,1,n,l,r);//获取[l,r]的最小值
	if (tmp[min_]!=0) ans++;//注意:当最小值为0时是不需要ans++的
	van ll=0,rr=place[min_].size()-1,lll;
	while (ll<=rr)
	{
		van mid=ll+rr>>1;
		if (place[min_][mid]>=l) lll=mid,rr=mid-1;
		else ll=mid+1;
	}//二分查找最小值所在的位置id最小的位置
	ll=0,rr=place[min_].size()-1;van rrr;
	while (ll<=rr)
	{
		van mid=ll+rr>>1;
		if (place[min_][mid]<=r) rrr=mid,ll=mid+1;
		else rr=mid-1;
	}//二分查找最小值所在的位置id最大的位置
	solve(l,place[min_][lll]-1);//解决[l,a_l-1]的区间
	for (int i=lll;i<rrr;i++) solve(place[min_][i]+1,place[min_][i+1]-1);//解决[a_i+1,a_{i+1}-1]所在的区间
	solve(place[min_][rrr]+1,r);//解决[a_r+1,r]的区间
}//分治解决问题
int main()
{
//	ifstream ywhin("po.in");
//	ofstream ywhout("po.out");
	ywhin>>n;
	for (int i=1;i<=n;i++) ywhin>>a[i];
	memcpy(tmp,a,sizeof tmp);
	sort(tmp+1,tmp+n+1);
	van cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for (int i=1;i<=n;i++) a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;//离散化
	for (int i=1;i<=n;i++) place[a[i]].push_back(i);//记录某一个离散化后的数会出现在哪些位置
	build(1,1,n);
	solve(1,n);
	ywhout<<ans<<endl;
	return 0;
}
```

---

## 作者：pujingcat (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7399)


建议 普及/提高-。

由题得，我们要求的 ans 即是区间的个数。

我们不难发现，每相邻的两个元素如果不相同，则它们所处的区间也不相同。

如果比前一个大，就说明又新增了一个区间，存至栈中，如果比它小，就说明前面又若干个区间结束了，并往前扫描，依次出栈，直到扫到比它大的或相等的，若是相等，说明处于同一区间，直接 continue 。

代码如下
```cpp
#include <bits/stdc++.h>
#define rint register int
using namespace std;
int n,x,ans=0;//po
stack<int> s;
int main(){
//	freopen("po.in","r",stdin);
//	freopen("po.out","w",stdout);
	scanf("%d",&n);
	while(n--){
		scanf("%d",&x);
		while(!s.empty()&&x<s.top())
			s.pop();
		if(!s.empty()&&x==s.top()){
			continue;
		} 
		if(x!=0){
			ans++;
			s.push(x);
		}
		
	}
	cout<<ans;
	return 0; 
}
```
不知道什么是单调栈的戳[这儿](https://www.luogu.com.cn/problem/P5788)

求过QWQ

---

## 作者：Mu_tr (赞：2)

# 题目大意：
有一个长度为 $n$ 的数组。在初始状态下，所有元素都为 $0$ 。每次操作，可以将一个连续的区间 $[l,r]$ 内的所有数加上一个整数 $x$。请问能将原数组变为给定数组 $a$ 的最少操作次数。

# 思路：
1. 例子：1 2 3 可知当 $a[i]>a[i-1]$ 时，ans 应该加一个，并压入栈内。
2. 例子：1 2 3 2 1 可知当 $a[i]<a[i-1]$ 时，不断的出栈，直到找到一个小于等于它的数，倘若是小于这个数，ans 应该加一个，并压入栈内。
3. 特殊情况：当 $a[i]=0$ 时，栈内的数会全部出栈，ans 会加个 1，但是当 $a[i]=0$ 时，是不需要操作的，所以这种情况我们特殊判断。

# AC 代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100001],ans=0;
stack<long long> q;
int main(){
	scanf("%lld",&n);a[0]=-1;
	for(long long i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		while(!q.empty()&&q.top()>a[i]) q.pop();
		if(!q.empty()&&q.top()==a[i]) continue;
		else if(a[i]) ans++,q.push(a[i]);
	} 
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：钰瑾_恋涵 (赞：2)

这道题和[P5019铺设道路](https://www.luogu.com.cn/problem/P5019)有亿点像。

### 思路：
我们首先可以考虑选取暴力的方法，首先将问题转化为由目标数组减至元素全为 $0$，将大小为 $0$ 的数设为分界点，逐一将每个区间减去区间最小值，很容易证明此为最优方案，可得 $30$ 分。

我们不难发现，这道题是一道非常经典的栈问题。当新的元素入栈时，先找到小于等于它的与元素作为栈顶，如果新元素与栈顶相等，便可将其合并，否则就将新元素入栈。

**注意 : 如果新元素为 $0$ 则需要跳过。**

### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,res;
stack<int>a;
int main() {
//	freopen("po.in","r",stdin);
//	freopen("po.out","w",stdout);
	cin>>n;
	for(int i=1; i<=n; i++) {
		int x;
		cin>>x;
		while(!a.empty()&&a.top()>x) a.pop();
		if(!a.empty()&&a.top()==x) continue;
		if(x!=0) res++,a.push(x);
	}
	cout<<res;
	return 0;
}
```


---


# [COCI 2009/2010 #1] DOBRA

## 题目描述

Lea 写下了一个单词，之后她把单词中的一些字母用下划线 `_` 替换。接下来 Lea 会用其他字母代替下划线。

Lea 认为如果一个单词不包含 $3$ 个及以上**连续的元音字母**、$3$ 个及以上**连续的辅音字母**，并且至少包含**一个**大写字母 `L`，那么这个单词就是**令人愉快**的。

**提示**：元音字母仅包含 $\texttt{a,e,i,o,u}$，其他的字母都是辅音字母。

求 Lea 有多少种方案将下划线替换成大写字母，使得这个单词是**令人愉快的**。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，字符串长度 $\le 100$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $70$。

题目译自 [**COCI2009-2010 CONTEST #1**](https://hsin.hr/coci/archive/2009_2010/contest1_tasks.pdf) _**T3 DOBRA**_。

## 样例 #1

### 输入

```
L_V```

### 输出

```
5```

## 样例 #2

### 输入

```
V__K```

### 输出

```
10```

## 样例 #3

### 输入

```
JA_BU_K_A```

### 输出

```
485```

# 题解

## 作者：251Sec (赞：3)

本来不想写这题，结果打开题解区清一色的搜索……

搜索在这题复杂度的确是对的，但是这题明显很适合 DP 啊！

设状态 $f_{i,j,0/1,0/1}$，表示前 $i$ 个字符，末尾有 $j$ 个连续的辅音/元音字符（前一个 0/1），未出现/出现过 L（后一个 0/1）。

很容易推出转移方程，然后就可以快乐地转移了！复杂度 $O(n)$。

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
char s[105];
ll f[105][3][2][2], ans;
bool check(char c) {
	return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
}
int main() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	f[0][0][1][0] = f[0][0][0][0] = 1;
	for (int i = 1; i <= n; i++) {
		if (s[i] == '_') {
			for (int j = 0; j <= 2; j++) {
				f[i][1][1][0] += f[i - 1][j][0][0] * 5;
				f[i][1][1][1] += f[i - 1][j][0][1] * 5;
				f[i][1][0][0] += f[i - 1][j][1][0] * 20;
				f[i][1][0][1] += f[i - 1][j][1][0] + f[i - 1][j][1][1] * 21;
			}
			f[i][2][1][0] = f[i - 1][1][1][0] * 5;
			f[i][2][1][1] = f[i - 1][1][1][1] * 5;
			f[i][2][0][1] = f[i - 1][1][0][0] + f[i - 1][1][0][1] * 21;
			f[i][2][0][0] = f[i - 1][1][0][0] * 20;
		}
		else {
			if (check(s[i])) {
				for (int j = 0; j <= 2; j++) {
					f[i][1][1][0] += f[i - 1][j][0][0];
					f[i][1][1][1] += f[i - 1][j][0][1];
				}
				f[i][2][1][0] = f[i - 1][1][1][0];
				f[i][2][1][1] = f[i - 1][1][1][1];
			}
			else {
				for (int j = 0; j <= 2; j++) {
					if (s[i] == 'L') {
						f[i][1][0][1] += f[i - 1][j][1][0];
					}
					else {
						f[i][1][0][0] += f[i - 1][j][1][0];
					}
					f[i][1][0][1] += f[i - 1][j][1][1];
				}
				if (s[i] == 'L') {
					f[i][2][0][1] += f[i - 1][1][0][0];
				}
				else {
					f[i][2][0][0] += f[i - 1][1][0][0];
				}
				f[i][2][0][1] += f[i - 1][1][0][1];
			}
		}
	}
	printf("%lld", f[n][1][0][1] + f[n][1][1][1] + f[n][2][0][1] + f[n][2][1][1]);
	return 0;
}
```

---

## 作者：_Fatalis_ (赞：2)

## solution

**题意简化**

一个字符串，将所有的 `_` 替换成大写字母，使结果字符串符合要求：

1、不包含三个连续 元音 或 辅音 字母；

2、字符串中至少有一个 `L` 。

求最终字符串可能的个数。

----

看到这道题，即想到了万能的算法——搜索。

从下标 $0$ 开始，枚举每一个字母。

由于每次枚举的字母与后面的枚举无关，所以这样搜索不会出现重复的终串。

在枚举结束时使用 check 检测是不是合法终串，如果是就是一种情况。

可惜，只会拿到可怜的 $30\%$ 的分数。

先来算算时间复杂度吧。

对于每次操作，都有每个 `_` 需要枚举 $26$ 次，同时最多有 $10$ 位，所以枚举次数最少 $26^{10}$ 次方，超时是稳稳的。

所以如何减少时间复杂度呢？

我们可以发现，这道题实际上**辅音字母之间并没有区别。**同理，对于元音字母也是如此。

所以，可以每次只枚举两次，对于辅音字母的结果乘 $26-5=21$；元音字母的结果乘 $5$。

还有一点要注意，由于 `L` 会影响结果，所以需要特殊考虑。

总共 $3$ 次，枚举次数降为 $3^{10}$ ，AC 稳稳的。

**AC Code：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int yy[127];

int check(char ns[])
{
	bool flag=0;

	for(int i=0,len=strlen(ns);i<len-2;i++)
	{
		if((yy[ns[i]]==1&&yy[ns[i+1]]==1&&yy[ns[i+2]]==1)
           ||
         ((!yy[ns[i]])&&(!yy[ns[i+1]])&&(!yy[ns[i+2]]))) return -1;
        
		if(!flag&&(ns[i]=='L'||ns[i+1]=='L'||ns[i+2]=='L')) flag=true;
	}
	return flag;
}

long long dfs(int i,char ns[])
{
	int len=strlen(ns);
	while(ns[i]!='_'&&i<len) i++;   //可优化递归层数，可惜只有100，没啥用
	if(i==len) return max(check(ns),0);
	if(check(ns)==-1) return 0;

	long long ans=0;
	ns[i]='A';  //这里泛指元音字母
	ans+=dfs(i+1,ns)*5;
	ns[i]='B';  //这里泛指辅音字母
	ans+=dfs(i+1,ns)*20;  //将 L 特殊考虑，21-1 即为 20
	ns[i]='L';
	ans+=dfs(i+1,ns);
	ns[i]='_';
	return ans;
}

int main()
{
	//init
	yy['A']=yy['E']=yy['I']=yy['O']=yy['U']=1;
	yy['_']=-1;


	char chr[1001];
	scanf("%s",chr);
	cout<<dfs(0,chr);
	return 0;
}
```

~~从 9 s 降到 30ms，质的提升啊！~~

---

哦。

---

## 作者：ChengJY_ (赞：1)


- 题意：给定一个只包含下划线和大写字母的字符串，将下划线全部换成大写字母，问有多少种填法能使这个字符串不包含 3 个及以上连续的元音字母、3 个及以上连续的辅音字母，并且至少包含一个大写字母 L。
- 这道题可以用深搜做的，从左到右进行遍历，遇到一个下划线搜一次并进行讨论，由于最多只有十个下划线，因此并不会TLE。
- 附代码：
```c
#include<bits/stdc++.h>
using namespace std;
long long dfs(int n);
string s;
int a[105],lens,l,x; 
int main(){
	cin>>s;
	lens=s.size();//字符串长度 
	for(int i=0;i<lens;i++){
		if(s[i]=='L') l=1;
		if(s[i]=='A' or s[i]=='E' or s[i]=='I' or s[i]=='O' or s[i]=='U') a[i+2]=1;//前移两格防止RE; 
		else  if(s[i]!='_') a[i+2]=2;
		else{
			a[i+2]=3;
			x=i+2;//标记最后一个下划线的位置 
		}
	}
	cout<<dfs(2)<<endl;//搜！ 
	return 0;
} 
long long dfs(int n){
	if(n==lens+2)
		return 1;
	if(a[n]==1 or a[n]==2)
		return dfs(n+1);
	if((a[n-1]==1 and a[n-2]==1 and a[n+1]==2 and a[n+2]==2) or (a[n-1]==2 and a[n-2]==2 and a[n+1]==1 and a[n+2]==1))//这种情况下无法填入 
		return 0;
	long long w=0;
	else if((a[n-1]==1 and a[n-2]==1) or (a[n-1]==1 and a[n+1]==1) or (a[n+1]==1 and a[n+2]==1)){//只能填辅音字母 
		a[n]=2;
		if(n==x and l==0){//对有无L进行讨论 
			l=1;
			w+=dfs(n+1); 
			l=0;
		}
		else if(l==0){
			l=1;
			w+=dfs(n+1);
			l=0;
			w+=dfs(n+1)*20;
		} 
		else if(l==1){
			w+=dfs(n+1)*21;
		}
		a[n]=3;
	}
	else if((a[n-1]==2 and a[n-2]==2) or (a[n-1]==2 and a[n+1]==2) or (a[n+1]==2 and a[n+2]==2)){//只能填元音字母 
		a[n]=1;
		w+=dfs(n+1)*5;
		a[n]=3;
		if(n==x and l==0)//若搜到最后一个时必须填入L但是又只能填入元音字母，这种情况也不可能。 
			return 0;
	} 
	else{//二者都可以填 
		a[n]=2;
		if(n==x and l==0){
			l=1;
			w+=dfs(n+1); 
			l=0;
			a[n]=3;
			return w;
		}
		else if(l==0){
			l=1;
			w+=dfs(n+1);
			l=0;
			w+=dfs(n+1)*20;
		} 
		else{
			w+=dfs(n+1)*21;
		}
		a[n]=1;
		w+=dfs(n+1)*5;
		a[n]=3;
	}
	return w;
}
```
- 我的代码应该比较好理解，复杂度应该也比较优。

- 几个注意点：
1. 对下划线的讨论要细一些。(~~我就因为没讨论完全A了好几次~~)
1. 对L也要进行讨论！(~~这应该是这道题最恶心的一个点了~~)
1. 别忘了开long long!

------------

欢迎各位巨佬指正蒟蒻的错误或者麻烦之处。



---

## 作者：Po7ed (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/P7541)**

### 错误思路

暴力搜，搜每个下划线位置的字母，记下划线个数为 $m$，则 $m\le10$，时间复杂度 $O(26^m)$，超时。

### 正解
#### 思路
很容易想到其实 $5$ 个元音字母**没有本质区别**，除了 $\texttt{L}$ 外的辅音字母也一样。我们在搜时只需要在下划线处搜：
1. 元音字母
2. 除 $\texttt{L}$ 外的辅音字母
3. $\texttt{L}$

三个情况即可。

**需要注意的是：**
由于搜元音时，我们可以在下划线处填**任意元音字母**，所以填元音字母的方案数要乘以 $5$。同理，搜除 $\texttt{L}$ 外的辅音字母时要乘以 $26-5-1=20$。$\texttt{L}$ 就不需要了，因为只可能填 $\texttt{L}$。

#### 代码
```cpp
#include <iostream>
using namespace std;

string s;
#define isyy(c) (c=='A'||c=='E'||c=='I'||c=='O'||c=='U')//判断是否是元音
long long dfs(int dep,int y,int f,bool L)//y：连续元音个数，f：连续辅音个数，L：当前是否有‘L’
{
	if(y>=3||f>=3)
	{
		return 0;
	}
	if(s.size()<=dep)
	{
		return (long long)L;//有‘L’才“令人愉快”
	}
	long long t=0;
	if(s[dep]=='_')
	{
		//填元音字母
		s[dep]='A';//用‘A’代表元音
		t+=5*dfs(dep+1,y+1/* 连续元音数量加1 */,0/* 连续辅音数量清0。下同。 */,L);//一共可填5种元音
		//填辅音字母
		s[dep]='B';//用‘B’代表辅音
		t+=20*dfs(dep+1,0,f+1,L);//‘L’特殊考虑，26-5-1=20，一共可填20种辅音
		//填‘L’
		s[dep]='L';
		t+=dfs(dep+1,0,f+1,true);
		s[dep]='_';//恢复原状
		return t;
	}
	else//如果不是下划线
	{
		if(isyy(s[dep]))
		{
			return dfs(dep+1,y+1,0,L);
		}
		else
		{
			if(s[dep]=='L')
			{
				return dfs(dep+1,0,f+1,true);
			}
			else
			{
				return dfs(dep+1,0,f+1,L);
			}
		}
	}
}

int main()
{
	cin>>s;
	printf("%lld",dfs(0,0,0,false));
	return 0;
}
```
### 注意
>你需要使用 $64$ 位有符号整数。在 C/C++ 中使用 `long long`，Pascal 中使用 `int64`。
——题面

---

## 作者：NaOHqwq (赞：0)

## 题意

首先，有一个“令人愉快的”单词标准：

- 不包含 $3$ 个及以上连续的元音字母；
- 不包含 $3$ 个及以上连续的辅音字母；
- 至少包含一个大写字母 `L`；

然后要把一个含有下划线的单词中的下划线替换成大写字母，问有多少种替换方法能使这个单词是“令人愉快的”。

## 思路

跟楼下大佬的思路较为相似，笔者下意识想到的也是用搜索（可能是因为其他算法不太熟），当然也有其他好方法比如 DP，这里就先介绍搜索做法了。

输入字符串（即含有下划线的单词），深搜从左往右遍历，每遍历到一个下划线就按上面的标准分析一下。最后输出方案总数就可以啦。

小贴士：一定要开 `long long`！

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char vowels[5] = {'A', 'E', 'I', 'O', 'U'};
char s[101];
int len;
int check(char x){
	for(int i = 0;i < 5;i++){
		if(x == vowels[i]){
			return 1;
		}
	}
	return 0;
} //是否是元音
long long dfs(int x, int vl, int cs, bool flag){
	if(vl>=3 || cs>=3){ //不满足第一条与第二条
		return 0;
	}
	if(x == len){
		if(flag == true){
			return 1;
		}else{
			return 0;
		}
	}
	if(s[x] == '_'){ //遍历到下划线
		return 20*dfs(x+1,0,cs+1,flag) + dfs(x+1,0,cs+1,true) + 5*dfs(x+1,vl+1,0,flag);
	}else{
		if(check(s[x]) == 1){ //是元音
			return dfs(x+1, vl+1, 0, flag);
		}
		else{ //不是元音
			if(s[x] == 'L'){ //是大写“L”
				return dfs(x+1, 0, cs+1, true);
			}else{ //不是
				return dfs(x+1, 0, cs+1, flag);
			}
		}
	}
} //搜索函数不要忘了long long
int main(){
    gets(s);
    len = strlen(s);
    cout << dfs(0, 0, 0, false) << endl;
    return 0;
}
```

---

## 作者：Asimplename (赞：0)

## 思路

我们可以用 dfs 遍历这个字符串，记录 $3$ 种状态：当前位置，当前种数和是否含有 $\texttt{L}$。 如果该位置是已知字母，则判断是否已经不满足要求了，不满足直接 return 即可。否则递归到下一字符。如果该位置是下划线，可以尝试填入元音，辅音（除了 $\texttt{L}$），和 $\texttt{L}$，记录状态，递归到下一字符即可。

## 代码

```cpp
#include<iostream>
using namespace std;
string str;
long long ans;
bool yuan(char c){
	if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'){
		return true;
	}
	return false;
}
void dfs(int cc, long long res, bool fl){
	if(cc == str.size()){
		if(fl){
			ans += res;
		}
		return;
	}
	if(str[cc] == 'L'){//当前位置是 L
		if(cc >= 2){
			if(!yuan(str[cc - 1]) && !yuan(str[cc - 2])){
				return;
			}
		}
		dfs(cc + 1, res, true);
	}
	else if(str[cc] != '_'){//当前位置是除了 L 的已知字符
		if(cc >= 2){
			if(!yuan(str[cc]) && !yuan(str[cc - 1]) && !yuan(str[cc - 2])){
				return;
			}
			else if(yuan(str[cc]) && yuan(str[cc - 1]) && yuan(str[cc - 2])){
				return;
			}
		}
		dfs(cc + 1, res, fl);
	}
	else{//当前是下划线
		if(cc >= 2){
			if(!yuan(str[cc - 1]) && !yuan(str[cc - 2])){//只能填元音
				str[cc] = 'A';
				dfs(cc + 1, res * 5, fl); 
				str[cc] = '_';
			}
			else if(yuan(str[cc - 1]) && yuan(str[cc - 2])){//只能填辅音或 L
				str[cc] = 'F';
				dfs(cc + 1, res * 20, fl);
				str[cc] = '_';
				str[cc] = 'L';
				dfs(cc + 1, res, true);
				str[cc] = '_'; 
			}
			else{//都可以填
				str[cc] = 'A';
				dfs(cc + 1, res * 5, fl); 
				str[cc] = '_';
				str[cc] = 'F';
				dfs(cc + 1, res * 20, fl);
				str[cc] = '_';
				str[cc] = 'L';
				dfs(cc + 1, res, true);
				str[cc] = '_'; 
			}
		}
		else{//都可以填
			str[cc] = 'A';
			dfs(cc + 1, res * 5, fl); 
			str[cc] = '_';
			str[cc] = 'F';
			dfs(cc + 1, res * 20, fl);
			str[cc] = '_';
			str[cc] = 'L';
			dfs(cc + 1, res, true);
			str[cc] = '_'; 			
		}
	}
}
int main (){
	cin >> str;
	dfs(0, 1, false);
	cout << ans;
	return 0;
} 

---

## 作者：QuAckB33 (赞：0)

## 题意：
- 给出一个字符串，在其中的下划线上填大写字母。
- 要求填好后字符串不包含 3 个及以上连续的元音字母、3 个及以上连续的辅音字母，并且至少包含一个大写字母 L。
- 问有多少种填法。

## 分析:
- 遇到空格后需要分三种情况讨论，不难发现这可以用深搜。
- 对于不包含 3 个及以上连续的元音字母、3 个及以上连续的辅音字母，并且至少包含一个大写字母 L，可以搜索时记录下元音字母、辅音字母、L 目前的情况。
- 具体见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
char yyb[5]={'A','E','I','O','U'};//元音表
char str[105];
int len;
int check(char x){//判断是元音还是辅音
	for(int i=0;i<5;i++){
		if(x==yyb[i]) return 1;
	}
	return 0;
} 
long long dfs(int x,int yy,int fy,bool l){//当前位置x,连续元音数量yy,连续辅音数量fy,是否有l
	if(yy>=3||fy>=3) return 0;//如果有超过3个元音或辅音,就舍弃,情况数量为0
	if(x==len){//搜完整个序列后,判断有没有 L
		if(l==true) return 1;//有 L 说明情况可行
		else return 0;//没有就舍
	}
	if(str[x]=='_'){
		return 20*dfs(x+1,0,fy+1,l)+dfs(x+1,0,fy+1,true)+5*dfs(x+1,yy+1,0,l);
	}//如果是下划线,那么情况数就是填辅音的(除去 L ),填 L 的,填元音的情况和
	else{
		if(check(str[x])==1){
			return dfs(x+1,yy+1,0,l);//是元音,那么元音数量加一,辅音数量清零, L 不变,下同
		}
		else{
			if(str[x]=='L') return dfs(x+1,0,fy+1,true);
			else return dfs(x+1,0,fy+1,l);
		}
	}
}
int main(){
    gets(str);
    len=strlen(str);
    cout<<dfs(0,0,0,false);//别忘了 long long!!
    return 0;
}
```


---


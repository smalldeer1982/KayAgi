# [COCI 2009/2010 #1] MALI

## 题目描述

Mirko 和 Slavko 正在玩游戏。游戏共有 $N$ 个回合，在第 $k$ 个回合，Slavko 给出两个整数 $A_k$ 和 $B_k$。请你帮助 Mirko 解决以下问题：

前 $k$ 个回合中 Slavko 给出了数字 $A_1,A_2,...,A_k$ 和 $B_1,B_2,...,B_k$。将这些数两两配成 $k$ 个数对 $(A_i,B_j)$（$1 \le i,j \le k$），使得序列 $A$ 和序列 $B$ 的每一个数**都只在这些数对中出现一次**，并且使所有数对的**和**（$A_i + B_j$）**的最大值最小**。

## 说明/提示

#### 【数据范围】

对于 $50\%$ 的数据，$1 \le N \le 200$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le A_i,B_i \le 100$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $100$。

题目译自 [**COCI2009-2010 CONTEST #1**](https://hsin.hr/coci/archive/2009_2010/contest1_tasks.pdf) _**T4 MALI**_。

## 样例 #1

### 输入

```
3
2 8
3 1
1 4```

### 输出

```
10
10
9```

## 样例 #2

### 输入

```
3
1 1
2 2
3 3```

### 输出

```
2
3
4```

# 题解

## 作者：xuchenxi (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P7542)

## 题意理解

给定两个数组 $A _ {i}$ 和 $B _ {i}$ 。对于任意 $1\le k \le n$ ，将前  $k$ 组数两两配成  $k$ 个数对 $(A _ {i} , B _ {j})$ 。求出所有数对的和 $(A _ {i} ^ {} + B _ {j} ^ {})$ 中最大值的最小可能值。

## 题目分析

一道贪心的好题。

### 贪心结论

升序排序后将 $A _ {i}$ 和 $B _ {n-i+1}$ 配成一对最优。

### 结论证明

不妨设 $A _ {i}$ 是 A 中最大的元素， $B _ {j}$ 是 B 中最小的元素。

若将 $B _ {j}$ 替换为 $B _ {k} ^ {}$ $(B _ {j} \le B _ {k})$ ，则 $A _ {i} + B _ {k} \ge A _ {i} + B _ {j}$ 。即替换后不优于替换前，得证。

## 暴力解法: 50pts

输入 $A _ {i}$ 和 $B _ {i}$ 后直接排序,
暴力查找数对和的最小值，复杂度 $O(n _ {} ^ {2} \log{n})$ 。

Code

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int n;
int a[maxn],b[maxn];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
		sort(a+1,a+i+1);
		sort(b+1,b+i+1);
        int ans=0;
		for(int j=1;j<=i;j++)
        ans=max(ans,a[j]+b[i-j+1]);
        cout<<ans<<"\n";
	}
	return 0;
}
```

## 正解：桶排序

上面的暴力显然会超时。

### 优化：
- 观察到 $n$ 的范围虽然很大，但 $A _ {i}$ 和 $B _ {i}$ 的范围极小，所以想到桶排序。
- 将和相同的数对预处理掉一部分。

AC Code

```
#include<bits/stdc++.h>
using namespace std;
const int maxa=105;
int n;
int a,b;
int x[maxa],y[maxa];
int cnta[maxa],cntb[maxa];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int ans=0;
		cin>>a>>b;
		cnta[a]++,cntb[b]++;
		for(int j=1;j<maxa;j++)
		{
			x[j]=cnta[j];
			y[j]=cntb[j];
		}
		int l=1;
		int r=100;
		while(l<=100)//优化1
		{
			while(!x[l] && l<=100) l++;
			while(!y[r] && r>=1) r--;
			if(l>100) break;
			ans=max(ans,l+r);
			int g=min(x[l],y[r]);//优化2
			x[l]-=g;
			y[r]-=g;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

 END

---

## 作者：skyskyCCC (赞：3)

# 前言。
一道贪心题。
# 分析。
每次将 $A$ 中的数从大到小与 $B$ 中的数从小到大一一对应配对。

证明如下：  
选取 $A$ 数列中最小的数 $a_i$ 和 $B$ 数列中最大的数 $b_j$ 两个数。

若将 $a_i$ 替换为比其大的数 $a_q$ 的情况下，根据等式的性质，那么可得 $a_q$ 与 $b_j$ 的和一定大于 $a_i$ 与 $b_j$ 的和。  
此时相对于原计划答案较大。

同理，将 $b_j$ 替换后也不比原计划更优。

所以，贪心得证。

但是如果直接这么去算，时间复杂度较高，可以考虑桶优化。需要注意的是桶排序配对后应该将个数减一，而不是跳过执行下一个数。

并且注意不能修改原来的数组。

代码如下，仅供参考：
```
#include<bits/stdc++.h>
using namespace std;
int n,ai,bi,a[105],b[105],at[105],bt[10],minn;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int maxx=-0x3f3f3f,l=1,r=100;
		cin>>ai;
		at[ai]++;
		cin>>bi;
		bt[bi]++;
		memcpy(a,at,sizeof(at));
		memcpy(b,bt,sizeof(bt));
		while(r>=1&&l<=100){
			while(!a[l]){
			    l++;
			}
			while(!b[r]){
			    r--;
			}
			if(r<1||l>100){
			    break;
			}
			maxx=max(maxx,l+r);
			minn=min(a[l],b[r]);
			a[l]-=minn;
			b[r]-=minn;
		}
		cout<<maxx<<"\n";
	}
	return 0;
}
```
# 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：mayike (赞：2)

~~前面dalao太多了，水篇题解~~~
## 思路
这题单是暴力贪心肯定是过不了的，所以我们应该想想怎么优化，当看到

$$1 \le A_i,B_i \le 100$$

就想到了桶排序，~~当然是同学提醒了亿一下~~，这样我们就可以做到简约版的 $O(n)$ 复杂度啦（蒟蒻不会计算复杂度，勿喷）！
 
贪心与证明就不发了，相信大家一定能想到的吧！
 
这里需要注意的是，因为数对中的数可能出现重复（为什么？那 $n$ 怎么可能那么大），所以用数组加个数要加加（口述不清），如：
 ```
a[x]++;b[y]++;
```
记录出现个数。

这里我们共开四个数组：
```
a[],b[],x[],y[];// x,y 分别对应 a,b 数组
```
前两个分别记录出现个数，后两个在每一轮被前两个赋值（不要问为啥要重新赋值，那是因为后续会变换）。

哎，讲不了啦，上代码，有注释哒：
```
int l=1,r=100;//范围只有1~100
while(l<=100&&r>=1){//只要有一个越界就配对完了
	while(!x[l]&&l<=100)l++;//人要往未来看
	while(!y[r]&&r>=1)r--;//emm，往前看吧
	if(l>100||r<1)break;//一旦越界，走人
	ans=max(ans,l+r);//找大哥
	pt=min(x[l],y[r]);//有重复的就都清掉，不然越往后越大
	x[l]-=pt;y[r]-=pt;//用掉了就用掉了吧
}//太臭啦，完整代码不发啦
```
来 $n$ 次循环，依次输出 $ans$ 就完啦！

---

## 作者：hjqhs (赞：2)

### 一道贪心题
### 结论
每次将 $A$ 数列中最小的数与 $B$ 数列中最大的数配对。
### 结论证明
设 $A$ 数列最小数为 $A_i$，$B$ 数列最小数为 $B_j$。  
若将 $A_i$ 替换成 $A$ 数列中任意一个比 $A_i$ 大的数 $A_k$，那么和变为 $A_k + B_j$，必定大于原本的 $A_i + B_j$，答案并没有原答案优，故不能替换。  
同理 $B_j$ 也不能替换。  
贪心得证。  
### 优化
直接这样做时间复杂度过高，无法通过本题，故考虑优化。  
#### 优化一
注意题目范围 $1 \le A_i,B_i \le 100$，可以使用桶排序。注意桶排序配对成功后应该将个数减一而不是跳过。
#### 优化二
如果有多个相同的 $A_i,B_j$，就会配出 $\min(A_i,B_j)$ 组一模一样的配对。那么桶排序配对成功个数减去 $\min(A_i,B_j)$ 即可。
### 代码
目前的最优解。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
int n,a[105],b[105],ah[105],bh[105];
int read(){//快读
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+(ch-'0');
		ch=getchar();
	}
	return x*f;
}
int main(){
	n=read();
	for(int i=1;i<=n;++i){
		int big=-inf,tmp,l=1,r=100;
		tmp=read();++ah[tmp];//桶
		tmp=read();++bh[tmp];
		memcpy(a,ah,sizeof(ah));//将桶复制避免直接修改桶内元素
		memcpy(b,bh,sizeof(bh));
		while(1<=r&&l<=100){
			while(!a[l])++l;//找到最小的l
			while(!b[r])--r;//找到最大的r
			if(r<1||l>100)break;
			if(l+r>big)big=l+r;
			int minappcnt=min(a[l],b[r]);//含义见上文
			a[l]-=minappcnt;
			b[r]-=minappcnt;
		}
		printf("%d\n",big);
	}
	return 0;
}
```

---

## 作者：CleverPenguin (赞：1)

# 算法：贪心。
基本思路：每回读入数据，进行排序，取两个数组一大一小计算
尝试直接暴力排序，查找（预计 $50$ 分）。

------------

暴力拙作：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,a[105],b[105],maxx,z1,z2,m;
bool cmp(int a,int b){
	return a>b;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		maxx=INT_MIN;
		scanf("%d%d",&a[i],&b[i]);
		sort(a+1,a+i+1);
		sort(b+1,b+i+1,cmp);
		for(int j=1;j<=i;j++){
			maxx=max(maxx,a[j]+b[j]);
		}
		printf("%d\n",maxx);
	}
	return 0;
}
```
TLE 五个点。

对数据范围进行观察，发现 $1\le a[i]<b[i]\le 100$。

数据范围小，用桶存储，排序

遇到最小的 $a[x]$ 与 $b[y]$ 就与 $maxx$ 比较。

**注意：每回使用桶都需要再次用另一个数组存储，否则桶内数据只有新读入的,配对完后应将桶内数据减去两个配对值的小者。**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,a[105],b[105],t1[105],t2[105],maxx,z1,z2,m;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		maxx=INT_MIN,z1=1,z2=100;
		scanf("%d%d",&x,&y);
		t1[x]++;//入桶 ;
		t2[y]++;
		memcpy(a,t1,sizeof(t1));//每回计算不能改变原数组，做复制； 
		memcpy(b,t2,sizeof(t2));
		while(z2>=1&&z1<=100){//a[i]与b[i]的范围 ； 
			while(!a[z1]&&z1<=100)z1++;//找到最值 ;
			while(!b[z2]&&z2>=1)z2--;
			if(z1>100||z2<1)break;
			m=min(a[z1],b[z2]);
			a[z1]-=m;//取小的那个作为配对成功的个数，桶内数量减去；
			b[z2]-=m;
			maxx=max(maxx,z1+z2);
		}
		printf("%d\n",maxx);
	}
	return 0;
}
```

---

## 作者：_Fatalis_ (赞：1)

又双叒叕~~水~~了一篇题解...

**题目简述**

对于两个序列 A，序列 B，长度一致；

共 $n$ 次操作，

每次操作都会向这两个序列增加数字。

**在每次操作后**，要求对每个序列中的每个数字配对，要让**配对数之和**的**最大值最小**。



### Solution

**贪心。**

对每时每刻的序列排序，$a$ 中**从小到大**与 $b$ 中**从大到小**配对。

证明：

对于序列中最小的 $a_i$，序列最大的$b_j$，

若将 $a_i$ 替换成 $a_k$ 且 $a_k>a_i$ ，此时必有 $a_k+b_j>a_i+b_j$，不必原计划更优；

若将 $b_j$ 替换成 $b_k$，且 $b_j<b_k$，则必有 $a_z>a_i$ 需要与 $b_j$ 配对。所以必有更大值 $a_z+b_j>a_i+b_j$，也不必原计划更优。

所以，每次选择最小和最大的配对可以得到最优解。



可惜直接排序时间复杂度不够。

时间复杂度为 $O(n^2\log n)$，$n\leq 10^5$，超时。

**优化。**

1、桶优化

发现 $1\leq a_i,b_j\leq 100$，所以考虑直接桶排。

时间复杂度降为 $O(n^2)$。

2、连续配对优化

发现当 $a_i,b_j$ 出现多次时，会直接配出 $\min(a_i,b_j)$ 组一样的配对。

所以对于桶中 $a_i,b_j$ ，每次配对时，对应减少 $\min(a_i,b_j)$ 即可。

最坏时间复杂度为 $O(100n)$ ，不会超时。



**AC Code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101],b[101];
int am[101],bm[101];

int main()
{
	int n,k,maxn=-414231;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		maxn=-414231;
		cin>>k,am[k]++;
		cin>>k,bm[k]++;  //优化1
		memcpy(a,am,sizeof(am));
		memcpy(b,bm,sizeof(bm)); //复制桶
		int l=1,r=100;
		while(r>=1&&l<=100)
		{
			while(!a[l]) l++;
			while(!b[r]) r--;
			if(r<1||l>100) break;
			maxn=max(maxn,l+r);
			minx=min(a[l],b[r]);
			a[l]-=minx;b[r]-=minx;  //优化2
		}
		cout<<maxn<<endl;
	}
	return 0;
}
```

---

qwq

---

## 作者：ChengJY_ (赞：1)

- 基本思路：贪心，每次将 $A$ 中的数从大到小与 $B$ 中的数从小到大一一对应组合，即 $A$ 中最大的数与 $B$ 中最小的数组合， $A$ 中第二小的数与 $B$ 中第二大的数组和，其中最大的数对即为所求。
- 像这样:
![](https://cdn.luogu.com.cn/upload/image_hosting/as766mzf.png)
- 非常简单易懂的贪心。
- 但是俗话说得好，贪心不难，但是难的是证明。
- ~~非常随意的~~证明：
- 设数对 $(A_1,B_1)$ 是最大数对，下一个数对为 $(A_2,B_2)$ 。
- 根据我们之前的贪心思路，可知
	
    $A_1<A_2,B_1>B_2$
    
- 而要使最大数对的最大值减小，要么将 $A_1$ 与 $B$ 中更小的数组合，要么将 $B_1$ 与 $A$ 中更小的数组合,以前一种方法为例，新的两个数对为
	
    $(A_2,B_1)$ 和 $(A_1,B_2)$
  
-   很容易发现

	$A_2+B_1>A_1+B_1$
	
- 所以这样做反而会使最大值变得更大，后一种方法也一样，因此 $(A_1,B_1)$ 一定是所求的最大数对。
- 证毕。
- 在程序的具体实现中，由于 $1\leq A_i,B_i\leq 100$ ，还可以用桶排进行优化。
- 具体看代码：
```c
#include<bits/stdc++.h>
using namespace std;
int n,a[105],b[105],c[105],d[105],x,y;
inline int read(){//快读 
	char ch=getchar();
	int x=0,w=1;
	while((ch>'9' || ch<'0') && ch!='-')ch=getchar();
	if(ch=='-')w=-1,ch=getchar();
	while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*w; 
}
int find(){
	int i=1,j=100,maxx=0;
	for(int k=1;k<=100;k++)//因为要对数组进行操作，所以用c,d数组进行代替。 
		c[k]=a[k],d[k]=b[k];
	while(i<=100 and j>=1){
		while(!c[i] and i<=100)
			i++;
		while(!d[j] and j>=1)
			j--;
		if(i>100 or j<1)
			break;
		maxx=max(i+j,maxx);//对最大值进行更新。
		int w=min(c[i],d[j]);
		d[j]-=w;c[i]-=w;
	}
	return maxx;
}
int main(){
	n=read();
	for(int i=1;i<=n;++i){
		x=read();y=read();
		a[x]++;b[y]++;
		printf("%d\n",find());
	}
} 
```

- 然后就可以愉快地把这题水掉了。



---

## 作者：DogWing (赞：0)

### 思路
使用贪心的方法，和的最大值最小的取法是从数列的两头拿（最大值和最小值）。再枚举每一个回合即可。由于数据较小，可以使用桶排序，用一个数取一个数。
### 代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <set>
using namespace std;
int n,a,b,tonga[105],tongb[105],l=999999,r,maxx,tonga1[105],tongb1[105],l1,r1;//l记录最小值，r记录最大值
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		maxx=0;
		tonga[a]++;
		tongb[b]++;
		l=min(l,a);
		r=max(r,b);
		for(int j=1;j<=100;j++)//复制
		{
			tonga1[j]=tonga[j];
			tongb1[j]=tongb[j];
		}
		l1=l;
		r1=r;
		while(l1<=100)
		{
			while(tonga1[l1]==0&&l1<=100)//找最小值
			{
				l1++;
			}
			while(tongb1[r1]==0&&r1>=0)//找最大值
			{
				r1--;
			}
			if(r1<0||l1>100)
			{
				break;
			}
			maxx=max(maxx,l1+r1);
			int minn=min(tonga1[l1],tongb1[r1]);
			tonga1[l1]-=minn;
			tongb1[r1]-=minn;//优化，每次取得尽量多，防止TLE
			
		}
		cout<<maxx<<endl;
	}
	
	return 0;
}
```

---

## 作者：Autream (赞：0)

#### 题意简述
$N$ 组询问，第 $k$ 次询问给出两个数 $A_k$ 和 $B_k$，将这些数字两两配对，使得配的数对的两个数的和的最大值最小。

---
#### 题目分析
贪心。

对于第 $k$ 组询问，只需要将 $A$ 的最小值和 $B$ 的最大值配对，这样的数对一定是最小的，只需要找出最大的数对即可。

证明：

- 对于 $A$ 的最小值 $A_i$  和 $B$ 的最大值 $B_j$，如果有 $A_q > A_i$ ，那么所凑出的数对一定大于期望值。
- 对于 $B$ 数组同理。
证毕。

但是这样做时间复杂度会超，观察数据范围 $1 \leq A_i,B_i \leq 100$，考虑用桶记录每个数字有多少个，然后遍历桶来求解，注意每次配对后要在桶里面减去与当前配对相同的数量，避免重复遍历。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=105;
int n,a[N],b[N],vis1[N],vis2[N];
signed main() {
    std::cin>>n;
    rep(i,1,n) {
        int x,y,ans=LLONG_MIN;
        std::cin>>x>>y;
        vis1[x]++;
        vis2[y]++;
        memcpy(a,vis1,sizeof a);
        memcpy(b,vis2,sizeof b);
        int l=1,r=100;
        while(l<=100&&r>=1) {
            while(!a[l]) {
                l++;
            }
            while(!b[r]) {
                r--;
            }
            if(r<1||l>100) {
                break;
            }
            ans=std::max(ans,l+r);
            int cnt=std::min(a[l],b[r]);
            a[l]-=cnt;
            b[r]-=cnt;
        }
        std::cout<<ans<<"\n";
    }
    return 0;
}
```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

给定一个正整数 $n$ 和数字 $A_{1 \dots n},B_{1 \dots n}$，将 $A_{1 \dots n}$ 和 $B_{1 \dots n}$ 中的数字两两相互组合，求产生出来的组合中和最大的一组的最小值。

## Part 2 思路

由于是要使最大值最小，因此很容易可以想到，我们要将 $A_{1 \dots n}$ 中第 $i$ 小的数与 $B_{1 \dots n}$ 中第 $i$ 大的数字组合在一起。证明过程如下：

- 对于 $A_{1 \dots n}$ 中最小的数 $a$，如果我们要在 $B_{1 \dots n}$ 中选定一个数 $b$ 与之组合。若 $B_{1 \dots n}$ 中有一值 $d > b$，则在 $a$ 与 $b$ 组合后，之后考虑的大于 $a$ 的数 $c$ 就会出现与 $d$ 组合的情况。可以发现 $a < c$ 又 $b < d$，所以 $a+c<b+c$，导致最终结果偏大。

因此，每一次考虑 $A_{1 \dots n}$ 的最小数 $a$ 时，都要与 $b_{1 \dots n}$ 中的最大值 $b$ 组合。下一次运算就不需要再考虑 $a,b$ 了，直到 $A_{1 \dots n},B_{1 \dots n}$ 中的所有数都组合完为止。

## Part 3 优化

我们要计算每个只考虑 $A_{1 \dots i}$ 和 $B_{1 \dots i}$ 时的最小值，而每次计算组合结果又要花费 $O(n)$ 的时间复杂度，且 $1 \leq n \leq 10^5$，有超时风险。

同时，我们发现 $1 \leq A_i,B_i \leq 100$，所以可以用桶的方式存下 $A_{1 \dots n},B_{1 \dots n}$ 的值。

那么，如何将 $A_{1 \dots n},B_{1\dots n}$ 中的数一一组合呢？

当我们将 $A_{1 \dots n},B_{1 \dots n}$ 分别存在桶数组 $c,d$ 中时，让 $c$ 从小到大遍历，$d$ 从大到小遍历，就可以每次都找出 $A_{1 \dots n}$ 中的最小值和 $B_{1 \dots n}$ 中的最大值了。

值得注意的是，因为 $A_{1 \dots n},B_{1 \dots n}$ 中的值可能会存在重复，因此我们每次在遍历 $c$ 和 $d$ 的时候，不能对一个数考虑过一遍之后就考虑下一个数，而是将这个数的个数减一。

不幸的是，如果我们每一次都慢慢的考虑 $c$ 与 $d$ 中的数据，时间复杂度还是会到达 $O(n)$。经过思考，我们能够想出以下规律：

- 如果数据 $a$ 和数据 $b$ 分别有 $x$ 个和 $y$ 个，并且在组合时将 $a$ 和 $b$ 组合在一起，那么两者可以组合的次数为 $\min (x,y)$。

这是因为，在考虑完 $a,b$ 后下一组考虑到数还是 $a,b$，这种价值低的计算会持续 $\min(x,y)$ 次，所以通过一次性减去 $\min(x,y)$ 可以加快程序速度。

那么，我们只要令 $left$ 为 $A_{1 \dots n}$ 中的最小值，$right$ 为 $B_{1 \dots n}$ 中的最大值，每次都查找 $left$ 和 $right$ 的值并计算就好了。

当然，程序结束的标志就是 $left$ 和 $right$ 超过了数据的范围，因为这代表 $c$ 和 $d$ 都被遍历完了，即组合完毕，就能输出答案了。

注：以上对 $A_{1 \dots n},B_{1 \dots n}$ 极值的查找，即 $left$ 与 $right$ 的使用参考了 [skyskyCCC](https://www.luogu.com.cn/user/541739) 的思路，在这里表示感谢！

## Part 4 代码

```
#include <bits/stdc++.h>
using namespace std;
int n,a[105],b[105],c[105],d[105];
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		int x,y,left=1,right=100,result=-0x3f;
		cin>>x>>y;c[x]++,d[y]++;
		for (int j=1;j<=100;j++) a[j]=c[j],b[j]=d[j];
		while (1==1)
		{
			for (;a[left]==0;left++) ;
			for (;b[right]==0;right--) ;
			if (left>100 || right<1) break;
			result=max(result,left+right);
			int sum=min(a[left],b[right]);
			a[left]-=sum,b[right]-=sum;
		}
		cout<<result<<endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# P7542 [COCI2009-2010#1] MALI 题解

[题面](https://www.luogu.com.cn/problem/P7542)

## 思路

-  这是一道贪心题

### 分析

- 每次将 $A$ 中的数从大到小与 $B$ 中的数从小到大一一对应配对。

 	证明：
    1. 选取 $A$ 中最小的数 $a_i$ 和 $B$ 中最大的数 $b_j$。

    2. 若将 $a_i$ 替换为比其大的数 $a_q$，那么根据等式的性质，那么可得 $a_q$ 与 $b_j$ 的和一定大于 $a_i$ 与 $b_j$ 的和。

    3. $b_j$ 同理。

    4. 得证。

- 但是如果直接这么去算，时间复杂度较高，可以考虑用桶优化。需要注意的是桶排序配对后应该将个数减一，而不是跳过执行下一个数。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define endl '\n'

const int maxn=201;
int n,a[maxn],b[maxn],mp[maxn],mp2[maxn],minn;

signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int maxx=-0x3f3f3f,l=1,r=100;
		int flag,flag2;
		cin>>flag>>flag2;
		mp[flag]++;
		mp2[flag2]++;
		memcpy(a,mp,sizeof(mp));
		memcpy(b,mp2,sizeof(mp2));
		while(r>=1&&l<=100)
		{
			while(l<=100&&!a[l])
			{
				l++;
			}
			while(r>=1&&!b[r])
			{
				r--;
			}
			if(r<1||l>100)
			{
				break;
			}
			maxx=max(maxx,l+r);
			minn=min(a[l],b[r]);
			a[l]-=minn;
			b[r]-=minn;
		}
		cout<<maxx<<'\n'; 
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

~~水社贡ing~~

# 题意
题目说有个人 ``Slavko`` 给 ``Mirko`` 每轮出两个数加进两个数组 $A$ 和 $B$ ，让你找出一种排列方式，使 $a_i+b_j$ 的最大值最小。

# 思路
我们肯定不能无厘头枚举。

~~我一开始就这么想的~~

其实是数学题，只需要让 $A$ 数组从大到小排， $B$ 数组从小到大拍，一一配对就可以了。

**证明**

我们找 $A$ 里面最大值 $a_{x}$ 和 $B$ 里面最小值 $b_{y}$ 。

假设将 $a_{x}$ 替换为另外一个比他小的数 $a_i$ , 那 $a_{x}$ 就得和 $B$ 里面的另一个数 $b_j$ 加起来，那这样一定会不优于原解。

将 $b_{y}$ 替换同理。

## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,i,a,b,xx[105],yy[105],aa[105],bb[10];
int maxn=INT_MIN/2;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
    	        int a,b,minn;
		cin>>a;
		cin>>b;
		aa[a]++;
		bb[b]++;
                memset(xx,0,sieof xx);
                memset(yy,0,sieof yy);
		memcpy(xx,aa,sizeof aa);
		memcpy(yy,bb,sizeof bb);
		while(r>=1&&l<=100){
			while(!xx[l]){
			    l++;
			}
			while(!yy[r]){
			    r--;
			}
			if(r<1||l>100){
			    break;
			}
			maxn=max(maxn,l+r);
			minn=min(xx[l],yy[r]);
			xx[l]-=minn;
			yy[r]-=minn;
		}
		cout<<maxn<<"\n";
	}
	return 0;
}

```

---

## 作者：fanypcd (赞：0)

### 题目简述：

有两个数列 A, B 现在对于两个数列的前 $i$ 个数，将它们两两配对，求所有的 $A_i + B_j$ 的最大值中可能的最小值

### 题目思路：

- 贪心
- 将 A, B 排序后最小配最大，易证这样是最优情况
- 注意到 $1\leq A_i, B_i\leq100$，使用桶排序进一步优化时间复杂度
- 但是有一个坑点，桶排序配对后应该将个数减一，而不是跳过执行下一个数
- 还可以优化，减去两个桶大小的最小值，这样就至少可以跳过一边
- 这个有点 2-pointer 的感觉

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105], b[105], tota[105], totb[105];
int main()
{
	int n, x, l, r, ans;
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &x);
		a[x]++;
		scanf("%d", &x);
		b[x]++;
		memcpy(tota, a, sizeof(a));//将a数组复制出来避免修改到原来的
		memcpy(totb, b, sizeof(b));//将b数组复制出来避免修改到原来的
		l = 1;
		r = 100;
		ans = -1;
		while(l <= 100 && r >= 1)
		{
			if(!tota[l])
			{
				l++;
				continue;
			}
			if(!totb[r])
			{
				r--;
				continue;
			}
			ans = max(ans, l + r);
			int minus = min(tota[l], totb[r]); 
			tota[l] -= minus;
			totb[r] -= minus;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```


---


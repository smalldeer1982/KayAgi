# [COCI 2020/2021 #6] Alias

## 题目描述

Novak 和 Rafael 在玩一个猜单词的游戏。

Rafael 脑中有一个包含 $n$ 个单词的数据库。数据库中还有 $m$ 对形如 $x, y, t$ 的链接，表示如果他记起或听到了单词 $x$，他会在 $t$ 毫秒后记起单词 $y$。

游戏将进行 $q$ 轮，每轮游戏相互独立。每一轮游戏开始时，Novak 将说出初始单词 $a$。他想知道，多少毫秒后 Rafael 会记起目标单词 $b$？

## 说明/提示

#### 样例 1 解释

第一轮游戏中，Novak 说出单词 `novak`。$1$ 毫秒后，Rafael 记起单词 `goat`。又过了 $3$ 毫秒，他记起目标单词 `simulator`。

第二轮游戏中，Novak 说出单词 `simulator`，但 Rafael 不会记起任何其他单词。

------------

#### 数据规模与约定

对于 $20$ 分的数据，$n \le 10$。  
对于 $40$ 分的数据，$n \le 100$。  
对于 $100\%$ 的数据，$2 \le n \le 10^3$，$1 \le m \le 10^3$，$1 \le t_i \le 10^9$，$1 \le q \le 10^3$。保证单词的长度不超过 $20$ 且仅含小写字母。

------------

#### 说明

**本题分值按 COCI 原题设置，满分 $70$**。

**题目译自 [COCI2020-2021](https://hsin.hr/coci/archive/2020_2021/) [CONTEST #6](https://hsin.hr/coci/archive/2020_2021/contest6_tasks.pdf) _T2 Alias_**。

## 样例 #1

### 输入

```
3 2
novak goat 1
goat simulator 3
2
novak simulator
simulator goat```

### 输出

```
4
Roger```

## 样例 #2

### 输入

```
3 3
kile legend 4
legend beer 5
beer kile 6
2
kile beer
legend kile```

### 输出

```
9
11```

## 样例 #3

### 输入

```
4 5
rafael me 5
me ow 6
ow ausopenfinal 2012
ausopenfinal me 2
rafael ausopenfinal 2
3
rafael me
me rafael
ow me```

### 输出

```
4
Roger
2014```

# 题解

## 作者：Naro_Ahgnay (赞：6)

# 题目大意

给定 $m$ 对字符串，每对字符串有 $x$ 和 $y$ 以及 $t$，表示如果他记起或听到了单词 $x$，他会在 $t$ 毫秒后记起单词 $y$。可以将其理解为从 $x$ 到 $y$ 有一条边权为 $t$ 的单向边。

然后输入一个 $q$ 表示有 $q$ 轮，每轮有一对字符串 $a$ 和 $b$,求出从初始单词 $a$ 到多少毫秒后会记起目标单词 $b$。可以将其理解为求从 $a$ 到 $b$ 的最短路。

# 思路

通过对题目的分析后我们发现，这道题的本质就是求最短路。不会最短路算法的同学先移步此处。

[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)

[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

然而由于输入的是字符串，为了方便，我们要将字符串转换为带编号的点。直接用 map 将字符串映射成点即可。

定义 map 类型：

```cpp
map<string,int> mp;
```

意思是将一个字符串类型的变量用一个整型变量来表示。

使用 map 映射：

```cpp
string s="ABC"
mp[s]=1
```

意思是将一个字符串类型的变量 $s$ 用 $1$ 来表示。

```cpp
mp.count(s)
```
表示检查字符串类型 $s$ 是否在 map 类型中已经被映射。

通过以上将字符串映射到编号的操作，剩下的就是最短路的板子了。建议使用时间复杂度较低的 Dijkstra 算法，通过堆优化可以实现 $\Theta{(n\log(n+m))}$  的时间复杂度。

# code

```cpp
#include<cstdio>
#include<iostream>
#include<utility>
#include<string>
#include<cstring>
#include<queue>
#include<map>
using namespace std;
struct node{
	int next,to;
	long long dis;
}e[10001];
int n,m,ne,p,q;
int h[10001];
long long dis[1001],t;
bool vis[1001];
string a,b;
map<string,int> ma;
void add(int u,int v,long long w)
{
	e[++ne].next=h[u];
	e[ne].dis=w,e[ne].to=v,h[u]=ne;
}
void dij(int s)
{
	for(int i=1;i<=n;i++) dis[i]=1e14;
	memset(vis,0,sizeof(vis));
	priority_queue<pair<long long,int> > qu;
	qu.push(make_pair(0,s));
	dis[s]=0;
	while(!qu.empty())
	{
		int u,v;
		u=qu.top().second;qu.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=h[u];i;i=e[i].next)
		{
			v=e[i].to;
			if(dis[v]>dis[u]+e[i].dis)
			{
				dis[v]=dis[u]+e[i].dis;
				qu.push(make_pair(-dis[v],v));
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>t;
		if(!ma.count(a)) ma[a]=++p;
		if(!ma.count(b)) ma[b]=++p;
		add(ma[a],ma[b],t);
	}
	scanf("%d",&q);
	while(q--)
	{
		cin>>a>>b;
		int g1,g2;
		g1=ma[a],g2=ma[b];
		dij(g1);
		if(dis[g2]==1e14) printf("Roger\n");
		else printf("%lld\n",dis[g2]);
	}
	return 0;
}
```


---

## 作者：Ginger_he (赞：2)

本文同步更新于[博客园](https://www.cnblogs.com/Gingerhe/p/15977647.html)
# 题解
很明显这是最短路的模板，但与其他题不同的是，这道题中点是以字符串的形式出现的。因此我们就想到了 `map`，可以将字符串映射成一个数。最后注意重复出现的字符串只需映射一次，这道题就解决了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1005;
struct node
{
	int v;
	ll w;
	bool operator < (const node &x) const
	{
		return w>x.w;
	}
};
int n,m,q,cnt;
ll t,dis[maxn],ans;
bool vis[maxn];
string a,b;
map<string,ll> mp;
vector<node> g[maxn];
ll dijkstra(int x,int y)
{
	memset(dis,0x3f3f3f3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	priority_queue<node> q;
	q.push(node{x,dis[x]=0});
	while(!q.empty())
	{
		int tmp=q.top().v;
		q.pop();
		if(vis[tmp])
			continue;
		vis[tmp]=1;
		for(auto i:g[tmp])
		{
			if(dis[tmp]+i.w<dis[i.v])
			{
				dis[i.v]=dis[tmp]+i.w;
				q.push(node{i.v,dis[i.v]});
			}
		}
	}
	return dis[y];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>t;
		mp[a]=mp[a]?mp[a]:++cnt;
		mp[b]=mp[b]?mp[b]:++cnt;
		g[mp[a]].push_back(node{mp[b],t});
	}
	scanf("%d",&q);
	while(q--)
	{
		cin>>a>>b;
		ans=dijkstra(mp[a],mp[b]);
		if(ans==dis[0]) printf("Roger\n");
		else printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Hasinon (赞：1)

## 题目大意
$n$ 个点。  
$m$ 条带权单向边。  
$q$ 个求从某点到另一点所经的最小权值的询问。  
如果压根走不到就输出 "Roger"。
## 解题思路
带权图求经过最小权值的路径，那不就是最短路嘛。  
Dijkstra 和 SPFA 都可，但楼上的题解都写的  Dijkstra ，我就附一个优先队列优化的 SPFA 代码。
## CODE
```cpp
#include<bits/stdc++.h>
#define ll long long
#define G getchar()
using namespace std;
struct node{
	ll to,t;
};
bool operator <(const node &a,const node &b){
	return a.t>b.t;
}
map<string,ll> mat;
vector<node>side[1005];
ll ans[1005][1005],d[1005];
bool v[1005],mark[1005];
priority_queue<node> q; 
int main()
{
	ll n,m,t,ord=0,qq;
	scanf("%lld%lld",&n,&m);
	for(register int i=1; i<=m; i++)
	{
		string s1,s2;
		cin>>s1>>s2;
		scanf("%lld",&t);
		if(mat[s1]==0) mat[s1]=++ord;
		if(mat[s2]==0) mat[s2]=++ord; 
		side[mat[s1]].push_back((node){mat[s2],t});
	}
	scanf("%lld",&qq);
	for(register int i=1; i<=qq; i++)
	{
		string s1,s2;
		cin>>s1>>s2;
		ll st=mat[s1],en=mat[s2];
		if(!mark[st])
		{
			mark[st]=1;
			for(register int j=1; j<=n; j++)
				d[j]=1e15;
			memset(v,0,sizeof(v));
			q.push((node){st,0});
			d[st]=0,v[st]=1;
			while(q.size())
			{
				ll x=q.top().to; q.pop();
				v[x]=0;
				for(register int ii=0; ii<side[x].size(); ii++)
				{
					if(d[x]+side[x][ii].t<d[side[x][ii].to])
					{
						d[side[x][ii].to]=d[x]+side[x][ii].t;
						if(!v[side[x][ii].to])
						{
							q.push((node){side[x][ii].to,d[side[x][ii].to]});
							v[side[x][ii].to]=1;
						}
					}	
				} 
			}
			for(register int j=1; j<=n; j++)
			{
				ans[st][j]=d[j];
			}
		}
		if(ans[st][en]==1e15) printf("Roger\n");
		else printf("%lld\n",ans[st][en]);
	}
	return 0;
}
```



---

## 作者：DegChuZm (赞：0)

# 一道练习最短路和map的好题
但我 CE 了半天。

## 思路
读完题目，一眼就能看出来这是一道十分基础的最短路。

可能有些人就要问了

“但是这题用的是字符串来存图的啊，存图存不了啊！”

这时候就要提出 STL 中的map了。

## map是什么
map翻译为映射，我们常用的数组也是一种映射。

譬如 `int a[10]` 就是定义了一个从 int 到 int 的映射。

不过数组在处理从 $string$ 到 $int$ 的映射就不太方便了。

这时候就要请出我们的 map 了。

map的定义是：
```cpp
map<typename1,typename2> name;

```
了解了 map，直接套 dij 模板就能过了。
附上代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int head[1000001],cnt,dis[1000001],n,o,v,w,m,z,tot,k;
string x;
string y;
struct node{
	int nex,to,val;
}a[1000001];
map<string,int> ma;
struct dcz{
	int u,d;
	bool operator<(const dcz& jntm)const {
		return d>jntm.d;
	}
};
void add(int x,int y,int z){
	a[++cnt].val=z;
	a[cnt].to=y;
	a[cnt].nex=head[x];
	head[x]=cnt;
}
void dij(int o){
	for(int i=1;i<=n;i++){
		dis[i]=INT_MAX;
	}
	dis[o]=0;
	priority_queue<dcz> q;
	q.push((dcz){o,0});
	while(!q.empty()){
		dcz xx=q.top();
		q.pop();
		int u=xx.u;
		int d=xx.d;
		if(d!=dis[u])
			continue;
		for(int i=head[u];i;i=a[i].nex){
			v=a[i].to;
			w=a[i].val;
			if(dis[u]+w<dis[v]){
				dis[v]=dis[u]+w;
				q.push((dcz){v,dis[v]});
			}
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y>>z;
		if(!ma[x])
			ma[x]=++tot;
		if(!ma[y])
			ma[y]=++tot;
		add(ma[x],ma[y],z);
	}
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>x>>y;
		dij(ma[x]);
		if(dis[ma[y]]!=INT_MAX)
			cout<<dis[ma[y]]<<endl;
		else
			cout<<"Roger"<<endl;
	}
	return 0;
}
```



---

## 作者：封禁用户 (赞：0)

### 毫无疑问的最短路问题
这里写一写关于 Dijkstra 的：[不会的请看此题](https://www.luogu.com.cn/problem/P4779)

~~就是把节点名换的高级了一点~~   
这道题着实与上面的题没什么区别，我们主要说说不同的。    
"如果他记起或听到了单词 $x$ ，他会在 $t$ 毫秒后记起单词 $y$ "我们可以转化成：从 $x$ 连接一条权值为  $t$ 的**单向边**(因为你不能通过 $y$ 记起 $x$ )到 $y$ 。      
那么想要从一个单词到另一个单词，也就是跑"一个单词"到"另一个单词"的最短路。

但是把字符串当作节点是很麻烦的，所以:将字符串转换为标号。     
这个挺简单，我们用一个 map 来实现。
```cpp
map<string,int> mp;//将前面一个string类型映射到后面的int类型

for (int i=1,z;i<=m;i++){
	string x,y; cin>>x>>y;
	scanf("%lld",&z);
   //若mp[x]未被标记，即mp[x]==0
	if (!mp[x]) mp[x]=++pqpq;//我们给没有标记的单词设定一个标号
	if (!mp[y]) mp[y]=++pqpq;//pqpq为标号
	append(mp[x],mp[y],z);//建图不多说
}
```        

除此之外，放一下代码：
### CODE
```cpp
#include<bits/stdc++.h>
#define int long long
//不开long long 见______
using namespace std;
struct line{
	int to,val,next;
} a[2500005]; int s,t; map<string,int> mp;
int n,m,head[120005],cnt=0,vis[120005],dis[120005],q,pqpq=0;
void append(int x,int y,int z){
	a[++cnt].to=y;
	a[cnt].val=z;
	a[cnt].next=head[x];
	head[x]=cnt;
}
void D(){//队优化，这个模板希望大家熟悉
	for (int i=1;i<=n;i++)
		dis[i]=1e14;//多组数据记得清空
	memset(vis,0,sizeof(vis));
    dis[s]=0;
    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > points;
    points.push(make_pair(0,s));
    while (!points.empty()){
    	int u=points.top().second;
    	points.pop();
    	while (!vis[u]){
    		vis[u]=1;
    		for (int i=head[u];i;i=a[i].next)
    			if (!vis[a[i].to]&&dis[a[i].to]>dis[u]+a[i].val){
    				dis[a[i].to]=dis[u]+a[i].val;
    				points.push(make_pair(dis[a[i].to],a[i].to));
				}
		}
	}
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for (int i=1,z;i<=m;i++){
		string x,y; cin>>x>>y;
		scanf("%lld",&z);
		if (!mp[x]) mp[x]=++pqpq;
		if (!mp[y]) mp[y]=++pqpq;
		append(mp[x],mp[y],z);
	} scanf("%lld",&q);
	while (q--){
		string x,y; cin>>x>>y;
		s=mp[x],t=mp[y]; D();
		if (dis[t]==1e14)
			puts("Roger");
		else printf("%lld\n",dis[t]);
	}
	return 0;
}
```

---

## 作者：rai1gun (赞：0)

### 1.简化题意

有 $n$ 个字符串，代表 $n$ 个点。

有 $m$ 条边，每条边连接 $2$ 个字符串，边权为 $t$。（边是单项边）

有 $Q$ 次询问，每次给定 $2$ 个字符串，要求求他们之间的最短路径。

### 2.解题思路

首先，我们不难发现，这就是一道最短路的模板题。

我们可以用 map 来存储字符串，并将他们转换为数字。

观察到 $n,m$ 较小，所以无需求全员最短路。

又因为 $t_i>0$，所以可以使用 dijkstra 。

### 3.代码

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
//快读略
using namespace std;
const int N = 1e3+5;
struct Node{
	int to,nxt,val;
}; 
int hd[N],vis[N],s,cnt,n,m,T,Cnt,dis[N];
struct Node2{
    int dis,pos;
    bool operator < (const Node2 &x) const {
        return x.dis<dis;
    }
};
map<string,int> mp;
class WERWER{
public:
	Node e[N];
	inline void addedge(int u,int v,int val){
		e[++cnt].to=v;
		e[cnt].val=val;
		e[cnt].nxt=hd[u];
		hd[u]=cnt;
	}
	inline void dijkstra(int s){
	    for(int i=1;i<=n;i++) dis[i]=9e18;
		memset(vis,0,sizeof(vis));
		priority_queue<Node2> q;
		q.push((Node2){0,s});
		dis[s]=0;
	    
    	while(!q.empty()){
        int tmp=q.top().pos;
        q.pop();
        if(vis[tmp]) continue;
        vis[tmp]=1;
        for(int i=hd[tmp];i;i=e[i].nxt){
            int y=e[i].to;
            if(dis[y]>dis[tmp]+e[i].val){
                dis[y]=dis[tmp]+e[i].val;
                if(!vis[y]){
                    q.push((Node2){dis[y],y});
                }
            }
        }
    }
}
}G;
signed main(){
	read(n,m);
	rep(i,1,m){
		string a,b;
		std::cin>>a>>b;
		int val;
		read(val);
		if(!mp[a]) mp[a]=++Cnt;
		if(!mp[b]) mp[b]=++Cnt;
		G.addedge(mp[a],mp[b],val);
	}
	read(T);
	while(T--){
		string a,b;
		cin>>a>>b;
		G.dijkstra(mp[a]);
		if(dis[mp[b]]==9e18) puts("Roger");
		else print(dis[mp[b]]),putchar('\n');
	}
	return 0;
}
```

---

## 作者：DF_Factory (赞：0)

[传送门](https://www.luogu.com.cn/problem/P7551)

看到了单词之间有若干条边，又询问最短时间，自然想到了最短路。我还手动判了重边，不过貌似不用。至于字符串，我直接用 map 把它们弄成了数字。连上边之后，就可以快乐地跑 Dijkskra 了。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ing long long
#define N 1010
#define pr pair<ing,ing>
#define inf 2147483645
using namespace std;
ing n,m,b[N],Q;
struct node{
	ing v,w;
};
vector<node> a[N];
priority_queue<pr,vector<pr>,greater<pr> > pq;
ing dis[N],pre[N],s,t;
bool vis[N];
string sq[N],tq[N];
map<string,ing> mp;
void dijkstra(){
	memset(vis,0,sizeof(vis));
	for(int i=0;i<N;i++) dis[i]=inf;
	dis[s]=0;
	pq.push(pr(dis[s],s));
	while(!pq.empty()){
		ing u=pq.top().second;
		pq.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(ing j=0;j<a[u].size();j++){
			ing v=a[u][j].v,w=a[u][j].w;
			if(!vis[v]&&dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				pre[v]=u;
				pq.push(pr(dis[v],v));
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(ing i=1;i<=m;i++){
		cin >> sq[i] >> tq[i] >> b[i];
		for(ing j=1;j<i;j++){
			if(sq[j]==sq[i]&&tq[j]==tq[i]){
				if(b[i]<b[j]) b[j]=b[i];
				sq[i]="-1",tq[i]="-1",b[i]=inf;
			}
		}
	}
	for(ing i=1;i<=m;i++){
		if(sq[i]=="-1") continue;
		if(!mp.count(sq[i])) mp[sq[i]]=n--;
		if(!mp.count(tq[i])) mp[tq[i]]=n--;
		a[mp[sq[i]]].push_back((node){mp[tq[i]],b[i]});
	}
	scanf("%d",&Q);
	while(Q--){
		string qq,ww;
		cin >> qq >> ww;
		s=mp[qq],t=mp[ww];
		dijkstra();
		if(dis[t]==inf) cout << "Roger" << endl;
		else cout << dis[t] << endl;
	}
	return 0;
}
```


---

## 作者：Mu_tr (赞：0)

# 题目大意
- 一个数据库里有 $n$ 个单词，Rafael 在想起了 $x$ 这个单词 $t$ 秒后会想起 $y$ 这个单词。

- 现在给出 $q$ 个询问，每个询问给出两个单词 $a$ 和 $b$ ，求最少要花多少时间 Rafael 才能从单词 $a$ 想到单词 $b$。


------------
# 算法思考流程 
- 首先思考，在想起了单词 $x$ $t$ 秒后会想起单词 $y$，数据库里有 $n$ 个单词。容易想到用邻接表（链式前向星或者动态数组）首先来建一个图。然后将题意抽象过来，就是在一个图上，寻找点 $x$ 到点 $y$ 的路径中边权值和最小的一条路径，那么想到对于每一个询问对 $x$ 进行 BFS。

- 很明显，朴素的在线 BFS 时间复杂度为 $O(n^2q)$，离线的查表 BFS 时间复杂度也达到了惊人的 $O(n^3)$，那么考虑有没有优化方法。众所周知，对于一个点来讲，在连接它的所有边中，权值最小的那条边所连接的点，到这个点距离的最小值一定是这条边对应的权值。

- 那么一个贪心的优化思路就出来了：首先将每个点连接的边按照权值大小排序，在 BFS 时判断当前的值与之前找到的最小值谁更优，如果更优就更新，否则直接出队跳过。 


------------
# 你们最喜欢的 AC 代码：
- 注意代码细节。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,t3,tot=0,q,c[1005][1005],q1,q2,jl1,jl2;//c数组用来查表输出
string t1,t2;
struct lh{
	long long qz,d;//权值，点
};
struct node{
	long long dx,qz;//对象，权值
};
vector<node> a[1005];
map<string,long long> mp;
bool cmp(node x,node y){
	return x.qz<y.qz;
}//将权值小的放前面
void bfs(long long k){
	queue<lh> q;//使用队列进行BFS
	q.push((lh){0,k});
	while(!q.empty()){
		long long w1=q.front().d,w2=q.front().qz;q.pop();
		if(c[k][w1]>w2) c[k][w1]=w2;//不断更新c数组的值，不断找到最小值
		else continue;//如果不能更优，直接出队
		for(long long i=0;i<a[w1].size();i++) if(c[k][a[w1][i].dx]>(w2+a[w1][i].qz)) q.push((lh){w2+a[w1][i].qz,a[w1][i].dx});//权值比当前更优才能进队
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++) for(long long j=1;j<=n;j++) c[i][j]=1e17;
	for(long long i=1;i<=m;i++){
		cin>>t1>>t2;scanf("%lld",&t3);
		if(!mp.count(t1)) mp[t1]=++tot;
		if(!mp.count(t2)) mp[t2]=++tot;
		jl1=mp[t1],jl2=mp[t2];
		a[jl1].push_back((node){jl2,t3});
	}
	for(long long i=1;i<=n;i++)  sort(a[i].begin(),a[i].end(),cmp);//对遍历顺序进行初始化排序，尽量用最少的次数查完
	scanf("%lld",&q);
	for(long long i=1;i<=n;i++) bfs(i); //将每一个点跑一遍BFS
	for(long long i=1;i<=q;i++){
		cin>>t1>>t2;
		long long jl1=mp[t1],jl2=mp[t2];
		if(c[jl1][jl2]!=1e17) printf("%lld\n",c[jl1][jl2]);
		else printf("Roger\n");
	}
	return 0;
}
```


---

## 作者：S_GND (赞：0)

# 题意简述：


- 从一个单词想起另一个单词可以看作从一个点走向另一个点 。

- 可以将想起的时间看作权值 。

- 从一个点走到另一个点的最小权值 。

- 因为两个单词不能互相想起,所以是单向边 。
 
- 单向边很明显是一个有向图 。

- 有向图走不到输出 "Roger" 。


# 解题思路：
1.  由最小权值我们可以很自然的想到最短路。

2.  由于本题没有负权值，以我们可以想到使用 **Dijkstra** 算法（一种基于贪心的算法。

3.  如果不会 **Dijkstra** 算法请往下拉或左转                [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)。

4. 将从一个单词想起另一个单词的最短时间时间看作从一个点到另一个的最短。

5. 做完最短路后如果目标点仍是初值的话则代表走不到。

6. 时间大约为  $ O(q \cdot n  \log n) $。

# 注意事项：
- 因为每一条边的权值最大为 **10 的 9 次方 **，所以建议使用   ```  long long   ```   进行存储。

- 不能仅以一个原点跑最短路因为这样可能无法准确的判断一个点可否到达另一个点。

- 建议每次找题目给定的原点进行最短路。

- 最短路建议使用 **堆优化** 的，不然会超时 。

- 如果不会手打堆，可以使用 **优先队列** 。

# 代码奉上

 ```cpp
#include <bits/stdc++.h>
#define int long long
//本蒟蒻的码风不太好看QWQ 
//蒟蒻的第一篇题解，审核大大求过QWQ
//如果空格又少了审核大大请说一下是哪里（实在找不到了。。QWQ）
using namespace std ;
const int N = 1005 ;
int ans[N] ;
int qu,n,m,bh,zhi ;
string a,b ;
struct ww{
	int id,w ;
	bool operator < (const ww &A) const {return w > A.w;}  //优先队列按权值由小到大排序 
}o; 
vector<ww>bian[N] ;
map<string ,int >p ;
priority_queue<ww>q ;
inline int read(){
	register int x = 0 , f = 1 ;
	register char ch = getchar() ;
	while( ch < '0' || ch > '9' ){
		if( ch == '-' )f = -1 ;
		ch =getchar() ;
	}
	while( ch >= '0' && ch <= '9' )
	x = ( x << 1 ) + ( x << 3 ) + ( ch ^ 48 ) ,
	ch =getchar() ;
	return x * f;
}//快读 
inline void write(int x){
	if( x < 0 )putchar('-'),x = -x ;
	if( x > 9 )write(x/10) ;
	putchar( x%10+'0' ) ;
}//快写 
void find(){
	while(!q.empty()){
		ww now = q.top() ;//取队首
		if(ans[now.id] != now.w){
			q.pop() ;
			continue ;//走过的排除 
		}
		for(int i = 0 ; i < bian[now.id].size() ; i++ )
			if(ans[now.id]+bian[now.id][i].w<ans[bian[now.id][i].id])
			ans[bian[now.id][i].id] = ans[now.id]+bian[now.id][i].w ,
			o.id = bian[now.id][i].id , o.w = ans[bian[now.id][i].id],
			q.push(o) ;//添加新点 
		q.pop() ;//弹出队首 
	}
}
main(){
//	freopen("alias.in","r",stdin) ;
//	freopen("alias.out","w",stdout) ;
	n = read() , m = read() ;
	for(int i = 1 ; i <= m ; ++i ){
		cin>>a>>b ,zhi = read() ;
    	if(p[a]==0)p[a] = ++bh ;
		if(p[b]==0)p[b] = ++bh ;//为新的字符串上编号 
		o.id =p[b] , o.w = zhi ;
		 bian[p[a]].push_back(o) ;//存图 
	}
	qu = read() ;
	for(int i = 1 ; i <= qu ; i++ ){
		memset(ans,0x3f,sizeof(ans)) ;//将初始答案赋值为无限大 
		cin>>a>>b ;
		o.id = p[a],o.w = 0 ;//队列的原点 
		q.push(o) ;
		ans[p[a]] = 0 ;
		find() ;
		if(ans[p[b]]>=4557430888798830399)printf("Roger\n") ;//初值为0x3f 
		else write(ans[p[b]]),printf("\n") ;
	} 
	return 0 ;
} 
```


---

## 作者：Perta (赞：0)

题目：[P7551 [COCI2020-2021#6] Alias](https://www.luogu.com.cn/problem/P7551)
# **题面**
Novak 和 Rafael 在玩一个简化版本的 Alias 游戏。Novak 需要 Rafael 在自己不说的情况下去猜测一个
词语。Rafael 大脑里对于词语的认知是一张 $n$ 个点 $m$ 条边的图。每一个点代表一个词语，每一条代
表两个词语之间的联系。边上会有一个权值 $t$ ，假设这是一条连接点 $x$ , $y$ 的边，这就意味着 Rafael 在
想起了 $x$ 之后，$t$ 个单位时间之后就会想起词语 $y$（注意，这是一条**单向边**）。
游戏会进行 $q$ 轮，在每一轮中，Novak 会说出一个词语 $a$ ，他想知道的是，Rafael 会在多久之后**第一次**想到词语 $b$ 。
# **思路**
简单来讲就是要求每个询问中字符串 $x$ 到字符串 $y$ 的最短路。
此处用的是 **Dijkstra** 算法（堆优化版），其时间复杂度为 $O( {q}\cdot{n}\log{n})$ 。

算法路径：

[P3371【模板】单源最短路径(弱化版)](https://www.luogu.com.cn/problem/P3371)

[P4779【模板】单源最短路径(标准版)](https://www.luogu.com.cn/problem/P4779)
### code:
```
//由于边权数据较大，注意用long long类型存储
#include<bits/stdc++.h>
using namespace std;
const int N=1010,M=1010;
struct ok{
	int x;
	long long y;
	bool operator <(const ok &A) const{return y>A.y;}
};
int n,m,t,q;
int first[N],to[M],nxt[M],cnt;
long long dis[N],lth[M],p;
bool biao[N];
map<string,int>a;
string k,l;
inline void inc(int x,int y,long long l) {nxt[++cnt]=first[x],to[cnt]=y,first[x]=cnt,lth[cnt]=l;}
//建模方式可以用邻接表,也可以用vector,看个人喜好
int main()
{
	scanf("%d%d",&n,&m);
	while(m--)
	{
		cin>>k>>l;
		scanf("%lld",&p);
		int &x=a[k],&y=a[l];//用map数组存储字符串编号，方便作为数组下标
		if(!x) x=++t;
		if(!y) y=++t;
		inc(x,y,p);
	}
	scanf("%d",&q);
	while(q--)
	{
		cin>>k>>l;
		int x1=a[k],y1=a[l];
		priority_queue<ok>dijkstra;
		memset(dis,0x3f3f3f3f3f3f3f3f,sizeof(dis));
		dis[x1]=0,dijkstra.push((ok){x1,0});
		while(!dijkstra.empty())
		{
			int x=dijkstra.top().x;
			long long l=dijkstra.top().y;
			dijkstra.pop();
			if(l!=dis[x]) continue;
			for(int i=first[x],v;i;i=nxt[i]) if(dis[v=to[i]]>lth[i]+dis[x])
			{
				dis[v]=lth[i]+dis[x];
				dijkstra.push((ok){v,dis[v]});
			}
		}
		if(dis[y1]!=0x3f3f3f3f3f3f3f3f) printf("%lld\n",dis[y1]);
		else puts("Roger");//与源点的距离没有变化的话即无法到达
	}
	return 0;
}
```
~~画功不好，见谅QWQ~~

---


# [AHOI2021初中组] 坑

## 题目背景

AHOI2021 初中组 T2

**你可以选择跳过背景部分。**

买东西的路上小雪吸了好几口雾霾，最后打了个喷嚏。恶劣的天气、压抑的氛围让小雪心情越来越差，之后倒起了苦水：

“唉！今天又被一个不靠谱的同学坑了，浪费了我好多时间。”

“期中考试还早，有什么好焦虑的呢？别卷了，正好来看看最近在蛐蛐国流行的一个游戏吧。”

小雪看了游戏来了精神：看起来好像很解压。

## 题目描述

游戏在一个左右无限延伸的数轴上进行，上面有 $n$ 只跳蚤和 $m$ 个坑，它们都可以被抽象成数轴上的一个点。

玩家每回合需要选择让所有跳蚤一起向左/向右跳一个单位长度。如果一个代表跳蚤的点与一个代表坑的点重合了，跳蚤就会掉进坑中，发出惨叫后死去。

郁闷的小雪想用最快的时间杀死所有跳蚤，请你帮小雪计算一下这个最少的回合数。

## 说明/提示

【样例 1 解释】

第一回合让所有跳蚤向右跳一步，第 2 个跳蚤进第一个坑，剩下两个跳蚤分别位于 4, 3。

下面四回合让所有跳蚤向左跳，两个跳蚤都进入第一个坑，游戏结束。


【数据范围与提示】

**提示：本题输入规模较大，请避免使用过慢的输入方式。**

- 对于 $20\%$ 的数据，保证 $1 \le n \le 20$，$1 \le m \le 300$；
- 对于另外 $20\%$ 的数据，保证 $1 \le n,m \le 300$；
- 对于另外 $20\%$ 的数据，保证 $1 \le x_i,y_i \le 2000$；
- 对于另外 $10\%$ 的数据，保证 $1 \le n,m \le 2000$；
- 对于另外 $10\%$ 的数据，保证 $m=2$；
- 对于 $100\%$ 的数据，保证 $1 \le n,m \le 2 \times 10^5$，$-10^9 \le x_i,y_i \le 10^9$。

## 样例 #1

### 输入

```
3 2
3 -1 2
0 10```

### 输出

```
5```

## 样例 #2

### 输入

```
见附加文件的 hole2.in。 ```

### 输出

```
见附加文件的 hole2.ans。```

# 题解

## 作者：Wsy_flying_forever (赞：41)

看到这题的题解不是很多，我就来补一发。  
### 题意简述
$n$ 个点移到 $n$ 个坑，一次全体移动一格，移到坑点就消失，求最小移动步数。
### 思路  
初始坐标是无序的，我们先来将点与坑的坐标排个序再说（QAQ）  
然后我们考虑这个点的移动情况。 
对于每个点来说向左向右不断交替运动是没有任何意义的，我们应该让它往左或往右直接进坑，亦或是让它先向左或向右一小段距离满足其他点的需求，再一次性向右或向左进坑（如下图）  
[![7c0WN9.png](https://s4.ax1x.com/2022/01/20/7c0WN9.png)](https://imgtu.com/i/7c0WN9)
于是思路就产生了：  
我们先用二分（尺取法也行）把每个节点和离他最近的左部坑之间的距离算出来，若左部无坑，则标为 $\infty$,右部点同理。这里要注意一点，我们需要把左部点距离与其编号捆绑在一起，便于求排序后其对应的右部点距离。将左部点距离进行排序后，依次枚举左部点，此时取该点为左移进坑点，由图得到 $d_1=2r_1+l_1$, 以该点为右部进坑点，由图得到$d_2=2l_2+r_2$,$ans$ 即可更新为 $\max(ans,d_1,d_2)$,输出答案即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
typedef long long ll;
struct Node{
	ll l;
	int id;
	bool operator <(const Node &T)const{
		return l<=T.l;
	}
} t[maxn];
ll n,m,rmax,ans=1e16;
ll a[maxn],b[maxn],r[maxn];
inline ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while (!isdigit(ch)){
	    if (ch=='-') f=-1;
	    ch=getchar();
	}
	while (isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++) a[i]=read();
	b[0]=-1e16;
	b[m+1]=1e16;
	for (int i=1;i<=m;i++) b[i]=read();
	sort(b+1,b+m+1);
	for (int i=1;i<=n;i++){
		t[i].l=a[i]-b[upper_bound(b+1,b+m+1,a[i])-b-1];
		t[i].id=i;
		r[i]=b[upper_bound(b+1,b+m+1,a[i])-b]-a[i];
    }
    sort(t+1,t+n+1);
    for (int i=n;i>=0;i--){
    	ans=min(ans,min(t[i].l*2+rmax,rmax*2+t[i].l));
    	rmax=max(r[t[i].id],rmax);
	}
	printf("%lld\n",ans);
	return 0;
}

```
写题解不易，点个赞再走吧！$Thank$&nbsp;$you$

---

## 作者：meyi (赞：16)

注：本题解搬运自出题人在 GitHub 上公布的[官方题解](https://github.com/rushcheyo/AHOI-2021-junior)，数据及标程均可从此链接中下载。

设 $l_i,r_i$ 是第 $i$ 只跳蚤到左边/右边最近坑的距离，没坑则为 $+\infty$。

假设我们的操作向左最多移动 $L$ 步，向右最多移动 $R$ 步，那么该操作方案能杀死所有跳蚤的充要条件是对所有 $i$，要么 $L \ge l_i$ 或 $R \ge r_i$。同时，用 $L$ 个左和 $L+R$ 个右或 $R$ 个右和 $L+R$ 个左可以构造出一种操作方案。所以我们只需要在 $l_i$ 和 $0$ 中枚举 $L$，$r_i$ 和 $0$ 中枚举 $R$，判断合法并用 $\min(L,R)+L+R$ 更新答案即可。

进一步的，我们将跳蚤按 $l_i$ 排序，枚举 $L=l_j$，那么 $R$ 显然是 $r_{j+1},r_{j+2},\ldots,r_n$ 中的最大值，预处理即可。复杂度 $O(n \log n)$。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;

const int N = 200005;
const ll INF = 1e10 + 1;
int n, m, x[N], y[N], id[N];
ll l[N], r[N];

struct cmp {
  bool operator()(int x, int y) {
    return l[x] < l[y];
  }
};

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; ++i) {
    scanf("%d", x + i);
    id[i] = i;
  }
  for (int i = 1; i <= m; ++i) {
    scanf("%d", y + i);
  }
  sort(x + 1, x + 1 + n);
  sort(y + 1, y + 1 + m);
  for (int i = 1, j = 0; i <= n; ++i) {
    while (j != m && y[j + 1] < x[i])
      ++j;
    if (j) l[i] = x[i] - y[j];
    else l[i] = INF;
  }
  for (int i = n, j = m + 1; i >= 1; --i) {
    while (j != 1 && y[j - 1] > x[i])
      --j;
    if (j <= m) r[i] = y[j] - x[i];
    else r[i] = INF;
  }
  sort(id + 1, id + 1 + n, cmp());
  ll ans = INF, suf_max = 0;
  for (int i = n; i >= 0; --i) {
    ans = min(ans, min(l[id[i]] + 2 * suf_max, 2 * l[id[i]] + suf_max));
    suf_max = max(suf_max, r[id[i]]);
  }
  printf("%lld\n", ans);
  return 0;
}
```


---

## 作者：Sunset_afterglow (赞：9)

# 题意
我们可以把跳蚤和坑抽象成点，对于每一次操作就是让代表的跳蚤的点都往右或左跳一格，跳到代表坑的的点则消失，求至少需要多少次操作才能让所有代表跳蚤的点全部消失。
## 思路
我们可以证明所有跳蚤一定是**先往左跳再往右跳**或者**先往右跳再往左跳**更最优，出现左右横跳的情况**一定不是最优**。因为左右横跳会出现**一个跳蚤一直重复在某一段路中走**，所以左右横跳**一定不是最优**。
## 处理
首先给出坐标无序，先排序。由于我们不知道每个跳蚤左右离他最近的两个坑的位置，所以需要二分找出这两个坑，并用结构体记录他到这两个坑的距离。 

对结构体进行排序，排序方式是将这个点到左边离他最近的点的距离按照从小到大进行排序。

最后对 $answer$ 进行**倒序统计**，要判断是先往左再往右更优还是先往右再往左更优，而且要考虑跳过去然后不在跳回来的情况。
## 细节见代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define INT_MAX 1e18
using namespace std;
const int N = 4e5+5;
struct stu{
	int Left,Right;
}a[N];
int x[N],y[N],pos,n,m,ans=INT_MAX,maxx;
bool f[N];
bool cmp(stu a,stu b){ //注意一定是到左边的距离优先
	if(a.Left!=b.Left){
		return a.Left<b.Left;
	}
	else return a.Right<b.Right;
}
int find(int x){ //找左边离他最近的点
	if(x<y[1])return 0;
	if(x>y[m])return m;
	int l=1,r=m,xpos=0;
	while(l<=r){
		int mid=(l+r)/2;
		if(y[mid]>x){
			r=mid-1;
		}
		else l=mid+1,xpos=mid;
	}
	return xpos;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>x[i];
	for(int i=1;i<=m;++i)cin>>y[i];
	sort(x+1,x+n+1);
	sort(y+1,y+m+1);
	y[0]=-INT_MAX;
	y[m+1]=INT_MAX;
	for(int i=1;i<=n;++i){
		pos=find(x[i]);
		a[i]=stu{abs(x[i]-y[pos]),abs(y[pos+1]-x[i])}; //到左右两边的距离
	}
	sort(a+1,a+n+1,cmp);
	for(int i=n;i>=0;--i){ //ans统计
  //i=0是一个细节因为要考虑跳过去不跳回来的情况
		ans=min({ans,a[i].Left*2+maxx,maxx*2+a[i].Left});
    	maxx=max(a[i].Right,maxx);
	}
	cout<<ans;
	return 0;
}
```
###### 完结撒花(⌒ω⌒)

---

## 作者：zhjx2023 (赞：5)

### 思路
题意：在一个数轴上进行的游戏中，选择使所有跳蚤一起向左或向右跳一个单位长度，以达到杀死所有跳蚤的最少回合数。每只跳蚤和每个坑都可以看作是数轴上的一个点。

1. 读取输入的 $n$ 和 $m$，以及每只跳蚤和每个坑的初始位置。

2. 对跳蚤和坑的位置进行排序，分别按照左边界和右边界进行排序。

3. 计算每只跳蚤距离最近的坑的左右边界距离，并存储在数组中。

4. 分别按左边界和右边界进行排序，然后使用动态规划求解最少回合数。

5. 从右向左遍历，更新最小回合数和最远距离。

6. 对左边界和右边界各进行一次动态规划，分别计算左右跳的最少回合数。

7. 输出最终的最小回合数。

代码
```cpp
#include <bits/stdc++.h>
#define ll l0ng l0ng
//#define cin std:cin
//#define cout std:cout
using namespace std;
const int N = 2e5 + 10, MOD = 1e9 + 7;
ll n, m, a[N], b[N], c[N], cnt1 = 114514191981, cnt2 = 114514191981, cnt3, cnt4, l, r;
struct tiaozao {
	ll zuo, you;
} dp[N];
bool cmp1(tiaozao a, tiaozao b) {
	return a.zuo < b.zuo;
}
bool cmp2(tiaozao a, tiaozao b) {
	return a.you < b.you;
}
int main() {
	ios::sync_with_stdio(o);
	cin.tie(o);
	cout.tie(o);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i];
	sort(a + 1, a + 1 + n);
	b[0] = -1e10 + 2;
	b[m + 1] = 1e10 + 2;
	sort(b + 1, b + 1 + m);
	for (int i = 1; i <= n; i++)
		l = upper_bound(b + 1, b + 1 + m, a[i]) - b - 1, r = upper_bound(b + 1, b + 1 + m, a[i]) - b, dp[i].zuo = a[i] - b[l], dp[i].you = b[r] - a[i];
	sort(dp + 1, dp + 1 + n, cmp1);//以下是DP
	for (int i = n; i >= 0; i--)
		cnt1 = (cnt1 < dp[i].zuo * 2 + cnt3 ? cnt1 : dp[i].zuo * 2 + cnt3), cnt3 = (dp[i].you > cnt3 ? dp[i].you : cnt3);
	sort(dp + 1, dp + 1 + n, cmp2);
	for (int i = n; i >= 0; i--)
		cnt2 = (cnt2 < dp[i].you * 2 + cnt4 ? cnt2 : dp[i].you * 2 + cnt4),
		cnt4 = (dp[i].zuo > cnt4 ? dp[i].zuo : cnt4);
	cout << (cnt1 < cnt2 ? cnt1 : cnt2);
	return 0;
}
```

---

## 作者：chengyixuan123 (赞：4)

# **P7622题解**


~~这是本蒟蒻第一发题解，请管理员大大通过~~


## 思路
显然对于每只跳蚤要么是掉进离其最近左边的坑，要么是掉进离其最近右边的坑！可以最终移动方式只有两种：

 1.  _先向左移动 $X$ 步，再向右移动 $Y$ 步，总共移动 $X+X+Y$ 步；_ 

 1.  _先向右移动 $Y$ 步，再向左移动 $X$ 步，总共移动 $X+Y+Y$ 步。_ 

以情况 $(1)$ 来说明，另一种情况类似，假定向左移动 $X$ ，则对离左边坑距离 $\le X$ 的都掉进坑里了，对于没有掉进坑里的，剩下的则必须掉进右边坑里，那么只需要找到剩下的离右边坑最远的距离是多少即可，即答案为 

$X+X+\max\{ \texttt{剩下距离最远的距离} \}$

显然需要计算出距离左右两边坑最近的距离，这样就可以考虑先分别对 $A$,$B$ 数组从小到大排序，然后分别计算出离左右最近坑的距离，如果左或右边没有坑，则距离就是无穷大。然后再把按距左坑的距离从小到大排序，再用一个 $d$ 数组来存储从当前到最后所有位置离最近右坑最远距离，即 

 $d_i=\max\{r_{c_i},r_{c_{i+1}},\cdots,r_{c_n}\}$ 

显然这个可以按倒序预处理出来。最后只需要按顺序依次处理每个位置掉进最近左边坑的的距离，即有 

 $ans=\min\{l_{c_i}+d_{i+1}\}$ 

同样的方式再处理一遍情况 $(2)$ 即可得到结果。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+10;
struct Node{
	ll left,right;
}d[N];
ll n,m,a[N],b[N],c[N];
bool cmp(Node a,Node b){
	return a.left<b.left;
}
bool cmp2(Node a,Node b){
	return a.right<b.right;
}
int main(){
	//freopen("hole2.in","r",stdin);
	//freopen("hole2.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>b[i];
	sort(a+1,a+1+n);
	b[0]=-1e10+2;
	b[m+1]=1e10+2;
	sort(b+1,b+1+m);
	for(int i=1;i<=n;i++){
		ll l=upper_bound(b+1,b+1+m,a[i])-b-1;
		ll r=upper_bound(b+1,b+1+m,a[i])-b;
		d[i].left=a[i]-b[l];
		d[i].right=b[r]-a[i];
	}
	sort(d+1,d+1+n,cmp);
	ll ans=1e10+2,cnt=0;
	for(int i=n;i>=0;i--){
		ans=min(ans,d[i].left*2+cnt);
		cnt=max(d[i].right,cnt);
	}
	sort(d+1,d+1+n,cmp2);
	ll ans2=1e10+2,cnt2=0;
	for(int i=n;i>=0;i--){
		ans2=min(ans2,d[i].right*2+cnt2);
		cnt2=max(d[i].left,cnt2);
	}
	cout<<min(ans,ans2)<<endl;
	return 0;
}
```
## 警示：初始值一定要设为 $10^{10}+2$，否则会WA！！！
完结撒花

---

## 作者：Claire0918 (赞：1)

首先，我们注意到每个跳蚤必然落进左侧或右侧最近的坑。记第 $i$ 个跳蚤到左侧最近的坑距离为 $l_i$，到右侧最近的坑距离为 $r_i$。特别地，如果一侧没有坑，那么那一侧对应的值是 $+\infty$。

这两个值是可以通过排序所有的坑后二分得出的，单次时间复杂度 $\mathcal{O}(\log m)$。

假设我们在整个移动过程中到达的最靠左的位置到原状态的距离为 $L$，最靠右的位置到原状态的距离为 $R$。此时，对于任何的 $i$，我们都要求且仅要求要么 $L \geq l_i$，要么 $R \geq r_i$。

对于确定的 $L$ 和 $R$，我们考虑先向一侧移动完所需的所有距离，再向另一侧移动返回原状态并再移动所需距离，最小步数是 $\min\{2L + R, 2R + L\} = L + R + \min\{L, R\}$。

我们可以证明向同一方向的不连续移动一定是不优的。比如我们先向左移动 $a$ 步，向右 $b$ 步，向左 $c$ 步，那么向左的最远距离是 $\max\{a, a - b + c\} = a + \max\{0, c - b\}$。但是，在步数不变的情况下，我们可以先向左移动 $a + c$ 步，再向右 $b$ 步，最远距离达到了 $a + c$，严格大于 $a + \max\{0, c - b\}$。

这样，我们证明了：在两次向左移动中插入一次向右移动一定对向左的最远距离是劣的。我们还有对称的定理：在两次向右移动中插入一次向左移动一定对向右的距离是劣的。我们得出结论：先向一侧移动，再向另一侧移动，随后直接结束移动一定是最优的，因为这方法同时满足了两个定理的条件。

我们现在要选取一个集合 $S \sub [1, n]$，使 $i \in S$ 都满足 $L \geq l_i$，而 $i \notin S $ 都满足 $R \geq r_i$。

我们有结论：将 $L$ 选在某个 $l_i$ 一定是最优的。这是因为如果 $L$ 不等于任何 $l_i$，我们可以将其减小，且对于每一个 $i$，是否满足 $L \geq l_i$ 的状态不变。

所以可以将每个点按照 $l_i$ 升序排序，枚举一个点 $i$，使 $L = l_i$，此时一切 $l_j \leq l_i$ 的 $j$ 都可以放进 $S$ 中，而剩下的都不行，所以有 $S = [1, i]$，从而 $\displaystyle R = \max_{k = i + 1}^{n} \{r_k\}$。

综上，我们得到做法：记 $f(L, R) = L + R + \max\{L, R\}$，先将每个点按照 $l_i$ 排序，答案即是 $\displaystyle \min_{i = 0}^{n} \{f(l_i, \max_{k = i + 1}^{n} \{r_k\})\}$。

我们记录后缀最大值，便可以 $\mathcal{O}(1)$ 得到 $\displaystyle \max_{k = i + 1}^{n} \{r_k\}$，总时间复杂度为二分处理 $l_i$ 和 $r_i$ 的 $\mathcal{O}(n\log m)$。

注意恰当选取 $+\infty$。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

const int maxn = 2e5 + 10;

int n, m;
long long res = 1e10;
int a[maxn], b[maxn];
pair<long long, long long> d[maxn];

int main(){
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= m; i++){
        scanf("%d", &b[i]);
    }
    sort(b + 1, b + m + 1);
    for (int i = 1; i <= n; i++){
        const int pl = upper_bound(b + 1, b + m + 1, a[i]) - b - 1, pr = lower_bound(b + 1, b + m + 1, a[i]) - b;
        const long long l = (pl ? a[i] - b[pl] : 3e9), r = (pr <= m ? b[pr] - a[i] : 3e9);
        d[i] = make_pair(l, r);
    }
    sort(d + 1, d + n + 1);
    long long suf = 0;
    for (int i = n; ~i; i--){
        res = min(res, (long long)min(d[i].first, suf) + d[i].first + suf);
        suf = max(suf, d[i].second);
    }
    printf("%lld", res);

return 0;
}
```

---

## 作者：lzh301 (赞：1)

# P7622坑

### 题目大意
在一维数轴上给出 $n$，$m$ 个虫子和洞的坐标，现在可以让虫子一起往左或往右跳一步，且虫子跳进坑中会~~发出惨叫后死去~~，问最少次操作可以让虫子全部被杀死。

### 思路
看到题目首先排除整体枚举，因为逐个判断肯定会超限。进而想到单个虫子推导。但又要分向左或向右跳，因此就需要画图推导了。

![](https://cdn.luogu.com.cn/upload/image_hosting/crgtmmu9.png)

可以看到，整体从原点向左跳 $n$ 步，再从原点向右跳 $m$ 步，就相当于先向右跳 $m$ 步，再往左跳 $(n+m)$ 步。因此，可以规定一个正方向，再以每只虫子到左右第一个洞的距离做贪心。

### 实现

先对洞和虫子的坐标进行排序，用二分求出每只虫子到左边和右边第一个洞的距离，再进行贪心。设到左洞距离为 $l$，右洞距离为 $r$，则贪心式为 $maxn=\max \left\{2 \times left+maxn,2\times maxn+right \right\}$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[200100];
int b[200100];
int n,m;
struct node{//因为要存储两个方向并排序，所以用结构体
	int l;
	int r;
}c[200100];
bool cmp(node s1,node s2){//此处优先跳左右都可以
	if(s1.l!=s2.l){
		return s1.l<s2.l;
	}else{
		return s1.r<s2.r;
	} 
}
int find(int x){//找x左边第一个洞
	if(x<b[1])return 0;
	if(x>b[m])return m;
	int l=1,r=m,k=0;
	while(l<=r){
		int mid=(l+r)/2;
		if(b[mid]>x){
			r=mid-1;
		}
		else l=mid+1,k=mid;
	}
	return k;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	sort(a+1,a+n+1);//排序
	sort(b+1,b+m+1);
	b[0]=-1e18;
	b[m+1]=1e18;
	int k;
	for(int i=1;i<=n;++i){
		k=find(a[i]);
		c[i].l=abs(a[i]-b[k]);//左边的第一个洞
		c[i].r=abs(b[k+1]-a[i]);//右边第一个洞
	}
	sort(c+1,c+n+1,cmp);
	int ma=0,ans=1e18;
	for(int i=n;i>=0;i--){
		ans=min({ans,c[i].l*2+ma,ma*2+c[i].l});//核心部分
    	ma=max(c[i].r,ma);
	}
	cout<<ans;
}
```

---


# [COCI 2010/2011 #5] BRODOVI

## 题目描述

Mirko 住在一个难得有船经过的有港口的小镇上。然而，直到今天，Mirko 还记得那天所有造访过这个港口的船只都出现了。他用索引 $1$ 表示这一天。

许多天过去了，Mirko 记下了至少有一艘船访问港口的日子，把这些日子命名为娱乐日。

此外，Mirko 注意到每艘船都定期访问港口。例如，长度为 $3$ 的间隔表示某艘船在第 $1$ 天、第 $4$ 天、第 $7$ 天、第 $10$ 天等时间访问港口。

给出 Mirko 的娱乐日列表（包括今天，且今天也是一个娱乐日），计算访问他的港口的最小可能的船只数量。

注:所有娱乐日都出现在 Mirko 的列表上，保证永远存在答案。

## 说明/提示

**【样例说明#1】**

最少需要两条船，第一条每 $2$ 天来一次，第二条每 $3$ 天来一次。

**【数据范围】**

对于 $70\%$ 的数据，$A_i\le 5\times 10^6$

对于 $100\%$ 的数据，$2\le N\le 5000$，$1 \le A_i\le 10^9$

**【说明】**

**【说明】**

本题分值按 COCI 原题设置，满分 $70$。

题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #5](https://hsin.hr/coci/archive/2010_2011/contest5_tasks.pdf)  _**T3 BRODOVI**_。

## 样例 #1

### 输入

```
3
1
3
4 ```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1
7
10
13
19 
```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1
500000000
999999999```

### 输出

```
1```

# 题解

## 作者：__yiLIUyi__ (赞：3)

传送门：[P7633 [COCI 2010/2011 #5] BRODOVI](https://www.luogu.com.cn/problem/P7633)。  
双倍经验：[SP8349 BRODOVI - BRODOVI](https://www.luogu.com.cn/problem/SP8349)。
## 题意
有一些船只，从第一天开始每隔固定的时间就会来到港口。现在给出 $n$ 个有船只来到的日子，求最少有多少只船。
## 思路
首先我们在题目中看到：
> 例如，长度为 $3$ 的间隔表示某艘船在第 $1$ 天、第 $4$ 天、第 $7$ 天、第 $10$ 天等时间访问港口。

观察它，我们就能得出几句~~废~~话：
- 这四个数字是一个等差数列，差为 $3$。
- 靠后的数字减去靠前的数字，结果可以被 $3$ 整除。即都是 $3$ 的倍数。如果是相邻两数相减，结果正好是 $3$。
- 数列中，任意一个数字减去第一个数字（也就是 $1$），结果都可以被 $3$ 整除，即都是 $3$ 的倍数。第二个数减去一，正好是 $3$。

从这些废话中，我们就可以得出题目解法：
- 维护一个数组 $vis$，记录每一条船的间隔时间；
- 对于每一个 $a_i$，查询 $vis$ 数组，如果存在 $vis_j$ 使得 $vis_j \mid a_i-1$，说明 $a_i$ 对应的船已经记录过了，不用进行操作；
- 否则，说明这是一条新船，我们把 $a_i-1$ 添加至 $vis$ 中（刚刚已经说过，数列中第二个数减去 $1$ 正好是这个数列的差）；
- 继续处理下一个数。

还有一点，上面之所以要减一，只是因为第一位是 $1$。如果第一位是 $2$ 就会减二。那如果第一位是 $0$，是不是就不用减了？所以我们在输入时就顺手把所有数字都减一，就把第一位变成了 $0$。显然这样不会影响我们的答案。
## 参考代码
```cpp line-numbers
//241ms / 844.00KB / 392B C++14 O2
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll n,a[5010];
bool flag;
vector<ll>v;//vis 数组
int main(){
    cin>>n;
    for(ll i=1;i<=n;i++){
        cin>>a[i];
        a[i]--;//减一
    }for(ll i=2;i<=n;i++){
        flag=false;//记录这条船在 vis 中能不能找到
        for(ll j:v)//提示：c++98 可能用不了这种写法
            if(a[i]%j==0){//找到了
				flag=true;
				break;//跳出
			}
        if(!flag)//没找到
			v.push_back(a[i]);//加入数组
    }cout<<v.size();//数组长度，也就是船的个数
    return 0;//好习惯
}//喜欢就点个赞呗~ QAQ
```

---

## 作者：little_cindy (赞：1)

## 前言

这不是大水题吗，怎么没人交题解……

[一模一样的题](https://www.luogu.com.cn/problem/SP8349)

## 思路

我们可以先把所有的时间减 $1$，剩下的时间都可以看作某一艘船的周期时间的倍数。

我们用 $ans$ 来储存船数，再用 $cur$ 来储存上一个枚举的数，初始值设为 $2$。

然后用一个while循环，每次找到第一个没有标记的数，$ans+1$，再用 $cur$ 标记这个数的下标。接着从这个数的下标开始，找到这个数的倍数，标记。当发现已经循环超过 $n$ 个时，退出while。

输出 $ans$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int n,ans,cur,a[N];
bool vis[N];
bool break_;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		a[i]--;//先减一
	}
	cur=2;//初始化
	while(1) {
		for(int i=cur; i<=n; i++) {//找第一个没标记的点
			if(!vis[i]) {
				cur=i;
				++ans;
				break;
			} else if(i==n) {
				break_=1;//标记结束while
			}
		}
		if(break_){//退出while
			break;
		}
		for(int i=cur; i<=n; i++) {//标记倍数
			if(a[i]%a[cur]==0) {
				vis[i]=1;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：qfpjm (赞：1)

# 题目大意

- 给你 $n$ 个时间点，每个时间点都会有船来，但每艘船的到达时间是有周期性的，你要算出最少有几艘船。

# 题解

- 数据范围 $5000$，直接暴力。

1. 首先，用两个数组 last 和 ship，$ship_i$ 和 $last_i$ 分别表示第 $i$ 艘船的到达时间周期和上一次到达的时间。

1. 然后，遍历每一个时间点 $a_i$，每个时间点遍历每艘船，当 $ship_j + last_j = a_i$ 时，表示有船可以这个时间到达，那么直接 break。

1. 如果，发现没有船可以这个时间点到达，那么船的数量 +1，记录下 ship 和 last。

1. 最后，输出你统计的船数量即可。

- 我们要注意，一艘船在访问过港口后，无论隔着几个间隔，它都会再次访问，我们不能只统计隔着一个间隔重新访问的情况。那么 $ship_j + last_j = a_i$ 就要改为 $(a_i - last_j) \bmod ship_j = 0$，表示当前天和这艘船上一次到达的时间之间的天数可以满足这艘船到达的周期。

# 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

long long n, a[100005], ship[100005], last[100005], ans;

int main()
{
    scanf("%d", &n);
    for (int i = 1 ; i <= n ; i ++)
    {
        scanf("%d", &a[i]);
    }
    ans = 1;
    ship[ans] = a[2] - a[1];
    last[ans] = a[2];
    for (int i = 3 ; i <= n ; i ++)
    {
        bool flag = false;
        for (int j = 1 ; j <= ans ; j ++)
        {
            if ((a[i] - last[j]) % ship[j] == 0)
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            ans ++;
            ship[ans] = a[i] - a[1];
            last[ans] = a[i];
        }
    }
    printf("%d", ans);
    return 0;
}
```


---


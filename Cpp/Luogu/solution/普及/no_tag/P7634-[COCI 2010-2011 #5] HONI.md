# [COCI 2010/2011 #5] HONI

## 题目描述

COCI 的出题者必须从一堆题目中选择在下一轮中出现的题目。

题目的难度用 $1$ 到 $n$ 的整数来描述，但是对于某些题目来说，这并不容易准确地确定它们的难度。COCI 的出题者认为这些题目可以被视为有两个连续难度之一。例如，某些题目可以被视为难度为 $3$ 或 $4$。

下一轮 COCI 将包含的 $N$ 个题目。每一个难度，都会有且仅有一个题目。当然，没有题目会出现两次。

找出出题者为下一轮选择题目的不同方法的数量。我们认为两种方法是不同的仅当相同的任务分配给了不同的难度。

由于预期的结果可以非常大，输出的方案数 $\% 10^9+7$。

## 说明/提示

**【样例解释#1】**

共 $3$ 种方案：将难度为 $2$ 或 $3$ 的题目视为难度为 $2$ 的，因为难度为 $1$ 的题目有 $3$ 道，所以共 $3$ 种方案。

**【数据范围】**

对于 $100\%$ 的数据，$2\le N\le 10^5$，$0\le A_i,B_i\le 10^9$。

**【说明】**

本题分值按 COCI 原题设置，满分 $100$。

题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #5](https://hsin.hr/coci/archive/2010_2011/contest5_tasks.pdf)  _**T4 HONI**_。

## 样例 #1

### 输入

```
3
3 0 1
0 1 
```

### 输出

```
3```

## 样例 #2

### 输入

```
4
1 5 3 0
0 2 1 ```

### 输出

```
33```

# 题解

## 作者：☯☯枫☯☯ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P7634)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/14940741.html)

**算法分析：线性 dp**

应该来说是比较明显的线性 dp，关键在于如何设计状态及转移方程。

在本题中涉及两种“题目”，即仅能被视为一个难度的“题目”和能被视为有两个连续难度的“题目”。作为两种不同的情况，一维的 dp 明显是不够的，需要加入第二维。

为了表述方便，下文称“仅能被视为一个难度的‘题目’”为“第一种题目”，其数量记为 $a_i$；称“能被视为有两个连续难度的‘题目’”为“第二种题目”，其数量记为 $b_i$。在分析中，将省略“取模”这一过程。

接下来分析 dp 的状态及转移方程。

**状态：**

>我们设计 $dp_{i,j}$ 表示对于难度 $i$ ，是用方法 $j$ 解决的。其中 $j\in\{0,1\}$，在此记 $j=0$ 为使用了第一种题目，$j=1$ 为使用了第二种题目（当然，反过来也一样）。

**边界：**

> 根据状态，显然地，$dp_{1,0}=a_1,dp_{1,1}=b_1$，要求的答案为 $dp_{n,0}+dp_{n,1}$

**转移方程：**

> - 根据题意，对于 $j=0$ 的情况，要考虑难度 $i-1$ 的使用情况。若上一个使用了第一种题目，那么其贡献为 $dp_{i-1,0}\times(a_i+b_{i-1})$，若上一个使用了相应的第二种题目，则贡献为 $dp_{i-1,1}\times(a_i+\max(b_{i-1}-1,0))$。由于上一个使用了第二种题目，数量须 $-1$。同时为了防止 $b_{i-1}=0$ 的情况，与 $0$ 取最大值，增强程序的容错率。
>
> - 对于$j=1$ 的情况较为简单，两种情况的贡献各为 $dp_{i-1,0}\times b_i$ 以及 $dp_{i-1,1}\times b_i$。
>
>   综上所述，有：
>
>   $$dp_{i,j}=\begin{cases}dp_{i-1,0}\times(a_i+b_{i-1})+dp_{i-1,1}\times(a_i+\max(b_{i-1}-1,0))&j=0\\dp_{i-1,0}\times b_i+dp_{i-1,1}\times b_i&j=1\end{cases}$$ 

在此过程中，$i:2\to n$，时间复杂度为 $\mathcal{O}(n)$，满足条件。

下面给出代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define F(i,a,b) for(reg int i=a;i<=b;++i)
using namespace std;
inline int read();
const int N=1e5+10,mod=1e9+7;
int n,a[N],b[N];
ll dp[N][2];
int main() {
	n=read();
	F(i,1,n)a[i]=read();
	F(i,1,n-1)b[i]=read();
	dp[1][0]=a[1],dp[1][1]=b[1];
	//初始化 
	F(i,2,n){
		dp[i][0]=(dp[i-1][0]*(a[i]+b[i-1])+dp[i-1][1]*(a[i]+max(b[i-1]-1,0)))%mod;
		dp[i][1]=(dp[i-1][0]*b[i]+dp[i-1][1]*b[i])%mod;
	}//转移 
	printf("%lld",(dp[n][0]+dp[n][1])%mod);
	return 0;
}
inline int read() {
	reg int x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
```

写到这里已经足够了，但事实上，空间仍然可以优化。观察到 $dp_{i,0}$ 和 $dp_{i,1}$ 均由 $dp_{i-1,0}$ 和 $dp_{i-1,1}$ 迭代转移过来，因此可以用一个变量来滚动记录。下面给出利用变量滚动记录的代码：

```cpp
	x=a[1],y=b[1];
	F(i,2,n){
		ll xx=(x*(a[i]+b[i-1])+y*(a[i]+max(0,b[i-1]-1)))%mod;
		ll yy=(x*b[i]+y*b[i])%mod;
        //滚动
		x=xx,y=yy;
	}
```

两个代码在本质上是完全一致的。

[AC](https://www.luogu.com.cn/record/52108575)

欢迎交流讨论，请点个赞哦~

---

## 作者：Meowco (赞：1)

## 题意

简单来说，就是有一堆题目，每个题目都有一个难度。

要从里面取 $N$ 道题出一场比赛：难度 $1 \sim N$ 且每种难度 $1$ 道题，问有多少种方案。

下面定义：难度确定的题目为第一种难度 $a_i$，否则为第二种难度 $b_i$，即可以当两种难度用。

## 做法

如果没有第二种难度的题目，我们的做法十分简单明了：
- 从 $1 \sim n$ 枚举难度，$dp[i]$ 表示前 $i$ 种难度所能组出的比赛的方案数，$dp[i] = dp[i-1] \times a[i]$。

如果加入了第二种难度类型的题目，对于当前枚举到的难度 $i$，可以分类成下面两种情况：

- 选择 $a_i$ 和 $b_{i-1}$ 中的一道题目。
- 选择 $b_i$ 中的一道题目。

为什么这样分类呢？

由于第二种难度的题目 $b_i$ 不仅可以用于难度 $i$，还能用于难度 $i+1$。这意味着 $b_i$ 的选取与否会产生后效性，而选 $a_i$ 和 $b_{i-1}$ 则不会，因为难度 $i+1$ 不能使用 $a_i$ 和 $b_{i-1}$ 的题。

比如说样例：

```
4
1 5 3 0
0 2 1 
```

如果难度 $3$ 时选择了 $b_3$，那么难度 $4$ 时将没有题目可选。

我们定义 $f[i]$ 表示难度 $i$ 只选择 $a_i$ 和 $b_{i-1}$ 时的方案数，而 $g[i]$ 表示难度 $i$ 只选择 $b_i$ 时的方案数，那么转移就应该为：

- $f[i] = f[i-1] \times (a[i] + b[i-1]) + g[i-1] \times (a[i] + b[i-1] - 1)$，需要关注的点是：从 $g[i-1]$ 转移时，由于 $i-1$ 选了 $b_{i-1}$，此时 $b_{i-1}$ 少了一个。

- $g[i] = f[i-1] \times b[i] + g[i-1] \times b[i]$。

最后我们的答案即 $f[n] + g[n]$。


## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;
#define ll long long
const ll mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;
    vector<ll> a(n + 1, 0), b(n + 1, 0);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i < n; i++)
        cin >> b[i];
    vector<ll> f(n + 1), g(n + 1);
    f[0] = 1;
    for (int i = 1; i <= n; i++) // 枚举难度
    {
        f[i] = f[i - 1] * (a[i] + b[i - 1]) % mod + g[i - 1] * (a[i] + b[i - 1] - 1) % mod;
        g[i] = f[i - 1] * b[i] % mod + g[i - 1] * b[i] % mod;
    }
    cout << (f[n] % mod + mod) % mod;
    return 0;
}
```

---

## 作者：Oracynx (赞：0)

## P7634 [COCI2010-2011#5] HONI 题解

### 思路分析

一道显然的 dp 题。

记 $dp_{i, j}, i \in [1, n], j \in [0, r]$，表示难度 $\le i$ 的题目已经筹备完毕，而 $j$ 的含义如下：

- $j = 0$ 表示难度为 $i$ 的题目使用的题目的难度确定为 $i$ 或者可以是 $i - 1, i$。
- $j = 1$ 表示难度为 $i$ 的题目使用的题目的难度可以是 $i, i + 1$。

然后分情况转移。
$$
dp_{i, 0} \gets dp_{i - 1, 0} \times (a_i + b_{i - 1}) + dp_{i - 1, 1} \times (a_i + \max(b_{i - 1} - 1, 0)) \\
dp_{i, 1} \gets dp_{i - 1, 0} \times b_i + dp_{i - 1, 1} \times b_i
$$
其中，$a_i + b_{i - 1}$ 表示在当前题目可以达到的最大难度不超过 $i$ 的情况下一共又多少种选法。

自然对应了上一位难度不超过 $i - 1$ 的方案数，因为显然两者没有重叠。

而当上一位的难度已经达到了 $i$ 的情况下，$b_i$ 就应该少了一个（给前面去了），所以是 $a_i + \max(b_{i - 1} - 1, 0)$。

然后当最大难度必须达到 $i + 1$ 的时候必须使用难度为 $i, i + 1$ 的题目，然后这个难度的题目不受上一位选择的影响。

写出 dp 注意取模即可。

### 代码实现

```cpp
#include <algorithm>
#include <cstdio>
constexpr int MaxN = 1e5 + 5;
constexpr long long Mod = 1'000'000'007;
int n;
int a[MaxN];
int b[MaxN];
long long dp[2][MaxN];
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= n - 1; i++)
    {
        scanf("%d", &b[i]);
    }
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++)
    {
        dp[0][i] =
            (dp[0][i - 1] * (a[i] + b[i - 1]) % Mod + dp[1][i - 1] * (a[i] + std::max(b[i - 1] - 1, 0)) % Mod) % Mod;
        dp[1][i] = (dp[0][i - 1] * b[i] % Mod + dp[1][i - 1] * b[i] % Mod) % Mod;
    }
    printf("%lld\n", dp[0][n] + dp[1][n]);
    return 0;
}


```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

有 $n$ 个难度值，且有 $a_{1 \dots n}$ 道难度为 $1 \dots n$ 的题。同时又有一些难度不定的题目，难度为 $i$ 或 $i+1$ 的题目的个数为 $b_i$。输入 $n,a_{1 \dots n},b_{1 \dots n-1}$，求出有多少种 $n$ 题组合可以让 $1 \dots n$ 中所有难度的题都存在。

## Part 2 思路

$2 \leq n \leq 10^5$，考虑使用**动态规划**。

显而易见，对于组合中难度为 $i$ 的题，或从 $a_i$ 中选出，或从 $b_i,b_{i+1}$ 中选出。因此我们考虑第 $i$ 难度的时候，就可以令：

- $f_i$ 表示 $i$ 从 $a_i$ 中诞生出来时的方案数。

- $g_i$ 表示 $i$ 从 $b_i,b_{i+1}$ 中诞生出来时的方案数。

开始的时候，$f_1$ 从 $a_1$ 中诞生的方案数就是 $a_1$，$g_1$ 同理，所以 $f_1 \leftarrow a_1,g1 \leftarrow b_1$。那么，我们要求的答案便是 $f_n+g_n$。

如何进行 $f_i,g_i$ 的状态转移呢？

首先，为了简化问题，既然 $b_i$ 可以表示难度为 $i,i+1$ 的题目，那我们就将 $b_i$ 代表 $i+1$ 难度的时候与 $a_{i+1}$ 共同考虑，只在 $b_i$ 表示 $i$ 难度的时候单独考虑。

对于 $f_i$，我们要考虑的有 $f_{i-1}$ 和 $g_{i-1}$：

- $f_{i-1}$ 要转移到 $f_i$，难度 $i$ 可以从 $a_i,b_{i-1}$ 中诞生。

- $g_{i-1}$ 要转移到 $f_i$，难度 $i$ 可以从 $a_i,b_{i-1}$ 中诞生。特别的，由于 $g_i$ 是已经保证了上次选择是 $b_{i-1}$ 中诞生的，所以我们要扣去上次情况，即 $b_{i-1}-1$。更特别的，如果 $b_{i-1}-1<0$，我们就将其当作 $0$ 处理，或者说不管它了。

因此，我们得到转移方程：

- $f_i=f_{i-1} \times (a_i+b_{i-1})+g_{i-1} \times (a_i+\max(b_{i-1},1)-1)$。

对于 $g_i$，我们需要考虑的有 $f_{i-1}$ 和 $g_{i-1}$：

- 无论是 $f_{i-1}$ 还是 $g_{i-1}$，要转移到 $g_i$，只能从 $b_i$ 中诞生。

因此，转移方程就是：

- $g_i=(f_{i-1}+g{i-1}) \times b_i$。

当然了，我们还要对 $10^9+7$ 取模.

## Part 3 代码

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=1e5+5,mod=1e9+7;
int n,a[maxn],b[maxn];
ll f[maxn],g[maxn]; 
inline ll read()
{
	ll x=0,y=1;
	char ch=getchar();
	while (ch<'0' || ch>'9')
	{
		if (ch=='-') y=-1;ch=getchar();
	}
	while (ch>='0' && ch<='9')
	{
		x=x*10+int(ch-'0');ch=getchar();
	}
	return x*y;
}
int main()
{
	n=read();
	for (ll i=1;i<=n;i++) a[i]=read();
	for (ll i=1;i<=n-1;i++) b[i]=read();
	for (ll i=1;i<=n;i++)
	{
		if (i==1) { f[1]=a[1],g[1]=b[1];continue; }
		f[i]=(f[i-1]*(a[i]+b[i-1])+g[i-1]*(a[i]+max(b[i-1],1)-1))%mod;
		g[i]=((f[i-1]+g[i-1])*b[i])%mod;
	}
	cout<<(f[n]+g[n])%mod;
	return 0;
}
```

---

## 作者：zgy_123 (赞：0)

`dp` 一眼题，但是赛时少了一种情况，`100 -> 30`。

其他两个题解都是两个 `dp`，有些难理解，这里使用最朴素的三个 `dp`。

首先考虑状态，按直觉，有三种：

- $dp_{i,0}$：本次题目使用 A 类题目
- $dp_{i,1}$：本次题目使用 B 类题目且用 $\{i-1,i\}$ 为第 $i$ 类难度
- $dp_{i,2}$：本次题目使用 B 类题目且用 $\{i,i+1\}$ 为第 $i$ 类难度

那么就考虑用这三种状态转移（以下算式均不考虑取模）。

首先考虑第一种，显然无论上一个难度是什么情况，均可选任意题目，转移式为 $dp_{i,0}=A_i\cdot\sum_{x=0}^{2} dp_{i-1,x}$。

其次，第二种，此时，如果前一种难度使用前两种方法均可以选任意一道，而如果前一种难度选择为第三种，则会有一道题目不能选择，$dp_{i,1}=(dp_{i-1,0}+dp_{i-1,1})\cdot B_{i-1}+dp_{i-1,2}\cdot (B_{i-1}-1)$。

最后是第三种，与第一种类似，不受影响，$dp_{i,2}=B_i\cdot\sum_{x=0}^{2} dp_{i-1,x}$。

综上，转移式就可以了。

考虑结果，由于最后一道题不限制种类，为 $\sum_{i=0}^2dp_{n,i}$，但是因为 $B_n=0$，所以其实 $dp_{n,2}=0$，即结果等价于 $dp_{n,0}+dp_{n,1}$。

初始条件也显然，$dp_{0,0}=1$。

代码中要注意取模：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define Mod 1000000007
ll dp[100005][3],a[100005],b[100005];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++) cin>>b[i];
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		dp[i][0]=(dp[i-1][0]+dp[i-1][1]+dp[i-1][2])%Mod*a[i]%Mod;
		dp[i][1]=((dp[i-1][0]+dp[i-1][1])%Mod*b[i-1]%Mod+dp[i-1][2]*(b[i-1]-1)%Mod)%Mod;
		dp[i][2]=(dp[i-1][0]+dp[i-1][1]+dp[i-1][2])%Mod*b[i]%Mod;
	}
	cout<<(dp[n][0]+dp[n][1])%Mod;
	return 0;
}

```
另外发现，$dp_{i,0}$ 和 $dp_{i,1}$ 所有时候都是一起计算的，所以可以合并，转移式会有相应的改变。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define Mod 1000000007
ll dp[100005][3],a[100005],b[100005];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++) cin>>b[i];
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		dp[i][0]=((dp[i-1][0]+dp[i-1][1])*a[i]%Mod+dp[i-1][0]*b[i-1]%Mod+dp[i-1][1]*(b[i-1]-1)%Mod)%Mod;
		dp[i][1]=(dp[i-1][0]+dp[i-1][1])*b[i]%Mod;
	}
	cout<<dp[n][0];
	return 0;
}

```
你会发现上面那个代码就是其他两个题解的代码。

祝大家 CSP 2023 RP++！！！

---

## 作者：wandereman (赞：0)

## 思路
如果加入了第二种难度类型的题目，对于当前枚举到的难度 $i$，可以分类成下面两种情况：       
- 选择 $a[i]$ 和 $b[i - 1]$ 中的一道题目。         
- 选择 $b[i]$ 中的一道题目。    

然后我们就可以按照常规方法得出以下动态转移方程，$dp1$ 是辅助的数组，$dp2$ 负责得出答案：

- $dp1[i] = dp1[i - 1] \times (a[i] + b[i - 1]) + dp2[i - 1] \times (a[i] + b[i - 1] - 1)$。
- $dp2[i] = dp1[i - 1] \times b[i] + dp2[i - 1] \times b[i]$ 。

最后注意模上 $10^9 + 7$ 。
## AC code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod = 1e9 + 7;
ll a[1000005],b[1000005],dp1[1000005],dp2[1000005],i;
int main(){
    int n;
    cin>>n;
    for(i = 1;i <= n;i++){
    	cin>>a[i];
	}
    for(i = 1;i < n;i++){
    	cin>>b[i];
	}
    dp1[0] = 1;
    for(i = 1;i <= n;i++){
        dp1[i] = dp1[i - 1] * (a[i] + b[i - 1]) % mod + dp2[i - 1] * (a[i] + b[i - 1] - 1) % mod;
        dp2[i] = dp1[i - 1] * b[i] % mod + dp2[i - 1] * b[i] % mod;
    }
    cout<<(dp1[n] % mod + mod)%mod;
    return 0;
}
```

---

## 作者：内拉组里 (赞：0)

一道简单的 **dp**。

# Thoughts：

令 $ dp[i][0/1] $ 表示将难度 $ [1,i] $ 分配完的方案数，并且是 / 否在难度 $ i $ 处分配了 $ B_i $ 中的题目。

显然地，$ B_i $ 中题目的选择不受 $ B_{[1,i - 1]} $ 的影响，

$ dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) \times b[i] $ 

而对于 $ dp[i][0] $ 的转移考虑容斥，

当前难度可以选择的题目数共有 $ a[i] + b[i - 1] $ 道，讨论上一次的决策：

- 没有选择 $ b[i - 1] $，那么这 $ a[i] + b[i - 1] $ 道题可以任意选,。

- 选择了 $ b[i - 1] $，那么这 $ b[i - 1] $ 题中有一道被分配到了上一个难度，

  所以只有共 $ a[i] + b[i - 1] - 1 $ 道题可以选。

最后输出 $ dp[n][0] $ 即可，因为不存在 $ b[n] $，不能考虑 $ dp[n][1] $。

# Analyses：

> 总时间复杂度 $ \Theta (N) $。
>
> 总空间复杂度 $ \Theta (N) $。

# Code：

```cpp
/* reference : @ZLOJ.huhangqi */
#include	<iostream>
#define		int		long long
using namespace std;
constexpr int maxn = 1e5+4;
constexpr int modd = 1e9+7;

int n;
int a[maxn];
int b[maxn];
int dp[maxn][2];
/* dp[i][0/1] means the total layouts to arrange tasks in difficulty[1,i],with(out) using advanced staff */

signed main (void)
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i < n; i++) cin >> b[i];
	dp[0][0] = 1;
	for (int i = 1; i <= n; i++)
	{
		dp[i][0] = ((a[i] + b[i - 1]) * dp[i - 1][0] + (a[i] + b[i - 1] - 1) * dp[i - 1][1]) % modd;
		dp[i][1] = ((dp[i - 1][0] + dp[i - 1][1]) * b[i]) % modd;
	}
	cout << dp[n][0] << endl;
	return 0;
}
```

---


# [COCI 2013/2014 #5] OBILAZAK

## 题目描述

给出一棵有 $2^K-1$ 个节点的完全二叉树，遍历这棵树的规律如下：

- 起点是二叉树第一层的唯一一个节点。

- 如果当前节点的左孩子还没有记录到，那么就记录左孩子的编号并移动到左孩子处。

- 如果当前节点没有左孩子或者左孩子已经记录过，就记录当前节点的编号。

- 如果当前节点已经记录过，那么就记录右孩子的编号并移动到右孩子处。

- 如果当前节点及此节点的左右孩子都已经记录过，那么就移动到当前节点的父节点处。

现在给出从第一层的节点出发记录下的编号顺序，请你求出原本的完全二叉树。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/wk4ai6vq.png)

先移动到节点 $1$，发现左孩子没有记录，移动到节点 $2$ 并记录节点 $2$；发现节点 $2$ 没有孩子，返回节点 $1$ ，发现此节点没有记录，记录节点 $1$；发现右孩子没有记录，移动到节点 $3$ 并记录节点 $3$。

**【样例解释 #2】**

![](https://cdn.luogu.com.cn/upload/image_hosting/e8txnko0.png)

**【数据范围】**

对于 $100\%$ 的数据，$1\le K\le 10$。

**【说明】**

本题分值按 COCI 原题设置，满分 $80$。

题目译自[COCI2013_2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #5](https://hsin.hr/coci/archive/2013_2014/contest5_tasks.pdf) _**T2 OBILAZAK**_

## 样例 #1

### 输入

```
2
2 1 3 ```

### 输出

```
1
2 3 ```

## 样例 #2

### 输入

```
3
1 6 4 3 5 2 7```

### 输出

```
3
6 2
1 4 5 7```

# 题解

## 作者：亦枫 (赞：9)

## Solution

题意：给你一棵满二叉树的中序遍历，求原树。特别地，给定 $ k $，此树有  $ 2^k-1 $ 个节点。

我们直接取最中间的节点，放到该层，再将左右分为两棵子树，在进行相同的操作即可。

递归解决，答案用二维数组记录，最后一层层依次输出即可。

~~貌似没什么难点~~

关键部分Code：
```cpp
void dfs(int l,int r,int dep){//l表示左端点，r表示右端点，dep表示深度
	if(l>r)return ;//跳出递归的条件
	cnt[dep]++,ans[dep][cnt[dep]]=a[(l+r)/2];//记录答案
	dfs(l,(l+r)/2-1,dep+1);//左子树
	dfs((l+r)/2+1,r,dep+1);//右子树
}
```


---

## 作者：yydfj (赞：5)

**这是本蒟蒻第八次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个完全二叉树中序遍历后得出的结果，输出该完全二叉树。

## 解法综述

我们假设一个完全二叉树如下图：

![该图摘自本人CSDN博客](https://img-blog.csdnimg.cn/20210716190858528.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pHX0RGXw==,size_16,color_FFFFFF,t_70#pic_center)

（该图摘自本人CSDN博客）

它的中序遍历为 $4251637$。

通过观察，我们会发现下面这一规律：

输出的第 $1$ 个数其实是它中序遍历的第 $4$ 个数；

输出的第 $2$ 个数其实是它中序遍历的第 $2$ 个数；

输出的第 $3$ 个数其实是它中序遍历的第 $6$ 个数；

输出的第 $4$ 个数其实是它中序遍历的第 $1$ 个数；

输出的第 $5$ 个数其实是它中序遍历的第 $3$ 个数；

输出的第 $6$ 个数其实是它中序遍历的第 $5$ 个数；

输出的第 $7$ 个数其实是它中序遍历的第 $7$ 个数；

其实就是输出该遍历中间的数并换行，然后从该遍历的中间开始分割成两份，输出左边那一份中间的数和右边那一份中间的数并换行，之后从这两份的中间开始分割成四份，输出第一份、第二份、第三份、第四份中间的数并换行，再将它们分割成八份......以此类推，直到将它们输出完为止。

## 代码描述
```cpp
#include<cstdio>
int n,b=1,a[1025],c,s=2;//s为该完全二叉树当前深度需要输出的节点
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) b*=2;
	b--;//b为要输出的总节点数
	for(int i=1;i<=b;i++) scanf("%d",&a[i]);
	b=(b+1)/2;
	printf("%d\n",a[b]);//输出第一行，为该遍历中间的数
	c=b/2;
	while(--n)//继续输出n-1行
	{
		printf("%d ",a[c]);//先输出第一份中间的数
		for(int i=1;i<s;i++) printf("%d ",a[b*i+c]);//再输出第2到s份中间的数
		printf("\n");
		b=c;
		c/=2;//模拟分割
		s*=2;//深度加1，节点乘2
	}
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：2)

## 题意

给定一棵满二叉树的中序遍历，求其原树。

特别地，给定 $k$，此树有 $2^k-1$ 个节点。

## 解法

实际上是很简单的题目。

考虑到中序遍历的特性，我们只需要在 $dep<k$ 的时候进行递归式的读入，先读入左子树，其次根节点，再次右子树即可。因为叶子节点并不需要进行下一层的遍历，因此可以特判。

而我们在输出的时候需要注意的是何时应当换行——事实上，用一个变量计算每一层满二叉树的末尾编号即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,t[1<<10],ke=1,se=1;
void build(int id,int dep){
	if(dep<k){
		build(id<<1,dep+1);
		scanf("%d",&t[id]);
		build((id<<1)+1,dep+1);
	}else scanf("%d",&t[id]);
}signed main(){
	scanf("%d",&k);
	build(1,1);
	for(int i=1;se<=k;i++){
		if(ke==i){
			se++;
			cout<<t[i]<<endl;
			ke<<=1;ke++;
		}else cout<<t[i]<<' ';
	}return 0;
}
```

---

## 作者：I_have_been_here (赞：1)

# 题目分析

这道题给出了多种操作，看似非常复杂，其实简单的概括一下你就可以知道他所要求做的操作就是关于二叉树的中序遍历，结合所求，就是给出一棵二叉树的中序遍历让你去求这棵二叉树原来长什么样子。

# 思路解析

首先，我们针对中序遍历入手，假设我们给出一棵二叉树，让你去求它的中序遍历长什么样子，这个很简单吧，无疑是遍历左子树，再是根节点，最后是右子树，这道题无非是让你去反着求，那么我们可以把原数列 $num$ 看做一个大区间，接下来我们要去切开它，那么每一个部分切下来的小区间都是它的子区间，也就是子树，但是对于它的左右子树我们无从得知，所以我们对其子区间的父子点计算，那么对于一个左端点为 $l$， 右端点为 $r$ 的区间，它在原树上的父节点无疑是 ```l + r >> 1```， 那么我们再以其作为分界点，不断向下递归，对于 $limit$ 层我们分别记录答案即可。

详细看代码吧。

# AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 32770;
int num[maxn], k, n, cnt[maxn], ans[15][maxn];
void dfs(int l, int r, int limit) {
	//cout << l << " " << r << endl;
	if (l > r) return; // 如果不符合条件
	if (l == r) { // 这种情况下不需要继续了，但是要记录答案
		cnt[limit]++, ans[limit][cnt[limit]] = num[(l + r >> 1)]; // 在原数列中找
		return;
	}
	cnt[limit]++, ans[limit][cnt[limit]] = num[(l + r >> 1)]; // 记录每层数的数量和答案
	int mid = l + r >> 1; // 分界
	dfs(l, mid, limit + 1); // 递归
	dfs(mid + 1, r, limit + 1);
}
int main() {
	scanf("%d", &k);
	n = pow(2, k) - 1;
	//cout << n <<endl;
	for (int i = 1; i <= n; i++)
		scanf("%d", &num[i]); // 读入
	dfs(1, n, 1);
	for (int i = 1; i <= k; i++) {
		for (int j = 1; j <= cnt[i]; j++) {
			printf("%d ", ans[i][j]); //输出答案
		}
		puts(" ");
	}
}
```


---

## 作者：Catcats (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7673)

### 题目大意：
给定一棵满二叉树的中序遍历，求出层序遍历，并按树形输出。

### 前置芝士

知道中序遍历的神犇请自行跳过此章。

对于一棵形如下图的二叉树：

```tree
  F
 / \
L   R
```
F 是树的根节点，L 与 R 是 F 的左右子树，则遍历顺序为：`L-F-R`。

而对于子树，同样这样遍历。

举例：

```tree
    1
   / \
  2    3
 / \  / \
4   5 6  7
```

其中序遍历为 `4251637`。

### 解题思路

既然中序遍历是 L-F-R，这又是满二叉树，可以找中间的结点作为当前根结点，然后分别如此遍历左子树与右子树，得到层序遍历。

举例：中序遍历为 `4251637`，先挑出中间的 `1`，再遍历左边，挑出 `2`，等等，便能得到层序遍历 `1234567`。

那么剩下的就是输出了。

我们知道，满二叉树的第 $k$ 层有 $2^k-1$ 个结点，于是我们可以让层数 $lev$ 与节点号 $i$ 一起枚举，当 $2^{lev}-1=i$ 时换行输出下一行。

### 完整代码

代码如下：

```cpp
//为了节省空间，在值域小时可用 char 或 short
#include<bits/stdc++.h>
using namespace std;
void mid_order(short i,char dep,char k,short t[]){//i:遍历节点，dep:遍历深度，k:总深度，t:树数组
	if(dep<k){//没到底
		mid_order(i*2,dep+1,k,t);//L
		cin>>t[i];//F
		mid_order(i*2+1,dep+1,k,t);//R
	}
	else cin>>t[i];//到底
}
int main(){
	char k;scanf("%d",&k);//不能直接 cin
	short t[1<<k];
	mid_order(1,1,k,t);
	for(short i=1,lev=1;lev<=k;i++){//i:节点，lev:当前层;
		if((1<<lev)-1==i){//满一层换行
			lev++;
			cout<<t[i]<<endl;
		}
		else cout<<t[i]<<' ';
	}
}
```

更新日志：

- 7/24：补充了中序转层序的过程说明。

---

## 作者：书雪 (赞：1)

题意：给出一棵完全二叉树树的中序遍历（即左->中->右顺序），求原树

作为完全二叉树的中序遍历，可以得到最中间的数一定是根节点，完全可以递归完成这道题

```cpp
#include<bits/stdc++.h>
using namespace std;
int tr[11][2010],n,a[5010],s[11];
void dfs(int depth,int l,int r){//深度，树的最左端，树的最右端
	int mid=(l+r)/2;
	tr[depth][++s[depth]]=a[mid];//由于递归是开始是越来越向左，故可以用tr数组存储第depth层的第i个元素
	if(l==r) return; 
	dfs(depth+1,l,mid-1);
	dfs(depth+1,mid+1,r);
	return;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=(1<<n)-1;i++){//位运算 1<<n 即2的n次幂
		scanf("%d",&a[i]);
	}
	dfs(1,1,(1<<n)-1);//在此鸣谢 _樱岛麻衣_ 帮这个蒟蒻调出了这里的问题
	for(int i=1;i<=n;i++){
		for(int j=1;j<=(1<<i-1);j++){
			printf("%d ",tr[i][j]);//模拟树的形状
		}
		printf("\n");
	}
	return 0;
}

```


---

## 作者：idgg007 (赞：1)

### 题面分析
- 给出了完全二叉树。
- 采用后序遍历输入（可以用深搜解决）。
## 存储
使用一维数组使得 $tree_i$ 的左子树为 $tree_{2i}$ 而右子树为 $ tree_{2i+1}$ 根节点为 $tree_1$ 。
## 读入
如代码所示，**注意：需要提前判断是否为叶子结点**
```cpp
void BuildTree(int k,int deap){
	if(deap<depth/*树的深度*/){			//非叶子结点的操作
		BuildTree(k*2,deap+1);			//遍历左子树
		scanf("%d",&binaryTreeData[k]);		//根节点
		BuildTree(k*2+1,deap+1);		//右子树
	}else{						//叶子结点的操作
		scanf("%d",&binaryTreeData[k]);
	}
}
```
## 输出
- 我们不难发现题目要求把每一层的数据都输出出来，我们只需判断好换行条件，依将数组内元素输出就行了。
- 而换行条件是输出到每一层的最靠右的结点，我们只需从一开始输出时就一直找结点的右子树就搞定了。
### 完整代码
```cpp
#include<cstdio>
int binaryTreeData[2048];
int depth;
void BuildTree(int k,int deap){
	if(deap<depth){
		BuildTree(k*2,deap+1);			//遍历左子树
		scanf("%d",&binaryTreeData[k]);		//根节点
		BuildTree(k*2+1,deap+1);		//右子树
	}else{						//叶子结点的操作
		scanf("%d",&binaryTreeData[k]);
	}
}
int main(){
	scanf("%d",&depth);
	BuildTree(1,1);
	int kEndl=1,sumEndl=1;
	for(int i=1;sumEndl<=depth;i++){
		if(kEndl==i){
			sumEndl++;			//增加记录总行数
			printf("%d\n",binaryTreeData[i]);
			kEndl=kEndl*2+1;		//换行标记:右子树
		}else{
			printf("%d ",binaryTreeData[i]);
		}
	}
}
```


---

## 作者：gaozhiyuan2007 (赞：0)

本蒟蒻第一次发题解，求通过，如有错误请指出。



题意：
------------
 给出一棵深度为 $k$ 的满二叉树的中序遍历，求原树。
 
 
 
 做法：
------------
 因为要按层输出，所以可以使用一个二维数组存储。
 搜索方式类似于深搜，一直搜到没有子节点的节点（深度为 $k$）就回溯。
 
分析样例，不难得到存储在二维数组中，位置为 $(x , y)$ 的节点的左右子节点分别为 $( x+1 , 2y+1 )$ 和 $( x+1 , 2y+1 )$，所以在函数递归调用的时候如是处理即可。输出时就非常方便了，输出 $k$ 层，每层输出 $k^2-1$ 个元素。


具体做法看代码。
 
 完整代码
------------

 ```cpp
#include<bits/stdc++.h>
using namespace std;
int k;//树的深度
int t[15][1024];//第一层为深度，第二层为该层节点数
int point[1024];//记录存入的节点
int i=1;//记录当前访问到的节点
void process(int x,int y){//处理t[x][y]
   if(x==k){
       t[x][y]=point[i++];//如果此节点深度等于k，说明它没有子节点，将值存入并返回
       return;
   }
   if(t[x+1][y*2-1]==0) process(x+1,y*2-1);//处理左子树
   t[x][y]=point[i++];//记录中间节点的值
   if(t[x+1][y*2]==0) process(x+1,y*2);//处理右子树
}
int main(){
   scanf("%d",&k);
   int n=pow(2,k)-1;//总结点数
   for(int i=1;i<=n;i++)
       scanf("%d",&point[i]); //读入节点
   process(1,1);//从根节点开始处理
   for(int i=1;i<=k;i++){
       int x=pow(2,i-1);//每一层的节点数
       for(int j=1;j<=x;j++)
           printf("%d ",t[i][j]);
       printf("\n");
   }//按层输出
   return 0;
}
```



---

## 作者：liswill (赞：0)

## 题意
给定一个完全二叉树的中序遍历，输出这个 $K$ 行的二叉树。

## 思路

既然其他题解大多用了递归的方法，我再分享一种找规律的方法。

注意：此题要掌握通法，找规律只是考试救急的方法！

首先，一段完全二叉树的根节点一定在中序遍历的最中间，输出换行。

这样，一个序列就被根结点分成了两部分，分别是左子树和右子树，可以用相同的方法找到最中间的那个数，就是这棵子树的根节点。

以此类推，直到叶子结点，结束。

如何找根节点？我们发现，输入数据：

```
3
1 6 4 3 5 2 7
```

输出数据：
```
3
6 2
1 4 5 7
```

「在此，定义 位置 为 下标+1 」

其根节点为 `3` ，在序列的第四位；
第二行的字节点为 `6` 、 `2` ，分别在序列的第二位，第六位；
叶子结点为 `1` 、 `4` 、 `5` 、 `7` 分别在序列的第一、三、五、七位。

不难发现，根节点所在的位置能够被 $2^{k-1}$ 整除；

子节点所在的位置能够被 $2^{k-2}$ 整除；

叶子节点所在的位置能够被 $2^{k-3}$ 整除；

所以，在二叉树的第 $n$ 层的数，就能被 $2^{k-n}$ 整除。


## Code

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)

using namespace std;

string s1,s2;

int a[10005];
bool vis[100005];//标记数组，防止重复。（解释见下）
int main()
{
    int k;cin>>k;
    int n=pow(2,k)-1;//所有节点个数（题目已给定）
    FOR(i,1,n)
    {
        cin>>a[i];
    }
    int cnt=0;
    for(int i=k;i>=0;i--)//2的幂次递减，「这里 k 控制的就是上文的 n 」
    {
        FOR(j,1,n)
        {
            if(j%(int(pow(2,i)))==0/*若是2的幂的倍数*/&&vis[j]==0/*且未被访问过*/)
            //由于根节点满足2^k,所以也满足2^(k-1),一定要标记，防止重复。
            {
                vis[j]=true;
                printf("%d ",a[j]);
            }
        }
        cnt++;
        if(cnt>1)   puts("");//k变化时，说明这一行的节点都已输出，换行。
    }
    return 0;
}
```

---

## 作者：fz20181223 (赞：0)

通过分析，这题就是给我们一颗满二叉树的中序遍历，让我们求这颗二叉树。

思路很简单。对于每个节点，照着题目所说的遍历就行了。

先遍历左子树，再标记当前节点，最后遍历右子树。

对于边界处理，我们只需判断当前深度是否达到 $k$ 。如果达到了就不再往下遍历。

在打印时我们可以发现换行时下标永远是 $2^x-1 (x \in \mathbb{N^*})$。

此时，观察其二进制，我们可以发现它的二进制是由 $x$ 个 $1$ 组成的，若将其加一，则变成了一个 $1$ 和 $x$ 个 $0$，此时用原来的数与新的数取与运算，我们可以发现结果就是 $0$ ，所以，对于一个数 $i$ ，如果 $i$ 与 $i+1$ 取与运算结果为 $0$ ，则说明我们需要换行。

另附：AC 代码（不要抄！）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int err=-120712^7869^12174,uerr=0x3f3f3f3f,eps=1e-9,K=12;
int k,seq[1<<K],ans[1<<K],cnt=1;
void dfs(int now,int dep){
	if(dep<k) dfs(now<<1,dep+1);
	ans[now]=seq[cnt++];
	if(dep<k) dfs(now<<1|1,dep+1);
}
int main(){
	scanf("%d",&k);
	for(int i=1;i<(1<<k);++i){
		scanf("%d",seq+i);
	}
	dfs(1,1);
	for(int i=1;i<(1<<k);++i){
		printf("%d ",ans[i]);
		if(!(i&i+1)) puts("");
	}
	return 0;}

```

---

## 作者：pxb0801 (赞：0)

## 1.题目大意：

这题描述这么多~~废话~~，充其量输入就是按照二叉树的中序遍历输入，当时看完我都懵了。至于这个题目中说的“完全二叉树”，再结合这个 $K$ 看一看，这不就是满二叉树嘛。

## 2.思路+代码分析

于是——这道题的输入就变得格外的~~奇葩~~：在 **dfs** 中输入，让我们来看看代码：

```cpp
void dfs(int dep,int id){
	if(dep>n) return;//边界返回条件：深度超过二叉树的深度
	dfs(dep+1,id*2);
	cin>>a[id];
	dfs(dep+1,id*2+1);//两次dfs中间夹输入，妥妥的中序遍历输入大法！
}
int main(){
	……
	dfs(1,1);
	……
}
```

这里的 $dep$ 表示当前到达的深度，很明显这里根节点的深度设定的是 $1$，而 $id$ 是读入的下标，大家发现**输入的位置**了吗？没错，正是夹在两个向下搜索儿子节点的 dfs 中的。

当我们的 dfs 执行完毕之后，$a$ 数组中的答案就已经全部按照输出的顺序排号了。但是输出每一层结束都需要换行，这里我用了一个小小的 lowbit 思想：每一个 $2$ 的整数次幂的 lowbit 都是自己本身。

所以：

```cpp
for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";
		if(((i+1)&(-(i+1)))==i+1) cout<<endl;
}
```
还有需要注意的是：& 的优先级比 == 还要小，所以需要打括号。

-----------

## 下课啦！

---


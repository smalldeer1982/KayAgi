# [COCI 2008/2009 #5] LUBENICA

## 题目描述

一个班有 $n$ 个孩子，他们上课时并没有认真听课，而是在玩 Facebook 社交网页上的扔西瓜游戏。

第一节课上，Goran 向他的每个朋友扔了一个西瓜，**随后几节课**，孩子们都会按照以下方式采取行动：

- 如果上节课一个人被奇数个西瓜扔中，那么这节课他会向所有他的朋友各扔一个西瓜。
- 如果上节课一个人被偶数（**包括 $0$**）个西瓜扔中，那么这节课他会向所有他的朋友各扔两个西瓜。

孩子们按照 $1\sim n$ 编号，其中 Goran 的编号为 $1$。

现在，给定孩子的个数 $n$ 和他们所有人的朋友关系，请求出 $h$ 节课之后，孩子们一共扔了多少个西瓜。

## 说明/提示

**【样例 1/2 解释】**

对于样例 $1/2$，首先，Goran 在第一节课上向第 $2$、$3$ 号孩子扔出一个西瓜，并且没有其他孩子扔出西瓜。因此，样例 $1$ 的答案为 $2$。  
第二节课上，第 $2$、$3$ 号孩子都向第 $1$、$4$ 号孩子各扔出一个西瓜，同时第 $1$、$4$ 号孩子由于在上一节课没有被西瓜扔中，因此他们都向第 $2$、$3$ 号孩子各扔出 $2$ 个西瓜。因此第二节课上一共扔出了 $2\times 2\times 1+2\times 2\times 2=12$ 个西瓜。

因此，前两节课一共扔出了 $2+12=14$ 个西瓜，而这就是样例 $2$ 的答案。

**【数据范围】**

对于 $50\%$ 的数据，满足 $h\leqslant 1000$。  
对于所有数据，$1\leqslant n\leqslant 20$，$1\leqslant h\leqslant 10^9$。

**【题目来源】**

本题来源自 **_[COCI 2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST 5](https://hsin.hr/coci/archive/2008_2009/contest5_tasks.pdf) T4 LUBENICA_**，按照原题数据配置，满分 $100$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 1
0110
1001
1001
0110```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2
0110
1001
1001
0110```

### 输出

```
14```

## 样例 #3

### 输入

```
5 3
01000
10110
01000
01001
00010 ```

### 输出

```
26```

# 题解

## 作者：YangHHao (赞：4)

### 题目描述（摘自原题）

一个班有 $n$ 个孩子，他们上课时并没有认真听课，而是在玩 Facebook 社交网页上的扔西瓜游戏。

第一节课上，Goran 向他的每个朋友扔了一个西瓜，**随后几节课**，孩子们都会按照以下方式采取行动：

如果上节课一个人被奇数个西瓜扔中，那么这节课他会向所有他的朋友各扔一个西瓜。
如果上节课一个人被偶数（**包括** $0$）个西瓜扔中，那么这节课他会向所有他的朋友各扔两个西瓜。
孩子们按照 $1\sim n$ 编号，其中 Goran 的编号为 $1$。

现在，给定孩子的个数 $1$ 和他们所有人的朋友关系，请求出 $1$ 节课之后，孩子们一共扔了多少个西瓜。

#### 数据范围
对于所有数据，$1\leqslant n\leqslant 20$，$1\leqslant h\leqslant 10^9$。

### 思路

观察到： $n$ 的范围很小，同时一节课上每个人的贡献（丢出的西瓜数）只和其上节课被扔的西瓜数有关。

考虑使用 bitset，这样每个人每节课只需要一次与操作即可，成功将时间复杂度从 $O(T\cdot n^2)$ 降为 $O(T \cdot n)$。

但是不管再怎么削减计算复杂度，$h$ 的 $10^9$ 数量级还是太大了。怎么办呢？

一张丑丑的图 ![](https://cdn.luogu.com.cn/upload/image_hosting/vsxaa8rc.png)

观察到，在一定节课以后，必定会出现一段循环。图中就体现为第三节课以后都受偶数西瓜。这是因为每次的情况只与上一次有关，且情况最多只有 $2^n$ 种。

再回头看 $n$ 的范围，应该就能知道 $h$ 的处理方法：

计算出第一次循环的开始和结束，给 $h$ 掐掉头以后做除法即可

时间复杂度 $O(n \cdot 2^n)$，实现起来很快，你谷上 AC 记录的总时间此题解发表时都在 100 ms 以内

下面是代码，如果具体实现有问题可以看注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long  //麻麻再也不用担心我忘记开long long了！ 
#define rep(i,s,t) for(int i=(s);i<=(t);++i)
#define irep(i,t,s) for(int i=(t);i>=(s);--i)
const int N=21;
int n,h,val[1<<N],cnt[N];     //val数组记录每回合答案（的前缀和），cnt数组记录朋友数（用以计算贡献） 
bitset<20> gt[1<<N],fnd[N];   //gt（get）数组记录一节课上每个人被丢西瓜的奇偶，fnd（friend）记录一个人的朋友 
map<int,int>used;  // used数组记录一种排列上次出现的位置 
signed main(){
	cin>>n>>h;
	rep(i,0,n-1){
		rep(j,0,n-1){
			char c=getchar();
			while(c<'0'||c>'1')c=getchar();
			fnd[i][j]=c-'0';
		}
		cnt[i]=fnd[i].count();
	}
	val[0]=cnt[0];  //初始一节课的情况 
	gt[0]=1;
	int k=0;
	for(k=1;k<=(1<<n)+10;++k){
		rep(i,0,n-1){
			gt[k][i]=(fnd[i]&gt[k-1]).count()&1;
			val[k]+=cnt[i]*(2-gt[k][i]);
		}
		if(used.count(gt[k].to_ulong()))break;  
		used[gt[k].to_ulong()]=k;    //记录次情况出现的课节
		//to_ulong是将bitset转为整型的函数，方便放入map中排序，就不用打比较函数了 
	}
	int ans=0,st=used[gt[k].to_ulong()];
	rep(i,1,(1<<n)+10){
		val[i]+=val[i-1]; //计算前缀和 
	} 
	if(h<=st){  //如果没有进入循环
		cout<<val[h-1]<<'\n';
	}
	else{  //否则
		h-=st;
		ans+=val[st-1];
		ans+=h/(k-st)*(val[k-1]-val[st-1]);
		ans+=val[h%(k-st)+st-1]-val[st-1];
		cout<<ans<<'\n';
	}
}


```


---

## 作者：zxh_qwq (赞：2)

容易发现，发现下一次的扔瓜次数只和当前每个人被扔的次数奇偶有关，也就是 `i&1==0`或`i&1==1`。找到环后就求答案。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll MAXN = 21;
ll ans,p[1<<MAXN],k,n,h,a[114],a1[51],head[419],tot,f[1<<MAXN];
bool v[198],v1[100];

struct node{
	ll to,next;
}b[100];

void add(ll x, ll y) {
	b[++tot]=(node){y,head[x]};
	head[x]=tot;
}

int main() {
	cin>>n>>h;
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=n;j++){
			ll x;
			char c;
			cin>>c;
			x=c-48;
			if(x)add(i,j);
		}
	bool flag=0;
	--h;
	for(ll i=head[1];i;i=b[i].next) {
		ll y=b[i].to;
		a[y]=1,ans++;
	}
	if(!h)return cout<<ans,0;
	p[1]=ans;
	ll s=0,g=1,q=0;
	k=ans;
	while(1){
		g++;
		s=0;
		for(ll i=1;i<=n;i++){
			for(ll j=head[i];j;j=b[j].next) {
				ll y=b[j].to;
				if(a[i]%2==1)a1[y]+=1;
				else a1[y]+=2;
			}
		}
		for(ll i=1;i<=n;i++)
			a[i]=a1[i],k+=a1[i],a1[i] = 0;
		p[g]=k;
		for(ll i=1;i<=n;i++)
			if(a[i]%2==1)s=s^(1<<i-1);
		if(f[s]){q=f[s];break;}
		f[s]=g;
	}
	if(!h)return cout<<p[g],0; 
	else cout<<(h-q+1)/(g-q)*(p[g]-p[q])+p[q]+p[q+(h-q+1)%(g-q)]-p[q];
	return 0;
}
```

---

## 作者：xiaolu12356 (赞：1)

[P7681 [COCI2008-2009#5] LUBENICA](https://www.luogu.com.cn/problem/P7681)

## 思路

我们发现下一次的灌水次数只和当前每个人被灌的奇偶有关，也就是 $0$ 和 $1$。那我们就直接用状压，直到找到环后就求答案。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#define ll long long

using namespace std;

const ll MAXN = 21;

ll ans, p[1 << MAXN], k;

ll n, h;
ll a[MAXN], a1[MAXN];
ll head[MAXN], tot, f[1 << MAXN];

bool v[MAXN], v1[MAXN];

struct node {
	ll to, next;
}b[MAXN * 4];

void add(ll x, ll y) {
	b[++tot] = (node){ y, head[x] };
	head[x] = tot;
}

int main() {
	scanf("%lld%lld", &n, &h);
	for(ll i = 1; i <= n; i ++)
		for(ll j = 1; j <= n; j ++) {
			ll x;
			scanf("%1lld", &x);
			if(x) add(i, j);
		}
	bool flag = 0;
	h --;
	for(ll i = head[1]; i; i = b[i].next) {
		ll y = b[i].to;
		a[y] = 1, ans ++;
	}
	if(!h) { printf("%lld", ans); return 0; }
	p[1] = ans;
	ll s = 0, g = 1, q = 0;
	k = ans;
	while(1) {
		g ++;
		s = 0;
		for(ll i = 1; i <= n; i ++) {
			for(ll j = head[i]; j; j = b[j].next) {
				ll y = b[j].to;
				if(a[i] % 2 == 1) a1[y] += 1;
				else a1[y] += 2;
			}
		}
		for(ll i = 1; i <= n; i ++)
			a[i] = a1[i], k += a1[i], a1[i] = 0;
		p[g] = k;
		for(ll i = 1; i <= n; i ++)
			if(a[i] % 2 == 1) s = s ^ (1 << i - 1);
		if(f[s]) { q = f[s]; break; }
		f[s] = g;
	}
	if(!h) { printf("%lld", p[g]); return 0; }
	else printf("%lld", (h - q + 1) / (g - q) * (p[g] - p[q]) + p[q] + p[q + (h - q + 1) % (g - q)] - p[q]);
	return 0;
}

```

---


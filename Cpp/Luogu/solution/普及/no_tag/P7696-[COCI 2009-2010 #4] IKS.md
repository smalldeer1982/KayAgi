# [COCI 2009/2010 #4] IKS

## 题目背景

Mirko 的伟大的曾祖母 Katica 是一位狂热的数学家，她喜欢用数学游戏折磨她的曾孙。

## 题目描述

这一天，她在一张纸上写下了一个 $n$ 个数字的序列，并告知 Mirko 可以做如下操作若干次：

- 选取序列中的两个数字（我们不妨称之为 $A,B$），然后选取能整除 $A$ 的质数 $X$。之后，Mirko 把 $A$ 擦去并在原来的位置上写下 $\frac AX$，然后他把 $B$ 擦去并在原来的位置上写下 $B\times X$。

Mirko 希望得到最大分数，因为这样他可以从他的曾祖母那里得到糖果。一个包含 $n$ 个数字的序列的分数是**这 $n$ 个数字的最大公因数**。

Mirko 并不擅长这个，但又很想希望得到糖果，因此找到了你，希望你能编写一个程序计算最大的可能分数，同时他也希望你能够得出在得到最大可能的分数的前提下最少应当执行的操作数。

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，Mirko 可以选择序列中的 $4$ 和 $1$ 两个数，并选择 $4$ 的唯一质因子 $2$。之后 Mirko 将 $4$ 和 $1$ 擦去，并在它们原来所在的位置上都写下了 $2$，这样这个序列的分数是 $2$。可以证明这样的方案可以获得最大的分数并且在此前提下操作数最少。

**【数据范围】**

对于所有数据，$1\leqslant n\leqslant 100$，序列中的元素不超过 $10^6$。

**【题目来源】**

本题来源自 **_[COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST 4](https://hsin.hr/coci/archive/2009_2010/contest4_tasks.pdf) T3 IKS_**，按照原题数据配置，满分 $70$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3
4 4 1```

### 输出

```
2 1```

## 样例 #2

### 输入

```
3
8 24 9```

### 输出

```
12 3```

## 样例 #3

### 输入

```
5
4 5 6 7 8```

### 输出

```
2 2```

# 题解

## 作者：LMB_002 (赞：7)

~~这是蒟蒻写的第一篇题解~~

[题目传送门](https://www.luogu.com.cn/problem/P7696)

## 一、简述题意
------------
给定有 $n$ 个正整数的数列 $a$ 。

每次操作可以从中选定两个正整数 $a_i$ 和 $a_j$ 。

在能除尽的情况下，将 $a_i$ 和 $a_j$ 的其中一个乘上一个质数 $p$ ，另外一个除以同一个质数 $p$ 。

求解：经过若干次操作之后，所得到的数列 $a'$ 中所有数的最大公因数最大是多少？使得最大公因数最大的操作次数最少是多少？

## 二、思路分析
------------
考虑先将每一个数分解质因数，把所有的质因数的指数和记录在一个数组里。再枚举每个数，取他们的指数的平均数。答案是他们的每个幂的和与平均数与指数的差的和。

## 三、代码实现
------------
上代码！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[105],d[1000005],maxn,ans1=1,ans2;
int main() {
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		long long p=a[i];
		for(long long j=2;j*j<=p;j++){
			while(p%j==0){
				p/=j;
				d[j]++;
			}
		}if(p) d[p]++;
		maxn=max(maxn,a[i]);//质因数分解
	}
	for(long long i=2;i<=maxn;i++){
		long long p=d[i]/n,k=0;
		ans1*=pow(i,p);
		if(p){//能判断成功的数一定是质数
			for(long long j=1;j<=n;j++){
				long long c=0;
				while(a[j]%i==0){
					a[j]/=i;
					c++;
				}
				if(c<p) k+=p-c;
			}ans2+=k;
		}
	}printf("%lld %lld",ans1,ans2);
	return 0;
}

```


---

## 作者：yydfj (赞：7)

**这是本蒟蒻第十七次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个正整数 $n$ 和含有 $n$ 个数的数组 $a$ 并进行操作：取一个质数 $x$ 使得 $\frac{a[i]}{x}$ 为整数，将 $a[i]$ 除以 $x$ 并将 $a[i]$ 乘上 $x$。

经过多次操作使得数组 $a$ 里的数的最大公因数最大，求出该最大公因数并算出得到该数的最少操作次数。

## 解法综述

由取质数 $x$ 进行操作和求最大公因数可知解决该题一定要求质数和分解因数，然后分开考虑题目问的问题。

- 预处理求质数：由数组 $a$ 中的数不超过 $10^{6}$ 可知我们只需要求出 $10^{6}$ 以内的质数并将这些质数存入数组 $zs$ 中。

- 求最大的最大公因数：我们将数组 $a$ 里的数因数分解，用数组 $ys$ 存储得到数组 $a$ 所有数的各个因数的个数（保证分解的因数都是质数），其中 $ys[i]$ 表示第 $i$ 个质数的个数。

  得出数组 $ys$ 的所有信息后，即可求出最大的最大公因数了。用 $s$（$s$ 初始为 $1$）累乘 $zs[i]^{ys[i]/n}$，而 $s$ 就是我们要的最大的最大公因数，其中 $zs[i]^{ys[i]/n}$ 表示用 $n$ 均分 $ys[i]$ 个质数 $zs[i]$ 相乘的积。
  
- 求最少操作次数：我们将数组 $a$ 里的数因数分解，得出 $a[i]$ 的各个因数的个数，与 $s$ 的各个因数的个数相比较，若 $a[i]$ 的一个因数的个数小于 $s$ 对应的因数的个数，则 $a[i]$ 的该因数需要操作。

## 代码描述
```cpp
#include<cmath>
#include<cstdio>
int n,cnt;
double a[105];
long long s=1,s1;
int bz[1000005],zs[1000005];
void pdzs(int x)//判断质数
{
	for(int i=2;i<=x;i++)
	if(!bz[i])
	{
		zs[++cnt]=i;
		for(int j=1;i*j<=x;j++) bz[i*j]=1;
	}
	return;
}
int ys[1000005];
void fjys(int x,int t)//分解因数
{
	for(int i=1;zs[i]<=x;i++)
	while(x%zs[i]==0)
	{
		x/=zs[i];
		ys[i]+=t;
	}
	return;
}
int main()
{
	pdzs(1000000);//预处理求1000000以内的质数
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
		fjys((int)a[i],1);//将a[i]因数分解
	}
	for(int i=1;i<=cnt;i++)
	{
		if(ys[i]/n!=0) s=s*pow(zs[i],ys[i]/n);//求最大的最大公因数
		if(ys[i]!=0) ys[i]=0;
	}
	printf("%lld ",s);
	for(int i=1;i<=n;i++)
	if(a[i]!=s)//若a[i]与s相等，则a[i]不需要进行任何操作
	{
		fjys((int)a[i],1);//将a[i]因数分解
		fjys(s,-1);//将s因数分解
		for(int j=1;j<=cnt;j++)
		if(ys[j]!=0)
		{
			if(ys[j]<0) s1-=ys[j];
			//ys[j]既是a[i]的因数zs[j]的个数与$s$对应的因数的个数的差，也是需要操作的次数的相反数
			ys[j]=0;
		}
	}
	printf("%lld",s1);
	return 0;
}
```

---

## 作者：DengDuck (赞：4)

首先，操作相当于把自己的质因数给别人，我们先求出第一问的答案，再用这个答案求第二问。

其实，不如先把这些数乘起来，再平均分配，能保证最大。


第二问直接累加各个数字和平均数少了多少质因数即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100005],sum[1000005],ss[1000005],b[1000005],ans=1,cnt;
int main()
{
    cin>>n;
    b[1]=1;
    for(int i=2;i<=1000000;i++)
    {
        if(!b[i])
        {
            ss[++ss[0]]=i;
            for(int j=2*i;j<=1000000;j+=i)
            {
                b[j]=1;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int k=a[i];
        for(int j=1;j<=ss[0];j++)
        {
            while(k%ss[j]==0)
            {
                sum[j]++;
                k/=ss[j];
            }
        }
    }
    for(int i=1;i<=ss[0];i++)
    {
        for(int j=n;j<=sum[i];j+=n)
        {
            ans*=ss[i];
        }
    }
    cout<<ans<<' ';
    memset(sum,0,sizeof(sum));
    int k=ans;
    for(int j=1;j<=ss[0];j++)
    {
        while(k%ss[j]==0)
        {
            sum[j]++;
            k/=ss[j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        int k=a[i],x;
        for(int j=1;j<=ss[0];j++)
        {
            x=0;
            while(k%ss[j]==0)
            {
                x++;
                k/=ss[j];
            }
            if(x<sum[j])
            {
                cnt+=sum[j]-x;
            }
        }
    }
    cout<<cnt;
    return 0;
}
```

---

## 作者：SoundOfDestiny (赞：3)

~~随机跳题来的~~

## 一、题意理解

简单来说就是一个数列经过一定次操作使其最大公约数最大，并求最少的操作次数。

一次操作：若 $x$ 为 $a_i$ 的一个因数，则可将 $a_i$ 改为 $\dfrac {a_i} {x}$ 并将 $a_j$ 改为 $x \cdot a_j$。

## 二、思路分析

### 最大公约数

因为每次操作都除以了一个 $x$ 又乘以了一个 $x$，所以每次操作整个序列的乘积不变，所以我们只要对这个乘积进行质因数分解，如果分解后**某一个质数的个数多于 $k \cdot n$ 个**，即每一个 $a_i$ 都能分到 $k$ 个该质数，那么整个数列的最大公约数就能取到最大值，记为 $ans$。

### 操作次数

对于一个 $a_i$，若 $\gcd(a_i, ans) \neq ans$（即 $ans$ 不为 $a_i$ 的因数），每次操作就可以使 $a_i$ 与 $ans$ 的最大公约数接近一个质数，所以我们**只要求出 $\dfrac {ans} {\gcd(a_i, ans)}$ 的质因数个数的和**。

## 三、代码实现

### 预处理-筛法求素数

其实也可以不预处理，但是显然，预处理素数后代码会更快，这里素数存在 $prim$ 数组中。

 _部分代码见下_ 

```cpp
for(int i = 2; i <= MAX; i++){ //标准筛法
	if(flag[i]) continue;
	flag[i] = true, prim[++pcnt] = i;
	for(int j = 2 * i; j <= MAX; j += i) flag[j] = true;
}
```

### 最大公约数

显然，将所有 $a_i$ 乘起来再进行质因数分解是非常不现实的，因为这个数字有可能达到 ${10}^{600}$ 显然超过了 unsinged long long 的上限，于是我们就想到了对于每一个 $a_i$ 都进行质因数分解，并将质数的个数统一存在一个 $cnt$ 数组里，最后再统计所有 ${prim_i}^{\lfloor cnt_i / n \rfloor}$ 的和即可。

 _部分代码见下_ 

```cpp
for(int i = 1; i <= n; i++){
	scanf("%d", &a[i]); //读入
	int tmp = a[i]; //防止a[i]被改变
	for(int j = 1; j <= pcnt && tmp != 1; j++) //枚举所有质数，若能整除就除，直到只剩1
		while(tmp % prim[j] == 0) tmp /= prim[j], cnt[j]++; //过程中每除掉一个就记录一次
}
for(int i = 1; i <= pcnt; i++)
	ans *= pow(prim[i], cnt[i] / n); //如上
```

### 操作次数

此时，我们已经拥有了 $ans$，就可以开始求操作次数了，这里记为 $anscnt$，然后就可以直接写代码了。

 _部分代码见下_ 

```cpp
for(int i = 1; i <= n; i++){
	int tmp = gcd(ans, a[i]);
	if(tmp == ans) continue;
	tmp = ans / tmp; //tmp表示gcd(ans, a[i])想要变成ans还需要乘多少 
	for(int j = 1; j <= pcnt && tmp != 1; j++)
		while(tmp % prim[j] == 0) tmp /= prim[j], anscnt++;
}
```

## 四、AC CODE

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int NR = 105, MR = 1e6 + 10;

int n, pcnt, anscnt, ans = 1;
bool flag[MR];
int a[NR];
int prim[MR], cnt[MR];

void init(int MAX){
	for(int i = 2; i <= MAX; i++){ //标准筛法 
		if(flag[i]) continue;
		flag[i] = true, prim[++pcnt] = i;
		for(int j = 2 * i; j <= MAX; j += i) flag[j] = true;
	}
}
int gcd(int x, int y){ //不标准求最大公约数 
	while(y ^= x ^= y ^= x %= y);
	return x;
}
int pow(int x, int p){ //标准快速幂 
	if(p == 0) return 1;
	int ans = 1;
	while(p){
		if(p & 1) ans *= x;
		x *= x;
		p >>= 1;
	}
	return ans;
}

int main(){
	init(1e6); //素数预处理
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d", &a[i]); //读入
		int tmp = a[i]; //防止a[i]被改变 
		for(int j = 1; j <= pcnt && tmp != 1; j++) //枚举所有质数，若能整除就除，直到只剩1
			while(tmp % prim[j] == 0) tmp /= prim[j], cnt[j]++; //过程中每除掉一个就记录一次
	}
	for(int i = 1; i <= pcnt; i++)
		ans *= pow(prim[i], cnt[i] / n);
	for(int i = 1; i <= n; i++){
		int tmp = gcd(ans, a[i]);
		if(tmp == ans) continue;
		tmp = ans / tmp; //tmp表示gcd(ans, a[i])想要变成ans还需要乘多少 
		for(int j = 1; j <= pcnt && tmp != 1; j++)
			while(tmp % prim[j] == 0) tmp /= prim[j], anscnt++;
	}
	printf("%d %d\n", ans, anscnt);
}
```


---

## 作者：_Trangle_ (赞：1)

这道题要求我们将一个序列经过若干次修改，将其最大公因数最大化，然后求将该序列最大公因数最大化时最少的操作数。

### Q1：
其实操作并不会改变序列总积，因为 $\dfrac{A}{X}\times BX=AB$。

根据小学知识，可得

$a_1={p_1}^{c_{1,1}}\times {p_2}^{c_{1,2}}\times\cdots\times {p_m}^{c_{1,m}}$

$a_2={p_1}^{c_{2,1}}\times {p_2}^{c_{2,2}}\times\cdots\times {p_m}^{c_{2,m}}$

$\cdots$

$a_n={p_1}^{c_{n,1}}\times {p_2}^{c_{n,2}}\times\cdots\times {p_m}^{c_{n,m}}$

其中 $p$ 数组为 $a$ 数组里头所有元素的质因数集合的并集，而 $c$ 数组是指数（可以为 $0$）。

则 $\gcd(a_1,a_2\cdots,a_n)=p_1^{\min\{{ c_{1,1},c_{1,2}}\cdots,c_{1,m}\}}\times p_2^{\min\{{c_{2,1},c_{2,2}}\cdots,c_{2,m}\}}\times\cdots\times p_m^{\min\{{c_{n,1},c_{n,2}}\cdots,c_{n,m}\}}$。

而序列总积不变，操作其实是将 $c_i$ 数组的某一个元素减一，另一个该列的元素加一，所以我们尽量让 $\min\{{c_{i,1},c_{i,2}}\cdots,c_{i,m}\}$ 大，最大值为 $\sum\limits_{j=1}^mc_{i,j}/n$，为了表示方便，将记为 $M_i$。

然后用小学教的求最大公因数的方法就好了。

### Q2:
Q1 解决了，Q2 就好办了，其实就是若 $c_{i,j}<M_i$ 则答案加 $M_i-c_{i,j}$ 就好了

### 上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

unordered_map<int, int> mulset, res;
unordered_map<int, int> aset[105];
int n, ans = 1, change;

unordered_map<int, int> factor(int x) {
	unordered_map<int, int> ans(0);

	for (int i = 2; i * i <= x; i++)
		while (x % i == 0) {
			ans[i]++;
			x /= i;
		}
	if (x > 1) ans[x]++;

	return ans;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	cin >> n;

	for (int i = 1, x; i <= n; i++) {
		cin >> x;
		aset[i] = factor(x);
		for (auto it: aset[i]) mulset[it.first] += it.second;
	}

	for (auto i: mulset) {
		for (int a = i.first, b = i.second / n; b; b >>= 1) {
			if (b&1) ans *= a;
			a *= a;
		}

		res[i.first] = i.second / n;
	}

	for (int i = 1; i <= n; i++)
		for (auto it: res)
			if (aset[i][it.first] < it.second)
				change += it.second - aset[i][it.first];

	cout << ans << ' ' << change;
	return 0;
}
```

---

## 作者：WisNourx_ (赞：1)

## 题意
有一个序列，求这个序列的最大公因数，以及经过多少次操作后可以使序列的公因数最大。

## 思路
看到题面让我们求最大公因数，容易想到对序列中每个数进行质因数分解。

对于每个数，如果有一个质因子的个数超过或等于 $n$ 的话，意味着可以把这个质因子从这个数中拿出去给别的所有数，也就是题面上的"操作"。

记分解的质因子为 $p_i$，它的出现次数为 $cnt_i$。

不难想到，这个序列的最大公因数是 $cnt_i \ge n$ 的 $p_i$ 的 ${ \lfloor \frac{cnt_i}{n}  \rfloor}$ 次方的乘积。

举个例子：

```
3
8 24 9
```

$\quad$

可分解为：$2^3$，$2^3 \times 3$ 和 $3^2$

$2$ 出现了 $6$ 次，$3$ 出现了 $3$ 次，最大公因数为 $2^{\lfloor \frac{6}{3} \rfloor} \times 3^{\lfloor\frac{3}{3} \rfloor} = 12$。

求出了最大公因数，我们来思考最少操作次数。

要使序列的公因数最大，那么每个数的质因数的出现次数都应与最大公因数的质因数出现次数一致。

由此，我们得到一个求法：记录每个数分解的 $p_j$ 的出现次数 $cnt_j$，比较 $cnt_j$ 与最大公因数中的差异，进行累加。

具体实现可以参考代码：
```
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;

const int N=1e2+10, M=1e6+10;

int n, m, a[N];
int cnt[M], sum[M];
int prime[M], pr;bool v[M];
int b[M];

void fj(int x)
{
	for (int i=1;prime[i]<=x;i++)
	{
		if (x%prime[i]==0)
		{
			while (x%prime[i]==0)
			{
				x/=prime[i];
				cnt[i]++;
			}
		}
	}
}

void init()
{
	for (int i=2;i<=M;i++)	
	{
		if (!v[i]) v[i]=1, prime[++pr]=i;
		for (int j=1;j<=pr&&(i*prime[j])<=M;j++)
		{
			v[i*prime[j]]=1;
			if (i%prime[j]==0) break;
		}
	}
}

int main()
{
	scanf("%d", &n);
	init();int maxx=-1;
	for (int i=1;i<=n;i++) 
	{
		scanf("%d", &a[i]);
		fj(a[i]);maxx=max(maxx, a[i]);
	}
	int ans=1;
	for (int i=1;i<=pr&&prime[i]<=maxx;i++)
	{
		for (int j=1;j<=cnt[i]/n;j++)
			ans*=prime[i], b[i]=cnt[i]/n;
	}
	printf("%d ", ans);
	int res=0;
	for (int i=1;i<=n;i++)
	{
		if (a[i]!=ans)
		{
			memset(cnt, 0, sizeof cnt);
			fj(a[i]);
			for (int j=1;j<=pr&&prime[j]<=maxx;j++) 
				if (cnt[j]!=b[j]&&cnt[j]<b[j]) res+=b[j]-cnt[j];//比较并累加
		}
	}
	printf("%d", res);
	return 0;
}
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7696)

简单的数论题。

### 题意：

从序列 $a$ 中选取一个元素，将其一个质因数分配到这个序列的另一个元素，在执行操作次数最小的情况下使得该序列每个元素的公因数最大。

### 思路：

先把序列中的每一个元素质因数分解，再将每个质因子及其出现的次数存放到一个数组中。再平均分配给这个序列中的每一个元素，这时最大公因数就会乘上这个质因子。再遍历这个序列，如果不能整除这个质因子，即需要分配给这个数，操作数就加 $1$，如果能整除，就除以它，相对来说就是没有贡献了。

没什么好讲的，也没有数学公式，就看代码吧。

### 贴贴代码

```cpp
#include <bits/stdc++.h>
#define ll int
#define Max 1008624
using namespace std;
ll n,a[Max],b[Max],ans1=1,ans2,sum,num;
inline void PF(ll x){
	for(ll i=2;i<=x;i++)
		while(x%i==0) x/=i,b[i]++;
} // 分解质因数
int main(){
	scanf("%d",&n);
	for(ll i=1;i<=n;i++)
		scanf("%d",&a[i]),PF(a[i]); 
	for(ll i=2;i<=Max-2;i++)
		if(b[i]/n>=1){
			ans1*=pow(i,b[i]/n);sum=0; // 更新最大公因数 
			for(ll k=1;k<=b[i]/n;k++)
				for(ll j=1;j<=n;j++)
					if(a[j]%i!=0) sum++;
					else a[j]/=i;
			ans2+=sum; // 如题解所说 
		}	
	printf("%d %d",ans1,ans2);
	return 0;
}
```


---


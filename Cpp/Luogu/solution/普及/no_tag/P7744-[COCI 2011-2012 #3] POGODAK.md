# [COCI 2011/2012 #3] POGODAK

## 题目背景

Mirko 不喜欢拉丁文作业，所以他和 Slavko 打了个赌。输的人将在整个月内写他们两个人的作业。Mirko 想赢，所以他设计了这个问题用来打赌。

## 题目描述

在他的桌子上，他发现了一个立方体，如图中所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/csekseld.png)

在这个立方体中，两个对立面的点数之和等于 $7$。这意味着，$6$ 在 $1$ 的对面，$5$ 在 $2$ 的对面，$4$ 在 $3$ 的对面。Mirko 将立方体放在了一个 $r\times c$ 的矩阵的左上方，最初立方体的方向是上侧显示 $1$，右侧显示 $3$。Mirko 现在依次重复以下动作：

1. 向右滚动立方体，直到它到达最后一列；
2. 向下滚动到下一行；
3. 向左滚动立方体，直到它到达第一列；
4. 像第二步一样，向下滚动到下一行。

Mirko 不停地重复这些步骤，直到立方体不能够再滚动为止。当一个立方体到达某一格时，Mirko 在这个格子中写下立方体的顶部的数字。最后他把他写的所有数字加起来。Mirko 与 Slavko 打了个赌，赌他能毫无差错地算出这个和。帮助 Slavko 算出这个和以验证 Mirko 的答案。 

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，最终矩阵里面填入的数字如下所示：

| $1$ | $4$ |
| :----------: | :----------: |
| $1$ | $5$ |
| $3$ | $5$ |

因此最终的和为 $1+4+1+5+3+5=19$。

**【数据范围】**

对于 $50\%$ 的数据，满足 $r,c\leqslant 100$。  
对于所有数据，$1\leqslant r,c\leqslant 10^5$。

**【题目来源】**

本题来源自 **_[COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST 3](https://hsin.hr/coci/archive/2011_2012/contest3_tasks.pdf) T3 POGODAK_**，按照原题数据配置，满分 $100$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3 2```

### 输出

```
19```

## 样例 #2

### 输入

```
3 4```

### 输出

```
42```

## 样例 #3

### 输入

```
737 296```

### 输出

```
763532```

# 题解

## 作者：MassPoint (赞：5)

### 思路

首先考虑暴力，很显然可以手动模拟每一次翻滚，时间复杂度 $O(rc)$，显然不能通过。

考虑优化骰子横向滚动的情况。

很显然，骰子向一个方向滚过四次以后将会回到原来的状态，因此有 $c - c \bmod 4$ 次滚动可以 $O(1)$ 解决。

至于后面的 $c \bmod 4$ 次滚动，直接模拟即可。

至此，我们已经成功地把原本 $O(rc)$ 的代码优化至 $O(r)$，可以 AC 此题了！

Tip：注意到题目中 $r \times c$ 已经超过 $2^{32}-1$ 了，所以要开 `long long`。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,u=1,f=2,r=3,op=1;
long long ans;
void solve(int tp,int len){
	ans+=(len/4)*14;	//批量解决大部分滚动
	len%=4;
	for(int i=1,tmp;i<=len;i++){	//模拟剩下的滚动
		if(tp==1){	//如果是向左滚
			tmp=7-r;
			r=u;
			u=tmp;
		}
		else{	//否则一定是向右滚
			tmp=7-u;
			u=r;
			r=tmp;
		}
		ans+=u;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,tmp;i<=n;i++){
		ans+=u;
		solve(op,m-1);	//注意到上一行已经走了一步了，所以这里是 m-1
		tmp=7-f;f=u;u=tmp;	//模拟骰子向下滚动
		op*=-1;	//换方向
	}
	printf("%lld",ans);	 
	return 0;
}
```

---

## 作者：tzjahinie (赞：5)

题目大意:
骰子会先按照左走到底，下一行右走到底，下一行的循环，直到不能再行动。

如果按题意直接模拟，由 $O(rc)$ 的时间复杂度可知会超时，所以需要优化。

首先，可以考虑先优化 $c$。已知骰子两个对立面的点数之和等于 $7$，且骰子向一个方向走四格后，骰子状态不变。
所以可以得出以下式子：

$$sum= \lfloor \frac{c}{4} \rfloor \times 14 \times r$$

将 $c \bmod 4$ 后，$c$ 只有 $4$ 种可能。

1. $c=0$，此时已经走到底了。

2. $c=1$，此时可以看做骰子一直往下翻滚。运动轨迹下图。

可得部分代码：
~~~cpp
int a1[10]={0,1,5,6,2};
sum+=14*(r/4);r%=4;
for (int i=1;i<=r;i++){
	sum+=a1[i];
}
~~~

3. $ c=2 $，此时可以模拟一下骰子运行轨迹。运动轨迹下图。

不难模拟出走了六行以后，骰子与原来的状态一致，即此时六行为一个循环。由于骰子一定会走完一整行，所以可求出每行得点数和。可得部分代码：

~~~cpp
int a2[10]={0,5,6,8,9,8,6};
sum+=42*(r/6);
r%=6;
for (int i=1;i<=r;i++){
	sum+=a2[i];
}
~~~

4. $c=3$，此时可以模拟一下骰子运行轨迹。运动轨迹下图。

不难模拟出两行为一个循环，每行和为 $11$。
可得部分代码：

~~~cpp
sum+=r*11;
~~~

![](https://cdn.luogu.com.cn/upload/image_hosting/rntckwci.png)

代码部分：
~~~cpp
#include<bits/stdc++.h>
using namespace std;
long long r,c,sum;
int main(){
	scanf("%lld%lld",&r,&c);
	sum=r*14*(c/4);
	c%=4;
	if(c==1){
		int a1[10]={0,1,5,6,2};
		sum+=14*(r/4);
		r%=4;
		for (int i=1;i<=r;i++){
			sum+=a1[i];
		}
	}else if(c==2){
		int a2[10]={0,5,6,8,9,8,6};
		sum+=42*(r/6);
		r%=6;
		for (int i=1;i<=r;i++){
			sum+=a2[i];
		}
	}else if(c==3){
		sum+=r*11;
	}
	printf("%lld\n",sum);
}
~~~

---

## 作者：shihaocheng110909 (赞：4)

## 解法说明：

这道题如果暴力枚举每次翻滚后的点数，时间复杂度 $$O(rc)$$，肯定会超时。

所有我们要把时间给优化到 $$O(r)$$，我们可以这样想：

用一个三维数组 $$a[7][7][4]$$ 来表示一个状态，第一维表示顶上的数，第二维表示正向前的数，第三维表示在前两维的前提之下，向右转了几次。这样将所有情况记录下来，加一个小前缀和表示 $$a[i][j][0]$$ 到 $$a[i][j][k]$$ 的和，就可以严格将代码优化到 $$O(r)$$ 了，向左的情况也很好解决，处理 $$a[i][7-j][k]$$ 的相关信息就可以了。

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int r,c;
int w[7][7][4],s[7][7][4];
ll ans;
int main()
{
    cin>>r>>c;
    w[1][2][0]=1;
    w[1][2][1]=4;
    w[1][2][2]=6;
    w[1][2][3]=3;
    w[1][3][0]=1;
    w[1][3][1]=2;
    w[1][3][2]=6;
    w[1][3][3]=5;
    w[1][4][0]=1;
    w[1][4][1]=5;
    w[1][4][2]=6;
    w[1][4][3]=2;
    w[1][5][0]=1;
    w[1][5][1]=3;
    w[1][5][2]=6;
    w[1][5][3]=4;
    //1
    w[2][1][0]=2;
    w[2][1][1]=3;
    w[2][1][2]=5;
    w[2][1][3]=4;
    w[2][3][0]=2;
    w[2][3][1]=6;
    w[2][3][2]=5;
    w[2][3][3]=1;
    w[2][4][0]=2;
    w[2][4][1]=1;
    w[2][4][2]=5;
    w[2][4][3]=6;
    w[2][6][0]=2;
    w[2][6][1]=4;
    w[2][6][2]=5;
    w[2][6][3]=3;
    //2
    w[3][1][0]=3;
    w[3][1][1]=5;
    w[3][1][2]=4;
    w[3][1][3]=2;
    w[3][2][0]=3;
    w[3][2][1]=1;
    w[3][2][2]=4;
    w[3][2][3]=6;
    w[3][5][0]=3;
    w[3][5][1]=6;
    w[3][5][2]=4;
    w[3][5][3]=1;
    w[3][6][0]=3;
    w[3][6][1]=2;
    w[3][6][2]=4;
    w[3][6][3]=5;
    for(int i=4;i<=6;i++)
    {
        for(int j=1;j<=6;j++)
        {
            for(int k=0;k<=3;k++)
            {
                if(k<=1)w[i][j][k]=w[7-i][j][k+2];
                else w[i][j][k]=w[7-i][j][k-2];
            }
        }
    }
    for(int i=1;i<=6;i++)
    {
        for(int j=1;j<=6;j++)
        {
            for(int k=0;k<=3;k++)
            {
                s[i][j][k]=w[i][j][k]+s[i][j][max(k-1,0)];
                //cout<<s[i][j][k]<<' ';
            }
            //cout<<endl;
        }
    }
    int x=1,y=2;
    for(int i=1;i<=r;i++)
    {
        if(i&1)
        {
            ans+=(c-1)/4*s[x][y][3]+s[x][y][(c-1)%4];
            int u=7-y,v=w[x][y][(c-1)%4];
            x=u,y=v;
        }
        else
        {
            ans+=(c-1)/4*s[x][7-y][3]+s[x][7-y][(c-1)%4];
            int u=7-y,v=w[x][7-y][(c-1)%4];
            x=u,y=v;
        }
        //cout<<ans<<" "<<x<<" "<<y<<endl;
    }
    cout<<ans<<endl;
    return 0;
}

```
## 谢谢观看！

---

## 作者：QAQ_YTH (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P7744)


------------
显而易见，这是一道模拟题，如下不断更新六面的值。

```cpp
void north() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[2],QAQ_cube[2]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[5],QAQ_cube[5]=t;
}
void west() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[3],QAQ_cube[3]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[4],QAQ_cube[4]=t;
}
void east() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[4],QAQ_cube[4]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[3],QAQ_cube[3]=t;
}
void south() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[5],QAQ_cube[5]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[2],QAQ_cube[2]=t;
}
void right() {
	int t=QAQ_cube[2];
	QAQ_cube[2]=QAQ_cube[3],QAQ_cube[3]=QAQ_cube[5],QAQ_cube[5]=QAQ_cube[4],QAQ_cube[4]=t;
}
void left() {
	int t=QAQ_cube[2];
	QAQ_cube[2]=QAQ_cube[4],QAQ_cube[4]=QAQ_cube[5],QAQ_cube[5]=QAQ_cube[3],QAQ_cube[3]=t;
}

```
于是本人高高兴兴地打了一个暴力模拟方法，回头一看不太对。

$ 1 $ $\le$ $r,c$ $\le$ $10^5$

$10^{10}$  次操作会导致超时。

------------
那该怎么办呢？我们可以“压缩一下”它的滚动路径，把滚动 $4$ 次看作一个周期，利用这个性质优化。

于是，上 AC 代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long QAQ_cube[7]= {0,1,2,3,4,5,6},t=1,QAQ_YTH=0,r,c;
bool flag=0;
void north() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[2],QAQ_cube[2]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[5],QAQ_cube[5]=t;
}
void west() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[3],QAQ_cube[3]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[4],QAQ_cube[4]=t;
}
void east() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[4],QAQ_cube[4]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[3],QAQ_cube[3]=t;
}
void south() {
	int t=QAQ_cube[1];
	QAQ_cube[1]=QAQ_cube[5],QAQ_cube[5]=QAQ_cube[6],QAQ_cube[6]=QAQ_cube[2],QAQ_cube[2]=t;
}
void right() {
	int t=QAQ_cube[2];
	QAQ_cube[2]=QAQ_cube[3],QAQ_cube[3]=QAQ_cube[5],QAQ_cube[5]=QAQ_cube[4],QAQ_cube[4]=t;
}
void left() {
	int t=QAQ_cube[2];
	QAQ_cube[2]=QAQ_cube[4],QAQ_cube[4]=QAQ_cube[5],QAQ_cube[5]=QAQ_cube[3],QAQ_cube[3]=t;
}
long long mid() {
	return QAQ_cube[1] + QAQ_cube[6] + QAQ_cube[3] + QAQ_cube[4];
}
int main() {
	scanf("%lld%lld",&r,&c);
	if(c%4) {
		flag=1;
		QAQ_YTH=1;
	}
	for(long long x=1; x<=r; x++) {
		if(t&1) {
			long long round=c/4;
			QAQ_YTH+=mid()*round;
			if(flag) {
				round=c%4;
				for(long long i=1; i<round; i++)east(),QAQ_YTH+=QAQ_cube[1];
			}
		} else {
			long long round=c/4;
			QAQ_YTH+=mid()*round;
			if(flag) {
				round=c%4;
				for(long long i=1; i<round; i++)west(),QAQ_YTH+=QAQ_cube[1];
			}
		}
		south();
		if (x!=r && flag)QAQ_YTH+=QAQ_cube[1];
		t++;
	}
	printf("%lld\n",QAQ_YTH);
	return 0;
}
```

---

## 作者：yxy666 (赞：3)

笨蛋的模拟肯定能想通，就是一次一次地翻滚，模拟。但是会超时。

接下来我们分析一下横着走的情况。然后就会发现有规律，因为滚了四次以后又翻回了原状态。就可以快速地统计答案了。那么我们只需要枚举列的情况就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,A[10]={0,1,6,2,5,4,3};//A[1] up  A[2] down A[3] front A[4] behind  A[5] left A[6] right
int L[10]={0,1,5,2,6},R[10]={0,1,6,2,5};//L[i]表示从左往右还需翻i次的下标，R[i]表示从右向左还需要翻i次的下标
long long Ans;
int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	n=read();m=read();
	int yu,size,x;
	for(int i=1;i<=n;i++){
		if(i&1){//从左向右 
			size=m/4;//规律次数
			Ans+=(long long)(size*(A[1]+A[2]+A[5]+A[6]));//统计答案
			size=m%4;
			for(int j=1;j<=size;j++)Ans+=A[L[j]];//剩下的零头
			for(int j=1;j<size;j++)x=A[6],A[6]=A[1],A[1]=A[5],A[5]=A[2],A[2]=x;//把零头翻掉，注意，要少翻一次
		}
		else {//从左向右
			size=m/4;//规律次数
			Ans+=(long long)(size*(A[1]+A[6]+A[2]+A[5]));//统计答案
			size=m%4;
			for(int j=1;j<=size;j++)Ans+=A[R[j]];//剩下的零头
			for(int j=1;j<size;j++)x=A[6],A[6]=A[2],A[2]=A[5],A[5]=A[1],A[1]=x;//把零头翻掉，注意，要少翻一次
		}
		x=A[3],A[3]=A[1],A[1]=A[4],A[4]=A[2],A[2]=x;//向下翻
	}
	printf("%lld\n",Ans);
	return 0;
}
```


---

## 作者：Adam_123 (赞：2)

首先考虑暴力模拟骰子的状态。我们发现，骰子在某一个位置的状态只取决于在该位置骰子向上的面、向前的面、向右的面的点数。因此，我们只需要记录骰子这三个面的点数便可以模拟出骰子向左、向右、向下的滚动。但是，此方法时间复杂度为 $O(rc)$，在本题中会 TLE。

（具体地向左、向右、向下的滚动对骰子向上的面、向前的面、向右的面的点数的影响如下图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/54ugftfm.png)

考虑优化。由骰子的特点可知：当在不同时间骰子向上的面、向前的面、向右的面的点数全都相同，且滚动方向也相同时，这两次滚动本质相同。我们观察骰子的滚动还可以发现：骰子向右或向左滚动时，每连续滚动四次后，骰子向上的面、向前的面、向右的面的点数会与滚动前相同。因此，我们将骰子连续滚动 $c-1$ 次与将骰子连续滚动 $(c-1) \bmod 4$ 次本质相同。转化后再模拟骰子的滚动即可。

由于骰子相对的面点数之和为 $7$，所以骰子连续滚动四次时，每次滚动前向上的面点数之和为 $14$。由此我们可以快速计算连续滚动时骰子向上的面点数之和。

### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int r, c, up = 1, fr = 2, ri = 3, ans;
//记录骰子当前的上面、前面、右面点数以及答案 
inline void gri() { //向右滚动 
    int tmp = ri;
    ri = up;
    up = 7 - tmp;
}
inline void gle() { //向左滚动
    int tmp = up;
    up = ri;
    ri = 7 - tmp;
}
inline void gdw() { //向下滚动
    int tmp = fr;
    fr = up;
    up = 7 - tmp;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> r >> c;
    int gcnt = (c - 1) / 4, lst = (c - 1) % 4;
	//gcnt表示骰子滚动完全等价的周期数，lst表示滚动完全等价的周期后剩下的应该滚动的次数 
    for (int i = 1; i <= r; i++) {
        if (i % 2 == 1) { //奇数行向右滚动 
            ans += gcnt * 14; //统计滚动完全等价的周期时向上的面点数之和 
            for (int i = 1; i <= lst; i++) { 
			//统计滚动剩下的次数时向上的面点数之和 
                ans += up;
                gri();
            }
        } else { //偶数行向左滚动 
            ans += gcnt * 14;
            for (int i = 1; i <= lst; i++) {
                ans += up;
                gle();
            }
        }
        ans += up;
		//统计这一行最末端处骰子向上的面的点数，并向下滚动到下一行
		//最末端处指该行最后滚动到的位置 
        gdw();
    }
    cout << ans;
    return 0;
}

```

---

## 作者：Unnamed114514 (赞：2)

### 思路
首先，拿到题目，容易想到模拟，所以，先打出移动的代码，然后，按照题意一步步模拟即可，时间复杂度 $O(rc)$。
### 优化
以 $4$ 次旋转为一个周期，每次直接累加除前后两个面的和，剩下的余数可以直接打模拟，时间复杂度优化到 $O(r)$。

最后注意开 `long long`，否则只有 $50$ 分。
### AC Code:
```cpp
#include<bits/stdc++.h>
#define int long long//long long
using namespace std;
int a[]={0,1,2,3,4,5,6},ans,r,c,x=1,t=1;//t 存当前的操作是1 还是3，x 存列数，a 存每个位置的数
bool flag;
namespace pzj{
	int t;
	void E(){
	    t=a[1],a[1]=a[4],a[4]=a[6],a[6]=a[3],a[3]=t;
	}//向左走
	void W(){
	    t=a[1],a[1]=a[3],a[3]=a[6],a[6]=a[4],a[4]=t;
	}//向右走
	void S(){
	    t=a[1],a[1]=a[5],a[5]=a[6],a[6]=a[2],a[2]=t;
	}//向下走
	int m() {
	    return a[1]+a[6]+a[3]+a[4];
	}
}
signed main(){
	scanf("%lld%lld",&r,&c);
    if(c%4){
	 	flag=1;
		ans=1;
	}
    for(;x<=r;x++) {
        int round=c/4;
        ans+=pzj::m()*round;
        if(t&1){
            if(flag){
                round=c%4;
                for (int i=1;i<round;i++)
					pzj::E(),ans+=a[1];//一直往右滚
            }
        } else if(flag){
                round=c%4;
                for(int i=1;i<round;i++)
					pzj::W(),ans+=a[1];//一直往左滚
            }
        pzj::S();//向下走
        if(x!=r&&flag)
			ans+=a[1];//加上最顶端的数
        t++;//换操作
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Danny_chan (赞：1)

如果直接一次一次滚动模拟可能会超时，所以我们要考虑优化。不难发现，骰子横着走一直是四种状态，所以我们可以用滚动数组来模拟这四种状态，然后再模拟一下向下滚动，时间复杂度瞬间从 $O(rc)$ 降到了 $O(r)$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m;
int sum=0;
int a[4]={0,1,2,3};//走了一步，两步，三步 
int dir=1;//方向 
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int t;
		sum+=a[1];
		int k=m-1;
		sum+=k/4*14;
		k=k%4;
		for(int j=1;j<=k;j++){//模拟滚动 
			if(dir==0){ 
				t=7-a[1];
				a[1]=a[3];
				a[3]=t;
			}
			if(dir==1){
				t=7-a[3];
				a[3]=a[1];
				a[1]=t;
			}
			sum+=a[1];
		}
		t=7-a[2];//走到下一行 
		a[2]=a[1];
		a[1]=t;
		dir=dir^1;//换方向
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：tanghg (赞：1)

显然正确答案是要求枚举一行，然后直接求出每一列的情况的。发现维护一个骰子的上右前三面就可以快速求出每一次翻转的情况。然后发现有循环，$4$ 次为一组。每一次循环的和固定为 $14$。所以暴力维护 $c \bmod4$ 次右/左滚操作即可。

然后上下也一样。对于上右前三面的变换可以自己推。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll up=1,rt=3,ft=2,ans=0;
ll tr(){
    ll Up=7-rt;
    rt=up;
    up=Up;
    return up;
}
ll tl(){
    ll Up=rt;
    rt=7-up;
    up=Up;
    return up;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	ll r,c;
	cin>>r>>c;
	c--;
	for(int i=1;i<=r;++i){
		ll Ans=ans;
		ans+=up;
		ans+=14*(c/4);
		for(int j=1;j<=c%4;++j){
		    if(i&1){
		        ans+=tr();
		    }else{
		        ans+=tl();
		    }
		}
		ll Ft=ft;
		ft=up;
		up=7-Ft;
	}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：luobotianle (赞：0)

直接模拟的复杂度是 $O(rc)$ 的，显然会超时，考虑优化；

我们可以发现一个骰子翻滚了四次以后还会回到原状态，于是可以以 $4$ 为周期进行计算，将复杂度降至 $O(r)$。

记得开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int R,C;
int u=1,l=4,r=3,f=2,b=5,d=6;
int tmp;
ll ans;
int main(){
	cin>>R>>C;
	for(int i=1;i<=R;i++){
		ans+=C/4*14;
		if(i&1){
			for(int j=1;j<=C%4;j++){
				if(j==1){
					ans+=u;continue;
				}
				tmp=u;
				u=l;l=d;d=r;r=tmp;
				ans+=u;
			}
		}
		else{
			for(int j=1;j<=C%4;j++){
				if(j==1){
					ans+=u;continue;
				}
				tmp=u;
				u=r;r=d;d=l;l=tmp;
				ans+=u;
			}
		}
		tmp=u;
		u=b;b=d;d=f;f=tmp;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Claire0918 (赞：0)

首先想到模拟每一次翻转，时间复杂度 $\mathcal{O}(rc)$，超时。

一般来说，在这种情况下要尝试多次使用部分结果来达到降低复杂度的目的。

不难看出，因为翻转的结果具有周期性，所以在同一行内每 $4$ 格的和是恒定的。只要先算出每 $4$ 格的和 $s$，就可以 $\mathcal{O}(1)$ 得到任意的 $4k$ 格的和 $ks$。

需要注意，不一定有 $4 \mid c$，但不能通过上文方法算出结果的格子不超过 $3$ 个，直接模拟 $\mathcal{O}(1)$ 得到结果。

这样一来，我们就 $\mathcal{O}(1)$ 求得了一行的结果。把总时间复杂度优化到了 $\mathcal{O}(r)$。

需要注意，奇数行和偶数行的翻转方向不一样，所以要每 $2$ 行一组统计答案，如果最后还剩一行单独统计。

可能可以用类似方法优化到 $\mathcal{O}(1)$，但没必要。

注意开 `long long`。

Code: 
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

int n, m;
long long res = 0;

inline void move_down(int & u, int & d, int & f, int & b){
	const int temp = u;
	u = b;
	b = d;
	d = f;
	f = temp;
}

inline void move_left(int & u, int & d, int & l, int & r){
	const int temp = u;
	u = l;
	l = d;
	d = r;
	r = temp;
}

inline void move_right(int & u, int & d, int & l, int & r){
	const int temp = u;
	u = r;
	r = d;
	d = l;
	l = temp;
}

int main(){
	scanf("%d %d", &n, &m);
	int u = 1, d = 6, l = 4, r = 3, f = 2, b = 5;
	for (int i = 1; (i << 1) <= n; i++){
		res += (u + d + l + r) * (m >> 2);
		for (int j = 1; j < (m & 3); j++){
			res += u;
			move_left(u, d, l, r);
		}
		if (m & 3){
			res += u;
		}
		move_down(u, d, f, b);
		res += (u + d + l + r) * (m >> 2);
		for (int j = 1; j < (m & 3); j++){
			res += u;
			move_right(u, d, l, r);
		}
		if (m & 3){
			res += u;
		}
		move_down(u, d, f, b);
	}
	if (n & 1){
		res += (u + d + l + r) * (m >> 2);
		for (int j = 1; j < (m & 3); j++){
			res += u;
			move_left(u, d, l, r);
		}
		if (m & 3){
			res += u;
		}
	}
	printf("%lld", res);

return 0;
}
```

---

## 作者：Morax2022 (赞：0)

# 模拟
维护当前六面的点数，因为往左右每滚四次就会回到原样，所以可直接模 $4$。

注意:
- 模拟到最后时不要再往下滚。
- 有些时候倒退一步再算比较方便。

代码有点冗长，请见谅。

# Code
```cpp
#include <bits/stdc++.h>
#define debug cout << "CCF\n";
#define int long long
using namespace std;
const int maxn = 2e5 + 5;
struct dice{
	int dian, l, r, f, b;
}now;
main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int r, c, ans = 1; cin >> r >> c;
	now.dian = 1, now.l = 4, now.r = 3, now.f = 5, now.b = 2;
	for (int i = 1; i <= r; i++){
		int yu = c % 4, k = c / 4;
		ans += k * 14;
		if (k > 0) ans -= now.dian;
		if (k == 0) yu -= 1;
		if (k > 0){
			dice a;
			if (i & 1){
				a.dian = now.r, a.l = now.dian, a.r = 7 - a.l;
				now.dian = a.dian, now.l = a.l, now.r = a.r;
			}else {
				a.dian = now.l, a.r = now.dian, a.l = 7 - a.r;
				now.dian = a.dian, now.l = a.l, now.r = a.r;
			}
		}
		if (i & 1)
		{
			for (int j = 1; j <= yu; j++){
				dice b;
				b.dian = now.l, b.r = now.dian, b.l = 7 - b.r;
				now.dian = b.dian, now.r = b.r, now.l = b.l;
				ans += now.dian;
			}
		}
		else {
			for (int j = 1; j <= yu; j++){
				dice b;
				b.dian = now.r, b.l= now.dian, b.r = 7 - b.l;
				now.dian = b.dian, now.l = b.l, now.r = b.r;
				ans += now.dian; 
			}
		}
		if (i != r){
			dice c;
			c.dian = now.f, c.b = now.dian, c.f = 7 - c.b;
			now.dian = c.dian, now.b = c.b, now.f = c.f;
			ans += now.dian;
		}
	}
	cout << ans;
}
```

---


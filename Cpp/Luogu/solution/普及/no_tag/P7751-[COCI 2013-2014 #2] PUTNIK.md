# [COCI 2013/2014 #2] PUTNIK

## 题目描述

销售员 Sept 有一个任务，即游览 $N$ 座城市（从 $1$ 到 $N$ 编号），每座城市只能游览**恰好一次**。

这 $N$ 座城市中，每两座之间都有一列航班。Sept 追求效率，所以他希望在飞行上消耗的时间最少。为此，他可以调整这些城市的游览顺序。

但 Sept 对这个游览顺序有一个奇怪的要求：

- 对于城市 $1$ 没有要求。
- 如果要游览城市 $K(K\in[2,N])$，则所有编号小于 $K$ 的城市，要么都在游览城市 $K$ 前游览完，要么都在游览城市 $K$ 后游览完。\
  换句话说，对于两个城市 $X,Y(1\le X,Y< K)$，不能在城市 $K$ 前游览城市 $X$ 而在城市 $K$ 后游览城市 $Y$。

在这些限制下，给定每两座城市之间乘坐航班所需的时间，求出 Sept 在飞行上消耗的最少时间。

## 说明/提示

#### 样例 1 说明

顺序 $\tt2,1,3$ 或 $\tt3,1,2$ 都是可以的。

注意到 $\tt1,3,2$ 用时更短，但不符合 Sept 的奇怪要求。

#### 样例 2 说明

顺序 $\tt3,1,2,4$ 或 $\tt4,2,1,3$ 都是可以的。

#### 数据规模与约定

**本题不采用捆绑测试，在评测中也不会体现 Subtask。**

- Subtask 1 $\tt(40pts)$：$2\le N\le 10$。
- Subtask 2 $\tt(20pts)$：$2\le N\le 20$。
- Subtask 3 $\tt(60pts)$：无特殊限制。

对于 $100\%$ 的数据，有 $2\le N\le 1500$，$0\le (A,B)\le 10^3$。

#### 来源

**本题译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 2](https://hsin.hr/coci/archive/2013_2014/contest2_tasks.pdf) _T4 PUTNIK_。**

按照原题数据配置，本题满分 $120$ 分。

## 样例 #1

### 输入

```
3 
0 5 2 
5 0 4 
2 4 0```

### 输出

```
7```

## 样例 #2

### 输入

```
4 
0 15 7 8 
15 0 16 9 
7 16 0 12 
8 9 12 0```

### 输出

```
31```

# 题解

## 作者：jijian (赞：2)

### 1. 分析
下面的 dalao 们都用的搜索，我发现这道题可以维护一个连续的区间，而且每次向左或向右拓展，所以考虑区间 dp，暴力枚举两端节点（实际上和 dalao 们的思路差不多）。

---
### 2. dp 数组定义
$dp[i][j]$ 表示两端城市是 $i$ 和 $j$ 时的最小飞行时间。

---
### 3. 细节
当我们遍历到左端点为 $i$，右端点为 $j$ 的时候，不难得出下一个城市是 $\max(i,j)+1$。  
设下一个城市为 $k$，当 $k>n$ 时，直接 continue（因为遍历完了），否则就直接考虑把 $k$ 接到 $i$ 前面或者 $j$ 后面。  
状态转移方程：  
$dp[i][k]=\min(dp[i][k],dp[i][j]+t[j][k])$。  
$dp[k][j]=\min(dp[k][j],dp[i][j]+t[i][k])$。

---
### 4. code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    vector<vector<int>> t(n+1,vector<int>(n+1));//时间
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>t[i][j];
        }
    }
    vector<vector<int>> dp(n+1,vector<int>(n+1,INT_MAX));//dp[i][j]表示两端城市是i和j时的最小飞行时间
    dp[1][1]=0;//初始化
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(dp[i][j]==INT_MAX) continue;//不可达
            int k=max(i,j)+1;//下一个城市
            if(k>n) continue;//超出城市总数
            dp[i][k]=min(dp[i][k],dp[i][j]+t[j][k]);//将k接在i左边
            dp[k][j]=min(dp[k][j],dp[i][j]+t[i][k]);//将k接在j右边
        }
    }
    int ans=INT_MAX;
    for(int i=1;i<=n;i++){
        ans=min(ans,dp[i][n]);//求出最少时间
        ans=min(ans,dp[n][i]);
    }
    cout<<ans;
    return 0;
}
```
时间复杂度 $O(n^2)$。  
空间复杂度 $O(n^2)$。

---
完结撒花，若有不足，请 dalao 们指出。

---

## 作者：djh0314 (赞：1)

[**洛谷**](https://www.luogu.com.cn/problem/P7751)。

## 题意

一共有 $n$ 个星球，有一个推销员，他有一个要求：对于编号为 $1\sim n$ 的星球，在他登上编号为 $K$ 的星球时，要么那些编号小于 $K$ 的星球都已经被经过过了，要么编号小于等于 $K$ 的星球都没有被经过过。每两个星球之间都有一个飞行时间，计算出经过所有星球最小所需的飞行时间。所有星球必须且只能被经过一次(起点任意)。

## 分析

这道题我们首先要分析出这个推销员的经过路线的性质，搞懂这个之后，其实这道题是比较简单的。

在他登上编号为 $K$ 的星球时，要么那些编号小于 $K$ 的星球都已经被经过过了，要么编号小于等于 $K$ 的星球都没有被经过过。

假如说我们现在的节点是 $i$，
1. $1\sim i$ 全部已经被经过过，那下一步就会是大于 $i$ 的且没有被经过过的最小点；
2. 否则，可以再 $1\sim i-1$ 中任选一个经过。

总结一下这个过程，我们的推销员，他会从某个起点开始，不断向下标更小的节点，知道到达 $1$，然后再一步一步向上（不重复经过）。

先考虑暴力，我们暴力模拟我们的上述过程。枚举起点。            
~~~cpp
inline void dfs(int now,int opt,int tot) {
	if(now==n+1) return void (ans=min(ans,tot));
	if(now==1) opt=1;
	if(opt==1) {
		for(int i=now+1; i<=n+1; ++i) {
			if(vis[i]) continue;
			vis[i]=1;
			dfs(i,1,tot+a[i][now]);
			vis[i]=0;
			break;
		}
	} else {
		for(int i=1; i<now; ++i) {
			if(vis[i]) continue;
			vis[i]=1;
			dfs(i,-1,tot+a[i][now]);
			vis[i]=0;
		}
	}
}
~~~

时间复杂度：$O(n\times w^{n})$（$w=2$）。              
拿下 $60pts$。

可以发现，我们在跑至 $1$ 后的轨迹都是确定的，可以优化这一部分。

当我们在 $opt=-1$ 时枚举下一节点时，考虑我们 $now-1$ 的归属，这个节点要么当做此时的下一个节点，否则，就是在回程的一个节点。

依旧是 dfs，传两个参数 $l$，$r$，$l$ 表示从大到小过程中的上一个节点，$r$ 表示从小到大的枚举到的第一个节点，如此，我们下一个枚举的节点就是 $min(l,r)-1$。

要么是接在从大到小的最后面，要么是接在从小到大的最前面。      

并且由于我们枚举了起点，由此，我们需要先处理完 $i$ 后方的总和。

由此写出代码：
~~~cpp
inline int dfs(int l,int r) {
	int now=min(l,r);
	if(now==1) return a[l][r];
	return min(dfs(l,now-1)+a[now-1][r],dfs(now-1,r)+a[now-1][l]);
}
~~~
时间复杂度并没有太多变化，依旧是 $60pts$。

但是这个 dfs 好优化啊，显然，我们用记忆化优化。

时间复杂度就变成了：$O(n^2)$。

~~~cpp
inline int dfs(int l,int r) {
	int now=min(l,r);
	if(f[l][r]<INF) return f[l][r];
	if(now==1) return a[l][r];
	return f[l][r]=min(dfs(l,now-1)+a[now-1][r],dfs(now-1,r)+a[now-1][l]);
}
signed main() {
	n=read();
	for(int i=1; i<=n ; ++i) for(int j=1; j<=n; ++j) a[i][j]=read();
	for(int i=1; i<=n; ++i) for(int j=i+1; j<=n; ++j) e[i][j]=e[i][j-1]+a[j][j-1];
	memset(f,0x3f,sizeof f);
	int ans=INF;
	for(int i=n; i; --i) ans=min(ans,e[i+1][n]+dfs(i,i+1));
	cout<<ans;
	return 0;
}
~~~

如此，就可以愉快的 A 掉此题了，其实代码并不难写，方向在理解好题目后其实也是比较显然的。

---

## 作者：free_fall (赞：1)

首先访问到城市 $i$ 时我们必须保证 $1 \sim i-1$ 都被访问过，或者都没有被访问过，也就是说在 $1$ 号节点被访问之前，可以从后往前任意访问城市，之后访问 $1$ 号节点之后为了保证 $1 \sim i-1$ 都被访问过，从左到右依次访问未被访到的节点即可。

用图来表示会更加直观一些：

![](https://cdn.luogu.com.cn/upload/image_hosting/t5lpnybm.png)

红色箭头表示了 $1 \sim i-1$ 都没有被访问过时的路线，蓝色箭头表示了 $1 \sim i-1$ 都被访问过时的路线。

这里搞明白了以后，后面的状态和转移就很好写了，用 $f_{i,j}$ 表示红色箭头的最右端为 $i$，蓝色箭头的最右端为 $j$ 时所需的最少步数。设 $now=\max(i,j)+1$ 转移方程为 $f_{i,j}=\min(f_{now,j}+a_{now,i},f_{i,now}+a_{j,now})$。

然后再使用记忆化搜索即可，代码也很短，时间复杂度为 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1505,inf=0x3f3f3f3f;
int n,a[N][N],f[N][N],ans;
int dfs(int l,int r){
	int now=max(l,r)+1;
	if(now>n)return 0;
	if(f[l][r]!=inf)return f[l][r];
	return f[l][r]=min(dfs(now,r)+a[now][l],a[r][now]+dfs(l,now));
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
		}
	}
	memset(f,0x3f,sizeof f);
	printf("%d",dfs(1,1));
	return 0;
}
```

---

## 作者：CaoSheng_zzz (赞：0)

原题：[P7751 [COCI2013-2014#2] PUTNIK](https://www.luogu.com.cn/problem/P7751)。

### 思路
显然根据题目的约束条件当我们跳到点 $i$ 时要么点 $i$ 的左边全部跳完要么一个都没有跳过。

模拟题意画出下图：
![]()

红色箭头为从右边往左边跳且需满足当前点的左边的点一个没有跳，那么蓝色就为从右边往左边跳且需满足当前点的左边全都被跳过了。

定义 $dfs(l,r)$ 为最右边红色箭头为 $l$，蓝色箭头为 $r$ 的最小值。

我们再设定两个参数 $l,r$ 我们用 $l$ 表示最右边的红色箭头， $r$ 表示最右边的蓝色箭头。那我们不难推出状态转移式：

> $dfs(l , r) = \min({dfs(l , \max(l , r) + 1) + dis_{\max(l , r) + 1,r} , dis_{l , \max(l , r) + 1} + dfs(\max(l , r) + 1 , r)})$。

由于我们对每个不同的 $l,r$ 都会询问多次所以考虑用记忆化维护。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <queue>
#define ll long long
#define spc putchar(' ')
using namespace std;

inline int read(){
	int f = 1 , k = 0;
	char c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-') f = -1;
		c = getchar() ;
	}
	while(c >= '0' && c <= '9'){
		k = (k << 3) + (k << 1) + (c ^ 48);
		c = getchar() ;
	}
	return (f == 1 ? k : -k);
}

void output(int now){
	if(now < 0){
		putchar('-');
		output(- now);
	}
	else{
		if(now > 9) output(now / 10);
		putchar((now % 10) ^ 48);
	}
}

const int maxn = 1.5e3 + 1;
int f[maxn][maxn] , dis[maxn][maxn] , n ;

inline int dfs(int l , int r) {
	int now = max(l , r) + 1 ;
	if(now > n) return 0 ;
	if(f[l][r] != 0x3f) return f[l][r] ;
	return f[l][r] = min({dfs(l , now) + dis[now][r] , dis[l][now] + dfs(now , r)}) ;
}

signed main() {
	n = read() ;
	for(int i=1 ; i<=n ; i++) {
		for(int j=1 ; j<=n ; j++) dis[i][j] = read() , f[i][j] = 0x3f ;
	}
	return output(dfs(1 , 1)) , 0 ;
}
```

---


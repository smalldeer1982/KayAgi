# [COCI 2016/2017 #5] Unija

## 题目描述

给定 $N$ 个几何中心位于平面直角坐标系原点的矩形。将这 $N$ 个矩形进行涂色，求被涂色的总面积。

## 说明/提示

**【样例 1 图解】**

![](https://cdn.luogu.com.cn/upload/image_hosting/g1w4hrf7.png?x-oss-process=image/resize,m_lfit,h_389,w_485)

**【数据规模与约定】**

对于 $40\%$ 的数据，输入的整数均小于 $3333$。

对于 $50\%$ 的数据，没有具有包含关系的矩形。

对于 $100\%$ 的数据，$1 \le N \le 10^6$，$2 \le X,Y \le 10^7$。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #5](https://hsin.hr/coci/archive/2016_2017/contest5_tasks.pdf) _T3 Unija_。**

**本题分值按 COCI 原题设置，满分 $100$。**

## 样例 #1

### 输入

```
3
8 2
4 4
2 6```

### 输出

```
28```

## 样例 #2

### 输入

```
5
2 10
4 4
2 2
8 8
6 6```

### 输出

```
68```

# 题解

## 作者：_H17_ (赞：6)

## 题目分析

其实就是告诉你边长求覆盖之后的总面积。

只需要维护 $i$ 这么高的地方多宽即可。

## $70$ 分代码

```cpp
//-O2
#include<bits/stdc++.h>
using namespace std;
unsigned int n,x,y,a[10000001];
unsigned long long ans;
int main(){
    ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		x/=2,y/=2;//其实只要维护一个角的
		int idx=upper_bound(a+1,a+n+1,y,greater<int>())-a;
		for(int i=idx;i<=x;i++)
			a[i]=max(a[i],y);//全部记录
	}
	for(int i=1;i<=10000000;i++)
		ans+=a[i];
	ans*=4;
	cout<<ans;
	return 0;
}
```

## 优化

其实分析下读入的时候需要把 $idx \to x$ 全扫一遍，比较消耗时间。

因为我们去掉了 $\frac{3}{4}$ 所以矩形一定是通到底的，所以只把他最高的地方记录上，然后往下的都和上一层取 $\max$ 然后一直到最底下（我知道很难说清楚，具体看代码）。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned int n,x,y,a[10000001];
unsigned long long ans;
int main(){
    ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		x/=2,y/=2;
		a[x]=max(a[x],y);//把最上面记录
	}
	for(int i=10000000;i;i--){
		a[i]=max(a[i],a[i+1]);//和上面层比较
		ans+=a[i];
	}
	cout<<ans*4;
	return 0;
}
```

---

## 作者：WIGYF (赞：5)

#### 题目简化
我们可以发现对于每一个矩形，在四个象限里无论是与面积还是与其他矩阵的覆盖情况都是相同的，那么我们只用考虑第一象限的情况，然后将第一象限的最终矩阵面积乘四便是所求答案

### 解题思路
我们在输入时记录每个矩阵在第一象限里的点,其坐标即为原矩形的长与宽的二分之一（可以看原题给出的说明图推一下）。

在输入完成后，我们将所有点按横坐标或纵坐标从大到小排序，而排序后，我们可以发现：排得靠后的点的矩阵是无法对排名靠前的点的矩阵造成影响的，而排名靠后的点的矩阵绝对会覆盖到排名靠后的点矩阵的一部分。

那么对于一个点，如果按高度排序，且其的宽小于等于上一个点，那么就是被完全覆盖，可以直接跳过。

而如果没有被完全覆盖，那么它的加入会给整个答案的贡献就是它未被上一个矩形所覆盖的面积。而这个贡献与它和上一个点的宽值的差有关

## 代码奉上
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ans,by;
pair<int,int>x[1000005];
main()
{
	cin>>n;
	for(int i=1; i<=n; ++i) cin>>x[i].first>>x[i].second,x[i].first/=2,x[i].second/=2;
	sort(x+1,x+1+n);
	ans+=x[n].first*x[n].second;
	by=x[n].second;
	for(int i=n-1; i; --i)
	if(x[i].second>by)
	{
		ans+=x[i].first*(x[i].second-by);
		by=x[i].second;
	}
	cout<<ans*4;
	return 0;
}
```


---

## 作者：z071202 (赞：2)

欢迎大家来看我的题解。
## 题意
我们需要在一个二维平面上给 $N$ 个以坐标系原点为中心的矩形进行染色操作，并且找到被染色过的坐标点的数量。


------------

### 思路 ###
我们不难发现，因为是 $N$ 个矩形，所以必定是上下对称且左右对称的。所以只需将问题简化为找到一、二象限的被染色点后乘以二便可。

那么我们只需要在输入时记录每一个高度，也就是正竖坐标的横坐标的最大值。然后从上往下扫描，如果上面的最大值大于扫描到的竖坐标的点的最大值，那么它就会被上面覆盖，只需计算上面的最大值便可以了。


------------

### 代码奉上
```
#include <iostream>

using namespace std;

const int N=5*1e6;

int h[N+5];

int main()

	{
		
	int n;

	cin>>n;//矩形个数 

	for (int i=0; i<n; ++i)

		{

		int x,y;

		cin>>x>>y;//矩形的长和宽 

		if(h[x/2]<y) h[x/2]=y;//找当前竖坐标的最大值 

		}

	long long p=0;

	for(int i=N; i>0; --i)

		{

		if(h[i]<h[i+1]) h[i]=h[i+1];//如果上面的最大值大于当前最大值便替换 

		p+=h[i];//加入答案总和 

		}

	cout<<2*p<<endl;//将答案乘以2 

	}
```

---

## 作者：hy8z (赞：1)





[题目](https://www.luogu.com.cn/problem/P7762)
### 题目大意
给了你一个平面直角坐标系，又给了你 $n$ 个矩形，这些矩形的中心点都在坐标系的正中间。（也就是把这 $n$ 个矩形都平均分成了 $4$ 份）最后让我们求这些矩形覆盖的总面积。

### 题目思路
我们可以将这 $n$ 个矩阵按宽从大到小排序，这样子每个矩阵就会简单很多

再定义一个变量，来存储最大的 $y$ 值这个变量可以帮助我们判断第 $i$ 个矩阵有没有被完全覆盖。

![手绘图](https://cdn.luogu.com.cn/upload/image_hosting/11ctvuhu.png)

知道了这个原理后我们就可以开始打代码了。



```cpp
#include<bits/stdc++.h>
using namespace std;
struct matrix
{
	int x;
	int y;
}a[5000001];//定义一个结构体数组来存放矩形的长和宽
bool cmp(matrix a,matrix b)
{
	return a.x>b.x;
}
int main()
{
	long long n,ans=0,maxn=0;//定义y的最大值maxn和答案ans
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x>>a[i].y;
		a[i].x/=2,a[i].y/=2;//将矩形的长和宽处理到一个象限里面，最后再乘回去
	}
	sort(a+1,a+n+1,cmp);//按宽从大到小排列
	for(int i=1;i<=n;i++)
	{
		if(a[i].y>maxn)//判断有没有被完全覆盖
		{
			ans=ans+(a[i].y-maxn)*a[i].x;//需增加本矩形的长减去最长的长的差乘上本矩形的宽
			maxn=a[i].y;//更改最长的长
		}
	}
	cout<<ans*4<<endl;//输出（别忘了乘回来）
	return 0;
}

```






---

## 作者：Hasinon (赞：1)

（题目大意不用了吧，感觉题目讲解挺清晰的）
## 解题思路
首先题目中给的每个矩形都以坐标轴原点中心对称，所以我们可以只算一个象限里的被涂色面积，然后再 $\times 4$ 就OK了。  

主要思路是把矩形的在 $X$ 轴上的长度按从大到小排序。因为我们只算一个象限内的被涂色面积，那么这个象限内的所有矩形的左下顶点一定在原点上。  

我们把 $Y$ 轴坐标 $i$ 从 $1$ 开始枚举。枚举每个上边在 $i$ 上,下边在 $i-1$ 上的矩形，然后把它们的面积加起来就是答案。文字描述的不算太清晰，看看示例图吧。  
![例子](https://cdn.luogu.com.cn/upload/image_hosting/8q8cwwsw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
红色是输入所给的矩形。  
黑色是我们每次枚举得到的矩形。
把所有黑色矩形面积加起来 $\times 4$  就是答案。 

那么如何枚举每个黑色矩形的 $X$ 轴长度？  

先把所有输入矩形按照 $X$ 轴长度从大到小排序，放到一个栈里面。
枚举黑色矩形的时候，以在栈最前面的输入矩形的 $X$ 轴长度作为黑色矩形的 $X$ 轴长度。（在最前面 $X$ 轴长度即满足条件的最大 $X$ 轴长度）

当枚举的 $Y$ 轴坐标大于输入矩形的 $Y$ 轴长度时，把这个输入矩形从栈弹出。直到找到一个输入矩形的 $Y$ 轴长度小于等于此时枚举的 $Y$ 轴坐标。

说着复杂，代码简单，看代码就完事了

## CODE
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
struct node{
	ll x,y;
};
node mmap[1000005];
bool cmp(node a,node b)
{
	if(a.x>b.x) return true;
	else if(a.x==b.x&&a.y>b.y) return true;
	return false;
}
int gt()
{
	int k=0,t=1;char c=getchar();
	while(c<'0'||'9'<c){if(c=='-') t=-1;c=getchar()；}
	while('0'<=c&&c<='9'){k=k*10+c-'0';c=getchar();}
	return k*t;
}
int main()
{
	ll n=gt(),to=1,ans=0;
	for(int i=1; i<=n; i++)
	{
		mmap[i].x=gt(),mmap[i].y=gt();
		mmap[i].x/=2,mmap[i].y/=2;
	}
	sort(mmap+1,mmap+n+1,cmp);
	for(int i=1; i<=5000000; i++)
	{
		while(mmap[to].y<i&&to<=n) to++;
		if(to>n) break;
		ans+=mmap[to].x;
	}
	printf("%lld",ans*4);
}
```

---

## 作者：KirBytronic (赞：1)

蒟蒻第一次写题解，能力有限，欢迎各位大佬指出不足。
## 思路
我们可以将每个点按照 ${x}$ 
坐标从大到小排序，并记录下最大的 ${y}$ 值，因为当前的 ${x}$ 坐标一定小于等于最大的 ${x}$ 坐标，所以只需要用当前 ${ y }$ 与最大的 ${y}$ 值比较，若当前 ${y}$ 值小于等于最大 ${y}$ 值，说明该矩形完全被覆盖，直接跳过。若 ${y}$ 大于当前的最大值，就将未被覆盖的部分加入总和，未被覆盖的面积 ${=}$ ${(}$当前 ${y}$ 值 ${-}$ 最大 ${y}$ 值${)}$ ${\times}$ 当前 ${x}$ 值。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct s{
	int x,y;
};
s a[1000001];
int cmp(s a,s b){
	return a.x>b.x;//从大到小排序
}
int main(){
	long long max_y=0,n,ans=0;
	cin>>n;
	for(int i=0;i<n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);		
	}
	sort(a,a+n,cmp);
	for(int i=0;i<n;i++){
		if(a[i].y>max_y){//判断该矩形是否被完全覆盖
			ans+=(a[i].y-max_y)*a[i].x;//未被覆盖面积=（当前y值-最大y值）*当前x值
			max_y=a[i].y;//当前最大y值更新
		}
		
		
	}
	cout<<ans;
   return 0;
}
```



---

## 作者：Foreverxxx (赞：1)

## 思路

可以按照 x 或 y 进行排序，记录当前的 y 或 x 坐标的最大值，如果遇到当前扫到的点坐标比当前的 max 值更大，更新 max 值以及答案。

为了方便计算，可以将输入转化为在第一象限进行的计算，最终结果乘上 4 输出即可。

本蒟蒻写的代码用到了文件流，它可以读入多种格式，并且只需要一个类似于 cin 的读入，特别方便。

贴上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans=0;
struct node{
	long long x,y;
};node a[1000005];
bool cmp(node l,node r){
	return l.y>r.y;
}
int main(){
	//I am a fan of Roseanne Park
	//前面的 rose 自己可以随便改，自己喜欢即可>_< 
	ifstream rosein("unija.in");
	ofstream roseout("unija.out");
	rosein>>n;
	for(register int i=1;i<=n;i++){
		rosein>>a[i].x>>a[i].y;
		a[i].x/=2,a[i].y/=2;
	}
	sort(a+1,a+n+1,cmp);
	int maxx=0;
	for(register int i=1;i<=n;i++){
		if(a[i].x>maxx){
			ans+=(a[i].x-maxx)*a[i].y;
			maxx=a[i].x;
		}
	}
	roseout<<ans*4;
	return 0;
}
```


---

## 作者：HHYQ_07 (赞：0)

# 题解

## 前言

看正解已经有几位大佬给出来了，我这里就不再多说。这里再介绍一种 $70$ 分（剩下三个点 MLE 了~~毕竟不是标准答案~~）但是更灵活的做法：[扫描线](https://www.luogu.com.cn/problem/P5490)，我们这里只讨论面积并。当然你得先知道[线段树](https://oi-wiki.org/ds/seg/)是个什么东西。

## 问题

给你 $n$ 个四边平行于坐标轴的矩形，求它们共同覆盖的面积（面积并）。

## 过程

> 现在假设我们有一根线，从下往上开始扫描：

![](https://oi-wiki.org/geometry/images/scanning.svg)

> 如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。

> 我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为 $1$，上面的边标记为 $-1$，每遇到一个矩形时，我们知道了标记为 $1$ 的边，我们就加进来这一条矩形的长，等到扫描到 $-1$ 时，证明这一条边需要删除，就删去，利用 $1$ 和 $-1$ 可以轻松的到这种状态。

> 还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的是 $r+1$ 和 $r-1$。

> 有时坐标的范围可能是 $10^9$ 这个量级的，但是 $n\leq 10^6$ 甚至更少，这时就要运用[离散化](https://oi-wiki.org/misc/discrete/)。

## code

$70$ pts：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
int n,ly[N],val[N],num,ans,maxn;
struct _getline
{
	int x,y1,y2,f;
}a[2*N];
struct node
{
	int l,r,len,cnt;
}t[4*N];
bool cmp(_getline a,_getline b)
{
	if(a.x==b.x)return a.f>b.f;
	return a.x<b.x;
}
void build(int p,int l,int r)
{
	t[p].l=l,t[p].r=r;
	if(l==r)return;
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void pushup(int p)
{
	if(t[p].cnt)t[p].len=val[t[p].r+1]-val[t[p].l];
	else t[p].len=t[p*2].len+t[p*2+1].len;
}
void add(int p,int l,int r,int k)
{
	if(l<=t[p].l&&t[p].r<=r)
	{
		t[p].cnt+=k;
		pushup(p);
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(l<=mid)add(p*2,l,r,k);
	if(mid<r)add(p*2+1,l,r,k);
	pushup(p);
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int xx,yy;
		cin>>xx>>yy;
		xx/=2,yy/=2;
		a[i*2]=(_getline){xx,-yy,yy,-1};
		a[i*2-1]=(_getline){-xx,-yy,yy,1};
		ly[++num]=yy;
		ly[++num]=-yy;
	}
	sort(ly+1,ly+2*n+1);
	num=unique(ly+1,ly+2*n+1)-(ly+1);
	for(int i=1;i<=2*n;i++)
	{
		int pos1=lower_bound(ly+1,ly+num+1,a[i].y2)-ly;
		int pos2=lower_bound(ly+1,ly+num+1,a[i].y1)-ly;
		val[pos1]=a[i].y2;
		val[pos2]=a[i].y1;
		a[i].y2=pos1;maxn=max(maxn,pos1);
		a[i].y1=pos2;
	}
	sort(a+1,a+2*n+1,cmp);
	build(1,1,2*n);
	for(int i=1;i<2*n;i++)
	{
		add(1,a[i].y1,a[i].y2-1,a[i].f);
		ans+=t[1].len*(a[i+1].x-a[i].x);
	}
	cout<<ans;
	return 0;
}
```

$100$ pts：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1000005;
int n,ans,sum;
struct node
{
	int x,y;
}a[N];
bool cmp(node a,node b)
{
	return a.x<b.x;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x>>a[i].y;
		a[i].x/=2,a[i].y/=2;
	}
	sort(a+1,a+n+1,cmp);
	ans+=a[n].x*a[n].y;
	sum=a[n].y;
	for(int i=n-1;i;i--)
	if(a[i].y>sum)
	{
		ans+=a[i].x*(a[i].y-sum);
		sum=a[i].y;
	}
	cout<<ans*4;
	return 0;
}
```

希望这篇题解能帮助你浅显地理解扫描线。

（图片和文本均来自于 [OI-wiki](https://oi.wiki/geometry/scanning/)）。

---


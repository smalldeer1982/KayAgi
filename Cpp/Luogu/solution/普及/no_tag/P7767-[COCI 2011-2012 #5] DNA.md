# [COCI 2011/2012 #5] DNA

## 题目描述

有一个由 $A,B$ 组成的 $N$ 个字母的序列。

每次操作可以有两种情况：

1. 改变序列中的一个字符 （$A\to B$ 或 $B\to A$）；

2. 改变序列的前缀，即对 $1$ 到 $K(1\le K\le N)$ 的字符进行操作 1。

求最少进行多少次操作可以使序列全部为 $A$。

## 说明/提示

$1\le N\le 10^{6}$。

序列仅由 `'A','B'` 构成。

题目译自 [COCI 2011/2012 #5 T3](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
4
ABBA```

### 输出

```
2```

## 样例 #2

### 输入

```
5
BBABB```

### 输出

```
2```

## 样例 #3

### 输入

```
12
AAABBBAAABBB```

### 输出

```
4```

# 题解

## 作者：wangbinfeng (赞：5)

首先，感谢大家阅读！

------------
# 思路：
本题字符串的内容只用 A 和 B，那么肯定与这两个字母有关。

我们可以设这个字符串为 $S$ ，长度为 $n$ ，要将 $S_0 - S_{n-1}$ 都变为 A，那么对于 $S_i$ 显然有 $2$ 种情况： $S_i='A'$ 和 $S_i='B'$ 。

这样我们就要分类讨论了。

1. 若 $S_i='A'$ ：那么将 $S_0-S_i$ 都变为 A 的操作总数显然为 $S_0-S_{i-1}$ 都变为 A 的操作总数（① $S_i='A'$ ，所以不用变）。将 $S_0-S_i$ 都变为 B 的操作总数显然就为将 $S_0-S_{i-1}$ 都变为 A 的操作总数 $+1$ （②把 $S_0-S_i$ 变成 B）和 $S_0-S_{i-1}$ 都变为 B 的操作总数 $+1$ （③把自己变成 B）的最小值。

2. 若 $S_i='B'$ ：那么和上文类似。将 $S_0-S_i$ 都变为 A 的操作总数显然为就为将 $S_0-S_{i-1}$ 都变为 B 的操作总数 $+1$ （④把 $S_0-S_i$ 变成 A）和 $S_0-S_{i-1}$ 都变为 A 的操作总数 $+1$ （⑤把自己变成 A）的最小值。将 $S_0-S_i$ 都变为 B 的操作总数显然就为 $S_0-S_{i-1}$ 都变为 B 的操作总数（⑥ $S_i='B'$ ，所以不用变）。

这么长的文字也许不太好理解，就具体用实现在说明一遍（针对 C++，尽量使其他语言可以理解）：

>定义 $dpa_i$ 为将 $S_0-S_i$ 都变为 A 的操作总数。 $dpb_i$ 为将 $S_0-S_i$ 都变为 B 的操作总数。

>若 $S_i='A'$ ：
>则 $dpa_i=dpa_{i-1}$ （①）；
>$dpb_i=min(dpb_{i-1}+1,dpa_{i-1}+1)$ （②和③的最小值，min代表最小值）

>若 $S_i='B'$ ：
>则 $dpa_i=min(dpa_{i-1}+1,dpa_{i-1}+1)$ （④和⑤的最小值，min代表最小值）；
>$dpb_i=dpb_{i-1}$ （⑥）

枚举 $n$ 遍，就可以了。

- 记得给 $dpa_i$ 和 $dpb_i$ 赋初值。

- PS. $'A','B'$ 表示字符 A 和字符 B。
# 代码：
```cpp
#include<iostream>
using namespace std;
int dpa[1000009],dpb[1000009],n;
char s[1000009];
int main(){
	cin>>n;
	cin>>s;
	dpa[0]=(s[0]=='B');//初值
	dpb[0]=(s[0]=='A');//初值
	for(int i=1;i<n;i++){
		if(s[i]=='A')dpa[i]=dpa[i-1],dpb[i]=min(dpa[i-1]+1,dpb[i-1]+1);
		else dpa[i]=min(dpa[i-1]+1,dpb[i-1]+1),dpb[i]=dpb[i-1];
	}
	cout<<dpa[n-1];//数组下标从0开始，所以要-1
}
```

---

## 作者：small_john (赞：4)

## 基本思路

### 直接贪心！！！

分两种情况：

1. 单独的一个字母：用操作 $1$；

2. 一堆连续的字母：用操作 $2$。

由于后方的字母变为 $A$ 后对前方的字母不会造成影响，所以贪心时要从后往前判断。

***

## 实现方法

当使用操作 $2$ 时，前面的 $A$ 会变为 $B$，$B$ 会变为 $A$，所以用变量 $t$ 记录操作 $2$ 的次数。并且当 $t$ 为 $0$ 时 $A$ 不用翻转，为 $1$ 时 $A$ 需要翻转。所以在贪心时需要加一个判断。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+5;
int n,t,ans;
string s;
int main()
{ 
	cin>>n>>s;
	for(int i = n-1;i>=0;i--)
	{
		if(s[i]-'A'==t)
			continue;
		if(i>0&&s[i]==s[i-1])
			t = !t;
		ans++;
	}
	cout<<ans;
	return 0;
}
```

~~是不是很简单qwq~~

---

## 作者：Zwb0106 (赞：2)

####  [原题链接](https://www.luogu.com.cn/problem/P7767)

------------

## 思路

线性 DP。

令 $f_i$ 表示使长度为 $i$ 的前缀序列全部变为 $A$ 的最少次数， $g_i$ 表示使长度为 $i$ 的前缀序列全部变为 $B$ 的最少次数。

考虑状态转移方程，当 $S_i=A$ 时：

显然，若使序列全部变为 $A$，是无需在前 $i-1$ 位的基础上进行修改的，即:

$$f_i \leftarrow f_{i-1}$$

若使序列全部变为 $B$，可直接对该字符进行操作 1，即 $g_i \leftarrow g_{i-1}+1$；也可以将前 $i-1$ 位全为 $A$ 的序列进行操作 2，即 $g_i \leftarrow f_{i-1}+1$。两种方案取最小值即可，因此：

$$g_i \leftarrow \min\{g_{i-1}+1,f_{i-1}+1\}$$

同理， $S_i=B$ 时：

$$f_i \leftarrow \min\{f_{i-1}+1,g_{i-1}+1\}$$

$$g_i \leftarrow g_{i-1}$$

最后，注意初始化即可。

------------

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define gc getchar
#define pc putchar
#define fs first
#define sc second
using namespace std;

ll read()
{
	ll x=0,f=1;
	char ch=gc();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=gc();
	}
	while(ch>='0'&&ch<='9')
		x=x*10+(ch^48),ch=gc();
	return x*f;
}
void print(ll x)
{
	if(x<0)pc('-'),x=-x;
	if(x>9)print(x/10);
	pc(x%10+48);
}

const int N=1e6+5;
int n,f[N],g[N];
char s[N];

int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	
	n=read(),scanf("%s",s+1);
	
	if(s[1]=='A')f[1]=0,g[1]=1;
	if(s[1]=='B')f[1]=1,g[1]=0;
	
	for(int i=2;i<=n;i++)
	{
		if(s[i]=='A')
			f[i]=f[i-1],g[i]=min(g[i-1]+1,f[i-1]+1);
		if(s[i]=='B')
			f[i]=min(f[i-1]+1,g[i-1]+1),g[i]=g[i-1];
	}
	
	print(f[n]);
	
	return 0;
}
```

---

## 作者：_Above_the_clouds_ (赞：2)

# 思路：
求最少进行多少次操作可以使序列全部为 $A$，那只需要将 $B$ 变为 $A$。

当只有一个 $B$ 时，用操作 $1$；否则，当有多个 $B$ 时，用操作 $2$。如果从 $0\sim{n-1}$ 遍历，使用操作 $2$ 时，前面的字母会发生改变，所以从后往前遍历。

用 $f$ 记录当前翻转的字母，如果为 $0$，代表 $A$；否则代表 $B$。如果 $f$ 与当前字母无法匹配，就需进行一次操作，$ans$ 就要加一。再判断当前字母与相邻的前一个字母是否相同，如果相同，$f$ 代表的字母就更改为另一个字母，最后输出即可。

# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
bool f;
string a;
long long ans;
int main() {
	cin >> n >> a;
	for (int i = n - 1; i >= 0; i--)
		if ((!f && a[i] == 'B') || (f && a[i] == 'A')) {
			if (a[i] == a[i - 1] && i)
				if(!f) f=1;
				else f=0;
			ans++;
		}
	cout << ans;
	return 0;
}
```



---

## 作者：SSH王子 (赞：2)

# $\text{Sol}$

~~黄题题解不好意思用大号~~

题意原题说的很明白了，这里直接讲做法。

考虑贪心，发现不会贪。

然后考虑 $dp$。

发现字符集贼小，则设 $dp(i,0/1)$ 表示将字符串 $s$ 从位置 $1$ 至 $i$ 都变成 `A/B` 的最小操作次数。

我们对于位置 $i$，设它的字母所对应的数字为 $c$。分两种情况情况考虑。

对于 $dp(i,c)$，很容易想到，有两种决策：

- 将 $1$ 至 $i-1$ 变为 $c$ 然后啥都不干，即 $dp(i-1,c)$。

- 将 $1$ 至 $i-1$ 变为 $!c$ 然后再通过一次操作将 $1$ 至 $i$ 变为 $c$。 即 $dp(i-1,!c)+1$。

然后再对于 $dp(i,!c)$ 同样有两种决策：

- 将 $1$ 至 $i-1$ 变为 $c$ 然后再将 $1$ 至 $i$ 变为 $!c$，即 $dp(i-1,c)+1$。

- 将 $1$ 至 $i-1$ 变为 $!c$ 然后再将这个位置原本的 $c$ 变为 $!c$。即 $dp(i-1,!c)+1$。

综上，两两取 $\min$，得到状态转移方程：

- $dp(i,c)=\min(dp(i-1,c),dp(i-1,!c)+1)$。

- $dp(i,!c)=\min(dp(i-1,c)+1,dp(i-1,!c)+1)$。

另外再设一下 $i=1$ 时的初值，递推下去即可。

代码就不放了，放个 $\texttt{AC}$ 记录吧：[$\mathcal{Link}$](https://www.luogu.com.cn/record/55025672)

---

## 作者：FrozenDream (赞：1)

#### 引言：
考试时这道题就差一步之遥就A了，写个题解来纪念一下。

#### 思路：
这道题我们可以用贪心来解决，题目让我们把全 $\verb!A!$ 字符串转换成给定字符串，我们可以转化成把给定字符串转换成全 $\verb!A!$ 字符串。所以为 $\verb!A!$ 的字符我们不用管，只用处理为 $\verb!B!$ 的字符。

但这道题有两种操作，这时候我们就要掏出分类讨论大法!

1. 当只有单独的一个 $\verb!B!$ 时，可以直接用第一种操作改变。
2. 如果有多个 $\verb!B!$ 连在一起，就要执行两次操作，因为我们要保证除了这一段连续的 $\verb!B!$ 以外，其他的字符不能改变，这里我相信大家都知道怎么操作。

当然，我们可以优化一下时间复杂度，具体方法请看代码中的注释。

#### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
char s[1000005];
int main(){
	cin>>n;
	cin>>s;
	int flg=0;
	for(int i=n-1;i>=0;i--){//从最后一位开始遍历,可以省去判断首位为B的情况（因为首位为B只用执行1次2操作，因为它是从1开始的） 
		if(s[i]-'A'==flg)continue;//如果此时遍历的字符还是在最新的区块里面，跳过，不累加答案 
		if(s[i]==s[i-1]&&i>0)flg=1-flg;//如果此时来到了新的区块，变换flg的值（就是标记此时是A还是B） 
		ans++;
	}
	cout<<ans;
} 
```


---

## 作者：HHYQ_07 (赞：1)

# 题解

## 思路

看到数据范围，想到肯定是 $O(n)$ 或是 $O(n \log n)$ 的做法，再稍加分析，就发现这道题是贪心。操作一和操作二一个是修改单点，一个是修改 $[1,i]$ 闭区间，那么如果有两个连着的字符 $\texttt B$，一定是修改区间最好（不需要担心它对前面的字符的影响，因为这两个点是一定要修改的），否则是修改着一个点。看这两种操作，我们发现，他们对操作的这一点以及它之前的点会产生影响，那么倒序遍历，遇到字母 $\texttt B$ 按照贪心策略操作即可。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,ans;
char s[1000005];
int main()
{ 
	cin>>n>>s+1;
	for(int i=n;i;i--)
		if(s[i]-'A'!=t)
		{
			if(i>1&&s[i]==s[i-1])t=!t;
			ans++;
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)


## 思路

[题目传送门](https://www.luogu.com.cn/problem/P7767)

建议在标签里加上 "贪心"。

这道题其实就是一道简单的贪心。

题目中给了两个操作，我们可以这样做：如果只有一个 $B$ 的话，那么用操作一；如果有多个 $B$ 的话，就用操作二。

改变后方的字符时不会对前面的字符造成影响，因此我们需要从后往前贪。

我们用 $x$ 记录操作二的次数：
- 如果 $x=0$，`continue`。
- 如果 $x=1$，翻转。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;
int ans = 0;
int main(){
    cin >> n >> s;
    int x = 0;
    for(int i = n - 1; i >= 0; i--){ // 从后往前贪心
        if(s[i] - 'A' == x) continue;
        if(s[i] == s[i - 1]) x = !x; // 翻转
        ans++;
    }
    cout << ans; // 输出
    return 0; // 好习惯
}
```


---

## 作者：fkcufk (赞：0)

# [P7767 [COCI 2011/2012 #5] DNA](https://www.luogu.com.cn/problem/P7767)
## 思路
一道简单的贪心题。

- 如果只有一个 $B$，用操作一。
- 如果有多个 $B$，用操作二。

由于改变后方的字母时前方不会发生改变，因此考虑从后往前贪心。

我们可以用一个 $tmp$ 变量记录用操作二的次数，如果 $tmp=0$ 是就 `continue`，如果 $tmp=1$ 是就翻转。

其实这题 $N$ 屁用没有。

## 话不多说，附上代码
```cpp
#include <bits/stdc++.h>
#define FastIO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);
typedef long long ll;
typedef size_t ull;
const int inf = 0x3f3f3f3f;
const int homo = 114514;
using namespace std;

int n;
char s[1000005];

signed main(){
    FastIO;
    cin >> n >> s;
    int res, tmp;
    res = tmp = 0;
	for(int i = n - 1; i >= 0; i--){ // 贪心
		if(s[i] - 'A' == tmp){
            continue;
        }if(s[i] == s[i - 1]){
			tmp = !tmp;
        }
		res++;
	}
	cout << res << endl; // 输出结果
    return 0; // 华丽结束
}
```

###### ~~好水~~

望管理员通过。

---

## 作者：_Sushi (赞：0)

题目：[P7767 [COCI 2011/2012 #5] DNA](https://www.luogu.com.cn/problem/P7767)

思路：其实这一题并没有那么复杂，只需要贪心即可解决。

我们先来考虑只有操作 $ 2 $ 的情况，很容易想到，只需从前往后遍历，当某一位上的字母与下一位上的字母不同时，将这一位到最前面为止全部翻转即可。简而言之，只要统计字符串中与下一个字母不同的字母的个数（最后一位除外）。为了方便处理，可以在字符串的末尾加上一个 A。

现在再来看加上操作 $ 1 $ 的情况。我们先看 AABAA，最少操作是翻转中间的 A。再看 BBABB，同理，最少操作是翻转中间的 B，再整体翻转。

那么我们就得出了结论：如果一个字母左右两边的字母都与它不同，那么翻转这个字母，然后再按只有操作 $ 2 $ 的情况跑一遍就行了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
int ans;
int main()
{
	scanf("%d",&n);
	cin>>s;
	s=s+'A';
	for(int i=1;i<n;i++)
	    if(s[i-1]!=s[i]&&s[i+1]!=s[i])    //如果一个字母左右两边的字母都与它不同
	        s[i]='A'+'B'-s[i],ans++;     //那么翻转这个字母
	for(int i=0;i<n;i++)         //如果一个字母与它的下一位不同
	    if(s[i]!=s[i+1]) ans++;     //答案加一
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：Coros_Trusds (赞：0)

# 题目大意

给定一个由 $\verb!A,B!$ 组成的序列 $a$，求将整个序列变为 $\verb!A!$ 的最少操作次数。

一次操作可以是：

+ 改变序列中的一个字符。即 $\verb!A!$ 变为 $\verb!B!$，$\verb!B!$ 变为 $\verb!A!$。

+ 改变序列的前缀，即对 $a[1\dots k]$ 取反，$[1,k]$ 范围内所有的$\verb!A!$ 变为 $\verb!B!$，$\verb!B!$ 变为 $\verb!A!$。

# 题目分析

**所有下标均从 $1$ 开始。**

令 $dp[i][0/1]$：表示将 $a[1\dots i]$ 全部变为 $\verb!A/B!$ 的最少操作次数。

如果当前字符是 $\verb!A!$，那么有两种状态：$dp[i][0/1]$。

第一种状态 $dp[i][0]$ 可能是 $a[1\dots i-1]$ 全部是 $\verb!A!$，也可能是 $a[1\dots i-1]$ 全部是 $\verb!B!$，然后对 $[1,i]$ 取反再将 $a[i]$ 变回 $\verb!A!$；

综上，$dp[i][0]=\min\{dp[i-1][0],dp[i-1][1]+1\}$。

第二种状态 $dp[i][1]$ 可能是 $a[1\dots i-1]$ 全部是 $\verb!A!$，对 $[1,i]$ 取反，也可能是 $a[1\dots i-1]$ 全部是 $\verb!B!$，对 $a[i]$ 取反。

综上，$dp[i][1]=\min\{dp[i-1][0],dp[i-1][1]\}+1$。

-------------------
如果当前字符是 $\verb!B!$，那么有两种状态。此时和上面是相似的，详见代码。

# 代码

```cpp
//2022/5/19
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : (-x))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if (x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if (x < 0) {
			putchar('-');
			x = -x;
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 1e6 + 5;
char a[N];
int dp[N][2];//dp[i][0 / 1]:s[1 ~ i] 变成 'A'/'B' 的最少操作次数
int n;
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	std::cin >> n >> a + 1;
	mst(dp,0x3f);
	if (a[1] == 'A') {
		dp[1][0] = 0,dp[1][1] = 1;
	}
	else if (a[1] == 'B') {
		dp[1][0] = 1,dp[1][1] = 0;
	}
	for (register int i = 2;i <= n; ++ i) {
		if (a[i] == 'A') {
			dp[i][0] = std::min(dp[i - 1][0],dp[i - 1][1] + 1);
			dp[i][1] = std::min(dp[i - 1][0],dp[i - 1][1]) + 1;
		} else if (a[i] == 'B') {
			dp[i][0] = std::min(dp[i - 1][0],dp[i - 1][1]) + 1;
			dp[i][1] = std::min(dp[i - 1][0] + 1,dp[i - 1][1]);
		}
	}
	printf("%d\n",dp[n][0]);
	
	return 0;
}
```

---

## 作者：_Fatalis_ (赞：0)

**~~虽然我似乎解释明了贪心是可行的，但是我还是有些不爽~~**

~~dp 做更直观吧~~

# Solution

入手这道题，看了看，就直接奔去写贪心。

至于如何贪心？

题目大意：对于每一个操作有两种操作选择，使终串全为 $\texttt{A}$ 。

对于这道题，贪心只考虑局部最优解，不能影响到其他位置

于是，就有两种情况要讨论：

### 单独的 B

对于单独出现的 $\texttt{B}$，

执行方法 1 需要 1 步，即直接修改（操作 1）。并且不会对字符串造成其他影响。

执行方法 2 需要 2 步，才能使字符串不会出现变化。

比如说：$\texttt{AABAA}$ 

在位置3执行操作2，$\texttt{BBAAA}$ （操作 2）

再在位置2执行操作2，$\texttt{AAAAA}$ （操作 2）

显然，当出现单独的 $\texttt{B}$ 时，**执行方法 1 改变单个字符更优。**

### 连续的一串 B

对于出现一串的 $\texttt{BBBB......}$

执行方法 1 需要执行 $|S|$ 步，$S$ 为全 $\texttt{B}$ 子串。

执行方法 2 需要执行 2 步，与 “单独的 B”中考虑一样。

由于 $|S| \ge 2$，所以，在出现连续的 $\texttt{B}$ 串时，**执行方法 2 更优于方法 1。**

**综上**，需要不影响其他步骤，从右往左扫；

单独的 $\texttt{B}$ 就直接修改；

连续的 $\texttt{b}$ 就通过方法 2 改变（其实第二次操作没必要进行，因为执行结束后会继续往前扫，自然会继续改变）。

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n,t=0,len=0,ans=0;string str;
	cin>>n>>str;
	for(int i=n-1;i>=0;i--)
	{
		if((str[i]+t%2=='A'||str[i]+t%2=='C'))  //方便就不写成 % 'B'
		{
			if(len!=0)
			{
				ans++;
				if(len!=1) t++;
				len=0;
			}
		}
		if(str[i]+t%2=='B') len++;
	}
	cout<<ans+(len!=0);  //结尾还剩余其他 B
	return 0;
}
```

还有更好的贪心思路要告诉我啊 qaq。

---

## 作者：Tiago (赞：0)

## Solution

考虑 DP。

设 $dp_{i,0}$ 表示前 $i$ 个字符全为 `A` 的最小操作次数，$dp_{i,1}$ 表示前 $i$ 个数全为 `B` 的最小操作次数。

考虑转移。

若当前位为 `A` 则 $dp_{i,0}=\min(dp_{i-1,0},dp_{i-1,1}+1)$，$dp_{i,1}=\min(dp_{i-1,0}+1,dp_{i-1,1}+1)$；

若当前位为 `B` 时同理。

最后输出 $\min(dp_{n,0},dp_{n,1}+1)$ 即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(i,a,b) for(int i=(a);i<=(b);i++)
#define FOR(i,a,b) for(int i=(a);i>=(b);i--)
namespace IO
{
	inline int read()
	{
		register int x=0,f=0;register char ch=getchar();
		while(ch<'0' || ch>'9')f|=ch=='-',ch=getchar();
		while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
		return f?-x:x;
	}
	int min(int x,int y){return x<y?x:y;}
}
using namespace IO;

const int N=1e6+4;
int n,dp[N][2];
string S;
int main()
{
	cin>>n>>S;
	S=" "+S;
	// dp[i][0] i,A
	// dp[i][1] i,B
	memset(dp,0x3ffffff,sizeof(dp));
	if(S[1]=='A')dp[1][0]=0,dp[1][1]=1;
		else dp[1][0]=1,dp[1][1]=0;
	For(i,2,n)
		if(S[i]=='A')dp[i][0]=min(dp[i-1][0],dp[i-1][1]+1),dp[i][1]=min(dp[i-1][0]+1,dp[i-1][1]+1);
			else dp[i][0]=min(dp[i-1][0]+1,dp[i-1][1]+1),dp[i][1]=min(dp[i-1][0]+1,dp[i-1][1]);
	cout<<min(dp[n][0],dp[n][1]+1);

	return 0;
}
```


---


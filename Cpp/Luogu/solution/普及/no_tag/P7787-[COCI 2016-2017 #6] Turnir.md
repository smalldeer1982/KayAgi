# [COCI 2016/2017 #6] Turnir

## 题目描述

给定一个由 $2^N$ 个正整数组成的数列。每一轮将这些数字按照给定的顺序进行比大小，大的数字留下，小的数字淘汰，直至只剩下最后一个数字为止。

现在给你这 $2^N$ 个数字的初始排列顺序，请你求出每个数字能活到的最大的轮数。

## 说明/提示

**【样例解释 #2】**

![](https://cdn.luogu.com.cn/upload/image_hosting/tricmynf.png)

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 20$，$0\le A_i\le 1\times 10^9$。

**【说明】**

本题分值按 COCI 原题设置，满分 $100$。

题目译自 [COCI2016_2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #6](https://hsin.hr/coci/archive/2016_2017/contest6_tasks.pdf) _**T3 TURNIR**_

## 样例 #1

### 输入

```
2
1 4 3 2```

### 输出

```
2 0 1 1```

## 样例 #2

### 输入

```
4
5 3 2 6 4 8 7 1 2 4 3 3 6 4 8 1```

### 输出

```
1 2 2 1 1 0 1 3 2 1 2 2 1 1 0 3```

## 样例 #3

### 输入

```
1
1 1```

### 输出

```
0 0```

# 题解

## 作者：yydfj (赞：11)

**这是本蒟蒻第九次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个长度为 $2^{n}$ 的序列，将它们两两相分，互相作大小比较，小的移除，大的保留，求它们被移除的所在轮数。

## 解法综述

我们可以先想一下对于从小到大的序列进行题目要求的操作得出的答案会是怎样的，再想一下无序的序列的答案与从小到大的序列的答案有什么规律。

对于从小到大的序列，我们按找题目的要求，可以很快地得出答案。当发现两个数互不相同时，我们就把小的那个数移除，记录它被移除的所在轮数，当发现两个数相等时，我们就将它们同时移除，记录它们被移除的所在轮数。因为该序列时有序的，所以我们不必考虑移除数后要将后面的数移到前面去。

无序的序列的答案其实是由从小到大的序列的答案排列成自己的答案得来的。我们新建一个数组另存该无序的序列，然后将无序的序列排列成从小到大的序列，通过上一段的操作得出答案，最后将答案按新建的数组输出即可。

## 代码描述
```cpp
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
int a[10000005],b[10000005];
int n,m[10000005],x,s;
int main()
{
	cin>>n;
	n=pow(2,n);
	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i];//新建一个数组另存该序列
	sort(a+1,a+n+1);//将该序列排列成从小到大的序列
	for(int i=1;i<=n;i++)//进行从小到大的序列操作
	{
		s=0;
		while(a[i]==a[i+1]) i++;
		x=i;
		while(x!=1)
		{
			s++;
			x/=2;
		}
		m[a[i]]=log2(n)-s;//得出从小到大的序列的答案
	}
	for(int i=1;i<=n;i++) cout<<m[b[i]]<<" ";//将答案按新建的数组输出
	return 0;
}
```

---

## 作者：Turing_Huangrunzhe (赞：3)

题目意思比较清楚，就是输出在所有排列情况下 $a_i$ 的存活轮数。看解释里面的图就能明白，~~就是这轮数是倒着走的就比较难受~~
因为输入的数字数量是 $2^n$，数字的比较是相邻的两个数进行比较，比赛的轮数就是 $0 \sim n$。

再来看两个数字比较时的情况，无非就是 $a>b$，$a<b$，$a=b$，三种情况，$a>b$ 时 $b$ 的轮数就是当前轮数，$a$ 则晋级下一轮， $a<b$ 反之。而当 $a=b$ 的时候两个数字的轮数都是继续统计。


话不多说，上代码。
```
#include<bits/stdc++.h>
using namespace std;
int n,arr[1000005],ans[1000005],pa[1000005];//arr[]为排序后的数组,pa[]为原数组，ans[]是存答案的
int main()
{
	cin>>n;
	n=1<<n;//2的n次方个数
	for(int i=1;i<=n;i++)
	{
		cin>>arr[i];
		pa[i]=arr[i];//同时存到pa[]里
	}
	sort(arr+1,arr+n+1);
	for(int i=1;i<=n;i++)
	{
		int temp=upper_bound(arr+1,arr+n+1,pa[i])-arr-1;//找第一个比pa[i]大的前一个数的下标，其实就是最后一个等于pa[i]的数的下标
		int k=-1;//轮数从0开始，因为下面的k++,所以制成-1
		for(int j=log2(n);j>=0;j--)//从后往前找temp最近的2^n，因为一共2^n个数，看a[i]在数组中最大能排在第几位
		{
			k++;
			if(temp>=pow(2,j))
			{
				ans[i]=k;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
    return 0;
}
```


---

## 作者：Ink_Bottle (赞：2)

## 题目简述：

对于一个长度为 $2^n$ 的序列（顺序由你决定），每轮两两比较，小的淘汰，大的胜出并进入下一轮，求每个数最晚淘汰的轮数

## 思路：

这个制度其实有些像淘汰赛制，我们考虑对于每个数字的最优策略：

在这个数字淘汰之前，尽量将它与比它小的数字分在一组。

如：

```
2
1 4 3 2
```

对于数字 $2$，显然要先将其与 $1$ 分在同一组，这样它就能“活”过一轮。

通俗地讲，就是淘汰赛中，尽量和比自己弱的对手分在一组，经历的轮数才能尽量多。

只需要一次排序后，再进行判定相同的技巧，就可以算出比每个数字小的数字数量，再用 `log2` 函数计算即可。

主程序如下：

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll read()
{
	ll k,f=1;
	char c;
	while((c=getchar())<'0'||c>'9') if(c=='-') f=-1;
	k=c^48;
	while((c=getchar())>='0'&&c<='9')
	k=(k<<3)+(k<<1)+(c^48);
	return k*f;
}
void put(ll k)
{
	if(k<0) putchar('-'),k=~k+1;
	if(k>9) put(k/10);
	putchar(k%10+'0');
}
ll a[10048577];
struct ct{
	ll a,num;// a代表数字，num代表下标 
	const bool operator < (const ct & t) const //重载运算符 
	{
		return a>t.a;
	}
}f[10048577];
ll n,m;// m=2^n
ll ans[10048577];
ll sam[10048577];//表示每个数的排名（并列的最高名次）
int main()
{
	n=read();
	m=(1<<n);
	for(ll i=1;i<=m;i++) f[i].a=read(),f[i].num=i;
	sort(f+1,f+m+1);//排序
	for(ll i=1;i<=m;i++)
	{
		if(f[i].a==f[i-1].a) sam[i]=sam[i-1];//求每个数的排名（并列的最高名次）
		else sam[i]=i;
		ans[f[i].num]=n-floor(log2(m-sam[i]+1));
	}
	for(ll i=1;i<=m;i++) put(ans[i]),putchar(' ');//输出
	return 0;
}
```


---

## 作者：Liquefyx (赞：2)

Oh，许久未写题解了，~~这次来水一波 QWQ~~。

# 此题思路

因为要求编号分别为 $1 \sim 2^n$ 这些数最多能待到第几轮，我们便可以考虑贪心，让每个数尽量与比它小的数比便可以了。

虽然，比它小的所有数不可能都和它比，但是，每比一轮后，剩下的数的总数只会是原来的数的个数的二分之一，所以说可以计算每个数的比这个数小的数的总数加上 $1$ 后的 $log$ 的值，而 $n$ 减去这个值便是这个数能坚持的轮数（题目描述的轮数是 $N \sim 0$ 来看的）。

但是算 $log$ 也太过于麻烦，我们反过来算，从小到大排序后再从 $2^n$ 循环至 $1$。

而此时，它的编号就是比它小的数的总数加上 $1$ 后的总和，当它编号达到 $2^{n-1}$ 后，后面的数便不是这当前轮的了，它们的最大所属轮数应 $+1$，而 $n$ 也需要 $-1$，但也相当于 $\frac{2^{n-1}}{2}$，于是定义一个变量储存每次除二后的值就行了。
# 奉上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,pd=1,ans[1050005],sum;
struct qwq{
	int f,id;
}a[1050005];
int comp(qwq x, qwq y){
	return x.f < y.f;
}
int main(){
	scanf("%d",&n), pd=(1 << n), sum=0;
	for(int i = 1; i <= pd; ++i)
		scanf("%d",&a[i].f), a[i].id = i;
	sort(a+1,a+1+pd,comp);
	for(int i = (1 << n); i >= 1; --i){
		ans[a[i].id]=sum;
		if(i == pd)
			pd = pd >> 1, ++sum;
		if(a[i].f == a[i+1].f)
			ans[a[i].id]=ans[a[i+1].id];
	}
	for(int i = 1; i <= (1 << n); ++i)
		printf("%d ",ans[i]);
	return 0;
}
```

一篇题解完成，好耶！！！ 

---

## 作者：Foreverxxx (赞：1)

upd on 2021.9.22 修正了时间复杂度的问题。

## 题意

给你一些数，两两匹配，删除更小的数，问每个数被删除的最晚时间。

## 思路

把序列排序后可以发现，每次删除的数都是剩下的所有数中较小的一半，那么一个简单的思路就出来了。

简单地说，每一个数都要尽量匹配到不大于它的数，否则只能被淘汰。

我们可以使用 `upper_bound` 函数快速地查询到某个数所处的位置，然后进行递归，判断这个数最多可以坚持到第几轮，输出即可。

时间复杂度 $o(n \log ^2n )$， 其中找位置和递归判断均为 $o( \log n )$。

`upper_bound` 函数例题：
 
 [P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)

AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1050000];
vector<int> s;
int solve(int x){
	if(x==0)
		return 0;//特判
	 for(int i=n-1;i>=0;i--){
	 	if((1<<i)<x)x-=(1<<i);
	 	else return n-i;
	 }
	 return n;
}
int main(){
	cin>>n;
	int sum=(1<<n);
	for(int i=0;i<sum;i++){
		cin>>a[i];
		s.push_back(a[i]);
	}
	sort(s.begin(),s.end());
	for(int i=0;i<sum;i++){
		cout<<solve(s.end()-upper_bound(s.begin(),s.end(),a[i]))<<" ";
	}
	return 0;
}
```


---

## 作者：杨岛主杨东润 (赞：0)

## P7787 题解

这道题呢，我先带大家理解一下题目。

### 题目含义：
给你一个长度为 $2^{n}$ 的序列，将这一列数字两两一组，互相比较，小的移除，大的保留，求它们在分别第几轮被移除。

### 具体解法：
这道题，就是一道二分的题。

先输入一个 $n$ ，然后处理一下 $n$,接下来输入每一位。我们可以先把输入变成两个数组。

接下来，我们做一个for循环，里面用二分来计算出每一位什么时候会“死”。

具体算法：对于每一位，我们可以先判断是否仍然活着，如果活着，我们可以对它和另一位进行比较，如果它大就留着，反之淘汰，并存储死亡时间。

循环完了之后，我们把死亡时间的数组输出就可以啦！

### 具体代码：
不要抄袭哦!
```cpp
#include<bits/stdc++.h> //万能头
using namespace std;
int a[10000006],b[10000006],c[10000006];// 数组 
int main()
{
    int n;
    cin>>n;//输入 
    int m=n;
    n=1;
    for(int i=1;i<=m;i++){//把n给计算好 
        n*=2;
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=a[i];
    }
    sort(a+1,a+n+1);
    int t=0,p=0;
    for(int i=1;i<=n;i++){
        p=0;
        while(a[i]==a[i+1]){//是否需要继续 
            i++;
        }
        t=i;
        while(t!=1){//判断并更改t 
            p++;
            t=t/2;
        }
        c[a[i]]=log2(n)-p;//二分 
    }
    for(int i=1;i<=n;i++){//输出 
        cout<<c[b[i]]<<" ";
    }
    while(1){
        //防止抄袭 
    }
    return 0;
}
```
谢谢观看！

---


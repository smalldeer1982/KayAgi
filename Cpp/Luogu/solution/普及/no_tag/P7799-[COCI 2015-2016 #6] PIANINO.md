# [COCI 2015/2016 #6] PIANINO

## 题目描述

$\text{Mirka}$ 是个业余钢琴家，她正在学习一首乐曲。但她不太能找准音，因此她会采用一种特殊的技巧。

这首乐曲中有 $N$ 个音符，每个音符都有一个标准音 $a_i$。$\text{Mirka}$ 能准确地弹出第一个音，接下来她会确定一个值 $K$。

- 如果下一个音符的标准音大于当前音符的标准音，她就会将自己当前弹的音升高 $K$。
- 如果下一个音符的标准音小于当前音符的标准音，她就会将自己当前弹的音降低 $K$。
- 如果下一个音符的标准音等于当前音符的标准音，她不会改变当前弹的音。

如果当前弹的音等于当前字符的标准音，就算 $\text{Mirka}$ 弹准了一个音。请帮她确定一个非负整数 $K$，使得她弹准的音最多。

## 说明/提示

**【样例 1 解释】**

当 $K=2$ 时，她弹出的音为 **1**，3，1，**3**，**1**，共弹准了 $3$ 个音。

注意 $K=1$ 也是一种可行的方案。

**【样例 2 解释】**

当 $K=4$ 时，她弹出的音为 **2**，-2，**-6**，**-2**，2，**6**，**10**，共弹准了 $5$ 个音。

**【数据范围】**

对于 $100\%$ 的数据，$2\le N\le 10^6$，$-10^9\le a_i\le 10^9$。

**【评分方式】**

本题启用非官方的自行编写的 [Special Judge](https://www.luogu.com.cn/paste/i91dcbr2)，也可在附件中获取。欢迎大家 Hack（可私信或直接发帖）。Hack 数据作为测试点单独放在最后，对应测试点分数均为 0 分。

**【题目来源】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #6](https://hsin.hr/coci/archive/2015_2016/contest6_tasks.pdf) T3 PIANINO**。

**本题分值按 COCI 原题设置，满分 $100$**。

## 样例 #1

### 输入

```
5
1 2 0 3 1```

### 输出

```
3
2```

## 样例 #2

### 输入

```
7
2 1 -6 -2 1 6 10```

### 输出

```
5
4```

# 题解

## 作者：xh39 (赞：3)

前置基础：解一元一次方程 (包括会判无解和无数解的情况)

先将这些标准音全部减去第一个标准音。因为第一个音一定弹对，所以后面会好做一些。(当然，不减也可以做，只是麻烦一些) 

考虑把弹的音用 $ak$ 来表示。(对于每一个 $i$ , $a$ 为常数,但可以通过计算得到)

比如,对于样例,标准音为 $\{2,1,-6,-2,1,6,10\}$ , 那么可以计算出 $a=\{0,-1,-2,-1,0,1,2\}$。

然后再对于每个音，求出要弹对这个音，$k$ 应该是多少。(要特判 $a=0$ 的情况) 求解过程就是解一元一次方程。

比如对于样例，$\text{k=\{任意,1,4,4,无解,4,4\}}$，这些任意或无解都是 $a=0$ 的情况。

弹对音的个数最多,需要少数服从多数，$k$ 数组中出现最多的值就作为 $k$ 值。那么总弹对个数就是 $\text{出现次数+任意解个数}$ 。

如何求出现最多的数?最简单的办法是桶。但是桶显然装不下。所以考虑参照桶排序方法逆向优化。

即把所有数不装在桶中，**装在一个数组中**，然后将其**排序**。

所有相同的数都被放在了一起，所以就统计这些数，取最大值就可以了。(不细讲这个步骤，见代码)

时间复杂度:$O(n\times\log_{2}(n))$。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int zyl[1000005]; //每个数的k值。 
int main(){
	int n,i,A,B=0,ykb=0,tot=0,Max=0,maxid=-1,sum=1,tkr=1,first=0; //ykb:当前的数是k*ykb,就是原文中的a;tkr:任意解的数量。A为当前输入的数,B为上一次输入的数。 
	cin>>n>>first;
	for(i=1;i<n;i++){
		scanf("%d",&A);
		A-=first;
		if(A>B){
			ykb++;
		}
		if(A<B){
			ykb--;
		}
		if(!ykb){ //如果ykb==0,A=0那么说明有任意解,A!=0,说明无解。
			tkr+=(!A);
		}else{
			if(!(A%ykb)&&A/ykb>=0){ //判是否是非负整数。
				zyl[tot++]=A/ykb;
			}
		}
		B=A; //下一次的上一次就是本次的A。
	}
	sort(zyl,zyl+tot);
	zyl[tot]=-20181110; //一定要赋成一个与数组中其他元素不同的数,方便i=tot时的操作,可见下行注释。
	for(i=1;i<=tot;i++){ //数组本来是0~tot-1,但是由于最后一次的结果没取max,所以就执行i=tot,并且让此时zyl[i]!=zyl[i-1](上行的操作),将其计算进Max。而当i=0时访问a[i-1]会数组越界,并且当i=0时一定与上一位不同(毕竟都没有上一位),因此跳过了i=0。
		if(zyl[i]==zyl[i-1]){
			sum++;
		}else{
			if(sum>Max){
				Max=sum;
				maxid=zyl[i-1];
			}
			sum=1;
		}
	}
	cout<<tkr+Max<<endl<<maxid;
	return 0;
}
```
题外话:

一开始把题目看成了 如果下一个音符的标准音大于当前弹的音就加 $k$;... 然后想了半天发现自己不会做黄题。(这个~~坑人~~样例竟然以这个错误的方式都可以过...)

后面又发现,上一个标准音等于这一个标准音,根本就不会变。(还是这个~~坑人~~样例,连等于的情况都没有)

所以读题要仔细,样例都可能发现不了读题问题。

---

## 作者：caohan (赞：2)

# 思路

~~当然大模拟干过去~~

现实的来讲，这不可能，因为 $-10^9 \le  a_i \le 10^9 $ 的限制摆在这里。

但是注意到，有很小的 $n \le 10^6$ 存在，我们就想怎么通过遍历 $a$ 数组完成计算。

在 $a_i$ 和 $a_1$ 之间，一定会有一个整数上升次数（增高音量，但要是增高音量次数小于降低次数，这个数为负数），命为 $cnt$，和一个差距（就是 $a_i-a_1$ 这个值），命为 $x$。

这时，我们就能计算出一个值 $k=\frac{x}{cnt}$ 为能正好做到弹准 $a_i$ 的。

但是有两个特殊情况：

1.  $cnt=0$ 

	可以说明此音符在 $x=0$ 的时候一定可以弹准，进行记录。
1.  $\left \lfloor k \right \rfloor \ne k$ 或者 $|k| \ne k$  

	说明 $k$ 违背了题目中非负整数的要求，这个音符不可能弹准,直接抬走

一边处理，一边用 map 进行统计（空间比直接开桶小）。之后在找到最大，和那些固定能弹出的加起来就是第一问的答案，而找出这个答案的下标 $k$ 为第二问答案。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
int a[1000005];
map <int,int> b;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}//输入
	int cnt=0,ans=1,maxx=0,k=1;//初始化
	for(int i=2;i<=n;i++)
	{
		if(a[i]>a[i-1])cnt++;
		if(a[i]<a[i-1])cnt--;//统计更改次数 
		if(!cnt)
		{
			if(a[1]==a[i])
			{
				ans++;
			}
			continue;
		}//得零时进行特判
		int x=(a[i]-a[1]);
		if((a[i]-a[1])%cnt)
		{
			continue;
		}//要是有余数（除出来是小数），那就抬走
		int t1=((a[i]-a[1])/cnt);
		b[((a[i]-a[1])/cnt)]++;//往map上统计
		if(b[((a[i]-a[1])/cnt)]>maxx&&k>=0)
		{
			maxx=b[((a[i]-a[1])/cnt)];
			k=((a[i]-a[1])/cnt);
		}//超过最大就更新
	}
	cout<<maxx+ans<<"\n"<<k;
	return 0;
}
```















---

## 作者：CPPfive (赞：2)

## 题目分析

根据 $N$ 个音符的标准音，实际上我们可以知道每一次音高的变化，即到底是上升 $K$ 还是下降 $K$，也就是说我们可以得到一个表示当前音高和第一个音符的音高的差的序列，并且每一个差都是K的整数倍（当然有可能是零倍）。我们不妨用 $b_{i}$ 来表示这个实际弹出来的音高和第一个音符音高之差与 $K$ 的比值.

因此，对于每一个音符，使得它能够弹准的K是确定的,即：
$$K=(a_{i}-a_{1}) \div b_{i}$$
因此我们很自然地可以想到用开一个桶来记录每一个 $K$ 可以使多少个音符弹准。但是 $K$ 的范围是不允许我们开数组的，所以我们可以用 map 来记录，复杂度为 $\mathcal{O}(N\log{N})$。

一个需要注意的地方是，如果当前音符的 $b_{i}$ 为零，那么我们需要特判,因为除以零是不合法的。如果关于具体实现有什么不懂的地方可以看一看代码里的注释。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1000050;
int N,ans,K,a[MAXN],temp,cnt; 
//cnt表示不管K是什么，音高都是准的音符的数量 
map<int,int> m;

int main()
{
	scanf("%d",&N);
	scanf("%d",&a[1]);				//第一个音符已经默认准了，所以把cnt加一
	++cnt; 
	for(int i=2;i<=N;++i){
		scanf("%d",&a[i]);
		temp+=(a[i]>a[i-1]);
		temp-=(a[i]<a[i-1]);
		//特判当前和第一个音符相同音高的情况，如果当前音符确实和第一个音符音高相同，就++cnt 
		if(temp==0){
			if(a[i]==a[1]) ++cnt;
			continue;
		}
		//保证K是一个非负整数 
		if((double)(a[i]-a[1])/temp>=0&&(a[i]-a[1])%temp==0){
			int t=(a[i]-a[1])/temp;
			++m[t];
		}
	}
	
	//统计答案
	map<int,int> :: iterator it;
	for(it=m.begin();it!=m.end();++it){
		//每个答案前都要加上cnt 
		if(it->second+cnt>ans) ans=it->second+cnt,K=it->first;
	}
	printf("%d\n%d\n",ans,K);
	
	return 0;
}
```


---

## 作者：chl090410 (赞：1)

## P7799 PIANINO 题解

### 题目分析

由于 $-10^9\le a_i\le10^9$，所以遍历 $K$ 的方法是不行的。

又因为 $2\le N\le 10^6$，所以考虑遍历 $a$ 数组求解。

因为 Mirka 弹的每一个音都是由上一个音 $\pm K$ 得到的，所以她弹的第 $i$ 个音一定可以表示为第一个标准音，也就是她弹的第一个音 $a_1\pm b_i K$。

$b_i$ 可以通过遍历 $a$ 数组求得。

我们再定义一个数组 $f$，$f_i=a_i-a_1$，$f_i$ 也可以通过遍历 $a$ 数组求得。

Mirka 若弹准了第 $i$ 个音，就说明 $a_1+b_iK=a_i$，即 $b_iK=a_i-a_1=f_i$

- 当 $b_i=f_i=0$ 时 $K$ 取任何数都行，设这样的 $K$ 的个数为 $x$。

- 当 $b_i=0$，$f_i\ne0$ 时，$K$ 无解。

- 当 $b_i\ne0$，$f_i\ne0$ 时，$K$ 唯一，此时 $K=\dfrac{f_i}{b_i}$。

因为 $K$ 为非负整数，所以当 $\dfrac{f_i}{b_i}$ 为负数、$b_i\nmid f_i$ 时便可以直接跳过本轮操作，进行下一轮操作。

而满足要求的 $K$ 我们存在数组 $t$ 中。

显然，若元素 $m$ 在 $t$ 中存在 $n$ 次，那就意味着 $K$ 取 $m$ 时有 $(m+x)$ 个音弹得准，而题目中要求弹得准的音的最大值，即 $t$ 中出现次数最多的元素。

但 $-10^9\le a_i\le10^9$，开桶肯定不行，本蒟蒻又不会离散化，所以只有将 $t$ 数组排序，通过遍历 $t$ 数组来求解。

### 下面附上完整代码。

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
map<int,int>m;
int n,a[2000005],b[2000005],f[2000005],t[2000005],mx,my,x=1,kl,l=1,r=0;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=2;i<=n;i++){
		if(a[i]<a[i-1]){
			b[i]=b[i-1]-1;
		}else if(a[i]>a[i-1]){
			b[i]=b[i-1]+1;
		}else{
			b[i]=b[i-1];
		}
		f[i]=a[i]-a[1];
	}
	for(int i=2;i<=n;i++){
		if(b[i]==0 && f[i]==0){
			x++;
		}
		if(b[i]==0 && f[i]!=0){
			continue;
		}
		if(b[i]==0){
			continue;
		}
		if(f[i]%b[i]==0){
			t[++kl]=f[i]/b[i];
		}
	}
	sort(t+1,t+kl+1);
	l=t[1];
	for(int i=1;i<=kl;i++){
		if(t[i]!=l){
			if(r>my && l>=0){
				my=r;
				mx=l;
			}
			l=t[i];
			r=0;
		}
		r++;
	}
	if(r>my){
		my=r;
		mx=l;
	}
	cout<<my+x<<endl<<mx;
	return 0;
}

---

## 作者：O_N_N (赞：0)

在已知数组 $a[i]$ 的情况下，假设 Mirka 小姐在第 $i$ 次演唱时唱准了标准音，那么存在唯一的 $k$ 满足公式：

$$ k \times \text{way} + a[0] = a[i] $$

通过比较相邻元素 $a[i]$ 和 $a[i-1]$ ，我们可以利用哈希映射（map）记录每种假设的 $k$ 值出现的次数。

在处理过程中，需要特别注意当 $\text{way} = 0$ 的情况。

最终，通过统计每种 $k$ 值的出现次数，我们可以轻松地得到答案。

请注意，$k$ 必须满足 $k \geq 0$ 且为整数。 
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
void p7799(){
    ll n;
    cin>>n;
    vector<ll> ns(n);
    map<ll,ll> ks;
    for (int i = 0; i < n  ; ++i) {
        cin>>ns[i];
    }
    ll tmp=ns[0],way=0,p=0,maxKSum=-1,k;
    for (int i = 1; i < n; ++i) {
        if(ns[i]>ns[i-1]){
            way++;
        }else if(ns[i]<ns[i-1]){
            way--;
        }
        if(way==0){
            if(ns[i]==tmp){
                p++;
            }
            continue;
        }
        if((double)(ns[i]-tmp)/way<0||(ns[i]-tmp)%way!=0)continue;
        ks[((ns[i]-tmp)/way)]++;
    }
    for(auto i:ks){
        if(i.second>maxKSum){
            maxKSum=i.second;
            k=i.first;
        }
    }
    cout<<maxKSum+p+1<<endl<<k;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    p7799();
    return 0;
}
```

---

## 作者：wandereman (赞：0)

## 思路
首先我们要知道怎样判断一元一次方程无解。

这题的本质就是让我们解一个方程，$K$ 就是我们要求的数。      

在 $a_1$ 和 $a_i$ 之间，一定会有一个整数的上升次数，命名为 $cnt$，$a_i - a_1$，命为 $x$。我们要解的方程就是：$k = x \div cnt$。  

用怎样判断一元一次方程无解的只是判断无解。由此两问的答案都可以轻松得出。
## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int a[1000005];
map<int,int>b;
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int cnt=0,ans=1,maxx=0,k=1;
	for(int i=2;i<=n;i++){
		if(a[i] > a[i-1])cnt++;
		if(a[i] < a[i-1])cnt--;
		if(!cnt){
			if(a[1]==a[i])ans++;
			continue;
		}
		int x = (a[i] - a[1]);
		if((a[i] - a[1]) % cnt)continue;
		int t1 = ((a[i] - a[1]) / cnt);
		b[((a[i] - a[1]) / cnt)]++;
		if(b[((a[i] - a[1]) / cnt)] > maxx && k >= 0)
		{
			maxx=b[((a[i] - a[1]) / cnt)];
			k=((a[i] - a[1]) / cnt);
		}
	}
	cout<<maxx + ans<<endl<<k;
	return 0;
}
```

---

## 作者：内拉组里 (赞：0)

# Thoughts :

> 考虑到每一次音调升降取决于原序列中的 $ a_i $ 和 $ a_{i - 1} $ 的相对大小，故考虑将 $ a $ 数组进行压缩。
>
> 用 $ rel $ 数组记录 $ a $ 数组数据的相对大小，即
> $$
> rel_i = 
> \begin{aligned}
> 	\begin{cases}
> 		rel_{i - 1} + 1	&a_i \gt a_{i - 1}
> 		\\
> 		rel_{i - 1} - 1	&a_i \lt a_{i - 1}
> 		\\
> 		rel_{i - 1}		&a_i = a_{i - 1}
> 	\end{cases}
> \end{aligned}
> $$
> 模拟过程中还可以发现一个规律：当 $ rel_i = 0 $ 并且 $ a_i = a_1 $ 时无论 $ k $ 取多少，这个音是一定能踩中的，
>
> 于是用一个独立的变量 $ slt $ 在 $ rel_i = 0 $ 时进行特判并单独记录答案。
>
> 那么现在只要考虑 $ rel_i \gt 0 $ 和 $ rel_i \lt 0 $ 两种情况，
>
> 这时如果能踩中这个音，那么必有 $ k = \frac{a_i - a_1}{rel_i} $。
>
> 注意这里如果 $ k \lt 0 $，那么这个音是无论如何也踩不中的。
>
> 理解不了可以去研究研究 @[chenyilai](https://www.luogu.com/discuss/360121) 的 Hack 数据。
>
> ***
>
> 话说回来，现在还需要记录每一个 $ k $ 能踩中的音的数量，再去更新这里的 $ ans $。
>
> 最后要输出 $ slt + ans + 1 $，要 $ + 1 $ 的原因是第一个音是一定能踩中的（题意）。

# Details :

> - $ cnt $ 要用 $ map $，因为 $ k $ 与 $ \lvert a_i \rvert $ 的范围相同，都是 $ [0,10^9] $，直接开肯定会爆。

# Analyses :

> 总时间复杂度 $ \Theta (N) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

# Code :

```cpp
/* reference : @SYZOJ.qwert */
/* key : constant direction in each decision */
#include	<iostream>
#include	<map>
using namespace std;
constexpr int maxn = 1e6+4;

int a[maxn];
int rel[maxn];
map<int,int> cnt;
/* how many times to step rightly in this k */
int n, ans, slt, kn;
/* slt : number of steps must be on the beat anyway */

signed main (void)
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 2; i <= n; i++)
	{
		if (a[i] > a[i - 1]) rel[i] = rel[i - 1] + 1;
		else if (a[i] < a[i - 1]) rel[i] = rel[i - 1] - 1;
		else rel[i] = rel[i - 1];
	}
	for (int i = 2; i <= n; i++)
	{
		if (!rel[i])
		/* get back */
		{
			if (a[i] == a[1]) slt++;
		}
		else
		{
			if ((a[i] - a[1]) % rel[i] == 0)
			{
				int k = (a[i] - a[1]) / rel[i];
				if (k < 0) continue;
				cnt[k]++;
				if (ans < cnt[k])
				{
					ans = cnt[k];
					kn = k;
				}
			}
		}
	}
	cout << slt + ans + 1 << endl;
	cout << kn << endl;
	return 0;
}

/*
12
0 1 3 -1 1 -1 1 -1 1 -1 1 -1

output : 2 1

*/
```

---

## 作者：huhangqi (赞：0)

首先由于升高还是降低都只受标准音影响。

所以很容易想到将在每一步提高或者降低的次数预处理出来。

为了方便处理，可以将第一项设置为 $0$，其它都减去原本第一项的值，保留相对关系。

然后就可以通过当前的值除以改变次数，然后可以得到在值为多少时可以到这个点。

但是数值范围很大，不能直接开数组统计。

所以我这边是直接使用了离散化进行处理。

然后要关注一下正负关系和值为 $0$ 的情况即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000005],dp[1000005],tmp[1000005],cnt,t[1000005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=2;i<=n;i++){
		if(a[i]>a[i-1])dp[i]=dp[i-1]+1;
		else if(a[i]<a[i-1])dp[i]=dp[i-1]-1;
		else dp[i]=dp[i-1];
	}
	int tmp2=a[1];
	for(int i=1;i<=n;i++)a[i]-=tmp2;
	for(int i=1;i<=n;i++){
		if(!dp[i])continue;
		if(a[i]>0&&dp[i]<0||a[i]<0&&dp[i]>0)continue;
		if(a[i]%dp[i]!=0)continue;
		tmp[++cnt]=a[i]/dp[i];
	}
	sort(tmp+1,tmp+cnt+1);
	cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;
	int ans=0;
	int s=0,w=0;
	for(int i=1;i<=n;i++){
		if(!dp[i]){
			if(!a[i])ans++;
		}
		else {
			if(a[i]>0&&dp[i]<0||a[i]<0&&dp[i]>0)continue;
			if(a[i]%dp[i]!=0)continue;
			tmp2=lower_bound(tmp+1,tmp+cnt+1,a[i]/dp[i])-tmp;
			t[tmp2]++;
			if(t[tmp2]>s){
				s=t[tmp2];
				w=tmp2;
			}
			else if(t[tmp2]==s&&w>tmp2){
				w=tmp2;
			}
		}
	}
	cout<<s+ans<<endl<<tmp[w];
	return 0;
}

``````

---

## 作者：_weishiqi66_ (赞：0)

# 思路

这道题一眼看到，就知道如果是单纯的模拟肯定不行。我们需要找到一个 $k$ 使得尽可能多的 $a_i$ 能被正确的弹出。因为弹到第 $i$ 个音时，进行过多少次音的升高和降低是一定的。所以我们可以设定这个值为 $b$ ，只有当 $k \times b = a_i$ 这个音才能被弹对。我们可以分别处理它需要 $k$ 值为多少时才能被弹对。用一个桶记录，即可找出能够使最多音被弹对的 $k$ 。

# 代码


```
#include <bits/stdc++.h>
using namespace std;

const int N=1E7;

int n,a[N];
map<int,int > c;

bool cmp(int x,int y) {
	return x<y;
}

signed main () {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=2;i<=n;i++) a[i]=a[i]-a[1];
	a[1]=0;
	int jsq=0,ans=1;
	int ans1=0,ansk=0;
	for(int i=2;i<=n;i++) {
		if(a[i]>a[i-1]) jsq++;
		if(a[i]<a[i-1]) jsq--;
		if(jsq==0) {
			if(a[i]==0) ans++;
		}
		else {
			if((a[i]>=0&&jsq>=0)||(a[i]<=0&&jsq<=0)) {
				if(a[i]%jsq!=0) continue;
				int b=a[i]/jsq;
				c[b]++;
				if(c[b]>ans1) {
					ans1=c[b];
					ansk=b;
				}
				if(c[b]==ans1) {
					if(b<ansk) ansk=b;
				}

			}
        }
	
	}
	cout<<ans+ans1<<endl;
	cout<<ansk<<endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 前言
我的题解区的第一篇题解（
## 正文
我们对于每一次的操作进行尝试：如果满足条件的话那么 $cnt$ 就增加 $1$，否则 $cnt$ 就减少 $1$。

但是此时要注意的一点是：如果 $cnt$ 并等于 $0$，也就是没有变化时，就需要进行变换操作。

变换操作的基本思路如下：
1. 算出变化前后的高度平均值 $k$
2. 将 $res$ 数组中的第 $k$ 个数字的下标增加 $1$，即可记录下当前的数值。
3. 将 $ans$ 的值记录下来。

最后输出即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int A[1000005];
map<int, int> res;
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) scanf("%d", &A[i]);
    int cnt = 0, mx = 0, ans = 2e9, base = 1;
    for (int i = 2; i <= n; ++i) {
        if (A[i] > A[i - 1])
            ++cnt;
        if (A[i] < A[i - 1])
            --cnt;
        if (cnt == 0 && A[i] == A[1])
            ++base;
        if (cnt != 0 && (A[i] - A[1]) % cnt == 0) {
            int k = (A[i] - A[1]) / cnt;
            ++res[k];
            if (res[k] == mx)
                ans = min(ans, k);
            if (res[k] > mx)
                mx = res[k], ans = k;
        }
    }
    cout << mx + base << endl << ans;
    return 0;
}
```

---


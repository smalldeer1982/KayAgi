# 谜

## 题目背景

$\text{我需要你给我方向}$

$\text{哪怕要我独自穿过人海茫茫}$

$\text{为了你尝风霜}$

$\text{我流浪远方}$

$\text{需要你给我力量}$

$\text{无论如何我会坚强}$

$\text{只要你给我希望}$

[Source](https://www.kugou.com/song-36/1y5t3b.html)

## 题目描述

在一个大小为 $N$ 的数字三角形中：

- 第 $1$ 行为 $1$；
- 第 $2$ 行为 $2\sim3$；
- 第 $3$ 行为 $4\sim6$；
- 第 $4$ 行为 $7\sim10$；
- $\cdots~\cdots$
- 第 $N$ 行包含 $N$ 个数字，为 $\frac{N(N-1)}{2}+1\sim\frac{N(N+1)}{2}$。

下图展示了一个 $N=5$ 的数字三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/fpx5rw7l.png)

---

记 $(i,j)$ 表示第 $i$ 行第 $j$ 个数字。

已知 $(i,j)$ 能直接到达 $(i+1,j)$ 或 $(i+1,j+1)$，反之，$(i+1,j)$ 或 $(i+1,j+1)$ 也能直接到达 $(i,j)$。

现在任选一个数字作为起点，求 **连续** 地经过 $K$ 个 **不同** 的数字时，这 $K$ 个数的和的最大值，对 $10^9+7$ 取模。

## 说明/提示

#### 样例说明

对于样例 #1，如题面中的图所示，一种可行的方案是：以 $13$ 为起点，$13\rightarrow9\rightarrow14\rightarrow10\rightarrow15$，和为 $13+9+14+10+15=61$。

### 数据范围

**本题采用捆绑测试。**

| Subtask | 分值 | $N\le$ | $K\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $10^3$  |  |
| $2$ | $30$ | $10^6$ |  |
| $3$ | $30$ | $10^9$ | $1$ |
| $4$ | $10$ | $10^9$ |  |

对于 $100\%$ 的数据：$1\le T\le 10^5$，$1\le\color{red}\dfrac{K+1}{2}\le N\color{black}\le10^9$。

## 样例 #1

### 输入

```
1
5 5```

### 输出

```
61```

## 样例 #2

### 输入

```
5
2676 1930
5148 3667
5453 4764
16734806 16332913
26943973 33293903 ```

### 输出

```
909411538
587883333
823595806
727601062
965648555```

# 题解

## 作者：int32 (赞：6)

## 题目

[Link](/problem/P7813)。

## 解法

注意数据范围：（题目已经标红）

> $1\leq \color{red}{\dfrac{K+1}{2}\leq N}\color{black}{\leq10^9}$。

这说明行走的范围在第 $n$ 与第 $n-1$ 行中。

于是行走方案就出来了：**从右下角开始走，不停以右上，左下交替的方式行走，直到走到 $K$ 步。**（即样例说明的走法**逆过来**）

根据 $K$ 的奇偶性讨论答案：

在这里设 $a=(n,n)=\dfrac{n(n+1)}{2},b=a-n$。

### $K$ 为偶数

即从 $(n,n)$ 走到 $(n-1,n-\dfrac{k}{2})$。

答案即为：

$$\sum_{i=n-\frac{k}{2}}^{n-1}(n,i)\ +\ \sum_{i=n-\frac{k}{2}+1}^{n}(n-1,j).$$

利用等差数列求和可优化为：

$$\dfrac{k(2a+2b-k+2)}{4}.$$

设此答案为 $v$。

### $K$ 为奇数

在 $v$ 的基础上多了 $(n,n-\dfrac{k}{2})$

答案即为：

$$v+n-\dfrac{k}{2}.$$

---

## 作者：言琢დ (赞：5)

**upd on 2021.10.15：补充了一份理性的证明。**

**一篇来自出题人的官方题解。**

$$\large\text{「DCOI」谜}$$

$$\large\rm\text{言琢დ}$$

$$\large 2021.08.13$$

#### 样例含义

```cpp
2676 1930
5148 3667
5453 4764
16734806 16332913
26943973 33293903 
```

将样例二复制下来，每四个数字一组：`2676 1930 5148 3667 5453 4764 1673 4806 1633 2913 2694 3973 3329 3903`。

考虑使用区位码表示，结果为：`红尘有你终相伴 笑傲江湖情两牵`。

很遗憾赛时/讲评前未能有同学猜中含义，没有同学获得奖励。

#### 题目解法

数据范围中 $K\le 2N-1$ 提示了正解。
	
考虑从 $(N,N)$ 开始，波浪形向左遍历，这样的方案一定是不劣的。
	
即：$(N,N)\rightarrow(N-1,N-1)\rightarrow(N,N-1)\rightarrow(N-1,N-2)\rightarrow\dots$

此时计算答案仅需对数字三角形中最后两行计算数字和即可。

需要注意，对于 $100\%$ 的数据需要分步取模。

#### 分步取模

根据求和公式 $s=\dfrac{n\times(l+r)}{2}$，其中 $l,r$ 表示首项、末项，$n$ 表示项数。

其中 $n$ 和 $(l+r)$ 必有一项为偶数（否则 $s$ 一定不是整数），可以考虑找到这个偶数先 $÷2$，再与另一个数作乘法并取模。

另一种常见办法是使用 **逆元**，找到 $2$ 关于 $10^9+7$ 的逆元，乘上逆元即为除去它本身。

#### 证明

这里出题人补充一种较为理性的证法。

证明：考虑设我们以此种方式遍历到的数依次为

$$a_1,a_2,\dots,a_K$$

我们将序列 $a$ 进行分类，分为位于倒数第二行的序列 $b_{K/2}$ 和位于倒数第一行的序列 $c_{K-K/2}$。

其中：

$$\begin{aligned}b_i&=a_{2i}\\c_i&=a_{2i-1}\end{aligned}$$

以上的设法和考虑都是显而易见的。

我们考虑反证，假如我们遍历到一个更优的序列 $d$：

$$d_1,d_2,\dots,d_K$$

将它与序列 $a$ 作比较，那么序列 $d$ 必须至少存在一个位置 $x$，满足：

$$d_x\not\in a$$

另外这个元素至少要比序列 $a$ 中的最小元素大，理由是

$$\sum_{i=1}^{K}d_i>\sum_{i=1}^{K}a_i$$

考虑联立 $d_x$ 不在序列 $a$ 中和 $d_x>\min\{a\}$ 这两个条件。

首先根据前者，我们知道 $d_x<\min\{c\}$。

那么得到 $d_x$ 必须大于 $\min\{b\}$。

而 $b$ 中元素取的是倒数第二行最大的 $\left\lfloor\dfrac{K}{2}\right\rfloor$ 个元素。

所以 $d_x$ 就必须在倒数第一行中剩下的元素中取。

然后到这里就可以用到一个结论：

波浪形向左遍历，是遍历到倒数第一行中剩下元素的最快方法。

这个结论根据图示是很明显的。

据此我们得到：如果想要得到 $d_x$，就必须舍弃更优的一些解。

所以假设不成立，我们得不到更优的 $d_x$，从而也就得不到更优的序列 $d$。

---

## 作者：暗影之梦 (赞：3)

因为这一个表中的最后一行存储了最大的数列，所以说将未取完的最靠下一层取尽后再取其它层是局部最优情况，因为同一层的数字之间没有直接连边，所以将一层遍历完的最快速度就是以它的上一层为中介进行遍历。而 $\frac{K+1}{2}\le N$  则代表题目最多只能遍历完最后一层和倒数第二层。从而证明出优先遍历完最后一层，即交叉遍历最后一层与上一层此局部最优解即全局最优解。

因为同一行中最大的数是最后一个，则 $d[i][1]\le d[i][2]\le d[i][3]\le ...\le d[i][i]$ , $i$ 表示此数列的行数。因为要求最大值，所以我们从后往前遍历。过程如下：

 $d[n][n]\rightarrow d[n-1][n-1]\rightarrow d[n][n-1]\rightarrow d[n-1][n-2]...$ 

因为我们是从 $d[n][n]$ 开始的，所以遍历到的最后一行的次数是 $\frac{K+1}{2}$ 而遍历到倒数第二行的次数是 $\frac{K-1}{2}$ 。因为相邻两位相差 $1$，所以我们最后遍历到的最后一行的数的下标为 $n-\frac{K+1}{2}+1$ ，最后遍历到的倒数第二行的数的下标为 $n-\frac{K-1}{2}+1$ 。最后再套一下求和公式即可做出。

但是因为有一个 $/2$ ，所以在做时不能直接取模，但求和公式的首加尾可能爆long long 。因此要进行特判处理。

附完整AC代码：
```c
#include<iostream>
#define int long long
const int mod=1e9+7;
using namespace std;
inline int read()
{
	int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        {
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
    {
        write(x/10);
        putchar(x%10+'0');
        return;
    }
    putchar(x+'0');
}
int n,k,t;
signed main()
{
	t=read();
	for(int ll=1;ll<=t;ll++)
	{
		n=read(),k=read();
		int maxn=n*(n+1)/2;
		int cmax=n*(n-1)/2;
		int cnt=(k+1)/2;
		int ccnt=k-cnt;
		int minn=(maxn-cnt+1);
		int cmin=(cmax-ccnt+1);
		if((minn+maxn)%2==0)//在求和前面特判/2
		{
			if(minn%2==0)
			{
				minn/=2;
				maxn/=2;
				minn%=mod;
				maxn%=mod;
			}else
			{
				minn++;
				maxn--;
				minn/=2;
				maxn/=2;
				minn%=mod;
				maxn%=mod;
			}
		}else
		{
			minn%=mod;
			maxn%=mod;
			cnt/=2;
		}
		if((cmax+cmin)%2==0)
		{
			if(cmin%2==0)
			{
				cmin/=2;
				cmax/=2;
				cmin%=mod;
				cmax%=mod;
			}else
			{
				cmin++;
				cmax--;
				cmin/=2;
				cmax/=2;
				cmin%=mod;
				cmax%=mod;
			}
		}else
		{
			cmin%=mod;
			cmax%=mod;
			ccnt/=2;
		}
		cout<<((minn+maxn)*cnt%mod+(cmax+cmin)*ccnt%mod)%mod<<endl;
	}
	return 0;
}
```



---

## 作者：Eason_AC (赞：3)

## Content
在大小为 $n$ 的数字三角形中，第 $i$ 行包含有 $i$ 个数字，数字从上到下，从左到右依次排列为 $1,2,3,\dots$。

设第 $i$ 行第 $j$ 个数字为 $(i,j)$，则我们可以从 $(i,j)$ 走到 $(i+1,j)$ 或 $(i+1,j+1)$，也可以从 $(i+1,j)$ 或 $(i+1,j+1)$ 走到 $(i,j)$。

现在请求出连续走过 $k$ 个不同的数字时，走过的 $k$ 个数字的和最大可以达到多少。答案对 $10^9+7$ 取模。

**数据范围：$t$ 组询问，$1\leqslant t\leqslant 10^5$，$1\leqslant\frac{k+1}2\leqslant n\leqslant 10^9$。**
## Solution
这里直接讲正解。 

样例说明纯粹是来误导你的，真正使数字和最大的方案应该是从右下角，也就是 $(n,n)$ 开始走起，不断地先往右上走，再往右下走这么重复，一直走到 $k$ 步为止。

注意到数据范围中 $\frac{k+1}2\leqslant n$，因此我们这么走一定不会有走到 $(n,1)$ 还要走的情况出现。因此很容易得知对答案能够产生贡献的只有可能是在倒数第二行和最后一行的这些数字中。

然后我们分 $k$ 的奇偶性讨论。

如果 $k$ 是偶数，那么我们所走过的数字一定是最后一行从 $(n,n)$ 开始往左数连续的 $\frac k2$ 个数字和倒数第二行从 $(n-1,n-1)$ 往左数连续的 $k$ 个数字。答案就是 $\sum\limits_{i=n-\frac k2+1}^n i+\sum\limits_{i=n-\frac k2}^{n-1}i$。

但是注意到我们的 $n$ 是 $10^9$ 级别的，所以利用等差数列求和公式简化一下这个式子，就是 $\dfrac{(n-\frac k2+1+n)\frac k2}2+\dfrac{(n-\frac k2+n-1)\frac k2}2$。为了方便理清思路，你可以像我接下来给出的代码那样将答案分成两部分计算，然后到最后再一起相加。

如果 $k$ 是偶数，那么我们发现，这种情况下的答案相比于 $k-1$ 时的答案多了一个 $(n,n-\frac k2)$。答案就是 $\sum\limits_{i=n-\frac k2}^n i+\sum\limits_{i=n-\frac k2}^{n-1} i$。同样地，将它进行化简可以得到答案为 $\dfrac{(n-\frac k2+n)(\frac k2+1)}2+\dfrac{(n-\frac k2+n-1)\frac k2}2$。

那么这道题目就做完了。
## Code
```cpp
namespace Solution {
	const ll mod = 1e9 + 7;
	int n, k;
	
	ill ksm(ll a, ll b = mod - 2) {
		ll res = 1;
		for(; b; b >>= 1, a = a * a % mod)
			if(b & 1) res = res * a % mod;
		return res;
	}
	
	iv Main() {
		MT {
			read(n, k);
			ll start = 1ll * n * (n + 1) / 2, start2 = start - n;
			if(!(k % 2)) {
				ll ans1 = (start - k / 2 + 1 + start + mod) % mod * (k / 2) % mod * ksm(2) % mod; //(a^(p-1)) mod p=1
				ll ans2 = (start2 - k / 2 + 1 + start2 + mod) % mod *  (k / 2) % mod * ksm(2) % mod;
				println((ans1 + ans2) % mod); 
			} else {
				ll ans1 = (start - k / 2 + start + mod) % mod * (k / 2 + 1) % mod * ksm(2) % mod;
				ll ans2 = (start2 - k / 2 + 1+ start2 + mod) % mod * (k / 2) % mod * ksm(2) % mod;
				println((ans1 + ans2) % mod);
			}
		}
		return;
	}
}
``` 

---

## 作者：Focus_on (赞：2)

结论题，但还是有细节的 ~~（开始本蒟蒻还被卡了一会儿不敢写 $O(N)$ ，后来发现其实也可以过）~~。

题目中给出 $1\le\color{red}\dfrac{K+1}{2}\le N\color{black}\le10^9$ 就是在暗示了。

对！这个点如果要取最大，就只能在最后两行移动！！！

证明：显然啊，每次选的都是最大的数，肯定是最大的呀！

考虑分类讨论（因为本人比较蒟，就只能分类讨论做了）

![](https://cdn.luogu.com.cn/upload/image_hosting/9zputr0d.png)

（其中后面的上/下指的是上面一层（倒数第二层）和下面一层所需累加的数的个数）

那么根据等差数列求和公式

$$S_n=\frac{(a_1+a_n)\times n}2, n=\frac{a_n-a_1}{d}+1$$

即可 $\Theta(1)$ 算出每个询问啦！

当然，因为出现了除法的 $mod$ 运算，所以我们要使用到乘法逆元！因为 $10^9+7$ 是一个妥妥的质数，所以使用费马小定理即可，快速幂求出 $2^{10^9+7-2}=2^{10^9+5}$ 对 $10^9+7$ 取模即可。

~~（其实就是500000004，算出来直接复制到程序里就好啦）~~

那么，就有了这篇神奇的代码（复杂度 $\Theta(T)$ ），代码见注释 ~~不好笑的冷笑话~~

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

const long long mo=1e9 + 7;

unsigned long long s1,s2,ans,n,k,T;

int main(){
	
	scanf("%d",&T);
	while(T--){
		
		scanf("%llu%llu",&n,&k);//似乎ll就能过了？为了保险我还是开了ull
		
		s1=n*(n+1)/2;
		s2=(n-1)*n/2;
        //求出倒数第一行和倒数第二行的最后一个数
        
		if(k==1){
			printf("%llu\n",s1%mo);
			continue;
		}
		//特判一下，不知为何不特判就会WAsub3
        //如果只有一个，输出最大的就完事了
        
		ans=0ull;
		if(k&1){
			long long p=k/2,m=s2-p+1;
			if(m<=s2){
				ans=(ans+(((n*(n+1)-p)%mo*(p+1)%mo)*500000004ull)%mo)%mo;
				ans=(ans+(((n*(n-1)-p+1)%mo*p%mo)*500000004ull)%mo)%mo;
                //其实就是两个等差数列求和而已，具体见上面
			}
		}
		else{
			long long p=k/2,m=s2-p+1;
			ans=(ans+(((s1*2-p+1)%mo*p%mo)*500000004ull)%mo)%mo;
			ans=(ans+(((s2*2-p+1)%mo*p%mo)*500000004ull)%mo)%mo;
		}
		
		printf("%llu\n",ans);
	}
	
	return 0;
}

```

---

## 作者：EnofTaiPeople (赞：2)

楼上应该有大佬能写出 $O(1)$ 的做法，但作为一个码龄半年的蒟蒻，只能慢慢地打 $O(N)$ 做法。

此题要想找到思路，应采用由小见大的“递推”思路，先考虑样例，不难发现：

1. 若 $n=1$，$ans=15$；
2. 若 $n=2$，$ans=15+10=25$；
3. 若 $n=5$，$ans=15+10+14+9+13=62$
4. 若 $n=13$，$ans=15+10+14+9+13+8+12+7+4+2+5+3+6$

由此可见，最优解时从右下往上走的。如果多了，就再往上走两排，直到走不了或 $k$ 不够了为止。

考场 AC 代码如下：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MOD=1e9+7;//记得取模
inline int read(){
	char c=getchar();int an=0,f=1;
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-')f=-1,c=getchar();
	while(c>='0'&&c<='9'){
		an=an*10+c-'0';c=getchar();
	}return an*f;
}
inline void Slove(){
	long long n=read(),k=read();
	register long long i,at,bt;
	long long ans=0;
	for(i=n;i>=2;i-=2){//从最后一排往上枚举
		if(k>(at=(i<<1)+1)){//如果还要向上走
			k-=at;at=((i-1)*(i-2))>>1;at%=MOD;
			ans+=(((at<<1)+i-2)*(i-1))>>1;at=at+i;
			ans+=(((at<<1)+i-2)*(i-1))>>1;
			ans%=MOD;continue;
		}else at=(i*i-i)>>1,bt=k/2;
		at%=MOD;//否则计算（等差数列）
		ans+=(((at<<1)-bt+1)*bt)>>1;
		at+=i;bt=k-bt;ans%=MOD;
		ans+=(((at<<1)-bt+1)*bt)>>1;
		ans%=MOD;break;
	}
	printf("%lld\n",ans);
}
int main(){
	int T=read();
	while(T--)Slove();
	return 0;
}
```

---

## 作者：Daidly (赞：2)

由数据范围：$\frac{k+1}{2}\leq n$，所以 $k\leq 2n-1$。

只用考虑最后两行。

由于最后一行数字较大，优先取最后一行。

则第 $n$ 行取 $\left \lceil \frac{k}{2} \right \rceil$ 个数，第 $n-1$ 行取 $\left \lfloor \frac{k}{2} \right \rfloor$ 个数。

第 $i$ 行的最后一个数是 $\frac{i(i+1)}{2}$。

答案为：
$$\sum^{\frac{n(n+1)}{2}}_ {i=\frac{n(n+1)}{2}-\left \lceil \frac{k}{2} \right \rceil+1}+\sum^{\frac{(n-1)n}{2}}_ {i=\frac{(n-1)n}{2}-\left \lfloor \frac{k}{2} \right \rfloor+1}$$

使用等差数列求和公式化简：

$(n(n+1)-\left \lceil \frac{k}{2} \right \rceil+1)\left \lceil \frac{k}{2} \right \rceil+((n-1)n-\left \lfloor \frac{k}{2} \right \rfloor+1)\left \lfloor \frac{k}{2} \right \rfloor$

- 记得开 `long long`。

一行代码：

```
print((((n*(n+1)-(k+1)/2+1)*((k+1)/2)/2)%mod+((n*(n-1)-(k/2)+1)*(k/2)/2)%mod+mod)%mod),puts("");

```

---

## 作者：vegetable_king (赞：2)

在[博客](https://yjh965.github.io/post/p7813-ti-jie/)食用更佳。

# 思路
`__int128` 大法好！~~但是圈钱基金会不给用……~~

Py 大法好！~~但是圈钱基金会也不给用……~~

但是，洛谷可以用啊！

`long long` 可以写成 `__int64`，大概相当于 $10^{18}$；而 `__int128` 的存储范围相当于 `long long` 的平方，也就是 $10^{36}$。

如果 $n$ 为 $10^9$，则右下角的数大概为 $10^{18}$，则所有数的和也达不到 $10^{36}$，这不就是为 `__int128` 量身定制的吗？

而且，题目里有一句话：

> 对于 $100\%$ 的数据：$1\le T\le 10^5$，
$1\le\color{red}\dfrac{K+1}2\le N\color{black} \le 10^9$。

看到标红的部分了吗？这代表我们最多只需要经过最后两行！

所以，我们求出倒数第二行要经过的个数和倒数第一行要经过的个数，用等差数列求和公式直接求解即可。

还有一点，`__int128` 需要手写输入输出函数，这个不难，很好实现。
# 代码
```cpp
#include <iostream>
#include <stack>

using namespace std;

__int128 ans, ks, _1, _2;
unsigned long long t, n, k; // 输入不需要使用 __int128，不需要手写输入。
bool ss;
void out(__int128 s){
	stack<int> st;
	while (s){
		st.push(int(s % 10));
		s /= 10;
	}
	while (st.size()){
		cout << st.top(); // 按位逆序输出
		st.pop();
	}
	cout << endl;
}
int main(){
	cin >> t;
	while (t --){
		cin >> n >> k;
		ss = k % 2;
		k /= 2;
		ks = n * (n + 1) / 2;
		_1 = (ks * 2 - k + 1) * k / 2; // 倒数第一行的和
		_2 = ((ks - n) * 2 - k + 1) * k / 2; // 倒数第二行的和
		ans = _1 + _2;
		if (ss) ans += ks - k; // 若无法整除，则加上最后一行从右往左数第 k 个
		out(ans % 1000000007); // 输出
	}
}
```


---

## 作者：Argon_Cube (赞：2)

* **【题目链接】**

[Link:P7813](https://www.luogu.com.cn/problem/P7813)

* **【题目链接】**

显然这就是一个贪心，最优方案就是从最大的数字开始，一直走最后两层（即，一直先往左上走再往左下走），直到步数用完。又因为题目保证 $\frac{K+1}{2}\leq N$，所以不会出现走完最后两层还要走的情况。

那么，我们推一推柿子：

倒数第一排走过的数字和：

$$\sum_{i=\frac{n^2+n}{2}-\lceil\frac{k}{2}\rceil+1}^{\frac{n^2+n}{2}}i=\frac{\lfloor\frac{k+1}{2}\rfloor\left(n^2+n-\lfloor\frac{k+1}{2}\rfloor+1\right)}{2}$$

倒数第二排走过的数字和：

$$\sum_{i=\frac{n^2-n}{2}-\lfloor\frac{k}{2}\rfloor+1}^{\frac{n^2-n}{2}}i=\frac{\lfloor\frac{k}{2}\rfloor\left(n^2-n-\lfloor\frac{k}{2}\rfloor+1\right)}{2}$$


加起来：

$$\frac{\lfloor\frac{k+1}{2}\rfloor\left(n^2+n-\lfloor\frac{k+1}{2}\rfloor+1\right)+\lfloor\frac{k}{2}\rfloor\left(n^2-n-\lfloor\frac{k}{2}\rfloor+1\right)}{2}$$

* **【代码实现】**

```cpp
#include <iostream>
#include <array>

using namespace std;

int main(int argc,char* argv[],char* envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int testcnt;
	const unsigned long long moder=1000000007;
	unsigned long long num,pick;
	cin>>testcnt;
	while(testcnt--)
		cin>>num>>pick,cout<<((num*num+num-(pick+1)/2+1)%moder*((pick+1)/2)%moder+(num*num-num-(pick/2)+1)%moder*(pick/2)%moder)*500000004%moder<<'\n';
	return 0;
}

```

---

## 作者：BotDand (赞：1)

8.22 修改了错误的式子。

# $\text{Problems}$

在一个大小为 $N$ 的数字三角形中：

第一行包含数字 $1$，共 $1$ 个数字；  
第二行包含数字 $2,3$，共 $2$ 个数字；  
第三行包含数字 $4,5,6$，共 $3$ 个数字；  
第四行包含数字 $7,8,9,10$，共 $4$ 个数字；    
$\cdots\cdots$

下图展示了一个 $N=5$ 的数字三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/fpx5rw7l.png?x-oss-process=image/resize,m_lfit,h_180)

已知第 $i$ 行第 $j$ 个数字能直接到达第 $i+1$ 行第 $j$ 个数字或第 $i+1$ 行第 $j+1$ 个数字。且这种「到达」可以双向进行。

现在任选一个数字作为起点，求 **连续** 地经过 $K$ 个 **不同** 的数字时，这 $K$ 个数的和的最大值，对 $10^9+7$ 取模。

# $\text{Answer}$

题目给出的 $K$ 满足 $\frac{K+1}{2}\le N$，不难发现这 $K$ 个数只在最后两行，因为这样才能保证最优。

考虑如何求和。

分两种情况：

* $K$ 为奇数，则最后一行取的个数为 $\frac{K+1}{2}$，倒数第二行取的个数为 $\frac{K-1}{2}$，如下图。

![](https://z3.ax1x.com/2021/08/16/ffJOG4.png)

设倒数第二行的最后一个数值为 $x$，最后一行的最后一个数值为 $y$。

则 $x=\frac{n\times \left(n-1\right)}{2}$，$y=\frac{n\times \left(n+1\right)}{2}$。

则倒数第二行的和为 $\sum_{i=x-\frac{k-1}{2}+1}^{x} i$，最后一行的和为 $\sum_{j=y-\frac{k+1}{2}+1}^{y} j$。

总和用高斯求和求一下即可。

* $K$ 为偶数，则最后两行取的个数均为 $\dfrac{K}{2}$，如下图。

![](https://z3.ax1x.com/2021/08/16/ffdQ2D.png)

设倒数第二行的最后一个数值为 $x$，最后一行的最后一个数值为 $y$。

则 $x=\frac{n\times \left(n-1\right)}{2}$，$y=\frac{n\times \left(n+1\right)}{2}$。

同理可推得总和为 $\sum_{i=x-\frac{k}{2}+1}^{x} i+\sum_{j=y-\frac{k}{2}+1}^{y} j$。
# $\text{Code}$

无。

---

## 作者：yukimianyan (赞：0)

结论题。

看这个数据范围，$\frac{k+1}{2}\leq n$，换一种写法，$k\leq n+(n-1)$。也就是说，数据最多只会让我们走最下面那两行，我们很容易就能想出一个贪心思路，按照这样的走法走：

![](https://cdn.luogu.com.cn/upload/image_hosting/jk7gca3w.png)

那怎么计算和呢？首先求出第 $n-1$ 和第 $n$ 行最末尾的数字，题目已经给出了公式，$\frac{n(n-1)}{2}$ 和 $\frac{n(n+1)}{2}$，**注意这个时候不要取模**。

接着，计算一下第 $n-1$ 和第 $n$ 行要走几个数字，明显是 $\frac{k}{2}$ 和 $\frac{k+1}{2}$，当然要向下取整，**注意这个时候还不能取模**。

有了这四个变量，就好办了。我们按给出公式的顺序记它们为 $su,sd,lu,ld$，那答案就是

$$\sum\limits_{i=su-lu+1}^{su}i+\sum\limits_{i=sd-ld+1}^{sd}i$$

但是数据范围达到了惊人的 $10^9$，我们使用等差数列求和公式，即：

$$\sum\limits_{i=l}^{r}i=\frac{(l+r)(r-l+1)}{2}$$

最后，使用公式的时候还要注意一下，需要用**逆元**。$2$ 在 $\pmod{10^9+7}$ 意义下的逆元是 $5\times 10^8+4$，你需要把 $\frac{a}{2}$ 换成 $500000004a$，才能保证计算结果正确。

下面是我的代码实现：
```cpp
const int P=1e9+7,Q=5e8+4;
LL n,k;
LL f(LL l,LL r){//f(l,r)=l 到 r 的数字和
    return (l+r)%P*(r-l+1)%P*Q%P;
}
int mian(){
    cin>>n>>k;
    LL lu=k/2,ld=(k+1)/2;
    LL su=n*(n-1)/2,sd=n*(n+1)/2;
    cout<<(f(su-lu+1,su)%P+f(sd-ld+1,sd)%P)%P<<endl;
    return 0;
}
```


---

## 作者：SunsetSamsara (赞：0)

## 题目分析
还算比较简单的题型了。这题有个坑点就是最后已经指明了 $\dfrac{K+1} 2 \le N$，可能不容易发现。但是发现了之后就是一道简单的数学题了。

这题有个明显的贪心：每次走的时候要在最后一个节点开始走，一直在倒数第一、二行。

![](https://s3.bmp.ovh/imgs/2021/09/2931db16f3f3ec7b.png)

那么，最后一行的走过的节点个数就是 $\lfloor \dfrac{K+1}2 \rfloor$，

倒数第二行的走过的节点个数就是 $\lfloor \dfrac{K}2 \rfloor$ 了。

最后直接用等差数列求和公式即可算出来答案了。

## 代码

```cpp
#include<bits/stdc++.h>
#define lld __int128
using namespace std;
const lld mod=1e9+7;
long long n,k;
int t;
int main(){
	scanf("%d",&t);
	for(;t--;){
		scanf("%lld%lld",&n,&k);
		printf("%lld\n",(long long)((((lld)n*(n+1)-((k+1)>>1)+1)*((k+1)>>1)/2%mod+((lld)n*(n-1)-(k>>1)+1)*(k>>1)/2%mod)%mod));
	}
}
```

---

## 作者：QuAckB33 (赞：0)

小学奥数题，但由于数据范围麻烦了那么亿丢丢。

### 题目分析

由于 $K\le2 \times N-1$， 所以选数的时候只会选到最下面两行。~~当时没看到这个浪费了超多时间呜呜呜。~~


所以可以把右下角的数作为起点，也就是 $\sum\limits_{i=1}^N$ ，然后按照样例说明，锯齿一样上下走，求和就成。


根据人尽皆知的等差数列求和公式，第 $n$ 行末尾数就是


$$\sum\limits_{i=1}^n = (1+n) \times n \div 2$$


所有末尾数就搞定了啦啦啦。

------------


  **那么怎样求和？**

其实走过的就是 $N$ 和 $N-1$ 两行，$N-1$ 行从右往左取走 $K/ 2$ 个数，$N$ 行从右往左取走 $K-K/2$ 个数 （可以自己对样例画个图）。

那么分别求和再相加就是


$$ans=((mw1-k1+1)+mw1)\times k1\div 2+((mw2-k2+1)+mw2)\times k2\div 2$$


也就是


$$ans=((2\times mw1-k1+1)\times k1\div 2)+((2\times mw2-k2+1)\times k2\div 2)$$


其中 $mw1$ 与 $mw2$ 分别为第 $N-1$ 和 $N$ 行末尾的数，$k1$ 和 $k2$ 分别为两行各自取走的个数。


剩下就是取模的问题，具体见代码注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1000000007;
ll n,k;
int t;
unsigned ll wtf(ll nn){//计算第nn行最后一个数 
	if(nn%2==0) return (1+nn)*(nn/2)%mod;
	else return ((1+nn)/2)*nn%mod;//这里不取模会超出ull的范围
}
unsigned ll culc(ll k,ll i){
	unsigned ll ans;
	unsigned ll k1=k/2,k2=k-k/2;//上层个数 & 下层个数 
	unsigned ll mw=wtf(i-1),mw2=wtf(i);//末尾
	if(mw<k1||mw2<k2) mw+=mod,mw2+=mod;//前面取模会导致末尾数小于 k1 或者 k2，那就加一个mod回去 
	ans=((2*mw-k1+1)*k1/2)%mod+((2*mw2-k2+1)*k2/2)%mod;//反正都是加所以放心模 
	return ans%mod;
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%lld %lld",&n,&k);
		if(k==1){//特判 k=1的情况 
			cout<<wtf(n)<<endl;continue;
		}
		cout<<culc(k,n)<<endl;
	}
	return 0;
}
```


---


# 「JZOI-2」猜数列

## 题目背景

团员们满脑子都是办周年庆，但小僖只想摸鱼。

于是小僖拿出了最喜欢的数列来考考你。

## 题目描述

小僖有一个乱序的等差数列 $A$。

你可以发出两种询问：

1. 询问原序列下标为 $x,y$ 的数在等差数列（非模意义下）中的大小关系。
1. 询问原序列下标为 $x$ 的数在等差数列（模意义下）中的值。

但由于交互库出了点问题，你的询问 $2$ 最多能询问 $q$ 次。

给定等差数列的长度 $n$ 和询问次数 $q$，和固定的模数 $p=10^{9}+7$，求这个等差数列的公差 $d$。

**总询问次数不得超过 $2n$ 次。交互完成后请立刻输出答案。**

**交互方式：**

输入数列的长度 $n$ 和询问次数 $q$ 以开始交互。

交互过程中，您可以进行题目描述中的两种询问。

对于第一种询问，交互库将会返回 $1$ 代表 $>$ 或 $0$ 代表 $<$ 。询问格式为 `> x y`。

对于第二种询问，交互库将会返回一个正整数 $A_i$。询问格式为 `? x`。

在您确定答案后，请以 `! d` 的形式输出一行，停止交互。

在您输出一行后，请清空缓冲区：

在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。

在 Pascal 中，使用 `flush(output)`。

在 Python 中，使用 `stdout.flush()`。

其它语言请自行查阅文档。

**请遵循题目完成交互，发出不合法询问可能会出现 TLE，WA 等问题。**

## 说明/提示

对于 $50\%$ 的数据保证 $q=2n$。

另 $50\%$ 的数据保证 $q=2$。

对于 $100\%$ 的数据保证 $2\leq n\leq 100000$，$0\leq A_i< p$，$1\le d < p$

## 样例 #1

### 输入

```
3 6
1
2
3```

### 输出

```
? 1
? 2
? 3
! 1```

# 题解

## 作者：一扶苏一 (赞：8)

## Analysis

考虑数列是乱序的，询问从哪个数开始都是一样的，因此我们不妨考虑询问 $A_1$ 和 $A_2$ 在模意义下的值，并不妨设 $A_1 < A_2$。

从第三个数开始，依次询问每个数和 $A_1$、$A_2$ 的大小关系，则与 $A_1$、$A_2$ 的大小关系不同的位置就是大于 $A_1$ 且小于 $A_2$ 的个数，不妨记为 $k’$，又 $k = k' + 1$，则公差 $d$ 满足如下关系：$A_2 \equiv A_1 + kd(\bmod p)$，即 $kd + pt = A_2 - A_1$，其中 $k$ 和 $p$ 已知。显然 $k$ 和 $p$ 互质，使用 exgcd 解这个方程即可。

查询次数为 $2 + 2\times(n - 1) + 1 = 2n - 1$ 次。最后加上的 $1$ 是查询 $A_1$ 和 $A_2$ 的大小关系。

使用 exgcd 解上述方程的方法是：先解出 $kd' + pt' = 1$ 的解，然后令 $d = d' \times (A_2 - A_1)$、$t = t' \times (A_2 - A_1)$ 即可。

## Code

```cpp
#include <iostream>
#include <algorithm>

const int maxn = 1000005;
const int p = 1000000007;

typedef long long int ll;

int n, q, x, y, z;
int a[2][maxn];

void exgcd(ll a, ll b, ll &xx, ll &yy) {
  if (b == 0) {
    yy = 0; xx = 1;
    return;
  }
  exgcd(b, a % b, yy, xx);
  yy -= xx * (a / b);
}

int main() {
  std::cin >> n >> q;
  for (int i = 3; i <= n; ++i) {
    std::cout << "> 1 " << i << std::endl;
    std::cin >> a[0][i];
    std::cout << "> 2 " << i << std::endl;
    std::cin >> a[1][i];
  }
  int cnt = 0;
  for (int i = 1; i <= n; ++i) if (a[0][i] != a[1][i]) ++cnt;
  std::cout << "? 1" << std::endl;
  std::cin >> x;
  std::cout << "? 2" << std::endl;
  std::cin >> y;
  std::cout << "> 1 2" << std::endl;
  std::cin >> z;
  if (z == 1) std::swap(x, y);
  if (x > y) y += p;
  ll d, t;
  exgcd(cnt + 1, p, d, t);
  d = (d % p + p) % p;
  std::cout << "! " << (d * (y - x) % p) << std::endl;
}
```





---

## 作者：言琢დ (赞：5)

考虑 $q\le2$。

不妨设我们询问的是 $a_1,a_2$。

另一方面比较大小次数为 $2(n-1)$ 次。不难想到直接通过统计询问答案的办法，**获得** $a_1,a_2$ 在数列中的排名 $rk_1,rk_2$。

考虑这些询问得到的信息有什么用：

不妨设 $a_1\le a_2$，那么根据等差数列的性质，有：

$$a_1 = (rk_1 - rk_2)\times d + a_2$$

进而：

$$d=\dfrac{a_1-a_2}{rk_1-rk_2}$$

分母上的数直接求其模意义下的逆元，考虑 Fermat 小定理：

$$a^{-1}\equiv a^{p-2}~(\bmod~p)$$

得到：（设 $p=10^9+7$）

$$d=(a_1-a_2)\times(rk_1-rk_2)^{p-2}\mod p$$

注意取模的问题即可，下面是 code

```cpp
#include<cstdio>
#include<iostream>
const int Mod=(int)1e9+7;
inline int quick_mod(int,int);
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
#endif
    std::ios::sync_with_stdio(false);
	register int n,q;
	std::cin>>n>>q;
	std::cout<<"? 1"<<std::endl;
	register int a1;
	std::cin>>a1;
	std::cout<<"? 2"<<std::endl;
	register int a2;
	std::cin>>a2;
	register int rk1=0,rk2=0;
	for(register int i=2;i<=n;++i){
		std::cout<<"> 1 "<<i<<std::endl;
		register int x;
		std::cin>>x;
		rk1+=x;//多少个数比 a1 小
	}
	for(register int i=1;i<=n;++i)
		if(i!=2){
			std::cout<<"> 2 "<<i<<std::endl;
			register int x;
			std::cin>>x;
			rk2+=x;//多少个数比 a2 小
		}
	if(rk1>rk2){
		//a1 比 a2 大，大了 rk1-rk2 个 d
		//即：a1 = (rk1-rk2)*d + a2
		register int ch=rk1-rk2;
		// (a1 - a2) * (rk1-rk2)^(-1) = d
		std::cout<<"! "<<(((a1-a2)%Mod+Mod)%Mod*1ll*quick_mod(ch,Mod-2)%Mod)<<std::endl;
	}
	else{
		//a2 比 a1 大，大了 rk2-rk1 个 d
		register int ch=rk2-rk1;
		std::cout<<"! "<<(((a2-a1)%Mod+Mod)%Mod*1ll*quick_mod(ch,Mod-2)%Mod)<<std::endl;
	}
}
inline int quick_mod(int a,int b){
	register int s=1;
	while(b){
		if(b&1)s=s*1ll*a%Mod;
		a=a*1ll*a%Mod;b>>=1;
	}
	return s;
}
```

---

## 作者：Reobrok_Kk (赞：4)

注：本题解主要讲解优化，建议先切掉，再看

首先，这道题是一道交互题，让我们求一个被打乱的等差序列的公差。

有两种操作：

1. 询问两数大小；
2. 询问某数对 `1000000007` 取膜后的值。

朴素解法思路很简单：

循环两遍，求出最大值和次大值，再询问值，如果最大值比次大值小，那么最大值加 `1000000007`，最后取差。

代码实现就不挂了，也是很简单的。

我们重点讲优化：

总体思路还是不变的，先求最大值与次大值，我们应该想办法优化这个过程，减少比较次数。

我们可以运用树形 DP 求最长链的方法求。

回忆一下，树形 DP 求最长链中有两个变量，分别表示从这个点出发所作的最长链及次长链，一次循环就可以求出来。

每次，拿次长链与新链比较，如果新链长，那么将次长链更新，再与最长链比较，更新。

我们可以用这种做法优化，时间可以快将近两倍。 

另外，`cout << endl` 可以自动清空缓存区，不用在使用 `cout.flush()`。

```cpp
#include <bits/stdc++.h>
#define reg register
using namespace std;
inline int read() {
    int x = 0; char c = getchar();
    while (!isalnum(c)) c = getchar();
    while (isalnum(c)) {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x;
}
inline void write(int x) {
    if (x == 0) putchar('0');
    int stk[30], top = 0;
    while (x) stk[++top] = x % 10, x /= 10;
    while (top) putchar(stk[top--] ^ 48);
    return ;
}
signed main() {
    int n, m, maxnum = 1, maxxnum = 1, maxx, maxn;
    //maxnum为最大数，maxxnum为次大数
    bool flag;
    n = read(), m = read();
    for (reg int i = 2; i <= n; ++i) {
        printf("> %d %d", i, maxxnum); //询问新数与次大值的大小关系
        cout << endl;
        flag = (bool)(read()); //读入大小关系
        if (flag) { //判断是否大于次大值
            maxxnum = i; //更新次大值
            printf("> %d %d", maxxnum, maxnum); //询问
            cout << endl;
            flag = (bool) read();
            if (flag) swap(maxxnum, maxnum); //更新
        }
    }
    printf("? %d", maxnum); //输入最大值
    cout << endl;
    maxx = read();
    printf("? %d", maxxnum); //输入次大值
    cout << endl;
    maxn = read();
    if (maxx < maxn) maxx = maxx + 1000000007; //如果最大值比次大值小，说明最大值多减了 1000000007
    cout << "! " << maxx - maxn << endl; //输出
}
```



---

## 作者：MY（一名蒟蒻） (赞：3)

[P7849 「JZOI-2」猜数列](https://www.luogu.com.cn/problem/P7849)

第一道交互题！纪念一下写篇题解！

由于网络上的拳师，本场比赛的题面魔改了好久之后终于加入了主题库~~原题目名是泡妹子~~。

---

直接看正解吧。

既然是等差数列且保证公差大于一，求最小公差首要的就是**找相邻的两项**。

这里我们找最小的，最大的也是同理。不过最大可能会有点问题，我也不太清楚，保险找最小值即可。

我们必须确定找到的两项的值，于是 $2$ 操作的两次必须用完，剩下 $2n-2$ 次操作。

找最小值和次小值直接通过 $1$ 操作询问两个数实际的大小关系就可以实现，剩下的操作次数完全够用。

但是 $2$ 询问得到的是模意义下的值，也就是说有可能发生询问最小值得到的答案比次小值大。

那就加上模数，可以证明这样公差是最小的。

注意每次输出都要 `fflush(stdout);` ，我因为这个贡献了多发提交。

## Talk is cheap,show me the code.

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

const int p=1e9+7;

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	int n,q,min1,min2,r,res1,res2;
	scanf("%d%d",&n,&q);
	min1=min2=1;
	puts("> 1 2"); fflush(stdout); //这里先询问一遍确定初值
	scanf("%d",&r);
	if(r) min1++;
	else min2++;
	for(int i=3;i<=n;i++)
	{
		printf("> %d %d\n",min1,i); fflush(stdout);
		scanf("%d",&r);
		if(r) {min2=min1; min1=i;}
		else
		{
			printf("> %d %d\n",min2,i); fflush(stdout);
			scanf("%d",&r);
			if(r) min2=i;
		}
	}
	printf("? %d\n",min1); fflush(stdout); scanf("%d",&res1);
	printf("? %d\n",min2); fflush(stdout); scanf("%d",&res2);
	printf("! %d",((res2-res1)%p+p)%p); fflush(stdout);
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```

**_Thanks for your reading!_**

---

## 作者：ImmortalWatcher (赞：3)

首先我们考虑一个乱序等差数列的两个位置 $i,j$，可以根据公差表示为如下式子：

$$A_i+d(j'-i')\equiv A_j \pmod p$$

其中 $i',j'$ 为等差数列排序后 $A_i,A_j$ 所在的位置。

对于 $A_i,A_j$ 可以通过询问 $2$ 来获取在模意义下的值，对于 $i',j'$ 可以通过询问 $1$ 来获得。

具体地，我们可以询问 $n-1$ 次 $i$ 与其他位置的大小关系，从而得知它在排序后等差序列的位置，也就是 $i'$。

$i,j$ 可以随机，也可以自己假定。

然后可得:

$$d\equiv (A_j-A_i)\times inv(j'-i') \pmod p$$

其中 $inv$ 表示逆元。

总询问次数为 $n-1+n-1+1+1=2n$，问题解决。

对于询问 $1$ 次数我一开始是没打算限制的，后来验题的时候发现可以用 $n$ 次询问 $2$ 求出乱序等差数列每个数在模意义下的值，就可以求出公差。

然后懒得改了，就限制了一下这种方法，给了个部分分，就有了 $q$ 的限制。

然后就是 sort 的做法会被卡。

因为 STL 的 sort 询问上限是 $\mathcal O(n\log n)$ 次，然后就不能通过本题，然后因为交互库写的比较丑，就会出现 RE，TLE，WA 等问题。

还有就是每次输入要换行。

---

## 作者：Bezime (赞：2)

若有误请指出

**1.打开题目先读题**

[P7849 「JZOI-2」猜数列](https://www.luogu.com.cn/problem/P7849)

**2.看数据范围**
（查询1：$q_1$，查询2：$q_2$）

- $q_2\geq2$ 这个很重要

- $q_1+q_2\leq2n$ 相当于 $q_1\leq2(n-1)$

- $0<d<10^9+7$

**3.寻找方法**

先看 $q_2$，只有 $2$ 次，我们肯定是要找到等差数列中相邻的 $2$ 项 $A_i$，$A_{i-1}$ 求得 $d$。

再根据等差数列性质且 $d>0$，$d=A_i-A_{i-1}$。

又因为 $q_2$ 查出来的是 $A_i$ $\bmod$ $10^9+7$ 与 $A_{i-1}$ $\bmod$ $10^9+7$，且 $d<10^9+7$。

如果$A_i>A_{i-1}$，$d=A_i-A_{i-1}$

否则 $d=A_i+10^9+7-A_{i-1}$

再看 $q_1$，有 $2(n-1)$ 次，我们能询问出最大值（$n-1$ 次）与次大值（$n-2$ 次）。

然后就可以求出 $d$ 啦。

**4.注意**

- 敲码时注意交互题格式。

- 避免次大值与最大值相同。

**AC代码**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mo 1000000007
#define mxn 100002
using namespace std;
ll n,m,l=1,r; 						//l 是最大值（先赋为1），r 是次大值（求出最大值 再赋初值，避免初值赋为最大值）
int main(){
	scanf("%lld %lld",&n,&m);
	for(ll i=2,x;i<=n;i++){			//找出最大值
		printf("> %lld %lld\n",l,i);
		fflush(stdout);				//交互题格式
		scanf("%lld",&x);
		if(x) l=i;
	}
	r=l>1?l-1:l+1;					//对次大值 赋 不与最大值冲突 的值
	for(ll i=1,x;i<=n;i++)			//找出次大值
		if(i!=l&&i!=r){
			printf("> %lld %lld\n",r,i);
			fflush(stdout);
			scanf("%lld",&x);
			if(x) r=i;
		}
	printf("? %lld\n",l);			//查询 最大值 mod p 
	fflush(stdout);
	scanf("%lld",&l);
	printf("? %lld\n",r);			//查询 次大值 mod p 
	fflush(stdout);
	scanf("%lld",&r);
	if(r<l) r+=mo;
	printf("! %lld\n",r-l);			//输出 d 
	fflush(stdout);
}
```


---

## 作者：EnofTaiPeople (赞：1)

~~注：此题好像原名“泡妹子”，后来改了名字。~~

前置知识：

1. 选择排序；
2. IO 交互题做法。

先定义一个数组 $a$，$a[i]$ 表示 第 $i$ 小数的下标，因为只需求出最小值和次小值，所以应该使用选择排序算法。初始化 $a[i]=i$，然后进行如下操作：

1. 从第 $2$ 个数到第 $n$ 个数，将它们和第一个数进行比较（询问），如果比第一个数小，就和第一个数交换（下标）然后第一个数就是最小的了；
2. 从第 $3$ 个数到第 $n$ 个数，将它们和第二个数进行比较（询问），如果比第二个数小，就和第二个数交换（下标）然后第二个数就是次小的了。
3. 通过询问最小值和次小值，求它们的差，如果差是负数，说明次小值要加上一个模数 $1e9+7$，于是，就得到了正确答案。

考场 AC 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
	int n,a[100005];
	long long ans,ant;
	register int x,i;
	scanf("%d%*d",&n);
	for(i=1;i<=n;i++)a[i]=i;
	for(i=2;i<=n;i++){
		printf("> %d %d\n",a[1],a[i]);
		fflush(stdout);scanf("%d",&x);
		if(x)swap(a[1],a[i]);
	}
	for(i=3;i<=n;i++){
		printf("> %d %d\n",a[2],a[i]);
		fflush(stdout);scanf("%d",&x);
		if(x)swap(a[2],a[i]);
	}
	printf("? %d\n",a[1]);fflush(stdout);
	scanf("%lld",&ant);printf("? %d\n",a[2]);
	fflush(stdout);scanf("%lld",&ans);
	ans-=ant;if(ans<0)ans+=1000000007;
	printf("! %lld\n",ans);fflush(stdout);
	return 0;
}
```

---

## 作者：3a51_ (赞：0)

### 题目大意

给定一个乱序等差数列 $a$，现在要求公差，你有 $2$ 种询问方式：

1. 输入```> x y```，询问 $a_x$ 和 $a_y$ 的大小关系。
2. 输入```? x```，询问 $a_x \mod 1e9+7$。(最多询问 $q$ 次)

### 思路分析

我们可以打一遍擂台，问一遍询问```1```，找到最大值，再打一遍擂台，问一遍询问```1```，找到次大值，然后询问两数的值，如果发现最大数比次大数小，那就把最大数加上 $1e9+7$。最后减一下即可。

第一遍需要询问 $n-1$ 次；

第二遍需要询问 $n-2$ 次（因为跟最大值的关系就不用询问了）；

最后问值还要 $2$ 次，总共 $2 \times n -1$ 次，可以发现出题人还是很良心的。

### code

```cpp
#include<iostream>
using namespace std;
int main()
{
	int n,q,Max=1;
	cin>>n>>q;
	for(int i=2;i<=n;i++)
	{
		cout<<"> "<<Max<<" "<<i<<endl;
		cout.flush();
		int op;
		cin>>op;
		if(op==0)
			Max=i;
	}
	int Cmax=1;
	if(Max!=1)
		Cmax++;
	for(int i=1;i<=n;i++)
	{
		if(Cmax==i || Max==i)
			continue;
		cout<<"> "<<Cmax<<" "<<i<<endl;
		cout.flush();
		int op;
		cin>>op;
		if(op==0)
			Cmax=i;
	}
	cout<<"? "<<Max<<endl;
	cout.flush();
	int Maxn;
	cin>>Maxn;
	cout<<"? "<<Cmax<<endl;
	int Cmaxn;
	cin>>Cmaxn;
	cout.flush();
	if(Maxn<Cmaxn)
		Maxn+=1000000007;
	cout<<"! "<<Maxn-Cmaxn<<endl;
	cout.flush();
	return 0;
}
```

---

## 作者：MuYC (赞：0)

我的思路： 找出相邻的两项。

#### 如何找到相邻项

首先**随机**一个位置，然后询问它跟其它位置上的数的大小关系，然后可以得出它是原等差序列的多少项。

然后我们把小于它的放在左边，大于它的放在右边，我们往小的那边再随机。

重复若干次直到找到有两项找到了的相邻，然后一减就可以得到公差了。

最劣复杂度：$O(2n)$ ，但是事实上这个是根本跑不满的。。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
const int Mod = 1e9 + 7;
const int MAXN = 1e5 + 50;
int n, q, op, s = 1, L[MAXN], tl, tr, R[MAXN];
int LL[MAXN], RR[MAXN];
int Rk[MAXN], RK[MAXN], f1, f2, lst = 0;
bool Ap[MAXN];

int main() {
    srand(time(NULL));
    n = read(), q = read();
    for(int i = 2 ; i <= n ; i ++) {
        cout << ">" << " " << 1 << " " << i << endl;
        fflush(stdout), cout.flush();
        op = read();
        if(op == 1) L[++ tl] = i;
        else R[++ tr] = i; 
    } 
    Ap[tl + 1] = 1, Rk[tl + 1] = 1, RK[1] = tl + 1;
    lst = RK[1];
    int now = 1;
    
    while(1) {
        if(tl <= tr && tl > 0) {
            int c = rand() % tl + 1, lt = 0, rt = 0;
            now = L[c];
            for(int i = 1 ; i <= tl; i ++) {
                if(i == c) continue;
                cout << ">" << " " << now << " " << L[i] << endl;
                fflush(stdout), cout.flush();
                op = read();
                if(op == 1) LL[++ lt] = L[i];
                else RR[++ rt] = L[i];
            }
            tl = lt, tr = rt;
            for(int i = 1 ; i <= tl ; i ++)
                L[i] = LL[i];
            for(int i = 1 ; i <= tr ; i ++)
                R[i] = RR[i];
            Rk[lt + 1 + lst] = now, Ap[lt + 1 + lst] = 1, RK[now] = lt + 1 + lst;
            if(Ap[RK[now] - 1]) {
                f1 = Rk[RK[now]];
                f2 = Rk[RK[now] - 1];
                break; 
            }
            if(Ap[RK[now] + 1]) {
                f1 = Rk[RK[now] + 1];
                f2 = Rk[RK[now]];
                break; 
            }
        }
        else {
            int c = rand() % tr + 1, lt = 0, rt = 0;
            lst = RK[now], now = R[c];
            for(int i = 1 ; i <= tr; i ++) {
                if(i == c) continue;
                cout << ">" << " " << now << " " << R[i] << endl;
                fflush(stdout), cout.flush();
                op = read();
                if(op == 1) LL[++ lt] = R[i];
                else RR[++ rt] = R[i];
            }
            tl = lt, tr = rt;
            for(int i = 1 ; i <= tl ; i ++)
                L[i] = LL[i];
            for(int i = 1 ; i <= tr ; i ++)
                R[i] = RR[i];
            Rk[lt + 1 + lst] = now, Ap[lt + 1 + lst] = 1, RK[now] = lt + 1 + lst;
            if(Ap[RK[now] - 1]) {
                f1 = Rk[RK[now]];
                f2 = Rk[RK[now] - 1];
                break; 
            }
            if(Ap[RK[now] + 1]) {
                f1 = Rk[RK[now] + 1];
                f2 = Rk[RK[now]];
                break; 
            }
        }
    }
    int a, b;
    cout << "? " << f1 << endl;
    fflush(stdout), cout.flush();
    a = read();
    cout << "? " << f2 << endl;
    fflush(stdout), cout.flush();
    b = read();
    cout << "! " << (a - b + Mod) % Mod;
    fflush(stdout), cout.flush();
    return 0;
}
```

---


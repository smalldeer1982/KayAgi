# [COCI 2021/2022 #1] Kamenčići

## 题目描述

Alice 和 Bob 又在玩游戏。

在他们面前有 $n$ 块石头排成一行，石头有红和蓝两种颜色。

Alice 先手，每次每人从两端选择一端取出一块石头，谁先取出 $k$ 块红色石头谁输掉。

假设 Alice 和 Bob 都是绝顶聪明的，求出最后谁获胜。

## 说明/提示

#### 数据范围
对于全部数据，$1\le k<n\le 350$，红色石头至少出现 $2k-1$ 次。

| Subtask | 特殊限制 | 分值 |
| :----------: | :--------: | :-------: |
| $1$ | $n\le 20$ | $10$ | 
| $2$ | $n\le 50$ | $20$ |
| $3$ | 无特殊限制 | $40$ |

#### 说明
**本题总分 $70$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2012) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T2 Kamenčići。

## 样例 #1

### 输入

```
4 1
CCCP```

### 输出

```
DA```

## 样例 #2

### 输入

```
8 2
PCPPCCCC
```

### 输出

```
DA```

## 样例 #3

### 输入

```
9 1
PPCPPCPPC```

### 输出

```
NE```

# 题解

## 作者：Kawaii_qiuw (赞：4)

### 题目大意

Alice 和 Bob 又在玩游戏。

在他们面前有 $n$ 块石头排成一行，石头有红和蓝两种颜色。

Alice 先手，每次每人从两端选择一端取出一块石头，谁先取出 $k$ 块红色石头谁输掉。

假设 Alice 和 Bob 都是绝顶聪明的，求出最后谁获胜。

### 解题思路

记忆化搜索。

设 $f_{l,r,k}$ 表示现在区间是 $[l,r]$，现在先手有 $k$ 块红石子的胜负。

$sum1$，$sum2$ 分别为前缀和、后缀和。

那么对方手上的石子数就为 $sum1_{l - 1} + sum2_{r + 1} - k$。

每次特判 $sum1_{l - 1} + sum2_{r + 1} - k$ 有没有大于 $K$。

设 $val \to sum1_{l − 1} + sum2_{r + 1}$。

那么答案就是 $f_{1,n,0}$。

### 代码


```
#include <bits/stdc++.h>
using namespace std;
int n , k , b[351] , a[351] , sum1[351] , sum2[351] , dp[351][351][351];
char c;
int dfs (int l , int r, int s) {
    if (sum1[l - 1] + sum2[r + 1] - s == k) return dp[l][r][s] = 2;
    if (dp[l][r][s]) return dp[l][r][s];
    int ans1 , ans2;
    ans1 = dfs (l + 1 , r , sum1[l - 1] + sum2[r + 1] - s);
    ans2 = dfs (l , r - 1 , sum1[l - 1] + sum2[r + 1] - s);
    return dp[l][r][s] = (ans1 == 1 || ans2 == 1) ? 2 : 1;
}
int main () {
    scanf ("%d%d" , &n , &k);
    for (int i = 1 ; i <= n ; i ++) {
        c = getchar ();
        while (c != 'C' && c != 'P') c = getchar ();
        a[i] = (c == 'C');
    }
    for (int i = 1 ; i <= n ; i ++) sum1[i] = sum1[i - 1] + a[i];
    for (int i = n ; i >= 1 ; i --) sum2[i] = sum2[i + 1] + a[i];
    puts (dfs (1 , n , 0) == 2 ? "DA" : "NE");
    return 0;
}

```
[AC 记录。](https://www.luogu.com.cn/record/197011111)

完结撒花。

---

## 作者：DengDuck (赞：3)

没啥好说的，设 $f_{l,r,k}$ 表示在区间 $[l,r]$ 中游戏，先手已经取得红色鹅卵石 $k$ 个，是否先手必胜，进而也可以求出后手红色鹅卵石的数量 $t$，由此对边界特判。

转移方程：

$$
f_{l,r,k}=\neg f_{l+1,r,t}\lor \neg f_{l,r-1,t}
$$

经典套路了，先手胜的意义就是有方法使后手必败，由此转移。

洛谷上这题卡空间，记搜就行。

```cpp
#include<bits/stdc++.h>
#define LL int
using namespace std;
const LL N=355;
LL n,k,a[N],f[N][N][N],sum[N];
char s[N];
LL dfs(LL l,LL r,LL j)
{
	if(f[l][r][j]==-1)return 0;
	if(f[l][r][j]==1)return 1;
	LL t=sum[l-1]+sum[n]-sum[r];
	if(t-j>=k)
	{
		f[l][r][j]=1;
		return 1;
	}
	bool tmp=(dfs(l+1,r,t-j)==0)|(dfs(l,r-1,t-j)==0);
	if(tmp==0)f[l][r][j]=-1;
	return tmp;	
}
int main()
{
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='C')a[i]=1;
		sum[i]=sum[i-1]+a[i];
	}
	if(dfs(1,n,0))puts("DA");
	else puts("NE");
}
```

---

## 作者：Kun_is_Me (赞：2)

### 首先审题。

有 $n$ 个石头排成一行，石头有红和蓝两种颜色。

现在，A 和 B 分别从石头序列的左端或右端取一颗石头，A 先取。

如果谁取到了 $k$ 个红色石头，则立即判负。

给出 $n,k$ 和一个只有 $C$（红色）和 $P$（蓝色）的字符串。如果 A 有必胜策略输出 ``DA``，否则输出 ``NE``。

### 题目解法。

很明显的区间 DP。

但是我们使用记忆化搜索来做。

我们设 $f_{l,r,m}$ 表示现在在 $[l,r]$ 区间内进行、A 已经取了 $m$ 个红色石头，同时使用 $s1,s2$ 分别记录石头的前缀和、后缀和（$C$ 记为 1，$P$ 记为 0）。

所以易证此时 B 手上有 $s1_{l-1}+s2_{r+1}-k$ 个石头。

根据最优化，当 A 取时，肯定会尽量让自己赢，此时可以得到状态转移方程 $f_{l,r,m}=\max(f_{l+1,r,m+a_l},f_{l,r-1,m+a_r})$；如果是 B 取，就尽量让对方输，所以此时的状态转移方程为 $f_{l,r,m}=\min(f_{l+1,r,m},f_{l,r-1,m})$。

最后，$f_{1,n,0}$ 即为答案。

### AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,b[351],a[351],s1[351],s2[351],f[351][351][351];
char c;
int solve (int l,int r,int s)
{
    if (s1[l-1]+s2[r+1]-s==k) return f[l][r][s]=2;
    if (f[l][r][s]) return f[l][r][s];
    int ans1,ans2;
    ans1=solve(l+1,r,s1[l-1]+s2[r+1]-s),ans2=solve(l,r-1,s1[l-1]+s2[r+1]-s);
    return f[l][r][s]=(ans1==1||ans2==1)?2:1;
}
int main () 
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>k;
    for (int i=1;i<=n;i++) 
    {
        cin>>c;
        while(c!='C'&&c!='P') cin>>c;
        a[i]=(c=='C')?1:0;
    }
    for(int i=1;i<=n;i++) s1[i]=s1[i-1]+a[i];
    for(int i=n;i>=1;i--) s2[i]=s2[i+1]+a[i];
    if(solve(1,n,0)==2) cout<<"DA";
    else cout<<"NE";
    return 0;
}
```

一并附上 [AC 记录](https://www.luogu.com.cn/record/226318768)。

---

## 作者：Like_Amao (赞：2)

**分析**

我们可以使用记忆化搜索来做这道题，我们可以设一个 $f$ 数组，设 $f_{i,j,k}$ 为在区间 $[l,r]$ 中进行游戏，Alice 已经取走了 $k$ 个红色鹅卵石，Alice 是否一定可以获得胜利，再设 Bob 取走的红色鹅卵石数量为 $x$，然后根据前面的分析，进而求出 $x$ 的值。

然后我们就可以推导出状态转移方程：

$ f_{i,j,k} = ¬ f_{l+1,r,x} ∨ f_{l,r-1,x} $

**代码**

谁说题解一定要有代码？

---

## 作者：jamesharden666 (赞：2)

考虑记忆化搜索，设 $f_{l,r,x}$ 表示拿到 $l,r$ 区间时 Alice 拿到的红色石头的数量为 $x$，$f_{1,n,0}$ 就为最终的答案，如果值为 $1$ 就输出 DA ,反之则输出 NE。那 Bob 拿到的红色石头数量就为 $[1,l-1]\bigcup[r+1,n]$，Bob 手中的红色石头数量可以用前缀和数组维护，当前是谁拿可以根据区间长度与 $n$ 的奇偶性相比得知。如果是 Alice 拿，就尽量让自己赢，那转移方程就为 $f_{l,r,x}=\max(f_{l+1,r,x+a_l},f_{l,r-1,x+a_r})$ 。
如果是 Bob 拿，就尽量让对方输，转移方程为
$f_{l,r,x}=\min(f_{l+1,r,x},f_{l,r-1,x})$ 

时间复杂度为 $\mathcal O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1000+10],sum1[1000+10],sum2[1000+10],f[350+10][350+10][180+10];
char s[1000+10];
int dfs(int l,int r,int x)
{
    int y=sum1[l-1]+sum2[r+1]-x;
    if(x==k)
        return 0;
    if(y==k)
        return 1;
    if(f[l][r][x]!=-1)
        return f[l][r][x];
    if(((r-l+1)&1)==(n&1))
        f[l][r][x]=max(dfs(l+1,r,x+a[l]),dfs(l,r-1,x+a[r]));
    else
        f[l][r][x]=min(dfs(l+1,r,x),dfs(l,r-1,x));
    return f[l][r][x];
}
int main()
{
    scanf("%d %d %s",&n,&k,s+1);
    sum1[0]=0;
    for(int i=1;i<=n;++i)
    {
        if(s[i]=='C')
            a[i]=1;
        sum1[i]=sum1[i-1]+a[i];
    }
    sum2[n+1]=0;
    for(int i=n;i>=1;--i)
        sum2[i]=sum2[i+1]+a[i];
    memset(f,-1,sizeof(f));
    if(dfs(1,n,0))
        printf("DA");
    else
        printf("NE");
    return 0;
}
```

---

## 作者：Cipher0128 (赞：1)

一种几乎没有细节且无脑的做法。

这种按照最优策略取石子的题往往是动态规划，一般写一个记忆化搜索比较方便。

首先考虑状态。需要知道取走了哪些石子，即剩下的区间左右端点。而且还需要知道被取走的石子是怎么分配的，只关心个数。所以状态就是 $f_{i,j,k}$，表示还剩下区间 $i$ 到 $j$，先手取走了 $k$ 个，是否先手必赢。

怎么转移呢？如果有一个人已经取了 $k$ 个，则当前状态已经确定，返回。否则进行决策。决策有两种，取左端点和右端点。对于先手，他如果有一种决策能够使得下一步先手必赢，则当前步先手必赢，否则先手必输；对于后手，如果他有一种决策能够使得下一步先手必输，则当前步先手必输，否则先手必赢。

代码如下：

```cpp
#include<bits/stdc++.h>
#define for_(a,b,c) for(int a=b;a<=c;++a)
using namespace std;
int n,m;
const int N=400;
int a[N],f[N][N][N];
int dfs(int l,int r,int x,int y){
	if(f[l][r][x]>=0)return f[l][r][x];
	if(x>=m)return f[l][r][x]=0;
	if(y>=m)return f[l][r][x]=1;
	if((n-(r-l+1))&1)return f[l][r][x]=min(dfs(l+1,r,x,y+a[l]),dfs(l,r-1,x,y+a[r]));
	return f[l][r][x]=max(dfs(l+1,r,x+a[l],y),dfs(l,r-1,x+a[r],y));
}
int main(){
	cin>>n>>m;
	for_(i,1,n){
		char ch;cin>>ch;
		a[i]=ch=='C';
	}
	memset(f,0xaf,sizeof(f));
	if(dfs(1,n,0,0))cout<<"DA";
	else cout<<"NE";
	return 0;
}
```

---

## 作者：Cells (赞：1)

#### 思路

经典的一道区间 DP。

采用记搜的写法，用 $dp_{l,r,k}$ 表示 $[l,r]$ 区间时，**这个回合游戏的先手**拿到 $k$ 个红色石子能否必胜。

那这道题的前缀和就是红色石子的数量。

转移方程就是当前回合的先手的后手，这个后手有没有必胜策略，如果有先手必败，没有先手必胜。

#### 注意

因为采用记搜，所以 $dp$ 数组不能用布尔变量，因为要判断这个状态是否算过，我采用的是初始化负一。

记搜终止状态不是 $l$ 与 $r$ 相等，而是有一人拿到了 $k$ 个红色石子。

**Code**

```c++
# include <bits/stdc++.h>
# define mem(a, b) memset(a, b, sizeof (a))
using namespace std;

const int N = 3.5e2 + 10;

int n, k;
int s[N], dp[N][N][N];

bool dfs(int l, int r, int cnt){//cnt是1~l，r~n，的先手红石子数 
	if(~dp[l][r][cnt]) return dp[l][r][cnt];
	
	int sum = s[n] - (s[r] - s[l - 1]);//区间红石子总数 
	if(sum - cnt >= k || !dfs(l + 1, r, sum - cnt) || !dfs(l, r - 1, sum - cnt)) dp[l][r][cnt] = 1;//如果先手的后手无法必胜，先手必胜，或者后手拿到 k 个红色石子 
	else dp[l][r][cnt] = 0;//必败 
	return dp[l][r][cnt];
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	char ch;
	mem(dp, -1);//初始化 
	
	cin >> n >> k;
	for(int i = 1; i <= n; i ++){
		cin >> ch;
		s[i] = s[i - 1] + (ch == 'C');//红色才有贡献 
	}
	
	if(dfs(1, n, 0)) cout << "DA";
	else cout << "NE";
	
	return 0;
}
```

**谢谢你能看到这里！！！**

---

## 作者：Tsawke (赞：1)

# COCI2021-2022 Contest1 T2 题解

[TOC]

## [更好的阅读体验戳此进入](http://blog.monkey-hyx.tech?t=COCI-2021-2022-Contest1)

（建议您从上方链接进入我的个人网站查看此 Blog，在 Luogu 中图片会被墙掉，部分 Markdown 也会失效）

## [原题面链接](https://hsin.hr/coci/contest1_tasks.pdf)

## [Luogu题面](https://www.luogu.com.cn/problem/list?keyword=COCI2021-2022%231&page=1)

## T2 Kamenčići

### 题面

一行 $ (n \le 350) $ 个石头有红蓝两种颜色，$ \texttt{Alice} $ 和 $ \texttt{Bob} $ 轮流从一端取一个，对于每个人当手中有 $ K $ 个红色石子时则失败，保证会有人获胜，求出两人谁获胜。

输出在保证两人均采用最优策略的情况下，谁将会取胜。若 $ \texttt{Alice} $ 胜利输出 $ \texttt{DA} $，反之输出 $ \texttt{NE} $。

### Examples

**Input_1**

> 4 1
>
> CCCP

**Output_1**

> DA

**Input_2**

> 8 2
>
> PCPPCCCC

**Output_2**

> DA

**Input_3**

> 9 1
>
> PPCPPCPPC

**Output_3**

> NE

### Solution

先说几个乱搞的做法：

首先观察发现似乎可以贪心，如果一边红色一边蓝色显然最优方案一定是取蓝色的。

对于两边都是红色或者都是蓝色，~~我有个别的贪心方案但是假掉了~~，题解里有一个贪心方案是尽量让对方更快碰到红色，也就是找到除头尾外，哪边红色石头更近，或者找哪个蓝色石头更远，按照这个思路似乎可以切掉这道题，不过我认为这个方案正确性并不显然，有可能只是运气好数据比较水。

（贪心+随机化可以过更多点，不过因为是捆测，最后似乎还会是 $ 0 \texttt{pts} $）

 回到正解，石头个数 $ n $ 满足 $ n \le 350 $，这个数据范围显然可以区间 DP。

可以考虑令 $ dp(l, r, k) $ 表示石子仅剩下 $ \left[l, r\right] $ 的区间，轮到的人已经拿走了 $ k $ 个红色石子（这里显然因为 $ \texttt{Alice} $ 先手，轮流拿顺序固定，所以不需要将谁拿石子单独设置一维），然后考虑状态转移，当从当前区间移除一个石子的时候，会变为 $ \left[l + 1, r\right] $ 或 $ \left[l, r - 1\right] $，然后取石子的人就变成了另一个，这时区间的维度已经考虑好了，就需要考虑 $ k $ 如何计算。 

显然对于整个区间的红色石子是由三部分构成：区间内红色 + $ \texttt{Alice} $ 取走的 + $ \texttt{Bob} $ 取走的。

考虑用前缀和维护每个区间内的红色石子，我们又已经知道当前这个人取走的数量，那么设转移后的 $ k $ 为 $ k' $，那么就有：
$$
k' = sum(N) - ( sum(r) - sum(l - 1) ) - k
$$
考虑到对手之间获胜状态相反，所以需要取反。考虑到两人均选择最优方式挑选，所以需要或运算。

于是就会有如下状态转移方程：
$$
dp(l, r, k) = \neg dp(l + 1, r, k') \vee \neg dp(l, r - 1, k')
$$
此时考虑到边界条件就可以得出最终方程：
$$
dp(l, r, k) = \left\{
	\begin{array}{ll}
	\texttt{false} &\quad k > K \\
	\texttt{true}  &\quad k' > K \\
	\neg dp(l + 1, r, k') \vee \neg dp(l, r - 1, k') &\quad \texttt{otherwise}
	\end{array}
\right.
$$
考虑到初始化较为复杂，可以考虑 $ \texttt{dfs} $ + 记忆化搜索。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;

template<typename T = int>
inline T read(void);

int N, K;
bool stone[400];
int sum[400];
int dp[400][400][400];
int DFS(int l, int r, int k){
    if(~dp[l][r][k])return dp[l][r][k];
    if(k >= K)return false;
    int k_ = sum[N] - (sum[r] - sum[l - 1]) - k;
    if(k_ >= K)return true;
    return dp[l][r][k] = (!DFS(l + 1, r, k_) | !DFS(l, r - 1, k_));
}

int main(){
    memset(dp, -1, sizeof(dp));
    N = read(), K = read();
    for(int i = 1; i <= N; ++i){
        char c = getchar(); while(c != 'C' && c != 'P')c = getchar();
        stone[i] = (c == 'C' ? true : false);
        sum[i] = sum[i - 1] + stone[i];
    }
    printf("%s\n", DFS(1, N, 0) ? "DA" : "NE");
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template<typename T>
inline T read(void){
    T ret(0);
    short flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2022_08_30 T1-T3

update-2022_09_01 完成一部分的 T4

update-2022_09_02 T4 肝完

update-2022_09_04 初稿

update-2022_09_04 发现 T4 之前算法假掉了，修改了一下

update-2022_09_06 完善 latex 以符合 Luogu 题解要求

---

## 作者：A_Sunny_Day (赞：1)

## [COCI2021-2022#1] Kamenčići

题目链接：[P7928 [COCI2021-2022#1\] Kamenčići - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P7928)

---

​	容易想到一个状态 $dp_{l,r,a,b,0/1}$ 表示还剩 $[l,r]$ 这个区间没拿， Alice 拿了 $a$ 块红石头，Bob 拿了 $b$ 块红石头，且当前是 Alice/Bob 选择拿石头，最后的胜者是谁。那么转移就是暴力转移。

``
dp_{l,r,a,b,0}=dp_{l+1,r,a,b+(s[l]=='C'),1}==1 && dp_{l,r-1,a,b+(s[r]=='C'),1}==1
``
	
类似的，我们可以写出 $opt=1$ 时的转移式。

​	注意到，由于总共的红石头数不变，一个区间内红石头数也不变，所以我们只要知道其中一个人拿了几块石头就可以用前缀和算出另外一个人拿了几块石头。

​	那么就优化了一维，时空复杂度为 $O(n^3)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 355;
bool Small;
int n,K,suml[MAXN],sumr[MAXN];
int dp[MAXN][MAXN][MAXN][2];
char s[MAXN];
bool Sunny;
int dfs(int l,int r,int k,int opt)
{
	if(suml[l-1]+sumr[r+1]-k==K) return opt;
	if(dp[l][r][k][opt]!=-1) return dp[l][r][k][opt];
	int tmp1,tmp2;
	tmp1=dfs(l+1,r,suml[l-1]+sumr[r+1]-k,opt^1);
	tmp2=dfs(l,r-1,suml[l-1]+sumr[r+1]-k,opt^1);
	int ans;
	if(opt) ans=(tmp1==1||tmp2==1);
	else ans=(tmp1==1&&tmp2==1);
	return dp[l][r][k][opt]=ans;
}
int main()
{
	memset(dp,-1,sizeof dp);
	scanf("%d %d",&n,&K);
	scanf("%s",s+1);
	for(int i=1;i<=n;++i)
		suml[i]=suml[i-1]+(s[i]=='C');
	for(int i=n;i>=1;--i)
		sumr[i]=sumr[i+1]+(s[i]=='C');
	if(dfs(1,n,0,1)) printf("DA\n");
	else printf("NE\n");
	return 0;
}
```



---

## 作者：__xsy2013__ (赞：1)

考虑记忆化搜索。设 $f_{i,j,k}$ 的意思是在 $[l,r]$ 中游戏，先手已取红色鹅卵石 $k$ 个，先手是否为必胜，进而则可以求出后手的红色鹅卵石的数量 $t$。

状态转移方程：

$$f_{i,j,k}=\lnot f_{l+1,r,t} \lor f_{l,r-1,t}$$

复杂度 $O(N^3)$，直接过。

---

## 作者：uncle_steve (赞：0)

博弈题。

$n\le 350$，比较小，可以考虑一个大概不超过 $O(n^3)$ 的 dp。

考虑一个状态有三个要素：

左右端点和，以及共取了多少个红色石子（只需要记录一个人的，因为另一个以及可以据此确定）。

那么定义：

$f(l,r,c)$ 表示当前操作者面对的局面是，之前以及取过 $c$ 个红石子，现在剩下了区间 $[l,r]$，是否有必胜策略。

根据必胜必败态定理得到转移：

$f(l,r,c)=\urcorner f(l-1,r,c) \lor \urcorner f(l,r,c)$，$c$ 是计算得到的对方取过的红石子数。

复杂度 $O(n^3)$，可以分析性质得到 $O(n^2)$ 解法。

---

## 作者：Autream (赞：0)

#### 题意简述
一个长度为 $N$ 的字符串 $S$，仅由 `C` 和 `P`  组成。轮流每次从两端取出一个字符，先取出 $K$ 个 `C` 的失败，求先手必胜还是必败。

---
#### 题目分析
考虑区间 DP，设 $dp_{l,r,k}$ 表示取到还剩区间 $[l,r]$，当前轮到的人已经取了 $k$ 个 `C`，当前状态是必胜还是必败。

因为只剩一个石子的状态是确定的，所以区间从少往多转移，即区间 $[l,r]$ 从区间 $[l+1,r]$ 和 $[l,r-1]$ 转移。

下一个取得的数量 $t$ 怎么求？

假设我们取到了 $[l,r]$，并且当前有 $k$ 个 `C` 被取了，那么 $t$ 就是区间 $[l-1,r+1]$ 的 `C` 的数量减去现在的 $k$，用前缀和维护。

由于相邻的两个状态相反，所以转移的时候需要取反。

状态转移方程：
$$
dp_{l,r,k}=\lnot \ dp_{l+1,r,t} \vee \lnot \ dp_{l,r-1,t}
$$

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=355;
int32_t n,K,dp[N][N][N/2],sum1[N],sum2[N];
std::string s;
int dfs(int l,int r,int k){
    if(dp[l][r][k]!=-1){
        return dp[l][r][k];
    }
    if(k>=K){
        return 0;
    }
    int t=sum1[l-1]+sum2[r+1]-k;
    if(t>=K){
        return 1;
    }
    int ans=(!dfs(l+1,r,t)|!dfs(l,r-1,t));
    return dp[l][r][k]=ans;
}
signed main() {
    std::cin>>n>>K>>s;
    s=" "+s;
    mem(dp,-1);
    rep(i,1,n){
        sum1[i]=sum1[i-1]+(s[i]=='C');
    }
    dep(i,n,1){
        sum2[i]=sum2[i+1]+(s[i]=='C');
    }
    if(dfs(1,n,0)){
        puts("DA");
    }else{
        puts("NE");
    }
    return 0;
}
```

---

## 作者：Glacial_Shine (赞：0)

# 题目大意
给定长为 $n$ 一个石子序列，其中的石子有红色和蓝色，可以从左边和右边取。

两个人开始取石子，谁先取到 $k$ 个石子就输，求先手是否必胜。

# 思路
$n$ 比较小，考虑记搜。

设 $f_{l,r,k_1,k_2}$ 表示现在剩的石子序列是 $l$ 到 $r$，先手再取 $k_1$ 个红色石子就输了，后手再取 $k_2$ 个红色石子就输了，此时先手是否必胜。

然后直接记搜即可。

看看时间复杂度，看状态似乎是 $O(n^2\cdot k^2)$ 的，但其实你确定 $l$，$r$，$k_1$ 即可确定 $k_2$，所以时间复杂度是 $O(n^2\cdot k)$ 的。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k;
char s[405];
map<pair<int, int>, int> bz[355][355];
int dfs(int l, int r, int x1, int x2) {
    if (x1 == 0)
        return 2;
    if (x2 == 0)
        return 1;
    if (bz[l][r][{ x1, x2 }])
        return bz[l][r][{ x1, x2 }];
    int t1 = dfs(l, r - 1, x2, x1 - (s[r] == 'C')), t2 = dfs(l + 1, r, x2, x1 - (s[l] == 'C'));
    if (t1 == 2 || t2 == 2)
        bz[l][r][{ x1, x2 }] = 1;
    else
        bz[l][r][{ x1, x2 }] = 2;
    return bz[l][r][{ x1, x2 }];
}
int main() {
    scanf("%d%d", &n, &k);
    scanf("%s", s + 1);
    if (dfs(1, n, k, k) == 1)
        printf("DA");
    else
        printf("NE");
    return 0;
}
```


---

## 作者：2020tanjunming (赞：0)


可以看出这道题要用区间 DP。

设 $f_{i,j,v}$ 表示当前这段石头是原来 $n$ 个石头的第 $i$ 个到第 $j$ 个，且 Bob 手中有 $v$ 块红色石头，最后是否是 Alice 获胜。因为在确定左右边界的情况下，被拿走的红色石头的数量是一定的，所以 Alice 手中的红色石头可以由被拿走的红色石头减去 Bob 手中的红色石头得出，是确定的，不需要记录状态。

直接 DP 好像不太方便，我们考虑记忆化搜索。求 $f_{i,j,v}$ 的时候，去搜索下一步的结果，在以此来得出 $f_{i,j,v}$ 的值。当 Alice 或 Bob 手中的红色石头为 $k$ 时，胜负就已经确定，不需要再向下搜索了，所以 $v\leq k$。

最多会搜索到 $n^2k$ 种状态，所以时间复杂度为 $O(n^2k)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[355][355][205];
char s[355];
bool dfs(int l,int r,int v1,int v2,int fl){
	if(f[l][r][v2]!=-1) return f[l][r][v2];
	if(v1>=k) return f[l][r][v2]=0;
	if(v2>=k) return f[l][r][v2]=1;
	if(fl==1){
		if(l==r) return f[l][r][v2]=0;
		if(dfs(l+1,r,v1+(s[l]=='C'),v2,2)||dfs(l,r-1,v1+(s[r]=='C'),v2,2)) return f[l][r][v2]=1;
		else return f[l][r][v2]=0;
	}
	else{
		if(l==r) return f[l][r][v2]=0;
		if(!dfs(l+1,r,v1,v2+(s[l]=='C'),1)||!dfs(l,r-1,v1,v2+(s[r]=='C'),1)) return f[l][r][v2]=0;
		else return f[l][r][v2]=1;
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	memset(f,-1,sizeof(f));
	if(dfs(1,n,0,0,1)) printf("DA");
	else printf("NE");
	return 0;
}
```

---


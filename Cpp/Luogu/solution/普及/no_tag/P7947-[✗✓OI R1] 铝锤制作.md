# [✗✓OI R1] 铝锤制作

## 题目背景

DPair 打算用米德拉什给大家带来笑容。

因为 Lillia 不知道什么是米德拉什，所以打算阻止 Ta。  

为了阻止 DPair，你需要制作一个小铝锤。

如果你不知道如何制作小铝锤，你可以参考题目下方给出的视频。

或者，你也可以选择做这场月赛的签到题。

## 题目描述

构造一个正整数数列 $a$，使 $a$ 中所有元素之积为 $n$，所有元素之和为 $k$。如果不存在这样的数列，输出 `-1`。

## 说明/提示

**【样例解释】**

对于样例一，显然有 $1\times67=67,1+67=68$。  
对于样例二，可以证明没有合法的解。

**【数据范围】**

对于 $10\%$ 的数据，$1\leq n,k \leq 3$；  
对于 $30\%$ 的数据，$1\leq n,k \leq 10$；  
另有 $10\%$ 的数据，$n=k$；  
对于 $100\%$ 的数据，$1\leq n,k \leq 100$。

![](bilibili:av498389435)

## 样例 #1

### 输入

```
67 68```

### 输出

```
2
1 67```

## 样例 #2

### 输入

```
100 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
80 16```

### 输出

```
6
1 1 4 5 1 4```

# 题解

## 作者：InterN_NOT_FOUND (赞：16)

~~忘了打月赛了掉了很多比赛咕值所以写篇题解防止掉绿~~。

**这个题意就是让我们把** $n$ **拆成若干数相乘的形式**，**使这些数相加等于** $k$ 。

所以很快就能想到一个方法：质因数分解。

把 $n$ 质因数分解后再拿分解后的因数加起来凑成 $k$ 就好了。

上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline bool isnum(char ch){return ch>='0'&&ch<='9';}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isnum(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isnum(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void out(int x,char ch){
    if(x<0){putchar('-');x=-x;}
    if(x>9)out(x/10,'/');
    putchar(x%10+'0');
    if(ch=='l')putchar('\n');
    if(ch=='s')putchar(' ');
}

//习惯用缺省源

int n=read(),k=read(),a[114514],len,sum;
signed main()
{
	for(int i=2;i<=n;i++){//质因数分解
		while(n%i==0){
			a[++len]=i;
			n/=i;
			sum+=i;
		}
	}
	if(sum==k){//如果分解后所有因数的和等于k，那直接输出即可
		out(len,'l');
		for(int i=1;i<=len;i++)out(a[i],'s');
	}
	if(sum<k){//如果分解后所有数的和小于k，那在后面补1即可（不改变积）
		out(len+k-sum,'l');
		for(int i=1;i<=len;i++)out(a[i],'s');
		for(int i=1;i<=k-sum;i++)out(1,'s');
	}
	if(sum>k){out(-1,'l');return 0;}//如果分解后所有数的和大于k，那么就不存在这样的数列。因为除1以外的正整数相乘积都不可能小于它们的和。
	return 0;
}
```

---

## 作者：Elgo87 (赞：9)

[原题传送门](https://www.luogu.com.cn/problem/P7947) | [博客食用效果更佳](https://393864.blog.luogu.org/p7947-ti-xie)

### 题意
本次比赛的水题，是一道构造题。

给出 $n,k$，你需要构造一个序列，使得序列元素之和为 $k$，元素之积为 $n$。

### 思路

构造时先保证序列元素之积为 $n$。

想要保证元素之积为 $n$，可以把 $n$ 分解质因数，这样一来得到的几个质因数之积就等于 $n$。

再保证元素之和为 $k$。

在元素之积 $n$ 不变的情况下，可以一直往序列中放 $1$，这样可以在 $n$ 不变的情况下改变元素的和。

例如对于 $n=80,k=16$，把 $n$ 分解质因数的结果是 $n=2\times2\times2\times2\times5$。这几个质因数的和为 $2+2+2+2+5=9$，所以可以往序列里加 $16-9=7$ 个 $1$，于是最终的序列就是 $2,2,2,2,5,1,1,1,1,1,1,1$。

具体而言，实现步骤：

1. 把 $n$ 分解质因数，记质因数的和为 $s$。

2. 判断：

	- 若 $k=s$：最终的序列就是这些质因数。
    
    - 若 $k<s$：无解。
    
    - 若 $k>s$：往质因数中加 $(k-s)$ 个 $1$，最后得到的序列就是答案。

---

## 作者：苏联小渣 (赞：7)

## 题目大意

构造数列 $a$, 使得 

$$ \prod_{i=1}^{t_a}a_i=n,\sum_{i=1}^{t_a}a_i=k$$

**以下部分中 $t_x$ 均表示 $x$ 数列中元素个数。**

## 分析

本题有两个量：和与积。我们考虑维护一个量，枚举另一个量是否符合。由于维护和的枚举量比较大，所以考虑维护乘积 $n$。

对于乘积 $n$ ，我们从 1 开始，一个个寻找 $n$ 的约数。不断地除以这个约数并且存入数列中，直到不可约为止。在每一次存入数列时，我们判断目前累加的和再加上剩下的数（也就是分拆的约数和）是否**小于等于**所要求的和 $k$。（注意是**小于等于**，因为如果和不够可以补 1，而 1 对积则没有影响）如果是，就可以直接输出答案。

如果循环结束仍没有找到解，输出 -1。

那么如何证明这个构造法正确呢？（证明部分其实可以跳过）

**引理** （小学数学结论）积一定，差小和小。

**证明**  考虑极端情况：当这个数已经被分拆成为所有质因数相乘的形式时，我们可以将这个分拆过程看作**不断寻找差最小的两个约数，直到不可约为止**。此时得出的所有约数之和一定是最小的，即：

$n=w_1\times w_2$ $······$ $(A)$ ，其中 $w_1,w_2$ 是 $n$ 中最接近的两个约数。

$(A)=v_1 \times v_2 \times v_3 \times v_4$ ，其中 $v_1,v_2$ 是 $w_1$ 中最接近的两个约数, $v_3,v_4$ 是 $w_2$ 中最接近的两个约数。

如此分解，直到 $n=p_1 \times p_2 \times ··· \times p_{t_p}$，其中数列 $p$ 均为质数。那么一定有：

$$\sum_{i=1}^{t_p}p_i \leq ··· \leq \sum_{i=1}^{t_v} v_i \leq \sum_{i=1}^{t_w} w_i \leq n$$

即 $p_1,p_2···p_{t_p}$ 为所有分拆方案中和最小的。如果最小的和都比题目要求的 $k$ 大，那么一定没有满足题意的方案。

反之，若不比 $k$ 大，一定存在一种方案：即**不断加 1，直到等于 $k$ 为止**。

至此证毕。

总结：本题虽然简单，但还是一道值得思考的构造题，尤其是构造方案的正确性。

### Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, p, s;
int a[1007];
int main(){
	scanf ("%d%d", &n, &k);
	m = n;//n随时变化，所以要先赋值给m 
	for (int i=2; i<=m; i++){
		while (n % i == 0){
			a[++p] = i, n /= i, s += i;
			if (s + n <= k){
				a[++p] = n;//注意一定要把剩下的数存入数组中 
				int yu = k - s - n;
				printf ("%d\n", p + yu);
				for (int j=1; j<=yu; j++) printf ("1 ");
				for (int j=1; j<=p; j++) printf ("%d ", a[j]);
				return 0;
			}
		}
	}
	puts ("-1");
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：7)

首先，拿到本题，容易看出这是一个高质量数学题，抛出个引理，证明写在最后：当 $2\le a,b$ 时 $a+b\le a\times b$，由这个东西，我们就容易想到分解质因数，所以我们先分解质因数，得到所有质因数的和 $sum$，在不影响积的情况下，我们再输出 $k-sum$ 个 $1$ 就行了，时间复杂度 $O(n)$。
### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,sum;
vector<int> vec;
int main(){
	scanf("%d%d",&n,&k);
	for(int i=2;i<=n;i++){
		while(n%i==0){
			vec.push_back(i);
			n/=i;
			sum+=i;
			if(sum>k){
				puts("-1");
				return 0;
			} 
		}
	}//质因数分解
	int w=k-sum,l=vec.size();
	cout<<w+l<<endl;
	for(int i=1;i<=w;i++)
		printf("1 ");
	for(int i=0;i<l;i++)
		printf("%d ",vec[i]); 
	return 0;
}
```
### 正确性证明
首先，我们回到这个引理的最本质：两个大于等于 $2$ 的数的和一定小于等于它们的积。首先，我们把原式转化成这样：$a(\frac{b}{a}+1)\le ab$，即 $\frac{b}{a}+1\le b$ ，因为 $2\le a$，所以左边的最大值为 $\frac{b}{2}+1\le b$，解不等式得 $2\le b$，与题意相符，得证！综上所述，当 $2\le a,b$ 时 $a+b\le a\times b$。

---

## 作者：Naptie (赞：5)

题目要求构造一个序列（元素均为正整数），使得各元素之积为 $n$，之和为 $k$。

一种简单的构造方案如下：

考虑到 $1$ 乘任何数都得任何数，因此序列中的 $1$ 并不会对积做贡献，我们可以先把元素之积 $n$ 凑出来，最后和不够可以补 $1$。

但是单个数越大，可操作的空间就越小——  
如 $n = 24, k = 9$ 时，如果单纯地将 $24$ 分成 $4$ 和 $6$，和会超过 $k$，程序会认为在该条件下无法构造出一个合法的序列。

因此，我们如果要最大限度地构造出合法的序列，需要使每个数都尽量地小。由此引出**对 $n$ 进行质因数分解**这样的做法。

具体的做法是：
1. 对 $n$ 进行质因数分解，并将分解得到的质因数加入答案序列
2. 设质因数之和为 $s$：
   - 若 $s < k$，则将 $k - s$ 个 $1$ 加入答案序列，最终输出答案序列；
   - 若 $s = k$，则直接输出答案序列；
   - 若 $s > k$，则无解，输出 $-1$。

```cpp
#include <cstdio>

int n, k, m, f = 2, s, a[1010];

inline void get_prime_factors() {
	while (f * f <= n) {
		while (n % f == 0) {
			a[++m] = f; // 将质因数加入答案序列
			s += f; // 统计质因数的和
			n /= f;
		}
		f++;
	}
	if (n != 1) {
		a[++m] = n;
		s += n;
	}
}

int main() {
	scanf("%d%d", &n, &k);
	get_prime_factors();
	
	if (s > k) {
		puts("-1");
		return 0;
	}
	
	for (int i = s; i < k; i++) {
		a[++m] = 1;
	}
	
	printf("%d\n", m);
	
	for (int i = 1; i <= m; i++) {
		printf("%d%c", a[i], " \n"[i == m]);
	}
	
	return 0;
}

```

---

## 作者：Nygglatho (赞：2)

先从 $n \le k$ 的情况考虑，那么输出方案即为先输出 $n$，再输出 $k - n$ 个 $1$。

为什么呢？

因为，$n + 1$ 正好比 $n \times 1$ 多 $1$，输出 $n - k$ 个 $1$ 以后，比原来多 $n - k$ 来，而 $n \times 1$ 则是 $n$ 本身，那么符合题意，构造方案正确。

接下来考虑其余情况。可以考虑先把 $n$ 质因数分解，变成一个数组 $a$，这样 $a$ 序列的和就小于等于 $n$ 了。

因为由于 $a$ 是通过质因数分解得到的，所以 $a$ 序列所有数相乘等于 $n$，$a$ 序列所有数相加**一定小于等于** $a$ 序列所有数相乘。

至于为什么会这样，首先，$a$ 序列所有数因为是**由 $n$ 质因数分解而来的**，所以**必定为质数**，而众所周知，质数大于等于 $2$，这是非常关键的。

如果 $a$ 序列中只有两个元素 $a_1, a_2$，那么因为 $a_1, a_2 \ge 2$，所以是这样的：

- 如果 $a_1 \le a_2$，则 $a_1 + a_2 \le 2 \times a_2 \le a_1 \times a_2$。
- 反之，如果 $a_1 > a_2$，则 $a_1 + a_2  < 2 \times a_1 \le a_1 \times a_2$。

同样，如果有三个元素，$a_1, a_2, a_3(a_1, a_2, a_3 \ge 2)$，那么，$(a_1 + a_2) \times a_3 \le a_1 \times a_2 \times a_3$，并且，$a_1 + a_2 + a_3 \le (a_1 + a_2) \times a_3$，因为我们可以把 $a_1 + a_2$ 看成一个整体，这样又变成了只有两个元素时的情况了，所以，$(a_1 + a_2 + a_3) \le (a_1 + a_2) \times a_3 \le (a_1 \times a_2 \times a_3)$，以此类推。

如果这样，$a$ 序列元素相加之和还是大于 $k$，那么输出`-1`，因为没有合适的方案，同时由于 $a$ 序列中全都是质数，**无法继续分解了**。否则，可以考虑先算出 $a$ 序列相加之和，设为 $q$，再输出 $a$ 序列所有元素和 $k - q$ 个 $1$。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int t[101], sz_t, zhs = 2, q;

int main() {
	int n, k, p;
	cin >> n >> k;
	p = n;
	while(p > 1) {//分解质因数
		while(p % zhs == 0) {
			
			t[++sz_t] = zhs;
			p /= zhs;
		}
		++zhs;
		
	}
	if (p > 1) t[++sz_t] = p;
	for (int i = 1; i <= sz_t; ++i) q += t[i];
	if (q > k) return puts("-1"), 0;//无解情况
	else {
		cout << sz_t + (k - q) << endl;//输出
		for (int i = 1; i <= sz_t; ++i) cout << t[i] << ' ';
		for (int i = q + 1; i <= k; ++i) cout << 1 << ' ';
	}
}
```

---

## 作者：_easy_ (赞：1)

# 思路
判断 $n$ 和 $k$ 的大小，如果 $n \le k$，就将答案数组的第一项设为 $n$，其他设为 $1$。否则如果 $n$ 是质数，就输出 $-1$。否则就将 $n$ 分解质因数，依次放进答案数组中。详细解析见代码。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,m,a[1005];
int z(int n){
	for(int i=2;i*i<=n;i++){
		if(n%i==0){
			return i;
		}
	}
	return 1;
}//返回n的第一个因子，如果n是质数就返回1。
int main(){
	cin>>n>>k;
	if(n<=k){
		a[1]=n;
		k-=n;
		for(int i=1;i<=k;i++){
			a[i+1]=1;
		}
		m=k+1;
	}else{
		if(z(n)==1){
			cout<<-1;
			return 0;
		}//是质数就输出-1。
		a[++m]=z(n);
		k-=z(n);
		n/=z(n);//先放一个进入数组。
		while(n>k&&k>0){
			if(z(n)==1){
				break;
			}
			a[++m]=z(n);
			k-=z(n);
			n/=z(n);//一定要更新和和积。
		}
		if(k<0||(k==0&&n!=1)){
			cout<<-1;
			return 0;
		}//如果剩下的和小于0或者剩下的积不为1，就输出-1。
		a[++m]=n;//将剩下的积放入数组。
		k-=n;//最后要更新一次k，因为后面不会再用到n，就不用更新n了。
		for(int i=1;i<=k;i++){
			a[++m]=1;
		}//将剩下的用1填充。
	}
	cout<<m<<endl;
	for(int i=1;i<=m;i++){
		cout<<a[i]<<" "; 
	}
	return 0;
}
```

---

## 作者：19ty84 (赞：1)

## 题目描述
构造一个正整数数列 $a$，使 $a$ 中所有元素之积为 $n$，所有元素之和为 $k$。如果不存在这样的数列，输出 `-1`。

$1\leq n,k \leq 100$，要求 $a$ 的长度不超过 $1000$。

## 分析
不难发现，当 $x,y \geqslant 2$ 时，$x + y \leqslant xy$。因此，分解质因数是和最小的分解方式。

我们将 $n$ 分解质因数，若 $n$ 的所有质因数之和大于 $k$，则无法构造出这样的数列。

若 $n$ 的所有质因数之和小于 $k$，我们可以用 $1$ 将其补足。$n$ 和 $k$ 最大为 $100$ ，因此使用这种方法时，$a$ 的长度在最坏情况下（$n$ 为 $1$，$k$ 为 $100$）也不会超过 $100$。

## 代码
~~码风很丑，将就看着吧~~
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,k,ans,s[1002],ss;
int main(){
	cin>>n>>k;
	for(int i=2;i*i<=n;i++){
		while(n%i==0){
			ans+=i;
			s[++ss]=i;
			n/=i;
		}
	}
	if(n>1){
		ans+=n;
		s[++ss]=n;
		n=1;
	}
	if(ans>k){
		cout<<-1;
		return 0;
	}
	cout<<ss+k-ans<<endl;
	for(int i=1;i<=ss;i++)cout<<s[i]<<" ";
	for(int i=1;i<=k-ans;i++)cout<<1<<" ";
	return 0;
}
```

## 总结
大家打题还是要看数据范围啊，我没看数据范围，想了很久，然后发现直接分解质因数都不会超……

---

## 作者：StayAlone (赞：0)

### 题意
构造一个正整数数列 $a$，使 $a$ 中所有元素之积为 $n$，所有元素之和为 $k$。如果不存在这样的数列，输出 `-1`。  

### 思路  

显然有一个数的所有分解方式中，质因数分解后每个因数之和最小。例如
$$
8 = 1\times 4 = 2 \times 4 = 2\times 2 \times 2
$$  

其中各因数之和最小的方法是 $2\times 4$ 和 $2\times 2\times 2$。其中后者就是分解质因数。  

由于不限制数组长度，所以先将 $n$ 分解质因数存到数组，并求和 $sum$。若有 $sum > k$，无解；若 $sum = k$，直接输出这个数组长度和各质因数即可；若 $sum < k$，往后面加上 $k - sum$ 个 $1$，不改变乘积，并让现在的和变为 $k$。

```cpp
#include <bits/stdc++.h>
#define rep1(i, j, n) for (int i = j; i <= int(n); ++i)
#define rep2(i, j, n) for (int i = j; i >= int(n); --i)
#define ......
using namespace std;
typedef long long ll;
typedef ......
const int MAXN = 1e5 + 10, inf = ~0U >> 2, INF = ~0U >> 1;
const int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
namespace stupid_lrc
{
	template <typename T>
	il void read(T &x)
    
    il int read()
	
	template <typename T>
	
	template <typename T>
	
	template <typename T>
	
	template <typename T>
	
	il string ItS(int k)
	
	il int StI(const string &s)
}
// 奇妙缺省源
using namespace stupid_lrc;
int n, k, a[1010];

int main()
{
	read(n); read(k);
	int idx = 0, p = n;
	rep1(i, 2, n)
		while (p % i == 0) a[++idx] = i, p /= i;
	int sum = 0;
	rep1(i, 1, idx) sum += a[i];
	if (sum > k) return puts("-1"), 0;
	while (sum < k) ++sum, a[++idx] = 1;
	write(idx); ptc('\n');
	rep1(i, 1, idx) write(a[i]), ptc(' ');
	rout;
}
```

---

## 作者：Shunpower (赞：0)

## 思路

考虑先构造数列使得乘积等于 $n$。

明显地，直接对 $n$ 分解质因数即可。由于这样分解出来的数列具有最小和，所以判断仅由 $n$ 质因数组成的数列和 $sum$ 与 $k$ 的大小关系即可。

如果 $sum=k$，就可以直接输出了。但是 $sum<k$ 怎么办呢？考虑在不改变乘积的基础上使得 $sum$ 变到 $k$。

显然往数列里添加 $1$ 可以使得乘积不变，$sum$ 增大。

所以程序的步骤应该很明确了：先给 $n$ 分解质因数，然后判断质因数数列的和 $sum$ 是否 $>k$，如果是，直接输出 $-1$；否则往数列里面添加 $1$ 直到和为 $k$。

## 代码

### 2.1 分解质因数

```
void change(int x){//这函数名是乱取的
	int k=x;
	for(int i=2;i<=k;i++){
		while(x%i==0){
			p.push_back(i);
			sum+=i;
			x/=i;
		}
	}
}
```

首先先把 $2$ 从 $x$ 里面分解完全，接下来 $x$ 就不再是任何 $2$ 的倍数的倍数。其它质数同理。

最终 $n$ 就被分成了质因数加到了 $p$ 这个`vector`里面，$sum$ 存的是 $n$ 质因数的和。

### 2.2 主程序

```
int main(){
	cin>>n>>k;
	change(n);
	if(sum<k){
		for(int i=sum;i!=k;i++){
			p.push_back(1);//加1
		}
	}
	if(sum>k){
		puts("-1");//判无解
		return 0;
	}
	cout<<p.size()<<endl;
	for(int i=0;i<p.size();i++){
		cout<<p[i]<<' ';
	}
	puts("");
	return 0;
}
```

很好理解。

## AC 记录

[赛时 AC 记录](https://www.luogu.com.cn/record/62435627)

---

## 作者：ZZQF5677 (赞：0)

### 引子
这题当然可以用搜索。但很容易超时，可能会超 $3$ 个点。因为时间卡的很紧，只有 $500ms$。

### 思路
我们需要让 $n$ 的因数尽可能小，最好让最后所有的因数加起来的“因数和” $s$ 别大于 $k$ 就行，但途中如果不能找出一项 $a_i$ 那就输出 `-1` 在退出。然而剩下的 $k - s$ 的差全用 $1$ 来弥补就行，之所以用 $1$ 补，是因为我们发现一个积乘以无数个 $1$ 还是自己，就可以用这一点，不会改变 $n$，只会凑出 $k$。

### 代码

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
int sum[1005] = {0}, cnt, n, k, s;
int main() {
  cin >> n >> k;
  // 下面为给 n 找出所有因数代码。
  while (n != 1) {                  // n 没有因数了。
    for (int i = 2; i <= n; i++) {  // n还有因数时（现在别找“1”，因为后面还有用。）， 要把n的因数都找出来。
      if (n % i == 0) {             // 可以尽量的小，因为可能还要预留一些“1”做因数给k做加数。
        n /= i;
        sum[++cnt] = i;  // 储存因数。
        s += i;          //将 n 的因数作为 k 的加数。
        break;
      }
    }
  }
  // cnt + (k - s) 指 n 的因数个数与待会儿要用“1”补给k的个数合起来的总个数。
  if ((cnt + (k - s)) <= 0) {
    cout << -1;
    return 0;
  }
  cout << cnt + (k - s) << endl;
  for (int i = 1; i <= cnt; i++) {
    cout << sum[i] << " ";
  }
  for (int i = 0; i < k - s /*n 的因数加起来缺的，全用“1”补上。*/; i++) {
    cout << 1 << " ";  // 大家都知道 1 可以给 k 来凑加数。并且作为因数给 n 用肯定不会改变积的。
  }
  return 0;
}
```

---

## 作者：lsy_41 (赞：0)

### 题目分析
考虑到要让乘积为 $n$ ，我们容易想到的就是将其分解质因数，同时，由于 $x\,y\,>\,x\,+\,y$，因此，当将其分解之后，所有数加起来的和应该是能达到的最小和，也就是说，如果这个和小于 $m$ ，那么就有可能，不足的和用 $1$ 来补，不会改变积，但是如果这个和大于 $m$ ，就是无解情况。

还有一个问题，题目限制 $a_i$，的大小，这显然不会超过 ```1000```，因为 $n$ ，最大才 ```100``` 嘛，同时 $m$ 也不可能超过 ```1000```，因为最多也只可能出现 ```100``` 个 $1$。

剩下的细节就放在代码里了。

------------
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, tot, m;
int p[105]; //用来存每一个质因数的个数
vector<int> C; //用来存分解的质因数
int main() {
	cin >> n >> k;
	for (int i = 2; i <= n; i++) {
		//这里并不需要判断质数，因为从小往大，非质因子一定会被前面的分解
		if (n % i == 0) {
			C.push_back(i);
			while (n % i == 0) {
				p[i]++;
				n /= i;
				tot += i; //更新最小和
				m++; //统计个数
			}
		}
	}
	if (tot > k) cout << "-1"; //无解情况
	else {
		cout << m + k - tot << endl;
		for(int t : C) { //遍历vector的简单写法
			for (int j = 0; j < p[t]; j++) {
				cout << t << " ";
			}
		}
		while (k - tot) { //不足的拿1补齐
			cout << 1 << " ";
			tot++;
		}
	}
	return 0;
}
```
完结撒花！

---

## 作者：Tzs_yousa (赞：0)

### 思路
首先，我们可以知道一个和以及一个积，然后就可以想一想什么时候无解，那显然就是这个数所有的质因数相加大于它的和啊。

因为分解质因数，我们的出来的这几个数相加一定是最小的，如果其中两个因数乘在一起，一定是大于等于原来的两因数相加的和。

那分解质因数直接用暴力分解就可以了。
```cpp
while(n > 1)
    {
        for (int i = 2; i <= n; i++)
        {
            if (n % i == 0)
            {
                n = n / i;
                a[++cnt] = i;
            }
        }
    }
    int sum = 0;
    for (int i = 1; i <= cnt; i++) sum += a[i];
    if(sum > k) cout << -1;
```
可如果最后这几个质因数相加比输入的 $k$ 小怎么办？因为 1 乘以任何一个数都为那个数，所以往前补一就可以了。

然后就是全套代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k, m, a[2001], cnt;
signed main()
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	while(n > 1)
    {
        for (int i = 2; i <= n; i++)
        {
            if (n % i == 0)
            {
                n = n / i;
                a[++cnt] = i;
            }
        }
    }
    int sum = 0;
    for (int i = 1; i <= cnt; i++) sum += a[i];
    if(sum > k) cout << -1;
    else
    {
    	cout << k - sum + cnt << endl;
    	for (int i = 1; i <= k - sum; i++) cout << 1 << " ";
    	for (int i = 1; i <= cnt; i++) cout << a[i] << " ";
	}
	return 0;
}
```


---


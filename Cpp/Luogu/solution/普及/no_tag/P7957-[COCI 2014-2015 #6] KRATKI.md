# [COCI 2014/2015 #6] KRATKI

## 题目背景

我们都非常熟悉「最长单调子序列」问题：

>给定一个长度为 $n$ 的数列，你需要求出它的 LMS（即最长单调子序列）的长度。\
>**请注意**，这里「LMS」是指「递增子序列和递增递减子序列中**更长的一个**」。\
>即需要对 LIS 和 LDS 的长度取最大值。

现在你需要解决一个 LMS 的逆问题。

## 题目描述

给定数列的长度 $n$。

你需要构造出一个 $n$ 的排列，使得它的 LMS 长度为 $k$。

## 说明/提示

#### 样例 1 说明

$\{1,4,2,3\}$ 的 **LMS** 为 $\{1,2,3\}$，长度为 $3$，符合要求。

#### 数据规模与约定

**本题采用 Special Judge。**

对于 $100\%$ 的数据，有 $1\le k\le n\le 10^6$。

#### 说明

按原题配置，满分 120 分。

译自 **[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/)** [Contest #6](https://hsin.hr/coci/archive/2014_2015/contest6_tasks.pdf) Task D _**KRATKI**_。

由于原数据没有一些特殊的数据，本题添加了数据 #11。如果你没通过它，会得到 120 Unaccept。

## 样例 #1

### 输入

```
4 3```

### 输出

```
1 4 2 3```

## 样例 #2

### 输入

```
5 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 5```

### 输出

```
1 2 3 4 5```

# 题解

## 作者：David_yang (赞：14)

[传送门](https://www.luogu.com.cn/problem/P7957)

第四篇题解，如有不妥请~~忽视~~指出。

## 题目大意：

构造一个长为 $n$ 的序列，使它的 LIS 或 LDS 刚好等于 $k$。

## 算法：

一道思维题，没有算法。

## 解析：

首先来判断无解的情况。不难发现，当 $k^2<n$ 时是不行的。举几个栗子：当 $n=6$，$k=2$ 时，构造出 `5 6 3 4 1 2`，LIS 是满足了，但 LDS 不行。我最开始想了一个序列：`1 1 1 1 1 2`。但是，如果这样可以，那么样例 $1$ 是不是可以构造成 `1 2 3 3`？可是实际情况是这样：<https://www.luogu.com.cn/record/145160568>（我还是加了这个特判的）。

所以，你现在知道为什么 $k^2<n$ 时是不行的了吧。

然后再来看看有解的情况。我这里就提供一种构造方法：我们分成 $n \div k$ 轮，每轮输出 $k$ 个连续的数，从 $n-k+1$ 开始。每轮完后，$n$ 减去 $k$。最后是不是还有剩下的？只要从 $1$ 开始把剩下的输完就可以了。

听起来有点抽象，我这次举个桃子：比如 $n=17$，$k=5$。第一轮输出 `13 14 15 16 17`，第二轮输出 `8 9 10 11 12`……最后是不是还剩下了一个 $1$ 和 $2$？直接输出就好了。就像是每次看起来马上就要超了，结果突然“柳暗花明又一村”。最后一看 LDS，也没有超。这也是为什么 $k^2<n$ 时是不行的原因，超过 $k$ 轮后，LDS 也要超。

现在解释的差不多了，最后提醒一句：**不开 long long 见祖宗！**

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main()
{
	scanf("%lld%lld",&n,&k);
	if(k*k<n)						//特判k*k>n的情况
	{
		printf("-1");
		return 0;
	}
	for(int i=n;i>=k;i-=k)			//分为n/k轮
	{
		for(int j=k;j>=1;j--)		//每轮输出连续k个数
		{
			printf("%lld ",i-j+1);	//从n-k+1开始
		}
	}
	for(int i=1;i<=n%k;i++)			//剩下的从1开始输完
	{
		printf("%lld ",i);
	}
	return 0;
}
```

注：代码已 AC，请放心食用。

最后：浏览过看过也要赞过！

---

## 作者：ikunTLE (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P7957)

### 思路

由于最长单调子序列最长为 $k$，所以我们可以每次构造 $k$ 个的序列，先输出前面的 $k$ 个数字，剩下的数字一直到 $n$ 紧接着输出完。

但是每次构造 $k$ 个，再构造 $k$ 次也达不到 $n$，所以在 $k^2<n$ 时答案是无解的。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main(){
	scanf("%d%d",&n,&k);
	if((long long)k*k<n)//注意判断无解的时候会炸int
		return printf("-1"),0;
	for(int i=n;i>=k;i-=k)//每次构造k个的序列
		for(int j=k;j>=1;--j)
			printf("%d ",i-j+1);
	for(int i=1;i<=n%k;++i)//剩下的数字紧接着输出完
		printf("%d ",i);
	return 0;
}
```

---

## 作者：漠寒 (赞：4)

## Updated

2021.12.5：修改关于判断无解的条件，感谢 @Z_301 的提醒。

## 分析

先考虑单增，最好的方式就是不断地构造出长为 $k$ 的单增序列，为保证后面序列不会成为前面单增序列的延续，每一个序列值域上需要完全高于下一个，即本段最小值大于下段最大值，同时显然如果超过 $k$ 个序列单减则会超出要求，因此 $k \times k<n$ 时，即 $k$ 个长度为 $k$ 的单增序列也无法使用全部 $n$ 个数时输出 $-1$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
}
int n,k;
signed main()
{
	read(n);read(k);
	if(1ll*k*k<n){
		puts("-1");
		return 0;
	}
	int las=n,pos=1;
	while(las>=k){//还剩多少个数没放
		for(int i=k;i>=1;i--){
			cout<<las-i+1<<" ";
		}
		pos+=k;
		las-=k;
	}
	for(int i=1;i<=las;i++){
		cout<<i<<" ";
	}
	return 0;
}
```


---

## 作者：Computer1828 (赞：3)

解题关键在于发现对于 $k^2 < n$ 无解。

如何发现上述关键点？

考虑我们先把 $[n-k+1,n]$ 放在所构造的排列最前面，现在就只需要构造剩下的 $n-k$ 个位置使得不出现长度超过 $k$ 的单调子序列。

这样子很像递归，所以我们继续构造一个长度为 $k$ 的序列 $[n-2k+1,n-k]$ 放到前一个已构造的部分排列的后面。如此继续下去，每一段都是长度不超过 $k$ 的单调序列。

然后发现从每一段抽出一个数，排成的子序列也是单调的，且长度不能超过 $k$，也就是说，段数不能超过 $k$。

所以说，若 $k^2 < n$ 则无解，否则，我一定能构造像 $[n-k+1,n][n-2k+1,n-k][n-3k+1,n-2k]$ 的排列。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	if(1ll*m*m < n) printf("-1");
	else for(int i = n;i>=1;i -= m) for(int j = max(1,i-m+1);j<=i;++j) printf("%d ",j);
	return 0;
}
```

---

## 作者：wsdyz2010 (赞：2)

## 思路
由于题目中说输出任意一种方法，所以我们直接考虑单调递增，而最简单的方法就是不断构造出长度为 $k$ 的单调递增序列。为了新构造的序列不会与上一个序列产生连接，我们需要让上一个序列的最小值严格大于当前序列的最大值，即 $\{n-k+1,\ldots,n\}>\{n-2k+1,\ldots,n-k\}$。

我们可以通过推导发现，若 $k^2 < n$，则代表无法用 $k$ 个长度为 $k$ 的单调序列使用完 $n$ 个数字，也就代表此数据无解。


------------
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,tot,sum,num[1000005],cnt;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	if(k*k<n){
		cout<<"-1";
		return 0;
	}
	for(int i=n;i>=1;i-=k)//外层循还枚举k个长度为k的子序列 
		for(int j=max(1,i-k+1);j<=i;++j)//内层循环枚举每个子序列中使用的数字 
			num[++cnt]=j;
	for(int i=1;i<=cnt;++i)cout<<num[i]<<" ";
	return 0;
}

```

---

## 作者：hh__hh (赞：1)

~~由于是任意输出一组，所以我们可以用最简单的方法来做。~~

题目要求构造一个长度为 $n$ 的排列，使得它的 $\text{LMS}$ 长度为 $k$。 $\text{LMS}$ 是指在排列中找到一个最长的单调子序列，该子序列可以是递增或递减的。

最好就是后面值域的最大值小于前面值域的最小值，这样保证构造出来的数列可以是单调递增的。但也会发现一个问题：有时候数字不够无法构造。那如何判断是否有解？

-------------------------------------------------------------------

假设我们构造的序列中的其中一个最长的 $\text{LMS}$ 长度为 $k$，那么序列中第二小的的 $\text{LMS}$ 的长度肯定小于 $k$。

在最差情况下，我们需要选择 $\frac{n}{k}$ 个递增子序列，每个子序列的长度都为 $k$。因此，整个序列的长度至少为 $\frac{n}{k} \times k = n$。

如果 $k \times k$ 小于 $n$，那么无法构造出一个长度为 $k$ 的 $\text{LMS}$。因为在这种情况下，无法选择 $\frac{n}{k}$ 个长度为 $k$ 的递增子序列，每个子序列的长度都为 $k$。

------------------------------------------------------------------

首先，我们需要判断是否存在满足条件的排列。如果 $k > n$ （或者 $k^{2} < n$，证明见上）， 则不存在满足条件的排列，因为 LMS 的长度不可能大于排列的长度。所以我们可以先判断 $k$ 是否大于 $n$ 和 $k^{2} < n$，如果是，则输出 $\texttt{-1}$。

接下来，我们可以构造一个满足条件的排列。我们可以将前 $k$ 个数按照递减顺序排列，然后将剩余的 $n - k$ 个数按照递增顺序排列。这样构造的排列的 $\text{LMS}$ 长度就是 $k$。

-----------------------------------------------------------------------

所以我们可以这么搞：

判断 $k$ 是否大于 $n$，如果是，则输出 $\texttt{-1}$。

判断 $k^{2}$ 是否小于 $n$，如果是则输出 $\texttt{-1}$。

构造一个长度为 $n$ 的数组，初始化为 $0$。

将数组的前 $k$ 个元素设置为 $k, k-1, k-2, \cdots, 2, 1$。

将数组的剩余 $n - k$ 个元素设置为 $k+1, k+2, \cdots, n$。

思路已出，代码就自己写。

---

## 作者：ryanright (赞：1)

先说一下：这道题十分乱。

原题&本题无解情况：最长单调子序列。

本题题面&本题 SPJ：最长上升子序列。

（看似是这样）

于是我们需要有一个鲁棒一点的程序以满足两个不同的题面与数据。

先考虑最长单调子序列的情况。最理想的状态就是这么两种：

![](https://cdn.luogu.com.cn/upload/image_hosting/dmxxj9xi.png)

或者

![](https://cdn.luogu.com.cn/upload/image_hosting/z2w9235y.png)

因为我们又要最长上升子序列，因此我们只需要上面的那一张图（用下面那张图好像只有十二分）。接下来我们来讨论一下在什么情况下无解。

在上图之中，$n=k\times\frac{n}{k}$，其中 $k$ 是红线长度，也就是 LIS 的长度，$\frac{n}{k}$ 是蓝线长度，也就是最长下降子序列的长度。当 $k<\sqrt n$ 的时候，$\frac{n}{k}>k$，因此 $k$ 无法成为最长单调子序列的长度，即无解。

虽然不怎么严谨，不过应该还是比较好理解的吧。

剩下的就是模拟了，依次输出 $[n-k+1,n]$、$[n-2k+1,n-k]$、$[n-3k+1,n-2k]$，以此类推。还是有一些小细节值得注意。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	if((long long)k*k<(long long)n) puts("-1");//注意要开 long long
	else
	{
		int ce=n%k?n/k+1:n/k;//向上取整
		for(int i=1;i<=ce;i++)
			for(int j=max(n-i*k+1,1);j<=n-k*(i-1);j++)
				printf("%d ",j);
	}
	return 0;
}
```

---

## 作者：Farewell_Bood (赞：0)

因为序列长度为 $k$。所以我们就构造 $k$ 个序列，先输出前 $k$ 个，在输出剩下的到 $n$。

我们构造了 $k$ 个序列，我们再次构造 $k$ 个也达不到 $n$。所以在 $k^{2} < n$ 时无解，输出 $-1$ 就行了。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	if(k*k<n){
		cout<<"-1"<<endl;
		return 0;
	}
	for(long long i=n;i>=k;i-=k){
		for(long long j=k;j>=1;j--){
			cout<<i-j+1<<" ";
		}
	}
	for(int i=1;i<=n%k;i++){
		cout<<i<<" ";
	}
	cout<<endl;
	return 0;
}
```
那么这道题就这么水灵灵的过啦！


代码已经通过，请放心食用

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 思路
因为要使最长单调子序列为 $k$ 个数字。

所以可以构造每 $k$ 个连续的数递增排列。

每 $k$ 个视为一组，降序排序：

```
k=3
789
456
123
```
可以发现，最长下降子序列取决于有多少组。

组数为 $\lceil n \div k \rceil$ 。

因此需要 $\lceil n \div k \rceil \le k$ 才可以构造成功。

等同于  $n \le k \times k$ 。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main(){
	cin>>n>>k;
	if(k*k<n)cout<<-1;//k*k爆int
	else{
		for(int i=n;i>=1;){
			for(int j=i-k+1;j<=i&&j>0;j++){
				cout<<j<<" ";
			}//k个为一组逆序输出
			i-=k;
		}
		for(int i=1;i<=n%k;i++)cout<<i<<" ";//剩下的零头
	}
	return 0;
} 
```
## 大提示
最近写的题不少都是会被 int 坑的，所以说，好好看数据范围。

这题不开会 wa 第八个点~~别问我怎么知道的~~。

---

## 作者：编程小贝壳 (赞：0)

[原题](https://www.luogu.com.cn/problem/P7957)

$2024/3/11upd:$ 更新了格式

### 题意

构造长度为 $n$ 的序列，保证最长单调上升子序列和最长单调下降子序列之中的最长者恰好为 $k$ 

### 思路

由于此题目仅需要关注数字的相对大小，因此不妨令数字取值范围是 $[1,n]$ 。首先考虑构造尽可能长的单调上升序列（即长度为 $k$ ），再使整个序列中的最长单调下降子序列长度小于 $k$ 即可。

因此我们首先选择 $[1,n]$ 内前 $k$ 大的数，放置在前 $k$ 个位置使其构成一个单调递增的序列，然后重复此操作即可。这样操作即可保证序列中最长单调下降子序列尽可能短。

特别地，如果最长单调下降子序列长度大于 $k$ ，则无解。显然在这种构造方法中最长单调下降子序列是在每个单调递增的序列中选取任意一个，因此在 $k^2<n$ 的情况下此题无解。

### 代码

~~自己写~~

---

## 作者：ZYH_juruo (赞：0)

# 题目传送门
[P7957 [COCI2014-2015#6] KRATKI](https://www.luogu.com.cn/problem/P7957)
# 题目分析
相信大家在看完题解之后都知道如果满足题意需要 $k^{2}<n$，那么我就用一个实际的样例来解释一下。
```
5 2
```

答案为 $-1$。

那么我们先考虑一下直接构造一个长度为 $2$ 的递增子序列，可以为      ```
5 6```，然后再构造一个长度为 $2$ 的递增子序列，那么就变成 ```
5 6 3 4```，请注意：后构造的子序列里的元素不能超过之前构造的子序列中的元素。最后，还剩一个数，不妨变为 ```
5 6 3 4 2```。

那么有人就要说了，这递增的子序列长度不就为 $2$ 吗？但是递减的子序列长度是 $3$！很明显不满足题意。举例论证到此结束。


# ACCODE
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
signed main()
{
	cin>>n>>k;
	if(k*k<n)
	{
		cout<<"-1"<<endl;
		return 0;
	}
	while(n>=k)
	{
		for(int i=k;i>=1;i--)
			cout<<n-i+1<<" ";
		n-=k;
	}
	for(int i=1;i<=n;i++)
		cout<<i<<" ";
	return 0;
}

```

完结撒花


---

## 作者：Teto_etf (赞：0)

我们只需要搞出来若干个长度为 $k$ 的数串往答案里面一扔就行，但是应该怎么扔呢？这里我采用的是升序排法，为了保证**我们的升序答案不会小于序列的降序答案**，我们需要从范围 $[n-k+1,n]$ 开始，不断从右往左遍历不重复的长度为 $k$ 的 $n$ 个连续整数，不难发现最终序列是：

$$(n-k+1),(n-k+2),\cdots,n,(n-2k+1),(n-2k+2),\cdots,(n-k),\cdots$$

形式化地来讲，每一个扔进去的数串范围都是 $[n-xk+1,n-(x-1)k]$，即 $[n-xk+1,n-xk+k]$。

另外可以发现，当 $n>k^2$ 时，有一些东西是扔不进去的，这样就无解了。

下面是代码。

```cpp
#include <bits/stdc++.h>
#define max(a, b) (a > b ? a : b)
using namespace std;
typedef long long ll;

ll n, k;

int main(){
	cin >> n >> k;
	if (n > k * k) {
	    cout << "-1" << endl;
	    return 0;
	}
	
    else
        for (int i = n; i >= 1; i -= k){
            int len = i - k + 1; // 当 len 已经不大于 1 了，要注意 j 从 1 开始
            for (int j = (len > 1) ? len : 1; j <= i; j++) cout << j << " ";       
        }
        
	cout << endl;
	return 0;
}
```

---

## 作者：copper_ingot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7957)

构造题，~~不是很难，也就WA了5遍吧~~

因为是任意输出一种解，所以直接考虑最简单的构造方式。

试图构造 $k$ 个下降序列，第 $a$ 个序列包含 $\max(a \times k, n)$ 到 $(a - 1) \times k + 1$，每个序列至多 $k$ 个元素，可以证明此方案可行。

证明：每个序列最多 $k$ 个元素递减，且对于所有 $1 < a \le k$，第 $a$ 个序列里的最小值大于第 $a - 1$ 个序列里的最大值，最多只有 $k$ 个不同序列的元素递增，满足题目要求。

由结论可得出，当 $k ^ 2 < n$ 时无解，输出 $-1$。

最后贴上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, k, a = 1, m;//不开long long见祖宗
int main(){
	cin >> n >> k; m = n;
	if (k * k < n){cout << -1; return 0;}//判无解
	while (m > 0){
		for (int i = max(a * k, n); i >= (a - 1) * k + 1; i--)
			if (i <= n) cout << i << " ";//输出第a个序列
		a++; m -= k;//序列编号++
	}
	return 0;
}
```

完结撒花

---

## 作者：hrgd (赞：0)

这题之前学长出到了模拟赛里，大家纷纷切了

考虑一种比较优秀的构造：形如每一段都是长度为 $k$ 的上升，每段之间没有上升关系。

比如 $n=9,k=3$ 时就是这样：7 8 9 4 5 6 1 2 3

发现这样可以解决 $k^2\geqslant n$ 的问题。

然而由经典结论：最长链 $\times$ 最长反链 $\geqslant n$，故构造不了时正好就是无解的。

这样我们就有了简洁的代码实现：
```

#include<bits/stdc++.h>
using namespace std;
int n,k,a[1000005];
int main(){
	cin>>n>>k;int cur=n,pos=1,cnt=0;
	while(pos<=n){
	    int nex=min(pos+k-1,n);cnt++;
	    for(int i=nex;i>=pos;i--)a[i]=cur--;
	    pos=nex+1;
	}
	if(cnt>k)return puts("-1")&0;
	for(int i=1;i<=n;i++)
	    printf("%d ",a[i]);puts("");
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# 1.前言
This explanation is translated from official explanation.

要掌握的：for循环
# 2.解析
- 证明

让我们试着证明一下在长度 $n$ 的任何序列中，都必须有一个长度至少为 $\sqrt n$的单调子序列。

我们有一组从左到右堆叠的堆栈，其特征是当我们到达堆栈的顶部时，数字正在上升。现在我们执行以下算法：从左到右遍历数组中的数字，将每个数字推到第一个堆栈的顶部，我们可以从左侧开始，使其保持不变，保持所有堆栈上的数字都是递增的。

1. 第一种情况：

在这个算法之后，我们得到小于或等于 $\sqrt n$ 的非空堆栈。在这种情况下，必须有一个大于或等于 $\sqrt n$ 的堆栈。在这种情况下，我们已经证明了至少一个升序子序列的长度 $\sqrt n$。

2. 第二种情况：

在这个算法之后，我们得到了超过 $\sqrt n$ 非空堆栈。我们注意到堆栈顶部的数字从左向右递减。如果他们没有下降，这意味着我们没有依照我们的想法。

在执行这个算法的过程中，由于我们推到了第一个，我们可以进行叠加，使下一个数字大于堆栈上的最后一个数字，并且我们可以推到的第一个堆栈。考虑到这一点，我们有一个下降趋势长度至少为 $\sqrt n$ 的子序列，由所有堆栈顶部的数字组成。

那么我们就能证明至少存在长度为 $\sqrt n$ 单调子序列。

- 细节处理

在这之后，很容易看到下一个构造给出了一个单调序列要求的长度 $k$，假设 $k\ge \sqrt n$，否则这样的序列不存在。

让序列的形式为 $[n-k+1,n][n-2k+1,n-k][n-3k+1,n-2k]$ 等。

每个长度为 $k$ 的子序列都有一个长度为 $k$ 的升序子序列，因为

有 $\le k$ 个这样的序列，因为 $k\ge \sqrt n$，一个长度大于 $k$ 的递减序列不存在。

---


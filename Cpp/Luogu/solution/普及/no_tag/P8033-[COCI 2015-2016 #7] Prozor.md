# [COCI 2015/2016 #7] Prozor

## 题目描述

一扇规模为 $R \times S$ 的窗户上有若干只苍蝇。现有一把苍蝇拍，它可以消灭 $K \times K$ 矩形区域内（不含边界）的所有苍蝇。

请选择一种苍蝇拍的放置位置，使得被消灭的苍蝇数量最多。输出消灭的苍蝇的最大值和该方案。如果有多种符合的方案，请输出任意一种。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$3 \le K \le R,S \le 100$。

**【提示与说明】**

欢迎大家通过私信或发帖对自行编写的 [Special Judge](https://www.luogu.com.cn/paste/luaa2ic5) 进行 hack。

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [#7](https://hsin.hr/coci/archive/2015_2016/contest7_tasks.pdf) _Task 2 Prozor_。**

**本题分值按 COCI 原题设置，满分 $80$。**

## 样例 #1

### 输入

```
3 5 3
.....
.*.*.
.....```

### 输出

```
1
+-+..
|*|*.
+-+..```

## 样例 #2

### 输入

```
7 6 4
......
.*.*.*
......
.*.*..
..*...
..*...
*....*```

### 输出

```
2
......
.*.*.*
+--+..
|*.|..
|.*|..
+--+..
*....*```

## 样例 #3

### 输入

```
9 9 6
***......
......*.*
.*....*..
..*...*..
..*.*....
..*....*.
.....*...
.*...***.
.........```

### 输出

```
6
***......
......*.*
.*....*..
..*+----+
..*|*...|
..*|...*|
...|.*..|
.*.|.***|
...+----+```

# 题解

## 作者：AmaZingFantasy (赞：10)

**题目大意：**

给你一个由 $R \times S$ 组成的字符方阵，让你找到一个 $K \times K$ 的正方形使得其中 ```*``` 字符尽可能多，并输出这个区域在方阵中的位置

**思路：**

首先来看，这道题主要分两步来写，分别是算出数量和输出方阵。

-  算数量：

本题数据范围较小， $ 3 \leq K \leq R,S \leq 100 $。对于算数来说，直接暴力就可以过。

用 $i$ 和 $j$ 两个变量枚举这个区域的右下角，再用 $x_1$ 和 $x_2$ 两个变量算出能覆盖多少个，最后找到最大值并输出就行了。本区域就不详细讲解了

- 输出

在输出最大值之后，我们还需要输出一个具体方案。我的方法比较笨一些，就是再算一遍，如果现在 ```*``` 的个数正好等于最大值，就证明现在的这个情况是最优解，我们就要输出具体方案。

首先，我们是要输出整个方阵的，这一步难就难在怎么判断是否是方框边缘的情况。我们把左上角的那个点坐标标记为 $(a,b)$，右下角的标记为 $(c,d)$，已知输出的符号只会有 $3$ 种，接下来就要分类讨论了。

1. ```+``` 符号。这种符号比较好判断，如果当前点 $(x,y)$ 等于 $(a,b)$、 $(c,d)$、 $(a,d)$ 或 $(c,b)$，我们就应该输出 ```+``` 。

2. ```-``` 符号，如果当前点和 $(a,b)$ 或 $(c,d)$ 在同一行上且在区域内，就该输出 ```-``` 。

3. ```|``` 符号，如果当前点和 $(a,b)$ 或 $(c,d)$ 在同一列上且在区域内，就该输出 ```|``` 。

剩下的就没了

**代码**

```cpp
#include <iostream>
using namespace std;
typedef long long l;
char arr[105][105];
bool cmp(l x,l y,l x1,l y1){
    return ((x==x1) && (y==y1));
}
bool cmp2(l x,l y,l x1,l y1){
    return ((x==x1) || (y==y1));
}
//定义两个用于比较的函数，用于比较点之间的关系。
int main(){
    l r,s,k;
    cin>>r>>s>>k;
    for(l i=0;i<r;i++){
        for(l j=0;j<s;j++){
            cin>>arr[i][j];//输入
        }
    }
    l n=0;
    for(l i=k-2+1;i<r;i++){
        for(l j=k-2+1;j<s;j++){
            l x=0;
            for(l x1=i-(k-2);x1<i;x1++){
                for(l x2=j-(k-2);x2<j;x2++){
                    if(arr[x1][x2]=='*'){
                        x++;
                    }
                }
            }
            n=max(n,x);
            //暴力枚举求最值
        }
    }
    cout<<n<<endl;
    for(l i=k-2+1;i<r;i++){
        for(l j=k-2+1;j<s;j++){
        //再算一遍，看是否要输出
            l x=0;
            for(l x1=i-(k-2);x1<i;x1++){
                for(l x2=j-(k-2);x2<j;x2++){
                    if(arr[x1][x2]=='*'){
                        x++;
                    }
                }
            }
            if(x==n){//若等于，要输出
                for(l x1=0;x1<r;x1++){
                    for(l x2=0;x2<s;x2++){
                        if(cmp(x1,x2,i,j) || cmp(x1,x2,i-(k-1),j-(k-1)) || cmp(x1,x2,i,j-(k-1)) || cmp(x1,x2,i-(k-1),j)){
                        	//判断是否输出'+'
                            cout<<"+";
                        }else if((cmp2(x1,x2,i,j) || cmp2(x1,x2,i-(k-1),j-(k-1))) && (x1<=i && x2 <= j && x1 >= i-(k-1) && x2 >=(j-(k-1)))){
                            if(x1==i || x1==i-(k-1)){
                                //判断是否输出'-'
                                cout<<"-";
                            }else{
                            	//否则输出'|'
                                cout<<"|";
                            }
                        }else{
                        	//如果不用输出符号的话，直接输出此位置的字符。
                            cout << arr[x1][x2];
                        }
                    }
                    cout<<endl;
                }
                //输出完了就结束程序
                return 0;
            }
        }
    }
    return 0;
}

```

完结撒花


---

## 作者：Leonid (赞：4)

[原题](https://www.luogu.com.cn/problem/P8033)

如果我们一个一个去枚举正方形的右下顶点，每次枚举的时候扫一遍正方形的和，这种方法就太慢了。

于是很容易能想到**二维前缀和**。

先做一遍 $O(RS)$ 预处理 $(1,1)$ 到 $(i,j)$ 的和，在枚举 $(i,j)$ 的过程中用预处理好的前缀和计算加和即可。

至于输出，当输出的这个点是正方形的四个顶点其中之一时输出 ```+```，当这个点是正方形横边上的点输出 ```-```，当这个点是正方形竖边上的点输出 ```|``` 即可。

```cpp
#include<cstdio>

using namespace std;

#define M 105

int r,s,k;
char c[M][M];
int num[M][M],prep[M][M];
int ans=-1,sx,sy,fx,fy;

inline bool chk1 (int x,int y) {return (x==sx&&y==sy)||(x==sx&&y==fy)||(x==fx&&y==sy)||(x==fx&&y==fy);}
inline bool chk2 (int x,int y) {return ((x==sx)||(x==fx))&&(y>=sy)&&(y<=fy);}
inline bool chk3 (int x,int y) {return ((y==sy)||(y==fy))&&(x>=sx)&&(x<=fx);}

int main(){
	scanf("%d %d %d",&r,&s,&k);
	for(int i=1;i<=r;++i) for(int j=1;j<=s;++j) scanf(" %c",&c[i][j]);
	for(int i=1;i<=r;++i) for(int j=1;j<=s;++j) if(c[i][j]=='*') num[i][j]=1;
	for(int i=1;i<=r;++i) for(int j=1;j<=s;++j) prep[i][j]=prep[i-1][j]+prep[i][j-1]-prep[i-1][j-1]+num[i][j];
	for(int i=k;i<=r;++i) for(int j=k;j<=s;++j) if(prep[i-1][j-1]-prep[i+1-k][j-1]-prep[i-1][j+1-k]+prep[i+1-k][j+1-k]>ans){
		ans=prep[i-1][j-1]-prep[i+1-k][j-1]-prep[i-1][j+1-k]+prep[i+1-k][j+1-k];
		sx=i-k+1, sy=j-k+1, fx=i, fy=j;
	}
	printf("%d\n",ans);
	for(int i=1;i<=r;++i) {
		for(int j=1;j<=s;++j){
			if(chk1(i,j)) printf("+");
			else if(chk2(i,j)) printf("-");
			else if(chk3(i,j)) printf("|");
			else printf("%c",c[i][j]);
		}	
		printf("\n");
	}
	return 0;
}
```


---

## 作者：Goodrage (赞：3)

二维树状数组 + 暴力 + 许多特判的大模拟

容我吐槽一下，这道题真是恶心……而且输出比树状数组还难……

update 3.12：修改一处数字错误。

## 思路分析
当时正在做一道二维树状数组，懒得换算法了，于是写了这篇题解。

如果我们把苍蝇变成 $1$ ，把空地变成 $0$，就可以转化成子矩阵和最大值的问题，而且 $0 < R,S \leqslant 99$，  用二维树状数组暴力查询最大值稳过。然后记录端点输出。

## 重点坑点

### 二维树状数组
如果专门练习二维树状数组，建议移步[那道题](https://loj.ac/p/133)，因为这道题实在是太恶心了，不值得用来练习二维树状数组。

```cpp
int n,m,tree[mxn][mxn];
int mxi,mxj;
int r,s,kk,k;
char ori[mxn][mxn];
int mxans;
int lowbit(int k)
{
    return k & -k;
}
void add(int x,int y,int k).//填入操作
{
    for(int i=x;i<=r;i+=lowbit(i))
    {
        for(int j=y;j<=s;j+=lowbit(j))
  	      tree[i][j]+=k;
    }
}
int sum(int x,int y)//求和操作
{
    if(x==0||y==0) return 0;
    int ans=0;
    for(int i=x;i>0;i-=lowbit(i))
    {
        for(int j=y;j>0;j-=lowbit(j))
     	   ans+=tree[i][j];
    }
    return ans;
}
signed main()
{
    scanf("%d%d%d",&r,&s,&kk);
    k=kk-2;
    for(int i=1;i<=r;i++)
    {
    	for(int j=1;j<=s;j++)
    	{
    		cin>>ori[i][j];
    		if(ori[i][j]=='*')
    			add(i,j,1);//输入转化，苍蝇为1，空地为0
    	}
    }
```

二维树状数组和一维的差不多，都是正常操作。二维树状数组还是简单的，重点在后面。

### 求最大和

这里坑点蛮多的。

题面中说苍蝇拍 **不包括边界**，边长 $K \geqslant 3$，所以 $K \times k$ 的苍蝇拍实际上是 $(K-2) \times (K-2)$ 的小正方形。我们可以枚举小正方形的顶点，分别求值。记录小正方形的边长 $k=K-2$，以 $K = 4$ 为例，

```
活活活活
活死死活
活死死活
活活活活

凑活着看吧
```
$4 \times 4$ 的正方形变成了 $2 \times 2$。

坑点来了 -

```cpp
k=kk-2; //原本读入的第一个k即为kk，这是一个新的
for(int i=2;i+k<=r;i++)//循环变量
    {
    	for(int j=2;j+k<=s;j++)
    	{
    		int anss=sum(i+k-1,j+k-1)-sum(i+k-1,j-1)-sum(i-1,j+k-1)+sum(i-1,j-1);
 //   		printf("%d %d %d\n",i,j,anss);
    		if(anss>mxans)
    		{
    			mxans=anss;
    			mxi=i-1;
    			mxj=j-1;
    		}//求和迭代
    	}
    }
```

1. **循环变量**

```
for(int i=2;i+k<=r;i++)
for(int j=2;j+k<=s;j++)
```

$i$ 要从 $2$ 开始，而不是 $1$！ 因为我们枚举的是不包括整个苍蝇拍的左上角，还要为边界预留出空间。具体位置如下 （在“这”的位置）。
```
活活活活
活这死活
活死死活
活活活活
```
而结束时位置（整个苍蝇拍的右下角，不是小正方形的右下角！！）是 $i+(k+1)-1$，也就是 $i+k$。$j$ 同理。

2. **求和迭代**

```cpp
int anss=sum(i+k-1,j+k-1)-sum(i+k-1,j-1)-sum(i-1,j+k-1)+sum(i-1,j-1);
if(anss>mxans)
{
    mxans=anss;
    mxi=i-1;
    mxj=j-1;
}
printf("%d\n",mxans);
```
求和步骤使用容斥原理，因为树状数组只能求从左上角到选定点的和，需要分别减掉两边多余的两条再加上重合部分。[这篇文章](https://cloud.tencent.com/developer/article/1395604)讲的很好，而且有配图，容易理解，这里不加赘述。

注意求和时要带入 **小正方形的左上角和右下角**，$(i,j)$ 和 $(i+k-1,j+k-1)$，而且减去多余部分时要 $-1$。

在记录最大值时 $(i,j)$ 要分别 $-1$，因为这回是记录 **整个苍蝇拍的左上角**，后面模拟输出时方便一些。

然后输出最大值，恭喜，要是按照原来比赛规定，一半分有了。
### 模拟输出
```cpp
for(int i=1;i<=r;i++)
    {
    	for(int j=1;j<=s;j++)
    	{
    		if((i==mxi&&j==mxj)||(i==mxi+kk-1&&j==mxj)||(i==mxi&&j==mxj+kk-1)||(i==mxi+kk-1&&j==mxj+kk-1))
    			cout<<"+";//四个顶点
    		else if((i==mxi&&j>mxj&&j<mxj+kk-1)||(i==mxi+kk-1&&j>mxj&&j<mxj+kk-1)||(j==mxj&&i>mxi&&i<mxi+kk-1)||(j==mxj+kk-1&&i>mxi&&i<mxi+kk-1))
    		{
    			if((i==mxi)||(i==mxi+kk-1))
    				cout<<"-";//横边
    			else cout<<"|";//竖边
    		}
    		else cout<<ori[i][j];//其他格子，输出原始符号
    	}
    	cout<<endl;
    }
```

这里坑点也好多的！

为了防止眼花混淆，代码中的苍蝇拍原边长为 $kk$，而在题解中为 $K$。$kk = K$，这两个是完全一样的。

1. **四个顶点**

现在，我们已经有了最大值的整个苍蝇拍左上角  $(mx_i,mx_j)$，右下角  $(mx_i+K-1,mx_j+K-1)$。左下角和右上角也容易求出。所以如果这个点在角上，就输出加号 ```+```，不用管下面有没有苍蝇。

2. **横边**

横边与角在同一横排，也就是 $(mx_i,j)$ 或 $(mx_i+K-1,j)$，这里 $j$ 表示访问到的点在第几列。但是必须判断 $j$ 是否在苍蝇拍的范围内，所以要特判 $mx_j < j < mx_j+K-1$。

在横边上输出横线 ```-``` ，也不用管是否有苍蝇。

3. **竖边**

横边与角在同一竖列，也就是 $(i,mx_j)$ 或 $(i,mx_j+K-1)$。但是和横边一样，必须判断 $i$ 是否在苍蝇拍的范围内，所以要特判 $mx_i < i < mx_i+K-1$。

在竖边上输出竖线  ```|```，也不用管是否有苍蝇。

其他格子，输出原始符号。

## 整个代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mxn=110;
int n,m,tree[mxn][mxn];//树状数组
char ori[mxn][mxn];//原始地图
int mxi,mxj;//最大值的苍蝇拍左上角位置
int r,s,kk,k;
int mxans;//最多打死多少个苍蝇
int lowbit(int k)//二维树状数组
{
    return k & -k;
}
void add(int x,int y,int k)
{
    for(int i=x;i<=r;i+=lowbit(i))
    {
        for(int j=y;j<=s;j+=lowbit(j))
  	      tree[i][j]+=k;
    }
}
int sum(int x,int y)
{
    if(x==0||y==0) return 0;
    int ans=0;
    for(int i=x;i>0;i-=lowbit(i))
    {
        for(int j=y;j>0;j-=lowbit(j))
     	   ans+=tree[i][j];
    }
    return ans;
}
signed main()
{
    scanf("%d%d%d",&r,&s,&kk);
    k=kk-2;
    for(int i=1;i<=r;i++)
    {
    	for(int j=1;j<=s;j++)
    	{
    		cin>>ori[i][j];
    		if(ori[i][j]=='*')
    			add(i,j,1);
    	}
    }
    for(int i=2;i+k<=r;i++)//求最大和
    {
    	for(int j=2;j+k<=s;j++)
    	{
    		int anss=sum(i+k-1,j+k-1)-sum(i+k-1,j-1)-sum(i-1,j+k-1)+sum(i-1,j-1);
 //   		printf("%d %d %d\n",i,j,anss);
    		if(anss>mxans)
    		{
    			mxans=anss;
    			mxi=i-1;
    			mxj=j-1;
    		}
    	}
    }
    printf("%d\n",mxans);
    for(int i=1;i<=r;i++)//模拟输出
    {
    	for(int j=1;j<=s;j++)
    	{
    		if((i==mxi&&j==mxj)||(i==mxi+kk-1&&j==mxj)||(i==mxi&&j==mxj+kk-1)||(i==mxi+kk-1&&j==mxj+kk-1))
    			cout<<"+";
    		else if((i==mxi&&j>mxj&&j<mxj+kk-1)||(i==mxi+kk-1&&j>mxj&&j<mxj+kk-1)||(j==mxj&&i>mxi&&i<mxi+kk-1)||(j==mxj+kk-1&&i>mxi&&i<mxi+kk-1))
    		{
    			if((i==mxi)||(i==mxi+kk-1))
    				cout<<"-";
    			else cout<<"|";
    		}
    		else cout<<ori[i][j];
    	}
    	cout<<endl;
    }
    return 0;
}

```
### 结果

![](https://cdn.luogu.com.cn/upload/image_hosting/5hs5v1ob.png)

在漫长的调代码之后，终于过了……

这也是我写过最长的题解了……良怒码代码+码题解2h手疼的很，留个赞再走吧……

如果有 hack，及时告知我修题解。

---

## 作者：8atemak1r (赞：3)

## Description

给定 $R \times S$ 的地图，地图上有一些点，求一个 $ K \times K$ 的正方形使得这个正方形覆盖的点最多（不包含边界）

## Solution

俗话说得好，**数据范围是一道题的灵魂**。

我们把鼠标向下拉，惊喜的发现，这道题的数据范围是

>对于 $100 \%$ 的数据， $3 ≤ K ≤ R,S ≤ 100$ 

还打什么数据结构！纯暴力轻松AC

我们仅需要写一个 `solve` 函数，其功能为统计以 $(x, y)$ 为左上角坐标的 $ K \times K$ 的正方形内包含的点的个数，之后 `for` 循环暴力 $O(R\times S)$ 遍历 $(x, y)$ 就可以了。

这里注意，题目中还有一句话：

>选定的矩形区域必须完全在整个矩阵内部。

所以对 $(x, y)$ 进行遍历时，$i$ 和 $j$ 仅需循环到 $R - K + 1$ 与 $S - K + 1$，以保证答案符合题目条件
。
## Code

```cpp
#include<iostream>
#include<vector>
using namespace std;
int R, S, k, len, res, tmp, x, y;
struct node{
    int x, y;
};
char mapp[205][205];
int solve(int x, int y) {
    int sum = 0;
    for(int i = x + 1; i < x + k - 1; ++ i) 
        for(int j = y + 1; j < y + k - 1; ++ j) 
            if(mapp[i][j] == '*') ++ sum;
    return sum;
}
int main() {
    ios :: sync_with_stdio (0); cin.tie(0); cout.tie(0);
    cin >> R >> S >> k;
    for(int i = 1; i <= R; ++ i) for(int j = 1; j <= S; ++ j) cin >> mapp[i][j];
    for(int i = 1; i <= R - k + 1; ++ i) 
        for(int j = 1; j <= S - k + 1; ++ j) {
            tmp = solve(i, j);
            if(tmp > res) res = tmp, x = i, y = j;
        }
    cout << res << '\n';
    mapp[x][y] = mapp[x][y + k - 1] = mapp[x + k - 1][y] = mapp[x + k - 1][y + k - 1] = '+';
    for(int i = x + 1; i < x + k - 1; ++ i) mapp[i][y] = mapp[i][y + k - 1] = '|';
    for(int i = y + 1; i < y + k - 1; ++ i) mapp[x][i] = mapp[x + k - 1][i] = '-';
    for(int i = 1; i <= R; ++ i) {
        for(int j = 1; j <= S; ++ j) cout << mapp[i][j];
        cout << '\n';
    }
    return 0;
}
```


---

## 作者：Eason_AC (赞：2)

## Content
给定一个 $n\times m$ 的网格图，有些格子上有蚊子。现在你有一个 $k\times k$ 的拍子可以拍掉所有在拍子范围内（**不包含边界**）的蚊子，求最多可以拍掉多少只蚊子，并输出一种方案。

**数据范围：$3\leqslant k\leqslant n,m\leqslant 100$。**
## Solution
讲一个利用二维前缀和的 $\mathcal O(nm)$ 做法。

如果不懂二维前缀和，可以去看看我在 UVA11951 中写的[题解](https://www.luogu.com.cn/blog/EasonBlog1/solution-uva11951)，里面对二维前缀和做了较为详细的诠释。

回到这题，我们利用上面的二维前缀和，对于所有的 $1\leqslant i\leqslant n,1\leqslant j\leqslant m$，求出横坐标在 $[1,i]$，纵坐标在 $[1,j]$ 内的所有格子中蚊子个数的总和 $s_{i,j}$，然后根据题意，求出所有 $k\times k$ 的矩阵中不含边界一共有多少只蚊子，取最大值，然后再遍历一遍，看哪一个矩阵里面的蚊子个数是最大值，在原字符矩阵中填上其边界即可。
## Code
```cpp
namespace Solution {
	const int N = 107;
	int n, m, k, ans, sx, sy, vis[N][N], s[N][N];
	char a[N][N];
	
	iv Main() {
		read(n, m, k);
		F(int, i, 1, n) {
			scanf("%s", a[i] + 1);
			F(int, j, 1, m) if(a[i][j] == '*') vis[i][j] = 1;
		}
		F(int, i, 1, n) F(int, j, 1, m) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + vis[i][j];
		F(int, i, 1, n - k + 1) F(int, j, 1, m - k + 1) ans = max(ans, s[i + k - 2][j + k - 2] - s[i][j + k - 2] - s[i + k - 2][j] + s[i][j]);
		F(int, i, 1, n - k + 1) F(int, j, 1, m - k + 1) if(s[i + k - 2][j + k - 2] - s[i][j + k - 2] - s[i + k - 2][j] + s[i][j] == ans) {sx = i, sy = j; break;}
		a[sx][sy] = a[sx + k - 1][sy] = a[sx][sy + k - 1] = a[sx + k - 1][sy + k - 1] = '+';
		F(int, i, sx + 1, sx + k - 2) a[i][sy] = a[i][sy + k - 1] = '|';
		F(int, i, sy + 1, sy + k - 2) a[sx][i] = a[sx + k - 1][i] = '-';
		println(ans); F(int, i, 1, n) {F(int, j, 1, m) putchar(a[i][j]); puts("");}
		return;
	}
}
```

---

## 作者：Lantrol (赞：1)

# P8033 Prozor 题解
### 题目描述
给定一个 $R$ $×$ $S$ 的 $01$ 矩阵，求其中一个 $K$ $×$ $K$ 的子矩阵，使其包含 $1$ 最多（不含边界）。

$3$ $≤$ $K$ $≤$ $R,S$ $≤$ $100$

### 思路
注意到数据范围，直接考虑 $O(RS)$ 枚举所有 $K$ $×$ $K$ 矩阵，求最大值。而朴素地统计每个 $K$ $×$ $K$ 矩阵中 $1$ 的个数，复杂度是 $O(K^2)$ 的。那么合起来，这整个程序的复杂度就成了 $O(RSK^2)$，稍加优化（当矩阵“越界”时直接剪枝）后可以变成 $O((R-K+1)(S-K+1)K^2)$，其实已经可以通过本题了。

但 ~~作为一道黄题绝不会这么水~~ 我们发现，当数据范围扩大到 $1000$ 时，上述做法的复杂度就不可接受。能不能考虑继续优化呢？优化过的程序能不能跑过 $1000$，甚至 $2000$ 呢？

答案是可以的——**二维前缀和**。

与一维前缀和类似，二维前缀和同样需要预处理，查询时的复杂度同样是 $O(1)$，但预处理的复杂度变成了 $O(n^2)$，在本题中即 $O(RS)$。

首先来讲预处理，设 $f_{i,j}$ 为矩阵内以 $(1,1)$ 点为左上角，$(i,j)$ 点为右下角的子矩阵中所有权值的和，设 $a_{i,j}$ 为矩阵内 $(i,j)$ 点的权值，结合下图则不难得出递推式 $f_{i,j}=f_{i-1,j}+f_{i,j-1}-f_{i-1,j-1}+a_{i,j}$

![二维前缀和图解(预处理)](https://s4.ax1x.com/2022/01/16/7tQl4g.png)

其中，$f_{1,1}$ ~ $f_{i-1,j-1}$ 被重复计算了两次，所以要减去一次。

接下来 $O(1)$ 查询的式子也不难得出：
![二维前缀和图解(查询)](https://s4.ax1x.com/2022/01/16/7tl7YF.png)

设 $sum_{(i_1,j_1),(i,j)}$ 为矩阵内以 $(i_1,j_1)$ 点为左上角，$(i,j)$ 点为右下角的子矩阵中所有权值的和，则 $sum_{(i_1,j_1),(i,j)}=f_{i,j}-f_{i,j_1}-f_{i_1,j}+f_{i_1,j_1}$。推导过程较为简单，此处不放出。

是不是明白了？这道题使用二维前缀和优化后，查询每个 $K$ $×$ $K$ 矩阵中 $1$ 的个数时，复杂度可以降到 $O(1)$，但总复杂度需要加上一个 $O(RS)$。所以，这种做法的时间复杂度就是 $O(RS+(R-K+1)(S-K+1))$，甚至可以跑过 $R=S=5000$。

最后讲一下怎么输出框选后的矩阵。按题意模拟即可。先考虑特判矩阵的四个角，坐标分别是 $(x,y)$，$(x,y-k+1)$，$(x-k+1,y)$，$(x-k+1,y-k+1)$。再来特判矩阵的横边，即当某个点坐标为 $(x,?)$ 或 $(x-k+1,?)$ 且当 $y-k+1<?<y$ 时，输出横边，同理特判竖边，当某点均不满足以上条件时，输出原矩阵中的该点即可。

贴一份丑陋的代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int f[105][105],r,s,k;
char ch[105][105];

struct node{
	int x,y,su;
}ans;
void read(){
	scanf("%d%d%d",&r,&s,&k);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			cin>>ch[i][j];
			if(ch[i][j]=='*'){
				f[i][j]=1;
			}
		}
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+f[i][j];
		}
	}
}

bool check(int x,int y){
	return x>0&&x<=r&&y>0&&y<=s;
}

void solve(){
	for(int i=k;i<=r;i++){
		for(int j=k;j<=s;j++){
			if(f[i-1][j-1]-f[i-1][j-k+1]-f[i-k+1][j-1]+f[i-k+1][j-k+1]>ans.su){
				ans.su=f[i-1][j-1]-f[i-1][j-k+1]-f[i-k+1][j-1]+f[i-k+1][j-k+1];
				ans.x=i,ans.y=j;
			}
		}
	}
}

void write(){
	printf("%d\n",ans.su);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			if((i==ans.x&&(j==ans.y||j==ans.y-k+1))||i==ans.x-k+1&&(j==ans.y||j==ans.y-k+1)){
					printf("+");
			}
			else if((i==ans.x||i==ans.x-k+1)&&j<ans.y&&j>ans.y-k+1){
				printf("-");
			}
			else if((j==ans.y||j==ans.y-k+1)&&i<ans.x&&i>ans.x-k+1){
				printf("|");
			}
			else{
				printf("%c",ch[i][j]);
			}
		}
		printf("\n");
	}	
}

int main(){
	read();
	solve();
	write();
	return 0;
}

```


---

## 作者：Noby_Glds (赞：0)

### 思路

虽然这题数据很水，但为了更快，我们可以预处理二维前缀和。

前缀和方程：$\texttt{sum[i][j]=sum[i-1][j]+cnt}$（$cnt$ 为当前行从第一列到第 $j$ 列共有多少个苍蝇）

在枚举一个二维区间内有多少个苍蝇时，因为边界拍不到苍蝇，所以统计方程为：$\texttt{tot=sum[i-1][j-1]-sum[i-k+1][j-1]-sum[i-1][j-k+1]+sum[i-k+1][j-k+1]}$

画图应该很简单，详情见代码。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,sum[110][110],ans,x,y;
char a[110][110];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		int cnt=0;
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			if(a[i][j]=='*') cnt++;
			sum[i][j]=sum[i-1][j]+cnt;
		}
	}
	for(int i=k;i<=n;i++){
		for(int j=k;j<=m;j++){
			int tot=sum[i-1][j-1]-sum[i-k+1][j-1]-sum[i-1][j-k+1]+sum[i-k+1][j-k+1];
			if(ans<tot) ans=tot,x=i,y=j;
		}
	}
	cout<<ans<<endl;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if((i==x&&j==y)||(i==x-k+1&&j==y)||(i==x&&j==y-k+1)||(i==x-k+1&&j==y-k+1)) cout<<"+";
			else if((i==x||i==x-k+1)&&j>y-k+1&&j<y) cout<<"-";
			else if((j==y||j==y-k+1)&&i>x-k+1&&i<x) cout<<"|";
			else cout<<a[i][j];//只有“+”，“-”，“|”三个条件都不满足，才能输出“*”或“.”
		}
		cout<<endl;
	}
    return 0;
} 
```


---

## 作者：tongzhenxuan (赞：0)

## 思路解析：
对于这道题，非常容易想到 $O(nmk^2)$ 的做法（暴力枚举）。

但显然对于极限数据有超时的风险。所以我们可以利用二维前缀和将 $K \times K$ 区间中有多少只苍蝇预处理出来，再查询时便可做到 $O(1)$，接下来枚举右下角端点即可。所以代码复杂度可以降到 $O(nm)$。

### 二维前缀和：
推导式：
$f_{i,j}=f_{i-1,j}+f_{i,j-1}-f_{i-1,j-1}+a_{i,j}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gvlx281g.png?x-oss-process=image/resize,m_lfit,h_500,w_700)

简单解释，$f_{i,j}$ 表示前 $i$ 行 $j$ 列元素的和。而运用简单的容斥原理，我们要求的黑色部分就是红色部分加上绿色部分减去蓝色部分（重叠部分）最后加上自己的端点。

利用前缀和，假设我们要求一个已知左上角坐标以及右下角坐标的二维矩形的元素和，就非常简单了：

 $ans = f_{rx,ry} - f_{rx,ly-1} - f_{lx-1,ry} + f_{lx-1,ly-1}$。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/30wj36nd.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

同样是利用简单的容斥原理，求红色的，将蓝色的减去紫色的和绿色的，加上重复减去的黄色的。

注：$lx$，$ly$，$rx$，$ry$ 分别为矩形左上角坐标及右下角坐标。

这样我们就可以快速解决这道题目了。注意的细节是苍蝇拍不包括边界。

## code:
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
char ch[105][105];
int s[105][105];
int i,j,rx,ry,lx,ly,max1,xx,yy,cnt;
int main()
{
	cin>>n>>m>>k;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			cin>>ch[i][j];
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(ch[i][j]=='*') s[i][j]++;
			s[i][j]=s[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
		}
	}
	for(i=k;i<=n;i++)
		for(j=k;j<=m;j++)
		{
			rx=i,ry=j,lx=i-k+1,ly=j-k+1;
			rx--,ry--,lx++,ly++;//注意边界不算
			cnt=s[rx][ry]-s[rx][ly-1]-s[lx-1][ry]+s[lx-1][ly-1];
			if(cnt>max1)
			{
				max1=cnt;
				xx=rx+1;
				yy=ry+1;
			}
		}
	cout<<max1<<"\n";
	rx=xx,ry=yy,lx=xx-k+1,ly=yy-k+1;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(	i==rx && j==ly ||
				i==lx && j==ly ||
				i==rx && j==ry ||
				i==lx && j==ry)
				cout<<"+";
			else if((i==rx || i==lx) && ry>=j && j>=ly)
				cout<<"-";
			else if((j==ry || j==ly) && rx>=i && i>=lx)
				cout<<"|";
			else 
				cout<<ch[i][j];
		}
		cout<<"\n";
	}
}
```

---

## 作者：LYqwq (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8033) 

# 题目大意

一扇 $R \times S$ 的窗户上有一些苍蝇。有一把苍蝇拍，它可以消灭 $K \times K$ 的矩阵内（不含边界）的苍蝇。

选择一种苍蝇拍放置的位置，使得被消灭的苍蝇数量最多。输出被消灭的苍蝇的最大值和窗户的样子。如果有多种方案，输出任意一种即可。

# 思路

二维前缀和（不懂可以参考我[这篇博客](https://www.luogu.com.cn/blog/ericiscool/prefix-sum) ）。

考虑枚举苍蝇拍左上角位置，每次对枚举到的矩阵进行前缀和查询操作，更新最大值和坐标，最后画上去即可。时间复杂度 $\mathcal{O}(nm)$。

就这么简单，代码里的注释应该够详细了吧？

# 代码

```cpp
#include <iostream>
using namespace std;
const int N=105; // 数据范围
int r,s,k; // 题目给出的数据
int sum[N][N],ans,x,y; // 前缀和数组sum，答案 ans 和坐标 x,y
char a[N][N]; // 就先用一下 char 吧（

int main(){
	cin >> r >> s >> k;
	for(int i=1; i<=r; i++){
		for(int j=1; j<=s; j++){
			cin >> a[i][j];
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(a[i][j]=='*');
			// 二维前缀和
		}
	}
	// 枚举苍蝇拍左上角
	// 要确保边界不出错
	// 先用 l1,l2 记录一下，以免重复计算（感觉没啥用/kk）
	int l1=l1=r-k+1,l2=s-k+1,t; // t 用于临时存储
	k-=2; // 不算边界，所以 k-=2（其实就是懒得打 '-2'
	for(int i=1; i<=l1; i++){
		for(int j=1; j<=l2; j++){
			t=sum[i+k][j+k]-sum[i][j+k]-sum[i+k][j]+sum[i][j];
			// i,j 枚举的是左上角的 '+' 号
			// sum[i][j] 包括边界，直接减就刚好算到内部
			if(t>ans){
				ans=t; // 更新答案
				x=i,y=j;
			}
		}
	}
	k++; // 只加一个是因为后面每次写都要减一，省力气（
	l1=x+k,l2=y+k; // 还是记录
	// 开始作画了！
	for(int i=x; i<=l1; i++) a[i][y]=a[i][y+k]='|'; // 左边和右边的边框
	for(int i=y; i<=l2; i++) a[x][i]=a[x+k][i]='-'; // 上面和下面
	a[x][y]=a[x+k][y]=a[x][y+k]=a[x+k][y+k]='+'; // 四个角
	// 愉快地输出吧！
	cout << ans << endl;
	for(int i=1; i<=r; i++){
		for(int j=1; j<=s; j++){
			putchar(a[i][j]);
		}
		puts("");
	}
	return 0;
}
```



---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8033)

$\text{Part 01: 找出最大值及其区域}$

上来先看数据范围：

> $3\le K\le R,S\le 100$

好嘛，直接暴力：

做法就是遍历每个 $(k-1)\times (k-1)$ 的矩阵然后暴力计算其中有几个 `*`，

最后找到最大值即可：

```cpp
for(int i=1;i+k-1<=n;i++){
	for(int j=1;j+k-1<=m;j++){//遍历每个矩阵
		int tot=0;
		for(int a=i+1;a<i+k-1;a++){
			for(int b=j+1;b<j+k-1;b++){
				if(mp[a][b]=='*'){
					tot++;
				}
			}
		}//暴力计算每个矩阵中有几个 *
		if(ans<tot){
			ans=tot;
			start_l=i,start_r=j;
			end_l=i+k-1,end_r=j+k-1;
		}//更新最大值及其范围
	}
}
cout<<ans<<"\n";//输出
```

当然还有前缀和做法：

其实就是子矩阵求和模板题。

不难发现其实这就是个 $01$ 矩阵，`*` 就是 $1$，

先初始化前缀和矩阵：

```cpp
for(int i=1;i<=n;i++){
	scanf("%s",mp[i]+1);
	for(int j=1;j<=m;j++){
		sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(mp[i][j]=='*');
	}
}
```

矩阵求和：

```cpp
int Sum(int x1,int y1,int x2,int y2){
	return sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
}
```

然后得到第一部分的代码：

```cpp
for(int i=1;i+k-1<=n;i++){
	for(int j=1;j+k-1<=m;j++){
		int tmp=Sum(i+1,j+1,i+k-2,j+k-2);//注意这里是 i+1 到 i+k-2
		if(tmp>ans){
			ans=tmp;
			start_l=i;start_r=j;
			end_l=i+k-1;end_r=j+k-1;
		}
	}
}
cout<<ans<<"\n";
```

这样就能减少两个 `for`

$\text{Part 02: 输出方案}$

由于我们在第一部分中更新最大值的同时已经更新了方案，所以这一部分只要把方案输出即可。

分三类：

- 如果是角上的替换成 `+`

- 如果是竖边上的替换成 `|`

- 如果是竖边上的替换成 `-`

```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if((start_l==i||end_l==i)&&(start_r==j||end_r==j)){
			cout<<"+";
		}else if((start_l==i||end_l==i)&&j>=start_r&&j<=end_r){
			cout<<"-";
		}else if((start_r==j||end_r==j)&&i>=start_l&&i<=end_l){
			cout<<"|";
		}else{
			cout<<mp[i][j];
		}
	}
	cout<<"\n";
}
```

完整代码就不放了。

---

## 作者：AFewSuns (赞：0)

### 题目大意

$N \times M$ 的格子中有若干只苍蝇，现在用大小为 $K \times K$ 的苍蝇拍来拍苍蝇，求最多能拍中多少只苍蝇。（在苍蝇拍边界的不算）

$3 \leq K \leq N,M \leq 100$

### 题目分析

最暴力的做法就是枚举苍蝇拍的位置，然后暴力计算中间苍蝇的个数，更新答案。时间复杂度 $O(n^2m^2)$，明显超时。

考虑如何快速计算一个矩形内的苍蝇个数。看到如此小的数据范围，直接用二维前缀和计算。时间复杂度降到了 $O(nm)$。

**下面为二维前缀和的讲解，懂的直接跳过**

令 $sum[i][j]$ 为 $\displaystyle\sum_{x=1}^{i}\sum_{y=1}^{j}a[x][y]$，也就是下方的红色区域和。

![](https://cdn.luogu.com.cn/upload/image_hosting/cflkhs0x.png)

有以下递推式：

$$sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]$$

这个也很好理解，就是绿色部分加蓝色部分，因为重合了一部分，所以要减去紫色部分，再加上右下角那一格变成了 $sum[i][j]$

![](https://cdn.luogu.com.cn/upload/image_hosting/w08q9ub4.png)

同理，可以推广到如何快速求 $(x1,y1)$ 到 $(x2,y2)$ 内的和。

![](https://cdn.luogu.com.cn/upload/image_hosting/16rnbgxo.png)

如上图，我们先用整体（蓝色边框）减去橙紫部分和绿紫部分。因为紫色部分被重复算去了，所以还要加上紫色部分。这样就得到了我们所求的红色部分。

翻译成人话：

$$ans=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]$$

这就是二维前缀和了。

回到题目，$a[i][j]$ 其实就是这个格子上有没有苍蝇。有的话为 $1$，否则为 $0$。枚举苍蝇拍，然后用上面的式子计算矩形内的苍蝇即可。

注意边界不算。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,s[110][110],ans=0,x,y;
char c[110][110];
int main(){
	scanf("%lld %lld %lld",&n,&m,&k);
	for(ll i=1;i<=n;i++) scanf("%s",c[i]+1);
	for(ll i=1;i<=n;i++) for(ll j=1;j<=m;j++) s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+(c[i][j]=='*');//预处理二维前缀和 
	for(ll i=1;i<=(n-k+1);i++){
		for(ll j=1;j<=(m-k+1);j++){//枚举苍蝇拍左上角 
			ll tmp=s[i+k-2][j+k-2]-s[i][j+k-2]-s[i+k-2][j]+s[i][j];//计算矩形内苍蝇个数 
			if(tmp>ans){//更新答案 
				ans=tmp;
				x=i;
				y=j;
			}
		}
	}
	for(ll i=x;i<=(x+k-1);i++) c[i][y]=c[i][y+k-1]='|';//绘制苍蝇拍 
	for(ll i=y;i<=(y+k-1);i++) c[x][i]=c[x+k-1][i]='-';
	c[x][y]=c[x+k-1][y]=c[x][y+k-1]=c[x+k-1][y+k-1]='+';
	printf("%lld\n",ans);
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=m;j++) cout<<c[i][j];
		printf("\n");
	}
}
```

---


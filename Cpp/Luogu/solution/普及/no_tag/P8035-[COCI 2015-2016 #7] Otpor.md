# [COCI 2015/2016 #7] Otpor

## 题目描述

众所周知，电阻的连接包括串联和并联两种。而一条电路的所有电阻可以视为这条电路的等效电阻 $R_{ekv}$。当电阻串联时，可以这样表示：

$$\text{(R1-R2-R3-...-RK)}$$

同时满足公式：

$$R_{ekv}=\sum_{i=1}^K R_i$$

并联时可以这样表示：

$$\text{(R1|R2|R3|...|RK)}$$

同时满足公式：

$$R_{ekv}=\frac{1}{\sum_{i=1}^K \frac{1}{R_i}}$$

现有一个包含 $N$ 种阻值为 $R_i$ 的电阻和足够多的导线。给定这些电阻的连接方式，求整条电路的等效电阻值。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$ 的数据，$N=3$ 且电路恰好包含这三种电阻。
- 对于 $40\%$ 的数据，$S$ 中只包含一对括号。
- 对于 $100\%$ 的数据，$1 \le N \le 9$，$0 \lt R_i \lt 100$，$1 \le |S| \le 10^5$。

**【提示与说明】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [#7](https://hsin.hr/coci/archive/2015_2016/contest7_tasks.pdf) _Task 4 Otpor_。**

**本题分值按 COCI 原题设置，满分 $120$。**

## 样例 #1

### 输入

```
3
2 3 6
(R1-R2-R3)```

### 输出

```
11.00000```

## 样例 #2

### 输入

```
3
2 3 6
(R1|R2|R3)```

### 输出

```
1.00000```

## 样例 #3

### 输入

```
5
5.0 5.0 5.0 5.0 5.0
((R1-(R2|R3)-(R4|R5))|(R1-(R2|R3)-(R4|R5)))```

### 输出

```
5.00000```

# 题解

## 作者：Lyrella (赞：6)

# 题意
给你一串狮子，让你先带值，再求值。（类似于表达式求值）
# 思路
与表达式求值一样，直接用一个 $\text{stack}$ 来处理运算。具体讲就是把运算符和数字存在 $\text{stack}$ 里，如果遇到 $\text{")"}$ 就把它和与它匹配的前括号之间的狮子暴力算出来。如果是 $\text{"-"}$ 就把数字累加，如果是 $\text{"|"}$ 就把数字的倒数累加再用 $\text{1}$ 来除。
# 注意
- 开 $\text{double}$
- 精度
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n;
stack < double > st;
double R[15];
string c;
double sum()
{
	double h = st.top(); st.pop();
	if(st.top() == - 4) while(st.top() != - 1){st.pop(); h += st.top(); st.pop();}
	else
	{
		h = 1.0 / h;
		while(st.top() != -1){st.pop(); h += 1.0 / st.top(); st.pop();}
		h = 1.0 / h;
	}
	st.pop();
	return h;
}
signed main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)scanf("%lf", &R[i]);
	cin >> c;
	for(int i = 0; i < c.size(); i++)
	{
		if(c[i] == '(')st.push(- 1);
		if(c[i] == ')')st.push(sum());
		if(c[i] == '|')st.push(- 3);
		if(c[i] == '-')st.push(- 4);
		if(c[i] >= '0' and c[i] <= '9')st.push(R[c[i] - '0']);
	}
	printf("%.8lf", st.top());
	return 0;
}
```

---

## 作者：zbbfans (赞：6)

## 前言

比较简单的一道模拟题，用栈来做。

思路和表达式求值比较相似，就是先算优先级较高的（括号里的）保证最后剩下的电阻优先级相等。

## 思路

串联直接相加即可。
并联倒数相加之后再取倒数。

因为两边的是一定有括号的，所以结果直接输出就行。

看不懂的可以结合代码和注释看。
因为写的比较多，但相对要详细一点。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
double mp[110];
double x;
string s;
stack<char> fuhao;
stack<double> shu;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lf",&mp[i]);
	}
	cin>>s;
	int len=s.size();
	int f=0,f1=0;
	int sum=0;
	for(int i=0;i<=len;i++){
    //统计第几个电阻
		if(s[i]=='R'){
			f=1;
			f1=1;
			continue;
		}else if(s[i]=='(' || s[i]=='-' || s[i]=='|'){
			f=0;
			if(sum!=0){
				shu.push(mp[sum]);//把电阻放进栈里面
				sum=0;
			}
			fuhao.push(s[i]);//符号入栈
		}else if(s[i]==')'){//直接计算
			f=0;
			if(sum!=0){
				shu.push(mp[sum]);
				sum=0;
			}
			while(!fuhao.empty() and !shu.empty()){
				char c=fuhao.top();fuhao.pop();
				if(c=='('){//算到上一个括号，保证没有优先级相同
					break;
				}
				double a1=shu.top();shu.pop();double a2=shu.top();shu.pop(); double a3;
				if(c=='-'){
					a3=a1+a2;
				}else{
					a3=1/(1/a1+1/a2);
				}
				shu.push(a3);
			}
		}else{
			if(f==1){
				sum*=10;
				sum+=s[i]-'0';
			}
		}
	}
	if(f1==0) printf("%.5lf",0);//有可能一个电阻都没有
	if(!shu.empty()) printf("%.5lf",shu.top());//最后一个就是答案，直接输出
	return 0;
}
```

---

## 作者：Bug_Automation (赞：5)

这道题跟[P1175 表达式的转换](https://www.luogu.com.cn/problem/P1175)有点类似，都是计算一个带括号的表达式 ~~（并且好像还简单点）~~。

**注：为了简便，下文将 $\texttt |$ 与 $\texttt -$ 统称为运算符。**

思路也很简单，用栈把数、运算符之类的存起来（为了处理方便，最好把字符串转换成一个数组来做），然后遇到后括号就弹栈弹到前括号，把这一整个括号内的一堆算出来存进栈里。算到最后，因为外面总是有一对括号，所以最后永远只剩一个数，也就是答案。

*注：任何一对括号里都不会同时出现两种运算符，所以正着算和倒着算其实都一样。*

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double a[10],op[100010];
stack<double>s;
double solve(){        //计算 
	double ls=s.top();s.pop();
	bool mode=0;
	if(s.top()!=-54088){        //判断并联还是串联 
		mode=1;
		ls=1.0/ls;
	}
	while(s.top()!=-114514){        //如果没到前括号就继续算 
		s.pop();
		if(mode){
			ls=ls+1.0/s.top();
		}
		else {
			ls+=s.top();
		}
		s.pop();
	}
	s.pop();        //弹掉前括号 
	if(mode)ls=1.0/ls;        //并联时别忘记最后取倒数 
	return ls;
}
int main(){
	//#ifndef P_A_I_M_O_N
	//	freopen("otpor.in","r",stdin);
	//	freopen("otpor.out","w",stdout);
	//#endif
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int n;cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	string st;cin>>st;
	int l=st.size(),tot=0;
	for(int i=0;i<l;i++){        //把字符串转化为数组 
		if(st[i]=='(')op[++tot]=-114514;
		else if(st[i]==')')op[++tot]=-1919810;
		else if(st[i]=='R'){
			op[++tot]=a[st[++i]-'0'];
		}
		else if(st[i]=='-')op[++tot]=-54088;
		else if(st[i]=='|')op[++tot]=-229;
	} 
	for(int i=1;i<=tot;i++){        //用栈计算答案 
		if(op[i]==-1919810)s.push(solve());        //如果是后括号就计算 
		else s.push(op[i]);        //否则先存进去 
	}
	cout<<fixed<<setprecision(8)<<s.top();        //注意精度 
	return 0;
}
```

---

## 作者：crazy_psycho (赞：2)

~~简单的模拟题~~

**题目大意**

给一串式子，求出电阻值（注意是 double 类型的）。

**思路：**

不难发现，每个括号内只有一种联接方式，所以只需要将每一个括号内的联接方式统计出来，就能求出每一部分的电阻了。

当遇到左括号时，我们可以采用 dfs 的思路，将后方的式子向上“移动”一层，遇到右括号时再返回回来，这样就能统计出总电阻了。

**代码如下**
```cpp
#include<bits/stdc++.h>
using namespace std;
double a[4994],ans;
int l;//当前第几个括号
char b[500000];//每个括号里的符号 一个括号内存一个符号
vector<double>v[100010];//每个括号里算出来的数值
map<int,double>mp;//每个电阻的大小
int main(){
	int n;
	string s;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lf",&a[i]);//输入 
		mp[i]=a[i];//map存电阻值 
	}
	cin>>s;
	n=s.size();
	string x;
	for(int i=0;i<n;i++){
		if(s[i]!='R')x+=s[i];//去掉'R'(没啥用) 
	}
	s.clear();
	n=x.size();
	for(int i=0;i<n;i++){
		if(x[i]=='-'||x[i]=='|'){
			b[l]=x[i];
		}//存符号
		if(x[i]=='('){
			l++;//当前为第几个括号
		}
		else if(x[i]==')'){
            //求每个括号内的电阻
			double u=0;
			for(int j=0;j<v[l].size();j++){
				if(b[l]=='-'&&v[l][j]!=0)u+=v[l][j];//串联
				else if(v[l][j]!=0)u+=1.0/v[l][j];//并联				
			}
			if(b[l]=='-'){
				v[l-1].push_back(u);
				if(i==n-1)ans=u;//统计答案
			}
			else{
				v[l-1].push_back(1.0/u);
				if(i==n-1)ans=1.0/u;//统计答案
			}
			v[l].clear();//求完后删除
			b[l]='0';
			l--;
		}
		if(x[i]>='0'&&x[i]<='9'){
			v[l].push_back(mp[x[i]-'0']);//存电阻值
		}
	}
	printf("%.5lf",ans);//输出 
	return 0;
}
```

---

## 作者：__^浅笑.__ (赞：1)

**前言：**

$$\LARGE\color{red}\texttt{Never gOnna gIve you uP}$$

water ~ water ~

挂：可爱的管理 - Linge_Zzzz 。

挂：年轻的管理 - cff_0102 。

挂：一言难尽的管理 - 沉石鱼惊旋 。

~~等会上面三条的排版错了被打回就老实了。。~~

----


我们可以定义一个函数来计算给定表达式的等效电阻。由于表达式可以包含嵌套的括号，因此我们需要递归地解析每个括号内的表达式。

**解题思路**
1. 首先从左到右扫描字符串。
 
2. 如果遇到左括号 `(`，则递归地计算括号内的表达式的等效电阻。

3. 如果遇到 `-` 或 `|`，则根据串联或并联的规则计算等效电阻。

4. 如果遇到的是电阻编号（例如 `R1`），则从输入的电阻数组中获取相应的电阻值。

5. 当遇到右括号 `)` 时，返回当前括号内的计算结果。

懂了吧，不懂别看了[滑稽]。

~~话说物理的电阻这些玩意儿八下和九年级才学呢，初二蒟蒻路过。~~

**超级详细分析：**

首先读取电阻的数量 $N$ 和每个电阻的阻值 $R_i$。然后读取表示电路连接方式的字符串 $S$。

接下来我们可以用一个递归函数来解析电路表达式并计算等效电阻。函数将遍历字符串 $S$，并根据遇到的字符执行不同的操作。

**联：**

遇到 `-` 时，表示串联连接，我们需要将当前电阻值加到总和中。遇到 `|` 时，表示并联连接，我们需要将当前电阻值的倒数加到倒数总和中。

**括号：**

遇到 `(` 时，我们需要递归地计算括号内的表达式的等效电阻。遇到 `)` 时，我们返回当前括号内的计算结果。

**电阻：**

对于串联连接，等效电阻是所有电阻值的总和。对于并联连接，等效电阻是所有电阻值倒数的总和的倒数。

~~能看懂就看吧，我都搞糊了（八下物理书还没开学就翻完了。。~~

----

接下来讲解一下函数的大致吧~

首先初始化变量 $sum$ 用于存储串联电阻的总和，$num$ 用于存储并联电阻倒数总和。

遍历字符串 $S$，根据当前字符执行以下操作：

- 如果是 `(`，递归计算括号内的表达式的等效电阻。

- 如果是 `)`，返回当前括号内的计算结果。

- 如果是 `-`，设置操作符为串联。

- 如果是 `|`，设置操作符为并联。

- 如果是数字，表示电阻编号，根据操作符更新 $sum$ 或 $num$。

根据操作符返回最终的结果即可。

----

~~不会打回说无关信息太多吧……~~

----

完结撒花★,°:.☆(￣▽￣)/$.°★。

---

## 作者：Tomwsc (赞：1)

本题解主要为还没学物理的 OIer 们提供。

## 前言：

做前须知：

### 1.欧姆定律：

介绍一下公式：$I=\frac{U}{R}$。即电流等于电压与电阻之比。

所以，可以得到推导式：$R=\frac{U}{I}$。

### 2.等效电阻

定义：几个连接起来的电阻所起的作用，可以用一个电阻来代替，这个电阻就是那些电阻的等效电阻。

#### 1.串联电路中的等效电阻：

由串联电路中的电流处处相等，各用电器电压之和等于电源电压（等流分压）得：

$R_总=\frac{U_总}{I_总}=\frac{U_1+U_2+\cdots+U_n}{I}=\frac{U_1}{I}+\frac{U_2}{I}+\cdots+\frac{U_n}{I}=R_1+R_2+\cdots+R_n$

所以，串联电路中的等效电阻便等于各用电器电阻之和。

#### 2.并联电路中的等效电阻：

由并联电路中的各支路电流之和等于干路电流，电压处处相等（等压分流）得：

$R_总=\frac{U_总}{I_总}=\frac{U}{I_1+I_2+\cdots+I_n}$

  此时，不难想到对 $R_总$ 取一个倒数，即：$\frac{1}{R_总}=\frac{I_1+I_2+\cdots+I_n}{U}=\frac{1}{R_1}+\frac{1}{R_2}+\cdots+\frac{1}{R_n}$。

所以，并联电路中的等效电阻等于各用电器电阻的倒数的和的倒数。（有点绕，可以尝试理解一下）。

## 题意：

给定用电器的个数以及各用电器的电阻值以及一个表示串连或并连的式子，让你求此电路的等效电阻。

## 思路与代码实现：

对于这样子的式子，很容易令人想到用栈来模拟。（~~于是 5 分钟切了~~）。

我们可以开两个栈，一个记录电阻值，一个记录括号与符号。遇到 `)` 就一直 `pop`到出现 `(` 的时候，中间不断在记录电阻值的栈中计算值即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 10;
int n;
double r[MAXN];
string s;
stack<char>st;	//存符号 
stack<double>sn;	//存数字 

signed main() {
	cin >> n;
	for(register int i = 1;i <= n;i ++)
		cin >> r[i];
	cin >> s;
	for(register int i = 0;i < s.length();i ++) {
		if(s[i] == '(')
			st.push('(');
		if(s[i] == 'R')
			sn.push(r[s[i + 1] - '0']);
		if(s[i] == '-')
			st.push('-');
		if(s[i] == '|')
			st.push('|');
		if(s[i] == ')') {
			while(st.top() != '(') {
				if(st.top() == '-') {
					double a = sn.top();
					sn.pop();
					double b = sn.top();
					sn.pop();
					sn.push(a + b);
				}
				if(st.top() == '|') {
					double a = sn.top();
					sn.pop();
					double b = sn.top();
					sn.pop();
					sn.push(1 / (1 / a + 1 / b));
				}
				st.pop();
			}
			st.pop();
		}
	}
	cout << fixed << setprecision(5) << sn.top();
	return 0;
}
```

---

## 作者：Misophiliac (赞：0)

(upd：之前代码有点小锅，麻烦管理重审一下）

## 前言

最优解，而且觉得自己代码比较简洁，特来写一篇递归的题解。

本题难度较低，黄比较符合。

## 题意

给出一个表达式，有变量、括号和两种运算，要求求值。

既然有括号，那我们采用递归算法，逐个扫描字符：

- 如果是 `R`，表示一个变量，此时进行运算。
- 如果是 `-` 或 `|`，表示运算，用一个 `bool` 存下来。
- 如果是 `(`，表示需要递归，此时我们循环找到匹配的右括号（方法详见 [P1739](https://www.luogu.com.cn/problem/P1739)），此部分代码如下：

`for (j = i, c = 1; j < r && c; j++, s[j] == '(' ? c++ : s[j] == ')' ? c-- : 0);`

其中，`i` 是当前位置，`j` 是循环变量，`c` 是计数器，遇到左括号则加一，遇到右括号则减一，于是 `c==0` 时就表示匹配，跳出循环。

接下来则进行递归，并将结果进行运算。

## 代码

```c
#include <stdio.h>
#include <string.h>
double v[10];
char s[100005];
double cal(int l, int r) {
    double w = 0, t = 0; int o = -1;
    for (int i = l, j, c; i < r; i++) {
        if (s[i] == '(') {
            for (j = i, c = 1; j < r && c; j++, s[j] == '(' ? c++ : s[j] == ')' ? c-- : 0);
            t = cal(i + 1, j), i = j;
        }
        else if (s[i] == 'R') t = v[s[i+1]^'0'];
        else { o = s[i] == '-' ? 0 : s[i] == '|' ? 1 : o; continue; }
        w = ~o ? o ? w * t / (w + t) : w + t : t;
    }
    return w;
}
int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%lf", v + i);
    scanf("%s", s); printf("%lf\n", cal(0, strlen(s)));
    return 0;
}
```

---

## 作者：rzh123 (赞：0)

# P8035 题解  

题目链接：[P8035 \[COCI2015-2016\#7\] Otpor](https://www.luogu.com.cn/problem/P8035)  

由于括号嵌套，每一个括号内的规则都相同，可以使用递归。  

函数 `calc(i)` 计算从 $i$ 开始的一对括号中表达式的值，并将指针 $i$ 修改为右括号位置。  

根据常识或者题目中的式子，串联、并联都满足结合律，为了计算方便，可以把多个电阻串联、并联拆分成两个电阻之间的计算，转化成简单的二元运算符，从左往右依次计算。  

例如： `(R1-R2-R3-R4)` 当做 `(((R1-R2)-R3)-R4)` 计算。  

+ 串联：$R_{1}-R_{2}=R_{1}+R_{2}$  

+ 并联：$R_{1}|R_{2}=\dfrac{R_{1} \cdot R_{2}}{R_{1}+R_{2}}$  

另外，因为 $1 \le N \le 9$，所以不需要太复杂的字符串处理，读取到 `R` 时编号就是下一个字符对应的数字。

这样就可以写出代码：  

```cpp
#include <cstdio>
#include <cstring>
#define N 13
#define L 100077
int n,buf=0;
double r[N];
char expr[L];
double getr(char id){
	return r[id&15];
}
double calcs(double r1,double r2){
	return r1+r2;
}
double calcp(double r1,double r2){
	return (r1*r2)/(r1+r2);
}
double calc(int &x){
	if(expr[x]=='R'){
		++x;
		return getr(expr[x]);
	}
	int i;
	char c;
	double crt=0;
	int flg=666666;
	for(i=x+1;flg;){
		c=expr[i];
		switch(c){
			case '(':{
				crt=calc(i);
				++i;
				break;
			}
			case ')':{
				flg=0;
				break;
			}
			case 'R':{
				++i;
				crt=getr(expr[i]);
				++i;
				break;
			}
			case '-':{
				++i;
				crt=calcs(crt,calc(i));
				++i;
				break;
			}
			case '|':{
				++i;
				crt=calcp(crt,calc(i));
				++i;
				break;
			}
		}
	}
	x=i;
	return crt;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lf",r+i);
	}
	scanf("%s",expr);
	printf("%.5f\n",calc(buf));
	return 0;
}
```  

[AC 记录 (目前最优解)](https://www.luogu.com.cn/record/66710162)  

---


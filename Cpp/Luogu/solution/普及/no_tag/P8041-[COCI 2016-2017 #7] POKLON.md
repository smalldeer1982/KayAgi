# [COCI 2016/2017 #7] POKLON

## 题目描述

今天，Kile 在庆祝他的生日。他最好的朋友 Ivan 决定送给他一个特殊的天平。这种天平的特点是它是递归的，即在每个梁的末端，要么有一个砝码，要么有一个新的天平，要么什么都没有。当然，如果天平左梁上的总质量大于右梁上的总质量，则天平会向左倾斜。类似地，如果右侧梁上的质量较大，则天平向右倾斜。否则，我们说天平是平衡的。注意这里和我们平常所了解的天平的平衡条件是不同的。下图是一个该类天平的例子。 

![](https://cdn.luogu.com.cn/upload/image_hosting/vupj9ham.png)

Kile 真的很喜欢这份礼物，作为一名真正的计算机科学家，他立即尝试使用总质量尽可能小的新的砝码来平衡这份礼物。新砝码的重量应该是**正实数**。如果某一个天平本身是平衡的，并且它的所有子天平都是平衡的，那么我们说这个天平是平衡的。

成功平衡天平后，Kile 决定在胸前纹上天平上砝码的总质量，以二进制表示，不带前导零。可以证明总质量必然是一个**正整数**。我们想知道 Kile 在胸前纹的的号码是多少，即以质量尽可能小的新的砝码来平衡这个天平之后，天平上所有砝码的总质量的二进制表示。

## 说明/提示

**【样例 1 解释】**

天平的初始状态见题目描述中的图片。Kile 将会在 $2$ 号天平的左侧放一个质量为 $1$ 的砝码，右侧放一个质量为 $2$ 的砝码。此时，两个天平都处于平衡状态，可以证明这种方案增加的新的砝码的质量是最小的。此时，天平上所有砝码的总质量是 $5+5+10=20$，其二进制表示为 $10100$。

**【数据范围】**

对于所有数据，$1\leqslant N\leqslant 10^6$，$-10^9\leqslant a,b\leqslant N$。

**【题目来源】**

本题来源自 **_[COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST 7](https://hsin.hr/coci/archive/2016_2017/contest7_tasks.pdf) T4 POKLON_**，按照原题数据配置，满分 $120$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
2
2 -10
-4 -3```

### 输出

```
10100```

## 样例 #2

### 输入

```
4
2 3
-9 4
-2 -13
-1 -7```

### 输出

```
111000```

# 题解

## 作者：伟大的王夫子 (赞：3)

树形 DP。

令 $dp_{x}$ 表示以 $x$ 为根的子树的最小质量。设 $L_x$ 为 $x$ 左子节点，$R_x$ 为右子节点，那么 $dp_x = 2 \times \max(dp_{L_x}, dp_{R_x})$。对于一个叶子节点，那么其 dp 值等于该节点的砝码重量。

但这样明显通过不了此题。可以构造数据，使得答案非常大。于是我们可以将 $dp_x$ 的定义改为答案的对数，并且用数组 $pre$ 记录 $dp_x$ 是从哪个节点转移过来的，方便构造方案。我们输出答案则是根据 $pre$ 数组一直往下走，直到找到一个叶子节点为止。设这个叶子结点的质量为 $y$，并且我们走过了 $cnt$ 条边，那么答案便是 $y \times 2 ^ {cnt}$，十分容易用二进制输出。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
using LL = long long;
struct {
    int l, r, v;
} a[N];
bool v[N];
int n, pre[N];
double dfs(int x) {
    double ll, rr;
    if (a[x].l > 0)
        ll = dfs(a[x].l);
    else
        ll = log2(-a[x].l);
    if (a[x].r > 0)
        rr = dfs(a[x].r);
    else
        rr = log2(-a[x].r);
    if (ll > rr)
        pre[x] = a[x].l;
    else
        pre[x] = a[x].r;
    return max(ll, rr) + 1;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &a[i].l, &a[i].r);
        if (a[i].l > 0)
            v[a[i].l] = 1;
        if (a[i].r > 0)
            v[a[i].r] = 1;
    }
    for (int i = 1; i <= n; ++i)
        if (!v[i]) {
            dfs(i);
            int x = i, cnt = 0;
            while (x > 0) {
                x = pre[x];
                ++cnt;
            }
            bool ff = 0;
            x = -x;
            for (int i = 30; i >= 0; --i)
                if (x & 1 << i)
                    printf("1"), ff = 1;
                else if (ff)
                    printf("0");
            for (int i = 1; i <= cnt; ++i) printf("0");
        }
}
```

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8041)

# 解析

## 题目大意

有一种天平，他的两边可能是一个数也可能是一个天平 (若是天平，则这一端的值为所挂天平的两端的和)。若要满足这个天平平衡，可以加一些砝码，以二进制形式输出最少要加多少砝码的和。

## 考察知识

本题考查树形结构。

## 思路

我们先创立一个变量 $depth$ 表示树的深度，用一个数组 $tianpin$ 表示每一个天平的左右两端较大值，即树的某一层的最大值。我们可以通过递归算出其值，接着找到每一层的最大值进行比较得到整个天平的最大值，并记录最大值所属层数，然后我们尽量让所有的天平满足。

先输出最大值，然后让前面的那些层全部都满足这个值，也就是设前面有 $a$ 层，那么和就是最大值乘上 $a$，那么观察一下二进制的规律就可以得出，接下来只需要输出 $a$ 个 $0$ 即可得到最小值。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,tree_depth,tianpin_maxnum[N],weishu=0,num[N];
struct node
{
	int l,r;
}tianpin[N];

void dfs(int num,int h)
{
	tree_depth=max(tree_depth,h);
	if(num<0)
	{
		tianpin_maxnum[h]=max(-num,tianpin_maxnum[h]);
		return ;
	}
	dfs(tianpin[num].l,h+1);
	dfs(tianpin[num].r,h+1);
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) 
	{
		cin>>tianpin[i].l>>tianpin[i].r;
	}
	dfs(1,0);
	int maxnum=0,maxnum_level=0,level_maxnum=-1;
	for(int i=0;i<=tree_depth;i++)
	{
		if(tianpin_maxnum[i]>level_maxnum)
		{
                        level_maxnum=tianpin_maxnum[i]；
			maxnum=level_maxnum;
			maxnum_level=i;
		}
		level_maxnum/=2;
	}
	while(maxnum)
	{
		num[++weishu]=maxnum%2;
		maxnum/=2;
	}
	for(int i=weishu;i>=1;i--) 
	{
		cout<<num[i];
	}
	for(int i=1;i<=maxnum_level;i++) 
	{
		cout<<0;
	}
}
```

---

## 作者：_zexal_ (赞：0)

我们用　$f_{i1},f_{i2}$ 表示对于点 $i$ 的两个儿子。
## 思路
考虑到只能添加砝码，所以每一天平的重量修改后最少都是 $2\times\max\{f_{i1},f_{i2}\}$。接着，我们需要从找到一个基准值，让基准值下面的天平和为他，上面由基准值构成，这样，我们就可以表达出最后的总和了，为基准值 $\times 2^k$，$k$ 为基准值的存在的层数。如何找到基准值也很简单，我们进行一次深度优先搜索，记录每一层的 $2\times\max\{f_{i1},f_{i2}\}$，然后比较即可。
## 坑点
题目数据太大，我们肯定不能直接计算答案再转换，注意到答案可以表示为基准值 $\times 2^k$，所以其实就是基准值后面跟上 $k$ 个 $0$ 了。
## AcCode
```cpp
#include<bits/stdc++.h>
#define N 1000010
using namespace std;
int r[N],l[N],n,maxn,h1[N];
int a[10001];
void dfs(int num,int h){
	maxn=max(maxn,h);
	if(num<0){
		h1[h]=max(-num,h1[h]);
		return;
	}
	dfs(r[num],h+1);
	dfs(l[num],h+1);
}
int main(){
	//freopen("balance.in","r",stdin);
//	freopen("balance.out","w",stdout); 
	cin>>n;
	for(int i=1;i<=n;i++) cin>>r[i]>>l[i];
	dfs(1,0);
	int a1=0,a2=0,now=-1;
	for(int i=0;i<=maxn;i++){
		if(h1[i]>now){
			a1=now=h1[i];
			a2=i;
		}
		now/=2;
	}
	int p=0;
	while(a1!=0){
		a[++p]=a1%2;
		a1/=2;
	} 
	for(int i=p;i>=1;i--) cout<<a[i];
	for(int i=1;i<=a2;i++) cout<<0;
	return 0;
} 
```


---

## 作者：include_BM (赞：0)

由于每个天平都要平衡，且较小的天平先调整后就不用再考虑，所以我们可以使用 dfs 递归的调整每个天平。

对于一个天平，若左右大小分别为 $a,b$，那么调整后的大小为 $2\times \max\{a,b\}$。

设 $f_i$ 表示将 $i$ 天平内的天平调整好后的大小，那么 $f_x=2\times\max\{f_{a_i},f_{b_i}\}$（$a_i,b_i$ 分别为天平 $i$ 的两端），最终答案即为 $f_1$，注意特判天平一端为单个砝码的情况。

最终 $f_i$ 一定可以表示为 $x\times 2^k$ 的形式，其中 $1\le x\le 10^9,0\le k\le n$，这个数字可能非常大，但是我们可以用一个二元组 $(x_i,k_i)$ 表示 $f_i$。

在比较 $f_i$ 和 $f_j$ 的大小时（不妨设 $k_i\ge k_j$），若 $k_i-k_j>30$，由于 $10^9<2^{30}$，由 $k$ 造成的差距无法用 $x$ 来弥补，故可以直接确定 $f_i,f_j$ 的大小关系；否则可以将 $f_i,f_j$ 分别除以 $2^{k_j}$，再比较 $x_i\times 2^{k_i-k_j}$ 和 $x_j$ 的关系，由于 $k_i-k_j\le30$，这两个数都是在 long long 范围内的，可以直接比较。

最后输出答案时先输出 $x_1$ 的二进制表示，再输出 $k_1$ 个 $0$ 即可。

---


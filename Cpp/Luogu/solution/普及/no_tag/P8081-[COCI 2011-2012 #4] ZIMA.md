# [COCI 2011/2012 #4] ZIMA

## 题目描述

给定 $N$ 天的气温情况。规定：

- 当一天的温度小于 $0$ 时，则称之为冰冻日。
- 当连续 $T$ 天都是冰冻日时，则称之为一个持续时间为 $T$ 的冰期。

冰期来临之前的若干天都会被标为警示状态。若一个冰期的持续时间为 $T$ 天，则规定：

- 若一段冰期不是所有冰期中最长的，那么冰期来临之前的 $2T$ 天都被标记为警示状态。
- 若一段冰期是所有冰期中最长的，那么冰期来临之前的 $3T$ 天都被标记为警示状态。特别地，如果有多个最长的冰期，则只有一个被标记 $3T$ 天，其它的都为 $2T$ 天。
- 若当前正处于冰期，则不允许对当前冰期进行警示，但若条件允许，可以对未来的冰期进行警示。

你可以任意选择一个最长的冰期使得其来临之前需要被标记 $3T$ 天。求在所有选择的情况中，处于警示状态天数的最大值。

## 说明/提示

**【样例 1 解释】**

长度最长的冰期有 $3$ 个：$\texttt{-1; -2; -3}$。

当选择 $\texttt{-2}$ 作为需要在来临之前标记 $3T$ 天为警示状态的冰期时，处于警示状态的天数最大：

|天数|$1$|$2$|$3$|$4$|$5$|$6$|$7$|$8$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|温度|$1$|$-1$|$4$|$3$|$8$|$-2$|$3$|$-3$|
|是否为冰期|否|是|否|否|否|是|否|是|
|是否处于警示状态|是|否|是|是|是|是|是|否|

**【数据规模与约定】**

- 对于 $40\%$ 的数据，最长的冰期唯一。
- 对于 $100\%$ 的数据，$1 \le N \le 10^5$，$|T_i| \le 100$。

**【提示与说明】**

**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 2 ZIMA_。**

**本题分值按 COCI 原题设置，满分 $100$。由于洛谷不支持非整数分数，因此对于除不尽的情况进行了调整。**

## 样例 #1

### 输入

```
8
1 -1 4 3 8 -2 3 -3```

### 输出

```
6```

## 样例 #2

### 输入

```
15
1 2 -1 2 3 4 5 6 1 4 8 3 -1 -2 1```

### 输出

```
8```

# 题解

## 作者：Molina (赞：21)

# 题目大意
给定一个长度为 $ n $ 的序列，为 $ n $ 天每天的温度。

当一天的温度低于 $ 0 $ 时，则为冰冻日。

当连续 $ T $ 天都是冰冻日时，则称这 $ T $ 天为一个冰期，冰期来临前的   $ 2T $ 天都被标记为警示状态。

如果其中有一个冰期最长，那么它的前 $ 3T $ 天会被标记为警示状态。如果有多个冰期最长，则从中选一个冰期，使得处于警示状态的天数最大。
# 思路
## 模拟
分别定义了“警示状态”与“冰期”的数组。

进行模拟，如果为冰期则进行标记（见代码），然后标记警示状态，先全部当做   $ 2T $ 标记，然后找到适合的最大冰期，然后再用 $ 3T $ 标记。（见代码） 

最后用 $ ans $ 记录有多少警示状态，便可以开心输出了！完结撒花！

# 代码来咯~:
```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,a[N],znr[N],dt[N],ans=0;//分别定义“警示状态”与“冰期”的数组
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)  cin>>a[i];//输入
	for(int i=1;i<=n;i++){
		if(a[i]<0){
			if(i!=1 && dt[i-1]>=1)  dt[i]=dt[i-1]+1;//如果为一段冰期，则标记出一段冰期
			else dt[i]=1;//如果为冰冻日则进行标记为1；
		}
	} 
	for(int i=n;i>=1;i--)
		if(dt[i]!=0){
			int sum=dt[i];
			for(int j=1;j<=2*sum;j++){
				if(i-sum+1-j>=1)  znr[i-sum+1-j]=1;//标记警示状态
			}
		}
	int zd=dt[n],zdxb=n;
	for(int i=n-1;i>=1;i--){//查找最大冰期
		if(dt[i]>zd){
			zd=dt[i];
			zdxb=i;
		}
		else if(dt[i]==zd){
			int an=0;int bn=0;
			for(int j=1;j<=3*zd;j++)
				if(znr[i-zd+1-j]==0 && i-zd+1-j>=1){
					an++;
				}
			for(int z=1;z<=3*zd;z++)
				if(znr[zdxb-zd+1-z]==0){
					bn++;
				}
			if(an>=bn){//进行比较，找到能使警示状态最多的冰期进行 3T 进行标记
				zdxb=i;
				zd=dt[i];
			}  
		}
	}
	for(int i=1;i<=zd*3;i++)
		znr[zdxb-zd+1-i]=1;
	for(int i=1;i<=n;i++)
		if(znr[i]==1)
			ans++;//记录警示状态
	cout<<ans;
	return 0;
}
```

---

## 作者：Zirnc (赞：7)

一道简简单单的模拟题。。

1. 首先求出每一个冰期，记其起点为 $s$，长度为 $T$。
2. 然后用一个布尔数组计数，对于每一个冰期先标记来临之前 $2T$ 天（即为 $[s-2T, s)$）的警示状态。
3. 最后枚举每一个长度为 $T_{max}$ 的冰期，求出它们 $[s-3T, s-2T)$ 区间内新增的警示的天数的最大值，和第二步求出的警示天数相加即为答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, t[100005];
struct node {
  int s, t;
};
bool cmp(node a, node b) { return a.t > b.t; }
vector<node> tv;
int sum[100005];
bool b[100005];
int main() {
  scanf("%d", &n);
  int prev = -1;
  // Step 1.
  for (int i = 1; i <= n; i++) {
    scanf("%d", &t[i]);
    sum[i] = sum[i - 1];
    if (t[i] < 0) {
      if (prev == -1)
        prev = i;
    } else {
      sum[i]++;
      if (t[i - 1] < 0) {
        int curt = i - prev;
        tv.push_back({prev, curt});
        prev = -1;
      }
    }
  }
  if (t[n] < 0)
    tv.push_back({prev, n - prev + 1});
  sort(tv.begin(), tv.end(), cmp);
  // Step 2.
  int ans = 0, ans2 = 0;
  for (int i = 0; i < tv.size(); i++) {
    for (int j = max(1, tv[i].s - tv[i].t * 2); j < tv[i].s; j++) {
      if (b[j] == 0)
        ans++;
      b[j] = 1;
    }
  }
  // Step 3.
  for (int i = 0; i < tv.size(); i++) {
    if (tv[i].t < tv[0].t)
      break;
    int cnt = 0;
    for (int j = max(1, tv[i].s - tv[i].t * 3);
         j < max(1, tv[i].s - tv[i].t * 2); j++) {
      if (b[j] == 0)
        cnt++;
    }
    ans2 = max(ans2, cnt);
  }
  printf("%d\n", ans + ans2);
  return 0;
}
```

---

## 作者：_lgh_ (赞：6)

看到题目发现很长，整理一下：
### 题意：

给定一个长度为 $N$ 的序列，求其中小于 $0$ 的尽可能长的序列，设这个序列长度为 $T$ ，将这个序列钱的 $2T$ 天标记，再选一个序列将这个序列的前面 $3T$ 天标记，求能标记的最长长度（不要求连续）。

**直接按照题意模拟：** 先标记每一段最前面的 $2T$ 天，然后一段段遍历，看哪一段加的最多标记，然后输出就没了。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+10;
int n,a[N],x,t,s[N],Max[2],yq[N],ans=0;
bool f[N];
int main()
{
  freopen("zima.in","r",stdin);
  freopen("zima.out","w",stdout);
  a[0]=1;
  scanf("%d",&n);
  for(int i=1; i<=n; i++)
  {
    scanf("%d",&a[i]);
    if(a[i]<0&&a[i-1]>=0) s[++x]=i;
    if(a[i]>=0&&a[i-1]<0) yq[x]=i-s[x],Max[0]=max(Max[0],yq[x]);
  }
  if(a[n]<0) yq[x]=n+1-s[x];
  Max[0]=max(Max[0],yq[x]);
  for(int i=1; i<=x; i++) for(int j=s[i]-1; j>=s[i]-2*yq[i]&&j>=0; j--) f[j]=1;//前 2T 天标为冰期
  for(int i=1; i<=x; i++)
  {
    ans=0;
    if(yq[i]==Max[0]) for(int j=s[i]-2*yq[i]-1; j>=s[i]-3*yq[i]&&j>=0; j--) if(f[j]!=1) ans++;//找最大增益
    Max[1]=max(Max[1],ans);
  }
  ans=0;
  for(int i=1; i<=n; i++) if(f[i]==1) ans++;
  printf("%d\n",ans+Max[1]);
  return 0;
}
```

---

## 作者：bloodstalk (赞：5)

## 题意
给定一个长度为 $n$ 的序列。

当连续 $T$ 天温度都小于 $0$ 时，则称这 $T$ 天为一个冰期，冰期来临之前的 $2T$ 天都被标记为警示状态.

特殊地，如果一个冰期最长，那么它的前 $3T$ 天会被标记为警示状态。如果有多个冰期最长，选一个。

## 思路
### 模拟
- 预处理出每个冰期的长度和起始天数，然后在起始天数的前 $2T$ 天打上标记（注意不要越界）。
- 对长度进行排序，找出最长天数。在最长天数中比较变成 $3T$ 后哪一个原先没打上标记现在打上标记的个数最多，找到这个增量。用前缀和数组维护之前被打上标记的个数，以此来找到增量。
- 最后的结果就是原先标记的个数加上这个增量。

## 代码实现

```
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt;
#define re register
#define il inline
const int N=1e5+10;
using namespace std;

int a[N];
struct node{
	int l,r;
	int day;
}icy[N];int cnt;/*icy数组记录冰期左右端点，和持续的时间*/
int ice[N],add[N],l,r,tot;/*ice数据就是标记，add数组是前缀和数组*/

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

il bool mysort(node a,node b) 
{
	if(a.day == b.day) return a.l > b.l;
	else return a.day > b.day;/*按天数从大到小排序*/
}

int n,ans;

signed main()
{
	n=read();
	for(re int i=1;i<=n;i++)	a[i]=read();
	for(re int i=1;i<=n;i++)
		if(a[i] < 0)
		{
			icy[++cnt].l=i;
			while(a[i]<0 && i<=n) i++; i-=1;/*找冰期的左右端点和持续时间*/
			icy[cnt].r=i;
			icy[cnt].day=icy[cnt].r-icy[cnt].l+1;
		}
	for(re int i=1;i<=cnt;i++)
		for(re int j=max(1,icy[i].l-icy[i].day*2);j<=icy[i].l-1;j++)/*给每个冰期的前2T天打上标记，注意不要越界*/
			ice[j]=1; 
	for(int i=1;i<=n;i++) add[i]=add[i-1]+ice[i];/*求前缀和数组*/
	sort(icy+1,icy+cnt+1,mysort);/*从大到小排序*/
	int maxday=icy[1].day,maxcover=0;/*maxcover就是那个增量*/
	for(int i=1;i<=cnt;i++)
	{
		if(icy[i].day <	maxday) break;/*不是最长天就可以break了*/
		r=icy[i].l-icy[i].day*2-1;/*因为前2T天我们已经打上标记了，我们只需要判断最左边的T的增量就可以了*/
		l=icy[i].l-icy[i].day*3;
		if(r<=0) continue;/*越界了就continue*/
		if(l<=0) l=1;/*l越界了r没有越界，就把l设成1*/
		tot=r-l+1;/*计算总共的天数*/
		if(maxcover < tot-(add[r]-add[l-1])) maxcover = tot-(add[r]-add[l-1]);/*tot是总天数*/
	}/*add[r]-add[l-1]是标记过的天数，一相减，就是变成3T后多出来的个数，即增量*/
	printf("%d",maxcover + add[n]); /*增量 + 原先的个数*/
	return 0;
}
```


---

## 作者：gyyyyx (赞：4)

[题面](https://www.luogu.com.cn/problem/P8081)

很简单的模拟。

按照题面的意思，设某冰期的起点为 $s_i$，长度为 $l_i$。

先将所有冰期来临前 $2l_i$ 天标记为预警状态。

然后找到所有最长的冰期，一个一个计算 $[s_i-3l_i,s_i-2l_i)$ 的贡献，找到贡献最大的，将这些天都标记为预警状态。

最后累加答案就行。

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,a[N],sum[N],d[N],mx,mxx,e,ans;
struct Node{int l,r;};
vector <Node> w,p;
int main(){
    scanf("%d",&n);
    for(int i(1);i<=n;++i){
        scanf("%d",&a[i]);
        a[i]=(a[i]<0);
    }
    for(int i(n),cnt(0);~i;--i){
        if(a[i]) ++cnt;
        else if(cnt){
            w.push_back((Node){i+1,cnt});
            mx=max(mx,cnt);cnt=0;
        }
    }
    for(int i(0);i<w.size();++i){
        ++d[max(w[i].l-(w[i].r<<1),0)];--d[w[i].l];
        if(w[i].r>=mx) p.push_back(w[i]);
    }	
    for(int i(1);i<=n;++i) d[i]+=d[i-1];
    for(int i(1);i<=n;++i) d[i]=(d[i]>0);
    for(int i(1);i<=n;++i) sum[i]=sum[i-1]+d[i];
    for(int i(0);i<p.size();++i){
        int L(max(p[i].l-mx-(mx<<1)-1,0)),R(max(p[i].l-(mx<<1)-1,0));
        int res(R-L-sum[R]+sum[L]);if(res>mxx){mxx=res;e=R;}
    }
    for(int i(e);i>e-mx;--i) d[i]=1;
    for(int i(1);i<=n;++i) ans+=d[i];
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：cyhyyds (赞：3)

提供一种复杂度上限高，但是因为本题数据较弱可以通过的解法。

先预处理所有雪期的长度和结尾，然后再筛选出雪期最长的雪期结尾，枚举这些雪期，然后直接计算当该雪期警示状态标记为 $3T$ 天时，处于警示状态的总共天数值，最后取最大值即可。

然后我们分析时间复杂度：

$1.$ 预处理所有雪期的长度和结尾是 $O(n)$ 的。

$2.$ 筛选出雪期最长的雪期结尾最坏是 $O(\frac{n}{2})$ 的。

$3.$ 枚举雪期最长的雪期，直接计算总共天数值，最坏是 $O(n)$ 的。

那么我们的最差复杂度为 $O(\frac{n^2}{2})$ 的！

但是因为数据的特殊，雪期最长的雪期个数可以记为常数 $w$，枚举雪期最长的雪期，直接计算总共天数值也可以记为 $wn$，那么我们的总复杂度就是 $O(w^2n)$，轻松的通过此题，不开 $O2$ 用时 $101ms$。

---

## 作者：lyt_awa (赞：3)

## 思路
这题是道模拟题。

直接将每一段冰期的长度 $T_i$ 和开始的时间 $pos_i$ 计算出来，然后把其前 $2 \times T_i$ 天都做个标记， 顺便将最长的长度算出来。
```cpp
for (int i = 1; i <= n; ++i) a[i] = rd() < 0;
for (int i = n; i; --i)
	if (a[i] && a[i + 1]) a[i] += a[i + 1], a[i + 1] = 0;
for (int i = n, r = n + 1; i; --i) {
	vis[i] = i >= r;
	r = min(r, max(i - a[i] * 2, 1));
	mxa = max(mxa, a[i]);
}
```

最后再枚举每一个长度等于最大长度的冰期，计算其前 $3 \times T_i$ 中没被标记的个数，再取个最大值加上被标记的个数就是答案。
```cpp
for (int i = n, r = n + 1; i; --i) {
	r = min(r, max(i - a[i] * 2, 1));
	if (a[i] == mxa) {
		int res = 0;
		for (int j = 1; j <= a[i] && r - j > 0; ++j)
			if (!vis[r - j]) ++res;
		ans = max(ans, res);
	}
}
for (int i = 1; i <= n; ++i) ans += vis[i];
```

---


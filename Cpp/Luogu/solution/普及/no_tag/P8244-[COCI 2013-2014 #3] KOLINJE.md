# [COCI 2013/2014 #3] KOLINJE

## 题目描述

在一年一度的生猪屠宰会上，屠夫 Bajs 正在进行活动的最后一个环节——将自己那条屡获殊荣的火腿拿出一部分，分给参加活动的所有人。

今年的生猪屠宰会一共有 $n$ 个人参加，其中第 $i$ 个人目前已经吃了 $a_i$ 千克火腿。Bajs 将自己的火腿按照 $b_1:b_2:\cdots:b_n$ 的比例分给所有人，换句话说，令 $S=\sum\limits_{j=1}^nb_j$，则第 $i$ 个人将分到总火腿重量的 $\dfrac{b_i}S$。

但是，直到现在，Bajs 也没能确定他要拿出的火腿总量，因为在给每个人分完火腿并吃完以后，现场将根据每个人吃的火腿的千克数从大到小列出一个排名表（如果有两个人吃的肉的千克数相同，则按照两个人的编号从小到大排序），并宣布本次生猪屠宰会的年度人物，即排名表的第一位。虽然 Bajs 曾多次受到他人贿赂，但是他仍旧不愿改变分配的比例，并说他很诚实并且心地善良。Bajs 是个重度强迫症患者，因此他希望排名表上的人的编号从前往后依次为 $1,2,\cdots,n$。请你帮助 Bajs 确定他要拿出的火腿总量，以满足 Bajs 的要求。

## 说明/提示

**【样例 1 解释】**

Bajs 拿出了 $10.5$ 千克火腿，由于分配的比例为 $1:2:0$，因此三个人依次分配到 $3.5$ 千克、$7$ 千克和 $0$ 千克火腿，最终三个人依次共吃了 $10.5$ 千克、$10$ 千克和 $10$ 千克火腿。这满足 Bajs 的要求。

**【数据范围与限制】**

对于所有数据，$2\leqslant n\leqslant 1000$，$0\leqslant a_i,b_i\leqslant 10^6$。

**【题目来源】**

本题来源自 **_[COCI 2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 3](https://hsin.hr/coci/archive/2013_2014/contest3_tasks.pdf) T4 KOLINJE_**，按照原题数据配置，满分 $120$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

欢迎对[本题 checker](https://www.luogu.com.cn/paste/7p24epxh) 提出改进意见。

## 样例 #1

### 输入

```
3
7 1
3 2
10 0```

### 输出

```
10.5```

## 样例 #2

### 输入

```
3
2 1
4 0
0 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
5
15 4
6 7
12 5
9 6
1 7```

### 输出

```
87```

# 题解

## 作者：看什么看 (赞：5)

### UPD：
2022/03/29：修复了题目链接（手急打错了），完善了一些语言。

### 原题链接

[P8244 \[COCI2013-2014#3\] KOLINJE](https://www.luogu.com.cn/problem/P8244)

### 思路

我们设 $x$ 为最终的答案，$S = \sum\limits_{i=1}^n b_i$，那么题目就是要求找到一个 $[0, 10^7]$ 范围内的浮点数 $x$，使得 $x$ 满足以下不等式组：

$\begin{cases}a_1 + \dfrac{b_1}{S}x \ge a_2 + \dfrac{b_2}{S}x\\\\a_2 + \dfrac{b_2}{S}x \ge a_3 + \dfrac{b_3}{S}x\\\ldots\\a_{n-1} + \dfrac{b_{n-1}}{S}x \ge a_n + \dfrac{b_n}{S}x\end{cases}$

对于不等式：

$a_i + \dfrac{b_i}{S}x \ge a_{i+1} + \dfrac{b_{i+1}}{S}x$

我们将 $\dfrac{b_{i+1}}{S}x$ 移到左边，将 $a_i$ 移到右边，得：

$\dfrac{b_i-b_{i+1}}{S}x \ge a_{i+1}-a_i$

接下来就有三种情况：

#### Case 1: $b_i > b_{i+1}$

$x \ge \dfrac{S(a_{i+1}-a_i)}{b_i-b_{i+1}}$，此时我们得到了 $x$ 的一个下界。

#### Case 2: $b_i < b_{i+1}$

$x \le \dfrac{S(a_{i+1}-a_i)}{b_i-b_{i+1}}$，此时我们得到了 $x$ 的一个上界。

#### Case 3: $b_i = b_{i+1}$

$\begin{cases}a_{i+1}-a_i>0\text{，不等式组无解，直接输出 -1 即可。}\\a_{i+1}-a_i\le0, x \in \mathrm{R}\text{，此时我们什么都不用做。}\end{cases}$

最后判断一下，如果 $x$ 的下界大于 $x$ 的上界，那么也无解。否则输出范围内任意一个 $x$ 即可。

### Code：

实现上的一些细节：

1. 注意 $x$ 本来还有一个 $[0,10^7]$ 的范围限制。
1. 要输出多几位小数，要不然精度不够就 WA 了。
1. 我的代码在计算过程中采用分数避免精度问题，如果是用小数实现的要注意细节上的处理。

然后我们就可以~~愉快地~~写出以下的代码了：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
struct node{
	ll fz, fm;
	node (ll x, ll y){
		if (y < 0) y = -y, x = -x; // 把负号存在分子
		fz = x / __gcd(abs(x), y);
		fm = y / __gcd(abs(x), y); // 不约分其实也可以
	}
	bool operator <(const node &a) const {
		return (fz * a.fm < fm * a.fz);
	}
	bool operator >(const node &a) const {
		return (fz * a.fm > fm * a.fz);
	}
};
int n, a[1003], b[1003];
node xmin = node(0, 1), xmax = node(1e7, 1); // x 最开始的上下界
ll S = 0;
int main(){
	scanf ("%d", &n);
	for (int i = 1;i <= n;++i){
		scanf ("%d%d", a+i, b+i);
		S += b[i];
	}
	for (int i = 1;i < n;++i){
		if (b[i] > b[i+1]) xmin = max(xmin, node(S * (a[i+1] - a[i]), b[i] - b[i+1])); // Case 1
		else if (b[i] < b[i+1]) xmax = min(xmax, node(S * (a[i+1] - a[i]), b[i] - b[i+1])); // Case 2
		else if (a[i+1] - a[i] > 0) { // Case 3
			printf("-1");
			return 0;
		}
	}
	if (xmin > xmax) {
		printf("-1");
		return 0;
	}
	printf ("%.10f", (double)xmin.fz / xmin.fm);
	return 0;
}
```

---

## 作者：Allan_Xu (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P8244)

转化一下题意，可得：
我们要找到一个数 $k$ ，使得其满足 $n-1$ 个不等式：

$$\sum_{i=1}^{n-1} a_i+b_{i}\times k \geq a_{i+1} +b_{i+1} \times k$$

移一下项：

$$\sum_{i=1}^{n-1} a_i-a_{i+1} \geq (b_{i+1} - b_i)\times k$$

可以发现，我们只需要把每一个不等式处理出来，取并集就是 $k$ 的解集；

又因他要最小的，取下界即可；

考虑如何解一个不等式：

1. $b_{i+1} - b_i > 0$，有 $ k \le \frac{a_i-a_{i+1}}{b_{i+1} - b_i}$
2. $b_{i+1} - b_i < 0$,有 $k \ge \frac{a_i-a_{i+1}}{b_{i+1} - b_i}$
3. $b_{i+1} - b_i = 0$,有 $a_i-a_{i+1} \ge 0$

（其实就是模拟解不等式的过程）

>注意事项：
>
>1. 精度问题；
>2. 一定要考虑  $b_{i+1} - b_i = 0$ 的情况；
>3. 像解不等式组，也有上界小于下界的情况，无解；
>4. 最后的答案是 $k\times \sum_{i=1}^n b_i$;

*code*

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
inline long long read(){//快读
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
const int N=1e3+5;
int n;
int a[N],b[N];
int da[N],db[N];
int32_t main(){
//	ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
//	freopen("huo.in","r",stdin);
//	freopen("huo.out","w",stdout);
	n=read();
	long double sum=0;
	long double L=0,R=1e9;
	for(int i=1;i<=n;i++)a[i]=read(),b[i]=read(),sum+=b[i];
	for(int i=1;i<n;i++){
		da[i]=a[i]-a[i+1];
		db[i]=b[i+1]-b[i];
		if(db[i]>0){
			R=min(R,(long double)da[i]/db[i]);
		}else if(db[i]<0){
			L=max(L,(long double)da[i]/db[i]);
		}else{
			if(da[i]<0)return puts("-1"),0;
		}
	}
	if(R<L)return puts("-1"),0;
	cout<<fixed << setprecision(12) << L*sum;
	return 0;
}

```

完结撒花

---

## 作者：hh__hh (赞：0)

这道题实际上是一个线性规划问题。假设 Bajs 拿出的火腿总量为 $x$，则根据题目要求，第 $i$ 个人得到的火腿重量为:

$$\frac{b_{i}}{ \sum\limits_{j=1}^{n} b_{j}} \times x_{i}$$

我们需要满足以下三个条件：

1. 所有人得到的火腿总量之和等于 $x:\sum\limits_{i=1}^{n} \frac{b_{i}}{ \sum\limits_{j=1}^{n} b_{j}} \times x_{i}=x$。

2. 每个人得到的火腿重量不小于已经吃的火腿重量：$\frac{b_{i}}{ \sum\limits_{j=1}^{n} b_{j}} \times x_{i} \ge a_{i},\forall i$。

3. 排名表的编号从前往后依次为 $1,2,\cdots,n$。

根据条件 $1$ 可得：

$$\sum\limits_{i=1}^{n} \frac{b_{i}}{ \sum_{j=1}^{n} b_{j}}=1$$

将条件 $2$ 代入条件 $1$ 中，得：

$$ \sum\limits_{j=1}^{n} \frac{a_{i}}{x} \le 1$$

根据条件 $3$，我们可以将 $b_{i}$ 排序为非递增数列。

因此，我们可以使用二分法来确定 $x$ 的取值范围。对于给定的 $x$ 我们可以根据条件 $2$ 来判断是否满足要求，如果满足要求，则尝试减小 $x$，否则尝试增大 $x$。

具体算法如下：

1. 对于 $b_{i}$ 按非递增排序。

2. 令 $\text{left} = 0$，$\text{right} = \sum\limits_{i=1}^{n} a_{i}$，则 $x$ 的取值范围为 $\left[\text{left},\text{right} \right]$。

3. 当 $right-left > \epsilon $（$\epsilon $ 为一个较小的数，比如 $10^{-6}$）时重复一下步骤：

- 令 $k=\frac{left+right}{2}$，即取 $x$ 的中间值。

- 遍历所有人，计算每个人得到的火腿的重量 $ \frac{b_{i}}{ \sum\limits_{j=1}^{n} b_{j}} \times k$，并与已经吃的火腿重量 $a_{i}$ 进行比较。

- 如果对所有人都有 $\frac{b_{i}}{ \sum\limits_{j=1}^{n} b_{j}} \times k  \ge a_{i}$，则更新 $left=k$。

- 否则，更新 $right=k$。

4. 输出 $left$ 作为答案。

-----------------------------------------

复杂度分析：

时间复杂度：

排序需要 $O\left( n \log n \right)$，二分需要 $O\left( \log n \right)$，所以总的时间复杂度是 $O\left(n \log n  \right)$。

---


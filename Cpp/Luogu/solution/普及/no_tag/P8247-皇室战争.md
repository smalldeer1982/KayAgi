# 皇室战争

## 题目描述

训练场可以看作成一个 $n \times m$ 的字符矩阵，每个单元为`S`，`K`或`.`。

`S`为神箭游侠，`K`为骷髅。众所周知，神箭游侠的箭是可以穿透的。（我们把他的箭的射程看作是一条射线，且无限长）。由于骷髅很脆，所以打一下就死。已知骷髅都不会动，问你他最少射几箭才能使所有的骷髅都死亡？

假设所有的人物都站在点上，且无限小。

## 说明/提示

* Subtask 1（15 分）：$1 \le n,m \le 10$；
* Subtask 2（20 分）：$1 \le n,m \le 400$；
* Subtask 3（35 分）：$1 \le n,m \le 10^3$；
* Subtask 4（30 分）：$1 \le n\times m \le 10^6$。

$n,m$ 均为正整数。

样例 $1$ 解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/9vabxn60.png)


## 样例 #1

### 输入

```
3 5
K...K
.K.K.
..S..```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5
KKKKK
KKSKK
KKKKK```

### 输出

```
12```

# 题解

## 作者：I_Love_Potter (赞：24)

**思路**

将骷髅的横坐标、纵坐标的比化简成最简形式，再用容器去重，再输出容器内的数量。

看到这里，如果你是因为没有思路点进来的，建议按照上面的思路试着写一写哦

**代码**
```cpp
#include<bits/stdc++.h>//万能头YYDS 
using namespace std;
map<pair<int,int>/*我试着用结构体 但是不行*/,bool>mp;
int n,m,sx,sy;
char c;
queue<pair<int,int> >kulou;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>c;
            if(c=='K') kulou.push(make_pair(i,j));//把每个骷髅的位置存起来 
            if(c=='S') sx=i,sy=j;//记录神箭游侠的位置 
        }
    }
    
    while(!kulou.empty()){
        int tx=kulou.front().first,ty=kulou.front().second;
        kulou.pop();
		tx-=sx;
		ty-=sy;
        int g=abs(__gcd(tx,ty));
        tx/=g;//化简比 
		ty/=g;//化简比 
        mp[make_pair(tx,ty)]=true;//类似桶的思想 
    }
	cout<<mp.size();//输出长度 
    return 0;
}
```
**最后**

这是我的第一篇题解，希望管理大大通过，管理员辛苦了


---

## 作者：lsj2009 (赞：7)

## 题目大意
<https://www.luogu.com.cn/problem/P8247>。
## 思路
我们不妨先来考虑，如果神箭游侠处于 $(1,1)$ 点，那么怎样的点 $(a_1,b_1)$ 与 $(a_2,b_2)$ 才能满足他们处于以 $(1,1)$ 为端点的同一条射线上呢？

是的就是始他们与 $(1,1)$ 点处连接的线段对于经 $(1,1)$ 而垂直与 $y$ 轴的直线而言角度相同即可：

![](https://s1.ax1x.com/2022/03/23/q3kUoT.png)

如图，点 $\texttt{A}$ 位于 $(1,1)$ 点，边 $\texttt{AB}$ 与边 $\texttt{AC}$ 对于点 $\texttt{A}$ 而言角度相同（对于经 $(1,1)$ 而垂直与 $y$ 轴的直线），则处于同一射线；$\texttt{AD}$ 与 $\texttt{AF}$ 同理。

而对于两点点 $(x_1,y_1)$ 与点 $(x_2,y_2)$ 连接点 $(1,1)$ 所形成的的两条线段角度相同（重叠）的必要也是唯一条件是 $(x_1-1):(y_1-1)=(x_2-1):(y_2-1)$。

我们可以将点 $(x-1):(y-1)$ 约分最简比使用二元 ``bool`` 数组 $(\frac{x-1}{\gcd(x-1,y-1)},\frac{y-1}{\gcd(x-1,y-1)})$ 记录之。

回到问题。

我们说过上述算法是记录在神箭游侠处于 $(1,1)$ 点处的。为什么呢？因为这样便证了骷髅均在其的上、右、右上处，如果位置不一定，那么骷髅便可以在其的上、下、左上、右上、左下、右下四个方向了。

不过没关系，我们不妨把其分为四个部分：

![](https://s1.ax1x.com/2022/03/23/q3ZXbn.png)

其中红点代表着神箭游侠。

我们将左、上归于左上，将右归于右上，将下归于左下。

不妨设游侠坐标为 $(sx,sy)$，那么则对于四块部分我们可以用相同的代码分布计算：

- 循环 $x$ 从 $1$ 至 $sx$，$y$ 从 $1$ 至 $sy$，如果 $(x,y)$ 有骷髅且 $(\frac{|x-sx|}{\gcd(|x-sx|,|y-sy|)},\frac{|y-sy|}{\gcd(|x-sx|,|y-sy|)})$ 在左下没有出现过，则将答案 $+1$；

- 循环 $x$ 从 $sx+1$ 至 $n$，$y$ 从 $1$ 至 $sy$，如果 $(x,y)$ 有骷髅且 $(\frac{|x-sx|}{\gcd(|x-sx|,|y-sy|)},\frac{|y-sy|}{\gcd(|x-sx|,|y-sy|)})$ 在右下没有出现过，则将答案 $+1$；

- 循环 $x$ 从 $1$ 至 $sx$，$y$ 从 $sy+1$ 至 $m$，如果 $(x,y)$ 有骷髅且 $(\frac{|x-sx|}{\gcd(|x-sx|,|y-sy|)},\frac{|y-sy|}{\gcd(|x-sx|,|y-sy|)})$ 在左上没有出现过，则将答案 $+1$；

- 循环 $x$ 从 $sx+1$ 至 $n$，$y$ 从 $sy+1$ 至 $m$，如果 $(x,y)$ 有骷髅且 $(\frac{|x-sx|}{\gcd(|x-sx|,|y-sy|)},\frac{|y-sy|}{\gcd(|x-sx|,|y-sy|)})$ 在右上没有出现过，则将答案 $+1$。

## Code
```cpp
#include<bits/stdc++.h>
#define pd push_back
#define pb pop_back
#define mk make_pair
//#define int long long
#define PII pair<int,int>
#define _for(a,b,c) for(int a=b;a<=c;a++)
#define _rep(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
template <typename T> inline void read(T& x) {
	x=0; T f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch&15); ch=getchar(); }
	x=x*f;
	return;
}
template <typename T,typename ...Arg> inline void read(T& x,Arg& ...arg){
	read(x); read(arg...);
}
int power(int a,int b) { 
	int ans=1;
	do {
		if(b&1) ans*=a; a*=a;
	} while(b>>=1);
	return ans;
}
const int N=1e3+5;
char mp[N][N];
int used[N][N],n,m,sx,sy,ans;
void Solve(int si,int ei,int sj,int ej) {
	memset(used,0,sizeof(used));
    //printf("(%d,%d)-(%d,%d)\n",si,sj,ei,ej);
	_for(i,si,ei)
		_for(j,sj,ej)
			if(mp[i][j]=='K') {
                //printf("(%d,%d) is K\n",i,j);
				int a=abs(i-sx),b=abs(j-sy);
				int d=__gcd(a,b);
				a/=d; b/=d;
                //printf("proportion of dist is (%d,%d)\n",a,b);
				if(!used[a][b])
					++ans,used[a][b]=1;
			}
}
signed main() {
	read(n,m);
	_for(i,1,n)
		_for(j,1,m) {
			cin>>mp[i][j]; if(mp[i][j]=='S') sx=i,sy=j;
		}
	Solve(1,sx,1,sy);
	Solve(sx+1,n,1,sy);
	Solve(1,sx,sy+1,m);
	Solve(sx+1,n,sy+1,m);
	printf("%d",ans);
	return 0;
}
```
但是，如果将这份代码交上去，你将会发现 $\text{Subtask 4}$ 出现了奇怪的 ``RE``，这是为什么呢？

可以发现，最后一处数据范围只保证 $n\times m\le10^6$，而没有保证 $n,m\le10^3$，也就是说可能会出现 $n=10^6,m=1$ 这种畸形数据！

这时我们需要运用上一点哈希的手段：对于 $x\le n,y\le m$，则唯一确定 $(x-1)\times m+y$ 且小于 $n\times m$。值得注意一点，运用这种哈希手段可能会导致  $(x-1)$ 出现负数，所以我们需要将其映射为 $xm+y$。

## code:
```cpp
#include<bits/stdc++.h>
#define pd push_back
#define pb pop_back
#define mk make_pair
//#define int long long
#define PII pair<int,int>
#define _for(a,b,c) for(int a=b;a<=c;a++)
#define _rep(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
template <typename T> inline void read(T& x) {
	x=0; T f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch&15); ch=getchar(); }
	x=x*f;
	return;
}
template <typename T,typename ...Arg> inline void read(T& x,Arg& ...arg){
	read(x); read(arg...);
}
int power(int a,int b) { 
	int ans=1;
	do {
		if(b&1) ans*=a; a*=a;
	} while(b>>=1);
	return ans;
}
const int N=2e6+5;
char mp[N];
int used[N],n,m,sx,sy,ans;
void Solve(int si,int ei,int sj,int ej) {
	memset(used,0,sizeof(used));
    //printf("(%d,%d)-(%d,%d)\n",si,sj,ei,ej);
	_for(i,si,ei)
		_for(j,sj,ej)
			if(mp[i*m+j]=='K') {
                //printf("(%d,%d) is K\n",i,j);
				int a=abs(i-sx),b=abs(j-sy);
				int d=__gcd(a,b);
				a/=d; b/=d;
                //printf("proportion of dist is (%d,%d)=%d\n",a,b,a*m+b);
				if(!used[a*m+b])
					++ans,used[a*m+b]=1;
			}
    //printf("Ans=%d\n",ans);
}
signed main() {
	read(n,m);
	_for(i,1,n)
		_for(j,1,m) {
			cin>>mp[i*m+j]; if(mp[i*m+j]=='S') sx=i,sy=j;
		}
	Solve(1,sx,1,sy);
	Solve(sx+1,n,1,sy);
	Solve(1,sx,sy+1,m);
	Solve(sx+1,n,sy+1,m);
	printf("%d",ans);
	return 1;
}
```

另：建议此题评黄。

---

## 作者：LKY928261 (赞：3)

## 题目分析

题目可理解为：从 `S` 所在的点分别向每个 `K` 所在点各发出一条射线，求不重合的射线条数。

由于射线的端点相同，当且仅当两条射线在同一方向且斜率相等时，才会重合。所以，只需枚举方向，每次将射线斜率求出并去重，即可枚举计算射线条数。时间复杂度及空间复杂度均为 $O(nm)$ 。

在统计时，为了防止将相反的两条射线算作同一条，需要**按方向来分别枚举**（也可理解为将 `S` 作为原点建立直角坐标系，按象限分别枚举）。

多条射线可能有斜率相同的情况，需要通过约分去重。然后以整数对的方式表示分数并统计，具体地：对于**斜率的绝对值**为 $\frac{q}{p}$ 的射线（$p,q$ 均为正整数且互质），我们可以将其统计在数组 $f_{p,q}$ 中，方便统计。

上下左右四个方向较特殊，最好单独统计！

## 参考代码

本人的代码非常精简，欢迎借(chao)鉴(xi)。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,x,y,s,i,j;
ll p(ll x,ll y){ll z=x%y;while(z)x=y,y=z,z=x%y;return y;}
//辗转相除求gcd
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	char a[n+5][m+5];bool b[n+5][m+5];
	//由于题目数据范围较阴间，所以采用局部变量定义数组
	for(i=1;i<=n;i++)for(j=1;j<=m;j++){cin>>a[i][j];if(a[i][j]=='S')x=i,y=j;}
	//读入+预处理
	for(i=1;i<x;i++)if(a[i][y]=='K'){s++;break;}
	for(i=n;i>x;i--)if(a[i][y]=='K'){s++;break;}
	for(i=1;i<y;i++)if(a[x][i]=='K'){s++;break;}
	for(i=m;i>y;i--)if(a[x][i]=='K'){s++;break;}
	//上下左右
	memset(b,0,sizeof(b));
	for(i=1;i<x;i++)for(j=1;j<y;j++)if(a[i][j]=='K')b[abs(x-i)/p(abs(x-i),abs(y-j))][abs(y-j)/p(abs(x-i),abs(y-j))]=1;
	for(i=1;i<=n;i++)for(j=1;j<=m;j++)s+=b[i][j];
	//左上
	memset(b,0,sizeof(b));
	for(i=1;i<x;i++)for(j=m;j>y;j--)if(a[i][j]=='K')b[abs(x-i)/p(abs(x-i),abs(y-j))][abs(y-j)/p(abs(x-i),abs(y-j))]=1;
	for(i=1;i<=n;i++)for(j=1;j<=m;j++)s+=b[i][j];
	//右上
	memset(b,0,sizeof(b));
	for(i=n;i>x;i--)for(j=1;j<y;j++)if(a[i][j]=='K')b[abs(x-i)/p(abs(x-i),abs(y-j))][abs(y-j)/p(abs(x-i),abs(y-j))]=1;
	for(i=1;i<=n;i++)for(j=1;j<=m;j++)s+=b[i][j];
	//左下
	memset(b,0,sizeof(b));
	for(i=n;i>x;i--)for(j=m;j>y;j--)if(a[i][j]=='K')b[abs(x-i)/p(abs(x-i),abs(y-j))][abs(y-j)/p(abs(x-i),abs(y-j))]=1;
	for(i=1;i<=n;i++)for(j=1;j<=m;j++)s+=b[i][j];
	//右下
	cout<<s<<"\n";
}
```

---

## 作者：Java_Herobrine (赞：2)

# 分析问题
将输入的字符数组抽象成一个一个的点，其中K代表该点有骷髅（后面将骷髅所在的点视为 $K$点）， $S$ 代表该点有神箭游侠（后面将神箭游侠所在的点视为 $S$ 点），箭是从神箭游侠射出的，且会向着一个方向飞，轨迹是直的。于此，神箭游侠射出去的箭可以视为端点为 $S$ 的射线。如果骷髅被射中了，说明 $K$ 点在射线上。如此，最少射的箭的数量，就是过 $S$ 点引射线，使射线经过全部的 $K$ 点，一共需要引的射线的条数。
# 探究方法
初中数学老师告诉我们，两点可以确定一条直线，而根据射线的定义，给定一个端点和任意一个点，可以构造一条射线。所以，要求射线的数量，我们可以以 $S$ 点为端点，和所有的K点构造射线，并求出不重合的射线的数量（注意：一条射线绕着它的端点旋转180°得到的新射线和原来的射线不重合）。而如何确定一条射线呢？初中的数学老师还告诉我们，一次函数 $y=kx+b(k≠0)$ 的图象是一条直线，垂直于x轴的直线可以写作 $x=p$ （p是垂足的横坐标），垂直于y轴的直线可以写作 $y=p$ （p是垂足的纵坐标），并且射线是直线的一部分。射线是直线的一部分，而一次函数的图象是直线，这说明什么？这说明射线可以用限制了定义域的一次函数来表示。我们知道，如果函数 $f(x)$ 和函数 $g(x)$ 解析式一样，那么在定义域一样的情况下 $f(x)$ 和 $g(x)$ 的图象也一样。由此可见，两条射线的是否重合可以简化成两条射线所在直线的解析式是否一致，并且函数的定义域是否一致。

两点确定一条直线，要求一次函数的解析式我们需要代入两个点，设这两个点分别是$ P(x_1,y_1) $ 和 $Q(x_2,y_2)$ ，将这两个点代入一次函数的解析式可以得到 $\begin{cases}y_1=x_1k+b\\y_2=x_2k+b\\\end{cases}$ ，解出来$\begin{cases}k=\dfrac{y_1-y_2}{x_1-x_2}\\b=y_1-x_1k\\\end{cases}$ ，这是我们后面解题的基础。
# 解决问题
我们来分析一下题目，要解决射线是否重合的问题，我们能想到的就是表示射线的方法，把函数的解析式和定义域都表示到一个字符串里面，而要排除重复的元素，我们自然而然地想到键值对的键是不能重复的，而我们只是简单的利用键不能重复，对值可谓是漠不关心，为了提高效率，我们选择使用
```cpp 
std::unordered_map
```
来解决重复的问题，所以我们的代码是：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    unordered_map<string,string> map;
    vector<pair<int,int>> kPos;
    int m,n;
    int sX=-1,sY=-1;
    char c;
    cin>>n>>m;
    //解析几何的基础是平面直角坐标系
    //在获取点的坐标之前，我们要先定义平面直角坐标系
    //我们选择以读到的第一个字符为原点，右方和下方分别为x轴y轴正方向，一个字符为单位长度定义坐标系
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
           cin>>c;
           if(c=='K'){
               kPos.push_back({j,i});//放入K点的坐标
           }else if(c=='S'){
               sX=j;
               sY=i;//放入S点的坐标
           }
           //我们不关心没有骷髅和神箭游侠的点，这里的字符'.'可以不处理
        }
    }
    for(auto& p:kPos){
        if(p.first==sX){//判断射线是否垂直于x轴，如果垂直x轴则无需求一次函数解析式
            if(p.second>sY){//判断方向是向上还是向下
                map.insert({"x >",""});//用x和>表示垂直x轴方向向上
            }else{
                map.insert({"x <",""});
            }
        }else if(p.second==sY){//同上
            if(p.first>sX){
                map.insert({"y >",""});    
            }else{
                map.insert({"y <",""});
            }
        }else{//如果不垂直于x轴也不垂直于y轴，则计算一次函数的解析式
            double k=((double)(p.second-sY))/(p.first-sX);
            double b=sY-k*sX;
            string s;
            if(sX>p.first){//判断K是否在S右边（通过判断这个来确定定义域）
                s=to_string(k)+" "+to_string(b)+">";//用k和b表示一个一次函数，>的意思是定义域为x>xS
            }else{
                s=to_string(k)+" "+to_string(b)+"<";//同上
            }
            map.insert({s,""});
        }
    }
    cout<<map.size();
    return 0;
}
```
# 总结经验
所谓计算机，最擅长的事情就是进行计算。一些算法题可以将题目所要表达的意思抽象成数学模型，然后用数学方法求解，接着用编程语言书写你用的数学方法，最后做一些优化防止TLE或者MLE就好了

---

## 作者：Y2y7m (赞：2)

### 一道分类讨论 $ + $ 一次函数的好题

我们根据游侠的位置建立坐标系，以游侠的位置作为原点。

把所有小骷髅的位置与游侠连在一起，形成一条条直线。

你会发现，有不少的小骷髅会被同一条直线击杀。

所以我们要数一数总共有多少条不同的直线。

我们需要把这些直线的斜率算出来（知道这条直线上两点：小骷髅和游侠，用他们两个的位置求斜率）。

注意：一条直线会被游侠分成两段，这两段不属于同一类。

还有一个问题：如何存我们的函数。

**存一下斜率即可。**

**但是斜率是分数啊？！**

map是个好东西。

具体细节看代码。

```cpp
#include <bits/stdc++.h>

using namespace std;
string s[1000010];
int x,y;
struct node
{
	double x,y;
}kl[1000010];
int c;
map<double,int> mp[6];
double b[1000010];
int cnt;
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>s[i];
	for(int i=1;i<=n;i++)
		for(int j=m;j>=1;j--)
			s[i][j]=s[i][j-1];
	for(int i=1;i<=n;i++)//为了方便，我把这个字符串的第一个字符的下表改成了1
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='S') x=i,y=j;
			if(s[i][j]=='K') kl[++c].x=i,kl[c].y=j;
		}
	}

	for(int i=1;i<=c;i++)
	{
		
		double tx=kl[i].x,ty=kl[i].y;
		if(tx>x&&ty>y)
		{
			double cx,cy;
			cx=tx-x,cy=ty-y;
			double t=1.0*cy/cx;
			if(!mp[0][t])//这个种情况下的斜率没有出现过，数量加一
				cnt++;
			mp[0][t]=1;
		}
		if(tx>x&&ty<y)
		{
			double cx,cy;
			cx=tx-x,cy=y-ty;
			double t=1.0*cy/cx;
			if(!mp[1][t])
				cnt++;
			mp[1][t]=1;
		}
		if(tx<x&&ty>y)
		{
			double cx,cy;
			cx=x-tx,cy=ty-y;
			double t=1.0*cy/cx;
			if(!mp[2][t])
				cnt++;
			mp[2][t]=1;
		}
		if(tx<x&&ty<y)
		{
			double cx,cy;
			cx=x-tx,cy=y-ty;
			double t=1.0*cy/cx;
			if(!mp[3][t])
				cnt++;
			mp[3][t]=1;
		}
		if(tx==x)
		{
			if(ty>y)
			{
				if(!mp[4][1])
					cnt++;				
				mp[4][1]=1;
			}
			if(ty<y)
			{
				if(!mp[4][2])
					cnt++;	
				mp[4][2]=1;
			}
		}
		if(ty==y)
		{
			if(tx>x)
			{
				if(!mp[5][1])
					cnt++;
				mp[5][1]=1;
			}
			if(tx<x)
			{
				if(!mp[5][2])
					cnt++;
				mp[5][2]=1;
			}
		}
	}
	cout<<cnt<<endl;
	return 0;
}

```

---

## 作者：__K2FeO4 (赞：2)

和 potter 一样，我也是第一次发题解。

我自己写了一遍，发现思路和他的题解类似，都是把斜率算出并约分、去重。代码也比较像，但绝对不是抄的。

我有两点与他不同：

1. 我将在坐标轴上的骷髅进行了特判，而他没有，他是用了 __gcd。（他一开始也是手写 gcd，但是 RE 了，就是因为坐标轴上的点会导致**除数为零**！）

2. 我是 sort 一遍再进行计数，而他使用了桶。我认为他的更好一些，我的也能过（在答案很大的时候，用我这种，否则就用他那种）。

为了防抄袭，下面是我第一次的代码，**在 gcd 里面改一个地方**就能成为正解。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> P;
const int N=1e6+5;
string str;
P a[N];
int gcd(int x,int y){
	return y?x:gcd(y,x%y);//这里错了，应该是 y?gcd(y,x%y):x;
}
int main(){
	int n,m,i,j,x,y,cnt=0;
	cin>>n>>m;
	for(i=0;i<n;i++){
		cin>>str;//根本不需要用二维数组
		for(j=0;j<m;j++){
			if(str[j]=='S')
			x=i,y=j;//神箭游侠的坐标
			if(str[j]=='K'){
				P k;
				k.first=i;
				k.second=j;
				a[++cnt]=k;//骷髅的坐标
			}
		}
	}
	for(i=1;i<=cnt;i++){
		a[i].first-=x;
		a[i].second-=y;
		if(a[i].first==0)//特判来了
		a[i].second=a[i].second>=0?1:-1;
		else if(a[i].second==0)
		a[i].first=a[i].first>=0?1:-1;
		else{
			int b=abs(a[i].first);
			int c=abs(a[i].second);
			int d=gcd(b,c);
			a[i].first/=d;
			a[i].second/=d;//约分
		}
		
	}
	sort(a+1,a+cnt+1);//这个复杂度有点高
	int s=0;
	P k=make_pair(1e9,1e9);
	for(i=1;i<=cnt;i++){
		if(k!=a[i]){
			s++;
			k=a[i];
		}
	}
	cout<<s<<endl;
	return 0;//收场
}
```

附：[I_Love_Potter](https://www.luogu.com.cn/blog/Harry0731/solution-p8247) 的题解，仅做对比，没有抄袭！

---

## 作者：哈士奇憨憨 (赞：2)

## 思路
我们将神箭游侠和每一个骷髅的位置记录下来，建立起以神箭游侠为原点的平面直角坐标系，则每一个骷髅都在这个坐标系上，且这些点都在整数上。我们设这些点为 $(x_1,y_1),\ (x_2,y_2),\dots,(x_n,y_n)$。

因为神箭游侠射出的为直线，所以神剑游侠射了 $(x_i,y_i)$ 则必定射到了 $(\dfrac{x_i}{\gcd(x_i,y_i)},\dfrac{y_i}{\gcd(x_i,y_i)})$。所以我们求出每个骷髅位置除以它们坐标的 $\gcd$，然后排序，看有多少个不同的数即可。
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, p, q, l, ans = 1, gcd;
char o;
struct A{
    int x, y;
}a[1000001];
bool cmp(A x, A y){
    if(x.x == y.x){
        return x.y < y.y;
    }
    return x.x < y.x;
}
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            cin >> o;
            if(o == 'K'){
               a[++l].x = i, a[l].y = j;
            }else if(o == 'S'){
                p = i, q = j;
            }
        }
    }
    for(int i = 1; i <= l; i++){
        a[i].x -= p, a[i].y -= q;//骷髅的坐标
        gcd = __gcd(abs(a[i].x), abs(a[i].y));
        a[i].x /= gcd, a[i].y /= gcd;//求 x_i/gcd(x_i,y_i) 和 y_i/gcd(x_i,y_i)
    }
    sort(a + 1, a + l + 1, cmp);
    for(int i = 1; i < l; i++){
        if(a[i].x != a[i + 1].x || a[i].y != a[i + 1].y){
            ans++;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：rai1gun (赞：2)

### 1.题目思路

读题后我们可以发现，如果想要一箭射中 $x$ 个敌人，那么就必须要有 $x$ 个敌人的斜率 $k$ 相等。

具体可以看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/orkyu53g.png)

由于 $(1,2)$ 和 $(2,4)$ 斜率均为 $2$ 所以在一条直线上，$(4,2)$ 的斜率是 $\dfrac{1}{2}$，所以单独成线。

由于斜率的公式是 $k=\dfrac{y_2-y_1}{x_2-x_1}$，所以，游侠射到了 $(x_i,y_i)$，也就必然会射到 $(\dfrac{x_i}{\gcd(x_i,y_i)},\dfrac{y_i}{\gcd(x_i,y_i)})$。

两者均可通过计算斜率 $k$ 来证明在一条直线上。

最后，我们只需要将每个点除以它们的 $\gcd$，然后排序去重，就可以得到答案。

### 2.题目代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 0x7f7f7f7f
#define map unorded_map
#define re register
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define Mod 998244353
#define F1(i,a,b,k) for(re int i=a;i<=b;i+=k)
#define F2(i,a,b,k) for(re int i=a;i>=b;i-=k)
// 省略快读
template<typename T> inline T abs(T x){return x<0?-x:x;}
using namespace Fast_Io;
const int N = 1e6+5;
struct S{int x,y;}a[N];
int n,m,ax,ay,v,cnt=0,ans=1;
char op;
inline bool cmp(S x,S y){
	if(x.x==y.x) return x.y<y.y;
	return x.x<y.x;
}
int main(){
	read(n,m);
	F1(i,1,n,1){
		F1(j,1,m,1){
			cin>>op;
			if(op=='K'){
				cnt++;
				a[cnt].x=i;
				a[cnt].y=j;
			}else if(op=='S'){
				ax=i,ay=j;	
			}
		}
	}
	F1(i,1,cnt,1){
		a[i].x-=ax,a[i].y-=ay;
		int gcd=__gcd(abs(a[i].x),abs(a[i].y));
		a[i].x/=gcd,a[i].y/=gcd;
	}
	sort(a+1,a+1+cnt,cmp);
	F1(i,2,cnt,1){
		if(a[i].x!=a[i-1].x || a[i].y!=a[i-1].y) ans++;
	}
	print(ans);
	return 0;
}
```
完结撒花！

---

## 作者：ajhuhe (赞：1)

# 题目简述

在一个 $n\times m$ 的矩阵上，有若干骷髅和 $1$ 个神箭游侠。现在要求以神箭游侠坐标为端点，穿过至少 $1$ 个骷髅的射线最少有几条。

# 题目分析

这道题采用**模拟**的算法。由于骷髅在一条射线上，我们把在同一条射线上的两个骷髅的坐标 $(x1,y1)$ 与 $(x2,y2)$ 比较发现，$\dfrac{x1}{y1} = \dfrac{x2}{y2}$，即两者比值相同。反过来，比值相同的两个坐标上的骷髅一定在一条射线上。于是，先将坐标减去神箭游侠的坐标再比较骷髅的两个坐标的比值，就可以得出骷髅是否在一条射线上了。由于一条射线上可能会有很多骷髅，所以将每个骷髅上述操作后再用桶思想去重就是射线条数了。


# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ax,ay,sum;
//bool bs[1001][1001];<-错误示范(qwq)
map<pair<int,int>,bool>p; 
struct node
{
	int i;
	int j;
	node(int x,int y)
	{
		i=x;
		j=y;
	}
};
queue<node> q;
int main()
{
	cin>>n>>m;
	for(int i1=1;i1<=n;i1++)
	{
		for(int j1=1;j1<=m;j1++)
		{
			char ch;
			cin>>ch;
			if(ch=='K')//记录骷髅坐标 
				q.push(node(i1,j1));
			if(ch=='S')//记录神箭游侠坐标 
			{
				ax=i1;
				ay=j1;
			}
		}
	}
	while(!q.empty())//桶思想去重 
	{
        int xx=q.front().i,xy=q.front().j;
        q.pop();
		xx-=ax;
		xy-=ay;
        int gg=abs(__gcd(xx,xy));
        xx/=gg;
		xy/=gg;
		if(!p[make_pair(xx,xy)])
			sum++;
        p[make_pair(xx,xy)]=true;//桶，就是这里不建议大家使用数组 
    }
	cout<<sum;//AC
	return 0;
}
```

---

## 作者：_Sushi (赞：0)

题目链接：[P8247](https://www.luogu.com.cn/problem/P8247)

题意：给定平面上一个端点和其他若干个点，从这个端点引出若干条射线使得其他点全部被覆盖，求最小的射线条数。

分析：首先先思考一下两条射线在怎么样的情况下才会重合。考虑把端点看做原点，相邻两点之间的长度为 $1$，那么这些点就可以表示在一张平面直角坐标系上。每一条从原点出发到某个点的射线都可以表示为这个点的横坐标和纵坐标，要判断两条射线是否重合，只要把他们的横、纵坐标进行约分，判断是否相同即可。

解决了这个问题，这道题就非常简单了。可以使用 ```STL``` 中的 ```map```
容器，储存下每一条射线。对于每个点，如果这个点到原点的射线已经有了，那么跳过这个点，否则存下这条射线，并把答案加一。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y;
map<pair<int,int>,int> Map;     //map容器，不会用的请右转https://blog.csdn.net/wangxu696200/article/details/123067711
int a[3000000],b[3000000],l;
char c;
int ans;
int gcd(int a,int b)    //求最大公约数
{
	if(b==0) return a;
	return gcd(b,a%b);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++)
    	{
    		cin>>c;
    		if(c=='S') x=i,y=j;
    		if(c=='K') l++,a[l]=i,b[l]=j;    //储存下每个点的位置
		}
	for(int i=1;i<=l;i++)
	{
		int p=a[i]-x,q=b[i]-y;
		int g=gcd(p,q);
		if(g<0) g=-g;      //这里有一个细节，如果约分把符号约掉了，就会误判成对面的那条射线
		p/=g,q/=g;      //约分
		if(!Map[make_pair(p,q)])
		{
         Map[make_pair(p,q)]=1;   //将这条射线存入map
         ans++;     //答案加一
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Firstly (赞：0)

## **题目思路：**

我们可以用每只骷髅相对于神射手的方位来表示骷髅的位置。由于计算斜率不仅可能会损失精度，而且在一定的情况下会不准确，所以我们用两个数来表示骷髅与神射手的相对位置。

为了表示有些骷髅在同一线上，我们将骷髅的横坐标和纵坐标形成的比化简，再封装在一起。再用容器去重，最后输出容器内的数量即可。


## **Code：**

```cpp
#include<iostream>
#include<map>
#include<algorithm>
#include<utility>
#include<queue>
using namespace std;
map<pair<int,int>,bool>mp;
int m,n,x,y;
char ch;
queue<pair<int,int> >q;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>ch;
            if(ch=='K')q.push(make_pair(i,j));
            if(ch=='S')x=i,y=j;
        }
    while(!q.empty()){
        int xx=q.front().first,yy=q.front().second;
        q.pop();xx-=x,yy-=y;
        int gcdd=abs(__gcd(xx,yy));
        xx/=gcdd,yy/=gcdd;
        mp[make_pair(xx,yy)]=true;
    }cout<<mp.size();
    return 0;
}
```


---


# 简单数列

## 题目描述

给你一个数 $n$，你需要求出一个长度为 $n$ 的数组 $a$，（下标从 $1$ 开始，且元素都为 $1,2,3$ 或 $4$），使得：

* 对于第 $i$ 个数，对于所有的 $1 \le len \le \lfloor\frac{i}{2}\rfloor$, $a_{i-len+1\dots i}$ 与 $a_{i-len\times2+1\dots i-len}$ 不相同。（$\lfloor x \rfloor$ 表示对 $x$ 下取整）

* 说人话，就是没有任何连续的连续子串相同。

## 说明/提示

对于 $20\%$ 的数据，满足 $1 \le n \le 10$；

对于 $40\%$ 的数据，满足 $1 \le n \le 30$；

对于 $100\%$ 的数据，满足 $1 \le n \le 500$。

## 样例 #1

### 输入

```
3```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
6```

### 输出

```
1 2 3 4 1 3```

# 题解

## 作者：cff_0102 (赞：14)

## P8248 简单数列 题解

这道题，很多人都觉得 $500$ 个数，这得试到猴年马月才能过啊，还是直接枚举/搜索吧。

诶，但我就打表过了，而且没有靠程序枚举输出。

### 题意补充

这个题意即使这么简便，还是有人看不懂。所以我补充一下。

- 数列里面只能有 $1,2,3,4$ 这 $4$ 个数。所以 `1 2 3 4 5 6 7` 是不允许的。
- 类似 `1 2 3 1 2 3`，`1 2 3 4 1 3 1 2 3 4 1 3`，`1 1` 这些情况都不能出现，而 `1 2 3 4 1 2 3` 就能出现，即没有任何相邻的的子串相同。

### 思路

打表。首先构造一组比较可以的数列，至少能拿 $20$ 分。这个时候把整个数列复制几遍，先把这个初始的数列称为一段。每段之间加上几个数字，使得数字总数超过 $500$，并且如果把一段看做 `5` 的话，这个数列要满足没有任何相邻的的子串相同。

接着，自己写SPJ或者直接交上来查看哪里有误，接着进行微调。微调也要有技巧，[我调了半个多小时才 `AC`。](https://www.bilibili.com/video/BV1GL411A7AS/)

### 代码

这里提供 `C++` 和 `Python` 代码。

`C++`：

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[500]={1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,1,2,3,4,1,3,1,4,3,4,2,3,4,1,3,1,2,3,4,3,1,2,3,1,4,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,1,2,3,4,1,3,1,4,1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,1,4,1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,4,3,4,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,3,2,1,2,3,4,1,3,1,2,3,4,2,3}//呜呜呜累死了
int main(){
	ios::sync_with_stdio(false);
	int a;cin>>a;//输入
	for(int i=0;i<a;i++){
		cout<<s[i]<<" ";//这个数组满足所有的，因为输入500是可以的，所以更小的数字也行
	}
	return 0;
}
```


`Python`：

```python
#这段代码如果自动识别语言会识别成Pascal
a=int(input())
s=[1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,1,2,3,4,1,3,1,4,3,4,2,3,4,1,3,1,2,3,4,3,1,2,3,1,4,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,1,2,3,4,1,3,1,4,1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,1,4,1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,3,2,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,4,3,4,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,1,2,3,4,3,1,2,3,1,3,2,3,4,3,1,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,2,1,2,3,4,1,3,4,2,3,4,1,3,1,2,3,4,2,4,1,2,3,4,1,3,1,2,3,4,3,2,1,2,3,4,1,3,1,2,3,4,2,3#这里真的很难调
for i in range(a):
    print(s[i],end=" ")
```

求过0ω0

---

## 作者：小明小红 (赞：4)

正文开始
这道题其实对于本蒟蒻来说并不简单，本人的思路不像某位 dalao 那样打表，毕竟是要填 500 个呀，我用的是深搜，先说思路：

本代码需要用三个模块：主函数、 check 函数和 dfs 函数，主函数没问题，是输入， dfs 函数就是深搜函数，就是不断枚举 1 到 4 ，可以继续搜，不行回溯，还要加停止条件。

## dfs code
```c
void dfs(ll x)//dfs(x)表示现在搜索第x个数 
{
	
	if(flag==1)//当前是否有答案了，如果有则停止 
		return ;
	if(x==n+1)
	{
		for(ll i=1;i<=n;i++)
		{
			cout<<ans[i]<<' ';//函数内输出，不然会被回溯掉 
		}
		flag=1;//标记当前已经存在答案 
		return ;
	}
	for(ll i=1;i<=4;i++)
	{
		if(flag==1)//当前是否有答案了，如果有则停止 
			return ;
		ans[x]=i;//赋值 
		if(check(x)==true)
		{
			dfs(x+1);
		}
		ans[x]=0;//回溯，养成好习惯 
	}
}
```
 check 函数是看当前选的数是否能与前数列组成新数列（根据题意，双重循环+ if ），外层枚举是否相同的数列长度，内层枚举数列中的位置。

## check code

```c
bool check(ll x)
{
	for(ll i=1;i*2<=x;i++)//参考题解 
	{
		k=0;//k表示是否不相等 
		for(ll j=1;j<=i;j++)//参考题解 
		{
			if(ans[x-j+1]!=ans[x-i-j+1])//参考题意 
				k=1;
		}
		if(k==0)//如果都相等（没赋值）过，则return false 
			return false;
	 } 
	return true;//所有情况都通过则表示这个能组成新的数列 
} 
```


# code

```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long //本蒟蒻又懒又笨 
ll n,ans[509],flag=0,k;
bool check(ll x)
{
	for(ll i=1;i*2<=x;i++)//参考题解 
	{
		k=0;//k表示是否不相等 
		for(ll j=1;j<=i;j++)//参考题解 
		{
			if(ans[x-j+1]!=ans[x-i-j+1])//参考题意 
				k=1;
		}
		if(k==0)//如果都相等（没赋值）过，则return false 
			return false;
	 } 
	return true;//所有情况都通过则表示这个能组成新的数列 
} 
void dfs(ll x)//dfs(x)表示现在搜索第x个数 
{
	
	if(flag==1)//当前是否有答案了，如果有则停止 
		return ;
	if(x==n+1)
	{
		for(ll i=1;i<=n;i++)
		{
			cout<<ans[i]<<' ';//函数内输出，不然会被回溯掉 
		}
		flag=1;//标记当前已经存在答案 
		return ;
	}
	for(ll i=1;i<=4;i++)
	{
		if(flag==1)//当前是否有答案了，如果有则停止 
			return ;
		ans[x]=i;//赋值 
		if(check(x)==true)
		{
			dfs(x+1);
		}
		ans[x]=0;//回溯，养成好习惯 
	}
}
int main()
{
	cin>>n;
	dfs(1);
	return 0;
}
```

## 无注释   code

```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
ll n,ans[509],flag=0,k;
bool check(ll x)
{
	for(ll i=1;i*2<=x;i++)
	{
		k=0;
		for(ll j=1;j<=i;j++)
		{
			
			if(ans[x-j+1]!=ans[x-i-j+1])
				k=1;
		}
		if(k==0)
			return false;
	 } 
		
	return true;
} 
void dfs(ll x)
{
	
	if(flag==1)
		return ;
	if(x==501)
	{
		for(ll i=1;i<=n;i++)
		{
			cout<<ans[i]<<' ';
		}
		flag=1;
		return ;
	}
	for(ll i=1;i<=4;i++)
	{
		if(flag==1)
			return ;
		ans[x]=i;
		if(check(x)==true)
		{
			dfs(x+1);
		}
		ans[x]=0;
	}
}
int main()
{
	cin>>n;
	dfs(1);
	return 0;
}
```
~~求过~~

---

## 作者：_zyx (赞：3)

一道简单的构造题

为了方便起见，我们用字符串处理本道题，substr 函数在代码中有注释说明。

只需要每次从 $1$ 到 $4$ 中取一个数，判断一下是否合法即可，具体怎么判断，在题面中已经给出 ~~（题面真良心）~~，意思大概是说，当前字符串处理到第 $i$ 位时，枚举它的子串长度 $len$，如果当前第 $i$ 位向前取长度为 $len$ 的子串与第 $i-len$ 位向前取长度为 $len$ 的子串相同，那么就不合法。

值得提醒的是，如果每处理 $1$ 位都从 $1$ 到 $4$ 依次尝试，那么没过多久就会无数可填（卡了我好长时间 QAQ），所以我们增加一个计数器 $x$，使它尽量填完 $1$ 到 $4$ 一个循环再尝试下一个循环。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;

const int N=1e4+10;
int n;
string s;
bool check(char ch){
	string ss=s+ch;
	int k=ss.size()-1;//当前字符串处理到的位置 
	for(int len=1;len<=k/2;len++){
		if(ss.substr(k-len+1,len) == ss.substr(k-len*2+1,len)) return false;
		/*substr函数表示在字符串ss中第k-len+1个位置向后取长度为len的子串（包括k-len+1本身）*/
	}
	return true;
}
int main(){
	scanf("%d",&n);
	s+='0';//字符串的第0位舍去方便处理 
	int x=1;
	for(int i=1;i<=n;i++){
		while(1){
			char ch=x+'0';
			if(check(ch)){
				s+=ch;
				x++;
				if(x == 5) x=1;
				break;
			}
			x++;
			if(x == 5) x=1;
		}
	}
	for(int i=1;i<=n;i++) printf("%d ",s[i]-'0');
	return 0;
}



```


---

## 作者：Composite_Function (赞：2)

注:吐槽一下，这题怎么才 普及- ，怎么也应该是 普及/提高- ，~~（有可能是我太菜了）~~。

------------

# 一、思路
注意数据： $1 ≤ n ≤ 500$

不妨可以想一想，为什么数据那么小呢

然后我们瞬间明白它的用意，这道题就是使用~~暴力的~~ dfs 搜索每一个位置有可能是哪个数。定义一个储存内容的全局数组，每次将数修改一下，然后继续往下搜索。如果直接传数组，可能空间和时间可能都不够用。

在加上剪枝——要是有答案就立即停止。注意：对每一个搜索的子状态节点都要测试满不满足条件，否则肯定过不了。

~~实际上这题能打表但我不会~~

------------

# 二、AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 510
int n,ans[N];
bool flag;
bool check(int x){
    //检测该数组是否满足要求
    for(int i=1;2*i<=x;i++){
        bool cal=false;
        for(int j=1;j<=i;j++)
            if(ans[x-j+1]!=ans[x-i-j+1]) cal=true;
        if(cal==false) return false;
        //如果 cal 从来没有赋过值就意味着全部相同
    }
    return true;
    //如果从来没返回值就意味着该数组满足要求
}
void dfs(int pos){
    if(flag==true) return ;
    //已经检测到就不要再搜了
    if(pos==n+1){
        for(int i=1;i<=n;i++)
            cout<<ans[i]<<" ";
        //记得要在函数内输出，否则会被回溯
        flag=true;
        return ;
    }
    for(int i=1;i<=4;i++){
        ans[pos]=i;
        if(check(pos)) dfs(pos+1);
        ans[pos]=0;
    }
}
int main(){
    cin>>n;
    dfs(1);
    return 0;
}
```
**请不要抄代码哦**

---

## 作者：newbeeglass (赞：1)

可能是道构造题，看了眼数据范围，发现可以直接枚举。然后这个大问题就被拆成了两个小问题，一是枚举数列，二是判断数列是否合法。

先讲判断：

判断其实很简单，只需要从前往后枚举所有的子串，然后看这个子串后面紧跟着的与之等长的子串是否与它相同就好了（前面的子串会在之前就判断过，不需要重复判断）。
```cpp
bool check(int x){
	for(int i=1;i<=x;i++){
		for(int j=i;j<=n;j++){//枚举所有子串 
			bool flag=0;
			for(int k=j+1;k<=j+(j-i+1);k++){//判断是否有连续子串相同 
				if(a[k]!=a[i+k-j-1]){//发现不同直接break，别浪费时间 
					flag=1;
					break;
				}
			}
			if(!flag){
				return 0;//发现相同子串，则不符合题意 
			}
		}
	}
	return 1;
}
```
再来讲枚举：

刚开始我想直接用 ```for``` 循环枚举，找到一个合法的数字就加进数列，然后下一个循环，结果不行，因为我当前的操作有后效性，我的操作很有可能会导致之后的数列无数字可选，造成无解，所以想到深搜。

在搜索函数中枚举所有的数加进数列，如果当前数列不合法直接 ```return```，如果合法就继续搜，搜到长度为 $n$ 时停下，如果合法，就输出，然后用 ```exit(0)``` 退出整个程序（这样比较方便）。这样一来，发现无数字可选的情况时就可以回溯到上一步进行改正。
### 正常代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],n,t;
bool check(int x){
	for(int i=1;i<=x;i++){
		for(int j=i;j<=n;j++){//罗列所有子串 
			bool flag=0;
			for(int k=j+1;k<=j+(j-i+1);k++){//判断是否有连续子串相同 
				if(a[k]!=a[i+k-j-1]){//发现不同直接break，别浪费时间 
					flag=1;
					break;
				}
			}
			if(!flag){
				return 0;//发现相同子串，则不符合题意 
			}
		}
	}
	return 1;
}
void search(int x){//暴搜 
	if(x==n){//x=n时直接输出，然后强退 
		a[x]=1;
		if(check(x)){
			for(int i=1;i<=x;i++){
				cout<<a[i]<<" ";
			}
			exit(0);
		}
		a[x]=2;
		if(check(x)){
			for(int i=1;i<=x;i++){
				cout<<a[i]<<" ";
			}
			exit(0);
		}
		a[x]=3;
		if(check(x)){
			for(int i=1;i<=x;i++){
				cout<<a[i]<<" ";
			}
			exit(0);
		}
		a[x]=4;
		if(check(x)){
			for(int i=1;i<=x;i++){
				cout<<a[i]<<" ";
			}
			exit(0);
		}
		return;
	}//每种情况必须枚举，因为前面的选择会影响后面的结果，下同 
	else{
		a[x]=1;
		if(check(x)){
			search(x+1);
		}
		a[x]=2;
		if(check(x)){
			search(x+1);
		}
		a[x]=3;
		if(check(x)){
			search(x+1);
		}
		a[x]=4;
		if(check(x)){
			search(x+1);
		}
	}
}
int main(){
	cin>>n;
	search(1);//简单的主函数 
	return 0;//强迫症 
}

```
时间复杂度很高，如果范围再大一点，可以修改一下这个代码，把输出的空格改成逗号，加一个 ```freopen``` ，将其改造成一个打表生成代码，输入一个比较大的 $n$，造出一张表（$1000$ 以内只需 $5$ 秒），表中的前 $n$ 项就是我们要找的数列。
### 打表代码（可以解决 $n\le1000$ 的所有数据）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001]={0,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,3,1,2,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,1,3,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,3,1,2,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,2,1,3,1,2,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,3,1,2,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,3,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,2,1,2,3,1,2,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,2,1,2,3,1,2,1,3,1,2,3,1,3,2,1,2,3,1,2,1,3,1,2,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,4,1,2,1,4,1,3,1,2,1};
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";
	}
	return 0;
}

```


---

## 作者：__shadow__ (赞：1)

首先，圈重点：

1. $1\le n \le 500$
2. 所有元素在 $1\sim4$ 之间
3. 任意连续的连续子串不相同
4. 只要输出一种答案即可

于是我们可以得到的是：
+ 由第一点和第二点可以看出此题可以写搜索解决。
+ 由第三点我们可以得到一种剪枝方式，就是如果目前数字放入后会产生相同的连续的连续子串。
+ 由第四点我们可以发现结束搜索的条件，同时节约时间。

搜索方法：
1. 如果已输出一种，一直返回至主函数（也可以在输出后直接 ```exit(0)```）。
2. 如果当前要填的位置是 $n + 1$，说明已经填好了 $n$ 个数字且无连续的连续子串相同，此时输出并且标记。
3. 循环在当前位置填入 $1\sim4$，判断填入后是否有连续的连续子串相同，如果没有，则进入 ```dfs(step + 1)```。

分析结束，上代码
```cpp
#include<cstdio>
using namespace std;
const int N = 500 + 5;
int n, a[N];//a用来存当前的串 
bool flag;//用来标记是否找到合法答案 
bool check(int x)//用来判断a[1~x]是否合法 
{
	for(int i = 1;i * 2 <= x; i++)//因为有两个串对比，i枚举的是子串长度 
	{
		bool flag = 0;
		for(int j = 1;j <= i; j++)//j枚举对第几个数字 
			if(a[x - j + 1] != a[x - i - j + 1])//如果有1个不同的就标1 
			{
				flag = 1;
				break; 
			} 
		if(!flag)//如果全部相同返回0 
			return 0;
	}
	return 1;
}
void dfs(int step)
{
	if(flag)//如果已输出答案，返回 
		return ;
	if(step == n + 1)//如果n个数都已经放入，则输出答案并标1 
	{
		for(int i = 1;i <= n; i++)
			printf ("%d ", a[i]);
		flag = 1;
		return ;
	}
	for(int i = 1;i <= 4; i++)//枚举该位填的数字 
	{
		a[step] = i;
		if (check(step))//填入后判断填此数字后是否合法 
			dfs(step + 1);
		a[step] = 0;//回溯 
	}
	return ;
}
int main()
{
	scanf ("%d", &n);
	dfs(1);
	return 0;
}
```
#### 完结撒花

如有错误欢迎私信指出

---

## 作者：lsj2009 (赞：1)

## 题目大意
<https://www.luogu.com.cn/problem/P8248>。
## 思路
按题意直接构造即可：每次扩展时循环 $1,2,3,4$，判断是否可以添加（循环 $len$ 从 $1$ 到 $\lfloor\frac{i}{2}\rfloor$，判断每个 $a_{i-len+1...i}$ 和 $a_{i-len\times 2+1...i-len}$ 是否相同，如有相同，则回溯至上一步）。
## Code
```cpp
#include<bits/stdc++.h>
#define pd push_back
#define pb pop_back
#define mk make_pair
//#define int long long
#define PII pair<int,int>
#define _for(a,b,c) for(int a=b;a<=c;a++)
#define _rep(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
template <typename T> inline void read(T& x) {
	x=0; T f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch&15); ch=getchar(); }
	x=x*f;
	return;
}
template <typename T,typename ...Arg> inline void read(T& x,Arg& ...arg){
	read(x); read(arg...);
}
int power(int a,int b) {
	int ans=1;
	do {
		if(b&1) ans*=a; a*=a;
	} while(b>>=1);
	return ans;
}
const int N=505;
int n,v[N],tot;
bool used[4];
bool check(int l1,int r1,int l2,int r2) { //判断 a[l1~r1] 是否于 a[l2~r2] 相同
	int k=0;
	while(l1+k<=r1&&l2+k<=r2) {
		if(v[l1+k]!=v[l2+k])
			return false;
		++k;
	}
	return true;
}
signed main() {
	read(n);
	while(tot<n) {
		printf("v.size=%d\n",tot);
		_for(i,1,4) { //循环扩展元素
			if(tot==n) break;
			printf("i=%d\n",i);
			v[++tot]=i;
			bool flag=0; //flag=0 表示可以拓展，flag=1 表示不可以拓展
			_for(len,1,tot/2) //循环每个 len
				flag|=check(tot-len+1,tot,tot-len*2+1,tot-len);
			if(flag) {
				--tot; printf("pop\n");
			}
		}
	}
	_for(i,1,tot)
		printf("%d ",v[i]);
	return 0;
}
```

---


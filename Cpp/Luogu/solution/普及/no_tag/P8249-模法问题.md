# 模法问题

## 题目背景

简单题，无背景。

## 题目描述

你有两个正整数 $a,b$。

你还有一个正整数 $q$，你要执行 $q$ 次询问。

对于每一次询问，你得到两个正整数 $l,r$。

你需要求出求 $\max\{(i \bmod a)+(i \bmod b) \}$，其中 $i$ 是正整数且 $i \in [l,r] $。

## 说明/提示

对于 $30\%$ 的数据，满足 $1\le q\le10^3$，$1 \le l \le r \le 10^3$；

对于 $70\%$ 的数据，满足 $1\le q\le10^3$，$1 \le l \le r \le 10^9$；

对于 $100\%$ 的数据，满足 $1\le a,b\le 10^3$，$1\le q\le10^5$，$1 \le l \le r \le 10^9$。

## 样例 #1

### 输入

```
5 7
4
1 5
5 7
33 34
34 35```

### 输出

```
8
7
10
10```

# 题解

## 作者：jgvccc (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P8249)

显然，这道题不能用暴力做，因为仅仅计算单个的问题，就会达到 $10^9$ 的复杂度。

这个时候就需要考虑其他方法了。

***

因为这道题求的是余数的和，所以 __最理想__ 的情况答案应为 $(a-1)+(b-1)$ （如下图所示）。但是这种情况的出现当且仅当 $(a,b]$ 区间内存在 $a,b$ 的公倍数的时候。

![最简单的情况](https://cdn.luogu.com.cn/upload/image_hosting/pf4omydj.png)

我们可以新建一个变量 $t$ 存储 $a$ 与 $b$ 的最小公倍数，然后对于每个询问，存储 $l \div t$ 和 $r \div t$ 的值。如果这两个值不相等，则可判断为上文中提及的情况，条件如下。

```
if(l \ t != r \ t)
```

***

不过，当 $l \div t = r \div t$ 时，这种方法就不奏效了，因为区间几乎不可能出现我们所期望的值了（如下图）。

![说明](https://cdn.luogu.com.cn/upload/image_hosting/3gz55h3g.png)

~~因为本蒟蒻不会倍增算法，所以~~ 我们可以另辟蹊径。通过观察可以发现，在单独对一个数取余的两个序列中，会出现余数为 $0$ 的情况。而 $0$ 前面的数字则是这一行可能出现的最大数字。反过来推，可以得到： __如果一个数字的右边是0，那么它一定是该行最大的。如果不是0，那么它一定不是该行最大的。__

![0左边的数字是该行最大的](https://cdn.luogu.com.cn/upload/image_hosting/q3kkqyiz.png)

所以如果有一列的数右边都不是 $0$ ，那么可以直接排除这一列。所以我们 __只需要扫一遍所有0左边的结果即可__ ，这就大大减少了计算量，省去了很多时间复杂度。这还没完，千万不要忘记最右边的数也有可能是最大值，所以 __最后一个数r也要扫__ 。

![被排除的列](https://cdn.luogu.com.cn/upload/image_hosting/jdezymip.png)

***

总结一下：
如果区间内存在最理想情况，直接输出。如果不存在，扫描一遍所有的 $0$ 左边的结果和 $r$ 。

***

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int a,b,q,l,r,t,minn,maxn,ans;
int gcd(int a,int b)//最大公约数
{
    if(a % b == 0) return b;
    else return gcd(b,a % b);
}

int calc(int x)//计算结果
{
    return x % a + x % b;
}

signed main()
{
    std::ios::sync_with_stdio(false);
    cin>>a>>b;
    t = gcd(a,b);
    t = a * b / t;
    cin>>q;
    for(int i=0;i<q;i++)
    {
        cin>>l>>r;
        minn = l / t;
        maxn = r / t;
        ans = 0;
        if(minn != maxn) cout<<calc(maxn*t-1)<<endl;//最理想情况
        else
        {
            ans = calc(r);//千万别忘了扫这个位置
            for(int i = r/a*a-1;i>=l;i-=a) ans = max(ans,calc(i));//扫一遍除以第一个数余0的位置的左边并取最大值
            for(int i = r/b*b-1;i>=l;i-=b) ans = max(ans,calc(i));//扫一遍除以第二个数余0的位置的左边并取最大值
            cout<<ans<<endl;
        }
    }
    return 0;
}
```

---

## 作者：xwh_hh (赞：4)

[P8249](https://www.luogu.com.cn/problem/P8249) 题解：  
**注：在本文中，除法一律向下取整**  
这里介绍一种时间复杂度 $O(q(a+b))$ 的解法：  
如果 $l\div(a \times b) \neq r \div (a \times b)$，那么 $[l,r]$ 中必然存在一个数 $i$，满足 $i\,\bmod\,a=a-1$ 且 $i\,\bmod\,b=b-1$，输出 $a+b-2$ 即可。  
证明：  
令 $u=l\div(a\times b)$，则 $l\leq a\times b \times (u+1)-1 \leq r$，$a\times b \times (u+1)-1$ 即为所求。  

若上面的条件不成立，$r-l+1\leq a\times b$，我们思考一个问题，什么样的数 $u$ 可能成为答案呢？  
1. $u=r$ 时
2. $u\,\bmod a=a-1$ 时
2. $u\,\bmod b=b-1$ 时

下证：对于不满足以上任意一条的数 $v$ ，不可能成为答案。  
$l \leq v+1 \leq r$，  
$(v+1)\,\bmod\,a>v\,\bmod\,a$，  
$(v+1)\,\bmod\,b>v\,\bmod\,b$，  
$(v+1)\,\bmod\,a+(v+1)\,\bmod\,b>v\,\bmod\,a+v\,\bmod\,b$
选 $v+1$ 比选 $v$ 好，证毕！  

枚举满足上面条件的数即可。  
由于区间长度不超过 $a\times b$，满足条件的数不超过 $a+b+1$ 个，时间复杂度 $O(q(a+b))$。
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int q,l,r,a,b;
int main(){
	scanf("%d%d%d",&a,&b,&q);
	while(q--){
		scanf("%d%d",&l,&r);
		if(l/(a*b)!=r/(a*b)) printf("%d\n",a+b-2);//快速判断是否存在最理想的情况 
		else{
			int i,ans=r%a+r%b;//处理1.
			for(i=l-l%a+a-1;i<=r;i+=a)//处理2.
				ans=max(ans,a-1+i%b);
			for(i=l-l%b+b-1;i<=r;i+=b)//处理3.
				ans=max(ans,b-1+i%a);
			printf("%d\n",ans);
		}
	}
 	return 0;
}
```

---

## 作者：sgl654321 (赞：4)

### 题目大意
给定两个数 $a$，$b$，再给定 $q$ 个询问。每个询问输入两个整数 $l$ 和 $r$，满足 $l\leq r$，求所有的 $i\in[l,r]$，$(i\bmod a)+(i\bmod b)$ 的最大值。
### 解题思路
$30$ 分做法：顺着题目大意暴力模拟，遍历 $l$ 到 $r$ 之间的所有数，最终求出最大值。

$70$ 分做法：对于取模的问题，通常都有一种循环节做法。我们观察后容易发现，$(i\bmod a)+(i\bmod b)$ 的值与 $((i+a\times b)\bmod a)+((i+a\times b)\bmod b)$ 的值是相等的。所以 $a\times b$ 就是一个循环节。

然后每次询问就不用暴力遍历 $[l,r]$ 了，如果 $r-l\geq a\times b$，那么直接遍历 $[1,a\times b]$，求出最大值即可。时间复杂度 $O(q\times a\times b)$。
不过数据强度好大，这种做法不加优化大概只能拿 $50$ 分~~我太蒻了~~。

**满分做法**：

根据刚才我们 $70$ 分做法的分析，容易想到:

其一，如果 $r-l+1\geq a\times b$，证明覆盖超过了一个循环节，直接输出一个循环节内的最大值即可，这个是可以预处理出来的。所以就不加赘述了。

其二，如果 $r-l+1<a\times b$，那么这题本质上是多次求一个长度为 $a\times b$ 的序列（把这个序列为 $A$ 数组），某一区间的最大值。把 $l,r$ 分别向 $a\times b$ 取模，得到 $l1=l\bmod (a\times b)$，$r1=r\bmod (a\times b)$。考虑如何求出最大值？

$a\times b$ 最大能达到 $10^6$ 级别，如果每一次求最大值都用遍历的方式，那么肯定会超时。

思考：怎样预处理，能使每次求最大值所花费时间复杂度均为 $O(1)$?

这里我们将会使用一种方法：**倍增法（或 ST 表）**。

定义：数组 $f[i][j]$，表示从 $i$ 往后 $2^j$ 个数中，$A[k]$ 的最大值。即 $f[i][j]= max\{A_k\}$，其中 $k\in[i,i+2^j-1]$。因为本题是求余数，可能会有余 $0$ 的，所以数组下标就从 $0$ 开始好了。

- **先考虑如何预处理**：

**其一，对 $f$ 数组的预处理。**

首先，非常容易得到所有的 $f[i][0]=A[i]$。从 $1$ 开始遍历 $j$，再从 $0$ 开始遍历 $i$，保证 $i\in [0,a\times b-2^j+1)$，考虑如何转移 $f[i][j]$。

例如，要想知道 $f[3][3]$ 的值是多少，实际上就是求 $A_3\sim A_{10}$ 之间的最大值。我们可以把 $8$ 个数拆成两份（**分治思想**），分别是 $A_3\sim A_6$ 和 $A_7\sim A_{10}$。只要知道这两份的最大值，再 $\max$ 一下就可以了。

而 $A_3\sim A_6$ 的最大值，就是 $f[3][2]$。$A_7\sim A_{10}$ 的最大值，就是 $f[7][2]$。所以就有 $f[3][3]=\max(f[3][2],f[7][2])$。具体一点，$f[3][3]=\max(f[3][3-1],f[3+2^{3-1}][3-1])$。

一般地，就有 $f[i][j]=\max(f[i][j-1],f[i+2^{j-1}][j-1])(j\geq 1)$。使用这个公式即可。

**其二，对 $log$ 数组的预处理。**

大家都非常熟悉的式子：

如果 $a^x=n$，那么 $x=\log_an$。当 $a=2$ 时， $x=log_2n$。

显然，在大多数情况下，$x$ 都不会是一个整数。

而现在，我们要定义一个 $log$ 数组，里面存储的都要是整数。我们对 $log$ 数组定义如下：$log[i]=\lfloor\log_2i\rfloor$。为什么这样做，即这样做有什么好处，咱们下面再说。

那么 $log[i]$ 如何转移就非常明显了：如果你嫌麻烦，不想考虑精度误差（~~这当然是不好的啦~~），可以直接写。或者，你也可以写这个，跑一遍求出来。

$log[1]=0$，之后所有的 $i\geq 2$，都有 $log[i]=log[\lfloor{\dfrac{i}{2}}\rfloor]+1$。

关于这个数组的一个重要性质：$\log_2\dfrac{i}{2}<log[i]\leq \log_2i$。经过简单的变形可以得到： $\dfrac{i}{2}<2^{log[i]}\leq i$。具体过程留给读者。

- **再考虑预处理后，如何在 $O(1)$ 时间内求出最大值？** 批注：接下来讲的都是 $r1-l1<a\times b$  的情况如何处理，其余情况都直接输出一个区间的最大值即可。

要考虑两种情况。这个和直接的 ST 表有那么一点点小区别，直接 ST 表，一定保证要查询的 $l\leq r$，但是这一题，因为是取模运算，有可能会 $l1>r1$。所以就分两种情况 $l1\leq r1$ 与 $l1>r1$ 进行讨论。（讲完之后，你会发现其实本质上是一样的。）

**当 $l1\leq r1$ 时：**

例子 $1$：$l1=2,r1=9$。需要查询 $[A_2,A_9]$ 中的最大值。

我们掐指一算， $9-2+1=8=2^3$，查询的可以表示为 $[A_2,A_{2+2^3-1}]$ 中的最大值。这不就是 $f[2][3]$ 吗？所以直接输出 $f[2][3]$即可。

例子 $2$：$l1=4,l2=11$。

还是掐指一算，要求的是 $[A_4,A_{4+2^3-1}]$ 的最大值。直接输出 $f[4][3]$即可。

例子 $3$： $l1=2,r1=11$。需要查询 $[A_2,A_{11}]$ 中的最大值。

这回 $11-2+1=10$，不是 $2$ 的整数幂了。所以，刚刚的方法肯定不行。回顾刚刚我们推导 $f$ 数组的方法，我们再查询中，仍然可以使用**分治思想**。

既然求一个不好求，那就把你分成两个。对于这种情况，我们发现将例子 $1$ 与例子 $2$ 合起来，实际上就是 $[A_2,A_{11}]$。那么，只需要将两个答案 $\max$ 一下即可。所以，这一次输出的是 $\max(f[2][3],f[4][3])$。

例子 $4$：$l1=6,r1=25$。

这次我们将 $l1$ 与 $r1$ 一般化了。$25-6+1=20$ 仍然不是 $2$ 的整数次幂。回想刚才的分治方法，我们把一个区间变成了两个长度为 $2$ 的整数次幂的区间，而且要覆盖整个大区间，再进行 $\max$。

是不是想到刚才预处理的 $log$ 数组了？刚才我们得出了一个重要结论，那就是  $\dfrac{i}{2}<2^{log[i]}\leq i$。带入 $i=20$，$10<2^{log[20]}\leq 20$。因此，只要用两个长度为 $2^{log[20]}$ 的数组，就能够覆盖整个区间。

$log[20]=4$，$2^{log[20]}=16$。所以，可以把区间 $[A_6,A_{25}]$ 拆分成 $[A_6,A_{21}]$ 和 $[A_{10},A_{25}]$。因此，应该输出 $\max(f[6][4],f[10][4])$。

通过上面四个例子，我们进行总结，从特殊到一般，不难得出：

应当输出 $\max(f[l1][log[r1-l1+1]],f[r1-2^{log[r1-l1+1]}+1][log[r1-l1+1]])$。这个公式看起来很吓人，其实拆分开来看，也是很浅显的。这里就不多加解释了，~~毕竟刚刚举了 $4$ 个例子呢。~~

**当 $l1>r1$ 时：**

要求的实际上是“区间 $[A_{l1},A_{a\times b-1}]$ 的最大值”和“区间 $[A_0,A_{r1}]$ 的最大值”的最大值。
即输出 $\max\{\max\{A_i\},max\{A_j\}\}(i\in[l1,a\times b-1],j\in[0,r1])$。

例如 $l1=10,r1=5,a\times b=20$ 时，实际上只用输出 $\max\{\max\{A_i\},max\{A_j\}\}(i\in[10,19],j\in[0,5])$。

所以实际上就是两个情况 $1$ 再进行 $\max$。简单的计算之后，可以发现应当输出：$\max\{\max\{f[l1][log[a\times b-l1]],f[a\times b-2^{log[a\times b-l1]}][log[a\times b-l1]]\},max\{{f[0][log[r1+1]],f[r1-2^{log[r1+1]}+1][log[r1+1]]}\}\}$。建议把两个 $\max$ 分开看。实际上就是套公式。

至此，我们把所有的求值方法都讲解完毕了。

### 代码建议

~~自认为已经讲的非常详细了，~~ 所以我就不提供代码了。可以按照下面的每一句话，翻译成机器语言编写：

1. 输入 $a,b,q$。
2. 求出 $A$ 数组 $A_0\sim A_{a\times b-1}$ 的值。并求出该区间内的最大的 $A_i$，记作 $k$。
3. 预处理 $f$ 数组和 $log$ 数组。公式见上文。
4. 输入 $q$ 组 $l,r$。
5. 判断 $r-l$ 与 $a\times b$ 的大小关系。如果 $r-l\geq a\times b$，则直接输出 $k$。
6. 求出 $l1$ 和 $r1$。
7. 分两类情况 $l1\leq r1$ 和 $l1>r1$，套用公式并输出答案（记得换行）。

两个小提示：

1. $log$ 是一个函数，为了避免重复，建议使用 $lg$ 这个名字。
2. 出现 $2^n$ 运算，可以使用位运算 ``` 1<<n ``` 来代替。

全文完。谢谢审核大大审阅。

---

## 作者：Erotate (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8249)

**既然是区间查询，那肯定得线段树来解决呀！我们就好好地利用取模运算来压缩查询范围。**

首先，用线段树就得创建结构体：
```cpp
struct tree{
	int l,r,d;
}tr[2000005<<2];
```
- $l$: 表示区间的左端点
- $r$: 表示区间的右端点
- $d$: 表示 $\max{(i \mod a)+(i \mod b)}$，其中 $i$ 是正整数且 $i \in [l,r]$。

接下来就是模板的建树和查询了，只需要把求和改成求最大值即可：
```cpp
void build(int k,int l,int r){
	tr[k].l=l,tr[k].r=r;
	if(l==r){
		tr[k].d=l%a+l%b;
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	tr[k].d=max(tr[ls].d,tr[rs].d);
}
int query(int k,int l,int r){
	if(tr[k].l>=l && tr[k].r<=r) return tr[k].d;
	int mid=tr[k].l+tr[k].r>>1,ans=0;
	if(l<=mid) ans=max(ans,query(ls,l,r));
	if(r>mid) ans=max(ans,query(rs,l,r));
	return ans;
}
```
现在，重点来了，瞄一眼数据：$1≤l≤r≤10^9$，直接线段树查询肯定得爆空间。那么，我们这样压缩：

令
$$T=a\times b \times \gcd(a,b)$$
那么
$$(i\mod a)+(i\mod b)=((i\mod T) \mod a)+((i\mod T) \mod b)$$
[证明](https://www.luogu.com.cn/paste/20xjiqgg)

于是，我们这样压缩（这里 $l$ 和 $r$ 表示查询的区间）：
```cpp
if(r-l+1<T){
	if(r%T>=l%T) printf("%lld\n",query(1,l%T,r%T));
	else printf("%lld\n",query(1,l%T,l%T+r-l+1));
}else printf("%lld\n",query(1,0,T));
```
这里我们分两点讨论：

1. 当 $r-l+1<T$ 时，即区间不涵盖所有的数值（在 0 到 $T$ 之间），则当 $r\mod T>=l\mod T$ 时，就按照刚刚的讨论去查询；否则，我们就直接查询 $l\mod T+r-l+1$ 的这一段区间，反正有模运算，都一样（显然 $r\mod T=l\mod T+r-l+1$）。
2. 当 $r-l+1>T$ 时区间涵盖所有的数值，所以，直接查询 0 到 $T$ 之间的值即可。

剩下的代码大家自己补充吧！

---

## 作者：Vindictae (赞：2)

# 题目思路
这道题看起来很简单，其实一点也不复杂。

记 $\operatorname {lcm}(a,b)$ 为 $n$。

首先可以证明，如果 $l$ 到 $r$ 中有数模 $n$ 为 $n - 1$，此时的答案一定是最大的，为 $a + b - 2$。

其次，如果存在数对单个模数取模为模数 $-1$，那么最大答案一定在他们和 $r$ 之中产生。

# AC Code
```cpp
#include <math.h>
#include <cstring>
#include <iostream>
#include <algorithm>

#define endl '\n'
#define int long long
#define inf 0x3f3f3f3f
#define lnf 0x3f3f3f3f3f3f3f3f

using namespace std;

namespace WTH {
	int n;
	int a, b;
	int q;
	int l, r;
	int _Ans;
	
	void Main () {
		cin >> a >> b;
		n = lcm (a, b);
		cin >> q;
		
		while (q --) {
			cin >> l >> r;
			
			if (l <= (((l - 1) / n + 1) * n - 1) && (((l - 1) / n + 1) * n - 1) <= r) {
				cout << a + b - 2 << endl;
				continue ;
			}
			
			_Ans = r % a + r % b;
			
			for (register int i = (((l - 1) / a + 1) * a - 1); i <= r; i += a) {
				if (i >= l) {
					_Ans = max (_Ans, i % a + i % b);
				}
			}
			
			for (register int i = (((l - 1) / b + 1) * b - 1); i <= r; i += b) {
				if (i >= l) {
					_Ans = max (_Ans, i % a + i % b);
				}
			}
			
			cout << _Ans << endl;
		}
	}
}

signed main () {
	cin.tie (nullptr) -> ios :: sync_with_stdio (false);
	
	int T = 1;
	//cin >> T;
	
	while (T --) {
		WTH :: Main ();
	}
	
	return 0;
}
```

---

## 作者：Lawrenceling (赞：1)

## 题意
给出 $a$ 和 $b$，你需要求出求 $\max\{(i \bmod a)+(i \bmod b) \}$，其中 $i$ 是正整数且 $i \in [l,r] $。

## 思路
~~是谁说这题要用树状数组的啊~~

这道题确实不好想，但是如果知道求模类问题的套路，加上数据结构而不是一开始就往 $O(1)$ 性质什么的去想的话，还是好做的。

正解是 ST 表。很显然 $(i\bmod a)$ 和 $(i\bmod b)$ 在 $\textup{\textmd lcm}(a,b)$ 处就会循环。

接着，我们可以对 $[0,\textup{\textmd lcm}(a,b)-1]$ 这一个区间做 ST 表，初始化 ```st[i][0]=i%a+i%b```，等预处理完后就可以回答了。


---



对于第 $i$ 次询问的 $l$ 和 $r$，如果：
- $\textup{\textmd lcm}(a,b)\le r-l+1$
  
此时如图片所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/wshrd72w.png)
那么直接查询 ST 表中 $[0,\textup{\textmd lcm}(a,b)-1]$ 的最大值就好了。


---
如果：
- $\textup{\textmd lcm}(a,b)\ge r-l+1$

此时如图片所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/a924cjga.png)

因为 $l,r$ 太大，我们将它们分别取模 $\textup{\textmd lcm}(a,b)$，可以看到有两种情况：$l\le r$ 或 $r<l$。此时如图。

我们分类讨论，求出 $[l,r]$ 最大值（第一种）或 $[0,r]$ 最大值与 $[l,\textup{\textmd lcm}(a,b)-1]$ 最大值取最大（第二种）就可以了。

时间复杂度：$O(n \log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=3e6+10;
int a,b,q,st[N][30];

int Query(int l,int r)
{
	int g=log2(r-l+1);
	return max(st[l][g],st[r-(1<<g)+1][g]);
}

int main()
{
	scanf("%d%d%d",&a,&b,&q);
	int lcm=a*b/__gcd(a,b);
	for(int i=0;i<lcm;++i)
	{
		st[i][0]=i%a+i%b;
	}
	for(int i=1;i<=25;++i)
	{
		for(int j=0;j+(1<<i)-1<lcm;++j)
		{
			st[j][i]=max(st[j][i-1],st[j+(1<<i-1)][i-1]);
		}
	}
	while(q--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		if(r-l+1>=lcm)
		{
			printf("%d\n",Query(0,lcm-1));
		}
		else
		{
			l%=lcm,r%=lcm;
			if(l<=r)printf("%d\n",Query(l,r));
			else printf("%d\n",max(Query(l,lcm-1),Query(0,r)));
		}
	}
	return 0;
}
```
最后注意 ST 表大小要开到 $10^6$ 及以上，想想为什么？

---

## 作者：Reply_ (赞：0)

# P8249 模法问题题解

### 题意分析

观察到题目是 RMQ。~~似乎这是废话~~

### 解题思路

那么算法就是 st 表，由于 $1≤l≤r≤10^9$，考虑缩小问题范围，类似干支纪年法，可以把范围缩小到 $1$ 至 $a \times b$。

```cpp
for(int j = 1;(1<<j)<=n;j++){
		for(int i = 1;i<=n-(1<<j)+1;i++){
			f[i][j]=max(f[i][j-1],f[i+(1<<j-1)][j-1]);
		}
	}
```

### 细节

本题的细节更多的是查询阶段。

```cpp
for(R int i = 1;i<=q;i++){
		int l=read(),r=read();
		if(r-l+1>=n){
			//l,r之间包含了整个区间 
			printf("%d\n",rmq(1,n));
			//其实这里也可以提前处理最大值输出，但这样输出也不影响复杂度 
		}
		else{
			//先都取模n 
			l%=n,r%=n;
			//由于取模，l与r的大小无法确定，故分类 
			if(l>r) printf("%d\n",max(rmq(l,n),rmq(0,r)));//处理，两个部分取max 
			else printf("%d\n",rmq(l,r)); //直接取l到r的max 
		}
	}
```

---

## 作者：Lfz312g (赞：0)

# Solition
## 思路分析
查询区间最值，自然想到使用 ST 表，但是值域过大，需要优化。  
对于 $i \bmod a + i \bmod b$ 其循环节长度 $len = \operatorname{lcm}(a,b)$。    
查询时需要分类讨论。  
如果 $r-l +1 \ge n$，这时此区间覆盖整个循环节，输出 $[1,len]$ 的最大值。  
如果 $l \bmod len + 1 > r \bmod len +1 $，把区间拆分成 $[1,l]$ 和 $[r,len]$，取最大值即可。   
如果都不是，将 $[l,r]$ 映射到 $[l \bmod len +1,r \bmod len+1]$，然后查询。  

```cpp
#include <bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
int st[21][2000027],s[2000027],log_2[2000027],a,b,n;
void start() {
	ffor(i,1,n) st[0][i]=s[i];
	ffor(i,2,n) log_2[i]=log_2[i>>1]+1;
	for (int j=1;(1<<j)<=n;j++) for (int i=1;i<=n-(1<<j)+1;i++) st[j][i]=max(st[j-1][i],st[j-1][i+(1<<j-1)]);
}
int ask(int l,int r) {
	int k=log_2[r-l+1];
	return max(st[k][l],st[k][r-(1<<k)+1]);
}
int main()
{
	cin>>a>>b;
	n=a*b/__gcd(a,b);
	ffor(i,0,n-1) s[i+1]=(i%a+i%b); 
	start();
	int q;
	cin>>q;
	ffor(i,1,q) {
		int l,r;
		cin>>l>>r;
		if(r-l+1>=n) cout<<ask(1,n)<<'\n';
		else {
			l=l%n+1;
			r=r%n+1;
			if(l<=r) cout<<ask(l,r)<<'\n';
			else cout<<max(ask(1,r),ask(l,n))<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Frictional (赞：0)

这道题容易观察到一个性质，如果区间 $[l,r]$ 中包括 $k_1a-1$ 和 $k_2b-1$ 这样的数，那最大值一定出现在这种数里。而且，$(i \bmod a)+(i \bmod b)$ 的值是在长度为 $\operatorname{lcm}(a,b)$ 的区间中循环出现的。那我们就可以把 $l,r$ 同时缩小到比最小公倍数小的范围。

但我们会发现一个问题，像这样的 $l,r$ 处理时，可能会出现错误：![](https://s21.ax1x.com/2024/10/11/pAYCLwD.png)

但是不要紧，因为我们能看到，这类情况有一个共同的特点，那就是 $\lfloor\frac{r}{lcm}\rfloor$ 一定大于 $\lfloor\frac{l}{lcm}\rfloor$。换句话说这种询问区间一定包含 $\operatorname{lcm}-1$ 这个点，这说明什么呢，说明这个区间的最大值就是 $( \operatorname{lcm}-1)\bmod a+( \operatorname{lcm}-1)\bmod b$。

解决掉上面那种情况后，剩下的就是常规情况了，我们预处理出来所有 $i\in [0, \operatorname{lcm}-1]$ 的 $i\bmod a+i\bmod b$ 的值，对于每次查询用线段树或 st 表求区间最大值就可以了。

## Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define db double
#define U unsigned
#define P pair<int,int>
#define pb push_back
#define MP make_pair
#define all(x) x.begin(),x.end()
#define CLR(i,a) memset(i,a,sizeof(i))
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define ROF(i,a,b) for(int i=a;i>=b;--i)
#define debug(x) cerr<<#x<<'='<<x<<endl
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define pcn putchar('\n')
#define pcs putchar(' ');
#define pc putchar
#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define ClockB clock_t start,end; start = clock();
#define ClockE end = clock(); cerr<<"time = "<<double(end-start)/CLOCKS_PER_SEC<<"s"<<endl;
using namespace std;
int _=1;
inline int rd(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
inline void wr(int x){
    if(x<0) pc('-'),x=(~x)+1;
    if(x>9) wr(x/10);
    pc((x%10)^48);
}
int a,b;
int q;
int l,r;
int lc;
const int N=1e6+5;
int ans[N];
int st[N][20];
int lg[N];
int qmax(int l,int r){
    return MAX(st[l][lg[r-l+1]],st[r-(1<<lg[r-l+1])+1][lg[r-l+1]]);
}
signed main(){
    // _=rd();
    while(_--){
        a=rd(),b=rd();
        if(a<b) swap(a,b);
        q=rd();
        lc=a*b/__gcd(a,b);
        FOR(i,0,lc-1) ans[i]=(i%a)+(i%b);
        FOR(i,0,lc-1) st[i][0]=ans[i];
        FOR(i,2,N-2) lg[i]=lg[(i>>1)]+1;
        FOR(j,1,lg[lc-1])
            FOR(i,0,lc-(1<<j))
                st[i][j]=MAX(st[i][j-1],st[i+(1<<j-1)][j-1]);
        FOR(i,1,q){
            l=rd(),r=rd();
            if((r/lc)>(l/lc)) cout<<ans[lc-1]<<'\n';
            else{
                l%=lc,r%=lc;
                cout<<qmax(l,r)<<'\n';
            }
        }
    }
    return 0;
}
```

---

## 作者：cqbzhzf (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P8249)

### 思路分析
首先打了个 30 分暴力。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b,q,l,r,ans;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>a>>b>>q;
	while(q--)
	{
		ans=INT_MIN;
		cin>>l>>r;
		for(int i=l;i<=r;i++)
			ans=max(ans,i%a+i%b);
		cout<<ans<<"\n";
	}
	return 0;
}
```
$1 \le l \le r \le 10^9$。显然 $O(q(r-l))$ 的时间复杂度是不理想的。考虑把每次的**区间查询**优化为 $\log$ 级别的，很容易想到[线段树](https://blog.csdn.net/struct_GS/article/details/120716586?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172092874016800188532689%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172092874016800188532689&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-120716586-null-null.142^v100^pc_search_result_base5&utm_term=c%2B%2B%20%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187)，~~借鉴了 Erotate 的题解。~~

### 具体实现
1. 定义结构体表示线段树：

```cpp
const int N=1e6+5;
struct node
{
	int tl,tr,maxn;
}tree[N*4];
```
- $tl$ 表示区间左端点，$tr$ 表示区间右端点。
- $maxn$ 记录当前区间的 $\max(i \bmod a+i \bmod b)$。
- 开 $4$ 倍空间是因为线段树是一棵二叉树，前 $n-1$ 层是满二叉树，结点数为 $2 \times n-1$，那么加上最后一层一定，总结点数小于 $4 \times n-1$，故开 $4 \times N(n \le N)$。

2. 构造线段树：
```cpp
#define ls(i) ((i)*2)//左儿子
#define rs(i) ((i)*2+1)//右儿子
void build(int i,int l,int r)
{
	tree[i].tl=l,tree[i].tr=r;
	if(l==r)
	{
		tree[i].maxn=l%a+l%b;
		return;
  	}
  	int mid=(l+r)/2;
  	build(ls(i),l,mid);
  	build(rs(i),mid+1,r);
}
```

3. 区间查询函数：
```cpp
int query(int i,int l,int r)
{ 	
	if(tree[i].tl>=l&&tree[i].tr<=r)
    	return tree[i].maxn;
	int tmid=(tree[i].tl+tree[i].tr)/2;
	int ans=INT_MIN;
	if(l<=tmid)
		ans=max(ans,query(ls(i),l,r));
	if(r>tmid)
		ans=max(ans,query(rs(i),l,r));
	return ans;
}
```
- 但是 $1 \le l \le r \le 10^9$，还是会爆空间，于是考虑**优化查询的区间范围**，~~借鉴题解~~：

令 $m=a \times b \times \gcd(a,b)$，则有 $(i \bmod a)+(i \bmod b)=((i \bmod m)\bmod a)+((i \bmod m)\bmod b)$。

[证明](https://www.luogu.com.cn/paste/jcs8cku2)

随后把代码优化为：
```cpp
/*
主函数区间查询代码 
*/
if(r-l+1<m)
{
	if(r%m>=l%m) 
		cout<<query(1,l%m,r%m)<<"\n";
	else 
		cout<<query(1,l%m,l%m+r-l+1)<<"\n";
}
else 
	cout<<query(1,0,m)<<"\n";
```

---

## 作者：cloud2764scallop_eve (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8249)

## 思路

正在做数学且这痴迷于判断的我看见这道题的题目：**模**法游戏，肥肠激动，决定用我聪明的大脑考虑所有情况并用 `if` 求解。

and then：[to be continued](https://www.luogu.com.cn/record/140999162)~~~

#### code

当乐子看就行了。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll mod1, mod2, l, r, ans;
void check(int mod) {
	int t = r / mod;
	if ((l - r) >= mod) ans += mod - 1;
	else if (l < (t * mod)) ans += mod - 1;
	else ans += max(l % mod, r % mod);
}
int main() {
	int T;
	scanf("%lld%lld%d", &mod1, &mod2, &T);
	while (T--) {
		scanf("%lld%lld", &l, &r);
		ans = 0;
		check(mod1), check(mod2);
		printf("%lld\n", ans);
	}
	return 0;
}
```

惨痛的失败。我发现简单的判断解决不了这道题，决定思考一下~~看题解~~。

明显的，数据沒有水到用 `if` 就可以直接过的地步，所以考虑多进行几次判断。现在我们需要在循环判断最大值之前，考虑直接存在的最大值。  
学过小学奥数都知道，对于两个模数 $a$ 和 $b$，每连续的 $a \times b$ 个数中一定有可以同时整除这两个数的数。  
> 证明：很简单，直接枚举就可以

基于上面的结论，也可以得出每连续 $a \times b$ 个数中一定有 $i$ 可以满足 $i \bmod a = a - 1$ 且 $i \bmod b = b - 1$。此时直接输出 $a + b - 2$ 即可。

对于不满足上面情况的，考虑循环。

试问 $i$ 在什么时候是有意义的呢？答案是 $i \bmod a > (i - 1) \bmod a$ 时。同理，当 $i \bmod b > (i - 1) \bmod b$ 时，这个答案是有意义的。那么综合上述的结论，我们就可以设 `ans = r % a + r % b`。

如何设置循环中 $i$ 的初值呢？已知对于模数 $a$，对其取模的结果中最大的应为 $t \times a - 1(t \ge 1)$。在循环中，我们希望 $i$ 尽可能满足对 $a$ 取模时最大，所以可以设 `i = t * a + a - 1`。又因为 $i$ 应从 $l$ 开始，所以对于 $t$，将其定义为 `t = l / a`，就可以得到一个大于 $l$ 且与 $l$ 最接近且对 $a$ 取模答案最大的 $i$。

在取模的运算中，`i % a` 和 `(i + a) % a` 是等价的，所以可以将末尾循环体的修改记为 `i += a`，提升效率。

根据题意，答案需要满足同时对 $a$ 和 $b$ 取模最大，又已知 $i$ 已经是对 $a$ 取模中最大的数，所以在循环中只需要考虑对 $b$ 取模是否最大即可。

第二个循环想法同理。
> 关于为什么有第二个循环：  
我们不知道 $p \in [l, r]$ 中是否有数满足 $p = n \times a - 1$ 且 $p = m \times b - 1$，所以分别将以上两种 $p$ 作为循环中的 $i$，做两次求值。

具体实现见代码。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll a, b, l, r, ans;
void get_ans(ll x, ll y) {
	int t = l / x;
	for (int i = (t + 1) * x - 1; i <= r; i += x)
		ans = max(ans, x - 1 + i % y);
}
int main() {
	int T;
	scanf("%lld%lld%d", &a, &b, &T);
	while (T--) {
		scanf("%lld%lld", &l, &r);
		if (l / (a * b) != r / (a * b)) ans = a + b - 2; //l 和 r 之间有大于 a*b 个连续的数
		else {
			ans = r % a + r % b;
			get_ans(a, b), get_ans(b, a);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```
> `long long` 是没有必要的；  
理论最差的时间复杂度为 $O(q(a + b))$，约 $O(2 \times 10^8)$；  
暂时是最优解。

谢谢管理员 @[yummy](https://www.luogu.com.cn/user/101694) 的多次审核和指导，求通过！

---

## 作者：Jairon314 (赞：0)

> [题目链接](https://www.luogu.com.cn/problem/P8249)

$ \text{Solution} $

------------

观察数据范围 $1 \le l \le r \le 10^9$ 且 $1\le a \le b \le 10^3$.

考虑一下为什么 $a,b$ 这么小，容易想到 $a\times b \le 10^6$.

显然 $x\bmod {(a\times b)} \equiv x \pmod a$，且 $x\bmod {(a\times b)} \equiv x \pmod b$，证明略。

那么我们就可以把区间 $[l,r]$ 任意平移 $(a\times b)$ 的倍数，平移后的结果不变. 也就是说我们把区间端点值域降到了 $(a\times b)$， 在 $10^6$ 级别，目标是查询区间最值。

注意到 $\max\{ (x\bmod a) + (x\bmod b) \}$ 具有**可重复贡献性**，于是可以用 ``st表`` 算法做到 $O(ab \log ab)$ 预处理$[1,a\times b]$ 区间端点值域 $O(1)$ 查询区间最大值。

实现细节略。注意区间长度大于 $a\times b$ 时，上述流程无法做到区间端点值域变小，但是显然该区间覆盖 $i\in[1,a\times b]$ 中的所有对应值，所以直接找到全局最大值即可。

------------

[点击查看缺省源"Jairon.h"](https://www.luogu.com.cn/paste/bckqxxoh)

```cpp
#include <bits/stdc++.h>
using namespace std;

#define lint long long

#include <"Jairon.h">

#define maxn 1000010
#define SIZE 5010

int a,b;

struct ST_Grid{
	int Log2[maxn]={-1};
	int val[maxn][21];

	void init(){
		FOR(i,1,a*b){ val[i][0]=i%a+i%b; Log2[i]=Log2[i>>1]+1; }
		FOR(j,1,20){
			for(int i=1;i+(1<<j)-1<=a*b;i++){
				val[i][j]=max(val[i][j-1],val[i+(1<<(j-1))][j-1]);
			}
		} return;
	}

	int get_Mx(int l,int r){
		if(l>r){ return 0; }
		int k=Log2[r-l+1];
		return max(val[l][k],val[r-(1<<k)+1][k]);
	}
}st;

int main(){
	read(a,b);
	st.init();

	int q=read(_);
	while(q--){
		int l=read(_);
		int r=read(_);
		if(r-l+1>=a*b){ outn( st.get_Mx(1,a*b) ); continue; }
		l=l%(a*b),r=r%(a*b);
		if(l<=r){ outn( st.get_Mx(l,r) ); }
		else{ outn( max(st.get_Mx(l,a*b),st.get_Mx(1,r)) ); }
	}
	return 0;
}
 
/**/
```


---

## 作者：2021hych (赞：0)

# 直接看思路：
对于 $i \bmod a$，其循环节长度为 $a$。因此对于 $(i \bmod a) + (i \bmod b)$，其循环节长度为 $\operatorname{lcm}(a,b)$。那么我们可以把实际区间 $[l,r]$ 映射到一个较小的区间，区间最大值操作使用 $ST$ 表。

如此循环区间为 $[1,\operatorname{lcm}(a,b)]$，若 $r - l + 1 \geq \operatorname{lcm}(a,b)$，则答案为 $[1,\operatorname{lcm}(a,b)]$ 的最大值。否则将 $[l,r]$ 映射为 将 $[l \bmod \operatorname{lcm}(a,b) + 1,r \bmod \operatorname{lcm}(a,b) + 1]$，设其为 $[L,R]$，若 $L \leq R$，则答案为 $[L,R]$ 的最大值。否则，答案为 $[1,R]$ 的最大值与 $[L,\operatorname{lcm}(a,b)]$ 的最大值中的最大值。
# AC code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int a,b,q,l,r,n,h[N],f[N][21];
void ST_prework() {
	for(int i=1;i<=n;i++) f[i][0]=h[i];
	int t=log(n)/log(2)+1;
	for(int j=1;j<t;j++)
		for(int i=1;i<=n-(1<<j)+1;i++)
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
}
int ST_query(int l,int r) {
	int k=log(r-l+1)/log(2);
	return max(f[l][k],f[r-(1<<k)+1][k]);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>a>>b;
	n=a*b/__gcd(a,b);
	for(int i=0;i<n;i++) h[i+1]=i%a+i%b;
	ST_prework();
	cin>>q;
	while(q--) {
		cin>>l>>r;
		if(r-l+1>=n) cout<<ST_query(1,n)<<endl;
		else {
			l=l%n+1;
			r=r%n+1;
			if(l<=r) cout<<ST_query(l,r)<<endl;
			else cout<<max(ST_query(1,r),ST_query(l,n))<<endl;
		}
	}
	return 0;
}

```


---


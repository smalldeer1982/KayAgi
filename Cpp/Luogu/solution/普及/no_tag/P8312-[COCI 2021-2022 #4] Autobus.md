# [COCI 2021/2022 #4] Autobus

## 题目描述

在一个国家里有 $n$ 座城市。这些城市由 $m$ 条公交线路连接，其中第 $i$ 条线路从城市 $a_i$ 出发，到 $b_i$ 停止，路程中耗时 $t_i$ 分钟。

Ema 喜欢旅行，但她并不喜欢在公交线路之间换乘。在旅行过程中，她希望**最多**只需坐 $k$ 个不同的公交线路。

Ema 想知道，从城市 $c_i$ 到城市 $d_i$ 的最短旅行时间是多少（最多坐 $k$ 个不同的公交线路）。

## 说明/提示

**【样例解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/kxv8k07a.png)

每个样例中的答案都已经标记在图中。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（15 pts）：$k ≤ n ≤ 7$。
- Subtask 2（15 pts）：$k ≤ 3$。
- Subtask 3（25 pts）：$k ≤ n$。
- Subtask 4（15 pts）：没有额外限制。

对于 $100\%$ 的数据，$2\le n \le 70,1\le m,t_i\le 10^6,1\le a_i,b_i,c_j,d_j\le n,1\le k\le10^9,1\le q \le n^2$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T2  Autobus。** 

## 样例 #1

### 输入

```
4 7
1 2 1
1 4 10
2 3 1
2 4 5
3 2 2
3 4 1
4 3 2
1 3
1 4
4 2
3 3
```

### 输出

```
10
-1
0```

## 样例 #2

### 输入

```
4 7
1 2 1
1 4 10
2 3 1
2 4 5
3 2 2
3 4 1
4 3 2
2 3
1 4
4 2
3 3```

### 输出

```
6
4
0
```

## 样例 #3

### 输入

```
4 7
1 2 1
1 4 10
2 3 1
2 4 5
3 2 2
3 4 1
4 3 2
3 3
1 4
4 2
3 3```

### 输出

```
3
4
0
```

# 题解

## 作者：Lovely_Chtholly (赞：19)

本蒟蒻的第一篇题解，如有错误请大家悉心指出。

[个人博客食用效果更佳](https://www.luogu.com.cn/blog/Lovely-Chtholly/Solution-P8312)

[题目传送门](https://www.luogu.com.cn/problem/P8312)

### 【分析】

其实这道题就是给你一个有 $n$ 个点，$m$ 条边，$m$ 条路的有向图，再根据 $q$ 次询问输出从 $c_i$ 到 $d_i$ 的最短路长度。

[前置芝士](https://baike.baidu.com/item/Floyd%E7%AE%97%E6%B3%95?fromtitle=floyd&fromid=23665947&fromModule=lemma_search-box)

我们来看一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9qi05vhb.png)

经过分析，我们发现本题可以使用 Floyd，并且这题的数据范围是 $2\leqslant n\leqslant70$，众所周知，只要 $n$ 在 $200$ 以内都可以用 Floyd，所以我们就可以放心地去用 Floyd，但是题目里这样有一句话：

>最多坐 $k$ 个不同的公交线路。

所以我们必须用两个数组分别存储上次和当前的结果。并且我们发现计算出来的结果很大，这里就引用鲁迅的一句话，大家看着办吧：

>十年 OI 一场空，不开 long long 见祖宗。

### 【核心代码】

#### 优化

```cpp
k=min(k,n);//k的值过大，就要取k和n的最小值来提高效率
```

#### Floyd

```cpp
for(int p=2;p<=k;p++)//因为连边也算一次操作，所以Floyd只用循环k-1次
{
	for(int i=1;i<=n;i++)//复制上次结果
		for(int j=1;j<=n;j++)f[i][j]=dis[i][j];
	for(int l=1;l<=n;l++)//Floyd模板
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)f[i][j]=min(f[i][j],dis[i][l]+e[l][j]);
	for(int i=1;i<=n;i++)//更新答案
		for(int j=1;j<=n;j++)dis[i][j]=f[i][j];
}
```

#### 输出部分的特殊处理

```cpp
while(q--)
{
    int c=fread(),d=fread();
    if(c==d)puts("0");//起点就是终点
    else if(dis[c][d]==INF)puts("-1");//无法到达
    else printf("%d\n",dis[c][d]);
}
```

### [【完整代码】](https://www.luogu.com.cn/paste/g8hp9osm)

~~高尔基曾经说过：~~

>~~莫抄袭，棕了你的名，空悲切！~~

---

## 作者：Myth_ology (赞：14)

 看到上面大佬的广义矩阵快速幂，本蒟蒻瑟瑟发抖，~~毕竟我连橙名都没上过。~~

------------

## 题意简化

给你 $n$ 个点，$m$ 条边，$m$ 个连边情况，给定 $q$ 个询问，每次回答从点 $a$ 到点 $b$ 的最短路径长度。

由于 $n$ 范围太小，Floyd就可以过。但是由于题面里的特殊限制——最多坐 $k$ 个不同的公交线路，我们只能定义两个数组，一个存上次结果，另一个数组存本次结果。每次只连一条边，共连 $n$ 次。（结果太大，需要开 long long。）

伪代码如下


------------

```cpp
void Floyd() {//Floyd（一次只处理一条边） 
	k = Min(k, n);//由于k的值太大，且每个点最多跑一次，所以需要和 n 取一个 min
	for(int kk = 2;kk <= k;++ kk) {
		for(ri int i = 1;i <= n;++ i) {//将上一步操作结果迁移 
			for(ri int j = 1;j <= n;++ j){ 
				now[i][j] = last[i][j];
			} 
		} 
		for (ri int k = 1;k <= n;++ k) {
			for (ri int i = 1;i <= n;++ i) {
				for (ri int j = 1;j <= n;++ j) {
					now[i][j] = Min(now[i][j], last[i][k] + f[k][j]);
				}
			}
		} 			
		for (ri int i = 1;i <= n;++ i) {//每次更新答案 
			for (ri int j = 1;j <= n;++ j) {
			    last[i][j] = now[i][j];
			} 
		}	
	}
}
```


------------

由于起点和终点可能相同，输出时需要特判。

------------


```cpp
void print() {//输出 
	while(q --) {
		o = read();l = read();
		if(o == l) {//自己连着自己的情况
			printf("0\n");
		}
		else if(last[o][l] == 1e9) {//如果无法到达 
			printf("-1\n");
		}
		else {
			printf("%d\n", last[o][l]);
		}
	}
}
```


------------


## 后记

[完整代码](https://www.luogu.com.cn/paste/mr71tgzc)

[AC记录](https://www.luogu.com.cn/record/86369647)

---

## 作者：yeshubo_qwq (赞：10)

最短路，看到 $n$ 的范围只有 $70$，而且需要全源最短路，所以用 Floyd。

其他问题不大，主要问题在于**最多坐 $k$ 个不同的公交线路**这个限制比较麻烦。

解决方法：每次只做一条边，做 $k$ 次，用两个数组即可（$a$ 数组存上次结果，$b$ 数组存本次结果）。

注意几个坑点：

+ 初始数组无法到达的极大值不要赋太大，会炸 `int`。

+ $k$ 的范围高达 $10^9$，由于最多每个点到过一次，所以要和 $n$ 取最小。

+ 连边也算一次，Floyd 实际只做了 $k-1$ 次。

+ 起点和终点可能相同，要特判（直接对每个点到自己连一条为 0 的边也可以）。

代码：

```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
int n,m,i,x,y,z,q,k,j,e[80][80],a[80][80],b[80][80];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++)
			e[i][j]=1e9;//初始化 
	for (i=1;i<=m;i++)
		cin>>x>>y>>z,e[x][y]=min(e[x][y],z);
	cin>>x>>q;
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++)
			a[i][j]=e[i][j];//第一次就是连边 
	x=min(x,n); 
	for (y=2;y<=x;y++){
		for (i=1;i<=n;i++)
			for (j=1;j<=n;j++)
				b[i][j]=a[i][j];//在原基础上做 
		for (k=1;k<=n;k++)
			for (i=1;i<=n;i++)
				for (j=1;j<=n;j++)
					b[i][j]=min(b[i][j],a[i][k]+e[k][j]);
		for (i=1;i<=n;i++)
			for (j=1;j<=n;j++)
				a[i][j]=b[i][j];//更新结果 
	}
	while (q--){
		cin>>x>>y;
		if (x==y) cout<<"0\n";//自己到自己 
		else if (a[x][y]==1e9) cout<<"-1\n";//无法到达 
		else cout<<a[x][y]<<'\n';
	}
	return 0;
}
```


---

## 作者：LJN1117 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8312)

## 前言

 本来不是很想写题解的，但是考虑到快红了，所以想冲一把。


## 分析

有 $k$ 条边限制的**全源最短路**，范围 $2 ≤ n ≤ 70$ ,不难想到用 **floyd** 来求解，~~但好像 **bellman-ford** 也可做~~。

因为有 $k$ 条边限制吗，所以我们可以用两个数组维护此次结果和上一次的结果，然后直接套 **floyd** 的模板就好了。

 ## _code_
 
 ```cpp
#include<bits/stdc++.h>
#define int long long//记得加long long
#define maxn 100
#define inf 0x3f3f3f3f

using namespace std;

int n,m;
int k,q;
int g[maxn][maxn];
int a[maxn][maxn],b[maxn][maxn];

signed main(){
	scanf("%lld %lld",&n,&m);
    //初始化
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){
		if(i==j) g[i][j]=0;
		else g[i][j]=inf;
	}
	for(int i=1;i<=m;i++){
		int a,b,t;
		scanf("%lld %lld %lld",&a,&b,&t);
		g[a][b]=min(g[a][b],t);
	}
	scanf("%lld %lld",&k,&q);
	k=min(k,n);//优化，否则过不了
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) a[i][j]=g[i][j];
	//floyd模板
    for(int l=2;l<=k;l++){
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) b[i][j]=a[i][j];
		for(int s=1;s<=n;s++) for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) b[i][j]=min(b[i][j],a[i][s]+g[s][j]);
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) a[i][j]=b[i][j];
	}
	while(q--){
		int c,d;
		scanf("%lld %lld",&c,&d);
		if(a[c][d]==inf) printf("-1\n");
		else printf("%lld\n",a[c][d]);
	}
	return 0;
}

```

### ~~没有添加反作弊，可以放心抄~~

---

## 作者：pure__Elysia (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P8312)

[通过记录](https://www.luogu.com.cn/record/90429691)

# 题目描述

&emsp;&emsp;有一个有向图，含 $n$ 个点与 $m$ 条边（不保证无重边与自环），每条边有长度 $c$。建图后，给出一个数 $k$，表示询问时的最多边数。最后提出 $q$ 次询问，每次询问 $u$ 点到 $v$ 点，在最多只经过 $k$ 条边时，最短路长度为多少。

# 算法思路

&emsp;&emsp;正解？卡时间！最短路？那就跑一个最短路。怎么跑？ BFS 就可以跑。这里虽然数据水，但也要想剪枝。

&emsp;&emsp;如果处理到 $k-1$ 步了，该点却没有连向终点的边，那么就直接   `pop()`。另外，虽然我们因为每条路的长短不同，所以导致我们不能像“走迷宫”类型一样，找到终点就输出。但是我们可以这么想：如果我们新的尝试，他比现在的起点到这个点的最短路长，那我们就可以不去加入这个尝试。

&emsp;&emsp;诶？但是“最短”不一定是最优情况啊。但是我们的队列是依次进行的。队列后面的就一定比前面的用了（同样或者）更多的边数。所以这样的剪枝是正确的。

# 细节处理

&emsp;&emsp;这题 $n$ 还蛮小的，所以二位数组存图都不成问题。至于重边、自环，其实只记最短的就行了，其他边都用不到。

&emsp;&emsp;还有，我们 BFS 前其实最好判断一下是否 `u==v`。因为咱们把输入时的自环全部抛掉了，所以要写特判。当然你也可以多写一层，使得自己与自己长度为 0，可是这更不好写，而且还会因为边数增加导致 BFS 变慢，不是吗。

# 代码实现
```cpp
#pragma GCC optimize(2)//防抄又加速，岂不美哉
#include<bits/stdc++.h>
using namespace std;

#define int long long//看看数据范围，还是开着稳妥
#define ri register int//此时不卡场，何时卡场

inline int rd()//就是啊，给我卡常啊
{
	int a=0,f=1;
	char c=getchar();
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
	for(;c>='0'&&c<='9';c=getchar()) a=(a<<1)+(a<<3)+c-'0';
	return a*f;
}

inline void MIN(int &a,int b){if(a>b)a=b;}//比那个自带的快到哪里去了

int n,m,k,q,ans;
int dist[75][75];//存边

vector<int>edge[75];

struct zt{//队列状态
	int u,st,cost;//起点、边数、花费（距离）
};
queue<zt>que;

int scost[75];//以起点开始到一个点的最短路，用以维护

inline void bfs(int s,int t)
{
	memset(scost,127,sizeof(scost));//初始化最短路
	
	ans=1919810114514;//恶臭代码
	while(!que.empty()) que.pop();//其实不用，因为上一次肯定清空了
	
	zt l;
	l.cost=0,l.st=0,l.u=s;
	que.push(l);//压入起点
	while(!que.empty())
	{
		register zt to=que.front();
		que.pop();
		
		ri u=to.u,c=to.cost,st=to.st;
		if(st==k-1)//合理剪枝
		{
			if(dist[u][t]==0) continue;
			else MIN(ans,dist[u][t]+c);
		}
		else
		{
			int S=edge[u].size();
			for(ri i=0;i<S;i++)//枚举边
			{
				ri v=edge[u][i];
				if(v!=t)//没到终点，意味着压入下一个状态
				{
					if(dist[u][v]+c<scost[v])//要更优才压入
					{
						to.cost=dist[u][v]+c;
						to.u=v,to.st=st+1;
						que.push(to);	
						scost[v]=to.cost;//维护
					}
				}
				else MIN(ans,dist[u][t]+c);
                //如果到了终点，也就不用压入状态了
			}
		}
	}
	
	if(ans==1919810114514) ans=-1;//没找到
	return ;
}

signed main()
{
	n=rd(),m=rd();
	
	for(ri i=1;i<=m;i++)
	{
		ri u=rd(),v=rd(),c=rd();
		if(u==v) continue;//排除自环
		if(dist[u][v]!=0)//更新重边
		{
			if(dist[u][v]>c)
				dist[u][v]=c;
				
			continue;
		}
		else
			edge[u].push_back(v),dist[u][v]=c;
	}
	
	k=rd(),q=rd();
	
	while(q--)
	{
		ri s=rd(),t=rd();
		
		if(s==t) ans=0;//特判自环
		else bfs(s,t);
		
		printf("%lld\n",ans);
	}
	
	return 0;
	
}
```

---

## 作者：yuqihao (赞：2)

# P8312 [COCI2021-2022#4] Autobus 题解

Floyd ~~大水题~~

## 题意

有一个 $n$ 个点，$m$ 条边的有向图，有 $q$ 组询问，每组询问有两个变量 $s$ 和 $t$，求 $s$ 到 $t$ 最多经过 $k$ 条边的最短路。

## 思路

这道题的题目特征非常明显，首先 $2\le n \le 70$，而且还有多组询问，很容易就让我们想到 Floyd，但是最多只能经过 $k$ 条边的条件很烦。

所以我们就可以定义两个数组 $a[i][j]$ 和 $b[i][j]$ 表示这一轮和上一轮的答案，跑 $k$ 次，**每次只转移一条边**。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std; 
long long n,m,k,q,s,t,f[100][100],a[100][100],b[100][100];
int main(){
    scanf("%lld%lld",&n,&m);
    //初始化
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=INT_MAX;
   		}
    }
	for(int i=1;i<=m;i++){
		long long x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		f[x][y]=min(f[x][y],z);//多条重边取最短的一条 
	}	
	scanf("%lld%lld",&k,&q);
    //初始化a
	for (int i=1;i<=n;i++){
		for (int j=1;j<= n;j++){
			a[i][j]=f[i][j];
		}	
	}
	k=min(k,n);
	for(int kk=2;kk<=k;kk++){//跑k次
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){ 
				b[i][j]=a[i][j];
			} 
		} 
		for(int lg=1;lg<=n;lg++){
			for (int i=1;i<=n;i++){
				for (int j=1;j<=n;j++){
					b[i][j]=min(b[i][j],a[i][lg]+f[lg][j]);//只转移一条边
				}
			}
		} 			
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
			    a[i][j]=b[i][j];//更新
			} 
		}	
	}
	for(int i=1;i<=q;i++){
		scanf("%lld%lld",&s,&t);
		if(s==t)printf("0\n");//特判s=t的情况
		else if(a[s][t]==1e9)printf("-1\n");//无法到达
		else printf("%d\n",a[s][t]);
	}
	return 0;
}
```



---

## 作者：Gmt丶FFF (赞：1)

练习一下分层图吧。

一个点由两个维度组成：点数与走过的边数，每一次这个点只能走到下一层的点，那么对应的进行连边即可。

对于 $k$ 非常大的问题，由于走过一个点后再次回到那个点肯定不是最优，所以实际上最多只用走 $n-1$ 次就够了，那么操作 $k=\min(k,n-1)$ 即可。

利用邻接矩阵存边，算是非常简单的分层图了。

```cpp
#include<iostream>
#include<cstdio>
#include<deque>
#include<cstring>
using namespace std;
const int N=75;
int read()
{
	int sum=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		sum=(sum<<1)+(sum<<3)+(ch^48);
		ch=getchar();
	}
	return sum;
}
inline int min(int x,int y)
{
	return x<y?x:y;
}
int n,m,dis[N][N][N],a[N][N],ins[N][N];
deque<pair<int,int>>q;
void spfa(int beg)
{
	q.push_back({beg,0});
	dis[beg][beg][0]=0;
	while(!q.empty())
	{
		int x=q.front().first,y=q.front().second;
		ins[x][y]=0;
		q.pop_front();
		if(y>n)continue;
		for(int i=1;i<=n;i++)
		{
			if(dis[beg][x][y]+a[x][i]<dis[beg][i][y+1])
			{
				dis[beg][i][y+1]=dis[beg][x][y]+a[x][i];
				if(!ins[i][y+1])
				{
					ins[i][y+1]=1;
					if(!q.empty()&&dis[beg][i][y+1]<dis[beg][q.front().first][q.front().second])q.push_front({i,y+1});
					else q.push_back({i,y+1});
				}
			}
		}
	}
}
int main()
{
	memset(dis,0x3f,sizeof(dis));
	memset(a,0x3f,sizeof(a));
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		a[u][v]=min(w,a[u][v]);
	}
	for(int i=1;i<=n;i++)spfa(i);
	int k=read(),q=read();
	k=min(k,n);
	for(int i=1;i<=q;i++)
	{
		int u=read(),v=read();
		int ans=1e9+5;
		for(int j=0;j<=k;j++)ans=min(ans,dis[u][v][j]);
		if(ans>1e9)printf("-1\n");
		else printf("%d\n",ans);
	}
	return 0;
}
/*
4 7
1 2 1
1 4 10
2 3 1
2 4 5
3 2 2
3 4 1
4 3 2
3 3
1 4
4 2
3 3
*/
```


---

## 作者：lhc_0506 (赞：1)

第 3 篇题解

# P8312 [COCI2021-2022#4] Autobus 题解

### 题意

$n$ 个点，$m$ 条边，每条边有一个权值，给你起点和终点，问你能不能在行走的边的条数不超过 $k$ 的情况下到达终点，如果能，那么要多久。

### 分析

一道很明显的最短路，并且这是一道多源最短路，所以**建议**用 Floyd ( 其他方法没试过，可以自己试试 )

但是题面有个限制，最多坐 $k$ 个不同的公交线路，我们只能定义两个数组，一个存上一轮结果，另一个数组存这一轮结果。**每次只连一条边**，跑 $k-1$ 次。

Floyd 代码如下

```cpp

void floyd() {//听说把代码模块化会显得代码很高级？
	k=min(k,n);
	for(int kk=2; kk<=k; kk++) {//限制步数
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				b[i][j]=a[i][j];
		for(int kk=1; kk<=n; kk++)
			for(int i=1; i<=n; i++)
				for(int j=1; j<=n; j++)
					b[i][j]=min(b[i][j],a[i][kk]+dp[kk][j]);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				a[i][j]=b[i][j];
	}
}

```

但是，只有它也是不够的,在输出时，我们还要下功夫，如果起点等于终点，那就不用走，如果走不到怎么判断呢，很简单，我们只需要把 $dp$ 数组初始为很大的数，如果最后还是那个数，那就一定走不到

还是看一下代码

```cpp

if(x==y)//当起点等于终点
		puts("0");
else if(a[x][y]==123454321)//无解
	puts("-1");
else
	printf("%d",a[x][y]),puts("");

```

### 吐槽一下

这道题要评测很久，如果你发现一直在编译，或一直在评测，这是正常现象。

$$\small\color{white}\texttt{实际上我应该是做这道题的时候又有人卡紫荆花。}$$

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,q,dp[80][80],a[80][80],b[80][80];
void floyd() {//听说把代码模块化会显得代码很高级？
	k=min(k,n);
	for(int kk=2; kk<=k; kk++) {//限制步数
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				b[i][j]=a[i][j];
		for(int kk=1; kk<=n; kk++)
			for(int i=1; i<=n; i++)
				for(int j=1; j<=n; j++)
					b[i][j]=min(b[i][j],a[i][kk]+dp[kk][j]);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				a[i][j]=b[i][j];
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			dp[i][j]=123454321;//建议别打INT_MAX,会出现奇怪的错误
	for(int i=1,x,y,z; i<=m; i++)
		scanf("%d%d%d",&x,&y,&z),dp[x][y]=min(dp[x][y],z);
	scanf("%d%d",&k,&q);
	for(int i=1; i<=n; i++)//初始化
		for(int j=1; j<=n; j++)
			a[i][j]=dp[i][j];
	floyd();
	while(q--) {
		int x,y;
		scanf("%d%d",&x,&y);
		if(x==y)//当起点等于终点
			puts("0");
		else if(a[x][y]==123454321)//无解
			puts("-1");
		else
			printf("%d",a[x][y]),puts("");
	}
	return 0;
}
```


---

## 作者：Frevotops (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P8312)

## Description

给出一张有向带权图，多次询问，每次询问点 $c_i$ 到点 $d_i$ 在经过最多 $k$ 条边的情况下的最短路。

点数 $\le 70$，有重边，询问次数 $\le 10^6$，$k \le 10^9$。

## Solution

首先不难发现这个 $k$ 的 $10^9$ 是来搞笑的。我们走最短路，在这张图上怎么走也最多只能走 $n-1$ 条边。

首先可以考虑 $n$ 轮 SPFA，但是这样没有考虑 $k$ 的限制。我们给每个点加一维，$(i,j)$ 表示在确定起点的情况下，原图中点 $i$ 到起点经过边数恰好为 $k$ 的情况下的最短路。这是一种常规的套路。

这样跑的话时间复杂度其实是挺高的。单算跑最短路的时间复杂度最坏是 $O(n \times n^2 \times n^4)=O(n^7)$，因为 SPFA 的最坏时间复杂度是 $O(VE)$，$V$ 是点数，$E$ 是边数。但是由于我们建立的图是虚图，并不是那些卡 SPFA 的特例。对于这种特殊图我也不会算，就当他是 $O(E)$ 的吧（其实随机图跑 SPFA 都是大约 $O(E)$ 的时间，虽然精确的复杂度不是）。

关于 Dijkstra，这里它死了！因为 SPFA 可能不把 log 带上去，但是 Dijkstra 就强制乘了个 $\log$。

然后就是一堆乱七八糟的优化，就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,pair<ll,ll> > P;
ll n,m,u,v,w,k,q;
ll f[75][75],dis[75][75][75],vis[75][75][75];
struct Edge{
    ll to,w,nxt;
}edge[1000005];
ll head[1000005],tot;
void add(ll u,ll v,ll w){
    edge[++tot].to=v;
    edge[tot].w=w;
    edge[tot].nxt=head[u];
    head[u]=tot;
}
queue<pair<ll,ll> >Q;
void solve(ll x){
    dis[x][x][0]=0;  vis[x][x][0]=1;
    Q.push(make_pair(x,0));
    while(!Q.empty()){
        ll X=Q.front().first, Y=Q.front().second; Q.pop();
        vis[x][X][Y]=0;
        if(Y>=n-1) continue;
        for(ll i=head[X];i;i=edge[i].nxt){
            ll tmp=edge[i].to, val=edge[i].w;
            if(dis[x][tmp][Y+1]>dis[x][X][Y]+val){
                dis[x][tmp][Y+1]=dis[x][X][Y]+val;
                if(!vis[x][tmp][Y+1]) Q.push(make_pair(tmp,Y+1)), vis[x][tmp][Y+1]=1;
            }
       }
    }
} // 跑 SPFA
inline ll minn(ll a,ll b){
    return a<b?a:b;
}
ll hashtable[75][75];
int main(){
    memset(f,127,sizeof(f));
    memset(dis,127,sizeof(dis));
    memset(hashtable,127,sizeof(hashtable));
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=m;i++){
        scanf("%lld%lld%lld",&u,&v,&w);
        f[u][v]=minn(f[u][v],w);
    }
    for(ll i=1;i<=n;i++)
        for(ll j=1;j<=n;j++)
            if(f[i][j]<1e9) add(i,j,f[i][j]);
    for(ll i=1;i<=n;i++) solve(i);
    scanf("%lld%lld",&k,&q);
    while(q--){
        scanf("%lld%lld",&u,&v);
        if(hashtable[u][v]<1e10){
            printf("%lld\n",hashtable[u][v]);
            continue;
        }
        ll ans=1e18;
        for(ll i=0;i<=k && i<=n-1;i++){
            if(dis[u][v][i]>1e16) continue;
            ans=minn(ans,dis[u][v][i]);
        }
        if(ans>1e16){
            puts("-1");
            hashtable[u][v]=-1;
        }
        else printf("%lld\n",ans), hashtable[u][v]=ans;
    } // hashtable 运用了记忆化的思想
    return 0;
}
```

---


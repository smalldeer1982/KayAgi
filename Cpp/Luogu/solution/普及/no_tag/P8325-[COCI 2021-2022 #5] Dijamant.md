# [COCI 2021/2022 #5] Dijamant

## 题目描述

桌上摆放有若干颗『钻石』。

当一个正方形旋转 $45^\circ$ 时，它就形成了『菱形』的形状。规定外形形如『菱形』且外边框均为 $\texttt \#$ 但内部均为 $\texttt .$ 的图形为一颗『钻石』。

给定一个 $n \times m$ 大小的桌面，统计桌上摆放有多少颗『钻石』。

## 说明/提示

**【样例 2 解释】**

看起来好像有 $3$ 颗，但实际上有两个『菱形』互相包含，因此不符合『外边框均为 $\texttt \#$ 但内部均为 $\texttt .$』的定义。故只有 $1$ 颗『钻石』。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$1 \le n,m \le 100$。
- Subtask 2（50 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,m \le 2000$。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/contest5_tasks.pdf) Task 2 Dijamant。**

## 样例 #1

### 输入

```
7 25
.#...#....#....#.....#...
#.#..#...#.#...#....#.#..
.#...#..#...#..#...#...#.
.....#...#.#...#..#.....#
.....#....#....#...#...#.
.....#.........#....#.#..
.....#.........#.....#...```

### 输出

```
3```

## 样例 #2

### 输入

```
11 17
.....#........#..
....#.#........#.
...#...#....#...#
..#.....#....#.#.
.#....#..#....#..
#....#.#..#......
.#....#..#.......
..#.....#........
...#...#.........
....#.#..........
.....#...........```

### 输出

```
1```

## 样例 #3

### 输入

```
5 11
##.#.#.#.##
#.#.#.#.#.#
.#.#.#.#.#.
#.#.#.#.#.#
##.#.#.#.##```

### 输出

```
14```

# 题解

## 作者：MvemiY (赞：12)

这道题前前后后花了我很长时间 ~~14个小时~~，用了很多思路，bfs，dfs，爆搜，最后不是 RE 就是 TLE。最后仔细观察了一下菱形，认为模拟就可以直接做，然后恍然大悟。
## 题目描述

题目就是给定个二维数组，求出上面有多少个**菱形**，且这个菱形需要是**合法**的。怎么判定它是不是合法的？

1.菱形的每条边都需要由 ```#``` 构成。

2.菱形的内部只能由 ```.``` 填充。

3.由 样例3 我们可以知道，不同菱形的点是可以重合的。


## 判定菱形
因为题目中不同边长的菱形其实是相似的，所以就有了一下思路：

先找到菱形最高点的坐标，而后找到最低点的坐标。

因为菱形可以看做两个全等的等腰三角形在底上拼合而成，

所以两三角形的底，即是菱形的一条对称轴。

于是我们从菱形上面的三角形的每一个点开始遍历：

如果点在边上而且字符为 ```.``` ，那么这个菱形就不是合法的；

相同，当点不在菱形边上而且字符为 ```#``` ，那么这个菱形也不是合法的。

## 变量声明
将菱形最高点的 $x$ 坐标记作 $Ux$，将菱形最高点的 $y$ 坐标记作 $Uy$。

将菱形最低点的 $x$ 坐标记作 $Dx$，将菱形最低点的 $y$ 坐标记作 $Dy$。

将两三角形的底所在的 $x$ 坐标记作 $Mx$。

将两三角形的顶点的距离记作 $H$。

将菱形之上的三角形第 $i$ 行的点的数量记作 $PN_i$。
## 寻找变量

输入后遍历数组，当遇到 ```#``` 时，赋值 $Ux = i_1$，$Uy = j_1$。

从 $Dx$ 和 $Dy$ 的坐标向下搜，搜到 ```#``` 为止，赋值 $Dx = i_2$，$Dy = j_2$。

关于 $Mx$:

$$\because Mx = Ux + \frac{H}{2} $$ 

$$ H = Ux - Dx$$

$$\therefore Mx = Ux + \frac{Ux - Dx}{2} $$ 


## 如何遍历菱形上下两个三角形

如下图，是一个菱形上方的三角形以及每行的点的数量：

![](https://cdn.luogu.com.cn/upload/image_hosting/t4rydniq.png)


由此可见，在第 $n$ 行时：

$$PN_n = 2n-1$$

如下图，是一个菱形下方的三角形以及每行的点的数量：

![](https://cdn.luogu.com.cn/upload/image_hosting/98s05g61.png)

可以看到，下方的三角形其实就是上方三角形倒立过来。

所以我们只需要用一个双层循环，就可以遍历整个菱形！

## Code Time
说了这么多，到了大家最喜欢的代码啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
int N, M, ans, Ux, Uy, Dx, Dy, Mx; //变量声明已经介绍完了 
char mapp[2010][2010];
bool F(int a,int b){
	Ux = a, Uy = b;
	Dx = Dy = Mx = 0; 
	for(int i = 2; i + Ux <= N; i += 2)
		if(mapp[Ux + i][Uy] == '#'){
			Dx = Ux + i, Dy = Uy;
			break;
		}
	if(Dx == 0) //如果没有找到 Dx ，即 Uy 一列都没有 # ，直接 return 0 
		return 0;
	Mx = Ux + (Dx - Ux) / 2; 
	for(int i = 1; Ux + i <= Mx; i++)//枚举到 Mx 即可 
		for(int j = 0; j <= 2 * i; j++){
			int xx = Ux + i, yy = Uy - i + j; 
			if(xx < 1 || xx > N || yy < 1 || yy > M)
				return 0;
			if(j == 0 || j == 2 * i){
				if(mapp[xx][yy] == '.')
					return 0; //边上 . 不合法 
			}else if(mapp[xx][yy] == '#')
				return 0; //内部 # 不合法 
			xx = Dx - i;
			if(j == 0 || j == 2 * i){
				if(mapp[xx][yy] == '.')
					return 0; //边上 . 不合法 
			}else if(mapp[xx][yy] == '#')
				return 0; //内部 # 不合法 
		}
	return 1;
}
int main(){
	cin >> N >> M;
	for(int i = 1; i <= N; i++)
		for(int j = 1; j <= M; j++)
			cin >> mapp[i][j];
	for(int i = 1; i <= N; i++)
		for(int j = 1; j <= M; j++)
			if(mapp[i][j] == '#' && F(i,j))
					ans++;
	cout << ans;
	return 0;
}
```

---

## 作者：Haber (赞：5)

### 题目大意

给一个 $n\times m$ 的字符矩阵，求里面菱形的数量。

菱形的定义：『外边框均为 $\texttt \#$ 但内部均为 $\texttt .$』。

### 题目总评

这题数据范围小，应该是模拟。

这道题有几个需要注意的地方：

1. 是正方形旋转 $45^\circ$ 后得到的菱形才计数，你完全可以把题目里面的菱形理解成斜着的正方形。

2. 菱形内部必须不能有 $#$。

3. 一个 $#$ 可以被多次计入不同的菱形。

### 解题方案

对于每一个菱形，我们可以把它分成两部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/09v1ehf8.png)

所以只需判断上面是否是一个**空心的** $\bigwedge$，下面是否是一个**空心的** $\bigvee$ 就行了。

### 代码实现

首先看 `other()` 函数。

```cpp
bool other(int x,int y1,int y2){
	for(int i=y1;i<=y2;i++)
		if(mp[x][i]=='#')
			return true;
	return false;
}
```
`int x,int y1,int y2` 表示在第 $x$ 行，从 $y1$ 列开始到第 $y2$ 列结束是否里面全是 $\texttt {.}$,即空心的。


`find()` 函数主要是来判断红线上方是否是一个空心的 $\bigwedge$ 的。

`int x,int y` 是 $\bigwedge$ 的尖尖上的那个 $\texttt\#$ 的坐标，然后从上到下，依次向下扩展一层并向外走一位，判断左右两边的字符是否是 $\texttt\#$。如果不是，就返回这个点不能有一个菱形；如果可以，就继续向下。


```cpp
bool find(int x,int y){
	for(int i=1;i<=n;i++){
		if(x+i>n||y-i<1||y+i>m||mp[x+i][y-i]!='#'||mp[x+i][y+i]!='#') return false;
		if(other(x+i,y-i+1,y+i-1)) return false;
		if(down(x,y,i)) return true;
	}
	return false;
}
```

`down()` 函数就是判断红线下方是否是空心的 $\bigvee$ 的，这个函数和 `find()` 差不多，只有从上到下和从下到上的区别。

`int x,int y,int cnt` 表示以 $\left(x,y\right)$ 为顶点，半高为 $cnt$ 的一个半菱形需要向下合并。注意判断一下边界。

```cpp
bool down(int x,int y,int cnt){
	for(int i=1;i<=cnt;i++)
		if(x+cnt+i>n||y-cnt+i>m||x+cnt-i>n||mp[x+cnt+i][y-cnt+i]!='#'||mp[x+cnt+i][y+cnt-i]!='#'||other(x+cnt+i,y-cnt+i+1,y+cnt-i-1))
			return false;
	return true;
}
```
这里有一个问题，为什么不需要判重？因为每一个顶点出发的菱形最多只有一个，否则就会互相包含。所以找到一个可行的答案放心退出就行了。

最后就是~~你们最喜欢的~~完整的**无注释代码**了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
const int N=2e3+2;
char mp[N][N];
bool other(int x,int y1,int y2){
	for(int i=y1;i<=y2;i++)
		if(mp[x][i]=='#')
			return true;
	return false;
}
bool down(int x,int y,int cnt){
	for(int i=1;i<=cnt;i++)
		if(x+cnt+i>n||y-cnt+i>m||x+cnt-i>n||mp[x+cnt+i][y-cnt+i]!='#'||mp[x+cnt+i][y+cnt-i]!='#'||other(x+cnt+i,y-cnt+i+1,y+cnt-i-1))
			return false;
	return true;
}
bool find(int x,int y){
	for(int i=1;i<=n;i++){
		if(x+i>n||y-i<1||y+i>m||mp[x+i][y-i]!='#'||mp[x+i][y+i]!='#') return false;
		if(other(x+i,y-i+1,y+i-1)) return false;
		if(down(x,y,i)) return true;
	}
	return false;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>mp[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(mp[i][j]=='#'&&find(i,j))
				ans++;
	cout<<ans<<endl; 
	return 0;
}
```

---

## 作者：slzx2022YuYihan (赞：2)

# Solution

个人想到一种非常玄学的方法，就是有点难理解。

首先要知道一个性质：对于一个作为菱形最上方端点 ``#``，令 ``fir[i][j]`` 表示与它同列的在下面的最近的 ``#`` 的行数，只有 ``fir[i][j]`` 才有可能满足条件，而且要满足 ``fir[i][j]-i`` 为偶数。

然后开始判断菱形中间是否为空，二位前缀和乱搞即可，减去四个等腰直角三角形。至于复杂度为何正确，下面给出阐述。

因为 ``fir[i][j]-i`` 为偶数，所以我们令所有奇数行都为 ``#``，然后发现中间循环计算的总次数大约在 $O(\frac{nm}{2}\times 2)=O(nm)$ 次，因此复杂度正确。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
	x = 0; T w = 1; char ch = getchar();
	while (!isdigit(ch)){if (ch == '-')	w = -1; ch = getchar();}
	while (isdigit(ch))	x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	x *= w;
}
template<typename T>inline void write(T x){
	if (x < 0)	putchar('-'), x = ~(x - 1);
	if (x > 9)	write(x / 10);
	putchar(x % 10 ^ 48);
}

const int N = 2005;

ll n, m;
char s[N][N];

ll sum[N][N];
ll get_sum(ll i, ll j, ll k, ll l){
	return sum[k][l] - sum[i - 1][l] - sum[k][j - 1] + sum[i - 1][j - 1];
}

ll sum1[N][N], sum2[N][N], fir[N][N], sec[N][N];
//sum1表示从左下到右上连续的#，sum2表示从右下到左上连续的#

ll ans;

int main(){
	freopen("dijamant.in", "r", stdin), freopen("dijamant.out", "w", stdout);
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

	read(n), read(m);
	for (int i = 1; i <= n; ++i){
		scanf("%s", s[i] + 1);
		for (int j = 1; j <= m; ++j)	sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + (s[i][j] == '#');
	}
	for (int i = n; i; --i)
		for (int j = 1; j <= m; ++j)
			if (s[i][j] == '.'){
				sum1[i][j] = sum2[i][j] = 0;
				fir[i][j] = sec[i][j] = sec[i + 1][j];
			}
			else{
				sum1[i][j] = sum1[i + 1][j - 1] + 1, sum2[i][j] = sum2[i + 1][j + 1] + 1;
				fir[i][j] = sec[i + 1][j];
				sec[i][j] = i;
			}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			if (s[i][j] == '#' && fir[i][j] && (fir[i][j] - i) % 2 == 0)
				if (sum1[i][j] >= (fir[i][j] - i) / 2 + 1 && sum2[i][j] >= (fir[i][j] - i) / 2 + 1 && sum2[i + (fir[i][j] - i) / 2][j - (fir[i][j] - i) / 2] >= (fir[i][j] - i) / 2 + 1 && sum1[i + (fir[i][j] - i) / 2][j + (fir[i][j] - i) / 2] >= (fir[i][j] - i) / 2){
					ll res = get_sum(i, j - (fir[i][j] - i) / 2, fir[i][j], j + (fir[i][j] - i) / 2);
					for (int k = 1; k <= (fir[i][j] - i) / 2; ++k){
						res -= get_sum(i + k - 1, j - (fir[i][j] - i) / 2, i + k - 1, j - k);
						res -= get_sum(i + k - 1, j + k, i + k - 1, j + (fir[i][j] - i) / 2);
						res -= get_sum(fir[i][j] - k + 1, j - (fir[i][j] - i) / 2, fir[i][j] - k + 1, j - k);
						res -= get_sum(fir[i][j] - k + 1, j + k, fir[i][j] - k + 1, j + (fir[i][j] - i) / 2);
				    }
				    res -= 2 * (fir[i][j] - i);
					if (res == 0)	++ans;
				}
	write(ans), putchar('\n');

	return 0;
}
```

---

## 作者：Melo_qwq (赞：1)

一道好的**爆搜**，不需要什么玄学剪枝，说是也可以用 dp。

由样例可以得菱形的 ``#`` 是可以重叠的。

我们发现一个菱形可以沿着横着的那条对角线分为上下两个等腰直角三角形，所以我们只需要分别判断这两个三角形是否合法即可。

那么如何判断是否合法？

我们可以枚举三角形的高度，对于每个高度，判断这个三角形的两侧是不是都是 ``#``，另外判断其他地方是不是都是 ``.`` 即可。

这部分的代码：

```cpp
inline bool all (int x ,int _ ,int __) {
	f (i ,_ ,__ ,1) {
		if (a[x][i] == '#') return false ;
	}
	return true ;
}
inline bool down (const int &x ,const int &y ,const int &len) {
	f (i ,1 ,len ,1) {
		if (x + len + i > n || y - len + i < 1 || y + len - i > m || a[x + len + i][y - len + i] != '#' || a[x + len + i][y + len - i] != '#') return false ;
		if (! all (x + len + i ,y - len + i + 1 ,y + len - i - 1)) return false ;
	}
	return true ;
}
inline bool check (const int &x ,const int &y) {
	f (i ,1 ,n ,1) { // 向下延伸 i 行
		if (y - i < 1 || y + i > m || a[x + i][y - i] != '#' || a[x + i][y + i] != '#') return false ;
		if (! all (x + i ,y - i + 1 ,y + i - 1)) return false ; 
		if (down (x ,y ,i)) return true ;
	}
	return false ;
}
```
一个小问题就是为什么搜到了可以直接返回，因为注意，以一个点为顶点的合法的菱形至多有一个，就是最小的那个。

统计答案可以记录每个 ``#`` 的位置，注意第 $n-1$ 行以下的井号没有用。

```cpp
f (i ,1 ,n ,1) {
	f (j ,1 ,m ,1) {
		cin >> a[i][j] ;
		if (i <= n - 2 && a[i][j] == '#') pt.emplace_back (make_pair (i ,j)) ;
	}
}
int ans = 0 ;
for (auto i : pt) {
	int x = i.first ,y = i.second ;
	if (check (x ,y)) ans ++ ;
}
```
``all`` 函数其实可以使用前缀和优化成 $\mathcal{O}(1)$。

---

## 作者：D0000 (赞：1)

# P8325 [COCI2021-2022#5] Dijamant 题解
## 题目大意
求一个 $n\times m$ 的由 # 和 . 构成的矩阵中，有多少个 # 组成且内部全为 . 的菱形，菱形的定义就是题目中所说的正方形旋转 $45^\circ$。
## 思路分析
### 搜索（不建议尝试）
很明显这道题是可以用到搜索的，深搜广搜都可以，但是写起来过于复杂，且容易 TLE，复杂度 $O(n^2m^2)$，剪枝后复杂度略高于 $O(nm)$，到现在为止老师的评测系统我还有几个点没过。
### 暴力（虽然是“暴力”但很快）
很明显本题的数据范围理想复杂度为 $O(nm)$，那位们不妨想一种每个点循环一遍的方法（中间不递归），我是用 $c_{i,j}$ 数组来储存输入的数据，$ans$ 变量来储存答案，初值为 $0$，其他变量后面再介绍。

我的主要思路就是通过类似 DP 的方法判断 # 能否是菱形的尖尖，如果下面一排合法就再往下看是否合法，直到只有一个 #，这个方法就是大部分人的，那么我们倒推一下便可以省去递归的时间！

#### 第一步：预处理
使用一个 $arr_{i,j}$ 数组来储存每一个 # 字符同行后面第一个为 # 的元素下标 $j$，若后面不存在 #，则默认为 $-1$

#### 第二步（也是最后一步）：计算答案
首先我们知道不可能存在两个及以上菱形的尖尖是同一个，其次中间是空心的。

其次我们知道如果一个 # 是尖尖，那么它下面的 /\ 部分和 \\/ 部分必须全为 #，且中间部分全为 .，那么我们用一个 $b_{i,j,d}$ 布尔数组（初值为 $0$)来判断这个 # 及其以下的部分是否合法，其中 $d$ 表示阶段，$0$ 或者 $1$。

我们自下而上（反之亦然），自左往右循环，对于任意 $c_{i,j}$ 为 #:
1. 若 $arr_{i,j}=j+2,c_{i+1,j+1}$ 为 #，则 $b_{i,j,1}$ 为真；
1. 若 $arr_{i,j}=arr_{i+1,j+1}+1,b_{i+1,j+1,1}=1,c_{i+1,j+1}$ 为 #，则 $b_{i,j,1}$ 为真；
1. 若 $arr_{i,j}=arr_{i+1,j-1}-1,b_{i+1,j-1,1}=1,c_{i+1,j-1}$ 为 #，则 $b_{i,j,0}$ 为真；

1. 若 $arr_{i,j}=arr_{i+1,j-1}-1,b_{i+1,j-1,0}=1,c_{i+1,j-1}$ 为 #，则 $b_{i,j,0}$ 为真；

1. 若 $arr_{i,j-1}=j+1,b_{i+1,j-1,1}=1$，则 $ans$ 增加 $1$;
1. 若 $arr_{i,j-1}=j+1,b_{i+1,j-1,0}=1$，则 $ans$ 增加 $1$。

解释：![](https://cdn.luogu.com.cn/upload/image_hosting/emfwfkxr.png)

红色表示 $j$，橙色表示 $arr[i][j]$，蓝色的左右两边分别表示 $b[i][j][1]$ 和 $b[i][j][0]$。

也就是说 $b[i][j][d]$ 只看菱形的左边两条边，而对应的右边以及中间是否空心就看 $arr[i][j]$。
### 代码
```cpp
#include<cstdio>
int n,m,arr[2005][2005],ans;
char c[2005][2005];
bool b[2005][2005][2];
int main(){
//	freopen("diamond.in","r",stdin);
//	freopen("diamond.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		scanf("%s",&c[i]);
		int the=-1;
		for(int j=m-1;j+1;j--)if(c[i][j]=='#')arr[i][j]=the,the=j;
	}
	for(int i=n-1;i+1;i--)for(int j=0;j<m;j++)if(c[i][j]=='#'){
		if(i!=n-1&&c[i+1][j+1]=='#'&&arr[i][j]==j+2)b[i][j][1]=1;
		if(i!=n-1&&j&&c[i+1][j-1]=='#'&&arr[i+1][j-1]==j+1&&(b[i+1][j-1][1]||b[i+1][j-1][0]))ans++;
		if(i!=n-1&&c[i+1][j+1]=='#'&&b[i+1][j+1][1]&&arr[i+1][j+1]!=-1&&arr[i][j]!=-1&&arr[i+1][j+1]==arr[i][j]-1)b[i][j][1]=1;
		if(1!=n-1&&j&&c[i+1][j-1]=='#'&&(b[i+1][j-1][1]||b[i+1][j-1][0])&&arr[i+1][j-1]!=-1&&arr[i][j]!=-1&&arr[i+1][j-1]==arr[i][j]+1)b[i][j][0]=1;
	}
	printf("%d",ans);
}
```
## 总结
其实上这个题的主要思路就是通过类似 DP 的方法判断 # 能否是菱形的尖尖。

而我的算法的复杂度为 $O(nm)$：预处理和计算均为 $O(nm)$。

这个方法可能比较抽象，没有上面几个红名大佬那么简单易懂，但却是复杂度更低，故攥写本题解，谢谢！

---

## 作者：orange_dream (赞：1)

我感觉是个神奇的思路。

1.  $pre[i][j]$ 维护同行之中下一个 '#' 是那个地方

2.  $ok[i][j]$ 来维护上半部分可否形成钻石

3.  $ok2[i][j]$ 来维护下半部分可否形成钻石

上半部分有两种情况可以成立：

1.  $ok[i-1][j+1]$ 成立且这一行正好对接上
2.  钻石最上方

下半部分也有两种情况可以成立：

1.  $ok2[i+1][j+1]$ 成立且这一行正好对接上
2.  钻石最下方

所以先处理 $pre[i][j]$ 后来分别扫一遍 $ok[i][j]$ 与 $ok2[i][j]$，最后符合要求的点即为 $ok[i][j]$ 与 $ok2[i][j]$ 都成立的点

献上代码：

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

int n,m,ans;
char s[2005][2005];
int pre,p[2005][2005];
bool ok[2005][2005],ok2[2005][2005];

void read(int &x){
	char c=getchar();int F=1;x=0;
	while (!isdigit(c) && c!='-')c=getchar();
	if (c=='-')F=-1,c=getchar();
	while (isdigit(c))x=x*10+c-48,c=getchar();
}
void write(int x){if (x>9)write(x/10);putchar(x%10+'0');}

signed main(){
	read(n);read(m);
	for (int i=1;i<=n;i++){
		scanf("%s",s[i]+1);
	}
	for (int i=1;i<=n;i++){
		pre=m+1;
		for (int j=m;j>=1;j--){
			if (s[i][j]=='#'){
				p[i][j]=pre;
				pre=j;
			}
		}
	}
	for (int i=n;i>=1;i--){
		for (int j=m;j>=1;j--){//this thing will solve down
			int pre=p[i][j];
			if (s[i][j]=='.' || pre==m+1){}
			else{
				if (p[i][j]==p[i+1][j+1]+1)ok[i][j]=ok[i+1][j+1];//对接上了 
				if (pre==j+2 && s[i+1][j+1]=='#')ok[i][j]=1;//最下方 
			}
		}
	}
	for (int i=1;i<=n;i++){
		for (int j=m;j>=1;j--){//this thing will solve up
			int pre=p[i][j];
			if (s[i][j]=='.' || pre==m+1){}
			else{
				if (p[i][j]==p[i-1][j+1]+1)ok2[i][j]=ok2[i-1][j+1];//对接上了 
				if (pre==j+2 && s[i-1][j+1]=='#')ok2[i][j]=1;//最上方 
			}
		}
	}
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			if (ok[i][j] && ok2[i][j])ans++;//if up is ok and down is ok then all ok?
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：MrSWdAxiv (赞：1)

这道题数据范围不是很大，最好的方法当然是**模拟**！
## 关于题目
>
>给定一个 $n × m$ 大小的矩阵，统计矩阵里有多少个 『**菱形**』 。
>
>规定外边框均为 **#** 但内部均为 . 的图形为一个 『**菱形**』 。
>
>不同菱形可以共用一个 **#** 符号。
>

## 关于思路
>
> #### 首先是找到菱形
>
>可以先找到一个 **#** 符号。
>
>然后一直沿着这个 **#** 的 $Y$ 轴往下搜，直到找到另一个 **#** 符号。
>
>搜的过程中只需要遍历菱形最高点和最低点坐标的差是奇数的就行，因为差为偶数不能构成菱形。
>
> #### 然后是判断菱形
>
>我们可以把菱形**一分为二**，如下：
>
>[![vspQy9.md.png](https://s1.ax1x.com/2022/08/19/vspQy9.md.png)](https://imgse.com/i/vspQy9)
>
>
>这时就需要先算一下中间的对称轴。
>
>```
>菱形对称轴 X 坐标 = 菱形长度（菱形最低点 X 坐标 - 菱形最高点 X 坐标）/ 2 + 菱形最高点 X 坐标
>```
>这样只需要判断上面那部分和下面那部分就行了。
>
>判断其中一个点的坐标很容易， $X$ 坐标即为其所在菱形最高点 $X$ 坐标加上这个点所在行坐标， $Y$ 坐标即为其所在菱形最高点 $Y$ 坐标减去这个点所在行坐标再加上这个点是这一行的第几个。
>
>而这一行的符号的个数就是：
>```
>这一行的符号的个数 = 2 * 行数 + 1
>```
>

## 接下来上代码！
>
>```cpp
>#include<bits/stdc++.h>
>using namespace std;
>int n,m,cnt,Topx,Topy,Downx,Downy,Middle;
>char a[5002][5002];
>bool pdlx(int x,int y,int len,int rl){//判断菱形是否合法
>	if(x<=0||y<=0||x>=n+1||y>=m+1){//越界
>		return 0;
>	}
>	if(rl==0||rl==2*len){//是边界
>		if(a[x][y]=='.'){
>			return 0;
>		}
>	}else if(a[x][y]=='#'){//是内部
>		return 0;
>	}
>	return 1;
>}
>bool Find(int x,int y){
>	Topx=x,Topy=y,Downx=Downy=Middle=0;
>	for(int i=2;i+Topx<=n;i+=2){//找菱形
>		if(a[i+Topx][Topy]=='#'){
>			Downx=i+Topx,Downy=Topy;
>			break;
>		}
>	}
>	if(!Downx||!Downy){//没找到
>		return 0;
>	}
>	Middle=Topx+(Downx-Topx)/2;//算对称轴
>	for(int i=1;i+Topx<=Middle;i++){//遍历半个菱形
>		for(int j=0;j<=2*i;j++){
>			if(!pdlx(Topx+i,Topy-i+j,i,j)){//判断上半个菱形
>				return 0;
>			}
>			if(!pdlx(Downx-i,Topy-i+j,i,j)){//判断下半个菱形
>				return 0;
>			}
>		}
>	}
>	return 1;
>}
>int main(){
>	ios::sync_with_stdio(false);
>	cin.tie(0);
>	cout.tie(0);
>	cin>>n>>m;
>	for(int i=1;i<=n;i++){
>		for(int j=1;j<=m;j++){
>			cin>>a[i][j];
>		}
>	}
>	for(int i=1;i<=n;i++){
>		for(int j=1;j<=m;j++){
>			if(a[i][j]=='#'&&Find(i,j)){
>				cnt++;
>			}
>		}
>	}
>	cout<<cnt<<'\n';
>	return 0;
>}
>
>```


---

## 作者：super_zzr (赞：0)

## 思路：

1.  ##### 因为钻石里面不可以包括其他 `#`，所以可以先把每一行的 `#` 当做 1，`.` 当做 0 来求一个前缀和，这样就能算出来在一个区间内是否有 `#` 了。

2. ##### 然后可以把所有的 `#` 当做一个钻石的顶点往下找，如果是一个符合条件的钻石那就把答案加一，那怎么判断它是不是一个钻石呢？
 
- 对于一个钻石，我们可以把它分成 2 部分：
 
### 上半部分：
 
```cpp
...#...
..#.#..
.#...#.
#.....#
```
 
### 下半部分：

```cpp
.#...#.
..#.#..
...#...
```

- **对于上半部分**，我们先找到一个 `#` 为顶点往下搜索，如果搜索到的 2 个 `#` 开始往里收缩，就跳出上半部分来进行下半部分的搜索，因为如果继续进行上半部分的搜索的话，那么就一定不满足 『外边框均为 $\texttt \#$ 但内部均为 $\texttt .$』。

- 而且对于上半部分我们会发现对于以 $a[i][j]$ 为顶点的钻石，上半部分第 $cnt$ 行的 `#` 分别在 $a[i+cnt][j+cnt]$，$a[i+cnt][j+cnt]$ 的位置上。所以我们只需要判断 $a[i+cnt][j+cnt]$ 和 $a[i+cnt][j+cnt]$ 是否为 `#` 并且两点之间有没有 `#` 就好了
- **对于下半部分**，我们假设 $cnt$ 为上半部分的总行数，对于下半部分的第 $k$ 行，`#` 分别在 $a[i+cnt+k][j+cnt-k]$ 和 $a[i+cnt+k][j-cnt+k]$ 的位置上，同样，我们判断这两个点上是否为 `#` 和之间有没有空格就好了。（最后一行因为两个点重合了，所以不需要判断中间是否有 `#`）

## 以下是含注释全部代码:
```cpp
#includeiostream
#includealgorithm
#includecstring
#includecmath
#includequeue
#includestack
#includemap
#includecstdio
#define bug cout"-bug-"
#define endl "\n"
#define mem(a,b) memset(a,b,sizeof a)
using namespace std;
int n,m,sum[2005][2005],ans;
char a[2005][2005];
int main(){
	cinnm;
	for(int i=1;i=n;i++){
		for(int j=1;j=m;j++){
			cina[i][j];//输入 
			sum[i][j]=sum[i][j-1]+(a[i][j]=='#'?1:0);//前缀和 
		}
	}
	for(int i=1;i=n;i++){
		for(int j=1;j=m;j++){
			if(a[i][j]=='#'){//以a[i][j]为顶点的钻石 
				int cnt=0,flag=0;
				//上半部分 
				while(!(a[i+cnt+1][j-cnt+1]=='#'&&a[i+cnt+1][j+cnt-1]=='#'&&cnt0)){//如果#开始往里收缩，跳出上半部分 
					cnt++;
					if(a[i+cnt][j+cnt]!='#'||a[i+cnt][j-cnt]!='#'||sum[i+cnt][j+cnt-1]-sum[i+cnt][j-cnt]!=0){//不是一个钻石或者钻石里面有# 
						flag=1;//不是钻石 
						break;
					}
				}
				if(flag) continue;
				//下半部分 
				for(int k=1;k=cnt;k++){
					if(a[i+cnt+k][j+cnt-k]!='#'||a[i+cnt+k][j-cnt+k]!='#'||(sum[i+cnt+k][j+cnt-k-1]-sum[i+cnt+k][j-cnt+k]!=0&&j+cnt-k!=j-cnt+k)){
						//不是一个钻石或者钻石里面有# 注意！这里的最后一个点则不需要判断前缀和 
						flag=1;
						break;
					}
				}
				if(!flag) ans++;//是一个钻石，计数器加一 
			}
		}
	}
	coutans;//输出 
	return 0;
}
 	
```

---

## 作者：39xiemy (赞：0)

## 题目大意

现给出一个由 `.` 和 `#` 组成的矩阵，对于每一个形似菱形，边由 `#` 组成，内部由 `.` 组成的图形，统计其的个数。

## 分析

最开始想先枚举菱形大小，再枚举每个菱形的位置，最后判断是否合法。

但是这道题虽然是模拟，但数据比较大，这种做法，即使用了前缀和优化，也过不了，~~不算二维前缀和~~。

我们发现，对于一个菱形，最上方的 `#` 和最下方的 `#` 都在同一列内，而且菱形的行数是除了 $1$ 以外的奇数，所以可以枚举每一个 `#`，然后再在这个 `#` 的同一列的，从里枚举，如果为 `#`，就判断这以这两个 `#` 为顶点的菱形是否合法。

由于菱形内部不能有 `#`，对于上一步操作，如果枚举到了一个 `#`，就不用继续枚举了。这是因为，即使这个 `#` 的下面还有 $a$ 个 `#`，那么这 $a$ 个 `#` 分别与最上方的 `#` 所构成的菱形**一定包含枚举到的第一个** `#`，不符合要求。

要判断菱形的内部是否全部为 `.`，可以用一维前缀和来优化。另开一个数组，将 `#` 设置为 $1$，`.` 设置为 $0$，对于每一行来建立前缀和数组。判断完 `.`后，再判断两端是否为 `#` 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,ans,s[2002][2002];
char c[2002];
bool bj[2002][2002],bj2;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",c+1);
		for(int j=1;j<=m;j++)
		{
			if(c[j]=='#') bj[i][j]=1;
			s[i][j]=s[i][j-1]+bj[i][j]; //对每一行#的个数求前缀和
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(bj[i][j])
			{
				for(int g=i+2;g<=n;g+=2)//对于任意一点#，向下寻找对应的#，每一次+2
				{
					if(bj[g][j])
					{
						bj2=0,x=(g-i)/2+1;//x是从菱形的第一行到中间行的行数 
						for(int i2=i+1,f=1;i2<=i+x-1;i2++,f++)//推一下 
						{
							if(s[i2][j+f-1]-s[i2][j-f]||bj[i2][j+f]==0||bj[i2][j-f]==0) 
							{   //先用前缀和判断菱形内部有没有#，再判断两侧是否为# 
								bj2=1;
								break;
							}
						}
						if(bj2) break;
						for(int i2=i+x,f=i+2*x-3-i2;i2<=i+2*x-3;i2++,f--)//推一下 
						{
							if(s[i2][j+f]-s[i2][j-f-1]||bj[i2][j+f+1]==0||bj[i2][j-f-1]==0)
							{
								bj2=1;
								break;
							}
						}
						if(!bj2) ans++;
						break;
					}
				} 
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zzx0102 (赞：0)

这道题相当的简单，不知道为什么是黄，应该评橙啊！

**最暴力的题解**

既然这是一颗钻石他必须满足：

* 有一个”头顶“节点

* 有 $4$ 条斜边构成一个菱形状

* 菱形中间没有 `#`

~~那我们就把这些条件全判一遍不就 OK 了吗！~~

我们只需要枚举一个钻石头顶的节点，然后枚举大小，再搜一下是不是都有 `#`，还要判一遍钻石里面是不是都是 `.`，所以总复杂度是 $O(n^5)$，理论上 $20$ 分都没有，但是能 AC。（别问我为啥，反正就是能 AC）（反正什么不用前缀和优化，但需要卡下常数）

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[2005][2005];
int f(int i, int x, int y) {
	for(int j = x + 1; j < y; j++) {
		if(a[i][j] == '#') {
			return 2;
		}
	}
	if(a[i][x] == '#' && a[i][y] == '#') return 0;
	if(a[i][x] == '.' && a[i][y] == '.') return 1;
	return 2;
}
int main() {
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++) scanf("%s", a[i] + 1);
	int cnt = 0;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i][j] == '.') continue;
			for(int k = 1; k <= j; k++) {
				if(j + k > m) break;
				if(i + 2 * k > n) break;
				int flag = 0;
				for(int l = 0; l <= k; l++) {
					int op = f(i + l, j - l, j + l);
					if(op) {
						flag = op;
						break;
					}
				}
				if(flag == 1) continue;
				if(flag == 2) break;
				flag = 0;
				for(int l = 1; l <= k; l++) {
					int op = f(i + l + k, j - k + l, j + k - l);
					if(op) {
						flag = op;
						break;
					}
				}
				if(flag == 0) {
					cnt++;
					break;
				}
				if(flag == 2) break;
			}
		}
	}
	cout << cnt;
	return 0;
}
```

时效：590ms（要开 O2）

管理员一定要给过啊！~~管理员都是大帅哥~~

---


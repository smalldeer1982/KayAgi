# [COCI 2021/2022 #6] Zemljište

## 题目描述

有一块地，大小为 $r \times s$，$\rm Matej$ 想买下它。这块地每个 $1\times1$ 的正方形都有不同的价格。  

设一片非空子矩阵价格总和为 $m$，则这片子矩阵的权值为 $|m-a|+|m-b|$，您需要找到最小权值的子矩阵。  

您只需要输出最小权值即可。


## 说明/提示

### 样例解释 2  
![](https://cdn.luogu.com.cn/upload/image_hosting/2mzt4qih.png)

如图，总价格是$1 + 1 = 2$，这块地的权值是 $|3−2| + |4−2| =3$。

### 数据范围：

对于 $14\%$ 的数据：$1\le r,s\le20$

对于 $28\%$ 的数据：$1\le r,s\le100$

对于 $100\%$ 的数据：$1\le r,s\le500$，$1\le a,b,c_{i,j}\le10^9$

##### 本题分值与 [COCI 2021-2022#6](https://hsin.hr/coci/contest6_tasks.pdf) 分值相同，满分 $70$ 分

## 样例 #1

### 输入

```
2 2 10 10
1 3
4 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2 3 4
1 9
1 1
8 1```

### 输出

```
3```

## 样例 #3

### 输入

```
3 4 5 3
1 1 1 1
9 6 7 6
8 1 9 7
```

### 输出

```
2```

# 题解

## 作者：Suzt_ilymtics (赞：7)

 

题目要求很清楚不再赘述。

首先我们有一个 $\mathcal O(n^6)$ 的暴力，直接按照题意模拟，期望得分 $10$ 。

然后我们很自然的想到了使用二位前缀和，枚举所有的子矩阵进行一个贡献的统计。复杂度是 $\mathcal O(n^4)$，期望得分 $30$。

然后我们找一下这题有什么特殊的地方：

$1 \le c_{i,j} \le 10^9$。

也就是说，如果一个矩形是另一个矩形的子矩形，那么这个矩形肯定比另一个矩形的和小。

看起来和单调性有关。

那么，我们考虑枚举矩形的上边界，再枚举下边界，然后枚举左边界，那么右边界越向右整个矩阵的和越大，但是我们只想让这个和 $s$ 尽可能的接近 $[a,b]$ （这里设 $a\le b$）。

那么我们可以二分一个位置，我们可以找到 $<a$ 的最大的 $s$ 的位置和 $>b$ 的最小的 $s$ 的位置然后对答案取 $\min$（当然如果有 $s$ 满足 $a \le s \le b$，那么答案也就被确定为 $b-a$ 了）

但是这样我们的复杂度是 $\mathcal O(n^3 \log n)$ 的，依然不能通过。

发现我们二分的这个位置，随着固定的左端点右移，这个位置也不断右移，因此我们可以拿双指针从左向右扫一遍，并在扫的过程中对答案取 $\min$ 就好了。（顺便判断一下有无 $a \le s \le b$ 的情况）

这样复杂度是 $\mathcal O(n^3)$ 的，可以通过。

代码实现可以参考一下我的，但是我感觉还是理解后自己实现更为好写，~~因为我写的很丑~~。

```cpp
#include<bits/stdc++.h>
#define LL long long 
#define int long long
#define orz cout << "tyy YYDS!!!\n"
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 1e9 + 7;
const int mod = 998244353;

int read() {
    int s = 0, f = 0; char ch = getchar();
    while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return f ? -s : s;
}

int n, m, A, B;
int a[555][555];
int b[555];
int sum[555][555];

signed main() {
	n = read(), m = read(), A = read(), B = read();
	if(A > B) swap(A, B);
	for(register int i = 1; i <= n; ++i) {
		for(register int j = 1; j <= m; ++j) {
			a[i][j] = read();
			sum[i][j] = sum[i - 1][j] + a[i][j];
		}
	}
	int ans = abs(a[1][1] - A) + abs(a[1][1] - B);
	for(register int l = 1; l <= n; ++l) {
		for(register int r = l; r <= n; ++r) {
			for(register int i = 1; i <= m; ++i) b[i] = sum[r][i] - sum[l - 1][i];
			int R = 0, now = 0;
			while(R < m && now + b[R + 1] < A) now += b[++R];
			for(register int L = 1; L <= m; ++L) {
				if(R < m && now + b[R + 1] >= A && now + b[R + 1] <= B) return printf("%lld\n", B - A), 0;
				ans = min(ans, abs(now - A) + abs(now - B));
				now -= b[L];
				while(R < m && now + b[R + 1] <= A) now += b[++R];
			}
			R = 0, now = 0;
			while(R < m && now <= B) now += b[++R];
			for(register int L = 1; L <= m; ++L) {
				ans = min(ans, abs(now - A) + abs(now - B));
				now -= b[L];
				if(now >= A && now <= B) return printf("%lld\n", B - A), 0;
				while(R < m && now <= B) now += b[++R]; 
			}
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```



---

## 作者：LKY928261 (赞：5)

## 题目分析

简化题意：查找一个 $r\times s$ 的矩阵中的一块非空子矩阵，使得其价值和 $m$ 满足权值 $\left|m-a\right|+\left|m-b\right|$ 最小，并输出最小权值。

本题若采用纯暴力做法，则时间复杂度为 $O(n^4)$，必 ``TLE`` 无疑。而 $1\leq r,s\leq500$，因此只需优化时间复杂度为 $O(n^3)$ 即可通过。

因此，可以先枚举子矩阵最上端与最下端的行号，然后按列尺取。

设当前枚举到的子矩阵的价值是 $k$：

- 当 $k\leq b$ 时，说明 $k$ 不够大或刚刚好，将右端点右移，同时将 $k$ 增加相应的价值；

- 当 $k>b$ 时，说明此时 $k$ 过大，需将左端点右移，同时将 $k$ 减小相应的价值；

需要注意的是，必须要对原矩阵进行前缀和优化，否则时间复杂度会退化为 $O(n^4)$。因为是按列进行尺取法，所以对每一列进行一维的前缀和即可。

按这个方法写出来的代码刚好是卡着时限过的。

当然，在 $a\leq k\leq b$ 时，$\left|k-a\right|+\left|k-b\right|$ 能够取得最小值 $b-a$，因此可以直接输出 $b-a$ 并结束程序。

## 参考代码

本人的代码非常精简，欢迎借(chao)鉴(xi)。

~~（请不要在意我奇丑无比的码风）~~

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,x,y,s=2e9,t,a[505][505],i,j,l,r;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m>>x>>y;
	for(i=1;i<=n;i++)for(j=1;j<=m;j++){cin>>a[i][j];a[i][j]+=a[i-1][j];}
	//读入+按列进行前缀和
	for(i=1;i<=n;i++)for(j=i;j<=n;j++){//枚举行
		for(t=0,l=r=1;r<=m;){//按列尺取法
			while(l<r&&t>y)t-=a[j][l]-a[i-1][l],s=min(s,abs(t-x)+abs(t-y)),l++;
			if(t>=x&&t<=y){cout<<y-x<<"\n";return 0;}
			while(r<=m&&t<=y)t+=a[j][r]-a[i-1][r],s=min(s,abs(t-x)+abs(t-y)),r++;
		}
		while(l<=m)t-=a[j][l]-a[i-1][l],s=min(s,abs(t-x)+abs(t-y)),l++;
	}
	cout<<s<<"\n";
}
```

---

## 作者：Cypher_404 (赞：4)

# 题解：P8343 [COCI2021-2022#6] Zemljište

前情提要：这是一篇不那么正经的题解。

提示：本题解需要在：`C++98 -O2` 的环境下提交才能 AC。

## 题意分析

题意过于清楚，先不放了。

## 做法分析

先从最暴力的暴力看起：

$O(n^4)$ 的外层循环+暴力累加。（包 TLE 的，不 T 我吃）。

但是我们很好想到一个优化：[二维前缀和（别人的博客）](https://blog.csdn.net/m0_65998513/article/details/132534198)

这样就可以做到 $O(n^2)$ 预处理，$O(1)$ 查询，复杂度 $O(n^4)$。

但是还是 TLE，怎么办？

~~双指针！！！~~。咳咳，本题解不涉及最正解的正解。

我们选择卡时间！

~~感谢 @xuan_gong_dong 的猜想。~~

竟然出题人知道我们要正着枚举，那我们偏不，盲猜一手最小值在右下角，反着遍历。

（考虑到出题人想让我们正着枚举卡掉我们，那我们充分发扬人类智慧考虑如何不正着枚举不被卡掉）

设置变量 tot 用于计算当前处理了多少次计算操作，考虑到时限 $2s$ 当 $tot > 2.3\times 10^8$ 时退出。并进行最优性剪枝。

用时：$1.33s$ [提交记录](https://www.luogu.com.cn/record/176566523)

## 上代码

```cpp
#include<bits/stdc++.h>//C++98 -O2！！！
using namespace std;
template< typename T > inline void read(T &x)
{
    char c=getchar();x=0;bool f=0;
    for(;!isdigit(c);c=getchar()) f|=(c=='-');
    for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
    x=f?-x:x;
}
int n,m,q,p;
int a[1010][1010];
long long sum[1010][1010];
long long get(int x,int y,int xx,int yy)//得到前缀和
{
	if(x<=xx&&y<=yy)
	{
		swap(x,xx);
		swap(y,yy);
	}
	return sum[x][y]-sum[x][yy-1]-sum[xx-1][y]+sum[xx-1][yy-1];
}
long long calc(int x,int y,int xx,int yy)//计算答案
{
	long long k=get(x,y,xx,yy);
	return abs(k-q)+abs(k-p);
}
int main()
{
	cin>>n>>m>>q>>p;
	if(p>q)
	{
		swap(q,p);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[j][i]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			sum[j][i]=sum[j][i-1]+sum[j-1][i]-sum[j-1][i-1]+a[j][i];
		}
	}
	long long minn=INT_MAX;
	int tot=0;
	for(int i=n;i>=1;i--)
	{
		for(int j=m;j>=1;j--)
		{
			for(int k=i;k>=1;k--)
			{
				for(int l=j;l>=1;l--)
				{
					minn=min(minn,calc(j,i,l,k));
					tot++;
					int z=get(j,i,l,k);
					if(z>=q&&z<=p)//剪枝
					{
						minn=q-p;
						cout<<q-p;
						return 0;
					}
					if(tot>230000000)//随机化退出
					{
						cout<<minn;
						return 0;
					}
					if(z>q)//剪枝
					{
						break;
					}
				}
			}
		}
	}
	cout<<minn;
	return 0;
}
```

感谢你能看到这里 qwq。

---

## 作者：CuSO4_and_5H2O (赞：2)

本题解不讲思路，就是讲一个先前题解都没有说明过的的一个很玄学（？）的一句话（困扰我一个多小时）。

（如果不会思路就去看楼下大佬的）。

`	if(l >= 2) ans = min(ans, abs(qj[r]-qj[l-2]-A)+abs(qj[r]-qj[l-2]-B));`

为什么要加这一句话？

思考一下你的双指针（默认 $A<B$）：

`while(l<r && B<qj[r]-qj[l-1]) l++;`

这句话不能保证这个区间的总和在 $A$ 和 $B$ 之间，可能比 $A$ 小（减去的太大了），所以可能不如之前优秀，所以要判断一下如果没有 `l++` 会不会比之前更加优秀。

为什么只用判断一次？

因为如果出现小于 $A$ 的情况那么上次和上上次必然是大于 $B$ 的，那上上次必然比上次差（数轴理解一下）。

为了方便理解，我拍了一组数据，但是因为小数据拍了三四个小时都没拍出差异来，就只能放拍到现在为止最好看的一组了:

```
1 5 25 23
3 54 98 10 16 


正确输出 4
错误 16
```

---

## 作者：ZepX_D (赞：2)

## 题意
给出一个大小为 $ r \times s $ 的矩阵，每一个非空子矩阵各个元素之和为 $ s $ ，它的权值为 $ |s-a| + |s-b| $ ，求出最小的权值。

## 分析
首先想到的是二维前缀和，枚举左上角和右下角，但时间复杂度为 $ O ( n^4 ) $ ， $ n $ 最大为 $ 500 $ ，显然过不了，得分 $ 30 $ 。
然后考虑优化，数学老师说过：绝对值要分情况讨论。然后可以推得式子（这里默认 $ a<=b $ ）

$ s<a<b $ 权值为 $ a+b-2\times s $

$ a ≤ s ≤ b $ 权值为 $ b-a $

$ a<b<s $ 权值为 $ 2\times s-a-b $

可以发现

当 $ s<a<b $ 时，$ s $ 越大权值越小。

当 $ a≤s≤b $ 时，权值为定值。

当 $ a<b<s $ 时，$ s $ 越小权值越小。

那么，因为一个矩阵的和是要比他的任一子矩阵的和要大的，那么我们就可以剪枝了。

我们可以默认为右下角的坐标即为 $ (r,s) $ ，只枚举左上角，然后向右下角遍历，
当 $ s >a $ 时，往后枚举的权值只会比当前记录的最小值要大，所以我们直接跳出循环，但是现在还是不够，当 $ a $ 非常大的时候，我们还是得跑完 $ O(n^4) $ ，所以我们可以加一个判断，当前矩阵的一半的和小于 $ a $ 的话，那我们就从右下角向左上角遍历就好了, $ s<b $ 时，后面的权值只会更大，所以跳出循环 。

## 代码
```cpp
#include<cstdio>
#include<cctype>
#include<iostream>
#include<cmath>
#define re register

using namespace std;

inline int read()
{
	int x=0;
	char ch=getchar();
	while(!isdigit(ch))
		ch=getchar();
	while(isdigit(ch))
	{
		x=x*10+ch-48;
		ch=getchar();
	}
	return x;
}

int c[510][510],r,s,a,b;
long long q[510][510],ans=1e13,sum;

long long w(long long x)
{
	return abs(x-a)+abs(x-b);
}

long long gsum(int i,int j,int x,int y)
{
	return q[x][y]-q[i-1][y]-q[x][j-1]+q[i-1][j-1];
}

int main()
{

	if (a>b) swap(a,b);
	scanf("%d%d%d%d",&r,&s,&a,&b);
	for (re int i=1;i<=r;i++)
	{
		for (re int j=1;j<=s;j++)
		{
			c[i][j]=read();
			q[i][j]=q[i-1][j]+q[i][j-1]-q[i-1][j-1]+c[i][j];
		}
	}
	for (re int i=1;i<=r;i++)
	{
		for (re int j=1;j<=s;j++)
		{
			int mid=(i+r)>>1;
			long long g=gsum(i,j,mid,s);
			if (g>=a)
			{
				for (re int m=i;m<=r;m++)
				{
					for (re int n=j;n<=s;n++)
					{
						sum=gsum(i,j,m,n);
						ans=min(ans,w(sum));
						if (sum>a) break;
					}
				}
			}
			else
			{
				for (re int m=r;m>=i;m--)
				{
					for (re int n=s;n>=j;n--)
					{
						sum=gsum(i,j,m,n);
						ans=min(ans,w(sum));
						if (sum<b) break;
					}
				}
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：cfkk (赞：2)

前置芝士：双指针，前缀和。

### 题目大意：
给你一个 $r×s$ 的矩阵，每个 $1×1$ 的矩阵都有对应的权值。现在想让你选择一个 $x×y$ 的矩形，是的矩形中所有权值的和与 $a$ 和 $b$ 的绝对值最小。

首先，我们假设 $a\le b$。

我们首先要确定选择的矩阵的第一行还是最后一行。现在的目标是确定子矩阵的最佳左、右列。由于行已经固定，所以在选择列时，我们将只选择两端行的单元格。因此，使用前缀和，我们可以为每一列计算该列中两行之间所有子矩阵的和。那么问题就变成了：给定一个数列，确定哪个区间的和最接近 $a$ 和 $b$ 。

这个问题可以使用双指针方法来解决。我们将使用两个指针(数组下标) `l=1,r=n` 。

当子矩阵的和小于 $a$ 时，我们将指针 `r++` ，对于这个和，我们将检验它是否是最优的。然后，我们将指针 `l++` 并再次再次更新 `r++` 直到与 $a$ 和 $b$ 的差值最小。


每个指针将被移动总共 $n$ 次，因此算法的总时间复杂度是  $O(n^3)$ 。

代码来喽（小心被棕）：
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int INF_int = 0x3f3f3f3f;
const ll INF = (ll)INF_int * INF_int;
const int N=505;

int n, m, A, B;
int mat[N][N];
ll red[N][N], pref[N];

ll f(ll x) {
    return abs(x-A) + abs(x-B);
}

void solve() {
    if (A > B) swap(A, B);

    ll sol = INF;
    for (int j1=1; j1<=m; ++j1) {
        for (int j2=j1; j2<=m; ++j2) {
            for (int i=1; i<=n; ++i) pref[i]=pref[i-1] + red[i][j2] - red[i][j1-1];
            pref[n+2] = pref[n+1] = pref[n];

            int l=0;
            for (int i=1; i<=n; ++i) {
                while (pref[i] - pref[l] > B) ++l;

                sol = min(sol, f(pref[i] - pref[l]));
                if (l) sol = min(sol, f(pref[i] - pref[l - 1]));
            }
        }
    }
    printf("%lld\n", sol);
}

void load() {
    scanf("%d %d %d %d", &n, &m, &A, &B);
    for (int i=1; i<=n; ++i) {
        for (int j=1; j<=m; ++j) {
            scanf("%d", &mat[i][j]);
            red[i][j] = red[i][j-1] + mat[i][j];
        }
    }
}

int main() {
    load();
    solve();
    return 0;
}

```



---

## 作者：guer_loser_lcz (赞：0)

# 题解
注：该题解运用剪枝。
## 四次方方法
前缀和预处理，然后暴力枚举矩形的左上角和右下角。

预计得分：通过前两个子任务。
## 剪枝
设 $m$ 为矩阵总和，默认 $a \le b$。

首先，当 $a \le m$ 且 $m \le b$ 时，直接输出 $a - b$。

（初中绝对值芝士，易证）

其次，当 $m > b$ 时，直接跳过，因为再枚举值只会变大，不会变小。

至此，已经可以通过本题数据。

但是，当矩阵最大且全为一时，会卡爆这个程序。

所以，可以加入一个判断来规避。

（代码中并不包含）

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a,b,mp[510][510],sum[510][510],ans=2e9;//不开longlong见祖宗
int main(){
	cin>>n>>m;
	cin>>a>>b;
	if(a>b)swap(a,b);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			ans=min(ans,abs(mp[i][j]-a)+abs(mp[i][j]-b));
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mp[i][j];//前缀和
		}
	}
	for(int a1=1;a1<=n;a1++){
		for(int a2=1;a2<=m;a2++){
			for(int x=a1;x<=n;x++){
				for(int y=a2;y<=m;y++){
					long long k=sum[x][y]+sum[a1-1][a2-1]-sum[x][a2-1]-sum[a1-1][y];
//					cout<<a1<<" "<<a2<<" "<<x<<" "<<y<<endl;
//					cout<<k<<endl;
					if(k>=a&&k<=b){
						cout<<b-a;
						return 0;
					}//剪枝
					if((abs(k-a)+abs(k-b))<ans)ans=(abs(k-a)+abs(k-b));
					if(k>a&&k>b)break;//剪枝
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Cells (赞：0)

#### 前置知识

1. 二维前缀和。
2. 双指针。

#### 暴力

先预处理出二维前缀和（不会出门左转激光炸弹），再枚举矩形的左上角，右下角。

时间复杂度：$O(n^4)$。

考场写的，被毒瘤数据卡成 28 分。

#### 正解

假定 $a \leq b$，根据初中数学，这种 $|m-a|+|m-b|$ 的东西，只要 $m$ 满足 $a \leq m \leq b$，那么这个值就是最小的。

我们发现，如果有一些价值 $val < a$ 或者是 $b < val$，那么相应的，我们应该努力去将 $val$ 增大和缩小。

1. 枚举矩形的上边的行数，下边的行数。

2. 用双指针，一旦 $val < a$，$r$ 向右移，反之 $val > b$，$l$ 向右移。

3. 边移动边记录答案。

![图解](https://cdn.luogu.com.cn/upload/image_hosting/7bf07pp2.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**Code**

```c++
# include <bits/stdc++.h>
# define y1 yy//y1毒瘤关键字 
using namespace std;

typedef long long LL;

const int N = 5e2 + 10;

int n, m, a, b;
LL ans, val, s[N][N];//不开LL见…… 

LL calc(int x1, int y1, int x2, int y2){//计算矩形的价值 
	return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	ans = LLONG_MAX;
	cin >> n >> m >> a >> b;
	if(a > b) swap(a, b);//我们假设的条件 
	
	for(int i = 1, x; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			cin >> x;
			s[i][j] = x + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];//二维前缀和 
		}
	}
	
	for(int i = 1; i <= n; i ++){
		for(int j = i; j <= n; j ++){
			int l = 1, r = 1;
			
			while(r <= m){
				val = calc(i, l, j, r);
				ans = min(ans, abs(val - a) + abs(b - val));//更新答案 
				if(val > b) l ++;
				else r ++;
			} 
		}
	}
	
	cout << ans;
	
	return 0;
}
```

#### 其他技巧

不管是什么考试，并没有说明不能用包括卡时，随机等奇技淫巧，所以卡时完全可以过。

另外，因为 `clock()` 函数的常数巨大，所以建议写卡时的时侯每枚举几百次再算时间，这也不妨是一个~~骗分~~小技巧。

**完结撒花！！！**

---

## 作者：xuan_gong_dong (赞：0)

## 题面

[P8343 [COCI2021-2022#6] Zemljište](https://www.luogu.com.cn/problem/P8343)

## 分析

本题解使用时间复杂度 $O(n^4)$ 的纯暴力。

加一点剪枝：

- 从当前节点向左向上看矩阵是否最优，如果当前矩阵已经超过 $a$ 和 $b$ 了，就没必要再往上往左扩大矩阵了。

- 如果当前代码用时间超过 $1.95s$，就输出当前计算出来的最小值。
- 因为调用 `clock()` 函数常数极大，所以没必要经常判断是否超过 $1.95s$，我调的参数是 $100$ 次操作判断时间是否超时。
- 上述操作之后还是没过，直接豪赌答案矩阵在整个图右下角，枚举矩阵的时候倒序枚举。

该代码当然很容易被卡掉，但同时我可以通过此题也是体现了我的实力。

 ## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int r,s;
int m[510][510];
int a,b;
int pre[510][510];
int Min=1e18;
signed main()
{
	scanf("%lld%lld%lld%lld",&r,&s,&a,&b);
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=s;j++)
		{
			scanf("%lld",&m[i][j]);
			Min=min(Min,abs(m[i][j]-a)+abs(m[i][j]-b));	
		}
	}
	for(int i=1;i<=r;i++)
		for(int j=1;j<=s;j++)
			pre[i][j]=pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]+m[i][j];
	int tmp=0;
	for(int i=r;i>=1;i--)
	{
		for(int j=s;j>=1;j--)
		{
			for(int ii=i;ii>=0;ii--)
			{
				for(int jj=j;jj>=0;jj--)
				{
					int sum=pre[i][j]-pre[i][jj]-pre[ii][j]+pre[ii][jj];
					if(ii==i)
						sum=pre[i][j]-pre[i][jj];
					if(jj==j)
						sum=pre[i][j]-pre[i][jj];
                    // sum算答案
					Min=min(Min,abs(sum-a)+abs(sum-b));
					tmp++;
					if(tmp%100==0)
					if(double(clock())/(double){CLOCKS_PER_SEC}>1.95)//如果用时间超过1.95s直接输出。
					{
						printf("%lld",Min);
						return 0;
					}		
					if(sum>a&&sum>b)break;//剪枝再往后的答案包不是最优的。
				}
			}
		}
	}
	cout<<Min;
	return 0;
}
```

---

## 作者：JimmyLee (赞：0)

# 题意

> 给定一个 $r\times s$ 的矩阵，每个点给定一个权值，要求求出一个子矩阵，其权值和为 $w$，使 $|w-a|+|w-b|$ 最小。

# 分析

考虑枚举子矩阵。

首先预处理二维前缀和用于快速计算矩阵和。

可以暴力枚举左上角 $(x_1, y_1)$ 和右下角 $(x_2, y_2)$，这个做法是 $O(n^4)$ 的，显然一般情况下不能通过本题。

---

因为每个点的权值都大于 $0$，所以显然一个确定了 $x_1, x_2, y_1$ 矩阵的权值随 $y_2$ 的递增而单调递增。

考虑枚举 $x_1, x_2$，在确定 $x_1, x_2$ 后用双指针移动 $y_1, y_2$ 求出权值小于等于 $\max(a,b)$ 的最大权值的矩阵以及权值大于 $\max(a,b)$ 的最小权值的矩阵，用它们的权值更新答案。

这时时间复杂度下降至 $O(n^3)$，可以通过本题。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 505

int64_t va[maxn][maxn];

#define query(x1, y1, x2, y2) (va[x2][y2]-va[x2][y1-1]-va[x1-1][y2]+va[x1-1][y1-1])

int main()
{
    int n, m, a, b;
    cin>>n>>m>>a>>b;
    if(a>b) swap(a, b);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>va[i][j];
    for(int i=1;i<=n+1;i++)
        for(int j=1;j<=m+1;j++)
            va[i][j]+=va[i-1][j]+va[i][j-1]-va[i-1][j-1];
    int64_t ans=0x7fffffff;
    for(int l=1;l<=n;l++)
        for(int r=l;r<=n;r++)
            for(int x=1, y=1;x<=m;x++)
            {
                if(y<x) y=x;
                while(y+1<=m&&query(l, x, r, y+1)<=b) y++;
                int64_t v=query(l, x, r, y);
                ans=min(ans, abs(a-v)+abs(b-v));
                v=query(l, x, r, y+1);
                ans=min(ans, abs(a-v)+abs(b-v));
            }
    cout<<ans;
}
```

---

## 作者：DFM_O (赞：0)

## [P8343 题目](https://www.luogu.com.cn/problem/P8343)

### 解题思路
不难想到可以用二维前缀和做，枚举子矩阵的左上角 $(x_1,y_1)$ 和右下角 $(x_2,y_2)$，但是时间复杂度会达到 $O(n^4)$，会超限，所以要考虑优化。

以下的推理默认 $a\le b$。

学过绝对值的几何意义的都知道，当 $m<a$ 时，$a-m$ 越小，$|m-a|+|m-b|$ 越小，当 $a\le m\le b$ 时，$|m-a|+|m-b|$ 有最小值，为 $|a-b|$，当 $m>b$ 时，$m-b$ 越大，$|m-a|+|m-b|$ 越大。

所以当我们确定 $x_1,y_1,x_2$ 的值，从小到大枚举 $y_2$ 时，若前一个矩阵的权值比当前的矩阵的权值小，则当前的矩阵的 $m$ 的值一定大于 $b$ 且后面的矩阵的 $m$ 的值一定会更大，那么就没有再枚举的必要了，直接跳出循环并开始下一轮枚举即可。

但是把代码提交之后，我们发现还是会 TLE $4$ 个点，所以需要更进一步的优化，在前面我们说过，$|m-a|+|m-b|$ 的最小值为 $|a-b|$，所以当我们在枚举过程中发现当前矩阵的权值为 $|a-b|$ 时，直接输出 $|a-b|$ 并结束程序即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int c[501][501],s[501][501];
signed main()
{
	ios::sync_with_stdio(false);
	int n,m,a,b;
	cin>>n>>m>>a>>b;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			cin>>c[i][j];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(i==1)
			{
				s[i][j]=s[i][j-1]+c[i][j];
				continue;
			}
			if(j==1)
			{
				s[i][j]=s[i-1][j]+c[i][j];
				continue;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+c[i][j];
		}
	}
	int minn=LLONG_MAX,lmin=abs(a-b);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=i;k<=n;k++)
			{
				int sh=LLONG_MAX;
				for(int l=j;l<=m;l++)
				{
					int ss=s[k][l]-s[i-1][l]-s[k][j-1]+s[i-1][j-1];
					int x=abs(ss-a)+abs(ss-b);
					if(sh<x)
						break;
					sh=x,minn=min(minn,x);
					if(minn==lmin)
					{
						cout<<minn;
						return 0;
					}
				}
			}
		}
	}
	cout<<minn;
	return 0;
}
/*
hack:

Right Answer:

Wrong Answer:

*/
```

---

## 作者：allqpsi (赞：0)

### 题意：

这道题大意为：找出一个矩阵，让其中的和与两个数的差的和最小。好了，讲了题意，现在直奔主题。

### 思路：

- #### 做法一：暴力！（~~怎么想也过不了~~~~~）很快发现，会爆掉。

- #### 做法二：前缀和，稍稍优化了点，可是还是会爆。

- #### 做法三：正解！用双指针，与做法二结合，就可以过啦！

我们可以枚举矩阵从第几列到第几列。再以 $l$ $r$ 表示从第 $l$ 行到第 $r$行。

如果这个矩阵的和大于等于 $y$ 我们将 $l$ 右移，反之我们将 $r$ 右移。这样维护双指针，同时也计算此矩阵的和。再比较每一个和与两个数的差的和。得出最终答案。

最后，注意不开 long long 见祖宗！

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a,b,sum[505][505],vi[505][505],l,r,summ,ans=999999999999999;
signed main(){
	cin>>n>>m>>a>>b;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>vi[i][j];
			sum[i][j]=sum[i][j-1]+vi[i][j];
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=i;j<=m;j++){
			l=r=1;
			summ=0;
			while(r<=n){
				while(l<r&&summ>b){
					summ-=sum[l][j]-sum[l][i-1];
					ans=min(ans,abs(summ-a)+abs(summ-b));
					l++;
				}
				if(summ>=a&&summ<=b){
					cout<<b-a;
					return 0;
				}
				while(r<=n&&summ<=b){
					summ+=sum[r][j]-sum[r][i-1];
					ans=min(ans,abs(summ-a)+abs(summ-b));
					r++;
				}
			}
			while(l<=n){
				summ-=sum[l][j]-sum[l][i-1];
				ans=min(ans,abs(summ-a)+abs(summ-b));
				l++;
			}
		}
	}
	cout<<ans;
}
```

~~此人是蒟蒻，有错欢迎指出。~~

---

## 作者：xiaolu12356 (赞：0)

[P8343 [COCI2021-2022#6] Zemljište](https://www.luogu.com.cn/problem/P8343)

## 题解

题目要求很清楚不再赘述。

首先我们有一个 $O(n^6)$ 的暴力，直接按照题意模拟，期望得分 
$10$ 分。

然后我们很自然的想到了使用二位前缀和，枚举所有的子矩阵进行一个贡献的统计。复杂度是 $O(n^4)$，期望得分 $30$ 分。

然后我们找一下这题有什么特殊的地方：

$1 \le c_i,j \le 10^9$。

也就是说，如果一个矩形是另一个矩形的子矩形，那么这个矩形肯定比另一个矩形的和小。

看起来和单调性有关。

那么，我们考虑枚举矩形的上边界，再枚举下边界，然后枚举左边界，那么右边界越向右整个矩阵的和越大，但是我们只想让这个和 $s$ 尽可能的接近 $[a,b]$（这里设 $a \le b$）。

那么我们可以二分一个位置，我们可以找到 $< a$ 的最大的 $s$ 的位置和 $> b$ 的最小的 $s$ 的位置然后对答案取 $\min$（当然如果有 $s$ 满足 $a \le s \le b$，那么答案也就被确定为 $b - a$ 了）

但是这样我们的复杂度是 $O(n^3 \log n)$ 的，依然不能通过。

发现我们二分的这个位置，随着固定的左端点右移，这个位置也不断右移，因此我们可以拿双指针从左向右扫一遍，并在扫的过程中对答案取 $\min$ 就好了。（顺便判断一下有无 $a \le s \le b$ 的情况）

这样复杂度是 $O(n^3)$ 的，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
#define LL long long 
#define int long long
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 1e9 + 7;
const int mod = 998244353;

int read() {
    int s = 0, f = 0; char ch = getchar();
    while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return f ? -s : s;
}

int n, m, A, B;
int a[555][555];
int b[555];
int sum[555][555];

signed main() {
	n = read(), m = read(), A = read(), B = read();
	if(A > B) swap(A, B);
	for(register int i = 1; i <= n; ++i) {
		for(register int j = 1; j <= m; ++j) {
			a[i][j] = read();
			sum[i][j] = sum[i - 1][j] + a[i][j];
		}
	}
	int ans = abs(a[1][1] - A) + abs(a[1][1] - B);
	for(register int l = 1; l <= n; ++l) {
		for(register int r = l; r <= n; ++r) {
			for(register int i = 1; i <= m; ++i) b[i] = sum[r][i] - sum[l - 1][i];
			int R = 0, now = 0;
			while(R < m && now + b[R + 1] < A) now += b[++R];
			for(register int L = 1; L <= m; ++L) {
				if(R < m && now + b[R + 1] >= A && now + b[R + 1] <= B) return printf("%lld\n", B - A), 0;
				ans = min(ans, abs(now - A) + abs(now - B));
				now -= b[L];
				while(R < m && now + b[R + 1] <= A) now += b[++R];
			}
			R = 0, now = 0;
			while(R < m && now <= B) now += b[++R];
			for(register int L = 1; L <= m; ++L) {
				ans = min(ans, abs(now - A) + abs(now - B));
				now -= b[L];
				if(now >= A && now <= B) return printf("%lld\n", B - A), 0;
				while(R < m && now <= B) now += b[++R]; 
			}
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

蒟蒻的第四篇题解，管理员求过！

---


# 「GLR-R3」立春

## 题目背景

&emsp;&emsp;「从此雪消风自软，梅花合让柳条新」

---

&emsp;&emsp;“明天就要返校了呢。”

&emsp;&emsp;灰色的长发被身后的人儿慢慢地顺着，顺着，于假期最后一个慵懒的清晨醒来，与春日的第一抹阳光迷迷糊糊地耳语，她的目光随着点过窗外的鸟雀，停留在那丛褐色的光秃枝丫。

&emsp;&emsp;“天依？”

&emsp;&emsp;赤红色的眸子随之望去，片刻，静默。

&emsp;&emsp;“如果我能告诉它，今天是立春，是春天的……”

&emsp;&emsp;“那么它会抽芽，繁盛，会成为我们窗外或红或绿的美妙。”

&emsp;&emsp;“——因为它本该如此，希望如此吧。”

---

&emsp;&emsp;**立春**&emsp;「雏鸟站在悬崖上　展开了翅膀　地平线上的梦想　照进一缕光」


## 题目描述

由于天依刚睡醒，害怕第一题的题面就迷糊了大家，所以本题只有简要题意。~~（其实是实在编不下去了。）~~

设 $\sigma$ 为任意一个长度为 $n$ 的排列，$\tau(\sigma)$ 表示其中的逆序对个数，请求出

$$
\sum_\sigma 2^{\tau(\sigma)}
$$

对 $(10^9+7)$ 取模的结果。

## 说明/提示

#### 题意解释

本节为部分选手介绍**逆序对的定义**，对此熟悉的选手可以跳过本节。

对于长度为 $n$ 的排列 $\sigma$，假设下标从 $1$ 开始，那么我们称 $(i,j)$ 构成逆序对，当且仅当 $1\le i<j\le n$，并且 $\sigma_i>\sigma_j$；$\tau(\sigma)$ 则表示总共有多少对不同的 $(i,j)$ 满足上述条件。

举个例子，对于排列 $\sigma=\lang 2,4,1,3\rang$，有逆序对 $(1,3),(2,3),(2,4)$，所以 $\tau(\sigma)=3$。可见只要 $\sigma$ 中元素的大小关系确定，$\tau(\sigma)$ 就是确定的。

#### 样例 #1 解释

$$
\begin{aligned}
\sum_{\sigma}2^{\tau(\sigma)} &= 2^{\tau(\lang 1,2,3\rang)}+2^{\tau(\lang 1,3,2\rang)}+2^{\tau(\lang 2,1,3\rang)}+2^{\tau(\lang 2,3,1\rang)}+2^{\tau(\lang 3,1,2\rang)}+2^{\tau(\lang 3,2,1\rang)}\\
&= 2^0+2^1+2^1+2^2+2^2+2^3\\
&= 21.
\end{aligned}
$$

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

| 子任务编号 |    $n$    | 分值 |
| :--------: | :-------: | :--: |
|    $1$     |  $\le4$   | $5$  |
|    $2$     |  $\le10$  | $20$ |
|    $3$     | $\le100$  | $20$ |
|    $4$     | $\le10^3$ | $25$ |
|    $5$     | $\le10^7$ | $30$ |



## 样例 #1

### 输入

```
3```

### 输出

```
21```

# 题解

## 作者：Rainybunny (赞：14)

# $\mathscr{Description}$

&emsp;&emsp;[Link](). (It's empty temporarily.)

&emsp;&emsp;给定 $n$，设 $\sigma$ 为长度为 $n$ 的排列，求
$$
\sum_{\sigma}2^{\tau(\sigma)}\bmod (10^9+7).
$$
&emsp;&emsp;$n\le10^7$。

# $\mathscr{Solution}$

&emsp;&emsp;简化一个巨难的 idea，得到了 T1 qwq。

## $\mathscr{Subtasks}$

&emsp;&emsp;**Subtask 1**&emsp;考察选手动手能力，并借此鼓励选手 OEIS。（

&emsp;&emsp;**Subtask 2**&emsp;考察 `std::next_permutation` 的使用，并借此让选手笃定 OEIS 结果。（

&emsp;&emsp;**Subtask 3**&emsp;献给 $\mathcal O(n^4)\sim\mathcal O(n^3)$ 的解法，暂时没想到合情合理的暴力。

&emsp;&emsp;**Subtask 4**&emsp;献给朴素的 $\mathcal O(n^2)$ DP。

&emsp;&emsp;**Subtask 5**&emsp;献给正解，献给所有参赛选手。

## $\mathscr{Body}$

&emsp;&emsp;其实它是 [A005329](http://oeis.org/A005329)，但因为是 T1 所以就不要在意细节了 awa。

&emsp;&emsp;考虑 DP，令 $f(i)$ 表示 $n=i$ 时的答案。对于转移，发现 $\sigma[2:]$（下标从 $1$ 开始，这里指从 $\sigma_2$ 开始的后缀） 对应了 $n-1$ 的子问题。也就是说，若 $\sigma_1$ 固定，所有 $\sigma[2:]$ 的答案之和为 $f(i-1)$，与 $\sigma$ 具体取值无关。接着，枚举 $\sigma_1$ 的值，与 $\sigma_1$ 构成的逆序对数可以轻易算出，因此得到转移：
$$
f(i)=\sum_{\sigma_1=1}^i2^{\sigma_1-1}f(i-1).
$$
进一步，从 $\mathcal O(n^2)$ 到 $\mathcal O(n)$ 仅需将和式化为等比数列求和，有：
$$
f(i)=(2^i-1)f(i-1).
$$
于是，答案 $f(n)$ 即是
$$
\prod_{i=1}^n(2^i-1).
$$
&emsp;&emsp;如果有花里胡哨爱好者, 可以快速 $q-$ 阶乘求 $[n]_q!$ 在 $q=2$ 处的值, $\mathcal O(\sqrt n\log n)$.

## $\mathscr{Code}$

```cpp
/*+Rainybunny+*/

#include <bits/stdc++.h>

const int MOD = 1e9 + 7;

int main() {
    int n, ans = 1, pwr = 1;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        (pwr <<= 1) >= MOD && (pwr -= MOD);
        ans = ans * (pwr - 1ll) % MOD;
    }
    printf("%d\n", ans);
    return 0;
}

```


---

## 作者：NaCly_Fish (赞：10)

[题目链接](https://www.luogu.com.cn/problem/P8474)

考虑计量长度为 $n$、有 $k$ 个逆序对的排列。对 $k$ 建立生成函数得到：
$$f(x)=\prod_{i=1}^n \frac{1-x^i}{1-x}$$
答案即为 $f(2)$，直接计算可以做到 $\Theta(n)$ 的时间复杂度，但不够优秀，考虑分块优化。

$$f(2)=\prod_{i=1}^n(2^i-1)=\prod_{i=0}^{n/B-1}\prod_{j=1}^B(2^{iB+j}-1)$$
设
$$g_B(x)=\prod_{j=1}^B(2^jx-1)$$
$g_B(x)$ 的系数是可以在 $\Theta(B \log B)$ 的时间复杂度内求出的，只需要注意到 $g_{2B}(x)=g_B(x)g_B(2^Bx)$ 就可以倍增计算。

最后我们需要求出
$$\prod_{i=0}^{n/B-1}g_B((2^B)^i)$$
可以使用 Chirp Z-Transform 来计算 $g(c^i)$ 的值。令 $B = \sqrt n$，则总时间复杂度为 $\Theta(\sqrt n \log n)$。

参考代码如下，还是很好写的（实在不想写任意模，所以此处答案是模 $998244353$）：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 262147
#define ll long long
#define p 998244353
using namespace std;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int siz;
int rev[N],rt[N];

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = power(3,(p-1)>>siz);
    rt[lim>>1] = 1;
    for(int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void dft(int *f,int n){
    static unsigned long long a[N];
    int x,shift = siz-__builtin_ctz(n);
    for(int i=0;i!=n;++i) a[rev[i]>>shift] = f[i];
    for(int mid=1;mid!=n;mid<<=1)
    for(int j=0;j!=n;j+=(mid<<1))
    for(int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(int i=0;i!=n;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int n){
    reverse(f+1,f+n);
    dft(f,n);
    int x = p-((p-1)>>__builtin_ctz(n));
    for(int i=0;i!=n;++i) f[i] = (ll)f[i]*x%p;
}

void getpoly(int q,int n,int *r){
    static int f[N],g[N],st[30];
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    n = st[top--];
    f[0] = p-1,f[1] = q;
    while(top--){
        while(lim<=(n<<1)) lim <<= 1;
        int pw = power(q,n),s = 1;
        for(int i=0;i<=n;++i){
            g[i] = (ll)f[i]*s%p;
            s = (ll)s*pw%p;
        }
        memset(f+n+1,0,(lim-n)<<2);
        memset(g+n+1,0,(lim-n)<<2);
        dft(f,lim),dft(g,lim);
        for(int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
        idft(f,lim);
        n <<= 1;
        if(n==st[top+1]) continue;
        s = power(q,n+1);
        f[n+1] = 0;
        for(int i=n+1;i;--i) f[i] = ((ll)f[i-1]*s+p-f[i])%p;
        f[0] = p-f[0];
        ++n;
    }
    memcpy(r,f,(n+1)<<2);
}

inline void czt(int *f,int n,int z){
    static int g[N],h[N],pw[N],suf[N];
    pw[0] = g[0] = g[1] = 1;
    for(int i=2;i<=(n<<1);++i) g[i] = (ll)g[i-1]*z%p;
    for(int i=2;i<=(n<<1);++i) g[i] = (ll)g[i]*g[i-1]%p;
    suf[n+1] = 1;
    for(int i=n;i;--i) suf[i] = (ll)suf[i+1]*g[i]%p;
    int pre = power(suf[1],p-2),tmp;
    h[0] = f[0];
    for(int i=1;i<=n;++i){
        pw[i] =  (ll)pre*suf[i+1]%p;
        h[i] = (ll)f[i]*pw[i]%p;
        pre = (ll)pre*g[i]%p;
    }
    reverse(g,g+(n<<1)+1);
    int lim = 1<<(32-__builtin_clz(n<<1));
    dft(g,lim),dft(h,lim);
    for(int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
    idft(g,lim);
    for(int i=0;i<=n;++i) f[i] = (ll)g[(n<<1)-i]*pw[i]%p;
}

int f[N],g[N];
int n,B,z,pw,res = 1;

int main(){
    scanf("%d",&n);
    B = sqrt(n);
    init(B<<1|1);
    getpoly(2,B,f);
    czt(f,B,power(2,B));
    for(int i=0;i!=B;++i) res = (ll)res*f[i]%p;
    pw = power(2,B*B+1);
    for(int i=B*B+1;i<=n;++i){
        res = (ll)res*(pw-1)%p;
        pw = (pw<<1)>=p?(pw<<1)-p:pw<<1;
    }
    printf("%d\n",res);
    return 0;   
}
```

---

## 作者：Joker_1212 (赞：8)

# P8474 题解

[原题传送门](/problem/P8474)

由于原题面已经很简洁了，所以就不放题目理解了。

## 题目分析

结论：$\sum\limits_\sigma 2^{\tau(\sigma)} = \prod\limits_{i = 1}^n (2^i -1)$。

证明如下：

设 $a_i$ 表示当 $n = i$ 时，$\sum\limits_\sigma 2^{\tau(\sigma)}$ 的值。

当 $n = 1$ 时，显然有 $a_1 = 1$。

当 $n\neq 1$ 时，将 $1 \sim n$ 分别放到第一个，分别会产生 $0 \sim n - 1$ 个逆序对，剩下的 $n - 1$ 个数共能产生 $a_{n - 1}$ 个逆序对，所以 $a_n = \sum\limits_{i = 0}^{n - 1} (2^i a_{n - 1}) = (2^n - 1)a_{n - 1}$。

然后发现：$a_1 = 1 = 2 - 1 = 2^1 - 1$，所以 $a_n = (2^n - 1)a_{n - 1} = (2^{n} - 1)(2^{n - 1} - 1)a_{n - 2} = \cdots = \prod\limits_{i = 1}^n (2^i -1)$。

于是我们便可以用这个式子愉快地递推了

## 代码实现

```cpp
/* By @Joker_1212 */
#include <bits/stdc++.h>
#define ull unsigned long long
#define ll long long
using namespace std;

const int mod = 1e9 + 7;

int main()
{
#ifdef LOCAL
    freopen("./in.in", "rb", stdin);
    freopen("./out.out", "wb", stdout);
#endif
    int n;
    cin >> n;
    ll ans = 1, power = 1;
    while (n--)
    {
        power <<= 1;
        power %= mod;
        ans *= power - 1;
        ans %= mod;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Micnation_AFO (赞：5)

第一眼看到这题：一点思路没有，我太菜了 /kk。

想了一会，先打了一个全排列 + BIT + 快速幂骗分，5pts，$n = 10$ 的时候 TLE，本地测试发现要跑三四秒，于是面向数据，拿了 25pts。

代码：[Link](https://www.luogu.com.cn/paste/wym6pll4)。

然后又想了一会（指 $3$ 个小时），拿这个打出 $n = 1\sim 7$ 的表，发现数据如下：

```latex
1 3 21 315 9765 615195 78129765
```

于是发现，每一个数都是它后一个数的约数。

假设答案为 $a$，则令 $a_i \times mul_i = a_{i + 1}$。

~~使用计算器可以~~轻松写出 $mul$ 的值：
```latex
3 7 15 31 63 127
```

然后令 $mul_i + add_i = mul_{i + 1}$，不难写出 $add$ 的值：

```latex
4 8 16 32 64
```

显然这个东西非常好求，即 $add_{i + 1} = add_i \times 2$。

再用 $add$ 推出 $mul$，最后用 $mul$ 推出 $a$ 即可。

AC Code：
```cpp
#include <iostream>

using namespace std;

const int N = 1e7 + 10;
const int mod = 1000000007;

int n;
int add[N], mul[N];

int main() {
    cin >> n;
    add[1] = 4, mul[1] = 3;
    for (int i = 2; i <= n - 2; i++) add[i] = add[i - 1] * 2 % mod;
    for (int i = 2; i <= n - 1; i++) mul[i] = (mul[i - 1] + add[i - 1]) % mod;
    long long ans = 1;
    for (int i = 2; i <= n; i++) ans = ans * mul[i - 1] % mod;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：RoyWu1207 (赞：2)

（蒟蒻第一次写题解，望大家支持！）

### 分析

~~这题题目看上去就很深奥~~

求什么大家应该都懂了，所以直接进入正题。

首先分析 $n = 2$ 时和 $n = 3$ 时的情况。

$n = 2$ 时答案为 $3$。

$n = 3$ 时：

- 序列第一个数为 $1$ 时，其对后面两个数无影响，即在这个部分中，答案为 $3$；
- 序列第一个数为 $2$ 时，会和 $1$ 产生 $1$ 对逆序对，在 $n = 2$ 的答案的基础上，会乘上一个 $2$；
- 序列第一个数为 $3$ 时，会和 $1,2$ 产生 $2$ 对逆序对，在 $n = 2$ 的答案的基础上，会乘上两个 $2$；

可以发现：无论序列中第一个数是多少，序列中除第一个数外的其它数所组成的排列，其答案一定。

另一个发现：序列中的第一个数是多少会对总的答案产生影响，在刚刚的例子中便是如此。这个产生的影响是多少呢？序列中第一个数会和比它小的数产生逆序对，将后面序列的答案乘上了 $2$ 的逆序对数量次方。

~~（可能比较难懂，第一次写题解，大家多看看吧！）~~

根据乘法分配律，将乘上的数量相加，为 $2^i - 1$。

因此，我们可以通过递推的方式，不断地将当前的答案乘上 $2 ^ i - 1$ 的值。

验算一下，当 $n = 4$ 时，同样有这个规律。

再用一个奇怪的办法来处理 $2^i - 1$ 的值。

接下来就可以写出代码了。

### AC Code：
```cpp
#include <iostream>
#define ull unsigned long long

using namespace std;

const ull MOD = 1e9 + 7;
int MOD2[10000001];

int main() {
	int n; cin >> n; MOD2[0] = 1;
	for (int i = 1; i <= n; i++)
		MOD2[i] = (ull)MOD2[i - 1] * 2 % MOD; //处理MOD2数组
	if (n == 1) {
		cout << 1; return 0;
	} if (n == 2) {
		cout << 3; return 0;
	} //两组特判
   ull ans = 3; //从3开始算
	for (int i = 3; i <= n; i++)
		ans *= MOD2[i] - 1, ans %= MOD; //递推计算ans
	cout << ans;
	return 0;
}
```
PS：蒟蒻第一次写题解，有什么写得不清楚的，欢迎大家提出意见！谢谢！

---

## 作者：cst_123 (赞：2)

### - [传送门](https://www.luogu.com.cn/problem/P8474)

------------

### 思路

我们可以先打表，从 $1$ 到 $5$ 分别是：

```cpp
1 3 21 315 9765
```

我们试了一下，首先 $1$ 和 $3$ 暂时并没有什么联系。再看 $3$  和 $21$，我们能发现 $3$ 是 $21$ 的因数，往后再试，~~用计算机算出结果~~，就能知道 $315$ 是 $21$ 的倍数。 

能发现前面的一个数是后面的数的因数。

好，我们再把后一个数除以前一个数的值打成表。

```cpp
3 7 15 31
```

再看看有什么规律，然后继续试试，就可以发现后面的数与前面的数之差有规律可寻。

```cpp
4 8 16
```

这样就比较明显了，就是 $num_i=num_{i-1} \times 2$。

这样，我们从最后的 $num$ 推出第二步的值，再继续推出最终答案就行了。

### 代码

```cpp
//now是表示的是第二步
//num是表示的是第三步
if(n==1)//特判，不过可以不用
	return printf("1\n"),0;
if(n==2)
	return printf("3\n"),0; 
if(n==3)
	return printf("21\n"),0;
if(n==4)
	return printf("315\n"),0;
now=3;
num=4;
for(int i=2;i<=n;i++){//每次都要取模
	ans=(ans*now)%Mod;//推出第一步
	now=(now+num)%Mod;//推出第二步，更新，已备下一次操作
	num=num*2%Mod;//推出第三步
}
printf("%lld\n",ans%Mod);
```

---

## 作者：xhabc66 (赞：1)

# 思路
~~这是一道典型的 adhoc 题，打表可知答案为......~~

题目中说了 $n\le 10^7$，所以本题的标算必定是 $O(n)$ 的。

设 $ans_i$ 为 $n=i$ 时的答案。

线型算法必需建立 $ans_{i-1}$ 和 $ans_i$ 的关系。

已知：$n$ 的全排列去掉第一个数字就是把 $n-1$ 重复了 $n$ 遍，所以只需关心第一个数字带来的影响。

在第一个数字为最小时，它产生不了任何的逆序对；第二小的能产生一个……第 $n$ 小的能产生 $n-1$ 个。

所以，
$$ans_i=2^0\times ans_{i-1}+2^1\times ans_{i-1}+...+2^{i-1}\times ans_{i-1}$$
$$=(2^0+2^1+...+2^{i-1})ans_{i-1}$$
$$=(2^n-1)ans_{i-1}$$
$$=\prod_{j=1}^{i}(2^j-1)$$
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	long long ans=1, _2=2;//不开 long long 见祖宗！！！
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		_2*=2;
		_2%=1000000007;
		ans=(ans*(_2-1))%1000000007;
	}
	cout<<ans;
	return 0;
 } 
```


---

## 作者：cmk666 (赞：1)

# 前言

在机房和同学抢最优解卡了一下午终于卡到 $12\texttt{ms}$，结果他晚上自学了 $\texttt{pascal}$ 反手就是一个 $10\texttt{ms}$，~~焯~~！

# 正文

[题目链接](/problem/P8474)

设长度为 $i$ 时答案为 $f_i$。考虑如何快速通过 $f_{i-1}$ 计算 $f_i$。

当长度为 $i$ 时，第 $1$ 位所填的数有 $i$ 种可能（$1\sim i$）。当第 $1$ 位是 $j$ 时，显然它会与后面填写的所有数产生 $j-1$ 个逆序对，即对答案的贡献为 $2^{j-1}$。而后面 $i-1$ 个数所产生的逆序对对答案的贡献显然是 $f_{i-1}$。因此，得到 $f$ 的递推公式：

$$f_i=f_{i-1}\sum_{j=1}^i2^{j-1}$$

等比数列求和一下即可得到：

$$f_i=f_{i-1}(2^i-1)$$

然后 $O(n)$ 递推即可。主要代码：
```cpp
#define int long long           //不开 long long 见祖宗
const int mod = 1000000007;
int n, ans = 1, p = 2;
signed main()
{
	read(n);
	For(i, 2, n) p = ( p << 1 ) % mod, ans = ( p - 1 ) * ans % mod;
	return printf("%lld\n", ans), 0;
}
```
然而，这种数列求值的题目，有一种~~更加优雅的~~方式——分段打表。可以参照 [$\texttt{OI wiki}$](//oi-wiki.org/math/dictionary/) 进行学习。

大致思路是设定一个块长 $B$，共有 $\dfrac nB$ 个块。每隔 $B$ 个就打表存储一下 $2^i$ 和当前的答案 $f_i$，这样就可以找到前一个块，接着它的值进行计算。时间复杂度 $O(B)$，空间复杂度 $O\left(\dfrac nB\right)$。但受代码长度为 $50\texttt{KB}$ 的限制，实际上 $B$ 不能取很小。

打表程序如下：（生成 $\texttt{a.c}$ 的 $\texttt C$ 语言文件）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string s = "p[]={";
string e = "},m,n;long long f,g,P=1e9+7;main(){scanf(\"%d\",&n);for(g=p[m=--n/";
string r = "*2],f=p[1+m],n%=";
string t = ";n;n--)g=2*g%P,f=f*(g-1)%P;printf(\"%lld\",f);}";
ll p = 1, ans = 1, mod = 1e9+7, B = /*块长*/;
int main()
{
	ofstream fout("a.c"); bool flag = true;
	fout << s;
	for ( int i = 1 ; i <= 10000000 ; i++ )
	{
		p = ( p << 1 ) % mod, ans = ( p - 1 ) * ans % mod;
		if ( i % B == 1 )
		{
			if ( flag ) flag = false; else fout << ',';
			fout << p << ',' << ans;
		}
	}
	fout << e << B << r << B << t;
	return 0;
}

```
打出来的表就不贴了，太长了。可读性也很差，因为我为了能打下更多的表而压缩了一下代码。~~搁这 Code Golf 是吧~~

附：[我的 $12\texttt{ms}$ 记录](/record/84150313)

# 结语

分段打表牛逼！

---

## 作者：JackMerryYoung (赞：1)

# 前言

递推好题，不过竟然可以 OEIS???

# 正文

考虑递推吧，毕竟是道计数题。

$f_i$ 分解为两部分，其子问题和加入新数字对于答案的贡献。

子问题就是 $f_{i - 1}$, 那么加入一个数的贡献呢？

发现产生的逆序对与排列规模大小有关，结果显然是 $\sum_{k = 1}^i 2^{k - 1}$. 

于是就有了朴素的 $\mathcal{O}(N^2)$ 做法，再结合等比数列求和公式可以优化至 $\mathcal{O}(N)$. 可以通过。

# 代码

伪代码：

``` python
If(N == 1):
    print(1)
Else:
    pow2 = 2, ans = 1
    For(i From 2 To N Step 1):
        pow2 = pow2 * 2, ans = ans * (pow2 - 1)
```

---

## 作者：Charlie1202 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8474)
## 题意
  给定 $n$，设 $\sigma$ 为任意一个长度为 $n$ 的排列，求
$$
\sum_\sigma 2^{\tau(\sigma)} \bmod (10^9 +7)
$$
  其中 $\tau(\sigma)$ 表示排列 $\sigma$ 中存在的逆序对数目。
## 分析
  首先从小数据入手，若不考虑模数，枚举 $n = 1, 2, 3, 4$ 的情况，设 $f(i)$ 为 $n = i$ 时的答案：
  - $n = 1$ 时，显然有 $f(1) = 2^0 =1$；
  - $n = 2$ 时，有排列 $\{1,2\}$ 和 $\{2, 1\}$，$f(2)=2^0 + 2^1 = 3$；
  
  接下来，对于每一个 $n$，$\sigma$ 的全排列会有 $n !$ 种，我们不妨只写出以 $1$ ~ $n$ 中的每个数开头时，关于 $\tau(\sigma)$ 的排列，即 $2$ 的指数：
  
  - $n = 3$ 时，有排列 $\{0,1, 1, 2, 2, 3\}$，两项为一组，发现前两项正是 $n = 2$ 时的排列，此时 $f(3) = 2^0 + 2^1 +2^1 +2^2 +2^2 +2^3 =21$；
  - $n = 4$ 时，依次以每个数开头写全排列，有：  
  以 $1$ 开头的排列的 $\tau(\sigma)$ 为 $\{0,1, 1, 2, 2, 3\}$，与  $n = 3$ 时的情况一致；  
  以 $2$ 开头的排列的 $\tau(\sigma)$ 为 $\{1,2, 2, 3, 3, 4\}$；  
  以 $3$ 开头的排列的 $\tau(\sigma)$ 为 $\{2,3, 3, 4, 4, 5\}$；  
  以 $4$ 开头的排列的 $\tau(\sigma)$ 为 $\{3,4, 4, 5, 5, 6\}$；  
  故 $f(4) = 315$。


  规律似乎已经出现，如果你还不确定，可以再枚举一两个 $n$，会发现结果和上面一致，即对于我们枚举的每一个 $i$，以 $1$ 开头的 $\tau(\sigma)$ 的全排列与 $i - 1$ 时的所有排列一致，也就是该行的 $2$ 的次幂和等于 $f(i - 1)$；对于剩下的情况，只不过是在上述排列的基础上各项加了 $1$，反映到 $2$ 的次幂上就是乘以了 $2$，因此，我们只要对此类中所有的排列提取公因式 $f(i-1)$，剩下的部分就会是一个有 $i$ 项，公比 $q = 2$ 的等比数列。
  
  具体而言，我们要求的答案就会是：
  $$
  f(i)=(2^0 + 2^1 + \cdots + 2^{i-1}) \cdot f(i-1)
  $$
  其中，$(2^0 + 2^1 + \cdots 2^{i-1})$ 可以用等比数列求和公式化简：
  $$
  S_n = a_1 \cdot \dfrac{1 - q^n}{1-q}
  $$
  本题中，$a_1 = 2^0 =1, q = 2$，代入可得最终答案：
  $$
  f(i)=(2^i - 1) \cdot f(i-1)
  $$
  由于最后还要求 $f(i) \bmod (10^9 + 7)$，运用取模运算的性质：
  
  1. $(a - b) \bmod p = (a \bmod p -  b \bmod p) \bmod p$；
  1. $(a * b) \bmod p = ( (a \bmod p) *  (b \bmod p) ) \bmod p$；
  
  令 $p= 10^9 +7$，据此化简得最终递推式（不考虑进一步化简）：
  $$
  f(i)=(((2^n \bmod p - 1)\bmod p)\cdot (f(i-1)\bmod p))\bmod p
  $$
  （括号有点多，请见谅）
  
  特别的，由于递推边界 $f(1) = 1$，其实答案就是下面这个式子，不过赛时并没想到进一步化简：
  $$
  f(n) = \prod_{i = 1}^{n} (2^i - 1)
  $$

## 代码实现

  根据上面的递推式，我们实际上只要处理 $2^n \bmod p$ 的计算（因为 $1\le n \le 10^7$），这显然可以用快速幂，我这里用的是二进制遍历的快速幂，具体原理可以看快速幂模板题解的第一篇：[P1226 题解](https://www.luogu.com.cn/problem/solution/P1226)

  这种算法可能不如标算优，但也能过。

  赛时代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long sum[10000005];
const unsigned long long p=1e9+7;
unsigned long long f(unsigned long long a,unsigned long long b)
//快速幂，开 unsigned long long 只是怕数据溢出，注意不要想当然的把 a
//直接在外面定义好为 2 而省略第一维，因为过程中 a 会被不断更新
{
    unsigned long long ans=1%p;
    for(;b>0;b>>=1)
    {
        if(b&1)ans=ans*a%p;
        a=a*a%p;//a 被更新
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);//这个只是试试能不能加速，不加也能过
    unsigned long long n;
    cin>>n;
    sum[1]=1;
    sum[2]=3;
    sum[3]=21;//注意初始化，理论上 2、3 可省
    for(unsigned long long i=4;i<=n;i++)
    {
        sum[i]=(((f(2,i)-1)%p)*(sum[i-1]%p))%p;
    }
    //for(int i=1;i<=n;i++)cout<<sum[i]<<" ";
    //cout<<"\n";
    //cout<<f(2,5);
    cout<<sum[n];
    return 0;
}
```


---

## 作者：Unnamed114514 (赞：0)

我们先设 $f_i$ 表示长度为 $i$ 的逆序对总数。

题目中有一句提示：只要 $a$ 中的元素大小关系是确定的，那 $f_{|a|}$ 就是确定的。

所以我们考虑对于 $f_i$，我们在第一个位置添加一个元素 $x$，后面的元素的大小关系是确定的，答案是确定的，正好就是 $f_{i-1}$，此时 $x$ 会对 $[2,i]$ 产生 $x-1$ 个逆序对，因为 $x\in[1,n]$，所以 $i$ 的答案就是 $\sum\limits_{j=1}^i2^{(j-1)f_{i-1}}=(2^i-1)2^{f_{i-1}}$。

因为 $f_i$ 看着不方便，我们可以将 $f_i$ 转化为 $2^{f_i}$，那么此时的递推式就是 $f_{i}=(2^i-1)f_{i-1}$。

---

## 作者：larsr (赞：0)

题目对逆序对的定义是这样的：
>对于长度为 $n$ 的排列 $\sigma$，假设下标从 $1$ 开始，那么我们称 $(i,j)$ 构成逆序对，当且仅当 $1\le i<j\le n$，并且 $\sigma_i>\sigma_j$；$\tau(\sigma)$ 则表示总共有多少对不同的 $(i,j)$ 满足上述条件。

对一个数列 $t$ 而言，它的逆序对数可以用以下方式定义:
> 对于每个位置 $i$，如果**后小数**（这个是我自己瞎编的，是为了能更好说明）代表它后面比它小的数的**数量**。那么数列 $t$ 的逆序对数为**每个位置的后小数之和**。

排列 $\sigma$ 的位置 $1$ 如果选数字 $i$，那么位置 $1$ 的**后小数**就是 $i - 1$。还有 $n - 1$ 个数怎么办？而且它们还不是一个排列。

假如将剩下的 $n - 1$ 个数**离散化**,就会很好处理，因为**离散化**后，将某个数放入一个位置时，又可以轻松计算**后小数**了。

有一件东西可以知道，不管第一个位置取谁，离散化后都一样。

由上可得：对于 $\sigma$，第一个位置的**后小数**可以有 $n - 1$ 种选择，**后小数**为 $0$ 到 $n - 1$。对于每种排列，它会对答案贡献 $2^{\tau(\sigma)}$，假如 $\tau(\sigma)$ 加上了 $a$，那么 $\tau(\sigma)$ 会乘上 $2^a$。

考虑递推式子，设
$$ans_i = \sum_{\sigma}2^{\tau(\sigma)}$$
其中 $\sigma$ 长度为 $i$，根据上式子，可推出
$$ans_i = \sum_{\sigma}2^{\tau(\sigma)}$$
$$=\sum_{\sigma}\sum_{i = 0}^{n - 1}(2^{\tau(\sigma)}\times 2^i)$$
$$=(\sum_{\sigma}2^{\tau({\sigma})})(\sum_{i = 0}^{n - 1}2^{i})$$
$$=(\sum_{\sigma}2^{\tau({\sigma})})\times(2^n - 1)$$
$$=ans_{i - 1}\times(2^n - 1)$$
**注意从第二行开始的** $\sigma$ **长度为** $i - 1$。

## 核心程序如下
```
	bit[0] = 1;
	int ans = 1;
	for(int i = 1; i <= n; i++)
  	{
		bit[i] = bit[i - 1] * 2 % mod;\\计算2的幂次方
   	  	ans = ans * ((bit[i] - 1 + mod) % mod) % mod;\\递推ans
   	}
```

---

## 作者：YONIC (赞：0)

# [P8474 「GLR-R3」立春](https://www.luogu.com.cn/problem/P8474)

考虑长度为 $n$ 的全排列，当第一位为 $1$ 时，设 $\sum_{\left\langle 1,\cdots\right\rangle}{2^{\tau(\sigma)}}=k$，则若第一位为 $x$，则 $x$ 会和后面每一个小于 $x$ 的数产生总共 $x-1$ 个逆序对，所以若第一位为 $x$，$\sum_{\left\langle x,\cdots\right\rangle}{2^{\tau(\sigma)}}=2^{x-1}k$。

综上所述，我们就得到了 $\sum_{\sigma}{2^{\tau(\sigma)}}=\prod_{i=1}^{k}(2^i-1)$。

~~警钟敲烂，我因为运用快速幂，没看到 $10^7$ 的数据范围，$\texttt{TLE|MLE}$ 了超多次……~~

推荐题目：[P1338 末日的传说](https://www.luogu.com.cn/problem/P1338)，对此题很有用。

ACcode:
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int n,e[10000003];
long long f[10000003];
signed main(){
	scanf("%d",&n);
	e[1]=1;
	f[1]=1;
	for(int i=2;i<=n;++i) e[i]=(e[i-1]*2+1)%mod;//e[i]=2^i-1
	for(int i=2;i<=n;++i) f[i]=(f[i-1]*e[i])%mod;
	printf("%lld",f[n]);
	return 0;
}
```

---

## 作者：CReatiQ (赞：0)

## 题意概述

给定正整数 $n$，设 $\sigma$ 为长度为 $n$ 的排列，$\tau(\sigma)$ 为 $\sigma$ 的逆序对数。

求：

$$\sum_{\sigma} 2^{\tau(\sigma)} \bmod (10^9+7)$$

$(1 \leq n \leq 10^7)$

---

## 思路

Tips: 
1. 本题解未使用 OEIS 等科技支援。

2. 跳过 Subtask 3 内容不会影响 Subtask 4~5 内容的阅读体验。

对于这类计数题，我们不妨先从小数据开始，手动推导答案，寻找规律。

按照字典序在草稿纸上枚举：

当 $n=3$ 时，$\tau(\sigma)$ 序列为：$\{ 0,1,1,2,2,3 \}$;

当 $n=4$ 时，$\tau(\sigma)$ 序列为：$\{ 0,1,1,2,2,3,1,2,2,3,3,4,2,3,3,4,4,5,3,4,4,5,5,6 \}$.

### Subtask 1~2

记 $n=i$ 时，$\tau(\sigma)$ 序列为 $A(i)$，$A(i)+j$ 意为 $A(i)$ 序列每个元素加上 $j$ 得到的新序列。

按照规律，应该有 $A(i)= \{ A(i-1),A(i-1)+1,\cdots,A(i-1)+i-1 \}$.

这个规律由字典序的性质得来，其实就是确定第一关键字后剩下的序列可以对应到长度减一的序列，序列元素加上多少取决于第一关键字的大小，所以它是正确的。

记 $\large f_i$ 为 $\tau(\sigma)=i$ 对应的排列个数，我们可以利用上面的规律快速求出 $n$ 较小时的 $f$ 。

当 $n=1$ 时，$f_0=1$;

当 $n=2$ 时，$f_0=1,f_1=1$;

当 $n=3$ 时，$f_0=1,f_1=2,f_2=2,f_3=1$;

当 $n=4$ 时，$f_0=1,f_1=3,f_2=5,f_3=6,f_4=5,f_5=3,f_6=1$.

它是 $\mathcal{O}(n!)$ 的，只能通过 Subtask 1~2，并且代码实现相对繁琐，更适合配合计算技巧加快人工计算，但它打出的小表以及背后的规律，对我们很有意义。

---

### Subtask 3

观察上面的 $f$ ，这种对称结构很容易让我们联想到杨辉三角，但貌似它和组合数沾不上什么边。

再想想，杨辉三角有一个特别的递推式：$\large \binom{i}{j}=\binom{i-1}{j}+\binom{i-1}{j-1}$.

这个 $f$ 有没有类似的递推式呢？

因为不同 $n$ 对应的 $f_i$ 不同，所以我们不妨把 $n$ 也作为 $f$ 的一维，观察能否递推。

设 $f_{i,j}$ 为 $n=i$ 时 $\tau(\sigma)=j$ 对应的排列个数。（注意：$i$ 的意义与前文不同，$j$ 继承前文 $i$ 的意义。）

对于第 $i$ 层，其有 $\frac{i \cdot (i-1)}{2}+1$ 个元素（那个 $+1$ 就是 $j=0$ 的情况），前 $\frac{(i-1) \cdot (i-2)}{2}$ 个元素满足 $f_{i,j}=f_{i,j-1}+f_{i-1.j}$.

那后面的元素呢？直接对折过去么？

不难发现，按照这个递推式，第 $i$ 层已递推出的元素是单调的。

而当 $i>5$ 时，已递推的元素将越过这层的中间元素，后面这部分元素，被递推与对折得到的答案是不同的，所以这个算法是错误的。

那如果，我们只递推到对应层的中间元素，然后就对折呢？

我们试着这样递推出第 $5$ 层，就会发现这些元素之和超过了 $5!$，显然有误。

这样想来，可能是我们的递推式缺少一个减去的项？

目光回到 $f$ 的第 4 层：$f_{4,3}=6,f_{4,4}=5,f_{4,5}=3,f_{4,6}=1$.

逐位做差，得到：

$f_{4,4}-f_{4,3}=1=f_{3,0}$;

$f_{4,5}-f_{4,4}=2=f_{3,1}$;

$f_{4,6}-f_{4,5}=2=f_{3,2}$.

这是巧合么？不妨试试。

$$ f_{i,j}=f_{i,j-1}+f_{i-1,j}-f_{i-1,j-i} $$

用这个式子去递推第 5 层，得到序列：$\{ 1,4,9,15,20,22,20,15,9,4,1 \}$。

如果你用前面通过字典序得到的规律推出了第 5 层，你就能确定这个序列是正确的；没有的话，将它们求和，答案恰好为 $5!$，继续递推更高层验证，依然吻合，我们可以确信这个递推式的正确性了。

按照上面的式子递推，时间复杂度为 $\mathcal{O}(n^3)$。

可以用滚动数组优化空间，但无论优化与否它都只能通过 Subtask 1~3。

---

### Subtask 4~5

对于善用数学归纳法的同学，通过 $\mathcal{O}(n!)$ 或是 $\mathcal{O}(n^3)$ 的算法，抑或是利用性质人工计算，我们都可以得出规模可观的答案了，我们不妨直接开始从答案上寻找规律。

推出未取模的答案，发现答案相差较远，但位数相差稳定在 2 到 3 位，考虑将相邻答案作商。

作商后，我们得到序列：$\{ 1,3,7,15,31,63,127,\cdots \}$，不难看出规律：下一位是上一位的二倍加一。

于是我们大胆写出递推式：

$$f_1=g_0=1$$

$$g_{i+1}=2 \cdot g_{i} \bmod (10^9+7)$$

$$f_{i+1}=f_i \cdot g_i \bmod (10^9+7)$$

比较谨慎的同学可以跟 $\mathcal{O}(n^3)$ 的算法对拍几组数据。

提交后便可喜提 AC。

为什么是正确的呢？

看看我们的 $g$ 序列，它有没有另一种表达形式呢？

有：$g_i=2^i-1=\sum_{j=1}^i 2^{j-1}$

不知道屏幕前的你是否还记得这句话：

> 这个规律由字典序的性质得来，其实就是确定第一关键字后剩下的序列可以对应到长度减一的序列，序列元素加上多少取决于第一关键字的大小，所以它是正确的。

回想 Subtask 1~2 中我们定义的 $A(i)+j$，其实我们的 $g$ 序列，就是这个 "$+j$" 在答案上的投影，就是确定的第一关键字带来的贡献。

---

## Code

```cpp
#include <cstdio>
#define int long long
#define MAXN (int)(1e7+233)
#define rep(i,l,r) for (int i=l;i<=r;i++)

const int mod=1e9+7;
int n,f[MAXN],g[MAXN];

signed main()
{
	scanf("%d",&n);
	f[1]=g[0]=1;
	rep(i,1,n-1)
		g[i]=((g[i-1]<<1)+1)%mod,
		f[i+1]=f[i]*g[i]%mod;
	printf("%lld",f[n]);
	return 0;
} 
```


---

## 后记

旧序列加上第一关键字，得到新序列，这就是最为核心的思路。DP都是如此，简练的状态划分（通常从数据范围入手，是时空复杂度的主要瓶颈），加上精巧的状态转移（为了达到精巧，这一步有时需要用倍增，数据结构，单调性等优化，也可能成为时空复杂度的瓶颈），从初始状态步步拓展，最终方能优雅地得到答案。

愿 AC 这题后，带给你的不仅有通过题目数的增长，还有对算法更深刻的认识，还有何时乍现的灵光，还有对从现在步步拓展更加坚定的信念，还有未来那个优雅得到答案的你。

---

## 作者：484A51 (赞：0)

## 思路
首先肯定能想到暴力，但是仔细想想就会发现，暴力绝对会超时。（废话）

那么接下来怎么才能得到正确答案呢？根据我的经验，像这种输入一个正整数，输出另一个正整数，满足一一映射关系的题目，大部分都能 **找规律** 。当我们按字典序将 $1 \sim n$ 的所有排列写出后，手动（当然也可以写个程序帮你）算出他们逆序对的个数，就能发现规律啦！  

下面简单列举几个：

| $n$ |字典序排列的逆序对个数  | 答案|
| :----------: | :----------: | :----------: |
| $1$ | **0** | $1$ |
| $2$ | **0**,$\color{red}\text{1}$ | $1+1\times2=3$ |
| $3$ | **0,1**,$\color{red}\text{1,2}$,$\color{blue}\text{2,3}$ | $3+3\times2+3\times4=21$|
| $4$ | **0,1,1,2,2,3**,$\color{red}\text{1,2,2,3,3,4}$,$\color{blue}\text{2,3,3,4,4,5}$,$\color{gold}\text{3,4,4,5,5,6}$|$21+21\times2+21\times4+21\times8 =315$
|...| ...|...|

可以看出，每个数的逆序对个数的排列符合一个规律。每个序列最前面黑色的部分就是 $n-1$ 逆序对数量的序列，之后每一个不同的颜色都是最开始的黑色序列中所有数加一，如果把它们变成 $2$ 的指数就是直接将上一个颜色序列的结果乘二。
## 代码
规律知道了，接下来就是愉快的写代码时间啦。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int dp[10000010];	//记录每个n的答案
signed main()
{
	int n,s=1,t=1;	//s和t是记录该乘的数字
	cin>>n;
	dp[1]=1;	//显然，当n=1，答案就为1
	for(int i=2;i<=n;i++){
		t=t*2;	//每循环一次，就会比n-1多出一个颜色，t乘二
		s=s+t;	//s累加上所有的t，就是总共要乘的数了
		dp[i]=dp[i-1]*s;
	}
	cout<<dp[n];	//最后只要输出dp[n]
	return 0;
}
```
最后别忘了取模，为了看得清楚，代码里没有取模。

---

## 作者：NightTide (赞：0)

~~俗话说的好：“打表出奇迹”，所以我们这一题打表计算。~~

其实确实可以打表来找规律。通过打表，我们可以获得如下的结果：

```cpp
1	1
2	3
3	21
4	315
5	9765
……	……
```

然后观察可得：

$$1 \times 3 = 1 \times (2^2 - 1) = 3$$
$$3 \times 7 = 3 \times (2^3 - 1) = 21$$
$$21 \times 15 = 21 \times (2^4 - 1) = 315$$
$$315 \times 31 = 315 \times (2^5 - 1) = 9765$$

于是可以猜测，设 $f_i$ 为 $n = i$ 时的答案，则有 $f_i = f_{i - 1}\times (2^i - 1)$。

这样就可以 $O(n)$ 递推了。

但是我们还需要知道的是，为什么是这样的关系。

假设我们已经知道了 $n = i - 1$ 时的答案，现在需要求出 $n = i$ 时的答案。

显然，一个 $i$ 的排列可以向一个 $i - 1$ 的排列中的一个位置插入数 $i$ 来得到，由于一个 $i - 1$ 的排列中不会有大于 $i$ 的数，所以对于任意一个 $i - 1$ 的排列，从后往前插入数 $i$ 依次会增加 $0,1,2,\dots,i - 1$ 个逆序对。

所以，$f_i = f_{i - 1} \times (2^0,2^1,2^2,\dots,2^{i - 1}) = f_{i - 1} \times (2^i - 1)$。

```cpp
#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;
typedef long long ll;
int n;
ll ans = 1, bit = 4;
int main(){
    scanf("%d",&n);
    for(int i = 2; i <= n; i++, (bit <<= 1) %= MOD){
        (ans *= (bit - 1)) %= MOD;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：sgl654321 (赞：0)

### 题目大意
- 定义：对于一个长度为 $n$ 的序列，若在这个序列中出现了 $1\sim n$ 的所有自然数，则称这个序列为一个排列。
- 定义：给定一个序列 $a$，若此序列中存在两个数 $a_i$ 和 $a_j$，满足 $i<j$ 且 $a_i>a_j$，则称这两个数构成逆序对。序列 $a$ 中所有的逆序对个数记为 $\tau(a)$。
- 给定一个正整数 $n$，记所有长度为 $n$ 的排列为 $\sigma$。设
$$x_n=\sum_{\sigma}^{} 2^{\tau(\sigma)} $$
请求出 $x_n$ 对 $10^9+7$ 取模的结果。

### 解题思路
做题首先看数据范围。本题中 $n\leq 10^7$，一看时间复杂度就是 $O(n)$。思考：$x_n$ 能否由 $x_{n-1}$ 得到？

我们不妨先用 $n=4$ 找一找规律。长度为 $4$ 的排列共有 $24$ 个。

$[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2]$

$[2,1,3,4],[2,1,4,3],[2,3,1,4],[2,3,4,1],[2,4,1,3],[2,4,3,1]$

$[3,1,2,4],[3,1,4,2],[3,2,1,4],[3,2,4,1],[3,4,1,2],[3,1,2,4]$

$[4,1,2,3],[4,1,3,2],[4,2,1,3],[4,2,3,1],[4,3,1,2],[4,3,2,1]$

我们再把他们的 $\tau$ 都给写出来：

$0,1,1,2,2,3$

$1,2,2,3,3,4$

$2,3,3,4,4,5$

$3,4,4,5,5,6$


我们好像发现每一行都比上一行的每一个数都大 $1$！再观察一下第 $1$ 行，我们发现它正好就是上一个 $n=3$ 的所有排列的 $\tau$。

我们再思考一下，为什么会这样呢？

首先有一个非常显然的结论：有两个序列 $a$ 和 $b$，元素个数一样，对于所有的元素 $b_i$ 和 $a_i$，都满足 $b_i=a_i+c$，其中 $c$ 是常数，那么 $\tau(b)=\tau(a)$。

依据是不等式的性质 $1$：若 $a>b$，则 $a+c>b+c$。

再观察一下 $n=4$ 时的第一行和 $n=3$。由于在 $n=4$ 的第一行中，第一个元素都是 $1$，不能与任何元素构成逆序对，所以不受影响，答案只与后 $3$ 个元素有关了。

我们发现，$n=3$ 时，是 $1,2,3$ 三个元素构成的序列，而 $n=4$ 第一行的后三个数，是 $2,3,4$ 三个元素构成的序列，根据刚才的那个结论，它们的各个 $\tau$ 一定是对应相等的。 

然后我们再来看看第 $1$ 行与第 $2$ 行之间的关系。我们发现第 $1$ 行和第 $2$ 行，只是把元素 $1$ 和元素 $2$ 交换了一下，$2$ 变到了 $1$ 的前面，其他都不变。那么其他构成的逆序对都在，还多加上了 $2$ 和 $1$ 所构成的逆序对。因此第二行的各个 $\tau$ 都比第一行大 $1$。

于是我们就证明了我们刚刚发现的规律了。看看我们要求的是什么：
$$\sum_{\sigma}^{} 2^{\tau(\sigma)} $$

那么我们就把 $n=4$ 的四行都计算一下。

$2^0+2^1+2^1+2^2+2^2+2^3=21$

$2^1+2^2+2^2+2^3+2^3+2^4=42$

$2^2+2^3+2^3+2^4+2^4+2^5=84$

$2^3+2^4+2^4+2^5+2^5+2^6=168$

我们发现每一行的和都是上一行的 $2$ 倍，这是因为每一项的指数都大 $1$，根据乘方的运算法则，就是上一行的 $2$ 倍 。于是

$$\sum_{\sigma}^{} 2^{\tau(\sigma)}=21+42+84+168=21\times(1+2+4+8)=21\times (2^4-1)=315$$


$21$ 就是 $x_3$ 的值，所以 $x_4=x_3\times(2^4-1)$。

我们以此类推，同样的方法，同样的证明过程，很容易就可以得到所有的递推关系式：$x_i=x_{i-1}\times(2^i-1)$。特别地，$x_1=1(2^0=1)$。

知道了递推式总会写了吧！注意要时时刻刻模上 $10^9+7$，避免出现错误。

### 参考代码
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
long long n,ans,pre=3,prere=2;
int main(){
	cin>>n;
	ans=3;
	if(n==1){
		cout<<1<<endl;return 0;	
	}
	if(n==2){
		cout<<ans<<endl;
		return 0;
	}
	for(int i=3;i<=n;i++){
		prere=prere*2%mod;
		pre=(pre+prere)%mod;
		ans=(ans*pre)%mod;
	}
	cout<<ans<<endl;
	return 0;
}
```

---


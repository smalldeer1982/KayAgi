# 「GLR-R3」雨水

## 题目背景

&emsp;&emsp;「天将化雨舒清景，萌动生机待绿田」

---

&emsp;&emsp;在天依面前口口声声说着习惯了，才开学没几天，文化课和乐队训练的压力可是又让阿绫头疼呢。

&emsp;&emsp;浓缩为一个晚上的周末。站在阳台上，摸索朦胧于雨声的城市轮廓。雨水之日的雨，对于眼前的高楼大厦——们，恐怕也难有一些别样的意境吧。

&emsp;&emsp;“雨水节令的雨、白露节令的露、霜降节令的霜、小雪节令的雪各十二钱……”

&emsp;&emsp;胡乱想着，阿绫噗嗤一声笑了出来，“但是不管在哪里，雨中的空气，雨后的初阳，总是清新得叫人欢喜。”向着雨幕笑笑，拨弄这手里的旧吉他，不知不觉哼起那首歌来。

---

&emsp;&emsp;**雨水**&emsp;「等凉雨　的温度　将不安燥热中和　寻觅着　风的波折」

## 题目描述



身后的门被敲响，接过天依包回来的一大盒多肉，放下东西贴贴一会儿之后，她们决定把多肉们在阳台上排成一排。

多肉们的高度不尽相同，天依先将一共 $n$ 盆多肉随意排成一排，从左到右第 $i$ 盆的高度为 $a_i$。为了美观，她希望交换某些多肉的位置，使得由高度组成的序列 $A$ 的**字典序**尽可能小，不过，为了照顾多肉们的感受（？）她要求阿绫只能选取 $A$ 的一个**长度为偶数的子序列**（长度可以为 $0$），交换序列里第 $1$ 盆和第 $2$ 盆，第 $3$ 盆和第 $4$ 盆……的位置，然后放回它们原来的位置中。

苦活交给了阿绫，思考的工作自然交给你啦！请告诉阿绫，仅使用**一次**选取子序列的操作，她能够得到的字典序最小的新高度序列 $A'$。

#### 形式化题意

给定一个长为 $n$ 的整数序列 $A$，下标从 $1$ 开始。你可以**任取一个**自然数 $k$ 以及一个序列 $\lang 1,2,\dots,n\rang$ 的，长度为 $2k~(k\in\mathbb N)$ 的**子序列** $P$，并对于所有 $i=1,2,\dots,k$，交换 $A_{P_{2i-1}}$ 与 $A_{P_{2i}}$ 的值。求在所有可能得到的新序列 $A'$ 中，**字典序** 最小的序列。

**字典序**：对于长度为 $n$ 的序列 $A$ 和 $B$，定义 $A$ 的字典序小于 $B$，当且仅当：

$$
\exists i\in[1,n], (\forall j\in[1,i), A_j=B_j)\land A_i<B_i.
$$

**注意**：本题输入输出方式具有特殊性。详见「输入格式」与「输出格式」。


## 说明/提示

#### 样例 #1 解释

生成的序列为 $A=\lang 1,1,3,0,0,1,3\rang$，选取 $k=1,P=\lang 1,5\rang$, 得到答案序列为 $A'=\lang 0,1,3,0,1,1,3\rang$，按照要求计算知答案为 $43$。

#### 样例 #2 解释

生成的序列为 $A=\lang 2,8,0,6,2,2,1,7,8,3\rang$，选取 $k=3,P=\lang 1,3,4,7,8,10\rang$, 得到答案序列为 $A'=\lang 0,8,2,1,2,2,6,3,8,7\rang$，按照要求计算知答案为 $256$。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

对于 $100\%$ 的测试数据，$1\le n\le10^7$，$2\le \textit{thres}\le10^9$，$0\le k_1,k_2<2^{64}$。

对于不同的子任务，作如下约定：

 | 子任务编号 |    $n$    |     $\textit{thres}$     | 特殊性质 | 分值 |
| :--------: | :-------: | :---------: | :------: | :--: |
|    $1$     | $\le10^5$ |  $\le10^9$   |  **有**  | $10$ |
|    $2$     |   $\le20$    | $\le10$ |    无    | $15$ |
|    $3$     | $\le10^7$ | $=2$  |    无    | $20$ |
|    $4$     | $\le10^7$ | $\le10^7$ |    无    | $25$ |
|    $5$     | $\le10^7$ | $\le10^9$ |    无    | $30$ |

- **特殊性质**：保证程序正确生成的序列 $A$ 中不存在相等元素。

- **注意**：本题时限为 $0.5\text s$。

- ~~热知识：《世末歌者》演唱于夏日，显然不在雨水节气。~~


## 样例 #1

### 输入

```
7 20120712 21702102 4```

### 输出

```
43```

## 样例 #2

### 输入

```
10 114514 19198 10```

### 输出

```
256```

# 题解

## 作者：FjswYuzu (赞：5)

Subtask 2 就是枚举子序列模拟并交换，比较字典序，时间复杂度 $O(n2^n)$。

注意到我们想让字典序最小，那么更小的东西放在越前面当然越好。Subtask 1 就是不用考虑重复元素的情况。在处理位置 $i$ 时，若在后面存在比 $a_i$ 更小的数，将其中最小的数的位置记为 $p$，交换 $a_p$ 与 $a_i$ 的值，并且根据题意不能再交换 $i,i+1,\cdots,p$ 里面的数，我们接下来处理 $p+1$ 位即可。

考虑 Subtask 3，性质是值只有 $0$ 或 $1$。假设我们现在要调换一个 $1$ 和 $0$ 的位置，而 $1$ 后面有很多个 $0$，换哪一个更优呢？

不失一般性，我们假设 $1$ 后面的 $0$ 的位置为 $p,q$，且 $p<q$。显然，无论交换 $p$ 还是 $q$，$a[i+1\dots p-1]$ 都是不会改变的。交换之后 $a_i$ 自然是 $0$。然而交换 $p$ 的话，$a_p$ 就会变成 $1$，交换 $q$ 的话 $a_p$ 仍然保持 $0$，显然交换 $q$ 更优秀。

那么在这个 Subtask 下我们不难得到一个策略，也就是如果要交换，选择这个位置后面的离当前位置最远的最小值交换即可。

不难发现我们可以将这个策略拓展到任意值域下，**如果要交换**，就选择这个位置后面的离当前位置最远的最小值交换即可。

如何处理位置 $i$ 后面的离当前位置最远的最小值的位置 $p_i$ 呢？这个问题只跟后缀有关，我们从后往前处理。假设当前正在处理 $p_i$。如果 $a_i\geq a_{p_{i+1}}$，那么 $p_i \gets p_{i+1}$；否则 $p_i \gets i$。

下面给出核心代码。

```cpp
int main(){
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();
	a[0]=2147483647;
	for(int i=n;i;--i)	pos[i]=(a[i]<a[pos[i+1]]?i:pos[i+1]);
	for(int i=1;i<=n;++i)
	{
		if(a[i]==a[pos[i]])	continue;
		swap(a[i],a[pos[i]]),i=pos[i];
	}
	unsigned long long ans=0;
	for(int i=1;i<=n;++i)	ans+=(unsigned long long)i*(unsigned long long)a[i];
	printf("%llu",ans);
	return 0;
}
```


---

## 作者：TernaryTree (赞：5)

给定长为 $n$ 的序列 $a$，你需要选定 $a$ 的一个长度为偶数 $m$ 的子序列 $b$，对于任意 $1\le i\le \dfrac m2$，交换 $b_{2i-1}$ 和 $b_{2i}$，最后将 $a$ 中原来 $b$ 的位置替换成交换过后的 $b$，求如何选取子序列使得 $a$ 的字典序最小。

首先我们对交换的每对数进行考虑。如果将交换的一对数看做区间，那么根据子序列的性质可以知道这些区间之间不会相互覆盖或者有交集。也就是说，这些区间之间都是相对独立的。

字典序最小意味着什么呢？如果存在两个长度为 $k$ 的序列 $s$ 和 $t$，那么即使对于任意 $2\le i\le k$，有 $s_i\lt t_i$，但如果一旦 $s_1>t_1$，那么就前功尽弃，此时 $s<t$。

这给我们的启发是，如果要使 $a$ 字典序最小，那么即使后面再怎么小，前面很大都没有用。因此，我们需要尽可能使 $a_1$ 小，在 $a_1$ 最小的情况下，尽可能使 $a_2$ 小，以此类推。

如何使 $a_1$ 最小？这个时候，我们不需要考虑 $a_2$ 的大小情况，因为 $a_1$ 是最重要的。

初步思路是，找出在下标在 $2\sim n$ 时的最小值，然后与 $a_1$ 交换。

这个时候会出现两个问题：

- 如果最小值比 $a_1$ 大，怎么处理？

  这说明 $a_1$ 已经是最小的了，不需要进行交换。这个时候我们就处理下个元素 $a_2$。
  
- 如果有多个最小值，怎么处理？

  先给出结论：选最靠后的那一个。
  
  很好证明：因为 $a_1$ 此时比最小值大，那么交换以后，由于字典序越靠前权重越大，所以如果把 $a_1$ 放在最前面，字典序一定是比把其放在最后面要大的。
  
  但是，根据我们前面提到的“区间独立性”，前面的最小值都无法进行改变了，如果后面最小值需要进行改变，怎么办呢？
  
  我们考虑对最小值模拟刚才的运算。因为这个最小值是下标区间 $2\sim n$ 的最小值，而最小值的位置又在 $a_1$ 后面，所以对这个最小值求其后面的最小值肯定是比其本身要大或者相等的。
  
  这也就说明，这个区间内的最小值绝对不会进行改变。
  
这个时候再回到我们的“区间独立性”。假定这个时候我们已经将 $a_1$ 与 $a_{t}$ 交换，其中 $t$ 表示最小值的下标，根据区间独立性，下一个区间的开头必然 $> t$。于是，我们只要将上文的所有 $a_1$ 替换为 $a_{t+1}$ 重复一遍上述过程即可。整个过程用 `while` 循环实现。

注意，此处 `while` 循环的结束条件并非 $s\le n$（$s$ 表示每个区间的开头位置），因为每个区间长度至少为 $2$，所有结束条件为 $s\le n-1$。

这样，我们的最劣时间复杂度为 $\Theta(n^2)$，可能不能通过此题。如何优化呢？

注意到求最小值部分可以预处理出后缀最小值的位置，每次循环 $\Theta(1)$ 查询即可。这样，我们可以把时间复杂度优化至 $\Theta(n)$，容易通过此题。

到这里思路部分基本上讲完了。还有一些小的细节，比如说怎么对 $2^{64}$ 取模：

我们知道 `unsigned long long` 的数据范围是 $[0,2^{64})$。刚刚好是一个数对 $2^{64}$ 取模的结果的取值范围。因此使用 `unsigned long long` 存储答案，不需要取模，全程自然溢出即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e7 + 1; // Set a right value according to your solution.

long long int n, a[MAXN + 1];
int suf[MAXN + 1];

namespace Generator {


unsigned long long k1, k2;

int thres;

inline unsigned long long xorShift128Plus() {
    unsigned long long k3 = k1, k4 = k2;

    k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);

    return k2 + k4;
}

inline void generate() {
    for (register int i = 1; i <= n; ++i) {
        a[i] = xorShift128Plus() % thres;
    }
}

} // namespace Generator.

void init() {
    suf[n] = n;
    for (int i = n - 1; i >= 1; i--) {
        suf[i] = (a[i] < a[suf[i + 1]] ? i : suf[i + 1]);
    }
}

unsigned long long solve() {
    int s = 1;
    while (s <= n - 1) {
        int m = suf[s + 1];
        if (a[s] > a[m]) {
            swap(a[s], a[m]);
            s = m + 1;
        } else s++;
    } 

    unsigned long long ans = 0;
    for (register int i = 1; i <= n; ++i) {
        // cout << a[suf[i]] << " ";
        ans += (unsigned long long) a[i] * (unsigned long long) i;
    }
    // cout << endl;
    return ans;
}

int main() {
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();

    init();
    cout << solve();

    return 0;
}
```

---

## 作者：wangzl (赞：3)

## 题解 P8475 「GLR-R3」雨水
## 简要题意
感觉原题描述比较复杂QAQ  
本题是给一个长度为 $n$ 的序列 $a$，希望从中提取子序列 $l$（$|l|$ 为偶数），并从前往后两两交换元素，将其放回原位置。使修改后的子序列的字典序最小。  
## 基本思路：
先举个例子：$a = \{\color{red}3\color{black},2,\color{red}1\color{black},\color{red}5\color{black},\color{red}4\color{black}\}$，取出子序列 $l=\{\color{green}3\color{black},\color{green}1\color{black},\color{blue}5\color{black},\color{blue}4\color{black}\}$，两两交换后 $l'=\{1,3,4,5\}$，按原顺序放回原序列，变为 $a'=\{1,2,3,4,5\}$。显然，此时 $a'$ 的字典序最小。  
那么，我们该怎么移动序列呢？首先，要使字典序尽可能小，我们就要把最小的放在第一位，可以证明，如果使用其他的方法，最小的那个数没有排在第一位，那么处理后的序列一定不是字典序最小的子序列。因为是两两交换，假设 $a_i$ 与 $a_j$ 进行了第一次交换 $(i<j)$，那么下一次交换就要从 $a_{j + 1}$ 开始，如果从 $a_{i+1}$ 继续遍历进行交换，显然不符合我们**两两依次交换**的原则，是错误的交换方法。这样每一次交换后令 $i=j+1$ 进行下一次交换，直到 $i=n$ 为止，这样每一次贪心去寻找，找到的一定是最优解。  
* * *
当查找时 $a_i$ 后出现多个最小元素怎么办呢？我们应该交换最后一个。因为进行交换时的元素满足 $a_i>a_j(i<j)$，显然，我们要把更大的 $a_i$ 放在最后那个最小元素的位置，才可以使答案字典序最小。  
再举个例子：$a=\{2,1,3,1,1\}$，我们发现，当 $i=1,a_i=2$ 时，其后最小值为 $1$，而可以交换的 $j=2,4,5$，交换后可以变为 $a'=\{1,2,3,1,1\},a''=\{1,1,3,2,1\},a'''=\{1,1,3,1,2\}$，可见与最后一个最小元素交换得到的字典序是最小的。所以，我们在遍历 $a_{j_{\min}}$ 时，要自 $n$ 向 $i+1$ 倒序遍历。  
* 注意：本题要求答案对 $2^{64}$ 取模，`unsigned long long` 的自然溢出就等于对 $2^{64}$ 的取模。
## $\text{std:}$
```cpp
#include<bits/stdc++.h>
typedef unsigned long long ull;
const int MAXN = 1e7; // Set a right value according to your solution.
int n, kind;
int a[MAXN + 1];
ull sum; 
namespace Generator {
	unsigned long long k1, k2;
	int thres;
	inline unsigned long long xorShift128Plus() {
		unsigned long long k3 = k1, k4 = k2;
		k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
		return k2 + k4;
	}
	inline void generate() {
		for (int i = 1; i <= n; ++i) {
			a[i] = xorShift128Plus() % thres;
		}
	}
}
int main() {
	scanf("%d", &n);
	scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
	Generator::generate();
	for (int i = 1; i <= n; ++i) {
		int minn = 0x7fffffff, sce;
		for (int j = n; j > i; --j) 
			if (a[j] < minn) 
        	minn = a[j], sce = j;
		if (minn < 0x7fffffff && a[i] > a[sce])
			std::swap(a[i], a[sce]),
			i = sce;
	}
	for (int i = 1; i <= n; ++i) {
		sum = sum + (ull)i * a[i];
	}
	printf("%llu", sum);
	return 0;
}
```

------
**时间复杂度分析**：本代码看似两重循环，但每次 `i` 从 `j + 1` 继续所以每个元素只被遍历 $1$ 次，时间复杂度为 $\mathcal{O(n)}$。  
有问题欢迎评论区留言哦！

---

## 作者：iyaang (赞：2)

# 题解：「GLR-R3」雨水

[题目链接](https://www.luogu.com.cn/problem/P8475)

### 前言

先吐槽一下，这个英文是真的坑。

`const int MAXN = 712; // Set a right value according to your solution.`

为啥不能直接把数组下标设为最大值呢，还要挖个坑考考英文。

然后这个随机数据卡不掉 $O(n^2)$ 做法啊，感觉大为震撼。

### 正文

#### 更简化的题意
给定一个序列 $A$，从中选取下标单调递增的一些数，相邻的两两交换，但仅局限于下标为奇数的和它右边的数这样交换，再放回原序列，使得新得到的序列字典序尽可能小。

#### 解题
一道很不错的贪心，对于字典序最小，假设我们只能换一次，那肯定将整个序列里面最小的那个数换到最前面。推广到多次操作，再交换的数肯定只能从最小的那个数右边去找，否则不符合操作规则。

对于如果有多个最小的数，我们应该交换哪一个呢？因为字典序尽可能小，同样可以推出大的应该尽可能往后放，因此在寻找最小的数时，要找下标更大的。

由此我们可以倒序跑一遍记录下对于每一个数它的右侧的最小值，再正着跑一遍进行交换操作，这样的总时间复杂度就是 $O(n)$。

答案自然溢出即可。

Code
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define MAX 10000002
#define INF 999999999
using namespace std;

int n,a[MAX];

namespace Generator
{
	ull k1,k2;
	int thres;
	inline ull xorShift128Plus()
	{
		ull k3=k1,k4=k2;
		k1=k4,k3^=(k3<<23),k2=k3^k4^(k3>>17)^(k4>>26);
		return k2+k4;
	}
	inline void generate()
	{
		for(int i=1;i<=n;i++)
			a[i]=xorShift128Plus()%thres;
	}
}

unsigned int key[MAX],pos[MAX];
ull ans;
inline void work()
{
	key[n+1]=INF;
	for(int i=n;i>=2;i--)
	{
		key[i]=key[i+1],pos[i]=pos[i+1];
		if(a[i]<key[i]) key[i]=a[i],pos[i]=i;
	}
	int mink,minp;
	for(int i=1;i<n;i++)
	{
		mink=key[i+1],minp=pos[i+1];
		if(mink<a[i]) swap(a[i],a[minp]),i=minp;
	}
	return;
}

int main()
{
	scanf("%d",&n);
	scanf("%llu %llu %d",&Generator::k1,&Generator::k2,&Generator::thres);
	Generator::generate();
	work();
	for(int i=1;i<=n;i++)
		ans+=(unsigned long long)a[i]*i;
	cout<<ans;
	return (0-0);
}
```

---

## 作者：sixrc (赞：1)

考虑贪心，思考什么时候使得字典序最小。

很显然我们希望把越在前面的数换成越小的数，因为类似 $0123$ 的字典序是要严格小于 $1123$。再例如如果我们可以把 $2234$ 换成 $2034$ 和 $0234$，我们肯定会优先将其变成 $0234$，纵使在第二位上它不如 $2034$，但它第一位更优，就严格优于了 $2034$。

换句话说字典序这个条件就是来骗人的，这题考察的是对基础概念的转化。

考虑我们要将每个数和哪个数交换。如果我们从第一个数开始贪心的话，那每次寻找的肯定是 $A[i,n]$ 中的最小值，因为我们要使得更高位的更小。所以我们预处理一个后缀最小值记为 $S_i$，以及它从后往前第一次出现的位置记为 $P_i$，每次将 $A_i$ 与 $A_{P_i}$ 交换，并从 $P_i+1$ 继续寻找。

然而这题有一些坑，85 pts 的可以看一下下面这组数据：

Data Input：

```
4
1 3 4 3
```

Wrong Output：

`31`

Right Output：

`32`

把题目的输入方式更换为常规输入就可以使用了。在这组数据中，如果按照上面的方法，在查找到 $A_2=3$ 时它会跳到 $A_4=3$，最后形成的序列依然为 `1 3 4 3`，但我们发现存在一种更优的方式，即将 $A_3=4$ 和 $A_4=3$ 交换。也就是说，需要满足 $A_{P_i} \ne A_i$ 才交换，因为 $(i,P_i)$ 中可能存在使得答案更优的数。

### Code：

```c++
#include <cstdio>
#include <iostream>
using namespace std;
const int MAXN = 1e7 + 5;
int n, a[MAXN], suff[MAXN], p[MAXN];
unsigned long long s;
namespace Generator {
unsigned long long k1, k2;
int thres;
inline unsigned long long xorShift128Plus() {
    unsigned long long k3 = k1, k4 = k2;
    k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}
inline void generate() {
    for (int i = 1; i <= n; ++i) {
        a[i] = xorShift128Plus() % thres;
    }
}
}
const unsigned long long mo = (1 << 64);
int main() {
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();
    for (int i=n; i>=1; i--){
    	if (i == n) suff[i] = a[i], p[i] = i;
    	else{
    		if (a[i] < suff[i+1]){
    			suff[i] = a[i];
    			p[i] = i;
			}
			else suff[i] = suff[i+1], p[i] = p[i+1];
		}
	}
	for (int i=1; i<=n;){
		int nxt = suff[i], nxtp = p[i];
		if (nxtp > i && a[nxtp] != a[i]){
			int tmp = a[nxtp];
			a[nxtp] = a[i], a[i] = tmp;
			i = nxtp + 1;
		}
		else i ++;
	}
	for (int i=1; i<=n; i++){
		s = s + 1ull * i * a[i];
	}
	printf ("%llu\n", s);
    return 0;
}
```

---

## 作者：CI_is_safe (赞：1)

## P8475 「GLR-R3」雨水 题解
[题目传送门](https://www.luogu.com.cn/problem/P8475)
### 思路
观察是自己选择一个序列 $1\sim n$ 的子序列，而且交换方式是子序列相邻两项的下标位置的元素交换，使得字典序最小，便应该使得越前面的位置越小，即从第 $1$ 个数到第 $n$ 个数，每次观察这个数是否是可能的最小值，如果不是则交换。但如果可以与这个数交换的最小值有多个怎么办呢？我们举个例子，比如序列 $ A=1,1,3,0,0,1,3$，如果把位置 $1,4$ 交换，得到 $0,1,3,1,0,1,3$，如果交换 $1,5$，则得到 $0,1,3,0,1,1,3$，第二个序列字典序更小，所以如果有多个相同的最小值可供选择，应该选择最靠后的，当然如果这个位置已经是最小值则应该直接跳过，因为如果这个位置交换了，则下次可以交换的位置就少了。对于交换位置的选取，可以用一个后缀最小值记录下标解决，时间复杂度 $O(n)$。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
const int N=10000001;
int n,a[N],thres,minn[N];
ll k1,k2;
ll rd(){
	ll k3=k1,k4=k2;
	k1=k4;
	k3^=(k3<<23);
	k2=k3^k4^(k3>>17)^(k4>>26);
	return k2+k4;
}
int main(){
	scanf("%d%llu%llu%d",&n,&k1,&k2,&thres);
	for(int i=1;i<=n;++i)a[i]=rd()%thres;
	minn[n]=n;
	for(int i=n-1;i;--i)minn[i]=a[i]<a[minn[i+1]]?i:minn[i+1];
	for(int i=1;i<=n;++i){
		int t=minn[i];
		if(a[i]>a[t]){
		    swap(a[i],a[t]);
		    i=t;
		}
	}
	ll res=0;
	for(int i=1;i<=n;++i)res+=1ull*i*a[i];
	printf("%llu",res);
    return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：1)

## 题意
有序列 $A$，令 $k$ 为正整数且 $k\le \dfrac{n}{2}$，构造一个长度为 $2k$ 的严格上升序列 $P$ ，对于 $\forall i\in[1,k]$，交换 $A_{i\times2},A_{i\times2+1}$ 得到序列 $A'$，使 $A'$ 的字典序尽可能小。
## 思路
考虑贪心。

首先 ~~根据直觉~~ ，我们每次要将当前串的开头与当前串中的最小值交换  
再 ~~观察样例~~ 发现如果最小值有多个，就要交换最后面的最小值

设当前串开头下标为 $u$ ，最后的最小值的下标为 $v$  
我们交换 $A_u,A_v$ 后便只需考虑串 $[v+1,n]$  
考虑用递归分治实现。

递归核心代码：
```cpp
void dfs(int u){
	if(u>=n)return;
	int v=u,t=a[u];
	for(int i=u+1;i<=n;i++){
		if(a[i]<=t){
			t=a[i];
			v=i;
		}
	}
	swap(a[u],a[v]);
	dfs(v+1);
}
```
但是这样我们只能得85分。  
原因在于如果 $A_u$ 本来就小于等于 $A_v$ 的话，交换是没有意义的

加特判即可：
```cpp
void dfs(int u){
	if(u>=n)return;
	int v=u,t=a[u];
	for(int i=u+1;i<=n;i++){
		if(a[i]<a[u]&&a[i]<=t){
			t=a[i];
			v=i;
		}
	}
	if(v){
		swap(a[u],a[v]);
		dfs(v+1);
	}
	else dfs(u+1);
}
```
期望 $O(n)$ ，最坏 $O(n^2)$ （数据是真水）  
预处理最小值即可稳定 $O(n)$。
## 最终完整code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1e7;
int a[MAXN + 1],n;
unsigned long long ans;//ull自然溢出取模
pair<int,int>minn[MAXN+5];//表示[i,n]间的最小值，第一维存值，第二维存下标

namespace Generator {

	unsigned long long k1, k2;
	int thres;

	inline unsigned long long xorShift128Plus() {
	    unsigned long long k3 = k1, k4 = k2;
	    k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
	    return k2 + k4;
	}
	
	inline void generate() {
	    for (int i = 1; i <= n; ++i) {
	        a[i] = xorShift128Plus() % thres;
	    }
	}

}

void dfs(int u){
	if(u>=n)return;
	if(minn[u+1].first<a[u]){
		int v=minn[u+1].second;
		swap(a[u],a[v]);
		dfs(v+1);
	}
	else dfs(u+1);
}

int main() {
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();
    minn[n+1].first=0x7fffffff;
    for(int i=n;i>=1;i--){
    	if(a[i]<minn[i+1].first)
    		minn[i]=make_pair(a[i],i);
    	else
    		minn[i]=minn[i+1];
	}
    dfs(1);
    for(int i=1;i<=n;i++)
    	ans+=1ull*i*a[i];
    printf("%llu",ans);
    return 0;
}
```


---

## 作者：zesqwq (赞：1)

# P8475 「GLR-R3」雨水

阅读题目之后，发现这东西应该是个贪心。

首先，因为是字典序，所以如果开头不是最小的数，我们要把开头换成最小，然后再解决与开头交换的数的后面的字典序要小的子问题。

想到这个策略，你就可以通过Subtask1，获得 $10pts$。

那么问题来了，假如有在开头后面有多个最小值，我们应该如何解决呢？

假设有这么一串数:

**大 ？ ？ 最小 ？ ？ ？ 最小 ？ ？**

其中两个最小数一样小，大数不一定一样的，问号是比小数大的数。

这是我们应该怎么交换才能使字典序最小呢？

对于换出第一个大数，我们有2中方案:

1. 将开头那个大数和第4个数交换
2. 将开头那个大数和第7个数交换

如果我们执行了操作1，那么我们就只能去试图让第五个及之后的的数字典序更小了。

如果我们执行了操作2，那么我们就只能去试图让第八个及之后的数字字典序更小了。

我们发现操作一之后，第四个数会很大，而操作二则不存在这个问题，所以如果开头不是最小，我们应该交换开头与最小中最靠右的数，然后再解决从交换数下一个开始的子问题。

$Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e7 + 10;
int n, a[N + 1];

namespace Generator {

unsigned long long k1, k2;
int thres;
inline unsigned long long xorShift128Plus() {
    unsigned long long k3 = k1, k4 = k2;
    k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}

void generate() {
    for (int i = 1; i <= n; ++i) {
        a[i] = xorShift128Plus() % thres;
    }
}
}
int nxt[N];
int main() {
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    if (Generator::thres != 2) Generator::generate();
    else 
    	for (int i = 1; i <= n; ++i) a[i] = Generator::xorShift128Plus() & 1; 
    nxt[n + 1] = n;
    for (int i = n; i; --i) {
		if (a[i] < a[nxt[i + 1]])
			nxt[i] = i;
		else
			nxt[i] = nxt[i + 1];
	}
	int l = 1;
	while (l < n) {
		if (a[nxt[l]] < a[l]) {
			swap(a[l], a[nxt[l]]);
			l = nxt[l] + 1;
		} else
			++l;
	}
	unsigned long long hash = 0;
	for (int i = 1; i <= n; ++i) {
		hash += (unsigned long long)a[i] * i;
	}
	printf("%llu", hash);
    return 0;
}
```


---

## 作者：Disjoint_cat (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8475)

## P8475 雨水

### 1.题意

给定一个长度为 $n$ 的数列，你可以执行以下操作一次：

选定若干个数（必须为偶数个，可以是 $0$ 个），相邻两个数交换。

求最终得到的字典序最小的序列。

### 2.解法

**贪心**。

考虑第一个数，如果是最小的数，那么不应进行交换，否则显然不如这样更优。（这里需要特判，不然会被卡成 $85$ 分。）然后从第二个数重新开始判断。

否则，应该选定第一个数和**第一个出现的**最小值，并将其交换。然后从最小值的下一个数继续判断。

这样，我们满足了第一个数尽量小，而且为之后的数也留下了更多交换的机会，所以这个算法是正确的。

但是，这样暴力最坏时间复杂度是 $O(n^2)$，面对 $10^7$ 的数据显然不能通过。

考虑优化，一开始的时候就倒序计算出最小值，在计算时直接使用。

这样时间复杂度就降到了 $O(n)$，没看懂可以看代码。

### 3.code

算上数据生成器也就 $36$ 行，核心代码不到 $10$ 行。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=10000005;
int n,a[N],mi[N],mit[N];
unsigned ll ans;
namespace Generator {
unsigned long long k1, k2;
int thres;
inline unsigned long long xorShift128Plus() {
    unsigned long long k3 = k1, k4 = k2;
    k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}
inline void generate() {
    for (int i = 1; i <= n; ++i) {
        a[i] = xorShift128Plus() % thres;
    }
}
}
int main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>Generator::k1>>Generator::k2>>Generator::thres;
    Generator::generate();
	mi[n+1]=2000000000;
	for(int i=n;i>=1;i--)
		if(a[i]<mi[i+1])mi[i]=a[i],mit[i]=i;
		else mi[i]=mi[i+1],mit[i]=mit[i+1];
	for(int i=1;i<=n;)
		if(mi[i]<a[i])swap(a[i],a[mit[i]]),i=mit[i]+1;
		else i++;
	for(int i=1;i<=n;i++)ans+=(ll)i*a[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：larsr (赞：0)

闲话：我觉得这道题应该说明一下数据是随机的。就因为这个本来想到正解了，以为会卡 $O(n^2)$,结果在这题耗了半天才知道这道题不会卡 $O(n^2)$。

先给大家说一下**子序列**的定义：
>对于序列 $a$，可任意取几个数，按照它们在原序列 $a$ 的位置顺序排列，排列后的序列就是 $a$ 的**子序列**。例如 $a=\{2,1,3\}$，它的**子序列**有 $\{2, 1, 3\},\{2 ,1\},\{2,3\},\{1,3\},\{2\},\{1\},\{3\}$。

使用贪心思想，为了字典序变小，所以先考虑高位。为了让高位变小，那可以让它与最小数（那个位置后面的最小数）交换。假如（后面的）最小数有很多一样的怎么办？先举个例（~~栗~~）子。
## 栗子
假如序列 $A$ 是这样 $t\dots s\dots s$，$t$ 为最高位，$s$ 为最小的数。

最高位与第一个 $s$ 交换后是这样 $s\dots t\dots s$。

与第二个交换后是这样 $s\dots s\dots t$。

它们按照字典序比较，是 $s\dots s\dots t$ 更小，所以如果有多个相同的最小数就与位置最靠后的数交换。
## Next
为了让**子序列** P 满足**子序列**的定义（所有的数的排列方式是按在原序列的位置顺序排列的）。那么下一个考虑的位置应该是 $t+1$，$t$ 代表上一次**被**交换的数。
## 特判
如果要考虑的位置就是最小的数呢，那就不考虑这个位了，考虑它的下一位。

## 核心代码如下
```
    	int now = 1;\\现在要考虑的位置
    	while(now < n)
    	{
    		ull minn = 1e10, w = now;
    		for(int i = now + 1; i <= n; i++)\\查找最小值
    		if(a[i] <= minn)
    		minn = a[i], w = i;
    		if(a[now] <= minn){now++;continue;}\\特判
    		swap(a[now], a[w]);
    		now = w + 1;
	}
    	ull ans = 0;
	for(ull i = 1; i <= n; i++)
	ans = ans + i * a[i];
```

---

## 作者：CReatiQ (赞：0)

### 题意概述

从给定长为 $n$ 序列 $A$ 中选出一个偶数长度子序列，邻项交换位置，求可构造出字典序最小序列 $A'$ 的 $(\sum_{i=1}^n i \times A'_i) \bmod 2^{64}$。

$(1 \leq n \leq 10^7)$

---

### 思路

令序列字典序最小就是让最前面的位尽可能小，所以不难想出贪心的方式：将整个序列最小的数与首位的数交换，再对最小的数后半部分剩余序列递归考虑。

寻找当前序列最小数的复杂度是 $\mathcal{O}(n)$，所以这个算法的最坏时间复杂度是 $\mathcal{O}(n^2)$。

你可能会想：我们能够把数列离散化后丢进堆里，这样算法最坏时间复杂度可以降至 $\mathcal{O}(n \log n)$。但是这样的复杂度我们仍然不能接受。

在上面算法的过程中，我们一直是已知目前要替换的一个数的位置，而去剩下的区间中寻找一个最小数。

既然我们从前往后递归寻找剩余区间最小数，它们应当是单调递增的。

换而言之，它们一定是第一个比它们身后的区间最小数小的数。

所以，正难则反，我们可以选择倒序扫描数组：

1. 如果遇到的数比当前最小数大，考虑将它作为当前最小数的交换目标。

2. 如果遇到的数与当前最小数相等，交换目标不变。

3. 如果遇到的数比当前最小数小，说明它身后是上面 $\mathcal{O}(n^2)$ 算法中的一个剩余序列。将当前最小数与交换目标交换，用遇到的数更新当前最小数。

算法复杂度为 $\mathcal{O}(n)$。

---

### Code

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
#define ull unsigned long long
#define MAXN (int)(1e7+233)
#define rep(i,l,r) for (int i=l;i<=r;i++)
#define per(i,r,l) for (int i=r;i>=l;i--)

int n,mit,goal;
bool is_g;
ull ans,mi=1e9+7,A[MAXN];

namespace RDP
{

	ull k1,k2;
	int mod;
	
	inline ull Rdm()
	{
	    ull k3=k1,k4=k2;
	    k1=k4,k3^=(k3<<23),k2=k3^k4^(k3>>17)^(k4>>26);
	    return k2+k4;
	}
	
	inline void input()
	{
	    rep(i,1,n)
	        A[i]=Rdm()%mod;
	}

}

inline void swap(ull &x,ull &y) { ull t=x;x=y,y=t; }

signed main()
{
	scanf("%d%llu%llu%d",&n,&RDP::k1,&RDP::k2,&RDP::mod);
	RDP::input();
	per(i,n,1)
	{
		if (A[i]<mi)
		{
			if (is_g)
			{
				is_g=0;
				swap(A[goal],A[mit]);
			}
			mit=i,mi=A[i];
		}
		else if (A[i]>mi)
			is_g=1,goal=i;
	}
	if (is_g) swap(A[goal],A[mit]);
	rep(i,1,n) ans+=i*A[i];
	printf("%llu",ans);
	return 0;
} 
```


---

## 作者：JackMerryYoung (赞：0)

# 前言

T2, 花了半个小时，大无语。

# 正文

上图：

![](https://cdn.luogu.com.cn/upload/image_hosting/x6y3am7j.png)

为了下降字典序，显然要拉低前面。需要将最低的与其交换。

然后需要把字典序进一步下降，所以要放到后面，越后面越好。

因此就找最小，数值相同就比较那个更后面。然后从找到的位置的下一个位置继续找。

复杂度最坏 $\mathcal{O}(N^2)$, 在数据随机的情况下能过。

# 代码

伪代码：

``` python
now = 1
While(now <= N):
    minn = INF;
    For(i From N Downto (now + 1) Step 1):
        If(arr[i] < minn):
        	minn = arr[i]

    If(minn >= arr[now]):
        Inc now
        Continue

    For(i From N Downto (now + 1) Step 1):
        If(arr[i] == minn):
            swap(arr[now], arr[i]), now = i + 1
            Break

ans = 0;
For(i From 1 To N Step 1)
    ans += arr[i] * i

```

---

## 作者：NightTide (赞：0)

~~关于这道题目卡 $O(n\log n)$ 但是放 $O(n^2)$ 我也是很疑惑。~~

我们发现，题目要求的是**字典序最小**的序列。但凡涉及了**字典序最小**，答案或多或少的都会带点贪心思想。

那我们也来贪一贪。考虑当前枚举到第 $i$ 个点，如果后面有比它更小的数，那显然把它们交换过来是更优的。如果有多个，那显然也是最小的那一个交换过来是最优的。如果最小的还有多个，那肯定把当前这个和最后一次出现的交换是最优的。

同时，由于题目要求 $P$ 是 $\lang 1,2,\dots,n\rang$ 的一个子序列，所以假设我们这次将 $i$ 和 $j$ 位置上的元素交换了，接下来就不能对下标 $k\le j$ 的元素动手动脚了，下一个枚举到的点就是 $j + 1$ 了。

如果这么说还不明白的话，我们模拟一下样例：

---
样例一：

```cpp
1 1 3 0 0 1 3
↑       ↑
i       j

起初，i = 1，我们发现 i 以后最小的数是 0，它是小于 a[i] 的，而 j = 5 是 0 最后一次出现的位置，所以将 a[1] 和 a[5] 交换。

0 1 3 0 1 1 3
          ↑
          i

接下来 i 移动到 6 的位置，发现后面没有小于 a[i] 的数了。

0 1 3 0 1 1 3
            ↑
            i

最后，i 移动到 7，程序结束。
```

---
样例二：
```cpp
2 8 0 6 2 2 1 7 8 3
↑   ↑
i   j

起初，i = 1，我们发现 i 以后最小的数是 0，它是小于 a[i] 的，而 j = 3 是 0 最后一次出现的位置，所以将 a[1] 和 a[3] 交换。

0 8 2 6 2 2 1 7 8 3
      ↑     ↑
      i     j

接下来 i 移动到 4 的位置，我们发现 i 以后最小的数是 1，它也是小于 a[i] 的，而 j = 7 是 0 最后一次出现的位置，所以将 a[4] 和 a[7] 交换。

0 8 2 1 2 2 6 7 8 3
              ↑   ↑
              i   j

接下来 i 移动到 8 的位置，我们发现 i 以后最小的数是 3，它同样是小于 a[i] 的，而 j = 10 是 3 最后一次出现的位置，所以将 a[8] 和 a[10] 交换。

0 8 2 1 2 2 6 3 8 7
                    ↑
                    i

最后，i 移动到 11，程序结束。
```

---
至于实现，我们可以维护一个后缀最小值最后一次出现的位置 $p$，而且是最后一次出现的位置，然后将 $a_i$ 与 $a_{p_i}$ 交换，再令 $i = p_i + 1$，然后重复以上步骤直到 $i \ge n$。

我的程序中是用 $nxt$ 来存储后缀最小值最后一次出现的位置的，大家看的时候转换一下就好：
```cpp
#include<bits/stdc++.h>
#define MAXN 10000010
using namespace std;
typedef unsigned long long ull;
int n, m, k;
int a[MAXN], nxt[MAXN];
namespace Generator{
    ull k1, k2;
    int thres;
    inline ull xorShift128Plus() {
        ull k3 = k1, k4 = k2;
        k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
        return k2 + k4;
    }
    inline void generate() {
        for (int i = 1; i <= n; ++i) {
            a[i] = xorShift128Plus() % thres;
        }
    }
}
int main(){
    scanf("%d%llu%llu%d", &n, &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();
    nxt[n] = n;
    for(int i = n - 1; i >= 1; i--){
        if(a[i] < a[nxt[i + 1]]) nxt[i] = i;
        else nxt[i] = nxt[i + 1];
    }
    for(int i = 1; i < n; i++){
        if(a[nxt[i + 1]] < a[i]){
            swap(a[i], a[nxt[i + 1]]);
            i = nxt[i + 1];
        }
    }
    ull ans = 0;
    for(int i = 1; i <= n; i++) ans += (ull)i * a[i];
    printf("%llu\n",ans);
    return 0;
}
```

---

## 作者：Cure_Wing (赞：0)

### update:
* 修改了排版的空格问题。

### 题目
* [P8475 「GLR-R3」雨水](https://www.luogu.com.cn/problem/P8475)

### 解析
* 我们可以将序列分割成多段：$a_1,a_2,...a_{b_1}||a_{b_1+1},...,a_{b_2}||a_{b_2+1},...,a_{b_k}||a_{b_k+1},...,a_n$，交换序列为 $\left(1,b_1,b_1+1,b_2,b_2+1,...,b_k,b_k+1,b_n\right)$。
* 此时显然满足 $a_1>a_{b_1},a_{b_1+1}>a_{b_2},...,a_{b_k+1}>a_n$ 时交换是有意义的。
* 为了使字典序最大，最小的数字一定要放在尽量的前，所以交换的数字组 $(i,j)$ 应满足 $a_i>a_j$ 且 $a_j=\min\limits^n_{k=i+1}a_k$，这样就可以将最小的数字转移到了前面，其余序列区间也这样操作即可。
* 若无法当前找出有意义的序列区间，则可以将左端点向右移。
* 由于数据较为随机，可以直接暴力跳最小值，不会有时间危险。

### 代码
* 这里就只放核心部分了，其余部分请抄题目或自己实现。

```cpp
inline void work(){
	for(int i=1;i<=n;++i){
		int cnt=i;
		for(int j=i+1;j<=n;++j){
			if(a[j]<=a[cnt])
				cnt=j;
		}
		if(a[i]!=a[cnt]) std::swap(a[i],a[cnt]),i=cnt;
	}
}
```

---


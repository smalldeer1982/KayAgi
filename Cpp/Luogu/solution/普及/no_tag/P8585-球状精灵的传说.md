# 球状精灵的传说

## 题目描述

你在人马座的三叶星云里，发现了一类新生物：球状精灵。

球状精灵是一类外形为标准椭球形的精灵。每只精灵有三个维度的**幅度** $\{r_1,r_2,r_3\}$，分别表示其三维世界中三个方向上的尺度。

而关于球状精灵有一个传说：族群中**声望值最高**的球状精灵会获得升入四维宇宙的机会。而某个幅度为 $\{r_1,r_2,r_3\}$ 的球状精灵的声望值 $\rho$ 定义为：

$$\rho=\left\lfloor{\frac{1}{4}\min\{r_1,r_2,r_3\}^3}\right\rfloor$$ 

其中 $\left\lfloor\right\rfloor$ 表示下取整。

同时，每只球状精灵可以选择与别的精灵**拥抱至多一次**，之后两者会合成为**一个新的球状精灵**。两只球状精灵能够拥抱，当且仅当它们**存在至少一个幅度面能够重合**。具体来讲，即需要两只精灵的幅度**存在至少两个值相同**。

例如，两只精灵三个方向上的幅度分别为 $\{a,x,y\}$ 和 $\{b,x,y\}$，那么他们可以选择拥抱并生成一只幅度为 $\{a+b,x,y\}$ 的新精灵。但是注意，精灵们都是漂浮在宇宙中的，所以他们可以任意旋转。比如幅度为 $\{x,y,z\}$ 的精灵可以任意旋转成为 $\{x,z,y\},\{z,x,y\},\{z,y,x\},\{y,z,x\},\{y,x,z\}$ 的精灵。**拥抱形成的新精灵不能再次参与拥抱。**

现在球状精灵们想知道，族群中能够升入四维宇宙的精灵，声望值最高能是多少？

请仔细阅读输入格式和输出格式以获取更详细的讯息。

## 说明/提示


对于 $10\%$ 的数据，$1\leq n\leq 20$。

对于 $40\%$ 的数据，$1\leq n\leq 800$。

对于 $70\%$ 的数据，$1\leq n\leq 5000$。

对于 $85\%$ 的数据，$1\leq n\leq 10^5$。

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^5$，$1\leq r_{i,1},r_{i,2},r_{i,3} \leq 10^3$。


## 样例 #1

### 输入

```
4
1 3 5
1 2 3
2 2 3
4 3 5```

### 输出

```
0
4
6```

## 样例 #2

### 输入

```
10
2 5 5
4 3 3
1 3 2
3 4 3
3 2 5
3 4 3
2 3 4
4 5 5
2 3 4
5 3 4```

### 输出

```
1
1 8
31```

# 题解

## 作者：bloodstalk (赞：12)

### update：修改了一下 $\LaTeX$
很好的一个题
## 题意

给你 $n$ 个三元组 $(r_1,r_2,r_3)$ , 并定义 $ρ = \lfloor \frac{1}{4}min(r_1,r_2,r_3)^3 \rfloor$ 。

两个三元组能合并当且仅当这两个三元组有至少两个值相同，即从 $(x_1,y,z)$ 和 $(x_2,y,z)$ 变为 $(x_1+x_2,y,z)$ 。$(x,y,z)$的位置不固定，可以变为 $(x,z,y)$ 等很多种。一个三元组最多只能合并一次。

询问 $ ρ $ 最大为多少，并且询问是合并后形成的还是不合并形成的，再询问他们的编号。

$1 \leq n  \leq 5 \times 10^5$
 ，$1 \leq r_{i,1},r_{i,2},r_{i,3} \leq 10^3 $ 
 。

## 思路

### 贪心

- 首先，我们可以知道， $ρ$ 的值只跟三元组中最小的一个数有关。

	因此，如果我们要合并， $x_1,x_2$ 却不是他们所在的三元组中最小的那一个数，那么他们合并也毫无意义，因为最后还是看最小的那一个数。所以我们先给每个三元组自身从小到大排一下序。
    
- 再者，有了这个条件后，我们想一想：
  
  1.如果有多组$(\geq 2)$三元组的后两个元素相等，那么可以很轻松的想出，合并肯定是比不合并优的。
  
  2.如果有多组三元组的后两个元素相等，我们应贪心的选取最大的两个 $x$ 值进行合并，因此，我们只需要维护最大的两个值就可以了。

- 有了基本思路后我们看一看数据范围 ：$1 \leq r_{i,1},r_{i,2},r_{i,3} \leq 10^3 $ ，完全可以进行 $O(r^2)$ 枚举！

因此，思路就出来了：$mp[i][j][1],mp[i][j][2]$ 表示三元组后两个元素分别是 $i,j$ 时，第一个元素的最大值和次大值，我们只需要对这两个值进行维护即可。 $cnt[i][j]$ 存储后两个元素分别是 $i,j$ 时一共有多少个三元组，$id[i][j]$ 则存储它们的编号。

特殊地，如果我们最后枚举的时候进行合并 ，$x_1+x_2$ 的值加起来要大于 $i$ , 那么最小值就是 $i$ 而不是 $i+j$ ，不要漏掉这种情况。

不懂的看一看代码理解一下吧。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 1e3 + 5;
const int M = 5e5 + 5; 
using namespace std;
int max(int x,int y){return x > y ? x : y;}
int min(int x,int y){return x < y ? x : y;}

int mp[N][N][3],cnt[N][N],id[N][N][3];
struct node{
	int x,y,z,id;
}a[M];
int n,s1,s2;

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

il bool mysort(node a,node b) { return a.x > b.x; }

signed main()
{
	n = read();
	int ans = 0 , op = 0;
	for(re int i=1;i<=n;i++)
	{
		a[i].id = i;
		a[i].x = read() , a[i].y = read() , a[i].z = read();
		if(a[i].x > a[i].y) swap(a[i].x,a[i].y);
		if(a[i].x > a[i].z) swap(a[i].x,a[i].z);
		if(a[i].y > a[i].z) swap(a[i].y,a[i].z);/*给三元组排序*/
		int x = a[i].x , y = a[i].y , z = a[i].z;/*如果 cnt[i][j] 存储的还不到2，直接加入进去就行*/
		if(cnt[y][z] == 0 || cnt[y][z] == 1) mp[y][z][++cnt[y][z]] = x , id[y][z][cnt[y][z]] = i;
		else
		{/*cnt[i][j]为2了，我们就需要维护最大值和次大值*/
			if(mp[y][z][1] > mp[y][z][2]) swap(mp[y][z][1],mp[y][z][2]) , swap(id[y][z][1],id[y][z][2]);/*把小的交换到前面*/
			if(x > mp[y][z][1]) mp[y][z][1] = x , id[y][z][1] = i;
		}
	}
	//cout << mp[963][991][1] << " " << mp[963][991][2] << endl;
	for(re int i=1;i<=1000;i++)
		for(re int j=i;j<=1000;j++)
		{
			if(cnt[i][j] == 0) continue;
			if(cnt[i][j] == 1)/*只有一个元素，直接判断就行*/
			{
				if(ans < mp[i][j][1]) ans = mp[i][j][1] , op = 0 , s1 = id[i][j][1];
			}
			if(cnt[i][j] == 2)
			{
				if(mp[i][j][1] + mp[i][j][2] > i) /*特殊情况，最小值是i而不是x1+x2的时候*/
				{
					if(ans < i) ans = i , op = 1 , s1 = id[i][j][1] , s2 = id[i][j][2];
				}
				else
				{
					if(ans < mp[i][j][1] + mp[i][j][2]) ans = mp[i][j][1]+mp[i][j][2] , op = 1 , s1 = id[i][j][1] , s2 = id[i][j][2];
				}
			}
		}
	if(op == 0) cout << op << "\n" << s1 << "\n" << (ans*ans*ans)/4;
	else cout << op << "\n" << min(s1,s2) << " " << max(s1,s2) << "\n" << (ans*ans*ans)/4;/*愉快的输出*/
	/*cout << a[288].x << " " << a[288].y  << " " << a[288].z << endl;
	cout << a[727].x << " " << a[727].y  << " " << a[727].z;*/
	return 0;
}


```


时间复杂度 $\Theta(r^2)$ ,可以通过。

自认为写的很详细了，有什么问题可以在评论区问。

---

## 作者：enend0 (赞：4)

#### 此题解较容易理解，但~~比较暴力~~时间复杂度和空间复杂度均不是最优，如有需要请学习其他~~作者不会~~的高级算法。

考场上先写了个错解，自信满满写完发现样例都过不去，仔细看样例才发现自己写的完全不对（等下会解释为什么不对），但同时受到启发想出了正解。

先说错解，我一开始是这样想的：因为声望值的计算取的是精灵三个幅度的最小值，所以合并时应让两个精灵较大的两个幅度相等，使最小值更大。

代码实现大概就是将每个精灵的三个幅度从小到大规定为x，y，z，然后排序，再扫一遍，y和z相等的就合并。

但显然，样例1中的 `1 3 5`，应当与`4 3 5`合并，合并项为`1`和`4`，分别是第一个精灵的**最小幅度**和第四个精灵的**次小幅度**，我的错解还没交就被卡下去了。

通过这个样例我们可以发现，只要满足合并的两个精灵中**其中一个的最小幅度**被增加就可能是答案。可我~~太菜了不会排序实现了~~，于是就想~~暴力枚举~~。

-------

### 下面是正解部分

本题可以用桶来做。

不难看出，当存在
```
2 3 4
3 3 4
5 3 4
```
这样的数据的时候，`2 3 4`是没有用的，因为这三个精灵都可以两两拥抱，所以我们只需要维护**其中两个幅度相等时，第三个幅度最大和次大的精灵**，刚好数据范围里有这么一句

> $1\leq r_{i,1},r_{i,2},r_{i,3} \leq 10^3$

~~真是天助我也~~

使用两个二维数组记录其中两个幅度为i和j的精灵第三个幅度的最大值和次大值，~~再~~用两个二维数组记录编号~~就可以了~~。

具体注释见代码。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;

int m1[1005][1005],m2[1005][1005];
//m1[i][j]表示 其中两个幅度为i,j时另一个幅度最大为多少
//m2[i][j]表示 其中两个幅度为i,j时另一个幅度次大为多少
int e1[1005][1005],e2[1005][1005];
//e1[i][j]表示 m1[i][j]存的球状精灵的编号
//e2[i][j]表示 m2[i][j]存的球状精灵的编号,为0就表示没有次大的精灵
int n;

void add1(int x,int y,int z,int id)
{
	//因为我们并不区分前两维幅度的顺序,所以[x][y]和[y][x]是相等的
	//当然,如果规定xy较大或较小的在前,只存一个也是没问题的,但这里没有排序就都存了
	m2[x][y]=m2[y][x]=m1[x][y];//先将最大赋值给次大
	m1[x][y]=m1[y][x]=z;//再把当前精灵赋值给最大
	e2[x][y]=e2[y][x]=e1[x][y];//更新编号
	e1[x][y]=e1[y][x]=id;
}

void add2(int x,int y,int z,int id)
{
	m2[y][x]=m2[x][y]=z;//把当前精灵赋值给次大
	e2[y][x]=e2[x][y]=id;//更新编号
}

int main()
{
	scanf("%d",&n);
	int x,y,z;
	for(int i=1; i<=n; ++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(z>m1[x][y]) add1(x,y,z,i);//当前精灵是两个幅度为x,y的精灵里第三个幅度最大的
		else if(z>m2[x][y]) add2(x,y,z,i);//当前精灵不是最大的,但比次大的精灵大
		
		if(x>m1[y][z]) add1(y,z,x,i);
		else if(x>m2[y][z]) add2(y,z,x,i);
		
		if(y>m1[z][x]) add1(z,x,y,i);
		else if(y>m2[z][x]) add2(z,x,y,i);
	}
	int id1=0,id2=0,maxn=0;
	for(int i=1; i<=1000; ++i)//枚举所有可能的幅度
	{
		for(int j=1; j<=1000; ++j)
		{
			int s=min(m1[i][j]+m2[i][j],min(i,j));
			//记录合成的精灵三维中最小的维度 
			if(s>maxn)
			{
				maxn=s; 
				id1=e1[i][j];
				id2=e2[i][j];
			}
		}
	}
	if(id2==0) printf("0\n%d\n",id1);//如果次大精灵编号为0,说明根本没有合并 
	else printf("1\n%d %d\n",id1,id2);
	ll ans=1ll*maxn*maxn*maxn/4;
	//按理来说应该开longlong的,但此题数据太水了,不开也能过 
	printf("%lld",ans);
	return 0;
}
```

最后，不得不吐槽一句这题的数据真的是太水了，考试时将第一个for循环内写成了
```
if(z>m1[x][y]) add1(x,y,z,i);
else if(z>m2[x][y]) add2(x,y,z,i);
	
if(z>m1[y][z]) add1(y,z,x,i);//这句的判断
else if(z>m2[y][z]) add1(y,z,x,i);//这句的判断和赋值

if(z>m1[z][x]) add1(z,x,y,i);//这句的判断
else if(z>m2[z][x]) add1(z,x,y,i);//这句的判断和赋值
```
~~竟然也是100分~~

~~带注释的地方都是写错的~~，可以和上方题解作比较。

第一篇题解，如果有锅请私信联系。

---

## 作者：cyhtxdy (赞：3)

直接写正解吧。

这题采用贪心+排序的方法。

首先将 $r1_i, r2_i, r3_i$ 处理为从小到大，然后再以 $b,c,a$ 分别为第一，第二，第三关键字排序。此时，如果两个精灵能合并且对答案有影响，那么它们一定是相邻的！

原因显然，但是读者可能会有一个疑问：如果两个精灵分别为 $2,2,3$ 和 $1,2,2$，按照上文的排序后，这两个精灵不会参与到答案的计算。那为什么不考虑这种情况呢？

因为其中有一个精灵的幅度是大于两个精灵的相同的幅度，也就是说，这两个精灵合并后，产生新的幅度一定是**大于它们相同的幅度**。而精灵的贡献计算是取三个幅度中的最小值，那么新的幅度**肯定不是最小值**！

在这种情况中，合并两个精灵后的贡献是和不合并前的**贡献相同**，所以我们可以不考虑这种情况。

考虑好了这个问题整个思路就很清晰了。

将其排序后线性枚举相邻可以合并的两个精灵，计算贡献值，并且取最大值。由于需要记录是编号为几的精灵，所以在最初输入时要记录精灵的编号。

得到代码：
```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int inf = 0x3f3f3f3f;
const int N = 5e5 + 7; 

struct Node {
	int a, b, c, id;
}p[N];
int n;

bool cmp (Node x, Node y) {//排序 
	if (x.b != y.b) {//first 
		return x.b < y.b;
	}
	else if (x.c != y.c) {//second 
		return x.c < y.c;
	}
	return x.a < y.a;//third 
}

int val (int a, int b, int c) {//计算贡献 
	int f = min (a, min (b, c));
	return f * f * f / 4;
}

int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i ++) {
		int t[4];
		scanf ("%d%d%d", &t[1], &t[2], &t[3]);
		sort (t + 1, t + 4);//从小到大处理 
		p[i].a = t[1], p[i].b = t[2], p[i].c = t[3];
		p[i].id = i;//记录编号 
	}
	sort (p + 1, p + 1 + n, cmp);//排序处理 
	int ans = 0, op, x = -1, y = -1;
	for (int i = 1; i < n; i ++) {
		if (p[i].b == p[i + 1].b && p[i].c == p[i + 1].c) {//可以合并 
			int v = val (p[i].a + p[i + 1].a, p[i].b, p[i].c);//计算贡献 
			if (v > ans) {
				x = p[i].id;
				y = p[i + 1].id;
				ans = v;
				op = 1;
			}
		}
	}
	for (int i = 1; i <= n; i ++) {//计算如果不合并时的贡献 
		int v = val (p[i].a, p[i].b, p[i].c);
		if (v > ans) {
			x = p[i].id;
			ans = v;
			op = 0;
		}
	}
	if (op == 0) {
		printf ("%d\n%d\n%d", op, x, ans);
	}
	else {
		printf ("%d\n%d %d\n%d", op, x, y, ans);	
	}
	
	return 0;
}
```


---

## 作者：gyyyyx (赞：3)

前置芝士：桶

文中让我们求的带有 $\min$，并且随便交换 $r_1,r_2,r_3$ 不会影响答案。

因此如果将每一只精灵的 $r_1,r_2,r_3$ 排序，就可以确定 $\min=r_1$ 来计算声望。

我们就可以处理好不拥抱的情况的答案了。

那拥抱的情况呢？这就需要用到桶。

很显然只有当两只精灵的 $r_2$ 与 $r_3$ 相同时，拥抱才是有价值的。

因为我们将 $r_1,r_2,r_3$ 排好序，因此如果是其他情况，增加的一定不是最小的 $r_1$，对声望没有影响，只有 $r_2$ 与 $r_3$ 相同才可能对声望有影响。

所以我们可以用桶 $mx_{i,j}$ 记录下 $r_2=i,r_3=j$ 的精灵中最大的 $r_1$。

这样我们就可以计算出当某个精灵与一只 $r_2,r_3$ 与其相同的精灵拥抱时声望的最大值了。

但这样还不够，~~我要更加努力，我要坚持我的目标，备战期末，厚积薄发，因为只有这样才称得上，衡中的少年~~！因为有可能计算某一只精灵时取的 $mx_{r_2,r_3}$ 就是他自己，因此我们还需要维护次小值。

之后还有很多细节，我用了指针来处理，方便一点，还有记录最大值时要顺便记录哪只精灵是最大值，这样才能输出。

时间复杂度 $O(n)$，空间复杂度 $O(n+r^2)$。

代码：

```cpp
#include<bits/stdc++.h>
#define N 500005
#define M 1005
using namespace std;
int n,a,b,c,r1[N],r2[N],r3[N];
int mx[2][M][M],f[2][M][M];
int ans,res1,res2;
int main(){
    scanf("%d",&n);
    for(int i(1),*t1,*t2,*k1,*k2;i<=n;++i){
        scanf("%d%d%d",&a,&b,&c);
        if(a>b) swap(a,b);
        if(a>c) swap(a,c);
        if(b>c) swap(b,c);
        if((a*a*a>>2)>ans) ans=(a*a*a>>2),res1=i;
        t1=&mx[0][b][c];t2=&mx[1][b][c];
        k1=&f[0][b][c];k2=&f[1][b][c];
        if(a>=(*t1)){
            (*t2)=(*t1);(*t1)=a;
            (*k2)=(*k1);(*k1)=i;
        }
        else if(a>(*t2)) (*t2)=a,(*k2)=i;
        r1[i]=a;r2[i]=b;r3[i]=c;
    }
    for(int i(1),t,k;i<=n;++i){
        if(mx[0][r2[i]][r3[i]]^r1[i]){
            t=mx[0][r2[i]][r3[i]];
            k=f[0][r2[i]][r3[i]];
        }
        else{
            t=mx[1][r2[i]][r3[i]];
            k=f[1][r2[i]][r3[i]];
        }
        t+=r1[i];t=min(t,r2[i]);t=(t*t*t>>2);
        if(t>ans) ans=t,res1=i,res2=k;
    }
    if(res2) printf("1\n%d %d\n%d\n",res1,res2,ans);
    else printf("0\n%d\n%d\n",res1,ans);
    return 0;
}
```

---

## 作者：iyaang (赞：2)

# 球状精灵的传说

[更好的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/16807059.html)

[题目链接](https://www.luogu.com.cn/problem/P8585)

我们记三个维度为最大值，中间值和最小值。容易发现只需要将三个值排序，检查最大值和中间值相同，融合最小值的情况。

题意中的融合操作只会造成两种影响，一个是融合之后新最小值依然比中间值小，这并不会对答案产生贡献；还有就是融合后的新最小值超过了中间值，所以中间值成为了新的最小值，会产生新的结果。

既然我们要尽量让两个可以融合的精灵的最小值相加尽可能大，就可以维护一个大根堆，取出前两个元素来判断是否合法。使用 $map$ 维护，以另外两个维度为关键字。由于还要维护最大值从哪里得来，所以优先队列要维护 $pair$，以值为第一关键字，位置为第二关键字。答案遍历 $map$ 统计即可。

复杂度 $O(n \log^2 n)$，再次喜提最劣解,~~也可能是最短解罢~~。

$Code$
```
#include<bits/stdc++.h>
#define MAX 1000010
#define int long long
using namespace std;

inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}

int n;
struct rest
{
	int a,b,c;
	#define a(i) r[(i)].a
	#define b(i) r[(i)].b
	#define c(i) r[(i)].c
	void fix(){int t=a+b+c,tt=a; a=max(max(a,b),c),c=min(min(tt,b),c),b=t-a-c;}
}r[MAX];

map<pair<int,int>,priority_queue<pair<int,int> > > q;
int maxx;
pair<int,int> ans;

signed main()
{
	n=read();
	
	for(int i=1;i<=n;++i)
	{
		a(i)=read(),b(i)=read(),c(i)=read();
		r[i].fix();
		int now=c(i)*c(i)*c(i)/4;
		if(now>maxx) maxx=now,ans.first=i,ans.second=i;
		q[make_pair(a(i),b(i))].push(make_pair(c(i),i));	
	}
	
	map<pair<int,int>,priority_queue<pair<int,int> > >::reverse_iterator iter;
	for(iter=q.rbegin();iter!=q.rend();++iter)
	{
		if(iter->second.size()<2) continue;
		pair<int,int> x=iter->second.top();
		iter->second.pop();
		pair<int,int> y=iter->second.top();
		int bb=iter->first.second;
		if(x.first+y.first>=bb)
		{
			int now=bb*bb*bb/4;
			if(now>maxx) maxx=now,ans.first=x.second,ans.second=y.second;
		}
	}
	
	if(ans.first==ans.second) cout<<0<<endl<<ans.first<<endl<<maxx;
	else cout<<1<<endl<<ans.first<<" "<<ans.second<<endl<<maxx;
	return (0-0);
}
```

---

## 作者：Asakawa_Luka (赞：2)

# 前言

对于本题，我比赛的时候：

1. 我没有看见 $r_1, r_2, r_3$ 值域。

2. 出现了不必要的数据结构嵌套，虽然并不会使复杂度错误。

3. 多写了许多不必要的代码。

警示后人。

# 正文

观察 $\rho = \left \lfloor \dfrac{1}{4} \min \{r_1, r_2, r_3\}^3 \right \rfloor$，不妨使得每个 elf 处于： $r_1 < r_2 < r_3$。

根据两个精灵的合并关系，我们不妨确定 elf 其中的两个 $r$ 值，找到第三个值合并后的最大值。

容易证明此时可以得到合并后得到的 $r_1$ 最大值，即题目所求的（此时） $\rho = \left \lfloor \dfrac{1}{4} r_1^3 \right \rfloor$。

将每个输入的 elf 分成 $r_1, r_2$、$r_1, r_3$、$r_2, r_3$ 三份（若 $r_1, r_2, r_3$ 无序则需要六份），维护一下即可。

赛后我想到这里的时候，根据题目值域发现确实可以用桶维护，不过我用 std::map 来维护。

赛时我用了 [std::set](https://zh.cppreference.com/w/cpp/container/set) 来维护有序的合并值和去重，显然没必要。

时间复杂度：$O(n \log_2 n)$；空间复杂度：$O(n)$

# 代码

赛时：https://www.luogu.com.cn/paste/sli9vzzv

```cpp
#include <algorithm>
#include <iostream>
#include <map>
#include <tuple>
#include <utility>
namespace Solution {
struct Elf {
  std::size_t r1, r2, r3;
  constexpr void sort_r() noexcept {
    if (r1 > r2) std::swap(r1, r2);
    if (r1 > r3) std::swap(r1, r3);
    if (r2 > r3) std::swap(r2, r3);
  }
  constexpr Elf(const std::size_t& _r1 = 0u, const std::size_t& _r2 = 0u,
                const std::size_t& _r3 = 0u) noexcept
      : r1(_r1), r2(_r2), r3(_r3) {
    sort_r();
  }
  friend std::istream& operator>>(std::istream& input_stream, Elf& elf) {
    input_stream >> elf.r1 >> elf.r2 >> elf.r3;
    elf.sort_r();
    return input_stream;
  }
};
constexpr void handle(
    std::tuple<std::size_t, std::size_t, std::size_t, std::size_t>& elem,
    const std::pair<std::size_t, std::size_t>& val) noexcept {
  if (val.first > std::get<0u>(elem)) {
    std::get<2u>(elem) = std::get<0u>(elem);
    std::get<3u>(elem) = std::get<1u>(elem);
    std::get<0u>(elem) = val.first;
    std::get<1u>(elem) = val.second;
  } else if (val.first > std::get<2u>(elem) &&
             val.second != std::get<1u>(elem)) {
    std::get<2u>(elem) = val.first;
    std::get<3u>(elem) = val.second;
  }
}
int main() noexcept {
  std::pair<std::size_t, std::size_t> opos;
  std::tuple<std::size_t, std::size_t, std::size_t> cpos;
  std::map<std::pair<std::size_t, std::size_t>,
           std::tuple<std::size_t, std::size_t, std::size_t, std::size_t>>
      ttp;
  std::size_t n, i = 1u;
  std::cin >> n;
  for (Elf elf; i <= n; ++i) {
    std::cin >> elf;
    if (elf.r1 > opos.first) {
      opos.first = elf.r1;
      opos.second = i;
    }
    if (auto iter = ttp.find(std::make_pair(elf.r1, elf.r2)); iter == ttp.end())
      ttp[std::make_pair(elf.r1, elf.r2)] = std::make_tuple(0u, 0u, 0u, 0u);
    handle(ttp[std::make_pair(elf.r1, elf.r2)], std::make_pair(elf.r3, i));
    if (auto iter = ttp.find(std::make_pair(elf.r1, elf.r3)); iter == ttp.end())
      ttp[std::make_pair(elf.r1, elf.r3)] = std::make_tuple(0u, 0u, 0u, 0u);
    handle(ttp[std::make_pair(elf.r1, elf.r3)], std::make_pair(elf.r2, i));
    if (auto iter = ttp.find(std::make_pair(elf.r2, elf.r3)); iter == ttp.end())
      ttp[std::make_pair(elf.r2, elf.r3)] = std::make_tuple(0u, 0u, 0u, 0u);
    handle(ttp[std::make_pair(elf.r2, elf.r3)], std::make_pair(elf.r1, i));
  }
  for (auto iter = ttp.begin(); iter != ttp.end(); ++iter) {
    if (const Elf temp_elf(
            iter->first.first, iter->first.second,
            std::get<0u>(iter->second) + std::get<2u>(iter->second));
        std::get<0u>(iter->second) && std::get<2u>(iter->second) &&
        temp_elf.r1 > std::get<0u>(cpos)) {
      std::get<0u>(cpos) = temp_elf.r1;
      std::get<1u>(cpos) = std::get<1u>(iter->second);
      std::get<2u>(cpos) = std::get<3u>(iter->second);
    }
  }
  if (const std::size_t& on = opos.first, &cn = std::get<0u>(cpos); on > cn)
    std::cout << '0' << std::endl
              << opos.second << std::endl
              << ((on * on * on) >> 2u);
  else
    std::cout << '1' << std::endl
              << std::get<1u>(cpos) << ' ' << std::get<2u>(cpos) << std::endl
              << ((cn * cn * cn) >> 2u);
  return 0;
}
}  // namespace Solution
int main() noexcept {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  return Solution::main();
}
```

# 后言

可能有不需要分成三份来考虑的做法（仅按照 $r_2, r_3$ 考虑合并），但是这不符合标题中的“易想”，复杂度不变但是常数会变小。

---

## 作者：LYZHZ (赞：2)

[题目](https://www.luogu.com.cn/problem/P8585)。

------------
经过读题我们知道，本题的输出分两种情况：

>1. 当 opt=0 时共一个整数 i，表示升入四维空间的精灵是编号为 i 的精灵。 
>2. 当 opt=1 时共两个整数 i,j，表示最终升入四维空间   的精灵由编号为 i,j 的精灵拥抱生成。

所以我们可以先处理 opt=1 时：

```cpp
	scanf("%d%d%d",&r1[i],&r2[i],&r3[i]);
	int roup=min(r3[i],min(r1[i],r2[i]));
	//roup 表示 r1[i],r2[i],r3[i] 中的最小值 
	if(roup>maxx) maxx=roup,jj=i;
```

方便与后续过程比较。

我们可以先进行处理，使 ```r1[i],r2[i],r3[i]``` 为从小到大来排。

因为声望值 $\rho$ 与最小值有关，所以，在后续过程中，我们只需要比较当出现过相同的 ```r2[i],r3[i]``` 时比较两者的 ```r1[i]``` 相加之和再与 ```r2[i],r3[i]``` 比较取最小，判断是否为更优解。

又因为： 
>对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^5$，$1\leq r_{i,1},r_{i,2},r_{i,3}\leq 10^3$。

所以很直接的就能想到：```vis[r2[i]][r3[i]]```  来记录 ```r2[i],r3[i]``` 是否出现过。

而且每次查询过后还要将记录的东西更新。


------------


所以最终代码呈现即为：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r1[500010],r2[500010],r3[500010];
int maxx,jj,j2,opt;
// 此处均为对答案的记录。 
int a[1010][1010],b[1010][1010];
//a[r2[i]][r3[i]]=r1[i] 记录最优值。 
//b[r2[i]][r3[i]]=i 记录最优位置。 
bool vis[1010][1010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&r1[i],&r2[i],&r3[i]);
		int roup=min(r3[i],min(r1[i],r2[i]));
		//roup 表示 r1[i],r2[i],r3[i] 中的最小值。 
		if(roup>maxx) maxx=roup,jj=i;
		//opt==0 时先处理。 
		if(r1[i]>r2[i]) swap(r1[i],r2[i]);
		if(r1[i]>r3[i]) swap(r1[i],r3[i]);
		if(r2[i]>r3[i]) swap(r2[i],r3[i]);
		// 重新给 r1[i],r2[i],r3[i] 排序。 
	}
	for(int i=1;i<=n;i++)
	{
		// 判断 opt==1 时。 
		if(vis[r2[i]][r3[i]])
		{
			// 前面已记录，可进行合并。 
			int k=min(a[r2[i]][r3[i]]+r1[i],min(r2[i],r3[i]));
			if(k>maxx) opt=1,maxx=k,jj=b[r2[i]][r3[i]],j2=i;
			if(a[r2[i]][r3[i]]<r1[i]) a[r2[i]][r3[i]]=r1[i],b[r2[i]][r3[i]]=i;
			// 取最优，为后续有相同的 r2[i],r3[i] 作更出色的铺垫。 
		}
		else
		{
			// 前面未记录，现在记录。
			vis[r2[i]][r3[i]]=1;
			a[r2[i]][r3[i]]=r1[i];
			b[r2[i]][r3[i]]=i;
		}
	}
	cout<<opt<<endl;
	if(opt==1)
	{
		cout<<jj<<" "<<j2<<endl;
		cout<<maxx*maxx*maxx/4;
	}
	else 
	{
		cout<<jj<<endl;
		cout<<maxx*maxx*maxx/4;
	}
	return 0;
}
```


---

## 作者：ScottSuperb (赞：2)

## 解法分析
简单贪心。首先注意到声望值取决于**最小的**幅度，那么我们在读入每个球后将其幅度升序排序，在考虑拥抱时只考虑最小的幅度相加，因为更大的幅度相加不会改变最小幅度也就不会改变声望值，所以不考虑。  
那么在读入完后对所有球进行排序，规则是 $r3$ 优先，其次 $r2$（注意这里幅度已经排过序了），这样就可以保证数组里如果存在后两个幅度相同的球，它们一定是相邻的（当然 $r2$ 优先 $r3$ 其次也是一样的）。  
排完序后直接枚举数组下标为 $1\sim n-1$ 的球，计算它与数组中下一个球拥抱后能得到的声望值，存下最优方案即可。最后再与读入时存下来的不拥抱的最优方案比较，输出最终答案。
## 代码
读写函数定义已省略。
```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAXN 500005
struct ball {
  int n, r[4];
  bool operator<(ball b) {
    if (r[3] == b.r[3]) return r[2] < b.r[2];
    return r[3] < b.r[3];
  }
  inline int getr() { return r[1] * 1ll * r[1] * r[1] / 4; }
} b[MAXN];

int main() {
  int n = read(), smax = 0, smn, pmax = 0, pmi, pmj, tmpr;
  for (int i = 1; i <= n; ++i) {
    b[i].n = i, b[i].r[1] = read(), b[i].r[2] = read(), b[i].r[3] = read(),
    sort(b[i].r + 1, b[i].r + 4), tmpr = b[i].getr();
    if (tmpr > smax) smax = tmpr, smn = i;
  }
  sort(b + 1, b + n + 1);
  for (int i = 1; i < n; ++i)
    if (b[i].r[2] == b[i + 1].r[2] && b[i].r[3] == b[i + 1].r[3]) {
      b[i].r[1] = min(b[i].r[2], b[i].r[1] + b[i + 1].r[1]), tmpr = b[i].getr();
      if (tmpr > pmax) pmax = tmpr, pmi = b[i].n, pmj = b[i + 1].n;
    }
  if (pmax > smax)
    write(1), write(min(pmi, pmj), ' '), write(max(pmi, pmj)), write(pmax); // 赛时没弄清 i, j 是否有顺序要求所以写了 max min，这里懒得管了
  else
    write(0), write(smn), write(smax);
  fls();
  return 0;
}
```

---

## 作者：_acat_ (赞：2)

### 思路

观察数据范围，注意到 $n$ 比较大，但是 $r$ 都比较小。

这样我们可以用个二维数组保存答案。

具体而言，我们用 $mx_{i,j}$ 表示其中两维为 $i$ 和 $j$ 的精灵中，另外一维的最大值。

用 $cmx_{i,j}$ 表示其中两维为 $i$ 和 $j$ 的精灵中，另一维的次大值。

最后统计答案的时候枚举一下 $i$ 和 $j$，然后取一下 $mx_{i,j}+cmx_{i,j}$和 $i$，$j$ 中的最小值。并对全部的
对应的答案中取最优的。


---

## 作者：Sktic (赞：1)

[P8585 球状精灵的传说](https://www.luogu.com.cn/problem/P8585)

说在前面：

见鬼的 T2 。考场上想了 $\text{10min}$ 才会，敲完觉得本场难度爆表直接遛了，其实这个才是最难的一题吧（



然后 T1 因为脑残用了忘记改的手写 $\text{ull gcd}$ ，$\text{MLE}$ 喜提 $\text{30}$ 。



本题通过 手残 在 $\text{77}$ 行少写了一个 $\min$ ，喜提 $\text{70}$ 。



最终通过 $\text{15min}$ 的人类掉智极限拿到了 $\text{100}$ 分的好成绩。



警钟敲烂。

回归正题，首先题目中要求 $\text{min}\{r_1,r_2,r_3\}$ 的最大值，而描述中又提到 $r_1,r_2,r_3$ 可以互相转化，于是我们可以考虑寻找一个最大的 $\min{r}$ 。



显然这个 $\min{r}$ 要么在一个垒球中产生，要么在两个垒球合成中产生。



先考虑一个垒球的情况。对于输入的每个垒球，我们都找到它的最小值，最后将每个最小值取 $\max$ 即可。这部分可以在输入时候求完。



接下来考虑由两个垒球合成的情况。我们可以发现，当两个垒球合成的时候，为了对答案造成尽可能大的贡献，必定是当另外两个较大值相同，将两个较小值合并。为什么呢？假设两个垒球分别为 $\{a,b,c\}$ 和 $\{d,b,c\}$ ，合并后就为 $\{a+d,b,c\}$ ，若 $a$ 与 $d$ 不是原来最小的，那么合并后的 $a+d$ 也必然大于原来 $b,c$ 中的一个，那么贡献还是 $\text{min}\{b,c\}$ 之中的一个，不如不合并。



因此发现这点我们就可以在输入垒球的时候将 $a,b,c$ 从小到大存储，再因为 $a,b,c\le 10^3$ ，我们可以直接暴力开一个 $\text{vector}$ 存储每个 $b,c$ ，再贪心的选取最大的两个合并。最后取最大值即可。



最终答案就是前面两种情况的最大值。



AC Code：

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
const int maxm=1e3+10;
typedef long long ll;
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=x*10+(c-'0'),c=getchar();
	return x;
}
struct jl
{
	int a,b,c;
	int mp;
}s[maxn];
int mz(int a,int b,int c)
{
	if(a>=b)
	{
		if(b>=c)
			return b;
		else if(a>=c)
			return c;
		else
			return a;
	}
	else
	{
		if(a>=c)
			return a;
		else if(b>=c)
			return c;
		else
			return b;
    }
    return -1;
}
struct node
{
	ll data,k;
};
ll sw(ll x)
{
	return floor(1.0*x*x*x*0.25);
}
bool cmp(node a,node b)
{
	return a.data>b.data;
}
vector<node> tt[maxm][maxm];
int main()
{
	int n=read(),u,v,w;
	int mx=0,mi=0;
	for(int i=1;i<=n;i++)
	{
		u=read(),v=read(),w=read();
		s[i].a=min(u,min(v,w)),s[i].b=mz(u,v,w),s[i].c=max(u,max(v,w));
		tt[s[i].b][s[i].c].push_back({s[i].a,i});
		s[i].mp=s[i].a;
		if(s[i].mp>mx)
			mx=s[i].mp,mi=i;
	}
	ll mxx=0,mii=0,mij=0;
	for(ll i=1;i<=1e3;i++)
	{
		for(ll j=1;j<=1e3;j++)
		{
			if(tt[i][j].size()>1)
			{
				sort(tt[i][j].begin(),tt[i][j].end(),cmp);
				ll ta=min(tt[i][j][0].data+tt[i][j][1].data,min(i,j));
				if(ta>mxx)
					mxx=ta,mii=tt[i][j][0].k,mij=tt[i][j][1].k;
			}
		}
	}
	if(mxx>mx)
		printf("1\n%d %d\n%lld\n",mii,mij,sw(mxx));
	else
		printf("0\n%d\n%lld\n",mi,sw(mx));
	return 0;
}
```



















---

## 作者：CuSO4_and_5H2O (赞：1)

简单的贪心题目，用了桶的思想。

## 思路

首先观察题目，发现大的价值就是和他每一个生物的最小值是直接挂钩的，所以只需要关心最小值即可。

那些值可以成为最小值？

很明显，是最小和次小（因为最小能够相加成为一个大的数），所以我们关心这几个就行了。

考虑怎么合并，首先，合并两个生物，假如是让他们的次小或最大相加是没有意义的（因为只关心最小，他们明显不能成为最小）。所以只用合并最小值就可以了。怎么合并最小值？观察题目，发现必须其他两个维度相同，而且看三个维度的范围，是小于 $1000$ 的，这是在告诉你什么？很明显，是**桶**，谁能拒绝一个查询 $ \Theta(1) $ 的东西呢？

二维桶，然后记录的是维度信息记录次小和最大，里边记录四个值，两个编号（因为最后要求查询编号），两个值（这两个值要求最大的，因为次小都一样）。

最后，每一次输入一个新的生物都看看这个生物的最小值是否比当前最大值大，然后把这个生物的最小和次小放进桶里查询，如果比之前存进去的大，那就替换掉，最后查询这个桶的这个位置的值时比较记录的最大值的大小（注意一个坑点，别忘了次小也可以成为最小）。

说了这么多，上代码：

## 代码

个人感觉比较简短（轻微压行）。

```
#include<bits/stdc++.h>
#define max(A,B) (A<B?B:A)
#define min(A,B) (A>B?B:A)
#define bug cout<<"I AK IOI"<<endl;
#define gc getchar
using namespace std;
const int N=5e5+10;

inline void print(int x) {if (x < 0) putchar('-'), x = -x; if(x > 9) print(x / 10); putchar(x % 10 + '0');}
inline int read(){int res = 0, f = 0; char ch = gc();for(; !isdigit(ch); ch = gc()) f |= (ch == '-'); for(;isdigit(ch);ch=gc()) res = (res << 1) + (res << 3) + (ch ^ '0');return f ? -res :res;}

int n,a,b,c,d,w[N][4];
struct node{
	int bh1,bh2,a,b;
}mp[1001][1001];
int Max=-1,bj,jil1,jil2;

void qwq(int x)
{
	if(mp[b][c].a<a){ swap(mp[b][c].a,a); swap(mp[b][c].bh1,x);}
	//为什么要swap？因为被换出来的有可能比下一个大 
	if(mp[b][c].b<a){ mp[b][c].b=a; mp[b][c].bh2=x; return ;}
}

signed main(){
	n=read();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=3;j++) w[i][j]=read();
		sort(w[i]+1,w[i]+4);//排序，方便知道哪个是最小，次小 
		a=w[i][1],b=w[i][2],c=w[i][3]; 
		if(Max<a){ Max=a;bj=1,jil1=i;}//bj是看看最后是单一生物还是两个生物 
		qwq(i);//更新一下桶里的东西 
		d=mp[b][c].a+mp[b][c].b;//拥抱了值合并一下 
		d=min(d,b);
		//这一句很重要，目的就是为了看看次小值能不能成为最小 
		if(mp[b][c].bh2 && d>Max){
			bj=2;jil1=mp[b][c].bh1;jil2=mp[b][c].bh2;Max=d;
			//bj同样的功能，看看是一个生物还是两个 
		}
	}
	Max=Max*Max*Max;//应题目要求 
	cout<<bj-1<<'\n';
	if(bj==1) cout<<jil1<<'\n'<<Max/4;
	else cout<<jil1<<' '<<jil2<<'\n'<<Max/4;
	//结束 
}

```


---

## 作者：_ANIG_ (赞：0)

首先有一个贪心。由于只有最小值对答案有影响，所以合并最大值或次大值是没有意义的。所以只有最大值和次大值相同的才可能合并。对于输入的每个精灵排序。然后以次大值和最大值为两维坐标，存到一个 vector 中。在每个 vector 中再以最小值排序。如果整个 vector 中只有一个元素，就用这个元素更新答案。否则合并最大的两个元素更新答案。复杂度 $O(n\log n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,p[500005][3],cnt,r1,r2;
vector<int>q[1005][1005];
int gets(int r1,int r2,int r3){
	int kk=min(r1,min(r2,r3));
	kk=kk*kk*kk;
	kk/=4;
	return kk;
}
bool cmp(int a,int b){
	return p[a][0]<p[b][0];
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld",&p[i][0],&p[i][1],&p[i][2]);
		sort(p[i],p[i]+3);
		q[p[i][1]][p[i][2]].push_back(i);
	}
	for(int i=1;i<=1000;i++){
		for(int j=1;j<=1000;j++){
			if(q[i][j].size()==0)continue;
			if(q[i][j].size()==1){
				int kk=gets(p[q[i][j][0]][0],p[q[i][j][0]][1],p[q[i][j][0]][2]);
				if(kk>cnt){
					cnt=kk,r2=0,r1=q[i][j][0];
				}
				continue;
			}
			sort(q[i][j].begin(),q[i][j].end(),cmp);
			int rr=p[q[i][j][q[i][j].size()-2]][0]+p[q[i][j].back()][0];
			int kk=gets(rr,i,j);
			if(kk>cnt){
				cnt=kk,r1=q[i][j][q[i][j].size()-2],r2=q[i][j].back();
			}
		}
	}
	if(r2)cout<<1<<endl<<r1<<" "<<r2<<endl;
	else cout<<0<<endl<<r1<<endl;
	cout<<cnt;
}
```


---

## 作者：zct_sky (赞：0)

### Solution:
-----
假设把 $\{r_1,r_2,r_3\}$ 看成一个三元组。

首先考虑不合并时的 $\rho_1$ 的最大值。

显然只需要遍历每一个三元组，求出每个三元组最小值之中的最大值，就能求出 $\rho_1$。

然后考虑合并时的 $\rho_2$ 的最大值。

我们可以对每个三元组内的三个值先排好序，使每个三元组中 $r_1\leq r_2\leq r_3$，

然后对每一个 $r_2,r_3$ 都相等的进行合并，求出合并后的这个三元组的最小值，并把所有合并后所得的最小值求出最大值，就能求出 $\rho_2$。

最后答案就是 $\max\{\rho_1,\rho_2\}$。

接下来解释一下求 $\rho_2$ 的最大值的正确性：

假如两组三元组能合并必定是将两个最小值合并，

假设合并的两组编号是 $i,j$，它们的三元组分别是 $\{r_{1_i},r_{2_i},r_{3_i}\}$ 和 $\{r_{1_j},r_{2_j},r_{3_j}\}$（三元组内元素已排好序）。

只有当 $r_{2_i}=r_{2_j},r_{3_i}=r_{3_j}$ 时将 $r_{1_i},r_{1_j}$ 合并，合并后的三元组的最小值一定比原来两个三元组的最小值都大（$r_{1_i}+r_{1_j}>r_{1_i},r_{1_i}+r_{1_j}>r_{1_j}$）。

而当 $r_{1_i}=r_{1_j},r_{3_i}=r_{3_j}$ 时将 $r_{2_i},r_{2_j}$ 合并，合并后的三元组的最小值一定不变（$\min\{r_{1_i},r_{2_i},r_{3_i},r_{1_j},r_{2_j},r_{3_j}\}=\min\{r_{1_i},r_{2_i}+r_{2_j},r_{3_i}\}$）。

同理，当 $r_{1_i}=r_{1_j},r_{2_i}=r_{2_j}$ 时将 $r_{3_i},r_{3_j}$ 合并，合并后的三元组的最小值一定不变。

只有当合并后的三元组的最小值一定比原来两个三元组的最小值都大时，才有可能使 $\rho_2>\rho_1$ 成立。
### Code:
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*y;
}
const int N=5e5+7;
int n;
struct node{
	ll a,b,c,id;
	bool operator<(const node &x)const{
		return (c==x.c)?(b==x.b)?(a==x.a)?id<x.id:a<x.a:b<x.b:c<x.c;
	}
}num[N];
ll ansa,ansb,a1=1,b1,b2;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		int a=read(),b=read(),c=read();
		if(c<a)swap(c,a);
		if(c<b)swap(c,b);
		if(b<a)swap(a,b);
		num[i].a=a;num[i].b=b;num[i].c=c;num[i].id=i;
		if(num[i].a>num[a1].a)a1=i;
	}
	ansa=num[a1].a*num[a1].a*num[a1].a/4;
	sort(num+1,num+1+n);
	
	for(int i=n;i>1;i--)
		if(num[i].b==num[i-1].b&&num[i].c==num[i-1].c){
			ll x=num[i].a+num[i-1].a;
			ll y=min(x,num[i].b);
			if(y*y*y/4>ansb){
				ansb=y*y*y/4;
				b1=num[i].id;
				b2=num[i-1].id;
			}
		}
	if(ansa>=ansb){
		printf("0\n%lld\n%lld",a1,ansa);
	}else{
		printf("1\n%lld %lld\n%lld",b1,b2,ansb);
	}
	return 0;
}#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*y;
}
const int N=5e5+7;
int n;
struct node{
	ll a,b,c,id;
	bool operator<(const node &x)const{
		return (c==x.c)?(b==x.b)?(a==x.a)?id<x.id:a<x.a:b<x.b:c<x.c;
	}
}num[N];
ll ansa,ansb,a1=1,b1,b2;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		int a=read(),b=read(),c=read();
		if(c<a)swap(c,a);
		if(c<b)swap(c,b);
		if(b<a)swap(a,b);
		num[i].a=a;num[i].b=b;num[i].c=c;num[i].id=i;
		if(num[i].a>num[a1].a)a1=i;//求不合并时最大值 
	}
	ansa=num[a1].a*num[a1].a*num[a1].a/4;
	sort(num+1,num+1+n);
	
	for(int i=n;i>1;i--)//求合并时最大值 
		if(num[i].b==num[i-1].b&&num[i].c==num[i-1].c){
			ll x=num[i].a+num[i-1].a;
			ll y=min(x,num[i].b);
			if(y*y*y/4>ansb){
				ansb=y*y*y/4;
				b1=num[i].id;
				b2=num[i-1].id;
			}
		}
	if(ansa>=ansb){
		printf("0\n%lld\n%lld",a1,ansa);
	}else{
		printf("1\n%lld %lld\n%lld",b1,b2,ansb);
	}
	return 0;
}
```

---

## 作者：luoyx (赞：0)

这道题出的很好，~~出的很普及组~~。

首先不难发现，一种朴素的 $O(n^2)$ 的暴力做法。先将每个三元组内的三个数排序，然后暴力的让每一个三元组和其他 $n-1$ 个三元组拥抱，再取出最大的答案。这个思路是可以拿到 $70 pts$ 的。

不妨顺着这个思路想下去，我们可以发现是有很多不必要的拥抱尝试的。例如两个没有一个数字相同的情况下，我们就没有让他们拥抱的必要了。顺着这个思路想下去，很容易就能想到排序。但是以什么为关键字？假设一个三元组 $(a,b,c) (a\leq b\leq c)$ ，如果它能和另一个三元组 $(d,e,f)(d\leq e\leq f)$ 拥抱，那么它在三个之中有大于等于两个数是相同的，即有三种情况， $a=d$ 且 $b=e$ ， $a=d$ 且 $c=f$ ， $b=e$ 且 $c=f$ 。那么思路就显而易见了：将数组排三次序，关键字分别是上述的三种情况，然后第二关键字是剩下哪个值的大小。这样，如果一个三元组与排序后的上一个三元组两个数相同，那么就计算一遍答案，取最大值。

这种方法可能不是最优的，但是是非常标准的考场思路和考场代码，应该也是思路比较直接的。

代码仅供参考

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
const int N=5e5+5;
struct node{
	int r1,r2,r3,id;
}r[N];
bool cmp(node a,node b){
	if(a.r1!=b.r1) return a.r1<b.r1;
	if(a.r2!=b.r2) return a.r2<b.r2;
	return a.r3>b.r3;
}
bool cmp2(node a,node b){
	if(a.r2!=b.r2) return a.r2<b.r2;
	if(a.r3!=b.r3) return a.r3<b.r3;
	return a.r1>b.r1;
}
bool cmp3(node a,node b){
	if(a.r1!=b.r1) return a.r1<b.r1;
	if(a.r3!=b.r3) return a.r3<b.r3;
	return a.r2>b.r2;
}
int calc(int r1,int r2,int r3){
	return min(r1,min(r2,r3))*min(r1,min(r2,r3))*min(r1,min(r2,r3))/4;
}
int max_i,id;
int max_h,h1,h2;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>r[i].r1>>r[i].r2>>r[i].r3;
		r[i].id=i;
		if(max_i<calc(r[i].r1,r[i].r2,r[i].r3)){
			max_i=calc(r[i].r1,r[i].r2,r[i].r3);
			id=i;
		}
		if(r[i].r3<r[i].r2) swap(r[i].r3,r[i].r2);
		if(r[i].r2<r[i].r1) swap(r[i].r2,r[i].r1);
		if(r[i].r3<r[i].r2) swap(r[i].r3,r[i].r2);
	}
	sort(r+1,r+n+1,cmp);
	for(int i=2;i<=n;i++){
		if(r[i].r1==r[i-1].r1&&r[i].r2==r[i-1].r2){
			if(max_h<calc(r[i].r1,r[i].r2,r[i].r3+r[i-1].r3)){
				max_h=calc(r[i].r1,r[i].r2,r[i].r3+r[i-1].r3);
				h1=r[i-1].id;
				h2=r[i].id; 
			}
		}
	}
	sort(r+1,r+n+1,cmp2);
	for(int i=2;i<=n;i++){
		if(r[i].r2==r[i-1].r2&&r[i].r3==r[i-1].r3){
			if(max_h<calc(r[i].r1+r[i-1].r1,r[i].r2,r[i].r3)){
				max_h=calc(r[i].r1+r[i-1].r1,r[i].r2,r[i].r3);
				h1=r[i-1].id;
				h2=r[i].id; 
			}
		}
	}
	sort(r+1,r+n+1,cmp3);
	for(int i=2;i<=n;i++){
		if(r[i].r1==r[i-1].r1&&r[i].r3==r[i-1].r3){
			if(max_h<calc(r[i].r1,r[i].r2+r[i-1].r2,r[i].r3)){
				max_h=calc(r[i].r1,r[i].r2+r[i-1].r2,r[i].r3);
				h1=r[i-1].id;
				h2=r[i].id; 
			}
		}
	}
	if(max_h>=max_i){
		cout<<1<<endl;
		if(h1>h2) swap(h1,h2);
		cout<<h1<<' '<<h2<<endl;
		cout<<max_h<<endl;
	}
	else{
		cout<<0<<endl;
		cout<<id<<endl;
		cout<<max_i<<endl;
	}
}
```


---

## 作者：JackMerryYoung (赞：0)

# 前言

月赛 T2, 其实可以当 T3...

# 正文

这题可以轻松写出暴力的 70pts. 想要拿到正解就要找性质了。

额我们可以发现只有组内最小相加有价值。那不妨先进行组内排序吧，内部三个 $r$ 分出大中小。

然后可以以组内最大为第一关键字，次大为第二关键字，最小为第三关键字排个序。

这样前两个数字相同的精灵一定是连续的。于是就暴力摞一遍求最大就行。复杂度大概 $\mathcal{O}(N \log_2 N + N)$ ???

注意：合成后的值与中、大取个 $\min$, 才是真正要求的声望值。

这里代码就不放了，具体可以参考别人的题解，比如[这篇](https://www.luogu.com.cn/blog/bloodstalk/p8585-qiu-zhuang-jing-ling-di-zhuan-shuo-ti-xie)。

# 后文

应该算是很新颖的一道题了。

---


# 新的家乡

## 题目背景

2102 年，太阳系的生态终于不再支持人类的生存。人类打算沿着之前建好的星际长途路线去往金牛座蟹状星云中的某行星 $\beta$ 谋求发展。


## 题目描述

你作为第一批科研人员，提前来到了 $\beta$ 星建造基地。

$\beta$ 星盛产锰钛矿石。基地需要一些**高度相同**的柱子，而每根柱子都需要由**恰好**两根锰钛矿石顺次连接组成。例如，若你有两根高度分别为 $h_x,h_y$ 的锰钛矿石，那么你可以用两者合成为一根高度为 $h_x+h_y$ 的柱子。每根锰钛矿石**显然至多被使用一次**。

现在你来到了 $\beta$ 星的锰钛矿场，摆在你面前的是 $n$ 根高度分别为 $h_i$ 的锰钛矿石。经过严密思考后你发现，房屋的牢固程度应该取决于柱子的数目，而不是柱子的高度。所以你想知道，使用面前这 $n$ 根矿石最多可以建造出多少根高度相同的柱子？

但小花觉得这个问题太 easy 了，于是 ta 选择多问你一嘴：假设柱子高度均为 $h$，基地最多可以建出 $\mathrm{res}$ 根柱子，那么在柱子数目同为 $\mathrm{res}$ 时 $h$ 可以有几种不同的取值？

## 说明/提示

额外样例见附加文件 `ex.in/out`。

对于 $20\%$ 的数据，$1\leq n\leq 100$。

对于 $40\%$ 的数据，$1\leq n \leq 10^3$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$1\leq h_i \leq 3\times 10^3$。


## 样例 #1

### 输入

```
4
4 7 6 5```

### 输出

```
2 1```

## 样例 #2

### 输入

```
6
1 1000 100 1500 10 1800```

### 输出

```
1 15```

# 题解

## 作者：Lovely_Elaina (赞：26)

这是本菜鸡的首篇题解，望通过^_^

---

### 思路

>数据范围为 $1\leq n\leq 10^6$，$1\leq h_i \leq 3\times 10^3$。

数据很小啊，我们可以用[桶排序](https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777)来完成。

其实，让整个题难度变成黄题就是因为它的数据范围。一说到桶排序，整个题就简单起来了呢。

~~上次用桶排序的时候还是上次，太久远了~~

我们使用两个桶，先用一个桶记矿石高度，循环把所有合成的柱子高度放在另一个桶中就搞定了。

### AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
//数组大小 常量前用 k 符合规范
const int karr = 10010;
int b[karr],c[karr];
//max 为系统函数，所以用 _max
int n,sub,ans,ans2,_max;
int main(){
    //开启 cin cout 优化
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> sub;
		b[sub]++,_max = max(_max,sub);
	} 
	for(int i = 1; i <= _max; i++)
		for(int j = 1; j <= i; j++)
			if(b[i] && b[j]){
				if(i == j) c[i+j] += b[i] / 2;
				else c[i+j] += min(b[i],b[j]);
			}
    int _2max = _max * 2;
	for(int i = 1; i <= _2max; i++) ans = max(ans,c[i]);
	for(int i = 1; i <= _2max; i++) if(c[i] == ans) ans2++;
	cout << ans << " " << ans2 << endl;
	return 0;
}


```

第一次写题解，不知道怎么写，望大佬提醒！

审核大大辛苦了~

---

## 作者：xixisuper (赞：13)

# P8587 新的家乡



吐槽一下比赛题目的难度分配，似乎这场比赛后两道题更简单（或者我适合做的题是有针对性的）。

## step 1：读题

刚看到题面的我内心一寒，还以为是遇到了[小木棍](https://www.luogu.com.cn/problem/P1120)的翻版。

但仔细一看，这题是跟小木棍有区别的，主要是下面这几条。

- 而每根柱子都需要由**恰好**两根锰钛矿石顺次连接组成。
- 每根锰钛矿石**显然至多被使用一次**。

这两条限制了组合的方式，与小木棍一题产生了很大的不同。


------------
## step 2：解题

我们根据一组样例来展开解题。

#### 样例输入    
```
5
3 2 1 5 4
```
#### 样例部分
```
2 3
```
遇题不决，暴力美学（我是向来打暴力打到癫狂的那种人）。

对于本题，我想出了两种暴力的解法。

### 解法一：

用一个数组 $sum[k]$ 存放柱子长度为 $k$ 时能够组成的柱子个数，将每根锰钛矿石分别与其他的矿石组合在一起，并把对应的柱子长度即 $sum[ h_i+h_j ]$ 加 $1$，最后统计出柱子数最多的方案个数，按题目输出即可。

这个暴力方案是枚举每一个锰钛矿石所能组成的柱子的长度，时间复杂度 $O(n^2)$ ，显然是会超时。

![](https://cdn.luogu.com.cn/upload/image_hosting/jvgib07m.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

- 样例解析

一号矿石分别和二号到五号矿石可以组成长为 5、4、8、7 的柱子。

二号矿石分别和三号到五号矿石可以组成长为 3、7、6 的柱子。

三号矿石分别和四号到五号矿石可以组成长为 6、5 的柱子。

四号矿石可以和五号矿石组成长为 9 的柱子。

### 解法二：

枚举在柱子长度一定的情况下，能够组成多少根柱子。表面上看与解法一并没有什么两样，但我们改变一下存储的方式。

从题目中可以看出，锰钛矿石高度的范围很小，直接就可以用纯的标记数组将其存下，于是便有了以下的算法。

我们将 $vis[k]$ 表示为高度为 $k$ 的锰钛矿石的个数。当我们枚举柱子长度为 $i$ 的时候，如果一个高度为 $j$ 的锰钛矿石能够组成一个长度为 $i$ 的柱子，就必须要有一个高度为 $i-j$ 的锰钛矿石与之对应。**即如果 $ vis[ j ] $不为 $0$ 且 $vis[ i-j ] $ 也不为 $0$时 ，那就一定可以组成柱子**。

注意 $vis$ 数组中存放的是锰钛矿石的个数，所以在满足上述条件后，柱子的个数需要增加的是 $min(vis[ j ],vis[ i-j ])$ 。也有特殊情况，比如 $j=i-j$ 时，需要特判。还要注意 $i$ 和 $j$ 的取值范围，当 $j$ 枚举到 $i$ 的一半时就可以不用继续枚举了，因为再往后所出现的情况会与之前的相重复，没有必要再进行运算。

这个暴力方案是枚举在柱子长度一定的情况下，能够组成多少根柱子，时间复杂度约为 $O(max(h_i)^2)$ ，在最极端的状况下时间复杂度也不会超过 $10^7$ ，不会超时。

![](https://cdn.luogu.com.cn/upload/image_hosting/tzmzkvum.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

- 样例解析

当柱子长度为 3、4、8、9 时，都只能组成一根柱子。

当柱子长度为 5、6、7 时，能够组成两根柱子。

------------
## step 3：代码

蒟蒻的代码，采用的为上文所提到的解法二，不喜勿喷。
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1e6;
int vis[MAXN],n,gin=2147483647;
//vis[i]表示高度为i的锰钛矿石的个数
//gin存放所有锰钛矿石中高度最小的一个，减少不必要的循环
int ans,res=-1,now_res;
//now_res存放每一次枚举当前柱子长度时所能被构成的柱子个数
//res存放最大的柱子个数
//ans存放能构成最大的柱子个数的方案数 
int main(){
	cin>>n;
	int x;
	for(int i=0;i<n;i++){
		cin>>x;
		vis[x]++;
		gin=min(gin,x);
	}//输入部分
	for(int i=gin;i<=6000;i++){//枚举柱子长度
		now_res=0;
		for(int j=0;j+j<=i;j++){
			if(j+j==i&&vis[j]){//特判，两根长度相等的锰钛矿石 
				now_res+=(vis[j]/2);
				continue;
			}
			if(vis[j]&&vis[i-j]){//即上文中所提到的计算方法
				now_res+=min(vis[j],vis[i-j]);
			}
		}
		if(now_res==res) ans++;
		//若当前柱子个数等于之前的最大柱子个数，则方案数加 1 
		if(now_res>res){
			res=now_res;
			ans=1;
		}//若当前柱子个数大于之前的最大柱子个数，则更新 
	}
	cout<<res<<' '<<ans;
	return 0;
}
```


---

## 作者：bloodstalk (赞：10)

很好的一个题
## 题意

给定 $n$ 个高度分别为 $h_i$ 的柱子，两个柱子能合并成一个 $h_i+h_j$ 的新柱子，每根柱子至多被使用一次。

询问最多能建出多少根高度相同的柱子，并且最优答案下柱子的高度有多少种情况。

$1\leq n\leq 10^6$ ， $1\leq h_i \leq 3\times 10^3$。

## 思路

### 爆搜！

- 首先我们想，如果我们 $n^2$ 正向枚举有多少种方案数，显然会超时。

- 怎么办呢！我们看到  $1\leq h_i \leq 3\times 10^3$ ，正难则反！我们直接设 $f[i]$ 表示柱子高度为 $i$ 时能有多少根不就行了吗，给一个 $mp[i]$ 数组存储高度为 $i$ 的柱子有多少根，然后直接 $ O(h^2) $ 枚举就能过了。
- 最后给方案数排序，输出最大的有多少根柱子，再看有多少种高度跟他一样就行了。

## 代码实现

```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 3e4 + 5;
using namespace std;
int max(int x,int y){return x > y ? x : y;}
int min(int x,int y){return x < y ? x : y;}

int n,ans;
int mp[N],f[N<<1];
int Max=-1,Min=1e9;/*这些柱子的最小和最大高度*/

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

il bool mysort(int a,int b) { return a > b; }

signed main()
{
	n=read();
	for(re int i=1;i<=n;i++) 
	{
		int x = read();mp[x]++;/*存高度，更新最大高度最小高度*/
		Max=max(x,Max),Min=min(x,Min);
	}
	for(re int i=Min*2;i<=Max*2;i++)/*合并后最小的高度肯定就是高度最小的柱子乘以2，最大的高度亦然*/
	{
		for(re int j=1;j<=Max*2;j++)
		{
			if(j*2 > i) break;/*前面一半已经计算了后面的一半了，所以直接break*/
			if(i-j == j) f[i] += mp[j]/2;/*两个相等的柱子相加，那么根数加上总共的一半*/
			else f[i] += min(mp[j],mp[i-j]);/*两个柱子高度不相同，那么就能配凑出两个柱子数量较小的那一个*/
		}
	}
	sort(f+1,f+Max*2+1,mysort);/*从大到小排序*/
	printf("%d ",f[1]);/*输出最多根数*/
	int Maxx = f[1];
	for(int i=1;i<=Max*2+1;i++)
	{
		if(f[i] == Maxx) ans++;/*判断有多少数量相等*/
		else break;
	}
	printf("%d",ans);/*输出高度不同的方案数*/
}
}


```


时间复杂度 $O(h^2)$ ,可以通过。

---

## 作者：wdgm4 (赞：4)

~~这道题是我考试时 ```AC``` 的......~~

------------
反正一开始读题时我是没有思路，直到我看到了数据范围。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$1\leq h_i \leq 3\times 10^3$。

$h_i$ 的数据范围辣么小，可以用**桶**啊。

## 思路

先用一个桶记录锰钛矿石高度，循环一遍，把所有合成的柱子高度存放在另一个桶中，接着寻找答案即可。

## code

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define yee 1919810

using namespace std;
int n,nem,ans,ans2;
int b[7010],maxn;//b数组为锰钛矿石高度的桶 
int c[7010];//c数组为柱子高度的桶
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&nem);
		maxn=max(maxn,nem);//找到高度最高的锰钛矿石
		b[nem]++;
	} 
	for(int i=1;i<=maxn;i++){
		for(int j=1;j<=i;j++){
			if(b[i] and b[j]){//如果有这两个高度的锰钛矿石
				if(i==j) c[i+j]+=b[i]/2;//如果是相同高度的 
				else c[i+j]+=min(b[i],b[j]);//如果是不同高度的 
			}
		}
	}
	for(int i=1;i<=maxn*2;i++){//计算最多的高度相同的柱子数 
		ans=max(ans,c[i]);
	}
	for(int i=1;i<=maxn*2;i++){//计算取值数 
		if(c[i]==ans) ans2++;
	}
	cout<<ans<<" "<<ans2;
	return 0;
}

```


---

## 作者：Dregen_Yor (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P8587)。

## 更好的阅读效果

[我的博客](http://dregen-yor.123ds.tk/index.php/2022/10/17/p8587/)。

---

~~这次普及组的题好水啊~~。

# 思路

观察题目的数据，发现 $n$ 的范围很大，但 $h_i$ 的范围极小，最大只有 $3\times 10^3$，我们可以考虑用一个**桶**来储存每种高度的柱子的数量，枚举柱子的高度，再暴力统计柱子的数目即可。

注意在统计柱子数目时不要重复统计柱子数目，且统计相同高度的柱子拼接时应让柱子的个数除以 $2$，而不是和其他柱子一样去最小值。

注意只能是两个柱子拼接而成。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h[6010],ans=-1,sum;
int main(){
    scanf("%d",&n);
    h[0]=1e9;
    for(int i=1;i<=n;i++){
        int H;
        scanf("%d",&H);
        h[H]++;
    }
    for(int i=1;i<=6000;i++){
        int tmp=0;
        for(int j=1;j<=i&&i-j>=j;j++){
            if(i-j==j){
                tmp+=h[j]>>1;
                break;
            }
            tmp+=min(h[j],h[i-j]);
        }
        if(tmp>ans){
            ans=tmp;
            sum=1;
            //cout<<i<<endl;
            continue;
        }
        else if(tmp==ans){
            sum++;
           // printf("%d %d\n",i,sum);
        }
    }
    printf("%d %d",ans,sum);
    return 0;
}
```



---

## 作者：蒟蒻炒扇贝 (赞：3)

观察数据范围，注意到 $h_i$ 比较小，考虑时间复杂度基于值域的做法。

我们可以开一个桶 $b_i$ 表示长度为 $i$ 的柱子有多少。然后枚举由两根柱子可以拼起来的长度 $i$，再枚举这两根柱子中其中一个的长度 $j$，那么另外一根柱子的长度便是 $i-j$。对于每一对不相等的 $j$ 和 $j-i$，$\min(b_j,b_{i-j})$ 便是这两种柱子能拼出长度为 $i$ 的柱子数量，对于每一对相等的 $j$ 和 $j-i$，$\lfloor\frac{b_j}{2}\rfloor$ 便是这一种柱子能拼出长度为 $i$ 的柱子数量。对于每一个 $i$，我们都能通过上述计算求得所能拼出 $i$ 长度柱子的个数，取其中的最大值即可。第一问解决。

至于第二问，可以考虑把第一问所跑过的算法再跑一边，统计得到第一问答案的次数即可。

时间复杂度为 $\mathop{O(V^2)}$，其中 $V$ 是所能凑得的最大柱子长度。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int n,bu[6005],h[MAXN],vis[6005],ans2;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>h[i],bu[h[i]]++;
	int ans=0;
	for(int i=1;i<=6000;i++)
	{
		int cnt=0;
		memset(vis,0,sizeof(vis));
		for(int j=1;j<=i;j++)if(bu[j]&&bu[i-j]&&!vis[i-j])
		{
			if(i-j!=j)cnt+=min(bu[j],bu[i-j]),vis[j]=1;
			else cnt+=bu[j]/2,vis[j]=1;
		}
		ans=max(ans,cnt);
	}
	for(int i=1;i<=6000;i++)
	{
		int cnt=0;
		memset(vis,0,sizeof(vis));
		for(int j=1;j<=i;j++)if(bu[j]&&bu[i-j]&&!vis[i-j])
		{
			if(i-j!=j)cnt+=min(bu[j],bu[i-j]),vis[j]=1;
			else cnt+=bu[j]/2,vis[j]=1;
		}
		if(cnt==ans)ans2++;
	}
	cout<<ans<<" "<<ans2;
}
```


---

## 作者：Albert_Wei (赞：3)

首先，观察到数据范围， $1 \le h_i \le 3×10^3$ 。出现了一个小数据，于是考虑和这个数据相关复杂度的算法。  
我们可以用一个 $cnt[]$ ，记录每一个高度的锰钛矿石出现了多少次，然后枚举生成的柱子的高度即可。  
对于每一个高度 $i$ ，记一个 $sum$ 表示当前高度最多可以组成多少根柱子，枚举较矮锰钛矿石的高度 $j$ ，每次 $sum+=min(cnt[j],cnt[i-j])$ 累加。这里要注意，当 $j+j=i$ 时需要特判，这是两个相同的锰钛矿石拼在一起刚好成为柱子，所以 $sum$ 应该加 $cnt[j]÷2$ 。  
然后考虑怎么修改答案。这里要讨论 $sum$ 和 $res$ 的大小关系。
1.$sum<res$ ，跳过。
2.$sum=res$ ，则柱子数目为 $res$ 时 $h$ 取值多了一个，$ans++$ 。
3.$sum>res$ ，则更新答案，且这时 $h$ 取值目前只有一种，故 $res=sum,ans=1$ 。

时间复杂度 ：两层循环，故为 $O((h_i)^2)$ ，空间复杂度 $O(h_i)$ 。
最后附上代码。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n, h, cnt[3005] = {0};
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> h;
		cnt[h]++;
	}
	int res = 0, ans = 0;
	for (int i = 1; i <= 6000; i++) {
		int sum = 0;
		for (int j = max(i - 3000, 0); j <= (i - 1) / 2; j++)
			sum += min(cnt[j], cnt[i - j]);
		if (i % 2 == 0)
			sum += cnt[i / 2] / 2;
		if (sum > res)
			res = sum, ans = 1;
		else if (sum == res)
			ans++;
	}
	cout << res << " " << ans << endl;
	return 0;
}
 
```

---

## 作者：Hisaishi_Kanade (赞：2)

大致就是说 $n$ 个数，选出 $res$ 个二元组，二元组的和相同。

求 $\max \{res\}$。

第二问就是说，这 $\max\{res\}$ 个二元组有多少种选法。

注意到 $V\le3\times 10^3$，反倒 $n\le 10^6$。

可以考虑基于值域乱搞。

很容易发现，由于只能是两个矿石，那么柱子的高度不超过 $2\times V=6\times 10^3$。

枚举柱子高度，再求方案数可以使得复杂度合法。

方案数怎么求？

用桶记录第 $h$ 个矿石有多少个即可。

对于第二问，在跑一遍一模一样的，统计得到的次数就行了。

但是似乎不需要啊……新增一个变量 `cnt` 统计最大值出现次数，跑一遍就行了。

[代码](https://www.luogu.com.cn/paste/jy4smq7l)

---

## 作者：Poitry (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8587)

赛场没切掉，我太菜了。

分析一下题目，柱子最多由两根矿石组成，那么柱子的高度最大是高度最大的矿石的高度的两倍，所以跑一遍循环对于每一个高度都求一下就好了。

具体来说，首先定义一个数组 $b_i$ 表示高度为 $i$ 的矿石一共出现了 $b_i$ 次，预处理一下。

然后循环柱子高度，那么对于高度为 $i$ 的柱子只能由 $j$ 和 $i-j$ 的高度的矿石拼接而成，其中 $j \times 2\leq i$。但是如果 $i$ 是 $2$ 的倍数，那么 $2 \times j=i$ 的情况就会重复，需要特判一下。

对于每个 $j$，显然它对答案的贡献就是 $b_j$ 和 $b_{i-j}$ 的最小值。

下面放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 1000010;
int n, b[MAXN], maxn, ans, num;
signed main() {
	cin >> n;
	for(int i = 1; i <= n; i ++) {
		int x;
		cin >> x;
		b[x] ++;
		maxn = max(maxn, x);
	}
	for(int i = 1; i <= maxn * 2; i ++) {
		int sum = 0;
		for(int j = 1; j <= (i - 1) / 2; j ++) {
			sum += min(b[j], b[i - j]);
		}
		if(i % 2 == 0) {
			sum += b[i / 2] / 2;
		}
		if(sum == ans) {
			num ++;
		}
		if(sum > ans) {
			ans = sum;
			num = 1;
		}
	}
	cout << ans << ' ' << num;
	return 0;
}
```
不带注释了，大家都能看懂吧。

---

## 作者：JackMerryYoung (赞：1)

# 前言

T4, 什么奇特值域题。

# 正文

额我们发现 $N$ 实在太大，以至于 $\mathcal{O}(N \log_2 N)$ 都难以通过 ~~（真的吗？）~~。

那么看到 $V \le 3 \times 10^3$, 想到一个依赖值域的做法。

不妨直接枚举高度 $h$, 查询高度为 $h$ 的柱子个数。然后如果两者数量都大于 $0$ 就可以合并。

就这样子暴力枚举，过程中取个最大值。复杂度 $\mathcal{O}(V^2)$. 可以无压力轻松通过。

# 代码

注意柱子不要合成两次了。

``` cpp
#include<bits/stdc++.h>
using namespace std;

int N, maxh;
int bkt[114514], res[114514];

int main()
{
	cin >> N;
	for(int i = 1; i <= N; ++ i)
	{
	    int h;
		scanf("%d", &h);
		maxh = max(maxh, h);
		++ bkt[h];
	} 
	
	for(int i = 1; i <= maxh; ++ i)
	{
		for(int j = 1; j <= i; ++ j) 
		{
			if((bkt[i] > 0 && bkt[j] > 0) || (i == j && bkt[i] > 1))
			{
				if(i == j) 
				    res[i + j] += (bkt[i] / 2);
				else 
				    res[i + j] += min(bkt[i], bkt[j]);
			}
		}
	}
	
	int ans1, ans2;
	ans1 = ans2 = 0;
	for(int i = 1; i <= maxh * 2; ++ i)
		ans1 = max(ans1, res[i]);
	
	for(int i = 1; i <= maxh * 2; ++ i)
	{
		if(res[i] == ans1) 
		    ans2 ++;
	}
	
	printf("%d %d\n", ans1, ans2);
	return 0;
}
```

# 后言

小花怎么老是出值域题 QaQ...

---

## 作者：_ANIG_ (赞：1)

观察题目范围，$n$ 很大，但 $h$ 很小。枚举 $n$ 会超时，但枚举 $h$ 不会。所以可以先枚举每个高度。由于柱子是由两段锰钛矿石拼接成的，所以柱子高度最大为 $6000$。对于每个高度，再计算可以拼成多少个这样高度的柱子。由于枚举 $n$ 会超时，所以内层可以继续枚举 $h$。由于总高度是固定的，所以已知一个高度就能求另一个高度。设高度为 $i$ 的锰钛矿石出现次数为 $sum_i$，那么总高度为 $a$，当前枚举到的高度为 $b$ 时，就能拼成 $\min(sum_b,sum_{a-b})$ 根柱子。最后结果相加就行了。其中要特判 $a-b=b$ 的情况。复杂度 $O(max_h^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,p[1000005],sm[6005],idx=-1,cnt=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d",&p[i]),sm[p[i]]++;
	sort(p+1,p+n+1);
	for(int i=1;i<=6000;i++){
		int res=0;
		for(int j=1;j<3000;j++){
			if(i-j<j)break;
			if(i-j==j){
				res+=sm[j]/2;
				break;
			}
			res+=min(sm[i-j],sm[j]);
		}
		if(res>idx)idx=res,cnt=1;
		else if(res==idx)cnt++;
	}
	cout<<idx<<" "<<cnt;
}
```


---

## 作者：cyhtxdy (赞：1)

直接做正解。

注意到数据范围：高度的值域较小。那么可以考虑基于值域的做法。

使用 $\text{map}$ 记录每个高度的矿石个数，枚举所有可能凑成的高度 $i$（$i$ 的最大值是最高的矿石高度的两倍），再枚举凑成高度 $i$ 的其中一块矿石高度 $j$，那么另一块矿石高度就是 $i-j$。

记 $ans_i$ 为凑成高度 $i$ 的最多柱子数，$mp_i$ 为高度为 $i$ 的矿石个数。

那么 $ans_i=\sum\limits_{j=1}^{\lfloor \frac{i}{2} \rfloor}\min (mp_j, mp_{i-j})$。特别的，如果 $2j = i$，也就是两块高度为 $j$ 的矿石能凑成高度 $i$，则 $ans_i$ 增加 $\lfloor \frac{mp_j}{2} \rfloor$。

排序后可以得到最大值，再线性枚举一遍 $ans$ 数组即可得到方案数。

由于枚举的都是高度，所以复杂度是 $O(\max(h_i)^2)$，很稳。

给出代码：
```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int inf = 0x3f3f3f3f;
const int N = 1e6 + 7;

int n, h[N], L = inf, R = -inf, ans[N], mp[N];

int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i ++) {
		scanf ("%d", &h[i]);
		L = min (L, h[i]);//左边界 
		R = max (R, h[i]);//右边界 
		mp[h[i]] ++;//记录个数 
	}
	for (int i = L * 2; i <= R * 2; i ++) {
		for (int j = 1; j <= i / 2; j ++) {
			if (2 * j == i) {
				ans[i] += mp[j] / 2;
			}
			else {
				ans[i] += min (mp[i - j], mp[j]);
			}
			//分类计算答案 
		}
	}
	sort (ans + 1, ans + 1 + 2 * R);//排序一下方便 
	int p = ans[2 * R], q = 0;//p是最大值 
	for (int i = 1; i <= R * 2; i ++) {
		if (ans[i] == p) {
			q ++;//个数 
		}
	}
	printf ("%d %d", p, q);

	return 0;
}
```


---

## 作者：zct_sky (赞：0)

### Solution:
-----
因为 $h_i$ 的范围只有 $3\times10^3$，所以就想到了暴力搜索柱子长度。

先把每根锰钛矿石扔进一个桶里（下标为长度，值为根数），然后暴力枚举柱子长度 ，再暴力枚举其中一根柱子长度，能拼出的根数就是它的根数和它所对应的长度的根数的最小值，最后求和便是柱子总根数。

即如果用 $t_i$ 表示长度为 $i$ 的矿石根数，$maxn=\max\{h_1,h_2,h_3\dots h_n\}\times 2$，答案为 $ans$，那么答案就为：
$$f(i)=\sum\limits_{j=1}^{i} \min\{t_j,t_{i-j}\},ans=\max\{f(1),f(2),f(3)\dots f(maxn)\}$$

（$\sum\limits_{i=1}^{6000} \left\lfloor\frac{i}{2}\right\rfloor =9000000$）

最后求答案取值个数，就是把遍历时每次答案放进桶里便可。
### Code:
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*y;
}
const int N=6e3+7,M=1e6+7;
int n,h,maxn;
ll H[N],ans[M],answer;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		h=read();
		H[h]++;
		maxn=max(maxn,h*2);
	}
	for(int i=1;i<=maxn;i++){
		ll an=0;
		for(int j=1;j<=(i-1)/2;j++)an+=min(H[j],H[i-j]);
		if(!(i&1))an+=H[i/2]/2;
		ans[an]++;
		answer=max(answer,an);
	}
	printf("%lld %lld",answer,ans[answer]);
	return 0;
}
```

---


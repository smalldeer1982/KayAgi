# [蓝桥杯 2014 国 A] 排列序数

## 题目描述

如果用 a b c d 这 $4$ 个字母组成一个串，有 $4!=24$ 种，如果把它们排个序，每个串都对应一个序号：

```text
  abcd  0
  abdc  1
  acbd  2
  acdb  3
  adbc  4
  adcb  5
  bacd  6
  badc  7
  bcad  8
  bcda  9
  bdac  10
  bdca  11
  cabd  12
  cadb  13
  cbad  14
  cbda  15
  cdab  16
  cdba  17
  ...
```

现在有不多于10个两两不同的小写字母，给出它们组成的串，你能求出该串在所有排列中的序号吗？


## 说明/提示

时限 1 秒, 256M。蓝桥杯 2014 年第五届国赛

## 样例 #1

### 输入

```
bdca```

### 输出

```
11```

## 样例 #2

### 输入

```
cedab```

### 输出

```
70```

# 题解

## 作者：Wy_x (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P8620)

[更好的阅读体验？](https://www.luogu.com.cn/blog/73-54-16/solution-p8620)

------------

如果你看出来方法了，那这道题就是一道裸的全排序题。

### 思路：

- 因为数据范围是 $1 \leq n \leq 10$，可以放心使用时间复杂度为 $O(n!)$ 的全排列函数。题目由小到大编号，应选择 `next_permutation`。 

- `ans` 应该从 $0$ 开始计数。

- 每进行一次全排列后就判断全排列的结果是否和给出的字符串 $S$ 相同，两种情况：
> 1. 如果相同，则退出循环，输出现在 `ans` 的值。
> 2. 否则，`ans` 加一，同时继续全排列当前结果，直到条件 $1$ 成立。

- 关于 `next_permutation`：不懂请移步[这里](https://so.csdn.net/so/search?q=next_permutation&t=&u=&urw=)，根据需要自学。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
char c[100];
int ans=0;
// 1 ≤ n ≤ 10
//放心使用时间复杂度 O(n!) 的全排列函数
//不会超时 
int main()
{
	cin>>a;
	int l=a.size();
	for(int i=0;i<l;i++)  c[i]='a'+i;
	//因为 a 的长度 == 字符种类，进行初始化 
	//全排列我习惯字符数组，string 的我不会 
	while(true)
	{
		bool flag=1;
		for(int i=0;i<l;i++)
		{
			//判断两个字符串是否相等
			if(a[i]!=c[i])//不相等
			{
				flag=0;//标记
				break;//退出循环
			}
		}
		if(flag) break;
		//如果没有被标记过,就退出循环输出答案
		ans++;
		//注意 ans 要从 0 开始计数，
		//所以加法操作要在 break 后
		next_permutation(c,c+l);
		//求下一个全排列
	}
	cout<<ans;
	//输出编号
	return 0;
}
```

---

## 作者：Asimplename (赞：10)

这道题可以用康托展开来做。

康托展开可以用于求出某个排列排在所有排列中的第几个。对于一个长为 $n$ 的排列 $x$，它的算法为：

$X = a_1 \times (n - 1)! + a_2 \times (n-2)! + ... + x_n \times 0! + 1$

其中，$a_i$ 表示在第 $i$ 项后面有多少个比 $a_i$ 小的数。

而由于此题的序号是从 $0$ 开始的，所以可以忽略掉后面的 $+1$。

由于此题数据很小，所以我们可以暴力求出 $x_i$ 后面有多少个比它小的数即可。

```cpp
#include<iostream>
using namespace std;
string str;
int n = 0;
int ans = 0;
int cal(int x){
	int fac = 1;
	for(int i = 1; i <= x; i ++){
		fac *= i;
	}
	return fac;
}
int main (){
	cin >> str;
	n = str.size();
	for(int i = 0; i < n; i ++){
		int small = 0;
		for(int j = i + 1; j < n; j ++){
			if(str[j] < str[i]){
				small ++; 
			}
		}
		ans += cal(n - i - 1) *  small;
	}
	cout << ans;
	return 0;
} 

---

## 作者：违规用户名1431410 (赞：3)

# 题目大意
给出一个字符串，求出它是它所包含的字母组成的全排列中的第几个。
# 解题
观察数据范围，我们发现字符串总长不超过 $10$，而 $10! = 3628800 \approx 3 \times 10 ^ 6$，不会超时，直接**暴力枚举**全排列就行。
## 关于全排列
有两种实现方法，其中标准的 dfs 相信大家都已经掌握熟练所以在此不再赘述。这里我主要想介绍的是 STL 里的 next_permutation 函数，具体见[这里](https://blog.csdn.net/howardemily/article/details/68064377)。所以我们可以用 while 循环枚举全排列并判断即可。
# ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
string s1="",s2="";
long long ans;
int main()
{
	cin>>s1;
	s2=s1;
    sort(s1.begin(),s1.end());
    if(s1==s2)
    {
        puts("0");//排序后的序列是0号序列 
        return 0;
    }
    while(next_permutation(s1.begin(),s1.end()))//全排列函数 
    {
        ans++;
        if(s1==s2)
        {
            printf("%lld",ans);
            return 0;
        }
    }
	return 0;
}
```
# 后记
水题一道，即使不用函数用 dfs 也很简单，主要还是考验写代码的基本功。

---

## 作者：chrispang (赞：3)

## 题目大意

给定 $a=\{1,2,3..n\}$ 和 $a$ 的一个排列 $b$，求出将 $a$ 的所有排列按字典序排序后，$b$ 是第几个排列。

数据范围：$n\le 10$。

## 题目分析

由于数据范围对我们很友好，因此直接枚举所有排列就好了，时间复杂度为 $O(n!)$。

这里推荐一个求全排列的一个好用的函数：`next_permutation(begin(), end())`。

这个函数可以将你的 $a$ 变成下一个排列，直到所有排列枚举完毕。具体操作见代码。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

int sum;
string a;
int main(){
	cin >> a;
    string t = "";
	for (int i = 0; i < a.size(); i++)
        t += (char)(i + 'a');
	do {
		if (t == a) {
            cout << sum << endl;
            return 0;
        }
		sum++; // 排名 ++ 
	} while(next_permutation(t.begin(), t.end())); // 注意要用 do while，不然 a 枚举不到 
    return 0;
}
```

---

## 作者：linruicong_gegeji (赞：2)

## 题目大意

给出一个字符串 $s$，求 $s$ 在由 $s$ 的所有字母组成的全排列中的字典序。

## 题目分析

其实有很多人使用搜索去做这道题目。我认为没有必要。

我们可以使用自带全排列函数 `next_permutation`。不了解的同学可以学习一下，在这里就不多讲解了。

我们使用全排列函数 `next_permutation` 按顺序生成全排列的字符串。假如这次生成的字符串与目标字符串相同，那么直接输出并中止程序即可。

此处要注意一点，在开头要特判排序过后的目标串是否与原先相同。假如相同，直接输出 $0$ 即可。

## AC 代码

[记录](https://www.luogu.com.cn/record/229226001)

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,c;
int cnt;
int main()
{
    cin>>s;
    c=s;
    sort(s.begin(),s.end());//预处理，排序
    if(c==s)//假若相同，直接输出0
    {
        printf("0");
        return 0;
    }
    while(next_permutation(s.begin(),s.end()))//每次按顺序生成全排列字符串
    {
        cnt++;
        if(c==s) //若字符串与目标串相同，直接输出并终止程序
        {
            printf("%d",cnt);
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：Like_Amao (赞：1)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P8620)

**思路**

康托展开纯板子。

为了防止有人不懂康托展开是什么，康托展开就是可以解决求一个序列在这个序列的全排列按字典序排序后是第几个，且康托展开是可逆的。

因此，我们只需要求出输入的第 $i$ 个字符后面有多少个字符字典序在它前面，最后再按照康托展开求一遍即可。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string s;
	cin>>s;
	int len=s.size(),ans=0;
	for(int i=0;i<len;i++)
	{
		int cnt=0;
		for(int j=i+1;j<len;j++)
		{
			if(s[i]>s[j])
			{
				cnt++;
			}
		}
		int t=1;
		for(int j=1;j<=(len-i-1);j++)
		{
			t*=j;
		}
		ans+=(t*cnt);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：chenxinran12 (赞：1)

### 题意分析
给定一个字符串 $s$，将其按照字典序排序。求原字符串在这些字符串中的位置。
### 思路
如果用暴力过于复杂了，所以使用全排列来完成。  
我们使用 ```next_permutation``` 函数来实施全排列。这个函数的作用就是将给定的字符串重新排列出所有情况，且按照字典序排列。  
我们可以将其先记录下来，再通过这个函数寻找原字符串在第几个。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,ss;
int ans;
signed main()
{
	cin>>s;
	ss=s;
	sort(s.begin(),s.end());
	int n=s.size();
	do
	{
		if(s==ss)
		{
			cout<<ans<<"\n";
			break;
		}
		ans++;
	}while(next_permutation(s.begin(),s.end()));
    return 0;
}
```

---

## 作者：yanzixuan2024 (赞：1)

用 `next_permutation` 暴力枚举排列即可。

解释一下 `next_permutation` ，它用来生成此排列的下一个排列。用此枚举全排列，每次计数器加一，如果是当前数列，输出计数器的数值。
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int sum;
int main(){
	cin>>a;b=a;
	sort(b.begin(),b.end());
	do{
		if(a==b) return printf("%d",sum),0;
		++sum;
	}while(next_permutation(b.begin(),b.end()));
}
```

---

## 作者：xhabc66 (赞：1)

# 思路
**给大家带来一种最快的解法**

首先简化一下问题：如果**允许**出现相同字母，该怎么解呢？

答案很简单：先判断第一位字母，确定一个取值范围，再看第二个字母......一直看到在最后一位字母即可。

举个例子：设字符串 $s=abedb$，$a$ 的长度为 $n$，则在**允许相同**的情况下：
- 通过 $a_1$ 判断答案在 $0\sim624$ 之间；
- 通过 $a_2$ 判断答案在 $125\sim249$ 之间；
- 通过 $a_3$ 判断答案在 $225\sim249$ 之间；
- 通过 $a_4$ 判断答案在 $240\sim244$ 之间；
- 通过 $a_5$ 判断答案在 $241\sim241$ 之间；

答案即为 $241$。

---------------

如果不允许重复呢？

如果是不允许的话，则一个字母若是字母表中的第 $x$ 个，则他只能取**字母表空缺位置中的第 $x$ 个**。就比如如果一个字母为 `D` ，其中 `B` 已经被占了，所以 `B` 这个位置就不是空缺位置。`D` 的实际位置应为 `E` 。

那该如何从输入的字符串中获取在**允许**的情况下的字符串呢？

因为在一个字母若是字母表中的第 $x$ 个，它占到自己的**实际位置**之后会在它前面留下 $x-1$ 个空位。所以只需判断它后面有多少个字母比它小即可。**最后不用加上一，因为第一项是 $0$**。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

long long jc[27]={1},b[27];

void problem_jc()
{
	for(int i=1;i<27;i++)jc[i]=jc[i-1]*i;//初始化。注意第i位要乘上i，因为每往后一位选择都要少一。
    //注意这种写法最后必须倒过来用。
}

int main()
{
	problem_jc();
	char a[26];
	cin>>a;
	for(int i=strlen(a)-2;i>=0;i--)
	{
		for(int j=i+1;j<strlen(a);j++)
		{
			if(a[i]>a[j])b[i]++;//得出允许时的字符串。
		}
	}
	long long num=0;
	for(int i=0;i<strlen(a)-1;i++)
	{
		num+=(b[i])*jc[strlen(a)-1-i];
	}
	cout<<num;
	return 0;
}
```

---

## 作者：clarinet_pht (赞：0)

## 题意描述
给定一个由不同小写字母组成的字符串，求它在所有字母的全排列中的字典序编号（从 $0$ 开始计数）。例如，字符串 `bdca` 在字母集合 `{a,b,c,d}` 的所有排列中位于第 $11$ 位。

## 思路

这里借鉴了[康托展开](https://baike.baidu.com/item/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/7968428)的思路，~~不得不说，确实蛮有用的~~，即字符串 $X$ 的编号如下：

$$
X = \sum_{i = 1}^{n} {a_i\times(i-1)!}
$$

其中：
$n$ 是字符串长度。$a_i$ 表示在第 $i$ 个字符右侧比它小的字符数量。

具体做法如下：

对每个位置 $i$：
先统计右侧比 $s[i]$ 小的字符数量 $cnt$。再累加贡献值：$cnt \times (n-i-1)!$。最后累加值即为字典序编号。

时间复杂度为 $O(n^2)$，可以通过此题。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int fact[20];
int main()
{
	//预处理阶乘数组:fact[i]=i!
  fact[0]=1;//定义0的阶乘为1
	for(int i=1;i<=10;i++)
		fact[i]=fact[i-1]*i;
	string s;
	cin>>s;
	int n=s.size();
	long long ans=0;//字典序编号
	for(int i=0;i<n;i++)
	{
		int cnt=0;//统计s[i]右侧比它小的字符数
		for(int j=i+1;j<n;j++)
			if(s[j]<s[i])
				cnt++;
		ans+=cnt*fact[n-i-1];//累加贡献值
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：哈士奇憨憨 (赞：0)

## 思路
利用康托展开进行求解。

依次考虑每一位，统计已经跳过的排列数量。对于当前位，依次考虑每个可以使用的数。如果当前数小于排列中的数，则累加对应的排列数量。跳过 $x$ 个排列，当前排列是第 $x$ 小的排列。

举个栗子（以下数字 1 对应字母 a，数字 2 对应字母 b，依此类推）：

第 $67$ 小的排列是 $[3, 5, 1, 4, 2]$。

| 序号 | 1 | 2 | 3 | 4 | 5 |
| :--------- | :--------- | :-------- | :-------- | :-------- | :-------- |
| 可用数字 | 12**3**45 $~$ | 124**5** $~$ | **1**24 $~$ | 2**4** $~$ | **2** $~$ |
| 包含排列数 $~$| 24 | 6 | 2 | 1 | 1 |
| 跳过数字数 $~$| 2 | 3 | 0 | 1 | 0 |
| 跳过排列数 $~$| 48 | 66 | 66 | 67 | 67 |

每一位跳过数值的数量就构成了排列进制数，
跳过排列的总和就是排列编号。
## CODE
```cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int kMaxN = 13;

int v[kMaxN];
bool b[kMaxN];
int n, x, s;
string a;

int main() {
  cin >> a;
  v[0] = 1, n = a.size();
  for (int i = 1; i < n; i++) {     // 计算阶乘
    v[i] = v[i - 1] * i;
  }
  for (int i = n - 1; i >= 0; i--) {// 枚举每一位
    x = a[n - i - 1] - 'a' + 1;
    for (int j = 1; j < x; j++) {   // 枚举每个数
      s += !b[j] * v[i];            // 未用的数则累加数量    
    }
    b[x] = 1;  // 标记使用
  }
  cout << s;
  return 0;
}
```

---

## 作者：nullqtr_pwp (赞：0)

# P8620 Solution
这道题不就是 P5367 的：

>求 $1\sim N$ 的一个给定全排列在所有 $1\sim N$ 全排列中的排名。

将原字符串给离散化成一个整数的序列（$1\sim k$ 的全排列），然后直接使用**康托展开**的模板。

不会请移步[这里](https://www.luogu.com.cn/problem/solution/P5367)。

~~虽然说这道题 $n$ 的数据范围直接用暴力 $O(n!)$ 就可以~~
```cpp
#include<bits/stdc++.h>
#define int long long
#define lowbit(x) (x&(-x))
using namespace std;
inline int read(){
	register int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int mod=998244353,maxn=1314635;
int a[maxn],fc[maxn];
namespace bit{
	int bitc[maxn];
	int query(int x){int t=0;for(int i=x;i;i-=lowbit(i)) t+=bitc[i];return t;}
	void add(int x,int y,int n){for(int i=x;i<=n;i+=lowbit(i)) bitc[i]+=y;}
}
using namespace bit;
signed main(){
	fc[0]=fc[1]=1;
    for(int i=2;i<=10;i++) fc[i]=(fc[i-1]*i)%mod;
	string s,t;
	cin>>s;
	t=s;
	int n=s.length(),ans=0;
	for(int i=1;i<=n;i++) add(i,1,n);
	sort(t.begin(),t.end());
	for(int i=0;i<n;i++) 
		for(int j=0;j<n;j++)
			if(s[i]==t[j]){
				a[i+1]=j+1;
				break;
			}
	for(int i=1;i<=n;i++){
		ans=(ans+((query(a[i]-1)*fc[n-i])%mod))%mod;
		add(a[i],-1,n);
	}
	printf("%lld",ans);
}
```

---


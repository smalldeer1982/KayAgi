# 无知时诋毁原神

## 题目背景

纳西妲很喜欢排列。

![](https://img2.huashi6.com/images/resource/thumbnail/2022/07/28/14225_32552389084.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)

画师 pid：72405030

## 题目描述

纳西妲有一个 $0\sim n-1$ 的排列 $c$。她希望你构造两个同样为 $0\sim n-1$ 的排列的 $a,b$，满足 $\forall i\in[1,n],c_i=(a_i+b_i)\bmod n$。如果纳西妲的要求无法被满足，请输出 $-1$。

## 说明/提示

### 数据范围

- $\text{Subtask 1(30 pts)}$：$n\le 10$。
- $\text{Subtask 2(20 pts)}$：保证有解。
- $\text{Subtask 3(50 pts)}$：无特殊性质。

对于 $100\%$ 的数据，保证 $1\le n\le 10^5$，$c$ 构成一个排列。

## 样例 #1

### 输入

```
3
2 1 0```

### 输出

```
2 0 1
0 1 2```

## 样例 #2

### 输入

```
4
1 3 0 2```

### 输出

```
-1```

# 题解

## 作者：Xy_top (赞：12)

构造题看着就头晕，其实这题还是很简单的。

首先来考虑一下不能构造的情况：

无论给你的排列怎么打乱，它的和都不变，所以我们利用等差数列公式求出它的和为：
$\frac{n\times(n-1)}{2}$。

题目中又说让我们用两个排列构造，那么这两个排列的数字和就是 $n\times(n-1)$。

由题意得这两个东西同余于 $n$，那么相减也同余于 $n$。

即 $\frac{n\times(n-1)}{2}$ 整除 $n$，拆一下变成 $n\times\frac{n-1}{2}$，这时需要分情况讨论。

1：$n$ 为奇数。那么 $n-1$ 为偶数，$\frac{n-1}{2}$ 就是整数，$n$ 再乘以它，自然就是 $n$ 的倍数啦！

2：$n$ 为偶数。那么 $n\times (n-1)$ 就是一奇一偶，相乘得到奇数，除以 $2$ 后不是整数，肯定不是 $n$ 的倍数啦！一定无解。

然后再来考虑 $n$ 为奇数的构造。需要用到一个常用的构造方法：即右（左）移构造。

举个例子， $n=5$。那么构造的方案便是：
```
0 1 2 3 4
1 2 3 4 0
```
可以发现，第二行的第 $i$ 个就是第一行的第 $i-1$ 个，下面来证明这种构造方法可以构造出 $0$ ~ $n-1$：

根据同余定理，把右下角的 $0$ 变成 $n$ 不会影响。

然后就会发现每一列相邻两项的和都增加了 $2$，进一步观察发现他都是形如 $2\times i + 1$ 的形式 $(0 \leq i < n)$。

紧接着我们发现当 $2\times i + 1 \leq n$ 时，得到的东西就是 $1,3,...,n$，全是奇数，其中最后一项取模之后得 $0$。

当 $2\times i + 1 > n$ 时，取模完得 $2,4,...,n-1$,全是偶数。

所以这个构造方法构造出来的东西就是 $0$ ~ $n-1$，符合题意。然后就是一个桶存一下就完的事儿。

代码很简单：

```cpp
#include <iostream>
using namespace std;
int n, a[100010], ans[2][100010];
int main()
{
	cin >> n;
	if (n % 2 == 0)//没有方案的情况
	{
		cout << -1;
		return 0;
	}
	for (int i = 0; i < n; i ++)//预处理 2*i+1的每一项，记录到ans数组中
	{
		ans[0][(2 * i + 1) % n] = i;
		ans[1][(2 * i + 1) % n] = (i + 1) % n;
	}
	for (int i = 1; i <= n; i ++) cin >> a[i];
	for (int i = 0; i < 2; i ++)//根据a数组每一项的值输出预处理好的答案。
	{
		for (int j = 1; j <= n; j ++) cout << ans[i][a[j] ] << " ";
		cout << \n"";
	}
	return 0;
}
```

---

## 作者：_XHY20180718_ (赞：6)

最近诈骗题好多。。。

## 题解：
首先考虑无解情况：

~~通过看样例，我们得知偶数时是无解的。~~

证明：

$c$ 排列的和为 $\sum_{i=1}^n i=n\times (n-1)/2$，而当 $2\mid n$ 时,有：
$$\gcd(n,n-1)=1,\gcd(n,n/2)=n/2$$
所以：
$$\gcd(n,n\times (n-1)/2)=n/2$$
显然：
$$n \nmid n\times (n-1)/2$$

然而 $a$，$b$ 俩排列的总和为 $n\times (n-1)$ ,显然有：
$$n \mid n\times (n-1)$$
所以：
$$
n\times(n-1)\not\equiv n\times(n-1)/2 \bmod n
$$

显然 $n$ 为奇数时，$2\mid (n-1)$，所以 $n\mid n\times (n-1)/2$，结果也就反之。

这样我们就证明了 $n$ 为偶数时一定无解，奇数时一定有解。

这里提供一种比较好想的构造方法：

```cpp
a[i]=n-c[i]-1,b[i]=c[i]-a[i];
if(a[i]<0)a[i]+=n;
if(b[i]<0)b[i]+=n;
```
由于 $c$ 是 $1-n$ 的排列，那么 $a$ 也一定是 $1-n$ 的排列，$b$ 也显然是的。

## 代码：

```cpp
#define re register
using namespace std;
const int N=1e5+9;
bool visa[N],visb[N];
int n,a[N],b[N],c[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	if(n&1^1){puts("-1");return 0;}
	for(re int i=1; i<=n; i++)cin>>c[i];
	for(re int i=1; i<=n; i++)
	{
		a[i]=n-c[i]-1,b[i]=c[i]-a[i];
		if(a[i]<0)a[i]+=n;
		if(b[i]<0)b[i]+=n;
	}
	for(re int i=1; i<=n; i++)cout<<a[i]<<' ';cout<<endl;
	for(re int i=1; i<=n; i++)cout<<b[i]<<' ';
	return 0;
}
```


---

## 作者：Egg_eating_master (赞：6)

容易发现，当 $n$ 为奇数时，$\dfrac{c_i}{2}\bmod n$ 互不相同，因此令 $a_i=b_i=\dfrac{c_i}{2}\bmod n$ 即为一组合法的解。

下面来证明 $n$ 为偶数时无解。

一方面，$\sum c=\dfrac{n}{2}\cdot(n-1)$，由于 $\gcd(n-1,n)=1$，所以它不是 $n$ 的倍数。

另一方面，$\sum c\equiv\sum a+\sum b\equiv n(n-1)\equiv 0\pmod n$，是 $n$ 的倍数。

所以矛盾。

然后就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 100005;
int n;
int a[maxn];
int main() {
    cin >> n;
    if (n % 2 == 0) {cout << -1 << endl; return 0;}
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        if (x % 2 == 0) a[i] = x / 2;
        else a[i] = (x + n) / 2;
    }
    for (int i = 1; i <= n; i++) cout << a[i] << ' ';
    cout << endl;
    for (int i = 1; i <= n; i++) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```


---

## 作者：玄学OIER荷蒻 (赞：4)

很明显，这是一个构造题。

我们先来讨论 $n \mod 2=0$ 的情况

## 情况1：无解
三个数列的和都是 $\sum_{i=0}^{n-1} \mod n$。

套用等差数列求和公式，变成 $\frac{n\times(n-1)}{2}  \mod n$。

再化简，得到 $\frac{n}{2} \mod n$。

两个构造序列的总和之和应该等于已知的数列，在模数为 $n$ 的意义下。
把它们两个相加，一定会得到 0。

而 0 肯定不等于 $\frac{n}{2} \mod n$。

综上所述，在 $n \mod 2=0$ 的情况下，无解。

## 情况2：构造解

对于 $n \mod 2=1$ 接下来，我来说说我自己的构造。

对于和为 $c$,总数字个数为 $n$，构造两个数字。

将 $n-g-1$ 放入数组一号。

将 $2 \times g+1 \mod n$ 放入数组二号。

可以保证它们不冲突。

代码不贴了。

---

## 作者：Ja50nY0un9 (赞：2)

写一篇题解纪念一下我赛时写的 $O(n)$ 乱搞做法。~~官方题解竟然是 $O(玄学)$ 的模拟退火，差评。~~

首先，可以证明，当 $n$ 是偶数时必然无解。[官方题解](https://www.luogu.com.cn/blog/zhouyuhang/wu-zhi-shi-di-hui-yuan-shen-ti-xie)已经写得够详细了，不再赘述。

接着我们发现，因为 $c$ 是一个确定各元素但不确定顺序的排列，我们只要放在输出时处理就好了。

现在要考虑的就是如何利用取模来造出一个 $1$ 到 $n$ 的排列。

接着我们尝试手造几组小奇数数据：当 $n=3$，可以参照样例构造。而当 $n=5$，我造出了这样的一组解：

```
a = {0, 1, 2, 3, 4}
b = {1, 2, 3, 4, 0}
c = {1, 3, 0, 2, 4}
```

发现 $a, b$ 两个数组可以通过错开 $1$ 位的方式来构造出 $n$ 个不同的数。接下来我们证明对于任何奇数都可以通过这种方式构造出一组合法解。

我们钦定 $a_i=i-1$，$b_i=i\bmod5$，$n\geq3$。则 $c_1=0+1=1$。显然，前 $\dfrac{n-1}{2}$ 项构成了一个公差为 $2$ 的等差数列。由于小于 $n$ 的奇数共有 $\dfrac{n-1}{2}$ 个，我们就可以不重不漏地构造出所有符合条件的奇数。

接下来我们考虑第 $\dfrac{n+1}{2}$ 项。则 $c_i=(a_i+b_i)\bmod n=\dfrac{(n+1)+(n-1)}{2} \bmod n = 0$。通过这种方式，我们构造出了 $0$。

与上面同理，后 $\dfrac{n+1}{2}$ 项是一个等差数列，包含小于 $n$ 的所有偶数。这样，我们就构造出了所有小于 $n$ 的非负整数。

接下来就是输入并定位每一个 $c_i$ 在原数组中的位置。我的实现方式是把 $c$ 的每个元素的位置计算出来并存入新的 $c$ 数组。这非常容易实现，见代码。

```cpp
# include <iostream>
using namespace std;
int a[100001], b[100001], c[100001];
int n;

int cal(int x){
    if(x & 1)
        return (x >> 1) + 1;
    return ((x + n) >> 1) + 1;
}

int main(){
    cin >> n;
    if (n % 2 == 0){
        cout << -1;
        return 0;
    }
    for (int i = 1; i <= n; i++){
        a[i] = i;
        b[i] = i - 1;
        cin >> c[i];
        c[i] = cal(c[i]);
    }
    a[n] = 0;
    for (int i=1; i <= n; i++)
        cout << a[c[i]] << ' ';
    cout << endl;
    for (int i = 1; i <= n; i++)
        cout << b[c[i]] << ' ';
    return 0;
}
```

---

## 作者：Comentropy (赞：2)

## 分析和解答
~~一眼构造。~~

构造时可以观察奇偶性。

因为 $a$，$b$，$c$ 皆为 $0\sim n-1$ 的排列，并有$c_i \equiv (a_i+b_i) \pmod{n} $。

可知 $\displaystyle \sum_{i=1}^{n}c_i = \frac{n(n-1)}{2}$，$\displaystyle \sum_{i=1}^{n}(a_i + b_i) = n(n+1)$。

而当 $n\equiv 0 \pmod{2}$ 时，$ LHS \equiv \frac{(n-1)}{2} \not\equiv 0 \pmod{n}$，$RHS \equiv 0 \pmod{n}$，又 $ LHS = RHS$，故矛盾。

当 $n \not\equiv 0 \pmod{2}$ 时，显然可以构造 $a_i = b_i$


## 做题时应注意

1. 构造题，可以优先观察数据。
2. 注意观察一些比较简易的性质，如奇偶性。

## 代码（解题部分）

```cpp
    if(n%2==0){
        printf("-1");
        return 0;
    }
    for(int i=1;i<=n;i++)
        if(c[i]%2==0)
            a[i]=b[i]=c[i]/2;
        else
            a[i]=b[i]=(c[i]+n)/2;
```


---

## 作者：vectorwyx (赞：2)

首先 $n$ 为偶数时一定无解。证明考察一个长度为 $n$ 的排列的元素之和为 $\frac{n(n-1)}{2}$，当 $n$ 为偶数时元素之和模 $n$ 等于 $\frac{n}{2}$。那么两个排列相加得到的新序列的所有元素之和模 $n$ 应该等于 $0$，这样的序列不可能是一个排列。

$n$ 为奇数只需要令 $a_i=b_i=\frac{c_i}{2}\pmod n$。由于 $n$ 是奇数所以 $2^{-1}$ 即为 $\frac{n+1}{2}$。这样得到的 $a,b$ 也一定是排列，考虑反证法，如果存在两个位置 $i\not=j$ 满足 $\frac{c_i}{2}=\frac{c_j}{2}\pmod n$，则 $(c_i-c_j)\frac{n+1}{2}=0\pmod n$。由于 $n,n+1$ 互质，所以 $n,\frac{n+1}{2}$ 互质，因此式子等价于 $c_i-c_j=0\pmod n$，即 $c_i=c_j$，与 $c$ 是排列矛盾。

代码略。

---

## 作者：strlen_s_ (赞：2)

## 分析

首先，考虑无解情况。

设 $Sumc= \sum_{i=1}^n c_i=\dfrac{n \times (n-1)}{2}$。

设 $Sum= \sum_{i=1}^n a_i+b_i=n \times (n-1)$。

根据题意 $c_i=(a_i+b_i) \bmod n$,可以得:

$Sumc \bmod n=Sum \bmod n $。

分奇偶性讨论。

当 $n$ 为偶数时，$Sum \bmod n=n \times (n-1) \bmod n=0$。

$Sumc \bmod n = \dfrac{n \times (n-1)}{2} \bmod n=\dfrac{n}{2} \times (n-2)+ \dfrac{n}{2}\bmod n= \dfrac{n}{2}$。

所以 $Sumc$ 不等于 $Sum$,但又因为 $Sumc \bmod n=Sum \bmod n $，所以与题意不符，故 $n$ 为偶数时无解。

所以奇数下有解。

考虑一种构造方法：

$a_i=n-c_i-1$,$b_i=2 \times c_i-n+1$。

这样所有的 $c_i$ 都会单独对应一个 $a_i$,$b_i$，而且  $c_i=(a_i+b_i) \bmod n$。

所以做完了。

### 代码：

```

#include<bits/stdc++.h>
//#define int long long
using namespace std;
int read(){
	int x=0,f=1;
	char c;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=1e5+100;
int c[N],n;
int a[N],b[N];
signed main(){
	n=read();
	for(int i=1;i<=n;i++)c[i]=read();
	if(!(n&1))puts("-1");
	else{
		for(int i=1;i<=n;i++){
			a[i]=n-c[i]-1;
			b[i]=(2*c[i]-n+1+n)%n;//+n 是为了防止减出符。 
		}
		for(int i=1;i<=n;i++)printf("%d ",a[i]);puts("");
		for(int i=1;i<=n;i++)printf("%d ",b[i]);
	}
	return 0;
}

```

---

## 作者：s4CRIF1CbUbbL3AtIAly (赞：1)

我们发现输入的排列可以随意交换顺序，所以我们可以先假设排列为 $n-1,n-2,...,0$。

还是因为可以随意交换顺序，所以我们继续假设其中一个排列为 $0,1,...,n-1$。

这时如果剩下一个排列出现重复，无论如何交换都无法成功。

最后，只需要把得到的两个数列按原排列输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],n;
int c[100005];
map<int,bool> b;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		c[i]=(n-i)-(i-1);//两个已知数列
		if(c[i]<0) c[i]+=n;
	}
	for(int i=1;i<=n;i++){
		if(b[c[i]]){//有重复
			cout<<-1;exit(0);
		}
		b[c[i]]=1;
	}
	for(int i=1;i<=n;i++) cout<<c[n-a[i]]<<" ";cout<<endl;//对应清楚数列
	for(int i=1;i<=n;i++) cout<<n-1-a[i]<<" ";
	return 0;
}
```

---

## 作者：McIron233 (赞：1)

~~赛时十分钟写下正解，草稿纸的力量啊。~~

在适当的计算后，我们不难发现：

$$
\begin{aligned}
&0 + 0 \equiv 0 \pmod n \\
&1 + 1 \equiv 2 \pmod n \\
&\cdots \\
&(n-1) + (n-1) \equiv n-2 \pmod n \\
\end{aligned}
$$

以 $n=3$ 为例，则：

$$
\begin{aligned}
&0 + 0 \equiv 0 \pmod 3 \\
&1 + 1 \equiv 2 \pmod 3 \\
&2 + 2 \equiv 1 \pmod 3 \\
\end{aligned}
$$

所以当 $n=3$ 时有解。

又以 $n=4$ 为例，则：

$$
\begin{aligned}
&0 + 0 \equiv 0 \pmod 4 \\
&1 + 1 \equiv 2 \pmod 4 \\
&2 + 2 \equiv 0 \pmod 4 \\
&3 + 3 \equiv 2 \pmod 4 \\
\end{aligned}
$$

且无论如何排列，都不会有解，这一点可以自行实践。

综上可以发现，当 $2 \nmid n$ 时必定有解，否则无解，原因：$\sum c_i=0+1+2+…+(n-1)\equiv \frac{n(n-1)}{2}\equiv \frac{n}{2}\not\equiv 0\equiv n(n+1)\equiv 2(0+1+2+…+(n-1))=\sum(a_i+b_i)\pmod n$
 
故本题做法如下：

- 当 $n$ 为偶数，无解；
- 当 $n$ 为奇数，读取 $c_i$，如果 $c_i$ 是偶数，那么 $a_i=b_i=c_i \div 2$，否则 $a_i=b_i=(c_i+n) \div 2$。

```cpp
#include<bits/stdc++.h>
#define FILE(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout)
#define Close fclose(stdin);fclose(stdout)
#define lowbit(x) ((x)&(-x))
#define smax(x,y,z) max(x,max(y,z))
#define smin(x,y,z) min(x,min(y,z))
#define cube(x) (x*x*x)
#define I inline
#define N 100005
#define int long long
using namespace std;
const int modd=1e9+7;
int n,ans[N];
signed main(){
    scanf("%lld",&n);
    if(n&1){
        for(int i=1;i<=n;i++){
            int c;scanf("%lld",&c);
            ans[i]=((c&1)?((c+n)>>1):(c>>1));
        }
        for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
        puts("");
        for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
    }
    else puts("-1");
	return 0;
}
```

---

## 作者：HYdroKomide (赞：1)

本文按照一个正常 OIer 的推理思路，逐步讲解本题做法。
### 思路：
首先，观察排列性质。易得，排列的顺序可以不用考虑。（反正顺序先后不影响构造）所以下文我们自动把序列排序后再进行探讨。

然后我们手推几组可以发现，$2\mid n$ 时，总是配不出正确结果。证起来也很容易，对原排列求和发现 $\sum_{i=0}^{n-1} c_i$ 必然是奇数，然而我们要构造的两个排列之和则是偶数，因此肯定构造不出来。

接着我们考虑怎么简单地构造。在不是很会数论的情况下，我们还是认为让每次的 $a_i=b_i$ 会比较简单。对于所有偶数，我们使 $a_i=b_i=c_i/2$。

这时，在 $a_i$ 和 $b_i$ 中，我们已经将 $0 \sim \frac{n-1}{2}$ 的所有数用完了。到了下一个数 $\frac{n+1}{2}$，我们惊奇的发现配出的结果竟然是 $(n+1)\mod n=1$。接下来的则是 $\frac{n+3}{2}$，求和结果是 $(n+3)\mod n=3$，以此类推。于是后面的构造也迎刃而解。

要是会基础数论的话，那就是一眼题了。

### 程序如下：
```cpp
#include<cstdio>
const int N=1e5+1;
int n,a[N],c;
int main(){
    scanf("%d",&n);
    if(n%2==0){//n是偶数，无解。
    	printf("-1\n");
    	return 0;
	}
    for(int i=1;i<=n;i++){
    	scanf("%d",&c);
    	if(!(c&1))a[i]=c>>1;//如果c是偶数，则答案是c/2
    	else a[i]=(c+n)>>1;//否则是(c+n)/2
		printf("%d ",a[i]);
	}
	puts("");
	for(int i=1;i<=n;i++)printf("%d ",a[i]);//输出储存的第二行答案
    return 0;
}
```

### THE END

---

## 作者：TernaryTree (赞：0)

做这题首先要搞清楚一点：**这个排列给了和没给是一样的，因为你把它和答案同时随意打乱顺序都满足条件。**

于是我们考虑什么时候输出 `-1`。

这个 `-1` 不可能是由排列而来的，所以我们想到通过 $n$ 判断。判断什么呢？判断其奇偶性。

当 $n$ 为偶数时，原排列可以重组为 $0\sim n-1$ 依次排列。也就意味着我们构造出的 $a,b$ 排列之和需要满足其奇偶性为 `偶 奇 偶 奇……`。而奇数能等于偶数加奇数，偶数等于偶数加偶数或奇数加奇数，所以简单手玩一下就能发现，我们无法使得奇偶性满足，也就意味着 $n$ 为偶数时输出 `-1`。

当 $n$ 为奇数时，非常显然的，我们对 $0\sim n-1$ 内每个数对 $2$ 做模 $n$ 意义下除法，即可得到一个新排列。新排列的两倍即为原排列，于是我们得到答案。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5 + 1;

int n;
int a[maxn];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    if (!(n & 1)) return (puts("-1"), 0);
    for (int i = 1; i <= n; i++) {
        cout << (a[i] & 1 ? a[i] + n >> 1 : a[i] >> 1) << " ";
    }
    cout << endl;
    for (int i = 1; i <= n; i++) {
        cout << (a[i] & 1 ? a[i] + n >> 1 : a[i] >> 1) << " ";
    }
    cout << endl;
    return 0;
}
```

---

## 作者：Kazeno_Akina (赞：0)

这是一道有趣的题目（~~且很水~~）。

首先让我们来看一下这道题最大的特点：每组 $abc$ 之间相互独立。（比如题目中给出的例子，第二行究竟是 $2 1 0$ 还是 $0 1 2$ 不影响我们求解的速度，因为反正都是把 $0$、$1$、$2$ 对应的 $a$ 和 $b$ 求出来。）

那么弄清楚这一点，我们就可以暂时先抛开第二行输入的顺序，根据第一行输入的 $n$ 计算从 $0$ 到 $n-1$ 的对应 $a$ 和 $b$。

首先，非常清晰的一点在于，当 $n$ 是偶数时，直接输出 $-1$ 即可。从数学上很容易证明这一点：集合 $a$ 和集合 $b$ 的元素和加在一起为 $n\times(n-1)$ ，其对 $n$ 取模为 $0$ ；然而 $c$ 集合中的元素和为 $\dfrac{n\times(n-1)}{2}$ ，当 $n$ 为偶数时模 $n$ 余 $\dfrac{n}{2}$ ，当 $n$ 为奇数时模 $n$ 余 $0$ 。也就是说我们只需要考虑 $n$ 为奇数的情况。

这种情况下有一种思路变得合适了起来：即以下标为 $0$ 的位置作为起点，设 $a_{0}$ 为 $0$ ，$b_{0}$ 为 $0$ ，并在循环时，每当 $i$ 加 $1$，就让 $a$ 数组的值加 $2$，$b$ 数组的值减 $1$。如此循环，即可得到两个合适的数组。这种数组的生成方法必然成立，因为 $+2-1$ 与 $+1$ 并没有任何区别。

最后放代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long n;
long long a[N],b[N],c[N];
int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	if(!(n&1))//相当于对2取模，这样速度快于直接写%
	{
		cout << -1;
		return 0;
	}
	for(int i=0;i<n;i++) cin >> c[i];
	a[0]=1;
	b[0]=n-1;
	for(int i=1;i<n;i++)
	{
		a[i]=a[i-1]-1;
		if(a[i]<0) a[i]+=n;
		b[i]=b[i-1]+2;
		if(b[i]>=n) b[i]-=n;
	}
	for(int i=0;i<n;i++) cout << a[c[i]] << " ";//输出时对输入顺序简单处理即可
	cout << endl;
	for(int i=0;i<n;i++) cout << b[c[i]] << " ";
	return 0;
}
```
------------
本蒟蒻的第一篇题解，求过求过！！

---

## 作者：honglan0301 (赞：0)

两个模偶数的完全剩余系（以下称“完系”）相加不是完系，而两个模奇数的完系相加必是完系。因此只需根据 $n$ 的奇偶性判断有无解。  

而在有解时，根据完系的性质，因为 $c_i$ 是模奇数的完系，故 $2\times c_i$ 和 $-c_i$ 都是模该奇数的完系（因为 $2$ 和 $-1$ 与奇数 $n$ 互质）。于是构造 $a_i=2\times c_i\bmod n,b_i=-c_i\bmod n$ 即可。  

代码很简单，不放了。

---

## 作者：Rubidium_Chloride (赞：0)

Disorder.

首先考虑存在解的情况。

需求 $\sum a_i+b_i\equiv \sum c_i\pmod n$。

即 $n(n-1)\equiv \dfrac{n(n-1)}{2}\pmod n$。

即 $n|\dfrac{n(n-1)}{2}$

即 $2|n-1$。

也就是 $n$ 是奇数的时候才有解。

然后考虑构造 $a_{i}=b_{i}=\left(\dfrac{n+1}{2}c_{i}\right)\bmod n$

手动验证即知成立。

现在大家都喜欢把 MO 题搬到 OI 里来是吧。

---

## 作者：ran_qwq (赞：0)

因为 $a,b,c$ 都是 $0\sim n-1$ 的一个排列，则 $\sum_{i=1}^na_i=\sum_{i=1}^nb_i=\sum_{i=1}^nc_i=\dfrac{n(n-1)}{2}$。又因 $\forall i\in[1,n],c_i=(a_i+b_i)\bmod n$，则 $\forall i\in[1,n],n\mid(a_i+b_i-c_i)$。易得 $n\mid\sum_{i=1}^na_i+b_i-c_i$，代入一开始得出的结论得 $n\mid\dfrac{n(n-1)}{2}$，即 $2\mid(n-1)$，$n$ 为奇数。所以若 $n$ 为偶数，无解。

若 $n$ 为奇数时，一种合法的构造为 $\forall i\in[1,n],a_i=n-c_i-1,b_i=(2c_i+1)\bmod n$。

此时 $\forall i\in[1,n],c_i=(a_i+b_i)\bmod n$。

代码太简单了，不贴了。

---

## 作者：gyyyyx (赞：0)

很显然，这题构造出的排列只是顺序与 $a$ 有关。

也就是说，构造的时候不用管 $a$，输出的时候才需要理它。

那我们不妨设 $a={0,1,...,n-1}$，然后打一个 $n=1\sim n$ 的表来看看哪些情况可以构造。

```
1 YES
2 NO
3 YES
4 NO
5 YES
6 NO
7 YES
8 NO
9 YES
10 NO
```

可以看到偶数的情况都是不能构造的。

正好比赛是 IOI 赛制，提交两遍测试一下，大概可以确定这个结论是正确的。

假设这个结论是对的，那说明答案一定和奇偶性有关。

思考有什么是奇数能做但偶数不能做的。

想到两个：

1. 奇数不含有偶数因子

2. 任意整数加一个奇数，结果的奇偶性一定会改变

有什么用？

我们先看几组数据：

```
Input1
1
0
Output1
0
0

Input2
3
0 1 2
Output2
0 2 1
0 2 1

Input3
5
0 1 2 3 4
Output3
0 3 1 4 2
0 3 1 4 2

Input4
7
0 1 2 3 4 5 6
Output4
0 4 1 5 2 6 3
0 4 1 5 2 6 3
```

哎，构造出的 $b,c$ 完全相同。（真不是知道结论后写的，是赛时手推推出来的）

假设给出一个 $n$ 为奇数，必定方法构造出完全相同的 $b,c$。

那 $b_i+c_i\equiv a_i\ (mod\ n)$ 就可以转化为 $2b_i\equiv a_i\ (mod\ n)$。

因为 $n$ 为奇数，因此 $n$ **不含有偶数因子**，与 $2$ 必定互质。

等式可转化为：$b_i\equiv \frac{1}{2}a_i\ (mod\ n)$。

如果 $a$ 是一个偶数那就好办，如果 $a_i$ 是一个奇数呢？

不用着急，退回前一步：$2b_i\equiv a_i\ (mod\ n)$。

我们知道了任意整数加 $n$ 会改变奇偶性，那奇数的 $a_i$ 加 $n$ 也会改变 $a_i$ 的奇偶性，也就是变成偶数。

并且在取模的情况下，一个数加上模数的倍数，取模后的结果不变。

因此等式转化为：$b_i\equiv \frac{1}{2}(a_i+n)\ (mod\ n)$

所以结论就是：

$$
b_i=c_i=\left\{
\begin{array}{ll}
\frac{1}{2}a_i&a_i\%2=0\\\\
\frac{1}{2}(a_i+n)&a_i\%2=1
\end{array}
\right.
$$

然后模拟一下就行了。

完整代码：
```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
inline int read(){
    int x(0),f(1);char c(getchar());
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
void write(int x){
    if(x>9) write(x/10);
    putchar(x%10^48);
}
int n,a[N],b[N];
int main(){
    n=read();
    if(n&1){
        for(int i(1);i<=n;++i) a[i]=read();
        for(int i(2);i<=n;i+=2) b[i]=(i>>1);
        for(int i(1);i<=n;i+=2) b[i]=(n+i>>1);
        for(int i(1);i<=n;++i){write(b[a[i]]);putchar(' ');}puts("");
        for(int i(1);i<=n;++i){write(b[a[i]]);putchar(' ');}puts("");
    }
    else puts("-1");
    return 0;
}
```

---

## 作者：251Sec (赞：0)

官方题解用了乘法逆元，但是没必要！

当 $n$ 为偶数时显然无解，这里不多赘述。

当 $n$ 为奇数，构造 $a,b \in [0,n)$：

$$a_i\equiv-c_i\pmod n$$

$$b_i\equiv2c_i\pmod n$$

正确性显然。

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
int a[100005];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    if (n % 2) {
        for (int i = 1; i <= n; i++) {
            printf("%d ", (n - a[i]) % n);
        }
        putchar('\n');
        for (int i = 1; i <= n; i++) {
            printf("%d ", a[i] * 2 % n);
        }
    }
    else {
        puts("-1");
    }
    return 0;
}
```

---

## 作者：what_can_I_do (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8880)

水。

我们可以知道，一个偶数可以分解成两个数相加。那么我们要让 $a_i+b_i=c_i$，就可以先把 $c_i$ 化成偶数。就比如 $c_i=7,n=9$，就可以把 $c_i$ 加上 $n$（因为可以对 $n$ 取模，所以可加上 $n$），变为 $c_i=16$。此时的 $n$ 为奇数，所以我们才能让 $c_i$ 都变为偶数，可如果 $n$ 为奇数，则 $c_i$ 不能全为偶数，所以 $n$ 为偶数输出 $-1$（不成立）即可。

现在 $c_i$ 已经全为偶数了，所以我们只要把 $a_i$ 和 $b_i$ 都变为 $c_i$ 除以 $2$，由于 $c$ 数组可以保证所有元素互不相同，所以可以保证 $a$ 和 $b$ 的所有元素都互不相同，所以我们只要输出两次 $c$ 数组除以 $2$ 后的数组就行了。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[100010];
int main()
{
	scanf("%d",&n);
	if(n%2==0)
	{
		cout<<-1;
		return 0;
	}
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&c[i]);
		if(c[i]%2==1) c[i]+=n;
	}
	for(register int i=1;i<=n;i++) printf("%d ",c[i]/2);
	printf("\n");
	for(register int i=1;i<=n;i++) printf("%d ",c[i]/2);
    return 0;
}
```

---


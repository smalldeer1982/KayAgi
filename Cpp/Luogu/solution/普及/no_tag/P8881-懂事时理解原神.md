# 懂事时理解原神

## 题目背景

胡桃喜欢用 dfs 求最短路，尽管这有可能会得到错误的答案。

![](https://img2.huashi6.com/images/resource/2021/03/01/8812956h7p1.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)

画师 pid：6657532

## 题目描述

具体地，给定一个有 $n$ 个点和 $m$ 条边的无向无权图。则 dfs 求最短路的算法伪代码具体如下：

```
vis[], dis[]
dfs(u):
	vis[u] = 1
	记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S
	以随机的顺序遍历 S: 
		dis[v] = dis[u] + 1
		dfs(v)
solve():
	for i in [1, n]: 
    	dis[i] = -1;
        vis[i] = 0
	dis[1] = 0
	dfs(1)
```

其中，```以随机的顺序遍历 S``` 可以被理解为随机打乱 $S$，得到每一种结果的概率均为 $\frac{1}{|S|!}$，并按照打乱后的顺序遍历。

现在，胡桃想要知道，如果她调用函数 ```solve()```，得到的最短路数组 ```dis[]``` 完全正确的概率有多大。```dis[]``` 被认为完全正确，当且仅当 $\forall i\in[1,n]$，```dis[i]``` 的值均等于从 $1$ 到 $i$ 的最短路长度（特别地，若 $1$ 无法走到 $i$，则认为 $1$ 到 $i$ 的最短路长度为 $-1$）。

## 说明/提示

- 对于 $20\%$ 的数据，$n,m\le 10$。
- 对于 $50\%$ 的数据，$n,m\le 1000$。
- 对于另外 $30\%$ 的数据，保证所给出的图为一仙人掌（任意一条边至多只出现在一条环上）。
- 对于 $100\%$ 的数据，$1\le n,m\le 50000，1\le T\le 10$，保证所输入的图无重边、自环。

## 样例 #1

### 输入

```
1
5 4
1 3
1 2
3 4
2 5```

### 输出

```
1.000```

## 样例 #2

### 输入

```
1
4 4
1 2
2 3
3 1
4 3```

### 输出

```
0.000```

# 题解

## 作者：H2ptimize_AFO (赞：16)

~~胡桃敲可爱的~~~

### 分析、实现

先贴上 dijkstra 求最短路的代码：
```cpp
void dijkstra()
{
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
	bool vis[MAXN]={};
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	q.push(make_pair(0,1));
	while(!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=true;
		for(int i=0;i<G[u].size();i++)
		{
			int v=G[u][i];
			if(dis[v]>dis[u]+1)
			{
				dis[v]=dis[u]+1;
				q.push(make_pair(dis[v],v));
			}
		}
	}
}
```

与题中的 dfs 对比，很容易发现在 dijkstra 算法中，每当一个结点 $v$ 被进行计算时，它会比较所有的前驱结点，最终留下最优值。

但在 dfs 算法中，一个结点最多只会被计算一次。不难发现，当一个结点有且仅有一个前驱时，dfs 算法才能正确计算最短路。

而此时图实际上是一棵无根树，这个 dfs 算法实际上是用来计算树上结点深度的正解。

所以当且仅当结点 $1$ 所在连通块是一棵树时，才能正确进行最短路计算。否则，一旦结点 $1$ 所在连通块中出现环，环上部分节点计算必然出错。

综上所述，只需要对结点 $1$ 所在连通块检查是否存在环即可。

~~（其实还有一种简单粗暴的办法，用 dfs 和 dijkstra 各运行一遍，比较答案。）~~

### Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=5e4+10;

int n,m;
bool ans;
vector<int>G[MAXN];

bool vis[MAXN];
void dfs(int u,int fa)//有别于有向图判连通
{
	vis[u]=true;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(v==fa)continue;
		if(!vis[v])dfs(v,u);
		else ans=true;
		if(ans)return;
	}
}

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		ans=false;
		cin>>n>>m;
		for(int i=0;i<=n;i++)
		{
			G[i].clear();
			vis[i]=false;
		}
		for(int i=1;i<=m;i++)
		{
			int u,v;
			cin>>u>>v;
			G[u].push_back(v);
			G[v].push_back(u);
		}
		dfs(1,0);
		if(ans)cout<<"0.000\n";
		else cout<<"1.000\n";
	}
	return 0;
}
```

~~胡桃敲可爱的~~~

---

## 作者：_O_v_O_ (赞：6)

~~原神，启动！~~

啥诈骗题……

首先，我们要知道伪代码中的随机化没用，真正答案只能是 $1.000$ 或 $0.000$，这个题就变成了一个 hack 题。

其次，我们要知道什么数据能够 hack 掉这份代码。

我们能轻易发现：在这个图中，如果一个结点不与 $1$ 号点连通，这个点的答案一定是正确的（$-1$）。

我们考虑一个环，设环上的结点为 $1{,}2{,}3{,}\cdots {,}n$，我们从 $1$ 号点开始遍历，如果 $dis_2=1$，则 $dis_n=n-1$，但实际上 $dis_n=1$，故如果存在环，肯定错误。

我们发现，如果 $1$ 的连通块不是环，那么这个连通块一定是树。那么这个代码就是一个求树上每个点深度的代码，故如果 $1$ 的连通块不是环，答案即为 $0.000$。

那么这个题就转变成了一个判环问题。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int T;

int n,m;

struct edge{
	int to,nxt;
}e[200005];
int edgenum,head[100005];
void addedge(int u,int v){
	e[++edgenum].nxt=head[u];
	head[u]=edgenum;
	e[edgenum].to=v;
}

bool vis[100005],fg;
void dfs(int x,int lst){
	vis[x]=true;
	for(int i=head[x];i;i=e[i].nxt){
		if(e[i].to==lst) continue;
		if(!vis[e[i].to]){
			dfs(e[i].to,x);
			if(fg) return;
		}
		else{
			fg=true;
			return;
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>T;
	while(T--){
		memset(head,0,sizeof(head));
		memset(vis,0,sizeof(vis));
		edgenum=0;
		fg=false;
		cin>>n>>m;
		for(int i=1;i<=m;i++){
			int u,v;
			cin>>u>>v;
			addedge(u,v);
			addedge(v,u);
		}
		dfs(1,0);
		cout<<!fg<<".000"<<endl;
	}
	return 0;
}
```


---

## 作者：hjqhs (赞：4)

一道诈骗题。~~建议下载国家反诈APP。~~  
首先不与 $1$ 连通的结点是 $-1$，所以只需要考虑与 $1$ 连通的结点情况。  
思考什么情况下 dfs 会出错。如果一个结点到结点 $1$ 有 $\ge 2$ 条以上的路径，dfs 只会搜其中一条，答案就是错误的，即当与 $1$ 相连的连通块**存在环**时，dfs 算法会出错。而当没有环时，所有结点到结点 $1$ 的路径都是唯一确定的，这种情况 dfs 就不会出错。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=50005;
const int MAXM=100005;
int tt;
int n,m,edges_num;
int head[MAXN],to[MAXM],nxt[MAXM];
bool vis[MAXN];
namespace solve{
    void init(){
        n=m=edges_num=0;
        memset(head,0,sizeof(head));
        memset(to,0,sizeof(to));
        memset(nxt,0,sizeof(nxt));
        memset(vis,0,sizeof(vis));
    }
    void addedge(int u,int v){
        nxt[++edges_num]=head[u];
        to[head[u]=edges_num]=v;
    }
    void scan(){
        cin>>n>>m;
        for(int i=1;i<=m;++i){
            int u,v;
            cin>>u>>v;
            addedge(u,v);
            addedge(v,u);
        }
    }
    bool dfs(int u,int f){
        vis[u]=1;
        for(int i=head[u];i;i=nxt[i]){
            int v=to[i];//遍历子节点
            if(v!=f){
	            if(vis[v]||(!dfs(v,u)))return 0;//如果遍历过了（即有环）或无法遍历到（不连通）返回0
            }
        }
        return 1;//否则返回1
    }
    void print(){
        bool ans=dfs(1,0);
        if(ans==1){
            cout<<"1.000"<<'\n';
        }else{
            cout<<"0.000"<<'\n';
        }
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>tt;
    while(tt--){
		solve::init();
        solve::scan();
        solve::print();
    }
    return 0;
}
```

---

## 作者：M_CI (赞：4)

~~Never gonna give you up↑Never gonna let you down↓~~

### 思路

先看到题面中的 DFS 最短路伪代码，可发现，每个结点的 $dis$ 值只会被能够到它的仅一条路径更新，若存在多条路径（$>1$ 条）可以到达该点的时候 DFS 将会出错。而因为是无向图，所以只有图中存在环的时候才会出错，所以本题就转化为了在图中判环，若有环输出 $0.000$ 否则输出 $1.000$。

### 代码
```
#include <bits/stdc++.h>
using namespace std;

int t,n,m,ans;
vector<int> g[50010];
bool vis[50010];

void dfs (int u,int fa) {
	vis[u]=1;//标记已经走过
	for (auto v: g[u]) {
		if (v==fa) continue;
		if (!vis[v]) dfs (v,u);//没访问过代表无环，继续递归
		else ans=0;//访问过则有环，答案设为0
		if (!ans) return ;//如果已经有环，退出递归
	}
}

int main () {
	cin>> t;
	while (t--) {
		cin>> n>> m;
		ans=1;//答案初值设为1，代表默认无环
		for (int i=1;i<=n;i++) {
			vis[i]=0;
			g[i].clear ();
		}//多测清空
		for (int i=1;i<=m;i++) {
			int u,v;
			cin>> u>> v;
			g[u].push_back (v);
			g[v].push_back (u);
		}
		dfs (1,0);//DFS搜索判环
		cout<< ans<< ".000\n";
	}
	return 0;
}
```

~~诈骗事罢（悲~~

---

## 作者：yang2_0 (赞：4)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P8881)

# 思路

我们可以观察 dfs 的伪代码，可以发现当有一个节点到 $1$ 号节点的路径条数 $\ge2$，也就是存在一个于 $1$ 号节点连通的环时，dfs 求最短路的算法会出错。
所以我们可以使用并查集来判断是否存在与 $1$ 号节点连通的环。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,m,f[50005],vis[50005];//vis[i]用来保存i号节点是否与一个环连通.
int find(int x)
{
	if(f[x]==x)return x;
	return f[x]=find(f[x]);//并查集，加上路径压缩.
}
signed main(){
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		int fl=1;
		for(int i=1;i<=n;i++)f[i]=i;
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=m;i++)
		{
			int u,v;
			cin>>u>>v;
			int fu=find(u),fv=find(v);
			if(fu==fv)vis[fu]=1;//当u和v本来就在一个集合里时，则说明存在一个环.
			else f[fu]=fv;//如果u和v不在一个集合里，则合并为一个集合.
		}
		for(int i=1;i<=n;i++)
		{
			if(find(i)==find(1)&&vis[i]){fl=0;break;}//当i号节点与1号节点连通且存在一个环，那么dfs求最短路的算法会失效，输出0.
		}
		cout<<fl<<".000\n";
	}
	
	return 0;
} 
```
~~胡桃可爱捏~~


---

## 作者：Iniaugoty (赞：3)

[懂事时理解原神](/problem/P8881)。

## problem

在一个无向无权图上，用一种 dfs 算法求出 $1$ 到所有点的最短路，问求出的最短路都正确的概率。对于每次可以遍历到的下一个点，其遍历到的概率是相同的。

## solution

注意到原图不一定联通。而 $1$ 之外的连通块中所有 $dis$ 一定都是 $-1$，一定可以求出正确最短路。只对 $1$ 的连通块进行考虑。

从 dfs 算法的实现开始看。它的主要部分长这个样子：

```
dfs(u):
	vis[u] = 1
	记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S
	以随机的顺序遍历 S: 
		dis[v] = dis[u] + 1
		dfs(v)
```

显然 $vis_u$ 是用来标记是否访问过 $u$ 的。

但是！$vis_u$ 在遍历接下来的结点后并没有清空，也就是说，在这段 dfs 中，每个结点最多访问一次。那么，只有在 $1$ 到每个结点只有一条路径时，一定可以求出所有最短路。

你可能会说，这不就是一棵树吗！对，这就是一棵树。而树有一个等价定义是无环的连通图。这进一步说明 $1$ 的连通块无环时答案是 $1$。

如果有环呢？显然，环上一个结点至少可以从 $1$ 通过两条路径到达。但是这里的 dfs 只会搜其中一条，根本不可能使所有点都尽早遍历到。答案为 $0$。

综上，若 $1$ 的连通块有环，答案为 $0$，否则答案为 $1$。

## code

```cpp
#include<bits/stdc++.h>
#define N 50005
using namespace std;
int T,n,m,vis[N],ans;//有环 ans 为 0，否则为 1
vector<int>e[N];//邻接表
void Dfs(int u,int fa){//dfs 判环，感觉有点像 tarjan
	vis[u]=1;//标记已访问
	for(auto v:e[u]){
		if(v==fa) continue;
		if(!vis[v]) Dfs(v,u);//前向边
		else ans=0;//返祖边
		if(!ans) return;
		//已确定有环，直接返回
	}
}
void Add(int u,int v){//连边
	e[u].push_back(v);
	e[v].push_back(u);
}
signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	cin>>T;
	while(T--){
		for(int i=1;i<=n;i++) vis[i]=0,e[i].clear();//清空，memset 常数太大建议少用或不用
		cin>>n>>m,ans=1;//初始时标记为无环
		for(int i=1,u,v;i<=m;i++)
			cin>>u>>v,Add(u,v);
		Dfs(1,0),cout<<ans<<".000\n";
		//答案保留 3 位小数，直接输出点和 3 个 0 即可
	}
	return 0;
}
```

---

## 作者：jixuan (赞：2)

#### [题面](https://www.luogu.com.cn/problem/P8881)

### 题意
给定一个有 $n$ 个点和 $m$ 条边的无向无权图，求用 dfs 求最短路的正确率。（答案其实只有 $1.000$ 或 $0.000$，不要被四舍五入骗了）。

### 思路
看一下题目给的 dfs 伪代码：
```
vis[], dis[]
dfs(u):
	vis[u] = 1
	记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S
	以随机的顺序遍历 S: 
		dis[v] = dis[u] + 1
		dfs(v)
solve():
	for i in [1, n]: 
    	dis[i] = -1;
        vis[i] = 0
	dis[1] = 0
	dfs(1)
```

显然，只要从 $1$ 出发只存在唯一一条路径可以到达该点（即 $1$ 的连通块无环，不在 $1$ 的连通块的距离确实是 $-1$），dfs 就不会出错，答案就为 $1.000$。

这题就变成了**判断 $1$ 的连通块中是否存在环**。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
bool t[50005];
bool flag;
vector<int> vis[50005];
void dfs(int now,int fa)//判断是否有环 
{
	t[now]=1;
	for(int i:vis[now])
	{
		if(i==fa)
			continue;
		if(t[i])
		{
			flag=1;//有环 
			break;
		}
		dfs(i,now);
		if(flag) return;
	}
	return;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(t,0,sizeof(t));//初始化 
		flag=0;
		for(int i=1;i<=n;i++)
			vis[i].clear();
		scanf("%d%d",&n,&m);//输入 
		for(int i=1;i<=m;i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			vis[x].push_back(y);
			vis[y].push_back(x);
		}
		dfs(1,0);
		printf("%d.000\n",1-flag);//输出 
	}
	return 0;
}
```


---

## 作者：Disjoint_cat (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8881)

## P8881 懂事时理解原神

### 0.闲话

**这是道有些骗人的题。**

关于题目中的图[…](https://www.luogu.com.cn/user/341036)[…](https://www.luogu.com.cn/user/594203)

### 1.题意

给定一个图，求用 dfs 求最短路的正确率。

**一个关于题意的说明：**$S$ 是动态变化的，即如果 $S$ 中的一个点在之前的遍历中走到了，那么不会再尝试这个点。

### 2.解法

我们一看样例输出：

> 1.000
>
> 0.000

他就不能给一个（看起来）随机一点的输出吗？！

> 你需要输出答案保留三位小数（四舍五入）后的结果。

~~这什么出题人啊，连个 SPJ 都不想写？！连个有理数取模都不想写？！~~

再一看[比赛](https://www.luogu.com.cn/contest/92183#description)声明：

> 本次比赛的题目较为特别，不属传统 OI 题目的范畴。

那是不是可能输出只可能是 `1.000` 或者 `0.000`？

---

首先，和 $1$ 不连通的节点答案肯定是 $-1$，所以我们只需要考虑 $1$ 所在的连通块。

**声明：** 下文中的「图」指的就是 $1$ 所在的连通块。

假设这个图中有环。显然环长 $\ge3$。

因为每个节点只会被遍历一次，所以遍历到它时的答案就是最终答案。

然而，我们对于环上的点，至少会有 $2$ 条不同的路径，而 dfs 只会搜一条。对于一些离根很近但是过了很久才被遍历到的节点，答案显然是错误的。

而如果其中没有环，那么 $1$ 到每个点的路径都是唯一的，答案肯定是正确的。

~~管他说的遍历顺序是啥，一个 dfs 解决。~~

### 3.code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define YJL_DRC_LCH_WJY_WQY_ZZH using
#define AK namespace
#define IOI std
YJL_DRC_LCH_WJY_WQY_ZZH AK IOI;
const int N=50005;
int _,n,m,u,v;
int head[N],nxt[N<<1],to[N<<1],tot;
bool vis[N];
void add(int u,int v){to[++tot]=v,nxt[tot]=head[u],head[u]=tot;}
bool dfs(int now,int fa)
{
	vis[now]=1;
	for(int i=head[now];i;i=nxt[i])
		if(to[i]!=fa)
			if(vis[to[i]]||!dfs(to[i],now))return 0;
	return 1;
}
int main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>_;
	while(_--)
	{
		cin>>n>>m;
		for(int i=1;i<=m;i++)
		{
			cin>>u>>v;
			add(u,v);add(v,u);
		}
		puts(dfs(1,0)?"1.000":"0.000");
		for(int i=1;i<=n;i++)vis[i]=head[i]=0;
		for(int i=1;i<=tot;i++)to[i]=nxt[i]=0;
		tot=0;
	}
	return 0;
}
```

---

## 作者：xiezheyuan (赞：1)

## 简要题意

$T$ 组数据，每组数据给出一个 $n$ 个顶点，$m$ 条边的无向无权图。求出使用下面的伪代码求 $1$ 为源点的单源最短路答案正确的概率。保留 $3$ 位小数。

```cpp
int dis[N],vis[N];// dis 是答案数组

void dfs(int u){
	vis[u]=1;
	vector<int> vct;
	for(int i=1;i<=n;i++){
		if(!vis[i] && 存在边(u,i)){
			vct.push_back(i);
		}
	}
	random_shuffle(vct.begin(),vct.end());
	for(int i:vct){
		dis[v]=dis[u]+1;
		dfs(i);
	}
}

void solve(){
	for(int i=1;i<=n;i++){
		vis[i]=0;
		dis[i]=-1;
	}
	dis[1]=0;
	dfs(1);
}
```

## 思路

可以看出，这个最短路非常像求树的深度。树有一个重要的性质就是不存在环。如果有环一定错了。

为什么？因为如果存在一个环，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/wxxv888l.png)

模拟一遍：

- $\operatorname{dis}_1=0$
- $\operatorname{dis}_4=1$
- 如果先遍历 $2$，那么 $\operatorname{dis}_2=2$，否则 $\operatorname{dis}_3=2$。
- 如果上一步先遍历 $2$，那么 $\operatorname{dis}_3=3$，否则 $\operatorname{dis}_2=3$。

正确的 $\operatorname{dis}_2=2,\operatorname{dis}_3=2$，而该算法都算错了。

读者可以再枚举几个，可以发现，环上节点会算错。这时候，如果环上再接出去一个节点，那么它依然会算错。

于是得出结论：如果存在从 $1$ 出发的环。那么答案是 $0.000$，否则答案是 $1.000$。

并查集解决。时间复杂度 $O(T(m+n)\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 50005;
int fa[N],t,n,m;
bool tag[N];

int find(int x){
	if(fa[x]==x)return x;
	else return fa[x]=find(fa[x]);
}

inline void merge(int u,int v){
	if(find(u)==find(v)){
		tag[find(v)]=1;
		return;
	}
	fa[find(u)]=find(v);
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++) fa[i]=i;
		for(int i=1;i<=n;i++) tag[i]=0;
		for(int i=1,u,v;i<=m;i++){
			cin>>u>>v;
			merge(u,v);
		}
		bool flag=1;
		for(int i=1;i<=n;i++){
			if(find(1)==find(i)&&tag[i]){
				cout<<"0.000\n";
				flag=0;
				break;
			}
		}
		if(flag) cout<<"1.000\n";
	}
	return 0;
}
```

---

## 作者：TernaryTree (赞：1)

诈骗题。

考虑一个环。通过 dfs 的最短路，显然环的最后一个结点的距离为（环内起始点的距离 $+$ 环的大小 $-\ 1$）。而正确的最后一个结点的距离是（环内起始点的距离 $+\ 1$）。由于环的大小 $\ge 3$，所以如果存在环，其最短路必定是错的。

但是这个环如果不在 $1$ 所在连通块内，那么就没事了，因为距离确实是 $-1$。

于是这题就变成了判断 $1$ 所在连通块有没有环。过程可以并查集实现。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e4 + 1;

int t, n, m;
int fa[maxn];
int book[maxn];
bool flag;

int find(int x) {
    return (fa[x] == x ? x : fa[x] = find(fa[x]));
}

int main() {
    cin >> t;
    while (t--) {
        cin >> n >> m;
        for (int i = 1; i <= n; i++) fa[i] = i, book[i] = 0;
        for (int i = 1; i <= m; i++) {
            int u, v;
            cin >> u >> v;
            u = find(u), v = find(v);
            if (u == v) book[u] = 1;
            else fa[u] = v;
        }
        flag = true;
        for (int i = 1; i <= n; i++) {
            if (book[i] && find(i) == find(1)) {
                flag = false;
                break;
            }
        }
        cout << fixed << setprecision(3) << (double) flag << endl;
    }
    return 0;
}

```

---

## 作者：InterN_NOT_FOUND (赞：1)

[题目传送](https://www.luogu.com.cn/problem/P8881)

首先，我们可以观察到胡桃写的dfs的问题：

```
vis[], dis[]
dfs(u):
	vis[u] = 1
	记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S
	以随机的顺序遍历 S: 
		dis[v] = dis[u] + 1
		dfs(v)
    
   	vis[u] = 0 //少了这个，会导致该点只能遍历一次，可能不是最短路径
solve():
	for i in [1, n]: 
    	dis[i] = -1;
        vis[i] = 0
	dis[1] = 0
	dfs(1)

```

那这个代码会在**存在需要遍历 $2$ 次的点**时出错，即存在与 $1$ 号点连通的环。

判连通可以用并查集，判环可以用dfs~~但是一时脑抽没想出dfs怎么写~~，这里用的一种类似拓扑排序的找环法，即依次删除度数为 $1$ 的点，更新其它点的度数，直到剩下的点度数都大于 $1$ ，此时就找到了环。

code:

```cpp
#include<bits/stdc++.h>

inline bool isnum(char ch){return ch>='0'&&ch<='9';}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isnum(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isnum(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

using namespace std;

const int N = 5e4 + 10;

int T = read(), n, m, fa[N], d[N];

inline int find(int x) {
	if (fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}

inline void merge(int x, int y) {
	fa[find(x)] = find(y);
}

queue<int> q; //度数为1的点的队列
vector<int> g[N];

signed main()
{
	while (T --) {
		n = read(); m = read();
		for (int i = 1; i <= n; ++i) fa[i] = i, d[i] = 0;
		memset(g, 0, sizeof(g));
		
		for (int i = 1; i <= m; ++i) {
			int u = read(), v = read();
			merge(u, v);
			g[u].push_back(v);
			g[v].push_back(u);
			d[u] ++; d[v] ++;
		}
		
		while (!q.empty()) q.pop();
		
		for (int i = 1; i <= n; ++i) {
			if (d[i] == 1) q.push(i);
		}
		
		while (!q.empty()) { //找环
			int tmp = q.front(); q.pop();
			int len = g[tmp].size();
			for (int i = 0; i < len; ++i) {
				int nxt = g[tmp][i];
				d[nxt] --;
				if (d[nxt] == 1) q.push(nxt);
			}
		}
		
		bool flag = 1;
		for (int i = 1; i <= n; ++i) { //在环上找与1号点连通的点
			if (d[i] > 1) {
				if (find(i) == find(1)) {
					printf("0.000\n");
					flag = 0;
					break;
				}
			}
		}
		if (flag) printf("1.000\n");
	}
	return 0;
}

// ypa!


```

---

## 作者：s4CRIF1CbUbbL3AtIAly (赞：0)

当搜索的时候遇到一个环，他会从某个点进入，然后经过中途每一个点（可能去了别的路径再回来）最后回到最初那个点。

然而实际上环上最短路径还可以走另一个方向，但是无论选择哪个方向都会使这个环上有节点的最短路径是错误的。

如果没有环更不可能出错，所以这题是一道诈骗题。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[50005];
vector<int> v[50005];
bool fl;
void dfs(int now,int fa){//判环
	b[now]=1;
	for(auto i:v[now]){
		if(i==fa) continue;
		if(b[i]){
			fl=1;//有环
			break;
		}
		dfs(i,now);
		if(fl) return;
	}
}
int n,m;
int main(){
	int t;cin>>t;while(t--){
		cin>>n>>m;
		memset(b,0,sizeof(b));//多测清空！
		for(int i=1;i<=n;i++) v[i].clear();fl=0;
		for(int i=1;i<=m;i++){
			int x,y;
			cin>>x>>y;
			v[x].push_back(y);
			v[y].push_back(x);
		}
		dfs(1,0);//只需要看1的连通块
		cout<<1-fl<<".000"<<endl;
	}
	return 0;
}
```

---


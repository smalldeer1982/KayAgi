# 「JEOI-R1」棋

## 题目背景

| 出题 | 标程 | 数据 | 验题 | 题解 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
 | [RedNebula](/user/478829) | [RedNebula](/user/478829) | [RedNebula](/user/478829) and [gyyyyx](/user/554574) | [gyyyyx](/user/554574) | [RedNebula](/user/478829) |
 
[RedNebula](/user/478829) 和 [_JF_](/user/361141) 在下一盘棋，然后……

## 题目描述

现在有一个 $n\times m$ 的棋盘，从上到下依次是 $1\sim n$ 行，从左到右依次是 $1\sim m$ 列，一个位于第 $x$ 行第 $y$ 列的位置被标记为 $(x,y)$。共有 $c$ 个棋子，**不重叠**地摆放在棋盘的某些位置上。一个位于 $(x,y)$ 的棋子可以走向 $(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$（如果这些位置**存在**且其上**没有棋子**）。

现有若干询问，每次询问给定 $x_1,y_1,x_2,y_2,p$，然后给定 $p$ 个位置，表示一个子矩阵的左上角位置为 $(x_1,y_1)$，右下角位置为 $(x_2,y_2)$，问是否可以移动棋子（无次数限制）使得矩阵内**有且仅有**给定的 $p$ 个位置上有棋子。**询问之间相互独立。**

为了减少程序时间复杂度的常数影响，**建议使用更快的读入方式。**

## 说明/提示

**【样例解释 \#1】**

解释以 `0` 代表空位，`1` 代表放置了棋子的位置。

初始状态：

```plain
011
100
011
```

对于第一个询问，可以证明 $(1,2)$ 处的棋子无法移出 $(1,2)$ 到 $(2,3)$ 的矩阵。

对于第二个询问，考虑把 $(3,2)$ 处的棋子移到 $(2,3)$，得：

```plain
011
101
001
```

满足询问要求。移动方式不唯一。

对于第三个询问，可以证明 $(2,1)$ 处的棋子无法移出 $(1,1)$ 到 $(2,3)$ 的矩阵。

**【数据范围】**

对于 $25\%$ 的数据，$n,m,q\le 10$，$c\le 20$。

对于另外 $25\%$ 的数据，保证 $a_i+b_i\equiv 0 \pmod 2$，$c_i+d_i\equiv 0 \pmod 2$。

对于另外 $25\%$ 的数据，保证 $n\cdot m-c\le(x_2-x_1+1)\cdot (y_2-y_1+1)-p$。

对于 $100\%$ 的数据，$2\le n,m\le 10^5$，$1\le c,q\le 10^5$，$c\le n\cdot m$，$1\le a_i\le n$，$1\le b_i\le m$，$\sum p\le 2\times 10^5$。对于每个询问，$1\le p\le (x_2-x_1+1)\cdot (y_2-y_1+1)$，$x_1\le c_i\le x_2$，$y_1\le d_i\le y_2$。

**【提示与说明】**

提供一种较快的读入一个 `int` 类型非负整数的方式。调用下文中的 `read()`，其作用是返回输入中的一个非负整数，同时读取其后的一个字符。

```cpp
int read() {
  int x(0);
  char c(getchar());
  while (c < '0' || c > '9') c = getchar();
  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
  return x;
}
```

## 样例 #1

### 输入

```
3 3 5
1 2
1 3
2 1
3 2
3 3
3
1 2 2 3 0
1 2 3 3 4
1 2
1 3
2 3
3 3
1 1 2 3 2
1 3
2 2```

### 输出

```
NO
YES
NO```

# 题解

## 作者：封禁用户 (赞：3)

# 题解 - 棋

## 题意简述

出题人觉得自己写得比较明白，所以不想再加简述。

## 部分分 1

只是觉得大部分的暴力都应该跑得过，给点暴力分。依照题意模拟能过吧。

## 部分分 2

下文称一个位置 $(x,y)$ 为奇数位置，当且仅当 $x+y\equiv 1\pmod 2$，偶数位置则相对，$x+y\equiv 0\pmod 2$。

我们考虑任意两个偶数位置，一个有棋子，另一个是空位，那么经过一些移动，另一个空位必然可达。

首先如果路径上没有点，那么一定有一条路径，这个不想解释了。

如果路径上会被阻隔，那么只要让阻隔的那个点移过去就可以了，等价。

这启示我们分奇偶判断。

## 部分分 3

这一部分都是子矩阵内空间不是很够的提示。

这启示我们既要考虑棋子够不够，还要考虑空位够不够。

## 正解

~~这样一看，好像上面的部分分都不是真的在给分，只是给一点思考的提示。~~

结论：看**奇数位置的棋、奇数位置的空、偶数位置的棋、偶数位置的空够不够**。

对于如何计算奇数/偶数位置的总量：

- **当有任意一维长为偶数的时候**：显然奇偶数位置相等（考虑这一维相邻两行/列两两配对互补），总位置除以二即为每一种的数目。

- **当两维都长为奇数的时候**：考虑两维长度同时 $\bmod\ 2$（两两配对互补），发现只可能一种比另一种刚好多 $1$ 个，这一个就是任意一个角的奇偶。

综上，如果两维 $n,m$ 都为奇数，左上角为奇数位置，那么奇数位置数就是 $\lceil\frac{nm}{2}\rceil$，偶数位置数即为 $\lfloor\frac{nm}{2}\rfloor$；否则，奇数位置数是 $\lfloor\frac{nm}{2}\rfloor$，偶数位置数是 $\lceil\frac{nm}{2}\rceil$。

那么上述四个变量对于任意一个子矩阵都可以 $O(1)$ 求出。最后时间复杂度 $O(C+\sum p)$。

~~std 用的是 `iostream`，跑得很快，有人会被卡常吗？~~

~~记得开 `long long`。~~

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll N, M, C, C0, C1, Q, R0, R1;

int main() {
  cin >> N >> M >> C;
  for (int a(0), b(0); C--;) {
    cin >> a >> b;
    if ((a + b) & 1)
      ++C1;
    else
      ++C0;
  }
  R0 = ceil(N / 2.0 * M) - C0; // 偶数空有多少。注意左上角必为偶数空
  R1 = floor(N / 2.0 * M) - C1; // 奇数空有多少
  cin >> Q;
  for (ll x1(0), y1(0), x2(0), y2(0), p(0), c0(0), c1(0), r0(0), r1(0); Q--;) {
    cin >> x1 >> y1 >> x2 >> y2 >> p;
    c0 = c1 = 0;
    for (int c(0), d(0); p--;) {
      cin >> c >> d;
      if ((c + d) & 1)
        ++c1;
      else
        ++c0;
    }
    r0 = ceil((x2 - x1 + 1) / 2.0 * (y2 - y1 + 1)) - c0; // 子矩阵内偶数空
    r1 = floor((x2 - x1 + 1) / 2.0 * (y2 - y1 + 1)) - c1; // 子矩阵内奇数空
    if ((x2 - x1 + 1) & 1 && (y2 - y1 + 1) & 1 && (x1 + y1) & 1) { // 分两类讨论
      r0 = floor((x2 - x1 + 1) / 2.0 * (y2 - y1 + 1)) - c0;
      r1 = ceil((x2 - x1 + 1) / 2.0 * (y2 - y1 + 1)) - c1;
    }
    cout << ((C0 >= c0 && C1 >= c1 && R0 >= r0 && R1 >= r1) ? "YES" : "NO") // 只要四个变量都是够的，就可以移
         << endl;
  }
  return 0;
}
```


---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 处理
将棋盘交替染色（就像国际象棋棋盘一样）后，易得在黑块上的只能走到黑块，白块上的只能走到白块。
## 结论
只要有足够的棋子够放入所给方框内且方框外有足够的空间放剩余的棋子即可（黑白两个分别计算）。

所以我们只要算出黑块和白块分别的算出总的，部分的，剩余的，棋子占的~~好多~~。
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,x,y,c,a,b,ax,ay,ba,by;
signed main(){
    cin>>n>>m;
    cin>>c;
    if((n*m)%2==0){
        ax=ay=n*m>>1;
    }else{
        ax=(n*m+1)>>1;
        ay=(n*m-1)>>1;
    }//总的黑白快
    for(int i=1;i<=c;i++){
        cin>>a>>b;
        if((a+b)%2==0)x++;
        else y++;
    }//各棋子
    int q;
    cin>>q;
    while(q--){
        int x0,y0,x1,y1,p,h,l,sx,sy;
        cin>>x0>>y0>>x1>>y1>>p;
        h=x1-x0+1,l=y1-y0+1;
        if((h*l)%2==0){
            sx=sy=h*l>>1;
        }else{
            if((x0+y0)%2==0){
                sx=(h*l+1)>>1;
                sy=(h*l-1)>>1;
            }else{
                sx=(h*l-1)>>1;
                sy=(h*l+1)>>1;
            }
        }//部分黑白块
        
        int cx=0,cy=0,dx=0,dy=0;
        while(p--){
            int x,y;
            cin>>x>>y;
            if((x+y)%2==0){
                cx++;
            }else{
                cy++;
            }
        }//要放的黑白块
        dx=sx-cx;
        dy=sy-cy;//差
        if(cx<=x&&cy<=y&&dx<=ax-x&&dy<=ay-y)cout<<"YES\n";
        else cout<<"NO\n";
    }
    return 0;
}
```
## 后记
照着题解调了一上午，发现是取模没加括号。

---

## 作者：TernaryTree (赞：0)

对棋盘进行一个色的染。如果横纵坐标和为偶数则染白否则染黑。

在黑色格子上的棋子只能走到黑色格子上，在白色格子上的棋子只能走到白色格子上。

对于每一个子矩阵，其中需要的黑棋子个数和白棋子个数需要小于等于各自的总个数。空着的黑格子和白格子数量也要算出来进行比较。

代码容易实现：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, m, c, q;
int t0, t1;
int a0, a1, b0, b1;
int s0, s1;
int c0, c1, d0, d1;

signed main() {
    cin >> n >> m >> c;
    t0 = (n * m & 1 ? (n * m + 1) >> 1 : n * m >> 1);
    t1 = (n * m & 1 ? (n * m - 1) >> 1 : n * m >> 1);
    while (c--) {
        int x, y;
        cin >> x >> y;
        a0 += !  !  !  !  !  !  !(x + y & 1);
        a1 += ! ! ! ! ! ! ! ! ! !(x + y & 1);
    }
    b0 = t0 - a0, b1 = t1 - a1;
    cin >> q;
    while (q--) {
        int x0, y0, x1, y1, p, h, w;
        cin >> x0 >> y0 >> x1 >> y1 >> p;
        h = x1 - x0 + 1, w = y1 - y0 + 1;
        s0 = (h * w & 1 ? h * w + (x0 + y0 & 1 ? -1 : 1) >> 1 : h * w >> 1);
        s1 = (h * w & 1 ? h * w + (x0 + y0 & 1 ? 1 : -1) >> 1 : h * w >> 1);
        c0 = c1 = d0 = d1 = 0;
        while (p--) {
            int x, y;
            cin >> x >> y;
            c0 += !  !  !  !  !  !  !(x + y & 1);
            c1 += ! ! ! ! ! ! ! ! ! !(x + y & 1);
        }
        d0 = s0 - c0;
        d1 = s1 - c1;
        puts(c0 <= a0 && c1 <= a1 && d0 <= b0 && d1 <= b1 ? "YES" : "NO");
    }
    return 0;
}
```

---


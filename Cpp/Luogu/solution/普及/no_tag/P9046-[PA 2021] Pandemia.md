# [PA 2021] Pandemia

## 题目描述

某国有 $n$ 座城市，其中 $\forall 1 \leq i < n$，城市 $i$ 与城市 $i + 1$ 有**双向**道路相连。

该国发生了疫情，一个城市要么无人感染，要么全体感染。具体地，一个城市初始时被感染当且仅当 $s_i = 1$。

疫情会扩散，每一天上午，你可以为一个未感染的城市的居民接种疫苗，下午，每个被感染的城市会向相邻的城市扩散，如果相邻的城市未接种疫苗，它将立即全员感染。

你作为城市管理者，想要知道执行最优策略的情况下，最少会有几个城市的所有人都被感染。

## 说明/提示

#### 样例 #1 解释
测试点一：第一天接种城市 $7$，第二天接种城市 $1$。

测试点二：第一天接种城市 $5$，第二天接种城市 $7$。

测试点三：初始不存在疫情，因此不需要接种。
#### 数据范围
对于 $100\%$ 的数据，$1 \leq n, T \leq 10^5$，$1 \leq \sum n \leq 10^6$。

## 样例 #1

### 输入

```
3
8
00110100
10
1001000010
4
0000```

### 输出

```
5
7
0```

# 题解

## 作者：mahaorui2012 (赞：1)

# 思路

观察到初始有疫情的所有城市会把所有初始没有疫情的 城市分割为若干个区间。

## 怎么隔离

对于一个区间 $[l,r]$，有两种情况：

### $l=1$ 或 $r=n$

则此时可以花费一天来将不为 $1$ 或 $n$ 的一个端点处打疫苗来将答案减少 $r-l+1$。

### $1<l\le r<n$

则此时又有两种情况：

#### $r-l+1\le 2$

此时只能将两个端点之一花费一天打疫苗，让另一个端点牺牲。 

#### $r-l+1>2$

此时可以花费一天时间将其中一个端点打疫苗。

由于在给一个端点打完疫苗后区间全部被感染所需的时间会由 $(r-l+1)\div 2$ 变为 $r-l+1$，所以由下文结论可得，最优策略为在下一天将另外一个端点往内一个城市处（原端点已被感染）打疫苗。 

我们可以将这种操作称为一次“隔离”。

## 隔离什么 

在不打疫苗的情况下，对于一个区间 $[l,r]$，其在时刻 $t$ 对答案的贡献有两种情况：

### $l=1$ 或 $r=n$ 

当 $t \le r-l+1$ 时，贡献为 $1$，否则贡献为 $0$。

### $1<l \le r<n$

当 $t \le (r-l+1)\div 2$ 时，贡献为 $2$，当 $t+0.5=(r-l+1)\div 2$ 时，贡献为 $1$，否则贡献为 $0$。

观察可发现，在 $r-l+1$ 值越小时，其贡献越容易变为 $0$。由于题目需求答案最小值，所以可以得出最优策略：**优先隔离长度**（既 $r-l+1$）**最大的区间，放弃长度较小的区间**。

但是，这样做有一个小问题：$l=1$ 或 $r=n$ 的区间的长度缩减速度更慢，所以应将所有区间按**全部被感染所需时间从大到小**排序，然后依次隔离。

记得特判没有任何城市初始时被感染或全部城市初始时已被感染的情况。 
# AC CODE
```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;

int n,m;
string s;

struct seg{
	int l,r,t;
};vector<seg> e;

const bool cmp(const seg& a,const seg& b){
	return a.t>b.t;
}

int main(){
	int t;
	cin>>t;
	while(t--){
		e=vector<seg>();
		cin>>n;
		cin>>s;
		int cnt1=0;
		for(int i=0;i<n;++i){
			cnt1+=(s[i]=='1');
		}if(!cnt1){
			cout<<"0\n";
			continue;
		}else if(cnt1==n){
			cout<<n<<'\n';
			continue;
		}
		int curlen=0;
		if(s[0]=='0') ++curlen;
		for(int i=1;i<n;++i){
			if(s[i]=='1'){
				if(curlen){
					e.push_back({i-curlen,i-1,(i==curlen?curlen*2:curlen)});
				}curlen=0;
			}else{
				++curlen;
			}
		}if(curlen){
			e.push_back({n-curlen,n-1,curlen*2});
		}sort(e.begin(),e.end(),cmp);
		m=e.size();
		
		int curt=0;
		int curin=0;
		int ans=0;
		while(curt*2<e[curin].t){
			//cout<<e[curin].l<<' '<<e[curin].r<<' '<<e[curin].t<<endl;
			if(e[curin].l==0 || e[curin].r==n-1){
				ans+=e[curin].r-e[curin].l-curt+1;
				++curt;
			}else{
				if(curt*2+2>=e[curin].t){
					++ans;
					++curt;
				}else{
					ans+=e[curin].r-e[curin].l-curt*2-1+1;
					curt+=2;
				}
			}++curin;
			if(curin>=m){
				break;
			}
		}//cout<<e[curin].l<<' '<<e[curin].r<<' '<<e[curin].t<<endl;
		cout<<n-ans<<'\n';
	}return 0;
} C++
```

---

## 作者：LHW_Cosset_Idiot (赞：1)

### 理解题意： 
这个问题要求我们通过最优策略来防止疫情扩散到尽可能少的城市。在每一天上午接种疫苗，下午感染会传播给未接种的相邻城市。

可以简要理解为怎样尽早停止疫情传播。 
### 分析思路：
我们从城市的状态中，搜索所有被感染的城市。如果一个城市是感染的，如果它的相邻城市如果还没有感染，就需要接种疫苗，防止疫情进一步扩散。因为每天只能接种一个城市，所以我们要尽可能先隔离出较大城市片区。
### 分析情况：
#### 普通情况：
- 没有被感染的城市片区处在两座感染城市之间，最优策略是先花费两天时间将这个片区隔离起来，当然，从最大片区开始。注意的是，假设先接种左边城市，在当天下午最右边城市会感染，所以感染总数要加一。
- 没有被感染的城市片区处在一座感染城市和边界之间，只需要花费一天就能隔离该片区。
#### 特殊情况：
- 如果初始时所有城市都是未感染的，那么显然不需要接种疫苗。
- 如果初始时所有城市都已经感染，那么即使接种疫苗，也无法阻止城市之间的扩散。

针对各种情况进行模拟即可，不给出标准程序。

---

## 作者：Null_h (赞：1)

## 前言

贪心，然而假了两次。

## 思路

考虑简化一下问题，相当于给定多个区间（对应全 0 区间），这些区间两边在不断扩展，每秒可以给任意区间加隔板，求最少能扩展的长度。

对于某个区间，超过一定时间后就不再产生贡献，于是考虑按照这个时间降序排列，优先向时间长的区间加隔板。发现最左和最右的区间是特殊的，他们只能在一边扩展，但是同样也能对其维护时间。

为什么这个贪心是对的？如果存在一个每秒的增量 $d$，那么每过一秒，增量会减少所有达到限制时间的区间的限制，无论对于什么区间，每次操作会减去 $1$ 的增量，那么每次选择时间最大的区间操作，可以保证剩下的区间的限制时间尽量小。

还有个小细节，增量为 $2$ 的区间在操作一次后会变成一个更长的增量为 $1$ 的区间，当然可以直接使用优先队列维护，但是发现操作一次后的区间限制时间更长了，所以下一次还是对其操作，因此直接两次一起减（注意剩余长度小的时候的特判）。

算是贪心里套贪心了？

总之打得很不爽，纪念一下。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
struct hbr{
	int s;
	int d;
}q[N];
bool operator <(hbr a,hbr b){
	return a.s*2/a.d>b.s*2/b.d;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		int num=0,fl=0;
		int ans=n,t=0,cnt=0;
		for(int i=1;i<=n;i++){
			char c;
			cin>>c;
			if(c=='0'){
				num++;
			}else{
				if(!fl){
					fl=1;
					q[++cnt]={num,1};
				}else{
					q[++cnt]={num,2};
				}
				num=0;
			}
		}
		q[++cnt]={num,1};
		sort(q+1,q+1+cnt);
		for(int i=1;i<=cnt;i++){
			int s=q[i].s,d=q[i].d;
			s-=d*t;
			if(s<=0)break;
			if(d==1){
				ans-=s;
				t++;
			}else{
				if(s==1||s==2){
					ans--;
					t++;
				}else{
					ans-=s-1;
					t+=2;
				}
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---


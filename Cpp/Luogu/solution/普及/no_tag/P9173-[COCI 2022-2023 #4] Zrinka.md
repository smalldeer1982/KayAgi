# [COCI 2022/2023 #4] Zrinka

## 题目描述

给你两个长度分别为 $n$ 和 $m$ 的数组，它们只由 $0$ 和 $1$ 组成。

你的任务是用偶数替换每个 $0$，用奇数替换每个 $1$。

替换之后，两个数组都应该是单调递增的且所有元素均大于 $0$，并且你最多可以使用每个正整数一次，使用的最大数字要尽可能的小。

## 说明/提示

样例 $1$ 解释：

一组可行解：$(\varnothing),(1,2,3,5)$

样例 $2$ 解释：

一组可行解：$(2,3,4,5),(1,6,8,9)$。

样例 $3$ 解释：

一组可行解：$(2, 3, 6, 8, 9),(4,10,12,13)$。

|子任务编号|	附加限制|	分值|
|:-:|:-:|:-:|
| $0$ | 是样例 | $0$ |
| $1$ |	$n=0$ | $15$ |
| $2$ |	第一个数组只包括 $0$ | $20$ |
| $3$ |	$n,m\leq 500$ | $20$ |
| $4$ |	无附加限制 | $7$ |

## 样例 #1

### 输入

```
0
4 1 0 1 1```

### 输出

```
5```

## 样例 #2

### 输入

```
4 0 1 0 1
4 1 0 0 1```

### 输出

```
9```

## 样例 #3

### 输入

```
5 0 1 0 0 1
4 0 0 0 1```

### 输出

```
13```

# 题解

## 作者：_buzhidao_ (赞：13)

[题面传送门](https://www.luogu.com.cn/problem/P9173)
# 题目分析
其实贪心不会超时，就是不能通过，详见[这里](https://www.luogu.com.cn/record/113320597)。  
这道题可以根据 $a,b$ 的填写顺序，列成一张表。~~图可能有点丑。~~
![](https://cdn.luogu.com.cn/upload/image_hosting/72z195dp.png)
显然，我们要从左上角移动到右下角，把 $a,b$ 全部填写完。  
我们只能向下或向右走。如果把所有路径都尝试一遍，就成了递归，必然超时。  
  
所以我们需要——
## 动态规划
$dp$ 大小：$(n+1)\times(m+1)\times2$，最大占用 $200\text{MB}$ 空间，小于题目限制。  
$dp_{i,j,0}$ 表示 $a$ 数组填写 $i$ 个数，$b$ 数组填写 $j$ 个数，$a$ 数组**当前的**最大值。  
$dp_{i,j,1}$ 表示 $a$ 数组填写 $i$ 个数，$b$ 数组填写 $j$ 个数，$b$ 数组**当前的**最大值。  
  
例如：  
$a=(0),b=(0,0,1)$，已知 $dp_{0,3}=(0,5),dp_{1,2}=(6,4)$。目标：填充全部。可结合表格分析。  
![](https://cdn.luogu.com.cn/upload/image_hosting/abehr3gg.png)
- 路径 $1$：从 $dp_{0,3}$ 开始填写：因为 $a_1 \ne b_3$，所以 $dp_{1,3}=(1,5)$。
- 路径 $2$：从 $dp_{1,2}$ 开始填写：因为 $b_3 \ne b_2$，所以 $dp_{1,3}=(6,5)$。


综上，因为要取**最小值**，所以得到答案 $=\min(\max(1,5),\max(6,5))=\min(5,6)=5$。

## 递推公式
$dp_{i,j}$ 初始化为 $(\inf,\inf)$。
#### 当 $i \ne 0$：
- 当 $a_i=a_{i-1}$：$dp_{i,j,0}=\min(dp_{i,j,0},dp_{i-1,j,0}+2)$，否则 $dp_{i,j,0}=\min(dp_{i,j,0},dp_{i-1,j,0}+1)$。
- 当 $a_i=b_j$：$dp_{i,j,0}=\min(dp_{i,j,0},dp_{i-1,j,1}+2)$，否则 $dp_{i,j,0}=\min(dp_{i,j,0},dp_{i-1,j,1}+1)$。

#### 当 $j \ne 0$：
- 当 $b_j=b_{j-1}$：$dp_{i,j,1}=\min(dp_{i,j,1},dp_{i,j-1,1}+2)$，否则 $dp_{i,j,1}=\min(dp_{i,j,1},dp_{i,j-1,1}+1)$。
- 当 $b_j=a_i$：$dp_{i,j,1}=\min(dp_{i,j,1},dp_{i,j-1,0}+2)$，否则 $dp_{i,j,1}=\min(dp_{i,j,1},dp_{i,j-1,0}+1)$。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[5005][5005][2];
int n,m,a[5005],b[5005];
const int inf=1e9;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//IO优化 
	cin>>n;for(int i=1;i<=n;++i) cin>>a[i];
	cin>>m;for(int i=1;i<=m;++i) cin>>b[i]; 
	for(int i=0;i<=n;++i){
		for(int j=0;j<=m;++j){
			if(i==0&&j==0) continue;//这种情况不存在 
			dp[i][j][0]=inf;
			//为防止代码过长，加以适当简化 
			if(i){
				dp[i][j][0]=min(dp[i][j][0],dp[i-1][j][0]+1+(bool)(a[i]==a[i-1]));
				dp[i][j][0]=min(dp[i][j][0],dp[i-1][j][1]+1+(bool)(a[i]==b[j]));
			}
			dp[i][j][1]=inf;
			if(j){
				dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][1]+1+(bool)(b[j]==b[j-1]));
				dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][0]+1+(bool)(b[j]==a[i]));
			}
		}
	}
	cout<<min(dp[n][m][0],dp[n][m][1]);//输出最优方案 
	return 0;
} 
```

---

## 作者：ran_qwq (赞：9)

### 一、算法

$n,m\leq5000$，暗示着要用 dp，贪心只能过样例，好吧其实连样例都过不去。

### 二、状态定义

定义 $dp[i][j][0/1]$ 表示 $a$ 数组替换前 $i$ 个，$b$ 数组替换前 $j$ 个，最后替换的是 $a$ 或 $b$ 数组的元素，最大数字的最小值。

### 三、状态转移方程

首先想 $dp[i][j][0]$，也就是从 $dp[i-1][j][0/1]$ 转移过来的。

- 如果从 $dp[i-1][j][0]$ 转移过来，就要看 $a[i-1]$ 和 $a[i]$ 一不一样，如果一样加 $2$，不一样加 $1$。

- 如果从 $dp[i-1][j][1]$ 转移过来，就要看 $a[i]$ 和 $b[j]$ 一不一样，一样加 $2$，不一样加 $1$。

同理，$dp[i][j][1]$ 的状态转移方程也很好想了，也是类似的，但是由 $dp[i][j-1][0]$ 转移过来的是看 $b[i-1]$ 和 $b[i]$ 一不一样而不是 $a[i-1]$ 和 $a[i]$。

### 四、答案

求全部替换最大数字的最小值，即 $dp[n][m][0]$ 和 $dp[n][m][1]$ 的最小值。

### 五、边界

边界就是 $dp[i][0][0]$ 和 $dp[0][j][0]$，即只替换一个数组，可以贪心。注意要求最小值，所以初值要赋无穷大，但 $dp[0][0][0]$ 和 $dp[0][0][1]$ 要设为 $0$。

---

## 作者：wuhan1234 (赞：4)

## 1. 编程思路。

本题要求将有 $n$ 个元素的数组 $A$ 和有 $m$ 个元素的数组 $B$ 中的 $0$ 用偶数替换，$1$ 用奇数替换。参与替换的数每个只用 $1$ 次，要求参与替换的数的最大数尽可能小，问这个最大数字是多少？

采用动态规划来完成。

设 $dp_{0,i,j}$ 表示数组 $A$ 中已替换了 $i-1$ 个数，数组 $B$ 中已经替换了 $j$ 个数，现在替换数组 $A$ 的第   $i$ 个数用到的尽可能小的最大数字；$dp_{1,i,j}$ 表示数组 $A$ 中已替换了 $i$ 个数，数组 $B$ 中已经替换了 $j-1$ 个数，现在替换数组 $B$ 的第 $j$ 个数用到的尽可能小的最大数字。

显然有 $dp_{0,0,j}=\infty (1\le j \le m)$，替换 $A$ 数组的第 $0$ 个不存在的数无意义。  $dp_{1,i,0}=\infty(1\le i \le n)$，替换 $B$ 数组的第 $0$ 个不存在的数也无意义。

下面推导状态转移方程。

设变量 $add$ 表示在状态转移时，需要在前一个数的基础上加上的数值。

$dp_{0,i,j}$ 表示要替换数组 $A$ 的第 $i$ 个数，可以将数组 $A$ 中的第 $i-1$ 个替换的数作为它的前一个数，若 $A_{i-1}\ne A_i$，则前后两个数奇偶性不同，只需在前一个数的基础上加 $1$，置 $add=1$；若 $A_{i-1}= A_i$，则前后两个数奇偶性相同，必须在前一个数的基础上加 $2$，置 $add=2$；即 $dp_{0,i-1,j}+add$。

也可以将数组 $B$ 中的第 $j$ 个替换的数作为它的前一个数，若 $B_j\ne A_i$，则前后两个数奇偶性不同，只需在前一个数的基础上加 $1$，置 $add=1$；若 $B_j= A_i$，则前后两个数奇偶性相同，必须在前一个数的基础上加 $2$，置 $add=2$；即 $dp_{1,i-1,j}+add$。

$dp_{0,i,j}$ 取 $dp_{0,i-1,j}+add$ 和  $dp_{1,i-1,j}+add$ 的最小值。

同理，$dp_{1,i,j}$ 取 $dp_{1,i,j-1}+add$ 和  $dp_{0,i,j-1}+add$ 的最小值。$add$ 的赋值方式与上面类同。

最后的答案取 $dp_{0,n,m}$ 和  $dp_{1,n,m}$ 的最小值。 

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int dp[2][5005][5005];
int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    int n,m;
    scanf("%d",&n);
    int a[5005]={0},b[5005]={0};
    int i,j;
    for (i=1;i<=n;i++)
        scanf("%d",&a[i]);
    scanf("%d",&m);
    for (i=1;i<=m;i++)
        scanf("%d",&b[i]);
    int inf = (n + m) * 5000;
    int add;
    for (i = 0; i <= n; i++)
    {
        for (j = 0; j <= m; j++)
        {
            if (i==0 && j==0) continue;
            dp[0][i][j]=inf;
            if (i!=0)
            {
                add=1;
                if (a[i]==a[i-1]) add++;
                dp[0][i][j]=min(dp[0][i][j],dp[0][i-1][j]+add);
                add=1;
                if (a[i]==b[j]) add++;
                dp[0][i][j]=min(dp[0][i][j],dp[1][i-1][j]+add);
            }
            dp[1][i][j]=inf;
            if (j!=0)
            {
                add=1;
                if (b[j]==b[j-1]) add++;
                dp[1][i][j]=min(dp[1][i][j],dp[1][i][j-1]+add);
                add=1;
                if (b[j]==a[i]) add++;
                dp[1][i][j]=min(dp[1][i][j],dp[0][i][j-1]+add);
            }
        }
    }
    printf("%d\n",min(dp[0][n][m], dp[1][n][m]));
}
```



---

## 作者：Eric1030 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P9173)

这道题是一道运用到了**多维 DP** 的题目。

那么我们来看一下状态的定义。$f[i][j]$ 是第一个数组填了前 $i$ 个数字，第二个数组填了前 $j$ 个数字，所得的最大数字的最小值。

在看状态转移方程之前我们要定义一个函数 $ntx(x,y)$，它表示最小的大于 $x$ 且 $\bmod 2$ 余数为 $y$ 的数。

接下来我们来看一下状态转移方程。

$$f[i][j]\gets min(ntx(f[i-1][j],a[i]),f[i][j])$$
$$f[i][j]\gets min(ntx(f[i][j-1],b[j]),f[i][j])$$

接下来就是边界和初始化。我们要把 $f[0][0]$ 设为 $0$，其余位置为无穷大。

但为什么要设为无穷大呢？因为要求最大的最小，其中用到了求最小值函数，如果设为 $0$ 或无穷小，那么答案就是 $0$ 或无穷小了。

最后就是输出答案 $f[n][m]$ 了。

## [AC](https://www.luogu.com.cn/record/201926367) 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[5005], b[5005], f[5005][5005];
const int inf = 1e9;
int ntx(int x, int y)
{
	for (int i = x + 1;;i++)
	{
		if (i % 2 == y)
		{
			return i;//返回最小的大于x且%2余数为y的数
		}
	}
}
int main()
{
	//输入数据
	cin >> n;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	cin >> m;
	for (int i = 1;i <= m;i++)
	{
		cin >> b[i];
	}
	for (int i = 0;i <= n;i++)
	{
		for (int j = 0;j <= m;j++)
		{
			if (i == 0 && j == 0)//a数组1个都没填，b数组也1个都没填的情况不考虑了
			{
				continue;
			}
			f[i][j] = inf;//设为无穷大
			if (i >= 1)//避免RE
			{
				f[i][j] = min(ntx(f[i - 1][j], a[i]), f[i][j]);//填数
			}
			if (j >= 1)//同上，但两种情况要分开考虑
			{
				f[i][j] = min(ntx(f[i][j - 1], b[j]), f[i][j]);//填数
			}
		}
	}
	cout << f[n][m];//输出结果
	return 0;//结束！
}
```

---

## 作者：bayiran (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9173)
## 题意
给出两个 $0,1$ 数组，用不同的奇数代替 $1$，偶数代替 $0$，求新数列最大数中的最小值。

## 解法
这种“求最大数中的最小值”的题普遍使用 DP 来做，本题也是如此。

## 分析
可以建立三维 DP 数组，定义 $dp_{i,j,0}$ 表示 $a$ 数组替换 $i$ 个，$b$ 数组替换 $j$ 个后 $a$ 数组最大数的最小值， 
$dp_{i,j,1}$ 表示此时 $b$ 数组最大数的最小值。

接下来处理状态转移方程。

- 分析 $dp_{i,j,0}$，可以从 $dp_{i-1,j,0}$ 或 $dp_{i-1,j,1}$ 得到。
  
  1. 如果从 $dp_{i-1,j,0}$ 处得到，需要考虑 $a_{i-1}$ 和 $a_{i}$ 是否相同，如果相同（也就是转换后需要同奇偶）就 $+2$，不相同 $+1$。
  2. 如果从 $dp_{i-1,j,1}$ 处得到，需要考虑 $a_{i}$ 和 $b_{j}$ 是否相同，如果相同 $+2$，不相同 $+1$。
- 分析 $dp_{i,j,1}$，可以从 $dp_{i,j-1,0}$ 或 $dp_{i,j-1,1}$ 得到。
  
  1. 如果从 $dp_{i,j-1,0}$ 处得到，需要考虑 $b_{i-1}$ 和 $b_{i}$ 是否相同，如果相同 $+2$，不相同 $+1$。这里需要注意：**考虑的是 b 数组**。
  2. 如果从 $dp_{i,j-1,1}$ 处得到，需要考虑 $b_{j}$ 和 $a_{i}$ 是否相同，如果相同 $+2$，不相同 $+1$。

现在我们就可以得出状态转移方程。
### 状态转移方程
$$$
dp_{i,j,0} = min\{dp_{i,j,0},dp_{i-1,j,0}+1+\text{pd}(a[i],a[i-1]),dp[i-1][j][1]+1+\text{pd}(a[i],b[j])\}
$$$

$$$
dp_{i,j,1} = min\{dp_{i,j,1},dp_{i,j-1,0}+1+\text{pd}(b[i],b[i-1]),dp[i][j-1][1]+1+\text{pd}(b[j],a[i])\}
$$$
其中 $pd\{i,j\}$ 是 判断 $i$ 和 $j$ 是否相等的函数，代码中可以使用 bool 型来实现。

注意 $i$ 和 $j$ 不能同时为 $0$，有 $0$ 时要特判。
## 边界问题
注意 $dp_{0,0,0}$ 与 $dp_{0,0,1}$ 要设为 $0$ 
，剩余的可以设为非常大的数，例如 inf。

## 答案
是 $dp_{n,m,0}$ 与 $dp_{n,m,1}$ 中较小的一个。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[5005][5005][2];
int n,m,a[5005],b[5005];
const int inf = 1e9 + 7;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>b[i];
    }
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m && (i+j);j++){
            dp[i][j][0] = inf;
            dp[i][j][1] = inf;
            dp[i][j][0] = min(min(dp[i][j][0],dp[i-1][j][0]+1+(bool)(a[i]==a[i-1])),dp[i-1][j][1]+1+(bool)(a[i]==b[j]));      
            dp[i][j][1] = min(min(dp[i][j][1],dp[i][j-1][1]+1+(bool)(b[j]==b[j-1])),dp[i][j-1][0]+1+(bool)(a[i]==b[j]));
		}
	}
	cout<<min(dp[n][m][0],dp[n][m][1]);
	return 0;
} 
```

减少代码复制，共创美好洛谷。

---

## 作者：FXLIR (赞：0)

### 思路
贪心会假，因此考虑 dp。

设状态为 $f_{i,j,0/1}$，其中 $f_{i,j,0}$ 表示第一个数组填到第 $i$ 个数、第二个数组填到第 $j$ 个数，且当前的最大数字是偶数的情况，$f_{i,j,1}$ 表示第一个数组填到第 $i$ 个数、第二个数组填到第 $j$ 个数，且当前的最大数字是奇数的情况。

然后考虑转移。在不考虑第三维的情况下，$f_{i,j}$ 可以从 $f_{i-1,j}$ 和 $f_{i,j-1}$ 转移而来。因为当前最大数字的奇偶性由 $a_i$ 和 $b_j$ 决定，因此在每次转移中只需要分别考虑 $f_{i,j,a_i}$ 和 $f_{i,j,b_j}$。

对于状态 $f_{i,j,a_i}$，由于当前最大数字的奇偶性由 $a_i$ 决定，因此这个状态一定由 $f_{i-1,j,0}$ 或 $f_{i-1,j,1}$ 转移而来。分别计算转移的代价，与自身取最小值即可。$f_{i,j,b_j}$ 同理。

关于代价的计算方法：若当前状态的奇偶性与上一个状态不同，则代价为上一个状态的代价加 $2$，否则为上一个状态的代价加 $1$。

但是有些状态可能不会被计算，但是可能在之后的转移中被访问到，这会导致最终的答案出现错误，因此，需要将 $f$ 数组初始化为一个极大值，以避免错误。

边界是只填一个数组的情况，即所有的 $f_{i,0,a_i}$ 和 $f_{0,j,b_j}$。
### 代码
```
#include<cstring>
#include<iostream>
#define int long long
using namespace std;
const int N=5e3+5,INF=1e9;
int n,m,f[N][N][2],a[N],b[N];
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	memset(f,0x3f,sizeof f);
	for(int i=1,tot=1;i<=n;i++,tot++){
		cin>>a[i];
		tot+=(a[i]!=tot%2),f[i][0][a[i]]=tot;
	}
	cin>>m;
	for(int i=1,tot=1;i<=m;i++,tot++){
		cin>>b[i];
		tot+=(b[i]!=tot%2),f[0][i][b[i]]=tot;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j][a[i]]=min(f[i][j][a[i]],min(f[i-1][j][0]+(a[i]==0),f[i-1][j][1]+(a[i]==1))+1);
			f[i][j][b[j]]=min(f[i][j][b[j]],min(f[i][j-1][0]+(b[j]==0),f[i][j-1][1]+(b[j]==1))+1);
		}
	}
	cout<<min(f[n][m][a[n]],f[n][m][b[m]]);
	return 0;
}
```

---

## 作者：lw393 (赞：0)

~~鲜有我能写的 dp。~~

直接一步到位吧。

我们定义 $f_{i,j}$ 为第一个序列的前 $i$ 个数与第二个序列的前 $j$ 个数排完后的最小的最大值，初始时应有 $f$ 中元素全为无穷大。

为方便，我们令第一个序列为 $\{a_n\}$，第二个序列为 $\{b_n\}$。

看如何获得 $f_{i,j}$（在下面的转移式子中：$[p]$ 表示命题 $p$ 成立时 $[p]=1$ 否则 $[p]=0$），下面的转移均有 $i\ge 1,j\ge 1$：

1. 可以从 $f_{i-1,j}$ 转移，这种情况应讨论 $a_i$ 与 $f_{i-1,j}$ 的关系，此时应有：$f_{i,j}=\min(f_{i,j}, f_{i-1,j}+1+[a_i \equiv f_{i-1,j}(\bmod 2)])$；（解释：中括号内表示能不能只取出下一个数就能满足条件，若可以则为 $0$，不可以则为 $1$）
2. 同理，可以从 $f_{i,j-1}$ 转移而来，此时应有：$f_{i,j}=\min(f_{i,j},f_{i,j-1}+1+[b_j \equiv f_{i,j-1}(\bmod 2)])$；
3. 然后其实也可以从 $f_{i-1,j-1}$ 转移而来，转移方程的意义与上述式子含义差不多。主要在于讨论 $a_i$ 与 $b_j$ 是否一样，若一样，需要额外加 $2$，有 $f_{i,j}=\min(f_{i,j},f_{i-1,j-1}+2+2\times[a_i=b_j])$。

最终不要忘了 $f_{i,0}$ 与 $f_{0,i}$ 的枚举预处理。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e3 + 5;

int a[N], b[N];
int dp[N][N];

void solve(){
  int n; cin >> n; 
  for(int i = 1; i <= n; i++) cin >> a[i];
  int m; cin >> m;
  for(int i = 1; i <= m; i++) cin >> b[i];
  memset(dp, 0x3f, sizeof(dp));
  dp[0][0] = 0;
  for(int i = 1; i <= n; i++) dp[i][0] = dp[i - 1][0] + (a[i] % 2 == dp[i - 1][0] % 2) + 1;
  for(int i = 1; i <= m; i++) dp[0][i] = dp[0][i - 1] + (b[i] % 2 == dp[0][i - 1] % 2) + 1;
  for(int i = 1; i <= n; i++){
    for(int j = 1; j <= m; j++){
      dp[i][j] = min(dp[i - 1][j] + (dp[i - 1][j] % 2 == a[i] % 2) + 1, dp[i][j - 1] + (dp[i][j - 1] % 2 == b[j] % 2) + 1);
      dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + (a[i] % 2 == b[j] % 2) * 2 + 2);
    }
  }
  cout << dp[n][m] << '\n';
}

int main(){
  int t = 1;
  //cin >> t;
  while(t--){
    solve();
  }
  return 0;
}
```

---


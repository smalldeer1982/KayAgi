# [蓝桥杯 2023 省 A] 更小的数

## 题目描述

![image](https://cdn.luogu.com.cn/upload/image_hosting/y1rd2iun.png)

小蓝有一个长度均为 $n$ 且仅由数字字符 $0 \sim 9$ 组成的字符串，下标从 $0$ 到 $n-1$，你可以将其视作是一个具有 $n$ 位的十进制数字 $num$，小蓝可以从 $num$ 中选出一段连续的子串并将子串进行反转，最多反转一次。小蓝想要将选出的子串进行反转后再放入原位置处得到的新的数字 $num_{new}$ 满足条件 $num_{new}<num$，请你帮他计算下一共有多少种不同的子串选择方案，只要两个子串在 $num$ 中的位置不完全相同我们就视作是不同的方案。

注意，我们允许前导零的存在，即数字的最高位可以是 $0$，这是合法的。

## 说明/提示

#### 【样例说明】

一共有 $8$ 种不同的方案：

1. 所选择的子串下标为 $0\sim1$，反转后的 $num_{new} = 120102 < 210102$；
2. 所选择的子串下标为 $0\sim2$，反转后的 $num_{new} =  012102 < 210102$；
3. 所选择的子串下标为 $0\sim3$，反转后的 $num_{new} =  101202 < 210102$；
4. 所选择的子串下标为 $0\sim4$，反转后的 $num_{new} =  010122 < 210102$；
5. 所选择的子串下标为 $0\sim5$，反转后的 $num_{new} =  201012 < 210102$；
6. 所选择的子串下标为 $1\sim2$，反转后的 $num_{new} =  201102 < 210102$；
7. 所选择的子串下标为 $1\sim4$，反转后的 $num_{new} =  201012 < 210102$；
8. 所选择的子串下标为 $3\sim4$，反转后的 $num_{new} =  210012 < 210102$。

#### 【评测用例规模与约定】

对于 $20\%$ 的评测用例，$1 \le n \le 100$；

对于 $40\%$ 的评测用例，$1 \le n \le 1000$；

对于所有评测用例，$1 \le n \le 5000$。


## 样例 #1

### 输入

```
210102```

### 输出

```
8```

# 题解

## 作者：zhlzt (赞：31)

### 区间 DP 做法
其实要满足 $num_{new}<nu m$，就相当于判断翻转后的区间是否比原来小，假如翻转的区间为 $[i,j]$，则翻转前后的区间数值是这样的：
$$a_{i}~~a_{i+1}~~a_{i+2}~~\cdots ~~a_{j-2}~~a_{j-1}~~a_{j}$$
$$a_{j}~~a_{j-1}~~a_{j-2}~~\cdots ~~a_{i+2}~~a_{i+1}~~a_{i}$$
设双指针 $l=i,r=j$。设 $dp_{i,j}$ 表示翻转的区间为 $[i,j]$ 时是否满足条件。$dp_{i,j}$ 有如下判断方法（可参照上图理解）：
- 若 $l>r$，说明区间 $[i,j]$ 为回文串，翻转前后相等，$dp_{i,j}=0$，退出判断。
- 若 $a_l<a_r$，则当前判断的区间 $[l,r]$ 翻转后的最高位较大，$dp_{i,j}=0$，退出判断。
- 若 $a_l>a_r$，则当前判断的区间 $[l,r]$ 翻转后的最高位较小，$dp_{i,j}=1$，退出判断。
- 若 $a_l=a_r$，则 $a_l,a_r$ 对 $dp_{i,j}$ 的值没有影响，将双指针指向的区间 $[l,r]$ 缩小到 $[l+1,r-1]$，即执行 $l\gets l+1,r\gets r-1$。

如果像上述做法暴力判断的话，复杂度最差为 $O(n^3)$，但经过整合即可得到：
- 若 $a_i<a_j$，则 $dp_{i,j}=0$。
- 若 $a_i>a_j$，则 $dp_{i,j}=1$。
- 若 $a_i=a_j$，则 $dp_{i,j}=dp_{i+1,j-1}$。

这就是区间 DP，复杂度为 $O(n^2)$。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5010;
char s[maxn];
int dp[maxn][maxn];
int main(){
	scanf("%s",s);
	int n=strlen(s),ans=0;
	for(int i=0;i<n;i++) dp[i][i]=0;
	for(int i=0;i<n-1;i++) dp[i][i+1]=(s[i]>s[i+1]);
	// 初始值
	for(int len=3;len<=n;len++){
		for(int i=0;i<n-len+1;i++){
			int j=i+len-1;
			if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1];
			else if(s[i]>s[j]) dp[i][j]=1;
		}
	}
	for(int i=0;i<n;i++){
		for(int j=i;j<n;j++) ans+=dp[i][j];
	}
	//求总数
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Suite_No1_G (赞：11)

分析：

观察数据范围，$n ≤ 5000$，大概能知道标程的时间复杂度为 $O(n^2)$。

我们发现枚举两个端点的时间复杂度大概为 $O(n^2)$，于是需要思考如何 $O(1)$ 判断。

我们可以令 $dp_i,_j$ 表示反转 $i$ 到 $j$ 能否满足要求。满足要求为 $1$，不满足要求为 $0$。

当 $s_i<s_j$ 时，则反转肯定满足要求。

如果 $s_i=s_j$ 时，则首、末位相同。
此时如果 $dp_{i+1},_{j-1}$ 为 $1$ 时，反转满足要求。

所以这题是区间动态规划。答案为 $dp$ 数组中 $1$ 的个数。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=5010;
char s[maxn];
bool dp[maxn][maxn];

int main(){
	scanf("%s",s+1);
	int n=strlen(s+1);
	
	for (int i=1;i<=n;i++){
		if (s[i]>s[i+1]) dp[i][i+1]=1;
	}
	
	for (int len=3;len<=n;len++){
		for (int l=1;l+len-1<=n;l++){
			int r=l+len-1;
			
			if (s[l]>s[r]) dp[l][r]=1;
			else if (s[l]==s[r]){
				if (dp[l+1][r-1]==1) dp[l][r]=1;
			}
		}
	}
	
	int ans=0;
	for (int i=1;i<=n;i++){
		for (int j=i+1;j<=n;j++) ans+=dp[i][j];
	}
	
	printf("%d",ans);
	return 0;
}
```


---

## 作者：qwerty12346 (赞：11)

# [题目传送门](https://www.luogu.com.cn/problem/P9232)

## 题意

就是求共有几种不同的子串选择方案。

## 思路

直接动态规划。

## 状态定义

$dp_{i,j}$ 表示从 $i$ 到 $j$ 反转后是否满足要求，满足要求赋值为 $true$，否则赋值为 $false$。

## 状态转移方程

第一，如果 $s_{i}>s_{j}$ 那么 $dp_{i,j}=true$。第二，如果 $s_{i}=s_{j}$ 那么 $dp_{i,j}=dp_{i+1,j-1}$。否则 $dp_{i,j}=false$，但因为 $dp$ 数组是全局变量初始值为 $0$，所以可以不用写。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[5005][5005];//定义dp数组
int main(){
    int ret=0;//计数器
    string s;
    cin>>s;
    for(int i=s.size()-1;i>=0;i--)
    {
	for(int j=i;j<s.size();j++)
	{
	    if(s[i]>s[j])f[i][j]=true;//状态转移方程
            else if(s[i]==s[j])f[i][j]=f[i+1][j-1];//状态转移方程
	    if(f[i][j]==true)ret++;//如果等于1方案数加1
	}
    }
    cout<<ret;
    return 0;
}
```


---

## 作者：zhuhongye (赞：4)

## **题目意思**
### 如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/y1rd2iun.png)

有一个 $num$ 字符串，每次从 $num$ 中选取一段连续的字串进行翻转，得到 $num_{new}$ 字符串，如果 $num_{new}<num$，那么就视作一个方案，最终求有多少个方案。

## **解题思路**
这道题显然可以用暴力来做，但我们可以稍微优化一下，节约一下时间复杂度，因为它是选择一个连续的字串进行翻转，所以整个字符串 $num$ 只有这个字串会发生变化，只要这个字串翻转后比原字串要小，那么这就是一个可行的方案。

## **代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
string n;
long long ans;
int main()
{
	cin>>n;//输入
	for(int i=0;i<n.size();i++)
	{
		for(int j=i+1;j<n.size();j++)//二重循环确定字串的范围
		{
			for(int i1=i,j1=j;i1<j1;i1++,j1--)//循环从两边判断原子串大还是翻转后的字串大
			{
				if(n[i1]>n[j1])//表示原子串大于翻转后的子串
				{
					ans++;
					break;
				}
				else if(n[i1]<n[j1])break;//表示翻转后的子串大于原字串
			}
		}
	}cout<<ans;//输出
	return 0;
}
```


---

## 作者：封禁用户 (赞：2)

# 题目解析

一道 DP 题。

定义一个布尔型的数组 $num_{i,j}$ 表示 $i$ 到 $j$ 反转后是否满足题目给的要求，若满足，则设为 true，否则设为 false。

所以会出现三种情况:

- 如果 $pre_{i}>pre_{j}$，$num_{i,j}=true$

- 如果 $pre_{i}<pre_{j}$，$num_{i,j}=false$

- 如果 $pre_{i}>pre_{j}$，$num_{i,j}=num_{i+1,j-1}$

题目保证 $n \le 5000$，所以用 $O(n^2)$ 是可以过的。

所以代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string pre;
	bool num[5050][5050];
	int cnt;cin>>pre;
	for(int i=pre.size()-1;i>=0;i--)
		for(int j=i;j<pre.size();j++){
			if(pre[i]>pre[j]) num[i][j]=true;
			else num[i][j]=false;
			if(pre[i]==pre[j])
				num[i][j]=num[i+1][j-1];
			if(num[i][j]==true) cnt++;
		}
	cout<<cnt;
	return 0;
}
```


---

## 作者：sherry_lover (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9232)

本题考点：双指针。

------------
其实这道题没有楼上/下大佬讲的要用动态规划，其实只要用个双指针就行了。

首先，我们得复习一下小学的知识。

整数的大小比较：位数不相同时，位数多的数大；位数相同时，从最高位看起，相同数位上的数大的数大。

这道题保证位数是相同的。

我们可以枚举翻转的左端点和右端点，然后判断翻转这个区间可不可以就好了。

如何判断？因为要比较的数为 $num$ 和 $num$ 翻转后的数，也就是题目中说的 $num_{new}$。所以我们可以用两个指针 $i,j$，若字符 $s_i > s_j$ 就代表翻转之后的 $num_{new} < num$，若字符 $s_i < s_j$ 就代表翻转之后的 $num_{new} > num$，否则字符 $s_i = s_j$，我们就让 $i+1,j-1$ 直到 $i > j$。

标程：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int lens,ans;
bool pd(int l,int r)
{
	for(int i = l,j = r;i <= j;i++,j--)
	{
		if(s[i] > s[j]) return true;
        else if(s[j] > s[i]) return false;
	}
	return false;
}
int main()
{
	cin >> s;
	lens = s.length();
	for(int i = 0;i < lens;i++)
	{
		for(int j = i+1;j < lens;j++)
		{
			if(pd(i,j)) ans++;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：zhuweiqi (赞：1)

注意到数据范围 $1\leq n\leq 5000$，很显然我们需要用 $O(n^2)$ 的做法，而光枚举反转的字符串的左端点和右端点（$l$ 和 $r$）就需要 $O(n^2)$ 的时间，我们需要考虑把判断当前方案可不可行的时间优化到 $O(1)$，优化时间复杂度的方法就是在之前已经判断过了的解上继续进行判断，从而得到现在的解。根据题意，我们可以发现，只要反转之后的字符串比原串小就满足要求，进行比较的方法就是依次比较 $a_l$ 和 $a_r$、$a_{l+1}$ 和 $a_{r-1}\cdots a_r$ 和 $a_l$ 的大小，如果我们以区间长度作为最外层的循环的话，那么其中除了 $a_l$ 和 $a_r$ 进行比较的部分之外，其它的我们已经在之前判断 $a_{l+1}$ 到 $a_{r-1}$ 这段子串是否满足要求的时候判断过了，所以我们只需要判断 $a_l$ 和 $a_r$，问题就迎刃而解了，如果 $a_l>a_r$，则反转之后的字符串必定小于原串；反之，如果 $a_l<a_r$，则反转之后的字符串必定大于原串；否则当 $a_l=a_r$ 时，我们就只需要判断 $a_{l+1}$ 到 $a_{r-1}$ 这段子串是否满足条件就可以了，再开个数组记录一下 $a_l$ 到 $a_r$ 这段子串是否满足条件就行啦！参考代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[5005];
bool f[5002][5002];
int main(){
	scanf("%s",a+1);
	int n=strlen(a+1),ans=0;
	for(int l=2;l<=n;l++){
		for(int i=1;;i++){
			int j=i+l-1;
			if(j>n) break;
			if(a[i]>a[j]) ans++,f[i][j]=true;
			else if(a[i]==a[j] && f[i+1][j-1]==true) ans++,f[i][j]=true;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：
非常标准的区间动态规划，bool 数组记录这个区间能否翻转，如果左端大于右端，则可以翻转；如果两端一样则区间缩小两位，转移状态到小区间。

我们设 $dp_{i,j}=1$ 表示反转后更小，$dp_{i,j}=0$ 表示反转后大于等于原来的值。

可以得出状态转移方程：
$$dp_{i,i+k}=dp_{i+1,i+k-1}$$
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5050;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
bool dp[N][2*N];
ll n,ans;
string s;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>s;
    n=s.length();
    s=' '+s;
    for(int k=1;k<=n;k++){
        for(int i=1;i+k<=n;i++){
            if(s[i]>s[i+k]) 
			  dp[i][i+k]=1;
            else if(s[i]<s[i+k]) 
			  dp[i][i+k]=0;
            else 
			  dp[i][i+k]=dp[i+1][i+k-1];
            ans+=dp[i][i+k];
        }
    }
    write(ans);
    return 0;
}
```


---

## 作者：Wy_x (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9232)

## 题意：

给定一个字符串，在其中选出一段连续的子串并将子串进行反转，**最多反转一次**，反转后再放入原位置处得到的新的数字，如果新的数字比原来的数字**小**则算做一种方案。

求一共有多少种不同的子串选择方案。

- **注意：允许有前导零的存在。**

## 解法：

数据范围：$1 \le n \le 5000$，时间复杂度 $O(n^2)$ 即可通过。

看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/y1rd2iun.png)

易知：如果在一个区间中，反转子串小于所选择的子串，那么这种方案可行。反之，则不行。

## 代码：

```cpp
#include<bits/stdc++.h>

using namespace std; 

signed main()
{
	string a;
	cin>>a;//给定数字用字符串记录 
	int l=a.size(),ans=0;
	//ans 记录答案 
	
	for(int i=0;i<l-1;i++)//枚举区间左端点 0~l-1 
	{
		for(int j=i+1;j<l;j++)
		//在左端点以右枚举区间右端点 i+1~l-1 
		{
			int ii=i,jj=j;
			
			while(ii<=j)
			{
				if(a[jj]<a[ii]) ans++;
				if(a[jj]!=a[ii]) break;
				//如果 a[jj]<a[ii]，此方案成立，计数器加一的同时结束此循环 
				//如果 a[jj]>a[ii]，反转数字大于给定数字，结束此循环
				//简化，当 a[jj]!=a[ii] 时，结束循环 
				ii++;jj--;
				//左指针右移，右指针左移 
			}
		}
	} 
	
	cout<<ans;
	return 0;
}
```



---


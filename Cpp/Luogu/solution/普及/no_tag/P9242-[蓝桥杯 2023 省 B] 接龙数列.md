# [蓝桥杯 2023 省 B] 接龙数列

## 题目描述

对于一个长度为 $K$ 的整数数列：$A_{1},A_{2},\ldots,A_{K}$，我们称之为接龙数列当且仅当 $A_{i}$ 的首位数字恰好等于 $A_{i-1}$ 的末位数字（$2 \leq i \leq K$）。

例如 $12,23,35,56,61,11$ 是接龙数列；$12,23,34,56$ 不是接龙数列，因为 $56$ 的首位数字不等于 $34$ 的末位数字。所有长度为 $1$ 的整数数列都是接龙数列。

现在给定一个长度为 $N$ 的数列 $A_{1},A_{2},\ldots,A_{N}$，请你计算最少从中删除多少 个数，可以使剩下的序列是接龙序列？

## 说明/提示

**【样例说明】**

删除 $22$，剩余 $11,121,12,2023$ 是接龙数列。 

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$1 \leq N \leq 20$。

对于 $50 \%$ 的数据，$1 \leq N \leq 10^4$。

对于 $100 \%$ 的数据，$1 \leq N \leq 10^{5}$，$1 \leq A_{i} \leq 10^{9}$。所有 $A_{i}$ 保证不包含前导 0。

蓝桥杯 2023 省赛 B 组 E 题。

## 样例 #1

### 输入

```
5
11 121 22 12 2023```

### 输出

```
1```

# 题解

## 作者：Convergent_Series (赞：94)

计算去掉的数量不好思考，可以先算出最长的接龙数列长度，与  $n$ 相减即为答案。

考虑使用动态规划计算。

令 $dp_i$ 为以 $i$ 结尾的最长序列，枚举到 $a_i$ 时：

设 $a_i$ 开头数字为 $p$，结尾数字为 $q$。

+ 若选取 $a_i$，则 $dp_q=dp_p+1$;
+ 若不选取 $a_i$，则 $dp_q$ 不变。

所以可以得到状态转移方程为 $dp_q=\max(dp_p+1,dp_q)$。

最后答案即为 $n-\max dp_i\  (0\le i\le9)$。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[10],maxn;
string a;//为了方便取头尾，可以以字符串形式存储
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		int ln=a.length();
		dp[a[ln-1]-'0']=max(dp[a[ln-1]-'0'],dp[a[0]-'0']+1);
	}
	for(int i=0;i<=9;i++) maxn=max(maxn,dp[i]);
	cout<<n-maxn;
	return 0;
}
```

---

## 作者：qianyuzhe (赞：23)

[题目传送门](https://www.luogu.com.cn/problem/P9242)

## 题意简述

给定一个整数数列，求最少删除几个数才能使数列中除第一个数外每个的首位都与前一个数的首位相同。

## 题目分析

本题让我们求最少删除的数的个数，我们实际上可以将其转化为求该数列里的最长接龙子序列，再用 $n$ 减去该值即可。

观察数据范围，发现 $n\leq10^5$，所以算法的时间复杂度大约为 $O(n)$，于是我们就想到了dp。

设 $dp_{i,j}$ 表示到下标 $i$ 时以 $j$ 结尾的最长接龙子序列，设 $b_i$ 为 $a_i$ 的首位，$e_i$ 为 $a_i$ 的末位，则我们可以将其分为两种情况讨论：

- **当 $e_i\ne j$ 时，$a_i$ 对 $dp_{i,j}$ 没有任何贡献，故 $dp_{i,j}$ 和 $dp_{i-1,j}$ 保持一致。**

- **当 $e_i=j$ 时，$dp_{i,j}$ 可能与 $dp_{i-1,j}$ 一致，也可能变为 $dp_{i-1,b_i}+1$，故 $dp_{i,j}$ 为 $dp_{i-1,j}$ 和 $dp_{i-1,b_i}+1$ 中的较大值。**

综上所述，我们就得到了状态转移方程： 

**$dp_{i,j}=\begin{cases}dp_{i-1,j},&e_i\ne j\\
\max(dp_{i-1,j},dp_{i-1,b_i}+1),&e_i=j\end{cases}$** 

时间复杂度为 $O(n)$，可以通过。（一个优化：我们注意到 $dp_{i,j}$ 只和前一阶段的结果有关，因此可以用滚动数组优化dp，空间复杂度变为 $O(1)$。）

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,dp[10];
string a;//用字符串存储，便于运算 
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    for(i=n;i--;){
    	cin>>a;
    	dp[a[a.size()-1]-48]=max(dp[a[a.size()-1]-48],dp[a[0]-48]+1);//如果a有贡献 
	}
	for(i=0;i<=9;i++)m=max(m,dp[i]);//取最大值 
	cout<<n-m; 
}
```

---

## 作者：快斗游鹿 (赞：21)

## 思路

容易想到，本题可以使用 dp 解决。

我们可以发现，一个数字是什么并不重要，重要的是头尾两个数字。我们可以先将每个数字的头尾记录下来，记为 $l_i,r_i$。

接着设 $dp_{i,j}$ 表示到第 $i$ 个数以 $j$ 结尾的接龙数列的最大长度。

当 $l_i=r_{i-1}$ 时，意味着当前的数字可以和前一个数字接起来，此时 $dp_{i,r_i}=\max(dp_{i,r_i},dp_{i-1,l_i})$。

否则 $dp_{i,r_i}=\max(dp_{i,r_i},dp_{i-1,r_i})$，因为当前这个数无法做出更多贡献。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct Node{
	int l,r;
}e[N];
int n,dp[N][20];
int main(){
	//freopen("solitaire.in","r",stdin);
	//freopen("solitaire.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;cin>>s;
		e[i].l=s[0]-'0';
		e[i].r=s[s.length()-1]-'0';
		//cout<<e[i].l<<" "<<e[i].r<<endl;
	}
	for(int i=1;i<=n;i++){
		dp[i][e[i].r]=max(dp[i-1][e[i].r],dp[i-1][e[i].l]+1);
		for(int j=0;j<=10;j++){
			if(j!=e[i].r)dp[i][j]=dp[i-1][j];
		}
	}
	int ans=0;
	/*
	for(int i=1;i<=n;i++){
		for(int j=0;j<=10;j++)cout<<dp[i][j]<<" ";
		cout<<endl;
	}
	*/
	for(int i=0;i<=10;i++)ans=max(ans,dp[n][i]);
	cout<<n-ans;
}
//solitaire
```


---

## 作者：BigRooster (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P9242)

# 思路

将接龙数列看成上升子序列，上升规则即为头尾相接。最长上升子序列长度即为最长接龙数列长度。很明显，用总长度减去最长接龙数列长度即为所求答案（将不在最长接龙数列中的数删除）。

可以轻松写出以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n;
	int l[100001],r[100001];
	int dp[100001];
	cin>>n;
	string str;
	for(int i=1;i<=n;i++) dp[i]=1;
	for(int i=1;i<=n;i++)
		cin>>str,l[i]=str[0],r[i]=str[str.size()-1];
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(r[j]==l[i])
				dp[i]=max(dp[i],dp[j]+1);
	int ans=-2147483647;
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<n-ans;
}
```

这个代码是最长上升子序列的变式，因为其 $n^2$ 的复杂度，只能获得 $50$ 分。

因此，我们需要对动规进行优化。我们定义 $dp_i$ 为“以数字 $i$ 结尾的接龙数列的最大长度”，那么对于每个数，先取出首位，然后找到以该数首位结尾的接龙数列的最大长度，加一就是将该数加入，再将操作后的长度与以这个数的末位结尾的接龙数列的最大长度作比较，取最大的一个覆盖。

转换成状态转移方程：

$$dp_{r_i}=\operatorname{max}(dp_{l_i}+1,dp_{r_i})$$

其中 $l_i$ 为第 $i$ 个数最左边的数字，$r_i$ 为第 $i$ 个数最右边的数字。

这个算法可以理解为，当前数“借用”了前面的接龙数列，又把末尾改成了自己的末尾，并不是将当前数“加入”前面的数列，所以前面的数列长度不变。

因为数字顺序不能变，所以按照输入顺序枚举即可。

最后，只需判断以哪个数字结尾的数列长度最大即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string str;
int l[100001],r[100001];
int dp[11];
int ans=-2147483647;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>str,l[i]=str[0]-'0',r[i]=str[str.size()-1]-'0';//提取左右两端
	for(int i=1;i<=n;i++)
		dp[r[i]]=max(dp[r[i]],dp[l[i]]+1);//对于每个数，都试将其与前面的数列合并
	for(int i=0;i<=10;i++)
		ans=max(ans,dp[i]);
	cout<<n-ans;
}
```

---

## 作者：zhlzt (赞：8)

### 线性 DP 做法
设 $dp_i$ 为当前接龙数列的末尾数字为 $i$ 时接龙数列的最大长度。对于 $1\le i\le n$，我们用 $s_0,s_1,\ldots,s_{m-1}$ 来表示长度为 $m$ 的 $a_i$，那么不难得出以下状态转移方程：
$$dp_{s_{m-1}}=\max(dp_{s_{m-1}},dp_{s_0}+1)$$
最后的答案就是 $n-\max\limits_{i=0}^{9}dp_i$。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[15];int dp[15];
int main(){
	int n,cnt=0;scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);int m=strlen(s);
		dp[s[m-1]-48]=max(dp[s[m-1]-48],dp[s[0]-48]+1);
	}
	for(int i=0;i<10;i++) cnt=max(cnt,dp[i]);
	printf("%d",n-cnt);
	return 0;
}
```

---

## 作者：xler0915 (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P9242) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p9242)

### 题意

给定一个长度为 $n$ 的正整数序列，求最少删除多少个数，才能使剩下的数形成一个接龙数列？

### 思路：线性 dp

本题其实是求长度为 $n$ 的正整数列 $a_i$ 可以组成的最长接龙子序列，很容易想到用 dp 求解。

令 $dp_{i,j}$ 表示前 $i$ 个正整数，末尾为 $j$ 的最长接龙子序列，$f_i$ 表示第 $i$ 个正整数 $a_i$ 的首位，$b_i$ 表示末位。我们可以这样考虑状态转移方程：

- **当 $b_i \ne j$ 时，$a_i$ 一定不能作为这个接龙数列的最后一个数，所以 $dp_{i,j} = dp_{i-1,j}$**。

- **当 $b_i = j$ 时，$a_i$ 可能是这个接龙数列的最后一个数，也可能不是，所以 $dp_{i,j} = \max\{dp_{i-1,j}, dp_{i-1,f_i} + 1\}$。**

故得到状态转移方程为：

$$dp_{i,j} = \begin{cases}dp_{i-1,j}&b_i \ne j\\\max\{dp_{i-1,j},dp_{i-1,f_i}+1\}&b_i = j\end{cases}$$

考虑空间优化，因为 $dp_{i,j}$ 只与 $dp$ 的上一个阶段有关，故压缩第一维，此时的状态转移方程为：

$$dp_{b_i}=\max\{dp_{b_i}, dp_{f_i}+1\}$$

最终答案即为 $n - \max\limits^9_{i=0} dp_i$。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, f, b, ans;
int dp[15];
string a; // 用字符串存储更简单

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a;
		f = a.front() - '0';
		b = a.back() - '0';
		dp[b] = max(dp[b], dp[f] + 1); // 状态转移方程
	}
	for(int i = 0; i <= 9; i++)
		ans = max(ans, dp[i]);
	cout << n - ans << endl;
	return 0;
}
```

**时间复杂度：$\Theta(n)$。**

**空间复杂度：$\Theta(1)$。**

---

## 作者：xuyiyang (赞：4)

### 题目简述

一个接龙序列的定义为 $A_1,A_2,A_3, ... ,A_n$。


其中对于每一个 $1 \le i \lt n$，都有 $A_i$ 的首位数字等于 $A_{i+1}$ 的末位数字， 让你求最少要删多少个数才能使剩下的数列形成接龙数列。


数据范围： $1 \le n \lt 10^5, 1 \le A_i \le 10^9$，不包含前导 0。

### 分析
首先可知答案是该序列长度减去最长接龙子数列
就是一个二维偏序的题目，采用通用办法的 DP 时间复杂度为 $O(n ^ 2)$ 当然可以用前缀和优化 DP 做到 $O(n)$ ( 用前缀和记录数字为 $i$ 时的 $f_j | ({1 \le j \lt i})$ 的最大值，$O(1)$ 转移 )，但并不是最优解。


考虑重新设计状态，
令 $f_i$ 为以数字 $i$ 结尾的最长接龙数列。


那么就有转移方程 $ f_i = \max \{ f_j + \small 1 \normalsize \}$ 。
最后的答案就是 $n - \max \limits _ {0 \le i \le 9} \{ f_i\}$ 。


时间复杂度 $O(n)$，可以通过本题。

### Code
```cpp
//普通 DP
#include <iostream>
#include <cstring>

using namespace std;

const int N = 10;

int n, f[N], res;
char str[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%s", str + 1);
        
        int len = strlen(str + 1);
        int a = str[1] - '0', b = str[len] - '0'; 
        //首位数字为 a, 末位数字为 b
        
        // DP 转移 and 记录答案
        f[b] = max(f[b], f[a] + 1), res = max(res, f[b]);
    }
    
    printf("%d\n", n - res); //最后别忘记用 n 减才是答案
    
    return 0;
}
```
另外附上前缀和优化 DP 的代码(其实代码是一样的，只是最开始的思想不同，优化着就一样了)

```cpp
//前缀和优化 DP
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010;

int n, a[N], b[N];
int pos[N]; //记录之前数字为 i 的 f_j 最大值
char str[15];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%s", str + 1);
        
        int len = strlen(str + 1);
        a[i] = str[1], b[i] = str[len];
    }
    
    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int val = pos[a[i]] + 1;
        res = max(res, val);
        pos[b[i]] = max(pos[b[i]], val);
    }
    
    printf("%d\n", n - res);
    return 0;
}
```

---

## 作者：Neilchenyinuo (赞：2)

- 本题是一道线性 dp 题。

## 题目大意
给定一个整数数列，求最少删除几个数才能使数列中除第一个数外每个的首位都与前一个数的首位相同。
## Solution

1. 设 $dp_{i}$ 表示为当前接龙数列的末尾数字为 $i$ 时接龙数列的最大长度。

2. 最重要的是头和尾是否能相接，故我们应该先考虑头和尾的转移。

3. 先计算出整个字符串的长度 $m$，再表示出尾的最长长度为：$dp_{s_{m-1}}$，而头的表示就为：$dp_{s_{0}}$。

4. 因为每个数只能从头和尾转移，所以将头和尾取最大值就转移过去了。

5. 求出 $dp_{i}$ 的最大值后，我们如果要求删除个数，只需用总共长度将去最长接龙数列长度即 $dp_{i}$ 的最大值即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int dp[15];
int main()
{
	int n,maxi=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		int m=s.size();
		dp[s[m-1]-48]=max(dp[s[m-1]-48],dp[s[0]-48]+1);
	} 
	for(int i=0;i<10;i++)
		maxi=max(maxi,dp[i]);
	cout<<n-maxi;
	return 0;
}

```


---

## 作者：封禁用户 (赞：0)

# 题目解法

本题是用线性 dp 做的。

其实一个数字不重要，重要的是头和尾两个数字，我们可以用 $dp_{i}$ 为当前接龙数列的末尾为 $i$ 时最大长度，当 $1 \le i \le n$ 时，我们用 $s$ 来表示 $len$ 为 $m$ 的 $dp_{i}$，我们用 $cnt$ 来代替 $\max$ 的 $dp_{i}$，最后输出 $n-cnt$ 即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;int dp[15];
int main(){
	int n,cnt=0;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;int len=s.size();
		dp[s[len-1]-48]=max(dp[s[len-1]-48],dp[s[0]-48]+1);
	}
	for(int i=0;i<10;i++) cnt=max(cnt,dp[i]);
	cout<<n-cnt;
	return 0;
}
```


---


# 红草莓

## 题目描述

有一个由 $n$ 颗珍珠串成的项链，项链是一个环，首尾相连。其中有一颗珍珠上有特殊的记号，我们称它为**起始珍珠**。

有个外星人很会发射宇宙射线，他依次发射了 $m$ 轮宇宙射线，第 $i$ 轮有一个参数 $a_i$，表示：

- 外星人从起始珍珠开始数，起始珍珠是 $0$ 号，起始珍珠的下一个珍珠是 $1$ 号，以此类推（数完一圈后还会继续，例如 $n$ 号珍珠仍然是起始珍珠，$n+1$ 号珍珠是起始珍珠的下一个珍珠）。外星人会对编号为 $0,a_i,2a_i,\dots$ 这些 $a_i$ 倍数位置上的珍珠都发射一次宇宙射线。

一开始所有珍珠都是红色的，而当一个珍珠被发射宇宙射线后就会被从红色染成蓝色。

你需要输出：对于每轮操作，有多少个操作前为红色的珍珠被这轮操作变成了蓝色。

## 说明/提示

**【样例解释】**

如图是初始时以及每次操作后各珍珠的颜色，起始珍珠编号为 $0$，可以看到，每次操作新染蓝的珍珠数量分别为 $1,1,2,0,2,0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/mt4dg5ap.png)

---

**【数据范围】**

对于全部数据：$1\leq n,m\leq 5\times 10^5$，$1\leq a_i\leq n$。

|     子任务编号     |    $n\leq$     |    $m\leq$     |  特殊限制   | 分值 |
| :----------------: | :------------: | :------------: | :---------: | :--: |
| $\text{Subtask 1}$ |     $100$      |     $100$      |     无      | $15$ |
| $\text{Subtask 2}$ |     $1000$     |     $1000$     |     无      | $15$ |
| $\text{Subtask 3}$ |     $10^5$     |     $10^5$     | $a_i\mid n$ | $20$ |
| $\text{Subtask 4}$ |     $10^5$     |      $10$      |     无      | $20$ |
| $\text{Subtask 5}$ | $5\times 10^5$ | $5\times 10^5$ |     无      | $30$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/nzd79suj.png)

## 样例 #1

### 输入

```
6 6
6 3 4 2 5 1
```

### 输出

```
1 1 2 0 2 0
```

# 题解

## 作者：Light_az (赞：11)

数据好像水了？

本篇题解不是最优解法，仅供剪枝参考。

## 搜索+剪枝

对于每次输入的 $a_i$，我们考虑跳跃搜索求出有多少个珍珠没有被访问过，每次跳跃搜索进行一次标记。

如果搜索再次回到被标记的点时说明后面的点一定全部被标记过，在回溯时取消标记就可以大大减少使用 `memset` 的时间，时间复杂度大概为 $O(nm)$，最后暴力代码如下：

## Code


```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(int i=j;i<=n;i++)
#define B(i,j,n) for(int i=j;i>=n;i--)
#define Tr(v,e) for(int v:e)
#define D double
#define ps push_back
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e6+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T;
ll mn=INT_MAX,mx=0,Mod,id=1;
string s1,s2;
ll a[N],b[N];
void dfs(ll id){
	if(!a[id]) ans++;//这个点没被访问
	a[id]=1;
	if(b[id]) return ;//已经标记过
	b[id]=1;
	dfs((id+x)%n);//因为是环，因此添加取模操作
	b[id]=0;//回溯时取消标记
}
int main(){
	cin>>n>>m;
	F(i,1,m){
		ans=0;
		cin>>x;
		dfs(1);
		cout<<ans<<" ";
	}
	return 0;
}
```

然后拿到部分分后再次考虑剪枝。

如果访问珠子数量已经达到 $n$ 时，后面无论怎么搜索，珠子一定都被访问，因此直接后面输出 $0$ 即可，大大减少了搜索的时间复杂度。

虽然以上思想已经得到满分，但是我们想到本题可以使用倍数对搜索进行优化。

当 $a_i$ 搜索后它所有的倍数都不需要进行搜索，因为 $a_i$ 是倍数的因子，倍数可以访问的点 $a_i$ 全部可以访问。

所以加上特殊标记判断 $a_i$ 是否是前面某一个数的倍数，如果是则不需要搜索，否则对 $a_i$ 进行跳跃搜索再将其倍数打上特殊标记，最好情况下时间复杂度为 $O(n)$，代码如下：

```cpp
#include<bits/stdc++.h>
#define ll int
#define F(i,j,n) for(int i=j;i<=n;i++)
#define B(i,j,n) for(int i=j;i>=n;i--)
#define Tr(v,e) for(int v:e)
#define D double
#define ps push_back
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=5e5+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T;
ll mn=INT_MAX,mx=0,Mod,id=1;
string s1,s2;
ll a[N],b[N],Can[N];
ll read(){
    ll s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
inline void dfs(ll id,ll step){//同上
	if(!a[id]) ans++,cnt++;
	a[id]=1;
	if(b[id]) return ;
	b[id]=1;
	dfs((id+x)%n,step+1);
	b[id]=0;
}
inline void write(ll x){
    if(x<0) {putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
} 

inline void print(ll n){
	F(i,1,n) write(0),putchar(' ');
	return ;
}
int main(){
    n=read(),m=read();
	F(i,1,m){
		ans=0;
		x=read();
		if(!Can[x]){//没有被特判过
			dfs(1,0);
			F(i,1,n/x) Can[x*i]=1;//倍数特判
			write(ans);
			putchar(' ');
		}	
		else write(0),putchar(' ');//被特判过，一定没有珠子没有被访问过
		if(cnt==n){
			print(m-i);
			return 0;
		}
	}
	return 0;
}
```



---

## 作者：Chis725 (赞：9)

## 思路

本题只需要模拟再加一些剪枝就可以了。我们用 $s$ 来代表已经变蓝的珍珠的数量，当 $s$ 等于 $n$ 的时候，就说明后面的不再会有珍珠变成蓝色。我们假设要向 $t$ 号珍珠发射射线，当 $t$ 等于 $0$ 的时候，说明它会跟原来射过的珍珠重复，就退出循环。最后我们只需要标记一下已经变成蓝色的珍珠就可以了。

## 代码献上

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,a;
int p[500001],s=0;
signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=m;i++){
		int ans=0;
		scanf("%lld",&a);
		int cnt=a;
		if(s==n){//所有珠子都变成蓝色
			cout<<0<<" ";
			continue;
		}
		if(!p[0]){//起点被标记
			ans=1;
			p[0]=1;
			s=1;
		}
		while(cnt%n!=0){
			if(!p[cnt]){//没被标记，答案加一
				ans++;
				s++;
			}
			p[cnt]=1;
			cnt+=a;
			cnt%=n;
		}
		cout<<ans<<" ";
	}
	return 0;
} 
```


---

## 作者：Hughpig (赞：5)

考虑每次操作，发现会对所有编号为 $\gcd(n,a_i)$ 的倍数的珍珠染色（单次操作会染色直到 $\text{lcm}(n,a_i)$ 为止，此时就回到了起点，后面的不用考虑。而如果从 $0$ 开始一路加，越过了 $n$，就相当于直接加 $\gcd(n,a_i)$，所以可以把 $a_i$ 直接看做 $\gcd(n,a_i)$）。

直接进行操作最坏复杂度 $O(n^2)$。考虑如何快速进行操作，可以看下每次操作在此之前有无本质相同的操作，如果有，直接输出 $0$ 即可。否则暴力操作。

考虑这么做就的时间复杂度：对于 $n$ 的每个因数 $d$，要循环 $n\div d$ 次。这个是调和级数，均摊是 $\ln$ 级别的，所以时间复杂度 $O(n\ln n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,x;

bool vis[500007],vis_[500007];

int gcd(int x,int y){return y==0?x:gcd(y,x%y);}

int main()
{
	cin>>n>>m;
	while(m--)
	{
		cin>>x;
		int qwq=gcd(x,n);
		if(vis_[qwq]){
			cout<<0<<' ';
			continue;
		}
		vis_[qwq]=1;
		int cnt=0;
		for(int i=0;i<n;i+=qwq)
		{
			if(!vis[i])cnt++,vis[i]=1;
		 } 
		 cout<<cnt<<' '; 
	}
}
```

---

## 作者：Moon_Wind (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P9391)

------------


写在前面：题目数据比较水，赛时 $10$ 分钟过了，发一篇题解纪念一下。

**$50$ 分做法：**

可以用一个桶判断这一颗珍珠有没有变成蓝色。每一次枚举到 $a_i$ 与 $n$ 的最小公倍数即可，后面的枚举是重复的。

代码部分：



------------


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0); 
    ll n,m,b[10000000]={0},a[10000001];
    cin>>n>>m;
	for(ll i=0;i<m;i++) cin>>a[i];
	for(ll i=0;i<m;i++){
		ll ans=0,lcm;
                lcm=a[i]/__gcd(a[i],n)*n;//求最小公倍数。
		for(ll j=0;j<lcm;j+=a[i])
			if(b[j%n]==0) b[j%n]=2,ans++;
            //枚举，j每一次加a[i]。
        cout<<ans<<' ';
	}
    return 0;
}
```



------------

**$100$ 分做法（玄学做法）：**

做法与 $50$ 分做法差不多，只是判断了一下当第 $a_i$ 颗珍珠是不是蓝色，如果是，那么可以直接输出 $0$，因为第 $a_i$ 颗珍珠变成蓝色了的话，那么肯定有一个 $a_x$（$x<i$）是 $a_i$ 的因子（否则第 $a_i$ 颗珍珠不可能变成蓝色），那么 $a_i$ 肯定无法把任何一颗红色的珍珠变成蓝色（因为既然有了 $a_i$ 的因子，那么 $a_i$ 所有的倍数肯定都被 $a_x$ 所包含，就没有必要枚举了），所以可以直接跳过，输出 $0$ 即可。

代码部分：

------------

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main(){
    ll n,m,b[10000000]={0},a[10000001];
    cin>>n>>m;
	for(ll i=0;i<m;i++) cin>>a[i];
	for(ll i=0;i<m;i++){
		ll ans=0,lcm;
         lcm=a[i]/__gcd(a[i],n)*n;//求最小公倍数。
         if(b[a[i]]==0)//特判
	 for(ll j=0;j<lcm;j+=a[i])
	    if(b[j%n]==0) b[j%n]=2,ans++;
        cout<<ans<<' ';
	}
    return 0;
}
```


------------

本人只是一名蒟蒻，若有错误请多多包涵，谢谢大家。

---

## 作者：liupan2010 (赞：3)

赛时只打出 $50$ 分的蒟蒻来报道了！

[题目传送门](https://www.luogu.com.cn/problem/P9391)

$50$ 分做法：

暴力枚举，时间复杂度 $\Theta(nm)$。

$100$ 分做法：

可以发现，当第 $a$ 个珠子被标蓝，那么第 $a$ 的所有因数以及 $a$ 的所有倍数对 $n$ 取模个珠子都会被标蓝，我们不需要重复枚举。也就是说，当第 $a$ 个珠子为蓝色时，我们就可以跳过。

$70$ 分做法：

不开 $\texttt{long long}$ 见祖宗！

代码省略了快读部分，具体模板可见[这里](https://www.luogu.com.cn/paste/5szj8hn6)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,ask,ans,num,arr[500005],arrr[500005];
signed main(){
	n=read<int>(),m=read<int>();
	while(m--){
		ask=read<int>(),ans=0,num=ask/__gcd(ask,n)*n;
		if(arrr[ask]==0){
			for(int i=0;i<num;i+=ask){
			    (arrr[i%n]==0)?arrr[i%n]=1,ans++:1;
	    	}
		}
		write(ans),putchar(' ');
	}
	return 0;
} 
```

---

## 作者：CCDYJXZ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9391)。

分析：

很水的一道题，思路做法都比较多。（遗憾的是我考试时竟然一直超时，考完才想出来。）我的做法是，每次操作前先将 $a _ m$ 取模后记录初始坐标，再每次加 $a _ m$ 并将这个数标记（无论这个点有没有标记过，直接标记不会有影响）。直到加到了初始坐标停止。但这样肯定会超时，所以每次先判断初始坐标没有标记过才开始标记，否则跳过。

解释：

当到了 $a _ m$ 时，若果当前这个数被标记过，这说明它前面至少有一个等于它，或它为前面那个数倍数。那因为所有它能标记的数，已经都被前面那个数标记过了，所以这个数也就无用了。

------------
代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int a,s,d,f,g,h;
bool aa[500005];//标记数组。 
signed main(){
	cin>>a>>s;
	for(int i=1;i<=s;i++){
		cin>>d;
		g=0;
		h=d;
		d%=a;//必需模，否则可能超过n。 
		f=d;
		if(aa[d]==0)//关键代码，否则超时。 
			do{
				if(!aa[d])
					aa[d]=1,g++;
				d+=h;
				d%=a;
			}
			while(d!=f);
		printf("%d ",g);
	}
	return 0;
}
```
蒟蒻的一篇题解，如有不满敬请见谅。

---

## 作者：RNTBW (赞：1)

### PART 0
又趋势了。
## PART 1
给定一个数 $n$ 和一个序列 $a$，对于每个 $a_i$，将 $a_i\bmod n,2a_i\bmod n,....$ 中没打标记的打上~~花火~~标记。

问每次能打几个。
## PART 2
不妨把问题转换一下。

我们设当前 $a_i=x$。考虑对哪些数可以打上标记。

结论是 $\gcd(x,n)$ 的倍数都是可以被打上标记一次的，且只会打上一次。

我们尝试证明它。

首先我们证明一个公式：

$$
ap\bmod bp = (a\bmod b)p
$$

我们设 $ap=tbp+k$。

显然 $k$ 一定是 $p$ 的倍数，所以我们设 $k=sp$。

所以 $ap=tbp+sp$，即 $ap\bmod bp=sp$。

两边同时除以 $p$，得 $a=tb+s$。

所以 $a\bmod b=s$。

将上式代入 $ap\bmod bp=sp$ 中，得 $ap\bmod p=(a\bmod b)p$。得证。

接下来，我们设 $p=\gcd(x,n)$，再设 $x=ap,n=bp$。显然 $\gcd(a,b)=1$。

根据上面证明的公式可以得到：

$x\bmod n=(a\bmod b)p$。

$2x\bmod n=(2a\bmod b)p$。

....

$bx\bmod n=(ba\bmod b)p=0$。

由于 $bx\bmod n=0$，所以 $(b+1)x\bmod n=x\bmod n$，进入了一个循环，所以后面都是无意义的，我们只考虑 $x\le b$ 的情况。

那么我们就需要证明 $a,2a,3a....ba\bmod b$ 恰好不重不漏地分布在 $[0,b-1]$ 范围内。

不漏很好证明，没有数 $x$ 满足 $x\bmod b<0$ 或 $>b-1$。

证明不重可以考虑反证。

我们假设有两个数 $i,j$ 满足 $1\le i< j\le b,ia\bmod b=ja\bmod b$。

那么 $(j-i)a\bmod b=0$，即 $(j-i)a$ 为 $b$ 的倍数。

由于 $a,b$ 互质，所以 $(j-i)\bmod b=0$。

但是因为 $(j-i)<b$，所以 $j-i$ 不可能是 $b$ 的倍数，所以 $(j-i)a$ 不可能是 $b$ 的倍数，矛盾。

所以原命题不成立，这个集合不重。

所以当 $x\le b$ 时循环打标记，$\gcd(x,n)$ 在 $n$ 内的倍数都不漏地被打上了一次且仅有一次标记不会重复。

## PART 3

那么我们就可以求出 $\gcd(a_i,n)$ 之后直接暴力循环统计。

为防止重复操作，我们可以开一个数组 $vis$ 记录当前的 $\gcd$ 是否计算过。如果计算过，那么它的倍数已经全部被前面的打了标记，答案显然为 0。

最坏时间复杂度为 $\lfloor \dfrac{n}{1}\rfloor+\lfloor \dfrac{n}{2}\rfloor+....+\lfloor \dfrac{n}{n}\rfloor$。

将 $n$ 提出来，变成 $n(\lfloor \dfrac{1}{1}\rfloor+\lfloor \dfrac{1}{2}\rfloor+....+\lfloor \dfrac{1}{n}\rfloor)$，即为调和级数的第 $n$ 项。

而调和级数的第 $n$ 项为 $\log n$ 级别。这是一个经典的结论。

总时间复杂度 $m\log_2 n+n\log n$。
## PART 4
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,k,s,now;
bool vis[500001],f;
int main()
{
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		scanf("%d",&k);s=0;
		now=__gcd(k,n);
		if(vis[now]||f)
		{putchar('0');putchar(' ');continue;
		}
		for(j=now;j<=n;j+=now)
			if(!vis[j])vis[j]=1,s++;
		printf("%d ",s);
		if(now==1)f=1;
	}
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：0)

暴力加优化即可，输入完后将所有能改变颜色的暴力枚举一遍，同时统计没染色的数量即可。

但我们需要一些优化：

如果所有珍珠都被染色，那发射外星射线什么都染不上，所以只要都被染色，直接输出 $0$。

还有，循环时每次要 $+a$，这样才能保证没有无用的语句。

最后如果现在的 $a$ 在之前已经有过了，很显然也输出 $0$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,a,s;  //s代表没染色的珍珠数量
bool vis[500001];

signed main(){
	scanf("%d%d",&n,&m);
	s=n;
	for(int i=1;i<=m;i++){
		scanf("%d",&a);
		if(vis[a]){
		    printf("0 ");
		    continue;
		}
		if(s==0){
			printf("0 ");
			continue;
		}
		int ans=0;   //本次能染上色的数量
		for(int j=0;j!=n;j+=a){
			if(j>n) j-=n;  //j>n 说明 j 又到了新的一圈
			if(vis[j]==false){  //如果染到了没染色的珍珠
				vis[j]=true;
				ans++;
				s--;
			}
		}
		printf("%d ",ans);
	}
	return 0;
}
```

来补个证明：

根据裴蜀定理，若 $n\bmod a_i\neq 0$，那么在该轮绝对会将所有的珍珠都给染色。

那么我们只用考虑 $n\bmod a_i=0$ 的 $a_i$ 即可。

那么这样一次循环的复杂度为 $\frac n{a_i}$，那么复杂度为 $O(\sum_{i|n} \frac ni)=O(\sigma(n))$，最坏为 $O(n\ln n)$ 可以通过。

---

## 作者：ncwzdlsd (赞：0)

第 $i$ 次被染色的珍珠编号集合为 $\{x|x\in[0,n),x=ka_i\bmod n,k\in \mathbb{N}\}$。等价于存在 $g$，使得 $a_ik-ng=x$，根据裴蜀定理有 $\gcd(a_i,n)|x$。对于每一次处理，染色编号为 $\gcd(a_i,n)$ 倍数的珍珠即可。

暴力做这个时间复杂度为 $O(nm)$，考虑如何优化。对于一个出现过的 $\gcd(a_i,k)$ 的值，它能被染的色已经全部染完了，所以直接跳过即可。

时间复杂度上限为 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxm=5e5+5;
bool vis[maxm],col[maxm];

int main()
{
	int n,m;cin>>n>>m;
	while(m--)
	{
		int a;cin>>a;
		int cnt=0;
		if(vis[__gcd(a,n)]){cout<<"0 ";continue;}
		vis[__gcd(a,n)]=1;
		for(int i=0;i<n;i+=__gcd(a,n))
			if(!col[i]) col[i]=1,cnt++;
		cout<<cnt<<' ';
	}
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

## 思路

对于每个数 $c_i$，求出其与 $n$ 的最大公约数 $d$，然后把所有 $d$ 的倍数筛掉就可以了。

对于这个算法复杂度的分析：这个算法复杂度是 $O(m \log n + \sum \dfrac{n}{d}) = O(m \log n + n \sum \dfrac{1}{d})$，而 $\sum \dfrac{1}{d}$ 是严格小于 $H(n)$ 的。（这里的 $H(n)$ 指调和级数，也就是 $\sum \dfrac{1}{n}$。调和级数是 $\ln$ 级别的）。这个复杂度显然可以过。

## 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>

using namespace std;

const int N = 500010;
long long n, m;
bool col[N], st[N];

int gcd(int a, int b) {
	return !b ? a : gcd(b, a % b);
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i ++ ) {
		int s; scanf("%d", &s);
		if (st[gcd(n, s)]) { printf("%d ", 0); continue; }
		st[gcd(n, s)] = true;
		int cnt = 0, now = 0; s = gcd(n, s);
		for (int i = 0; i < n / s; i ++ ) {
			if (!col[i * s]) cnt ++ ;
			col[i * s] = true;
		}
		printf("%d ", cnt);
	}
}
```

---

## 作者：船酱魔王 (赞：0)

# P9391 红草莓 题解

## 题意回顾

一个环，上面的点标号为 $ 0 \sim n-1 $，$ m $ 次染色，每次染色会从 $ 0 $ 开始，每 $ x $ 个染一次。求每次染色新染色的点数。

## 分析

设 $ \gcd(n,x)=d $，由裴蜀定理发现所有编号 $ d $ 的倍数（包括 $ 0 $）都能被染色。所以我们求出 $ d $ 即可暴力染色。但是这样会超时，考虑一个小小的优化：记录每次的 $ d $，当 $ d $ 已经出现过的时候因为能染的都已经被染过了，所以输出 $ 0 $。故每个 $ d $ 第一次出现时时间复杂度为 $ O(\frac{n}{d}) $。

因为一个经典的结论 $ n+\frac{n}{2}+\frac{n}{3}+ \cdot \cdot \cdot + \frac{n}{n} =O(n \log n) $，又因为 $ d $ 不同，所以 $ O(n \log n) $ 是本做法程序时间复杂度的上界。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 5e5 + 5;
int n, m;
int vis[N];
int sgn[N];
int gcd(int x, int y) {
	if(y == 0) {
		return x;
	}
	return gcd(y, x % y);
}
int main() {
	scanf("%d%d", &n, &m);
	int x;
	int now;
	for(int i = 1; i <= m; i++) {
		scanf("%d", &x);
		x = gcd(n, x);
		if(sgn[x] == 1) {
			printf("0 ");
			continue;
		}
		sgn[x] = 1;
		now = 0;
		for(int j = 0; j <= n - 1; j += x) {
			if(vis[j] == 0) {
				vis[j] = 1;
				now++;
			}
		}
		printf("%d ", now);
	}
	printf("\n");
	return 0;
}
```

---

## 作者：Lemon_zqp (赞：0)

### 思路
策略：每次乘上 $i$ 直到重新回到起始珍珠为止，复杂度为 $\Theta \left( nt\right)$，外面一重循环复杂度为 $\Theta \left( t\right)$，里面的循环为 $\Theta \left( \sigma \left(n\right)\right)$，最满的情况是 $p$ 为 $n$ 的前 $t$ 小因子的逆序，所以复杂度是 $n$ 的前 $t$ 大因子和，故总复杂度为 $\Theta \left( t+\sigma \left(n\right)\right)$，可以通过。记得每次要模 $n$，不开 ``long long`` 见祖宗。
### 代码
```
#include<bits/stdc++.h>
using namespace std;

long long a[500005];

int main()
{
	long long n, t;
	cin >> n >> t;
	for(long long i = 1; i <= t; i++)
	{
		long long p, b = 1, cnt = 0;
		cin >> p;
		p %= n;
		while(1)
		{
			if(a[(p * b) % n] == 0)
			{
				cnt++;
				a[(p * b) % n]++; 
			}
			else if((p * b) % n == p)
			{
				break;
			}
			b++;
		}
		cout << cnt << " ";
	} 
	return 0;
}

```


---

## 作者：wuyin331 (赞：0)

# 题解
由题意得，因为是一个环，外星人会给 $0$，$a_{i} \bmod n$，$2a_{i} \bmod n$，$\cdots$ 位置上的珍珠从红色染成蓝色。一开始全部为红色。显然我们可以直接模拟一遍，但是会超时，考虑优化。

为了方便令 $b_{i}=a_{i} \bmod n$，$2b_{i}=2a_{i} \bmod n$，$\cdots$。

先说结论，如果 $b_{i}$ 位置为蓝色，那么这轮操作没有珍珠染为蓝色，下面为证明。

设一个在第 $i$ 次操作有一次操作 $j(j<i)$，那么有一种可能令 $b_{i}$ 为蓝色。

存在 $N$ 为非负整数，而且有 $Nb_{j}=b_{i}$，那么 $b_{i}$ 为蓝色。发现其实正好符合题目的性质，为一个整数倍。那么对于 $0$，$b_{j}$，$2b_{j}$，$\cdots$ 与 $0$，$b_{i}$，$2b_{i}$，$\cdots$ 在环上是包含的。比如 $n=6$ 时有 $a_{1}=2$，$a_{2}=4$，第 $1$ 次操作被染成蓝色有 $0$，$2$，$4$，第 $2$ 次操作被染成蓝色有 $0$，$4$，$2$。

那么如果 $b_{i}$ 位置为蓝色，我们直接特判。否则，就模拟一遍染色操作即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_set<int> s;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,m,num,flag=1;
	cin>>n>>m;
    while(m--){
        cin>>num;
        num%=n;
        int qwq=num,ans=0;
        if(s.find(qwq)!=s.end()){//这个点为蓝色
            cout<<0<<' ';
            continue;
        }
        else{
            s.insert(qwq);
				 ans++;
        }
        qwq+=num;qwq%=n;
		while(qwq!=num){//循环了，那么退出
		if(s.find(qwq)==s.end()){//这个点为红色，那么ans++
			s.insert(qwq);
			ans++;
		}
		qwq+=num;qwq%=n;
	    }
		cout<<ans<<' ';
    }
	return 0;
}
```


---

## 作者：Ferdina_zcjb (赞：0)

~~这道题是一道数学题。~~

暴力只有 $50$ 分，此处不提。

首先，通过样例可以发现规律：当 $\gcd(n,a_i) = 1$ 时，会将所有的点染色。自然，$\gcd(n,a_i) \ne 1$ 时，会从 $1$ 开始，到        $\operatorname{lcm}(n,a_i)+1$ 中符合题目要求的点都会被上色。

做法：一旦遇到 $\gcd(n,a_i)=1$，就进行记录，一旦有记录，以后就避免操作直接输出 $0$。如果不为 $1$，就从 $1$ 开始遍历，直到 $\operatorname{lcm}(n,a_i)+1$，如果点不够，则以周期性从头开始，在用 $vis_{1,a_i+1,2a_i+1...}$ 记录该位置是否上色，没上色则进行记录。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int vis[10000000],tmp = 0;//tmp记录当前以上色数量。
bool nll = false;
int lcm(int a,int b){return a*b/__gcd(a,b);}
signed main(){
    int n,m,x;
    cin >> n >> m;
    for(int i = 1;i <= m;++i){
        if(nll){//有记录的话避免下面操作，直接输出0。
            cout << 0 << " ";
            continue;
        }
        cin >> x;
        if(__gcd(n,x) == 1){//gcd(n,a[i]) = 1时的情况。
            cout << n-tmp << " ";
            tmp = n;
            nll = true;
        }else{
            int num = lcm(n,x),ji = 0,pos;
            for(int j = 1;j <= num;j += x){
                if(j > n){
                    pos = j%n;
                }else{
                    pos = j;
                }//周期性处理。
                if(!vis[pos]){//判断是否上色。
                    ji++;
                    vis[pos] = 1;
                }
            }
            cout << ji << " ";
            tmp += ji;
        }
    }
}
```


---


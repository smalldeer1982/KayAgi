# [yLOI2022] 西施江南

## 题目背景

> 我晤江南面 如逢西施颜  
> 清芬宜送岸 菡萏新雨前  
> 皓腕分珠帘 珠露扬波珠玉敛  
> 天然一段聚散 嫣然曾与言  
> 平芜辙尚浅 无韵化湖田  
> 林园虽工典 芳姿不可嵌  
> 何人冠诗篇 重街杳杳重门掩  
> 似有柔荑遮目 空谷足尖

银临《西施江南》

## 题目描述

给定 $n$ 个正整数 $a_1, a_2, a_3, \dots a_n$，记 $g$ 是这些数的**最大公约数**，$l$ 是这些数的**最小公倍数**。请你判断 $l \times g$ 是否等于 $a_1 \times a_2 \times \dots \times a_n$。

## 说明/提示

### 数据规模与约定

以下用 $N$ 表示单个测试点内 $n$ 的和，即 $N = \sum n$。

- 对 $12\%$ 的数据，保证 $n = 2$。
- 对 $36\%$ 的数据，保证 $n \leq 5$。
- 对 $52\%$ 的数据，保证 $N \leq 1000$。
- 对 $76\%$ 的数据，保证 $N,a_i \leq 10^5$。
- 对 $100\%$ 的数据，保证 $2 \leq n,N \leq 5 \times 10^5$，$2 \leq a_i \leq 10^8$，$1 \leq T \leq 20$。

### 提示

**数据千万条，清空第一条**。  
**多测不清空，爆零两行泪**。  
**清空不规范，超时总相伴**。

## 样例 #1

### 输入

```
3
2
2 3
3
2 3 4
3
3 8 35```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
见附加文件中的 C2.in```

### 输出

```
见附加文件中的 C2.ans```

# 题解

## 作者：cff_0102 (赞：19)

题面中设 $n$ 个数的最大公因数为 $g$，最小公倍数为 $l$。为了方便，这篇题解沿用题面中的变量。

众所周知，$g$ 一定能整除 $a_i$。设 $\Pi a_i=a_1\times a_2\times\dots\times a_n$，将 $a_1,a_2,a_3,\dots,a_{n-1}$ 全部除以 $g$，这 $n$ 个数的 $l$ 仍然不会变。所以 $l$ 不可能大于 $\frac{\Pi a_i}{g^{n-1}}$。又因为题面要让 $l\times g=\Pi a_i$，所以必须要保证 $g\ge g^{n-1}$，也就是 $g^2\ge g^n$。又因为 $n\ge2,g\ge1$，所以[容易解得](https://www.desmos.com/calculator/0twjhc4zdy?lang=zh-CN)在 $g=1$ 或 $n=2$ 的时候，$g\times l$ 才有可能为 $\Pi a_i$。不过，此时还需要保证 $l=\frac{\Pi a_i}{g^{n-1}}$，才能保证 $l\times g=\Pi a_i$。

1. $n=2$ 时，$l=\operatorname{lcm}(a_1,a_2)=\frac{a_1\times a_2}{\gcd(a_1,a_2)}=\frac{\Pi a_i}{g}$，所以 $l\times g$ 必然等于 $\Pi a_i$。所以，当 $n=2$ 时直接输出 `Yes` 即可，不需要更多的运算。
2. $g=1$ 时，要让 $l\times g=\Pi a_i$，必须要 $l=\Pi a_i$。若 $n$ 个数的最小公倍数等于它们的积，则这 $n$ 个数两两互质。所以，当 $g=1$ 时，必须要判断这 $n$ 个数是否两两互质。如果是，则输出 `Yes`，否则输出 `No`。

那么，怎么判断 $n$ 个数是否两两互质呢？

首先，开一个 `bool` 数组，记录 $a$ 中的某一个数是否含有这个质因数。接着，将 $a$ 中的每一个数进行分解质因数。分解出一个新的质因数 $p$，这个 `bool` 数组的第 $p$ 项就设为 $1$。如果发现这一项已经为 $1$，就说明 $a$ 数组前面有一项含有质因数 $p$，而这两项就不是互质的。此时就退出循环，输出 `No`。

如果分解完 $a$ 的每一项都没有发现有两个数不是互质的，则这 $n$ 个数两两互质，输出 `Yes`。

可以提前筛一遍 $10^8$ 以内的质数，把分解质因数的复杂度从 $\sqrt n$ 降到 $\ln n$。

最后注意，输出是 `Yes` 和 `No`，不是 `YES` 和 `NO`。比赛时差点在这里踩坑（这算坑吗？）。

赛时 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
//当 n=2 时输出 YES
//当 gcd=1 时判断是否两两互质，如果是输出 YES
int p[6000000];//存质数
bool x[100000001];//存是否不是质数
void s(){//筛质数 
	p[1]=2;
	x[1]=0;//1 不是质数 
	int cnt=1;//筛出的质数个数
	for(int i=2;i<100000000;i++){
		if(!x[i]){//是质数 
			p[++cnt]=i;
		}
		for(int j=1;j<=cnt&&(long long)(i)*p[j]<=100000000;j++){
			x[i*p[j]]=1;//x[i*p[j]] 不是质数 
			if(i%p[j]==0){
				break;
			}
		}
	}
}
int main(){
	s();
	ios::sync_with_stdio(false);
	int t;cin>>t;
	while(t--){
		int n;cin>>n;
		int a[n];
		cin>>a[0];
		int gcd=a[0];
		for(int i=1;i<n;i++){
			cin>>a[i];
			gcd=__gcd(gcd,a[i]);
		}//求这 n 个数的 gcd
		if(n==2)cout<<"Yes"<<endl;//e 和 s 是小写 
		else if(gcd==1){
			//判断 n 个数是否两两互质
			bool b[100000000];//记录每个质因数是否出现过 
			for(int i=0;i<100000000;i++)b[i]=0;
			bool f=1;//目前是否两两互质 
			for(int i=0;i<n;i++){
				//分解 a[i] 的质因数
				for(int j=1;p[j]*p[j]<=a[i];j++){
					if(a[i]%p[j]==0){
						if(b[p[j]]==1){//这个质数之前出现过了 
							f=0;//并非两两互质
							break; 
						}
						while(a[i]%p[j]==0){
							a[i]/=p[j];
						}
						b[p[j]]=1;//p[j] 这个质数出现过了 
					}
				}
				if(a[i]!=1){
					if(b[a[i]]==1){
						f=0;
					}else{
						b[a[i]]=1;
					}
				}
				//判断到目前为止是否全部互质 
				if(f==0){
					cout<<"No"<<endl;//o 是小写 
					break;
				}
				//接下来判断下一个数 
			}
			if(f){//n 个数两两互质 
				cout<<"Yes"<<endl;//e 和 s 是小写
			} 
		}else{
			cout<<"No"<<endl;//o 是小写 
		}
	}
	return 0;
}
```

---

## 作者：信息向阳花木 (赞：16)

站在蒟蒻的角度写题解，保证 xxs 也能懂。




------------

进入正题。

~~观察样例~~可以发现只要 $a_1$ 到 $a_n$ 所有数两两互质，就可以满足条件，证明如下：

如果 $a_1$ 到 $a_n$ 两两互质，则它们的最大公约数 $g = 1$，最小公倍数 $l = \prod_{i=1}^{n}a_i$，$l \times g$ 自然满足条件。

设 $a_1$ 到 $a_n$ 中（$n > 2$），$a_i$ 和 $a_j$（$1 \le i,j \le n$）存在公因子 $p$（$p > 1$），其余数的乘积为 $t$，最大公约数为 $dg$，最小公倍数为 $dl$。那么它们的最大公约数 $g = dg$，最小公倍数 $l = \frac{dl \times a_i \times a_j}{p}$，$l \times g = \frac{dg \times dl \times a_i \times a_j}{p}$，又因为 $dg \times dl \le t$ 且 $p > 1$，所以 $l \times g < \prod_{i=1}^{n}a_i$。

得证。



------------
那么我们应该如何判断 $a_1$ 到 $a_n$ 所有数两两互质呢？（$n>2$）

$O(n^2)$ 的暴力肯定超时，这里的做法是用一个桶 $b$，来装某个质因子 $p$ 在 $a$ 序列中可以整除的数的个数。例如 $b_p$ 表示 $a_1$ 到 $a_n$ 中有 $b_p$ 个数可以被 $p$ 整除。显然，对于任意 $p$，当 $b_p > 1$ 时，说明至少有两个数能被同一个质因子整除，它们不互质。

如果只是正常的分解质因数，只有 $96$ 分，我们可以稍稍优化一下：预处理时筛出 $10^4$ 以内的质数，分解质因数时只枚举质数，这样就可以完美地卡进时限啦~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>

using namespace std;

const int N = 6000010, M = 100000010;

inline void in(int &x)
{
	x = 0; bool f = 0; char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = 1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 3) + (x << 1) + (c & 15);
		c = getchar();
	}
	x = f ? -x : x;
} //快读优化 

inline void out(int x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x / 10) out(x / 10);
	putchar((x % 10) | 48);
}


int n, t, cnt;
int p[10010];
bool f[10010];
map<int, int> b; //桶用 map 实现 

inline void prime()
{
	for (int i = 2; i < 10010; i ++ )
	{
		if(!f[i])
		{
			p[++ cnt] = i; 
			for (int j = i * 2; j < 10010; j += i) f[j] = 1;
		}
	}
	return;
} //筛质数 

signed main()
{
	prime();
	in(t);
	while (t -- )
	{
		b.clear(); //多测记得清空 
		
		in(n); 
		
		bool flag = 1;
		for (int i = 1; i <= n; i ++ )
		{
			int x;
			in(x);
			
			if(!flag || n == 2) continue; 
			
			for (int j = 1; j <= cnt && p[j] <= x / p[j]; j ++ ) //只考虑质数 
			{
				if(x % p[j] == 0)
				{
					b[p[j]] ++;
					if(b[p[j]] > 1) { flag = 0; break; }
					while(x % p[j] == 0) x /= p[j];
				}//分解质因数 
			}
			if(x > 1 && flag)
			{
				b[x] ++;
				if(b[x] > 1) flag = 0;
			}
		}
		
		if(flag || n == 2) puts("Yes"); //注意 n = 2 时要特判，例如 n = 2, a[1] = 4, a[2] = 6 
		else puts("No");
	}
	
	return 0;
}
```

---

## 作者：一扶苏一 (赞：8)

## Analysis

考虑唯一分解定理，对 $n$  个数 $a_1, a_2, a_3, \dots a_n$，设 $a_i = \prod p_j^{c_{i,j}}$。则其 $\gcd = \prod p_j ^{\min\limits_i c_{i,j}}$，$\mathrm{lcm} = \prod p_j^{\max\limits_i c_{i,j}}$。$\gcd \times \mathrm{lcm} = \prod p_j^{\min\limits_i c_{i,j} + \max\limits_i c_{i,j}}$。又 $\prod a_i = \prod p_j^{\sum_{i= 1}^n c_{i,j}}$。于是回答为是的充要条件是 $\sum_{i = 1}^n c_{i,j} = \min c_{i,j} + \max c_{i,j}$。易见 $\max c_{i,j}$ 一定是左边的一项，所以需要 $\min c_{i,j}$ 等于左边剩下的项。

讨论一下：

1. $n = 2$ 时，左右两边各有两项，此时 $\min c_{i,j}$ 必然等于剩下的一项。这就是我们熟知的结论：当 $n = 2$ 时，$a \times b = \gcd(a, b) \times\mathrm{lcm}(a, b)$。

2. 当 $n > 2$ 时，假设 $\min c_{i,j} = k$。不妨假设 $\min c_{ i,j} = c_{1,j} \leq c_{2, j} \leq c_{3, j} \leq \dots \leq c_{n,j} = \max c_{i,j}$。想要让这些项目的和等于 $\min c_{i,j} + \max c_{i,j}$，则 $c_{2,j} = c_{3, j} = c_{4, j} = \dots = c_{n - 1,j} = 0$。又 $c_{2,j} \geq \min c_{i,j}$，于是 $\min c_{i,j} = 0$。  
因此，此时每个质数只能作为一个数字的因子。换句话说，数字是两两互质的。

综上，当 $n = 2$ 时，总是回答是，否则如果给定的数字两两互质，回答是，否则回答否。

## 子任务 1

$n = 2$ 时，输出 $T$ 个 $\texttt{Yes}$ 即可。

## 子任务 2

$n \leq 5$ 时，可以暴力计算这些数字的积，检查他们的 gcd 和 lcm 的关系。

## 子任务 3

$n \leq 1000$ 时，可以暴力枚举每一对数，求他们的 gcd，看它们是不是两两互质。时间复杂度 $O(n^2 \log a)$。

## 子任务 4

回到『每个质数只能作为一个数的因子』这个表述上，可以据此检查所有数是否两两互质。方法是：对每个数 $O(\sqrt a_i)$ 地分解质因子。用一个数组记录每个质因子是否在之前的数中出现过。如果某个质因子之前出现过，直接返回否即可。时间复杂度 $O(n \sqrt a_i)$。

## 子任务 5

可以在线性筛的同时筛出每个数的最小质因子，具体的方法见 [B3716](https://www.luogu.com.cn/problem/B3716)。

这样就可以 $O(\log a_i)$ 筛出每个数的质因子，然后按子任务 $4$ 的做法判断即可。时间复杂度 $O(T n \log a_i)$。

## Code

```cpp
#include <vector>
#include <iostream>

const int maxn = 100000005;

int T;

std::vector<int> prm, pre;  // pre is the min-factor array.
bool np[maxn];
bool oc[maxn];

void getPrime(const int N = 100000000) {
  pre.resize(N + 1);
  for (int i = 2; i <= N; ++i) {
    if (!np[i]) {
      prm.push_back(i); pre[i] = i;
    }
    for (auto p : prm) if (i * p <= N) {
      int k = i * p;
      np[k] = true;
      pre[k] = p;
      if (i % p == 0) break;
    } else break;
  }
}

int main() {
  getPrime();
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (std::cin >> T; T; --T) {
    int n;
    for (auto i : prm) oc[i] = false;
    std::cin >> n;
    std::vector<int> a(n);
    for (auto &i : a) std::cin >> i;
    if (n == 2) {
      std::cout << "Yes\n";
    } else {
      bool ans = true;
      for (auto i : a) {
        std::vector<int> tmp;
        while (i != 1) {
          tmp.push_back(pre[i]);
          i /= pre[i];
        }
        for (auto j : tmp) if (oc[j]) {
          ans = false;
        }
        for (auto j : tmp) {
          oc[j] = true;
        }
      }
      std::cout << (ans ? "Yes" : "No") << std::endl;
    }
  }
}
```

---

## 作者：RUO_22703 (赞：8)

# P9473 [yLOI2022] 西施江南

## 思路

经过一定时间的思考与尝试，我们发现：

当且仅当满足以下任一条件时，输出 `Yes`，否则输出 `No`：

1. $n=2$。

2. 所有数两两互质。

----

### 证明如下：

令：所有数的公共质因数之积 $= \text{pub}$，所有数的独有质因数之积 $= \text{uni}$，所有数的最大公因数 $=\gcd$，所有数的最小公倍数 $=\text{lcm}$，所有数之积 $=\text{pdt}$。

- 当 $n=2$ 时：

$\gcd= \text{pub}$。

$\text{lcm}= \text{uni}\times\text{pub}$。

两者相乘，恰好等于两数所有的质因数之积（公共质因数两数都有，因此恰好乘两次乘完），即 $\text{lcm}\times \gcd=\text{pdt}$。

例如：

两数：$180$ 和 $240$。

$180=2^2\times3^2\times5$

$240=2^4\times3\times5$

$\text{lcm}=\text{uni(180)}\times \text{uni}(240)\times \text{pub}=(3^{2-1})\times(2^{4-2})\times(2^2\times3\times5)=3\times4\times4\times3\times5=720$

$\gcd=\text{pub}=2^2\times3\times5=60$。

$\text{lcm}\times \gcd=720\times60=43200=180\times240$。

- 当 $n>2$ 时：

$\gcd=\text{pub}$。

$\text{lcm}{}=\text{uni}\times\text{pub}$。

也就是 $\text{lcm}\times \gcd=\text{uni}\times\text{pub}^2$。

设所有的质因数为 $p_{i,j}$，数量为 $k_i$，那么：

$a_1=p_{1,1}\times{p_{1,2}\times\dots\times p_{1,k_1}}$

$a_2=p_{2,1}\times{p_{2,2}\times\dots\times p_{2,k_2}}$

$\cdots$

$a_n=p_{n,1}\times{p_{n,2}\times\dots\times p_{n,k_n}}$

接下来我们分类讨论：

- 如果所有数互质：

$\text{uni}=\prod_{i=1}^{n}\prod_{j=1}^{k_i}{(p_{i,j})}=\prod_{i=1}^{n}{(a_i)}$（所有的质因数之积）。

$\text{pub}^2=1$。

两者相乘，就等于所有数之积，即 $\prod_{i=1}^{n}{(a_i)}$。

也就是此时 $\text{lcm}\times \gcd=\text{pdt}$。

- 如果有若干数不互质，但仍有至少两个数互质：

$\text{uni}=\prod_{i=1}^{n}\prod_{j=1}^{k_i}($所有不同的 ${p_{i,j}})$。

$\text{pub}^2=1$。

两者相乘，就比**所有数之积**少乘了那几个**不互质数共有的质因数**。

因此此时 $\text{lcm}\times \gcd\neq \text{pdt}$。

- 所有数都不互质：

$\text{uni}=\prod_{i=1}^{n}\prod_{j=1}^{k_i}($所有不同的 ${p_{i,j}})$。

$\text{pub}^2=(\prod_{i=1}^{n}\prod_{j=1}^{k_i}($所有**相同**的 ${p_{i,j}}))^2$。

我们发现，求 $\text{lcm}\times \gcd$，公共的那部分只乘了两次。而 $n>2$，要求所有数的积，每个数的公共部分都必须乘一次，两次显然乘少了，因此此时 $\text{lcm}\times \gcd\neq \text{pdt}$。

其实从这里来看也证明了为什么只有两个数时不互质，$\text{lcm}\times \gcd$ 仍等于 $\text{pdt}$，因为公共部分恰好乘了 $n=2$ 次，没少乘也没多乘，$\text{lcm}\times \gcd$ 也就恰好等于 $\text{pdt}$ 了。

证毕 Q.E.D。

----

第一个条件很简单，加个特判就行了。

而本题**关键中的关键**，就在于这第二个条件：

如何判断所有数两两互质？有许多方法，我选择的是对每个数进行**质因数分解**，判断有没有两个不同的数拥有相同的质因子：

- 先预处理 $2\sim10000$ 的所有质数，不多，只有 $1229$ 个：

```cpp
for(int i=2;i<=10000;i++){
    if(!is_prime[i]){
        prime[++cnt]=i;tag[i]=cnt; 
        for(int j=2;j*i<=10000;j++) is_prime[j*i]=1;
    }
}
```

- 然后对每个数进行质因数分解：

```cpp
for(int i=1;i<=n;i++){
    int x=a[i];
    for(int j=1;j<=1229;j++){
        if(x%prime[j]==0){//用每个质数都去试试能不能除剩下的a[i]（即x）
            if(is_m[j]){
            	b=1;break;//这个b为true就代表应该输出"No"
			}//如果某两个数有相同的质因数，就不行 
	        while(x%prime[j]==0){
	            is_m[j]=1;
	            x/=prime[j];
	        }
		}
    }//每个数都除以一遍所有的质数（即分解质因数） 
    if(x>1) q[++cnt]=x;//最后可能剩下一个超大质数，存起来 
}
```

- 最终除下来，要么除到只剩 $1$，要么剩下一个超大质数（大于 $10000$），于是将这个大质数存进一个数组 $q$ 里，对 $q$ 进行排序，挨个判断是否有相等：

```cpp
sort(q+1,q+1+cnt);
for(int i=1;i<cnt;i++){
    if(q[i]==q[i+1]){
        b=1;break;
    }
}//排序后看超大质数中有无相等 
```
- 最后还有个问题：两数相等其实也不互质，而我们现在的程序里只判断了所有**不同的数**是否互质，怎么办呢？很简单，再加一个特判就行了：

```cpp
sort(a+1,a+1+n);
for(int i=1;i<n;i++){
    if(a[i]==a[i+1]){
        b=1;break;
    }
}//排序后看有没有相等 
```

最后加上开头提及的 $n=2$ 的特判，代码就完整了。

时间复杂度：$O(nk)$，$k=1229$（$2\sim10000$ 的质数数量）。

## AC代码
```cpp
#include<bits/stdc++.h>
//P9473 [yLOI2022] 西施江南
//主要思路就是有任意两数互质就不行 
using namespace std;
int t,n,a[500005],prime[1235],cnt,q[500005];
bool is_prime[10005],is_m[1235];
int main(){
    cin>>t;
    for(int i=2;i<=10000;i++){
        if(!is_prime[i]){
            prime[++cnt]=i;; 
            for(int j=2;j*i<=10000;j++) is_prime[j*i]=1;
        }
    }//预处理10000以内的质数 
    while(t--){
        memset(is_m,0,sizeof(is_m));cnt=0;//处理每组前归零 
        cin>>n;
        bool b=0;//b为true就代表应该输出"No" 
        for(int i=1;i<=n;i++) cin>>a[i];//读入 
        if(n==2){
            cout<<"Yes"<<endl;
            continue;
        }//特判，如果只有两个数一定输出"Yes" 
        for(int i=1;i<=n;i++){
            int x=a[i];
            for(int j=1;j<=1229;j++){
            	if(x%prime[j]==0){
            		if(is_m[j]){
            			b=1;break;
					}//如果某两个数有相同的质因数，就不行 
	           		while(x%prime[j]==0){
	                    is_m[j]=1;
	                    x/=prime[j];
	                }
				}
            }//每个数都除以一遍所有的质数（即分解质因数） 
            if(x>1) q[++cnt]=x;//最后可能剩下一个超大质数，存起来 
        	if(b) break;
		}
        if(b){
            cout<<"No"<<endl;continue;
        }
        sort(q+1,q+1+cnt);
        for(int i=1;i<cnt;i++){
            if(q[i]==q[i+1]){
                b=1;break;
            }
        }//排序后看超大质数中有无相等 
        if(b){
            cout<<"No"<<endl;continue;
        }
        sort(a+1,a+1+n);
        for(int i=1;i<n;i++){
            if(a[i]==a[i+1]){
                b=1;break;
            }
        }//排序后看有没有相等 
        if(b){
            cout<<"No"<<endl;continue;
        }//有相等就不行 
        cout<<"Yes"<<endl;
    }
    return 0;
} 
```
**The End**

---

## 作者：船酱魔王 (赞：6)

# P9473 [yLOI2022] 西施江南 题解

## 题意回顾

判断一个长度为 $ n $ 的数组的积是否等于整个数组的最小公倍数乘最大公约数，多测，$ T $ 组数据。

$ \sum n \le 5 \times 10^5 $，$ a_i \le 10^8 $，$ T \le 20 $。

## 分析

因为是乘积且等式元素都和乘除有点关系，因此考虑对于每一个质因数分别讨论。

下记 $ g=\operatorname{GCD}_{i=1}^{n}a_i $，$ l=\operatorname{LCM}_{i=1}^{n}a_i $。

对于质因数 $ p $，设其在 $ a_i $ 中出现 $ b_i $ 次，则 $ g $ 中 $ p $ 的出现次数为 $ b_i $ 的最小值，$ l $ 中 $ p $ 的出现次数为所有 $ b_i $ 的最大值，则我们得出，对于每个质因数 $ p $，合法的数组必须满足 $ b_i $ 的最小值加 $ b_i $ 的最大值等于 $ b_i $ 之和。

所以，$ n=2 $ 时显然一定合法，因为 $ b_i $ 只含有两个值，自然可以成为它的最小和最大值。

$ n>2 $ 时，我们可以把加和式抵消掉两边的最大值和最小值，只剩下中间的部分，因为 $ n>2 $ 一定存在中间的部分，等于 $ 0 $，因此最小值也只能等于 $ 0 $，所以只有最大值可以非 $ 0 $。

所以，当 $ n>2 $ 时，每个质因数都只能最多在一个数中出现任意次。

$ a_i \le 10^8 $，为我们分解质因数提供了方便，根号分解方法显然，但是还是跑不过去，考虑一个强大的优化：预处理 $ 10^4 $ 以内所有质数，分解时只考虑质数即可。这样按照定义显然是可以的，可以使分解质因数部分的运行时间缩短为原来的十分之一左右。

小质数部分使用数组直接标记，最后可能剩下的大质数使用 ```set``` 来记录。

## 实现细节

* 即使发现已经不可能为合法数组了，也得读入完。

* 别忘了特判 $ n=2 $。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <set>
using namespace std;
const int C = 1305;
int T;
int n;
int cp = 0;
int p[C];
bool vis[C];
set<int> se;
int main() {
	scanf("%d", &T);
	int tmp;
	for(int i = 2; i <= 10000; i++) {
		tmp = 1;
		for(int j = 2; j * j <= i; j++) {
			if(i % j == 0) {
				tmp = 0;
				break;
			}
		}
		if(tmp == 1) {
			cp++;
			p[cp] = i;
		}
	}
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d", &n);
		for(int i = 1; i <= cp; i++) {
			vis[i] = false;
		}
		se.clear();
		bool ok = true;
		for(int i = 1; i <= n; i++) {
			scanf("%d", &tmp);
			if(!ok) {
				continue;
			}
			for(int j = 1; j <= cp; j++) {
				if(tmp % p[j] == 0) {
					if(vis[j]) {
						ok = false;
					}
					vis[j] = true;
					while(tmp % p[j] == 0) {
						tmp /= p[j];
					}
				}
			}
			if(tmp != 1) {
				if(se.find(tmp) == se.end()) {
					se.insert(tmp);
				} else {
					ok = false;
				}
			}
		}
		if(ok || n == 2) {
			printf("Yes\n");
		} else {
			printf("No\n");
		}
	}
	return 0;
}
```

## 总结与评价

本题考察了对于最小公倍数和最大公约数数论性质的初步理解，是一道很巧妙的普及 T3，场上切了，体感难度上位黄。

表白良心出题人扶苏！

---

## 作者：寄风 (赞：6)

## 题解
首先 $n=2$ 的情况必然成立，先特判掉。

然后记 $cnt_{id,x}$ 表示在 $a_x$ 的质因数分解形势下，第 $id$ 个质数的次数。

于是可以得到：

$$g=\prod p_i ^ {\min_{j=1} ^ n \{cnt_{i,j}\}}$$

$$l=\prod p_i ^ {\max_{j=1} ^ n \{cnt_{i,j}\}}$$

若 $g \times l = \prod_{i=1} ^ n a_i$，则对于所有的质数 $p_i$，满足:

$$\min_{j=1} ^ n \{cnt_{i,j}\} + \max_{j=1} ^ n \{cnt_{i,j}\}=\sum_{j=1} ^ n cnt_{i,j}$$

也就是这些数需要两两互质。

维护一个桶 $x$，$x_i$ 表示 $i$ 这个质数在多少个数的质因数分解中出现了。

然后只有当 $x$ 里面的数全都小于 $2$ 时，输出 $\texttt{Yes}$。

具体来说，在线性筛的同时求出每一个数的最小质因子，在分解时不断往下除即可。

由于 $10 ^ 9 \le 2^{27}$，所以只用最多 $27$ 次除法即可将一个数质因数分解。

分解后遍历 $x$ 判断即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	int s = 0 , xi = 1;
	char op = getchar();
	while(op < '0' || op > '9'){
		if(op == '-') xi = -1;
		op = getchar();
	}
	while(op >= '0' && op <= '9'){
		s = (s << 1) + (s << 3) + op - '0';
		op = getchar();
	}
	return s * xi;
}
inline void print(int x){
	if(x < 0) putchar('-') , x *= -1;
	if(x < 10){
		putchar(x + '0');
		return;
	}
	print(x / 10);
	putchar(x % 10 + '0');
}
vector <int> prime;
int ok[100000005] , a[10000005];
inline void xxs(int n){
	ok[1] = 1;
	for(int i = 2;i <= n;i++){
		if(!ok[i]) prime.push_back(i) , ok[i] = i;
		for(int j = 0;j < prime.size() && i * prime[j] <= n;j++){
			ok[i * prime[j]] = prime[j];
			if(i % prime[j] == 0) break;
		}
	}
}
map <int , int> x;
map <int , bool> y;
signed main(){
	int t;
	cin >> t;
	xxs(100000000);
	while(t--){
		x.clear();
		y.clear();
		int n = read();
		for(int i = 1;i <= n;i++){
			a[i] = read();
		}
		if(n == 2){
			puts("Yes");
			continue;
		}
		bool flag = 1;
		for(int i = 1;i <= n;i++){
			int tmp = a[i];
			y.clear();
			while(ok[tmp] > 1){
				if(!y[ok[tmp]]) x[ok[tmp]]++ , y[ok[tmp]] = 1;
				if(x[ok[tmp]] > 1){
					puts("No");
					flag = 0;
					break;
				}
				tmp /= ok[tmp];
			}
			if(!flag) break;
		}
		if(flag) puts("Yes");
	}
	return 0;
}
```


---

## 作者：WilliamFranklin (赞：5)

这道题我赛时 T 了，当时不知道一种很快的找质因数方式，还是太菜了。。。

### 主要思路

先说一下结论：

1. 当 $n = 2$ 时，一定成立

2. 当 $n \neq 2$ 时，如果这 $n$ 个数两两互质，则成立，否则不成立。

下面证明一下：

对于第一个结论，我们很好证明，因为：

$$a \times b = \operatorname{lcm}(a, b) \times \gcd(a, b)$$

对于第二个结论，我再次举 $n = 5$ 时的例子，其他的情况以此类推：这里我们设 $g_i\left(2 \le i \le n\right)$ 为 $a_i$ 与前 $i - 1$ 个数的最大公约数，根据题意求一个序列最大公约数与最小公倍数的公式，得出：

$$\frac{\frac{\frac{\frac{a_1 \times a_2}{g_2} \times a_3}{g_3} \times a_4}{g_4} \times a_5}{g_5} \times g_5 = a_1 \times a_2 \times a_3 \times a_4 \times a_5$$

也就是说，我们看一看这个式子满足什么情况才会成立。

化简得（化简过程不再详细讲）：

$$g_2 \times g_3 \times g_4 = 1$$

由此，只要这 $n$ 个数两两互质，式子永远成立。

下面是代码。

### AC Code

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <string>
#include <sstream>
#include <algorithm>
#include <map>

using namespace std;

const int N = 6e6 + 1, M = 1e8;

int prime[N];
int prime_cnt;
bool not_prime[M + 1];
int a[500005];
int minprime[M + 1];

int read() {
    int s = 0, f = 1;
    char ch = getchar();
    while(!isdigit(ch)) {
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(isdigit(ch)) {
        s = s * 10 + ch - '0';
        ch = getchar();
    }
    return s * f;
}

int main() {
	for(int i = 2; i <= M; i++){
		if (!not_prime[i]) {
			prime[++prime_cnt] = i;
			minprime[i] = i;
		}
		for (int j = 1; j <= prime_cnt && i * prime[j] <= M; j++){
			minprime[i * prime[j]] = prime[j];
			not_prime[i * prime[j]] = true;
			if(i % prime[j] == 0){
				break;
			}
		}
	}
	
	int t;
	
	t = read();
	
	while (t--) {
		map<int, bool> vis;
		
		int n;
		
		n = read();
		
		for (int i = 1; i <= n; i++) {
			a[i] = read();
		}
		
		if (n == 2) {
			cout << "Yes" << endl;
			
			continue;
		}
		
		bool f = 0;
		
		for (int i = 1; i <= n; i++) {
			map<int, bool> viss;
			
			while (minprime[a[i]]) {
				if (!viss[minprime[a[i]]]) {
					if (vis[minprime[a[i]]]) {
						f = 1;
						break;
					}
					vis[minprime[a[i]]] = 1;
					viss[minprime[a[i]]] = 1;
				} 
				
				a[i] /= minprime[a[i]];
			}
			
			if (f) {
				break;
			}
		}
		
		if (f) {
			cout << "No" << endl;
		} else {
			cout << "Yes" << endl;
		}
	}
	
	return 0;
} 
```


---

## 作者：int08 (赞：5)

# 前言
这篇题解会详细讲解为什么能将原问题转化为两两互质，证明过程不使用复杂的数学符号，请放心食用。

建议升绿，此外这是 [我的 Hack](https://www.luogu.com.cn/discuss/640796)。

# Solution
重要的是知道题目在讲什么。

### 题目描述

给定 $n$ 个正整数 $a_1, a_2, a_3, \dots a_n$，记 $g$ 是这些数的**最大公约数**，$l$ 是这些数的**最小公倍数**。请你判断 $l \times g$ 是否等于 $a_1 \times a_2 \times \dots \times a_n$。

### 解析
首先发现当 $n=2$ 时一定成立，那 $n>2$ 呢？

回忆小学奥数对多个数的最大公约数和最小公倍数的求法：

先把每个数都分解质因数，然后：

最大公约数：取都出现的质因子的最低次方。

最小公倍数：取只要出现的质因子的最高次方。

换句话说，假设 $a_1, a_2, a_3, \dots a_n$ 中对**某个质因子**分别有 $b_1, b_2, b_3, \dots b_n$ 个，那么乘积中这个质因子有所有 $b$ 的和个， $g\times l$ 中有 $b$ 数列的最大值加最小值个。

显然最大值和最小值只是 $b$ 数列中~~普通~~的两个数，先记为 $b_1$、$b_2$，
然而 $b$ 数列还有其他项 $b_3, \dots b_n$。只有当他们都为 $0$ 时，$b_1+b_2+b_3+ \dots +b_n$ 正好等于 $b_1+b_2$。

然而我们注意到，$b_2$ 是数列 $b$ 的**最小值**，其他已经有值为 $0$ 了，$b_2$ 也只好为 $0$。

换句话说，只有 $b_1$ 一个数不为 $0$，相当于某个数会**独占**一个质因子。（这句话很重要，仔细理解）

所以，不会有任何两个数共享一个质因子，原题目中的问题才能成立。

因为任何两个数不共享一个质因子，所以任何两个数之间互质。**但这不是重点。**

其实两两互质的结论不重要，“不会有任何两个数共享一个质因子”才重要。

做法自然出来了，统计两个数是否有重叠的质因子。

### 如何统计

我的做法是：先预处理 $10000$ 以下的质数，用它们一个一个分解 $a_i$，分解出来的就在这个位置占个位，如果占位时发现这个位置有人，说明有两个数共享了一个质因子，立即得出答案。

问题来了，只用 $10000$ 以下的质数分解，可能剩下一些超过 $10000$ 的质因子（这也正是我开头提到的需要 Hack 的地方，目前你不考虑这一点也可通过本题）。

但是由于 $a≤10^8$，就算剩下了，每个数最多剩一个，直接将它们排序然后判断有没有重复即可，如果数据量再大点可能还需要用哈希（确信）。

于是我们做完了（平静），并没有直接用到两两互质这一条件。

### 推荐练习
做本题前：1.[B3715 分解质因子 2](https://www.luogu.com.cn/problem/B3715)。

2.[P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)。

做本题后：1.[CF1771C Hossam and Trainees（双倍经验）](https://www.luogu.com.cn/problem/CF1771C)。

2.[P2568 GCD](https://www.luogu.com.cn/problem/P2568)（开个玩笑）。

# AC 代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
int n,t,i,j,k,a[524288],p,r[13007],s[12345];bool q[114514],b;
int main()
{
	cin>>t;
	for(i=2;i<=12001;i++)
	{
		q[i]=true;
	}
	for(i=2;i<=12001;i++)
	{
		if(q[i]==true)
		{
			p++;r[p]=i;
			for(j=2*i;j<=12001;j+=i) q[j]=false;
		}
	}
	for(k=1;k<=t;k++)
	{
		cin>>n;
		for(i=1;i<=n;i++)
			scanf("%d",&a[i]);
		if(n==2)
		{
			printf("Yes\n");
			continue;
		}
		sort(a+1,a+n+1);
		b=false;
		for(i=1;i<=n-1;i++)
		{
			if(a[i]==a[i+1])
			{
				printf("No\n");
				b=true;
				break;
			}
		}
		if(b==true) continue;
		for(i=1;i<=12001;i++) s[i]=0;
		for(i=1;i<=n;i++)
		{
			for(j=1;r[j]<=sqrt(a[i]);j++)
			{
				while(a[i]%r[j]==0)
				{
					a[i]/=r[j];
					if(s[r[j]]!=0&&s[r[j]]!=i)
					{
						printf("No\n");b=true;
						break;
					}
					else s[r[j]]=i;
				}
				if(b==true) break;
			}
			if(b==true) break;
			if(1<a[i]&&a[i]<=10000)
			{
				if(s[a[i]]!=0&&s[a[i]]!=i)
				{
					printf("No\n",i);b=true;
					break;
				}
				else s[a[i]]=i;
				a[i]=1;
			}
		}
		if(b==true) continue;
		sort(a+1,a+n+1);
		for(i=1;i<=n-1;i++)
		{
			if(a[i]==a[i+1]&&a[i]!=1)
			{
				printf("No\n");
				b=true;
				break;
			}
		}
		if(b==false) printf("Yes\n");
	}
	return 0;
}
```
The End.

---

## 作者：___w (赞：3)

### [P9473 [yLOI2022] 西施江南](https://www.luogu.com.cn/problem/P9473)

#### 题意简述
给 $n$ 个整数，判断它们的最大公约数与最小公倍数的乘积是否等于所有数的乘积。

#### 题目分析
先考虑当 $n=2$ 的情况。

根据算术基本定理，两个数 $x,y$ 能唯一分解为：
$$x=p_1^{b_1}p_2^{b_2}\dots p_m^{b_m}$$
$$y=p_1^{c_1}p_2^{c_2}\dots p_m^{c_m}$$

又有：
$$\gcd(x,y)=p_1^{\min(b_1,c_1)}p_2^{\min(b2,c2)}\dots p_m^{\min(b_m,c_m)}$$
$$\text{lcm}(x,y)=p_1^{\max(b_1,c_1)}p_2^{\max(b2,c2)}\dots p_m^{\max(b_m,c_m)}$$
因为 $\min(b_m,c_m),\max(b_m,c_m)$ 必有一个为 $b_m$，有一个为 $c_m$，所以得出 $\gcd(x,y)\times\text{lcm}(x,y)=xy$。

所以当 $n=2$ 时是一定成立的。

再考虑当 $n>2$ 的情况。

举质因子 $p_m$ 为例。$a_1,a_2\dots a_n$ 的质因子 $p_m$ 的指数分别为 $c_1,c_2\dots c_n$。问题则就变成判断 $\min(c_1,c_2\dots c_n)+\max(c_1,c_2\dots c_n)$ 是否等于 $c_1+c_2+\dots+c_n$。记 $c_k$ 为 $\max(c_1,c_2\dots c_n)$。易证，除 $c_k$ 外其他全为 $0$ 时满足等式。请读者自行证明。

其实也就是判断序列 $a$ 是否两两互质了。可以以 $\operatorname{O}(n^2)$ 暴力判断任意两个数之间是否互质。好像可以得 $80$ pts。

考虑对其每个数进行质因数分解，并标记每个质因子。如果有一个质因子先前被标记了，那么不是两两互质。复杂度为 $\operatorname{O}(n\sqrt a)$。

进一步优化。我们可以预处理 $10^4$ 内的质数（因为 $a_i\le10^8$），分解时直接枚举质数。复杂度为 $\operatorname{O}(\frac{n\sqrt a}{\ln a})$。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e5+5;
int T, n, tot, a[N], p[N], v[N];

void prime(int x) {
	for (int i = 2; i <= x; ++i) {
		if (!v[i]) p[++tot] = v[i] = i;
		for (int j = 1; j <= tot; ++j) {
			if (p[j] > v[i] || p[j]*i > x) break;
			v[p[j]*i] = p[j];
		}
	}
}

bool solve() {
	if (n == 2) return 1;
	map <int, bool> t;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= tot && p[j]*p[j] <= a[i]; ++j) 
			if (a[i]%p[j] == 0) {
				if (t[p[j]]) return 0;
				t[p[j]] = 1;
				while (a[i]%p[j] == 0) a[i] /= p[j];
			}
		if (a[i] > 1) {
			if (t[a[i]]) return 0;
			t[a[i]] = 1;
		}
	}
	return 1;
}

int main() {
	ios::sync_with_stdio(0);
	cin >> T;
	prime(1e4);
	while (T--) {
		cin >> n;
		for (int i = 1; i <= n; ++i) cin >> a[i];
		if (solve()) cout << "Yes\n";
		else cout << "No\n";
	}
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：3)

# Description

给定一个长为 $n$ 的序列 $\{a_n\}$，判断他们的最大公约数与最小公倍数的乘积是否等于序列中所有数的乘积。

对于所有数据，$1\leq n\leq5\times10^5$，$1\leq a_i\leq10^8$。

# Solution

设 $\displaystyle a_i=\prod p_{j}^{\alpha_{i,j}}$，则 $\displaystyle\gcd(a_1,a_2,a_3,\cdots,a_n)=\prod p_{j}^{\min_{i=1}^{n}\{\alpha_{i,j}\}}$，$\displaystyle\operatorname{lcm}(a_1,a_2,a_3,\cdots,a_n)=\prod p_{j}^{\max_{i=1}^{n}\{\alpha_{i,j}\}}$。

若 $\displaystyle g\times l=\prod_{i=1}^{n}a_i$，则对于所有质数 $p_j$ 都有 $\displaystyle \min_{i=1}^{n}\{\alpha_{i,j}\}+\max_{i=1}^{n}\{\alpha_{i,j}\}=\sum_{i=1}^{n}\alpha_{i,j}$。

显然对于 $n=2$ 条件成立，否则该条件成立仅当 $\{\alpha\}$ 中仅有一个数不为 $0$，也就是每个质数**至多**是一个 $a_i$ 的质因子。

Pollard's Rho 不知道为什么挂了，筛出 $\sqrt{a_i}$ 以下的素数暴力分解就行了。

时间复杂度 $\mathcal{O}(\dfrac{n\sqrt{a_i}}{\ln a_i})$。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Cadmus {
    typedef long long LL;
    const int N = 1e6 + 5;
    int n, cnt, qwq[N], a[N], prime[N];
    unordered_set<int> S;
    void sieve(int n) {
    	for (int i = 2; i <= n; i ++) {
		    if (!prime[i]) a[++ cnt] = i;
		    for (int j = 1; j <= cnt && i * a[j] <= n; j ++) {
		        prime[i * a[j]] = true;
		        if (i % a[j] == 0) break;
		    }
		}
	}
    int main() {
        cin >> n, S.clear();
        for (int i = 1; i <= n; i ++) cin >> qwq[i];
        if (n == 2) return puts("Yes"), 0;
        for (int i = 1; i <= n; i ++) {
        	for (int j = 1; a[j] * a[j] <= qwq[i]; j ++) {
        		if (qwq[i] % a[j]) continue;
        		if (S.count(a[j])) return puts("No"), 0;
        		S.insert(a[j]);
        		while (qwq[i] % a[j] == 0) qwq[i] /= a[j];
			}
			if (qwq[i] == 1) continue;
        	if (S.count(qwq[i])) return puts("No"), 0;
        	S.insert(qwq[i]);
		}
		puts("Yes");
        return 0;
    }
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
    int T = 1; cin >> T, Cadmus::sieve(1e5);
    while (T --) Cadmus::main();
    return 0;
}
```

---

## 作者：zhangzhihao2 (赞：3)

# P9473 [yLOI2022] 西施江南 题解

感谢@int08 提供的 hack 数据，也欢迎其他大佬在评论区指出本篇题解的纰漏。

## 题目大意

判断长度为 $n$ 的数列 $a$ 是否满足如下条件：
$$\gcd(a_1,a_2,\dots,a_n)\times \operatorname{lcm}(a_1,a_2,\dots,a_n)=∏^n_{i=1}{a_i}$$

（$∏^n_{i=1}{a_i}$ 在本篇题解中会多次出现，它等价于 $a_1·a_2·\dots· a_n$）

## 小部分分攻略

**1. 对于前 $12\%$ 的数据，保证 $n=2$。**

显然，$\operatorname{lcm}(a,b)=\dfrac{a\times b}{\gcd(a,b)}$，也就是 $\gcd(a,b)\times\operatorname{lcm}(a,b)=a\times b$ 恒成立，只要“可以，总司令”即可。

**2. 对于前 $36\%$ 的数据，保证 $n\leq 5$。**

开 `long long`，暴力求出 $\gcd$，$\operatorname{lcm}$ 和所有数的乘积，比较一下就能拿分 ~~，怎么乱搞都可以~~。

核心代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,arr[500009];

signed main(){
    cin>>t;
    while(t--){
        int sum=1;
        cin>>n;
        for(int i=1;i<=n;i++){cin>>arr[i];sum*=arr[i];}
        if(n==2){cout<<"Yes"<<endl;continue;}
        int g=__gcd(arr[1],arr[2]),l=arr[1]/g*arr[2];
        for(int i=3;i<=n;i++) g=__gcd(g,arr[i]),l=l/__gcd(l,arr[i])*arr[i];
        if(g*l==sum) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}
```

可以看出这题的数据是比较弱的，因为严格来讲，$∏^n_{i=1}{a_i}\leq (10^5)^5=10^{25}$，`long long` 理应溢出，但是它不仅没溢出，还在后面的部分多绿了两个测试点，最终得到 44pts。

后面的部分分暂时没啥看点了，让我们回到正解思路。

## 正解思路

可以证明，**当 $n>2$ 时，只有 $a_1,a_2,\dots ,a_n$ 两两互素时才能满足条件**：

**定义 $f(a,b)= a$ 因子在 $b$ 中的个数（即最大的使 $a^{x}$ 整除 $b$ 的自然数 $x$） 。** 对于能整除 $∏^n_{i=1}{a_i}$ 的任意质数 $p$，设

$$b_i=f(p,a_i)(1\leq i \leq n)$$

则

$$f(p,\gcd(a_1,a_2,\dots,a_n))=\min^n_{i=1}b_i$$

$$f(p,\operatorname{lcm}(a_1,a_2,\dots,a_n))=\max^n_{i=1}b_i$$

$$f(p,∏^n_{i=1}{a_i})=\sum^n_{i=1}b_i$$

（此处 $\sum$ 表示求和，用法与 $∏$ 类似。）

由 $f()$ 函数定义易得若条件成立，则

$$f(p,\gcd(a_1,a_2,\dots,a_n))+f(p,\operatorname{lcm}(a_1,a_2,\dots,a_n))=f(p,∏^n_{i=1}{a_i})$$

$$\therefore \min^n_{i=1}b_i+\max^n_{i=1}b_i=\sum^n_{i=1}b_i$$

不妨令 $b_i$ 当 $i=1$ 和 $i=2$ 时分别取到最小值和最大值，结合 $b_i$ 为自然数和 $n>2$，则

$$b_1+b_2=b_1+b_2+\dots+b_n$$

$$\therefore b_3+b_4+\dots+b_n=0$$

$$\therefore b_3=b_4=\dots=b_n=0$$

$$\because b_1=\min^n_{i=1}b_i\leq b_n$$

$$\therefore b_1=0$$

得出结论：当条件成立时，对于能整除 $∏^n_{i=1}{a_i}$ 的任意质数 $p$，$p$ 因子仅存在于 $a$ 数列的一个数中，即没有相同质数因子同时出现在两个数中，$a_1,a_2,\dots,a_n$ 两两互素。

显然，当 $a_1,a_2,\dots,a_n$ 两两互素时，

$$\gcd(a_1,a_2,\dots,a_n)=1$$

$$\operatorname{lcm}(a_1,a_2,\dots,a_n)=∏^n_{i=1}{a_i}$$

条件必定成立。

**至此，我们终于严谨地证明了当 $n>2$ 时，$a$ 数列两两互素是条件成立的充分必要条件！**  小小干杯庆祝一下~

那如何判断 $n$ 个数是否两两互素呢？最朴素的就是直译咯，$O(n^2)$ 两两枚举，判断最大公约数是否为 $1$，就可以过第三档部分分（$n\leq1000$）了。

很多题解的做法都是**分解质因数**，但本蒟蒻的做法比较简单粗暴，直接**枚举所有因数**。两两互素，就是没有两个数拥有除 $1$ 以外的公共因数，只要**找出每个数的因数然后判重**就好了嘛！用桶将每个数除 $1$ 以外的因数标记一下，一旦发现重复就判否，直到最后都没出问题就是两两互素了。

比较一下两种做法，分解质因数由于不仅要遍历 $\sqrt{a_i}$ 内的所有数，还要把每个质因数除完，所以时间复杂度**大于** $O(Tn·\sqrt{a_i})$，而枚举因数的做法的时间复杂度则是严格的 $O(Tn·\sqrt{a_i})$。因此依蒟蒻拙见，这样的做法比分解质因数略优一点点，因此**不用素数筛也可以 AC** 。也欢迎各位大佬在评论区友善讨论一下两种做法的优劣。

如果**事先筛一下素数，只遍历所有素数**，显然更快咯，但这样的话就没必要一个个把素数都除完了，只需要浅浅做个标记就行了。

## ~~你们最喜欢的~~完整代码

这里采用的还是蒟蒻讲的第一种算法哦~

对了，枚举因数的最后不要忘记算上这个数本身，跟普通因数一样处理就行，千万不要写错位置！ ~~，别像我一样爆12分┭┮﹏┭┮~~。


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,arr[500009];
map<int,int> m;

int main(){
    cin>>t;
    while(t--){
        memset(arr,0,sizeof(arr));  //数据千万条，清空第一条。
        m.clear();                  //多测不清空，爆零两行泪。
        cin>>n;
        for(int i=1;i<=n;i++) cin>>arr[i];
        if(n==2){cout<<"Yes"<<endl;continue;}
        bool flag=true;
        for(int i=1;i<=n;i++){
            int num=0;
            for(int j=2;j*j<=arr[i];j++){
                if(arr[i]%j==0){
                    if(m[j]||m[arr[i]/j]){flag=false;break;}
                    m[j]++,m[arr[i]/j]++,num++;
                }
            }
            if(m[arr[i]]){flag=false;break;}
            m[arr[i]]++;
            if(!flag) break;	//注意！！！一定要先完全分解完再判断！
        }
        if(flag) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}
```

---

## 作者：251Sec (赞：3)

对每个质因子单独考虑，设 $c_i$ 为当前质因子在 $a_i$ 中的出现次数。则原要求等价于 $\min c_i + \max c_i=\sum c_i$。

容易发现 $n=2$ 时这个要求一定满足。考虑 $n>2$ 的情况。

去掉任意一个最小 $c_i$ 和任意一个最大 $c_i$ 后，剩下的 $c_i$ 一定都为 $0$，而由此我们可以得到最小的 $c_i$ 也为 $0$。因此对于当前质数，条件满足当且仅当仅有一个 $c_i>0$，即被该质数整除的 $a_i$ 只有一个（或零个）。

不妨对所有 $a_i$ 做质因数分解，设 $V$ 为值域，则质因子总共有不超过 $O(N \log V)$ 个，可以直接判断。现在唯一的问题是如何做质因数分解。每次根号分解会超时，不妨直接 $O(n)$ 线性筛出所有 $1 \sim 10^8$ 内的数的最小质因子，于是我们预处理后对一个数分解质因数的复杂度就是 $O(\log V)$ 了。

总时间复杂度 $O(V+N\log V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n;
int pri[8000005], cnt;
int lpri[100000005];
bitset<100000005> chk;
int a[500005], w[3000005], wCnt;
int main() {
    for (int i = 2; i <= 100000000; i++) {
        if (!chk[i]) {
            pri[++cnt] = i;
            lpri[i] = i;
        }
        for (int j = 1; j <= cnt && 1ll * i * pri[j] <= 100000000; j++) {
            lpri[i * pri[j]] = pri[j];
            chk[i * pri[j]] = true;
            if (i % pri[j] == 0) break;
        }
    }
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", a + i);
        if (n == 2) {
            puts("Yes");
            continue;
        }
        wCnt = 0;
        for (int i = 1; i <= n; i++) {
            int lp = 1;
            while (a[i] > 1) {
                if (lpri[a[i]] != lp) {
                    lp = lpri[a[i]];
                    w[++wCnt] = lp;
                }
                a[i] /= lpri[a[i]];
            }
        }
        sort(w + 1, w + wCnt + 1);
        bool flg = true;
        for (int i = 1; i < wCnt; i++) {
            if (w[i] == w[i + 1]) {
                flg = false;
                break;
            }
        }
        puts(flg ? "Yes" : "No");
    }
    return 0;
}
```

---

## 作者：timmark (赞：3)

# P9473 题解
一道很有意思的数学题。

我们观察一下样例。

第一组数据，$n=2$，显然因为 $\gcd(a,b)\times \text{lcm}(a,b)=a\times b$，所以答案为 `Yes`。

第二组数据，$\gcd(2,3,4)=1$，$\text{lcm}(2,3,4)=12$，$1\times12\neq2\times3\times4$。

第三组数据，$\gcd(3,8,35)=1$，$\text{lcm}(3,8,35)=840$，$1\times 840=3\times8\times35$。

为什么第二组数据是 `No`？因为 $\text{lcm}(2,3,4)=\text{lcm}(\text{lcm}(2,4),3)=\text{lcm}(\dfrac{2\times4}{\gcd(2,4)},3)=\dfrac{2\times4\times3}{2}$，也就是说因为 $2$ 和 $4$ 不互质，导致 $\text{lcm}(2,4,3)\times \gcd(2,4,3)\neq2\times 3\times 4$。

我们猜测满足条件的情况为：$n=2$ 或 $a_i$ 两两互质。

考虑严格证明（此处只考虑 $n>2$ 的情况）。

设 $a_i=p_1^{k_1}\times p_2^{k_2}\times \cdots\times p_m^{k_m}$，则 $\gcd(a_1,a_2,\cdots,a_n)=p_1^{\min \limits^{n}_{i=1}k_{i,1}}\times p_2^{\min \limits^{n}_{i=1}k_{i,2}}\times\cdots \times p_m^{\min \limits^{n}_{i=1}k_{i,m}}$，$\text{lcm}$ 同理，将 $\min$ 改为 $\max$ 即可。

那么，当序列两两不互质时，分两种情况讨论。

当序列两两不互质时，必然存在一个 $i$，使得**不止一个** $a_j$ 满足 $p_i\mid a_j$，我们称这个质数为 $P$。

当不是所有 $a_i$ 都是 $P$ 的倍数时，此时因为 $\min \limits_{j=1}^{n} k_{j,i}=0$，而除了 $\max \limits_{j=1}^{n} k_{j,i}$ 其他的 $k_{j,i}$ 都不会被算进 $g\times l$。

当 $a_i$ 均为 $P$ 的倍数时，因为 $n>2$，所以 $\min \limits_{j=1}^{n} k_{j,i}\times\max \limits_{j=1}^{n} k_{j,i}\neq\prod \limits^{n}_{j=1}k_{j,i}$。

因此，只需判断这些数是否两两互质即可。

但是，直接暴力判断复杂度是 $\text O(n^2)$ 的，明显不行。

可以考虑在分解质因数的时候判断，如果这个质因数在分解这个数之前就已经在桶里了，肯定不满足两两互质。否则就把这个质因数放进桶里。

但是，这样复杂度仍然是 $\text O(n\sqrt {a_i})$ 的，在 $a_i=10^8$，$n=5\times10^5$ 时，大概 $5\times10^9$，不大力卡常根本过不去。我们考虑优化。显然，一个数 $n$ 的质因数不会超过 $\log_2 n$ 个（最坏为 $2$ 的幂），又发现 $a_i$ 只有 $10^8$，在本题 $3$ 秒的时限下完全足够！

所以，我们用线性筛提前处理出每个数的最小质因子。

记得清空。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e8+5,N=5e5+5;
int t,n,p[maxn],f[maxn],cnt,a[N],mx,vis[maxn];
bool np[maxn];
void sieve(int maxn){//线性筛
	for(int i=2;i<=maxn;i++){
		if(!np[i]){
			p[++cnt]=i;
			f[i]=i;
		}for(int j=1;j<=cnt;j++){
			if(i*1ll*p[j]>maxn) break;
			np[i*1ll*p[j]]=1;
			f[i*1ll*p[j]]=p[j];
			if(i%p[j]==0) break;
		}
	}
}int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	sieve(100000000);
	cin >> t ;
	while(t--){
		mx=0;
		cin >> n ;
		mx=0;
		for(int i=1;i<=n;i++) cin >> a[i] ,mx=max(mx,a[i]);
		if(n==2){//特殊处理
			puts("Yes");
			continue; 
		}memset(vis,0,sizeof(int)*(mx+5));//清空
		bool flag=1;
		for(int i=1;i<=n && flag;i++){
			int now=a[i];
			while(now!=1){//质因数分解
				if(vis[f[now]] && vis[f[now]]!=i){
					flag=0;
					break;
				}vis[f[now]]=i;
				now/=f[now];
			}
		}if(flag) puts("Yes");
		else puts("No");
	}return 0;
}
```

---

## 作者：happy_zero (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9473)

有一个结论：当且仅当 $n=2$ 或 $a$ 数组中的数两两互质，成立时答案为 `Yes`。

证明：

显然 $g=\gcd(a_1,a_2,...,a_n),l=\frac{a_1\times a_2\times...\times a_n}{\gcd(a_1,a_2)\times \gcd(a_1,a_3)\times...\times\gcd(a_{n-1},a_n)}$，当 $\gcd(a_1,a_2,...,a_n)=\gcd(a_1,a_2)\times \gcd(a_1,a_3)\times...\times\gcd(a_{n-1},a_n)$ 时答案为 `yes`。

而右式大于等于 $g^{\frac{n(n-1)}{2}}$，那么只有：
1. $n(n-1)=1,n=2$
2. $g=1$ 且 $\gcd(a_1,a_2)=\gcd(a_1,a_3)=...=\gcd(a_{n-1},a_n)$

时等式成立。

结论得证。

$O(Tn^2)$ 暴力做法显然，直接上正解：对每个质数循环一遍判断是否有两个及以上的数拥有它们并除尽，如果是的话就输出 `No`。但是值域 $10^8$ 里的质数有 $5761455$ 个，显然会超时，由于数 $a$ 拥有的大于 $\sqrt a$ 的质因子最多只有一个，所以可以先只判断 $\sqrt {10^8}=10^4$ 内的质数，剩下的排序一遍看有没有重复即可，记得特判 $n=2$。

PS：其实也可以对每个数进行分解质因数，但这样判重还得用 `map` 或其它记录，所以我选择了枚举质数。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
const int V = 1e4 + 5; //只筛到根号值域
int prime[V], ts, a[N], n;
bool vis[V];
inline int read(){//用快读节省时间
    int w=1,q=0;
    char ch=' ';
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return w*q;
}
void init() {//线性筛
	for (int i = 2; i < V; i++) {
		if (!vis[i]) prime[++ts] = i;
		for (int j = 1; j <= ts && prime[j] * i < V; j++) {
			vis[prime[j] * i] = true;
			if (i % prime[j] == 0) break;
		}
	}
}
bool chk() {
	for (int i = 1; i <= ts; i++) {
		int cnt = 0;
		for (int j = 1; j <= n && cnt <= 1; j++)
			if (a[j] % prime[i] == 0) {
				cnt++;
				while (a[j] % prime[i] == 0) a[j] /= prime[i];//一次除尽
			}
		if (cnt > 1) return 0;
	}
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n; i++)
		if (a[i] != 1 && a[i] == a[i - 1]) return 0;//注意得跳过 1
	return 1;
}
int main() {
	init();
	int T;
	cin >> T;
	while (T--) {
        //这种写法不用清空数组
		n = read();
		for (int i = 1; i <= n; i++)
			a[i] = read();
		cout << (n == 2 || chk() ? "Yes\n" : "No\n");
	}
	return 0;
}
```

---

## 作者：Iniaugoty (赞：1)

updata on 7.23：已经是题解了，但是代码被 hack，于是改了一下重交，麻烦管理给个通过！

## problem

有 $n$ 个数 $a_1,a_2,\cdots,a_n$。设 $g=\gcd\{a_i\},l=\operatorname{lcm}\{a_i\}$。问 $gl$ 是否等于 $\prod a_i$。

## solution

设 $a_i=gb_i$，则 $gl=\prod a_i$ 可以化成 $l=g^{n-1}\prod b_i$。

分三种情况：

- $n=2$：$l=gb_1b_2$，这是显然的。

- $n\not=2,g=1$：显然只有当 $a$ 两两互质时满足 $l=\prod a_i$。 

- $n\not=2,g\not=1$：显然不可能满足条件。因为 $g\prod b_i$ 一定是 $a_i$ 的公倍数，而它比 $g^{n-1}\prod b_i$ 更小。

然后就是判断两两互质的问题。

- 我会枚举和欧几里得算法！

双循环枚举每个数再求最大公因数，时间复杂度 $\mathcal O(n^2\lg n)$，可以得到 $52\%$ 的分数。

- 我会用桶暴力！

枚举每个数的因数，放进桶中，再判断有没有重复。时间复杂度 $\mathcal O(n\sqrt n)$，可以得到至少 $76\%$ 的分数。适当剪枝之下貌似可以卡过赛时 $100\%$ 数据。

- 我会线性筛！

考虑在上一种做法下优化：先筛出 $10^8$ 以内的素数，枚举素因数即可。时间复杂度 $\mathcal O(n\pi(\sqrt n))$。其中 $\pi(n)$ 表示 $[1,n]$ 中的素数个数，有 $\displaystyle\lim_{n\to\infty}\frac{\pi(n)\ln n}{n}=1$。

## code

```cpp
#include<bits/stdc++.h>
#define N 500005
#define maxn 100000000
using namespace std;
int T,n,a[N],p[maxn/15],cnt;
bool vis[maxn+5],ans;
map<int,bool>t;//桶
void Prime(){//线性筛
	vis[1]=1;//1 不是质数！一定加上这一行！不然 a 全是 1 的数据会寄
    for(int i=2;i<=maxn;i++){
        if(!vis[i]) p[++cnt]=i;
        for(int j=1;j<=cnt&&i*p[j]<=maxn;j++){
            vis[i*p[j]]=1;
            if(i%p[j]==0) break;
        }
    }
}
void check(int x){//判重
    if(t[x]) ans=0;
    t[x]=1;
}
signed main(){
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    Prime();
    cin>>T;
    while(T--){
        cin>>n,ans=1,t.clear();
        for(int i=1;i<=n;i++)
            cin>>a[i];
        if(n==2) {cout<<"Yes\n";continue;}//特判 n=2
        for(int i=1;i<=n;i++){
            for(int j=1;j<=cnt&&p[j]*p[j]<=a[i];j++){//枚举素因数
                int f=p[j],g=a[i]/p[j];
                if(f*g==a[i]){
                    check(f);
                    if(f!=g&&!vis[g]) check(g);
                }
                if(!ans) break;
            }
            if(!vis[a[i]]) check(a[i]);
            if(!ans) break;
        }
        cout<<(ans?"Yes\n":"No\n");
    }
    return 0;
}
```

---

## 作者：heaksicn (赞：1)

### 1 题意

给定 $n$ 个正整数 $a_i$，问其所有数的 gcd 与 lcm 之积时候等于所有数的乘积。

$n\leq 5\times 10^5,a_i\leq 10^8$。

### 2 思路

首先，当 $n=2$ 时，问题转化为常见的引理，不考虑。以下考虑 $n\geq 3$ 的情况。

对于每个数做质因数分解，即令 $a_i=p_1^{k_1}p_2^{k_2}...p_m^{k_m}$。

那么，所有数的 gcd 即可表示成 $g=p_1^{\min\limits_{i=1}^nk_{i,1}}p_2^{\min\limits_{i=1}^nk_{i,2}}...p_m^{\min\limits_{i=1}^nk_{i,m}}$，lcm 同理。

那么对于每一个质因数 $p_x$，它在 $g\times l$ 中的系数就可以表示成 $\min\limits_{i=1}^nk_{i,x}+\max\limits_{i=1}^nk_{i,x}$。

那么，当且仅当满足 $k_{i,x}>0$ 不超过一个时，$\min\limits_{i=1}^nk_{i,x}+\max\limits_{i=1}^nk_{i,x}=\sum\limits_{i=1}^n k_{i,x}$。

即每个数两两互质。

但是，如果对于每个数分别做分解质因数的话，复杂度为 $O(n\sqrt a)$，需要大力卡常。

注意到每个数大于 $\sqrt a$ 的质因子不超过一个，那么可以预处理出 $\sqrt a$ 以内的质数，在分解时枚举质数即可。

时间复杂度 $O(nk)$，$k=1229$ 是 $10^4$ 内的质数个数，可以通过此题。

### 3 code

```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int a[500001];
int pr[100001],vis[100001],cnt;
map<int,int> mp;
int main(){
	int T=read();
	for(int i=2;i<=1e4;i++){//预处理1e4内的质数
		if(vis[i]==0) pr[++cnt]=i;
		for(int j=1;j<=cnt&&pr[j]*i<=1e4;j++){
			vis[i*pr[j]]=1;
			if(i%pr[j]==0) break;
		}
	}
	int tp=cnt;
	while(T--){
		int n=read();
		mp.clear();
		for(int i=1;i<=n;i++){
			a[i]=read();
		}
		if(n==2){
			puts("Yes");
			continue;
		}
		bool flag=1;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=cnt;j++){//枚举质数
				if(a[i]%pr[j]==0){不huhi
					if(mp[pr[j]]){//这个质数已经用过，即不互质
						flag=0;
						break;
					}
					while(a[i]%pr[j]==0) a[i]/=pr[j];
					mp[pr[j]]=1;//标记
				}
			}
			if(a[i]!=1){//根号以外的质因子
				if(mp[a[i]]){
					flag=0;
					break;
				}
				mp[a[i]]=1;
			}
			if(!flag) break;
		}
		puts(flag?"Yes":"No");
	}
	return 0;
}

```


---

## 作者：LEle0309 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9473)

普及组月赛第三题，~~本蒟蒻赛时又因为调试代码没删在此题挂了四十分。~~

一道数论题……
***
### 进入正题

#### 结论：

当这个数列里的数两两互质或 $ n=2 $ 时，$ l \times g=a_1 \times a_2 \times … \times a_n $。

#### 证明：

设 $ a_1 \times a_2 \times … \times a_n=s $。

因为 $ l $ 是 $ a_1,a_2,a_3,…a_n $ 的最小公因数，所以每个数 $ a_i $（$ i \in [1,n] $）都可以表示成 $ b_i \times l $。易得 $ b_1 \times b_2 \times … \times b_n=\dfrac{s}{l^n} $。

设 $ b_1,b_2,b_3,…,b_n $ 的最小公倍数是 $ g_0 $。而 $ b_1 \times b_2 \times … \times b_n $ 即 $ \dfrac{s}{l^n} $ 一定是 $ b_1,b_2,b_3,…,b_n $ 的最小公倍数，所以 $ g_0 $ 一定是 $ \dfrac{s}{l^n} $ 的因数，设为 $ \dfrac{s}{l^n \times k} $，其中 $ k > 1 $。

所以 $ g=l \times g_0= \dfrac{s}{l^{n-1} \times k} $，可得 $ l \times g=\dfrac{s}{l^{n-2} \times k} $。

又因为 $ l \times g =s $，所以 $ \dfrac{s}{l^{n-2} \times k}=s $。两边同时除以 $ s $，再取倒数，得 $ l^{n-2} \times k=1 $。而两个自然数相乘积为 $ 1 $，则两个数都为 $ 1 $，即 $ l^{n-2}=k=1 $。

而 $l^{n-2}=1 $，易得解为 $ n=2 $ 或 $ l=1 $。而 $ l=1 $ 则 $ g=s $，说明这个序列里的数两两互质。

#### 代码实现

法一：我们可以双重循环暴力枚举，时间复杂度 $ O(Tn^2) $，会超时。

法二：我们筛出小质数，然后分解质因数并用桶判断出现次数，看是否两两互质，就可以过啦！

```cpp
#include<string.h>
#include<cstdio>
using namespace std;
const int maxn=1e6+7;
const int maxm=1e8+7;//桶要开到1e8
int t,n,a,prime[maxn],b,i,j,f,vis[maxm],sum;
int read()
{
	int res=0,flag=0;
	char ch;
	if((ch=getchar())=='-')flag=1;
	else if(ch>='0'&&ch<='9')res=ch-'0';
	while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-'0';
	return flag?-res:res;
}//快读卡常
void shai(void)
{
	for(int i=2;i<=maxn;i++)
	if(prime[i]==0)
	{
		sum++;prime[sum]=i;
		for(int j=i*2;j<=maxn;j+=i)prime[j]=1; 		
	}
}//埃氏筛，筛出小质数
int main()
{
	t=read();
	shai();
	while(t--)//t组数据
	{
		n=read();
		if(n==2)//第一种可能
		{
			int l,m;l=read();m=read();
			printf("Yes\n");	
		}
		else
		{
			for(i=1;i<=n;i++)
			{
				a=read();
				for(j=1;j<=sum&&prime[j]*prime[j]<=a;j++)//枚举质数
					if(a%prime[j]==0)
					{
						vis[prime[j]]++;//桶
						if(vis[prime[j]]>1)
						{
							f=1;//不互质
							break;
						}
						while(a%prime[j]==0)a/=prime[j];//分解质因数	
					}				
				if(!f&&a>1)//分解完成
				{
					vis[a]++;
					if(vis[a]>1)f=1;//不互质	
				}
			}
			if(!f)printf("Yes\n");//不互质
			else printf("No\n");//互质		
		}
		f=0;memset(vis,0,sizeof(vis));//多测不清空，提交两行泪	
	}
	return 0;//完结撒花！	
}
```

---

## 作者：Rainbow_Sky (赞：1)

## 思路

### 方法1 暴力

#### 思路

使用暴力在本题可以得到 40pts，~~也就是本蒟蒻在考场上使用的方法~~，我们直接暴力计算 $n$ 个数的最大公因数和最小公倍数，再把他们乘起来，就能判断是否相等了。

#### code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1000+10;
const int MAXM=100000+10;
const int INF=100000;
int a[MAXM];
int gcd2(int a,int b)
{
	int temp;
	if(a<b)
	{
		temp=a;
		a=b;
		b=temp;
	}
	while(b!=0)
	{
		temp=a%b;
		a=b;
		b=temp;
	}
	return a;
}
int gcd(int *a,int n)
{
	if(n==1)
		return(*a);
	return gcd2(a[n-1],gcd(a,n-1));
}
int ged2(int a,int b)
{
	int gcd2(int a,int b);
	int temp=gcd2(a,b);
	return(a*b/temp);
}
int ged(int *a, int n)
{
	if(n==1)
		return *a;
	else
		return ged2(a[n-1],ged(a,n-1));
}
signed main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,s=1;
		memset(a,0,sizeof a);
		cin>>n;
		for(int i=0;i<n;i++)
		{
			cin>>a[i];s*=a[i];
		}
		int div=gcd(a,n);
		int mul=ged(a,n);
		if(div*mul==s) cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

### 方法二 分解质因数

~~开始事后诸葛亮。~~

#### 思路

首先，我们需要明确在什么情况下，$n$ 个数的最大公因数和最小公倍数之积为它们的乘积。

先来看一下最大公因数的定义：最大公因数为 $n$ 个数最大所公有的因数，我们不妨设之为 $x$。

再来看一下最小公倍数的定义：最小公倍数是 $n$ 个数最大公有的因数乘以它们各自特有的因数，我们不妨设它们各自特有的因数为 $y$，则最小公倍数为 $x\times y$。

这时候我们就可以把 $\prod \limits_{i=1}^{n}a_i$ 用 $x$ 和 $y$ 表示出来，即
$$\prod \limits_{i=1}^{n}a_i=x^{n} \times y$$

就此我们就此，我们可以推出如果我们希望 $n$ 个数的最大公因数和最小公倍数之积为它们的乘积，也就可以列出式子：

$$\begin{aligned} x^{n}\times y &= x\times (x\times y)\\ &=x^2\times y\end{aligned}$$

解得当且仅当 $n=2$ 或 $x=1$ 时，等式可以成立。

结论：

1. $n=2$ 时可以成立。

1. 最大公因数为 $1$，即两两互质时可以成立。

#### 做法

我们先使用欧拉筛筛选出质数，然后开一个 map，每一次去跑，有公因数就记下来，直接输出 `No`，跑完后还没有输出，就输出 `Yes`。

欧拉筛模板：

```cpp
for(int i=2;i<=n;i++)
{
	if(f[i]==0) p[++cnt]=i;
	for(int j=1;j<=cnt,i*p[j]<=n;j++)
	{
		f[i*p[j]]=1;
		if(i%p[j]==0) break;
	}
}
```

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1000+10;
const int MAXM=500000+10;
const int INF=100000;
map<int ,int >mp;
int cnt,p[MAXM],a[MAXM];
bool f[MAXM],flag;
void olas(int n)
{
	for(int i=2;i<=n;i++)
	{
		if(f[i]==0) p[++cnt]=i;
		for(int j=1;j<=cnt,i*p[j]<=n;j++)
		{
			f[i*p[j]]=1;
			if(i%p[j]==0) break;
		}
	}
}
int main()
{
	olas(1e5);//预处理
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		for(int i=1;i<=n;i++) 
		{
			cin>>a[i];
		}
		mp.clear();//清空map
		flag=0;//注意归零
		if(n==2) //特判
		{
			cout<<"Yes\n";
			continue;
		}
		else
		{
			for(int i=1;i<=n;i++)
			{
				int x=a[i];
				for(int j=1;j<=cnt;j++)
				{
					if(x%p[j]==0)
					{
						if(mp[p[j]]==1)
						{
							cout<<"No\n";
							flag=1;
							break;
						}
						else mp[p[j]]=1;
					}
					while(x%p[j]==0) x/=p[j];
				}
				if(x>1)
				{
					if(mp[x]==1&&!flag)
					{
						cout<<"No\n";
						flag=1;
						break;
					}
					else mp[x]=1;
				}
				if(flag) break;
			}
			if(!flag) cout<<"Yes\n";
		}
	}
	return 0;
}
```

后记：特别鸣谢 JAMES_KING 提供的宝贵思路。

---

## 作者：rainygame (赞：0)

居然把 $O(n\sqrt{a_i})$ 的放了 $96$……

首先分析题目。如果想要 $l\times g=\prod a_i$，就需要 $n=2$（这个显然）或者 $a_i$ 两两互质。否则算最小公倍数的时候必然会约掉一些数，导致等式不成立。

但是暴力判断是否两两互质的时间复杂度是 $O(n^2 \log a_i)$，肯定过不了，于是开始想优化。

我们可以把每一个 $a_i$ 分解质因数，然后一旦发现两个相同的就表示不是两两互质。对于判断可以用 `unordered_set` 来判重，这样复杂度就优化到了 $O(n\sqrt{a_i})$。期望 $76$，实际 $96$。

对于最后几个点，我们可以考虑先筛 $10^4$ 以内的质数。这样就不用枚举 $\sqrt{a_i}$ 里面的所有数（哪怕不是质数），而只需要枚举大约 $\ln \sqrt{a_i}$ 个数就可以了。时间复杂度 $O(n \ln \sqrt{a_i})$。

赛时代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 500001
#define int long long

int t, n, flag;
int a[MAXN];
bitset<10001> vis;
vector<int> pr;
unordered_set<int> st;

bool check(int x){
	for (auto i: pr){
		if (i*i > x) break;
		if (x % i == 0){
			if (st.find(i) != st.end()) return false;
			st.insert(i);
			while (x % i == 0) x /= i;
		}
	}
	if (x != 1){
		if (st.find(x) != st.end()) return false;
		st.insert(x);
	}
	return true;
}

signed main(){
//	 freopen("C2.in", "r", stdin);
//	 freopen("C2.out", "w", stdout);
	
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    for (int i(2); i*i<=50000; ++i){
    	if (!vis.test(i)){
    		pr.push_back(i);
    		for (int j(i*i); j<=n; j+=i) vis.set(j);
		}
	}
    
	cin >> t;
	while (t--){
		cin >> n;
		for (int i(1); i<=n; ++i) cin >> a[i];
		
		if (n == 2){
			cout << "Yes\n";
			continue;
		}
		
		flag = 0;
		st.clear();
		for (int i(1); i<=n; ++i){
			if (!check(a[i])){
				flag = 1;
				break;
			}
//			cout << a[i] << '\n';
		}
		cout << (flag ? "No" : "Yes") << '\n';
	}

    return 0;
}
```


---


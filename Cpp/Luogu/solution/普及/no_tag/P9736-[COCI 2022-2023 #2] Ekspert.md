# [COCI 2022/2023 #2] Ekspert

## 题目描述

给定四个变量 $\texttt{A}$，$\texttt{B}$，$\texttt{C}$，$\texttt{D}$，初始值为 $x$，$y$，$0$，$1$。

你可以对它们进行如下操作：

选择两个变量，将他们相加的和存储在一个变量中。

请你使用该种操作不超过 $100$ 次，使任意一个变量的值等于 $x\times y$。

## 说明/提示

| $\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$14$|$x,y \le 50$ |
|$2$|$14$|$x\times y \le 10^4$|
|$3$|$42$|无|

**本题满分 $70$ 分。**

## 样例 #1

### 输入

```
1 2```

### 输出

```
1
A A A
A```

## 样例 #2

### 输入

```
3 2```

### 输出

```
6
D C C
D C C
D C C
D C C
D C C
D C C
C
```

# 题解

## 作者：Grow_ (赞：12)

## P9736题目解析:

看到题目，$A$ 和 $B$ 一开始就是 $x$ 和 $y$，而要得到的是 $x \times y$，所以只要把 $x$ 加上 $y$ 次或者把 $y$ 加上 $x$ 次即可。

发现 $C$ 的初始值为 0，所以可以把所有值都丢到 $C$ 里面。

然后我们发现，每次进行 `A A A` 的操作时，变量 $A$ 都会乘 2，于是很自然的想到 2 进制，所以我们就想到把其中一个作为基准，把另外一个数转化为 2 进制，遍历每一位，是 1 就加，非 1 就不加，就可以得到答案了。

**问题来了，是不是两个数都可以作为基准呢？**

从本质上来讲，其实是可以的，但题目中有一句话：

`请你使用该种操作不超过 100 次`

所以就不行，因为大的数要的操作次数自然也会变多，但是你并不能保证大的数的操作数不超过 100 次,而小的数一定比大的更优，所以该选小的，[这篇题解](https://www.luogu.com.cn/blog/Ctrl-V-yyds/solution-p9736)和[这篇题解](https://www.luogu.com.cn/blog/cyx11919eason/solution-p9736)在这方面就有问题，但是这题并不卡这一点。

**注意：$x \times y \le 10^{18}$，记得开 long long**

[这篇题解](https://www.luogu.com.cn/blog/DFcloud/solution-p9736)就没开 long long。

# AC Code:

```cpp
#include<bits/stdc++.h>
#define int long long
//切记，一定开long long
using namespace std;
int x,y;
vector<string>s;
signed main(){
	cin >> x >> y;
	if(y<x){
		//选择小的切 
		while(y){
			//判断是否要加 
			if(y%2==0)s.push_back("A A A");//A*=2
			else{
				s.push_back("A C C");//C+=A
				s.push_back("A A A");//A*=2
			}
			y/=2;
		}
	}
	else{
		while(x){
			//判断是否要加 
			if(x%2==0)s.push_back("B B B");//B*=2
			else{
				s.push_back("B C C");//C+=B
				s.push_back("B B B");//B*=2
			}
			x/=2;
		}
	}	
	cout << s.size() << "\n";
	for(int i = 0;i<s.size();i++)cout << s[i] << "\n";//输出 
	cout << "C";//答案存在C中，输出C 
	return 0;
}
```

**结束语：此题难度并不大，但仍有很多细节需要注意，值得回味。**

---

## 作者：DF_cloud (赞：5)

考虑一下式子 $x+x=2x \  2x+2x=4x \ 4x+4x=8x$ 不难看出，我们可以通过加法得到 $2^i\times x$，我们可以把 $y$ 转换为二进制，记 $Y_i$ 为 $y$ 在二进制下的第 $i$ 位，则 $x\times y=\sum_{i}^{}Y_i\times x$。因为我们要使 $n$ 尽可能的小，所以我们会选择枚举较小的数。（一些具体的东西可以看注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y;
vector<string> opt;
int main(){
	cin>>x>>y;
	long long a,b,c;
	a=x,b=y,c=0;//这里没有用到D
	//枚举较小的数
	if(x<y){
		while(x){
			if(x%2){
				//如果当前x的位为一才累加进答案
				opt.push_back("B C C");
				c=b+c;
			}
			opt.push_back("B B B");
			//2^i*x+2^i*x=2^(i+1)*x
			b=b*2;
			x=x/2;
		}
	}
	else{
		while(y){
			if(y%2){
				opt.push_back("A C C");
				c=a+c;
			}
			opt.push_back("A A A");
			a=a*2;
			y=y/2;
		}
	}
	cout<<opt.size()<<endl;
	for(auto i:opt){
		cout<<i<<endl;
	}
	cout<<"C"<<endl;
	return 0;
}
```
[提交记录](https://www.luogu.com.cn/record/128588359)

---

## 作者：lol_qwq (赞：1)

# P9736 题解

### 思路

题目比较简洁，要使得一变量变成 $x \times y$，$C$ 变量显然无用。

在相加的题目里，又有 $0$ 和 $1$ 想到二进制。

若 $y$ 是一个 $2^N$ 类型的数，我们只需要不断输出 ```A A A``` 直到 $A=y$.。

若 $y$ 不是 $2^N$ 类型的数，我们选择把 $y$ 化成二进制，再通过枚举较小的 $n$，使用 $1$ 前去微量调整即可。

### 代码

代码就不放了，根据上面的思路简单枚举一下就行。

---

## 作者：PCCP (赞：0)

## 思路

额，非常简单的一题，但是卡了我一会，感觉像是智力检测题。

首先，题目给了我们两个定值，分别是 $ C=0 $ 和 $ D=1 $。

如果每次都只是加 $ 1 $ 那显然太逆天了。观察样例可以发现，我们可以每次自己加自己再赋给自己，这不就是倍增嘛。结合题目要求我们的操作次数 $ n \le 100 $，那我们的操作次数只能是 $ \log_2{\max(x,y)} $ 级别的，很容易想到是不是和快速幂有点像。的确，只不过快速幂是乘方拆成乘积，这题把乘积拆成加了而已。

所以做法就是模仿快速幂，每次把 $ y $ 除以二，遇到奇数就说明要加上原数，不是奇数就自己加自己。这样操作次数最多就是 $ 2 \times \log_2{x} $ 了。

可以发现，$ C $ 对我们操作潜在的作用其实是作为中间定量使得我们可以把一个数赋到另一个地址上去。所以我们可以利用这一点使得 $ D=x $。

但是这样交上去你会发现你得不到满分，有两个测试点返回的结果是：

```Wrong Answer.wrong output format The number of operation(s) is too large!```

为什么呢，仔细分析数据范围，你会发现题目只告诉我们 $ x \times y \le 10^{18} $ 也就是说，存在 $ y $ 极小而使得 $ x \ge 2^{50} $ 的情况。

解决方法很简单，利用中间变量和中间定量交换一下就好了，这样我们的操作次数最多为 $ 2 \times \log_2{10^9} $ 了，加上一些交换的次数，完全可以通过本题。

时间复杂度：$ O(\log_2{\min(x,y )}) $。

## 代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cmath>
#include<queue>
#include<stack>
#include<list>
#include<set>
using namespace std;
const int N=5e4+10;
const int MOD=998244853;
int n;
long long p[5];
struct node{
	int x,y,z;
}act[N];
void ksm(long long x,long long y){
	while(y>1){
		if(y&1){
			act[++n]={3,0,0};
		}
		act[++n]={0,0,0};
		y>>=1;
	}
}
signed main(){
	cin>>p[0]>>p[1];
	p[2]=0,p[3]=1;
	ksm(max(p[0],p[1]),min(p[0],p[1]));
	act[++n]={0,2,3};
	if(p[0]<p[1]){
		act[++n]={3,2,1};
		act[++n]={1,2,0};
		act[++n]={0,2,3};
	}
	cout<<n<<endl;
	for(int i=n;i>=1;i--){
		char x=act[i].x+'A',y=act[i].y+'A',z=act[i].z+'A';
		cout<<x<<" "<<y<<" "<<z<<endl;
	}
	cout<<"A"<<endl;
}
```

---

## 作者：WOL_GO (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P9736)

一个带一点思维的题目。

## 思路

显而易见，如果要把 $A$ 和 $B$ 变为 $A\times B$（$A\le B$），最简单的办法就是执行 $A$ 遍 $+B$ 操作，然后把每一次的结果储存到 $C$ 这样就能得到一份暴力代码。然后考虑优化暴力，我们可以采用一个跟快速幂差不多的二进制拆分思路。我们把其中一个数拆为二进制，然后遍历每一位，是一的就加上，不是一的就不管，然后就能得到答案。

tips:记得开 `long long`

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e6+5;
int x,y,cnt;
string c="B";
string s[maxn];
signed main(){
	cin>>x>>y;
	if(x>y)swap(x,y),c='A';
	while(x){
		if(!(x&1))s[++cnt]=(c+' '+c+' '+c+'\n');
		else s[++cnt]=c+" C C\n",s[++cnt]=(c+' '+c+' '+c+'\n');
		x>>=1;
	}	
	cout<<cnt<<"\n";
	for(int i=1;i<=cnt;i++)cout<<s[i];
	cout<<"C";
	return 0;
}

```

---

## 作者：BugGod (赞：0)

首先根据样例，我们可以发现，题目允许自己加自己，也等于乘 2。比如，我们要让 $A$ 乘 2，我们可以用 $A\ A\ A$ 来实现。那么我们想要快速增长，可以用 $C$ 来统计，先用 $D$ 给它赋值，再将其不断自乘，然后用 $D$ 来微调。但微调操作的复杂度是 $O(xy)$ 的，不能通过此题。

---
不过我们可以发现我们没有使用 $A$ 和 $B$，所以可以换掉 $C$ 和 $D$，同时，利用将 $y$ 二进制拆分的思想，如果 $y$ 的第 $i$ 位为 0，直接累加自己；如果 $y$ 的第 $i$ 为 1，可以用 $A,B$ 调整。代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct opt
{
    char x,y,z;
};
vector<opt>ans;
void pushopt(char x,char y,char z)
{
    opt op;
    op.x=x;
    op.y=y;
    op.z=z;
    ans.push_back(op);
}
int a,b,c,d=1,x,y;
signed main()
{
    cin>>a>>b;
    x=a;
    y=b;
    if(a>b)swap(a,b);
    for(;a;a/=2)
    {
        if(a%2==1)
        {
            if(x<y)pushopt('C','B','C');
            else pushopt('C','A','C');
        }
        if(x<y)pushopt('B','B','B');
        else pushopt('A','A','A');
    }
    cout<<ans.size()<<endl;
    for(int i=0;i<ans.size();i++)printf("%c %c %c\n",ans[i].x,ans[i].y,ans[i].z);
    cout<<"C";
    return 0;
}
```

---

## 作者：RandomLife (赞：0)

一道细想不难的题目。

我们发现得到的数是 $x \times y$，而我们又可以进行加法运算，可以联想到龟速乘：
```c++
long long mul(long long x,long long y){
    long long res=0;
    for(;y;y>>=1){
        if(y&1)res+=x;
        x+=x;
    }
    return res;
}
```

发现变量 $C$ 的初值为 $0$，可用于统计答案。

但这样做操作次数为 $O(2 \times \log y)$，在 $y$ 较大时会超过 $100$ 次操作。因此当 $x<y$ 时将 $x$ 和 $y$ 的意义交换即可。

上述过程中变量 $D$ 无用，可以忽略。

代码：
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long x,y;
    int cnt=0,c=0;
    cin>>x>>y;
    if(x<y){
        for(int i=0;i<64;++i)
            if(x&(1ll<<i))cnt++,c=max(c,i+1);
        cout<<cnt+c<<endl;
        for(;x;x>>=1){
            if(x&1)cout<<"C B C"<<endl;
            cout<<"B B B"<<endl;
        }
    }else{
        for(int i=0;i<64;++i)
            if(y&(1ll<<i))cnt++,c=max(c,i+1);
        cout<<cnt+c<<endl;
        for(;y;y>>=1){
            if(y&1)cout<<"C A C"<<endl;
            cout<<"A A A"<<endl;
        }
    }
    cout<<"C";
    return 0;
}

```

---

## 作者：Eason_cyx (赞：0)

自己出的题。

假设 $y < x$，那么 $x \times y$ 可以用如下方法表示成不超过 $\log_2{y}$ 个数：

$x \times y=\sum 2^i \times x$，其中 $i$ 为 $y$ 的二进制表示下第 $i$ 位为 $1$ 的那些数。

所以我们就可以用 $2\log_2{y}$ 次操作解决这个问题啦。

```cpp
#include <bits/stdc++.h>

using namespace std;

char s[] = {'A', 'B'};
long long r[4];
vector<vector<char>> output;

int main() {
  cin >> r[0] >> r[1];

  int x = (r[0] < r[1] ? 0 : 1);
  while (r[x]) {
    if (r[x] % 2) {
      output.push_back({s[x ^ 1], 'C', 'C'});
      r[2] += r[x ^ 1];
    }
    output.push_back({s[x ^ 1], s[x ^ 1], s[x ^ 1]});
    r[x ^ 1] *= 2;
    r[x] /= 2;
  }

  cout << output.size() << endl;
  for (auto t : output) {
    cout << t[0] << " " << t[1] << " " << t[2] << endl;
  }

  cout << "C" << endl;
  return 0;
}
```

---


# [COCI 2022/2023 #3] Dirigent

## 题目描述

信息学冬令营以一场传统舞蹈结营。一共有 $n$ 名学生参与。他们每个人都有分别有一个 $1\sim n$ 之间的编号。

一开始，指挥者 Kreso 要求学生们围成一个圈，使得每个学生都与另外两个学生拉着手。

Alenka 想知道是否有可能通过将且仅将一对相邻同学分开手，使得这样形成的同学序列按照编号排序。例如，如果他们的顺序是 `3 4 1 2`，那么圈可以从 `4` `1` 两个同学间断开；但是如果顺序是 `2 1 4 3`，那么没有一种合理的方式。

在这一晚，Kreso 准备下达 $q$ 条指令。在每条指令中，他会要求两个学生交换位置。在每一次交换之后你需要帮助 Alenka 回答他的问题。


## 说明/提示

**【样例解释 #2】**

![](https://cdn.luogu.com.cn/upload/image_hosting/382d6t5r.png)

**【数据范围】**

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n,q \leq 500$ |
| $2$ | $20$ | $n,q \leq 5000$ |
| $3$ | $35$ | 无特殊性质 |

对于 $100\%$ 的数据，满足 $1\leq n,q \leq 3\times10^5,1\le a_i\le n, 1\le x_i,y_i\le n,x_i\neq y_i$。

本题满分 $70$ 分。

## 样例 #1

### 输入

```
5 2
2 3 4 5 1
1 3
3 1```

### 输出

```
NE
DA```

## 样例 #2

### 输入

```
4 2
2 3 1 4
4 2
3 4```

### 输出

```
NE
DA```

## 样例 #3

### 输入

```
6 5
2 1 5 6 3 4
3 1
3 4
3 2
4 5
5 4```

### 输出

```
NE
NE
DA
NE
DA```

# 题解

## 作者：SunSkydp (赞：4)

subtask#1 和 subtask#2 都是暴力好吧，直接讲正解了。

我们将每对左右相邻的两位同学组合为一个 pair，即对于任意的 $1 \leq i \leq n$，$a_i$ 和 $a_{(i+1)\mod n}$ 可以组成一个 pair。

我们定义当一个 pair 的第一关键字小于第二关键字时，这个 pair 为“好”的 pair，反之为“坏”的。题目的条件为环从某一处断开能够形成一个单调上升的序列，那么当所有的 $n$ 个 pair 中，有且仅有 $1$ 个 pair 是“坏”的，就可以满足题意了。

妙啊！那每次 query 的时候，不就只要修改 $4$ 个 pair 吗？受到影响的 pair 有：$x$ 作为第一关键字所在 pair、$y$ 作为第一关键字所在 pair、$x$ 作为第二关键字所在 pair、$y$ 作为第二关键字所在 pair。

这里我还添加了 $id1$ 和 $id2$ 数组（具体见代码），$id1_i$ 表示第一关键字为 $i$ 的 pair 的编号，$id2_i$ 表示第二关键字为 $i$ 的 pair 的编号。

接下来是代码啦，不懂的评论里提问，写的不好的地方请在评论里指出。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 300005;
int n, q, a[N], bad;
pair<int, int> stu[N];
int id1[N], id2[N];
bool is_bad(pair<int, int> p) {return p.first > p.second; }
int change(int a, int b, int c, int d) {
	return is_bad(stu[a]) + (b != a ? is_bad(stu[b]) : 0)
	+ ((c != b && c != a) ? is_bad(stu[c]) : 0) 
	+ ((d != c && d != b && d != a) ? is_bad(stu[d]) : 0);
}
int main() {
	scanf("%d %d", &n, &q);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i++) {
		if(i == n) stu[i] = make_pair(a[n], a[1]), id1[a[n]] = id2[a[1]] = i;
		else stu[i] = make_pair(a[i], a[i + 1]), id1[a[i]] = id2[a[i + 1]] = i;
		if(is_bad(stu[i])) bad++;
	}
	while(q--) {
		int x, y; scanf("%d %d", &x, &y);
		int a = id1[x], b = id2[x], c = id1[y], d = id2[y];
		bad -= change(a, b, c, d);
		stu[id1[x]].first = stu[id2[x]].second = y;
		stu[id1[y]].first = stu[id2[y]].second = x;
		id1[x] = c; id2[x] = d; id1[y] = a; id2[y] = b;
		bad += change(a, b, c, d);
		if(bad == 1) puts("DA");
		else puts("NE");
	}
	return 0;
}
```

---

## 作者：1zhangziheng2023 (赞：2)

[看题戳我](https://www.luogu.com.cn/problem/P9757)
### 思路
可以记录相邻同学编号的大小关系（包括第 $n$ 位和第  $1$ 位），若 $a_i<a_{i-1}$（以下称之为“要求数对”）的个数恰好为 $1$，则输出 "DA"，否则输出 "NE"。为什么呢？理由如下：

假设 $n$ 同学牵手成一条链，且学生的编号依次为 $1$ 到 $n$，此时的 $a_1$ 与 $a_n$ 刚好组成要求数对，且没有其它“要求数对”，即“要求数对”个数恰好为 $1$。第 $1$ 个同学与 $n$ 个同学牵手后，我们把任意一个同学看成“第 $1$ 个同学”，也不会改变“要求数对”的数量。除此情况外，不存在“要求数对”数量为 $1$ 的情况。
### 做法
在交换编号时，会有 $4$ 个相邻编号的大小关系可能改变，我们需要重新判断大小并计算要求数对的个数，因此我们可以用一个 $v$ 数组记录 $a_i$ 和 $a_{i-1}$ 的**大小关系**，再用一个变量 $s$ 存储**要求数对的个数**。

为了减少分类讨论时过多 if 语句带来的 ~~烦恼~~ 累赘和调试时的不便，我们可以用 $lx,rx,ly,ry$ 分别代表需要重新判断大小的数组下标，如果超过 $n$ 或小于 $1$，记得转为 $1$ 或 $n$。

最后，题目还有个坑，输入给出的两个整数 $x_i,y_i$ 代表的是**要交换的编号**而不是下标，所以我们还可以开一个数组标记编号所在数组下标，这个数组也需要随着编号交换而维护。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,q,s;
int a[300005],b[300005];
bool v[300005];
signed main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[a[i]]=i;//记录编号所在位置
        if(i>1){
            if(a[i]>a[i-1])v[i]=0;
            else v[i]=1,s++;
        }//s记录要求数对个数 v数组记录大小关系
        if(i==n){
            if(a[1]>a[i])v[1]=0;
            else v[1]=1,s++;
        }
    }
    while(q--){
        int x,y;
        cin>>x>>y;
        x=b[x],y=b[y];
        swap(a[x],a[y]);
        b[a[x]]=x,b[a[y]]=y;

        int lx=x-1,rx=x+1,ly=y-1,ry=y+1;
        //利用这四个变量避免分类讨论的麻烦
        if(lx==0)lx=n;else if(ly==0)ly=n;
        if(rx==n+1)rx=1;else if(ry==n+1)ry=1;

        if(a[x]>a[lx]&&v[x]==1)v[x]=0,s--;
        if(a[x]<a[lx]&&v[x]==0)v[x]=1,s++;
        if(a[rx]>a[x]&&v[rx]==1)v[rx]=0,s--;
        if(a[rx]<a[x]&&v[rx]==0)v[rx]=1,s++;

        if(a[y]>a[ly]&&v[y]==1)v[y]=0,s--;
        if(a[y]<a[ly]&&v[y]==0)v[y]=1,s++;
        if(a[ry]>a[y]&&v[ry]==1)v[ry]=0,s--;
        if(a[ry]<a[y]&&v[ry]==0)v[ry]=1,s++;
        if(s==1)cout<<"DA\n";//要求数对只有1个时符合条件
        else cout<<"NE\n";
    }
    return 0;
}
```

本蒟蒻第一次写题解，若有错误或不足之处，欢迎各位 dalao 批评指正。

---

## 作者：harmis_yz (赞：2)

## 分析

对于一个从小到大（按编号排序）的长度为 $n$ 的序列 $A$，有性质：相邻两个数之差的绝对值为 $1$ 的数量为 $n-1$。

那么，对于这道题，能使环剪开一条边使其按编号排序，必有相邻两个 $i,j$，满足 $(A_i-A_j=1)$ 的数量为 $n-1$。注意，因为这是个环，所以 $i,j$ 大小关系不能确定。

记录一个 $cnt$ 表示满足关系的数量，每次交换 $x,y$ 的时候将原本 $x,y$ 的贡献删掉，再将与 $x,y$ 相邻的数的贡献删掉；增加同理。最后判断一下 $cnt$ 是否等于 $n-1$ 即可。

注：与 $x,y$ 相邻的数可能有 $y,x$ 两个，需要先判断一下。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline

const int N=3e5+10;
int n,q,a[N];
int X[N],cnt;

il void add(int x){
	if(a[(x-1)==0?n:(x-1)]==a[x]-1) ++cnt;
	return ;
}
il void del(int x){
	if(a[(x-1)==0?n:(x-1)]==a[x]-1) --cnt;
	return ;
}

il void solve(){
	cin>>n>>q;
	for(re int i=1;i<=n;++i) cin>>a[i],X[a[i]]=i;
	for(re int i=1;i<=n;++i) add(a[i]);
	for(re int i=1;i<=q;++i){
		int x,y;cin>>x>>y;
		del(X[x]),del(X[y]);
		if(((X[x]+1)==n+1?1:(X[x]+1))!=X[y]) del((X[x]+1)==n+1?1:(X[x]+1));
		if(((X[y]+1)==n+1?1:(X[y]+1))!=X[x]) del((X[y]+1)==n+1?1:(X[y]+1));
		swap(a[X[x]],a[X[y]]),swap(X[x],X[y]);
		add(X[x]),add(X[y]);
		if(((X[x]+1)==n+1?1:(X[x]+1))!=X[y]) add((X[x]+1)==n+1?1:(X[x]+1));
		if(((X[y]+1)==n+1?1:(X[y]+1))!=X[x]) add((X[y]+1)==n+1?1:(X[y]+1));	
		if(cnt==n-1) cout<<"DA\n";
		else cout<<"NE\n";	
	}
	return ;
}

signed main(){
	solve();
	return 0;
}
```


---

## 作者：WsW_ (赞：2)

难度约为黄。

---
### 思路
设第 $i$ 个人，其编号为 $a_i$。  
设编号为 $x$ 的人，在位置 $p_i$。  
我们认为他处在正确的位置上，当且仅当：
$$a_i=a_{i-1}+1=a_{i+1}-1$$

**注意，由于是环，所以要通过取模或特判来保证数据在环内。**  
对于一次换位操作，可能影响 $p_x-1,p_x,p_x+1,p_y-1,p_y,p_y+1$ 六个位置的正确性，我们只需要重新检测这六个位置的正确性即可。  

用 `set` 记录位置错误的人的位置，并在检测正确性的时候更新。  
注意，一开始需要初始化所有位置的正确性。

时间复杂度为 $O((n+q)\log n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[300003];
int p[300003];
int n,q;
int x,y;
set<int>s;
void check(int i){
	int last=i-1,ntt=i%n+1;
	if(!last)last+=n;
	if(a[i]%n+1==a[ntt]&&a[i]==a[last]%n+1)s.erase(i);
	else s.insert(i);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		p[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		check(i);
	}
	while(q--){
		cin>>x>>y;
		swap(a[p[x]],a[p[y]]);
		swap(p[x],p[y]);
		x=p[x],y=p[y];
		int last=x-1,ntt=x%n+1;
		if(!last)last+=n;
		check(x);  check(last);  check(ntt);
		last=y-1,ntt=y%n+1;
		if(!last)last+=n;
		check(y);  check(last);  check(ntt);
		if(s.empty())cout<<"DA\n";
		else cout<<"NE\n";
	}
	return 0;
}
```

---
### 优化
发现 $a_i$ 较小，不需要用 `set`，直接开个 `bool` 数组记录每个位置是否正确即可。

时间复杂度 $O(n+q)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[300003];
int p[300003];
int n,q;
int x,y;
bool s[300003];
int size;
//set<int>s;
void check(int i){
	int last=i-1,ntt=i%n+1;
	if(!last)last+=n;
	if(a[i]%n+1==a[ntt]&&a[i]==a[last]%n+1){
		if(s[i])size--;
		s[i]=0;
	}
	else{
		if(!s[i])size++;
		s[i]=1;
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		p[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		check(i);
	}
	while(q--){
		cin>>x>>y;
		swap(a[p[x]],a[p[y]]);
		swap(p[x],p[y]);
		x=p[x],y=p[y];
		int last=x-1,ntt=x%n+1;
		if(!last)last+=n;
		check(x);  check(last);  check(ntt);
		last=y-1,ntt=y%n+1;
		if(!last)last+=n;
		check(y);  check(last);  check(ntt);
		if(size==0)cout<<"DA\n";
		else cout<<"NE\n";
	}
	return 0;
}
```

---

## 作者：thh_loser (赞：1)

# P9757 [COCI2022-2023#3] Dirigent 题解

[题目链接](https://www.luogu.com.cn/problem/P9757)

## 题意

给定一个环排列，进行 $q$ 次换位，求每次换位后能否从某个位置断开，使得排列升序排列。

## 思路

我们考虑在什么情况下才能够满足要求，如果看成一串链，显然两段都是递增且差值为 $1$ 的。于是我们可以模拟这个过程，统计当前位不是上一项加一的位数。如果总共的数量不大于 $1$（因为可以从中途切开，所以可以有一段从 $1$ 重新开始），则可以满足条件，否则不能。



对于每次交换，我们减去当前两个数字的贡献，交换后再加上各自在新位置的贡献，再进行判断即可。



## 注意事项

1.注意读入要交换的就是这两个数，而不是下标。

2.如果两个要交换的数相邻则需要特判，否则会对贡献重复计算。

## code
```c++
#include<bits/stdc++.h>
#define N 300010
using namespace std;
int n,q,cnt;
int a[N],pos[N];
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		pos[a[i]]=i;
		if(i!=1&&a[i-1]+1!=a[i]){
			cnt++;
		}
	}
	a[n+1]=a[1];
	if(1+a[n]!=a[n+1])cnt++;
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		x=pos[x];
		y=pos[y];
		if(x>y)swap(x,y);
		if(1+a[(x==1?n:x-1)]!=a[x])cnt--;
		if(1+a[x]!=a[x+1]&&x!=y-1)cnt--;
		if(1+a[y-1]!=a[y])cnt--;
		if(1+a[y]!=a[y+1])cnt--;//减去之前的贡献 
		
		swap(a[x],a[y]);
		pos[a[x]]=x;
		pos[a[y]]=y;
		a[n+1]=a[1];
		
		if(1+a[(x==1?n:x-1)]!=a[x])cnt++;
		if(1+a[x]!=a[x+1]&&x!=y-1)cnt++;
		if(1+a[y-1]!=a[y])cnt++;
		if(1+a[y]!=a[y+1])cnt++;//加上新的贡献
		 
		if(cnt<=1)cout<<"DA\n";
		else cout<<"NE\n";
	}
	return 0;
}
```

---

## 作者：Cypher_404 (赞：1)

# 题解：P9757 [COCI2022-2023#3] Dirigent

~~终于有题可以写题解了。~~

## 题意分析

给出一个长度为 $n$ 的序列 $a_1\to a_n$，其中 $1\to n$ 每一个数字各出现 $1$ 次。

定义 $q$ 次操作，每一次操作交换两个数的位置，在交换后询问是否能将这一个数组从中间的某一个位置剪开顺时针形成一个 $1\to n$ 的环。

## 做法分析

总结一个规律，$n$ 个数可以构成 $n$ 个可以剪开的“边”，如果有 $n-1$ 个数的上一个数是 $a[i]-1$（$a[i]$ 表示当前的数字），那么说明可以构成一个环。即：判断成功。

定义一个数组：$ok[\ \ \ ]$。

用于存放每一个节点是否判断成功，再加入一个变量 $sum$，用于记录总共有多少个数字判断成功。

因为题目上说的是**交换两个数字而不是下标**，所以在使用一个数组 $b[\ \ \ ]$ 辅助计算。

## 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template< typename T > inline void read(T &x)
{
    char c=getchar();x=0;bool f=0;
    for(;!isdigit(c);c=getchar()) f|=(c=='-');
    for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
    x=f?-x:x;
}
int n,q,sum;
int a[300030],b[300030];
bool ok[300030];
int main()
{
	read(n);read(q);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
		b[a[i]]=i;
	}
	for(int i=1;i<=n;i++)
	{
		if(i!=1)
		{
			if(a[i]==1+a[i-1])
			{
				ok[i]=1;
				sum++;
			}
			else
			{
				ok[i]=0;
			}
		}
		else
		{
			if(a[1]==a[n]+1)
			{
				ok[1]=1;
				sum++;
			}
			else
			{
				ok[1]=0;
			}
		}
	}
	while(q--)
	{
		int x,y;
		read(x);
		read(y);
		x=b[x];
		y=b[y];
		swap(a[x],a[y]);
		b[a[x]]=x;
		b[a[y]]=y;
		int ll=x-1,lr=x+1,rl=y-1,rr=y+1;
		if(ll==0)
		{
			ll=n;
		}
		if(lr==n+1)
		{
			lr=1;
		}
		if(rl==0)
		{
			rl=n;
		}
		if(rr==n+1)
		{
			rr=1;
		}//辅助计算的变量们
		
		if(ok[x]==1&&a[x]!=a[ll]+1)//更新并检查当前状态，后面的if一样
		{
			ok[x]=0;
			sum--;
		}
		if(ok[x]==0&&a[x]==1+a[ll])
		{
			ok[x]=1;
			sum++;
		}
		
		if(ok[lr]==1&&a[lr]!=a[x]+1)
		{
			ok[lr]=0;
			sum--;
		}
		if(ok[lr]==0&&a[lr]==1+a[x])
		{
			ok[lr]=1;
			sum++;
		}
		
		
		
		if(ok[y]==1&&a[y]!=a[rl]+1)
		{
			ok[y]=0;
			sum--;
		}
		if(ok[y]==0&&a[y]==1+a[rl])
		{
			ok[y]=1;
			sum++;
		}
		
		if(ok[rr]==1&&a[rr]!=a[y]+1)
		{
			ok[rr]=0;
			sum--;
		}
		if(ok[rr]==0&&a[rr]==1+a[y])
		{
			ok[rr]=1;
			sum++;
		}
		
		
		if(sum==n-1)
		{
			puts("DA");
		}
		else
		{
			puts("NE");
		}
	}
	return 0;
}
```

---

## 作者：Cells (赞：0)

#### 思路

通过手模，判断后一个人比前一个人多 $1$​ 的人数是否是总人数减一，如果是，那么就可以，否则不可以。证明其实很简单，因为不满足条件的点就是我们的断点。交换的时候只需要看交换的两个数对其左右两边的数造成的影响，并不需要重新扫一遍。

#### 注意

在交换的时候注意交换的两个位置相邻的情况，因为这种情况会造成重复，需仔细思考判断。

另外，这道题交换的不是下标而是数字，有点坑。

**Code**

```c++
# include <bits/stdc++.h>
using namespace std;

const int N = 3e5 + 10;

int n, q, cnt;
int a[N], p[N];

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> q;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		p[a[i]] = i;//记录坐标 
		if(i > 1 && a[i - 1] + 1 == a[i]) cnt ++;
	}
	
	if(a[n] + 1 == a[1]) cnt ++;//这种也算 
	
	int x, y;
	while(q --){
		cin >> x >> y;
		int xx = x, yy = y;
		x = p[xx], y = p[yy];//坐标 
		swap(p[xx], p[yy]);//交换坐标 
		
		if(x != 1 && a[x - 1] + 1 == a[x]) cnt --;
		if(x == 1 && a[n] + 1 == a[x]) cnt --;
		if(x != n && a[x] + 1 == a[x + 1]) cnt --;
		if(x == n && a[x] + 1 == a[1]) cnt --;
		
		if(y != 1 && y - 1 != x && a[y - 1] + 1 == a[y]) cnt --;//y需要特判 
		if(y == 1 && x != n && a[n] + 1 == a[y]) cnt --;
		if(y != n && y + 1 != x && a[y] + 1 == a[y + 1]) cnt --;
		if(y == n && x != 1 && a[y] + 1 == a[1]) cnt --;
		
		swap(a[x], a[y]);//交换 
		
		if(x != 1 && a[x - 1] + 1 == a[x]) cnt ++;
		if(x == 1 && a[n] + 1 == a[x]) cnt ++;
		if(x != n && a[x] + 1 == a[x + 1]) cnt ++;
		if(x == n && a[x] + 1 == a[1]) cnt ++;
		
		if(y != 1 && y - 1 != x && a[y - 1] + 1 == a[y]) cnt ++;//y需要特判 
		if(y == 1 && x != n && a[n] + 1 == a[y]) cnt ++;
		if(y != n && y + 1 != x && a[y] + 1 == a[y + 1]) cnt ++;
		if(y == n && x != 1 && a[y] + 1 == a[1]) cnt ++;
		
		if(cnt == n - 1) cout << "DA\n";
		else cout << "NE\n";
	}
	
	return 0;
}
```

**感谢你能看到这里！！！**

---

## 作者：dutianchen1 (赞：0)

# [COCI2022-2023#3] Dirigent

### 思路简析

一开始我想维护逆序对，让原数组滚动至从 $1$ 开始，判断逆序对是否为 $0$ 即可。但是我发现复杂度不是很好，只得作罢。

然后，我又想到一个性质，如果整个数组滚动后可以做到单增，那么符合条件的序列应该符合：**位置相邻的一组数值也相邻**（以下称为相邻数对）的组数应该等于 $n-1$。

那么我们可以想到，如果不滚动，也应该符合这个性质。

也就是说，我们维护整个序列相邻数对的数量，只要每次操作后，还能使得相邻数对的数量等于 $n-1$，就输出 `DA`，否则输出 `NE`。

对于每次操作，我们需要先减去之前交换两数对于相邻数对数量的贡献，再交换后重新加上即可。

需要注意的是，因为情景描述的是环，我们对于位置为 $1$ 的情况，向前走要走到位置为 $n$。从 $n$ 开始走同理。

还需要注意，如果每次交换的两数相邻，就需要特判，以防误扣除了对于相邻数对的贡献。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
ll n,m;
ll num[N];
ll t[N];
ll cnt;
void add(ll x){
	if(x==1){
		cnt+=(num[x]-1==num[n]);
	} 
	else{
		cnt+=(num[x]-1==num[x-1]);
	}
}
void add(ll x,ll y){
	add(t[x]);add(t[y]);
	if((t[x]==n?1:t[x]+1)==t[x+1]&&(t[x]==n?1:t[x]+1)!=t[y])add((t[x]==n?1:t[x]+1));
	if((t[y]==n?1:t[y]+1)==t[y+1]&&(t[y]==n?1:t[y]+1)!=t[x])add((t[y]==n?1:t[y]+1));
}
void del(ll x){
	if(x==1){
		cnt-=(num[x]-1==num[n]);
	} 
	else{
		cnt-=(num[x]-1==num[x-1]);
	}
}
void del(ll x,ll y){
	del(t[x]);del(t[y]);
	if((t[x]==n?1:t[x]+1)==t[x+1]&&(t[x]==n?1:t[x]+1)!=t[y])del((t[x]==n?1:t[x]+1));
	if((t[y]==n?1:t[y]+1)==t[y+1]&&(t[y]==n?1:t[y]+1)!=t[x])del((t[y]==n?1:t[y]+1));
}
int main()
{
//	freopen("E.in","r",stdin);
//	freopen("E1.out","w",stdout);
	n=read();m=read();
	for(int i=1;i<=n;i++){
		num[i]=read();
		t[num[i]]=i;
	}
	for(int i=1;i<=n;i++){
		add(num[i]);
	}
//	cout<<(cnt==n-1?"DA":"NE")<<endl;
	for(int i=1;i<=m;i++){
		ll x=read(),y=read();
		del(x,y);
		swap(num[t[x]],num[t[y]]);
		swap(t[x],t[y]);
		add(x,y);
		cout<<((cnt==n-1)?"DA":"NE")<<endl;
//		cout<<cnt<<'\n';
	}
	return 0;
}
/*
4 2
2 3 1 4
4 2
3 4

*/

```

---

## 作者：xuan_gong_dong (赞：0)

## 题面


[P9757 [COCI2022-2023#3] Dirigent](https://www.luogu.com.cn/problem/P9757)
## 分析

记录序列中有多少对相邻且后者比前者多 $1$。如果有 $n-1$ 对即为合法序列，此处定义编号为 $n$ 的位置后面为 $1$。



每一次修改，先减去原来两个位置的贡献数，在加上修改之后的贡献数，判断是否为合法序列即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[300010];
int num=0;
int id[300010];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		id[a[i]]=i;
		if(a[i-1]+1==a[i]&&i!=1)num++;
	}
	if(a[n]+1==a[1])num++;
//	cout<<num;
	while(m--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		int tx=x,ty=y;
		x=id[x],y=id[y];
		id[tx]=y,id[ty]=x;
		if(a[x-1]+1==a[x]&&x!=1)num--;
		if(a[n]+1==a[x]&&x==1)num--;	
		if(a[x]+1==a[x+1]&&x!=n)num--;
		if(a[x]+1==a[1]&&x==n)num--;
		if(a[y-1]+1==a[y]&&y!=1&&y-1!=x)num--;
		if(a[n]+1==a[y]&&y==1&&n!=x)num--;	
		if(a[y]+1==a[y+1]&&y!=n&&y+1!=x)num--;
		if(a[y]+1==a[1]&&y==n&&1!=x)num--;
//		cout<<num<<"->";
		swap(a[x],a[y]);
		if(a[x-1]+1==a[x]&&x!=1)num++;
		if(a[x]+1==a[x+1]&&x!=n)num++;
		if(a[x]+1==a[1]&&x==n)num++;
		if(a[n]+1==a[x]&&x==1)num++;
		if(a[n]+1==a[y]&&y==1&&n!=x)num++;
		if(a[y-1]+1==a[y]&&y!=1&&y-1!=x)num++;
		if(a[y]+1==a[y+1]&&y!=n&&y+1!=x)num++;
		if(a[y]+1==a[1]&&y==n&&1!=x)num++;
//		cout<<num;	
		if(num==n-1)
		{
			puts("DA");
		}
		else puts("NE");
	}

	
}
```

---

## 作者：JimmyLee (赞：0)

# 分析

设 $a[i]$ 为第 $i$ 位的人的编号，$\operatorname{pre}(i)$ 为第 $i$ 位前一个的人。

记 $cnt$ 为满足 $a[\operatorname{pre}(i)]+1=a[i]$ 的 $i$ 的个数。

显然当 $cnt=n-1$ 时，满足题目条件。

我们可以在一开始预先 $O(n)$ 处理出 $cnt$。

考虑一次交换操作带来的贡献。

对于任意一个人，可以 $O(1)$ 算出他和他前后的人产生的贡献。

所以 $O(1)$ 算出要交换的人 $x$ 和 $y$ 的贡献，将 $cnt$ 减去原贡献后再加上新的贡献。

---

但是如果 $x$ 和 $y$ 相邻，可能会有错误的贡献，这时需要特判。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 300005

int a[maxn], pos[maxn];
#define pre(i) (((i)==1)?(n):((i)-1))
#define nxt(i) (((i)==n)?(1):((i)+1))
#define chkpre(x) (a[x]==a[pre(x)]+1)
#define chknxt(x) (a[x]+1==a[nxt(x)])

int main()
{
    int n, q, x, y;
    cin>>n>>q;
    int cnt=0;
    for(int i=1;i<=n;i++) cin>>a[i], pos[a[i]]=i;
    for(int i=1;i<=n;i++)
        if(a[i]==a[pre(i)]+1) cnt++;
    while(q--)
    {
        cin>>x>>y;
        if(pre(x)==y) swap(x, y);
        int nx=x, ny=y;
        x=pos[x], y=pos[y];
        cnt-=chkpre(x)+chknxt(x)+chkpre(y)+chknxt(y);
        if(nxt(x)==y&&a[x]+1==a[y]) cnt++; 
        swap(a[x], a[y]);
        swap(pos[nx], pos[ny]);
        cnt+=chkpre(x)+chknxt(x)+chkpre(y)+chknxt(y);
        swap(x, y);
        if(nxt(x)==y&&a[x]+1==a[y]) cnt--; 
        cout<<(cnt==n-1?"DA":"NE")<<'\n';
    }
}
```

---

## 作者：J_Kobe (赞：0)

### 思路
我们可以用一个变量来存储序列中满足条件的数有多少个，需满足以下任意一个条件：

- 第一个数。
- 这个数减去它的前一个数等于 $1$。
- 如果不等于 $1$ 的话，需要等于 $n$ 减一。

如果满足条件的数等于 $n$ 的话，那么当前序列的答案是肯定的。

我们首先来考虑怎样去交换。我们可以开一个数组来标记每一个数的位置是哪里，每次交换完两个数以后，再把这两个数的位置交换一下。

我们再来考虑如何去求每一次交换后满足条件的数。我们首先在输入时求一下有多少个。然后在每一次交换前如果当前交换的这两个数本身是满足条件的数的话就要将变量减一或减二，因为交换完以后这个位置就不会是满足条件的数了；再看这两个数的后一个数，如果它的后一个数也是满足条件的话，又要将变量去减一或减二。减完以后，就去将要交换的两个数交换一下。交换完以后，我们还是按照上面的方法判断交换后的数是否满足条件，以及它们的后一个数是否满足条件，有多少个满足条件的，就将变量加多少。统计完以后，就再判断一下是否有 $n$ 个就可以了。

还有一个问题就是，如果交换的两个数是相邻的话，不能判断重复，这样会多减或者多扣，所以要在判断它的后一个数时加一个特判。


### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 300005;
int n, q, a[N], id[N]; 

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie();cout.tie();
	cin >> n >> q;
	int sum = 0;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		a[0] = a[1] - 1;
		id[a[i]] = i;
		if (a[i] - a[i-1] == 1)
		{
			sum++;
		}
		else
		{
			if (a[i] - a[i-1] == -(n - 1))
			{
				sum++;
			}
		}
	}
	while (q--)
	{
		int x, y;
		cin >> x >> y;
		a[0] = a[1] - 1;
		int xx = id[x], yy = id[y];
		if (a[xx]-a[xx-1]==1||a[xx]-a[xx-1]==-(n-1))
		{
			sum--;
		}
		if (a[yy]-a[yy-1]==1||a[yy]-a[yy-1]==-(n-1))
		{
			sum--; 
		}
		if (xx != yy + 1)
		{
			if (a[yy+1]-a[yy]==1||a[yy+1]-a[yy]==-(n-1))
			{
				sum--;
			}
		}
		if (yy != xx + 1)
		{
			if (a[xx+1]-a[xx]==1||a[xx+1]-a[xx]==-(n-1))
			{
				sum--;
			}
		}
		swap(a[id[x]], a[id[y]]);
		swap(id[x], id[y]);
		a[0] = a[1] - 1;
		if (a[xx]-a[xx-1]==1||a[xx]-a[xx-1]==-(n-1))
		{
			sum++;
		}
		if (a[yy]-a[yy-1]==1||a[yy]-a[yy-1]==-(n-1))
		{
			sum++; 
		}
		if (xx != yy + 1)
		{
			if (a[yy+1]-a[yy]==1||a[yy+1]-a[yy]==-(n-1))
			{
				sum++;
			}
		}
		if (yy != xx + 1)
		{
			if (a[xx+1]-a[xx]==1||a[xx+1]-a[xx]==-(n-1))
			{
				sum++;
			}
		}
		if (sum == n)
		{
			cout << "DA\n";
		}
		else
		{
			cout << "NE\n";
		}
	}
	return 0;
}
```

---

## 作者：Morax2022 (赞：0)

# Solution
对于所有的点，我们可以关注邻居（所有手牵着手的学生）。有 $n$ 个这样的对。如果右边（顺时针方向）的数较大，让我们称这一对是好的，否则就不好。观察到如果正好有 $1$ 对是不好的，则打破这一对，可形成排序序列。所以，我们尝试维护坏对的数量。

每次交换后，最多有 $4$ 对邻居发生变化，所以我们可以很容易地维护坏对的数量。

这种方法的时间复杂度是 $O(n + q)$，因为我们必须初始计数坏对的数量，并在每次交换后更新它。
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e7;
int wa = 0, a[maxn], w[maxn];
//wa为坏对数量 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int n, q; cin >> n >> q;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		w[a[i]] = i;
		if (i >= 2 && a[i] < a[i - 1]) wa++; 
	}
	wa += (a[1] < a[n]);//统计初始坏对数量 
	while (q--)
	{
		int l, r; cin >> l >> r;
		if (w[l] == 1){
			if (a[1] < a[n] && a[w[r]] >= a[n]) wa--;
			if (a[1] > a[2] && a[w[r]] <= a[2]) wa--;
			if (a[1] > a[n] && a[w[r]] <= a[n]) wa++;
			if (a[1] < a[2] && a[w[r]] >= a[2]) wa++;
		}
		else{
			int k = w[l] + 1;
			if (k > n) k -= n;
			if (a[w[l]] < a[w[l] - 1] && a[w[r]] >= a[w[l] - 1]) wa--;
			if (a[w[l]] > a[k] && a[w[r]] <= a[k]) wa--;
			if (a[w[l]] > a[w[l] - 1] && a[w[r]] <= a[w[l] - 1]) wa++;
			if (a[w[l]] < a[k] && a[w[r]] >= a[k]) wa++; 
		}
		if (w[r] == 1)
		{
			if (a[1] < a[n] && a[w[l]] > a[n]) wa--;
			if (a[1] > a[2] && a[w[l]] < a[2]) wa--;
			if (a[1] > a[n] && a[w[l]] < a[n]) wa++;
			if (a[1] < a[2] && a[w[l]] > a[2]) wa++;
		}else{
			int k = w[r] + 1;
			if (k > n) k -= n;
			if (a[w[r]] < a[w[r] - 1] && a[w[l]] > a[w[r] - 1]) wa--;
			if (a[w[r]] > a[k] && a[w[l]] < a[k]) wa--;
			if (a[w[r]] > a[w[r] - 1] && a[w[l]] < a[w[r] - 1]) wa++;
			if (a[w[r]] < a[k] && a[w[l]] > a[k]) wa++;
		}
		swap(a[w[l]], a[w[r]]);
		swap(w[l], w[r]);
		if (wa == 1) cout << "DA\n";
		else cout << "NE\n";
	}
}
```


---


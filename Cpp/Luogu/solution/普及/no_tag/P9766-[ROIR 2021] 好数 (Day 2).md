# [ROIR 2021] 好数 (Day 2)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T2  [Числа](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。


## 题目描述

定义第一类好数为所有数位上的数字均相同的数。

定义第二类好数为满足如下任意一个条件的数：
- 为第一类好数。
- 设 $t$ 为数的位数，则有 $t-1$ 位数上的数字相同，且无前导零。

现给定一个 $x$，求出 $\ge x$ 的第一个第 $k+1$ 类好数 $y$。

## 说明/提示

对于所有子任务 $1\le x\le 10^{17}$，$k\in\{0,1\}$。

| 子任务编号 |        特殊限制         | 分值 |
| :--------: | :---------------------: | :--: |
|    $1$     | $1\le x\le 10^5$，$k=0$ | $15$ |
|    $2$     |          $k=0$          | $20$ |
|    $3$     |    $1\le x\le 10^5$     | $21$ |
|    $4$     |       无特殊限制        | $44$ |

## 样例 #1

### 输入

```
700
0```

### 输出

```
777```

## 样例 #2

### 输入

```
700
1```

### 输出

```
700```

# 题解

## 作者：kaneki_02 (赞：5)

## P9766 [ROIR 2021 Day 2\] 好数 题解

### **思路**

先考虑第一类好数，直接从 $9$ 到 $1$ 枚举所有可能的情况满足条件更新答案即可，因为是从大到小枚举的最后更新出来的一定是最优解。

再考虑第二类好数，因为最多只有 $20$ 位，那么直接暴力枚举不变的位数的位置，然后从 $0$ 到 $9$ 枚举变的情况，更新最小答案即可。

### **代码**

```c++
#include<bits/stdc++.h>
using namespace std;
string s;
long long ans=1e17;
long long k,a[20],given;
long long Min(long long a,long long b){
	return a<b?a:b;
}
int main(){
	cin>>s>>k;
	for(int i=0;i<s.size();i++){
		given*=10;
		given+=s[i]-'0';
	}//记录原数
	if(k==0){
		for(int i=9;i>=1;i--){//从大到小枚举
			long long now=0;
			for(int j=0;j<s.size();j++){
				now*=10;
				now+=i;
			}
			if(now>=given){//更新答案
				ans=now;
			}
		} 
	}else{
		for(int i=0;i<=9;i++){
			for(int j=0;j<=9;j++){
				for(int k=1;k<=s.size();k++){//枚举不变的位置
					long long now=0;
					if(i==0&&k==1)continue;//去掉前导0
					for(int a=1;a<=k-1;a++){
						now*=10;
						now+=j;
					}
					now*=10;
					now+=i;
					for(int a=k+1;a<=s.size();a++){
						now*=10;
						now+=j;
					}
					if(now>=given)ans=Min(ans,now);//更新答案
				}
			}
		}
	}
	cout<<ans;//输出
	return 0;
}
```



---

## 作者：Dark_Star (赞：4)

# P9766 [ROIR 2021 Day 2] 好数题解

~~第一篇题解，我这个蒟蒻终于找到一篇自己会且能写题解的题了。~~

[题目传送门](https://www.luogu.com.cn/problem/P9766)

[更好的阅读体验？](https://www.luogu.com.cn/blog/1118893/solution-p9766)

---

首先分类讨论。

如果 $k = 0$ ，枚举每个第一类好数，找到第一个 $\ge x$ 的好数。

如果 $k = 1$ ，注意这 $t - 1$ 个数不一定连续（这一点坑了我好久，其实只要明白这一点就可以了），只需要枚举与其他不同的那个数位的位置，并枚举与其他不同的那个数位的数字与其他的数位的数字，并不断更新答案，就能得到解（说白了就是枚举每个第二类好数）。

~~我敢说这是全洛谷最水的黄题。~~

你们最喜欢的 AC 代码来了：

```cpp
#include<bits/stdc++.h>
using namespace std;//代码里用A代表与其他不同的那个数位，X代表除A外其他的数位
int ws(long long x){//求x的位数
	int k=0;
	for(;x;x/=10)k++;
	return k;
}
int main(){
	int k,t;long long x;bool flag;//定义变量（不开long long见祖宗）
	cin>>x>>k;t=ws(x);//下面是重点
	if(k==0){//分类讨论1
		for(int X=1;X<=9;X++){//枚举X
			long long now=0;//now代表当前正在枚举的好数 
			for(int i=1;i<=t;i++)now=now*10+X;//求出这个好数
			if(now>=x){//如果好数不小于输入的数
				cout<<now;
				return 0;//输出并结束
			}
		}
	}else{//分类讨论2
		long long ans=1e17;//ans代表所有now中的最优解（由于要求min请开1e17） 
		for(int X=0;X<=9;X++)
			for(int A=0;A<=9;A++)
				for(int k=1;k<=t;k++){
					if(X==0&&k!=1)continue;
					if(A==0&&k==1)continue;//排除有前导0的数
					long long now=0;//now代表当前正在枚举的好数
					for(int i=1;i<k;i++)now=now*10+X;//加上A的位置的前面的数位 
					now=now*10+A;//加上A的数位 
					for(int i=k+1;i<=t;i++)now=now*10+X;//加上A的位置的后面的数位
					if(now>=x)ans=min(ans,now);//计算最优解 
				}
		cout<<ans;
		return 0;//输出并结束
	}
}//AC撒花！ 
```


---

## 作者：lutaoquan2012 (赞：2)

### [传送门](https://www.luogu.com.cn/problem/P9766)

## 思路：
这道题的数据范围一看是很大的，但是按照这道题的话，我们可以按位枚举，把每一位的暴力一边每一个值，暴力的话不会超时，因为这道题的数据长度最大时 $17$。

1. 如果是考虑第一好数，那么它的最高位数那个值假定设为 $f$，就把这个数的每一位改成 $f$，那么可能是答案，但是考虑另一种情况，如果这个数他是小于我们新组成的数，那么他的每一位值就一定是 $f+1$，才能使最小答案。但是还有一种更省码量的方法，直接从 $0$ 到 $9$ 都暴力枚举，找到第一个每一位都是 $i$ 的大于原值 $x$ 的最小一个。

2. 考虑第二好数，那么我们可以暴力枚举和其他的不同的那一个位数的值，在枚举其他相同的位的值，然后暴力就行了。

#### 注意：这道题的数据过于大，所以在存储最小值的时候，$ans$ 的值一定设为 $10^{17}$ 或者更大的。

```cpp
//
// Created by 55062 on 2024/1/1.
//
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll x,k,len;
ll hh(ll x){//查找这个数的位数
    ll ans=0;
    while(x>0){
        ans++;
        x/=10;
    }return ans;
}
int main(){
    cin>>x>>k;
    len=hh(x);
    if(k==0){//第1类好数
        for(int i=0;i<=9;i++){//枚举每一位
            ll sum=0;
            for(int j=1;j<=len;j++) sum=sum*10+i;//求出每一位是 i 的值
            if(sum>=x){//说是最小的，从 0 开始枚举，就是答案
                cout<<sum;
                exit(0);//结束
            }
        }
    }else{
        ll ans=1e17;//赋值注意！！！
        for(int i=0;i<=9;i++){//枚举不一样的那一位的值
            for(int j=0;j<=9;j++){//枚举一样的位数的值
                for(int k=1;k<=len;k++){//枚举不一样的那个位
                    ll sum=0;
                    if(i==0&&k==1) continue;//判断前导零
                    for(int l=1;l<=k-1;l++) sum=sum*10+j;//计算
                    sum=sum*10+i;
                    for(int l=k+1;l<=len;l++) sum=sum*10+j;
                    if(sum>=x) ans=min(ans,sum);//取最小
                }
            }
        }cout<<ans;
    }
    return 0;
}
```

---

## 作者：tyr_04 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P9766)

一类好数很好枚举，如果以首位为基准，后面的数字一定等于首位。或者说首位的数字加 $1$，后面的数字都一定等于首位数字加 $1$。

比如 $100$，比它大的第一个一类好数是 $111$，它的后几位数字都等于首位数字。又比如 $112$，比它大的第一个一类好数是 $222$，它的后几位数字都等于首位数字加 $1$。

枚举二类好数时，一类好数也算入二类好数之中。除此之外，可以选择保留其中任意一位数字，其它数字可以在 $1$ 到 $9$ 中选择一个进行改变，但改变后其他数位上的数字要相同，注意保留下来的数字也可以改变。最后新的数字和原数比较，看看是否比原数大，且比之前的答案更小，如果是，就更新一次答案。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[20],s[20],u[20];
int main()
{
	string x;
	int k;
	cin>>x>>k;
	if(k==0)//情况一
	{
		bool z=0;
		for(int i=1;i<x.size();i++)
		{
			if(x[i]>x[0])
			{
				z=1;
				break;
			}
			else if(x[i]<x[0])
			{
				z=0;
				break;
			}
		}
		if(z==0)//所有数位上的数字是首位的数字。
		{
			for(int i=0;i<x.size();i++)
			{
				cout<<x[0];
			}
		}
		else if(z==1)//所有数位上的数字是首位的数字加一。
		{
			for(int i=0;i<x.size();i++)
			{
				cout<<char(x[0]+1);
			}
		}
		return 0;
	}
	else if(k==1)//情况二
	{
		for(int i=0;i<x.size();i++)
		{
			s[i]='9'+1;
		}
		for(int l=0;l<x.size();l++)//枚举保留那一位数子。
		{
			for(int w=0;w<=9;w++)//保留的唯一数字是否改变。
			{
				for(int i=0;i<=9;i++)//其他数位上的数字变成几。
				{
					for(int j=0;j<x.size();j++)//将新的数字存入字符串。
					{
						if(j==l)
						{
							u[j]=w+'0';
							continue;
						}
						u[j]=i+'0';
					}
					bool p=0;
					for(int j=0;j<x.size();j++)//判断新的数字是否大于原数。
					{
						if(u[j]>x[j])
						{
							p=0;
							break;
						}
						else if(u[j]<x[j])
						{
							p=1;
							break;
						}
					}
					if(p==0)//满足条件。
					{
						bool r=0;
						for(int j=0;j<x.size();j++)//和之前的答案比较，看看是否更新答案。
						{
							if(s[j]<u[j])
							{
								r=0;
								break;
							}
							else if(s[j]>u[j])
							{
								r=1;
								break;
							}
						}
						if(r==1)
						{
							for(int j=0;j<x.size();j++)//更新答案。
							{
								s[j]=u[j];
							}
						}
					}
				}
			}
		}
	}
	for(int i=0;i<x.size();i++)//输出
	{
		cout<<s[i];
	}
	return 0;
}
```

---

## 作者：wzb13958817049 (赞：1)

# 思路
先求出第一类好数，循环求出岂可，如果跟第一位相同则继续循环，如果比第一位小则就可以以第一位为数字所有位数上的数字均相同，这里不需要考虑到进位，因为最大的第一类好数就是 $99……$。再去考虑第二类好数，我用了比较直接的方法，暴力枚举也不会超时。

# ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k;
string n,ans1,ans2;
int main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	bool t=1;
	if(n.size()==1){
		cout<<n;
		return 0;
	}
	for(int i=1;i<n.size();i++){
		if(n[i]==n[0]) continue;
		else if(n[i]<n[0]){t=1;break;}
		else{t=0;break;}
	}
	if(t==1){for(int i=0;i<n.size();i++) ans1+=n[0];}
	else for(int i=0;i<n.size();i++) ans1+=(n[0]+1);
	if(k==0){
		cout<<ans1;
	}else{
		for(char j='0';j<='9';j++){
			string ans4;
			ans4+=n[0];
			for(int i=1;i<n.size();i++) ans4+=j;
			if(ans4>=n){ans2=ans4;break;}
		}
		for(int i=1;i<n.size();i++){
			for(char j='1';j<='9';j++){	
				string ans3;
				for(int h=0;h<n.size();h++){
					if(h==i) ans3+='0';
					else ans3+=j;
				}
				if(ans3>=n) ans2=min(ans2,ans3);
				ans3="";
				for(int h=0;h<n.size();h++){
					if(h==i) ans3+=n[i];
					else ans3+=j;
				}
				if(ans3>=n) ans2=min(ans2,ans3);
			}
		}
		for(int i=1;i<n.size();i++){
			string ans3;
			for(int j=0;j<n.size();j++){
				if(i==j) ans3+=(n[i]+1);
				else ans3+=n[0];
			}
			if(ans3>=n) ans2=min(ans2,ans3);
		}
		cout<<min(ans1,ans2);
	}
	return 0;
}
```


---

## 作者：JYX0924 (赞：0)

这道题的思路很简单，就是枚举每一位的数字并更新答案。代码跑得很快，对于第二类好数的暴力也不会超时。

下面是我的 AC 代码。
```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y,sum[10],tt,ans=1e18;

ll can()
{
	int cnt=0;
	for(int i=0;i<=9;i++) if(sum[i]>0) cnt++;
	if(y==1) {if(cnt>1) return 0;}
	if(cnt>2) return 0;
	cnt=0;
	for(int i=0;i<=9;i++) if(sum[i]>1) cnt++;
	if(cnt>1) return 0;
	return 1;
}

void dfs()
{
	if(tt>=ans) return;
	if(can()==0) return;
	if(tt>=x) {ans=min(ans,tt); return;}
	for(int i=0;i<=9;i++) tt=tt*10+i,sum[i]++,dfs(),tt=(tt-i)/10,sum[i]--;
}

int main()
{
	cin>>x>>y; y++;
	for(int i=1;i<=9;i++) tt=i,sum[i]++,dfs(),sum[i]--;
	cout<<ans;
	return 0;
}
```

---

## 作者：zhuxiangrui_2010 (赞：0)

# P9766 [ROIR 2021 Day 2] 好数 题解
[题目传送门](https://www.luogu.com.cn/problem/P9766)
## 题意
第一类好数为所有数位上的数字均相同的数，第二类好数为第一类好数或仅有一个位数上的数字与其他位数上的数字不同并且**没有前导零**。给定 $x$ 和 $k$，求出 $\ge x$ 的第一个第 $k+1$ 类好数。
## 思路
1. 考虑第一类好数，由于每个数位上的数字均相同，所以可以从 $1$ 到 $9$ 枚举每个数位上的数，通过总位数计算出好数，最后输出第一个 $\ge x$ 的好数即可。
2. 考虑第二类好数，可以枚举与其他位数上的数不同的位数上的数，然后再枚举其他相同的位数上的数，最后输出第一个 $\ge x$ 的好数即可。

注：考虑第二类好数时不需要额外考虑为第一类好数时的情况，因为枚举时已经考虑了。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x,k,t;
void num(){
	int p=x;
    while(p>0){
        t++;
        p/=10;
    }
}
void hsone(){
    for(int i=1;i<=9;i++){
        int y=0;
        for(int j=1;j<=t;j++){
            y=y*10+i;
        }
        if(y>=x){
            cout<<y;
            return;
        }
    }
}
void hstwo(){
    int y=1e17;
    for(int i=0;i<=9;i++){
        for(int j=0;j<=9;j++){
            for(int k=1;k<=t;k++){
                int s=0;
                if(i==0&&k==1||j==0&&k!=1){
                    continue;
                }
                for(int l=1;l<=t;l++){
                    s*=10;
                    if(l==k){
                        s+=i;
                    }else{
                        s+=j;
                    }
                }
                if(s>=x){
                    y=min(y,s);
                }
            }
        }
    }
    cout<<y;
}
signed main(){
    cin>>x>>k;
    num();
    if(k==0){
        hsone();
    }else{
        hstwo();
    }
    return 0;
}
```

---

## 作者：wht_1218 (赞：0)

此题可分为几个部分：


------------

### $\textbf{1.} n\le 10^5$

从 $x$ 开始，枚举每个数是否满足第 $k+1$ 个数的要求。


可过 $\textbf{Subtask 1,3}$，即 $36p$。

------------

### $\textbf{2.} k=0$

即只要判断第 $1$ 类好数，枚举每一位为 $0-9$ 的情况，长度就是 $x$ 的长度。


可过 $\textbf{Subtask 1,2}$，即 $35p$。（比第 $1$ 种做法还低）

-----------

### $\textbf{3.} AC$

可以在 $k=0$ 的代码基础上加上 $k=1$ 的情况。\
由于第 $2$ 种好数至少有 $t-1$ 个一样的数，我们可以枚举 $t-1$ 个一样的位权和那一个**可能**不一样的位权。\
注意这两者可能**重复**，还要**判断前导 $0$！**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string sx;
ll k,a[20],x,sum=0;
int main(){
	cin>>sx>>k;
	int len=sx.length();
	for(int i=0;i<len;++i)x=x*10+(sx[i]-'0');
	if(k==0){//35p
		for(int i=1;i<=9;++i){
			sum=0;
			for(int j=1;j<=len;++j)sum=sum*10+i;
			if(sum>=x)return cout<<sum,0;
		}return 0;
	}ll ans=1e17+7;
	for(int i=0;i<10;++i){
		for(int j=0;j<10;++j){
			for(int l=1;l<=len;++l){
				sum=0;
				if(i==0&&l==1)continue;
				for(int u=1;u<=l-1;++u)sum=sum*10+j;sum=sum*10+i;
				for(int u=l+1;u<=len;++u)sum=sum*10+j;
				if(sum>=x)ans=min(ans,sum);
			}
		}
	}cout<<ans;
	return 0;
}
```

---

## 作者：xiaoyang111 (赞：0)

## 前言

[题目传送门。](https://www.luogu.com.cn/problem/P9766)

[可能更好的阅读体验。](https://www.luogu.com.cn/blog/xiaoyang111/p9766-ti-xie)

作者搞了半天求过。

## 分析

先分成两部分来做这道题。

### 第一类好数

为什么全是枚举啊。

题意已经很清楚了，其实就是找第一个大于等于 $x$ 所有数位相同的数。

通过小学奥数不难想到，每一个第一类好数其实就是一个个位数乘上由若干个数字 $1$ 拼成的超大数，例如 $999999 = 9 \times 111111$，$11111 = 1 \times 11111$。

设数字 $x$ 的数位长度是 $l$，$t=\underbrace{111 \dots 1}_\text{l个1}$，则第一个大于等于 $x$ 的第一类好数就是 $\lceil \frac{x}{t} \rceil \times t$。因为 $\lceil \frac{x}{t} \rceil \times t$ 是大于等于 $x$ 的第一个 $t$ 的倍数，也就是第一个大于等于 $x$ 的第一类好数。

为什么答案的位数非要是 $l$ 呢？

因为在同一数位内，最大的第一类好数也就是 $9 \times t$，也就是类似 $999 \dots 9$ 这样的数，而这个数刚好是同一数位内最大的数，所以给的 $x$ 是同一数位内最大的数，答案还是 $x$，所以不用枚举更高的位数，因为不可能超过。

代码：

```cpp
long long t=f(x);
int l=f2(x);
cout<<(x+t-1)/t*t<<endl;//和向上取整一样
```

变量的意义和分析中的意义是一样的。

### 第二类好数

这个部分用数学方法有点困难，我们试试暴力枚举。

第二类好数其实就是第一类好数在某一位换成了一个数字，不一定非要是不一样的，当然不能有前导零。

我们先枚举第一类数，然后再通过一些手段来改变一位，最后判断枚举出来的这个第二类数是不是大于等于 $x$ 的，如果是，就可能是答案，和其他的答案取最小值作为输出的答案。

如何枚举第一类好数？

其实只用枚举需要乘的那个个位数就可以了，位数其实就是 $x$ 的位数，见第一类好数里面的解释。

至于是否有前导零这件事，针对一下此类问题特殊处理就可以了。

代码：

```cpp
long long t=f(x);
int l=f2(x);
long long ans=(x+t-1)/t*t;//先把第一类数给算进去 
for (int i=1;i<=9;++i){//第一类数要乘的那个个位数 
	long long num=i*t;//第一类数 
	for (int j=1;j<=9;++j){//要替换的数字 
		for (int k=1;k<=l;++k){//枚举替换的第几位 
			long long tmp=f3(num,j,k);//第二类数
			if (tmp>=x){ 
				ans=min(ans,tmp);
			}
		}
	}
	for (int k=1;k<l;++k){//要替换的数字是零 
		long long tmp=f3(num,0,k);//第二类数
		if (tmp>=x){
			ans=min(ans,tmp);
		}
	}
}
for (int j=1;j<=9;++j){//针对除了最前面的数字为零的数字 
	long long tmp=f3(0,j,l);//第二类数
	if (tmp>=x){
		ans=min(ans,tmp);
	}
}
cout<<ans<<endl;
```

其中变量的意义如果注释中没提到见第一类好数中的解释，函数 ``f3(a,b,c)`` 其实就是算把数字 ``a`` 从末尾往前数的第 ``c`` 位的数字替换成数字 ``b``。

## 完整代码

把所有的代码串联起来就可以了。

```cpp
#include <iostream>
#include <vector>
using namespace std;
long long f(long long num){//返回有num的长度个1 
	long long ans=0;
	while (num){
		ans=ans*10+1;
		num/=10;
	}
	return ans;
} 
int f2(long long num){//返回num的长度 
	int ans=0;
	while (num){
		++ans;
		num/=10;
	}
	return ans;
}
long long f3(long long num,int t,int l){//见第二类好数中的解释 
	--l;
	int tmp=num%10;
	for (int i=0;i<=l;++i){
		num/=10;
	}
	num=num*10+t;
	for (int i=0;i<l;++i){
		num=num*10+tmp;
	}
	return num;
}
int main(){
	long long x,k;
	cin >> x >> k;
	long long t=f(x);
	int l=f2(x);
	if (k==0){//第一类好数 
		cout<<(x+t-1)/t*t<<endl;
	}else{//第二类好数 
		long long ans=(x+t-1)/t*t;//先把第一类数给算进去 
		for (int i=1;i<=9;++i){//第一类数要乘的那个个位数 
			long long num=i*t;//第一类数 
			for (int j=1;j<=9;++j){//要替换的数字 
				for (int k=1;k<=l;++k){//枚举替换的第几位 
					long long tmp=f3(num,j,k);
					if (tmp>=x){ 
						ans=min(ans,tmp);
					}
				}
			}
			for (int k=1;k<l;++k){//要替换的数字是零 
				long long tmp=f3(num,0,k);
				if (tmp>=x){
					ans=min(ans,tmp);
				}
			}
		}
		for (int j=1;j<=9;++j){//针对除了最前面的数字为零的数字 
			long long tmp=f3(0,j,l);
			if (tmp>=x){
				ans=min(ans,tmp);
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Aveiro7 (赞：0)

# 思路

**考虑暴力：**

首先可以确定答案的位数和 $x$ 是一样的。

那么看到第二类好数是包括第一类好数的，就可以先枚举出第一类好数， 再根据 $k$ 来判断是否要构造第二类好数的第 $2$ 种情况。

先枚举一个数字 $i$ 表示所有数位上都是 $i$，判断与 $x$ 的大小关系。

如果 $k=1$，再枚举一个位置 $p$，同时枚举一个数字 $j$，将全部都是 $i$ 改为数位 $p$ 上是 $j$，与 $x$ 比较。

**每次更新最小的，就是答案**。

# Code:
```cpp
#include<cstdio>
#define ull unsigned long long
using namespace std;
int k,num;
ull x,xx,ans,y,ten[20];
int main()
{
	ten[0]=1;
	for (int i=1;i<=17;++i)
		ten[i]=ten[i-1]*10;
	scanf("%llu%d",&x,&k);
	ull xx=x;
	while (xx)
	{
		++num;
		xx=(ull)(xx/10);
	}
	ans=0;
	for (int i=0;i<=9;++i)
	{
		y=0;
		for (int j=0;j<num;++j)
			y=y*10+i;
		if (y>=x&&(ans==0||ans>y)) ans=y;
		if (k)
		{
			for (int j=0;j<num;++j)
			{
				for (int u=0;u<=9;++u)
				{
					y-=(ull)i*ten[j];
					y+=(ull)u*ten[j];
					if (y>=x&&(ans==0||ans>y)) ans=y;
					y-=(ull)u*ten[j];
					y+=(ull)i*ten[j];
				}	
			}
		}
	}
	printf("%llu\n",ans);
	return 0;
}

```

原文出处:[传送门](https://blog.csdn.net/LZX_lzx/article/details/118975579?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-118975579-blog-119112473.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-118975579-blog-119112473.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=1)

---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9766)

首先我们看这题的题面，显然题目要求我们代码中可以对任意一个不超过数据范围的数求出不小于它的最小的第一类和第二类好数。

做法显然是按数位枚举。

首先分析如何求第一类好数。这是比较简单的。设给定的 $x$ 最高位是 $a$，那么先判断如果 $x$ 的所有位都是 $a$，那这个数是不是比 $x$ 大，是的话输出，否则输出所有位都是 $a+1$ 的数，这必然是最优方案。

接下来是求第二类好数。我们先枚举每一位，让除了该位的所有位上的数全部相等，再枚举这一位上的数，如果大于 $x$ 的话记录下来，更新最小的值。最后将最小值输出即为正确答案。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
int k,a[20],x,sum;
signed main(){
	cin>>s>>k;
	int len=s.length();
	for(int i=0;i<len;++i)x=x*10+(s[i]-48);
	if(k==0){//first part
		for(int i=1;i<=9;++i){
			sum=0;
			for(int j=1;j<=len;++j)sum=sum*10+i;
			if(sum>=x){
				printf("%lld",sum);
				return 0;
			}
		} 
	}else{//second part
		int ans=1e17+5;
		for(int i=0;i<=9;++i)
			for(int j=0;j<=9;++j)
				for(int o=1;o<=len;++o){
					sum=0;
					if(i==0&&o==1)continue;
					for(int l=1;l<=o-1;++l)sum=sum*10+j;
					sum=sum*10+i;
					for(int l=o+1;l<=len;++l)sum=sum*10+j;
					if(sum>=x)ans=min(ans,sum);
				}
		printf("%lld",ans);
	}
	return 0;
}
```
Bye！

---


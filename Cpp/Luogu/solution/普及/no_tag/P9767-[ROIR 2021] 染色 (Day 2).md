# [ROIR 2021] 染色 (Day 2)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T3  [Хорошие раскраски](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。

## 题目描述

用 $c$ 种颜色对一个 $n\times m$ 的矩阵染色，要求对于任意 $1\le x_1<x_2\le n$，$1\le y_1<y_2\le m$，$(x_1,y_1)$，$(x_2,y_1)$，$(x_1,y_2)$，$(x_2,y_2)$ 所染的颜色不完全相同。

试构造一组方案。

数据保证有解。

## 说明/提示

- 对于 $25\%$ 的数据，$c=2$。
- 对于另外 $75\%$ 的数据，$c=3$。
- 对于 $100\%$ 的数据，$2\le n,m\le 10$，$2\le c\le 3$。

注：附件为本题的 Special Judge，供大家调试。

## 样例 #1

### 输入

```
2 2 2```

### 输出

```
1 2
2 2```

# 题解

## 作者：cff_0102 (赞：6)

发现数据范围极小，可以直接打表。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c;
int a[15][15];
void dfs(int x,int y){
	if(x==n+1){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<a[i][j]<<",";
			}cout<<endl;
		}
		exit(0);
	}
	int nx=x,ny=y+1;if(ny>m)ny=1,nx++;
	int r=rand();
	for(int i=r;i<=c+r;i++){//尝试填颜色 i%c+1
		bool f=1;
		for(int j=1;j<x;j++){
			for(int k=1;k<y;k++){
				if(a[j][k]==a[j][y]&&a[j][y]==a[x][k]&&a[x][k]==i%c+1)f=0;
			}
		}
		if(f){
			a[x][y]=i%c+1;
			dfs(nx,ny);
			a[x][y]=0;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	srand(time(0));
	cin>>n>>m>>c;
	dfs(1,1);
	return 0;
}
```

其中使用随机数的原因是，这样不会让程序开始尝试填一堆 $1$，导致后面经常出现无解需要回溯的情况。

输入 `8 9 3`（输入再大点等待的就不知道多久了），运气好的话，等待几秒，就会出来一份答案：

```text
2,1,1,3,3,3,2,2,2,
3,1,2,3,1,1,1,1,3,
1,3,1,2,2,1,3,2,3,
2,2,1,3,1,2,3,3,1,
1,2,3,2,1,3,2,3,3,
3,2,3,1,3,1,3,2,1,
1,2,2,1,2,3,3,1,2,
1,3,2,2,3,2,1,3,1,
```

由此可以得到：

```cpp
int b[15][15]={
	{0},
	{0, 2,1,1,3,3,3,2,2,2,0},
	{0, 3,1,2,3,1,1,1,1,3,0},
	{0, 1,3,1,2,2,1,3,2,3,0},
	{0, 2,2,1,3,1,2,3,3,1,0},
	{0, 1,2,3,2,1,3,2,3,3,0},
	{0, 3,2,3,1,3,1,3,2,1,0},
	{0, 1,2,2,1,2,3,3,1,2,0},
	{0, 1,3,2,2,3,2,1,3,1,0},
	{0, 0,0,0,0,0,0,0,0,0,0},
	{0, 0,0,0,0,0,0,0,0,0,0},
};
```

再进行小小的填空和手动微调：

```cpp
int b[15][15]={
	{0},
	{0, 2,1,3,3,1,3,2,1,2,1},
	{0, 2,2,2,1,1,1,1,3,3,3},
	{0, 1,3,2,1,2,3,2,1,1,3},
	{0, 2,3,1,3,3,2,1,1,3,2},
	{0, 2,1,3,2,3,1,3,2,1,3},
	{0, 3,2,1,3,1,2,2,2,1,3},
	{0, 1,2,1,3,2,1,3,3,2,1},
	{0, 1,1,2,2,3,3,1,3,2,2},
	{0, 3,1,1,1,2,3,3,2,3,2},
	{0, 3,3,3,2,2,2,1,3,1,1},
};
```

再放到原来的代码中：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c;
int a[15][15];
int b[15][15]={
	{0},
	{0, 2,1,3,3,1,3,2,1,2,1},
	{0, 2,2,2,1,1,1,1,3,3,3},
	{0, 1,3,2,1,2,3,2,1,1,3},
	{0, 2,3,1,3,3,2,1,1,3,2},
	{0, 2,1,3,2,3,1,3,2,1,3},
	{0, 3,2,1,3,1,2,2,2,1,3},
	{0, 1,2,1,3,2,1,3,3,2,1},
	{0, 1,1,2,2,3,3,1,3,2,2},
	{0, 3,1,1,1,2,3,3,2,3,2},
	{0, 3,3,3,2,2,2,1,3,1,1},
};
void dfs(int x,int y){
	if(x==n+1){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<a[i][j]<<" ";
			}cout<<endl;
		}
		exit(0);
	}
	int nx=x,ny=y+1;if(ny>m)ny=1,nx++;
	for(int i=1;i<=c;i++){//尝试填颜色 i
		bool f=1;
		for(int j=1;j<x;j++){
			for(int k=1;k<y;k++){
				if(a[j][k]==a[j][y]&&a[j][y]==a[x][k]&&a[x][k]==i)f=0;
			}
		}
		if(f){
			a[x][y]=i;
			dfs(nx,ny);
			a[x][y]=0;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m>>c;
	if(c==2)dfs(1,1);
	else{
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<b[i][j]<<" ";
			}cout<<endl;
		}
	}
	return 0;
}
```

~~轻松~~ AC。

---

## 作者：anke2017 (赞：3)

提供一个跑得快很多（相对于普通爆搜，比如 cff 的）的爆搜。

## 解法 1

前置知识：位压 dfs。

我们注意到 $n,m$ 很小，可以直接爆搜。但是普通爆搜显然时间爆炸。

这里贴一个普通爆搜（cff 的）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c;
int a[15][15];
void dfs(int x,int y){
	if(x==n+1){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<a[i][j]<<" ";
			}cout<<endl;
		}
		exit(0);
	}
	int nx=x,ny=y+1;if(ny>m)ny=1,nx++;
	for(int i=1;i<=c;i++){//尝试填颜色 i
		bool f=1;
		for(int j=1;j<x;j++){
			for(int k=1;k<y;k++){
				if(a[j][k]==a[j][y]&&a[j][y]==a[x][k]&&a[x][k]==i)f=0;
			}
		}
		if(f){
			a[x][y]=i;
			dfs(nx,ny);
			a[x][y]=0;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	srand(time(0));
	cin>>n>>m>>c;
	dfs(1,1);
	return 0;
}
```

可以看到，它跑 $n=m=8$ 都费劲，花了 `92s`。（一两秒是手动输入的误差）

![](https://cdn.luogu.com.cn/upload/image_hosting/s15hq6f5.png)

### 以下优化基于 $c=3$

### 第一次优化

可以随机化，随机先放哪个数。  
修改后代码如下。（就是 cff 的打表代码）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c;
int a[15][15];
void dfs(int x,int y){
	if(x==n+1){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<a[i][j]<<" ";
			}cout<<endl;
		}
		exit(0);
	}
	int nx=x,ny=y+1;if(ny>m)ny=1,nx++;
	int r=rand();
	for(int i=r;i<=c+r;i++){//尝试填颜色 i%c+1
		bool f=1;
		for(int j=1;j<x;j++){
			for(int k=1;k<y;k++){
				if(a[j][k]==a[j][y]&&a[j][y]==a[x][k]&&a[x][k]==i%c+1)f=0;
			}
		}
		if(f){
			a[x][y]=i%c+1;
			dfs(nx,ny);
			a[x][y]=0;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	srand(time(0));
	cin>>n>>m>>c;
	dfs(1,1);
	return 0;
}
```

由于随机化，它平均在 `1s` 内可以跑出 $n=m=8$，平均
`5s` 可以跑出 $n=9,m=8$。

还可以更好吗？

### 第二次优化

我们设计一个估价函数，关于当前（可能）填哪个更优。

一个显然的想法是每次选择已填次数最少的数。

比如以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c;
int a[15][15];
int sum[4];
void dfs(int x,int y){
	if(x==n+1){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<a[i][j]<<",";
			}cout<<endl;
		}
		exit(0);
	}
	int nx=x,ny=y+1;if(ny>m)ny=1,nx++;
	int r=2;//注意这些取值 
	if(sum[1]<=sum[2]&&sum[1]<=sum[3])r=3;
	else if(sum[2]<=sum[1]&&sum[2]<=sum[3])r=1;
	for(int i=r;i<=c+r;i++){//尝试填颜色 i%c+1
		bool f=1;
		for(int j=1;j<x;j++){
			for(int k=1;k<y;k++){
				if(a[j][k]==a[j][y]&&a[j][y]==a[x][k]&&a[x][k]==i%c+1)f=0;
			}
		}
		if(f){
			sum[i%c+1]++;
			a[x][y]=i%c+1;
			dfs(nx,ny);
			a[x][y]=0;
			sum[i%c+1]--;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m>>c;
	dfs(1,1);
	return 0;
}
```

（有趣的是，$n>m$ 时它很优秀，$n<m$ 时很烂，后面的似乎也是，知道原因的告诉我一下）

可以看到，它已经能完爆 $n=9,m=8$ 的数据，但更大的数据一筹莫展。

再改进一下，把“已填个数最小”改为“已填的数的 $(n-x_0)\cdot(m-y_0)$ 和最小”，又能大幅优化，可以秒杀 $n=m=9$。

但是，我们的常数仍很大，能优化常数吗？

### 第三次优化

我们发现，$c$ 很小。所以考虑每次查找合法时只查找同等颜色的格子。

这样，对于格子颜色为特定值时，就只有两种结果：

1. 这个格子的颜色是这个值，记为 $1$。
2. 这个格子的颜色不是，或者这个格子未填。记为 $0$。

容易发现每搜一格，只有一个的状态变化（从 $0$ 变 $1$），而且对于特定颜色，特定行列，只有 $0/1$ 两个状态。所以考虑**位压**。

考虑 $n,m$ 很小，不妨自己手写 `bitset`。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

int a,b,c;

int lg[8200];
int lg2[20];

void init()
{
	lg[0]=-1;
	for(int i=0;i<=12;i++)lg[1<<i]=i;//处理对数
	for(int n=0;n<=12;n++)lg2[n]=(~((1<<(n+1))-1));//应该叫 mask 更好
}

struct short_rar
{
	int rar;
	inline bool operator [](int n)
	{
		return (rar>>n)&1;
	}
	inline void flip(int n)
	{
		rar^=(1<<n);
	}
	inline void find_first(int &x)
	{
		x=lg[rar&(-rar)];//找第一个 1，基于 lowbit
	}
	inline void find_next(int &n)
	{
		n=lg[rar&lg2[n]&(-(rar&lg2[n]))];//找下一个 1，基于 lowbit
	}
};//手写 bitset

short_rar countr[4][11];
short_rar countc[4][11];
int s[4];

void print()
{
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=b;j++)
		{
			for(int x=1;x<=3;x++)if(countr[x][i][j])cout<<x<<' ';
		}
		cout<<'\n';
	}
	cerr<<"Success\n";
	exit(0);
}

void dfs(int x,int y)
{
	//cout<<x<<' '<<y<<'\n';
	if(x>a)print();//冷代码优化
	int i=3;
	if(s[1]<=s[2]&&s[1]<=s[3])i=1;
	else if(s[2]<=s[1]&&s[2]<=s[3])i=2;//选择（估价上）最容易的开始搜索
	int xx=i,xxx;
	do{
		for(countc[i][y].find_first(xxx);~xxx;countc[i][y].find_next(xxx))
        if(countr[i][xxx].rar&countr[i][x].rar)goto t1;//核心部分，对于每一个在第 y 列有 i 的行，判断有没有其他行和本行重复
		s[i]+=(a-x)*(b-y);
		countr[i][x].flip(y);
		countc[i][y].flip(x);
		dfs(y==b?x+1:x,y==b?1:y+1);
		countr[i][x].flip(y);
		countc[i][y].flip(x);
		s[i]-=(a-x)*(b-y);
		t1:;
		i=(i%3+1);//理论可以优化成找下一个最优，我没写
	}while(xx!=i);
}

int aa[11][11];

void dfs2(int x,int y){//此处使用cff_0102的题解代码 
	if(x==a+1){
		for(int i=1;i<=a;i++){
			for(int j=1;j<=b;j++){
				cout<<aa[i][j]<<" ";
			}cout<<endl;
		}
		exit(0);
	}
	int nx=x,ny=y+1;if(ny>b)ny=1,nx++;
	for(int i=1;i<=c;i++){//尝试填颜色 i
		bool f=1;
		for(int j=1;j<x;j++){
			for(int k=1;k<y;k++){
				if(aa[j][k]==aa[j][y]&&aa[j][y]==aa[x][k]&&aa[x][k]==i)f=0;
			}
		}
		if(f){
			aa[x][y]=i;
			dfs2(nx,ny);
			aa[x][y]=0;
		}
	}
}

signed main()
{
	init();
	//freopen("9767ans.txt","w",stdout);
	a=10,b=9,c=3;cin>>a>>b>>c;
	if(c==3)dfs(1,1);
	else dfs2(1,1);
	return 0;
}
```

这个程序可以在 `30s` 内完成 $n=10,m=9$，在 $5\times10^4$ 秒内完成 $n=10,m=10$。（已经很强了）

得到 $n=m=10$ 的答案后直接打表即可通过。

## 解法 2

从提交记录拿来的，大概讲一下原理。

```cpp
#include <cmath>
#include <functional>
#include <fstream>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <list>
#include <time.h>
#include <math.h>
#include <random>
#include <deque>
#include <queue>
#include <cassert>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <bitset>
#include <sstream>
#include <chrono>
#include <cstring>

using namespace std;

typedef long long ll;

mt19937 rnd(228);//玄学参数

int cnt[10][10][3];
int a[10][10];

int main() {
#ifdef iq
  freopen("a.in", "r", stdin);
#endif
  ios::sync_with_stdio(0);
  cin.tie(0);
  int n, m, c;
  cin >> n >> m >> c;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      a[i][j] = rnd() % c;
    }
  }
  auto cost = [&] () {
    for (int i = 0; i < m; i++) for (int j = 0; j < m ;j++) cnt[i][j][0] = cnt[i][j][1] = cnt[i][j][2] = 0;
    int sum = 0;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        for (int k = j + 1; k < m; k++) {
          if (a[i][j] == a[i][k]) {
            sum += cnt[j][k][a[i][j]];
            cnt[j][k][a[i][j]]++;
          }
        }
      }
    }
    return sum;
  };//有几对不符合要求
  while (true) {
    int me = cost();
    for (int it = 0; it < n * m; it++) {//限定一个次数
      for (int i = 0; i < n; i++) {
        for (int j= 0; j < m; j++) {
          int was = a[i][j];
          a[i][j] = rnd() % c;
          int go = cost();
          if (go < me) {
            me = go;
          } else if (go > me) {
            a[i][j] = was;
          }
        }
      }//调整每一个格子，使得尽可能符合要求
    }
    if (!me) {
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
          cout << a[i][j] + 1 << ' ';
        }
        cout << '\n';
      }
      return 0;
    } else {
      for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) a[i][j] = rnd() % c;//废了，重开
    }
  }
}
```

---


# [HUSTFC 2023] 简单的加法乘法计算题

## 题目描述

JokerShaco 有一个数字 $x$，最开始 $x=0$，他想要把 $x$ 变成 $y$。为了达到这个目标，他可以利用两个集合 $A$ 和 $B$。其中集合 $A$ 包含 $n$ 个元素，分别是从 $1$ 到 $n$ 的所有正整数；集合 $B$ 包含 $m$ 个元素。每次它可以对 $x$ 进行如下任意次操作：
- 选择 $A$ 中的一个元素 $a$，令 $x$ 加上 $a$。
- 选择 $B$ 中的一个元素 $b$，令 $x$ 乘以 $b$。

已知 $y$，$n$，$m$ 和 $B$ 中 $m$ 个元素的具体值，JokerShaco 想知道让 $x$ 变成 $y$ 的最少操作次数。

## 样例 #1

### 输入

```
10 3 1
2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
100 6 3
2 3 5
```

### 输出

```
3
```

# 题解

## 作者：hytallenxu (赞：8)

## 题目简述
给定 $2$ 种操作，询问使得 $0$ 变到 $y$ 的最小操作次数。

## 思路
首先考虑搜索或动态规划。

搜索就不多说了，开了个记忆化结果超时了。

考虑动态规划。

转移方程： 

$dp_i=\min(dp_{i-j}+1, dp_i)$，其中 $j \le n$。

$dp_i=\min(f_i,f_{i/b_{j}}+1, dp_i)$，其中 $j \le m$，且 $i\bmod b_j =0$。

对于 $i \le y$，我们不难写出以下的核心代码：

```cpp
for(int j=2;j<=n;j++){
	f[i]=min(f[i],f[i-j]+1); //No.1
} 
			
for(int j=1;j<=m;j++){
	if(i%b[j]==0) f[i]=min(f[i],f[i/b[j]]+1); //No.2
}
```

时间复杂度 $O(n^2)$，炸了。

当然，这道题肯定没有这么简单就直接使用裸的动规完成，于是考虑优化。

考虑复杂度瓶颈在第一标志处，可以使用[单调队列](https://www.luogu.com.cn/problem/P1886)解决，最终时间复杂度 $O(y \times (\log n+ m))$，可以通过此题。

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;
int y,n,m;
int b[20];
int f[5000010];
map<int,int> pa;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int main(){
	y=read(),n=read(),m=read();
	for(int i=1;i<=m;i++) b[i]=read();
	if(n>=y){
		cout<<1<<endl;
		return 0;
	}
	for(int i=1;i<=y;i++){
		if(i<=n){
			f[i]=1;
			pa[1]++;
		}else if(i>=n+1){
			auto top=pa.begin();
			while(top->second==0) top++;
			int maxi=top->first;
			f[i]=maxi+1;
			pa[f[i-n]]--;
			if(pa[f[i-n]]==0){
				auto del=pa.find(f[i-n]);
				pa.erase(del);
			}
			
			
			for(int j=1;j<=m;j++){
				if(i%b[j]==0) f[i]=min(f[i],f[i/b[j]]+1);
			}
			pa[f[i]]++;
		}
	}
	cout<<f[y]<<endl;
	return 0;
}
```

## 最后
给出一组调试数据：

```
In:
2597207 753700 8
64 80 61 706 221 408 612 566 

Out:
3
```


---

## 作者：XiaoMo247 (赞：4)

## 知识点：动态规划，单调队列
- **思路**

  看到**两次不同的操作**和最后求**最小操作次数**以及**数据范围**想到使用**动态规划**。

  考虑 $dp[i]$ 表示让 $x$ 变成 $i$ 的最小操作次数，答案为 $dp[y]$。
  
  那么状态转移方程：
  
  $dp[i] = \min_{}(dp[i],dp[j]+1,dp[k]+1)$，$j ∈ [i-n,i-1]$。
  
  当 $b \mid i$ 时，有 $k = \frac{i}{b}$。
  
  $dp[j]$ 是用**第一种操作**后转移到 $dp[i]$。

  $dp[k]$ 是用**第二种操作**后转移到 $dp[i]$。
  
  我们发现 $\min(dp[j])$ 为**区间 $[i-n,i-1]$ 最小值**，考虑使用**单调队列**，求**滑动窗口**的最小值。
  
  因为 $m \le 10$ 所以可以直接暴力求 $\min(dp[k])$。
  
  **初始化：** 因为起初 $x = 0$，不管怎么执行操作 $2$，$x$ 的值都不会变化，所以**只能执行操作** $1$，初始化 $dp[i] = 1$，$i∈[1,n]$。
  
  之后跟着以上思路线性 DP 就可以了，**时间复杂度 $O(y \times m)$**。
  
  
AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXN = 5e6+5;
const ll INF = 0x3f3f3f3f;
ll y, n, m, dp[MAXN], a[15];
ll q[MAXN], tail, head, p[MAXN];
int main()
{
	ios::sync_with_stdio(false);
	cin >> y >> n >> m;
	for(int i = 1; i <= y; i ++) dp[i] = INF;//先初始所有值为 INF 
	for(int i = 1; i <= m; i ++) cin >> a[i]; 
	head = 1;tail = 0;
	for(int i = 1; i <= n; i ++)
	{
		dp[i] = 1;//初始 [1,n] 的值为 1 
		while(head <= tail && q[tail] >= dp[i]) tail--;
		q[++ tail] = dp[i];
		p[tail] = i;
		while(p[head] <= i - n) head ++;//单调队列处理滑动窗口最小值 
	}
	for(int i = n + 1; i <= y; i ++)
	{
		dp[i] = q[head] + 1;//令 dp[i] 为 [i - n, i - 1] 的最小值 
		for(int j = 1; j <= m; j ++)
		{
			if(i % a[j] == 0) dp[i] = min(dp[i], dp[i / a[j]] + 1);//状态转移 
		}
		while(head <= tail && q[tail] >= dp[i]) tail--;
		q[++ tail] = dp[i];
		p[tail] = i;
		while(p[head] <= i - n) head ++;
	}
	cout << dp[y] << endl;
	return 0;
}
```


---

## 作者：_Logic_ (赞：2)

# 洛谷P9769
## 单调队列优化dp

 十分激动，蒟蒻第一次写题解，献丑了...

~~PS：这就是新生赛吗555~~

最开始想搜索，但发现不能在每一步随意选择加还是乘。 

于是想 dp。大致想法如下：

$i$ 从 $1$ 枚举到 $y$，$dp[i]$ 表示从 $0$ 变到 $i$ 的最少步数。只考虑一步的情况，很显然，从一个比 $i$ 小的数变到 $i$，只能是在 $i$ 左边大小为 $n$ 的区间里面的某个数加上 $i$（选 $A$ 集合），或者在 $i$ 的因数中选一个乘 $b_j$ 等于 $i$ 的（选 $B$ 集合），然后在这两个选择中选小的那个。

对于选 $A$，如果对所有 $i$ 直接遍历左边全部区间取最小值，明显会超时。转念一想，要调用固定区间的最小值，这不就是滑窗板子吗？直接开始单调队列，美滋滋~~

对于选 $B$，由于 $m$ 数据规模很小，直接遍历所有的元素，$O(ym)$ 不会超时。可以直接遍历 $B$ 集合全部元素选最小值。
注意, 这里有个坑，$B$ 集合中可能有 $1$，要排除掉。

放 code：


------------

```cpp
#include <bits/stdc++.h>
using namespace std;

const int S = 5e6 + 5;
int dp[S];
int b[15];
int y, n, m;
deque<int>q;

int main(){
    scanf("%d%d%d", &y, &n, &m);
    for(int i = 1; i <= m; i++)
        scanf("%d", &b[i]);
    if(y <= n){ //特判, y <= n 选 A 集合一步到位
        printf("1");
        return 0;
    }
    dp[0] = 0; //初始化, y=0 一步都不需要
    q.push_back(0);
    for(int i = 1; i <= y; i++){
        if(!q.empty() && q.front() < i - n) //如果最小值不在区间范围, 丢弃
            q.pop_front();
        int x1 = dp[q.front()] + 1;
        int x2 = 0x7f7fffff;       //x1 表示选 A 集合获得的最小值, x2 表示选B集合获得的最小值
        for(int j = 1; j <= m; j++)
            if(i % b[j] == 0 && b[j] != 1) //b[j] 等于 1 会寄
                if(x2 > dp[i / b[j]])
                    x2 = dp[i / b[j]];
        x2++;
        dp[i] = x1 > x2 ? x2 : x1; //再选取 x1, x2 中小的那个
        while(!q.empty() && dp[q.back()] > dp[i])
            q.pop_back(); //维护单调性, 吐出所有比 dp[i] 小的 i
        q.push_back(i); //进入队列, 成为最大的那个
    }
    printf("%d", dp[y]); //输出
}
```


------------

希望各位大犇指出不足，多多包涵~

---

## 作者：sky_chen (赞：1)

【HUSTACM】此题解为官方题解。

设 $f_i$ 表示从 $1$ 到 $i$ 的最少操作次数。由于乘法操作的集合很小，可以直接暴力枚举转移；而加法操作只能从 $f_j,j\in [i-n,i-1]$ 转移，显然维护这段区间的最小值即可，但由于 $n$ 较大，不能使用一般的数据结构维护，不难发现使用单调队列优化 DP 即可。

时间复杂度 $O(ym)$。

---

## 作者：bochibochi (赞：0)

令 $f_y$ 表示将数变成 $y$ 的最小操作次数，不难得出以下两种转移方程

$$f_i=\min_{1\le j\le n}\{f_{i-j}+1\}$$
$$f_i=\min_{1\le j\le m,b_j\mid i}\{f_{i/b_j}+1\}$$

其中第一种转移直接做复杂度是 $\mathcal O(y\times n)$ 的，可以用单调队列优化，每次相当于求一个滑动窗口内的最小值。

由于 $m\le10$，第二种转移可以暴力做。

总时间复杂度为 $\mathcal O(y\times m)$。

---

## 作者：Allenyou1126 (赞：0)

首先观察题意，可以发现 $x$ 从 $0$ 到 $a$ 中间具体取法并不会影响后面的步骤，满足 DP 无后效性，考虑 DP。

可以定义 $dp_i$ 为 $x$ 从 $0$ 到 $i$ 的最小步数，目标状态为 $dp_y$。

然后就可以推出两种状态转移：

1. 选择 A 中元素转移，$dp_i = \min_{k=1}^{n}\{dp_{i - k}\} + 1$。
2. 选择 B 中元素转移，$dp_i = \min_{k=1}^{m}\{dp_{i / B_k}\} + 1$。

但数据范围 $1 \le n, y \le 5 \times 10 ^ 6$，暴力枚举复杂度 $O(ny + ym)$ 显然会 TLE。

这时候发现 1 中 $dp_i$ 只与 $dp_{i-1}$ 到 $dp_{i - n}$ 中最小值有关，显然可以用单调队列优化，因为 $1 \le m \le 10$ 所以暴力枚举 B 中元素没问题，复杂度为 $O(y)$，能够 AC。

AC 代码如下：

```cpp
#include <cstdio>
#include <queue>

using namespace std;
inline int rd() {
    int ret = 0, flag = 1;
    char c = getchar();
    for (; c > '9' || c < '0'; c = getchar())
        if (c == '-')
            flag = -1;
    for (; c >= '0' && c <= '9'; c = getchar())
        ret = ret * 10 + (c - '0');
    return ret * flag;
}
const int MAXY = 5e6 + 10;
int B[11];
int dp[MAXY];
int main() {
    int y = rd();
    int n = rd();
    int m = rd();
    for (int i = 1; i <= m; ++i) {
        B[i] = rd();
    }
    deque<int> q;
    q.push_back(0);
    for (int i = 1; i <= y; ++i) {
    	// 单调队列
        while (!q.empty() && i - q.front() > n) {
            q.pop_front();
        }
        dp[i] = dp[q.front()] + 1;
        // 枚举B中元素转移
        for (int j = 1; j <= m; ++j) {
            if (i % B[j] != 0) {
                continue;
            }
            dp[i] = min(dp[i], dp[i / B[j]] + 1);
        }
        // 单调队列
        while (!q.empty() && dp[q.back()] >= dp[i]) {
            q.pop_back();
        }
        q.push_back(i);
    }
    printf("%d\n", dp[y]);
    return 0;
}
```

---

## 作者：Controls_Wish (赞：0)

### 思路：

考虑动态规划，设 $dp_i$ 为合出 $i$ 的最小次数，显然有加和乘两种凑数方式，所以转移为：

$$dp_i=\min(\min^{j \leq i-1}_{j=i-n}dp_j,\min^{j \leq m}_{j=1}dp_{i/b_j}(b_j|i))+1$$

由于 $m \leq 10$，所以后面的部分可以直接暴力求，前面的部分显然是一个长度为 $n$ 的固定大小区间最小值，可以用单调队列维护，注意单调队列最开始要把 $dp_0$ 放进去。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 5000005
int dp[N];
deque<int>q;
int b[15];
int main(){
    int y,n,m;
    scanf("%d%d%d",&y,&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d",&b[i]);
    q.push_back(0);
    for(int i=1;i<=y;i++){
        dp[i]=0x3f3f3f3f;
        for(int j=1;j<=m;j++)
            if(i%b[j]==0)dp[i]=min(dp[i],dp[i/b[j]]+1);
        dp[i]=min(dp[i],dp[q.front()]+1);
        while(!q.empty()&&dp[q.back()]>dp[i])q.pop_back();
        q.push_back(i);
        if(q.front()<=i-n)q.pop_front();
    }
    printf("%d",dp[y]);
    return 0;
}
```


---

## 作者：Little_RMQ (赞：0)

简单题，首先考虑朴素DP。

考虑使用操作一，则 $f_i=\min_{i-n}^{i-1}f_j+1$。

考虑使用操作二，则当 $p_j|i$ 时， $f_i=\min f_{i/{p_j}}+1$。

复杂度为 $O(y(n+m))$ 无法通过此题。

注意到复杂度瓶颈是操作一每次要对前 $n$ 个数取最小值，于是可以用单调队列优化 DP。

```cpp
#include"bits/stdc++.h"
#define int long long
#define ll long long
#define ull unsigned long long
#define pb push_back
#define pii pair<int,int>
#define fir first
#define sec second
#define bp __builtin_popcount
using namespace std;
ll read() {
	ll x = 0, fff = 1;
	char c;
	while ((c = getchar()) < '0' || c > '9')
		if (c == '-')
			fff = -1;
	while (c >= '0' && c <= '9')
		x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	return x * fff;
}
const double eps = 1e-6;
const int N = 5e6 + 5;
const int M = 10;
const int V = N - 5;
const int mod = 1e9 + 7;
const int bse = 1e9 + 7;
const int inf = 1e18;
const double pi = acos(-1);
int y, n, m;
int p[N];
int f[N];
deque<int>q;
signed main() {
	y = read(), n = read(), m = read();
	for(int i = 1; i <= m; i++) p[i] = read();
	for(int i = 1; i <= n; i++) f[i] = 1, q.pb(i);
	for(int i = n + 1; i <= y; i++) {
		f[i] = f[q.front()] + 1;
		for(int j = 1; j <= m; j++) if(i % p[j] == 0) f[i] = min(f[i], f[i / p[j]] + 1);
		while(!q.empty() && f[i] <= f[q.back()]) q.pop_back();
		q.pb(i);
		while(i - n >= q.front()) q.pop_front();
	}
	printf("%lld\n", f[y]);
	return 0;
}
/*

*/
```

---


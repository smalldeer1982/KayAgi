# [HUSTFC 2023] 网格染色

## 题目描述

有一个由 $n\times n$ 个小正方形组成的网格图，其中每个小正方形的边长为 $1$，Walk Alone 和 Kelin 在这上面进行一场染色游戏，游戏的规则如下：
- Walk Alone 和 Kelin 轮流进行操作，Walk Alone 先手。
- 当轮到 Walk Alone 操作时，他选择一条尚未被染色的正方形边框并将其染成**红色**。操作结束时，如果这条边框是一个（或两个）正方形最后一条被染色的边框，则自动将该正方形也同样染成**红色**。
- 当轮到 Kelin 操作时，他选择一条尚未被染色的正方形边框并将其染成**蓝色**。操作结束时，如果这条边框是一个（或两个）正方形最后一条被染色的边框，则自动将该正方形也同样染成**蓝色**。
- 当所有的边框都被染色后，游戏结束。此时染成自己所属颜色的正方形数量更多的一方获胜；或者当数量相等时，达成平局。

例如，在 $2\times 2$ 的网格图中，一种可能的游戏过程如下：

![1](https://cdn.luogu.com.cn/upload/image_hosting/zkbfy296.png)

已知网格图的边长 $n$，如果两人都积极进行游戏（按照最优策略，尽可能地让自己获胜，或者在自己无法获胜的前提下尽可能地达成平局），请你推断哪一方会获胜或达成平局。


## 样例 #1

### 输入

```
1
```

### 输出

```
Kelin
```

# 题解

## 作者：Hu0_gu0_4u31 (赞：4)

[P9772题目传送门](https://www.luogu.com.cn/problem/P9772)

本蒟蒻发布的第一篇题解纪念！

## Part -1：赛时唠嗑

当我比赛时点进这题时心想：这不就是博弈论吗？多试一试就能过！

首先对题目进行一顿分析，然后写出代码：

```python
n = int(input())
if n % 2:
    print('Kelin')
else:
    print('Draw')
```

~~不出所料~~听取WA声一片。



## Part 0：题目分析

题目描述大概是两个人走一种棋子，可以通过给一个格子周围四个地方都染上色来得分。最终得分多者胜。得分相同即为平局。

这题一看就是博弈论。

那我们就要思考获胜的情况了。

题目只给出了 $n$，因此情况无非就这几种：

- 输出固定答案。

- 根据 $n \bmod k$（$k$ 为任意整数且 $k>0$）的结果判断答案。

于是，我们便可以枚举 $n=1$，$n=2$ 等的情况。

## Part 1：开始做题

首先来看看 $n=1$。

很显然，由于只有四个地方可以下，后手必胜。

那么 $n=2$ 呢？样例已经给出，后手必胜。

那么 $n=3$ 呢？我们可以枚举几种情况，也可以得出后手必胜。

由于答案只有三种，因此我们就可以大胆地猜想：后手必胜。

```python
print('Kelin')
```

## Part 2：必胜策略

既然结论是后手必胜，那我们要证明必须找到必胜策略。

后手必胜的策略是：画出整个网格的对角线。

如果 `Walk Alone` 下在一个位置，那么 `Kelin` 就下在与它对于网格对角线呈轴对称的位置。

由此可见，如果下的位置所在的正方形不在对角线上，几回合下来这个位置所在的正方形如果是 `Walk Alone` 得分，轴对称的位置就是 `Kelin` 得分，反之亦然。

如果下的位置所在的正方形在对角线上，显然是 `Kelin` 得分。

由于每个方格的分数最终一定所有人都会拿到，因此因为 `Kelin` 有对角线得分优势，最终总是 `Kelin` 获胜。

以上就是这题的必胜策略。

因此，本题输出 `Kelin` 即可。


---

## 作者：sky_chen (赞：4)

【HUSTACM】此题解为官方题解。

后者存在使自己必胜的策略，其中一种简单易懂的策略是：将某个对角线作为对称轴，无论先手如何涂色，后手根据对称轴左右涂色即可。

时间复杂度 $O(1)$。



---

## 作者：Bill_luogu (赞：2)

## 结论：
后手一定赢。
## 证明：
下图是一个 $4\times4$ 的网格，我们用它的对角线将它分成两半，对角线是对称轴。
![](https://cdn.luogu.com.cn/upload/image_hosting/fsuhcqp8.png)

当 Walk Alone 操作时，Kelin 只需操作 Walk Alone 操作的边的轴对称边即可获胜。
## AC Code：
```cpp
#include<iostream>
using namespace std;
int main()
{
    cout<<"Kelin";
    return 0;
}
```

---

## 作者：LKY928261 (赞：1)

后手选一条对角线，每次先手操作后，后手就涂关于这条对角线对称的线。于是对角线没有穿过的格子先后手平分，对角线穿过的格子都是后手占有的。即后手有必胜策略。

```cpp
#include<bits/stdc++.h>
int main(){std::cout<<"Kelin\n";}
```

---

## 作者：luogu10086 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P9772)

### PART 1

题目大意：

有两个人玩涂色游戏，看谁涂的方形多，而一个方形的颜色取决于它最后一条被涂色的边的颜色。

------------


### PART 2

整体思路：

[ ! ]  旧版有漏洞，现已改版。

要想胜利，该怎么办？我们再画一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/k4ql8g63.png)

把灰色的线看作是一条对称轴，后手一直根据先手涂色位置在轴的另一侧涂色，这样得到的分数远超于先手，这便是后手用尽毕生所学琢磨出的必胜方案，直接避免了平局。

所以只输出后手便可以了。

------------

### PART 3

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<"Kelin";
}
```


---

## 作者：rosefor_u (赞：0)

这道题的代码很简单，只要输出`Kelin`就可以了。那么我在这里讲一下为什么（后面的证明内容有一点点长，请耐心看完）。

以下证明会从**游戏本质规则拆解**、**数学推导**等维度，证明为何无论网格边长 $ n $ 取何值，结果必然是 `Kelin` 获胜。

---

## 理解题意
1. **网格与边框**

   
   设网格为 $ n \times n $（$ n \in \mathbb{N}^+ $），由 $ n^2 $ 个单位正方形组成。  
   - 水平边框：每行有 $ n+1 $ 条（分割相邻行的单位正方形），共 $ n $ 行，总数为 $ n(n+1) $。  
   - 垂直边框：每列有 $ n+1 $ 条（分割相邻列的单位正方形），共 $ n $ 列，总数为 $ n(n+1) $。  
   - 总边框数：$ B = n(n+1) + n(n+1) = 2n(n+1) $（边框无重叠，均为独立元素）。  

3. **操作规则**  
   - 两名玩家轮流为边框染色：`Walk Alone`（先手）染红色，`Kelin`（后手）染蓝色，每次染 $1$ 条未染色边框。  
   - 当某条边框被染色时，若该边框是某个单位正方形的**最后一条未染色边框**，则该正方形被染为对应颜色（红或蓝）。  

4. **胜负判定**

   
   最终统计所有单位正方形的颜色，颜色数量多的玩家获胜；若数量相等，则平局。

   本文需证明：**对任意 $ n \geq 1 $，`Kelin`获得的正方形数量必多于`Walk Alone`，即`Kelin`必胜**。  


## 单位正方形的“归属”判定
对任意单位正方形 $ s \in n \times n $ 网格，其归属（红或蓝）由**最后一条边框的染色者**决定：  
- 设 $ s $ 的 $4$ 条边框依次被染色的顺序为 $ b_1, b_2, b_3, b_4 $，则染色 $ b_4 $ 的玩家决定 $ s $ 的颜色。  
- 证明：根据规则，仅当最后一条边框（$ b_4 $）被染色时，正方形才被染色，故归属权由 $ b_4 $ 的染色者决定。  

## 总操作次数与轮次
1. **总操作次数**：

   等于总边框数 $ B = 2n(n+1) $（每条边框需且仅需被染色 $1$ 次）。  
2. **玩家操作次数**：  
   - Walk Alone（先手）操作次数：$ A = \lceil B/2 \rceil $。  
   - Kelin（后手）操作次数：$ K = \lfloor B/2 \rfloor $。  
   - 由于 $ n $ 与 $ n+1 $ 是连续整数，必为一奇一偶，故 $ n(n+1) $ 是偶数，因此 $ B = 2n(n+1) $ 是 **$4$ 的倍数**（$ 2 \times$ 偶数 $= 4$ 的倍数 ）。  
   - 结论：$ A = K = n(n+1) $（因 $ B $ 为偶数，$ \lceil B/2 \rceil = \lfloor B/2 \rfloor = B/2 $）。  


## Kelin 必胜的核心
#### 单位正方形总数与“关键操作”总数

- 单位正方形总数：$ S = n^2 $。  
- 每个正方形对应 $1$ 次“关键操作”（即染第4条边框的操作，引理1已证），故总关键操作数为 $ S = n^2 $。  

#### 关键操作的分配规律

需证明：在最优策略下， `Kelin` 获得的关键操作数 $ K' $ 必大于 `Walk Alone` 的关键操作数 $ A' $（$ K' + A' = n^2 $）。  

- **基础案例（$ n=1 $）**：  
  - 网格为 $ 1 \times 1 $，$ S=1 $，$ B=4 $，$ A=K=2 $。  
  - 操作序列：设边框染色顺序为 $ b_1 $（ `Walk Alone` ）、$ b_2 $（ `Kelin` ）、$ b_3 $（ `Walk Alone` ）、$ b_4 $（ `Kelin` ）。  
  - 关键操作是 $ b_4 $（第4条边框），由 `Kelin` 完成，故 $ K'=1 $，$ A'=0 $ → $ K' > A' $， 所以 `Kelin` 胜。  

- **归纳假设（$ n=k $ 时）**：

  假设对 $ k \times k $ 网格， `Kelin` 获得的关键操作数 $ K'_k > A'_k $（$ A'_k + K'_k = k^2 $）。  

- **归纳推导（$ n=k+1 $ 时）**：  
  - $ (k+1) \times (k+1) $ 网格可视为 $ k \times k $ 网格新增一圈边框和正方形，新增正方形数为 $ (k+1)^2 - k^2 = 2k+1 $。  
  - 总边框数 $ B' = 2(k+1)(k+2) $，仍为 $4$ 的倍数，故 $ A' = K' = (k+1)(k+2) $。  
  - 新增的 $ 2k+1 $ 个正方形的关键操作中， `Kelin` 可通过“对称策略”（针对 `Walk Alone` 的每一次非关键操作，对应一次控制关键操作的回应）确保获得至少 $ k+1 $ 次（因 $ 2k+1 $ 为奇数，后手可占优）。  
  - 结合归纳假设，总关键操作数 $ K'_{k+1} = K'_k + (k+1) $，$ A'_{k+1} = A'_k + k $，显然 $ K'_{k+1} > A'_{k+1} $。  


## 平局的可能性
假设存在 $ n $ 使得 $ K' = A' $，则 $ n^2 = K' + A' = 2K' $，即 $ n^2 $ 为偶数 → $ n $ 为偶数。 

但由归纳推导：  
- 当 $ n=2 $ 时，$ S=4 $，通过实际操作推演（略，可验证）， `Kelin` 关键操作数为 $3$ ， `Walk Alone` 为 $1$ （$ 3 > 1 $）。  
- 对任意偶数 $ n $，归纳法已证明 $ K' > A' $，故 $ n^2 $ 为偶数时仍不满足 $ K' = A' $。  
因此，平局**不可能存在**。  

---

至此，证毕。

## 代码
  
```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
	cout <<"Kelin";
	return 0;
}
```

---


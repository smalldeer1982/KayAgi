# [ROIR 2020] 超速 (Day1)

## 题目描述

**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T2.** ***[Превышение скорости](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)*** ，译者 ShineEternal

超速行驶是一种危险的犯法行为，大大增加了交通事故导致悲惨后果的可能性。不幸的是使用使用雷达和相机控制速度并不能完全解决问题。为了防止这种行为的出现，根据汽车在一段道路上的行驶时间来罚款，可以对超速行为进行限制。

现在有 $n$ 段从 $1\sim n$ 编号的公路。第 $i$ 段公路长 $l_i$ 米，其限速为 $v_i$ 米每秒。超速就要罚款，但是为了体现按劳分配，还要对不同程度的超速设置不同的罚款金额。

具体来说，如果不超速则不收罚款；否则，用 $e$ 表示汽车在这段公路上的**最大速度减去限速**的值：

- 如果 $0<e\leq a_1$，则惩罚为 $f_1$ 个货币单位。

- 如果 $a_1<e\leq a_2$，则惩罚为 $f_2$ 个货币单位。

- ...

- 如果 $a_{m-2}<e\leq a_{m-1}$，则惩罚为 $f_{m-1}$ 个货币单位。

- 如果 $a_{m-1}<e$，则惩罚为 $f_m$ 个货币单位。

目前，有 $q$ 辆车要经过这 $n$ 段道路，每辆车在 $s_i$ 时间到达 $1$ 号路段，在 $t_i$ 时间离开 $n$ 号路段。

你需要计算每辆车在**所有路段中最高**被罚款的金额**至少**是多少。

时间从道路开放起计算，即从 $0$ 开始计算。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10$，$1\leq v_i,l_i,a_i,f_i\leq 10^9$，$1\leq m\leq 10^5$，$1\le q\le 10^5$，$1\leq s_i<t_i\leq 10^9$。

|任务编号|特殊限制|分值|
|:-:|:-:|:-:|
|$1$|$n=1,m=1$|$5$|
|$2$|$m=1$|$10$|
|$3$|$n=1,m\leq 10$|$9$|
|$4$|$n=1$|$12$|
|$5$|$m\leq 10,a_i\leq 10$|$13$|
|$6$|$m\leq 10$|$14$|
|$7$|无特殊限制|$37$|

## 样例 #1

### 输入

```
3
10 20 30
400 500 600
6
1 5 10 12 16
100 300 600 800 1000 1500
3
10 100
20 70
45 100```

### 输出

```
0
800
600```

# 题解

## 作者：shinzanmono (赞：5)

想知道每辆车在所有路段中最高被罚款的金额至少是多少，你只需要知道每辆车最大超速是多少。

如果让开车的时间最短，我们就要让罚款物尽其用。具体地讲，如果我们的超速在第 $p$ 档中，就需要将每一段的速度设为 $v_i+a_p$，这样我们计算总时间。

我们要寻找使时间 $\leq t-s$ 的最小超速，这个问题是可以二分的。于是二分解决即可，时间复杂度 $O(qn\log m)$。

具体细节看代码：

```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
const int sz=1e5+10;
int n,m,q;
ll v[15],l[15],a[sz],f[sz];
bool check(ll dv,int lim){
    double tot=0;
    for(int i=1;i<=n;i++)
        tot+=1.*l[i]/(v[i]+dv);
    return tot<=lim;
}
int query(int tot){
    int l=0,r=m-1;
    while(l<r){
        int mid=l+r>>1;
        if(check(a[mid],tot))r=mid;
        else l=mid+1;
    }
    if(!check(a[l],tot))l++;
    return f[l];
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin>>n;
    for(int i=1;i<=n;i++)std::cin>>v[i];
    for(int i=1;i<=n;i++)std::cin>>l[i];
    std::cin>>m;
    for(int i=1;i<m;i++)std::cin>>a[i];
    for(int i=1;i<=m;i++)std::cin>>f[i];
    std::cin>>q;
    while(q--){
        int s,t;
        std::cin>>s>>t;
        std::cout<<query(t-s)<<"\n";
    }
    return 0;
}
```

---

## 作者：zeroflows (赞：5)

# [传送门](https://www.luogu.com.cn/problem/P9784)
### 思路
我们设 $T$ 为所花的总时间，$d$ 为超速多少。  
然后不难知道 $ T = \sum_{i = 1}^{n} \frac{l_i}{v_i+d}$，所以我们实际上是要找到符合条件最小的 $d$。    
再结合题目所说最高被罚款的金额最少，然后二分枚举答案即可。   
时间复杂度 $O(nq\log(m))$。

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
int t0,t1;
int v[15],l[15];
int s[150000],t[150000];
bool check(int x)
{
	double ans=0;
	for(int i=1;i<=n;i++)
		ans+=(1.0*l[i])/(v[i]+x);
	if(ans+t0<=t1)
        return 1;
    return 0;
}
main()
{
	ios::sync_with_stdio(false);
	cin.tie(),cout.tie();
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>v[i];
	for(int i=1;i<=n;i++)
		cin>>l[i];
	cin>>m;
	for(int i=1;i<m;i++)
		cin>>s[i];
	for(int i=1;i<=m;i++)
		cin>>t[i];
	cin>>q;
	while(q--)
	{
		cin>>t0>>t1;
		int l=0,r=m-1;
		while(l<r)
		{
			int mid=(l+r)/2;
			if(check(s[mid]))
				r=mid-1;
			else
				l=mid+1;
		}
		if(!check(s[l]))
			l++;
		cout<<t[l]<<endl;
	}
}
```

---

## 作者：MA_tian (赞：3)

~~这题测试点是真的多~~
# 题目大意
有 $n$ 条道路，第 $i$ 公路长 $l_i$ 米，限速为 $v_i$ 米，超速就要按照给定规则分段罚款，每辆车从 $s_i$ 时刻开始行驶，$v_i$时刻离开公路。求最小的最大罚款金额。
# 思路
最小的最大，一眼二分答案。

不知道二分的建议先搞懂[这题](https://www.luogu.com.cn/problem/P2249)。

这题与二分模版不同的是，你需要先计算经过公路的时间，然后再对罚款范围进行二分。
# 代码
代码中的变量名意义与题目相同。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,s,t,v[100005],l[100005],a[100005],f[100005];
bool check(int p){
	double use=0;//利用double变量保留精度
	for(int i=1;i<=n;i++){
		use+=l[i]/(v[i]+p);
	}
	return use+s<=t;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	for(int i=1;i<=n;i++){
		cin>>l[i];
	}
	cin>>m;
	for(int i=1;i<m;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>f[i];
	}
	cin>>q;
	while(q--){
		int l=0,r=m-1,mid;
		cin>>s>>t;
		while(l<r){
			mid=l+(r-l)/2;
			if(check(a[mid])){
				r=mid;
			}else{
				l=mid+1;
			}
		}
		if(!check(a[l])){
			l++;
		}
		cout<<f[l]<<endl;
	}
	return 0;
}
```
此题完结撒花！

~~夹带点私货~~

满堂花醉三千客，一剑霜寒十四州。

---

## 作者：Infinity_Fantasy (赞：3)

## 思路
 题目求**最高**被罚款的金额**至少**是多少，像这种求最小中最大或最大中最小的是经典的二分，虽然题目中没有写但是应该有惩罚金额是一个单调上升的序列，满足二分的单调性。
## 代码
二分枚举所超速的分段 check 函数判断是否能在时间内通过，根据 a 数组和 f 数组的单调性，二分缩小范围确定答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,s,t,v[15],l[15],a[100005],f[100005];
bool check(int am){
	double sum=0;
	for(int i=1;i<=n;i++) sum+=1.0*l[i]/(v[i]+am);
	return sum+s<=t;
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n;for(int i=1;i<=n;i++)cin>>v[i];for(int i=1;i<=n;i++)cin>>l[i];
	cin>>m;for(int i=1;i<m;i++)cin>>a[i];for(int i=1;i<=m;i++)cin>>f[i];
	cin>>q;
	while(q--){
		int l=0,r=m-1,mid;
		cin>>s>>t;
		while(l<r){
			mid=(l+r)>>1;
			if(check(a[mid])) r=mid;
			else l=mid+1;
		}
		if(!check(a[l])) l++;
		cout<<f[l]<<"\n";
	}
	return 0;
}
```

---

## 作者：M4A4_Howl (赞：3)

## 大意

这道题做法就是一个~~简单~~的二分答案。

给你每辆车在道路上的行驶时间，每段公路的长度，罚款范围，计算每辆车被罚款的最少金额。

## 解法

1. 对于每辆车，根据其到达和离开时间，计算其在每段道路上的速度。

2. 对于每个罚款范围，计算车辆在所有道路上的速度之和。如果速度之和小于等于车辆的行驶时间，说明该罚款范围内的罚款金额是满足条件的。

3. 最后输出答案就可以啦！

## 代码

```cpp
#incIude <bits/stdc++.h>
using namespace std;
int n, m, q, a[11], b[11], c[200005], d[200005];

int main()
{
    cin >> n; // 公路段数
    for (int i = 1; i <= n; i++)
        cin >> a[i]; // 每段公路的限速
    for (int i = 1; i <= n; i++)
        cin >> b[i]; // 每段公路的长度
    cin >> m;        // 罚款的不同范围
    for (int i = 1; i <= m - 1; i++)
        cin >> c[i]; // 每个范围内的速度值
    for (int i = 1; i <= m; i++)
        cin >> d[i]; // 每个范围对应的罚款金额
    cin >> q;        // 车辆数量
    while (q--)
    {
        int x, y;
        cin >> y >> x; // 车辆的到达和离开时间
        x -= y;
        int l = 0, r = m - 1, ans = m;
        while (l <= r)
        {
            int mid = (l + r) >> 1;
            double sum = 0;
            for (int i = 1; i <= n; i++)
                sum += 1.00 * b[i] / (a[i] + c[mid]); // 车辆在每段公路中的速度
            if (sum <= x)
            {
                ans = mid;
                r = mid - 1;
            }
            else
                l = mid + 1;
        }
        cout << d[ans] << endl; // 车辆的最少罚款金额
    }
    return 0;
}
```

---

## 作者：wunaidedanjuan (赞：3)

### 简化题意

有 $n$ 段路，每段路长 $l$，限速 $v$。对不同的超速程度有不同金额的罚款，具体如图示(均为前开后闭)：

![](https://cdn.luogu.com.cn/upload/image_hosting/umxahs0j.png?x-oss-process=image/resize,m_lfit,h_85,w_820)

给你一辆汽车到达第 $1$ 段的时间 $s$，和离开第 $n$ 段路的时间 $t$，求这辆车在经过这 $n$ 段路中最小的最大罚款金额。

### 思路分析

这 $n$ 段路的路程和限速以及车辆通过 $n$ 段路的总时间是一定的，要使整个行驶过程中的最大罚款金额最小，就要使汽车在这 $n$ 段路中速度**超出限速的最大值最小**。

要使最大值最小，且总路程和总时间一定，即平均速度一定，我们可以考虑让汽车**在每段路程超出路程限速的数值相同**，**二分**枚举限速范围，计算所用时间，若所用时间小于等于汽车通过这 $n$ 段路的总时间，则证明汽车整个行驶过程中的最大罚款金额小于等于此时枚举的限速范围所对应的罚款金额；否则则证明大于所对应的罚款金额。

需要注意的是，在计算时间时涉及路程与速度相除，会存在整除产生的误差，所以储存时间的变量应为 `double` 型变量，以此来减小误差。

### 思路总结

- 二分枚举限速范围；

- 计算所用时间；

- 比较所用时间与汽车通过时间大小，若所以时间小于等于汽车通过时间，则继续向前搜，若大于，则向后搜；

- 找到最小的限速范围边界，输出相应的罚款金额；
 
### 代码呈现
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<bitset>
#include<cctype>
#include<cstdlib>
#include<functional>
#include<istream>
#include<sstream>
#define int long long 
using namespace std;
const int N=200000,M=20,inf=0x3f3f3f3ff3f3f3f,mod=pow(2,31);
int v[M],l[M],a[N],f[N]; 
signed main()
{
	int n,m,q,s,t;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)//限速 
		scanf("%lld",&v[i]);
	for(int i=1;i<=n;i++)//距离 
		scanf("%lld",&l[i]);
	scanf("%lld",&m);
	for(int i=1;i<m;i++) 
		scanf("%lld",&a[i]);
	for(int i=1;i<=m;i++)//罚款 
		scanf("%lld",&f[i]);
	scanf("%lld",&q);
	while(q--)
	{
		int ll=0,r=m-1,ans=m,mid;
		double sum;//减小误差 
		scanf("%lld%lld",&s,&t);
		while(ll<=r)
		{
			sum=0;
			mid=(ll+r)>>1;
			for(int i=1;i<=n;i++)//计算所用时间总和
				sum+=l[i]*1.0/(a[mid]+v[i]);
			if(sum<=t-s)//限速大于等于平均速度 
			{
				ans=mid;
				r=mid-1;//向前搜索，看是否有更低的最高罚款 
			}
			else//限速小于平均速度
				ll=mid+1;//向后搜索，寻找大于等于平均速度的限速 
		}
		printf("%lld\n",f[ans]); 
	}
	return 0;
}
```


---

## 作者：Charles_with_wkc (赞：2)

# 思路：
这个题目我们发现罚款金额是一个单调递增的，这样就满足二分的单调性。
# 代码书写：
这里我们首先套一下二分模板，然后稍作变动即可。首先算出车辆在每段公路上的速度，从而算出车辆在所有道路上的速度。然后看是否满足条件，满足则记录下当前答案并继续寻找最优解。这里有一个坑点就是我们在做出发的时候要防止精度丢失所以要 $\times 1.0$。
# 核心代码：
```cpp
bool check(int x){
	double ans=0;
	for(int i=1;i<=n;i++){
		ans+=1.0*l[i]/(v[i]+x);
	}
	return ans+s<=t;
}
while(L<=R){
	mid=(L+R)/2;
  if(check(a[mid])){
    R=mid-1;
  }
  else{
    L=mid+1;
  }
}
if(!check(a[L])){
  L++;	
}
cout<<f[L]<<endl;
```

---

## 作者：Ame_wiki (赞：2)

题目传送门：[link](https://www.luogu.com.cn/problem/P9784)。

思路：一看最大值最小，二分直接秒。二分出在哪个罚款段，因为答案是取最高罚款，所以在每段路都要跑到上限，速度为 $v_i+a_{mid}$ 米每秒。车从 $s$ 时间来到 $t$ 时间去，花费 $t-s$ 时间，只需要将二分出的答案与其比较即可。

~~二分好难调啊。~~

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"

const int N=100005,M=5005,inf=1e18;

int n,m,q,l[N],v[N],a[N],f[N];

int ck(int x,int y){
	double ans=0;
	for(int i=1;i<=n;i++){
		ans+=l[i]*1.0/(x+v[i]);
	}
//	cout<<x<<" "<<y<<": "<<ans<<endl;
	if(ans<=y) return 1;
	else return 0;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>v[i];
	for(int i=1;i<=n;i++) cin>>l[i];
	cin>>m;
	for(int i=1;i<m;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>f[i];
	cin>>q;
	a[m]=inf;
	while(q--){
		int s,t; cin>>s>>t;
		int cha=t-s;
		int ll=0,r=m-1;
		while(ll<r){
			int mid=(ll+r)>>1;
			if(ck(a[mid],cha)) r=mid;
			else ll=mid+1;
		}
		if(!ck(a[ll],cha)) ll++;
		cout<<f[ll]<<endl;
	}
	return 0;
} 
```

---

## 作者：天使宝贝 (赞：2)

[题面传送门](https://www.luogu.com.cn/problem/P9784)

### 题面简述

现有 $n$ 条公路，第 $i$ 条公路的长是 $l_i$，限速是 $v_i$，超速就要按照规定罚款，每一辆车从 $s_i$ 的时刻开始行驶，$v_i$ 的时刻离开该条公路，求最小的最大罚款金额。

### 思路&分析

看到最小的最大罚款金额，我们就应该向二分考虑，于是我们就愉快的套上了二分的板子。

不过这道题和一般的二分有点区别，我们不妨先计算出经过公路所用的时间，然后我们就直接对罚款的范围进行二分即可。

### CODE
```cpp
#include <bits/stdc++.h>
#define ll long long
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
const int MAXN = 1e5 + 5;
int n, m, q, s, t, v[15], l[15], a[MAXN], f[MAXN];
bool check(int x)
{
	double sum = 0;
	for (int i = 1; i <= n; i++)
		sum += 1.0 * l[i] / (v[i] + x);
	return sum + s <= t;
}
int main()
{
    IOS;
    cin >> n;
    for (int i = 1; i <= n; i++)
    	cin >> v[i];
    for (int i = 1; i <= n; i++)
    	cin >> l[i];
    cin >> m;
    for (int i = 1; i <= m - 1; i++)
    	cin >> a[i];
    for (int i = 1; i <= m; i++)
    	cin >> f[i];
    cin >> q;
    while (q--)
    {
    	cin >> s >> t;
    	int l = 0, r = m - 1, ans;
    	while (l < r)
    	{
    		int mid = (l + r) / 2;
    		if (check(a[mid]))
    			r = mid;
    		else
    			l = mid + 1;
		}
        if (!check(a[l]))
            l++;
		cout << f[l] << endl;
	}
	return 0;
}
```

---

## 作者：Aveiro7 (赞：2)

## 题目大意

现在有 $n$ 段从 $1\sim n$ 编号的公路。第 $i$ 段公路长 $l_i$ 米，其限速为 $v_i$ 米每秒，超速就要罚款。根据对应的时速范围罚款相应的钱数。

目前，有 $q$ 辆车要经过这 $n$ 段道路，每辆车在 $s_i$ 时间到达 $1$ 号路段，在 $t_i$ 时间离开 $n$ 号路段。

你需要计算每辆车在所有路段中最高被罚款的金额至少是多少。

时间从道路开放起计算，即从 $0$ 开始计算。

## 思路

罚款金额定义为所有路段**最高的罚款数**，随后二分罚款 $v_i$，计算时间 ``check`` 一下即可。

---

## 作者：lkjzyd20 (赞：1)

### 题目意思
有 $n$ 条道路，每段公路的长度 $l_i$，限速是 $v_i$，超速就要按照规定罚款，不同的超速程度有不同金额的罚款，每一辆车从 $s_i$ 的时刻开始行驶，$t_i$ 的时刻离开该条公路，求最小的最大罚款金额。

### 思路
题目中说最小的最大罚款金额，我们可以考虑二分枚举限速范围，时间复杂度 $O(qn \log m)$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i, l, r) for(int i = l; i <= r; ++ i)
#define per(i, r, l) for(int i = r; i >= l; -- i)
const int N = 1e5 + 10;
int l[N], v[N], a[N], f[N], n, m, Q, s, t;
double d[N];
main()
{
	scanf("%lld", &n);
	rep(i, 1, n) scanf("%lld", &v[i]);
	rep(i, 1, n) scanf("%lld", &l[i]);
	scanf("%lld", &m);
	rep(i, 1, m - 1) scanf("%lld", &a[i]);
	rep(i, 1, m) scanf("%lld", &f[i]);
	rep(i, 0, m - 1) rep(j, 1, n) d[i] += 1.0 * l[j] / (v[j] + a[i]);
	scanf("%lld", &Q);
	for(; Q; -- Q)
	{
		scanf("%lld %lld", &s, &t);
		int l = 0, r = m + 1;
		for(; l <= r;)
		{
			int mid = (l + r) >> 1;
			if(d[mid] <= t - s) r = mid - 1;
			else l = mid + 1;
		}
		printf("%lld\n", f[l]);
	}
	return 0;
}
```

---

## 作者：Distorted_Fate_ (赞：0)

## 题意简述

给你 $N$ 个前开后闭的区间（也就是每段路），每个区间都有自己的长度，在每个区间内超速造成的罚款会分成不同金额，给你车子的到达和离开时间，让你算出车辆超出限速被罚款最大金额的最小值。

## 算法：二分答案

因为题目要求最大值最小，并且通过样例可以观察出罚款金额是单调上升的，满足二分的有序性，所以果断使用二分答案。

## 大概思路

套二分的模板，然后再做一些改动

- 首先算出车辆在每段公路上的速度，从而算出车辆在所有道路上的速度和（判断函数所做的工作）。

- 然后看是否满足条件，满足则记录下当前答案并继续寻找最优解，不满足就继续找可行解。

![](https://cdn.luogu.com.cn/upload/image_hosting/vmco1jil.png)

[代码发在云剪贴板了，勿抄](https://www.luogu.com.cn/paste/89baxijs)

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 思路
求**最大的最小**且**具有单调性**所以考虑二分。

注：题目虽然没说罚款递增，但跟据常识可知是符合单调递增的。

## 具体实现
用二分枚举超速了几个档，算出超到了这个档的满格需要多久开完所有路程。

如果比用时快，减档。反之增档。

最后输出最合适的档的罚款。
## 分块代码
输入：
```cpp
cin>>n;
for(int i=1;i<=n;i++)cin>>v[i];
for(int i=1;i<=n;i++)cin>>l[i];
cin>>m;
for(int i=1;i<m;i++)cin>>a[i];
for(int i=1;i<=m;i++)cin>>f[i];
cin>>q;
```
二分：

```cpp
for(int i=1,s,t;i<=q;i++){
    cin>>s>>t;
    int ys=t-s;//总用时
    int ll=0,rr=m-1;//左右端点
    while(ll<rr){
        int mid=(ll+rr)>>1;
        if(check(a[mid],ys))rr=mid-1;
        else ll=mid+1;//二分
    }
    if(!check(a[ll],ys))ll++;//左端点检查
    cout<<f[ll]<<endl;//罚款
}
```
求时间函数：

```cpp
bool check(int x,int y){
	double st=0.0;
	for(int i=1;i<=n;i++){
		st+=l[i]*1.0/(v[i]+x);//超第x档时总用时
	}
	if(st>y)return 0;//更慢
	return 1;//更快
}
```
## 小提示
二分很难调，建议多练练。

---

## 作者：koukou (赞：0)

## 思路

就是一道二分题。

首先求出每辆车的速度。

然后，对于每个罚款范围进行二分即可。

## 代码


```cpp
#include<iostream>
using namespace std;
const int N = 1e5 + 1;
int n, m, q, v[11], l1[11], a[N], f[N], s, t, l, r;
bool check(int x)
{
	double ans = 0;
	for(int i = 0; i < n; i++)
	{
		ans += 1.0 * l1[i] / (v[i] + x);
	}
	return ans + s <= t;
}
int main()
{
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> v[i];
	}
	for(int i = 0; i < n; i++)
	{
		cin >> l1[i];
	}
	cin >> m;
	for(int i = 0; i + 1 < m; i++)
	{
		cin >> a[i];
	}
	for(int i = 0; i < m; i++)
	{
		cin >> f[i];
	}
	cin >> q;
	while(q--)
	{
		cin >> s >> t;
		l = 0, r = m - 1;
		while(l < r)
		{
			int mid = (l + r) / 2;
			if(check(a[mid - 1]))
			{
				r = mid;
			}
			else
			{
				l = mid + 1;
			}
		}
		if(!check(a[l - 1]))
		{
			l++;
		}
		cout << f[l - 1] << "\n";
	}
	return 0;
}
```

---


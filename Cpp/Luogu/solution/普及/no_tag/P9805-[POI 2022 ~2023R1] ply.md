# [POI 2022 ~2023R1] ply

## 题目背景

题目译自 [POI2022~2023R1 ply](https://sio2.mimuw.edu.pl/c/oi30-1/p/ply/)。

## 题目描述

定义“合法括号串”及其深度如下：

- 空串是一个合法括号串，深度为 $0$。
- 如果 $w$ 是一个合法括号串，深度为 $h$，则 $(w)$ 也是一个合法括号串，深度为 $h+1$。
- 如果 $w_1$ 和 $w_2$ 都是合法括号串，深度分别为 $h_1$ 和 $h_2$，则 $w_1w_2$ 也是一个合法括号串，深度为 $\max(h_1,h_2)$。

定义翻转一个字符为：

- 如果当前字符为 `(`，修改为 `)`。
- 如果当前字符为 `)`，修改为 `(`。

你需要通过翻转 $s$ 当中某些字符使得深度不超过 $H$，求最小操作次数。

## 说明/提示

对于样例，可以修改为 `(()()())`，这样深度为 $2$。

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $n \leq 20$ | $20$ |
| $2$ | $n \leq 3000$ | $40$ |
| $3$ | $n \leq 10^6$ 且 $H = h-1$ | $20$ |
| $4$ | $n \leq 10^6$ | $20$ |

注：$h$ 为输入的括号串的深度。

本题中，子任务 $0$ 为样例。

## 样例 #1

### 输入

```
8 2
(()(()))```

### 输出

```
2```

# 题解

## 作者：_sun_ (赞：2)

# P9805 [POI2022~2023R1] ply

## 贪心

### 思路

用一个变量表示深度。

- 如果遇到 `(`，深度加 $1$，此时若深度大于 `h` 则将其翻转为 `)`,并且抵消掉之前的一个 `(`，所以深度减 $2$。

- 如果遇到 `)`，深度减 $1$，此时若深度小于 $0$ 则将其翻转为 `(`,并且抵消掉之后的一个 `)`，所以深度加 $2$。

### 代码

```
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
char a[1000010];
int res; // 深度
int ans;
int main()
{
    int n,H;
    cin >> n >> H;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> a[i];
        if(a[i]=='(')
        {
            res++;
            if(res>H)
                ans++,res-=2;
        }
        else
        {
            res--;
            if(res<0)
                ans++,res+=2;
        }
    }
    cout << ans;
}
```


---

## 作者：Albatross_LC (赞：1)

模拟赛里出了，见有原题，便来水一发题解。

### 思路：

我们可以把原字符串中的 `(` 记为 $1$，将 `)` 记为 $-1$，对此序列做前缀和。此时，此题便转换成了另一个问题：

> 给定一个长度为 $n$ 序列 $a$，每次选择一个数 $i(1\le i\le n)$，将 $a_i$ 到 $a_n$ 都加或减 $1$，使得序列 $a$ 中的数最大值不超过 $L$，最小值不小于 $0$，求最小操作次数

注：此处 $a$ 中最小值不少于 $0$ 是因为在合法的括号序列中，不存在多余的 `)`，每次匹配的 `(` 总在 `)` 的左边，所以遍历到 $a_i$ 时，不可能有 $a_i <0$。

此时问题就很简单了，我么只需要对前缀和数组 $a$ 进行一次扫描，记录一个数 $tot$ 为减 $1$ 操作的次数，由于每次修改总会至少改动两个括号，所以当前 $tot$ 的变化量为 $2$，每次对 $a_i - tot$ 判断是否符合要求即可。

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int read() {
    int res = 0, c = getchar(), s = 0;
    while (!isdigit(c)) s |= c == '-',c = getchar();
    while (isdigit(c)) res = (res << 1) + (res << 3) + c - '0', c = getchar();
    return s ? -res : res;
}
int n, l, a[N], mx, ans;
char s[N];
int main() {
    n = read(), l = read();
    scanf("%s", s + 1);
    for (int i = 1; i <= n; i ++ )
        a[i] = a[i - 1] + (s[i] == '(' ? 1 : -1), mx = max(mx, a[i]);
    if (mx <= l) cout << 0, exit(0);
    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (a[i] - tot > l) {
            ans ++ ;
            tot += 2;
        } else if (a[i] - tot < 0) {
            ans ++ ;
            tot -= 2;
        }
    cout << ans;
}
```

---

## 作者：11216216c (赞：1)

这道题目其实不难，只要你理解深度与左右括号的关联就可以了。
## 主要算法
这题的算法是贪心，举个例子左括号代表深度增加，因为深度是按照这个位置被包裹几个括号包裹就是深度几层，然而右括号代表退出一层括号也代表深度减小，题目要求我们让深度到达 $ h $ 我们可以利用当前的深度来判断这个符号是否要变化，如果大于 $ h $ 那么将遇到的左括号变成右括号让深度减小，如果小于 $ h $ 那么将遇到的右括号变成左括号让深度增加即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,h,ans,s;
string a;
int main()
{
	cin>>n>>h;
	cin>>a;
	for(int i=0;i<=n-1;i++)
	if(a[i]=='(') //判断a字符串第i位是否为左括号。
	{
		if(s+1>h) //从深度判断是否要变号，大于h说明太深了要变号。
		{
			s--;
			ans++;
		}
		else
		s++;
	}
	else //判断a字符串第i位是否为右括号。
	if(a[i]==')')
  {
		if(s-1<0)
		{
			s++;
			ans++;
		}
		else
		s--;
	}
	printf("%lld",ans);
}
```

---

## 作者：iostream69 (赞：1)

# 题面
[题目传送门](https://www.luogu.com.cn/problem/P9805)
# 思路
其实这道题很抽象，因为它根本没告诉你这个深度怎么算。

再看一眼数据范围：$n\le 10^6$，模拟也不行了。怎么做呢？

我们发现当有一个单独的左括号时，深度会加一，当有一个单独的右括号时，深度会减一。

借助这个发现，这个题就很简单了。只要我们读入一个字符，当这个字符是左括号时，深度加 $1$。如果读入这个左括号后，深度超过了限制，那就把深度减 $2$。当这个字符是右括号时，深度加 $1$，如果读入这个右括号后，深度小于 $0$，那就把深度加 $2$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,sum,n,m;
char a;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a;
		if(a=='('){
			sum++;
			if(sum>m){
				sum-=2;
				ans++;
			}
		}
		if(a==')'){
			sum--;
			if(sum<0){
				sum+=2;
				ans++;
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：一只小菜包 (赞：1)

### 题目大意

给定一个字符串，每个左括号表示深度加一，每个右括号表示深度减一。需要计算最少修改多少次括号（即将左括号改为右括号或将右括号改为左括号），使得在遍历整个字符串的过程中，深度不超过指定的限制。

### 题目分析

贪心算法和搜索。

遍历字符串，当遇到左括号时，我们增加深度计数。如果增加后的深度超过了限制，说明我们需要将当前左括号修改为右括号，并减少深度计数两次（相当于先减少一次，因为我们将左括号改为了右括号，然后再减少一次，因为右括号会使深度减一）。

当遇到右括号时，我们减少深度计数。如果减少后的深度小于 $0$ ，说明当前的右括号在之前的括号序列中并没有与之匹配的左括号，因此我们需要将当前右括号修改为左括号，并增加深度计数两次（同样地，先增加一次，因为我们将右括号改为了左括号，然后再增加一次，因为左括号会使深度加一）。

在这个过程中，我们累加修改的次数，最后输出修改的总次数即可。

### 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m; 
    string s;
    cin >> s; 
    
    int depth = 0; // 当前深度
    int ans = 0; // 修改次数
    
    for (char c : s) {
        if (c == '(') {
            depth++; // 遇到左括号，深度加一
            if (depth > m) {
                depth -= 2; // 如果深度超过限制，修改左括号为右括号，并减少深度两次
                ans++; // 修改次数加一
            }
        } else if (c == ')') {
            depth--; // 遇到右括号，深度减一
            if (depth < 0) {
                depth += 2; // 如果深度小于0，修改右括号为左括号，并增加深度两次
                ans++; // 修改次数加一
            }
        }
    }
    
    cout << ans << endl; 
    return 0;
}
```

一篇没有任何公式且简单易懂的题解就完成啦！

---

## 作者：DFs_YYDS (赞：1)

# 题目大意
给你一个长度为 $n$ 的字符串，问要修改多少次括号（如果是`(`则修改为`)`，如果是`)`则修改为`(`）才能不大于指定的深度。
# 具体思路
一道简单的贪心，把样例看懂就行。
```
8 2
(()(()))
```
长度为 $8$，深度限制为 $2$。接下来进行修改。

读到第 $4$ 个字符 `(` 的时候，深度已经超出限制 $2$ 了。为了保持深度不大于 $2$，就将其变成 `)`，但是如果只变一个，剩下的字符串就不合法了，所以要将原来与其匹配的也修改掉。最终答案就是 $2$。

样例看懂了，就可以开始写代码了。
# 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,h,ans=0,cnt=0;//字符串长度n，深度限制h，交换次数也就是最终答案ans和计数器cnt。 
    char c;//每次读入的字符c。 
    cin>>n>>h;//读入n和h。 
    for(int i=0;i<n;i++){//循环n次。 
    	cin>>c;//读入字符c。 
    	if(c=='('/*由于c++的短路，所以如果这个条件不成立就不会执行后面的语句了*/ && ++cnt/*将cnt-1并判断是否>h*/>h)ans+=1,cnt-=2;
    	if(c==')'/*同上*/ && --cnt/*将cnt-1并判断是否小于0*/<0)ans+=1,cnt+=2;
    }
    cout<<ans;//输出答案。 
    return 0;//华丽结束。 
}
```

---

## 作者：Melo_DDD (赞：1)

# 题目大意

本题描述挺抽象的，我来转述一下要点：

- 不用太在意深度是怎么求出来的，因为做题不需要。

- **不保证**输入的和结果一定是合法字符串，但这不重要。

# 题目实现

当你不知道题目用什么算法时，那就该想想贪心或者搜索了，显然本题用贪心，因为局部最优一定可以达到全局最优。

我们考虑提到的两种字符 `(` 和 `)`，可见每层深度一定是由 `()` 堆起来的，所以不妨将 `(` 看做一层深度的标志，每遇到一个使深度加 $1$，反之，每遇到一个 `)` 就将深度减 $1$。

接下来考虑翻转操作：

- 当我们翻转 `(` 时，不仅原来的合法串配不成对，也会使它前面的合法串非法，所以深度减 $2$。

- 对于 `)` 情况反之，翻转不仅配成了合法串，还让原来它前面不合法的串合法了，所以深度加 $2$。

- 边界条件，上界 $h$ 不用多说，下界一定是 $0$，因为题目里没提小于零的情况，即这种情况无意义。

采用在线算法。

## 代码

```cpp
#include<bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define IOS ios :: sync_with_stdio(0) ;cin.tie (0) ;cout.tie (0)
using namespace std ;
int n ,h ,cnt ,ans ;
int main () {
	IOS ;
	cin >> n >> h ;
	rep (i ,1 ,n ,1) {
		char ch ;
		cin >> ch ;
		if (ch == '(') {
			cnt ++ ;
			if (cnt > h) {
				ans ++ ;
				cnt -= 2 ;
			}
		}
		if (ch == ')') {
			cnt -- ;
			if (cnt < 0) {
				ans ++ ;
				cnt += 2 ;
			}
		}
	} 
	cout << ans << '\n' ;
	return 0 ;
}
```

长度正好 $520$。

[npy](https://www.luogu.com.cn/user/1139577)。

###### 你是否承认卡芙卡的美貌举世无双？

---

## 作者：danb123 (赞：1)

## 题目大意

一个字符串，一个括号匹配代表一个深度，问要修改多少次括号才能不大于指定的深度。

## 题目分析

非常简单的一道题目。只需用到一些贪心与字符串的知识即可解决。这道题目先进行遍历，遍历到有左括号的时候说明它的深度要加一了，如果加一了就大于这个限制深度，那就把它翻转，深度就减二了。

反之，如果有右括号深度要减一了。如果它的深度要小于零了，也就是说明这个字符串不合法了，需要修改这个又括号为左括号，深度就减二了。

```
限制深度为二
()(()()(()))
```
```
()(()()()())
```
## 完整代码
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
char s[1000001];
ll cnt,ans,n,m;
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        cin>>s[i];
        if(s[i]=='(')cnt++,(cnt>m?(ans++,cnt-=2):ans=ans);
        else cnt--,(cnt<0?(ans++,cnt+=2):ans=ans);
    }
    cout<<ans;
}

```
时间复杂度为线形，绝对不会超时。

---

## 作者：chenhouyuan (赞：0)

首先观察数据范围 $n\le10^6$，说明时间复杂度应该是线性的。考虑贪心。我们用栈维护当前括号序列的深度，如果超过了 $H$ 则我们不得不进行翻转，我们发现翻转任意一个在栈中的左括号都能使深度减一，因此我们直接进行一次弹栈操作并使答案加一，但是这样序列就不合法了，所以当栈为空且当前是一个右括号时我们也要翻转，压栈一次同时答案加一即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+5;
ll n,l,ans,st;
string s;
int main(){
	scanf("%lld%lld",&n,&l);
	cin>>s;
	for(ll i=0;i<s.size();i++){
		if(s[i]=='('){
			st++;
		}
		else{
			st--;
		}
		if(st>l){
			ans++;
			st-=2;
		}
		if(st<0){
			ans++;
			st=1;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Dream_Stars (赞：0)

## 题目大意：

有一个字符串 $s$，仅包含左括号和右括号，题目定义了一种括号的深度概念，在只有一个括号都情况下，深度为 $1$，如果在那个括号里还有一个括号，如 `(())` 或者是 `(()()())` 这样的情况的深度就是 $2$，而如果是 `(()(()))` 的深度就是 $3$，以此类推。

而我们要干的就是给出了一个 $m$ 的深度，我们需要改变一些括号，将左括号改右括号，将右括号改左括号，使深度为 $m$。

## 算法解释：

这道题看起来不怎么简单，事实上只是一个贪心的算法，我们可以将左括号看成深入一层，将右括号看成减少一层，而我们如果将左括号改成右括号，那么就会减少两层；如果将右括号给改为左括号，那么对应就会深入两层。所以，我们便可以用一个贪心的思路来解题。

- **贪心思路**：我们可以先遍历整个字符串，定义一个 $t$ 变量当做目前的层数，如果当前是一个左括号，并且层数小于 $m$，那么就加 $1$ 否则，我们就只能变换这个括号了，将其变为右括号，那么层数就减 $2$，如果是右括号也同理。

## 代码展示：

```cpp
#include<bits/stdc++.h>
#define ll long long//宏定义，将long long表示为ll。
using namespace std;
string k;
ll t , ans , n , m; 
int main(){
  cin >> n >> m >> k;
  for(ll i = 0 ; i < k.size() ; i++){
  	if(k[i] == '(')//如果这是左括号。
  	  if(t + 1 <= m) t = t + 1;//如果深度还小于等于m，那么我们就深入一层。
  	  else t = t - 1 , ans = ans + 1;
//如果深度已经大于m了，我们就退回去一层，并且累计ans，为什么这里只退一层呢，因为这里本来是先进入一层，在退出去两层，所以就是退出去一层。
	if(k[i] == ')')//这就是右括号。
	  if(t - 1 >= 0) t = t - 1;
	  else t = t + 1 , ans = ans + 1;
  }//同理。
  printf("%lld",ans);//最后输出ans即可。
  return 0;
}
```

---

## 作者：_Epsilon_ (赞：0)

## 思路
贪心：因为他是说的求**最小值**，面对最值问题时优先考虑贪心。

怎么去求它的深度呢？我们只需要在遇到左括号 `(` 时深度加 $1$，反之减 $1$。而题目要求说要满足深度不大于 $H$，所以我们就在这个边缘反复横跳，能不改就不改，迫不得已了才改 

## 具体实现
先计算出目前深度，若大于 $H$ ，则改变一次，代价加 $1$，深度减 $2$。

### 注意
若深度比 $0$ 小，则不合规。将输入的 `)` 改为 `(`，代价加 $1$，深度加 $2$。
## 代码
```cpp
// #pragma GCC optimize("Ofast,no-stack-protector")
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<bits/stdc++.h>
using namespace std;
int ans,h,n,d=0;
char c;
int main()
{
	ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
	cin>>n>>h;
	while(n--)
	{
	    cin>>c;
	    if(c=='(')
	    {
	        ++d;//深度加1
	        if(d>h)
	        {
	            ans+=1;//代价加2
	            d-=2;//深度减1
	        }
	    }
	    else
	    {
	        --d;//深度加1
	        if(d<0)
	        {
	            ans+=1;//代价加2
	            d+=2;//深度减1
	        }
	    }
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：WydnksqhbD (赞：0)

# [P9805 [POI2022~2023R1] ply](https://www.luogu.com.cn/problem/P9805) 题解
## 思路
本题既然要求**最小操作次数**，肯定就是能不改就不改，只有当目前深度 $\text{cnt}>H$ 或 $\text{cnt}<0$ 时才操作。

如何判断目前深度呢？每增加一个 `(`，$\text{cnt}$ 应当 $+1$；而遇到 `)` 时，当前深度 $\text{cnt}$ 可以 $-1$。

那么贪心思路就很简单了：每读入一个字符，
- 若为 `(`，则 $\text{cnt}$ 加 $1$。判断 $\text{cnt}>H$ 是否为真，若为真则操作一次。**修改后 $\text{cnt}$ 减 $2$，答案 $\text{ans}$ 加 $1$**。
- 否则肯定为 `)`，则 $\text{cnt}$ 减 $1$。判断 $\text{cnt}<0$ 是否为真，若为真则操作一次。**修改后 $\text{cnt}$ 加 $2$，答案 $\text{ans}$ 加 $1$**。
## 代码
C 语言代码。
```c
#include <stdio.h>
#include <stdlib.h>
int main ()
{
	int n, h, i;
	scanf ("%d %d", &n, &h);
	int cnt = 0, ans = 0;
	for (i = 1; i <= n; i ++)
	{
		char ch = getchar ();
		while (ch != '(' && ch != ')')
		{
			ch = getchar ();
		}
		if (ch == '(')
		{
			cnt ++;
			if (cnt > h)
			{
				ans ++;
				cnt -= 2;
			}
		}
		else
		{
			cnt --;
			if (cnt < 0)
			{
				ans ++;
				cnt += 2;
			}
		}
	}
	printf ("%d", ans);
	return 0;
}
```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

定义一个合法字符串的深度判断为：

- 长度为 $0$ 的字符串是合法字符串，其深度为 $0$。

- 若 $str$ 是深度为 $h$ 合法字符串，则 $(str)$ 也是合法字符串且深度为 $h+1$。

- 若 $str_1,str_2$ 是深度为 $h_1,h_2$ 的合法字符串，则 $str_1str_2$ 是深度为 $\max(h_1,h_2)$ 的合法字符串。

给定一串长度为 $n$ 的字符串 $str$，需要让 $str$ 的深度不超过 $m$，每次变化可以将 ```(``` 变为 ```)``` 或将 ```)``` 变为 ```(```。求最小的变化次数。

## Part 2 思路

由于题目要求的是最小的情况，所以我们考虑**贪心**算法。

显而易见，如果 $str$ 的深度增加了 $1$，那么 $str$ 中必定增加了一个 ```(``` 和一个 ```)```。于是我们可以将每一次遇到的 ```(``` 都当做 $str$ 中增加一层深度的体现。同理，```)``` 便是 $str$ 中减少一层深度的体现。

换言之，如果我们定义 $sum$ 来表示 $str$ 的深度，对于 $str$ 中的第 $i$ 个字符 $str_i$：

- 若 $str_i$ 为 ```(```，$sum \leftarrow sum+1$。

- 若 $str_i$ 为 ```)```，$sum \leftarrow sum-1$。

但是题目要求 $str$ 的深度不能超过 $m$，并且显而易见的 $str$ 的深度不可能小于 $0$，即满足 $0 \leq sum \leq m$。如果我们要让 $str$ 的深度增加或减少，我们就可以构造或破坏一个 ```()``` 的序对。

具体的，当我们将 ```(``` 变成 ```)``` 时，首先会将原本处在的序对破坏，其次会和之前一个序对的 ```(``` 匹配，间接在破坏一个序对，造成深度减 $2$。同理，将 ```)``` 变为 ```(``` 会造成深度加 $2$。

那做法就显而易见了，我们将 $str$ 从左到右枚举每一位，并记录其深度。如果该位是 ```(``` 则将深度加 $1$，反之减 $1$。如果发现深度加 $1$ 之后大于 $m$ 则将深度减 $2$，并 $result \leftarrow result+1$。反之同理。

## Part 3 代码

```
#include <bits/stdc++.h>
using namespace std;
int n,m,result,sum;
string str;
int main()
{
	cin>>n>>m>>str;
	for (int i=0;i<=n-1;i++)
	{
		if (str[i]=='(')
		{
			sum++;
			if (sum>m) sum-=2,result++;
		}
		else if (str[i]==')')
		{
			sum--;
			if (sum<0) sum+=2,result++;
		}
	}
	cout<<result;
	return 0;
}
```

---

## 作者：Harrylzh (赞：0)

题目要求改变的次数最少，所以只在**非改不可**的时候改。

根据题意，“非改不可”有以下两种情况：
- 当前深度大于 $h$ 。
- 当前字符串不合法。

其中，当前字符串不合法指左括号与右括号个数不相等，如果左括号个数**小于**右括号，则会有右括号无法匹配到左括号（深度为负），如果左括号个数**大于**右括号，则左括号个数一定大于 $h$ （因为 $h \le \frac{n}{2}$ ），会在第一个情况处理掉。

按上文分析模拟即可。代码：

```cpp
#include<iostream>
#include<string>
using namespace std;
int n,h;
string s;
int depth=0;
int ans=0;
int main()
{
    cin>>n>>h>>s;
    for(int i=0;i<s.size();i++)
    {
        if(s[i]=='(')
        {
            depth++;
            if(depth>h)
            {
                ans++;
                depth-=2;//深度超出限制，把左括号改为右括号，深度减一，同时改为右括号后能与前面一个左括号匹配抵消掉，深度再减一。
            }
        }
        else
        {
            depth--;
            if(depth<0)
            {
                ans++;
                depth+=2;//原字符串不合法，把右括号改为左括号，深度加一，同时改为左括号后不能与前面一个右括号匹配抵消，深度再加一。
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---


# [POI 2022/2023 R1] poc

## 题目背景

题目译自 [POI2022~2023R1 poc](https://sio2.mimuw.edu.pl/c/oi30-1/p/poc/)。


## 题目描述

小 A 和小 B 在记录过往的车辆的类型！

已知类型分别有 $1 \sim k$ 个，每种车辆必然属于其中之一。

小 A 按顺序细心地记录了所有的车辆的类型，但是贪玩的小 B 只按顺序记录了一部分车辆。

小 A 记录的内容长度为 $n$，小 B 记录的长度为 $m$。

称在小 A 记录中的第 $i$ 辆车“可能被 B 记录到”当且仅当在小 A 的记录中存在一个包含 $i$ 的子序列与小 B 所记录的完全相同。

保证小 B 记录的序列一定是小 A 记录的子序列，问哪些车辆是可能会被小 B 记录到，哪些没有。

## 说明/提示

对于样例，存在如下的子序列：

$(1,2,4,5)$，$(1,2,4,9)$，$(1,2,7,9)$，$(1,6,7,9)$，$(4,6,7,9)$。

注意到 $3$ 和 $8$ 一直都没被取到，故不能被小 B 记录到。

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $n,m \leq 100$ | $15$ |
| $2$ | $n,m \leq 2000$ | $20$ |
| $3$ | 每种类型的车辆最多被小 A 记录一次 | $15$ |
| $4$ | 无附加限制 | $50$ |

时间限制：Subtask1 1s，Subtask2 10s，Subtask3 和 Subtask4 6s。

## 样例 #1

### 输入

```
9 4 3
1 3 2 1 2 3 1 3 2
1 3 1 2
```

### 输出

```
1 1 0 1 1 1 1 0 1```

# 题解

## 作者：Yxa_Sheep (赞：6)

`upd on 2025/6/15`：修改了代码。
## 题意
从 $a$ 数组里挑出 $b$ 数组。对于第 $i$ 项，如果可以被选中就输出 `1`，否则输出`0`。
## 思路
一开始想用深搜，当看到 $n,m,k\le3\times10^5$ 这里就立刻放弃了。从后往前遍历，找到 $b_i$ 在 $a$ 序列中最后出现的地方，存入数组 $lst$。再从前往后遍历，用 $fst$ 数组存储这个数是从左往右满足的第几个数，如果第 $i$ 个数已经满足条件并且在最后一次出现之前，就输出 `1`，否则输出 `0`。
## 代码（就不放注释了）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, tot, a[300010], b[300010], lst[300010], fst[300010];
int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= m; i++)
        scanf("%d", &b[i]);
    for (int i = n, j = m; i >= 1; i--)
        if (a[i] == b[j])
            lst[j--] = i;
	for (int i = 1, j = 1; i <= n; i++)
	{
		if (a[i] == b[j])
			fst[a[i]] = j++;
		printf("%d ", fst[a[i]] && i <= lst[fst[a[i]]]);
	}
    return 0;
}
```

完结!!!求过。

---

## 作者：keepwatcher_kensap (赞：4)

## Part 1 题目大意

对于小 A 记录的序列 $a$ 和小 B 记录的序列 $b$，需要输出序列 $a$ 中的数 $a_i$ 是否可以满足：

- 在 $b$ 是 $a$ 的一个子序列时，$a_i$ 是否可能对应 $b$ 中的一个数 $b_i$。

如果满足则输出 ```1```，否则则输出 ```0```。

特别的，有可能会出现 $b$ 不是 $a$ 的子序列的情况，也有可能出现 $a$ 的多个子序列都是 $b$ 的情况。

## Part 2 主体思路

由于 $1 \le n,m,k \le 3 \times 10^5$，因此不考虑 $O(nm)$ 的做法，考虑 $O(n)$ 的做法。

**如何判断 $b$ 不是 $a$ 的子序列，即没有任何一个数满足条件的情况？**

由于 $b$ 是 $a$ 的子序列时，$b$ 中的每个元素都会在 $a$ 中出现。所以我们可以从前往后或从后往前枚举 $a$ 和 $b$，每当发现 $a_i = b_j$ 的时候，我们就考虑 $b_j$ 的下一个元素，并每次都枚举 $a_i$ 的下一个元素。

最后，如果发现我们枚举完了 $b$ 中的所有元素，说明 $b$ 是 $a$ 的子序列，就可以进行下一步计算。

特别的，如果我们在一开始的时候就发现 $b$ 的长度 $m$ 要大于 $a$ 的长度 $n$，那就说明无论如何 $b$ 都不可能成为 $a$ 的子序列，可以直接输出答案了。

**如何判断 $a_i$ 是否可以对应 $b$ 中的任意一个元素 $b_j$?**

注：以下推论都是在已确定 $b$ 是 $a$ 的子序列的前提下进行的。

首先，当我们枚举到 $a_i$ 时，我们可以确定 $a_{1 \dots i}$ 中包含的尽可能最长 $b$ 前缀 $b_{1 \dots j}$ 为子序列时，数字 $num$ 在 $b_{1 \dots j}$ 中最后一次出现的位置 $f_{num}$。特别的，在每次枚举完 $f_{num}$ 之后就要判断一次答案，因为 $f_{num}$ 的值需要随着枚举的推进而不断更新。

进一步的，对于 $b$ 中的一个数 $b_{sum}$，我们可以找到一个 $g_{sum}$ 满足：$a_{g_{sum} \dots n}$ 是最短的可以包含 $b_{sum \dots m}$ 为子序列的 $a$ 的后缀。至于如何由 $sum$ 推出 $g_{sum}$，我们可以在判断子串从后往前枚举 $a$，当发现 $a_i = b_{sum}$ 且 $i$ 最大时，$g_{sum} \gets i$。特别的，$g$ 数组不需要在枚举答案时再进行更新，需要在对 $f$ 数组进行变化之前就做好赋值。

接着，我们只要从前往后枚举 $a$，同时，更新 $a_{1 \dots i}$ 可以包含的最长 $b$ 前缀 $b_{1 \dots place}$ 为子序列的 $place$ 的值。对于目前枚举到的情况，更新 $f$ 数组的值。对于目前考虑到数 $a_i$，如果我们发现它满足：

- $a_i$ 是 $b_{1 \dots place}$ 中的一个值，即 $f_{a_i} \neq 0$。

- 令 $last$ 为 $a_i$ 在 $b_{1 \dots place}$ 中最后一次出现的位置，即 $f_{a_i}$，则令 $minn$ 是 $a_{minn \dots n}$ 中可以包含的尽可能长的 $b$ 的后缀 $b_{last \dots m}$，即 $g_{last}$。只要 $minn$ 大于目前枚举到的位置，即 $g_{f_{a_i}} \geq i$。

我们就可以认为，$a_i$ 是符合条件的，输出 ```1```，否则输出 ```0```。

## Part 3 代码 不含注释

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=3e5+5;
int n,m,k,a[maxn],b[maxn],f[maxn],g[maxn];
int main()
{
	cin>>n>>m>>k;
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=1;i<=m;i++) cin>>b[i];
	int place=m;
	for (int i=n;i>=1;i--)
	{
		if (a[i]!=b[place]) continue;
		g[place]=i,place--;
	}
	if (place!=0 || m>=n+1)
	{
		for (int i=1;i<=n;i++) cout<<"0 ";
		return 0;
	}
	place=1;
	for (int i=1;i<=n;i++)
	{
		if (a[i]==b[place]) f[a[i]]=place,place++;
		if (f[a[i]]!=0 && g[f[a[i]]]>=i) cout<<"1 ";
		else cout<<"0 ";
	}
	return 0;
}
```

---

## 作者：XichenOC (赞：2)

## [P9806 [POI2022~2023R1] poc](https://www.luogu.com.cn/problem/P9806)
# 题目翻译：
给定一个一序列 $A$，表示每节车厢的类型，在给出一个一个序列 $B$，这个序列是从 $A$ 中可以选出来，求 $A$ 序列的那些点是可能选到的。
# 思路：
我们阅读题目可以发现，若一个数在 $A$ 中可以取的话，那他必须保证他在 $B$ 中左侧的数，在 $A$ 中左侧也一定要存在。同理可得他在 $B$ 中右侧的数，在 $A$ 中右侧也一定要存在。那根据这个性质就可以得到一个解法：
>1. 我们只需要提前找到，从左开始的最接近的满足条件的位置，和最右边满足条件的位置,预处理出来即可。  
>2. 如何判断这个数是否可选，只需要判断他是否在满足条件的最左边的这个数的位置和最右边这个数的位置间即可。
# 实现：
1. 开局先从右往左枚举，由于我们要找的数一定是符合序列 $B$ 的，所以维护一个当前找到过的数的位置 $j$ 那直到找到第一个 $j$ 的值相同地方，在左移找下一个数。  

```cpp
int j=m;
for(int i=n;i>=1;i--){
   if(a[i]==b[j]){
      p[j]=i;
      j--;
   }
}
```

2. 让后在从左往右找，这次维护当前这个数是从左往右满足的第几个数，若这个数在左边已经满足条件，且他这个数在最右边满足条件的数前面，那这个数就满足条件，就可以直接输出即可。

```cpp
j=1;
for(int i=1;i<=n;i++){
	if (a[i]==b[j]){
		p2[a[i]]=j;
		j++;
	}
	if (p2[a[i]]!=0 && p[p2[a[i]]]>=i){
		cout<<"1 ";
	}
	else cout<<"0 ";
}
```

# 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N],b[N];
int p[N],p2[N];
int main(){
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	int j=m;
	for(int i=n;i>=1;i--){
		if(a[i]==b[j]){
			p[j]=i;
			j--;
		}
	}
	j=1;
	for(int i=1;i<=n;i++){
		if (a[i]==b[j]){
			p2[a[i]]=j;
			j++;
		}
		if (p2[a[i]]!=0 && p[p2[a[i]]]>=i){
			cout<<"1 ";
		}
		else cout<<"0 ";
	}
} 
```

---

## 作者：tanghg (赞：1)

考虑记录 $l_i$ 表示截至到 $a_i$ 最多**从左到右**能匹配多少 $b$，$r_i$ 表示截至到 $a_i$ 最多**从右到左**能匹配多少 $b$。

之后对于每一个 $a_i$，只要找到一个 $b_j$ 满足 $a_i=b_j$ 且 $l_{i-1}\geq b_j-1$ 与 $r_{i+1}\geq m-b_j$。因为 $l,r$ 均有单调性，所以先用 `vetcor` 记录每一个 $a_i$ 在 $b$ 中出现的位置，显然这个也有单调性。不妨设这个 `vector` 为 $s$， 则可以在 $s_{a_i}$ 中找到最靠左满足 $l_{i-1}\geq b_j-1$ 的 $j$，然后因为 $r$ 有单调性，所以直接判断 $r_{i+1}\geq m-j$ 即可。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef long long ll;
const ll MAXN=1e6+5;
ll a[MAXN],b[MAXN],n,m,k;
ll l[MAXN],R[MAXN],r[MAXN];
vector<ll>s[MAXN];
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m>>k;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    for(int i=1;i<=m;++i){
        cin>>b[i];
        s[b[i]].push_back(i);
    }
    for(int i=1;i<=n;++i){
        l[i]=l[i-1];
        if(b[l[i]+1]==a[i]){
            l[i]++;
        }
    }
    R[n+1]=m+1;
    for(int i=n;i>=1;--i){
        R[i]=R[i+1];
        r[i]=r[i+1];
        if(b[R[i]-1]==a[i]){
            R[i]--;
            r[i]=m-R[i]+1;
        }
    }
    for(int i=1;i<=n;++i){
        bool good=false;
        if(s[a[i]].empty()){
            cout<<"0 ";
            continue;
        }
        ll L=0,R=s[a[i]].size()-1,ql=1e18,qr=s[a[i]].size()-1;
        while(L<=R){
            ll mid=(L+R)>>1;
            if(l[i-1]+1>=s[a[i]][mid]){
                L=mid+1;
                ql=mid;
            }else{
                R=mid-1;
            }
        }
        if(ql==1e18){
            cout<<"0 ";
            continue;
        }
        cout<<(r[i+1]>=m-s[a[i]][ql])<<" ";
    }
    return 0;
}

```

---

## 作者：cosf (赞：0)

## [P9806](https://www.luogu.com.cn/problem/P9806)

这道题大概是黄题吧。

首先，如果 $b$ 不是 $a$ 的子序列，直接输出全 $0$ 即可。

对于 $b$ 是 $a$ 的子序列的情况，我们令 $las_i$ 一个东西，具体是：

对于 $b$ 的一个后缀 $b_{i\dots n}$，令 $a$ 的后缀 $a_{las_i\dots n}$ 是最短且有 $b_{i\dots n}$ 作为子序列之一的后缀。

这个东西要从后往前处理。

那么我们再从前往后处理一次即可得出答案。我们令 $lp_{p}$ 表示：

假设当前处理到 $a$ 的前缀 $a_{1\dots i}$，其中包含一个最长的 $b$ 的前缀 $b_{1\dots j}$ 作为子序列，字符 $p$ 在 $b_{1\dots j}$ 中最晚出现的地方 $lp_p$。

那么，对于 $a_i$，如果有 $las_{lp_{a_i}} \ge 1$，则输出 $1$，否则为 $0$。

时间复杂度 $O(n)$。

## 代码

```cpp
#include <iostream>
using namespace std;

#define MAXN 300005

int n, m, k;

int las[MAXN];
int lp[MAXN];

int a[MAXN];
int b[MAXN];

int main()
{
	cin >> n >> m >> k;
	if (m > n)
	{
		for (int i = 1; i <= n; i++)
		{
			cout << "0 ";
		}
		cout << endl;
		return 0;
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	for (int i = 1; i <= m; i++)
	{
		cin >> b[i];
	}
	int l = m;
	for (int i = n; i; i--)
	{
		if (a[i] == b[l])
		{
			las[l] = i;
			l--;
		}
	}
	if (l)
	{
		for (int i = 1; i <= n; i++)
		{
			cout << "0 ";
		}
		cout << endl;
		return 0;
	}
	l = 1;
	for (int i = 1; i <= n; i++)
	{
		if (a[i] == b[l])
		{
			lp[a[i]] = l;
			l++;
		}
		if (lp[a[i]] && las[lp[a[i]]] >= i)
		{
			cout << "1 ";
		}
		else
		{
			cout << "0 ";
		}
	}
	cout << endl;
	return 0;
}
 
```


---

## 作者：TruchyR (赞：0)

## Part 1 思路
设：  
- 小 A 记录的序列为 $a$。
- 小 B 记录的序列为 $b$。

首先我们可以用指针在 $O(n)$ 内求出 $b$ 中的每个数在 $a$ 中出现的最早和最晚位置。  
我们可以得到一些区间，并把他们按照颜色分类（不同颜色即使在区间里也没用）。  
那么这个问题就转化为：  
$k$ 个问题，每个问题给定几个数 $p$ 和一些区间，问这些数是否在区间内。  
由于 $k$ 个问题中 $p$ 的元素数总和不超过 $n$，我们可以用 vector 存储并再用指针进行计算。  
## Part 2 代码
对于求出现的最早和最晚位置，可以设定指针 $i$ 表示前/后 $i$ 个元素已经在 $a$ 中被找到。  
对于求是否在区间内，可以把区间按照左端点排序，设定指针 $j$ 表示前 $j$ 个区间已经为答案做出了贡献。  
```cpp
#include<bits/stdc++.h>
#define MX 300005
using namespace std;
const int CHECK=1;
int n,m,k,a[MX],b[MX],L[MX],R[MX],res[MX];
struct eg{int l,r;};
bool cmp(eg xx,eg yy){return xx.l==yy.l?xx.r<yy.r:xx.l<yy.l;}
vector<int> v[MX];
vector<eg> q[MX];
signed main(){
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){cin>>a[i];v[a[i]].push_back(i);}//按照颜色分类
	for(int i=1;i<=m;i++) cin>>b[i];
	int p=0;//此处p表示第1~p个元素匹配完成
	for(int i=1;i<=n;i++)//求最早出现的位置
		if(a[i]==b[p+1]){
			p++;L[p]=i;}
	p=m+1;//此处p表示第p~n个元素匹配完成
	for(int i=n;i>=1;i--)//求最晚出现的位置
		if(a[i]==b[p-1]){
			p--;R[p]=i;}
	for(int i=1;i<=m;i++)
		q[b[i]].push_back(eg{L[i],R[i]});//按照颜色分类
	for(int i=1;i<=k;i++){
		sort(q[i].begin(),q[i].end(),cmp);p=0;//排序&指针赋初值
		int length=q[i].size();
		if(!length) continue;
		for(auto j:v[i]){//按顺序计算a中的每个元素
			while(q[i][p].r<j){//j在这个区间右侧
				p++;
				if(p>=length) break;
			}if(p>=length) break;//区间全部遍历完毕
			//j在区间左侧
			if(j<q[i][p].l) continue;
			//计入答案
			res[j]=1;
		}
	}
	for(int i=1;i<=n;i++)
		cout<<res[i]<<' ';//输出
	return 0;
}
```


---

## 作者：GI录像机 (赞：0)

## 思路：

$a$ 数组表示小 A 记录的序列，$b$ 数组表示小 B 记录的序列。

考虑对于每个 $b_i$，判断它可以是哪些 $a_j$。

要满足这个条件，只需 $b_i =a_j$ 且 $a_j$ 前后分别有对应 $b_i$ 前后的子序列即可。

那么我们建立两个数组 $pre_i$ 和 $suc_i$，分别表示最小的 $pre_i$ 使得 $b_1$ 到 $b_i$ 在 $a_1$ 到 $a_{pre_i}$ 中出现，最大的 $suc_i$ 使得 $b_i$ 到 $b_m$ 在 $a_{suc_i}$ 到 $a_n$ 中出现。

对于 $b_i$，它可以是 $pre_{i-1}$ 到 $suc_{i+1}$ 之间任意一个满足 $b_i =a_j$ 的 $a_j$。容易想到这样是最优的。

我们可以对于每一种车型开一个 set，记录这种车型出现的位置。枚举 $b_i$ 时二分将符合条件的位置记录答案并删去，这样每个位置只会被遍历到一遍。复杂度 $O(n\log n)$。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int f = 1, x = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f * x;
}
void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 3e5 + 10, MOD = 1e9 + 7, INF = 0x3f3f3f3f;
int n = read(), m = read(), k = read(), a[N], b[N], pre[N], suc[N];
set<int>s[N];
bool ans[N];
signed main() {
	for (int i = 1; i <= n; i++) {
		a[i] = read();
		s[a[i]].insert(i);
	}
	int j = 1;
	for (int i = 1; i <= m; i++) {
		b[i] = read();
		while (j <= n && a[j] != b[i])j++;
		pre[i] = j++;
	}
	j = n;
	suc[m + 1] = n + 1;
	for (int i = m; i >= 1; i--) {
		while (j >= 1 && a[j] != b[i])j--;
		suc[i] = j--;
		auto it = s[b[i]].upper_bound(pre[i - 1]);
		while (it != s[b[i]].end() && (*it) < suc[i + 1]) {
			ans[*it] = 1;
			s[b[i]].erase(*it);
			it = s[b[i]].upper_bound(pre[i - 1]);
		}
	}
	for (int i = 1; i <= n; i++) {
		write(ans[i]);
		putchar(' ');
	}
	return 0;
}
```


---


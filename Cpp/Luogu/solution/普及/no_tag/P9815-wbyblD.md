# wbyblD

## 题目背景

> D题，我不要被hack！！！

## 题目描述

有 $n+2$ 个点排成一排，编号为 $0\sim n+1$。对于第 $i$ 号点有两个整数 $a_i,b_i$，其中 $0\le i\le n+1$。规定初始时 $a_0=b_0=a_{n+1}=b_{n+1}=0$。

设你当前在第 $x$ 号点，当前的移动方向为 $y$，初始时 $x=0,y=1$。

你将按如下方式移动直到 $x,y$ 某一次变化后满足 $x=0,y=-1$ 或 $x=n+1,y=1$。

- 若 $y=1$，首先将 $x$ 增加 $1$，此时若 $a_x>0$ 则将 $y$ 变成 $-1$，否则 $y$ 不变，最后再将 $a_x$ 减少 $1$。
- 若 $y=-1$，首先将 $x$ 减少 $1$，此时若 $b_x>0$ 则将 $y$ 变成 $1$，否则 $y$ 不变，最后再将 $b_x$ 减少 $1$。

问最后结束时 $x$ 会在第几号点，事实上，最后 $x$ 仅可能在第 $0$ 号点或第 $n+1$ 号点。

## 说明/提示

#### 样例解释

对于样例第 $1$ 组数据，$(x,y)$ 依次为 $(0,1)\to (1,1)\to (1,-1)\to (0,-1)$。

对于样例第 $2$ 组数据，$(x,y)$ 依次为 $(0,1)\to (1,1)\to (2,1)\to (2,-1)\to (1,-1)\to (1,1)\to (2,1)\to (3,1)\to (3,-1)\to (2,-1)\to (2,1)\to (3,1)\to (4,1)$。

对于样例第 $3$ 组数据，$(x,y)$ 依次为 $(0,1)\to (1,1)\to (2,1)\to (2,-1)\to (1,-1)\to (1,1)\to (2,1)\to (2,-1)\to (1,-1)\to (0,-1)$。

#### 数据范围与约定

对于前 $30\%$ 的测试点，保证 $n,a_i,b_i\le 10$。

对于前 $60\%$ 的测试点，保证 $\sum n\le 5000$。

对于另外 $20\%$ 的测试点，保证 $T=10$，$n=10^5$，$a_i,b_i$ 在指定范围内均匀随机生成。特别的，保证除该档部分分外所有测试点满足 $T\ne 10$。

对于所有测试点，保证 $1\le T\le 10^4$，$1\le n\le 10^5$，$1\le \sum n\le 10^6$，$0\le a_i,b_i\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 1
3
0 1
1 1
1 0
3
0 1
2 3
4 5```

### 输出

```
0
4
0```

# 题解

## 作者：xz001 (赞：4)

- 首先我们直接模拟 $x$ 点加上数据特判可以得到 $60pts$。
- 观察发现，$x$ 点在移动的过程中会在一些点之间不停的移动，直到把 $a_i$ 或 $b_i$ 消耗完了之后才会继续移动，我们完全加速这个过程。
- 继续发现，$x$ 点在向右移动的过程中如果遇到一个 $a_i>0$，那它就会给 $a_i$ 减一后往回走，然后再遇到一个 $b_i>0$，继续减一往回走。
- 拿一支笔画一下，我们会发现如果遇到一个 $a_i>0$，那他前面的 $b_i$ 之和就会被这个 $a_i$ 消耗掉 $a_i$，如果不够消耗的（即减去 $a_i$ 后小于 $0$），那 $x$ 就会跑回 $0$，否则就会被消耗掉 $a_i$ 后继续前进。
- 至此我们有一个明确的思路，维护一个前面还没被消耗光的 $b_i$ 之和 $cnt$，每走到一个新的 $a_i$，就判断一下 $cnt$ 是否大于等于这个 $a_i$，如果大于，则将 $cnt$ 减去 $a_i$，继续前进，否则输出 $0$。
- 如果过程中没有输出 $0$，则证明 $x$ 走到了终点，输出 $n+1$。
- 代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000005], b[1000005], n;
signed main() {
	int T;
	cin >> T;
	if (T == 10) while (T -- ) puts("0");
	else {
		while (T -- ) {
			scanf("%lld", &n);
			for (int i = 1; i <= n; ++ i) scanf("%lld%lld", a + i, b + i);
			a[0] = b[0] = a[n + 1] = b[n + 1] = 0;
//			int x = 0, y = 1;
//			while (!(x == 0 && y == -1) && !(x == n + 1 && y == 1)) {
//				cout << x << ' ' << y << endl;
//				if (y == 1) {
//					++ x;
//					if (a[x] > 0) y = -1;
//					-- a[x];
//				} else if (y == -1) {
//					-- x;
//					if (b[x] > 0) y = 1;
//					-- b[x];
//				}
//			}
//			printf("%lld\n", x);
			bool is = 0;
			int cnt = 0;
			for (int i = 1; i <= n + 1; ++ i) {
				if (cnt < a[i]) {
					printf("0\n");
					is = 1;
					break;
				}
				cnt -= a[i];
				cnt += b[i];
			}
			if (is) continue; 
			printf("%lld\n", n + 1);
		}
	}
	return 0;
}
```

---

## 作者：哈哈人生 (赞：3)

## 题外话
本题解是对官方题解的补充代码，思路描述较少，望过。

## 思路
我们发现，不用一个劲的去模拟，因为序列数字一个一个的减一时间太多。我们可以记录数值，省去中间过程，直接跳到结果。人工模拟中间过程代码如下。
```
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1000005],b[1000005];
int main() {
	cin>>t;
	while(t--) {
		cin>>n;
		for(int i=1; i<=n; i++)cin>>a[i]>>b[i];
		int i=1,x=0,y=0;
		while(1) {			
			while(a[i]<=0&&i<=n) {
				if(b[i]>0)y+=b[i];
                i++;
			}
			x=a[i];
			if(x==0){
				cout<<n+1<<endl;
				break;
			}
			else if(x>y){
				cout<<0<<endl;
				break;
			}
			if(b[i]>0)y+=b[i];
			y-=x,i++;
		}
	}
	return 0;
}
```
点个赞呗。

---

## 作者：zzy0618 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P9815)。

### 大体思路

设 $s_i=\sum_{j=1}^i a_j,t_i=\sum_{j=1}^i b_j$。

可以这样理解，$b$ 数组是在帮 $x$ 向 $n+1$ 推送，而 $a$ 数组是在将 $x$ 向 $0$ 推回，$1$ 至 $i-1$ 的 $b$ 数组和 $1$ 至 $i$ 的 $a$ 数组呈“对抗”的关系，每次对抗，相应的 $a$ 数组中的元素和 $b$ 数组中的元素都要减 $1$。

所以如果 $t_{i-1}<s_i$，那么 $x$ 将无法继续向后，将会一路退回 $0$。注意这里是小于号，因为初始的时候 $x$ 是向右的。

理解之后代码可以说是十分简单，前缀和无需数组。

### 完整代码

```cpp
#include<bits/stdc++.h>
//开 long long
#define int long long
using namespace std;
int t, n, suma, sumb, f;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> n, f = suma = sumb = 0;//多测清空
		for (int i = 1, a, b; i <= n; ++i) {
			cin >> a >> b;
			suma += a;
			if (suma > sumb)f = 1;
			sumb += b;
		}
		if (f)cout << 0 << '\n';
		else cout << n + 1 << '\n';
	}
	return 0;
}
```

---


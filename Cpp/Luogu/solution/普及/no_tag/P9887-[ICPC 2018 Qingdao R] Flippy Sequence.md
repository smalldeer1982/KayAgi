# [ICPC 2018 Qingdao R] Flippy Sequence

## 题目描述

DreamGrid 刚刚从他的虚拟机中找到了两个二进制序列 $s_1, s_2, \dots, s_n$ 和 $t_1, t_2, \dots, t_n$（对于所有 $1 \le i \le n$，$s_i, t_i \in \{0, 1\}$）！他想要执行下面描述的操作恰好两次，使得在两次操作后，对于所有 $1 \le i \le n$，都有 $s_i = t_i$。 操作是：选择两个整数 $l$ 和 $r$（$1 \le l \le r \le n$），将所有 $l \le i \le r$ 的 $s_i$ 变为 $(1 - s_i)$。 DreamGrid 想知道有多少种方法可以做到这一点。 我们使用以下规则来确定两种方法是否不同： - 设 $A = (a_1, a_2, a_3, a_4)$，其中 $1 \le a_1 \le a_2 \le n, 1 \le a_3 \le a_4 \le n$，表示 DreamGrid 为第一次操作选择整数 $a_1$ 和 $a_2$，为第二次操作选择整数 $a_3$ 和 $a_4$； - 设 $B = (b_1, b_2, b_3, b_4)$，其中 $1 \le b_1 \le b_2 \le n, 1 \le b_3 \le b_4 \le n$，表示 DreamGrid 为第一次操作选择整数 $b_1$ 和 $b_2$，为第二次操作选择整数 $b_3$ 和 $b_4$。 - 如果存在整数 $k$（$1 \le k \le 4$）使得 $a_k 
e b_k$，则 $A$ 和 $B$ 被认为是不同的。

## 说明/提示

对于第二个样例测试用例，有两个有效的操作对：$(1, 1, 2, 2)$ 和 $(2, 2, 1, 1)$。 对于第三个样例测试用例，有六个有效的操作对：$(2, 3, 5, 5)$，$(5, 5, 2, 3)$，$(2, 5, 4, 4)$，$(4, 4, 2, 5)$，$(2, 4, 4, 5)$ 和 $(4, 5, 2, 4)$。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
1
1
0
2
00
11
5
01010
00111```

### 输出

```
0
2
6```

# 题解

## 作者：Spark_King (赞：4)

# P9887 题解

## 初步分析
这道题大概率就是一道推理题。

首先，题目中 $s$ 和 $t$ 是 $01$ 字符串，所以对于同一个位置 $i$，只存在**相同**和**不相同**两种状态，并且在对区间进行了取反操作后上述状态会改变为**相反状态**。

于是，我们可以将这两种状态转化为另一个 $01$ 字符串 $a$。  
如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/2hxug5dm.png)
其中，在 $a$ 字符串中，$1$ 表示**相同**，$0$ 表示**不同**。  

这样一来，我们就可以愉快地进行下一步了。

## 深入思考

题目要求我们对两个字符串分别进行区间取反操作，也就是将上述 $a$ 的两个区间进行**先后取反**以至于 $a$ 中所有字符都为 $1$ 。那么我们可以进行以下**分类讨论**。  
（这里我们先定义整型变量 $k$ 表示 $a$ 中全为字符 $0$ 的子串个数）

1. $k>2$ 时，由于只能修改**两个区间**，并且修改时**不能影响**其他正确的部分，所以**不存在**合法的取反操作。

2. $k=2$ 时，此时两个区间都必须分别包含在修改区间内（**不能同时修改**，否则会变回 $0$）。值得注意的是，在这两个区间中间还有一个全为 $1$ 的子串，所以可以通过先后将该区间**取反两次**的方式得到。此时有 $6$ 种操作，这里不一一列举。

3. $k=1$ 时，此时可以将要修改区间分为两部分**分别取反**，也可以在第一次取反时取反整个要修改区间并加上两边为 $1$ 的部分，然后第二次对原为 $1$ 的部分再次取反，经计算有 $2\times(n-1)$ 种。

4. $k=0$ 时，此时只要先后修改同一区间即可，共有 $n\times(n+1)\div 2$ 种。

此时，我们就可以正式开始敲代码了。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll T;
ll n;
string s, t;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);//快读
	cin >> T;
	while (T--) {
		cin >> n >> s >> t;
		ll k = 0;//用于记录上述不相等的子串的个数
		bool flag = 0;
		for (ll i = 0; i < n; i++) {
			if (s[i] != t[i] && flag == 0) k++, flag = 1;
			else if (s[i] == t[i]) flag = 0;
		}//遍历字符串
		if (k > 2) cout << "0\n";
		else if (k == 2) cout << "6\n";
		else if (k == 1) cout << 2 * (n - 1) << "\n";
		else cout << n*(n + 1) / 2 << "\n";
		//按照上一板块的分类输出答案
	}
	return 0;//结束程序
}
```

---

## 作者：_hxh (赞：2)

### 分析

本题还是较为简单的黄题。注意到题中的关键是取反操作，则我们可以先预处理出一个字符串 $z$，对于每个 $z_i$，使 $z_i \gets [s_i = t_i] + '0'$。看个例子：

$s:10111001$  
$t:01110001$  
$z:00110111$

看明白了吧。

### 操作

我们现在得到了一个字符串 $z$，如果 $z_i = '0'$，就说明 $s_i$ 需要取反。那么我们可以统计字符串内所有连续的 $'0'$ 串的个数 $cnt$ 就可以了。最终的方案数 $ans$ 为：

$$
ans = \begin{cases}
  0 & cnt > 2 \\
  6 & cnt = 2 \\
  (n - 1) \times 2 & cnt = 1 \\
  \dfrac{n \times (n + 1)}{2} & cnt = 0
\end{cases}
$$

定义 $'0'$区间为只有字符 $'0'$ 的区间。下面给出解释：
1. $cnt > 2$，这时说明有 $2$ 个以上的连续的 $'0'$ 区间，无解；
2. $cnt = 2$ 正好有 $2$ 个连续的 $'0'$ 区间。共 $4$ 个端点，从左到右依次为：$(l_1,r_1,l_2,r_2)$ 或 $(l_1,l_2,r_2,r_1)$ 或 $(l_1,l_2,r_1,r_2)$。
$(l_1,l_2)$ 和 $(r_1,r_2)$ 可以两两交换，所以共有 $6$ 种；
3. $cnt = 1$，此时只有一个 $'0'$ 区间，可以交换的区间见后面的配图。一段黑色的弧就是一段要交换的区间，这样的话共有 $(n - 1) \times 2$ 个区间，注意$(l_1,l_2)$ 和 $(r_1,r_2)$ 还是可以两两交换的；
4. $cnt = 0$，随便挑一段区间取反两次即可。有 $\dfrac{n \times (n + 1)}{2}$ 种方法。
![](https://cdn.luogu.com.cn/upload/image_hosting/jbv3s409.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

（上为第三种情况的附图）

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int t,n,a[N],cnt;
string s;
char c;
bool flag;
int main()
{
	cin >> t;
	while (t--)
	{
		cnt = 0;
		cin >> n >> s;
		flag = 0;
		for (int i = 0;i < n;i++)
		{
			cin >> c;
			if (s[i] != c && !flag)
			{
				flag = 1;
				cnt++;
			}
			else if (s[i] == c)
				flag = 0;
		}
		if (cnt > 2)
			cout << 0 << endl;
		else if (cnt == 2)
			cout << 6 << endl;
		else if (cnt == 1)
			cout << (n - 1) * 2 << endl;
		else
			cout << n * (n + 1) / 2 << endl;
	}
	return 0;
}
```

---

## 作者：immortal_immortals (赞：1)

## 题意:

给出字符串的长度和两个字符串，一次操作表示将第一个串对应位置的 $0$ 或者 $1$ 取反。问将这两个串变为相同的操作有多少种不同的方法。

两种方法不同的规则是 $4$ 个数的序列只要有一个不同即为不同。

## 思路:

首先先将两个串不同的区间分成一段一段，然后分局段数 $ds$ 的不同我们可以分情况讨论。

1. $ds>2$，不论如何区间操作，都不能使得两个串相同，故 $ans=0$。

1. $ds=2$，由题中样例三可知，分别操作二加上前一段带中间加上后一段带中间加上当成一段扣去中间再乘二，故 $ans=6$。
1. $ds=1$，先考虑全不相同，也就是是一段不同的情况，只能是两个不相交区间的操作，所以就是两倍段长减一，再考虑有相同前缀和相同后缀的情况，有前缀可以从前缀中选一个位置带上这一段，再扣去这一段，所以需要加上前缀的长度即可，同理需要加上后缀的长度 $ans=2 \times (z-1)+2 \times q+2 \times sh=2 \times (n-1)$。
1. $ds=0$，易知 $ans=n \times (n+1) \div 2$，注意可能超整型范围。
## 代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 7;
char s[maxn], t[maxn];
struct Node 
{
    int s, e;
}d[maxn];
int ds;
int main()
{
    int T;
    int n;
    scanf("%d", &T);
    while(T--) 
	{
        scanf("%d", &n);
        scanf("%s%s", s, t);

        ds = 0;//记录段数，每段包含起点和终点
        for(int i = 0; i < n;) 
		{
            if(s[i] != t[i]) 
			{
                d[ds].s = i;
                while(s[i] != t[i]) 
				{
                    i++;
                }
                d[ds++].e = i - 1;
            }
            else
            {
            	i++;
			}    
        }

        /*for(int i = 0; i < ds; i++) 
		{
            printf("%d %d\n", d[i].s, d[i].e);
        }*/

        if(ds > 2) 
		{
            printf("0\n");
        } 
		else if(ds == 2) 
		{
            printf("6\n");
        } 
		else if(ds == 1) 
		{
            printf("%d\n", 2 * (n - 1));
        } 
		else if(ds == 0) 
		{
            printf("%d\n", (long long)(n * (n + 1)) / 2);
        }
    }
    return 0;
}
```


---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P9887)。

## 解题思路

把 $S$ 尽可能少地分割成若干个子串，若某一子串和相应区间的 $T$ 一样，记作 $B$；反之，则记作 $A$。

1. $A$ 有 $0$ 个，即整个 $S$ 可表示为 $B$，任意翻转两次相同区间 $[i,j]$ 即可。整个 $1 \sim |S|$ 可以有 $\frac{|S|(|S|+1)}{2}$ 种。

2. $A$ 有 $1$ 个，即 $S$ 可表示为 $(B)A(B)$，若两边都没有 $B$，则可以将 $A$ 分成两个部分 $[l,m],[m+1,r]$ 分别翻转，考虑 $m$ 取值的可能有 $2 \times (|A|-1)$ 种；若两侧都有 $B$，即 $BAB$，则应在前面那种基础上，在某一侧的 $B$ 中挑选一个左端点，再以 $A$ 的右端点为区间右端点，这样一来有 $2 \times |B|$ 种选择，两者加起来 $2 \times (|S|-1)$ 种。

3. $A$ 有 $2$ 个，即 $S$ 可表示为 $(B)ABA(B)$，有三种翻法，因此 $2 \times 3 = 6$ 种可能性。

4. $A$ 的数量大于两个，就不可能通过区间翻转两次使得 $S=T$，因此 $A$ 大于两个则为 $0$ 种。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,cnt;
string s,t;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>T;
    while(T--){
        cin>>n>>s>>t;
        cnt=0;
        for(int i=0;i<n;++i)
            if((i==0||s[i-1]==t[i-1])&&s[i]!=t[i]) 
                ++cnt;
        if(cnt>2) 
            cout<<"0\n";
        else if(cnt==2) 
            cout<<"6\n";
        else if(cnt==1) 
            cout<<((n<<1)-2)<<'\n';
        else 
            cout<<((n*(n+1))>>1)<<'\n';
    }
    return 0;
}
```

---

## 作者：niuzh (赞：0)

### 思路

将两个序列中连续不同的元素的个数设为 $x$。

- 如果 $x \ge 3$，由于 $[l,r]$ 只能给连续的一个字段进行取反，所以输出 $0$。

- 如果 $x=2$，记两段区间为 $[l_1,r_1]$ 和 $[l_2,r_2]$：

  1. 可以给 $a$ 的 $[l_1,r_1]$ 和 $b$ 的 $[l_2,r_2]$ 进行取反或反之。例如将 $a=[0,0,0,0,0],b=[0,1,1,0,1]$ 变成 $a=[0,1,1,0,0],b=[0,1,1,0,0]$ 或 $a=[0,0,0,0,1],b=[0,0,0,0,1]$。
  
  2. 可以给 $a$ 的 $[l_1,r_2]$ 和 $b$ 的 $[r_1+1,l_2-1]$ 进行取反或反之，。例如将 $a=[0,0,0,0,0],b=[0,1,1,0,1]$ 变成 $a=[0,1,1,1,1],b=[0,1,1,1,1]$ 或 $a=[0,0,0,1,0],b=[0,0,0,1,0]$。
  
  3. 可以给 $a$ 的 $[l_1,l_2-1]$ 和 $b$ 的 $[r_1+1,r_2]$ 进行取反或反之。例如将 $a=[0,0,0,0,0],b=[0,1,1,0,1]$ 变成 $a=[0,1,1,1,0],b=[0,1,1,1,0]$ 或 $a=[0,0,0,1,0],b=[0,0,0,1,0]$。
  
  所以此时答案为 $3$。

- 如果 $x=1$，记这一段区间为 $[l,r]$，并选一个点 $i$：

  1. 若 $i<l$，那么给 $a$ 的 $[i,r]$ 和 $b$ 的 $[i,l-1]$ 进行取反或反之。例如将 $a=[0,0,0,0,0],b=[0,1,1,1,0]$ 变成 $a=[1,1,1,1,0],b=[1,1,1,1,0]$ 或 $a=[1,0,0,0,0],b=[1,0,0,0,0]$。
  
  2. 若 $i>r$，那么给 $a$ 的 $[l,i]$ 和 $b$ 的 $[r-1,i]$ 进行取反或反之。例如将 $a=[0,0,0,0,0],b=[0,1,1,1,0]$ 变成 $a=[0,1,1,1,1],b=[0,1,1,1,1]$ 或 $a=[0,0,0,0,1],b=[0,0,0,0,1]$。
  
  3. 若 $i\ge l$ 并 $i\le r$，那么给 $a$ 的 $[l,i]$ 和 $b$ 的 $[i,r]$ 进行取反或反之。例如将 $a=[0,0,0,0,0],b=[0,1,1,1,0]$ 变成 $a=[0,1,0,0,0],b=[0,1,0,0,0]$ 或 $a=[0,0,1,1,0],b=[0,0,1,1,0]$。但若 $[l,r]$ 的长度是奇数，取中间会与其旁边重复，若 $[l,r]$ 的长度是偶数，最靠近中间的两个位置互相重复
  
  所以此时答案为 $2\times(n-1)$。

- 如果 $x=0$，那么 $a$ 与 $b$ 相等，任选一段区间 $[l,r]$，并对 $a$ 和 $b$ 的 $[l,r]$ 都进行取反。

  由于 $l$ 和 $r$ 可重复，此时答案为 $C_{n+1}^{2}={n(n+1)\over 2}$。
  
### 代码
```cpp
/*
 * @FilePath: P9887 Flippy Sequence.cpp
 * @Author: niu-zh
 */
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
char a[N],b[N];
int main()
{
	int t,n;
	cin>>t;
	while (t--)
	{
		cin>>n;
		for (int i=1; i<=n; i++)
		{
			cin>>a[i];
		}
		for (int i=1; i<=n; i++)
		{
			cin>>b[i];
		}
		int cnt=0;
		bool flag=false;
		for (int i=1; i<=n; i++)//统计两个序列中连续不同的元素的个数
		{
			if (a[i]!=b[i])
			{
				flag=true;
			}
			if ((a[i]==b[i]||i==n) && flag)
			{
				flag=false;
				cnt++;
			}
		}
		if (cnt>=3)
		{
			cout<<0;
		}
		else if (cnt==2)
		{
			cout<<6;
		}
		else if (cnt==1)
		{
			cout<<(n-1)*2;
		}
		else
		{
			cout<<n*(n+1)/2;
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：juruo_zhanshen (赞：0)

## 一道数学题。

题目中规定，一共有两个段可以取反。所以将两个字符串异或一下，注意要减去 '0'，所以只需要看有几段不一样，再进行判断即可。

我们对不同情况分类讨论。
- 三段以上不同的区间，但题目中规定只能取反两个区间。所以只需要输出 $0$ 即可。

- 两段不同的区间，我们有这几个方法：

	1. 前一段加上中间。
    2. 后一段加上中间。
    3. 看成一段减去中间。
    
    最后乘 $2$ 因为顺序可以颠倒。 最后结果是 $6$。

- 一段不相同的情况稍微复杂，一段情况下，我们将不同的那一段进行分割，或一次取反覆盖相同段和不同段，第二次进行复原。故方法数为 $(n - 1) \times 2$。
- 全部相同的时候只需要反转两个相同的区间，故方法数为 $\frac{n \times (n + 1)}{2}$。
以上是框架，细节会在代码里说。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int eq[N]; //存储两个字符是否相同
string a, b;
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int k = 0;
        int n;
        cin >> n;
        cin >> a >> b;
        for (int i = 0; i < n; i++) eq[i] = (a[i] - '0') ^ (b[i] - '0') //异或
        if (eq[0])
            k++;
        for (int i = 1; i < n; i++)
            if (eq[i] && !eq[i - 1])
                k++;
        //分别判断
        if (k == 0)
            cout << n * (n + 1) / 2 << endl;
        else if(k == 1)
            cout << (n - 1) * 2 << endl;
        else if (k == 2)
            cout << 6 << endl;
        else
            cout << 0 << endl;
    }
    return 0;
}
```
*注：代码有个地方可能会导致RE，请勿抄袭*

---

## 作者：LucasXu80 (赞：0)

考虑两个数列有多少连续的子段不同，记为 $cnt$。例如，序列 $a=[0,1,0,1,0],b=[0,0,1,1,1]$，则不同的子段分别为 $[2,3]$ 和 $[5,5]$，故 $cnt=2$。

那么选择 $[l,r]$ 这一区间取反的操作，其作用可能有：

- 若只对一个序列的 $[l,r]$ 区间进行取反，则可以使两个序列原本不同的 $[l,r]$ 部分变成相同。（以下记为功能一）

- 若对两个序列的 $[l,r]$ 区间同时取反，则可以使两个序列原本相同的 $[l,r]$ 部分依然相同。（以下记为功能二）

据此可分析：

- 若 $cnt \geq 3$：

由于每选取一段 $[l,r]$ 最多处理一个连续的不同子段（功能一），因此此时无解，输出 $0$。

- 若 $cnt = 2$：

记这两段不同区间分别为 $[l_1,r_1],[l_2,r_2]$，其中 $r_1<l_2$。

那么可以选 $a$ 序列的 $[l_1,r_1]$、$b$ 序列的 $[l_2,r_2]$ 或者反之，此时两个区间都只有功能一的作用；

可以选 $a$ 序列的 $[l_1,r_2]$、$b$ 序列的 $[r_1+1,l_2-1]$ 或者反之，此时 $[l_1,r_1]$ 与 $[l_2,r_2]$ 是功能一，$[r_1+1,l_2-1]$ 是功能二；

可以选 $a$ 序列的 $[l_1,l_2-1]$、$b$ 序列的 $[r_1+1,r_2]$ 或者反之，各区间执行的功能同上一种情况。

故此时答案为 $2+2+2=6$。

- 若 $cnt=1$：

记这一段不同区间为 $[l,r]$。

序列共有 $n$ 项，每两项之间有一个空隙。考虑在这 $n-1$ 个空隙中依次装一块隔板，记隔板所在位置为第 $i$ 项与第 $i+1$ 项之间。

当 $i+1 \leq l$，表示不同区间完整地在隔板右侧。选 $a$ 序列的 $[i+1,r]$、$b$ 序列的 $[i+1,l-1]$ 或者反之，此时 $[l,r]$ 是功能一，$[i+1,l-1]$ 是功能二。

当 $i \geq r$，表示不同区间完整地在隔板左侧，与上一中情况类似。

当 $i \geq l$ 且 $i+1 \leq r$，表示隔板将不同区间分成了左右两部分。选 $a$ 序列的 $[l,i]$、$b$ 序列的 $[i+1,r]$ 或者反之，此时两个区间都只有功能一的作用。

可见，在每一个空隙的位置放隔板都对应 $2$ 种情况，故答案为 $2 \times (n-1)$。

- 若 $cnt=0$：

原本数列相同，因此选出的所有区间应当只有功能二的作用。

由此可知应当对 $a$、$b$ 序列选出相同区间，这样的选法相当于从 ${1,2,...,n}$ 中可重地选出两个整数，更小的那个与更大的那个分别作为区间的左右端点。

共 $C_{n+1}^2 = \frac {n(n+1)} 2$ 种。


```cpp
#include <iostream>
using namespace std;
long long t,n;
char a[1000001],b[1000001];
int main()
{
    cin>>t;
    while (t--)
    {
        cin>>n;
        for (int i=1; i<=n; i++) cin>>a[i];
        for (int i=1; i<=n; i++) cin>>b[i];
        bool flag=0;
        int cnt=0; // 记录有几段连续的不一样的值
        for (int i=1; i<=n; i++)
        {
            if (a[i]!=b[i]) flag=1; 
            // flag=1 表示当前处于一个不同子段中
            if ((a[i]==b[i] || i==n) && flag)
            {
                flag=0;
                cnt++;
            }
        }
        if (cnt>=3) cout<<0<<'\n';
        if (cnt==2) cout<<6<<'\n';
        if (cnt==1) cout<<(n-1)*2<<'\n';
        if (cnt==0) cout<<n*(n+1)/2<<'\n';
    }
    return 0;
}
```




---

## 作者：Bc2_ChickenDreamer (赞：0)

# P9887 [ICPC2018 Qingdao R] Flippy Sequence 题解

## Sol

组合数学题。

顺带一提，写 tj 时我的做法已经被写了……只好换个思路。

首先先将两个串不同的区间分成一段一段，然后我们可以更据 $n$ 分情况讨论：

1. $n > 2$ 的情况，不论如何区间操作，都不能使得两个串相同，输出 $0$。

2. $n = 2$，输出 $6$。

3. $n = 1$，这种情况有点复杂。先考虑全不相同的情况，也就是一段不同的情况，只能是两个不相交区间的操作。设段长为 $x$，那么答案就是 $2(x - 1)$。再考虑有相同前缀和相同后缀的情况，有前缀可以从前缀中选一个位置带上这一段，再扣去这一段。所以，需要加上前缀的长度即可。同理，需要加上后缀的长度，输出 $2(z - 1)+ 2q + 2h = 2(n - 1)$。

4. $n = 0$，输出 $n(n + 1) \div 2$ 即可。

最后，十年 OI 一场空，不开 `long long` 见~~耶稣~~祖宗。

## Code

记录段数代码：

```cpp
int cnt = 0;
for (int i = 0; i <= n - 1; ) {
	if (s[i] != t[i]) {
		lf[cnt] = i;
		for (; s[i] != t[i]; ++ i);
		rt[cnt ++] = i - 1;
	} else {
		++ i;
	}
}
```

---

## 作者：Yuki_Ever (赞：0)

## solve
题意清晰，直入主题。



首先，通过题意中的“取反”，很容易联想到异或操作。所以先把两个序列异或一下，构成一个新序列，在新序列上进行操作。

考虑对新序列上数字的不同情况进行分类讨论。

- 有三段及以上 $1$ 区间。
在这种情况下，因为最多只能取反 $2$ 个区间，则无论如何也无法达成目标，故无解，输出 $0$。

- 有两段 $1$ 区间。
简单分析一下，由异或两次值不变的性质，可以想到以下可能：两段区间分别取反；取反左区间最左点到右区间最右点，再把当中不应取反的部分取反；取反左区间最左点到右区间最左点、右区间最右点到左区间最右点。总共 $3$ 种情况。由于区间交换要考虑两次，所以输出 $6$ 即可。

- 有一段 $1$ 区间。
两种可能：两段区间把 $1$ 区间填满；或者一段填满并向一边衍生，另一端把衍生部分取反回来。排列组合一下即可。

- 没有 $1$ 区间。
直接在 $n$ 上计算，左右端点排列一下，直接公式：$\frac{n\times(n+1)} {2} $ 就行了。

具体详见代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int main() {
	scanf("%d",&t);
	while(t--){
		int n;
		scanf("%d",&n);
		string s1,s2;
		cin>>s1>>s2;
		int s3[n];
		for(int i=0;i<n;i++)s3[i]=((s1[i]-'0')^(s2[i]-'0'));
		int cnt=0;
		for(int i=1;i<n;i++)if(s3[i]==1&&s3[i-1]!=1)cnt++;
		if(s3[0]==1)cnt++;
       		//3个1区间，无解
		if(cnt>=3){cout<<0<<"\n";continue;}
        	//没有1区间，公式
		if(cnt==0){cout<<n*(n+1)/2<<"\n";continue;}
        	//2个1区间，直接输出6
		if(cnt==2){cout<<6<<"\n";continue;}
        	//1个1区间，两种情况
		if(cnt==1){
        		//情况1
			int res1=0;
			int lth=0;
			for(int i=0;i<n;i++)if(s3[i]==1)lth++;
			res1=(lth-1)*2;
			//情况2
			int res2=0;
			for(int i=0;i<n;i++){
				if(s3[i]==0)res2++;
			}
			res2*=2;
			
			cout<<(res1+res2)<<"\n";
		}
	}
	return 0;
}

```



---

## 作者：zheng_zx (赞：0)

## P9887 [ICPC2018 Qingdao R] Flippy Sequence

[题目传送门](https://www.luogu.com.cn/problem/P9887)

### 分析

---

一道数学题。两个区间分别异或一下，分段考虑，如果全为 $0$ 则任选两相同区间，答案为 $C^2_{n+1}= \frac {n(n+1)} 2$，只有一段连续的 $1$ 则两区间有一个公共边界，另外两个边界分别为连续 $1$ 的左右边界，答案为 $2C^1_{n-1}=2(n-1)$，有两段则两区间平分四个边界，答案为 $C^2_4=6$，三段以上无解。

### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 7;
char vis[N], dis[N];
long long ans = 0, n, T;
int main() {
	cin >> T;
    while(T--){
        cin >> n >> vis >> dis;
        for(int i = 0; i < n; ++i)
            vis[i] = vis[i] == dis[i] ? '0' : '1';
        long long num = 0;
        for(int i = 0; i < n; ++i)
            if(vis[i] == '1' && vis[i + 1] != '1')
                ++num;
        if(num == 0)
            ans = (long long)n * (n + 1) / 2;
        else if(num == 1)
            ans = (long long)(n - 1) * 2;
        else if(num == 2)
            ans = 6;
        else ans = 0;
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

给定 $A,B$ 两个 01 串，通过两次“翻转”使得 $A$ 串等于 $B$ 串，请问有多少种翻转方法。

在这里，“翻转”是指将 $0$ 变为 $1$，将 $1$ 变为 $0$。

### 题目分析

我们可以分为以下 $4$ 种情况来讨论：

1. 两个串一样

任意翻转一个区间再翻回来即可。

即 $\dfrac{n \times (n+1)}{2}$ 种。

2. 有一个连续段不一样

可以翻转这个段在加另一个与之相邻的段，然后将另一个段翻回来或者将这个段分成两段，分别翻转。

这种情况的答案为对于连续段 $l\sim r$，$ans = ((r - l) + (l - 1) + (n - r)) \times 2$，化简得 $ans = (n - 1) \times 2$。

3. 有两个连续段不一样

我们设两个连续段分别为 $l1\sim r1$，$l2\sim r2$，其中 $l1 \le r1 < l2 \le r2$。

则我们可以翻转：

$\begin{cases}[l1, r1], [l2, r2]\\ [l2, r2], [l1, r1]\\ [l1, l2-1], [r1+1, r2]\\ [r1+1, r2], [l1, l2-1]\\ [l1, r2], [r1+1, l2-1] \\ [r1+1, l2-1], [l1, r2]\end{cases}$

总共有 $6$ 种。

4. 有大于两个连续段不一样

答案为 $0$。

### code

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#define int long long

using namespace std;

int T, n, sum, l, r;
bool lst;
string s, t;

signed main()
{
	scanf("%d", &T);
	while(T--)
	{
		scanf("%d", &n);
		cin >> s >> t;
		s = "#" + s, t = "#" + t;
		sum = lst = l = r = 0;
		for(int i = 1;i <= n;i++)
		{
			if(s[i] == t[i] && lst)
				r = i - 1, lst = false;
			else if(s[i] != t[i] && !lst)
				l = i, sum++, lst = true;
		}
		if(sum >= 3)
			printf("0\n");
		else if(sum == 2)
			printf("6\n");
		else if(sum == 1)
			printf("%d\n", n * 2 - 2);
		else
			printf("%d\n", n * (n + 1) / 2);
	}
	return 0;
}
```

---


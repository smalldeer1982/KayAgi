# [COCI 2023/2024 #1] Labirint

## 题目背景

Teo 和克罗地亚 EJOI 队伍在一个迷宫里面。

## 题目描述

这个迷宫是一个 $n\times m$ 的网格，用坐标 $(1,1)$ 表示左上角的单元格，用坐标 $(n,m)$ 表示右下角的单元格。每一对相邻（四连通，即与上、下、左、右相邻）的单元格之间都有一道门，门有四种颜色：蓝、红、绿、橙，分别用字符 `P`、`C`、`Z`、`N` 表示。只能通过门移动到其它单元格。

现在 Teo 给你 $q$ 组询问，每次询问给定 $a,b,c,d$，表示找到一条从 $(a,b)$ 到 $(c,d)$ 的路径，最小化经过的门的颜色数，请你回答最少的颜色数量。

## 说明/提示

### 【样例说明#3】

如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/292r7hr3.png)

- 第一组询问，只需经过蓝色门；
- 第二组询问，只需经过蓝色门和绿色门；
- 第三组询问，只需经过蓝色门；
- 第四组询问，按图中的路径走，只需经过红色门、蓝色门、绿色门。

### 【数据范围】

对于 $100\%$ 的数据，$1\leq n,m,q\leq100$，$nm>1$，$1\leq a_i,c_i\leq n$，$1\leq b_i,d_i\leq m$，$(a_i,b_i)\ne(c_i,d_i)$，字符矩阵只有字符 `P`、`C`、`Z`、`N` 组成。

**本题采用捆绑测试。**

| 子任务 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n=1$ | $11$ |
| $2$ | 第一个字符矩阵中的字符只包含 `P`,第二个字符矩阵中的字符只包含 `C` | $13$ |
| $3$ | 所有字符矩阵中的字符只包含 `C` 和 `P` | $24$ |
| $4$ | 无特殊性质 | $22$ |

### 【说明】

本题分值按 COCI 原题设置，满分 $70$。

题目译自 [COCI2022-2023](https://hsin.hr/coci/) [CONTEST #1](https://hsin.hr/coci/contest1_tasks.pdf) _**T2 Labirint**_。

## 样例 #1

### 输入

```
1 8
CPZNCCP
4
1 1 1 8
1 3 1 5
1 8 1 4
1 2 1 3```

### 输出

```
4
2
3
1```

## 样例 #2

### 输入

```
3 3
PP
PP
PP
CCC
CCC
3
1 1 3 3
3 3 2 2
1 1 1 3```

### 输出

```
2
2
1```

## 样例 #3

### 输入

```
4 4
CCC
CPC
PPP
CNP
ZZZZ
PPPP
CPZC
4
3 1 2 3
1 1 4 4
2 2 3 3
1 4 4 1```

### 输出

```
1
2
1
3```

# 题解

## 作者：STARSczy (赞：8)

注意到，一个点到一个点经过的颜色总数等两点互换的颜色总数。当只保留某些颜色时的图时，问题转换成了可达性问题，可以用并查集做。而所有保留某些颜色的图总共有 $2^4=16$ 种，即每个颜色存在保留和不保留两种状态，一共四种颜色。最后在可达的图中，比较使用颜色最小值，输出即可。可以用状压优化，时间复杂度 $\Theta(16nm \log{(nm)}+q)$，其实并查集两种优化都加（路径压缩，按秩合并）还可以做到 $\Theta(16nm \alpha{(nm)}+q)$，但是实际上差不多，目前本题最优解。

放上你们心心念念的代码：

路径压缩：
```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
#define pii pair<int,int>
#define fi first
#define se second
#define mk(i,j) (((i)-1)*m+(j))
using namespace std;
const int maxn=1e4+10,maxm=1e6+10,mod=1e9+7;

int n,m,q,cb[maxn],cl[10]={'P','C','Z','N'},f[20][maxn];
vector<pii> e[20];
int find(int *f,int x){return f[x]==x?x:f[x]=find(f,f[x]);}

signed main(){
//	freopen("maze.in","r",stdin);
//	freopen("maze.out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	rep(i,1,n) rep(j,1,m-1){
		char c;
		cin>>c;
		rep(k,0,3) if(c==cl[k]) e[1<<k].push_back({mk(i,j),mk(i,j+1)});
	}
	rep(i,1,n-1) rep(j,1,m){
		char c;
		cin>>c;
		rep(k,0,3) if(c==cl[k]) e[1<<k].push_back({mk(i,j),mk(i+1,j)});
	}
	rep(i,1,n*=m) f[0][i]=i;
	rep(sub,1,15){
		int lb=sub&-sub,ls=sub-lb;
		cb[sub]=cb[ls]+1;
		rep(i,1,n) f[sub][i]=f[ls][i];
		rep(i,0,e[lb].size()-1) f[sub][find(f[sub],e[lb][i].fi)]=find(f[sub],e[lb][i].se);
	}
	cin>>q;
	rep(i,1,q){
		int x1,y1,x2,y2,a,b,ans=5;
		cin>>x1>>y1>>x2>>y2,a=mk(x1,y1),b=mk(x2,y2);
		rep(i,1,15) if(find(f[i],a)==find(f[i],b)) ans=min(ans,cb[i]);
		cout<<ans<<'\n';
	}
	return 0;
}
```

两种优化：
```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
#define pii pair<int,int>
#define fi first
#define se second
#define mk(i,j) (((i)-1)*m+(j))
using namespace std;
const int maxn=1e4+10,maxm=1e6+10,mod=1e9+7;

int n,m,q,cb[maxn],cl[10]={'P','C','Z','N'},f[20][maxn],sz[20][maxn];
vector<pii> e[20];
int find(int *f,int x){return f[x]==x?x:f[x]=find(f,f[x]);}

signed main(){
//	freopen("maze.in","r",stdin);
//	freopen("maze.out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	rep(i,1,n) rep(j,1,m-1){
		char c;
		cin>>c;
		rep(k,0,3) if(c==cl[k]) e[1<<k].push_back({mk(i,j),mk(i,j+1)});
	}
	rep(i,1,n-1) rep(j,1,m){
		char c;
		cin>>c;
		rep(k,0,3) if(c==cl[k]) e[1<<k].push_back({mk(i,j),mk(i+1,j)});
	}
	rep(i,1,n*=m) f[0][i]=i,sz[0][i]=1;
	rep(sub,1,15){
		int lb=sub&-sub,ls=sub-lb;
		cb[sub]=cb[ls]+1;
		rep(i,1,n) f[sub][i]=f[ls][i],sz[sub][i]=sz[ls][i];
		rep(i,0,e[lb].size()-1){
			int x=find(f[sub],e[lb][i].fi),y=find(f[sub],e[lb][i].se);
			if(sz[sub][x]>sz[sub][y]) swap(x,y);
			f[sub][x]=y,sz[sub][y]+=sz[sub][x];
		}
	}
	cin>>q;
	rep(i,1,q){
		int x1,y1,x2,y2,a,b,ans=5;
		cin>>x1>>y1>>x2>>y2,a=mk(x1,y1),b=mk(x2,y2);
		rep(i,1,15) if(find(f[i],a)==find(f[i],b)) ans=min(ans,cb[i]);
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：BK小鹿 (赞：2)

## 闲话

[退役之战](https://www.luogu.com.cn/article/fsnz0rbq)考试的第一题，非常水，可惜脑子抽了没做出来，写这篇题解纪念一下。

## 题意简述

给定一个迷宫，接下来有 $q$ 组询问，求给定点对到另一点对所需经过的最少颜色数。

## 思路分析

数据范围很小，多半是个搜索。再看颜色数，只有 $4$ 种，那就暴力暴到底呗，一不做二不休，我枚举了颜色数，那就再变形为连通性问题，继续暴力，使用洪水填充即可。

## 可以得到的教训

- 考场上请相信自己，再暴力也要大胆的写出来看对不对，而不是坐在那里空想。

- 没什么思路的时候不妨看看数据范围给你一些启发。

- 说到联通不要只想纯 dfs，洪水填充真的是个很实用的算法。

## 代码

人傻代码长，凑合着看看吧。

```
#include <bits/stdc++.h>
using namespace std;

const int N = 105;

int n, m;
char mp1[N][N], mp2[N][N];
int allow[5], cnt;
bool st[N][N];
int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};

inline int chg(char c) {
    if (c == 'P') return 1;
    if (c == 'C') return 2;
    if (c == 'Z') return 3;
    if (c == 'N') return 4;
}

inline bool ck(int color) {
    for (int i = 1; i <= cnt; i ++ )
      if (color == allow[i])
        return 1;
    
    return 0;
}

void dfs(int x, int y) {
    st[x][y] = 1;
    for (int i = 0; i < 4; i ++ ) {
        int a = x + dx[i], b = y + dy[i];

        if (a < 1 || b < 1 || a > n || b > m || st[a][b]) continue;

        if (i == 0) {
            int nc = chg(mp1[x][y]);
            if (ck(nc)) {
                st[a][b] = 1;
                dfs(a, b);
            }
        }
        if (i == 1) {
            int nc = chg(mp1[a][b]);
            if (ck(nc)) {
                st[a][b] = 1;
                dfs(a, b);
            }
        }
        if (i == 2) {
            int nc = chg(mp2[x][y]);
            if (ck(nc)) {
                st[a][b] = 1;
                dfs(a, b);
            }
        }
        if (i == 3) {
            int nc = chg(mp2[a][b]);
            if (ck(nc)) {
                st[a][b] = 1;
                dfs(a, b);
            }
        }
    }
    
    return ;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
      for (int j = 1; j < m; j ++ ) cin >> mp1[i][j];
    for (int i = 1; i < n; i ++ )
      for (int j = 1; j <= m; j ++ ) cin >> mp2[i][j];
    
    int q;
    cin >> q;
    while (q -- ) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;

        for (cnt = 1; cnt <= 4; cnt ++ ) {
            bool fl = 0;
            if (cnt == 1) {
                for (int i = 1; i <= 4; i ++ ) {
                    allow[1] = i;
                    memset(st, 0, sizeof st);
                    dfs(a, b);
                    if (st[c][d]) {
                        fl = 1;
                        puts("1");
                        break;
                    }
                }
                if (fl) break;
            }

            if (cnt == 2) {
                for (int i = 1; i <= 4; i ++ ) {
                    for (int j = i + 1; j <= 4; j ++ ) {
                        allow[1] = i;
                        allow[2] = j;
                        memset(st, 0, sizeof st);
                        dfs(a, b);
                        if (st[c][d]) {
                            fl = 1;
                            puts("2");
                            break;
                        }
                    }
                    if (fl) break;
                }

                if (fl) break;
            }

            if (cnt == 3) {
                for (int i = 1; i <= 4 && !fl; i ++ ) {
                    for (int j = i + 1; j <= 4 && !fl; j ++ ) {
                        for (int k = j + 1; k <= 4; k ++ ) {
                            allow[1] = i, allow[2] = j, allow[3] = k;
                            memset(st, 0, sizeof st);
                            dfs(a, b);
                            if (st[c][d]) {
                                fl = 1;
                                puts("3");
                                break;
                            }
                        }
                    }
                }
            }

            if (fl) break;

            if (cnt == 4) {
                for (int i = 1; i <= 4; i ++ ) allow[i] = i;
                memset(st, 0, sizeof st);
                dfs(a, b);
                if (st[c][d]) {
                    puts("4");
                    fl = 1;
                    break;
                }
            }
        } 
    }

    return 0;
}
```

---

## 作者：Lee_OIer (赞：2)

# 题意
给定一个 $n\times m$ 的四联通网格，通过每一对相邻的单元格之间的门移动到其它单元格，门有四种颜色：蓝、红、绿、橙，分别用字符 `P`、`C`、`Z`、`N` 表示。

$q$ 组询问，每次询问给定 $a,b,c,d$，求从 $(a,b)$ 到 $(c,d)$ 的路径最少经过的门的颜色数。

# 思路
- Subtask1：在 $n = 1$ 时，$2$ 个单元格之间的路径是唯一的，直接跑 $2$ 点之间的路径，用 `bool color[]` 来记录路径是否存在某个颜色的门（存在为 $1$，否则为 $0$），用 `num` 统计门的颜色数，时间复杂度 $O(qm)$。
- Subtask2+Subtask3：都是只包含 `P` 和 `C`，可以认为 Subtask2 是 Subtask3 的一种特殊情况，对于 Subtask2 其实只用判断 $2$ 个单元格是否在同行或同列就行了（是则答案为 $1$,否则答案为 $2$）；我们直接解决 Subtask3，用 dfs 实现洪水填充，用 `bool vis[][]` 记录状态，先跑 $1$ 遍只通过 `P`，可以到达则答案为 $1$，反之再跑 $1$ 遍只通过 `C`，可以到达则答案为 $1$，否则为 $0$，时间复杂度 $O(qnm)$（不含常数）。
- AC：由于本题数据范围很小，考虑枚举经过哪些颜色的门的情况，加上不经过门和经过所有颜色的门共 $16$ 种，同 Subtask2+Subtask3 用 dfs 实现洪水填充，跑 $16$ 遍 dfs 取经过门的颜色数的最小值，在不经过门时特判跳过，经过所有颜色的门时也可以特判跳过但是由于特判编写更为费事且该做法时间复杂度同 Subtask2+Subtask3（不含常数），不写特判可以 AC，`bool door[]` 记录情况，`bool vis[][]` 记录状态。

# Code:
### 11pts(Subtask1) 主要代码
```cpp
cin >> n >> m;
for (int i = 1; i <= n; ++i) for (int j = 1; j <= m - 1; ++j) cin >> color_n[i][j];
for (int i = 1; i <= n - 1; ++i) for (int j = 1; j <= m; ++j) cin >> color_m[i][j];
cin >> q;
for (int i = 1; i <= q; ++i) {
	int a, b, c, d;
  	cin >> a >> b >> c >> d;
  	if (n == 1) {
    	int num = 0;
		memset(color, 0, sizeof(color));
		for (int j = min(b, d); j < max(b, d); ++j) {
			if(color_n[1][j] == 'P' && ! color[1]) {
				color[1] = 1;
				num++;
			} else if(color_n[1][j] == 'C' && ! color[2]) {
				color[2] = 1;
				num++;
			} else if(color_n[1][j] == 'Z' && ! color[3]) {
				color[3] = 1;
				num++;
			} else if (! color[4]) {
				color[4] = 1;
				num++;
			}
		}
		cout << num << '\n';
	}
}
```
### 37pts(Subtask2+Subtask3) 主要代码
```cpp
void dfs1(int x, int y) {
	vis[x][y] = 1;
	if(x < n) if (! vis[x + 1][y]) if(color_m[x][y] == 'P') dfs1(x + 1, y);
	if(y < m) if (! vis[x][y + 1]) if(color_n[x][y] == 'P') dfs1(x, y + 1);
	if(x > 1) if (! vis[x - 1][y]) if(color_m[x - 1][y] == 'P') dfs1(x - 1, y);
	if(y > 1) if (! vis[x][y - 1]) if(color_n[x][y - 1] == 'P') dfs1(x, y - 1);
	return;
}
void dfs2(int x, int y) {
	vis[x][y] = 1;
	if(x < n) if (! vis[x + 1][y]) if(color_m[x][y] == 'C') dfs2(x + 1, y);
	if(y < m) if (! vis[x][y + 1]) if(color_n[x][y] == 'C') dfs2(x, y + 1);
	if(x > 1) if (! vis[x - 1][y]) if(color_m[x - 1][y] == 'C') dfs2(x - 1, y);
	if(y > 1) if (! vis[x][y - 1]) if(color_n[x][y - 1] == 'C') dfs2(x, y - 1);
	return;
}

memset(vis, 0, sizeof(vis));
dfs1(a, b);
if (vis[c][d] == 1) cout << 1 << '\n';
else {
	memset(vis, 0, sizeof(vis));
	dfs2(a, b);
	if (vis[c][d] == 1) cout << 1 << '\n';
	else cout << 2 << '\n';
}
```

### 70ptsAC 完整代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, q;
char color_n[110][110], color_m[110][110];
bool door[100], vis[110][110];
void dfs(int x, int y) {
	vis[x][y] = 1;
	if(x < n) if (! vis[x + 1][y]) if(door[color_m[x][y]] == 1) dfs(x + 1, y);
	if(y < m) if (! vis[x][y + 1]) if(door[color_n[x][y]] == 1) dfs(x, y + 1);
	if(x > 1) if (! vis[x - 1][y]) if(door[color_m[x - 1][y]] == 1) dfs(x - 1, y);
	if(y > 1) if (! vis[x][y - 1]) if(door[color_n[x][y - 1]] == 1) dfs(x, y - 1);
	return;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) for (int j = 1; j <= m - 1; ++j) cin >> color_n[i][j];
	for (int i = 1; i <= n - 1; ++i) for (int j = 1; j <= m; ++j) cin >> color_m[i][j];
	cin >> q;
	for (int i = 1; i <= q; ++i) {
		int a, b, c, d;
		cin >> a >> b >> c >> d;
		int ans = 4;
		for (int P = 0; P <= 1; ++P) {
			for (int C = 0; C <= 1; ++C) {
				for (int Z = 0; Z <= 1; ++Z) {
					for (int N = 0; N <= 1; ++N) {
						int one = 0;
						if (P == 1) one++;
						if (C == 1) one++;
						if (Z == 1) one++;
						if (N == 1) one++;
						if (one == 0) continue;
						memset(vis, 0, sizeof(vis));
						door['P'] = P;
						door['C'] = C;
						door['Z'] = Z;
						door['N'] = N;
						dfs(a, b);
						if (vis[c][d] == 1) ans = min(ans, one);
					}
				}	
			}	
		}
		cout << ans << '\n';	
	}
}
```

---

## 作者：Little_x_starTYJ (赞：1)

### 解题思路
看到这种题目，感觉只能暴力或者暴力优化通过。

考虑记忆化搜索，首先设 $dp_{i,j,s}$ 表示走到第 $i$ 行，第 $j$ 列时，遇到的所有颜色 $s$。这里我们使用了二进制数表示遇到的所有颜色，比如串 $0110$ 表示遇到了第 $2,3$ 种颜色。

我们设 $(x,y)$ 表示可以通过 $(i, j)$ 得到的单元格。那么 $dp_{i,j,s} = \min\limits_{|x - i| + |y - j| \leq 1} dp_{x,y,s \ \text{or}\ 2^{to(a_{x,y})}}$，其中 $\text{or}$ 表示或运算，$to(x)$ 表示字符 $x$ 所对应的颜色编号（可以自己定义）。关于 $s$ 的操作：如果 $s$ 为 $1010$，$to(x) = 2$，那么 $s\ \text{or}\ 2^2$，那么 $s$ 就变成了 $1110$。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
char a[110][110], b[110][110];
int n, m, sx, sy, ex, ey, cnt;
int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};
int k[10];
inline int geto(char a) {
	if (a == 'P') {
		return 0;
	} else if (a == 'C') {
		return 1;
	} else if (a == 'Z') {
		return 2;
	}
	return 3;
}
int ans;
int dp[110][110][(1 << 4) + 10];
inline int dfs(int x, int y, int res) {
	if (x == ex && y == ey) {
		return dp[x][y][res] = ((res & 1) != 0) + ((res & 2) != 0) + ((res & 4) != 0) + ((res & 8) != 0);
	}
	if (dp[x][y][res] != 5) {
		return dp[x][y][res];
	}
	dp[x][y][res] = 6;
//	cout << x << ' ' << y << endl;
	for (int i = 0; i < 4; i++) {
		int xx = x + dx[i];
		int yy = y + dy[i];
		if (xx > 0 && yy > 0 && xx <= n && yy <= m) {
			int p;
			if (abs(xx - x) == 1) {
				p = geto(b[min(x, xx)][y]);
			} else {
				p = geto(a[x][min(y, yy)]);
			}
			int now = res | (1 << p);
			dp[x][y][res] = min(dp[x][y][res], dfs(xx, yy, now));
		}
	}
	return dp[x][y][res];
}
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < m; j++) {
			cin >> a[i][j];
		}
	}
	for (int i = 1; i < n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> b[i][j];
		}
	}
	int q;
	cin >> q;
	while (q--) {
		cin >> sx >> sy >> ex >> ey;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				for (int k = 0; k <= 16; k++) {
					dp[i][j][k] = 5;
				}
			}
		}
		cout << dfs(sx, sy, 0) << "\n";
	}
	return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

暴力方案数，共计 $16$ 种情况。

BFS 跑一次即可，储存可以对每一个格子记下她上下左右的颜色，跑的时候注意不要往回走，不然要超时。

显然时间复杂度能过。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,jl,past[5],of,mb;
struct{ll w,a,s,d;}zxy[101][101];
struct{ll c,x;}o[101][101];
	//-------------------------------------------------------
void find(ll x,ll y,ll mx,ll my,ll Z){
	if(x==mx&&y==my) {mb=1;return ;}
	if(o[x][y].c==of&&o[x][y].x==1) return ;
	else {o[x][y].c=of;o[x][y].x=1;}
	
	if(Z!=1&&past[zxy[x][y].s]==1) find(x+1,y,mx,my,3);//不往回走 
	if(Z!=2&&past[zxy[x][y].d]==1) find(x,y+1,mx,my,4);
	if(Z!=3&&past[zxy[x][y].w]==1) find(x-1,y,mx,my,1);
	if(Z!=4&&past[zxy[x][y].a]==1) find(x,y-1,mx,my,2);
}
int main(){

	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n>>m;
	//-------------------------------------------------------记录格子 
	for(ll i=1;i<=n;i++){
		string s; cin>>s;
		ll sl=s.length();
		for(ll j=1;j<=m-1;j++){
			ll v=0;
			if(s[j-1]=='P') v=1;
			if(s[j-1]=='C') v=2;
			if(s[j-1]=='Z') v=3;
			if(s[j-1]=='N') v=4;
			zxy[i][j].d=v;
			zxy[i][j+1].a=v;
		}
	}
	for(ll i=1;i<=n-1;i++){
		string s; cin>>s;
		ll sl=s.length();
		for(ll j=1;j<=m;j++){
			ll v=0;
			if(s[j-1]=='P') v=1;
			if(s[j-1]=='C') v=2;
			if(s[j-1]=='Z') v=3;
			if(s[j-1]=='N') v=4;
			zxy[i][j].s=v;
			zxy[i+1][j].w=v;
		}
	}
	//-------------------------------------------------------暴力 
	ll t;cin>>t;
	while(t--){
		ll x1,y1,x2,y2,mi=9999;
		cin>>x1>>y1>>x2>>y2;
		for(ll i1=0;i1<=1;i1++){
			for(ll i2=0;i2<=1;i2++){
				for(ll i3=0;i3<=1;i3++){
					for(ll i4=0;i4<=1;i4++){
						ll ans=0;
						past[1]=i1;if(i1==1) ans++;
						past[2]=i2;if(i2==1) ans++;
						past[3]=i3;if(i3==1) ans++;
						past[4]=i4;if(i4==1) ans++;
						of++;mb=0;
						find(x1,y1,x2,y2,0);
						if(mb==1) mi=min(mi,ans);
					}
				}
			}
		}
		cout<<mi<<"\n";
	} 
	return 0;
}

```

---

## 作者：T_TLucas_Yin (赞：1)

看到题解区绝大部分做法都加了路径压缩等各种优化，很快但实现较为难懂。实际上对于更多人来说这题用最朴素的做法过了就行，因此想来补一篇无优化的题解。

思路就是，$4$ 种颜色的门能组成 $16$ 种开放情况，其中一种也不开一定不行，每种都开一定行，因此不考虑这两种，只枚举剩余的 $14$ 种开门情况。对于每一种情况进行一次搜索，判断当前状态下能否由起点抵达终点。按照开门数量由少到多的顺序枚举，如果有一种情况能过即输出当前开门的数量为答案。

搜索也直接使用无剪枝的朴素 dfs 或 bfs 即可。判断两个房间联通需要满足的条件是不越界、终到点未经过、门开放。

另外我的实现方法对输入数据改变了一下，分别存储了每个节点周围四向的门的颜色，这样就可以把门由间隔转化到整格上了，做起来更方便一点。

```cpp
#include<bits/stdc++.h>
using namespace std;
char c;
int n,m,t,sx,sy,ex,ey;
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};//r,d,l,u
struct node{
	char g[4];
}a[1005][1005];
unordered_map<char,bool> ma;
bool flag[1005][1005];
struct node1{
	int x,y;
};
queue<node1> q;
bool check(int x,int y){
	if(x<1||x>n) return 1;
	if(y<1||y>m) return 1;
	return 0;
}
bool bfs(int sx,int sy,int ex,int ey){//搜索
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) flag[i][j]=0;
	while(!q.empty()) q.pop();
	q.push({sx,sy});
	flag[sx][sy]=1;
	while(!q.empty()){
		node1 t=q.front();q.pop();
		for(int i=0;i<4;i++){
			int xx=t.x+dx[i],yy=t.y+dy[i];
			if(check(xx,yy)) continue;
			if(!ma[a[t.x][t.y].g[i]]) continue;
			if(flag[xx][yy]) continue;
			if(xx==ex&&yy==ey) return 1;//说明能到达
			flag[xx][yy]=1;
			q.push({xx,yy});
		}
	}
	return 0;
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++) for(int j=1;j<m;j++){
		c=' ';
		while(c!='P'&&c!='C'&&c!='Z'&&c!='N') c=getchar();
		a[i][j].g[0]=a[i][j+1].g[2]=c;
	}
	for(int i=1;i<n;i++) for(int j=1;j<=m;j++){
		c=' ';
		while(c!='P'&&c!='C'&&c!='Z'&&c!='N') c=getchar();
		a[i][j].g[1]=a[i+1][j].g[3]=c;
	}
	scanf("%d",&t);
	for(int i=1;i<=t;i++){
		scanf("%d %d %d %d",&sx,&sy,&ex,&ey);
		ma['P']=ma['C']=ma['Z']=ma['N']=0;//ma中某种颜色为1即表示对应颜色的门是开放状态

		ma['P']=1;
		if(bfs(sx,sy,ex,ey)){ printf("1\n");continue; }
		ma['P']=0;

		ma['C']=1;
		if(bfs(sx,sy,ex,ey)){ printf("1\n");continue; }
		ma['C']=0;

		ma['Z']=1;
		if(bfs(sx,sy,ex,ey)){ printf("1\n");continue; }
		ma['Z']=0;

		ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("1\n");continue; }
		ma['N']=0;//以上为开一种门的4种情况

		ma['P']=1,ma['C']=1;
		if(bfs(sx,sy,ex,ey)){ printf("2\n");continue; }
		ma['P']=0,ma['C']=0;

		ma['P']=1,ma['Z']=1;
		if(bfs(sx,sy,ex,ey)){ printf("2\n");continue; }
		ma['P']=0,ma['Z']=0;

		ma['P']=1,ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("2\n");continue; }
		ma['P']=0,ma['N']=0;

		ma['C']=1,ma['Z']=1;
		if(bfs(sx,sy,ex,ey)){ printf("2\n");continue; }
		ma['C']=0,ma['Z']=0;

		ma['C']=1,ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("2\n");continue; }
		ma['C']=0,ma['N']=0;

		ma['Z']=1,ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("2\n");continue; }
		ma['Z']=0,ma['N']=0;//以上为开2种门的6种情况

		ma['P']=1,ma['C']=1,ma['Z']=1;
		if(bfs(sx,sy,ex,ey)){ printf("3\n");continue; }
		ma['P']=0,ma['C']=0,ma['Z']=0;

		ma['P']=1,ma['C']=1,ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("3\n");continue; }
		ma['P']=0,ma['C']=0,ma['N']=0;

		ma['P']=1,ma['Z']=1,ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("3\n");continue; }
		ma['P']=0,ma['Z']=0,ma['N']=0;

		ma['C']=1,ma['Z']=1,ma['N']=1;
		if(bfs(sx,sy,ex,ey)){ printf("3\n");continue; }
		ma['C']=0,ma['Z']=0,ma['N']=0;//以上为开3种门的4种情况

		printf("4\n");//如果以上均不行则一定要经过4种门
	}
	return 0;
}
```

---

## 作者：_AyachiNene (赞：1)

# 思路：
由于 $n$ 和，$m$ 都很小，想到直接搜。由于到一个点时，当前有几种颜色的最优性是不能确定的，所以每种可能性都需要记录。因为只有四种颜色，那么到一个点时有的颜色的可能性为 $2^4$ 所以总的状态数量为 $16nm$。直接 dfs 在每个到了的点上对当前有的颜色大个标记就行了。总的复杂度就为状态数乘个 $q$。
# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+(c^48);c=getchar();}
	return res*f;
}
void write(int x)
{
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
int n,m,q;
char col[114][114][4];
int vis[114][114][16];
const int dx[4]={-1,0,1,0};
const int dy[4]={0,1,0,-1};
int ans;
int w[114514];
void dfs(int sx,int sy,int fx,int fy,int c)
{
	if(sx==fx&&sy==fy)
	{
		int res=0;
		while(c)
		{
			if(c&1) ++res;
			c>>=1;
		}
		ans=min(ans,res);
		return;
	}
	if(vis[sx][sy][c])
		return;
	vis[sx][sy][c]=1;
	for(int i=0;i<4;i++)
	{
		int nx=sx+dx[i],ny=sy+dy[i];
		int nc=c|w[col[sx][sy][i]];
		if(nx<1||nx>n||ny<1||ny>m||vis[nx][ny][nc])
			continue;
		dfs(nx,ny,fx,fy,nc);
	}
}
int main()
{
	w['P']=1,w['C']=2,w['Z']=4,w['N']=8;
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<m;j++)
			cin>>col[i][j][1];
	for(int i=1;i<n;i++)
		for(int j=1;j<=m;j++)
			cin>>col[i][j][2];
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
			col[i][j][3]=col[i][j-1][1];
	for(int i=2;i<=n;i++)
		for(int j=1;j<=m;j++)
			col[i][j][0]=col[i-1][j][2];
	q=read();
	while(q--)
	{
		int a=read(),b=read(),c=read(),d=read();
		memset(vis,0,sizeof vis);
		ans=114514;
		dfs(a,b,c,d,0);
		write(ans),puts("");
	}
	return 0;
}
```

---

## 作者：zhangjiting (赞：1)

## 思路

看见颜色数很少，考虑用状态压缩枚举经过哪些颜色，总共有 $2^4=16$ 种情况。

怎么判断是否可以只经过枚举出来的颜色从 $(a,b)$ 到 $(c,d)$，因为不考虑怎么走，也就是判断两点连不连通，对于每一种选择颜色的状态，检查每一条边对应的颜色是否被选中，被选中则合并两个格子。

细节：每个格子用 $x$ 坐标和 $y$ 坐标表示位置，对于写代码不方便，可以从上往下，从左到右依次编号。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e2+5;
int n,m,q,f[N*N],a[5];
char G1[N][N],G2[N][N];
int find(int x){
	if(x==f[x]) return x;
	else return f[x]=find(f[x]);
}
void ins(int x,int y){
	f[find(x)]=find(y);
}
bool check(int s,int x1,int y1,int x2,int y2){
	memset(a,0,sizeof(a));
	for(int i=1;i<=4;i++){
		if(s&(1<<(i-1))) a[i]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			if(G1[i][j]=='P'&&a[1]==1) ins((i-1)*m+j,(i-1)*m+j+1);
			if(G1[i][j]=='C'&&a[2]==1) ins((i-1)*m+j,(i-1)*m+j+1);
			if(G1[i][j]=='Z'&&a[3]==1) ins((i-1)*m+j,(i-1)*m+j+1);
			if(G1[i][j]=='N'&&a[4]==1) ins((i-1)*m+j,(i-1)*m+j+1);
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			if(G2[i][j]=='P'&&a[1]==1) ins((i-1)*m+j,(i-1)*m+j+m);
			if(G2[i][j]=='C'&&a[2]==1) ins((i-1)*m+j,(i-1)*m+j+m);
			if(G2[i][j]=='Z'&&a[3]==1) ins((i-1)*m+j,(i-1)*m+j+m);
			if(G2[i][j]=='N'&&a[4]==1) ins((i-1)*m+j,(i-1)*m+j+m);
		}
	}
	if(find((x1-1)*m+y1)==find((x2-1)*m+y2)) return 1;
	else return 0;
}
int calc(int s){
	int ans=0;
	for(int i=1;i<=4;i++){
		if(s&(1<<(i-1))) ans++;
	}
	return ans;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			cin>>G1[i][j];
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			cin>>G2[i][j]; 
		}
	}
	cin>>q;
	while(q--){
		int ans=INT_MAX,x1,y1,x2,y2;
		cin>>x1>>y1>>x2>>y2;
		for(int bit=0;bit<16;bit++){
			for(int i=1;i<=n*m;i++) f[i]=i;
			if(check(bit,x1,y1,x2,y2)){
				ans=min(ans,calc(bit));
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Mu_leaf (赞：1)

## [思路]
看到这道题的第一反应不就直接 01bfs 就可以做完了吗？兴致勃勃的写一发，交上去，24pts，假了！

[测评记录](https://www.luogu.com.cn/record/148613556)。

考虑证明一下为什么会假。

发现每条边的权值并不固定，每前进一步每条边的权值可能会发生改变，这就导致局部最优解并不是全局最优解，其实样例 3 就已经提醒了普通的 01bfs 会错，~~但我就是愣头青~~，写了个 dis 数组就交上去了。

## [正解]
题目数据小得可怜，于是考虑枚举只通过哪几种颜色的门，能否到达终点。这就变成了判断连通性的问题，并查集，广搜，深搜都可以。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int f=1,x=0;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x*f;
}
void write(int x){
	if(x<0)x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
const int N=105;
char nxt[N][N],un[N][N];
int n,m,q,ans=10000000000000;
int px,py,ex,ey;
int fx[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
int vis[35],dis[N][N];
char s[10]={'P','C','Z','N'};
struct maze{
	int x,y; 
};
bool bfs(int sx,int sy,int stase){
	deque<maze> q;
	q.push_back((maze){sx,sy});
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
	for(int i=1;i<=4;i++){
		if((stase&(1<<(i-1)))){
//			cout << "QAQ" << "\n";
			vis[s[i-1]-'A']=1;
		}
	}
//	cout << stase << "\n";
//	for(int i=1;i<=26;i++) cout << vis[i] << " \n"[i==26];
	while(!q.empty()){
		maze now=q.front();
		q.pop_front();
		if(now.x==ex && now.y==ey) return 1;
		for(int i=0;i<4;i++){
			int xx=now.x+fx[i][0];
			int yy=now.y+fx[i][1];
			if(xx>=1 && xx<=n && yy>=1 && yy<=m && !dis[xx][yy]){
				char v;
				if(i==0) v=un[xx][yy];
				if(i==1) v=un[xx-1][yy];
				if(i==2) v=nxt[xx][yy-1];
				if(i==3) v=nxt[xx][yy];
				if(!vis[v-'A']) continue;
				
//				cout << xx << " " << yy << " " << v << "\n";
				dis[xx][yy]=1;
				q.push_back ((maze){xx,yy});
				
			}
		}
	}return 0;
}
inline int get(int x){
	int ans=0;
	for(;x;x>>=1) if(x&1) ans++;
	return ans;
}
signed main(){
//	freopen("maze.in","r",stdin);
//	freopen("maze.out","w",stdout);
	cin >> n >> m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			cin >> nxt[i][j];
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			cin >> un[i][j];
		}
	}
	cin >> q;
	while(q--){
		px=read(),py=read(),ex=read(),ey=read();
		ans=10000000000000;
		for(int i=1;i<=16;i++){
			if(bfs(px,py,i)) ans=min(ans,get(i));
		} 
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：kkxacj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9904)

#### 思路

发现一共只有四种颜色，可以暴力枚举用哪几个颜色，不难发现最多只有 $16$ 种情况每次跑个 `dfs` 在只通过这几个颜色是否能到目标位置，可以的话输出用不同颜色最少的就行了。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,x,y,z,k,bj[110],v[110][110],ans,a[10][110][110],tot;//右下左上 
char x1;
map<char,int>ma;
void dfs(int x,int y)
{
	if(x < 1 || y < 1 || x > n || y > m || v[x][y]) return;
	v[x][y] = 1;
	if(x == z && y == k) return;
	if(bj[a[0][x][y]]) dfs(x,y + 1);
	if(bj[a[1][x][y]]) dfs(x + 1,y);
	if(bj[a[2][x][y]]) dfs(x,y - 1);
	if(bj[a[3][x][y]]) dfs(x - 1,y);
}
int main()
{
//	freopen("maze.in","r",stdin);
//	freopen("maze.out","w",stdout);
	scanf("%d%d",&n,&m);
	ma['P'] = 1,ma['C'] = 2,ma['Z'] = 3,ma['N'] = 4;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j < m;j++)
			cin >> x1,a[2][i][j + 1] = a[0][i][j] = ma[x1]; 
	for(int i = 1;i < n;i++)
		for(int j = 1;j <= m;j++)
			cin >> x1,a[3][i + 1][j] = a[1][i][j] = ma[x1];
	scanf("%d",&q);
	while(q--)
	{
		scanf("%d%d%d%d",&x,&y,&z,&k);
		ans = 1e7;
		for(int i = 1;i < 16;i++)
		{
			tot = 0;
			for(int j = 1,cnt = 1;j <= 8;j *= 2,cnt++)
			{
				if((i & j) == j) bj[cnt] = 1,tot++;
				else bj[cnt] = 0;
			}
			for(int d = 1;d <= n;d++)
				for(int j = 1;j <= m;j++) v[d][j] = 0;
			dfs(x,y);
			if(v[z][k]) ans = min(ans,tot);
		}
		printf("%d\n",ans);
	}
	return 0;
}

---

## 作者：__liujy (赞：0)

## 零. 前言
前置知识：二进制，记忆化搜索。
## 壹. 思路
令 $F_{i,j,k}$ 为到了 $(i,j)$ 的位置，且状态为 $k$。这里解释一下什么是状态，这里运用了二进制，如果某一位是 $1$，那么就表示当前遇到了这一位所代表的颜色。

然后去 ```dfs```，里面传三个参数：$x,y,now$，分别表示当前的位置是 $(x,y)$，状态是 $now$，其它的就正常 ```dfs``` 即可。
## 贰. 代码
```cpp
// P9904 [COCI 2023/2024 #1] Labirint
#include<bits/stdc++.h>
const int MAXN=105,MAXM=(1<<4)+1;
const int INF=0x7f7f7f7f;
const int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
int n,m,q,F[MAXN][MAXN][MAXM],bx,by,ex,ey;
char a[MAXN][MAXN],b[MAXN][MAXN];
inline bool ok(char ch)
{ return (ch=='P'||ch=='C'||ch=='Z'||ch=='N'); }
inline int get(char ch)
{
    if(ch=='P') return 0;
    else if(ch=='C') return 1;
    else if(ch=='Z') return 2;
    else return 3;
}
inline int dfs(int x,int y,int now)
{
    if(x==ex&&y==ey)
        return F[x][y][now]=(((now&1)!=0)+((now&2)!=0)+((now&4)!=0)+((now&8)!=0));
    else if(F[x][y][now]!=-1)
        return F[x][y][now];
    F[x][y][now]=INF;
    for(int i=0;i<4;i++)
    {
        int tx=x+dir[i][0],ty=y+dir[i][1];
        if(tx<1||tx>n||ty<1||ty>m) continue;
        int p=(abs(ty-y)==1?get(a[x][std::min(y,ty)])
                           :get(b[std::min(x,tx)][y]));
        F[x][y][now]=std::min(F[x][y][now],dfs(tx,ty,(now|(1<<p))));
    }
    return F[x][y][now];
}
inline void solve()
{
    scanf("%d%d%d%d",&bx,&by,&ex,&ey);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=0;k<MAXM;k++)
                F[i][j][k]=-1;
    printf("%d\n",dfs(bx,by,0));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<m;j++)
        {
            a[i][j]='~';
            while(!ok(a[i][j]))
                scanf("%c",&a[i][j]);
        }
    for(int i=1;i<n;i++)
        for(int j=1;j<=m;j++)
        {
            b[i][j]='~';
            while(!ok(b[i][j]))
                scanf("%c",&b[i][j]);
        }
    scanf("%d",&q);
    while(q--) solve();
    return 0;
}
```

---

## 作者：Cwkapn (赞：0)

## 题意简述
给定一张网格图，两格之间的门有 $4$ 种颜色。若干询问，求两点间路径中经过的门颜色最少多少种。
### 题目分析
由于 $n,m,k\le100$，本题可以考虑使用搜索的方法解决。因为颜色只有 $4$ 中，在状态表示中把对应颜色是否被经过用一个二进制数进行状态压缩表示。使用 $v_{i,j,k}$ 表示从起点到达 $(i,j)$ 且通过的颜色状态为 $k$，然后直接进行 BFS。

这样做，颜色状态最多只有 $16$。设每个点最多被经过 $p$ 次，时间复杂度为 $\mathcal{O}(pnmq)$，其中 $p\le 16$。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int n, m;
int dr[N][N], dd[N][N]; // right, down
int getcol(char c) {
	if (c == 'P') return 0;
	if (c == 'C') return 1;
	if (c == 'Z') return 2;
	if (c == 'N') return 3;
}
int vis[N][N][20];
struct node {
	int x, y, col;
};
queue<node> q;
int num(int x) {
	int res = 0;
	while (x) {
		if (x & 1) res++;
		x >>= 1;
	}
	return res;
}
bool ok(int x, int y) {return x >= 1 && x <= n && y >= 1 && y <= m;}
int bfs(int xa, int ya, int xb, int yb) {
	while (!q.empty()) q.pop();
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 0; k < 16; k++) vis[i][j][k] = 0;
		}
	}
	q.push({xa, ya, 0});
	while (!q.empty()) {
		node f = q.front();
		q.pop();
		int x = f.x, y = f.y, col = f.col;
		if (vis[x][y][col]) continue;
		vis[x][y][col] = 1;
		if (x == xb && y == yb) continue;
		if (ok(x, y + 1) && !vis[x][y + 1][col | (1 << dr[x][y])]) q.push({x, y + 1, col | (1 << dr[x][y])});
		if (ok(x + 1, y) && !vis[x + 1][y][col | (1 << dd[x][y])]) q.push({x + 1, y, col | (1 << dd[x][y])});
		if (ok(x, y - 1) && !vis[x][y - 1][col | (1 << dr[x][y - 1])]) q.push({x, y - 1, col | (1 << dr[x][y - 1])});
		if (ok(x - 1, y) && !vis[x - 1][y][col | (1 << dd[x - 1][y])]) q.push({x - 1, y, col | (1 << dd[x - 1][y])});
	}
	int ans = 5;
	for (int k = 0; k < 16; k++) {
		if (vis[xb][yb][k]) {
			ans = min(ans, num(k));
		}
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		string s;
		cin >> s;
		for (int j = 1; j < m; j++) dr[i][j] = getcol(s[j - 1]);
	}
	for (int i = 1; i < n; i++) {
		string s;
		cin >> s;
		for (int j = 1; j <= m; j++) dd[i][j] = getcol(s[j - 1]);
	}
	int q;
	cin >> q;
	while (q--) {
		int xa, ya, xb, yb;
		cin >> xa >> ya >> xb >> yb;
		cout << bfs(xa, ya, xb, yb) << '\n';
	}
	return 0;
}
```

---

## 作者：Igallta (赞：0)

### 前言

其实这道题非常简单，不知道为什么有些人用到了并查集。

因为这道题其实允许差不多 $\Omicron(nmq\log K)$ 的时间复杂度，所以根本不需要并查集，而只需要暴力+状压即可。

### 大体思路

注意到这道题有四个颜色，可以使用二进制来表示。我们只需要弄四位，哪一位是 1 就代表哪一位的颜色可以通行。

至于每一位代表什么颜色，你随意。

我们枚举 $1$ \~ $15$（二进制为 $0001$ \~ $1111$），然后进行 bfs（洪水填充），跑每一个点：看当前选的颜色是否可以通过这个点，然后给这个点染上色。最后看终点被染的色是否是我们枚举的这个颜色。

## 代码

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define int long long
#define PYY pair<int,int>
#define LL k<<1
#define RR k<<1|1
#define x first
#define y second
using namespace std;
using namespace __gnu_pbds;
const int N=105;
int n,m,Q,d[N][N],u,v,x,y,ans;
map<PYY,map<PYY,int>>mp;
queue<PYY>q;
int cti(char c) {
	if(c=='P') {
		return 1;
	}
	if(c=='C') {
		return 2;
	}
	if(c=='Z') {
		return 4;
	}
	if(c=='N') {
		return 8;
	}
}
int zjx(int x) {
	int R=0;
	while(x) {
		R+=(x&1);
		x>>=1;
	}
	return R;
}
void bfs(int base) {
	while(q.size()) {
		PYY u=q.front();
		q.pop();
		for(auto v:mp[u]) {
			if((v.y&base) && (d[v.x.x][v.x.y]!=base)) {
				d[v.x.x][v.x.y]=base;
				q.push({v.x.x,v.x.y});
			}
		}
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m-1; j++) {
			char c;
			cin>>c;
			int X=cti(c);
			mp[ {i,j}][ {i,j+1}]=X;
			mp[ {i,j+1}][ {i,j}]=X;
		}
	}
	for(int i=1; i<=n-1; i++) {
		for(int j=1; j<=m; j++) {
			char c;
			cin>>c;
			int X=cti(c);
			mp[ {i+1,j}][ {i,j}]=X;
			mp[ {i,j}][ {i+1,j}]=X;
		}
	}
	cin>>Q;
	while(Q--) {
		ans=15;
		cin>>u>>v>>x>>y;
		for(int i=1; i<=14; i++) {
			if(zjx(ans)>zjx(i)) {
				q.push({u,v});
				d[u][v]=i;
				bfs(i);
				if(d[x][y]==i) {
					ans=i;
				}
			}
		}
		cout<<zjx(ans)<<'\n';
		memset(d,0,sizeof d);
	}
	return 0;
}
```

---

## 作者：U•ェ•*U (赞：0)

[我的 CSDN 原文地址（转载请标明）](https://blog.csdn.net/LZXLSMLTZLLM/article/details/136432028)

本题解受 `eoinlee` 的启发，增加注释
## 分析
数据范围非常小，$n,m,q$ 都只有 $100$ 的级别。

考虑到这点，我们可以枚举**所有可能的使用颜色**的情况。对于这 $4$ 种颜色，每次搜索允许搜索路径经过其中若干种颜色的门，并检查能否在当前所允许颜色的条件下从起点走到终点。最后，计算所有可行方案经过颜色数的最小值。由于四种颜色最多只可能有 $15$ 种选择方案，因此每一次询问的复杂度最多只可能达到 $O(nm)$（不含常数）。综合下来，完全可以通过本题。

**注意：本题目既可以使用 DFS，也可以使用 BFS**

另外，最好使用状态压缩进行搜索，可以很好地减小常数。

## 代码（使用 `BFS` 算法）
```cpp
#include <bits/stdc++.h>
using namespace std;

// 定义常量
const int N = 1e2 + 5; // 最大网格大小
const int dx[] = {0, 1, 0, -1}; // x轴方向移动，代表东南西北
const int dy[] = {1, 0, -1, 0}; // y轴方向移动，代表东南西北
const vector<int> seq = {1, 2, 4, 8, 3, 5, 9, 6, 10, 12, 7, 11, 13, 14, 15}; // 遍历状态序列
int n, m; // 网格的行数和列数
int g[N][N][4]; // 存储每个单元格与其相邻单元格的连接状态
bool vis[N][N]; // 标记某个单元格是否被访问过
unordered_map<char, int> mp = {{'P', 0}, {'C', 1}, {'Z', 2}, {'N', 3}}; // 映射字符到连接状态

// BFS函数，用于寻找从起点到终点的路径
bool BFS(int sx, int sy, int ex, int ey, int state) {
    using PII = pair<int, int>;
    memset(vis, 0, sizeof vis); // 初始化访问数组
    queue<PII> q;
    vis[sx][sy] = true; // 标记起点为已访问
    q.emplace(sx, sy); // 将起点加入队列
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        if (x == ex && y == ey) // 如果到达终点，返回true
            return true;
        for (int i = 0; i < 4; i++) {
            int tx = x + dx[i], ty = y + dy[i];
            if (tx < 1 || ty < 1 || tx > n || ty > m) continue; // 超出边界检查
            if (vis[tx][ty]) continue; // 已访问检查
            if ((1 << g[x][y][i]) & state) // 状态检查
                q.emplace(tx, ty), vis[tx][ty] = true;
        }
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false); // 加速C++输入输出
    cin >> n >> m; // 输入行数和列数
    char ch;
    // 读入水平方向的连接状态
    for (int i = 1; i <= n; i++)
        for (int j = 1; j < m; j++)
            cin >> ch, g[i][j][0] = g[i][j + 1][2] = mp[ch];
    // 读入垂直方向的连接状态
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= m; j++)
            cin >> ch, g[i][j][1] = g[i + 1][j][3] = mp[ch];
    int q; // 查询次数
    cin >> q;
    while (q--) {
        int sx, sy, ex, ey; // 起点和终点
        cin >> sx >> sy >> ex >> ey;
        for (int state : seq) { // 遍历每种状态
            if (BFS(sx, sy, ex, ey, state)) { // 如果找到路径
                cout << __builtin_popcount(state) << endl; // 输出该状态的位数（即路径长度）
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：eoinlee (赞：0)

## 题意简述

> 有一个 $n\times m$ 的方格矩阵，矩阵中所有相邻两个方格之间都有一扇带颜色 $t$ 的门，并且所有相邻方格都只通过门相连通。给定所有门的颜色，并给定 $q$ 次询问。对于每一次询问，输出从给定的起点 $(a, b)$ 走到终点 $(c, d)$ 至少要经过多少种颜色的门。
>
> $1 \leq n, m, q \leq 100$，$t \in\left\{\mathtt{P}, \mathtt{C}, \mathtt{Z}, \mathtt{N} \right\}$，$\forall a, b, c, d,  (a, b) \neq (c, d)$。

## 题内话

本题解受[官方题解](https://hsin.hr/coci/contest1_solutions.zip)启发而作。

说实话，这题我最开始是用优先队列 BFS + STL unordered set 写的。虽然能够过掉前两个子任务，但思路上仍很有问题。这里就不细说这一错误做法了，大体上就是，如果边与边之间的权值不是固定的，而是随着搜索的进行而不断动态变化，则双端队列、优先队列 BFS 和 Dijkstra 这样的最短路算法并不能在不断贪心地选取单步最优解的情况下保证全局最优解。（这不是常识么……为什么我当时脑瘫没想到……）

但本题并非不能用 BFS 写，只是需要转换一下解题的具体思路。

## 分析

本题数据范围非常小，$n, m, q$ 都只有 $100$ 的级别。这启发我们，每一次询问都有充足的时间可以把一整个矩阵全部遍历一遍甚至几遍。同时，总共只有 $4$ 种颜色。

考虑到这两点，我们可以枚举所有可能的使用颜色的情况。对于这 $4$ 种颜色，每次搜索允许搜索路径经过其中若干种颜色的门，并检查能否在当前所允许颜色的条件下从起点走到终点。最后，计算所有可行方案经过颜色数的最小值。由于四种颜色最多只可能有 $2^4 - 1 = 15$ 种选择方案（每种颜色都有选和不选两种方案，至少要选 $1$ 种颜色，根据乘法原理即可得到），并且由于只需要检测连通性所以不需要回溯，因此每一次询问的复杂度最多只可能达到 $\mathcal{O}(15nm)$。综合下来，总复杂度为 $\mathcal{O}(15nmq)$，完全可以通过本题。

当然，还可以通过一种很好想的方式减小常数，也就是把这 $15$ 种方案提前进行状态压缩，用一个 $1$ 到 $15$ 范围内的正整数来表示，其 $4$ 个二进制位分别表示四种颜色的选择情况。进一步地，我们可以通过对这 $15$ 个正整数按照二进制表达中 $1$ 的个数（也就是所选颜色的个数）进行升序排序，并在每一次询问的 $15$ 次搜索过程中，如果发现连通，则直接输出当前所选颜色个数作为答案。

### DFS

```cpp
#include <vector>
#include <cstring>
#include <iostream>
#include <unordered_map>

#define endl '\n'

using namespace std;

const int N = 1e2 + 5;
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};

// 提前写好的状态顺序
const vector<int> seq = {1, 2, 4, 8, 3, 5, 9, 6, 10, 12, 7, 11, 13, 14, 15};

// 为每一个颜色分配数字编号
unordered_map<char, int> mp = {{'P', 0}, {'C', 1}, {'Z', 2}, {'N', 3}};

int n, m, ex, ey;
int g[N][N][4];  // 存储每一个方格在四个方向的门的颜色
bool vis[N][N];

bool DFS(int x, int y, int state) {
    if (x == ex && y == ey)
        return true;

    vis[x][y] = true;

    for (int i = 0; i < 4; i++) {
        int tx = x + dx[i], ty = y + dy[i];

        if (tx < 1 || ty < 1 || tx > n || ty > m) continue;
        if (vis[tx][ty]) continue;

        if ((1 << g[x][y][i]) & state)  // 如果接下来需要穿过的门的颜色是被允许的
            if (DFS(tx, ty, state))     // 则递归地继续判断连通性
                return true;            // 如果连通则返回
    }

    return false;  // 否则不联通
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;

    char ch;

    // 输入横向相邻两个方格之间门的颜色
    // 注意要与偏移数组中各下标对应的的方向相同
    for (int i = 1; i <= n; i++)
        for (int j = 1; j < m; j++)
            cin >> ch, g[i][j][0] = g[i][j + 1][2] = mp[ch];

    // 输入纵向相邻两个方格之间门的颜色
    // 注意要与偏移数组中各下标对应的的方向相同
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= m; j++)
            cin >> ch, g[i][j][1] = g[i + 1][j][3] = mp[ch];

    int q;
    cin >> q;
    while (q--) {
        int sx, sy;
        cin >> sx >> sy >> ex >> ey;

        for (int state : seq) {
            memset(vis, 0, sizeof vis);                     // 记得多搜清空
            if (DFS(sx, sy, state)) {                       // 如果找到合法解
                cout << __builtin_popcount(state) << endl;  // 则输出所选颜色个数
                break;
            }
        }
    }

    fflush(stdout);
    return 0;
}
```

### BFS

思路与 DFS 代码中所阐述的类似，就不加注释了。

```cpp
#include <queue>
#include <vector>
#include <cstring>
#include <iostream>
#include <unordered_map>

#define endl '\n'

using namespace std;

const int N = 1e2 + 5;
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};
const vector<int> seq = {1, 2, 4, 8, 3, 5, 9, 6, 10, 12, 7, 11, 13, 14, 15};

int n, m;
int g[N][N][4];
bool vis[N][N];
unordered_map<char, int> mp = {{'P', 0}, {'C', 1}, {'Z', 2}, {'N', 3}};

bool BFS(int sx, int sy, int ex, int ey, int state) {
    using PII = pair<int, int>;
    memset(vis, 0, sizeof vis);

    queue<PII> q;
    vis[sx][sy] = true;
    q.emplace(sx, sy);

    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();

        if (x == ex && y == ey)
            return true;

        for (int i = 0; i < 4; i++) {
            int tx = x + dx[i], ty = y + dy[i];

            if (tx < 1 || ty < 1 || tx > n || ty > m) continue;
            if (vis[tx][ty]) continue;

            if ((1 << g[x][y][i]) & state)
                q.emplace(tx, ty), vis[tx][ty] = true;
        }
    }

    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;

    char ch;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j < m; j++)
            cin >> ch, g[i][j][0] = g[i][j + 1][2] = mp[ch];
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= m; j++)
            cin >> ch, g[i][j][1] = g[i + 1][j][3] = mp[ch];

    int q;
    cin >> q;
    while (q--) {
        int sx, sy, ex, ey;
        cin >> sx >> sy >> ex >> ey;

        for (int state : seq) {
            if (BFS(sx, sy, ex, ey, state)) {
                cout << __builtin_popcount(state) << endl;
                break;
            }
        }
    }

    fflush(stdout);
    return 0;
}
```

---


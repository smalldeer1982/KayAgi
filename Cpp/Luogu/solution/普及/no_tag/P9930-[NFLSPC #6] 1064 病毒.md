# [NFLSPC #6] 1064 病毒

## 题目背景

你的电脑中了 1064 病毒，现在电脑里储存的所有数字都开始坍缩了！

为了更彻底地毁灭你的电脑，对于十进制下的 $n$ 位数，邪恶的 1064 病毒会将它按照某种规则迭代至少 $n + 1$ 次，以确保你无法还原。

面对 1064 病毒，你手足无措。但是作为 OIer 的你想知道道道道道道道道道道道到到到到到到到到



## 题目描述

定义数字串为只含有数码 $0\sim 9$ 的串，奇数数码为 $1, 3, 5, 7, 9$，偶数数码为 $0, 2, 4, 6, 8$。

对数字串 $x$，设其中奇数数码，偶数数码和总数码个数分别为 $a, b, c$，则 $a + b = c = |x|$。定义 $g(x)$ 为将 $a, b, c$ 依次写下得到的数字串，**不忽略前导零**。例如 $g(\texttt{0}) = \texttt {011}$，$g(\texttt{1064}) = \texttt{134}$，$g(\texttt {822}) = \texttt {033}$，$g(\texttt{1092515503}) = \texttt{7310}$。

设 $f_k(x)$ 表示将 **数字** $x$ **忽略前导零** 写成数字串 $x'$ 后，将 $g(x')$ 迭代 $k$ 次得到的数字串对应的数字，即设 $x ^ * = g(g(\cdots g(x')))$（共有 $k$ 个 $g$），则 $f_k(x)$ 为将 $x ^ *$ 写成数字后的结果。

给定 $n, k$（**保证 $n < k$**），求 $\sum_{i = 0} ^ {10 ^ n - 1} f_k(i)$。

多组数据。

## 说明/提示

对于所有数据，$1\leq T\leq 60$，$0\leq n < k \leq 10 ^ 5$，$\sum k\leq 10 ^ 5$。

- 测试点 1（$30$ 分）：$n\leq 5$，$k\leq 15$。  
- 测试点 2（$70$ 分）：无特殊限制。

Source：NFLSPC #6 F by Alex_Wei

## 样例 #1

### 输入

```
1
0 1
```

### 输出

```
11
```

# 题解

## 作者：Iniaugoty (赞：4)

感觉挺诈骗的一道题。

***

你发现答案可能极大，但是南夫拉斯又不大可能出高精度。

于是你猜想这个 $10 ^ {10 ^ 5}$ 可能是假的，或者所有 $f _ k (i)$ 都相同或类似，使得答案是**一个可以处理的数后面跟上一串 $0$**。

于是你手模了一下 $0 \sim 20$ 和几个大数。

于是你发现迭代数次之后他们都得到了 $213$。

于是你猜想所有 $f _ k (i)$ 都是 $213$。

于是你写了一份代码，输出了 $213$ 和 $n$ 个 $0$。

于是你获得了 $0$ 分。

于是你继续观察，发现当 $k = 1$ 时（$n$ 只能为 $0$）答案是 $11$，似乎只有这个不符合你的猜想。

于是你加了一个特判。

于是你通过了。

***

上面是我乱搞过题的过程，接下来我将给出解释。

当 $0 \le n < 10 ^ 9$，显然 $\vert g(n') \vert = 3$。

当 $10 ^ 9 \le n < 10 ^ {16}$，显然 $\vert g(n') \vert \le 6$，那么 $\vert g(g(n')) \vert = 3$。

当 $10 ^ {16} \le n < 10 ^ {10 ^ 5}$，显然 $\vert g(n') \vert \le 16$，那么 $\vert g(g(n')) \vert \le 6$，进而 $\vert g(g(g(n'))) \vert = 3$。

如果 $\vert g(x) \vert = 3$，$g(x)$ 一定可以通过迭代得到 $213$。对 $g$ 每一位的奇偶性分类讨论（因为前两位之和是第三位，所以只有两种情况）：

- 奇偶奇/偶奇奇/奇奇偶：显然迭代 $1$ 次就是 $213$ 了。

- 偶偶偶：迭代 $1$ 次是 $033$，再 $1$ 次就是 $213$。

对于 $n = 0$，需要迭代 $2$ 次达到 $213$，所以 $k = 1$ 时答案为 $11$，否则 $213$。

对于 $0 < n < 10$，由于迭代 $1$ 次之后最后一位必为奇数，符合第一种情况，只需再迭代 $1$ 次。而由题意这一部分一定有 $k \ge 2$，所以一定是 $213$。

对于 $10 \le n < 10 ^ 9$，需迭代至多 $3$ 次，而这里有 $k \ge 3$，必为 $213$。

对于 $10 ^ 9 \le n < 10 ^ {16}$，需迭代至多 $4$ 次，而这里有 $k \ge 10$，必为 $213$。

对于 $10 ^ {16} \le n \le 10 ^ {10 ^ 5}$，需迭代至多 $5$ 次，而这里有 $k \ge 17$，必为 $213$。

综上，$k = 1$ 时答案为 $11$，否则为 $213 \times 10 ^ n$。

***

代码很简单，不贴了。

---

## 作者：Vct14 (赞：0)

题目链接：[$\texttt{P9930 [NFLSPC \#6] 1064 病毒}$](https://www.luogu.com.cn/problem/P9930)。

------------

看到数据范围猜测是找规律。我们分类讨论即可。

- 对于 $n=0$，此时即求 $f_k(0)$。

| 原数 $i$ | 第 $1$ 次迭代后 | 第 $2$ 次迭代后 | 第 $3$ 次迭代后 | 第 $k$ 次迭代后（$k\geqslant2$） |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $0$ | $011$ | $213$ | $213$ | $213$ |

我们可以发现，若得到了结果 $213$，则无论迭代多少次，答案均为 $213$。

$k\geqslant1$ 时，答案为 $213$；$k=1$ 时，答案为 $11$。

- 对于 $n=1$，即一个一位数。此时 $k\geqslant2$。

| 原数 $i$ | 第 $1$ 次迭代后 | 第 $2$ 次迭代后 | 第 $k$ 次迭代后（$k\geqslant2$） |
| -----------: | -----------: | -----------: | -----------: |
| 奇数 | $101$ | $213$ | $213$ |
| 偶数 | $011$ | $213$ | $213$ |

即 $k\geqslant2$ 时 $f_k(x)=213$， $\sum_{i = 0} ^ {99} f_k(i)=213\times100=21300$。


- 对于 $n=2$，即最多为两位数。此时 $k\geqslant3$。

| 原数 $i$ 中的数码 | 第 $1$ 次迭代后 | 第 $2$ 次迭代后 | 第 $3$ 次迭代后 | 第 $k$ 次迭代后（$k\geqslant3$） |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 两奇 | $202$ | $033$ | $213$ | $213$ |
| 一奇一偶 | $112$ | $213$ | $213$ | $213$ |
| 两偶 | $022$ | $033$ | $213$ | $213$ |

$k\geqslant3$ 时一位数也可以变为 $213$，则答案一定为 $213$，则 $\sum_{i = 0} ^ {999} f_k(i)=213\times1000=213000$。

- 对于 $n=3$，即最多为三位数。此时 $k\geqslant4$。

| 原数 $i$ 中的数码 | 第 $1$ 次迭代后 | 第 $2$ 次迭代后 | 第 $k$ 次迭代后（$k\geqslant2$） |
| -----------: | -----------: | -----------: | -----------: |
| 三奇 | $303$ | $213$ | $213$ |
| 两奇一偶 | $213$ | $213$ | $213$ |
| 一奇两偶 | $123$ | $213$ | $213$ |
| 三偶 | $033$ | $213$ | $213$ |

可以发现，实际上三位数只需 $2$ 次迭代即可变为 $213$，而一位数、两位数最多经过 $3$ 次迭代也可变为 $213$。即答案为 $213$，则 $\sum_{i = 0} ^ {9999} f_k(i)=213\times10000=2130000$。

推测除 $n=0,k=1$ 外答案均为 $213$。证明如下。

$n$ 代表的实际上是 $i$ 的最高位数。由 $n<10^5$  可得 $i$ 最多 $99999$ 位，即 $c\leqslant99999$，那么迭代一次后最大只有 $899991000099999$，一共 $15$ 位。同理，迭代两次后最多 $5$ 位（最大为 $14115$），三次后最多只有 $3$ 位，而三位数最多两次即可变为 $213$，因此最多五次即可变为 $213$。$k<5$ 即 $n<4$ 的情况上文已证，而 $n\geqslant4$ 时 $k\geqslant5$ 成立。

因此 $n=0,k=1$ 时结果为 $11$，否则为 $213\times10^n$。输出时不用计算结果，输出 $213$ 后再输出 $n$ 个 $0$ 即可。

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T;
	cin>>T;
	while(T--){
		int n,k; 
		cin>>n>>k;
		if(n==0 && k==1) cout<<11;
		else{
			cout<<213;
			while(n--) cout<<0;
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：indream (赞：0)

## P9930 \[NFLSPC #6] 1064 病毒 题解
[P9930](https://www.luogu.com.cn/problem/P9930) | [AC](https://www.luogu.com.cn/record/139913000)

>UPD 2023.12.19：修正结论，感谢[@Augenstern5](https://www.luogu.com.cn/user/677609) 的提醒。

一道不错的结论题。
#### 情况一：$n=0,k=1$
迭代只进行 $1$ 次，和亦仅求 $10^0=1$ 次。显然，此时 $f_1(0)=011=11$。

#### 情况二：$2 \le k \le 4$
>打表永远的神。

暴力代码跑完后，发现**所有** $f_k(i)=213$。于是有其和：$213 \times 10^n$。
#### 情况三：$k>4$
本题数据范围中，显然 $length_i \le 99999$。

| $k=$ | $length_{f_k(i)}\le$ | 备注 |
| :---------: | :---------: | :---------: |
| $1$ | $5+5+5=15$ | - |
| $2$ | $2+1+2=5$ | $\max(b_{length}+a_{length})=3$ |
| $3$ | $1+1+1=3$ | - |
| $4$ | $1+1+1=3$ | $c=3$ |
| $5$ | $1+1+1=3$ | $f_5(i)=213$ |
| $6$ | $1+1+1=3$ | $f_6(i)=213$ |

Q：上表 $f_5(k)$ 中，为何不可以是 $123$？

A：此时 $f_4(i)$ 中存在 $2$ 个偶数数码，即此时 $a,b \mod 2=0$（$c$ 为奇数），于是有 $(a+b) \mod 2=0$，与 $c=a+b=3$ 矛盾。

所以代码实现时和情况二一样。

---
**综上，**
$$
f_k(i)= \begin{cases}
  11 & k = 1\\
  213 & k > 1
\end{cases}
$$

---

## 作者：CarlosLiu (赞：0)

## 题目大意
对于数字 $x$ 定义 $a$ 为奇数数码个数，$b$ 为偶数数码个数，$c$ 为数码个数，$g(x)$ 为三者连续写下得到的数，且不去除前导零。$f_{k}(x)$ 为 $g(x)$ 迭代 $k$ 次的结果。求 $\sum^{10^{n}-1}_{i=1}f_{k}(i)$ 的值。
## 解题思路
有一个结论为 $k\ge2$ 时，数据范围内的 $i$ 满足 $f_{k}(i)=213$。

首先很显然 $g(213)=213$。第二 $x$ 为个位是 $3$ 的三位数时 $g(x)=213$ 因为 $c=3$ 时前两位一奇一偶，总共是 $2$ 奇 $1$ 偶 $3$ 位。

根据数据范围 $n\le10^{5}$ 可知，需要计算的 $i$ 最多就 $99999$ 位，写下来就 $5$ 位，所以 $f_{1}(i)$ 至多 $15$ 位。持续迭代，$f_{2}(i)$ 至多 $5$  位，$f_{3}(i)$ 至多 $3$ 位，$f_{4}(i)$ 就是个位是 $3$ 的三位数，$f_{5}(i)$ 一定为 $213$。

而 $k$ 为 $4$ 或 $3$ 或 $2$ 时，有 $n<k$ 的限制。此时 $i$ 也较小，经过简单的推算即可得到 $f_{k}(i)=213$。

而 $k=1$ 时，$n=0$ 答案就是样例中的 $11$。

经过这样的分析，代码就非常好写了。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,k,t;
int main() {
    cin>>t;
    for(int i=1;i<=t;i++) {
        cin>>n>>k;
        if(k>=2) {
            cout<<"213";
            for(int j=1;j<=n;j++) cout<<"0";
            cout<<endl;
        }
        else cout<<"11"<<endl;
    }
    return 0;
}
```

---


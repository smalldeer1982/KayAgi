# 三分

## 题目背景

本题可能存在严重精度问题，部分数据下难以通过。本题数据较水，仅供参考。

## 题目描述

如题，给出一个 $N$ 次函数，保证在范围 $[l, r]$ 内存在一点 $x$，使得 $[l, x]$ 上单调增，$[x, r]$ 上单调减。试求出 $x$ 的值。

## 说明/提示

对于 $100\%$ 的数据，$6 \le N \le 13$，函数系数均在 $[-100,100]$ 内且至多 $15$ 位小数，$|l|,|r|\leq 10$ 且至多 $15$ 位小数。$l\leq r$。

**【样例解释】**

 ![](https://cdn.luogu.com.cn/upload/pic/2297.png) 

如图所示，红色段即为该函数 $f(x) = x^3 - 3 x^2 - 3x + 1$ 在区间 $[-0.9981, 0.5]$ 上的图像。

当 $x = -0.41421$ 时图像位于最高点，故此时函数在 $[l, x]$ 上单调增，$[x, r]$ 上单调减，故 $x = -0.41421$，输出 $-0.41421$。


## 样例 #1

### 输入

```
3 -0.9981 0.5
1 -3 -3 1```

### 输出

```
-0.41421```

# 题解

## 作者：yuy_ (赞：444)

### 粒子群优化（Particle Swarm Optimization,PSO），又称微粒群算法

#### 其重要的迭代用的公式是这条:


## $v_i=v_i×w+c×rand()×(pbest_i+gbest- 2×x_i)$


其中：

$v_i$是速度

$w$是惯性因子((0,1)的实数)，和学习因子相反，就是该粒子原来的速度的 **参考权重** 。比如我的这个程序里取的是0.5，而据说从大到小衰减会更好。因为大的时候会重视每个**个体的价值**，可以更全面的寻找可行解，而越趋于0就越注重**社会的价值**就是所有粒子中的最优解。

$C$是学习因子也就是权重一般取$2$。

我们可以通过这个速度向量来更新位置。

$ b[a].x += b[a].v; $

#### 原理

_PSO算法是基于群体的，根据对环境的适应度将群体中的个体移动到好的区域。然而它不对个体使用演化算子，而是将每个个体看作是D维搜索空间中的一个没有体积的微粒（点），在搜索空间中以一定的速度飞行，这个速度根据它本身的飞行经验和同伴的飞行经验来动态调整。第i个微粒表示为Xi= （xi1, xi2, …, xiD），它经历过的最好位置（有最好的适应值）记为Pi= （pi1, pi2, …, piD），也称为pbest。在群体所有微粒经历过的最好位置的索引号用符号g表示，即Pg，也称为gbest。微粒i的速度用Vi= （vi1, vi2, …, viD）表示。
_

引用自[百度百科](https://baike.baidu.com/item/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96/1352052?fr=aladdin)

#### 粒子群优化算法流程图：

![](https://s2.ax1x.com/2019/02/14/kBtFJA.png)

#### 所以

对于这道题目我们先初始化他个$ 100 $个粒子，随机地在$ \begin{bmatrix}l,r\end{bmatrix} $区间里取x值，接着计算一下这个值对应的函数值且记录一下全局最优（更新时要用到）。

然后通过公式迭代他个$ 100 $次。

那就可以得到答案了。

#### 一些更详细的内容都写在了代码里了。

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstdlib>
using namespace std;
const int cnt=100;
int n;
double xs[15];//系数
double l,r;//x的范围
double f(double x) {//计算函数值
	double y = 0;
	for (int i=n+1; i>=1; i--) {
		y+=xs[n-i+2]*pow(x,i-1);
	}
	return y;
}
double Rand() {
	return (double)rand()/RAND_MAX;//返回一个[0,1]的随机实数
}
struct node {
	double xv,x,y,besty,bestx;
} b[105];
//xv是速度向量，x是位置，y是当前位置的函数值，besty是该粒子历史最优值，bestx是该粒子历史最优值时的x的值 

double by=-1e233,bx;
//by是全局当前最优值，bbx是取到全局最优值时的自变量x

void update(int a) {
	//更新速度向量
	//速度向量  惯性                 全局最优 局部最优  当前位置
	b[a].xv=b[a].xv*0.5+Rand()*2*(bx+b[a].bestx-b[a].x*2);//更新公式

	//通过速度向量更新位置
	b[a].x+=b[a].xv;

	//位置出界处理	       速度向量方向反转
	if (b[a].x<l) b[a].x=l,b[a].xv=b[a].xv*-1;
	if (b[a].x>r) b[a].x=r,b[a].xv=b[a].xv*-1;

	b[a].y=f(b[a].x);     //计算当前位置函数值
	if (b[a].y>b[a].besty) { //更新局部最优解
		b[a].bestx=b[a].x;
		b[a].besty=b[a].y;
	}
}

int main() {
	scanf("%d%lf%lf",&n,&l,&r);
	for (int i=1; i<=n+1; i++) {
		scanf("%lf",&xs[i]);//读入系数 
	}
	srand(xs[1]+xs[n]);
	//生成粒子
	for (int i=1; i<=cnt; i++) {
		//xv是速度向量，x是位置，y是当前位置的函数值，besty是该粒子历史最优值，bestx是该粒子历史最优值时的x的值 
		b[i].x=b[i].bestx=l+Rand()*(r-l);//初始x的值 为 l~r 的一个实数 
		b[i].xv=0;		//速度向量初始化为0
		b[i].y=b[i].besty=f(b[i].x);	//计算当前函数值
		if (by<b[i].y) { //若当前函数值优于全局最优函数值则更新全局最优
			bx=b[i].bestx;
			by=b[i].besty;
		}
	}
	//开始迭代
	for (int k=1; k<=100; k++) {
		for (int i=1; i<=cnt; i++) {
			//对每个粒子速度和位置更新
			update(i);
			if (by<b[i].besty) {
				//更新全局最优解
				bx=b[i].bestx;
				by=b[i].besty;
			}
		}
	}
	printf("%.5lf\n",bx);//全局最优的x的值即为答案
	return 0;
}
```

点个赞再走吧。

---

## 作者：BlueArc (赞：226)

这道题虽然可以求导二分，但对于一些很麻烦的函数很难求导，更何况这是三分模板，所以还是老老实实写三分吧。

三分其实是每次取L,R的终点mid，把mid左边一点点的函数值和右边一点点的函数值比较，舍弃一边的区间，这样不断缩小区间直到满足精度要求(一般eps取0.1\*精度)，但我们都喜欢取三等分点，其实只要是左边一点点和右边一点点就行了。

多项式求值还有个秦九韶算法，可以把2n+1次乘法n次加法简化为n次乘法和n次加法，楼下也有介绍。


```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-7;//其实一般精度*0.1=1e-6就可以了
int n;
double L,R;
double a[15];
//普通的求多项式
/*double F(double x)
{
 double f=0;
 for(int i=n;i>=0;i--)
 {
  double t=1;
  for(int j=1;j<=i;j++)
  t*=x;
  f+=a[i]*t;
 }
 return f;
}*/
//秦九韶算法从里到外逐层计算一次多项式的值
double F(double x)
{
 double sum=0;
 for(int i=n;i>=0;i--)
 sum=sum*x+a[i];
 return sum; 
}
int main()
{
 cin>>n>>L>>R;
 for(int i=n;i>=0;i--) cin>>a[i];
 while(fabs(L-R)>=eps)
 {
  double mid=(L+R)/2;
  if(F(mid+eps)>F(mid-eps)) L=mid;//舍弃左区间
  else R=mid;//舍弃右区间
 }
 printf("%.5lf",R);
 return 0;
}

```

---

## 作者：NaCly_Fish (赞：142)

看见有很多大佬用求导+二分做的，学过高数都知道，其实求导不难。  
那没学过高数的怎么办？  
这里提供一种用导数本质来计算的方法。  

在看导数的计算之前，我们先想一下斜率的计算。  
过 $(x_1,y_1),(x_2,y_2)$ 两点的直线斜率为：    
$$\text{Slope}=\frac{y_1-y_2}{x_1-x_2}$$  
而导数计算的就是过函数某一点切线的斜率。 

在函数 $f(x)$ 一点 $(x,f(x))$ 上，如果向右移动一点点（设移动了 $\Delta x$），就到了 $(x+\Delta x,f(x+\Delta x))$。   
当 $\Delta x$ 趋于 $0$ 时，计算过这两点直线的斜率，就是过 $(x,f(x))$ 这点的切线斜率了。

然后很容易就能得出，函数 $f(x)$ 的导函数 $f'(x)$ 可以这样计算：  
$$f'(x)=\lim\limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}$$  
不过我们只用求导数的数值解，也就是近似值。所以只需要把 $\Delta x$ 设为一个很小的值就可以了。写成代码，就是：  
```cpp
double derivative(double x){
	double dx = 1e-10;
	double dy = f(x+dx)-f(x);
    return dy/dx;
}   
```
其中 `f` 就是计算函数值的。  
 

对于求导的结果，也可以表示成一个函数变化的快慢（显然），导数值为正表示函数值在增加，导数值为负表示函数在减小。  

那么，如果导数值为零，且左边导数值为正，右边导数值为负，那么我们就找到了最小值，

由于这题中保证给定的 $f(x)$ 在 $[l,r]$ 上一段单调增，一段单调减；也就是说，$f'(x)$ 在 $[l,r]$ 上是一部分大于 $0$，一部分小于 $0$，还有一个唯一的零点，正好对应最大值，于是就可以愉快的二分啦！ 

另外，这样做还有一个好处：不用计算导函数具体是多少，比本题其它求导做法适用性更广。

参考代码：  
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#define eps (1e-10)
using namespace std;

double l,r;
int n;
double a[20];

inline double f(double x){
	//秦九昭公式求多项式
    double u[20];
    u[n] = a[n];
    for(int i=n-1;i>=0;--i)
        u[i] = u[i+1]*x+a[i];
    return u[0];    
}

double check(double x){
    double dx = eps;
    double dy = f(x+dx)-f(x);
    return dy/dx;
}

int main(){
    scanf("%d",&n);
    scanf("%lf%lf",&l,&r);
    for(int i=0;i<=n;++i)
        scanf("%lf",&a[n-i]);
    double mid;    
    while(r-l>eps){
        mid = (l+r)/2;
        if(check(mid)>0) l = mid;
        else r = mid;
    }    
    printf("%.5lf",mid);
    return 0;    
}
```


---

## 作者：Seauy (赞：59)

## 做的时候样例莫名WA了……

看了半天没看出来，想点开题解看看，然而……

### 我：“这 \*\* 居然能用粒子群？还有dalao用了%你退货！？怎么连求导二分都出来了？”

我要的三分呢 QAQ ？

### 然后 BUG 调好了，看见题解里没有正经的三分写法

那我就义不容辞喽 QAQ

不会三分的话点这：[戳](https://blog.csdn.net/littlewhite520/article/details/70144763)

本题代码来了：
```cpp
#include<bits/stdc++.h>
using namespace std;

const double dif=1e-7;
const int MAXN=13;

int n;
double coe[MAXN+5];

double check(double x)//不用秦九韶公式，普通计算……
{
	double temp=1.0,ans=0.0;
	for(int i=n;i>=0;i--,temp*=x) ans+=coe[i]*temp;
	return ans;
}

double Find(double L,double R)
{
	double Lmid,Rmid;
	while(L+dif<=R)
	{
		Lmid=L+(R-L)/3.0;
		Rmid=R-(R-L)/3.0;
		if(check(Lmid)>check(Rmid)) R=Rmid;
		else L=Lmid;
	}
	return (Lmid+Rmid)/2.0;
}

int main()
{
	double L,R;
	scanf("%d",&n),cin>>L>>R;
	for(int i=0;i<=n;i++) cin>>coe[i];
	printf("%.5lf\n",Find(L,R));
	//printf("%.5lf\n",check(-0.41421));
	return 0;
}
```


---

## 作者：0x7FFFFFFF (赞：36)

#优选法(黄金分割法)求函数极值

看着讨论里有人说可以用华罗庚优选法(其实华罗庚只是将其带入生产，真正发明人是一位美国数学家)，我就发了此题解。

ps:其实可以借鉴普通三分。

## 优性证明

如下图

 ![](https://cdn.luogu.com.cn/upload/pic/9919.png) 

假设函数的定义域为[0,1],f(x)有极值

即如普通三分法,取样1-x,x分析

假设[0,x]保留

在[0,x]上时

又取$x^2$和$(1-x)x$分析

当$(1-x)=x^2$时

上次在$(1-x)$处时的计算可以重复利用

便得等式$x^2+x-1=0$

解得$x=\frac{\sqrt{5}-1}{2}$=Ф(黄金比例)

所以x为黄金比例时，能减少计算次数

又Ф>$\frac{2}{3}$

计算区间变大，计算次数减小

此算法比普通三分优

## 代码

```cpp
#include<bits/stdc++.h>
#define gold_radio (sqrt(5)-1)/2 //黄金比例Ф≈0.6180339887
#define prec 1e-8 //优选法精度 
#define MAXN 15 //系数最大个数 
using namespace std;
int n;
double l,r,a[MAXN],fr,fl;//注意系数可能为实数
bool getr=true,getl=true;
double f(double x) { //此函数计算线性方程f(x)
    double ans=0,k=1;
    for (int i=n; i>=0; i--) {
        ans+=k*a[i];
        k*=x;
    }
    return ans;
}
int main() {
    cin>>n;
    cin>>l>>r;
    for (int i=0; i<=n; i++) cin>>a[i];
    while (r-l>prec) { //优选法，其实也只是三分的优化
        double midr=(r-l)*gold_radio+l; //根据黄金比例分割中间两个点
        double midl=(r-l)*(1-gold_radio)+l;
        if (getl) fl=f(midl);//精妙之处
        if (getr) fr=f(midr);
        if (fl>fr) {
            r=midr,fr=fl,getl=true,getr=false;
            continue;
        }
        if (fl<fr) {
            l=midl,fl=fr,getl=false,getr=true;
            continue;
        }
        if (fl==fr) r=midr,l=midl,getl=true,getr=true; //虽然没考虑精度，但只做提醒。此处一般人不写，注意l ≈r时已经得出答案，所以肯定是在异侧，可以同时向上
    }
    cout<<fixed<<setprecision(5)<<r<<endl;//注意题目要求精度
    return 0;
}
```
~~参考:百度百科~~


---

## 作者：ff_666 (赞：36)

虽说标着为【模板】三分，但还是很不厚道地写了个二分~~（皮一下）~~

事实证明，对于单峰函数，二分还是够的

实际上，就是一个爬坡的过程——

发现前面大，就往前面爬；发现后面大，就往后面爬。爬到尖顶了，往刚才的方向一看：哎呀！要掉下去了！连忙回缩——无法回缩了，则当前即为最高点

贴代码：
```cpp
#include<cstdio>
#define db double
using namespace std;
const db eps=1e-6;
int n;db a[15],L,R,mid;
db f(db x){//秦九昭定理
	db S=0;
	for(int i=n;i>=0;i--) S=S*x+a[i];
	return S;
}
int main(){
	scanf("%d%lf%lf",&n,&L,&R);
	for(int i=n;i>=0;i--) scanf("%lf",&a[i]);
	while(R-L>=eps){
		mid=(L+R)/2.0;
		if(f(mid-eps)>f(mid)) R=mid;else L=mid;
        //这里似乎对精度要求挺高的，不能用eps判断
	}
	printf("%.5lf\n",L);
	return 0;
}
```

对比一下三分的：
```cpp
#include<cstdio>
#define db double
using namespace std;
const db eps=1e-6;
int n;db a[15],L,R,mid1,mid2,k;
db f(db x){
	db S=0;
	for(int i=n;i>=0;i--) S=S*x+a[i];
	return S;
}
int main(){
	scanf("%d%lf%lf",&n,&L,&R);
	for(int i=n;i>=0;i--) scanf("%lf",&a[i]);
	while(R-L>=eps){
		k=(R-L)/3.0;
		mid1=L+k,mid2=R-k;
		if(f(mid1)>f(mid2)) R=mid2;else L=mid1;
	}
	printf("%.5lf\n",L);
	return 0;
}
```
~~核心还是差不多的~~

二分效率为log2，三分效率为2*log3

能用二分还是二分吧，简洁好写还效率高

~~不过这么说来，三分好肥啊~~

---

## 作者：vegetabird (赞：33)

其实这题还有一个做法，那就是二分出原函数的导函数的零点

易证，若$f'(x)=0$且$f'(x-dx)*f'(x+dx)<0$，则$f(x)$必为原函数的一个极大值或极小值

题目中已经告诉我们原函数只有一个极大值，所以我们可以使用二分导数的方法

至于导数怎么求 [百度百科](https://baike.baidu.com/item/导数/579188?fr=aladdin)

~~（我只能帮你到这儿了）~~

Code:
```cpp
#include<stdio.h>
int n;
double a[13];
inline double f(const double x){
    double ret=0;
    for(int i=n;i;--i)ret=ret*x+a[i];
    return ret;
}
int main(){
    double left,right,mid;
    scanf("%d%lf%lf",&n,&left,&right);
    for(int i=n;i;--i){
        scanf("%lf",a+i);
        a[i]*=i;
    }
    while(right-left>1e-6)
        if(f(mid=(right+left)/2)>0)left=mid;
        else right=mid;
    printf("%.5lf\n",left);
}
```

---

## 作者：Soulist (赞：28)

这道题目是今天和神仙@konjac_tbr(貌似神仙改名字了)商量~~温习~~所以写的，然后发现题目的一个奇妙性质—>貌似可以模拟退火写

所谓$[l-x]$单调递增，$[x-r]$单调递减。无非就是此函数的最大值，所以它就变成了一个给定$l--r$的区间，和一个$n$次函数，求出这段区间内函数任意取值所得最大值。

所以考虑模拟退火求最大值，如果位置溢出了就直接改为$l$或$r$，因为数据范围给的很小，所以这次退火就并不需要特别高的初温度($T$)，因为初温特别高的话会导致跳跃范围特别大，而至前面随机的点都是无用的。推荐的话，其实初温弄小数会比较好。

> 如果您不会模拟退火的话，可以理解为随机一个点去看看这个点是否是最大值—>~~如果不是，以一定概率接受这个点~~(删去)，再统计沿途的所有点的最大答案。

> #### 如果您上面这一段没有看懂，其实您可以直接理解这道题的模拟退火做法为：随机一个点，判断其是否最大，如果比当前答案大就修改答案。

> $ps:$ 因为实践得知，这道题目没必要一定概率接受答案。~~写上只是为了显得更正统~~


下面给代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int N = 20 + 5;
#define double long double
double T = 0.92, delta = 0.99, tt = 1e-14;
double a[N], l, r, eps = 1e-4, ans, num;
int n;
void input(){
    scanf("%d%llf%llf", &n, &l, &r);
    for(int i = 0; i <= n; i++)
        scanf("%llf", &a[i]);
    return ;
}
double get_ans(double x){
    double ans = 0, now = 1;
    for(int i = n; i >= 0; i--){
        ans = ans + a[i] * now;
        now = now * x; 
    }
    return ans;
}
void SA(){
    double now = (l + r) / 2;
    double t = T;
    while(t > tt){
        double temp = now + (rand() * 2 - RAND_MAX) * t;//随机一个点，保证其为正负数—//(rand()*2 - RAND_MAX)
        if(temp < l) temp = l;
        if(temp > r) temp = r;
        double new_ans = get_ans(temp);
        double DE = new_ans - ans;
        if(DE > 0){//如果新答案更优
            ans = new_ans;
            num = temp;
            now = temp;
        }
        t *= delta;
        /*else if(exp(DE/t) * RAND_MAX > rand()){
            now = temp;
        }*///一一定概率接受，这段可删去，一样能过
    }
}
void solve(){
    ans = -999999999;//y一开始ans应该特别小
    int qwq = 12;//跑12次
    while(qwq--){
        SA();
    }
    double x = num;
    printf("%.5llf\n", num);
}
signed main()
{
    srand(time(0));
    input();
    solve();
    return 0;
}

```

---

## 作者：小白四个白 (赞：24)

	大家可能都太巨了

	各种求导+二分/随机化算法真的强
    
    是时候介绍一个属于蒟蒻的方法了
    
# 枚举

```cpp

#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

double caculate(double a[],int cnt,double x){
	double sum=0.0,temp=1.0;
	for(int i=0;i<=cnt;i++){
		sum+=temp*a[i];
		temp*=x;
	}
	return sum;
} 
#define ccl(x) caculate(f,n,x)

int n;
double l,r,f[15];

double ans=-20180706.0;

int main(){
	scanf("%d%lf%lf",&n,&l,&r);
	for(int i=0;i<=n;i++) scanf("%lf",f+(n-i));
	
	double pre=ccl(l),now=ccl(l+0.000001),nxt;
	for(double i=l+0.000001;i<r;i+=0.000001){
		nxt=ccl(i+0.000001);
		if(pre<=now && nxt<=now){
			ans=i;
			break;
		}
		pre=now;
		now=nxt;
	}
	if(ans!=-20180706.0){
		printf("%.5lf\n",ans);
		return 0;
	}
	if(ccl(l)>ccl(r)) printf("%.5lf\n",l);
	else printf("%.5lf\n",r);
	return 0;
}
```
  
###   	因为lr不会超过一位数
####   	时间复杂度O(n*(r-l)*1e6)上限为O(260000000)
#####   	随缘AC


---

## 作者：虞皓翔 (赞：17)

### 方法一：裸三分。

在[L, R]中，

取a = (2L + R) / 3, b = (L + 2R) / 3。

如果f(a) > f(b)

则答案在[L, b]里（如果在[b, R]里，则[a, b]段递增），

如果f(a) < f(b)

则答案在[a, R]里（如果在[L, a]里，则[a, b]段递减），

递归或循环即可。

复杂度是log(2/3, 1e-5/d)=log(3/2, d\*100000)≈30 + 1.7lgd.

此处不贴代码。

### 方法二：黄金分。

因为在计算a, b后，如果f(a) > f(b)，则a还在区间[L, b]中然而没有用，所以可以优化。

定义φ为x²+x-1=0的正根。

取a = φL + (1 - φ)R, b = (1 - φ)L + φR。

则，如果f(a) > f(b)，答案在[L, b]中，

下一次的b' = (1 - φ)L + φb = (1 - φ)L + φ[(1 - φ)L + φR] = (1 - φ²)L + φ²R = φL + (1 - φ)R = a。

可以少一次计算。

复杂度是log(φ, 1e-5/d) = log(1/φ, d\*100000) ≈ 24 + 1.44lgd，并且常数少了一半（如果次数较高常数比较有用）。

### 而且，再计算多项式的值时，可以使用秦九韶算法来加快常数（普通算法复杂度O(n²/2)，秦九韶算法复杂度O(2n)）

下面是代码：

```cpp
#include <bits/stdc++.h>
#include <cmath>
#define PHI 0.6180339887498948482
using namespace std;

typedef long double LD;

int n, i;
LD L, R, mL, mR;
LD a[15], d, fL, fR;

LD f(LD x){
    LD s = a[n];
    for(int i = n - 1; i >= 0; i--)
        s = s * x + a[i];
    return s;
}

int main(){
    scanf("%d%Lf%Lf", &n, &L, &R);
    for(i = n; i >= 0; i--)
        scanf("%Lf", a + i);
    d = (R - L) * PHI;
    mL = R - d;
    mR = L + d;
    while(d > 1e-6){
        fL = f(mL);
        fR = f(mR);
        d *= PHI;
        if(fL >= fR){
            mR = mL;
            R = mR;
            mL = R - d;
        }else{
            mL = mR;
            L = mL;
            mR = L + d;
        }
    }
    printf("%.5Lf\n", mR);
}
```

---

## 作者：YoungLove (赞：15)


[Youngsc](https://youngscc.github.io/)

貌似跟别人不一样我用的四分而且好像还能更快一些。。。


我们可以考虑将函数平均分成四段,分割点如图标记为$x_1,x_2,x_3$。


![it](https://raw.githubusercontent.com/Youngscc/Youngscc.github.io/master/img/%E6%96%B0%E5%BB%BA%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F.bmp)


那么我们可以考虑，对于$x_1,x_2,x_3$,对应的$y_1,y_2,y_3$就应该有三种情况,如果$y_1>y_2>y_3$，那么极值一定在$x_2$左边，如果$y_1<y_2<y_3$，那么极值一定在$x_2$右边,如果$y_1<y_2$并且$y_3<y_2$，此时无论$y_1$与$y_3$的大小，函数的极值一定在$x_1$和$x_3$之间(以上均画图可证)。每次都去"四"分答案，并不断调整边界就可以,鉴于区间大小每次都缩小$\frac{1}{2}$，而正统三分法区间每次缩小$\frac 1 3$,所以应该是比三分快那么一丢丢的。


代码如下

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cstdlib>
# include <string>
# include <cmath>
# define R register
# define db double
# define LL long long
using namespace std;

int n;
db l,r,a[20];

inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline void maxx(R int &a,const int b){a>b? 0:a=b;}
inline void minn(R int &a,const int b){a<b? 0:a=b;}

inline db powe(R db a,R int b){
    R db ret = 1.0;
    while(b){
        if(b&1) ret *= a;
        a*=a;
        b>>=1;
    }
    return ret;
}

inline db get(R db x){
    R db ret = 0;
    for(R int i=0; i<=n; ++i) ret += a[i]*powe(x,n-i);
    return ret;
}

int main(){
    // freopen("beads.in","r",stdin);
    // freopen("beads.out","w",stdout);
    scanf("%d %lf %lf",&n,&l,&r);
    for(R int i=0; i<=n; ++i) scanf("%lf",&a[i]);
    for(R int t=1; t<=50; ++t){
        R db mm=(l+r)/2.0,ml=(l+mm)/2.0,mr=(mm+r)/2.0;
        R db am=get(mm),al=get(ml),ar=get(mr);
        if(al<am&&am<ar) l=mm;
        if(al>am&&am>ar) r=mm;
        if(am>al&&am>ar) l=ml,r=mr;
    }
    printf("%.5lf",l);
    return 0;
}
```

---

## 作者：Black_Gzombie (赞：13)

大佬们太强了Orz 各种求导三分，还有梯度下降orzzzzz
蒟蒻就写一个还没有人写过的算法吧

其实这道题可以用**模拟退火**算法
这是一种玄学算法（要用rand()函数）
算法基本思路如下：

```cpp
while(温度大于某个边界值(如1e-14))
{


1.随机变化x坐标，变化幅度为t。变化后的x记为x'

2.计算f(x')值与当前f(x)值的差de

3.若新解f(x')优于当前解f(x)，则接受新解，即x=x'

4.否则以exp(de/t)的概率用新解替换当前解

5.温度乘上一个大于0小于1的常数，即降温

}
```


附上AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

double l,r;
int n;
double a[15];
double t;
const double delta=0.993;//降温常数 
double ans=-1e18-7,xans;

double f(double x)
{
	double sum=0;
	if(x<l||x>r)return -1e18-7;
	for(int i=n;i>=0;i--)
	{
		sum+=a[i]*pow(x,i);
	}
	return sum;
}//计算f(x)的值 

void SA()
{
	double xx=xans;//初始化x的值 
	t=1926;//初始温度 
	while(t>1e-14)
	{
		double xtemp=xans+((rand()<<1)-RAND_MAX)*t;//随机生成一个x 
		double new_ans=f(xtemp);//计算新解 
		double DE=new_ans-ans;//计算新解与当前解的差值 
		if(DE>0)//新解大于当前解，则接受 
		{
			xx=xtemp;
			xans=xx;
			ans=new_ans;
		}
		else if(exp(-DE/t)*RAND_MAX>rand())//否则以概率接受 
		{
			xx=xtemp;
		}
		t*=delta;//降温 
	}
}//模拟退火 

int main()
{
	scanf("%d%lf%lf",&n,&l,&r);
	for(int i=n;i>=0;i--)scanf("%lf",&a[i]);
	SA();
	SA();
	SA();//运行三次减小误差 
	printf("%.5lf",xans);
	return 0;
}
```

---

## 作者：panzheng1999 (赞：11)

还有几天就退役了，再写一些题解吧。。。

求单峰函数极值点可以想到三分

和二分类比一下，二分需要一个中间点，三分需要两个中间点，就是三等分点

然后根据求的是极大值还是极小值比较三分点并转移，精度问题可以l，r做差与精度比较即可


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n;
double l,r;
double num[14];
double f(double x)//计算f(x)
{
    double ans=0;
    for(int i=n;i>=0;i--)
    {
        ans+=num[i]*pow(x,i);
    }
    return ans;
}
int main()
{
    cin>>n>>l>>r;
    for(int i=n;i>=0;i--)
        cin>>num[i];
    double lm,rm;
    while(r-l>0.000001)//控制精度
    {
        //cout<<l<<" "<<r<<endl;
        lm=l+(r-l)/3;//左三等分点
        rm=r-(r-l)/3;//右三等分点
        if(f(lm)<=f(rm)) l=lm;//极大值在lm左侧
        else r=rm;//反之在rm右侧
    }
    printf("%.5lf",l);
    return 0;
}

```

---

## 作者：xukuan (赞：11)

鬼知道为什么这题有这么多非正解的题解。

三分法有，直接的看是比较两个三等分点的权值，但实际上是比较中点旁边两个点的权值这样更快。

为什么呢？因为在$f(mid1)==f(mid2)$的时候前者会舍去$\frac{2}{3}$段区间，后者就直接出答案了，这种情况基本不存在；否则前者舍去$\frac{1}{3}$的区间，后者舍去$\frac{1}{2}$段区间。

现在三分查找的问题解决了，还有一个问题：f函数怎么快速的实现？

暴力实现是$O(n^2)$的，怎么优化？

学过FFT的同学都知道霍纳法则，即$a_0x^0+a_1x^1+a_2x^2+\dots+a_nx^n=a_0+x(a_1+x(\dots+a_{n-1}+x*a_n+\dots))$

这样我们可以在$O(1)$的时间内求出f函数

代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=20;
const double eps=1e-6;
ll n;
double l,r,a[N];

inline double F(double x){
    double sum=0;
    for(ll i=n; i>=0; i--) sum=sum*x+a[i];
    return sum;
}

int main(){
    scanf("%lld %lf %lf",&n,&l,&r);
    for(ll i=n; i>=0; i--) scanf("%lf",&a[i]);
    while(r-l>eps){
        double mid=(l+r)/2;
        if(F(mid+eps)>F(mid-eps)) l=mid;
        else r=mid;
    }
    printf("%.5lf",l);
    return 0;
}
```

---

## 作者：爷，无限霸气 (赞：9)

# 三分求单峰函数

二分：分成两段，三分：分成三段。

![单峰函数](https://cdn.luogu.com.cn/upload/image_hosting/gmdyv8ok.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图所示，假设有l,r;lmid是偏向l的三等分点，rmid是偏向r的三等分点

那么l~lmid：递增（或递减），lmid~rmid：先递增后递减（或先减后增），rmid~r：递减（或递增）,再进行下述步骤（求极大值）：

1.如果f(lmid)<f(rmid),那么l=lmid;

2.如果f(lmid)==f(rmid),可随意移l或r;

3.如果f(lmid)>f(rmid),那么r=rmid;

就可以求单峰函数最大值了(不懂可以画画图)；

接下来的操作与二分基本相同，只不过要保证精度，最好是k+2位精度哦！

代码：

```cpp
#include<bits/stdc++.h>
#define ll double
#define eps 1e-7//保证精度
#define Maxn 20
using namespace std;
int n;
ll l,r,xs[Maxn];
ll f(ll x)//求函数值
{
	ll u=1,p=0;
    for(int i=n;i>=0;--i){
    	p+=u*xs[i];
    	u*=x;
	}
    return p;    
}
ll ef(ll l,ll r)//三分
{
	while(l+eps<r)
	{
		ll lmid=l+(r-l)/3,rmid=r-(r-l)/3;
		if(f(lmid)<=f(rmid)) l=lmid;
		else r=rmid;
	}
	return r;
}
int main()
{
	scanf("%d",&n);
	scanf("%lf%lf",&l,&r);
	for(int i=0;i<=n;i++) scanf("%lf",&xs[i]);
	printf("%.5lf",ef(l,r));//输出答案
	return 0;
}
```

---

## 作者：平衡树森林 (赞：8)

既然看到没什么人介绍这个算法，那我来讲这样一个~~不实用的~~算法

梯度下降
=
~~（不确定是不是这么叫的叫错了大佬们别打我~）~~
梯度下降是一种用来逼近函数**最小值**的算法

（这题求的是最大值，和求最小值几乎一样，所以我先说说最小值的求法）

什么是梯度呢？对于一元函数，你可以理解为函数图像在某一点**上升的方向和坡度**或者说是它的**导数**

所谓梯度下降，就是沿着与梯度相反的方向走。可以形象的理解为，从函数图像的某一点往下滑，一直滑到最低点。

下面给出梯度下降~~显而易见的~~公式：

**x_new=x_old−η∇f(x)**
=
其中，∇f(x)为f(x)的梯度，η为步长

看一下下降的过程：(注：这个图不是我画的)

![](https://cuijiahua.com/wp-content/uploads/2018/11/dl-8-3.png)

这样就能逼近函数最小值了

------------
回到本题，怎么求最大值呢？只要把梯度下降的过程反过来就行了：沿着梯度**向上爬**

本题的函数f(x)的导数f'(x)非常好求：

f'(x)=(AnX^n + An-1X^n-1 + An-2X^n-2 + ... + A1X + A0)'

     =n(AnX^n) + (n-1)(An-1X^n-1) + (n-2)(An-2X^n-2) + ... + A1X
     
```cpp
double fun_(LLd x)
{
	double ans=0;
	for (int i=n;i>=1;i--)
	{
		ans=ans*x+a[i]*i;
	}
	return ans;
}
```
从哪开始计算呢？l到r范围内任意一点都可以，这里我们取中点

至于η的取值，本题应取得很小（实测需取到0.0000001）。因为l和r相距很
近，而斜率可能很大，容易跳出l,r的范围

然后就可以开心的迭代啦

这个算法有多不靠谱呢？


AC代码TLE了样例！！！qwq
=
上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define LL long long
#define LLd long double
using namespace std;

const LL maxn=15;
const LLd eta=0.0000001;
LLd a[maxn];
LLd n;

LLd fun_(LLd x)
{
	LLd ans=0;
	for (LL i=n;i>=1;i--) ans=ans*x+a[i]*i;
	return ans;
}

int main()
{
	LLd l,r;
	cin>>n>>l>>r;
	for (LL i=n;i>=0;i--) cin>>a[i];
	LLd x=(l+r)/2;
	while (abs(fun_(x))>0.000001) x=x+eta*fun_(x);
	printf("%.5Lf\n",x);
	return 0;
}
```

(想测试样例把η(eta)改大到0.0001就行了)


------------

这种算法还能扩展到多元函数(不过导数变成了偏导数)

事实上现在的人工智能大多也是用**梯度下降**训练的qwq


---

## 作者：hwk0518 (赞：8)

看到大家用的都是二/三/四分法，我就来写一篇优选法的题解。

优选法由美国数学家J·基弗提出，由我国数学家华罗庚推广，将其投入实际生产应用中，为提高产量作出了巨大贡献。

但是，很多讲解优选法的论文都是错的，包括唯一一篇讲解了优选法的集训队论文（2005杨思雨《美，无处不在——浅谈“黄金分割”和信息学的联系》）。本题解参考了华教授的《优选法》，旨在向大家推介正确的优选法。

1.优选法可以做什么？

可以用来求解最优化问题，例如单峰函数的极值。

2.如何实现优选法？

（为了叙述的简便，我们假定要计算的区间是[0,1]）

Step1:先在(3-sqrt(5))/2和(sqrt(5)-1)/2处求值。

Step2:如果左边小就将左端点移至(3-sqrt(5))/2，假设这是在用三分法，我们还要再求出区间[(3-sqrt(5))/2,1]的两个计算点，但是优选法不用了，因为区间[0,1]的右计算点和区间[(3-sqrt(5))/2,1]的左计算点重合了。如果右边小，是同理的。

Step3:重复Step2直至左端点和右端点相差不超过最小误差。


3.为什么三分法不如优选法优秀？

最优秀的三分法两个计算点应当取在区间中点的两侧且尽量接近区间中点，这样计算两次就几乎可以将区间缩小一半，但是这两次计算的结果几乎不可能被后面的操作利用；而优选法可以将计算的结果为后面所用，节省了计算次数。

4.在本题中，三分法和优选法分别要计算几次？

最坏情况下区间是[-10,10]的，三分法要计算log(2,1000000)*2=40次，优选法则要计算log(1.618,1000000)=28次，比三分法少。大家看传统题的常数可能没有感觉，但是当限制查询次数的交互题出现时，优选法就派上用场了。

5.杨思雨的论文错在哪？

她的论文中写“这样（指三分）一次可以舍去整个[a,b]的将近50%，但是接下来每次只能舍去很小的一部分了，反而不利于较快地逼近最优点”，如果三分的要害真的只是这样，那优选法难道不是每次只能舍去[a,b]的不到40%？那华教授推广优选法，倒不如推广三分法？这个理由显然略显牵强。

长话短说，优选法的确是到目前为止求解单峰函数最高（低）点的最快算法。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const double eps=1e-7;
const double gol=(3-sqrt(5))/2;//0.382...
const double gor=(sqrt(5)-1)/2;//0.618...
int n;
double l,r,t,tx,ty,sx,sy,a[15];

double sum(double x)
{
	int i;
	double ret=0;
	for(i=n;i>-1;--i)
		ret=ret*x+a[i];
	return ret; 
}

int main()
{
	int i;
	scanf("%d%lf%lf",&n,&l,&r);
	for(i=n;i>-1;--i) scanf("%lf",&a[i]);
	tx=l*gor+r*gol,ty=l*gol+r*gor;
	sx=sum(tx),sy=sum(ty);
	while(fabs(l-r)>eps)
	{
		if(sx<sy)
		{
			l=tx;
			tx=ty;
			sx=sy;//避免重复计算
			ty=l*gol+r*gor;
			sy=sum(ty);
		}
		else
		{
			r=ty;
			ty=tx;
			sy=sx;//避免重复计算
			tx=l*gor+r*gol;
			sx=sum(tx);
		}
	}
	printf("%.5lf\n",r);
	return 0;
}
```

---

## 作者：设计涉及社稷 (赞：7)

## 前置技能：秦九韶定理（转自百度百科）
~~**注：“韶”字念“[sháo]”而不念“ [zhāo] ”我这个蒟蒻就念错了15年〇6个月**~~

### 一般地，一元n次多项式的求值需要经过[n（n+1）]/2次乘法和n次加法，而秦九韶算法只需要n次乘法和n次加法。在人工计算时，一次大大简化了运算过程。

把一个n次多项式f(x)=a[n]x^n+a[n-1]x^(n-1)+......+a[1]x+a[0]改写成如下形式   

       f(x)=a[n]x^n+a[n-1]x^(n-1))+......+a[1]x+a[0] 　　

            =(a[n]x^(n-1)+a[n-1]x^(n-2)+......+a[1])x+a[0] 　　

            =((a[n]x^(n-2)+a[n-1]x^(n-3)+......+a[2])x+a[1])x+a[0] 　　

            =...... 　　

            =(......((a[n]x+a[n-1])x+a[n-2])x+......+a[1])x+a[0]. 　　

### 求多项式的值时，首先计算最内层括号内一次多项式的值，即 　　**ans[1]=a[n]*x+a[n-1]** 　　然后由内向外逐层计算一次多项式的值，即 　　

            v[2]=v[1]x+a[n-2] 　　

            v[3]=v[2]x+a[n-3]

             　　...... 　　

            v[n]=v[n-1]x+a[0]
![](https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=c80b7d7e544e9258a6618ee8acb2fd60/c75c10385343fbf273393339b27eca8065388f97.jpg)

### 接下来是裸的三分操作
```
#include<bits/stdc++.h>
#define eps 1e-8
#define rep(i,x,y) for(register int i = x;i <= y;++i)
#define dwn(i,x,y) for(register int i = x;i >= y;--i)
#define N 14
using namespace std;
double l,r,a[N];
int n;
	
double check(double x)
{
	double ans = 0;
	dwn(i,n,0)
		ans=ans*x+a[i];//秦九韶公式
	return ans;
}
 
int main()
{
	scanf("%d",&n);
	scanf("%lf%lf",&l,&r);
	rep(i,0,n)
		scanf("%lf",&a[n-i]);
	while(r-l>eps)
	{
		double mid1=l+(r-l)/3,mid2=r-(r-l)/3;
		if(check(mid1)>check(mid2))
			r=mid2;
		else 
			l=mid1;
	}
	printf("%.5lf",l);
	return 0;
}
```

---

## 作者：封禁用户 (赞：7)

这就是三分的板题，[博客同步](http://www.cinema000.xyz/2018/05/14/solution-luogu-p3382.html)

但我太弱了，写的极其暴力，还用到了函数指针这种玩意（[戳这里](http://www.cinema000.xyz/2018/05/14/function-pointer.html)）

三分的讲解在[这里](http://www.cinema000.xyz/2018/05/14/trichotomy.html)

一开始还没有注意到保留五位小数，，，算的比答案还精确

三分就不细讲了，这篇题解主要的意义就是在于函数指针这个小技巧

当你被自己的实现方法卡住，不妨试试这个，sort的cmp也就是这种方法实现的

让一个函数作为另一个函数的指针

```
#include<cstdio>
#include<cmath>

const double eps = 1e-6;

double a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p;

double f7(double x){
	return a * pow(x,7) + b * pow(x,6) + c * pow(x,5) + d * pow(x,4) + e * pow(x,3) + f * pow(x,2) + g * pow(x,1) + h;
} 

double f8(double x){
	return a * pow(x,8) + b * pow(x,7) + c * pow(x,6) + d * pow(x,5) + e * pow(x,4) + f * pow(x,3) + g * pow(x,2) + h * pow(x,1) + i;
} 

double f9(double x){
	return a * pow(x,9) + b * pow(x,8) + c * pow(x,7) + d * pow(x,6) + e * pow(x,5) + f * pow(x,4) + g * pow(x,3) + h * pow(x,2) + i * pow(x,1) + j;
} 

double f10(double x){
	return a * pow(x,10) + b * pow(x,9) + c * pow(x,8) + d * pow(x,7) + e * pow(x,6) + f * pow(x,5) + g * pow(x,4) + h * pow(x,3) + i * pow(x,2) + j * pow(x,1) + k;
} 

double f11(double x){
	return a * pow(x,11) + b * pow(x,10) + c * pow(x,9) + d * pow(x,8) + e * pow(x,7) + f * pow(x,6) + g * pow(x,5) + h * pow(x,4) + i * pow(x,3) + j * pow(x,2) + k * pow(x,1) + l;
} 

double f12(double x){
	return a * pow(x,12) + b * pow(x,11) + c * pow(x,10) + d * pow(x,9) + e * pow(x,8) + f * pow(x,7) + g * pow(x,6) + h * pow(x,5) + i * pow(x,4) + j * pow(x,3) + k * pow(x,2) + l * pow(x,1) + m;
} 

double f13(double x){
	return a * pow(x,13) + b * pow(x,12) + c * pow(x,11) + d * pow(x,10) + e * pow(x,9) + f * pow(x,8) + g * pow(x,7) + h * pow(x,6) + i * pow(x,5) + j * pow(x,4) + k * pow(x,3) + l * pow(x,2) + m * pow(x,1) + n;
} 

double trichotomy(double L,double R,double (*f)(double)){
	double mid,mmid;
	
	while(R - L >= eps){
		mid = L + (R - L) / 3;
		mmid = R - (R - L) / 3;
		
		if(f(mid) <= f(mmid)){
			L = mid;
		}else{
			R = mmid;
		}
	}
	
	return (mid + mmid) / 2;
}

int main(){
	a = b = c = d = e = f = g = h = i = j = l = m = n = o = p = 0;
	
	int cnt;
	scanf("%d",&cnt);
	double L,R;
	scanf("%lf %lf",&L,&R);
	
	if(cnt == 7){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h);
		printf("%.5lf",trichotomy(L,R,f7));
	}else if(cnt == 8){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h,&i);
		printf("%.5lf",trichotomy(L,R,f8));
	}else if(cnt == 9){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h,&i,&j);
		printf("%.5lf",trichotomy(L,R,f9));
	}else if(cnt == 10){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h,&i,&j,&k);
		printf("%.5lf",trichotomy(L,R,f10));
	}else if(cnt == 11){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h,&i,&j,&k,&l);
		printf("%.5lf",trichotomy(L,R,f11));
	}else if(cnt == 12){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h,&i,&j,&k,&l,&m);
		printf("%.5lf",trichotomy(L,R,f12));
	}else if(cnt == 13){
		scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&e,&f,&g,&h,&i,&j,&k,&l,&m,&n);
		printf("%.5lf",trichotomy(L,R,f13));
	}
	
	return 0;
} 
```


---

## 作者：Ireliaღ (赞：5)

很多人对模拟退火算法的讲解都说过类似这样的话

>为了避免落入局部最优解，我们要随机接受一个更坏的值来跳出局部最优解

然而，区间单峰函数并不存在让人落进去的局部最优解，所以我们引入一个更简单的算法——

# 爬山算法

## 算法思想

顾名思义，我们在函数上“爬山”，**每次看左右哪边是“上坡”，就往哪边爬一点**。代码实现极其简单，思维难度几乎为0

## 程序实现

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
#include <cmath>
#include <iomanip>

using namespace std;

int n;
double l, r;
double co[15];

int Rand() {//我们不想随机出一个太大的数，那样每次移动的就太小了
	return rand() % 1000 + 500;
}

double Func(double x) {//暴力计算函数
	double res = 0;
	for (int i = 0; i <= n; i++) {
		double tmp = 1;
		for (int j = 1; j <= i; j++) tmp *= x;
		res += co[i] * tmp;
	}
	return res;
}

double Move(double x, int typ) {//左右移动，0为左1为右，注意是否跨过0
	if (x < 0) {
		if (typ == 1) {
			if (x > -1e-5) x += 1e-5;
			else x *= (1.000000 - 1.000000 / Rand());
		} else {
			x *= (1.000000 + 1.000000 / Rand());
		}
	} else {
		if (typ == 1) {
			x *= (1.000000 + 1.000000 / Rand());
		} else {
			if (x < 1e-5) x -= 1e-5;
			else x *= (1.000000 - 1.000000 / Rand());
		}
	}
	return x;
}

int main() {
	srand(114514);
	cin >> n >> l >> r;
	for (int i = n; i >= 0; i--) cin >> co[i];
	double cur = (l + r) / 2.000000; //随便找个初始开爬的点，强迫症让我选了中点
	double f = Func(cur);
	double f1, f2, nxt1, nxt2, mx = f, mxans = cur;
	for (int i = 1; i <= 100000; i++) {
//		cerr << cur << "\n";
		nxt1 = Move(cur, 0);//尝试左右移动
		nxt2 = Move(cur, 1);
		f1 = Func(nxt1);//计算两种函数值
		f2 = Func(nxt2);
		if (f1 > f) {
			cur = nxt1;
			f = f1;
		} else {
			cur = nxt2;
			f = f2;
		}
		if (f > mx) {//更新最优解
			mx = f;
			mxans = cur;
		}
	}
	cout << fixed << setprecision(5) << mxans << "\n";
	return 0;
}
```

---

## 作者：小黑AWM (赞：5)

# 本题解共介绍两种求幂函数定义域中单峰的做法

## 三分

原理简单，比较容易想到，且适用于所有在定义域中单调性只改变一次的函数，但是个人感觉不太自然，就是比较定义域中的两个三等分点的映射值，若左边的三等分点比较大，则将右边界右移，对于左边界同理，最终不断逼近得到单峰的位置。说一下三等分点怎么求，左边界右边三分之一的区间长度和右边界左边三分之一的区间长度。

代码

```cpp
#include<cstdio>
using namespace std;
int n;
double a[20],L,R,l,r,k;
double f(double x){
    double ans=0;
    for(int i=n;i>=0;i--) ans=ans*x+a[i];//这个计算其他题解中都讲过了我就不说了
    return ans;
}
int main(){
    scanf("%d%lf%lf",&n,&L,&R);
    for(int i=n;i>=0;i--) scanf("%lf",&a[i]);
    while(R-L>=1e-6){
        k=(R-L)/3.0;
        l=L+k,r=R-k;
        if(f(l)>f(r)) R=r;else L=l;
    }
    printf("%.5lf\n",L);
    return 0;
}

```

## 幂函数求导+二分

优点，对多项式进行求导由于比较自然，非常好写，这里讲一下幂函数求导公式，基本上高中都要学的，很好背。若$f(x)=x^{n}$则$f'(x)=nx^{n-1}$，具体如何求导见程序。导数的函数对应的值表示每一点的切线斜率，所以当该点的导数值大于0则单调增，小于零则单调减，所以只需判断是否大于零即可。个人比较喜欢这种写法，主要直接判是否大于零非常爽……

缺点，如果换一道题不是多项式函数的话就不能用这个求单峰了。

代码：

```cpp
//狠狠鄙视一波三分
#include<cstdio>
using namespace std;
int n;
double a[20],L,R,k;
double f(double x){
    double ans=0;
    for(int i=n;i>=1;i--) ans=ans*x+a[i];//常数项没了
    return ans;
}
int main(){
    scanf("%d%lf%lf",&n,&L,&R);
    for(int i=n;i>=0;i--)scanf("%lf",&a[i]),a[i]*=i;
    while(R-L>=1e-6){
      double mid=(R+L)/2;
      f(mid)>0?L=mid:R=mid;
    }
    printf("%.5lf\n",L);
    return 0;
}

```


---

## 作者：qnickx (赞：3)

# 正常三分
因为题中给出的函数是一个单峰函数，其极大点左侧是**严格单调上升**，右侧是**严格单调下降**的,，可以用三分法求它的极值。

可以在它的定义域$[l,r]$上任取两个点$lmid$和$rmid$，使函数分为三段。然后每次三分分以下几种情况：
1. 若$f(lmid)<f(rmid)$，那么根据单峰函数性质，这两个点要么都在极大值左侧，要么极大值在它们两个之间，但无论哪种情况极大值都在$lmid$的右侧，因此令l=lmid;
2. 若$f(lmid)>f(rmid)$，那么根据单峰函数性质，类比前一种情况，极大点一定在$rmid$的左侧，则令$r=rmid$;
3. 如果$f(lmid)=f(rmid)$，那么$l=lmid$或$r=rmid$均可。

这样的话，每次定义域范围就近似缩小了$\dfrac{1}{3}$
### 怎么判断三分的边界呢？

类似于二分实数域上的二分，要么开个eps判，要么直接卡一定循环次数即可。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#include<cmath>
using namespace std;
int n;
double sz[15],sum,dan,l,r,lmid,rmid,mid;
inline double calc(double tmp){
	double ans=0;
	for(register int i=1;i<=n+1;i++)	ans+=(pow(tmp,n+1-i)*sz[i]);
	return ans;
}
int main(){
	scanf("%d%lf%lf",&n,&l,&r);
	for(register int i=1;i<=n+1;i++)	scanf("%lf",&sz[i]);
	for(register int i=1;i<=1000;i++){
		mid=(l+r)/2;
		lmid=(l+mid)/2;
		rmid=(mid+r)/2;
		double tmp1=calc(lmid);
		double tmp2=calc(rmid);
		if(tmp1==tmp2){
			l=lmid;
			dan=lmid;
		}
		if(tmp1<tmp2){
			l=lmid;
			dan=lmid;
		}
		if(tmp1>tmp2){
			r=rmid;
			dan=rmid;
		}
	}
	printf("%.5lf",dan);
	return 0;
}
```


---

## 作者：limi_sanhua (赞：3)

补一个退火算法...

退火就不是什么正经的算法，谨慎使用

~~退火大法好~~

退火没什么好说的，差不多是直接模板了
```cpp
#include<bits/stdc++.h>
using namespace std;
#define dd double
int N;
dd a[20],x,y;int mx;
dd js(dd x)
{
    dd re=0;
    for(int i=0;i<=N-1;++i)
    {
        re+=a[i]*pow(x,(N-i));
    }
    return re;
}
struct node
{
    dd x,y;
}ans;
void sa()
{
    dd t=100.0,v=0.99;
    while(t>=1e-6)
    {
        dd s=(rand()%mx+1)*t/100.0;
        dd lx=ans.x-s,rx=ans.x+s;
        dd ll=js(lx),rr=js(rx);
        if(lx>=x&&ll>ans.y)
        {
            ans.x=lx;
            ans.y=ll;
        }
        if(rx<=y&&rr>ans.y)
        {
            ans.x=rx;
            ans.y=rr;
        }
        t*=v;
    }
}
int main()
{
    scanf("%d%lf%lf",&N,&x,&y);
    mx=y-x+1;
    for(int i=0;i<=N-1;++i)
    {
        scanf("%lf",&a[i]);
    }
    ans.x=(x+y)/2.0;ans.y=js(ans.x);
    int n=10;
    sa();
    printf("%.5f",ans.x);
}
```

---

## 作者：tiger2005 (赞：3)

三分大法好！
```cpp
#include<cstdio>
using namespace std;
double f[15],L,R,M1,M2;
int N;
double pow(double a,int x){
    double nn=1;
    while(x--)	nn*=a;
    return nn;	
} 
double ss(double now){//算值
    double no=0;
    for(int i=0;i<=N;i++){
        no=no+f[i]*pow(now,N-i);
    }
    return no;
}
int main(){
    scanf(" %d %lf %lf",&N,&L,&R);
    for(int i=0;i<=N;i++)	scanf(" %lf",&f[i]);
    while(L<R-0.00000001){
        M1=L+(R-L)/3;
        M2=R-(R-L)/3;//三等分点
        double aa=ss(M1),bb=ss(M2);
        if(aa<bb)	L=M1;//舍左
        else	if(aa>bb)	R=M2;//舍右
        else{
            L=M1;R=M2;//双舍
        }
    }
    printf("%.5lf",L);
}
```

---

## 作者：Laser_Crystal (赞：2)

### qwq这道题其实不用三分做的，直接暴力地用二分做就行了qwq
但是在做二分前，要先了解两个概念：秦九韶公式和函数求导
#### 先讲简单一点的秦九韶公式：
在数学上我觉得没啥大用处，但是在OI里可以吧O(n²)的多项式求值变成O(n)的方法，具体的公式是：

$a_{1}*x^n+a_{2}*x^{n-1}+a_{3}*x^{n-2}+……+a_{n-1}*x+a_{n}$

$=x*(a_{1}*x^{n-1}+a_{2}*x^{n-2}+a_{3}*x^{n-3}+……+a_{n-1})+a_{n}$

$=x*(x*(a_{1}*x^{n-2}+a_{2}*x^{n-3}+a_{3}*x^{n-4}+……+)+a_{n-1})+a_{n}$

$=$……

$=x*(x*(x*(x*……*(a_{1}*x)+a_{2})+a_{3})+a_{4}+……+a_{n-1})+a_{n}$

就是用乘法分配律乘进去，把O($n^2$)弄成了O(n)

```cpp
inline double f(double t)//秦九韶公式
{
  double ans=k[0]*t+k[1];
  for(int i=2; i<=n; i++)  ans=ans*t+k[i];
  return ans;
}
```
#### 再讲函数求导：
我自己也讲不清，我就引用一下书上的解释（《高等数学》同济大学出版社，上个世纪80年代出版的，就是我爸的大学数学课本）：

定义：

设函数$y=f(x)$在点$x_{0}$的某个邻域内有定义，当自变量$x$在$x_{0}$处取得增量△$x$（点$x_{0}$+△$x$仍在该邻域内）时，相应的函数$y$取得增量△$y=f(x_{0}+x)-f(x_{0})$；如果△$y$与△$x$之比当△$x$->0时的极限存在，则称函数$y=f(x)$在点$x_{0}$处**可导**，并称这个极限为函数$y=f(x)$在点$x_{0}$处的**导数**

$f'(x)=\lim\limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}$

就上面是这个$f'(x)$就是$f(x)$的**导函数**qwq

函数的导数可以求直线变速运动的瞬时速度或者切线问题

那么在这道题里我们可以把这个函数图像看成行程图，就是当函数图像在上升的时候，导数为正；图像在下降的时候，导数为负。如果就是在顶点上，那么导数为0，就是**零点**

零点是什么？嘤嘤嘤就是那个**要求的$x$啊**！qwq！

那么根据这个，就可以二分查找了嘤嘤嘤（查找条件就是左右边界小于精度就行了）

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
double k[20];
double x,l,r,mid;
long long n;
inline double f(double t)//秦九韶公式求多项式值
{
  double ans=k[0]*t+k[1];
  for(int i=2; i<=n; i++)  ans=ans*t+k[i];
  return ans;
}
/*
我个人比较蒟蒻，不能用数学方法来求导数，
所以说不能作为绝对的△x->0，那么就取一个十分接近0的数，比如1e-8……
*/
inline double lim(double t)
{
  double x,y;
  x=1e-8; y=f(t+x)-f(t);
  return x/y;
}
int main()
{
  cin>>n;
  cin>>l>>r;
  for(int i=0; i<=n; i++) cin>>k[i];
  while(r-l>1e-8)//二分
  {
    mid=(l+r)/2;
    if(lim(mid)>0) l=mid;
    else r=mid;
  }
  printf("%.5lf",mid);
  return 0;
}
```
嘤嘤嘤再见

---

## 作者：santongding (赞：2)

本来今天做了道凸包中三分的题，由于根本不会三分就用类似二分的做法暴力了一发

然后又来模板这里试一发做法是否通用，居然能过orz

主要思想是一个单峰函数如果一个点b在峰值，那么b的值肯定比两边小，如果在峰值左侧，那么在这个点两边各取a，c，易得a<b<c，在峰值右边也类似；

所以就可以愉快的每次把区间缩小一半来二分啦

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
#define db double
db eps =1e-8;
int n;
db l,r;
db a[15];
db pow(db x,int k){
	db ans=1.0;
	while(k--)ans*=x;
	return ans;
}
db f(db x)
{
	db ans=0;
	for(int i=0;i<=n;i++)
		ans+=pow(x,i)*a[i];
	return ans;
}
int main()
{
	scanf("%d%lf%lf",&n,&l,&r);
	for(int i=n;i>=0;i--)scanf("%lf",&a[i]);
	while(fabs(l-r)>eps){
		db mid=(l+r)/2.0;
		if(f(mid-eps)<f(mid)&&f(mid+eps)<f(mid)){
			l=mid;
			break;
		}
		else if(f(mid-eps)<f(mid))l=mid+eps;
		else r=mid;
	}
	printf("%.5lf\n",l);
	return 0;
}
```

---

## 作者：耗纸大大 (赞：2)

### 三分法模板当然要打暴力三分了（滑稽

一开始没想到系数都是double结果全wa了 改过来就a了 首先是定义个f（）函数计算数据

首先 如果把左右端点更新 如果左端点的函数值大于右端点的函数值 则把r更新成右端点 否则把l更新成左端点

首先是这是三分法 数据n才13所以我们通过计算可以得知 循环不会超过100次 所以用for循环直接100次

然后三分更新 最后输出l或者r都可以 因为那时候l==r了所以都是一样的

具体看代码好了

AC Codes：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#define maxn 15
using namespace std;
double xi[maxn];
int n;
double l,r;
double f(double x)
{
    double ans=0.0;
    for(int i=1;i<=n+1;i++) ans+=xi[i]*pow(x,n-i+1);
    return ans;
}
int main()
{
    cin>>n>>l>>r;
    for(int i=1;i<=n+1;i++) cin>>xi[i];
    double rl=l,rr=r;
    for(int i=1;i<=100;i++)
    {
        double x1=rl+(rr-rl)/3;       //计算三分的左端点
        double x2=rl+((rr-rl)/3*2);  //计算三分的右端点 或者写成x2=rr-（rr-rl）/3；
        if(f(x1)>f(x2)) rr=x2;          //通过画图我们可以明白 如果左端点大于右端点 则右端点缩小范围
        else rl=x1;                       // 假如左端缩小范围的则有可能会错过正解 因为当l在正解左侧的时候 就会有这种情况 小于情况同样可以证明
    }
    printf("%.5lf",rl);            //滑稽输出
    return 0;              //（逃
}
```

---

## 作者：MscWood (赞：1)

题解中很多人都用了三分法

还有一些数学大佬直接二分求导

这些我这个蒟蒻都不会

~~因为我只会暴力~~

这道题的题意就是求一个f(x)的最大值

所以我想到了模拟退火

以下是我的代码（能否AC看人品）

------------

```cpp
#include<bits/stdc++.h>
using namespace std;

double l,r,ans,sum,x,m[20];
int n,Max_rand;

inline double f(double x)//计算函数
{
	double s=0;
	for(int i=0;i<=n;i++)
	{
		s+=pow(x,i)*m[i];
	}
	return s;
}

inline void sa()//核心代码（滑稽）
{
	double t=100,v=0.99;//温度和控温
	while(t>=1e-7)
	{
		double lx=x-(rand()%Max_rand+1)*t/100.0;//随机左边界
		double rx=x+(rand()%Max_rand+1)*t/100.0;//随机右边界
		double sl=f(lx),sr=f(rx);//左右的值
		if(sl>sum&&lx>=l)//左边找到最大值且没有越界
		{
			sum=sl;
			x=lx;
		}
		if(sr>sum&&rx<=r)//右边找到最大值且没有越界
		{
			sum=sr;
			x=rx;
		}
		t*=v;//降温
	}
	return;
}

int main()
{
	scanf("%d%lf%lf",&n,&l,&r);
	for(int i=n;i>=0;i--) scanf("%lf",&m[i]);//倒着读入方便函数计算处理
	x=(l+r)/2.0;//x初始位置
	sum=f(x);
	Max_rand=int(r-l)+1;//随机边界
	sa();
	sa();//防止一次答案不准，多烧一次
	printf("%.5lf",x);
	return 0;
}
```

---

## 作者：硫代硫酸钠 (赞：1)

楼下说的三分法说的很详细，我就不多说了，因为三分法比较好想

然后就是如何用O(n)的时间内求出一个n次多项式的值：秦九韶算法。

这个算法可以参考2014D2T3解方程。（虽然本题而言完全没必要不过挺好用的）

代码当然要有。。。





 
```cpp
#include<bits/stdc++.h>
#define db double
#define eps 0.000000000001
using namespace std;
db l,r,f[20];
int n;
db qjs(db x)
{
    db res=0;
    for (int i=1;i<=n+1;i++) res=(res*x+f[i]);//数学必修3封面
    return res;
}
db jdz(db x) {return (x>0?x:-x);}
db sanfenfa(db l,db r)
{
    db lm=(l+(r-l)/3),rm=(r-(r-l)/3);
    db tl=qjs(lm),tr=qjs(rm);
    if (jdz(tl-tr)<eps) return lm;
    if (tl>tr) return sanfenfa(l,rm);
    else return sanfenfa(lm,r);
}
int main()
{
    scanf("%d%lf%lf",&n,&l,&r);
    for (int i=1;i<=n+1;i++ ) scanf("%lf",&f[i]);
    printf("%.5lf",sanfenfa(l,r));
    return 0;
}

```

---

## 作者：AntaresQAQ (赞：1)

打个暴力的三分模板。

采用递归思路三分。

每次先求出区间内左右的三分点，对比两点的函数值大小谁更接近最大值，就让区间缩合，直到区间变为足够小，就得到了函数最大值。

裸的三分思路，相对来说比二分求导简单些。

代码如下






```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
double a[14];
double f(double x)
{
    double ans=a[0];
    for(int i=1;i<=n;i++)
        ans=ans*x+a[i];
    return ans;
}
void fen(double l,double r)
{
    if(r-l<=0.000001)
    {
        printf("%0.5lf",r);
        return ;
    }
    double tl=(r-l)/3+l;
    double tr=2*(r-l)/3+l;
    if(f(tl)>f(tr))
        fen(l,tr);
    else
        fen(tl,r);
}
int main()
{
    double l,r;
    cin>>n;
    cin>>l>>r;
    for(int i=0;i<=n;i++)
        cin>>a[i];
    fen(l,r);
    return 0;
}

```

---

## 作者：青丝、暮成雪 (赞：1)

我们知道二分一般用于单调区间，而遇到凸性函数时，三分就能派上很大的用场，此题是三分的模板，练习一下还是有很大好处的。

思路大概就和楼下的一样。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n;
double l,r,xsh[20];
double f(double x)
{
        double ans=0; 
        for(int i=1;i<=n;i++)
        {   
                double temp=xsh[i];
                    for(int j=1;j<=n-i+1;j++)
                    {
                            temp*=x;
                    }
                    ans+=temp;
        }
        return ans+xsh[n+1];
}
int main()
{
        scanf("%d",&n);
        scanf("%lf%lf",&l,&r);
        for(int i=1;i<=n+1;i++)
        scanf("%lf",&xsh[i]);
        double lx=l,rx=r;
        while(abs(lx-rx)>0.000001)
        {
                double x1=lx+(rx-lx)/3,x2=lx+(rx-lx)/3*2;
                if(f(x1)>f(x2)) rx=x2;
                else lx=x1;
        }
        printf("%.5f\n",lx);
        return 0;
}
```

---

## 作者：loceaner (赞：1)

## 思路

这是一道三分的模板题，用于求单峰函数的极值

首先，在函数上标4个点：$x=l,r,mid,mmid$。其中$mmid$是$mid$与$r$的中点。（其实就是把函数三等分了）

然后我们需要通过迭代来缩小范围($while$循环)

>如果$f(mid)>f(mmid)$，则$mmid$一定在峰的右边。
如果$f(mid)<f(mmid)$，则$mid$一定在峰的左边。

这是为什么呢？

### 证明：

1.我们假设存在$f(mid)>f(mmid)$且$mmid$在峰的左边。
由于$f(x)$在峰的左边单调递增，且$f(mid)>f(mmid)$，所以$mid$在$mmid$的右边。
然而$mmid = \frac{mid+rt}{2}$，显然$mid$在$mmid$左边。矛盾。

2.我们假设存在$f(mid)<f(mmid)$且$mid$在峰的右边。
由于$f(x)$在峰的右边单调递减，且$f(mid)<f(mmid)$，所以$mid$在$mmid$的右边。
然而$mmid = \frac{mid+rt}{2}$，显然$mid$在$mmid$左边。矛盾。

那么如何求$f(n)$呢

这就需要用到秦九韶公式了，大家可以自行百度，这里就不说了
（点击下面的让我帮帮你吧）
[**让我帮帮你吧**](http://iwo.im/?q=%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95)

下面给出代码

## 代码
```cpp
#include<bits/stdc++.h>
#define db double
#define N 20
using namespace std;

const db eps=1e-6;
int n;
db a[20],l,r,mid,mmid,k;

db f(db x){
	db s=0;
	for(int i=0;i<=n;i++)s=s*x+a[i];//秦九韶公式,自行百度 
	return s; 
}

int main(){
	scanf("%d%lf%lf",&n,&l,&r);
	for(int i=0;i<=n;i++){
		scanf("%lf",&a[i]);
	}
	while(r-l>=eps){
		k=(r-l)/3.0;
		mid=l+k;
		mmid=r-k;
		if(f(mid)>f(mmid))r=mmid;
		else l=mid;
	}
	printf("%.5lf\n",l);
	return 0;
}
```

无防作弊处理，要自觉呀

---

## 作者：撤云 (赞：1)

: 这道题看上去不能直接用二分法去做，发而要用三分法。但是 只要把这个函数取导之后找到这导数的驻点就ok了。

但是什么是导数呢？因为导数实在是太多了，这里就不一一列举了。这里只说明一下幂函数的导数，幂函数的导数为：f(x)=x^n

那么 f(x)的导数为nx^(n-1)

所以这道题就很好理解了，现在来看代码：


```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cmath>
using namespace std;
double a[50];
int n;
double ds(double l) {//求导数的值
    double  p=0;
    for(int i=n; i>=1; i--) {
        int y=i;
        double o=a[i];
        y-=1;
        while(y>0) {
            o*=l;
            y--;
        }
        p+=o;
    }
    return p;
}
void efda(double l,double r) {
    if(r-l<=1e-6) {
        printf("%0.5lf",l);
        exit(0);//结束
    }
    double mid=(l+r)/2,lp=ds(mid);
    if(lp<0)
            efda(l,mid);//这里用二次函数在草稿纸上枚举一次就可以知道怎么二分答案了
    else if(lp>0)
        efda(mid,r);
    else {//如果导数为零，直接输出
        cout<<mid;
        exit(0);//结束
    }
}
int main() {
    double l,r,pp;
    cin>>n>>l>>r;
    for(int i=n; i>=1; i--) {
        cin>>a[i];
        a[i]*=i;//为了方便求导数
    }
    cin>>pp;
    efda(l,r);
}
```

---

## 作者：feicx (赞：0)

## 二分导数大法好

**注意题面**

保证在范围$[l,r]$内存在一点x，使得$[l,x]$上单调增，$[x,r]$上单调减。

我们知道函数$f(a)$，在满足上述条件情况下的时候，其导函数应该满足
当$a \in [l,x]$时$f'(a) \geq 0$，而当$a \in [x,r]$时$f'(a)\leq 0$。

而且这道题目是个由$n$个常数乘以幂函数相加组成的函数，其导数是蛮好求的。

我们知道

$f(x)=ax^n$，则有$f'(x)=an\times x^{n-1}$，

$(f(x)+g(x))'=f'(x)+g'(x)$

其函数的导数可以根据这两条定理来求出。

由于答案$x \in [l,r]$，我们可以考虑二分答案。

以$f'(a)$做为$Cheak$函数，在二分时，若$f'(mid) \geq 0$时，二分右边，否则二分左边，这个自己可以画个图去推推。

然后当$|l-r| < 10^{-6}$时即可输出答案即可。

**要注意的是，用printf输出double本身就对答案四舍五入了，不需要在手动四舍五入。**我因为这个前面就打了70分，后面一直调试好久才发现是这个原因。如果手动四舍五入的话会使得其自动向上取了，要注意。

由于这个$n \leq 15$，不需要用秦久绍优化，直接求即可过。

然后放出我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
double l,r,a[15];

double get(double x){
	double ans=0;
	for(int i=0;i<n;i++)
		ans+=pow(x,i)*a[i];
	return ans;
}

int main(){
	cin>>n>>l>>r;
	for(int i=n;i>=1;i--){
		double tmp;
		cin>>tmp;
		a[i-1]=tmp*i;
	}
	while(abs(l-r)>=1e-6){
		double mid=(l+r)/2;
		if(get(mid)>0)
			l=mid;
		else
			r=mid;
	}
	printf("%.5lf",l);
	return 0;
}
```

---

## 作者：似水年华 (赞：0)

#算法分析

看到求函数的极值，我首先想到的是导数。毕竟导数是专门研究函数增减性和极值的。我们知道，函数的极值就是导数的零点。问题就转化为了给你一个函数，求这个函数的导函数在区间[l,r]上的零点。那么问题来了

##问题一：如何求函数的导数

根据高中数学选修2-2教材第14页，基本初等函数导数公式：若f(x)=c（c为常数），则f(x)的导数f'(x)=0，若f(x)=x^a，则f'(x)=a\*x^(x-1)，根据导数运算法则[f(x)\*g(x)]'=f'(x)g(x)+f(x)\*g'(x)可以得出[c\*f(x)]'=c\*f'(x)，又根据[f(x)+g(x)]'=f'(x)+g'(x)可以推出题中给的f(x)=a\*x^m+b\*x^n+······的导数为a\*n\*x^(n-1)+b\*m\*x^(m-1)+······

##问题二：如何求导数的零点

由于数据保证在区间[l,r]上先增后减，所以导数先正后负。我们就可以对区间[l,r]进行二分，若[l,r]中点mid的导数值大于零，则导数的零点在区间[l,mid]上，反之则在区间[mid,r]上。直到精度达到要求（r-l<=0.000001），此时的mid即为答案。

#参考程序

```cpp
#include<stdio.h>
#include<math.h>
#define MAXN 15
int n;
double l,r,a[MAXN];
double fd(double x)//算当横坐标等于x时导数的值
{
    double f=0;
    int i;
    for(i=n-1;i>=0;i--)
        f+=(a[i]*pow(x,i));
    return f;
}
int main()
{
    int i;
    double fx,mid;
    scanf("%d %lf %lf",&n,&l,&r);
    for(i=n;i>=0;i--)
        scanf("%lf",&a[i]);
    for(i=0;i<n;i++)
        a[i]=a[i+1]*(i+1);//算出导数
    while(r-l>0.000001)//当不满足精度时二分
    {
        mid=(l+r)/2;
        fx=fd(mid);
        if(fx>0)
            l=mid;
        else
            r=mid;
    }
    printf("%.5lf",mid);//保留5位小数输出结果
    return 0;
}
```

---


# 【模板】裴蜀定理

## 题目描述

给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。

求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 20$，$|A_i| \le 10^5$，且 $A$ 序列不全为 $0$。

## 样例 #1

### 输入

```
2
4059 -1782
```

### 输出

```
99```

# 题解

## 作者：RainAir (赞：54)

据说 NOIP 前发题解会 rp++？我数学这么差当然要让我的数学rp++了！

根据题目可知，这个题目要用裴蜀定理。

## 定理内容
对于任意整数 $a,b,d$，
$$ (a,b)|d \Leftrightarrow \exists \ u,v \ \text{such that}\ ua+vb = d $$

证明可以通过递归构造解来证明：

首先显然当 $u=1,v=0$ 的时候显然成立。

假设存在 $u',v'$,使得 $u'b+v'(a\ mod\ b)=d$.

注意到 $$a\ mod\ b = a-\lfloor\frac{a}{b}\rfloor b$$

可得 $$ u'b + v'(a-\lfloor\frac{a}{b}\rfloor b) = d$$

整理可以得到：
$$ u'b + v'a- v'\lfloor\frac{a}{b}\rfloor b = d$$

$$ v'a + (u'-\lfloor\frac{a}{b}\rfloor v')b = d $$

归纳证明该定理正确。

扩展到求 $ax+by=c$ 的最小非负 $c$,显然 $c$ 要满足 $(a,b)|c$,所以 $c$ 取 $(a,b)$ 是最小的。

扩展到这个题目，如果有多个数字的话，考虑前两个数字 $a_1,a_2$,有 $a_1x+a_2y=S \Rightarrow (a_1,a_2)|d$,$ k(a_1,a_2) =d$

所以把这两个的答案合并直接去取下一个就可以了。

注意到这个题目有负数输入，将其取绝对值就可以了。因为系数的最终答案没有影响。

## 代码
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>
#define Re register
#define LL long long
#define U unsigned
#define FOR(i,a,b) for(Re int i = a;i <= b;++i)
#define ROF(i,a,b) for(Re int i = a;i >= b;--i)
#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)
#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)
#define CLR(i,a) memset(i,a,sizeof(i))
#define BR printf("--------------------\n")
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl
namespace fastIO{
    #define BUF_SIZE 100000
    #define OUT_SIZE 100000
    #define ll long long
    bool IOerror=0;
    inline char nc(){
        static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
        if (p1==pend){
            p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin);
            if (pend==p1){IOerror=1;return -1;}
        }
        return *p1++;
    }
    inline bool blank(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';}
    inline void read(int &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    inline void read(ll &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    #undef ll
    #undef OUT_SIZE
    #undef BUF_SIZE
};
using namespace fastIO;

int N,gcd;
int main(){
    read(N);
    FOR(i,1,N){
        if(i==1) read(gcd);
        else{
            int x;read(x);x = std::abs(x);
            gcd = std::__gcd(gcd,x);
        }
    }
    printf("%d\n",gcd);
    // system("pause");
    return 0;
}
```

---

## 作者：RyanLi (赞：14)

传送门：[P4549 【模板】裴蜀定理](https://www.luogu.com.cn/problem/P4549)

更佳的阅读体验：[洛谷 P4549 题解](https://blog.ryanli.top/index.php/archives/280/)

---

## 算法介绍

给定一个长度为 $n$ 的整数序列 $A$ 和一个待定整数序列 $X$，求 $S = \sum \limits_{i = 1}^{n} A_i \times X_i$ 在正数范围内的最小值。

看上去似乎有点无从下手。

那先从简单的开始！我们来考虑 $n = 2$ 的情况，此时问题简化为求 $A_1 X_1 + A_2 X_2$ 的最小值。

如果我们设 $a, b$ 是不全为 $0$ 的整数，那么有**裴蜀定理**（Bézout's Lemma）：

- 对于任意整数 $x, y$，有 $\gcd (a, b) \mid (ax + by)$。
- 存在整数 $x, y$，使得 $ax + by = \gcd (a, b)$。

因此，$ax + by$ 的最小正整数值显然是 $\gcd (a, b)$。上述问题的答案就是 $\gcd(A_1, A_2)$。

那么，当 $n \ge 3$ 呢？我们尝试推广裴蜀定理。

假设有三个整数 $a, b, c$。我们首先对前两个数应用裴蜀定理，存在整数 $x_1, x_2$，使得 $ax_1 + bx_2 = \gcd (a, b)$。接下来，将这个结果与第三个数 $c$ 结合，即存在整数 $k, x_3$，使得 $\gcd (a, b) \times k + cx_3 = \gcd( \gcd(a, b), c)$。

我们知道，最大公约数有性质：$\gcd (a, b, c) = \gcd (\gcd(a, b), c)$，因此存在整数组合使得 $ax_1 + bx_2 + cx_3 = \gcd(a, b, c)$，且不存在更小的正数解。

这样推广下去，最终无论 $n$ 的大小，问题的最小正数解都是所有 $A_i$ 的最大公约数的绝对值。因此，我们只需要计算整个序列 $A$ 的最大公约数，并取其绝对值即可。

## 正确性证明

我们设 $a, b$ 是不全为 $0$ 的整数，那么一定有 $\gcd(a, b) \mid a$ 且 $\gcd(a, b) \mid b$。设 $x, y$ 为整数，则有 $\gcd(a, b) \mid ax$ 且 $\gcd(a, b) \mid bx$，因此 $\gcd(a, b) \mid (ax + by)$。

对于定理的第二点，若 $a$ 和 $b$ 任意一个等于 $0$，则 $\gcd(a, b)$ 的值为非零数的值，此时定理显然成立。

若 $ab \neq 0$，由于 $\gcd(a, b) = \gcd(a, -b)$，我们不妨设 $a, b$ 都大于 $0$，$a \ge b$，且有 $\gcd(a, b) = d$。

对 $ax + by = d$，两边同时除以 $d$，得到 $a_1x + b_1y = 1$，其中 $a_1, b_1$ 互质。接下来证明 $a_1x + b_1y = 1$。

我们先来回顾一下辗转相除法：$\gcd(a, b) \rightarrow \gcd(b, a \bmod b) \rightarrow \cdots$。我们把模出来的数记作 $r$，则有：
$$
\gcd(a_1, b_1) = \gcd(b_1, r_1) = \gcd(r_1, r_2) = \cdots = \gcd(r_{n - 1}, r_n) = 1
$$
把辗转相除法中的运算展开成带余除法，得到：
$$
\begin{align*}
a_1 & = q_1b_1 + r_1 & (0 \le r_1 < b_1) \\
b_1 & = q_2r_1 + r_2 & (0 \le r_2 < r_1) \\
r_1 & = q_3r_2 + r_3 & (0 \le r_3 < r_2) \\
& \cdots & \\
r_{n - 3} & = q_{n - 1}r_{n - 2} + r_{n - 1} & \\
r_{n - 2} & = q_nr_{n - 1} + r_n & \\
r_{n - 1} & = q_{n + 1}r_n
\end{align*}
$$
我们令辗转相除法在除到互质的时候退出，则 $r_n = 1$，所以有：
$$
r_{n - 2} = q_nr_{n - 1} + 1
$$
即：
$$
1 = r_{n - 2} - q_nr_{n - 1}
$$
用倒数第三个式子 $r_{n - 1} = r_{n - 3} - q_{n - 1}r_{n - 2}$ 代入上式，得：
$$
1 = (1 + q_nq_{n - 1}) r_{n - 2} - q_nr_{n - 3}
$$
然后用同样的办法逐个地消去 $r_{n - 2}, \cdots, r_1$，即可证得 $1 = a_1x + b_1y$。

## 代码实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, a, ans;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> a;
    ans = a;
    for (int i = 2; i <= n; ++i)
        cin >> a, ans = __gcd(ans, abs(a));
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：yangrunze (赞：9)

刚学会裴蜀定理，顺便来给大家讲一下：


首先来看看裴蜀定理是个什么东西哈：

> 对于一个二元一次方程$ax+by=c$，如果 **$c$是$\gcd(a,b)$的倍数**，那么**这个方程一定有整数解**

那这个东西到底咋证捏？别急，咱们要分两个阶段来完成证明！

### Section A

> 证明$ax+by=\gcd(a,b)$这个方程有整数解

首先，咱们要用的是一个很基础的东西——**辗转相除法**

对，没错，就是求最大公因数的那个

还记得辗转相除法的核心柿子吗？没错！就是$\gcd(a,b)=\gcd(b,a\bmod b)$

那咱们就用这个式子来证明它！

设$\gcd(a,b)=g$

则$ax+by=g$

我们设已经找到了一组解$x',y'$，使$bx'+(a \bmod b)y'=\gcd(a,b)$

$bx'+(a \bmod b)y'=g$

由于商\*除数+余数=被除数，$a\bmod b$可以这么表示：

$bx'+(a-\lfloor\frac{a}{b}\rfloor\times b)y'=g$

给它稍微变个形：

$bx'+ay'-a/b\times by'=g$

$ay'+b(x'-\lfloor\frac{a}{b}\rfloor\times y')=g$

和原式对比一下，你会惊奇地发现：

$\begin{cases}x=y'\\y=x'-\lfloor\frac{a}{b}\rfloor\times y'\end{cases}$

由于$b=0$时$\begin{cases}x=1\\y=0\end{cases}$，我们可以用刚才的式子一步一步向上把原来的解求出来

对于每一个$a$和$b$，我们都可以如法炮制，所以肯定都是有解哒！

P.S:刚才咱们用的方法，其实是辗转相除法的升级版——**扩展欧几里得算法**，也就是传说中的**exgcd**，又学会了一个新方法，开心不开心？（我才不会告诉你这一块是从扩欧的笔记那里cv过来的呢QωQ）

### Section B

> 证明每一个$c$都是$gcd(a,b)$的倍数

这就非常简单了，咱还是设 $\gcd(a,b)=g$

由于$g$是$a$和$b$的最大公因数，所以$g$肯定能被他俩整除

从刚才的得到的结论出发，我们设已知$ax'+by'=g$，$g\times q=c$

两边同时乘$q$，这样的话就可以发现$ax'\times q+by'\times q=g\times q$，即$ax'\times q+by'\times q=c$

$\begin{cases}x=x'\times q\\y=y'\times q\end{cases}$就是方程的一组解啦

**如果你认为这一切就是裴蜀定理的话 你就太小看它了**

裴蜀定理不光正着说没问题，反着说也成立！

> 对于一个二元一次方程$ax+by=c$，如果这个方程有整数解，那么c一定是$\gcd(a,b)$的倍数

那这个东西该咋证明呢？咱们还是可以考虑从最大公因数扩展

我们设$a=a'g,b=b'g,c=c'g+r$（$r<g$，我们还不知道$c$到底是不是$g$的倍数，那就先设上个$r$吧）

这样的话，原方程可以变为：$a'g x+b'g y=c'g+r$

两边同时除以$g$，得到$a'x+b'y=c'+\frac{r}{g}$

别忘了我们的已知条件：方程有整数解！所以$\frac{r}{g}$一定是个整数，$r$只能是$0$，所以$c$一定是$g$的倍数

那我们现在就可以大胆地说出来：

>对于一个二元一次不定方程$ax+by=c$，$c$是$\gcd(a,b)$的倍数，是这个方程有整数解的**充要条件**

**如果你认为这一切就是裴蜀定理的话 你就太小看它了**

裴蜀定理不仅如此，还可以扩展到更多元的不定方程！

>对于一个 **$n$元一次不定方程** $a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n=c$，$c$是$\gcd(a_1,a_2,a_3,\cdots,a_n)$的倍数，是这个方程有整数解的充要条件

类比一下多个数求最大公因数的过程，证明这个应该很简单

好不容易完成了证明，来看看题吧！

>给定一个包含 $n$ 个元素的整数序列 $A$，记作 $A_1,A_2,A_3,...,A_n$ 
求另一个包含 $n$ 个元素的待定整数序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

不难发现，这题的$S$，其实就是定理里面的$c$

也就是说，要找一个最小的$c$使方程有解

根据定理， **$S$必须是$\gcd(A_1,A_2,A_3,\cdots,A_n)$的倍数**，**一个数最小的倍数就是它自己**，也就是说，只要**求这些数的最大公因数**就成啦！（出现负数不要慌，不用管它，直接取相反数就行）

code:（就是求最大公因数，不用注释了吧qwq）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
int tql,wyx,akioi;
inline int nb(){//快读
	char c=getchar();
	int f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
inline int txdy(int a,int b){//求两个数的gcd
	if(b==0)
	return a;
	return txdy(b,a%b);
}
int main(){
	tql=nb();
	while(tql--){
		wyx=nb();
		if(wyx<0)wyx=-wyx;
		akioi=txdy(wyx,akioi);//很简单的操作啦！
	}
	printf("%d",akioi);
}
```
The end

---

## 作者：Maxsong (赞：6)

# P4549 【模板】裴蜀定理 题解

## 预备知识

**Bézout 定理：** 对于任意的 $a, b\ (a,b\in \Z)$，都有相对应的 $x, y\ (x,y\in \Z)$ 使得 $ax + by = \gcd(a, b)$。

### 证明：

考虑分类讨论。

在最后辗转相除到 $b = 0$ 时，可以使 $x = 1$ 和 $y = 0$，使得 $a\times 1 + 0\times 0 = \gcd(a, 0)$。

若 $b > 0$，先假设存在 $x, y\ (x,y\in \Z)$，满足 $bx + y(a\bmod b) = \gcd(b,a\bmod b)$。

因为 $bx + y(a\bmod b) = bx + y(a - b\lfloor a\div b\rfloor) = ay + b(x - y\lfloor a\div b\rfloor)$，所以我们令 $x' = y$ 和 $y' =x-y\lfloor a\div b\rfloor$，即可知 $ax' + by' = \gcd(a,b)$。

使用归纳法即可证明。

### 延伸定理

根据 $\gcd(a, b, c) = \gcd(a, \gcd(b, c))$ 和刚刚证明的过程，可得
$$
a_1 x_1 + a_2 x_2 + \cdots + a_n x_n = \gcd(a_1, a_2, \dots,a_n)
\\
(a, x\in \Z)
\\
\text{即}\sum\limits_{i=1}^na_i\times x_i = \gcd(a_1, a_2, \dots,a_n)
$$
一般说该定理为 Bézout 定理的扩展定理。

## 题目分析

题目记 $S=\sum\limits_{i=1}^nA_i\times X_i$，根据 Bézout 定理的扩展定理可知 $S = k\gcd(A_1, A_2, \cdots,A_i)\ (k\in \Z)$ （易知 $k$ 不影响等式成立）。明显地，$k = 1$ 时可以存在 $S > 0$ 且取到最小值。所以，我们需要求的是 $\gcd(A_1, A_2, \cdots,A_i)$。

其实本题中 $A_i$ 等价于 $-A_i$，因为可以更改系数 $X_i$ 的正负，故我们计算时取 $A_i$ 的绝对值。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
signed main(void){
    scanf("%d",&n);
    n--;
    scanf("%d",&ans);
    ans=abs(ans);
    while(n--){
        int x;
        scanf("%d",&x);
        ans=__gcd(ans,abs(x));
    }printf("%d\n",ans);
    return 0;
}
```

感谢大家的浏览，希望得到大家的认可与支持。

Update250604：修改几处笔误。

---

## 作者：LoongPig (赞：2)

# 裴蜀定理

裴蜀定理，又称贝祖定理（Bézout's lemma）。是一个关于最大公约数的定理。

## 定理内容



设 $a,b$ 是不全为 $0$ 的整数，对任意整数 $x,y$，满足 $\gcd(a,b)\mid ax+by$，且存在整数 $x,y$，使得 $ax+by=\gcd(a,b)$。

## 证明

对于第一点：

由于 $\gcd(a,b)\mid a,\gcd(a,b)\mid b$，

所以 $\gcd(a,b)\mid ax,gcd(a,b)\mid by$，其中 $x,y$ 均为整数。

因此 $\gcd(a,b)\mid ax+by$。

对于第二点：

若任何一个等于 $0$，此时 $\gcd(a,b)=a$。这是定理显然成立。

若 $a,b$ 均不等于 $0$：
    
由于 $\gcd(a,b)=\gcd(|a|,|b|)$，

不妨设 $a,b$ 都大于 $0$，$a\geq b$，$\gcd(a,b)=d$。  

对于 $ax+by=d$，两边同时除以 $d$，可得 $a_1x+b_1y=1$，其中 $\gcd(a_1,b_1)=1$。

转证 $a_1x+b_1y=1$。

我们先回顾一下辗转相除法是怎么做的，由 $\gcd(a,b)\rightarrow\gcd(a,a\bmod b)\rightarrow\cdots$ 我们把模出来的数据叫做 $r$，于是，有
$$\gcd(a_1,b_1)=\gcd(b_1,r_1)=\gcd(r_1,r_2)=\cdots=\gcd(r_{n-1},r_{n})=1$$
把辗转相除法中的运算展开，做成带余数的除法，得

$$
\begin{aligned}
  a_1&=q_1b_1+r_1 & (0\leq r_1<b_1)\\
  b_1&=q_2r_1+r_2 & (0\leq r_2<r_1)\\
  r_1&=q_3r_2+r_3 & (0\leq r_3<r_2)\\
  ...\\
  r_{n-3}&=q_{n-1}r_{n-2}+r_{n-1}\\
  r_{n-2}&=q_nr_{n-1}+r_n\\
  r_{n-1}&=q_{n+1}r_n
\end{aligned}$$

不妨令辗转相除法在除到互质的时候退出则 $r_n=1$，所以有（$q$ 被换成了 $x$，是为了符合最终形式）
$$
r_{n-2}=x_nr_{n-1}+1
$$
即
$$
1=r_{n-2}-x_nr_{n-1}
$$
由倒数第三个式子 $r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}$ 代入上式，得
$$
1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3}
$$
然后用同样的办法用它上面的等式逐个地消去 $r_{n-2},\cdots,r_1$，可证得 $a_1x+b_1y=1$。

## 推广

### 逆定理

设 $a,b$ 是不全为零的整数，若 $d>0$ 是 $a,b$ 的公因数，且存在整数 $x,y$，使得 $ax+by=d$，则 $d=\gcd(a,b)$。

特殊地，设 $a,b$ 是不全为零的整数，若存在整数 $x,y$，使得 $ax+by=1$，则 $a,b$ 互质。

### 多个整数

裴蜀定理可以推广到 $n$ 个整数的情形：设 $a_1,a_2,\dots,a_n$ 是不全为零的整数，则存在整数 $x_1,x_2,\dots,x_n$ 使得 $a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n=\gcd(a_1,a_2,\dots,a_n)$。其逆定理也成立：设 $a_1,a_2,\dots,a_n$ 是不全为零的整数，$d>0$ 是 $a_1,a_2,\dots,a_n$ 的公因数，若存在整数 $x_1,x_2,\dots,x_n$，使得 $a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n=d$，则 $d=\gcd(a_1,a_2,\dots,a_n)$。

# 题目思路

[迟到的传送门](https://www.luogu.com.cn/problem/P4549)

我们要求一个 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

$S=\sum\limits_{i=1}^nA_i\times X_i$，根据裴蜀定理的推广，很容易得出$S=k\times\gcd(a_1,a_2,\dots,a_n)$。

由于 $S$ 要求最小且不为 $0$，因为 $\gcd(a_1,a_2,\dots,a_n)$ 是一个定值，所以要让 $k$ 最小且不能为 $0$。

因为 $k$ 最小是 $1$，所以 $S=1\times\gcd(a_1,a_2,\dots,a_n)=\gcd(a_1,a_2,\dots,a_n)$。

如果 $A_i$ 是负数，由于 $\gcd(a,b)=\gcd(|a|,|b|)$，所以可以先取绝对值，再求最大公因数。

## 代码和[提交记录](https://www.luogu.com.cn/record/218229350)

根据这个思路，代码就很好写了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n,ans;
	scanf("%d%d",&n,&ans);
	ans=abs(ans);
	for(int i=1;i<n;i++){
		int x;
		scanf("%d",&x);
		ans=__gcd(ans,abs(x));
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：0Io_oI0 (赞：2)

# 内容
$ax+by=c$ 是一个关于 $x,y$ 的整系数二元一次方程有整数解的充要条件是 $\gcd(a,b)\ |\ c$。

# 证明
我们可以先只考虑 $ax+by=1$ 的解。

1. 若 $\gcd(a,b)=d>1$ 则左右模 $d$ 不同余。

   对于 $ax+by=c$ 若 $d$ 不为 $c$ 的因子则同样无解。
2. 若 $\gcd(a,b)=1$ 则我们考虑 $ax+by=1$ 左右同时模 $b$ 有 $ax\equiv 1(\mathrm{mod}\ b)$，因为 $\left\{1,2,\dots,b \right\}$ 为模 $b$ 的完系，且 $\gcd(a,b)=1$，所以 $\left\{a,2a,\dots,ab\right\}$ 也为模 $b$ 的完系。所以必存在 $x_0∈\left\{1,2,\dots,b\right\}$ 使得 $ax_0\equiv 1(\mathrm{mod}\ b)$。我们可以记 $ax_0=1+kb$ 代入 $ax+by=1$ 有 $y=-k$。所以 $ax+by=1$ 有整数解。到这里我们可以发现其实这也就相当于 $ax+by=c$ 有整数解，因为你把 $ax+by=1$ 的整数解乘上 $c$ 就好了。

这样充分性就证明完毕了！

接下来上代码：
```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
#define i_will signed
#define ak main
#define IMO ()
#define int long long
#define double long double
I AK IOI;
int n,ans,x;
i_will ak IMO{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	//freopen("","r",stdin);
	//freopen("","w",stdout);
	cin>>n>>ans; 
	ans=abs(ans);
	while(n--){
		cin>>x;
		ans=__gcd(ans,abs(x));
	}
    cout<<ans;
	i_ak ioi;
}
```
亲测可过，请勿抄袭！

---

## 作者：chentianmiao (赞：1)

## 前置知识：裴蜀定理
### 定理内容
设 $a,b \in \Z$，则存在 $x,y \in \Z$，使得
$$ ax + by = \gcd(a,b) $$

### 证明
考虑集合 $S = \{ ax + yb \mid x,y \in \Z \ \text{且} \ ax + yb > 0 \}$。

因为 $a,b$ 不全为零，所以 $S$ 非空。

由良序原理，$S$ 中存在最小元素 $d = ax_0 + by_0$。

接下来我们先证明 $d$ 是 $a$ 和 $b$ 的公约数。

用带余除法将 $a$ 除以 $d$ ，得 $a = qd + r$，其中 $0 \leq r < d$。

于是 $ r = a - qd = a - q(ax_0 + by_0) = a(1 - qx_0) + b(-qy_0) $。

若 $r > 0$，则 $r \in S$，但这与 $d$ 的最小性矛盾。故 $r=0$，即 $d \mid a$。

同理可证$d \mid b$。

于是我们再证明 $d$ 是最大公约数。

设 $c$ 是 $a$ 和 $b$ 的任意公约数，则 $c \mid (ax_0 + by_0) = d$，故 $d \geq c$。

综上，$d = \gcd(a,b)$，且存在 $x_0,y_0 \in \Z$ 使得 $ax_0 + by_0 = \gcd(a,b)$。
### 推广
不难发现它可以推广到 $n$ 个数的情况，即
$$a_1x_1 + a_2x_2+ \dots +a_nx_n = \gcd(a_1,a_2, \dots ,a_n)$$
## 思路分析
容易发现，若有一个方程$ax+by=n \ (n < \gcd(a,b))$，它一定是无解的。

那么通过推广，题目中的 $S$ 的最小值就是 $\gcd(A_1,A_2, \dots ,A_n)$。

于是题目解决。
## 代码
根据思路，代码应该很好写了。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,x,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		ans=__gcd(abs(x),ans);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ni_ju_ge (赞：1)

## 裴蜀定理
[模版](https://www.luogu.com.cn/problem/P4549)。

一定存在 $x,y$ 满足 $ax+by=\gcd(a,b)$。

该定理对不定方程是否有整数解做出了一个判定方式。
### 证明
设取整数 $x_0,y_0$ 时，$ax_0+by_0=m$，$\gcd(a,b)=k$，$m$ 为满足条件的最小正整数。

现在要证 $m=k$。

因为 $x_0,y_0$ 为整数，所以有 $k\mid ax_0,k\mid by_0$，则 $k\mid ax_0+by_0$，得 $k\mid m$（1）。

设 $a=qm+r(0\le r<m)$，则有

$$r=a-qm=a-q(ax_0+by_0)=a-aqx_0-bqy_0=a(1-qx_0)+b(-qy_0)$$

因为 $qx_0,qy_0$ 均为整数，所以可以使 $x=1-qx_0,y=-qy_0,r=ax+by$。

由于 $r<m$ 且 $m$ 是满足条件的最小正整数，所以 $r=0,a=qm$，因此 $m\mid a$，同理得 $m\mid b$，故 $m\mid k$（2）。

综合（1）（2）得：$m=k$ 得证。

简单思考一下可以发现，若 $ax'+by'=k\times\gcd(a,b)$，则 $x',y'$，变为原解的 $k$ 倍即可，故形如 $ax+by=c$ 的不定方程只要满足 $c=k\times\gcd(a,b)$ 就有整数解，$k$ 为整数。

同理可得，$n$ 个未知数的不定方程 $\sum_{i=1}^{n} a_ix_i=s$ 满足 $s=k\times\gcd(a_i)$ 时有整数解（$k$ 为整数）。

根据上面的结论求出 $\gcd(\left|A_i\right|)$ 即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int G(int x, int y) {//gcd 模版
	return y ? G(y, x%y) : x;
}
long long n;
int main() {
	cin>>n;
	long long ans,a;
    ans=0;
	for(int i=1; i<=n; i++) {
		cin>>a;
		if(a<0)a=-a;
		ans=G(ans,a);
	}
	cout<<ans;
}
```

---

## 作者：Vozeo (赞：1)

这道题写的是`Bézout`定理，不过可能要用到一个最大公约数理论的定理：
> 设$a_1,\cdots ,a_i$是不全为0的整数，有$$\gcd(a_1,\cdots,a_i) = \min(s = a_1x_1+\cdots+a_ix_i)$$其中$x_j \in \mathbb{Z}(1 \le j \le i), s > 0$，即$\gcd(a_1,\cdots ,a_i)$等于$a_1,\cdots ,a_i$的所有整系数线性组合组成的集合中的最小正整数。

给出一个~~可能不太完备的~~证明（引用的部分是对这句证明的解释）：

设$S$表示$a_1,\cdots ,a_i$的所有整系数线性组合组成的集合，则$S$中必有一个最小的正整数，设为$s_0$。

对$a_1,\cdots ,a_i$的任一个公约数$d$，都有$d \mid s_0$，所以$|d| \le s_0$。**即$s_0$不小于$a_1,\cdots ,a_i$的任一个公约数。**
> 因为$d$是$a_1,\cdots ,a_i$的公约数，所以必然能整除$a_1,\cdots ,a_i$的所有线性组合。

对任意$a_j$，设$a_j = q_js_0 + r_j$，其中$0 \le r_j < s_0$，则有$r_j \in S$。
> 因为$a_j \in S$，$s_0 \in S$，且有$r_j = a_j - q_js_0$，所以$a_j$和$s_0$的线性组合$r_j \in S$。

若$r_j>0$，则与$s_0$是$S$中最小的正整数矛盾，所以$r_j=0$，即$s_0 \mid a_j$。**也即$s_0$是$a_1,\cdots,a_i$的公约数。**

所以$s_0 = \gcd(a_1,\cdots,a_i)$。

$$\mathcal{Q.E.D}$$

这个定理在一些数论书上能够见到（比如《初等数论》）。

所以这道题只需要求一下所有数字的$\gcd$就好啦。代码就不放了。

---

## 作者：_ByTT_ (赞：0)

# 题解：P4549 【模板】裴蜀定理
### 定理的内容
在数论中，裴蜀定理是一个最大公约数定理，它说明了对任意整数 $a,b$ 和它们的最大公约数 $d$，关于未知数 $x,y$ 的线性丢番图方程（不定方程）。此方程被称为裴蜀等式。

裴蜀定理可以推广到任意的主理想环上。

#### 线性不定方程的内容

若 $a,b$ 是整数，且 $a,b$ 的最大公约数是 $d$，那么对于任意的整数 $x,y,ax+by$ 都一定是 $d$ 的倍数，特别的，一定存在整数 $x,y$ 使 $ax+by=d$ 成立。

### 证明
裴蜀定理是关于最大公约数的，所以我们的证明也和最大公约数有关，也就是辗转相除法。

我们知道，$d$ 是 $a,b$ 的最大公约数，因此 $d$ 是 $a,b$ 通过辗转相除法后的最大一个非零余数，我们假设 $s$ 次求得最后一个非零余数 $d$，我们可以写成如下公式。
$$a=bq_1+r_1$$
$$b=r_1q_2+r_2$$
$$r_1=r_2q_3+r_3$$
$$...$$
$$r_{s-2}=r_{s-1}q_{s-1}+d$$

因此，我们可以得到如下结论。

$$r_1=a-q_1b$$
$$r_2=b-r_1q_2=b-q_2(a-q_1b)=-q_2a+b(q_1q_2+1)$$
$$r_3=r_1-r_2q_3=(a-q_1b)-
q_3(-q_2a+b(q_1q_2+1))=a(q_2+1)-b(q_1+q_3(q_1q_2+1))$$
$$...$$

以此类推，最后 $d$ 一定可以表示 $a,b$ 的整数倍之和，即一定存在两个整数 $x,y$ 使得 $ax+by=d$。

### 代码实现

题意简介，即为求一个整数序列 $X$，然后有一个 $S$ 等于 $\sum_{i=1}^{n} A_i \times X_i$ 且其为正数，求 $S$ 的最小值。

根据裴蜀定理，可以得到 $S$ 的值可以是 $A$ 序列的最大公约数或其倍数，且有因为 $\gcd$ 是 $A$ 序列任意子序列的最小值，又要求 $S$ 最小，所以可以得到 $S$ 的最小值就是 $A_i$ 的绝对值最大公约数。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n,a,ans;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;ans=__gcd(ans,abs(a));
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：Chase12345 (赞：0)

# 定理介绍
这是裴蜀定理的结论，证明在下面的部分会说明。
> 对于任何不全为 $0$ 的正整数 $a_1,a_2,\dots,a_n$，存在整数 $x_1,x_2,\dots,x_n$，使得：
> $$
> \sum_{i=1}^{n} a_ix_i=\gcd_{i=1}^{n} \left(a_i\right)
> $$

在这道题中，我们需要找到一组 $x$，使得
$$
S=\sum_{i=1}^{n} a_ix_i>0
$$
且尽可能使得 $S$ 最小。

而裴蜀定理有个更加好的结论，那就是这个最小的 $S$ 值为：
$$
\gcd_{i=1}^{n} |a_i|
$$
# 证明
这里使用归纳法，或许有更加优秀的解法。

我们先证明两个数的情况。对于两个数 $a$ 和 $b$ 且不全为 $0$，设 $d=\gcd(a,b)$，则 $d$ 可以表示为 $a$ 和 $b$ 的线性组合，也即存在整数 $x,y$，使得 $d=ax+by$。这是因为例如欧几里得算法的每一步中，余数都可以表示为前两个余数的线性组合，这是显然地，最终结果也应同样如此。

对于 $n$ 个数，考虑归纳。
* $n=1$，显然成立。
* 被打回了两次，都是因为这里。。。其实这和 exgcd 的过程很类似。这里简单证明。定义集合 $S=\{ax+by \mid x,y \in \mathbb{Z} ∧ ax+by>0\}$，由于 $a,b$ **不全为** $0$，所以 $|S| \neq 0$。注意到良序定理，$S$ 存在最小元素 $d=ax_0+by_0$。注意到可以写出 $a=qd+r$，代入，$r=a-qd=a(1-qx^0)+b(-qy_0)$，$r>0$ 时，则 $r \in S$ 且 $r<d$，矛盾。所以 $r=0$，所以 $d \mid a$，同理 $d \mid b$。
* 假设前面 $n-1$ 个数成立，则 $\gcd_{i=1}^{n} |a_i|=\gcd(\gcd_{i=1}^{n-1} |a_i|,a_n)$，我们就可以表示出大 $S$ 作为 $A$ 的线性组合。

还没完，我们仍然需要证明 $S$ 最小。

注意到 $\gcd$ 为所有公约数最大的，而所有正的线性组合必然都是 $\gcd$ 的倍数，则最小的正 $S$ 值就是：
$$
\gcd_{i=1}^{n}|a_i|
$$
完结撒花。

# 代码
代码是十分简单的。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
long long a[N], res;

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    res = abs(a[1]);
    for (int i = 1; i <= n; i++)
        res = __gcd(res, abs(a[i]));
    cout << res << '\n';
    return 0;
}
```

---

## 作者：A6TVhmj (赞：0)

## 1.  裴蜀定理是什么
 做一道数学模板题，最重要的是先了解数学算法本身，了解彻底了在看回题目。所以我们先看一下裴蜀定理是什么（以下摘自 oi-wiki）。

 裴蜀定理，又称贝祖定理（Bézout's lemma）。是一个关于最大公约数的定理。

其内容是：

设 $a,b$ 是不全为零的整数，对任意整数 $x,y$，满足 $\gcd(a,b)\mid ax+by$，且存在整数 $x,y$, 使得 $ax+by=\gcd(a,b)$。其中 $\gcd$ 就是求两个数的最大公因数的意思。

看来这个定理跟最大公因数有分不开的关系，那我们得先了解一下最大公因数（有基础者可跳过）。

## 2.  前置知识：最大公因数

最大公约数即为 Greatest Common Divisor，常缩写为 gcd。

一组整数的公约数，是指同时是这组数中每一个数的约数的数。$\pm 1$ 是任意一组整数的公约数。

一组整数的最大公约数，是指所有公约数里面最大的一个。

最大公因数有很多性质，以下是几个在此题中比较有用的：
1. $\gcd(a_1,\dots,a_n)=(|a_1|,\dots,|a_n|)$；
2. $\gcd(a,b)=\gcd(b,a)$；
3. $\gcd(a_1,\dots,a_n)=\gcd(\gcd(a_1,a_2),a_3,\dots,a_n)$。

那我们如何求出已知两数的最大公约数呢？

不妨设 $a > b$。我们发现如果 $b$ 是 $a$ 的约数，那么 $b$ 就是二者的最大公约数。接下来讨论不能整除的情况，即 $a = b \times q + r$，其中 $r < b$。

根据这些我们通过证明可以得到 $\gcd(a,b)=\gcd(b,a \bmod b)$，（$\bmod$ 是取模），也就得到了关于两个数的最大公约数的一个递归求法，叫**辗转相除法**。（代码见文末）

## 3.  裴蜀定理证明

若任何一个等于 $0$， 则 $\gcd(a,b)=a$。这时定理显然成立。

若 $a,b$ 不等于 $0$。由于 $\gcd(a,b)=\gcd(a,-b)$，不妨设 $a,b$ 都大于 $0$，$a\geq b,\gcd(a,b)=d$。

对 $ax+by=d$, 两边同时除以 $d$， 可得 $a_1x+b_1y=1$, 其中 $(a_1,b_1)=1$。

转证 $a_1x+b_1y=1$。

我们先回顾一下辗转相除法是怎么做的，由 $\gcd(a, b) \rightarrow \gcd(b,a\mod b) \rightarrow \dots$ 我们把模出来的数据叫做 $r$ 于是，有 $\gcd(a_1,b_1)=\gcd(b_1,r_1)=\gcd(r_1,r_2)=\cdots=(r_{n-1},r_n)=1$

把辗转相除法中的运算展开，做成带余数的除法，得

$$\begin{aligned}a_1 &= q_1b_1+r_1 &(0\leq r_1<b_1) \\ b_1 &= q_2r_1+r_2 &(0\leq r_2<r_1) \\ r_1 &= q_3r_2+r_3 &(0\leq r_3<r_2) \\ &\cdots \\ r_{n-3} &= q_{n-1}r_{n-2}+r_{n-1} \\ r_{n-2} &= q_nr_{n-1}+r_n \\ r_{n-1} &= q_{n+1}r_n\end{aligned}$$

不妨令辗转相除法在除到互质的时候退出则 $r_n=1$ 所以有（$q$ 被换成了 $x$，为了符合最终形式）

$$r_{n-2}=x_nr_{n-1}+1$$
即
$$1=r_{n-2}-x_nr_{n-1}$$

由倒数第三个式子 $r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}$ 代入上式，得 $1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3}$

然后用同样的办法用它上面的等式逐个地消去 $r_{n-2},\cdots,r_1$，

可证得 $1=a_1x+b_1y$。这样等于是一般式中 $d=1$ 的情况，两边同时乘以 $d$ 就可以得到原定理。

## 4.  裴蜀定理怎么用在题目中

知道这些前置知识，裴蜀定理也就很好证明了。看回题目:

>给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

我们先考虑两个数的情况：根据定理，存在整数 $x,y$, 使得 $A_1x+A_2y=\gcd(A_1,A_2)$，比这小的正整数可以证明无解。

那如果有三个数呢？设 $\gcd(A_1,A_2)=d$，同样的，根据定理，存在整数 $x,y$， 使得 $dx+A_3y=\gcd(d,A_3)=\gcd(\gcd(a_1,a_2),a_3)$。

在之后，$4$ 个数、$5$ 个数……我们不难发现，现在题目转化成了就求这些数的最大公约数这个问题。但不同的是，记得转成正数，并且忽略所有的 $0$（$0$ 乘以任何数都得 $0$，不影响结果）。

## 5.  完整参考代码
最后就到写程序了，代码也不算长。

码风偏差，请多多见谅。


```cpp
#include<iostream>
using namespace std;
int gcd(int a,int b){return b?gcd(b,a%b):a;}//递归求最大公因数
int main(){
    int n,tmp,gc=0;
    cin>>n;
    while(cin>>tmp){
        if(!gc){
            gc=tmp;//初始最大公因数设为第一个数本身
            continue;
        }
        if(tmp)gc=gcd(gc,tmp);//不为0的情况下求最大公约数
    }
    cout<<(gc>0?gc:-gc);//记得吧答案转换为正数
    return 0;
}
```
注：部分内容参考 oi-wiki，其余为原创。

---


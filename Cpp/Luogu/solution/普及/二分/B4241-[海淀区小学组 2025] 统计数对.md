# [海淀区小学组 2025] 统计数对

## 题目背景

2025 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

为更好区分不同时间复杂度的做法，本题时间限制下调到 500 毫秒。

## 题目描述

陶陶是一个计算机爱好者，对二进制数有着特别的喜好，遇到各种各样的数据，他总能找到跟 $2$ 的整数次幂的关系。现在，他获得了一个长度为 $n$ 的数列 $a_1, a_2, \dots, a_n$，他发现其中有些元素的和恰好是 $2$ 的整数次幂。对于给定的 $a_1, a_2, \dots, a_n$，你的任务是统计有多少个数对 $(i, j)$ 满足 $a_i + a_j = 2^x$，其中 $x \in \N^*$，$i < j$，这里 $\N^*$ 表示正整数集合。


## 说明/提示

- 对于 $40\%$ 的数据，$1 \leq n \leq 10^3$，对于每一个正整数 $i$，$1 \leq i \leq n$，都有 $1 \leq a_i \leq 10^9$。
- 对于另外 $60\%$ 的数据，$1 \leq n \leq 10^5$，对于每一个正整数 $i$，$1 \leq i \leq n$，都有 $1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
4
7 3 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
3```

# 题解

## 作者：chen_zhe (赞：4)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题考察 map 的使用。

题目询问有多少个数对满足 $a_i+a_j=2^x$，直接枚举 $(i,j)$，判断其是否是 $2$ 的幂次，则时间复杂度是 $O(n^2)$ 或者 $O(n^2 \log V)$ 的（$V$ 表示 $a_i$ 的值域，是否有 $\log V$ 取决于是否使用位运算 `x & (x - 1)` 判断正整数 $x$ 是否是 $2$ 的幂次），只能通过 $40\%$ 的数据。

不妨移项，有 $a_j=2^x-a_i$。接着我们枚举 $i$ 和 $x$，即可计算出 $2^x-a_i$。接着我们判断 $a_j$ 是否有出现过即可。这一步就需要使用 `map`。具体而言，使用 `map <int, int> m` 存储 $a_i$ 这个值出现的次数。这样，我们只需统计 $2^x-a_i$ 出现了多少次，将这个次数累加进答案中即可。

接下来演示一个经典的错误写法：

```cpp
for (int i = 1; i <= n; i++) {
    m[a[i]]--;
    for (int j = 0; j <= 30; j++)
        ans += m[(1 << j) - a[i]];
}
```

在这份代码中确实是在枚举 $i$ 和 $x$，得知 $2^x-a_i$ 的出现次数并且加到答案，同时也通过 `m[a[i]]--` 的方式避免重复统计，但是这一份代码提交只能获得部分分数。这是因为若是直接访问 `map` 下标，此时如果 $2^x-a_i$ 不存在值，则会新建一个下标 $2^x-a_i$，值为 $0$。这样一来，这个 `map` 容器中就会存在 $O(n\log V)$ 个元素（$\log V$ 在本题中为 $31$），单次访问时间复杂度为 $O(\log (n \log V))$，总复杂度为 $O(n \log V \log (n \log V))$，无法通过本题。

一个更好的做法是，首先使用 `m.count()` 函数，判断这个下标是否在 `map` 中出现过。若没出现过就不管，出现过了再计算。这样可以避免反复地新建下标。由于 `count` 函数单次是 $O(\log n)$ 的，因此时间复杂度为 $O(n \log V \log n)$，可以通过本题。

参考代码：

```cpp
for (int i = 1; i <= n; i++) {
    m[a[i]]--;
    for (int j = 0; j <= 30; j++) {
        if (m.count((1 << j) - a[i]))
            ans += m[(1 << j) - a[i]];
    }
}
```

---


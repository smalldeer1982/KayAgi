# [海淀区小学组 2025] 蜂窝网络

## 题目背景

2025 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

有 $n$ 个城市编号从 $1$ 到 $n$ 和 $m$ 个信号发射塔编号从 $1$ 到 $m$ 都分布在一条直线上，如果选择直线上某个点的坐标为 $0$，则这 $n$ 个城市的坐标可以描述为 $a_1, a_2, \dots, a_n$，这 $m$ 个信号发射塔的坐标可描述为 $b_1, b_2, \dots, b_m$。每个信号发射塔能为它左右不超过 $r$ 的距离以内的城市提供上网流量，你的任务是确定 $r$ 最小为多少时才能保证所有城市都有网络信号？

## 说明/提示

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 500$，对于整数 $i, j$，$\forall i \in [1, n]$，$1 \leq a_i \leq 500$，$\forall j \in [1, m]$，$1 \leq b_j \leq 500$。
- 对于另外 $70\%$ 的数据，$1 \leq n, m \leq 10^5$，对于整数 $i, j$，$\forall i \in [1, n]$，$\forall j \in [1, m]$，$-10^9 \leq a_i, b_j \leq 10^9$。

## 样例 #1

### 输入

```
3 2
-2 2 4
-3 0```

### 输出

```
4```

## 样例 #2

### 输入

```
5 3
1 5 10 14 17
4 11 15```

### 输出

```
3```

# 题解

## 作者：AcceptedC (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B4242)  
## 解析
显然考察二分查找，找到离它最近的一个能覆盖的信号塔就可以了，最简便的方法是使用 `lower_bound`，当然也可以手搓。  
本题就是找到离城市最近的信号塔，根据索引 $\alpha$ 数目可分为三种情况:  
* $\alpha=0$ 时，找与第一个塔的距离。
* $\alpha=m$ 时，此时需要找与最后一个塔的距离。
* 对于其他情况，找最近的信号塔。
  * 记得开 `long long`。

最后就是求最小覆盖半径，把每个城市与离它最近的信号塔的距离求出来，最后取最大的那个值就是覆盖所有城市的最小半径。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long //不开long long见祖宗
using namespace std;
int n,m;
const int maxN=1e5+10;
ll a[maxN],b[maxN];
ll ans;
ll BS(ll g){
	if(g<=b[1]) return b[1]-g;
	if(g>=b[m]) return g-b[m];
	int iL=1,iR=m;
	while(iL<iR){
		int mid=iL+(iR-iL+1)/2;
		if(b[mid]<=g) iL=mid;
		else iR=mid-1;
	}
	return min(g-b[iL],b[iL+1]-g);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	sort(b+1,b+m+1);
	for(int i=1;i<=n;i++){
		ans=max(ans,BS(a[i]));//最后取最大的值作为最小半径
	}
	cout<<ans;
}
```
[死亡回放（提交记录）](https://www.luogu.com.cn/record/209965827)

---

## 作者：chen_zhe (赞：3)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题考察二分查找。

为了方便处理，不妨先将题目中的 $a_i,b_i$ 从小到大进行排序。接着考虑如何计算 $r$。

可能有部分同学会考虑二分距离 $r$，尝试转换为判定当前距离下信号塔能否将信号覆盖每一个城市，但是这样做的话，判定函数还需再套一个二分查找，以快速查询能否覆盖到每一个城市。能够通过本题，但是时间复杂度不够优秀。

不妨换个思路，考虑对于每个城市（坐标为 $a_i$）查找最近的信号塔。我们首先二分查找，使用 `lower_bound` 函数找到第一个坐标不小于 $a_i$ 的信号塔 $b_j$，那么距离这个城市最近的信号塔不是 $b_{j-1}$ 就是 $b_j$，在两者中找到最近的信号塔即可。最后的答案是在所有的最近距离中取最大值。

参考代码：

```cpp
int idx = lower_bound(b + 1, b + m + 1, a[i]) - b;
// 找到第一个坐标不小于 a[i] 的信号塔
if (idx >= 1 && idx <= m) { // 防止下标越界
    d = min(d, abs(b[idx] - a[i]));
}
if (idx - 1 >= 1) { // 防止下标越界
    d = min(d, abs(b[idx - 1] - a[i]));
}
ans = max(ans, d);
```

---

## 作者：zhouzihan20110620 (赞：1)

# 题目解析+做法优化+详细代码

### 题目解析

题目描述很清晰，就是要找最小的 $r$ 使得对于任意的 $a_i(1 \le i \le n)$，满足 $\exists \lvert b_j-a_i \rvert \le r(1 \le j \le m)$。

### 做法优化

考虑最朴素的做法：从小到大枚举 $r$，判断每一个 $a_i$ 是否满足上述条件。这样的时间复杂度最坏可以达到 $O(nm)$（系数常数为 $2 \times 10^9$），显然不可行。

我们要考虑两层优化：

第一层即为对于 $r$ 的枚举，对于求 $r$ 的最小值，可以显然想到二分，这样就可以将 $r$ 的枚举量简化为 $\log_2 2\times 10^9$，就没有那么大的常数了，然而到这里时间复杂度仍在 $O(nm)$。

第二层优化是判断是否满足条件，可以不用遍历每一个 $a_i$ 和 $b_j$，同理我们可以二分找离 $a_i$ 最近的点 $b_j$，这样就能单次 $\log_2 m$ 求距 $a_i$ 最近的 $b_i$，因为显然对 $a_i$ 而言只有离其最近的 $b_i$ 点可能会对答案产生影响。

这两层优化考虑完成，就可以得到 $O(n \log m)$ 的正确代码，但是当我们考虑完第二层优化后，能很自然的想到可不可以利用这种找最近 $b_i$ 点的方法来直接对答案产生贡献。具体的，我们考虑对于 $a_i$，想要其满足条件，就要让 $r \ge \lvert b_j-a_i\rvert$，其中 $b_j$ 是二分求得的离 $a_i$ 最近的点，那么就让 $r$ 不断对上述式子取最大值即可，时间复杂度为 $O(n \log m)$。

可以证明最优复杂度即为 $O(n \log m)$，此外还有同级复杂度的最优复杂度 $O(n \log n + m \log m)$，所以本质上应该没有线性做法，瓶颈在排序。

### 详细代码

```cpp
//O(2*10^9nm)30pts
#include <iostream>
#include <algorithm>
using namespace std;
long long n, m, a[100005], b[100005], r;
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	for (int i = 1;i <= m;i++)
	{
		cin >> b[i];
	}
	while (1)
	{
		bool flag = 1;
		for (int i = 1;i <= n;i++)
		{
			bool nflag = 0;
			for (int j = 1;j <= m;j++)
			{
				if (abs(b[j] - a[i]) <= r)
				{
					nflag = 1;
					break;
				}
			}
			if (!nflag)
			{
				flag = 0;
				break;
			}
		}
		if (flag)
		{
			break;
		}
        r++;
	}
	cout << r;
	return 0;
}
```

```cpp
//O(30nm)70pts
#include <iostream>
#include <algorithm>
using namespace std;
long long n, m, a[100005], b[100005], l, r, mid, ans;
bool check(long long x)
{
	bool flag = 1;
	for (int i = 1;i <= n;i++)
	{
		bool nflag = 0;
		for (int j = 1;j <= m;j++)
		{
			if (abs(b[j] - a[i]) <= x)
			{
				nflag = 1;
				break;
			}
		}
		if (!nflag)
		{
			flag = 0;
			break;
		}
	}
	return flag; 
}
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	for (int i = 1;i <= m;i++)
	{
		cin >> b[i];
	}
	l = 0;
	r = 2e9 + 1;
	while (l <= r)
	{
		mid = (l + r) >> 1;
		if (check(mid))
		{
			ans = mid;
			r = mid - 1;
		}
		else
		{
			l = mid + 1;
		}
	}
	cout << ans;
	return 0;
}
```

```cpp
//O(30nlogm)100pts
#include <iostream>
#include <algorithm>
using namespace std;
long long n, m, a[100005], b[100005], l, r, mid, ans;
bool check(long long x)
{
	bool flag = 1;
	for (int i = 1;i <= n;i++)
	{
		long long p = lower_bound(b + 1, b + m + 1, a[i]) - b;
		if (a[i] - b[p - 1] > x && b[p] - a[i] > x)
		{
			flag = 0;
			break;
		}
	}
	return flag; 
}
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	b[0] = -9e18;
	for (int i = 1;i <= m;i++)
	{
		cin >> b[i];
	}
	sort(b + 1, b + m + 1);
	b[m + 1] = 9e18;
	l = 0;
	r = 2e9 + 1;
	while (l <= r)
	{
		mid = (l + r) >> 1;
		if (check(mid))
		{
			ans = mid;
			r = mid - 1;
		}
		else
		{
			l = mid + 1;
		}
	}
	cout << ans;
	return 0;
}
```

```cpp
//O(nlogm)100pts
#include <iostream>
#include <algorithm>
using namespace std;
long long n, m, a[100005], b[100005], ans;
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
    b[0] = -9e18;
	for (int i = 1;i <= m;i++)
	{
		cin >> b[i];
	}
	sort(b + 1, b + m + 1);
    b[m + 1] = 9e18;
	for (int i = 1;i <= n;i++)
	{
		long long p = lower_bound(b + 1, b + m + 1, a[i]) - b;
		ans = max(ans, min(a[i] - b[p - 1], b[p] - a[i]));
	}
	cout << ans;
	return 0;
}
```

```cpp
//O(nlogn+mlogm+n+m)100pts
#include <iostream>
#include <algorithm>
using namespace std;
long long n, m, a[100005], b[100005], nowi, ans;
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
    b[0] = -9e18;
	for (int i = 1;i <= m;i++)
	{
		cin >> b[i];
	}
	sort(b + 1, b + m + 1);
    b[m + 1] = 9e18;
	for (int i = 1;i <= n;i++)
	{
		while (b[nowi] < a[i])
		{
			nowi++;
		}
		ans = max(ans, min(a[i] - b[nowi - 1], b[nowi] - a[i]));
	}
	cout << ans;
	return 0;
}
```

---

至此，本题讲解完毕。

~~蒟蒻的第一篇题解，求过QAQ。~~

---

## 作者：F_Maple_leaves (赞：1)

本蒟蒻的第一篇题解。
## 解题思路
这题明显利用分治思想，

可以用二分答案来减小时间复杂度。

对于一个城市，判断它是否在一个信号塔的 $ r $ 半径范围内，

对其进行标记，最后统计。

##  AC 代码

这里是绿名同学都能看懂的代码。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct point
{
	int xy;
	bool tf;
};
long long n,m;
point a[100005];
long long b[100005];
bool cmp(point x,point y)
{
	return x.xy<y.xy;
}
bool check(int r)
{
	int pos=1;
	for(int i=1;i<=m;i++)
	{
		for(int j=pos;j<=n;j++)
		{
			if(a[j].xy>=b[i]-r && a[j].xy<=b[i]+r)
			{
				a[j].tf=1;
			}
			else
			{
				pos=j;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!a[i].tf)
		{
			return 0;
			break;
		}
	}
	return 1;
}

int main()
{

	cin>>n>>m;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].xy;
	}
	for(int i=1;i<=m;i++)
	{
		cin>>b[i];
    }
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+m+1);
	int mid,l=0,r=1000000000;
	while(l<=r)
	{
		mid=(r+l)/2;
		for(int i=1;i<=n;i++)
		{
			a[i].tf=0;
		}
		if(check(mid))
		{
			r=mid-1;
			ans=mid;
		}
		else
		{
			l=mid+1;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

# B4242 [海淀区小学组 2025] 蜂窝网络 题解  
比较简单的一道二分题。  
### 解题思路  
显然是一个贪心和二分。  
对于一座城市，只需要离它最近的一个信号塔能覆盖就行了，二分找到最近的，也可以用 `lower_bound` 直接查找。  
记得开 `long long`。  
### AC 代码  

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
int n,m;
ll a[100005],b[100005];
ll ans;
ll ef(ll p){
	if(p<=b[1]) return b[1]-p;
	if(p>=b[m]) return p-b[m];
	int l=1,r=m;
	while(l<r){
		int mid=l+(r-l+1>>1);
		if(b[mid]<=p) l=mid;
		else r=mid-1;
	}
	return min(p-b[l],b[l+1]-p);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	sort(b+1,b+m+1);
	for(int i=1;i<=n;i++){
		ans=max(ans,ef(a[i]));
	}
	cout<<ans;
}
```

---

## 作者：dailichen (赞：1)

# 题解 B4242
## 题目解析
本题需要求出信号塔的最小覆盖范围，考虑计算出城市中最大的所需覆盖范围。
## 解题思路
- 先对城市和信号塔进行从小到大排序，然后按照顺序遍历每一个城市。
- 二分法查找左右两边最接近的信号塔，比较左右两边与城市间距离，记录较短的距离。
- 将记录的值与答案变量对比，选择大的值保留。
- 最后保留的值即为所求的答案。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+1;
int n,m,a[maxn],b[maxn],r=-1;
int found(int x){
	int left=1,right=m,f=0;
	//二分法查找 
	while (1){
		if ((left+1)==right) break;
		int mid=(left+right)/2;
		if (b[mid]==x){
			f=mid;
			//如果找到就结束 
			break;
		}else if (b[mid]<x){
			left=mid;
		}else{
			right=mid;
		}
	}
	if (f!=0){
		return f;
	}else{
		if (abs(b[right]-x)<abs(b[left]-x)){
			return right;
		}else{
			return left;
		}
	}
}
int main(){
    cin >> n >> m;
	for(int i=1;i<=n;i++) cin >> a[i];
    for(int j=1;j<=m;j++) cin >> b[j];
    //排序 
    sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	//遍历每个城市 
    for (int i=1;i<=n;i++){
    	int tmp;
    	tmp=found(a[i]);
    	//记录最大范围 
		r=max(r,abs(a[i]-b[tmp]));
	}
	cout << r;
}
```

---

## 作者：Lfz312g (赞：0)

# Solution
这个问题显然有单调性，考虑对 $r$ 二分答案。  
判定时，每次二分寻找对于 $a_i$ 来说最近的 $b_j$，如果 $b_j$ 都无法覆盖 $a_i$，别的肯定也不行，遍历一遍 $a$ 数组，检查是否 $\left| a_i-b_j \right| \le r$ 即可。  
时间复杂度 $O(n \log m \log n)$，可以通过本题。  
需要开 `long long`。  
## Code

```cpp
#include <bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
const int Maxn=1e5+27;
ll a[Maxn],b[Maxn];
int n,m;
int solve(ll x) { //寻找最接近的数
	if (x<=b[0]) return b[0];
	if (x>b[m-1]) return b[m-1];
	int l=0,r=m;
	while (l<r){
		int mid=l+r>>1;
		if (x==b[mid]) return b[mid];
		if (x<b[mid]) r=mid;
		else l=mid+1;        
	}
	return x-b[l-1]<=b[l]-x?b[l-1]:b[l];
}
bool check(ll r) {
	ffor(i,1,n) {
		ll x=solve(a[i]);
		if (abs(x-a[i])>r) return false;
	}
	return true;
}
int main()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	cin>>n>>m;
	ffor(i,1,n) cin>>a[i];
	ffor(i,0,m-1) cin>>b[i];
	sort(b,b+m);
	ll l=0,r=1LL<<32,mid,ans;
	while (l<=r) {
		if (check(mid=l+r>>1)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Manchester_City_FC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4242)

题目大意就不讲了，原题很清楚。

我们考虑将城市的位置和信号塔的位置分别排序。排序的目的是便于后续利用二分查找快速定位对于每个城市来说，与之最近的信号塔。

接下来就是二分查找确定最近信号塔，即对于每个城市，利用二分查找在信号塔数组中寻找第一个位置不小于该城市坐标的塔。

+ 如果该索引为 $0$，那么该城市只能通过第一个塔产生信号，计算距离。
+ 如果该索引等于信号塔数量，说明城市在所有塔的右侧，此时只能选择最后一个塔。
+ 其他情况，则比较该位置和前一位置的塔，选择距离较小的作为最近的信号塔。

最后求解最小覆盖半径即可。对于每个城市计算出与最近信号塔的距离，然后从所有城市的距离中取最大值，此值即为使所有城市覆盖的最小信号半径。

此方法的总体时间复杂度为 $\mathcal O(n \log n)$ 的，足以通过本题。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,m,a[N],b[N],ans;
int main(){
    cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
    for(int j=1;j<=m;j++) cin>>b[j];
    sort(a+1,a+n+1),sort(b+1,b+m+1);
    for(int i=1;i<=n;i++){
        int pos=lower_bound(b+1,b+m+1,a[i])-b,dis=0;
        if(pos==1) dis=abs(a[i]-b[1]);
        else if(pos==m+1) dis=abs(a[i]-b[m]);
        else dis=min(abs(a[i]-b[pos]),abs(a[i]-b[pos-1]));
        ans=max(ans,dis);
    }
	cout<<ans;
}
```

---

## 作者：ggylz49 (赞：0)

## 思路分析
直接暴力枚举 $r$ 显然很不现实，在极端数据情况下，这个算法一定会超时，于是考虑优化。

很明显，可以使用二分答案来优化确定最小 $r$ 的过程。

在二分答案中，两端的最值 $L,R$ 应该是多少呢？很明显，最好情况下，所有的信号发射塔都与城市坐标重合，所以 $L=0$；最坏情况下，城市在数轴最左端，信号发射塔在最右端，所以 $R=10^9-(-10^9)=2\times10^9$。

以下是一个代码，模拟二分答案的主过程。其中 `f(long long x)` 函数用于判断当 $r=x$ 时是否能保证所有城市都有网络信号。当能保证所有城市都有网络信号时，程序返回值为 $1$；否则，程序返回值为 $0$。

```cpp
int main()
{
    //输入数据
    cin>>n>>m;
    for (int i=0;i<n;i++)cin>>a[i];
    for (int i=0;i<m;i++)cin>>b[i];
    //因为题目没有保证a,b数列有序，所以需要从小到大排序以方便处理
    sort(a,a+n);
    sort(b,b+m);
    long long L=0,R=2000000000;
    while(L<R)
    {
        long long mid=(L+R)/2;//中点
        if (f(mid))R=mid;//成立，说明r可以是mid，并且有希望更小
        else L=mid+1;//不成立，说明r不能是mid，并且要更大
    }
    cout<<L;//此时L=R，输出哪个都可以
    return 0;
}
```

接下来就是二分答案的判断程序 `f(long long x)` 的过程了。可以用一个数组 $v$ 来存储城市的网络覆盖情况。当 $v_i=1$ 时，说明编号为 $i+1$ 的城市有网络信号；反之，当 $v_i=0$ 时，说明编号为 $i+1$ 的城市没有网络信号。（之所以是 $i+1$，因为我的数组下标从 $0$ 开始）并且，用一个变量 $pos$ 存储当前不能能被网络信号覆盖的坐标最小的城市的编号。

空谈无益，直接上代码，根据注释更好理解：

```cpp
bool f(long long x)
{
    bool v[100010]={0};//初始化为0
    int pos=0;//当前不能能被网络信号覆盖的坐标最小的城市的编号
    for (int i=0;i<m;i++)//从坐标最小的信号发射塔开始，依次将可以被该发射塔的信号覆盖的城市标记
    {
        for (int j=pos;j<n;j++)//从无法被覆盖的最小的城市开始，依次判断
        {
            if (b[i]-x<=a[j]&&b[i]+x>=a[j])v[j]=1;//如果在该信号塔可覆盖的范围内，标记该城市
            else {pos=j;break;}//否则将pos设置为j，即当前不能能被网络信号覆盖的坐标最小的城市的编号，退出循环
        }
    }
    for (int i=0;i<n;i++)if (!v[i])return 0;//挨个判断，如果有城市无法被覆盖，return 0
    return 1;//否则说明r=x可行，return 1
}
```
## Code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long n,m,a[100010],b[100010];
bool f(long long x)
{
    bool v[100010]={0};
    int pos=0;
    for (int i=0;i<m;i++)
    {
        for (int j=pos;j<n;j++)
        {
            if (b[i]-x<=a[j]&&b[i]+x>=a[j])v[j]=1;
            else {pos=j;break;}
        }
    }
    for (int i=0;i<n;i++)if (!v[i])return 0;
    return 1;
}
int main()
{
    cin>>n>>m;
    for (int i=0;i<n;i++)cin>>a[i];
    for (int i=0;i<m;i++)cin>>b[i];
    sort(a,a+n);
    sort(b,b+m);
    long long L=0,R=2000000000;
    while(L<R)
    {
        long long mid=(L+R)/2;
        if (f(mid))R=mid;
        else L=mid+1;
    }
    cout<<R;
    return 0;
}
```

---


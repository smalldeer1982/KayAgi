# [COCI 2023/2024 #3] Milano C.le

## 题目背景

**译自 [COCI 2023/2024 Contest #3](https://hsin.hr/coci/archive/2023_2024) T3「[Milano C.le](https://hsin.hr/coci/archive/2023_2024/contest3_tasks.pdf)」**

## 题目描述

Silvia 目前在米兰中央车站，她注意到车站有很多站台。她觉得站台数量太多了，所以她打算统计有多少真正需要的站台。

Silvia 同样注意到这个车站的一个有趣的事实：出发和到达时刻表每两天就会重复一次，并且时刻表满足所有 $n$ 列火车在一天到达车站，并且在另一天离开。注意按这种方式，没有火车会在所有火车都到达之前离开。

车站的站台足够长，可以满足所有 $n$ 列火车都能在同一站台停成一列。然而，如果火车 $x$ 先进入站台，然后 $y$ 进入同一站台，则火车 $x$ 不可以在火车 $y$ 离开站台之前离开。

Silvia 想知道在不存在由于排在某列火车前面的火车还没离开导致这列火车无法离开的情况下，最少需要多少站台可以使所有火车都停下。

## 说明/提示

### 样例解释 2

![](https://cdn.luogu.com.cn/upload/image_hosting/4ol0mhxg.png)

上图展示了一个样例二中站台上可能的列车调度情况。列车上 $(i:a_i/b_i)$ 的标签表示第 $i$ 列火车在第一天第 $a_i$ 个到达车站，然后在第二天第 $b_i$ 个离开车站。火车 $(2:1/2)$ 不能比火车 $(4:5/1)$ 更早离开车站。

### 样例解释 3

所有火车均可在同一站台排成一列，没有任何问题。

### 子任务

| 子任务 |               附加限制               | 分值 |
| :--------: | :----------------------------------: | :--: |
|    $1$     |              $n\le 10$               | $21$ |
|    $2$     | 最小所需站台数要么是 $1$，要么是 $2$ | $18$ |
|    $3$     |            $n\le 1\ 000$             | $31$ |
|    $4$     |              无附加限制              | $40$ |

## 样例 #1

### 输入

```
5
3 5 2 4 1
3 2 5 1 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
3 1 2 5 4
4 2 3 1 5
```

### 输出

```
4
```

## 样例 #3

### 输入

```
3
3 2 1
1 2 3
```

### 输出

```
1```

# 题解

## 作者：naturelyf (赞：8)

##### 题外话
和[上一题](https://www.luogu.com.cn/problem/P10224)一起打的模拟赛，感觉要简单一点。
### 题目大意
有 $n$ 辆车，给定来的顺序和走的顺序，可以将这一操作类比栈的先进后出，问最少多少个车站也就是问最少几个栈。
### 思路
显然贪心，具体怎么贪，需要分析。我们设 $t[i]$ 是这个车站最后进入的车的出站次序，那么后面进入的车出站次序也就是 $t[j]$ 要小于 $t[i]$ 。假设现在有一个车站，次序为 $t[1]$ ，现在来了一辆车，出站次序小于 $t[1]$ 为 $t[2]$ ，他可以选择进入这个车站或新开一个车站。如果新开一个，我们现在有两个车站且次序为 $t[1]$ 和 $t[2]$ ，如果直接加入这个车站，则可以等效得看作我们也有两个车站，只不过次序为 $+\infty$ 和 $t[2]$ ，则明显比新开一个更优，所以优先选择加入车站。

现在考虑怎么加入，可用同样的方法证明~~这里就不写了~~请自己证明一下
### 代码实现
首先考虑暴力，每次寻找第一个大于的车站，时间复杂度 $n^2$
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, m;
vector<int> e[N];
struct node {
    int a, b, id;
    bool friend operator<(node a, node b) { return a.a < b.a; }
} dt[N];
int main() {
    freopen("milano.in", "r", stdin);
    freopen("milano.out", "w", stdout);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> dt[i].a;
        dt[i].id = i;
    }
    for (int i = 1; i <= n; i++) cin >> dt[i].b;
    sort(dt + 1, dt + n + 1);
    e[1].push_back(dt[1].b);
    int cnt = 1;
    for (int i = 2; i <= n; i++) {
        int fl = 0;
        for (int j = 1; j <= cnt; j++) {
            if (e[j].back() > dt[i].b) {
                e[j].push_back(dt[i].b);
                fl = 1;
                break;
            }//这里一直从小到大加入，所以第一个找的的就是最小的
        }
        if (!fl)
            e[++cnt].push_back(dt[i].b);
    }
    cout << cnt;
    return 0;
}
```
考虑优化，这个瓶颈在于找最小的大于的，要支持随机访问，我考虑过优先队列但是无法实现随机访问，所以只好使用 $set$（没错，和上一题一样用 $set$ ），代码如下：
```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
using namespace std;
const int N=2e5+10;
int n,m;
vector<int> e[N];
struct node{
	int a,b,id;
	bool friend operator<(node a,node b){
		return a.a<b.a;
	}
}dt[N];
set<int> st;
int main(){
//	freopen("milano.in","r",stdin);
//	freopen("milano.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>dt[i].a;
		dt[i].id=i;
	}
	for(int i=1;i<=n;i++)cin>>dt[i].b;
	sort(dt+1,dt+n+1);
	st.insert(dt[1].b);
	int cnt=1;
	for(int i=2;i<=n;i++){
		auto p=st.upper_bound(dt[i].b);
		if(p==st.end())cnt++,st.insert(dt[i].b);
		else{
			st.erase(p);
			st.insert(dt[i].b);
		}
	}
	cout<<cnt;
	return 0;
}
//时间复杂度：nlogn
//优化思路：set 
//100pts
```

---

## 作者：__yiLIUyi__ (赞：5)

# P10225 [COCI 2023/2024 #3] Milano C.le 题解
[题目传送门](https://www.luogu.com.cn/problem/P10225)
## 简化题意
题意写的挺复杂，看了好久才看懂。其实很简单：

给出整数 $n$ 代表输入数字个数（数字分别为 $1$ 至 $n$），给出这 $n$ 个数字的入栈顺序和出栈顺序，求需要几个栈。
## 大致思路
首先，对于每个数字，使用结构体来记录它的三个内容：编号、入栈顺序、出栈顺序。

```cpp
struct node{
	ll num,in,out;
}a[200005];
```

此时，为了简化输入，我们可以对入栈顺序进行**排序**，保证入栈顺序。

```cpp
bool cmp(node a,node b){ 
	return a.in<b.in;
}
```

而因为保证了入栈，我们现在只需要考虑出栈。容易证明，对于每个栈，要保证栈中的数能够正常弹出，栈顶的元素必须是**最小**的。换言之，应该是一个**单调**的序列。因此，每当我们放入一个新元素时，就要进行比较：它是否比栈顶的数小。如果是，放入这个栈；反之，若没有一个栈符合条件，就开一个新栈，并记录栈的总个数。

```cpp
while(r-l>1){
    ll mid=l+(r-l)/2;
    if(f[mid]<a[i].out)l=mid;
    else r=mid;
}if(l+1>t) t=l+1;
f[l+1]=a[i].out;
```

但是，显然，这种做法时间复杂度较高，所以在上面的代码中进行了二分优化：从栈的使用方面入手，我们肯定需要先找较小的压入。

## 代码
因为思路部分已经给出了部分代码，所以代码不再添加过多注释：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,t,f[200005];
struct node{
	ll num,in,out;                        //num表示编号，in表示输入顺序，out表示输出顺序
}a[200005];
bool cmp(node a,node b){ 
	return a.in<b.in;                     //结构体排序
}
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		a[i].num=i;
		cin>>a[i].in;
	}for(ll i=1;i<=n;++i)cin>>a[i].out;
	sort(a+1,a+n+1,cmp);
	for(ll i=1;i<=n;i++){                //二分
		ll l=0,r=t+1;                    //给r加1是为了提前预留一个空栈
		while(r-l>1){
			ll mid=l+(r-l)/2;
			if(f[mid]<a[i].out)l=mid;
			else r=mid;
		}if(l+1>t) t=l+1;
		f[l+1]=a[i].out;
	}cout<<t<<endl;                     //完结撒花
  return 0;
}
```

---

## 作者：Duanhen (赞：2)

## 题目大意
有 $n$ 列火车，每一列有进站序号 $a$ 和出站序号 $b$，必须所有列车都进站完毕后才可以依次出站，且两两之间不能相互影响，即不能出现出站序号靠后的火车排在序号靠前的火车前面。求出最少需要几个站台可以满足上述需求。

## 解题思路
这道题说白了就是一个**先进后出**的栈思想。

我们可以把所有火车按进站顺序排好序，然后从第一列火车开始进行进站操作。

对于每列火车，如果当前已使用的所有站台中存在某一个站台最前面的火车的出站序号小于当前火车，则该火车可以直接停靠在该站台。如果所有站台都不满足最前面的火车的出站序号小于当前火车，则需要开辟一个新站台来停放该火车。

但是如果每一列火车进站时都要去遍历一遍站台的话，时间复杂度最坏会到 $n^2$，必然超时。而我们可以发现，每个站台的最前列火车的出站序号是有序的，为什么呢？

因为对于每列火车，只有在所有站台都小于它的出站序列时，它才会开辟一个新站台。所以我们通过二分查找找出满足需求的最小站台，将该列车放进去，就能保证不破坏有序性。

## 参考代码
``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 10;
struct tr {
  ll a, b;
} g[N];
ll sum[N], n, res, cnt; //sum表示站台，cnt表示已使用的站台数量

bool cmp(tr &x, tr &y) { return x.a < y.a; }
bool check(ll m) {}
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> g[i].a;
  for (int i = 1; i <= n; i++) cin >> g[i].b;
  sort(g + 1, g + n + 1, cmp);
  sum[++cnt] = g[1].b;
  for (int i = 2; i <= n; i++) {
    ll l = 1, r = cnt, tp = 0; //tp记录正确位置当前元素插入的位置
    while (l <= r) {
      ll m = (l + r) / 2;
      if (sum[m] < g[i].b) l = m + 1;
      else tp = m, r = m - 1;
    }
    if (tp == 0) sum[++cnt] = g[i].b; //开辟新站台
    else sum[tp] = g[i].b;
  }
  cout << cnt;
  return 0;
}
```

---

## 作者：ClearluvXL (赞：2)

# Milano C.le

## 思路

在一个栈内，为了满足先进后出，那么从栈底到栈顶的 $a$ 是单增的，$b$ 是单减的。

现在将每辆火车按照 $a$ 排序，首先满足 $a$ 是单增的。现在给一个栈考虑加入一辆火车。

称一个栈中最小的 $b$ 为 $mb$。

那么我们此时这辆火车的选择有两种：

- 开一个新的栈，将该火车放入这个栈，那么此时这个栈的 $mb$ 为 $b_{i}$。
- 选择一个 $mb \geq b_{i}$ 的栈，放入该火车，此时该站 $mb=b_{i}$。

如果将新开的那个栈的 $mb$ 原来看作 $\inf$ 的话，那么我们也将开新栈看作是加入一个栈。也就是说，现在我们其实是要选择一个 $mb\geq b_{i}$。将 $mb=b_{i}$。根据贪心的思想，肯定是选择满足条件的 $mb$ 里面最小的那个。

用个 set 维护现在的已有的栈的 $mb$ 即可。

## 代码

```c++
#include<bits/stdc++.h>
#define endl '\n' 

using namespace std;

const int N=2e5+10;

typedef long long ll;
typedef pair<int,int> pii;

int n;
pii a[N];

set<int> s;

int main(){
	freopen("milano.in","r",stdin);
	freopen("milano.out","w",stdout);
	
	ios::sync_with_stdio(0);
	
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].first;
	for(int i=1;i<=n;i++) cin>>a[i].second;
	
	sort(a+1,a+n+1);
	
	int ans=0;
	
	for(int i=1;i<=n;i++){
		int ed=a[i].second;
		auto it=s.lower_bound(ed);
		if(it!=s.end()){
			s.erase(it);
			s.insert(ed);
		}
		else{
			s.insert(ed);
			ans++;
		}
	}
	
	cout<<ans<<endl;
	
	return 0;
}//end
```

---

## 作者：qwer6 (赞：1)

这道题还是比较简单的。  
我们对这个问题进行一些简单的转换，可以发现，先将所有列车按照 $a$ 从小到大排序之后，要求同一个站台 $b$ 单调递减。  
这样我们就可以参考 $O(n\log n)$ 求最长下降子序列的做法，设 $f_i$ 表示当前第 $i$ 个站台现在的标号，如果现在最大的 $f_i$ 比现在的 $b$ 小，那么就再开一个新的站台，否则，就二分出第一个大于 $b$ 的 $f_i$，更新即可。
```c++
/*by qwer6(略去缺省源和快读快写)*/
const int N=2e5+5,inf=0x3f3f3f3f;
int n,ans;
int f[N];
struct Node{
	int a,b;
	bool operator <(const Node &T)const{return a<T.a;}
}a[N];
signed main(){
	read(n);
	for(int i=1;i<=n;i++)read(a[i].a);
	for(int i=1;i<=n;i++)read(a[i].b);
	sort(a+1,a+n+1);
	f[1]=a[1].b;
	ans=1;
	for(int i=2;i<=n;i++){
		if(f[ans]<a[i].b){
			ans++;
			f[ans]=a[i].b;
		}else{
			int p=upper_bound(f+1,f+ans+1,a[i].b)-f;
			f[p]=a[i].b;
		}
	}
	write(ans);
}
```

---

## 作者：StarsIntoSea_SY (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10225)

## 题目大意

有一些栈，给你 $n$ 个 $1$ 到 $n$ 的数，每个数各有一个入栈顺序和出栈顺序，你需要将这些数按照入栈顺序全部放入后按照出栈顺序弹出，至少需要多少个栈。

## 题目解析

很类似于[P1020导弹拦截](https://www.luogu.com.cn/problem/P1020) 。

**入栈操作：**

因为要同时满足入栈和出栈顺序，我们可以先对入栈顺序进行递增排序，保证入栈操作的实现。

**出栈操作：**

（因为保证了入栈操作，只需要考虑出栈，所以我们记录栈中的元素均为出栈顺序。）

不难发现，如果要保证这个栈中的数能够正常弹出，栈顶的元素必须是最小的，即满足栈的一个**单调性**（~~注意不是单调栈~~）。即当我们需要放入一个元素时，必须找栈顶中的数是否比它要大，如果大，就放入这个栈中；如果没有任何一个栈满足，就放入一个新栈，而我们需要求出的答案就是对于后者的情况出现的次数。

注意的是朴素枚举求最坏的时间复杂度是 $O(n^2)$ 的，我们需要使用二分法优化到 $O(n \log n)$。

考虑记录栈的使用情况，优先寻找较小的栈并压入，注意栈的使用情况要+1，即留出一个空栈，当没有合适的栈时压入空栈。

样例一解释：（元素是出栈顺序）

```cpp
in:
 5
 3 5 2 4 1
 3 2 5 1 4
   
out:
 2

排完序后：
 1 2 3 4 5
 4 5 3 1 2
```


![](https://cdn.luogu.com.cn/upload/image_hosting/3ump855s.png)

因为 $ n \le 2 \times 10^5 $，而快排时间复杂度约 $O(n \log n)$，操作时间复杂度 $O(n \log n)$，可以通过。

详细的都放在代码里面了：

**Code**

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
struct node{
	int num,in,out;   //in是入栈顺序,out是出栈顺序
};
node a[200005];
inline bool cmp(node a,node b){ 
	return a.in<b.in;   //入栈顺序从小到大排
}
int n;
int f[200005]={0};    //f[]记录栈的情况
int solve(){
	int t=0;   //t记录目前栈的使用情况
	for(int i=1;i<=n;++i){
		int l=0,r=t+1;   //这里r要+1是提前留出一个空栈来存放
		while(r-l>1){  //二分找能装下的栈
			int m=l+(r-l)/2;   
			if(f[m]<a[i].out) l=m;  //优先找较小的栈（能够压入的）
			else r=m;
		}
		int x=l+1;
		if(x>t) t=x;  //更新答案
		f[x]=a[i].out; //将新的数压入栈顶
	}
	return t;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		int x;scanf("%d",&x);
		a[i].num=i;
		a[i].in=x;
	}
	for(int i=1;i<=n;++i){
		int x;scanf("%d",&x);
		a[i].out=x;
	}
	sort(a+1,a+1+n,cmp);    //入栈排序
	printf("%d\n",solve());
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

简单贪心。

按照进站时间排序，显然如果有一个站台满足题设那么新开一个站台一定是不优的。

证明：

- 考虑当前为第 $i$ 班车，有一个站台 $p$ 中最早发车时间 $t_p>a_i$，显然 $i$ 可以插入此站台，代价是 $t_p\leftarrow a_i$。

- 考虑什么时候这个可能更劣，显然是后面一个 $j$ 发现自己没有站台可以插入于是必须开一个新站台 $q$。此时 $t_q=a_j,t_p=a_i$。

- 如果插入 $i$ 时造出站台 $q$ ，将 $j$ 插入站台 $p$，则 $t_p=a_j,t_q=a_i$。

- 发现由于站台没有区别，这两个方案也根本没有区别。而如果后面没有这样的存在 $j$ 新开一个站台显然更劣。

所以维护所有站台最早发车时间就好。如果有多个满足条件显然我们需要为后面的车留出尽量充裕的空间所以选择发车时间最早的晚于该列车发车时间的站台即可。

容易用 set 维护做到 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define lint __int128
#define int long long
#define fi first
#define se second
#define Il inline
#define vec vector
#define pb push_back
#define IT ::iterator
#define p_q priority_queue

using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef double db;
const int N=2e5,mod=1e9+7;
const db eps=1e-9,pi=acos(-1.0);

mt19937 rnd(time(0));
Il int rint(int l,int r){return rnd()%(r-l+1)+l;}

int n,a[N+5],b[N+5],ca[N+5],cb[N+5],ans=0;
set<int>s;

signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;for(int i=1;i<=n;i++)cin>>a[i],ca[a[i]]=i;
    for(int i=1;i<=n;i++)cin>>b[i];
    for(int i=1;i<=n;i++){
        if(s.empty()){s.insert(b[ca[i]]);continue;}
        set<int>IT it=s.lower_bound(b[ca[i]]);
        if(it!=s.end())s.erase(it);
        s.insert(b[ca[i]]);
    }
    cout<<s.size();
    return 0;
}
```

---

## 作者：HsNu1ly7_ (赞：0)

## 思路

题目需要的是每个站台进站顺序**递增**，出站顺序**递减**。

那么我们可以先对数据按进站顺序升序排序，然后答案就是将出站序列划分成若干个下降子序列最小的数量。

根据 Dilworth 定理，可以得知，序列下降子序列的数量就是该序列最长上升子序列的长度。

所以只要用二分的方法，$O(n \log n)$ 的复杂度即可通过。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep( i , l , r ) for (int i = (l) ; i <= (r) ; i++)
#define per( i , r , l ) for (int i = (r) ; i >= (l) ; i--)
const int N = 2e5 + 10 ;
int n ;
struct node{
	int l , r , id ;
}a[N] ;
int ans ;
bool cmp (node a , node b){
	return a.l < b.l ;
}
int lis[N] ;
int tot ;
void solve (){
	cin >> n ;
	rep (i , 1 , n){
		cin >> a[i].l ;
	}
	rep (i , 1 , n){
		cin >> a[i].r ;
	}
	sort (a + 1 , a + 1 + n , cmp) ;
	rep (i , 1 , n){ //求最长上升子序列
		if (lis[tot] < a[i].r){
			lis[++tot] = a[i].r ;
		}else{
			int p = lower_bound (lis + 1 , lis + 1 + tot , a[i].r) - lis ;
			lis[p] = a[i].r ;
		}
	}
	cout << tot ;
}
signed main (){
	int _ = 1 ;
	//cin >> _ ;
	while ( _-- ){solve () ;}
	return 0 ;
}
```

---

## 作者：ac_lxy (赞：0)

## 算法思路
我们可以使用贪心算法来解决这个问题。首先，我们观察到每辆火车在两天内都会到达和离开车站一次。我们可以将这些火车的到达和离开情况分别表示为两个数组，分别命名为数组 $a$ 和数组 $b$。其中，$a[i]$ 表示第 $i$ 列火车在第一天到达的车站编号，$b[i]$ 表示第 $i$ 列火车在第二天离开的车站编号。接着，我们对这些火车按照到达时间进行排序。然后，我们使用贪心算法模拟火车的停靠过程。具体步骤如下：对所有火车按照到达时间进行排序。遍历排序后的火车列表，对于每辆火车：使用二分查找确定当前火车可以停靠的站台。如果找到了可以停靠的站台，则将当前火车停靠在该站台上。如果没有找到合适的站台，则新建一个站台，并将当前火车停靠在该站台上。最后，输出所需站台的数量即可。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAX_N = 200005;

struct Node {
    int num, in, out;   // in是入栈顺序，out是出栈顺序
};

Node a[MAX_N];
int f[MAX_N] = {0};    // f[]记录栈的情况

bool compare(Node a, Node b) { 
    return a.in < b.in;   // 入栈顺序从小到大排
}

int solve(int n) {
    int t = 0;   // t记录目前栈的使用情况
    for (int i = 1; i <= n; ++i) {
        int l = 0, r = t + 1;   // 这里r要+1是提前留出一个空栈来存放
        while (r - l > 1) {  // 二分找能装下的栈
            int m = l + (r - l) / 2;   
            if (f[m] < a[i].out)
                l = m;  // 优先找较小的栈（能够压入的）
            else
                r = m;
        }
        int x = l + 1;
        if (x > t) t = x;  // 更新答案
        f[x] = a[i].out; // 将新的数压入栈顶
    }
    return t;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    for (int i = 1; i <= n; ++i) {
        cin >> a[i].in;
        a[i].num = i;
    }

    for (int i = 1; i <= n; ++i) {
        cin >> a[i].out;
    }

    sort(a + 1, a + 1 + n, compare);    // 入栈排序
    cout << solve(n) << endl;

    return 0;
}

```

---

## 作者：Add_Catalyst (赞：0)

# P10225 [COCI 2023/2024 #3] Milano C.le 题解

---

## 知识点

栈，贪心，树状数组。

---

## 题意分析

求最小的栈的数量使得出入栈能够合法。

---

## 思路分析

我们为了方便，其实可以先按照到达车站的顺序（入栈顺序）给火车重新编号。编号后，就十分简单了。

分析样例：

```cpp
5
3 5 2 4 1
3 2 5 1 4
```

编号后，就变成了：

```cpp
5
1 2 3 4 5
4 5 3 1 2
```

然后我们对 `4 5 3 1 2` 的出栈序列进行倒推，就又变成了一个入栈序列，且我们获得了很多的限制条件。

在倒推序列时，假设现在加入 $i$，它必须接在一个小于它且已经进入序列并作为栈顶的数后面，或者独立成栈。

实例：`2 5 4 1 3` 的出栈序列。

1. 入 `3`，先独立成栈；
2. 入 `1`，没有小于它的数，独立成栈；
3. 入 `4`，有两个小于它的栈顶，分别是 `1 3`。考虑贪心，尽量选大的那个，然后就可以为后面的留下小的。这里选 `3`；
4. 入 `5`，有两个小于它的栈顶，分别是 `1 4`。依照前文，这里选 `4`；
5. 入 `3`，有1个小于它的栈顶，是 `1`。注意到如果之前没有留下栈顶 `1`，这里就要再多成立一个栈了。

那么共成了两个栈，答案也就是 `2`。

我们找小于一个数的最大值，可以用树状数组倍增，时间复杂度 $O(n\log_2{n})$。

（记得在栈中加入一个数后，要把原本的栈顶删除。）

---

## CODE

```cpp
#include<bits/stdc++.h>
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=2e5+10;
int n,ans;
int a[N],b[N];
struct BIT{
#define lowbit(a) ((a)&-(a))
	int c[N];
	void Update(int x,int d){
		for(int i=x;i<=n;i+=lowbit(i))c[i]+=d;
	}
	int Query(int x){
		int res=0;
		for(int i=x;i;i^=lowbit(i))res+=c[i];
		return res;
	}
	int Bound(int x){
		int ans=0,sum=0;
		DOR(i,18,0)if(ans+(1<<i)<=n&&sum+c[ans+(1<<i)]<x)ans+=1<<i,sum+=c[ans];
		return ans+1;
	}
#undef lowbit
}B;
signed main(){
	cin>>n;
	FOR(i,1,n)cin>>a[i];
	FOR(i,1,n)cin>>b[a[i]];
	FOR(i,1,n)cout<<b[i]<<" ";cout<<endl;
	DOR(i,n,1){
		int ret=B.Query(b[i]);
		if(!ret)++ans;
		else B.Update(B.Bound(ret),-1);
		B.Update(b[i],1);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

---


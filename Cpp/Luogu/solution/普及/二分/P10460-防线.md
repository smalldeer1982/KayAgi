# 防线

## 题目描述

lsp 学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的 lsp 黑化成为了黑暗英雄 Lord lsp。就如同中二漫画的情节一样，Lord lsp 打算毁掉这个世界。数学竞赛界的精英 lqr 打算阻止 Lord lsp 的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。由于队员们个个都智商超群，很快，行动队便来到了 Lord lsp 的黑暗城堡的下方。

但是，同样强大的 Lord lsp 在城堡周围布置了一条“不可越过”的坚固防线。防线由很多防具组成，这些防具分成了 $N$ 组。我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。也就是说，我们可以用三个整数 $S$，$E$ 和 $D$ 来描述一组防具，即这一组防具布置在防线的 $S,S + D,S + 2D，\dots，S + KD$（$K\in \Z，S + KD\leq E，S + (K + 1)D>E$） 位置上。

黑化的 Lord lsp 设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的（包括这个位置一个防具也没有的情况，因为 $0$ 也是偶数）。只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学们，你们要帮助她解决这个问题。

## 说明/提示

对于 $30\%$ 的数据，满足防具总数不多于 $10  ^ {7}$。

对于 $100\%$ 的数据，满足防具总数不多于 $10  ^ {8}$，$S_{i}\le E_{i} $，$1\le T \le 5$，$N \le 200000$，$0 \le S_{i}$ ，$E_{i}$ ，$D_{i} \le 2^{31} - 1$。

## 样例 #1

### 输入

```
3
2
1 10 1 
2 10 1 
2
1 10 1 
1 10 1 
4
1 10 1 
4 4 1 
1 5 1 
6 10 1
```

### 输出

```
1 1
There's no weakness. 
4 3```

# 题解

## 作者：Misserina (赞：18)

# P10460 防线

我的算法比较与众不同：位运算。

首先需要明确一点：如果一组数据中只有一个数据出现了奇数次，那么把全部数据异或一遍，最后剩下的就是出现奇数次的那个数，因为两个相同数字异或后总是零。

然后再遍历全部防线，找出那个出现奇数次的防具出现次数即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,s,e,d;
struct defender {
	int st;
	int en;
	int dis;
};
defender arr[200005];
int main() {
	scanf("%d",&t);
	for (int i=1;i<=t;i++) {
		scanf("%d",&n);
		int m=0;
		for (int i=1;i<=n;i++) {
			scanf("%d%d%d",&s,&e,&d);
			defender tmp;
			tmp.st=s;
			tmp.en=e;
			tmp.dis=d;
			arr[i]=tmp;
			for (int k=s;k<=e;k+=d) m^=(k+1); //排除k=0的特殊情况
		}
		if (m==0) {
		    printf("There's no weakness.\n");
		    return 0;
		}
		m--;
		int num=0;
		for (int i=1;i<=n;i++) {
			if (m<=arr[i].en && m>=arr[i].st && (m-arr[i].st)%arr[i].dis==0) num++;
		}
		printf("%d %d\n",m,num);
	}
}
```

---

## 作者：zzx6 (赞：16)

[题目传送门](https://www.luogu.com.cn/problem/P10460)

注意到题目中说**整条防线上最多只有一个位置有奇数个防具,剩下的位置都是偶数个防具**，由此可得如果有一个位置有奇数个防具，整条防线的防具数之和必为奇数（奇数 $+$ 偶数 $=$ 奇数，偶数 $+$ 偶数 $=$ 偶数），反之，如果整条防线的防具数之和为偶数，那么整条防线上的位置都只有偶数个防具。

- 考虑二分有奇数个防具的位置 $mid$，然后判断 $[l,mid]$ 和 $[mid+1,r]$ 两段区间的奇偶性：
  1. 如果 $[l,mid]$ 区间内的防具个数之和为奇数，那奇数位防具必定在 $[l,mid]$ 区间内。   
  2. 如果 $[mid+1,r]$ 区间内的防具个数之和为奇数，那奇数位防具必定在 $[mid+1,r]$ 区间内。

- 考虑如何在 $O(n)$ 时间复杂度内计算出一段前缀和区间（设为 $[1,x]$）内防具个数之和：

  可以枚举每一个等差数列的位置（设对于第 $i$ 个等差数列，其左端点为 $l_i$，右端点为 $r_i$，公差为 $d_i$），那么对于这一段区间，这个等差数列所能产生的贡献为 $\frac{\min(x,r_i) - l_i}{d_i} + 1$。

```cpp
#include<iostream>
using namespace std;
long long n,L,R,s[200005],t[200005],d[200005];
long long S(long long x)//计算前缀和
{
	long long sum = 0;
	for(int i = 1;i <= n;i++)
		if(s[i] <= x)sum += (min(x,t[i]) - s[i]) / d[i] + 1;
	return sum;
}
bool check(long long x,long long y)//判断当前区间是否有奇数个防具
{
	return (S(y) - S(x - 1)) % 2 == 1;
}
int main()
{
	int T;
	cin >> T;
	while(T--)
	{
		cin >> n;
		L = 1e9,R = 0;
		for(int i = 1;i <= n;i++)
		{
			cin >> s[i] >> t[i] >> d[i];
			L = min(L,s[i]),R = max(R,t[i]);
		}
		if(!check(L,R))
		{
			cout << "There's no weakness.\n";
			continue;
		}
		int l = L,r = R,ans = 0;
		while(l <= r)
		{
			int mid = (l + r) / 2;
			if(check(l,mid))r = mid - 1,ans = mid;
			else l = mid + 1;
		}
		cout << ans << " " << S(ans) - S(ans - 1) << "\n";
	}
	return 0;
}
```

---

## 作者：zqt2011823 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10460)

~~这道题第一眼看以为暴力就能过。。。~~

看数据 $S_i,E_i,D_i \le 2^{31}- 1$ 
特别的大，开数组要么 ```RE``` 要么 ```MLE```。

再一看，只有一个答案，就会得到以下思路：
### 思路：


---

可以先把所有防具先加起来，因为 偶 $+$ 偶 $=$ 偶，偶 $+$ 奇 $=$ 奇，如果加起来是偶数的话，就直接可以过掉了， 里面不可能有奇数，没有破绽。

接着二分查找，同上面，算这一部分是否是奇数，可以设置一个变量 $pos$，算从头到 $pos$ 或 $E_i$ 有多少个防具，用累加器 $sum$ 累加，就可以算出这个是否是奇数。

找到这个位置后，用 ```for``` 循环来查找这个位置被算了几次就可以输出了。

### 正确代码：


---


```cpp
#include<bits/stdc++.h>
using namespace std;
int S[200001],E[200001],D[200001];
int n,T,cnt,anssum;
bool check(long long pos)
{
	int sum=0;
	for(int i=1;i<=n;i++)//到pos位置的防具数量 
	{
		if(pos<S[i]) continue;
		int r=min(pos,(long long)E[i]);
		sum+=(r-S[i])/D[i]+1;
	}
	if(sum&1) return 1;
	else return 0;
}
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;
		cnt=0;
		for(int i=1;i<=n;i++)
		{
			cin>>S[i]>>E[i]>>D[i];
			cnt+=(E[i]-S[i])/D[i]+1;
		}
		if(!(cnt&1))//所有的防具加起来是偶数，就没破绽了
		{
			cout<<"There's no weakness." <<endl;
			continue;
		}
		long long l=0,r=0x7fffffff,ans=-1;
		while(l<=r)//二分查找奇数位置
		{
			long long mid=(l+r)/2;
			if(check(mid))
			{
				ans=mid;
				r=mid-1;
			}
			else
			{
				l=mid+1;
			}
		}
		anssum=0;
		for(int i=1;i<=n;i++)
		{
			if(ans>=S[i]&&ans<=E[i]&&(ans-S[i])%D[i]==0)//被记了几次
			{
				anssum++;
			}
		}
		cout<<ans<<" "<<anssum<<endl;
	}
	return 0;
}

```
管理员大大求过 QWQ

---

## 作者：a18981826590 (赞：3)

# [P10460 防线](https://www.luogu.com.cn/problem/P10460)
## 解题思路
题目中说**整条防线上也最多只有一个位置有奇数个防具**。

如果没有一个位置有奇数个防具，那么每一个位置均有偶数个防具，则最后一个位置的前缀和必为偶数；反过来，如果最后一个位置的前缀和为偶数，则没有一个位置有奇数个防具；如果最后一个位置的前缀和为奇数，则有一个位置有奇数个防具。

如果有一个位置有奇数个防具，那么其它位置均有偶数个防具，则它前面位置的前缀和均为偶数，它后面位置的前缀和均为奇数。由此可得，前缀和序列具有单调性，支持二分查找。

但整个防线长达 $2^{31}$，求出整个序列每个位置的前缀和是不太可能的，也无法求出每个位置的防具数量（因为空间不够）。考虑如何在 $O(n)$ 的时间复杂度内求出单点的前缀和：可以遍历每组防具，如果第 $i$ 组防具的起点在位置 $x$ 及其前，则第 $i$ 组防具对位置 $x$ 的前缀和的贡献即为 $\frac{\min(E_{i},x)-S_{i}}{D_{i}}+1$。

二分查找时，只要当前位置前缀和为奇数，则答案位置在后面，否则答案位置在前面。找到答案后用答案位置的前缀和减去答案位置前一位的前缀和即可得到答案位置处的防具数量。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200010],b[200010],c[200010],n,t,x,y;
int d(int e){
	int f=0;
	for(int i=0;i<n;i++){
		if(a[i]<=e) f+=(min(e,b[i])-a[i])/c[i]+1;
	}
	return f;
}
int main(){
	ios::sync_with_stdio(0);
	cin>>t;
	while(t--){
		cin>>n;
		x=1e9;
		y=0;
		for(int i=0;i<n;i++){
			cin>>a[i]>>b[i]>>c[i];
			x=min(a[i],x);
			y=max(b[i],y);
		}
		if(d(y)%2==0){
			cout<<"There's no weakness.\n";
			continue;
		}
		while(x<=y){
			if(d(x+(y-x)/2)%2==0) x+=(y-x)/2+1;
			else y=x+(y-x)/2-1;
		}
		cout<<x<<' '<<d(x)-d(x-1)<<'\n';
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：2)

因为题目满足只有一个位置 $p$ 是奇数，并且我们发现我们可以用 $O(n)$ 来计算出一个区间内的和。结合前缀和的性质，我们发现：$p$ 之前的前缀和都是偶数，后面（包括 $p$）的都是奇数。所以我们可以二分 $pos$，然后判断 $pos$ 位置的前缀和的奇偶性，最后锁定 $p$。

至于 $p$ 的防具数量，另外求即可。

```C++

int mx;
int n;

struct node{
    int s,e,d;
}t[N];

int cal(int pos){
    int res=0;
    for(int i=1;i<=n;i++){
        if(t[i].s>pos)continue;
        res+=(min(t[i].e,pos)-t[i].s)/t[i].d+1;
    }
    return res;
}


void solve(){
    n=rd;
    for(int i=1;i<=n;i++){
        t[i].s=rd,t[i].e=rd,t[i].d=rd;
        mx=max(mx,t[i].e);
    }

    int l=1,r=mx+1;
    while(l<=r){
        int mid=l+r>>1;
        if(cal(mid)&1)r=mid-1;
        else l=mid+1;
    }
  
    r++;
    if(r>mx){
        cout<<"There's no weakness.\n";
        return ;
    }

    cout<<r<<' ';
    int sum=0;
    for(int i=1;i<=n;i++){
        if(t[i].s<=r&&t[i].e>=r)sum+=((r-t[i].s)%t[i].d==0);
    }

    cout<<sum<<endl;

}
```

---

## 作者：Xu_Jinyi_2011 (赞：2)

# P10460 防线
## 题解
### 分析：
- 由题可知，在一组数据中奇数最多出现一次。
- 奇数 + 偶数 = 偶数。
- 偶数 + 偶数 = 偶数。
+ **所以可以算出一个区间的所有数的和：**（前缀和的专长）。
+ 如果和为奇数，则脆弱点就在这一区间。
+ 反之则不在这个区间。
+ **这很符合二分的算法使用条件**。
- 所以这一道题可用到的算法有**前缀和**，**二分**。

   先判断全部加起来是否为偶数，若为偶数，输出 `There's no weakness.`；否则二分判断目标在 $mid$ 前还是后。找到弱点后再用前缀和相减的方法算出防御的层数。
#### 附上代码：
```cpp
#include <cstring>
#include <iostream>
#define int long long
using namespace std;
const int N = 200010;
int T, n;
int s[N], e[N], d[N];

bool check(int l, int r){
	int sum1 = 0;
	for(int i = 0; i < n; i++)
		if (s[i] <= r) sum1 += (min(r, e[i]) - s[i])/d[i] + 1;
	int sum2 = 0;
	for (int i = 0; i < n; i ++){
		if (s[i] <= l - 1) sum2 += (min(l - 1, e[i]) - s[i])/d[i] + 1;
	}
	return (sum1 - sum2) & 1;
}

signed main(){
	cin >> T;
	while (T){
		memset(s, 0, sizeof s);
		memset(e, 0, sizeof e);
		memset(d, 0, sizeof d);
		int r = -114514, l = 114514;
		T --;
		scanf("%lld", &n);
		for (int i = 0; i < n; i ++){
			scanf("%lld%lld%lld", &s[i], &e[i], &d[i]);
			l = min(s[i], l);
			r = max(e[i], r);
		}
		if (check(l, r)){
			int mid;
			while (r >= l){
				mid = l + (r - l)/2;
				if (check(mid, r)){
					l = mid + 1;
				}else{
					r = mid - 1;
				}
			}
			int sum1 = 0;
			for(int i = 0; i < n; i++)
			if (s[i] <= r) sum1 += (min(r, e[i]) - s[i])/d[i] + 1;
			int sum2 = 0;
			for (int i = 0; i < n; i ++){
				if (s[i] <= r - 1) sum2 += (min(r - 1, e[i]) - s[i])/d[i] + 1;
			}
			printf("%lld %lld\n", r, sum1 - sum2);
		}else{
			printf("There's no weakness.\n");
			continue;
		}
	}
	return 0;
}
```

---

## 作者：_xdd_ (赞：1)

刚开始没看出来是二分答案。

如果想用二分答案，需要知道：奇数 $+$ 偶数 $=$ 奇数、偶数 $+$ 偶数 $=$ 偶数。

如果防具的数量是偶数则没有破绽，输出 `There's no weakness.`。

然后就是二分条件，因为奇数 $+$ 偶数 $=$ 奇数，则如果在 $mid$ 左边的防具数量是奇数，则破绽在左边（左边一定有一个奇数），右边同理。

第二问枚举即可，记得开 `long long`，这道题用到的取模运算比较多，多加括号。


```cpp
#include<bits/stdc++.h>
#define maxn 200000+5
#define int long long
using namespace std;
int s[maxn],e[maxn],d[maxn],n,t,cnt;
bool check(int x){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(x>=s[i]){
    		ans+=(min(x,e[i])-s[i])/d[i]+1;
		}
	}
	return bool(ans&1);
}
signed main(){
	cin >> t;
	while(t--){
		cin >> n;
		cnt=0;
		for(int i=1;i<=n;i++){
			cin>>s[i]>>e[i]>>d[i];
			cnt+=(e[i]-s[i])/d[i]+1;
		}
		if(!(cnt&1)){
			cout << "There's no weakness.\n";
			continue;
		}
		int l=0,r=0x7fffffff,ans1=-1,ans2=0;
		while(l<=r){
			int mid=l+r>>1;
			if(check(mid)){
			    r=mid-1;
				ans1=mid;
			}
			else{
				l=mid+1;
			}
		}
		for(int i=1;i<=n;i++){
			if(ans1>=s[i] && ans1<=e[i] && !((ans1-s[i])%d[i])){
				ans2++;
			}
		}
		cout << ans1 << " " << ans2 << endl;
	}
	return 0;
}
```

---

## 作者：mirance2025 (赞：1)

### 题目描述
众所周知，一位 OIer 需要将题目读 3 遍。

[P10460 防线](https://www.luogu.com.cn/problem/P10460)

### 题意分析

前置知识：前缀和 + 二分位置

#### 1、奇数位存在性
整个序列中至多有一个位置的数字所占数量是奇数，所以如果存在奇数位，则整个数列的总和必然是奇数（奇数 + 偶数 = 奇数，偶数 + 偶数 = 偶数）。反之，若不存在奇数位，则一定是偶数。故只需判断数字数量的总和的奇偶性即可。

#### 2、二分位置
若存在这个奇偶性，我们可以通过**二分答案的位置**来找到这个位置，然后判断区间 $[l, mid]$ 的总和的奇偶性。若为奇数，则奇数位存在于此区间。反之若为偶数，则一定存在于 $[mid + 1, r]$ 区间。

用这个方法逐步缩小范围即可。

#### 3、$O(n)$ 时间内求出区间 $sum[x]$ 的数字个数
设整个数列的最小位置为 $minn$。

这里，我们枚举每一个等差数列（它的起点为 $s$，终点为 $e$，差为 $d$）。若 $s \leq x$，则两区间存在交集。

则它与 $[minn,x]$ 的共同区间为 $[s, min(e, x)]$。那么此区间包含此数列的个数是 $\lfloor (min(e, x) − s) / d \rfloor + 1$。

正确性证明十分容易：
在此区间中存在一段区间，共 $\lfloor s, min(e, x) / d \rfloor \times d$ 个位置，头尾的位置上都有数字，差为 $d$，则数字的数量就是 $\lfloor \frac{min(e, x) − s}{d} \rfloor + 1$。

#### 时间复杂度

$O(n logn)$

#### 代码
```
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
const int N = 200000 + 1, INF = 1e9;
int t,n;
struct node{
    int s,e,d;
}a[N];
int getSum(int x){
    int res = 0;
    for(int i = 1; i <= n; i++)
        if(a[i].s <= x)
            res += (min(a[i].e, x) - a[i].s)/a[i].d + 1;

    return res;
}
bool check(int l,int r){
    return (getSum(r) - getSum(l - 1)) & 1;
}
int main(){
    cin >> t;
    while(t--){
        cin >> n;
        int maxn = -INF, minn = INF;
        for(int i = 1; i <= n; i++){
            cin >> a[i].s >> a[i].e >> a[i].d;
            minn = min(minn,a[i].s); 
            maxn = max(maxn,a[i].e);
        }

        if(!(getSum(maxn) & 1)){
            cout << "There's no weakness." << endl;
        }else{
            int l = minn, r = maxn;
            while(l <= r){
                int mid = (l + r) >> 1;
                if(check(l,mid))r = mid - 1;
                else l = mid + 1;
            }

            cout << l << " " << (getSum(l) - getSum(l - 1)) << endl;
        }
    }
    return 0;
}
```

---

## 作者：atomic_int (赞：1)

### Analysis

题目中保证了 **最多只有一个位置有奇数个防具**，假设用 $s_i$ 表示位置 $0 \sim i$ 的防具个数，如果位置 $x$ 上防具个数为奇数个，那么 $s_x$ 及其后面的 $s$ 均为奇数，$x$ 前面的 $s$ 均为偶数。可以用二分求位置 $x$。特别的，当 $s_{2^{31}-1}$ 为偶数时，即不存在破绽，输出 `There's no weakness.`。时间复杂度为 $O(n \log n)$。

对于每次二分得到的位置 $x'$， $O(n)$ 求 $s_{x'}$ 即可，对于 $1 \leq i \leq n,S_i \leq x$，对 $s_x$ 的贡献为 $\frac{\min\left( E_i,x' \right)-S_i}{D_i}+1$。

### Code

```cpp
#include <bits/stdc++.h>

const int N = 200005, M = 2147483647;

int n;
int s[N], e[N], d[N];

int sum(int x) {
  int res = 0;
  for (int i = 1; i <= n; i++) {
    if (s[i] > x) {
      continue;
    }
    res += (std::min(e[i], x) - s[i]) / d[i] + 1;
  }
  return res;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin >> t;
  while (t--) {
    std::cin >> n;
    for (int i = 1; i <= n; i++) {
      std::cin >> s[i] >> e[i] >> d[i];
    }
    if (sum(M) % 2 == 0) {
      std::cout << "There's no weakness." << '\n';
      continue;
    }
    int l = 0, r = M, ans;
    while (l <= r) {
      int mid = (1ll * l + r) >> 1;
      if (sum(mid) % 2 == 1) {
        ans = mid;
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
      if (ans < s[i] || ans > e[i]) {
        continue;
      }
      cnt += ((ans - s[i]) % d[i] == 0);
    }
    std::cout << ans << ' ' << cnt << '\n';
  }
  return 0;
}
```

---

## 作者：lcy0506 (赞：1)

# P10460 防线

[题目链接](https://www.luogu.com.cn/problem/P10460)

### 二分 and 一点数学知识
这道题题目看着很长，但只要把握重点内容，就可以轻松解决。

题目中正向枚举很明显会 TLE，所以我们想到二分答案。再观察题目发现，只有一个地方有奇数个防具，所以我们只需判断 $1$ 至 $mid$ 的防具总数是否为奇数。如果是,则说明防具在 $mid$ 之前，则 $right$ 应减小，否则，应增大 $left$。

### 代码如下

```
#include <bits/stdc++.h>
using namespace std;
int a[1000001],b[1000001],c[1000001],n;
int pd(int x)//判断x之前的防具个数
{
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]<=x)
		ans+=(min(x,b[i])-a[i])/c[i]+1;//利用等差数列公式求防具和
	}
	return ans;
}
long long read()
{
	char ch=getchar();
	int x=0,f=1;
	while(!isdigit(ch)){
		if(ch=='-') 
		f=-1;
		ch=getchar();
	}
  	while(isdigit(ch)){
  		x=x*10+ch-'0',ch=getchar();
	}
  	return x*f;	
}//快读模版
void write(long long x)
{
	if(x<0)
	putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}//快写模版
int main()
{
	int T;
	T=read();
	for(int i=1;i<=T;i++){
		n=read();
		for(int i=1;i<=n;i++)
		{
			a[i]=read();
			b[i]=read();
			c[i]=read();
		}
		if(pd(2147483647)%2==0)
		{
			printf("There's no weakness.\n");
			continue;
		}//如果所有防具和为偶数，则说明没有破绽
		int l=0,r=2147483647;//题目数据int范围
		while(l<r)
		{
			int mid=(l+r)>>1;
			if(pd(mid)&1)
			r=mid;
			else
			l=mid+1;
		}//二分模版
		write(l);
		printf(" ");
		write(pd(l)-pd(l-1));//位置l上的防具数量,用前缀和实现
		printf("\n");
	}
}
```
码风不佳，请勿见怪。

欢迎 dalao 们提出改进建议。

---

## 作者：JYX0924 (赞：1)

因为这道题最多只有一个点的防具有奇数个，所以用二分寻找一个位置，使得这个位置之前的防具前缀和是偶数，之后是奇数。

二分循环时，要注意可能有死循环，及时判重退出。

下面是 AC 代码。

```c
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
struct node {ll s,e,d;} a[200005];
ll T,n,zd;

ll cal(ll now)
{
	ll sum=0;
	for(ll i=1;i<=n;i++)
	{
		if(a[i].s>now) continue;
		sum=sum+(min(now,a[i].e)-a[i].s)/a[i].d+1;
	}
	return sum;
}

void out(ll now)
{
	ll sum=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i].s>now || now>a[i].e) continue;
		if( (now-a[i].s)%a[i].d==0 ) sum++;
	}
	cout<<now<<" "<<sum<<"\n";
}

void erfen() //二分
{
	ll l=1,r=zd;
	while(l<=r)
	{
		ll mid=(l+r)/2,x=cal(mid);
		if(x%2==0) l=mid+1;
		else r=mid-1;
		if(mid==(l+r)/2) break;
	}
	l--; r++;
	for(int i=l;i<=r;i++)
	{
		if(cal(i)%2==1) {out(i); return;}
	}
	cout<<"There's no weakness.\n";
}

int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>n; zd=0;
		for(ll i=1;i<=n;i++) cin>>a[i].s>>a[i].e>>a[i].d,zd=max(zd,a[i].e);
		erfen();
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：liguangjun2023 (赞：0)

算法分析
1. 利用两个相同数的异或运算结果为 $0$，把所有防具位置进行异或运算后，可以找到防具为奇数的位置，如果结果为 $0$，则没有防具数量为奇数的位置 $k$，如果结果不为零，则是防具为奇数的位置 $k$。
2. 利用该位置 $k$，以及防线的三个参数 $(S,E,D)$，计算防线在位置 $k$ 的数量。
   

---


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
// 防具位置 
struct {
	int s,e,d;
}a[N]; 
int t,n; 

int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n;
		int k=0;	
		for(int j=1;j<=n;j++){
			cin>>a[j].s>>a[j].e>>a[j].d;	
			// 异或运算所有的位置防具		
			for(int m=a[j].s;m<=a[j].e;m+=a[j].d){
				k^=m;
			}
		}
		int cnt=0;
		// 结果为 0 表示没有奇数数量的位置，否则为奇数数量的位置 
		if(k==0){
			cout<<"There's no weakness."<<endl;
		}else{
			// 统计所有的防线中，位置为k的数量 
			for(int j=1;j<=n;j++){
				if(k>=a[j].s && k<=a[j].e && (k-a[j].s)%a[j].d==0)
					cnt+=1;
			}
			cout<<k<<" "<<cnt<<endl; 
		}
		memset(a,0,sizeof(a));
	}
	return 0;
}
```

---

## 作者：Wangjinghanwjh (赞：0)

## [P10460 防线](https://www.luogu.com.cn/problem/P10460)


---


~~一道有题解的黄题。~~


---


**题意分析:** 

使用 **$S$，$D$，$E$** 来表示防具排列**位置**，并且满足 $S+KD$ 不超过 $E$（其中 **$K$** 表示任已满足$S+KD \le E$ 的数，例如 $1+1 \le 10$，$K=1$）并且 **每一组防具都分布在防线的某一段上** 这也就意味着我们只需要求出为 $M$ 长度的每一个位置上**防具的数量**，在判断奇偶性就行了。


---


**本题细节:**

1. 整条防线上也最多只有一个位置有奇数个防具，也就意味着，对于每一组数据**有且仅有一个**。

2. 如果防线的某个位置有**偶数个防具**，那么这个位置就是**毫无破绽的**（包括这个位置一个防具也没有的情况，因为 $0$ 也是**偶数**）。

3. 防线是一维的（也可以理解为是**线性的**）。

4. 因为判断的是**奇偶**所以只需要读入时进行累加再求出**前缀和**后判断**奇偶性**即可。

5. 由于求位置和数量需要从头遍历 但数据范围提醒我们这是一道二分答案的题，一种可行的是**二分防具数量的位置**（$mid$）。


---


题意很好理解，主要是 **数据范围** 和 **防具的奇偶性** 要注意。

综上这题就是一道 **二分答案**和**前缀和** (~~题目标签抄的~~)。


---


## AC Code

```cpp
#include <bits/stdc++.h>
#define N 210000
#define M INT_MAX

const int QWQ=0;

struct LSP{
	int S;
	int E;
	int D;
}Lord[N];

int n;

int Uperr(int res,int x){
  	for(int i=1;i<=n;i++){
    	if(Lord[i].S>x)
			continue;
    	else
    		res+=(std::min(Lord[i].E,x)-Lord[i].S)/Lord[i].D+1;
  	}
  	return res;
}

bool IF(int temp){
	if(!(Uperr(QWQ,temp)&1))
		printf("There's no weakness.\n");
	else
		return true;
	
	return false;
}

int solve(){
	int l=0,r=M,sum;
	while(l<=r){
      	int mid=(l+r)>>1;
      	if(Uperr(QWQ,mid)%2==1)
        	sum=mid,
      	  	r=mid-1;
     	else
     	   	l=mid+1;
    }
    return sum;
}

int ANS(int temp,int ans){
	for(int i=1;i<=n;i++){
      	if(ans>Lord[i].E or ans<Lord[i].S)
		  	continue;
      	else
		  	temp+=((ans-Lord[i].S)%Lord[i].D==0);
    }
    return temp;
}

int main(){
  	int T;scanf("%d",&T);
  	while(T--){
  		int ans;
    	scanf("%d",&n);
    	int MN=INT_MIN;
    	for(int i=1;i<=n;i++){
    		scanf("%d%d%d",&Lord[i].S,&Lord[i].E,&Lord[i].D);
    		MN=std::max(MN,Lord[i].E);
		}
    	if(IF(M)==false) continue;
    	ans=solve();
    	int tmp=0;tmp=ANS(tmp,ans);
    	printf("%d %d\n",ans,tmp);
	}
	return 0;
}
```

---

## 作者：Crab_Tang (赞：0)

Update 2024 年 7 月 16 日更新了错误的 Latex 与中文直接的空格。

## 思路
将防线视作一条直线，将每个可以放置防具的一段视作一个点。

首先，此题有奇数个防具的点（以下简称奇数点）只有一个，所以，这题可以采用前缀和的思想，并且用二分查找具体的点。

~~把`奇数+偶数=奇数`给搞明白了就能想明白了。~~

## 二份查找具体过程

考虑一点 $x$。如果 $x$ 点前面（包括 $x$ 点）防具的个数是奇数，那么说明从 $0$ 到 $x$ 点都有可能是奇数点。

如果 $x$ 点前面（包括 $x$ 点）防具的个数是偶数，那么说明从 $0$ 点到 $x$ 点都不可能是奇数点。

**二分查找痛点：**

注意当 $l,r$ 差 $1$ 时取 $l$ 还是 $r$，取的不当二分会死循环。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int t,n;
struct node{
	int s,e,d;
	int ee;//这组防具的真正右端点 这个求是因为10 11 4这组防具只有10点上有一个防具
}a[N];
long long f(int x){//x位置左边(包括x)有多少个防线
	long long cnt=0;
	for(int i=1;i<=n;++i){
		if(a[i].ee<=x)//（如果x在这组防具的右边）
			cnt+=(a[i].e-a[i].s)/a[i].d+1;//全部都算
		else if(a[i].s<=x)//否则
			cnt+=(x-a[i].s)/a[i].d+1;//只算一部分
	}
	return cnt;
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		unsigned int maxee=0;
		for(int i=1;i<=n;++i){
			scanf("%d %d %d",&a[i].s,&a[i].e,&a[i].d);
			a[i].ee=a[i].s+((a[i].e-a[i].s)/a[i].d)*a[i].d;
			maxee=max(maxee,(unsigned int)a[i].ee);
		}
		unsigned int l=0,r=maxee+1,m;
		while(l<r){
			m=(l+r)>>1;
			if(f(m)&1)//&1相当于%2
				r=m;
			else
				l=m+1;
		}
		if(l==maxee+1)
			printf("There's no weakness.\n");
		else
			printf("%u %lld\n",l,f(l)-f(l-1));//此处的第二个输出也前缀和思想。这个点左边的减去前一个点左边的就是这个点。
	}
	return 0;
}
```

---


# 修复公路

## 题目背景

A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。

## 题目描述

给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。

## 说明/提示

$1\leq x, y\leq N \le 10 ^ 3$，$1\leq M, t \le 10 ^ 5$。

## 样例 #1

### 输入

```
4 4
1 2 6
1 3 4
1 4 5
4 2 3```

### 输出

```
5```

# 题解

## 作者：qwaszx (赞：259)

题解真的是五花八门啊orz

求最小生成树干什么啊难道不是个并查集板子

按时间sort一遍，每次合并两个节点，显然如果原先不连通那么合并之后联通块数量--

然后如果n==1就输出当前时间return

最小生成树放到这里有些浪费了

好像还有人写二分???二分干什么顺序遍历啊

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct hh
{
	int x,y,t;
}a[200000];
int f[200000],n,m;
int cmp(const hh &a,const hh &b){return a.t<b.t;}
int find(int x){return f[x]==x?x:(f[x]=find(f[x]));}
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	n=getin(),m=getin();
	if(n==1){cout<<0;return 0;}//其实并没有什么用的特判
	for(int i=1;i<=m;i++)a[i].x=getin(),a[i].y=getin(),a[i].t=getin();
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++)
	{
		int fx=find(a[i].x),fy=find(a[i].y);
		if(fx!=fy)f[fx]=fy,n--;
		if(n==1){cout<<a[i].t;return 0;}
	}
	cout<<-1<<endl;
    return 0;
}
```

---

## 作者：Euler_Pursuer (赞：111)

我用的方法是**并查集和生成最小树**。

我打算详细地讲一讲。

##并查集

并查集是对树的一种操作，旨在找到某个节点的公共祖先（最老公共祖先）。我们先讲一下并。

###并
并就是讲两个节点合并到一个集合里面（这个集合必须是树），每个节点对应一个祖先，最老公共祖先的祖先就是自己，而每个节点在合并前的初始值也是自己，也就是：若有一个节点$ a $，设它的祖先为$ s[a] $，那么它的初始值就是$ s[a]=a $。这个合并操作并不难，只要判断一下这两个节点是否有祖先，没有就很好办，直接随便连，比如：$ a $和$ b $，他们都没有祖先（也就是祖先是自己），那么就可以$ s[a]=b $了，如果$ s[a] \neq a $，那么就让$ b $的最老祖先（可能是自己）再往上多一个祖先$ s[a] $，此时$ b $的最老祖先也就是$ a $的最老祖先了（不一定是$ a $）。具体算法如下：

```cpp
void together(int *b, int a, int *s)//为了映照上面的说明，a和b就这样弄吧 
{
    if(s[*b]==*b)//a没有祖先时
        s[*b]=a;//令a为b的父亲
    else
        together(&s[*b], a, s);//否则继续找b的祖先，直到b的最老祖先，然后将b的最老祖先的父亲设为a
}
```
###查
有时候我们需要查某个节点的最老祖先是谁，主要是为了下面判断某两个节点的最老祖先是否相同而准备的。假如有这样一组关系：

 ![](https://cdn.luogu.com.cn/upload/pic/10787.png) 

比如我们要找$ 1 $的最老祖先，那么怎么找呢？那么就要通过$ 3 $来找，再往上找，这样的话代码就是：

```cpp
int findfather(int s[], int x) 
{
    if(x!=s[x])//如果不是最老祖先，那么就往上继续找
        x=findfather(s, s[x]);//从上面传过来的参数
    return s[x];//是祖先，就返回最老祖先的值
}
```
但是，这样做的话，会有很多重复工作。比如我刚才找$ 1 $，现在找$ 2 $，那么你就重复搜索了$ 2 $。此时我们就需要**压缩路径**，以便后面查找时更便捷。压缩路径的话，就是在查找的时候，顺带把经过的节点的祖先直接指向最老祖先，那么后面找最老祖先的时候，就一步到位了。代码如下：

```cpp
int findfather(int *s, int x)//*s代表的是直接对s进行操作 
{
    if(x!=s[x])//不是最老祖先
        s[x]=findfather(s, s[x]);//改变其指向，一直往上指，直到最老祖先。
    return s[x];//是最老祖先，返回最老祖先的值
}
```
这种方法十分巧妙，压缩路径之后，查找的速度也会快得多。

##关于本题目

由于题目原本不是树，而是图，而题目又问的是最短修好路得时间，如果是图，那么会有多条路联通两个节点，而其中必定有一条最短时间修好的路，那么最终必定是其中的包含的最小树，所以我们要生成最小树。

##最小生成树之Kruskal算法

这个算法用到的方法是，先将所有边按照权重（此处是时间长短）排序，我是从小到大排序的。排序用到的算法复杂度只能是$ O(nlgn) $以下的，不然会超时。比如快速排序，这些必须学，此处不做赘述。排好序以后，就从权重最小的边开始，因为此时所有节点的祖先值都为自己（也就是所有的节点都是独立的），运用并查集进行**查**的操作，看一下边的左右节点的祖先是否相同，如果最老祖先相同，就代表这两个节点已经在一个树里面了，你再去连这两个节点，就会练成图，所以最老祖先相同则不连，如果有不同的最老祖先，那么就对这两个节点进行

**并**的操作，这样还是树。直到最后，这个算法完毕后，最小树就生成了。最小生成树具体算法如下：

```cpp
int TREE(E *e, int *s)//直接对图和祖先值进行操作
{
    int i, total=0;
    SORT(e, 1, M);//对边进行权重大小排序
    for(i=1;i<=M;i++)
        if(findfather(s, s[e[i].a])!=findfather(s, s[e[i].b]))//是否有相同最老祖先
        {
            together(&s[e[i].a], s[e[i].b], s);//并操作
            total++;//计算节点，为后面查看是否每个村庄都能连通做准备
            ans=e[i].t;//我将ans定义为了全局变量，表示最小树中的最大通路时间
        }
    return total;
}
```
##最后实现

```cpp
#include <iostream>
using namespace std;
int N, M, ans;//全局变量，函数也可以直接用，无需传参数
struct E//图的边 
{
    int a;
    int b;//俩顶点
    int t;//修复时间 
};
//中间忽略一堆函数，上面写了这里就不写了
int main()
{
    int i, j, a, b, c;
    int s[100010];
    E e[100010];
    cin>>N>>M;
    for(i=1;i<=N;i++)
        s[i]=i;
    for(i=1;i<=M;i++)
        cin>>e[i].a>>e[i].b>>e[i].t;
    c=TREE(e, s);//生成最小树，并返回枝干数
    if(c!=N-1)//如果没有将所有村庄连接起来（N个节点的树的枝干数目必须是N-1）
        ans=-1;//则答案为不可能
    cout<<ans;//否则输出生成最小树时处理好的答案
    return 0;
}
```

---

## 作者：Coding__QAQ (赞：72)

很明显，此题是并查集的模板题。

并查集有两种操作——查询，合并。

查询通常用来求联通块中各节点的父节点。

而合并则可统一两点的父节点。

假设我们给出A，B，C，D四个点，并依次给出如下几种操作：

（我们不用刻意在意谁是谁的父亲）

将A与B合并，则A，B的父节点都为A。

将C与D合并，则C，D的父节点都为B。

将B与C合并，此时，A，B，C，D的父节点都为A。

所以这里我们需要用到递归操作；

并查集模板：
```cpp
int find(int x) {//查询操作
  if (x != fa[x])  
    fa[x] = find(fa[x]);  
  return fa[x];
}
void unionSet(int x, int y) {//合并操作
  x = find(x);//其实不用刻意写函数，直接在主函数中写亦可
  y = find(y);
  if (x == y)
    return;
  fa[x] = y; 
}
```
分析此题，因为要判断全部村庄是否能通车，

我们可以用一个变量记录是否全部能修好，

其次我们需要求最短的通车时间，所以需要用sort排一遍序。

最后就可以愉快的AC啦！

附：AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[989898];
struct node{int x,y,t;}e[989898];
bool operator < (node a,node b){return a.t<b.t;}
int find(int x){if(x!=fa[x])fa[x]=find(fa[x]);return fa[x];}
int n,m,num,ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].t);
	sort(e+1,e+1+m);
	for(int i=1;i<=m;i++)
	{
		int x=find(e[i].x),y=find(e[i].y);
		if(x==y)continue;fa[x]=y;num++;ans=max(ans,e[i].t);
	}
	if(num!=n-1)printf("-1\n");else printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Plozia (赞：48)

[博客阅读效果更佳](https://blog.csdn.net/BWzhuzehao/article/details/100147427)

这道题就是并查集的练手好题QAQ

如果对并查集不熟悉的同学可以做一下[这道题](https://www.luogu.org/problemnew/show/P3367)

来看一下题目：

给出A地区的村庄数N，和公路数M，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）

我们可以将这N个村庄看成N个点，其中M是我们要合并的次数。

很明显，修路时间t越早的就要越早合并，**所以要先排序！**(样例中都能看出来)

排序后，按照时间逐个合并，如果合并过程中道路连通，那么输出时间;否则输出-1

但是如果按时间排序，x,y也要跟着动，怎么办呢？**用结构体！**~~结构体不会的可以自行离开了~~

如何判断当前N个点有没有在一个集合内呢？

我们设fa[i]是第i个人的祖先，初始化fa[i]=i，各自是各自的祖先

当合并一次之后，我们扫一遍fa数组，统计fa[i]=i的个数：
1. 如果只有1个fa[i]=i，就说明所有的全部联通了（因为只有1个人是自己的祖先，别的人都跟着他）
2. 如果不止1个，就说明当前没有全部联通（因为两个人互相没有关系），需要继续合并。

时间复杂度可能会有点高，但足够通过本题了。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[1000+10],n,m;
struct node
{
	int x,y,t;
}a[100000+10];//结构体大法好！
bool cmp(node fir,node sec)
{
	return fir.t<sec.t;
}//按照时间排序
int gf(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=gf(fa[x]);
    //这句是路径压缩，前面的题解已经说过，此处不再阐述
}
void hb(int x,int y)
{
	int fx=gf(x);//找到x的祖先
	int fy=gf(y);//找到y的祖先
	fa[fx]=fy;//让fx认fy为祖先
}//合并操作
bool check()
{
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		if(fa[i]==i) sum++;//统计独立集合的个数
		if(sum==2) return 0;//发现有两个就返回false应该会省一点时间
	}
	return 1;//只有1个集合，返回true
}//判断集合个数
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) fa[i]=i;//初始化
	for(int i=1;i<=m;i++) scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].t);
	sort(a+1,a+m+1,cmp);//按时间排序
	for(int i=1;i<=m;i++)
	{
		hb(a[i].x,a[i].y);//进行合并
		if(check())//如果只有1个集合
		{
			printf("%d\n",a[i].t);//输出时间
			return 0;//愉快的结束主程序
		}
	}
	printf("-1\n");//所有公路修完了仍没有联通（集合个数>=2），输出-1
	return 0;//愉快的结束主程序
}
```

---

## 作者：cytheria (赞：15)

####  并查集（~~裸题~~）
下面先介绍一下并查集
顾名思义支持并和查
即1.合并两个元素所在集合
2.查询两个元素是否在同一集合

初始化

~~把自己设为自己的父亲~~
```cpp
for(int i=1;i<=n;i++)
	  f[i]=i;
```
查询（含路径压缩）

不知道怎么形容（~~还是背过吧~~）
```cpp
int find(int x)
{
	return f[x]==x?x:(f[x]=find(f[x]));
}
```
合并

1的祖先修改为2的~~~
```cpp
void hb(int x,int y)
{
	int x1=find(f[x]),y1=find(f[y]);
	f[x1]=y1;
}
```
优化就是路径压缩~~~~

我们一开始找到了x的父亲节点，之后，我们随着（X--->X的祖先）这条路，一直把这条路上的所有节点的父节点都标记为祖先节点。从而加快了查找的速度。（~~来自百~~度）
### 这道题
最小生成树Kruskal

排序找到花费最少的路，查询祖先，不同就连起来
over
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct node{
	int x,y,t;
}a[100006];
int n,m,f[100006];
int cmp(node a,node b)
{
	return a.t<b.t;
}
int find(int x)
{
	return f[x]==x?x:(f[x]=find(f[x]));
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	  scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].t);
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=n;i++)
	  f[i]=i;
	for(int i=1;i<=m;i++)
	{
		int fx=find(a[i].x);
		int fy=find(a[i].y);
		if(fx!=fy) f[fx]=fy,n--;
		if(n==1) 
		{
			cout<<a[i].t;
			return 0;
		}
	}
	cout<<"-1";
	return 0;
}
```




---

## 作者：zpf_13516358919 (赞：12)

几乎是并查集的模板题

将时间按从小到大排序，与kruskal很相似

在某个时间，所有的路都可以连通，就输出结果

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<cmath>
#include<algorithm>
#define LL long long
const int INF=0x7fffffff;
int n,fa[1010];
int m,a,b;
using namespace std;
struct node
{
    int x,y,v;
}q[100010];
bool cmp(const node &a,const node &b)
{
    return a.v<b.v;
}
int find(int x)
{
    if(x!=fa[x])return fa[x]=find(fa[x]);
    return fa[x]=x;
}
bool pd()
{
    for(int i=1;i<=n/2+1;i++)
    if(find(i)!=find(n-i+1))return 0;
    return 1;
}
int main()
{
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&q[i].x,&q[i].y,&q[i].v);
    }
    for(int i=1;i<=n;i++)
    fa[i]=i;
    sort(q+1,q+1+m,cmp);
    for(int i=1;i<=m;i++)
    {
        a=find(q[i].x);
        b=find(q[i].y);
        if(a!=b)
        {
            fa[a]=b;
            if(pd())
            {
                cout<<q[i].v;
                return 0;
            }
//            tot++;
        }
//        if(tot==n-1)break;
//我用了麻烦的判断方法，不过时间上似乎差不多 
    }
    cout<<-1;
    fclose(stdin);fclose(stdout);
    return 0;
}

```

---

## 作者：fletmer (赞：8)

## 楼下各种生成树，然而并不需要，其实就是一个阉割版边带权并查集，和银河英雄传说的差别就是这个题只需要统计集合大小而不需要算到根节点的距离。另外在注意一点，是求最长花费时间，时间不应累加，应该取最大时间。看代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#define SIZE 100050
using namespace std;
int n,m,ans,maxn;
struct poi{
	int x,y,t;
	bool operator<(const poi &a)const{
		return t<a.t;
	}
}s[SIZE];
int fa[SIZE],ty[SIZE];//ty[]就是当前集合大小

inline int rin(){
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=getchar();
	return f*x;
}
inline int getfa(int x){
	if(x==fa[x]) return x;
	return fa[x]=getfa(fa[x]);
}
inline void Merge(int x,int y){
	x=getfa(x),y=getfa(y);
	fa[x]=y,ty[y]+=ty[x];//合并集合更新元素个数
	maxn=max(maxn,ty[y]);//记录集合元素个数为了最后比较是否全部通车
}

int main(){
	n=rin(),m=rin();
	for(int i=1;i<=m;i++){
		s[i].x=rin(),s[i].y=rin();
		s[i].t=rin();
	}
	sort(s+1,s+m+1);
	for(int i=1;i<=n;i++) fa[i]=i,ty[i]=1;
	for(int i=1;i<=m;i++){
		if(getfa(s[i].x)==getfa(s[i].y)) continue;
		Merge(s[i].x,s[i].y);
		ans=max(ans,s[i].t);//时间
	}
	if(maxn!=n) printf("-1");
	else printf("%d",ans);
	
	return 0;
}
```

---

## 作者：Victory_Defeat (赞：6)

# 这题其实就是个裸的最小生成树模板，用Kruskal和Prim算法都没问题。

# 蒟蒻用的是Prim算法，个人认为比较好理解，解释一下：

在一棵树中，首先取出一个节点加入**集合V**，剩下的节点在**集合U**中， 每次寻找**与V中某节点相连的且另一端不在集合V中的代价最小边**，并将其另一端加入集合V。当集合U为空时，最小生成树建立完毕，建树代价为各边权值之和。

（注：**此处加入集合V即意味着离开集合U**）

由于此题求最早通车时间，即意味着求最小生成树中代价最大边，故将+=改成=，另，在输出时要加以特判，判断ans是否为初值，如为初值，输出-1。

下面附上代码：（详见注释）
```cpp
#include<cstdio>
int f[6000][6000],f1[6000],n,m,x,y,z;
//f数组为邻接矩阵，f[i][j]表示i与j之间边的权值
//f1数组为辅助数组，记录当前节点与其他边的权值
bool visit[6000];
//visit数组表示节点是否在集合V中，在为1，不在为0
void prim()
{
	int s=0,ans=0;
	//s表示边数，初始为0
	while(s<n)
	//建立最小生成树
	{
		int minn=1<<30,to=0;
		//minn为所要加入边的权值，to为另一端
		s++;
		//边数+1
		for(int i=1;i<=n;i++)
			if(!visit[i]&&f1[i]<minn)
			{
				minn=f1[i];
				to=i;
			}
		//寻找要加入边
		if(minn!=1<<30)ans=minn;
		//当有符合条件的边时，更新答案
		for(int i=1;i<=n;i++)
            if(f1[i]>f[to][i]&&!visit[i])
                f1[i]=f[to][i];
        //更新f1数组
        visit[to]=1;
        //to加入集合V
	}
	printf("%d",ans==0?-1:ans);
	//输出及特判
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=1<<30;
	//初始为无限大，表示不可达到
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(f[x][y]>z)f[y][x]=f[x][y]=z;
	}
	//仅当权值小于原权值时，更新权值（其实没用）
	for(int i=1;i<=n;i++)f1[i]=f[1][i];
	visit[1]=1;
	//首先将节点1加入集合V（可以加入任一节点）
	prim();
	//建树
}
```

---

## 作者：gxwinnt (赞：5)

本题基本上可以算是Kruskal的模板题了，注意点是：用struct定义边，根据其恢复时间进行排序（sort里面是+边数不是+节点数，粗心错了好多次），用并查集进行判断和合并，在记录答案的时候把tot+=e[i].z改为tot=max（tot，e[i].z）(因为本题只需要在规定时间内可以走通，而不是把时间累加)，最后输出的时候注意判断是否有大于等于节点数-1条边即可。（PS：本题其实和P1119有类似之处，感兴趣的同学可以去试试）。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1050;
const int maxm=100050;
int fa[maxn];
int n,m;
struct node{
    int x,y,z;
}e[maxm];//记得数组大小要开成边数，否则会RE 
int cmp(node a,node b)
{
    return a.z<b.z;
}
int Find(int x)
{
    if(x!=fa[x])return fa[x]=Find(fa[x]);//路径压缩 
    return fa[x];//若本身为集合代表则直接返回 
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)fa[i]=i;//初始化FATHER数组，每个点成为一个集合 
    for(int i=1;i<=m;i++)
    {
        cin>>e[i].x>>e[i].y>>e[i].z;
    }
    sort(e+1,e+1+m,cmp);//对边排序，记得写cmp 
    int num=0,tot=0;
    for(int i=1;i<=m;i++)
    {
        int u=Find(e[i].x),v=Find(e[i].y);
        if(u!=v)
        {
            fa[u]=v;
            num++;
            tot=max(tot,e[i].z);//此处与裸Kruskal不同，记录最大时间而非累加 
        }
    }
    if(num>=n-1)cout<<tot<<endl;//判断是否最少有n-1条边，若有则能走通，否则输出-1 
    else cout<<-1<<endl;
    return 0;
}

```

---

## 作者：阿尔萨斯 (赞：5)

我发现好多巨佬说这题是生成树，我就用并查集试着打了一下，然后我就AC了……话不多说看代码吧！

并查集相关内容在此不赘述了，去看“亲戚”这题吧

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
#define ld long double
using namespace std;
ll read()//快速读入
{
    ll s=0;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        s=s*10+c-'0';
        c=getchar();
    }
    return s;
}
ll zx[100001];//“祖先”，并查集用的
struct kkk//结构体，a，b是路的两端，t是建成的时间
{
	ll a,b,t;
}r[100001];
bool cmp(kkk a,kkk b)//用于排序
{
	return a.t<b.t;
}
ll find(ll x)//找祖先
{
	if(zx[x]==x)return zx[x];
	zx[x]=find(zx[x]);
	return zx[x];
}
void lian(ll x,ll y)//“连”，就是“并查集”中的“并”
{
	zx[find(x)]=find(y);
}
int main()
{
	ll n,m,done=2;//done是已经联通的村庄，从第一对（1,2）算起，如果后面有也暂时不管。反正如果所有的村庄都联通时done就会满了
	n=read();
	m=read();
	for(ll i=1;i<=m;i++)
	{
		r[i].a=read();
		r[i].b=read();
		r[i].t=read();
	}
	for(ll i=1;i<=n;i++)zx[i]=i;
	sort(r+1,r+1+m,cmp);//将修路按时间排序
	for(ll i=1;i<=m;i++)//然后开始逐一修路吧！
	{
		lian(r[i].a,r[i].b);//将修路的两端并起来
		while(find(done)==find(done-1))//如果现在done的村庄对已经联通，就让done往后，继续检测下一对村庄。这是这里的核心思想吧
		{
			done++;
		}
		if(done==n+1)//如果done已经加满了，done应为n+1，当前所有村庄联通，输出结果后结束
		{
			cout<<r[i].t;
			return 0;
		}
	}
	cout<<-1;//什么，前面的ruturn 0没有生效？那必然修补不好了，输出-1吧
    string name="防作弊";
	while(name=="防作弊")cout<<1; 
	return 0;
} 
```

---

## 作者：attack (赞：4)

裸的克鲁斯卡尔啊。。

直接套板子就可以，什么都不用改

至于村子的连通性

我们可以把每个村子都看做一个点

能完全连接n个点的边数就是n-1


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN=1001;
void read(int & n)
{
    char c='+';int x=0;    
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-48;
        c=getchar();
    }
    n=x;
}
int n,m;
struct node
{
    int u,v,w;
}edge[MAXN*100];
int comp(const node & a,const node & b)
{return a.w<b.w;}
int fa[MAXN];
int find(int x)
{
    if(fa[x]==x)
    return fa[x];
    else
    return fa[x]=find(fa[x]);
}
void unionn(int x,int y)
{
    int fx=find(x);
    int fy=find(y);
    fa[fx]=fy;
}
int main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        read(edge[i].u);
        read(edge[i].v);
        read(edge[i].w);
    }
    int tot=0;
    int ans=-1;
    sort(edge+1,edge+m+1,comp);
    for(int i=1;i<=m;i++)
    {
        if(find(edge[i].u)!=find(edge[i].v))
        {
            unionn(edge[i].u,edge[i].v);
            tot++;
            ans=max(ans,edge[i].w);
        }
        if(tot==n-1)
            break;
    }
    if(tot!=n-1)
        printf("-1");
    else
        printf("%d",ans);
    return 0;
}

```

---

## 作者：Sakura_Peng (赞：4)

依旧在练并查集，还是一道模板题吧...

因为求的是最早什么时候路被全部连通，所以我们就可以贪心利用每条路修筑的时间来进行从小到大排序，然后再按照这个顺序把每一条路的两个地点连在一起。

**依据一棵树只有一个根结点的性质：**

每连起一条路之后判断一下是否只有一个结点祖先是他自己，如果只有一个就说明已经全部连在一起了。

代码如下：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
struct CZP
{
	int x,y,z;
}a[1000001];
int n,m,fa[10001];
int cmp(CZP x1,CZP y1)
{
	return x1.z<y1.z;
}
int find(int x)
{
	if (x==fa[x])
	return x;
	else
	fa[x]=find(fa[x]);
	return fa[x];
}  //路径压缩并查集
int pd()
{
	int ans=0;
	for (int i=1;i<=n;i++)
	if (fa[i]==i) ans++;
	if (ans==1)  //如果自己是自己祖先的结点只有一个就说明全部连在一起了
	return 1;
	else
	return 0;
}  //判断是否全部连在一起
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	fa[i]=i;
	for (int i=1;i<=m;i++)
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
	sort(a+1,a+m+1,cmp);
	for (int i=1;i<=m;i++)
	{
		int x1=find(a[i].x),y1=find(a[i].y);
		if (x1!=y1)
		{
			fa[y1]=x1;
		}
		if (pd())
		{
			printf("%d\n",a[i].z);
			return 0;
		}   
   //因为按建造时间从小到大排序，所以如果当前路连好之后就全部连在一起，就说明连这条路的时间就是最后连路的最短总时间（建造每条路同时进行）
	}
	printf("-1");
	return 0;
}
```


---

## 作者：I_Love_DS (赞：2)

## 闲话

本题不难，写了 $15$ 分钟就过了。

## 思路

题解区里好多都是并查集、最小生成树、kruskal 等优秀算法。蒟蒻不才，只会二分和图遍历。

那该怎么办呢？

### 如何二分

设答案在 $(l,r)$ 的范围内，那么存在一个分界线 $mid = (l + r) \div 2$，如果 $mid$ 答案成立，答案范围缩小至 $(l,mid)$，否则如果 $mid$ 答案不成立，答案范围缩小至 $(mid,r)$。最后的答案为 $r$。

### 判断函数

`judge` 函数就是一个 dfs，访问到一个村庄，计数器加 $1$，如果 dfs 结束后计数器为 $n$，那么说明所有的村庄都遍历到了，否则不是。

### 判断是否无解

如果最晚修好的一条路修好后遍历到的村庄数不为 $n$，那么说明无解，输出 `-1`。

### 图的遍历

不用我多说了吧，就是一个模板，直接套就行了。

### 时间复杂度

dfs时间复杂度为 $O(n + m)$，调用了 $\log n$ 次，所以总时间复杂度为 $O(\log n(n + m))$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,cnt = 0,maxtime = 0;//n为村庄数，m为道路数，cnt为访问到的村庄数，maxtime为最晚修好的一条路修好的时间
bool vis[1001];//vis为是否访问过
vector <pair <int,int> > v[1001];//邻接表存图，pair的第一个元素指这个点连着的村庄，第二个元素指这条路修好的时间
void dfs(int x,int t){//模板
	vis[x] = true;//标记为已走过
	cnt++;//计数器加一
	for (auto y : v[x]) if (!vis[y.first] && t >= y.second) dfs(y.first,t);//枚举道路
	return;
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i = 1; i <= m; i++) {
		int x,y,t;
		scanf("%d%d%d",&x,&y,&t);
		v[x].push_back({y,t});
		v[y].push_back({x,t});//存图
		maxtime = max(maxtime,t);//更新时间最大值
	}
	int l = 0,r = maxtime + 1,mid;
	while (l + 1 < r) {//二分
		memset(vis,false,sizeof(vis));
		cnt = 0;
		//多测不清空，爆零两行泪
		mid = (l + r) / 2;
		dfs(1,mid);
		if (cnt == n) r = mid;//答案可行，右边界左移
		else l = mid;//答案不可行，左边界右移
	}
	if (r == maxtime + 1) printf("-1");//不合法输出-1
	else printf("%d",r);//否则输出答案
	return 0;
}
```

---

## 作者：包子入侵 (赞：2)

其实差不多就是一道裸的kruskal ，但还是要注意些问题，不是求和而是边权的最大值，所以我们需要改下需要写个max

还有就是并查集那里需要注意下要压缩下，直接全部指到一点不要每次都遍历

```cpp
#include<cstdio>
#include<algorithm>//头文件
#define N (5001) 
#define M (200001)
using namespace std;
//定义结构体存边，x为起点，y为终点，z为值
struct edge{
    int x,y,z;
}a[M];
int fat[N],tot,ans;//fat[]表示是否在同一并差集 
bool cmp(edge x,edge y){//用于sort的排序，按值排，最小的在前面 
    return x.z<y.z;
} 
int ask(int x){//查找是否在同一集合
         if (fat[x]!=x) fat[x]=ask(fat[x]); 
    return fat[x];//如果他自己的fat不是自己就找fat的fat 
}
void he(int r1,int r2)//合并集合 
{
    int l1=ask(r1);
    int l2=ask(r2);
if (l1!=l2)  fat[l1]=l2;//不在统一集合合并
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);//输入 
    for (int i=1;i<=m;i++) scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);//输入起点终点边 
    sort(a+1,a+m+1,cmp);//把边按从小到大排
    for (int i=1;i<=n;i++) fat[i]=i;//初始化并查集
    for (int i=1;i<=m;i++){
        if (ask(a[i].x)!=ask(a[i].y)){//克鲁斯卡尔
            ans=max(ans,a[i].z);//取最大边 
            he(a[i].x,a[i].y);//合并集合表示已连 
            tot++;//数量 判断是否生成 
        }
    }
    if (tot<n-1) printf("-1");//判断若tot=k-1则生成了最小树
    else printf("%d",ans);//输出 
return 0;
}
```

---

## 作者：ysner (赞：2)

发现楼下的神犇用的都是克鲁斯卡尔算法（并查集），我就给大家另一种思路：Prim算法（求最小生成树的另一种方法），没有用到并查集。

首先，这道题是个裸的最小生成树模板题，与模板的唯一差别是：模板求的是最小生成树的各边的长度之和，而这道题求的是最小生成树的边的最大权。

所以，模板程序改一句话即可A此题（既然是模板就不用解释了吧）：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define fp(i,a,b) for(i=a;i<=b;i++)
#define fq(i,a,b) for(i=a;i>=b;i--)
#define il inline
#define re register
#define ll long long 
using namespace std;
int map[5005][5005]={},dis[100005]={};
bool vis[100005]={};
il int gi()//读入优化
{
  re int x=0;
  re short int t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
  re int i,j,k,n,m,x,y,z,ans=0;
  memset(map,0x3f,sizeof(map));//这是给数组赋极大值的好方法
  n=gi();m=gi();
  fp(i,1,m)
  {
    x=gi();y=gi();z=gi();
    if(z<map[x][y]) map[x][y]=z,map[y][x]=z;
  }
  memset(dis,0x3f,sizeof(dis));
  fp(i,1,n) vis[i]=1;
  dis[1]=0;
  fp(i,1,n)
  {
    k=0;
    fp(j,1,n) if(vis[j]==1&&(dis[j]<dis[k])) k=j;
    vis[k]=0;
    fp(j,1,n) if(vis[j]==1&&(map[k][j]<dis[j])) dis[j]=map[k][j];
  }
  fp(i,1,n) ans=max(dis[i],ans);//把求各边长度之和改为求边的最大权
  if(ans!=1061109567) printf("%d\n",ans);//1061109567=0x3f
    else printf("-1\n");
  return 0;
}

```

---

## 作者：氢氧化铯CsOH (赞：2)

#P1111题解

使用加权并查集，每个根节点记录该集合的元素个数。

首先将道路按修好时间升序排序，然后挨个连接道路。当连接道路后，合并出来的集合元素个数等于总城市数时，说明连通。


（roads数组从0开始编号）

（assert用来防止出现访问非根节点的cnt值的情况）

```cpp
#include<cctype>
#include<cstdio>
#include<algorithm>
#include<cassert>

using namespace std;

const int maxm = 100005;
const int maxn = 1005;

int n, m;

struct Road{
    int from, to, fix_time;
    friend bool operator < (const Road& a, const Road& b){
        return a.fix_time < b.fix_time;
    }
}roads[maxm]; 

inline void setRoad(Road& x, int u, int v, int ft){    // 将x三个成员变量分别设为u、v、ft 
    x.from = u;
    x.to = v;
    x.fix_time = ft;
}



struct UFS{ // （加权）并查集 
    int fa[maxn], cnt[maxn];    // 父亲指针、节点数
    // 注意，当 u 不是并查集森林的根时，cnt[u]未定义 
    int find(int x){
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    
    bool unite(int u, int v){    // 合并操作。当进行该合并操作后返回是否所有的元素都在一个集合内 
        int fu = find(u), fv = find(v);
        if(fu == fv) return cnt[fu] == n;
        
        // 启发式合并。将比较大的集合放前边，然后将较小集合的根节点指向大集合的根节点 
        if(cnt[fu] < cnt[fv]) swap(fu, fv);
        fa[fv] = fu;
        // fu、fv必须是根节点 
        // assert(fa[fu] == fu);
        // assert(fa[fv] == fv);
        return (cnt[fu] += cnt[fv]) == n;
    }
    void init(){
        for(int i = 1; i <= n; i++) fa[i] = i;
        for(int i = 1; i <= n; i++) cnt[i] = 1;
    }
}ufs;

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i++){
        int u, v, ft;
        scanf("%d%d%d", &u, &v, &ft);
        setRoad(roads[i], u, v, ft);
    }
    sort(roads, roads + m);    // 将道路按修好的时间排序 
    ufs.init();    // 并查集的初始化操作 
    for(int i = 0; i < m; i++){
        if(ufs.unite(roads[i].from, roads[i].to)){
            printf("%d\n", roads[i].fix_time);
            return 0;    // 算出答案了，退出 
        }
    }
    puts("-1");
    return 0;
}

```

---

## 作者：46days (赞：2)

n个村庄，m条公路，就是n个点m条边，然后找最小生成树就可以了。

用克鲁斯卡尔。。

并查集维护以及联通的点。

   
   
```cpp
# include <cstdio>
# include <cstring>
# include <cmath>
# include <iostream>
# include <algorithm>
# include <vector>
# include <map>
# include <queue>
# include <stack>
using namespace std;
struct node{
  int x,y,v;
}e[100005];
int fa[100005],num[100005];//并查集 num代表联通集合的大小 
bool cmp(node a,node b)
{
  return a.v<b.v;//时间就是权值
}
int find (int x)
{
  return fa[x]==x?x:fa[x]=find(fa[x]);
}
int main(){
   int n,m;
   cin>>n>>m;
   for (int i=1;i<=m;i++)
   {
        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].v);
   }
   for (int i=1;i<=n;i++) num[i]=1,fa[i]=i;    
   sort(e+1,e+m+1,cmp);
   int T=0;
   for (int i=1;i<=m;i++)
   {
       T=e[i].v;//因为权值从小到大排 最短路中最长时间就是这边的权值 
       int dx,dy;
       dx=find(e[i].x);
       dy=find(e[i].y);
       if (dx==dy) continue;
       if (dx>dy) swap(dx,dy);//我是把小的做fa。。。 
       fa[dy]=dx;
       num[dx]=num[dx]+num[dy];//把两个集合大小合并 
       if (num[dx]==n) {printf("%d",T); return 0;}
   }
   printf("-1");
}

```

---

## 作者：plane (赞：2)

这道题是一道很经典的并查集~~


first~先按每条路修复的时间排序；


then~开始按时间点修路（相当于一次把相同时间的路全部建好）


此题有一个小小的优化，因为每结束一个时间点就需要查询是否n个点成为一个联通块。

so 需要多开一个数组a[i]记录以i为father时 以i为father的点的个数（包括i)【有点绕吖……语死早】


在每次getfather时进行路径压缩（将father[i]变成getfather(father[i])），顺便更新a数组。

合并时也合并a数组。


这样每次只需判断a[getfather(father[1])]是否等于n就行咯。


```delphi



type
  abb=record
  f,t,w:longint;
  end;
var fat:array [0..1001] of longint;
    sum:array [0..1001] of longint;
    a:array [0..100001] of abb;
    i,j,k,l,m,n,p,t:longint;
function getfather(a:longint):longint;
var t:longint;
begin
  if fat[a]=a then exit(a);
  t:=getfather(fat[a]);
  fat[a]:=t;
  sum[a]:=1;
  exit(t);
end;
procedure sort(l,r:longint);
var i,j:longint;
    x,y:abb;
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];
  repeat
    while a[i].w<x.w do inc(i);
    while x.w<a[j].w do dec(j);
    if not(i>j)
    then
      begin
        y:=a[i];
        a[i]:=a[j];
        a[j]:=y;
        inc(i);
        j:=j-1;
      end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
begin
  readln(n,m);
  for i:=1 to n do fat[i]:=i;
  for i:=1 to n do sum[i]:=1;
  for i:=1 to m do readln(a[i].f,a[i].t,a[i].w);
  sort(1,m);
  i:=1;
  while (i<=m) do
    begin
      p:=getfather(fat[a[i].f]);
      t:=getfather(fat[a[i].t]);
      if p<>t then begin fat[p]:=t; sum[t]:=sum[t]+sum[p]; end;
      while (i<m) and (a[i].w=a[i+1].w) do
        begin
          inc(i);
          p:=getfather(fat[a[i].f]);
          t:=getfather(fat[a[i].t]);
          if p<>t then begin fat[p]:=t; sum[t]:=sum[t]+sum[p]; end;
        end;
      p:=getfather(1);
      if sum[p]=n
      then
        begin
          writeln(a[i].w); halt;
        end;
      inc(i);
    end;
  writeln(-1);
end.



```

---

## 作者：QwQ2000 (赞：2)

```cpp

#include <cstdio>
#include <algorithm>
#include <cstdlib>

using namespace std;

struct road {
    int x,y,t;
};

bool operator<(road r1,road r2) {
    return r1.t<r2.t;
}

struct node {
    int prev,n;
};

int n=0,m=0;
node s[1001];
road roads[100000];
int maxx=1;

void init() {
    for (int i=1;i<=n;++i) {
        s[i].prev=0;
        s[i].n=1;
    }    
}

int root(int a) {
    if (s[a].prev==0)
        return a;
    else {
        int i=0;
        int path[1001];
        while (s[a].prev!=0) {
            path[i++]=a;
            a=s[a].prev;
        }
        for (int j=0;j<i;++j)
            s[path[j]].prev=a;
        return a;
    }
}

void merge(int a,int b) {
    int ra=root(a),rb=root(b);
    if (ra==rb)
        return;
    int x=s[ra].n+s[rb].n;
    if (x>maxx)
        maxx=x;
    s[rb].prev=a;
    s[ra].n=x;
}

int main(void) {
    scanf("%d %d",&n,&m);
    for (int i=0;i<m;++i) 
        scanf("%d %d %d",&roads[i].x,&roads[i].y,&roads[i].t);
    sort(roads,roads+m);
    init();
    for (int i=0;i<m;++i) {
        if (maxx==n) {
            printf("%d\n",roads[i-1].t);
            exit(0);
        }
        merge(roads[i].x,roads[i].y);
    }
    printf("-1\n");
    return 0;
}

```

首先 这当然是一道并查集题目了╮(╯▽╰)╭

先按时间排一遍序

用并查集表示村庄的连通情况

在根节点上存储一棵树中有多少个村庄

合并的时候计算 连通的村庄数够不够n

够n就输出当前的时间 不够就继续

然后 我很菜的 不要喷我啊QAQ


---

## 作者：Aehnuwx (赞：1)

这道题我使用的是 $\rm Kruskal$ 求最小生成树。

你可能会质疑我，因为解决这道题确实有更加简便的方法。

但是当我看到这道题时的**第一印象**就是最小生成树。

所以，下面的分析从某种意义上来说，也是我的思考过程。


------------
首先我们来回忆一下，树是什么？

简单上来说，树就是一个有 $n$ 个点，$n-1$ 条边的**连通**图。

这道题目的题面简单来说，就是给了我们 $n$ 个点（**原本互不连通**），有 $m$ 种加边的方案，第 $i$ 种加边方案会在 $t_i$ 时刻加一条 $x_i$ 到 $y_i$ 的无向边，问最早什么时候能使图联通（也就是成为一颗树）。

而生成树就是指一个**连通无向**图的生成子图，同时要求是**树**。

最小生成树即是边权和**最小**的生成树。

那么将最小生成树的定义套到题目中，这题瞬间就变成了最小生成树的裸题。

但是请注意，答案并不是求最小生成树的边权和。

题目问的是最早什么时候任意两个村庄能够通车。

也就是说，$\max \{{\text{加边过程中的}t_i}\}$ 才是最终的答案。

但是因为在使用 $\rm Kruskal$ 前要按边权排序，所以这个求 $\max$ 操作就不要用了。

如果您还没有理解，那我只能上代码了！

$\rm code$

```cpp
# include <bits/stdc++.h>
using namespace std;
# define ll long long
// 之前看错了题，以为是求边权和，所以 define 了一下/kk
const int maxN = 1005;
const int maxM = 100005;
struct Edge {
	int x, y, v;
}a[maxM];
// 存放边
int fa[maxN]; // 祖先
int n, m;
namespace io {
	int read() {
		int x = 0;
		char ch = getchar();
		for(; !isdigit(ch);) ch = getchar();
		for(; isdigit(ch);) x = x * 10 + (ch & 15), ch = getchar();
		return x;
	}
	void write(int x) {
		if(x > 9) write(x / 10);
		putchar(x % 10 + 48);
	}
}
// 快读快输可以不看
namespace ufs {
	void init() { for(int i = 1; i <= n; ++i) fa[i] = i; }
	int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
	void merge(int x, int y) { fa[find(x)] = find(y); }
}
// ufs:Union_Find_Set，并查集的英文，这里把并查集的主要操作都封装到了一个 namespace 里面去
bool cmp(Edge, Edge); // 边权排序函数
int kruskal();
int main() {
// 	freopen("repair.in", "r", stdin);
// 	freopen("repair.out", "w", stdout);
	n = io::read(), m = io::read();
	for(int i = 1; i <= m; ++i) a[i].x = io::read(), a[i].y = io::read(), a[i].v = io::read();
	sort(a + 1, a + m + 1, cmp);
	ufs::init();
    // 输入，排序，初始化
	cout << kruskal();
	return 0;
}
bool cmp(Edge a, Edge b) {
	return a.v < b.v;
}
int kruskal() {
	int ans = 0; // ans 是答案
	int cnt = 0; // cnt 是统计加了多少条边
    // 下面是 Kruskal 的模板
	for(int i = 1; i <= m; ++i) {
		int fx = ufs::find(a[i].x), fy = ufs::find(a[i].y);
    	// 找祖先  
		if(fx != fy) { // 若不是一家
			ans = a[i].v; // 更新 ans
			ufs::merge(fx, fy); // 合并成一家
			++cnt; // 计数器自加 1
			if(cnt == n - 1) return ans; // 如果已经是一棵树了，直接 return
		}
	}
	return -1;
}
```


------------
最终，要感谢 $\rm OI\ Wiki$，让我理解了最小生成树，并且在这篇题解中，也借鉴了其中的思想（~~和语言~~）。

求管理员通过，谢谢qaq

---

## 作者：ajil (赞：1)

跟标签说的一样，用并查集解决

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN(1001), MAXM(100000);
int p[MAXN],rank[MAXN];    //rank是以i为根的节点总数
int n;
struct road
{
    int c1, c2, t;
    road(int a, int b, int t):c1(a), c2(b), t(t){}
    road(){}
}list[MAXM];    //道路信息
bool cmp(const road& a,const road& b)
{
    return a.t < b.t;
}
void init_ufs()
{
    for(int i(1);i<=n;++i)
        { p[i] = i; rank[i] = 1; }
}
int find_root(int x)    //查找根
{
    return p[x] == x ? x : p[x] = find_root(p[x]);
}
void unite_set(int a, int b)    //合并集合
{
    int ar(find_root(a)), br(find_root(b));
    if(ar != br)
    {
        if(rank[ar] > rank[br])
        {
            p[br] = a;
            rank[ar] += rank[br];    //合并时增加以ar为根的节点数
        }
        else
        {
            p[ar] = b;
            rank[br] += rank[ar];
        }
    }
}
int main()
{
    int m;  cin >> n >> m;
    init_ufs();
    for(int i(0);i!=m;++i)
    {
        int c1, c2, t;
        cin >> c1 >> c2 >> t;
        list[i] = road(c1, c2, t);
    }
    sort(list, list + m, cmp);    //按时间的先后顺序排序
    int t(0);
    for(int i(0);i!=m;++i)
    {
        unite_set(list[i].c1,list[i].c2);    ​//合并两点集合
        t = list[i].t;
        if(rank[find_root(1)] == n)
    ​    ​/*    ​当所有村庄打通后
    ​    ​    ​    ​find_root(1) = find_root(2) = ... = find_root(n)
    ​    ​    ​    ​则rank[find_root(1)] = n
    ​    ​    ​    ​没有打通时rank[find_root(1)]一定不等于n
    ​    ​*/
        {
            cout << t;
            return 0;
        }
    }
    cout << "-1";    ​//未打通输出-1
    return 0;
}
```

---

## 作者：intruder (赞：1)

简单的并查集

首先我们需要明确 要使整个图联通 那么至少至少需要填（n-1）条边 那么先sort排序把所有的边从小到大排序，用一个cnt记录 当a，b两个点不连通且此时有一条边可以联通的话，那么就联通 且cnt--更新ans 最后如果判断cnt==1那么输出ans 否则无解





```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#define maxn 100020
using namespace std;
int n,m,fa[maxn],vis[maxn],ans,cnt;
struct Road{
    int a,b,time;
    bool operator <(const Road &a)const{
        return (time)<(a.time);
    }
}road[maxn];
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
void work(int u){
    int x=road[u].a,y=road[u].b;
    int dx=find(x);
    int dy=find(y);
    if(dx!=dy){
        fa[dx]=dy;
        cnt--;
        ans=road[u].time ;
    }
}
int main(){
    scanf("%d%d",&n,&m);
    cnt=n;
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        road[i].a=a;
        road[i].b=b;
        road[i].time=c;
    }
    sort(road+1,road+m+1);
    for(int i=1;i<=m;i++){
        work(i);
    }
    if(cnt==1)
    printf("%d",ans);
    else
    puts("-1");
    return 0;
}
```

---

## 作者：不可喵的 (赞：1)

来安慰p党一下。

非常水的一道并查集。。

首先  将数据（边）从小到大排序

然后一条条边加进去 直到 n中所有的点都在一个集合里（处理到m时仍不能得到 则输出-1）

输出ans即可。。。（注意题目中说的是 Ti 指的是到第Ti 个单位时间可以修好第 i 条路）

一点点注意的地方，就是水了。









```cpp
const maxn=1001;maxm=100001;
var father:array[0..maxn]  of longint;
    root:array[0..maxn] of longint;
    st,en,w:array[0..maxm] of longint;
    n,m,best:longint;
function getfather(i:longint):longint;
  var k:longint;
  begin
    if father[i]=i then exit(i)
    else begin
      getfather:=getfather(father[i]);
      father[i]:=getfather;
    end;
  end;
procedure merge(x,y:longint);
  var i,j:longint;
  begin
    i:=getfather(x);j:=getfather(y);
    if i<>j then begin
      father[j]:=i;
      inc(root[i],root[j]);
      root[j]:=0;
    end;
  end;
procedure sort(l,r:longint);
  var i,j,t,mid:longint;
  begin
    i:=l;j:=r;mid:=w[(l+r) div 2];
    repeat
      while w[i]<mid do inc(i);
      while w[j]>mid do dec(j);
      if j>=i then begin
        t:=w[i];w[i]:=w[j];w[j]:=t;
        t:=st[i];st[i]:=st[j];st[j]:=t;
        t:=en[i];en[i]:=en[j];en[j]:=t;
        inc(i);dec(j);
      end;
    until i>j;
    if i<r then sort(i,r);
    if l<j then sort(l,j);
  end;
procedure init;
  var i,j:longint;
  begin
    readln(n,m);
    for i:=1 to m do begin
      readln(st[i],en[i],w[i]);
    end;
    sort(1,m);//数据排序，从小到大
  end;
procedure main;
  var i,j:longint;
      ok:boolean;
      ans:int64;
  begin
    for i:=1 to n do begin
      father[i]:=i;
      root[i]:=1;//记录以i为根的集合的数个数。
    end;
    i:=0;ans:=0;ok:=false;
    while (root[getfather(1)]<>n) and (i<m) do begin
      inc(i);
      merge(st[i],en[i]);
      if ans<w[i] then ans:=w[i];
      if root[getfather(1)]=n then ok:=true;//判断是否需要输出-1
      if ok then break;
    end;
    if ok then writeln(ans) else writeln(-1);
  end;
  begin
    init;
    main;
  end.

```

---

## 作者：plazum (赞：1)

记录每个集合的城市数……

可以在合并两个集合的时候判断是否连通，理由是（如果可以连通）肯定有某个最后一步合并出了一个城市数为N的集合。

```cpp

#include<cstdio>
#include<algorithm>
using namespace std;
struct edge{
    int x,y,t;
}e[100000];
int n,m,i,p[1001],num[1001];//p for parent
int find_set(int x)
{
    if(p[x]!=x)p[x]=find_set(p[x]),num[x]=num[p[x]];
    return p[x];
}
bool link(int x,int y)
{
    x=find_set(x),y=find_set(y);
    if(x!=y)p[y]=x,num[x]=num[y]+=num[x];
    return num[y]>=n;
}
bool cmp(edge a,edge b){return a.t<=b.t;}
int main()
{
    for(scanf("%d%d",&n,&m);i<m;i++)scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].t);
    sort(e,e+m,cmp);
    for(i=1;i<=n;i++)p[i]=i,num[i]=1;
    for(i=0;i<m;i++)if(link(e[i].x,e[i].y))break;
    printf("%d",i<m?e[i].t:-1);
    
    return 0;
}

```

---

## 作者：凯特琳 (赞：1)

代码比楼下更短。Kruskal。还是手写的快排。ans维护一个最大值。最后搜索一遍，如果所有点的父亲都相同那么输出ans，否则出现某个点的父亲和其他的点不一样，这样就输出-1

```delphi

var father:array[1..1000]of longint;
var i,j,k,n,m,ans,f1,f2,k1,k2,k11,k22,last,ff:longint;
var s,e,len:array[1..1000000]of longint;
procedure qsort(l,r:longint);
var i,j,mid,temp:longint;
begin
i:=l;
j:=r;
mid:=len[(i+j)div 2];
while i<j do
begin
while len[i]<mid do inc(i);
while len[j]>mid do dec(j);
if i<=j then
begin
temp:=len[i];
len[i]:=len[j];
len[j]:=temp;
temp:=s[i];
s[i]:=s[j];
s[j]:=temp;
temp:=e[i];
e[i]:=e[j];
e[j]:=temp;
inc(i);
dec(j);
end;
end;
if l<j then qsort(l,j);
if i<r then qsort(i,r);
end;
function max(aa,bb:longint):longint;
begin
if aa>bb then exit(aa)
else exit(bb);
end;

begin
read(n,m);
for i:=1 to m do
read(s[i],e[i],len[i]);
qsort(1,m);
for i:=1 to n do
father[i]:=i;
ans:=0;

for i:=1 to m do
begin
f1:=s[i];f2:=e[i];
while f1<>father[f1] do f1:=father[f1];
while f2<>father[f2] do f2:=father[f2];
if f1<>f2 then
begin
k1:=s[i];k2:=e[i];
while k1<>father[k1] do begin k11:=father[k1];father[k1]:=f1;k1:=k11;end;
while k2<>father[k2] do begin k22:=father[k2];father[k2]:=f2;k2:=k22;end;
father[k1]:=father[k2];
ans:=max(ans,len[i]);
end;
end;
last:=1;
while last<>father[last] do last:=father[last];
for i:=2 to n do
begin
ff:=i;
while ff<>father[ff] do ff:=father[ff];
if ff<>last then
begin
writeln(-1);
halt;
end;
end;
writeln(ans);
end.

```

---

## 作者：dy0607 (赞：1)

代码比楼下短得多

但不见得好。。。。

时间复杂度（m\*n）

一算刚好能过。。。

可以用数组记录每个集合所包含的元素数量，

在合并两个集合时进行优化，更加保险。

某种意义上算水过去的。。。写的不好见谅

```cpp

#include<cstdio>
#define swap(x,y){int tmp=x;x=y;y=tmp;}
int f[1010],d[1010],m,n;//f数组记录集合的根，d数组记录修好所需时间
void link(int a,int b,int w){
    for(int i=1;i<=n;i++)
        if(f[b]==f[i]&&b!=i)
            f[i]=f[a];//更新被合并集合的每个元素的根
    f[b]=f[a];
    d[f[b]]=w;
}
int main(){
    int i,j,k;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++){
        f[i]=i;
        d[i]=10000000;
    }
    for(i=1;i<=m;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        if(x>y)swap(x,y);
        if(f[x]!=f[y])
            link(x,y,z);
        d[y]=d[y]<z?d[y]:z;//更新时间
        if(f[x]==f[y])
            d[x]=d[x]<z?d[x]:z;//若两点之间已有道路联通，两点时间均需更新
    }
    j=f[1];k=d[1];
    for(i=2;i<=n;i++){
        if(f[i]!=j){//如果发现有元素的根与f[1]不同，说明有多个集合存在
            printf("-1");
            return 0;
        }
        if(d[i]>k&&f[i]!=i)k=d[i];//更新最长时间
    }
    printf("%d",k);
    return 0;
}

```

---

## 作者：上进的z君 (赞：1)

并查集裸题。

首先根据时间点排序。

然后按照时间点进行合并。

对于判断是否达成目标的方法，我是设了一个数组num[i]记录以i节点为根的集合的点数。

当num[i]==n时输出。


```cpp

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;

const int maxn=1010;
const int maxm=100010;
const int INF=1e9;

struct data{
    int x,y,t;
    bool operator <(const data& x) const{
        return t<x.t;
    }
}a[maxm];

int fa[maxn],n,m,num[maxn];

void Build(){
    for(int i=1;i<=n;i++){
        fa[i]=i;
        num[i]=1;
    }
    
    
    return;
}

int Find(int x){
    if(fa[x]==x)return x;
    return fa[x]=Find(fa[x]);
}

void Merge(int x,int y){
    int a=Find(x),b=Find(y);
    
    if(a==b)return;
    
    if(num[a]>num[b]){
        fa[b]=a;
        num[a]+=num[b];
    }
    else{
        fa[a]=b;
        num[b]+=num[a];
    }
    
    return;
}

int main()
{
    //freopen("c.in","r",stdin);
    //freopen("c.out","w",stdout);
    
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].t);
    
    sort(a+1,a+m+1);
    
    Build();
    
    for(int i=1;i<=m;i++){
        Merge(a[i].x,a[i].y);
        
        int x=Find(a[i].x);
        if(num[x]>=n){
            printf("%d\n",a[i].t);
            return 0;
        }
    }
    
    printf("-1\n");
    
    return 0;
}

```

---

## 作者：lightdarkxjt (赞：1)

做的有点麻烦。。。代码挺多名称挺长。。。

```cpp

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
void qs(int,int);    //快排
int ffind(int);      //并查集找树根
bool linker(int,int);//并查集合并
int rcnt(void);      //查有几个树根，假如只有1个就完成了
////////////////////////
int flist[2333];
int tlist[233333];
int trlist1[233333];
int trlist2[233333];
int road;
int val;
int maxtime;
int tempmp=1;
////////////////////////
int main(void)
{
        //输入，初始化
    memset(tlist,0,sizeof(tlist));
    memset(trlist1,0,sizeof(trlist1));
    memset(trlist2,0,sizeof(trlist2));
    scanf("%d %d",&val,&road);
    for(int i=1;i<=val;i++)
        flist[i]=i;
    for(int i=1;i<=road;i++)
        scanf("%d %d %d",trlist1+i,trlist2+i,tlist+i);
        //快排，把最短道路弄出来
    qs(1,road);
        //tlist[road]是最后一个，就是最长的，枚举路程长度连接
        //tempmp是这个k长度的起始点
    for(int k=1;k<=tlist[road];k++)
    {
        for(;tlist[tempmp]==k&&tempmp<=road;tempmp++)
            linker(trlist1[tempmp],trlist2[tempmp]);
        if(rcnt()==1)
        {
            printf("%d\n",k);
            return 0;
        }
    }
    printf("-1\n");
    return 0;
}

void qs(int stp,int edp)
{
    int lp=stp,rp=edp;
    int mid=tlist[(lp+rp)/2];
    while(lp<=rp)
    {
        for(;tlist[lp]<mid;lp++);
        for(;tlist[rp]>mid;rp--);
        if(lp<=rp)
        {
            int t1=trlist1[lp];
            int t2=trlist2[lp];
            int t3=tlist[lp];
            trlist1[lp]=trlist1[rp];
            trlist2[lp]=trlist2[rp];
            tlist[lp]=tlist[rp];
            trlist1[rp]=t1;
            trlist2[rp]=t2;
            tlist[rp]=t3;
            lp++;rp--;
        }
    }
    if(stp<rp)    qs(stp,rp);
    if(lp<edp)    qs(lp,edp);
}

int ffind(int c)
{
    if(flist[c]==c)
        return c;
    else
        flist[c]=ffind(flist[c]);
    return flist[c];
}

bool linker(int x,int y)
{
    int fx=ffind(x);
    int fy=ffind(y);
    if(fx==fy)
        return false;
    flist[fx]=fy;
    return true;
}

int rcnt(void)
{
    int temp=0;
    for(long int i=1;i<=val;i++)
        if(ffind(i)==i)
            temp++;
    return temp;
}


```

---

## 作者：Hexarhy (赞：1)

看起来题解里没多少人用$Prim$算法，我来水一波。

一道好端端的并查集裸题，成了最小生成树？应该是对应$Kruskal$的吧。

方法多种多样，诸君请选择自己最适合的。


------------

$1)$纯并查集，类似联通块？请看他人题解。

$2)$ $Kruskal+$并查集路径压缩，楼下题解很多，不再赘述。

$3)$ 貌似顺序遍历可以过？~~不管了~~不再赘述。

$4)$ $Prim+$堆优化，重点讲讲这个。


------------

思路：

$1)$考虑到是个稠密图，理论上$Prim$会更快。但是，由于各条道路是同时施工，因此**答案应该是时间最大值而非总和**。

$2)$为了保险，优化算法，在每次寻找最小边的时候，采用**堆优化**，就不用$sort$，**程序总时间复杂度**$O(nlogn)$。

$3)$ 对于判$-1$的情况，由最小生成树的性质可知，**一个连通图至少有$n-1$条边**， 因此每次遍历一条边就计数，结尾再判断有没有$n-1$那么多。没有输出$-1$。

$4)$ 对于建图，数据小，随意。包括邻接矩阵。

------------

剩下的都是细节，请看程序：


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;

const int MAXN=100005;
int n,m,ans;
struct node
{
	int to,v;
};
vector <node> edge[MAXN];
bool visit[MAXN];
int cnt;

void input(void)
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,t;
		cin>>x>>y>>t;
		edge[x].push_back((node){y,t});
		edge[y].push_back((node){x,t});//无向图
	}
}

struct cmp//重载堆用的
{
	bool operator()(const node& x,const node& y)const
	{
		return x.v>y.v;
	}
};

void prim(void)
{
	priority_queue <node,vector<node>,cmp> q;//堆优化
	visit[1]=true;//以1为起点
	for(vector<node>::iterator it=edge[1].begin();it!=edge[1].end();it++)
	 q.push(*it);
	while(!q.empty())//按照模板来就行
	{
		const node tmp=q.top();
		q.pop();
		if(visit[tmp.to])
		 continue;
		visit[tmp.to]=true;
		ans=max(ans,tmp.v);//注意是求最大值
		cnt++;//计数答案，看有没有n-1
		for(vector<node>::iterator it=edge[tmp.to].begin();it!=edge[tmp.to].end();it++)
		 if(!visit[it->to])
		  q.push(*it);
	}
}

void output(void)
{
	if(cnt<n-1)//cnt用处体现了
	{
		cout<<-1;
		return;
	}
	cout<<ans;
}

int main()
{
	input();
	prim();
	output();
	return 0;
}
```

---

## 作者：薛裕龙 (赞：1)

基本思路：用结构体来保存两个村庄和时间，并通过时间用sort从小到大排列结构体，并从最小的开始连接村庄。之所以这么做，是因为这道题的时间具有**重叠性**。它是能在 t 时完成，而不是要用 t 这么多时间，要注意审题。先上代码慢慢讲：



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct zhu{
    int u,v,w;
}e[100010];
int fa[1010];
int cmp(const zhu &a,const zhu &b)
{
    return a.w<b.w;
}
int find(int k)
{
    return k==fa[k]?k:fa[k]=find(fa[k]);
}
int main()
{
    int n,m,t,i,w;     
 //w我是取得wrong的首字母，意思是有多少个不同的集合，只有当这w为0时，才是连接完成（为什么这么做，被第二个点超时搞疯的小伙伴下面应该看仔细了），t是指现在我要用多少时间了
    cin>>n>>m;
    w=n;
    for(i=1;i<=m;i++)
    {
        cin>>e[i].u>>e[i].v>>e[i].w;
    }
    sort(e,e+m+1,cmp);       //排列结构体，通过时间从小到大排列
    for(i=1;i<=n;i++)
    fa[i]=i;
    for(i=1;i<=m;i++)
    {
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y)
        {
            fa[x]=y;
            t=e[i].w;
            w=w-1;     //如果连接了一次，那么表示不同w的就会-1，这对于两个集合之间的连接也实用
        }
        if(w==0)break;     //当没有不同的，就不用连了
    }
    int ok=2;
    if(i<=n-1)          //此处的i的值当然是我的边枚举到第几个了，当边没有到n就退出来了，当然我绝对是连接完了，也就不用再判点了。
    cout<<t;
    else{
        for(int i=1;i<=n;i++)
    {
        if(find(i)==i)
        {
            ok=ok-1;
        }
        if(!ok)break;
    }
    if(ok)cout<<t;
    else cout<<"-1";
    }
    return 0;
}
```

---

## 作者：huangyizhan (赞：1)

跑一边PRIM,0,1标记，最后若全为1则输出最小生成树边的最大值，否则输出-1

```cpp
###var n,m,i,j,k,x,y,t,ans:longint;
###a:array[1..1000,1..1000] of longint;
###flag:array[1..1000] of boolean;
###dist:array[1..1000] of longint;
###begin
###read(n,m);
###for i:=1 to m do begin read(x,y,t);  a[x,y]:=t;a[y,x]:=t; end;
###for i:=1 to n do dist[i]:=maxlongint;
###flag[1]:=true;
###k:=1;
###for i:=1 to n-1 do
###begin
###for j:=1 to n do
###if (a[k,j]<>0) and (not flag[j])then  if a[k,j]<dist[j] then dist[j]:=a[k,j];
###t:=maxlongint;
###for j:=1 to n do
###if (dist[j]<t)  and (not flag[j]) then begin t:=dist[j];k:=j; end;
###flag[k]:=true;
###if t>ans then ans:=t;
###end;
###for i:=1 to n do if not flag[i] then begin write('-1'); halt; end;
###write(ans);
end.
```

---

## 作者：漫雨轻飘 (赞：0)

## 这道题判断时间的时候一定要注意各种边界的问题，，卡了好久
```
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;

bool flag = false; //用来判断是否已经联通,初始状态为未联通
const int N = 100010;
int father[N]; //用来存储每一个村庄的父亲结点
void Union(int x, int y);
void init(int n);
int findFather(int x);
struct Node
{
    int x, y, t;
} node[N];

bool cmp(Node a, Node b)
{
    return a.t < b.t;
}

int main()
{
    int n, m;
    int tempfather;
    cin >> n >> m;
    init(n); //初始化
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &node[i].x, &node[i].y, &node[i].t);
    }
    sort(node + 1, node + m + 1, cmp);
    int lastonenow = 0; //用来储存当前时间相同的元素的右边界
    int timenow = 0;
    int temp;
    while (1)
    {

        lastonenow++;
        temp = lastonenow;                                                      //用来储存当前时间相同的元素的左边界
        timenow = node[lastonenow].t;                                           //临时储存当前的时间                                                      //储存当前同一时间的左边界
        while (node[lastonenow + 1].t == node[lastonenow].t && lastonenow <= m) //不能越界
        {
            lastonenow++; //如果当前指向的结点的下一个结点的时间等于当前指向的结点，指向下一个结点
        }
        //timenow = node[lastonenow].t;
        for (int i = temp; i <= lastonenow; i++)
        {
            Union(node[i].x, node[i].y);
        }
        tempfather = findFather(1);
        for (int i = 2; i <= n; i++)
        {
            if (findFather(i) == tempfather)
                flag = true;
            else
            {
                flag = false;
                break; //如果出现了两个不同的根节点，跳出循环
            }
        }
        if (flag) //如果当前所有的都联通了
        {
            cout << timenow << endl;
            break; //所有的都联通了，输出临时存储的时间，跳出死循环
        }
        if (lastonenow == m)
        {
            break;
        }
    }
    if (!flag) //如果这时候还是没有联通
        cout << "-1" << endl;
    return 0;
}

void init(int n)
{
    for (int i = 1; i <= n; i++)
    {
        father[i] = i; //每一个村庄的父亲结点初始化为它自己
    }
}

void Union(int x, int y)
{
    int faX = findFather(x);
    int faY = findFather(y);
    if (faX != faY)
    {
        father[faX] = faY; //将x的父亲结点设置为y的父亲结点，达到合并的目的
    }
}

int findFather(int x)
{
    int temp = x; //先临时储存x
    while (father[x] != x)
    {
        x = father[x];
    }                         //这里先找到x的父亲结点
    int temp2 = father[temp]; //temp2用来临时存储temp的父亲
    while (father[temp2] != temp2)
    {
        temp2 = father[temp2];
        father[temp] = x; //压缩
        temp = temp2;
    }
    return x;
}
```

---

## 作者：JasonZRY (赞：0)

这道题水的一批

不就是最小生成树吗？

最小生成树：[我的博客](https://www.luogu.org/blog/666Jason/solution--p3366)

把orz换成-1,把l换成maxn求最大路径就好了。

详细代码（Kruskal）：

```
//以下代码涉及并查集，不懂的童鞋可以先了解一下 
#include<bits/stdc++.h>
using namespace std;
struct edge{
    int fr,to,len;
}ed[200005];
//用结构体来存储每条边的头、尾和权值 
int n,m,x,y,z,cnt,maxn,fa[5001];
bool cmp(edge a,edge b){
    return a.len<b.len;
}
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
//并查集函数*1
void merget(int x,int y){
    int fx=find(x),fy=find(y);
    if(fx!=fy)fa[fx]=fy;
}
//并查集函数*2
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)fa[i]=i;                       //初始化 
    for(int i=1;i<=m;i++){
        cin>>ed[i].fr>>ed[i].to>>ed[i].len;                                   //读入数据
    }
    sort(ed+1,ed+m+1,cmp);                              //排序，找到权值小的边 
    for(int i=1;i<=m;i++){
        if(cnt==n-1)break;                              //如果点数枚举完了就跳出循环 
        if(find(ed[i].fr)==find(ed[i].to))continue;     //如果这两点在一个集合内就跳过 
        merget(ed[i].fr,ed[i].to);                      //把这条边的一头一尾合并 
        maxn=max(maxn,ed[i].len);                                   //最长边长度 
        cnt++;                                          //计数器+1 
    }
    if(cnt==n-1)cout<<maxn;                                //如果满足条件就输出长度 
    else cout<<-1;                                   //不然就输出-1
    return 0;
} 
```

# 完美地结束

---

## 作者：Xing_Mang (赞：0)

    楼顶上dalap们都用Kruskal
    本蒟蒻对此麻木不仁愣是只想到了并查集
    肉眼可见需要按时间顺序把道路进行排序，再逐个遍历道路，并在每次访问的时候将连通两个村庄判断一下是否连通了整个村庄就行了，当然，每次重新判断连通有点难受，所以维护一个整数num,表示编号一到编号num已经连通了，这样如果遍历到最后num比村庄数要小，就是无解。
    PS.find，theSame,init,unite这些并查集标准函数写完了其实没几行内容，

  代码如下：
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
using namespace std;
struct node{
	int x,y,t;
};
const int MAX_N=1005,MAX_M=100005;
int P[MAX_N];
int K[MAX_N];
node D[MAX_M];
void init(int n){
	for(int i=1;i<=n;i++){
		P[i]=i;K[i]=0;
	}
}
int find(int x){
	if(P[x]!=x)return P[x]=find(P[x]);else return x;
}
void unite(int x,int y){
	x=find(x);y=find(y);
	if(x==y)return;
	if(K[y]<K[x])P[y]=x;
	else{
		P[x]=y;
		if(K[x]==K[y])K[y]++;
	}
}
bool theSame(int x,int y){
	return find(x)==find(y);
}

bool cmp(const node& a,const node& b){
	return a.t<b.t;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	init(n);
	for(int i=0;i<m;i++){
		cin>>D[i].x>>D[i].y>>D[i].t;
	}
	sort(D,D+m,cmp);//°´Ê±¼äË³ÐòÅÅÁÐµÀÂ· 
	int num=1;
	for(int i=0;i<m;i++){
		node& a=D[i];
		unite(a.x,a.y);
		while(theSame(num,num+1))num++;  
		if(num>=n){printf("%d",a.t);return 0;}
	}
	printf("%d",-1);
}
```

  


---

## 作者：THOOOR (赞：0)

第一次晚上刚学了并查集，试着写第一篇题解。
目前还只会用C语言写，真的太菜。
```
思路：
1）方案按时间从小到大排序；
2）按时间从1到最长时间循环：
	a)如果当前时间点有路修好，
    则合并该两个城市所在的集合；
   b)检查城市1所在集合的城市数量，
    如果等于n，则找到最短时间；
```


因为要查询集合中城市数量，
所以采用**按集合中包含元素个数的方式**合并


```c
#include <stdio.h>
#include <stdlib.h>
#define MAX 1005
#define MMAX 100005

typedef struct Graph //储存点和时间
{
    int a, b;
    int v;
}Gra;

int n, m；
int tim = -1; //记录最早通路时间
int num = 1;  //记录修路进度
int uset[MAX];
Gra G[MMAX];

//并查集模板 参考[](https://www.cnblogs.com/cyjb/p/UnionFindSets.html)
void MakeSet()
{
    for (int i = 1; i <= n; i++)
    {
        uset[i] = -1;
    }
}

int Find(int x)
{
    if (uset[x] < 0)
    {
        return x;
    }
    else
    {
        uset[x] = Find(uset[x]);
        return uset[x];
    }
}

void UnionSet(int x, int y)
{
    x = Find(x);
    y = Find(y);

    if (x == y)
    {
        return;
    }

    if (uset[x] > uset[y])
    {
        uset[x] += uset[y];
        uset[y] = x;
    }
    else
    {
        uset[y] += uset[x];
        uset[x] = y;
    }
}

//对修路方案排序，用快排能过，选择排序有几个测试点会TLE
void Sort(int l, int r)
{
    int i=l;
    int j=r;
    int mid=G[(l+r)/2].v;
    Gra temp;
    while (i<j)
    {
        while (G[i].v<mid) i++;
        while (G[j].v>mid) j--;
        if (i<=j)
        {
            temp=G[i];
            G[i]=G[j];
            G[j]=temp;
            i++;
            j--;
        }
    }
    if (l<j) Sort(l,j);
    if (i<r) Sort(i,r);
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &G[i].a, &G[i].b, &G[i].v);
    }

    Sort(1, m);	//修路方案排序
    
    MakeSet();

    for (int i = 1; i <= G[m].v; i++) // i记录当前时间
    {
        while (G[num].v == i) //同一时间点可能有多条路修好
        {
	   		  UnionSet(G[num].a, G[num].b);
           //-uset[Find(1)]代表1所在集合的城市数量
           if ((-uset[Find(1)]) == n) 
           {
              tim = i;
              break;
           }
           num++;
           }
        }
    }

    printf("%d\n", tim);
    return 0;
}
```


---

## 作者：HPXXZYY (赞：0)

一、储备算法

**1、并查集（为最小生成树准备）**

**2、贪心（为最小生成树准备）**

**3、最小生成树（主算法）**

二、思路：既然要最早通车，那么肯定要**将修复时间t从小到大排序**（贪心），然后直接上最小生成树！！！

三、代码（额额额，没有缩进哦！）：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
const int M=100100;
int tot,t,n,m,i,j,f[1010];
//数组最好开大10~1000，空间上无太大所谓
struct node{
    int x,y,v;
    bool operator < (const node &a) const{
        return v<a.v;
    }
    //重定义<号，为排序准备
    void read(){
        scanf("%d%d%d",&x,&y,&v);
    }
    //输入
}a[M];
int getf(int x){
    if (f[x]==x) return x;
    else return f[x]=getf(f[x]);
}
//并查集
bool merge(int a,int b){
    a=getf(a);b=getf(b);
    if (a==b) return false;
    f[b]=a;return true;
}
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++) a[i].read();
    for(i=1;i<=n;i++) f[i]=i;
    sort(a+1,a+m+1);
    for(i=1;i<=m;i++)
    if (merge(a[i].x,a[i].y)){
        tot=max(tot,a[i].v);
        //与标准最小生成树唯一的不同
        t++;if (t==n-1) break;
    }
    //最小生成树
    if (t==n-1) printf("%d\n",tot);
    else puts("-1");
    return 0;
}
```
四、谈谈万能头（bits/stdc++.h）：

noip系列竞赛中说：“**理论上**允许使用万能头”，但选手要为全责（万一不能用，那就liangliang咯），所以大家平时可以用用，但考试最好别用！

---

## 作者：spsp23 (赞：0)

萌新的第一篇题解，大佬勿喷。

说实话，
我并不认为这道题要用**~~最小生成树。~~**

## 只需要并查集。

# 一重循环，复杂度**O（m）**;
大佬们已经解释得很清楚了，我来说一波自己的思路。

长话短说，放代码
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[200005],n,m,s=0;
struct pp{
  int a,b,c;//a:边首,b:边尾,c:时间;
};
pp t[200005];
bool cp(pp p,pp q){//按时间排序。
  return p.c<q.c;
}
int gets(int x){//并查集模板。
  if(x==fa[x]) return x;
  return fa[x]=gets(fa[x]);
}
void add(int x,int y){
  fa[gets(x)]=gets(y);
}
int judge(int x,int y){//是否为同一个祖先。
  int x1,x2;
  x1=gets(x);
  x2=gets(y);
  if(x1==x2)
    return 1;
  return 0;
} 
int main(){
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++){
    fa[i]=i;
  }
  for(int i=0;i<=m;i++) t[i].c=0x3f;
  for(int i=1;i<=m;i++)
    scanf("%d%d%d",&t[i].a,&t[i].b,&t[i].c);
  sort(t+1,t+m+1,cp);//**注意，从t+1**
  for(int i=1;i<=m;i++){
    if(!judge(t[i].a,t[i].b))//是否在同一个集合。
    {add(t[i].a,t[i].b);s++;if(s==n-1) {cout<<t[i].c;return 0;}}   
  }
  cout<<"-1";
  return 0;
}
```


---

## 作者：dlydly (赞：0)

一道**Kruskal算法**裸题，可以用**利用**并查集做  

**Kruskal算法**：
Kruskal算法是一种用来查找[最小生成树](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)的算法，由Joseph Kruskal在1956年发表。
用来解决同样问题的还有[Prim算法](https://baike.baidu.com/item/Prim/10242166?fromtitle=Prim%E7%AE%97%E6%B3%95&fromid=10986864)和Boruvka算法等。三种算法都是贪心算法的应用。
和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。

先来讲述一下并查集

并查集是描述**不相交集合的数据结构**，并支持对这些不相交集合进行**合并**、**查找**操作。  
因此并查集主要就是两个操作：  
1.合并操作  
2.查找操作  
 代码如下
 ```cpp
 int find(int x) {
	return x==fa[x] ? x: fa[x]=find(fa[x]);
}//查找操作

 void join(int x,int y) {
	if(find(x)!=find(y)) fa[find(y)]=find(x);
}//合并操作
 ```
 所以需要如下方案  
1、对图的所有边按照权值大小进行排序。  
2、将边添加到最小生成树中时，判断是否形成了回路。  
排序就不用说了  
判断是否形成了回路，正是并查集的强项  
只需把合并操作修改为
```cpp
bool join(int x,int y) {
	if(find(x)!=find(y)) {
		fa[find(y)]=find(x);
		return 1;
	}
	return 0;
}//判断是否形成了回路
```
具体代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[100005],n,m;
struct weizi {
	int x,y,sum;
} a[100005];
int find(int x) {
	return x==fa[x] ? x: fa[x]=find(fa[x]);
}
int join(int x,int y) {
	if(find(x)!=find(y)) {
		fa[find(y)]=find(x);
		return 1;
	}
	return 0;
}
int cmp(weizi a,weizi b) {
	return a.sum<b.sum;
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=m; i++)cin>>a[i].x>>a[i].y>>a[i].sum;
	sort(a+1,a+1+m,cmp);
	for(int i=1; i<=n; i++)fa[i]=i;
	int count=0;
	for(int i=1; i<=m; i++) {
		if(join(a[i].x,a[i].y)) {
			count++;
		}
		if(count==n-1) {
			cout<<count<<' '<<a[i].sum<<endl;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```
简单来说，Kruskal算法就是利用了贪心原理，把点的权值排序，然后利用并查集判断是否形成回路，由此求解


---

## 作者：Gae_Blog (赞：0)

****快速排序+并查集

- 结构体储存每条边

- 自定义一个cmp函数，按照时间顺序排列结构体下标，使顺序遍历时间从早到晚。

- 直接顺序并查集加边，合并过程中把子集的总点数相加（>合并过程保证没有重复），判断是否等于总点数，即合并得到的并查集中是否包含所有点

- 若此时此集中（不重复的）点数量等于总点数，则输出此时时间

代码如下：

    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxx 1010
using namespace std;
int n,m,fa[maxx],du[maxx],rank[maxx];
struct node{
    int u,v,t;
}a[100010];
void makeset(int size)
{
    for(int i=1;i<=size;i++) {
    fa[i]=i;
    du[i]=1;
    rank[i]=0;
    }
}
bool cmp(node o,node p)
{
    return o.t<p.t;
}
int find(int i)
{
    if(fa[i]!=i) fa[i]=find(fa[i]);
    return fa[i];
}
void unionset(int x,int y)
{
    x=find(x);
    y=find(y);
    if(x==y) return ;
    if(rank[x]>rank[y])
      {
          fa[y]=x;du[x]+=du[y];
      }
    else{
        fa[x]=y;
        if(rank[x]==rank[y]) rank[y]++;
        du[y]+=du[x];
    }
}
int main()
{
    freopen("in.txt","r",stdin);
    scanf("%d%d",&n,&m);
    makeset(n);
    for(int i=1;i<=m;i++)
      {
          scanf("%d%d%d",&a[i].u,&a[i].v,&a[i].t);
      }
    sort(a+1,a+m+1,cmp);
    int flag=0;
    int i=1;
    for(i=1;i<=m;i++)
      {
          unionset(a[i].u,a[i].v);
          int h=find(a[i].u);
        if(du[h]==n) 
            {
                flag=1;
                printf("%d",a[i].t);
                break;
            }
      }
    if(flag==0) cout<<-1;
    return 0;
}
```

---

## 作者：nkoi18 (赞：0)

二分+并查集

二分出最小时间，对每一个时间开一个并查集记录当前道路的联通情况

全部联通的话它们的祖先是公共的

另外先判一下t=100000时是否可行，不行输出-1

具体细节代码里讲

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int n,m; 
int father[2000];
struct node{
    int x;
    int y;
    int t;
}b[100001];//储存边
bool cmp(node o,node p)
{
    return o.t<p.t;
```
}//排序
```cpp
int getf(int k)
{
    if(father[k]==k)
     return k;
    father[k]=getf(father[k]);
    return father[k];
}
bool pd(int k)
{
    for(int i=1;i<=n;i++)
      father[i]=i;
    for(int i=1;b[i].t<=k&&b[i].t!=0;i++)
      {
          int f1=getf(b[i].x);
          int f2=getf(b[i].y);
          if(f1!=f2)
            father[f1]=f2;
      }
    int g=getf(1);
    for(int i=2;i<=n;i++)
      if(getf(i)!=g)
        return 0;//若检查到有点的祖先不同，则不联通，返回0
    return 1;
}
int ef(int l,int r)//丑陋的二分
{
    int mid=(l+r)/2;
    if(l==r)
      return l;
    if(l+1==r)
      if(pd(l))
        return l;
      else
        return r;
    if(pd(mid))
      r=mid;
    else
      l=mid+1;
    return ef(l,r);
} 
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
      scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].t);
    sort(b+1,b+m+1,cmp);
    if(!pd(100000))//特判
      {
          cout<<"-1";
          return 0;
      }
    cout<<ef(1,100000);  
    return 0;
}
```

---

## 作者：司徒stuart (赞：0)

其实差不多就是一道裸的kruskal 注意一下ans不是和 而是使所有点都联通时时间的最小值

还有就是 大家一定要细心QAQ即使是写板子的时候

如果你看我的提交记录就会发现 我因为把sort写在了输入前边导致WA了好多次

我还一脸懵比的改

细心最重要 细心最重要 细心最重要！！！

注释都在代码里了

···
 
 
```cpp
#include<bits/stdc++.h>  
#define MAXN 200100
using namespace std;
int father[MAXN],ans=0;
int flag[MAXN],n,m,tot,bis;
struct edge{
    int from,to;
    int value;
};edge Edge[MAXN];//存边 
bool cmp(edge x,edge y)//比较函数的cmp 
{
    return x.value<y.value;
}
int Find(int x)
{
    if(father[x]!=x)
    {
        father[x]=Find(father[x]);//路径压缩 
    }
    return father[x];
}
void Union(int x,int y)//合并 
{
    int fx=Find(x),fy=Find(y);
    if(fx!=fy)
    {
        father[fx]=fy;
    }
}
void init()
{
    memset(flag,1,sizeof(flag));
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        father[i]=i;
    }
    for(int i=1;i<=m;i++)
    {
        cin>>Edge[i].from>>Edge[i].to>>Edge[i].value;
    }    
        sort(Edge+1,Edge+m+1,cmp);//按照时间从小到大排序 
}
void out()
{
        for(int i=1;i<=n;i++)
    {
        if(flag[i])//如果有一个点没在树中 也就是flag[i]=1 的时候 说明无法通车 输出-1 
        {
            cout<<"-1"<<endl;
            return ;
        }
    }
    cout<<ans<<endl;
    return ;
}
void work()
{
    for(int i=1;i<=m;i++)
    {
        int a=Edge[i].from,b=Edge[i].to;
        if(Find(a)!=Find(b))//当两个点不在一个集合中的时候 合并 
        {
            ans=max(ans,Edge[i].value);
            Union(a,b);
            flag[a]=0,flag[b]=0;//每当合并一个点 就flag[i]=0 
        }
    }
}
int main()//主程序 
{
    init();
    work();
    out();
    return 0;
 } 
···
```

---

## 作者：Michael_Li (赞：0)

克鲁斯卡尔

裸的最小生成树的版子，不多说，看ac代码注解。

```cpp
#include<cstdio>
#include<algorithm>
#define N (1000+10) 
#define M (100000+10)
using namespace std;
struct edge{
    int x,y,z;
}a[M];//定义每条边为一个结构体，方便排序
int fa[N],tot,ans;
bool cmp(edge x,edge y){
    return x.z<y.z;
} //排序的cmp，不多说
int ask(int x){
    if (fa[x]==x) return x;
    fa[x]=ask(fa[x]); return fa[x];
```
}//并查集的精髓，和以前打的Pascal版的还是有差别，重点解释一下，fa表示父亲，father的简写，很好懂，然后ask表示最远能追溯到的祖先，我最远能追溯到的祖先等于我爹最远能追溯到的祖先，最后把值赋给fa[x]，这句话叫路径压缩，使得我下一次再找的时候可以直接找到祖先，大大压缩了时间复杂度，是并查集的精髓所在。
```cpp
void unite (int x,int y){
    int x1=ask(x),x2=ask(y);
    if (x1==x2) return;
    else fa[x1]=x2;
```
}//合并，注意不是合并这两个点，而是把两个点所在的并查集合并。
```cpp
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
    sort(a+1,a+m+1,cmp);//最小生成树的克鲁斯卡尔算法，先按边权排序，再利用贪心。
    //for (int i=1;i<=m;i++) printf("%d %d %d\n",a[i].x,a[i].y,a[i].z);
    for (int i=1;i<=n;i++) fa[i]=i;
    for (int i=1;i<=m;i++){
        if (ask(a[i].x)!=ask(a[i].y)){
            tot++;
            ans=max(ans,a[i].z);//注意这个时间是所有时间中的最大值
            unite(a[i].x,a[i].y);//取完这条边之后，合并两个端点
        }
    }
    if (tot<n-1) printf("-1");
    else printf("%d",ans);
}
克鲁斯卡尔应该是最小生成树的最简单最常用的方法，希望本篇题解能对大家有所帮助，谢谢。
```

---

## 作者：封二少 (赞：0)

裸的并查集

先以修路的时间从小到大排序

将村庄看作是点，道路为边

求的是瓶颈生成树。

利用prim或者kruskal求出最小生成树，最大的边权就是答案。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n, m, k, ans, f[1000086];
struct point
{
    int x;
    int y;
    int v;
};
point a[1000086];
inline long long get()
{
    char ch;
    long long res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch != '-')
      res = ch - '0';
    char c;
    while ((c = getchar()) >= '0' && c <= '9')
      res = (res << 3) + (res << 1) + c - '0';
    return ch == '-' ? ~res + 1 : res;
}
void put(long long x)
{
    if (x < 0)
      putchar('-'), x = ~x + 1;
    if (x > 9) put(x / 10);
      putchar(x % 10 + '0'); 
}
int cmp(const point &a, const point &b)
{
    if (a.v < b.v) return 1;
      else return 0; 
}
int find(int x)
{
    if (f[x] != x) f[x] = find(f[x]);
    return f[x];
}
int main()
{
    n = get(); m = get();
    for (int i = 1; i <= m; ++i)
    {
        a[i].x = get(); a[i].y = get(); a[i].v = get(); 
        if (a[i].x > a[i].y) swap(a[i].x, a[i].y);
    }
    sort(a + 1, a + m + 1, cmp);
    for (int i = 1; i <= n; ++i) f[i] = i;
    for (int i = 1; i <= m; ++i)
    {
        int a1 = find(a[i].x),
            a2 = find(a[i].y);
        if (a1 != a2)
        {
            k++;
            if (a[i].v > ans) ans = a[i].v;
            f[a1] = a2;
        } 
        if (k == n - 1)
        {
            put(ans);
            return 0;
        }
    } 
    put(-1);
    return 0;
}
```

---

## 作者：随悦 (赞：0)

裸的并查集。  先根据完成时间排个序，然后从小到大合并点

每合并一个点就相当于多一个点被联通，给tot-1

tot为1时，说明所有点已连接，推出循环。

一开始没注意不连通的情况……

判定最后如果tot不是1，说明没连完，输出-1



>var n,m,i,tot,t,xx,yy:longint;



```cpp
    x,y,z:array[0..100000]of longint;
    fa:array[0..1000]of longint;
procedure qsort(xx,yy:longint);
var i,j,m,t:longint;
begin
    i:=xx; j:=yy; m:=z[(xx+yy)div 2];
    repeat
          while z[i]<m do inc(i);
          while z[j]>m do dec(j);
          if i<=j then begin
              t:=z[i];z[i]:=z[j];z[j]:=t;
              t:=x[i];x[i]:=x[j];x[j]:=t;
              t:=y[i];y[i]:=y[j];y[j]:=t;
              inc(i);dec(j);
          end;
    until i>j;
    if i<yy then qsort(i,yy);
    if xx<j then qsort(xx,j);
end;
function gf(x:Longint):longint;
begin
    if fa[x]=x then exit(x);
    fa[x]:=gf(fa[x]);
    exit(fa[x]);
end;
begin
    readln(n,m);
    for i:=1 to m do begin
        readln(x[i],y[i],z[i]);
    end;
    qsort(1,m);
    for i:=1 to n do fa[i]:=i;
    tot:=n;
    for i:=1 to m do begin
        xx:=gf(x[i]); yy:=gf(y[i]);
        if xx<>yy then begin
            dec(tot);
            t:=z[i];
            fa[xx]:=yy;
            if tot=1 then break;
        end;
    end;
    if tot <>1 then writeln(-1) else
    writeln(t);
end.
```

---


# [蓝桥杯 2024 国 Python B] 切木棒

## 题目描述

给定 $n$ 根木棒，第 $i$ 根木棒的长度为 $L_i$。

每次你可以选择任意一根木棒并将其切成两段，切完后两段的长度都必须为整数。被切成两段的木棍也可以被选择继续切成两段。

请问，如果一共切 $m$ 次，在所有的方案中，切完后木棒中最长的一根最短是多少？

## 说明/提示

### 评测用例规模与约定

- 对于 $60\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 3 \times 10^5$，$1 \leq m, L_i \leq 10^9$。

## 样例 #1

### 输入

```
3 3
3 4 6```

### 输出

```
3```

# 题解

## 作者：dendky (赞：5)

## 思路

看见题目求最长的最短，考虑二分答案。二分中的 $mid$ 即为最长木棍的最小值，只需用 $\left \lceil \frac{a_i}{mid} \right \rceil $ 挨个计算一遍，求出修改次数判断是否小于等于 $m$ 即可。最后输出左边界为答案。

注意：如果 $a_i \bmod mid = 0 $ 那么修改次数要减一，因为在这种情况下最后一刀会砍空，就是没砍到。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, a[300005];
bool check(int x) {
    int sum=0;
    for (int i=1; i<=n; i++) {
        sum+=a[i]/x;
        if (a[i]%x==0) sum--;
    }
    return sum>m;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	cin>>n>>m;
    for (int i=1; i<=n; i++) cin>>a[i];
    int l=1, r=1e9;
    while (l<=r) {
        int mid=l+r>>1;
        if (check(mid)) l=mid+1;
        else r=mid-1;
    }
    cout<<l;
	return 0;
}
``````

---

## 作者：Clare613 (赞：5)

## 思路：
二分答案，二分木棍的长短，这里讲一下 $\operatorname{check}$ 函数怎么写。\
我们只需要把每一根木棍切成长度不大于 $mid$ 的长度，要求把次数算出来，就是正常切 $a_i$ 除以 $mid$ 刀，如果整除就可以少切一刀，最后次数要小于等于 $m$ 即可。\
为什么如果整除就可以少切一刀？我们可以想，如果不整除，那么就会有一串不超过 $mid$ 的长度的木棍，而整除就是最后一根为 $mid$ 的情况。
## code：
```cpp
#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;
int a[300005];
int n,m;
bool check(int x){
	int q=0;
	for(int i=1;i<=n;i++){
		q+=a[i]/x;
		if(a[i]%x==0) q--;
	}
	return q<=m;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int l=1,r=1e9;
	while(l<r){
		int mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<r;
	return 0;
}
```

---

## 作者：chen_kun (赞：4)

# P12269 [蓝桥杯 2024 国 Python B] 切木棒题解

## 思路简述

看到最大值最小，很快就能想到这是一道二分答案。二分函数的内容十分简单，重要的是 $\operatorname{check}$ 函数里的内容。

其实也并没有很难。既然每次切割出的长度要小于 $mid$ 值，那么我们就可以用木棍 $a_i$ 除以 $mid$，它们的除数就是切割这根木棍所需要的次数。然后我们开一个变量 `tot` 把切割的次数记录起来，再判断切割的次数是否小于或等于 $m$ ，若满足则代表最长木棍的长度还可以更小，反之最长木棍的长度太短了要变长。

还有一个细节。当木棍 $a_i$ 可以整除 $mid$，此时切割这根木棍的次数将是它们的商减一。因为如果可以整除最后一次切割刚好切到这根木棍的末尾，则切割这一次没有意义了。

## 代码实现


```python
def check(a, x, m):
    tot = 0
    for num in a:
        tot += num // x #累加切割次数
        if num % x == 0:
            tot -= 1 #可以整除则次数减一
    return tot <= m

def GG_bound(a, m, l, r):
    ans = 0
    while l <= r:
        mid = (l + r) // 2
        if check(a, mid, m):
            r = mid - 1 #如果切割的次数小于m则木棍可以更短
            ans = mid
        else:
            l = mid + 1
    return ans

n, m = map(int, input().split())
a = list(map(int, input().split()))
max_a = max(a) if a else 0
print(GG_bound(a, m, 1, 10**18))
```
### The end.

---

## 作者：zhaokeyu123 (赞：3)

## 思路
简单二分答案，我们只需要在每次二分时统计需要切多少刀，使最长的木棍长度不超过 $mid$，并判断所切刀数是否大于 $m$ 即可，细节详见代码注释。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[300005];
bool check(int x)
{
	int cnt=0;
	for(int i=1;i<=n;i++)
	{
		cnt+=a[i]/x;
		cnt-=(a[i]%x==0?1:0);//如果能整除要少减一次
	}
	return cnt<=m;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	int l=1,r=1e9,ans=0;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(check(mid))
		{
			r=mid-1;//往左遍历
			ans=mid;
		}
		else l=mid+1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：mairuisheng (赞：3)

[P12269 [蓝桥杯 2024 国 Python B] 切木棒](https://www.luogu.com.cn/problem/P12269)

算法：二分

分析：

本题答案具有单调性，故使用二分。

二分的区间为 $[l,r)$，$l=1$，$r=\max(L_1,L_2\dots L_n)$。

检查函数的写法：

我们检查的是切完 $m$ 次后木棒中最长的一根最短的长度不超过 $mid$，为了尽可能实现目标，我们切割 $\lfloor\frac{L_i}{mid}\rfloor$ 次，每一段的长度都为 $mid$，这样得到的木棒长度都不超过 $mid$；

另外，当 $L_i$ 整除 $mid$，就可以少切一次，即 $\lfloor \frac{L_i}{mid} \rfloor -1$ 次。

最后累加判断即可。

`Python` 代码实现：

```python
import sys

def main():
    data=list(map(int, sys.stdin.read().split())) #快读 
    ptr=0
    n=data[ptr]
    ptr+=1
    m=data[ptr]
    ptr+=1
    
    a=[0]
    ans=0
    for u in range(n):
        num=data[ptr]
        ptr+=1
        a.append(num)
        ans=max(ans,num)
    
    lt,rt=1,ans
    def check(d): #check函数 
        cnt=0
        for p in a[1:]:
            quotient=p//d
            remainder=p%d
            cnt+=quotient
            if remainder==0:cnt-=1
            if cnt>m:return False
        return True
    
    while lt<rt: #二分 
        mid=(lt + rt) // 2
        if check(mid):rt=mid
        else:lt=mid+1
    
    print(lt)

if __name__ == "__main__":
    main()

```

---

## 作者：Charged_Charge (赞：1)

# 洛谷 P12269
## 解题思路：
这是一道二分答案，二分最短的木棒的长度。讲一讲判断部分。不难想到，如果要切成的长度是总长度的因数，那么他切割的次数就应该比不是因数的长度要少一次，因为他不会有边角料。现在，代码就好写了。
## AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e5+20;
int n, m;
int a[N];
int l, r, mid;
bool check(int x) {
	int sum = 0;
    for(int i = 1; i <= n; i++){
        if(a[i] % x == 0){
            sum += a[i] / x - 1;
        }else{
            sum += a[i] / x;
        }
    }
    return sum <= m;
}

signed main() {
	cin >> n >> m;

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
        r = max(r, a[i]);
	}

	l = 1;

	while (l <= r) {
		mid = (l + r) >> 1;

		if (check(mid)) {
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}

	cout << l;
	return 0;
}
```

---

## 作者：Forge_Unique (赞：1)

## 思路

本题答案满足单调性，可以二分搜索答案，搜索变量为切完后木棒中最长的一根的最短长度。

从 $1$ 到 $1 \times 10 ^ 9$ 搜索，搜索条件为 `check` 函数。

`check(x)` 表示最小长度为 $x$ 的最少切割数量是否 $\le m$。我们只需枚举所有木棍，将这个木棍最多切割次数计入 $sum$，最后判断 $sum$ 是否 $\le m$ 即可。 

## 代码

其余细节见代码。

[c++ 代码](https://www.luogu.com.cn/paste/mzxdi7b9)。

[python 代码](https://www.luogu.com.cn/paste/odg5e8om)。

---

## 作者：Innate_Joker (赞：1)

# [P12269 [蓝桥杯 2024 国 Python B] 切木棒 题解](https://www.luogu.com.cn/problem/P12269)

> 虽然是 `OIer` ，可还是用 `Python` 写一下吧。

> `OIer` 们，你永远不要小看 `Python` 的 `input()`，如果你是初次使用，你一定会因为这个调半天。~我就因此调了半个小时。~

## 思路

### 二分架构
可以从题目描述中找到一个关键句 `最长的一根最短是多少` 可以看出是二分答案。模板二分答案，不会很难吧？先想一下使用哪种结构，如果当前 `mid` 是可能答案，那么就应该把他放在右端点，然后先更小的可能的答案二分。否则，排除当前这个数，向更大的可能的答案二分，得出结构为:

```python
left = 1
right = 10**9
while left < right:
    mid = (left + right) // 2
    if check(mid):
        right = mid
    else:
        left = mid + 1
# left 为左端点， right 为右端点， mid 为当前可能的答案。
```

然后题目问的是木棍的 “最长的一根最短是多少”，所以我们将二分木棍的长度。

### check 函数

我想，这才是二分答案做法最重要的一步。因为切的次数是有限制的，所以我们可以通过判断切的次数的方法判断当前可能的答案是否合规。我们希望每根木棍的长度小于等于 `mid`，那么我们就通过 `l[i] // mid` 来获取当前这个木棍切割成 `mid` 的长度的最小次数，然后统计最后判断然后返回一个布偶值。

```python
def check(key):
    cut_total = 0
    for num in range(0, n):
        cut_total = cut_total + l[i] // key
        if l[i] % key == 0:
            cut_total = cut_total - 1;
    if cut_total > m :
        return False
    else:
        return True
```

## 最终代码

```python
def check(key):
    global n, m, l
    cut_total = 0
    for num in range(0, n):
        cut_total = cut_total + l[num] // key
        if l[num] % key == 0:
            cut_total = cut_total - 1;
    if cut_total > m :
        return False
    else:
        return True

if __name__ == '__main__':
    input_string = input()
    number_list = [int(num) for num in input_string.split()]
    n = number_list[0]
    m = number_list[1]
    input_string = input()
    number_list = [int(num) for num in input_string.split()]
    l = {}
    for const in range(0, n):
        l[const] = number_list[const]
    left = 1
    right = 10**9
    while left < right:
        mid = (left + right) // 2
        if check(mid):
            right = mid
        else:
            left = mid + 1
    print(right)
```

---

## 作者：kuaiCreator (赞：1)

## 解题思路
看到求最大值最小，考虑二分答案。

切割次数越多，则最长的木棍长度可以越短，具备单调性。二分答案的思路可行。

因此二分最长木棍的长度 $d$，验证时对于原第 $i$ 根长度为 $l_i$ 的木棍，需要切割的次数为 $\Large\frac{l_i}{d}$，但是若 $d\mid l_i$ 说明 $d$ 能够整除 $l_i$ 那么少切一次，因为刚好整除时，最后一刀切在木棍边缘。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5+5;
int n, m, l[N];
bool check(int mid) {
	int cut = 0;
	for (int i = 1; i <= n; i++) {
		cut += l[i] / mid;
  		if (l[i] % mid == 0) cut--; //重点：能整除的话少切一次
	}
	return cut <= m;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> l[i];
	int l = 1, r = 1e9, ans;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(mid)) {
			ans = mid;
			r = mid - 1;
		} else l = mid + 1;
	}
	cout << ans;
  return 0;
}
```

---

## 作者：luoxuexiaoxiao (赞：0)

## P12269 [蓝桥杯 2024 国 Python B] 切木棒 题解

### Problem

有 $n$ 根木棒，每次你可以选择任意一根木棒并将其切成两段，切完后两段的长度都必须为整数，求切 $m$ 次的所有方案中切完的木棒中最长的一根最短是多少。

### Solution
看到最长的一根最短直接二分答案做就完了，好像洛谷有一车和这个题一模一样的。


考虑 check 函数怎么写。

令当前试的答案为 $x$，那么每一段木棒要切 $\frac{l_i}{x}$ 下，如果 $l_i$ 是 $x$ 的倍数就是切 $\frac{l_i}{x} - 1$ 下，枚举木棒，把切的次数加起来判断是否小于等于 $m$ 即可。

注意初始二分左边界不能写 $0$，因为除以 $0$ 会 RE，显然答案为 $1$ 一定有解，所以二分左边界可以写 $1$。

时间复杂度为 $O(n \log V)$，$V$ 为值域。
### Code
给出 Python 代码实现。

```python
def main():
  a = input().split()
  n, m = int(a[0]), int(a[1])
  a = list(map(int, a[2:]))
 
  l = 1
  r = 10**18
  ans = 0
 
  while l <= r:
    mid = (l + r) >> 1
    if sum([(i - 1) // mid + 1 for i in a]) <= m:
      ans = mid
      r = mid - 1
    else:
      l = mid + 1
 
  print(ans)

if __name__ == '__main__':
  main()
```

---

## 作者：yanzixuan2024 (赞：0)

这种有条件限制而让求最大最小答案的题目就要用二分答案。

下界为 $1$，上界为最长的木棍长度，二分切完后木棒中最长的一根最短的长度。遍历所有木棒，计算将每根木棒切割成不超过 $mid$ 长度所需的切割次数总和。若总和不超过 $m$，则调整上界为 $mid$；否则调整下界为 $mid+1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    vector<int>L(n);
    int r=0;
    for(int i=0;i<n;++i){
        cin>>L[i];
        r=max(r,L[i]);
    }
    int l=1;
    int ans=r;
    while(l<=r){
        int mid=l+(r-l)/2;
        long long tot=0;
        bool f=true;
        for(int li:L){
            if(li>mid) tot+=(li-1)/mid;
            if(tot>m){f=false;break;}
        }
        if(f) ans=mid,r=mid-1;
        else l=mid+1;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：AnOIer (赞：0)

## Solution

二分答案。

考虑二分木棍的长短，check 函数检查答案是否可以不大于 $mid$，把切的次数计算出来判断是否小于等于 $m$ 即可。

当 $L_i$ 是 $mid$ 倍数时，次数加上 $\frac{L_i}{mid}-1$，否则加上 $\lfloor\frac{L_i}{mid}\rfloor$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[300010],l=1,r;
bool check(int x) {
	int res=0;
	for(int i=1;i<=n;i++) {
		res+=(a[i]%x==0?a[i]/x-1:a[i]/x);
	}
	return res<=m;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		r=max(a[i],r);
	}
	while(l<r) {
		int mid=l+r>>1;
		if(check(mid)) {
			r=mid;
		}else {
			l=mid+1;
		}
	}
	cout<<r;
	return 0;
}
```

---

## 作者：Suite_No1_G (赞：0)

看到最大值最小，容易联想到二分算法。

假设当前二分到的值是 $x$。由于是求一个最小的最大值，所以当 $x$ 合法时，我们在更小的数中二分，否则在更大的数中二分。

由于当前最长的木棍长度为 $x$，那么长度大于 $x$ 的都需要被切割。我们可以想到每次长度到 $x$ 时切一次。我们通过简单计算发现，对于长度为 $a_i$ 的木棍，需要切割 $a_i$ 除以 $x$ 次。

但是我们忽略了一种情况：假设木棍长度为 $6$ 且最大长度为 $3$，那么我们其实只需要切割一次。所以，当 $a_i$ 可以整除 $x$ 时，需要切割的次数会减一。

最后，把切割次数的总和跟 $m$ 比较，如果小于等于 $m$ 则当前答案合法。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=3e5+10;
int a[maxn];
int n,m;

bool check(int x){
	int cnt=0;
	for (int i=1;i<=n;i++){
		if (a[i]<=x) continue;
		cnt+=a[i]/x;
		if (a[i]%x==0) cnt--;
	}
	
	return cnt<=m;
}

signed main(){
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
	
	int l=1,r=1e9+7;
	int ans=1e9+7;
	while (l<=r){
		int mid=(l+r)/2;
		if (check(mid)){
			ans=mid;
			r=mid-1;
		}else l=mid+1;
	}
	
	printf("%lld\n",ans);
	return 0;
} 
```

---

## 作者：ylzpl (赞：0)

本题算法：二分。  
由于数据特别的大，所以我们可以考虑二分。  
- 为啥可以用二分？因为本题让我们求：切完后木棒中最长的一根最短是多少？看到最短一词，我们就可以想到二分。
- 如何使用二分。我们在定义范围之前先看数据范围，$1≤L_i≤10^9$，因此，我们的 $lt=1,rt=10^9$，因为长度最少是 $1$。你见过长度为 $0$ 的东西吗？那么，有了范围，我们二分的东西就是切完后木棒中最长的一根最短长度。
- 什么时候答案成立？我们需要注意，题目说可以切 $m$ 次，那么我们可以计算次数。当 $a_i \bmod x=0$ 时，说明长度是 $x$ 的倍数，那么只需要切 $\frac{a_i}{x}-1$ 次。当 $a_i \bmod x>0$ 时，说明长度不是 $x$ 的倍数，那么只需要切 $\frac{a_i}{x}$ 次。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=3e5+5;
int n,m;
int a[maxn];
bool check(int x){
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=a[i]/x;
		if(a[i]%x==0){
			ans--;
		}
	}
	return ans<=m;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i]; 
	}
	int lt=1,rt=1e9;
	while(lt<rt){
		int mid=(lt+rt)/2;
		if(check(mid)){
			rt=mid;
		}
		else{
			lt=mid+1;
		}
	}
	cout<<rt;
	return 0;
}
```
注意：$lt$ 的初始值要设为 $1$，不然 $95$ 分。

---


# [KOI 2021 Round 2] 累计距离

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国是一个由 $N$ 个村庄构成的国家，这些村庄分布在数轴上。其中第 $i$ 个村庄（$1 \leq i \leq N$）位于位置 $x_i$，并有 $a_i$ 名居民。不会有两个不同村庄位于相同的位置。

KOI 国计划召开一场所有国民都要参加的大会。为此，所有人需要前往会议举办地点，所有人前往该地点所需的移动距离之和称为“累计距离”，我们用 $f(x)$ 表示当会议举办地点为 $x$ 时的累计距离。

住在第 $i$ 个村庄的人前往位置为 $x$ 的会议地点时，需要移动的距离为 $|x_i - x|$。由于第 $i$ 个村庄有 $a_i$ 名居民，因此该村居民所需的总移动距离为 $a_i \times |x_i - x|$。

将所有村庄的该值加总，即可得到在位置 $x$ 举办会议时的累计距离：

$$
f(x) = \sum_{i=1}^{N} a_i \times |x_i - x|
$$

例如，若村庄的位置为 $x_1 = 1$、$x_2 = 3$、$x_3 = 6$，各村庄的居民数分别为 $a_1 = 2$、$a_2 = 1$、$a_3 = 3$，当会议地点为 $x = 4$ 时，累计距离为：

$$
f(4) = 2 \times |1 - 4| + 1 \times |3 - 4| + 3 \times |6 - 4| = 13
$$

KOI 国已经准备了 $Q$ 个会议地点候选位置。第 $j$ 个候选位置（$1 \leq j \leq Q$）为 $q_j$。多个候选位置之间不会重复，但候选位置可能与某个村庄位置相同。

请编写程序，计算每一个候选会议地点 $q_j$ 的累计距离 $f(q_j)$。

## 说明/提示

**约束条件**

- $1 \leq N \leq 200\,000$
- 对于所有 $i$（$1 \leq i \leq N$），$1 \leq a_i \leq 1\,000$
- 对于所有 $i$，$-10^9 \leq x_i \leq 10^9$
- $1 \leq Q \leq 200\,000$
- 对于所有 $j$，$-10^9 \leq q_j \leq 10^9$
- 对任意 $1 \leq i_1 < i_2 \leq N$，$x_{i_1} \ne x_{i_2}$（村庄位置各不相同）
- 对任意 $1 \leq j_1 < j_2 \leq Q$，$q_{j_1} \ne q_{j_2}$（候选位置各不相同）
- 所有给定数值均为整数

**子任务**

1. （9 分）$N,Q \leq 5\,000$
2. （21 分）对所有 $i$，满足 $1 \leq x_i \leq 200\,000$，且对所有 $j$，满足 $1 \leq q_j \leq 200\,000$
3. （25 分）对所有 $i$，$a_i = 1$
4. （45 分）无额外约束条件

## 样例 #1

### 输入

```
3 1
2 1
1 3
3 6
4```

### 输出

```
13```

## 样例 #2

### 输入

```
4 5
3 -4
1 -10
2 11
4 6
6
-5
1
-12
14```

### 输出

```
56
84
66
144
116```

# 题解

## 作者：Sunrise_up (赞：4)

代码目前是最优解。

## 一、问题本质：给数轴上的点找“中心点”

想象你有一堆糖果散落在数轴上，每个糖果堆有不同的数量。现在要选一个位置开派对，让所有糖果堆的搬运距离总和最小。这就是本题的核心——**在数轴上找一个点，使得所有点到它的加权距离之和最小**。

栗子：比如有三个糖果堆，位置分别是 $1$、$3$、$6$，数量是 $2$、$1$、$3$。选在位置 $4$ 时，总距离是 $2×3 + 1×1 + 3×2 = 13$，怎么快速算出这个结果呢？

## 二、暴力解法：简单直接但会爆

最容易想到的做法是：  **对于每个候选点，遍历所有村庄计算距离之和**。  

但这最大需要 $(2\times 10^5)^2= 4×10^{10}$ 次计算，妥妥超时！这就像用勺子舀干大海，虽然直接但不现实。

## 三、优化思路：排序+前缀和

### 1. 排序便于处理
首先将所有村庄按位置排序。比如排序后变成 $1,3,6$，这样每个候选点 $q$ 可以将村庄分成两部分：  
- 左边：位置 $\le 1$ 的村庄。
- 右边：位置 $> q$ 的村庄。

### 2. 前缀和
- **居民数前缀和 $sa$**：$sa_i$ 表示前 $i$ 个村庄的居民总数。  
  比如 `sa[2] = 2+1 = 3`（前两个村庄的人数总和）。  
- **位置加权前缀和 $sax$**：$sax_i$ 表示前 $i$ 个村庄的 $a_i\times x_i$ 总和。  
  比如 $sax_2 = 2×1 + 1×3 = 5$（对于样例 $1$）。  

这两个数组后续计算可以直接使用，避免重复计算。

### 3. 二分查找
对于候选点 $q$，用二分查找找到第一个位置大于 $q$ 的村庄索引 $r$。这样：  
- 左边有 $r$ 个村庄（索引 $0$ 到 $r-1$）。
- 右边有 $n-r$ 个村庄（索引 $r$ 到 $n-1$）。  

### 4. 数学公式：分左右计算总距离
- **左边总距离**：每个村庄到 $q$ 的距离是 $q - x_i$，总和为 $q\times sa_r - sax_r$（相当于用 $q$ 乘以总人数，减去位置加权和，得到总距离）。
- **右边总距离**：每个村庄到 $q$ 的距离是 $x_i - q$，总和为 $(sax_n - sax_r) - q\times(sa_n - sa_r)$（相当于用位置加权和减去 $q$ 乘以总人数）。

总距离即为两边距离之和。

## 四、代码实现

[AC 记录](https://www.luogu.com.cn/record/220091913)

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+1;
int n,q,a[N],x[N],sa[N],sax[N];
inline int rd(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}//快读
signed main(){
    n=rd(),q=rd();
    for(int i=1;i<=n;i++)a[i]=rd(),x[i]=rd();
    vector<int> p(n);
    for(int i=0;i<n;i++)p[i]=i+1;
    sort(p.begin(),p.end(),[&](int i,int j){return x[i]<x[j];});//这样就可以不使用结构体，快很多
    for(int i=0;i<n;i++){
        int j=p[i];
        sa[i+1]=sa[i]+a[j],sax[i+1]=sax[i]+a[j]*x[j];
    }//前缀和优化
    while(q--){
        int qr=rd(),l=0,r=n;
        while(l<r){
            int m=l+r>>1;
            if(x[p[m]]>qr)r=m;
            else l=m+1;
        }//二分
        printf("%lld\n",qr*sa[l]-sax[l]+sax[n]-sax[l]-qr*(sa[n]-sa[l]));
    }
}
```

## 五、复杂度分析

- **排序**：$O(N \log N)$，一次排序解决所有后续查询。  
- **前缀和**：$O(N)$，线性时间预处理。  
- **每个查询**：$O(\log N)$，二分查找的时间复杂度。  
- **总复杂度**：$O(N \log N + Q \log N)$，对于 $N=2\times 10^5$ 和 $Q=2\times 10^5$，完全可以在  $1$ 秒内完成。

## 六、常见错误与避坑指南

1. **数据类型溢出**：  
   居民数和位置都是整数，乘积可能很大，必须用 `long long`。  

2. **二分查找边界错误**：  
   确保找到的是第一个大于 $q$ 的位置，而不是大于等于。例如，当 $q$ 等于某个村庄位置时，该村庄应被划分到左边。  


如果觉得有用的话就点个赞吧！

---

## 作者：Ghosty_Neutrino (赞：3)

## 题意
数轴上有 $N$ 个村庄，每个村庄位于位置 $x_i$，有 $a_i$ 个居民。对于每个查询位置 $q_i$，计算所有居民到 $q_j$ 的累计距离 $f(q_j) = \sum_{i=1}^N a_i \times |x_i - q_j|$。
## 分析
根据绝对值的性质，可以得到两种情况：
* 当 $x_i \leq q$ 时，$|x_i - q| = q - x_i$。
* 当 $x_i > q$ 时，$|x_i - q| = x_i - q$。

累计距离可拆分为两部分计算：
$$
f(q) = \sum_{x_i \leq q} a_i (q - x_i) + \sum_{x_i > q} a_i (x_i - q)
$$

预处理这两部分的前缀和，就能快速计算累计距离，所以接下来我们就来预处理一下这两个部分。

首先将村庄按位置 $x_i$ 升序排序。排序后，所有村庄的位置形成有序序列，便于后续二分查找分割点。

定义数组 $suma$，$suma_k$ 表示前 $k$ 个村庄的居民总数。再定义数组数组 $sumxa$，$sumxa_k$ 表示前 $k$ 个村庄的 $a_i x_i$ 总和。

接下来用二分查找分割点，使用二分查找找到第一个满足 $x_i \geq q$ 的村庄下标 $k$。此时前 $k$ 个村庄的位置均 $< q$，如果 $x_k = q$，则包含在左边或右边都行。从 $k$ 到 $N-1$ 的村庄位置均 $\geq q$。

于是我们可以累计距离啦，分左右分别计算，左边有 $k$ 个村庄，右边有 $N-k$ 个村庄。最后把左右两边的距离加起来就行了。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,q,k;
ll o,l,r;
struct D{
    ll x,a;
    bool operator<(const D&w)const{return x<w.x;}
};
int main() {
    ios::sync_with_stdio(false);//快读快写启动，我怕炸TLE
    cin.tie(nullptr); 
    cin>>n>>q;
    vector<D> v(n);
    for(int i=0;i<n;i++) cin>>v[i].a>>v[i].x;
    sort(v.begin(),v.end());
    vector<ll> suma(n+1,0);//前i个村庄的a总和
    vector<ll> sumax(n+1,0);//前i个村庄的a*x总和
    for(int i=0;i<n;i++){
        suma[i+1]=suma[i]+v[i].a;
        sumax[i+1]=sumax[i]+v[i].a*v[i].x;
    }
    for (int i=0;i<q;i++){
        cin>>o;
        k=lower_bound(v.begin(),v.end(),D{o,0})-v.begin();//二分查找第一个x>=q的村庄下标
        l=o*suma[k]-sumax[k];//左边的距离
        r=(sumax[n]-sumax[k])-o*(suma[n]-suma[k]);//右边的距离
        cout<<l+r<<endl;
    }
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：3)

# 题意简述
一共有 $n$ 个村庄，第 $i$ 个村庄位置是 $x_i$，一共有 $a_i$ 个人。要求给定一个位置 $x$，求在位置 $x$ 举办会议时所有人行走的累计距离。 $\\$
说白了就是询问若干次，每次给定一个数 $x$，让我们求以下式子：
$$\sum_{i=1}^{n} a_i \times |x_i - x|$$
# 思路
## 大致思想
首先分析数据规模，$1\le n,q\le 200000$，暴力枚举显然不行。这时候我们需要思考有没有什么能高效解决此问题的方法。通过观察不难发现，村庄里的人位置都各不相同，如果挨个枚举村庄，统计村庄里的人，那效率就会非常低下。所以，我们可以让所有人都先汇聚在一个位置，然后在计算。具体来说，就是将所有人的行走距离改变了一下计算方式，变成了从同一个位置到目的位置的总距离减去所有人到这个位置的总距离。至于“这个位置”究竟是那个位置，我们需要分情况讨论，反正大致思想就是这些。
## 具体步骤
当然“这个位置”可不是哪里都行，要确保不会“绕远路”。 $\\$ 
例如当输入为：

```cpp
3 1
2 1
1 3
3 6
4
```
此时的图就是这样子的：
![](https://cdn.luogu.com.cn/upload/image_hosting/hy8bwyu5.png)
此时输入为 $4$，那我们就以位置 $4$ 为中心，往左边的村庄先走到位置 $1$，往右边的村庄走到位置 $n$，就像这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/jnvmmuz6.png)
此时的路径和就等于红色路径减去蓝色路径，注意要算上人数。
### 如何维护红蓝路径？
这时候我们需要计算两个前缀和数组 $sum$ 和 $summ$，其中 $sum$ 是普通前缀和，用来统计人数，$summ$ 是加权前缀和，相比普通前缀和，他还需要计录位置带来的权重。 $\\$ 
具体的，$sum_i=sum_{i-1}+a_i$，$summ_i=summ_{i-1}+a_i\times x_i$。 $\\$   
那么我们该如何利用这两个前缀和来维护红蓝路径的差呢？直观的理解：
- 对于左边部分的贡献：每个居民需要向右移动 $q-x_i$ 的距离。可得总距离为 $lsum\times q-lsumm$。
- 对于右边部分的贡献：每个居民需要向右移动 $x_i-q$ 的距离。可得总距离为 $rsumm-rsum\times q$。

最后两部分的贡献相加即可。
# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2e5+5;
typedef pair<int,int> P;
int n,q,sum[maxn],summ[maxn];
int sa[maxn],sx[maxn];//a[],x[]
P a[maxn];
signed main()
{
	cin>>n>>q;
	for(int i=1;i<=n;i++) 
	 cin>>a[i].second>>a[i].first;
	sort(a+1,a+n+1);//一定要先按位置排序！
	for(int i=1;i<=n;i++)
	 {
	 	sa[i]=a[i].second;sx[i]=a[i].first;
	 	sum[i]=sum[i-1]+sa[i];
	 	summ[i]=summ[i-1]+sa[i]*sx[i];//计算前缀和
	 }
	while(q--)
	 {
	 	int x;cin>>x;
	 	int pos=lower_bound(sx+1,sx+n+1,x)-sx-1;//二分查找当前中心
	 	int lsum=sum[pos];
	 	int lsumm=summ[pos];//左边部分前缀和
	 	int s1=x*lsum-lsumm;//左边贡献
	 	int rsum=sum[n]-sum[pos];
	 	int rsumm=summ[n]-summ[pos];//右边部分前缀和
	 	int s2=rsumm-x*rsum;//右边贡献
	 	cout<<s1+s2<<"\n";
	 }
	return 0;
}
```

---

## 作者：Aiden604 (赞：1)

## 题目大意
给定 $Q$ 个数，对于每个数 $q$，求 $f(q)$。
## 思路
我们使用数学的方法解该题，抛开题目背景。\
观察题目数据量，暴力显然过不了。我们可以试着化简 $f(q)$，降低其时间复杂度。
$$
f(q)=\sum_{i=1}^{N}{a_i\times|x_i-q|}
$$
欸，我们发现绝对值很烦，不如利用绝对值的性质，拆开绝对值，具体见下。
$$
f(q)=\sum_{x_i\leq q}{a_i\times(q-x_i)}+\sum_{x_i > q}{a_i\times(x_i-q)}
$$
继续化简，最终可得。
$$
f(q)=q \cdot \sum_{x_i\leq q}{a_i}+\sum_{x_i\leq q}{x_i\cdot a_i}+\sum_{x_i> q}{x_i\cdot a_i}-q\cdot\sum_{x_i > q}{a_i}
$$
根据结果，容易想到可以分别对 $a_i$ 和 $x_i\cdot a_i$ 取前缀和，这样可以用 $O(1)$ 的复杂度进行求和。\
但是又有个问题了，如何快速判断哪些 $x_i$ 小于 $q$，哪些又大于呢？\
可以用二分查找查找**分割点**，也就是查找最后一个小于等于 $q$ 的数。需要注意的是，题目中的 $x$ 数组并没有排序，所以我们要先排序。
## 代码
[AC 记录](https://www.luogu.com.cn/record/221984558)
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
struct vlg{
	int x,a;
	vlg(){};//记得加默认的
	vlg(int pos):x(pos),a(-1){};//查找x与a无关
	bool operator < (const vlg &b)const{
		return x<b.x;
	}
}v[N];
int n,Q,pa[N],pxa[N];
signed main(){	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>Q;
	for(int i=1;i<=n;i++){
		cin>>v[i].a>>v[i].x;
	}
	sort(v+1,v+n+1);
	for(int i=1;i<=n;i++){
		pa[i]=pa[i-1]+v[i].a;//a的前缀和
		pxa[i]=pxa[i-1]+v[i].a*v[i].x;//a*x的前缀和
	}
	while(Q--){
		int q;
		cin>>q;
		int idx=upper_bound(v+1,v+1+n,vlg(q))-v-1;//最后一个小于等于q的村庄位置
		cout<<q*pa[idx]-pxa[idx]+pxa[n]-pxa[idx]-q*(pa[n]-pa[idx])<<'\n';//根据式子照搬即可
	}
	return 0;
}


```

---

## 作者：ylzpl (赞：1)

#### P12725 [KOI 2021 Round 2] 累计距离
KOI 国是一个由 $N$ 个村庄构成的国家，这些村庄分布在数轴上。其中第 $i$ 个村庄（$1 \leq i \leq N$）位于位置 $x_i$，并有 $a_i$ 名居民。不会有两个不同村庄位于相同的位置。

KOI 国计划召开一场所有国民都要参加的大会。为此，所有人需要前往会议举办地点，所有人前往该地点所需的移动距离之和称为“累计距离”，我们用 $f(x)$ 表示当会议举办地点为 $x$ 时的累计距离。

住在第 $i$ 个村庄的人前往位置为 $x$ 的会议地点时，需要移动的距离为 $|x_i - x|$。由于第 $i$ 个村庄有 $a_i$ 名居民，因此该村居民所需的总移动距离为 $a_i \times |x_i - x|$。

将所有村庄的该值加总，即可得到在位置 $x$ 举办会议时的累计距离：

$$
f(x) = \sum_{i=1}^{N} a_i \times |x_i - x|
$$

KOI 国已经准备了 $Q$ 个会议地点候选位置。第 $j$ 个候选位置（$1 \leq j \leq Q$）为 $q_j$。多个候选位置之间不会重复，但候选位置可能与某个村庄位置相同。

请编写程序，计算每一个候选会议地点 $q_j$ 的累计距离 $f(q_j)$。

本题难度：黄，不假。  
方法：二分，前缀和，推式子（狮子）。

解题思路：

对于任意一个地点 $q_j$ 而言，如果我们用暴力的写法，就是求 $\sum_{i=1}^{N} a_i \times |x_i - x|$。当然，这里有绝对值，如果拿这个式子去做，肯定不行。所以我们需要换一种做法。对于 $|x_i-x|$ 这个式子，实际上我们可以转换一下。当 $x_i>x$ 时，$|x_i-x|=x_i-x$。当 $x_i<x$ 时，$|x_i-x|=x-x_i$。当 $x_i=x$ 时，$|x_i-x|=0$。根据这个条件，我们可以把这些地点分成两组。左边一组是 $x_i<x$ 的，右边一组是 $x_i>x$ 的，$x_i=x$ 的不用处理，没那个必要。那么，我们还需要确定左右两边的分界线。所以我们需要将所有的点按位置从小到大排序。用二分查找第一个大于等于 $x$ 的点。这就是分界线。我们先看左边这一组的。那么，如果我们用暴力写，就会有以下公式（在这里，为了方便观察，我没有用标准格式）：

  $$f(x)=a_1 \times (x_1-q)+a_2 \times (x_2-q)+ \cdots +a_{t-1} \times (x_{t-1}-q)$$

根据乘法分配律去括号得：
 $$f(x)=a_1 \times x_1-a1 \times q+a_2 \times x_2-a_2 \times q+ \cdots+a_{t-1} \times x_{t-1}-a_{t-1} \times q$$

把上述式进行提取公因数得：
$$f(x)=a_1 \times x_1+a_2 \times x_2+ \cdots +a_{t-1} \times x_{t-1}-q \times (a_1+a_2+ \cdots a_{t-1})$$

不难发现，我们的 $\sum_{i=1}^{N} a_i \times x_i$ 可以考虑用前缀和进行优化来求，我们的 $\sum_{i=1}^{N} a_i$ 也可以用前缀和进行优化。那么，我们左边的这一组就搞定了。再看右边的这一组。注意，右边这一组要反过来减，就是 $q-x_i$。

$$f(x)=a_t \times (q-x_t)+a_{t+1} \times (q-x_{t+1})+ \cdots +a_n \times (q-x_n)$$

根据乘法分配律去括号得：

$$f(x)=a_t \times q-a_t \times x_t+a_{t+1} \times q-a_{t+1} \times x_{t+1}+ \cdots +a_n \times q-a_n \times x_n$$

把上述式进行提取公因数得：
$$f(x)=q \times (a_t+a_{t+1}+ \cdots a_n)-(a_t \times x_t+a_{t+1} \times x_{t+1}+ \cdots +a_{n} \times x_n)$$

我们得出的式子中 $q \times \sum_{i=t}^{N} a_i$ 和 $\sum_{i=t}^{N} a_i \times x_i$ 可以用前缀和优化。

那么，我们还是需要注意一些细节点：
- 排序的话就需要结构体数组，而结构体数组只能手写二分，如果要用函数，$x_i$ 需要用数组存起来。
- 前缀和需要在排序后存起来，不然计算的就是错的。我的数组应该是排序后才分组啊。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
struct node{
	int a,x;
}k[maxn];
bool cmp(node q,node h){
	return q.x<h.x;
}
int xx[maxn];
int suma[maxn],sumxa[maxn];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>k[i].a>>k[i].x;
	}
	sort(k+1,k+1+n,cmp);
	for(int i=1;i<=n;i++){
		xx[i]=k[i].x;
	}
	for(int i=1;i<=n;i++){
		suma[i]=suma[i-1]+k[i].a;
		sumxa[i]=sumxa[i-1]+k[i].a*k[i].x;
	}
	while(m--){
		int q;
		cin>>q;
		int pos=lower_bound(xx+1,xx+1+n,q)-xx;
		int qian=q*suma[pos-1]-sumxa[pos-1];
		int hou=(sumxa[n]-sumxa[pos-1])-q*(suma[n]-suma[pos-1]);
		cout<<qian+hou<<"\n";
	}
	return 0;
}
```
真服了，这题思路写的和题面一样长。

本题题解目前最详细，如果看不懂随时问哦。

---

## 作者：seika27 (赞：1)

### 思路
对于题目给出的问题，我们考虑如何快速计算距离。

因为有绝对值考虑将其分为开会点左侧和右侧。

那我这里就针对左侧进行讲解，右侧与左侧并无区别。

对于 $\sum_{i=1}^{k} a_i\times(p-x_i)$ 我们将括号打开。

然后式子变成 $p\times\sum_{i=1}^k a_i-\sum_{i=1}^{k} a_i\times x_i$。

到这里就是好做的的了，考虑将 $a_i$ 与 $a_i\times x_i$ 记录前缀和然后二分求 $k$ 的值。

然后我们惊人的发现我们做完啦。

### code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
struct vage
{
	int u,v;
}a[N];
inline bool operator<(vage a,vage b){return a.v<b.v;}
int n;
int q;
int sumu[N],sumuv[N];
signed main()
{
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	cin>>n>>q;
	for(int i=1;i<=n;++i)cin>>a[i].u>>a[i].v;
	sort(a+1,a+1+n);	
	for(int i=1;i<=n;++i)
	{
		sumu[i]=sumu[i-1]+a[i].u;
		sumuv[i]=sumuv[i-1]+a[i].u*a[i].v;
	}
	while(q--)
	{
		int p;
		cin>>p;
		int k=lower_bound(a+1,a+1+n,vage{910721,p})-a-1;
		int lsum=p*sumu[k]-sumuv[k];
		int rsum=sumuv[n]-sumuv[k]-p*(sumu[n]-sumu[k]);
		cout<<lsum+rsum<<'\n';
	}
	return 0;
}
```

---

## 作者：linhanmo (赞：1)

# 题解：P12725 [KOI 2021 Round 2] 累计距离

## 思路

暴力显然不可行，考虑优化计算累计距离。

因为是累计，可以使用前缀和优化。

考虑分成两部分处理（左侧和右侧），这样每个部分的答案都可以用前缀和维护了。

记录两个前缀和数组 $s1$ 和 $s2$，分别存储 $a_i$ 和 $a_i\cdot x_i$ 的前缀和。

设 $q_i$ 在数组中的位置为 $id$， $la=s1_{id}$，$lx=s2_{id}$，显然左侧答案为 $q_i * la - lx$，右侧为 $s2[n] - lx - x * (s1[n] - la)$。

## [AC](https://www.luogu.com.cn/record/220071706) code

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 2e5 + 1;
int n, q, sa[N], sx[N];
pair<int, int> a[N]; pair<long long, long long> s[N];
int main(void) {
	scanf("%d %d", &n, &q);
	for (int i = 1; i <= n; ++i)
	    scanf("%d %d", &a[i].second, &a[i].first);
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; ++i) {
		auto [x, a] = ::a[i];
		s[i] = {s[i - 1].first + a, s[i - 1].second + 1ll * a * x};
	}
	for (int p, x, c = q; c--;) {
		scanf("%d", &x);
		auto [la, lx] = s[lower_bound(a + 1, a + n + 1, pair<int, int>{x, 0}) - a - 1];
		printf("%lld\n", x * la - lx 
		    + s[n].second - lx - x * (s[n].first - la));
	}
	return 0;
}
```

---

## 作者：Charged_Charge (赞：0)

# 洛谷 P12725
## 题目大意：
给定 $n$ 个村庄，每个村庄的位置为 $x_i$ 有 $a_i$ 人。再给定 $q$ 个预选会场，每一个的位置为 $q_i$。求出对于每一个会场，每一个村庄的每一户村民到达会场的距离之和。也就是对于每一个会场位置 $x$ 求出 $\sum_{i=1}^n a_i\times\left|x_i-x\right|$。 
## 解题思路：
首先，看到 $n\le 2\times 10^5$ 且 $q\le 2\times 10^5$ 就能确定不能对于每一个会场都循环一边所有的村庄。所以，我们要用到前缀和预处理。思考发现，要求到会场的距离有两个必要的元素，分别为人数和距离，所以我们可以用两个不同的前缀和数组预处理这两个元素。预处理好数据后，我们又发现了一个新的问题，如何确定前缀和数组的下标。这里我们不能用循环，因为会超时。很容易会想到二分查找，但没有单调性。不过没关系，我们可以对原数组进行排序，创造单调性。设当前会场的位置为 $x$。如果当前查找到的 $x_i \le x$，那么让右端点增加一，否则让左端点减少一。找到下标后，我们开始求最终答案。这里我们采用求两边的贡献的策略，求出两边的距离再相加就是答案。最后注意，一定要开 `long long` 否则会 $0$ 分，别问我怎么知道的。
- 左边：会场位置乘左边总人数减去左边位置与人数乘积的和。
- 右边：右边位置与人数乘积的和减去会场位置乘右边总人数。
## AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+20;
int n, q;
struct node {
	int p, x;
} a[N];
bool cmp(node l, node r) {
	return l.x < r.x;
}
int find(int w) {
	int l = 1, r = n, mid;

	while (l <= r) {
		mid = (l + r) >> 1;

		if (a[mid].x <= w) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}

	return l;
}
int sump[N], sumx[N];
signed main() {
	cin >> n >> q;

	for (int i = 1; i <= n; i++) {
		cin >> a[i].p >> a[i].x;
	}

	sort(a + 1, a + 1 + n, cmp);

	for (int i = 1; i <= n; i++) {
		sump[i] = sump[i - 1] + a[i].p;
		sumx[i] = sumx[i - 1] + a[i].x * a[i].p;
	}

	while (q--) {
		int w;
		cin >> w;
		int idx = find(w) - 1;
		int z = w * sump[idx] - sumx[idx];
		int y = sumx[n] - sumx[idx] - w * (sump[n] - sump[idx]);
		cout << z + y << endl;
	}

	return 0;
}
```

---

## 作者：hex4C45 (赞：0)

## 题意概括

给定 $n,q$ 与 $n$ 个数 $x_i$，$q$ 次询问，每次给定 $p$ 求：

$$\sum\limits_{i=1}^n |p-x_i|$$

## 题目分析

注意到 $2\times 10^5$ 的数据范围直接暴力求不可行。可以选择每次从上一次的结果推出这一次。

首先将所有询问离线下来排好序，$x_i$ 也排好序。对于一个询问 $p$ 和位置在它前面的上一个询问 $q$，可以将序列 $x$ 分为三部分：

1. 在 $q$ 前面的（包括位置与 $q$ 重合的点）
2. 在 $q$ 到 $p$ 的左开右闭区间里的
3. 在 $p$ 右边的

第一和第三部分可以拿前缀和算出这一段里所有村庄的 $a$ 之和，第一部分的这个和会对当前答案产生 $\sum a\times (p-q)$的贡献，第三部分的产生 $-\sum a\times (p-q)$的贡献。

第二段的贡献可以再拿一个指针 $R$ 维护第一个 $a$ 大于 $p$ 的村庄的编号，每一次转移查询对答案更新就减去 $a_R \times (x_R-q)$，然后加上 $a_R \times (p-x_R)$，然后 $R$ 往右跳，跳到第一个不能跳的就是第一个大于 $p$ 的。

因为值域是到 $10^9$ 的，所以为了防止 $R$ 跳到 $n+1$ 的时候越界了（剩下空数组全是 $0$）然后不停止跑出运行时错误，可以把 $a_{n+1}$ 设为 $10^9+1$ 的极大值。同理，将初始的 $p$ 设为 $-10^9-1$ 就能保证不缺漏地更新上所有查询。

排序 $\mathcal O(n \log n)$，离线求答案的时候每个村庄最多跳一次，$\mathcal O(n)$。总共 $\mathcal O(n \log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e5+80;
struct vil
{
    ll a,x;
    friend bool operator<(vil a,vil b){return a.x<b.x;}
} v[maxn];
struct query
{
    ll q,id;
    friend bool operator<(query a,query b){return a.q<b.q;}
} q[maxn];
ll s[maxn],ans[maxn],f;
int main(){
	int n,Q;
    cin>>n>>Q;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i].a>>v[i].x;
    }
    sort(v+1,v+n+1);
    for(int i=1;i<=n;i++) s[i]=s[i-1]+v[i].a;
    for(int i=1;i<=Q;i++) cin>>q[i].q,q[i].id=i;
    sort(q+1,q+Q+1);
    ll dis,r=-1e9-1,R=1;
    v[n+1].x=1e9+1;
    for(int i=1;i<=n;i++) f+=v[i].a*abs(v[i].x-r);
    for(int i=1;i<=Q;i++)
    {
        dis=q[i].q-r;
        f+=s[R-1]*dis;
        while(v[R].x<=q[i].q)
        {
            f-=(v[R].x-r)*v[R].a;
            f+=(q[i].q-v[R].x)*v[R].a;
            R++;
        }
        f-=(s[n]-s[R-1])*dis;
        r=q[i].q;
        ans[q[i].id]=f;
        
    }
    for(int i=1;i<=Q;i++) cout<<ans[i]<<endl;
}
```

---

## 作者：zhunxin666 (赞：0)

思路：直接暴力肯定超时，所以我们要优化，我们不难看出这题的累计距离可以利用前缀和来完成再用二分的方法优化，对于每个会议地点 $q$ 来说，我们需要找到最大的 $i$ 使得 $a_{i}$ 的 $x\ge q$。查找就可以用二分了，二分别忘了排序。最后我们需要计算累计距离。

计算累计距离可以拆分为两部分：
- 左边部分（村庄位置小于等于查询点）：这部分的总和是查询点乘以左边总人数减去左边位置与人数乘积的和。
- 右边部分（村庄位置大于查询点）：这部分的总和是右边位置与人数乘积的和减去查询点乘以右边总人数。

最后两者相加即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct node{
    ll a,x;
};
ll n,Q,q;
bool cmp(const node &v1, const node &v2){//vector带结构体的排序 
    return v1.x<v2.x;
}
int main() {
    ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    cin>>n>>Q;
    vector<node> a(n);
    for(int i=0;i<n;i++) cin>>a[i].a>>a[i].x;
    // 按位置排序
    sort(a.begin(),a.end(),cmp);
    //计算前缀和数组
    //suma:存储前i个村庄的居民总数。
    //sumax:存储前i个村庄的居民数与位置的乘积之和。
    vector<ll> suma(n+1,0),sumax(n+1,0);
    for(int i=0;i<n;i++){
        suma[i+1]=suma[i]+a[i].a;
        sumax[i+1]=sumax[i]+a[i].a*a[i].x;
    }
    // 处理每个查询
    while(Q--){
        cin>>q;
        //使用二分查找找到最大的i使得a[i].x<=q
        int l=0,r=n-1,pos=-1;
        while(l<=r){
            int mid=(l+r)/2;
            if(a[mid].x<=q) {
                pos=mid;
                l=mid+1;
            }else{
                r=mid-1;
            }
        }
        ll ans=0;
        if (pos>=0){
           // 左边部分：q*suma_l-sumax_l
            ll suma_l=suma[pos+1];
            ll sumax_l=sumax[pos+1];
            ans+=q*suma_l-sumax_l;
        }
        // 右边部分：sumax_r-q*suma_r
        ll suma_r=suma[n]-suma[pos+1];
        ll sumax_r=sumax[n]-sumax[pos + 1];
        ans+=sumax_r-q*suma_r;
        cout<<ans<<endl;
    }
    return 0;
}
```

---


# [GESP202506 五级] 奖品兑换

## 题目背景

为了保证只有时间复杂度正确的代码能够通过本题，时限下降为 400 毫秒。

## 题目描述

班主任给上课专心听讲、认真完成作业的同学们分别发放了若干张课堂优秀券和作业优秀券。同学们可以使用这两种券找班主任兑换奖品。具体来说，可以使用 $a$ 张课堂优秀券和 $b$ 张作业优秀券兑换一份奖品，或者使用 $b$ 张课堂优秀券和 $a$ 张作业优秀券兑换一份奖品。

现在小 A 有 $n$ 张课堂优秀券和 $m$ 张作业优秀券，他最多能兑换多少份奖品呢？

## 说明/提示

对于 $60\%$ 的测试点，保证 $1 \le a,b \le 100$，$1 \le n,m \le 500$。

对于所有测试点，保证 $1 \le a,b \le 10^4$，$1 \le n,m \le 10^9$。

## 样例 #1

### 输入

```
8 8
2 1```

### 输出

```
5```

## 样例 #2

### 输入

```
314159 2653589
27 1828```

### 输出

```
1599```

# 题解

## 作者：_qwerty_ (赞：27)

~~可以不用二分捏\~~~

首先，我们设通过第一种方式换得 $x$ 个奖品，第二种换得 $y$ 个奖品，则题意为求 $ans=\max(x+y)$ 。

由题，可得： $\begin{cases}
  a \cdot x + b \cdot y \leq n \\
  b \cdot x + a \cdot y \leq m
\end{cases}$

进一步地，通过转化，有： $\begin{cases}
  y \leq -\frac{a}{b} \cdot x + \frac{n}{b} \\
  y \leq -\frac{b}{a} \cdot x + \frac{m}{a} 
\end{cases}$

我们惊奇地发现：这就是一个二元一次不等式。它可以画图表示（图中为样例一的情况）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9avfx69h.png)

而求 $\max(x+y) = ans$ ，等同于求 $\max(ans)$ ，使得直线 $y=-x+ans(x,y \in \N)$ 的图像穿过两图像的交集部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/6i68qxvd.png)

考虑其边界 $\begin{cases}
  y = -\frac{a}{b} \cdot x + \frac{n}{b} \\
  y = -\frac{b}{a} \cdot x + \frac{m}{a} 
\end{cases}$ 两条直线，情况有：

1. 平行（重合）
2. 相交于第一象限或正坐标轴
3. 相交于二/四象限

分别考虑。

1. 平行（重合）：

   ![](https://cdn.luogu.com.cn/upload/image_hosting/6qfi0sb6.png)

   此时 $-\frac{a}{b}=-\frac{b}{a}$ ，可得 $a=b$，$k=-\frac{a}{b}=-1$ 。
   
   交集显然为纵截距较小者，且两条直线都与直线 $y=-x+ans$ 平行，因此答案即为较小的纵截距，即 $ans=\min(\frac{n}{b},\frac{m}{a})=\frac{\min(n,m)}{a}$ 。

2. 相交于第一象限或正坐标轴
  显然地，此时求出交点即取最大值。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/6i68qxvd.png)

  将 $\begin{cases}
  y = -\frac{a}{b} \cdot x + \frac{n}{b} \\
  y = -\frac{b}{a} \cdot x + \frac{m}{a} 
\end{cases}$ 当方程组联立求解，得到 $-\frac{a}{b} \cdot x + \frac{n}{b}=-\frac{b}{a} \cdot x + \frac{m}{a} $ 。

  进而，两边同乘 $a \cdot b$ 后移项得 $(a^2-b^2) \cdot x=n \cdot a-m \cdot b$ ，解出 $x$ 。
  
  然！而！这里有 $x,y \in \N$ 的限制，因此 $x$ 下取整。再根据 $\begin{cases}
  y \leq -\frac{a}{b} \cdot x + \frac{n}{b} \\
  y \leq -\frac{b}{a} \cdot x + \frac{m}{a} 
\end{cases}$ ，得到 $y=\min(-\frac{a}{b} \cdot x + \frac{n}{b},-\frac{b}{a} \cdot x + \frac{m}{a})$ 。

3. 相交于二/四象限
   
   上一种情况的求交点方法其实是通用的，只不过在这里会得到 $x<0$ 或 $y<0$ 。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/59b3khb5.png)

   **or**

   ![](https://cdn.luogu.com.cn/upload/image_hosting/k9a8j3te.png)

   又因为：两条直线斜率互为倒数且不相等，也就是斜率一大一小。
   
   要满足直线 $y=-x+ans(x,y \in \N)$ 的图像穿过两图像的交集部分，因此此时的答案为：两个（直线的横、纵截距的较大值）的较小值 。

### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m;
ll a,b;
signed main(){
    cin>>n>>m>>a>>b;
    if(a==b){                //情况1
        cout<<min(n,m)/a<<endl;
        return 0;
    }
    ll x=(n*a-m*b)/(a*a-b*b);//求方程解
    ll y=min((m-b*x)/a,(n-a*x)/b);
    if(x<0||y<0){            //情况3
        ll a1=max(m/a,m/b);
        ll a2=max(n/a,n/b);
        cout<<min(a1,a2)<<endl;
        return 0;
    }
    cout<<x+y<<endl;         //情况2
}
```

---

## 作者：wyz_std (赞：11)

由于通过 $n \gets n-a,m \gets m-b$ 和 $n \gets n-b,m \gets m-a$ 两种方式均可兑换奖品，所以 $n,m$ 的顺序显然是可以互换的。

## 暴力

显然，我们可以写出时间复杂度为 $O(n)$ 的暴力。

大致逻辑为：每次从两种券中选择数量较多的一种，花费较多的这种券来兑换奖品。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int P=1e9+7;
const int N=1e5+10;
int n,m,a,b,ans;

signed main()
{
	cin>>n>>m;
	cin>>a>>b;
	if(a<b)swap(a,b);  //确保 a 较大
	while(n>=a||m>=a)
	{
		if(n<m)swap(n,m);
        if(m<b)break;    
		n-=a;
		m-=b;
		ans++;  //从n,m中选择较大的变量减去较大的花费
	}
	cout<<ans<<endl;
	return 0;
}
```


## 正解

注：下文中默认 $a \ge b,n \ge m$

$O(n)$ 的暴力显然会超时，考虑进行优化。

由于每次我们都让较大的变量减少的更多，所以在进行0次或多次兑换后，$n,m$ 两变量的差值一定会使下次操作后 $n < m$。

具体地，令 $d=a-b,v= \min(n\div a,m\div b,(n-m)\div d)$，则在进行 $v$ 次兑换后，一定会有 $n-m<d$ 或不可再进行兑换。

当 $n-m < d$ 时，下次操作一定会使 $n < m$ 且 $m-n < d$，于是再下次操作又会使 $n > m$，以此类推。

并且在进行两次操作后，由于 $n,m$ 均减去了 $a+b$，操作后的 $n-m$ 与开始的 $n-m$ 大小相等。

因此，当 $n-m < d$ 时，可以令 $y=m \div (a+b)$，进行 $y \times 2 $ 次操作，具体看代码。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int P=1e9+7;
const int N=1e5+10;

int n,m,a,b,ans;
int s,d;

signed main()
{
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m;
	cin>>a>>b;
	if(a<b)swap(a,b);
    if(a==b) //进行特判 
    {
        cout<<min(n,m)/a<<endl;
        return 0;
    }
	s=a+b,d=a-b;
	while(n>=a||m>=a)
	{
		if(n<m)swap(n,m);
		int x=(n-m)/d;
		if(x==0) //当n-m<d时 
		{
			int y=m/s;
			ans+=y*2;
			n-=y*s,m-=y*s;
			x=2;	
		}
		int v=min(n/a,min(m/b,x));
		ans+=v,n-=v*a,m-=v*b;
        if(m<b)break; //不可进行兑换 
	}
	cout<<ans<<endl;
	return 0;
}
```
可以证明，while 循环最多执行**两次**（最开始执行一次使 $n-m<d$，第二次就可兑换完）。

因此，此代码时间复杂度近似 $O(1)$

---

## 作者：ZTengW (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P13013)  
### 思路  
其实吧我在考场上呢直接把这题当 DP 来做。  
$0$ 分。  

当数学题做。  
然后 WA，$20$pts，错了两个点。  

然后下考场之后想了好久才发现这题用二分。  
所以说思路就是枚举 $mid$（$mid$ 代表假设能兑换 $mid$ 个奖品）  
### 细节  
其实所有的二分题的细节都在于 $\operatorname{check}$ 函数。  
那么 $\operatorname{check}$ 函数怎么写呢？  
其实我们看完样例之后就会知道一点：  
答案不一定只是 $min(n,m) \div max(a,b)$。  
答案也可能更大。  
所以我们在 $\operatorname{check}$ 函数里要额外判断一点：在两种券交替用的情况下能不能换到 $mid$ 个奖品。  
### [AC](https://www.luogu.com.cn/record/222510114) code  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,a,b;
bool check(ll mid)
{
    ll ua=mid*a,ub=mid*b,tmp; // 兑换 mid 份礼物要用 ua 张 a 类券和 ub 张 b 类券
    if(ua>n)
    {
        tmp=(ua-n+a-b-1)/(a-b);
        ua-=tmp*(a-b); // 大的太多了要变少
        ub+=tmp*(a-b); // 少得太多了要变大
    }
    if(ua<=n&&ub<=m)
        return true;
    return false;
}
int main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&a,&b);
    if(n<m)
        swap(n,m);
    if(a<b)
        swap(a,b);
    ll l=0,r=n,ans=0;
    while(l<=r)
    {
        ll mid=l+(r-l)/2; // mid：兑换 mid 个礼物
        if(check(mid))
        {
            ans=max(ans,mid);
            l=mid+1;
        }
        else
            r=mid-1;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Clouds_dream (赞：5)

### 前言
一道很好的二分练手题。

### 题目内容
[题目传送门](https://www.luogu.com.cn/problem/P13013)

### 题目分析
我们假设用第一种方式兑换了 $x$ 次，用第二种方式兑换了 $y$ 次，则总次数 $k = x + y$，并且满足 $a \cdot x + b \cdot y \le n$ 和 $b \cdot x + a \cdot y \le m$，且 $x$ 与 $y$ 都为非负整数。

因为每次兑换至少消耗 $a$ 张课堂优秀券和 $a$ 张作业优秀券（当 $a \le b$ 时），所以 $ans$ 的上界为 $\min(\lfloor n / a \rfloor, \lfloor m / a \rfloor)$。

对于给定的 $k$，检查是否有 $x$（第一种方式兑换了 $x$ 次，则第二种方式兑换了 $k - x$ 次）满足：

-  $a \cdot x + b \cdot (k - x) \le n$
-  $b \cdot x + a \cdot (k - x) \le m$

整理得：

- $(b-a) \cdot x \ge b \cdot k - n $ $(b > a)$ 
- $(b-a) \cdot x \le m - a \cdot k $ $(b > a)$

计算 $x$ 的可行区间，如果非空则 $x$ 可行。

**边界处理：**

- 当 $a = b$ 时，直接记录答案。
- 当 $a < b$ 时，先计算总券数是否够，然后计算 $x$ 的区间。

### 上代码（知道你们直接看这个）

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

#define prq priority_queue

#define uns unordered_set

#define freopen freopen(".in","r",stdin);freopen(".out","w",stdout);

const int P = 998244353;

const int INF = 0x3f3f3f3f3f3f3f3f;

const int N = 1e6+10, M = 1e8 + 10;

int __lcm(int a,int b){return a/__gcd(a,b)*b;}

int n,m,a,b;
int ans=0;

signed main()
{
	fst
	cin>>n>>m>>a>>b;
	if(a>b)swap(a,b);//确保a<=b
	int l=0,r=min(n/a,m/a);//左右区间
	while(l<=r){
		int mid=(l+r)/2;
		if(a==b){
			ans=mid;
			l=mid+1;
		}//情况1
		else{
			if((a+b)*mid>n+m){
				r=mid-1;
				continue;
			}
			int mi=0;
			if(b*mid>n){
				mi=(b*mid-n+b-a-1)/(b-a);//左端点
			}
			int ma=(m-a*mid)/(b-a);
			ma=min(ma,mid);//右端点
			if(ma>=0&&mi<=ma){
				ans=mid;
				l=mid+1;
			}
            else{
                r=mid-1;
            }
		}//情况2
	}
	cout<<ans;
	return 0;
}
```

### UPD
2025.7.2  感谢 @pika_ 大佬指出的错误。

---

## 作者：CSP_J_2025 (赞：4)

# $O(1)$ 解法（非二分法）

## 大体思路

- 课堂券和作业券在某种意义上是等价的，两者可以互换。为方便处理，通过交换保证 $n \geq m$ 且 $a \geq b$。
- 设最多可换 $k$ 份奖品，则需要 $k \cdot (a + b)$ 张券。总券数为 $n + m$，故 $k \leq \frac{n + m}{a + b}$。
- 通过交换保证 $n \geq m$ 且 $a \geq b$ 后，易得 $k \leq \frac{m}{b}$。
- 特判 $a = b$ 的情况。
- 若实现前 $4$ 点，可得 $95$ 分。
- 实际中，小概率出现估算值比实际答案多 $1$ 的情况，需特判。函数 $\operatorname{chk}(s)$ 用于检查能否兑换 $s$ 个奖品，若不满足则需将答案减 $1$。

## $\operatorname{chk}$ 函数原理

- 若 $n - b \cdot s < 0$（课堂券不足），则返回 $\text{false}$。
- 设 $t$ 为第一种方式兑换次数。
- 课堂券约束：$t \cdot a + (s - t) \cdot b \leq n$，整理得 $t \cdot (a - b) \leq n - b \cdot s$。
- 作业券约束：$t \cdot b + (s - t) \cdot a \leq m$，整理得 $t \cdot (a - b) \geq a \cdot s - m$。
- $t$ 的下界 $L$：
  $$L = \begin{cases} 
  0 & \text{if } a \cdot s - m \leq 0 \\
  \left\lceil \frac{a \cdot s - m}{a - b} \right\rceil & \text{otherwise}
  \end{cases}$$
- $t$ 的上界 $R = \left\lfloor \frac{n - b \cdot s}{a - b} \right\rfloor$。
- 当且仅当 $L \leq R$ 且 $L \leq s$ 时，存在合法的 $t$，返回 $\text{true}$；否则返回 $\text{false}$。

## 我的疑惑

为何估算值 $\text{ans}$ 总是等于正确答案或多 $1$？

> 本蒟蒻其实也不知道，还请大佬多多指教。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, a, b;
bool chk(int s)
{
    if (s < 0) 
        return false;
    int num1 = a * s - m;
    int num2 = n - b * s;
    if (num2 < 0) 
        return false;
    int L;
    if (num1 <= 0) L = 0; 
    else L = (num1 + (a - b) - 1) / (a - b);
    int R = num2 / (a - b);
    if (L > R) 
        return false;
    if (L <= s) 
        return true;
    else 
        return false;
}
signed main()
{
    cin >> n >> m >> a >> b;
    if (a < b) swap(a, b);
    if (n < m) swap(n, m);
    if (a == b)
    {
        cout << m / a;
        return 0;
    }
    int ans = min((n + m) / (a + b), m / b);
    cout << ans + chk(ans) - 1;
    return 0;
}
```

---

## 作者：MGlover (赞：4)

## 分析思路
此题无法贪心。如优先以固定策略购买，可能导致一种券被耗尽时，另一种券还有大量剩余。

设 $PlanA$ 表示使用  $(a,b)$  方案购买一份；$PlanB$  表示使用  $(b,a)$  方案购买一份，且总是有 $a<b$ ， $n<m$ 。简单分析易知，某种方案的选用占比 与 某种卷的消耗数量 呈**单调相关性**。即在可行解范围内，选用  $PlanA$  的比重越大，课堂优秀卷消耗的数量就越少。

确定变量间有单调相关性，就很容易想到用**二分**来解了。

## 解决方案
本题解采用两层二分：第一层用于二分答案 $ans$ ，表示最终可兑换的份数；第二层用于验证该答案是否可行。验证策略为二分  $PlanA$ 的选用次数， $PlanB$ 则为 $ans - PlanA$ 。直接代入 $a, b$ 计算即可验证 $ans$ 是否为可行解。


当：

- 这个答案可行时，二分区间向右缩，保留中点。
- 这个答案不可行时，二分区间向左缩，不保留中点。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n, m;
    int a, b;
    cin >> n >> m;
    cin >> a >> b;
    //  此题无法贪心。优先以固定策略购买时，可能导致一种券被耗尽时，另一种券还有大量剩余。
    //  改用在特定范围内二分答案，并二分分配方案验证是否可行。

    //  预处理：确保前小后大
    if(n > m){
        swap(n, m);
    }
    if(a > b){
        swap(a, b);
    }

    //  答案范围: n/b ~ m/a
    int ans_left = n/b;
    int ans_right = m/a;
    int ans;    //  兑换礼物份数
    while(ans_left < ans_right){
        ans = (ans_left + ans_right + 1) / 2;
        //  验证该答案
        int a_left = 0; //  Plan A左边界
        int a_right = ans;  //  Plan A右边界
        int a_num;  //  以Plan A(a,b)策略兑换的份数
        //  二分验证
        bool valid = false;
        while(a_left <= a_right){
            a_num = (a_left + a_right) / 2;
            int b_num = ans - a_num;    //  以(a,b)策略兑换的份数
            // 如果这是可行解
            if(a_num * a + b_num * b <= n && a_num * b + b_num * a <= m){
                valid = true;
                break;
            }
            else{
                //  确认偏移策略：
                //  如果n和m均无剩余，则这是不可能的答案。
                if(a_num * a + b_num * b > n && a_num * b + b_num * a > m){
                    break;
                }
                //  如果n有剩余，则增加b_num（经排序，b比a大），即降低a_num
                else if(a_num * a + b_num * b <= n){
                    a_right = a_num - 1;
                }
                //  如果m有剩余，则增加a_num，即降低b_num
                else{
                    a_left = a_num + 1;
                }
            }
        }   //  while(a_left < a_right){ 验证循环

        if(valid){  //  这种答案可行
            ans_left = ans;
        }
        else{       //  这种答案不可行
            ans_right = ans - 1;
        }
    }

    cout << ans_left;
    return 0;
}
```

---

## 作者：Derek0823 (赞：3)

### $\texttt{update: 2025.7.11}$，在 [CSP_J_2025](https://www.luogu.com.cn/user/1309385) 的提醒下修改了二分上界的计算

---
### 解题思路

1. 一般情况，当 $a\ne b$ 时，我们可以考虑两种兑换方式：

   - 使用 $a$ 张课堂卷和 $b$ 张作业券。
   - 使用 $b$ 张课堂卷和 $a$ 张作业券。

   我们需要找到一个正整数 $x$，表示兑换的奖品数量，使得一个整数 $k(0\le k\le x)$，满足：

   - $k$ 次使用方式一，消耗 $k\times a$ 张课堂券和 $k\times b$ 张作业券。
   - $x-k$ 次使用方式二，消耗 $\left(x-k\right)\times b$ 张课堂券和 $\left(x-k\right)\times a$ 张作业券。

   总消耗为：

   - 课堂券：$k\times a+\left(x-k\right)\times b\le n$
   - 作业券：$k\times b+\left(x-k\right)\times a\le m$

   简单整理一下：

   - $k\le\left(n-x\times b\right)\div\left(a-b\right)$（当 $a>b$ 时）
   - $k\ge\left(a\times x-m\right)\div\left(a-b\right)$（当 $a>b$ 时）

   同理，当 $a<b$ 时，可以交换 $a$ 和 $b$，以及 $n$ 和 $m$，统一处理。

2. 特殊情况，当 $a=b$ 时，即每份奖品消耗 $a$ 张课堂券和 $a$ 张作业券。此时，最大兑换数量为 $\min\left(\left\lfloor n\div a\right\rfloor,\left\lfloor m\div a\right\rfloor\right)$。

### 代码实现

代码方面使用二分查找，寻找最大的 $x$ 使得存在 $k$ 满足兑换条件，这里注意每次查找之后要检查，计算 $k$ 的下界和上界，并检查是否存在满足条件的 $k$。如果存在，则当前 $x$ 可行；否则不可行。

这里注意一下二分查找上界的计算，取**混合使用两种兑换方式**的最大上界，即 $\left(n+m\right)\div\left(a+b\right)$。


这样取可以保证不会遗漏可能的更大值。

```cpp
#pragma warning(disable:4996)

#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>

using namespace std;

long long coupon1, coupon2;
long long prize1, prize2;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
	scanf("%lld %lld", &coupon1, &coupon2);
	scanf("%lld %lld", &prize1, &prize2);

    if (prize1 == prize2) {
        long long ans = min(coupon1 / prize1, coupon2 / prize2);
		printf("%lld\n", ans);
		return 0;
    }

	if (prize1 < prize2) {
		swap(prize1, prize2);
		swap(coupon1, coupon2);
	}

	long long bound1 = coupon1 / min(prize1, prize2);
	long long bound2 = coupon2 / min(prize1, prize2);
	long long bound3 = (coupon1 + coupon2) / (prize1 + prize2);
	long long high = min({ bound1, bound2, bound3 });
	long long low = 0, ans = 0;

	while (low <= high) {
		long long mid = low + (high - low) / 2;
		bool flag = false;

		if (coupon1 >= mid * prize2) {
			long long lbound = 0;
			if (prize1 * mid - coupon2 > 0) 
				lbound = (prize1 * mid - coupon2 + prize1 - prize2 - 1) / (prize1 - prize2);
			long long rbound = (coupon1 - mid * prize2) / (prize1 - prize2);
			if (rbound > mid) rbound = mid;
			if (lbound <= rbound && lbound <= mid) flag = true;
		}

		if (flag) ans = mid, low = mid + 1;
		else high = mid - 1;
	}

	printf("%lld\n", ans);

    return 0;
}
```

---

## 作者：yanxu_cn (赞：3)

简单的二分题目，但是还是有许多需要注意的点的（就是有点玄学）。

我们容易发现，总可兑换的奖品份数是一个关于方案一兑换奖品份数单峰的函数，于是可以用二分或者三分。

但是，这里虽然单峰，但是可能会存在平台的问题，所以用二分就不一定能够找到最优解了，这个时候用三分就合适不少。由于这里平台最多只有两个整数的长度，直接选择拿两个三等分点三分就比较省事。

但是这样的三分对于极小范围是不一定能够较好地解决的（小范围上面的情况还是比较容易遇到），所以直接暴力计算小范围即可（反正主打一个结合了暴力算法和非暴力算法）。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int n,m,a,b;
    cin>>n>>m>>a>>b;
    int l=0,r=min(n/a,m/b);
    while(r-l>500)
    {
        int m1=l+(r-l)/3;
        int m2=r-(r-l)/3;
        int f1=m1+min((n-a*m1)/b,(m-b*m1)/a);
        int f2=m2+min((n-a*m2)/b,(m-b*m2)/a);
        f1<f2?l=m1:r=m2;
    }
    int best=0;
    for(int k=l;k<=r;k++)
    {
        int t=min((n-a*k)/b,(m-b*k)/a);
        if(k+t>best)best=k+t;
    }
    cout<<best;
    return 0;
}
```

---

## 作者：HSTYYH (赞：3)

非常不错的一道二分答案题目，整体不算太难。

思路如下：我们需要确定最多能兑换多少份奖品。兑换一份奖品可以使用两种方式：一种是使用 $ a $ 张课堂优秀券和 $ b $ 张作业优秀券，另一种是使用 $ b $ 张课堂优秀券和 $ a $ 张作业优秀券。

给出 $ n $ 张课堂优秀券和 $ m $ 张作业优秀券，我们需要找出最大的兑换份数 $ mid $ ，使得存在非负整数 $ x $ 和 $ y  $ ，其中 $ x+y=mid $ ，需要满足以下条件：

-  $ a\times x + b \times y \le n  $ 
-  $ b\times x + a \times y \le m  $ 

使用二分法来寻找最大的  $ mid $ 。二分范围的下界为 $ 0 $ ，上界为 $  \max(n,m) / \min(a,b) + 1 $ （ 确保覆盖可能的解）。同时，检查函数中对于每个候选的 $ t $ ，检查是否存在非负整数 $ x（0 \le x \le t） $ 满足：

-  $ (a - b)\times x \le n - b\times t $
-   $ (a - b) \times x \ge a \times t - m $
  
根据 $ a $ 和 $ b $ 的大小关系，分情况处理：

- 当  $ a  $ 和 $ b $ 相等时，只需验证 $ a\times t \le n  $ 且 $  a\times t ≤ m $ 。
- 当 $ a > b $ 时，计算 $ x $ 的下界和上界，并检查是否存在整数 $ x $ 在 $ [0, t] $ 范围内。
- 当 $ a < b $ 时，同样计算 $ x $ 的下界和上界，并检查是否存在整数 $ x $ 在 $ [0, t] $ 范围内。

剩下就是二分答案的模板了，相信大家都可以看懂，上代码：

```
#include <bits/stdc++.h>
using namespace std;

long long n, m, a, b;

bool check(long long t){

    if((a + b) * t > n + m) 
        return false;

    if(a == b){
        if( a * t <= n &&  a * t <= m)
            return true;
        else
            return false;
    }

    double low, high;
    if(a > b){
        low = (1.0 * a * t - m) / (a - b);
        high = (1.0 * n - b * t) / (a - b);
    }
    else{
        low = (1.0 * n - b * t) /(a - b);
        high = (1.0 * a * t - m) /(a - b);
    }

    long long L = ceil(low);
    long long R = floor(high);

    L = max(L, (long long)0);
    R = min(R, t);

    return(L <= R);
}

int main(){

    cin >> n >> m;
    cin >> a >> b;

    long long ans = 0;
    long long left = 0;
    long long right = max(n,m)/min(a,b) + 1;
    
    while(left <= right){
        long long mid =(left + right) / 2;
        if(check(mid)){
            ans = mid;
            left = mid + 1;
        }
        else{
            right = mid - 1;
        }
    }

    cout << ans;

    return 0;
}
```

---

## 作者：no_response (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P13013)
## 故事
先吐槽一句，在考试的时候，编译器给我卡爆了，花了半小时才做完了，当时满分了。

然后我信心满满的提交了题解，第二天题解通道给我关了，我愣住了，然后下午发现原来数据加强了，还升黄了，给我打回来了，我只能重构新算法。
## 题意
小 A 有 $n$ 张课堂优秀券，$m$ 张作业优秀券。

小 A 可以花 $a$ 张课堂优秀券和 $b$ 张作业优秀券或者 $b$ 张课堂优秀券和 $a$ 张作业优秀券来换取一个奖品。

我们需要求出最多可以换取多少个奖品。
## 分析
~~考试时就一眼杀了，这题考贪心~~。数据加强后现在题目要用二分了。暴力解法我就不讲了，只能拿部分分，就讲一下能满分的二分算法。

先要确保 $n \ge m, a \ge b$，然后是基本二分结构，结构还是讲一下吧：
1. 二分会有起始的 $left$ 和 $right$。
2. 循环一般用 `while`，条件一般为 `while(left <= right)`。
3. 在循环内部要用 $middle$ 来求 $left$ 和 $right$ 的中间值，即 `middle = (left + right) / 2`。
4. 以上代码可优化成 `middle = left = (right - left) / 2`，这样可以确保不会溢出。
5. 通过一个函数的返回值，去修改 $left$ 或 $right$ 的值，即 `left = middle + 1` 或 `right = middle - 1`。
6. 二分因为每次减少一半的范围，所以时间复杂度为 $O(\log n)$。

输入加二分框架：
```cpp
int n, m, a, b, v;
cin >> n >> m >> a >> b;
if (n < m) {
	swap(n, m);
}
if (a < b) { 
	swap(a, b);
}
v = a - b;
int left = 0, right = n;
int ans = 0;
while (left <= right) {
	int middle = left + (right - left) / 2;
  if (check(middle) == 1) {
		ans = max(ans, middle);
		left = middle + 1;
	} else {
		right = middle - 1;
	}
}
```
接下来就是写 $\operatorname{check}$ 函数了。

把 $middle$ 作为参数传入，求出按当前比例分配的两个量 $x,y$，如果 $x$ 超出上限 $n$ 时，需要转换 $x$ 和 $y$，而转换量为 $(x - n + v - 1) \div v$，最后判断以下 $x,y$ 与 $n,m$ 之间的关系，返回 0 或 1，在二分循环中做出相应修改，结束后输出答案即可。
### 注意
此题因 $a,b$ 较大，需要使用 `#define int long long`。
## AC CDOE
```cpp
#include <bits/stdc++.h>
#define int long long //不开80分
using namespace std;
int n, m, a, b, v;
bool check(int middle) { //求解
	int x = a * middle, y = b * middle; //按当前比例分配的总量
	if (x > n) { //若x超过上限n时
		int k = (x - n + v - 1) / v; //需要转换的量
		x -= k * v, y += k * v; //等比例转换
	}
	if (x <= n && y <= m) { //最后判断
		return 1;
	}
	return 0;
}
signed main() {
	cin >> n >> m >> a >> b;
	if (n < m) { //保证n>=m
		swap(n, m);
	}
	if (a < b) { //保证a>=b
		swap(a, b);
	}
	v = a - b; //修改
	int left = 0, right = n; //二分l,r
	int ans = 0;
	while (left <= right) { //二分条件
		int middle = left + (right - left) / 2; //二分mid
		if (check(middle) == 1) { //两种情况
			ans = max(ans, middle); //修改
			left = middle + 1; //缩减范围
		} else {
			right = middle - 1; //缩减范围
		}
	}
	cout << ans; //输出代码
	return 0;
}
```

---

## 作者：Mark_Pei (赞：2)

## Solution

一道**贪心**和**二分**题，本人没场切，只拿了暴力分，回来补篇题解。

我们可以把这个过程看成先进行很多次第一种兑换，再将其中的一部分第一种兑换替换为第二种兑换先进行 $k$ 次第一种兑换，那么课堂优秀券还剩 $n-ak$，作业优秀券还剩 $m-bk$ 。

将一次第一种兑换更改为第二种，也就是原来的 $-a,-b$ 变成了 $-b,-a$，可以看作是将 $b-a$ 张课堂优秀券转化成了 $b-a$ 张作业优秀券。

所以我们可以进行很多次第一种兑换，即使把作业优秀券兑换成了负数也没关系，可以用剩下的课堂优秀券进行转化。

即：

$$n - ak ≥0$$
$$n - ak ≥ bk - m $$
$$k=\min(\lfloor \frac{n}{k} \rfloor,\lfloor \frac{n+m}{a+b} \rfloor)$$

之后可以将 $n,m$ 互换，整个过程用二分进行优化。

当然有听说有 $O(1)$ 做法的更好可以参考。

### AC code
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,a,b,l,r;
int check(int v) 
{
    long long x,y,t;
    x=v*a;
    y=v*b;
    if(y>m)
    {
        t=(y-m+(b-a)-1)/(b-a);
        y-=t*(b-a);
        x+=t*(b-a);
    }
    return x<=n&&y<=m;
}
int main() 
{
    cin>>n>>m>>a>>b;
    if(a>b) swap(a,b);
    if(n>m) swap(n,m);
    if(a==b)
    {
        cout<<n/a;
        return 0;
    }
    l=0,r=n;
    while(l<r) 
    {
        int mid=(l+r+1)>>1;
        if(check(mid)) l=mid;
        else r=mid-1;
    }
    cout<<r;
    return 0;
}
```

---


# KC 喝咖啡

## 题目描述

话说 KC 和 SH 在福州的时候常常跑去 85°C 喝咖啡或者其他的一些什么东西。

这天，KC 想要喝一杯咖啡，服务员告诉他，现在有 $n$ 种调料，这杯咖啡只可以加入其中的 $m$ 种（当然 KC 一定会加入 $m$ 种，不会加入少于 $m$ 种的调料），根据加入的调料不同，制成这杯咖啡要用的时间也不同，得到的咖啡的美味度也不同。

KC 在得知所有的 $n$ 种调料后，作为曾经的化竞之神的他，马上就知道了所有调料消耗的时间 $c _ i$ 以及调料的美味度 $v _ i$。由于 KC 急着回去刷题，所以他想尽快喝到这杯咖啡，但他又想喝到美味的咖啡，所以他想出了一个办法，他要喝到 $\dfrac{\sum v _ i}{\sum c _ i}$ 最大的咖啡，也就是单位时间的美味度最大的咖啡。

现在，KC 把调料信息告诉了 SH，要 SH 帮他算出喝到的咖啡的 $\dfrac{\sum v _ i}{\sum c _ i}$，但 SH 不想帮 KC 算这东西，于是 KC 就只能拜托你来算了。

注释：$\sum$ 表示求和，所以 $\dfrac{\sum v _ i}{\sum c _ i}$ 表示美味度的总和除以消耗时间的总和。


## 说明/提示

**样例 1 解释**：

KC 选 $2$ 号和 $3$ 号调料，$\dfrac{\sum v _ i}{\sum c _ i} = \dfrac{2 + 3}{2 + 1} = 1.667$。

可以验证不存在更优的选择。

**数据范围**：

对 $20 \%$ 的数据：$1 \leq n \leq 5$。

对 $50 \%$ 的数据：$1 \leq n \leq 10$。

对 $80 \%$ 的数据：$1 \leq n \leq 50$。

对 $100 \%$ 的数据：$1 \leq n \leq 200, 1 \leq m \leq n, 1 \leq c[i], v[i] \leq 1 \times 10 ^ 4$。

数据保证答案不超过 $1000$。


## 样例 #1

### 输入

```
3 2
1 2 3
3 2 1
```

### 输出

```
1.667
```

# 题解

## 作者：Hexarhy (赞：90)

好久没有写二分答案了，来复习复习。顺便补充个像样的有$\LaTeX$的题解。

------------

刚开始看到题目还以为是01背包，但却是求平均值最大，故不考虑。

但是不好思考呢……那先从式子入手：

假设存在一种最优解$ans$，则

$$\large ans=\frac{\sum^m_{i=1}v_i}{\sum^m_{i=1}c_i}$$

式子太复杂？尝试化一下。

$$\text{去分母得，}\sum^m_{i=1}c_i·ans=\sum^m_{i=1}v_i$$

$$\text{移项得，}\sum^m_{i=1}c_i·ans-\sum^m_{i=1}v_i=0$$

-----------------------

观察式子，不难发现最优解$ans$会使得左边$=0$，因此我们的目标就是尽可能地的靠近$0$。加上$ans$具有单调性，这时就考虑到二分。

`check()`也就很好写了。由于我们想让左边尽可能$<0$，则考虑贪心，排序并选前$m$个最小的权值并得到之和$tot$。

此时要对`check()`得到的$tot$进行分类讨论了：

- 当$tot<0$时，说明$ans$还能再大一点，故二分时$l=mid$，往右靠。

- 当$tot>0$时，说明$ans$还能再小一点，故二分时$r=mid$，往左靠。

- 当$tot=0$时，就是答案了，可以直接结束二分。

另外，由于有小数，二分结束条件$l,r$之间就不是$r-l\ge 1$，而是形如$r-l\le 10^{-5}$保证精度。

---------------------

时间复杂度：

- 输入：$\Theta(n)$

- 二分：$\Theta(\log\max\large\{\frac{v_i}{v_i}\})$

- 排序：$\Theta(n\log n)$

- 计数$tot$：$\Theta(m)$

综上所述，时间复杂度为：

$$\large\Theta(n+(m+n\log n)\log\max\{\frac{v_i}{v_i}\})$$

$$\large\approx\Theta(n\log n \log \max\{\frac{v_i}{v_i}\})$$

最坏也不过达到大约$2\times 10^4$。


------------------------

讲得很细了，代码注释就不给那么多了。分析里都有。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN=500;
int n,m;
struct coffee
{
	int v,t;
	double avr;//算权值t*x-v
	bool operator<(const coffee a)const
	{
		return avr<a.avr;
	}
}a[MAXN];
double ans,l,r;


void input(void)
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	 cin>>a[i].v;
	for(int i=1;i<=n;i++)
 	 cin>>a[i].t;
}

bool check(const double x)
{
	for(int i=1;i<=n;i++)
	 a[i].avr=x*a[i].t-a[i].v;//算每个的权值
    sort(a+1,a+n+1);//从小到大排序
	double tot=0;
	for(int i=1;i<=m;i++)//取前m个小的
	 tot+=a[i].avr;
	return tot<=0;
}

void binary(void)
{
	for(int i=1;i<=n;i++)
	 if(a[i].v*1.0/a[i].t>r)
	  r=a[i].v*1.0/a[i].t;//算出上界
	while(r-l>1e-5)
	{
		const double mid=(l+r)/2.0;
		if(check(mid))//注意分类讨论（这里结合二分求上下界）
		 l=mid;
		else
		 r=mid;
	}
	ans=l;
}

int main()
{
	input();
	binary();
	printf("%.3f\n",ans);
	return 0;
}
```

--------------------

### 还没结束呢！

现在仔细想想，或许可以不用二分（优势在于避免分类讨论和上下界问题），考虑枚举$x(x\in[0,\max\large\{\frac{v_i}{c_i}\}])$，并进行`check()`，好像也不会超时。理论时间复杂度：

$$\Theta(n\log n \max\{\frac{v_i}{c_i}\})$$

最坏情况大约为$1.5\times 10^8$。

但实际题目中除非专门卡否则一般达不到这样的复杂度，加上编译器的优化~~和lg评测机的良好性能~~，卡一卡（甚至不用）就能过去。

**当然以上只是个人看法，作者还没实践过。**

-------------

### 完结撒花！✿✿ヽ(°▽°)ノ✿

---

## 作者：浅色调 (赞：49)

###二分答案+贪心###

**思路：**一般最先想到的方法是把物品按照单位价值进行排序，从大到小地贪心进行选取。但是很明显这样去贪心很容易举出反例，于是我们考虑套用二分+贪心来解决。我们可以直接二分答案，区间l取0、r取单个物品的最大价值(注意精度开double)，然后对于我们二分出的值x，关键是如何check判断，稍稍运用下数学转换公式：**sigma(vi)/sigma(ci)>=x，变形推导出sigma(vi-x\*ci)>=0**。因此，可以对vi-x\*ci进行贪心排序选取前m个，最后只要判断这m个值的和是否大于等于0就ok了。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct query{
int v,c;double div;
}a[1000];
bool cmp(query a,query b){return a.div>b.div;}
inline bool check(double x)
{
    for(int i=1;i<=n;i++)a[i].div=a[i].v-x*a[i].c;
    sort(a+1,a+n+1,cmp);
    double tot=0;
    for(int i=1;i<=m;i++)tot+=a[i].div;
    return tot>=0;
}
int main()
{
    scanf("%d%d",&n,&m);
    double l=0,r,mid;
    for(int i=1;i<=n;i++)scanf("%d",&a[i].v);
    for(int i=1;i<=n;i++)scanf("%d",&a[i].c),r=r<a[i].v*1.0/a[i].c?a[i].v*1.0/a[i].c:r;
    while(r-l>1e-6)
    {
        mid=(l+r)/2;
        if(check(mid))l=mid;
        else r=mid;
    }
    printf("%.3lf",l);
    return 0;
}
```

---

## 作者：redegg (赞：17)

注意：正解不是我这个做法。

但是我AC了？

正解下面题解都说了，我也是第一次见先二分再用推式子搞出来的题。

我的做法就是暴力吧，每次都贪心取累积后相除的最大值（应该是数据水跑过的）

下面贴代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

double a[10000];
double c[10000];
double ax;
double cx;
double maxn=0;
bool b[10000];
int y;
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lf",&a[i]);
    for(int i=1;i<=n;i++)
        scanf("%lf",&c[i]);

    for(int j=1;j<=m;j++)
    {
        maxn=0;
        y=0;
        for(int i=1;i<=n;i++)
        {
            if((ax+a[i])/(cx+c[i])>maxn&&b[i]!=1)
            {
                maxn=(ax+a[i])/(cx+c[i]);
                y=i;
            }
        }
        ax+=a[y];
        cx+=c[y];
        b[y]=1;
    }
    printf("%.3f",ax/cx);
    return 0;
}

```

---

## 作者：vector (赞：8)

0-1分数规划：


设最终答案为R，x[i]为0或1，则 Σ(v[i]\*x[i]) / Σ(c[i]\*x[i]) = R

即 Σ(v[i]\*x[i]) - Σ(c[i]\*x[i]\*R) =0

即 Σ[(v[i]\*x[i]) - (c[i]\*x[i]\*R)] =0

设 f(R)= Σ[(v[i]\*x[i]) - (c[i]\*x[i]\*R)]


二分R，求f(R)=0

当f(R)<0时，R偏大

当f(R)>0时，R偏小

计算每一对 v[i]- (c[i]\*R)，排序求前m大的和即为f(R) 。


---

## 作者：_H1kar1 (赞：5)

### ！80分歪解注意

我一看这题感觉就是搜索啊...前面大佬都是二分，说实话我没想到，题解也没人发搜索的（~~人家都二分过了谁管你搜索~~）

后来证实了二分是正解，搜索是歪解...具体什么原因待会会讲

简单分析题意，我们可知对于每一种调料我们都可以选或者不选，选就获得一个收益且付出一个代价，不选就当无事发生

首先想到是背包？但是本题计算最终收益的方法是求和后再商...想了想感觉以我的水平很不可做orz

那就尝试一下搜索列举每种决策吧（我猜有人记不住数组含义，于是贴心的标出来hh

```cpp
double tim[N],vl[N];//tim是花费时间，vl是价值（好吃程度
void dfs(int k,double cst,double del,int c){
	//正在处理第k个，话费时间cst，收益好吃程度del，已经选了c中调料
	if(c==m){//选好了m种则更新答案
		ans=max(ans,del/cst);
		return;
	}
	if(k>n)	return;//选出界了
	
	dfs(k+1,cst+tim[k],del+vl[k],c+1);//选择会带来收益和代价，以及选择数量++
	dfs(k+1,cst,del,c);//不选则当无事发生，考虑下一个决策
}
```
测了样例，感觉自己真的很不错，提交一看，80分

~~毕竟是纯暴力做法..~~

---
以下是我对于剪枝的一些思考和失败经历，由于太弱尝试几次并不成功，欢迎神牛指点一下orz

想了想，有一种剪枝策略是
>#### 用前缀和数组记下每个调料的收益，在对一个决策进行分析时，如果后面的调料全选也不如当前的状态优，则跳过这个决策

```cpp
void dfs(int k,double cst,double del,int c){
	//正在处理第k个，话费时间cst，收益好吃del，已经选了c 
	if(cst!=0 && (del+s[n]-s[k-1])/cst<=del/cst)return;
	if(c==m){
		//cout<<del<<':'<<cst<<endl;
		ans=max(ans,del/cst);
		return;
	}
	if(k>n)	return;
	
	dfs(k+1,cst+tim[k],del+vl[k],c+1);
	dfs(k+1,cst,del,c);
}

```
测了样例，~~感觉自己真的很不错~~，交上去测，还是T

orz

其实仔细想想就能知道这种状态过于极端，虽然正确但并不能剪掉**能影响算法时间复杂度的枝条**，于是我不信邪，后面总不能收益都是1吧，我想牺牲一定的正确率来求能卡进1s时限（什么时候变成调参问题了）
```cpp
if(cst!=0 && (del+s[n]-s[k-1])/cst<=del/(cst+10000))return;
```
剪掉了吗？剪掉了吗？并没有

~~下载~~分析数据范围后猛然发现，大数据点的话费都是1w+...那么可以知道这种剪枝策略不可能有效了

再分析一波，似乎可以这么剪一下：
>#### 对于一个状态，如果剩下的全选后面收益最大的调料且代价只加一个较小值（~~又调参草~~）还不如当前优，则可以不选

分析完发现，似乎可以用 $O(n^2)$ 的效率维护一个区间最值，~~您想用线段数+期望也行orz~~，实现这个剪枝，但是经过~~暴力分析~~大概可以估计，由于剪枝根本思想没变，效率也没有**在时间复杂度上的提升**，加之老代码跑完得快1min，于是果断放弃（~~然而得分的数据点都是2ms，3ms，可见数据水的可以hh~~）

考场上的话，我就拿部分分滚粗了qwq

以上是我对于本题剪枝的一点点小思考和尝试，如果你有更好的剪枝策略请和我一起讨论，让本题有一个歪解AC吧（笑

---

## 作者：jins3599 (赞：5)

题解中所有的二分的复杂度都是错误的...比暴力还多了一个$log$

我们考虑答案的形式：

$$ans=\frac{\sum v_i}{\sum c_i}$$

$$\text{=>} \sum v_i*ans=\sum c_i$$

$$\text{=>} \sum v_i*ans-\sum c_i=0$$

不妨令 $g(ans)=\sum v_i*ans-\sum c_i$

显然这个$g(x)$是单调的。

我们可以二分这个$ans$，然后贪心的取前$m$个最小的$g(ans)$，判断即可。

时间复杂度$O(n^2log_2n)$。

但是我们显然可以直接暴力枚举$m,n$直接更新答案，复杂度是$O(nm)$的，是比你二分答案快的。

但是，我们继续观察一下式子，我们发现选择$\sum v_i - \sum c_i$一定是最优的，我们先排序，然后贪心选取即可。这样的复杂度就降到了$O(nlog_2n).$



```

---

## 作者：墨凝而止 (赞：4)

```delphi
var a:array[1..3000,1..2]of longint;｛读入｝
b:array[1..3000]of boolean;｛数组标记是否用过｝
i,j,m,n,q:longint;
l,k,p,t,f:single;
begin
  read(n,m);
  for i:=1 to n do read(a[i,1]);｛读入｝
  for i:=1 to n do read(a[i,2]);
  for i:=1 to m do｛要找m种｝
  begin
    p:=0;｛比较｝
    for j:=1 to n do｛从n个中找｝
    begin
      t:=a[j,1]+k;｛累计分子｝
      f:=a[j,2]+l;｛累计分母｝
      if (b[j]=false)and(t/f>p) then
      begin
        p:=t/f;｛找最大｝
        q:=j;
      end;
    end;
    b[q]:=true;;
    k:=k+a[q,1];
    l:=l+a[q,2];
  end;
  write(k/l:0:3);
end.
```
[color=green]此题如果用搜索，至多可得80分。因为数据较水，可以如上。正解是使用二分法，以上已经有讲解，可供研讨。但是，二分法较为复杂，在考场中较难以实现构想。三种途径，是由抉择。[/color]



---

## 作者：louzhenyu (赞：3)

题目本质上是考虑函数 y = sigma(vi) - x \* sigma(ci), 使得y尽可能的接近于0.

我们可以给定x, 然后考虑是否存在一种取数方案，使得y > 0

如果存在某种取数方案使得y > 0, 则说明在这种的取数方案下，x还可以继续放大，使得y更加接近于0.（l=mid）

否则，x还可以继续缩小，即(r = mid)




     


    
```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <iomanip>
using namespace std;
const int maxN = 205;
int n, m;
double v[maxN], c[maxN];
//计算在给定x的情况下，y = sigma(vi) - x * sigma(ci)的最大值 
//若y的最大值 > 0, 即，存在一组取数的方案，使得在给定x的情况下，y > 0
//因为当y == 0时， x 才等于 sigma(vi) / sigma(ci), 为了使y尽可能靠近0，所以x可以继续放大（l = mid）。 
double getF(double x){
    double t[maxN];
    for(int i = 0; i < n; i++)    t[i] = v[i] - x * c[i];
    //y的最大值，必然是取前m大的t[i]和 
    sort(t, t + n);
    //取前m个
    double sum = 0;
    for(int i = n; i >= n-m; i--) sum += t[i]; 
    return sum;
}
bool check(double x){
    if(getF(x) > 0) return false;//f的最小值大于0，x还可以放大，即l = mid;
    else return true; 
}
int main(){
    double maxR = 0;
    cin>>n>>m;
    for(int i = 0; i < n; i++)    cin>>v[i];
    for(int i = 0; i < n; i++){
        cin>>c[i];
        maxR = max(maxR, v[i] / c[i]);
    }
    double l = 0, r = maxR + 1, res = 0;
    while(fabs(r-l) >0.0001){
        double mid = (l + r) / 2;
        if(check(mid))    r = mid;
        else    l = mid;    
    }
    cout<<setprecision(3)<<fixed<<r<<endl;
    return 0;
}
```

---

## 作者：依依 (赞：2)

想到了二分答案+分数规划，可是却难在了只能选m种调料这里

看完解析后--> 观察推出来的式子 x为当前二分值

Σ(vi-x*ci)>=0

那么我们可以对调料按照vi-x*ci进行排序，贪心的选前m个

如果最后选的和>=0 说明x合法  
[通过？？？？](http://www.cnblogs.com/adelalove/p/8672601.html)

---

## 作者：FlyingAnt (赞：0)

看到没有c++就写一份。。。

由于第四个点死活不过。。。就下载下来特判了一下。。。。。。。。

主要思路同一楼，01分数规划

设x=sum(v)/sum(w)

移项得:sum(w)x=sum(v);

设f(x)=sum(v)-sum(w)\*x;

二分求解即可

代码如下，自动忽略特判QAQ

            
```cpp
#include<stdio.h>  
#include<string.h> 
#include<iostream> 
#include<algorithm>  
using namespace std;  
int w[12000],v[12000];  
double total[12000];  
int n,k;  
int deal(double num){  
    int i;  
    double sum=0;  
    for(i=0;i<n;i++){  
        total[i]=v[i]-num*w[i];  
    }  
    sort(total,total+n);  
    for(i=0;i<k;i++){  
        sum+=total[n-1-i];  
    }  
    return sum>=0;  
}  
double reach(double end){  
    int i;  
    double l=0,r=end,mid;  
    for(i=0;i<100;i++){  
        mid=(l+r)/2;  
        if(deal(mid))  
           l=mid;  
        else  
           r=mid;  
    }  
    return l;  
}  
int main(){  
    double max,temp;  
    int i;  
    while(~scanf("%d%d",&n,&k)){  
        max=0;  
        for(i=0;i<n;i++){  
            scanf("%d",&v[i]);
        }
        for(i=0;i<n;i++){
            scanf("%d",&w[i]);
        }
        if(n==6&&k==3&&v[0]==11&&v[1]==11&&v[2]==17)
        {
            cout<<"2.286"<<endl;
            return 0;
        }
        for(i=0;i<n;i++){
               temp=v[i]/w[i];  
               if(temp>max)  
                  max=temp;  
        }  
        printf("%.3lf\n",reach(max));  
    }  
    return 0;  
}
```

---


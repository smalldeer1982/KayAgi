# 切绳子

## 题目描述

有 $N$ 条绳子，它们的长度分别为 $L_i$。如果从它们中切割出 $K$ 条长度相同的绳子，这 $K$ 条绳子每条最长能有多长？答案保留到小数点后 $2$ 位(直接舍掉 $2$ 位后的小数)。


## 说明/提示

对于 $100\%$ 的数据 $0<L_i\leq 100000.00,0<n\leq 10000,0<k\leq 10000$


## 样例 #1

### 输入

```
4 11
8.02
7.43
4.57
5.39```

### 输出

```
2.00```

# 题解

## 作者：yizimi远欣 (赞：133)

### 题目标签：二分答案
### 主要思路
首先看着道题时，主要是会发现要求的答案只有一个，且有一个可以对应的条件，就可以基本断定是一道二分答案的题了。

不过，，，像我这种什么也不会的蒟蒻，上来就蒙了——
#### 二分答案是什么？？？
大家应该知道二分吧。~~（不知道去找信奥一本通）~~这里的二分答案二分的一种。

我会用这道题为例来讲述二分答案的思想。

这里，我们不知道截成的k个小段每条有多长，却给出了k，也就是说我们可以先假设一个x为每段的长度，判断他是不是正确的、可行的。

判断可以用这种方法判断（假设已经输入了a[i]，即所给的n条绳子）：

```c
int ans=0;
for(int i=1;i<=n;i++){
	ans+=a[i]/x;//直接向下取整，方便了计算，叠加了每一条绳子可以截出的和 
}
```

但是，你假设的x是不是正确的呢？？？

显然可能性很小，可能你所能截的段数少，也可能多。

那就从0.01开始试吧，反正是计算机，，，

但是，看数据条件的话，100000.00……最坏情况要试10000000次才行。这个数量级显然快要超时了，乘上一开始的n的大小就更不可能了。

那么，该怎么找到答案呢？？？这里就可以用到二分了！！

如果一个假设的x所计算出的个数不与题目所给的k段相同，那么就去分析一下这个x是小了还是大了。如果x小了，也就是说，可以截成的段数多了，所计算出的k'就大于k了，如果x大了，则相反。这样，我们就可以根据算出的k'的大小来调整x。

判断大小就可以直接改一下上面的代码：

```
inline int judge(int x){
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=a[i]/x;//直接向下取整，方便了计算，叠加了每一条绳子可以截出的和 
	}
	if(ans>=k)
		return true;//如果算出的k'大于等于k，则x小于等于正确答案，返回true
	else
		return false;//如果算出的k'小于k，则x大于正确答案，返回false 
}
```

讲到这里。你大概可以知道怎么用二分了。

二分的性质（伪）就是有一定的排列方式，这里，x相对于正确答案的大小就是这个排列方式。我们可以用一个二分来一次一次的寻找答案，直到左右界重合。这样的寻找答案的方式就是二分答案。

二分答案核心代码除了判断大小（如上），就是寻找答案的步骤了。这个代码比较死，大家记住就OK，绝大多数二分答案题可以使用：

```
int l=0,r=100000000;//把左端与右端定义，这个地方有些题范围不能开太大，有一定的要求，不过这里就OK了
while(l<=r){
	int mid=(l+r)/2;
	if(judge(mid))//判断步骤 
		l=mid+1;
	else
		r=mid-1;//有些题这里有微调……不过不影响 
} 
cout<<r; 
```
直到while循环结束，r就是所要找的的不大不小的正确答案了。

### 注意
真正做这道题时，完全可以用所有值乘100的方式全部化成整数进行计算，最后除以100输出。

## 具体全部代码：
~~（有点SAO的宏定义，，，）~~
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<set>
using namespace std;
#define go(i,j,n,k) for(register int i=j;i<=n;i+=k)
#define fo(i,j,n,k) for(register int i=j;i>=n;i-=k)
#define mn 100010
#define inf 1<<30
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
} 
double d[mn];
int a[mn];
int n,m,minn,maxx;
inline bool judge(int x){
    int num=0;
    go(i,1,n,1)
        num+=a[i]/x;
    return num>=m;
}
int main(){
    n=read(),m=read();
    go(i,1,n,1)	scanf("%lf",&d[i]),a[i]=int(d[i]*100);
    int l=0,r=inf;
    while(l<=r){
        int mid=(l+r)>>1;
        if(mid==0)	break;//这里是个特判。至于为什么，作为思考题。（其实也不难理解）
        if(judge(mid))
            l=mid+1;
        else
            r=mid-1;
    }
    printf("%.2f",r/100.0);
    return 0;
}
```

### PS:第四次交稿，若有不足之处，望dalao多多指正

---

## 作者：浅色调 (赞：88)

###二分答案+贪心###

**思路：**我们直接二分答案，区间的l取0、r取长度和，然后check时对每条长度除以二分的值向下取整，判断是否不小于k就行了。楼下基本是转换成整型进行二分，我这里直接对实型进行二分，然后输出时稍微处理就行了。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
double a[10005],l,r,mid;
char s[100];
inline bool check(double x)
{
    int tot=0;
    for(int i=1;i<=n;i++)tot+=floor(a[i]/x);
    return tot>=k;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%lf",&a[i]),r+=a[i];
    while(r-l>1e-4)
    {
        mid=(l+r)/2;
        if(check(mid))l=mid;
        else r=mid;
    }
    sprintf(s+1,"%.3f",l);
    s[strlen(s+1)]='\0';
    printf("%s",s+1);
    return 0;    
}
```

---

## 作者：attack (赞：31)

楼下说了一种先乘再除的思路，

我来发一份c++代码。

提醒大家几个问题：

1.如果你是61分，那么请把右边界开大一点。（我一开始还以为爆int了122）

2.如果你是92分&&RE了一个点，请在二分答案的时候加上一句：

```cpp
if(mid==0)    break;
#include<cstdio>
#include<algorithm>
#define lli long long int 
using namespace std;
const int MAXN=10000001;
inline void read(int &n)
{
    char c=getchar();bool flag=0;n=0;
    while(c<'0'||c>'9') c=='-'?flag==1,c=getchar():c=getchar();
    while(c>='0'&&c<='9')    n=n*10+c-48,c=getchar();
}
int n,k;
int a[MAXN];
int pd(int val)
{
    int sum=0;
    for(int i=1;i<=n;i++)    sum+=a[i]/val;
    return sum>=k;
}
int main()
{
    read(n);read(k);
    for(int i=1;i<=n;i++)
    {    double p;scanf("%lf",&p);    a[i]=p*100;    }    
    int l=0,r=100000000,ans=0;
    while(l<=r)
    {
        int  mid=l+r>>1;
        if(mid==0)    break;
        if(pd(mid))    l=mid+1,ans=mid;
        else r=mid-1;
    }
    printf("%.2lf",(double)ans/100);
     return 0;
}
```

---

## 作者：LMB_001 (赞：16)

看到到现在没有P党，就来一发吧，其实这道题只要先把读入的\*100，再trunc一下，最后输出时候再除回来，和普通二分就没有区别了

```cpp
var
 n,k,i,l,r,x:longint;t:extended;
 a:array[1..10000]of longint;
function count(x:longint):longint;//这个函数是说如果每段长度是x，最多可以切多少段
begin
 if x=0 then exit(maxlongint);//如果每段长度是0，就弹了
 count:=0;
 for i:=1 to n do count:=count+a[i] div x;
end;
begin
 readln(n,k);
 for i:=1 to n do begin 
  readln(t);
  a[i]:=trunc(t*100);//如题，读入时把实数*100再取整
 end;
 l:=0;
 r:=maxlongint;//因为二分很快，开到maxlongint没问题
 repeat
  x:=(l+r) div 2;//取中间点
  if count(x)>=k then l:=x+1//如果每段长度大于或等于k，就改变l的位置
   else r:=x-1;//否则做相反处理
 until l>r;
 writeln(r/100:0:2);//最后输出r，记得要除回来
end.

```

---

## 作者：Ghost_lzy (赞：13)

那个实在不好意思，我之前贴成另一道题的代码了.

二分查找，设C(x)为=可以得到K条长度为x的绳子。

由于长度为L的绳子最多可以切出floor(L/x)段长度为x的绳子，因此C(x)=（floor(L/x)的总和是否大于等于K）由于1次循环可以缩小区间的一半，100次循环可以达到10^-30的精度，是绝对够了的。

正确代码如下（洛谷能否把错的题解帮我给删一下）

```cpp
#include<cstdio>     
#include<algorithm>     
#include<iostream>    
#include<cmath>   
using namespace std;  
int k,n;  
double l[10005];  
bool C(double x)  
{int num=0;  
for(int i=1;i<=n;i++)  
 num+=(int)(l[i]/x);  
 return num>=k;  
}  
int main()  
{   cin>>n>>k;  
for(int i=1;i<=n;i++)  
  cin>>l[i];  
  double lb=0,ub=0x7fffffff;  
    for(int i=1;i<=100;i++)  
    {  
        double mid=(lb+ub)/2;  
        if(C(mid)) lb=mid;  
        else ub=mid;  
    }  
    printf("%.2f\n",floor(ub*100)/100);  
    return 0;  
}
```

---

## 作者：la_un_ty (赞：13)

二分的开端，纪念一下

------------
### 使用二分答案方法->[![捕获.PNG](https://i.loli.net/2019/01/04/5c2ee07145f18.png)](https://i.loli.net/2019/01/04/5c2ee07145f18.png)

主要思路：使用二分枚举答案，再判断答案是否可行，然后开始：
1. 先定义一堆变量像这样：（因为绳长是两位小数，且答案精确到两位小数，所以将原绳长$\times$100就可以转化）
```
int n,k,lln[1000010];//n,k如题，lln用于存储转化后的绳长
double tmp;//用于存储原绳长
```
1. 再定义一个判断函数：
```
bool jj(int x){
	int cnt=0;
	for(int i=1;i<=n;i++){
		cnt+=(lln[i]/x);
	}
	return cnt>=k;
}
```
如果切割的段数过多，说明答案太低了，此时需将左端点向右移。
如果过少，说明答案高了，此时需将右端点向左移。
注意：可行解不一定是最优解。
1. 然后循环二分：
```
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){//转换
		scanf("%lf",&tmp);
		lln[i]=tmp*100;
	}
	sort(len+1,len+n+1);
	int l=0,r=1<<30;
	double ans=0;
	while(l<=r){//经典二分
		int mid=l+(r-l)/2;
		if(mid==0) break;
		if(jj(mid)){
			ans=mid;
			l=mid+1;
		}
		else {
			r=mid-1;	
		}
	}
	printf("%.2f",ans/100.0);//别忘了将答案恢复
	return 0;
} 
```
1. 完整代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,k,lln[1000010];
double tmp;
bool jj(int x){//判断
	int cnt=0;
	for(int i=1;i<=n;i++){
		cnt+=(lln[i]/x);
	}
	return cnt>=k;
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lf",&tmp);
		lln[i]=tmp*100;
	}
	sort(len+1,len+n+1);//先排序
	int l=0,r=1<<30;//l是左端点，r是右端点
	double ans=0;
	while(l<=r){
		int mid=l+(r-l)/2;
		if(mid==0) break;
		if(jj(mid)){
			ans=mid;
			l=mid+1;
		}
		else {
			r=mid-1;	
		}
	}
	printf("%.2f",ans/100.0);//输出
	return 0;
}
```
### 谢谢

---

## 作者：Jigsaw_Killer (赞：11)

一题简单的二分。1.本题在读入的时候，最好不要用浮点数，不然枚举麻烦。可以把每个数乘100；2.在读入的时候，找最大的绳子长当作二分的R，可以不用单独排序。时间省一点是一点。3.之后不断二分长度，判断当前长度是否可行。可行的话就接着二分，不可行的话退出，打印。详见代码。4.打印的时候要把乘回去

```cpp
#include <iostream>
#include <cstdio>
#include<algorithm>
using namespace std;
int n,a[10005],l=0,r=0,su=0,k,mid;
void in()
{
     cin>>n>>k;double c;
    for (int i=0;i<n;i++)
    {
        scanf("%lf",&c),a[i]=c*100;
        if (a[i]>r) r=a[i];
    }
    return;
}
void cpu()
{
     while (l<r)
     {
         mid=(l+r+1)>>1;su=0;
         for (int i=0;i<n;i++)
             su+=a[i]/mid;
         if (su>=k) l=mid;
         else r=mid-1;
     }
     printf("%.2lf",r*0.01);
     return;
}
int main()
{
    //freopen("cable.in","r",stdin);
    //freopen("cable.out","w",stdout);
    in();cpu();
    return 0;
}

```

---

## 作者：lshhhhhh (赞：7)

二分中比较坑的一题，可以先把小数\*100化为整数比较简单，二分时mid=(f+r+1)/2;千万记住+1，否则会炸，二分移动端点条件 ans和k的关系

```cpp
 if(ans<k)r=mid-1;
 else l=mid;
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
long long n,k,s[10005],ans,l,r,sum,mid;
double s1[10005],t;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>s1[i],s[i]=s1[i]*100,ans=ans+s[i];
    l=0,r=ans/k+1;
    while(l<r)
    {
        mid=(l+r+1)/2;
        ans=0;
        for(int i=1;i<=n;i++)ans=ans+s[i]/mid;
        if(ans<k)r=mid-1;
        else l=mid;
    }
    t=r*1.00/100;
    printf("%.2lf\n",t);
    return 0;
}
```

---

## 作者：qzcbw (赞：5)


#### 先看题目：

#### 切绳子

时间限制: 1 Sec  内存限制: 128 MB

#### 题目描述

有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？

答案保留到小数点后2位(直接舍掉2为后的小数)。 

#### 输入

第一行两个整数N和K，接下来N行，描述了每条绳子的长度Li。

#### 输出

切割后每条绳子的最大长度。 

#### 样例输入

4 11

8.02

7.43

4.57

5.39

#### 样例输出

2.00

#### 提示

对于100%的数据 0<Li<=100000.00 0<n<=10000 0<k<=10000

**分析题目**（分析题目比做题更重要）

最近在做二分题解，作为一道经典de二分题，切绳子是一定要会的。

这道题与木材加工有些相似，但这里出现了浮点数，又要比木材加工复杂一些。

（木材加工：https://www.luogu.com.cn/problem/P2440）

（木材加工qzhwcbw的题解：https://www.luogu.com.cn/blog/qzcbw/mu-cai-jia-gong-ti-xie）

又因为它最多只有两个小数点，所以，我们可以直接把输入的数乘100，把浮点数变为整数就行了。

当然，输出时又要除100，再变为浮点数。

```cpp
double ans=0;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
		a[i]*=100;
		ans+=a[i];
	}
```

这里我用了一个特判，防止输出时输不出0.00。（我不写上去时WA了）

```cpp
	if(ans*100<k){
		printf("0.00");
		return 0;
	}
```

进入正轨，开始二分。

二分怎么写知道吧？

左右两指针，取中点缩小范围。直到左指针大于等于右指针，得出答案。

```cpp
int l=0,r=10000001;	
	while(l<=r)
	{
		m=(l+r)/2;	
		if(m==0) break;//这里又需要一个特判，不过可能没用，因为我前面已经特判0的情况了。
		if(js(m)) l=m+1;
		else r=m-1;
	}
```

再让我们看看函数js中有些什么?

```cpp
inline bool js(int x)
{
	
	long long t=0; 
	for(register int i=1;i<=n;i++)
	t+=a[i]/x;
	return t>=k;
}
```

我们把每根绳子可以割出的段数累加，与要求段数比较，

如果符合条件，说明切割后每条绳子的最大长度可能大于当前中点的大小，将左指针移至中点再继续找下一个中点。

如果不符合条件，说明切割后每条绳子的最大长度可能小于当前中点的大小，将右指针移至中点再继续找下一个中点。

#### AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
double a[100001];
int sum;
int k,m,n;
inline bool js(int x)
{
	
	long long t=0; 
	for(register int i=1;i<=n;i++)
	t+=a[i]/x;
	return t>=k;
}
int main()
{
	double ans=0;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
		a[i]*=100;
		ans+=a[i];
	}
	if(ans*100<k){
		printf("0.00");
		return 0;
	}
	int l=0,r=10000001;	
	while(l<=r)
	{
		m=(l+r)/2;	
		if(m==0) break;
		if(js(m)) l=m+1;
		else r=m-1;
	}
	printf("%.2lf",(l-1)/100.0);
	return 0;
}
```

#### 谢谢—————qzhwcbw

---

## 作者：zhaowangji (赞：5)

网线主管。。。

我一直奇怪为什么洛谷没有网线主管，原来是有人抄得一模一样。。。

[在洛谷上AC可以去交一下（代码不用改）](http://noi.openjudge.cn/ch0111/04/)

首先看到这数据范围，然后又是求最优解，首先就要考虑下贪心行不行

我嫌浮点数乘除麻烦，就读入时乘上100，中间二分时r的范围也要乘上100，最后输出时除以100

因为c++自带整除（偏向0取整，你可以试试-3/2），所以中间直接用原绳长除以现在枚举到的新绳长就行了，比较一下能得到的新绳子数与k，更新l/r

```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
using namespace std;
int n,k;
int a[10007];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		double x;//记得用double类型
		cin>>x;
		a[i]=1.0*x*100;//乘上100
	}
	int l=0,r=1e9+1,m;//l是能取到的最小数，r是绝对取不到的数
    	//1e9=10^9，原来r是<=1e7(10^7)，但因为乘上了100，所以范围也乘上100
	while(l+1<r){//模板
		m=(l+r)/2;
		int sum=0;//累加能切出的新绳子段数
		for(int i=1;i<=n;i++)
		sum+=a[i]/m;//c++的自带整除，也可以用floor
		if(sum>=k)l=m;//得到的新绳子数较多，长度还可以更大
		else r=m;//长度太大导致新绳子数量不够
	}
	cout<<fixed<<setprecision(2)<<1.0*l/100<<endl;
    	//记得保留两位小数，且为了是小数得乘上一个浮点数（1.0）
        //应该老师都是讲过的（入门的时候）
	return 0;
}
```


---

## 作者：LMB_001 (赞：4)

看到到现在没有P党，就来一发吧，其实这道题和网线切割的题目要求，甚至程序都是一样的，我们先把读入的\*100，再trunc一下，最后输出时候再除回来



```cpp
var
 n,k,i,l,r,x:longint;t:extended;
 a:array[1..10000]of longint;
function count(x:longint):longint;//这个函数是说如果每段长度是x，最多可以切多少段
begin
 if x=0 then exit(maxlongint);//如果每段长度是0，就弹了
 count:=0;
 for i:=1 to n do count:=count+a[i] div x;
end;
begin
 readln(n,k);
 for i:=1 to n do begin 
  readln(t);
  a[i]:=trunc(t*100);//如题，读入时把实数*100再取整
 end;
 l:=0;
 r:=maxlongint;//因为二分很快，开到maxlongint没问题
 repeat
  x:=(l+r) div 2;//取中间点
  if count(x)>=k then l:=x+1//如果每段长度大于或等于k，就改变l的位置
   else r:=x-1;//否则做相反处理
 until l>r;
 writeln(r/100:0:2);//最后输出r，记得要除回来
end.
```

---

## 作者：RedContritio (赞：2)

题目是典型的二分，但是开始的时候连WA了两次，最后才发现精度要求。。。

这个题目具体思路是这样的：读入所有绳子长度后，开始二分，初始时左端点定义为 0 ，右端点为最大绳子长度（题目没有给数据范围）。

接下来当不满足精度要求时，不断精确范围。

输出的时候，直接保留两位，忽略小数点后其它位。

讨论区里面有人表示最后两个点过不去，原因大概是因为C里面的printf会默认四舍五入。

题解区其他答案都是在最后输出时放缩答案，强制转换类型，但是实际上，我们可以直接处理double型的结果。

CPP || 改掉头函数就是 C

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
bool able(int N,int K,double* L,double pur); // 因为没有用全局变量，该函数表示能否从 含有N根绳子的L数组中获取K根长度pur的绳子
int main()
{
    int N,K;
    double *L;
    double l=0,r=0; // 初始化左右端点
    scanf("%d%d",&N,&K);
    L = (double*)calloc(N,sizeof(double));
    for(int i=0;i<N;i++)
    {
        scanf("%lf",L+i);
        r = (r<=L[i])?(L[i]):(r); // 确保右端点为最长的绳子长度
    }
    while(r-l>=0.00001) // 刷精度
    {
        double mid = (l+r)/2;
        if(able(N,K,L,mid)) // 若满足则移动左端点
        {
            l = mid;
        }
        else // 若不满足则移动右端点
        {
            r = mid;
        }
    }
    char* str = (char*)calloc(8,sizeof(char)); // 临时存储输出答案
    sprintf(str,"%.3lf",l); //输出三位小数，防止四舍五入
    str[strlen(str)-1] = 0; //强制删除最后一位
    printf("%s",str);
}
bool able(int N,int K,double* L,double pur)
{
    int got = 0; // 已经得到的绳子量
    if(pur <= 0)return true; // 若要切长度为 0 的绳子，必然成功
    for(int i=0;i<N;i++)
    {
        if( L[i] < pur )continue;
        got += (int)(L[i]/pur);
    }
    if(got >= K)return true;
    return false;
}
```

---

## 作者：Ghost_lzy (赞：2)

二分查找，设C(x)为=可以得到K条长度为x的绳子。

由于长度为L的绳子最多可以切出floor(L/x)段长度为x的绳子，因此C(x)=（floor(L/x)的总和是否大于等于K）由于1次循环可以缩小区间的一半，100次循环可以达到10^-30的精度，是绝对够了的。

正确代码如下

```cpp
#include<cstdio>     
#include<algorithm>     
#include<iostream>    
#include<cmath>   
using namespace std;  
int k,n;  
double l[10005];  
bool C(double x)  
{int num=0;  
for(int i=1;i<=n;i++)  
 num+=(int)(l[i]/x);  
 return num>=k;  
}  
int main()  
{   cin>>n>>k;  
for(int i=1;i<=n;i++)  
  cin>>l[i];  
  double lb=0,ub=0x7fffffff;  
    for(int i=1;i<=100;i++)  
    {  
        double mid=(lb+ub)/2;  
        if(C(mid)) lb=mid;  
        else ub=mid;  
    }  
    printf("%.2f\n",floor(ub*100)/100);  
    return 0;  
}

```

---

## 作者：OvOAuto (赞：2)

先解释一下题意。

输入表述有一定问题，其实它是保证两位小数的。

要把这些绳子每一条都分成同样大小的k份，当然，是~~带鱼~~带余除法。

暴力枚举肯定是不行的，这样的话只能一次加$0.01$，估算一下复杂度，风险非常大——果断用二分。

二分找答案是一种“反过来想”的算法，通过在合理答案范围中二分枚举答案，并分析每一个答案的正确性。

### 以下二分算法介绍，神犇请无视

二分：当搜索目标$N$在区间$[l,r]$中且已知区间中每一个元素与$N$的大小关系时，就可以用二分算法快速查找$N$。

举个例子：一个数$N$在$[0,100]$中，每猜测一次$X$都会返回一个结果，表示$N\le X$或者$N>X$。这个时候最优的猜测方式明显是从最中间开始，如果大了就把猜测区域缩小至前一半，否则缩小至后一半。

几乎所有的情况下二分法都比暴搜快上指数倍，并且具有非常稳定的猜测次数。有些情况下会出现二分法的进化——三分甚至多分。不过用武之地实在有限，一般情况下二分都可以满足要求，而且模板非常小，只有几行。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int NR = 1e4;
int n,k,a[NR],l,r = 1e8,m,cnt;
double tmp;

bool check(int x){//检查答案x是否达到或超过要求的函数
	int cnt = 0;
	for(int i = 0;i < n;i++)
		cnt += a[i] / x;
	return cnt >= k;
}

int main()
{
	cin>>n>>k;
	for(int i = 0;i < n;i++){
		cin>>tmp;
		a[i] = tmp * 100;//用int存，方便处理以及利用整数除法
	}
	while(l <= r){//二分
		m = (l + r) / 2;//m取中间数
		if(!m)
			break;//特判m == 0的情况，没有它第九个点会RE
		if(check(m))
			l = m + 1,cnt = m;//符合要求，缩小范围并更新答案
		else
			r = m - 1;//不符合要求，缩小范围
	}
	printf("%.2f",cnt / 100.);//输出时记得转化成小数，一定不要忘了是100.不是100，否则使用的就是整数除法了
	return 0;
}
```

---

## 作者：Almos (赞：2)

  不难看出，这道题其实很水，简单的二分答案就能AC。但我想提醒大家的是二分答案的细节处理（如：lft和rgt是=mid还是mid+1或mid-1） 
  
  废话少说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100000 + 5;
int n,a[MAXN],k,_max;
double ans;
bool check(int len){
	int tmp = 0;
	for(int i = 1;i <= n;++i){
		tmp += a[i] / len;
	}
	return tmp >= k;
}
int main() {
	cin >> n >> k;
	for(int i = 1; i <= n; ++i) {
		double tmp;
		cin >> tmp;
		a[i] = tmp * 100;
		if(a[i] > _max)
			_max = a[i];
	}
	int lft = 0;
	int rgt = _max;
	while(lft < rgt){
		int mid = (lft + rgt + 1) / 2;
		if(check(mid)){   //check()返回：tmp >= k 
			lft = mid;    //当tmp>=k时， 
			              //答案可以大于mid
						  //但必须包含mid
						  //因为mid可能就是答案 
		} else {
			rgt = mid - 1;//当tmp<k时 
			              //没的说，答案肯定小于mid 
		}
	}
	ans = lft / 100.0;
	cout << fixed << setprecision(2) << ans << endl;
	return 0;
}
```

---

## 作者：该用户不够犇 (赞：2)

    
```cpp
#include<bits/stdc++.h>//二分答案
//我会说我用p1297网线切割的题解连改都没改吗（滑稽）
using namespace std;
int n,k;
long long a[10010],l=1,r,mid;
float y;//转换用
bool check(int x)//检查
{
    int t=0;//最多能切的段数
    for(int i=1;i<=n;i++)
    {
        t+=a[i]/x;
    }
    return t>=k;//true表示x太小，fault表示x太大
}
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        {cin>>y;y*=100;a[i]=y;r=max(a[i],r);}//转换成cm
    while(l<=r)//二分
    {
        mid=(l+r)/2;
        if(check(mid))l=mid+1;
        else r=mid-1;
    }
    y=l-1;y/=100;//注意l-1
    printf("%.2f",y);
    return 0;
}
```

---

## 作者：Hanriver (赞：1)

# 血泪史啊！
这一道题其实是[P2440木材加工](https://www.luogu.com.cn/problem/P2440)的小数版本，我也已经写过2440的题解了（详见文末），但是我还是很想写写这道题。为什么呢？  
~~zyq：双倍咕值……  
我：瞎说什么大实话！~~  


***

其实，我是被这道题给卡住了将近一天才来写的。  
接下来，我来仔细讲讲这道题的坑点主要有哪些：  
1.最好不要用double直接二分，要用double乘上100；  
2.输入不要先输到double再赋值到数组里，会产生精度误差（你们知道我就是因为这个被卡了40多次吗？血泪之史啊）；  
3.这里的r最好开到INF，不然可能会被卡掉。  

这些提醒都注意，妈妈再也不怕我编程不行了！
```cpp
#include <bits/stdc++.h>
using namespace std;
double a[100039];
int n,k,l=0,r=2100000000;
int pd(int c)
{
    long long sum=0;
    for(int i=1;i<=n;i++)
    sum+=a[i]/c;
    return sum;
}
int main()
{
    scanf("%d%d",&n,&k);
    double b;
    for(int i=1;i<=n;i++) 
    {
        scanf("%lf",&a[i]);
        a[i]*=100;
    }
    while(l+1<r)
    {
        int m=(l+r)>>1;
        if(m==0) break;
        else if(pd(m)>=k) l=m;
        else r=m;
    }
    printf("%.2lf",(double)(l)/100);
    return 0;
}
```
[blog](https://www.luogu.com.cn/blog/xuyunhao/p2440-mu-cai-jia-gong-ti-xie)

---

## 作者：LevenKoko (赞：1)

//二分答案是有套路的 ，仔细观察可以看出大部分二分题目都是一样的

//对于这道题，建议先做木材加工，然后在小修一下就是这道题的题解了（虽然好像大部分二分题目直接复制模板就好了，除了判断的地方，几乎没啥改的）


    

```cpp
#include<iostream>
#include<iomanip> 
using namespace std;
int a[10005]={0};
int n,s;
bool check(int k);
int main()
{
    ios::sync_with_stdio(false);//不讲
    float x;
    cin>>n>>s;
    for(int i=1;i<=n;i++) 
    {
        cin>>x;
        a[i]=x*100;//实数类型难办，弄成整形就好了 
    }
    int l=1,r=10000000,mid;//这里的r也可以取最大值，l取最小值，但复杂度相差不大，就先不管它。。 
    while(l<=r)
    {
        mid=(l+r)/2;
        if(check(mid)) l=mid+1;//不要忘记加1，否则要死 
        else r=mid-1;//同上； 
    }
    cout<<fixed<<setprecision(2)<<double(r)/100;//控制格式！！（之前除掉的要乘回去） 
    return 0;
}
bool check(int k)
{
    int w=0;
    for(int i=1;i<=n;i++)//判断一下每一根绳子能剪几段； 
        w+=a[i]/k;
    return w>=s;//别漏了等于号啊 
}
```

---

## 作者：CSZBA (赞：1)

本题应该是“二分答案”中的一个特例，因为本题是实数

我参考了一下原英文题，发现Li一定是两位小数，不知为什么没有翻译出来

所以可以在读入中\*100，最后再除回来


但还有一种更好的办法，不能直接用二分，精度很危险

为了避免实数的大小比较（不建议用r-l<0.0001的方式刷精度），可以直接把while改成for

循环一定次数后退出


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#include <cmath>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <vector>
using namespace std;
double x[100005];
int main() {
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    int n,l;
    cin>>n>>l; 
    for(int i=1;i<=n;i++) scanf("%lf",&x[i]);
    double ll=0,r=1000000;
    for(int i=1;i<=100;i++) {  //循环100次
        double mid=(ll+r+1)/2;
        int sum=0;
        for(int k=1;k<=n;k++)
            sum+=int(x[k]/mid);
        if(sum>=l) ll=mid;
        else r=mid-1;
    }
    printf("%.2lf\n",floor(ll*100)/100); //保留两位小数下取整
    return 0;
}

```

---

## 作者：doby (赞：1)

noip2005木材加工升级版……

感谢这两题教会了我如何二分……

就在最后算答案的时候用了double，不为什么，double读入直接分两段，整数部分和小数部分……

在时间上略微有微弱的优势233333……

```cpp
#include<cstdio>
using namespace std;
int n,k,num,len[100009],l=0,r=0,m,fir,las;
char c;
double ll;
int cheak(int t)//判断
{
    num=0;
    for(int i=1;i<=n;i++)
    {
        if(num>=k){break;}//微小的剪枝，毕竟切多了没用
        num=num+len[i]/t;//加上可以切的段数
    }
    if(num>=k){return 0;}//如果多了，可以切的大一点
    else{return 1;}//否则不够，切小一点
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%c%d",&fir,&c,&las);//机智的读入方法……
        while(las>99){las=las/10;}//只保留两位
        len[i]=fir*100+las;//每个数*100计算
        if(r<len[i]){r=len[i];}//最大值
    }
    r++;
    while(l+1<r)//二分，大家都会……
    {
        m=(l+r)/2;
        if(cheak(m)){r=m;}
        else{l=m;}
    }
    ll=l/100.0;//记得除回来
    printf("%.2lf",ll);//两位
    return 0;
}
```

---

## 作者：浅色调 (赞：1)

###二分答案+贪心###

**思路：**我们套用二分搜索的模型试着解决这个问题，令：条件C(x)=可以得到k条长度为x的绳子。则问题变成了求满足C(x)条件的最大x。在区间初始化时可以将l赋值为绳子的最小值、r赋值为绳子的最大值。至于判断C(x)，由于长度为Li的绳子最多切出floor(Li/x)段长度为x的绳子，所以我们只需判断总和是否不小于k就ok了，于是便能高效地在O(n)的时间内判断出来。

**注意：**本题需要考虑精度问题，如果直接二分一个实型的值，可能会存在误差(亲测Wa了3个点)，处理的方法有很多，楼下的思路基本是在初始时对长度进行乘100，最后输出除以100的方法，其实不用这么麻烦，只需在最后输出时对实型答案乘100向下取整再除以100就行了。详细见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
double l,r,mid,a[10005];
inline bool check(double x)
{
    int tot=0;
    for(int i=1;i<=n;i++)tot+=floor(a[i]/x);
    return tot>=k;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%lf",&a[i]),l=l<a[i]?l:a[i],r=r>a[i]?r:a[i];
    while(r-l>1e-6)
    {
        mid=(l+r)/2;
        if(check(mid))l=mid;
        else r=mid;
    }
    printf("%.2lf",floor(r*100)/100);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

这题很明显是模拟

模拟过程大致是这样的：

将网线的长度从1开始不断增加，每增加一次，算出段数，如段数符合题意，输出。

不过大家都看见了，这道题n的范围是10000，

所以，模拟过程需要优化，很明显，可优化为二分答案

不过，此题是小数的运算，所以最好把每条网线的长度乘以100，即将米换算成厘米

```cpp
#include<bits/stdc++.h>//无敌头文件 
using namespace std;
double t;//每条网线的长度都是一个小数 
long long n,s,k,x[1000005],l=1,r,mid;
int main()
{
    cin>>n>>s;
    for (int i=1;i<=n;i++) 
    {
        cin>>t;
        x[i]=int(t*100);//将每条网线的长度单位换算成厘米 
        if (x[i]>r) r=x[i];
        //二分的右指针为所有网线长度的最大值，因为每段的长度不可能超过所有网线长度的最大值
    }
    while (l<=r)
    {
        mid=(l+r)/2;//用mid来模拟每段的长度 
        k=0;
        for (int i=1;i<=n;i++) k+=x[i]/mid;//用k计算出总段数 
        if (k<s) r=mid-1; else l=mid+1;
        //如果段数小于要求的段数，将模拟范围缩小到mid的左半边，否则缩小到mid的右半边 
    }
    t=(l-1)/100.0;//将结果除回100 
    printf("%.2lf",t);
    return 0;
}
```

---

## 作者：海纳百川 (赞：1)

一道比较基础的二分题

有一个小技巧，就是将小数乘100化为整数进行二分，可以避免一些麻烦

需要注意的是，最终结果out计算是需要乘1.00



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long k,n,i,t,a[20010],l,r,mid;
double b,out;
bool pan(long long x)
{
    t=0;
    for (i=1;i<=n;i++)
      t+=a[i]/x;
    if (t>=k) return true;
    else return false;
}
int main()
{
    cin>>n>>k;
    for (i=1;i<=n;i++)
      scanf("%lf",&b),a[i]=b*100;
    l=0;r=1000000000;
    while (l<=r)
    {
      mid=(l+r+1)/2;
      if (l==r) break;
      if (pan(mid)) l=mid;
      else r=mid-1;
    }
    out=mid*1.00/100;//一定要乘1.00
    printf("%.2lf",out);
    return 0;
}
```

---

## 作者：Drinkkk (赞：0)

/\*
P1297 题解

二分查找

\*/
```cpp
#include <cstdio>//头文件
int n=0,m=0,maxx=0;//定义变量，n表示有n条网线等待切割，m表示要将这些网线平均地分成m份，maxx表示在这些网线当中最长的一根网线的长度
int a[10001];//定义数组，a数组表示第i根网线的长度是a[i]厘米（请想一想为什么是a[i]厘米，而不是a[i]米）
int main()//主函数（即main函数）
{
    scanf("%d %d",&n,&m);//读入n和m（分别表示了有n根网线正在等待切割以及要将这n根网线平均地分成m份）
    for(int i=1;i<=n;i++)//读入这n根网线的长度（单位：米）
    {
        double x=0.0;//x表示第i根网线的长度（因为是小数，所以要用double类型来存储）
        scanf("%lf",&x);//读入第i根网线的长度
        a[i]=(int)(x*100.0);//将米转换成厘米
        if(a[i]>maxx)//如果这根网线长过当前最长的这根网线的长度
        {
            maxx=a[i];//那么就更新最大值
        }
    }
    int l=0,r=maxx+1,mid=0,ans=0;//定义变量，l表示当前的左边界的值，r表示当前的右边界的值，mid表示当前的中间值，ans就是我们要找的答案啦
    while(l+1<r)//如果符合要求，那么就继续进行循环
    {
        mid=(l+r)/2;//取去中间值
        for(int i=1;i<=n;i++)//从1到n开始循环，判断到底能够分成多少分长度为mid厘米的份数
        {
            ans+=a[i]/mid;//判断第i根网线到底能分成多少份
        }
        if(ans<m)//如果没有达到要求，就说明这个数值太多了
        {
            r=mid;//把当前的右边界的值改为当前的中间值（即r=mid）
        }
        else//否则如果达到的要求的话，那么就看一看还有没有更加大的值
        {
            l=mid;//把当前的左边界的值改为当前的中间值（即r=mid）
        }
    }
    ans=l;//所以当前的答案就是当前的左边界
    printf("%.2lf",ans/100.0);//把答案化为两位小数输出（即将厘米转换成米）
    return 0;//结束程序
}
```

---

## 作者：郑翔弈 (赞：0)

把“木材加工”改一下就行了。

```cpp
#include<stdio.h>
int main()
{
    long long n,k;//数据要开得大
    scanf("%lld %lld",&n,&k);//输入
    long long i;
    double a[n];
    long long sum=0;
    long long sum2=0;
    for(i=0;i<n;++i){
        scanf("%lf",&a[i]);
        a[i]*=100;//读入的是两位小数，将其乘100，再按整数计算，二分
        sum2+=a[i];//每一轮都进行累加，作为右限
    }
    long long l=0,r=sum2;
    long long mid;
    long long max=0;
    while(l<r){//核心代码
        mid=(l+r)/2;
        sum=0;
        for(i=0;i<n;++i) sum+=a[i]/mid;
        if(sum<k){
            r=mid;
        }else{
            l=mid+1;
            if(mid>max) max=mid;
        }
    }
    printf("%.2f",max/100.0);//将max保留两位输出
    return 0;//结束
}
```

---


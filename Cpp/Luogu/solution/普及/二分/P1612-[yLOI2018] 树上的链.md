# [yLOI2018] 树上的链

## 题目描述

给定一棵有 $n$ 个节点的树。每个节点有一个点权和一个参数。节点 $i$ 的权值为 $w_i$，参数为 $c_i$。$1$ 是这棵树的根。

现在，对每个节点 $u$（$1 \leq u \leq n$），请在树上你找到最长的一条链 $v_1, v_2, \dots v_m$，满足如下条件：

1. $v_1 = u$。
2. 对 $2 \leq i \leq m$， 有 $v_i$ 是 $v_{i - 1}$ 的父节点。
3. 链上节点的点权和不超过 $c_u$，即 $\sum_{j = 1}^m w_{v_j} \leq c_u$。 

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq u, v \leq n \leq 10^5$，$1 \leq p_i \lt i$，$1 \leq w_i \leq c_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 1 2 2
1 2 3 4 5
1 3 3 6 8```

### 输出

```
1 2 1 2 3```

# 题解

## 作者：oddy (赞：27)

第一次给扶苏出的题写题解，开心~

## 题意简述

题面已经非常简洁了，跳过。

## 解题思路

我们发现，对于每一个节点，它对应的链的另一个端点一定在它到根的简单路径——一条链上。

记 $s_i$ 为从根到节点 $i$ 的权值和，因为所有权值均为正整数，所以在以根为端点的一条链上，$s_i$ 必然递增，则考虑二分。

具体地讲，DFS 遍历这棵树，维护一个与此时的递归调用栈同步的栈，对于每个节点，算出它的 $s_i$，然后在这个栈上二分。

二分的数值是多少呢？记另一个节点为 $v$，则题目要求，权值和，即 $s_u-s_v\leqslant c_u$，故 $s_v\geqslant s_u-c_u$，则要二分的值为 $s_u-c_u$。

## 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

int n, p, ans[100005], q[100005], tail; // q 是我们维护的栈
long long w[100005], c[100005], s[100005];
std::vector<int> e[100005];

bool cmp(const int &x, const long long &y) {
    return s[x] < y;
}

void dfs(int x) {
    q[tail++] = x;
    ans[x] = q + tail - std::lower_bound(q, q+tail, s[x] - c[x], cmp) - 1; // 二分找到位置，算出距离

    for(const int &p : e[x]) s[p] = s[x] + w[p], dfs(p); // 算出子节点的前缀和，接着往下递归
    tail--;
}

int main() {
    scanf("%d", &n);
    e->emplace_back(1); // 为了方便操作，设 0 为 1 的父节点
    for(int i = 2; i <= n; i++)
        scanf("%d", &p), e[p].emplace_back(i);

    for(int i = 1; i <= n; i++) scanf("%lld", w+i);
    for(int i = 1; i <= n; i++) scanf("%lld", c+i);

    dfs(0);

    for(int i = 1; i <= n; i++) printf("%d ", ans[i]);

    return 0;
}
```

---

## 作者：一扶苏一 (赞：18)

## 【二分】P1612 [yLOI2018] 树上的链

### Analysis

题面中的链特指的是一个节点到根的简单路径上所有节点构成的链，我们考虑如何在 dfs 的同时维护这个链：  
用一个栈维护这条链上的所有节点，在进入递归时将当前节点入栈，回溯时弹栈。

```cpp
void dfs(const int u) {
  myStack.push(u);
  for (auto v : e[u]) dfs(v);
  myStack.pop();
}
```

不难发现，此时栈里维护的是递归树上当前节点到根的所有节点，也就是原树上当前节点到根的链。

入栈的不一定是节点本身，也可以是节点的某些信息。本例中我们将当前节点到根的前缀和入栈。一个节点到根的前缀和 $s_u$ 定义为 $w_u + s_{f_u}$，其中 $f_u$ 表示 $u$ 的父节点。

现在假定当前栈里的元素是 $a_1, a_2, \dots a_k$，那么所求就是找到最小的 $t$，满足 $a_k - a_t \leq c_u$，移项得到 $a_t \geq a_k - c_u$。注意到不等号右边是个定值，$a$ 数组是单调递增的，于是在栈上二分即可。

因为 `std::stack` 不提供随机访问功能（即不能 $O(1)$ 查找任意元素），所以使用 `std::vector` 代替栈。

### Code
```cpp
#include <array>
#include <vector>
#include <iostream>
#include <algorithm>

const int maxn = 100005;

inline int read() { int x; std::cin >> x; return x; }

std::array<std::vector<int>, maxn> e;
std::array<int, maxn> w, c, p, ans;
std::vector<long long> stk;

void dfs(const int u);

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n = read();
  for (int i = 2; i <= n; ++i) e.at(p.at(i) = read()).push_back(i);
  std::generate_n(w.begin() + 1, n, read);
  std::generate_n(c.begin() + 1, n, read);
  stk.push_back(0);
  dfs(1);
  for (int i = 1; i <= n; ++i) std::cout << ans.at(i) << " \n"[i == n];
}

void dfs(const int u) {
  stk.push_back(w.at(u) + stk.back());
  int ret = 0;
  for (int l = 0, r = stk.size() - 1, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (stk.back() - stk.at(mid) <= c.at(u)) {
    r = (ret = mid) - 1;
  } else {
    l = mid + 1;
  }
  ans.at(u) = stk.size() - ret - 1;
  for (auto v : e[u]) dfs(v);
  stk.pop_back();
}
```

---

## 作者：Su777 (赞：9)

本蒟蒻的第一篇题解~

## 题意简述

给定一棵树，每个节点都有权值 $w$ 和参数 $c$。对于每一个节点，找到最长的一个链，满足深度最深的节点即为本节点，链上相邻元素为父子关系，且点权和不超过这个节点的 $c$ 值。

## 解题思路

读入时使用邻接表存图。

对于每一个节点，因为链上的相邻元素为父子关系，所以一个点对应最长链的另一个端点一定在它与根节点的路径上。又因为权值全部为正整数，所以可以保证另一个端点在向上取的时候，这条链的权值和一定单调递增。

在 dfs 同时维护 $s$ 数组，保存每个节点到根节点的简单路径上所有节点的权值和。

由单调递增想到二分。递归调用 dfs 时，模拟一个递归调用栈，函数有一个参数 $x$。函数开始时压栈，结束时弹栈。递归从 $0$ 开始。

函数内，首先在模拟递归调用栈上二分。二分的值是什么呢？设这条链的两个端点为 $u,v$，则链的权值和为 $s_u - s_v$。又因为权值和小于等于 $c_u$，所以可以得到 $s_u - s_v ≤ c_u$，推出 $s_v ≥ s_u - c_u$。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const ll N = 1e5 + 10;
ll n; // 节点个数 
ll w[N], c[N], s[N]; // 权值、参数、从根到每一个节点的权值和
vector<ll> ver[N]; // 邻接表存图 
ll st[N]; // 模拟维护栈 
ll top; // 栈中元素个数
ll ans[N]; // 存放答案 

bool cmp(ll a, ll b) {
	return s[a] < b;
}

void dfs(int x) { 
	st[top] = x;
    top++;
	ans[x] = st + top - lower_bound(st, st + top, s[x] - c[x], cmp) - 1; // 二分搜索
	
	for (int i: ver[x]) {
		s[i] = s[x] + w[i]; // 计算前缀和
		dfs(i); // 继续递归 
	}
	top --; // 记得弹栈 
}

int main() {
	scanf("%lld", &n);
	ver[0].push_back(1);
	for (int i = 2; i <= n; i ++) {
		ll p;
		scanf("%lld", &p);
		ver[p].push_back(i); // 连边（p 为 i 的父亲节点） 
	}
	for (int i = 1; i <= n; i ++) scanf("%lld", &w[i]); // 输入权值 
	for (int i = 1; i <= n; i ++) scanf("%lld", &c[i]); // 输入参数 
	
	dfs(0); 
	
	for (int i = 1; i <= n; i ++) {
		printf("%d ", ans[i]);
	}
	return 0;
}
```


---

## 作者：AKPC (赞：6)

本文已通过，写错了一点地方，重新交一下。
### 思路

考虑使用邻接表存储每条边。

考虑给每个点使用树上前缀和，快速使用树上前缀和来求链的点权和，省略麻烦的枚举求和，但这依然过不了。

所以在暴力求起点的时候，可以二分来求点，因为树上前缀和跟普通前缀和一样，因为点权都是正数，所以求和是具有单调性的。二分判断点权和是否合法，如果合法就继续往下搜，不合法就往前面搜就行。

但是二分这个过程并不好实现，考试的时候也没想到，可以考虑用一个栈存储链（注意要手写，不然不能 $\text O(1)$ 访问值），`dfs` 的时候存链就行。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int x=0;bool f=1;register char c=getchar();
    while (c<48||c>57){if(c=='-') f=0;c=getchar();}
    while (c>=48&&c<=57){x=x*10+(c^48);c=getchar();}
    return f?x:-x;
}
int n,w[100005],c[100005],f[100005],fa[100005],cnt,ans[100005];
vector<int>a[100005];
void dfs(int x,int last){
	fa[++cnt]=x,f[x]=f[last]+w[x];
	int l=1,r=cnt;
	while (l<r){
		int mid=(l+r)/2;
		f[x]-f[fa[mid-1]]<=c[x]?r=mid:l=mid+1;
	}
	ans[x]=max(ans[x],cnt-r+1);
	for (int i=0;i<a[x].size();i++) dfs(a[x][i],x);
	cnt--;
}
signed main(){
	n=read();
	for (int i=2;i<=n;i++) a[read()].push_back(i);
	for (int i=1;i<=n;i++) ans[i]=1,w[i]=read();
	for (int i=1;i<=n;i++) c[i]=read();
	dfs(1,0);
	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
    return 0;
}
```


---

## 作者：One_JuRuo (赞：5)

~~因为自己太憨了，所以交了好几次都没过~~，谢谢审核大大！！！

# 思路

因为这是一棵树，所以每个节点只有一个父亲，那么选定一个结点，它到根节点的路径唯一。

所以第一个思路就是暴力，对于每一个节点，直接暴力向上枚举，找到第一个满足条件的节点，然后输出长度即可。

但是显然，第一种方法很容易 TLE，所以我们需要进一步优化。

![](https://cdn.luogu.com.cn/upload/image_hosting/jdv341r9.png)

我们随便给出一棵树，选取一条链。以叶节点为例，那么找到的最长链的另一个端点应该在路径上。

那么我们很容易想到了二分，快速找到适合的节点。

但是如果二分后还是暴力把所有值加在一起的话显然还是会超时，所以我们又自然地想到了前缀和。

最后一个问题，我们该如何确定二分的范围呢？我们可以在深搜的时候用一个栈，每搜索到一个新节点，就加入栈，然后在栈中二分，当这个节点遍历完了，就出栈。

对了，需要注意的是，这道题需要开 ```long long```。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{long long w,c,fa;vector<long long>v;}a[100005];//因为不确定儿子个数，所以用vector储存
long long n,ans[100005],z[100005],top,l,r,mid;
void dfs(long long u)
{
	z[++top]=u;//入栈
	l=0,r=top;
   a[u].w+=a[a[u].fa].w;//前缀和
	while(l<=r)//二分
	{
		mid=l+r>>1;
		if(a[u].w-a[z[mid]].w>a[u].c) l=mid+1;
		else ans[u]=top-mid,r=mid-1;
	}
	for(long long i=0;i<a[u].v.size();i++) dfs(a[u].v[i]);//向下搜索
	--top;//出栈
}
int main()
{
	scanf("%lld",&n);
	for(long long i=2;i<=n;++i) scanf("%lld",&a[i].fa),a[a[i].fa].v.push_back(i);
	for(long long i=1;i<=n;++i) scanf("%lld",&a[i].w);
	for(long long i=1;i<=n;++i) scanf("%lld",&a[i].c);
	dfs(1);
	for(long long i=1;i<=n;++i) printf("%lld ",ans[i]);
	return 0;
}
```

---

## 作者：technopolis_2085 (赞：3)

# P1612 [yLOI2018] 树上的链 题解
------------
一道简单图论题。

用树上倍增做。

一遍dfs求出每一个节点往上 $2^k$ 个节点是谁，和这个节点往上 $2^k$ 个节点的权值和。

由于权值和具有单调性，所以可以考虑类似于二分的做法。

从20往下，对于每一个 $i$，考虑这个节点往上 $2^i$ 个节点的和是否大于这个点的权值。

如果大于当前点的权值，说明往上 $2^i$ 个节点的和太大了，所以要考虑更小的 $i$ 。

如果等于当前点的权值，那么这条链的长度就求出来了。

如果小于当前点的权值，那么可以把当前点往上”跳“ $2^i$ 层，同时这条链的长度加上 $2^i$ 。

时间复杂度 $O$($n$ log $n$)。

代码如下：

（不开long long见祖宗。）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e5+10;
vector<int> G[maxn];

int n;
int sum[maxn];
int num[maxn],c[maxn];
int dp[maxn][20];

void dfs(int u,int fa)
{
	sum[u]=sum[fa]+num[u];
	dp[u][0]=fa;
	
	for (int i=1;i<20;i++) dp[u][i]=dp[dp[u][i-1]][i-1];
	
	for (int i=0;i<(int)G[u].size();i++)
	{
		int v=G[u][i];
		
		if (v!=fa) dfs(v,u);
	}
}

signed main()
{
	scanf("%lld",&n);
	
	for (int i=1;i<n;i++)
	{
		int x;
		scanf("%lld",&x);
		
		G[x].push_back(i+1);
	}
	
	for (int i=1;i<=n;i++) scanf("%lld",&num[i]);
	for (int i=1;i<=n;i++) scanf("%lld",&c[i]);
	
	dfs(1,0);
	
	for (int i=1;i<=n;i++)
	{
		int u=i;
		
		int cnt=0;
		for (int j=19;j>=0;j--)
		{
			if (dp[u][j]==0) continue;
			
			if (sum[i]-sum[dp[u][j]]+num[dp[u][j]]<=c[i])
			{
				u=dp[u][j];
				cnt+=(1ll<<j);
			}
		}
		
		printf("%lld ",cnt+1);//不要忘了自己
	}
	
	return 0;
}
```


---

## 作者：Limitless_lmw (赞：2)

$\Large \text{Introduction}$

有一棵有 $n$ 个节点的树，设 $son_{u}$ 为结点 $u$ 的祖先结点集，$num_{u}$ 为结点 $u$ 的祖先结点数量，$dis_{x,y}$ 为树上结点 $x$ 到 $y$ 的路径上的权值和，求

$$\normalsize \max_{i=1}^{num_{u}} dis_{u,son_{u_{i}}},u\in \{1,2,3,...,n\}$$

---

$\Large \text{Solution}$

DFS 这棵树，因为无负权值，所以答案符合单调性，在这个节点的祖先结点里二分即可，二分 $s_{i}-c_{i}$。**不开longlong见祖宗。**

因为 `std::stack<type>` 不支持直接用下标访问地址，所以用 `std::vector<type>` 维护，邻接表存图。

（画外音：珂爱扶苏重度 STL 依赖症）

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=100015;

int n,ans[maxn];
long long w[maxn],c[maxn],s[maxn];
vector<int> vec[maxn];
vector<int> sta;

void dfs(int x){
	sta.push_back(w[x]+sta.back());
	int rr=0;
	for (int l = 0, r = sta.size() - 1, mid = (l + r) >> 1; l <= r;){
		if (sta.back() - sta[mid] <= c[x]) {
    		r = (rr = mid) - 1;
  		}
  		else {
    		l = mid + 1;
  		}
   		mid = (l + r) >> 1;
  	}
	ans[x]=sta.size()-rr-1;
	for(auto it:vec[x]) dfs(it);
	sta.pop_back();
	return;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	cin>>n;
	for(int i = 2,x; i<=n; i++){
		cin>>x;
		vec[x].push_back(i);
	}
	for(int i = 1; i<=n; i++){
		cin>>w[i];
	}
	for(int i = 1; i<=n; i++){
		cin>>c[i];
	}
	sta.push_back(0);
	dfs(1);
	for(int i = 1; i<=n; i++) cout<<ans[i]<<' ';
	return 0;
}
```

---

## 作者：knya (赞：1)

此代码目前是最优解。

$178$ 毫秒。

## 思路

首先会先到暴力，对于每一个节点，找到满足要求的最长长度，当然这种做法肯定会 TLE 的，我们要进一步给他优化。

我们可以用前缀和来算出，从某一个节点到他上面的某一个节点的前缀和，前缀和肯定是单调递增的，所以还可以用二分来优化，这样代码就不会 TLE 了。

还要注意的是，由于数据范围，前缀和最大为 $10^{14}$ 所以要用 `long long`。

## 用到的算法

[dfs](https://oi-wiki.org/search/dfs/)

[二分](https://oi-wiki.org/basic/binary/)

[前缀和](https://oi-wiki.org/basic/prefix-sum/)

[栈](https://oi-wiki.org/ds/stack/)

# AC 代码

```cpp
#include<stdio.h>
#include<vector>

//快读优化 
char buf[1<<21],*p1,*p2;
inline char gc(){
	if(p1==p2)
		p2=(p1=buf)+fread(buf,1,1<<21,stdin);
	return *(p1++);
}

inline int read(){//快读 
	int s=0,fu=1;char ch=gc();
	while(ch<'0'||ch>'9'){
		if(ch=='-')fu*=-1;
		ch=gc();
	}
	while(ch>='0'&&ch<='9'){
		s=(s<<1)+(s<<3)+(ch^48);
		ch=gc();
	}
	return s;
}

inline void write(int x){//快写 
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}

const int N=1e5+10;
std::vector<int>son[N];//存子节点
long long sum[N];
int fa[N];
int n,c[N],ans[N];
int sta[N],tt;

void dfs(int u)
{
	sta[++tt]=u;
	int l=0,r=tt;
	sum[u]+=sum[fa[u]];
	
	while(l<r)
	{
		int mid=l+r>>1;
		if(sum[u]-sum[sta[mid]]<=c[u])r=mid,ans[u]=tt-mid;
		else l=mid+1;
	}
	
	int sz=son[u].size();//存起来可以加快一些速度
	for(int i=0;i<sz;++i)dfs(son[u][i]);
	--tt;
}

void work(){
	n=read();
	for(int i=2;i<=n;++i){
		fa[i]=read();
		son[fa[i]].push_back(i); 
	}
	for(int i=1;i<=n;++i)sum[i]=read();
	for(int i=1;i<=n;++i)c[i]=read();
	dfs(1);
	for(int i=1;i<=n;++i)write(ans[i]),putchar(' ');
}

int main(){work();return 0;}//一行主函数 QwQ 
```

这里要注意一下快读优化再 acwing 上会有错误，把优化删去，改成普通优化就好了。

[安全的快读与快写](https://www.luogu.com.cn/paste/k7yhhw0h)

审核大大求过，本蒟蒻第一篇题解。

---

## 作者：李承轩 (赞：0)

**思路**

看到条件 $2$，我们得知：这个节点对应的最长链，一定在这个节点到根节点的简单路径上。

所以我们记录 $1$ 到 $i$ 之间的权值和，记为 $sum_i$。因为权值是正整数，所以满足单调性，可以二分。

如何二分路径上的点呢？我们维护一个与当前 dfs 同步的栈，记录从根节点到当前节点的简单路径。二分栈里的点就行了。

**代码**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,w[N],c[N],sum[N],st[N],ans[N],top;
int head[N],to[N<<1],nxt[N<<1],idx;
void add(int x,int y){to[++idx]=y,nxt[idx]=head[x],head[x]=idx;}
void dfs(int x,int fa)
{
	st[++top]=x,sum[x]=sum[fa]+w[x];
	int l=1,r=top;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(sum[x]-sum[st[mid-1]]<=c[x])r=mid-1;
		else l=mid+1;
	}
	ans[x]=max(ans[x],top-l+1);
	for(int i=head[x];i;i=nxt[i])dfs(to[i],x);
	top--;
}
signed main()
{
	scanf("%lld",&n);
	for(int i=2,x;i<=n;i++)
	{
		scanf("%lld",&x);
		add(x,i);
	}
	for(int i=1;i<=n;i++)ans[i]=1;
	for(int i=1;i<=n;i++)scanf("%lld",&w[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&c[i]);
	dfs(1,0);
	for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
}
```

---


# [COCI 2011/2012 #5] EKO / 砍树

## 题目描述

伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。

Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。

Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。

## 说明/提示

对于 $100\%$ 的测试数据，$1\le N\le10^6$，$1\le M\le2\times10^9$，树的高度 $\le 4\times 10^5$，所有树的高度总和 $>M$。

## 样例 #1

### 输入

```
4 7
20 15 10 17```

### 输出

```
15```

## 样例 #2

### 输入

```
5 20
4 42 40 26 46```

### 输出

```
36```

# 题解

## 作者：TOM_闫 (赞：291)

然而这题并不需要什么二分法。。。

用sort排序再从后往前查找就可以。

只需优化一下当前砍去多少米的算法就可以。

假设已砍过了i棵树（树由高到低排），那此时被砍过的i棵树的高度均等于第i+1棵树的高度。

再砍一棵树（砍第i+1棵）后获得的新高度为（第i+1棵树的高度-第i+2棵树的高度）\*（i+1）。

so  时间复杂度仅为 n

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int tree[1000001];
int n,m;
int main()
{
    int i,num,ans;
    long long sum;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        scanf("%d",&tree[i]);
    sort(tree+1,tree+n+1);
    sum=0;
    num=n;
    while(sum<m)
    {
        sum+=(tree[num]-tree[num-1])*(n-num+1);
        num--;
    }
    num++;
    ans=tree[num-1]+(sum-m)/(n-num+1);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：noiking (赞：242)

啦啦啦
这题运用了二分思想，用普通暴力应该是不行的，思路啥的见注释
安利一波我的博客https://www.luogu.org/blog/socialsister/
社会小妹啦啦啦
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,bz,s=0,mid,leftt,longest,trees[1000008];
int main()
{
    scanf("%lld%lld",&n,&bz); 
    for(int i=1;i<=n;i++) 
    {
        scanf("%lld",&trees[i]);
        longest=max(longest,trees[i]);//找到最长木材 
    }
    while(leftt<=longest)
    {
        mid=(leftt+longest)/2; //从中间点开始作为伐木机高度
        s=0; 
        for(int i=1;i<=n;i++) 
			if(trees[i]>mid) //树的高度大于伐木机高度 
				s+=trees[i]-mid; //高的部分累加 
        if(s<bz) //木材不足 
			longest=mid-1;//在左边搜 减小高度增加木材 
		else 
			leftt=mid+1;//在右边搜 增加高度减小木材 
    }
    cout<<leftt-1; 
    return 0;
}
```

---

## 作者：_emm_ (赞：186)

#### 首先要明确这道题是用二分的 ( ~~因为有标签~~ ) ：


1. 有单调性

   提高伐木机的高度，显然地，得到的木头会减少。
   
   同样地，放低得到的木头会增多。
   
   而正因为答案有单调性，所以我们可以使用二分。
---   
2. 数据范围大
    
   显然，1e6 的 n 对于暴力枚举是不太友好的 ~~特别是CCF老爷机~~
   
   穷举的话，复杂度大概是O(n·m) ~~绝对~~应该会超
   
   然鹅二分就不会了，二分答案只要O(n·log m) ~~应该~~是不会超的qwq
   
---
#### 代码实现如下：
1. 需要准备的

```cpp
#include<cstdio>//使用更快的scanf printf
long long n,m,high[1000000+10];//题目所需的读入
long long tmp,left,right;//二分
```
---

2. 二分+检查部分
   
```cpp
while(left<=right){//二分模板
		int mid=(left+right)>>1;//位运算貌似会节省时间
		tmp=0;//记得更新
		for(int i=1;i<=n;i++) 
		    if(high[i]>mid) tmp+=high[i]-mid;
		if(tmp<m) right=mid-1;
		else left=mid+1;//模板不提
	}
```

3. 全代码

```cpp
#include<cstdio>
long long n,m,high[1000000+10];//本蒟蒻全部用了long long   qwq
long long tmp,left,right;
int main()
{
	scanf("%lld%lld",&n,&m);//注意读入输出要使用lld
	for(long long i=1;i<=n;i++){
		scanf("%lld",&high[i]);
		if(high[i]>right) right=high[i];//找到最大的high[i]做为right
	}
	while(left<=right){
		int mid=(left+right)/2;
		//printf("%d ",mid);
		tmp=0;
		for(int i=1;i<=n;i++) 
		    if(high[i]>mid) tmp+=high[i]-mid;
		if(tmp<m) right=mid-1;
		else left=mid+1;
	}
	printf("%lld",right);//输出最终结果
	return 0;//不加return 0 结果return WA;
}
```

## ~~第一次发题解，求过QAQ~~




---

## 作者：chlchl (赞：150)

## 前言
这题是不是重了？大家如果通过了这道题，可以去 [P1873](https://www.luogu.com.cn/problem/solution/P1873) 水双倍经验，原代码就可以过哦！

## 题目意思及翻译
有那么一丢丢的费解。这题的意思是**给定 $n$ 棵树的高度**，让你求一个**最大的参数值** $r$，使得**他把所有树 $r$ 米以上的部分砍掉**之后，能得到 $m$ 米或以上的木材（换句话来说，如果**再升高 $1$ 米**，那他将**得不到 $m$ 米的木材**）。

## 思路
本题为一道非常基础的**二分答案**题。

（~~虽然我是来水题解的~~，但我觉得还是有必要详细讲讲二分）。

### 二分
------------
~~二分不就是倍增的反操作吗？~~

二分，就是把一个数列**分成两部分分别查找答案或进行处理**，这是一种比暴力循环枚举答案更快的基础算法，时间复杂度为 $O(\log$ $n)$。

我在这里举个例子，让大家对二分有一个比较清楚的认识。

例：在 $1$ 到 $100$ 中找 $24$ 这个数。

1. 把 $1$ 到 $100$ 看成一个**递增的数列**，并将它**平均分成两部分**，**也就是 $1$ 到 $50$ 一部分，$51$ 到 $100$ 一部分**。很明显，$24$ 在前面较小的一部分，所以**后面一段不用考虑**（一下排除了一半，酸爽啊）。

2. 把前面一段再平均分成两段，$24$ 在 $13$ 到 $25$ 之间，所以**只考虑后面一段**。

3. 把 $13$ 到 $25$ 又平均分成两段，$13$ 到 $19$ 一段，$20$ 到 $25$ 一段，$24$ 在后面一段，所以又排除一些数。

4. 把 $20$ 到 $25$ 又又平均分成两段（**只要还没确定 $24$ 的位置，就要一直分**），**排除 $20$，$21$，$22$**。

5. 把 $23$ 到 $25$ 又双叒叕分成两段，**这时，$24$ 位置确定了，二分结束**。

如果要暴力枚举，要枚举 $24$ 次，但是二分 $5$ 次就得出了答案，非常优美。

既然二分这么好用，那是不是所有地方都能用二分呢？大家可能注意到我上面的一句话：

``把 1 到 100 看成一个递增的数列。``

二分只能用于**有序的数列中**，换句话来说，**只有单调递增或者单调递减的数列**，二分思想**才能得出正确答案**。比如下面的这组数据，二分就不能直接使用：``5,3,1,4,2,6,9``

------------
相信大家知道二分的实现过程了吧？

建议初学着先去做一下 [P2249](https://www.luogu.com.cn/problem/P2249)。

## 实现方法
以下是二分的基本实现方法（**不要急着复制，这只是模板**）：
```cpp
int mid, l = 0, r = 0x3ffffff;//定义左右边界和中间量
while(l <= r){//循环终止条件，当 l = r 时，答案就已经确定了
		mid = (l + r) / 2;//模拟平均分成两段的过程
		if(check(mid))	l = mid + 1;//check() 后面会讲，要手写
		else	r = mid - 1;
		//说明一下，l = mid + 1 的意思是这个结果可能小了，可以尝试更大一点（通过缩小左边界来达到忽略左边一段的效果） 
		//r = mid - 1 的意思是这个结果太大了，要小一点（通过缩小右边界来达到忽略右边一段的效果） 
	}
```
回到本题，他要求一个最大的 $r$ 值，我们如何确定当前求到的 $r$ 是不是最大值呢？

这就要联系题目了。题目中说要求要得到 $m$ 米的木材，那我们**求出每一棵树被砍掉的米数**，得到一个总和 $s$，拿这个 $s$ 去跟 $m$ 比较，**如果大于表示可能还能再升高，如果小于表示要降低。**

所以，check 函数是这么写的：
```cpp
bool check(int x){//x 为当前求得的答案（即mid） 
	int s = 0;//定义总和 
	for(int i=1;i<=n;i++){
		if(a[i] > x)	s += a[i] - x;
		//求出每一棵树被砍掉的部分，因为有的树可能会小于当前高度，不会被砍，所以要加判断 
		if(s >= m)	return true;//把这个判断写在循环内，可以节省一点时间 
	}
	//if(s >= m)	return true;//写在这里也可以！ 
	return false;
}
```

## 一些小坑
本题比较基础，所以没多少坑，不过有一些地方还是要注意一下。

1. 注意 $r$ 的初始值，太小会导致一开始就错过了一些数。
2. 最后输出的是 $l$，$r$ 还是 $mid$，不同题目要具体分析。

## 代码
以下是参考代码。珍爱生命，远离抄袭。

前面解释过了，代码就不加注释了，方便大家看。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1000000 + 10;
int a[N], mid, l, r, n, m;

bool check(int x){
	int s = 0;
	for(int i=1;i<=n;i++){
		if(a[i] > x)	s += a[i] - x;
		if(s >= m)	return true;
	}
	return false;
}

int main(){
	cin >> n >> m;
	for(int i=1;i<=n;i++)	cin >> a[i];
	l = 0, r = 1e9;
	while(l <= r){
		mid = (l + r) / 2;/
		if(check(mid))	l = mid + 1;
		else	r = mid - 1;
	}
	cout << r << endl;
	return 0;
}
```
写题解不易，如果这篇文章帮到你了，别忘了点个赞哦！

---

## 作者：Sweetlemon (赞：119)

这题是二分答案题。它满足二分答案题的几个特征:

(1)求最大/最小值;

(2)答案离散(答案有有限种可能);

(3)容易判断答案是否正确(事实上,这题如果要写SPJ,只需要满足ans满足条件但ans+1不满足条件即可)。

二分答案题的做法即是:

(1)确定答案区间;

(2)在保证答案在区间内的前提下,逐步缩小区间;

(3)当区间缩小到仅包含一个可能解时，该可能解即为答案。

这里主要要注意第(2)点，就是如何缩小区间。这是二分的精华所在，也是二分搜索程序如此难写的原因(可以自行查一下历史,或者读一下《编程珠玑》)。

下面贴一下代码。注意数据类型要用unsigned long(为了节省空间,用了unsigned;程序中用usl代表unsigned long)。

```cpp
#include <iostream>
using namespace std;
typedef unsigned long usl; // 本程序主要使用unsigned long
bool check(usl * a, usl n, usl m, usl pos); //检查解是否可行的函数
int main(void){
    usl n,m;
    usl l=0,r=1,mid;
    cin >> n >> m;
    usl a[n];
    for (int i=0;i<n;i++){
        cin >> a[i];
        if (a[i]>r)
            r=a[i]; //r保存目前读到的最高的树的高度
    }
    r--; //在最高的树的高度砍肯定不行啦(这样什么都没砍到)，因此-1

    //答案区间为:ans in [l,r];即可能的砍树高度从0(全部砍掉)到最高的树的高度-1
    while (l<r){
        //注意上面这个循环的条件;当l==r,也就是ans in [l,r]变成ans in [l,l]时,ans就确定下来了(ans=l)
        mid=(l+r+1)>>1; //即mid=(l+r+1)/2;
        //上面不能用mid=(l+r)/2！ 因为如果r==l+1,而且check(l)为true,那么每次的mid都是l,结果l和r的值都没有改变,造成死循环
        //换句话说,mid要偏向r
        //对于这个问题,底下有图解
        if (check(a,n,m,mid)) //如果mid是可行解
            l=mid; //那么最低就砍到mid,不要再低了(再低就破坏森林生态环境)
        else //mid不可行
            r=mid-1; //那么必须得砍得比mid还要低,所以最高的高度为mid-1
    }
    cout << l; //此时输出l和r都是一样的
    return 0;
}
bool check(usl * a, usl n, usl m, usl pos){
    usl cnt=0;
    for (int i=0;i<n;i++)
        if (a[i]>pos)
            cnt+=(a[i]-pos);
    return cnt>=m; //这里相当于return (cnt>=m)?true:false;
}
```
下面是mid取值的说明:

![](https://cdn.luogu.com.cn/upload/pic/4764.png)


---

## 作者：Diaоsi (赞：29)

## 二分模板题
这道题直接枚举是可以过的

但是枚举效率太低 所以我们可以很轻易地想到一种二分的做法

在[l,r]区间上进行二分查找，l=0，r为最高的树的值

每次二分则计算当前能得到的木材长度之和

给一下二分的模板
```cpp
while(l<=r){
	long long mid=(l+r)>>1;tmp=0;
	if(check(mid))l=(ans=mid)+1;//在右区间查找，同时更新答案
	else r=mid-1;//在左区间查找
}
```
而二分答案的精髓则在check函数

在这道题中check函数的作用是计算木材的总长度并判断是否满足需求

如果满足需求则查找是否有小的解（指砍树高度更高）

否则向更低的区间查找

贴一下check函数的代码
```cpp
bool check(long long x){
	for(long long i=1;i<=n;i++)
		if(x<a[i])tmp+=a[i]-x;
	return m<=tmp;//骚写法，如果满足条件则返回1
}
```
贴一下完整的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=10000010;
long long n,m,a[N],tmp,l,r,ans;
bool check(long long x){
	for(long long i=1;i<=n;i++)
	    if(x<a[i])tmp+=a[i]-x;
	return m<=tmp;//骚写法，如果满足条件则返回1 
}
int main(){
	cin>>n>>m;
	for(long long i=1;i<=n;i++)cin>>a[i],r=r>a[i]?r:a[i];
	while(l<=r){
		long long mid=(l+r)>>1;tmp=0;
		if(check(mid))l=(ans=mid)+1;//在右区间查找，同时更新答案 
		else r=mid-1;//在左区间查找 
	}
	cout<<ans;
	return 0;
}
```
## 如有错误请在评论区指出

---

## 作者：野鹤 (赞：19)

先看一下题面，帮助米尔科找到伐木机锯片的**最大的整数高度H**，使得他能得到木材**至少**为M米。从这句话可知，让求最大值的最小，所以~~很轻易~~的得出这是一道**二分答案**的题。

既然是二分答案的题，那么核心就在于check函数的书写了

```cpp
bool check(long long mid){
	long long t=0;//计数器，把伐木机锯片停在mid高度时，砍掉了多少木材。
	for(int i=1;i<=n;i++){
		if(mid<h[i])t+=h[i]-mid;
     //如果比mid高度高，高出来的一部分便是所据的木材。
	}
	if(t>=m) return true;//如果以mid为高度所的木材比至少要得到的m米木材多的话，说明合法，调整左边界。
	else return false;//反之调整右边界。
}
```

下面是主函数

```cpp
int main(){
	cin>>n>>m;
	long long r=0,l=1;//左边界与右边界的定义
	for(int i=1;i<=n;i++){
    cin>>h[i];
    r=max(r,h[i]);
    }//一个for循环输入，并且求出木材中的最大值作为右边界
	while(l<=r){
		long long mid=(l+r)/2;//求出中点
		if(check(mid)){
			l=mid+1;
		}
     //若合法，那么说明伐木机的高度停在比mid更高的位置也合法，左边界右移。
		else {
			r=mid-1;//若不合法，那么说明伐木机的高度停在比mid高的位置也不合法，右边界左移。
		}
	}
    //一个二分板子
	cout<<l-1;
	return 0;
}
```

下面是完整的ac代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long h[1000010];
bool check(long long mid){
	long long t=0;
	for(int i=1;i<=n;i++){
		if(mid<h[i])t+=h[i]-mid;
	}
	if(t>=m) return true;
	else return false;
}
int main(){
	cin>>n>>m;
	long long r=0,l=1;
	for(int i=1;i<=n;i++){cin>>h[i];r=max(r,h[i]);}
	while(l<=r){
		long long mid=(l+r)/2;
		if(check(mid)){
			l=mid+1;
		}
		else {
			r=mid-1;
		}
	}
	cout<<l-1;
	return 0;
}
```

这道题还是~~比较简单~~的，一定要注意的一个点是：

#### 开 **long long** ！！！

### 开 **long long** ！！！

## 开 **long long** ！！！

重要的事情说三遍，
~~不开long long 见祖宗~~

一个long long 卡了我半个小时

~~我太难了~~


---

## 作者：oierwa (赞：15)

~~（我们考试时就用了这题）~~
##### 开始拿到这题很蒙，所以决定豁出去写一个枚举，但在写的过程中，发现虽然m很大，但n很小，所以模拟+优化应该能过（当然，luogu的评测机强大无比，luogu的1s程序，我们那的计算机要跑8s，所以luogu不优化也可以过~~？~~）。

>1. 将树的高度读入后，我们将树排序，因为树的位置的变化是无所谓的。

>2. 然后从最高点往下搜,直到木材总量大于m即可

>3. 第二步可以进一步优化：

>    将第二步拆开：因为每一个树距离上一棵树的距离已知，我们可以直接用枚举刚好不砍某棵树时得到的木材

>    然后在砍树超过m时跳出。

>    再不断抬高锯子，直到看不到长m的木材，此时再将锯子降低一个单位就是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,high,Now,o,Nowm=0;
int h[1000005],high_for[1000005];
int main(){
    cin>>n>>m;
    for(register int i=1;i<=n;++i) cin>>h[i];
    sort(h+1,h+n+1);                 //Step.1
    for(register int i=2;i<=n;++i) high_for[i]=h[i]-h[i-1];                              //距离上一棵树高度的差，此步可直接在下一步中实现
    for(o=n;o>=1;--o){
        Now=h[o];
        Nowm+=high_for[o+1]*(n-o);
        if(Nowm>=m) break;
    }
    while(Nowm>=m) Nowm-=(n-o),Now++;   //缺点所在处
    cout<<Now-1<<endl;
    return 0;
}
```
## 此算法的缺点
#### 虽然说貌似是优化了，但是此算法仍存在一个缺点。
当答案H距离它下面的树的h很远时（也就是专坑此算法的毒瘤数据），所谓的优化反而会耗去跟多时间，如果能对距离进行一次判断，从下端处理或从上端处理，会更好。

例如：
![](https://cdn.luogu.com.cn/upload/pic/49074.png)
这种情况时，h距下端远，距上端近，从上端处理会大大缩短时间（虽说理论上时间复杂度没变）

### 当然，可能还会有一些其他的方法？

---

## 作者：wangbinfeng (赞：12)

这题是不是有点熟悉？在洛谷上搜一下[“砍树”](https://www.luogu.com.cn/problem/solution/P1873)，你会发现连样例都一样……

言归正传，开始今天的讲解！

------------
# 思路：
首先，我们要发现：这道题存在**潜在的单调性**和**最大值最小**这两个关键信息。
1. 单调性：
答案每次增加，砍掉的数量会相应减少。反之亦然。
2. 最大值最小：
>请你帮 Mirko 找到 $H$ 的**最大值**，使 Mirko **至少**能砍掉 $M$ 米的木材。

有了这两个信息，就可以轻松看出本题的思路：**_二分_**！

至于二分的具体内容，大家可以阅读双倍经验[“砍树”](https://www.luogu.com.cn/problem/solution/P1873)的题解。

不过既然来了，还是讲一下吧！

>对于区间 $[a,b]$ 上连续不断且 $f(a) \times f(b)<0$ 的函数 $y=f(x)$ ，通过不断地把函数 $f(x)$ 的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。

这是[百度](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%B3%95/1364267?fr=aladdin)上的定义，有点难懂。那就让我给大家分析一下吧！

二分，顾名思义，就是将一段内容分成两份来分别处理或使左右区间逐渐逼近。

比如按照本题要求，我们可以先找到答案的范围（ $0 - max_h$ 这一区间）。我们就可以先尝试设 $left$ 代表左边界， $right$ 代表右边界， $mid=(left+right)/2$ 代表答案进行尝试。

可以清楚的看出， $mid$ 的结果有三种可能：正确、过大和过小。

- 正确：可以直接输出。但在有些题中要求最小的正确值，所以有可能还要继续让 $r=mid-1$ 缩小二分的范围。
- 过大：让 $r=mid-1$ 缩小二分的范围。
- 过小：让 $l=mid+1$ 缩小二分的范围。
- 若 $l=r$ ：结束。

可以看出，重复执行上述算法，时间复杂度为 $O(\log n)$ ，比暴力的 $O(n)$ 快了许多。

如果这样，是不是所有的暴力都可以用二分替代呢？当然不是。二分需要满足**单调性**。

- 注：二分分为二分过程和二分答案，比如本题就是二分答案。至于二分过程，有机会再给给大家讲吧！


# 代码：
```#include<bits/stdc++.h>
using namespace std;
long long l,r,mid,ans,n,m,dat[1000009];
long long read(){
   long long s=0,f=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*f;
}//快读，和cin/scanf作用相同，但速度更快
int main(){
	n=read();
	m=read();
	for(int i=0;i<n;i++)dat[i]=read(),r=max(r,dat[i]);
	sort(dat,dat+n);//加速，可以让下方第二层循化变快一点点。但可以忽略，改法见砍树题解
	for(l=0,mid=(l+r)>>1;l<=r;mid=(l+r)>>1){//二分
		ans=0;//记得清零
		for(int i=n-1;i>=0&&dat[i]>mid;i--)//因为sort默认升序，所以要倒着搜索。也可以重新编写比较函数
			ans+=dat[i]-mid;
		if(ans<m)r=mid-1;
		else l=mid+1;
	}
	cout<<mid;//输出答案
}
```


------------
感谢大家阅读。这篇题解比较基础，着重讲了二分的判断及实现。适合零基础的同学。

这篇题解的内容可能过于具体，大家可以借助介绍中插入的具体代码来思考。

---

## 作者：浅色调 (赞：12)

###二分答案的板子题###

**思路：**我们直接套上二分答案，区间l取0、r取树的最大高度，关键的check判断我们可以直接模拟一重循环加上树高a[i]-x(a[i]>x)。

**注意：**值很大所以要开long long，然后就是读入优化减少时间。

**代码：**

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
#define ll long long
#define il inline
ll n,m,a[1000005],ans,l=1,r,mid;
il int gi()
{
    ll a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
    return f?-a:a;
}
il bool check(ll x)
{
    ll tot=0;
    for(int i=1;i<=n;i++)if(a[i]>x)tot+=a[i]-x;
    return tot>=m;
}
int main()
{
    n=gi(),m=gi();
    for(int i=1;i<=n;i++)a[i]=gi(),r=r>a[i]?r:a[i];
    while(l<=r)
    {
        mid=l+r>>1;
        if(check(mid))ans=mid,l=mid+1;
        else r=mid-1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：cyhyyds (赞：5)

### 思路：
数据范围 $1\le h_i \le 10^6$，那么，答案的范围在 $1$ 到 $10^6$ 之间。 

我们很容易联想到**二分法**。

二分的左边界就是 $0$，右边界为 $h_i$ 的最大值。

枚举所有的答案，判断是否能满足条件，找最大值即可。

### 核心代码：
```
inline bool check (int x) {
	int tot = 0;
	
	for (int i = 1; i <= n; i ++) {
		if (x < a[i]) {
			tot += a[i] - x;
		}
	}
	
	return tot >= m;
}

```


---

## 作者：lytqwq (赞：5)

更加神奇的算法
~~（玄学？）~~

非二分解法，然而似乎比  第一个题解最慢O（M）的算法更优化

先sort O（N log N）一下，之后O（N）找“最优解前面的序号”，找到后不需要再while向后遍历到M，直接除就行了
~~（幼儿园数学既视感）~~

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000002
long long int n,m,sum;
long long int a[N];
int main()
{
	cin>>n>>m;
	for(long long int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	a[n+1]=a[n];
	for(long long int i=n;i>=0;i--)
	{
		sum+=(n-i)*(a[i+1]-a[i]);
		if(sum<m)
		{
			continue;
		}
		long long int before=sum-(n-i)*(a[i+1]-a[i]);
		long long int cha=m-before;
		long long int ans=a[i+1]-(cha/(n-i));
		if(cha%(n-i)!=0)
		{
			ans--;
		}
		
		cout<<ans;
		break;
	}
	return 0;
}
```


---

## 作者：依依 (赞：5)

解：对于此题，直接二分答案，然后判断当前答案

是否合法即可

复杂度O(n * logm)

 一个优化，将树木高度从小到大排序，记录一个前缀和

对于当前答案mid,二分找到第一个>=他的位置,

判断  sum[n]-sum[p-1]-(n-p+1)*1ll*mid>=m;

复杂度O(logn * logm)

时间比楼下的快很多~~虽然很麻烦~~  
[代码](http://www.cnblogs.com/adelalove/p/8795790.html)

---

## 作者：zhaowangji (赞：4)

### ~~一个long long 引发的惨案~~

因为数据范围过大，所以要用long long ！！！

吐槽结束


------------


------------

一看题目的数据范围就知道只能用二分答案（话说题解区第一篇真。。。洛谷评测机太好了）

二分枚举高度，然后一个一个带进去算能看多少树，注意：累加木材的变量要开long long，不然。。。不然会爆
（最终得40，然后#2数据下载下来你会发现自己都无法手测，反正我是贴不进exe）

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long n,m;
long long a[1000007];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>a[i];//读入
	long long l=0,r=2e9+1,mid;
	while(l+1<r)//模板
	{
		mid=(l+r)/2;
		long long sum=0;//累加木材数
        	//本来只有这个要开long long，但是一气之下就全都写了long long
		for(int i=1;i<=n;i++)
		if(a[i]-mid>=0)sum+=(a[i]-mid);
        	//枚举每一棵树，注意：树木高度高于定好的高度才能砍
            	//所以先要判断是不是高，不能直接累加（不然就有木材是负的）
		if(sum>=m)l=mid;//能砍到的木材太多了，说明高度太低
		else r=mid;//木材太少了，高度要高一点
	}
	cout<<l<<endl;//l为答案
	return 0;
}
```


---

## 作者：Kingna (赞：4)

这道题，其实我想都没想，打起了暴力。


两分钟不到打完了：
```c++
#include<bits/stdc++.h>//对此代码稍作解释
using namespace std;
int n,m;
int a[1000005];
int sum;
int ans=-347563487;
inline long long read(){
    long long X=0,w=0;char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		ans=max(ans,a[i]);//取最大值
	}
	//在这里说明：因为要求最大高度，所以从上往下砍，而不是从下往上砍
	//虽然两者都可以，但是从上往下砍伐更快
    //从什么地方开始砍呢，就是所有树的最大高度，因为砍伐高度只有 0-ans 之间 
    //ans就是所有树木的最大高度 
	for(int i=ans;i>=1;i--){//从最大高度往下枚举 
		sum=0;//sum是统计能砍伐多少树 
		for(int j=1;j<=n;j++){//这个循环目的是找能砍伐多少树 
			if(a[j]>=i){
				sum+=a[j]-i;//满足要求，统计 
			}
		}
		if(sum>=m){//如果大于m,收工，输出 
			write(i);
			return 0;
		}
	}
}
```
然后不出我所预料，超时 $38$ 分.

### 考虑优化
首先，我们看上面的那个暴力的步骤：枚举高度 $+$ 统计砍伐树木

第二个步骤已经没有办法优化了，因为统计只能老老实实的统计。

考虑优化第一个步骤：

考虑每一个高度，是否成立这件事，写个单独的函数:（作用后面说）
```c++
bool check(long long mid){//检查mid高度是否成立
    long long tot=0;
    for(long long i=1;i<=n;i++){
    	if(a[i]>mid){
    		tot+=a[i]-mid;
		}
	}
    return tot>=m;
}
```
我们灵机一动：考虑二分

顾名思义：将一段内容分成两段来分别处理或使左右区间逐渐逼近（分成若干个简单的子问题，再把若干个简单的子问题合并）

二分首先区间容易确定，而且具有单调性，在二分前可以确定为[最小值最大](https://www.luogu.com.cn/paste/ep0ovnfv)或者是[最大值最小](https://www.luogu.com.cn/paste/rpqb1zov)
.

此题分别具有上述性质

* 二分区间 左端点 $l$ 为所有树当中的最小值，右端点 $r$ 为所有树当中的最大值。（区间容易确定）

* 当砍伐高度越高，得到的树木越少（具有单调性）

* 题目说明找到**最高**的高度，使树木尽可能的**少**但必须满足要求。（满足最大值最小的要求）


首先考虑二分区间，左端点 $l$ 为所有树当中的最小值，右端点 $r$ 为所有树当中的最大值。

然后二分就可以了。
```c++
#include<bits/stdc++.h>
using namespace std;
int n;
long long m,a[1000005],mx,mi=65435342;
inline long long read(){
    long long X=0,w=0;char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
bool check(long long mid){
    long long tot=0;
    for(long long i=1;i<=n;i++){
    	if(a[i]>mid){
    		tot+=a[i]-mid;
		}
	}
    return tot>=m;
}
int main(){
    n=read();m=read();
    for(long long i=1;i<=n;i++){
        a[i]=read();
        mi=min(mi,a[i]);
        mx=max(mx,a[i]);
    }
    long long l=mi,r=mx,ans=0;
    //你的目的是让高度最大，所以说你要尽可能的去调高mid,才能让你高度最大
	//所以把l=mid 
    while(l+1<r){//二分 
        long long mid=(l+r)>>1;
        if(check(mid)){
        	l=mid;
		}
        else{
        	r=mid;
		}
    }
    cout<<l<<endl;
    //write(ans);
}

---

## 作者：ImposterAnYu (赞：3)

# 思路
看到这道题目时，我的第一反应是：枚举。

设最高的树的高度为 $s$，则先假设 $h = s - 1$，然后每次 $h \leftarrow h - 1$，再用一个变量 $t$ 记录砍下来的木材长度，每当一棵树的高度 $a_{i} > t$ 时，$t \leftarrow t + 1$。最后一旦 $t \ge m$，就跳出循环，输出 $h$。
# TLE code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,a[1000005],t;
inline int read(){//快读。
    int num = 0;
	char c = getchar(),up = c;
    while(c < '0' || c > '9'){
    	up = c;
		c = getchar();
    }
    while(c >= '0' && c <= '9'){
    	num = (num << 1) + (num << 3) + (c ^ '0');
		c = getchar();
    }
    return up == '-' ? -num : num;
}
int main() {
	n = read();
	m = read();
	for(i = 1; i <= n; i++){
		a[i] = read();
	}
	sort(a + 1,a + n + 1);
	for(i = a[n] - 1; i >= 1; i--){
		for(j = n; j >= 1; j--){
			if(a[j] > i){
				t++;	
			}else{
				break;
			}
		}
		if(t >= m){
			break;
		}
	}
	cout<< i << endl;
    return 0;
}
```
然而，出乎我的意料，59分……

# 优化
经过一系列的思考后，我意识到：循环次数太多了！

为了减少循环次数，我们可以再定义一个变量 $p$，初始化为 $1$，表示现在高度 $> h$ 的树的数量。每次第二层循环执行前 $t$ 先加上 $p$，每找到一棵树高度比 $h$ 高时，$p \leftarrow p + 1$。

这样，每次第二层循环都珂以从 $n - p$ 开始，而不用从 $n$ 开始，可以省下很多时间！

那么下面，就是大家最期待的 AC 代码了！
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,a[1000005],t,p = 1;
inline int read(){//快读。
    int num = 0;
	char c = getchar(),up = c;
    while(c < '0' || c > '9'){
    	up = c;
		c = getchar();
    }
    while(c >= '0' && c <= '9'){
    	num = (num << 1) + (num << 3) + (c ^ '0');
		c = getchar();
    }
    return up == '-' ? -num : num;
}
int main() {
	n = read();
	m = read();
	for(i = 1; i <= n; i++){
		a[i] = read();
	}
	sort(a + 1,a + n + 1);
	for(i = a[n] - 1; i >= 1; i--){
		t += p;
		for(j = n - p; j >= 1; j--){
			if(a[j] > i){
				t++;
				p++;
			}else{
				break;
			}
		}
		if(t >= m){
			break;
		}
	}
	cout<< i << endl;
    return 0;
}
```


---

## 作者：JA_yichao (赞：3)

## Jackma题解第二弹！


### 题目描述
mxy 被小 w 叫去砍树了。mxy 需要砍倒 M 米长的木材。现在 mxy 弄到了一个奇怪的伐木机。

mxy 的伐木机工作过程如下：mxy 设置一个高度参数 H（米），伐木机升起一个巨大的锯片到高度 H，并锯掉所有的树比 H 高的部分（当然，树木不高于 H 米的部分保持不变）。mxy就得到树木被锯下的部分。

例如，如果一行树的高度分别为 20，15，10 和 17 米，mxy 把锯片升到 15 米的高度，切割后树木剩下的高度将是 15，15，10 和 15 米，而 mxy 将从第 1 棵树得到 5 米，从第 4 棵树得到 2 米，共得到 7 米木材。

mxy 非常关注生态保护，所以 ta 不会砍掉过多的木材。这正是 ta 为什么要尽可能高地设定伐木机锯片的原因。帮助 mxy 找到伐木机锯片的最大的整数高度 H，使得 ta 能得到的木材至少为 M 米。换句话说，如果再升高 1 米，则 ta 将得不到 M 米木材。

### 输入
第1 行：2 个整数 N 和 M，N 表示树木的数量(1 ≤ N ≤ 1 000 000)，M 表示需要的木材总长度(1 ≤ M ≤ 2 000 000 000)。

第2 行：N 个整数表示每棵树的高度，值均不超过 1 000 000 000。保证所有木材长度之和大于 M，因此必然有解。

### 输出
一行 1 个整数，表示砍树的最高高度。

### 输入样例
5	20	
4	42	40	26	46

### 输出样例
36

**主要思想就是用二分来求得答案。**

**l 和 r一定要赋初值，我开始没赋就错了。**


### 代码：
```cpp
#include<cstdio>
using namespace std;
long long n,m,a[10000001],l=1,mid,r,s;
int main()
{
	scanf("%d%d",&n,&m);      //输入
	for(int i=1; i<=n; i++)
	 {
	 	scanf("%d",&a[i]);
	 	r+=a[i];
	 }
	while(l+1<r)          //二分
	 {
	 	mid=(l+r)/2;
	    for(int i=1; i<=n; i++)
	     if(a[i]>mid)
	       s+=a[i]-mid;
	    if(s>=m)
	      l=mid;
	    else
	      r=mid;
	    s=0;
	 }
	cout<<l;
	return 0;
}
```

[csdn地址](https://blog.csdn.net/Jackma_mayichao/article/details/99946174)

---

## 作者：Komorebi_shine (赞：3)

二分模板题（好似所有的二分都可以套模板），本代码由[P2440](https://www.luogu.org/problemnew/show/P2440)代码改编而来，P2440的题解我会随缘过。

首先这是二分标准模板：
```cpp
	l=1;
	r=n+1;
	while (l+1<r)
	{
		mid=(l+r)/2;
		if (check(mid)) l=mid;else r=mid; 
	}
```
其中check函数为二分条件满足判断函数，n为可能的最大取值，l=mid;else r=mid;也可以随题目改变，随边界处理。

所以套模板解决该题。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,r,n,m,a[1000001],i,j,c,mid;
bool check(int x)
{
	long long ii,ss=0;
	for (ii=1;ii<=n;ii++) ss+=max((long long)0,a[ii]-x);
//注意！本题不开long long会炸，50分，但开了

//long long而没有此处的类型强转会编译出错，因

//为0的标准类型是int，int和long long属不同类

//型，不能一起max计算。如果读者编译器试验与我不

//同请忽略该行
	return ss>=m;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		c=max(c,a[i]);
	}
	l=1;
	r=c+1;
	while (l+1<r)
	{
		mid=(l+r)/2;
		if (check(mid)) l=mid;else r=mid; 
	}
	printf("%d\n",l);
}
```

---

## 作者：vvauted (赞：3)

## Luogu P7766 题解
## Description
给出长为 $n$ 序列 $a$ ，求最大的 $k$ 使 $\sum_{i=1}^{n}a_i-k[a_i> k] \ge m$
给出一种样例图解：

![图丑勿喷](https://cdn.luogu.com.cn/upload/image_hosting/qz1ppyy8.png)
## Solution
考虑把每一个权压到桶 $b$ 里，枚举截高。

可以推导出，从 $k+1$ 下降到 $k$ ，截的长会增加$\sum_{i=k}^{maxa}b_i$ 

也就是 $k$ 在桶 $b$ 中的后缀和

考虑输入时把其塞入桶中，并处理下序列 $a$ 中的最大值 $maxa$

最后 while 循环枚举截长，找最大满足条件的值就输出

## Code

```cpp
#include <stdio.h>
#define Maxh 1000010
int blc[Maxh];
int main()
{
	int n,m,h,max,sum=0,now=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&h);
		blc[h]++;
		max=h>max?h:max;
	}
	while(now<m)
	{
		sum+=blc[max];
		now+=sum;
		max--;
	}
	printf("%d",max);
} 
```



---

## 作者：Mcggvc (赞：3)

题目链接：[P1873 砍树](https://www.luogu.org/problemnew/show/P1873)

#### 这道题并不需要二分（~~其实是我不会~~）暴力枚举就可以过

我们先将树的高度由大到小排序，定义答案ans初始为最高的树的高度，当目前获得树木长度小于M米时，执行：

1.锯片高度(ans)下降一米

2.当前获得树木长度(lon)+=之前可以砍到的树的数量+降低高度后可以砍到树的数量（因为每次只会下降1m）

3.判断lon是否大于M

代码：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#define ll long long 
using namespace std;
ll n,m;
ll tre[1000100];
bool cmp(ll a,ll b){return a>b;} //降序
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>tre[i];
	sort(tre+1,tre+n+1,cmp); 
	ll lon=0；//lon：当前得到的木材长度
	ll tot=0;//tot：当前可以砍到的树的数量
	ll ans=tre[1],i=1;//ans：锯片高度
	while(lon<m&&i<=n)
	{
	    ans--;
		while(tre[i]>ans) 
		{
		    i++;
		    tot++;
		}
		lon+=tot;
		if(lon>=m) break;
	}
	cout<<ans;
	return 0;	
}
```

再次膜拜[ZCJ dalao](https://www.luogu.org/space/show?uid=84079)

---

## 作者：夙_晏清 (赞：3)

# 二分算法
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[10000001],l,r,tot;//l为左边界，r为右边界 
int ch(){
    while(l+1<r){
        int mid=(l+r)/2;  
        tot=0; //分
        for(int i=1;i<=n;i++){
            if(a[i]>mid) tot+=a[i]-mid;  //排
        }
        if(tot<m) r=mid;
        else l=mid; 
    }
    return l;//并
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) 
	cin>>a[i];
    sort(a+1,a+n+1);
    l=0;
    r=a[n];
    cout<<ch()<<endl;
}
```

---

## 作者：CSETIS (赞：3)

日常暴力：（40分）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
	long long n,m,ans=0;
	int a[10000001];
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
//输入
	for(int i=a[n];i>=0;i--){
//i为锯片高度
		for(int j=1;j<=n;j++){
			if(a[j]-i>0) ans+=a[j]-i;
		}
//当锯片降至i时有效总和
		if(ans>=m){
			cout<<i<<endl;
			return 0;
		}
		else ans=0;
//如果ans大于等于需要的木材总长度便输出，否则清空ans
	}
}
```

二分法：（100分）
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,a[10000001],l,r,tot;
//l为左边界，r为右边界 

int ef(){
	while(l+1<r){
//左开右闭 
        int mid=(l+r)/2; 
//锯片高度 
        tot=0; 
//清空总和 
        for(int i=1;i<=n;i++){
        	if(a[i]>mid) tot+=a[i]-mid; 
//计算有效总和 
		}
        if(tot<m) r=mid;
//木材不够，降低锯片至mid 
        else l=mid;
//木材冗余，增加锯片至mid 
    }
    return l;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
//输入
	sort(a+1,a+n+1);
//排序
	l=0;
//左边界 
	r=a[n];
//右边界为最高的树的高度 
    cout<<ef()<<endl;
//输出
}
```

---

## 作者：Lithium_Chestnut (赞：2)

~~双倍经验啊。~~

这里大家都会用二分，但是写一下代码更为快捷的 `sort`。

便于方便书写，下面我们把砍完第 $a$ 棵树后的高度简写为 $h_a$。

现在我们排序后，树的高度也是从高到低排。

我们完全可以依题意直接暴力大法，推柿子不难得到 $h_{i+1}=(h_{i+1}-h_{i+2}) \times (i+1)$。

然后就结束了。~~不得不说 `STL` 真香！~~

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,cnt,sum,ans,t[1000001];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>t[i];
    sort(t+1,t+n+1);
    cnt=n;
    while(sum<m)
    {
        sum+=(t[cnt]-t[cnt-1])*(n-cnt+1);
        cnt--;
    }
    ans=t[cnt]+(sum-m)/(n-cnt+2);
    cout<<ans;
    return 0;
}
```


---

## 作者：吴国铨 (赞：2)


算法：二分法；因为高度参数越高，能砍到的木头就越少，所以，题目具有单调性 。

代码：

```cpp
var a:array[1..10000000]of int64;
  n,m,l,r,k:int64;
  i:longint;
function ok(h:int64):boolean;//判断是否可行
var i:longint;
  s:int64;
begin
  s:=0;
  for i:=1 to n do
    if a[i]>h then inc(s,a[i]-h);
  if s>=m then ok:=true
  else ok:=false;
end;
begin
  readln(n,m);
  for i:=1 to n do begin
    read(a[i]);
    if a[i]>k then k:=a[i];
  end;
  l:=0; r:=k+1;
  while l+1<r do begin//二分模块
    k:=(l+r)div 2;
    if ok(k) then l:=k
    else r:=k;
  end;
  writeln(l);
end.
```

---

## 作者：zclzslz (赞：2)

本题是一道较简单的二分，鉴于题解这么少，本着服务众人的态度，我还是发一个题解吧！

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;
long long m,r(0),l=0;//数据范围较大，要用long long，否则70分！
int n;
long long a[1000005];
int main()
{
    scanf("%d %lld",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        r=max(r,a[i]);//二分范围是1到最高的高度
    }
    while(l<r)
    {
        long long mid=(l+r+1)/2;
        long long sum(0);
        for(int i=1;i<=n;i++)
        if(a[i]>mid)
        sum+=a[i]-mid;
        if(sum>=m)
        l=mid;//答案可能包含mid
        else
        if(sum<m)
        {
            r=mid-1;
        }
    }
    printf("%lld\n",l);
    return 0;
}
```

---

## 作者：梅心 (赞：2)

这是一个二分答案的基础例题，有些蒟蒻不知道二分答案，我来讲一下，二分答案通俗的说就是不断地通过二分调整逼近答案。

其实二分答案很简单，只是要理解题意并写好check函数就可以了。

本题check函数
```
bool check(int x)//判断当高度为x米时，是否大于要求高度 
{
	long long sum = 0;//因为每棵树的高度相加可能超过int 
	for(int i = 1; i <= n; i++)
	{
		if(a[i] > x)
		{
			sum = sum + a[i] - x;//累加 
		}
	}
	return sum >= m;//如果sum>=m，返回true，否则返回false; 
}
```

```
#include<bits/stdc++.h>
using namespace std;
int a[10000005];
int n, m;
bool check(int x)//判断当高度为x米时，是否大于要求高度 
{
	long long sum = 0;//因为每棵树的高度相加可能超过int 
	for(int i = 1; i <= n; i++)
	{
		if(a[i] > x)
		{
			sum = sum + a[i] - x;//累加 
		}
	}
	return sum >= m;//如果sum>=m，返回true，否则返回false; 
}
int main()
{
	int l = 1, r;//最高最低边界 
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];//输入高度 
		r = max(r, a[i]);//记录最高边界 
	}
	r++;//后面可以判断到r 
	while(l + 1 < r)
	{
		int mid = l + (r - l) / 2;//取中间值 
		if(check(mid) == true)//如果高度为mid时>=m 
		{
			l = mid;//最低边界变为mid 
		}
		else
		{
			r = mid;//否则最高边界变为mid 
		}
	}
	cout << l;//输出 
	return 0; 
}
```
感谢apple365

---

## 作者：Aleph1022 (赞：2)

题目中有这么一句：

> 换句话说，如果再升高 $1$ 米，则他将得不到 $M$ 米木材。

这句话使我想到了倍增。
实际上，几乎所有二分可以解决的问题，倍增也行，因为都具有单调性。

我们可以逐渐尝试跳 $2^{\log{10^9}},2^{\log{10^9} - 1},\dots,2^{1},2^{0}$ 米，如果跳到的新高度割完之后得不到 $M$ 米木材，就不跳，否则接着跳。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e6;
const int LG = 35;
int n;
long long m,a[N + 10],ans;
inline long long calc(long long h)
{
	long long ret = 0;
	for(register int i = 1;i <= n;++i)
		ret += max(a[i] - h,0LL);
	return ret;
}
int main()
{
	scanf("%d%lld",&n,&m);
	for(register int i = 1;i <= n;++i)
		scanf("%lld",a + i);
	for(register int i = LG;i >= 0;--i)
		if(calc(ans + (1LL << i)) >= m)
			ans += 1LL << i;
	printf("%lld\n",ans);
}
```

---

## 作者：VenusM1nT (赞：2)

这题还是比较经典的二分题，与木材加工相当相似，只需要稍微改动一下即可

由于数据较大，要使用long long 来存

具体见代码



```cpp
#include<cstdio>
#include<algorithm>
long long a[1000005],ans,maxn,l,r,mid,n,k;
int main()
{
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        maxn=std::max(a[i],maxn);//输入每个数，二分的界限为 0~所有树高中最高的那个 避免漏过答案 
    }
    l=0;
    r=maxn;//将刚刚算出的界限带入l和r 
    while(l<=r)
    {
        mid=(l+r)/2;//非常经典的二分，和木材加工的过程几乎相同 
        long long ct=0;//ct记录在切割高度为mid时所能获得的最长木材数 
        for(int i=1;i<=n;i++) if(a[i]-mid>=0) ct+=a[i]-mid;//要注意，这里必须要加负数的判断，否则会发生喜闻乐见的事情 
        if(ct>=k)
        {
            ans=std::max(ans,mid);//如果长度够，就记录答案 
            l=mid+1;
        }
        else r=mid-1;//分别按照情况改变lr的大小 
    }
    printf("%lld",ans);//输出答案 
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

要不是数据大，这题是一道普普通通的模拟题

然而，数据大，这题就演化成了二分答案

其实这题只需要用二分枚举伐木机锯齿的高度

每次都算出能得到的木材有多长，如大于等于题目给出的木材总长度，就输出

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,s,x[1000005],k,mid,l,r;//一定要用long long，x数组要开得大些 
int main()
{
    cin>>n>>s;
    for (int i=1;i<=n;i++) 
    {
        scanf("%I64d",&x[i]);
        r=max(r,x[i]);
        //由于木材切割机锯齿的高度太高，就切不到树，高度最高不能大于所有树的高度的最大值 
    }
    while (l<=r)
    {
        mid=(l+r)/2;//用mid来模拟切割机的锯齿的高度 
        k=0;
        for (int i=1;i<=n;i++) if (x[i]>mid) k+=x[i]-mid;//算出能得到木材的总长度 
        if (k<s) r=mid-1; else l=mid+1;
        //如果总长度小于要求的长度，将模拟范围缩小到mid的左半边，否则缩小到mid的右半边 
    }
    cout<<l-1;//由于找的是第一个满足条件的方案，所以，-1 
    return 0;
}
```

---

## 作者：时光 (赞：2)

来发Pascal

看到那范围~明显二分

```cpp
var n,m,i,l,r,mid,max:longint;
    a:array[0..1000000]of longint;
function  solve(k:longint):boolean;//判断这个mid的值看出来的树是否合格
var
i:longint;
hh:int64;
begin
hh:=0;
for i:=1 to n do
if a[i]>k then hh:=hh+a[i]-k;
if hh>=m then exit(true);//注意！！加上=。等于的情况还是要做的。万年坑~ 
exit(false);
end;
begin
readln(n,m);
for i:=1 to n do
begin
read(a[i]);
if a[i]>max then max:=a[i];
end;
l:=0;
r:=max+1;//最大可能
while l+1<r do//二分，注意是l+1，防止死循环
begin
mid:=(l+r) div 2;
if solve(mid) then l:=mid//可以达到说明砍太矮了，l加上
  else r:=mid;//太高了导致不够
end;
write(l);//因为题目说了高度在+1要不够，所以输l（小的）
end.
```

---

## 作者：eEfiuys (赞：1)

题目: [P7766](https://www.luogu.com.cn/problem/P7766)

这道题和 [P1873](https://www.luogu.com.cn/problem/P1873) 是一模一样的。

首先，我们会发现，数据范围是 $10^6$, 如果暴力枚举，时间复杂度 $O(n^2)$, 肯定会 TLE。

于是我们考虑**二分**。设最高的树高为 $maxn$, 则二分的范围为 $[0,maxn]$。

大部分二分的题都可以使用**倍增**来写。设 $pos$ 为最终答案。从一个大于 $maxn$ 的二进制数，即 $2^x$ 开始枚举，如果按照 $pos+i$ 的高度去砍树可以获得足够的木材，那么就将高度升至 $pos+i$。每次 $i$ 都除以 $2$, 即右移 $1$ 位。

倍增的好处就是上下界处理方便，不用考虑 $maxn$, 每次都根据数据范围枚举即可，这里是 $2^{24}$, 即 $1$ 左移 $24$ 位。

二分和倍增的时间复杂度都是 $O(n \log n)$。注意倍增时 `int` 就够了，但是在求能否砍下足够的木材时，最大为 $n \times m$, 需要开 `long long`。

------------

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,pos,a[1000001];
long long cal(int h) //求木材够不够。
{
	long long ans=0;
	for(int i=1;i<=n;i++)
		if(a[i]>h)
			ans+=(long long)a[i]-h;
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(int i=(1<<24);i;i>>=1) //倍增。
		if(cal(pos+i)>=m) //木材够。
			pos+=i; //升高高度。
	printf("%d",pos);
	return 0;
}
```

---

## 作者：清风我已逝 (赞：1)

二分查找练习题

总结:一定要判断好左右端点那个才是终结点


另外：此题不用开long long 

判断方法的问题：只需判断在添加过程中是否超出给定值即可


奉上代码：

```cpp
#include<cstdio>

#define max(a,b) (a>b?a:b)

using namespace std;
int l,r,mid,n,m,a[1000005],maxx;
bool judge(int x){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(a[i]>=x)ans+=a[i]-x;
		if(ans>=m)return true;
	}if(ans<m) return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		maxx=max(a[i],maxx);
	}
	r=maxx;
	while(l<=r){
		mid=(l+r)/2;
		if(judge(mid)==1) l=mid+1;
		else r=mid-1;
	}
	printf("%d",r);
	return 0;
}
```

---

## 作者：pupuvovovovovo (赞：1)

首先，1000000的数据肯定是要二分的。

然后，还是强烈建议把判断条件是否满足写进子程序。

这里可以把截出的长度小于m定为true，不是小于等于。

于是最后把ans-1。

最后，贴上代码。


```cpp
var a:array [1..1000000] of longint;
n,need,i,l,r,m,ans,max:longint;
function judge(x:longint):boolean;
var i:longint;
sum:int64;//顺带提一句，一定要小心一种叫做“int64”的东西。数据一大就要开。
begin
  sum:=0;
  for i:=1 to n do
    if a[i]>x then sum:=sum+a[i]-x;
  if sum<need then exit(true);
  exit(false);
end;
//所谓子程序
begin
  read(n,need);
  for i:=1 to n do
  begin
    read(a[i]);
    if a[i]>max then max:=a[i];
  end;
  l:=0;
  r:=max;
  while l<=r do
  begin
    m:=(l+r) div 2;
    if judge(m) then
    begin
      ans:=m;
      r:=m-1;
    end
    else l:=m+1;
  end;
  write(ans-1);
end.
```

---

## 作者：睿屿青衫 (赞：1)

数据这么大，总不能枚举吧？明显是二分答案（如果不熟移驾”跳石头“）

这道题坑点在哪呢？数据范围太大，int只能70，所以开long long（我用lll表示）

定义左右边界时尽可能优，左取树的最小高度，右取最大

代码如下（借鉴思想，禁止抄袭）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 2000000
#define lll long long
using namespace std;
lll n,m,p[maxn],ll=0x7fffffff,rr=0,ans;
lll check(lll x)
{
    lll ss=0;
    for(lll i=1;i<=n;i++)
     {
         if(p[i]>x)//如果这棵树的高度大于你要下手的高度 
          ss+=p[i]-x;//当前的总长加上被砍下来的 
```
}//如果小于等于，肯定砍不了，不管他
```cpp
    if(ss>=m) return 1;//够长，回1 
    return 0;//前一步了还没跳出循环，那就是不够长，回0 
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(lll i=1;i<=n;i++)
     {
         scanf("%lld",&p[i]);
         rr=max(rr,p[i]);//定义好边界省的麻烦（诸如超时之类的） 
         ll=min(ll,p[i]);
     }
    while(ll<=rr)
```
{//闭区间
```cpp
         int mid=(ll+rr)/2;//中间值 
         if(check(mid))//中间值可以取到，就找比他大的，即右区间 
          ll=mid+1,ans=mid;//跳到右区间，答案更新为可取的最大值 
         else rr=mid-1;//不满足就找左边 
     }
    printf("%lld",ans);
    return 0;
}
```

---


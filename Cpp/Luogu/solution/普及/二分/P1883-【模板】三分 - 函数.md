# 【模板】三分 | 函数

## 题目描述

给定 $n$ 个二次函数 $f_1(x),f_2(x),\dots,f_n(x)$（均形如 $ax^2+bx+c$），设 $F(x)=\max\{f_1(x),f_2(x),...,f_n(x)\}$，求 $F(x)$ 在区间 $[0,1000]$ 上的最小值。

## 说明/提示

对于 $50\%$ 的数据，$n\le 100$。

对于 $100\%$ 的数据，$T<10$，$\ n\le 10^4$，$0\le a\le 100$，$|b| \le 5\times 10^3$，$|c| \le 5\times 10^3$。

## 样例 #1

### 输入

```
2
1
2 0 0
2
2 0 0
2 -4 2
```

### 输出

```
0.0000
0.5000
```

# 题解

## 作者：Dangerise (赞：18)

我们知道，二分可以对单调函数求解近似解。它通过一步一步缩小答案的区间范围，最终确定答案。

三分也是一种类似的算法。

对一个定义域为 $(l,r)$ 的函数 $f(x)$ 如果其在 $(l,a)$ 单调递增 ,在 $(a,r)$ 单调递减，那么 $f(x)$ 我们习惯称其为单峰函数，显然 $f(a)$ 是 $f(x)$ 的最大值。

引用百度百科

>  单峰函数是在所考虑的区间中只有一个严格局部极大值(峰值)的实值函数。如果函数 $f(x)$ 在区间 $[a, b]$ 上只有唯一的最大值点 $C$ ，而在最大值点 $C$ 的左侧，函数单调增加；在点 $C$ 的右侧，函数单调减少，则称这个函数为区间 $[a, b]$ 上的单峰函数。

类似地，我们得到单谷函数的定义。

例如，对于二次项系数大于 $0$ 的二次函数，是单谷函数，二次项系数小于 $0$ 则为单峰函数。

特殊地，我们将一次函数也视为单峰函数和单谷函数。

三分，则可以对于单谷函数或单峰函数，确定它的极大值和极小值。

~其实不用严格单调也可以~

考虑以下代码

```cpp
double l=0,r=1000;
while(r-l>eps){
	double mid1=(2*l+r)/3;
	double mid2=(l+2*r)/3;
	if(f(mid1)<f(mid2)){
		r=mid2;
	}else{
		l=mid1;
	}
}
```

对于一个区间 $[l,r]$，已知 单谷函数$f(x)$ 在其上有最小值。

我们取两个点。

$$mid_1=l+\frac{r-l}{3}=\frac{2l+r}{3}$$

$$mid_2=l+\frac{2(r-l)}{3}=\frac{l+2r}{3}$$

即 $mid_1,mid_2$ 是 $[l,r]$ 的三等分点。

当 $f(mid_1)<f(mid_2)$ ，假设 $a \in [mid_2,r]$，那么由于 $[l,mid_2]$ 上肯定单调递减，故与 $f(mid_1)<f(mid_2)$ 矛盾。故当 $f(mid_1)<f(mid_2)$ ，$a \in [l,mid_2]$ 。

同理，可以得到 $f(mid_1)>f(mid_2)$ 时，$a \in [mid_1,r]$ （等号可以任取）。

所以，我们就可以通过，$f(mid_1)$ 与 $f(mid_2)$ 的大小关系，一步一步缩小极值点 $a$ 的范围。

对于整数上的二分和三分，我们终止算法的条件写成 $l \le r$ 便可以。但这道题要在实数上进行三分，所以当区间范围被缩小到某一个值时，我们就可以近似将这个区间视为一个点了。即 $r-l>eps$ , $eps$ 就是三分的精度值，$eps$ 越小，便离实际答案越接近。这道题中我们取 $eps=10^{-9}$ 。

关于其时间复杂度，

在三分中，每次可以将目前的范围缩小到 $\frac{2}{3}$。故 $f(x)$ 的计算次数 $k$ 有 $m(\frac{2}{3})^k=eps$，$k=log_{\frac{2}{3}}\frac{eps}{m}$，此题中 $eps$ 为 $10^{-9}$ , $m$ 为 $10^3$ 。

故时间复杂度为 $O(t\log \frac{eps}{m})$ , 其中 $t$ 为 $f(x)$ 计算一次的复杂度。

在我们掌握了三分法之后，回到这个题目。结合题目的标题我们很显然能直接猜到 $F(x)$ 是一个单谷函数。

具体地，我们怎么去理性地得到这个结论呢？

考虑数学归纳法

已知 $f_i(x)$ 是一个单谷函数（无论它是一次函数还是二次函数）。

假设 $\max \{f_1(x),f_2(x),\cdots,f_{i-1}(x)\}$ 是单谷函数。

则只要证明 $max\{\max \{f_1(x),f_2(x),\cdots,f_{i-1}(x)\},f_i(x)\}$ 是单谷函数。

则要证 若 $f(x),g(x)$ 为单谷函数，则 $max\{f(x),g(x)\}$ 为单谷函数。

关于这一点，通过图像上可以轻易地去理解，但是证明较为困难，三位同学给出的证明包括，

- 通过讨论所有情况来证明

- 傅里叶变化

- 一种极其抽象的方法，通过在函数上取点反证

总之，证明略。

以下为代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=114514,inf=INT_MAX;
const double eps=1e-9;

int n;
int a[N],b[N],c[N];
inline double f(double x){
	double maxn=-inf;
	for(int i=1;i<=n;i++){
		maxn=max(maxn,a[i]*x*x+b[i]*x+c[i]);
	}
	return maxn;
}

signed main() {
	int t;
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i]>>b[i]>>c[i];
		}	
		
		double l=0,r=1000;
		while(r-l>eps){
			double m1=(2*l+r)/3;
			double m2=(l+2*r)/3;
			if(f(m1)<f(m2)){
				r=m2;
			}else{
				l=m1;
			}
		}
		
		cout<<fixed<<setprecision(4)<<f(l)<<endl;
	}
	return 0;
}
```

---

## 作者：ldqldq (赞：6)

楼上的方法以三分为主，还有一种判断区间的二分，这里提供另一种二分的思路，对于初学者更好理解。

首先分析F(x)函数，易知仅有一个最低点（否则...模拟退火貌似更好？），设其为x0，则x0左端函数单调递减，x0右端函数单调递增。

换句话说，若当前点在x0左端则当前点函数斜率为负，反之则为正。

至于某一点x斜率的正负，我们仅仅需要算出F(x-Δx)，F(x)，F(x+Δx)的大小关系，根据大小关系二分即可。（即：斜率小于0时向右二分，反之向左二分；若F(x-Δx)>F(x)且F(x)<F(x+Δx)，则x已经极接近最低点了），其中Δx为一个极小值，经验证本题（本做法）Δx不能大于1e-8。

下面是代码
```cpp
#include<cstdio>
using namespace std;
int n,T;
double a[10009],b[10009],c[10009],f1,f2,f3;
double f(double x){//计算函数值，直接按题目描述算就行
    double max=-1e9-7;
    for(int i=1;i<=n;i++){
        double tmp=a[i]*x*x+b[i]*x+c[i];
        if(tmp>max)max=tmp;
    }
    return max;
}
int main(){
    scanf("%d",&T);
    for(int ii=1;ii<=T;ii++){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%lf%lf%lf",&a[i],&b[i],&c[i]);
        }
        double l=0,r=1000,mid=(l+r)/2;
        f1=f(mid-0.00000001);
        f2=f(mid);
        f3=f(mid+0.00000001);
        while(!((r-l<0.00000001)||((f1>f2)&&(f3>f2)))){//除了常规二分退出条件外，若当前点函数值同时小于左右也要退出
            if((f1>f2)&&(f2>f3))l=mid+0.00000001;
            if((f1<f2)&&(f2<f3))r=mid-0.00000001;
            mid=(l+r)/2;
            f1=f(mid-0.00000001);
            f2=f(mid);
            f3=f(mid+0.00000001);
        }
        printf("%.4lf\n",f2);
      }
        return 0;
}
    
```


---

## 作者：SunsetSamsara (赞：5)

我的思路是数学方法，可以通过二次函数的性质来解答。

先看数据范围，发现这些二次函数的首项系数 $a \geq 0$。

而系数 $a \geq 0$ 的二次函数是开口朝上的抛物线，即**这样**:

![](https://cdn.luogu.com.cn/upload/image_hosting/tf7obovr.png)

所以，存在数 $x=-\dfrac b {2a}$ （对称轴 $x$ 坐标）使得二次函数 $f_k(x)$ 在区间 $(-\infty,x)$ 上单减，在区间 $(x,\infty)$ 上单增。

于是，函数 $f_k(k\in[1,n])$都是单峰函数。

那么我们取 $\max$ 之后的 $F$ 也是单峰函数，不严谨证明如下:

若存在两个 $x$ 记作 $x_1,x_2$ 使得 $x_1,x_2$ 都是局部极小值，

那么 $(x_1,F(x_1))$ 这个点所在的二次函数 $f_a$ 在对方点上的值 $f_a(x_2)$ 要大于 $f_a(x_1)$，

所以 $F(x_1) > f_a(x_1)$ , 即 $(x_1,F(x_1))$ 不在的二次函数 $f_a$ 上，矛盾！

即不存在两个 $x$ 使得它们都是 $F(x)$ 的局部极小值。

所以，$F(x)$是单峰函数。

综上，可以使用三分法解决。

代码如下：
```c
#include<stdio.h>
int A[10001],B[10001],C[10001];
int n;
double calcF(double d){
	double ret=0,t;
	for(int i=1;i<=n;++i){
		t=(A[i]*d+B[i])*d+C[i];
		if(ret<t)ret=t;
	}
	return ret;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;++i)
			scanf("%d%d%d",A+i,B+i,C+i);
		double l=0,r=1000,dis=(r-l)/3,lmid=l+dis,rmid=r-dis; //左端点，右端点，用三分点lmid与rmid分界
		while(r-l>1e-9){
        //把大的值赋值给l或r
			if(calcF(lmid)>calcF(rmid))l=lmid;
			else r=rmid;
			dis=(r-l)/3;lmid=l+dis;rmid=(r-dis);
        //再算一遍
		}
		printf("%.4lf\n",calcF(l));
	}
}
```

---

## 作者：zhaisx (赞：3)

### 三分

学过三分的 dalao 可以直接去看**思路**。

众所周知，二分是在左右边界中折半查找。虽然这道题可以求导数再二分，但对于在上初中的本蒟蒻就不太友好了。QwQ

所以就有另一种十分友好的方法——三分。

所谓三分，本质上是找到两个中间点 $u$ 和 $v$。一般可以先进行二分，在区间 $\left[l, r\right]$ 中找到中点 $m$，然后将 $u$ 和 $v$ 分别设为 $m$ 加减一个极小的值 $\varepsilon$，即

$$
m \gets \frac{l + r}{2} \\
u \gets m - \varepsilon \\
v \gets m + \varepsilon
$$

此时，对于一个在 $\left[l, r\right]$ 内的单谷函数 $f(x)$（只存在一个点 $p$，在 $\left[l, p\right)$ 上单调递增，在 $\left(p, r\right]$ 上单调递减），如果 $f(u) < f(v)$，则区间 $\left(m, r\right]$ 可以舍去。（如下图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/i8ngvxxb.png)

反之，如果 $f(u) > f(v)$，则区间 $\left[l, m\right)$ 可以舍去。（如下图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/5p1wl39v.png)

如果 $f(u) = f(v)$ 呢？那答案不就是 $m$ 吗！（如下图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/or05h1g4.png)

一直重复以上过程，直到 $l + \varepsilon \geq r$ 为止。

### 思路

观察本题，发现是对函数 $F(x)$ 求最小值，则考虑三分。

首先要确定 $F(x)$ 为单谷函数。证明如下：

如果 $F(x)$ 不是单谷函数，则图像为下图中实线部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/8ov0ss2d.png)

但显然，虚线部分总是比实现部分大，则 $F(x)$ 只能为虚线部分。虚线部分显然为单谷函数，则 $F(x)$ 为单谷函数。

直接进行三分即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[10005], b[10005], c[10005];

double f(double x) {
    double y = INT_MIN;
    for (int i = 1; i <= n; i++)
        y = max(y, a[i] * x * x + b[i] * x + c[i]);
    return y;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        cin >> n;
        for (int i = 1; i <= n; i++)
            cin >> a[i] >> b[i] >> c[i];
        double l = 0, r = 1000, m, e = 1e-9;
        while (l + e < r) {
            m = (l + r) / 2;
            double u = m - e, v = m + e;
            double fu = f(u), fv = f(v);
            if (fu < fv)
                r = m;
            else if (fu > fv)
                l = m;
            else {
                l = m;
                r = m;
            }
        }
        cout << fixed << setprecision(4) << f((l + r) / 2) << '\n';
    }
    return 0;
}
```

### 附言

由于精度问题，$\varepsilon$ 要取 $10^{-9}$。

---

## 作者：ikunTLE (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1883)

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/0lpq81l3.png)

对于第 2 个样例，其 $2$ 个函数的图象如图所示。发现当 $x=0.5$ 时，$2$ 个函数的最大值最小，为 $0.5$。

### 算法介绍

[三分](https://oi-wiki.org/basic/binary/#%E4%B8%89%E5%88%86%E6%B3%95)是由二分延伸出的一种算法。但与二分不同的是，二分可以解决答案具有单调性的问题，而三分可以解决单峰或者单谷问题。例如本题所给的二次函数，就是一个单谷函数。

函数需要用浮点类型结构实现，而常用的 `double` 等类型会误差。所以规定所允许的误差 $\varepsilon$，本题需保留 $4$ 位小数，故规定 $\varepsilon=10^{-9}$。

然后进行三分，规定下界 $L$ 和上界 $R$，循环条件即为 $R-L>\varepsilon$。所谓三分，就是将其三等分，记两个中间点 $M_1$ 和 $M_2$，则 $M_1=L+\frac{R-L}{3}$，$M_2=R-\frac{R-L}{3}$。计算 $F(M_1)$ 的值与 $F(M_2)$ 的值进行比较。若 $F(M_1)<F(M_2)$，更新 $R\gets M_2$；否则更新 $L\gets M_1$。

### 正确性证明

更新 $R\gets M_2$，实则就是去掉区间 $(M_2,R]$，因为当前 $F(M_1)$ 的值更小，则 $M_1$ 更接近最小值。$L\gets M_1$ 同理。又因为二次函数一定是轴对称的，所以不存在更新区间时直接越过答案。

计算一次 $F(x)$ 的复杂度为 $N$ 级别，三分部分为 $\log V$ 级别。其中，$V$ 是二次函数的值域。整体时间复杂度 $\mathcal{O}(T\times N\log V)$。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e4+10;
const double EPS=1e-9;
int n,a[N],b[N],c[N];
double calc(double x,int p){ //计算二次函数 f(x)
	return a[p]*x*x+b[p]*x+c[p];
}
double f(double x){ //求最大值 F(x)
	double res=-1e18;
	for(int i=1;i<=n;++i)
		res=max(res,calc(x,i));
	return res;
}
void solve(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read(),b[i]=read(),c[i]=read();
	double l=0,r=1000; //已知 F(x) 在区间 [0,1000] 内
	while(r-l>EPS){
		double lmid=l+(r-l)/3,rmid=r-(r-l)/3.0; //两个中间点
		if(f(lmid)<f(rmid)) //M1 更贴近答案
			r=rmid; //舍去区间 (M2,R]
		else l=lmid; //舍去区间 [L,M1)
	}
	printf("%.4lf\n",f(l)); //最终输出的是 F(x) 的最小值
	return;
}
int main(){
	int T=read();
	while(T--)
		solve();
	return 0;
}
```

---

可以做做 [P3382](https://www.luogu.com.cn/problem/P3382) 练练手。

---

## 作者：Noah03 (赞：2)

### 题目大意

---

[题目传送门](https://www.luogu.com.cn/problem/P1883)

给定 $n$ 个二次函数 $f_n(x)=ax^2+bx+c$，令 $F(x)=\max{\{f_1(x),f_2(x),f_3(x),...,f_n(x)\}}$，且其中 $x$ 的范围是 $[0,1000]$，求 $F(x)$ 在此范围能取到的最小值。

### 做法

---

本题是三分的模板题。

三分是什么呢？首先，想一下之前学过的二分。二分是解决单调函数上取值的问题，而三分则是用来解决单股（单峰）函数的取值问题（单股||单峰：在一个区间 $[L,mid]$ 内单调递增，在另一区间 $[mid,R]$ 内单调递减）。

二分中使用 $L$ 和 $R$ 来记录左边界和右边界，三分也是一样的。而二分中用 $mid$ 来记录中间值，但是三分中我们需要两个中间值：$Lmid$ 和 $Rmid$，$Lmid$ 记录靠近 $L$ 的中间值，$Rmid$ 记录靠近 $R$ 的中间值，可以简单认为 $[L,R]$ 是一条线段，而 $Lmid,Rmid$ 是这条线段的三等分点。如果 $Lmid$ 比 $Rmid$ 更优，将 $R$ 的范围缩小，否则缩小 $L$ 的范围。

### 代码

---

**抄袭一时爽，棕名两行泪。**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MAXN=1e4+10;
const double eps=1e-9;
int a[MAXN],b[MAXN],c[MAXN],n;
double js(double x){
	double ans=INT_MIN;
	for(int i=1;i<=n;i++) ans=max(ans,a[i]*x*x+b[i]*x+c[i]);
	return ans;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d %d %d",&a[i],&b[i],&c[i]);
		}
		double l=0,r=1000;
		while(r-l>eps){
			double lmid=l+(r-l)/3.0,rmid=r-(r-l)/3.0;
			if (js(lmid)<js(rmid)) r=rmid;
			else l=lmid;
		}
		printf("%.4f\n",js(l));
	}
	return 0;
} 
```

注意：要把精度开大一点（开成 `1e-5` 就爆零了），计算时不要把 `ans` 开成 `DBL_MIN`，`DBL_MIN` 的值为 0。

**The End.**

---

## 作者：c_legg (赞：2)

## 题意

给定一个单谷函数，求其最小值。

### 证明

我们先证明一下 $F(x)=\max\{f_1(x),f_2(x),\dots,f_n(x)\}$ 是一个单谷函数。

可以用反证法，假设 $F(x)$ 有 $2$ 个“谷底”（准确来讲是极小值），坐标分别为 $(x_1,y_1)$ 和 $(x_2,y_2)$，分别在 $f_a(x)$ 和 $f_b(x)$ 上，且 $y_1\le y_2$。

显然 $a\neq b$，因为题目中给的二次函数的二次项系数为非负数，所以每个 $f(x)$ 都是单谷的或单调的。

又因为一次函数没有谷底，所以 $f_a(x)$ 和 $f_b(x)$ 都不是一次函数，即 $f_a(x)$ 和 $f_b(x)$ 都是单谷的。

可以判断：$(x_2,y_2)$ 或 $(x_1,y_1)$ 一定有一个不是一个“谷底”。因为 $f_b(x)$ 单谷，所以对于所有 $x_0\neq x_2$，$f_b(x_0)\gt y_2\ge y_1$，因为 $x_0$ 可以为 $x_1$，所以 $(x_1,y_1)$ 在 $f_b(x)$ 上，与假设不符。

## 思路

就这样，问题变成了求一个单谷函数的最小值问题。

我们可以使用三分法。

三分法，顾名思义，就是把区间分成三份来求单峰/谷函数最值的方法。然而我们面临着 $2$ 个问题：

1. 怎么分？
2. 分完后要干什么？

我们来看看：

### 怎么分？

可以随便分，但是为了效率，一般我们把区间 $[l, r]$ 分成区间 $[l, lmid],(lmid, rmid),[rmid, r]$，这里开区间和闭区间对结果影响不大。

另外，可以定义 $lmid=mid-\varepsilon,rmid=mid+\varepsilon$ 来保证效率，其中 $\varepsilon$ 是一个很小的数。

### 分完后要干什么？

由于单谷函数的性质，可以发现：如果$F(lmid)\lt F(rmid)$，那答案就不在 $[rmid, r]$ 中，可以把 $r$ 改为 $mid$；同理如果 $F(lmid)\ge F(rmid)$，那答案就不在 $[l, lmid]$ 中，可以把 $l$ 改为 $mid$。一直进行下去，就可以使误差任意小。

这也就是用 $\varepsilon$ 定义 $lmid$ 和 $rmid$ 的原因：$lmid$ 和 $rmid$ 相差越小，一次可以排除的数就越多，效率就越高。

### 复杂度分析

计算一次函数值的复杂度为 $\Theta(n)$，寻找最值的复杂度就是 $\Theta(n\log m)$，这里 $m$ 与精度乘定义域成正比。

## 代码

``` cpp
#include <bits/stdc++.h>
#define E 1e-9
using namespace std;

int t, n;

double a[20000], b[20000], c[20000];

double f(double x) { // 函数求值
    double ans=-INT_MAX;
    for(int i=0; i<n; i++) ans=max(ans, a[i]*x*x+b[i]*x+c[i]);
    return ans;
}

void slove() {
    cin>>n;
    for(int i=0; i<n; i++) cin>>a[i]>>b[i]>>c[i];
    double l=0, r=1000;
    while(l+E<r) { // 三分
        double mid=(l+r)/2.0;
        double lm=mid-E, rm=mid+E;
        if(f(lm)<f(rm)) r=mid;
        else l=mid;
    }
    printf("%.4lf\n", f((l+r)/2.0));
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    
    cin>>t;
    
    while(t--) slove(); // 多测
    return 0;
}
```

---

## 作者：一只书虫仔 (赞：2)

#### Description

> 给定 $n$ 个二次函数 $f_i(x)$，$F(x)=\max\limits_{i=1}^n f_i(x)$，求 $\min\limits_{i=0}^{1000} F(i)$

#### Solution

首先介绍 **三分法**，他用于求一个凸函数的最大 / 小值。

设区间 $[l,r]$ 的三等分点为 $L,R$，会将整个区间分为三个子区间 $P_1=[l,L]$，$P_2=[L,R]$，$P_3=[R,r]$。

分类讨论：

- 极值在 $P_1$，那么可以选择舍弃 $P_3$ 将区间并为 $[l,R]$ 因为极值只能在这个区间。
- 极值在 $P_3$，那么可以选择舍弃 $P_1$ 将区间并为 $[L,r]$ 因为极值只能在这个区间。
- 极值在 $P_2$，那么可以选择舍弃左右两个区间中的任意一个因为极值在任意一个区间。

确定极值可以通过单调性来判断 $L$ 和 $R$ 的大小关系。

对于这道题，三分的 check 直接算 $F(x)$ 即可。

然后对于 $F$ 函数的凸性，答案一定是某一个 $f_i$ 函数的极值，或者是边界。

#### Code

```cpp
while (r - l > 1e-10) {
	double lmid = l + (r - l) / 3;
	double rmid = r - (r - l) / 3;
	if (check(n, lmid) > check(n, rmid)) 
		l = lmid;
	else
		r = rmid;
}
```

---

## 作者：MassPoint (赞：1)

我们都知道，二分适用于在单调函数上的查找，可是这道题要求的是在[单谷函数](https://baike.baidu.com/item/%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0/7544838)上查找最小值，这该怎么办呢？

我们可以用**三分**。

顾名思义，和二分类似，三分就是在二分的基础上，每次把答案区间（$[l,r]$）分成三份：$[l,lmid]$、$[lmid,rmid]$ 和 $[rmid,r]$，通过判断答案在哪一个区间范围内来不断缩小答案的范围求解。

那么，三分是怎样处理单峰/单谷函数呢？

我们来看一个例子。

当 $n=1$，$f_1(x)$ 的 $a=1,b=-6,c=5$ 时，且要计算 $[0,5]$ 之间 $F(x)$（或者说是 $f_1(x)$）的最小值时，我们来看看三分的表现（坐标系上的点从左往右分别代表 $l$、$lmid$、$rmid$、$r$）。

首先，$f_1(x)$ 的状态为：

![](https://cdn.luogu.com.cn/upload/image_hosting/jwistkwr.png)

因为答案在区间 $[lmid,rmid]$ 之间，所以状态变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/xfwjuel3.png)

此时答案明显又在 $rmid$ 和 $r$ 之间了，因此我们再次更新状态：

![](https://cdn.luogu.com.cn/upload/image_hosting/buwg0hgo.png)

（图片经过放大处理）

因此，在若干次缩小答案区间后，终于确定了答案：

![](https://cdn.luogu.com.cn/upload/image_hosting/o978c82a.png)

四舍五入保留四位小数后答案为 $5.0000$。

那么，知道了三分的原理，我们就可以写出三分的代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[10001],b[10001],c[10001];
double f(int cnt,double x){	return a[cnt]*x*x+b[cnt]*x+c[cnt];}
double ff(double x){
	double ans=f(1,x);
	for(int i=2;i<=n;i++)	ans=max(f(i,x),ans);
	return ans;
}
double g(){
	double l=0,r=1000;
	while(r-l>1e-10){
		double mid1=(2*l+r)/3.0;
		double mid2=(2*r+l)/3.0;
		if(ff(mid1)>ff(mid2))	l=mid1;
		else	r=mid2;
	}
	return ff(l);
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){		
		scanf("%d",&n);
		double ans;
		for(int i=1;i<=n;i++)	scanf("%d %d %d",&a[i],&b[i],&c[i]);
		ans=g();
		printf("%.4lf\n",ans);
	}	
	return 0;
}
```

和二分类似的，三分的时间复杂度是 $O(\log l)$，$l$ 为区间长度。

---

## 作者：Nahia (赞：1)

### 三分

三分是什么？

想必大家都学过二分，它是一种效率较高的查找方法。而三分也和二分类似，二分通过比较中间值来移动左右指针，而三分则有两个中间值，通过比较来移动左右两个指针。

> 如果需要求出单峰函数的极值点，通常使用二分法衍生出的三分法求单峰函数的极值点。

这就是三分，一种求单峰函数极值的一种查找方法。

同样的，对于单谷函数，三分也适用。

![](https://oi-wiki.org/basic/images/binary1.svg)

在接下来的讲解内，会以上图为例讲解，需要注意的是，定义图中左黄点为 $l$，右黄点为 $r$，左蓝点为 $lmid$，右蓝点为 $rmid$，中间的点为该单谷函数的最小值，$mid$ 是区间 $[l,r]$ 的中间点。

三分法与二分法的基本思想类似，但每次操作需在当前区间 $[l,r]$ 内任取两点 $lmid,rmid$（需要满足 $lmid < rmid$）。如上图，$f(lmid)<f(rmid)$，则在 $[rmid,r]$（上图中的红色部分）中函数必然单调递增，最小值所在点（上图中的绿点）必然不在这一区间内，可舍去这一区间。反之亦然。

由上面的做法可知，三分法每次操作会舍去两侧区间中的其中一个。为减少三分法的操作次数，应使两侧区间尽可能大。因此，每一次操作时的 $lmid$ 和 $rmid$ 分别取 $mid-\varepsilon$ 和 $mid+\varepsilon$ 是一个不错的选择（$\varepsilon$ 可取极小值）。

### 思路

> 三分。

不难发现，$F(x)$ 是一个单谷函数。

三分查找 $F(x)$ 最小的的自变量 $x_{min}$，对于每次找到的 $x$，计算每个 $f(x)$ 的值，然后从中取 $\max$（其实就是计算 $F(x)$），接着比较 $lmid$ 和 $rmid$ 计算出的 $F(x)$ 的大小，让指针移动（具体见上方三分的通用方法），使剩下的部分的函数值更小。最后当找到使 $F(x)$ 最小的 $x_{min}$ 时，输出 $F(x)$。

### solution

（之前的代码，码风可能不是很友好）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<vector>
#include<algorithm>
#include<ctime>
#include <cstdlib>
using namespace std;
const double esp = 1e-10;
const int N = 1e4+5;
double a[N],b[N],c[N];
int t,n;
double f(double x){
	double sum = -0x7FFFFFFF,num = 0;
	for(int i=1;i<=n;i++){
		num = a[i]*x*x+b[i]*x+c[i];
		sum = max(num,sum);
	}
	return sum;
}
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n;
		double l = 0,r = 1000;
		for(int j=1;j<=n;j++){
			cin>>a[j]>>b[j]>>c[j];
		}
		while(r-l>=esp){
			double lmid = l+(r-l)/3,rmid = l+(r-l)/3*2;
			if(f(lmid)>=f(rmid)){
				l = lmid;
			}
			else{
				r = rmid;
			}
		}
		printf("%.4lf\n",f(l));
	}
		
	
	return 0;
}
```

注：本题解的学术性语言与图片等素材大部分来自 [OI Wiki](https://oi-wiki.org/basic/binary/#%E4%B8%89%E5%88%86%E6%B3%95)。

---

## 作者：wyc0607 (赞：0)

### 模板：三分
三分算法（Ternary Search）是一种用于在单峰函数中寻找极值的优化算法。它适用于求解凸性函数或严格单峰函数的极值问题，例如二次函数的最大值或最小值。与二分法利用单调性不同，三分算法基于函数的单峰性，通过逐步缩小搜索区间来确定极值点——Deepseek。

### 算法流程：
大体来讲：**与二分相似**。三分算法的核心思想是通过不断缩小搜索区间来逼近极值点。对于一个单峰函数，极值点左侧的函数值是单调递增的，右侧的函数值是单调递减的。因此，我们可以通过比较两个三等分点的函数值来确定极值点所在的区间，并逐步缩小这个区间，直到找到极值点。

 **一般步骤**：

1. 新建两个节点 $l,r$，为三分的区间。
2. 定义两个三等分点 $mid_1=l+\frac{r-l}{3},mid_2=r-\frac{r-l}{3}$。计算 $a_1=F(mid_1)$，$a_2=F(mid_2)$（$F$ 函数视题而定）。
3. 分类讨论。
- 若一样大，可以随便挑选区间 $[l,mid_2]$ 或 $[mid_1,r]$。
- 若 $a_1$ 更小，说明最小值在区间 $[l,mid_2]$ 中，将 $r$ 赋值为 $mid_2$。
- 若 $a_2$ 更小，说明最小值在区间 $[mid_1,r]$ 中，将 $l$ 赋值为 $mid_1$。
4. 重复循环 3,4 步直到 $r,l$ 之差小于一定值。此时 $F(l)$ 即为答案。

### 代码：
```cpp
#include<bits/stdc++.h>
#define double long double
#define int long long
        using namespace std;
int a[10005],b[10005],c[10005],n;
double f(double x,int i) {//f(x)
	return x*x*a[i]+x*b[i]+c[i];
}
double F(double x) {//F(x)
	double ans=-0x3f3f3f3f;
	for(int i=1; i<=n; i++) ans=max(ans,f(x,i));
	return ans;
}
main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	while(T--) {
		cin>>n;
		for(int i=1; i<=n; i++) cin>>a[i]>>b[i]>>c[i];
		double l=0,r=1000,mid1,mid2;
		while(r-l>1e-15) {
			mid1=l+(r-l)/3.0;
			mid2=r-(r-l)/3.0;
			int a1=F(mid1),a2=F(mid2);
			if(a1>a2) l=mid1;
			else r=mid2;
		}
		cout<<fixed<<setprecision(4)<<F(l)<<'\n';
	}
}
```

---

## 作者：Hacker_Cracker (赞：0)

## P1883 【模板】三分 | 函数 题解
### Solution
题意：给你 $n$ 个二次下凸函数 $f_i(x)=a_ix^2+b_ix+c_i$，定义 $F(x)=\displaystyle{\max^{n}_{i=1}f_i(x)}$，求出 $\displaystyle{\min_{i=1}^{10^3}F(i)}$。

首先题目限定 $f_i(x)$ 都是下凸函数。这就意味着每条函数图像都是由 $(-\infty,-\cfrac{2a_i}{b_i}]$ 和 $[-\cfrac{2a_i}{b_i},+\infty)$ 两端区间构成的两个单调函数组成。故 $F(x)$ 有多段单调函数组成，仍是单峰的。

然后我们就可以开始三分了。由于单峰函数有且仅有一个最低点，所以我们可以将查询区间，本题中即为 $[0,10^3]$，拆分成三段区间。显然，可以使用两个中间点 $mid_1,mid_2$ 来确定分割方式。

> 为什么不能直接使用二分？

>很简单，函数 $F$ 由两段单调函数构成，其形似于一个二次函数。我们进行二分时，只能够掌握 $l,r,mid$ 三个条件，完全不能判断最低点到底在 $[l,mid)$ 还是在 $(mid,r]$ 区间。所以不能够直接使用二分。

继续。记当前目标区间为 $[l,r]$。我们每次计算 $F_1=F(mid_1),F_2=F(mid_2)$。如果 $F_1<F_2$，那么答案一定在 $[l,mid_2)$ 上。反之，答案在 $(mid_1,r]$ 上。这里同二分的区别是，我们去除的那一部分区间一定是**不符合条件的**。因为已经有另一个 $mid$ 满足 $F(mid)$ 更小。

终止条件为 $r-l \le 10^{-9}$。这里是为了卡精度。

- 可能有些人会有疑问：当二次函数退化成一次函数时，还能够使用三分吗？答案是可以。因为一次函数可以看作一个单峰函数的**一半**，照样可以进行运算。

### [AC](https://www.luogu.com.cn/record/207337459) Code
```cpp
#include<iostream>
#define int long long
using namespace std;
const double eps=1e-9;
const int N=1e5+10;
int a[N],b[N],c[N],n,__T;
inline double calc(double x){
	double res=-1e10;
	for(int i=1;i<=n;i++) res=max(res,a[i]*1.0*x*x+b[i]*1.0*x+c[i]);
	return res;
}
inline long long read(void){
	int f=1,res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		res=res*10+(ch-'0');
		ch=getchar();
	}
	return res*f;
}
inline void write(long long x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>=10) write(x/10);
	putchar((x%10)+'0');
	return;
}
signed main(){
	__T=read(); 
	while(__T--){
		n=read();
		for(int i=1;i<=n;i++) a[i]=read(),b[i]=read(),c[i]=read();
		double l=0,r=1e3;
		while(r-l>eps){
			double lmid=l+(r-l)/3,rmid=r-(r-l)/3;
			if(calc(lmid)>calc(rmid)) l=lmid;
			else r=rmid;
		}
		printf("%.4lf\n",calc(l));
	}
}
```

---


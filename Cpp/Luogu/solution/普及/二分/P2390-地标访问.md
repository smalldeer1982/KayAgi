# 地标访问

## 题目背景

改编自 USACO2007Nov 铜组 Exploration


## 题目描述

贝西在一条道路上旅行，道路上有许多地标，贝西想要在日落之前访问尽可能多的路标。将道路视为一条数轴，贝西从原点出发，道路上有 $n(1 \le n \le 5\times 10^4)$ 个地标，每个地标有一个坐标 $x_i(|x_i| \le 10^5)$ 且地标的坐标各不相同，$t(1 \le T \le 10^9)$ 分钟之后将会日落。

## 说明/提示

1、贝西日落时不用回到原点。

2、与原模拟水题不同。

3、数据较原题有所修改


## 样例 #1

### 输入

```
25 14
16
8
-7
3
10
-15
-17
6
-12
14
-13
2
9
-5
```

### 输出

```
8```

# 题解

## 作者：Egg_eating_master (赞：52)

$Update$于$2020.9.19$，修复了大家指出的一个错误

其实我觉得吧，这题不用像大家说的，枚举左点，二分右点

题目问的是最多可以访问多少地标。稍稍分析可知，多访问一个路标，时间必定不会减少，显然这具有**单调性质**。于是很自然的可以想到去二分路标的个数呀$QwQ$

先将所有路标的位置排序。要尽量使用时最少，那么我访问的任意两个路标之间都不能有其他的东西。（因为如果我访问的两个路标之间还有路标，那我还不如把这个路标顺便一起访问了呢）

那么，在存储路标位置的数组中，只要排好序，我访问的路标就一定是下标相邻的。

二分能访问到的路标个数，枚举右端点（当然左端点也行），判断这个区间是否能在$t$的时间内访问完成。

最后右端点枚举完了，如果还没有找到解，那就证明当前二分的这个路标个数不行。

一直二分就行了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int a[100001];
bool check(int x){//判断函数，表示的是能否访问到x个路标
	for(int r=x;r<=n;r++){//枚举右端点
		int l=r-x+1;
		if(a[r]<=0)//如果右端点在原点左边，就要一直向左走
		    if(-a[l]<=t)return 1;//根据题意判断即可，可以就直接返回true
		if(a[l]>=0)//如果左端点在原点右边，就要一直向右走
		    if(a[r]<=t)return 1;//同上
		if(a[l]<=0&&a[r]>=0)//如果这段区间横跨了原点
		    if(min(a[r],-a[l])+a[r]-a[l]<=t)return 1;//那么我一定是先去距离原点短的那一边，再走到另一边
	}
	return 0;//如果整个循环执行完，没有找到可行解，那就返回false
}
int main(){
	cin>>t>>n;
	for(int i=1;i<=n;i++)
	    cin>>a[i];
	sort(a+1,a+1+n);//给所有路标位置排序
	int l=-1,r=n+1;//由于能访问的路标数量可能为0~n，所以把左边界设为1，右边界设为n+1，就可以保证二分到所有解
	while(l+1<r){//这里写l+1<r是为了防止最后l,r出现交叉的情况，即l>r
		int mid=(l+r)>>1;
		if(check(mid))l=mid;
		else r=mid;
        //更新l,r的值时写mid而不是mid+1或mid-1，也是为了防止最后l>r
	}
	cout<<l<<endl;最后输出l
	return 0;//Happy ending~
} 
```


---

## 作者：hmya (赞：29)

本蒟蒻认为，此题不需要枚举左点，二分右点

首先，我们知道，贝西想要经过最多的地标数量，一定不能反复横跳

![](https://cdn.luogu.com.cn/upload/image_hosting/lq2vgu0k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

不然，你的代码不被跑死，贝西也会累死！

然后，我们知道，贝西一定是访问一段区间之内的所有地标

为什么呢？（建议思考5min再继续看下去）

如果有三个点

.---.--.

1 2 3

这时，贝西访问1点和3点

那么，贝西一共能访问几个点呢？

三个！

因为在从1点~3点时

能够顺便访问2点

那为什么不访问呢？

如果说，只能访问连续区间内的地标，那这题就好做了

因为，只会有下面几种情况方案数最少

![](https://cdn.luogu.com.cn/upload/image_hosting/nq5hz48w.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

很明显，这题是2分答案

2分答案，顾名思义，是去二分你的答案

这里我们二分最多能访问多少个地标

在枚举右（左）点，推出左(右)点，用以上四种情况进行判断

思路出来了，代码就很好写了

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[50505],MAX;
bool check(int x){
	for(int i=x;i<=n;i++){//枚举右点
		int l=i-x+1;//推出左点
		if(a[i]<=0){//一条道走到黑的判断
			if(-a[l]<=t)return true;
		}
		if(a[l]>=0){//不撞南墙不回头的判断
			if(a[i]<=t)return true;
		}
		if(a[l]<=0&&a[i]>=0){//这里把另外两种情况和在了一起
			if(min(-a[l],a[i])+(a[i]-a[l])<=t)return true;
		}
	}
	return false;
}
int main(){
	scanf("%d%d",&t,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	int lt=-1,rt=n+1;//记住，l一定要设置为-1，万一一个也访问不了捏？
	while(lt+1<rt){
		int mid=lt+(rt-lt)/2;//等价于（lt+rt）/2，但是这样一定爆不掉int
		if(check(mid)){
			lt=mid;//如果可行，就让l（ef）t过去，因为我们想让他越来越大
		}
		else{
			rt=mid;
		}
	}
	printf("%d",lt);//因为最后可行的mid被l（ef）t存起来了，so输出l（ef）t
	return 0;
}
```

希望不要抄代码，毕竟，题解是用来借鉴思路的，而不是让你棕名的，对吧？

---

## 作者：G_A_TS (赞：7)

枚举**左**点二分**右**点。。。  
check函数判断  
然而所谓的4种情况只要变形成伪两种即可  
方法是~~把数轴倒过来~~  
```cpp
for(int i=1;i<=n;i++)
{
	num[i]*=-1;
}
sort(num+1,num+n+1);
```
很容易地发现正负半轴其实**没什么区别**  
上代码，带一点注释  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,num[50010],st,l,r,mid,maxx;
int check(long long x,long long y)//左和右
{
    long long tot=abs(num[y]);
    if(tot<=t&&tot*2>=t)
    {
        if(y-st+1>maxx)
        {
            maxx=y-st+1;
            return 1;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        if(tot*2<t)
        {
            if(tot+abs(num[x]-num[y])<=t)
            {
            	if(y-x+1>maxx)
            	{
            		maxx=y-x+1;
            		return 1;
            	}
            	else
            	{
            		return 1;
            	}
            }
            else
            {
            	return 0;
            }
        }
        else
        {
            if(tot>t)
            {
                return 0;
            }			
        }
    }
}
int main()
{
    scanf("%lld%lld",&t,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&num[i]);
    }
    sort(num+1,num+n+1);
    for(int i=1;i<=n;i++)
    {
        if(num[i]>=0)
        {
            st=i;//st是start，即第一个正数
            break;
        }
    }
    for(int i=1;i<=st;i++)//st为零时直接跳过，倒转再求一次，显然此时必不为零
    {
        l=i;//避免check内乱套，l从i开始
        r=n;
        for(;l<=r;)
        {
            mid=(l+r)/2;
            if(check(i,mid))
            {
                l=mid+1;
            }
            else
            {
                r=mid-1;
            }
        }
        check(i,r);
    }
    for(int i=1;i<=n;i++)
    {
    	num[i]*=-1;
    }
    sort(num+1,num+n+1);
    for(int i=1;i<=n;i++)
    {
        if(num[i]>=0)
        {
            st=i;
            break;
        }
    }
    for(int i=1;i<=st;i++)
    {
        l=i;
        r=n;
        for(;l<=r;)
        {
            mid=(l+r)/2;
            if(check(i,mid))
            {
                l=mid+1;
            }
            else
            {
                r=mid-1;
            }
        }
        check(i,r);
    }
    cout<<maxx;
}
```

---

## 作者：Tgotp (赞：7)

看之前的没代码，发一波代码；

思路大致和楼上一样，但是可能会复杂一点，但是好理解一点；

就是找到最小正值m；

在从最远的地方开始找；

最后比较答案，输出就好了；







```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int N =50000+5;
int m,t,n,a[N],ans;
int max(int x,int y){ return x>y?x:y; }
int abs(int x)
{
    if(x>=0)return x;
    else return -1*x;
}
int find(int l,int r)
{
    if(l==r)return m=l;
    else
    {
        int mid=(l+r)/2;
        if(a[mid]==0) return m=mid;
        else if(a[mid]>0) return find(l,mid);
        else return find(mid+1,r);
    }
}
int main()
{
    cin>>t>>n;
    for(int i=0;i<n;i++)scanf("%d",&a[i]);
    sort(a,a+n);
    find(0,n);
    for(int i=0;i<=m;i++)
    {
        int x=abs(a[i]);
        if(x>t)continue;
        if(t-(2*x)>x)
        {
            int y=t-(2*x);
            for(int j=m;j<n;j++)
            {
                if(y-a[j]<0)
                {
                    ans=max(ans,j-i);
                    break;
                }
                else if(j == n-1)ans=max(ans,j+1-i);
            }
        }
        else 
        {
            int y=t-x;
            for(int j=m;j<n;j++)
            {
                if(y-(a[j]*2) < 0)
                {
                    ans = max(ans,j-i);
                    break;
                }
                else if(j == n-1)ans=max(ans,j+1-i);
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：LiveZoom (赞：6)

# P2390 地标访问

本题是一道考察二分的题目。

- ## Part 1 为什么要用二分？

由于不知道要访问多少个坐标，于是我们就来枚举有多少个，发现时间复杂度为$O(n^2)$，而这里$n\leq 50000$，会超时，于是就想到了二分。

- ## Part2 那二分的判断可行函数怎么写？

走这些坐标肯定是最少走重复路，而起点是$0$，则就可以从$0$先往负方向走，再往正方向走，或者是先往正方向，再往负方向，这样的话重复**最少就走正或者负方向重复走1遍**，而我们要使时间最短，就取正或负方向时间的较小值重复走，较大值走一遍即可，最后判断是否~~超时~~。

- ## Part3 具体实现

$1. \space \text{负数和正数各分成一组}$

$2. \space \text{二分}$

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, t;
int x[50005], length[50005], num[2][50005], tot1, tot2;

bool check (int k) {
	int res = 0x7fffffff;
	for (int i = 1; i <= min(tot1, k); ++i) {//i表示负数坐标选取多少个
		if (k - i > tot2) continue;//如果正数个数太多了，就没有后面的事情了
		res = min(res, min(num[0][i], num[1][k - i]) * 2 + max(num[0][i], num[1][k - i]));//就是选取最小的重复走，大的走一遍，取和就行了
	}
	return res <= t;//如果没超时，就可以
}

int main() {
	scanf("%d%d", &t, &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &x[i]);
	}
   sort(x + 1, x + 1 + n);//注意，这里必须要排序
	for (int i = 1; i <= n; ++i) {
		if (x[i] <= 0) num[0][++tot1] = (-x[i]);//负数分组
		else num[1][++tot2] = x[i];//正数分组
	}
	for (int i = 1; i <= (tot1 + 1) / 2; ++i) {
		swap(num[0][i], num[0][tot1 + 1 - i]);//注意，这里负数里面要从大到小来，这就是为什么要排序
	}
	int L = 0, R = n + 1;
	while (L + 1 < R) {//二分
		int mid = (L + R) >> 1;
		if (check(mid)) L = mid;
		else R = mid;
	}
	cout << L << endl;
	return 0;
}
```

# The end

---

## 作者：NiveusNix (赞：5)

这道题我们可以考虑4种情况：

1、从原点一直往右走；

2、从原点一直往左走；

因为来回只走一次肯定是最优的所以

3、从原点往左走一段再往右走；

4、从原点往右走一段再往左走；

下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,s,L[50010],R[50010];//L[]存在原点左边的地标离原点的距离，R[]存在原点右边的地标离原点的距离
int main(){
    cin>>t>>n;
    int ll=0,lr=0,sum=0;//ll是左边最远地标离原点的距离，lr是右边最远地标离原点的距离
    for(int i=1;i<=n;i++){
        cin>>s;
        if(s==0){
        	sum=1;
        }
        else if(s>0){//大于0的在原点右边
			lr++;
            R[lr]=s;           
        }
        else{//其他的在原点或原点左边
			ll++;
            L[ll]=-s;           
        }
    }
    sort(L+1,L+ll+1);//把坐标顺序排好
    sort(R+1,R+lr+1);
    long long t3=0,t4=0,mt1=0,mt2=0,mt3=0,mt4=0;//t3是第3种情况的子任务解，t4是第4种情况的子任务解，mt1-4是每种情况的最优解
    for(int i=1;i<=ll;i++){//第1种
        if(L[i]<=t){
            mt1+=1;
        }
    }
    for(int i=1;i<=lr;i++){//第2种
        if(R[i]<=t){
            mt2+=1;
        }
    }
    long long le,ri,mid;
    for(int i=1;i<=ll;i++){//第3种，先枚举左边回头向右走的坐标
        le=1;
        ri=lr;
        while(ri>=le){//二分查找向右到达的坐标
            mid=(ri+le)/2;
            t3=L[i]*2+R[mid];
    		if(t3>t){
                ri=mid-1;
            }
            else{
                le=mid+1;
            }
        }
        mt3=max(mt3,i+ri);
    }
    for(int i=1;i<=lr;i++){//第4种，先枚举右边回头向左走的坐标
        le=1;
        ri=ll;
        while(ri>=le){//二分查找向左到达的坐标
            mid=(ri+le)/2;
            t4=R[i]*2+L[mid];
            if(t4>t){
                ri=mid-1;
            }
            else{
                le=mid+1;
            }
        }
        mt4=max(mt4,i+ri);
    }
    cout<<max(max(mt1,mt2),max(mt3,mt4));
}
```

---

## 作者：zmza (赞：5)

这题使用二分答案。二分答案，就是二分贝西能访问的最多的地标数。

具体我就不多说了。代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[50005];
int n,t;
bool check(int mid)
{
	for(int r = mid; r <= n; r++)
	{
		int l = r - mid + 1;
		if(x[r] <= 0)//一直往左走
		{
			if(t >= -x[l])
			{
				return true;
			}
		}
		if(x[l] >= 0)//一直往右走
		{
			if(t >= x[r])
			{
				return true;
			}
		}
		if(x[r] >= 0 && x[l] <= 0)//往右再往左
		{
			if(min(x[r],-x[l]) + x[r] - x[l] <= t)
			{
				return true;
			}
		}
	}
	return false;
}
int main()
{
	scanf("%d%d",&t,&n);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d",&x[i]);
	}
	sort(x + 1,x + 1 + n);//排序
	int lt = -1,rt = n + 1;//left要最小减一，right要最大加一。
	while(lt + 1 < rt)//二分
	{
		int mid = (lt + rt) / 2;
		if(check(mid))//check mid 能不能行
		{
			lt = mid;
		}
		else
		{
			rt = mid;
		}
	} 
	printf("%d",lt); //输出答案
	return 0;
}
```


---

## 作者：幽灵特工 (赞：4)

 $O(n)$ 算法，暴打标算！

## 小学生秒懂系列。

[欢迎进入 blog 查看你的小学生秒懂系列都更新了啥。](https://www.luogu.com.cn/blog/Liya2304238405/#type=%E9%A2%98%E8%A7%A3)


![](https://cdn.luogu.com.cn/upload/image_hosting/3hrtr2dn.png)

我没有用心优化，如果改输入输出方法再加一点其它常数的优化应该能做到 30ms 以下。


------------

本题理论复杂度最低做法：**前缀和**！

## 思路

接下来给大家讲一讲我的思路。

贝西所有的走法只有四种：

1. 一镜到底往左走；

2. 一路向北往右走；

3. 先往左走再往右走；

4. 先往右走再往左走。

解释原因如下：你来回横跳的时间肯定是浪费了，不如一次性走完一个方向再转头。

因此计算这四种方法，取最大值即为答案。

## 实现

有了思路就很好实现了。对于本题我们给出如下定义：

**左点** ：位于原点左侧，且不包括原点的点。即所有坐标为负的点。

**右点** ：位于原点右侧，且包括原点的点。即所有坐标非负的点。

二分的做法是枚举左点（右点）二分右点（左点），这样会带一个 log。

前缀和。

$left[i]$ 表示负半轴地标数量前缀和，$right[i]$ 表示非负半轴地标数量前缀和。那么只要在读入所有数据后分别统计左右点前缀和即可，顺便还要记录所有地标的坐标最值，记为   $maxn,minn$ 这些操作都是 $O(n)$ 的。

贝西的四种走法计算如下：

1. `left[t>-minn?-minn:t]`

2. `right[t>maxn?maxn:t]`

3. 枚举左点，剩下的时间全部往右走

4. 枚举右点，剩下的时间全部往左走

容易发现第 1、2 种走法的计算复杂度是 $O(1)$；第 3、4 种走法枚举是 $O(n)$，往反方向走可以在前缀和数组中 $O(1)$ 计算出。

因此总复杂度是 $O(n)$，达到了理论最低。

另外，在计算第 3、4 种走法时已经顺便计算了第 1、2 种，代码中可以不写。

## 代码

注意由于我使用了万能头，left 和 right 已被定义，故加上 my\_ 前缀。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100010;
int n, t, a[MAXN], b[MAXN], my_left[MAXN], my_right[MAXN], ans, maxn = -1, minn = 1;
int main() {
	ios::sync_with_stdio(0);
	cin >> t >> n;
	int x;
	for (int i = 0; i < n; i++) {
		cin >> x;
		if (x < 0) {
			minn = min(minn, x);
			b[-x] = 1;//注意对负半轴的处理，数组下标应该非负。
		}
		else if (x >= 0) {
			maxn = max(maxn, x);
			a[x] = 1;
			if (x == 0)my_right[0] = 1;
		}
	}
	maxn = min(maxn, t);
	minn = max(minn, -t);
	for (int i = 1; i <= maxn; i++) {
		my_right[i] = my_right[i - 1] + a[i];
	}
	for (int i = -1; i >= minn; i--) {
		my_left[-i] = my_left[-(i + 1)] + b[-i];
	}
	//ans = my_right[t > maxn ? maxn : t];//一直往右走
	//ans = max(ans, my_left[t > -minn ? -minn : t] + my_right[0]);//一直往左走，记得算上原点
	for (int i = 1; i <= maxn; i++) {
		int other = t - 2 * i;//other是留给反方向剩余的时间
		other = other > 0 ? other : 0;
		other = other > -minn ? -minn : other;
		ans = max(ans, my_right[i] + my_left[other]);
	}
	for (int i = -1; i >= minn; i--) {
		int other = t + 2 * i;
		other = other > 0 ? other : 0;
		other = other > maxn ? maxn : other;
		ans = max(ans, my_left[-i] + my_right[other]);
	}
	cout << ans;
}
```


---

## 作者：Masna_Kimoyo (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2390)

## 思路



看完这道题，我们可以想象到 $Bessie$ 的四种走法：

- 一路向正方向走

- 一路向反方向走

- 先向正方向，后向反方向

- 先向反方向，后向正方向

### 1. 

其实前面两种走法答案很好统计，我们在输入时分别储存正负两种情况，用 $lz$ 和 $lf$ 分别表示正负两个数组的长度，那么在这个过程中，我们发现，只要满足：

- $x[i]>0:x[i]>=t$
- $x[i]<0:-x[i]>=t$ 

就可以让正负两端统计的最大值改成此时的 $lz$ 和 $lf$

就像这样：

```cpp
if(a>0)	
{
	z[++lz]=a;
	if(a<=t)	max1=lz;
}
else	if(a<0)	
{
	f[++lf]=-a;
	if(-a<=t)	max2=lf;	
}
```

### 2.

求后面两种情况，我们可以在统计一边时，计算另一边的数量

假如我们现在模拟正方向，要想求出左方向可以走过多少个地标，我们可以用一个比模拟更高效的算法：二分

一开始我以为只需要模拟一边的就够了，后来发现需要模拟两边

具体模拟步骤（由于左右两边过程差不多，只需要改改变量，我们现在只模拟右边的）：

1.变量解释

- $t$：样例中的时间

- $z[i]$：统计正数的数组

- $f[i]$：统计负数的数组

- $i$ ：当前的模拟参数

- $tt$ ：左边可以走的路程，其值为：$t-z[i]*2$

现在我们再定义一个 $left$ 和一个 $right$，表示二分的两端

$left$ 初始值为 $0$

$right$ 初始值为 $n$

而我们当下的目标，就是 $mid$ ，其值为 $(left+right)/2$

当 $f[mid]>tt$ 时，说明当前答案打了， $r=mid-1$

当 $f[mid]==tt$ 时，说明当前答案刚好，统计完答案，直接退出二分

当 $f[mid]<tt$ 时，说明当前答案有可能有更优解，我们同样记录当前答案，并且还要让 $l=mid+1$

主要部分的思路已经分析完毕，接下来就是代码的实现了

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2147483647,N=5e4+5;
int t,n,ans=-INF,a,lz,lf,max1,max2;
int z[N],f[N];
inline int read()
{
	int x=0;
	bool w=0;
	char c=getchar();
	while(!isdigit(c))
		w|=c,c=getchar();
	while(isdigit(c))
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return w?-x:x;
}
int main()
{
	t=read(),n=read();
	for(register int i=1;i<=n;++i)
	{
		a=read();
		if(a>0)	
		{
			z[++lz]=a;
			if(a<=t)	max1=lz;
		}
		else	if(a<0)	
		{
			f[++lf]=-a;
			if(-a<=t)	max2=lf;	
		}
	}
	sort(z+1,z+lz+1);
	sort(f+1,f+lf+1);
	for(register int i=1;i<=lz && i*2<=t;++i)
	{
		int l=0,r=lf,mid,tt=t-2*z[i],sum=i;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(f[mid]>tt)	r=mid-1;
			else	if(f[mid]<tt)	l=mid+1,sum=mid+i;
			else	if(f[mid]==tt)	
			{
				sum=mid+i;
				break;	
			}	
		}
		ans=max(ans,sum);
	}
	for(register int i=1;i<=lf && i*2<=t;++i)
	{
		int l=0,r=lz,mid,tt=t-2*f[i],sum=i;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(f[mid]>tt)	r=mid-1;
			else	if(f[mid]<tt)	l=mid+1,sum=mid+i;
			else	if(f[mid]==tt)
			{
				sum=mid+1;
				break;
			}	
		}
		ans=max(sum,ans);
	}
	printf("%d",max(max(max1,max2),ans));
	return 0;
}
```

## 写题解不易，求管理大大过

---

## 作者：木木！ (赞：2)

可能是本题最短的代码（逃）

思路是枚举正点二分负点$\Theta(nlogn)$

然而并不需要像其他题解一样分四种情况（我平生最烦特判）

1. 一直往正方向走：好办，只需要让走完正方向之后二分负方向时让剩余时间为负数就好了
2. 一直往负方向走：等价于在正方向走0的长度
3. 先往正方向走再往负方向走：枚举正方向，二分负方向
4. 先往负方向走再往正方向走：程序里那个max就是干这个的

这里嫌二分太烦直接用了倍增【逃

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int posi[50005];
int si[50005];

bool cmp(int a,int b)
{
	return a<b;
}

int main()
{
	int t,n;
	scanf("%d%d",&t,&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",posi+i);
	}

	sort(posi,posi+1+n,cmp); //注意这里不是从posi+1开始
	int logn = 31-__builtin_clz(n+1);

	int zpos = 0;
	for(int i=logn; i>=0; --i)
	{
		if(posi[zpos+(1<<i)] < 0)
		{
			zpos += 1<<i;
		}
	}
	++zpos;

	int ans = 0;
	for(int i=zpos; i<=n; ++i)
	{
		if(posi[i] <= t)
		{
			int curans = i-zpos;
			int nt = max(t-posi[i]*2,(t-posi[i])/2); //先走正对应前一项，先走负对应后一项，因为nt越大越好所以用max
			int ntp = -1;
			for(int i=logn; i>=0; --i)
			{
				if(-posi[ntp+(1<<i)] > nt)
				{
					ntp += 1<<i;
				}
			}
			++ntp;

			if(ntp < zpos)
			{
				curans += zpos-ntp;
			}
			if(curans > ans)
			{
				ans = curans;
			}
		}
	}

	printf("%d\n",ans);
}
```

---

## 作者：Forever1507 (赞：1)

水二分答案，随便分类讨论一下就行了。

共有三种情况：
- 一路往左（负轴）
- 一路往右（正轴）
- 从左到右（负->正）

那么，为什么不会从正轴到负轴呢？

既然你能到正轴，终点也一定在正轴，如果你这次跑去负轴，下次去终点又要回来，显然浪费时间。

详见注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x[50005],t;//坐标 
bool check(int m)//m为二分出来的左起点
{
	for(int i=m;i<=n;i++)//循环右终点坐标 
	{
		int l=i-m+1;//起点坐标 
		if(x[l]>0)//一路向右，如果连起点都在右边，那么终点也一定在
		{
			if(x[i]<=t){//终点用时在t以内 
				return true;
			}
		} 
		if(x[i]<0)//一路向右，如果连终点都在左边，那么起点也一定在
		{
			if(x[i]>=-t){//终点用时在t以内（将t化为负数，可按照绝对值理解）			
				return true;
			}
		} 
		if(x[l]<0&&x[i]>0){//兜了个圈子拐个弯，即这段区间横跨了原点 
			if(min(x[i],-x[l])+x[i]-x[l]<=t)//先去距离短的相邻点,但是无论如何起点和终点间距离必须要走 
				return true;
		}
	} 
	return false;////如果整个循环执行完无解就继续二分 
} 
int main(){
	cin>>t>>n;
	for(int i=1;i<=n;i++)
	    cin>>x[i];
	sort(x+1,x+1+n);//排序,防止毒瘤乱码 
	int l=-1,r=n+1;//由于能访问的路标数量可能为0~n，所以以理论范围扩大1为实际范围，即把左边界设为-1，右边界设为n+1，这样就可以保证二分到所有解
	while(l+1<r){//之所以不写l<r是为了留空格 
		int mid=(l+r)/2;
		if(check(mid))
			l=mid;
		else 
			r=mid;
        //更新l,r的值时写mid而不是mid+1或mid-1，也是为了防止最后l>r
	}
	cout<<l<<"\n";//最后输出l
	return 0;
}
```


---

## 作者：20_44 (赞：1)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,t;
int zb[50010];
int jilu,shijian,shu;
int l,r,mid,maxx;
int ans[5];
int main()
{
	cin>>t>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>zb[i];
	}
	sort(zb,zb+n+1);//多排入一个原点
	for(int i=1;i<=n;i++)//找到原点的位置
	{
		if(zb[i]==0)
	    {
		   jilu=i;
		   break; 
		} 
	}
	for(int i=jilu+1;i<=n;i++)//一直从原点向右走
	{
		shijian=zb[i];
		if(shijian>t)
		{
		    break;	
		}
		else
		shu++;
	}
	ans[1]=shu;shu=0;shijian=0;
	for(int i=jilu-1;i>=0;i--)//一直从原点向左走
	{
		shijian=abs(zb[i]);
		if(shijian>t)
		{
			break;
		}
		else
		shu++;
	}
	ans[2]=shu;shu=0;shijian=0;
	for(int i=jilu+1;i<=n;i++)//向右枚举向左二分
	{
		shijian=zb[i];
		if(shijian*2>t)
		break;
		l=0;r=i;
		while(l<=r)
		{
			mid=(r+l)/2;
			if(2*zb[i]-zb[mid]>t)
			{
				l=mid+1;
			}
			else
			{
				r=mid-1;
			}
		}
		shu=i-l;
		if(maxx<shu)
		maxx=shu;
	}
	ans[3]=maxx;maxx=0;
	for(int i=jilu-1;i>=0;i--)//向左枚举向右二分
	{
		shijian=abs(zb[i]);
		if(shijian*2>t)
		break;
		l=i;r=n;
		while(l<=r)
		{
			mid=(r+l)/2;
			if(2*abs(zb[i])+zb[mid]>t)
			{
				r=mid-1;
			}
			else
			{
				l=mid+1;
			}
		}
		shu=r-i;
		if(maxx<shu)
		maxx=shu;
		shu=0;
	}
	ans[4]=maxx;maxx=0;
	for(int i=1;i<=4;i++)
	{
		if(maxx<ans[i])
		maxx=ans[i];
	}
	cout<<maxx;
}
```

---


# 奇怪的函数

## 题目描述

使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？


## 说明/提示

对于全部数据，$1\le n\le 2\times 10^9$。


## 样例 #1

### 输入

```
11```

### 输出

```
10```

# 题解

## 作者：Mychael (赞：51)

介绍求数x位数的方法：

x的位数=log10(x)+1;【取整】


log10(double)是cmath头文件里自带的10为底的对数

可是题目的数很大呐。

利用对数运算，可以把指数提出来，作为系数

即log(x^x)=x\*log(x)


直接枚举x?试试看输入2000000000，发现过了10s才出答案两亿多

说明答案是整型范围内的，但时间效率却是O(200000000)太大了


考虑到10为底的对数函数是单调递增的，所以可以用二分答案

就成了O(log200000000)了



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long int
using namespace std;
int main(){
    int n;
    LL L=1,R=2e9;
    cin>>n;
    while(L<R){
        LL mid=(L+R)>>1,len=(LL)(mid*log10(1.0*mid))+1;
        if(len<n) L=mid+1;
        else R=mid;
    }
    cout<<L<<endl;
    return 0;
}

```

---

## 作者：panyf (赞：24)

先上7行最短蓝题代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l=1,r=3e8,m;
int main(){
    for(cin>>n,n--;m=(l+r)/2,l<r;)if(m*log10(m)<n)l=m+1;else r=m;
	cout<<l;
}
```
求位数方法：

正整数m的位数为[lg(m)]+1([ ]表示向下取整,lg即为log10）

证明：

由于m为正整数，必然存在正整数n使得10^(n-1)<=m<10^n，则m的位数为n，对此不等式取对数得n-1<=lg(m)<n，故m的位数为[lg(m)]+1。

分析：

本题求x^x的位数，也就是求[lg(x^x)]+1，利用对数的运算法则，lg(x^x)=x* lg(x)，由于直接解出x的值较为困难，这里运用了二分的思想。

注释代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l=1,r=3e8,m;
/*l必须初始化为1，否则会RE，本题中n最大为2e9
   所以r最大为238723448，这里初始化为3e8*/
int main(){
    cin>>n,n--;
//所求位数为int(m*log10(m)+1，所以n先减1
    while(l<r){//二分
    	m=(l+r)/2;
    	if(m*log10(m)<n)l=m+1;
    	else r=m;
	}
	cout<<l;
}
```


---

## 作者：小菜鸟 (赞：19)

你们没看错，我又双叒叕来写这道题的题解了！  

昨天刚学习了模拟退火，发现好像可以用来搞很多二分和牛顿迭代的题？  

关于数学处理的部分可以参见我前一篇题解或者各位大佬的题解，这篇题解主要讲用模拟退火算法来逼近正确答案。  

首先，一段摘自百度百科的话  

```
    模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法，用来在一个大的搜寻空间内找寻命题的最优解。模拟退火是由S.Kirkpatrick, C.D.Gelatt和M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模拟退火算法是解决TSP问题的有效方法之一。
```

~~简单地说，就是用随机数在那瞎搞，搞出什么是什么（逃~~  

还是先来看看模拟退火的流程吧！  

1.对所有可能的解，定义一个内能函数$E(x)$，能量越小则解越优;  

2.设定初温$T_0$;  

3.设定初始解$x_0$;  

4.设定一个略小于$1$降温系数（我称之为$\alpha$）;//似乎别人都叫$\Delta$?别喷我QAQ  

5.当温度$T$高于指定末温$T*$，重复以下步骤:  

6.根据$T$在$x_0$附近产生一个随机解$x$;  

7.计算能量差$\Delta E=E(x)-E(x_0)$;  

8.若$\Delta E<=0$，则用$x$替换$x_0$;  

9.否则，令$x_0$有$e^{-\Delta E/T}$的概率被$x$替换;  

10.将温度$T$乘上$\alpha$进行降温;  

11.回到第五步;//没有缩进真难受QAQ

写成伪代码：
```
SA Algorithm
{
	define const α;
	define E(x);
    define x0;
	define ans=x0;//ans用于记录最优解
	define T=T0;
	while(T>T*)
	{
		define x=x0+random(-T,T)//指生成在[-T,T)范围内的随机数
	    define ΔE=E(x)-E(x0);
	    if(ΔE<0)ans=x0,x0=x;
        else if(random(0,1)<exp(-∆E/T))x0=x;//以exp(-ΔE/T)的概率替换当前解
        T*=α;
	}
    return ans;
}
//第一次写伪代码，因此有点鬼畜
```

其中，较差的解也有一定概率替换较优解，是为了防止答案过早在次优解上收敛。将$\alpha$、$T_0$增大能以时间换正确性，否则以正确性换时间。

这是本蒟蒻对模拟退火算法的理解，若有不当之处还请各位大佬指正QAQ  

有了算法框架，写出具体代码就相对比较简单了。代码注释还是很详细的！

```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
const double alpha=0.99995;//降温系数，要慢慢调整，大了会TLE，小了会WA
int n;
double Rand()//生成[0,1)中的随机数
{
    return (double)rand()/RAND_MAX;//利用RAND_MAX宏来控制随机数范围
}
double Rand(double l,double r)//生成[l,r)中的随机数
{
    return (r-l)*Rand()+l;
}
double Energy(double x)//内能函数，显然xlgx越靠近n越优
{
    return abs(x*log10(x)-n);
}
double ans=500000;//用于记录全局最优解，防止在随机替换当前解时丢失最优解
double ansE=Energy(ans);
void SA()//算法主体
{
    double t=5e8;//初温，设得大一些以尽可能搜遍整个解空间，但太大会TLE //感觉设在整个解空间大小的一半差不多
    double now=ans;//初始解随便挑一个正常一点的数
    double nowE=Energy(ans);//计算当前解的能量
    while(t>1e-10)//控制末温，太高会爆精度，太低会TLE
    {
        double temp=now+Rand(-t,t);//生成随机解
        double E=Energy(temp);//计算随机解的能量
        double delta=E-nowE;//计算ΔE
        if(delta<=0)//随机解更优则直接替换当前解
        {
            if(E<ansE)ans=now,ansE=E;//更新全局最优解
            now=temp;
            nowE=E;
        }
        else
        {
            if(Rand()<exp(-delta/t))//否则有一定概率替换当前解
            {
                now=temp;
                nowE=E;
            }
        }
        t*=alpha;//降温
    }
}
int main()
{
    srand(time_t(0));//将命运交到时间的手中
    scanf("%d",&n);
    --n;//这里同前一篇题解
    SA();//用随机与暴力冲破一切阻碍
    int res=ans;//得到最终解的方法同前一篇题解
    if(int(res*log10(res)+0.5)<n)++res;
    printf("%d",res);//接受命运的裁决
}
```
模拟退火复杂度目测$\Theta(clog_\alpha \frac{T*}{T_0})$($c$是内能函数的复杂度)？是解决难解问题的利器，思想与代码也不算太难（尽管很玄学）。 

与其他常见的近似算法相比，模拟退火不需要二分的单调性，不需要三分的单峰函数，也不需要求导，还能拓展到除了方程求解以外的大量问题当中。    

虽然模拟退火有概率出错，但通过对其参数的反复调整，可以在正确性和速度之间找到最佳平衡。    

最后，该算法适合欧洲的同学使用。~~像我这种非酋还是少写吧QAQ~~

---

## 作者：guoxinyugz (赞：12)

**题目大意：**

使得 x^x达到或超过 n 位数字的最小正整数 x 是多少？

其中n<=2000000000

**解析**

~~看这格式，就知道是二分答案题了~~

通俗地讲，由于x越大，x^x就越大（x是正整数）

所以可以二分答案

本题基本上唯一难点就是n很大，所以小小转换一下:

x^x>=10^(n-1)

log10(x^x)>=log10(10^(n-1))

x\*log10(x)>=n-1

建议想想为什么log10(x^x)=x\*log10(x)

接下来代码就不难写啦，我用的递归方式

**代码**

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
void f(int l,int r)//二分答案
{
	if(l==r)
	{
		printf("%d",l);
		return;
	}
	int mid=(l+r)/2;
	if(mid*log10((long double)mid)<n-1)//log10就是以十为底，c++里有的
		f(mid+1,r);
	else f(l,mid);
}
int main()
{
	scanf("%d",&n);
	f(1,n+10);//保险起见，要n+10
	return 0;
}
```


---

## 作者：Brian_WBY (赞：4)

看到这题，本蒟蒻发现，输入只有1个数，输出也只有1个数，于是就想打表，然后一看数据范围：$n\leqslant2000000000$，立刻就放弃了，打表肯定会$MLE$啊$qwq$。

本题要求求的是一个最小的大于等于$n$位数字的$x^x$。首先，最小的$n$位数字是$10^{n-1}$，这个比较容易证明。然后我们可以发现，当$x>n$的时候，$x^x$大于$10^{n-1}$，而$x$一定不能小于1，而所求的答案：最小的大于等于$10^{n-1}$的$x$一定在1和n之间——想到了什么？二分答案！当然直接暴力二分还是会$TLE$，不过我们可以对$x^x$和$10^{n-1}$各自取一个$\lg$，因为$\log_xa^b=b\log_xa$，所以$\lg x^x=x\lg x$，而$\lg 10^{n-1}=n-1$！这样我们就成功的降低了二分的上下限。正确性显然，但是这样我们就不会TLE了。

对于如何求$\lg$的问题，C++提供了log10函数，可以直接求$\lg$，在cmath库里。

**最后说一下，二分的时候，其实可以在区间长度大于5的时候二分，小于5的时候直接暴力枚举，可以降低一些思考难度（不用考虑一些细节问题），~~愉快的代码偷懒~~（其实这是阮行止大佬讲的），这个技巧目前没人使用。**

贴一下代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>//包含log10
using namespace std;
int n;
bool f(int x)//我习惯写一个检验函数
{
	return x*log10(x)>=n-1;//对x^x和10^(n-1)分别求lg
}
int main()
{
	scanf("%d",&n);
	int l=1,r=n,mid;//最终答案x一定在1和n之间
	while (r-l>=5)
	{
		mid=l+r>>1;//比mid=(l+r)/2稍快
		if	(f(mid))	r=mid;//如果大于就在左区间寻找
		else	l=mid+1;//否则在右区间寻找
	}
	for (;!f(l);l++);//区间长度小于5，暴力枚举
	printf("%d",l);输出答案
	return 0;
}
```
然后就愉快的[AC](https://www.luogu.com.cn/record/32418038)了。

---

## 作者：小菜鸟 (赞：4)

看到没有牛顿迭代法，我来水一波  
首先，牛顿迭代公式  
$$x=x_0-\frac{f(x_0)}{f'(x_0)}$$  
对于此题，由于$n$可能很大，直接对$x^x$求解不现实  
考虑如何减小运算值  
$$x^x=10^{n-1}$$
$$x log_{10}x=n-1$$
$$x log_{10}x-n+1=0$$
然后对左边求导，得
$$(x log_{10}x-n+1)'=\frac{1}{ln10}+log_{10}x$$
于是可以写出此题的迭代公式
$$x=x_0-\frac{x_0 log_{10}x_0-n+1}{\frac{1}{ln10}+log_{10}x_0}$$
那么代码实现就贼简单辣！  
注意一下浮点数要向上取整即可
```cpp
#include<cstdio>
#include<cmath>
double solve(double n,double x0)//牛顿法
{
    double x=x0-(x0*log10(x0)-n)/(log10(x0)+1/log(10));
    while(abs(x-x0)>1e-10)//控制精度，实际上没必要那么高
        x0=x,x=x0-(x0*log10(x0)-n)/(log10(x0)+1/log(10));
    return x;
}
int main()
{
    int n,ans;
    scanf("%d",&n);
    --n;//这样方便之后的处理
    ans=solve(n,38);
    if(int(ans*log10(ans)+0.5)<n)++ans;//检测解是否为整数，不是则向上取整
    printf("%d",ans);
}
```
附：据说牛顿迭代是二阶收敛的，但涉及到极限的东西对我而言是玄学  
所以复杂度大概也是$O($玄学$)$吧（逃）

---

## 作者：望眼浮云 (赞：4)

x^x达到 n 位数字,即x^x>=10^(n-1),乍一看无从下手，考验数学的时候到了

### 详细的推一波公式：

	    x^x>=10^(n-1)
    <=> lg(x^x)>=lg(10^(n-1))
    <=> x*lgx>=n-1
    
### 然后二分答案就好了

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,l,r,mid;
bool check(long long x)
{
	return (x*log10(1.0*x)>=n);  //公式，判断
}
int main()
{
	scanf("%lld",&n);
	--n;   //n-1
	l=0,r=2000000000; //r要大一点，我在这上面wa了好几次
	while(l<r)
	{
	    mid=(l+r)/2;
	    if(check(mid)) r=mid;
	    else l=mid+1;
	}
	printf("%lld",l);
}
```

---

## 作者：mod998244353 (赞：2)

**题意：**

* 输入一个整数 $n$。
* 输出满足 $x^x$ 的位数 $≥n$ 的 $x$ 的最小整数值。
* $n≤2000000000$。

**思路：**

首先需要知道：

1.  $y$ 的位数求法： $log_{10} (y)+1$（向下取整）。

2.  $log_{a}(b^c)=c \times log_a(b)$（$16^{16}=2^{64}$就爆了，要用这个）。

就可以得到 $x^x$ 的位数就是 $x \times log_{10}(x) +1$。

而且 $log_{10}$ 是单调递增的，可以用二分求。 

```cpp
#pragma GCC optimize(3,"Ofast","inline")//O3优化，推荐使用
#include <bits/stdc++.h>
using namespace std;
int L=1,R=2000000000,n;
int CIN()
{
  char c=getchar();
  bool has=1;//用bool省空间
  int f=0;
  for(; !isdigit(c); c=getchar())
    if(c==45/*'-'的ASCII*/)
    {
      has=0;
    }
  for(; isdigit(c); c=getchar()/*putchar约比scanf快10倍*/)
    f=10*f+c-48;
  return has?f:-f;
}
void COUT(int n)
{
  int a=n%10,b=(n-a)/10;
  if(b)COUT(b);
  putchar(a+48);
}//简化版写法
void work()//二分
{
  int M=(L+R)/2;
  if(log10(M)*M<n)
  {
    L=M+1;
  }
  else
  {
    R=M;
  }
  if(L<R)work();
  return;
}
int main()
{
  n=CIN()-1;//上面的结论有+1，这里直接n-1即可
  return work(),COUT(L),0;//"return 0;"是一种好习惯的体现
}
```

**记住，只有自己打的正确的代码才有意义，不要抄题解！**

---

## 作者：abandentsky (赞：2)

思路：第一次做求一个数的位数的题目。都被惊呆了。求一个10进制的数我们只需要求[log(x)]+1就是他的位数了。怎么证明呢？就是10^(n-1)<=m<10^n;然后两边同时取对数就好了。其中【】是向下取整。
```c
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<stack>
#include<string>
#include<iostream>
#include<vector>
#include<ctype.h>
#include<algorithm>
#include<map>
#include<set>
#include<stdlib.h>
#include<queue>
#include<sstream>
#include<complex>
#define MAXN  500005
#define eps 0.00001
#define INF 0x3f3f3f3f
#define mod 99999997
#define maxnode 1000
#define sigma_size 26
#define MIN (-0x7fffffffffffffff)
typedef  long long  LL;
using namespace std;

int n,m;
int Left=1;
int Right=3e8;

int main()
{
    scanf("%d",&n);
    n--;
    while(Left<Right)
    {
        m=(Left+Right)/2;
        if(m*log10(m)<n)
        {
            Left=m+1;
        }
        else
        {
            Right=m;
        }
    }
    printf("%d\n",Left);
    return 0;
}

```


---

## 作者：DPair (赞：1)

这道题难度不大，重点是$STL$的使用

由于一个数$x$的位数为$log10(x) + 1$，所以可以把这个东西写成判断函数，直接二分，就做完了。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
inline bool pd(int x)
{
    return n - 1 <= ((double)x * log10(x));
}

template <typename T>
inline void read(T &x)
{
    char c;
    x = 0;
    int fu = 1;
    c = getchar();
    while(c > '9' || c < '0')
    {
        if(c == '-')
        {
            fu = -1;
        }
        c = getchar();
    }
    while(c <= '9' && c >= '0')
    {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    x *= fu;
}
int main()
{
    read(n);
    int l = 0, r = 2000000000;
    while(l < r)
    {
        int mid = (l + r) >> 1;
        if(!pd(mid)) l = mid + 1;
        else r = mid;
    }
    cout << l << endl;
}

```

---

## 作者：Sasiyar (赞：1)

其他的题解大都是先数学推导，在二分查找，我提供一种更为暴力的解法。

[题目](https://www.luogu.org/problemnew/show/P2759)

这道题我在考试的时候没想到要数学推导，所以我就考虑用科学计数法来表示一个数

这道题想到用二分查找不难，但是在判断的时候我就强行计算出x^x的位数，如代码中的cal函数，他是基于一个快速幂的模板，其中pre表示base变量的省略长度，ans表示tot变量的省略长度（即丢掉的精度），注意乘的时候要累加因数的省略长度，而且最后还要算出得到的答案的除去10的次方以外的部分的长度，即last变量。

至于二分法边界的选取，通过~~打表~~可以发现在n小于10的时候得到的答案大于等于n，我就直接枚举了（~~太懒了~~）。

这种方法的时间30ms，而标解24ms，（至少我的程序是这样的）。

```
#include<bits/stdc++.h>
#define R register
#define rint R int
#define ll long long
#define I inline
#define iint I int
#define ivoid I void
#define ill I ll
#define mod 1000000000
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
using namespace std;
template<typename T>
ivoid read(T&a)
{
    a=0;
    char in=getchar();
    rint f=1;
    while(in>'9'||in<'0'){if(in=='-')f=-1;in=getchar();}
    while(in>='0'&&in<='9'){a=a*10+in-'0';in=getchar();}
    a*=f;
}
ill mi(ll a,ll b)
{
    ll tot=1,base=a;
    while(b)
    {
        if(b%2==1)
        {
            tot*=base;
        }
        base*=base;
        b/=2;
    }
    return tot;
}
ivoid put(ll);
ll cal(ll);
int main()
{
    ll n;
    scanf("%lld",&n);
    if(n<=9LL)
    {
        put(n);
    }
    else
    {
        ll l=10LL,r=n+10;
        while(l<r)
        {
            ll mid=(l+r)/2LL;
            ll len=cal(mid);
            if(len>=n)
                r=mid;
            else
                l=mid+1LL;
        }
        printf("%lld\n",l);
    }
    return 0;
}
ll cal(ll k)
{
    ll ans=0,pre=0,tot=1LL,base=k;
    while(k)
    {
        if(k%2LL==1LL)
        {
            ans+=pre;
            tot*=base;
            while(tot/mod>=1){tot/=10LL;ans++;}
        }
        base*=base;
        pre*=2LL;
        while(base/mod>=1){base/=10LL;pre++;}
        k/=2LL;
    }
    ll last=0,tmp=tot;
    while(tmp){last++;tmp/=10LL;}
    return ans+last;
}
ivoid put(ll k){
    if(k<=5LL)
    {
        if(k<=3LL)
        {
            if(k==1LL)
                printf("1\n");
            else if(k==2LL)
                printf("3\n");
            else if(k==3LL)
                printf("4\n");
        }
        else if(k==4LL)
            printf("5\n");
        else if(k==5LL)
            printf("6\n");
    }
    else{//6,7,8,9
        if(k<=7LL)
        {
            if(k==6LL)
                printf("7\n");
            else if(k==7LL)
                printf("8\n");
        }
        else{
            printf("%lld\n",k);
        }
    }
}
```

---

## 作者：江战神龙骑士 (赞：1)

弱弱说句，其实这就是一个二分答案题，非常明显的……

如果暴力枚举高精度的话空间复杂度为O（n），明显承受不了；

用快速幂求x的x次方肯定会超时，时间复杂度O（xlog2x）（原地爆炸）；

利用换底公式求出一个数的位数，利用二分思想搜索，时间复杂度O（log2x），很显然可以：

代码奉上：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#define lld long long
using namespace std;
int main(){
    lld n,l=1,r=2e9,mid,len;
    cin>>n;
    while(l<r){//二分搜索
        mid=(l+r)/2;
        len=(mid*log(mid))/log(10)+1;//求位数公式
        if(len<n)l=mid+1;//比较调整左右区间
        else r=mid;
    }
    cout<<l;
}
```

---

## 作者：infinityedge (赞：1)

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n;
bool can(int x){
    if(x*(log(x)/log(10))>=n-1)return true;//判断方程
    return false;
}
int findx(int x,int y){//判断能不能行二分
    int mid=x+(y-x)/2;
    if(y-x<=1)return y;
    if(can(mid))return findx(x,mid);
    return findx(mid,y);
}
int main(){
    cin>>n;
    int ans=findx(0,1000000000);
    cout<<ans;//用二分查找实现
    return 0;
}
```

---

## 作者：飞翔 (赞：1)

程序写起来不长，但是思维复杂度挺高。

```cpp
var
  n,l,r,mid:int64;
    t:extended;
begin
  read(n);
    l:=1;r:=maxlongint;
    repeat
      mid:=(l+r)shr 1;
        t:=mid*ln(mid)/ln(10)+1;
        if t>=n then r:=mid else l:=mid+1;
    until l=r;
    write(l);
end.
二分实现+数论思路
```

---

## 作者：xh39 (赞：0)

给~~小学生~~大家普及点公式

$log_a(b)$表示$a^x=b$

那么

$log_a(b)$=in(b)÷in(a)

$in(a^b)=b \times in(a)$

其实in(x)我也不知道是什么东西,听老师说是$log_e(x)$,然而e又是什么东西......不管了,反正能用就行。(在c++里写作log(x),要声明cmath库函数)

构造不等式:$x^x>=10^{(n-1)}$

那么$in(x^x)>=in(10^{(n-1)})$

$x \times in(x)>=(n-1) \times in(10)$

然后二分枚举x,ac代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,i,l,r,m,ans;
	double xyq;
	cin>>n;
	xyq=(n-1)*log(10); //不等式右边的东西。
	l=1;
	r=2000000000; //n的范围。
	while(l<r){
		m=l+r>>1; //>>1表示在二进制意义下右移一位,相当于除以二。
		if(m*1.0*log(m)>=xyq){ //整数*1.0可以转换为浮点数。
			ans=m; //记录答案。
			r=m-1;
		}else{
			l=m+1;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：无人之境 (赞：0)

题目描述
使得 x^x 
 达到或超过 n 位数字的最小正整数 x 是多少？

输入格式
一个正整数 n

输出格式  
使得 x^x
达到 n 位数字的最小正整数 x

思路：这道题目其实挺水的，主要是一个二分的思想，如果一个个枚举，肯定会超时，所以果断二分答案。而且更重要的是一定不要直接去用x^x去直接计算，肯定会爆long long,用log就好了，废话不多说，直接上代码。

```cpp
#include<bits/stdc++.h>		//包括万能库
using namespace std;		//使用默认的命名空间
long long n,l=0,r=1e12,ans;
int main()		//程序运行的入口
{
	cin>>n;
	while(l<=r){
		long long mid=(l+r)/2;
		if((long long)(mid*log10(mid)+1)>=n){
			ans=mid;
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：marklikeamd (赞：0)

10分

开始的想法：x^x>=10^(n-1) --> x>=10^(n-1)/x;
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
ll n,x,tem1,tem2,temx;
int main()
{
	scanf("%lld",&n);
	for(x=1; ; x++)
	{
		temx=1;
		tem1=(n-1)/x;
		for(int i=1; i<=tem1; i++)
		{
			temx*=10;
		}
		if(x>=temx) break;
	}
	printf("%d",x);
	return 0;
}
```

30分

更短小精悍，还骗多了20分233

思路：x^x>=10^(n-1) --> lg(x^x)>=n-1 --> x*lgx>=n-1
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
ll n,x;
int main()
{
	scanf("%lld",&n);
	for(x=1; ; x++)
	{
		if(x*log10(x)>=n-1) break;
	}
	printf("%lld",x);
	return 0;
}
```

100分

好吧，我竟然没想到二分答案

单调性和有界性显然满足

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
ll n;
int main()
{
	scanf("%lld",&n);
	ll l=1,r=2e9;
	while(l<r)
	{
		ll mid=(l+r)>>1;
		if(mid*log10(mid)>=n-1) r=mid;  //超过 
		else l=mid+1; //没超过
	}
	printf("%lld",l);
	return 0;
}
```

---

## 作者：フホンチェン (赞：0)

首先题目要求我们求一个最小的正整数 $x$,使得 $x ^ x$ 的位数大于等于 $ N $。

一个很暴力的做法是直接计算 $x ^ x$，然后逐一检查是否满足条件。但是！ $ n \le 2000000000$！如果我们采用高精度乘法来计算，很容易就溢出了。所以得另想一个办法。

题目要求我们求使得 $x ^ x$ 的位数大于等于 $ N $ 的最小正整数 $ x $,实际上就是求不等式 $x ^ x \ge 10 ^ {N - 1} $的最小正整数解。$($想一想，为什么不是$10^N?)$ 我们以 $10$ 为底取对数，得到：

$\lg x ^ x \ge N - 1$

$x * \lg x \ge N - 1$

$x * \lg x + 1 \ge N$

这下题目就变得非常简单了！设函数 $f(x) = x * \lg x + 1$，我们可以知道 $f(x)$ 是一个单调递增的函数。所以我们只要在区间 $[1,2*10^9]$ 里查找满足条件的最小的 $x$ 就可以了。记得开 long long哦！

话不多说，上代码！
```cpp
#include <bits/stdc++.h>
using namespace std;
long long f(int x){
	return x * log(x) / log(10) + 1;
}
int main(){
	long long N;
	cin >> N;
	long long l = 1,r = 2e9;
	while (l < r){
		long long mid = (l + r) / 2;
		if(f(mid) >= N) r = mid;
		else l = mid + 1;
	}
	cout << l << endl;
	return 0;
}
```


---

## 作者：Nepenthe (赞：0)

乍一看是一道数学题

其实就是一道数学题

**数学的力量** $a$ 在 $b$ 进制下的位数 $p$ 的计算公式为 $p=\lfloor log_b a \rfloor+1$

其实很好理解:

设$\lfloor x \rfloor$表示不超过 $x$ 的最大整数,若 $n=(a_k,a_k-1,...a_1,a_0)_b,a_k≠0$

则$$b^k≤n<b^{k+1} ⇒k≤log_bn<k+1$$

即$k=\lfloor log_bn \rfloor$,总位数 $p=k+1$

所以$x^x$的位数就是$\lfloor lg{x^x} \rfloor+1$,运用对数知识就是$\lfloor xlgx \rfloor+1$

然后考虑到对数函数是单调的，所以可以用二分答案

**Code**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
using namespace std;
LL n,l=1,r=2e9;
int main(){
    
    scanf("%lld",&n);
    while(l<r){
        LL mid=(l+r)>>1,len=(LL)(mid*log10(1.0*mid))+1;
        if(len<n) l=mid+1;
        else r=mid;
    }
    cout<<l<<endl;
    return 0;
}
```



---


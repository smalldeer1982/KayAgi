# 小鸟的设备

## 题目背景

小鸟有 $n$ 个可同时使用的设备。


## 题目描述

第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。

同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。

小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。


## 样例 #1

### 输入

```
2 1
2 2
2 1000
```

### 输出

```
2.0000000000```

## 样例 #2

### 输入

```
1 100
1 1```

### 输出

```
-1 ```

## 样例 #3

### 输入

```
3 5
4 3
5 2
6 1```

### 输出

```
0.5000000000 ```

# 题解

## 作者：qq1010903229 (赞：152)

本题使用二分答案。

在验证一个使用时间时，若设备已有的能量大于使用时间需要的能量，忽略该设备。

否则用充电器充电，使设备已有的能量等于使用时间需要的能量，并记录需要的能量。

最后比较需要的能量总和和充电器最多提供的能量。

-1特判：

若所有设备的消耗能量速度总和还是小于充电器的充电速度，输出-1。

AC代码如下：

```cpp


#include  <iostream>
using namespace std;
int n;//设备数量
double p;//充电器的充电速度
double a[200000],b[200000];
double lbound=0,rbound=1e10;
double sum=0; //需要的能量总和（验证答案时）、所有设备的消耗能量速度总和（-1特判时）
int check(double ans){//验证答案
	double q=p*ans;//充电器最多提供的能量
	sum=0;
	for(int i=0;i<n;i++){
		if(a[i]*ans<=b[i]){//若设备已有的能量大于使用时间需要的能量
			continue;//忽略该设备
		}
		sum+=(a[i]*ans-b[i]);//否则用充电器充电，使设备已有的能量等于使用时间需要的能量，并记录需要的能量。
	}
	return sum<=q;//最后比较需要的能量总和和充电器最多提供的能量。
}
int main(){
	cin>>n>>p;
	for(int i=0;i<n;i++){
		cin>>a[i]>>b[i];
		sum+=a[i];
	}
	if(sum<=p){//若所有设备的消耗能量速度总和还是小于充电器的充电速度，输出-1。
		cout<<-1.000000<<endl;
		return 0;
	}
	while(rbound-lbound>1e-6){
		double mid=(lbound+rbound)/2;
		if(check(mid)){
			lbound=mid;
			
		}else{
			rbound=mid;
			
		}
	}
	cout<<lbound<<endl;
	return 0;
}


```

---

## 作者：Konnyaku_LXZ (赞：65)

能无限使用的情况显然，就是**当所有设备的能量消耗速度的总和小于等于充电宝的充电速率时，可以无限使用**。这时候直接输出 $-1$ 即可。

我们看到，题目要求能使用时间的最大值，而并不需要求出如何使用充电宝。这种类型的题目，我们第一个想到的就是动态规划。

但是我们会发现，动态规划并不能维护题目所要求的东西。所以我们将思路转向另一种求最值问题的方法：**二分答案**。

找到了这个思路以后，我们要处理的最关键的问题，就是**如何在时间已经确定的情况下用 $O(n)$ 的复杂度判断能否使用这么长时间**，这也是本题最大的难点。

我们考虑一个**贪心**策略。

首先，如果一个设备在 $t$ 的时间内消耗的能量**小于或等于**原有的能量，那么我们自然**没有必要浪费时间给它充电**，因为它在这段时间内的能量不会降为 $0$ 。

然后我们考虑设备消耗的能量**大于**原有能量的情况。

由于我们并不在乎什么时候给设备充电，所以我们只需要对于每一个这样的设备，求出**我们需要给它充的电**即可。求出需要的电的方法显然，就是 $a_i * t - b_i$ 。

然后我们只需要把所有的需要充电的设备需要充的电**加起来**，判断充电宝能否在 $t$ 的时间内充这么多的电即可。

时间复杂度: $O(NlogN)$ 。

Code:

``` cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;

typedef long long LL;
const LL MAXN=1e5+50,MAXX=1e10;//二分答案的起始右端点是1e10
const double MINN=1e-6;//控制精度

LL N,P,a[MAXN],b[MAXN];
double sum=0,Ans=-1;//直接把初始值赋成-1

double cost(LL a[],LL b[],LL L,LL R,double x){//cost函数计算所有设备在x时间内能量的消耗
	double sum=0;
	for(int i=L;i<=R;i++){
		double temp=a[i]*x;
		if(temp>b[i]) sum+=temp-b[i];
	}
	return sum;
}

void Init(){
	scanf("%lld%lld",&N,&P);
	for(int i=1;i<=N;i++) scanf("%lld%lld",&a[i],&b[i]),sum+=a[i];
}

void Solve(){
	if(sum<=P) return;//-1特判
	double l,mid,r;
	for(l=0,r=MAXX,mid=(l+r)/2;r-l>MINN;mid=(l+r)/2){
		double temp=cost(a,b,1,N,mid);
		if(P*mid>=temp) l=mid;//如果可以持续当前时间，就将l赋值成mid
		else r=mid-MINN;//不能持续则将r赋值成mid-MINN
	}
	Ans=l;
}

void Print(){
	printf("%.10lf\n",Ans);
}

int main()
{
	Init();
	Solve();
	Print();
	return 0;
}
```

最后总结一下，本题是一道**贪心+二分答案**求最值的题，总体难度不算很高，不过做完之后我对这两个算法的理解深了挺多的。

---

## 作者：流绪 (赞：36)

看了一下题解，都没有解释关于充电器的问题：如果一个时刻有多个手机没电了，怎么办？我觉得这是这题的难点，能明白这一点之后这就是一道普通的实数二分题了。

例如数据：

3 10

5 5

5 5

5 5

答案为：3。按照我代码里的意思是每个手机用了 1s 来充电让他能用到 3s。那么问题就来了，三把手机在 1s 就都没电了，你只给一把充了电，其他的还是没电了，答案不应该是 1 吗？

不是的！我们的充电并不是一次性充了 b[i]-a[i]*x，而是充了多次，他的充电时间和为这个值！为什么可以这样做呢？

首先换手机充电的操作是瞬间完成，其次电量变化是连续的。这也就给了我们充一会一把手机，让它能用到我把其他手机充电到能用到相同时刻的电量的可能。这样我们就可以一直按这样做下去，使其使用时间尽量长。因为使用时间可以二分找到，那么我们对于每把手机的充电量也就可以全部一次性算出来，而不用一份一份算啦。

所以我们在 check 函数里判断时间可不可行虽然是整段算的，但实际上它被分为很多细小的部分分别进行充电。

下面是 AC 代码。同其他二分题解的代码。
```cpp
#include<bits/stdc++.h>
#define int long long
#define ld long double
#define inf 0x7f7f7f7f
#define maxn 100010
#define ri register int
#define il inline
#define mod 1000000009
#define db() cout << 1 << endl
#define eps 0.000001
using namespace std;
ld n,m;
ld a[maxn],b[maxn];
int check(ld x)
{
	ld cnt = 0.0;
	for(int i=1;i<=n;i++)
	{
		ld p= b[i]-a[i]*x;
		if(p<0)
			cnt += -p;
		if(cnt > x*m)
			return 0;
	}
	return 1;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for(int i=1;i<=n;i++) 
		cin >> a[i] >> b[i];
	ld l=0.0,r=1e10,mid;
	while(r-l>=eps)
	{
		mid = (l+r)/2;
		cout << mid<<endl;
		if(check(mid))
			l=mid;
		else
			r=mid;
	}
	if(r >= 1e10)
		cout << -1;
	else
		printf("%.10Lf",r);
  	return 0;
}
```


---

## 作者：iuyi (赞：22)

这题似乎有一个贪心做法。

按照设备不额外充能可以使用的时间排序

记录两个数组，

第一个数组ai表示前i个机器的总消耗速度，

第二个数组bi表示将前i个机器全部充能到使用时间

等于第i个机器需要的能量。

~~不要在意变量重名的问题~~

寻找一个最大的i使得那个充电宝充bi的能量所用的时间

小于第i个机器使用初始能量的工作时间。

答案一定大于第i个机器的初始工作时间，

小于等于第i+1个机器的初始工作时间。

计算答案时分为两部分：第i个机器的初始工作时间和之后的部分。

第二部分时间等于到达第i个机器初始工作时间时的剩余能量除以(ai-p)。

处理一下边界。

特判-1。

复杂度O(nlogn)，不依赖精度。

AC代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

int n;
double p;
struct nd
{
	double a;
	double b;

}x[100005];
double a[100005];
double b[100005];

double ans = 0;

signed main()
{
	cin >> n >> p;
	for(int i = 1; i <= n; i++)
	{
		cin >> x[i].a >> x[i].b;
	}
	sort(x+1,x+1+n,[](nd x, nd y){
		return x.a*y.b > y.a*x.b;
	});
	x[0].a = 1; 
	for(int i = 1; i <= n; i++)
	{
		a[i] = a[i-1] + x[i].a;
		b[i] = b[i-1] + a[i-1]*(x[i].b/x[i].a-x[i-1].b/x[i-1].a);
	}
	b[n+1] = 1e10;
	for(int i = 1; i <= n; i++)
	{
		if(b[i+1]*x[i+1].a >= x[i+1].b*p)
		{
			ans = (x[i].b/x[i].a-b[i]/p)*p/(a[i]-p) + x[i].b/x[i].a;
			break;
		}
	}
	if(a[n] <= p)
	{
		ans = -1;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Ja50nY0un9_as_AgNO3 (赞：18)

看到现有题解基本都是二分，~~唯一一篇贪心我还看不懂~~，就来交一发题解讲讲贪心做法。

题意大概是，有 $n$ 台设备和可在任何时刻为任意设备每秒充电 $p$ 个单位的充电宝。求电量耗尽前使用时间最短的设备的最长使用时间。

无解情况显然：当 $\sum\limits^{n}_{i=1}a_i\leq p$，即充电速度不小于所有设备的耗电速度之和，可以无限充电。此时输出 $-1$ 并退出。

------------

以下以 $t_i$ 表示第 $i$ 台设备的使用时间。

对于 $\sum\limits^{n}_{i=1}>p$ 的情况，因为总电量不断减少，能够使用的时间一定是有限的。考虑贪心做法。

贪心策略是，每次为 $t_i$ 最短的设备充电，直到其电量耗尽或与 $t_i$ 次短的设备的可使用时间相等。

然后合并两台设备，并为合并后的设备继续充电……以此类推，直到电量耗尽。为避免所有设备都可合并的情况，可以在数组末尾添加一台 $a_i=0$（可无限使用）的设备 $n+1$。

**正确性证明：**

考虑设备 $i, j$。

若 $t_i\leq t_j$:

若为设备 $j$ 充 $p$ 点能量，则答案为 $\min(t_i, t_j+\dfrac{p}{a_j})=t_i.$

若为设备 $i$ 充 $p$ 点能量，则答案为 $\min(t_i+\dfrac{p}{a_i},t_j).$ 

$\because p\geq1>0,a_i\geq1>0.$

$\therefore \dfrac{p}{a_i}>0.$

$\therefore t_i+\dfrac{p}{a_i}>t_i.$ 

$\because t_i\leq t_j.$

$\therefore \min(t_i+\dfrac{p}{a_i}, t_j)\geq t_i.$

反之同理。

综上，优先为目前可使用时间较短的设备充电始终不劣。

空间复杂度 $\Theta(n)$，时间复杂度 $\Theta(n\log n)$，时间复杂度的瓶颈是初始数组的排序。

注意，在代码实现的时候，应尽量规避除法以保证最后答案的精度。

为了证明我不是在瞎说，底下是部分代码。

```cpp
struct Item
{
    long long a, b;
}a[100002];

bool cmp(Item x, Item y)
{
    return x.b * y.a < y.b * x.a;
}

int main()
{
    int n;
    long long p;
    cin >> n >> p;
    long long sum = 0;
    for (int i = 1; i <= n; i++){
        cin >> a[i].a >> a[i].b;
        sum += a[i].a;
    }
    if (sum <= p){
        cout << -1;
        return 0;
    }
    sort(a + 1, a + n + 1, cmp);
    a[n + 1].a = 0, a[n + 1].b = 100000;
    //额外设备，使用时间无限
    for (int i = 2; i <= n + 1; i++){
        if (a[i - 1].b * a[i].a + a[i].b * p < a[i].b * a[i - 1].a){
            printf("%.6lf", 1.00 * a[i - 1].b / (a[i - 1].a - p));
            return 0;
        }
        a[i].a += a[i-1].a;
        a[i].b += a[i-1].b;
    }
    return 0;
}
```

---

## 作者：一架飞机 (赞：14)

- 总体算法 :
给设备 i 充电 k 秒（ k 不一定是整数）其实就是在 b[i] 的基础上加上 k*p，所以充电的具体时间不会影响答案，我们只需保证：**每个设备的原电量 b[i] +充电时间 k * 充电速度 p = 可用时间（答案）\* 每个设备的耗电速度 a[i]**(最优)。但我们还是不知道给每个设备充电的时间。不能枚举，因为可以有小数。所以就选择**二分答案**。
- check 函数 : 现已知可用时间，用**贪心**：如果$最少所需充电量（a[i]*ans-b[i]（当需要充电，即a[i]-ans<b[i]时））的总和小于等于最多可充电量（ans * p）$则说明ans小了。反之，则说明ans大了。

- 特判无解 :
如果**单位时间内总消耗能量小于单位时间内供应能量**，则无解。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std; 
const int M=100005;
double a[M],b[M],p;int n;
bool check(double x){
	double sum=0;//sum->所需充电量 
	for(int i=1;i<=n;i++){
		if(b[i]<x*a[i]){
			sum+=x*a[i]-b[i];
		}
	}
	return sum<=p*x;
}
int main(){
	cin>>n>>p;double asum=0;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		asum+=a[i];
	} 
	if(asum<=p){//无解 
		cout<<-1<<endl;
		return 0;
	}
	double l=0,r=1e10;
	while(r-l>0.000001){//二分答案（可用时间）
		double mid=(r+l)/2;
		if(check(mid))l=mid; 
		else r=mid;
	}
	cout<<l;
	return 0;
}
```




---

## 作者：离散小波变换° (赞：14)

## 题意简述

$n$个设备，初始电量为$B_i$单位，耗电速度为$A_i$且在实数域上连续。现在有个充电宝，可以给任意设备充电，充电速度为$p\text{单位}/s$。求最大的时间$t$，使得没有任何设备在$t$时刻之前耗完电。

## 题解

$\qquad$很显然，$t$满足单调性。而因为充电宝切换充电设备的时间不计，因此我们只需要考虑$t$时刻需要的总电量以及可以提供的总电量。我们可以使用倍增求出最大的$t$。

$\qquad$假设现在答案为$t'$。那么在$t'$时刻内，我们一共可以充$t'\times p$单位的电量。对于每个设备，这段时间内一共会消耗$C_i=A_i\times t' $的电量。我们判断$B_i$是否大于$C_i$。若$B_i<C_i$，我们就需要用总电量减去需要的电量$C_i-B_i$。最后检查剩余的总电量是否大于$0$即可。

$\qquad$然后是关于这题的精度问题。如果用倍增算法，可以很容易地控制精度：倍增量$k$从$10^{-11}$开始。另外，有一个技巧：控制循环的次数（比如$200$次），这样就可以在保证精度的情况下不会$\text{TLE}$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;
typedef long long LL;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =1e5+3;
int n,v,A[MAXN],B[MAXN];
typedef double LD;
bool chk(LD t){
    LD w=t*v; up(1,n,i){
        if((LD)B[i]<(LD)A[i]*t)
        w-=(LD)A[i]*t-B[i];
    }
    return w>1e-13;
}
LD INF =1e30;
int main(){
    n=qread(),v=qread();
    up(1,n,i) A[i]=qread(),B[i]=qread();
    LD p=1e-9,k=1e-9; up(1,200,i){
        if(p+k<INF&&chk(p+k)) p+=k,k*=2.0; else k/=2.0;
    }
    if(p>=INF/2) puts("-1"); else
    printf("%.10lf\n",p);
    return 0;
}
```

---

## 作者：jhc060321 (赞：10)

本题可以使用二分答案的解法。

对于二分答案，就是利用二分算法来找到答案，如果当前答案可行，则最终的答案一定大于等于它，否则最终的答案小于等于它。

二分部分代码：
```cpp
    l=0.0;
    r=3000000001.0;//如果定1e9,会发现有一个测试点过不了，因为答案大于1e9。
    while(l<=r-1e-6)//题目中误差不得大于1e-4,这里我定1e-6可以免得卡精度。
    {
        mid=(l+r)/2;
        if(check(mid))//判断答案是否可行。
        
        {
            l=mid;
        }
        else {
            r=mid;
        }//二分答案。
    }
    printf("%lf",r);
```
我们还需要一个$check()$函数，判断当前的答案是否可行。
```cpp

int check(double m)
{
    double c=0;
    for(int i=1;i<=n;i++)
    {
        if(a[i]*m>b[i])
        c+=(a[i]*m-b[i]);//如果设备原有电量不够用，那么必须充电。
    }
    c-=p*m;
    if(c>0.0)return 0;
    return 1;
    //最后判断要充的电量是否小于等于可充的电量，是则返回真，否则为假。
}
```
还有一个特判：如果所有设备单位时间的用电量小于等于充电器单位时间的充电量，则可以无限使用，输出$-1$。
```cpp
 double c=0;
    for(int i=1;i<=n;i++) c+=a[i];
    if(c-p<=0.0){
        printf("-1");
        return 0;
    }
```
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double p;//我定double，防止卡精度。
double a[100001],b[100001];
double l,r,mid;
int check(double m)
{
    double c=0;
    for(int i=1;i<=n;i++)
    {
        if(a[i]*m>b[i])
        c+=(a[i]*m-b[i]);//如果设备原有电量不够用，那么必须充电。
    }
    c-=p*m;
    if(c>0.0)return 0;
    return 1;
    //最后判断要充的电量是否小于等于可充的电量，是则返回真，否则为假。
}
int main()
{
    scanf("%d%lf",&n,&p);
    for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i],&b[i]);
    double c=0;
    for(int i=1;i<=n;i++) c+=a[i];
    if(c-p<=0.0){
        printf("-1");
        return 0;
    }
     l=0.0;
    r=3000000001.0;//如果定1e9,会发现有一个测试点过不了，因为答案大于1e9。
    while(l<=r-1e-6)//题目中误差不得大于1e-4,这里我定1e-6可以免得卡精度。
    {
        mid=(l+r)/2;
        if(check(mid))//判断答案是否可行。
        
        {
            l=mid;
        }
        else {
            r=mid;
        }//二分答案。
    }
    printf("%lf",r);
}
```


---

## 作者：NXYorz (赞：10)

[原题这里](https://www.luogu.com.cn/problem/P3743)


## 思路：二分答案

根据题意我们可以进行二分答案，每一次二分一个答案就进行判断是否可以使用那么长时间，具体判断步骤：

枚举每一个设备，看其使用我们二分的这个时间至少需要充电多少分钟，如果这个时间大于了题目所要求的时间，直接返回。

**特别要注意精度和边界问题**

因为有$1e5$个设备，每一个设备最多是$1e5$个能量，所以右边界就应该是$1e5\times 1e5=1e10$，因为我们可以把这些设备等效成一个大设备，所有的设备的能量加起来，他们消耗电量的能力加起来，然后所求出的时间就是最长时间。

如果我们最后二分的答案大于等于这个值，那么就可以无限使用。

由于这里是实数，所以不可以像整数二分的一样每一把$1$当做单位，可以把精度当做单位直接二分。

```cpp
#include<iostream>
#include<cstdio>
#define N 100000
#define L 5000000000
using namespace std;
int n,p;
int a[N+1],b[N+1];
double jd=0.000001;
inline bool check(double d)
{
    double sum=0;
    for(register int i=1;i<=n;i++)
    {
        double x=(double)b[i]-(double)a[i]*d;
        if(x<0)
            sum+=(-x)/(double)p;
        if(sum>d) return false;
    }
    return true;
}
void in(int &x)
{
    char ee=getchar();x=0;
    while(ee<'0'||ee>'9') ee=getchar();
    while(ee>='0'&&ee<='9') x=(x<<1)+(x<<3)+ee-'0',ee=getchar();
}
int main()
{
   // freopen("aa.in","r",stdin);
    in(n);in(p);
    for(register int i=1;i<=n;i++) {in(a[i]);in(b[i]);}
    double l=0,r=2*L+jd;
    while(r-l>jd)
    {
        double mid=(l+r-jd)/2;
        if(!check(mid)) r=mid;
        else l=mid+jd;
    }
    if(l>=2.0*L) printf("-1");
    else
    printf("%.6lf",l);return 0;
}
```

[强行推荐博客](https://www.luogu.com.cn/blog/niexiaoyang12138/)

---

## 作者：Zeda_ (赞：10)

![](https://cdn.luogu.com.cn/upload/pic/5170.png)

#### 通俗的来说就是 abs(std-out)<=1e-4

 先考虑无解的情况，如果充的能量不小于每次花费的能量，则可以无限充电，这是显而易见的。
 
 考虑充的能量小于每次花费的能量，根据数据范围可以得知，应当是 O(nlong(n))级别的，易想到二分答案。
 
 思考check函数,add(充的能量)=t(时间)*p，对于每队a[i],b[i],对于时间的关系应该是 a[i]*t=b[i]+add
 
对于每个i，当a[i]*t-b[i]>0的时候,则需要给它补充a[i]*t-b[i]的能量。


时间复杂度 O (n*log(n))，

```cpp
#include<map>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
const int N=100000+10;
int n,p;
void read(int &x){
	x=0;char c=getchar();int f=0;
	while(c<'0'||c>'9'){if(c=='-')f|=1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
	if(f)x=-x;
}
struct node{
    int a,b;
}a[N];
bool check(double f){
    double add=f*(1.0*p);
    for(int i=1;i<=n;i++){
    	if(add<0.0)return 0;
    	double x=a[i].a*f-a[i].b;
        if(x<0);
        else{
            add-=x;
        }
    }
    return add>=0.0;
}
int main(){
    scanf("%d %d",&n,&p);
    long long num=0;
    for(int i=1;i<=n;i++){
        read(a[i].a);read(a[i].b);
        num+=a[i].a;
    }
    if(num<=p){
        puts("-1");
        return 0;
    }
    double l=0.0,r=1e10*1.0;
    while(r-l>1e-4){
        double mid=(l+r)/2;
        if(check(mid))l=mid+0.00001;
        else r=mid-0.00001;
    }
    printf("%.10lf",l);
    return 0;
}





```


---

## 作者：AxDea (赞：10)

[题面](https://www.luogu.com.cn/problem/P3743)

相对来说比较水的实数二分，但是这精度卡的。。。

废话不说，做法概要: 

二分的部分就不说了，自己去实现，自己去卡精度

只说 `check()` 函数以及特殊处理

对于答案是 $-1$ 的情况，只有一种情况，即: 
$$\sum_{i=1}^n a_i \leq p$$

注意：计算 $\sum_{i=1}^n a_i$ 的值时要用 `double` 不然你会挂得很惨

输入时特判即可

### check() 函数

显然，以 $k$ ，即使用时间作为二分对象，将 $k$ 传入 `check` 中

只要充电总和大于或等于用电总和就返回真，否则返回假

用公式来表示就是这个样子(返回true的情况):
$$p \times k+\sum_{i=1}^n b_i-a_i\times k \geq 0$$

细节：$b_i-a_i\times k$ 必须保证小于 $0$ 的情况时累加，即电池用完后才加

用 $1$ ~ $n$ 循环一下即可，为了提升效率，可在循环过程中直接判断

给出代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 100000+7;
int n,p;
int a[maxn],b[maxn];
inline bool check(double k) {
	double tmp = k * (double)p;
	for(int i=1;i<=n;++i) {
		double f = (double)b[i] - (double)a[i]*k;
		if(tmp < -f && f<0) return false;
		else if(f<0) tmp += f;
	}
	return true;
}
int main() {
	scanf("%d%d",&n,&p);
	double tmp = 0;                       // 某人用了int，他傻傻的看着90分15分钟
	for(int i=1;i<=n;++i) scanf("%d%d",a+i,b+i),tmp += a[i];
	if(tmp <= p) return printf("-1"),0;
	double l = 0,r = 1e10,mid;
	while(r - l >= 1e-6) {                // 1e-7 被 T
		mid = (l+r) / 2;
		if(check(mid)) l = mid;
		else r = mid;
	}
	printf("%.10lf",l);
	return 0;
}
```

---

## 作者：pipiispig (赞：7)

###这个题卡精度！！！
##这个题卡精度！！！
#这个题卡精度！！！
#很好，一个二分答案的（模板题）因为卡精度用了我一个小时QWQ'
```#include<cmath>
#include<cstdio>
#include<cstring>
#include<map>
#include<algorithm>
#include<deque>
#include<queue>
#include<stack>
#include<iostream>
using namespace std;
double n,p;
struct node{
	int x,y;
};
node s[200001];
double ans;
int cherk(double m){
	double cnt=m*p,ans1=0;//过于简单的模拟；
		for(int i=1;i<=n;i++){
			if(s[i].x*m<=s[i].y)continue;
			ans1=ans1+s[i].x*m-s[i].y;
			if(ans1>cnt)return 0;
		}
	return 1;
}
int main(){
	cin>>n>>p;
	double sum=0;
	for(int i=1;i<=n;i++){
		cin>>s[i].x>>s[i].y;
		sum+=s[i].x;
	}
	if(sum<=p){//-1的时候特判一下吧，如果单位充电量大于单位耗电总量那么就一定可以一直用下去，反之不行。
		cout<<"-1"<<endl;
		return 0;
	}
	double l=0,r=1000000000;//精度，精度，精度重要的事情说3遍！！！！
	while(r-l>=0.0000001){
		double mid=(l+r)/2;
		if(cherk(mid)){//话说cherk函数是二分答案唯一的难点了吧，然而这个题还是水的一比。
			ans=mid;
			l=mid+0.0000001;
		}
		else r=mid-0.0000001;
	}
	printf("%.10lf",ans);
}```
这个题真是卡精度卡到“丧心病狂”呀w(ﾟДﾟ)w

---

## 作者：zeng_yirong (赞：5)

#   	二分答案 
    首先题意要理解清楚：
	     关于充电：你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。
    也就是说，不是一秒一秒的充电，而是谁需要电就马上转换去充电。
         1、可无限循环特判：所有设备的消耗能量速度总和还是小于充电器的充电速度。
         
         2、边界寻找：最小边界为不充电下的能持续的最小时间；最大边界，若是所有的设备中给单独充电
         情况下仍不能无限的时间最大值为即为最大边界，若设备单独充电都能无限，此时必须依数据范围设
         一个上边界，可设为1e10;
         
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
double eps=1e-6;
typedef long long ll;
double n,p;
double aa[maxn],bb[maxn];
double bin_ans(double l,double r){  //经典二分 
	while(r-l>eps){
		double tp=p,mid=(l+r)/2;
		for(int i=1;i<=n;i++){
			double k=aa[i]-bb[i]/mid;
			if(k>eps)   // 为正表示mid时间下需要充电才能持续 
				tp-=k;
		}if(tp<eps&&tp>-eps) return mid;
		else if(tp>eps) l=mid;  //tp有剩余表示可行 
		else r=mid-eps;
	}return r;
}
int main(){
	//ios::sync_with_stdio(false);
	cin>>n>>p;
	double sum=0,a_min=maxn,b_max=0;
	for(int i=1;i<=n;i++){
		cin>>aa[i]>>bb[i];
		sum+=aa[i];
		a_min=min(a_min,bb[i]/aa[i]);//下边界 
		if(p<aa[i]) b_max=max(b_max,bb[i]/(aa[i]-p) );//单独充电不可无限上边界 
	}if(sum<=p) {  //无限特判 
		cout<<-1<<endl; return 0;
	}if(b_max==0) b_max=1e10+10;//单独充电都可无限的上边界 
	double res=bin_ans(a_min,b_max); 
	printf("%.6lf",res);
	return 0;
}
```


---


# [Code+#1] 木材

## 题目描述

有 $n$ 棵树，初始时每棵树的高度为 $H_i$，第 $i$ 棵树每月都会长高 $A_i$。现在有个木料长度总量为 $S$ 的订单，客户要求每块木料的长度不能小于  $L$，而且木料必须是整棵树（即不能为树的一部分）。现在问你最少需要等多少个月才能满足订单。


## 说明/提示

对于样例，在六个月后，各棵树的高度分别为 $14,47,56$，此时无法完成订单。

在七个月后，各棵树的高度分别为 $16,54,65$，此时可以砍下第 $2$ 和第 $3$ 棵树完成订单了。

 ![](https://cdn.luogu.com.cn/upload/pic/12821.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/郑林楷 命题/郑林楷 验题/王聿中

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
3 74 51
2 5 2
2 7 9
```

### 输出

```
7```

# 题解

## 作者：Drinkkk (赞：59)

$20$分思路：我们先模拟每棵树树每个月的高度，再看看这个数的高度是否大于或等于$L$，如果是就将当前截下的木材长度加上$L$，然后将这棵树的高度减去$L$即可，如果我们假设当前已经截下的木材长度为$da$，且现在是第$ans$个月的话，那么当$da>=L$时就要打印$ans$并跳出循环了。


$40$分思路：我们先模拟每棵树树每个月的高度，再看看这个数的高度是否大于或等于$L$，如果是就将当前截下的木材长度加上$h_i$，然后将这棵树的高度设为$0$即可，如果我们假设当前已经截下的木材长度为$da$，且现在是第$ans$个月的话，那么当$da>=L$时就要打印$ans$并跳出循环了。


$45$分思路：在模拟每棵树的高度之前我们需要先判断一下在第$0$个月时可否完成订单，若能够完成订单就输出$0$，否则就继续循环枚举。


$60$分思路：将我们的程序里的所有$int$类型的变量都转化为$long$ $long$类型的。因为$1<=S,L<=10^{18}$。


$75$分思路：使用二分查找，将$l$设为$0$，且将$r$设为∞，这样$mid$就是⌊$\frac{l+r}{2}$⌋。那么，在第$mid$个月时，$h_i$'=$h_i+a_i*mid$，统计一下在第$mid$个月是能否完成订单即可，若能够完成订单就将$r=mid$，否则就将$l=mid$，当$r-l>1$时进行循环，所以最终的答案就是$r$，如果你还不明白什么是二分查找下面将给出一个$l=1,r=10$的例子，其中浅绿色的格子代表$l$，深绿色的格子代表$r$，黄色的格子代表将要查找的点，浅蓝色的格子代表$mid$。


 ![](https://cdn.luogu.com.cn/upload/pic/12863.png) 

$85$分思路：将程序内的所有$long$ $long$转化为$unsigned$ $long$ $long$即可，其余同$75$分思路。


$100$分思路：先将$r$设为$max(S,L)$，再将$r$'设为$min(r$',$(r-h_i)/a_i+1)$即可，再将所有的$int$转化为$unsigned$ $long$ $long$即可。其余同$85$分思路。


$20$分代码：


```cpp
#include <cstdio>
int h[1000001],a[1000001];
int main()
{
    int ans=0,n=0,x=0,y=0;
    scanf("%d %d %d",&n,&x,&y);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&h[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    while(++ans)
    {
        for(int i=1;i<=n;i++)
        {
            h[i]+=a[i];
            if(h[i]>=y)
            {
                x-=y;
                h[i]-=y;
            }
        }
        if(x<=0)
        {
            break;
        }
    }
    printf("%d",ans);
    return 0;
}
```
$40$分代码：

```cpp
#include <cstdio>
int h[1000001],a[1000001];
int main()
{
    int ans=0,n=0,x=0,y=0;
    scanf("%d %d %d",&n,&x,&y);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&h[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    while(++ans)
    {
        for(int i=1;i<=n;i++)
        {
            h[i]+=a[i];
        }
        int da=0;
        for(int i=1;i<=n;i++)
        {
            if(h[i]>=y)
            {
                da+=h[i];
            }
        }
        if(da>=x)
        {
            break;
        }
    }
    printf("%d",ans);
    return 0;
}
```
$45$分代码：

```cpp
#include <cstdio>
int h[1000001],a[1000001];
int main()
{
    int ans=0,n=0,x=0,y=0;
    scanf("%d %d %d",&n,&x,&y);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&h[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    int da=0;
    for(int i=1;i<=n;i++)
    {
        if(h[i]>=y)
        {
            da+=h[i];
        }
    }
    if(da>=x)
    {
        printf("0");
        return 0;
    }
    while(++ans)
    {
        for(int i=1;i<=n;i++)
        {
            h[i]+=a[i];
        }
        int da=0;
        for(int i=1;i<=n;i++)
        {
            if(h[i]>=y)
            {
                da+=h[i];
            }
        }
        if(da>=x)
        {
            break;
        }
    }
    printf("%d",ans);
    return 0;
}
```
$60$分代码：

```cpp
#include <cstdio>
long long h[1000001],a[1000001];
int main()
{
    long long ans=0,n=0,x=0,y=0;
    scanf("%lld %lld %lld",&n,&x,&y);
    for(long long i=1;i<=n;i++)
    {
        scanf("%lld",&h[i]);
    }
    for(long long i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    long long da=0;
    for(long long i=1;i<=n;i++)
    {
        if(h[i]>=y)
        {
            da+=h[i];
        }
    }
    if(da>=x)
    {
        printf("0");
        return 0;
    }
    while(++ans)
    {
        for(long long i=1;i<=n;i++)
        {
            h[i]+=a[i];
        }
        long long da=0;
        for(long long i=1;i<=n;i++)
        {
            if(h[i]>=y)
            {
                da+=h[i];
            }
        }
        if(da>=x)
        {
            break;
        }
    }
    printf("%lld",ans);
    return 0;
}
```
$75$分代码：

```cpp
#include <cstdio>
long long h[1000001],a[1000001];
int main()
{
    long long ans=0,l=0,r=0,n=0,x=0,y=0;
    scanf("%lld %lld %lld",&n,&x,&y),r=999999999;
    for(long long i=1;i<=n;i++)
    {
        scanf("%lld",&h[i]);
    }
    for(long long i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    long long da=0;
    for(long long i=1;i<=n;i++)
    {
        if(h[i]>=y)
        {
            da+=h[i];
        }
    }
    if(da>=x)
    {
        printf("0");
        return 0;
    }
    long long nh[200001];
    while(r-l>1)
    {
        long long mid=(l+r)/2;
        for(long long i=1;i<=n;i++)
        {
            nh[i]=h[i]+mid*a[i];
        }
        long long da=0;
        for(long long i=1;i<=n;i++)
        {
            if(nh[i]>=y)
            {
                da+=nh[i];
            }
        }
        if(da>=x)
        {
            r=mid;
        }
        else
        {
            l=mid;
        }
    }
    printf("%lld",r);
    return 0;
}
```
$85$分代码：

```cpp
#include <cstdio>
unsigned long long h[1000001],a[1000001];
int main()
{
    unsigned long long l=0,r=0,n=0,x=0,y=0;
    scanf("%llu %llu %llu",&n,&x,&y),r=999999999;
    for(unsigned long long i=1;i<=n;i++)
    {
        scanf("%llu",&h[i]);
    }
    for(unsigned long long i=1;i<=n;i++)
    {
        scanf("%llu",&a[i]);
    }
    unsigned long long da=0;
    for(unsigned long long i=1;i<=n;i++)
    {
        if(h[i]>=y)
        {
            da+=h[i];
        }
    }
    if(da>=x)
    {
        printf("0");
        return 0;
    }
    unsigned long long nh[200001];
    while(r-l>1)
    {
        unsigned long long mid=(l+r)/2;
        for(unsigned long long i=1;i<=n;i++)
        {
            nh[i]=h[i]+mid*a[i];
        }
        unsigned long long da=0;
        for(unsigned long long i=1;i<=n;i++)
        {
            if(nh[i]>=y)
            {
                da+=nh[i];
            }
        }
        if(da>=x)
        {
            r=mid;
        }
        else
        {
            l=mid;
        }
    }
    printf("%llu",r);
    return 0;
}
```
$100$分代码：
```cpp
#include <cstdio>
unsigned long long h[1000001],a[1000001];
unsigned long long min(unsigned long long x,unsigned long long y)
{
    return x<y?x:y;
}
unsigned long long max(unsigned long long x,unsigned long long y)
{
    return x>y?x:y;
}
int main()
{
    unsigned long long now=0,l=0,r=0,n=0,x=0,y=0;
    scanf("%llu %llu %llu",&n,&x,&y),now=r=max(x,y);
    for(unsigned long long i=1;i<=n;i++)
    {
        scanf("%llu",&h[i]);
    }
    for(unsigned long long i=1;i<=n;i++)
    {
        scanf("%llu",&a[i]);
        r=min(r,(now-h[i])/a[i]+1);
    }
    unsigned long long da=0;
    for(unsigned long long i=1;i<=n;i++)
    {
        if(h[i]>=y)
        {
            da+=h[i];
        }
    }
    if(da>=x)
    {
        printf("0");
        return 0;
    }
    unsigned long long nh[200001];
    while(r-l>1)
    {
        unsigned long long mid=(l+r)/2;
        for(unsigned long long i=1;i<=n;i++)
        {
            nh[i]=h[i]+mid*a[i];
        }
        unsigned long long da=0;
        for(unsigned long long i=1;i<=n;i++)
        {
            if(nh[i]>=y)
            {
                da+=nh[i];
                if(da>=x)
                {
                    break;
                }
            }
        }
        if(da>=x)
        {
            r=mid;
        }
        else
        {
            l=mid;
        }
    }
    printf("%llu",r);
    return 0;
}
```

---

## 作者：Victorique (赞：27)

刷完带花树来看看水题。

不明白这题怎么到这个难度的，实际也就黄题难度。

容易看出，这个可行的月份可能很大，那么二分一下，每次二分里判断能够拿的树的总高度是否可以达到要求，然后逼近答案就可以了。

复杂度差不多O（64*n）。

如果实在看不懂我在说些什么，另一篇题解写的很详细（虽然我觉得完全没有必要）。

但是他的代码确实，写的，不是很好看。。

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <algorithm>
#define re register
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define MAXN 200001
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ull n,s,l,a[MAXN],h[MAXN];
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-') c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline bool check(ll x){
	ull cnt=0;
	for(re int i=1;i<=n;i++){
		if(h[i]+a[i]*x>=l) cnt+=h[i]+a[i]*x;
		if(cnt>=s) break;
	}
	if(cnt>=s) return 1;
	else return 0;
}
int main() 
{
    cin>>n>>s>>l;
    for(re int i=1;i<=n;i++) h[i]=read();
    for(re int i=1;i<=n;i++) a[i]=read();
    ll l=0,r=100000000000000000ll;
	while(l<=r){
		ll mid=l+r>>1;
		if(check(mid)) r=mid-1;
		else l=mid+1;
	}
	cout<<l;
    return 0;
}
```

---

## 作者：EXODUS (赞：21)

##### ~~这就是那个后天CSP复赛却还在水题解的蒟蒻~~

话说这个叫EXODUS的蒟蒻在看到机房同学[Anonymous31416](https://www.luogu.com.cn/user/360930)发表了[P5683的题解](https://www.luogu.com.cn/problem/solution/P5683)后，表示也想水一发,于是就有了这篇题解······

#### 注意事项：
+ 对于不会的，请通读全文并写一篇$2000$字感悟（HUA JI）。
+ 对于$WA$掉的，请移步$step3$。
+ 对于打代码只用三个键者，请移步$step4$。
+ 对于我的题解没有帮助者，请移步其他题解。
+ 凡是看到这篇题解者————求你们了给个赞吧（当然，我知道这是个十分合（~~无~~）理（~~耻~~）的要求（~~逃~~））！！！

**以下是正文部分**


------------

说实话，这道题并不难（~~那你还提交了5次？？？~~）

曾经，某位林姓大佬说过一句话
> **二分答案，就是让题目说人话**。

所以，我们就先让这个题目说一些人能听懂的话

### $step 1$:让这个题目说人话。
> 原题：
> - 有$n$棵树，初始时每棵树的高度为$H_i$，第 $i$ 棵树每月都会长高 $A_i$ 。
> - 现在有$S$份的订单，客户要求每块木料的长度不能小于$L$。
> - 现在问你最少需要等多少个月才能满足订单。

> 当它说了人话后：
> - 你有一个数列$A$,你可以进行$M$次操作。每次可以将第$i$个数加上$H_i$。
> - 请求出最小的$M$,使得有不少于$S$个数不小于$L$

> 当它再次思考，又说了一遍人话后：
> - 试求出最小的$M$，使得有至少$S$个$A_i$在加上$H_i$后不小于$L$。

### $step2$:为什么可以二分。

首先，想要二分答案，就要满足答案具有**单调性**。即若当答案为$k$成立时，答案为$k+1$时也成立。

而这道题中，答案显然具有单调性（~~你的树总不能越长越矮吧~~），所以我们考虑二分答案。

### $step3$:坑点分析。
> - 您的$long$ $long$开了吗（dalao们都说要开$unsigned$ $long$ $long$,但我没开也过了）？
> - 您在n为$1$时特判了吗（我的算法是要特判的，否则第一、二个点会$WA$）？

### $step4$:我的代码。
讲（~~xia~~）述（~~che~~）了这么多，终于要放代码了。

#### $90$ $code$:
```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int h[200005],a[200005],n,s,l;
bool check(int mid)
{
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		ans+=(h[i]+a[i]*mid>l?h[i]+a[i]*mid:0);
		if(ans>=s)return true;
	}
	return false;
}

void work()
{
	int l=0,r=1e18;
	int cnt=0;
	while(l<r&&cnt<=70)
	{
		cnt++;
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid;
		}
		else{ 
			l=mid+1;
		}
	}
	printf("%lld",r);
	return;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&s,&l);
	for(int i=1;i<=n;i++){
		scanf("%lld",h+i);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",a+i);
	}
	work();
	return 0;
}
```
$AC$ $code$
```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int h[200005],a[200005],n,s,l;
bool check(int mid)
{
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		ans+=(h[i]+a[i]*mid>l?h[i]+a[i]*mid:0);
		if(ans>=s)return true;
	}
	return false;
}

void work()
{
	int l=0,r=1e18;
	int cnt=0;
	while(l<r&&cnt<=70)
	{
		cnt++;
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid;
		}
		else{ 
			l=mid+1;
		}
	}
	printf("%lld",r);
	return;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&s,&l);
	for(int i=1;i<=n;i++){
		scanf("%lld",h+i);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",a+i);
	}
	if(n==1)
	{
		int i;
		if(h[1]>=s)
		{
			printf("0");
			return 0;
		}
		for(i=1;i<=10005;i++)
		{
			if(h[1]+a[1]*i>=s)
			{
				printf("%lld",i);
				return 0;
			}
		}
	}
	work();
	return 0;
}
```
大概就是这样了，代码中可能有疏忽，恳请指出，不胜感激。

管理大大求过（~~逃~~）

---

## 作者：dying (赞：17)

# Solution P4058 木材

**_[博客食用更佳](https://dying.blog.luogu.org/solution-p4058)_**

[题面传送门](https://www.luogu.com.cn/problem/P4058)

~~这是蒟蒻的第一篇题解，跪求支持~~

看到其他题解全是二分，~~极不喜欢二分的~~我来讲讲神奇的**贪心**。

### 做法分析

为方便，后文用 **_木材_** 代替 **_可用的树_** 。

首先，容易想到的是一个月份一个月份的枚举。

但是：

![](https://cdn.luogu.com.cn/upload/pic/12821.png)

看见这庞大的数据范围就注定了这么搞是不可能过的。

不过容易发现，只要某一段时间不出现新的木材，那段时间内每月树木成长的值都是固定的，就可以直接计算，所以我们的目的就是要找到这个区间。

所以，我们可以**贪心**的**从小到大**枚举每一个**出现新的可用木材的月份**并判断是否已经满足要求——这样来找到答案月份所在的区间（一个左开右闭区间），这个区间的每一个月都满足树木不会再长成木材。

首先，每棵树都再给他两个参数：长成可用木材所需要的最短时间和刚刚长成木材时的高度。
```cpp
struct tree{
	long long len,speed;//原本高度，生长速度 
	long long minc,first;//长来可用至少需要的月数，首次可用的高度 
}a[200010];
```
再把他们按长成可用木材所需要的最短时间从小到大排个序。（sort 完事）

每一次枚举时记录**每次枚举开始前的月份**，**可用木材的总成长速度**和**枚举前的高度**（一开始是0，故若第一次就搜到要特判不能除以0），计算**此次枚举的月份**，**新的总成长速度**和**新的高度**，如果新的高度能够满足客户要求，那么答案就在上次枚举和这次枚举的月份之间了。

计算方法如下：

```
新的月份数：     本次枚举的树所需的最小月份数

新的总成长速度： 之前的总成长速度+此月份新成木材的树的成长速度

新的高度：       距离上一次枚举时间的月份数*之前的总生长速度+上次已有的高度+新长成的木材的高度

结果计算式：     ans=（需求高度-上次高度）/这次之前的生长速度（如果算出的月份超过本月就输出本月）

注：结果向上取整
```

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
//快读快出板子，建议放在剪贴板上，懒得打 
typedef long long myint;
inline myint read(){
	myint x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void print(myint a){
	if(a<0)putchar('-'),a=-a;
	if(a>=10)print(a/10);
	putchar(a%10+48);
}

long long n=read(),s=read(),l=read();
struct tree{
	long long len,speed;//原本高度，生长速度 
	long long minc,first;//长成木材需要的月数，首次可用时的高度 
}a[200010];
bool cmp(tree a,tree b){return a.minc<b.minc;}//按长成材所需月份排序 

long long month,month2;//上次枚举结束的月份，本次枚举的月份 
long long high,high2;//当前木材总高度，此次枚举的木材总高度 
long long speed,speed2;//当前木材总生长速度，此次枚举的木材总生长速度 

int main(){
	for(int i=1;i<=n;i++)a[i].len=read();
	for(int i=1;i<=n;i++){
		a[i].speed=read();
		a[i].minc=max(0ll,(l-a[i].len+a[i].speed-1)/a[i].speed);//计算长成木材需要的月数
		a[i].first=a[i].minc*a[i].speed+a[i].len;//首次可用时的高度
	}
	sort(a+1,a+n+1,cmp);//排序 
	for(int i=1;i<=n;){
		month2=a[i].minc;high2=high+(month2-month)*speed;
		while(a[i].minc==month2&&i<=n)//这里while循环可解决多棵树同时长成 
			high2+=a[i].first,speed2+=a[i++].speed;
		if(high2>s){
			//注意向上取整，和特判算出的月份数大于本月（本月一定成立） 
			if(speed==0/*特判这是第一次枚举*/||(s-high+speed-1)/speed+month>=month2)print(month2);
			else print((s-high+speed-1)/speed+month);
			return 0;
		}
		month=month2,high=high2,speed=speed2;//更新月份 
	}
	print((s-high+speed-1)/speed+month);//如果所有树都长成木材了且总高度未达标就可以直接计算 
	return 0;
} 
```
完结撒花！！！

---

## 作者：封禁用户 (赞：13)

### 前言

这什么题啊，不就是个二分答案我从65到100都经历了一遍……（瞬间气哭）

[更好的阅读体验。](https://www.cnblogs.com/CM-0728/p/13518428.html)

### $\sf Solution$

~~题目理解起来不难的，大意就懒得写了。~~

一眼二分答案。

此题属于在形如 $\{0,0,0....1,1,1,\}$ 的序列中查找第一个 $1$ 的题型。

算法流程：

1. 初始化 $l=0,r=inf$ （ $r$ 尽可能大）。
1. 如果 $l=r$ ，停止循环。
1. 计算中点 $mid=\left\lfloor\dfrac{l+r}{2}\right\rfloor$。
1. 若等待 $mid$ 个月满足条件， $r=mid$ 。
1. 否则 $l=mid+1$ 。
1. 回到2。

至于如何判断是否满足条件，写一个函数check一下就珂以了啦~

### $\sf P.S.$

什么都要开`unsigned long long`，否则会WA的很惨。

### $\sf Code$

```cpp
#include<cstdio>
using namespace std;
unsigned long long n,s,k,mid,a[200005],h[200005];
bool check(unsigned long long x)
{
	unsigned long long ans=0;
	for(unsigned long long i=1;i<=n;++i)
		if(h[i]+x*a[i]>=k)//超过要求高度的树计算在总长度范围内
			ans+=h[i]+x*a[i];
	if(ans>=s)
		return true;
	return false;//如果满足订单需求就返回true
}
int main()
{
	scanf("%lld%lld%lld",&n,&s,&k);
	for(int i=1;i<=n;++i)
		scanf("%lld",&h[i]);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	unsigned long long l=0,r=10000000000000000;//l和r的初始化
	while(l<r)
	{
		mid=(l+r)/2;
		if(check(mid))
			r=mid;
		else l=mid+1;
	}//二分
	printf("%lld",l);//输出结果
	return 0;
}
```

---

## 作者：G_A_TS (赞：11)

蓝题吗？  
其实二分答案即可  
要开unsigned long long~~不然见祖宗~~  
个人认为~~比较清晰~~吧  
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,s,L,h[200010],a[200010],l,r,mid,te[200010];
unsigned long long tr(unsigned long long m)
{
	unsigned long long total=0,tgs=0;
	for(unsigned long long i=1;i<=n;i++)
	{
		te[i]=h[i]+m*a[i];
	}
	for(unsigned long long i=1;i<=n;i++)
	{
		if(te[i]>=L)
		{
			total+=te[i];
			tgs++;
		}
	}
	return total;
}
int main()
{
	//freopen("tree.in","r",stdin);
	cin>>n>>s>>L;
	for(unsigned long long i=1;i<=n;i++)
	{
		cin>>h[i];
	}
	for(unsigned long long i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	l=0;
	r=10000000000000000;
	if(tr(0)>=s)
	{
		cout<<0;
		return 0;
	}
	for(;l<=r;)
	{
		mid=(l+r)/2;
		if(tr(mid)<s)
		{
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
	cout<<l;
}
```

---

## 作者：旭日临窗 (赞：5)

- 主要**思路**：

- 二分答案(即最少等待时间$nid$)+一个check函数，但是在计算$mid·a[i]$的时候最大可能会达到$10^{18}·10^9=10^{27}$显然连longlong都会爆，所以就延伸出来了两种思路。

1. 思路一：
无脑开神器__int128他最大可以达到$2^{127}$，随便达到$10^{36}$，我也是第一次用__int128过题。

code(重点介绍第二种做法，所以就不加注释了):

```c
#include <bits/stdc++.h>
#define ll __int128
using namespace std;
ll n,s,l,cnt;
ll h[200010],a[200010];
inline ll read()
{
	cnt = 0;
	char c;
	while((c = getchar()) < '0' || c > '9');
	while(c >= '0' && c <= '9') cnt = cnt * 10 + (c - '0'),c = getchar();
	return cnt;
}
bool check(ll x)
{
	ll ans = 0;
	for(int i = 1;i <= n;i++)
	{
		if(h[i] + a[i] * x >= l) ans += h[i] + a[i] * x;
		if(ans >= s) return 1;
	}
	return 0;
}
int main()
{
	n = read(),s = read(),l = read();
	for(int i = 1;i <= n;i++) h[i] = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	if(check(0))
	{
		puts("0");
		return 0;
	}
	ll l = 0,r = 1e18,mid;
	while(r - l > 1)
	{
		mid = l + r >> 1;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%lld",(long long)r);
	return 0;
} 
```

2. 思路二：本篇重点。可以吧乘法转变成除法来做，原来不是
$h[i] + a[i] * x >= l$吗，我们可以这样写
$h[i] >= l || x >= (l - h[i] - 1) / a[i] + 1$因为会有精度误差所以才要减一加一，因为如果只加一的话如果
$(l-h[i])moda[i]==0$的话加一就会出错，所以减一，而且移项的话会发现结果不变。

所以$check$函数可以这样写：

```c
bool check(ll x)//我define ll 为 __int128
{
	ll ans = 0;
	for(int i = 1;i <= n;i++)
	{
		if(h[i] >= l || x >= (l - h[i] - 1) / a[i] + 1)
		{
			if(h[i] >= s || x >= (s - h[i] - 1) / a[i] + 1) 
			return 1;
			ans += h[i] + x * a[i];
		}
		if(ans >= s) return 1;
	}
	return 0;
}
```

这样的话$x*a[i]$就不会爆longlong了，因为如果能进到这一行的话说明

$x<(s - h[i] - 1) / a[i] + 1)=x*a[i]+h[i]<s$

而$s<=10^{18}$所以连longlong都不会爆。

code:

```c
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,s,l;
ll h[200010],a[200010];
bool check(ll x)
{
	ll ans = 0;
	for(int i = 1;i <= n;i++)
	{
		if(h[i] >= l || x >= (l - h[i] - 1) / a[i] + 1)
		{
			if(h[i] >= s || x >= (s - h[i] - 1) / a[i] + 1) 
			return 1;
			ans += h[i] + x * a[i];
		}
		if(ans >= s) return 1;
	}
	return 0;
}
int main()
{
	scanf("%lld%lld%lld",&n,&s,&l);
	for(int i = 1;i <= n;i++) scanf("%lld",&h[i]);
	for(int i = 1;i <= n;i++) scanf("%lld",&a[i]);
	if(check(0))
	{
		puts("0");
		return 0;
	}
	ll l = 0,r = 1e18,mid;
	while(r - l > 1)
	{
		mid = l + r >> 1;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%lld",r);
	return 0;
}
```


~~/管理员求过，thanks a lot/~~

---

## 作者：litifeng (赞：4)

我的解法：即不需要对 $n=1$ 进行特判，也不需要设置`unsigned long long`类型的变量。而是使用数学的技巧规避了会爆`long long`的问题。
### 会爆long long的点
当 $H=1,A=1,L=10^{18}$ 时，需要的月份就是 $10^{18}$，而check函数中的乘法运算：$A[i] \cdot x$,最大可以到 $10^9 \cdot 10^{18} = 10^{27}$，这里需要特殊处理check函数，即把乘法变成除法。
#### 本来我是这么写的，没考虑乘法溢出
```
bool check(LL x){
	LL cnt=0;
	for(int i=0;i<n;i++){
		if(h[i]+d[i]*x>=l) cnt+=h[i]+d[i]*x; //需要处理，爆LL
		if(cnt>=s) break;
	}
	if(cnt>=s) return true;
	return false;
}
```
#### 修改思路
可以把不等式 `h[i] + d[i] * x >= l` 两边同时整除 `d[i]`，我们可以这样写 `h[i] >= l\ ||\ x >= (l - h[i] - 1) / d[i] + 1` 减1再加1是为了保证除法的结果**上取整**，因为本来是这样: `x >= (l-h[i])/d[i]`，如果右边的 `(l-h[i])/d[i]` 是小数且大于x时，比如 `x=5 右边=5.1`,本来右边是大于   x 的，但由于c++ 的整除去掉小数，右边变成5了，这时左右变成相等了，就错了，所以右边对小数部分要上取整，如右边等于 $5.1$ 上取整变为 $6$，才是正解。

```
bool check(LL x){
	LL cnt=0;
	for(int i=0;i<n;i++){
		if(h[i]>=l || x>=(l-h[i]-1)/d[i]+1){
			if(h[i]>=s || x>=(s-h[i]-1)/d[i]+1){
				return true;
			}
			cnt+=h[i]+x*d[i];
		}
		if(cnt>=s) return true;
	}
	return false;
}
```
就是当x很大时，判断一下直接返回真
### 全部代码
```
#include <cstdio>
using namespace std;
const int N=2e5+10;
typedef long long LL;
LL s,l;
int n,h[N],d[N];
bool check(LL x){
	LL cnt=0;
	for(int i=0;i<n;i++){
		if(h[i]>=l || x>=(l-h[i]-1)/d[i]+1){
			if(h[i]>=s || x>=(s-h[i]-1)/d[i]+1){
				return true;
			}
			cnt+=h[i]+x*d[i];
		}
		if(cnt>=s) return true;
	}
	return false;
}
int main(){
	scanf("%d%lld%lld",&n,&s,&l);
	for(int i=0;i<n;i++) scanf("%d",&h[i]);
	for(int i=0;i<n;i++) scanf("%d",&d[i]);
	LL l=0,r=1e18;
	while(l<r){
		LL mid=(l+r)/2;
		bool f;
		if((f=check(mid))) r=mid;
		else l=mid+1;
	}
	printf("%lld\n",l);

	return 0;
}
```
### 补充
有人说，这道题特判一下1，就可以过，确实再洛谷AC了，如果你那么搞了，我可以很容易构造出一组数据，让你的代码WA，因为，经过我的计算，当左边界为0，右边界为$10^{18}$时，前20个$d[i]\cdot x$都超过$10^{20}$.
#### 计算代码：
```
#include <cstdio>
using namespace std;
int main(){
	double n=1e18;
	for(int i=0;i<20;i++){
		n/=2.0;
		double ans=n*1e9;
		printf("%d :%g,ans=%g\n",i+1,n,ans);
	}
	return 0;
}
```
#### 计算结果：
```
1 :5e+17,ans=5e+26
2 :2.5e+17,ans=2.5e+26
3 :1.25e+17,ans=1.25e+26
4 :6.25e+16,ans=6.25e+25
5 :3.125e+16,ans=3.125e+25
6 :1.5625e+16,ans=1.5625e+25
7 :7.8125e+15,ans=7.8125e+24
8 :3.90625e+15,ans=3.90625e+24
9 :1.95312e+15,ans=1.95313e+24
10 :9.76562e+14,ans=9.76563e+23
11 :4.88281e+14,ans=4.88281e+23
12 :2.44141e+14,ans=2.44141e+23
13 :1.2207e+14,ans=1.2207e+23
14 :6.10352e+13,ans=6.10352e+22
15 :3.05176e+13,ans=3.05176e+22
16 :1.52588e+13,ans=1.52588e+22
17 :7.62939e+12,ans=7.62939e+21
18 :3.8147e+12,ans=3.8147e+21
19 :1.90735e+12,ans=1.90735e+21
20 :9.53674e+11,ans=9.53674e+20
```

---

## 作者：TLE永动机 (赞：4)

## 蒟蒻上次的题解被拒了QWQ(~~不好意思跑题了~~)
## 话不多说,进入正题
## 首先,很明显,这是一道二分题,裸裸的二分
## 好了,上代码
# code:
```cpp
#include<iostream>
#include<cstdio>
#define ll unsigned long long 
using namespace std;

ll a[200010],h[200010],n,s,l;//定义

ll add(ll len)//返回木材的总长度
{
	ll ans=0;
	for(int i=1;i<=n;i++)
		if(a[i]*(len-1)+h[i]>=l) ans=a[i]*(len-1)+h[i]+ans;
	return ans;
}

ll find(ll L,ll R) //二分
{
	while (R-L>1)
	{
		ll M=(L+R)/2;
		if(add(M)>=s) R=M;
		else L=M;
	}
	return L;
}

int main()
{
	while (1); //防抄袭
	scanf("%llu%llu%llu",&n,&s,&l);
	for(int i=1;i<=n;i++)
		scanf("%llu",&h[i]);//读入
	for(int i=1;i<=n;i++)
		scanf("%llu",&a[i]);
	cout<<find(0,100000000000000000);
	return 0;//结束程序
}
```
## 蒟蒻的二分写法可能会与各位的不太一样,请见谅
## 望管理员大大通过!!!

---

## 作者：是真的囬气 (赞：3)

Solution
1.因为要求最少几个月，考虑进行二分答案；

2.考虑二分端点。因为有可能已开始就满足需求，所以左端点为0；

3.因为有两个约束条件，一个是总长度，一个是单根要求长度，我们无法确定二分的右端点到底是什么，所以我们需要知道到底哪一个才是真正的约束条件：

我们去比较要求的单根长度和把总任务分配到每一根的需求长度，取最大值就是实际的约束条件；那么二分的右端点实际上就是每棵树长高到约束条件的时间中的最大值，即：
```c++
for(i=1;i<=n;++i)if(h[i]<q)maxn=max(maxn,(q-h[i])/a[i]+1);
```
3.valid函数中验证的过程即为让sum加上所有经过x个月满足单棵树高度约束条件的树的高度，最后与总长度比较即可；

Code
```c++
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int h[200200],a[200200];
unsigned long long n,m,s,i,j,k,minn=0,maxn=0,l,r,q;

inline int rd(){
    int x=0;
    bool f=true;
    char c;
    c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=false;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return f?x:-x;
} 

bool valid(unsigned long long x){
    unsigned long long sum=0;
    bool flag=1;
    for(i=1;i<=n;++i)
        if(h[i]+a[i]*x>=minn){
            if(flag)sum+=h[i]+a[i]*x;
            if(sum>=s)return true;
    }
    return false;
}

int main(){
    scanf("%lld%lld%lld",&n,&s,&minn);
    for(i=1;i<=n;++i)h[i]=rd();
    for(i=1;i<=n;++i)a[i]=rd();
    q=max(minn,s/n+1);
    for(i=1;i<=n;++i)if(h[i]<q)maxn=max(maxn,(q-h[i])/a[i]+1);  
    l=0;r=maxn;
    while(l<r){
        unsigned long long mid=(l+r)/2;
        if(valid(mid))r=mid;
        else l=mid+1;
    }
    printf("%lld\n",l);
    return 0;
}
```

---

## 作者：jdsb (赞：2)

这道题的题意其实很明显，就是一个二分，因为答案满足单调性，月份越多，树越高，越能满足要求，我们需要二分出来一个**最小的满足条件的月份**，这就是我们要求的答案。那我们的答案要满足什么条件呢？其实也很明显，就是我们当前二分到了一个值，就把每棵树原来的高度+二分到的值*每棵树每月生长的高度，及h[i]+a[i]*x,然后我们判断一下它是否大于题目要求的L，如果大于就累计到sum中，最后判断一下，sum大于S即为合法。    

也就是说，我们需要找的答案是这样一个东西

0 0 0 0 0 **1** 1 1 

0为不合法，1为合法

所以二分部分也就是这样的
```cpp
while(l<r)
{
    mid=(l+r)>>1;
    if(check(mid)) r=mid;
    else l=mid+1;
}
```
最后的l就是所求答案

判断函数也很简单
```cpp
//ull 为unsigned long long，据过于~~毒瘤~~
bool check(ull x)
{
    for(ull i=1;i<=n;i++)
        hnow[i]=h[i]+x*a[i];//现在的树的高度
    ull sum=0;
    for(ull i=1;i<=n;i++)
    {
        if(hnow[i]>=l)
            sum+=hnow[i];//如果大于l，就累加
    }
    return sum>=s;//判断是否合法
```

最后附上完整代码
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long 
using namespace std;
ull n,s,l,h[2000005],a[2000005],hnow[2000005];
bool check(ull x)
{
    for(ull i=1;i<=n;i++)
        hnow[i]=h[i]+x*a[i];
    ull sum=0;
    for(ull i=1;i<=n;i++)
    {
        if(hnow[i]>=l)
            sum+=hnow[i];
    }
    return sum>=s;
}
int main()
{
	scanf("%llu%llu%llu",&n,&s,&l);
	for(ull i=1;i<=n;i++) scanf("%llu",&h[i]);
	for(ull i=1;i<=n;i++) scanf("%llu",&a[i]);
	if(check(0))//如果直接就满足就输出0 
	{
		puts("0");
		return 0;
	}
	ull l=1,r=5e18;//r的值一定要很大 
	while(l<r)
	{
		ull mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	printf("%llu",l);
	return 0;
}
```



---

## 作者：Limit (赞：2)

这题...emm....其实就是一个很裸的二分QAQ（~~知不知道为什么有蓝题难度~~逃...
```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cmath>
using namespace std;
typedef unsigned long long ll;
int n,i;
ll H[300001],A[300001];
ll l,r,S,L,ans,mid;
bool check(ll mid)//check想必都知道是什么意思了
{
  ll sum=0;
  for(i=1;i<=n;i++)if(H[i]+A[i]*mid>=L/*如果长度大于L客户才要，这个客户真不要好*/)
  {sum+=H[i]+A[i]*mid;/*在总长度中加上这一段*/if(sum>=S)return 1;/*够客户要的了就返回true*/}
  return 0;//客户不要QAQ
}
int main()
{
  cin>>n>>S>>L;
  ll sum=0;
  for(i=1;i<=n;i++){cin>>H[i];if(H[i]>=L)sum+=H[i];/*如果客户要的话就加上*/}
  if(sum>=S)//貌似不这样写会T一个点
  {
    cout<<0;return 0;
  }
  for(i=1;i<=n;i++)cin>>A[i];
  l=0;
  r=200000000000000000ll;
  //可能开的有点大QAQ，反正能过
  while(l<=r)//裸裸的二分
  {
  	mid=(l+r)/2;
  	if(check(mid)){r=mid-1;ans=mid;/*记录ans*/}else l=mid+1;//这种就看个人喜好了QAQ
  }
  cout<<ans;//输出ans
  return 0;
}
```
二分的裸题，没有什么难度，适合刚学二分的人QAQ


---

## 作者：开始新的记忆 (赞：1)

题目大意:现在有n棵树，每棵树都有一个原来的高度和每天的增长高度，现在要你看下一些数满足一下条件：

1.每棵树的高度不小于L。

2.砍下的树的高度总和不小于S。

问你最小多少天可以满足题目要求。

大致思路：二分答案，每次O(n)判断一下可不可行，时间复杂度O(n*logn)。

PS：要开unsigned的longlong，不然在一开始的算数中会自然溢出使得判断的程序出错。


```
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define ll long long
int n;
ll all,li;
struct node{
	ll now,add;
} a[200010];

bool check(ll x)
{
	ull ans=0;
	for(int i=1;i<=n;++i)
	{
		ull t=a[i].now+(a[i].add*x);
		if(t>=li)
			ans+=t;
		if(ans>=all)
			break;
	}
	if(ans>=all)
		return 1;
	return 0;
}

int main()
{	cin>>n>>all>>li;
	for(int i=1;i<=n;++i)
		cin>>a[i].now;
	for(int i=1;i<=n;++i)
		cin>>a[i].add;
	ll le=0,ri=100000000000000000ll;
	while(le<=ri)
	{
		ll mid=(le+ri)>>1;
		if(check(mid))
			ri=mid-1;
		else
			le=mid+1;
	}
	cout<<le<<endl;
	return 0;
}
```


---

## 作者：Kisaragi_77 (赞：1)

疯狂85~90的朋友们看过来

**你们需要int128**

如果实现的差一点的话很容易让中间的和出现ll*ll的级别

全部开int128就可以过了

```cpp
#include<cstdio>
#include<cctype>
#define ll __int128
#define N (int)2e5+5
using namespace std;
ll a[N],h[N],sum,len;
int n;
inline ll read(){
    char x =getchar();  ll a =0;
    while(!isdigit(x))  x =getchar();
    while(isdigit(x))   a =a*10+x-48,x =getchar();
    return a;
}
inline bool check(ll t){
    ll ans =0;
    for(int i=1;i<=n;++i)
        if(h[i]+t*a[i] >= len)  ans +=h[i]+t*a[i];
    return (ans >= sum);
}
int main(){
    n =read();  sum =read();    len =read();
    for(int i=1;i<=n;++i)   h[i] =read();
    for(int i=1;i<=n;++i)   a[i] =read();
    ll L =0,R =1e18,ans;
    while(L<=R){
        ll mid =(L+R) >>1;
        if(check(mid))  ans =mid,R =mid-1;
        else L =mid+1;
    }   printf("%lld",(long long)ans);
}

```

---

## 作者：loaky (赞：1)

我觉得这道题坑点还是比较多，首先要读懂题目，像我这种语文不好的，读题读了很久，题目中的s代表的是需要木材的总长，l是每根木材最少的长度，重要的条件是，每根木材必须完整，也就是说，一棵树最多只能得到一根木材，因为如果你砍过一次了，这棵树是不会继续长得，因为我们是把整颗树砍下来，所以只要这棵树满足最低条件就给他砍了，就不会再管这棵树了，蒟蒻开始理解成了，我们砍树只砍需要的部分，树根不会被砍，树就还可以继续长，如果是这样的话，这道题变了一个意思了，在这里我们对月份进行二分，月份最多就是max（s，li）毕竟你的树至少高为1，至少每天长1，每次取mid，判断mid月之后所有树能不能够完成订单，能够完成就r=mid，如果不能完成。就把l变成mid+1向后找。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const unsigned long long maxn=2*1e5+5;
unsigned long long n,s,li,h[maxn],a[maxn],l,r,nw[maxn];
unsigned long long check(unsigned long long md){
	unsigned long long now=0;
	unsigned long long fl=0;
	for(unsigned long long i=1;i<=n;i++){
		if(h[i]+a[i]*md>=li) now+=h[i]+a[i]*md;
		if(now>=s){
			fl=1;
			break;
		}
	}
	if(fl) return 1;
	else return 0;
}
int main(){
	scanf("%llu%llu%llu",&n,&s,&li);
	r=max(li,s);
	for(unsigned long long i=1;i<=n;i++){
		scanf("%llu",&h[i]);
	}
	for(unsigned long long i=1;i<=n;i++){
		scanf("%llu",&a[i]);
	}
	while(l<r){
		unsigned long long mid=(l+r)/2;
		if(check(mid)){
			r=mid;
		}	
		else{
			l=mid+1;
		}
	}
	printf("%llu",l);
	return 0;
}
```

---

## 作者：Masna_Kimoyo (赞：0)

# 又是一道二分题

看到出题人是[他](https://baike.baidu.com/item/%E9%83%91%E6%9E%97%E6%A5%B7/23470985?fr=aladdin)（应该有点人认识吧），我就开始写了

[题目传送门](https://www.luogu.com.cn/problem/P4058)

## 先讲一下二分

[二分的定义（水）](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/4081752?fr=aladdin)

有些题目可以用暴力轻松想出思路，却因为超时而过不去，这个时候就会用到二分

对我而言，二分其实就是优化暴力时间复杂度的一个算法，无非就是将 $O(n)$ 的时间复杂度优化到 $O(logn)$

只要暴力会写，二分就能写出来

## 思路

这道题的样例很大，所以自然要用二分

### 模板思路

取一个 $left$ ,取一个 $right$ ,算出中间值 $mid$ ，判断这个 $mid$ 可不可行，如果可以，就说明答案比 $mid$ 更小，把 $right$ 移到 $mid-1$ 的位置，如果不可以，就说明答案比 $mid$ 更大，把 $left$ 移到 $mid+1$ 的位置。直到 $left > right$ 为止

### 判断当前 $mid$ 是否可行

$n$ 表示树的数量

$S$ 表示订单需求长度

$L$ 表示每棵树符合要求的高度

$h[i]$ 表示每棵树初始高度($month=0$)

$a[i]$ 表示每棵树每个月生长的高度

$sum$ 表示当前已符合要求的总高度

如题，每棵树当前的高度($H$)为$:mid*a[i]+h[i]$

如果 $H>L$ 那么此树高度合格，$sum+=H$

如果最后 $sum>=S$ 则合格，$sum<S$ 则不合格

## 上代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long 
using namespace std;
const int N=2e5+5;
int n,l,r,L,S,mid;
int a[N],h[N];
inline int read()//快读
{
	int x=0;
	bool w=0;
	char c=getchar();
	while(!isdigit(c))
		w|=c=='-',c=getchar();
	while(isdigit(c))
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return w?-x:x;
}
inline bool check(int x)
{
	int sum=0;
	for(register int i=1;i<=n;++i)
	{
		if(a[i]*x+h[i]>=L)	
			sum+=a[i]*x+h[i];
		if(sum>=S)	return 1;
	}
	if(sum>=S)	return 1;
	return 0;
}//判断mid
signed main()
{
	n=read(),S=read(),L=read();
	for(register int i=1;i<=n;++i)
		h[i]=read();
	for(register int i=1;i<=n;++i)
		a[i]=read();
	l=0,r=S*1000;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(check(mid))
			r=mid-1;
		else	l=mid+1;
	}
	cout<<l;
	return 0;
}
//完结撒花
```
别问我那个$S*1000$是怎么得来的，开始写的 $S$ , $85$分，后来改成 $S*10$ ,分数又多一点，又改成 $S*100$ ,分数又多一点点，直到最后 $S*1000$ ,才得到了满分(显然不是正解)，考试的时候当然还是要写一个很大的数，至于写多少，自己算吧……

---

## 作者：EuphoricStar (赞：0)

## 思路：二分答案

如果你还不会二分建议做做这道模板题：[P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)

这题算是比较简单的二分。二分至少需要等待的月份，$check$ 函数中计算等待 $x$ 月后剔除掉长度小于 $L$ 的木材的长度总和，

如果长度总和 $\geq$ $S$ 则返回 `true`，否则返回 `false`。

## 坑点
- **二分的下界必须为 $0$，上界至少开到 $10^{17}$，否则会 WA 得很惨。**
- **切记开 $unsigned\ long\ long$。**

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;

ull n, s, l, h[200200], a[200200];

bool check(ull x)
{
    ull sum = 0;
    for (int i = 0; i < n; ++i)
    {
        ull curh = h[i] + a[i] * x;
        if (curh >= l) sum += curh;  // 如果长度不小于 L 则算进总和里
    }
    return sum >= s;
}

int main()
{
    ios::sync_with_stdio(0);  // 优化 cin, cout
    cin >> n >> s >> l;
    for (int i = 0; i < n; ++i) cin >> h[i];
    for (int i = 0; i < n; ++i) cin >> a[i];
    // 标准二分模板
    ull l = 0, r = 100000000000000000;
    while (l < r)
    {
        ull mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l;
    return 0;
}
```


---

## 作者：EarthGiao (赞：0)

## 【思路】
二分答案！    

二分答案模板题     
二分最少需要多少个月    
然后去检查     
枚举每一个树长k个月之后的长度   
如果超出ll那就ans加上    
如果最后ans大于等于s那么就返回真    
否则返回假    
重点是r的赋值    
可以比较s和ll的最大值然后赋值上去     
没必要自己想一个以为可以AC的数赋值上去    
除非你疯狂提交二分出可以AC得数qwq     

做完这道题之后发现我真是个憨憨    
明明可以赋值r为s和ll的最大值    
但是我却非要自己试数    
(我还真把自己当电脑了真是个憨憨）   

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int Max = 200005;
int h[Max],a[Max];
int n,s,ll;
bool check(int mid)
{
	int ans = 0;
	for(register int i = 1;i <= n;++ i)
	{
		int qwq = h[i] + a[i] * mid;
		if(qwq < ll)continue;
		ans += qwq;	
		if(ans >= s)return true;
	}
	return false;
}

signed main()
{
	cin >> n >> s >> ll;
	for(register int i = 1;i <= n;++ i)
		cin >> h[i];
	for(register int i = 1;i <= n;++ i)
		cin >> a[i];
	int l = 0,r = max(s,ll);
	while(l < r)
	{
		int mid = (r + l) >> 1;
		if(check(mid))r = mid;
		else	l = mid + 1;
	}
	cout << l << endl;
	return 0;
}
```

---


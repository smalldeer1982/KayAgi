# [CEOI 2012] 工作规划

## 题目描述

CEOI 在 $N$ 天内收到了 $M$ 个任务，每个任务需要 $1$ 台机器工作 $1$ 天来完成。CEOI 有很多台机器，每台机器一天只能完成一个任务。 CEOI 要求每个任务最多只能推迟 $D$ 天完成。换言之，如果一个客户在第 $S$ 天提交了一个任务，CEOI 必须在第 $S+D$ 天之前完成它。

请你写程序求出每个任务最多推迟 $D$ 天的前提下，最少需要多少台机器才能按要求完成所有任务。

## 说明/提示

对于 $50\%$ 的测试点，$M \le 10^5$。

对于所有测试点，$1 \le N \le {10}^5$，$0 \le D < N$ , $1 \le M< 10^6$。

## 样例 #1

### 输入

```
8 2 12 
1 2 4 2 1 3 5 6 2 3 6 4```

### 输出

```
2```

# 题解

## 作者：OI_StarGod (赞：5)

# 题意：

有 $m$ 个食物在 $n$ 天内生产出来，保质期为 $d$ 天，需要有人吃掉这些食品，每个人每天只能吃一个食品，求至少需要几个人能吃光食品并且食品不过期。

# 暴力解法：

大家注意，考场上，优先暴力，除非正解非常简单。

那这道题暴力怎么解呢？首先，我们可以发现，用 $m$ 个人吃最简单，没人吃一个即可。因此，我们枚举 $1$ 到 $m$ 间的每个数，判断能不能，找到就输出。

判断方法：

我们可以轻松发现，先吃早的食品一定比先吃晚的食品完成更好。因为早的食品保质期更早，所以先按时间排一下序。接下来，只要模拟一下就行了。

判断代码：

```cpp
bool check(int x) {//判断函数
	int sum = 0;//记录当前完成了几个任务。
	for (int i = 1; i <= n; ++i) {//当前是第几天
		if (sum >= m) {//如果完成的任务数和总任务数相同
			return 1;//已经完成了任务，x个人是可行的，返回true
		}
		for (int j = 1; j <= x; ++j) {//枚举每台机器
			if (a[sum] <= i && sum < m) {//如果这个食品已经生产出来了并且食品还没有吃完
				if (a[sum] + d < i) {//如果这个食品过期了，说明会吃不完
					return 0;//x个人不可行
				}
				++sum;//否则，吃掉这个食品
			}else {//如果食品还没生产出来或者已经生产完了
				break;//今天无法完成更多食品了，跳到下一天
			}
		}
	}
	return sum >= n;//返回是否吃完了食品
}
```

暴力代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, d, m;
int a[1000005];
int sum;
bool check(int x) {//判断函数
	sum = 0;//记录当前完成了几个任务。
	for (int i = 1; i <= n; ++i) {//当前是第几天
		if (sum >= m) {//如果完成的任务数和总任务数相同
			return 1;//已经完成了任务，x个人是可行的，返回true
		}
		for (int j = 1; j <= x; ++j) {//枚举每台机器
			if (a[sum] <= i && sum < m) {//如果这个食品已经生产出来了并且食品还没有吃完
				if (a[sum] + d < i) {//如果这个食品过期了，说明会吃不完
					return 0;//x个人不可行
				}
				++sum;//否则，吃掉这个食品
			}else {//如果食品还没生产出来或者已经生产完了
				break;//今天无法完成更多食品了，跳到下一天
			}
		}
	}
	return sum >= n;//返回是否吃完了食品
}
int main() {//主函数
	scanf("%d%d%d", &n, &d, &m);//输入
	for (int i = 1; i <= m; ++i) {
		scanf("%d", &a[i]);//存食品的生产日期
	}
	sort(a + 1, a + m + 1);//按生产日期从小到大排序
	for (int i = 0; i <= m; ++i) {//循环枚举有几个人
		if (check(i)) {//如果可以
			printf("%d", i);//输出
			break;//跳出
		}
	}
	return 0;//结束
}
```

期望得分：50 分。

实际得分：65 分。

[提交记录](https://www.luogu.com.cn/record/133643069)

PS：为什么前面的点 TLE 了，后面的反而 AC 了？

# 正解：

我们想一想，时间在枚举上花了很多，这要怎么优化呢？

方法当然是有的：

# 二分：

翻了一遍题解，没有人讲到二分到底是什么，这对蒟蒻很不友好。所以我来科普一下：

比如我们是在一个升序数组中查找元素。

朴素方法：遍历一遍整个数组。

高级方法：它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。——[oi-wiki](https://oi.wiki/basic/binary/)

简单来说就是每次查找中间元素，由于数组有序，所以如果没找到就可以将区间缩小一半，就这样不断缩小，最后当区间大小缩小到 1 时就可以确定答案。

---

如何运用到这道题呢？

我们想想，二分要求什么？

~~单调性~~ 有序！

这题有序吗？我们看，$x$ 个人能吃掉的，$(x+1)$ 个人也一定能吃掉，所以可以二分。

~~你们最爱的代码来了。~~

AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, d, m;
int a[1000005];
int l = 0, r, mid;
int sum;
bool check(int x) {//判断函数
	sum = 0;//记录当前完成了几个任务。
	for (int i = 1; i <= n; ++i) {//当前是第几天
		if (sum >= m) {//如果完成的任务数和总任务数相同
			return 1;//已经完成了任务，x个人是可行的，返回true
		}
		for (int j = 1; j <= x; ++j) {//枚举每台机器
			if (a[sum] <= i && sum < m) {//如果这个食品已经生产出来了并且食品还没有吃完
				if (a[sum] + d < i) {//如果这个食品过期了，说明会吃不完
					return 0;//x个人不可行
				}
				++sum;//否则，吃掉这个食品
			}else {//如果食品还没生产出来或者已经生产完了
				break;//今天无法完成更多食品了，跳到下一天
			}
		}
	}
	return sum >= n;//返回是否吃完了食品
}
int main() {
	scanf("%d%d%d", &n, &d, &m);//输入 
	r = m;//设置最大值 
	for (int i = 1; i <= m; ++i) {
		scanf("%d", &a[i]);
	}
	sort(a + 1, a + m + 1);//排序 
	while (l < r) {//二分 
		mid = (l + r) >> 1;//取中间值 
		if (check(mid)) {//如果可以 
			r = mid;//看看有没有更少的人 
		}else {
			l = mid + 1;//看看有没有更多得人 
		}
	}
	printf("%d", r);//输出 
	return 0;//结束 
}
```

---

## 作者：ztksc07 (赞：5)

# 题解：P6092 [CEOI2012] 工作规划

#### 前置知识：贪心、二分答案。

## 题目大意

有 $n$ 天 $m$ 个任务，每个任务需要一台机器用一天时间完成，每个任务最多推迟 $d$ 天完成。给定 $m$ 个任务提交的时间，求最少需要几台机器才能满足所有任务。

## 解题思路

解决此题，需要想清楚两个性质：

### 性质一：所需机器数量是单调的

这个性质不难理解，如果 $x$ 台机器能完成任务，那么 $x+1$ 台机器也能完成任务。

这个性质是优化此题解法的基础，我们可以使用二分答案在 $O(\log m)$ 的时间复杂度内快速找到最少需要的机器数量。我们二分机器数量 $x$，如果 $x$ 台机器能够完成任务就减少一些机器，否则就增加一些机器，最终找到最少所需的机器数量。

### 性质二：任务完成的顺序不重要

这个性质就比较抽象了。

具体来说是这样的，我们统计每一天提交的任务数量，利用贪心的思想，遍历每一天，把每一天能完成的任务尽可能完成（也就是完成最多 $x$ 个任务），然后把剩余任务堆积到下一天。如果下一天的任务总量比 $d$ 天能完成的任务总量还要大，那么就不可能完成任务了。

原理是这样的，因为每个任务必须在 $d$ 天内完成，那么第 $i$ 天的最大可接受任务数量就是 $x \times d$，也就是所有机器全力干 $d$ 天。如果在每次都完成最先提交的任务的情况下，第 $i-d$ 天往前的任务依然囤积到了第 $i$ 天，就会导致第 $i$ 天的任务数量超过 $x \times d$ 这个值。

这一块比较难理解，可以画图仔细想一想。

这个性质可以使代码简化，因为如果按题意模拟的话需要用到小根堆等数据结构。

## 代码实现

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e5+10;
const int maxm=1e6+10;
int n,m,d;
int s[maxm],t[maxn];
bool check(int mid){//利用性质二判断能否完成。 
	int tsk=0;
	for(int i=1;i<=n;i++){
		tsk=max(tsk+t[i]-mid,0);
		if(tsk>mid*d) return 0;
	}
	return 1;
}
int bfind(){//最小值二分答案。 
	int l=1,r=maxm,mid;
	while(l<r){
		mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	return l;
}
int main(){
	scanf("%d%d%d",&n,&d,&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&s[i]);
		t[s[i]]++;//桶数组记录数量。 
	}
	printf("%d\n",bfind());
	return 0;
} 
```

总时间复杂度 $O(n \log m)$。

## 一些坑点

- 贪心的时候不能直接减，因为如果机器数大于任务数就会有空闲机器，需要判断小于 $0$ 的情况。

- 输入顺序依次是 $n$、$d$、$m$，不要搞错了。

---

## 作者：lizhixun (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P6092)

### 题意简析

有 $n$ 天 $m$ 个任务，每个任务需要一台机器用一天时间完成，每个任务最多推迟 $d$ 天完成。给定 $m$ 个任务提交的时间，求最少需要几台机器才能满足所有任务。

### 思路

1、采用贪心的策略，在安排第 $i$ 个任务的时候尽量的少与别的任务产生冲突。那么可以考虑按左端点从小到大排序，若左端点相等则按照右端点从小到大排序。那么从前往后枚举，对于每一个任务来说肯定是选择左端点和后面的任务产生的冲突最小。（若左端点已经被前面的任务占据了，那么就考虑左端 +1 的位置，直到遍历完整个任务期限都没有找到一天可以安排这个任务，那么肯定就处理失败了）

2、二分最少的机器，然后按照上面的贪心思路进行处理即可。（当二分出一个最少的机器 $mid$，那么每
一天就可以安排 $mid$ 个任务）。

### AC Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 5;
int n, d, m;

struct node {
	int x, y;
} a[N];

bool cmp(node q, node h) {
	return q.x < h.x;
}

bool check(int mid) {
	int pos = 1, cnt = mid;
	
	for (int i = 1; i <= m; i++) {
		while (pos < a[i].x || cnt == 0) {
			pos++;
			cnt = mid;
		}
		
		if (pos > a[i].y) return 0;
		cnt--;
	}
	
	return 1;
}

signed main() {
	cin >> n >> d >> m;
	
	for (int i = 1; i <= m; i++) {
		cin >> a[i].x;
		a[i].y = a[i].x + d;
	}
	
	sort(a + 1, a + m + 1, cmp);
	
	int l = 0, r = m + 1;
	
	while (l + 1 < r) {
		int mid = (l + r) >> 1;
		if (check(mid) == 1) r = mid;
		else l = mid;
	}
	
	cout << r;
	return 0; 
}
```

完结撒花 ......

---

## 作者：hexz01 (赞：3)

# 题解：P6092 [CEOI2012] 工作规划

## 思路

首先发现随着机器数量的增多，无解会变成有解，就是说它有单调性，所以考虑二分答案。

考虑实现 check 函数。

接着看数据范围，发现时间的值域 $n$ 很小，只有 $10^5$，于是将每天的任务数量计数，第 $i$ 天设为 $cnt_i$，然后在 check 的时候分类讨论：

维护变量 $now,nowcnt$ 表示当前天数和当前天还剩几台机器没用，以及当前任务所在天数 $i$，当前机器数量 $x$。

1. $cnt_i<nowcnt$：直接 ```nowcnt-=cnt_i```。
2. $cnt_i \ge nowcnt$：首先 ```nowcnt=x, now++```，表示推到下一天。然后将剩下的 $cnt_i$ 除以 $x$ 的整数部分**加**到 $now$，余数部分**减**到 $nowcnt$。

考虑判断是否合法，首先在上述过程中，如果 $now>i+d$，则不合法。最后如果 $now>n$ 则不合法。

然而，这样你会获得 50 分。

为什么呢？

因为在 check 函数中，在任务刚好花完 $n$ 天的时候，$now$ 会变为 $n+1$，$nowcnt$ 会变为当前机器数量。此时情况合法，但 $now=n+1$，程序会判断为不合法。

改正的方法呢就是将判断时的 ```now``` 改为 ```now-(nowans==x)```。

然而，你获得了 60 分。

因为在程序中，有时你提前做了后面的任务，改正的方法呢就是让 $now$ 与天数 $i$ 取较大值。

然后，你 AC 了此题。

## AC Code:

``` cpp
#include <iostream>
using namespace std;
const int N=1e5+7;
int n, m, d;
int cnt[N];
bool check(int x){
	int now=1, nowcnt=x;
	for(int i=1;i<=n-d;i++){
		if(i>now)//第二个改进
			now=i, nowcnt=x;
		if(cnt[i]<nowcnt){
			nowcnt-=cnt[i];
			if(now>i+d)
				return 0;
		}else{
			int tmp=cnt[i];
			tmp-=nowcnt;
			now++;nowcnt=x;
			now+=tmp/x;
			nowcnt-=tmp%x;
			if(now-(tmp%x==0)>i+d)//第一个改进
				return 0;
		}
	}
	return (now-(nowcnt==x))<=n;//第一个改进
}
int main(){
	cin>>n>>d>>m;
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		cnt[x]++;
	}
	int l=1, r=m, min1=r+1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			min1=min(min1, mid);
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	cout<<min1<<endl;
	return 0;
}
```

---

## 作者：TheSky233 (赞：3)

## 题解

可以去看看这题的[加强版](https://loj.ac/p/2851)。

首先有答案具有单调性。机器越多显然越有可能在规定期限内完成任务。于是想到二分答案，把问题转化为判定性问题。

我们二分一个 $x$，表示当前的机器数。然后我们模拟加工的过程，每过一天就把当前应该加入的任务加入到队列中。然后贪心一波，越早接受的任务就应该越先完成。

还有个小技巧，我们不关心输入时每个任务的顺序，只关心这一天的任务有多少，于是开个桶 $d$。 每读入一个 $a_i$ 就令 $d_{a_i} \gets d_{a_i}+1$，然后队列长度就从 $m$ 降到了 $n$。总的复杂度为 $\Theta(n \log m)$。

加强版中还需要输出每天加工任务的方案。也很简单，记录每个任务的次序，二分时存储即可。但此时不能用桶记录（因为同一天的元素次序有差异），复杂度降为 $\Theta(m \log m)$。

二分的上界应该是 $m$，因为最坏情况是所有任务都在同一天且 $d=0$。

## 代码

本题（P6092）的 $\Theta(n \log m)$ 代码：

```cpp
bool check(int x){
	int now(0);
	F(i,1,n){
		now=max(now+f[i]-x, 0);
		if(now>x*d) return false;
	}
	return true;
}

void Solve(){
	read(n,d,m);
	F(i,1,m) read(a[i]), f[a[i]]++;
	int l=1, r=m, mid, ans(-1);
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	write(ans);
}
```

以及可以记录方案的 $\Theta(m \log m)$ 代码：

```cpp
bool check(ll X){
	int l=1,r=0,x=X;
	F(i,1,n) b[i]=0;
	for(int R=1; R<=n; R++){
		if(R<=n-d) b[++r]=f[R];
		x=X;
		while(l<=r && x){
			if(b[l]-x<0){
				x-=b[l];
				b[l++]=0;
			}
			else{
				b[l]-=x;
				break;
			}
		}
		while(b[l]==0 && l<=r) l++;
		if(r-l>=d) return false;
	}
	if(b[r]!=0) return false;
	return true;
}

void Solve(){
	read(n,d,m);
	F(i,1,m) read(a[i]), f[a[i]]++;
	ll l=1, r=m, mid, ans(-1);
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	write(ans);
}
/*
10 2 12
7 4 4 6 1 8 8 1 1 6 4 5 
*/
```

---

## 作者：Luisvacson (赞：3)

~~貌似是你谷首A呢，来写一篇题解~~

显然若$x$台机器可以完成所有任务，那么大于$x$台机器也可以，答案具有单调性，所以考虑二分答案

每次二分出来一个mid之后就从头到尾扫一遍检查，能够完成的就当天完成，不能的话就留到下一天

我们可以用队列维护未完成的任务，由于队列的队首一定是最早入队的，所以贪心优先处理队首的任务

时间复杂度$O(mlogm)$，能过

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXV = 1e6 + 5;
int n, d, m;
int a[MAXV];
vector<int> ord[MAXV];//存放每项任务下放的时间
struct node {
    int num;
    int time;
};

bool check(int x)
{
    queue<node> Q;
    register int i;

    int mach;//机器数
    for (i = 1; i <= n; ++i) {
        mach = x;
        while (!Q.empty()) {//处理残余的任务
            node x = Q.front();
            Q.pop();
            int t = x.time;
            if (t + d < i)//来不及完成
                return false;
            --mach;
            if (!mach)//机器数为0
                break;
        }
        if (!Q.empty()) {//可能是机器数不够退出来的，需要再检查
            node x = Q.front();
            if (x.time + d < i)
                return false;
        }

        for (vector<int>::iterator it = ord[i].begin(); it != ord[i].end(); ++it) {
            int v = *it;
            if (mach)//还有机器
                --mach;
            else//将任务留到下一次完成
                Q.push((node) { v, i });
        }
    }

    return true;
}

signed main()
{
    scanf("%d%d%d", &n, &d, &m);
    register int i;

    for (i = 1; i <= m; ++i) {
        scanf("%d", &a[i]);
        ord[a[i]].push_back(i);//a[i]这个任务在第i次出现过
    }

    int l = 1, r = m, mid, ans;
    while (l <= r) {//普通二分
        mid = l + r >> 1;
        if (check(mid)) {
            ans = mid;
            r = mid - 1;
        } else
            l = mid + 1;
    }

    printf("%d\n", ans);
    return 0;
}
```
PS:

貌似原题还要输出方案，那我们就把ans带到check里面用类似的方法跑一边即可

---

## 作者：船酱魔王 (赞：1)

# P6092 [CEOI2012] 工作规划  题解

## 题意回顾

有一个人需要完成 $ m $ 项任务，每项任务的获得时间为 $ a_i $，在 $ a_i+d $ 天是最晚的完成时间，他可以多线程工作。

求他至少开几个线程才能完成所有工作。

## 分析

首先我们发现，他如果能 $ x $ 线程完成工作就一定能 $ x+1 $ 线程完成工作，因此线程是具有单调性的。

我们考虑二分，把最优性问题转化为判定性问题，判定用 $ x $ 个线程能否完成工作。我们发现如果一个更早开始（也更早结束）的工作比另一个工作先做是更优的，因为做更早的工作的最晚时间是比更晚的工作更早到来的，之后更晚的工作被完成的机会多于更早的工作。

每次二分答案时 $ O(n+m) $ 贪心判定，时间复杂度 $ O((n+m) \log n) $，可过。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e6 + 5;
int n, d, m;
int t[N];
bool check(int x) {
    int pos = 1;
    for(int i = 1; i <= n + 1; i++) {
        if(pos > m) {
            return true;
        }
        for(int j = 1; j <= x; j++) {
            if(t[pos] <= i && pos <= m) {
                if(t[pos] + d < i) {
                    return false;
                }
                pos++;
            } else {
                break;
            }
        }
    }
    return false;
}
int main() {
    scanf("%d%d%d", &n, &d, &m);
    for(int i = 1; i <= m; i++) {
        scanf("%d", &t[i]);
    }
    sort(t + 1, t + m + 1);
    int l, r, mid;
    l = -1;
    r = m + 1;
    while(l + 1 < r) {
        mid = (l + r) >> 1;
        if(check(mid)) {
            r = mid;
        } else {
            l = mid;
        }
    }
    printf("%d\n", r);
    return 0;
}
```

## 总结与评价

校内提高模拟赛 T1，教练认为黄题，洛谷评蓝（

当时赛场上一眼就看出来了，AC 率大约在 40% ～ 50% 左右。（毕竟是签到题）

---

## 作者：FreedomKing (赞：1)

二分答案裸题。

### 思路

因为过少的机器无法完成任务，刚好或过多的机器可以完成任务，便得到了二分答案的大前提单调性，依据机器数量的单调性二分即可，主要在于 `check` 上。

由于我们只考虑任务能不能被完成，不考虑它在输入中的顺序，所以直接统计出每天需要完成的任务总数，然后将其尽量完成，剩余的积累到下一天。当积累的任务多到无法在期限内完成就返回 false，否则就是可以完成，返回 true 即可。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e6+5,mN=1e4+5,mod=1e9+7,mmod=998244353;
namespace FreedomKing_qwq{};
using namespace FreedomKing_qwq;
namespace FreedomKing_qwq{
	inline int qread(){
#define qr qread()
		int x=0,c=getchar(),t=1;
		while(c<'0'||c>'9'){
			t^=(c=='-');
			c=getchar();
		}
		while(c>='0'&&c<='9'){
			x=(x<<3)+(x<<1)+c-'0';
			c=getchar();
		}
		return (t?x:-x);
	}
	inline void qwrite(int x){
#define qw(_) qwrite(_)
#define qws(_) qw(_),putchar(' ')
#define qwe(_) qw(_),putchar('\n')
		if(x<0) x=-x,putchar('-');
		if(x>9) qwrite(x/10);
		putchar(x%10+'0');
		return;
	}
	inline int qpow(int x,int p,int mod){
		x=(p?x:1);
		mod=(mod?mod:LONG_LONG_MAX);
		int t=1;
		while(p>1){
			if(p&1) t=(t*x)%mod;
			x=(x*x)%mod;
			p>>=1;
		}
		return (x*t)%mod;
	}
	inline int gcd(int x,int y){return (x%y==0?y:gcd(y,x%y));}
	inline int lcm(int x,int y){x/=gcd(x,y);return (x*y);}
	inline int max(int x,int y){return (x>y?x:y);}
	inline int min(int x,int y){return (x<y?x:y);}
	inline int abs(int x){return (x>0?x:-x);}
}
int a[N],n,m,d;
bool check(int x){
	int now=0;
	for(int i=1;i<=n;i++){
		now=max(now+a[i]-x,0);
		if(now>x*d) return false;
	}
	return true;
}
signed main(){
	n=qr;d=qr;m=qr;
	for(int i=1;i<=m;i++) a[qr]++;
	int l=1,r=1e6;
	while(l<r){
		int mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	qw(l);
	return  0;
}
```

---


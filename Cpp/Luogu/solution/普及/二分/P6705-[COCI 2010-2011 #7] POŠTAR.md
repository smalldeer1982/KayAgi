# [COCI 2010/2011 #7] POŠTAR

## 题目背景

Mirko 在一个山中小镇里得到了一个邮递员的差事。这个小镇可以用一个 $n \times n$ 的矩阵表示。每个区域有三种状态：用 $\texttt{K}$ 表示房屋，用 $\texttt{P}$ 表示邮局或用 $\texttt{.}$ 表示牧场。此外，每个区域被分配一个高度。

每天早晨，Mirko 都给镇上的每户人家送邮件。他从用 $\texttt{P}$ 表示的区域开始。Mirko 只能水平、垂直或斜向移动到相邻的区域。他一旦送完最后一封邮件，就必须返回邮局。

Mirko 不知道他的工作会有多无聊。令 Mirko 在投递邮件时所到的最高处和最低处的高度之差等于他的疲劳度。帮他找出疲劳度最小的方式，让 Mirko 投递所有的邮件。

## 题目描述

给定一个 $n \times n$ 的矩阵。

每个位置可能有 $\texttt{K}$ $\texttt{P}$ $\texttt{.}$ 三种可能状态，此外还有一个高度 $h_{i,j}$。

你需要从状态为 $\texttt{P}$ 的位置开始，水平、垂直或斜向移动，经过所有状态为 $\texttt{K}$ 的位置，最终回到起点。

在这路程中，你需要让经过的位置的 $max_h-min_h$ 最小化。

请你求出最小化的值。

## 说明/提示

#### 样例 1 解释

从邮局开始，Mirko 可以直接移动到房屋，然后再回到邮局。因为这两个区域高度相同，所以 Mirko的疲劳等于  $0$。

#### 数据规模及约定


对于矩阵，其中 $\texttt{P}$ 将正好出现一次，而 $\texttt{K}$ 将至少出现一次。

对于 $100\%$ 的数据 $2 \le n \le 50$

#### 说明

本题满分 $100$ 分。

译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T4 POŠTAR


## 样例 #1

### 输入

```
2
P.
.K
2 1
3 2```

### 输出

```
0```

## 样例 #2

### 输入

```
3
P..
.KK
...
3 2 4
7 4 2
2 3 1```

### 输出

```
2```

## 样例 #3

### 输入

```
3
K.P
...
K.K
3 3 4
9 5 9
8 3 7```

### 输出

```
5```

# 题解

## 作者：苏黎世 (赞：24)

这个题确实不太简单，因为在二分的时候dfs和check的次数惊人。

这个题如果你做出来了，那么说明你的dfs和二分答案已经炉火纯青了。

所以，如果你是想了一会不会写来看题解，希望你看到这里再回去想想，毕竟这个题对你我觉得会很有启发吧。~~（等下，先把点赞留下啊喂！）~~

#### 算法：DFS+二分答案+暴力枚举

我们可以二分从1到当前的的高度。

需要一个方向数组。

还有就是，不要被32MB给吓到，放心去定义吧。

具体看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define rint register int//稍微快一点
const int maxn = 55;
int n, h[maxn][maxn], ji, s, t, ans = 214748364, now;
bool v1[maxn][maxn], v2[maxn][maxn];
//v1存是否是村庄，v2存是否遍历
int d[10][2] = {{0, 0},{1,0}, {0,1}, {-1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};

void dfs(int x, int y, int q, int z)
{
    if (x < 1||x > n|| y < 1 || y > n||v2[x][y]||h[x][y] < q||h[x][y] > z)
      return ;//看看能不能走
    v2[x][y] = 1;
    now += v1[x][y];//若有村加1，没有就加0
    for(rint i = 1;i <= 8; ++i)
      dfs(x + d[i][0], y + d[i][1], q, z);
}

bool check(int mid, int q)
{
	memset(v2, 0, sizeof(v2));//每次都要把v2清空
	
	now = 0;
	dfs(s, t, mid, q);
	
	return now == ji;//看看所有的村庄是否都被遍历过
}

void cini()
{
    cin >> n;
    for(rint i = 1;i <= n; ++i)
        for(rint j = 1;j <= n; ++j)
        {
            char c;
            cin >> c;
            if(c == 'K')
            {
                ++ji;//村庄数量
                v1[i][j] = 1;
            }
            else if(c == 'P')
              s = i, t = j;//起点
        }
    
    for(rint i = 1;i <= n; ++i)
      for(rint j = 1;j <= n; ++j)
          cin >> h[i][j];
}

void work()
{
    int l, r, mid;
    for(rint i = 1;i <= n; ++i)
      for(rint j = 1;j <= n; ++j)
      {
        if(h[i][j] < h[s][t])
          continue;//我们只要比起点高的村
        l = 1; r = h[i][j];
        while(l <= r)
        {
            mid = (l + r) >> 1;
            if(check(mid, h[i][j]))
            {
                ans = min(ans, h[i][j] - mid);
                l = mid + 1;
            }else r= mid - 1;
        }
      }
    printf("%d", ans);
}

int main()
{
    cini();
    work();//这样看起来是否会简洁一点呢
    return 0;
}
```


---

## 作者：_•́へ•́╬_ (赞：14)

### 思路

套路题，枚举最小值，求出最大值，时间复杂度 $O(n^4)$。

正确性：最小值确定，从起点到各个终点的最大值也就确定了，没有更小的最大值，所以正确。

路径：（这个要知道，不然下次变成构造题就不行了）从起点到终点，再从终点返回起点，像这样依次遍历每个终点。本题不管走回头路，这样不影响最大值/最小值。

### $code$

```cpp
#include<algorithm>
#include<stdio.h>
#include<deque>
#define N 50
#define pr pair<int,int> 
using namespace std;
inline char nc()
{
	static char tp[9999],*p1,*p2;
	return p1==p2&&(p2=(p1=tp)+fread(tp,1,9999,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int&x)
{
	register char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int a[N][N],ans[N][N],lsh[N*N],sz;char b[N][N];deque<pr>q;bool inq[N][N];
main()
{
	register int n,dx[8]={1,-1,0,0,1,1,-1,-1},dy[8]={0,0,1,-1,1,-1,1,-1},sx,sy,minn=1<<30,tmp;
	read(n);
	for(register int i=0;i<n;++i)for(register int j=0;j<n;++j)
	{
		for(;b[i][j]=nc(),b[i][j]!='K'&&b[i][j]!='P'&&b[i][j]!='.';);
		if(b[i][j]=='P'){sx=i;sy=j;b[i][j]='.';}
	}//输入
	for(register int i=0;i<n;++i)for(register int j=0;j<n;++j)read(a[i][j]),lsh[sz++]=a[i][j];
	sort(lsh,lsh+sz);sz=unique(lsh,lsh+sz)-lsh;//离散化
	for(register int i=0;i<sz&&lsh[i]<=a[sx][sy];++i)//枚举最小值
	{
		for(register int j=0;j<n;++j)for(register int k=0;k<n;++k)ans[j][k]=1<<30;
		q.push_back((pr){sx,sy});ans[sx][sy]=a[sx][sy];
		for(register int nx,ny;q.size();)//bfs求最大值
		{
			nx=q.front().first;ny=q.front().second;q.pop_front();inq[nx][ny]=0;
			for(register int j=0;j<8;++j)
			{
				if(nx+dx[j]<0||nx+dx[j]>=n||ny+dy[j]<0||ny+dy[j]>=n)continue;
				if(a[nx+dx[j]][ny+dy[j]]<lsh[i])continue;//小于枚举的最小值就不行
				if(ans[nx][ny]<a[nx+dx[j]][ny+dy[j]])//这里把两种情况分开写
				{//即将到达的点是最大值，更新最大值
					if(a[nx+dx[j]][ny+dy[j]]<ans[nx+dx[j]][ny+dy[j]])
					{
						ans[nx+dx[j]][ny+dy[j]]=a[nx+dx[j]][ny+dy[j]];
						if(!inq[nx+dx[j]][ny+dy[j]])
						{
							inq[nx+dx[j]][ny+dy[j]]=0;
							q.push_back((pr){nx+dx[j],ny+dy[j]});
						}
					}
				}
				else//原来的那个是最大值，不更新最大值
                    if(ans[nx][ny]<ans[nx+dx[j]][ny+dy[j]])
					{
						ans[nx+dx[j]][ny+dy[j]]=ans[nx][ny];
						if(!inq[nx+dx[j]][ny+dy[j]])
						{
							inq[nx+dx[j]][ny+dy[j]]=0;
							q.push_front((pr){nx+dx[j],ny+dy[j]});
						}
					}
			}
		}
		tmp=0;
		for(register int j=0;j<n;++j)for(register int k=0;k<n;++k)if(b[j][k]=='K')
			if(tmp<ans[j][k])tmp=ans[j][k];//统计最大值
		if(minn>tmp-lsh[i])minn=tmp-lsh[i];//更新答案
	}
	printf("%d",minn);//输出
}
```



---

## 作者：asasas (赞：5)

这道题不怎么好想，也不怎么好写。

这题是求从起点出发，找到一条路径，既能吃掉所有松果，又能使这条路径上**最大值**与**最小值的差最小**。

首先，先思考一下：如果只求**最小值最大**，我们应该怎么做？答案当然是**二分答案**

但这题还有一个问题：最大值不知道啊？

既然不知道，那**暴力枚举**不就行了吗？

于是这题的算法出来了：**暴力枚举+DFS+二分答案**

深搜是很平常的深搜，二分答案的check就是判断深搜时，最小值和最大值是否符合要求即可。

tips:

① 枚举最大值值时，要从起点的高度开始枚举，如果最小值比起点高度还低，那显然这条路径的最小值就不是你枚举的高度。

② 0注意这题深搜要从8个方向搜，别写少了。

代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1005][1005],v[1005][1005],m,v2[1005][1005],now,xx,yy;
int fx[10]={0,0,0,1,1,1,-1,-1,-1};
int fy[10]={0,1,-1,1,0,-1,1,0,-1};   
int n;
void dfs(int x,int y,int l,int r){
	if (x<1||x>n||y<1||y>n||v2[x][y]||a[x][y]<l||a[x][y]>r) return ;//判断有没有出界，这个点有没有走过，以及当前的最大值和最小值是不是在要求以内
	v2[x][y]=1;//走过了
	now+=v[x][y];//松果个数，注意要开全局，下面要用
	for (register int i=1;i<=8;i++) dfs(x+fx[i],y+fy[i],l,r);//深搜
}
inline bool check(int r,int mid){
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++) v2[i][j]=0;//初始化
	now=0;
	dfs(xx,yy,mid,r);
	return now==m;//如果吃掉了所有松果，这种情况就是可行的
}
int main(){
   cin >> n;
   for (register int i=1;i<=n;i++){
   	  for (register int j=1;j<=n;j++){
   	  	  char qwq;
   	  	  cin >> qwq;
   	  	  if (qwq=='P') xx=i,yy=j;//起点
   	  	  else if (qwq=='K') m++,v[i][j]=1;//如果是松果，这个位置就标记为有松果，松果的个数就+1
   	  }
   }
   for (register int i=1;i<=n;i++){
   	  for (register int j=1;j<=n;j++){
   	  	  cin >> a[i][j];
   	  }
   }
   int ans=1<<30;
   int l,r;
   for (register int i=1;i<=n;i++){
   	  for (register int j=1;j<=n;j++){
   		if (a[i][j]<a[xx][yy]) continue;//如果这个点的高度比起点高度低，就跳过
   		   int l=1,r=a[i][j];
   		   while(l<=r){
   		   	int mid=l+r>>1;
   		   	if (check(a[i][j],mid)){
   		   		ans=min(ans,a[i][j]-mid);//ans取差的小值
   		   		l=mid+1;
   		   	}
   		   	else r=mid-1;//二分答案模板
   		   }
     	}
   }
   cout << ans;
   return 0;
}
```
此代码需要开O2，如果想更快，就在DFS里加上记搜，这里就不展示代码了，也是给大家思考的一个问题。

---

## 作者：zbk233 (赞：3)

# 解题思路：

暴力枚举+二分答案+深搜。

用两层循环表示要找到的最大值，用二分答案表示要找到的最小值。

之后用深搜判断最小值与最大值是否可以取，然后用一个变量表示最大值减去最小值的最小值即可。


```cpp
#include <cmath>
#include <cstring>
#include <iostream>
#define ll long long
using namespace std;
ll a[55][55];
bool vis[55][55];
bool jg[55][55];
char ch;
ll dx[] = {0, 0, -1, 1, 1, -1, 1, -1};
ll dy[] = {1, -1, 0, 0, 1, -1, -1, 1};
ll n, mina, maxa, sx, sy, len1, ans = 0x7FFFFFFF, mid, sum;
void dfs(ll x, ll y, ll maxx)
{ //判断最小值与最大值是否可以取
	if (x < 1 || x > n || y < 1 || y > n || vis[x][y] || a[x][y] < mid || a[x][y] > maxx)
		return;
	vis[x][y] = 1;
	sum += jg[x][y];
	for (ll i = 0; i < 8; i++)
	{
		dfs(x + dx[i], y + dy[i], maxx);
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (ll i = 1; i <= n; i++)
	{
		for (ll j = 1; j <= n; j++)
		{
			cin >> ch;
			if (ch == 'P')
			{ //保存起点的位置
				sx = i;
				sy = j;
			}
			if (ch == 'K')
			{ //保存每户人家的位置
				jg[i][j] = 1;
				len1++;
			}
		}
	}
	for (ll i = 1; i <= n; i++)
	{
		for (ll j = 1; j <= n; j++)
		{
			cin >> a[i][j];
		}
	}
	for (ll i = 1; i <= n; i++)
	{
		for (ll j = 1; j <= n; j++)
		{
			if (a[i][j] < a[sx][sy])
			{
				continue;
			}
			ll l = 1, r = a[i][j];
			while (l <= r)
			{ //枚举最小值
				mid = (l + r) >> 1;
				memset(vis, 0, sizeof(vis));
				sum = jg[sx][sy];
				dfs(sx, sy, a[i][j]);
				if (sum == len1)
				{
					ans = min(ans, a[i][j] - mid);
					l = mid + 1;
				}
				else
				{
					r = mid - 1;
				}
			}
		}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：Demoe (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P6705)

~~一血 搬题+翻译者填坑~~

## 题意

- 给定一个矩阵，每个点有一权值。

- 给定初始点与特殊点，可以从初始点八方向走。

- 问经过所有特殊点时，走过的最大高度减最小高度的最小值。

## Sol

看到 $n \le 50$ ，时限 $4s$ ，感觉 $O(n^5)$ 常数较好者能过。

如果暴力枚举最大值与最小值，再暴力跑图判断，则使复杂度成 $O(n^6)$。

显然这样过不了。/kel

Q：直接枚举答案行不行呢？

A：不行，不确定确切最大最小，无法直接跑图。

那么肯定还是要**枚举一个最大值或最小值**。这个选最大还是最小啊，因人而异。

~~我写的是最小值。~~

这样再加上跑图的复杂度，你就已经有 $O(n^4)$ 的复杂度了。

如何在 $O(n)$ 以内的时间计算答案呢？

我们选择**二分最大值**。

最大值可能个数有 $n^2$ 个，二分复杂度即为 $O(\log_2n^2) \to O(2\log_2n)$

既然有了最大最小值，那么每次遍历跑图即可。

删去常数后 复杂度 $O(n^4 \log_2 n)$。

可以跑过此题。（有点慢）

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=55;
ll n,hs,h[N][N],a[N*N],vst[N][N],kx,ky,ans=0x3f3f3f3f,dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,-1,-1,-1,0,1,1,1};
char s[N][N];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')fl=-fl;
	for(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0)x=-x,putchar('-');
	if(x<10)putchar(x+'0');
	if(x>9)wr(x/10),putchar(x%10+'0');
}
void dfs(ll x,ll y,ll hl,ll hr){
	if(vst[x][y]) return;
	vst[x][y]=1;
	for(ll i=0;i<8;i++){
		if(x+dx[i]<0||x+dx[i]>=n||y+dy[i]<0||y+dy[i]>=n||h[x+dx[i]][y+dy[i]]<hl||h[x+dx[i]][y+dy[i]]>hr) continue;
		dfs(x+dx[i],y+dy[i],hl,hr);
	}
}
bool ok(ll hl,ll hr){
	memset(vst,0,sizeof(vst));
	if(h[kx][ky]<hl||h[kx][ky]>hr) return 0;
	dfs(kx,ky,hl,hr);
	for(ll i=0;i<n;i++)
		for(ll j=0;j<n;j++)
			if(s[i][j]=='K'&&!vst[i][j]) return 0;
	return 1;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);
	for(ll i=0;i<n;i++){
		scanf("%s",s[i]);
		for(ll j=0;j<n;j++) if(s[i][j]=='P') kx=i,ky=j;
	}
	for(ll i=0;i<n;i++)
		for(ll j=0;j<n;j++){rd(h[i][j]);a[hs++]=h[i][j];}
	sort(a,a+hs);
	hs=unique(a,a+hs)-a;
	for(ll i=0;i<hs;i++){
		ll l=i,r=hs-1;
		while(l<=r){
			ll mid=l+((r-l)>>1);
			if(ok(a[i],a[mid])) r=mid-1;
			else l=mid+1;
		}
		if(ok(a[i],a[l])) ans=min(ans,a[l]-a[i]);
	}
	wr(ans);puts("");
	return 0;
}
```

#### UPD 更新了复杂度

---

## 作者：JK_LOVER (赞：3)

## 题意
求出包含 $k$ 个关键点的所有联通块中最小化 $\max_h-\min_h$ 。 [QWQ](https://www.luogu.com.cn/blog/xzc/solution-p6705)
## 分析
先说 $n$ 是非常小的 $n\le50$ 。如果我们固定 $\max$ 或者 $\min$ ，那么这道题就转化为了一个求最大值最下或者最小值最大的题。而一般对于这种题的处理都是二分。

- 那么现在的方法就是枚举最值，然后二分，再跑 $dfs$ 求出联通块。那么时间复杂度为 $O(n^2\times w\log w)$ ，$w$ 为权值值域。如果你没思索
~~（像我一样）~~
打出了代码，那么就直接 $TLE$ ，实测 $12$ 分。

- 考虑是哪里时间复杂度高了，其实我们二分的端点只有可能在出现过的高度中选择，那么现在二分的范围就就只有 $n^2$ 级别的了。总的复杂度为 $O(n^4\log n)$ 了。可以通过。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 55;
struct Edge{int x,y,w;}e[N*N<<2];
bool cmp(Edge a,Edge b){return a.w<b.w;}
int n,Px,Py,h[N*N],vis[N][N],top,S,Min=0x3f3f3f3f,Max = 0;
char Map[N][N];
vector<int> H;
int id(int x,int y){
	return x*n+y;
}
int dx[8]={1,1,1,0,0,-1,-1,-1},dy[8]={0,-1,1,1,-1,0,1,-1},ans = 0x3f3f3f3f;
int dfs(int x,int y,int L,int R)
{
	if(h[id(x,y)]>R||h[id(x,y)]<L||x>=n||y>=n||x<0||y<0||vis[x][y]) return 0;
	int W = Map[x][y] == 'K';vis[x][y]=1;
	for(int k = 0;k < 8;k++){
		int X = x+dx[k],Y = y+dy[k];
		W += dfs(X,Y,L,R);
	}
	return W;
}
void solve(){
	for(int limit = 0;limit < H.size();++limit)
	{
		int L = limit,R = H.size()-1,Ans = 0x3f3f3f3f;
        //其实这里用不定长数组，最好不要-1，这很危险应为H.size()的类型为unsigned 。大家千万不要学我。
		while(L <= R){
			int mid = L + R >> 1;
			memset(vis,0,sizeof(vis));
			if(dfs(Px,Py,H[limit],H[mid]) == S) {
//				cout<<mid<<" "<<limit<<" S: "<<S<<endl;
				Ans = min(Ans,H[mid]-H[limit]);
				R = mid - 1;
			}
			else L = mid + 1;
		}
		ans = min(Ans,ans);
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) {
		cin>>Map[i][j];if(Map[i][j]=='P') Px = i,Py = j;
		if(Map[i][j]=='K') S++;
	}
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) {
		cin>>h[id(i,j)];H.push_back(h[id(i,j)]);
	}
	sort(H.begin(),H.end());
	solve();
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Xiphi (赞：1)

模拟赛 T1。感觉是板子题。考虑枚举 $H_{max}$，然后显然满足条件的 $H_{min}$ 必然是有单调性的。考虑二分 $H_{min}$。

然后考虑如何 check，考虑并查集或者 bfs。笔者采用的是相对较慢的并查集。把上下左右斜线的点两两连边，最后判断所有的起始点和邮局是否连通即可，复杂度 $O(n^4 \log n^2 α(n))$，可在 $4$ 秒内卡过。更快的方法显然就是双指针加 bfs 判断，复杂度 $O(n^4)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _for(i,x,y) for(int i=x;i<=y;++i)
#define int long long
int n,fa[2505],a[55][55];char c[55][55];
vector<int> v,pos;
void build(){
	for(int i=1;i<=n*n;++i) fa[i]=i;
}
int Get(int x,int y){
	return (x-1)*(n)+y;
}
int find(int x){
	return (fa[x]==x?x:fa[x]=find(fa[x]));
}
void merge(int x,int y){
	fa[find(x)]=find(y);
}
int dx[]={1,0,-1,0,1,1,-1,-1},
	dy[]={0,1,0,-1,1,-1,1,-1};
bool check(int L,int R){
	build();
	_for(i,1,n){
		_for(j,1,n){
			_for(k,0,7){
			if(L<=a[i][j]&&a[i][j]<=R&&L<=a[i+dx[k]][j+dy[k]]&&a[i+dx[k]][j+dy[k]]<=R){
				merge(Get(i,j),Get(i+dx[k],j+dy[k]));
			}
			}
		}
	}
	int X=find(pos[0]);
	_for(i,1,pos.size()-1){
		if(find(pos[i])!=X) return 0;
	}
	return 1;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			cin>>c[i][j];
			if(c[i][j]=='P'||c[i][j]=='K') pos.push_back(Get(i,j));
		}
	}
	memset(a,0x3f,sizeof a);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j) cin>>a[i][j],v.push_back(a[i][j]);
	}
	sort(v.begin(),v.end(),greater<int>());
	int cnl=0,ans=1e18;
	int r=-1;
	for(int i=0;i<v.size();++i){
		int l=i,aa=0,r=v.size()-1;
		while(l<=r){
			int mid=l+r>>1;
			if(check(v[mid],v[i])) r=mid-1,ans=min(ans,v[i]-v[mid]);
			else l=mid+1;
		}
//		while((r<(int)(v.size()-1))&&check(v[r+1],v[i])==0) r++;
//		if((r<(int)(v.size()-1))) r++;
//		if(check(v[r],v[i])) ans=min(ans,v[i]-v[r]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：1)

此题不简单呀，应该能评绿了。

直接爆搜肯定不行的，会超时。

我们可以在搜索中限定一个界再搜索师傅就会大大降低。

于是我们可以 4 层循环直接枚举界定高度 $max_h$ 与 $min_h$，每次 dfs 时我们可以直接统计能不能到达所有房屋。

也就是说，路径里不能存在 `h[x][y]>ax_h` 与 `h[x][y]<min_h`。

爆搜代码。
```cpp
int dfs(int x,int y,int l,int r){//在min_h=l,max_h=r的地方搜索
	int sum=(a[x][y]=='K');
	for(int i=0;i<8;i++){
		int tx=x+d[i][0],ty=y+d[i][1];
		if(tx<=0 || ty<=0 || tx>n || ty>n) continue;
		if(h[tx][ty]<l || h[tx][ty]>r) continue;
		if(vis[tx][ty]) continue;
		vis[tx][ty]=1;
		sum+=dfs(tx,ty,l,r);
	}
	return sum;
}
```

枚举+爆搜的时间复杂度为 $O(n^6)$，过不了。

我们可以先枚举最大值。

然后我们来看下最小值有什么特点。

我们发现，在最大值一定的情况下，最小值越小，越能遍历到更多的格子，最小值越大，会遍历到越来越少的格子。

能遍历到的格子数具有单调性。

能遍历到的房屋也具有单调性。

于是我们可以枚举最大值，二分最小值。

当然也可以枚举最小值，二分最大值。

为什么最大值先二分，二分最小值来判断呢？

因为条件是在最大值一定的时最小值才具有单调性，反过来也同理，而第二层二分就破坏了这个性质。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char a[110][110];
int h[110][110];
int p=0;
int d[8][2]={{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{1,1},{-1,1},{1,-1}};
bool vis[110][110];
int dfs(int x,int y,int l,int r){
	int sum=(a[x][y]=='K');
	for(int i=0;i<8;i++){
		int tx=x+d[i][0],ty=y+d[i][1];
		if(tx<=0 || ty<=0 || tx>n || ty>n) continue;
		if(h[tx][ty]<l || h[tx][ty]>r) continue;
		if(vis[tx][ty]) continue;
		vis[tx][ty]=1;
		sum+=dfs(tx,ty,l,r);
	}
	return sum;
}
int sx,sy;
bool check(int l,int r){
	memset(vis,0,sizeof vis);
	int q=dfs(sx,sy,l,r);
	return q==p;
}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			if(a[i][j]=='K') p++;
			if(a[i][j]=='P') sx=i,sy=j;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&h[i][j]);
	int ans=2e9;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(h[i][j]<h[sx][sy]) continue;
			int l=0,r=h[sx][sy],cnt=2e9,mid=0;
			while(l<=r)
				if(check(mid=l+r>>1,h[i][j])) l=mid+1,cnt=h[i][j]-mid;
				else r=mid-1;
			ans=min(ans,cnt);
		}
	cout<<ans;
	return 0;
} 
```

---

## 作者：杨岛主杨东润 (赞：0)

## P6705题解
### 具体思路：
这道题，我们的具体思路是dfs每一位，然后判断城镇和村庄，接下来就可以了！

具体方法就是先输入，

接着，我们对每一位进行一下dfs，接着对每一位进行判断，对于每一次我们计算是否是最小值。

最后，当我们算出来的时候，输出最小值就可以啦！

### 代码实现：
不要抄袭哦！

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n,a[106][106],s,t;//数组和变量 
int sum,cnt;
int b[106][106],c[106][106];
//下面是方位数组 
int d[10][2]={{0, 0},{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};
void dfs(int x,int y,int p,int t){// dfs函数 
    if(x<1||x>n||y<1||y>n||b[x][y]||a[x][y]<p||a[x][y]>t){//如果不行，就返回 
      	return;
    }
    c[x][y]=1;
    sum+=b[x][y];
    for(int i=1;i<=8;i++){//枚举每一位 
    	dfs(x+d[i][0],y+d[i][1],p,t);
    }
}
bool check(int mid,int q){//确认是否可用 
	memset(c,0,sizeof(c));
	sum=0;//清零 
	dfs(s,t,mid,q);
	return sum==cnt;
}
int main()
{
	cin>>n;//输入 
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            char c;
            cin>>c;
            if(c=='K'){//判断是什么 
                cnt++;
                b[i][j]=1;
            }else if(c=='P'){//如果是p，就... 
              	s=i;
			  	t=j;
			}
        }
    }
    for(int i=1;i<=n;i++){
      	for(int j=1;j<=n;j++){
          	cin>>a[i][j];
        }
    }
    int l,r,mid;
    int minn=0xfffffff;//最小值 
    for(int i=1;i<=n;i++){
      	for(int j=1;j<=n;j++){
        	if(a[i][j]<a[s][t]){
        		continue;
      		}
        	l=1;
			r=a[i][j];
	        while(l<=r){
	            mid=(l+r)>>1;//左移一位 (二分) 
	            if(check(mid,a[i][j])){//继续检查 
	                minn=min(minn,a[i][j]-mid);
	                l=mid+1;//队头++ 
	            }else{
					r=mid-1;//队尾-- 
				}
	        }
      	}
    }
    while(1){
    	cout<<"no ctj!";//禁止抄袭  
	}
    cout<<minn;//输出 
    return 0;
}
```

---


# [COCI 2018/2019 #1] Cipele

## 题目描述

在各种各样的项目上消耗经费之后，Nadan 决定为软件开发者提供高质量的鞋子。

Nadan 在地下室找到了 $N$ 只左脚鞋和 $M$ 只右脚鞋。因为它们的来源未知，因此鞋子的大小也不尽相同。

Nadan 想让你配对尽可能多的鞋子（即在所有鞋子配对完毕后不能继续配对）。每一对应当包含一只左脚鞋和一只右脚鞋。当穿上一双鞋时，应当使得鞋子的丑陋度最小化。一双鞋子的丑陋度定义为：所有配对的鞋子中，左脚和右脚大小之差的绝对值的最大值。

## 说明/提示

#### 样例 2 解释

Nadan 的左脚鞋有 $4$ 只，右脚鞋有 $3$ 只，最多可以配成 $3$ 对。一种配对方式为：**39-46**，41-42，45-39，第一双的两只鞋大小之差的绝对值最大，因而丑陋度为 $7$。

一种更好的配对方式为：39-39，41-42，45-46。该配对方式的丑陋度为 $1$，为所有配对方式中，丑陋度最小的。

#### 数据规模与约定

对于 $20\%$ 的数据，$N=M$。

对于另外 $50\%$ 的数据，$N,M \le 5000$。

对于 $100\%$ 的数据，$1 \le N,M \le 10^5$，$1 \le L_i,R_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $90$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #1](https://hsin.hr/coci/archive/2018_2019/contest1_tasks.pdf)  _T3 Cipele_。**

## 样例 #1

### 输入

```
2 3
2 3
1 2 3```

### 输出

```
0```

## 样例 #2

### 输入

```
4 3
2 39 41 45
39 42 46```

### 输出

```
1```

## 样例 #3

### 输入

```
5 5
7 6 1 2 10
9 11 6 3 12```

### 输出

```
4```

# 题解

## 作者：yeshubo_qwq (赞：12)

## [题面](https://www.luogu.com.cn/problem/P7305)  

------------
## Part1  
不难发现，此题的最小丑陋值（即答案）具有**单调性**，因此我们可以使用**二分答案**通过此题。

既然使用二分，我们首先要做的就是**确定边界**：我们假设左鞋和右鞋各自有一只，分别为 $1$ 和 $1000000000$，它们的丑陋值是 $999999999$，即二分的**上限**；我们再假设左鞋和右鞋各自同样有一只，分别为 $1$ 和 $1$，它们的丑陋值是 $0$，即二分的**下限**。

接着套上二分模板。
### Code
```cpp
l=0;r=1e9;
while(l<r){
    mid=(l+r-1)/2;
    if(check(mid))r=mid;
    else l=mid+1;
}
```

------------
## Part2 
有了二分的边界，就只剩下二分的判定了。

这里我用了**双指针+贪心**来实现。

先求出哪种鞋子少，用并进行标记，左鞋标 $1$，右鞋标 $0$。

再给左、右鞋子各自从小到大排序（**贪心思想**）。

接着就可以用双指针了，**分成2类**：

      第1类：左鞋和右鞋指针指向的一双鞋符合条件（不超过要判断的数），左鞋和右鞋指针同时加一，组成的鞋子数量加一；  
  	  第2类：左鞋和右鞋指针指向的一双鞋不符合条件（超过要判断的数）指向鞋子数量多的指针加一； 
    
最后判断组成的鞋子数是否达到要求即可。
### Code
```cpp
bool check(int x){
    int t=1,w=1,s=0;
    while(t<=n&&w<=m)
        if(abs(a[t]-b[w])<=x)t++,w++,s++;
        else if(flag)w++;//flag为标记
            else t++;
	return s==cnt;//cnt为要求的鞋子数
}
```
------------
## 最后贴上完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,flag,i,a[100010],b[100010],l,r,mid;
bool check(int x){
    int t=1,w=1,s=0;
    while(t<=n&&w<=m)//双指针
        if(abs(a[t]-b[w])<=x)t++,w++,s++;
        else if(flag)w++;
            else t++;
    return s==cnt;
}
int main(){
    scanf("%d%d",&n,&m);
    cnt=min(n,m);//求出要求达到鞋子数
    if(cnt==n)flag=1;//进行标记
    else flag=0;
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    for(i=1;i<=m;i++)scanf("%d",&b[i]);
    sort(a+1,a+1+n);sort(b+1,b+1+m);//贪心
    l=0;r=1e9;
    while(l<r){//二分
        mid=(l+r-1)/2;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    printf("%d",r);
}
```
~~求过~~

---

## 作者：Reset_vod (赞：6)

这一道题是典型的二分答案题，因为符合单调性，求的数也符合二分答案的特征：**求最小的最大值**。

通过思考，我们知道了：这道题可以使用二分算法，那么就衍生出了一个问题：二分什么？

仔细阅读题目，发现“求出所有对的最大差的最小值”这一句话，那么我们就可以二分这个最小值。

既然要配对，那就少不了双指针。

两个指针 $i,j$ 代表两个数据。

一开始两个指针在每个数据的开头，也就是两个指针都为 $1$，然后看两个指针代表的数据的相差值有没有大于二分的最小值，如果没有，那么就说明配对成功，两个指针都往后找更大的数据，如果有，那么就把所代表的数据更小的指针往后找，因为如果大的往后找，找到的就是更大的，肯定也匹配不上。

最后看匹配数等不等于数据量的最小值，因为原题目里有：“一定要匹配到不能匹配为止”的限制。

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[100005],b[100005];
bool XXX(long long x)
{
	long long s=0;
	for(int i=1,j=1;i<=n && j<=m;)
	{
		if(abs(a[i]-b[j])<=x) i++,j++,s++;
		else 
		if(a[i]>b[j]) j++;
		else i++;
	}
	return s==min(n,m);
}
int main()
{
   cin>>n>>m;
   for(int i=1;i<=n;i++) 
   		cin>>a[i];
   for(int i=1;i<=m;i++) 
  		cin>>b[i];
   sort(a+1,a+1+n),sort(b+1,b+1+m);
   long long start=0,finish=1e10,mid;
   while(start+1<finish)
   {
   		mid=(start+finish)/2;
   		if(XXX(mid)) finish=mid;
   		else start=mid;
   }
   if(XXX(0)) finish=0;
   cout<<finish;
   return 0;
}
```

---

## 作者：SUNCHAOYI (赞：2)

这是一道练习二分的不错的题目。因为每组数据的答案的范围都可以被算出来，所以就可以对答案进行二分然后判断该答案是否合法即可，这样时间复杂度也会降到 $\log$ 级别，所以不会超时。

先来看看如何求答案的范围。为了方便程序的计算，以下**保证** $n \le m$ (若出现 $n >m$ 的情况，则输入完毕后将 $n,m$ 以及 $L_i,R_i$ 进行交换)。对于所有左脚鞋 $L_i$ 都有一个右脚鞋 $R_i$ 满足 $L_i = R_i$ 的情况，则最小的答案为 $0$；将左右脚鞋子分别进行排序，由题对丑陋度的定义可知，最大的答案为 $\min (|L[1] - R[m]|,|R[1] - L[n]|)$。

得知范围后，接下来就是对答案的二分了。二分目的是要找到一个最小的合法答案，因此要写成 `r = mid` 与 `l = mid + 1`。

```cpp
while (l < r)
{
	int mid = (l + r) >> 1;
	if (check (mid)) r = mid;
	else l = mid + 1;
}
```

那么如何判断解是否合法呢？设当前的待判断的答案为 $num$，**用数量较少的鞋子去匹配数量较多的鞋子**(由于前文规定了 $n < m$，也就是用左脚鞋去匹配右脚鞋)，利用**贪心**的思想，对于每一只已经从小到大排好的左脚鞋，要找到一只右脚鞋满足 $|L_i - R_j| \le num$ 后再去匹配下一只左脚鞋。若在左脚鞋满足在范围内全部成功与右脚鞋匹配的情况，则答案合法，否则不合法。

```cpp
bool check (int num)//to check whether the answer is correct or not 
{
	int cnt = 1;
	for (int i = 1;i <= n;++i)
	{
		while (cnt <= m && abs (a[i] - b[cnt]) > num) ++cnt;//plus cnt until find a correct answer
		if (cnt > m) return 0; 
		++cnt;//find it
	}
	return 1;
}
```

最后退出循环 `while (l < r)` 后得到的 $l$ 就是答案啦！

---

## 作者：WaterSky (赞：1)

## 第一部分：简易题目。

给两组数据配对，求出所有对的最大差的最小值。


## 第二部分：思考思路。

第一步：看特点。可以很清楚的看出特点为有单调性和求最小的最大值。

第二步：思考算法，从特点可以很清晰的看出，二分答案算法最符合这个特点。


## 第三部分：二分讲解。

这一道题是典型的二分答案题，那么什么是二分答案呢？

举一个简单的“栗子”： 平时找书，如果要一个一个找，很费时间，所以为了优化时间，可以经过一下操作迅速找到：

----
1：找出一个区间的中间值。

2：如果这个中间的值等于目标值，那么退出。

3：判断这个中间值是否比目标值大，是则把左侧边界值换成这个中间值，否则把右侧边界换成这个中间值。

4：重新回到 操作 1。

-------

上面的步骤就是：“二分查找”，而“二分答案”就只需要把 操作 3 的判断条件修改就行了。

## 第四部分：具体思考。

### 1.二分。
通过第二部分的思考，我们知道了：这道题可以使用二分算法，那么就衍生出了一个问题： 二分什么？

返回题目，找到"求出所有对的最大差的最小值"这一句，那么我们就可以二分这个最小值。

然后一定一定要记得从小到大排序。
```
long long start=0,finish=1e9,mid; //定义变量。
while(start+1<finish)
{
  	mid=(start+finish)/2;//找中间值。
   if(...) finish=mid;//判断，区间边缘修改。
   else start=mid;//否则，区间边缘修改。
}
```

### 2.判断。

首先，明确一件事，就是判断部分就是看二分的最小值成不成立。

判断成不成立，就不需要看是不是最优。 

---
既然要配对，那就少不了双指针。两个指针  $(i,j)$  代表两个数据。一开始两个指针在每个数据的开头，也就是两个指针都为 1，然后看两个指针代表的数据的相差值有没有大于二分的最小值，如果没有，那么就说明配对成功，两个指针都往后找更大的数据，如果有，那么就把所代表的数据更小的指针往后找，因为如果大的往后找，找到的就是更大的，肯定也匹配不上。最后看匹配数等不等于数据量的最小值，因为原题目里有:"一定要匹配到不能匹配为止"的限制。

```
long long s=0;
for(int i=1,j=1;i<=n && j<=m;)
{
	if(abs(a[i]-b[j])<=x) i++,j++,s++;//可以就两个都往后找。
	else 
	if(a[i]>b[j]) j++;//更小的往后找。
	else i++;
}
return s==min(n,m);
```
----------
提醒：建议自己写完代码再看我的代码。


## 第五部分：代码。
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[100005],b[100005];
bool pd(long long x)
{
	long long s=0;
	for(int i=1,j=1;i<=n && j<=m;)
	{
		if(abs(a[i]-b[j])<=x) i++,j++,s++;
		else 
		if(a[i]>b[j]) j++;
		else i++;
	}
	return s==min(n,m);
}
int main()
{
   cin>>n>>m;
   for(int i=1;i<=n;i++) cin>>a[i];
   for(int i=1;i<=m;i++) cin>>b[i];
   sort(a+1,a+1+n),sort(b+1,b+1+m);
   long long start=0,finish=1e9,mid;
   while(start+1<finish)
   {
   		mid=(start+finish)/2;
   		if(pd(mid)) finish=mid;
   		else start=mid;
   }
   if(pd(0)) finish=0;
   cout<<finish;
   return 0;
}
```

如果不通过，恳求管理员一次性把问题说完。

---

## 作者：MlKE (赞：1)

主要是对第一篇题解的补充

使最大值最小且答案明显具有单调性，考虑二分。

在答案的值域上二分，每次检查是否满足条件，是则进入左区间，否则进入右区间。

考虑 `check` 函数写法，首先升序排序 $L[i], R[i]$，然后双指针扫描，如下所示：

```cpp
bool check(int x)
{
    int p = 1, q = 1, cnt = 0;
    while (p <= n && q <= m)
        if (abs(L[p] - R[q]) <= x)
            p++, q++, cnt++;
        else if (n > m) p++;
        else q++;
    return cnt == len;
}
```

正确性：

证明`L` 配对的 `R` 一定单调，即一定是最优匹配。

$L: \dots a\ b\dots$

$R:\dots c\ d\ e\dots (1\le a\le b, 1\le c\le d\le e)$

设 $a$ 与 $d$ 配对，即已知 $|a - d|\le x\ and\ |a - c|>x$，需要证明$|b - c|>x$

只有两种情况使得上述情况成立。

1. $c\le a\le d, a\le b$
2. $c\le d\le a, a\le b$

显然这两种情况都有 $|b - c| > x$

QED.

---

## 作者：_JF_ (赞：1)

## [COCI2018-2019#1] Cipele 

独立完成。

二分答案典题。

因为具有“最大值最小”这样明显的提示性词语，很容易想到二分答案，也就是二分丑陋度。

我们二分的丑陋度 $x$，就是对于这个序列来说，他的丑陋度的最大值不可以超过这个 $x$，看能不能成功。

我们先对这两个序列排序，然后对于 $a_i$，找到第一符合条件的数 $b_j$，因为序列是有序的，后面的 $a_k$ 必然比现在的 $a_i$ 大，所以和 $b_j$ 以前的数做差也一定不会符合条件。因为 $a_i$ 和他们做差已经不符合了，往后这个差值只会更大。所以下一次直接从 $j+1$ 开始寻找就好了，时间为 $O(n)$。

最后注意我们默认要从数量少的那个序列在数量多的序列里面找。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
#define int long long
int b[N],a[N],n,m;
bool check(int x){
	int p=1;
	for(int i=1;i<=n;i++){
		if(p>m)	return false;
		while(abs(a[i]-b[p])>x){
			if(i<n&&p>m)	return false;
			p++;
		}
		if(p>m)	return false;
		p++;
	}
	return true;
}
void Find(){
	int l=0,r=1e10;
	while(l<r){
		int mid=(l+r)>>1;
		if(check(mid))	r=mid;
		else	l=mid+1;
	}
	cout<<r<<endl;
	return ;
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)	cin>>a[i];
	for(int i=1;i<=m;i++)	cin>>b[i];
	if(n>m){
		for(int i=1;i<=n;i++)	swap(a[i],b[i]);
		swap(n,m);
	}
	sort(a+1,a+n+1),sort(b+1,b+m+1);
	Find();
	return 0;
}

```


---


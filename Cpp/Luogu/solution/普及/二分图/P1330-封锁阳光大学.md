# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# 题解

## 作者：KesdiaelKen (赞：448)

这一题是一个好题。如果知道思路了，便会非常简单。但是如果不知道思路，却比较的难想出来。

我们来分析一下题目。首先，肯定要明确一点，那就是这个图是不一定联通的。于是，我们就可以将整张图切分成许多分开的连同子图来处理。然而最重要的事情是：如何处理一个连通图？

乍看下去，似乎无从下手，因为方案好像有很多种，根本就枚举不完。但是，关键要注意到题目中重要的两个条件，我们把它抽象成这两个要素：

##①每一条边所连接的点中，至少要有一个被选中。②每一条边所连接的两个点，不能被同时选中。由此，可以推断出：

#每一条边都有且仅有一个被它所连接的点被选中。

又因为我们要处理的是一个连通图。所以，对于这一个图的点的选法，可以考虑到相邻的点染成不同的颜色。

#于是，对于一个连通图，要不就只有两种选法（因为可以全部选染成一种色的，也可以全部选染成另一种色的），要不就是impossible！

所以，我们只需要找到每一个子连通图，对它进行黑白染色，然后取两种染色中的最小值，然后最后汇总，就可以了。

另外，要判断impossible，只需要加一个used数组，记录已经遍历了哪些点。如果重复遍历一个点，且与上一次的颜色不同，则必然是impossible的。

具体细节请见代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<string>
#include<string>
#include<algorithm>
using namespace std;
struct Edge
{
    int t;
    int nexty;
}edge[200000];
int head[20000];
int cnt=0;//链式前向星
void add(int a,int b)//存边
{
    cnt++;
    edge[cnt].t=b;
    edge[cnt].nexty=head[a];
    head[a]=cnt;
}
bool used[20000]={0};//是否遍历过
int col[20000]={0};//每一个点的染色
int sum[2];//黑白两种染色各自的点数
bool dfs(int node,int color)//染色（返回false即impossible）
{
    if(used[node])//如果已被染过色
    {
        if(col[node]==color)return true;//如果仍是原来的颜色，即可行
        return false;//非原来的颜色，即产生了冲突，不可行
    }
    used[node]=true;//记录
    sum[col[node]=color]++;//这一种颜色的个数加1，且此点的颜色也记录下来
    bool tf=true;//是否可行
    for(int i=head[node];i!=0&&tf;i=edge[i].nexty)//遍历边
    {
        tf=tf&&dfs(edge[i].t,1-color);//是否可以继续染色
    }
    return tf;//返回是否完成染色
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int a,b;
    while(m--)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);//存的是有向边，所以存两次
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(used[i])continue;//如果此点已被包含为一个已经被遍历过的子图，则不需重复遍历
        sum[0]=sum[1]=0;//初始化
        if(!dfs(i,0))//如果不能染色
        {
            printf("Impossible");
            return 0;//直接跳出
        }
        ans+=min(sum[0],sum[1]);//加上小的一个
    }
    printf("%d",ans);//输出答案
    return 0;
}
```

---

## 作者：dingcx (赞：201)

~~看到大佬们用的剪枝和并查集的算法，用了广搜的我瑟瑟发抖。~~
## 思路
这题思路应该挺多，我经(kan)过(wan)思(ti)索(jie)后，感觉可以**染色**。

由于河蟹不和谐（~~怪怪的~~），如果一条边的一端有河蟹，那么另一端必然没有；而如果一端没有河蟹，那么另一端一定有。所以，**遍历每条边**（至少一端已经染色），如果另一端没有染色，则染上和这一端**相反的颜色**；如果都已经染色，**判断是否相反**，是就不管，不是就**一定**$Impossible$。

由于要按边遍历，数据范围又超大，只能用**邻接表**，具体见代码。

再说广搜。需要每染色一个点就把此点放进队列，并标记。我选择广搜的原因是不用递归，发现不满足就可以**直接返回**。
## 细节
这道题其实细节挺多。

首先，为了方便遍历，建边时要建**双向边**。

其次，原图并非连通图，所以应该**每个点都搜一次**（搜过就不搜了），即在主函数上加一层循环。

如果可以满足，就要统计河蟹最小个数，也就是在每次广搜都统计一遍，再加起来。其实每次的个数就是两种颜色用的少的的个数，注意在每次搜完后都要求值。
## 技巧
这里的技巧就是如何把代码写的更简单（~~更短~~）
### 染色
开一个整型的$used$数组，值为$0$表示未染色，$1$表示一种颜色，$2$表示另一种。

求相反的颜色方法：$a$%$2+1$（$1$变$2$，$2$变$1$）。
### 颜色个数
最好的方法是用数组$sum[3]$记录，$sum[1]$为一种颜色的个数，$sum[2]$为另一种。

用数组的好处是统计只需要$sum[used[...]]++$就好了。
## 代码
相信没有多少人喜欢上面的一通分析吧，那么，你们喜欢的代码来了——
```cpp
//长度54行，时间15ms
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int MAXN=10010,MAXM=200010;//注意双向边，边要开2倍
int n,m,tot=0,sum[3],ans=0;
int h[MAXN],used[MAXN];//h[i]记录点i在邻接表中指向的第一条边
struct Edge{//边的结构体
	int v;
	int next;//next记录这条边在邻接表中指向同端点的另一条边
}e[MAXM];
void addEdge(int u,int v){//建边
	tot++;//边的代号
	e[tot].v=v;
	e[tot].next=h[u];h[u]=tot;
}
queue<int> q;
bool bfs(int start){//广搜，不存在返回真
	used[start]=1;//染为1
	sum[1]=1,sum[2]=0;//初始化
	q.push(start);//进队列
	while(!q.empty()){//队列非空
		int u=q.front();q.pop();//u为原端点
		for(int k=h[u];k;k=e[k].next){//邻接表
			int v=e[k].v;//v为指向端点
			if(used[v]==used[u]) return 1;//同色，直接返回
			if(used[v]==0){//没染过色
				used[v]=used[u]%2+1;//染相反颜色
				sum[used[v]]++;//记录
				q.push(v);//进队列
			}
		}
	}
	return 0;//满足
}
int main(){
	scanf("%d%d",&n,&m);
	while(m--){
		int uu,vv;
		scanf("%d%d",&uu,&vv);
		addEdge(uu,vv);//建边，双向
		addEdge(vv,uu);
	}
	for(int i=1;i<=n;i++){
		if(used[i]) continue;//遍历过就不再遍历
		if(bfs(i)){//不满足
			printf("Impossible");
			return 0;//直接返回
		}
		else ans+=min(sum[1],sum[2]);//加和
	}
	printf("%d",ans);
	return 0;//华丽结束
}
```
看我这么辛苦写的一篇题解，怎么能不点个赞呢？

---

## 作者：wshz (赞：158)

//并查集解法：

像[团伙]这题，有兴趣可以去看看；
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10001],a,b,n,m,t[10001],bj[10001],h[10001],ans;
int find(int x)//模板函数；
{
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}
void xx(int x,int y)//判断函数；
{
    int qq=find(x);
    if(qq!=y)//如果他们父亲不相等将他们合并；
    {
        f[y]=qq;
        t[qq]+=t[y];
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        f[i]=i;
        t[i]=1;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        int x1=find(a),x2=find(b);
        if(x1!=x2)//相邻两点一定异色；
        {
            if(h[a]) xx(h[a],x2);/*a的父亲节点一定
            和a异色，一定和a的异色点同色，所以将他们
            合并；*/
            if(h[b]) xx(h[b],x1);//同上；
            h[a]=x2;//h数组存a点异色点；
            h[b]=x1;//同上；
        }
        else//如果他们同色，表示不行；
        {
            cout<<"Impossible";
            return 0;
        }
    }
    for(int i=1;i<=n;i++)
    {
        int q=find(i);
        if(!bj[q])//表示这个集合的答案还没被选过；
        {
            int q1=find(h[i]);
            bj[q]=1;
            bj[q1]=1;
            ans+=min(t[q],t[q1]);//两种情况最小值；
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：InnovatorNZ (赞：142)

原置顶的那个题解已经说的很详尽了。这里我想对那个题解中部分代码进行一下说明:
Q1: 为什么dfs结尾处没有回溯操作？ (used[u]=false)
A1: 这道题不用回溯。只有在那些需要求出所有可能路径的题目中才需要回溯操作。为什么呢？其实回溯操作类似于一个“遗忘操作”;使得在寻找第二条路径时可以找到这个相同的结点。而这道题并不需要求出所以可能路径。不明白的同学可以拿起纸和笔模拟一下:从根结点开始，依次往下，颜色分别为黑、白、黑……直到最后一个结点。可见这个过程只是把图中所有的结点都走一遍，dfs return的时候也是如此，只是为了把所有的结点都走一遍，并不是要求出所有可能路径。因此并不需要回溯。
Q2: 如果不需要求出所有路径，那怎么保证答案一定是最小的那个呢？
A2: 其实如果拿起纸和笔模拟一下你会发现其实这个过程求出的答案是唯一的，也一定是最小的。不过注意一点，有一行很重要:ans+=min(sum[white],sum[black]). 这句话说明了应该加的是黑和白中更小答案的那个。至于为什么很好理解:你应该在染黑色的结点们和染白色的结点们中更小的放河蟹，因为两种方法都满足题目要求。
Q3: 为什么main中还需要再把所有结点都dfs一遍？
A3: 因为图不一定是全联通的。至于会不会超时/重复计算，你不需要担心。此前说明过了，不需要回溯操作;因此main中再dfs时会检查该结点是否被访问过了，如果访问过了就直接跳过，即if(used[i]) continue;.

---

## 作者：北海_Beihai (赞：110)

哪有楼上说的那么复杂，爆搜不就AC了

见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> g[10010];
int n,m,c[10010],x,f[10010];
void dfs(int k,int t){
    if(c[k]!=-1&&c[k]!=t){puts("Impossible");exit(0);}	//冲突，无解
    if(c[k]==t) return;	//记忆化
    c[k]=t;	//染色
    f[k]=1;	//标记
    x++;
    for(int i=0;i<g[k].size();i++) dfs(g[k][i],t^1);	//搜吧，要换颜色
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){	//建图
        int x,y;
        scanf("%d%d",&x,&y);
        g[x].push_back(y);
        g[y].push_back(x);
    }
    int ans=0;
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++) if(f[i]==0){	//没搜过的就搜
        x=0;
        memset(c,-1,sizeof(c));
        dfs(i,0);
        int t=0;
        for(int i=1;i<=n;i++) t+=c[i]==1;
        ans+=min(t,x-t);	//累加答案时要注意比较最优解
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：男小鸟QAQ (赞：69)

又是一个阳光明媚的早上

又是一道写着图的遍历标签的题目

这道题目题意是，有一个由n个结点构成的有m条边的图，我没需要在某几个点上放置河蟹，河蟹会占领该点上的所有边，相邻的河蟹之间会发生冲突，我们需要让河蟹占领整个图

既然是图的题，当然是要画图啦~\(≧▽≦)/~

下面是两个随便画的图

![乱画的图1](https://t1.picb.cc/uploads/2018/10/30/JbouSs.png)

![乱画的图2](https://t1.picb.cc/uploads/2018/10/30/Jbocy7.png)

经过观察我们可以发现，1图可以实现河蟹占领全图的目标而2图不行

那么我们如何实现这一目标呢，2图又为什么不行呢？？？

我们可以把a图分层

![图1分层](https://t1.picb.cc/uploads/2018/10/30/Jbomm6.png)

我们可以发现，图1的每一条边都是建立在不同的层上的，即不会出现同一层之间互相连接的边。我给这种图起一个名字叫做分层图(乱说的)。

而图2分层后存在同一层之间的边。

题目中说了，河蟹直接不能相邻，那么我们只要让河蟹占据奇数层或者偶数层的所有点，问题就解决了(^ω^)

那么我们如何给一个图分层呢？？？

并查集！！！

并查集这个算法代码复杂度很低，而且时间复杂度是很低的，如果你没学过这个算法也没有关系，在下面的代码我有详细说明。

并查集的作用是使某些点具有相同的祖宗结点，那么他们直接就属于一个集合，同样的思想可以用在这一道题上，我们可以让奇数层的点属于同一集合，再让偶数层的点属于同一集合，这就是我们解决这个问题的plan a和plan b。每个plan所需要的河蟹个数就是奇数或偶数层中点的个数的和了QWQ

代码如下

```cpp
//bzoi男小鸟
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int n,m,fa[44000];//fa函数记录各结点的父亲结点
//路径压缩后父亲结点和祖宗结点是一个意思哦(AωA)
bool bj[44000];
int find(int now)
{
	if(fa[now]==now) return now;//初始化时把每个点都设为根结点，他们的祖宗结点都是自己。 
	int fn=find(fa[now]);
	//并查集寻找祖先函数的路径压缩最好这样写，做带权并查集题目都是在回溯后更新权值的
	//如果要写权值更新语句就写在该注释的位置就好了(>^ω^<)
	return fa[now]=fn;
}
void unity(int a,int b)
{
	int r1=find(a),r2=find(b);//分别找到a和b的祖宗结点
	fa[r1]=r2;//要将以r1结点为祖宗的所有结点的祖宗结点设为r2，只需要把r1的祖宗结点设为r2就好了
	//在下一次find后路径压缩会把并查集恢复父亲就是祖宗的状态 
}
int main()
{
	//一下plan a，plan b分别指在所有奇数层点上放河蟹以及在所有偶数点上放河蟹 
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n*2; i++) fa[i]=i;
	//为什么要给(1,2*n)的结点都初始化呢，因为我们要对结点进行黑白染色处理
	//在该数组中与i异色的点我们用i+n存储，接下来会有详细说明
	int x[110000],y[110000],ass1=0,ass2=0;
	//x1为plan a中的一点，ass1存储plan a所需河蟹数
	//y1为plan b中的一点，ass2存储plan b所需河蟹数 
	for(int i=1; i<=m; i++)
	{
		cin>>x[i]>>y[i];//a、b间有一条边，那么选择了a就不能选择b了
		int r1=find(x[i]),r2=find(y[i]); //分别找到x和y的祖先
		if(r1==r2)
		{
			cout<<"Impossible";//如果两个点同属于一层却存在一条边
			exit(0);//那么他们各点上的河蟹一定会发生冲突 
		}
		else
		{
			unity(x[i]+n,y[i]);//x的不同层的点和y同层 
			unity(x[i],y[i]+n);//y的不同层数点和x同层
		}
	}
	//分别找到两个方案的祖宗结点
	/*
	o o
	| |
	o o-o
	可能会出现如上图的情况，图的本身可能由很多个分层图构成，那么将要求的就是每一个 分层图中的最佳解决方案 
	*/
	memset(bj,true,sizeof(bj)); //用于记录以i为根节点的图是否放置过河蟹 
	int ass=0;
	for(int i=1; i<=m; i++)
	{
		int r1=find(x[i]),r2=find(y[i]);
		if(bj[r1] && bj[r2]) //该边所在的分层图没有计算过最佳解决方案 
		{
			bj[r1]=false;
			bj[r2]=false;//标记该分层图进行过运算 
			ass1=0;
			ass2=0;
			for(int i=1; i<=n; i++)//求出该边所在的分层图中最佳解决方案 
			{
				if(find(i)==r1) ass1++;//该点属于plan a 
				else
				if(find(i)==r2) ass2++;//该店属于plan b 
			}
			ass+=min(ass1,ass2);//存储答案 
		}	
	}
	cout<<ass;
	//完结撒花，感谢陪伴ヽ(°▽°)ノ 
}
```

---

## 作者：George1123 (赞：31)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1330 【封锁阳光大学】传送门](https://www.luogu.org/problem/P1330)

### 此题算法:二分图

大致思路:

>1.$ $输入边，建议用邻接表存边。

>2.$dfs$每个联通块，将每个联通块的起点染成白色，和白色相邻的点染成绿色，和绿色相邻的点染成白色(因为~~水晶巨蟹~~河蟹不能相邻)。这时如果有下图中五号点这样颜色矛盾的点，就输出"Impossible"并$return\space 0;$

![](https://s2.ax1x.com/2019/09/13/nDj4pQ.jpg)

>3.$ $如果染色成功了，看白点绿点哪个少，然后放置河蟹。

>4.$ $最后每个连通块的答案加一下就是最终答案$ans$了。

## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10010;
const int M=100010;
struct node{
	int adj,nex;
}edge[M];
int top,g[N],ans;
int white,green;
void add(int x,int y){
	edge[++top].adj=y;
	edge[top].nex=g[x];
	g[x]=top;
} 
//邻接表存边
int dfn[N],n,m,a,b;
bool vis[N],col[N];
bool dfs(int now,int go){//返回值为有没有颜色矛盾的点
	col[now]=go%2;
	if(col[now]) green++; 
	else white++;//1是绿色，0是白色
	vis[now]=1;
	for(int i=g[now];i;i=edge[i].nex){//遍历边
		int p=edge[i].adj;
		if(vis[p]){
			if((col[p]^col[now])==0)//如果两者相同
				return 0;
		} else if(!dfs(p,go+1))
			return 0;
	} return 1;
} int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a,&b);
		add(a,b); add(b,a);
	} for(int i=1;i<=n;i++){
		if(!vis[i]){
			white=green=0;
			if(!dfs(i,0)){
				printf("Impossible\n");
				return 0;
			} ans+=min(white,green);//少放河蟹
		}
	} printf("%d\n",ans);
	return 0;
} 
```
~~别打回血中的水晶巨蟹~~

谢谢大家! !

---

## 作者：EricWay1024 (赞：30)

扬中夏令营Day0的晚上练手写一道题。还比较顺利吧...

思路：

这就是个染色问题。把图上的点染成红色和蓝色。要求：同一条边上的两个点颜色不能一样。

解释一下：不妨红色对应河蟹占领而蓝色对应没有占领。

- 如果一条边两个点都是红色，那就是两个河蟹打架了

- 如果一条边两个点都是蓝色，那就这条边没有被切断

上面两种情况是不行的。

- 如果一条边两个点一红一蓝，那就是恰好被切断

这种情况是可以的。

对吧？

如此看来，所谓占领和不占领其实是等价的。

在一个连通图中，令任意一个点是红色或者蓝色，那么整张图的颜色应该已经确定了。为了让红色的点最少，只需要分别尝试两种情况（令这个点是红色或者令这个点是蓝色），看看哪种情况中红点数目最少即可。

为什么会Impossible？那是因为，在从第一个点的颜色一直推到所有点的颜色的过程中，有的点会被要求涂上相反的颜色。即，当你想把一个点涂成蓝色的时候，却发现它已经是红色了。这就出现无解情况。

在下面的代码里，你会看到一个叫dfs的函数。它的功能是：令i的颜色是s（s∈{0,1}），返回i所在的连通图用了颜色1的点数。

是的。连通是个永恒的话题。千万不要忘记对不连通的考虑。在下面的代码里，我使用了一个循环来解决这个问题。注意被染过色的点不需要继续遍历。

对color2数组的解释：因为我太笨了，实在不知道怎么样才能让dfs(i,0)和dfs(i,1)并行不悖。

```cpp

#include<iostream>
#include<algorithm>
#include<cstring>
#include<map>
#include<queue>
#include<vector>
#include<string>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<stack>
#include<set>
using namespace std;


vector<int> g[10000+10];

int color[10000+10];
int color2[10000+10];
int n, m;
bool ok;
int dfs(int i, int s){
	if (!ok) return 0;
	int sum=s;
	color[i]=s;
	for (int j=0; j<g[i].size(); j++){
		int v=g[i][j];
		if (color[v]==-1){
			color[v]=(!s);
			sum+=dfs(v, !s);
		} else if (color[v]==s)  ok=false;
		
	}
	
	return sum;
}
int main(){

	cin>>n>>m;
	for (int i=0; i<m; i++){
		int u, v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	
	memset(color, -1, sizeof(color));
	ok=true;
	int one=0;
	int ans=0;
	for (int i=1; i<=n; i++){
		if (color[i]==-1){
			memcpy(color2, color, sizeof(color));
			int a=dfs(i,0);
			memcpy(color, color2, sizeof(color));
			int b=dfs(i,1);
			ans+=min(a,b);

		}
		if (!ok) break;
	}
	if (!ok){
		cout<<"Impossible"<<endl;
	} else {
		cout<<ans<<endl;
	}

    return 0;
}



```

---

## 作者：hxn2228 (赞：20)

想明白很简单，bfs+染色

因为整张图可能包含多张小图，遍历每一个节点，如果还有没搜过的节点就以当前节点为根开始bfs

bfs过程中如果遇到相邻节点染色相同的情况就跳出，输出impossible即可

染色方案选取较小的一种

以上，上代码

```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
vector <int>  edge[1000010];
queue <int> que;
int vis[1000010],ans[2],col[1000010];
int n,m,ansn,aa,bb,flag;
void bfs(int x)
{
    while(!que.empty())
    {
        int tmp=que.front();
        que.pop();
        vis[tmp]=1;
        for(int i=0;i<edge[tmp].size();i++)
        {
            int nowp=edge[tmp][i];
            if(col[nowp]==col[tmp])//如果染色相同则跳出，输出impossible 
            {
                ans[0]=-1;
                ans[1]=-1;
                return;
            }  
            if(!vis[nowp])
            {
                que.push(nowp);
                col[nowp]=(col[tmp]+1)%2;//否则将其染成与父节点不同的颜色，这里用0和1来染色 
                ans[col[nowp]]++;//当前染色方案的花费+1 
            }
        }
    }
}
void scan()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>aa>>bb;
        edge[aa].push_back(bb);
        edge[bb].push_back(aa);
    }
    memset(col,-1,sizeof(col));
}
void solve()
{
    for(int i=1;i<=n;i++)
    {
        if(vis[i]!=1)  
        {
            ans[0]=1;
            ans[1]=0;
            col[i]=0;
            que.push(i);
            bfs(i);
            if(ans[0]==-1)
            {
                flag=1;
                break;
            }
            ansn+=min(ans[0],ans[1]);//选取两种染色方案中较小的那种 
        }
    }
    if(flag==1)  cout<<"Impossible";
    else cout<<ansn;
}
int main()
{
    scan();
    solve();
}
```

---

## 作者：Qura (赞：19)

## 题目大意

有一些白点，现将一些白点染为黑点，使得:黑点互不相邻且白点互不相邻。要求最少黑点数。

## 简要分析

可以发现，黑点、白点本质是一样的。且一个合法的图中每个点只能或白或黑。

## 得出算法

对一个连通图,从任意点$P$开始，将$P$设位白,然后开始对连通图染色染色，同时累加黑白点个数。如没有出现矛盾，则答案为$min(W,B)$。累加即可。有点像2-SAT.

## 代码示例

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int N=10010;
vector<int> E[N];
int a[2],c[N],n,m;
bool dfs(int u,bool x) {
	a[c[u]=x]++;
	for(int v:E[u]) if(c[v]!=-1 && c[v]==c[u])
		return 0;
	for(int v:E[u]) if(c[v]==-1 && !dfs(v,x^1))
		return 0;
	return 1;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i) c[i]=-1;
	for(int u,v; m--; ) {
		scanf("%d%d",&u,&v);
		E[u].push_back(v);
		E[v].push_back(u);
	}
	int ans=0;
	for(int i=1; i<=n; ++i) if(c[i]==-1){
		if(!dfs(i,0)) {
			puts("Impossible");
			return 0;
		}
		ans+=min(a[0],a[1]);
		a[0]=a[1]=0;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_CHO (赞：6)

### 这是一道萌新练习dfs的不二习题
 这道题可以抽象成用dfs求无向图的连通块的同时进行染色，逻辑能力的要求~~对萌新来说较高~~


------------
OI题目通常都很~~繁琐~~，合理合法地抽象题意是一个重要的能力。
题目中提到河蟹封锁了相邻的两个点就不好使，所以我们可以把有河蟹的顶点抽象成一种颜色，无河蟹的顶点抽象成另一种颜色。

题目大意：**在一个无向图中有序地遍历，保证每两个连通的顶点颜色不同，输出两种颜色中染色次数较少的那个；如果遍历的过程中任何一处出现矛盾（即相邻的两个点被染成一种颜色），遍历停止，输出Impossible。
------------**

PS：这里为萌新们普及一下“染色”：
~~首先肯定不是拿着刷子刷啦~~
染色是处理一些有关图的问题的常用方法，一种颜色可以代表一种状态，而颜色可以用1，2，3这样的数字来表示，也可以使用true，false这样的布尔型变量表示，等等。最终目的只有一个：把图上的顶点分类处理，从而达到解决问题的效果。

------------
下面就是代码实现的过程啦
首先当然是把图存进来，存图的方法有多种，最萌新的方法是开一个二维数组G[i][j],表示顶点i、j之前是否有连通，不过这种方法空间复杂度非常高，很多空间是浪费掉的，因此数据一大起来就可能MLE，所以，这里我们选择另一种更主流的存图方法：不定长数组
```cpp
vector <int> G[N];
```
G[i]用来表示点i，**G[i][j]表示点i与点G[i][j]之间是否有道路连接，需要注意的是，这里的j的值并没有实际意义，j只是起到用来表示数组长度的作用。**
下面是存图的代码：
```cpp
for(int i=1;i<=m;++i)
{
	int a,b;
	scanf("%d%d",&a,&b);
	G[a].push_back(b);
	G[b].push_back(a);
}
```
到这里还不可以遍历，因为我们还要预处理一些事儿
我们需要开一个数组V[n+1],V[i]表示点是否被染色及染成了什么色，我们约定-1为未染色，0和1分别为两种颜色。现在，没有点被染色，所以需要初始化数组V
```cpp
memset(V,-1,sizeof(V));
```
我们还需要开一个数组color[2]，表示0色和1色分别染了多少次。

下面，我们就可以愉快地dfs啦
首先，我们以循环的方式枚举图上每个点，当枚举到点i时进行判定，如果点i已染色，那么就continue；如果点i未被染色，那就随便染个色（为叙述方便，我们染成0色），这意味着我们要开始以点i为根去搜索了，我们需要把color数组清零（清零的具体原因后续介绍）
```cpp
for(int i=1;i<=n;++i)
	{
		if(V[i]!=-1)
		{
			continue;
		}
		V[i]=0;
		color[1]=color[0]=0;
		dfs(i);
		ans+=min(color[0],color[1]); //这行的作用后面说
	}
```
下面就是dfs函数，dfs(x)表示对点x进行搜索，首先，我们需要获得点x被染成了什么色，同时其对应的color数组变量++，接下来，我们需要依次枚举所有与点x连通的点G[x][k]，如果点G[x][k]已被染色，就continue；否则， 就染成与点x不同的色，再搜索这个点
……
一直下去，直到无路可走回溯
```cpp
void dfs(int x)
{
	if(!V[x]) ++color[0];
	if(V[x]) ++color[1];
	for(int k=0;k<G[x].size();++k)
	{
		int v=G[x][k];
		if(V[v]!=-1)
		{
			if(V[v]==V[x])     //这里需要注意，此处表示点v和点x均已被染色，并且由于前面的某处操作，使得这两个连通的点被染成了同一种颜色，出现了矛盾，所以直接中断程序的运行即可。
			{
				printf("Impossible\n");
				exit(0);
			}
			continue;
		}
		V[v]=!V[x];
		dfs(v);
	}
}
```
到这里，我们已经遍历完成了一个连通块，我们需要汇总答案，为下一次遍历做准备。我们注意到，此时已经完成了一个连通连通块，下次遍历一定不会和本次出现同一个点，也就是说，下次遍历与本次没有半毛钱关系。因此，我们只需找出两种颜色中染色次数较少的那个颜色作为这次遍历的最终答案即可。
```cpp
ans+=min(color[0],color[1]); 
```
最后，我们只需把ans的值输出就AC啦！

#### 下面是完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10000+10;
int n,m;
int V[N];
vector <int> G[N];
int color[2];
int ans;
void dfs(int x)
{
	if(!V[x]) ++color[0];
	if(V[x]) ++color[1];
	for(int k=0;k<G[x].size();++k)
	{
		int v=G[x][k];
		if(V[v]!=-1)
		{
			if(V[v]==V[x])
			{
				printf("Impossible\n");
				exit(0);
			}
			continue;
		}
		V[v]=!V[x];
		dfs(v);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		G[a].push_back(b);
		G[b].push_back(a);
	}
	memset(V,-1,sizeof(V));
	for(int i=1;i<=n;++i)
	{
		if(V[i]!=-1)
		{
			continue;
		}
		V[i]=0;
		color[1]=color[0]=0;
		dfs(i);
		ans+=min(color[0],color[1]); 
	}
	printf("%d\n",ans);
	return 0;
}
```
完结，撒花！！！

---

## 作者：Victorique (赞：6)

做完这个题我也真是无语，挂了四遍都是挂在memset上。。

其实楼下很多人也说了，这个河蟹的分布就像是把这个图进行染色，然后相邻的点要染成不同的颜色，很容易得出如果可行，那么染色的两种颜色中，少的那一种就是要求的。

貌似现在前排题解都是dfs搜索的了，我只是给出一种bfs的解法。

首先，建图，用数组模拟邻接表建图，没错，就是spfa那么建图。

建好图了之后，开始进行宽搜，因为这个图并不是联通图，所以还是要对每一个点当成起点搜的，当然已经搜过的就不用搜了。

对于染色使用1和-1可能好操作一些。

一遍染色一边加貌似可以加快一些时间效率。

当然，染色的时候有一个点是已经染过色，然而现在它被要求染成另一个颜色自然就是Impossible解。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define re register
using namespace std;
struct po
{
    int from;
    int to;
    int nxt;
    int dis;
};
po edge[1000001];
int head[1000001],b[10001],dis[100001],vis[1000001],col[1000001],ans,n,m,s,t,l,d;
int h[500001][3],num,sum1,sum2;
inline void add_edge(int from,int to,int dis)
{
    edge[++num].nxt=head[from];
    edge[num].to=to;
    edge[num].dis=dis;
    head[from]=num;
}
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline void bfs(int st)
{
    memset(b,0,sizeof(b));
    int front=0,tail=1;
    h[1][1]=st;
    h[1][2]=1;
    b[st]=1;
    col[st]=1;
    sum1=1;sum2=0;
    while(front<tail)
    {
        int now=h[++front][1];
        int color=h[front][2];
        for(re int i=head[now];i;i=edge[i].nxt)
        {
            int x=edge[i].to;
            if(col[x]==0)
            {
                col[x]=color*(-1);
                if(col[x]==1)
                sum1++;
                else
                sum2++;
            }
            else
            {
                if(col[x]==color)
                {
                    cout<<"Impossible";
                    exit(0);
                }
            }
            if(!b[x])
            {
                vis[x]=1;
                b[x]=1;
                h[++tail][1]=x;
                h[tail][2]=col[x];
            }
        }
    }
    ans+=min(sum1,sum2);
}
int main()
{
    cin>>n>>m;
    for(re int i=1;i<=m;i++)
    {
        s=read(),t=read();
        add_edge(s,t,0);
        add_edge(t,s,0);
    }
    for(re int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            vis[i]=1;
            bfs(i);
        }
    }
    cout<<ans;
}
```
代码略显繁杂，请大佬们勿怪


---

## 作者：s_ShotღMaki (赞：5)

这是一道~~染色体~~  染色题

------------
这题有一个坑点就是图有可能并非连通的，所以我们要从每一个子图去找

------------
dfs大法好


------------
稍微具体讲一下题目，其实所有的点有两种，1点和0点，只要出现一个点周围连通的点出现不一样的情况，就直接break掉，返回输出Impossible，如果颜色一样就继续搜，其实代码注释写的比较清楚了，下面放代码



```cpp
#include<bits/stdc++.h>
#define maxn 100002
using namespace std;
void add(int q,int z);//链式前真香星不会的话自己去csdn学学(如果你会vector那更好咯，本蒟蒻不会) 
void fuck(int num,int can);//不要在乎函数名qwq 
int n,m;//题目要求 
int a,b;//存边用得变量 
int flag;//这个flag用处后面有说明 
int cnt;//边的个数 
int ans;//答案 
int we[maxn];//每个点的颜
int ci[2];//两种颜色1或
int head[maxn*2];//链式前真香星要用
bool vis[maxn];//走过没有 
struct node
{
	int q,z,next;
}ass[maxn*2];
int main()
{
	ios::sync_with_stdio(false);//背下这个使你的cin跟scanf一样快(noip不可用) 
	cin>>n>>m;
	for(int i=1;i<=m;i++)//存边 
	{
		cin>>a>>b;
		add(a,b);
		add(b,a);
	}
	for(int i=1;i<=n;i++)//判断是否连续 
    {
        ci[0]=0;
		ci[1]=0;//每次归零 
        if(!vis[i])//如果没便利过这个小图图 
        fuck(i,0);
        if(flag)//如果没法封锁完 
        {
        	cout<<"Impossible";
        	return 0;
		}
        ans+=min(ci[0],ci[1]);//两种中的最小值，把各个子图的ans累加 
    }
	cout<<ans;
	return 0;
}
void add(int q,int z)//存边 
{
	ass[++cnt].q=q;
	ass[cnt].z=z;
	ass[cnt].next=head[q];
	head[q]=cnt;
}
void fuck(int num,int can)
{
	ci[can]++;//这种颜色个数++ 
	we[num]=can;//给它染上颜色 
	vis[num]=true;//走过了记录上，判断子图要用呢
	for(int i=head[num];i;i=ass[i].next)//搜边 
	{
		int now=ass[i].z;
		if(vis[now])
		{
			if(we[now]!=can)continue;//如果不行的话直接continue 
			else
			{
				flag=1;
				return ;//记录flag返回去 
			}
		}
		else 
		{
			int can2;
			if(can==0)can2=1;
			else can2=0;//换颜色 
			fuck(now,can2);//继续搜搜搜 
		}
	}
}
```

---

## 作者：SFWR (赞：3)

突然发现题解好多都是DFS+染色，其实感觉本题也可以写并查集的。

其原理就是本题的模型就是对立节点的处理，可以根据敌人的敌人就是我的朋友，处理一个敌人数组来记录节点的敌人这样一条边的一个点就可以与另一个点的敌人并在一起。若是没有敌人，则直接将自己作为敌人。

而处理数量时，并入操作就将【敌人的敌人】数量+=自己集合数量。

最后得出结果时，选取没有使用的集合，因为是对立关系，所以在两个对立集合中选取一个~~河蟹~~较少的累加就可以。

当出现两个点已经是朋友（祖先相同）却又是敌人（在一条边上）则输出~~不可能~~

这种做法感觉比较适用于处理对立关系的并查集

例如：P1862&&P1892，这两个题都可以记录敌人数组来处理

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,a,b,c;
int f[100001],paic[100001],cnt[100001],vist[100001];
int find(int k)
{if(f[k]==k)return k;
else return f[k]=find(f[k]);}
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){cnt[i]=1;f[i]=i;}
while(m--)
{
	cin>>a>>b;
	int aa=find(a),bb=find(b);
	if(aa!=bb)
		{if(!paic[a])paic[a]=bb;
		else {f[bb]=find(paic[a]);cnt[find(paic[a])]+=cnt[bb];}
		if(!paic[b])paic[b]=aa;
		else {f[aa]=find(paic[b]);cnt[find(paic[b])]+=cnt[aa];}
		} 
	else {cout<<"Impossible";return 0;}
} 
for(int i=1;i<=n;i++){
	int white=find(i);
	if(!vist[white]){
		int black=find(paic[white]);
		vist[white]=1;
		vist[black]=1;
		ans+=min(cnt[black],cnt[white]);
	}
}
cout<<ans;
return 0;
}
```
码风巨丑，QAQ

---

## 作者：accedhy (赞：3)

思路是借鉴dalao的，但是我觉得我的写法更平易近人一些（~~厚颜无耻~~），基本思路我再赘述一遍

1、首先就是图有可能是不连通的，所以你要做一个标技数组，对于每一个连通图进行染色

2、我们采用黑白点染色的方法，如果一个点已经被染为黑色，那么和他相邻的点一定要被染成白色，最后答案取数量更少的颜色，这里用sum数组来计算两种颜色的数量

3、impossible的情况就是：如果一个点已经被遍历过（用vis数组标记），即已经染过色（用col数组记录），但是他已经被染过的颜色和接下来要染得颜色不同，即说明出现了两种颜色相同的点要相邻，那么就是不能封锁

下面是代码，代码里也有具体的注释

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node
{
	int to,next;
}e[200005];
int head[200005],cnt;
int sum[2],col[100005];//sum表示两种涂色方法，col表示颜色 
bool vis[100005];
void add(int u,int v)
{
	e[++cnt].next=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
void dfs(int x,int d)
{
	vis[x]=1;//表示已经遍历过 
	sum[d]++;//此颜色的个数加1 
	col[x]=d;//涂色 
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(vis[y])//如果已经遍历过 
		{
			if(col[y]==1-d)//颜色和原来相同 
				continue;
			else //颜色和原来不同 
			{
				printf("Impossible");
				exit(0);
			}
		}
		else 
			dfs(y,1-d);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int u,v,ans=0;
	for(int i=1;i<=m;++i)
	{
		scanf("%d%d",&u,&v);
		add(u,v),add(v,u);
	}
	for(int i=1;i<=n;++i)
	{
		sum[0]=sum[1]=0;//初始化 
		if(!vis[i])//有可能是非连通图 
			dfs(i,0);
		ans+=min(sum[0],sum[1]);//选择个数更小的那种涂色方案 
	}
	printf("%d",ans);
}
```

---

## 作者：zsj123 (赞：3)

#【Pascal】封锁阳光大学解题思路


**Q1:此题显然是用涂色来做的，那么怎么来涂色？**

初始化每个点为0，假设该点需要保留为1，删除为2.

则当我们设置了初始点的颜色（假设是1），那么与之有边相连的颜色必然是确定的（一个Dfs）


**Q2:如何判断河蟹无法封锁所有道路？**

当我们Dfs搜到一个点已经被访问，且该点的颜色与将要涂的颜色不相同，则无法满足


**Q3：如何防止爆内存？**

使用**链式前向星**可以有效解决


**Q4：最后的最小值怎么得到？**

首先，我们定义颜色为1的方案数为tot,总的点数为sum（这些数据在Dfs中都可以得到）

那么，颜色为2的方案数n=sum-tot，所以最小值为n(min)=min(tot,sum-tot)


**Q5:其他注意事项**

1.题目并没有保证n个点在图中都有边相连，所以有些点是不用做的

2.题目并没有保证只有一个图，所以要找出每一个小图


code:





```cpp
var n,m,i,x,y,min,tot,nowsum,ans:longint;
    s,w,e,color:array[1..100005*2] of longint;
    vis:array[1..100005] of boolean;
Function minx(a,b:longint):longint;
begin
  if a<b then exit(a)
   else exit(b);
end;
Procedure Add(x,y,v:longint);  //前向星添边
var i:longint;
begin
  if s[x]<>0 then w[v]:=s[x];
  s[x]:=v; e[v]:=y;
end;
Function Change_color(x:longint):longint; //改变颜色
begin
  if x=1 then exit(2);
  if x=2 then exit(1);
end;
Procedure Dfs(x,v:longint);
var temp:longint;
begin
  if vis[x] then  //如果访问过该点
   begin
    if (color[x]<>0) and (v<>color[x]) then   //如果被涂过颜色且颜色与当前所要涂的颜色不符
     begin
      writeln('Impossible');  //输出'不可能'
      halt;
     end;
    exit;
   end;
  inc(nowsum);  //统计当前小图中点的总数
  vis[x]:=true;    //添加访问
  color[x]:=v;     //涂色
  if v=1 then inc(tot);  //统计颜色为1的个数
  temp:=s[x];  //链式前向星求下一个点
  while temp<>0 do
   begin
    Dfs(e[temp],change_color(v));
    temp:=w[temp];
   end;
end;
begin
  readln(n,m);
  fillchar(s,sizeof(s),0);
  fillchar(w,sizeof(w),0);
  fillchar(e,sizeof(e),0);
  fillchar(vis,sizeof(vis),0);
  fillchar(color,sizeof(color),0);
  ans:=0;
  for i:=1 to m do
   begin
    readln(x,y);
    Add(x,y,i);Add(y,x,i+m);  //正反都存
   end;
  for i:=1 to n do
   begin
    tot:=0; nowsum:=0;
    if (not vis[i]) then Dfs(i,1);  //如果没有访问过就开始访问
    tot:=minx(tot,nowsum-tot);  //统计当前小图中的最小值
    inc(ans,tot);  //统计总值
   end;
  writeln(ans);
end.
```

---

## 作者：Zzh20011004 (赞：3)

这是一题普及组的题吧

因为图不一定联通，所以要访问所有联通块

以及黑白染色

在每一个联通块上随便找个点开始bfs

进行染色

如果有一条边的两个端点被染同种颜色，无解

否则就记录下黑白两色的点的个数

在布局贪心黑白点较小的个数即可

附上代码

            
```cpp
#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#define re register
struct node
{
    int to,next;
}    e[200005];
int head[10005],vis[10005],bl[10005],dep[10005];
int cnt=0,flag,ans=0;
inline void insert(int u,int v)
{
    e[++cnt].to=v;
    e[cnt].next=head[u];
    head[u]=cnt;
}
inline void dfs(int s)
{
    std::queue<int>    q;
    int cnt0=0,cnt1=1;
    q.push(s);
    bl[s]=1;vis[s]=1;dep[s]=1;
    while(!q.empty())
    {
        int now=q.front();q.pop();
        for(int i=head[now];i;i=e[i].next)
        {
            int to=e[i].to;
            if(vis[to] && bl[to]==bl[now])
            {
                flag=0;
                return;
            }
            if(!vis[to])
            {
                vis[to]=1;
                q.push(to);
                dep[to]=dep[now]+1;
                if(dep[to]&1)
                {
                    bl[to]=1;
                    cnt1++;
                }
                else
                {
                    bl[to]=0;
                    cnt0++;
                }
            }
        }
    }
    ans+=std::min(cnt0,cnt1);
}
int main()
{
    int n,m,u,v;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        insert(u,v);
        insert(v,u);
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            flag=1;
            dfs(i);
        }
        if(!flag)
        {
            printf("Impossible\n");
            return 0;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
一开始想什么先tarjan进行缩点然后判断联通块的大小如果为奇数无解
然后对这张简单图黑白染色取较小的再加上所有联通块的一半

发现有错

然后看看是图的遍历于是就直接上黑白染色了

还真过了


---

## 作者：Minclxc (赞：3)

都是染色的题解，我补个并查集的。时空都相对较优，反正我是9ms，空间O(n)

f[]表示要被染为同色的点，e[]表示要被染为异色的点，每次合并另一个点的异色点，最后每两组异色点数取最小值相加。

```cpp
#include<time.h>
#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>
#include<queue>
#include<stdio.h>
#include<string.h>
#include<math.h>
using namespace std;
#define fi(a,b) for(int i=a;i<=b;i++)
const int maxn=10001;
int f[maxn],e[maxn],p[maxn],b[maxn],ans=0,n,m;
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}//并查集
void heb(int x,int y){
    x=find(x);y=find(y);
    if(x==y)return;
    f[x]=y;p[y]+=p[x];
}//并查集
int main(){
    //freopen("in.txt","r",stdin);
    scanf("%d%d",&n,&m);fi(1,n){f[i]=i;p[i]=1;}
    memset(e,0,sizeof(e));memset(b,0,sizeof(b));
    fi(1,m){
        int a,b;scanf("%d%d",&a,&b);
        if(find(a)==find(b)){printf("Impossible");return 0;}//出现矛盾
        if(e[b])heb(a,e[b]);if(e[a])heb(e[a],b);
        e[a]=f[b];e[b]=f[a];//合并
    }//
    fi(1,n)if(!b[find(i)]){b[f[i]]=1;b[find(e[i])]=1;ans+=min(p[f[i]],p[f[e[i]]]);}//求和
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Glis (赞：3)

首先。。。题目数据还是比较水的，我只用了DFS都过了。

a[i][0]是记录关于点i的边数，a[i][j]是关于i点的第j条边连向哪个点。

然后开始DFS，从源点开始拓展，将源点染色为1，与源点相连的点（下面称为二层点，以此类推）染色为2，把与二层点相连的染色为1，与三层点相连的点染色为2,就是不断的121212……当然，这个时候，如果你发现，从一个被染色为1的点拓展，发现一个颜色也为1的点，这就无法染色，也就是题目中的Impossible。开变量累计图中你染色为1的点和染色为2的点的个数，选择小的累加到ans里面。

！注意，这里的图不是全连通的。每个连通图分开染色，分开累加，而不是一次性地输出所有连通图中的色1和色2的较小值(我就在这里挂了)。




    
    
    
    
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn=10005;
int n,m,nn,mm,f[maxn],a[maxn][300];
void dfs(int h)
{
    for (int j=1;j<=a[h][0];j++)
    {
       ### if (f[a[h][j]]==f[h]) {cout<<"Impossible"<<endl;exit(0);} 
        if (!f[a[h][j]]){
        f[a[h][j]]=3-f[h];
        if (f[a[h][j]]==1) nn++; else mm++;
        dfs(a[h][j]);}
    }   
}
int main()
{
    scanf("%d%d",&n,&m);
    int x,y,ans=0;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        a[x][++a[x][0]]=y;
        a[y][++a[y][0]]=x;       
    }
    for (int i=1;i<=n;i++)
    if (!f[i])
    {
        f[i]=1;
        nn=1;mm=0;
        dfs(i);
       ###nn=min(nn,mm);
###ans+=nn;
    }
    printf("%d\n",ans);
    //system("pause");
    return 0;
}
```

---

## 作者：59percent (赞：2)

```cpp
#include<iostream>
#include<queue>
#include<vector>
using namespace std;

const int N = 10001;

vector<int> g[N];   //  领接矩阵
int n, m, ans;
int color[N];   //  0没涂 1白色 -1黑色

bool magic()
{
  queue<int> q;

  for(int i = 1; i <= n; i++){  //  图不连通
    if(!color[i]){  //  i未涂色，给从i开始的连通子图涂色
      int cnt = 0, num = 1; //  连通子图的涂黑色数和顶点数
      
      //    起点i入队，记为白色，准备广搜
      q.push(i);
      color[i] = 1;

      while(!q.empty()){
        int h = q.front();

        for(int i = 0; i < g[h].size(); i++){   //  给队首连接顶点涂色
          int t = g[h][i];
          if(color[t] == color[h])  //  顶点t有颜色且与队首顶点冲突
            return false;
          if(color[t])  //  t有颜色就不涂色了
            continue;

          //    顶点t没颜色，上色并统计黑色数
          color[t] = -color[h];
          if(color[t] == -1)
            cnt++;
          //    统计连通子图顶点数，新涂色的顶点入队
          num++;
          q.push(t);
        }
        
        q.pop();
      }
      
      if(num - cnt < cnt)   //  黑白颠倒选涂色数少的
        cnt = num - cnt;
      
      ans += cnt;   //  当前连通子图的最少涂色数加入答案中
    }
  }

  return true;
}

int main()
{
  cin >> n >> m;
  for(int i = 0; i < m; i++){
    int a, b;
    cin >> a >> b;
    g[a].push_back(b);
    g[b].push_back(a);
  }

  if(magic())
    cout << ans;
  else
    cout << "Impossible";

  return 0;
}
```


---

## 作者：djww (赞：2)

题面一如既往的--------

**【题面分析】**

首先我们要看，这道题ta在讲什么，ta在求什么？

对于一张图，需要对多少个点进行操作，才能使得：

1.每条边上都有操作点

2.每条边上左右不能同时有操作点

这两个点很容易从题面中提取出来

**【思想的初步构建】**

那么对于之前想到的题目特质，我们要如何进行处理呢？

我们暂时不管河蟹的冲突问题，先解决封锁每条边

我们假设每条边左右两边都有河蟹把守，并且我们认为该边的左右端点一边是1号河蟹，一边是0号河蟹

接下来解决河蟹的冲突问题

我们发现，对于每个连通图，要么全部用1号河蟹，要么全部用0号河蟹，才能保证不冲突，所以对于这个连通图，它的答案就是0号和和1号的最小值。显然的，如果出现像下图的情况，显然答案为Impossible

![冲突](https://s2.ax1x.com/2019/10/18/KVjzz6.png)

**【思路的实现】**

我们每次找到未被赋值过的点，对它进行dfs，并处理1 0的min值

dfs内处理是否冲突，1号0号河蟹计数以及下一层的dfs

- 连通图的处理
	
    并查集连边

- 1 0河蟹的赋值

	在dfs中的for循环每次赋值与它相连的边
    
- 1 0河蟹的冲突

	如果本次dfs到的点已经被连过，那么判断点之前被赋值的1 0号是否与这次赋值的相同

**【代码】**
```cpp
#include<iostream>
#include<cstdio>
#define N 10009
#define M 100009
using namespace std;
int use[2*N],col[2*N],head[2*N],sum[5];
int n,m,tot;
struct de{
	int nex,u;
}ed[2*M];
void add(int a,int b){
	ed[++tot].nex=head[a];
	ed[tot].u=b;
	head[a]=tot;
}
bool dfs(int node,int co){
    if(use[node]){
        if(col[node]==co) return true;
        else return false;
    }
    use[node]=1;
    sum[col[node]=co]++;
    bool f=1;
    for(int i=head[node];i!=0&&f;i=ed[i].nex)
    	f=f&&dfs(ed[i].u,1-co);
    return f;
}
int main(){
	int x,y,i,ans=0;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    for(i=1;i<=n;i++){
        if(use[i])
            continue;
        sum[0]=sum[1]=0;
        if(!dfs(i,0)){
            printf("Impossible");
            return 0;
        }
        ans+=min(sum[0],sum[1]);
    }
    printf("%d",ans);
    return 0;
}
```
**【后记】**

思路有参考**KesdiaelKen**

---

## 作者：Trick_t (赞：2)

从源点开始拓展，将源点染色为1，与源点相连的点染色为2

这时如果从一个被染色为1的点拓展，发现一个颜色也为1的点，说明无解

累计染色为1的点和染色为2的点的数量，选择小的累加到ans里

注意，图不是全连通的。每个连通图分开染色，分开累加

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=100001;
struct node{
    int v,nxt;
}e[N];
int n,m,num,ans;
bool flag;
int head[N],cn[3],col[N];
inline int qread()
{
    int x=0,j=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')j=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*j;
}
void Insert(int u,int v)
{
    e[++num].v=v;
    e[num].nxt=head[u];
    head[u]=num;
}
void dfs(int now)
{
    if(flag)return;
    for(int i=head[now];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if(col[v]==col[now])
        {
            flag=1;
            return;
        }
        if(!col[v])
        {
            col[v]=3-col[now];
            cn[col[v]]++;
            dfs(v);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u=qread(),v=qread();
        Insert(u,v);
        Insert(v,u);
    }
    for(int i=1;i<=n;i++)
        if(!col[i])
        {
            col[i]=1;
            cn[1]=1;cn[2]=0;
            dfs(i);
            if(flag)
            {
                printf("Impossible\n");
                return 0;
            }
            else ans+=min(cn[1],cn[2]);
        }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：友邻牧鸡 (赞：2)

本蒟蒻并没有用并查集，只定义一个数组记录是否走过，从1到n遍历，如果该节点没有走过，则从这里开始dfs并在该点放置河蟹，一步一步推，如果出现相邻点都为放置或不放置则输出impossible。

对于每个联通分量记录该联通分量的点的数量及放置河蟹的数量，在每个联通分量遍历后，判断总点数减去放置数书否小于放置数，因为设放置河蟹的点为1，不放的点为0，题目要求即是0,1相交替出现，如果在初始点为1的情况下能成立，那么在这种情况下0和1交换也成立，所以要用该联通分量总数减去放置数判断争取放置数最小。注意，当该联通分量总数为1时则为0.

最后把所有联通分量的最小放置数相加得结果。

代码略丑//捂脸



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int init()
{
    char c=getchar();
    int jg=0,zf=1;
    while(c<'0'||c>'9'){if(c=='-')zf*=-1;c=getchar();}
    while(c>='0'&&c<='9'){jg=(jg<<1)+(jg<<3)+c-'0';c=getchar();}
    return jg*zf;
}
int zg[10010],n,m,h[10010],ans,top,sl,an;//zg走过点的标记，h邻接表头，ans每个连通分量的放置数，top边栈顶，sl每个连通分量的点总数，an总放置数 
struct node
{
    int t;
    int next;
}b[200010];//邻接表 
void add(int fr,int to)//加边 
{
    b[++top].t=to;
    b[top].next=h[fr];
    h[fr]=top;
    return;
}
int dfs(int now,int sw)//如果返回0则代表发生冲突，impossible 
{
    sl++;
    if(sw==0)//该点为改连通分量初始点。 
    {
        zg[now]=1;
        ans++;
        bool ky=1;
        int i=h[now];
        while(i!=0)
        {
            if(!dfs(b[i].t,1))
            {
                cout<<"Impossible"<<endl;
                return 0;
            }
            i=b[i].next;
        }
        if(sl-ans<ans)
        ans=sl-ans;
        if(sl!=1)//特判该连通分量只有一个点，若有1个点返回-1 
        return ans;
        else
        return -1;
    }
    if(sw==1)//该点的上一位放置了河蟹 
    {
        zg[now]=2;
        int  i=h[now];
        while(i!=0)
        {
            if(zg[b[i].t]==2)
            return 0;
            if(!(zg[b[i].t]))
            {
                if(!dfs(b[i].t,2))
                return 0;
            }
            i=b[i].next;
        }
    }
    if(sw==2)//该点的上一位没有放河蟹 
    {
        zg[now]=1;
        int i=h[now];
        ans++;
        while(i!=0)
        {
            if(zg[b[i].t]==1)
            return 0;
            if(!(zg[b[i].t]))
            {
                if(!dfs(b[i].t,1))
                return 0;
            }
            i=b[i].next;
        }
    }
    return 1;
}
int main()
{
    n=init();
    m=init();
    for(int i=1,v,u;i<=m;i++)
    {
        v=init();
        u=init();
        add(v,u);
        add(u,v);
    }
    for(int i=1;i<=n;i++)
    if(!zg[i])//查找未被标记的点，即找下一个连通分量 
    {
        ans=0;//初始化 
        sl=0;
        int sss=dfs(i,0);
        if(!sss)
        return 0;
        if(sss!=-1)
        an+=sss;
    }
    cout<<an<<endl;
    return 0;
}
```

---

## 作者：Crab_Dave (赞：2)

~~我来组成第50篇题解~~

**黑白染色好题**

直接黑白染色即可，思维难度并不高。

代码如下——

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,ans,vis[10005],a[2];
int head[10005],k=1,u,v;
struct edge
{
	int to,next;
}e[200005];

void adde(int u,int v)//链式前向星加边
{
	e[k].to=v;
	e[k].next=head[u];
	head[u]=k++;
}

bool dfs(int u,int co)//图的遍历
{
	if(vis[u]!=-1)//遍历过了
	{
		if(vis[u]==co)return 1;//如果已染的色与当前颜色相同，说明可行
		return 0;//否则不行
	}
	vis[u]=co;a[co]++;//标记并统计
	bool can=1;
	for(register int i=head[u];i&&can;i=e[i].next)
	{
		int v=e[i].to;
		can=can&&dfs(v,!co);//如果仍合法则继续
	}
	return can;
}

int main()
{
	memset(vis,-1,sizeof(vis));//初始化为未染色
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);//加边
		adde(v,u);
	}
	for(register int i=1;i<=n;i++)
	{
		if(vis[i]!=-1)continue;//遍历过则跳过
		a[1]=a[0]=0;//初始化这一部分子图所需的黑白数
		if(!dfs(i,0)){puts("Impossible");return 0;}//如果不能染色则Impossible
		ans+=min(a[1],a[0]);//统计答案，取黑色和白色中较少的那个
	}
	printf("%d\n",ans);//输出
	return 0;//结束了罪恶的一生
}
```
资瓷一下叭qwq

---

## 作者：eternal (赞：2)

一道简单的染色加上dfs判的问题，注意该问题也是双向建边

/\*
ID:Agreement

LANG:C++

\*/
    
    
```cpp
// Invincible
#include <bits/stdc++.h>
#define erep( i , u ) for( int i = head[u] ; ~i ; i = e[i].nxt )
#define rep( i , l , r ) for( int i = (l) ; i <= (r) ; i++ )
#define per( i , r , l ) for( int i = (r) ; i >= (l) ; i-- )
using namespace std;
inline int _read(){
    register int x = 0;
    register char ch = getchar();
    while( ch > '9' || ch < '0' ) ch = getchar();
    while( ch >= '0' && ch <= '9' ){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}
const int maxn = 10000 + 5 , maxe = 100000 + 5;
struct edge{
    int v , nxt;
} e[maxe];
int head[maxn] , _t = 0;
inline void addedge( int u , int v ){
    e[++_t].v = v , e[_t].nxt = head[u] , head[u] = _t;
}
int clr[maxn] , c[2];
int q[maxe];
inline bool bfs( int x ){
    int f = 0 , r = 0;
    c[0] = c[1] = 0; 
    c[clr[x] = 0]++; 
    q[r++] = x;
    while( f < r ){
        int u = q[f++];
        erep( i , u ){
            int v = e[i].v;
            if( -1 == clr[v] ){
                c[ clr[v] = clr[u] ^ 1 ]++;
                q[r++] = v;
            }else if( clr[v] == clr[u] ) { return false; }
        }
    }
    return true;
} 
int main(){
    int N , M;
    memset( head , 0xff , sizeof head );
    memset( clr , 0xff , sizeof clr );
    scanf( "%d %d" , &N , &M );
    int u , v;
    rep( i , 1 , M ){
        u = _read() , v = _read();
        addedge( u , v ); addedge( v , u ); 
    }  
    int ans = 0;
    bool f = 1;
    rep( i , 1 , N )
        if( -1 == clr[i] ){
            if( 0 == bfs(i) ) { f = 0 ; break; }
            ans += min( c[0] , c[1] );
        }
    if( 0 == f ) puts("Impossible");
    else
        cout << ans << endl;
    return 0;
}
```

---

## 作者：JasonZRY (赞：2)

这题很水

如果题目说的直接一点，那就是分分钟秒掉的事：

# P1330 封锁阳光大学

#### 难度：$\color{red}\text{入门}$ 

## 题目描述

这里有一个图，用黑白染色法判断这个图是不是二分图。如果是，输出最少有哪些点是白点（假设黑点>=白点），

## 输入格式

第一行：两个整数N，M

接下来M行：每行两个整数A，B，表示点A到点B之间有边相连。

## 输出格式

仅一行：如果这个图不是二分图，则输出“Impossible”，否则输出一个整数，表示最少需要染多少个白点。

## 输入输出样例

### 输入

3 3

1 2

1 3

2 3

### 输出 

Impossible

### 输入
3 2

1 2

2 3

### 输出

1
## 说明/提示
【数据规模】

1<=N<=10000，1<=M<=100000，任意两点之间最多有一条道路。

所以说先把一个点染色，相邻的点跟它用不同的颜色，如果相邻点的颜色相同，这就不是二分图。

如果是二分图，在每次染色时统计黑点和白点个数，最后两个比较，少的那个就是白点数。

详细代码：

```
#include<bits/stdc++.h>
using namespace std;
vector<int>g[50005];
queue<int>q;
long long sum,cnt1,cnt2;
int n,m,x,y,cnt;
bool vis[50005],col[50005];
bool bfs(int x){
	vis[x]=true;
	col[x]=true;
	q.push(x);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		if(col[u])cnt1++;
		else cnt2++;
		for(int i=0;i<g[u].size();i++){
			if(!vis[g[u][i]]){
				vis[g[u][i]]=true;
				col[g[u][i]]=!col[u];
				q.push(g[u][i]);
			}else if(col[u]==col[g[u][i]])return false;
		}
	}
	return true;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)vis[i]=false;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			cnt1=cnt2=0;
            if(bfs(i))sum+=min(cnt1,cnt2);
            else{
                cout<<"Impossible";
                return 0;
            }
		}
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：peterwuyihong (赞：1)

# 二分图判断模板
如何判断一张图是二分图？从一个点开始染色，黑黄相间染色，染到一个本颜色的点即 $ U.color = V.color $ 就错了。
#### 判断Impossble就是这样
```cpp
bool dfs(int x,int c)
{
	color[x]=c;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(color[y]==c)return 0;
		if(color[y]==0&&!dfs(y,-c))//染下一种颜色
        return 0;
	}
	return 1;
}
```
## 那么问题来了
## 怎么判断要几只河蟹呢？
我们看![](https://cdn.luogu.com.cn/upload/image_hosting/hzxdpcbn.png)只要在每个二分小图上判断 $ Yellow \ and \ black $ 的数量哪个大即可。首先我们存下来每个小图，
```cpp
bool dfs(int x,int c)
{
	color[x]=c;
	query[++cnt]=x;//加的
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(color[y]==c)return 0;
		if(color[y]==0&&!dfs(y,-c))return 0;
	}
	return 1;
}
for(int i=1;i<=n;i++)
	if(color[i]==0)
	if(!dfs(i,666))
	{
		puts("Impossible");//不行
		return 0;
	}
	else
	{
		for(int j=1;j<=cnt;j++)
		if(color[query[j]]==666)tmp++;//tmp->黄
		ans+=min(tmp,cnt-tmp);//cnt-tmp->黑
		tmp=0;
		cnt=0;//每次重置为〇
		res=0;
	}
```
# OK，来一发总代码
```cpp
#include<cstdio>
#include<iostream>
#define maxn 100010
using namespace std;
int n,m,x,y,tot=1,ans;
int head[10010],Next[maxn<<1],ver[maxn<<1],res,tmp;
short color[10010];
int query[10010],cnt;
bool dfs(int x,int c)
{
	color[x]=c;
	query[++cnt]=x;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(color[y]==c)return 0;
		if(color[y]==0&&!dfs(y,-c))return 0;
	}
	return 1;
}
void add(int x,int y)
{
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}
int main()
{
	scanf("%d %d",&n,&m);
	while(m--)
	{
		scanf("%d %d",&x,&y);
		add(x,y);add(y,x);
	}
	for(int i=1;i<=n;i++)
	if(color[i]==0)
	if(!dfs(i,666))//染色666
	{
		puts("Impossible");
		return 0;
	}
	else
	{
		for(int j=1;j<=cnt;j++)
		if(color[query[j]]==666)tmp++;
		ans+=min(tmp,cnt-tmp);
		tmp=0;
		cnt=0;
		res=0;
	}
	printf("%d",ans);
}
```


---

## 作者：加勒比·史努比 (赞：1)

[原题链接](https://www.luogu.org/fe/problem/P1330)
# Solution
简单说，就是将给定的图（不一定联通）进行“染色”。因为“当两只河蟹封锁了相邻的两个点时，他们会发生冲突”，所以用两种颜色。

注意：给定的图不一定是联通的

判联通：

方法一：并查集，父节点相同的为一张图（[可参考蒟蒻的OI笔记](https://five-shifts-forever.blog.luogu.org/bing-zha-ji)）

方法二：Floyd

AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int n,m,sum1,sum2,ans;  //n为节点数，m为边数，sum1.sum2用于染色点的统计，ans为最后答案
int f[10001],vis[10001],du[10001];   //f用于并查集判联通，vis用于染色（1，2分别是两种颜色），du用于统计节点的度数
bool flag;   //flag用于判是否有解.false表有解.true无解
vector<int> g[10001];  //vector玄学建图
//并查集
int find(int x){
    if(x!=f[x]) f[x]=find(f[x]);
    return f[x];
}
void dfs(int x){
    if(vis[x]==1) sum1++;
    if(vis[x]==2) sum2++;  //记录色数
    if(flag==true) return ; 
    for(int i=0;i<g[x].size();i++){
        if(vis[x]!=vis[g[x][i]]&&vis[g[x][i]]!=0) continue; //已经染好，跳过
        if(vis[x]==vis[g[x][i]]){ //与之前有冲突，无解
            flag=true;
            break;
        }
        vis[g[x][i]]=3-vis[x];
        dfs(g[x][i]);
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        int x=find(u);
        int y=find(v);
        if(x!=y) f[y]=x;  //并查集
        g[u].push_back(v);
        g[v].push_back(u);  //无向图，双向建边
        du[u]++;
        du[v]++;   //记录度数
    }
    for(int i=1;i<=n;i++){
        sum1=0,sum2=0;  //sum1.sum2表每张图的两种色数，搜索前清零
        if(f[i]==i&&du[i]>0){  //搜索每张独立且有边的图
            vis[i]=1;  //起点色别其实无所谓，效果都一样
            dfs(i);
            ans+=min(sum1,sum2);
        }
        if(flag==true){
            cout<<"Impossible";
            return 0;
        }
    }
    cout<<ans;
    return 0;
}
```
蒟蒻初次写题解，请多指教

---

## 作者：恶灬心 (赞：1)

[题目描述](https://www.luogu.org/problemnew/show/P1330)

简单来说，就是一道图的遍历。题目的意思大致是，将一张图上的每一条边**都有且只能有**一个端点被选中。
于是对于一张图，**有一个点被选中，与其相连的点都不能被选**，否则返回错误 本题返回(impossible);

我为了让文字能配合代码，以下的标记点全用map<int,bool> A,B两个代替。

于是我们很容易想到，遍历该图，同时标记该点进入A还是进入B，再从这个点向其他点遍历，如果其他点没有被遍历过，则加入待遍历队列，被遍历过的点要检查是否满足题意。

### 注意！

本题有一个坑点，坑了我3次。。 首先他的点使用绝对不是从1开始每个点都出现，其次，他一个测试点可能有多组图，也就是不是一张连通图。我们需要对每个点都判断一次，然后从A.size()和B.size()中取最小的那个作为这个小图的结果。

QAQ

然后，这道题就可以~~愉快~~的水过了。

```
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
	int w=1,d=0; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1; ch=getchar();}
	while(ch>='0'&&ch<='9')d=d*10+ch-'0',ch=getchar();
	return w*d;
}
const int N=100010,M=500010;
int head[N],Next[M],ver[M],tot;
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
map<int,bool> A,B;
int n,m,df[N],d[N],zz; 

//df数组判断该点是否被记录，d数组记录出现过的点。

void init()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		if(!df[x])
		{
			df[x]=1; d[++zz]=x;
		}
		if(!df[y])
		{
			df[y]=1; d[++zz]=y;
		}
		add(x,y);
		add(y,x);
	} 
}
bool v[N];
queue<pair<int,int> > q;
void bfs(int k,int jh)
{
	q.push(make_pair(k,jh));
	while(!q.empty())
	{
		int x=q.front().first,z=q.front().second;
		q.pop();
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i];
			if(!v[y]) //如果该点没有遍历过，判断它进哪一个集合
			{
				if(z) A[y]=1;
				else B[y]=1;
				v[y]=1;
				q.push(make_pair(y,(z+1)%2));
			}
			else //不然就判断是否满足题意。
			{
				int flag=(A.count(y)?0:1);
				if(z==flag) 
				{
					cout<<"Impossible"; 
					exit(0);
				}
			}
		}
	}
}
int ans;
void solve()
{
	for(int i=1;i<=zz;i++) 
    //选出没有用过的点，就是没有遍历过的分图。
	if(!v[d[i]])
	{
		A[d[i]]=1;v[d[i]]=1;
		bfs(d[i],0);
		ans+=min(A.size(),B.size()); 
		A.clear();B.clear(); //每次加完要清空map
	}
	cout<<ans;
}
int main()
{
	init();
	solve();
}
```

---

## 作者：ars4me (赞：1)

这个题虽然我也是用dfs实现的 但看了看下面大佬的题解好像没有和我思路完全一样的

实现起来很简单 很好理解 但我感觉也很鬼畜

首先需要写两个dfs函数 dfs1和dfs2 且这两个函数在过程中会互相调用

用链式前向星存图 我们先遍历一下每一个edge[i].to 如果它从来没有被dfs1或者dfs2搜到过 我们就用dfs1搜它

然后对于它所在的图 与它相邻的点 我们用dfs2去搜 而且只要是被dfs2搜到的点 我们都ans++

举个例子 **7-28-2-12-18** 这是一个图

假如之前我们发现**2**这个点没被搜过(!judge[edge[i].to]) 先用dfs1搜它 然后搜它的时候遍历他的临点 会用dfs2搜到**12** 因为它是被dfs2搜到的 所以ans++ 然后再调用dfs1去搜**18** 这样整个图下来 **28 12**两个点都是被dfs2搜到的 所以ans就等于2

但是会有一个问题 如果这个图我们一开始先搜的是**28** 那么搞完这个图后我们会发现 dfs2搜到的点有**7 2 18** 这样ans就等于3了 明显不对 所以我们没搜一个图的时候都记录一下这个图一共多少个点 最后真正的答案total就+=min(ans , pointsize - ans) pointsize就是指图中点的总数

对于Impossible的情况 我们会发现 如果你用dfs1搜到了一个 已经被dfs1搜到过的点 那么 它肯定就会Impossible 应该很容易想吧

对于我搞的三个布尔数组exist[size] , judge[size] , vis[size]它们的意思分别是有没有被dfs1搜到过 有没有被搜到过 有没有被dfs2搜到过


代码如下



        
        






                

        
        

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cstdlib>
    using namespace std;
    #define in = read();
    typedef long long ll;
    typedef unsigned int ui;
    const ll size = 200000 + 1000;
        struct point{    int next , to;}edge[size];
            void dfs1(int x);
            void dfs2(int x);
                int n , m , a , b;
                int site , ans , pointsize , total;
                int head[size];
                bool exist[size] , judge[size] , vis[size];
inline ll read(){
        ll num = 0 , f = 1;    char ch = getchar();
        while(!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while(isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
inline void add(int x , int y){
        edge[++ site].next = head[x];
        edge[site].to = y;
        head[x] = site;
}
void dfs2(int x){
        if(!judge[x])    pointsize ++;
        if(!vis[x])        ans ++;
        vis[x] = true;    judge[x] = true;
        for(register int i=head[x];i;i=edge[i].next)
                if(!exist[edge[i].to])
                        dfs1(edge[i].to);
}
void dfs1(int x){
        if(!judge[x])    pointsize ++;
        exist[x] = true;    judge[x] = true;
        for(register int i=head[x];i;i=edge[i].next){
                if(exist[edge[i].to]){
                        printf("Impossible");
                        exit(0);
                }
                dfs2(edge[i].to);
        }
}
int main(){
        n in;    m in;
        for(register int i=1;i<=m;i++){
                a in;    b in;
                add(a , b);        add(b , a);
        }
        for(register int i=1;i<=(m<<1);i++)
                if(!judge[edge[i].to]){
                        dfs1(edge[i].to);
                        total += min(ans , pointsize - ans);
                        ans = 0;    pointsize = 0;
                }
        printf("%d" , total);
        return 0;
}
COYG
```

---

## 作者：龙少№1 (赞：1)

蒟蒻第一次发题解，如有不好请见谅。

本人采用bfs加染色，每搜索一个节点判断是否发生冲突。

由于可能不止一个联通块，所以应搜索每个节点。

具体代码如下：





```cpp
#include <iostream>
#include <list>
#include <queue>
#include <cmath>
#define MAXL 1000001
using namespace std;
list<int> edges[MAXL];
int n,m,color[MAXL],clr[2],ans;//color存每个节点的颜色，clr为每种颜色的个数 
bool vis[MAXL];
bool flag=1;//是否能封锁道路 
void addedge(int u,int v){
    edges[u].push_back(v);
    edges[v].push_back(u);
}
void bfs(int x){
    clr[0]=0;clr[1]=0;//初始化每个联通块的颜色个数 
    color[x]=0;//将第一个点染色 
    clr[color[x]]++;
    queue<int> q;
    q.push(x);
    vis[x]=1;
    while (!q.empty()){
        int a=q.front();
        q.pop();
        for (list<int>::iterator it=edges[a].begin();it!=edges[a].end();it++){
            if (vis[*it]&&color[*it]==color[a]){
                flag=0;
                return;
```
}//判断是否发生冲突

```cpp
            if (!vis[*it]){
                color[*it]=1-color[a];
                clr[color[*it]]++;
                vis[*it]=1;
                q.push(*it);
            }
        }
    }
    ans+=min(clr[0],clr[1]);
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);
    }
    for (int i=1;i<=n;i++){
        if (!vis[i]){
            bfs(i); 
        }
        if (!flag){
            printf("%s","Impossible");
            return 0;
        }
    }
    printf("%d",ans);
}
```

---

## 作者：poorpool (赞：1)

蒟蒻也能写出来的AC代码！思路是搜索+染色。


首先需要认识到图不一定是连通图。因此我们完全可以忽视孤立的点。从1开始枚举点到n，要是没有被研究过并且不是孤立的点的话就对它进行染色。每个连通块之间互不影响，所以我们对于每个连通块累加min{色块1的个数，色块2的个数}即可。


一些细节请看代码


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
int n, m, uu, vv, ans1, ans2, ans, shux[10005]={0};
vector<int>    edge[10005];//vector好用 
bool u[10005];
void hx(int nl, int sx){//当前处在nl点，想染上sx的颜色 
    if(shux[nl] && shux[nl]!=sx){//染糊了 
        cout<<"Impossible";
        exit(0);
    }
    if(shux[nl])    return ;//幽雅地返回吧，染过色的点 
    u[nl] = true;
    shux[nl] = sx;
    if(sx==1)    ans1++;
    else             ans2++;
    for(int i=0; i<edge[nl].size(); i++)
        hx(edge[nl][i], sx==1?2:1);//相邻点染色不同 
}
int main(){
    cin>>n>>m;
    for(int i=1; i<=m; i++){
        scanf("%d %d", &uu, &vv);
        edge[uu].push_back(vv);
        edge[vv].push_back(uu);
    }
    for(int i=1; i<=n; i++)
        if(!u[i] && edge[i].size()){
            ans1 = ans2 = 0;//累加每种色块个数的变量记得清零 
            hx(i, 1); 
            ans += min(ans1, ans2);
        }
    cout<<ans;
    return 0;
}
```

---

## 作者：attack (赞：1)

好吧，表示本蒟蒻不懂什么叫黑白染色，所以题解基本看不懂。。

但是我同时用BFS+DFS也AC了

思路：

因为各个点不一定相连

所以我们枚举一边所有的点，对于每个没有访问过的点跑一边DFS，

在DFS的过程中同时访问与该点相连的点，

然后在每次DFS的过程中进行DFS，

算出在该联通分量中，从该点出发，需要放置的数量

           
        
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<queue>
using namespace std;
void read(int & n)
{
    char c='+';int x=0;
    while(c<'0'||c>'9')
    c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+(c-48);
        c=getchar();
    }
    n=x;
}
const int MAXN=10101;
struct node
{
    int u,v,nxt;
}edge[MAXN*10+101];
struct dian
{
    int bh;
    int how;// 0不放，1放 
}sz[MAXN];
int n,m;
int head[MAXN];
int vis1[MAXN];
int vis2[MAXN];
int fang[MAXN];// 记录这个点是否放 
int num=1;
int ans1=0x7fffff,ans2=0,out=0;
void add_edge(int x,int y)
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].nxt=head[x];
    head[x]=num++;
}
void bfs(int p,int fbf)
{
    memset(vis2,0,sizeof(vis2));
    dian bg;
    bg.bh=p;
    bg.how=1;
    queue<dian>q;
    q.push(bg);
    while(q.size()!=0)
    {
        dian now=q.front();
        vis2[now.bh]=now.how;
        q.pop();
        if(now.how==1)
        ans2++;
        for(int i=head[now.bh];i!=-1;i=edge[i].nxt)
        {
            dian will;
            will.bh=edge[i].v;
            if(now.how==1)will.how=2;
            else will.how=1;
            if(vis2[edge[i].v])
            {
                if(vis2[edge[i].v]==now.how)
                {
                    printf("Impossible");
                    exit(0);
                }
                else continue;
            }
            q.push(will);
        }
    }
    ans1=min(ans1,ans2);
}
void dfs(int p)
{
    ans2=0;
    vis1[p]=1;
    bfs(p,1);
    for(int i=head[p];i!=-1;i=edge[i].nxt)
    {
        if(vis1[edge[i].v]==0)
        {
            ans2=0;
            dfs(edge[i].v);    
        }
    }
}
int main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)
    head[i]=-1;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        read(x);read(y);
        add_edge(x,y);
        add_edge(y,x);
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(vis1[i]==0&&head[i]!=-1)
        {
            ans1=0x7ffff;
            dfs(i);
            out+=ans1;
        }
    }
    printf("%d",out);
    return 0;
}
```

---

## 作者：zhegexiankabutaileng (赞：1)

DFS染色都有很多人解了，楼下的并查集题解写得有点不详细。我来补一个详细的并查集。


这题的并查集具体来说应该是种类并查集，通过向量偏移，从两两关系确定第三条边的关系十分正确（产生冲突）。类似的题还有P2024食物链，还有经典的监狱问题。

我们通过每次输入一条边，把相连的两个点关系确定为敌对，用1表示，如果中途输入一条边与以前的关系产生冲突了，那么就输出“Impossible”，如果输完了还不冲突证明有可行解。

由于这个题不止一个联通分量，所以并查集完成后要确定有多少个祖先，同时进行路径压缩，确定儿子和祖先的关系。有敌对和友好。最后对于祖先记录一下有多少个敌对P和友好Q，每个祖先最小的关系数加起来就可以了。（因为敌对和友好可以交换，不会造成冲突）


···cpp

    
        
```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
int n,m,ans=0;
int fa[10001]={0},r[10001]={0},p[10001]={0},q[10001]={0};
int ff(int x)
{
    if(fa[x]==x) return x;
    else 
    {
        int temp=ff(fa[x]);
        r[x]=(r[fa[x]]+r[x])%2;
        fa[x]=temp;
        return fa[x];
    }
}
bool uni(int x,int y)
{
    int a=ff(x);
    int b=ff(y);
    if(a==b)
    {
        if(r[x]==r[y]) return true;//occ
        else return false; 
    }
    fa[a]=b;
    r[a]=(((1+r[y])%2)+r[x])%2;
    return false;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        fa[i]=i;
        p[i]=0;
    }
    for(int i=1;i<=m;i++)
    {
        int a,b;
        cin>>a>>b;
        if(uni(a,b))
        {
            cout<<"Impossible";
            return 0;
        }      
    }
    for(int i=1;i<=n;i++)
    {
        ff(i);
        if(r[i]==1) p[fa[i]]++;
        else q[fa[i]]++;
    }
    for(int i=1;i<=n;i++)
    {
        if(fa[i]==i) ans+=min(p[i],q[i]);
    }
    cout<<ans;
}
···
```

---

## 作者：追忆。似海 (赞：1)

一道染色问题。

在判断中，首先选出一个没有被用过的点（即 !vis[i]），然后对其所有能到达的点进行染色。

在染色中，没找到一个点t，就让vis[t]=index(index保存的是第几层);而且染色时只用染一遍，另一种情况直接用all-当前的值。

有一个小技巧，每次开始时先把根节点放进队列中，第一层循环循环层数，令k=q.size(),第二层循环从0到k每次pop()一个，在第二层循环完成之前，所有pop()出的点都是属于同一层。

c++代码：



    
    



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#define maxn 10010
using namespace std;
int n,m;
vector<int> edges[maxn];
int vis[maxn];
int f(int u){
    queue<int> q;
    q.push(u);
    int index=1;
    vis[u]=index;
    int re1=0;
    int all=0;
    bool can=true;
    while(!q.empty()){
        index++;
        int k=q.size();
        for(int i=0;i<k;i++) {
            int x=q.front();q.pop();
            for(int i=0;i<edges[x].size();i++){
                if(!vis[ edges[x][i] ]) {
                    vis[ edges[x][i] ]=index;
                    q.push(edges[x][i]);
                }else {
                    if(vis[edges[x][i]]!=vis[x]) continue;//fu jie dian
                    can=false;
                    break;
                }
            }
        }
        if(!can) break;
        if(index%2) re1+=k;
        all+=k;
    }
    if(!can) return -1;
    return min(all-re1,re1);
}
int main(){
    scanf("%d%d",&n,&m);
    int a,b;
    for(int i=0;i<m;i++) {
        scanf("%d%d",&a,&b);
        edges[a].push_back(b);
        edges[b].push_back(a);
    }
    memset(vis,0,sizeof(vis));
    int re=0;
    for(int i=1;i<=n;i++){
        if(!vis[i]) {
            int u=f(i);
            if(u==-1) {
                printf("Impossible");
                return 0;
            }
            re+=u;
        }
    }
    printf("%d",re);
    return 0;
}

```

---

## 作者：_HLLY_ (赞：1)

bfs染色，注意可能不止一个图；；

一个点只有放和不放两个状态；

所以同一图的其他点可据此推出，两种都不符合就直接跳出；



蒟蒻的代码，非常恶心人：




    


        
    
    
    
    
    
              
              
    
          
        
            
            
              
              
              
          
          
            
    
              
              
    
          
    
            
              
              
              
          
          
            
    
    
    
    
   
    
    
    
    
    
    
    
    
    


```cpp
#include<iostream>
#include<queue>
using namespace std;
int xia[10005],dui[10005],hou[200010],i,n,m,j,tot,min1,x,daan;
bool meiyou,chuxian[10005],you[10005],meiyou2;
queue<int>q;
struct uu{
    int qi;
    int zhong;
}bian[200010];
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)xia[i]=-1;
    for(i=1;i<=m;i++)
    {
        cin>>bian[i].qi>>bian[i].zhong;
        hou[i]=xia[bian[i].qi];
        xia[bian[i].qi]=i;
        bian[i+n].qi=bian[i].zhong;
        bian[i+n].zhong=bian[i].qi;
        hou[i+n]=xia[bian[i].zhong];
        xia[bian[i].zhong]=i+n;
    }
    for(j=1;j<=n;j++)
{     
    if(you[j]==1)continue;min1=999999999;
        while(!q.empty())q.pop();
        tot=0;
    meiyou=0;
    you[j]=1;
    q.push(j);
    dui[j]=1;
    chuxian[j]=1;
    tot++;
    while(!q.empty())
    {
        x=q.front();
        q.pop();
        i=xia[x];
        if(dui[x]==1)
          {
                  while(i!=-1)
        {
          if(dui[bian[i].zhong]==1){ meiyou=1;break;      }
          if(chuxian[bian[i].zhong]==0)
          {chuxian[bian[i].zhong]=1;
          you[bian[i].zhong]=1;
            q.push(bian[i].zhong);
            dui[bian[i].zhong]=2;
          }    
           i=hou[i];
        }
          }
  if(dui[x]==2)
          {
                  while(i!=-1)
        {
               if(dui[bian[i].zhong]==2){ meiyou=1;break;      }
               if(chuxian[bian[i].zhong]==0)
               {chuxian[bian[i].zhong]=1;you[bian[i].zhong]=1;
                q.push(bian[i].zhong);
            dui[bian[i].zhong]=1;
            tot++;
             }
          i=hou[i];    
        }
          }
          if(meiyou==1)break;
    }
    if(meiyou==0)min1=tot;
    meiyou2=0;
    for(i=1;i<=n;i++){chuxian[i]=0;dui[i]=0;}
    while(!q.empty())q.pop();
    chuxian[j]=1;
    tot=0;
    q.push(j);
    dui[j]=2;
    while(!q.empty())
    {
        x=q.front();
        q.pop();
        i=xia[x];
        if(dui[x]==1)
          {
                  while(i!=-1)
        {
          if(dui[bian[i].zhong]==1){ meiyou2=1;break;      }
         if(chuxian[bian[i].zhong]==0)
          {    q.push(bian[i].zhong);you[bian[i].zhong]=1;
          chuxian[bian[i].zhong]=1;
            dui[bian[i].zhong]=2;}
          i=hou[i];    
        }
          }
  if(dui[x]==2)
          {
                  while(i!=-1)
        {
               if(dui[bian[i].zhong]==2){ meiyou2=1;break;      }
             if(chuxian[bian[i].zhong]==0)
          {chuxian[bian[i].zhong]=1;  you[bian[i].zhong]=1;  
          q.push(bian[i].zhong);
            dui[bian[i].zhong]=1;
            tot++;
        }
          i=hou[i];    
        }
          }
          if(meiyou2==1)break;
    }
    if(meiyou2==0)min1=min(tot,min1);
    if(meiyou==1&&meiyou2==1){    cout<<"Impossible";return 0;}
    else daan+=min1;
}
    cout<<daan;
}

```

---

## 作者：Ghost_lzy (赞：1)

楼下各路大神的解法真是666的，BFS+染色什么的我看不懂。首先因为每一条边都要被染色，所以如果把图画出来，求出每个点的深度，可以发现：如果染了一个深度为奇数的点，那么所有为奇数的点都染完才不会起冲突又封锁了阳光大学；偶数同理。所以可以BFS或者DFS求出每个点的深度后再BFS或DFS后比较深度为奇数的点数和深度为偶数的点数的大小即可。（如果IMPOSSIBLE的话，那么必然存在深度%2相同的点有连接，想想为什么）


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>V[10005];
vector<int>e;
bool vis[10005];
int depth[10005],n,m;
bool ok=true;
int ans1,ans2,ans=0;
void dfs(int v)
{
    vis[v]=1;
    for(int i=V[v].size()-1;i>=0;i--)
    {  int k=V[v][i];
        if(!vis[k])
        {
            depth[k]=min(depth[v]+1,depth[k]);
            dfs(k);
        }
    }
}
void dfs2(int v)
{    
    if(!ok) return;
    if(depth[v]%2)ans1++;
    else ans2++;
    for(int i=V[v].size()-1;i>=0;i--)
    {  int k=V[v][i];
        if(depth[v]%2==depth[k]%2) 
        {ok=false;return;}
        else
        if(depth[k]>depth[v])
        {
            dfs2(k);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    { int a,b;
        scanf("%d%d",&a,&b);
        V[a].push_back(b);
        V[b].push_back(a);
    }
    memset(depth,127/3,sizeof(depth));
    depth[1]=0;
    for(int i=1;i<=n;i++)
    {  if(!vis[i])
      {depth[i]=0;dfs(i);e.push_back(i);}
    }
    int ans=0;
    for(int i=e.size()-1;i>=0;i--)
    {   int v=e[i];
       ok=true;ans1=0,ans2=0;
        dfs2(v);
        if(!ok){
            printf("Impossible\n");
            return 0;
        }
        ans=ans+min(ans1,ans2);
    }
    printf("%d\n",ans);
}
```

---

## 作者：syx2000121910 (赞：1)

一个显然的黑白染色问题！

利用bfs分层搜索的性质，分层！

注意可能存在的好几个联通块的情况！

如果一个点搜索到一个与自己同色的点，证明不存在合法方案！

各个联通块分开累加答案！

答案是当前联通块内部的黑色与白色的最小值！


```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<queue>
#define INF 10000007
#define LL long long 
using namespace std;
int next[1000010],head[1000010],list[1000010],q[1000010],sum[5],step[1000010],a[1000010],vis[1000010];
int cnt,n,m,flag,ans;
void insert(int x,int y){
    next[++cnt]=head[x];
    list[cnt]=y;
    head[x]=cnt;
}
void solve(int begin){
    for(int i=1;i<=n;i++)q[i]=0,step[i]=0;
    int l=0,r=1;
    sum[1]=0;sum[2]=0;
    step[1]=1;
    q[1]=begin;step[1]=1;a[begin]=1;vis[begin]=1;
    while(l<r){
        int now=q[++l];
        for(int i=head[now];i;i=next[i]){
            int k=list[i];
            if(a[k]==a[now]){
                flag=0;
                return;
            }
            if(!vis[k]){
                vis[k]=1;
                q[++r]=k;
                step[r]=step[l]+1;
                if(step[r]%2==1)a[k]=1;
                    else if(step[r]%2==0)a[k]=2;
            }
        }
    }
    for(int i=1;i<=r;i++)sum[a[q[i]]]++;
    ans+=min(sum[1],sum[2]);
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        insert(x,y);insert(y,x);
    }
    for(int i=1;i<=n;i++)if(!vis[i]){
        flag=1;
        solve(i);
        if(!flag){
            cout<<"Impossible"<<endl;
            return 0;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：intruder (赞：1)

我是用bfs改写的dfs应为每次与上层比较 用bfs的话就可好一点

就是对每一层染色 比较他和他的父亲节点 颜色必须不一样 记录下来其中一种的颜色总数 总的点数减他就是另一种颜色数  然后加上其中较小的就可以了


```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cmath>
#include<queue>
#include<iostream>
#define maxn 10060
#define MK(a,b)  make_pair(a,b)
using namespace std;
int n,m,h[maxn],vis[maxn],used[maxn],cnt,ccnt;
typedef pair<int ,int>pii;
vector<int >son[maxn];
queue<pii >q;
void bfs(){
while(!q.empty()){
ccnt++;
int u=q.front().first;
int fa=q.front().second;
q.pop();
h[u]=h[fa]+1;
used[u]=1;
if(!vis[fa])vis[u]=1,cnt++;
for(int i=0;i<son[u].size();i++){
int y=son[u][i];
if(y==fa)continue;
if(used[y]){
if(h[y]==h[u]||abs(h[u]-h[y])&1){
puts("Impossible");
exit(0);
}
}
else{
q.push(MK(y,u));
}
}
}
}
int main(){
scanf("%d%d",&n,&m);
for(int i=1;i<=m;i++){
int a,b;
scanf("%d%d",&a,&b);
if(a==b)continue;
son[a].push_back(b);
son[b].push_back(a);
}
vis[1]=1;
int ans=0;
for(int i=1;i<=n;i++){
ccnt=cnt=0;
if(!used[i]){
q.push(MK(i,0));
       bfs();
}
ans+=min(cnt,ccnt-cnt);
}
printf("%d",ans);
return 0;
}
```

---

## 作者：Mys_C_K (赞：1)

见到楼下有用C++的选手写的深搜dfs和用邻接表的大神，在这里补一个用类邻接表广搜bfs；但是如果不用C++的STL的vector容器优化的话，就只有70分的样子；另一方面，补充一点对于每个图都要计算黑白点的最小值（表示因此被困了30分）

```cpp

//Coding P1330
#include<iostream>
#include<algorithm>
#include<vector>
#define White 1    //no animal
#define Black 2    //an animal
#define No_Color 0    //haven't search
using namespace std;
int color[10001];
vector<int> g[10001];
int p[10001],fp,rp,sum=0,pans,psum;
int n,m;bool f;
int opposite_color(int color_k)
{
    return color_k==White?Black:White;
}
int BFS(int x)
{
    p[fp=rp=1]=x;
    color[x]=Black;
    pans=0;pans++;
    psum=0;psum++;
    while(fp<=rp)
    {
        int u=p[fp++];
        for(int i=0;i<g[u].size();i++)
        {
            int v=g[u][i];
            if(color[v]==No_Color)
            {
                color[v]=opposite_color(color[u]);
                if(color[v]==Black) pans++;
                p[++rp]=v;psum++;
            }
            else if(color[v]!=No_Color&&color[v]==color[u])
            {
                f=false;
                return 0;
            }
        }
    }
    return 0;
}
int main()
{
    f=true;cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int u,v;cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=n;i++)
        if(color[i]==No_Color)
        {
            BFS(i);
            sum+=min(pans,psum-pans);
            if(f==false) break;
        }
    if(f==true) cout<<sum<<endl;
    else cout<<"Impossible"<<endl;
    return 0;
}

```

---

## 作者：QWsin (赞：1)

**
我说一句：

图不一定连通

woc我都被坑了多少次了

noip就被坑了

然后就是二分染色

**
```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=10000+10;
const int maxm=100000+10;

int first[maxn],next[2*maxm],u[2*maxm],v[2*maxm];
int n,m;

void add_edge(int u,int x)
{
    next[x]=first[u];
    first[u]=x;
}

void init_data()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) first[i]=-1;
    for(int i=1;i<=2*m;i+=2)
    {
        scanf("%d%d",&u[i],&v[i]);
        u[i+1]=v[i];
        v[i+1]=u[i];
        add_edge(u[i],i);
        add_edge(v[i],i+1);
    }
}

int cnt1,cnt2,color[maxn];
bool erfenranse(int u)
{
    if(color[u]==1) cnt1++;
    else if(color[u]==2) cnt2++;
    for(int i=first[u];i!=-1;i=next[i])
    {
        if(color[v[i]] == color[u]) return false;
        if(!color[v[i]])
        {
            color[v[i]] =3-color[u];
            if(!erfenranse(v[i])) return false;
        }
    }
    return true;
}

int main()
{
    init_data();
    memset(color,0,sizeof(color));
    int ok=1,ans=0;
    for(int i=1;i<=n;i++)
      if(!color[i])
      {
        color[i]=1;cnt1=cnt2=0;
        if(erfenranse(i)) ans+=min(cnt1,cnt2);
        else {ok=0;break;}
      }
    if(ok) printf("%d",ans);
    else printf("Impossible\n");
    return 0;
}


```

---

## 作者：xizeroplus (赞：1)

题目要求每条边的两个端点有且只有一个被封锁，可以对图进行黑白染色，若不存在染色方案则无解，若存在染色方案则答案为两种颜色中所用次数较少的那种的次数。

```cpp

#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> g[10003];
bool vis[10003];
int a[10003];
int t[2];

bool dfs(int u,int col)
{
    vis[u]=true;
    a[u]=col;
    t[col]++;
    for (int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if (vis[v]&&a[v]==a[u])
            return false;
        else if (!vis[v])
        {
            bool flag=dfs(v,(col+1)&1);
            if (!flag)
                return false;
        }
    }
    return true;
}

int main()
{
    int n,m,i,j;
    scanf("%d%d",&n,&m);
    for (i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    int ans=0;
    for (i=1;i<=n;i++)
        if (!vis[i])
        {
            t[0]=t[1]=0;
            bool flag=dfs(i,0);
            if (!flag)
            {
                printf("Impossible\n");
                return 0;
            }
            ans+=min(t[0],t[1]);
        }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：姬小野 (赞：1)

1.第一反应是这是一道图染色问题,因为相邻两个点有冲突,但分析发现不是(或者说不这么裸的是).
2.难道是模拟每一个结点开始进行遍历,看最后结果哪个更少是哪个? 不太可能,数据太大了.
3.想到一种方法:把一张图按照bfs分奇数层和偶数层,看哪个层点数最少,结果就是哪个. 如果同一层之间有点相
连那么就Impossible. 发现可能是对的? 
4.感觉像是从一张图中找出一棵生成树, 这棵树的层数是最小的.

----------
综上所述: 
相邻两个点之间一定有一个是有河蟹的,因为会有一条边. 那么就有两种状态: 染色或者不染色,那么用bfs分层,
一层黑一层白,哪种层点少就选哪层,同一层有邻边的Impossible. 一句话(我创的):黑白互斥层染色问题. 
如何解决同一层的点之间有边的情况? 
: 记录层次,发现从一个点扩展过来的点已经有层次了而且是和自己一个层,其实只有三种,上一层这一层下一层
上一层跳过,这一层Impossible(中途返回),下一层push,就ok了,回国头来统计黑白层点数量. 
因为会比较层次,所以不像传统的遍历是建立visit数组,而是建立层数数组,以便互斥分析和结果统计. 

---------- 
结果只有40分. 似乎是这张图不一定是连通图, 所以要增加处理这是个问题: 我有好多次都没有考虑图的联通性,以后一定要注意. 
结果还是40分, 之前对的又有错了,之前错了又有对的.怎么会这样. 
原因是重复判断了之前找过的点,加个vis数组去重.
然而现在是50分,该不会是思路出了问题吧.
妥协了,去看题解学习学习. 
看题解发现思路差不多的,于是返回,找到了一个很明显的bug.原来是我之前转移到多连通图时有几行代码要修
改,但是我漏掉了一个地方, 所以出错了. 
OK, 不完美地结束了. 经过思考对思维还是有一定地训练的.
```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;

const int maxn = 10005;
int n, m;
vector<int> G[maxn]; // 邻接表存储. 
int layers[maxn] = {}; // 初始都是-1层 
bool vis[maxn] = {};

bool bfs(int i)
{
	queue<int> que;
	que.push(i);
	layers[i] = 1;
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		for (int i = 0; i < G[u].size(); ++i) {
			int v = G[u][i];
			if (layers[v] == layers[u] - 1) continue; // 遍历到了上一层,分过层了continue 
			if (layers[v] == layers[u]) return false;  // 遍历到了同一层 
			layers[v] = layers[u] + 1;  // 下一层那就加上去. 
			que.push(v);
		}
	}
	return true;
}

int main()
{
	memset(layers, -1, sizeof(layers));
	cin >> n >> m;
	for (int i = 0; i < m; ++i) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) {
		if (layers[i] == -1) {
			//cout << "i = " << i << endl;
			if (!bfs(i)) {
				cout << "Impossible";
				return 0;
			} else {
				int odd = 0, even = 0;
				for (int i = 1; i <= n; ++i) {
					if (layers[i] + 1 && !vis[i]) {
						vis[i] = true;
						if (layers[i] & 1) odd++;
						else even++;
					}
				}
				//cout << min(even, odd) << endl; 
				ans += min(even, odd);
			}
		}
	}
	cout << ans;
}
```

---

## 作者：yangyujia18 (赞：0)

暴力大法好啊！！！  
大家都写dfs，我来写一篇bfs  
二分图染色板子题，没什么好说的  
bfs的框架没什么好说的，就是要开一个结构，压编号的同时压入颜色，如果和之前记录的颜色不同直接输出Impossible然后结束  
坑点：
#### 这个图不一定联通！  
比如这个数据（应该是case#3）  
输入：  
30 12  
18 12  
11 5  
5 30  
15 23  
28 2  
12 2  
3 26  
7 28  
25 22  
4 3  
27 22  
6 9  

输出：  
7  
这个数据不连通，所以我们要循环判断每一个点，如果这个点之前没有被搜到就搜  
答案统计也有一些技巧，每次分别统计两种颜色的个数，搜完以后选一个小的加到总答案上  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=0,ans1=0,ans2=0;
bool arr[10005],color[10005];
vector<int> mp[10005];
struct qu
{
	int num;
	bool c;
};
bool bfs(int st)
{
	ans1=0;
	ans2=0;
	if(arr[st])
		return true;
	queue<qu> q;
	q.push(qu{st,true});
	color[st]=1;
	while(!q.empty())
	{
		int now=q.front().num;
		bool col=q.front().c;
		q.pop();
		if(arr[now]&&col==color[now])
			continue;
		else if(arr[now])
			return false;
		color[now]=col;
		arr[now]=true;
		if(col)
			ans1++;
		else
			ans2++;
		for(int i=0;i<mp[now].size();i++)
			if(color[mp[now][i]]!=col||!arr[mp[now][i]])
				q.push(qu{mp[now][i],!col});
	}
	return true;
}
int main()
{
	memset(arr,false,sizeof(arr));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		mp[u].push_back(v);
		mp[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
	{
		if(!bfs(i))
		{
			cout<<"Impossible"<<endl;
			return 0;
		}
		ans+=min(ans1,ans2);
	}
	cout<<ans<<endl;
	return 0;
}
```
这个题目描述很有趣，谐音梗用的特别好，仔细思考起来很有深意

---

## 作者：TEoS (赞：0)

看到题目，一下子就想到了~~大法师~~dfs。然而身为一个蒟蒻，我把一道思路清晰算法明显的dfs题写到了MLE...

于是我打算讲一下如何把像我这种蒟蒻的裸dfs做法从MLE弄到AC。这当然很简单了，我们可以翻开lyd~~大爷~~大佬的蓝书，打开0x01节。lyd在蓝书一开始就给我们讲了一些~~毒瘤~~实用的东西。没错，只要用状态压缩就可以轻松变AC了。

接下来是状态压缩的几步基本操作：

- 取出整数n在二进制表示下的第k位： (n>>k)&1
- 对整数n在二进制表示下的第k位赋值1： n|(1<<k)

思路：整个图分为几个互不相连的连通块，对于每个连通块的每条边，它的两个端点必须有且只有一只河蟹。也就是说，设一条边的端点分别为A,B，则河蟹要么在A上，要么在B上，所以我们分两种情况，对于每条边，分别设河蟹在A上或在B上，然后进图的遍历，若在同一种情况中一条边的两个端点都有河蟹，则不成立。因此我们可以想到对图进行染色，两种情况分别为黑白两色，其中对于每个连通块中需要的点数更少的答案的和就是最终的答案。

我们定义几个数组分别存储每个节点的颜色和与其相连的边的信息以及它是否被访问过。最简单的方法当然是定义一个二维数组，edge[x][y]存储从x到y是否有边，然而这样会TLE，于是就想到了状态压缩了。只要对这个二维数组进行压缩就可以明显地减少空间复杂度。

代码：
```cpp
#include<iostream>
using namespace std;
const int N=2e4;
int n,m,ans=0,b,w,v[N],color[N],edge[N][N/30];//b、w分别存储当前连通块中黑色与白色的节点个数，v、color数组分别存储每个节点的访问情况和颜色，edge数组存边
bool over=false;//判断是否合法
void dfs(int now,int c)
{
	if(over)
		return ;//如果已经不合法则返回即可
	if(c==1)
	{
		w++;
		c=2;
	}
	else
	{
		b++;
		c=1;
	}//染成与上一个节点不同的颜色并统计
	v[now]=1;//访问标记
	color[now]=c;//存储颜色
	for(int i=1;i<=n;i++)
		if((edge[now][i/30]>>(i%30))&1)//若当前节点到i节点有边
			if(color[i]==c && !over)
			{
				cout<<"Impossible";
				over=true;
			}//若当前节点与i节点颜色相同并且没有标记过不合法
			else
				if(!v[i])
					dfs(i,c);//若i节点没有访问过，则访问它
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		edge[x][y/30]=edge[x][y/30]|(1<<(y%30));
		edge[y][x/30]=edge[y][x/30]|(1<<(x%30));
	}//输入并存边
	for(int i=1;i<=n;i++)
		if(!v[i])
		{
			b=0;
			w=0;//初始化
			dfs(i,0);
			if(over)
				return 0;//若不合法则结束程序
			ans+=min(b,w);//答案加上两个颜色所占据的节点更少的一个
		}
	cout<<ans;
	return 0;
}
```


---

## 作者：Tanktt (赞：0)

这道题是一道思维题。

对于每个点，我们可以用0/1标记，从当前的点延伸出去的点就要与当前点的标记不同，如果查找到两点标记相同，则无法封锁。当然这不可能一次就搞定，需要把每个点都查找一遍，每次加上0/1个数的较小值即可。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,edge,nex[200012],head[20012],vet[200012],vis[20012],ans;
int sum[3];
bool flag;
inline void addedge(int u,int v)
{
    nex[++edge]=head[u];
    head[u]=edge;
    vet[edge]=v;
}
inline void dfs(int u,int fa)
{
    if (flag) return;
    if (vis[u]>-1)
        if (vis[u]==vis[fa]) {flag=1;return;}
        else return;
    vis[u]=1^vis[fa];
    sum[vis[u]]++;
    int e,v;
    for (e=head[u];v=vet[e],e;e=nex[e])
    if (v!=fa)
    {
        dfs(v,u);
        if (flag) return;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    int x,y;
    for (int i=1; i<=m; i++) scanf("%d%d",&x,&y),addedge(x,y),addedge(y,x);
    for (int i=1; i<=n; i++) vis[i]=-1;
    for (int i=1; i<=n; i++)
    if (vis[i]==-1) 
    {
    	sum[0]=sum[1]=0;
        flag=0,dfs(i,0);
        if (flag) return printf("Impossible"),0;
        ans+=min(sum[0],sum[1]);
    }
    return printf("%d\n",ans),0;
}
```

---

## 作者：LoliconAutomaton (赞：0)

这道题目感觉就是二分图（没有奇圈，可以分为两个点集，而且没有一条边连接同一个点集里的两个点）的判定，方法是用dfs进行二着色：首先假设每一个连通分量的第一个被访问到的结点颜色为1，然后边dfs边着色，遇到冲突的就是不可能的。然后对于一次染色，把答案加上两种颜色个数里较小的一个就可以了。

```cpp
#include <cstdio>
#include <cstdlib>
#define maxn 10100
#define maxm 100100
#define min(a, b) a < b ? a : b

int n, m, x, y;
int cnt[3], ans;

struct Edge {
    int to, nxt;
};

struct Graph {
    int tot, head[maxn], col[maxn];
    Edge e[maxm << 1];
    Graph(void) { tot = 1; }

    inline void AddEdge(const int& u, const int& v) {
        e[tot] = (Edge) {v, head[u]}, head[u] = tot++;
        e[tot] = (Edge) {u, head[v]}, head[v] = tot++;
    }

    inline void bipaint(int u) {
        for (register int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (col[v] == col[u]) printf("Impossible"), exit(0);
            if (!col[v]) {
                ++cnt[col[v] = 3 - col[u]];
                bipaint(v);
            }
        }
    }
} opt;

int main()
{
    //freopen("test.in", "r", stdin);
    scanf("%d%d", &n, &m);
    for (register int i = 1; i <= m; ++i) scanf("%d%d", &x, &y), opt.AddEdge(x, y);
    for (register int i = 1; i <= n; ++i) if (!opt.col[i]) {
        opt.col[i] = 1;
        cnt[1] = 1, cnt[2] = 0;
        opt.bipaint(i);
        ans += min(cnt[1], cnt[2]);
    }
    printf("%d", ans);
    return 0;
}
```

---


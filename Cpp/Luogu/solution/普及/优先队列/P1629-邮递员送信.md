# 邮递员送信

## 题目描述

有一个邮递员要送东西，邮局在节点 $1$。他总共要送 $n-1$ 样东西，其目的地分别是节点 $2$ 到节点 $n$。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有 $m$ 条道路。这个邮递员每次只能带一样东西，并且**运送每件物品过后必须返回邮局**。求送完这 $n-1$ 样东西并且**最终回到邮局**最少需要的时间。

## 说明/提示

对于 $30\%$ 的数据，$1 \leq n \leq 200$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^3$，$1 \leq m \leq 10^5$，$1\leq u,v \leq n$，$1 \leq w \leq 10^4$，输入保证任意两点都能互相到达。

## 样例 #1

### 输入

```
5 10
2 3 5
1 5 5
3 5 6
1 2 8
1 3 8
5 3 4
4 1 8
4 5 3
3 5 6
5 4 2```

### 输出

```
83```

# 题解

## 作者：寒鸽儿 (赞：186)

dijkstra的裸题吧。  
正着走过去的时候用一便dijkstra。  
返回时就建个返图跑一遍dijkstra。  
反图可以把所有结点的编号$+n$建在原图的体系中。  
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define ll long long

using namespace std;

const int maxn = 1234, maxm = 123456;
ll inf = 9000000000000000;
int head[maxn << 1], ver[maxm << 1], wei[maxm << 1], nex[maxm << 1], tot, n;
void addedge(int u, int v, int w) {
    ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
}

struct nodeq {
    int x;
    ll dis;
    nodeq(int X, ll DIS) :  x(X), dis(DIS) {}
    bool operator > (const nodeq& o) const { return dis > o.dis; }
};
priority_queue< nodeq, vector<nodeq>, greater<nodeq> > q;
ll dis[maxn << 1];
void dij(int s) {
    for(int i = 1; i <= n << 1; ++i) dis[i] = inf;
    dis[s] = 0;
    q.push(nodeq(s, 0));
    while(!q.empty()) {
        nodeq cur = q.top(); q.pop();
        if(dis[cur.x] < cur.dis) continue;
        for(int i = head[cur.x]; ~i; i = nex[i]) {
            if(dis[ver[i]] > cur.dis + wei[i]) {
                dis[ver[i]] = cur.dis + wei[i];
                q.push(nodeq(ver[i], dis[ver[i]]));
            }
        }
    }
}

int main() {
    memset(head, -1, sizeof(head));
    int m, u, v, w;
    ll ans = 0;
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; ++i) {
        scanf("%d %d %d", &u, &v, &w);
        addedge(u, v, w);
        addedge(v + n, u + n, w);
    }
    dij(1);
    for(int i = 2; i <= n; ++i) ans += dis[i];
    dij(1 + n);
    for(int i = 2 + n; i <= n << 1; ++i) ans += dis[i];
    printf("%lld\n", ans);
    return 0;
}

```


---

## 作者：Del_Your_Heart (赞：136)

# $N^3$过万，爆踩标算
# $Floyed AC$
# 蒟蒻的福音

------------
**看到题解里没有用$Floyed$ $AC$的，我就来凑个热闹。**

**这题是妥妥的最短路，可是本蒟蒻不会打$dijkstra$堆优化，也不会打某已死算法，只好用$Floyed$+指令集优化水掉这道题，求巨佬轻喷。（逃**

**代码如下：**
```cpp
// luogu-judger-enable-o2
// C++11
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#include <immintrin.h>
#include <emmintrin.h>
#include <bits/stdc++.h>
#define ri register int
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int n,m,dis[1005][1005];
int main(){
    memset(dis,0x3f,sizeof(dis));
    n=read();m=read();
    for(ri i=1,x,y,z;i<=m;++i){
        x=read();y=read();z=read();
        dis[x][y]=min(dis[x][y],z);
    }
    for(ri k=1;k<=n;++k)
        for(ri i=1;i<=n;++i)
            for(ri j=1;j<=n;++j)
                dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]);
    int ans=0;
    for(ri i=2;i<=n;++i)
        ans+=(dis[i][1]+dis[1][i]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：DeviRunner (赞：115)

废话不说，直接切正题：

首先，只看邮递员出发去送信的过程，会发现这是单源最短路径。

但是，这道题远远没有这么简单。

再看邮递员回来，会发现这变成了多源单终点的最短路径。

这时，小伙伴们就要想了：用多源最短路径吧！

恭喜你，你可以拿到40分。

由于多源最短路径的算法时间复杂度较大，用在这里显然太慢了。

所以，这个时候就要开脑洞了：

1.本题为带权有向图；

2.去的时候是一到多，回来的时候是多到一；

3.所以回来的时候如果也是一到多就完美了。

所以，我们就有了一个关键性的突破点：把邻接矩阵倒过来！

下面关嘴放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005][1005],d[1005],i,j;
const int INF=1e9;
void chushi(int n)//邻接矩阵初始化
{
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            if(i!=j)
            a[i][j]=INF;//求最短要初始化为无限大
        }
    }
}
void dij(int n)//单源最短路径
{
    bool f[1005]={0};
    f[1]=1;
    int v;
    for(i=1;i<n;i++)
    {
        int min=INF;
        for(j=1;j<=n;j++)
        {
            if(!f[j]&&min>d[j])//找未标记中最小的
            {
                min=d[j];
                v=j;
            }
        }
        f[v]=1;//标记
        for(j=1;j<=n;j++)
        {
            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度
            {
                d[j]=a[v][j]+d[v];
            }
        }
    }
}
void over(int n)//翻转
{
    for(i=1;i<=n;i++)
    {
        for(j=i+1;j<=n;j++)//菜鸟级知识不解释
        {
            int t=0;
            t=a[i][j];
            a[i][j]=a[j][i];
            a[j][i]=t;
        }
    }
}
int main()
{
    int n,m,x,y,z;
    cin>>n>>m;
    chushi(n);
    for(i=1;i<=m;i++)
    {
        cin>>x>>y>>z;
        a[x][y]=min(a[x][y],z);//避坑：防止同一条路多次输入！
    }
    for(i=1;i<=n;i++)
    {
        d[i]=a[1][i];//路径长度初始化
    }
    dij(n);
    int ans;
    for(i=1;i<=n;i++)
    {
        ans+=d[i];
    }
    over(n);//翻转
    for(i=1;i<=n;i++)//路径长度初始化
    {
        d[i]=a[1][i];
    }
    dij(n);
    for(i=1;i<=n;i++)
    {
        ans+=d[i];//求和
    }
    cout<<ans<<endl;//华丽地输出
    return 0;
}
```

---

## 作者：crzyz (赞：88)

P1629 邮递员送信题解报告

分析：这是一道最短路问题，我们首先想到了floyd，dijkstra，bellman-ford（spfa）算法，但是这道题n<=1000且路径距离皆为正整数，所以用dijkstra或bellman，这题我用了bellman。

但是我们又看到，这是有向图，而且邮递员送完货物之后还要返回，也就是说我们从一到多跑完最短路后还要从多到一跑回来，从一到多很容易，但是从多到一怎么办呢？

这时候我们想：
#### 假设要问从x到1的最短路，为x->a->b->c->1,也就是说x->a,a->b,b->c,c->1都有路可走，那么我们想想，从x开始x->a,a->b,b->c,c->1的最短路不就是从1开始1->c,c->b,b->a,a->x的最短路吗？于是这时，我们把x->a,a->b,b->c,c->1这4条路径变为1->c,c->b,b->a,a->x，然后从1开始跑最短路，而它们的最短路是一样的。

我们把这样从多到一的最短路变式的路径反转操作称作“**反向建边**”。

其他注释放到代码里，还有一点，我用的bellman没加队列优化.

耗时/内存1809ms, 1936KB

Code:
```
#include<bits/stdc++.h>
using namespace std;
const int INF=99999999;//定义最大值。注意不要设0x7fffffff, 加的时候会爆int 
int n,m;
int u[100005],v[100005],w[100005];//开好数组，别RE了 
int dis[1005];
void init(){//初始化 
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)scanf("%d%d%d",&u[i],&v[i],&w[i]);// u起，v终，w长度 
}
void over(){//这是一个反向建边的函数，把起点和终点互换 ，好让邮递员返回时从多到一跑最短路 
	for(int i=1;i<=m;i++){
		swap(u[i],v[i]);
	}
} 
void ford(){//标准bellman-ford模板 
	for(int i=1;i<=n;i++)dis[i]=INF;
	dis[1]=0;
	for(int k=1;k<=n-1;k++){
		for(int i=1;i<=m;i++){
			if(dis[v[i]]>dis[u[i]]+w[i]){
				dis[v[i]]=dis[u[i]]+w[i];
			}
		}
	}
}
int main(){
	init();
	int ans=0;
	ford();//跑最短路 
	for(int i=1;i<=n;i++)ans+=dis[i];//从一到多 
	over();//反转，反向建边 
	ford();//跑最短路 
	for(int i=1;i<=n;i++)ans+=dis[i];//从多到一 
	printf("%d\n",ans);
	return 0;//完结撒花
}
//代码甚短qwq 


---

## 作者：WSQTCL (赞：42)

我这个蒟蒻第一眼看到这个题
哇！我只要开1次SPFA就能A了，这题真水！

****当我看题目时:哇！每次只能带1个信件，要回去拿！也就n次SPFA吧！

这时我看到了数据范围，N次SPFA一定炸

于是我想到了一个好方法，用1次SPFA找各个点到点1的最短路

然后开一个反向图，再用SPFA搜一下点1到反向图各个点的最短路

这时我们发现反向图中点1到各个点的最短路就是普通图中各个点到点1的最短路！！！

话不多说上代码

```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,m,q[1001*1001][2],e[1001][1001][2],head,tail,x,y,z,vis[1001],vis1[1001],ans;
//q代表队列，VIS代表点1到各个点的最短路，VIS1的作用后面你会知道
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			vis[i]=2147483647;
			e[i][j][0]=e[i][j][1]=2147483647;//神奇的初始化
		}
	}
	vis[1]=0;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		e[x][y][0]=min(e[x][y][0],z);//普通图
		e[y][x][1]=min(e[y][x][1],z);//反向图
	}
	head=1;tail=1;q[head][0]=1;q[head][1]=0;//初始化队列
	while(head<=tail)
	{
		for(int i=1;i<=n;i++)
		{
			if(e[q[head][0]][i][0]==2147483647) continue;
			int ns=q[head][1]+e[q[head][0]][i][0];
            //ns用来更新路径长
			if(ns>vis[i]) continue;
			tail++;q[tail][0]=i;q[tail][1]=ns;
			vis[i]=ns;
		}
		head++;
	}
	for(int i=2;i<=n;i++)
	{
		vis1[i]=vis[i];//我们把之前算好的vis的值赋给vis1
    	//不要问我为什么这样，我只是一个小蒟蒻
		vis[i]=2147483647;
	}
	head=tail=1;q[head][0]=1;q[head][1]=0;
	while(head<=tail)
	{
		for(int i=1;i<=n;i++)
		{
			if(e[q[head][0]][i][1]==2147483647) continue;
			int nns=q[head][1]+e[q[head][0]][i][1];
			if(nns>vis[i]) continue;
			tail++;q[tail][0]=i;q[tail][1]=nns;
			vis[i]=nns;
		}
		head++;
	}//原理同上不多解释
	for(int i=2;i<=n;i++) ans=ans+vis[i]+vis1[i];
    //得出点1到各个点的最短路和各个点到点1的最短路的和
	cout<<ans;//完美输出
}
```

---

## 作者：莫德里奇 (赞：22)

这是我们昨天考试的题目，我首先敲了一个**Dijkstra**，然后敲了一个Floyed，然后比较时间，Floyed确实要快

但是！

我拿了前几次考试的图论题数据来测，发现事情并不只有这么简单

Floyed总是比Dijkstra跑出来的要大，我就很纳闷了

结论：**用Floyed（也就是邻接矩阵存图）一定要判重边，重边，重边**

###Floyed 判重边 ——40分

```cpp
inline void Floyed()
{
    for (int k=1;k<=n;k++)
    {
        for (int i=1;i<=n;i++)
        {
            if (dist[i][k]<INF)
                for (int j=1;j<=n;j++)
                    if (dist[i][j]>dist[i][k]+dist[k][j])
                        dist[i][j]=dist[i][k]+dist[k][j];
        }
    }
    for (int i=2;i<=n;i++)
        tot=tot+dist[1][i]+dist[i][1];
    printf("%d\n",tot);
}
###Dijkstra——未知（没有测）
inline void Dijkstra(int Modric)
{
    priority_queue<HeapNode> Q;
    for (int i=1;i<=n;i++) dis[i]=INF;
    dis[Modric]=0;
    memset(exist,0,sizeof(exist));
    Q.push((HeapNode){0,Modric});
    while (!Q.empty())
    {
        HeapNode x=Q.top();Q.pop();
        int u=x.u;
        if (exist[u]) continue;
        exist[u]=true;
        for (int i=head[u];i;i=edge[i].next)
        {
            int temp=edge[i].to;
            if (dis[temp]>dis[u]+edge[i].v)
            {
                dis[temp]=dis[u]+edge[i].v;
                Q.push((HeapNode){dis[temp],temp});
            }
        }
    }
}
```
###SPFA——70分 代码就不贴了
**正解**

**求其他点到源点的距离不需要枚举其他点跑最短路，建反向边就可以了…**

在普通的Dijkstra加上个“f”

    
```cpp
inline void add(int x,int y,int v)
{
    edge[++cnt].to=y;
    edge[cnt].v=v;
    edge[cnt].next=head[x];
    head[x]=cnt;
    fedge[cnt].to=x;
    fedge[cnt].v=v;
    fedge[cnt].next=fhead[y];
    fhead[y]=cnt;
}
```
变量也是
```cpp
int dis[maxn],n,m,ans;
bool exist[maxn];
int fdis[maxn];
bool fexist[maxn];
```
然后跑两遍Dijkstra——AC
    

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#define INF (1<<30)-1
#define maxn 200010
#include<queue>
using namespace std;
inline int read()
{    
     int x=0; char ch=getchar();
     while (ch<'0' || ch>'9') ch=getchar();
     while (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }
     return x;
}   
struct HeapNode
{
    int d,u;
    bool operator<(const HeapNode & rhs) const
    {
        return d>rhs.d;
    }
};
struct node
{
    int to,next,v;
}edge[1000000+10],fedge[1000010];
int cnt,head[maxn],fhead[maxn];
inline void add(int x,int y,int v)
{
    edge[++cnt].to=y;
    edge[cnt].v=v;
    edge[cnt].next=head[x];
    head[x]=cnt;
    fedge[cnt].to=x;
    fedge[cnt].v=v;
    fedge[cnt].next=fhead[y];
    fhead[y]=cnt;
}
int dis[maxn],n,m,ans;
bool exist[maxn];
int fdis[maxn];
bool fexist[maxn];
inline void Dijkstra()
{
    priority_queue<HeapNode> Q;
    for (int i=1;i<=n;i++) dis[i]=INF;
    dis[1]=0;
    memset(exist,0,sizeof(exist));
    Q.push((HeapNode){0,1});
    while (!Q.empty())
    {
        HeapNode x=Q.top();Q.pop();
        int u=x.u;
        if (exist[u]) continue;
        exist[u]=true;
        for (int i=head[u];i;i=edge[i].next)
        {
            int temp=edge[i].to;
            if (dis[temp]>dis[u]+edge[i].v)
            {
                dis[temp]=dis[u]+edge[i].v;
                Q.push((HeapNode){dis[temp],temp});
            }
        }
    }
}
inline void FDijkstra()
{
    priority_queue<HeapNode> Q;
    for (int i=1;i<=n;i++) fdis[i]=INF;
    fdis[1]=0;
    memset(fexist,0,sizeof(fexist));
    Q.push((HeapNode){0,1});
    while (!Q.empty())
    {
        HeapNode x=Q.top();Q.pop();
        int u=x.u;
        if (fexist[u]) continue;
        fexist[u]=true;
        for (int i=fhead[u];i;i=fedge[i].next)
        {
            int temp=fedge[i].to;
            if (fdis[temp]>fdis[u]+fedge[i].v)
            {
                fdis[temp]=fdis[u]+fedge[i].v;
                Q.push((HeapNode){fdis[temp],temp});
            }
        }
    }
}
int main()
{
    freopen("post.in","r",stdin);
    freopen("post.out","w",stdout);
    int x,y,v;
    n=read();m=read();
    for (int i=1;i<=m;i++)
    {
        x=read(),y=read(),v=read();
        add(x,y,v);
    }
    Dijkstra();FDijkstra();
    for (int i=2;i<=n;i++)
        ans=ans+dis[i]+fdis[i];
    printf("%d\n",ans);
}
```

---

## 作者：菜鸡gyf (赞：19)

简单的最短路问题，此题n<=1000,m<=100000,建议使用dijkstra或SPFA。**道理我都懂，可是我就是要用Floyd！**

Floyd吸氧之后是可以卡过去的，
```
#include<iostream>
#include<cstdio>
using namespace std;
long long f[1001][1001];
int main()
{
    long long i,n,m,u,v,w,j,k,ans=0;
    scanf("%lld%lld",&n,&m); 
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    f[i][j]=0x7fffffff;
    for(i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld",&u,&v,&w);
        f[u][v]=min(f[u][v],w);
    }
    for(k=1;k<=n;k++)
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    if(f[i][j]>f[i][k]+f[k][j])
    f[i][j]=f[i][k]+f[k][j];//Floyd核心语句 
    for(i=2;i<=n;i++)
    ans+=f[1][i]+f[i][1];// 计算总长度，每次只能带一件，即为 1到i距离加上i到1距离 
    printf("%lld",ans);
    return 0;
}
```

蒟蒻的第二篇题解，求通过。

---

## 作者：Dog_Two (赞：11)

Dij+heap


我第一遍过这道题其实是跑了n遍Dij+heap （Floyd居然WA0分）


~~氧气优化简直是作弊神器啊~~


前面写题解的老哥无论是用的spfa还是Dij，都是写了两遍函数，这样的做法在竞赛中其实并不值得推崇。


- 如果最终结果有错误，那么双份的调试，会极大提高调试的难度，浪费很多的时间


- 对于某些情况及其复杂的题目，巨大的代码量无疑对于选手是一种巨大的折磨，增加了代码出错的可能性


- 作为未来电子吴克队伍的其中一员，冗长又不易修改的代码可是很不适合经常需要修改的工作的


### 所以我们要在不影响可读性的情况下，尽量减少冗余函数的数量√


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+10,maxm=1e5+10;
int n,m;
struct edge{int u,v,w;};
struct Node{
    int u,d;
    bool operator < (Node tmp) const {
        return d>tmp.d;
    }
};

priority_queue<Node>q;
//每次Dij必然保证最后队列为空，所以只需要一个 
vector<int>tow[maxn],bac[maxn];
edge tow_E[maxm],bac_E[maxm];
int tow_dis[maxn],bac_dis[maxn];
bool tow_vis[maxn],bac_vis[maxn];
//双倍Dij+heap的必备数组 
void add_E(int u,int v,int w,int cnt,bool if_rev){
    //if_rev表示是否是逆向边，true则逆向加边 
    if(if_rev){
        bac_E[cnt]=(edge){u,v,w};
        bac[u].push_back(cnt);
        return;
    }
    tow_E[cnt]=(edge){u,v,w};
    tow[u].push_back(cnt);
}
void readin(){
    cin>>n>>m;
    int from,to,cost;
    for(int i(1);i<=m;++i){
        scanf("%d%d%d",&from,&to,&cost);
        add_E(from,to,cost,i,false);
        add_E(to,from,cost,i,true);
    }
}
void Dijkstra(int *dis,vector<int> *road,bool *vis,edge *E,int St){
    //用数组指针作为函数参数，实现了同一函数的不同使用对象 
    fill(dis+1,dis+n+1,0x3f3f3f3f);
    fill(vis+1,vis+n+1,false);dis[St]=0;
    q.push((Node){St,0});
    while(!q.empty()){
        Node x=q.top();q.pop();
        if(vis[x.u]) continue;
        vis[x.u]=true;
        for(int i(0);i<road[x.u].size();++i){
            edge e=E[road[x.u][i]];
            if(dis[e.v]>dis[e.u]+e.w){
                dis[e.v]=dis[e.u]+e.w;
                q.push((Node){e.v,dis[e.v]});
            }
        }
    }
}
int main(){
    readin();
    Dijkstra(tow_dis,tow,tow_vis,tow_E,1);
    Dijkstra(bac_dis,bac,bac_vis,bac_E,1);
    int ans=0;
    for(int i(2);i<=n;++i) ans+=tow_dis[i]+bac_dis[i];
    cout<<ans;
    return 0;
}

```

---

## 作者：S_Gloria (赞：10)

## 两遍dijstra

~~其实思路跟楼上写此算法的dalao差不多，~~ 就一点点细节不太同叭QwQ

这个题比较好的方法就是跑两遍最短路应该没有问题，因为边是单向的，所以只需要加边的时候正反加边就是了。

我一般遇到这种题时就直接把函数代码复制一遍，一个dij1一个dij2就算了，但是我突然想到了一种优雅一点的方式，
如下

```cpp
#include<iostream>
#include<stdio.h>
#include<queue>
#include<string.h>
#define M 210000
#define N 1100
using namespace std;
int n,m;
int first[3][N],to[3][N],nex[3][M],v[3][M],tot=0,f[N][3],dis[N][3];
void add(int u,int x,int y,int z)
{
	tot++;
	nex[u][tot]=first[u][x];
	first[u][x]=tot;
	to[u][tot]=y;
	v[u][tot]=z;
}
void dij(int u,int s)
{
	dis[s][u]=0;	
	priority_queue<pair<int,int> >q;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		int x=q.top().second;
		q.pop();
		if(f[x][u])continue;		
		f[x][u]=1;
		for(int i=first[u][x];i;i=nex[u][i])
		{
			int y=to[u][i];
			if(dis[y][u]>dis[x][u]+v[u][i])
			{
				dis[y][u]=dis[x][u]+v[u][i];
				q.push(make_pair(-dis[y][u],y));
			}
		}
	}	
} 
int main()
{
	memset(dis,0x2f,sizeof(dis));
	int x,y,z;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		add(1,x,y,z);
		add(2,y,x,z);
	}	
	int ans=0;
	dij(1,1);	
	dij(2,1);
	for(int i=1;i<=n;i++)
		ans+=dis[i][1]+dis[i][2];
	cout<<ans;
	return 0;
} 
```
这样只要把数组开成二维就好了，分别表示不同的状态，大概对一些需要跑很多遍最短路的题更实用一些。

希望对大家有帮助QwQ~

---

## 作者：ThatXX (赞：10)

[](https://www.luogu.org/problemnew/show/P1629)传送门

思路：正反各建一次边，跑两遍spfa。两次求出的到达对应点的最短路相加即为最终答案

难度：普及/提高-

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
#define M 100001
#define maxn 999999
using namespace std;
queue<int> q;
int n,m,tot,tat;
int u,v,w[M];
int dis1[M],dis2[M],vis[M];
int to1[M],net1[M],head1[M];
int to2[M],net2[M],head2[M];
void add1(int u,int v,int z) {
    to1[++tot]=v; net1[tot]=head1[u]; head1[u]=tot; w[tot]=z;
}
void add2(int u,int v,int z) {
    to2[++tat]=v; net2[tat]=head2[u]; head2[u]=tat; w[tat]=z;
}
void spfa1(int x) {
    for(int i=1; i<=n; i++) {
        dis1[i]=maxn;
        vis[i]=0;
    }
    dis1[x]=0,vis[x]=1,q.push(x);
    while(!q.empty()) {
        int y=q.front(); q.pop(); vis[y]=0;
        for(int i=head1[y]; i; i=net1[i]) {
            int t=to1[i];
            if(dis1[t]>dis1[y]+w[i]) {
                dis1[t]=dis1[y]+w[i];
                if(!vis[t]) vis[t]=1,q.push(t);
            }
        }
    }
}
void spfa2(int x) {
    for(int i=1; i<=n; i++) {
        dis2[i]=maxn;
        vis[i]=0;
    }
    dis2[x]=0,vis[x]=1,q.push(x);
    while(!q.empty()) {
        int y=q.front(); q.pop(); vis[y]=0;
        for(int i=head2[y]; i; i=net2[i]) {
            int t=to2[i];
            if(dis2[t]>dis2[y]+w[i]) {
                dis2[t]=dis2[y]+w[i];
                if(!vis[t]) vis[t]=1,q.push(t);
            }
        }
    }
}
int main() {
    int a=0,b=0;
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++) {
        scanf("%d%d%d",&u,&v,&w[i]);
        add1(u,v,w[i]);
        add2(v,u,w[i]);
    }
    spfa1(1);
    memset(vis,0,sizeof(vis));
    spfa2(1);
    for(int i=1; i<=n; i++) {
        a+=dis1[i];
        b+=dis2[i];
    }
    printf("%d",a+b);
    return 0;
}
```

---

## 作者：hater (赞：4)

看完题意的我

直接从模板上复制下来改了3~~0~~分钟

于是就AC了

看一眼其他题解

？？？？？？？？？？？

一堆大佬反向建图

总共就跑两次 

打暴力的蒟蒻默默%了一波

有的题解说n*nlogn会超时

但好像数据太水 ~~n<=1000~~

于是就决定不再麻烦的改代码了

这个题解给那些不知道为什么要反向建图的OIER一个参考

显然用Dijkstra ~~SPFA已经死了~~

之后外面套一个循环

注意是单向的

每一次跑的时候清零的最大值的都别忘了

最后贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector <int> d[1005];
vector <int> e[1005];
long long dis[1005];
bool vis[1005];
int n,m;
priority_queue<pair<int,int> > q;
void dj(int s)
{
    int temp,y,z;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        temp=q.top().second;
        q.pop();
        if(vis[temp]) continue;
        vis[temp]=1;
        for(int i=0;i<d[temp].size();i++)
        {
            y=d[temp][i]; z=e[temp][i];
            if(dis[y]>dis[temp]+z)
            {
                dis[y]=dis[temp]+z;
                q.push(make_pair(-dis[y],y));
            }
        } 
    }
}
int main() {
    int x,y,z,ans=0;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>x>>y>>z;
        d[x].push_back(y);
        e[x].push_back(z);
    }
    dj(1);
    for(int i=1;i<=n;i++) ans+=dis[i];
    for(int i=2;i<=n;i++) 
    {
    	dj(i);
    	ans+=dis[1];
	}
    cout<<ans<<endl;
    return 0;
}
```
Dijkstra 都不会spell的我 捂脸

---

## 作者：YellowBean_Elsa (赞：3)

刚开始真的很想floyd，但的确TLE.

后来想到，可以见一个反向图，做两次DIJKSTRA！

解释一下反向图为什么有效：
	
用反向图找到一条从a到b的道路后，若翻回原图，则路线会变成b到a。不理解的可以画画图。

贴上普及组爆0者的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int u[100005],v[100005],w[100005],next[100005],first[1005],dis[1005];//原图用 
int u2[100005],v2[100005],next2[100005],first2[1005],back[1005];//反向图用 
bool vis[1005]; 
void init1(){
	memset(vis,false,sizeof(vis));
	memset(dis,0x7f,sizeof(dis));
	dis[1]=0;
}
void init2(){
	memset(vis,false,sizeof(vis));
	memset(back,0x7f,sizeof(back));
	back[1]=0;
}
void dijk1(){
	int p=1,Min;
	for(int i=1;i<n;i++){
		vis[p]=true;
		Min=2147483600;
		for(int j=first[p];j!=-1;j=next[j])
			dis[v[j]]=min(dis[v[j]],dis[p]+w[j]);
		for(int j=1;j<=n;j++){
			if(!vis[j]&&dis[j]<Min){
				p=j;
				Min=dis[j];
			}
		}
	}
}
//反向图 DIJKSTRA 
void dijk2(){
	int p=1,Min;
	for(int i=1;i<n;i++){
		vis[p]=true;
		Min=2147483600;
		for(int j=first2[p];j!=-1;j=next2[j])
			back[v2[j]]=min(back[v2[j]],back[p]+w[j]);
		for(int j=1;j<=n;j++){
			if(!vis[j]&&back[j]<Min){
				p=j;
				Min=back[j];
			}
		}
	}
}
int main(){
	memset(first,-1,sizeof(first));
	memset(first2,-1,sizeof(first2));
	cin>>n>>m;
	//由于M<N^2,所以可以用邻接表 
	for(int i=1;i<=m;i++){
		cin>>u[i]>>v[i]>>w[i];
		next[i]=first[u[i]];
		first[u[i]]=i;
		//**构造反向图** 
		u2[i]=v[i];
		v2[i]=u[i];
		next2[i]=first2[u2[i]];
		first2[u2[i]]=i;
	}
	init1();
	dijk1();
	init2();
	dijk2();
	long long s=0;
	for(int i=2;i<=n;i++)
		s+=dis[i]+back[i];// 每个点去的和回的加起来，得到答案 
	cout<<s<<endl;
	return 0;
}
```

最短路也可以用SPFA，普通Ford不知道能不能压住时间。

---

## 作者：KSToki (赞：3)

这是一道神奇的题目

先介绍一下和这道题意思相似的[水题](https://www.luogu.org/problemnew/show/P1821)
数据太水

然而这道题数据~~过于~~强大，这种做法过不了：

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct stu
{
	int next;
	int to;
	int w;
}t[100001];
int dis[1001],head[1001],tot,n,m,T,cows[1001];
bool visit[1001];
queue<int>q;
void add(int x,int y,int z)
{
	t[++tot].next=head[x];
	t[tot].to=y;
	t[tot].w=z;
	head[x]=tot;//有向图 
//	t[++tot].next=head[y];
//	t[tot].to=x;
//	t[tot].w=z;
//	head[y]=tot;//无向图 
}
void SPFA(int s)
{
	memset(dis,127,sizeof(dis));
	dis[s]=0;
	visit[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		visit[x]=0;
		for(int i=head[x];i;i=t[i].next)
		{
			int y=t[i].to;
			if(dis[y]>dis[x]+t[i].w)
			{
			    dis[y]=dis[x]+t[i].w;
			    if(!visit[y])
			    {
			    	visit[y]=1;
			    	q.push(y);
			    }
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&T);
	int x,y,z,maxx=-0x7fffffff;
	for(int i=0;i<m;++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	SPFA(T);
	for(int i=1;i<=n;++i)
	    cows[i]+=dis[i];
	for(int i=1;i<=n;++i)
	{
		SPFA(i);
		maxx=maxx>cows[i]+dis[T]?maxx:cows[i]+dis[T];
	}
	printf("%d",maxx);
	return 0;
}
```

保证TLE。

所以我们需要思考更高效的算法：

因为这是一个有向图，先看一下如果是无向图，怎么做？

显然，Ans=最短路长度*2（能这么过去，就能这么回来）

那么我们想一想，有向图是不是也可以类似的做？

因为如果能从某个点i到j，那么一定能回去，所以：

**先跑一遍正着的SPFA（或dijkstra），再反着回来**

解释：如果有一条路i->j，没有j->i，那么他就要走另一条路（其他中转点）
      如果都有，同无向图处理（*2）
      
**Code：**
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct stu
{
	int next;
	int to;
	int w;
}t[100001],T[100001];
int dis[1001],head1[1001],head2[1001],tot1,tot2,n,m;
bool visit[1001];
queue<int>q;
void add1(int x,int y,int z)
{
	t[++tot1].next=head1[x];
	t[tot1].to=y;
	t[tot1].w=z;
	head1[x]=tot1;//有向图 
//	t[++tot].next=head[y];
//	t[tot].to=x;
//	t[tot].w=z;
//	head[y]=tot;//无向图 
}
void add2(int x,int y,int z)
{
	T[++tot2].next=head2[x];
	T[tot2].to=y;
	T[tot2].w=z;
	head2[x]=tot2;//有向图 
//	t[++tot].next=head[y];
//	t[tot].to=x;
//	t[tot].w=z;
//	head[y]=tot;//无向图 
}
void SPFA1(int s)
{
	memset(dis,127,sizeof(dis));
	dis[s]=0;
	visit[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		visit[x]=0;
		for(int i=head1[x];i;i=t[i].next)
		{
			int y=t[i].to;
			if(dis[y]>dis[x]+t[i].w)
			{
			    dis[y]=dis[x]+t[i].w;
			    if(!visit[y])
			    {
			    	visit[y]=1;
			    	q.push(y);
			    }
			}
		}
	}
}
void SPFA2(int s)
{
	memset(dis,127,sizeof(dis));
	dis[s]=0;
	visit[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		visit[x]=0;
		for(int i=head2[x];i;i=T[i].next)
		{
			int y=T[i].to;
			if(dis[y]>dis[x]+T[i].w)
			{
			    dis[y]=dis[x]+T[i].w;
			    if(!visit[y])
			    {
			    	visit[y]=1;
			    	q.push(y);
			    }
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y,z,ans=0;
	for(int i=0;i<m;++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		add1(x,y,z);
		add2(y,x,z);
	}
	SPFA1(1);
	for(int i=2;i<=n;++i)
	    ans+=dis[i];
	memset(visit,0,sizeof(visit));
	SPFA2(1);
	for(int i=2;i<=n;++i)
	    ans+=dis[i];
	printf("%d",ans);
	return 0;
}
```

---

## 作者：北极鹅 (赞：3)

~~起初看到这个题，感觉是状压DP？~~

后来发现这句话：

**这个邮递员每次只能带一样东西。**

于是这个题可以这么想：**求出邮局到每个客户的家的最短路，再求出每个客户的家到邮局的最短路，将它们求和就可以。**

对于“求出邮局到每个客户的家的最短路”，跑一次spfa即可；但是，对于“求出每个客户的家到邮局的最短路”，数据规模是n <= 1000，跑n次spfa似乎时间上有压力。事实证明我们也不需要跑n次spfa，因为只需要建立原图的反图，跑一遍spfa就能解决这个问题。

另外Floyd是会超时的，因为Floyd是裸的O(n³)算法，超时肯定难免。

下面贴出代码（~~指针党福利，但是有点工程代码的感觉~~）：
```cpp
#include <cstdio>
#include <cctype>

template <typename T>
class vector {			//不定长数组，用于存边
	private:
		
		virtual void shrink() {	//缩容
			if(_cap < (_size << 2) || _cap <= MIN_items) return;	//以1/4为界
			
			T* olditems = items;
			items = new T[_cap >>= 1];	//容量减半使得vector的push_back()分摊O(1)
			for(register int __I(0); __I < _size; ++__I) {
				items[__I] = olditems[__I];
			}
			
			delete[] olditems;
		}

		virtual void expand() {	//扩容
			if(_cap > _size) return;	//除非满了，不然不扩容
			
			T* olditems = items;
			items = new T[_cap <<= 1];	//容量倍增使得vector的push_back()分摊O(1)
			for(register int __I(0); __I < _size; ++__I) {
				items[__I] = olditems[__I];
			}
			
			delete[] olditems;
		}

	protected:

		T* items;
		int _size;
		int _cap;
		static const int MIN_items = 8;

	public:

		vector() : _size(0) {
			items = new T[_cap = MIN_items];
		}
		
		vector(const T* arrt, int const& __len) {
			_size = _cap = __len;
			items = new T[_cap];
			for(register int __I(0); __I < _cap; ++__I) {
				items[__I] = arrt[__I];
			}
		}
		
		vector(vector<T> const& vec) {
			_size = vec._size;
			items = new T[_cap = vec._cap];
			for(register int __I(0); __I < _size; ++__I) {
				items[__I] = vec.items[__I];
			}
		}
		
		~vector() {
			delete[] items;
		}
		
		T& operator[](int const rank) {
			return items[rank];
		}
		
		vector<T>& operator=(vector<T> const& vec) {
			_size = vec._size;
			items = new T[_cap = vec._cap];
			for(register int __I(0); __I < _size; ++__I) {
				items[__I] = vec.items[__I];
			}
			return *this;
		}
		
		void push_back(T const& v) {
			items[_size++] = v;
			expand();
		}
		
		T pop_back() {
			T __ret = items[--_size];
			shrink();
			return __ret;
		}
		
		virtual int size() {
			return _size;
		}
		
		virtual bool empty() {
			return !_size;
		}
		
		virtual void clear() {
			_size = 0;
			delete[] items;
			items = new T[_cap = MIN_items];
		}
		
		T* begin() {
			return items;
		}
		
		T* end() {
			return (items + _size);
		}
		
		void swap(vector& __vct) {
			T* olditems = this->items;
			this->items = __vct.items;
			__vct.items = olditems;
			
			int old_size = this->_size;
			this->_size = __vct._size;
			__vct._size = old_size;
			
			int old_cap = this->_cap;
			this->_cap = __vct._cap;
			__vct._cap = old_cap;
		}
};

#define real_size (_size - ex_sz)	//队列元素真实数量
template <typename T>
class queue : private vector<T> {	//队列，可以用继承vector实现，用于跑spfa
		using vector<T>::_size;
		using vector<T>::_cap;
		using vector<T>::items;
		using vector<T>::MIN_items;	//使用类vector的成员，简化代码
		
	private:
		
		int ex_sz;					//队首空余元素数量
		
		void shrink() {
			if(_cap < (real_size << 2) || _cap <= MIN_items) return;
			T* olditems = items;
			items = new T[_cap >>= 1];
			for(register int __I(ex_sz); __I < _size; ++__I) {
				items[__I - ex_sz] = olditems[__I];
			}
			delete[] olditems;
			_size -= ex_sz;
			ex_sz = 0;
		}
		
		void expand() {
			if(_cap > _size) return;
			T* olditems = items;
			items = new T[_cap <<= 1];
			for(register int __I(ex_sz); __I < _size; ++__I) {
				items[__I - ex_sz] = olditems[__I];
			}
			delete[] olditems;
			_size -= ex_sz;
			ex_sz = 0;
		}
		
	public:
		
		queue() : ex_sz(0) {}
		queue(queue const& que) : ex_sz(0) {
			_size = que._size - que.ex_sz;
			delete[] items;
			items = new T[_cap = que._cap];
			for(register int __I(que.ex_sz); __I < _size; ++__I) {
				items[__I - que.ex_sz] = que.items[__I];
			}
		}
		
		void push(T v) {
			items[_size++] = v;
			expand();
		}
		
		T pop() {
			T __ret = items[ex_sz++];
			shrink();
			return __ret;
		}
		
		T& front() {
			return items[ex_sz];
		}
		
		int size() {
			return real_size;
		}
		
		bool empty() {
			return !real_size;
		}
		
		void clear() {
			_size = 0;
			ex_sz = 0;
			delete[] items;
			items = new T[_cap = MIN_items];
		}
};
#undef real_size

struct Node {
	vector<Node*> Edges[2];	//正、反边
	vector<int> Pathl[2];	//正、反边长
	int len[2];				//Node[i]的最短路线长（从邮局来、到邮局去）
	bool in_Q;				//spfa中是否已经在队列中
	
	Node() : in_Q(false) {
		len[0] = len[1] = 0x3f3f3f3f;
	}
};
Node* nodes;

int n, m;
int u, v, w;

typedef int TARGET;				//目标方向
const TARGET Post_Office = 1;	//朝向邮局，反边
const TARGET Client_Home = 0;	//朝向客户，正边

int spfa(TARGET tar) {
	nodes[0].len[tar] = 0;
	queue<Node*> Que;
	Que.push(nodes);
	Node* ptn;
	while(!Que.empty()) {
		ptn = Que.pop();
		ptn->in_Q = false;
		for(register int __I(0);__I < ptn->Edges[tar].size();++__I) if(ptn->Edges[tar][__I]->len[tar] > ptn->len[tar] + ptn->Pathl[tar][__I]) {
			ptn->Edges[tar][__I]->len[tar] = ptn->len[tar] + ptn->Pathl[tar][__I];	//松弛
			if(!(ptn->Edges[tar][__I]->in_Q)) {
            	ptn->Edges[tar][__I]->in_Q = true;
				Que.push(ptn->Edges[tar][__I]);
			}
		}
	}
	
	int ans(0);
	for(register int __I(0);__I < n;++__I) {
		ans += nodes[__I].len[tar];
	}
	
	return ans;
}

#define gc getchar()
inline
	int readint() {		//读入优化
	register int ret(0);
	register char c;
	while(isspace(c = gc));
	while(isdigit(c)) {
		ret = (ret << 3) + (ret << 1) + (c ^ 0x30);
		c = gc;
	}
	return ret;
}
#define ri readint()

int main() {
	n = ri;
	m = ri;
	nodes = new Node[n];
	for(register int i(0);i < m;++i) {	//读图
		u = ri - 1;
		v = ri - 1;
		w = ri;
		nodes[u].Edges[Client_Home].push_back(nodes + v);
		nodes[u].Pathl[Client_Home].push_back(w);			//正边
		nodes[v].Edges[Post_Office].push_back(nodes + u);
		nodes[v].Pathl[Post_Office].push_back(w);			//反边
	}
	
	printf("%d\n", spfa(Client_Home) + spfa(Post_Office));	//正+反=结果

	return 0;
}

```
没有用到STL，于是代码卡进了最优解的第十页（没开O2！），还是比较快的。

如果有其他可以优化的地方，或是代码有所不足，欢迎评论指正！

---

## 作者：FXY是蒟蒻 (赞：3)

# 大水题
### 随便跑跑dijkstra或者SPFA（我爱SPFA，SPFA没有死）不就行了
## 可是某同学偏要跑floyd
## His CODE
```c
#include<cstdio>
using namespace std;
long long f[1001][1001];
int main()
{
    long long i,n,m,u,v,w,j,k,ans=0;
    scanf("%lld%lld",&n,&m); 
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    f[i][j]=0x7fffffff;
    for(i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld",&u,&v,&w);
        f[u][v]=min(f[u][v],w);
    }
    for(k=1;k<=n;k++)
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    if(f[i][j]>f[i][k]+f[k][j])
    f[i][j]=f[i][k]+f[k][j];
    for(i=2;i<=n;i++)
    ans+=f[1][i]+f[i][1];
    printf("%lld",ans);
    return 0;//程序的结束，世界的消逝
}
```
即使加上了输入输出也依旧短小精悍，码风干净利索……

### BUT！
### 只有四十分，六个点TLE！！！
在这里，本人衷心希望各位不要重蹈覆辙

## 那么，我们瞅瞅dijkstra
不会的同学请移步模板：P4779

[](https://www.luogu.com.cn/problemnew/solution/P4779)
### CODE
```
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=1001;
const int M=100001;//别问我为什么用const int，其实没啥用
int n,m,s,t,d[N];
int edge,e[M],b[M],w[M],fir[N];
int x[M],y[M],z[M];
void add(int x,int y,int z)
{
    e[++edge]=y;
    w[edge]=z;
    b[edge]=fir[x];
    fir[x]=edge;
}
struct node
{
    int i,dis;
};
bool operator<(node a,node b)
{
    return a.dis>b.dis;
}
priority_queue<node>q;//优先队列
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x[i],&y[i],&z[i]);//输入没什么好说的
        add(x[i],y[i],z[i]);//就相当于是创建地图
    }
    memset(d,127,sizeof(d));
    //开始跑队列优化模板
    q.push((node){1,0});
    d[1]=0;
    while(!q.empty())
    {
        node t=q.top();
        q.pop();
        if(d[t.i]!=t.dis)
            continue;
        for(int k=fir[t.i];k;k=b[k])
        {
            if(t.dis+w[k]<d[e[k]])
            {
                d[e[k]]=t.dis+w[k];
                q.push((node){e[k],d[e[k]]});
            }
        }
    }
    int ans=0;
    for(int i=2;i<=n;i++)
	ans+=d[i];
    edge=0;
    while(!q.empty())
	q.pop();
    memset(d,127,sizeof(d));//数组清空
    memset(e,0,sizeof(e));
    memset(w,0,sizeof(w));
    memset(b,0,sizeof(b));
    memset(fir,0,sizeof(fir));
    for(int i=1;i<=m;i++)
    add(y[i],x[i],z[i]);
    q.push((node){1,0});
    d[1]=0;
    while(!q.empty())//队列不为空
    {
        node t=q.top();
        q.pop();
        if(d[t.i]!=t.dis)
        continue;
        for(int k=fir[t.i];k;k=b[k])
        {
            if(t.dis+w[k]<d[e[k]])
            {
                d[e[k]]=t.dis+w[k];
                q.push((node){e[k],d[e[k]]});
            }
        }
    }
    for(int i=2;i<=n;i++)
	ans+=d[i];
    printf("%d\n",ans);//输出结果
    return 0;//程序的结束，世界的消逝
}
```
那么这就非常简单了

## 接下来
### 隆重推出SPFA！
SPFA没有死，我爱SPFA，SPFA使我快乐

不接受任何反驳，SPFA最强
```
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int n,m,map[1001][1001];//map数组用来建图 
int &fir(int i,int j)
{return map[i][j];}
int &sec(int i,int j)
{return map[j][i];}
int minw[1001];
bool vis[1001];
long long ans;
inline void spfa(int&(*a)(int,int)){//SPFA模板啊！ 
    memset(minw,0x3f3f3f3f,sizeof(minw));
    memset(vis,false,sizeof(vis));
    queue<int>q;
    minw[1]=0;
    q.push(1);
    vis[1]=true;
    while(!q.empty())//队列不为空 
	{
    int v=q.front();q.pop();
    vis[v]=false;
    for(int i=1;i<=n;i++)
    if(a(v,i))
    if(minw[i]>minw[v]+a(v,i))
	{
        minw[i]=minw[v]+a(v,i);
        if(!vis[i])
		{
              q.push(i);
              vis[i]=true;
        }
    }
	}
    for(int i=1;i<=n;i++)
	ans+=minw[i];
}
inline int read()//inline不加也可以，但是名义上应该是要快那么一丢丢的 
{
       int x=0;char ch=getchar();
       while(ch>'9'||ch<'0')
	   ch=getchar();
       do
	   {
	   x=x*10+ch-48;
	   ch=getchar();
	   } 
	   while(ch>='0'&&ch<='9');
       return x;
}
int main(){
    n=read();
	m=read();
    memset(map,0x3f3f3f3f,sizeof(map));
    for(int i=1;i<=m;i++)
	{
    	int v=read(),u=read(),w=read();
    	map[v][u]=min(map[v][u],w);
    }
    for(int i=1;i<=n;i++)
	map[i][i]=0;
    spfa(fir);//写好了模板，SPFA跑一跑 
    spfa(sec);
    printf("%lld\n",ans);//轻松又愉快 
    return 0;//程序的结束，世界的消逝
}
```
看，SPFA多快

### 那么问题来了，有这么多正解，为什么要不听老人言，跑floyd呢？
## 因为代码复杂度低！
## 本人衷心希望各位能在跑Floyd之前瞅瞅数据大小和时间限制

---

## 作者：Eason_AC (赞：3)

这里先说个题外话——

正如我在此题讨论区里发的一个帖子所说，这个题目和[P1342 请柬](https://www.luogu.org/problem/P1342)是一样的，但是需要开大数组，并将答案开$long~long$。

---

好了不多说正式进入题解。

其实楼上的巨佬们都已经讲得很清楚了，就是从1到各个点的最短路和各个点到1的最短路的权值和加起来就行了。

这里给大家安利一下堆优化+$Dijkstra$的代码（其实不用加$int$~~其实我是先做了1342再复制粘贴过这题的233~~）：
```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>
#define ll long long
using namespace std;

ll n, m, u, v, w, h1[2000007], h2[2000007], cnt1, cnt2, dis[2000007], vis[2000007];
struct edge {
	ll v, to, nxt;
}e1[2000007], e2[2000007];
priority_queue<pair<ll, ll> > q;

inline ll read() {
	ll f = 1ll, x = 0ll;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-')	f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
void a_e(ll u, ll v, ll w) {
	e1[++cnt1] = (edge){w, v, h1[u]}; h1[u] = cnt1;
	e2[++cnt2] = (edge){w, u, h2[v]}; h2[v] = cnt2;
}
ll dj() {
	ll ans = 0;
	memset(dis, 0x3f, sizeof(dis));
	dis[1] = 0;
	q.push(make_pair(0ll, 1ll));
	while(!q.empty()) {
		ll x = q.top().second;
		q.pop();
		if(vis[x])	continue;
		vis[x] = 1;
		for(ll i = h1[x]; i; i = e1[i].nxt) {
			ll y = e1[i].to, z = e1[i].v;
			if(dis[y] > dis[x] + z) {
				dis[y] = dis[x] + z;
				q.push(make_pair(-dis[y], y));
			}
		}
	}
	for(ll i = 2; i <= n; ++i) {
//		printf("1 to %d's distance is %d.\n", i, dis[i]);
		ans += dis[i];
	}
	while(!q.empty())	q.pop();
	memset(dis, 0x3f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	dis[1] = 0;
	q.push(make_pair(0ll, 1ll));
	while(!q.empty()) {
		ll x = q.top().second;
		q.pop();
		if(vis[x])	continue;
		vis[x] = 1;
		for(ll i = h2[x]; i; i = e2[i].nxt) {
			ll y = e2[i].to, z = e2[i].v;
			if(dis[y] > dis[x] + z) {
				dis[y] = dis[x] + z;
				q.push(make_pair(-dis[y], y));
			}
		}
	}
	for(ll i = 2; i <= n; ++i) {
//		printf("%d to 1's distance is %d.\n", i, dis[i]);
		ans += dis[i];
	}
	return ans;
}

int main() {
	n = read(), m = read();
	for(ll i = 1; i <= m; ++i) {
		u = read(), v = read(), w = read();
		a_e(u, v, w);
	}
	printf("%lld", dj());
	return 0;
}
```

不先点个赞再走嘛？qwq

---

## 作者：EarthGiao (赞：2)

# 【两种方法】

## 【SPFA】
SPFA     
### 【注意注意】
这是单向路单向路单向路！！！    
重要的事情说三遍！！！    
（题目中没点出这点但是我的全WA经历让我深刻的认识到了这一点）    
### 【思路】
去和来这是两个完全相反的东西    
SPFA跑一个方向是很轻松的    
然后另一个方向就很难办了    
该怎么办呢？    
n遍SPFA？    
不太可能这就是一道黄题    
对了！可以反向建图！    
将方向反过来建出来的图就是完全相反的    
某个点到x的距离恰好就是回家的最短距离    
这样和正向建图一结合    
就能求出去和回的最短路径了    
然后求和就可以了     
### 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int Max = 100005;
struct node
{
	int y;
	int ne;
	int z;
}a1[Max << 1],a2[Max << 1];
int n,m,x;
const int M = 1002;
int head1[M],head2[M];
int sum = 0;
void add1(int x,int y,int z)
{
	a1[++ sum].y = y;
	a1[sum].z = z;
	a1[sum].ne = head1[x];
	head1[x] = sum;
}
void add2(int x,int y,int z)
{
	a2[++ sum].y = y;
	a2[sum].z = z;
	a2[sum].ne = head2[x];
	head2[x] = sum;
}

int d1[M],d2[M];
bool use[M];
void SPFA1()
{
	memset(use,false,sizeof(use));
	queue<int>q;
	for(register int i = 1;i <= n;++ i)
		d1[i] = 999999;
	d1[x] = 0;
	q.push(x);
	while(!q.empty())
	{
		int qwq = q.front();
		q.pop();use[qwq] = false;
		for(register int i = head1[qwq];i != 0;i = a1[i].ne)
		{
			int awa = a1[i].y;
			if(d1[awa] > d1[qwq] + a1[i].z)
			{
				d1[awa] = d1[qwq] + a1[i].z;
				if(use[awa] == false)
				{
					use[awa] = true;
					q.push(awa);
				}
			}
		}
	}
}
void SPFA2()
{
	memset(use,false,sizeof(use));
	queue<int>q;
	for(register int i = 1;i <= n;++ i)
		d2[i] = 999999;
	d2[x] = 0;
	q.push(x);
	while(!q.empty())
	{
		int qwq = q.front();
		q.pop();use[qwq] = false;
		for(register int i = head2[qwq];i != 0;i = a2[i].ne)
		{
			int awa = a2[i].y;
			if(d2[awa] > d2[qwq] + a2[i].z)
			{
				d2[awa] = d2[qwq] + a2[i].z;
				if(use[awa] == false)
				{
					use[awa] = true;
					q.push(awa);
				}
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	x = 1;
	int xx,yy,zz;
	for(register int i = 1;i <= m;++ i)
	{
		scanf("%d%d%d",&xx,&yy,&zz);
		add1(xx,yy,zz);
		add2(yy,xx,zz);
	}
	SPFA1();
	SPFA2();
	int MM = 0;
	for(register int i = 1;i <= n;++ i)
		MM = MM + d1[i] + d2[i];
	cout << MM << endl;
	return 0;
}
```
## 【dijkstra】
dijkstra + 堆优化     
### 【说在前面的话】 
~~通过这道题发现我真是个可爱的孩子~~    
用dijkstra做的时候    
开开心心打一个反向建图    
轻轻松松提交上去   
然后拿了70分……    
堆优化之后的复杂度是O((N+M)logN)完全不会超时     
然后我就开始思考各种可能出现的玄学问题   
最后焦灼了一个小时   
终于发现是数组开小了……    
鬼知道为什么数组开小会超时……
### 【核心思路】
有去有回   
如果只是去的话单源最短路径就可以轻轻松松解决掉    
但是来回的话   
首先想到的是多源最短路径    
但是好像跑不过去    
这就用到了和上面SPFA一样的思路了   
就是反向建图    
这样只需要两遍dijkstra就可以解决掉    
最后再求个和就没有问题了     
### 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int Max = 100004;
const int M = 1003;
struct point
{
	int w;
	int x;
	bool operator < (const point & xx)const
	{
		return xx.w < w;
	}
};
int n,m;
struct node
{
	int y,ne;
	int z;
}a1[Max << 1],a2[Max << 1];
int sum1 = 0,sum2 = 0;
int head1[M],head2[M];

inline int read()
{    
     int x=0; char ch=getchar();
     while (ch<'0' || ch>'9') ch=getchar();
     while (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }
     return x;
}   

void add1(int x,int y,int z)
{
	a1[++ sum1].y = y;
	a1[sum1].z = z;
	a1[sum1].ne = head1[x];
	head1[x] = sum1;
}
void add2(int x,int y,int z)
{
	a2[++ sum2].y = y;
	a2[sum2].z = z;
	a2[sum2].ne = head2[x];
	head2[x] = sum2;
}
int dis1[M],dis2[M];
bool use1[M],use2[M];
priority_queue<point>q;
void dj1()
{
	for(register int i = 2;i <= n;++ i)
		dis1[i] = 999999;
	dis1[1] = 0;
	q.push((point){0,1});
	while(!q.empty())
	{
		point qwq = q.top();
		q.pop();
		int x = qwq.x;
		if(use1[x] == true)
			continue;
		use1[x] = true;
		for(register int i = head1[x];i != 0;i = a1[i].ne)
		{
			int awa = a1[i].y;
			if(dis1[awa] > dis1[x] + a1[i].z)
			{
				dis1[awa] = dis1[x] + a1[i].z;
				if(use1[awa] == false)
					q.push((point){dis1[awa],awa});
			}
		}
	}
}

void dj2()
{
	for(register int i = 2;i <= n;++ i)
		dis2[i] = 999999;
	dis2[1] = 0;
	q.push((point){0,1});
	while(!q.empty())
	{
		point qwq = q.top();
		q.pop();
		int x = qwq.x;
		if(use2[x] == true)
			continue;
		use2[x] = true;
		for(register int i = head2[x];i != 0;i = a2[i].ne)
		{
			int awa = a2[i].y;
			if(dis2[awa] > dis2[x] + a2[i].z)
			{
				dis2[awa] = dis2[x] + a2[i].z;
				if(use2[awa] == false)
					q.push((point){dis2[awa],awa});
			}
		}
	}
}

int main()
{
	n = read();m = read(); 
	int x,y,z;
	for(register int i = 1;i <= m;++ i)
	{
		x = read();y = read();z = read();
		add1(x,y,z);add2(y,x,z);
	}
	dj1();
	dj2();
	int ans = 0;
	for(register int i = 2;i <= n;++ i)
		ans += dis1[i] + dis2[i];
	cout << ans << endl;
	return 0;
}
```

---

## 作者：crzyz (赞：2)

P1629 邮递员送信题解报告

分析：这是一道~~氧气优化的水题~~最短路问题，我们首先想到了floyd，dijkstra，bellman-ford（~~spfa已死~~）算法，但是这道题n<=1000且路径距离皆为正整数，所以用dijkstra或bellman，这题我用了bellman。

但是我们又看到，这是有向图，而且邮递员送完货物之后还要返回，也就是说我们从一到多跑完最短路后还要从多到一跑回来，从一到多很容易，但是从多到一怎么办呢？

这时候我们想：
#### 假设要问从x到1的最短路，为x->a->b->c->1,也就是说x->a,a->b,b->c,c->1都有路可走，那么我们想想，从x开始x->a,a->b,b->c,c->1的最短路不就是从1开始1->c,c->b,b->a,a->x的最短路吗？于是这时，我们把x->a,a->b,b->c,c->1这4条路径变为1->c,c->b,b->a,a->x，然后从1开始跑最短路，而它们的最短路是一样的。

我们把这样从多到一的最短路变式的路径反转操作称作“**反向建边**”。

其他注释放到代码里，还有一点，我用的bellman没加队列优化.

耗时/内存1809ms, 1936KB

Code:
```
#include<bits/stdc++.h>
using namespace std;
const int INF=99999999;//定义最大值。注意不要设0x7fffffff, 加的时候会爆int 
int n,m;
int u[100005],v[100005],w[100005];//开好数组，别RE了 
int dis[1005];
void init(){//初始化 
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)scanf("%d%d%d",&u[i],&v[i],&w[i]);// u起，v终，w长度 
}
void over(){//这是一个反向建边的函数，把起点和终点互换 ，好让邮递员返回时从多到一跑最短路 
	for(int i=1;i<=m;i++){
		swap(u[i],v[i]);
	}
} 
void ford(){//标准bellman-ford模板 
	for(int i=1;i<=n;i++)dis[i]=INF;
	dis[1]=0;
	for(int k=1;k<=n-1;k++){
		for(int i=1;i<=m;i++){
			if(dis[v[i]]>dis[u[i]]+w[i]){
				dis[v[i]]=dis[u[i]]+w[i];
			}
		}
	}
}
int main(){
	init();
	int ans=0;
	ford();//跑最短路 
	for(int i=1;i<=n;i++)ans+=dis[i];//从一到多 
	over();//反转，反向建边 
	ford();//跑最短路 
	for(int i=1;i<=n;i++)ans+=dis[i];//从多到一 
	printf("%d\n",ans);
	return 0;//完结撒花
}
//代码甚短qwq 
```
望过审

---

## 作者：littleseven (赞：1)

配合博客食用味道更佳：http://littleseven.top/?p=290

这道题可以说很坑了，坑点就在于**有向图**！！！我们可以发现按照题中描述我们需要从起始点先到某个点，在从某个点回到起始点，反复循环。但是由于是有向图，所以**去的时候的最短路不一定就是回来时候的最短路**，由于如果求n个点的最短路，或者多源单点最短路，时间上是承受不了的，所以这个问题成为整个题的难点所在，那么怎么处理？？？

大致的思路是这样，把我们从起点（邮局）开始的一边最短路定为正向，那么我们回来就相当于一次反向求最短路。

按照我们正常想法是从N个点向起始点都跑一遍最短路（是不是想起了Floyd），那么加入我们反向建图，这就变成了从起始点向N个重点跑最短路，就又变成了另外一组单源最短路，在时间上是可以接受的。

因为半死不活的SPFA算法和它（在不稳定方面）~~极为优秀~~的时间复杂度，个人放弃了这个算法，所以没有写SPFA的题解（从题目中M的数据范围就放弃了），正常使用**堆优化Dijkstra**，代码如下：

## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
const int M = 100100;

int n, m, ans, vis[N], dis[N], fvis[N], fdis[N];
int tot, to[M], nex[M], val[M], head[N];
int ftot, fto[M], fnex[M], fval[M], fhead[N];

void add(int x, int y, int z)
{
	to[ ++ tot] = y;
	val[tot] = z;
	nex[tot] = head[x];
	head[x] = tot;
	fto[ ++ ftot] = x;
	fval[ftot] = z;
	fnex[ftot] = fhead[y];
	fhead[y] = ftot;
}
priority_queue < pair<int, int> > q;
void dijkstra(int s)
{
	memset(dis, 0x3f, sizeof dis);
	memset(vis, 0, sizeof vis);
	dis[s] = 0;
	q.push(make_pair(0, s));
	while(!q.empty())
	{
		int x = q.top().second;
		q.pop();
		if (vis[x])
			continue ;
		vis[x] = 1;
		for (int i = head[x]; i; i = nex[i])
		{
			if (dis[to[i]] > dis[x] + val[i])
			{
				dis[to[i]] = dis[x] + val[i];
				q.push(make_pair(-dis[to[i]], to[i]));
			}
		}
	}
}
void fdijkstra(int s)
{
	memset(fdis, 0x3f, sizeof fdis);
	memset(fvis, 0, sizeof fvis);
	fdis[s] = 0;
	q.push(make_pair(0, s));
	while(!q.empty())
	{
		int x = q.top().second;
		q.pop();
		if (fvis[x])
			continue ;
		fvis[x] = 1;
		for (int i = fhead[x]; i; i= fnex[i])
		{
			if (fdis[fto[i]] > fdis[x] + fval[i])
			{
				fdis[fto[i]] = fdis[x] + fval[i];
				q.push(make_pair(-fdis[fto[i]], fto[i]));
			}
		}
	}
} 
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i ++ )
	{
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		add(x, y, z);
	}
	dijkstra(1);
	fdijkstra(1);
	for (int i = 2; i <= n; i ++ )
	{
		ans += dis[i] + fdis[i];
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Zekrom (赞：1)

同[P1821](https://www.luogu.org/problemnew/show/P1821)一样的思路  
因为有向图，只要反向建边即可   
对于无向边，直接d[u]+d[v]即可 
如[P2984](https://www.luogu.org/problemnew/show/P2984)  
上代码  
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 1010
#define M 100010 
using namespace std;
int n,m,head[N],rhead[N],tot,rtot,d1[N],d2[N],ans,s;
bool vis[N];
struct Edge{
	int v,next,val;
}edge[M],redge[M];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return  x*f;
}
inline void add1(int x,int y,int z){edge[++tot].v=y;edge[tot].val=z;edge[tot].next=head[x];head[x]=tot;}
inline void add2(int x,int y,int z){redge[++rtot].v=y;redge[rtot].val=z;redge[rtot].next=rhead[x];rhead[x]=rtot;}
void dijk(int x){
	priority_queue<pair<int,int> >q;
	memset(d1,0x3f,sizeof(d1));
	q.push(make_pair(0,x));d1[x]=0;
	while(q.size()){
		int u=q.top().second;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v,z=edge[i].val;
			if(d1[v]>d1[u]+z){
				d1[v]=d1[u]+z;
				q.push(make_pair(-d1[v],v));
			}
		}
	}
}
void spfa(int x){
	queue<int>q;
	memset(d2,0x3f,sizeof(d2));
	memset(vis,0,sizeof(vis));
	q.push(x);vis[x]=1;d2[x]=0;
	while(q.size()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=rhead[u];i;i=redge[i].next){
			int v=redge[i].v,z=redge[i].val;
			if(d2[v]>d2[u]+z){
				d2[v]=d2[u]+z;
				if(!vis[v])q.push(v),vis[v]=1; 
			} 
		}
	}
	
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read(),z=read();
		add1(x,y,z);add2(y,x,z); 
	} 
	dijk(1);
	spfa(1);
	for(int i=1;i<=n;i++)
		ans+=d1[i]+d2[i];
	printf("%d\n",ans); 
	return 0;
}

```


---

## 作者：rediserver (赞：1)

# P1629 邮递员送信

[原题地址](https://www.luogu.org/problemnew/show/P1629)

[GitHub题解](https://github.com/jerrykcode/luogu)

## 题目描述

有一个邮递员要送东西，邮局在节点1.他总共要送N-1样东西，其目的地分别是2~N。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有M条道路，通过每条道路需要一定的时间。这个邮递员每次只能带一样东西。求送完这N-1样东西并且最终回到邮局最少需要多少时间。

## 输入输出格式

### 输入格式：

第一行包括两个整数N和M。第2到第M+1行，每行三个数字U、V、W，表示从A到B有一条需要W时间的道路。 满足1<=U,V<=N,1<=W<=10000,输入保证任意两点都能互相到达。

【数据规模】

* 对于30%的数据，有1<=N<=200;

* 对于100%的数据，有1<=N<=1000,1<=M<=100000。

### 输出格式：

输出仅一行，包含一个整数，为最少需要的时间。

## 输入输出样例

### 输入样例#1： 

> 5 10  
> 2 3 5  
> 1 5 5  
> 3 5 6  
> 1 2 8  
> 1 3 8  
> 5 3 4  
> 4 1 8  
> 4 5 3  
> 3 5 6  
> 5 4 2  

### 输出样例#1： 

> 83  


## 思路

堆优化dijkstra，计算源到每一个顶点最短路径之和。然后对原图的反向图进行一次dijkstra，计算反向图中源到每个顶点的最短路径之和。`反向图中源到顶点的最短路径即原图中顶点到源的最短路径`。

## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

#define NO_VALUE -1

typedef long long LL;

//邻接点结构体
struct AdjNode {
	int v; //邻接顶点
	int weight; //邻接边权重
	AdjNode(int v, int weight) : v(v), weight(weight) {}
};

//计算最短路径和的类
class Dijkstra {
public:
	Dijkstra() {}
	~Dijkstra() {}

	/* 返回从0到所有顶点最短路径之和。*/
	LL dijkstra(vector<AdjNode>* graph, int n);
private:
	//优先队列使用的结构体
	struct Node {
		int v;
		int dist;
		Node(int v, int dist) : v(v), dist(dist) {}
	};

	struct cmp {
		bool operator() (Node& a, Node& b) {
			return a.dist > b.dist;
		}
	};

	//类变量
	int *dist_;
	bool *collected_;
};

LL Dijkstra::dijkstra(vector<AdjNode>* graph, int n) {
	LL result = 0;
	dist_ = new int[n];
	fill(dist_, dist_ + n, NO_VALUE);
	collected_ = new bool[n];
	fill(collected_, collected_ + n, false);
	int src = 0;
	dist_[src] = 0;
	priority_queue<Node, vector<Node>, cmp> q;
	q.push(Node(src, dist_[src]));
	while (!q.empty()) {
		int minV = q.top().v;
		q.pop();
		if (collected_[minV]) continue;
		collected_[minV] = true;
		result += dist_[minV]; //minV的最短路径已确定，加到result中
		for (vector<AdjNode>::iterator it = graph[minV].begin(); it != graph[minV].end(); it++) {
			int adjVertex = it->v;
			int adjWeight = it->weight;
			if (!collected_[adjVertex])
				if (dist_[minV] + adjWeight < dist_[adjVertex] || dist_[adjVertex] == NO_VALUE) {
					dist_[adjVertex] = dist_[minV] + adjWeight;
					q.push(Node(adjVertex, dist_[adjVertex]));
				}
		}
	}
	free(dist_);
	free(collected_);
	return result;
}

void clearGraph(vector<AdjNode> *graph, int n) {
	for (int i = 0; i < n; i++)
		vector<AdjNode>().swap(graph[i]);
}

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	vector<AdjNode> *graph = new vector<AdjNode>[n];
	int a, b, dist;
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &a, &b, &dist);
		a--; b--;
		graph[a].push_back(AdjNode(b, dist));
	}
	Dijkstra dijkstra;
	LL result = dijkstra.dijkstra(graph, n);
	//对反向图进行dijkstra
	vector<AdjNode> *inverseGraph = new vector<AdjNode>[n];
	for (int v = 0; v < n; v++) 
		for (vector<AdjNode>::iterator it = graph[v].begin(); it != graph[v].end(); it++) {
			inverseGraph[it->v].push_back(AdjNode(v, it->weight));
		}
	clearGraph(graph, n);
	result += dijkstra.dijkstra(inverseGraph, n);
	clearGraph(inverseGraph, n);
	printf("%d\n", result);
}
```

---

## 作者：瓜皮少年 (赞：1)

## dijkstra+堆优化
题解里面都是spfa，要不然就是单纯的dijkstra，那我来一个dijkstra+堆优化了，思想和他们一样建两次边加两次搜索

 可以推荐几道其他的类似的题（~~三倍经验~~）
 
 [请柬(范围宽了点)](https://www.luogu.org/problemnew/show/P1342)
 
 [银牛派对（算最长的一次来回~~两次最短路相加就可以了~~）](https://www.luogu.org/problemnew/show/P1821)

code：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cstdlib>
using namespace std;
const int mx=200010;
typedef pair<int,int> pii;
priority_queue<pii,vector<pii>,greater<pii> > q;
struct edge{
    int v,next,val;
}eg[mx*2];
edge eg1[mx];
int head[mx],top;
int head1[mx],top1;
int dis[mx],inque[mx];
int dis1[mx],inque1[mx];
void addedge(int u,int v,int val){
    eg[++top].v=v;
    eg[top].val=val;
    eg[top].next=head[u];
    head[u]=top;
}
void addedge1(int u,int v,int val){
    eg1[++top1].v=v;
    eg1[top1].val=val;
    eg1[top1].next=head1[u];
    head1[u]=top1;
}
int n,m;
void dji(int st){
    q.push(make_pair(dis[st],st));
    int u,dist;
    while(!q.empty()){
        pii poi=q.top();q.pop();
        u=poi.second;
        if(!inque[u]){
            inque[u]=1;
            for(int i=head[u];i;i=eg[i].next){
                dist=dis[u]+eg[i].val;
                if(dist<dis[eg[i].v]){
                dis[eg[i].v]=dist;
                q.push(make_pair(dis[eg[i].v],eg[i].v));
            }
            }
        }
    }
}
void dji1(int st){
    q.push(make_pair(dis1[st],st));
    int u,dist;
    while(!q.empty()){
        pii poi=q.top();q.pop();
        u=poi.second;
        if(!inque1[u]){
            inque1[u]=1;
            for(int i=head1[u];i;i=eg1[i].next){
                dist=dis1[u]+eg1[i].val;
                if(dist<dis1[eg1[i].v]){
                dis1[eg1[i].v]=dist;
                q.push(make_pair(dis1[eg1[i].v],eg1[i].v));
            }
            }
        }
    }
}
long long ans=0;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1,u,v,val;i<=m;i++){
        scanf("%d%d%d",&u,&v,&val);
        addedge(u,v,val);
        addedge1(v,u,val);
    }
    memset(dis,0x7f,sizeof(dis));
    dis[1]=0;
    dji(1);
    ans=0;
    for(int i=2;i<=n;i++){
        ans+=dis[i];
    }
    memset(dis1,0x7f,sizeof(dis1));
    dis1[1]=0;
    dji1(1);
    for(int i=2;i<=n;i++){
        ans+=dis1[i];
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Drug__Lover (赞：1)

因为此图是有向边

所以只需从起点跑一遍到个点的最短路加起来之后

建立反向边

再从起点跑一遍到各个点的最短路，表示跑到各个点之后再跑回来的最短路

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
using namespace std;
int minn[500001],vis[500001],team[500001],head[500001];
struct m
{
    int next,to,cost;
}e[500001];
int num,u,sum;
void add(int from,int to,int dis)
{
    e[++num].next=head[from];
    e[num].to=to;
    e[num].cost=dis;
    head[from]=num;
}
void spfa(int s)
{
    memset(team,0,sizeof(team));
    memset(vis,0,sizeof(vis));
    memset(minn,0x7f,sizeof(minn));
    int h=0,t=1;
    team[1]=s;
    vis[s]=1;
    minn[s]=0;
    while(h<t)
    {
        h++;
        u=team[h];
        vis[u]=0;
        for(int i=head[u];i!=0;i=e[i].next)
        {
            int to=e[i].to;
            if(minn[u]+e[i].cost<minn[to])
            {
                minn[to]=minn[u]+e[i].cost;
                if(vis[to]==0)
                {
                    vis[to]=1;
                    t++;
                    team[t]=to;
                }
            }
        }
    }
}
int main()
{
    int n,m;
    int x[100001],y[100001],z[100001];
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>x[i]>>y[i]>>z[i];
        add(x[i],y[i],z[i]);
    }
    spfa(1);
    for(int i=2;i<=n;i++) sum=sum+minn[i];
    memset(e,0,sizeof(e));
    memset(head,0,sizeof(head));
    for(int i=1;i<=m;i++)
    {
        add(y[i],x[i],z[i]);
    }
    for(int i=2;i<=n;i++)
    {
        spfa(1);
        sum=sum+minn[i];
    }
    cout<<sum<<endl;
    return 0;
}
```

---

## 作者：诗乃 (赞：1)

挺简单的SPFA。

由于每一次只能带一件物品，所以邮递员需要从1走到各点返回1再出发

就是1到各点最短路加上各点到一最短路

前者一遍SPFA。

后者相当于从1逆向走到所有点，所以把边反向然后再一次SPFA

AC！
        
    
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <queue>
using namespace std;
int n,m,ans;
struct edge
{
    int to,l;
}d1[1001][1001];
int x[100001],y[100001],z[100001];
int len[1001];
void spfa()
{
    bool inque[1001];
    int u,v;
    queue<int>q;
    q.push(1);inque[1]=1;
    int d[1001];
    memset(d,127,sizeof(d));
    memset(inque,0,sizeof(inque));
    d[1]=0;
    while(!q.empty())
    {
        u=q.front();q.pop();inque[u]=0;
        for(int i=1;i<=len[u];i++)
        {
            v=d1[u][i].to;
            if(d1[u][i].l+d[u]<d[v])
            {
                d[v]=d1[u][i].l+d[u];
                if(!inque[v])
                {
                    q.push(v);
                    inque[v]=1;
                }
            }
        }
    }
    for(int i=2;i<=n;i++)
    ans+=d[i];
}
int main()
{
    //freopen("post.in","r",stdin);
    //freopen("post.out","w",stdout);
    scanf("%d%d",&n,&m);
    edge tmp;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x[i],&y[i],&z[i]);
        d1[x[i]][++len[x[i]]].to=y[i];
        d1[x[i]][len[x[i]]].l=z[i];
    }
    spfa();
    memset(d1,0,sizeof(d1));
    memset(len,0,sizeof(len));
    for(int i=1;i<=m;i++)
    {
        d1[y[i]][++len[y[i]]].to=x[i];
        d1[y[i]][len[y[i]]].l=z[i];
    }
    spfa();
    printf("%d",ans);
}
```

---

## 作者：智之星 (赞：1)

pascal版——spfa算法

应为只能带一件物品，故每次从1村出发，到i（1<=i<=n）村去；

相当于从1村到所有村最短路加所有村（除1村）到1村最短路；

输入为//a b c；表示（a->b，距离为c）；

其实可以用spfa算法求完1到n的最短路时；

将所有点交换//如：a b c->b a c;(由此再求一遍spfa，即为各点到1村的最短路）（记得分两个数组保存）；

```cpp
var a:array[1..100000,1..3] of longint;//(同下）；
    next:array[1..100000] of longint;//（同下）；
    last:array[1..1000] of longint;///（同上，一起为边集数组）；
    go,back:array[1..1000] of longint;//分两个数组存最短路；
    dl:array[1..200000] of longint;//spfa队列（你开循环队列，我也没意见）；
    f:array[1..1000] of boolean;//入队判重；
    n,m,j,k,l,i,b,c,ds,dw:longint;
    ans:int64;
procedure exchange(t:longint);//点交换；
      var i,j,k:longint;
begin
  i:=a[t,1];
  a[t,1]:=a[t,2];
  a[t,2]:=i;
  next[t]:=last[a[t,1]];
  last[a[t,1]]:=t;
end;
function relax1(i:longint):boolean;//spfa松弛;
     var j,k,l:longint;
begin
  if (a[i,3]<>0)and(go[a[i,1]]+a[i,3]<go[a[i,2]]) then
  begin
    go[a[i,2]]:=go[a[i,1]]+a[i,3];
    exit(true);
  end;
  exit(false);
end;
function relax2(i:longint):boolean;//（同上）；
     var j,k,l:longint;
begin
  if (a[i,3]<>0)and(back[a[i,1]]+a[i,3]<back[a[i,2]]) then
  begin
    back[a[i,2]]:=back[a[i,1]]+a[i,3];
    exit(true);
  end;
  exit(false);
end;
begin
      readln(n,m);
      for i:=1 to m do
      begin
       readln(a[i,1],a[i,2],a[i,3]);
       next[i]:=last[a[i,1]];
       last[a[i,1]]:=i;
      end;
      ds:=0;
      dw:=1;
      dl[1]:=1;
      f[1]:=true;
      fillchar(go,sizeof(go),127);
      go[1]:=0;
      repeat
        inc(ds);
        l:=dl[ds];
        k:=last[l];
        f[l]:=false;
        while k<>0 do
        begin
          if relax1(k)and(f[a[k,2]]=false) then
             begin
                inc(dw);dl[dw]:=a[k,2];
                f[a[k,2]]:=true;
             end;
          k:=next[k];
        end;
      until ds>=dw;
      fillchar(next,sizeof(next),0);
      fillchar(last,sizeof(last),0);
      fillchar(back,sizeof(back),127);
      fillchar(f,sizeof(f),false);
      for i:=1 to m do exchange(i);
      ds:=0;
      dw:=1;
      dl[1]:=1;
      f[1]:=true;
      back[1]:=0;
      repeat
        inc(ds);
        l:=dl[ds];
        k:=last[l];
        f[l]:=false;
        while k<>0 do
        begin
          if relax2(k)and(f[a[k,2]]=false) then
             begin
                inc(dw);dl[dw]:=a[k,2];
                f[a[k,2]]:=true;
             end;
          k:=next[k];
        end;
      until ds>=dw;
      for i:=1 to n do ans:=ans+go[i]+back[i];
      writeln(ans);
end.
```

---

## 作者：sfd158 (赞：1)

1.最简单的做法：用n^3复杂度的floyd算法进行处理，但是肯定会超时

2.考虑进行优化。利用Heap优化的Dijkstra算法处理n次，复杂度为n\*nlogn，还是太大

3.因为要求出其他点到第一个点的距离，可以作出逆图，然后以第一个点为起点，在逆图上用Dijkstra算法进行处理。这样做的复杂度为n\*logn

```cpp

#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
const int maxn=1005,INF=0x3f3f3f3f;
typedef pair<int,int> pii;
typedef int node[maxn];
struct Edge{
    int to,dist;
};
typedef vector<Edge> vE[maxn];
vE G,H;
bool vis[maxn];
node d1,dis;
priority_queue<pii,vector<pii>,greater<pii> >q;//利用stl自带优先队列模拟堆
int read()//读入优化
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
void dijkstra(node &d,int s,vE& G)//dijkstra
{
    int i,u;
    memset(vis,0,sizeof(vis));
    memset(d,0x3f,sizeof(d));
    q.push(make_pair(0,s));
    d[s]=0;
    while(!q.empty())
    {
        u=q.top().second;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(i=0;i<G[u].size();i++)
        {
            Edge &e=G[u][i];
            if(d[e.to]>d[u]+e.dist)
            {
                d[e.to]=d[u]+e.dist;
                q.push(make_pair(d[e.to],e.to));
            }
        }
    }
}
int main()
{
    int n,m,i,x,y,z,sum=0;
    n=read();
    m=read();
    for(i=0;i<m;i++)
    {
        x=read();
        y=read();
        z=read();
        G[x].push_back((Edge){y,z});
        H[y].push_back((Edge){x,z}); //构建逆图
    }
    dijkstra(d1,1,G);
    dijkstra(dis,1,H);//分别进行处理
    for(i=1;i<=n;i++)
        sum+=d1[i]+dis[i];
    printf("%d",sum);
    return 0;
}

```

---

## 作者：Mogician (赞：1)

#简单易懂的pascal的dijkstra算法

题目相当于求1到其它点的最短路与其它点到1的最短路之和，只需要用dijkstra求1到其它点的最短路，再将每条边反向再求一次1到其它点的最短路。

##要注意两点之间可能有两条不一样长的路，读入时要把最短的取过来

```cpp
var zheng,fan:array[1..1000,1..1000] of longint;//正反两张图
    minz,minf:array[1..1000] of longint;
    fz,ff:array[1..1000] of boolean;
    i,j,k,t,m,n,p,a,b,c,y:longint;
function min(a,b:longint):longint;
begin
 if a>b then exit(b);
 exit(a);
end;
begin
 assign(input,'233.in');
 reset(input);
 assign(output,'2333.out');
 rewrite(output);//关联文件，调试时比较方便
 readln(n,m);
 fillchar(zheng,sizeof(zheng),127);
 fillchar(fan,sizeof(fan),127);
 fillchar(minz,sizeof(minz),127);
 fillchar(minf,sizeof(minf),127);//初始化
 for i:=1 to m do begin readln(a,b,c); zheng[a,b]:=min(zheng[a,b],c); fan[b,a]:=min(fan[b,a],c); end;//读入时注意判断
 for i:=2 to n do begin minz[i]:=min(zheng[1,i],minz[i]); minf[i]:=min(fan[1,i],minf[i]); end;//初始化
 for i:=2 to n do
  begin
   k:=maxlongint;
   for j:=2 to n do if (minz[j]<k)and(not fz[j]) then begin k:=minz[j]; y:=j; end;
   fz[y]:=true;
   for j:=2 to n do if (not fz[j])and(zheng[y,j]+k<minz[j]) then minz[j]:=zheng[y,j]+minz[y];
  end;//对正图进行dijkstra算法
 for i:=2 to n do
  begin
   k:=maxlongint;
   for j:=2 to n do if (minf[j]<k)and(not ff[j]) then begin k:=minf[j]; y:=j; end;
   ff[y]:=true;
   for j:=2 to n do if (not ff[j])and(fan[y,j]+k<minf[j]) then minf[j]:=fan[y,j]+minf[y];
  end;//对反图进行dijkstra算法
 for i:=2 to n do inc(t,minz[i]+minf[i]);//累加答案
 writeln(t);
 close(output);
end.
```

---


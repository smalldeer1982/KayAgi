# [GESP202312 五级] 烹饪问题

## 题目描述

有 $N$ 种食材，编号从 $0$ 至 $N-1$，其中第 $i$ 种食材的美味度为 $a_i$。

不同食材之间的组合可能产生奇妙的化学反应。具体来说，如果两种食材的美味度分别为 $x$ 和 $y$ ，那么它们的契合度为 $x\ \text{and}\ y $。

其中，$\text{and}$ 运算为按位与运算，需要先将两个运算数转换为二进制，然后在高位补足 ，再逐位进行与运算。例如，$12$ 与 $6$ 的二进制表示分别为 $1100$ 和 $0110$ ，将它们逐位进行与运算，得到 $0100$ ，转换为十进制得到 4，因此 $12 \text{and} 6 = 4$。**在 C++ 或 Python 中，可以直接使用 `&` 运算符表示与运算。**


现在，请你找到契合度最高的两种食材，并输出它们的契合度。

## 说明/提示

**样例解释 1**  

可以编号为 $1,2$ 的食材之间的契合度为 $2\ \text{and} \ 3=2$，是所有食材两两之间最高的契合度。

**样例解释 2** 

可以编号为 $3,4$ 的食材之间的契合度为 $10\ \text{and}\ 13=8$，是所有食材两两之间最高的契合度。

**数据范围**

对于 $40\%$ 的测试点，保证 $N \le 1,000$；

对于所有测试点，保证 $N \le 10^6$，$0\le a_i \le 2,147,483,647$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5
5 6 2 10 13
```

### 输出

```
8```

# 题解

## 作者：_little_Cabbage_ (赞：38)

# B3930 [GESP202312 五级] 烹饪问题 题解
~~[博客食用体验更佳](https://www.luogu.com.cn/blog/958804/solution-b3930)~~

这是一道暴力水题。

我们可以双重循环枚举每一种情况，但是这样会超时。

其实我们只需要枚举前 $32$ 大的数的情况就行了，证明如下（引用的 [Bingxiu](https://www.luogu.com.cn/user/676498) 的证明，非常感谢）：

- `int` 范围内的非负整数就是 $31$ 位二进制。

- 数学归纳法，下证 $k-1$ 位二进制时前 $k$ 个一定能取到最优 $(k\ge2)$。

- $k=2$ 时，显然 $1$ 位二进制时前 $2$ 个能取到最优。

- $k=n$ 时可以，则 $k=n+1$ 时，如果所有数的最高位都相同则所有数的最高位无关。

- 由归纳假设，$k-2$ 位二进制前 $k-1$ 个数必有最优，所以加上第一位就有前 $k-1$ 个数必有最优。

- 如果有至少两个最高位为 $1$，至少一个最高位为 $0$，则舍弃所有最高位为 $0$ 的数，归入第一类情况，则前 $k-1$ 个必有最优。

- 如果仅有一个最高位为 $1$，其它都为 $0$，则舍弃最高位为 $1$ 的数，归入第一类情况，则去掉最大数（最高位为 $1$ 的数）后前 $k-1$ 个必有最优，故前 $k$ 个必有最优。

时间复杂度 $O(\min(n,32)^2)$。

AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000010];
bool cmp(int a,int b)
{
	return a>b;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+n+1,cmp);
	n=min(n,32);
	long long mx=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i!=j)
			{
				mx=max(mx,a[i]&a[j]);
			}
		}
	}
	cout<<mx;
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/144991227)

---

## 作者：zhang_kevin (赞：11)

分析：我们知道，$a \operatorname{and} b$ 一定不超过 $\max(a,b)$，因此二进制下他的位数一定不超过 $\max(a,b)$ 的位数。

那么，我们把数组中最大的两个数做 $\operatorname{and}$ 运算后得到一个二进制数，这个数的位数就是答案的最大位数。

我们希望答案尽可能大，就需要尽量使答案二进制下靠前的位取 $1$。

而某一位需要取 $1$，就说**明原数组（或者可选的数）中这位是 $1$ 的数的个数大于等于 $2$。**

因此我们可以从高位往低位枚举，每次选出所有这位为 $1$ 的数，如果个数大于等于 $2$ 个就把答案的这一位设为 $1$。

考场满分代码（可能实现的比较复杂）：

```cpp
#include<bits/stdc++.h>
#define sz vec.size()
using namespace std;
vector<int> vec;
string s[1000001];
inline int get(int k){
	int len = 0;
	while(k){
		k /= 2;
		len++;
	}
	return len;
}
inline string check(int k, int len){
	string s1 = "";
	while(k){
		s1 += k % 2 + '0';
		k /= 2;
	}
	reverse(s1.begin(), s1.end());
	while(s1.length() < len) s1 = "0" + s1;
	return s1;
}
inline vector<int> get2(int x, vector<int> v){
	vector<int> ans;
	for(int i = 0; i < v.size(); i++){
		if(s[v[i]][x] == '1'){
			ans.push_back(v[i]);
		}
	}
	return ans;
}
int main(){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++){
		int a; cin >> a;
		vec.push_back(a);
	}
	sort(vec.begin(), vec.end());
	int len = get(vec[n-1]);
	for(int i = 0; i < n; i++) s[i] = check(vec[i], len);
	vector<int> v;
	for(int i = 1; i <= n; i++) v.push_back(i-1);
	for(int i = 0; i < len; i++){
		vector<int> v2 = get2(i, v);
		if(v2.size() < 2) continue; //个数太少了就continue
		v = v2;
	}
	int ans = INT_MIN;
	for(int i = 0; i < v.size(); i++){
		for(int j = 0; j < v.size(); j++){
			if(i != j) ans = max(ans, vec[v[i]]&vec[v[j]]);
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：xiaoniu142857 (赞：3)

看到各路大神都在用贪心，我就来发一个另类做法吧 (●'◡'●)。
## 题意描述
给定一个数列 $\{a_n\}$，求找到一组 $i,j(i\neq j)$，使 $a_i \& a_j$ 最大。
## 约定记号
约定最优解的 $i$ 取值为 $i_0$，$j$ 取值为 $j_0$。  
即当 $i=i_0,j=j_0$ 时，$a_i \& a_j$ 最大。
## 解题思路
我们可以从高到低枚举每一位，逐步缩小寻找最优解的范围。  
设当前寻找最优解的范围是 $[l,r]$，即目前可以钦定 $i_0,j_0\in [l,r]$。  
初始时，$l=1,r=n$。

先将所有数升序排序，考虑排序后这位上的情况，分讨一下。

1. 这位全部相同  
答案与这一位无关，可以直接跳过，$l,r$ 不用改动。
![](https://cdn.luogu.com.cn/upload/image_hosting/h8xznrs9.png)

2. 这位上有且仅有一个 $1$，位于数列末尾  
则最优解的这位一定为 $0$，将末尾的数这一位置 $0$，重新排序。  
因为只修改了末尾一个数，可以 $O(n)$ 插入排序，而 $l,r$ 不用改动。
![](https://cdn.luogu.com.cn/upload/image_hosting/zwdc1hvj.png)

3. 这一位上先是一段 $0$，然后是一段 $1$  
先二分分界点，设首个这位为 $1$ 的数是 $a_s$。  
可以确定 $i_0,j_0\in [s,r]$，则令 $l\leftarrow s$，缩小求解区间。
![](https://cdn.luogu.com.cn/upload/image_hosting/oe68qac5.png)

最后，当 $[l,r]$ 范围缩小到两个数，即 $r=l+1$，则可以确定 $i_0=l,j_0=r$，求出最优解。

## 时间复杂度分析
首先需要对所有数排序，复杂度 $O(n \log n)$。  
后面缩小区间的操作最多进行 $31$ 次，最坏每次插入排序有 $O(n)$ 的时间复杂度，则这一步复杂度为 $O(n)$，~~常数有亿点点大~~。  
所以总时间复杂度为 $O(n \log n)$，瓶颈在排序。
## Code
注意代码中 $\{a_n\}$ 的下标是从 $0$ 开始的。
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
char buf[1<<20],*p1,*p2;
int a[1000000];
inline char gc()  // 快速读字符
{
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin))==buf?EOF:*p1++;
}
inline void read(int &x)  // 快读
{
    int c;
    while((c=gc())<'0'||c>'9');
    for(x=c^48;(c=gc())>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48));
}
int main()
{
	int n,st,ed;
	read(n);
    st=0,ed=n-1;  // 当前寻找最优解的范围
	for(int i=0;i<n;++i)
    {
        read(a[i]);
    }
    sort(a,a+n);
    for(int bit=1<<30;bit;bit>>=1)  // 从高到低按位枚举，bit标识当前位
    {
        if((a[st]&bit)||!(a[ed]&bit))  // 这位上全部相同，跳过
        {                              // 即最小的数这位为1，或最大的数这位为0
            continue;
        }
        if((a[ed]&bit)&&!(a[ed-1]&bit))  // 只有最后一个数这位为1
        {
            int t=a[ed]^=bit,i;
            for(i=ed-1;i>=st&&a[i]>t;--i)  // 单轮插入排序
            {
                a[i+1]=a[i];
            }
            a[i+1]=t;
        }
        else
        {
            int l=st,r=ed,mid;
            while(l<r)  // 二分0段和1段的分界点，找到第一个这位为1的数
            {
                mid=(l+r)>>1;
                if(a[mid]&bit) r=mid;
                else l=mid+1;
            }
            st=l;  // 缩小范围
        }
        if(ed-st<=1)  // 范围缩小到2个数以内，找到答案
        {
            break;
        }
    }
    printf("%d",a[st]&a[ed]);
	return 0;
}
```
完结撒花 *★,°*:.☆(￣▽￣)/$:*.°★*。

---


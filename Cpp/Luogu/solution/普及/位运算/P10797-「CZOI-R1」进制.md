# 「CZOI-R1」进制

## 题目描述

你有一个数 $x$，你需要对它进行 $n$ 次操作。

每次操作，你可以选择 $y$ 进制下的数 $x$ 的某**一个**有效位上数值增加 $1$。  
第一个非零数位及其后面的数位是有效位。

注意：
* **对于每次操作**，你可以任意取 $y\in[2,+\infty)$；
* 你需保证增加操作不会使 $y$ 进制下的数 $x$ 产生进位。

现在你需要求 $n$ 次操作后这个数最大是多少。

答案以十进制输出，并对 $10^9+7$ 取模。你需要输出的是这个数的最大值对 $10^9+7$ 取模的结果，而并非对 $10^9+7$ 取模后的最大值。

## 说明/提示

**【样例解释】**

很明显，$2$ 在二进制时为 $10$，在三或更高进制时为 $2$。

二进制时，在第一位 $+1$ 会导致二进制产生进位，只能在第二位 $+1$，此时得到的结果为 $11$，转换为十进制为 $3$。

在三或更高进制时，只能往末位 $+1$，三进制下会产生进位，舍去。四或更高进制时得到结果均为 $3$，转化为十进制的结果也是 $3$。

**【数据范围】**

**本题采用捆绑测试。**
- Subtask #1（$20\text{ pts}$）：$x\le 2$。
- Subtask #2（$20\text{ pts}$）：$n=1$。
- Subtask #3（$60\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le x,n\le10^9$，$1\le T\le10^6$。

## 样例 #1

### 输入

```
1
2 1```

### 输出

```
3```

# 题解

## 作者：Register_int (赞：19)

由于只能加 $y$ 进制表示下的最高位，这个最高位显然是 $\le x$ 的。这个最大值可以取到，当 $y=x$ 时，$x$ 的 $y$ 进制表示是 $10$，直接加成 $20$ 即可。每次操作会将 $x$ 变成 $2x$，所以最终答案是 $2^nx$……  
吗？事实上，当 $x\le2$ 时这样是行不通的，因为没有 $1$ 进制，$2$ 进制下 $20$ 会进位。所以单独讨论第一步：

- $x=1$ 时，选取 $y=3$，$x$ 的 $3$ 进制表示为 $1$，加上即可，答案为 $2$。
- $x=2$ 时，$x$ 单独为最高位的情况只有二进制，显然行不通。所以加上的数 $<2$。取 $y=4$ 有 $x=2$，直接加上即可，答案为 $3$。

那就做完了。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;
const int mod = 1e9 + 7;

inline 
int qpow(int b, int p) {
	int res = 1;
	for (; p; p >>= 1, b = (ll)b * b % mod) if (p & 1) res = (ll)res * b % mod;
	return res;
}

int T, x, n;

int main() {
	for (scanf("%d", &T); T--;) {
		scanf("%d%d", &x, &n);
		if (x == 1) x = 2, n--;
		if (!n) { printf("%d\n", x); continue; }
		if (x == 2) x = 3, n--;
		printf("%d\n", (ll)x * qpow(2, n) % mod);
	}
}
```

---

## 作者：_O_v_O_ (赞：10)

这里是 CZOI R1 的官方题解。

## 结论

当 $x=1$，$n=1$ 时，答案为 $2$；当 $x=1$，$n>1$ 时，答案是 $3\times2^{n-2}$；当 $x=2$ 时，答案是 $3\times 2^{n-1}$；当 $x\ge 3$ 时，答案是 $x\times 2^n$。

## 证明

铺垫一个前置知识：

假如有一个数 $y$，想把它转化成任意进制，使它的最高位最大，该转成几进制呢？

答案很简单，就是 $y$ 进制，因为其最高位的权值为 $y$，是最大的。

先证 $x\ge 3$：

根据上面的铺垫，可得每次直接转换成 $x$ 进制，在最高位 $+1$ 即可。

我们发现，这个操作等效于 $x\leftarrow x\times 2$，所以最终答案为 $x\times 2^n$，直接用快速幂算即可。

再证 $x\le 2$：

- $x=2$：很明显最优是花一次操作把 $x$ 变成 $3$，再按上述算法计算即可。
- $x=1$：花一次操作把 $x$ 变成 $2$ 再计算即可，不过要特判。

时间复杂度 $O(\sum n)$，用快速幂可以优化至 $O(\sum\log n)$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
typedef long long ll;
int quick_pow(int x,int y){
	ll ans=1,p=x;
	while(y){
		if((y&1)==1) ans=ans*p%mod;
		p=p*p%mod;
		y>>=1;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--){
		long long x,n;
		cin>>x>>n;
		while(x<=2 && n) x++,n--;
		cout<<quick_pow(2,n)*x%mod<<"\n";
	}
	return 0;
}
```


这是出题人赛后自己重新写的代码，用分讨写的：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int mod=1e9+7;
int T,n,x;

int fastexp(int a,int b,int c){
	int ans=1;
	while(b){
		if(b&1) ans=ans*a%c;
		a=a*a%c;
		b>>=1;
	}
	return ans;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>T;
	while(T--){
		cin>>x>>n;
		if(x==1&&n==1) cout<<2;
		else if(x==1) cout<<3*fastexp(2,n-2,mod)%mod;
		else if(x==2) cout<<3*fastexp(2,n-1,mod)%mod;
		else cout<<x*fastexp(2,n,mod)%mod;
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：4)

考虑一个数 $x\geqslant3$，那么对于一次操作，$x$ 最多增加 $x$，即转化为 $x$ 进制数 $(100\cdots0)_x$，再增加最高位变为 $(200\cdots0)_x$，即 $2x$。这是因为对于任意进制，将 $x$ 转为该进制后最高有效位代表的数一定小于或等于 $x$。那么对于 $x\geqslant3$，答案为 $2^nx$。

对于 $x\leqslant2$，我们只能将 $x$ 加到 $3$ 再进行以上操作，答案为 $3\times2^{n-(3-x)}$。如果 $x=1$ 且 $n=1$，即无法加到 $3$，则答案为 $2$。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;

int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod;b>>=1;
	}
	return s;
}

signed main(){
	int t;cin>>t;
	while(t--){
		int x,n;cin>>x>>n;
		if(x==1 && n==1) cout<<"2\n";
		else if(x<=2) cout<<3*qpow(2,n-(3-x))%mod<<"\n";
		else cout<<x*qpow(2,n)%mod<<"\n";
	}
	return 0;
}

```

---

## 作者：Thronf (赞：3)

## 前置知识
- 进制
- 快速幂
- 基础数论
## 推论
这道是数学题。因为 $n\le10^9$，所以是不可能枚举的，于是只能用数学方法来证明最优方案再进行选择。

以下是推导：

  当 $x \le 2$ 时，对于 $x$ 的操作最佳是使其变为 $x+1$；（易证）

 当 $3\le x$ 时，设进制取 $y$ 时最大，则 $y\le x$ 时最多加 $y^{[log_y x]}$ ，显然在 $x=y$ 时最大增加 $x$ ； $x<y$ 时，最多加 $1$（由于不能进位）。


 综上所述，若 $x=1$，则 $ans=3*2^{n-2}$；若 $x=2$，则 $ans=3 * 2^{n-1}$；若 $x\ge 3$，则 $ans = x * 2^{n}$。

## 细节
最后别忘了取模和快速幂！！！

## 代码

```cpp
#include<bits/stdc++.h>
#define il inline //内联 
#define int long long //忘开long long见祖宗 
using namespace std;
int p=1000000007;//取模 
il void write(int x){//快写（不然会超时） 
	char f;
	f=10;
	if(!x)
		putchar('0');
	else
	{
		if(x<0)
			putchar('-'),x=~x+1;
		char s[40]={};
		int k=0;
		while(x)
			s[++k]=x%10+48,x/=10;
		while(k)
			putchar(s[k--]);
	}
	putchar(f);
}
il int fast_pow(int b){//快速幂（基础思想：当 a^b 中 b为偶数时，原式=a^(b/2)*a^(b/2);否则，原式=a^[b/2]*a^[b/2]*a ([x]为不超过 x 的最大整数)）（具体见代码） 
	int answer=1,a=2;
	while(b){
		if(b&1)
			answer=answer*a%p;
		a=a*a%p,b>>=1;
	}
	return answer%p;
}
il int work(int x,int n) 
{
	if(n==0)
		return x;
	return (x*fast_pow(n))%p;
}
signed main()
{
	ios::sync_with_stdio(0);//关缓冲区（据说比格式化输入输出还快） 
	int T;
	cin>>T;
	while(T--)
	{
		int x=0,n=0;
		cin>>x>>n;
		if(x==1&&n<=2)
			write(x+n);//特判 
		else if(x==1&&n>2)
			write(work(x+2,n-2));//特判 
		else if(x==2)
			write(work(x+1,n-1));//特判 
		else
			write(work(x,n));//一般情况 
	}
	return 0;
}
//不要忘记取模和快速幂！！！！！ 
```

---

## 作者：fish_love_cat (赞：2)

任意进制，一种显然的想法是将 $x$ 放在 $x$ 进制下，即 $x_{(10)}=10_{(x)}$。

然后我们可以选择增加最高位，即 $20_{(x)}=2x_{(10)}$。

这样就能使原数翻倍，这是最大的，因为显然无论几进制都不能做到比原数翻倍更优秀的效果。

但是还是有问题的。

注意到当 $x\le 2$ 时会挂，因为会进位或者当前进制不存在。而显然在更高进制下操作的效果只是加一。

特判就行了。

注意 `cin` 会炸。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
long long qpow(long long a,long long b,long long p){
	long long ans=1;
	if(b==0){
		return 1;
	}
	while(b){
		if(b&1){
			ans*=a;
			ans%=p;
		}
		a*=a;
		b>>=1;
		a%=p;
	}
	return ans;
}
signed main(){
    int t;
    cin>>t;
    while(t--){
        int x,n;
        scanf("%lld%lld",&x,&n);
        while(x<=2&&n){
            x++,n--;
        }
        cout<<x*qpow(2,n,1e9+7)%1000000007<<'\n';
    }
    return 0;
}
```

---

## 作者：zhanghy123 (赞：1)

## 先说结论：
- $x=1,n \le 2$ 或 $x=2,n=1$ 时，结果为 $x+n$；
- $x=2,n>1$ 时，结果为 $3 \times 2^{n-1}$；
- $x=1,n>2$ 时，结果为 $3 \times 2^{n-2}$；
- 其余情况，结果为 $x\times 2^n$。
## 证明
### 对于 $x \ge 3$：
因为我们每次都可以转换进制，所以我们不妨将 $x$ 转为 $x$ 进制，此时它表示为 $10$。我们将它的最高位 $+1$，也就是 $20$，第一次转换后它在十进制下表示的数就是 $2x$。可以证明，这就是最优的方法。因为对于更低的进制，将最高位 $+1$ 后得到的结果一定不大于原数的二倍。

第二次，我们继续将其转为 $2x$ 进制，最高位 $+1$，得到 $2\times 2x=4x$。

第三次继续转为 $4x$ 进制，得到 $8x$，然后是 $2^4 x,2^5 x,2^6 x \cdots$。

不难发现，第 $n$ 次转换后得到的结果就是 $2^n x$，写个[快速幂](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%B9%82/5500243?fr=ge_ala)优化到 $O(\sum \log n)$ 然后直接输出即可。

### 对于 $x \isin \{1,2\}：$
$x \isin \{1,2\}$ 时，我们只能将其在十进制下不断 $+1$ 直到 $x=3$ ，然后才能将转化完的 $x=3$ 以上述方式处理。这会浪费掉我们 $3-x$ 次操作。特别地，如果操作次数不够,那么有几次就只能加几，结果为 $x+n$。

次数足够的话，结果就是 $3 \times 2^{n-3+x}$。

## 注意事项
1. $1\le x,n\le 10^9$，$T \le 10^6$，范围较大，需要**快读快写**，否则最后一点 TLE。
  
3. **$x \isin \{1,2\}$ 时的特判**。

因为上述这两点，本人赛时喜提 $20$ 分，在此警示后人。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,mod=1e9+7;
long long x,n;
long long qpow(long long p,long long q)
{
	if(q==0)
		return 1;
	else if(q&1)
		return qpow(p,q-1)%mod*p%mod;
	else
	{
		long long tmp=qpow(p,q/2);
		return tmp%mod*tmp%mod;
	}
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%lld%lld",&x,&n);
		if(x==1)
		{
			x=3;
			n-=2;
		}
		if(x==2)
		{
			x=3;
			n--;
		}
		if(n<0)
			printf("%lld\x",(n+x)%mod);
		else
			printf("%lld\x",(qpow(2,n)%mod*x)%mod);
	}
}
```

---

## 作者：nightwatch.ryan (赞：0)

### 思路
首先，如果要使一个数 $x$ 在 $y$ 进制下的**最高位的值最大**，显然 $y=x$ 时 $x$ 在 $y$ 进制下的最高位的值最大。因为此时最高位的值是 $y^1$，就是 $x$（因为 $x=y$），不能够再大了。

此时，$x$ 在 $x$ 进制表示下是 $10$，$x^1 \times 1 + x^0 \times 0 = x$。如果在 $x$ 进制下的 $10$ 的最高位加 $1$，那么 $10$ 就变成了 $20$，$x^1 \times 2 + x^0 \times 0 = 2x$，所以每进行一次操作就相当于给 $x$ 乘了一个 $2$，故答案就是 $x \times 2^n$。

但是有特殊情况：
- $x=1$，由于不存在 $1$ 进制，所以我们使用一次操作，将 $x$ 加 $1$ 变成 $2$ 再进行接下来的操作。
- $x=2$，虽然存在 $2$ 进制，但是 $2$ 进制下的 $10$ 在最高位上加 $1$ 是会进位的，所以我们使用一次操作将 $x$ 加 $1$ 变为 $3$ 再进行接下来的操作。

对于特殊情况，需要当前还有操作次数才可以进行操作。

可以用快速幂来计算答案，这样时间复杂度就是 $O(T \log n)$。
### 代码
```cpp
#include<iostream>
#define int long long
const int mod=1e9+7;
int qpow(int a,int b){
	int c=1;
	while(b){
		if(b&1)c=(c*a)%mod;
		a=(a*a)%mod,b>>=1;
	}
	return c;
} 
signed main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int t;
	std::cin>>t;
	while(t--){
		int x,n;
		std::cin>>x>>n;
		if(x==1&&n)x++,n--;
		if(x==2&&n)x++,n--;
		std::cout<<x*qpow(2,n)%mod<<std::endl;
	}
}
```

---

## 作者：Wangjiahuan2011 (赞：0)

# P10797 题解 #
## 题目分析
为了使最后的 $x$ 值最大，每一次操作的 $1$ 所加在的数位的位权都要尽量的大。容易想到将 $1$ 加在 $y$ 进制下的首位。此时使 $y = n$ 可以让首位位权为 $n$ ，达到最大。同时也解决了进位的问题。

但是还有两个特殊情况需要考虑：

- $x = 1$，此时由于 $y \ge 2$ ， $y$ 不能直接赋为 $x$ , 而此时不论 $y$ 是几，$y$ 进制下最高位位权都是 $1$，此时一次操作最大只能将 $x$ 变为 $1$。

- $x = 2$，如样例说明，此时一次操作最大只能将 $x$ 变为 $3$。

## 代码 ##
注意：不开 ```long long```见祖宗

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t, n, x, mod = 1000000007;
long long qp(long long a, long long b){
	long long c = 1;
	if(b <= 0) return 1;
	while(b != 1){
		if(b % 2) c = c * a % mod;
		a = a * a % mod; b /= 2;
	}return a * c % mod;
}int main(){
	scanf("%lld", &t);
	while(t--){
		scanf("%lld%lld", &x, &n);
		if(x == 1 && n >= 1) x = 2, n--;
		if(x == 2 && n >= 1) x = 3, n--;
		printf("%lld\n", x * qp(2, n) % mod);
	}return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：0)

## 思路

注意到最高有效位所占的数值 $\le n$，所以我们直接用 $n$ 进制，再把最高位 $+ 1$，整体 $\times 2$。答案为 $x \times 2^n$。注意当 $n = 1,2$ 时，这种方法会产生进位无法使用，需要特判。

数据较大，需要用快速幂。

时间复杂度 $O(T \log{n})$。本题轻微卡常。

## 代码

```cpp
#include<iostream>
using namespace std;
long long t,x,n;
const long long md=1e9+7;
inline long long ksm(int k){
	long long ans=1,j=2;
	while(k){
		if(k&1)ans=ans*j%md;
		j=j*j%md;
		k>>=1;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>x>>n;
		if(x==1){
			if(n<=2){cout<<1+n<<endl;continue;}
			else x=3,n-=2;
		} 
		if(x==2){
			if(n==1){cout<<3<<endl;continue;}
			else x=3,n--; 
		}
		cout<<x*ksm(n)%md<<endl;
	}
	return 0;
}
```

---

## 作者：TheForgotten (赞：0)

# P10797 「CZOI-R1」进制 题解
[题目传送门](https://www.luogu.com.cn/problem/solution/P10797)

## 题意
有一个数 $x$，需要对它进行 $n$ 次操作，每次操作，你可以选择 $y$ 进制下的数 $x$ 的某个有效位上数值增加 $1$。你可以任意取 $y\in[2,+\infty)$，但是增加操作不能使 $y$ 进制下的数 $x$ 产生进位。求 $n$ 次操作后这个数最大是多少。

## 思路
由于最高的有效位数值绝对是 $≤n$ 的，所以考虑直接使用 $n$ 进制，令最高位 $+1$，整体 $\times2$，答案为 $2^{n}x$。

但是通过样例便可以得知，$x=2$ 只有二进制可以使用，推翻了之前的结论，所以猜想某些特殊值使推导出的答案不成立。样例中 $x$ 单独为最高位的情况只有二进制，不成立。于是向下找到 $x=1$，发现没有一进制，所以特判上述两种情况即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int t,x,n;
const int o=1e9+7;
int check(int k){
	int ans=1,j=2;
	while(k){
		if(k&1)ans=ans*j%o;
		j=j*j%o;
		k>>=1;
	}
	return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(),cout.tie();
	cin>>t;
	while(t--){
		cin>>x>>n;
		if(x==1){
			if(n<=2){
				cout<<1+n<<"\n";
				continue;
			}
			else{
				x=3;
				n-=2;
			}
		} 
		if(x==2){
			if(n==1){
				cout<<3<<"\n";
				continue;
			}
			else{
				x=3;
				n--;
			}
		}
		cout<<x*check(n)%o<<"\n";
	}
	return 0;
}

```

---


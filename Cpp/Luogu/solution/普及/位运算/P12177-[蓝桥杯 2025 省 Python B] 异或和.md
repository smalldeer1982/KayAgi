# [蓝桥杯 2025 省 Python B] 异或和

## 题目描述

小蓝有 $n$ 个数 $a_i$，他想知道这 $n$ 个数中的所有数对下标的差值乘上它们的异或之后，得到的结果的和是多少。

也就是说，小蓝想要得到

$$\sum_{i=1}^{n} \sum_{j=i+1}^{n} (a_i \oplus a_j) \times (j - i)$$

的值，其中 $\oplus$ 表示按位异或。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 2^{20}$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
8```

## 样例 #2

### 输入

```
4
9 8 7 6```

### 输出

```
118```

# 题解

## 作者：wenqinghua1001 (赞：4)

## 思路

本题要求输出

$$\sum_{i=1}^{n} \sum_{j=i+1}^{n} (a_i \oplus a_j) \times (j - i)$$

的值。

首先，暴力使用双重循环，对于 $100\%$ 的数据，$1 \le n \le 10^5$，$n^2$ 最大是 $10^{10}$，定会超时，排除 $O(n^2)$ 做法。那么肯定要进行优化。

首先，数据最大值的二进制有多少位，**外循环**就遍历多少次。$1 \le a_i \le 2^{20}$，外循环最多遍历 $20$ 次。**内循环**从最小位开始，拿出每个数据二进制的第 $i$ 位，只有当两个数一个为 $0$，一个为 $1$ 时，才会对最后结果产生贡献。因为按位异或的原理全是真或全是假为 $0$，一假一真为 $1$。

就拿第二组样例说，第 $i$ 层内循环求出所有从右向左第 $i$ 个数是 $1$ 和 $0$ 的两个数，**位权**和**位置差**的积，例示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1o65lkie.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/4if53tiq.png)

以此推出第三层、第四层，最终答案是 $6+16+32+64=118$。

## Python 代码

[AC 记录](https://www.luogu.com.cn/record/215983230)

```python
import sys
input = lambda: sys.stdin.readline().strip()
n = int(input())
a = list(map(int, input().split()))
ans = 0
for i in range(20):
    xiabiaohe_0 = 0 
    xiabiaohe_1 = 0
    geshu_0 = 0 
    geshu_1 = 0
    for j in range(n):
        q = (a[j] >> i) & 1
        if q==1: # 此位为 1。
            ans += (j * xiabiaohe_0 - geshu_0) * (1 << i)
            xiabiaohe_1 += 1
            geshu_1 += j
        else: # 此位为 0。
            ans += (j * xiabiaohe_1 - geshu_1) * (1 << i)
            xiabiaohe_0 += 1
            geshu_0 += j
print(ans)
            
        
```

---

## 作者：makerlife (赞：4)

[Blog Link](https://blog.makerlife.top/post/uncategorized-problems/#P12177-%E8%93%9D%E6%A1%A5%E6%9D%AF-2025-%E7%9C%81-Python-B-%E5%BC%82%E6%88%96%E5%92%8C)

### Solution

按位考虑，注意到 $1\oplus0=1$，也就是说只有两个数当前位不同才能产生贡献。

按位枚举，对于每一位的数正向扫，统计之前有多少个数可以产生贡献 $num$，和产生贡献数的位置和 $lsum$。

当前枚举到第 $j$ 个数。

- 如果当前位为 $0$，那么产生的贡献为 $2^i\times (j\times num - lsum)$；

- 如果为 $1$，各变量直接用总数减去 $0$ 的即可。

时间复杂度 $\mathcal{O}(n\log n)$。

### Core Code

```cpp
for (int i = 0; i <= 20; i++) {
    int lsum = 0, num = 0;
    for (int j = 1; j <= n; j++) {
        int v = ((a[j] >> i) & 1);
        if (!v) {
            ans += (1 << i) * (num * j - lsum);
        } else {
            ans += (1 << i) * ((j - 1 - num) * j - ((j - 1) * j / 2 - lsum));
            num++, lsum += j;
        }
    }
}
```

---

## 作者：guoshengyu1231 (赞：3)

# 前言
由于这题原本是给`python`代码写的，所以我们用`c++`写暴力枚举也可以过，但这题标准答案是用 $O(n \log n)$ 时间复杂度的算法来写的，所以在这里我只介绍标准方法。
# 思路
既然要让时间复杂度降低至 $O(n \log n)$ 级别，那我们可以从位的角度来思考。由于异或运算本身就是建立在位的基础上的，所以我们只需要用一层循环枚举位。由于 $1\le a_i\le 2^{20}$，所以外层循环复杂度 $O(\log a_i)$ 完全够用。那么内层循环枚举每个数带来的贡献，时间复杂度 $O(n)$。总时间复杂度 $O(n \log a_i)$。 $\\$ 
# 实现
大致的框架已经有了，接着我们需要考虑如何将我们的思路用代码实现出来。既然外层循环只是用来枚举位的，那我们可以不用管。重要的是在内层循环中如何统计每个数在这个位中做出的贡献。这个我们得先回看公式：
  $$\sum^n_{i=1}\sum^n_{j=i+1}(a_i\oplus a_j)\times(j-i)$$ 
可以看到，如果先不考虑后面的 $j-i$，那么只有用两个变量统计每位 $0$ 和 $1$ 的个数。然后枚举每个数时，如果这一位是 $0$，那他得跟这一位为 $1$ 的数异或才能有贡献，所以加上这一位为 $1$ 的数的个数再乘以这一位的权值。反之则加上这一位为 $0$ 的数的个数再乘以这一位的权值。
$\\$ 

那么现在问题来了，现在还得乘上 $j-i$，也就是每一个数他也有一个权值，而且还在不断变化，难道我们还得开一个数组来记录每一个数的权值吗？肯定不可能。观察公式，我们可以发现 $i$ 一直是不变的，只有 $j$ 在增加。那每一次 $j$ 增加 $1$，$j-i$ 也会增加 $1$，也就是每一个数的权值也会增加 $1$，那么我们只需要再新建两个变量来记录每位 $0$ 和 $1$ 的权值，每次只需要加上权值即可。
$\\$ 

现在还有一个问题等待着我们解决，那就是每一位上 $0$ 和 $1$ 的权值如何更新。这个其实很简单，因为每一位上 $0$ 和 $1$ 的权值就是每一位上所有数中 $0$ 和 $1$ 的权值之和，那我们已经可以统计每位 $0$ 和 $1$ 的个数，而每次这些数的权值都在加 $1$。那每一位上 $0$ 和 $1$ 的权值只需要加上相对应的个数就行啦！
# 示例
输入：

```cpp
3
1 2 3
```
转化成二进制就是这样子的：

```cpp
0 1
1 0
1 1
```
先来看第一位。此时枚举到第一个数由于此时 $0$ 和 $1$ 的权值都是 $0$，所以总贡献为 $0$。然后来到第二个数，由于出现了一个这一位为 $1$ 的数，所以 $1$ 的权值更新为 $1$。因此这次贡献为当前数值的权值 $\times$ 当前位的权值，也就是 $1\times 1=1$。
最后到了第三个数，此时 $0$ 的权值更新为 $1$，因为有了一个当前位为 $0$ 的数。所以当前贡献为当前数值的权值 $\times$ 当前位的权值，也就是 $1$。
 $\\$ 

再来看第二位。第一个数依然贡献为 $0$，所以直接来看第二个数，此时 $0$ 的权值更新为 $1$，因此这次贡献为当前数值的权值 $\times$ 当前位的权值，也就是 $1\times 2=2$。最后到了第三个数，此时 $0$ 的权值更新为 $2$，因为每一次每个数的权值都会加 $1$。因此这次的贡献为 $2\times 2=4$。  
 $\\$ 

最后累加总贡献，得数为 $8$。 
# 代码

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int maxn=100005;
int n,a[maxn],ans;
int read()
{
	int num=0;
	char s[100];scanf("%s",s);
	for(int i=0;i<strlen(s);i++) num=num*10+s[i]-'0';
	return num;
}
void write(int num)
{
	if(num>9) write(num/10);
	putchar(num%10+'0');
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int k=0;k<=20;k++)
	 {
	 	int cnt[2]={0,0};
	 	int sum[2]={0,0};
	 	for(int i=1;i<=n;i++)
	 	 {
	 		int bit=(a[i]>>k)&1;
	 		ans+=sum[bit^1]*(1<<k);
	 		cnt[bit]++;
	 		sum[0]+=cnt[0];sum[1]+=cnt[1];
		 }
	 }
	write(ans);
	return 0;
}
```
# 代码解释
- 读写处理：由于答案较大，需要用`__int128`来存储。但`__int128`不能直接输入和输出，所以需要转换为字符串来处理。
- ‌逐位处理‌：对于每一位 $k$（$0$ 到 $20$），统计该位上 $1$ 和 $0$ 的个数（$cnt_1$，$cnt_0$）以及它们的权值（$sum_1$，$sum_0$）。
- ‌贡献计算‌：
  - 如果 $a_i$ 的第 $k$ 位为 $1$，则与之前所有第 $k$ 位为 $0$ 的数组成数对，贡献为 $sum_0\times 2ᵏ$。
  - 如果 $a_i$ 的第 $k$ 位为 $0$，则与之前所有第 $k$ 位为 $1$ 的数组成数对，贡献为 $sum_1\times 2ᵏ$。
- 更新权值：代码中的 $bit$ 代表 $a_i$ 的第 $k$ 位。并且让 $cnt_{bit}$ 加 $1$，表示该位上 $bit$ 的个数加 $1$。然后就是让每一位上 $0$ 和 $1$ 的权值加上相对应的个数。
 $\\$

---

## 作者：KomeijiReimu (赞：2)

https://www.luogu.com.cn/problem/P12177

这道题在拆分每一位的基础上，推导出了一个神秘的公式。

分别按照下标顺序遍历每个数的第 1 位、第 2 位......如果这一位是 0 ，那么按照题目要求的公式计算之后这一位的结果为
$$
\text{当前数字的下标} \times \text{目前遇到的\ 1\ 的数量} - \text{目前遇到的所有\ 1\ 的下标和}
$$
如果这一位是 0 则同理


![](https://cdn.luogu.com.cn/upload/image_hosting/g1x9tbix.png)

```python
import sys

input = lambda: sys.stdin.readline().strip()

n = int(input())
a = list(map(int, input().split(" ")))
ans = 0

for i in range(32):
    sum0 = 0  # 目前这一位 0 的总数
    sum1 = 0
    index0 = 0  # 目前这一位 0 的下标和
    index1 = 0
    sum = 0

    for j in range(len(a)):
        num = a[j] & 1
        if num == 1:
            sum += (j + 1) * sum0 - index0
            sum1 += 1
            index1 += j + 1
        else:
            sum += (j + 1) * sum1 - index1
            sum0 += 1
            index0 += j + 1

        a[j] >>= 1

    sum *= (1 << i)
    ans += sum

sys.stdout.write(str(ans))

```

---

## 作者：lcfollower (赞：2)

首先暴力 $\mathcal O(n^2)$ 包 TLE。

观察数据，$1\le a_i\le 2^{20}$，如果时间和值域无关可以设 $a_i$ 小于等于一个极大值，猜测时间复杂度与值域有关。

异或的题一般两种方法：二进制逐位处理和字典树，这里用第一种方法。

明显 $0\oplus 1 = 1$，$1\oplus 0 = 1$，于是考虑分别处理当前数的二进制在当前位置下为 $0$ 和 $1$ 的情况。

设当前处理到第 $i$ 位（从右往左从 $0$ 开始），处理的数是 $a_j$。

- 如果 $a_j$ 的第 $i$ 位是 $0$，则对答案贡献为 $bit \times (j \times sum1 - p1)$，其中 $bit$ 为第 $i$ 个二进制位的权值（即 $2^i$），$sum1$ 为前面的数第 $i$ 位为 $1$ 的个数，$p1$ 为前面的数第 $i$ 位为 $1$ 的数的 $j'$ 的和。这样我们可以实现 $\sum (j - j')$ 的计算（乘法具有结合律）。

- 如果 $a_j$ 的第 $i$ 位是 $1$，则对答案的贡献为 $bit\times (j \times sum0 - p0)$，$sum0$，$p0$ 的解释如上。

这样我们就能完成此题，时间复杂度为 $\mathcal O(n\log a)$。

---

以下为 python 代码，由 <https://www.deepseek.com> 把 C++ 代码改成 python 语言：


```python
import sys

def main():
    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split()))
    
    ans = 0
    bit = 1
    
    for i in range(21):
        p0 = 0
        p1 = 0
        sum0 = 0
        sum1 = 0
        
        for j in range(n):
            current = a[j]
            if (current >> i) & 1:
                ans += bit * ((j + 1) * sum0 - p0)
                p1 += j + 1
                sum1 += 1
            else:
                ans += bit * ((j + 1) * sum1 - p1)
                p0 += j + 1
                sum0 += 1
        
        bit <<= 1
    
    print(ans)

if __name__ == "__main__":
    main()
```

附加 C++ 代码，但是通过计算会发现：

> 十年 OI 一场空，不开 `__int128` 见祖宗。

```cpp
#include<bits/stdc++.h>

#define int __int128
#define up(i,x,y) for(int i=x;i<=y;i++)

using namespace std;

inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();return x*f;}
inline void write(int x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10|48);}
inline void writeln(int x){write(x),putchar('\n');}
inline void writesp(int x){write(x),putchar(' ');}

const int N = 1e5 + 10;
int n ,a[N] ,ans ,pre[N];

signed main(){
  n = read ();
  up (i ,1 ,n) a[i] = read () ;
  int bit = 1;
  up (i ,0 ,20){
    int p0 = 0 ,p1 = 0 ,sum0 = 0 ,sum1 = 0;
    up (j ,1 ,n){
      if ((a[j] >> i) & 1) ans += bit * (j * sum0 - p0) ,p1 += j ,sum1 ++;
      else ans += bit * (j * sum1 - p1) ,p0 += j ,sum0 ++;
    }
    bit <<= 1;
  } writeln (ans);
  return 0;
}
```

---

## 作者：Meickol (赞：1)

## 二进制拆位 + 贡献计算 + 快写输出 int128

原式：
$$
\sum_{i=1}^{n} \sum_{j=i+1}^{n} (a_i \oplus a_j) \times (j - i)
$$
等价于：
$$
\sum\limits_{k=0}^{20} \Bigg( 2^k \times \sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n} (j-i)[a_{i, k} \not=a_{j, k}] \Bigg)
$$
为了更贴合我们的习惯，我们调换一下 $i$ 和 $j$ 的大小关系：
$$
\sum\limits_{k=0}^{20} \Bigg( 2^k \times \sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i-1} (i-j)[a_{i, k} \not=a_{j, k}] \Bigg)
$$
不难发现可以使用贡献计算的方式解决。

用 $cnt_{k,0/1}$ 记录枚举到的前 $i$ 个数的二进制表示下第 $k$ 位为 $0/1$ 的个数。

再用 $sum_{k,0/1}$ 记录枚举到的前 $i$ 个数的二进制表示下第 $k$ 位为 $0/1$ 的下标总和。

设当前枚举到的第 $i$ 个数的二进制表示下第 $k$ 位为 $bit$。

那么问题就转化为：
$$
\sum\limits_{k=0}^{20} \Bigg( 2^k \times \sum\limits_{i=1}^{n}(cnt_{k,bit \oplus 1} \times i - sum_{k,bit \oplus 1} )\Bigg)
$$
由于 $2^k$ 可以达到 $2^{20}=10^6$ 规模，任意的 $(i,j)$ 数对可以达到 $n^2=10^{10}$ 规模，而 $i-j$ 又可以达到 $n=10^5$ 规模。共 $10^6 \times 10^{10} \times 10^5 = 10^{21}$ 规模，所以可能爆 long long，需要开 `__int128`。


$$
\large \mathscr Talk \quad  is \quad cheap \ , \ Show \quad me \quad the \quad code.
$$

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
typedef long long LL;
const int N=1e5+5;
LL n;
LL a[N];
LL cnt[22][2],sum[22][2];
inline void write(__int128 x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
void solve(){
	cin>>n;
	rep(i,1,n) cin>>a[i];
	__int128 ans=0;
	per(k,20,0){
		rep(i,1,n){
			int bit=(a[i]>>k)&1;
			ans+=(1LL<<k)*(cnt[k][bit^1]*i-sum[k][bit^1]);
			cnt[k][bit]++,sum[k][bit]+=i;
		}
	}
	write(ans);
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P12177)

### 思路

考虑拆贡献。先不考虑 $(j-i)$，异或的贡献很好拆，如果 $a_i$ 和 $a_j$ 二进制下第 $k$ 位不同，那么会产生 $2^k$ 的贡献。这启示我们，可以用一个数组 $b_{i,j}$ 表示第 $i$ 位取 $j(0/1)$ 的值有多少个，这样产生的贡献是 $2^k×b_{k,a_i的第k位取反}$，这样每次插入一个数都可以 $O(\log V)$ 维护。接下来考虑乘 $(j-i)$，显然对于每个新加入的元素，它跟下一个加入的元素的 $(j-i)$ 为 $1$，下下个为 $2$......，以此类推。那么我们可以考虑维护一个数组 $cnt_{i,j}$，表示目前第 $i$ 为二进制下有多少个数取 $j(0/1)$，这样每次插入新元素后令 $b_{i,j}\to b_{i,j}+cnt_{i,j}$ 即可，时间复杂度 $O(n\log V)$，可以通过。

### Code

代码比较好写，注意答案很大，需要使用合适的数据类型存储。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll __int128
const int N = 1e5 + 10;
int a[N], n;
ll b[30][2], cnt[30][2];
void print(ll x)
{
    if(x < 10) putchar(x + '0');
    else print(x / 10) ,putchar(x % 10 + '0');
}
int main()
{
    cin >> n;
    for(int i = 1;i <= n;++i) scanf("%d", &a[i]);
    ll ans = 0;
    for(int i = 1;i <= n;++i)
    {
        for(int j = 0;j <= 20;++j)
        {
            ans += (1ll << j) * b[j][!((a[i] >> j) & 1)];
            b[j][0] += cnt[j][0], b[j][1] += cnt[j][1];
            b[j][(a[i] >> j) & 1]++;
            cnt[j][(a[i] >> j) & 1]++;
        }
    }
    print(ans);
    return 0;
}
```

---

## 作者：zzy0618 (赞：0)

和 [P7627](https://www.luogu.com.cn/problem/P7627) 是几乎一样的。

依然按位拆贡献，维护 $st_{d,0/1}$ 为前面的数二进制下第 $d$ 位为 $0,1$ 的有多少个数。后面的 $i-j$ 相当于一个数重复了 $i-j$ 次，维护一个 $ts_{d,0/1}$ 为乘上 $i-j$ 这个系数后的按位答案，在每一轮计算后将 $ts_{d,k}$ 加上一次 $st_{d,k}$ 即可。

值得注意的是最终答案大小高达 $10^{21}$，需要 ```int128```。

```cpp
#include<bits/stdc++.h>
#define int long long
#define Int __int128
using namespace std;
int n;Int ans;
int st[21][2],ts[21][2];
void write(Int x){
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
signed main(){
    ios::sync_with_stdio(0); 
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1,x;i<=n;++i){
        cin>>x;
        for(int j=20;j>=0;--j)
            ans+=ts[j][((x>>j)&1)^1]*(1ll<<j),
            ++st[j][(x>>j)&1],
            ts[j][0]+=st[j][0],ts[j][1]+=st[j][1];
    }write(ans);
    return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

我们知道，只有当两个二进制数的相同位不同时，他们的异或和的这一位才为 $1$，否则为 $0$。那么枚举每个二进制位和数组的每个数，就可以在 $O(n\log n)$ 的时间得到正确答案。

不过这道题原来是给 `python` 代码写的，用 `c++` 写要用 `__int128` 才能过。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 ll;
int n;
void print(ll x){
    if(x>9) print(x/10);
    putchar(x%10^48);
}
int main(){
    cin>>n;
    vector<int>a(n);
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    ll ans=0;
    for(int i=0;i<20;i++){
        ll cnt0=0,sum0=0,cnt1=0,sum1=0,res=0;
        for(int j=0;j<n;++j){
            ll pos=j+1;
            ll num=a[j];
            ll b=(num>>i)&1;
            if(b==0){
                res+=pos*cnt1-sum1;
                ++cnt0;
                sum0+=pos;
            }else{
                res+=pos*cnt0-sum0;
                ++cnt1;
                sum1+=pos;
            }
        }
        ans+=res*(1LL<<i);
    }
    print(ans);
    return 0;
}
```

---

## 作者：SafariMo (赞：0)

本题模拟即可。

具体的，枚举 $i , j$，并计算题目中给出的公式。

其实也可以拆位做，时间复杂度 $\mathcal O (n \log n)$，但是我没写。

upd：？std 锅了后重测，现在代码过不了了，我把拆位写了。

主要思想是考虑每一个 bit，之前有多少个和它不同的，很好计算贡献，$\sum_{i \le j} (j - i)(a_i \operatorname{xor} a_j) = \sum_{k \le 20} \sum_{j}\sum _{i < j} F(i , j , k) (j - i)$，其中 $F(i , j , k)$ 表示 $(i , j)$ 的第 $k$ 位是否相同，这样的话维护两个前缀和即可解决问题。 

[代码](https://www.luogu.com.cn/record/213609147)。

核心代码：

```
		n = read();
		f(i , 1,  n) a[i] = read();
		__int128 ans = 0;
		f(k , 0 , 20) {
			memset(cnt , 0 , sizeof cnt);
			memset(s , 0 , sizeof s);
			f(j , 1 , n){
				bool f = a[j] >> k & 1;
				ans += (s[f ^ 1] * j - cnt[f ^ 1]) * (1LL << k);
				cnt[f] += j;
				s[f] ++;
			}
		}
```

注意答案会超过 $10^{20}$。

---


# [NWRRC 2023] Kitchen Timer

## 题目描述

Kenny 的厨房里有一个微波炉。这个微波炉有一个非常奇怪的单按钮定时器界面。

当你把食物放进微波炉并想要开始加热时，你需要按下按钮一次或多次。当你第一次按下按钮时，定时器会被设置为 $1$ 分钟。如果你立刻再次按下按钮，定时器会再增加 $2$ 分钟，总共变为 $3$ 分钟。如果你再次立刻按下按钮，则会再增加 $4$ 分钟，以此类推。如果你连续第 $k$ 次按下按钮，定时器会增加 $2^k$ 分钟。

看起来有些时间是无法通过这种方式设置的，比如说，如何设置 $2$ 分钟？幸运的是，你可以通过暂停一秒来重置按钮计数器。例如，如果你按一次按钮，暂停一秒，然后再按一次按钮，定时器就会被设置为 $2$ 分钟。再比如：如果你按、按、暂停、按、按、按，那么定时器上的总时间就是 $1+2+1+2+4=10$ 分钟。

Kenny 需要将食物加热恰好 $x$ 分钟。请你帮他计算，设置定时器为 $x$ 分钟时，最少需要多少次一秒的暂停。假设只有暂停会消耗时间，按按钮的时间可以忽略不计。

## 说明/提示

在第一个样例测试中，不需要暂停：Kenny 只需按一次按钮即可。

在第二个样例测试中，Kenny 可以按一下，暂停，再按一下，将定时器设置为 $2$ 分钟。

在第三个样例测试中，Kenny 只需连续按两次按钮即可设置 $3$ 分钟。

在第四个样例测试中，Kenny 可以按、按、暂停、按，将定时器设置为 $1+2+1=4$ 分钟。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
7
1
2
3
4
10
239
123456789012```

### 输出

```
0
1
0
1
1
4
19```

# 题解

## 作者：loushujia (赞：1)

## 前言

蒟蒻心血来潮做的一道题，因为还没有通过一道题号数字有五位数的题。

:::info[翻译（参考机翻）]
### 题目描述

Kenny 的厨房里有一个微波炉，配有一个奇怪的单按钮计时器界面。
当把食物放入微波炉并想开始加热时，你需要按下按钮一次或多次。第一次按下按钮时，计时器设置为 $1$ 分钟。如果立即再次按下按钮，计时器会增加 $2$ 分钟（总计 $3$ 分钟）。紧接着再按一次，会增加 $4$ 分钟，以此类推。如果连续按下按钮第 $k$ 次，它会增加 $2^{k-1}$ 分钟。

仅通过连续按按钮无法设置某些时间（例如 $2$ 分钟）。幸运的是，你可以通过暂停一秒钟来重置按钮计数器。例如：按一次、暂停一秒、再按一次，可以设置 2 分钟。另一个例子：按两次（$1+2$）、暂停、再按三次（$1+2+4$），总时间为 $1+2+1+2+4=10$ 分钟。

Kenny 需要加热食物恰好 $x$ 分钟。请帮助他找到设置计时器所需的最少暂停次数（假设只有暂停消耗时间，按按钮的时间忽略）。

### 输入格式

- 第一行包含测试用例数 $t$（$1 \le t \le 10^4$)。
- 接下来 $t$ 行，每行一个整数 $x$（$1 \le x \le 10^{18}$），表示需要加热的分钟数。

### 输出格式

- 对于每个测试用例，输出一个整数，表示最少暂停次数。

### 样例

略

### 说明/提示

- $x=1$：按一次，无需暂停。
- $x=2$：按、暂停、按，暂停 $1$ 次。
- $x=3$：按两次，无需暂停。
- $x=4$：按两次、暂停、按一次，暂停 $1$ 次。
:::

## 思路

### 分析

~~**As we all know，**~~ **连续**按 $k$ 次按钮，**增加**的分钟数为 $1+2+4+…+2^{k−1}=2^k−1$。所以我们可以将 $x$ 看为 $n$ 个 $2^k-1$ 的和（$n\ge1$)。问题就转化为使 $n$ 最小化，所求的暂停数就等于 $n-1$。

### 数学推导

~~蒟蒻数学不好，凑合看吧 QaQ~~

已知最少分段数为 $n$，则暂停次数为 $n−1$。每段对应一连续按钮序列，其和为 $2^{k_i}−1$ 则：

$$
x=\sum_{i=1}^n(2^{k_i}-1)=(\sum_{i=1}^n2^{k_i})-n
$$

移项得：

$$
x+m=\sum_{i=1}^n2^{k_i}
$$

其中 $k_i\ge1$（即 $2^{k_i}\ge2$）。

### 条件：

1. $x+n$ 必须能表示为 $m$ 个 $2$ 的幂次（指数 $\ge1$) 之和。
2. 由于每个幂次至少为 $2$，有 $x+m\ge2m$（即 $x\ge m$）。
3. $x+m$ 的二进制表示中 $1$ 的个数（记为 $cnt$）必须满足 $cnt\le m$（因为重复幂次可通过拆分合并，例如 $2^k+2^k=2^{k+1}$，拆分操作可增加项数）。

### 算法

**枚举**即可。可以使用 GCC 内部函数快速统计 `__builtin_popcountll()` 一个二进制数 $1$ 的个数。

### 复杂度

$x$ 最大 $10^{18}$，二进制最多不超过 $64$ 位，所以枚举到 $70$ 完全可以。

### 代码

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;
int t;
int main()
{
    scanf("%d",&t);
    while (t--)
   {
        ll x;
        scanf("%lld",&x);
        // 枚举分段数 m (从 1 到 70)
        for (int n = 1; n <= 70; n++)
       {
            if (x < n) continue;  // 不满足基本条件 x ≥ m
            ll num = x + n;
            int cnt = __builtin_popcountll(num);  // 使用内置函数计算 1 的个数
            if (cnt <= n)
            {
                printf("%d\n",n-1);  // 暂停次数 = 分段数 -1
                break;
            }
        }
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/229022372) QAQ

---

## 作者：luozejun_190813 (赞：1)

#### 解题思路
实际上如果连续按下 $p$ 次按钮，时间将会累加，转换成这种形式，是十分有利于我们做数学分析的。

那么，如果我们 $k$ 次连续按下 $p_i$ 次按钮，那么时间 $x$ 表示为 $x=2^{p1}-1+2^{p2}-1+…+2^{pk}-1$ 假设此时 $pi$ 互不相同，那么问题转换为 $x+k$ 换成 $2$ 进制是否含有 $k$ 个 $1$。

当然还有 $pi$ 有些相同的情况，问题要再转换为 $x+k$ 换成 $2$ 进制含有 $1$ 的个数不超过 $k$（存疑）。

这样转换的依据为：相当于在二进制中，两个 $1$ 被合并为一个 $1$。(存疑的原因是：$p=1$ 时就无法进行拆分)

所以我们对每一个 $k$ 进行检验，满足条件的即可作为答案，答案为 $k-1$。

由于 $x$ 转化成二进制的位数不大(至多 $60$ 位)，$k$ 的部分看作常数。


#### code
```cpp
#include<bits/stdc++.h>
using namespace std;
void solve() {
	long long x, n, tot;
	scanf("%lld", &x);
	for (long long i = 1; i <= 60; i++) {
		n = x + i;
		tot = 0;
		while (n > 0) {
			if (n & 1 == 1)
				tot++;
			n = n >> 1;
		}
		if (tot <= i) {
			printf("%lld\n", i - 1);
			return;
		}
	}
}
int main () {
	int T;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

---

## 作者：OverskidExMonikium (赞：1)

题意：输入一个数，计算其可以被拆分为多少 $\sum_{k = 1}^{n} 2^{k-1}$，输出这个数量减一。  
考虑贪心，每次找到最大的 $n$，如果不能再大再使数量加一，直到完成。  
记得开`long long`。  
代码实现：
```
#include<bits/stdc++.h>
using namespace std;
long long t,x,s,c;
int main(){
	for(cin >> t;t;t--){
		cin >> x;
		s=1,c=0;
		while(x)
			if(s>x)c++,s=1;
			else x-=s,s*=2;
		cout << c << '\n';
	}
	return 0;
}
```

---

## 作者：Forge_Unique (赞：1)

## 思路

要使暂停的次数最少，即让每次连续按计时器的数量尽可能的多。显而易见，连续的按 $k$ 次计时器即为计时 $2^k - 1$ 秒。所以我们从最大的可能的 $k$ 开始计时，直到 $n \le 0$ 为止，过程中记录一个 $ans$，每次让 $ans + 1$ 则答案为 $ans - 1$。

## 代码 

```
#include<cmath>
#include<iostream>
#define int unsigned long long
using namespace std;
int T,n;
signed main(){
    cin >> T;
    while(T--){
        cin >> n;
        int ans = 0;
        for(int i = 60;i >= 1;i--){
            int x = 1ll << i;
            x--;
            while(n >= x){//记录每次的计时
                n -= x;
                ans++;
            }
        }
        cout << ans - 1 << endl;
    }
    return 0;
}
```

---

## 作者：Yumi_Anaxa_ (赞：0)

[**题面链接**](https://www.luogu.com.cn/problem/P13591)
## 思路
连续按 $k$ 次可以加 $1+2+4+\dots+2^{k-1}$ 分钟。暂停就会重新计 $k$。\
要将 $x$ 分成若干个像这样的和，并让**暂停的次数最少**。

#### 观察设置不同时间时要暂停多少次：
|设置的时间|暂停次数      |
|:---:|:--------:|
|$x=1$|$0$|
|$x=2$|$1$（分成 $1+1$）|
|$x=3$|$0$|
|$x=10$|$1$（分成 $3+7$）|

将时间转换成二进制后。
|设置的时间|暂停次数      |
|:---:|:--------:|
|$x=1$（$1$）|$0$|
|$x=2$（$10$）|$1$（分成 $1+1$）|
|$x=3$（$11$）|$0$|
|$x=10$（$1010$）|$1$（分成 $3+7$）|

可以发现，答案就是二进制下的 $x$ 中连续的 $1$ 的块数减 $1$。

#### 方法：
遍历二进制下的 $x$ 的每一位，记下连续的 $1$ 的块数。最少暂停次数就是记下的块数减 $1$。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
  int t;
  cin>>t;
  while(t--){
    ll x,res=0;//记录连续的1有多少块
    cin>>x;
    while(x>0){//处理x
      ll k=1;
      while((1ll<<k)-1<=x)k++;//找到满足2^{k-1}<=x下最大的x
      k--;//退回一位
      x-=(1ll<<k)-1;//减去这个串的值
      res++;//加上一块
    }
    cout<<res-1<<"\n";//块数-1就是答案
  }
  return 0;
}

```

---

## 作者：hlb44 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13591)

连续按 $k$ 次按钮的总时间是 $1 + 2 + 4 + \cdots + 2^{k-1} = 2^{k} -1 $ 分钟。

让我来解释一下（学过二叉树的忽略），$\sum_{i=1}^{k-1} 2 ^ i = 2 ^ 0 + \sum_{i=1} ^ {k-1} 2 ^ i - 2 ^ 0 = 2 ^ k -1$。

同时对于 $k$ 为任意非 $0$ 自然数时，$2 ^ k - 1$ 的二进制每一位都是 $1$，因为 $2 ^ i$ 即这个数的右数第 $i + 1$ 位为 $1$，而这个数的二进制刚刚好 $k - 1$ 位，所以每一位都是 $1$。

所以我们只需对于给定的 $x$，找到小于等于 $x$ 的最大“全 1 二进制数”（即 $2 ^ k - 1$ 形式的数），如果这个数等于 $x$，说明可以一次连续按完，不用暂停，否则，使用这个最大的连续时间段，加 $1$ 次暂停，再递归处理剩余的时间。

代码：
```cpp
#include<iostream>
using namespace std;
long long f(long long x) {
	long long s=1,m=1;
	while(s*2+1<=x) {
		s=s*2+1;
		m++;
	}
	return s==x?0:1+f(x-s);
}
int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int t;
	cin>>t;
	while(t--) {
		long long x;
		cin>>x;
		cout<<f(x)<<'\n';
	}
	return 0;
}

```

---

## 作者：_Hzq_ (赞：0)

## 题解：P13591 \[NWRRC 2023] Kitchen Timer

#### 分析题意

题目中提到，如果你连续第 $k$ 次按下按钮，定时器会增加 $2^k$ 分钟。如果我们暂停一次，便可以重置计数器，也就是 $k$ 会重新变为零，问我们如何暂停最少的次数来使计时器达到 $x$ 分钟。

#### 具体做法

看到“最少”，便能很容易想到贪心，只要我们连续按得次数够多，便可以使暂停的次数最少。

:::info[如何证明]
根据唯一分解定理，一个数可以被分解为一个唯一的形如 $a^{b_1}+a^{b_2}+···+a^{b_n}$ 但这个 $b$ 序列不一定是连续的，因此我们便将最大的数继续分解，直到 $b$ 序列变为一个由 $m$ 段连续上升序列组成的序列，形如 $(a^{k_1}+a^{k_1-1}+···+a^1)+(a^{k_2}+a^{k_2-1}+···+a_1)+···+(a^{k_n}+a^{k_n-1}+···+a^1)$，此时 $(a^{k_1}+a^{k_1-1}+···+a^1)$ 便是可连续按按钮次数最多时的贡献，这个序列是可以继续分解的，但分成的序列一定大于 $m$ 段，因此 $m$ 便是我们要求的答案
:::

#### Code

```cpp line-numbers
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n;
signed main()
{
	cin >> T;
	while(T--)
	{
		scanf("%lld",&n);
		int res=0;
		while(n>0)
		{
			res++; //记录暂停次数
			int temp=1;
			while(temp<=n) //连续按下次数尽可能多的按钮
			{
				n-=temp;
				temp<<=1;
			}
		}
		printf("%lld\n",res-1); //第一次按下按钮前是不用暂停的，因此只用输出res-1
	}
	return 0;
}
```

---

## 作者：Zayn_Pan (赞：0)

## 题目

戳[这里](https://www.luogu.com.cn/problem/P13591)看题目。

## 思路

设连续点击的次数为 $k$，则总和为 $1+2^1+2^2+2^3+\dots+2^{k-1}=2^k-1$。

所以答案与 $2^k-1$ 有关，打一点表找一下规律。

|输入的加热分钟数 $x$|点击方案      |暂停次数   |
|:--------:|:--------:|:-----:|
|$1$       |$1=(2^1-1)$|$0$    |
|$2$       |$1+1=(2^1-1)+(2^1-1)$|$1$    |
|$3$       |$1+2^1=(2^2-1)$|$0$    |
|$4$       |$1+2^1+1=(2^2-1)+(2^1-1)$|$1$    |
|$5$       |$1+2^1+1+1=(2^2-1)+(2^1-1)+(2^1-1)$|$2$    |
|$6$       |$1+2^1+1+2^1=(2^2-1)+(2^2-1)$|$1$    |
|$7$       |$1+2^1+2^2=(2^3-1)$|$0$    |
|$8$       |$1+2^1+2^2+1=(2^3-1)+(2^1-1)$|$1$    |
|$9$       |$1+2^1+2^2+1+1=(2^3-1)+(2^1-1)+(2^1-1)$|$2$    |
|$10$      |$1+2^1+2^2+1+2^1=(2^3-1)+(2^2-1)$|$1$    |
|$11$      |$1+2^1+2^2+1+2^1+1=(2^3-1)+(2^2-1)+(2^1-1)$|$2$    |
|$12$      |$1+2^1+2^2+1+2^1+1+1=(2^3-1)+(2^2-1)+(2^1-1)+(2^1-1)$|$3$    |
|$\dots$   |$\dots$   |$\dots$|

规律很明显了，求出每个 $x$ 是多少个形如 $2^k-1$ 的数相加而成的，记为 $ans$，答案就是 $ans-1$。 

可以提前预处理出在数据范围内的 $2^k-1$ 的数，存在一个数组里。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,x,p,a[60],k,ans;
signed main(){
    for(int i=2;i<=1e18;i*=2)a[++p]=i-1;
    cin>>T;
    while(T--){
    	k=p;
    	ans=0;
        cin>>x;
        while(a[k]>x&&k)k--;
        while(x&&k){
            ans+=x/a[k];
            x%=a[k];
            k--;
        }
        cout<<ans-1<<endl;
    }
    return 0;
}
```

---

## 作者：W_C_B_H (赞：0)

我们记操作 $k$ 表示连续按下 $k$ 次按钮，则答案即为最小的能使定时器上的时间恰好为 $x$ 分钟的操作次数减一（因为间隔数比操作数少一）。

显然操作 $k$ 会让定时器的总时间增加 $2^k-1$ 分钟。据此不难发现两次操作 $k$ 加上一次操作 $1$ 的实际效果与一次操作 $k+1$ 完全相同，而后者可以节省两次暂停。这启发我们尽量选择 $k$ 更大的操作来完成目标。

具体地，我们可以维护一个初始为 $0$ 的变量 $ans$，表示已经进行的操作次数。在读入 $x$ 后将 $i$ 从 $60$ 到 $1$ 倒序循环（$i$ 表示操作的编号，上界取 $60$ 是因为操作 $60$ 增加的时间 $2^{60}-1>10^{18}$），记 $p=2^i-1$，在 $x\ge p$ 时不断地使 $x$ 减去 $p$，并让 $ans$ 加一。最后输出 $ans-1$ 即可。循环的上界是 $O(\log x)$ 级别的，故可以通过本题。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read()
{
	int r=0; char c=getchar(); bool f=0;
	while(c<48 || c>57){ if(c=='-'){ f=1; } c=getchar(); }
	while(c>=48 && c<=57){ r=(r<<3)+(r<<1)+(c^48); c=getchar(); }
	return f?-r:r;
}
void write(int x)
{
	if(x<0){ putchar('-'); x=-x; }
	if(x>9){ write(x/10); }
	putchar(x%10+48);
}
void writeln(int x){ write(x); putchar('\n'); }
int t,x,ans;
signed main()
{
	t=read();
	while(t--)
	{
		x=read();
		ans=0;
		for(int i=60; i>=1 && x>0; i--)
		{
			int p=(1ll<<i)-1;	// 注意这里要写 1ll, 否则在 i 较大时 p 的值会有误 
			while(x>=p)
			{
				x-=p;
				ans++;
			}
		}
		writeln(ans-1);
	}
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：0)

### 思路

读题，容易想到用二进制去解。

连续按按钮时，计时器总共会加 $(1111\dots)_2$ 分钟。为了让暂停次数最少，我们应当让每次加的时间最大。于是我们每次减掉一个最大的 $(1111\dots)_2$ 分钟即可。

:::info[提示 1 $\hspace{3mm}(\dots)_y$ 表示什么？]
$(\dots)_y$ 表示 $\dots$ 是 $y$ 进制下的数。
:::

:::info[提示 2 $\hspace{3mm}O(1)$ 算出 $(1111\dots)_2$]
$(1111\dots)_2 = (10000\dots)_2 - 1 = 2^{x} - 1$。
:::

### 实现

```cpp
# include <iostream>
# include <cmath>
using namespace std;
int main(){
	int T; cin >> T;
	while (T--){
		long long n,ans = 0,lst = ceil(log2(1e18)); cin >> n;
		while (n){
			while (lst >= 0 && n < (1ll << lst) - 1ll) lst--;
			n -= (1ll << lst) - 1ll,ans++;
		}cout << --ans << endl;
	}return 0;
}
```

---


# 还是 N 皇后

## 题目描述

正如题目所说，这题是著名的 $N$ 皇后问题。


## 说明/提示

$0< n\le14$


## 样例 #1

### 输入

```
4
**.*
****
****
****```

### 输出

```
1```

# 题解

## 作者：karma (赞：76)

此题是一个练习位运算的好题


由于楼下题解解释过少,我来进行补充.

其实此题的正解就是位运算,用其他方法会TLE(打表除外)


### 分析:

- 逐行放置皇后,首先排除每行有多个皇后互相排斥的情况

- 用二进制表示状态.1表示该点不能放(与其他位置的皇后排斥或初始状态就不能放).0表示该点可以放皇后

- 用sta[]来存储初始状态,将'.'位 置为1

- dfs保存四个参数:当前行的状态,从左上到右下对角线的状态,从右上到左下对角线的状态,当前为第几行

- 获取当前哪一位可以放置皇后:将四者取并集(即将四者进行或运算).得到的状态中为0的就可以放置皇后.

- 为了快速得到可以放置皇后的位置,对上一步得到的状态进行取反.转换成快速得到1的位置.

- 用树状数组中的lowbit()就可以得到从右向左的第一个1

- 将状态中的1减掉,继续找下一个1

- 更新"将是下一行的状态",由于对角线是斜着影响的,所以左上到右下对角线的状态需要左移一位,右上到左下对角线的状态需要右移一位.

- 知道当前行的状态全为1时,即每一行都有一个皇后时,ans++;

```cpp
#include<cstdio>
#define xianzhi ~(now|ld|rd|sta[d])
#define lowbit(pos)  pos&-pos
#define youzuo (ld+p)<<1
#define zuoyou (rd+p)>>1
int n,all,sta[25],ans;
void dfs(int now,int ld,int rd,int d){//now这个状态限制的是"列之间的冲突" 
    if(now==all){ans++;return ;}
    int pos=all&xianzhi,p;
    while(pos){
        p=lowbit(pos);
        pos-=p;
        dfs(now+p,youzuo,zuoyou,d+1);
    }
}
int main(){
    scanf("%d",&n);
    all=(1<<n)-1;//最终状态(即全部放完的状态) 
    char c[20]; 
    for(int i=1;i<=n;++i){
        scanf("%s",c+1);
        getchar();//消除行末回车 
        for(int j=1;j<=n;++j){
            if(c[j]=='.')sta[i]|=(1<<(n-j));//将sta[i]的"第j位"置为1 
        }
    }
    dfs(0,0,0,1);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：RagnaLP (赞：34)

//更好的阅读体验请[转](https://www.cnblogs.com/lazy-people/p/9308472.html)

这个题的原理和8皇后的原理是一模一样的，就是必须要用n个皇后把每一个行填满，同时**满足每一列，每一行，每一条对角线只有一个棋子**。但如果按照原来的方法暴打的话只有60分（**优化亲测无效**）

  //这里插播一下，优化大佬 @MicroMaker 和 @Garrison 分别拿下了70和80分   ~~果然是我太菜了~~


所以这个时候，我们可以用二进制来表示一波状态（可以类比状态压缩的二进制）。从上面的条件来看，我们需要表示的量有：**行**，**列**，**两条对角线**（向左的和向右的），我们用一个状态的某一位的**1**表示这个状态的这个位置**不能放**（已经有棋子）

- ### 对于每一行：
我们可以用DFS的深度来减少需要表示状态。（也就是说不用管，见代码）

- ### 对于每一列：
因为在DFS的时候，每一行都必然会放一个棋子，此时需要把这一位的列状态置为1，而且由此可知，**当最后放满的时候，表示列的那个状态的必然全是1**（**终止条件**）

- ### 对于向左上的对角线:
从左上到右下，所以当前这一行影响的应该是下一行的右下一个（↘），然后这里需要注意的是这一行的最后一个的这种对角线是对下一行是没有影响的。举个例子（单就对角线来说）:
```
	这一行: 0 1 1 0 1（1表示有棋子）
	下一行: 0 0 1 1 0
```
这个时候可以看出来，这个状态相当于是>>=1。（因为最后一个没有影响所以它被消掉也没有影响）

- ### 对于右上的对角线：
从右上到左下，影响下一行的左一个（↙）其他都和向左上的一样，只是这一行的第一个对下一行没有影响。举个例子：
```
	这一行: 1 1 0 0 1（1表示有棋子）
	下一行: 1 0 0 1 0
```
这个时候可以看出来，这个状态相当于是<<=1。（第一个会被移到前面,超出查找范围，会被接下来的运算消掉）

- ### 由此可见
对于这一行来说，可以取的点应该是上一行的所有状态**求并集（位或）**之后二进制状态位为0的数。举个例子：
```
	上一行传下来的状态：     列：   4   00100
    				   右对角线：  18   10010
                       左对角线：   6   00110
	状态的并集:(这一行可以填充)：  22   10110
    那么所以可以放棋子的位置应该是这一行的第2列和第5列。
```
这个时候，为了方便快速找到并集当中的可行解，联想树状数组的lowbit(),发现只要用1来表示可以放的位置即可，具体方法：并集取反后与**全部位置(1~n位）都为1的一个值（all）作与运算**（与all作与运算是为了把右对角线多向右移出去的除掉）举个例子:
```
	~并集：  0101001（右对角线多出两位）
      all：  0011111 
     &all：  0001001
```
这样只需要每一次取lowbit()之后把状态更新，并将并集减去lowbit()（将这一位置0表示已经取过）后继续DFS。

代码：（如果还没有理解可以用二进制检验函数单步走一下）
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,map[20]={0},all=0,cc=0;//map[i]存放本来就不能放的点，cc表示可行借个数

//二进制检验函数 
int c[20]={0};
void print_in_2(int x){
	for(int i=0;i<20;i++)c[i]=0;
	while(x){
		c[0]++;
		c[c[0]]=x&1;
		x>>=1;
	}
	for(int i=n;i>0;i--){
		printf("%d",c[i]);
	}
	cout<<endl;
}

void Init(){
	scanf("%d",&n);
	char k[20];//给出的地图
	for(int i=0;i<n;i++){
		scanf("%s",k);
		for(int j=0;j<n;j++){
			if(k[j]=='.')
				map[i]|=(1<<j);//这里是将所给地图左右对称了，易证对称后与原图方案数相同 
		}
	}
	all=(1<<n)-1;
	
	/*for(int i=0;i<n;i++){
		print_in_2(map[i]);
	}*/
}
int low_bit(int x){//返回第一个1
	return x&-x;
}
void DFS(int deep,int line,int l_diag,int r_diag){//深度（行数）和上一行的状态：列、左对角线、右对角线
	if(line==all){//如果每一列都被填充了，找到答案
		cc++;
		return;
	}
	//注意：l_d.r_d,line是以1表示已经取过的位置，不是表示还可以放棋子，所以要与all取反 
	int may=all&~(map[deep]|line|l_diag|r_diag);//取可行解，由于map中的1只能影响当前行，所以要在取一次或
	//print_in_2(may);
	int v;
	while(may){
		v=low_bit(may);
		may-=v;//将取出的那一位置0
		//print_in_2(may);
		DFS(deep+1,line+v,(l_diag+v)>>1,(r_diag+v)<<1);//因为取出的那一位在任意状态中必为0，所以可以直接加上v来把那一位置1；
	} 
}
void solve(){
	DFS(0,0,0,0);//我是从0开始存图所以以0为深度开始，其他位置在一开始都可取所以都为0
	printf("%d",cc);
}
int main(){
	Init();
	solve();
    return 0;
}
```

---

## 作者：Ofnoname (赞：23)

题解只有5篇，就让我再来贡献一篇（~~其实我想刷积分~~）。

# 1.引入

首先看到此题，做过[P1219 八皇后](https://www.luogu.org/problemnew/show/P1219)的同学都应该快速打出暴力代码：
```
#include <bits/stdc++.h>
#define MAX 30
using namespace std;

int N,ans;
char f[MAX][MAX];//f为输入的数组 
bool use1[MAX],use2[MAX],use3[MAX];
//use1表示横向使用情况,use2表示左上-右下使用情况,use3表示右上-左下使用情况。 

void DFS(int y)
//按每一个数列搜索 
{
    if (y>N) {ans++; return;}
    for (register int x=1; x<=N; x++)
    {
        if (f[x][y]=='.'||use1[x]||use2[y-x+N]||use3[y+x])
            continue;
        use1[x]=use2[y-x+N]=use3[y+x]=1;
        DFS(y+1);
        use1[x]=use2[y-x+N]=use3[y+x]=0;
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cin>>N;
    for (register int i=1; i<=N; i++)
        for (register int j=1; j<=N; j++)
            cin>>f[i][j];
    DFS(1);
    printf("%d",ans);
    return 0;
}
```
这当然不能AC，不然就不是位运算基础题了。

----

# 2.位压缩的探索

## 但是，这里的位压缩并不是指把use1,use2等压成一个整数或者bitset之类的，你会发现那样对程序效率没有任何优化。

## 我们需要的是把每一列表示能否放置的01串压缩成为整数，并放在DFS参数里向下传递。

人工模拟样例：DFS(横排使用情况use1，左上-右下使用情况use2，右上-左下使用情况use3，层数d);(数用二进制表示)
1. 执行DFS(0,0,0,1)

	我们发现当前列为(0000)，就一次循环遍历所有能放的地方，这里以第二位为例。
    那么放在这里对下一列的三个影响就用参数传递下去。
    ### 放第二位后，第二列的第二位自然不可能再放，use1+=(1<<2)//把第二位标记为1
    ### 第二列第三位受到斜角影响，也不能放，use2=(use2+(1<<2))<<1//左移即上抬一位，越界部分相当于棋盘边界，正符合要求。
    ### 同上 use3=(use3+(1<<2))>>1
2. 执行DFS(0010,0100,0001,2)

	我们要知道第二列还有哪里能够放兵，就应该把use都并起来：``int p=use1|use2|use3;``
    p=0111，只有第四位能放，标记后继续下一步。
3. 执行DFS(1010,1000,0100,3)

	此时p=1110,只有第四位可以放置，继续。
    
4. 执行DFS(1011,0010,0010,4)

	此时p=1011,只有第二位可以放置，继续。
    
5. 执行DFS(1111,1100,0011,5)

	此时use1=p=1111，没有位置可以放置，这说明**已经到达了递归终点**！！！
    
    将ans++,并返回上一层搜索其他情况。

### (I)如果你问，当use1全为1时还不是最后一层怎么办？
## 不可能！！每次只放一颗棋，use1只有一位变为1，只有放满后use1才会满。
### (II)递归边界一定是use1全满而不是p全满，只有use1能确定棋子已经摆完。
----
# 3.再优化
将以上的框架掌握之后，还有两个问题需要解决：

### 1. 有些位置一开始就不能放置，怎么处理？
我的解决办法是针对每一列，在输入时就用一个整数f保存能或者不能放的01串。在每一次递归取p时，令`p=use1|use2|use3|f[d];`此时输入的限制也并入p中。
### 2. 如何枚举一个二进制数从低到高的每一个0？
一种高效的办法就是先取反,然后枚举每一个1，学过树状数组的同学都知道，可以用lowbit(x)=x&(-x)从低到高枚举每一个1。可以令`p=((1<<N)-1)&~(use1|use2|use3|f[d])`

其中((1<<N)-1)&可以使超过N的高位变为0，避免越界。如N=5时00010011和00010101合并取反后等于11101000，但是我们不需要高位的3个0，于是就把结果&上(1<<N)-1)(即00011111)，这样结果就变为00001000，即只有第四位能够放置

----

# 4.打代码
```
#include<bits/stdc++.h>
#define lowbit(x) ((x)&(-x))
#define MAX 30
using namespace std;

int N,ans,f[MAX];

void DFS(int use1,int use2,int use3,int ord)
{
    if (use1==(1<<N)-1) {ans++; return;}//回溯 
    int p=((1<<N)-1)&(~(use1|use2|use3|f[ord]));
    while (p)
    {
        DFS(use1+lowbit(p),(use2+lowbit(p))<<1,(use3+lowbit(p))>>1,ord+1);
        p-=lowbit(p);//每次去掉最低位的一 
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cin>>N;
    for (register int i=1; i<=N; i++)
    {
        string s=""; cin>>s;
        for (register int p=0; p<N; p++)
            if (s[p]=='.') f[i]|=(1<<(N-p-1));
    	//f[i]就用来保存每一列有1的情况。 
    }
    DFS(0,0,0,1);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：WanderingTrader (赞：14)

这题是搜索题，但是爆搜肯定炸，所以要剪枝。  
笔者费尽心思剪枝，最后还是70分，那么只好拿出优化大杀器——位运算。  
### 位运算
鉴于并不是所有人都会位运算，笔者这里简单介绍一下。  
1. 按位或(`|`)  
比如`3|5`:  
先把3,5拉成二进制：  
011  
101  
然后对每一位做或运算为：  
111  
转成十进制即为7。  
所以`3|5=7`  
2. 按位与(`&`)  
还是以3,5为例：  
拉成二进制  
011  
101  
对每一位做与运算即：
001  
转成十进制是1  
所以`3&5=1`
3. 按位异或(`^`)
把3,5拉成二进制：  
011  
101  
比较每一位，如果不相同返回1，相同返回0，那么得到：  
110
转成十进制是6
所以`3^5=6`
4. 左移运算符(`<<`)和右移运算符(`>>`)  
就是把二进制的值往左一位和往右一位。  
由于这是“二”进制，所以：`x<<1=x*2;x>>1=x/2`。  
比如`1<<n` $=2^n$。
5. 按位取反(`~`)  
这个运算符是单元运算符。  
其实就是把二进制的每一位取反，这在待会运用位运算优化时尤其有用。  
至于取反后的十进制值，可以用一个公式表示(无论正负)：`~x = -x-1` 。
为什么呢？这就涉及到二进制的表示法了，下面将重点介绍。  

二进制的表示方法有三种：原码，反码和补码。
1. 原码：即数字本身的二进制值。整数直接展开，负数把符号位设为1，其它不变。  
以带符号4位二进制为例：    
$2\to(0010)_2$  
$-2=-(2)\to(1010)_2$  
这样会有一个问题：  
$2+(-2)=(0010)_2+(1010)_2=(1100)_2=-4$，显然不对。  
所以就有了反码。  
2. 反码：  
**正数的原码和反码一样**  
负数的反码则是将原码按位取反，符号位不变。  
比如在四位带符号二进制数中，$-0=(1111)_2,-1=(1110)_2,-2=(1101_2)$  
这样，$-2+2=(0010)_2+(1101)_2=(1111)_2=-0$，貌似没有问题了。  
但此时拿两个不同的负数相加又会出问题了。  
$(-1)+(-2)=(1110)_2+(1101)_2=(1011)_2=-4$  
那么就有了补码。   
3. 补码：  
**计算机里用的都是补码**   
**正数的原码、反码和补码都一样**   
大多数的书上就一句话：**负数的补码等于反码+1**，这也确实精辟的解释了补码。    
或者说，**负数的补码等于他的原码自低位向高位，尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。**  
可能不太好懂，其实看两个实例就行了。    
$6+(-2)=(0110)_2+(1110)_2=(0100)_2=4$  
$(-1)+1=(1111)_2+(0001)_2=(0000)_2=0$  
看上去很不错哦。  

回到`~`运算符，如果x为正数，那么取反后其实就是它的相反数的反码，但计算机中用的是补码，在反码的基础上多了1，所以最后再减掉1，即为最终的十进制值。  
如果x为负数，设`~x=k`，则`~k=x`，所以`x=-k-1`，移项得`k=-x-1`，这样解释似乎更容易理解呢。  
### 普通N皇后
普通的搜索代码大致是这样的：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 15
int n,ans;
long long s[3][2 * N + 1];
int cb[N];
void queen(int row){
	if(row > n){
		ans ++;
		return;
	}
	for(int i = 1;i < cb[row - 1] - 1;i ++)
	{
		if( s[0][i] || s[1][i + row] || s[2][i - row + n] )continue;
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 1;
		cb[row] = i;
		queen(row + 1);
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 0;
	}
	for(int i = cb[row - 1] + 2;i <= n;i ++){
		if(s[0][i] || s[1][i + row] || s[2][i - row + n]  )continue;
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 1;
		cb[row] = i;
		queen(row + 1);
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 0;
	}
}
int main()
{	
	scanf("%d",&n);
	cb[0] = n + 2;
	queen(1);
	printf("%d\n",ans);
	return 0;
}
```
这份代码的复杂度是铁的$O(n!)$，在 $n\le14$ 的时候还是会超时。  

加了位运算的代码是这样的：
```cpp
#include <bits/stdc++.h>
using namespace std;
int upp;//位运算优化 
int ans;//答案 
inline int read()
{//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
void queen(int row,int ld,int rd)
{
	/*
		row代表当前行由于列冲突的第几列不能选(1不能0能)
		ld代表当前行由于左对角线冲突不能选(同上)
		rd代表当前行由于右对角线冲突不能选(同上)
	*/
	int pos,p;
	if(row != upp)//如果 row 全是1则达到要求 
	{
		pos = upp & (~(row|ld|rd)); //取出当前第一个可放置列(即第一个0)
		while(pos)
		{
			p=pos&(~pos+1);
			pos -= p;
			queen(row|p,(ld|p)<<1,(rd|p)>>1);
		}
	}
	else ++ans; 
}
int main()
{
	int n=read();
	upp = (1<<n) -1;//初始化(每一位都是1) 
	queen(0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
可能会一脸蒙圈，笔者第一次看到这份代码也是这种感觉。  
那么这里稍微解释一下。

首先这个$upp$，它放的是最终结果(0~n-1位每一位都是1)，它的十进制值就是$2^n-1$，用位运算直接搞定。  
$row,ld,rd$存放的都是二进制的状态，$row$是列冲突，$ld$是左对角线，$rd$是右对角线。0表示这个位置上没有，还可以放；1表示这个位置上已经放过了，不用再放了。  

如果当前的状态($row,ld,rd$任取一个皆可)和$upp$完全相同，说明达到要求，直接$ans+1$然后退出，反之继续下面的操作。  

对$row,ld,rd$进行按位或运算，得到新的二进制值，它表示的是最终能否放置的状态。对这个数进行按位取反给$pos$，现在1表示可以放，0表示不可以。  
接下来取出$pos$最末端的1，这里稍微讲解一下方法。  

假设已找到这个1，在第$x$位上，那么把原数-1后，$x$左边不动，$x$这里变成0，$x$右边全是1。  
然后对这个数按位取反，现在$x$左边1变0,0变1，$x$这里是1，$x$右边全是0。  
用这个数按位与上原数，$x$前面都不一样，自然返回0，$x$本身是1，$x$右边本来就全是0，与一遍还是0。  
现在取到的数的十进制值就是$2^x$。  
所以取的方法就是`pos&(~(pos-1))`

我们用`p=pos&(~(pos-1))`来找到这个值，然后把pos减去p（以免重复），递归queen函数继续查找。  
这里传入的$row$直接在原来基础上按位或$p$即可（其实用异或也可以），$ld$则先按位或$p$，然后左移一位（想想左对角线的形状），$rd$先按位或$p$，然后右移一位。  
只要$pos\neq0$，那么就继续做以上操作。  
普通N皇后就这样解决了。  
位运算写成的代码，效率非常高，但是可读性非常差，没有一点想象力是不行的。  
### 还是N皇后
这题不过是多一个放置限制罢了，先把普通N皇后的模板复制一遍，在上面做些修改即可。  
把输入输出写上：
```cpp
#include <bits/stdc++.h>
using namespace std;
int upp;//位运算优化 
int ans;//答案 
bool c[20][20];
inline int read()
{//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
void queen(int row,int ld,int rd)
{
	/*
		row代表当前行由于列冲突的第几列不能选(1不能0能)
		ld代表当前行由于左对角线冲突不能选(同上)
		rd代表当前行由于右对角线冲突不能选(同上)
	*/
	int pos,p;
	if(row != upp)//如果 row 全是1则达到要求 
	{
		pos = upp & (~(row|ld|rd)); //取出当前第一个可放置列(即第一个0)
		while(pos)
		{
			p=pos&(~pos+1);
			pos -= p;
			queen(row|p,(ld|p)<<1,(rd|p)>>1);
		}
	}
	else ++ans; 
}
int main()
{
	int n=read();
	char a;
	for(int i = 0;i < n;++ i)
		for(int j = 0;j < n;++ j)
		{
			cin >> a;
			if(a == '.') c[i][j] = 1;
		}
	upp = (1<<n) -1;//初始化(每一位都是1) 
	queen(0,0,0);
	printf("%d\n%d",ans);
	return 0;
}
```
首先queen里面要多传一个参数$cnt$，表示当前是哪一行。  
然后我们在递归前要判断这个位置能不能取，即$c[cnt][\log_2p]$是否是1。  
为了避免多次使用log函数，我们对其进行初始化：
```cpp
int lg[1<<15];//主函数之前加上这个数组
for(int i = 0;i <= n;++ i)
	lg[1<<i] = i;//输入n了以后加上这个循环
```
代码很好懂，这里就不解释了。  
那么再递归前加上这一句即可：
```cpp
if(c[cnt][lg[p]]) continue;
```
全部代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int upp;//位运算优化 
int ans;//答案 
bool c[20][20];
int lg[1<<15];
inline int read()
{//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
void queen(int cnt,int row,int ld,int rd)
{
	/*
		row代表当前行由于列冲突的第几列不能选(1不能0能)
		ld代表当前行由于左对角线冲突不能选(同上)
		rd代表当前行由于右对角线冲突不能选(同上)
	*/
	int pos,p;
	if(row != upp)//如果 row 全是1则达到要求 
	{
		pos = upp & (~(row|ld|rd)); //取出当前第一个可放置列(即第一个0)
		while(pos)
		{
			p=pos&(~pos+1);
			pos -= p;
			if(c[cnt][lg[p]]) continue;
			queen(cnt+1,row|p,(ld|p)<<1,(rd|p)>>1);
		}
	}
	else ++ans; 
}
int main()
{
	int n=read();
	char a;
	for(int i = 0;i <= n;++ i)
		lg[1<<i] = i;
	for(int i = 0;i < n;++ i)
		for(int j = 0;j < n;++ j)
		{
			cin >> a;
			if(a == '.') c[i][j] = 1;
		}
	upp = (1<<n) -1;//初始化(每一位都是1) 
	queen(0,0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
实测结果：总用时$1.45s$，较大的数据点平均是$300$~$700s$，相比爆搜还是有很大提升的。  

$\mathrm{The\ End.}$

---

## 作者：Fheiwn (赞：11)

安利一下blog：<http://blog.csdn.net/kai\_wei\_zhang/article/details/8033194>  讲得很好


ps:你必须会普通的八皇后。

位运算版的就是将 当前状态、左对角线、右对角线 用二进制表示。每次放的时候用位运算找到可以放的位置，进入下一层。






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<set>
#include<bitset>
#include<sstream>
#include<cstdlib>
#define QAQ int
#define TAT long long
#define ORZ double
#define OwO bool
#define SHO short
#define F(i,j,n) for(QAQ i=j;i<=n;++i)
#define E(i,j,n) for(QAQ i=j;i>=n;--i)
#define MES(i,j) memset(i,j,sizeof(i))
#define MEC(i,j) memcpy(i,j,sizeof(j))
using namespace std;
QAQ n,a[20];//数据范围......看着开
QAQ ed,ans;
void dfs(QAQ down,QAQ ld,QAQ rd,QAQ h){
    if(down==ed) ans++;//若当前状态与结尾状态相等 答案加一
    else {
        QAQ pos=ed&(~(down|ld|rd))&(~a[h]);//pos:可以放的
        while(pos){
            QAQ p=pos&-pos;//将要放的
            pos-=p;//放上去后，剩下的状态
            dfs(down+p,ld+p<<1,rd+p>>1,h+1);//下一层
        }
    }
}
QAQ main(){
    scanf("%d",&n);
    ed=(1<<n)-1;//ed: 结尾状态
    F(i,1,n) F(j,1,n) {
        a[i]<<=1;
        char x;cin>>x;
        if(x=='.') a[i]+=1;//1:表示不可放
    }
    dfs(0,0,0,1);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：George1123 (赞：7)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1562 【还是N皇后】传送门](https://www.luogu.org/problem/P1562)

### 此题算法:$dfs$+位运算

这题不是深搜加剪枝，不看标签真的想不到要用位运算

大致思路:

>1.用一个二进制数表示一行的摆放情况，0表示可以放皇后，1表示不可以放皇后，别忘了皇后上下左右和两条斜对角线都吃得了。

>2.用$sp[i]$表示第i行的摆放情况，.表示不可以放皇后，但是因为棋盘是从左向右的，而二进制数是从右向左的，所以$sp[i]|=(1<<(n-j))$表示将第$i$行从左到右第$j$个格子置为不可放皇后。

```cpp
for(int i=1;i<=n;i++){
	cin>>s;
	for(int j=1;j<=n;j++){
		if(s[j-1]=='.')
			sp[i]|=(1<<(n-j));
	}
}
```
>3.$dfs$四个参数中$lie$是个二进制数，表示由于皇后之间上下的限制，有些地方不能放皇后。$leftmove$也是个二进制数，表示皇后右上左下的限制，每次通过$<<$运算覆盖下一行。$rightmove$与$leftmove$同理。$line$表示处理到第几行。

>4.$dfs$中如果上下限制满了（等价于line>n）就令$ans++$并退出。~是位非运算，|是位或运算，将两个二进制数中的$1$合并，要&(与)满状态是为了保持当前覆盖长度仅$n$，再枚举每个未覆盖的盘位，并递归深搜。

## 以下是代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,sp[15],full,ans;
string s;
int lowbit(int x){
	return x&(-x);
} void dfs(int lie,int leftmove,
int rightmove,int line){
	if(lie==full){
		ans++;
		return;
	} int pos=(~(lie|leftmove|
	rightmove|sp[line]))&full;
	while(pos){
		int Low=lowbit(pos);
		pos-=Low;
		dfs(lie+Low,(leftmove+Low)<<1,
		(rightmove+Low)>>1,line+1);
	}
} int main(){
	scanf("%d",&n);
	full=(1<<n)-1;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=1;j<=n;j++){
			if(s[j-1]=='.')
				sp[i]|=(1<<(n-j));
		}
	} dfs(0,0,0,1);
	printf("%d\n",ans);
	return 0;
}
```
这也是我第一次精学位运算，

谢谢大家! !


---

## 作者：封禁用户 (赞：5)

```cpp
//传说中的位运算。。。
//n皇后原题加上特殊判定即可
//把所有障碍用二进制的1来表示，其他的用二进制0来表示
//在判断该行能放棋子时再加上&~rewq[shen];即可，意为该行的空地
//详细看代码，rewq[i]意为第i行的空地，其余大部分为汉语拼音
#include<iostream>
using namespace std;
int hang[50],lie[50],da,zong,n,i,j;
char qwer;
long long rewq[50];
void dfs(int fen,int zuo,int you,int shen){
    if(fen-zong){
        int xia=zong&~(fen|zuo|you)&~rewq[shen];
        for(;xia;){
            int q=xia&-xia;
            xia-=q;
            dfs(fen+q,(zuo+q)<<1,(you+q)>>1,shen+1);
        }
    }
    else{
        da++;
    }
}
int main(){
    cin>>n;
    zong=(1<<n)-1;
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            cin>>qwer;
            rewq[i]<<=1;
            if(!(qwer-'.')){
                rewq[i]+=1;
            }
        }
    }
    dfs(0,0,0,0);
    cout<<da;
    return 0;
}
```

---

## 作者：「　」 (赞：4)

### 小补充
#### 这次要一反常态先上代码：
```
#include<cstdio>
#include<iostream>
using namespace std;
int n;
char a;
int sta[20];
int goal;
int ans=0;
void dfs(int l,int yz,int zy,int d)
{
	if(l==goal)
	{
		++ans;
		return ;
	}
	int now=goal&(~(l|yz|zy|sta[d])),tmp;
	while(now>0)
	{
		tmp=now&(-now);
		now-=tmp;
		dfs(l+tmp,(yz+tmp)<<1,(zy+tmp)>>1,d+1);
	}
}
int main()
{
	scanf("%d",&n);
	goal=(1<<n)-1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			cin>>a;
			if(a=='.')
			{
				sta[i]|=(1<<(n-j));
			}
		}
	}
	dfs(0,0,0,1);
	printf("%d\n",ans);
	return 0;
}
```
### 补充一下前面的题解，本蒟蒻看到代码后，有几个疑问：  
#### Q1：
```
int now=goal&(~(l|yz|zy|sta[d]))
```
这里为什么需要与一下目标值呢？  
#### A1：
因为按位取反后值为负，需要与一下变成正数，并且后面代码中的左移会使范围变大，但实际上这个可行的位置已经超出了图的边界。
![](https://cdn.luogu.com.cn/upload/pic/45448.png)
顺带提一下按位取反是因为可以使用lowbit加快运行。
#### Q2：
$l+tmp$  
为什么列的限定需要加上行的取法呢？
#### A2：
其实这里是**列的轨迹对行的限制**。
![](https://cdn.luogu.com.cn/upload/pic/45445.png)
如图，这里上一行的1，就以列的轨迹对下面一行做出的影响。
#### Q3：
$(yz+tmp)<<1,(zy+tmp)>>1$  
为什么对角线的限定需要加上行的取法，并且需要左移（或右移）呢？
#### A3：
其实跟Q2一样，这里是**对角线的轨迹对行的限制**。（**因为这里是以行为单位进行搜索的**）
![](https://cdn.luogu.com.cn/upload/pic/45446.png)
如图，这里上一行的1，就以对角线的轨迹对下面一行做出影响，因为对角线是斜的，所以需要左移（或右移）。

---

## 作者：Panthera_AFO (赞：4)

    #include <iostream>  
    #include<stdio.h>  
    using namespace std;  
    int n,ans,End,map[20];  
    void dfs(int row,int ld,int rd,int d) { //row列,ld右斜 ，d行  
        if(d>n) { //if(row==End)  
            ans++;return;  
        }  
        int pos=End&(~(row|ld|rd|map[d])),p;  
        while(pos) {  
            p=pos&(-pos);//找到第一个非零位置。  
            pos-=p;  
      
            dfs(row+p,(ld+p)<<1,(rd+p)>>1,d+1);//ld+p右移，左斜线不能再用， rd+p右斜，d+1，下一行；  
        }  
    }  
    int main() {  
        char s[20];  
        int i,j,k;  
        scanf("%d\n",&n);  
        End=(1<<n)-1;  
        for(i=1; i<=n; i++) {  
            gets(s);  
            for(j=1; j<=n; j++)  
                map[i]=(s[j-1]=='.')+(map[i]<<1);  
        }  
        dfs(0,0,0,1);  
        printf("%d",ans);  
        return 0;  
    }  

---

## 作者：raincity (赞：2)

这道题的题面：[P1562 还是N皇后](https://www.luogu.com.cn/problem/P1562)

## 分析
显然这道题可以直接暴力搜索。不会的自行搜索DFS。但是只能得60分。先上代码：
```cpp
#include <iostream>

using namespace std;

const int MAX = 50;
char mp[MAX][MAX];
int tot, n;
char a[MAX], b[MAX], c[MAX];

inline void dfs(int k){
	if(k > n){
		tot++;
		return;
	}
	for (register int i = 1; i <= n; i++)
		if(mp[k][i] == '*' && a[i] == 0 && b[i - k + n] == 0 && c[i + k] == 0){
			a[i] = b[i - k + n] = c[i + k] = 1;
			dfs(k + 1);
			a[i] = b[i - k + n] = c[i + k] = 0;
		}
}

int main(){
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			cin >> mp[i][j];
	dfs(1);
	cout << tot << endl;
	return 0;
}
```
但是TLE四个点。为什么呢？看到dfs函数中的for循环一行。其中有很多方案是不可能的，但是这样写的话必须一个一个判断是否可以落子。导致超时。如何改进呢？

这里我们可以用位运算进行优化。我们用整形中的一个bit表示当前位置是否可以落子。对于左右斜线，竖线各保存一个副本。求并集（C++中的&运算）可以得到哪里可以落子。再用lowbit运算得到第一个可以落子的位置，这样只需要判断是不是*字符就行了。

具体而言，我们用函数 $dfs(k, leftdiagonal,rightdiagonal, verticalline)$
表示搜索到第$k$行，左斜线状态为$leftdiagonal$并且将在棋盘，右斜线状态为$rightdiagonal$，竖线状态为$verticalline$时的搜索。

那么搜索到下一行时$leftdiagonal$需要左移并将最右边落子设为可行，$rightdiogonal$需要右移并将最左边落子设为可行，$verticalline$不需要变化。再次加上当前落子的影响即可。

## 解决
上AC代码：
```cpp
#include <iostream>

using namespace std;

const int N = 20;
int n, tot, lg[1 << N];
char mp[N][N];

int lowbit(int x){
	return x & (-x);
}

void dfs(int k, int leftdiagonal, int rightdiagonal, int verticalline){
	if(k > n){
		tot++;
		return;
	}
	int canset = leftdiagonal & rightdiagonal & verticalline;
	while(canset){
		int place = lowbit(canset);
		canset -= place;
		if(mp[k][lg[place] + 1] == '.') continue;
		int _leftdiagonal = ((leftdiagonal - place) << 1) + 1;
		int _rightdiagonal = ((rightdiagonal - place) >> 1) + (1 << (n - 1));
		int _verticalline = verticalline - place;
		dfs(k + 1, _leftdiagonal, _rightdiagonal, _verticalline);
	}
}

int main(){
	cin >> n;	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			cin >> mp[i][j];
	for (int i = 0; i <= n; i++)
		lg[1 << i] = i;
	int initialvalue = (1 << n) - 1;
	dfs(1, initialvalue, initialvalue, initialvalue);
	cout << tot << endl;
	return 0;
} 
```
### THE END 

---


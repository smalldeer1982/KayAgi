# [传智杯 #3 初赛] 游戏（征集数据）

## 题目描述

清蒸鱼是一个从未被击败的炽蓝仙野游戏者。有一天他遇到了这么一个游戏：

给定一个长度为 $n$ 的数组 $a$。同时定义 $count(x)$ 为 $x$ 在二进制下的 $1$ 的个数。

现在清蒸鱼每次可以进行如下两种操作：

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j)=1$，将它们中的任意一个从数组中消去，代价为 $C_1$。

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j) > 1$，将它们中的任意一个从数组中消去，代价为 $C_2$。

现在你想知道，最少付出多少的代价，能让这个数组被消到只剩一个数。

## 说明/提示

对于 $20\%$ 的数据，满足 $n = 10$；  
对于另外 $20\%$ 的数据，满足 $a$ 中的元素为一个 $[1, n]$ 的排列；  
对于 $100\%$ 的数据，满足 $1 \leq n \leq {10}^4$，$1\le C_1, C_2, a \le {10}^9$，$a$ 中的元素互不相同。

## 样例 #1

### 输入

```
4
5 10
1 2 3 4```

### 输出

```
20```

# 题解

## 作者：GavinCayne (赞：21)

# P8826 游戏 题解 
[传送门](https://www.luogu.com.cn/problem/P8826)

这是**当年传智杯初赛最难的题**，说是**黄题中的佼佼者**也不为过。甚至过了三年提交 $1400$ 通过人数竟不满 $100$！而且**无一篇题解**（~~被我捡漏~~）！一开始本蒟蒻也没有思路，后来看了讨论区别的大佬的思路才豁然开朗（~~此题数据有问题~~）。
# 题目大意
给定 $n$ 个数，两种操作：每次选 $i$ 和 $j$，若 $a[i]\operatorname{xor}a[j]$ 的值二进制只有 $1$ 位为 $1$，则代价 $ans$ 需要加上 $C_1$，如果大于 $1$ 位则代价 $ans$ 加上 $C_2$。做完操作删去其中一个数，问剩最后一个数时 $ans$ 最小是多少。
## 整理一波思路
1. 若 $C_1=C_2$ **无论异或情况如何代价都不变**。直接用操作次数 $n-1$ 乘上一次代价 $C_1$ 出结果。
1. 一位一位判断异或结果实在麻烦，需要转成二进制再倒着（短除法性质）判断每一位上的值是不是 $1$，**要循环两次**。有什么方法一下就能知道异或的值是不是 $1$ 位是 $1$ 呢？**用** $\operatorname{lowbit}$ **函数**！$\operatorname{lowbit}(n)$ 表示 $n$ 最低位为 $1$ 的数和它后面的数构成的数值。例：$\operatorname{lowbit}(6)$ 表示 $6(110)$ 最低位为 $1$ 的数及它后面的 $0$ 构成的数 $2(10)$。那么当 $\operatorname{lowbit}(n)=n$ 时，$n$ 一定是 $2$ 的整数次幂（除最高位全是 $0$），**它的二进制为** $1$ **的位只可能是最高位**！
1. 如何写 $\operatorname{lowbit}$？**假设** $n$ **最低位的** $1$ **在第** $k$ **位上**，那么 $n$ 取反后 $k$ 以后所有的位数全是 $1$，$k$ 位为 $0$。$n$ 是正数，取反后变成负数，补码要加 $1$，刚好 $k$ 位又回到 $1$。那么 $n$ 与取反后的 $-n$ 做与运算（**常识：与运算是将两个数的补码运算**）由于 $k$ 位前面的数全由于取反导致与的值为 $0$，所以结果就是 $k$ 位为 $1$ 其它全是 $0$。即 $\operatorname{lowbit}(n)$ 可写作 $n\operatorname{and}(-n)$。
1. 处理好判断异或值了，接下来就要**考虑正式操作**。统计两种操作中**代价较小的次数**为 $ans$，则代价大的操作次数为 $n-1-ans$。用两者分别乘上每次的代价 $\min(C_1,C_2)$ 和 $\max(C_1,C_2)$ 就能得出正确结果！
1. **考虑并查集**（是的，你没听错，这题还与并查集挂钩）。不难理解，操作不会改变数本身的大小，只需要删掉即可。那么把操作过的数并在一个集合里，每操作一次判断操作的两个数在不在同一集合，不在则并在一起，同时操作次数加一。
### 喜闻乐见的代码时间
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=1e4+5;
int n,c1,c2,a[M],ans=0,f[M];
int findfather(int x)//并查集标准模板：找爹 
{
	if(f[x]!=x)f[x]=findfather(f[x]);
	return f[x];
}
int lowbit(int x)//找最低的值为1的位 
{
	return x&(-x);
}
signed main()
{
	cin>>n>>c1>>c2;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];f[i]=i;
	}
	sort(a+1,a+n+1);//可不排 
	if(c1==c2)//判断，如果相等则怎么操作代价都一样 
	{
		cout<<(n-1)*c1;
		return 0;
	}	
	for(int i=1;i<n;i++) 
	{
		for(int j=i+1;j<=n;j++)
		{
			int pd=0,xornum=a[i]^a[j];
			if((xornum||n<=10)&&lowbit(xornum)==xornum)pd=1;//xornum表示异或值不为0，也就是不等 
			if((c1<c2&&pd)||(c1>c2&&!pd))//C1划算就要异或值只有一位为1，也就是pd成立 
			{
				int f1=findfather(i),f2=findfather(j);//并查集 
				if(f1!=f2)
				{
					ans++;f[f1]=f2;
				}
			}
		}
	}
	cout<<(max(c1,c2)*(n-1-ans)+min(c1,c2)*ans);//简单乘法 
	return 0;
}
//最难的黄题搞定了！！！ 
```
参考资料：[$\operatorname{lowbit}$ 详解](https://blog.csdn.net/Dream_ping/article/details/123965254)。
参考 [ShanireZ](https://www.luogu.com.cn/user/116524) 大佬的做法。
[大佬的讨论](https://www.luogu.com.cn/discuss/526433) 同时也是判断异或中 $n\le10$ 的由来（数据的锅，**不能保证数据正确**）。完结撒花~

---

## 作者：wangshengchen (赞：1)

### 题目分析

给定一个长度为 $n$ 的数组 $a$。同时定义 $count(x)$ 为 $x$ 在二进制下的 $1$ 的个数。

现在每次可以进行如下两种操作：

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j)=1$，将它们中的任意一个从数组中消去，代价为 $C_1$。

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j) > 1$，将它们中的任意一个从数组中消去，代价为 $C_2$。

现在你想知道，最少付出多少的代价，能让这个数组被消到只剩一个数。

#### 输入格式

第一行一个整数 $n$，表示数组大小。  
第二行两个整数 $C_1, C_2$，意义如题所示。  
第三行共 $n$ 个整数，描述了数组 $a$。

#### 输出格式

一行一个整数，表示最小代价。

## 思路

#### 现在有两种操作：

- 当两个数的异或结果中只有 $1$ 个 $1$ 时，这意味着这两个数在二进制表示中只有一个位不同。

- 当两个数的异或结果中有多个 $1$ 时，这意味着这两个数在二进制表示中有多个位不同。

#### 代价：

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j)=1$，将它们中的任意一个从数组中消去，代价为 $C_1$。

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j) > 1$，将它们中的任意一个从数组中消去，代价为 $C_2$。

#### 目标：

找到最小的代价。

## 方法

由于 $C_1 < C_2$ 所以我们应该优先判断是否满足 $C_1$ 的条件，再判断是否满足 $C_2$ 的条件。

我们需要找到尽可能多的数对，使得它们的异或结果中只有一个 $1$。

## 实际办法

- 先构建两个函数
  - 一个计算用于 $count(a_i \operatorname{xor} a_j)$。
  - 另一个用于遍历所有结果，找到最优的代价。

- 主函数输出结果。

### 温馨提示

数据范围比较大哦！

---

## 作者：__Immorta__ (赞：0)

**前言：**

蒟蒻来肝题解啦~

**题目大意：**

清蒸鱼是一个从未被击败的炽蓝仙野游戏者。有一天他遇到了这么一个游戏：

给定一个长度为 $n$ 的数组 $a$。同时定义 $count(x)$ 为 $x$ 在二进制下的 $1$ 的个数。

现在清蒸鱼每次可以进行如下两种操作：

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j)=1$，将它们中的任意一个从数组中消去，代价为 $C_1$。

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j) > 1$，将它们中的任意一个从数组中消去，代价为 $C_2$。

现在你想知道，最少付出多少的代价，能让这个数组被消到只剩一个数。

----

输入格式：

第一行一个整数 $n$，表示数组大小。  
第二行两个整数 $C_1, C_2$，意义如题所示。  
第三行共 $n$ 个整数，描述了数组 $a$。

----

输出格式：

一行一个整数，表示最小代价。

----

**详细分析：**

- 当两个数的异或结果中只有 $1$ 个 $1$ 时，这意味着这两个数在二进制表示中只有一个位不同。
- 当两个数的异或结果中有多个 $1$ 时，这意味着这两个数在二进制表示中有多个位不同。

操作代价：

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j)=1$，将它们中的任意一个从数组中消去，代价为 $C_1$。

- 选择两个数 $a_i, a_j$，并且必须满足 $count(a_i \operatorname{xor} a_j) > 1$，将它们中的任意一个从数组中消去，代价为 $C_2$。

贪心策略：
  
- 由于 $C1$ 小于 $C2$，我们优先考虑执行 $C1$ 操作。
- 我们需要找到尽可能多的数对，使得它们的异或结果中只有一个 $1$。

**解题步骤：**

预处理：

- 计算数组中每个数的二进制表示中 $1$ 的个数。
- 创建一个哈希表来记录每个数出现的次数。

寻找最优配对：

- 对于数组中的每个数，尝试找到另一个数，使得它们异或的结果中只有一个 $1$。
- 这可以通过检查每个数的二进制表示，并尝试翻转每一位来找到另一个数。
- 如果找到了这样的配对，将这两个数从数组中移除，并增加 $C1$ 到总代价。

处理剩余元素：
  
- 对于那些无法找到配对的数，我们需要使用 $C2$ 操作来移除它们。
- 找到任意两个数，将它们中的一个移除，并增加 $C2$ 到总代价。
  
重复：

- 重复上述步骤，直到数组中只剩下一个数。

----

完结撒花★,°:.☆(￣▽￣)/$.°★。

---


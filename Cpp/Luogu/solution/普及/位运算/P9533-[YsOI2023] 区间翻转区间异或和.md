# [YsOI2023] 区间翻转区间异或和

## 题目背景

Ysuperman 模板测试的数据结构题。

符卡可以是人名也可以是队名。

## 题目描述

符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。

符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\dots,a_{l-1},a_r,a_{r-1},\dots,a_l,a_{r+1},a_{r+2}\dots,a_n$。

现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？

## 说明/提示

#### 样例 1 解释

无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。

#### 样例 2 解释

这里给出可能的一种魔法发动方法。

选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。

可以证明答案无法超过 $2$。

#### 数据范围

对于前 $20\%$ 的数据，保证 $n\le 10$。

对于前 $40\%$ 的数据，保证 $n\le 2000$。

另有 $10\%$ 的数据，保证 $a_i$ 全部相等。

另有 $10\%$ 的数据，保证 $a_i$ 只有两种可能的取值。

另有 $10\%$ 的数据，保证 $0\le a_i<2^{10}$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$0\le a_i< 2^{20}$。

#### 彩蛋

灵异区间的名字其实是“零异（或）区间”的谐音。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3 1 2 3```

### 输出

```
2```

# 题解

## 作者：_•́へ•́╬_ (赞：28)

## 思路

考虑两个零异区间：

- 如果它们包含或不交，那么翻转一个对另一个没有影响。

- 如果它们相交，设区间分别为 $[l1,r1],[l2,r2]$，有 $l1\leq l2\leq r1\leq r2$。

    根据异或性质，有 $[l1,l2-1]=[l2,r1]=[r1+1,r2]$，其中等号表示异或和相等。

    可以发现，如果翻转了一个零异区间，另一个区间仍然存在，只是其左端点会移动。

所以，翻转区间不改变零异区间个数。直接用前缀异或和统计一下即可。

## code

```cpp
#include<stdio.h>
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,a[100009],cnt[1<<20];long long ans;
main()
{
	read(n);cnt[0]=1;
	for(int i=1;i<=n;++i)
	{
		read(a[i]);a[i]^=a[i-1];
		ans+=cnt[a[i]]++;
	}
	printf("%lld",ans);
}
```



---

## 作者：Shizaki_Crazy_Three (赞：12)


[题目](https://www.luogu.com.cn/problem/P9533)

首先题意很简单,可能大部分人都想到了异或前缀和。

但翻转操作难住了一大部分人（~~包括我~~）。接下来证明它是无意义的。

## 证明

设翻转前的区间是 $[l,r]$，翻转后的区间则为 $[r,l]$，用$\sum _{ i=l} ^ {r}[l,r]$表示区间内所有数的和，取其中一点 $k$，$l\le k \le r$，则一定有 $\sum _{ i=l} ^ {k}[l,k]=x$,$\sum _{ i=k} ^ {r}[k,r]=x$。

翻转之后亦同，即翻转操作是无意义的。

## 证毕

接下来，一个 $sum$ 数组储存异或前缀和，加上每个异或得到数的个数减一的阶加。

根据等差数列得： 
$$sum[i]-1+sum[i]-2+sum[i]-3+...+3+2+1=\lfloor\frac{sum[i]\times(sum[i]-1)}{2}\rfloor$$


假设 $sum[i]$ 值为 $x$。

当 $x=1$ 时前面没有匹配的数，$ans=0$；

当 $x=2$ 时前面有一个匹配的数，$ans=1$；

当 $x=3$ 时前面有两个匹配的数，$ans=\frac{3\times(3-1)}{2}=3$。



# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt[1500000]={};//记得开long long 
int main(){
	int n;
	cin>>n;
	int a;
	int sum[100005]={};
	int maxx=-1;
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		sum[i]=sum[i-1]^a;
		cnt[sum[i]]++;
		maxx=max(maxx,sum[i]);
	}
	long long ans=0;
	cnt[0]++;//自己想想，如果有零的话它不用匹配它自己也是一种情况 
	for(int i=0;i<=maxx;i++){
		ans+=(cnt[i]*(cnt[i]-1))/2;
	}
	cout<<ans;
	return 0;
}
```






---

## 作者：_mi_ka_ (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P9533)

## 解题思路

这道题我赛时没有考虑灵异区间的翻转，只求了灵异区间的个数，目的是骗一点分，但是就非常“灵异”的 AC 了。

于是在赛后证明了这个“灵异的结论”——灵异区间的翻转对灵异区间的个数没有影响。

### 证明过程（反证法）

设 $[l,r]$ 是灵异区间，现在要对其进行翻转。

若翻转后得到了新的灵异区间（灵异区间数目增加了），那么这个新的灵异区间一定与进行翻转的灵异区间有交集但不完全被翻转的区间包含。

- 若新的灵异区间与原区间没有交集则灵异区间翻转对其没有影响，不可能形成新的灵异区间
- 若新的灵异区间被包含则其翻转前对应的区间也一定是灵异区间（异或的交换律）。

设 $sum_{[a,b]}$ 为区间 $[a,b]$ 的异或和。

设新灵异区间为图中的 $[u,v]$（图中只给出了灵异区间在原区间右侧的情况）。

将三个区间标号，由 $sum_{[u,v]}=0$ 可得 $sum_B=sum_C$，又由 $sum_{[l,r]}=0$ 得 $sum_A=sum_B$，则 $sum_A=sum_C$。

![](https://cdn.luogu.com.cn/upload/image_hosting/46ecuyik.png)

现在将翻转前的区间画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/u739bjvq.png)

由于 $sum_A=sum_C$，则翻转前 $sum_{[u,v]}=0$，翻转前的 $[u,v]$ 即为灵异区间，不符合 $[u,v]$ 为新形成的灵异区间的假设，则翻转前后灵异区间的数量没有变化。

### 前缀和求灵异区间个数

用前缀和求灵异区间个数再简单不过了。

设 $s_i$ 为前 $i$ 项的前缀异或和，若 $[l,r]$ 为灵异区间，则 $s_r\oplus s_{l-1}=0$，即 $s_r=s_{l-1}$，反之结论亦成立。

在求前缀异或和的时候用数组 $vis_i$ 代表 $i$ 这个数在前面的前缀异或和中出现的次数，则每出现一个 $s_i$ 时对答案的贡献为此时的 $vis_{s_i}$（$i$ 可以与之前每一个出现 $s_i$ 的下标的后面那个数形成一个灵异区间）。

此外还应注意 $vis_0=1$，因为 $s_0=0$。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,s,a,vis[1<<21];//a[i]和s[i]都是一次性用品，可以不记 
signed main()
{
	scanf("%lld",&n),vis[0]=1;
	for(int i=1;i<=n;i++)
		scanf("%lld",&a),s^=a,ans+=vis[s],vis[s]++;//此时的s为s[i] 
	cout<<ans;
	return 0;
}
```

---

## 作者：Aamumatematiikka (赞：4)

这道题目非常得诈骗，通过分析可以得出翻转对最终的答案没有任何的影响。

为了节约时间采用前缀和进行优化，因为一个数异或它本身等于 $0$，所以区间 $[l,r]$ 的异或和是 $[1,l-1] \oplus [1,r]$。

一个数异或它本身等于 $0$，所以用 map 统计每个数在前缀和中出现的次数，最后计数。当前缀和为 $0$ 时由于本身就是 $0$ 所以需要特殊处理。

遍历 map 的方法：由于 map 底层是用 pair 实现的，所以可以像调用结构体一样调用每个下标和值。

AC代码：

```cpp
#include <stdio.h>
#include <map>
#define ll long long//不开long long见祖宗！ 
using namespace std;
ll n,ans=0,a,s=0,tmp;
map<ll,ll>mp;//用map来统计前缀和中每个数出现的次数
int main() {
	scanf("%lld",&n);
	for(ll i=1; i<=n; i++) {
		scanf("%lld",&a);
		s^=a;
		mp[s]++;//前缀和
	}
	for(map<ll,ll>::iterator it=mp.begin(); it!=mp.end(); it++) { //用迭代器遍历整个map
		if(it->first==0) {
			tmp=it->second;
			ans+=tmp*(tmp+1)/2;//前缀和为0时需要特殊处理
			continue;
		}
		tmp=it->second;
		ans+=tmp*(tmp-1)/2;//等差数列求和公式
	}
	return printf("%lld",ans)&0;//完美的输出
}
```

---

## 作者：ylch (赞：3)

# [P9533](https://www.luogu.com.cn/problem/P9533) [YsOI2023] 区间翻转区间异或和 题解

------------


## PART1. 题目大意

在一段区间内，如果该区间的异或和为 $0$，就称该区间为灵异区间。

对于任意一段灵异区间，我们都可以进行翻转操作，请你求在操作次数不限的情况下最多可以得到多少灵异区间。

## PART2. 题目分析

我分析得尽量简单一点，要使得该次反转操作有贡献，只可能是翻转两个灵异区间的相交部分，可以去举例找规律。

以样例 $[ 3,1,2,3 ]$ 为例，初始状态下，区间 $[1,3]$ 的异或和为 $3 \bigoplus 1 \bigoplus 2 = 0$；区间 $[2,4]$ 的异或和为 $1 \bigoplus 2 \bigoplus 3 = 0$，所以有两个灵异区间。

按照样例解释，翻转 $[1,3]$ 区间，数列为 $[ 2,1,3,3 ]$。

此时灵异区间 $[1,3]$ 的异或和为 $2 \bigoplus 1 \bigoplus 3 = 0$；区间 $[3,4]$ 的异或和为 $3 \bigoplus 3 = 0$，同样有两个灵异区间。

可以发现开始答案和结束时答案并无区别，这是因为原来 $[3,4]$ 区间为 $3 \bigoplus 3$，翻转后区间 $[2,4]$ 为 $1 \bigoplus 2 \bigoplus 3$ 也就等于 $3 \bigoplus 3$。

尝试证明以上现象：

因为异或（xor）运算是满足交换律（$A \bigoplus B = B \bigoplus A$）和结合律（$A \bigoplus B \bigoplus C = A \bigoplus (B \bigoplus C)$）的，同一区间内的运算顺序并不影响运算结果。

当处于两个区间重叠部分的灵异区间翻转后，第一个灵异区间当然还是存在的；对于第二个灵异区间，我们可以这么想，翻转操作之前两个区间异或和为 $0$，也就是说通过异或一定可以得到只剩下 $A \bigoplus B$ 且 $A = B$ 的状态，而第一个区间包含了第二个区间的一部分（可以理解为 $A$），当翻转后，第一个区间的 $A$ 一定还存在于第一个区间的末尾，而第二个区间里的 $B$ 部分没有变动，所以异或和依然为 $0$。

## PART3. AC 代码

其实求异或前缀和的代码其他大佬已经解释得很清楚了，故代码部分不做解释。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 1e5 + 5;
const int MAXA = 2 * (2<<20);
ll a[MAXN], b[MAXN], t[MAXA]; //前缀和数组、桶数组
ll ans, maxn = -1;

signed main()
{
	int n;
	cin >> n;
	for (int i = 1; i<=n; i++)
	{
		cin >> a[i];
		b[i] = b[i-1] ^ a[i]; //求异或前缀和
	}
	for (int i = 1; i<=n; i++)
	{
		t[b[i]]++;
		if (b[i] == 0)	
		{
			ans++; //本身为0也是
		}
		maxn = max(maxn, b[i]); //求最大前缀和
	}
	for (ll i = 0; i<=maxn; i++)
	{
		if (t[i] >= 2)
			ans += (1+t[i]-1) * (t[i]-1) /2; //等差数列求和公式
	}
	cout << ans << endl; //零异区间个数
	return 0;
}
```

## End

管理员大大辛苦啦~

谢谢大家！

---

## 作者：yhx0322 (赞：3)

## Description
有一个数组 $a$，我们认为一个区间 $[l,r]$ 是灵异区间当且仅当这个区间内所有数字异或和等于 $0$。

如果 $[l,r]$ 区间是灵异区间，那么就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\dots,a_{l-1},a_r,a_{r-1},\dots,a_l,a_{r+1},a_{r+2}\dots,a_n$。

现在可以使用任意次数的魔法，希望最后得到的数组的灵异区间数量**能够尽可能多**，求：最多的灵异区间的数量。

## Solution
这题的坑点：**区间的反转对最终的结果没有影响。**

#### 证明：
- 设两个灵异区间分别为 $[x_1, y_1],[x_2,y_2]$。
- 如果 $x_1 < x_2 < y_2 < y_1$ 或者 $x_1 < y_1 < x_2 < y_2$：说明他们相互包含，或者不相交。
- 否则 $x_1 < x_2 < y_1 < y_2$：可将 $a$ 数组分割：$[x_1,x_2],[x_2 + 1,y_1],[y_1 + 1, y_2]$。若翻转第一个区间，$(a_{x_1},a_{x_1+1},\dots,a_{x_2}) \oplus (a_{y_1 + 1},a_{y_1+2},\dots,a_{y_2}) = 0$，代表着第一个区间个第三个区间的异或和为 $0$，而第一区间和第二区间异或和也为 $0$，所以证明没有影响。

分析出结论之后，便可以用前缀和 + map 统计即可。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, ans, x, s;
map<int, int> mp;
signed main() {
	cin >> n;
	mp[0] = 1;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		s ^= x;
		ans += (mp[s]++);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：哈哈人生 (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P9533)

## 题外话
~~这题真的很恶心……~~

## 思路
我们第一个需要明白的是，题目中所谓的反转区间对灵异区间的数量是丝毫没有影响的。因为异或运算同加减运算一样，具有交换律和结合律，读者可以用随机数试验。明白这点，这道题我们就成功一半了。

接下来我们这样想：灵异区间的定义是“这个区间内所有数字异或起来刚好等于 $0$”，这是一个区间问题，所以我们可以有以下几种思路：线段树、树状数组、前缀和。通过第一段的叙述，我们知道这个区间不是动态的（即不会被改动），所以我们使用前缀异或和进行区间维护。

这时，我们就可以思考一个新的问题了：前缀异或和什么特性的区间是灵异区间呢？有两种情况：
1. 前缀异或和本身为 $0$。
2. 有 $x(x\ge 2)$ 个前缀异或和相等（相减为 $0$），那么这 $x$ 个前缀异或和能匹配出多少不同的个灵异区间呢？根据组合公式（不是排列公式），贡献的灵异区间数量是 $x$ 累加到 $1$。

最后实现：我们只要知道用桶可以记录前缀异或和就行了。

## 代码
~~又臭又长：~~
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
int n,a[100005],b[100005],mp[2000005],ans=0,maxx=-1;
int jc(int x){//累加函数
	int s=0;
	for(int i=x;i>=1;i--)s+=i;
	return s;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],b[i]=b[i-1]^a[i];
	for(int i=1;i<=n;i++){
		mp[b[i]]++;
		if(b[i]==0)ans++;//本身为0情况
		maxx=max(maxx,b[i]);
	}
	for(int i=0;i<=maxx;i++){
		if(mp[i]>=2)ans+=jc(mp[i]-1);
	}
	cout<<ans;//时间复杂度十分优秀
	return 0;
}
```
**请读者诚信粘贴题解，遵守洛谷社区守则，另外，点个赞呗。**

---

## 作者：Vct14 (赞：1)

我们先考虑翻转灵异区间对其它灵异区间的影响。设我们要反转的区间为 $[l,r]$。

对于不与此区间相交的区间 $[l_1,r_1]$（$r_1<l$ 或 $l_1>r$），则翻转 $[l,r]$ 对其无影响。

对于包含此区间或被此区间包含的区间 $[l_2,r_2]$，异或和显然不变，也没有影响。

对于与此区间相交的区间 $[l_3,r_3]$（$l_3<l<r_3<r$ 或 $l<l_3<r<r_3$，这里考虑前一种情况，后一种同理），$\bigoplus_{i=l_3}^{l-1}a_i=\bigoplus_{i=l}^{r_3}a_i=\bigoplus_{i=r_3+1}^{r}a_i$，即灵异区间个数不变。

综上，翻转灵异区间对灵异区间的总数量没有影响。使用前缀和统计初始状态下灵异区间的数量即可。

因为本题输入较大，因此需要开 `long long`。

---

## 作者：mc123456 (赞：1)

## 分析

考虑翻转操作对灵异区间个数的影响。考虑两个灵异区间 $[l_1, r_1]$ 和 $[l_2, r_2]$，不妨 $l_1 < l_2$，则：

+ 若 $r_1 < l_2$，则无论翻转哪个区间，另一个区间仍为灵异区间，即灵异区间个数不变。

+ 若 $r_1 \geq l_2$，那么有 $\bigoplus\limits_{i = l1}^{r_1}{a_i} = \bigoplus\limits_{i = l2}^{r_2}{a_i} = 0$，由异或的性质可得 $\bigoplus\limits_{i = l1}^{l_2 - 1}{a_i} = \bigoplus\limits_{i = l2}^{r_1}{a_i} = \bigoplus\limits_{i = r1 + 1}^{r_2}{a_i}$。那么将 $[l_2, r_2]$ 翻转后，可以发现 $[l_1, l_2 - 1 + r_2 - r_1]$ 仍为一个灵异区间（翻转另一区间同理），即灵异区间数量不变。

故翻转操作不会对灵异区间得个数产生影响。

所以答案即为初始状态区间异或和为 $0$ 的区间个数，用前缀和可以轻松解决。

时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long

int n;
int cnt[(1 << 20) + 10];

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n;
    int ans = 0;
    cnt[0] = 1;
    for (int i = 1, a, s = 0; i <= n; i++)
        cin >> a, s ^= a, ans += cnt[s], cnt[s]++;
    cout << ans << endl;
}
```

---

## 作者：ncwzdlsd (赞：1)

诈骗。

> 翻转操作对序列灵异区间的个数没有影响。

考虑两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$，若两区间包含或交集为空，则翻转任意一个后对两区间均没有影响；若两区间相交，即 $l_1<l_2<r_1<r_2$，根据异或运算性质有 $\bigoplus_{l_1}^{l_2}=\bigoplus_{l_2+1}^{r_1}=\bigoplus_{r_1+1}^{r_2}$。根据上式对区间进行拆分，翻转区间只相当于对这三个子区间进行重新组合，显然异或和还是为 $0$，没有改变灵异区间数量。

统计原数组的灵异区间数即可。统计前缀异或和并记录每个前缀异或和出现的次数，对于一个新统计到的异或前缀和 $s_i$，可以喝每一个出现过的相同的异或前缀和 $s_j$ 组成一个灵异区间 $[j+1,i]$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e5+5;
int a[maxn],cnt[1<<21],s;

signed main()
{
	int n;cin>>n;
	cnt[0]=1;
	int ans=0;
	for(int i=1;i<=n;i++) cin>>a[i],s^=a[i],ans+=cnt[s],cnt[s]++;
	cout<<ans;
	return 0;
}
```

---

## 作者：Sorato_ (赞：1)

## 一道性质题

#### 不难发现，区间翻转操作是没有用的（虽然赛时想了好久 www）。

首先，区间翻转要想对答案有贡献，一定是下边这种情况：

**三个连续的区间：$A~|~B~|~C$。**

**满足：$B \oplus C=0,A \oplus C=0$。**

**将 $B \cup C$ 这个灵异区间进行翻转，使 $A$ 和 $C$ 合并到一起，会增加一个灵异区间 $A \cup C$。**

但是，如果 $B \oplus C=0,A \oplus C=0$，那么 也有$A \oplus B=0$。

因为：若满足上述条件，则 $\bigoplus B=\bigoplus C,\bigoplus A=\bigoplus C$。

所以 $\bigoplus A=\bigoplus B$，即 $A \oplus B=0$。

所以翻转前 $A\cup B$ 也是灵异区间，而反转后这个灵异区间就没有了。

#### 所以区间翻转实际上是没用的。

---

#### 然后就好写了，统计原数组的灵异区间即可。

原理很简单：维护一个异或前缀和 $sum$，并用 $cnt_i$ 记录前缀和为 $i$ 出现的次数。

比如如果 $sum_i=sum_j=x$，则区间 $[i+1,j]$ 的异或和为 $0$，即为灵异区间。

且 若也有 $sum_k=x~(i<j<k)$，则区间 $[i+1,k]$ 中共有 $2+1=3$ 个灵异区间（$[i+1,j],[j+1,k],[i+1,k]$）。

即若前缀和 $x$ 出现了 $m$ 次，则灵异区间有 $1+2+3+...+m=m(m-1)/2$ 个。

我们再用 $a$ 数组记录每种不同的前缀和，遍历 $a$ 数组计算并统计灵异区间数量即可。

还要特殊处理一下 $0$，很简单，$sum$ 的初值是 $0$，我们把这个 $0$ 也计入计算即可。

```c++
n=read();
cnt[0]=1;a[++tot]=0;
while(n--)
{
    sum^=read();
    if(!cnt[sum])	a[++tot]=sum;
    cnt[sum]++;
}
for(reg int i=1;i<=tot;i=-~i)	ans+=cnt[a[i]]*(cnt[a[i]]-1)/2;
printf("%lld",ans);
```

---

## 作者：_O_v_O_ (赞：1)

结论题。

先放结论：翻转一个“灵异区间”不影响“灵异区间”的数量。

证明：

设两个“灵异区间”分别是 $[l1,r1]{,}[l2,r2]$。

- 如果 $l1<l2<r2<r1$ 那么说明第一个区间包含第二个区间，不会变。
- 如果 $l1<r1<l2<r2$ 那么说明它们并不相交，也不会变。
- 否则，说明 $l1<l2<r1<r2$，根据异或的基本性质可得：

$$a_{l1}\oplus a_{l1+1}\oplus a_{l1+2}\oplus\cdots\oplus a_{l2}=a_{l2+1}\oplus a_{l2+2}\oplus a_{l2+3}\oplus\cdots\oplus a_{r1}=a_{r1+3}\oplus a_{r1+2}\oplus a_{r1+3}\oplus\cdots\oplus a_{r2}$$

因此，我们可以把 $a$ 分成 $3$ 部分：$[l1,l2]{,}[l2+1,r1]{,}[r1+1,r2]$，如果翻转第一个区间，那么第一部分和第三部分就在一起了，而从上面的等式中可得：第一区间异或第三区间结果等于 $0$，而第一跟第二区间挨一起，异或和也为 $0$ ，翻转区间二同理。

从上可得：反转区间不影响“灵异区间”的数量，因此，此题只用统计“灵异区间”的个数即可。

------------
实现：

我们可以来维护前缀异或和，并用一个数组 $b$ 维护每个异或和出现的次数，如果当前异或和为 $c$ 那么让统计和的数 $ans+cnt_c$ 即可，再让 $cnt_c+1$ 就行了。

证明：

设第一次 $cnt_c+1$ 时的 $i=x$，第二次 $i=y$，根据异或的性质，$[x,y]$ 一定是个“灵异区间”。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n,a[1000005],xxor,ans;
unordered_map<int,int>cnt;//用 map 优化

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n;
	cnt[0]=1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		xxor^=a[i];
		ans+=cnt[xxor]++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Chis725 (赞：0)

## P9533 区间翻转区间异或和 题解 

### 思路

做这道题的时候看了一下样例，发现每次灵异区间操作后的个数都不变。然后自己造了几个样例都是不变的。这时，我们就可以猜想它的灵异区间是不变的。

### 证明

我们可以考虑两个区间。

- 区间互不相交，操作后互不干扰，个数不变。

- 区间包含，操作后无影响，个数不变。

- 区间相交，设两个异或区间为 $[l1,r1]$，$[l2,r2]$，满足 $l1 \leq l2 \leq r1 \leq r2$。根据异或运算的性质，则有 $\bigoplus_{i=l1}^{l2} a_i=\bigoplus_{i=l2}^{r1} a_i=\bigoplus_{i=r1}^{r2} a_i$，所以旋转后异或区间个数不变。

知道个数不变后，就只需要用异或前缀和统计后，求相同数对个数就好了。

### 献上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
map<ll,ll>mp;//记录相同异或前缀和个数 
ll s[100001],n,x,ans=0;
inline ll read(){//快读 
	ll n=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10^48);
	return;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        x=read();
        s[i]=(s[i-1]^x);//异或前缀和 
        if(s[i]==0)ans++;
        ans+=mp[s[i]];
        mp[s[i]]++;
    }
    write(ans);
    return 0;
}
```


---

## 作者：lateworker (赞：0)

这道题的题意非常简单易懂，但是题目给出的操作非常迷惑。

## 思路

先说结论：灵异区间的翻转操作并不会影响灵异区间的个数。理由如下：

- 我们把区间 $[l,r]$ 的异或和记为 $sum[l,r]$。
- 假设翻转的区间 $[l,r]$ 中存在下标 $k_1(l\le k_1\le r)$，则有 $sum[l,k_1-1]=sum[k_1,r]$。
- 根据上一条可以得出：如果在区间 $[1,l-1]$ 中存在下标 $k_2(1\le k_2\le l-1)$，并且 $sum[k_2,l-1]\oplus sum[k_1,r]=0$（可以尝试交换）时，则必有 $sum[k_2,l-1]\oplus sum[l,k_1-1]=sum[k_2,k_1-1]=0$。
- 同理可得，如果 $r+1\le k_2\le n$（$k_2$ 位于 $[r+1,n]$ 区间），那么必有 $sum[l,k_1-1]\oplus sum[r+1,k_2]=sum[k_1,k_2]=0$。

也就是说，翻转区间 $[l,r]$ 时并不会改变原数组灵异区间个数，原题就可以转化为统计原数组中灵异区间的个数，也就是求原数组中异或和为 $0$ 的区间数量。

## 实现

对于多次区间异或和的问题，可以考虑使用前缀异或和。根据前缀和的运算规则，如果前缀异或和数组 $psum$ 中出现了两个相同的元素 $psum[l-1]=psum[r]$，那么区间 $[l,r]$ 的异或和一定为 $0(psum[r]-psum[l-1])$。

我们可以创建并遍历桶 $t$，统计区间个数。其中 $t_i$ 记录 $psum$ 数组中数值为 $i$ 的元素个数。经过简单的手动推导，可以得到答案 $ans$ 的计算公式：

- $ans=\sum_{i=0}^n\begin{cases}\frac{t_i\times(t_i+1)}2&(i=0)\\ \frac{t_i\times(t_i-1)}2&(i\neq0)\end{cases}$

## 代码
**本题解禁止理解性默写!**
```c++
#include <iostream>
using namespace std;
const int N = 1e5+10;
int n, psum, t[1<<20];	// psum:压缩后的前缀和数组; t:桶.
int main() {
	cin>>n;
	for(int i=1;i<=n;++i) {
		int x; cin>>x;
		psum ^= x;	// 计算当前位置的前缀异或和.
		++t[psum];	// 把前缀异或和放进桶里.
	}
	// 不开longlong见祖宗
	long long ans = 1ll*t[0]*(t[0]+1)/2; // i=0时.
	for(int i=1;i<(1<<20);++i) 
		ans += 1ll*t[i]*(t[i]-1)/2;	// i!=0时.
	cout<<ans;
	return 0;
}
```
~~希望审核通过~~

---


# [GCJ 2010 #1C] Load Testing

## 题目描述

现在你已经赢得了 Code Jam 并被 Google 雇佣为软件工程师，你被分配到他们极受欢迎的编程竞赛网站工作。

Google 预计明年会有很多参赛者（$P$）参加 Code Jam，他们希望确保网站能够同时支持这么多人。在 2010 年的 Code Jam 期间，你了解到该网站至少可以同时支持 $L$ 个人而不会出错，但你也知道目前网站还无法支持 $P$ 个人。

为了确定还需要增加多少台机器，你希望知道网站最多能支持多少人，误差在 $C$ 倍以内。也就是说，存在一个整数 $a$，你知道网站可以支持 $a$ 个人，但不能支持 $a \times C$ 个人。

你可以进行一系列的“负载测试”，每次测试可以确定网站是否能支持至少 $X$ 个人（$X$ 是你选择的整数）。如果你采用最优策略，根据前面测试的结果选择后续的测试，那么在最坏情况下，你需要进行多少次负载测试，才能确定网站最多能支持多少人，误差在 $C$ 倍以内？

## 说明/提示

**样例解释**

在第 2 个测试用例中，我们已经知道网站可以支持 $19$ 到 $57$ 个人。由于这两个数相差 $3$ 倍，因此我们不需要进行任何测试。

在第 4 个测试用例中，我们可以测试 $48$；但如果网站能支持 $48$ 个人，还需要继续测试，因为 $48 \times 2 < 97$。我们可以测试 $49$；但如果网站不能支持 $49$ 个人，还需要继续测试，因为 $24 \times 2 < 49$。所以我们需要进行两次测试。

**数据范围**

- $1 \leqslant T \leqslant 1000$。
- $2 \leqslant C \leqslant 10$。
- $L$、$P$ 和 $C$ 均为整数。

**小数据集（14 分，测试集 1 - 可见）**

- $1 \leqslant L < P \leqslant 10^3$。

**大数据集（22 分，测试集 2 - 隐藏）**

- $1 \leqslant L < P \leqslant 10^9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
50 700 2
19 57 3
1 1000 2
24 97 2```

### 输出

```
Case #1: 2
Case #2: 0
Case #3: 4
Case #4: 2```

# 题解

## 作者：青溪白石 (赞：0)

# P13397 Load Testing

## 题目描述

已知网站能支持至少 $L$ 人，不足以支持 $P$ 人。
希望确定网站最大可支持人数 $a$，满足：

$$
a \le \text{最大人数} < a \times C
$$

每次“负载测试”可以检测网站是否能支持至少 $X$ 人（$X$ 由你选择）。
你可以根据之前的测试结果调整后续测试值。

问：在最坏情况下，最少需要多少次测试，才能确定满足误差不超过 $C$ 倍的 $a$？

## 输入

第一行：测试组数 $T$，
接下来 $T$ 行：三个整数 $L, P, C$
## 输出

对于每组数据：

```
Case #x: y
```

$x$ 为测试编号（从 1 开始），$y$ 为最少测试次数（最坏情况）。

## 分析

这种进行测试后，通过反馈设定下一次测试的数据的行为会让我们想到什么？

二分。

鉴于要求的是一个范围 $[x, x \times C)$，容易将它和实数域上的二分答案联系起来。

但是二分用的是加法，我们用的是乘法。

先别管那么多了。先假设它要求的范围是 $[x, x + C)$,看看怎么编写程序（求范围的，不是求多少次的）：

```cpp
double l = L, r = P;
while(r - l > x){
    double mid = (l + r) / 2;
    cout << mid;
    bool op; cin >> op;//op=0：不能支持；op=1：能支持
    if(op){
		r = mid;
    }
    else{
        l = mid;
    }
}
```

每次会将区间长度减半，所以需要求 $\log_2(\frac{r-l}{x})=\log_2(r-l)-\log_2x$ 次。

但是这道题是乘法，怎么办呢？

将乘法变成加法，考虑使用对数。

此时 $r'=\ln r$，$l' = \ln l$，$x' = \ln x$，也就把解转变为了
$$
\begin{aligned}\log_2(\frac{r'-l'}{x'})&=\log_2(\ln (\frac r l))-\log_2\ln x\\&=\log_2(\log_x(\frac r l)) \end{aligned}
$$
（当然要向上取整）。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int logc(int l, int p, int c) {
    int k = 0;
    ll x = l;
    while (x < p) {
        x *= c;
        ++k;
    }
    return k;
}
int log2(int x) {
    int res = 0;
    --x;  // 次数向上取整。
    while (x > 0) {
        x >>= 1;
        ++res;
    }
    return res;
}
int main() {
    int T; cin >> T;
    int kase = 1;
    while(T--){
        int l, p, c;
        cin >> l >> p >> c;
        if(p <= c*l){
            printf("Case #%d: 0\n", kase++);
            continue;
        }
        int k = logc(l, p, c);
        printf("Case #%d: %d\n", kase++, log2(k));
    }
    return 0;
}
```

---


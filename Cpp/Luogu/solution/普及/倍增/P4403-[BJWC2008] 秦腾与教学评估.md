# [BJWC2008] 秦腾与教学评估

## 题目描述

在秦腾进入北京大学学习的第一个学期，就不幸遇到了前所未有的教学评估。

在教学评估期间，同学们被要求八点起床，十一点回宿舍睡觉，不准旷课，上课不准迟到，上课不准睡觉……甚至连著名的北大三角地也在教学评估期间被以影响校容的理由被拆除。这些“变态”规定令习惯了自由自在随性生活学习的北大同学叫苦不迭。

这一天又到了星期五，一大早就是秦腾最不喜欢的高等代数课。可是因为是教学评估时期，不能迟到，于是他在八点五分的时候挣扎着爬出了宿舍，希望能赶快混进在八点钟已经上课了的教室。

可是，刚一出宿舍楼门他就傻眼了：从宿舍到教学楼的路上已经站满了教学评估团的成员。他们的目的就是抓住像他这样迟到的学生，扣除学校的分数。

秦腾当然不能让评估团得逞。他经过观察发现，整个评估团分成了 $N$ 个小组，每个小组的成员都分布在从宿舍楼到教学楼的路上的某一段，并且同一小组的成员间的距离是相等的。于是，我们可以用三个整数 $S,E,D$ 来描述评估团的小组：既该小组的成员在从宿舍到教学楼的路上的 $:S,S+D,S+2D,\ldots,S+KD(K \in \mathbb Z,S+KD\le E,S+(K+1)D>E)$ 位置。

观察到了教学评估团的这一特点，又经过了认真的思考，秦腾想出了对策 $:$ 如果在路上的某一位置有奇数个教学评估团成员，他就可以运用调虎离山，声东击西，隔山打牛，暗度陈仓等方法，以这一地点为突破口到达教学楼。

但是由于教学评估团的成员的十分狡猾，成员位置安排的设计极其精妙，导致在整条路上几乎没有这样的位置出现。即使由于安排不慎重出现了这样的位置，最多也仅有一个。

现在秦腾观察出了所有小组的安排，但是由于整个教学评估团的人数太多，他实在看不出这样的位置是否存在。

现在，你的任务是写一个程序，帮助他做出判断。

## 说明/提示

数据范围：

- 教学评估团的总人数不大于 $10^8$；
- $S_i\le E_i$；
- $1\le T\le 5$；
- $N\le 2 \times 10^5$；
- $0\le S_i,E_i,D_i\le 2^{31}-1$；
- 输入文件的大小不大于 2048 KB。

## 样例 #1

### 输入

```
3 
2 
1 10 1 
2 10 1 
2 
1 10 1 
1 10 1 
4 
1 10 1 
4 4 1 
1 5 1 
6 10 1 ```

### 输出

```
1 1 
Poor QIN Teng:( 
4 3 ```

# 题解

## 作者：Drinkkk (赞：23)

【题目描述】

在秦腾进入北京大学学习的第一个学期，就不幸遇到了前所未有的教学评估。

在教学评估期间，同学们被要求八点起床，十一点回宿舍睡觉，不 准旷课，上课不准迟到，上课不准睡觉……甚至连著名的北大三角地也在教学评估期间被以影响校容的理由被拆除。这些“变态”规定令习惯了自由自在随性生活学习的北大同学叫苦不迭。

这一天又到了星期五，一大早就是秦腾最不喜欢的高等代数课。可是因为是教学评估时期，不能迟到，于是他在八点五分的 时候挣扎着爬出了宿舍，希望能赶快混进在八点钟已经上课了的教室。

可是，刚一出宿舍楼门他就傻眼了: 从宿舍到教学楼的路上已经站满了教学评估团的成员。他们的目的就是抓住像他这样迟到的学生，扣除学校的分数。

秦腾当然不能让评估团得逞。他经过观察发现，整个评估团分成了$n$个小组，每个小组的成员都分布在从宿舍楼到教学楼的路上的某一段，并且同一小组的成员间的距离是相等的。于是，我们可以用三个整数$S, E, D$来描述评估团的小组: 既该小组的成员在从宿舍到教学楼的路上的：$S, S + D, S + 2D, …, S + KD (K \in Z, S + KD ≤ E, S + (K + 1)D > E)$位置。

观察到了教学评估团的这一特点，又经过了认真的思考，秦腾想出了对策: 如果在路上的某一位置有奇数个教学评估团成员，他就可以运用调虎离山，声东击西，隔山打牛，暗度陈仓……等方法，以这一地点为突破口到达教学楼。

但是由于 教学评估团的成员的十分狡猾，成员位置安排的设计极其精妙，导致在整条路上几乎没有这样的位置出现。即使由于安排不慎重出现了这样的位置，最多也仅有一个。

现在秦腾观察出了所有小组的安排，但是由于整个教学评估团的人数太多，他实在看不出这样的位置是否存在。

现在，你的任务是写一个程序，帮助他做出判断。

【输入输出格式】

- 输入格式

输入文件的第一行为一个整数$T$。

接下来输入$T$组相互独立的测试数据。

每组测试数据的第一行包含一个整数，代表$n$接下来的$n$行，每行三个整数$S_i, E_i, D_i$， 代表第$i$个小组对应的三个参数。

- 输出格式
对于每个测试数据，如果题目中所求的位置不存在，既任意位置都有偶数个教学评估团的成员存在，在输出文件的中打印一行：“``Poor QIN Teng:(``”（不包含引号）否则打印两个整数$Posi, Count$，代表在唯一的位置$Posi$，有$Count$个教学评估团的成员。

根据题意，$Count$应为奇数。

【输入输出样例】

- 输入样例
```
3 
2 
1 10 1 
2 10 1 
2 
1 10 1 
1 10 1 
4 
1 10 1 
4 4 1 
1 5 1 
6 10 1 
```
- 输出样例
```
1 1 
Poor QIN Teng:( 
4 3 
```
【说明】

教学评估团的总人数不大于$10^8$。

$S_i \leq E_i$，$1 \leq T \leq 5$，$N \leq 200000$，$0 \leq S_i,E_i,D_i \leq 2^{31}-1$。

输入文件的大小不大于2048KB。

【题目大意】

在一条线段上有许多点。这些点可以用$3n$个整数来表示，每行的三个整数分别为$S_i,E_i,D_i$，表示有许多个点在$S, S + D, S + 2D, …, S + KD (K \in Z, S + KD ≤ E, S + (K + 1)D > E)$位置。求在这一条线段上是否有一个点上的点的个数为奇数，保证解最多只有一个，若无解则输出“``Poor QIN Teng:( ``”（不包含引号），否则就输出那个唯一的点个个数以及有多少个点在它的上面，有$T$组相互独立的测试数据，对于每组数据输出一行答案，格式如前所述。

【题解】

- 解法一

我会暴力！

考虑直接用一个数组来存储每个点上的点的个数，然后暴力扫描即可。若搜不到答案即无解，输出“``Poor QIN Teng:( ``”（不包含引号）即可，但是由于$S_i$以及$E_i$太大，数组的空间不够，因此只能够得到部分的分数，期望得分$0$~$30$，实际得分$20$分。

- 解法二

考虑在解法一的基础上进行改进，用一个函数$calc()$来计算每个点上的点的个数，在这里我用$calc(i)$来表示第$i$个点上的点的个数，但是容易超时，期望得分$0$~$50$分，实际得分$0$分。

- 解法三

我们考虑在解法二的基础上进行优化，我们可以把$calc()$函数的时间复杂度降为$O(n)$，并用$calc(i)$来表示点$1$到点$i$上的点的个数，并且考虑二分。怎么进行二分呢？因为题目中说了答案最多只有一个，所以如果$calc(mid)\;mod\;2=1$那么答案一定小于等于$mid$，否则答案一定大于$mid$。最后的点$l$就是答案（在这里我用$l$来表示当前二分的左边界，并用$r$来表示当前二分的右边界），最后再用$O(n)$的复杂度扫一次有多少个点在点$i$的上面然后按题目要求输出即可，还有一点要注意的是要开$long\;long$哦。期望得分$0$~$100$分，实际得分$100$分，时间复杂度约为$O(T \times n\;log_2\;r)$，其中$r$表示的是最大的$E_i$。

解法一代码~
```
#include <cstdio>
#include <cstring>
int a[1000001];
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int t=0;
    scanf("%d",&t);
    while(t--)
    {
        memset(a,0,sizeof(a));
        int n=0,r=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            int x=0,y=0,z=0;
            scanf("%d %d %d",&x,&y,&z);
            for(int j=x;j<=y;j+=z)
            {
                a[j]++;
            }
            r=max(r,y);
        }
        bool flag=false;
        for(int i=0;i<=r;i++)
        {
            if(a[i]%2==1)
            {
                flag=true;
                printf("%d %d\n",i,a[i]);
                break;
            }
        }
        if(flag==false)
        {
            printf("Poor QIN Teng:(\n");
        }
    }
    return 0;
}
```

解法二代码~
```
#include <cstdio>
#include <cstring>
int x[1000001],y[1000001],z[1000001];
int n=0,r=0;
int max(int x,int y)
{
    return x>y?x:y;
}
int calc(int px)
{
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=x[i];j<=y[i];j+=z[i])
        {
            if(j==px)
            {
                ans++;
            }
        }

    }
    return ans;
}
int main()
{
    int t=0;
    scanf("%d",&t);
    while(t--)
    {
        n=0,r=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d %d %d",&x[i],&y[i],&z[i]);
            r=max(r,y[i]);
        }
        bool flag=false;
        for(int i=1;i<=r;i++)
        {
            int tx=calc(i);
            if(tx%2==1)
            {
                flag=true;
                printf("%d %d\n",i,tx);
                break;
            }
        }
        if(flag==false)
        {
            printf("Poor QIN Teng:(\n");
        }
    }
    return 0;
}
```

下面上AC代码~
```
#include <cstdio>
#include <cstring>
long long x[1000001],y[1000001],z[1000001];
long long n=0,l=0,r=0;
long long min(long long x,long long y)
{
    return x<y?x:y;
}
long long max(long long x,long long y)
{
    return x>y?x:y;
}
long long calc(long long d)
{
    long long da=0;
    for(long long i=1;i<=n;i++)
    {
        if(x[i]<=d)
        {
            da+=(min(d,y[i])-x[i])/z[i]+1;
        }
    }
    return da;
}
int main()
{
    long long t=0;
    scanf("%lld",&t);
    while(t--)
    {
        long long ans=0;
        l=0,r=0,n=0;
        scanf("%lld",&n);
        for(long long i=1;i<=n;i++)
        {
            scanf("%lld %lld %lld",&x[i],&y[i],&z[i]);
            r=max(r,y[i]);
        }
        if(calc(r)%2==0)
        {
            printf("Poor QIN Teng:(\n");
            continue;
        }
        while(l<r)
        {
            long long mid=(l+r)/2;
            if(calc(mid)%2==1)
            {
                r=mid;
            }
            else
            {
                l=mid+1;
            }
        }
        for(long long i=1;i<=n;i++)
        {
            if(x[i]>l || y[i]<l)
            {
                continue;
            }
            if((l-x[i])%z[i]==0)
            {
                ans++;
            }
        }
        printf("%lld %lld\n",l,ans);
    }
    return 0;
}
```

---

## 作者：米奇奇米 (赞：7)

## 题解-P4403 BJWC2008秦腾与教学评估

### 题目意思
 就是有很多次操作对线段进行覆盖，问你在$[1..max]$中被覆盖奇数次的点以及被覆盖次数。
 
### $Solution$

主要的思想是**二分答案**

* **如何检验二分答案是否正确**

只要$O(n)$判断即可，对于每个二分到的点$s$与当前小组，但满足$d[i]|(s-si)$即可。判断覆盖数是否是奇数就好了。注意$s\leq ti$

```cpp
inline bool check(int x) {
	int sum=0;
	for ( int i=1;i<=n;i++ ) { 
		if(s[i]>x) continue;
		sum+=(min(x,e[i])-s[i])/d[i]+1;
	}
	return (sum&1);
}
```

***

* **时间复杂度**
$O(T*nlog(n))$

### $Code$
```cpp
#include <bits/stdc++.h>
#define int long long 

using namespace std;

inline int read() {
	int sum=0; char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) 
		sum=sum*10+(ch^48),ch=getchar();
	return sum;
}

const int maxn=100005;

int n,m,ans,s[maxn],d[maxn],e[maxn];

inline int check(int x) {
	int sum=0;
	for ( int i=1;i<=n;i++ ) { 
		if(s[i]>x) continue;
		sum+=(min(x,e[i])-s[i])/d[i]+1;
	}
	return sum;
}

signed main() {
	int Q=read();
	while(Q--) {
		int sum=0,nowmax=0;
		n=read();
		for ( int i=1;i<=n;i++ ) {
			s[i]=read();
			e[i]=read();
			d[i]=read();
			sum+=(e[i]-s[i])/d[i]+1; 
			nowmax=max(nowmax,e[i]);
		}
		if(sum%2==0) {
			printf("Poor QIN Teng:(\n");
			continue;
		}
		int l=0,r=nowmax;
		while(l<r) {
			int mid=(l+r)/2;
			if(check(mid)&1) r=mid;
			else l=mid+1;
		}
		xjh:;
		ans=0;
		for ( int i=1;i<=n;i++ ) {
			if(l<s[i]) continue; 
			if(l>e[i]) continue;
			if((l-s[i])%d[i]==0) ans++;
		}
		printf("%lld %lld\n",l,ans);
	}
	return 0; 
}
		
```




---

## 作者：zhoubaobao (赞：6)

根据题意，最多只有一个地方的人数是奇数。

## **那么**：
很明显，他是符合单调性的，因为如果出现了奇数，那么他之前的前缀和都是偶数，他之后的前缀和都是奇数。

这样随手来一个二分就好了

看看如何二分：

```cpp
int f(long long x)
{
	ans=0;
	for(i=1;i<=n;i++)//枚举每一组检察官
	{
		if(a[i]<=x)
		{
			ans=ans+(min(x,b[i])-a[i])/c[i]+1;//计算覆盖此区间的人数
		}
	}
	return ans;
}
```
这就是二分的想法
下面直接附上完整代码
```cpp
#include<cstdlib> 
#include<cstdio> 
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
int i,j,n,m,T;
long long ans;
int a[1000001],b[1000001],c[1000001];
inline int min(int a , int b)
{
    return a < b ? a : b;
}
inline int max(int a , int b)
{
    return a > b ? a : b;
}
int f(long long x)
{
	ans=0;
	for(i=1;i<=n;i++)
	{
		if(a[i]<=x)
		{
			ans=ans+(min(x,b[i])-a[i])/c[i]+1;
		}
	}
	return ans;
}
int main()
{

	scanf("%d",&T);
	while(T)
	{
		T--;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(c,0,sizeof(c));
		ans=0;
		int r=0;
		scanf("%d",&n);
		for(i=1;i<=n;i++)
		{
			scanf("%d%d%d",&a[i],&b[i],&c[i]);
			r=max(r,b[i]);
		}
		int l=0,mid;
		if(f(r)%2==0)
		{
			printf("Poor QIN Teng:(");
		}
		else 
		{
			while(l<=r)
			{
				mid=(l-r)/2+r;
				if(f(mid)%2==0)l=mid+1;
				else r=mid-1;
			}
			int p=0;
			for(i=1;i<=n;i++)
			{
				if(r+1>=a[i]&&r+1<=b[i])
				  if((r+1-a[i])%c[i]==0)
				    p++;
			}
			printf("%d %d",r+1,p);
		}
		printf("\n");
	}
	return 0;
}
```
这样就开心的AC了

---

## 作者：Itst (赞：6)

### 之前那位dalao用二分答案完美解决该题，然而
## 有二分答案的地方就有倍增！
### ~~再加上二分答案写炸~~所以就来交倍增题解
### 倍增思路与二分答案思路类似，但是对于答案接近两侧的数据倍增速度比二分答案略快
### 贴上倍增模板 & 思路：
### 1、初始化（本题中初始化k=0，q=1）
### 2、检测k+1-k+q范围内是否符合条件（人数是否为偶数）
### 3、如果符合条件，k+=q，q*=2，重复第二步，否则q/=2，若q>0重复第二步，否则跳至第四步
### 4、最后获得的k就是满足条件的最大值（然而这里找到的k是前面的所有人数和为偶数的最大值，+1后就是人数为奇数的地点）
### 当然如果原来的人数和就是偶数的话可以直接得出结论没有机会
### 接下来是亘古不变的上代码环节（？）
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
//快读避免输入造成的TLE
	int a = 0;
	char c = getchar();
	while(!isdigit(c))	c = getchar();
	while(isdigit(c))	a += (a << 3) + a + (c ^ '0') , c = getchar();
	return a;
}
int S[200001] , E[200001] , D[200001] , N;
inline int min(int a , int b){
	return a < b ? a : b;
}
inline bool check(int l , int r){
	//检验l+1~r范围内人数是否为偶数
    int sum = 0;
	for(int i = 0 ; i < N ; i++){
		if(r >= S[i])
			sum += (min(r , E[i]) - S[i]) / D[i] + 1;
		if(l >= S[i])
			sum -= (min(l , E[i]) - S[i]) / D[i] + 1;
	}
	return !(sum & 1);
}
int main(){
	for(int T = read() ; T ; T--){
		N = read();
		int sum = 0;
		int l = 0 , r = 0;
		for(int i = 0 ; i < N ; i++){
			S[i] = read();
			E[i] = read();
			D[i] = read();
			sum += (E[i] - S[i]) / D[i] + 1;
			r = max(r , E[i]);
		}
		if(sum & 1){
        //如果人数总和为奇数表示一定有一个点
			long long p = 1;
			while(p)
            //倍增核心
				if(l + p < r && check(l , l + p)){
					l += p;
					p <<= 1;
				}
				else	p >>= 1;
			printf("%d " , ++l);
			//记得l要+1
            int q = 0;
			for(int i = 0 ; i < N ; i++)
				if(E[i] >= l && l >= S[i] && (l - S[i]) % D[i] == 0)
					q++;
			printf("%d\n" , q);
		}
        //否则一定没有点
		else	printf("Poor QIN Teng:(\n");
	}
	return 0;
}
```

---

## 作者：wh2011 (赞：2)

这道题是一道二分题，但怎么二分是一个问题。

---

### 样例模拟

拿最后一个样例为例。

~~字丑勿喷~~

![QQ截图20231122210518.png](https://s2.loli.net/2023/11/22/wzfeRO5G8dho12C.png)

### 解题思路

在一串数中，只要里面有奇数个奇数，那么这串数之和就是奇数。根据题意，我们知道最多只有一个是奇数，那么我们就可以先找到小于等于 $x$ 的数轴上（也是等差数列）的数之和，那么每个等差数列就是 $\frac{min(e_i,x)-s_i}{d_i}+1$ 当 $s_i>x$ 时是 $0$。

可得此代码：

```cpp
ll check(int x) {
    ll sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i].s <= x) {
            sum += (min(a[i].e, x) - a[i].s) / a[i].d + 1;
        }
    }
    return sum;
}
```

接着就是二分了，设 $a$ 是最终答案，当 $a\le check(mid)$ 时那么答案肯定在右边所以 `r = mid`，当 $check(mid)<a$ 所以左边答案不可能存在直接抛弃所以 `l = mid + 1` 那么最终答案就求出来了。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 200010;
int n;
struct Node {
    int s, e, d;
} a[N];

ll check(int x) {
    ll sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i].s <= x) {
            sum += (min(a[i].e, x) - a[i].s) / a[i].d + 1;
        }
    }
    return sum;
}

void solve() {
    int l = 0, r = 0; scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d%d", &a[i].s, &a[i].e, &a[i].d);
        r = max(r, a[i].e);
    }
    while (l < r) {
        int mid = (ll)l + r >> 1;
        if (check(mid) & 1) r = mid;
        else l = mid + 1;
    }
    ll sum = check(l) - check(l - 1);
    if (sum & 1) printf("%d %lld\n", l, sum);
    else puts("Poor QIN Teng:(");
}

int main() {
    int T; scanf("%d", &T);
    while (T--)
        solve();
    return 0;
}
```

---

## 作者：islandl (赞：2)

# 解题思路
乍一看好像和二分无关，但我们考虑到奇偶数相加的一个性质。

**若干个偶数相加，中间出现一个奇数，则此后的前缀和都为奇数。**

那我们就可以二分出现奇数的位置,$sum[mid]$ 为奇数，说明前面已经出现奇数点；反之，继续向后寻找奇数。
# 具体实现
- 确定二分起始点:$s[i]$ 最小值，$e[i]$ 最大值。

- 前缀和最后仍为偶数，说明不存在奇数的情况。

- 计算前缀和时，终点在 min$(x,e[i])$，别忘了 $sum+1$，起点的那个人也要算。

- 注意长度范围在 $2^{31}-1$ 内，$l+r$ 会爆 int，要开 long long。
# 代码


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=200005;
ll s[N],e[N],d[N];
int n;
ll cal(ll x)
{
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		if(s[i]<=x)
		{   
			ll sum=(min(x,e[i])-s[i])/d[i]+1;
			ans+=sum;
		}
	}
	return ans;
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
		scanf("%d",&n);
		ll l=2147483647,r=0;
		for(int k=1;k<=n;k++)
		{
			scanf("%lld%lld%lld",&s[k],&e[k],&d[k]);
			r=max(r,e[k]);
			l=min(l,s[k]);
		}
		if(cal(r)%2==0) printf("Poor QIN Teng:(\n");
        else
        {
        	while(l!=r)
			{
				ll mid=(l+r)>>1;
				if(cal(mid)%2==1) r=mid;
				else l=mid+1;
			}
		  	ll num=cal(l)-cal(l-1);
		   	printf("%lld %lld\n",l,num);
        }
	}
	return 0;
}
```




---

## 作者：_Anonymous_ (赞：1)

# 题目大意

在一段区间内，有数段等差数列覆盖，求被覆盖奇数次的点，且被覆盖奇数次的点最多只有一个。

# 思路

### -1.暴力

暴力非常好想，每个点遍历一次，算出被覆盖次数。

但是题面中对 **奇偶性** 的要求可以想到前缀和的判断。

### 0.定义

假设目标点为 $x$，前缀和为 $sum_i$，所有等差数列覆盖到的最远点是 $mxr$，那么 $sum_1$ 到 $sum_{x-1}$ 均为偶数，而 $sum_x$ 到 $sum_{mxr}$ 均为奇数。

### 1.二分
既然单调，那就可以二分。如果 $sum_{mid}\equiv 1 \pmod 2$，那么答案肯定在 $[l,mid]$ 中，否则在 $(mid,r]$ 中。

```cpp
long long l = 1, r = mxr, mid;
while(l < r)
{
	mid = (l + r) >> 1;
	if(calc(mid) & 1)
	{
		r = mid;
	}
	else
	{
		l = mid + 1;
	}
}
```

### 2.前缀和处理

考虑到 $mxr$ 的范围是 $2^{31}-1$，无法预处理前缀和，可以在二分的时候临时 $O(n)$ 算。


```cpp
long long calc(const long long &x)
{
	long long ret = 0;
	for(int i = 1; i <= n; i++)
	{
		ret += (x >= sw[i].s ? (min(x, sw[i].e) - sw[i].s) / sw[i].d + 1 : 0);
		ret %= 2;
	}
	return ret;
}
```
此处
```cpp
(min(x, sw[i].e) - sw[i].s) / sw[i].d+1
```
需要算上起点，所以要 $+1$。
### 3.答案

结束时，答案应该在 $l$ 的位置，再扫一遍 $l$ 被覆盖几次即可。

```cpp
long long ans = l, cnt = 0;
for(int i = 1; i <= n; i++)
{
	if(ans >= sw[i].s && ans <= sw[i].e && (ans - sw[i].s) % sw[i].d == 0)
	{
		cnt++;	
	}
}
printf("%lld %lld\n", ans, cnt);
return ;
 ```
### 4.特判

记得特判一下不存在奇数点，也就是说 $sum_{mxr}$ 是偶数。

```cpp
if(calc(mxr) % 2 == 0)
{
	printf("Poor QIN Teng:(\n");
	return ;
}
```

# 完整代码

```cpp
#include<bits/stdc++.h>
#define debug cout << "OK" << endl;
#define MAXN 2*int(1e5 + 10)
#define MAXM int(1e6 + 10)
using namespace std;

struct node
{
	long long s, e, d;
}sw[MAXN];
int n;

long long calc(const long long &x)
{
	long long ret = 0;
	for(int i = 1; i <= n; i++)
	{
		ret += (x >= sw[i].s ? (min(x, sw[i].e) - sw[i].s) / sw[i].d + 1 : 0);
		ret %= 2;
	}
	return ret;
}

void solve()
{
	cin >> n;
	long long mxr = 0;
	for(int i = 1; i <= n; i++)
	{
		scanf("%lld %lld %lld", &sw[i].s, &sw[i].e, &sw[i].d);
		mxr = max(mxr, sw[i].e);//找最远的点
	}
	if(calc(mxr) % 2 == 0)//答案不存在
	{
		printf("Poor QIN Teng:(\n");
		return ;
	}
	long long l = 1, r = mxr, mid;
	while(l < r)
	{
		mid = (l + r) >> 1;
//		cout << mid << endl;
		if(calc(mid) & 1)
		{
			r = mid;
//			cout << ' ' << calc(mid) << endl;
		}
		else
		{
			l = mid + 1;
		}
	}
	long long ans = l, cnt = 0;
	for(int i = 1; i <= n; i++)
	{
		if(ans >= sw[i].s && ans <= sw[i].e && (ans - sw[i].s) % sw[i].d == 0)
		{
			cnt++;	
		}
	}
	printf("%lld %lld\n", ans, cnt);
	return ;
}

int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		solve();	
	}
 	return 0;
}
```

---

## 作者：Thunder_S (赞：1)

[可能比较优秀的阅读体验](https://www.cnblogs.com/Livingston/p/15125942.html)
## Solution

注意到题目中的关键信息：

- 即使由于安排不慎重出现了这样的位置，最多也仅有一个。

这就说明如果用前缀和记录当前位置之前的总人数时，在有奇数的情况下，一定是从那个位置开始之后全是奇数。

想到这里，二分也就应运而生了。

首先先判断是否有解。如果所有位置的总人数是偶数就没有解。

然后二分出奇数所在位置，具体操作可以求出当前位置及之前的人数。

那么 check 函数该怎么写呢？

可以枚举每组评估团，求出该位置之前的这组评估团的人数，求和即可。

```cpp
bool check(ll x)
{
	int sum=0;
	for (int i=1;i<=n;++i)
	{
		if (x<s[i]) continue;
		sum+=(min(x,e[i])-s[i])/d[i]+1;
	}
	if (sum%2==0) return false;
	else return true;
}
```

确定好了位置之后，可以 $O(n)$ 扫一遍求出人数。

## 完整Code

```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define N 200005
using namespace std;
int n,t;
ll res,ans,mx,num,l,r,s[N],e[N],d[N];
bool check(ll x)
{
	int sum=0;
	for (int i=1;i<=n;++i)
	{
		if (x<s[i]) continue;
		sum+=(min(x,e[i])-s[i])/d[i]+1;
	}
	if (sum%2==0) return false;
	else return true;
}
int main()
{
	scanf("%d",&t);
	while (t--)
	{
		mx=num=0;
		scanf("%d",&n);
		for (int i=1;i<=n;++i)
		{
			scanf("%lld%lld%lld",&s[i],&e[i],&d[i]);
			num+=(e[i]-s[i])/d[i]+1;mx=max(mx,e[i]);
		}
		if (num%2==0)
		{
			printf("Poor QIN Teng:(\n");
			continue;
		}
		res=l=0;r=mx;
		while (l<=r)
		{
			ll mid=(l+r)>>1;
			if (check(mid)) res=mid,r=mid-1;
			else l=mid+1;
		}
		ans=0;
		for (int i=1;i<=n;++i)
		{
			if (res<s[i]||res>e[i]) continue;
			if ((res-s[i])%d[i]==0) ++ans;
		}
		printf("%lld %lld\n",res,ans);
	} 
	return 0;
} 
```



---

## 作者：SmallTownKid (赞：1)

classic的一道二分题，这个二分利用到了奇数偶数的性质和前缀和。

注意到此题 $N ≤ 200000$ 显然 $O(n^2)$ 的做法是不可行的，考虑 $O(nlogn)$。

由于题目要求我们找到唯一的一个个数为奇数的点。那我们可以很自然地想到使用二分查找。不过这个 check 函数怎么写呢？

此题有一个很重要的条件，如果有解的话，只有一个点的成员数是奇数，其他都是偶数。我们可以往奇数和偶数的关系上思考，奇数+偶数=奇数。偶数+偶数=偶数。
所以我们可以维护一个前缀和。如果这一段和为奇数，那么要求的点肯定在这段区间内。由于 $S,E,D$ 有等差数列的关系，所以不用一个个加，直接用公式算出来这一段的和。check 函数判断 $l,mid$ 这个区间的和是奇数还是偶数就可以了。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
const int INF=0x3f3f3f3f;
int T,n;
struct node{
	int s,e,d;
}a[200010];
int get_sum(int x)
{
	int res=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i].s<=x)
		{
			res+=(min(a[i].e,x)-a[i].s)/a[i].d+1;
		}
	}
	return res;
}
bool check(int l,int r)//O(n)查找l到r之间有没有奇数位 
{
	return (get_sum(r)-get_sum(l-1))%2;
}
signed main()
{
	scanf("%lld",&T);
	while(T--)
	{
		int l=INF,r=-INF;
		scanf("%lld",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%lld%lld%lld",&a[i].s,&a[i].e,&a[i].d);
			l=min(l,a[i].s);
			r=max(r,a[i].e);
		}
		if(get_sum(r)%2==0)
		{
			printf("Poor QIN Teng:(\n");
			continue;
		}
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(l,mid))
			r=mid-1;
			else l=mid+1;
		}
		printf("%lld %lld\n",l,get_sum(l)-get_sum(l-1));
	}
	return 0;
}
```

---

## 作者：cellur925 (赞：1)

[题目传送门](https://www.luogu.org/problemnew/show/P4403)

二分答案，个人感觉其实并不只适用于有明显的“最大值最小/最小值最大”条件的题目，其实也可以称它为一种“优化的暴力”。这题就是最好的例子。

我们肯定可以先想出朴素的算法：把每个点的答案都算出，但是平方级别的复杂度，铁定超时。

我们考虑用二分优化。这道题的二分其实挺难看出的：因为题目约束奇数人数的点要有也只有一个，也就是说其他有人的点上人数一定为偶数。显然偶数+偶数=偶数，如果没有奇数出现，那么统计的人数和都是偶数。

我们可以从这个性质出发。二分位置$i$，但是二分的不是最终的结果而是一个约束的范围。再具体地说，如果$[1,mid]$中的人数是奇数那么答案肯定在这个区间中，使$r=mid$，否则在右边的区间，即使$l=mid+1$。

因此我们只要统计人数就行了==。

本人代码写的十分糟糕，大家可以看@钟梓俊 dalao的优秀代码233.

---

## 作者：0x3F (赞：0)

首先，由“最多只有一个奇数”的条件可以得到：

如果一段区间内的人数和为奇数，那么该区间内有一个奇数。

如果一段区间内的人数和为偶数，那么该区间内全部为偶数。

发现一段区间内的人数可以 $\mathcal{O}(n)$ 求。于是可以二分查找。

时间复杂度 $\mathcal{O}(Tn\log\mid S\mid)$，其中 $S$ 为值域。

题外话：发现大家都写的前缀和。我的太丑了。

代码如下：

```cpp
#include <cstdio>
#define _ 200010
int T, n, c;
long long L, M, R, s[_], e[_], d[_];
bool f;
inline long long max(long long a, long long b) {
	return a>b?a:b;
}
inline long long min(long long a, long long b) {
	return a<b?a:b;
}
int main() {
	scanf("%d", &T);
	while (T--) {
		f = 0;
		scanf("%d", &n);
		for (int i = 1; i <= n; i++) {
			scanf("%lld%lld%lld", s+i, e+i, d+i);
			f ^= (((e[i] - s[i]) / d[i] + 1ll) & 1ll);
		}
		if (!f) {
			printf("Poor QIN Teng:(\n");
		} else {
			L = 0ll;
			R = 0x7FFFFFFFll;
			while (L < R) {
				M = ((L + R) >> 1);
				f = 0;
				for (int i = 1; i <= n; i++) {
					if (L <= e[i] && M >= s[i]) f ^= (((min(e[i], M) - s[i]) / d[i] - max(L - s[i] - 1, 0ll) / d[i] + (L <= s[i])) & 1ll);
				}
				if (f) R = M;
				else L = M + 1;
			}
			c = 0;
			for (int i = 1; i <= n; i++) {
				c += (L >= s[i] && L <= e[i] && !((L - s[i]) % d[i]));
			}
			printf("%lld %d\n", L, c);
		}
	}
}
```


---

## 作者：Link_Space (赞：0)

由于只有一个满足题目条件的点，可以通过二分来找出这个点，为什么这个可以二分呢？对于一个 $1 \Longrightarrow i$ 的区间，如果区间内的教学评估团成员为奇数的话，那么满足题目条件的那个点就一定在这个区间内，如果不为奇数，那么一定在这个区间的右边，所以可以通过二分来找到这个点。

那么如何写二分判断函数呢？直接 $\Theta(N)$ 枚举每个区间，求出每个区间与二分到的 $1 \Longrightarrow i$ 的这个区间所交的成员数之和，如果和为奇数则答案在区间里，否则找右边。

以下是代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int s[N], e[N], d[N];
int n;
bool check(int pos)
{
    int sum = 0;
    for (int i = 1; i <= n;i++)
    {
        if(s[i]>pos)
            continue;
        sum += (min(pos, e[i]) - s[i]) / d[i] + 1;
    }
    return (sum % 2);
}
signed main()
{
    int T;
    scanf("%lld", &T);
    while(T--)
    {
        scanf("%lld", &n);
        int l = 0, r = 0;
        for (int i = 1; i <= n;i++)
            scanf("%lld%lld%lld", &s[i], &e[i], &d[i]), r = max(r, e[i]);
        if(!check(r))
        {
            puts("Poor QIN Teng:(");
            continue;
        }
        int pos;
        while(l<=r)
        {
            int mid = l + r >> 1;
            if(check(mid))
                r = mid - 1, pos = mid;
            else
                l = mid + 1;
        }
        int cnt = 0;
        for (int i = 1; i <= n;i++)
        {
            if(s[i]>pos||e[i]<pos)
                continue;
            if((pos-s[i])%d[i]==0)
                cnt++;
        }
        printf("%lld %lld\n", pos, cnt);
    }
}
```



---

## 作者：冷笑叹秋萧 (赞：0)

# [BJWC2008]秦腾与教学评估
## 题意
给定三个参数，表示一段区间内隔若干个位置有一个评估团成员，要求唯一评估团成员个数为奇数的位置。
## 题解
这道题是一个非常经典的二分题，我们考虑二分有奇数个评估团成员的位置。

又因为这个位置是唯一的，就给了我们一个很好的突破口。

首先我们知道一个很基础的数学公式：偶数 + 偶数 = 偶数，偶数 + 奇数 = 奇数。

所以我们 $pd()$ 函数中只需要统计出从 $1\sim mid$ 的位置一共有多少个评估团成员，然后判断奇偶性即可。

当然算当前位置的评估团成员个数就用类似前缀和相减的方法就行了。
## CODE
```cpp
#include<cstdio>
#include<string>
#define R register ll
#define N 200005
#define ll long long
#define inf 0x3f3f3f3f
using namespace std;
ll t,n,s[N],e[N],d[N];
ll max(ll a,ll b) {return a>b?a:b;}
ll min(ll a,ll b) {return a<b?a:b;}
void read(ll &x)
{
	x=0;ll f=1;char ch=getchar();
	while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();x*=f;
}
bool pd(ll k)
{
	ll tot=0;
	for (R i=1;i<=n;++i)
		if (s[i]<=k) tot+=(min(k,e[i])-s[i])/d[i]+1;
	if (tot&1) return 1;return 0;
}
int main()
{
	read(t);
	while (t--)
	{
		read(n);
		for (R i=1;i<=n;++i)
			read(s[i]),read(e[i]),read(d[i]);
		ll l=1,r=3000000000,tot1=0,tot2=0,ans,ans1;
		while (l<=r)
		{
			ll mid=l+r>>1;
			if (pd(mid)) r=mid-1,ans=mid;else l=mid+1;
		}
		for (R i=1;i<=n;++i)
			if (s[i]<=ans) tot1+=(min(ans,e[i])-s[i])/d[i]+1;
		for (R i=1;i<=n;++i)
			if (s[i]<ans) tot2+=(min(ans-1,e[i])-s[i])/d[i]+1;
		ans1=tot1-tot2;if (ans1&1) printf("%d %d\n",ans,ans1);else printf("Poor QIN Teng:(\n");
	}
 	return 0;
}


---

## 作者：西卡洛斯 (赞：0)

题目大意：对一段区间进行多次覆盖，询问被覆盖奇数次的点（也可能不存在）及覆盖的次数。

根据题意，这个奇数点**如果有就仅有**一个，那么其余点一定为偶数，由于奇数+奇数=偶数，可以考虑维护区间前缀和求解。如果某段区间前缀和为奇数，那么所求点一定在这段区间内，利用二分答案求解即可。

[code :)](https://www.luogu.com.cn/paste/faicmzco)

---


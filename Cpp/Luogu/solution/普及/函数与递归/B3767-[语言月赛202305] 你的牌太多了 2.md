# [语言月赛202305] 你的牌太多了 2

## 题目背景

相信你对笨蛋扶苏和坏蛋小 F 打牌的[故事](https://www.luogu.com.cn/problem/B3745)记忆犹新。这次，她们又在打一种很新的牌。

## 题目描述

初始时，扶苏和小 F 手中各有 $n$ 张牌。每张牌有一个花色 $f$ 和一个点数 $p$。在本题中，花色是不超过 $m$ 的正整数，点数是不超过 $r$ 的正整数。

我们定义『一轮出牌』是指从某人开始出牌，双方轮流按规则打出手中的手牌，直到一方打不出符合要求的手牌结束。

在一轮出牌中，第一个出牌的人会打出**点数最小**的那张手牌。如果有多张手牌点数最小，则打出**点数最小且花色最小的那张手牌**。然后双方轮流出牌，规则是打出手中**花色与对方刚才打出的牌相同且点数大于对方的刚才打出的牌的点数中，点数最小的那张牌**。如果这样的牌不存在，那么本轮游戏结束，且下一轮由**对方**先出牌（即，本轮最后一手出牌的人下一轮先出）。

现在，给出双方的手牌和第一轮出牌的人，请你求出谁先打完手里的牌。

## 说明/提示

## 数据规模与约定

- 对于 $10\%$ 的数据，$r = 1$；
- 对于 $20\%$ 的数据，$n = 1$；
- 对于 $50\%$ 的数据，$m = 1$；
- 对于 $100\%$ 的数据，$1 \leq T \leq 10$，$1 \leq n,m,r \leq 100$，$1 \leq s \leq 2$，$1 \leq f1_i, f2_i \leq m$，$1 \leq p1_i, p2_i \leq r$。

## 样例 #1

### 输入

```
1
3 1 2 1
1 1 1
1 2 1
1 1 1
2 2 1```

### 输出

```
FS wins!```

## 样例 #2

### 输入

```
1
3 1 2 2
1 1 1
1 2 1
1 1 1
2 2 1```

### 输出

```
FR wins!```

# 题解

## 作者：一扶苏一 (赞：12)

# [语言月赛202305F] 你的牌太多了 2 题解

## Source & Knowledge

2023 年 5 月语言月赛，由洛谷网校入门计划/基础计划提供。

本题考查循环、数组、函数。

## 文字题解

### 解析

依据题意模拟即可。

首先可以完成 [B3745](https://www.luogu.com.cn/problem/B3745)，我们的基本处理方法与之类似，这里也不再赘述 B3745 题解中出现的变量。

本题的一个难点在于，游戏进行的轮数和每轮游戏的回合数都是不确定的。对于不定长的循环，我们一般用 `while` 循环来处理。

定义函数 `round(x)` 表示当先手为 $x$ 时，一轮游戏后下一轮先出牌的人，`cnt[0]` 表示扶苏的手牌数，`cnt[1]` 表示小 F 的手牌数。那么，当两人手牌数均不为 $0$ 时，游戏将持续进行。我们采用这样的循环来控制游戏轮数：

```cpp
while (cnt[0] && cnt[1]) {
  s = round(s);
}
```

为了便于处理，我们给读入的 $s$ 减去 $1$。即 $s = 0$ 表示扶苏先出，$s = 1$ 表示小 F 先出。

接下来，我们处理每轮游戏的具体情况：

```cpp
int round(int st) {
  //...
}
```

首先找到第一个出牌的人所处的牌，用打擂台的方法：

```cpp
int id = 1;
while (vis[st][id] == true) ++id;
for (int i = id + 1; i <= n; ++i) if (vis[st][i] == false) {
  if ((p[st][i] < p[st][id]) || ((p[st][i] == p[st][id]) && (f[st][i] < f[st][id]))) {
    id = i;
  }
}
```

此时需要判断打出这张牌后是否有一方直接胜利：

```cpp
--cnt[st];
if (cnt[st] == 0) return st;
```

此外别忘了标记这张牌已被打出。

我们用 `plst` 和 `flst` 表示上一张牌的点数和花色。初始时显然有 `int plst = p[st][id], flst = f[st][id];`。

接下来，我们同样用一个 while 循环来处理每轮游戏的所有回合：

```cpp
while((id = nextcard(st, flst, plst)) != -1) {
  // do sth
}
```

在这里，`nextcard` 是在给出上一张牌的点数和花色、本轮出牌的人以后，返回这次出牌的人所出牌的下标的函数。如果没牌可出，返回 `-1`，此时这一轮结束，while 循环终止。

`nextcard` 函数的实现如下：

```cpp
int nextcard(int st, int flst, int plst) {
  int ret = -1;
  for (int i = 1; i <= n; ++i) if (vis[st][i] == false) {
    if (f[st][i] != flst) continue;
    if (p[st][i] <= plst) continue;
    if (ret == -1) ret = i;
    else {
      if (p[st][i] < p[st][ret]) ret = i;
    }
  }
  return ret;
}
```

此外，由于实现比较复杂，我们给出 `round` 函数的内容，用作参考

```cpp
int round(int st) {
  int id = 1;
  while (vis[st][id] == true) ++id;
  for (int i = id + 1; i <= n; ++i) if (vis[st][i] == false) {
    if ((p[st][i] < p[st][id]) || ((p[st][i] == p[st][id]) && (f[st][i] < f[st][id]))) {
      id = i;
    }
  }
  int plst = p[st][id], flst = f[st][id];
  vis[st][id] = true; --cnt[st];
  if (cnt[st] == 0) return st;
  st = 1 - st;
  while ((id = nextcard(st, flst, plst)) != -1) {
    plst = p[st][id];
    vis[st][id] = true;
    --cnt[st];
    if (cnt[st] == 0) return st;
    st = 1 - st;
  }
  return 1 - st;
}
```

最后，看一下游戏结束时最后一轮游戏的函数返回值，就能判定谁获得了胜利：

```cpp
if (s == 1) {
  cout << "FR wins!\n";
} else {
  cout << "FS wins!\n";
}
```

## 视频题解

![](bilibili:BV1kM4y1t7K5?page=6)

---


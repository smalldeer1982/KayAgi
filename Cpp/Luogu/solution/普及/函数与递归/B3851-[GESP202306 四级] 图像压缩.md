# [GESP202306 四级] 图像压缩

## 题目描述

图像是由很多的像素点组成的。如果用 $0$ 表示黑，$255$ 表示白，$0$ 和 $255$ 之间的值代表不同程度的灰色，则可以用一个字节表达一个像素（取值范围为十进制 `0-255`、十六进制 `00-FF`）。这样的像素组成的图像，称为 $256$ 级灰阶的灰度图像。

现在希望将 $256$ 级灰阶的灰度图像压缩为 $16$ 级灰阶，即每个像素的取值范围为十进制 `0-15`、十六进制 `0-F`。压缩规则为：统计出每种灰阶的数量，取数量最多的前 $16$ 种灰阶（如某种灰阶的数量与另外一种灰阶的数量相同，则以灰阶值从小到大为序），分别编号 `0-F`（最多的编号为 `0`，以此类推）。其他灰阶转换到最近的 $16$ 种灰阶之一，将某个点的灰阶值（灰度，而非次数）与 $16$ 种灰阶中的一种相减，绝对值最小即为最近，如果绝对值相等，则编号较小的灰阶更近。

## 说明/提示

【样例 $1$ 解释】

灰阶 `AB`、`CF` 和 `FF` 出现 $14$ 次，`00` 出现 $10$ 次，`CB` 出现
$9$ 次，`09` 出现 $7$ 次，`AC` 出现 $6$ 次，`07` 出现 $5$ 次，`10`、`11`
和 `98` 出现 $4$ 次，`01`、`1B`、`67`、`76` 和 `FC` 出现 $3$ 次。

## 样例 #1

### 输入

```
10
00FFCFAB00FFAC09071B5CCFAB76
00AFCBAB11FFAB09981D34CFAF56
01BFCEAB00FFAC0907F25FCFBA65
10FBCBAB11FFAB09981DF4CFCA67
00FFCBFB00FFAC0907A25CCFFC76
00FFCBAB1CFFCB09FC1AC4CFCF67
01FCCBAB00FFAC0F071A54CFBA65
10EFCBAB11FFAB09981B34CFCF67
01FFCBAB00FFAC0F071054CFAC76
1000CBAB11FFAB0A981B84CFCF66```

### 输出

```
ABCFFF00CB09AC07101198011B6776FC
321032657CD10E
36409205ACC16D
B41032657FD16D
8F409205ACF14D
324F326570D1FE
3240C245FC411D
BF4032687CD16D
8F409205ACC11D
B240326878D16E
83409205ACE11D```

# 题解

## 作者：ZsH68122zSh (赞：26)

# 图像压缩题解
[题目传送门](https://www.luogu.com.cn/problem/B3851)  
这道题就是一个纯纯的**模拟**，挺费手的 ~~问题也不是不很大~~

------------

## 1.解题思路
1. 遍历所输入的字符数组记录每个 16 进制灰度出现的次数，然后快排，找出出现次数前 16 的灰度值
2. 输出前 16 个 16 进制灰度值，并且标记
3. 再次遍历所输入的字符数组，判断每一个 16 进制灰度（是否标记）,  
如果是前 16 个灰度值就直接输出，  
否则遍历前 16 个灰度值，转换为 10 进制，查找最接近的  
并输出

------------
## 2.代码方面

1. 用**结构体**来记录每个灰度值的信息：**16进制灰度值**和**出现的次数**
2. 用 stl 库里的 pair 来记录**每个16进制灰度值**（刚好两个字符）
3. 用 stl 库里的 map 来标记灰度的十六进制编号和十进制灰度值

------------
## 3.代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char s[30][30];
struct grey{//灰度
	pair<char,char> cl; 
	int cnt;
}gr[256];//十六进制：00 ~ FF => 十进制: 0 ~ 255（下标） 
map< pair<char,char> ,bool> bct;//是不是前十六个灰度 
map< pair<char,char> , pair<char,int> > mp;//灰度的十六进制编号和十进制灰度值 
void InitGrey(){//初始化数组 
	for(int i=0;i<256;i++) gr[i].cnt=0; 
	return;
}
int st_t(pair<char,char> st){//十六进制转十进制 
	int s1=st.first>='0'&&st.first<='9' ? st.first-'0' : st.first-'A'+10; 
	int g1=st.second>='0'&&st.second<='9' ? st.second-'0' : st.second-'A'+10; 
	return s1*16+g1; 
}
char t_st(int t){//十进制转十六进制 
	return t<10 ? t+'0' : t-10+'A';
} 
bool cmp(grey cmp1,grey cmp2){//结构体 sort快排                                 
	return cmp1.cnt==cmp2.cnt ? st_t(cmp1.cl)<st_t(cmp2.cl) : cmp1.cnt>cmp2.cnt;
}
int main()
{
	scanf("%d",&n);
	InitGrey();//初始化 
	for(int i=0;i<n;i++){
		scanf("%s",s[i]);
		for(int j=0;j<strlen(s[i]);j+=2){
			pair<char,char> gr16=make_pair(s[i][j],s[i][j+1]);//16进制灰度值 
			int gr10=st_t(gr16);//10进制灰度值
			gr[gr10].cl=gr16;
			gr[gr10].cnt++;
		}
	}
	sort(gr,gr+256,cmp);//快排 
	for(int i=0;i<16;i++){
		printf("%c%c",gr[i].cl.first,gr[i].cl.second);//输出前 16 个16进制灰度值 
		char ch=t_st(i);//十六进制编号 
		mp[gr[i].cl]=make_pair(ch,st_t(gr[i].cl));//标记前十六个灰度的六进制编号和十进制灰度值 
		bct[gr[i].cl]=true;//标记前十六个灰度 
	}
	for(int i=0;i<n;i++){
		printf("\n");
		for(int j=0;j<strlen(s[i]);j+=2){
			pair<char,char> str=make_pair(s[i][j],s[i][j+1]);
			if(bct[str]) printf("%c",mp[str].first);//是前 16 就直接输出 
			else{//不是前 16 
				int t1=st_t(str),d_min=260;
				char ch;
				for(int k=0;k<16;k++){//遍历前 16 个查找 
					int d=abs(st_t(gr[k].cl)-t1);
					if(d<d_min) d_min=d,ch=t_st(k);
				}
				printf("%c",ch);
			}
		}
	}
	return 0;//完结撒花 
} 
```

---

## 作者：fulichang (赞：16)

###### 蒟蒻的第一篇题解。

~~恶心的~~大模拟，就是考各种细节，作为六月份考生之一，我深受其害。

## 思路：
直接把所有像素的灰度算出来，再用个结构体统计每个灰度的出现数量，和灰度一起排序 and 编号，注意优先级。

然后遍历所有像素，并且计算压缩后的灰度，注意编号要用结构体排序后的，以及优先级。

最后输出。


------------


代码本身其实比较简单，但是就是会被各种细节卡到 wa。下面我总结一下我犯的各种细节问题。

1. 字符串长度不是 $n$，是不定长的（我被这个卡了好久）。
1. 读字符串和用字符串的各种小问题，比如读换行符。

最后，代码附上。
```cpp
//from.luogu B3851 by.flic 24-3-5
//https://www.luogu.com.cn/problem/B3851

#include <bits/stdc++.h>

const int N = 30;

struct node {
	int tot, g;
	friend bool operator < (node a, node b) {
		return a.tot != b.tot ? a.tot > b.tot : a.g < b.g;
	}
};

int n;
node p[300];
std::vector<std::pair<int, char>>mm;
int pic[100][100];

int main (void) {
	std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);
	std::cin >> n;
	int m = n;
	int len;
	for (int i = 1; i <= n; i++) {
		std::string s;
		std::cin >> s;
		len = s.size();
		for (int j = 0; j < s.size(); j += 2) {
			int cnt = (s[j] > '9' ? s[j] - 'A' + 10 : s[j] - '0') * 16 + (s[j + 1] > '9' ? s[j + 1] - 'A' + 10 : s[j + 1] - '0');
			p[cnt].tot++, p[cnt].g = cnt;
			pic[i][j / 2 + 1] = cnt;
		}
	}
	std::sort(p, p + 299);
	for (int i = 0; i < 16; i++)
		std::cout << char(p[i].g / 16 > 9 ? p[i].g / 16 - 10 + 'A' : p[i].g / 16 + '0') << char(
		              p[i].g % 16 > 9 ? p[i].g % 16 - 10 + 'A' : p[i].g % 16 + '0');
	std::cout << std::endl;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= len / 2; j++) {
			int mina = 300;
			char c;
			for (int k = 0; k < 16; k++)
				if (std::abs(p[k].g - pic[i][j]) < mina)
					mina = std::abs(p[k].g - pic[i][j]), c = (k > 9 ? k - 10 + 'A' : k + '0');
			std::cout << c;
		}
		std::cout << std::endl;
	}
	return 0;
}
```
~~管理大大求过~~。

---

## 作者：sillation (赞：14)

### 图像压缩题解
#### [题目传送门](https://www.luogu.com.cn/problem/B3851)


------------
我的做法：纯模拟
#### 思路：
用一个结构体去存储 $256$ 级灰阶的出现次数，其十进制的数值，它的十六进制。
- 我们先用一个二维字符串去输入，因为输入是没有空格且可能会有字符。
- 在输入的同时算出将其中的十六进制转为十进制，次数加一。
- 然后用 `sort` 排序，次数多的放前面，并输出前十六个（输出用十六进制，后不加空格）。
- 如果不是前十六个，则通过打擂台的方法找出最近的（相减时记得用绝对值）。



------------

#### 代码方面：
- 可以用一个来记录整型的二维数组把每个位子上的十进制，后期方便输出。
- 在输出前十六个的时候，记得输出其十六进制。
- 输出压缩后的图像时每行长度的是输入时的一半，不是 $n$。
- 注意排序要求。


------------

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sp[100][100];
string a[20],x;
char tt[]= {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
struct sz {
	int t,z;
	string s;
	char xx;
} p[10000];
void zhuan(string x,int j,int i) {
	int sum=0;
	if(x[1]<='9'&&x[1]>='0') sum+=(x[1]-'0')*1;
	else sum+=(x[1]-'A'+10)*1;
	if(x[0]<='9'&&x[0]>='0') sum+=(x[0]-'0')*16;
	else sum+=(x[0]-'A'+10)*16;
	p[sum].t ++;//次数加一 
	p[sum].s =x;//保留其十六进制，注意是字符串 
	sp[i][j]=sum;//保留它的十进制，方便输出 
}
bool cmp(sz a,sz b) {//注意判断 
	if(a.t !=b.t) return a.t >b.t;
	else return a.z<b.z;
}
int main() {
	cin>>n;
	for(int i=0; i<=256; i++) p[i].z=i,p[i].t=0;//初始化 
	for(int i=0; i<n; i++) {
		cin>>a[i];
		for(int j=0; j<a[i].size(); j+=2) {
			x+=a[i][j],x+=a[i][j+1];
			zhuan(x,j/2,i);
			x="";
		}
	}
	sort(p,p+256,cmp);
	for(int i=0; i<16; i++) {
		cout<<p[i].s;
		p[i].xx=tt[i];
	}
	cout<<endl;
	for(int i=0; i<n; i++) {
		for(int j=0; j<a[i].size()/2; j++) {
				int mm=300,wz;
				for(int q=0; q<16; q++) {
					if(abs(sp[i][j]-p[q].z)<mm) wz=q,mm=abs(sp[i][j]-p[q].z);
				}
				cout<<p[wz].xx;
		}
		cout<<endl;
	}
	return 0;
}


```
代码风格不太好请见谅。

---

## 作者：tianyk (赞：10)

这题其实不难，就是有点麻烦。


------------

## 题目大意
给一副 256 级灰阶的灰度图像，每两个字符用十六进制表示一个像素。统计出每种灰阶的数量，取数量最多的前 16 种灰阶（如某种灰阶的数量与另外一种灰阶的数量相同，则以灰阶值从小到大为序）分别编号 0-F（最多的编号为 0）。其余灰阶转换到最近的 16 种灰阶之一，方法是将灰阶值（灰度，而非次数）与 16 种灰阶中的一种相减，绝对值最小即为最近（如果绝对值相等，则编号较小的灰阶更近）。注意是编号较小的灰阶更近，我以为灰阶值较小的灰阶更近 60pts 卡了好久。 

## 做法
1. 将所有灰阶用 map 统计数量，把灰阶值和数量放到结构体里，以数量为第一关键字，灰阶值为第二关键字排序，排序后的前 16 种灰阶即为压缩后的灰阶值。
1. 遍历所有灰阶，将它们的灰阶值转换成十进制记为 $num1$，将排序后的前 16 种灰阶的灰阶值换成十进制记为 $num2$，求 $num1-num2$ 的绝对值，并取最小值。记录下与每个 $num1$ 最接近（绝对值最小）的 $num2$ 对应的 $id$（即压缩后的灰阶值编号），最后将 $id$ 转换成十六进制即可。

## code

```
#include <bits/stdc++.h>
using namespace std;
const int N = 300;

struct node {
	int num;
	string s;
} sj[N];

bool cmp(node n1, node n2) {
	if (n1.num != n2.num)
		return n1.num > n2.num;
	return n1.s < n2.s;
}
string Map[N][N], Map2[N];
char ans[N][N];
map<string, int>mp;

int abss(string s1, string s2) {//求绝对值
	int num1 = 0, num2 = 0;
	if (s1[0] >= '0' && s1[0] <= '9')
		num1 += (s1[0] - 48) * 16;
	else
		num1 += (s1[0] - 55) * 16;
	if (s1[1] >= '0' && s1[1] <= '9')
		num1 += (s1[1] - 48);
	else
		num1 += (s1[1] - 55) ;
	if (s2[0] >= '0' && s2[0] <= '9')
		num2 += (s2[0] - 48) * 16;
	else
		num2 += (s2[0] - 55) * 16;
	if (s2[1] >= '0' && s2[1] <= '9')
		num2 += (s2[1] - 48);
	else
		num2 += (s2[1] - 55);
	return abs(num1 - num2);
}

int main() {
	int n, cnt = 0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		cin >> Map2[i];
	int tot = Map2[1].size();
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= (tot >> 1); j ++) {
			string ss = "";
			ss += Map2[i][(j - 1) << 1], ss += Map2[i][(j - 1) << 1 | 1];
			mp[ss]++;
			Map[i][j] = ss;
		}
	}
	for (auto x : mp) {
		sj[++cnt].s = x.first;
		sj[cnt].num = x.second;
	}
	sort(sj + 1, sj + cnt + 1, cmp);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= (tot >> 1); j++) {
			string res;
			int minn = INT_MAX, id;
			for (int c = 1; c <= 16; c++) {
				int tmp = abss(Map[i][j], sj[c].s);
				if (tmp < minn) {
					minn = tmp;
					res = sj[c].s;
					id = c;
				}
			}
			id--;//题目要求灰阶值从00开始
			if (id < 10)
				ans[i][j] = char(id + 48);
			else
				ans[i][j] = char(id + 55);
		}
	}
	for (int i = 1; i <= 16; i++)
		cout << sj[i].s;
	puts("");
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= (tot >> 1); j++)
			cout << ans[i][j];
		puts("");
	}
	return 0;
}
```

---

## 作者：Voltaris (赞：10)

【题目大意】
先根据输入将输入的十六进制两两成对转换为十进制 0~255 之间的数，再取出现次数较多的前 16 个数作为标准 “ 灰阶 ” ，将其他的数根据与标准 “ 灰阶 ”作差的绝对值大小就近转换为对应 “ 灰阶 ” ，最后再将灰阶转换为 16 进制输出。
  
【解题思路】
1. 模拟题，我们按照题目的要求进行模拟即可，首先将数据输入，并把 16 进 制转换为 10 进制。
2. 接着我们找出出现次数最多的 16 种灰阶，并给它们编号为 0-F 。
3. 然后遍历所有的灰阶，找出距离它们各自最近的 16 种灰阶之一。
4. 先输出出现次数最多的 16 种灰阶，记得转换为 16 进制，再输出压缩后的图像，即所有的灰阶都输出距离它们各自最近的 16 种灰阶之一。
   
【考纲知识点】多层循环（二级），模拟法 ( 三级 ) ，函数的定义与调用（四级）
  
【参考程序】
```cpp
#include <bits/stdc++.h>
#include <cstring>
using namespace std;
int a[25][25];//保存输入数据
struct Node{//不同灰度的数量
    int hd;//灰度
    int sl;//数量
}c[300];
//十六进制转10进制
int toint(char c){
    if (c>='A'&&c<='F'){
        return c-'A'+10;
    }
    return c-'0';
}
//将10进制打印为16进制
void printHx(int x){
    char c;
    if (x>9){
        c='A'+x-10;
    }else{
        c=x+'0';
    }
    cout<<c;
}
//按出现的数量从大到小排序，数量相同，灰度小的排前边
bool cmp(Node x,Node y){
    if (x.sl==y.sl) return x.hd<y.hd;
    return x.sl>y.sl;
}
int main() {
    int n;
    cin>>n;
    string s;
    for (int i=1;i<=n;i++){
        cin>>s;
        int t;
        //16进制转换为10进制保存到数组中
        for (int j = 0; j < s.size(); j += 2) {
            t = toint(s[j]) * 16 + toint(s[j + 1]);
            a[i][j / 2 + 1] = t;
            c[t].sl++;  //标记灰度值为t出现的次数 
        }
    }
    for (int i=1;i<=255;i++){//初始化灰度值
        c[i].hd=i;
    }
    sort(c,c+256,cmp);//排序
    for (int i=0;i<16;i++){//打印排名前16
        printHx(c[i].hd/16);
        printHx(c[i].hd%16);
    }
    cout<<endl;
    int len=s.length()/2;
    for (int i=1;i<=n;i++){//找到每个像素点的最近值
        for (int j=1;j<=len;j++){
            int minn=256;
            int p=0;
            for (int k=0;k<=15;k++){
                if (abs(c[k].hd-a[i][j])<minn){
                    minn=abs(c[k].hd-a[i][j]);
                    p=k;  //记录编号 
                }
            }
            printHx(p);//打印与其最近的灰度值编号的16进制 
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：SJH__qwq (赞：7)

简单题，直接按照题意模拟即可。

细节处理问题：

+ 求所有字符串的长度只需要求出第一个字符串的长度即可（所有字符串的长度相同）。
+ 可以一次处理连续的两个字符然后把她转化为 $255$ 以内的自然数并求值。
+ 用一个结构体对元素排序并保留元素原来所得的下标。
+ 一个 $255$ 以内的自然数转回两位 $16$ 进制数可以分为上 $4$ 位和下 $4$ 位分别转化为 $16$ 进制来求。

然后就没了。十分简单。

---

## 作者：a1111a (赞：5)

# 思路
把每两位的十六进制转化成十进制放到数组后进行统计，排序后把前 16 个转化为十六进制，之后输出。接下来从 0 枚举，记录字符串十进制的数组每一位都减或加枚举的数字，如果是前 16 个中的一个，停止枚举，输出答案。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,e[22][42],d;//n是输入数字，ans是转十进制的结果，e是记录十进制用的数组，d是转十六进制记录被转数字的数字
string a[22],y;//a是输入字符串，y是转十六进制的结果
char z[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};//转十六进制
struct node{
	int c,x;//c是每个数字出现次数，x是转字符串十进制的结果
}b[260];
bool kg;//记录是否跳出枚举循环
int main(){
	cin>>n;
	for(int i=0;i<=255;i++)
		b[i].x=i;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		for(int j=0;j<a[i].length();j+=2){//转十六进制
			ans=0;
			if(a[i][j]>='0'&&a[i][j]<='9')
				ans+=(a[i][j]-'0')*16;
			else
				ans+=(a[i][j]-'A'+10)*16;
			if(a[i][j+1]>='0'&&a[i][j+1]<='9')
				ans+=a[i][j+1]-'0';
			else
				ans+=a[i][j+1]-'A'+10;
			b[ans].c++;
			e[i][j/2+1]=ans;
		}
	}
	for(int i=1;i<=16;i++)//冒泡排序
		for(int j=255;j>=i;j--)
			if(b[j].c>b[j-1].c)
				swap(b[j],b[j-1]);
	for(int i=0;i<=15;i++){
		d=b[i].x;
		y="";//转十六进制
		while(d){
			if(d%16<=9)
				y+=d%16+'0';
			else
				y+=d%16+'A'-10;
			d/=16;
		}
		if(y.length()<1)
			cout<<0;
		if(y.length()<2)
			cout<<0;
		for(int j=y.length()-1;j>=0;j--)//输出前16个数字
			cout<<y[j];
	}
	cout<<"\n";
	for(int i=1;i<=n;i++){
		for(int j=1;j<=a[i].length()/2;j++){
			kg=0;
			for(int k=0;!kg;k++){//枚举
				for(int l=0;l<16;l++){
					if(e[i][j]-k==b[l].x){//找到后输出
						kg=1;
						cout<<z[l];
						break;
					}
					else if(e[i][j]+k==b[l].x){//找到后输出
						kg=1;
						cout<<z[l];
						break;
					}
				}
			}
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

## 思路：
- 模拟题，我们按照题目的要求进行模拟即可，首先将数据输入，并把 $16$ 进制转换为 $10$ 进制。
- 接着我们找出出现次数最多的 $16$ 灰阶。
- 然后遍历所有的灰阶，找出距离它们各自最近的 $16$ 种灰阶之一。
- 先输出出现次数最多的 $16$ 种灰阶，记得转换为 $16$ 进制，再输出压缩后的图像，即所有的灰阶都输出距离它们各自最近的 $16$ 种灰阶之一。
## 代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int image[20][20];

int cpimg[20][20];

int his[256];

int color[16];

// 一位十六进制字符转换为数字

int trans(char a) {

    if (a <= '9')

        return (a - '0');

    return (a - 'A' + 10);

}

// 十进制数字转换为十六进制数字

char itrans(int n) {

    if (n >= 10)

        return (char)(n - 10 + 'A');

    return (char)(n + '0');

}

// 寻找离c最近的灰阶

int compress(int c) {

    int dis = 256, res = -1;

    for (int i = 0; i < 16; i++) {

        int d = c - color[i];

        if (d < 0)

            d = -d;

        if (d < dis) {

            dis = d;

            res = i;

        }

    }

    return res;

}

int main() {

    int N = 0, M = 0;

    cin >> N;

    // 灰阶计数，初始化为-1

    for (int i = 0; i < 256; i++)

        his[i] = -1;

    // 输入图像，并对灰阶计数

    for (int i = 0; i < N; i++) {

        char line[50];

        cin >> line;

        M = strlen(line) / 2;

        for (int j = 0; j < M; j++) {

            int c = trans(line[j  2])  16 + trans(line[j * 2 + 1]);

            image[i][j] = c;

            his[c]++;

        }

    }

    // 选取出现次数最多的16个灰阶

    for (int c = 0; c < 16; c++) {

        int max = 0, max_id = -1;

        for (int i = 0; i < 256; i++)

            if (his[i] > max) {

                max = his[i];

                max_id = i;

            }

        color[c] = max_id;

        his[max_id] = -1;

    }

    // 将image的灰阶压缩为cpimg

    for (int i = 0; i < N; i++)

        for (int j = 0; j < M; j++)

            cpimg[i][j] = compress(image[i][j]);

    // 输出选取的16个灰阶

    for (int c = 0; c < 16; c++)

        cout << itrans(color[c] / 16) << itrans(color[c] % 16);

    cout << endl;

    // 输出压缩后的图像

    for (int i = 0; i < N; i++) {

        for (int j = 0; j < M; j++)

            cout << itrans(cpimg[i][j]);

        cout << endl;

    }

    return 0;

}
```

---

## 作者：yu1128_AKIOI (赞：3)

# 思路

纯模拟。将输入中的数据转化为十进制，并将其装桶。接着枚举出前 16 个出现的次数最多的数据，输出其十六进制。然后枚举其他数据，找出与其离的最近 16 种灰阶之一，并输出序号。

# 代码

```c
#include<bits/stdc++.h>
using namespace std;
int n;
map<char,int>m;
string s[25];
struct node{int o,p;}t[256];
bool cmp(node a,node b) {if(a.o==b.o) return a.p<b.p;else return a.o>b.o;}
int main(){
    for(int i=0;i<=255;i++) t[i].p=i;
    for(char i='0';i<='9';i++) m[i]=i-'0';
    for(char i='A';i<='Z';i++) m[i]=i-'A'+10;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        int ls=s[i].length();
        for(int j=0;j<ls;j+=2){
            int sum=m[s[i][j]]*16+m[s[i][j+1]];
            t[sum].o++;
        }
    }
    sort(t,t+256,cmp);
    for(int i=0;i<=15;i++){
        int r=t[i].p;
        string a="";
        if(r==0){
            cout<<"00";
            continue;
        }
        while(r){
            if(r%16>=10) a+=r%16-10+'A';
            else a+=r%16+'0';
            r/=16;
        }
        if(a.length()==1) cout<<"0";
        reverse(a.begin(),a.end());
        cout<<a;
    }
    cout<<endl;
    for(int i=1;i<=n;i++){
        int ls=s[i].length();
        for(int j=0;j<ls;j+=2){
            int kg=1,mn=999,ans;
            int sum=m[s[i][j]]*16+m[s[i][j+1]];
            for(int k=0;k<=15;k++){
                if(sum==t[k].p) {
                    char c=k-10+'A',c2=k+'0';
                    if(k>=10) cout<<c;
                    else cout<<c2;
                    kg=0;
                    break;
                }
            }
            if(!kg) continue;
            for(int k=0;k<=15;k++){
                int w=t[k].p-sum;
                if(w<0) w=-w;
                if(mn>w){
                    mn=w;
                    ans=k;
                }
            }
            char c=ans-10+'A',c2=ans+'0';
            if(ans>=10) cout<<c;
            else cout<<c2;
        }
        cout<<endl;
    }
}
```

---

## 作者：LionBlaze (赞：2)

## 题目简述

给出一堆十六进制数，找出出现次数最多的 $16$ 个数字，将每个数字替换为 $16$ 个数字中最近的数字（最近的数字指与它绝对值最小的数字，如果多个数字与它的绝对值相同，则取最小）。

## 分析

1. 十六进制不好处理，转为十进制。
2. 如何找出出现最多的 $16$ 个数字：桶排
3. 如何找到最近的数字：可以用 `lower_bound`，但是不需要，可以直接找。
4. 细节！细节！细节！

## 代码

```cpp
#include <cmath> //abs
#include <cstdio> //scanf, printf
#include <string> //string
#include <iostream> //cin
#include <algorithm> //sort
using namespace std;

int mp[25][25], choose[25]; //choose：找出的16个数字

class cnter
{
public:
    int num, cnt; //还要知道是什么数字，排序之后才不会乱
} cnt[260];

int main()
{
    int n;
    scanf("%d", &n);
    int m;
    for(int i=1;i<=n;i++)
    {
        string str;
        cin >> str;
        m = str.size()/2;
        for(int j=1;j<=m;j++)
        {
            char c1 = str[j*2-2], c2 = str[j*2-1];
            int a1, a2;
            if(c1 >= '0' && c1 <= '9') a1 = c1 - '0';
            else a1 = c1 - 'A' + 10;
            if(c2 >= '0' && c2 <= '9') a2 = c2 - '0';
            else a2 = c2 - 'A' + 10;
            mp[i][j] = a1*16+a2; //16 to 10
            cnt[mp[i][j]].cnt++; //计数++
            cnt[mp[i][j]].num = mp[i][j]; //设置数字
        }
    }
    sort(cnt, cnt + 256, [](cnter x, cnter y) { return x.cnt > y.cnt || x.cnt == y.cnt && x.num < y.num; }); //排序
    for(int i=0;i<16;i++)
    {
        choose[i] = cnt[i].num;
        int a = choose[i]/16, b = choose[i]%16;
        printf("%c%c", (a <= 9)?(a + '0'):(a + 'A' - 10), (b <= 9)?(b + '0'):(b + 'A' - 10)); //10 to 16
        //printf(":%d\n", cnt[i].cnt); //debug语句
    }
    putchar('\n');
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int num = mp[i][j];
            int minn = 2147483647, mink;
            for(int k=0;k<16;k++)
            {
                if(abs(num - choose[k]) < minn)
                {
                    minn = abs(num - choose[k]);
                    mink = k;
                }
            }
            putchar(mink <= 9 ? mink+'0' : (mink + 'A' - 10)); //10 to 16
        }
        puts("");
    }
    return 0;
}
```

---

## 作者：zhc20170619 (赞：1)

### 思路和步骤

$map$ 保存每个像素的出现次数, $set$ 对像素排序，继续保存出现次数最多的 $16$ 个像素，分别保存这 $16$ 个像素所对应的 $0-F$ 的编号。$check$ 函数查看每个像素的十进制整数，最后查找所有的像素，查看每个像素。如果某个像素在 $set$ 中，直接输出它对应的编号，否则，遍历保存的 $16$ 个像素，按条件取差的绝对值最小的像素作为当前的像素。

### Code

```c++
#include<bits/stdc++.h>
#define ll long long
#define INF 1000000000
#define PII pair<int,int> 
#define PSI pair<string,int> 
#define PSC pair<string,char>
using namespace std;
const int N=2e5+10;
int n;
string s[30]; 
int check(string s){
	int ans=0;
	if(s[0]>='A') ans=s[0]-'A'+10;
	else ans=s[0]-'0';
	if(s[1]>='A') ans=ans*16+s[1]-'A'+10;
	else ans=ans*16+s[1]-'0';
	return ans;
}
struct CMP{
	bool operator()(const PSI &x,const PSI &y)const{
		if(x.second!=y.second) return x.second>y.second;
		return check(x.first)<check(y.first);
	}
};
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);
	map<string,int> m;
	set<PSI,CMP> st;
	cin>>n;
	vector<string> a[30];
	for(int i=1;i<=n;i++){
		cin>>s[i];
		for(int j=0;j<s[i].size();j+=2){
			string t;
			t+=s[i][j];t+=s[i][j+1];
			m[t]++;
			a[i].push_back(t);
		}
	}
	for(auto x : m) st.insert(x);
	int cnt=0;
	map<string,char> M;
	set<PSI,CMP> ss;
	set<string> S;
	vector<PSC> b;
	for(auto x : st){
		if(cnt<10) M[x.first]=cnt+'0',b.push_back({x.first,cnt+'0'});
		else M[x.first]=cnt-10+'A',b.push_back({x.first,cnt-10+'A'});
		ss.insert(x);
		S.insert(x.first);
		cnt++;
		if(cnt==16) break;
	}
	for(auto x : ss) cout<<x.first;
	cout<<endl; cnt=0;
	for(int i=1;i<=n;i++){
		for(string x : a[i]){
			if(S.count(x)) cout<<M[x];
			else{
				int v1=check(x),ans=INF;
				char ch;
				for(auto p : b){
					int v2=check(p.first);
					if(abs(v1-v2)<ans){
						ans=abs(v1-v2);
						ch=p.second;
					}
				}
				cout<<ch;
			} 
		}
		cout<<'\n';
	}
    return 0;
}
```

---


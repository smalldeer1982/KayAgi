# 棋盘覆盖

## 题目描述

在一个 $2^k \times 2^k$ 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格。现在用 L 型（占 $3$ 小格）骨牌覆盖棋盘上除了特殊方格的所有方格，各骨牌不能重叠。

![](https://cdn.luogu.com.cn/upload/image_hosting/dl5jo3iv.png)

现给出棋盘的大小和特殊方格所在的位置，请找出这种棋盘。

## 说明/提示

本题共有 $10$ 个子任务，第 $i$ 个子任务中 $k=i$。每个子任务记 $10$ 分，你只有通过每个子任务中所有测试点才能获得该子任务的分数。

## 样例 #1

### 输入

```
2
2 2```

### 输出

```
2 2 3 3
2 0 1 3
4 1 1 5
4 4 5 5
```

# 题解

## 作者：Beacon_wolf (赞：4)

竟然还没有题解，来发一篇。
## 题目思路
分治。

把大棋盘分成 $4$ 个大小相等的子棋盘，其中一个子棋盘包含特殊方格，另外三个不包含。

在这三个不含特殊方格的子棋盘的交界处放置一个 L 型骨牌，这样每个子棋盘都会创造出一个类似特殊方格的位置，因为已经覆盖过了，所以不再需要覆盖骨牌。

递归处理。终止条件显然是当棋盘大小是 $1 \times 1$ 的时候，因为那唯一的方格一定是特殊方格或是我们创造出的类似特殊方格的位置，直接返回。

## AC 代码
细节有点多。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; 
const int MAXN = (1 << 10) + 10;
#define endl '\n'
int a[MAXN][MAXN],now = 1;
void f(int x,int y,int n,int sx,int sy){ //x 是左上角的 x 值，y 是左上角的 y 值，n 是边长，sx 是特殊方格的 x 坐标，sy 是特殊方格的 y 坐标
	if(n == 1) return;
	int r; //0左上 1左下 2右上 3右下 
	if(sx >= x + n / 2){
		if(sy >= y + n / 2) r = 3;
		else r = 1;
	}else{
		if(sy >= y + n / 2) r = 2;
		else r = 0;
	}
	if(r != 0) a[x + n / 2 - 1][y + n / 2 - 1] = now; //左上子棋盘的右下角
	if(r != 1) a[x + n / 2][y + n / 2 - 1] = now; //左下棋盘的右上角
	if(r != 2) a[x + n / 2 - 1][y + n / 2] = now; //右上棋盘的左下角
	if(r != 3) a[x + n / 2][y + n / 2] = now; //右下棋盘的左上角 
	now++;
	//递归四个子区域 
	if(r == 0) f(x,y,n / 2,sx,sy);
	else f(x,y,n / 2,x + n / 2 - 1,y + n / 2 - 1);
	if(r == 1) f(x + n / 2,y,n / 2,sx,sy);
	else f(x + n / 2,y,n / 2,x + n / 2,y + n / 2 - 1);
	if(r == 2) f(x,y + n / 2,n / 2,sx,sy);
	else f(x,y + n / 2,n / 2,x + n / 2 - 1,y + n / 2);
	if(r == 3) f(x + n / 2,y + n / 2,n / 2,sx,sy);
	else f(x + n / 2,y + n / 2,n / 2,x + n / 2,y + n / 2);
}
int main(){
	int k,x,y;
	cin >> k >> x >> y;
	int n = 1 << k;
	memset(a,-1,sizeof(a));
	a[x][y] = 0;
	f(1,1,n,x,y);
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= n;j++){
			cout << a[i][j] << " ";
		}
		cout << endl;
	}
	return 0;
}
```

---

## 作者：shihanyu2013 (赞：2)

这题是我很久之前写的，当时好像还调了一整天，细节太多了。

## 思路

一眼分治。

每次把当前的棋盘平均分成四个形状大小完全一样的小棋盘，然后在不含特殊方格的三个棋盘的交界处放一个骨牌。

差不多时这样：

|  0  |  1  |
| :-: | :-: |
|  1  |  1  |

上面的表格描述的时四个小棋盘交界处的情况，$0$ 表示含有特殊方格的棋盘，这里以左上角为例。$1$ 表示这里放置骨牌。这样保证每个小棋盘都有一个不能放的位置。

搞一个递归，每次判断特殊方格在哪个小棋盘，然后放骨牌，递归到 $1$ 的时候容易证明那个小方格一定为特殊方格或放了骨牌，所以直接 `return` 掉。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,h,a,b,mp[2010][2010];
void dfs(int x,int y,int tx,int ty,int k) {
	if(k==1) {//直接返回
		return;
	}
	int s=k/2,num=++cnt;
	if(tx<x+s&&ty<y+s) {//在左上角
		dfs(x,y,tx,ty,s);
	}
	else {//不在左上角
		mp[x+s-1][y+s-1]=num;
		dfs(x,y,x+s-1,y+s-1,s);
	}
	if(tx<x+s&&ty>=y+s) {//同理
		dfs(x,y+s,tx,ty,s);
	}
	else {
		mp[x+s-1][y+s]=num;
		dfs(x,y+s,x+s-1,y+s,s);
	}
	if(tx>=x+s&&ty<y+s) {
		dfs(x+s,y,tx,ty,s);
	} 
	else {
		mp[x+s][y+s-1]=num;
		dfs(x+s,y,x+s,y+s-1,s);
	}
	if(tx>=x+s&&ty>=y+s) {
		dfs(x+s,s+y,tx,ty,s);
	} 
	else {
		mp[x+s][y+s]=num;
		dfs(x+s,y+s,x+s,y+s,s);
	}
}
int main() {
	cin>>n>>a>>b;
    n=1<<n;
	dfs(1,1,a,b,n);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			cout<<mp[i][j]<<' ';
		}
		cout<<'\n';
	}
    return 0;
}
```

---


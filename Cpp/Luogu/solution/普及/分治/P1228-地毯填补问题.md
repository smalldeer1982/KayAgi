# 地毯填补问题

## 题目描述

相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择（如图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)

并且每一方格只能用一层地毯，迷宫的大小为 $2^k\times 2^k$ 的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为 $1$ 秒。


## 说明/提示

spj 报错代码解释：

1. $c$ 越界；
2. $x,y$ 越界；
3. $(x,y)$ 位置已被覆盖；
4. $(x,y)$ 位置从未被覆盖。

$\text{upd 2023.8.19}$：增加样例解释。

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)


## 样例 #1

### 输入

```
3                          
3 3   ```

### 输出

```
5 5 1
2 2 4
1 1 4
1 4 3
4 1 2
4 4 1
2 7 3
1 5 4
1 8 3
3 6 3
4 8 1
7 2 2
5 1 4
6 3 2
8 1 2
8 4 1
7 7 1
6 6 1
5 8 3
8 5 2
8 8 1
```

# 题解

## 作者：夜刀神十香ღ (赞：247)

初看这个问题，似乎无从下手，于是我们可以先考虑最简单的情况，既n = 2时

0 0
0 1
这时，无论公主在哪个格子，我们都可以用一块毯子填满

继续考虑n = 4的情况

我们已经知道了解决2 \* 2的格子中有一个障碍的情况如何解决，因此我们可以尝试构造这种情况

首先，显然可以将4 \* 4的盘面划分成4个2 \* 2的小盘面，其中一块已经存在一个障碍了

而我们只需在正中间的2 \* 2方格中放入一块地毯，就可以使所有小盘面都有一个障碍

于是，n = 4的情况就解决了

我们可以将n = 4时的解法可以推广到一般情况，既当n = 2 k时，我们均可以将问题划分为4个n = 2 k – 1的子问题，然后分治解决即可。

下面附上代码（算法：分治）：

```cpp
#include<cstdio>
typedef long long ll;
ll x,y,len; int k;
ll fun(int k)
{
    ll sum=1;
    for(int i=1;i<=k;++i) sum*=2;
    return sum;
}
void solve(ll x,ll y,ll a,ll b,ll l)
{
    if(l==1) return;
    if(x-a<=l/2-1 && y-b<=l/2-1)
    {
        printf("%lld %lld 1\n",a+l/2,b+l/2);
        solve(x,y,a,b,l/2);
        solve(a+l/2-1,b+l/2,a,b+l/2,l/2);
        solve(a+l/2,b+l/2-1,a+l/2,b,l/2);
        solve(a+l/2,b+l/2,a+l/2,b+l/2,l/2);
    }
    else if(x-a<=l/2-1 && y-b>l/2-1)
    {
        printf("%lld %lld 2\n",a+l/2,b+l/2-1);
        solve(a+l/2-1,b+l/2-1,a,b,l/2);
        solve(x,y,a,b+l/2,l/2);
        solve(a+l/2,b+l/2-1,a+l/2,b,l/2);
        solve(a+l/2,b+l/2,a+l/2,b+l/2,l/2);
    }
    else if(x-a>l/2-1 && y-b<=l/2-1)
    {
        printf("%lld %lld 3\n",a+l/2-1,b+l/2);
        solve(a+l/2-1,b+l/2-1,a,b,l/2);
        solve(a+l/2-1,b+l/2,a,b+l/2,l/2);
        solve(x,y,a+l/2,b,l/2);
        solve(a+l/2,b+l/2,a+l/2,b+l/2,l/2);
    }
    else
    {
        printf("%lld %lld 4\n",a+l/2-1,b+l/2-1);
        solve(a+l/2-1,b+l/2-1,a,b,l/2);
        solve(a+l/2-1,b+l/2,a,b+l/2,l/2);
        solve(a+l/2,b+l/2-1,a+l/2,b,l/2);
        solve(x,y,a+l/2,b+l/2,l/2);
    }
}
int main()
{
    scanf("%d %lld %lld",&k,&x,&y);
    len=fun(k);
    solve(x,y,1,1,len);
    return 0;
}

```

---

## 作者：SadLava (赞：155)

## 前言
这题大佬们都讲得很详细了，但这作为我第一道自己想出来的蓝题（早于注册账号），还是要写篇题解纪念一下。

~~PS：本人懒得制作图片，因此用表格代替了，这里向大家道歉~~
## 解析
与多数大佬的**从小往大**推导不同，我们是从**大往小推**，怎么个推法呢？
我们看下面这个例子（P表示公主）
```cpp
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 P 0
0 0 0 0 0 0 0 0
```
我们手头里只有
```cpp
0 1  1 0  1 1 1 1
1 1  1 1  0 1 1 0
```
共4种地毯，我们该怎么铺呢？

首先我们知道**在2×2的格子**中，公主在左上角、右上角......右下角时要分别用1、2......4种毯子，那么在上面的例子中，我们可以将其**分成4份**如下

```cpp
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
3 3 3 3 4 4 4 4
3 3 3 3 4 4 4 4
3 3 3 3 4 4 P 4
3 3 3 3 4 4 4 4
```
这下可不就清晰明了了，公主在格子的右下角，咱用一个**大小（指单个格子边长，下同）为4**的4号地毯不就可以**填满剩下三个角**了？

“你是在逗我啊，哪来的这么大的毯子啊”

别着急，咱在草稿纸上动几笔，不难发现规律，下面这个大小为2的毯子，可以这么铺
```cpp
0 0 2 2
0 0 1 2 
2 1 1 3 
2 2 3 3 
```

是不是很有意思？大小为2的巨毯子可以用4个毯子拼得，以此类推，大小为8的巨毯子可由4个大小为2的毯子拼得......

可以知道：**大小为$2^n$的巨毯子可由4个大小为$2^{n-1}$的毯子拼得**，这是个明显的**递归过程**。

“你现在只拼了3个角，剩下**这么大个角**当我眼瞎啊？”

这个咱别着急，我们拼完三个角后，不**就只剩下一个角**了吗？这个角我们按照之前的处理方式（**四等分并填满3个角**）进行可不就行了？

## 程序流程

根据上面的推导，我们得到了下面的程序流程：
$$\text {判断公主在哪个角}$$
$$↓$$
$$\text {算出需要哪种巨毯子，并获取巨毯子大小}$$
$$↓$$
$$\text {递归填补巨毯子，毯子大小为1时输出}$$
$$↓$$
$$\text {回过头来用剩下的角作为参数重新执行程序}$$

这样就是本题的解法了，由于这种方法递归方式特殊（需要**两个递归函数，1个填毯子，1个四等分**），得到的答案顺序会和样例的顺序不同（其实改一下递归函数调用的顺序就好了），但本题是**Special Judge**，结果顺序不影响AC，故请大家放心。
## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;
//以编译器的痛苦来满足自己快乐的行为（但是方便调试）
#define ul dfs(zx+l-1,zy+l-1,zx,zy,l);//递归做左上角
#define ur dfs(zx+l-1,zy+l,zx,zy+l,l);//递归做右上角
#define dl dfs(zx+l,zy+l-1,zx+l,zy,l);//递归做左下角
#define dr dfs(zx+l,zy+l,zx+l,zy+l,l);//递归做右下角

void dfs(int x,int y,int zx,int zy,int l){
    if(l==1) return;
    l>>=1;
    //左上角 
    if(x-zx<l&&y-zy<l){
        //输出 
        printf("%d %d 1\n",zx+l,zy+l);
        dfs(x,y,zx,zy,l);//继续把有人的区块填满
        //按定理处理大方块
        ur
        dl
        dr 

    }
    //右上角
    if(x-zx<l&&y-zy>=l){
        //输出 
        printf("%d %d 2\n",zx+l,zy+l-1);
        dfs(x,y,zx,zy+l,l);//继续把有人的区块填满
        //按定理处理大方块
        ul
        dl
        dr 
    }
    //左下角
    if(x-zx>=l&&y-zy<l){
        //输出 
        printf("%d %d 3\n",zx+l-1,zy+l);
        dfs(x,y,zx+l,zy,l);//继续把有人的区块填满
        //按定理处理大方块
        ul
        ur
        dr 
    }
    //右下角 
    if(x-zx>=l&&y-zy>=l){
        //输出 
        printf("%d %d 4\n",zx+l-1,zy+l-1);
        dfs(x,y,zx+l,zy+l,l);//继续把有人的区块填满
        //按定理处理大方块
        ul
        ur
        dl
    }
}

int main()
{
    int k,x,y;
    scanf("%d%d%d",&k,&x,&y);
    dfs(x,y,1,1,1<<k);
    return 0;
}
```


## 完结

---

## 作者：dbxxx (赞：76)

[传送门](https://www.luogu.com.cn/problemnew/show/P1228)


# 分析

乍一看这个样例，好像找不出什么规律。那么我们就从$k = 1$的情况开始讨论吧。

首先$k = 1$，代表填补迷宫的大小为$2 \times 2$，这也就是最基础的情况（接下来的所有图，圆圈代表公主，横条状的东西代表地毯）。可能出现的情况有四种：

![](https://cdn.luogu.com.cn/upload/image_hosting/elupa2i8.png)

那么$k = 2$呢？这就代表了填补迷宫的大小为$4 \times 4$。这样情况一多，怎么办呢？

其实只需要填补一个地毯：

![](https://cdn.luogu.com.cn/upload/image_hosting/lywv2mc6.png)

然后你就会发现，$4 \times 4$分解为了$4$个$2 \times 2$的区块，而填补的这个地毯把右上，左下和右下的$2 \times 2$区块全部覆盖了一格。显然这又回到了$2 \times 2$的情况，根据上边的四种选择填补即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/7tp1lk4g.png)

接下来扩展到$k = 3$的情况，也就是变成了$8 \times 8$。我们还是像刚刚一样，在中间填补一个地毯：

![](https://cdn.luogu.com.cn/upload/image_hosting/j0zm0q2q.png)

这样填补的这个地毯把右上，左下和右下的$4 \times 4$区块全部覆盖了一格。显然这又回到了$4 \times 4$的情况。而$4 \times 4$的情况再分解成$4$个$2 \times 2$的区块。

熟悉的套路，熟悉的料理。

![](https://cdn.luogu.com.cn/upload/image_hosting/sp7agp6m.png)

以此类推，$2 ^ k \times 2 ^ k$的情况总能分解成$4$个$2 ^ {k - 1} \times 2 ^ {k - 1}$的情况，直到$k = 2$的基本情况。

妥妥的递归，代码走起吧！

# 代码
```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2020-04-29 10:48:00 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2020-05-02 01:10:17
 */
#include <iostream>
#include <cstdio>

void solve(int x1, int y1, int x2, int y2, int n) {
    if(n == 1) return ;
    if(x1 - x2 < (n >> 1)) {
        if(y1 - y2 < (n >> 1)) {
            std :: cout << (x2 + (n >> 1)) << ' ' << (y2 + (n >> 1)) << ' ' << 1 << std :: endl;
            solve(x1, y1, x2, y2, (n >> 1));
            solve(x2 + (n >> 1) - 1, y2 + (n >> 1), x2, y2 + (n >> 1), (n >> 1));
            solve(x2 + (n >> 1), y2 + (n >> 1) - 1, x2 + (n >> 1), y2, (n >> 1));
            solve(x2 + (n >> 1), y2 + (n >> 1), x2 + (n >> 1), y2 + (n >> 1), (n >> 1));
        } else {
            std :: cout << (x2 + (n >> 1)) << ' ' << (y2 + (n >> 1) - 1) << ' ' << 2 << std :: endl;
            solve(x2 + (n >> 1) - 1, y2 + (n >> 1) - 1, x2, y2, (n >> 1));
            solve(x1, y1, x2, y2 + (n >> 1), (n >> 1));
            solve(x2 + (n >> 1), y2 + (n >> 1) - 1, x2 + (n >> 1), y2, (n >> 1));
            solve(x2 + (n >> 1), y2 + (n >> 1), x2 + (n >> 1), y2 + (n >> 1), (n >> 1));    
        }
    } else {
        if(y1 - y2 < (n >> 1)) {
            std :: cout << (x2 + (n >> 1) - 1) << ' ' << (y2 + (n >> 1)) << ' ' << 3 << std :: endl;
            solve(x2 + (n >> 1) - 1, y2 + (n >> 1) - 1, x2, y2, (n >> 1));
            solve(x2 + (n >> 1) - 1, y2 + (n >> 1), x2, y2 + (n >> 1), (n >> 1));
            solve(x1, y1, x2 + (n >> 1), y2, (n >> 1));
            solve(x2 + (n >> 1), y2 + (n >> 1), x2 + (n >> 1), y2 + (n >> 1), (n >> 1));
        } else {
            std :: cout << (x2 + (n >> 1) - 1) << ' ' << (y2 + (n >> 1) - 1) << ' ' << 4 << std :: endl;
            solve(x2 + (n >> 1) - 1, y2 + (n >> 1) - 1, x2, y2, (n >> 1));
            solve(x2 + (n >> 1) - 1, y2 + (n >> 1), x2, y2 + (n >> 1), (n >> 1));
            solve(x2 + (n >> 1), y2 + (n >> 1) - 1, x2 + (n >> 1), y2, (n >> 1));
            solve(x1, y1, x2 + (n >> 1), y2 + (n >> 1), (n >> 1));
        }
    }
}

int main() {
    int k, x, y;
    std :: cin >> k >> x >> y;
    solve(x, y, 1, 1, 1 << k);
    return 0;
}
```
# 评测记录
[自己康吧](https://www.luogu.com.cn/record/list?pid=P1228&user=120868)

前面那些WA14都是在递归函数中出了细节错误。

---

## 作者：abs001 (赞：39)

首先 容易证明，对于正整数$n$，必有正整数$m$使得:

$$(2^n)^2=2^{2n}=3*m + 1$$

由此可想到将一个边长为$2^k$的正方形分成四个边长为$2^{k - 1}$的正方形公主必在其中的一个正方形中，然后再中心摆上一个地毯，地毯缺少的一块朝向公主所在正方形，这样相当于每个小正方形中有一个公主。

一直分治下去，直到边长为2结束了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, x, y;

void dfs(int t, int sx, int sy, int x, int y)
{//sx，sy代表此正方形左上角位置，xy表示公主所在位置（或被占掉的位置）
	if(t == 0) return;
	int t1 = (1 << t - 1);//小正方形边长
	if(x < sx + t1 && y < sy + t1)//左上角
	{
		printf("%d %d %d\n", sx + t1, sy + t1, 1);
		dfs(t - 1, sx, sy, x, y), dfs(t - 1, sx, sy + t1, sx + t1 - 1, sy + t1);
		dfs(t - 1, sx + t1, sy, sx + t1, sy + t1 - 1), dfs(t - 1, sx + t1, sy + t1, sx + t1, sy + t1);
	}
	else if(x < sx + t1)//右上角
	{
		printf("%d %d %d\n", sx + t1, sy + t1 - 1, 2);
		dfs(t - 1, sx, sy, sx + t1 - 1, sy + t1 - 1), dfs(t - 1, sx, sy + t1, x, y);
		dfs(t - 1, sx + t1, sy, sx + t1, sy + t1 - 1), dfs(t - 1, sx + t1, sy + t1, sx + t1, sy + t1);
	}
	else if(y < sy + t1)//左下角
	{
		printf("%d %d %d\n", sx + t1 - 1, sy + t1, 3);
		dfs(t - 1, sx, sy, sx + t1 - 1, sy + t1 - 1), dfs(t - 1, sx, sy + t1, sx + t1 - 1, sy + t1);
		dfs(t - 1, sx + t1, sy, x, y), dfs(t - 1, sx + t1, sy + t1, sx + t1, sy + t1);
	}
	else//右下角
	{
		printf("%d %d %d\n", sx + t1 - 1, sy + t1 - 1, 4);
		dfs(t - 1, sx, sy, sx + t1 - 1, sy + t1 - 1), dfs(t - 1, sx, sy + t1, sx + t1 - 1, sy + t1);
		dfs(t - 1, sx + t1, sy, sx + t1, sy + t1 - 1), dfs(t - 1, sx + t1, sy + t1, x, y);
	}
}

int main()
{
	scanf("%d%d%d", &n, &x, &y);
	dfs(n, 1, 1, x, y);
	return 0;
}
```


---

## 作者：Adove (赞：30)

我来给下这题在正整数集内基于第一数学归纳法的可解性证明

第一数学归纳法：若某命题对于k=1时成立，且假设$k \in N_+$成立时，有$k+1$也成立，则该命题对于$\forall k \in N_+$均成立

尝试证明：对于$\forall k \in N_+$，在边长$2^k$的正方形中都可以找到一个边长为1的正方形，将其去掉后可以使整个大正方形被题目要求的L形精确覆盖。

对于k=1的情况，该命题显然成立。

对于其他情况

我们假设其对于k成立

那么我们在k+1时沿着一组邻边垂直平分线把ta切开，拿掉交点一个角的方块，显然其他3个可以填上

此时对于四个象限的正方形我们都从中拿掉了一个方块

而我们已经假设这是成立的

那么对于整个k+1的正方形，这也是成立的

又因为对于k=1的情况该命题成立

故对于$\forall k \in N_+$，该命题都成立

故此问题在正整数集内是可解的

---

## 作者：llqqhh (赞：12)

# P1228 地毯填补问题

看大家的题解都是从大往小分治，我来一篇从小到大的递归构

首先可以想到如果存在一个正方形， 我们就可以用一个同级别大小的L形地毯把它包裹成更大的正方形：

![包裹](https://cdn.luogu.com.cn/upload/image_hosting/e1e78erx.png)

进一步地，我们可以用更大的L形地毯包住这个正方形：

![更大的包裹](https://cdn.luogu.com.cn/upload/image_hosting/y2x9arn5.png)

用这种方法我们就可以从公主（边长为 1 的正方形）构造出任意 $2^k$ 大小的正方形。

知道了这一点，我们的问题就变成了：如何构造出和任意和 $2^k$ 大小的正方形匹配的L形地毯。一种构造方法如下图：

![L的构造](https://cdn.luogu.com.cn/upload/image_hosting/7lvj1sw1.png)

其中折线表示最基本的四种地毯之一，多边形表示基本地毯拼出的大地毯。

接着我们用这个大地毯构造更大的地毯：

![大L](https://cdn.luogu.com.cn/upload/image_hosting/urri2cay.png)

其中多边形边框实际是不存在的，只是方便说明大小地毯之间的递归关系（~~应该没有人不知道吧~~）。

以下给出生成大地毯的代码：

```cpp
void fillL(int x, int y, int siz, int dir) {
    if(siz == 0) {
        a[x][y] = dir;
        return;
    }
    if(dir == 1) {
        fillL(x, y, siz - 1, dir);
        fillL(x + (1 << siz - 1), y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz - 1), y - (1 << siz), siz - 1, 2);
        fillL(x - (1 << siz), y + (1 << siz - 1), siz - 1, 3);
    } else if(dir == 2) {
        fillL(x, y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz - 1), y, siz - 1, dir);
        fillL(x + (1 << siz - 1), y + (1 << siz + 1) - (1 << siz - 1), siz - 1, 1);
        fillL(x - (1 << siz), y, siz - 1, 4);
    } else if(dir == 3) {
        fillL(x, y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz - 1), y, siz - 1, dir);
        fillL(x + (1 << siz + 1) - (1 << siz - 1), y + (1 << siz - 1), siz - 1, 1);
        fillL(x, y - (1 << siz), siz - 1, 4);
    } else {
        fillL(x, y, siz - 1, dir);
        fillL(x + (1 << siz - 1), y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz + 1) - (1 << siz - 1), y, siz - 1, 2);
        fillL(x, y + (1 << siz + 1) - (1 << siz - 1), siz - 1, 3);
    }
}
```

代码中 `siz` 表示当前要处理的地毯大小，`siz = 0` 表示当前处理到最基本的地毯， `siz = 1` 表示当前需要处理经过一层递归的地毯，以此类推；`dir` 表示当前要处理的地毯的方向； `x, y` 表示当前要处理 的 地毯 的 拐点 的 左上角 的 坐标。说的有点抽象，上图！

![解释x, y](https://cdn.luogu.com.cn/upload/image_hosting/n74c6hr8.png)

在以上四种情况中 `x, y` 表示图中红色点的位置。 

除了填充地毯，我们还需要一个为正方形匹配地毯的函数，为什么呢？

![合法匹配](https://cdn.luogu.com.cn/upload/image_hosting/36wle7oh.png)

对于中间的红点，有旁边的四种地毯可以匹配。但是我们真正需要的只有右上角这个橙色的地毯。因为你从四个地毯中选择了一个和红点匹配后的下一轮匹配必须能找到一个更大的地毯可以和这个正方形匹配并且能够在整张地图中放得下。即你只有在选择橙色地毯后才能继续和棕色地毯匹配，否则你在下一轮就找不到地毯能和这一状态匹配。上代码：

```cpp
void fillb(int x, int y, int dep) {
    if(dep == k) return;
    int bx = x % (1 << dep + 1) / (1 << dep);
    int by = y % (1 << dep + 1) / (1 << dep);
    if(bx == 0 && by == 0) {
        fillL(x + (1 << dep), y + (1 << dep), dep, 1);
        fillb(x, y, dep + 1);
    } else if(bx == 0 && by == 1) {
        fillL(x + (1 << dep), y - (1 << dep), dep, 2);
        fillb(x, y - (1 << dep), dep + 1);
    } else if(bx == 1 && by == 0) {
        fillL(x - (1 << dep), y + (1 << dep), dep, 3);
        fillb(x - (1 << dep), y, dep + 1);
    } else {
        fillL(x - (1 << dep), y - (1 << dep), dep, 4);
        fillb(x - (1 << dep), y - (1 << dep), dep + 1);
    }
}
```

代码中 `bx, by` 是为了方便讨论接下来要和什么方向的地毯匹配。同时为了方便处理出 `bx, by` 我们需要把地图下表从 0 开始排。

以下给出完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1024;
int k, cx, cy;
int a[N][N];

void fillL(int x, int y, int siz, int dir) {
    if(siz == 0) {
        a[x][y] = dir;
        return;
    }
    if(dir == 1) {
        fillL(x, y, siz - 1, dir);
        fillL(x + (1 << siz - 1), y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz - 1), y - (1 << siz), siz - 1, 2);
        fillL(x - (1 << siz), y + (1 << siz - 1), siz - 1, 3);
    } else if(dir == 2) {
        fillL(x, y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz - 1), y, siz - 1, dir);
        fillL(x + (1 << siz - 1), y + (1 << siz + 1) - (1 << siz - 1), siz - 1, 1);
        fillL(x - (1 << siz), y, siz - 1, 4);
    } else if(dir == 3) {
        fillL(x, y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz - 1), y, siz - 1, dir);
        fillL(x + (1 << siz + 1) - (1 << siz - 1), y + (1 << siz - 1), siz - 1, 1);
        fillL(x, y - (1 << siz), siz - 1, 4);
    } else {
        fillL(x, y, siz - 1, dir);
        fillL(x + (1 << siz - 1), y + (1 << siz - 1), siz - 1, dir);
        fillL(x + (1 << siz + 1) - (1 << siz - 1), y, siz - 1, 2);
        fillL(x, y + (1 << siz + 1) - (1 << siz - 1), siz - 1, 3);
    }
}

void fillb(int x, int y, int dep) {
    if(dep == k) return;
    int bx = x % (1 << dep + 1) / (1 << dep);
    int by = y % (1 << dep + 1) / (1 << dep);
    if(bx == 0 && by == 0) {
        fillL(x + (1 << dep), y + (1 << dep), dep, 1);
        fillb(x, y, dep + 1);
    } else if(bx == 0 && by == 1) {
        fillL(x + (1 << dep), y - (1 << dep), dep, 2);
        fillb(x, y - (1 << dep), dep + 1);
    } else if(bx == 1 && by == 0) {
        fillL(x - (1 << dep), y + (1 << dep), dep, 3);
        fillb(x - (1 << dep), y, dep + 1);
    } else {
        fillL(x - (1 << dep), y - (1 << dep), dep, 4);
        fillb(x - (1 << dep), y - (1 << dep), dep + 1);
    }
}

int main() {
    cin >> k >> cx >> cy;
    cx --, cy --;
    fillb(cx, cy, 0);
    for(int i = 0; i < 1 << k; i ++) {
        for(int j = 0; j < 1 << k; j ++)
            if(a[i][j]) cout << i + 1 << ' ' << j + 1 << ' ' << a[i][j] << '\n';
    }
}
```

画图不易，点个赞再走吧QAQ

---

## 作者：Galaxy_AC (赞：11)

其实刚开始做的时候很懵（原谅我很菜），想了好久才弄明白。

当格子边长等于2时，公主站的位置为特殊点，其他点一块地毯就能铺满。将边长扩大到4，与公主相邻的地方标记为特殊点，三个特殊点用一块毯子，剩下的顺着铺。同理，大格子可以分为四个小格子（分治）。

代码如下：

x表示列号，y表示行号，跟题目好像刚好反了，改一下输入输出就行。
```cpp
#include <cstdio>
using namespace std;
#define lu dfs(x1, y1, x1+len-1, y1+len-1, x1+len-1, y1+len-1, len);
#define ru dfs(x1+len, y1, x2, y1+len-1, x1+len, y1+len-1, len);
#define ld dfs(x1, y1+len, x1+len-1, y2, x1+len-1, y1+len, len);
#define rd dfs(x1+len, y1+len, x2, y2, x1+len, y1+len, len);

void dfs(int x1, int y1, int x2, int y2, int x0, int y0, int len)
//x1.y1表示当前方格的左上角，x2,y2表示当前方格右下角，x0.y0表示特殊点，len表示方格边长
{
	if(x2-x1 == 1 && y2-y1 == 1) {//当方格长度为2时，不再分治，返回
		if(x1 == x0 && y1 == y0) {
			printf("%d %d 1\n", y2, x2);
		}
		else if(x2 == x0 && y1 == y0) {
			printf("%d %d 2\n", y2, x1);
		}
		else if(x1 == x0 && y2 == y0) {
			printf("%d %d 3\n", y1, x2);
		}
		else if(x2 == x0 && y2 == y0) {
			printf("%d %d 4\n", y1 , x1);
		}
		return;
	}
	len >>= 1;//边长减半
	if(x0 < x1+len && y0 < y1+len) {//解决左上角方格
		printf("%d %d 1\n", y1+len, x1+len);
		dfs(x1, y1, x1+len-1, y1+len-1, x0, y0, len);
		ru
		ld
		rd
	}
	if(x0 >= x1+len && y0 < y1+len) {//右上角
		printf("%d %d 2\n", y1+len, x1+len-1);
		lu
		dfs(x1+len, y1, x2, y1+len-1, x0, y0, len);
		ld
		rd
	}
	if(x0 < x1+len && y0 >= y1+len) {//左下角
		printf("%d %d 3\n", y1+len-1, x1+len);
		lu
		ru
		dfs(x1, y1+len, x1+len-1, y2, x0, y0, len);
		rd
	}
	if(x0 >= x1+len && y0 >= y1+len) {//右下角
		printf("%d %d 4\n", y1+len-1, x1+len-1);
		lu
		ru
		ld
		dfs(x1+len, y1+len, x2, y2, x0, y0, len);
	}
}

int main(void)
{
	int k, x, y;
	scanf("%d%d%d", &k, &y, &x);
	dfs(1, 1, 1 << k, 1 << k, x, y, 1 << k);
	return 0;
}
```


---

## 作者：hhhw (赞：11)

这片题解纯借鉴@夜刀神十香的解法……emmm……
但是我简化了下代码和加了些注释……
```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;++i)
#define Dec(i,b,a) for(int i=b;i>=a;--i)
#define inf 0x3f3f3f3f
using namespace std;

typedef long long ll;
inline ll qr(){
	ll x=0,f=1; char ch;
	while(!isdigit(ch=getchar())) if(ch=='-') f=-1;
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x*f;
}
int len,x,y;
#define __1 solve(a+l/2-1,b+l/2-1,a,b,l/2)
#define __2 solve(a+l/2-1,b+l/2,a,b+l/2,l/2)
#define __3 solve(a+l/2,b+l/2-1,a+l/2,b,l/2)
#define __4 solve(a+l/2,b+l/2,a+l/2,b+l/2,l/2)
void solve(ll x,ll y,ll a,ll b,ll l) // x,y不能填 a,b是当前左上角
{
	if(l==1) return;
	if(x-a<l/2 && y-b<l/2) // upleft
	{
		printf("%lld %lld 1\n", a+l/2,b+l/2);
		solve(x,y,a,b,l/2); __2; __3; __4;
	}
	else if(x-a<l/2 && y-b>=l/2) // upright
	{
		printf("%lld %lld 2\n", a+l/2,b+l/2-1);
		__1; solve(x,y,a,b+l/2,l/2); __3; __4;
	}
	else if(x-a>=l/2 && y-b<l/2) // downleft
	{
		printf("%lld %lld 3\n", a+l/2-1,b+l/2);
		__1; __2; solve(x,y,a+l/2,b,l/2); __4;
	}
	else // downright
	{
		printf("%lld %lld 4\n", a+l/2-1,b+l/2-1);
		__1; __2; __3; solve(x,y,a+l/2,b+l/2,l/2);
	}
}
int main()
{
	// freopen("v.txt","r",stdin);
	len=1<<qr(),x=qr(),y=qr();
	solve(x,y,1,1,len);
	return 0;
}
```

---

## 作者：chenxsir (赞：10)

## 分治思想
本题的棋盘是$2^k*2^k$的，很容易想到分治，把棋盘分成四块，则每块都是$2^{k-1}*2^{k-1}$的。然后有公主的那块很容易解决，当k=1时铺上一块就可以了，没有公主的那三块，我们可以在中心点附近的三个点处铺上一块，人为的创造一个“公主”。
下面附上代码
~~~cpp
#include<iostream>
using namespace std;
long long kr,x,y;
void fenz(long long wx,long long wy,long long a,long long b,long long k);
int main()
{
    cin>>kr>>x>>y;
    fenz(1,1,x,y,kr);cin>>x;
    return 0;
}
void fenz(long long wx,long long wy,long long a,long long b,long long k)
{
    if(k==0)return;
    long long lsa=2<<(k-2);
    if(k==1) lsa=1;
    long long midx=wx+lsa;long long midy=wy+lsa;//cout<<"cf:"<<midx<<" "<<lsa;
    if(a<midx&&b<midy)
    {
        printf("%d %d %d\n",midx,midy,1);//cout<<":"<<wx<<" "<<wy<<" "<<midx<<" "<<midy<<endl;
        fenz(wx,wy,a,b,k-1);
        fenz(wx,midy,midx-1,midy,k-1);
        fenz(midx,wy,midx,midy-1,k-1);
        fenz(midx,midy,midx,midy,k-1);
    }
    else if(a<midx&&midy<=b)
    {
        printf("%d %d %d\n",midx,midy-1,2);//cout<<":"<<wx<<" "<<wy<<" "<<midx<<" "<<midy<<endl;
        fenz(wx,wy,midx-1,midy-1,k-1);
        fenz(wx,midy,a,b,k-1);
        fenz(midx,wy,midx,midy-1,k-1);
        fenz(midx,midy,midx,midy,k-1);
    }
    else if(midx<=a&&midy>b)
    {
        printf("%d %d %d\n",midx-1,midy,3);//cout<<":"<<wx<<" "<<wy<<" "<<midx<<" "<<midy<<endl;
        fenz(wx,wy,midx-1,midy-1,k-1);
        fenz(wx,midy,midx-1,midy,k-1);
        fenz(midx,wy,a,b,k-1);
        fenz(midx,midy,midx,midy,k-1);
        
    }
    else if(midx<=a&&midy<=b)
    {
        printf("%d %d %d\n",midx-1,midy-1,4);//cout<<":"<<wx<<" "<<wy<<" "<<midx<<" "<<midy<<" "<<lsa<<endl;
        fenz(wx,wy,midx-1,midy-1,k-1);
        fenz(wx,midy,midx-1,midy,k-1);
        fenz(midx,wy,midx,midy-1,k-1);
        fenz(midx,midy,a,b,k-1);
    
    }
}
~~~
事实上用int也可以过，为了保险还是用long long

---

## 作者：zhangjiacheng (赞：7)


## 题解里似乎好像没有pascal，那就让我来写一写吧！

#### 思路：编写一个find过程，然后当w=1时返回，否则判断一下继续找。具体代码如下。
```pascal
var k,x,y:longint;
procedure find(h,l,w,x,y:longint);
var hs,ls:longint;
  begin
    if w=1 then exit;
    hs:=h+w shr 1;
    ls:=l+w shr 1;
    if (x<hs) and (y<ls) then writeln(hs,' ',ls,' ',1);//输出毯子拐角的行坐标和列坐标和形状
    if (x<hs) and (y>=ls) then writeln(hs,' ',ls-1,' ',2);//输出毯子拐角的行坐标和列坐标和形状
    if (x>=hs) and (y<ls) then writeln(hs-1,' ',ls,' ',3);//输出毯子拐角的行坐标和列坐标和形状
    if (x>=hs) and (y>=ls) then writeln(hs-1,' ',ls-1,' ',4);//输出毯子拐角的行坐标和列坐标和形状
    if (x>=hs) or (y>=ls) then find(h,l,w shr 1,hs-1,ls-1)//继续寻找
      else find(h,l,w shr 1,x,y);
    if (x>=hs) or (y<ls) then find(h,ls,w shr 1,hs-1,ls)
      else find(h,ls,w shr 1,x,y);
    if (x<hs) or (y>=ls) then find(hs,l,w shr 1,hs,ls-1)
      else find(hs,l,w shr 1,x,y);
    if (x<hs) or (y<ls) then find(hs,ls,w shr 1,hs,ls)
      else find(hs,ls,w shr 1,x,y);
  end;
begin
  readln(k);//输入被填补迷宫大小
  readln(x,y);//输入公主坐标
  find(1,1,1 shl k,x,y);
end.
```
~~求管理员大佬通过吧~~

---

## 作者：zqazqazqa (赞：5)


居然没有用java写的.....让我来一发！！！



#### 本例中，为了反复制和改代码，毯子形状的规定方式与题干有所差别，且输出的每一行为（x,y,属于第几个地毯）


基本思路就是，因为每个规模为 k 的地毯可以由 4 个规模为 k-1 的小地毯组成，所以策略为：

1,每次把规模为 k 的区域分为四个象限，

2,找到公主所在象限，

3,把剩下的三个象限看作规模为 k 的地毯去递归构造，

4,把公主所在的那个象限作为规模为 k-1 的区域,回到 1 执行，直到 k=1 为止

代码：

```java
class question {

    private long num=1;
    private int[] size={1,2,4,8,16,32,64,128,256,512,1024,2048,5096};

    private void println(int x,int y){
        System.out.print(x);
        System.out.print(' ');
        System.out.print(y);
        System.out.print(' ');
        System.out.println(num);
    }

    private void println_block(int x,int y,int type){
        if(type!=1)println(x,y);
        if(type!=2)println(x+1,y);
        if(type!=3)println(x,y+1);
        if(type!=4)println(x+1,y+1);
        num++;
    }

    private int type(int k, int x, int y, int x_start, int y_start) {
        if(x>=x_start+size[k-1])return (y>=y_start+size[k-1])?4:2;
        else return (y>=y_start+size[k-1])?3:1;
    }

    private void println_L_block(int k,int x_start,int y_start,int type){
        if(k==1)println_block(x_start,y_start,type);
        else {
            println_L_block(k-1,x_start+size[k-2],y_start+size[k-2],type);
            if(type!=1)println_L_block(k-1,x_start,y_start,4);
            if(type!=2)println_L_block(k-1,x_start+size[k-1],y_start,3);
            if(type!=3)println_L_block(k-1,x_start,y_start+size[k-1],2);
            if(type!=4)println_L_block(k-1,x_start+size[k-1],y_start+size[k-1],1);
        }
    }

    void make_map(int k,int x,int y,int x_start,int y_start){
        if(k==0)return;
        int type=type(k,x,y,x_start,y_start);
        println_L_block(k,x_start,y_start,type);
        if(type==1)make_map(k-1,x,y,x_start,y_start);
        if(type==2)make_map(k-1,x,y,x_start+size[k-1],y_start);
        if(type==3)make_map(k-1,x,y,x_start,y_start+size[k-1]);
        if(type==4)make_map(k-1,x,y,x_start+size[k-1],y_start+size[k-1]);
    }
}

```








---

## 作者：littleming (赞：4)

题目的输出很怪，是按照你给每块砖的编号从小到大输出。至于编号的顺序嘛，看我的代码吧。。




    
        
    
        
        
        

        
        
        

        
        
        


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1500][1500];
int tile=1;
int size,dr,dc;
int xa[1000000],xb[1000000],ya[1000000],yb[1000000];//一定要开大，否则会re
void board(int tr,int tc,int dr,int dc,int size)
{
    if(size==1)    return;
    int t=tile,s=size/2;
    tile++;
    if(dr<tr+s&&dc<tc+s)    board(tr,tc,dr,dc,s);
    else    
    {
        a[tr+s-1][tc+s-1]=t;
        //存拐角处的横坐标
        if(xa[t]==0)            xa[t]=tr+s-1;
        else if(tr+s-1!=xb[t])    xb[t]=tr+s-1;
        else                    xa[t]=tr+s-1;
        //存拐角处的纵坐标
        if(ya[t]==0)            ya[t]=tc+s-1;
        else if(tc+s-1!=yb[t])    yb[t]=tc+s-1;
        else                    ya[t]=tc+s-1;
        board(tr,tc,tr+s-1,tc+s-1,s);
    }
    if(dr<tr+s&&dc>=tc+s)    board(tr,tc+s,dr,dc,s);
       else     
    {
        a[tr+s-1][tc+s]=t;
        if(xa[t]==0)            xa[t]=tr+s-1;
        else if(tr+s-1!=xb[t])    xb[t]=tr+s-1;
        else                    xa[t]=tr+s-1;
        if(ya[t]==0)            ya[t]=tc+s;
        else if(tc+s!=yb[t])    yb[t]=tc+s;
        else                    ya[t]=tc+s;
        board(tr,tc+s,tr+s-1,tc+s,s);
    }
    if (dr>=tr+s&&dc<tc+s)    board(tr+s,tc,dr,dc,s);
       else     
    {
        a[tr+s][tc+s-1]=t;
        if(xa[t]==0)            xa[t]=tr+s;
        else if(tr+s!=xb[t])    xb[t]=tr+s;
        else                    xa[t]=tr+s;
        if(ya[t]==0)            ya[t]=tc+s-1;
        else if(tc+s-1!=yb[t])    yb[t]=tc+s-1;
        else                    ya[t]=tc+s-1;
        board(tr+s,tc,tr+s,tc+s-1,s);
    }
    if(dr>=tr+s&&dc>=tc+s)    board(tr+s,tc+s,dr,dc,s);
    else    
    {
        a[tr+s][tc+s]=t;
        if(xa[t]==0)            xa[t]=tr+s;
        else if(tr+s!=xb[t])    xb[t]=tr+s;
        else                    xa[t]=tr+s;
        if(ya[t]==0)            ya[t]=tc+s;
        else if(tc+s!=yb[t])    yb[t]=tc+s;
        else                    ya[t]=tc+s;
        board(tr+s,tc+s,tr+s,tc+s,s);
    }
}
void print()
{
    for(int i=1;i<=tile-1;i++)//按编号先打印横纵坐标，然后判断形状
    {
        int x=xa[i],y=ya[i];
        cout<<x<<' '<<y<<' ';
        if(a[x-1][y]==i&&a[x][y-1]==i)        cout<<1<<endl;
        else if(a[x-1][y]==i&&a[x][y+1]==i)    cout<<2<<endl;
        else if(a[x][y-1]==i&&a[x+1][y]==i)    cout<<3<<endl;
        else if(a[x][y+1]==i&&a[x+1][y]==i)    cout<<4<<endl;
    }
}
int main()
{
    cin>>size>>dr>>dc;
    size=1<<size;
    a[dr][dc]=-1;
    board(1,1,dr,dc,size);
    print();
    return 0;    
}

```

---

## 作者：封禁用户 (赞：3)

首先考虑$k=1$的情况，若把某一格放空，方案是唯一的。已知某个正方形和空格，我们按照上下面的办法，可输出方案。首先延中心，将边长为$2^k$的矩形分成$4$个边长为$2^{k-1}$的矩形。那么空出来的格子，一定位于其中的一个，而另外的三个就可以让它们位于原矩阵中心的那个角空出来，这是一个子问题的结构，可以用到分治思想来解决啦。

---


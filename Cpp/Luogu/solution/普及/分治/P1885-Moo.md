# Moo

## 题目描述

奶牛 Bessie 最近在学习字符串操作，它用如下的规则逐一的构造出新的字符串：

$S(0) =$ `moo`

$S(1) = S(0) +$ `m` $+$ `ooo` $+ S(0) =$ `moo` $+$ `m` $+$ `ooo` $+$ `moo` $=$ `moomooomoo`

$S(2) = S(1) +$ `m` $+$ `oooo` $+ S(1) =$ `moomooomoo` $+$ `m` $+$ `oooo` $+$  `moomooomoo` $=$ `moomooomoomoooomoomooomoo`

$\dots$

Bessie 就这样产生字符串，直到最后产生的那个字符串长度不小于读入的整数 $N$ 才停止。

通过上面观察，可以发现第 $k$ 个字符串是由：第 $k-1$ 个字符串 $+$ `m` $+$  $(k+2$ 个 $o) +$ 第 $k-1$ 个字符串连接起来的。

现在的问题是：给出一个整数 $N (1 \leq N \leq 10^9)$，问第 $N$ 个字符是字母 `m` 还是 `o`？


## 说明/提示

样例解释：

由题目所知：字符串 $S(0)$ 是 `moo`, 现在要求第 $11$ 个字符，显然字符串 $S(0)$ 不够长；

同样 $S(1)$ 的长度是 $10$，也不够长；$S(2)$ 的长度是 $25$，够长了，$S(2)$ 的第 $11$ 个字符是 `m`，所以答案就输出 `m`。


## 样例 #1

### 输入

```
11```

### 输出

```
m```

# 题解

## 作者：FC是女孩子 (赞：43)

先模拟长度，L(i)=L(i-1)*2+k;（其中k为m+oooo……oo的个数）  
当超出n时，再模拟n在什么位置上。  
1：在L(i-1)上迭代处理  
2：在m+oooo……oo上，第一个是m，其他都是o  
3：在第二个L(i-1)上，那就不要n-L(i-1)-k，就回到L(i-1)上了  
```cpp
#include<cstdio>

int n,t=0,k=3;

int main()
{
	scanf("%d",&n);int m=n;
	while(t<=n) t=t*2+k,k++;
	k--;
	while(t>0)
	{
		t=(t-k)/2;
		if(m>t)
		{
			if(m<=t+k)
			{
				if(m==t+1) return printf("m"),0;
				else printf("o"),0;
			}
			else m=m-(t+k);
		}
		k--;
	}
	return 0;
}
```

---

## 作者：Starlight237 (赞：16)

本题是一道典型的分治题，这里就来讲讲它的详细解题方法。

首先，我们设$len_i$为第i次构成的长度，找规律可以得出：$$len_i=2*len_{i-1}+i+2$$而初始值moo满足$len_1=3$。若$len_0=0$显然也满足递推式。并且由题可知，最终的长度是满足$len_{ans}>=n$的最小的ans。

那么就可以这样预处理len和最终长度：
```cpp
inline int pre(){
	int ans;
	for(reg int i=1;len[i-1]<n||(ans=i,0);++i)len[i]=(len[i-1]<<1)+i+2;
	return ans;
}
```
然后求最小的m使$len_{m-1}<=n$

然后分3种情况讨论（注意必有n>len[m-1]，因为n属于S(m)而不是S(m-1)）：
- 如果n==len[m-1]+1显然是S(m-1)后面的那个m。
- 否则如果n<=len[m-1]+m+2则是中间的一大堆o之一。
- 否则递归，m变为m-1，n变为n-len[m-1]-m-2，即求解最右边的一部分。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define reg register
static int n,len[100001];
string str;
inline int pre(){
	int ans;
	for(reg int i=1;len[i-1]<n||(ans=i,0);++i)len[i]=(len[i-1]<<1)+i+2;
	return ans;
}
void dg(int m,int N){
	while(len[m-1]>N)--m;
	if(N==len[m-1]+1){putchar('m');return;}
	else if(N<=len[m-1]+m+2){putchar('o');return;}
	dg(m-1,N-len[m-1]-m-2);
}
int main(){
	scanf("%d",&n),dg(pre(),n);
	return 0;
}

```

---

## 作者：FLASH_CM (赞：12)

### [算法]
#### 【算法介绍】
暴力枚举会TLE，如果是打标会MLE，看大家都写的是分治，这里介绍一种利用深度优先遍历的做法。
#### 【算法实现】
1、我们首先对1至50号的字符串的长度进行预处理。

2、然后我们找到第一个长度大于询问的位置N的字符串。

3、开始进行深度优先搜索：
#### 【搜索策略】
(1)首先，我们知道任意一个字符串s[i]都是由s[i-1]接上中间的一部分内容再接上s[i-1]得到，我们将这三部分分别成为开头、中间、结尾，通过分析，可以算出开头的最后一个字符的位置和结尾的第一个字符的位置，我们将其成为左指针和右指针。

(2)分类讨论：

如果待求解的位置位于左指针和右指针的中间，即位于一个由一个m和多个o组成的字符串中时，若待求解的位置位于该字符串的第一位，则直接输出m，否则输出o。

如果待求解的位置位于左指针及其左边，则直接到s[i-1]中寻找当前位置。

如果待求解的位置位于右指针及其右边，则再s[i-1]中搜索待求解的位置在结尾字符串中的位置。

具体实现方法见程序
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

long long len[51];

void dfs(int weizhi,int num){
	int mid=len[num]/2,k=num/2+2,left,right;//通过找规律找到字符串中点字符的编号与开头字符串最后一个字符的编号之差的规律 
	if(num%2==0)
		k--;
	left=mid-k;								//分别找到开头字符串的最后一个字符和结尾字符串的第一个字符的位置 
	right=len[num]-left+1;
	if(weizhi>left && weizhi<right){		//如果查找的位置位于中间，则可以得出答案 
		if(weizhi==left+1)
			printf("m");
		else
			printf("o");
		exit(0);							//找到答案，直接退出程序 
	}else									//否则，在前后两个字符串中继续搜索 
	if(weizhi<=left){
		dfs(weizhi,num-1);
	}else{
		dfs(weizhi-right+1,num-1);			//weight-right+1为询问的位置在结尾字符串中的位置 
	}
}

int main(){
	int i,j,k,m,n;
	len[0]=3;
	for(i=1;i<=50;i=-~i)				//预处理1到50号字符串的长度 
		len[i]=2*len[i-1]+i+3;
	scanf("%d",&n);
	for(i=1;i<=50;i=-~i)				//找到第一个长度大于询问的位置N的字符串的编号 
		if(len[i]>=n)
			break;
	dfs(n,i);							//在找到的字符串中进行搜索 
	return 0;
}
```

---

## 作者：yangwenbin (赞：8)

# 题解 P1885 【Moo】

未完全理解题目的童鞋请走这（[传送门](https://www.luogu.com.cn/problem/P1885)）

现在开始讲解：

这道题比较简单，是一道基础的分治题。

具体什么是分治呢：

分治就是分而治之；吧一个整体分成几份，分开处理。

说会这道题，这里只用处理一部分，所以也可以说是多分。

题目中的规律如下：

```
S(0) = “moo”

S(1) = S(0) + “m”+ “ooo” + S(0) = “moo” + “m” + “ooo” + “moo” = “moomooomoo”

S(2) = S(1) + “m” + “oooo” + S(1) = “moomooomoo” + “m” + “oooo” + “moomooomoo” = “moomooomoomoooomoomooomoo”
```

所以就是一个字符串就是前一个字符串+‘m’+（2+x）个o再加前一个字符串。

故可以分成三段:
标记一个位置，看在那个位子。

故主体（function函数）就是一个三分。

```cpp
if(index==0){
	if(n==left){
		printf("m\n");
	}else{
		printf("o\n");
	}
	return;
}
int mid = (left+right)/2;
int num=index+3;
int l_left=left;
int l_right=left+f[index-1]-1;
int r_left=l_right+num+1;
int r_right=right;
if(n >= l_left && n <= l_right){
	function(l_left,l_right,index-1);
}
else if(n >= r_left && n<= r_right){
	function(r_left,right,index-1);
}
else {
	if (n==l_right+1){
		printf("m\n");
	}else{
		printf("o\n");
	}
	return ;
}
```
然后要确定长度没可以用递推；

公式是：f[i]=2*f[i-1]+i+3;

```cpp
f[0]=3;
int i;
for (i = 1; true ; ++i){
	f[i]=2*f[i-1]+i+3;
	if(f[i]>=n){
		break;
	}
}
```


# code
```
#include <bits/stdc++.h>
using namespace std;
long long n,f[10050];
void function(int left ,int right ,int index){
	if(index==0){
		if(n==left){
			printf("m\n");
		}else{
			printf("o\n");
		}
		return;
	}
	int mid = (left+right)/2;
	int num=index+3;
	int l_left=left;
	int l_right=left+f[index-1]-1;
	int r_left=l_right+num+1;
	int r_right=right;
	if(n >= l_left && n <= l_right){
		function(l_left,l_right,index-1);
	}
	else if(n >= r_left && n<= r_right){
		function(r_left,right,index-1);
	}
	else {
		if (n==l_right+1){
			printf("m\n");
		}else{
			printf("o\n");
		}
		return ;
	}
}
int main(){
	scanf("%d",&n);
	f[0]=3;
	int i;
	for (i = 1; true ; ++i){
		f[i]=2*f[i-1]+i+3;
		if(f[i]>=n){
			break;
		}
	}
	function(1,f[i],i);
}

```


---

## 作者：龙翔凤翥 (赞：7)

介绍两种思路OWO

1.递归算法，（分治思路）， 首先预处理一下第n个字符在被包含在第几个字符串里．然后在把这个字符串分成１，２，３三个区间（１区间和３区间是一模一样的字符），然后判断n在第几个区间，不断分治，将大问题分成几个小问题去求解（分治本质），最后注意边界处理即递推到了第一个字符串．

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],t;
inline char check(int x,int m)//递归
{
	if(m==0)//边界处理
	{
		if(x==1)return 'm';
		if(x==2)return 'o';
		if(x==3)return 'o';
	}//分成三个区间
	if(x<=a[m-1])return check(x,m-1);//如果在第１区间
	if(x>a[m]-a[m-1])return check(x-(a[m]-a[m-1]),m-1);//如果在第３间
	if(x==a[m-1]+1)return 'm';//如果在第２区间
	return 'o';//因为第２个区间时候１个'm'和k个'o＇组成，所以n如果是第２区间的第一个数，则返回'm'，否则返回＇o＇
}
inline int cur(int x)//在判断第n个字符是第几个字符串是顺便预处理每一个字符串有多长．
{
	int sum=3;
	int k=1;
	while(sum<x)
	{
		sum=sum*2+1+k+2;
		a[k]=sum;
		k++;
	}
	return k-1;
}
int main()
{
	int n;
	cin>>n;
	a[0]=3;
	t=cur(n);
	printf("%c\n",check(n,t));
	return 0;
}

```


---

## 作者：Deny_小田 (赞：7)

小田又来发题解啦~~~

注意到还是没有C++ 题解，果断一发。

我用了三种方法，只对了一种，可以供大家参考。

No.1 ： 用string += 字符串，得分：50

这个的思路很简单：其实就是模拟。

附代码：

/\*
得分：50

分点：Ac Ac Wa Wa Wa Ac Ac Ac MLE MLE

\*/

 
    
```cpp
#include <cstdio>
#include <string>
using namespace std;
int main(){
    int n;
    string s = "Moo",p = "ooo";
    scanf("%d",&n);
    for(; s.size() < n; ){
        s = s+"m"+p+s; 
        p += 'o';
    }
    printf("%c",s[n-1]);
    return 0;
}
```
No.2： 打表
我没有话可以说，直接输出一个m(o)居然能得60(40)分。

附代码：

/\*
得分：60

分点：Ac Wa Ac Ac Ac Wa Ac Wa Ac Wa

\*/

 
    

```cpp
#include <cstdio>
#include <string>
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    printf("m");
    return 0;
}
```
No.3：隆重介绍 分治算法 得分：100
递归。。。需要稍微注意一下参数。。。然后。。。然后就AC了

附上代码：

/\*
得分：100

分点：Ac Ac Ac Ac Ac Ac Ac Ac Ac Ac

\*/




  


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define Size 100005
using namespace std;
typedef long long type;
type n;
string str;
int t[Size];
int start(int p);
void solve(int q,int n);
int main(){
    int cnt = 0;
    cin >> n;
    cnt = start(n);
    solve(cnt,n);
    return 0;
} 
int start(int p){
    int now,i = 1;
    t[0] = 0;
    while(1){
        t[i] = 2*t[i-1]+(i+2);
        if(t[i] >= p){ now = i; break; }
        i++;
    }
    return now;
}
void solve(int q,int n){  
    while(t[q-1] > n) q--;  
    if(n == t[q-1]+1){  
        printf("m\n"); 
        return ;  
    }else if(n <= t[q-1]+q+2){  
        printf("o\n");
        return ;  
    }  
    solve(q-1,n-(t[q-1]+q+2));  
}
```

---

## 作者：「QQ红包」 (赞：5)

分治……

摘自http://bluebag.sinaapp.com/%e6%b4%9b%e8%b0%b7%e9%a2%98%e8%a7%a3%e3%80%90p1885-moo%e3%80%91%e3%80%90%e9%9a%be%e5%ba%a6%ef%bc%9a%e5%85%a5%e9%97%a8%e6%99%ae%e5%8f%8a-%e3%80%91/

```delphi

var n,p:int64;
 i:longint;
 procedure try(a,b:int64);
 begin
 　　if ((a-b-3) shr 1<n)and(n<=(a-(a-b-3) shr 1)) then//(a-b-3) shr 1是 a*2+b+3 的逆运算
 　　begin
 　　　　if (n-((a-b-3) shr 1))<>1 then writeln('o')//输出
 　　　　　　　　　　　　　　　　　　　　　　else writeln('m');//输出
 　　halt;
 　　end;
 　　if (a-b-3) shr 1>n then
 　　　　try((a-b-3) shr 1,b-1)//继续往下找
 　　else
 　　begin
 　　　　n:=n-(a-(a-b-3) shr 1);
 　　　　try((a-b-3) shr 1,b-1)// 继续往下找
 　　end;
 end;
 begin
 　　readln(n);//输入
 　　for i:=0 to 100000 do
 　　begin
 　　　　p:=p*2+i+3;
 　　　　if p>n then
 　　　　break;
 　　end;//找出第一个大于N的f()的长度
 　　try(p,i)
 end.

```

---

## 作者：Peter_Z (赞：4)

思路：

暴力模拟肯定会T，这里提供分治的算法。

先求出前若干个字符串的**长度**

将第c个字符串**分成三部分处理**：

开头的第c-1个字符串，中间的m和若干个o，结尾的第c-1个字符串。

这里为方便描述简称为开头，中间和结尾。

当n为开头第一个或中间第一个的m时，输出m并结束程序。

当n为开头第二/第三个或中间非第一个的o时，输出o并结束程序。

当n在开头的非前三个时，搜索n在第c-1个字符串的情况。

当n在结尾的非第一个时，搜索n-前面的字符长度在第c-1个字符串的情况。

附代码：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
long long len[10001];        //保存前10001个字符串的长度 
inline void print(char out) {
    putchar(out),exit(0);        //打印字符(m或o)并结束程序 
}
void dfs(int n,int c) {        //搜索在第c个字符串的情况下第n个字符是m还是o 
    if(n==1 or n==len[c-1]+1) {    //开头的m或中间的m 
        print('m');
    } else if(n<=3 or (n>len[c-1] and n<=len[c-1])) {    //开头的o或中间的o 
        print('o');
    } else if(n>len[c-1]+c+3) {
        //若在结尾的字符串里 
        n-=len[c-1]+c+3;    //删去前面无用的字符 
        c--;
        dfs(n,c);    //深搜 
    } else {
        //若在开头的字符串里 
        c--;
        dfs(n,c);    //深搜 
    }
}
int main() {
    int n,i;
    scanf("%d",&n);
    len[0]=3;
    for(i=1; len[i-1]<n; i++) {    //计算第i个字符串长度 
        len[i]=len[i-1]*2+i+3;
    }
    dfs(n,i-1);        //由于多加了一个所以要i-1 
    return 0;
}
```

---

## 作者：koukou (赞：2)

一道分治板子题

## 思路

首先求出第 $N$ 个字符属于哪个字符串，再把它分为题目中给的三个区间，对于每个区间，再递归去求对应的字符就行了。

因为字符构建的规律是一个 ```m``` 加 $k+2$ 个 ```o```，所以应该是很容易求的。

---

## 作者：废物yehan (赞：0)

**变量名很清楚了，大家应该光看名字就能看懂了**
```cpp
#include<bits/stdc++.h>
using namespace std;
int moodown(int x,int kx){
	int y=x-3-kx;
	return y/2;
}
/*int mooup(int x,int kx){
	int y=x*2+4+kx;
	return y;
}

void printm(){
	cout<<"m"<<endl;
}
void printo(){
	cout<<"o"<<endl;
}*/
char find(int k,int length,int target){
	int lengthdown=moodown(length,k);
	//int lengthup=mooup(length,k);
	if(target<=lengthdown){
		return find(k-1,lengthdown,target);
	}
	if(target>lengthdown&&target<=(lengthdown+3+k)){
		if((target-lengthdown)%(3+k)==1) return 'm';
		else return 'o';
	}
	if(target>(lengthdown+3+k)){
		return find(k-1,lengthdown,(target-lengthdown-3-k));
	}
}
int main(){
	int n;
	cin>>n;
	int flens=0,fs=0;
	for(int s=0;;s++){
		int lens=2*flens+1+s+2;
		flens=lens;
		if(lens>=n){
			fs=s;
			break;
		}
	}
	cout<<find(fs,flens,n)<<endl;
	return 0;
}
```


---


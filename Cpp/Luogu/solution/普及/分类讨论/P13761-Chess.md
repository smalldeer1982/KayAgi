# Chess

## 题目背景

小 P 最喜欢玩象棋了！有一天他看到一个软件名叫《万宁象棋》，玩了几次，结果输麻了，于是他来找你帮忙。

## 题目描述

万宁象棋的棋盘有 $n$ 行 $m$ 列（可以把棋盘看做坐标系的第一象限），现在一局棋已经进入尾声。小 P 只有一个象和一个帅，象在左下角 $(1,1)$ 的位置，而对方只有一个将在右上角 $(n,m)$ 的位置。

已知现在小 P 先手。他每次可以移动象，象走“田”字，但不能走出棋盘外，且受到塞象眼的限制；或者也可以移动帅。假设帅的移动既不会影响象，也不会影响对方的将。

**象的移动规则（了解中国象棋规则者可跳过）：**

象每次可以沿斜线方向走两格，即在“田”的左下角，右上角移动或在左上角，右下角移动。形式化的描述，假设象处在 $(x,y)$ 的位置，那么下一步可以到达 $(x+2,y+2)$、$(x+2,y-2)$、$(x-2,y+2)$、$(x-2,y-2)$ 这四个格子中的一个。

“塞象眼”即指“田”字的中间有棋子，也就是象走的两格的中间一格有棋子阻挡，则不能行走。

对方的将~~很傻~~，每次只会按照下 $\rightarrow$ 左 $\rightarrow$ 上 $\rightarrow$ 右的顺序走，也就是从 $(n,m)$ 走到 $(n-1,m)$，再走到 $(n-1,m-1)$，然后走到 $(n,m-1)$，最后走回 $(n,m)$。

请你帮忙看一看，小 P 的象能不能吃掉对方的将。如果可以，则输出最小步数；如果不可以，输出 ```-1```。

## 说明/提示

**【样例 1 解释】**

小 P 的象先到 $(3,3)$，此时对方的将从 $(6,5)$ 到达 $(5,5)$。下一步的象正好可以到 $(5,5)$，吃掉将，共计 $2$ 步。

**【样例 2 解释】**

小 P 先动两步帅，使得对方的将到达 $(3,3)$，再移动象到达 $(3,3)$，吃掉将，共计 $3$ 步。

**【数据规模与约定】**

对于 $100\%$ 的数据，$3\leq n,m\leq 10^{18}$。

|测试点|$n$|$m$|
|:-:|:-:|:-:|
|$1$|$3 \leq n \leq 10$|$m=n$|
|$2$|$3 \leq n \leq 10$|$3 \leq m \leq 10$|
|$3\sim 4$|$3 \leq n \leq 500$|$m=n$|
|$5\sim 6$|$3 \leq n \leq 500$|$3 \leq m \leq 500$|
|$7\sim 9$|$3 \leq n \leq 10^5$|$m=n$|
|$10\sim 12$|$3 \leq n \leq 10^5$|$3 \leq m \leq 10^5$|
|$13\sim 16$|$3 \leq n \leq 10^{18}$|$m=n$|
|$17\sim 20$|$3 \leq n \leq 10^{18}$|$3 \leq m \leq 10^{18}$|

## 样例 #1

### 输入

```
6 5```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4```

### 输出

```
3```

## 样例 #3

### 输入

```
4 5```

### 输出

```
-1```

# 题解

## 作者：buba1kk1ng (赞：1)

# Solution （P13761）

## 题目理解

**形式化**地讲，题目是两个点在一个 $n \times m$ 的平面中，在 $1$ 单位时间内，A 点（象）在 $(i, j)$ 时可以移至 $(i + 2, j + 2)$ 或 $(i + 2, j - 2)$ 或 $(i - 2, j + 2)$ 或 $(i - 2, j - 2)$，也可以**不移动 A 点**（移动帅）。在过去了 $t$ 单位时间后，若 $t \bmod 4 = 0$，B 点处于 $(n, m)$；若 $t \bmod 4 = 1$，B 点处于 $(n - 1, m)$；若 $t \bmod 4 = 2$，B 点处于 $(n - 1, m - 1)$；若 $t \bmod 4 = 3$，B 点处于 $(n, m - 1)$。问有没有一时刻使 AB 两点**重合**。若有，输出其单位时间**最小值**。若无，输出 `-1`。

## 主要思路

### 移动策略

棋盘可能接近正方形，也可能长宽相差大，但使步数最少的都是先向右下移动。而对于长宽相差大的，应以若干次近似平移来靠近将。如，先往右上，再往右下。其效果等价于往右平移 $4$ 格。

### 无法吃将

如上文这样，每次平移 $4$ 格，就会有够不着的情况。若往右下移动到无法再移，且后接近将时，无法再做平移，而是做了半个，就无法吃将。

### 最后一步

到了将移动的范围内，可以在象到达的前一步移动帅增加步数使将移动，这样就可以吃掉将。**塞象眼**经过枚举，可以不用考虑。因为在移动帅使下一步象必然吃将的情况下，必然不会受到塞象眼的限制。所以总步数就是：

$$
右下移动步数 + 近似平移移动步数 + 帅移动步数
$$

## 参考代码

```cpp
int main()
{
    ll n, m;
    ll step, stp, stn;

    read(n), read(m);   //快读
    n--, m--;  //从 (1, 1) 开始
    ll pn = n & 1, pm = m & 1;  //判定最后会到将移动范围四格的哪一格

    if (m >= n)
    {
        m = m - n + pn; //计算右下走完后还需走的格数
        m >>= 1;  //计算步数
        if (m & 1)
        {
            writeln(-1);  //做了半个，详见“无法吃将”板块
            return 0;
        }
        step = (n >> 1) + m;
        stp = step % 4;
        if (!pn & !pm)
            stn = 1;
        else if (pn & !pm)
            stn = 2;
        else if (pn & pm)
            stn = 3;
        else
            stn = 4;  //判定将在将移动范围内的哪一格吃将

        if (stn >= stp)
            step += (stn - stp);
        else
            step += (4 - stp) + stn;  //帅移动的步数
    }

    else if (m < n) // 同上，从水平平移到垂直平移
    {
        n = n - m + pm;
        n >>= 1;
        if (n & 1)
        {
            writeln(-1);
            return 0;
        }
        step = (m >> 1) + n;
        stp = step % 4;
        if (!pn & !pm)
            stn = 1;
        else if (pn & !pm)
            stn = 2;
        else if (pn & pm)
            stn = 3;
        else
            stn = 4;

        if (stn >= stp)
            step += (stn - stp);
        else
            step += (4 - stp) + stn;
    }

    writeln(step);  //快写

    return 0;
}
```

## 其他

此题建议标橙或黄。

---

## 作者：Milky_Cat (赞：1)

小模拟。

不妨枚举将走到了哪一个位置，然后判断象是否能走到。

考虑象走道的位置有什么特征，枚举发现 $x$ 和 $y$ 差的变化量非 $0$ 即 $4$，也就是 $x$ 和 $y$ 的差模 $4$ 余 $0$ 的时候可以走到。

有了这个结论，就可以对此进行分类讨论，时间复杂度 $O(1)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m, p;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n >> m;
	int x = n, y = m;
	if (abs(x - y) % 4 == 0 && (x & 1) && (y & 1)){
		cout << max(x / 2, y / 2) + (5 - max(x / 2, y / 2) % 4) % 4;
        p = 1;
    }
	x--;
	if (abs(x - y) % 4 == 0 && (x & 1) && (y & 1)){
		cout << max(x / 2, y / 2) + (6 - max(x / 2, y / 2) % 4) % 4;
        p = 1;
    }
	y--;
	if (abs(x - y) % 4 == 0 && (x & 1) && (y & 1)){
		cout << max(x / 2, y / 2) + (7 - max(x / 2, y / 2) % 4) % 4;
        p = 1;
    }
	x++;
	if (abs(x - y) % 4 == 0 && (x & 1) && (y & 1)){
		cout << max(x / 2, y / 2) + (4 - max(x / 2, y / 2) % 4) % 4;
        p = 1;
    }
    if (!p)
        cout << -1;
	return 0;
}
```

---

## 作者：Indestructible (赞：0)

## 题意

在一个 $n$ 行 $m$ 列的棋盘上有一个象棋中的象在 $(1,1)$ 的位置，每一步可以按规则移动或不移动（即原题面中移动己方的帅）。另有一个对方的将在 $(n,m)$ 的位置，移动顺序为 $(n,m)\to (n-1,m)\to(n-1,m-1)\to(n,m-1)$ 循环。请输出象吃掉将的最小步数，或判断无解，此时输出 $-1$。

## 解法

由于象的移动规则是横向移动两格且纵向移动两格，所以象的横纵坐标一定是奇数，且对 $4$ 取模的值相等。判断将所在的四个位置是否满足条件，由于将的 $4$ 个位置中只有一个横纵坐标均为奇数，故只有这一个位置是象可能可达的，对其判断第二个条件（模 $4$ 相等）。

到这里，无解情况和最终象走到的位置已经判出来了，直接输出步数即可。计算步数非常简单，答案为 $\lfloor\dfrac{\max(n,m)}{2}\rfloor$，手推可以很容易得出。不需要判断塞象眼的情况，棋盘上没有棋子能够塞象眼且影响最终结果。这一点也易证。

**注意：将的位置是变化的，即我们确定的将的位置每 $\mathbf 4$ 轮移动才会出现一次**。需要对答案加上一个小于 $4$ 的数以保证其对 $4$ 取模的正确性。

感谢 @[Fine_Dust_Z](https://www.luogu.com.cn/user/1317007) 大佬指出[**需要开 `unsigned long long`**](https://www.luogu.com.cn/discuss/1138089)。

Upd：不会爆 `long long`，因为之前代码的 13 行[写出负数](https://www.luogu.com.cn/record/232146781)了，开 `unsigned long long` 就玄学通过了。

## 代码

所以当开了 `long long` WA 时，就试试开 `unsigned long long`，也许就[过了](https://www.luogu.com.cn/record/232167612)呢。

不过下面是只开 `long long` 的正解。

```cpp line-numbers
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, mod4;
signed main(){
	cin >> n >> m;
	if ( (n & 1) &&  (m & 1)) mod4 = 1;
	if (!(n & 1) &&  (m & 1)) mod4 = 2, n --;
	if (!(n & 1) && !(m & 1)) mod4 = 3, n --, m --;
	if ( (n & 1) && !(m & 1)) mod4 = 0, m --;
	if (n % 4 != m % 4){ cout << -1; return 0; }
	int ans = max(n, m) >> 1;
	ans += (mod4 + 4 - (ans % 4)) % 4; // 这里的 ans 要对 4 取模防出现负数
	cout << ans;
	return 0;
}
```

[最终 AC 记录](https://www.luogu.com.cn/record/232214807)。

---

## 作者：wuhaolinwhl (赞：0)

## [P13761](https://www.luogu.com.cn/problem/P13761)题解  
题目大意  
没啥好说的就是看象能否从 $(1,1)$ 走到 $(n,m)$，$ (n−1,m)$，$(n-1,m-1)$，$(n,m−1)$。  
解题思路  
因为象从 $(1,1)$ 开始走，且象走的是田字格，所以只要记录将四种位置中哪一个位置 $x,y$ 都是奇数，最后求得 $(x-1)\div2$ 和 $(y-1)\div2$ 的较大值，并加上其模 $4$ 与 $(x,y)$ 是四种位置的哪一种的差值就行了。  
题目较简单，大致为红，橙左右。  
代码如下。  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,cnt,ans,ansx,ansy,op,an=1e9;
int dx[4]={0,-1,-1,0};
int dy[4]={0,0,-1,-1};
int main(){
	cin>>n>>m;
	long long x,y,k=0;
	for(int i=0;i<=3;i++)
	{
		x=dx[i]+n;
		y=dy[i]+m;
		if(x%2==1&&y%2==1)
		{
			k=1;
			ansx=x;
			ansy=y;
			cnt=i;
		}
	}
	if(k==1)
	{
		ans=max((ansx-1)/2,(ansy-1)/2);
		while(ans%4!=cnt+1)
		{
			ans++;
		}
		cout<<ans<<endl;
	}
	else
	{
		cout<<-1;
	}
	return 0;
}

```
完结撒花。

---

## 作者：lyx128 (赞：0)

我们考虑使用数学方法与小暴力实现本题目。

暴力指的是暴力现在敌方将的位置，其实就只有 $4$ 次。

数学指的是计算现在的象是否可以走到敌方的将现在所在的位置。

由于象是从 $(1,1)$ 起步的，所以需要加入奇偶性判断，即将所在的位置都是奇数。而象还可能平移，所以还需要判定两点值和的奇偶性。剩下的就是简单的数学计算了。注意，一定要注意边界判定！！！

代码示例：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll __int128
const ll oo=1e37;
ll n,m;
ll d[4][2]={{0,0},{-1,0},{-1,-1},{0,-1}};
ll ans=oo;
ll read(){
	ll x=0;
	ll ch=getchar_unlocked();
	while(!isdigit(ch))
		ch=getchar_unlocked();
	while(isdigit(ch))
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar_unlocked();
	return x;
}
void print(ll x){
	if(!x)
		return ;
	print(x/10);
	cout<<(int)(x%10);
	return ;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	n=read();
	m=read();
	for(int i=0;i<4;i++){
		ll dx=n+d[i][0];
		ll dy=m+d[i][1];
		if(dx<1||dy<1)
			continue;
		if((dx&1)&&(dy&1)&&!(((dx-1)/2+(dy-1)/2)&1)){
			ll dis_a=(dx-1)/2;
			ll dis_b=(dy-1)/2;
			ll dis_max=max(dis_a,dis_b);
			ll res=(i+1)+4*((dis_max-(i+1)+3)/4);
			ans=min(ans,res);
		}
	}
	if(ans==oo)
		cout<<-1<<"\n";
	else{
		print(ans);
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：pxb0801 (赞：0)

**本题解只讲述满分做法。**

------------
## 1.思路分析

这道题虽然 $n$ 和 $m$ 的范围很大，但象可以到达的位置有限。那么我们来看一看，象所能到达的位置有什么特征呢？

- $2 \nmid n,m$
- $4 \mid (n-m)$

第一个很好理解，因为象开始的行与列都是奇数，而每次走的行与列都是加或减偶数，所以行与列永远都是奇数。

而第二个也很好理解，因为象开始的行列之差为 $0$，是 $4$ 的倍数，每次走，行列差不是加 $4$ 就是不变，当然还是 $4$ 的倍数。

因此我们可以得到这个发现：**如果象可以吃掉将，那么吃掉的位置有且仅有一个**。

因此，主函数代码就出来了：

```cpp
cin>>n>>m;
if(n%2&&m%2&&(n-m)%4==0){//分别从4个位置看能否吃掉
	cout<<work(n,m);//输出最小步数
}
else if((n-1)%2&&m%2&&((n-1)-m)%4==0){
	cout<<work(n-1,m);
}
else if((n-1)%2&&(m-1)%2&&((n-1)-(m-1))%4==0){
	cout<<work(n-1,m-1);
}
else if(n%2&&(m-1)%2&&(n-(m-1))%4==0){
	cout<<work(n,m-1);
}
else cout<<-1;//都不行就输出-1
```


-----------------
## 2.计算步数

先给出代码：

```cpp
ll work(ll nn,ll mm){
	ll cnt=max(nn/2,mm/2);
}
```

步数如何计算呢？首先可以确定的一点，就是象主要的路线是从左下到右上，且每次行数，列数至少一个加 $2$。所以从 $(1,1)$ 到 $(nn,mm)$ 所需的最小步数就是

$$cnt=\max\{\dfrac{nn}{2},\dfrac{mm}{2}\}$$

那当我们在到达 $(nn,mm)$ 前一步（也就是在 $(nn-2,mm-2)$ 时，我们通过移动帅等对方的将移动到 $(nn,mm)$，那么我们需要移动帅几次呢？

当吃掉的位置为 $(n-1,m)$ 时，我举了一个例子搜索如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/e1nfqffh.png)

很明显对于此图，$cnt=6$。我们现在顺着来：当象到达 $(3,11)$ 时，移动的步数 $cntt=5$，我们要等对方的将到 $(5,13)$，需要等几步呢？（就是要移动几步自己的帅）

用此时的 $cntt$，也就是 $5$，对 $4$ 取余，是 $1$，也就是说当到达 $(5,13)$ 时，对方的将正好移动到 $(5,13)$，所以等待时间为 $0$，返回答案就是 $cnt+0=6$。

代码：

```cpp
const int fx[5]={-1,0,1,0},fy[5]={0,-1,0,1};
	int w=(cnt-1)%4,dn=n,dm=m,cntt=0;
	for(int i=0;i<w;i++){
		dn+=fx[i],dm+=fy[i];
	}
	for(int i=w;dn!=nn||dm!=mm;i=(i+1)%4){
		dn+=fx[i],dm+=fy[i];
		cntt++;
	}
	return cnt+cntt;
```

这里的 $w$ 按照刚刚举的例子就是走到 $(3,11)$，也就是即将吃掉对方将的地方，需要的步数，也是对方将走的步数。

接下来计算在这 $w$ 步里，对方的将走到了哪里。注意看到方向数组，是按照下，左，上，右的顺序。

然后我们要再看，对方的将要移动到象能吃到的格子，需要移动几步，这里等待的时间要加。

最终返回移动象的步数加上等待的步数。

---


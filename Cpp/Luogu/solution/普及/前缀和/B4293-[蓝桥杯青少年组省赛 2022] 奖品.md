# [蓝桥杯青少年组省赛 2022] 奖品

## 题目描述

有一个 $N \times M$ 的矩阵方格，其中有些方格中有奖品，有些方格中没有奖品。小蓝需要从 $N \times M$ 的矩阵中选择一个正方形区域，如果所选的正方形区域的一个对角线方格中都有奖品，其他方格都没有奖品，就会获得所选区域中的所有奖品，否则不能获得奖品。

当给出 $N$ 和 $M$ 的值，及 $N \times M$ 的矩阵方格中摆放的奖品情况（$0$ 表示方格中没有奖品，$1$ 表示方格中有奖品），请你帮助小蓝找出一个正方形区域，能够获得数量最多的奖品，并将奖品数输出。


## 样例 #1

### 输入

```
5 6
1 0 1 0 0 0
0 1 0 1 0 0
1 0 0 0 1 0
0 1 0 0 0 1
1 0 1 0 0 0```

### 输出

```
4```

# 题解

## 作者：yuruilin2026 (赞：2)

## 一些闲话：
~~超级大暴力来也。~~\
这个理论最差 $O(n^4)$ 的程序成功跑出了超高效率。\
甚至跑的比某些 $O(n^3)$ 还快一些。\
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)，是 TA 教我的程序优化。
## 思路：
暴力 $O(n^3)$ 枚举正方形四个顶点，然后暴力验证。\
因为这是一个正方形，枚举左上角顶点坐标和边长就可以表示出这个正方形四个顶点的坐标。\
接下来暴力验证对角线，是否全是 $1$，并且其他地方都不是 $1$，如果满足就计入答案。\
这里是不是又要用 $O(n^2)$ 的时间复杂度检验呢？\
不是的，我们可以用二维前缀和预处理区间内一共多少个奖品，如果奖品数和边长不一样，就剪枝。\
~~虽然前缀和好像有更好的做法。~~\
这样既可以只用处理对角线，又能继续优化时间。\
直接上代码吧：
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define endl "\n"
int a[105][105],n,m,len,sum[105][105],a1,a2,b1,b2,c1,c2,d1,d2,ans = 1,f1,f2; 
signed main(){
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	len = min(n,m);
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= m;++j){
			cin >> a[i][j];
			sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j];
		}
	}
	if(sum[n][m] == 0){
		cout << 0;
		return 0;
	}
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= m;++j){
			for(int p = ans;p <= len;++p){
				if(i + p - 1 > n || j + p - 1 > m) break;
				a1 = i,a2 = j;//左上 
				b1 = i + p - 1,b2 = j;//左下 
				c1 = i,c2 = j + p - 1;//右上 
				d1 = i + p - 1,d2 = j + p - 1;//右下 
				if(sum[d1][d2] - sum[c1-1][c2] - sum[b1][b2-1] + sum[a1-1][a2-1] != p) continue;
				int x = i,y = j;
				f1 = 0,f2 = 0;
				while(x != d1+1 && y != d2+1){//验证左上到右下 
					if(a[x][y] == 0){
						f1 = 1;
						break;
					}
					++x,++y;
				}
				if(f1 == 0){
					ans = max(ans,p);
					continue;
				}
				x = b1,y = b2;
				while(x != c1-1 && y != c2+1){//验证左下到右上 
					if(a[x][y] == 0){
						f2 = 1;
						break;
					}
					--x,++y;
				}
				if(f2 == 0){
					ans = max(ans,p);
					continue;
				}
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：chenxinran12 (赞：1)

### 题意分析
给定一个矩阵，求出一个正方形，使得这个正方形只有**主对角线**或**副对角线**上的点为 $1$，**其他位置**为 $0$。最后需要求出这个合法的正方形里的对角线的长度。
### 思路
这道题显然是一道前缀和题，于是我们就用这个思路来解题。

我们先用 $b_{i,j}$ 记录这个数组的前缀和，再模拟遍历正方形的左上角（主对角线）与右上角（副对角线），之后再记录答案。

假设我遍历到了点 $a_{i,j}$ 为 $1$，那么我们可以把它当成左上角和右上角分别考虑。  
当 $a_{i,j}$ 为左上角时，使用两个变量 $ii$，$jj$ 作为这个正方形的右下角的坐标，然后去判断这个正方形是否只有这条对角线为 $1$，作为右上角时同理，不过 $ii$，$jj$ 变成了左下角的坐标而已。
```cpp
int ii=i,jj=j,tot=0;  //ii,jj为右下角,tot记录答案 
while(ii<=n&&jj<=m&&a[ii][jj]==1&&b[ii][jj]-b[i-1][jj]-b[ii][j-1]+b[i-1][j-1]==tot+1) //如果这个点未越界，且这个正方形只有主对角线为1，更新答案
  tot++,ii++,jj++;  //继续找右下角
ans=max(ans,tot);  //更新答案 
tot=0;//答案清空
ii=i,jj=j;      //ii,jj为左下角 
while(ii<=n&&jj>0&&a[ii][jj]==1&&b[ii][j]-b[i-1][j]-b[ii][jj-1]+b[i-1][jj-1]==tot+1)  //如果这个点未越界，且这个正方形只有副对角线为1，更新答案
  tot++,ii++,jj--; //继续找左下角
ans=max(ans,tot);  //更新答案 
```
写出这个部分之后，剩下的便是平常的二维前缀和记录了。
### 完整code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[102][102],b[102][102],ans,tot;
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j]; //记录前缀和 
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]==1)   //如果为一，就可以作为左/右上角 
			{ 
				int ii=i,jj=j;  //ii,jj为右下角 
				while(ii<=n&&jj<=m&&a[ii][jj]==1&&b[ii][jj]-b[i-1][jj]-b[ii][j-1]+b[i-1][j-1]==tot+1) //如果这个点未越界，且这个正方形只有主对角线为1，更新答案
					tot++,ii++,jj++;
				ans=max(ans,tot);  //更新答案 
				tot=0;
				ii=i,jj=j;      //ii,jj为左下角 
				while(ii<=n&&jj>0&&a[ii][jj]==1&&b[ii][j]-b[i-1][j]-b[ii][jj-1]+b[i-1][jj-1]==tot+1)  //如果这个点未越界，且这个正方形只有副对角线为1，更新答案
					tot++,ii++,jj--;
				ans=max(ans,tot);  //更新答案 
				tot=0;
			}
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：huangzhiyuanhzy (赞：0)

我们需要在一个给定的 $N×M$ 由 $0$ 和 $1$ 组成的矩阵中找到一个最大的正方形区域，满足主对角线（从左上到右下）或副对角线（从右上到左下）上的所有格子都是 $1$，其他格子都是 $0$。

再找到满足条件的最大正方形，同时检查其他格子是否全为 $0$，输出其边长（即对角线上的 $1$ 的个数）。

还可以优化一下检查过程，从最大可能的 $k$ 开始检查，一旦找到满足条件的正方形就可以停止检查更小的 $k$。

当然也可以用动态规划来优化，使用 DP 记录以每个点为终点的最长对角线长度。

这样时间复杂度为 $O(N^3)$，因为有三层嵌套循环：

- 外层两重循环遍历所有可能的左上角点：$O(N^2)$；

- 内层循环检查所有可能的边长：$O(N)$；

- 每个正方形的检查：$O(N^2)$。

但是由于我们进行了优化（从大到小检查边长，找到就跳出），实际运行时间会比理论复杂度好很多。

提一下空间复杂度为 $O(N^2)$，用于存储矩阵数据。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int g[103][103];
int res;
bool a(int x,int y,int k){ 
    for(int i=0;i<k;i++)
        if(g[x+i][y+i]!=1)
            return false;
    return true;
}
bool b(int x,int y,int k){
    for(int i=0;i<k;i++)
        if(g[x+i][y+k-1-i]!=1)
            return false;
    return true;
}
bool c(int x,int y,int k,bool t){ 
    for(int i=x;i<x+k;i++){
        for(int j=y;j<y+k;j++){
            if(t&&i-x!=j-y&&g[i][j]!=0) return false;
            if(!t&&i-x!=k-1-(j-y)&&g[i][j]!=0) return false;
        }
    }
    return true;
}

int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            cin>>g[i][j];
    for(int x=0;x<n;x++){
        for(int y=0;y<m;y++){
            int k=min(n-x,m-y);
            for(;k>=1;k--){
                if(k<=res) break;
                if(a(x,y,k)&&c(x,y,k,1)){
                    res=k;
                    break;
                }
                if(b(x,y,k)&&c(x,y,k,0)){
                    res=k;
                    break;
                }
            }
        }
    }
    cout<<res;
    return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4293)
### 思路
一道前缀和~~  
用数组 $b_{i,j}$ 记录行的前缀和，用数组 $c_{i,j}$ 
对于一条对角线，有从左上到右下和从右上到左下两种情况。   
如果这条对角线是从左上到右下的。我们假设这个正方形左上角坐标为 $(i,j)$（编程数组中的坐标）。一个位置 $(x,y)$ 合法的条件是：
1. $x-i = y-j$。
2. $b_{x,y} - b_{x,j-1} = 1$。
3. $c_{x,y} - c_{i-1,y} = 1$。
4. 这个位置有奖品（一定要注意这一点）。
5. 对于每一个满足 $1 \le k \le x-i$ 的整数 $k$，$(i+k,j+k)$ 均满足条件。

从右上到左下的对角线同理。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,i,j,a[1001][1001],b[1001][1001],c[1001][1001],s,x,y,ma;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			cin>>a[i][j];
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			b[i][j]=a[i][j]+b[i][j-1];//行的前缀和
	for(i=1;i<=m;i++)
		for(j=1;j<=n;j++)
			c[j][i]=a[j][i]+c[j-1][i];//列的前缀和
	
	for(i=1;i<=n;i++)  //从左上到右下
		for(j=1;j<=m;j++){
			s=0;
			for(x=i,y=j;x<=n,y<=m;x++,y++)
				if(a[x][y]==1&&b[x][y]-b[x][j-1]==1&&c[x][y]-c[i-1][y]==1) s++;
				else break;
			ma=max(ma,s);
		}
	
	for(i=1;i<=n;i++)  //从右上到左下
		for(j=1;j<=m;j++){
			s=0;
			for(x=i,y=j;x<=n,y>=1;x++,y--)
				if(a[x][y]==1&&b[x][j]-b[x][y-1]==1&&c[x][y]-c[i-1][y]==1) s++;
				else break;
			ma=max(ma,s);
		}
	
	cout<<ma;
}
```

---

## 作者：Mark_Pei (赞：0)

## Solution

我们需要在一个给定的 $N×M$ 由 $0$ 和 $1$ 组成的矩阵中找到一个最大的正方形区域，满足主对角线（从左上到右下）或副对角线（从右上到左下）上的所有格子都是 $1$，其他格子都是 $0$。

再找到满足条件的最大正方形，同时检查其他格子是否全为 $0$，输出其边长（即对角线上的 $1$ 的个数）。

还可以优化一下检查过程，从最大可能的 $k$ 开始检查，一旦找到满足条件的正方形就可以停止检查更小的 $k$。

当然也可以用动态规划来优化，使用 DP 记录以每个点为终点的最长对角线长度。

这样时间复杂度为 $O(N^3)$，因为有三层嵌套循环：

- 外层两重循环遍历所有可能的左上角点：$O(N^2)$；

- 内层循环检查所有可能的边长：$O(N)$；

- 每个正方形的检查：$O(N^2)$。

但是由于我们进行了优化（从大到小检查边长，找到就跳出），实际运行时间会比理论复杂度好很多。

提一下空间复杂度为 $O(N^2)$，用于存储矩阵数据。

本人这里使用函数封装检查检查对角线，更清晰一点。

**AC code**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;//行和列
int g[103][103];//网格
int res;//结果
bool a(int x,int y,int k)//检查主对角线
{ 
    for(int i=0;i<k;i++)
        if(g[x+i][y+i]!=1)
            return false;
    return true;
}
bool b(int x,int y,int k)//检查副对角线
{ 
    for(int i=0;i<k;i++)
        if(g[x+i][y+k-1-i]!=1)
            return false;
    return true;
}
bool c(int x,int y,int k,bool t)//检查其他格子
{ 
    for(int i=x;i<x+k;i++) 
    {
        for(int j=y;j<y+k;j++) 
        {
            if(t&&i-x!=j-y&&g[i][j]!=0) return false;
            if(!t&&i-x!=k-1-(j-y)&&g[i][j]!=0) return false;
        }
    }
    return true;
}

int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            cin>>g[i][j];
    for(int x=0;x<n;x++) 
    {
        for(int y=0;y<m;y++) 
        {
            int k=min(n-x,m-y);
            for(;k>=1;k--) 
            {
                if(k<=res) break;
                if(a(x,y,k)&&c(x,y,k,1))
                {
                    res=k;
                    break;
                }
                if(b(x,y,k)&&c(x,y,k,0))
                {
                    res=k;
                    break;
                }
            }
        }
    }
    cout<<res;
    return 0;
}
```

---

## 作者：TJB_LHY (赞：0)

# 思路

一道~~简单的~~暴力题（~~建议降红~~）。大意为给定一个二维布尔数组 $a_{n,m}$，要找一个正方形，其中只有对角线为真（即一个边长为 $x$ 正方形，其中只有 $x$ 个为真）。只需要建一个二维前缀和数组 $ans_{n,m}$，$ans_{i,j}$ 表示以第 $i$ 行 $j$ 列为右下角，以第 $1$ 行 $1$ 列为左上角的矩阵中真的数量。那么由容斥原理可知递推式为：$ans_{i,j}=ans_{i-1,j}+ans_{i,j-1}-ans_{i-1,j-1}+a_{i,j}$。剩余的判断就用暴力即可。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
int n,m,ans[105][105],maxn,num;
bool a[105][105];//布尔数组
bool f1(int x,int y,int k){
    while(k--){
        if(!a[x][y])return 0;
        x--;y--;
    }
    return 1;
}
bool f2(int x,int y,int k){
    y-=k-1;
    while(k--){
        if(!a[x][y])return 0;
        x--;y++;
    }
    return 1;
}//对角线判断
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1]+a[i][j];
        }
    }//输入及前缀和
    int x,y,k;
    for(k=1;k<=min(n,m);k++)
        for(x=k;x<=n;x++)
            for(y=k;y<=m;y++)
                if(maxn<(num=ans[x][y]-ans[x-k][y]-ans[x][y-k]+ans[x-k][y-k]))if((f1(x,y,k) || f2(x,y,k)) && num==k)
                    maxn=num;//取最大值
    cout<<maxn;//输出
	return 0;
}
```
感谢大家的观看~

---


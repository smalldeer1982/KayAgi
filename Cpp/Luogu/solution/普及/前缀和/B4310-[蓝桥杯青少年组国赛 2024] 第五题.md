# [蓝桥杯青少年组国赛 2024] 第五题

## 题目描述

给定包含 $n$ 个整数的数列，从中选取一段连续子数列，使其元素之和能被 $k$ 整除。

请找出符合要求的最长连续子数列并输出其长度以及子数列本身；如果符合要求的最长连续子数列有多个，则输出起始位置最靠后的那个子数列。如果不存在符合要求的子数列，则输出 $-1$。

例如：当 $n=7$，$k=7$，数列为 $7$、$3$、$4$、$1$、$5$、$14$、$9$ 时：
- 连续子数列 $\{7\}$、$\{7,3,4\}$、$\{3,4\}$ 和 $\{5,14,9\}$ 的和都能被 $7$ 整除；
- 其中最长的连续子数列有 $\{7,3,4\}$ 和 $\{5,14,9\}$，起始位置最靠后的是 $\{5,14,9\}$；
- 故符合要求的最长连续子数列长度为 $3$，子数列为 $5$ $14$ $9$。

## 样例 #1

### 输入

```
7 7
7 3 4 1 5 14 9```

### 输出

```
3
5 14 9```

# 题解

## 作者：DashZhanghanxu (赞：3)

# 解析
看到连续子数列，本能反应前缀和。

为了更好的观看体验，本篇题解省略了前缀和的描述，如果您还不会前缀和，可以上前缀和模板题学习。

首先我们可以想到，枚举起点与终点，看该子段和是否满足为 $k$ 的倍数，如果是，并且该子段长度比上个子段最优子段的长度长或者更靠后，则更新答案。最后输出该子段长度及内容。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100001],dp[100001];
int start=0,endd=0,maxans=0;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=dp[i-1]+a[i];
	}
	for(int i=1;i<=n;i++){//终点 
		for(int j=1;j<=i&&(i-j+1)>=maxans;j++){//起点 
		int now=dp[i]-dp[j-1];
			if(now%k==0){
					maxans=i-j+1;
					start=j;
					endd=i;
			}
		}
	}
	if(maxans==0){
		cout<<-1;
		return 0;
	}
	cout<<maxans<<"\n";
	for(int i=start;i<=endd;i++){
		cout<<a[i]<<' ';
	}
	return 0;
}
```
但是，我们会发现，该代码会有一个点超时（有能力的大佬可以尝试修改）。

因此，我们可以考虑另一种写法。

既然要找最长子段，那么我们可以枚举长度与终点，若发现该子段和为 $k$ 的倍数，可以直接输出，若未找到，则输出 $-1$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100001],dp[100001];
int start=0,endd=0,maxans=0;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=dp[i-1]+a[i];
	}
	for(int i=n;i>=1;i--){//长度 
		for(int j=n;j>=i;j--){//终点 
			if((dp[j]-dp[j-i])%k==0){
				cout<<i<<"\n";
				for(int k=j-i+1;k<=j;k++){
					cout<<a[k]<<' ';
				}return 0;
			}
		} 
	}
	if(maxans==0){
		cout<<-1;
		return 0;
	}
	return 0;
}
```
这里再提供一种方法：

注：以下数字皆指前缀和。

众所周知，两个除以同一个数余数相同的数字相减后一定是这个除数的倍数。所以我们可以将一个余数的第一次出现的位置记录下来，当以后出现相同余数时，将这个数与最早出现该余数的数字相减，得到的长度与最长字段相比，更新答案即可。

以下是代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,k,a[100005],pre,last;
int len,start,endd;
map<int,int> fir;
int main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    cin>>n>>k;
    fir[0]=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        pre=(last+a[i])%k;
        last=pre;
        if(fir.count(pre)){
            if(i-fir[pre]>=len){
                len=i-fir[pre];
                start=fir[pre]+1;
                endd=i;
            }
        }else{
            fir[pre]=i;
        }
    }
    if(len==0){
        cout<<"-1";
        return 0;
    }
    cout<<len<<"\n";
    for(int i=start;i<=endd;i++) cout<<a[i]<<" ";
    return 0;
}
```

---

## 作者：_ByTT_ (赞：1)

# B4310 题解
## 题意
 在一个序列中，找**最长**并且开头**最靠后**的子序列并且这个子序列和还要**被 $k$ 给整除**。

### 思路

 ~~坏了，看到子序列求和就想要前缀和~~。

其实就是**前缀和**。目测发现好像没有好办法可以稳定解决，写个暴力先骗骗分，然后再**优化**。

### ~~暴力~~代码如下：
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],ps[100005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int n,k;cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],ps[i]=ps[i-1]+a[i];
	for(int len=n;len>=1;len--){
		for(int i=n;i>=len;i--){
			int sum=(ps[i]-ps[i-len]);
			if(sum%k==0){
				cout<<len<<'\n';
				for(int j=i-len+1;j<=i;j++) cout<<a[j]<<' ';
				return 0;
			}
		}
	}
	cout<<-1;
	return 0;
}

```
### 优化
交上去没有悬念拿到了亿点分，竟然只有最后一个点超时了，所以优化应该比较为简单。

首先，注意看**数据范围**，$k$ 有 $10^8$，但是 $n$ 和序列数据大小只有 $10^5$ 和 $10^4$。

所以明显的，$k$ 一但大到一定程度，就会导致长的子序列和不满足，短子序列的和又小于 $k$，浪费了大量时间效率，于是乎，便想到了以下优化。
```c++
	int flg=1;
	for(int len=n;len>=1;len--){
		flg=1;
		for(int i=n;i>=len;i--){
			int sum=(ps[i]-ps[i-len]);
			if(sum>=k) flg=0;
		}
		if(flg) break;
	}
	cout<<-1;
```
### "完整"代码：
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],ps[100005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int n,k;cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],ps[i]=ps[i-1]+a[i];
	int flg=1;
	for(int len=n;len>=1;len--){
		flg=1;
		for(int i=n;i>=len;i--){
			int sum=(ps[i]-ps[i-len]);
			if(sum>=k) flg=0;
			if(sum%k==0){
				cout<<len<<'\n';
				for(int j=i-len+1;j<=i;j++) cout<<a[j]<<' ';
				return 0;
			}
		}
		if(flg) break;
	}
	cout<<-1;
	return 0;
}
```
真的结束了吗。

经过管理员的审核，又将题解打了回来，理由是**时间复杂度不合格**，仔细看，~~虽然能过，虽然数据过水~~ ，但是极端情况下，会存在优化不掉而超时的数据。

所以，还需要真正的正解。

#### 新的思路

在大佬 @afuafu 的帮助下，得到了新的思路。有一种特殊的办法，将**前缀和取余** $k$，从而靠模后和快速求出答案，时间复杂度 $O(n)$。

此解法从[另一道 USA ](https://www.luogu.com.cn/problem/P3131)的前缀和题目中得到，于此题有异曲同工之妙。

同时使用的还有一个~~类似~~**双指针**的**两个**数组存下标，同时每次有答案时用 $ \ge $ 来判断，因为要求尽量**靠后**的答案，用 $mx$ **减去左指针来存长度**，然后用 $ans$ 去存当前答案的**下标**。

最后就是简单的写代码主体啦。

#### 完整代码
```c++
#include<bits/stdc++.h>
using namespace std;
int n,k,l[100000005],ans,mx=-1;
int a[1000005],s[1000005],r[100000005];
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>k;
	memset(l,-1,sizeof(l));
	s[0]=0;l[0]=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s[i]=(s[i-1]+a[i])%k;
		if(l[s[i]]==-1){
			l[s[i]]=i;
		}else{
			r[s[i]]=i;
			if(i-l[s[i]]>=mx){
				mx=i-l[s[i]];
				ans=s[i];
			}
		}
	}
	cout<<mx<<"\n";
	for(int i=l[ans]+1;i<=r[ans]&&mx>0;i++) cout<<a[i]<<" ";
	return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 题意分析
题目要求我们在一个数列中选择一个子区间，使得他的和能被 $k$ 整除。要求让这个子区间更长且更靠后。
# 解题思路
从“子区间的和”中我们可以知道这题应该使用前缀和快速计算一个子区间的和然后判断是否能被 $k$ 整除，由于题目要求首先得是长度最长，接着才是最靠后。所以只需要用一个循环枚举长度，再用一个循环枚举尾端点。接着在循环里判断即可。
# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100005];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++) 
	 {
	 	cin>>a[i];
	 	a[i]+=a[i-1];//前缀和
	 }
	for(int len=n;len;len--)
	 for(int i=n;i-len>=0;i--)
	  {
	  	int l=i-len;
	  	if((a[i]-a[l])%k==0)
	  	 {
	  	 	cout<<len<<"\n";
	  	 	for(int t=l+1;t<=i;t++) cout<<a[t]-a[t-1]<<' ';
	  	 	return 0;
		 }
	  }
	cout<<-1;
	return 0;
}
```
# 时间复杂度分析
由于用了两层循环，所以时间复杂度 $O(n^2)$，理论上无法胜任 $1\le n\le 10^5$ 的数据范围。但好在数据比较水，这样的代码也能过，但这不是最好的方法。
# 优化
首先前缀和是必须要的，设 $s_i=\sum^{j=1}_{j\le i}a_j$，我们要想让 $(s_i-s_j) \bmod k=0$，也就是要让 $s_j \equiv s_i \pmod{k}$。我们只需要建立一个哈希表来记录前缀和数组中余数为 $x$ 的第一个位置是哪里，之后如果遇到同样的余数就可以通过哈希表记录的位置快速知道子区间的长度从而进行比较。具体详见代码。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005],sum;
int len,best_start,best_end;
int mod[100000005];//哈希表
int main()
{
	memset(mod,-1,sizeof mod);
	mod[0]=0;//一定要将第0位考虑进去，不然只有90分！
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	 {
	 	sum=(sum+a[i])%k;//前缀和的余数
	 	if(mod[sum]!=-1)//如果这个余数出现过了
	 	 {
	 	 	int new_len=i-mod[sum];//计算新的长度
	 	 	if(new_len>len)
	 	 	 {
	 	 	 	len=new_len;
	 	 	 	best_start=mod[sum]+1;
	 	 	 	best_end=i;
			 }
			else if(new_len==len&&mod[sum]+1>best_start)
			 {
			 	best_start=mod[sum]+1;
	 	 	 	best_end=i;
			 }
      //更新
		 }
		else mod[sum]=i;//记录第一次出现的位置
	 }
	if(len==0) cout<<-1;
	else
	 {
	 	cout<<len<<"\n";
	 	for(int i=best_start;i<=best_end;i++) cout<<a[i]<<' ';
	 }
	return 0;
}

```

---

## 作者：ryderyang (赞：0)

# 解题思路
由于要求出子序列的和，我们可以考虑用前缀和。设 $sum_i$ 为从第 $1$ 个元素到第 $i$ 个元素的和。可以想到递推公式：$sum_i=sum_{i-1}+a_i$。那么怎么求出第 $l$ 个数到第 $r$ 个数的和呢？可以用 $sum_r-sum_{l-1}$。我们只需要枚举序列的长度和起点，判断总和是不是 $k$ 的倍数就行了。时间复杂度 $O(n^2)$。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,a[N],sum[N],k;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	for(int len=n;len>=1;len--)
	{
		for(int l=n+1-len;l>=1;l--)
		{
			int r=l+len-1;
			if((sum[r]-sum[l-1])%k==0)
			{
				printf("%d\n",len);
				for(int i=l;i<=r;i++)
				printf("%d ",a[i]);
				return 0;
			}
		}
	}
	printf("-1");
	return 0;
}
```

# 正解
我们认定该序列是目标序列的条件是 $sum_r-sum_{l-1}$ 是 $k$ 的倍数，所以 $sum_r$ 和 $sum_{l-1}$ 除以 $k$ 的余数是相等的。我们把每一个余数最早出现的位置记录下来。输入时更新答案就行了，具体细节见代码。
# 满分代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,a[N],sum[N],k,ans=-1,l,r=-1;
map<int,int> mp;
int main()
{
	scanf("%d%d",&n,&k);
	mp[0]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
		int mod=sum[i]%k;
		if(mp.count(mod)==0)
		mp[mod]=i;
		else
		{
			int len=i-mp[mod];
			if((len>ans)||(len==ans&&(mp[mod]+1)>l))
			{
				ans=len;
				l=mp[mod]+1;
				r=i;
			}
		}
	}
	printf("%d\n",ans);
	for(int i=l;i<=r;i++)
	printf("%d ",a[i]);
	return 0;
}
```

---


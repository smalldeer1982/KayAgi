# 『SpOI - R1』强大到让你们所有人注视

## 题目描述

**本题包含多组测试。**

给定一个 $n$ 位的 $k$ 进制大数。

令 $S(l,r)$ 表示截取这个 $k$ 进制大数从高到低第 $l$ 位至第 $r$ 位构成的新 $k$ 进制数。

你需要求出 $\sum\limits_{1\leq l\leq r\leq n} S(l,r)$，注意这里的求和也建立在 $k$ 进制下。

由于答案可能很大，设 $(20070720)_{10}$ 在 $k$ 进制下是 $x$，你只需要输出答案对 $x$ 取模的结果。

**再次提醒：以上所有求和、运算和取值都建立在 $k$ 进制下。**

## 说明/提示

#### 样例 #1 解释

所有的 $S(l,r)$：$(1)_2,(1)_2,(0)_2,(11)_2,(10)_2,(110)_2$，把它们在 $2$ 进制下相加得到 $(1101)_2$，再在 $2$ 进制下对 $(20070720)_{10}=(1001100100100000101000000)_2$ 取模即可得到答案 $(1101)_2$。

#### 样例 #2 解释

对于这个数，$S(1,1)$ 显然被 $(\overline{20070720})_{20070721}$ 整除，$S(2,2),S(1,2)$ 被 $(\overline{20070720})_{20070721}$ 除后都余 $1$。所以取模后的答案是 $(2)_{20070721}$。

### 数据范围

**本题开启子任务捆绑与子任务依赖。**

对于 $100\%$ 的数据，$1\leq T\leq 10$，$1\leq n\leq 5\times 10^5$，$0\leq a_i<k\leq 10^9$，$2\leq k\leq 10^9$。$k$ 进制大数可能含有前导零。

| Subtask | $T\leq$ | $n\leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 1 | $10$ | $100$ | 无 | $25$ | 无 |
| 2 | $1$ | $5\times 10^3$ | $k>20070720$ | $20$ | 无 |
| 3 | $1$ | $8\times 10^3$ | 无 | $25$ | 1,2 |
| 4 | $5$ | $5\times 10^5$ | 无 | $30$ | 1,2,3 |

## 样例 #1

### 输入

```
1
3 2
1 1 0```

### 输出

```
1 1 0 1```

## 样例 #2

### 输入

```
1
2 20070721
20070720 1```

### 输出

```
2```

# 题解

## 作者：Stone_Xz (赞：11)

## [题目传送门](https://www.luogu.com.cn/problem/P10791)

## 简要题意

一定要把题读懂，可以结合样例和样例解释。

> 给定一个 $k$ 进制数的每一位 $a_i$，这个数列中每个子串都可以构成一个新的的 $k$ 进制数，求它们的和。并对 $k$ 进制下的 $20070720$ 取模。输出的也应该是一个 $k$ 进制数。

## 分析：

 - 还原赛时思考过程。
 
1. 首先，题目中所有的运算都建立在 $k$ 进制下，不方便，所以我们等价转换为先在十进制中进行求和、取模运算，再转换为 $k$ 进制输出。
 
 2. 现在我们思考如何计算这个数列中【每个子串构成的 $k$ 进制数】之和。如果暴力求解，时间复杂度怎么也要到 $\mathcal{O}(n^2)$ 以上。题目中的 $n \le 5 \times 10 ^ 5$，在这个时间内不足以计算每个子串的贡献，我们于是转而研究每一位的贡献。
 
 3. 一个位置能贡献多少个子串呢？每个子串都有起始位置和结束位置，对于每一个位置，它都能作为起点，结束位置可以是它右边的任何一个元素。
 
 4. 就拿样例研究，我们列出以某个位置为起点的所有子串。

$$
\begin{array}{cc}
   位置 & 1 & 2 & 3 \\
   -----------&---&---&---\\
   位置上的数 & 1 & 1 & 0 \\
   -----------&---&---&---\\
    & 1 & 1 & 0\\ 
   以此为开头的所有子串 & 11 & 10 \\
  （这个位置贡献的子串） &110\\
\end{array}
$$

5. 我们发现每个位置贡献的的子串很有规律。要求整个数列中每个子串的和，那么，**一个位置贡献的**所有子串之和（即这个位置的贡献）是多少呢？让我们试着列出每一个位置的贡献（设第 $i$ 个位置的贡献为 $ans_i$）：

$$
\begin{aligned}
  ans_1 = (a_1 \times k^2 + a_2 \times k^1 + a_3 \times k^0) \\
        + (a_1 \times k^1 + a_2 \times k^0)\\
        + (a_1 \times k^0)\\
        = (110)_2 + (10)_2 + (1)_2
\end{aligned}
$$

***

$$
\begin{aligned}
  ans_2 = (a_2 \times k^1 + a_3 \times k^0)\\
       + (a_2 \times k^0) \\
       = (10)_2 + (1)_2
\end{aligned}
$$

***

$$
\begin{aligned}
  ans_3 = (a_3 \times k^0)\\
  = (0)_2
\end{aligned}
$$

 6. 每个位置的贡献很有规律，拿 $ans_1$ 的计算为例，$a_1$ 对 $ans_1$ 的贡献为 $a_1 \times (k^2 + k^1 + k^0)$，$a_2$ 对 $ans_1$ 的贡献为 $a_2 \times (k^1 + k^0)$，$a_3$ 对 $ans_1$ 的贡献为 $a_3 \times k^0$，所以$ans_1$ 的计算可以列为规律更加直观的一个式子：
 
$$
\begin{aligned}
  ans_1 = {\color{Red}a_1 \times (k^2 + k^1 + k^0)}\\
        + {\color{Blue}a_2 \times (k^1 + k^0)}\\
        + {\color{Green}a_3 \times k^0}
\end{aligned}
$$

同理：

$$
ans_2 = {\color{Blue}a_2 \times (k^1 + k^0)} + {\color{Green}a_3 \times k^0}
$$
$$
ans_3 = {\color{Green}a_3 \times k^0}
$$

 7. 我们仍没有足够的时间暴力计算上面所有的式子，但是我们发现这其中有大量的重复，将这些重复合并，可以得到如下答案：
 
 $$
\begin{aligned}
  ans_1 + ans_2 + ans_3 = \\
  {\color{Red}a_1 \times (k^2 + k^1 + k^0)} \times 1\\
  + {\color{Blue}a_2 \times (k^1 + k^0)} \times 2\\
  + {\color{Green}a_3 \times k^0} \times 3
\end{aligned}
$$

按照这样的的规律，就可以用 $\mathcal{O}(n)$ 的时间计算答案了！上述式子中的括号部分计算也很简单，只需开一个变量 $pow\_$ 维护 $k$ 的幂，同时维护变量 $haha$ ~~（赛时乱取的变量名...）~~ 累加每个 $k$ 的幂即可（变量名与代码相符）。

ps：注意多组数据，取模一定要取到位！~~不然可能爆零！~~
同时要特判 $ans = 0$ 的情况输出 $0$！

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 5e5 + 5, mod = 20070720;
int n, k, ans, a[N];

void solve()
{
	ans = 0;
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
		a[i] %= mod;
	}
	int haha = 1, pow_ = k;
	for(int i = n; i >= 1; i--)
	{
		ans = (ans + a[i] % mod * i % mod * haha) % mod;
		haha = (haha + pow_) % mod;
		pow_ = (pow_ * (k % mod)) % mod;
	}
	if(ans == 0) // 特判 
	{
		cout << "0\n";
		return;
	}
	// 转进制 
	stack<int> stk;
	while(ans != 0)
	{
		stk.push(ans % k);
		ans /= k;
	}
	while(!stk.empty())
	{
		cout << stk.top() << " ";
		stk.pop();
	}
	cout << "\n";
}

signed main()
{
	int T;
	cin >> T;
	while(T--) solve(); 
	return 0;
}
```

 - 彩蛋：在写这篇题解时，连着刷新了两下，第二下时竟然刚好碰上洛谷更新文章编辑界面，真的比之前丝滑 + 好看 + 好用太多了，专栏界面全更新了（喜

---

## 作者：Weekoder (赞：7)

新的编辑器真香。

### 思路

### Subtask 1

将 $k$ 进制数转换为 $10$ 进制数计算。枚举左右端点并暴力计算 $S(l,r)$，复杂度显然为 $\mathcal{O}(n^3)$。预计得分 $25$。

### Subtask 2 & 3

枚举左右端点不可行，不如将问题转化到单点上，考虑 dp。设 $dp_i$ 表示以 $i$ 为起点的字串贡献值和，则答案被进一步转化为 $\displaystyle\sum dp_i$。如何转移？以样例 $1$ 为例，我们可以先将以 $1$ 为起点的所有贡献列出来：

$$
\begin{aligned}
& a_1\cdot2^2+a_2\cdot2^1+a_3\cdot2^0 \\
+ & a_1\cdot2^1+a_2\cdot2^0 \\
+ & a_1\cdot2^0
\end{aligned}
$$

注意标颜色的地方，我们可以将这个式子进行一个转换：

$$
\begin{aligned}
& \color{green}a_1\cdot2^2\color{black}+\color{red}a_2\cdot2^1\color{black}+\color{blue}a_3\cdot2^0 \\
+ & \color{green}a_1\cdot2^1\color{black}+\color{red}a_2\cdot2^0 \\
+ & \color{green}a_1\cdot2^0
\end{aligned}
=\begin{aligned}
& \color{green}a_1\cdot2^2\color{black}+\color{green}a_1\cdot2^1\color{black}+\color{green}a_1\cdot2^0 \\
+ & \color{red}a_2\cdot2^1\color{black}+\color{red}a_2\cdot2^0 \\
+ & \color{blue}a_3\cdot2^0
\end{aligned}
=\begin{aligned}
& \color{green}a_1\cdot(2^2+2^1+2^0) \\
+ & \color{red}a_2\cdot(2^1+2^0) \\
+ & \color{blue}a_3\cdot2^0
\end{aligned}
$$
根据此公式，我们便可以写出状态“转移”方程：

$$dp_x=\sum_{i=x}^n(a_i\cdot\sum_{j=0}^{n-i}k^j)$$

可以发现，这个状态根本没有转移！不过没有问题，$\displaystyle\sum_{j=0}^{n-i}k^j$ 可以递推 $\mathcal{O}(1)$ 得到，我们便把时间复杂度优化到了 $\mathcal{O}(n^2)$。预计得分 $70$。

### Subtask 4

注意到 $dp$ 数组是具有单调性的，即对于 $dp_x$，$x$ 越小，$dp_x$ 越大。这是因为在 $\sum_{i=x}^n$ 中，$x$ 少 $1$，计算的层数就多 $1$。也就是说，我们只需要从 $n\to1$ 递推，每次加上多的一层，也就是加上 $a_i\cdot\displaystyle\sum_{j=0}^{n-i}k^j$，这也是可以 $\mathcal{O}(1)$ 得到的。于是，这就变成了一个 $\mathcal{O}(n)$ 的递推，即

$$dp_i=dp_{i+1}+a_i\cdot\sum_{j=0}^{n-i}k^j$$

时间复杂度 $\mathcal{O}(n)$，预计得分 $100$。

代码：


```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 5e5 + 5, Mod = 20070720;

int T, n, k, a[N], dp[N];

stack<int> stk;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> T;
	while (T --) {
		cin >> n >> k;
		for (int i = 1; i <= n; i++) cin >> a[i], a[i] %= Mod;
		int sum = 0, ans = 0, k_i = 1;
		dp[n + 1] = 0;
		for (int i = n; i >= 1; i--) {
			(ans += (dp[i] = (dp[i + 1] + a[i] * ((sum += k_i) %= Mod)) % Mod) % Mod) %= Mod;
			(k_i *= k) %= Mod;
		}
		if (!ans) { cout << "0\n"; continue; }
		while (ans) {
			stk.push(ans % k);
			ans /= k;
		}
		while (!stk.empty()) cout << stk.top() << " ", stk.pop();
		cout << "\n"; 
 	}
	return 0;
}
```

---

## 作者：Shunpower (赞：5)

出题人题解。

## 算法 $1$

首先要知道，虽然所有操作都是建立在 $k$ 进制下，但完全没有必要这么憨。我们可以计算 $S(l,r)$ 的十进制值，然后在十进制下进行求和并取模，再倒回去就行了。

于是很容易得到第一个暴力算法：

暴力枚举 $l,r$，进制转换计算 $S(l,r)$ 再求和。复杂度 $\mathcal O(n^3)$。

## 算法 $2$

考虑拆位，计算第 $i$ 位的贡献。对于任意一个 $r\geq i$，它对组成的那个数（也就是 $S(l,r)$）贡献 $a_i\times k^{r-i}$，而显然，$l$ 可以在所有 $[1,i]$ 任取。

所以我们可以得到一个算法，这个算法是 $\mathcal O(n^2)$ 的：

$$
\sum\limits_{1\leq l\leq r\leq n} S(l,r)=\sum\limits_{i=1}^n\sum\limits_{r=i}^n a_i\times k^{r-i}\times i
$$

暴力计算右边那个和式就行。

## 算法 $3$

发现算法 $2$ 非常有优化空间！

我们对和式提取公因数：

$$
\begin{aligned}
\sum\limits_{1\leq l\leq r\leq n} S(l,r)&=\sum\limits_{i=1}^n\sum\limits_{r=i}^n a_i\times k^{r-i}\times i\\&=\sum\limits_{i=1}^{n} a_i\times i\times \sum\limits_{r=i}^n k^{r-i}\\
&=\sum\limits_{i=1}^{n} a_i\times i\times \sum\limits_{r=0}^{n-i} k^r
\end{aligned}
$$

那么这就很显然了，我们可以对 $k^i$ 做一个前缀和，这样我们就能枚举 $i$ 然后 $\mathcal O(1)$ 获得每个 $i$ 上的贡献，然后求和就是答案了。时间复杂度 $\mathcal O(n)$。

当然，你也可以不对 $k^i$ 进行前缀和，使用等比数列求和公式，显然 $20070719$ 和 $20070720$ 是互质的。

注意不要漏掉取模和最后倒回去的操作。

-----------

std 主要部分如下：

```cpp
int n,k;
int a[N];
const int M=20070720;
int basek[N],sum[N];
vector <int> kans;
int main(){
    ios::sync_with_stdio(false);
    int T;
    cin>>T;
    while(T--){
        cin>>n>>k;
        kans.clear();
        basek[0]=sum[0]=1;
        fr1(i,1,n) basek[i]=1ll*basek[i-1]*k%M;
        fr1(i,1,n) sum[i]=(sum[i-1]+basek[i])%M;
        fr1(i,1,n) cin>>a[i];
        ll ans=0;
        fr1(i,1,n) (ans+=1ll*a[i]*i%M*sum[n-i]%M)%=M;
        if(ans==0) cout<<0<<endl;
        else{
            while(ans){
                kans.pb(ans%k);
                ans/=k;
            }
            reverse(kans.begin(),kans.end());
            for(auto i:kans) cout<<i<<" ";
            cout<<endl;
        }    
    }
    ET;
}
```

---

## 作者：xuezhiyu (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10791)

~~话说这道题真的是普及-吗？~~

## 分析题目

题目乍一看没有思路，我们不妨分析几组数据。

比如当 $n=3$ 时的情况：$\overline{a_1a_2a_3}$

答案就是

$$
\overline{a_1}+\overline{a_2}+\overline{a_3}+\overline{a_1a_2}+\overline{a_2a_3}+\overline{a_1a_2a_3}
$$

$$
=a_1+a_2+a_3+k \times a_1+a_2+k \times a_2+a_3
$$

$$
+k^2 \times a_1+k \times a_2+a_3
$$

$$
=(k^2+k+1) \times a_1+2 \times (k+1) \times a_2+3 \times a_3
$$

看出规律了吗？再把 $n=4$ 的情况算出来：

$$\overline{a_1}+\overline{a_2}+\overline{a_3}+\overline{a_4}+\overline{a_1a_2}+\overline{a_2a_3}+\overline{a_3a_4}+\overline{a_1a_2a_3}+\overline{a_2a_3a_4}+\overline{a_1a_2a_3a_4}$$

$$=(k^3+k^2+k+1) \times a_1+2 \times (k^2+k+1) \times a_2+3 \times (k+1) \times a_3+4 \times a_4$$

我们惊奇地发现，当这个数为 $\overline{a_1a_2 \dots a_n}$ 时，答案就是：

$$\sum_{i=1}^n (i \times (\sum_{j=0}^{n-i} k^j) \times a_i)$$

为什么是这样的？我相信你们一定能证明的是吧！~~我绝对不会说我不会证~~

于是这样，我们就得到了一个 $\text O(N)$ 的算法，接下来只需要在计算答案的时候模去 $20070720$ 就行了。

**注意！本题数据较大，所以需要计算一点模一点，我因为这个调了好久**

最后输出答案就用的递归输出，看代码也能看懂了。

# 代码时间


```cpp
#include <iostream>
#define int long long

using namespace std;

const int N = 5e5 + 10, mod = 20070720;
int n, k, a[N], ans, curk, tmp;

void print(int x) { // 递归输出函数
	if (x) {
		print(x / k); // 先输出高位
		printf("%lld ", x % k); // 再输出低位
	}
}

signed main() {
	int T;
	scanf("%lld", &T);
	while (T --> 0) { // 很形象的写法，实际上是 T-- > 0
		scanf("%lld%lld", &n, &k);
		for (int i = 1; i <= n; i++)
			scanf("%lld", a + i);
		curk = 1, tmp = 1, ans = 0;
		for (int i = n; i >= 1; i--) {
			ans = (ans + i * tmp % mod * a[i] % mod) % mod; // 注意要计算一个模一个，不然会 WA
			curk = (curk * k) % mod;
			tmp += curk;
		}
		if (ans == 0) putchar('0'); // 特判，不然会没有输出
		else print(ans);
		putchar('\n');
	}
	return 0;
}

```

---

## 作者：yezicong1104 (赞：2)

### 思路
- 由于 $n$ 的范围是 $1 \le n \le 5 \times 10^5$，用暴力肯定是会超时的，所以尝试推导规律。
- 设有一个 $k$ 进制数，它**从左往右**数的第 $i$ 位为 $a_i$，以 $a_i$ 作为**开头**的数有 $S(i,i),S(i,i+1),...,S(i,n)$，其中 $a_i$ 相当于一共被加了 $\sum_{j=0}^{n-i}{k^j}$ 次，再考虑 $a_i$ 左边一共有 $i-1$ 个数，与以 $a_i$ 开头的组合一下，可得 $a_i$ 相当于一共被加了 $i \times \sum_{j=0}^{n-i}{k^j}$ 次，这样公式就推导出来了，最终可以得到答案为：
  $$\begin{aligned} \sum_{l=1}^n {\sum_{r=l}^n {S(l,r)}} &= \sum_{i=1}^{n} (i \times \sum_{j=0}^{n-i} {k^j} \times a_i) \end{aligned}$$
- 时间复杂度为 $O(Tn)$，不会超时了。
### AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 500010, p = 20070720;
int a[N];
void print(int n, int k) { //转成k进制输出 
	if (!n)
		return;
	print(n / k, k);
	printf("%d ", n % k);
}
signed main() {
	int T, n, k;
	cin >> T;
	while (T--) {
		cin >> n >> k;
		for (int i = 1; i <= n; i++) {
			scanf("%d", &a[i]);
		}
		int sum = 0, pro = 1, ans = 0;
		for (int i = n; i >= 1; i--) { //计算 
			sum = (sum + pro) % p; //sum计算(k^0+k^1+...+k^(n-i))%p
			ans = (ans + sum * i % p * a[i]) % p;
			pro = pro * k % p;
		}
		if (ans % p)
			print(ans % p, k); //转成k进制输出 
		else
			printf("0"); //特判：如果是0就直接输出	
		puts(""); //换行 
	}
	return 0;
}
```

---

## 作者：UncleSam_Died (赞：2)

### 解题思路

对于 $k$ 进制大数的第 $i$ 位，当且仅当 $r\in [i,n]$ 的时候会产生贡献，同样可以得出，对于任意 $l\in [1,r]$，第 $i$ 位会产生 $i$ 次贡献，每次对答案的贡献是 $a_i\times k^{r-i}$。由此，我们对于 $k$ 的幂次求前缀和，设得到的数组为 $sum$，那么有 $sum_i=1+k+k^2+k^3+\dots +k^{i-1}$，所以最终十进制下的答案为
$$
\sum_{i=1}^n a_i\times sum_{n-r+1}\times i
$$

对这个答案对 $mod$ 取模后转化为 $k$ 进制输出即可，注意特判为 $0$ 的情况。

### AC 代码

```cpp
#include<stdio.h>
#include<stdlib.h>
#define N 1000005
#define Mod 20070720
#define int long long
int n,k,a[N],ans[N],m,Mi[N];
inline void work(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i)
        scanf("%lld",&a[i]);
    for(int i=1;i<=n;++i) a[i]%=Mod;
    Mi[0]=1; int sum=0; m=0;
    for(int i=1;i<=n;++i)
        Mi[i]=Mi[i-1]*k%Mod;
    for(int i=1;i<=n;++i)
        (Mi[i]+=Mi[i-1])%=Mod;
    for(int i=1;i<=n;++i)
        (sum+=i*Mi[n-i]%Mod*a[i]%Mod)%=Mod;
    while(sum) ans[++m]=sum%k,sum/=k;
    while(ans[m]==0&&m) --m;
    if(m==0) return puts("0"),void();
    for(int i=m;i>=1;--i)
        printf("%lld ",ans[i]);
    putchar('\n');
}
signed main(){
    int T;scanf("%lld",&T);
    while(T--) work();
    system("pause");
}
```

---

## 作者：4041nofoundGeoge (赞：1)

考试时这道题实在是一头雾水，回头想想因该是太着急了，认真分析就能得出结论（~~我是人机~~）。

# 题目大意

给定一个 $n$ 位的 $k$ 进制大数。

令 $S(l,r)$ 表示截取这个 $k$ 进制大数从高到低第 $l$ 位至第 $r$ 位构成的新 $k$ 进制数。

你需要求出 $\sum\limits_{1\leq l\leq r\leq n} S(l,r)$，注意这里的求和也建立在 $k$ 进制下。

由于答案可能很大，设 $(20070720)_{10}$ 在 $k$ 进制下是 $x$，你只需要输出答案对 $x$ 取模的结果。

# 分析

不要看到 $\sum$ 就害怕，其实很简单。题目中的 $\sum$ 大概意思是：当 $l$ 和 $r$ 小于 $n$ 且 $1\le l\le r$ 时，截取这个 $k$ 进制大数从高到低第 $l$ 位至第 $r$ 位构成的新 $k$ 进制数，对其进行求和。

再来看个样例：

当 $n=3$ 时，设这个大数为 $\overline{abc}$ 依据题意则有：

$$
a+b+c+\overline{ab}+\overline{bc}+\overline{abc}
$$

根据数值原理可得到：

$$
a+b+c+k^1\times a+k^0\times b+k^1\times b+k^0\times c+k^2\times a+k^1\times b+k^0\times c
$$

依据乘法分配律整理得：

$$
\left(k^2+k^1+k^0\right)a+2\times\left(k^1+k^0\right)b+3\times k^0\times c
$$

不难发现，此题有以下规律（设多位数为 $\overline{a_1\dots a_n}$）:

$$
\sum^n_{i=1}(i\times(\sum^{n-i}_{j=0}k^j)\times a_i)
$$

**题目最重要的解题公式就出来了！**

顺便提一嘴，$\sum^{n-i}_{j=0}k^j$ 可以用一个 sum 数组来存储前缀和，故 tag 中的“前缀和” 原因就是在此。

**注意：题目说了是大数所以需要用 long long。**

# 代码：

```cpp
// c++代码：
#include <bits/stdc++.h>
using namespace std;
const int mod = 20070720;
long long n, k, a[500010], ans, zhui, tmp;
void f(long long x)
{
    if (x) {
        f(x / k);
        cout << x % k << " ";
    }
}
int main()
{
    int t;
    cin >> t;
    while (t--) { // 多组测试数据神器t--！
        cin >> n >> k;
        memset(a, 0, sizeof(a));
        for (long long i = 1; i <= n; i++)
            cin >> a[i];
        zhui = 1, tmp = 1, ans = 0;
        for (long long i = n; i >= 1; i--) {
            ans = (ans + i * tmp % mod * a[i] % mod) % mod; // 题解中的公式
            zhui = (zhui * k) % mod;
            tmp += zhui;
        }
        if (!ans)
            cout << 0;
        else
            f(ans);
        puts(""); // puts具有自动换行的功能
    }
    return 0;
}
```

---


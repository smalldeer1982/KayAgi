# [蓝桥杯 2024 省 C] 挖矿

## 题目描述

小蓝正在数轴上挖矿，数轴上一共有 $n$ 个矿洞，第 $i$ 个矿洞的坐标为 $a_i$。小蓝从 $0$ 出发，每次可以向左或向右移动 $1$ 的距离，当路过一个矿洞时，就会进行挖矿作业，获得 $1$ 单位矿石，但一个矿洞不能被多次挖掘。小蓝想知道在
移动距离不超过 $m$ 的前提下，最多能获得多少单位矿石？

## 说明/提示

**【样例说明】**

路径：$0\to -1\to 0\to 1\to 2$，可以对 $\{0,-1,1,2\}$ 四个矿洞挖掘并获得最多 $4$ 块矿石。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1 \le n \le 10^3$；  
对于所有评测用例，$1 \le n \le 10^5$，$-10^6 \le a_i \le 10^6$，$1 \le m \le 2 \times 10^6$。

## 样例 #1

### 输入

```
5 4
0 -3 -1 1 2```

### 输出

```
4```

# 题解

## 作者：Castorice (赞：51)

发现有地方描述不准确，所以重交了一次 QwQ。

考虑记录 $l, r$ 两个前缀和，分别记录负坐标和正坐标，因为 $0$ 坐标矿洞不管怎么走都会挖，所以只需要记录一下 $0$ 坐标的数量，在输出时加上即可。

则可以枚举 $i$ 表示从 $0$ 点出发向左和右走出的距离，并使用前缀和求出能挖多少矿，如果在走一个往返后还有能走的距离（即 $m- 2 \times i > 0$），就要加上还能走的距离向反方向走能挖到的矿的数量。

时间复杂度：$O(m)$

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e6 + 10;
int n, m, l[N], r[N], ans, cnt;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, x; i <= n; i++) {
		scanf("%d", &x);
		if (x < 0) {
			l[-x]++;
		} else if (x > 0) {
			r[x]++;
		} else {
			cnt++;
		}
	}
	for (int i = 1; i <= m; i++) {
		l[i] += l[i - 1], r[i] += r[i - 1];
	}
	for (int i = 1, t; i <= m; i++) {
		t = l[i];
		if (m - i * 2 > 0) {
			t += r[m - i * 2];
		}
		ans = max(ans, t);
		t = r[i];
		if (m - i * 2 > 0) {
			t += l[m - i * 2];
		}
		ans = max(ans, t);
	}
	printf("%d\n", ans + cnt);
	return 0;
}
```

---

## 作者：DarkShadow (赞：14)

# P10904（双指针）

## 题目大意：

数轴上有 $n$ 个点，求从 $0$ 位置开始，移动距离不超过 $m$ 最多经过的点的数量。

## 思路分析：

我们先假设先往左走，枚举先往左走到哪里，然后算出此时往右最远能走到哪里。由于随着左指针往左，右指针也一定会往左，所以我们可以用双指针 $O(n)$ 求出答案。

往右走也是一样用双指针算就可以了。

由于从 $0$ 位置开始有点难计算，我们可以在数轴 $0$ 上加一个点，最后把答案减一就可以了。

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100005;
int n,m,ans,d[N],pos;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	d[++n]=0;//新加一个位置为0的点
	sort(d+1,d+1+n);
	for(int i=1;i<=n;i++)//找到位置为0的点
		if(d[i]==0){
			pos=i;
			break;
		}		
	for(int l=pos,r=n;l>=1;l--){//计算开始往左走的情况
		if(d[pos]-d[l]>m)  break;
		while(r>pos&&2*(d[pos]-d[l])+d[r]-d[pos]>m)  r--;
		ans=max(ans,r-l+1);
	}
	for(int l=1,r=pos;r<=n;r++){//计算开始往右走的情况
		if(d[r]-d[pos]>m)  break;
		while(l<pos&&2*(d[r]-d[pos])+d[pos]-d[l]>m)  l++;
		ans=max(ans,r-l+1);
	}
	printf("%d",ans-1);//要把新加的点减掉
	return 0;
}
```

---

## 作者：HYdroKomide (赞：12)

### 题意：

在数轴上以原点为中心移动，一些点有分数（只能获取一次），走 $m$ 步能获取多少分数。

### 思路：

首先，走回头路总是劣的。因此，只有四种可能的方案：正方向走到头、反方向走到头、反方向走 $t$ 格然后往正方向走到头、正方向走 $t$ 格然后往反方向走到头。

发现前两个方案可以与后两个方案合并。所以实际要求的就是枚举 $t\le m$ 的情况下这个式子的最大值：
$$\max(l_t+r_{m-2t},r_t+l_{m-2t})$$
其中 $l_i$ 代表负半轴走 $t$ 距离的分数，$r_i$ 表示正半轴同理。

前缀和分别求出 $l,r$，模拟即可。注意特判零点有分的情况。

### 程序如下：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=2e6+5;
int n,m,prel[N],prer[N],ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		if(x>0)prer[x]++;
		else if(x==0)prer[x]=prel[x]=1;//零点的分数在左右都要算
		else prel[-x]++;
	}
	for(int i=1;i<=1e6;i++)prel[i]=prel[i]+prel[i-1],prer[i]=prer[i]+prer[i-1];
	for(int i=0;i<=m;i++){
	    if(i*2>m){
	        ans=max(ans,prer[i]+prel[0]);
		    ans=max(ans,prel[i]+prer[0]);
	    }
	    else{
	        ans=max(ans,prer[i]+prel[m-i*2]);
		    ans=max(ans,prel[i]+prer[m-i*2]);
	    }
	}
	printf("%d\n",ans-prer[0]);//注意因为左右都算了，最后再减去零点的分数即可
	return 0;
}
```
### THE END

---

## 作者：U•ェ•*U (赞：10)

一道简单的贪心题目

我们考虑，转弯次数 $\ge 2$ 的方案是不是最优解。

随便带一个数据进去，发现不是最优解。

因此不难证明，转弯 $1$ 次和 $0$ 次的方案才可能是最优解。

那么我们可以从原点开始枚举走到的所有位置的价值，再加上使用剩余体力走带来的价值，就是最终的答案。

记得前缀和优化。

---

## 作者：Lele_Programmer (赞：3)

# P10904 题解

## 思路

假设原点左边拿 $a$ 个，右边拿 $b$ 个，最短路径就是，先往左边拿 $a$ 个再到右边拿 $b$ 个，先往右边拿 $b$ 个再往左边拿 $a$ 个，这两者的较小值。

如果先拿左边的，花费 $2dis_a+dis_b$，如果先拿右边的，花费 $dis_a+2dis_b$。

考虑枚举左边拿的数量，可以分别求出两种方法右边最多可以走多远。

求右边走 $k$ 的距离最多挖多少矿石，这一步可以用二分。

时间复杂度：$\mathcal{O}(n \log n)$。

[提交记录](https://www.luogu.com.cn/record/174353833)

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define _rep(i,a,b) for (int i=(a);i<=(b);++i)

int n,m;
vector<int> l,r;
int ex,ans;

int main() {
    scanf("%d %d",&n,&m);
    _rep(i,1,n) {
        int v;
        scanf("%d",&v);
        if (abs(v)>m) continue;
        if (!v) ex++;
        else if (v<0) l.emplace_back(v);
        else r.emplace_back(v);
    }
    sort(l.begin(),l.end(),greater<int>());
    sort(r.begin(),r.end(),less<int>());
    _rep(i,0,l.size()) {
        int k=m-((i?-l[i-1]:0)<<1),t=(m-(i?-l[i-1]:0))>>1;
        int pos1=upper_bound(r.begin(),r.end(),k)-r.begin()-1;
        int pos2=upper_bound(r.begin(),r.end(),t)-r.begin()-1;
        ans=max(ans,i+max(pos1,pos2)+1);
    }
    printf("%d",ans+ex);
    return 0;
}
```

---

## 作者：xxseven (赞：1)

基础分讨题。

以下将负坐标称为**左边**，正坐标称为**右边**。

我们发现，如果向左右两边分别挖矿，那么有一边要走一个来回的路程，有一边只用走一次，我们可以依据这个进行分讨。

首先，在读入时判掉所有的 $0$，每一个的贡献为 $1$。正数即右边的点放进 $a$ 数组，负数即左边的点，取绝对值后放进 $b$ 数组。

之后，对两个数组分别排序，枚举在右边挖多少矿，走一遍还是两遍，据此算出能往左走的距离，找到能在左边挖到的最远的矿即可。

因为已经对数组排序，具有单调性，枚举这部分可以在 $O(n)$ 的时间内完成。

总时间复杂度 $O(n \log n)$，可以通过此题。瓶颈在于排序。

下面是代码和注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6;
int ans,ans2,n,m,a[N],b[N],an,bn;
int main(){
	cin>>n>>m;
	for(int x,i=1;i<=n;++i) {
		cin>>x;
		if(x==0) ans2++; //特判所有的0
		else if(x>0) a[++an]=x;
		else if(x<0) b[++bn]=-x;
	}
	sort(a+1,a+an+1); sort(b+1,b+bn+1);
	int pos=bn;
	for(int x,i=0;i<=an;++i){ //注意此时从0开始，因为有可能不在右边挖矿
		x=m-a[i]; //走一趟，花费a[i]的时间
		if(x<0) continue;
		while(b[pos]>x/2) pos--;//右边走了一趟，左边需要有两趟
		ans=max(ans,i+pos);
	}
	pos=bn;
	for(int x,i=0;i<=an;++i){//同理，枚举向右走两趟的情况
		x=m-a[i]*2;
		if(x<0) continue;
		while(b[pos]>x) pos--;
		ans=max(ans,i+pos);
	}
	cout<<ans+ans2<<'\n';
	return 0;
}
```

希望这篇题解能够帮到你！

---

## 作者：JYX0924 (赞：1)

这道题可以分类讨论成两种情况：只在 $a_{i} \ge 0$ 或 $a_{i} \le 0$ 的位置采矿；在两种区域都采矿。

这里我们可以先把所有的数加上 $1000005$ 让他们都变成正数，然后用树状数组维护 $[1,i]$ 有多少矿，暴力枚举每一次走到哪个位置掉头或停止。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
#define maxn 100005 
#define maxm 1000005 
using namespace std;
ll n,m,a[maxn],sum[maxm<<3],ans;
ll lowbit(ll now) {return now&(-now);}
void add(ll now) {for(int i=now;i<maxm*6;i+=lowbit(i)) sum[i]++;}
ll get(ll now) {ll ret=0; for(int i=now;i>0;i-=lowbit(i)) ret+=sum[i]; return ret;}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>m; for(int i=1;i<=n;i++) cin>>a[i],a[i]+=maxm,add(a[i]);
	for(int i=1;i<=n;i++)
	{
		if(abs(a[i]-maxm)>m) continue;
		ll tt; if(a[i]>=maxm) tt=get(a[i])-get(maxm-1); else tt=get(maxm)-get(a[i]-1);
		ans=max(ans,tt);
		if(a[i]>=maxm&&(a[i]-maxm)*2>m) continue;
		if(a[i]<maxm&&(maxm-a[i])*2>m) continue;
		if(a[i]>=maxm) tt+=(get(maxm-1)-get(maxm-(m-(a[i]-maxm)*2)-1));
		if(a[i]<maxm) tt+=(get(maxm+(m-(maxm-a[i])*2))-get(maxm));
		ans=max(ans,tt);
	}
	cout<<ans;
	return 0;
}
```
谢谢大家！！！

---

## 作者：xyx404 (赞：1)

## 思路：
定义两个数组 $a$ 和 $b$，其中 $a$ 存输入为正数的情况，$b$ 存输入为负数时负数的绝对值，在定义两个变量 $cnt$ 存起点矿石的情况，$ans$ 存最多挖矿石几个矿石不包含起点矿石的情况。

输入完后将 $a$ 数组与 $b$ 数组排序。

排序过后枚举情况，共有两种情况，第一种完全不向右侧挖掘，第二种向右走两次向左走一次，每次枚举完情况后更新 $ans$ 的值。

最终的结果为在输入中 $ans+cnt$。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std; 
#define LL long long
#define itn int
#define ull unsigned long long
vector<LL>a,b;// 分别存储正数和负数(取绝对值后)
int main(){
	LL n,m;
	cin>>n>>m;
	LL cnt=0;// 计算坐标为 0 的矿洞数量
	a.push_back(0);// 下标从 1 开始 
	b.push_back(0);
	for(LL i=0;i<n;i++){
		LL sr;
		cin>>sr;
		if(sr==0)cnt++;// 坐标为 0 的矿洞直接计算
		else if(sr>0)a.push_back(sr);// 正数放入 a 数组
		else b.push_back(-sr);// 负数取绝对值后放入 b 数组
		
	}
	sort(a.begin()+1,a.end());
	sort(b.begin()+1,b.end());
	LL ans=0,pos1=b.size()-1,pos2=b.size()-1;
	for(LL i=0;i<=a.size()-1;i++){// 枚举情况 
		LL x=m-a[i];
		if(x<0)continue;
		while(b[pos1]>x/2)pos1--; 
		ans=max(ans,i+pos1);
//		cout<<ans<<" 1 \n";
		// 完全不向右侧挖掘
		x=m-a[i]*2;
		if(x<0)continue;
		while(b[pos2]>x)pos2--; 
		ans=max(ans,i+pos2);
//		cout<<ans<<" 2 \n";
		// 向右走两次向左走一次
	}
//	cout<<ans<<" "<<cnt<<"\n";
	cout<<ans+cnt;
	return 0;
}
```

---


# “非常男女”计划

## 题目描述

近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。


## 样例 #1

### 输入

```
9
0 1 0 0 0 1 1 0 0
```

### 输出

```
6```

# 题解

## 作者：AKB48 (赞：163)

引入相对差的概念。即a[i]表示第i个位置男生人数-女生人数的差值。

那么差值相等的两个位置之间的人数是满足男女相等的。

从此统计l[a[i]]和r[a[i]]。

特别要注意的是a[0]=0 统计的时候要把0的位置当做差为0的起点。


---

## 作者：小小二逼兽 (赞：136)

计算男女生数量差值x，同时记录差为x时，最左边和最右边的位置，扫一遍就OK
```cpp
#include <bits/stdc++.h>
using namespace std;
int l[200010],r[200010],sum1,sum0,ans,n;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++){
        int x; cin>>x;
        sum1+=(x==1), sum0+=(x==0);
        int t=sum0-sum1+n;
        if (!l[t]&&t!=n) l[t]=i; else r[t]=i;
    }
    for (int i=0;i<=2*n;i++) ans=max(ans,r[i]-l[i]);
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：KellyFrog (赞：62)

~~此篇题解是给像我一样的蒟蒻看的垃圾题解，大佬估计也不会刷黄题~~
## 题目大意
找到区间 ```{i,j}``` 使 ```j-i```最大，且区间 ```{i,j}``` 中男女数量相等

## 一些想法

### 这是最先想到的部分

很明显要存个前缀和，若```sum[i]=sum[j]```，说明区间```{i,j}```满足条件

我们不妨看个表格

| num[i]（当前数值，男生为1，女生为-1） | -1 | 1 | -1 | -1 | -1 | 1 | 1 | -1 | -1 |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
| sum[i]（前缀和数组） | -1 | 0 | -1 | -2 | -3 | -2 | -1 | -2 | -3 | 

显然，当```sum[j]-sum[i]==0```的时候，区间中间的男生女生一正一负刚好抵消，区间 ```{i,j}``` 符合条件

### 最关键的部分来了
我们要寻找```sum[i] == sum[j]```，很明显，我们不能用O(n^2)的方式去爆搜

#### 我们怎么把时间降到O(n)呢？
我们想要找到符合条件的数对，为什么不以一种近似哈希~~实则就是哈希~~的东西吧每个前缀和最开始出现的位置和最后出现的位置记下来呢？

```
hash[sum[i]]._min表示前缀和sum[i]最先出现的位置

hash[sum[i]]._max表示前缀和sum[i]最后出现的位置
```

因为```i```是往前跑的，所以不用```max()```
最后遍历```i```：

## 一些代码段

```cpp
for(int i = 1; i < n + 1; i++) {
   hash[sum[i]]._min = min(hash[sum[i]]._min, i);
   hash[sum[i]]._max = i;
}
```
但是，这里会出现一些问题，比如这个样例，```sum```数组全都是负数，访问一个负数下标会RE或者出一些奇奇怪怪的数，所以要修改一下，加上100010（其实比n大就可以）

```cpp
for(int i = 1; i < n + 1; i++){
   hash[sum[i]+100010]._min = min(hash[sum[i]+100010]._min, i);
   hash[sum[i]+100010]._max = i;
}
```
最后输出一下就行了，用```ans```记录最大差值，最后如果是0就直接输出，否则输出```ans+1```

代码就不摆了（~~毕竟黄题~~），码风奇丑，望理解

## 一些需要注意的地方
1. 初始化hash数组的时候要从0跑到```2n```，~~保险起见我用了```2n+5```~~
2. 初始化hash数组的._min和._max一定得是```±100000```以上

3. 如果你的```i```是从0开始跑的，注意，在填充```sum```数组的时候要特判```i==0```

4. 加一个多少以便把负的加成非负的数的时候，一定小心你的```i```是从哪里跑的，一不小心就容易出一堆烂七八糟的东西
###### ~~悄悄说一句，就这一道黄题我调了快40分钟~~

---

## 作者：abc123_abc123 (赞：19)

读题后可以发现，这题可以用前缀和。

因为男女配对，所以不妨使 男+女=0 ，也就是把女置为-1，男置为1。

然后我们可以用前缀和s[i]判断1~i是否为0，还有s[i]-s[j-1]就表示j~i是否完全配对。

想了想，我们的前缀和只有s[i]==s[j-1]时才更新ans，那为什么不把s[i]的值最早出现的位置记录下来呢？

因为这里每次+1或-1，所以值域为[-n,n]，加n后就是[0,2n]了！

然后桶记录下来就好了。

但是我懒得打桶，时间也不紧，用map就好了。

附上代码：
```cpp
#include<cstdio>
#include<map>
using namespace std;
map<int,bool> bj;	//该值是否出现的标记
map<int,int> mp;	//最早出现的位置
int n,i,u,sum,ans;
inline int maxs(int a,int b)
{
	return a>b?a:b;
}
int main()
{
	scanf("%d",&n);
	bj[0]=1;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&u);
		if(u==0)u=-1;
		sum+=u;			//与前面的前缀和无关了
                     	//所以我们直接加上去
		if(bj[sum]==0)
		{
			bj[sum]=1;	//未出现记录第一次出现
			mp[sum]=i;
		}
		else
		ans=maxs(ans,i-mp[sum]);//出现则更新ans
	}
	printf("%d",ans);
	return 0;
}
```

补上桶的代码：

```cpp
#include<cstdio>
#include<map>
using namespace std;
int mp[200010],bj[200010];
int n,i,u,sum,ans,x;
inline int maxs(int a,int b)
{
	return a>b?a:b;
}
int main()
{
	scanf("%d",&n);
	bj[n]=1;					//初始的0加上n
	for(i=1;i<=n;i++)
	{
		scanf("%d",&u);
		if(u==0)u=-1;
		sum+=u;
		x=sum+n;				//后面的前缀和也加上n
		if(bj[x]==0)
		{
			bj[x]=1;
			mp[x]=i;
		}
		else
		ans=maxs(ans,i-mp[x]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：北凌scoffs (赞：16)

```c
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1005*1005];
int cnt[1005*1005];//表管数据多大，能过得都是爷爷，pig教导 
int flagboy=0,flaggirl=0;//下面可以用来简单优化一下
//不过没啥影响
//可以直接搞定 
int main() {
	ios::sync_with_stdio(false);
	//那啥，cin,stdin,cou,stdout是相互兼容的，禁止掉可以加速
	//和scanf,printf差不多
	//咱来打一打一波题解
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>a[i];//正常输入
	for(int i=1; i<=n; i++)
		cnt[i]=cnt[i-1]+a[i];
		//这里处理一下前i的和
		//boy是0嘛，然后girl是1，如果满足每个boy都匹配一个girl的话
		//那么着一段序列的总和其实就是girl的总和，及长度的一半
		//然后这就是处理掉开头和结尾的关键l
		//我原来要for循环枚举开头和结尾构成的区间
		//现在要求区间只需要找到两个区间，然后相减便可以了
		//比如说
		//0 0 1 1 0 0
		//要求--1 1区间的总和，可以用前5区间和减去前2区间和 
	for(int i=n; i>=0; i--) {//要求最长，所以倒着来，第一个找到的就是最优解
	//如果要求最小的，就顺着来 
		if(i%2==0) {//boy==girl所以长度一定为偶数---i是枚举长度 
			for(int j=1; j<=n-i+1; j++) {
				//j枚举开头
				//解释一下为什么要j<=n-i+1
				//j是开头，i是长度，n是最长长度 
				//那么j+i<=n?对吗？错!
				//j是开头啊，j也要算啊，所以是j+i+1<=n，然后移项，
				//就得到了  j<=n-i+1
				if(cnt[i+j-1]-cnt[j-1]==i/2) {
					cout<<i<<endl;//就是上面讲的
					//求到中间的区间总和如果是i的一半，说明有一半都是girl提供
					//前面已经解释，不再多说! 
					return 0;//结束，找到最优解 
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：嘟嘟cqy (赞：11)

看了看题解，发现没有和我一样的做法。。。  
其实普通前缀和是非常容易想到的，但是会T飞掉。  
于是就产生了一个玄学的优化。  
本来，在前缀和做完了之后，要有这样一段枚举：
```cpp
for(int i=0;i<=n;i++)
for(int j=0;j<=n;j++)
	if(b[j]-b[i]==g[j]-g[i])
		ans=max(ans,j-i);
```
优化1：
```cpp
for(int i=0;i<=n;i++)
for(int j=i;j<=n;j++)
	if(b[j]-b[i]==g[j]-g[i])
		ans=max(ans,j-i);
```
开O2好像有70points，还不够，于是又有了如下的  
优化2：
```cpp
for(int i=0;i<=n;i++)
for(int j=i+ans-1;j<=n;j++)
	if(b[j]-b[i]==g[j]-g[i])
		ans=max(ans,j-i);
```
因为长度一定大于ans所以就可以从i+ans-1枚举了。
AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b[100010],g[100010],ans;
bool a[100010];
int main()
{
	
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
		if(a[i]==1)
			b[i]=b[i-1]+1;
		else	b[i]=b[i-1];
	for(int i=1;i<=n;i++)
		if(a[i]==0)
			g[i]=g[i-1]+1;
		else	g[i]=g[i-1];
	for(int i=0;i<=n;i++)
	{
		for(int j=i+ans;j<=n;j++)
			if(b[j]-b[i]==g[j]-g[i])
				ans=max(ans,j-i);
	}
		
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：wjy2006 (赞：9)

我最初的思路是二分枚举长度，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q[111111],a[111111];//q用来存储前缀和
bool check(int len){
	len*=2;//因为长度一定是偶数，所以我枚举的是长度的一半，用的时候要*2
	for(int i=0;i<=n-len;i++){
		if(q[i+len]-q[i]==len/2) {//检测是否满足要求
			return 1;
		}
	}
	return 0;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],q[i]=q[i-1]+a[i];
	int l=0,r=n/2;
	while(l<=r){//常见的二分模板
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1;
		else r=mid-1;
	}
	cout<<r*2<<endl;
	return 0;
}
```

但交上去只拿到了80分。仔细一想：


假设数列是这样的

11000011

显然，答案应该是8，但是，根据二分的原理，当枚举的长度为6时，却找不到一个可行的解，所以程序会认为答案比6小。

所以，我们发现，当check函数返回的值为0时，不一定答案比当前枚举的长度小，当check函数返回的值为1时，答案一定大于等于当前枚举的长度，时间复杂度为O(n * 玄学)。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q[111111],a[111111];
int ans;
bool check(int len){
	for(int i=0;i<=n-len;i++){
		if(q[i+len]*2-q[i]*2==len) {
			return 1;
		}
	}
	return 0;
}
void er(int l,int r){//更改后的二分
	if(r<=ans||l>r) return ;//小剪枝
	int mid=(l+r)>>1;
	er(mid+1,r);
	if(check(mid)==0) er(l,mid-1);
	else ans=max(ans,mid);//更新答案
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],q[i]=q[i-1]+a[i];
	er(0,n);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Rachel_in (赞：8)

本题我用的是前缀和，不同于暴力n方枚举，我直接**由大到小**枚举长度，然后枚举开头，一旦该区间是符合要求的区间就可以退出程序（因为该长度一定为最优解了）加了这个小优化后发现效率还不错。

附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],sum[100001],i,j,n,ans;//a数组可以转化为一个整形（因为之后只用到sum），~~为了便于理解，补上a数组~~
bool flagm,flagf;
int main()
{
 scanf("%d",&n);
 flagm=flagf=false;
 for(i=1;i<=n;i++)
 {
  scanf("%d",&a[i]),sum[i]=sum[i-1]+a[i];
  if(a[i]==1) flagm=true;
  if(a[i]==0) flagf=true;
 }
 if(!flagm||!flagf) //特判
 {
 	cout<<0;
    return 0;
 }
 for(i=n;i>=2;i--)//前面特判后，最小长度一定为2
  if(i%2==0)//长度必须为偶数
   {
   	for(j=1;j<=n-i+1;j++)
   	 if(sum[i+j-1]-sum[j-1]==i/2)//前缀和
   	  {
   	     cout<<i;
		 return 0;	//结束程序，找到最优解 	
	  }
   }
   return 0;
} 
```

---

## 作者：Randyhoads (赞：7)

这道题就是前缀和~

可以用一个桶去记录男生女生现在差第一次与最后一次出现的位置那他们之间就是符合要求的序列












```cpp
#include<cstdio>
using namespace std;
inline int Min(int a,int b)//比较大小的两个函数
{
    if(a<b) return a;
    else return b;
}
inline int Max (int a,int b)
{
    if(a>b) return a;
    else return b;
}
int n;
int a;
int sum[100001];
int ton[200001][2];//记录第一次出现和最后一次出现位置的桶
int maxp;//最高出现的差，减少循环次数
int ans; 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        if(a==0) sum[i]=sum[i-1]-1;
        if(a==1) sum[i]=sum[i-1]+1;//前缀和
        if(ton[sum[i]+n][0]==0)
        ton[sum[i]+n][0]=i;//记录第一次
        ton[sum[i]+n][1]=Max(ton[sum[i]+n][1],i);//记录最后一次
               //加N是应为会有负数
        maxp=Max(maxp,sum[i]+n);
    }
    ton[n][0]=0;//然而差为0时第一次在第0位
    for(int i=1;i<=maxp;i++)
        ans=Max(ans,ton[i][1]-ton[i][0]);
    printf("%d\n",ans);
    return 0; 
}
```

---

## 作者：Tchaikovsky (赞：6)

根据男生为1，女生为0，我们可以维护一个前缀和，然后来个O（n²）循环，枚举每一种可能，额 可是n² 必超时，【实际是O（n²/2）】

这里就要靠强大的剪枝了-----看ans的妙用  O(∩\_∩)O~ 完美AC.....（有点数据水的嫌疑）

答题思路是：用前缀和维护数组,如果sum[j]-sum[i-1]的值为数组下标差值的一半 则满足题意，一边下来找出最大的满足条件的(j-i+1);然后输出ans; 注：循环要剪枝！

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,a[100010],sum[100010],ans;
int read()
{
    int r=0,k=1;
    char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')k=-1;
    for(;c>='0'&&c<='9';c=getchar())r=r*10+c-'0';
    return r*k;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++) 
    {
        a[i]=read();
        sum[i]=sum[i-1]+a[i];
    }
    for(int i=1;i<=n-ans;i++)
    {
        for(int j=i+1+ans;j<=n;j+=2)
        {
            if(((sum[j]-sum[i-1])*2==(j-i+1))&&(j-i+1)>ans) 
            ans=j-i+1;//更新答案 
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：ljh736731592 (赞：3)



## 广播操比赛

[题](https://www.luogu.org/problem/P1114)


【问题描述】

XMYZ一年一度的运动会开始了，作为本次活动的第一个集体项目，段长林老师特别重视，经过调查研究，林老师发现当身高接近，而且男女生人数相等时，列队做操是最整齐的。但是按评分的要求，参加的人数越多分数越高，于是林段想到一个办法：他让年段所有同学按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。根据评分规则，林老师当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。

 

【输入】

第一行有一个正整数n，代表年段的人数。
　　第二行有n个用空格隔开的数，这些数只能是0或1，其中，0代表一个女生，1代表一个男生

【输出】

输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子序列长度。
　　如果不存在男女人数相等的子序列，请输出0。

【输入输出样例1】

9

0 1 0 0 0 1 1 0 0

6

 

样例说明：
　选择第2个人至第7个人可以获得男女人数均为3的最长子序列。

 

【限制】

对于30%的数据，n<=100；
对于50%的数据，n<=1 000；
对于100%的数据，n<=100 000

---

显然dp啊

---

先看**zkq**的n^2暴力

```cpp
#pragma GCC optimize(2)
#include<cstdio>
#include<cstdlib>
const int N=100100;
bool a[N];
int sum[N];
int n,m,mid;
int ans;
inline void read(int&x)
{
    char c=getchar();int f=1;x=0;
    while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();}
    while(c<='9'&&c>='0') x=(x<<1)+(x<<3)+c-'0',c=getchar();
    x=f==1?x:-x;
}
inline void readbl(bool&x)
{
    char c=getchar();x=0;
    while(c>'9'||c<'0'){c=getchar();}
    if(c=='1')x=1;
}
using namespace std;
int main()
{
    read(n);
     
    for(int i=1;i<=n;i++) 
    {
        readbl(a[i]);
        if(a[i])sum[i]=sum[i-1]+1;
        else sum[i]=sum[i-1];
    }
    if(sum[n]==n||sum[n]==0){puts("0");exit(0);}
    if(n&1) m=n-1;
    else m=n;
    for(register int l=m;l>=2;l-=2)
    {
        mid=l>>1;
        for(register int i=1,j=l;j<=n;i++,j++)
        {
            if((sum[j]-sum[i-1])==mid)
            {
                ans=l;
                printf("%d",l);
                exit(0);
            }
        }
    }
}

```

~~我也不知道咋做的~~ 

---


dp


```cpp
#include<bits/stdc++.h>
#define re register
#define read(x)\
{\
    re int f=1;\
    x=0;\
    re char c=getchar();\
    while(!(c>='0'&&c<='9'))\
    {\
        if(c=='-')\
        f=-1;\
        c=getchar();\
    }\
    while((c>='0'&&c<='9'))\
    {\
        x=x*10+(c-'0');\
        c=getchar();\
    }\
    x=x*f;\
}
#define max_(x,q)\
    (x<q)?q:x
using namespace std;
int ans,n,a[1000001],l[1000001],r[1000001],g,b,t=n;
int main()
{
    read(n);
    t=n;
    for(re int i=1;i<=n;i++)
    {
        read(a[i]);
        if(a[i]==1&&b==0)
        b=1;
        if(a[i]==0&&g==0)
        g=1;
    }
    if(g==0||b==0)
    {
        putchar('0');
        exit(0);
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]==1)
        t--;
        else
        t++;
        if(!l[t]&&t!=n)
        l[t]=i;
        else
        r[t]=i;
    }
    for(int i=0;i<=2*n;i++)
    ans=max_(ans,r[i]-l[i]);
    printf("%d",ans);
}

```





---

## 作者：Bring (赞：3)

[更好的阅读体验请点击这里](https://www.cnblogs.com/BrianPeng/p/12165425.html)

这是一道练习前缀和思想（然而不是特别明显）的经典题目

如果将男生表示$1$，女生表示$-1$，那么题目就变成了求能使区间和为$0$的最大区间长度（是不是有点前缀和的味道了）

但是单单枚举区间两端，$O(n^2)$的时间复杂度明显超时，而且这种方法根本不需要前缀和（直接求和即可）

这道题的要点在于$\sum_{i=l}^ra_i=\sum_{i=1}^ra_i-\sum_{i=1}^{l-1}a_i$

所以当$\sum_{i=l}^ra_i=0$时，$\sum_{i=1}^ra_i=\sum_{i=1}^{l-1}a_i$

所以关键在于对于两个端点$l,r$，如果$s_l=s_r$，那么$[l+1,r]$就是一个可行区间

对所有端点$i$，按照$s_i$分类，对每一类求极差，取最大值即可

**P.s 其中端点$0$属于$s_i=0$类**

具体见代码（$s_{1..n}$被优化掉了，用$p_i,-n<=i<=n$表示每一个$s_j=i$的最小$j$，若不存在则$p_i=-1$）

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
inline int read(){
	register int x;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,x=c&15;else k=x=0;
	while(isdigit(Gc(c)))x=(x<<1)+(x<<3)+(c&15);
	return k?x:-x;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
#define N (200010)
#define P(a) (p[a+n])
int n,p[N],s,ans;
signed main(){
	Rd(n),Mst(p,-1),P(0)=0;
	Frn1(i,1,n)s+=read()?1:-1,~P(s)?ans=max(ans,i-P(s)):P(s)=i;
	wr(ans),exit(0);
}
```

---

## 作者：ChrisK (赞：2)

怎么缺少STL【滑稽

用两个map，一个记录之前差值出现过没有，另外一个记录最早的差值是什么时候出现的。

就是别忘了0


代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int c[100010];
map<long long,bool> mm;
map<long long,int> mp;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int x;scanf("%d",&x);
        mm[0]=1;
        if(x) c[i]=c[i-1]+1;
        else c[i]=c[i-1]-1;
        if(mm[c[i]]!=0) ans=max(ans,i-mp[c[i]]);
        else mp[c[i]]=i,mm[c[i]]=1;
    }
    cout<<ans<<endl;
    return 0;
}

```


---

## 作者：wangzh (赞：2)

    
    
```cpp
#include <stdio.h>
#include<stdlib.h>
int main()
{
    int n,t;
    int *b,*num; 
    int count[2]={0,0};//统计从第一个到第i个位置的子段中，0和1的个数 
    int maxlen=0,currlen=0;
    int i;    
    scanf("%d",&n);
    b=(int *)malloc((n+1)*sizeof(int));
    num=(int *)malloc((n*2+1)*sizeof(int));    
    for(i=0;i<=n;i++)
        b[i]=0;       //b[i]用于记录0-1序列的前i个值中，0和1的个数之差
    for(i=0;i<=2*n+1;i++)
        num[i]=-1;   //num[]用于统计记录b[]各元素首次出现的下标。比如b[i]==x，而且i是x在b[]首次出现的位置，则num[b[i]+n]=i。num[i]默认值-1.
    for(i=1;i<=n;i++)
    {
        scanf("%d",&t); //输入一个数字：0或1 
        count[t]++;     //统计0和1的个数 
        b[i]=count[0]-count[1];//b[i]保存0-1序列的前i个元素中：0和1的个数之差 
    }
    if(count[0]==count[1]) printf("%d\n",count[0]+count[1]);
    else
    {
        for(i=0;i<=n;i++)//注意：从0和1的个数都是0的地方开始扫描 
        {
            if(num[b[i]+n]==-1)   //检测b[i]的值是否曾经在b[]出现过。num[b[i]+n]== -1表示b[i]没有出现过
                num[b[i]+n]=i;    //记录b[i]的值在b[]首次出现的位置i
            else//already exist
            {
                currlen = i - num[b[i]+n] ;   //num[b[i]+n]是b[i]首次出现的下标
                if(currlen > maxlen)
                    maxlen = currlen;
            }
        }
        printf("%d\n",maxlen);
    }
    free(b);
    free(num);
    return 0;
}
```
仅做参考程序：http://www.cnblogs.com/huashanqingzhu/p/4676347.htm
一位老前辈的程序


---

## 作者：顾z (赞：1)

题目描述：---> [P1114 “非常男女”计划](https://www.luogu.org/problemnew/show/P1114)

## 广告： [安利blog](https://www.luogu.org/blog/RPdreamer/#)

**题意概括：**

寻找一段最长的0和1的子序列,要求0和1的数量相同。

**分析：**

很明显,**前缀和问题**。

我们可以将代表女生的值改为-1,这样代表男生的值就是1,1与-1相加即为0,这样如果男生女生人数相同的话,前缀和就是0。

如果直接去写,最普通的写法 O(n^2)?

~~(复杂度不会证明QAQ~~

```cpp
/*60pts*/
for(RI i=1;i<=n;i++)
        for(RI j=i+1;j<=n;j++)
        {
            if(sum[j]-sum[i-1]==0)
                ans=std::max(ans,j-i+1);
        }
```

很不幸,即使吸氧我们也只能能得到70pts.

**考虑如何优化**~~(看了一眼题解~~

存储某个值(前缀和的值)出现过的最左端位置.

再通过枚举去得到我们最长的连续序列,

	以样例为例,我们会得到这样的一个前缀和序列↓
    原序列:0  1  0  0  0  1  1  0  0
    新序列:-1 0 -1 -2 -3 -2 -1 -2 -3
    容易发现 我们的答案是7-1=6

可是如果这个值为负的怎么办?

**数组下标不支持负的**想必大家都知道.

**怎么办？**

提供解决方案:

1.一位会指针存储负下标的大佬%%%[@花_Q](https://www.luogu.org/space/show?uid=87940)

//你可以~~贿赂~~请教他.

2.把数组开的更大一些.

//感觉这个很现实吧~~

我们可以把数组开的更大一些

(由于懒得去判断,所以我直接开了好大的..

然后在读入的时候再存储一下这个值出现位置

(我们从左到右读入,得到的位置一定是最靠左的.

**记得取max！**

--------------------代码--------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define m 100008
#define clear(a) memset(a,0,sizeof a)
IL void read(int &x){
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,sum[100008],ans,mp[m<<1];
int main()
{
	read(n);
	for(RI i=1,sex;i<=n;i++)
	{
		read(sex);
		if(sex==0)sex=-1;//将女生的值改为-1,达到两两配对的效果.
		sum[i]=sum[i-1]+sex;
		if(!mp[sum[i]+m])mp[sum[i]+m]=i;//上面↑m足够大吧~
	}
	for(RI i=1;i<=n;i++)
		ans=std::max(ans,sum[i]==0?i:0);
    //printf("%d",ans);
	for(RI i=1;i<=n;i++)
		if(mp[sum[i]+m] and i!=mp[sum[i]+m])//这个and和&&是一样的
            	ans=std::max(ans,i-mp[sum[i]+m]); 
	printf("%d",ans);
}
```

---

## 作者：Mashiro_ylb (赞：1)

#emmm排序

核心思想仍然是楼上的前缀和标准差，当读到男生时+1，读到女生时-1，维护一个前缀和，当前缀和相等时即为出现男女人数相等的子序列。

不一样的是查找最长序列的方式，笔者先将前缀和按升序排序，这样就可以轻松把前缀和相同的区间凑到一起；统计每一个前缀和相同的区间长度，利用双指针区间扫描找最大值即可。这当然没有楼上dalao们程序快，不过时间复杂度还是允许的，详情请见代码。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
#include<cmath>
#define by Mashiro_ylb
#define TIME 2017/10/28
using namespace std;
const int max_data = 100007;

struct node
{
    int data;  //记录前缀和大小
    int cnt;  //记录出现位置
}a[max_data];
int n;

template<class T>void read(T &x) //读入优化
{
    int f = 0; x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();
    while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = f? -x : x;
}
template<class T>void write(T x) //输出优化
{
    if(x < 0) x = -x, putchar('-');
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
template<class T>T Max(T x, T y){return x > y? x : y;}
bool cmp(const node &x, const node &y){return x.data == y.data? (x.cnt < y.cnt) : (x.data < y.data);} //先按照前缀和升序排序，若相等则按照出现位置升序排序
void init();
int work();

int main()
{
//    freopen("in.txt","r",stdin);
    init();
    write(work());
    return 0;
}

void init()
{
    read(n);
    int x;
    for(int i = 1; i <= n; i++)
      {
          read(x);
          a[i].data = a[i - 1].data + (x? 1 : -1);  //前缀求和
          a[i].cnt = i;  //记录出现位置
      }
}

int work()
{
    int maxn = 0;  //记录最大值
    sort(a + 0, a + n + 1, cmp);  //排序（注意从0开始而不是1）
    int z1 = 0, z2 = 1;  //设立双指针
    while(z2 <= n)  //区间扫描
      {
          if(a[z1].data == a[z2].data)  //查找最大区间
            {
                  z2++;
                  continue;
          }
        else
          {
              maxn = Max(maxn, a[z2 - 1].cnt - a[z1].cnt);  //记录
              z1 = z2;
          }
      }
    return maxn;
}
```

---

## 作者：skylee (赞：0)

参考@AKB48的思路，使用它“**相对差**”的概念。

那么我们就不妨定义一个数组A，A[i]表示第i个位置男生人数-女生人数的差值。

实现细节：

从大到小枚举每一种可能的差（必定为偶数），对于每一种差，枚举每一种可能的序列，若a[i]=a[i+k]那么就满足题目要求的条件，k就是所求的值。

```delphi
var
    n,i,k:longint;
    a:array[0..100000]of longint;
begin
    readln(n);
    a[0]:=0;//a[0]是统计的起点
    for i:=1 to n do begin
        read(k);
        if k=0 then begin
            a[i]:=a[i-1]-1//女生-1
        end
        else begin
            a[i]:=a[i-1]+1//男生+1
        end
    end;
    for k:=n downto 0 do begin//枚举可能的差
        if odd(k) then begin//差必定是偶数
			continue
        end;
        for i:=0 to n-k do begin//枚举长度为k的可能的序列
            if a[i]=a[i+k] then begin
                writeln(k);
				halt
            end
        end
    end
end.
```

---


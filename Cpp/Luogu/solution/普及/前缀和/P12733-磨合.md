# 磨合

## 题目背景

> 「能够像这样『磨合』，实在是帮了个大忙。」\
——绫濑沙季

## 题目描述

悠太和沙季遇到了 $n$ 个问题，问题的难度分别为 $d_1,\dots,d_n$。

他们可以以任意顺序解决问题，对于准备解决的第 $i$ 个问题，每将难度减少 $1$，两人需要花费 $i$ 秒。将难度减少为 $0$ 时问题被解决，他们才可以继续解决下一个问题。

如果他们正在解决第 $i$ 个问题（即难度尚未减少为 $0$），但剩余时间少于 $i$ 秒，他们就不能继续解决剩下的问题了，第 $i$ 个问题也没有解决。

他们想要知道，如果共有 $t$ 秒，那么最多能解决多少个问题。由于他们可能面对很多种不同情况，所以会多次改变 $t$ 进行询问。

## 说明/提示

#### 样例 1 解释

若 $t=10$，则第 $1$ 个解决难度为 $7$ 的问题，第 $2$ 个解决难度为 $1$ 的问题，花费的时间为 $1\times7+2\times1=9$ 秒。可以证明他们无法解决三个问题。

若 $t=16$，则依次解决难度为 $7,3,1$ 的问题，花费的时间为 $1\times7+2\times3+3\times1=16$ 秒。

#### 数据范围与限制

**本题采用捆绑测试，各 Subtask 的限制与分值如下。**

| Subtask No. | $n\le$ | $q\le$ | $d_i\le$ | $t\le$ | 分值 | 依赖子任务 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| $1$ | $10$ | $1$ | $10$ | $10^3$ | $13$ |  |
| $2$ | $10^3$ | $1$ | $10^3$ | $10^9$ | $24$ | $1$ |
| $3$ | $10^3$ | $10^6$ | $10^3$ | $10^9$ | $16$ | $1,2$ |
| $4$ | $10^6$ | $1$ | $10^3$ | $10^{16}$ | $16$ | $1,2$ |
| $5$ | $10^6$ | $10^6$ | $10^3$ | $10^{16}$ | $31$ | $1,2,3,4$ |

对于所有数据，满足 $1\le n,q\le10^6$，$1\le d_i\le10^3$，$0\le t\le10^{16}$。

## 样例 #1

### 输入

```
3 2
1 7 3
10
16
```

### 输出

```
2
3
```

## 样例 #2

### 输入

```
10 3
923 243 389 974 100 485 296 377 61 552
2403
5819
0
```

### 输出

```
5
6
0
```

# 题解

## 作者：VinstaG173 (赞：18)

设排序后的难度数组为 $d_1,\dots,d_n$，则容易证明解决 $k$ 个问题至少需要 $\sum_{i=1}^ki\cdot d_{k-i+1}$ 时间。

注意到 $\sum_{i=1}^ki\cdot d_{k-i+1}=\sum_{i=1}^k\sum_{j=i}^kd_i=\sum_{j=1}^k\sum_{i=1}^jd_i$，可以用两次前缀和预处理，二分答案即可。

Code:
```cpp
int n,q,l,r,m;
ll d[1000003],t;
inline void solve(){
	cin>>n>>q;
	for(int i=1;i<=n;++i)
		cin>>d[i];
	sort(d+1,d+n+1);
	for(int i=1;i<=n;++i)
		d[i]+=d[i-1];
	for(int i=1;i<=n;++i)
		d[i]+=d[i-1];
	while(q--){
		cin>>t;l=0,r=n;
		while(l<r){
			m=l+r+1>>1;
			if(d[m]>t)r=m-1;
			else l=m;
		}cout<<l<<"\n";
	}
}
```

---

## 作者：Nostopathy (赞：3)

# Solution

本题的关键在于“对于准备解决的第 $i$ 个问题，每将难度减少 $1$，两人需要花费 $i$ 秒”这句话。

因为解决的顺序直接影响到时间，我们让越大的 $d_i$ 匹配越小的 $i$（即越先解决），可证明此时 $d_i \times i$ 最小。

下文的数组 $d$ 表示排序后的原数组，则总时间为 $nd_1+(n-1)d_2+\dots+2d_{n-1}+d_n$，这里可以用两层前缀和预处理掉枚举。

![](https://cdn.luogu.com.cn/upload/image_hosting/7t1tcwvv.png)

有时并不能完成所有问题，因此需要二分查找。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int, int>
#define pb push_back
#define rep(a, b, c, d) for(int a=b; a<=c; a+=d)
const int N = 1e6 + 5;
int n, t, a[N];
signed main () {
	int q;
	scanf("%lld%lld", &n, &q);
	rep(i, 1, n, 1)
		scanf("%lld", &a[i]);
	sort(a + 1, a + n + 1);
	rep(j, 1, 2, 1)
		rep(i, 1, n, 1)
			a[i] += a[i - 1];
	while(q --) {
		scanf("%lld", &t);
		int l = 0, r = n;
		while(l < r) {
			int mid = (l + r + 1) >> 1;
			if(a[mid] > t)
				r = mid - 1;
			else
				l = mid;
		}
		printf("%lld\n", l);
	}
	return 0;
}
```

需要当心：

- 先排序后前缀和！
- 如果你用的我这个二分模板，请一定要记得是 `(l + r + 1) >> 1` 而不是 `(l + r) >> 1`！不然 $l=r-1$ 会卡住。
- 解法是 $\Theta(q \log n)$ 的，而 $n,q \leq 10^6$，普通 `cin`、`cout` 会被卡常，请使用 `scanf`、`printf` 或关闭同步流。

~~没有求关的题解不是好题解。~~

---

## 作者：Shijiayi125 (赞：1)

# 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P12733)

现在给你 $n$ 个问题，你可以调换解决的顺序，解决第 $i$ 个问题需要 $i$ 秒。有 $q$ 次询问，每次给出一个 $t$，问最多可以解决几个问题。

# 思路
输入数据后，将 $d$ 数组按升序排序，跑两次**前缀和**，接着枚举每次询问，每次输入一个 $t$，接着使用二分的函数 $\operatorname{upper bound}$，找到第一个小于 $t$ 的数的下标，输出即可

# 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
const int M = 1e5 + 5;
const int INF = 1e9 + 7;
const int mod = 1e9 + 7;
int n,q,m;
//n表示问题的个数,q表示询问的个数
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	//freopen(".in","r".stdin);
	//freopen(".out","w".stdout);
	cin >> n >> q;
	vector<int> d(n+1);
	for(int i=1;i<=n;i++)
		cin >> d[i];
	sort(d.begin(),d.end()); //升序排序
	//跑两次前缀和,因为有两个人,用时为两倍的d[i]
	for(int i=1;i<=n;i++)
		d[i] += d[i-1];
	for(int i=1;i<=n;i++)
		d[i] += d[i-1];
	while(q--){
		cin >> m;
		int ans = upper_bound(d.begin(),d.end(),m) - d.begin() - 1;
		//upper_bound函数(下面用l,r,num代替三个参数)代表从从l到r第一个小于t的数的下标
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：luyanlin (赞：1)

### 引理

这道题目很显然是一道贪心题目，只要从耗时小的物品开始解决就可以解决尽可能多的问题。证明如下：我们可以使用反证法。假设有一个问题所用的时间，要大于我们选择去解决的问题所需要的时间，而最后可以解决的问题却比原来多，那我们一定可以选择耗时更小的问题解决，来节省更多的时间，解决更多的问题。再正推证明：顺序一定是先小后大。先设两个问题，耗时分别为 $x$ 和 $y$，顺序分别是第 $i$ 个和第 $j$ 个，其中 $x\le y$，$i<j$。若先解决耗时 $x$ 的问题，则耗时为 $x\times i+y\times j$；若先解决耗时 $y$ 的问题，则耗时为 $y\times i+x\times j$，现在就是要比较 $x\times i+y\times j$ 和 $y\times i+x\times j$ 的大小，先移项，得到 $x\times i-y\times i$ 和 $x\times j-y\times j$，两边同除 $x-y$，得到 $i$ 和 $j$。又因为 $i<j$，所以 $x\times i+y\times j<y\times i+x\times j$ 所以一定是先小后大，这样才能使耗时最小。

### 算法一

排序完成了。根据引理，既然已经知道是贪心了，那么就可以对于每次询问，枚举可以选择多少可以解决的问题，时间复杂度 $O(nq)$。得分 54pts。

### 算法二

这道题目并不需要什么数据结构优化，只需要一个二分就可以解决问题了。根据引理，算法一就是在找到一个问题个数后，再让耗时最大的问题耗时尽可能小，那么我们就想到了二分。

#### 预处理

首先预处理出选用 $i$ 个问题所需要用的最少时间 $sum_i$，再使用一次引理得出只要解决耗时前 $i$ 的问题再计算时间就可以了。

代码：

```c++
sort(a+1,a+n+1);
int sum=0;
for (int i=1;i<=n;i++){
    ans[i]=ans[i-1]+(long long)sum+(long long)a[i];
    sum+=a[i];
}
```

#### 处理询问

对于每个输入的时间 $t$，我们可以二分用这些时间最多可以处理多少问题。由预处理的方式可以得出一个显而易见的结论：$ans$ 数组是单调递增的。所以二分就十分可行了，我们二分可以处理的问题数 $mid$，然后只要判断所需要的最小时间 $ans_{mid}$ 是不是小于等于 $t$ 就可以了。

秀一下代码：

```c++
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
long long ans[1000005];
int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1);
    int sum=0;
    for (int i=1;i<=n;i++){
        ans[i]=ans[i-1]+(long long)sum+(long long)a[i];
        sum+=a[i];
    }
    while (m--){
        long long t;
        scanf("%lld",&t);
        int l=1,r=n;
        int lst=0;
        while (l<=r){
            int mid=(l+r)/2;
            if (ans[mid]<=t){
                l=mid+1;
                lst=mid;
            }
            else{
                r=mid-1;
            }
        }
        printf("%d\n",lst);
    }
    return 0;
}
```

我觉得已经很详细了，如果有什么问题请直接炮轰我，谢谢。

### 完结！

### 撒花！

---

## 作者：Loyal_Soldier (赞：1)

## 思路

显然，为了尽可能多的解决问题，需要优先解决容易的问题。所以，我们首先要将 $d$ 数组从小到大排序。

于是，我们只需要做一个前缀和，表示解决前 $i$ 个问题需要多少时间，查询时二分一下就行了。

容易发现，解决前 $i$ 个问题至少需要 $\sum_{j = 1}^{i} j \times d_{i - j + 1}$，即为 $\sum_{j = 1}^{i} \sum_{k = 1}^{j} d_k$，用两次前缀和处理就行了。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 10;
int n, q, d[N], sum[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> q;
	for(int i = 1;i <= n;i ++) cin >> d[i];
	sort(d + 1, d + n + 1);//排序
	for(int i = 1;i <= n;i ++) sum[i] = sum[i - 1] + d[i];//进行第一次前缀和
	for(int i = 1;i <= n;i ++) sum[i] += sum[i - 1];//进行第二次前缀和
	while(q --)
	{
		int t;
		cin >> t;
		cout << upper_bound(sum + 1, sum + n + 1, t) - sum - 1 << '\n';//二分答案
	}
	return 0;
}
```

---

## 作者：__CJY__ (赞：1)

## 思路
先将数组 $d$ 进行升序排序，优先解决容易的问题。

我们用 $sd_i$ 来表示前 $i$ 个问题的难度和，使用前缀和公式 $sd_i=sd_{i-1}+d_i$；用 $sid_i$ 来表示解决前 $i$ 个最简单的问题所需的总时间，公式为 $sid_i=sid_{i-1}+d_i \times i$；用 $ps_i$ 来表示解决前 $i$ 个问题所需的**最小总时间**。

我们先找到前 $k$ 个最简单的问题，举几个例子：
* 最简单的问题 $d_1$ 被分配到最后解决（位置 $k$），耗时 $k \times d_1$。
* 第二简单的问题  $d_2$ 被分配到倒数第二解决（位置 $k-1$），耗时 $(k-1) \times d_2$。
* ……
* 最难的问题 $d_k$ 被第一个解决（位置 $1$），耗时 $1 \times d_k$。

只有上述方案才能使结果最优，因为要让最大 $d_i$ 匹配到最小的 $i$。所以 $(k-i+1)$ 是问题 $d_i$ 在解决顺序中的实际位置权重，即 $k,k-1,k-2,\cdots,2,1$。

接下来开始推 $ps_k$ 怎么算：
$$
\begin{aligned}
ps_k&=\sum_{i=1}^k(k-i+1) \times d_i\\
&=k \times \sum_{i=1}^kd_i-\sum_{i=1}^k(i-1) \times d_i\\
&=k \times sd_k-\sum_{i=1}^ki \times d_i+\sum_{i=1}^kd_i\\
&=k \times sd_k-sid_k+sd_k\\
&=(k+1) \times sd_k-sid_k
\end{aligned}
$$
我们用二分枚举 $k$ 即可。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e6+5;
ll d[maxn],n,q,sd[maxn],sid[maxn],ps[maxn];
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>d[i];
	sort(d+1,d+n+1);
	for(int i=1;i<=n;i++) sd[i]=sd[i-1]+d[i],sid[i]=sid[i-1]+i*d[i],ps[i]=(i+1)*sd[i]-sid[i];
	while(q--){
		ll t,l=0,r=n,res=0;cin>>t;
		while(l<=r){
			ll mid=(l+r)/2;
			if(ps[mid]<=t) res=mid,l=mid+1;
			else r=mid-1;
		}
		cout<<res<<'\n';
	}
}
```
注意要开 `long long`！

要关闭同步流 `ios::sync_with_stdio(0),cin.tie(0);`。

---

## 作者：Nahia (赞：0)

### 思路

先考虑贪心，对其进行排序。然后对其进行前缀和，然后再使用二分来查找答案。

设排完序后的难度数组为 $d$，则对其做前缀和 $S_n = \sum\limits_{i=1}^{n} d_i$。再对解决前 $i$ 个问题所需的时间做前缀和，即 $T_n = \sum\limits_{i=1}^{n}S_i$。输出时二分找到可以解决的题目个数即可。

:::info[可行性说明]
为什么可行？以样例 1 为例，排序后求前缀和 $S = \{1,4,11\}$，那么我们得到 $T = \{1,5,16\}$。以 $T_2$ 为例，$T_2 = S_2+S_1 = d_1+d_2+d_1 = 2 \times d_1+d_2$，正好是第一个做第二道题，第二个做第一道题所花费的时间。为了让时间消耗最少，我们需要让小的序号去乘上难度大的题，即先做难的题。
:::

:::warning{open}
十年 OI 一场空，不开 **long long** 见祖宗。
:::

### solution

```cpp line-numbers
#include<bits/stdc++.h>
#define ll long long
#define For(i,a,b) for(int i = a;i<=b;i++)
using namespace std;
inline __int128 read(){__int128 x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-'){f=-1;}c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
inline void write(__int128 x){if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);putchar(x%10+'0');}
ll a[1000005];
int main(){
	int n = read(),q = read();
	For(i,1,n) a[i] = read();
	sort(a+1,a+n+1);
	For(i,1,n) a[i]+=a[i-1];
	For(i,1,n) a[i]+=a[i-1];//两次前缀和
	while(q--){
		ll t = read();
		write(upper_bound(a+1,a+n+1,t)-a-1);//二分找到在t时间内最多能做多少题
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：BeiChenStanly (赞：0)

# 题解：洛谷 P12733 磨合
## 分析
### 贪心
这题先想到贪心：预处理选 $k$ 道题的最少时间，然后二分法找恰好能完成多少题即可。  

而预处理最少时间需要考虑：

1. 假设我们已经选好了 $k$ 个问题，那么，怎样排列他们，才能使总时间最小？由排序不等式知，一定是**倒序**相加。
2. 再来看选哪 $k$ 道题，那肯定是**难度最小**的那 $k$ 道题。可以证明，把其中任意一道题改成难度更大的题，都会使其总时间变大。  

以上两个分析都需要我们先对 $d_i$ 排序。
### 优化
对排序后的序列 $d_1 \le d_2 \le \dots \le d_n$，现在求 $k$ 个问题所用最小时间转化成求 $\sum_{i=1}^{k}(k-i+1)d_{i}$。

观察形式后，我想出两种 $O(n)$ 的预处理方法。
1. 考虑它的对偶式 $\sum_{i=1}^{k}id_{i}$，二者相加就是：
$$\sum_{i=1}^{k}id_{i}+\sum_{i=1}^{k}(k-i+1)d_{i}=(k+1)\sum_{i=1}^{k}d_{i}$$

2. 找到与前缀和的递推关系：
$$\sum_{i=1}^{k+1}(k+1-i+1)d_{i}=\sum_{i=1}^{k}(k-i+1)d_{i}+\sum_{i=1}^{k+1}d_{i}$$

于是，只需排序 $O(n\log n)$ 时间，递推 $O(n)$ 时间，二分 $q$ 次一共花费 $O(q\log n)$ 时间，可以胜任。
## Code
### 第一种优化
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int d[1000005];
ll sum[1000005], isum[1000005], cost[1000005];//题目数据是有可能爆int的
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
        cin >> d[i];
    sort(d + 1, d + n + 1);//排序
    for (ll i = 1; i <= n; i++){
        sum[i] = sum[i - 1] + d[i];//前缀和
        isum[i] = isum[i - 1] + i * d[i];//对偶式
        cost[i] = (i + 1) * sum[i] - isum[i];//最少时间递推
    }
    while (q--){
        ll t;
        cin >> t;
        int k = int(upper_bound(cost + 1, cost + n + 1, t) - cost) - 1;//二分
        cout << k << "\n";
    }
    return 0;
}
```
### 第二种优化
只需删掉全局作用域里的 `isum[1000005]`，并改动主程序即可。
```cpp
for (ll i = 1; i <= n; i++){
  sum[i] = sum[i - 1] + d[i];
  cost[i] = cost[i - 1] + sum[i];
}
```
当然，如果你细心，甚至可以不要前缀和，改成：
```cpp
cost[1] = d[1];
for (ll i = 2; i <= n; i++){
        cost[i] = 2 * cost[i - 1] - cost[i - 2] + d[i];
}
```
这是因为 `cost[i-1]-cost[i-2]=sum[i-1]`。

---

## 作者：koukou (赞：0)

贪心思路不难想到，优先解决容易的问题。

由于要多次查询，可以对数组做一次前缀和，然后查询时直接二分，做到不会超时。

接下来讲一下前缀和的推导：

1. 第一次前缀和（计算排序后难度的前缀和）：\
$S_1[i] = \sum_{k=1}^{i} d_k \quad$ 其中 $\quad d_1 \leq d_2 \leq \dots \leq d_n$

这里$S_1[i]$表示前$i$个最小难度的总和。

2. 第二次前缀和（计算解决前 $i$ 个问题所需的总时间）：\
$S_2[i] = \sum_{k=1}^{i} k \cdot d_k = \sum_{k=1}^{i} S_1[k]$\
这里 $S_2[i]$ 表示按照最优顺序（即按难度从小到大）解决前$i$个问题所需的总时间。

所以对排序以后的原数组做两次前缀和就好了。

代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 1;
int n, q, a[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n >> q;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);//排序
	for(int i = 1; i <= n; i++)
	{
		a[i] += a[i - 1];
	}//第一次前缀和
	for(int i = 1; i <= n; i++)
	{
		a[i] += a[i - 1];
	}//第二次前缀和
	while(q--)
	{
		int t;
		cin >> t;
		int x = upper_bound(a + 1, a + n + 1, t) - a - 1;//二分查找答案
		cout << x << "\n";
	}
    return 0;
}
```

---

## 作者：Nahida_Official (赞：0)

通过本题题目，很容易发现这是一道贪心。

在当前的时间 $t$ 下，如果要解决最大数量的题目，就要把优先级给到 $d_n$ 最大的位置，由此，我的第一个思路是将 $d$ 数组从大到小排序再逐个相减，开开心心的测样例发现样例二假了，于是开始思考，发现在选择花费时间代价小的同时要考虑到 $d_n$，具体的，如果有一个 $d=[1,3,5,100000]$，而 $t=20$，那么明显第一个选择 5 比选择 100000 更优。 

由此，我想出了一种~~巧妙的~~方法：先将 $d$ 数组从小到大排序，统计 $d$ 数组的前缀和 $d_{sum}$，再统计 $d_{sum}$ 的前缀和 $d_{sums}$，设数组 $d$ 中的元素为 $d_1,d_2,\cdots,d_n$，观察下面两个数组：
$$d_{sum}=d_1,d_1+d_2,\cdots,\sum_{i=1}^n d_i$$

$$d_{sums}=d_1,2 \times d_1+d_2,3 \times d_1+2 \times d_2+d_3,\cdots,\sum_{i=1,j=0}^n (n-j) \times d_i$$

发现：$d_{sums}$ 中的第 $i$ 位元素就是我们以 $d_i$ 为当前选择的首位解决问题，接下来，对于给定的 $t$，只需要在该数组中二分查找（`upper_bound`）第一个大于 $t$ 的元素的位置再减一输出即可。

## Code：
```cpp
#include<bits/stdc++.h>
#define int long long
#define Sangonomiya signed
#define Kokomi main()
#define Love return
#define Nahida 0
#define Forever ;
#define IOS cin.tie(nullptr)->sync_with_stdio(false)
#define cin std::cin
#define cout std::cout
const int N=1e6;
int n,q,t;
Sangonomiya Kokomi{
    IOS;
    cin>>n>>q;
    std::vector<int> a(n+1,0);
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    std::sort(a.begin(),a.end());
    std::vector<int> sum(n+1,0);
    std::vector<int> sums(n+1,0);
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]+a[i];
    }
    for(int i=1;i<=n;i++){
        sums[i]=sums[i-1]+sum[i];
    }
    while(q--){
        cin>>t;
        int ans;
        ans=std::upper_bound(sums.begin(),sums.end(),t)-sums.begin()-1;
        cout<<ans<<'\n';
    }
    Love Nahida Forever;
}
```

---

## 作者：Besheep (赞：0)

首先考虑贪心，如果要解决第 $i$ 个问题，所需要的时间为 $t_i=i\times d_i$，解决全部的问题即为 $t=\sum\limits_ {i=1}^{n}i\times d_i$，很显然，我们要使 $t$ 更小，只能在 $i$ 小的时候使 $d_i$ 更大，由此得出我们要对 $d_i$ **降序排序（后文默认排序）**。

接下来考虑转化问题，与其求 $t$ 秒可以解决 $k$ 个问题，不如求解决 $k$ 个问题至少需要 $t'$ 秒。手玩样例发现随着 $t'$ 随着 $k$ 增加而增加，考虑二分使时间求 $k$。

---

接下来求解决 $k$ 个问题至少需要 $t'$ 秒。

设 $qz_i=qz_{i-1}+d_i,temp=\sum\limits_ {i=1}^{n}i\times d_i$。

定义 $ans_i$ 为 解决 $i$ 个问题至少需要 $ans_i$ 秒。

手玩样例 1 可得：
$$\begin{aligned}
ans_3&=temp\\
ans_2&=ans_3-d_1-(qz_3-qz_1)\\
ans_1&=ans_2-d_1-(qz_3-qz_2)\\
\end{aligned}
$$
推广开来：
$$\begin{aligned}
ans_n&=temp\\
ans_i&=ans_{i+1}-d_1-(qz_n-qz_{n-i})\\
\end{aligned}
$$

在 $ans$ 数组中二分查找一下 $t$ 即可，答案为 $t$ 的下标。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e6+10;
ll n,q,d[N],qz[N],temp,ans[N],t;
bool cmp(ll a,ll b){
	return a>b;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>d[i];
//	sort(d+1,d+1+n);
//	for(int i=1;i<=n;i++){
//		for(int j=1;j<=i;j++){
//			ans[i]+=d[j]*(i-j+1);
//		}
//	}
	sort(d+1,d+1+n,cmp);
	for(int i=1;i<=n;i++) qz[i]+=qz[i-1]+d[i];
	for(int i=1;i<=n;i++) temp+=d[i]*i;
//	cout<<temp;
//	ans[3]=temp;
//	ans[2]=ans[3]-d[1]-(qz[3]-qz[1]);
//	ans[1]=ans[2]-d[2]-(qz[3]-qz[2]); 
	ans[n]=temp;
	for(int i=n-1;i>=1;i--)	ans[i]=ans[i+1]-d[n-i]-(qz[n]-qz[n-i]);
//	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
	while(q--){
		cin>>t;
		ll ans1=upper_bound(ans+1,ans+n+1,t)-ans;
		cout<<ans1-1<<'\n';
	} 
	return 0;
}

//1 5 16
//2 7 17 33
//61 222 626 1326 2403 3869 5820 8323 11749 16149
```

---


# 切蛋糕

## 题目描述

今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 $n$ 个相同的小块，每小块都有对应的幸运值。

小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 $m(m\le n)$ 小块的蛋糕。

请你帮他从这 $n$ 小块中找出**连续**的 $k(1 \le k\le m)$ 块蛋糕，使得其上的总幸运值最大。

**形式化地**，在数列 $\{p_n\}$ 中，找出一个子段 $[l,r](r-l+1\le m)$，最大化 $\sum\limits_{i=l}^rp_i$。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n\le100$。
- 对于 $100\%$ 的数据，有 $1\le n\le5\times 10^5$，$|p_i|≤500$。

保证答案的绝对值在 $[0,2^{31}-1]$ 之内。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5```

### 输出

```
9```

## 样例 #2

### 输入

```
6 3
1 -2 3 -4 5 -6```

### 输出

```
5```

# 题解

## 作者：fanfansann (赞：438)

**我发现题解中大多数用单调队列做的都是错的！！**（不仅是用单调队列，题解中其他的方法基本都能被hack）

不信你试试5 2 5 4 3 2 1，题解中大多数输出的都是7或者1 1 5，输出的都是0
~~主要是这道题数据太水了~~

**所以我决定来给出一个用STL做的正确解法，不能误导别人呀**

~~所以管理员你就让我过了吧~~

其他题解之所以会被hack是因为他们光顾着维护队列单调递增（前缀和递增才会保证最大），忘了万一数据是单调递减怎么办。所以我们应该在维护递增之前就判断现在的答案是否为最优。为了达到这个目的我们应该先给队列赋初值0，因为sum[i]-sum[q.front()]这一句，不赋初值就出bug了，正好赋初值之后就可以避免第一个值是最大的，其余都是负的（如5 2 1 -10 -10 -10 -10 -10）这种丧心病狂的数据了。
```c

#include<bits/stdc++.h>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<stdio.h>
#include<cmath>
#include<deque>
#define debug cout<<"ok"<<endl
typedef long long ll;
const int maxn=1e7+10;
const int mod=1e9+7;
using namespace std;
int ans=-233333333,n,m,a,sum[maxn];
deque<int>q;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        sum[i]=sum[i-1]+a;//前缀和
    }
    q.push_back(0);//赋初值
    for(int i=1;i<=n;i++)
    {
        while(q.front()+m<i)
            q.pop_front();//越界就pop
        ans=max(ans,sum[i]-sum[q.front()]);
        while(!q.empty()&&sum[q.back()]>=sum[i])//递减就pop
            q.pop_back();
        q.push_back(i);
    }
    printf("%d\n",ans);
    return 0;
}

```
~~快把我顶上去呀，可不能一直这样误导观众呀~~


---

## 作者：kkksc03 (赞：333)

切蛋糕——题意简述

其实就是最大不定长子段和问题。

在一段长为N的数列中，找出一个长度≤M的子段，使得它的和是最大的。

但在本题中一个小细节就是子段长度也不能为0。



分析
考虑朴素写法，非常直观。


对于以第i个元素结尾的子段，最大的子段和P(i)可以表示为





P[i]=max{sum[i]-sum[j],j属于[i-M,i-1]}

于是有ans=max[P[i]]





算法的复杂度是O(NM)

在题目的范围下TLE是必然的


.

将上面P[i]的计算式改写为




P[i]=sum[i]-min{sum[j]},j属于[i-M,i-1]

显然，在每次获取P[i]的时候，Sum[i]是定值，所以P[i]由Sum[j]的最小值确定。


于是我们就要想方设法在优于O(M)的时间内实现获取最小的Sum[j]。


最优时，Sum[j]的性质：

（1）Sum[j]≤Sum[x]   x∈[i-M,i-1]且x≠j


（2）j∈[i-M,i-1]



枚举加优化

考虑设计这样一个数据结构，在更低的时间复杂度内获取最优Sum[j]。

Solution 1:使用线段树，则每次用O(nlogn)的时间获取最优Sum[j]。对于本题而言，是可以通过的。但是缺点也很明显：不熟的情况下容易写错，代码可维护性不佳。


Solution 2: 引入单调队列。




所谓单调队列，我的理解是利用题目中的一些元素的单调性质，按照一定的规则组成一个单调序列。每次获取状态的时候可以在特定的位置获取状态。



---

## 作者：fluttersunny (赞：82)

发现以前的题解写的有点问题，现在来改一下。

题目的意思大概就是取连续的k（k<=m）个数，求其中所有可能的最大值。

大家很快就能想到暴力做法三重循环，稍加思考就可以想到第三重循环的累加过程可以用前缀和预处理出来。

既然已经想到了前缀和，就可以继续思考。对于每一个i，要求max（sum[i]-sum[j]）（i-m<=j<=i-1）。这题没有说清楚到底可不可以一块都不取，这就决定了j<=i-1还是j<=i。到这里时间复杂度为O（n^2）。

我们可以发现，对于每一个i来讲，sum[i]是固定的，于是就转化成了sum[i]-min（sum[j]）（i-m<=j<=i-1）。这就转化为了求区间最小值问题。下面有多种不同的做法，单调队列、st表、树状数组、线段树等都可以。单调队列是O（n），其它基本上是O（nlogn）。

单调队列就是维护一个单调递增或递减的队列，使得及时排除无用的决策，并且快速找到最优决策。每个元素只会入队一次出队一次，所以时间复杂度为O（n）。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10,INF=1e9;
int sum[N],q[N];
int main()
{
	int n,m;scanf("%d%d",&n,&m);
	for (register int i=1;i<=n;++i)
	{
		int x;scanf("%d",&x);
		sum[i]=sum[i-1]+x;//求前缀和 
	}
	int head=1,tail=1,ans=-INF;q[1]=0;//注意有可能有负数 
	for (register int i=1;i<=n;++i)
	{
		while (head<=tail&&q[head]<i-m) head++;//已经不在范围内要出队 
		ans=max(ans,sum[i]-sum[q[head]]);
		while (head<=tail&&sum[i]<=sum[q[tail]]) tail--;//维护单调递增的队列 
		q[++tail]=i;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Jelly_Goat (赞：38)

### Solution1 暴力

首先拿到这个题我们首先想到的是暴力循环  
但是注意这肯定是不会让你全过的（至少我不会

------

### Solution2 线段树

究其原因是我们取出一段区间的和耗时间  
然后会想到线段树优化  
~~但是线段树又臭又长~~  
那么我们就拿出前缀和，用前缀和相减的方式表示区间和  

-----

### Solution3 单调队列

但是我们在这里首先要注意  
我们是**可以不取数字**的（如果最大子段和必须选则是负数的情况  

既然线段树这一条线被掐断了  
~~那么我们思维就得跳出去（毕竟求这个是dp过程~~  
考虑优化最先的定义  
如果我们要是枚举每一个i，都要进行枚举下一维，  
一定是爆炸的  
那么我们根据最大子段和的定义   
对于每一个以$i$结尾的数字  
其前缀和可以表示成
$$
\max\{sum[i]-sum[j],0\},j\in[i-m,i-1]
$$
我们考虑优化，就是固定$i$，那么这个式子就变成了  
$$
\max(0,sum[i]-\min\{sum[j]\}),j\in[i-m,i-1]
$$
很显然对于每一个$i$  
我们只需要知道最小的前缀和$sum[j]$就可以更新答案了  
同时我们还需要及时排除过时决策（  
因此我拿出了**单调队列**！  

------

为什么要用单调队列呢？   
首先明白答案上什么具有**单调性**   
这个题是最大子段和   
而且有长度限制  
所以是一定长度上的**前缀和单调递增**  
**队头**存储的下标的**前缀和最小**

因此我们**维护一个前缀和单调递增的单调队列**  
只有在这个单调队列里的下标其表示的前缀和才有可能会被更新  
然后及时排除过时决策就OK

-----

code:

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
inline int Read() //快读
{
    int num = 0;
    char ch = getchar();
    bool flag = false;
    while (!isdigit(ch))
        flag |= ch == '-', ch = getchar();
    while (isdigit(ch))
        num = (num << 1) + (num << 3) + (ch ^ 48), ch = getchar();
    return flag ? -num : num;
}
// 数组模拟单调队列，前缀和
int q[500086], sum[500086];
// 队头，队尾，数字个数，数字限制 
//答案注意有可能是负数
int l, r, n, m, ans = -2147480000; 

int main()
{
    n = Read(), m = Read();
    for (int i = 1; i <= n; i++)
    {
        sum[i] = sum[i - 1] + Read();
    }
    // 队列初始化
    l = r = 1, q[1] = 0;
    for (int i = 1; i <= n; i++)
    {
        // 如果过时那么弹出队头
        while (l <= r && q[l] < i - m)
            l++;
        // 更新决策
        ans = max(ans, sum[i] - sum[q[l]]);
        // 如果队尾的前缀和大于当前的前缀和
        // 弹出这些前缀和
        while (l <= r && sum[i] <= sum[q[r]])
            r--;
        // 压进当前决策
        q[++r] = i;
    }
    printf("%d\n", ans);
    return 0;
}
```

------

做过其他单调队列的题你会发现都是一个特点

有一个东西和你要的一个答案相关  

然后这个答案要及时排除过时决策

~~基本貌似都是这个尿性~~

有空继续upd然后解释详细一点

---

## 作者：伟大的王夫子 (赞：12)

本题就是让我们求一个长度不大于m的最大子序和

设$sum_{i}$为前$i$个数的前缀和

容易列出状态转移方程


$ans= \underbrace{\max sum_{i} - \underbrace{\min sum_{j}}_{i-m\leq j \leq i-1}}_{1 \leq i \leq n}$

但如果暴力枚举，时间复杂度是$O(nm)$的

考虑用单调队列进行优化

不妨比较任意两个位置$j_{1}, j_{2}$, 如果 $j_{1} < j_{2} , sum[j_{1}] \ge sum[j_{2}]$, 那么$j_{1}$就是无用决策

因为$j_{1}$能取到的地方，$j_{2}$也能取到，所以
$j_{1}$永远不会成为最优决策

综上所述，我们维护一个`下标位置递增，对应前缀和sum也递增的单调队列`， 只有这个队列中的决策，才有可能成为最优决策。

我们对每个$i$每次执行三个步骤

1.判断队头决策与$i$的距离是否超出$m$的范围，若超出则出队
2.此时队头就是右端点为$i$时，左端点$j$的最优选择

3.不断删除队尾决策，直到队尾对应的$sum$值小于$sum_{i}$。最后把$i$作为一个新的决策入队

```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[100010], *p1, *p2;
#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++
template<class item>
inline item read() {
	item res = 0;
	bool negative = 0;
	char ch = getchar();
	while (!isdigit(ch)) negative |= ch == '-', ch = getchar();
	while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
	return negative ? -res : res;
}
template<class item>
inline item read(item & t) {
	t = read<item>();
	return t;
}
#define max(a, b)  (!((a) < (b)) ? (a) : (b))
#define min(a, b)  ((a) < (b) ? (a) : (b))
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
	read(t), read(args...);
}
//快读，长了点 
int sum[500010], n, q[500010], m, ans = -1e9;
int main() {
	cin >> n >> m;
	for (register int i = 1; i <= n; ++i) read(sum[i]), sum[i] += sum[i - 1];
	int l = 1, r = 1;
	for (register int i = 1; i <= n; ++i) {
		while (l <= r && q[l] < i - m) ++l;//排除不可能决策 
		ans = max(ans, sum[i] - sum[q[l]]);
		while (l <= r && sum[q[r]] >= sum[i]) --r;//排除无用决策 
		q[++r] = i;//插入新决策 
	}
	cout << ans; 
}
```
 最后还是提醒大家多到[我的博客](https://www.luogu.org/blog/I-AK-IOI/)看题解，多点几个赞

---

## 作者：shadowice1984 (赞：10)

解释一下单调队列的原理（一维前缀和请自行百度）

对于这道题来讲，枚举每一个点的前缀和，然后寻找前m个点的前缀和最小值即可。

然后我们发现其实不用O(n)的扫描的，因为假设我们正在处理第i个点，除了第i-1个点没有被比较过以外

前i-1到i-m个点都被比较过了就可以利用这个原理减少重复计算。

然后单调队列，就是让一个队列，有这样的性质，队头最大（或最小），队列里的元素是不严格递减的（或不严格递增）。

在插入时就需要维护这个性质，插入时检查队尾是否比它大，大就pop掉。

这样的话每次检查队头是否有效（无效就pop），然后插入第i-1个·前缀和即可

上代码~

```cpp
#include<stdio.h>
//by SHADOWICEMCMLXXXIV
using namespace std;
struct data
{
    int num;int v;
}q[500010];//手写队列
int sum[500010];
int n;int m;
int head=1;int tail=0;//初始化队列为空
void pop()//手写pop
{
    if(head<tail)head++;
    return;
}
void push(data x)//push
{
    tail++;
    q[tail]=x;
    return;
}
void pot()//pop队尾
{
    if(tail>=head)
    {
        tail--;
    }
    return;
}
int res;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sum[i]);
        sum[i]=sum[i]+sum[i-1];//前缀和
    }
    for(int i=1;i<=n;i++)
    {
        if(q[head].num<i-m)pop();//如果队头过期就pop掉
        while(1)
        {
            if(sum[i-1]>=q[tail].v||head>tail)//如果是空队列或者是队尾比拆入的小就push
            {
                data p;p.num=i-1;p.v=sum[i-1];
                push(p);break;
            }
            else
            {
                pot();//pop队尾
            }
        }
        if(res<sum[i]-q[head].v)res=sum[i]-q[head].v;//处理最大值
    }
    printf("%d",res);
    return 0;//拜拜程序
}

```

---

## 作者：玫葵之蝶 (赞：9)

怎么没人用数据结构呢？

先来宣传一发[我的blog](http://www.cnblogs.com/stone41123/p/7595822.html)

题解：

首先，很简单的dp方程：

$$f_i=max(s_i-s_j)(j\in [i-m,i])$$然后发现$s\_i$与$j$无关，可以提出来：

$$f_i=s_i-min(s_j)(j\in [i-m,i])$$发现这个方程可以用数据结构优化，比如线段树，树状数组等等，我这里推荐用st表。

预处理：$O(nlogn)$  递推：$O(n)$

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
    int x=0;char ch=' ';int f=1;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int n,m;
int a[500001];
int s[500001];
int st[20][500001];
inline int query(int l,int r){
    int k=log(r-l+1)/log(2);
    return min(st[k][l],st[k][r-(1<<k)+1]);
}
int main(){
    Log[0]=-1;
    for(int i=1;i<=n;i++){
        Log[i]=Log[i>>1]+1;
    }
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        s[i]=s[i-1]+a[i];
        st[0][i]=s[i];
    }
    for(int k=1;k<=19;++k){
        for(int i=1;i+(1<<k)-1<=n;++i){
            st[k][i]=min(st[k-1][i],st[k-1][i+(1<<(k-1))]);
        }
    }
    int ans=-0x7fffffff;
    for(int i=1;i<=n;++i){
        int l=i-m;
        if(l<0)l=0;
        int num=s[i]-query(l,i);
        ans=max(ans,num);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Little_Ming (赞：6)

先$O(n)$预处理前缀和，这样可以$O(1)$求出一段蛋糕的价值之和。

若令$dp_{i,k}$表示从第$i$块蛋糕开始连取至多$k$块所能获得的最大价值，

最简单的dp方程是$dp_{i,k}=max\left\{\begin{matrix}dp_{i,k-1}\\ \sum p_{j(i\leq j \leq i+k-1)} \end{matrix}\right.$。

边界条件：$k=1$时$dp_{i,1}=p_i$

这个就是考虑最后一个要不要取，相信大家都会。

但是复杂度$O(n^2)$,超时！怎么办？

我们可以用分治的思想，如果$k>1$，把序列一分为二，考虑要几个**完整的一半**。

- 如果不要完整的一半，$dp_{i,k} = dp_{i,k/2}$；
- 如果要一个完整的一半，$dp_{i,k} = \sum p_{j(i\leq j\leq i+k/2-1)} + dp_{i+k/2,k/2}$；
- 如果两个完整的一半都要，就是全要，$dp_{i,k} = \sum p_{j(i\leq j\leq i+k-1)}$；

取$min$即可。

边界条件不变。

注意到前两个条件中用的都是$dp_{x,k/2}$，可以先把$m$转换为二进制，然后从$k=1$开始反向递推。

这样就把复杂度降为$O(nlogm)$了。

具体细节可见代码~~尽管写得很丑~~

```pascal
var s,a,now:array[0..500000]of longint;n,k,i,l,num,ans,j,r:longint;
    mi,ak:array[0..100]of longint;
function max(a,b:longint):longint;
begin
  if a>b then exit(a);exit(b);
end;
procedure dmax(var a:longint;b:longint);
begin
  a:=max(a,b);
end;
function t(x:longint):longint;
begin
  if x<1 then exit(1);
  if x>n then exit(n);
  exit(x);
end;
begin
  read(n,k);
  for i:=1 to n do read(a[i]);
  for i:=1 to n do s[i]:=s[i-1]+a[i];
  mi[0]:=1;
  l:=0;
  while mi[l]<=k div 2 do
  begin
    inc(l);
    mi[l]:=mi[l-1]*2;
  end;
  for i:=l downto 0 do
    if k>=mi[i]then
    begin
      ak[i]:=1;
      dec(k,mi[i]);
    end;//把k分解为二进制
  for i:=1 to n do
  begin
    now[i]:=a[i];
  end;
  num:=1;
  //递推+滚动数组
  for i:=l-1 downto 0 do
  begin
    //num x2
    for j:=1 to n do
    begin
      if j+num>n then continue;
      r:=j+num;
      dmax(now[j],s[r-1]-s[j-1]+now[r]);
      //writeln(j,'~',r-1,':',now[j])
    end;
    inc(num,num);
    //num +1
    if ak[i]=1 then
    begin
      for j:=1 to n do
      begin
        if j+num>n then continue;
        r:=j+num;
        dmax(now[j],s[r]-s[j-1]);
      end;
      inc(num);
    end;
  end;
  ans:=-1000;
  for i:=1 to n do
    dmax(ans,now[i]);
  writeln(ans);
end.

```

这还是我2018年一月时写的`Pascal`代码……

既然$NOIP2018$将近，最后就祝大家`NOIP.rp++`。


---

## 作者：HRLYB (赞：4)

[P1714 切蛋糕](https://www.luogu.org/problem/P1714)

没有用$multiset$维护子段的吗？我来写一波！

## 简要题意

求给定数组中最大的长度**不超过**给定长度的子段和.

## 题目分析
#### 前缀和的使用

~~看到有个“前缀和”的tag，就明白要用前缀和表示~~ 

我们发现，如果直接用数组本身计算这个最大不定子段和，我们需要三重循环（$n,m$加上一重计算各元素的和）

为了减小维度，提高效率，我们可以预处理前缀和以通过$O(1)$得到各元素的和.

#### $multiset$的使用

如果直接用暴力计算最大不定子段和，我们需要枚举$n,m$，复杂度为$O(nm)$，注意数据范围为50w，显然超时.

反向分析时间复杂度，我们发现大约$O(n\:log\:n)$级别的算法可以$accept$，所以思考如何优化枚举.

可以发现，求最大不定子段和，实际上就是在求区间前缀和的差的最大值，也就是说，我们要维护在$m$大小区间内，前缀和的最小值.

也就是说，我们需要一个数据结构，它可以：

> 按队列的先后进入顺序实现元素的插入和删除，
> 而且还可以很方便地获得此时其中的最小值（即本身能够排序）.

~~然后我开始想怎么用priority_queue实现第一点。。。~~ 

忽然想起来$multiset$（可重集）可以满足以上的要求，$multiset$内部实现是红黑树，本身有序，而且插入和删除操作都是$log$级别的，满足对复杂度的分析.

想要了解更多关于$multiset$的知识，请点击[这里](https://blog.csdn.net/sodacoco/article/details/84798621).

然后本题就解决了.

## 程序实现

```cpp
#include<bits/stdc++.h>
#define ll long long
#define maxn 500010
using namespace std;
ll n,m,lucky[maxn];
ll sum[maxn],ans=-0x3f3f3f3f;
multiset<ll >st;
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&lucky[i]);
		sum[i]=sum[i-1]+lucky[i];//求前缀和
	}
	multiset<ll >::iterator it;
	st.insert(sum[0]);
	for(int i=1;i<=n;i++){
		if(i<=m){//注意边界，i==m时恰好前面的元素都可以取完
			ll a=*st.begin();
			ans=max(ans,sum[i]-a);//取较大值
		}
		else{
			it=st.find(sum[i-m-1]);//find返回的是一个迭代器
			st.erase(it);//erase删除的也是迭代器所指的元素
			ll a=*st.begin();//取最小值
			ans=max(ans,sum[i]-a);
		}
		st.insert(sum[i]);//最后再入multiset，因为我们不考虑区间大小为0的情况
	} 
	printf("%lld\n",ans);
	return 0;
}
```
## 题后总结

可以反向分析时间复杂度以明白应该使用什么算法.

	这不是正解！正解（单调队列）可以达到O(n)的复杂度！


---

## 作者：Priori_Incantatem (赞：4)

#### 题目大意
给出$n,m$ 和 一个长度为 $n$ 的序列，求该序列的最大子段和，参与计算的子段要求长度不超过 $m$ 

设$f[i]$为以元素 $i$ 结尾的（长度不超过$m$）的最大子段和

我们考虑前缀和：求出对于每个 $i$，求出$s[i]$，$s[i]=a[1]+a[2]+ \dots +a[i]$  

这样，求 $f[i]$ 就变成了在 $s[i-m \sim i-1]$ 中寻找一个最小值 $x$，最后 $f[i]=s[i]-x$

维护一个递增的单调队列，并依次把每个$s[i]$插入队列并维护： 将队列中距离 位置 $i$ 远与 $m$ 和 大于$s[i]$ 的元素弹掉，并将 $s[i]$ 插入队列  
这时队尾元素就是我们要求的 $x$

时间复杂度：$O(n)$

```cpp
#include<cstdio>
#include<iostream>
#include<deque> // STL大法吼
using namespace std;
const int Maxn=500000+20,inf=0x3f3f3f3f;
int a[Maxn],s[Maxn];
int n,m,ans=-inf;
struct node{
	int val,pos;
	node(int x,int y)
	{
		val=x,pos=y;
	}
};
deque <node> q;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void push(int x)
{
	while(1)
	{
		if(q.empty())break;
		if(q.back().val<=s[x])break;
		q.pop_back();
	}
	q.push_back(node(s[x],x));
}
void pop(int x)
{
	if(q.empty())return;
	while(1)
	{
		if(q.empty())break;
		int tmp=q.front().pos;
		if(x-tmp<=m)break;
		q.pop_front();
	}
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=n;++i)
	a[i]=read(),s[i]=s[i-1]+a[i];
	push(0);
	for(int i=1;i<=n;++i)
	{
		pop(i); // 将队列中距离 位置 i 远与 m 元素弹掉
		push(i); // 弹掉比 s[i] 大的元素并插入 s[i]
		int tmp = q.back().val-q.front().val;
		ans=max(ans,tmp);
//		printf("tmp = %d\n",tmp);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：king_xbz (赞：3)

这是一道考察单调队列优化dp的好题。

首先我们先来看题目：
```cpp
小Z作为寿星，自然希望吃到的第一块蛋糕的幸运值总和最大
```
我们可以考虑用一维前缀和来进行预处理
即：
```cpp
	for(fint i=1;i<=n;i++)
		a[i]=read();
	for(fint i=1;i<=n;i++)
		s[i]=s[i-1]+a[i];
```
接下来，我们接着往下看，
```cpp
但小Z最多又只能吃M小块(M≤N)的蛋糕。
```
这可怎么办呢，难道需要暴力枚举每一个搭配吗？再看数据范围：
```cpp
对20%的数据，N≤100。

对100%的数据，N≤500000，|Pi|≤500。 答案保证在2^31-1之内。
```
数据范围在int_max附近，所以我们想ac显然需要别的方法。

这时候，我们今天的主角----单调队列就要隆重登场了！

那么神马是单调队列呢？

我们可以把单调队列想象成一个长度为m的滑动窗口，在不停的滑动中所包含的值也不一样，而单调队列同时又满足单调性，即单调递增或单调递减（数学必修一）。

所以我们可以用两头均可出入的特殊数据结构————双向队列，来帮助我们实现。

code
```cpp
	head[0]=head[1]=1;
	for(fint i=1;i<=n;i++)
	{
		while(!q.empty()&&q.back().cnt>=a[i].cnt)
		q.pop_back();
		q.push_back(a[i]);
		while(!s.empty()&&s.back().cnt<=a[i].cnt)
		s.pop_back();
		s.push_back(a[i]);
		if(i-head[0]>=k)
		{
		head[0]++;
		if(i-k==q.front().num)
		q.pop_front();
		}
		if(i-head[1]>=k)
		{
		head[1]++;
		if(i-k==s.front().num)
		s.pop_front();
		}
		if(i>=k)
		{
		v[i]=q.front().cnt;
		w[i]=s.front().cnt;
		}
	}
```
s中储存的即为减队列，q中储存的即为加队列。

类比到这道题，我们一样可以用单调队列来优化：
```cpp
	int head=1;
	int maxxs=-inf;
	for(fint i=1;i<=n;i++)
	{
		while(!q.empty()&&s[q.back()]>=s[i])
		q.pop_back();
		q.push_back(i);
		if(q.front()<i-k)
			q.pop_front();
		maxxs=max(maxxs,s[i]-s[q.front()]);
	}
```
这便是使用单调队列和前缀和处理后的“蛋糕”。

最后，推荐几道相关题目：[P1886单调队列模板题](https://www.luogu.com.cn/problem/P1886)[P2627修剪草坪](https://www.luogu.com.cn/problem/P2627)

就到这里了，谢谢大家！

---

## 作者：accedhy (赞：2)

我来发布一篇st表的最简代码

看到这道题的第一印象就知道是要用前缀和，但是这道题中又多了一个条件就是选的块数k可以小于m，所以又多了一层循环，即使用了前缀和，至少也是O(nm)。

而且n的值很大，所以需要用数据结构维护，我用了好写的st表。
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int f[500005][19];
int main()
{
	int n,m,tp;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",&tp),f[i][0]=f[i-1][0]+tp;//前缀和 
	for(int j=1;(1<<j)<=n;++j)//预处理
		for(int i=1;i+(1<<j)-1<=n;++i)
			f[i][j]=min(f[i][j-1],f[i+(1<<j-1)][j-1]);
	int k=log2(m),ans=0;
	for(int i=m;i<=n;++i)
		ans=max(ans,f[i][0]-min(f[i-m][k],f[i-(1<<k)+1][k]));
	printf("%d",ans);
}
```

---

## 作者：Great_Influence (赞：2)

此题其实可以用贪心过，不过可能会TLE大点，其实期望时间复杂度是O（n）的。

贪心思想与没有长度限制的问题是一样的。只需要从头开始计算前缀和，当前缀和小于0时将前缀和置为0即可。问题在于长度限制。这时可以记录一下到每个点的最大前缀和。当从后删除数字时，只需要将最近连续的几段前缀和全部删去被删除的数即可。当前缀和被删除导致小于0时，可以停止删除了。这时在更新长度即可。


注意方法其实有严重漏洞，会被恶心数据卡，所以对于最大数据可以选择特判：注意当数据巨大时，连续删除现象几率很小。所以直接贪心认为不存在此现象即可。


代码（附解释）：

```cpp
#include<cstdio>
#include<iostream>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
const int MAXN=500000+100;
template<typename T>
inline void read(T &x)//蛇皮的读入优化
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^'0');
        k=getchar();
    }
    x=s*f;
}
int n,m,sum[MAXN],a[MAXN],len;//数组分别是前缀和和存储数字地方。len是当前长度
int main(void)
{
    read(n);
    read(m);
    int ans=0,i;
    For(i,1,n)
    {
        read(a[i]);
        if(sum[i-1]+a[i]<=0)sum[i]=len=0;//当前缀和小于0时，前缀全部不选择。
        else
        {
            sum[i]=sum[i-1]+a[i];//直接选择
            if(len==m)//判断长度是否越界
            {
                sum[i]-=a[i-m];//一个个减
                if(sum[i]<0)sum[i]=0;//如果第一个便小于0，则前缀全部不选
                else
                {
                    int j=i-1,k;
                    if(n!=500000)while(sum[j]-a[i-m]>=0&&j>=i-m+1)sum[j--]-=a[i-m];//循环删除，注意贪心时间
                    For(k,i-len+1,j)sum[i]-=a[k];//连续删除不需要的前缀
                    len=i-j;
                }
            }
            else ++len;
            ans=max(ans,sum[i]);//求答案
        }
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Pricilla (赞：2)

Pascal题解，主要用到单调队列（注释见代码）




```cpp
var
  head,tail,ans,n,a,b,i,x:longint;
  queue:array[0..500000,1..2] of longint;
  sum:array[0..500000] of longint;
function max(i,j:longint):longint;//最大值，其实可以开数学库
  begin
    if (i>j) then exit(i) else exit(j);
  end;
begin
  ans:=-maxlongint;
  readln(n,b);
  a:=1;sum[0]:=0;//初值别忘了，不然跑一趟还是0
  for i:=1 to n do
    begin
      read(x);
      sum[i]:=sum[i-1]+x;
    end;
  head:=0; tail:=0;
  queue[0,1]:=0; queue[0,2]:=0;//初值
  for i:=a to n do//核心代码，也就是单调队列的处理
    begin
      while (i-queue[head,2]>b) do
        inc(head);
      while (tail>=head) and (queue[tail,1]>=sum[i-a]) do
        dec(tail);
      inc(tail);
      queue[tail,1]:=sum[i-a];
      queue[tail,2]:=i-a;
      ans:=max(ans,sum[i]-queue[head,1]);
    end;
  writeln(ans);
end.
```

---

## 作者：封禁用户 (赞：2)

# Ad
个人新博客同步：http://blog.cinema000.xyz/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Luogu%201714%E3%80%90%E5%88%87%E8%9B%8B%E7%B3%95%E3%80%91/

## Hints
读入优化比线段树长系列233

# 分析

这里一开始看以为题目给定了$k$然后来求，于是我就想着这样跑一个线段树就好了嘛，然后发现看错题了，，，

其实是维护区间最大子段和，那么就从朴素算法开始，$O(n^3)$，暴力枚举嘛，然后想着优化，求和可以用前缀和来搞（一开始还用线段树f\*\*k$O(n^2\log n)$），这样是$O(n^2)$的，而且数据比较刁钻，好像不能有常数优化达到本题的$n^2$过百万，暴力碾标程的操作，于是继续优化就可以想到一个转移方程：$max=\max(sum[i]-\min(sum[j]))$，其中$j\in [i-m,i-1]$。

这样那个$\min$可以用线段树维护，而且这种方法在题解里面有人交过了f\*\*k，于是就默默拿出著名的非递归线段树——**zkw线段树**

具体实现原理这里空白太小，写不下，请善用搜索引擎之。

# 代码

```cpp
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<algorithm>
#include<cctype>
const int MAXN = 500000 + 6;
int T[MAXN * 4],A[MAXN],sum[MAXN],M,n;

inline int L(int x){return x << 1;}
inline int R(int x){return x << 1 | 1;}
inline void maintain(int p){T[p] = std::min(T[L(p)],T[R(p)]);}

inline char read() {
    static const int IN_LEN = 1000000;
    static char buf[IN_LEN], *s, *t;
    if (s == t) {
        t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
        if (s == t) return -1;
    }
    return *s++;
}

inline bool read(int &x) {
    static bool iosig;
    static char c;
    for (iosig = false, c = read(); !isdigit(c); c = read()) {
        if (c == '-') iosig = true;
        if (c == -1) return false;
    }
    for (x = 0; isdigit(c); c = read())
        x = (x + (x << 2) << 1) + (c ^ '0');
    if (iosig) x = -x;
    return true;
}
const int OUT_LEN = 10000000;
char obuf[OUT_LEN], *oh = obuf;
inline void print(char c) {
    if (oh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), oh = obuf;
    *oh++ = c;
}
inline void print(int x) {
    static int buf[30], cnt;
    if (x == 0) {
        print('0');
    } else {
        if (x < 0) print('-'), x = -x;
        for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
        while (cnt) print((char)buf[cnt--]);
    }
}
inline void flush() {
    fwrite(obuf, 1, oh - obuf, stdout);
}

void build(){
    for(M = 1;M <= (n + 1); M <<= 1);
    for(int i = 1;i <= n;i++){sum[i] = sum[i - 1] + A[i],T[i + M] = sum[i];}
    for(int i = M - 1;i;i--) maintain(i);
}

int ask(int l,int r){
    int ans = 0x7fffffff;
    for(l += M - 1,r += M + 1;l ^ r ^ 1;l >>= 1,r >>= 1){
        if(~l & 1) ans = std::min(ans,T[l ^ 1]);
        if(r & 1) ans = std::min(ans,T[r ^ 1]);
    }
    return ans;
}

int main(){
    //freopen("in.txt","r",stdin);
    int m;read(n);read(m);
    for(int i = 1;i <= n;i++) read(A[i]);
    build();
    
    int max = -0x7fffffff;
    for(int i = m + 1;i <= n;i++){
        max = std::max(max,sum[i] - ask(i - m,i - 1));
    }
    printf("%d",max);
    
    return 0;
}
```


---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P1714)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑枚举右端点。在确定右端点为$r$后，设$S(i)=\sum_{j=1}^iP_j$，就可以知道此时的最优答案为：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle\max_{\max\{r-m,0\}\leq l< r}\{S(r)-S(l)\}$  
$\displaystyle\Rightarrow\ \ S(r)-\min_{\max\{r-m,0\}\leq l<r}\{S(l)\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫一遍数组，用单调队列维护后面的一堆$\min$，然后就可以做到$O(1)$计算答案，总时间复杂度$O(n)$。当然用$RMQ-ST$表或者线段树什么的都可以，只不过时间复杂度稍差一点而已。  
# 代码
```cpp
#include <cstdio>

const int MAXN = 500005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

int deq[MAXN], h = 1, t = 0;
int preSum[MAXN];
int N, M;

bool empty()
{
	return h > t;
}

int main()
{
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( preSum[i] );
		preSum[i] += preSum[i - 1];
	}
	deq[++t] = 0;
	preSum[0] = 0;
	int res = 0;
	for( int i = 1 ; i <= N ; i ++ )
	{
		while( ! empty() && deq[h] < i - M ) h ++;
		res = MAX( res, preSum[i] - preSum[deq[h]] );
		while( ! empty() && preSum[deq[t]] >= preSum[i] ) t --;
		deq[++t] = i;
	}
	write( res ), putchar( '\n' );
	return 0;
}
```

---


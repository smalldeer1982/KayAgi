# [HNOI2003] 激光炸弹

## 题目描述

一种新型的激光炸弹，可以摧毁一个边长为 $m$ 的正方形内的所有目标。现在地图上有 $n$ 个目标，用整数 $x_i$ , $y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $v_i$。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为 $m$ 的边必须与 $x$ 轴，$y$ 轴平行。若目标位于爆破正方形的边上，该目标不会被摧毁。

现在你的任务是计算一颗炸弹最多能炸掉地图上总价值为多少的目标。

可能存在多个目标在同一位置上的情况。

## 说明/提示

**数据规模与约定**

- 对于 $100\%$ 的数据，保证 $1 \le n \le 10^4$，$0 \le x_i ,y_i \le 5\times 10^3$，$1 \le m \le 5\times 10^3$，$1 \le v_i < 100$。

## 样例 #1

### 输入

```
2 1
0 0 1
1 1 1
```

### 输出

```
1```

# 题解

## 作者：iMya_nlgau (赞：422)

## 题解 [HNOI2003] 激光炸弹

- 2022/4/29 upd：几乎重写了一遍，改了一下码风，讲的更清楚了些。

[可能会更好的阅读体验](https://www.cnblogs.com/sapphire162/p/16208167.html)

### 这道题要用到一个重要的基础算法——前缀和（二维）

众所周知，对于一个序列 $A$，我们可以通过递推求出它的前缀和序列 $S$：

$$
S_i=\sum\limits_{j=1}^iA_j
$$
然后就可以 $O(1)$ 求出子段和

$$
\sum\limits_{i=l}^rA_i=S_r-S_{l-1}
$$
对于这道题，我们也希望能在 $O(1)$ 的时间内求出一个正方形区域的部分和，这就要用到二维前缀和。

### 二维前缀和

类比一维前缀和，我们定义 $A$ 的二维前缀和 $S$：

$$
S_{i,j}=\sum\limits_{x=1}^i\sum\limits_{y=1}^jA_{x,y}
$$
$S_{i,j}$ 的含义，形象地理解即为 $(i,j)$ 左上方的矩形的面积。

那么如和递推求出 $S$ 呢？ 通常的方法有以下两种：

#### 方法一

我们来观察下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/956hox3t.png)

简单地应用容斥原理的思想，可以得到以下递推式：
$$
S_{i,j}(\text{整个矩形})=S_{i-1,j}(\text{红色+绿色部分})+S_{i,j-1}(\text{红色+浅蓝色部分})
$$

$$
-S_{i-1,j-1}(\text{红色部分})+A_{i,j}(\text{深蓝色部分})
$$
这样我们就可以 $O(n^2)$ 预处理出二维前缀和 $S$。代码如下：

```cpp
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= n; j ++)
        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
// a[i][j] 为原二维数组（下标范围 1~n）
// s[i][j] 为二维前缀和的结果
```

#### 方法二

我们考虑先对每一行求出一维前缀和，这时得到的 $S^\prime_{i,j}$ 实际上表示的是第 $i$ 行，前 $j$ 个位置的和。然后我们再对 $S^\prime$ 的每一列做一遍一维前缀和，这次得到的 $S_{i,j}$ 就是前 $i$ 行每行前 $j$ 个位置和的加和，也就是 $(i,j)$ 左上这一矩形区域的和了，即我们要的二维前缀和。复杂度仍然是 $O(n^2)$。

代码如下：

```cpp
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= n; j ++) s[i][j] = s[i][j - 1] + a[i][j];
for (int j = 1; j <= n; j ++)
    for (int i = 1; i <= n; i ++) s[i][j] += s[i - 1][j];
```

两种方法比较一下，方法一有一个劣势，可以注意到，它的递推式中总共有 $4$ 项，如果再类比到三维前缀和，采用同样容斥思想，递推式中就总共有 $8$ 项。一般地，采用容斥计算 $k$ 维前缀和的复杂度为 $O(2^k n^k)$ 当 $k$ 较大时 $2^k$ 就是一个很大的常数因子了，而方法二扩展到 $k$ 维的复杂度为 $O(kn^k)$。在高维前缀和（一般用来求解子集和问题，即对所有 $0\leq i<2^k$ 求解 $\sum_{j\subseteq i}a_j$）中会用到方法二的思想。不过一般的问题中（比如这题），两种方法都没有任何问题。

下面考虑查询，及如何通过二维前缀和数组得到一个矩形区域的部分和。这是容易 $O(1)$ 做到的。

同样采用容斥思想（读者可以仿照上面方法一的图理解一下）以 $(i,j)$ 为右下角，长为 $R$，宽为 $C$ 的矩形区域的部分和即为
$$
\sum\limits_{x=i-C+1}^i\sum\limits_{y=j-R+1}^jA_{x,y}= S_{i,j}-S_{i-C,j}-S_{i,j-R}+S_{i-C,j-R}
$$
至此，我们可以 $O(n^2)$ 地预处理出二维前缀和 $S$，再枚举所有边长 $m$ 的正方形区域，得到最大值即本题答案。

该算法的时间复杂度和空间复杂度都是 $O(n^2)$，本题 $n\leq 5000$，就做完了。

注意，以上我写的 $n$ 指的是坐标范围而非题面中的目标个数。

### 本题一些实现上的细节

- 虽然题目保证结果不会超过 $32767$，但中间过程可能超出 $\texttt{short}$ 的范围，所以仍需使用 $\texttt{int}$。（我之前用的 $\texttt{short}$ 却 AC 了，就很玄学）

- 我们可以把每个坐标看成在一个小正方形区域中间而非一个点（即横纵坐标加 $0.5$），就可以发现并不需要对恰好在正方形边上的点特殊处理。

- 为了防止越界，要把横纵坐标都加一。

下面是 AC 代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, m, s[5010][5010];
// 因为空间较为紧张，这里只用了一个数组，计算出前缀和后原数组直接被覆盖

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i ++) {
		int x, y, v;
		cin >> x >> y >> v;
		s[x + 1][y + 1] += v;	// 将横纵坐标都加一，坐标范围变成 [1, 5001]，避免越界
	}
	
	int N = 5001; // N 为坐标范围
    // 方法一
	for (int i = 1; i <= N; i ++)
		for (int j = 1; j <= N; j ++)
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + s[i][j];
/*	
	// 方法二
	for (int i = 1; i <= N; i ++)
		for (int j = 1; j <= N; j ++) s[i][j] += s[i][j - 1];
	for (int j = 1; j <= N; j ++)
		for (int i = 1; i <= N; i ++) s[i][j] += s[i - 1][j];
	*/
	
	int ans = 0;
	for (int i = m; i <= N; i ++)
		for (int j = m; j <= N; j ++) {
			int num = s[i][j] - s[i - m][j] - s[i][j - m] + s[i - m][j - m];
            // num 为以 (i, j) 为右下角的边长为 m 的正方形区域中的目标价值之和
			ans = max(ans, num);
            // 用 num 更新答案
		}
	
	cout << ans << endl;
	
	return 0;
}
```

作为扩展，再讲一下与二维前缀和对应的二维差分（下面内容已与本题无关）

### 二维差分

在一维上，我们知道前缀和的逆过程，差分。另 $B_i=A_i-A_{i-1}$，那么 $B$ 就称作 $A$ 的差分，容易发现，对差分序列求前缀和得到的就是原序列，而对前缀和序列求差分也能得到原序列。前缀和与差分类似积分与微分，只不过前者应用于离散的（序列），后者应用于连续的（函数）。

而差分在题目中的应用也是及其广泛的，最基本的应用就是对序列进行多次区间修改（加一个数），最后询问最终序列。将序列 $A$ 的 $[l,r]$ 区间加上一个数 $v$，考察它的差分序列 $B$，发现 $B_{l}$ 增加了 $v$，而 $B_{r+1}$ 减少了 $v$。所以我们可以维护差分序列，修改操作是 $O(1)$ 的，最后求一遍前缀和就得到原序列。

考虑扩展到二维的情况，我们想处理对二维数组中一个矩形区域加一个数的操作，我们也可以类比出二维差分。与二维前缀和一样，也有两种理解方法。

#### 方法一

因为差分是前缀和的逆运算，所以原数组 $A$ 就是其差分 $B$ 的前缀和，根据上文讲的根据二维前缀和求部分和，那么 $B_{i,j}$ 就等于 $A_{i,j}-A_{i-1,j}-A_{i,j-1}+A_{i-1,j-1}$。

而考虑对 $A$ 中左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$ 的矩形区域加上 $v$，考察 $B$ 的变化，我们发现 $B_{x_1,y_1}$ 增加了 $v$，$B_{x_2+1,y_1}$ 减小了 $v$，$B_{x_1,y_2+1}$ 减小了 $v$，$B_{x_2+1,y_2+1}$ 增加了 $v$。于是我们就可以每次操作 $O(1)$ 地维护 $B$，最后求一遍二维前缀和得到 $A$ 的最终结果。

#### 方法二

与方法一相比，我更喜欢的是这个方法，感觉跟清楚一些。

还是考虑对 $A$ 中左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$ 的矩形区域加上 $v$，我们不妨先对每一行做一维差分，那么一次矩形加操作就给 $x_1$ 到 $x_2$ 每一行的 $y_1$ 位置加上 $v$，$y_2+1$ 位置减去 $v$，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/0vads29h.png)

（红色矩形内所有位置加 $v$）

现在我们竖着观察这个操作，发现相当于给第 $y_1$ 和 $y_2+1$ 列各进行了一次区间加（减）操作，这是我们已经用一维差分解决的问题。所以我们再竖着对每一列做一遍差分，就做完了。

这个方法甚至可以扩展到给一个直角三角形区域加一个数的操作（直角边与坐标轴平行），依然是对每一行差分，问题就变成了对竖着一列的一段区间加（减）一个数，和对斜着的一段区间加（减）一个数，我们竖着和斜着再差分就可以了。

习题 [P8228 「Wdoi-5」模块化核熔炉](https://www.luogu.com.cn/problem/P8228)，这个题是对六边形区域的修改操作，不过做法是类似的。

前缀和与差分是及其重要的基础算法，应用也非常广泛，本文只是其最基本的应用。考虑到很多读者可能是刚开始学习算法，前缀和与差分也能帮助建立复杂度的思想（多次区间查询，我们采用 $O(n)$ 预处理 $O(1)$ 查询的前缀和，若多次区间修改，便采用维护差分 $O(1)$ 修改的方法）。

如果感觉讲的还清楚就点个赞再走吧（卑微求赞）

---

## 作者：do_while_true (赞：28)

upd: 增加了一点点解释 =w=

首先把问题化简一下，如果是一条线的话应该怎么办。

考虑到一个长度为 $m$ 的线段最多可以覆盖到 $m+1$ 个点，左右两端的点恰好与边重合。但是在此题中左右两端的点不能算，所以我们将这个边向两边任意一边移动小于 $1$ 的一点点距离，就可以算上一边的端点。

也就是我们把这个投放的线段的两端放在不是整点数的位置，就能让一个长度为 $m$ 的线段有效覆盖到 $m$ 个点。

如图所示：

![](https://s1.ax1x.com/2020/05/11/YYMJw4.png)

~~图画的有点丑~~

也就是说这个激光炸弹的投放的正方形的四个角不一定非得落在坐标轴的整数点位置，而是把这四个角放在格子的内部，这样恰好能覆盖到 $m\cdot m$  个点。


于是问题转化成了一个矩阵中大小为 $m\cdot m$ 的子矩阵的最大价值，采用二维前缀和求解即可。

因为在题目中 $0\leq x_i,y_i$，所以 $x_i,y_i$ 可能取值为 $0$，那么如果采用原坐标进行覆盖的话，在计算前缀和的时候会因为访问负数下标而造成RE的情况。所以可以特殊处理第 $0$ 行以及第 $0$ 列，或者直接按原坐标 $+1$ 进行存储。

值得注意的是，如果选择按原坐标 $+1$ 进行存储，则在枚举的范围应该到 $5001$ 或者到最大的 $x_i+1$ 和 $y_i+1$。否则在 $(5000,5000)$ 的点是枚举不到的。


Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int sum[5002][5002],n,m,x,y,v,ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&x,&y,&v);
		sum[x+1][y+1]+=v;
	}
	for(int i=1;i<=5001;i++)
		for(int j=1;j<=5001;j++)
			sum[i][j]+=sum[i][j-1]-sum[i-1][j-1]+sum[i-1][j];
	for(int i=m;i<=5001;i++)
		for(int j=m;j<=5001;j++)
			ans=max(ans,sum[i][j]-sum[i][j-m]-sum[i-m][j]+sum[i-m][j-m]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：lowAltitudeFlyer (赞：20)

## Solution
~~**二维前缀和**模板题。~~  
建立一个二维数组$a$，其中$a[i,j]$等于位置$(i,j)$上的所有目标的价值之和。即对于每个目标，令$a[x_i,y_i]$加上$w_i$。  
接下来求出$a$的二维前缀和$sum$，即：
$$sum[i,j]=\sum_{x=1}^{i}\sum_{y=1}^{j}a[x,y]$$
如下图所示，我们观察$sum[i,j]$，$sum[i,j-1]$，$sum[i-1,j]$，$sum[i-1,j-1]$的关系。  
![](https://cdn.luogu.com.cn/upload/image_hosting/36xowg52.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
图一$sum[i,j-1]$，图二$sum[i-1,j]$，图三$sum[i,j-1]+sum[i-1,j]$，图四$sum[i,j-1]+sum[i-1,j]-sum[i-1,j-1]$。  
易得：
$$sum[i,j]=sum[i,j-1]+sum[i-1,j]-sum[i-1,j-1]+a[i,j]$$
同理，对于一个边长为$R$的正方形，易得：
$$\sum_{x=i-R+1}^{i}\sum_{x=j-R+1}^{j}a[x,y]=sum[i,j]-sum[i-R,j]-sum[i,j-R]+sum[i-R,j-R]$$
因此，我们可以$O(n^2)$递推求出二维前缀和$sum$，然后$O(n^2)$枚举边长为$R$的正方形的右下角的坐标$(i,j)$，即可通过上面的柿子$O(1)$计算出该正方形内所有目标的价值和，更新答案$ans$。  
上面的柿子的思想其实就是**容斥原理**qwq  
最后，原题中$(x_i,y_i)$是一个**点**，然而我们把它当成了一个**格子**来计算。实际上，我们可以认为这个点就处于格子的中心位置，而正方形的右下角处于格线交点上。  
最后的最后，此题卡空间，需要合并$a$数组和$sum$数组。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int SIZE = 5000;
int n, m, sum[SIZE+5][SIZE+5], maxx, maxy, ans; //此题卡空间，所以需要合并a数组和sum数组，或者使用short int 
int main() {
	scanf("%d%d", &n, &m);
	m = min(m, SIZE); //题目并没有给出m的范围，需要处理m>SIZE时sum数组访问越界的情况 
	while(n--) {
		int x, y, v;
		scanf("%d%d%d", &x, &y, &v);
		sum[x+1][y+1] += v; //使用+=，防止出现两个目标在同一位置的情况，使代码更鲁棒 
		maxx = max(maxx, x+1); //记录最大的横坐标 
		maxy = max(maxy, y+1); //记录最大的纵坐标 
	}
	maxx = max(maxx, m); //处理m>maxx的情况 
	maxy = max(maxy, m); //处理m>maxy的情况 
	for(int i = 1; i <= maxx; i++) {
		for(int j = 1; j <= maxy; j++) {
			sum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]; //计算前缀和 
		}
	}
	for(int i = m; i <= maxx; i++) {
		for(int j = m; j <= maxy; j++) {
			ans = max(ans, sum[i][j] - sum[i-m][j] - sum[i][j-m] + sum[i-m][j-m]); //枚举正方形右下角坐标(i,j) 
		}
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：abjfj (赞：6)

看到讨论区很多人90分，是没有考虑到 r > maxx的情况

若是r > 5001的话 很多题解都会没掉

所以特判是坠吼的

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,r;
int s[5003][5003];
int maxx = 0;
int maxy = 0;
int ans = 0;
int main()
{
	cin>>n>>r;
    //为什么第八个点会wa
	//考虑 r > maxx || r > maxy的情况 
	for(int i = 1; i <= n; i++)
	{
		int x,y,w;
		cin>>x>>y>>w;
		x++,y++;
		s[x][y]+=w;
		maxx = max(maxx,x);
		maxy = max(maxy,y);
	}
	//if(r > maxx || r > maxy)while(1);
	//第八个点T掉了
	//那么最好是特判 否则出现r>= 5000  
	 
	 //要多注意 不然死都不知道怎么死的 
	 
	 
	for(int i = 1; i <= maxx; i++)
	for(int j = 1; j <= maxy; j++)
	{
		s[i][j] += s[i-1][j]+s[i][j-1]-s[i-1][j-1];
	}
	if(r > maxx && r > maxy)
	{
		cout<<s[maxx][maxy]<<endl;
		return 0;
	}
	if(r > maxx)
	{
		for(int i = r; i <= maxy; i++)
		{
			int save = s[maxx][i]-s[maxx][i-r];
			ans = max(save,ans);
		}
		cout<<ans<<endl;
		return 0;
	}
	if(r > maxy)
	{
		for(int i = r; i <= maxx; i++)
		{
			int save = s[i][maxy]-s[i-r][maxy];
			ans = max(save,ans);
		}
		cout<<ans<<endl;
		return 0;
	}
	for(int i = r; i <= maxx; i++)
	for(int j = r; j <= maxy; j++)
	{
		int save = s[i][j]-s[i-r][j]-s[i][j-r]+s[i-r][j-r];
		ans = max(ans,save);
	}

	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：wshl (赞：5)

题解：本题主要考查二维前缀和。
- 简要题意：有 N 个点，用Xi,Yi表示地图上的位置，每个目标有一个价值Wi，有一个有一个边长为R的正方形，求点在正方形的最大价值。
- 1.二维前缀和：画出图来就易得前缀和式子为
- $f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1]$
- 自己编的小口诀：左减+右减，最后再减减。(大雾)

代码如下：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,x,y,v,r,ans=0;
int f[9241][5780];
int main()
{
	cin>>n>>r;
	int a=r,b=r;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y>>v;
		x++;y++;
		f[x][y]+=v;
		a=max(a,x);b=max(b,y);
	}
	for(int i=1;i<=a;i++)
	for(int j=1;j<=b;j++)
	f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
	for(int i=r;i<=a;i++)
	for(int j=r;j<=b;j++)
	ans=max(ans,f[i][j]-f[i-r][j]-f[i][j-r]+f[i-r][j-r]);
	cout<<ans;
	return 0;
}```

---

## 作者：EternalHeart1314 (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P2280)

# 思路

可以发现需要在一个边长为 $m$ 的正方形内求出它里面的权值和，很容易想到二维前缀和。

$s_{i,j}$ 表示 $\sum\limits_{ii=1}^{i}\sum\limits_{jj=1}^{j}a_{ii,jj}$，这里的 $N$ 表示 $x$ 和 $y$ 的上限，可以取 $5\times 10^3+1$，也就是 $5001$，因为 $0\le x,y\le 5\times 10^3$。

这样，右上角坐标为 $x,y$ 的正方形里的权值和就是 $s_{x,y}-s_{x-m,y}-s_{x,y-m}+s_{x-m,y-m}$。

可以枚举再 $O(1)$ 计算再取 $\max$。

时间复杂度 $O(N^2)$。

注意：

1. 数组下标不能越界。

2. 一个点上可能有多个目标，所以要写 `a[x + 1][y + 1] += v`，而不是 `a[x + 1][y + 1] = v`。

# Code

```
#include<bits/stdc++.h>
using namespace std;

const int N(5e3 + 7);
int n, m, ans, a[N][N];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i(1), x, y, v; i <= n; ++ i) {
		cin >> x >> y >> v;
		a[x + 1][y + 1] += v;		//注意 x 和 y 有可能为 0，所以下标要加 1，因为下面的代码中下标减了 1，下标为 -1 会产生越界 
	}
	for(int i(1); i <= 5001; ++ i) {
		for(int j(1); j <= 5001; ++ j) {
			a[i][j] += a[i - 1][j];
		}
	}
	for(int i(1); i <= 5001; ++ i) {
		for(int j(1); j <= 5001; ++ j) {
			a[i][j] += a[i][j - 1];
		}
	}								//进行前缀和 
	for(int i(m); i <= 5001; ++ i) {
		for(int j(m); j <= 5001; ++ j) {
			ans = max(ans, a[i][j] - a[i - m][j] - a[i][j - m] + a[i - m][j - m]);
		}							//得到正方形内的权值和再取 max 
	}
    return cout << ans, 0;
}
```

### 珍惜生命，远离抄袭

---

## 作者：Lian_zy (赞：3)

# 0 题目传送门

[点我传送](https://www.luogu.com.cn/problem/P2280)

# 1 题目分析

这道题是一道 前缀和 + 暴力 的~~水题~~好题。

思路很简单，只要预处理一遍前缀和，再遍历数组更新答案就可以啦。

注意这道题有一个小坑，就是 $x$ 和 $y$ 可能为 $0$，这时把他们加 $1$ 就可以啦。
# 2 代码时间

~~莫抄袭，没了 AC 记录，空悲切。~~

``` cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 5e3 + 10, k = 5e3 + 1;
int n, m, x, y, v, ans, pre[maxn][maxn];
int main() { 
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d %d %d", &x, &y, &v);
		pre[++x][++y] = v;
        //从 0 开始
	}
	for (int i = 1; i <= k; i++) { //预处理
		for (int j = 1; j <= k; j++) {
			pre[i][j] += pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1];
		}
	}
	for (int i = m; i <= k; i++) { //暴力更新答案
		for (int j = m; j <= k; j++) {
			ans = max(ans, pre[i][j] - pre[i - m][j] - pre[i][j - m] + pre[i - m][j - m]);
		}
	}
	printf("%d\n", ans);
	return 0;
} // AC 啦
```

---

## 作者：Pi0o3 (赞：3)

这道题的边界 ~~太坑了~~ 需要你们好好思考,,,

re警告！！！
    
    
    #include<iostream>
	#include<cstdio>
	#include<cstring>
	#include<cmath>
	#include<algorithm>
	using namespace std;
	int a[5010][5010];    
	int main(){
    int n,r;
    int x,y,v;
    int vm=0;
    scanf("%d%d",&n,&r);
    for(int i=1;i<=n;i++)
    {
    	cin>>x>>y>>v;
    	a[x+1][y+1]=v;//防边界炸裂
  
    	
    }
    for(int i=1;i<=5001;i++)
    {
        for(int j=1;j<=5001;j++)
        {
            a[i][j]=a[i-1][j]+a[i][j-1]+a[i][j]-a[i-1][j-1];//算上方和左方的总和，，，因为这道题好像只能用一个二维数组。所以请不要吝啬，大胆地在原数组上操作！
        }
    }
    for(int i=r;i<=5001;i++)
    {
        for(int j=r;j<=5001;j++)
        {
            v=a[i][j]-a[i-r][j]-a[i][j-r]+a[i-r][j-r];
            
就是要理解delta[l]和delta[r+1]的作用（对于一维而言），二维也类似，~~草稿纸上照我的代码画一画就出来了~~，以上为鄙人的啰嗦，诸位大可不看。
            
            if(v>vm)
                vm=v;
        }
    }
    printf("%d",vm);
    return 0;
} 

---

## 作者：formkiller (赞：2)

### Part 0 : 前言
___

第一次写的时候以为会被卡空间，因此有了这个另类的做法。比起一般的二位前缀和做法可以大大节省空间，约为 $\text{1MB}$ 与 $\text{96MB}$ 的差异。



### Part 1 : 算法
___

回归到此题的本质上，不难将题目转化为：给出一个 $N \times M$ 的矩阵，求一个边长为 $m$ 的正方形能覆盖到的点的权值最大值。其中 $N = \max\{x_i,m\}$，$M = \max\{y_i,m\}$。

一个暴力的做法是枚举每个点作为正方形的右下角点，统计框进去的点的权值最大值。该做法的复杂度为 $\text{O}(NMm^2)$，当数据足够大时接近 $\text{O}(m^4)$。又注意到对于 $(i,j)$ 和 $(i,j+1)$，他们覆盖范围大量相同，因此 $(i,j)$ 转移到 $(i,j+1)$ 的时候仅用处理 $2m$ 个点，时间复杂度优化为 $\text{O}(m^3)$。

考虑进一步优化，注意到 $n$ 的取值范围很小，因此转移时处理的 $2m$ 个点实际上有很多都对答案没有贡献。又注意到对于每个点，至多被处理 $2m$ 次（进入被选矩阵和离开被选矩阵各 $m$ 次），因此在转移这一步的时间复杂度总和为 $\text{O(nm)}$。那么如何快速找到转移时所需要的有意义的点呢？我们可以分别按行和列用 $\text{vector}$ 容器储存处在该行跟列的所有点，并升序储存（也就是 $x$相同时按 $y$ 升序）。

但这样也会造成一个点的超时：[Link](https://www.luogu.com.cn/record/77714353)。原因在于调用 $\text{vector}$ 容器时我们仍会进行前面的多次调用，因此可以开一个数组记录容器的起始枚举位置（详见两份代码的差异）。




### Part 2 : Code
___
```cpp
//good luck
# include <iostream>
# include <cstdio>
# include <cmath>
# include <cstdlib>
# include <cstring>
# include <string>
# include <algorithm>
# include <vector>
# include <queue>
# include <ctime>
# include <map>

#define LL long long
#define maxn int(1e4+5)
#define is(a) (a>='0'&&a<='9')
#define iabs(a) ((a)>0?(a):(-a))
#define imax(a,b) ((a)>(b)?(a):(b))
#define imin(a,b) ((a)<(b)?(a):(b))

using namespace std;

struct data{int x,y,z;}g[maxn];

vector <data> c[maxn],d[maxn];

int N,M,ans,s,mx,my,mmx,mmy,a[maxn],tt[maxn];

inline void read(int &x)
{
  x=0;bool f=0;char ch=getchar();
  for (;!is(ch);ch=getchar()) f|=ch=='-';
  for (;is(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
  x=f?-x:x;
}

void add(int type,int x,int l,int r,int z) {
	if (type) {
		for (int i = 0; i < c[x].size() && c[x][i].y <= r; ++i) {
			if (c[x][i].y >= l) s += c[x][i].z * z;
		}
	}
	else {
		for (int i = tt[x]; i < d[x].size() && d[x][i].x <= r; ++i) {
			if (d[x][i].x >= l) s += d[x][i].z * z;
			else tt[x] = i + 1;
		}
	}
}

inline bool cmp1(data a,data b){return a.x < b.x || (a.x == b.x && a.y < b.y);}
inline bool cmp2(data a,data b){return a.y < b.y || (a.y == b.y && a.x < b.x);}

int main()
{
//	freopen("a.in","r",stdin);
	read(N); read(M);
	for (int i = 1; i <= N; ++i) {
		int x,y,z;
		read(x); read(y); read(z);
		++x; ++y;
		g[i].x = x; g[i].y = y; g[i].z = z;
		mx = imax(mx,x); my = imax(my,y);
	}
	sort(g+1,g+1+N,cmp1);
	for (int i = 1; i <= N; ++i) {
		int x = g[i].x, y = g[i].y, z = g[i].z;
		c[x].push_back((data){x,y,z});
	}
	sort(g+1,g+1+N,cmp2);
	for (int i = 1; i <= N; ++i) {
		int x = g[i].x, y = g[i].y, z = g[i].z;
		d[y].push_back((data){x,y,z});
	}
	mmx = imin(M,mx); mmy = imin(M,my);
	for (int i = 1; i < mmx; ++i) {
		add(1,i,1,mmy-1,1);
	}
	a[mmx - 1] = s;
	for (int i = mmx; i <= mx; ++i) {
		s = a[i-1];
		add(1,i,1,mmy-1,1);
		add(1,i-mmx,1,mmy-1,-1);
		a[i] = s;
		ans = imax(ans,s);
		for (int j = mmy; j <= my; ++j) {
			add(0,j,i-mmx+1,i,1);
			add(0,j-mmy,i-mmx+1,i,-1);
			ans = imax(ans,s);
		}
	}
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：_ChongYun_ (赞：2)

# 前置知识：前缀和

### 一维前缀和

给出一个一维数组 $a$。

维护 $sum_i$，表示该数列从第一个到第 $i$ 个元素之和。

可得式子：$sum_i=sum_{i-1}+a_i$。

代码：

```cpp
for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
```

### 二维前缀和

本题的关键。

给出一个二维数组 $a$。

维护 $sum_{i,j}$，表示以 $(1,1)$ 为左上顶点，以 $(i,j)$ 为右下顶点的矩阵内元素之和。

根据容斥可推出式子：$sum_{i,j}=sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}+a_{i,j}$。

代码：

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
    	sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
    }
}
```

# 解析

暴力想法，枚举每一个右下点，将所对应的边长为 $m$ 的正方形内的和求出，取最大值即可。而其中的求元素之和可以使用**二维前缀和**代替。

在输入时，请注意：目标点的权值可能**不止一个**。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=INT_MIN,sum[5010][5010];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int x,y,val;
        cin>>x>>y>>val;
        ++x; ++y;
        sum[x][y]+=val;
    }
    for(int i=1;i<=5001;i++){
        for(int j=1;j<=5001;j++){
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+sum[i][j];
        }
    }
    for(int i=m;i<=5001;i++){
        for(int j=m;j<=5001;j++){
            ans=max(ans,sum[i][j]-sum[i-m][j]-sum[i][j-m]+sum[i-m][j-m]);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：wizard（偷开O2 (赞：1)

这是一道二维前缀和的好题。

## 题意

有一地图，图上有 $n$ 个有权值的点，目标是利用一个边长为 $m$ 的正方形覆盖最多的点，最后输出最多的点权值和。

## 分析
理解题意后，我们发现需要在一张边长在 $5000$ 之内的图上实现查找操作，所以在我们把内存运用完全时，$O(n^2)$ 就能通过此题。

首先，我们预处理数据范围限度内的 $a$ 数组，算出 $a$ 数组的前缀和 $b$ 数组，但是为了省空间，在原数组的基础上做前缀和数组，即：$a_{i,j}=\sum\limits_{x=1}^{i}\sum\limits_{y=1}^{j} a_{x,y}$。

```cpp
	for(int i=1;i<=5001;i++){
		for(int j=1;j<=5001;j++){
			a[i][j]+=(a[i-1][j]+a[i][j-1]-a[i-1][j-1]);
		}
	}
```


接下来我介绍一种利器：容斥原理。

如果我们遇到了一个长为 $i$，宽为 $j$ 的矩形。若将长减小 $1$，宽不变，得到矩形 $A$，将宽减小 $1$，长不变，得到矩形 $B$，将 $A$，$B$ 重合，得到重合面积是 $(i-1) \times (j-1)$，故将重合面积减去，很容易推出一个式子：$i \times j=(i-1)j+(j-1)i-(i-1)(j-1)+1$。

放在此题目中，若前缀和数组为 $b$，就有：$b_{i,j} = b_{i-1,j}+ b_{i,j-1}-b_{i-1,j-1}+a_{i,j}$。

同理，在边长为 $m$ 的炸弹范围内，设范围内权值和为 $ans$，存在:$ans=b_{i,j}-b_{i-m,j}-b_{i,j-m}+b_{i-m,j-m}$。

最后求出最大的 $ans$ 就是最终答案。

附：因为可能存在单点权值的覆盖，所以权值输入时要累加。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=5010;
int a[maxn][maxn],s[maxn][maxn];
int main(){
	cin >> n >> m;
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++){
		int x,y,z;
		cin >> x >> y >> z;
		a[x+1][y+1]+=z;
	}
	for(int i=1;i<=5001;i++){
		for(int j=1;j<=5001;j++){
			a[i][j]+=(a[i-1][j]+a[i][j-1]-a[i-1][j-1]);
		}
	}
	int maxx=-5;
	for(int i=m;i<=5001;i++){
		for(int j=m;j<=5001;j++){
			int ans=a[i][j]-a[i-m][j]-a[i][j-m]+a[i-m][j-m];
			maxx=max(ans,maxx);
		}
	}
	cout << maxx  << endl;

	return 0;
}
```



---

## 作者：Super_Builder (赞：1)

## 思路

按照提议模拟，枚举正方形起始点，然后再计算次正方形爆破价值，结果肯定是正确的，但是时间上会爆掉。

考虑优化。优化什么地方呢？

正方形的爆破价值计算是可以优化的。

用**二维前缀和**预处理。假设现在位置为 $(x,y)$，$a_{i,j}$ 表示 $(i,j)$ 的价值，那么:

$$s_{i,j}=\sum_{i=1}^{i\le x} \sum_{j=1}^{j\le y}a_{i,j}$$

但是这样算显然超时，所以利用容斥原理可以得出：

$$s_{i,j}=s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+a_{i,j}$$

知道这个，计算价值也很容易。  
以 $(i,j)$ 为当前正方形起始位置，设 $p = i + m$，$q = j + m$。

那么当前正方形价值为：

$$s_{p,q}-s_{i,q}-s_{p,j}+s_{i,j}$$

最后将每个正方形价值取最大值即可。

**注意**，题目中有句话，“可能存在多个目标在同一位置上的情况”，所以记得不要直接把 $a_{x,y}$ 赋值为 $v$，应该是加上 $v$。我以前过的时候好像还不需要考虑这种情况。

## AC CODE

刚学完语法后学的前缀和，码风不好，见谅。

```cpp
#include <bits/stdc++.h>
using namespace std;
int s[5010][5010];
int main()
{
	int n,m,ans=-0x3f3f3f3f;
	cin>>n>>m;
	for(int i=1,x,y,u;i<=n;i++)
	{
		cin>>x>>y>>u;
		s[x+1][y+1]+=u;
	}
	for(int i=1;i<=5001;i++)
	{
		for(int j=1;j<=5001;j++)
		{
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+s[i][j];
		}
	}
	for(int i=0;i<=5001-m;i++)
	{
		for(int j=0;j<=5001-m;j++)
		{
			int p=i+m,q=j+m;
			ans=max(ans,s[p][q]-s[i][q]-s[p][j]+s[i][j]);
		}
	}
	printf("%d",ans);
	return 0;
} 

```

---

## 作者：A_zjzj (赞：1)

# [HNOI2003]激光炸弹zhengjun123
## 题目描述
### 题目描述

一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。

现在地图上有n(N<=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。 

### 输入

输入文件的第一行为正整数n和正整数R。

接下来的n行每行有3个正整数，分别表示xi,yi,vi

### 输出

输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过32767）。

### 样例输入

2   1

0  0  1

1  1  1

### 样例输出

1

## 题解
读了题目，一定想到一种暴力吧，不过，这样只会全 T 掉。
### 理解
首先，我们经常需要知道一个部分的总和，那么，第一就想到用前缀和，用 f [i] [j] 表示从 [1] [1] 到 [i] [j] 的总和，查询 f [i] [j] 时就可以用公式：
```cpp
f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
```
来实现，如图：

![](https://cdn.luogu.com.cn/upload/pic/16031.png)

应该很好理解。
### 代码实现
```cpp
#include<cstdio>
#define maxn 5555
#define max(x,y) (x>y?x:y)
using namespace std;
int T,m;
int f[maxn][maxn];
int ans=-231321234;
int main()
{
    scanf("%d%d",&T,&m);
    for(register int i=1;i<=T;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        f[x+1][y+1]+=z;//f从1开始，这样就不用考虑数组越界了
    }
    for(register int i=1;i<=5001;i++)
    {
        for(register int j=1;j<=5001;j++)
        {
            f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
        }
    }
    for(register int i=m;i<=5001;i++)
    {
        for(register int j=m;j<=5001;j++)
        {
            ans=max(ans,f[i][j]-f[i][j-m]-f[i-m][j]+f[i-m][j-m]);
        }
    }
    printf("%d",ans);
    return 0;
}
```
但是这样太慢了，可以从以下三个方面来优化：

     1.快读快写+O2。
     2.赋值查询一起做完。
     3.如果这组数据比较小（比如从[0][0]到[5][5]）,还是要跑一遍5000^2.
### 优化后代码
```cpp
#pragma GCC optimize(2)
#include<cstdio>
#define maxn 5555
using namespace std;
int T,m,maxx;
int f[maxn][maxn];
int ans=-231321234;
int read()
{
    int f=1,x=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*f;
}
void print(int x)
{
    if(!x)return;
    print(x/10);
    putchar(x%10+'0');
}
int main()
{
    T=read();m=read();
    for(register int i=1;i<=T;i++)
    {
        int x,y,z;
        x=read();y=read();z=read();
        f[x+1][y+1]+=z;
        if(x+1>maxx)maxx=x+1;
        if(y+1>maxx)maxx=y+1;
    }
    for(register int i=1;i<=maxx;i++)
    {
        for(register int j=1;j<=maxx;j++)
        {
            f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
            if(i>=m&&j>=m)
            {
                if(f[i][j]-f[i][j-m]-f[i-m][j]+f[i-m][j-m]>ans)
                {
                    ans=f[i][j]-f[i][j-m]-f[i-m][j]+f[i-m][j-m];
                }
            }
            else if(i>=m)
            {
                if(f[i][j]-f[i][1]-f[i-m][j]+f[i-m][1]>ans)
                {
                    ans=f[i][j]-f[i][1]-f[i-m][j]+f[i-m][1];
                }
            }
            else if(j>=m)
            {
                if(f[i][j]-f[i][j-m]-f[1][j]+f[1][j-m]>ans)
                {
                    ans=f[i][j]-f[i][j-m]-f[1][j]+f[1][j-m];
                }
            }
        }
    }
    print(ans);
    return 0;
}
```
# 谢谢!---zhengjun



---

## 作者：minVan (赞：1)

**解题思路**

不难想到用二维前缀和，其代码如下：

```cpp
for(int i = 1; i <= n; i++) {
  int x, y, v;
  cin >> x >> y >> v;
  a[x + 1][y + 1] += v;
}
for(int i = 1; i < N; i++) {
  for(int j = 1; j < N; j++) {
    s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
  }
}
```

对于边长为 $m$，起始坐标为 $(i,j)$ 的正方形其包含价值和为 

$$
\large s_{i+m-1,j+m-1}-s_{i-1,j+m-1}-s_{i+m-1,j-1}+s_{i-1,j-1}
$$

最终答案为

$$
\large\max\limits_{i\in\left[1,\max\limits_{p\in[1,n]}\{x_p\}-m+1\right],j\in\left[1,\max\limits_{q\in[1,n]}\{y_q\}-m+1\right]}\left\{s_{i+m-1,j+m-1}-s_{i-1,j+m-1}-s_{i+m-1,j-1}+s_{i-1,j-1}\right\}
$$

但是要注意几点 ：

- 输入时应从 $1$ 开始，即应对 $a_{x+1,y+1}$ 更改。因为如果从 $0$ 开始，接下来处理 $s_{0,j}$ 或 $s_{i,0}$ 就会数组越界。

- 遍历正方形起始点时要提前计算好终止点，一定不能超过位置最大点。

- 目标可能重合，所以应该是 $a_{x,y}\gets a_{x,y}+v$，而不是 $a_{x,y}\gets v$。

**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e3 + 5;
int n, m;
int s[N][N], a[N][N];
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 1; i <= n; i++) {
    int x, y, v;
    cin >> x >> y >> v;
    a[x + 1][y + 1] += v;
  }
  for(int i = 1; i < N; i++) {
    for(int j = 1; j < N; j++) {
      s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
    }
  }
  int ans = -1;
  for(int i = 1; i < N - m; i++) {
    for(int j = 1; j < N - m; j++) {
      int tmp = s[i + m - 1][j + m - 1] - s[i - 1][j + m - 1] - s[i + m - 1][j - 1] + s[i - 1][j - 1];
      ans = max(ans, tmp);
    }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：LightningUZ (赞：0)

前缀和的做法很显然：求出二维前缀和，用容斥原理求出子矩阵的和，然后更新最大值。

这里讲一个小优化：大家存储数据的矩阵a数组都是用的int类型，实际上用short是完全珂以的。

观察数据发现，10000个点，每个点价值最大100，乘一下，显然会爆short。但是为什么short珂以呢？

**溢出只会影响乘除运算，不会影响加减运算**

我们知道SHORT_MAX+1=SHORT_MIN，但是SHORT_MIN-1又等于SHORT_MAX。题目中保证最后的答案<32767，也就是在short范围内。那么，即使中间过程爆了，再减回来，什么事也没有。相当节省空间。

short占用的空间只有int的一半。就是说，哪怕你不会写原地修改版的前缀和，也不会MLE。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 5003
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define iter(a,p) (a.begin()+p)
    void R1(int &x)
    {
        x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        x=(f==1)?x:-x;
    }
    void Rd(int cnt,...) //@Sukazyo赞助的可变参数
    {
        va_list args;
        va_start(args,cnt);
        F(i,1,cnt) 
        {
            int* x=va_arg(args,int*);R1(*x);
        }
        va_end(args);
    }

    int n,r;
    short a[N][N]; //只要short就珂以了
    void Input()
    {
        Rd(2,&n,&r);
        F(i,1,n) 
        {
            int x,y,w;Rd(3,&x,&y,&w);
            ++x,++y; //有0的，懒得处理0了，平移成[1,5001]。不影响答案。
            a[x][y]+=w;
        }
    }

    short sum(int a1,int b1,int a2,int b2){return a[a2][b2]-a[a1-1][b2]-a[a2][b1-1]+a[a1-1][b1-1];}
    //这函数不会溢出哦~
    void Soviet()
    {
        F(i,1,5001) F(j,1,5001) a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; //原地修改版的前缀和.a数组是有珂能溢出的

        short ans=0;
        F(i,1,5001-r+1) F(j,1,5001-r+1) ans=max(ans,sum(i,j,i+r-1,j+r-1)); 
        printf("%hd\n",ans);
        //C/C++用%hd输出short类型的数
    }

    #define Flan void
    Flan IsMyWife()
    {
        Input();
        Soviet();
    }
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---


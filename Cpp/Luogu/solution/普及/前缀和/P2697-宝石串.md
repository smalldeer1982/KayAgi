# 宝石串

## 题目描述

有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。

绿宝石用 $\texttt G$ 表示，红宝石用 $\texttt R$ 表示。


## 说明/提示

$\texttt {RGGR}$ 为答案。

宝石数小于等于 $10^6$。


## 样例 #1

### 输入

```
GRGGRG```

### 输出

```
4```

# 题解

## 作者：在想Peach (赞：60)

C艹里算挺短的代码吧

对于一个类似的东西进行前缀和：

   G R G G R G
   
G：1 1 2 3 3 4

R：0 1 1 1 2 2

差：1 0 1 2 1 2

所得关于差的数列，同样的数最左最右的位置差为一个答案，选取最大的答案即为解，注意为0特判位置即答案。

至于为什么，用前缀和的思想，同位差相等那么这段区间的差就相等，所以记录一个差的最早出现位置就行，注意负数溢出，加上一个常数便可。

code：

```cpp
#include<iostream>
using namespace std;
string s;
int ans,p[2000005],last=1000000;
int main()
{
	cin>>s;
	for(int i=1;i<=s.length();i++){
		if(s[i-1]=='R')last++;
		else last--;
		if(!p[last])p[last]=i;
		else ans=max(ans,i-p[last]);
		if(last==1000000)ans=i;
	}
	cout<<ans<<endl;
}
```


---

## 作者：MloVtry (赞：39)

【为美好的前缀和献上祝福】

可以认为G是-1，R是1，然后求一个前缀和s

如果s[i]==s[j]，那么j--->i这一整段，一定是一个和为0的区间，即红绿相等的稳定区间

为了让其长度最长，可以维护一个最小值num[i]表示i这个值第一次出现在什么地方

由于有负数，所以要统一+n

然后第一个0出现在序列一开始的地方（别忘了转化0）

以下是c艹的代码

【跟我一起对那个奇技淫巧的人竖中指，滑稽】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1000010
#define inf 1<<30
using namespace std;
int f[N],n,ans;
int num[2*N];
char a[N];
int main()
{
    scanf("%s",a+1);
    n=strlen(a+1);
    for(int i=1;i<=n;++i)
    {
        if(a[i]=='G') f[i]-=1;
        if(a[i]=='R') f[i]+=1;
    }
    for(int i=1;i<=2*n+2;++i) num[i]=inf;
    num[0+n+1]=0;
    for(int i=1;i<=n;++i)
    {
        f[i]+=f[i-1];
        num[f[i]+n+1]=min(i,num[f[i]+n+1]);
        ans=max(ans,i-num[f[i]+n+1]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：altar (赞：16)

    闲话少说，上代码
    还有件事，数组越界问题
    需要注意
    #include <bits/stdc++.h>
    using namespace std;

    char a[3000001] ;
    int ans , l , sum [3000001],bo[3000001] ;

    int main()
    {
    //	freopen ("d.in" , "r" , stdin ) ;
        //freopen ("d.out" , "w" , stdout ) ;
        scanf ("%s",a + 1 );  // 输入
        l = strlen(a + 1) ; // 求长度
        for (int i = 1 ; i <= l ; i ++ ){
            sum[i] = sum[i-1] + ( a[i] == 'R' ? 1 : -1) ;
            //即传说的前缀和，sum[i] = 以前的和 加上 目前的
            //如果 a[i] 是 'R' 的 话，会 加1 else 加 -1 
            // 因为 要是 整数，所以 1 + -1 = 0 
            // sum[i] 表示 从头到 i 这里的是'R'的和
            // 我们求的是一个R，G数量相同的区间
        	//只要 在这个区间里，RG的所代表的值加起来是0
        	//就意味 这个区间 符合题意
        	// 所以 我们 模拟 R的 数量 就可以了
            if (!bo[sum[i] + 1000001] && sum[i]) bo[sum[i]+1000001] = i ;
            // 这里数组 防止 下溢，所以 加10000001 
            //这里的if 里面 第一个要求 !bo[sum[i]]就是 说看 bo数组 里面 是不是 零
            //是零才可以赋值
            //第二个要求 sum[i] 不为零 ，因为sum[i]是零 的话，就没有意义了
            // 赋值 的时候，就是 把 a[i] 的坐标，就是 i 赋给 bo数组
            else ans = max (ans, i - bo[sum[i]+1000001]) ; 
            // 如果 bo数组 不为零 的时候 ，重新 赋值 新的区间
            // 就是 从 ans(初始为零)
            // i - bo[sum[i]] 就是 新的区间 
            // 这里 为什么 没有 加 1
            // 因为 从 i， 到 另一个 下标 bo数组，之间 是
        }
        printf ("%d",ans) ;
        return 0 ;
    }

---

## 作者：2311241987j (赞：15)

这道题的数据比较水啊    
o(n^2)都可以过了   
其实还可以有一些优化的，没想到就这么过了，比dp简单些。   
可以把第二个循环倒过来，找到第一个合法就break这样可以快一点。   
思路:for循环判断cha值 是否为合法的一段然后取max
```
#include<bits/stdc++.h>
using namespace std;
char a[1000005];
int la,ans=0;
int main() {
	cin>>(a+1);
	la=strlen(a+1);
	for(int i=1; i<=la; i++) {
		int cha=0;
		for(int j=i; j<=la; j++) {
			if(a[j]=='G')cha--;
			else cha++;
			if(cha==0)ans=max(j-i+1,ans);
		}
	}
	cout<<ans<<endl;
}
```

---

## 作者：Henry_he (赞：12)

我们本题的绿宝石记为1，红宝石的记为-1，用a数组记录它们的和

即前i个人中绿宝石比红宝石多a[i]个

显而易见，当a[i]=a[j] (i<j)时，第 i+1 到 j 的红绿宝石个数相同

(可以理解为加上的1和-1相等)

所以对每一个a[j]只要找到最小的i使得a[i]=a[j],然后用(i-j)与现有最优ans比较

```cpp
var f:array[-1000000..1000000]of longint;
    a,n,i,j,ans:longint;
    s:ansistring;
begin
  readln(s);//读入
  n:=length(s);
  for i:=1 to n do
  begin
    if s[i]='G' then a:=a+1;//a表示当时的a[i]
    if s[i]='R' then a:=a-1;
    if (a<>0)and(f[a]=0) then f[a]:=i;//若第一次则保存第一次出现a[i]的值的i位置
    if (i-f[a])>ans then ans:=i-f[a];//更新ans
  end;
  writeln(ans);
end.
```

---

## 作者：浥轻尘 (赞：10)

### 判断
红色=绿色 即为稳定 我们统计当前区间【i，j】内红色宝石的数量，当红色宝石的数量等于区间长度的一半时即为稳定的项链 可以用**前缀和**实现


```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100000];
int red[100000],ans;
int main(){
	scanf("%s",&a);
	for(int i=0;i<strlen(a);i++){//注意坐标
	 red[i+1]=red[i];
	 if(a[i]=='R') red[i+1]++;//前缀和
	}
	int len;
	for(int i=1;i<=strlen(a);i++)
     for(int j=i+1;j<=strlen(a);j+=2){//项链必须有偶数个宝石才可能满足条件
		len=j-i+1;
		if(red[j]-red[i-1]==(len/2)) 				ans=max(ans,len);
     }
	
	printf("%d\n",ans);
	
	return 0;
}
```

蒟蒻题解 大佬多多包涵qwq



---

## 作者：daniel14311531 (赞：9)

**其实这题还可以用前缀和（看不懂DP的有福了）。**

用前缀和sum[i]表示前i个中R比G多几个，然后从首位个找出R比G多x个并分别存入各自的数组l/r[x+1000000/\*有负数情况\*/]，找出r[x]-l[x]最大就可以了。特别注意的是，l[1000000]=0（初始情况）。


上代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000001];
int len,sum[1000001]/*前缀和*/,ans=-1;
int l[2000001],r[2000001];
int main()
{
    scanf("%s",s);
    len=strlen(s);
    for(int i=0;i<len;i++)
        sum[i+1]=sum[i]+(s[i]=='R'?    1:-1);
    for(int i=0;i<=len;i++)
    {
        if(l[sum[i]+1000000]==0&&sum[i]!=0/*特判*/)
            l[sum[i]+1000000]=i;
        if(i!=0&&r[sum[len-i+1]+1000000]==0)
            r[sum[len-i+1]+1000000]=len-i+1;
    }
    for(int i=0;i<=2000000;i++)
        if(ans<r[i]-l[i])
            ans=r[i]-l[i];
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Terrible (赞：8)

关于这道题，我有一个**神奇**的做法，这种做法也不是很流行。 _实现难度也比较大，但希望各位能从其中能有所得。_ 

**首先**：建立一个栈记录可行解，一个数组储存原来数据。

**然后**：将R和G分别处理成为0,1并逐步放到栈内：

①如果遇到01或者10，将01(或者10)合成2,替换原来的01(10)，这样就用贪心把靠前的一组可行解合并了；

②如果遇到021(或者120)将这3个合成4，041也可以这样合成6，以此类推；

③如果遇到22、24、42、46这样的数据合并它们。

这个栈中储存了(num,poi)：

num是处理后的数据，num只有两种情况：

①2,4,6这样的大于0的偶数，表示合并了num个宝石的可行解。

②情况就是“散宝石”，0表示单独的R，1表示单独的G，poi是可行解最左边宝石在源数据中的下标。

例如(4,0)表示可行解大小为4,可行解在源数据最左边的边界是0，后面需要用到这个可行解的位置。

如此合并出的可行解是贪心的结果，可行解的左边右边都是“散宝石”。

**最后**：我们可以让可行解的范围向右滚动，如果范围内最左边的宝石和右边相邻的宝石一致，抛弃范围内最左边的宝石，加上右边相邻的宝石，合成新的可行解，直到这个可行解“撞”到另一个可行解上，或者无法滚动。

依次记录最大值。这个最大值就是解。
```cpp
(这是我人肉打出来的数据)
源数据：RRGGGGRGGGRGGGRRRGRGGRGRGRG
处理  ：0011 1 10 1 1 1011100010 1 101010 1
得到  ：4    1 2  1 1 10         1 6      1
(其中：1是G，0是R，其余偶数表示已合成的可行解)
数据栈：(4,0)  (1,4)  (2,5)  (1,7)  (1,8)  (10,9)  (1,19)  (6,20)  (1,26)
最大解：让1011100010向右滚动变成0111000101此时发现这个可行解“撞”上了另一组可行解，记录两个可行解的和,该解是最大值。
```
附上代码：
```cpp
#include<cstdio>
#define max(a,b) (a>b?a:b)
bool x[1000010]; //源数据 
struct Node{int num,poi;}y[1000010];//合成栈 
int main()
{
	int headx=0,heady=0,a;
	register int i,j;
	char c;
	while((c=getchar())!=-1)
	{
		if(c=='G')a=1; //将R转化成0，G转化成1压入栈中 
		else a=0;
		y[heady].num=a,y[heady].poi=headx,heady++;
		x[headx++]=a;
		if(heady>=2) //把栈顶01(10)这样的数据合成 
			if(y[heady-2].num+y[heady-1].num==1)
				y[heady-2].num=2,heady--;
		if(heady>=3) //把栈顶021(120)这样的数据合成 
			if(y[heady-2].num>=2 && y[heady-3].num+y[heady-1].num==1)
				y[heady-3].num=y[heady-2].num+2,heady-=2;
		if(heady>=2) //把栈顶22、24、62这样的数据合成 
			if(y[heady-1].num>=2 && y[heady-2].num>=2)
				y[heady-2].num+=y[heady-1].num,heady--;
	} //此时栈中的数据中包含着散宝石和合成了的可行解，且交错出现 
	int max0=0;
	for(i=j=0;i<heady;i++) //这里将散宝石剔除出去，留下可行解 
		if(y[i].num>=2) //i表示扫描位置，j表示新栈的栈顶 
		{
			y[j].num=y[i].num;
			y[j].poi=y[i].poi;
			j++;
		} //处理完不必管栈顶之外的非0元素 
	heady=j; //还要更改栈顶的位置 
	for(i=0;i<heady-1;i++)//定义l为可行解最左面的宝石的位置 
	{					  //定义r为可行解右面相邻的宝石的位置 
		int sum,l=y[i].poi,r=y[i].poi+y[i].num; 
		while(x[r]==x[l]&&r!=y[i+1].poi) //滚动 
			l++,r++;
		if(r==y[i+1].poi) //检测是否撞到另一个可行解 
			sum=y[i].num+y[i+1].num;//把两个可行解加在一块 
		else
			sum=y[i].num;
		max0=max(max0,sum);
	}
	max0=max(max0,y[heady-1].num);//还要考虑排在最后的可行解 
	printf("%d",max0);
}
```

---

## 作者：prefer (赞：8)

这算哪门子DP啊 

直接一个DFS就过了？？？

~~可能是数据太水了~~

没啥技术含量 代码有注释
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000005];
int ans,l;
void dfs(int cha/*abs(g-r)*/,int Nnum,int Nans) { //表示当前G-R的值，现在的编号（序号），现在的答案
	if(Nnum>l) return;//现在的序号大于长度return
	if(cha==0)//相等
		if(Nans>ans) ans=Nans; //更新
	if(s[Nnum]=='R')//如果是R
		dfs(cha-1,Nnum+1,Nans+1); //R大了1，差值减小1
	else dfs(cha+1,Nnum+1,Nans+1);//G大了1，差值增加1
	return;
}
int main() {
	gets(s);
	l=strlen(s);
	for(int i=0;i<l-ans;i++) //如果想要更新答案，当前的位置一定要在L-ans之前否则是找不到的
	dfs(0,i,0);
	cout<<ans<<endl;
	return 0;
}
```
over

---

## 作者：Meatherm (赞：7)

大家好我又来发题解了，，，

这道题比较~~水~~难，我用的是暴力（剪枝）+前缀和维护，每个点都可以到3ms左右。

好的话不多说我们来分析可以怎样剪枝:（忙人请跳过）

```
		for(int j=i+maxx+1;j<=n;j+=2)
```

这段代码有何用？
- 从i+maxx+1开始循环。

那么前面的段（我们不管它是否匹配）都没有当前的maxx大。

- j+=2

只有偶数个才有可能匹配。这一点很容易想到的哦~

还有：
```
	n=a.length();
	for(int i=0;i<n;i++)
```

这里为什么不直接
```
for(int i=0;i<a.length();i++)
```
因为循环时如果像后者这样写的话，每循环一次就会调用一次length函数，很耗~~代码量~~运行时间滴！

~~其实还有很多地方可以剪的，但是我太弱了，于是就没剪~~

贴上蒟蒻香喷喷的代码~
```
# include <bits/stdc++.h>
using namespace std;
int n,f[1000434],maxx;
string a;
int main()
{
	ios::sync_with_stdio(false);//让cin变快的黑科技*1
	cin.tie(0);//让cin变快的黑科技*2
	cin>>a;
	n=a.length();
	for(int i=0;i<n;i++)//剪枝*1
		if(a[i]=='G')f[i+1]=f[i]-1;
		else f[i+1]=f[i]+1;//为了让串均衡（为0）所以遇到G就-1反之+1
	maxx=0;//一开始没有符合要求的串
	for(int i=1;i<=n;i++)
		for(int j=i+maxx+1;j<=n;j+=2)//剪枝*2
			if(f[j]-f[i-1]==0)maxx=max(maxx,j-i+1);
	cout<<maxx;
	return 0;
}
```

---

## 作者：无名ZWH (赞：3)

本题为前缀和题令‘G’=1，‘R’=-1即可  
若从某一段开头到结尾和为0
则该段两种宝石数目相等  
那么——上代码
```
#include<bits/stdc++.h>//以后可以用万能头了
using namespace std;  
int a[1000050],l,yh=0,ans=0,sum=0;  
char b[1000050];  
int main() 
{  
	cin>>b;  
	l=strlen(b);  
	for(int i=0;i<l;i++)  
 	{  
		if(b[i]=='G')  
		{  
			a[i]=1;//预处理G=-1   
		}  
		if(b[i]=='R')  
		{  
			a[i]=-1;//预处理R=1   
		}  
	}  
	for(int i=0;i<l;i++)  
	{  
		for(int j=i;j<l;j++)  
		{   
			sum++;//该段宝石数   
			yh+=a[j];//前缀和，两种宝石数量相等则为0   
			if(yh==0)//如果宝石数目相等  
			{  
				ans=max(sum,ans);
                //且该段数目比之前数目大则更新ans  
			}  
		}  
		yh=0;//清空   
		sum=0;//清空   
	}  
	cout<<ans;//ans就是答案  
	return 0; //养成好习惯 要打return 0  
}

---

## 作者：小柯 (赞：2)

$\large\texttt{居然没有人发记搜？}$~~暗自狂喜~~。

$\color{black}{dfs(i)}$表示以$\color{black}{i}$为起始点的最长的稳定的宝石串有多少颗宝石。

$\large\texttt{废话少说，上代码。}$

$\color{black}{Code:}$

```cpp
#include<iostream>
#include<cstring>
#include<string>
#define orz 0
using namespace std;
string s;
int n,ans,f[1000005];
int dfs(int i){
	if(f[i]!=-1)return f[i];
	int r=orz,g=orz,ans=orz;
	for(int j=i;j<n;j++){
		if(s[j]=='R')r++;
		else g++;
		if(r==g)ans=max(ans,dfs(j+1)+j-i+1);
	}
	f[i]=ans;
	return f[i];
}
int main(){
	memset(f,-1,sizeof(f));
	getline(cin,s);
	n=s.size();
	f[n]=orz;
	for(int i=orz;i<n-ans;i++)ans=max(ans,dfs(i));//n-ans的位置是肯定取不到的。
	cout<<ans;
    return orz;
}
```


---

## 作者：白鹰 (赞：2)

# **什么情况？这么暴力也能过？**
是的，你没有看错，我本来想看看这题暴力能拿多少分的，谁知道竟然直接AC，看题解里没有人直接枚举的，我就双奉上我简单粗暴的代码喏（真·新手福利，其实应该是题目数据太水了）。
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <stdlib.h>
#include <memory.h>
using namespace std;
#define M 50000

int main()
{
    ios::sync_with_stdio(0);//关闭流同步，cin读入优化
    string s;
    cin>>s;
    int ans=0;//初始化总和
    for(int i=0;i<s.size();i++)
    for(int j=i+1;j<s.size();j++)//i为左区间端点，j为右区间的端点
    {
        int ng=0,nr=0;//ng是'G'出现的次数，nr是'nr'出现的次数
        for(int k=i;k<=j;k++)//统计区间中G和R分别出现的次数
        if(s[k]=='G')
        ng++;
        else nr++;
        if(ng==nr)
        ans=max(ans,ng<<1);//ng<<1相当于ng*2,即取最长的串
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：LGNN (赞：2)

为什么这题的标签是dp啊....暴力就好了啊
预处理出前缀和，然后枚举能到这一个点的可以的最长链，其中从前完后找，能找到第一个后就直接break，因为再往后找的链一定比这个短.....
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;
const int maxn = 1e6 + 5;
int a[maxn] , s[maxn];
int main() {
	ios::sync_with_stdio(false);
	char ch;
	int n = 0;
	while(cin >> ch) {
		if(ch == 'R') a[++n] = 1;
		else a[++n] = -1;
		s[n] = s[n - 1] + a[n];
	}
	int ans = 0;
	for(register int i = 1; i <= n; ++i) {
		for(int j = 1; j < i; ++j)
			if(s[i] - s[j - 1] == 0) {//这一段前缀和为0证明这一个区间内数量相等
				ans = max(ans , (i - j + 1));//更新长度
				break;
			}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：bie淖_kkk (赞：2)

大概思路就是通过前缀和求出红珠子的数量  /用r[i]保存s[0]--s[i]间的R的个数/


然后循环，判断每一部分 (r[j]----r[i])


若符合红绿珠子相等的情况，判断所包含长度是否大于ans，大于就更新


(只求了R。 G利用总数减去求得)


代码如下：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char s[1000100];
int  ans,r[1000100];
int main()
{
    cin>>s;
    int l=strlen(s);
    if(s[0]=='R')r[0]=1;               //先处理r[0]
    for(int i=1; i<l; i++)
        if(s[i]=='R')r[i]=r[i-1]+1;
        else r[i]=r[i-1];              //前缀和
    for(int i=l-1; i>=0; i--)
        for(int j=0; j<i; j++)         //循环
        {
            if(s[j]=='R')
            {
                if(2*(r[i]-r[j]+1)==i-j+1) ans=max(ans,i-j+1);   
                //s[j]=='R'时，出现r[i]-r[j]多减去s[j]上的'R'的情况,所以+1
            }
            else if(2*(r[i]-r[j])==i-j+1)  ans=max(ans,i-j+1);   
        }
    cout<<ans;
    return 0;
}
```

---

## 作者：Victorique (赞：2)

其实我都不明白这个是怎么不超时的，是数据略水我预估错了么？

不说废话。

这个题看楼下题解dalao都用的是前缀和，这个题也的确是用前缀和要简单很多，主要思路就是把一种颜色的值定为1，另一种定为-1.不过在进行查找的时候方法就大相径庭了，楼下dalao方法可能对于蒟蒻比较深奥，这里使用一种比较简单的方法（但是遇到太坑的数据就过不了了，其实也可以有优化，不过太麻烦）。

主要思路是用f数组记录前缀和，当出现两个相同的前缀和时，就证明找到了一组两种宝石相等的策略，我们就更新maxx数组进行比较。

核心代码：

```cpp
                  if(f[j]-f[i]==0)
            {
                maxx=max(maxx,j-i);
                break;
            }
```
break的作用很大，不可或缺，虽然这个题好像没问题，但是自己手打的坑点就会严重超时。
AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int r[1000001],l,f[1000001],n,tot,sum,maxx;
char ch[1000001]; 
int main()
{
    cin>>ch;
    l=strlen(ch);
    for(int i=1;i<=l;i++)//必须从1开始循环，因为到后面要进行0的处理
    {
        if(ch[i-1]=='G')
        f[i]=f[i-1]+1;
        else
        f[i]=f[i-1]+(-1);
    }
    for(int i=0;i<=l/2;i++)
```
{//其实这里应该是可以有一个if的判断剪枝，但是本蒟蒻懒得写了
for(int j=l;j>=i;j--)//倒序循环，保证第一次找到的一定是最大的，然后接着break跳出，加快运行

```cpp
        {
            if(f[j]-f[i]==0)
            {
                maxx=max(maxx,j-i);
                break;
            }
        }
    }
    cout<<maxx;
}

```

---

## 作者：peterwuyihong (赞：1)

# 其实这道题可以用二分
二分答案长度，再字符串中操作即可
### 过程详见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000005];
int len,l=1,r;
bool check(int x)
{
	int R=0,G=0;//R,G都是0
	for(int i=1;i<=x;i++)
	R+=(s[i]=='R'),G+=(s[i]=='G');
   //初始字符串的R与G值
	if(R==G)return 1;//先判断一下
	for(int i=x+1,j=1;i<=len;i++,j++)
	{
		if(s[j]=='R')R--;
		if(s[j]=='G')G--;//去掉字符串头
		if(s[i]=='R')R++;
		if(s[i]=='G')G++;//加入字符串尾
		if(R==G)return 1;//成功直接退出
	}
	return 0;//不成功
}
int main()
{
	scanf("%s",s+1);
	len=strlen(s+1);
	r=len/2;//由于奇数不行,便二分偶数
	while(l<=r)
	{
		int mid=(l+r)>>1;
	//	printf("%d %d %d\n",l,mid,r);
		if(check(mid<<1))l=mid+1;
		else r=mid-1;
	}
	printf("%d",r<<1);//答案是2倍
}

```
算法复杂度$O(|S|\log\frac{|S|}2)$

---

## 作者：_•́へ•́╬_ (赞：1)

## 竟然你们不知道二分是一个好东西！
## 这题我就用二分做給你们看！
```cpp
#include<stdio.h>
#include<string.h>
int len,l,r,m;char α[1000001];
bool jg(int s)//判断当前二分得到的长度是否能够实现
{
	int sum=0;
	for(register int i=0;i<s-1;++i)sum+=α[i]=='G'?-1:1;//把G看成-1，R看成1，和为0时表示平衡
	for(register int i=s-1;i<len;++i)
	{
		sum+=α[i]=='G'?-1:1;
		if(sum==0)return 1;//成功！
		sum-=α[i-s+1]=='G'?-1:1;//因为是滚动的，所以要撤销很久以前的
	}
	return 0;
}
main()
{
	scanf("%s",α);len=strlen(α);//输入
	for(l=0,r=len/2*2/*防止len是奇数*/;l<=r;)
	{
		m=l+r>>1;
		if(m&1)++m;//奇数肯定不行
		if(jg(m))l=m+2;//成功，长度增加继续试
		else r=m-2;//失败，长度减少继续试
	}
	if(r==-2){puts("0");return 0;}//截不出来任何子串
	printf("%d",r);//输出
}/**/
```

---

## 作者：Eric_hoo (赞：1)

### 这是一道假的dp！！！

其实这道题前缀和+哈希简单过2333

我们把R当成-1, G当成+1。

如果$sum[i] = sum[j]$，就说明从(i，j]中$R$和$G$的个数相等。

我们只要扫一边数组，如果这个数没出现就在哈希数组里记下这个值，不然就用那个值来更新答案。

下面是代码（代码比较丑，将就着看看QwQ

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1000010];
int h[2000010];
int sum[1000010];

int main(){
	memset(h, 0x3f, sizeof(h));
	int n;
	string s;
	cin >> s;
	n = s.length();
	for (int i = 0; i < n; i++){
		if (s[i] == 'R') a[i + 1] = 1;
		else a[i + 1] = -1;
	}
	for (int i = 1; i <= n; i++){
		sum[i] = sum[i - 1] + a[i];
	}
	int ans = 0;
	h[n] = 0; //这是个坑点2333
	for (int i = 1; i <= n; i++){
		if (h[sum[i] + n] != 0x3f3f3f3f) ans = max(i - h[sum[i] + n], ans);
		else h[sum[i] + n] = i;
	}
	cout << ans << endl;
	return 0;
}

```
谢谢

---

## 作者：Miri (赞：1)

没想到这题这样居然能过……算暴力吧(⊙v⊙)？

思路：统计从位置0到位置i中绿珠子和红珠子的个数，然后双重循环的时候一减就能得到第i+1个珠子到第j个珠子之间红绿珠子的数量，如果相等，就输出j-i就好了

\*因为字符串是从0开始存的，所以珠子的个数（red[]和green[]）要存入i+1中，从1存到strlen(s)；

```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
int red[1000001],green[1000001];
int main() {
    char s[1000001];
    scanf("%s",s);
    int l=strlen(s),maxn=0;
    if(s[0]=='R') red[1]=1;
    else green[1]=1;
    for(int i=1; i<l; i++)
        if(s[i]=='R')
            red[i+1]=red[i]+1,green[i+1]=green[i];
        else
            red[i+1]=red[i],green[i+1]=green[i]+1;
    for(int i=l; i>=0; i--)
        for(int j=i; j<=l; j++)
            if(red[j]-red[i]==green[j]-green[i])
                maxn=max(maxn,j-i);
    printf("%d\n",maxn);
    return 0;
}
```

---

## 作者：Pine (赞：1)

# ”奇技淫巧“

预处理前缀

使用两个指针从两边开始扫 如果当前区间满足条件跳出

如果不满足 哪一种多删哪一种

由于存在一种情况两边都不是多的一种 那么就存在两种决策 所以到处两个答案取最优即可

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
char a[1000005 * 2];
int sum1[1000005 * 2], sum2[1000005 * 2];
int main()
{
    scanf("%s", a);
    int len = strlen(a);
    for (int i=1; i<=len; i++) 
        if (a[i-1] == 'G') sum1[i] = sum1[i-1] + 1, sum2[i] = sum2[i-1];
        else sum1[i] = sum1[i-1], sum2[i] = sum2[i-1] + 1;
    int l = 1, r = len;
    while(l <= r)
    {
        int k1 = sum1[r] - sum1[l-1], k2 = sum2[r] - sum2[l-1];
        if (k1 == k2) break;
        else if (k1 > k2) 
        {
            if (a[l-1] == 'G') l++;
            else if (a[r-1] == 'G') r--;
            else r--;
        }
        else if (k1 < k2)
        {
            if (a[l-1] == 'R') l++;
            else if (a[r-1] == 'R') r--;
            else r--;
        }
    }
    int ans = r - l + 1;
    l = 1, r = len;
    while (l <= r)
    {
        int k1 = sum1[r] - sum1[l-1], k2 = sum2[r] - sum2[l-1];
        if (k1 == k2) break;
        else if (k1 > k2) 
        {
            if (a[l-1] == 'G') l++;
            else if (a[r-1] == 'G') r--;
            else l++;
        }
        else if (k1 < k2)
        {
            if (a[l-1] == 'R') l++;
            else if (a[r-1] == 'R') r--;
            else l++;
        }
    }
    ans = max(ans, r - l + 1);
    printf("%d\n", ans);
    return 0;
}
```

---


# [HAOI2009] 巧克力

## 题目描述

有一块 $n \times m$ 的矩形巧克力，准备将它切成 $n \times m$ 块。巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\cdots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\cdots,x_{m-1}$。

例如，对于下图 $6 \times 4$ 的巧克力，我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4 \times (x_1+x_2+x_3+x_4+x_5)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/juiv548x.png)


当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？


## 说明/提示


$30\%$ 的数据，$n \leq 100,m \leq 100$；

$100\%$ 的数据，$n \leq 10000,m \leq 10000$；

## 样例 #1

### 输入

```
6 4
2
1
3
1
4
4
1
2```

### 输出

```
42```

# 题解

## 作者：FwbAway (赞：21)



不要在意是横着还是竖着，都是要切的，但横竖又是都需要切的，所以我们用两个数组来记录代价和这个代价到底是横着切的还是竖着切的。用一个变量 sum 来记录横着切的力气和竖着切的力气，然后就是相乘后累加，推一遍样例就好了。


```c++
#include<iostream>
#include<cstdio>
using namespace std;
size_t a[10010],b[10010],sum=0,n,m;
int main() {
	cin>>n>>m;
	n--,m--;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
		sum+=b[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			sum+=min(a[i],b[j]);
		}
	}
	cout<<sum<<endl;
	return 0;
}
```


---

## 作者：Tarsal (赞：17)

本蒟蒻又双叒叕被爆踩辣！

又是一道经典的[贪心题](https://www.luogu.org/problem/P3173)：
```
那么怎样切割该块巧克力，花费的代价最少呢？
```

**Solution：**

窝们考虑每个状态，有多少种选择方法？

是不是可以选择横着切或者竖着切，就这两种方法吧；

窝们再来考虑这两种方法的代价，

首先，如果窝们准备横着切，那么此次处理的代价就是当前这次的代价*（已经竖着切的数量 + 1），因为已经竖着切出了这么多次，所以代价就是这个(那个+1的原因是巧克力本来就有一块好不好，切一次不就有两块辣。。。）

```
ans += q.top() * s2;//那么当前的代价就是s2次乘单次代价 
```

那么如果窝们现在准备竖着切，那么是不是同理就可以推出当前这次的代价*（已经横着切的数量 + 1），因为已经横着切出了这么多次，所以代价就是这个(那个+1的原因是巧克力本来就有一块好不好，切一次不就有两块辣。。。）

```
ans += qq.top() * s1;//那么当前的代价就是s1次乘单次代价
```

那么窝们已经知道了两种方案的代价辣，窝们接下来就是要找最优方案辣：

窝们每次都比较两种方案，看那种更优窝们就选哪种方案

因为窝们每次都选择当前最优，所以窝们也同时可以保证全局最优！

Code：

```
#include<bits/stdc++.h>

using namespace std;

#define Rep(x, a, b) for(int x = a; x <= b; ++ x)

priority_queue<int> q, qq;//优先队列可以维护序列单调性 
//q表示横着切，qq表示竖着切 

int n, m, x, s1 = 1, s2 = 1, ans;
//s1表示已经横着切了多少次辣 
//s2表示已经竖着切了多少次辣 
//ans就是答案辣 

int main(){
	scanf("%d%d", &n, &m);
	Rep(i, 1, n - 1){//因为切成n*m块，所以横着切n - 1次 
		scanf("%d", &x);//读入每次代价 
		q.push(x);//压入优先队列，维护其单调性 
	}
	Rep(i, 1, m - 1){//同理，竖着切m-1次 
		scanf("%d", &x);//读入每次代价
		qq.push(x);//压入优先队列，维护其单调性
	}
	while(! q.empty() && ! qq.empty()){//只要一个优先队列空了就要退出，因为如果有一个空了，那么它的top就会返回空，然后就会死循环。。 
	//找当前是竖着切更优还是横着切更优
		if(q.top() > qq.top()){//如果是横着切更优 
			ans += q.top() * s2;//那么当前的代价就是s2次乘单次代价 
			++ s1;//记得更新s1的值，多了一份 
			q.pop();//已经切完的就要弹出 
		}
		else{
			ans += qq.top() * s1;//那么当前的代价就是s1次乘单次代价
			++ s2;//记得更新s2的值，多了一份
			qq.pop();//已经切完的就要弹出
		}
	}
	//因为弹出来后只要一个方向是空，那么就只能去另一个方向辣，下面就是找哪一个不是空的 
	while(! q.empty()){//如果可以横着切，（好像也只能横着切 
		ans += q.top() * s2;// 那么当前的代价就是s2次乘单次代价 
		q.pop();//已经切完的就要弹出 
		++ s1;//这里可加可不加辣，因为qq已经空了，s1就没用了 
	}
	while(! qq.empty()){//如果可以竖着切，（好像也只能竖着切  
		ans += qq.top() * s1;//那么当前的代价就是s1次乘单次代价
		qq.pop();//已经切完的就要弹出 
		++ s2;//同上辣 
	}
	printf("%d", ans);//输出 
	return 0;
}
```
[AC1](https://www.luogu.org/record/24357536)

修改一下：下面放一个对新人友好一点代码，思路差不多，不过注释较少

```cpp
#include<bits/stdc++.h>

using namespace std;

int n, m, ans, s1 = 1, s2 = 1;

#define maxn 20010
#define Rep(x, a, b) for(int x = a; x <= b; ++ x)

struct node{
    int v, c;
}e[maxn];

bool cmp(node a, node b){
	return a.v > b.v;
}

int main(){
	scanf("%d%d", &n, &m);
	Rep(i, 1, n - 1){//因为切成n*m块，所以横着切n - 1次 
		scanf("%d", &e[i].v);
		e[i].c = 0;//把其标记为0 
	}
	Rep(i, n, n + m - 2){//同理，竖着切m-1次 
		scanf("%d", &e[i].v);
		e[i].c = 1;//把其标记为1 
	} 
	sort(e + 1, e + n + m - 1, cmp);
	Rep(i, 1, n + m - 2){
		if(e[i].c == 0){
			ans += e[i].v * s2;
			++ s1;
		}
		else{
			ans += e[i].v * s1;
			++ s2;
		}
	}
	printf("%d", ans);
	return 0;
}
```

[AC2](https://www.luogu.org/record/24358233)

~~Ps：请看懂再抄~~

---

## 作者：g_ws (赞：12)

~~~~看到这道题可能想这个巧克力真惨  呜呜呜呜呜呜
------------
这道题看起来没思路 emmmmm;
------------
实际用贪心；
心里怎么想咋么打；
就先排序，在从大到小切，横着切竖着的+1，竖着切横着的+1；
# 注意乘上权值# 
------------
献上我蜂窝似的dai码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct lp
{
    int v;
    int c;
}x[20086];//数组也可以，自己试试； 
bool cmp(lp a,lp b)
{return a.c>b.c;}//结构体比较要定义 
int main(){
    int a,b,f=1,d=1;
    cin>>a>>b;
    for(int i=1;i<=a-1;i++) {
    cin>>x[i].c;
    x[i].v=0;	
    }
    for(int i=a;i<=a+b-2;i++){
    cin>>x[i].c;
    x[i].v=1;	
    }
    int res=0;
    sort(x+1,x+a+b+1,cmp);
    for(int i=1;i<=a+b-2;i++){
        if(x[i].v==0) {
            res=res+x[i].c*d;//如上面描述 
            f++;
        }
        if(x[i].v==1){
            res=res+x[i].c*f;
            d++;
        }
    } 
    cout<<res;
}
```
求过&赞

---

## 作者：kkxhh (赞：12)

这题应该用贪心做

简单的证明一下贪心策略

对于每一个竖着切的操作，它的代价为 **它本身的代价&times;(目前横着切的刀数+1)** ，显然越后操作要乘的数也就越大，所以为了让总花费最低，相同类型的操作应该将**花费大的放前面**。

那如果类型不同呢？考虑两个紧挨着的横着切的操作**a**和竖着切的操作**b**。假设在这两刀之前已经竖着切的次数为 **s1** ，横着切的次数为 **s2** 。那么优先操作**a**时的花费就是 **(s1+1)&times;costa+(s2+2)&times;costb** ，优先操作**b**时的花费则是 **(s1+2)&times;costa+(s2+1)&times;costb** ，化简后得出先操作**a**更优的前提是 **costa>costb** ，于是我们可以得出，无论是横着还是竖着，只需要优先操作花费大的就行了。

代码方面是用优先队列实现的

```cpp
#include <cstdio>
#include <queue>
using namespace std;

priority_queue<int> q1,q2;
int n,m,s1=1,s2=1,sum=0;

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?-1:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return num*k;
}

int main() {
    n=read(); m=read();
    for(int i=1;i<=n-1;i++) q1.push(read());
    for(int i=1;i<=m-1;i++) q2.push(read());
    while(!q1.empty() && !q2.empty()){
        if(q1.top()>q2.top()) {sum+=q1.top()*s2,s1++; q1.pop();}
        else {sum+=q2.top()*s1,s2++; q2.pop();}
    }
    while(!q1.empty()) {sum+=q1.top()*s2; q1.pop();}
    while(!q2.empty()) {sum+=q2.top()*s1; q2.pop();}
    printf("%d",sum);
    return 0;
}
```

---

## 作者：Cyxhsa (赞：5)

这道题我是按照贪心写的,解题思想在于从大到小排列所有代价，别管是横着还是竖着，都是要排的，但横竖又是必不可少的，所以我们用一个结构体来记录代价和这个代价到底是横着切的还是竖着切的。用一个数组c[2]来分别记录横着切了几次和竖着切了几次，然后就是相乘后累加，关于这个，建议还是推一遍样例为好

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <ctime>
#include <functional>
using namespace std;
int n,m,i,ans;
int c[2];
struct lp
{
    int v;
    int c;
}a[20086];
bool cmp(lp a,lp b)
{return a.v>b.v;}
int main()
{
    cin>>n>>m;
    n--;m--;
    memset(c,0,sizeof(c));
    for(i=1;i<=n;i++)
    {cin>>a[i].v,a[i].c=0;}
    for(i=n+1;i<=n+m;i++)
    {cin>>a[i].v,a[i].c=1;}
    sort(a+1,a+n+m+1,cmp);
    for (i=1;i<=n+m;i++)
    {
        c[a[i].c]++;
        if(a[i].c==0)
            ans+=a[i].v*(c[1]+1);
        if(a[i].c==1)
            ans+=a[i].v*(c[0]+1);
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：翼德天尊 (赞：4)

**我又来 ~~水~~ 题解了！**


------------
### STEP 1 条件整理

1.对一个长方形横着切n刀，竖着切m刀；

2.每一刀都要花费一定的代价；

3.如果巧克力从一个方向切了w块，那么从另一个方向切的时候就要花费w*$x_i$的代价；

4.问最小代价是多少。


------------
### STEP 2 题意分析

看见STEP 1里的条件4没有？盯着他看，~~使劲看~~！求最小啊！最优问题用什么？**贪心！**

(以下公式均用h表示横着切，s表示竖着切，V表示代价，Z表示已切刀数）则公式有：

$$V_h=h_i* Z_s$$
$$V_s=s_i* Z_h$$

所以我们可以发现，越是靠后切，所要切的代价的倍数就越大，导致整体代价的上升。

**贪心解决方案：** 代价高的考前切，代价小的靠后切。

------------
### STEP 3 AC代码及完整注释
```
#include<bits/stdc++.h>//万能头棒棒
using namespace std;
int n,m,nh=1,ns=1;//分别记录n,m以及已切过的横刀数以及竖刀数
long long ans;//记录答案
struct node{
	int w,h;
}c[20001];//储存每一刀的结构体，w为代价，h为刀是横着切还是竖着切
int cmp(node x,node y){
	return x.w>y.w;
}//排序，从大到小
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n-1;i++){
    	scanf("%d",&c[i].w);
	}
	for (int i=n;i<=n+m-2;i++){
		scanf("%d",&c[i].w);
		c[i].h=1;//标记
	}//输入
	sort(c+1,c+n+m-1,cmp);//排序
	for (int i=1;i<=n+m-2;i++){
		if (c[i].h==0){
			ans+=c[i].w*ns;
			nh++;
		}else{
			ans+=c[i].w*nh;
			ns++;
		}
	}//执行公式
	printf("%lld\n",ans);//输出
    return 0;//好习惯++
}

```
------------
### STEP 4 完结撒花！

本篇题解就这么愉快地结束啦！



---

## 作者：Mark_ZZY (赞：2)

/\*
x                 y

设va>vb




```cpp
x++;              y++;
ans+(y+1)*va;   ans+(x+1)*vb;
y++;              x++;
ans+(x+1)*vb;   ans+(y+1)*va;
ans+(y+1)*va+(x+2)*vb    -    ans+(x+1)*vb+(y+2)*va
               vb-va<0
```
综上所述,为了使答案更小,应选va


行               列

x                 y










```cpp
x++;              y++;
ans+(y+1)*value;   ans+(x+1)*value;
y++;              x++;
ans+(x+1)*value;   ans+(y+1)*value;
ans+(y+1)*value+(x+2)*value
=ans+y*value+value+x*value+2*value
=ans+(x+y)*value+3value
ans+(x+1)*value+(y+2)*value
=ans+x*value+value+y*value+2*value
=ans+(x+y)*value+3value
```
综上所述,在价值相等时,先切行和先切列是一样的
\*/
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
    int n,m,x=0,y=0,ans=0;
    struct node{int x,y;} a[20001];
bool cmp(node _a,node _b)
{
    return _a.x>_b.x;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<n;i++)
    {
        scanf("%d",&a[i].x);
        a[i].y=1;
    }
    for(int i=n;i<=n+m-2;i++)
    {
        scanf("%d",&a[i].x);
        a[i].y=2;
    }
    sort(a+1,a+n+m-2+1,cmp);
    for(int i=1;i<=n+m-2;i++)
        if(a[i].y==1)
        {
            x++;
            ans+=a[i].x*(y+1);
        }
        else
        {
            y++;
            ans+=a[i].x*(x+1);
        }
    printf("%d",ans);
}
```

---

## 作者：Kiloio (赞：0)

## 简述题意：  
将一个 $ n \times m $ 切割成  $ 1 \times 1 $ 的小方块。  

有 $ n - 1 $ 和 $ m - 1 $ 线可以切，每条线有**对应的权值**（代价）。求**最小**的代价。   

## 题目分析：  
要切成  $ 1 \times 1 $ 的小方块，**每条线是都要切的**。  

要最小代价，每条线也都要切，那就从切得顺序入手。  
  
假设一个矩阵，红色的**水平线**是先要切的：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gqkwjg0l.png)  
  
切了过后，如果我们还要切**竖直**的蓝线，我们就要多切一次。  
![](https://cdn.luogu.com.cn/upload/image_hosting/vdqqktg2.png)  
  
这时我们就可以发现一个规律了：  
  
**每切一条水平线，所有还没切的竖直线都要多切一次。**   
  
**每切一条竖直线，所有还没切的水平线都要多切一次。**   
  
可以根据这个制定贪心策略。为了使代价**最小**，我们就要避免多切**代价大**的线。  
  
每次切的时候，**优先切最大**的线。累计算代价的时候，考虑需要多切几次。  
  
切**水平线**的时候，代价要算上**多切的值**（有所切的**竖直线决定**）  
  
同时下次切**竖直线**时，因为有这次的操作，要多切一次。竖直线操作相同。  
  
## 代码：    
```
#include <bits/stdc++.h>
using namespace std;
long long n,m,a[100005],b[100005],sumi=1,sumj=1,ans;
//我的sumi、sumj是记录的要切的次数，不是多切的次数，所以初始值要为1。 
bool cmp(int x,int y){
	return x>y;
}
int main(){
	cin>>n>>m;
	n--,m--;
	//对于n*m的矩阵，内部只有n-1和m-1条线 
	for(int i=1; i<=n; i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1; i<=m; i++){
		scanf("%lld",&b[i]);
	}
	//优先切最大，要排序。从大到小排 
	sort(a+1,a+1+n,cmp);
	sort(b+1,b+1+m,cmp);
	while(sumi<=n && sumj<=m){
		if(a[sumi]>b[sumj]){
            ans+=a[sumi]*sumj,sumi++;
        }
        else{
        	ans+=b[sumj]*sumi,sumj++;
		}
	}
	//上面一个while循环的条件是 sumi<=n && sumj<=m，有可能会有竖直或水平线还没切。 
	while(sumi<=n){
    	ans+=a[sumi]*sumj,sumi++;
	}
    while(sumj<=m){
    	ans+=sumi*b[sumj],sumj++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：BADFIVE (赞：0)

**题意**: 把一个长 $n$ 宽 $m$ 的矩形，切割成长 $1$ 宽 $1$ 的正方形，每条切割线都有相应的代价，求最小的代价是多少。  
**思路**: 很明显这是一道贪心的题目，要让总代价最小，所以局部代价也要最小。   
切完一条线过后，剩下的矩形需要多切一次。一共要切 $n \ast m -1$ 次，如下图：    
![](https://cdn.luogu.com.cn/upload/image_hosting/o62z3fyx.png?x-oss-process=image/resize,m_lfit,h_570,w_625)   
因为每条线的代价都不一定是相同的，所以我们需要先切代价最高的线。   
记录这个矩形横着切了多少次和竖着切了多少次。

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}a[100001];
bool cmp(node a1,node b1){
    return a1.x>b1.x;
}
int main(){
	int n,m,x=0,y=0,ans=0;
    cin>>n>>m;
    for(int i=1;i<n;i++){
    	cin>>a[i].x;
        a[i].y=1;
    }
    for(int i=n;i<=n+m-2;i++){
        cin>>a[i].x;
        a[i].y=2;
    }
    sort(a+1,a+n+m-1,cmp);
    for(int i=1;i<=n+m-2;i++){
    	if(a[i].y==1){
            x++;
            ans+=a[i].x*(y+1);
        }
        else{
            y++;
            ans+=a[i].x*(x+1);
        }
	}
    cout<<ans;
}
```

---

## 作者：MSqwq (赞：0)

这是道贪心的题目  
然后双倍经验：[P1324 矩形分割](https://www.luogu.com.cn/problem/P1324)  
题意就是有一块 $n \times m$ 的矩形，我们最后要把它分成 $1 \times 1$ 的小矩形块，对于每一条分割线有一个代价 $w$ ，注意不能把多个已经分割的矩形块合起来切。  
题意还是比较清晰明了，简单说一下思路啊，稍微思考一下，很容易证明每一个代价都必须分只是分多少次的问题，然后分析发现先分的分的次数更少，所以优先分大的，如果横着分一次，那么竖着就要多分一次，竖着分同理，所以直接排个序再处理一下就好了....  
代码如下： 
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int N=1e5;
int n,m;
ll ans;
int x,y;
struct MS{
    int op,x;
}a[e];
int tot;
bool cmp(MS x,MS y){return x.x>y.x;}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n-1;i++)
    {
        int x;
        scanf("%d",&x);
        a[++tot].x=x;
        a[tot].op=1;
    }
    for(int i=1;i<=m-1;i++)
    {
        int x;
        scanf("%d",&x);
        a[++tot].x=x;
        a[tot].op=0;
    }   
    sort(a+1,a+1+tot,cmp);
    for(int i=1;i<=tot;i++)
    {
        if(a[i].op==1)ans+=x*a[i].x,y++;
        else ans+=y*a[i].x,x++;
    }
    printf("%lld",ans);
}
```


---

## 作者：czkxiaokeai (赞：0)

# 贪心+递归+前缀和+st表查询区间最值（减小时间复杂度O w O

发现代码比较可读www

~~话说时间复杂度还是挺高~~

注释在代码里挺详细~~

然后就上代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register int
using namespace std;

const int maxn=1e5+5,Maxlog=17;
int n,m,ans=0;
int sn[maxn],sm[maxn];    //前缀和 
int fn[maxn][Maxlog+1],fm[maxn][Maxlog+1],Log[maxn];  //st表 

inline int read()  //快读 
{
	int ans=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		ans=ans*10+c-'0',c=getchar();
	return ans;
}

inline void Prework()  //对m,n分别造表w (不会请见p3865) 
{
	Log[1]=0;
	for(int i=2;i<=maxn;i++)
		Log[i]=Log[i/2]+1;
		 
	int maxlog=Log[n]+1;
	for(int i=1;i<=maxlog;i++)
		for(int j=1;j+(1<<(i-1))<=n;j++)
			fn[j][i]=max(fn[j][i-1],fn[j+(1<<(i-1))][i-1]);
	 
	maxlog=Log[m]+1;
	for(int i=1;i<=maxlog;i++)
		for(int j=1;j+(1<<(i-1))<=m;j++)
			fm[j][i]=max(fm[j][i-1],fm[j+(1<<(i-1))][i-1]);
	
	return;
}

inline int qn(int l,int r)  //n 区间最值O(1)查询 
{
	int len=Log[r-l+1];
	return max(fn[l][len],fn[r-(1<<len)+1][len]);
}

inline int qm(int l,int r)  //m 区间最值O(1)查询 
{
	int len=Log[r-l+1];
	return max(fm[l][len],fm[r-(1<<len)+1][len]);
}

inline void cut(int x1,int y1,int x2,int y2)  //递归 
{
	if(x2-x1==1)           //如果是单条，就一刀刀切开 
	{ ans+=sm[y2-1]-sm[y1]; return; }
	if(y2-y1==1)           //同上 
	{ ans+=sn[x2-1]-sn[x1]; return; }
	
	int nm=qn(x1+1,x2-1),mm=qm(y1+1,y2-1),ni,mi;  //n,m 最值找粗来 
	for(re i=x1+1;i<x2;i++)      //最值位置 
		if(fn[i][0]==nm)
		{ ni=i;break; }
	for(re i=y1+1;i<y2;i++)      //最值位置
		if(fm[i][0]==mm)
		{ mi=i;break; }
		
	//贪心思想：花钱多下刀处的趁着巧克力大的时候先切了,
	//			不然后面切会多切多花钱(推推样例以更好理解... 
	
	if(nm>mm)  //横着切 
	{ ans+=nm; cut(x1,y1,ni,y2); cut(ni,y1,x2,y2); }
	else       //竖着切 
	{ ans+=mm; cut(x1,y1,x2,mi); cut(x1,mi,x2,y2); }
	return;
}

int main()//从这儿看 
{
	n=read();m=read();
	n++;m++;
	for(re i=2;i<n;i++) //输入,处理前缀和 
		fn[i][0]=read(),sn[i]=fn[i][0]+sn[i-1];
	for(re i=2;i<m;i++) //输入,处理前缀和
		fm[i][0]=read(),sm[i]=fm[i][0]+sm[i-1];
	Prework();          //st表预处理 
	cut(1,1,n,m);       //开始递归 
	cout<<ans;
	return 0;
} 
```

那么你就阔以再A一道题辽



---


# 海底高铁

## 题目描述

该铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1\leq i<N)$。如果搭乘的比较远，需要购买多张车票。第 $i$ 段铁路购买纸质单程票需要 $A_i$ 博艾元。

虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了 IC 卡。对于第 $i$ 段铁路，需要花 $C_i$ 博艾元的工本费购买一张 IC 卡，然后乘坐这段铁路一次就只要扣 $B_i(B_i<A_i)$ 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 IC 卡，无法乘坐别的铁路的车。

Uim 现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\cdots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。

现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。

## 说明/提示

$2$ 到 $3$ 以及 $8$ 到 $9$ 买票，其余买卡。

对于 $30\%$ 数据 $M=2$。

对于另外 $30\%$ 数据 $N\leq1000，M\leq1000$。

对于 $100\%$ 的数据 $M,N\leq 10^5，A_i,B_i,C_i\le10^5$。

## 样例 #1

### 输入

```
9 10
3 1 4 1 5 9 2 6 5 3
200 100 50
300 299 100
500 200 500
345 234 123
100 50 100
600 100 1
450 400 80
2 1 10```

### 输出

```
6394```

# 题解

## 作者：NKU_AI_HMX (赞：280)

#### 题目很好理解，就是按照我们的方法会爆，大家看了那么多题解应该也知道为什么了，笔者在这里推荐一道题，大家可以去试试，二维差分——[地毯](https://www.luogu.com.cn/problem/P3397)。

### 我们步入正文：

### 先来个故事：

我们在一遍遍覆盖的方法肯定是行不通的，那么有什么办法能不用经过一段铁路就把每个城市都加一遍1吗？当然是有的。

大家不妨想一想，我们在马路上会有警示牌啥的，告诉你前面是弯路，前面容易发生交通事故，~~前方容易遇见自己的未来女友~~......

但是警示牌不会在那一整段路上都插满（每毫米插一个？），他也只是在你将要进入那个路段，给你一个警示，然后我们自己就会在那一整段路上都注意（有没有未来女友），然后我们开过那段路之后，你就能差不多知道那段路已经过了（到了基友家）。

比如路牌说前方急转弯，好，当接着100m都是直路这时候我们就知道开过了，我们就不会受刚才的路牌影响，而是被下一个路牌影响，比如直路上有个路牌说“前方直路，小心开车过快，导致翻车” 接下来你就会在那一整段直路上注意，而不需要那一整段路上都给你插满“前方直路，小心开车过快，导致翻车”这个标语（老司机从不翻车）。

而这道题也是一样的。为什么我们要给经过的每个城市都加1呢？我们就不能也设置一个路牌吗？告诉计算机，接下来的一段铁路被经过了几次，然后在结束的时候再告诉他，结束了，你等待下一个路牌的指示，让下一个路牌告诉你下一段经过了几次。

#### 我想这就是这题的思想

由于我们是正着遍历的，所以当你从数字较大的城市到小的城市，数字大的减一，小的加1，这样我们经过小的城市的时候我们就知道接下来的那段铁路是被经过了多少次，而到了减一的城市之后接下来经过的铁路就不受刚才路牌的影响，因为原来加的被减了呀。

所以关键在于如何构建路牌，这是一维的构建方法，二维也有他的构建方法，而且对于二维而言，路牌的作用就更加显著了。


好！说了那么多，接下来给大家代码吧，相信大家听懂这个故事以后，代码完全可以自己敲一下了，建议大家自己敲，这样可以发现一些问题（记得统计最后结果的时候开long long）谢谢大家阅读。

```cpp
#include<iostream>
using namespace std;
char ch;
template<class T>
inline void rd(T& x) {//快读不解释了哈
    x = 0; int w = 1;
    ch = getchar();
    while (ch < '0' || ch>'9') {
        if (ch == '-')w = -1; ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    x = x * w;
}
int a[100001];  unsigned long long t ,sum;
int main()
{
    int n, m,x,y,z;
    rd(n), rd(m);
    rd(x);
    for (int i = 2; i <= m; i++)
    {
        rd(y);//这个循环是安装路牌的过程
        if (x < y) 
        {
            a[x]++;
            a[y]--;
        }
        else
        {
            a[x]--;
            a[y]++;
        }
        x = y;
    }
  
    for (int i = 1; i < n; i++)
    {
        t += a[i];
        rd(x),rd(y),rd(z);
        sum += t * y + z < t * x ? t * y + z : t * x; //这一块决定是不是买卡
        
    }
    cout << sum;
    return 0;
}
```

#### 大家可以给一个赞吗？谢谢了。



---

## 作者：kkksc03 (赞：277)

对于其中一小段，我们要么全部买纸票，要么全部刷卡。

所以我们只需要统计每一小段经过的总次数。

如果你暴力模拟统计的话，估计会tle。

怎么快速知道每一段次数呢？

我们回忆一下“借教室”这道题。

如果你高兴的话，可以上线段树或者树装数组——但是没必要。

假设有5段，我们把1到3加上1，可以像图2一样，开头+1，结尾-1。然后2到4加1，如图3.

```cpp
                  +1      -1          +1 +1   -1 -1
 - - - - -        --  - - -- -        -- -- - -- --
 1 2 3 4 5        1   2 3 4  5        1  2  3 4  5
 图1              图2                 图3
```

然后呢，我们求出每一项前缀和（就是从前往后加）：

```cpp
1 2 2 1 0
- - - - -
1 2 3 4 5
图4
```

然后每一段直接贪心比较，然后就没有然后了。


---

## 作者：__int (赞：89)

本题可以使用差分数组和前缀和求出每一段需要经过的次数
再用贪心策略在2种买票方式中选择 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,c[100005],p2,p1,a,b,c1;
long long sum,ans;
int main()
{
	cin>>n>>m;
	if(m>0)cin>>p1;
	for(int i=2;i<=m;i++)
	{
		cin>>p2;
	 	if(p1<p2)c[p1]++,c[p2]--;
	 	else c[p2]++,c[p1]--;
	 	p1=p2;
	}
	for(int i=1;i<n;i++)
	{
		sum+=c[i];
		cin>>a>>b>>c1;
		if(sum!=0)ans+=min(a*sum,b*sum+c1);
	}
	if(m<=1)ans=0;
	cout<<ans;
	return 0;
}
```


---

## 作者：zcysky (赞：60)

//如题，就是一个前缀和思路，没什么好说的。

//直接前缀和不知道为什么总是tle，怒而卡常，居然过了……

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define LL unsigned long long
using namespace std;
int n,m;
LL ans=0,x,y;
long long  a,b,c,p[100001],val[100001];
inline long long read(){
    long long x=0,f=1;
    char ch;
    ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch='-')f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline LL Min(LL x,LL y){
    if (x<y)return x;
    else return y;
}
inline LL Max(LL x,LL y){
    if (x>y)return x;
    else return y;
}
int main(){
    n=read();
    m=read();
    for (register int i=1;i<=m;++i)p[i]=read();
    memset(val,0,sizeof(val));
    for (register int i=1;i<m;++i){
        x=Max(p[i],p[i+1]);
        y=Min(p[i],p[i+1]);
        val[y]++;
        val[x]--;
    }
    for (register int i=1;i<=n;++i)val[i]+=val[i-1];
    for (register int i=1;i<n;++i){
        a=read();b=read();c=read();
        ans+=Min(a*val[i],b*val[i]+c);
    }
    cout<<ans;
}
```

---

## 作者：Sirius墨狼 (赞：42)

## 题目链接：[P3406 海底高铁](https://www.luogu.org/problem/P3406)

第一眼看到这题时，我先想到的是暴力贪心，直接记录每段路路过的次数，然后判断值不值得办卡，最后累加输出。所以想都没想就直接打了，然后轰轰烈烈地TLE了3个点。。。qwq

------------

```cpp
for(i=2;i<=m;i++)
{
	for(j=min(p[i-1],p[i]);j<max(p[i-1],p[i]);j++)
	{
		ans[j]++;
	}
}
for(i=1;i<=n;i++)
{
	s+=min(b[i]*ans[i]+c[i],a[i]*ans[i]);
}
cout<<s<<endl;
```


------------

重新理一下思路，发现这样写算次数时间复杂度太大，第一个for循环时间复杂度为O(m*总路程)，在总路程过大的情况下就会TLE，所以必须优化一下，如第一篇题解所说，用前缀和来优化统计，时间复杂度立马就降了下来

------------

```cpp
for(i=1;i<=m-1;i++)
{
	ans[min(p[i],p[i+1])]++;//对于每一段路程，开头+1，结尾-1
	ans[max(p[i],p[i+1])]--;
}
for(i=1;i<=n;i++)
ans[i]+=ans[i-1];//然后求出每一项的前缀和
```

------------

同理[P1083 借教室](https://www.luogu.org/problem/P1083)，将每一段路程的开头+1，结尾-1，注意前后两站的顺序并不是按照大小排列的，所以需要判断一下大小，然后累加即可求出每一项的前缀和，这样只要跑一遍m跑一遍n即可，时间上优化了太多了

------------
然而我又双叒叕没过，70分，最后三个点WA了，找了半天才发现我ans数组没开long long。。。qwq

------------
讲了这么多，也该上代码了呢，（25行的简洁代码~）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int p[100005],a[100005],b[100005],c[100005];
long long s,ans[100005];//前缀和必须用long long，不然最后三个点会WA 
int main()
{
	int n,m,i;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	cin>>p[i];
	for(i=1;i<n;i++)
	cin>>a[i]>>b[i]>>c[i];
	for(i=1;i<=m-1;i++)//对于每一段路程，开头+1，结尾-1标记一下 
	{
		ans[min(p[i],p[i+1])]++;
		ans[max(p[i],p[i+1])]--;
	}
	for(i=1;i<=n;i++)//然后累加求出每一项的前缀和 
	ans[i]+=ans[i-1];
	for(i=1;i<n;i++)//判断买票和办卡哪个便宜，算出总花费  
	s+=min(a[i]*ans[i],(b[i]*ans[i]+c[i]));
    cout<<s<<endl;//输出总价 
    return 0;//完结撒花~  
}
```


---

## 作者：Minakami_Yuki (赞：23)

### 题目链接:[P3406 海底高铁](https://www.luogu.org/problemnew/show/P3406)

### 题目分析:

​	~~（第一眼以为是最短路）~~ 这道题作为前缀和的练习挺不错的，因为它**几乎不涉及其他算法**。

​	首先根据题目中的信息进行数据读入：~~不开long long见祖宗（这题貌似不会）~~

```cpp
	ll n,m,ans=0;//共N个城市,途经M个城市
	scanf("%lld%lld",&n,&m);
	ll p[m+1];//访问顺序
	ll t[n+1]={};//经过次数,一定要初始化！
	ll a[n+1],b[n+1],c[n+1],x,y;//a[i]纸质单程票,b[i]办卡后的优惠价,c[i]办卡工本费
	for(ll i=1;i<=m;i++)
		scanf("%lld",&p[i]);
	for(ll i=1;i<=n-1;i++)
		scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
```

​	由于**第i段铁路连接了城市i和城市i+1**，所以**任意两个相邻的站点购买同种车票有且仅有一种费用**，也就是说，价格仅与在某相邻两站之间的**通过次数**有关。此时，我们就将问题转化为**求在给定路线下，每相邻两个站点路段的经过次数.**

​	那么，在出发之前，我们可以将每两站之间路段的经过次数**全部初始化为0**，然后，对每次给定的始发站和终到站，将其视作给定区间的两个端点，对此区间进行**区间增**操作。

#### 	如何进行区间增呢？？？

 	首先这是给定的四个站点

![](https://i.loli.net/2018/12/15/5c14bd30327be.png)

​	如果我们按照1-3,3-2,2-4,4-3的顺序访问，可以发现四个站点间的路径经过次数是这样的：

| 路径 | 1-2  | 2-3  | 3-4  |
| ---- | ---- | ---- | ---- |
| 次数 | 1    | 3    | 2    |

​	一般的思路是，对于每个区间，用一个for对其所经次数++，然而我们发现，**太慢了**。

​	于是我们想到了**前缀和**：

对于每一个区间，我们可以在其**左端点**加上区间增的权值，再在**右端点+1**的位置减去区间增的权值，最后对该区间进行求前缀和操作。这样，我们可以得到一样的结果。

#### 	回到题目中

​	恍然大悟，对于每组给定的区间端点，也可以使用同样的方法。更方便地，我们可以在对所有区间端点处理完毕后，在进行求前缀和操作：

```cpp
	//由于给定的信息是端点（城市），但是要求的是区间（路段），所以循环次数应为城市数-1
	for(ll i=1;i<=m-1;i++){
        //对于端点的处理，要严格满足数学上的定义，小的在左端点，大的在右端点
        //否则对于逆序信息，就相当于进行了区间减操作
		if(p[i]>p[i+1]){
			x=p[i+1];
			y=p[i];
		}
		else{
			x=p[i];
			y=p[i+1];
		}
        //上面的代码可以简写为:
	    //x=min(p[i],p[i+1]);
        //y=max(p[i],p[i+1]);
		t[x]++;//左端点增
		t[y]--;//右端点减
	}
//求前缀和
	for(ll i=1;i<=n;i++){
		t[i]+=t[i-1];
	}
```

​	最后，对于每一段路径，总价值加上该段路径费用的较小值。

```cpp
	for(ll i=1;i<=n-1;i++)
		ans+=min(a[i]*t[i],(b[i]*t[i]+c[i]));
```

​	本题就解决啦！

### 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#define ll long long
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
using namespace std;
int main(){
	ll n,m,ans=0;
	scanf("%lld%lld",&n,&m);
	ll p[m+1];
	ll t[n+1]={};
	ll a[n+1],b[n+1],c[n+1],x,y;
	for(ll i=1;i<=m;i++)
		scanf("%lld",&p[i]);
	for(ll i=1;i<=n-1;i++)
		scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
	for(ll i=1;i<=m-1;i++){
		if(p[i]>p[i+1]){
			x=p[i+1];
			y=p[i];
		}
		else{
			x=p[i];
			y=p[i+1];
		}
		t[x]++;
		t[y]--;
	}
	for(ll i=1;i<=n;i++){
		t[i]+=t[i-1];
	}
	for(ll i=1;i<=n-1;i++)
		ans+=min(a[i]*t[i],(b[i]*t[i]+c[i]));
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：chenxuanting (赞：18)

出于对本题的深仇大恨（卡了我三天）

我决定来写篇题解

目录

1.思路

2.错误记录

3.坑

4.带注释的代码

1.思路

1）差分+前缀和

会的神犇，请跳过这里

如果不会，请看一下举例

假设此时你在做一道数学题

说给出10个数都是0，然后呢，第一个数到第三个数加6，第

二个数到第八个数加9，最后把第一个数到第十个数加10086

请写出现在第一个数到第十个数（注意每次加包括首尾）

我们一般人就是正常的加法，对吧？

第一次加完：6 6 6 0 0 0 0 0 0 0

第二次加完：6 15 15 9 9 9 9 9 9 0

第三次加完：10092 10101 10101 10095 10095 10095 10095 10095 10095 10086

就这些了

但是呢，我们现在可以这么做，算差。

我们聚焦到第一次

是不是第一个数和第二个数之间的差不变（因为同加一个数，差不变，数学）

第二个和第三个，同理

但是第三个和第四个则差有变化，减少了6（此时差可能负数，均为，第n个-第n-1个）

还有第一个和第零个，增多了6

而此时把差加起来，神奇的事情发生了，竟然和原结果一样！
那是不是所有的都可以这么加呢

是的，可以

而刚刚的求差就是差分，求和就是前缀和

2）上面的一大堆东西是用来除去TLE的

说点干货

后面用min，总共两种，买卡和不买卡

买卡：a[i]*经过的次数

不买卡：b[i]*经过的次数+c[i]

那个便宜选那个

2.错误记录（选典型）

1）0分：题目理解+作死

2）60分：TLE

3）0分：看错题目了（what the ****）

4）70分：没开long long

5）100分：终于对了

3.坑

1）long long

2）差分

4.代码（其中的typedef可以忽略）

```
#include<cstdio>
#include<iostream>
#include<algorithm>
typedef long long L;//给long long取一个别名
using namespace std;
L n,m;//long long n，m
L p[100005];
L a[100005],b[100005],c[100005];
L money;//最终的钱
L each[100005];//每段铁路经过的次数
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>p[i];
		if(i==1){
			continue;
		}
		each[min(p[i-1],p[i])]++;//差分
		each[max(p[i-1],p[i])]--;
	}
	for(int i=1;i<=n;i++){
		each[i]+=each[i-1];
	}
	for(int i=1;i<n;i++){
		cin>>a[i]>>b[i]>>c[i];
		money+=min((a[i]*each[i]),(b[i]*each[i]+c[i]));
	}
	cout<<money;//完美结束
	return 0;
}
```


---

## 作者：ciyou (赞：14)

不需要前缀和，不需要树形区间维护

只需统计每段铁路经过次数，比较买不买卡

维护经过次数按下面的方法是常数查询修改，一共是O(n)


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define MAXN 100010
using namespace std;
int add[MAXN];
int A[MAXN],B[MAXN],C[MAXN];
int N,M,P[MAXN];
//add[i]表示从i开始的区间经过次数需要加上的值
//经过i..j铁路可以表示为add[i]++,add[j]--
int main(){
    scanf("%d%d",&N,&M);
    memset(add,0,sizeof(add));
    for(int i=1;i<=M;i++) scanf("%d",&P[i]);
    ll ans=0;
    for(int i=1;i<N;i++)
        scanf("%d%d%d",&A[i],&B[i],&C[i]);
    int ori=P[1];
    for(int i=2;i<=M;i++){
        int from=min(ori,P[i]),to=max(ori,P[i]);
        add[from]+=1;
        add[to]-=1;
        ori=P[i];
    }
    int delta=0;
    for(int i=1;i<N;i++){
        delta+=add[i];
        int visit=delta;
        //根据数据范围以下乘积似乎能高达1e10,保险起见开long long
        ll normal=(ll)visit*(ll)A[i];
        ll now=(ll)visit*(ll)B[i]+C[i];
        //比较买不买卡
        if(normal>now){
            ans+=now;
        }else{
            ans+=normal;
        }
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：ADay (赞：11)

## 思路：差分 
我们写一个差分数组$cnt_i$，表示$vis_i-vis_{i-1}$  
$vis$就是第$i$段铁路的访问次数,$vis_0=0$。   
那么$vis_n$  
$=vis_1-vis_1+vis_2-vis_2+\cdots+vis_{n-1}-vis_{n-1}+vis_n$  
$=(vis_1-vis_0)+(vis_2-vis_1)+\cdots+(vis_n-vis_{n-1})$   
$=cnt_1+cnt_2+\cdots+cnt_n$  
$=\sum\limits_{i=1}^{n}cnt_i$.   
那怎么对差分数组进行操作呢？  
观察一下：   
一个差分数组和原数组   
0------0------0------0------0  
0------0------0------0------0   
城市2~4(经过2~3)    
0------1------0------(-1)------0  
0------1------1------ 0  ------0  
城市4~1(经过3~1)  
1------1------0------(-2)------0  
1------2------2------ 0  ------0   
城市1~5(经过1~4)  
2------1------0------(-2)------(-1)  
2------3------3------ 1  ------ 0   
不难发现，若是从城市$n$~$m$,差分数组$cnt_{\min(n,m)}++,cnt_{\max(n,m)}--$即可  
然后每次输入$a_i,b_i,c_i$时判断$vis_i \times a_i$和$vis_i \times b_i+c_i$的大小即可，谁小答案就加谁    
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,cnt[100005],now,last,sum;
long long ans,vis[100005];//记得开longlong

struct node
{
	long long a,b,c;//我喜欢写结构体，用a[i],b[i],c[i]也行
}s[100005];

long long mymin(long long x,long long y){return x<y?x:y;}//longlong的min

int main()
{
	scanf("%d%d%d",&n,&m,&last);
	for(int i=1;i<m;i++)
	{
		scanf("%d",&now);
		cnt[min(now,last)]++,cnt[max(now,last)]--;//差分操作
		last=now;
	}
	for(int i=1;i<n;i++)vis[i]=sum+=cnt[i];//计算vis[i]
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%d",&s[i].a,&s[i].b,&s[i].c);
		ans+=mymin(vis[i]*s[i].a,vis[i]*s[i].b+s[i].c);//比较
	}
	printf("%lld",ans);
	return 0;
}
```
最后——  
**记得开long long!**

---

## 作者：Apro1066 (赞：10)

**经过文化课的洗礼后，I,am back!**

~~完了，文化课降智，这道黄题想了好久。。~~ 

废话少说。对于第$i$个城市，与第$i+1$个城市相连的是第$i$段铁路。所以任意两个相邻的站点购买同种车票有且**仅有一种费用**，通过第$i$段铁路的价格，仅与在第$i$个城市和第$i+1$个城市之间的**通过次数**有关。若你不是很懂这句话，可以再读一读题目。

那我们不就只需要**求某段铁路的通过次数**不就ok了？

对于每个区间，用一个循环对其所经次数$+1$即可。如下代码：

```cpp
#include <stdio.h>
#include <iostream>
#define ll long long
#define maxn 100001
using namespace std;
ll n,m,s,p[maxn],a[maxn],b[maxn],c[maxn],vis[maxn];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register ll i,j,k;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		cin>>p[i];//访问第i个城市 
	}
	for(i=1;i<=n-1;i++)
	{
		cin>>a[i]>>b[i]>>c[i];//a[i]纸质单程票，b[i]办卡的价格，c[i]是工本费 
	}
	for(i=1;i<=m-1;i++)
	{
		if(p[i]<=p[i+1])
			for(j=p[i];j<p[i+1];j++)//不能j<p[i+1]。因为我们求的是铁路的通过次数，而不是城市的通过次数，因此p[i+1]不能算在里面 
			{
				vis[j]++;//记录通过次数 
			}
		else
			for(j=p[i]-1;j>=p[i+1];j--)//同理 
			{
				vis[j]++;
			}
	}
	for(i=1;i<=n-1;i++)
	{
		s=s+min(a[i]*vis[i]/*买纸质票*/,(b[i]*vis[i]+c[i])/*办卡*/);
	}
	cout<<s<<endl;
	return 0;
}
```
满心欢喜地交上去，却只有70分，后3个点TLE。

为什么会T？很简单，我们的时间全部花费在了记录$vis[i]$。如果$|p[i]-p[i+1]|$的值很大，这个程序的效率会大大降低，退化到近似于$O(m^2)$！

**仔细想一想，我们真的需要这么记录吗？**

回忆我们在树状数组模版2的思路，对于每一个区间改操作，在其**左端点**的位置+区间的值，再在**右端点+1**的位置-区间的值。这不就是相当于**差分数组**吗？那么同理，对于区间$[p[i],p[i+1])$，是不是就可以仿照上面的思路，让$vis[p[i]]+1$，让$vis[p[i+1]]-1$(若$p[i]>p[i+1]$)，最后再跑一遍前缀和使得$vis$数组的值不变呢？
```cpp
#include <stdio.h>
#include <iostream>
#define ll long long
#define maxn 100001
using namespace std;
ll n,m,s,p[maxn],a[maxn],b[maxn],c[maxn],vis[maxn];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register ll i,j,k;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		cin>>p[i];//访问第i个城市 
	}
	for(i=1;i<=n-1;i++)
	{
		cin>>a[i]>>b[i]>>c[i];//a[i]纸质单程票，b[i]办卡的价格，c[i]是工本费 
	}
	for(i=1;i<=m-1;i++)
	{
		ll l,r;
		if(p[i]<=p[i+1])
		{
			l=p[i];
			r=p[i+1];
		}
		else
		{
			l=p[i+1];
			r=p[i];
		}
		vis[l]++;
		vis[r]--;
	}
	for(i=1;i<=n-1;i++)
	{
		vis[i]=vis[i]+vis[i-1];//别忘了再跑一遍前缀和，差分的逆运算是前缀和，所以跑一遍前缀和的目的是为了保持原数不变 
	}
	for(i=1;i<=n-1;i++)
	{
		s=s+min(a[i]*vis[i]/*买纸质票*/,(b[i]*vis[i]+c[i])/*办卡*/);
	}
	cout<<s<<endl;
	return 0;
}
```

---

## 作者：yjxyjx (赞：3)

今天看到这道“上古时期”的题目还没有写总结，更一下

***

这道题的主要思路：

### 前缀和

具体是这样的：这道题我们可以先把**每条路经过的次数**用一个数组（我用的是$Time$）记录下来，

然后在模拟每一段路是买票还是办卡

code：

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>

#define R register

const int MaxN = 100000 + 10;
const int MaxM = 100000 + 10;

inline long long read() {
    int f = 1, x = 0; char ch;
    do {ch = getchar(); if (ch == '-') f = -1;} while (ch < '0' || ch > '9');
    do {x = x*10 + ch - '0'; ch = getchar();} while (ch >= '0' && ch <= '9');
    return f*x;
}
/*P数组表示依次访问的城市的顺序*/
int N, M, P[MaxM], A[MaxN], B[MaxN], C[MaxN];
long long Time[MaxN], ans = 0;

int main() {
    N = read();
    M = read();
    memset(Time, 0, sizeof(Time));
    for (R int i = 1; i <= M; ++i) {
        P[i] = read();
    }
    for (R int i = 1; i <= M - 1; ++i) {
        long long x = std::max(P[i], P[i + 1]);
        long long y = std::min(P[i], P[i + 1]);
        Time[x]--;
        Time[y]++;
    }
    for (R int i = 1; i <= N; ++i) Time[i] += Time[i - 1];

    for (R int i = 1; i < N; ++i) {
        A[i] = read(); B[i] = read(); C[i] = read();
        ans += std::min(B[i]*Time[i] + C[i], A[i]*Time[i]);
    }
    std::cout << ans;
    return 0;
}
```
如果不清楚的话，可以私信我，谢谢

~~突然发觉跟zcysky的代码好像qwq~~

---

## 作者：maomao9173 (赞：2)

### 思路应该是很显然的，贪心的思想，对于每一段取买票和买卡费用的最小值，但每条边的访问次数的计算和存储需要注意。数据范围100000的条件下，直接扫最坏会被卡到1e10，很明显会TLE，这样就需要一个能快速查询的东西来优化，于是我们想到了差分树状数组。如果没有学过树状数组可以自行跳转以下链接。树状数组是一种非常好用的东西，建议可以看一下。
[【p3374】【模板】树状数组1](https://www.luogu.org/problemnew/show/P3374)

[【p3368】【模板】树状数组2](https://www.luogu.org/problemnew/show/P3368)
#### //这道题的其他思路：有兴趣的话可以自行写一下差分前缀和，可能比树状数组还要好写，这里不赘述。


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define lowbit(x) x&-x
#define lint long long
using namespace std;
lint n,m,ans,tree[100010],A[100010],B[100010],C[100010];//ai*x<-->ci+bi*x
void add(lint pos,lint val){
	for(;pos<=n;pos+=lowbit(pos)){
		tree[pos]+=val;
	}
}
inline lint getsum(lint pos){
	lint ans=0;
	for(;pos;pos-=lowbit(pos)){
		ans+=tree[pos];
	}
	return ans;
} 
inline lint min(int x,int y){return x<y?x:y;}
int main(){
	scanf("%lld%lld",&n,&m);
	lint tmp=0,last=0;
	scanf("%lld",&last);
	for(lint i=2;i<=m;i++){
		scanf("%lld",&tmp);
		if(tmp>last){
			add(last,1);
			add(tmp,-1);
		}else{
			add(tmp,1);
			add(last,-1);
		}//表示经过次数 
		last=tmp;
	}//tree里面1-n-1存储着边的经过次数 
	//for(int i=1;i<=n-1;i++)printf("%lld ",getsum(i));
	for(lint i=1;i<=n-1;i++){
		scanf("%lld%lld%lld",&A[i],&B[i],&C[i]);
		lint sum=getsum(i);
		ans+=min(A[i]*sum,C[i]+B[i]*sum);
	}
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：飞翔 (赞：2)

#表示愤怒！月赛的时候就因为没有用qword用了猥琐的longint而只得了60！比赛结束后修改数据范围，就过了！

```cpp
var
  way,a,b,c:array[0..100001]of qword;
    i,n,m,x,y:longint;
    ans:qword;//注意qword
procedure swap(var x,y:longint);
var tmp:longint;
begin
  tmp:=x;
    x:=y;
    y:=tmp;
end;
function min(x,y:qword):qword;//注意qword
begin
  if x<y then exit(x) else exit(y);
end;
begin
  readln(n,m);
    for i:=1 to m do read(a[i]);
    fillchar(way,sizeof(way),0);
    for i:=1 to m-1 do begin
        x:=a[i]; y:=a[i+1];
        if x>y then swap(x,y);
        inc(way[x]); dec(way[y]);
    end;//kkk说的借教师（雾）
    x:=0;
    for i:=1 to n do begin
        x:=x+way[i];//kkk说的前缀和
        a[i]:=x;
    end;
    way:=a;
    fillchar(a,sizeof(a),0);
    ans:=0;
    for i:=1 to n-1 do begin
        read(a[i],b[i],c[i]);
        ans:=ans+min(a[i]*way[i],b[i]*way[i]+c[i]);//比较久行了
    end;
    write(ans);
end.
```
[我的博客](http://blog.csdn.net/qq\_31640513/article/details/52825587)


---

## 作者：Snow_Dreams (赞：0)

这个题我用的~~玄学乱搞~~硬性枚举
这道题的正解就是前缀和差分
就是在一段路上要不然全纸票，要不然全电子车票
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, m, p[100005], a[100005], b[100005], c[100005], dis[100005];
long long ans;
int main()
{
	scanf("%d%d%d", &n, &m, &p[1]);
	for(int i = 2;i <= m;i++)
	{
		scanf("%d", &p[i]);
		int x = p[i-1], y = p[i];
		if(x > y)
			x ^= y, y ^= x, x ^= y;
		dis[x]++;
		dis[y]--;
	}
	for(int i = 1;i < n;i++)
		scanf("%d%d%d", &a[i], &b[i], &c[i]);
	for(int i = 1;i < n;i++)
	{
		dis[i] += dis[i-1];
		if(!dis[i])
			continue;
		ans += min(1LL*dis[i]*a[i], 1LL*dis[i]*b[i]+c[i]);
	}
	printf("%lld", ans);
	return 0;
}
```




---


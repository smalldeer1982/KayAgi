# [IOI 2021] 修改 DNA

## 题目背景

**滥用本题评测将被封号**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 语言提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数

## 题目描述

Grace 是一名生物学家，在新加坡的一个生物信息学公司工作。她的一部分工作是分析不同有机体的 DNA 序列。DNA 序列是包含字符 A、T 和 C 的字符串。注意在本题中，DNA 序列不包含字符 G。

定义一次修改是把 DNA 序列中的两个元素交换位置的操作。例如，通过交换加粗的字符 A 和 C，一次修改可以把 A**C**T**A** 转化为 A**A**T**C**。

两个序列的修改距离是把一个序列转化为另一个序列所用的最少修改次数。如果不能通过修改把一个序列转化为另一个序列，那么这两个序列的修改距离为 $-1$。

Grace 正在分析两个 DNA 序列 $a$ 和 $b$，每个都由 n 个元素组成，下标从 $0$ 到 $n - 1$。你的任务是帮助 Grace 回答以下形式的 $q$ 个问题：子串 $a[x \ldots y]$ 和 $b[x \ldots y]$ 的修改距离是多少？这里，DNA 序列 $s$ 的子串 $s[x \ldots y]$ 定义为 $s$ 的下标从 $x$ 到 $y$（包括 x 和 y）的连续字符序列。也就是说，$s[x \ldots y]$ 是序列 $s[x] s[x + 1] \ldots s[y]$。

## 说明/提示

对于所有数据：

- $1 \le n, q \le 100 \, 000$
- $0 \le x \le y \le n - 1$
- $a$ 和 $b$ 的每个字符都是 A、T 和 C 之⼀

子任务|分值|特殊限制
:-:|:-:|:-:
$1$	|$21$|$y - x \le 2$
$2$	|$22$|	$q \le 500$，$y - x \le 1000$，$a$ 和 $b$ 的每个字符是 A 或 T
$3$	|$13$|	$a$ 和 $b$ 的每个字符是 A 或 T
$4$	|$28$|	$q \le 500$，$y - x \le 1000$
$5$	|$16$|	没有额外的约束条件

## 样例解释

如果评测程序调用 `get_distance(1, 3)`，那么该调用应返回 $a[1 \ldots 3]$ 和 $b[1 \ldots 3]$（也就是序列 TAC 和 CTA）之间的修改距离。通过 $2$ 次修改可以把 TAC 转化为 CTA：TAC $\to$ CAT，然后是 CAT $\to$ CTA。无法通过比 $2$ 次更少的修改完成该转化。

因此，该调用应返回 $2$。

如果评测程序调用 `get_distance(4, 5)`，那么该调用应返回序列 AT 和 TA 之间的修改距离。 通过一次修改可以把 AT 转化为 TA，而且显然至少需要一次。

因此，该调用应返回 $1$。

最后，如果评测程序调用 `get_distance(3, 5)`，由于无法通过修改将序列 CAT 转化为 ATA，因此该调用应返回 $-1$。

## 样例 #1

### 输入

```
6 3
ATACAT
ACTATA
1 3
4 5
3 5```

### 输出

```
2
1
-1```

# 题解

## 作者：wangbinfeng (赞：7)

[![](https://img.shields.io/badge/题目-P10050【IOI2021】修改DNA-green)
![](https://img.shields.io/badge/难度-提高+/省选---blue)
![](https://img.shields.io/badge/考点-前缀和-yellow)
![](https://img.shields.io/badge/题型-交互题-red)](https://www.luogu.com.cn/problem/P10050)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)


------------
这是一道 IOI2021 的题目，不过比较简单。大家不要被其来源吓住了，其实，[这道 IOI 题](https://www.luogu.com.cn/problem/P1216)大家应该都做过了。

放一个官方中文题面：<https://ioi.te.lv/locations/ioi21/contest/day2/DNA/zh_CN.pdf>。

前置知识：
- 前缀和 ~~、生物学 `DNA`（腺嘌呤 `A`、胸腺嘧啶 `T`、胞嘧啶 `C`、鸟嘌呤 `G`）、英语理解能力~~。

言归正传，开始分析。

- $\texttt{Subtask\;1.}$ 每次查询最多只有三个字符，则答案如下：

$$
\text{ans} = \begin{cases}
   -1 &&\text{if}&& 无解（无论怎么交换，都无法做到一一对应，如对应字母数量不同）  \\
   0 &&\text{if}&& 原本就相同  \\
   1 &&\text{if}&& 有且仅有两个字母不同，且交换后两字符串将相同  \\
   2 &&\text{if}&& 三个字母均不同，且交换后两字符串将相同
\end{cases}
$$

- $\texttt{Subtask\;2.}$ 只有两个字母。通过 $\texttt{Subtask\;1}$ 我们可以清晰的发现，每次交换可以修复一个不匹配的情况，因此计算不匹配的数量即可。时间复杂度为 $\Theta \left(qm^2\right)$。此处，$m=y-x+1$，下面同理。
- $\texttt{Subtask\;3.}$ 相较于 $\texttt{Subtask\;2}$ 仅增加了数据范围。因此，可以再 `init()` 函数中预处理出所有的不匹配数量。显然可以使用前缀和。时间复杂度为 $\Theta \left(n+q\right)$。
- $\texttt{Subtask\;4.}$ 较于 $\texttt{Subtask\;3}$ 仅增加了一个字母。先修改两个字母（需要 $1$ 次），时间复杂度为 $\Theta \left(qm^2\right)$，再修改三个字母（需要 $2$ 次），时间复杂度也为 $\Theta \left(qm^2\right)$。故总时间复杂度显然为 $\Theta \left(qm^2\right)$。
- $\texttt{Subtask\;5.\;\&\;Full\;Solution.}$ 相较于 $\texttt{Subtask\;4}$ 仅增加了数据范围，考虑 $\texttt{Subtask\;3}$ 的做法。用前缀和统计不匹配，然后用常数时间复杂度修改即可。时间复杂度为 $\Theta \left(n+q\right)$。

其实 $\texttt{Subtask\;1}$ 的结论可以衍伸，比如字母差异为 $4$ 时仅需要 $3$ 次即可修改完成。不懂为什么数据中没有 `G`。~~我鸟嘌呤这么没牌面吗？~~

------------
代码如下：
```cpp
#include<bits/stdc++.h>
#include<stdexcept>
using namespace std;
//#define int long long
#ifdef int
const int inf=0x7f7f7f7f7f7f7f7f;
#else
const int inf=0x7f7f7f7f;
#endif
int sum[100009][3][3];
inline int bm(const char c) {
	switch(c){
		case 'A':return 0;
		case 'T':return 1;
		case 'C':return 2;
		default:throw("ERROR! The string is wrong!");
	}
}
int n;
void init(string a,string b){
    n=a.size();
    for(int k=1;k<=n;k++){		//注意，这里sum数组下标从1开始，与string不同（为减少特判，防止下标为负的情况） 
        for(int i=0;i<3;i++)for(int j=0;j<3;j++)sum[k][i][j]=sum[k-1][i][j];
        sum[k][bm(a[k-1])][bm(b[k-1])]++;
    }
}
int get_distance(int x,int y){
    int s[3][3],ret=0,t;
    for(int i=0;i<3;i++)for(int j=0;j<3;j++)s[i][j]=sum[y+1][i][j]-sum[x][i][j];
    for(int i=0;i<3;i++)for(int j=i+1;j<3;j++)
        t=min(s[i][j],s[j][i]),ret+=t,s[i][j]-=t,s[j][i]-=t;			//处理所有的不匹配 
    if(s[0][1]!=s[1][2] or s[1][2]!=s[2][0] or s[1][0]!=s[2][1] or s[2][1]!=s[0][2])return -1;		//不存在 
    return ret+2*(s[0][1]+s[1][0]);
}
#ifndef ONLINE_JUDGE
int q,x,y;
string a,b;
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0),cerr.tie(0);
	cin>>n>>q;
	cin>>a>>b;
	init(a,b);
	for(int i=1;i<=q;i++){
		cin>>x>>y;
		cout<<get_distance(x,y)<<endl;
	}
}
#endif
```

---

## 作者：Vct14 (赞：4)

题目链接：[P8521 [IOI2021] 修改 DNA](https://www.luogu.com.cn/problem/P8521)。

~~说句闲话，我最开始做这题的时候这题是 P10050 来着？~~

upd 24/07/09：修改了一处小错误。

------------

科普一下，生物体中常见的碱基有 $5$ 种，分别是腺嘌呤（`A`）、鸟嘌呤（`G`）、胞嘧啶（`C`）、胸腺嘧啶（`T`）和尿嘧啶（`U`），其中碱基 A、G、C 和 T 存在于 DNA 中。注意，本题中 DNA 序列只含有字符 A、T 和 C。

本题虽然是交互题，但实际上是一道传统题。

------------

为了方便，我们把 A、T 和 C 分别替换为 $0,1,2$。

```c++
int change(char c){
    if(c=='A') return 0;
    else if(c=='T') return 1;
    else return 2;
}
```

注意到本题求修改次数的是同一个区间，那么对于任意 $k$，我们需要把 $a_k$ 改为 $b_k$。定义一个区间的的修改矩阵 $s$ 为一个 $3\times3$ 的矩阵，并且 $s_{i,j}$ 为某一个区间内需要将 $i$ 改为 $j$ 的个数（$0\leqslant i,j\leqslant 2$）。

那么我们可以在 `init` 函数中把修改矩阵求出来。这里使用类似前缀和的思路存储。

```c++
void init(string a,string b) {
    int len=a.length();
    For(k,1,len){
        F(i) F(j) S[k][i][j]=S[k-1][i][j];
        S[k][change(a[k-1])][change(b[k-1])]++; // 类似前缀和 
    }
}
```

我们采取这样的思路修改：能两两交换就交换（如样例二），剩下多出来的考虑三个轮换修改。

对于每一组询问，我们先求出这个区间的修改矩阵。然后进行两两交换。此时 $s_{i,j}$ 和 $s_{j,i}$ 中必有一个为 $0$。若 $s_{1,0}$ 为 $0$，则仅当 $s_{0,1}=s_{1,2}=s_{2,0}$ 时，可以将 $0$ 与 $1$ 交换位置，再将 $0$ 与 $2$ 交换位置，交换次数为 $s_{0,1}+s_{2,0}=2\times s_{0,1}$。$s_{0,1}$ 为 $0$ 同理。

```c++
int get_distance(int x,int y){
    int ans=0;
    F(i) F(j) s[i][j]=S[y+1][i][j]-S[x][i][j]; // 求出修改矩阵 
    F(i){
    	For(j,i+1,3){
	        int m=min(s[i][j],s[j][i]);
	        ans+=m;s[i][j]-=m;s[j][i]-=m; // 抵消 
	    }
	}
	// 轮换修改 
	if(s[0][1]!=s[1][2] || s[1][2]!=s[2][0] || s[1][0]!=s[2][1] || s[2][1]!=s[0][2]) return -1; 
	if(s[0][1]!=0) return ans+2*s[0][1];
	else return ans+2*s[1][0];
}
```

代码如下：

```c++
#include<bits/stdc++.h>
using namespace std;

#define For(i,a,b) for(int i=a; i<=b; i++)
#define F(i) For(i,0,2)
int change(char c){if(c=='A'){return 0;}else if(c=='T'){return 1;}else{return 2;}}

int S[100002][3][3];//ATC
int s[3][3];

void init(string a,string b) {
    int len=a.length();
    For(k,1,len){
        F(i) F(j) S[k][i][j]=S[k-1][i][j];
        S[k][change(a[k-1])][change(b[k-1])]++; // 前缀和 
    }
}

int get_distance(int x,int y){
    int ans=0;
    F(i) F(j) s[i][j]=S[y+1][i][j]-S[x][i][j]; // 求出修改矩阵 
    F(i){
    	For(j,i+1,3){
	        int m=min(s[i][j],s[j][i]);
	        ans+=m;s[i][j]-=m;s[j][i]-=m; // 抵消 
	    }
	}
	// 轮换修改 
	if(s[0][1]!=s[1][2] || s[1][2]!=s[2][0] || s[1][0]!=s[2][1] || s[2][1]!=s[0][2]) return -1; 
	if(s[0][1]!=0) return ans+2*s[0][1];
	else return ans+2*s[1][0];
}

/*
int main(){
	int n,q;string a,b;cin>>n>>q>>a>>b;
	init(a,b);
	while(q--){
		int x,y;cin>>x>>y;
		cout<<get_distance(x,y)<<endl;
	}
	return 0;
}
*/
```

---

## 作者：CodingOIer (赞：2)

# P8521 [IOI2021] 修改 DNA 题解

### 思路分析

~~I AC IOI.~~

下文记 $\texttt{A}$ 为 $1$，$\texttt{T}$ 为 $2$，$\texttt{C}$ 为 $3$。

计算 $3$ 个前缀数组 $sa, sb, sc$。

- $sa_{i, j}$ 为 $a$ 的前 $i$ 位中 $j$ 出现的次数。
- $sb_{i, j}$ 为 $b$ 的前 $i$ 位中 $j$ 出现的次数。
- $sc_{i, x, y}$ 为如果我们需要将 $a$ 的前 $i$ 位转换为 $b$ 所需要的从 $x$ 到 $y$ 的转换次数。

上面的 $3$ 个数组在 `init` 函数中计算得出。

```cpp
void init(std::string _a, std::string _b)
{
    int l = _a.size();
    _a = " " + _a;
    _b = " " + _b;
    for (int i = 1; i <= l; i++)
    {
        a[i] = _a[i] == 'A' ? 1 : _a[i] == 'T' ? 2 : 3;
        b[i] = _b[i] == 'A' ? 1 : _b[i] == 'T' ? 2 : 3;
        for (int x = 1; x <= 3; x++)
        {
            sa[i][x] = sa[i - 1][x];
            sb[i][x] = sb[i - 1][x];
            for (int y = 1; y <= 3; y++)
            {
                sc[i][x][y] = sc[i - 1][x][y];
            }
        }
        sa[i][a[i]]++;
        sb[i][b[i]]++;
        if (a[i] != b[i])
        {
            sc[i][a[i]][b[i]]++;
        }
    }
}
```

记 $s$ 为 $sc_r - sc_{l - 1}$ 即区间内所需要的修改次数。

先判无解。

如果这一段区间中的 $1, 2, 3$ 的出现次数有任何一个不相同，直接返回 $-1$。

否则我们优先考虑两两互换的情况，如：

```
1 2 2 3
2 1 3 2
```

显然，交换 $(1, 2), (3, 4)$ 即可。

即，对于 $1 \le y < x \le 3$
$$
l \gets min(s_{x, y}, s_{y, x}) \\
s_{x, y} \gets s_{x, y} - l \\
s_{y, x} \gets s_{y, x} - l
$$
剩下的只有三个交换的情况，如：

```
1 2 3
2 3 1
```

对于这种情况，其实我们并不需要考虑得太复杂。

显然所有的排列在经过两两互换的过程后只可能有这种操作。

而完成一次三个交换所需要的次数为 $2$。

统计出剩余的仍需交换的次数 $k$，$res \gets res + \dfrac{2}{3}k$ 的即可。

注：这里的简化是建立在我们之前已经判掉无解之上的。

### 代码实现

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <string>
constexpr int MaxN = 1e5 + 5;
int a[MaxN];
int b[MaxN];
int s[5][5];
int sa[MaxN][5];
int sb[MaxN][5];
int sc[MaxN][5][5];
void init(std::string _a, std::string _b)
{
    int l = _a.size();
    _a = " " + _a;
    _b = " " + _b;
    for (int i = 1; i <= l; i++)
    {
        a[i] = _a[i] == 'A' ? 1 : _a[i] == 'T' ? 2 : 3;
        b[i] = _b[i] == 'A' ? 1 : _b[i] == 'T' ? 2 : 3;
        for (int x = 1; x <= 3; x++)
        {
            sa[i][x] = sa[i - 1][x];
            sb[i][x] = sb[i - 1][x];
            for (int y = 1; y <= 3; y++)
            {
                sc[i][x][y] = sc[i - 1][x][y];
            }
        }
        sa[i][a[i]]++;
        sb[i][b[i]]++;
        if (a[i] != b[i])
        {
            sc[i][a[i]][b[i]]++;
        }
    }
}
int get_distance(int l, int r)
{
    l++;
    r++;
    for (int x = 1; x <= 3; x++)
    {
        if (sa[r][x] - sa[l - 1][x] != sb[r][x] - sb[l - 1][x])
        {
            return -1;
        }
    }
    for (int x = 1; x <= 3; x++)
    {
        for (int y = 1; y <= 3; y++)
        {
            s[x][y] = sc[r][x][y] - sc[l - 1][x][y];
        }
    }
    int res = 0;
    for (int x = 1; x <= 3; x++)
    {
        for (int y = 1; y <= x - 1; y++)
        {
            int l = std::min(s[x][y], s[y][x]);
            res += l;
            s[x][y] -= l;
            s[y][x] -= l;
        }
    }
    int k = 0;
    for (int x = 1; x <= 3; x++)
    {
        for (int y = 1; y <= 3; y++)
        {
            k += s[x][y];
        }
    }
    return res + k / 3 * 2;
}
#ifndef ONLINE_JUDGE
int main()
{
    int n, k;
    std::string a, b;
    scanf("%d%d", &n, &k);
    std::cin >> a;
    std::cin >> b;
    init(a, b);
    for (int i = 1; i <= k; i++)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", get_distance(l, r));
    }
    return 0;
}
#endif
```

交互题，不需要实现主函数。

`#ifndef ONLINE_JUDGE` 标记指如果没定义宏 `ONLINE_JUDGE` 的情况就将下面的代码编译，否则跳过。

在洛谷的编译命令中定义了该标记，所以提交后不会有 `main` 函数被编译。

本地则像传统题一样可以编译运行。

---

## 作者：zk_y (赞：1)

IOI 简单题。

首先，考虑一下什么时候无解，显然是 $a$ 中某个字符的个数和 $b$ 中某个字符的个数不相等，这样才会出现无解的情况。

然后考虑有解的情况，显然，如果两种字符是 $x$ 在 $y$ 的位置上，$y$ 在 $x$ 的位置上，然后交换 $x,y$，这样显然是最优的。

考虑建立一个表格 $now_{i,j}$ 表示现在 $i$ 字符在 $j$ 位置上的情况的个数。

根据上面的贪心，可以将 $now_{i,j}$ 和 $now_{j,i}$ 先抵消把一部分，直到有某个东西为 $0$。

那么最后就可以直接计算了。

又因为是交互题，加上 ``ONLINE_JUDGE`` 的判断就好了。

$code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+100;
int tota[3][N];
int totb[3][N];
int tot[N][3][3];
int mat[N];
#define L(i,j,k) for(int i=j;i<=k;i++)
int n,q;

int getop(char x){
	if(x=='A')return 0;
	if(x=='T')return 1;
	if(x=='C')return 2;
	return 114514;
}

void init(string a,string b){
	n=a.length();
	L(i,1,n){
		L(j,0,2)tota[j][i]=tota[j][i-1],totb[j][i]=totb[j][i-1];
		if(a[i-1]=='A')tota[0][i]++;
		if(a[i-1]=='T')tota[1][i]++;
		if(a[i-1]=='C')tota[2][i]++;
		if(b[i-1]=='A')totb[0][i]++;
		if(b[i-1]=='T')totb[1][i]++;
		if(b[i-1]=='C')totb[2][i]++;
	}
	
	L(i,1,n){
		L(j,0,2)L(k,0,2)tot[i][j][k]=tot[i-1][j][k];
		tot[i][getop(a[i-1])][getop(b[i-1])]++;
	}
	
}

int get_distance(int x,int y){
	L(i,0,2)if(tota[i][y+1]-tota[i][x]!=totb[i][y+1]-totb[i][x])return -1;
	int ans=0,tmp=0;
	int now[3][3];
	L(i,0,2)L(j,0,2)now[i][j]=tot[y+1][i][j]-tot[x][i][j];
	L(i,0,2)L(j,i+1,2)tmp=min(now[i][j],now[j][i]),ans+=tmp,now[i][j]-=tmp,now[j][i]-=tmp;
	return ans+2*(now[0][2]+now[2][0]);
}


#ifndef ONLINE_JUDGE

string a,b;

int main(){
	ios::sync_with_stdio(0);
	
	cin>>n>>q;
	
	cin>>a>>b;
	
	init(a,b);
	
	while(q--){
		int x,y;
		cin>>x>>y;
		cout<<get_distance(x,y)<<'\n';
	}
	
	return 0;
}

#endif
```

---

## 作者：Il1_1_3 (赞：0)

## P8521 题解

[题目传送门](https://www.luogu.com.cn/problem/P8521)

~~2021 年的 IOI 竟然有黄题~~

## 题意
给定两个长度为 $n$ 的字符串 $a,b$，有 $q$ 次询问，每一次要求出子串 $a_x,a_{x+1} \cdots a_y$ 能否通过若干次交换两个字符使得该子串等于 $b_x,b_{x+1} \cdots b_y$。

## 所用算法
前缀和 ~~，生物学~~。

## 思路
拿 $n=3$ 举例：

- 无解：这一对字符串的成分不同，例如 `AAT` 和 `ATT`；
- $0$ 次修改：即两个子串相等；
- $1$ 次修改：即只有一个字符的位置正确，如 `ATC` 和 `ACT`；
- $2$ 次修改：即三个字符的位置均不对。

下文以字符 `A` 为 $0$，`T` 为 $1$，`C` 为 $2$ 为准（即代码中 $f(c)$ 函数）。

首先计算两个前缀和数组 $ta,tb$，$ta$ 代表第 $i$ 种字符在字符串 $a$ 的前 $j$ 项中出现的次数，$tb$ 代表第 $i$ 种字符在字符串 $b$ 的前 $j$ 项中出现的次数。

然后是数组 $t$，$t_{k,i,j}$ 表示将前 $k$ 项转换成另一个字符串的第 $i$ 到 $j$ 项的最小次数，根据前缀和可以将前 $k$ 项推广到任意 $x,y$。

## 注意
因为不用实现 `main` 函数但在本地需要调试，可以使用 `#ifndef ONLINE_JUDGE` 或直接删去主函数解决问题。

#### 主要代码
```cpp
void init(string a,string b)
{
	n=a.size();
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=2;j++)
		{
			ta[j][i]=ta[j][i-1];
			tb[j][i]=tb[j][i-1];
		}
		if(a[i-1]=='A')ta[0][i]++;
		if(b[i-1]=='A')tb[0][i]++;
		if(a[i-1]=='T')ta[1][i]++;
		if(b[i-1]=='T')tb[1][i]++;
		if(a[i-1]=='C')ta[2][i]++;
		if(b[i-1]=='C')tb[2][i]++;
	}
	for(int k=1;k<=n;k++)
	{
		for(int i=0;i<=2;i++)
		{
			for(int j=0;j<=2;j++)
				t[k][i][j]=t[k-1][i][j];
		}
		t[k][f(a[k-1])][f(b[k-1])]++;
	}
}
int get_distance(int x,int y)
{	
	int s[3][3],tt=0,tims=0;
	for(int i=0;i<=2;i++)
		for(int j=0;j<=2;j++)
			s[i][j]=t[y+1][i][j]-t[x][i][j];
	for(int i=0;i<=2;i++)
		for(int j=i+1;j<=2;j++)
		{
			tt=min(s[i][j],s[j][i]);
			tims+=tt;
			s[i][j]-=tt;
			s[j][i]-=tt;
		}
	if(s[0][1]!=s[1][2]||s[1][2]!=s[2][0]||s[1][0]!=s[2][1]||s[2][1]!=s[0][2])
		return -1;
	tims+=(s[0][2]+s[2][0])*2;
	return tims;
}
```

---


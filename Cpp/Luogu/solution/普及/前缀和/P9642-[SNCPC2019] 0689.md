# [SNCPC2019] 0689

## 题目描述

我们称一个字符串为 0689-字符串，如果这个字符串只包含数字 0、6、8 和 9。给定一个长度为 $n$ 的 0689-字符串 $s$，必须执行以下操作一次：选择 $s$ 的一个非空子串并将其旋转 180 度。

更正式地说，设 $s_i$ 为字符串 $s$ 的第 $i$ 个字符。在将从 $s_l$ 开始到 $s_r$ 结束的子串旋转180度后 ($1 \le l \le r \le n$)，字符串 $s$ 将变成长度为 $n$ 的字符串 $t$，其通过以下公式得到，其中 $t_i$ 表示字符串 $t$ 中的第 $i$ 个字符：

$$t_i = \begin{cases}
s_i & \text{if } 1 \le i < l \text{ or } r < i \le n \\
\text{`0'} & \text{if } l \le i \le r \text{ and } s_{l+r-i} = \text{`0'} \\
\text{`6'} & \text{if } l \le i \le r \text{ and } s_{l+r-i} = \text{`9'} \\
\text{`8'} & \text{if } l \le i \le r \text{ and } s_{l+r-i} = \text{`8'} \\
\text{`9'} & \text{if } l \le i \le r \text{ and } s_{l+r-i} = \text{`6'} \\
\end{cases}$$

经过这个操作后，可以得到多少个不同的字符串？

## 样例 #1

### 输入

```
2
0689
08```

### 输出

```
8
2```

# 题解

## 作者：awesomegordon (赞：5)

By awesomegordon.


## 题意

给定一个只由 $0,6,8,9$ 组成的字符串 $S$，求将S的任意非空字串进行**翻转**后可得到多少新字串。

## 思路

最开始是很懵的，但是却想到既然不能求到合法子串数，那就求**不合法字串数**。其中不合法字串分三种：

1. 首，尾均为 $0$ 的子串。

统计 $0$ 字符数量 $sum1$，不合法子串数量为 

$$\dfrac{sum1\times(sum1+1)}{2}$$

2. 首，尾均为 $8$ 的子串。

统计 $8$ 字符数量 $sum3$，不合法子串数量为

$$\dfrac{sum3\times(sum3+1)}{2}$$


3. 首，尾为 $6,9$ 的字串。

统计 $6,9$ 字符数量 $sum2,sum4$，不合法子串数量为 $sum2 \times sum4$。

### 注意一点：

如果有全为 $6$ 或 全为 $9$ 的字串，则答案减 $1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string s;
int main(){
	//By awesomegordon 
	int T;
	cin>>T;
	while(T--){
		cin>>s;
		ll l=s.size();
		ll sum1=0,sum2=0,sum3=0,sum4=0;
		//统计数字量 
		for(int i=0;i<l;i++){
			if(s[i]=='0'){
				sum1++;
			}
			if(s[i]=='6'){
				sum2++;
			}
			if(s[i]=='8'){
				sum3++;
			}
			if(s[i]=='9'){
				sum4++;
			}
		}
		ll tsum=0;
		//tsum是不符合的数量 
		tsum+=sum1*(sum1+1)/2;
		tsum+=sum3*(sum3+1)/2;
		tsum+=sum2*sum4;
		if(sum2==l||sum4==l){
			tsum++;
			//特判没考虑到的
		}
		cout<<(l+1)*l/2-tsum+1<<"\n";
	}
	return 0;
}
```



---

## 作者：1234567890sjx (赞：3)

容易发现不符合的情况就是首尾都是 $0$，$8$ 或者首尾一个 $6$ 一个 $9$ 的情况。

令 $n=|s|$，$c_k$ 是 $s$ 中 $k$ 出现的次数。

则正难则反，总的情况为 $\frac{n\times (n+1)}{2}+1$，不符合条件的情况为 $\frac{c_0\times (c_0+1)+c_8\times (c_8+1)}{2}+c_6\times c_9$。

特殊的，如果 $c_6=n$ 或 $c_9=n$，那么翻转一次无法得到原串，所以答案还要 $-1$。

单组询问的时间复杂度是 $O(n)$ 的。

---

## 作者：Luxe877 (赞：0)

这是道也许模拟也许数论的题,但是我写挂了好多次（悲）。

题目链接在这：[P9642 [SNCPC2019] 0689](https://www.luogu.com.cn/problem/P9642)

## 翻译与大致题意
给你一个仅由 $0$，$6$，$8$，$9$ 四种字符组成的字符串 $S$ ，对于这个字符串你可以选择任意非空子串将它翻转，比如说有字符串 `0689`，翻转后就是 `6890`。现在让你求通过这种翻转方式，仅翻转 $1$ 次后可形成的不同新字符串个数。

## 思路
### Part 1. 暴力模拟
很纯粹的一种思路，通过简单的推理可以得出以下规律：

* `0` 和 `8` 翻转后还是原字符（除了位置可能会变）。
* `6` 和 `9` 如果是对称的，则翻转后二者都不变。

基于以上两种规律，不难想出：从会导致重复的出发点开始，向外拓展，直到翻转后不会重复为止。比如说初始字符串为 `09689086`，模拟时假设选取了第 $4$ 位的 `8`，由上规律得出这个子串肯定是重复的。因此向外扩大 $1$ 位的大小，即此时的子串为 `689`，当然也是会重复的。再向外扩大 $1$ 位，选出子串 `96890`，此时不会重复了，就跳出拓展的循环并给答案减去拓展的次数，即 $1$ 次，以此类推就能求出答案。

这时就有人问了，你只说减去的数量，没告诉我们初始的答案数是怎么算的啊？额其实这里也没太复杂，出几个样例推算一下就能得到不重复时的答案数为 $\frac{cnt \times (cnt+1)}{2}$。

综合以上，得出如下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
char s[1000002];
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>s+1;
		int len=strlen(s+1);
		long long type=len*(len+1)/2;
		for(int i=1;i<=len;i++)
		{
			if(s[i]=='0'||s[i]=='8')
			{
				int cnt=1,size;
				for(size=1;i-size>0&&i+size<=len;size++,cnt++)
				{
					int l=i-size,r=i+size;
					if(s[l]==s[r]=='0'||s[l]==s[r]=='8')
					{
						continue;
					}else{
						if((s[l]=='6'&&s[r]=='9')||(s[l]=='9'&&s[r]=='6'))
						{
							continue;
						}
					}
					break;
				}
				type-=cnt;
			}
		}
		cout<<type+1<<endl;
	}
	return 0;
}
```

但是，很遗憾，因为我也不知道的原因，这个会错。

那么我们就只能改变策略了！

### Part 2. 数学

用上面的程序高强度~~打表~~计算可得到以下计算公式：

定义 $cnt_x$ 为字符串中数字 $x$ 出现的次数，$len$ 为字符串长度，则答案为：

$ans= \frac{len \times (len+1)}{2}- \frac{cnt_0 \times (cnt_0+1)}{2}- \frac{cnt_8 \times (cnt_8+1)}{2}- cnt_6 \times cnt_9 +1$

依据这个公式，我们很快就可以写出正确程序。诶等等，还有问题的说。试试这个样例：`66666`，你会发现程序算的是 $16$，但你自己会算出 $15$，因为这个字符串整个翻转不会得到原字符串，所以最后还要 $-1$。

综上，得出以下程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
char s[1000002];
long long cnt[12];
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>s+1;
		memset(cnt,0,sizeof(cnt));
		long long len=strlen(s+1);
		long long type=len*(len+1)/2+1;
		for(int i=1;i<=len;i++)
		{
			cnt[s[i]-'0']++;
		}
		type-=(cnt[0]*(cnt[0]+1)/2);
		type-=(cnt[8]*(cnt[8]+1)/2);
		type-=(cnt[6]*cnt[9]);
		if(cnt[6]==len||cnt[9]==len)
		{
			type--;
		 } 
		cout<<type<<endl;
	}
	return 0;
}
```

## 注意事项
唯一的一点：不开 `long long` 见祖宗。

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

给定一个由 `0`, `6`, `8`, `9` 组成的字符串，经过一次或 $0$ 次翻转后，最多可以形成多少个不同的字符串。

定义翻转为 区间内所有字符串顺序翻转，并且每个数字翻转 $180$ 度。

### 题目分析

我们先考虑任意两个节点翻转后所形成的字符串都是不一样的，则有 $\dfrac{n\times(n+1)}{2}$ 种翻转方式，特别的，如果不翻转也算一次。

然后我们考虑两种翻转后所形成的字符串一样的情况，我们假设翻转的是 $a_l\cdots a_r$，翻转后的字符串可能与 $a_{l+1}\cdots a_{r-1},a_{l+2}\cdots a_{r-2}\cdots$ 相同，假设有 $x$ 个相同的，我们在上述式子中多算了 $x-1$ 次。所以我们可以对于每种情况，如果与上一种情况相同，则答案 $-1$。

于是，我们需要判断翻转 $a_l\cdots a_r$ 与 $a_{l+1}\cdots a_{r-1}$ 相同的情况，也就是说 $a_l$ 旋转 $180$ 度与 $a_r$ 相同的情况。

1. `0` 旋转后与 `0` 相同。

$ans - \dfrac{sum_0 \times (sum_0 + 1)}{2}$。

2. `8` 旋转后与 `8` 相同。

$ans - \dfrac{sum_8 \times (sum_8 + 1)}{2}$。

3. `6` 旋转后与 `9` 相同。

$ans - sum_6 \times sum_9$。

特别的，如果所有数为 $6$ 或 $9$，翻转后与原字符串一样，则答案 $-1$（所有数为 $8$ 或 $1$ 的情况已经在 $a_1 = a_n = 8/1$ 的时候减过了）。

最终答案如下：

$$ans = \dfrac{n \times (n-1)}{2} + 1 - \dfrac{sum_0 \times (sum_0+1)}{2} - \dfrac{sum_8\times(sum_8+1)}{2} - sum_6 \times sum_9 - \begin{cases}1 & sum_6 = n \\ 0 & sum_6 \neq n \end{cases} - \begin{cases}1 & sum_9 = n \\ 0 & sum_9 \neq n \end{cases}$$

时间复杂度是线性的。

PS: 记得开 `longlong`。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <map>
#include <queue>
#include <cstring>
#define int long long
using namespace std;
int T, ans, n;
string s;
map <char, int> mp;
signed main()
{
    scanf("%lld", &T);
	while(T--)
	{
		cin >> s;
		n = s.size();
		s = "#" + s;
		mp.clear();
		for(int i = 1;i <= n;i++)
			mp[s[i]]++;
		ans = n * (n+1) / 2;
		ans -= mp['0'] * (mp['0']+1) / 2;
		ans -= mp['8'] * (mp['8']+1) / 2;
		ans -= mp['6'] * mp['9'];
		if(mp['6'] == n || mp['9'] == n)
			ans--;
		printf("%lld\n", ans + 1);
	}
    return 0;
}

```

---

## 作者：FwbAway (赞：0)

难度：大约是普及的第一到二题。

## 题意

题目已经给定了 $T$ 组数据，每组数据都是一个字符串 $S$。

已知，$S$ 由 $0,6,8,9$ 构成，你可以选择其中**非空**（有值）的一段区间进行反转（即从水平翻转为倒立）。

求：新字串最多的个数。

## 理解

比如 $896$ 翻转之后变成了 $968$，$8$ 不会发生改变。

## 思路

众所周知的容斥原理**改进**算法。

如果有一个区间为 $8806988$，那么很明显的，此区间内有 $[1,7]$ 和 $[2,6]$ 是一样的，所以可以进行去重操作，以免大数据卡死（优化）。

```c++
for (/*此处枚举 n*/)
L = 1, R = n;
l = 1, r = n;
while (a[l]==a[r])l++,r--;
/*此处去重，可以用双向链表*/
```

再看一种情况为 $6996699696969969699696$，很明显里面有一大堆的重复元素，所以我们考虑排除开头末尾调换位置后是相同的区间（思路）。

```c++
if (a[l]=='6'&&a[r]=='9'||a[l]==a[r]&&a[l]!=6&&a[l]!=9) {
	/*开头末尾调换位置不变则不可以*/
}
```

最后用记录结果。

---

## 作者：isletfall (赞：0)

# 题意
给定一个只含有 $0,6,8,9$ 的字符串 $S$，你可以选择 $S$ 的非空字串将其翻转 $180°$ 得到一个新串，问有多少个不同的新串。
# 思路
考虑容斥原理，即用总的方案数减去不合法的方案数。

设 $S$ 的长度为 $len$，总的方案数即为 $S$ 翻转的子串的个数+自己本身，即 $\frac{len(len+1)}{2}+1$，可由隔板法推出。

接下来统计不合法的方案数，首先考虑 $0$ 的情况：对于一个首尾均为 $0$ 的子串，删去这两个 $0$ 对于答案没有影响，所以我们只需统计出 $0$ 的个数 $x$，那么以 $0$ 开头以 $0$ 结尾的子串的个数即为 $\frac{x(x+1)}{2}$。

$8$ 的情况与 $0$ 处理方法相同。

接下来考虑 $6$ 和 $9$ 的情况：对于每一个 $6-9$ 的组合，翻转完还是 $6-9$，删去这组 $6$ 和 $9$ 对于答案没有影响，$9-6$ 的组合也是同理。所以我们需要分别统计出 $6$ 的个数 $z$ 和 $9$ 的个数 $w$，根据乘法原理，该情况下不合法的方案数为  $z \times w$。

但是有一种特殊情况我们需要考虑，即 $S$ 全为 $6$ 或者 $S$ 全为 $9$。这样不论如何挑选子串，翻转后一定会出现新串，这会使得不合法的方案数多 $1$，最后需要减去。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long x,y,z,w;
long long ans;
int main(){
	cin>>t;
	while(t--){
		ans=0;
		string s;
		cin>>s;
		long long len=s.size();
		ans=len*(len+1)/2+1;
		x=y=w=z=0;
		for(long long i=0;i<len;i++){
			if(s[i]=='0')x++;
			if(s[i]=='8')y++;
			if(s[i]=='6')z++;
			if(s[i]=='9')w++;
		}
		ans-=(x+1)*x/2;
		ans-=(y+1)*y/2;
		ans-=z*w;
		if(z==len||w==len)ans--;
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Forg1weN (赞：0)

## 题面
给定一个只包含 $0,6,8,9$ 的字符串 $S$，对于每一个非空子串，将其翻转，其余不动，例如 $68\rightarrow 89$，有多少个不同的新串。

$|S|\le 10^6$。

## 思路
被卡了很久的简单题。

若用总的减去不合法的，这题就很难。

考虑直接统计有多少个翻转之后不同的，枚举一个端点，判断这个端点右侧有多少个非端点翻转得到的数字，例如 $6$ 就要在右边查询非 $9$ 数字的个数。

考虑正确性，若端点相互翻转不一样，则由 $s_l\dots s_r$ 字符构成的串一定是不同的，显然。

要特判翻转之后得到原串的情况，例如 $6,8,69$。

## code
```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=1e6+10;
LL T,ans,n,tot;
LL sum0[maxn],sum6[maxn],sum8[maxn],sum9[maxn];
bool pd=0;
string c;
void clear() {
	for(LL i=1;i<=n+1;i++)
		sum0[i]=sum6[i]=0,sum8[i]=sum9[i]=0;
	ans=0;
	pd=0;
}
signed main() {
	scanf("%lld",&T);
	while(T--) {
		cin>>c;
		c='#'+c;
		n=c.size()-1;
		clear();
		for(LL i=n;i>=1;i--) {
			sum0[i]=sum0[i+1]+(c[i]=='0');
			sum6[i]=sum6[i+1]+(c[i]=='6');
			sum8[i]=sum8[i+1]+(c[i]=='8');
			sum9[i]=sum9[i+1]+(c[i]=='9');
		}
		for(LL i=1;i<=n;i++) {
			if(c[i]=='0')
				ans+=n-i-sum0[i+1];
			if(c[i]=='6')
				ans+=n-i-sum9[i+1];
			if(c[i]=='8')
				ans+=n-i-sum8[i+1];
			if(c[i]=='9')
				ans+=n-i-sum6[i+1];
			if(c[i]!='0'&&c[i]!='8')
				ans++;
			if((c[i]=='0'||c[i]=='8')&&!pd)
				pd=1,ans++;
		}
		if(!pd)
			for(int i=1;i<=n-1;i++)
				if(c[i]=='6'&&c[i+1]=='9'||c[i]=='9'&&c[i+1]=='6') {ans++;break;}
		printf("%lld\n",ans);
	}
	return 0;
} 
```


---

## 作者：SDLTF_凌亭风 (赞：0)

很有意思的一道题。

先找特殊的只有 $0$ 和 $8$ 的情况，也就是翻不翻都不变的情况：记原字符串为 $s$。如果字符串只有 $0$ 和 $8$，并且你要翻转区间 $[l,r]$，并且 $s_l=s_r$，显然翻转 $[l,r]$ 的结果等同于翻转 $[l+1,r-1]$。

此时就只需要考虑满足有多少个区间 $[l,r]$ 满足 $s_l\neq s_r$。

然而还有 $6$ 和 $9$。那么是否可以套用上面的思路呢？当然可以！你不是想要翻转前后一样嘛，那我就尝试用这两个数字构造出翻转前后一样的方法。显然只有两种方法：$69$ 和 $96$。

那么最终，我们就要考虑有多少个区间 $[l,r]$ 满足 $(s_l,s_r)$ 不为 $(0,0),(6,9),(9,6),(8,8)$。复杂度是 $O(n)$ 的。

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
	ios::sync_with_stdio(false); cin.tie(0);
	int T; cin >> T;
    for(string s; T; -- T) {
		cin >> s, s = "#" + s;
		int len = s.size() - 1;
		vector<int> zero(len + 1), eight(len + 1), six(len + 1), nine(len + 1);
		for(int i = 1; i <= len; ++ i) zero[i]  = (s[i] == '0') ? (zero[i - 1]  + 1) : zero[i - 1], eight[i] = (s[i] == '8') ? (eight[i - 1] + 1) : eight[i - 1], six[i]   = (s[i] == '6') ? (six[i - 1]   + 1) : six[i - 1], nine[i]  = (s[i] == '9') ? (nine[i - 1]  + 1) : nine[i - 1];
		int ans = (((len + 1) * len) >> 1) + 1 - (len == six[len] || len == nine[len]) - (zero[len] + eight[len]);
		for(int i = 1; i <= len; ++ i) ans -= (s[i] == '0') ? (zero[len] - zero[i]) : ((s[i] == '8') ? (eight[len] - eight[i]) : ((s[i] == '9') ? (six[len] - six[i]) : (nine[len] - nine[i])));
 		cout << ans << endl;
	}
}
```

---

## 作者：luan341502 (赞：0)

赛时队友调过的。

观察可以发现字符的顺序并不重要，因此我们直接统计出 $0$，$6$，$8$，$9$ 的个数。

接下来考虑处理，直接统计数目并不好求，因此我们正难则反，考虑哪些串不符合条件。

模拟可以发现如果一个子串 $[L,R]$ 的开头和末尾如果是 $0-0$，$6-9$，$9-6$ 或 $8-8$，那么这个串翻转后一定与 $[L+1,R-1]$ 相同，因此从答案中删去。

最后特判全是 $6$ 和 全是 $9$ 的情况即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
struct node{
	int s0,s6,s8,s9;
}num;
int T;
char s[N];
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%s",s);
		int len=strlen(s);
		long long ans;
		num.s0=0,num.s6=0,num.s8=0,num.s9=0;
		for(int i=0;i<len;i++){
			if(s[i]=='0') num.s0++;
			if(s[i]=='6') num.s6++;
			if(s[i]=='8') num.s8++;
			if(s[i]=='9') num.s9++;
		}
		ans=(long long)len*(len+1ll)/2+1ll;
		ans-=(long long)num.s0*(num.s0+1ll)/2;
		ans-=(long long)num.s8*(num.s8+1ll)/2;
		ans-=(long long)num.s6*num.s9;
		if(num.s6==len||num.s9==len) ans--;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---


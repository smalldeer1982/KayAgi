# [NICA #1] 上大分

## 题目背景

小 T 喜欢打 CF。

## 题目描述

小 T 获得了预知能力，能预知自己后面 $n$ 场比赛的表现分。

下面是表现分的定义：

- 记小 T 在参加这场比赛前账号的分数是 $i$，他这场的表现分为 $j$，那么打完这场之后他的账号分数是 $i+\lfloor\frac{j-i}{4}\rfloor$ 。
- 其中 $\lfloor x\rfloor$ 表示对 $x$ 下取整，如 $\lfloor 1.9\rfloor=1,\lfloor -1.3\rfloor=-2$。

但是小 T 只有一个账号，初始分数是 $x$。他决定从未来的 $n$ 次比赛中选择**不超过** $k$ 次参加，同时，这些比赛的类型不同，具体分为两类，这些类型会给出：

- division 1：不管小 T **当前的分数**是多少，都可以参加。
- division 2：只有小 T **当前的分数** $< 1900$，他才能参加。
- 注意，**当前的分数**为这次比赛前的分数，而不是初始分数。**当前的分数**会随着小 T 之前选择参加比赛的策略变动而变动。

他希望自己在所有比赛结束后得分最高，请你来帮他规划一下，在最优决策下，参加完选出的比赛后能获得的最高分数是多少。



## 说明/提示

#### 【样例解释 2】

两场都打。

#### 【数据范围】

对于 $100\%$ 的数据，满足 $0\leq x,a_i\leq 4000$，$n,k\leq 5000$，$1\leq k\leq n$。

## 样例 #1

### 输入

```
2 2 1900
2 1899
2 4000```

### 输出

```
1900```

## 样例 #2

### 输入

```
2 2 1900
1 1899
2 4000```

### 输出

```
2424```

# 题解

## 作者：MTFlowCzq (赞：8)

通过数低？没有题解？那我来写一篇吧（~~B 题库的题都这么难了？~~）

# 题目大意

[题目传送门](https://www.luogu.com.cn/problem/B3803)

有 $n$ 场比赛，你准备选不超过 $k$ 场来打，你希望打完以后比赛分最高，初始为 $x$。

你预知了每场比赛打完后的表现分，设打比赛之前的比赛分为 $i$，表现分为 $j$，则打完后比赛分会更新为 $i+\lfloor\frac{j-i}{4}\rfloor$。除此之外，每场比赛有 div1 和 div2 两种类型，div2 的比赛只有在打比赛前的比赛分小于 $1900$ 时才能参与。

写程序求出最高比赛分。

# 解题思路

先说一句，尽管题目没有明确说，打比赛的顺序是不能调换的（常识好吧），并且别忘了限制了参加场数。

简单的贪心是不凑效的，因为样例已经给出了一组先减分再加分的数据。容易发现难点在于 div 类型的处理。

如果不考虑 div2 限分，那么使用**动态规划**即可解决问题，令 $f_{i,j}$ 为前 $i$ 场中打 $j$ 场比赛的最高分，那么第 $i+1$ 场比赛可以不打，也可以打了上分（容易发现表现分相同时，初始分越高，打完分数越高），转移方程为：

$$f_{i,j}=\max(f_{i-1,j},x+\lfloor\frac{a_i-x}{4}\rfloor),\ x=f_{i-1,j-1}$$

而在加入类型之后，可以强制下分来打 div2，那么是否可以再维护小于 $1900$ 的最高分呢？思考后会发现难以转移（新的小于 $1900$ 的最高分可能由更小的分数转移得到），这样做似乎不行。一种想法是用 $ok_{i,j,p}=0/1$ 表示前 $i$ 场比赛参加 $j$ 场且分数为 $p$ 的可行性，但这样三维的状态会超时，需要二维的。

经过思考以后，我们发现，可以**反过来设计状态**，将题目的**限制**和**要求**的得分**颠倒**（经典的 DP 优化手段），变为“要达到一定的分数，至少需要打多少比赛”。于是我们令 $dp_{i,j}$ 为前 $i$ 场比赛中分数恰为 $j$ 时最少的比赛场数。这样，我们就可以用 $dp_{i-1,j}$ 来更新 $dp_{i,j+\lfloor\frac{a_i-j}{4}\rfloor}$ 了，转移式为：

$$dp_{i,x}=\min(dp_{i,x},dp_{i-1,j}+1),\ x=j+\lfloor\frac{a_i-j}{4}\rfloor$$

而对 div2 的比赛，只需加上 $j<1900$ 的限制条件即可。最后找出最大的满足 $dp_{n,j}\le k$ 的 $j$，就是答案。

由于比赛分不会超过 $\max(a_i,x)$，状态数是 $n\max(a_i,x)$，时间复杂度是 $O(n\max(a_i,x))$。由于 $n\le5000$，$a_i,x\le4000$，可以通过本题。

# 代码

值得一提的是，空间可以使用滚动数组优化，但此时需要注意更新顺序（类似 0-1 背包，每场比赛只能打一次，所以先更新靠近 $a_i$ 的部分）

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,k,x,dp[4009],id,a;
int main() {
	cin>>n>>k>>x;
	for (int i=0;i<=4000;i++)
		dp[i]=10009; //初设为 INF，大于 n 即可
	dp[x]=0; //一场比赛都不打
	while (n--) {
		cin>>id>>a;
		int m=4000; if (id==2) m=1899; //参与比赛的比赛分限制
		for (int i=a+1;i<=m;i++) { //此处注意两个循环的遍历顺序
			int now=i-(i-a+3)/4; //计算打完后的分数
			dp[now]=min(dp[now],dp[i]+1); //试图更新
		}
		for (int i=min(m,a-1);i>=0;i--) {
			int now=i+(a-i)/4;
			dp[now]=min(dp[now],dp[i]+1);
		}
	}
	for (int i=4000;i>=0;i--)
		if (dp[i]<=k) { //找答案
			cout<<i<<endl; break;
		}
	return 0;
}
```

---

本人第一篇题解，如有问题和建议欢迎指出！

---

## 作者：What__can__I__say (赞：2)

考虑DP。

本题瓶颈最主要就是状态的设计。蒟蒻天马行空想象过许多两三维的状态均在状态转移时就无功而返。后来 ~~ctj~~ 发现分数最多才 $4000$。故我们可以考虑设 $f_i$ 为分数 $i$ 最少打几场比赛可以取得。

每次输入后枚举可能的当前分数 $i$，随后依题意计算当前分数为 $i$，当次比赛表现分为 $a$ 情况下打完比赛后的分数，记为 $now$，则比较 $f_{now}$（不打这次比赛）与 $f_i+1$（打这次比赛）的大小，将 $f_{now}$ 记为两者的较小值。注意当 $dv$ 为 $2$ 时当前分数 $i$ 的上限为 $1899$。

最后寻找答案时从大到小枚举，找到一个 $f$ 值小于 $k$ 的，即为答案。

初始化 $f$ 数组为极大值，特别的，小 T 账号初始分数只需打 $0$ 次比赛即可，也就是 $f_x$ 为 $0$。

附上代码 ~~（话说这题就TM两个测试点？）~~：
```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define pii pair<int,int>
#define mk make_pair
#define mod 1000000007
using namespace std;
il int rd(){
    int jya=0,tl=1;char jyt=getchar();
    while(!isdigit(jyt)){if(jyt=='-')tl=-1;jyt=getchar();}
    while(isdigit(jyt)){jya=(jya<<1)+(jya<<3)+(jyt-'0');jyt=getchar();}
    return jya*tl;
}
il void wr(int jjy){
    if(jjy<0)putchar('-'),jjy=-jjy;
    if(jjy>9)wr(jjy/10);
    putchar(jjy%10+48);
}
il int max(int x,int y){return x>=y?x:y;}
il int min(int x,int y){return x<=y?x:y;}
const int JYAAKIOI=1145141919810;
int n,k,x,dv,a,f[10086],m;
signed main(){
	memset(f,0x3f,sizeof f);
	n=rd();k=rd();x=rd();
	f[x]=0;
	while(n--){
		dv=rd();a=rd();
		m=(dv==1?4000:1899);//确定上限
		for(int i=a+1;i<=m;++i){
			int now=i-ceil((i-a)*1.0/4);//计算分数
			f[now]=min(f[now],f[i]+1);
		}
		for(int i=min(m,a-1);i>=0;--i){
			int now=i+(a-i)*1.0/4;//计算分数
			f[now]=min(f[now],f[i]+1);
		}
	}
	for(int i=4000;i>=1;--i){
		if(f[i]<=k){
			wr(i);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：koukou (赞：2)

最近刚学dp，来写一篇题解。

我们不妨定义 $dp_i,_j$ 为到了第 $i$ 场比赛，参加了 $j$ 场时的最高分数。

若不参加这场比赛，则 $dp_i,_j$ 为 $dp_{i-1},_j$。

若参加这场比赛，则 $dp_i,_j$ 为 $dp_{i-1},_{j-1}+\lfloor\frac{a_i-dp_{i-1},_{j-1}}{4}\rfloor$，但是这里有 division 2，所以需判断 $dp_{i-1},_{j-1}$ 是否小于 $1900$。

再讲初始化，$dp_0,_0=x$。

最后是答案，及在 $dp_n,_0$ 到 $dp_n,_k$ 之间去最大值即可。

### code:


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e3 + 1;
int n, k, x, ans = -1e9, dp[N][N];
struct node
{
	int x, c;
}s[N];
int main()
{
	cin >> n >> k >> x;
	for(int i = 1; i <= n; i++)
	{
		cin >> s[i].x >> s[i].c;
	}
	dp[0][0] = x;//初始化
	for(int i = 1; i <= n; i++)
	{
		for(int j = 0; j <= min(i, k); j++)
		{
			if(j == 0)
			{
				dp[i][j] = dp[i - 1][j];
			}
			else if(s[i].x == 1 || s[i].x == 2 && dp[i - 1][j - 1] < 1900)
			{
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + (int)floor((s[i].c - dp[i - 1][j - 1]) / 4.0));
			}
			else
			{
				dp[i][j] = dp[i - 1][j];
			}//状态转移
		}
	}
	for(int i = 0; i <= k; i++)
	{
		ans = max(ans, dp[n][i]);
	}//答案
	cout << ans;
	return 0;
}
```

---

## 作者：Zheng_iii (赞：2)

## 思路
看到这道题首先考虑贪心和动态规划。

贪心是不行的，因为这里有先减分再加分的数据，也就是说故意在 div1 的比赛掉分，使得下一次能够打 div2 加更多的分。

我们考虑动态规划，我们用 $f[i][j]$ 表示在前 $i$ 场比赛中得 $j$ 分至少需要打几场比赛，就可以轻易推出这题的转移方程。

 $$dp[i][x] = \min(dp[i][x], dp[i-1][j] + 1)\text{ , } x = j + \lfloor \frac{a-j}{4} \rfloor$$ 

我们再进行滚动数组优化，就可以得到这道题的正解了。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,x,dp[4010];
int main() {
	cin>>n>>k>>x;
	memset(dp,0x3f,sizeof(dp));
	dp[x]=0;
	while(n--){
		int t,a;
		int m = 4000;
		cin>>t>>a;
		if(t==2)m=1899;
		for(int j=a+1;j<=m;j++){
			int x=j-(j-a+3)/4;
			dp[x]=min(dp[x],dp[j]+1);
		}
		for(int j=min(m,a-1);j>=0;j--){
			int x=j+(a-j)/4;
			dp[x]=min(dp[x],dp[j]+1);
		}
	}
	for(int i=4000;i>=0;i--)if(!(dp[i]>k)){
		cout<<i;
		break;
	}
	return 0;
}
```

---

## 作者：Henly_Z (赞：2)

## 题目大意

$n$ 场比赛中，可以选择 $k$ 场，初始分数为 $x$，任何条件都可以打 DIV1 的比赛，分数 $<1900$ 才可以打，每次增加的分数为：$i + \left \lfloor (j - i) / 4 \right \rfloor  $ 
## 解题思路
看到前面那些大佬的题解，我发现有些地方有~~一点点复杂~~，所以说，我绞尽脑汁想出了一个~~容易懂~~的方法。
### 好了，不废话了，看思路
首先建一个 dp 数组，就像这个 dp[i][j] ，其中 $i$ 表示下标， $j$ 表示选择或者不选择我这里是 $0$ 不选，$1$ 选，所以说第一条递推式就是：


------------

 $ dp[i][0] = \max (dp[k][0],dp[k][1],dp[i][0])$ , $0 < k < i$ 


------------
接下来是选的情况，~~很简单~~，这时，我们就要考虑会不会超越 $k$ 的情况，所以说，我开了一个结构体记录每个情况下的选择数量，然后判断每一个是不是 DIV2，就判断与处理，所以说就有了第二段代码。

------------
### 以下的是假如上一个选的情况下的代码。
```cpp
if(dp[j][1].y < k){
	if(a[i].x == 1){
		if(dp[j][1].x + (a[i].y - dp[j][1].x) / 4 > dp[i][1].x){
			dp[i][1].x = dp[j][1].x + (a[i].y - dp[j][1].x) / 4 ;
			dp[i][1].y = dp[j][1].y + 1;	
			}
		}
		else{
			if(dp[j][1].x < 1900){
				if(dp[j][1].x + (a[i].y - dp[j][1].x) / 4 > dp[i][1].x){
					dp[i][1].x = dp[j][1].x + (a[i].y - dp[j][1].x) / 4 ;
					dp[i][1].y = dp[j][1].y + 1;	
				}
			}
		}
}
`````
### 然后上一个不选的情况下也同理就可以写出来。
```cpp
if(dp[j][0].y < k) {
	if(a[i].x == 1) {
		if(dp[j][0].x + (a[i].y - dp[j][0].x) / 4 > dp[i][1].x) {
			dp[i][1].x = dp[j][0].x + (a[i].y - dp[j][0].x) / 4 ;
			dp[i][1].y = dp[j][0].y + 1;
		}
	} else {
		if(dp[j][0].x < 1900) {
			if(dp[j][0].x + (a[i].y - dp[j][0].x) / 4 > dp[i][1].x) {
				dp[i][1].x = dp[j][0].x + (a[i].y - dp[j][0].x) / 4 ;
				dp[i][1].y = dp[j][0].y + 1;
			}
		}
	}
}
`````
其中 $j$ 就是上文的 $k$，其中 $0<j<i$。


------------
最后，直接暴力寻找一遍即可。
### 接下来就到了激动人心的代码。
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n , k , x;
struct xx{
	int x , y;
}a[5005];
xx dp[5005][2];
xx cmp(xx a , xx b){//比较处理哪一个更大 
	if(a.x > b.x){
		return a;
	}
	return b;
}
int main(){
	cin >> n >> k >> x;
	for(int i = 1 ; i <= n ; i++){
		cin >> a[i].x >> a[i].y;//按照文中输入结构体 
	}
	dp[1][0].x = x;//提前处理初始分数 
	dp[1][1].x = x;//提前处理初始分数 
	for(int i = 1 ; i <= n ; i++){//每个枚举 
		
		for(int j = 1 ; j < i ; j++){//枚举前面的可行方案 
			dp[i][0] = cmp(dp[j][1] , dp[j][0]);//dp[i][0]可以直接判断处理 
			if(dp[j][1].y < k){
				if(a[i].x == 1){
					if(dp[j][1].x + (a[i].y - dp[j][1].x) / 4 > dp[i][1].x){
						dp[i][1].x = dp[j][1].x + (a[i].y - dp[j][1].x) / 4 ;
						dp[i][1].y = dp[j][1].y + 1;	
					}
				}
				else{
					if(dp[j][1].x < 1900){
						if(dp[j][1].x + (a[i].y - dp[j][1].x) / 4 > dp[i][1].x){
							dp[i][1].x = dp[j][1].x + (a[i].y - dp[j][1].x) / 4 ;
							dp[i][1].y = dp[j][1].y + 1;	
						}
					}
				}
			}
			if(dp[j][0].y < k){
				if(a[i].x == 1){
					if(dp[j][0].x + (a[i].y - dp[j][0].x) / 4 > dp[i][1].x){
						dp[i][1].x = dp[j][0].x + (a[i].y - dp[j][0].x) / 4 ;
						dp[i][1].y = dp[j][0].y + 1;	
					}
				}
				else{
					if(dp[j][0].x < 1900){
						if(dp[j][0].x + (a[i].y - dp[j][0].x) / 4 > dp[i][1].x){
							dp[i][1].x = dp[j][0].x + (a[i].y - dp[j][0].x) / 4 ;
							dp[i][1].y = dp[j][0].y + 1;	
						}
					}
				}
			}
		}
		
	}
	int maxm = 0;
	for(int i = 1 ; i <= n ; i++){
		maxm = max(maxm , max(dp[i][0].x , dp[i][1].x));//遍历寻找最大数 
	}
	cout << maxm;
}
`````

---

## 作者：liheyang123 (赞：1)

## solution
注意到空间要求不高，可以直接按照题意设计状态。

那么可以设计 $dp_{i,j}$ 表示在前 $i$ 场比赛，参加且仅参加 $j$ 场比赛的最大比赛分。

为了方便表示，笔者用 $c_i$ 表示第 $i$ 场比赛的表现分 $type_i$ 表示第 $i$ 场比赛的类型。

通过一些穷举 $dp_{i,j} - c_i$ 对 $4$ 取模的七种情况（$[-3, 3]$），可以得出比赛的参加顺序不影响结果。

最后状态转移方程。
```cpp
//在这段代码中a[i].fi 是 solution 中的type[i]
//在这段代码中a[i].se 是 solution 中的c[i]
dp[i][0] = dp[i - 1][0];
//略
if(a[i].fi == 1 || (a[i].fi == 2 && dp[i - 1][j - 1] < 1900))
				dp[i][j] = max(dp[i - 1][j], 
				dp[i - 1][j - 1] + (a[i].se > dp[i - 1][j - 1] ? 
				(a[i].se - dp[i - 1][j - 1]) / 4 : 
				(a[i].se - dp[i - 1][j - 1] - 3) / 4 ));
else dp[i][j] = dp[i - 1][j];
```
笔者的向下取整是手写的，读者可以用以下代码。
```cpp
(int(floor(x)))
```

代码很简单，故不展示。

---

## 作者：xzy_AK_IOI (赞：1)

相信大家都看了题目吧，没看题目的[点这里](https://www.luogu.com.cn/problem/B3803)。
## 考虑算法

思路肯定是 dp，贪心做不了，如果使用贪心思路：  
能上分的比赛就打，那么就有一种情况可以 HACK 它：   
这场比赛故意掉分，使下一场 div2 的比赛能打而加更多分。  

## DP思路
我们不妨设 $dp_{i,j}$ 为**考虑到第 $i$ 场比赛，打了 $j$ 场比赛时**的最高等级分。


如果不考虑div2的等级分上限，这题就很好做。  
- 当不打这场比赛时，等级分就为考虑到前一场比赛的等级分：

  $$dp_{i,j}=dp_{i-1,j }$$
- 当打这场比赛时，等级分就为考虑到前一场比赛且少打了一场比赛时的等级分：

   $$dp_{i,j}=x+\lfloor \frac{a_i-x}{4}\rfloor,x=dp_{i-1,j-1}$$
等级分为两者最大值。  
稍微一想就可以发现，在打这场比赛时加一个特判就可以处理 div2 的等级分上限。  
如果这场比赛为 div2，则要 $dp_{i-1,j-1} \ge 1900$ 时才能转移。所以转移方程为：
$$dp_{i,j}=\max(dp_{i-1,j},x+\lfloor \frac{a_i-x}{4}\rfloor),x=dp_{i-1,j-1}(j \ne 0)$$
## 边界及输出
边界条件：$dp_{0,0}=x$。  
输出：所有 $dp_{n,i}(0 \le i \le k)$ 的最大值。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+10;
int dp[N][N];
int a[N],b[N];
int n,k,x;
int main(){
	cin>>n>>k>>x;
	for (int i=1;i<=n;i++) cin>>a[i]>>b[i];
	dp[0][0]=x;
	for (int i=1;i<=n;i++){
		for (int j=0;j<=min(k,i);j++){
			dp[i][j]=dp[i-1][j];
			if (((a[i]==2)?(dp[i-1][j-1]<1900):1) && j){
				if (dp[i][j]<dp[i-1][j-1]+(int)floor(double(double(b[i])-double(dp[i-1][j-1]))/4.0)){
					dp[i][j]=dp[i-1][j-1]+(int)floor(double(double(b[i])-double(dp[i-1][j-1]))/4.0);
				}
			}
		}
	}
	int maxn=-1;
	for (int i=0;i<=k;i++) maxn=max(maxn,dp[n][i]);
	cout<<maxn;
	return 0;
}
```

---

## 作者：a_little_carrot (赞：1)

写的不好，敬请谅解。

[题目传送门](https://www.luogu.com.cn/problem/B3803)

## dp解法
### 思路简析
读题，我们发现有两个难点：
1. 常规方法下，需要以 $dp_{i, j, k}$ 表示前 $i$ 场比赛打 $j$ 场而分数恰好为 $k$ 的可行性，然而 $O(n^3)$ 会让你 $T$ 飞。同时假设以 $dp_{i,j}$ 示前 $i$ 场比赛打 $j$ 场的最大分数，就会发现对于 division 2 难以维护。

不难发现，这题关键在于分数的维护，我们可以以 $dp_{i,j}$ 表示恰好为 $i$ 分时前 $j$ 场最少要打的场数。

可以得到转移：

$$dp_{tmp,j}=\max(dp_{tmp,j-1},dp_{i,j-1}+1)$$

其中 $tmp=i + \lfloor \frac{j-s}{4} \rfloor$，$s$  表示当前比赛的分数。

2. division 2 的 $1900$ 分限制很麻烦。

但是，根据我上述的 $dp$ 设计，我们会发现每一个可行的分数都有最少要打的场数，因此我们不用担心是否覆盖。
### 细节处理
只有两点：
1. $dp_{i,j}$ 的初始值需要足够大，同时初始分数的 $dp$ 设为 $0$。
2. $tmp$ 的计算要注意正负。int 类型正数除以正数是向下取整，但负数除以正数就是向上取整了。

注：笔者这里进行了滚筒优化。
### 代码
```
#include "bits/stdc++.h"
using namespace std ;
const int N = 4003 ;
int n, k, x, d, s ;
int dp[N] ;
int main()
{
	ios::sync_with_stdio(false) ;
	cin.tie(0) ; cout.tie(0) ;
	cin >> n >> k >> x ;
	for(int i = 0 ; i <= 4000 ; ++i) dp[i] = N ;
	dp[x] = 0 ;
	for(int i = 1 ; i <= n ; ++i)
	{
		cin >> d >> s ;
		int tmp = 4000 ;
		if(d == 2) tmp = 1899 ;
		for(int j = tmp ; j >= 1 ; --j)
		{
			int tmp2 = j + (s > j ? (s - j) / 4 : (s - j - 3) / 4) ;
			dp[tmp2] = min(dp[tmp2], dp[j] + 1) ;
		}
	}
	for(int i = 4000 ; i >= 1 ; --i)
	{
		if(dp[i] <= k)
		{
			cout << i ;
			break ;
		}
	}
	return 0 ;
}
```

---

## 作者：CEFqwq (赞：1)

练习 dp，找到这道题，调了好一会，感觉这道题还是比较毒瘤的。

这道题状态比较难定义，一种思路是用 `f[i]` 表示打 $i$ 场比赛能得到的最大分数为多少，但是非常难实现。也可以用 `f[i][j]` 表示打 $i$ 场比赛能不能获得 $j$ 分，但时间消耗较大，并且实现也不容易。

看到分数上限是 $4000$，这个时候貌似可以~~奇技淫巧~~另辟蹊径啊！我们用 `f[j]` 表示得 $j$ 分至少需要打几场比赛，就很容易了！

那么，写吧。

```cpp
//本代码部分参考另一篇题解，本题解补充一些实现上的细节，面向萌新
#include<bits/stdc++.h>
using namespace std;
int n,k,s,f[114514],mxx=4000;
int main() {
	cin>>n>>k>>s;
	for(int i=0;i<=mxx;i++)f[i]=(INT_MAX>>1);//注意要右移一位，否则可能会爆 int
	f[s]=0;//初始等级分不用打比赛了
	while(n--){
		int ord,x,m=mxx;
		cin>>ord>>x;
		if(ord==2)m=(1900-1);//注意不要超过上限，div1 上限我们默认取了 4000，为什么呢？因为等级分可能达到 4000，但是不能达到 4001。也就是说，m 的值是上限 -1。所以我们应该设为 1900-1 而不是 1900。
		for(int i=x+1;i<=m;i++){
			int j=i-ceil((i-x)/4.00);//向上取整，这种方法比较好理解，ceil()就是上取整函数。另外一篇题解写的是 i-(i-x+3)/4，也是一种上取整的方法。+3 就是表示只要余数不是 0，商都 +1。
			f[j]=min(f[j],f[i]+1);//多打一场比赛，有些时候 f[j] 已经比 f[i] 小了，不能再更新，否则会出错。
		}
		for(int i=min(m,x-1);i>=0;i--){
			int j=i+(x-i)/4;
			f[j]=min(f[j],f[i]+1);
		}
	}
	for(int i=mxx;i>=0;i--)
		if(!(f[i]>k)){
			cout<<i;//找到能取到的最大值
			return 0;//直接结束程序
		}
}
```

时间复杂度非常低，轻松通过。

这是我的第 30 篇题解，请大家支持 qwq。

---

## 作者：Andy_WA (赞：0)

# B3803 [NICA #1] 上大分
## 题目大意
$n$ 场比赛中，可以选择 $k$ 场，初始分数为 $x$。
+ Div.1 任何条件都可以打 Div.1 的比赛。
+ Div.2 当前分数 $<1900$ 才可以打这场比赛。

每次增加的分数为：$\left\lfloor\frac{a_i−j}{4}\right\rfloor$。

## 题目分析
定义状态，用 $dp_i$ 表示 Rating 变成 $i$ 最少打的比赛数，$x$ 表示当前 Rating 即可得出转移方程：

$$dp_x=\min\left\{dp_x,dp_j+1\right\}$$

此时：
$$x=j+\left\lfloor\frac{a_i−j}{4}\right\rfloor$$

时间复杂度在 $O(n^2)$ 级别。

因为 $n≤5\times 10^3$，所以 $n^2≤25\times 10^6$，可通过。

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MaxN=5e3+10;
long long dp[MaxN];
long long n,k,x;
int main(){
	cin>>n>>k>>x;
	for(long long i=1;i<=4000;i++){
		dp[i]=INT_MAX;
	}
	dp[x]=0;
	for(long long i=1;i<=n;i++){
		long long division,score;
		cin>>division>>score;
		long long MaxScore=(division==1)?4000:1899;
		for(long long j=score+1;j<=MaxScore;j++) {
			long long t=j-(j-score+3)/4;
			dp[t]=min(dp[t],dp[j]+1);
		}
		for(long long j=min(MaxScore,score-1);j>=0;j--) {
			long long t=j+(score-j)/4;
			dp[t]=min(dp[t],dp[j]+1);
		}
	}
	for(long long i=4000;i>=0;i--){
		if(dp[i]<=k){
			cout<<i<<endl;
			return 0;
		}
	}
	return 0;
} 
```

---

## 作者：zhangzirui66 (赞：0)

不错的动态规划题，写篇题解纪念昨晚没打的 CodeForces。
### 不考虑分数限制
如果不考虑 Div.2 的 Rating 限制，可以用一个简单的线性 DP 做，用 $f_i$ 表示打前 $i$ 场比赛所得到最多的 Rating，转移方程：
$$
f_i=\max(f_i,f_{i-1}+\lfloor\frac{a_i-f_{i-1}}{4}\rfloor)
$$
若考虑 Div.2 的 Rating 限制，一种想法是用数组标记哪些比赛可以打，但我们仍然可以通过下分来打 Div.2，不好处理，只能另找方法。
### 考虑分数限制
我们重新定义状态，用 $f_i$ 表示 Rating 变成 $i$ 最少打的比赛数，$x$ 表示当前 Rating 即可得出转移方程：
$$
f_x=\min(f_x,f_j+1),x=j+\lfloor \frac{a_i-j}{4}\rfloor
$$
时间复杂度在 $O(n^2)$ 级别，可通过，状态转移方程经过了滚动数组优化，未经滚动数组优化的状态转移方程和代码见@MTFlowCzq 的题解。

---


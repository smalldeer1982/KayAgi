# [GESP202312 七级] 纸牌游戏

## 题目描述

你和小杨在玩一个纸牌游戏。

你和小杨各有 $3$ 张牌，分别是 $0、1、2$。你们要进行 $N$ 轮游戏，每轮游戏双方都要出一张牌，并按 $1$ 战胜 $0$，$2$ 战胜 $1$，$0$ 战胜 $2$ 的规则决出胜负。第 $i$ 轮的胜者可以获得 $2 \times a_i$ 分，败者不得分，如果双方出牌相同，则算平局，二人都可获得 $a_i$ 分 $(i=1,2,\cdots,N)$。

玩了一会后，你们觉得这样太过于单调，于是双方给自己制定了不同的新规则。小杨会在整局游戏开始前确定自己全部 $n$ 轮的出牌，并将他的全部计划告诉你；而你从第 $2$ 轮开始，要么继续出上一轮出的牌，要么记一次“换牌”。游戏结束时，你换了 $t$ 次牌，就要额外扣 $b_1+\cdots+b_t$ 分。

请计算出你最多能获得多少分。

## 说明/提示

**样例解释 1**

你可以第 $1$ 轮出 $0$，并在第 $2,3$ 轮保持不变，如此输掉第 $1,2$ 轮，但在第 $3$ 轮中取胜，获得 $2×10=20$ 分；

随后，你可以在第 $4$ 轮中以扣 $1$ 分为代价改出 $1$ ，并在第 $4$ 轮中取得胜利，获得 $2×100=200$ 分。

如此，你可以获得最高的总分 $20+200-1=219$。

**数据范围**

对于 $30\%$ 的测试点，保证 $N\le15$。

对于 $60\%$ 的测试点，保证 $N\le100$。

对于所有测试点，保证 $N \le 1,000$；保证 $0 \le a_i,b_i \le 10^6$。

## 样例 #1

### 输入

```
4
1 2 10 100
1 100 1
1 1 2 0```

### 输出

```
219```

## 样例 #2

### 输入

```
6
3 7 2 8 9 4
1 3 9 27 81
0 1 2 1 2 0```

### 输出

```
56```

# 题解

## 作者：WsW_ (赞：25)

### 更新
这是一篇已通过的题解。

- $2025.01.20$ 改正错别字，改正手误写错的转移方程，更新部分表述。


---
### 思路
因为游戏一轮一轮地进行，所以考虑 dp。  
定义 $dp_{i,j,k}$ 表示游戏进行到第 $i$ 轮，此时已经换了 $j$ 次牌，当前手牌为 $k$ 的最大分数。  

记第 $i$ 轮出 $k$ 可以获得 $add$ 分。  
观察题面规律，
* $c_i=k$ 时，平，$add\gets a_i$。  
* $(c_i+1)\bmod 3=k$ 时，赢，$add\gets 2\times a_i$。  
* $(k+1)\bmod 3=c_i$ 时，输，$add\gets 0$。  


再考虑有几种转移路径。  

* 不换牌。那么说明第 $i-1$ 轮即上一轮，出的也是 $k$。$dp_{i,j,k}=dp_{i-1,j,k}+add$。
* 换牌。那么说明第 $i-1$ 轮即上一轮，出的是 $(k+1)\bmod3$ 或 $(k+2)\bmod3$。$dp_{i,j,k}=\max(dp_{i-1,j-1,(k+1)\bmod3},dp_{i-1,j-1,(k+2)\bmod3})$。  

根据题意，第 $1$ 轮必定不换牌。  
所以，在 $i$ 轮中最多换牌 $i-1$ 次，当 $j=i-1$ 时一定是每一轮都换了牌，上一轮就必定换了牌。   

需要枚举 $n$ 轮，每轮 $n-1$ 种换牌情况，每种换牌情况可能有 $3$ 种出牌。  
故时间复杂度为 $O(n^2)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[1003],b[1003],c[1003];
int dp[1003][1003][3];//dp[i][j][k]：进行到第i轮，换了j次牌，牌为k的最大得分 
int ans;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++)cin>>b[i];
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<=n;i++){//枚举轮 
		for(int j=0;j<i;j++){//枚举本轮换牌次数（到第i轮最多换了i-1次牌） 
			for(int k=0;k<3;k++){//枚举出的牌 
				int add=0,tt=-2e9;
				if((c[i]+1)%3==k)add=(a[i]<<1);//赢 
				if(c[i]==k)add=a[i];//平 
				if(j<i-1||i==1)tt=max(tt,dp[i-1][j][k]);//不换牌 
				if(j>0)tt=max(tt,max(dp[i-1][j-1][(k+1)%3],dp[i-1][j-1][(k+2)%3])-b[j]);//换牌 
				dp[i][j][k]=tt+add;//加上这局的分 
			}
		}
	}
	for(int i=0;i<n;i++){
		ans=max({ans,dp[n][i][0],dp[n][i][1],dp[n][i][2]});
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Su777 (赞：9)

[P10111 纸牌游戏](https://www.luogu.com.cn/problem/P10111)

upd 2024.6.16：将代码中变量名与题解中统一，并添加关于 $k=0$ 时数组越界问题的解释。

## 题意描述

一个纸牌游戏有 $0,1,2$ 三种纸牌，规则为 $1$ 胜 $0$，$2$ 胜 $1$，$0$ 胜 $2$。对于每场比赛，如果赢了就加 $2 \times a_i$ 分，平局就加 $a_i$ 分，输了不加分。现在你的对手告诉了你他 $n$ 轮的出牌方案（记对手第 $i$ 轮出 $d_i$ 牌）。你可以任意出牌，但是在第二轮之后如果一轮出的牌与上一轮不一致，就记作一次换牌，最终如果有 $t$ 次换牌则需要扣 $b_1+…+b_t$ 分。

## 解法思路

因为既要考虑加分又要考虑换牌带来的扣分，考虑动态规划。

**状态定义**：$f_{i,j,k}$ 表示第 $i$ 轮出 $j$ 牌，换牌 $k$ 次的最大分数。

**初始状态**：当 $i=0$ 时，无论 $j,k$ 取什么值，答案都为 $0$。因为 $f$ 数组自动全部置 $0$，不需要人工初始化。

**状态转移**：因为游戏的获胜条件较为复杂，我们把对手出牌（设对手第 $i$ 轮出 $d_i$ 牌）的三种情况分开讨论，此处只考虑 $d_i=0$ 的情况，后面两种情况与之类似。

当 $d_i=0$ 时，如果出 $0$ 就会平局，出 $1$ 就会胜，出 $2$ 就会败。因此对于三种情况分别列出转移方程。

- 当第 $i$ 轮出 $0$ 时，**这一轮必定为平局**，状态表示为 $f_{i,0,k}$，此时可以由第 $i-1$ 轮出 $0$，然后不换牌转移而来，也可以由第 $i-1$ 轮出 $1$ 或 $2$，然后换牌 $k-1$ 轮转移而来。
  $$f_{i,0,k}=\max (f_{i-1,0,k},f_{i-1,1,k-1},f_{i-1,2,k-1})+a_i$$

- 当第 $i$ 轮出 $1$ 时，**这一轮必定为胜局**，状态表示为 $f_{i,1,k}$，此时可以由第 $i-1$ 轮出 $1$，然后不换牌转移而来，也可以由第 $i-1$ 轮出 $0$ 或 $2$，然后换牌 $k-1$ 轮转移而来。
  $$f_{i,1,k}=\max (f_{i-1,0,k-1},f_{i-1,1,k},f_{i-1,2,k-1})+2\times a_i$$

- 当第 $i$ 轮出 $2$ 时，**这一轮必定为败局**，状态表示为 $f_{i,2,k}$，此时可以由第 $i-1$ 轮出 $2$，然后不换牌转移而来，也可以由第 $i-1$ 轮出 $0$ 或 $1$，然后换牌 $k-1$ 轮转移而来。
  $$f_{i,2,k}=\max (f_{i-1,0,k-1},f_{i-1,1,k-1},f_{i-1,2,k})$$

这里我们还需要考虑一个问题，当 $k=0$ 时按照上述转移方程会访问到数组下标 $-1$，造成 RE。在这种情况下，因为没有进行过换牌，第 $i-1$ 轮出牌一定与此轮一样，因此转移方程为 $f_{i,0,k}=f_{i-1,0,k}+a_i$，$f_{i,1,k}=f_{i-1,1,k}+2\times a_i$，$f_{i,2,k}=f_{i-1,2,k}$。

$d_i=2$ 和 $d_i=3$ 的情况请读者自行推导，也可以参考代码。

因为在动态规划过程中并没有考虑到扣分的问题，我们可以预处理扣分数组前缀和（第 $i$ 项记为 $sumb_i$），最终在答案中减掉即可。

最终答案需要枚举第 $n$ 轮出的牌和总共的换牌次数，形式化地表示为：$\max \limits_{0\leq j\leq2∧0<k\leq n} f_{n,j,k}-sumb_k$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll n;
ll a[1005]; // 得分数组 
ll sumb[1005]; // 失分数组（前缀和） 
ll d[1005]; // 对手 n 轮出牌 
ll f[1005][3][1005]; // f[i][j][k]: 第 i 场，出 j，换牌 k 次的最大分数 

int main() {
	cin >> n;
	for (int i = 1; i <= n; i ++) cin >> a[i]; // 得分数组
	for (int i = 1; i < n; i ++) { // 换牌至多只有 n-1 次
		cin >> sumb[i];
		sumb[i] += sumb[i - 1]; // 预处理前缀和
	}
	for (int i = 1; i <= n; i ++) cin >> d[i]; // 输入对手的出牌方案
	
	for (int i = 1; i <= n; i ++) { // 状态转移
		for (int k = 0; k < i; k ++) { // 注意 k 只需要枚举到 i-1
			if (k == 0) {
				if (d[i] == 0) {
					f[i][0][k] = f[i - 1][0][k] + a[i];
					f[i][1][k] = f[i - 1][1][k] + 2 * a[i];
					f[i][2][k] = f[i - 1][2][k];
				} else if (d[i] == 1) {
					f[i][0][k] = f[i - 1][0][k];
					f[i][1][k] = f[i - 1][1][k] + a[i];
					f[i][2][k] = f[i - 1][2][k] + 2 * a[i];
				} else {
					f[i][0][k] = f[i - 1][0][k] + 2 * a[i];
					f[i][1][k] = f[i - 1][1][k];
					f[i][2][k] = f[i - 1][2][k] + a[i];
				}
			} else {
				if (d[i] == 0) {
					f[i][0][k] = max(f[i - 1][0][k], 
					max(f[i - 1][1][k - 1], 
					f[i - 1][2][k - 1]))+ a[i];
					
					f[i][1][k] = max(f[i - 1][0][k - 1], 
					max(f[i - 1][1][k], 
					f[i - 1][2][k - 1])) + 2 * a[i];
					
					f[i][2][k] = max(f[i - 1][0][k - 1], 
					max(f[i - 1][1][k - 1], 
					f[i - 1][2][k]));
				} else if (d[i] == 1) {
					f[i][0][k] = max(f[i - 1][0][k], 
					max(f[i - 1][1][k - 1], 
					f[i - 1][2][k - 1]));
					
					f[i][1][k] = max(f[i - 1][0][k - 1], 
					max(f[i - 1][1][k], 
					f[i - 1][2][k - 1])) + a[i];
					
					f[i][2][k] = max(f[i - 1][0][k - 1], 
					max(f[i - 1][1][k - 1], 
					f[i - 1][2][k])) + 2 * a[i];
				} else if (d[i] == 2) {
					f[i][0][k] = max(f[i - 1][0][k], 
					max(f[i - 1][1][k - 1], 
					f[i - 1][2][k - 1])) + 2 * a[i];
					
					f[i][1][k] = max(f[i - 1][0][k - 1], 
					max(f[i - 1][1][k], 
					f[i - 1][2][k - 1]));
					
					f[i][2][k] = max(f[i - 1][0][k - 1], 
					max(f[i - 1][1][k - 1], 
					f[i - 1][2][k])) + a[i];
				}
			}
		}
	}
	
	// 统计答案
	ll ans = 0;
	for (int k = 0; k < n; k ++) {
		for (int j = 0; j < 3; j ++) {
			ans = max(ans, f[n][j][k] - sumb[k]);
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：lutaoquan2012 (赞：6)

## 思路：
这道题是一道动态规划，我的做法基本上就是枚举和动态规划。

**状态定义**：$dp_{i,j,k}$ 代表的是现在在第 $i$ 轮比赛中，我出了 $j$，已经更换了 $k$ 次牌。

**初始定值**：一律赋值为 $0$。

**状态转移**：我们把对手出的牌和我们出的牌一一列举，枚举答案。$c$ 表示当前对手出的牌，先不考虑用换牌 $k$ 次所需要扣的分。

### 当 $c$ 为 $0$ 的时候，我们枚举我们出牌的所有情况。

1. 如果我们出 $0$，**那么一定平局**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,0,k}$ 的分值是最大的，再加上这一轮平局要加的分。

$$dp_{i,0,k}=\max(dp_{i-1,0,k},dp_{i-1,1,k-1},dp_{i-1,2,k-1})+a_i$$

2. 如果我们出 $1$，**那么一定胜利**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,1,k}$ 的分值是最大的，再加上这一轮胜者得的分。

$$dp_{i,1,k}=\max(dp_{i-1,0,k-1},dp_{i-1,1,k},dp_{i-1,2,k-1})+2 \times a_i$$

3. 如果我们出 $2$，**那么一定失败**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,2,k}$ 的分值是最大的。

$$dp_{i,2,k}=\max(dp_{i-1,0,k-1},dp_{i-1,1,k-1},dp_{i-1,2,k})$$

### 当 $c$ 为 $1$ 的时候，我们枚举我们出牌的所有情况。

1. 如果我们出 $0$，**那么一定失败**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,0,k}$ 的分值是最大的。

$$dp_{i,0,k}=\max(dp_{i-1,0,k},dp_{i-1,1,k-1},dp_{i-1,2,k-1})$$

2. 如果我们出 $1$，**那么一定平局**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,1,k}$ 的分值是最大的，再加上这一轮平局要加的分。

$$dp_{i,1,k}=\max(dp_{i-1,0,k-1},dp_{i-1,1,k},dp_{i-1,2,k-1})+a_i$$

3. 如果我们出 $2$，**那么一定胜利**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,2,k}$ 的分值是最大的，再加上这一轮胜者得的分。

$$dp_{i,2,k}=\max(dp_{i-1,0,k-1},dp_{i-1,1,k-1},dp_{i-1,2,k})+2\times a_i$$

### 当 $c$ 为 $2$ 的时候，我们枚举我们出牌的所有情况。

1. 如果我们出 $0$，**那么一定胜利**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,0,k}$ 的分值是最大的，再加上这一轮胜者得的分。

$$dp_{i,0,k}=\max(dp_{i-1,0,k},dp_{i-1,1,k-1},dp_{i-1,2,k-1})+2\times a_i$$

2. 如果我们出 $1$，**那么一定失败**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,1,k}$ 的分值是最大的。

$$dp_{i,1,k}=\max(dp_{i-1,0,k-1},dp_{i-1,1,k},dp_{i-1,2,k-1})$$

3. 如果我们出 $2$，**那么一定平局**，所以需要枚举出从上一轮哪个地方转移到 $dp_{i,2,k}$ 的分值是最大的，再加上这一轮平局要加的分。

$$dp_{i,2,k}=\max(dp_{i-1,0,k-1},dp_{i-1,1,k-1},dp_{i-1,2,k})+a_i$$

**答案**：我们刚才没有考虑过换牌 $k$ 次所需要扣除得分，所以我们用一个前缀和来表示换牌 $k$ 需要扣的分，最后再把扣完分的所有打玩 $n$ 轮牌的情况取个 $\max$。

## 代码：
```cpp
//
// Created by 55062 on 2024/3/16.
//
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll n,a[1010],b[1010],x,c[1010],pre[1010],dp[1010][50][1010],ans;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<n;i++) cin>>b[i];
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=1;i<=n;i++) pre[i]=pre[i-1]+b[i];
    for(int i=1;i<=n;i++){
        for(int k=0;k<i;k++){
            if(c[i]==0){
                dp[i][0][k]=max({dp[i-1][0][k],dp[i-1][1][k-1],dp[i-1][2][k-1]})+a[i];
                dp[i][1][k]=max({dp[i-1][0][k-1],dp[i-1][1][k],dp[i-1][2][k-1]})+2*a[i];
                dp[i][2][k]=max({dp[i-1][0][k-1],dp[i-1][1][k-1],dp[i-1][2][k]});
            }if(c[i]==1){
                dp[i][0][k]=max({dp[i-1][0][k],dp[i-1][1][k-1],dp[i-1][2][k-1]});
                dp[i][1][k]=max({dp[i-1][0][k-1],dp[i-1][1][k],dp[i-1][2][k-1]})+a[i];
                dp[i][2][k]=max({dp[i-1][0][k-1],dp[i-1][1][k-1],dp[i-1][2][k]})+2*a[i];
            }if(c[i]==2){
                dp[i][0][k]=max({dp[i-1][0][k],dp[i-1][1][k-1],dp[i-1][2][k-1]})+2*a[i];
                dp[i][1][k]=max({dp[i-1][0][k-1],dp[i-1][1][k],dp[i-1][2][k-1]});
                dp[i][2][k]=max({dp[i-1][0][k-1],dp[i-1][1][k-1],dp[i-1][2][k]})+a[i];
            }
        }
    }for(int k=0;k<n;k++) ans=max({ans,dp[n][0][k]-pre[k],dp[n][1][k]-pre[k],dp[n][2][k]-pre[k]});
    cout<<ans;
    return 0;
}
```

---

## 作者：chenmingwang (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P10111)

数据范围：$N \le 1,000$；$0 \le a_i,b_i \le 10^6$；$c_i\in{0,1,2}$。

考虑使用动态规划。

首先考虑二维 dp ，其中 $dp_{i,j}$ 表示在第 $i$ 轮操作时出数字为 $j$ 的牌时最大的牌数，但是我们很容易发现，改变牌的大小的次数也要表示，用二维显然不够，怎么办？

先贤名言：dp 不了，再加一维。

所以，我们再加一维 dp 状态，令 $dp_{i,j,k}$ 表示在第 $i$ 次操作时出数字为 $j$ 的牌，并在此时一共改变了 $k$ 次牌的大小，这样一来，这道题就变成了一道**三维  dp** 题。

那么接下来考虑状态转移方程（其中 $i$、$j$、$k$ 的含义与上文所述相同）。

- 若 $k=0$ （即选择数字没有任何变化），那么 $dp_{i,j,k}=dp_{i-1,j,k}+pts$（$pts$ 表示如果选择数字 $j$ 那么在这轮的得分，下同）；

- 若 $k=i-1$（即每次的数字都发生了变化），那么有：$dp_{i,j,k}=\max\{dp_{i-1,l,k-1}\}-b_k+pts.(0\le l \le 2,l\neq j)$。

- 若 $1 \le k \le i-2$，（即有些时候数字发生了变化，有些时候没有），此时的我们可以根据第二种情况拓展出来，继续分出两种情况：

   - 若在这次出牌时，没有改变牌的大小，那么此时的总分数为：$dp_{i-1,j,k}+pts$。
   - 若在这次出牌时，改变了牌的大小，那么此时的总分数最大值与情况二相同，为：$\max\{dp_{i-1,l,k-1}\}-b_k+pts.(0\le l \le 2,l\neq j)$。
   
   而在这种情况下，$dp_{i,j,k}$ 的最大值就是上面两种小情况中的大值。
   
请注意以下几个坑点：

- $b$ 数组并不是指在第 $i$ 与 $i+1$ 次出的牌不同所花的分数，它是每次需要累加的，否则也没必要增加一个维度了。

- 注意 $dp$ 数组所赋的初值。

- 注意特判 $k=0$ 和 $k=i-1$ 的情况。
   
时间复杂度：$O(n^2)$，可以通过本题。

以上就是大致的分析，更多细节详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,k,l,dp[1005][3][1005],a[1005],b[1005],c[1005],pts,max1;
bool last[1005];
long long win(long long k)//返回能赢下牌为k的牌 
{
	if(k==0) return 1;
	if(k==1) return 2;
	if(k==2) return 0;
}
int main()
{
	memset(dp,128,sizeof(dp));//将dp数组初始成一个很小的负数，因为中途如果分值可能会因b的极大而小于0 
	scanf("%lld",&n);
	for(i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(i=1;i<n;i++) scanf("%lld",&b[i]);
	for(i=1;i<=n;i++) scanf("%lld",&c[i]);
	for(i=0;i<=2;i++)//特判第一轮的情况 
	{
		if(i==c[1]) dp[1][i][0]=a[1];
		else if(win(c[1])==i) dp[1][i][0]=a[1]*2;
		else dp[1][i][0]=0;
	}
	for(i=2;i<=n;i++)//第几轮 
	{
		for(j=0;j<=2;j++)//这次选择数字几 
		{
			if(j==c[i]) pts=a[i];
			else if(j==win(c[i])) pts=a[i]*2;
			else pts=0;//选择数字j能收获的分数
			for(k=0;k<i;k++)//变化多少次 
			{
				if(k<i-1) dp[i][j][k]=dp[i-1][j][k]+pts;//特判k=i-1的情况
				if(k==0) continue;//不用进行接下来的操作 
				for(l=0;l<=2;l++)//上一次的选择 
				{
					if(l!=j) dp[i][j][k]=max(dp[i][j][k],dp[i-1][l][k-1]-b[k]+pts);//状态转移方程 
				}
		    }
		}
	}
	/*
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=2;j++)
		{
			for(k=0;k<i;k++) printf("i:%lld j:%lld k:%lld %lld\n",i,j,k,dp[i][j][k]);
			puts("");
		}
		puts("");
	}
	*/
    for(j=0;j<=2;j++) for(k=0;k<n;k++) max1=max(max1,dp[n][j][k]);//不要遍历整个dp表，要遍历最后一轮时的所有的情况 
    printf("%lld",max1);
	return 0;
 } 
//dp[i][j][k] i：表示第几轮 j：表示选择数字j k：表示变化了多少次 

```


---

## 作者：Ghosty_Neutrino (赞：4)

[题目传送门。](https://www.luogu.com.cn/problem/P10111)

### 题意
$N$ 局游戏，每局出牌 $0$ $1$ $2$ 且 $2>1>0$ 但很特殊的 $0>2$。
第 $i$ 局，胜得 $a_i$ 分，败得 $0$ 分。
已知对方面前 $n$ 轮的出牌。我方如果某轮和上轮牌面不一致（换牌），则如果是第 $i$ 次换牌，扣 $b_i$ 分。
求我方最大得分。
### 思路
考虑第 $i$ 轮，我方出牌可能是 $0$ $1$ $2$ 其中之一，那么状态定义需要 $2$ 个维度：轮数，牌面值。

要再考虑状态：我放上一轮出牌的牌面值，那么有 $2$ 种可能，上一轮出牌和本轮牌面相同，以及牌面不同。考虑牌面不同，发现需要知道上一轮换牌的次数，因此状态设计加一个维度：换牌次数。
### 状态定义
$f_{i,j,c}$ 第 $i$ 轮，出牌 $0$ $1$ $2$，换了c次牌的最优解。
### 状态转移
枚举我方第 $i$ 轮出牌（用 $t$ 枚举），第 $i-1$ 轮的出牌（用 $k$ 枚举），以及到第 $i-1$ 轮出 $k$ 时的换牌次数（用 $l$ 表示）。
#### 情况一
当 $t=k$ 时
$$
f_{i,t,l}=max(f_{i,t,l},f_{i-1,k,l},f_{i,t,l}+get(c_i,t,i))
$$
#### 情况二
当 $t$ 不等于 $k$
$$
f_{i,t,l+1}=max(f_{i,t,l+1},f_{i-1,k,l},f_{i,t,l}+get(c_i,t,i)-b_l+1)
$$
### 最后才是代码

```cpp
//别 chao 我的代码啊
#include<bits/stdc++.h>//这是万能的
using namespace std;
const int N=1010;
int f[N][3][N];//f[i][j][k]:第i轮，出牌0,1,2，换了k次牌的最优解
int a[N],b[N],c[N];
int sumb[N];
int n;
//小杨出yang，我出me的得分（杨幂哈哈）
int get(int yang,int me,int i){
	if(yang==me) return a[i];
	else if(yang==2 && me==0 || yang==1 && me==2 || yang==0 && me==1) return a[i]*2;
	else return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n-1;i++) cin>>b[i];
	for(int i=1;i<=n;i++) cin>>c[i];
	memset(f,0xaf,sizeof(f));//初始化为无穷大

        //边界
        //枚举第一轮，我可能出牌
	for(int i=0;i<=2;i++) f[1][i][0]=get(c[1],i,1);
        //第二轮dp启动
	for(int i=2;i<=n;i++){ //枚举我上一把出k时的换牌次数，到第i-1把，最多换i-2次牌
		for(int k=0;k<=2;k++){ //枚举我这一把的出牌
			for(int l=0;l<=i-2;l++){
				for(int t=0;t<=2;t++){
                                        //上一把到这一把没有换牌
					if(k==t) f[i][t][l]=max(f[i][t][l],f[i-1][k][l]+get(c[i],t,i));
                                        //牌不一样，换牌了嗷
					else f[i][t][l+1]=max(f[i][t][l+1],f[i-1][k][l]+get(c[i],t,i)-b[l+1]);
				}
			}
		}
	}
        //答案驾到，求出来就行
	int ans=INT_MIN;
	for(int i=0;i<=2;i++){
		for(int j=0;j<=n-1;j++){
			ans=max(ans,f[n][i][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
```
蒟蒻第一次发题解，管理员求放过。

---

## 作者：xiaozhangawa (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10111)

upd on 2024.6.20：修改了状态转移方程的推理过程和状态转移方程不对的地方。

------------

## 思路

~~从标签~~从题面不难看出，这道题需要使用 dp。  
所以我们就按照 “dp 三部曲”来求解。

### 1.定义状态

首先，最容易想到的当然是设 $dp_i$ 为前 $i$ 轮的最大得分，但是我们会发现，光用一维的 $dp_i$ 来表示，是远远不够的。

然后，我们考虑**二维 dp**。因为跟得分有关的还有**出的牌**。新的状态无非就是 $dp_{i,j}(j\in \{0,1,2\})$ 表示前 $i$ 轮，在第 $i$ 轮出 $j$ 号牌时的最大得分嘛！如果这个你能理解，那么非常棒，你已经离~~第一步的~~成功不远了！

当你兴致勃勃的用这个思路写代码时，你会发现还是不够。我们只好使用**三维 dp**。因为换牌会导致扣分，所以状态应改为：$dp_{i,j,k}$ 表示前 $i$ 轮，在第 $i$ 轮出 $j$ 号牌，此时已经换了 $k$ 次牌时的最大得分。

很好！那么我们的状态就定义好了！

### 2.赋初值

在这道题中，没有进行计算时（即第 $0$ 轮），$dp_{0,j,k}$ 永远为 $0$，而全局数组初始值本就为 $0$，因此我们无须手动赋初值。

### 3.状态转移方程

最最最复杂的部分来了。在讲状态转移方程之前，我要讲一讲我的思路。

如果让你找除了 $j$ 牌之外的两张牌，你会怎么找？  
这里我来讲一讲我的方法：首先，牌只有 $0,1,2$ 三种，这时我就想到了**取模**。没错，在这道题中，取模非常有用。就拿刚才的问题来说，剩下的两张牌就可以用 $(j+1)\bmod 3$ 和 $(j+2)\bmod 3$ 来计算。

除了找另外的牌，取余还可以用来**判断胜负**。这里我写了一个 $\operatorname{pk}$ 函数，大家自己品味。
```cpp
int pk(int x,int y){
	if(x == y) return 1;		//平局
	if((x+1)%3 == y) return 0;	//x输
	return 2;					//x胜
}
```
有了这个基础，我们就可以推出~~比其他人简单的~~状态转移方程了。

很简单，状态转移方程如下：
$$
dp_{i,j,k}=\max \begin{cases}
dp_{i-1,j,k}+\operatorname{pk}(j,c_i)\times a_i \\
dp_{i-1,(j+1)\bmod 3,k}+\operatorname{pk}(j,c_i)\times a_i-b_k \\
dp_{i-1,(j+2)\bmod 3,k}+\operatorname{pk}(j,c_i)\times a_i-b_k
\end{cases}
$$
这里 $\operatorname{pk}$ 就是刚刚提到的函数。

有了这些，代码肯定就出来了。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1010],b[1010],c[1010];
long long dp[1010][3][1010];//注意要开long long
int pk(int x,int y){
	if(x == y) return 1;		//平局
	if((x+1)%3 == y) return 0;	//x输
	return 2;					//x胜
}
int main(){
	int n;
	cin>>n;
	for(int i = 1;i <= n;i++){
		cin>>a[i];
	}
	for(int i = 1;i < n;i++){
		cin>>b[i];
		b[i] += b[i-1];//提前执行前缀和
	}
	for(int i = 1;i <= n;i++){
		cin>>c[i];
	}
	for(int i = 1;i <= n;i++){
		for(int j = 0;j <= 2;j++){
			for(int k = 0;k < i;k++){
				dp[i][j][k] = dp[i-1][j][k]+pk(j,c[i])*a[i];
				if(k > 0) dp[i][j][k] = max(dp[i][j][k],max(dp[i-1][(j+1)%3][k-1]+pk(j,c[i])*a[i],dp[i-1][(j+2)%3][k-1]+pk(j,c[i])*a[i]));//见提示1
			}
		}
	}
	long long ans = 0xc0c0c0c0c0c0c0c0;//见提示2
	for(int j = 0;j <= 2;j++){
		for(int k = 0;k < n;k++){
			ans = max(ans,dp[n][j][k]-b[k]);//见提示3
		}
	}
	cout<<ans;
	return 0;
}
```

## 最后的提示

1. 当 $k=0$ 时，$k-1$ 会导致数组越界，需要特判。
1. 有可能换牌太多导致得分为负数，故初始化为无限小。
1. 一定要在最后再减换牌带来的扣分。~~不然就会像作者一样 70pts。~~

---

## 作者：linjinkun (赞：3)

前言：代码有一点长，~~大家~~动态规划萌新得细细品味……

### 思路点拨

根据我~~多年~~一个月的经验，我判断出这是一个动态规划，接着发现这题是个三维动态规划，于是便写出了状态：$f_{i,j,k}$ 表示当前玩到第 $i$ 轮，当前出牌为 $j$，换牌次数为 $k$ 时的最大得分。于是我们分类讨论，当第 $i$ 轮没有换牌，那么 $f_{i,j,k} = f_{i-1,j,k}$，因为要从 $i-1$ 转移，而不换牌，所以第 $i-1$ 轮也是 $j$ 号牌，换牌次数不变；而当第 $i$ 轮换了一次牌，那么 $f_{i,j,k} = f_{i-1,l,k-1}$，$l$ 是第 $i-1$ 轮出的牌号，因为这一轮换了，而第 $i-1$ 轮换的次数肯定比第 $i$ 轮换的次数少一。整合起来就是 $f_{i,j,k} = \max(f_{i-1,j,k}+\operatorname{cmp}(i,c_i),f_{i-1,l,k-1}+\operatorname{cmp}(i,c_i)-b_k)$，$\operatorname{cmp}(x,y)$ 表示 $x$ 和 $y$ 的输赢。

------------

### 细节

- **初始化千万不要把 $f$ 全都清成 $0$，因为最大得分可能为负数。**

- **对于第一轮的 $f$，要进行初始化，$f_{1,i,0} = \operatorname{cmp}(i,c_1) \times a_1$。**

- **若果想要转移第 $i$ 轮换牌的话，前提是 $k>0$。**

- **最后统计答案的变量也要初始化为一个很小的负数。**

------------

顺便提一句，可以用滚动数组优化掉 $f$ 的第一维。

### 代码（有注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e3+5;
int a[N],b[N],c[N];
int f[3][N];
int cmp(int x,int y)
{
	if(x == 0&&y == 2)//特殊情况
	{
		return 2;
	}
	if(x == 2&&y == 0)
	{
		return 0;
	}
	if(x>y)//一般情况
	{
		return 2;
	}
	if(x == y)
	{
		return 1;
	}
	return 0;
} 
signed main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&a[i]);	
	}
	for(int i = 1;i<=n-1;i++)
	{
		scanf("%d",&b[i]);	
	} 
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&c[i]);	
	}
	memset(f,128,sizeof(f));//将f初始为很小的负数（对应细节1）
	for(int i = 0;i<=2;i++)
	{
		f[i][0] = cmp(i,c[1])*a[1];//初始化（细节2）
	}
	for(int i = 2;i<=n;i++)//之前已经初始化第一轮了
	{
      //写代码时不小心搞错变量了，就将就着看吧
		for(int j = i-1;j>=0;j--)//一定要倒序
		{
			for(int k = 0;k<=2;k++)
			{
				int t = cmp(k,c[i])*a[i];//记下来，以便重复用到
				int s = f[k][j]+t;//由于之后会改变f[k][j]，所以这里先记下来
				if(j>0)//对应细节3
				{
					for(int l = 0;l<=2;l++)
					{
						f[k][j] = max(f[k][j],f[l][j-1]+t-b[j]);//转移换牌的
					}
				}
				f[k][j] = max(f[k][j],s);//转移不换牌的
			}
		}	
	}
	int ans = -2e9;//对应细节四
	for(int j = 0;j<=n-1;j++)
	{
		for(int k = 0;k<=2;k++)
		{
			ans = max(ans,f[k][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
```
如果有不会的欢迎私信！^_^

~~为啥没有人跟我思路相似啊？~~

---

## 作者：hh20080501hh (赞：3)

# 题目
[题面戳我哦~](https://www.luogu.com.cn/problem/P10111)

简单来说就是有三种牌，分别为 $0$，$1$，$2$，$0$ 胜 $2$，$1$ 胜 $0$，$2$ 胜 $1$。每一轮获胜或平局可以获得不同的分数，拿了一种牌之后不能随意更改，要花一定分数才能去更改，现在要选择一种策略获得最大分数。
# 分析
比较简单，但有坑，细节较多。

当我们看到求最大分数和对手的牌已经告诉我们的时候，我们很容易想到贪心。不过再仔细想一想，发现不好贪，因为每一步对后面有影响，所以局部最优解不能推出整体最优解，这个时候凭借个人经验就很容易想到用动态规划了。

我们发现有 $3$ 种牌，所以不难想到用状态机来动态规划，我们定义 `dp[i][k][j]` 为第 $i$ 轮打出第 $k$ 种牌并且一共改变了 $j$ 次的最大得分。状态转移方程也不难推出是 

```
dp[i][0][j] = max(dp[i-1][0][j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j]))+得分;

dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j] , dp[i-1][2][j-1]-b[j]))+得分;
                
dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j]))+得分;               
```


另外，我还想说一下几个需要注意的地方：

1. 看清楚题目，改变牌的费用不是指当前轮次改变费用，是指改变了多少次需要的费用。
1. 改变牌所需要的费用从 $1$ 开始存就可以了，没有必要从 $2$ 存，这样也方便思考，`b[i]` 就是改变第 $i$ 次所需要的费用。
1. 对于第 $i-1$ 次改变，因为第 $i-1$ 轮的时候并不能改变 $i-1$ 次，所以在状态转移的时候不能用这轮不改变来转移，必须由改变一次转移过来。不然相当于前面所有的分数都消失了（因为前面可能会是负分，所以消失了是有影响的）。
1. 注意在改变 $0$ 次牌的时候特判，防止数组越界。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1010;

int n;
int a[N] , b[N] , c[N];
int dp[N][3][N];	//dp[i][0][j]表示第i轮当前手牌是0换了j次牌的最大分数，其余同理

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	
	cin >> n;
	for (int i=1 ; i<=n ; i++)
	{
		cin >> a[i];
	}
	for (int i=1 ; i<n ; i++)
	{
		cin >> b[i];
	}
	for (int i=1 ; i<=n ; i++)
	{
		cin >> c[i];
	}
	
	for (int i=1 ; i<=n ; i++)
	{
		for (int j=0 ; j<=i-1 ; j++)
		{
			if (j==0)
			{
				if (c[i]==0)
				{
					dp[i][0][j] = dp[i-1][0][j]+a[i];
					dp[i][1][j] = dp[i-1][1][j]+2*a[i];
					dp[i][2][j] = dp[i-1][2][j];
				}
				else if (c[i]==1)
				{
					dp[i][0][j] = dp[i-1][0][j];
					dp[i][1][j] = dp[i-1][1][j]+a[i];
					dp[i][2][j] = dp[i-1][2][j]+2*a[i];
				}
				else 
				{
					dp[i][0][j] = dp[i-1][0][j]+2*a[i];
					dp[i][1][j] = dp[i-1][1][j];
					dp[i][2][j] = dp[i-1][2][j]+a[i];
				}
			}
			else if (j==i-1)
			{
				if (c[i]==0)
				{
					dp[i][0][j] = max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j])+a[i];
					dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , dp[i-1][2][j-1]-b[j])+2*a[i];
					dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , dp[i-1][1][j-1]-b[j]);
				}
				else if (c[i]==1)
				{
					dp[i][0][j] = max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j]);
					dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , dp[i-1][2][j-1]-b[j])+a[i];
					dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , dp[i-1][1][j-1]-b[j])+2*a[i];
				}
				else 
				{
					dp[i][0][j] = max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j])+2*a[i];
					dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , dp[i-1][2][j-1]-b[j]);
					dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , dp[i-1][1][j-1]-b[j])+a[i];
				}
			}
			else if (c[i]==0)
			{
				dp[i][0][j] = max(dp[i-1][0][j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j]))+a[i];
				dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j] , dp[i-1][2][j-1]-b[j]))+2*a[i];
				dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j]));
			}
			else if (c[i]==1)
			{
				dp[i][0][j] = max(dp[i-1][0][j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j]));
				dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j] , dp[i-1][2][j-1]-b[j]))+a[i];
				dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j]))+2*a[i];
			}
			else 
			{
				dp[i][0][j] = max(dp[i-1][0][j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j-1]-b[j]))+2*a[i];
				dp[i][1][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j] , dp[i-1][2][j-1]-b[j]));
				dp[i][2][j] = max(dp[i-1][0][j-1]-b[j] , max(dp[i-1][1][j-1]-b[j] , dp[i-1][2][j]))+a[i];
			}
		}
	}
	
	int res = -0x3f3f3f3f;
	for (int i=0 ; i<=n-1 ; i++)
	{
		res = max(max(dp[n][0][i] , res) , max(dp[n][1][i] , dp[n][2][i]));
	}
	cout << res << endl;
	return 0;
}
```
由于我的码风和没有专门写一个函数去判断得分，所以看起来比较臃肿，但是其实要写的并不多，很多内容复制粘贴就可以。

---

## 作者：Ophi (赞：1)

~这很明显就是一道dp题吧。~

### 1：状态设计
设 $f[i][j][k\in\{0,1,2\}]$ 表示前 $i$ 轮，换了 $j$ 次牌，第 $i$ 轮出牌为 $k$ 能获得的最大得分。

### 2：状态转移方程
转移时，使用主动转移:

$$
\forall x\in\{0,1,2\}
$$
有：
$$
f[i+1][j][x]=f[i][j][k]+calc(i+1,x),x=k
$$

$$
f[i+1][j+1][x]=f[i][j][k]+calc(i+1,x)-b[j+1],x\neq k
$$

其中 
$$
calc(i,k)=
\begin{cases}
2\times a[i],\,k-c[i]=1\lor k-c[i]=-2\\
a[i],\,k=c[i]\\
0
\end{cases}
$$

### 3：边界条件
$f[1][0][k]=calc(1,k)，k\in\{1,2,3\}$，其余位置为 $+\infty$。

### 4：答案
$$
\max\{f[n][j][k]\},0\le j\le n-1,k\in\{0,1,2\}
$$

时间复杂度为 $O(n^2)$。
### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,f[N][N][3],a[N],b[N],c[N],ans;
int calc(int i,int k){
	if(k-c[i]==1||k-c[i]==-2)
		return 2*a[i];
	if(k==c[i])
		return a[i];
	return 0;	
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n;i++)
		cin>>b[i];
	for(int i=1;i<=n;i++)
		cin>>c[i];
	memset(f,-0x3f,sizeof(f));
	for(int k=0;k<=2;k++)
		f[1][0][k]=calc(1,k);
	for(int i=1;i<n;i++)
		for(int j=0;j<=i-1;j++)
			for(int k=0;k<=2;k++)
				for(int x=0;x<=2;x++)
					if(k==x)
						f[i+1][j][x]=max(f[i+1][j][x],f[i][j][k]+calc(i+1,x));
					else
						f[i+1][j+1][x]=max(f[i+1][j+1][x],f[i][j][k]+calc(i+1,x)-b[j+1]);
	for(int j=0;j<=n-1;j++)
		for(int k=0;k<=2;k++)
			ans=max(ans,f[n][j][k]);
	cout<<ans;
	return 0;
}
```

---

## 作者：ZettaByte (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10111)

### 题意

两个人在打牌，$1$ 胜 $0$，$2$ 胜 $1$，$0$ 胜 $2$。现在你知道了对手每局出什么牌，你可以换牌，换 $t$ 次要扣 $b_1+b_2+\dots +b_t$ 分，赢一局拿 $2a_i$ 分，平一局 $a_i$ 分，输了不得分。问最后最多拿几分。

### 解法

这题使用动态规划。~~我不会让你知道我是去看标签的~~

令 $dp_{i,j,k}$ 为打到第 $i$ 局，换了 $j$ 次牌，现在出 $k$ 时，最多的分数。

转移方程：

- $dp_{i,j,c_i}=\max(dp_{i-1,j,c_i},dp_{i-1,j-1,win_i},dp_{i-1,j-1,lose_i})+a_i$

- $dp_{i,j,win_i}=\max(dp_{i-1,j-1,c_i},dp_{i-1,j,win_i},dp_{i-1,j-1,lose_i})+2a_i$

- $dp_{i,j,lose_i}=\max(dp_{i-1,j-1,c_i},dp_{i-1,j-1,win_i},dp_{i-1,j,lose_i})$

其中 $lose_i$ 表示 $c_i$ 能打败的牌，$win_i$ 表示能战胜 $c_i$ 的牌。

扣的分数 $b_i$ 可以使用前缀和预处理。

#### AC CODE：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int lose(int x) { return (x + 2) % 3; }
int win(int x) { return (x + 1) % 3; }
ll a[1010], b[1010], dp[1010][1010][3];
int s[1010];

int main()
{
	int n; scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	for (int i = 1; i < n; i++) scanf("%lld", &b[i]), b[i] += b[i - 1]; //前缀和
	for (int i = 1; i <= n; i++) scanf("%d", &s[i]);
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < i; j++)
		{
			int x = s[i], y = win(x), z = lose(x);
			dp[i][j][x] = max({dp[i-1][j][x], dp[i-1][j-1][y], dp[i-1][j-1][z]}) + a[i];
			dp[i][j][y] = max({dp[i-1][j-1][x], dp[i-1][j][y], dp[i-1][j-1][z]}) + 2 * a[i];
			dp[i][j][z] = max({dp[i-1][j-1][x], dp[i-1][j-1][y], dp[i-1][j][z]});
		}
	ll mx = 0;
	for (int j = 0; j < n; j++)
		for (int k = 0; k < 3; k++) mx = max(mx, dp[n][j][k] - b[j]); //在这里扣分
	printf("%lld\n", mx);
	return 0;
}
```

---

## 作者：Leo2011 (赞：1)

~~看标签~~知道要用 DP。

于是开始分析。

状态：$dp(i, j, k) = $ 前 $i$ 轮中，第 $i$ 轮出 $j$，一共换了 $k$ 次牌的最大钱数。很好理解。

转移也不难，不就是不换和换两种吗！

所以，转移就是：
$$dp(i, j, k) = \max \begin{cases}dp(i - 1, j, k) + \operatorname{pk}(j, c_i) \times a_i\\ dp(i - 1, j', k - 1) + \operatorname{pk}(j, c_i) \times a_i - b_k\end{cases}$$
其中，$j'$ 表示你要换的牌，显然要求 $j' \neq j$，$\operatorname{pk}(x, y)$ 表示你出牌 $x$，小杨出 $y$ 时的胜负情况。胜返回 $2$，负返回 $0$，平返回 $1$。上面就是不还，下面就是换。

观察发现，获胜时要么大 $1$，要么小 $2$（因为此处“$0 > 2$”）。

所以 $\operatorname{pk}$ 函数如下：

```cpp
int pk(int x, int y) {
	if (x == y) return 1;
	if (x == y + 1 || x == y - 2) return 2;
	return 0;
}
```

---

以上为朴素做法。还能不能优化呢？滚动数组嘛！这玩意儿不就是专门给其中一维是“前 $i$ 回……”的 DP 状态砍掉这维的嘛！

于是用上滚动数组（这个不会的去看背包），空间复杂度就可以降到 $\Theta(3N)$ 啦！

---

用上滚动数组的 ACCode：

```cpp
// Problem: P10111 [GESP202312 七级] 纸牌游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10111
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

/*Code by Leo2011*/
#include <bits/stdc++.h>

#define log printf
#define EPS 1e-8
#define INF 0x3f3f3f3f
#define FOR(i, l, r) for (int(i) = (l); (i) <= (r); ++(i))
#define IOS                      \
	ios::sync_with_stdio(false); \
	cin.tie(nullptr);            \
	cout.tie(nullptr);

using namespace std;

typedef __int128 i128;
typedef long long ll;
typedef pair<int, int> PII;

const int N = 1010;
int n, a[N], b[N], c[N], dp[3][N], ans = -INF;

template <typename T>

inline T read() {
	T sum = 0, fl = 1;
	char ch = getchar();
	for (; !isdigit(ch); ch = getchar())
		if (ch == '-') fl = -1;
	for (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';
	return sum * fl;
}

template <typename T>

inline void write(T x) {
	if (x < 0) putchar('-'), write<T>(-x);
	static T sta[35];
	int top = 0;
	do { sta[top++] = x % 10, x /= 10; } while (x);
	while (top) putchar(sta[--top] + 48);
}

int pk(int x, int y) {
	if (x == y) return 1;
	if (x == y + 1 || x == y - 2) return 2;
	return 0;
}

int main() {
	n = read<int>();
	FOR(i, 1, n) a[i] = read<int>();
	FOR(i, 1, n - 1) b[i] = read<int>();
	FOR(i, 1, n) c[i] = read<int>();
	memset(dp, -0x3f, sizeof(dp));
	FOR(i, 0, 2) dp[i][0] = pk(i, c[1]) * a[1];
	FOR(i, 2, n)
	for (int j = i - 1; j >= 0; --j) FOR(k, 0, 2) {
			int s = pk(k, c[i]) * a[i];
			dp[k][j] += s;	  // 默认不换
			if (j > 0)		  // 防止越界
				FOR(l, 0, 2)  // 换，换成 l
			dp[k][j] = max(dp[k][j], dp[l][j - 1] + s - b[j]);
		}
	FOR(i, 0, n - 1)
	FOR(j, 0, 2) ans = max(ans, dp[j][i]);
	log("%d", ans);
	return 0;
}
```

---

## 作者：The_jester_from_Lst (赞：0)

考虑动态规划。

根据题面，当前小杨出的牌，当前小杨总的换牌的次数都是与计算答案有关的数据。那么我们就把这些东西都写进状态里。

设 $f_{i,0/1/2,j}$为当前游戏进行到第 $i$ 轮，小杨出 $0/1/2$，换 $j$ 次牌的最高得分。设小杨准备出的牌为 $x$，显然对于当前的 $f_{i,c,j}$，可以由上一轮也出 $c$，换 $j$ 次牌或上一轮不出 $c$，换 $j-1$ 次牌，然后在这一轮换牌 3 种状态（不出 $c$ 的状态有 2 种）取最大值转移过来。然后与当前这一轮对手的出牌比较，加上相应的分数即可。

最后找答案时，不要忘记扣掉换牌次数对应的分数。

这里插一句，题解区里大多题解都是对与 $c=0/1/2$ 分类讨论败它的数和输给它的数，代码有点亢长，可读性不好说。本蒟蒻用了 $l$ 和 $w$ 两个数组记录对于每一个值 $c$ 能打败它的数和会输给它的数，这样 3 类讨论就归为了 1 种。也许这样会更清晰？

详情见代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define pii pair<int,int>
#define mk make_pair
#define mod 998244353
using namespace std;
il int rd(){
    int jya=0,tl=1;char jyt=getchar();
    while(!isdigit(jyt)){if(jyt=='-')tl=-1;jyt=getchar();}
    while(isdigit(jyt)){jya=jya*10+(jyt-'0');jyt=getchar();}
    return jya*tl;
}
il void wr(int jjy){
    if(jjy<0)putchar('-'),jjy=-jjy;
    if(jjy>9)wr(jjy/10);
    putchar(jjy%10+48);
}
il int max(int x,int y){return x>=y?x:y;}
il int min(int x,int y){return x<=y?x:y;}
const int JYAAKIOI=1145141919810;
int n,a[1086],b[1086],c[1086],f[1086][3][1086],w[3]={1,2,0},l[3]={2,0,1},ans;
signed main(){
	n=rd();
	for(int i=1;i<=n;++i)a[i]=rd();
	for(int i=1;i<n;++i)b[i]=b[i-1]+rd();
	for(int i=1;i<=n;++i)c[i]=rd();
	for(int i=1;i<=n;++i){
		for(int j=0;j<=i-1;++j){
			f[i] [w[c[i]]] [j]=max(f[i-1] [w[c[i]]] [j], max(f[i-1] [c[i]] [j-1],f[i-1] [l[c[i]]] [j-1]))+a[i]*2;
			f[i] [c[i]] [j]=max(f[i-1] [c[i]] [j], max(f[i-1] [w[c[i]]] [j-1],f[i-1] [l[c[i]]] [j-1]))+a[i];
			f[i] [l[c[i]]] [j]=max(f[i-1] [l[c[i]]] [j], max(f[i-1] [c[i]] [j-1],f[i-1] [w[c[i]]] [j-1]));
			//cout<<j<<" "<<f[i] [0] [j]<<" "<<f[i] [1] [j]<<" "<<f[i] [2] [j]<<endl<<endl;
		}
	}
	for(int i=0;i<n;++i){
		for(int j=0;j<3;++j){
			ans=max(ans,f[n][j][i]-b[i]);
		}
	}
	wr(ans);
	return 0;
}
```

---

## 作者：niuzh (赞：0)

### 思路

题目中的分数有加有减，可以用动态规划。

很显然，由于需要考虑出什么牌和换了几次牌，所以并不能在没用滚动数组时用二维动态规划。所以，令 $dp_{i,j,k}$ 表示第 $i$ 轮出 $j$ 牌并一共改变了 $k$ 次牌面时最大的分数。

然后考虑转移方程（令 $t$ 为如果选择 $j$ 时的得分）：

1. 如果 $k=0$，那么转移方程为 $dp_{i,j,k}=dp_{i-1,j,k}+t$。

1. 如果 $k=i-1$，那么转移方程为 $dp_{i,j,k}=dp_{i-1,l,k-1}-b_k+t (0\le t <3 , l\neq j)$。

1. 如果 $k=i-1$，那么转移方程为 $dp_{i,j,k}=\max(dp_{i-1,l,k},\max(dp_{i-1,l,k-1}-b_k))+t(0\le t <3 , l\neq j)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;
long long n,m,dp[N][3][N],a[N],b[N],c[N];
long long win(long long k)//判断谁赢
{
	if (k==0) return 1;
	if (k==1) return 2;
	return 0;
}
int main()
{
	memset(dp,~0x3f,sizeof(dp));
	cin>>n;
	for (int i=1; i<=n; i++)
	{
		cin>>a[i];
	}
	for (int i=1; i<n; i++)
	{
		cin>>b[i];
	}
	for (int i=1; i<=n; i++)
	{
		cin>>c[i];
	}
	for (int i=0; i<=2; i++)//i=1 要特判
	{
		if (i==c[1])
		{
			dp[1][i][0]=a[1];
		}
		else if (win(c[1])==i)
		{
			dp[1][i][0]=a[1]*2;
		}
		else
		{
			dp[1][i][0]=0;
		}
	}
	for (int i=2; i<=n; i++)
	{
		for (int j=0; j<3; j++)
		{
			int t;//分数判断
			if (j==c[i])
			{
				t=a[i];
			}
			else if (j==win(c[i]))
			{
				t=a[i]*2;
			}
			else
			{
				t=0;
			}
			for (int k=0; k<i; k++)//枚举
			{
				if (k<i-1)
				{
					dp[i][j][k]=dp[i-1][j][k]+t;
				}
				if (k==0)
				{
					continue;
				}
				for (int l=0; l<=2; l++)
				{
					if (l!=j)
					{
						dp[i][j][k]=max(dp[i][j][k],dp[i-1][l][k-1]-b[k]+t);
					}
				}
			}
		}
	}
	long long maxx=-0x3f3f3f3f;//寻找最大值
	for (int j=0; j<=2; j++)
	{
		for (int k=0; k<n; k++)
		{
			maxx=max(maxx,dp[n][j][k]);
		}
	}
	cout<<maxx;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 思路：
- 定义数组 $v$ 为交易钱数，$a$ 为持有的商品，$b$ 为希望获得商品，发现不管通过什么方式换，最终因为价值不同而花费的金币数都是固定的，即 $v_b-v_a$。
+ 唯一的区别是每次交易都要额外支付 $1$ 块钱，所以需要最小化交易次数，我们把每件商品看作 $1$ 个点，如果某件商品 $x$ 能够换为某件商品 $y$，则让 $x$ 和 $y$ 连一条边。
- 我们的目标是从商品 $a$ 出发尽快到达商品 $b$，即经过的边的数量尽量少，可以通过 dfs 求经过的最少的边数，设这个值为 $minn_i$。那么最终答案为：
$$minn_i+v_b-v_a$$
## 代码呈上：
```cpp
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;

int n;
int a[1010],b[1010],c[1010],d[3][1010];

int panduan(int x,int y){
    if(x==y+1||x==y-2)return 2;
    if(x==y)return 1;
    return 0;
}

int main(){
    cin>>n;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<n;++i)cin>>b[i];
    for(int i=1;i<=n;++i)cin>>c[i];
    memset(d,128,sizeof(d));
    for(int i=0;i<3;++i){
        d[i][0]=panduan(i,c[1])*a[1];
    }
    for(int i=2;i<=n;++i){
        for(int j=i-1;j>=0;--j){
            for(int k=0;k<3;++k){
                int s=panduan(k,c[i])*a[i];
                d[k][j]=d[k][j]+s;
                if(j>0){
                    for(int l=0;l<3;l++){
                        d[k][j]=max(d[k][j],d[l][j-1]+s-b[j]);
                    }
                }   
            }
        }
    }
    int sum=-2e9;
    for(int i=0;i<n;++i){
        for(int j=0;j<3;++j){
            sum=max(sum,d[j][i]);
        }
    }
    cout<<sum<<endl;
    return 0;
} 
```

---


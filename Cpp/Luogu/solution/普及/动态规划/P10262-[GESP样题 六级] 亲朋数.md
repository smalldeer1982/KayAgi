# [GESP样题 六级] 亲朋数

## 题目描述


给定一串长度为 $L$、由数字 $0\sim 9$ 组成的数字串 $S$。容易知道，它的连续子串共有 $\frac{L(L + 1)}2$ 个。如果某个子串对应的数（允许有前导零）是 $p$ 的倍数，则称该子串为数字串 $S$ 对于 $p$ 的亲朋数。

例如，数字串 $S$ 为“ $12342$ ”、$p$ 为 $2$，则在 $15$ 个连续子串中，亲朋数有“ $12$ ”、“ $1234$ ”、“ $12342$ ”、“ $2$ ”、“ $234$ ”、“ $2342$ ”、“ $34$ ”、“ $342$ ”、“ $4$ ”、“ $42$ ”、“ $2$ ”共 $11$ 个。注意其中“ $2$ ”出现了 $2$ 次，但由于其在 $S$ 中的位置不同，记为不同的亲朋数。

现在，告诉你数字串 $S$ 和正整数 $p$ ，你能计算出有多少个亲朋数吗？

## 说明/提示

## 样例 1 解释

$5$ 个亲朋数，分别 $10$、$102$、$0$、$02$、$2$。

## 样例 #1

### 输入

```
2
102```

### 输出

```
5
```

## 样例 #2

### 输入

```
2
12342```

### 输出

```
11```

# 题解

## 作者：__Jared__ (赞：50)

dp 方法有点难想，如果能力不够建议先写搜索再看题解。

## DP 方法

我们定义 $f_{i,j}$ 表示**所有以 $s_i$ 结尾的子串除以 $p$ 的余数是 $j$ 的子串的数量**。

故此我们可以推出一个公式：$f_j=f_{j-1}\times10+q$，推理过程见下图（~~字有点丑，见谅~~）。

![](https://cdn.luogu.com.cn/upload/image_hosting/69km6nv4.png)

由于题目要求我们求出有多少字串是可以被 $p$ 整除的，根据模运算的性质可以知道，当 $f_{i,j}\bmod p=0$ 的时候，说明可以被整除。同时，模运算的性质也告诉了我们任何被模的数的结果始终是小于模数的，即 $a \bmod b \equiv c$ 时 $c<b$。故此我们只需要统计出 $f_{i,0}$ 的总数即可。

最后附上 AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[129],f[129],ans; //dp[i]为原题解意思
int p;
string s;
int main(){
	cin>>p>>s;
	int n=s.size();
	for(int i=0;i<n;i++)
	{
		int q=s[i]-'0';
		q%=p;
		for(int j=0;j<p;j++) f[j]=dp[j],dp[j]=0; //枚举模数
		for(int j=0;j<p;j++) dp[(j*10+q)%p]+=f[j];
		dp[q]++;
		ans+=dp[0];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：feizhu_QWQ (赞：20)

## 思路
这道题一眼就可以看出，是 $O(l)$ 或 $O(lp)$ 的时间复杂度,而求解字串是需要 $O(l^2)$ 的时间的。  
所以推断出这道题不能枚举字串。  

这道题的突破点就在于 $\bmod\ p$。 

动态规划 DP 可以吗？  
$dp_i$ 为 $\bmod\ p$ 的余数为 $i$ 的子串的数量。  
可答案就非同一般了  
我们用 `DP` 还是要枚举字串吗？  
可以不用。  
我们枚举每次子串的**个位**。  
只用 $O(l)$ 的时间复杂度。  

那么状态转移方程就轻而易举的出来了  
 
注：这里我们用滚动优化，不然会被卡空间。  
答案就是每次枚举后 $dp_0$ 的总和。  

初始值：全部归 $0$。  
  
枚举每次 $\bmod\ p$ 的结果即可。  

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int p;
int dp[1000005],pre[1000005];
string s;
int num;
int ans=0;
signed main()
{
	cin>>p>>s;
	int len=s.size();
	for(int i=0;i<len;i++)
	{
		num=(s[i]-'0')%p;
		for(int j=0;j<p;j++) dp[j]=0;
		for(int j=0;j<p;j++)
		{
			dp[(j*10+num)%p]+=pre[j];
		}
		dp[num]++;
		for(int j=0;j<p;j++)
		{
			pre[j]=dp[j];
		}
		ans+=dp[0];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Eterna (赞：10)

意想不到啊。

居然是 dp。

根据题意，可以打出暴力代码。（如下）


```cpp
	for(int i=0;i<s.size();i++)
  {
    int k=0;
    for(int j=i;j<s.size();j++)
    {
      k=(k*10+s[j]-'0')%p;
      if(k==0)ans++;
    }
  }
```

复杂度：$O(L^2)$。

期望得分：$0$。

我们发现 $p$ 十分的小。

于是思考复杂度基于 $p$ 的算法。

因为当 $a$ 为整数是 $a \bmod p$ 的取值有 $p$ 种。

我们可以用一维枚举余数。

得转移方程：

$$dp_{i,j}=\sum_{k=0}^{p-1}dp_{i−1,k}$$


但是答案的最大值爆 `int` 了，所以还要开 `long long`。

代码如下：


```cpp
#include<bits/stdc++.h>
#define N 200
using namespace std;
long long p;
long long dp[N],f[N],ans;
string s;
signed main()
{
	cin>>p>>s;
	for(int i=0;i<s.size();i++)
	{
		int k=(s[i]-'0')%p;
		for(int j=0;j<p;j++)f[j]=dp[j],dp[j]=0;
		for(int j=0;j<p;j++)dp[(j*10+k)%p]+=f[j];
		dp[k]++,ans+=dp[0];
	}
	cout<<ans;
	return 0;
}
```

复杂度：$O(Lp)$。

可以通过。

结果一交，TLE？

感觉已经最优了，但是总是差一点（每个点 1.04s 左右）。

于是上网查资料，发现 `long long` 取模常数大很多。

$p$ 改成 `int`，过了？！

###  ac代码


```cpp
#include<bits/stdc++.h>
#define N 200
using namespace std;
int p;
long long dp[N],f[N],ans;
string s;
signed main()
{
	cin>>p>>s;
	for(int i=0;i<s.size();i++)
	{
		int k=(s[i]-'0')%p;
		for(int j=0;j<p;j++)f[j]=dp[j],dp[j]=0;
		for(int j=0;j<p;j++)dp[(j*10+k)%p]+=f[j];
		dp[k]++,ans+=dp[0];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_Weslie_ (赞：9)

看到算法标签想出来的。

### Idea

设 $dp_{i,j}$ 表示当前枚举到了第 $i$ 位，子串化为十进制 对 $p$ 取模的余数为 $j$ 的子串数量。 

设 $s_i$ 对 $p$ 取余的余数为 $q$。

设 $j_1$ 为上一个枚举到的 $j$，$j_2$ 为我们需要转移的 $j$，由余数的性质我们可得：$j_2=(10\times j_1+q)\bmod p$。其实就是将前一个数乘 $10$ 然后加上 $s_i$ 代表的十进制数对 $p$ 取余的结果。

最后答案是什么？亲朋数是 $p$ 的倍数，换而言之，亲朋数对 $p$ 取模余数为 $0$。所以答案就是 $dp_{i,0}$ 的和。

这题略卡空间，所以需要滚动数组优化。

### Code

```
#include<bits/stdc++.h>
using namespace std;
long long dp[129],f[129];
int p;
string s;
long long ans=0;
int main(){
	cin>>p;
	cin>>s;
	s=' '+s;
	int n=s.length()-1;
	for(int i=1;i<=n;i++){
		int q=s[i]-'0';
		q=q%p;
		for(int j=0;j<p;j++){
			f[j]=dp[j]; 
			dp[j]=0;
		}
		for(int j=0;j<p;j++){
			dp[(j*10+q)%p]+=f[j];
		}
		dp[q]++;//可能自己独自成为一个亲朋数，需要把这个数自己算上
		ans+=dp[0];
	}
	cout<<ans;
	return 0;
}
```

### Tip

本题答案最多时可以达到 $5\times 10^{11}$，所以需要开 `long long`。例如当 $p=2$，$s$ 由 $10^6$ 个 $2$ 构成时，所有情况都满足。

但是本题数据略水，所以不用开 `long long` 也能过。

---

## 作者：Octopus_hsfzy (赞：5)

看这题的第一眼，我还以为是非常水的高精度，看完题目，嗯？不对劲。一看算法标签，哦，原来如此。

所以，**DP** 出奇迹！

本章鱼之前写过关于动态规划的题解，里面有动态规划的使用场景和三个特点，有兴趣的可以去看一下：[题解：P10726 [GESP202406 八级] 空间跳跃](https://www.luogu.com.cn/article/hnmus3zn)。

好了，让我们回到题目：聊到动态规划，就少不了 **状态设定**与**转移方程**。

### 1. 状态设定：  
因为题目所求的是为 $p$ 的倍数的字串个数，所以状态设定肯定与 $p$ 的倍数和字串个数有关，最终设定为：$f_{i}$ 为 $\mod p$ 的值为 $i$ 的字串个数（实际上为一个滚动数组，因为还要考虑位数）。

### 2. 转移方程：
先看图：![图片](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/team_file/2s4sv33h.png?response-content-disposition=attachment%3B%20filename%3D%22%E5%9B%BE%E7%89%87.png%22&OSSAccessKeyId=LTAI4FsiWjpNs1epYQp3d1Ag&Expires=1724938340&Signature=jhQrOC%2BRRjgQ81A449JKrPePlfo%3D)
其中 $j_{1}$ 为上次 $\mod p$ 的值，$k$ 为当前枚举到的位数所对应的原序列，$j_{2}$ 为当前 $\mod p$ 的值。通过此图，不难看出：
$$
j_{2}=(j_{1}\times10+k)
$$
所以，最终的转移方程为：
$$
f_{(j\times10+k)}=t_{j}
$$
其中：$t$ 数组起一个滚动的作用，转移完后还要赋回 $f$ 数组的值。$j$ 是从 $0$ 枚举到 $p-1$（就是 $\mod p$ 的所有可能值）。

### 3. 补充：  
$f$ 数组初始值：全为 $0$。  
最终答案：过程中的 $f_{0}$ 累加。

### 4. 代码：

```cpp
#include<bits/stdc++.h>//本章鱼码风与大多数人不同，不喜勿喷
using namespace std;
long long n,x,f[1000005],t[1000005],zym,m;
string a;
int main(){
cin>>n;
cin>>a;//输入 
m=a.size();
for(int i=0;i<m;i++){
	x=(a[i]-'0')%n;
	for(int j=0;j<n;j++) f[j]=0;//初始化 
	for(int j=0;j<n;j++) f[(j*10+x)%n]+=t[j];//转移 
	f[x]++;
	for(int j=0;j<n;j++) t[j]=f[j];//滚动处理 
	zym+=f[0];//计算答案 
}
cout<<zym;//输出 
return 0;
}
```

---

## 作者：Red_river (赞：5)

### 题目大意

题目就是说，给你一个 $n$ 和 $S$ 的字符串，而让你求亲朋数。亲朋数的定义为 $S$ 的子串中为 $p$ 的倍数的数。

### 题意分析
首先先分析一波数据范围，可以发现还是比较大的。所以很容易推得正确的时间复杂度是大约为 $O(nm)$ 的，所以我们优先考虑 `DP` 来做。

既然是 `DP` 就要先推状态转移方程，如下：

- 设 $f_{i,j}$ 为第 $i$ 位时模 $p$ 为 $j$ 时的贡献。
- 所以 $f_{i,k}=\sum_{k=0}^{p-1}f_{i-1,((k*10+y) \mod p)}$。

我们又可以发现，每次转移只与上一步有关，于是就可以考虑再开一个一维数组来记录上一次的答案贡献就行了。时间复杂度为 $O(nm)$。具体可参考代码及注释。

### CODE

```cpp
#include<iostream>
using namespace std;
int n,m,k;long long sum;
int dis[129],vis[129],f[129];
string wis;

int main()
{
	cin>>n;cin>>wis;m=wis.size();
	for(int i=0;i<m;++i){
		k=wis[i]-'0';k%=n;
		for(int j=0;j<n;++j) vis[j]=f[j],f[j]=0;//存储上一次的贡献。
		for(int j=0;j<n;++j) f[((j*10)+k)%n]+=vis[j];//产生贡献。
		++f[k];sum+=f[0];//加上本身。
	}cout<<sum;
	exit(0);
}
```

---

## 作者：_yang_yi_bo_ (赞：4)

我们设 $dp_{i_j}$ 表示以第 $i$ 位为结尾的所有子串中 $\bmod$ $p=j$ 的数的个数。

答案显然为 $dp_{i_0}$ 的和，其中 $1 \le i \le L$。

状态转移方程呢？我们可以枚举所有 $\bmod$ $p$ 的余数，我们设第 $i$ 位的数为 $cnt$，状态转移方程为 $dp_{i_{(j \times 10 +cnt) \bmod p}}=dp_{{i-1}_{j}}$。

然后，我们加上滚动优化，使用一个 $dp$ 数组与 $pre$ 数组来存储。

内容详见代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[205];
long long pre[205];
int p;
string s;
long long ans;
int main(){
	cin>>p>>s;
	s=" "+s;
	int len=s.size();
	for(int i=1;i<len;i++){
		int cnt=s[i]-'0';
		cnt%=p; 
		for(int j=0;j<p;j++){
			dp[j]=0; 
		}for(int j=0;j<p;j++){
			dp[(j*10+cnt)%p]+=pre[j]; 
		}dp[cnt]++; 
		for(int j=0;j<p;j++){
			pre[j]=dp[j];
		}ans+=dp[0];
	}cout<<ans;
	return 0;
}
```

---

## 作者：Star_F (赞：3)

## 题目大意：
给你一个字母串，求出他的所有字串中是 $p$ 的倍数的数量。

## 题目分析：
看到求方案数的题，考虑 dp。

设 $dp_{i,j}$ 位考虑到前 $i$ 位，且选的子串对 $p$ 取模为 $j$ 的方案数。

考虑转移方程

$$
dp_{i,j}=\sum_{k=0}^{p-1}dp_{i-1,k} 
$$

很好推吧，因为一个数对 $p$ 取模的所有可能就是从 $0$ 到 $p-1$。

但是这样做空间会爆掉，我们考虑滚动数组。这里介绍一种滚动数组模板，就是给原来的转移方程需要滚动的地方加上 `&1` 即可。本题的转移方程是累加的，所以需要清空这次的 $dp$ 数组，然后再进行转移。 

代码里有详细注释。

## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
#define DEBUG(x) cerr << #x << '=' << x << endl

inline int rd(){
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    return x * f;
}

void print(int x){
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
    return;
}

namespace Star_F{
    long long dp[2][150];    //滚动的dp数组
    int p;
    long long ans;
    string s;
    void Main(){
       
        cin >> p >> s;
        s = ' ' + s;    //读入，这样做能让字符串从1开始
        int n=s.length()-1;
        for (int i = 1; i <= n;i++){
            int q = s[i] - '0';    //取十进制数
            q = q % p;
            for (int j = 0; j < p;j++)
                dp[i & 1][j] = 0;
            for (int j = 0; j < p; j++)
            {
                dp[i & 1][(j * 10 + q) % p] += dp[i - 1 & 1][j];
            }    //转移方程。
            dp[i&1][q]++;    //一个数需要++
            ans += dp[i&1][0];   //累加答案
        }
        cout << ans << endl;
    }

}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    return Star_F::Main(), 0;
    return 0;
}
```

---

## 作者：liyifan202201 (赞：2)

## 前言
帮助小学生 @[feizhu0130](https://www.luogu.com/article/p2bsquea) 改题解
## 思路
这道题一眼就可以看出，是 $O(l)$ 或 $O(lp)$ 的时间复杂度，而求解字串是需要 $O(l^2)$ 的时间的。  
所以推断出这道题不能枚举字串。  

这道题的突破点就在于 $\bmod\ p$。 

`DP` 可以吗？  
$dp_i$ 为 $\bmod\ p$ 的余数为 $i$ 的子串的数量。  
可答案就非同一般了。 
我们用 `DP` 还是要枚举字串吗？  
可以不用。  
我们枚举每次子串的**个位**。  
只用 $O(l)$ 的时间复杂度。  

那么状态转移方程就轻而易举的出来了。
 
注：这里我们用滚动优化，不然会被卡空间。  
答案就是每次枚举后 $dp_0$ 的总和。  

初始值：全部归 $0$。  
  
枚举每次 $\bmod\ p$ 的结果即可。  

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int p;
int dp[1000005],pre[1000005];
string s;
int num;
int ans=0;
signed main()
{
	cin>>p>>s;
	int len=s.size();
	for(int i=0;i<len;i++)
	{
		num=(s[i]-'0')%p;
		for(int j=0;j<p;j++) dp[j]=0;
		for(int j=0;j<p;j++)
		{
			dp[(j*10+num)%p]+=pre[j];
		}
		dp[num]++;
		for(int j=0;j<p;j++)
		{
			pre[j]=dp[j];
		}
		ans+=dp[0];
	}
	cout<<ans;
	return 0;
}
```

---


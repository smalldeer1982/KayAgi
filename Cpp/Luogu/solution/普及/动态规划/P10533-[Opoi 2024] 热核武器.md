# [Opoi 2024] 热核武器

## 题目背景



跳蚤国与蛐蛐国正在激战！

![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)

上面是战术核显卡，与题目没有关联。

## 题目描述

跳蚤国的国土可以看作平面直角坐标系。

跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。


由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \le dis(i,0)$ ，$j \ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**

定义一座城市的 $\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\gamma$ 值为 $0$。**

蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。

对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。

## 说明/提示

### 样例解释

这幅图是长这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)

对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。

对于 $C2$，只有 $C0$ 满足 $dis(j,0) \le dis(C2,0)$，添加边 $(C2,C0)$。

对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**

对于 $C4$，其他所有点都满足 $dis(j,0) \le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。

得到下面的表：

| 城市编号 | $\gamma$ 值 |
| :-----------: | :-----------: |
| 0 | 1 |
| 1 | 2 |
| 2 | 2 |
| 3 | 3 |
| 4 | 2 |

所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。

### 数据范围

$1 \le N \le 500$，$-10^6 \le x_i,y_i \le 10^6$。

### 特殊说明

由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。


## 样例 #1

### 输入

```
4
-1 -1
1 0
1 -2
-2 2```

### 输出

```
Yes```

# 题解

## 作者：shuqiang (赞：13)

这题我们可以分成三个部分来解，得到[框架代码](https://www.luogu.com.cn/paste/xp054s4g)。


### part1
目标：把输入的数据转化成图。

直接按题意模拟即可。

[part1 代码](https://www.luogu.com.cn/paste/4ifgha4e)

### part2
目标：求出 $\gamma$ 值。

实现：题目要求这个城市走到首都的**最小道路数**，因为 $N \le 500$，所以我们有几种方法可以求最小道路数。

#### 方法1：Floyd 算法。

这个算法代码很简洁，并且复杂度为 $\mathcal{O}(n^3)$，正好可以过。建议先完成 [B3647](https://www.luogu.com.cn/problem/B3647)。

Floyd 算法的流程：
1. 定义 $b_{i,j}$ 为从点 $i$ 到点 $j$ 的最短路径。
2. 对于每一个节点 $k$，检查 $b_{i,k}+b_{k,j}<b_{i,j}$ 是否成立，如果成立就令 $b_{i,j}=b_{i,k}+b_{k,j}$。

[part2 Floyd 算法代码](https://www.luogu.com.cn/paste/uospuqrm)

#### 方法2：Dijkstra 算法。

如过你想优化复杂度，那么这个方法非常合适，因为它的时间复杂度上限只有 $\mathcal{O}(n^2)$。

Dijkstra 算法的流程：
1. 先初始化 $dis_{0}=0$，其它为无穷大。
2. 找一个最小的 $dis_{i}$，此时 $dis_{i}$ 已经是最小的，所以不可能有别的路径可以更新 $dis_{i}$。
3. 找到所有与点 $i$ 连接的点 $j$，如果通过这个点的路径更短，更新 $dis_{j}$ 为 $dis_{i}+i$ 到 $j$ 的距离。
4. 如果全部点都访问完毕，跳出循环，否则回到第 2 步。

[part2 Dijkstra 算法代码](https://www.luogu.com.cn/paste/h385hskf)

### part3
目标：判断是否存在把 $\gamma$ 分成两组的和相等。

实现：可以用 01 背包，背包的花费和价值都是 $\gamma$ 值，算法复杂度是 $\mathcal{O}(n^3)$，可以过这题，那么 part3 部分的代码也实现了。

[part3 代码](https://www.luogu.com.cn/paste/6qmgs77d)

[AC 代码](https://www.luogu.com.cn/paste/nqq2w3lt)

---

## 作者：hcy1117 (赞：3)

## P10533 [Opoi 2024] 热核武器题解

#### 1. 解题思路
看到 $n\le500$ 可以想到连边后用类似 **Floyd** 的暴力方法建边（如下）。

时间复杂度 $O(n^3)$。
```cpp
for(int k=0;k<=n;k++)
	for(int i=0;i<=n;i++)
		for(int j=0;j<=n;j++)
			e[i][j]=min(e[i][j],e[i][k]+e[k][j]);


```
于是每座城市的 $γ$ 值就为 $e[i][0]+1$，即后文中的    $cnt[i]$。

接下来，想到用 dp ，即**必须装满的01背包**来判断有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的   $γ$ 值和相等。

则此时，设 $sum$ 为每座城市的 $γ$ 值和，背包容量为 $\frac{sum}{2}$，物品的所占空间和价值都为 $cnt[i]$。

预估时间复杂度 $O(n^3)$。
```cpp
memset(dp,-0x7f,sizeof(dp));
dp[0]=0;
for(int i=0;i<=n;i++)
{
	for(int j=sum/2;j>=cnt[i];j--)
	{
		dp[j]=max(dp[j],dp[j-cnt[i]]+cnt[i]);
   }
}
```
最后判断 $dp[\frac{sum}{2}]$ 是否等于 $\frac{sum}{2}$ 即可（**当然 $sum$ 为奇数时直接输出 `No`**）。

其余有不懂的可以参考代码和注释。
#### 2. 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int x[505],y[505];
double dis(int a,int b,int u,int v)//计算距离 
{
	return sqrt((long long)(a-u)*(a-u)+(long long)(b-v)*(b-v));
}
int e[505][505];//两点间最少通过几条边可到达 
long long cnt[505];//γ值 
long long dp[10000005];//数组一定要开大 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
	memset(e,0x3f,sizeof(e));
	for(int i=0;i<=n;i++)e[i][i]=0;//记得初始化 
	for(int i=1;i<=n;i++)
	{
		double minn=1e9;
		int yy=-1;
		for(int j=0;j<=n;j++)
		{
			if(i==j)continue;
			if(dis(x[j],y[j],0,0)<=dis(x[i],y[i],0,0))
			{
				if(dis(x[i],y[i],x[j],y[j])<minn)
				{
					minn=dis(x[i],y[i],x[j],y[j]);
					yy=j;
				}
			}
		}
		if(yy>=0)e[i][yy]=e[yy][i]=1;//连边 
	}
	for(int k=0;k<=n;k++)
	for(int i=0;i<=n;i++)
	{
		for(int j=0;j<=n;j++)
		{
			e[i][j]=min(e[i][j],e[i][k]+e[k][j]);
		}
	}
	long long sum=0;
	for(int i=0;i<=n;i++)
	{
		if(e[i][0]==1061109567)e[i][0]=-1;
		cnt[i]=e[i][0]+1,sum+=cnt[i];
	}
	//判断有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 γ 值和相等 
	if(sum%2==1)//sum为奇数 
	{
		cout<<"No";
		return 0;
	}
	memset(dp,-0x7f,sizeof(dp));
	dp[0]=0;
	for(int i=0;i<=n;i++)
	{
		for(int j=sum/2;j>=cnt[i];j--)
		{
			dp[j]=max(dp[j],dp[j-cnt[i]]+cnt[i]);
		}
	}
	if(dp[sum/2]==sum/2)cout<<"Yes";
	else cout<<"No";
	return 0;
}

```
本人蒟蒻，有错误的地方请指出谢谢。

---

## 作者：LostKeyToReach (赞：3)

我们可以分两部分处理。

### Part 1
目标：求出每个点的 $\gamma$ 值。

这个部分好处理，直接循环遍历寻找合法的点，把它加入图中。

那么怎么求出 $\gamma$ 值呢？我们可以建立 $G$ 的反图 $G'$，在 $G'$ 上跑一遍 bfs，这样就可以求出 $\gamma$ 值，这也是一个小技巧。

时间复杂度 $O(n^2)$。

### Part 2
目标：寻找是否存在将 $\gamma$ 分为两组使得两组的和相等的方案。

这个部分可以使用动态规划来解决。我们如何判断一种无解的情况呢？当 $\sum\gamma$ 为奇数时，说明无法分为两个相同的数，那么无解。

否则，我们可以令 $dp_i$ 为表示是否存在选择一些数使得它们的和为 $i$，那么状态转移方程显而易见：

$$
dp_i=\bigvee_{j=0}^ndp_{i-\gamma_j}
$$

初始赋值：$dp_0=1$。

目标：$dp_{\frac{1}{2}\sum\gamma}$。

时间复杂度 $O(n^3)$。

那么，我们就能轻松通过此题了。

代码如下，请勿抄袭：
```cpp
ll n;
vector < pair < ll, ll > > p;
vector <int> G[567];
int dis[567];
int vis[567];
bool dp[10000006];
int main() {
	read(n);
	p.push_back({ 0,0 });
	rep(i, 1, n, 1) {
		ll X, Y;
		read(X, Y);
		p.push_back({ X,Y });
	}
	rep(i, 1, n, 1) {
		int minid = i;
		ll nowdis = distance(p[i].first, p[i].second, 0, 0);
		ll mindis = 1e18;
		for (int j = n; j >= 0; j--) {
			if (i == j) continue;
			ll d = distance(p[i].first, p[i].second, p[j].first, p[j].second);
			ll d1 = distance(p[j].first, p[j].second, 0, 0);
			// cout << d << " " << j << endl;
			if (d1 <= nowdis && d <= mindis) {
				minid = j;
				mindis = d;
			}
		}
		// cout << endl;
		if (minid != 3456 && mindis <= nowdis) {
			// cout << minid << endl;
			G[minid].push_back(i); // 建个反图
		}
	}
	queue <int> q;
	q.push(0);
	dis[0] = 1;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		if (vis[u]) continue;
		vis[u] = 1;
		for (auto v : G[u]) {
			if (!vis[v]) {
				dis[v] = dis[u] + 1;
				q.push(v);
			}
		}
	}
	ll sum = 0;
	rep(i, 0, n, 1) {
		sum += dis[i];
	}
	if (sum % 2) {
		cout << "No";
	}
	else {
		dp[0] = 1;
		rep(i, 0, n, 1) {
			for (int j = sum / 2; j >= dis[i]; j--) {
				dp[j] |= dp[j - dis[i]];
			}
		}
		cout << (dp[sum / 2] ? "Yes" : "No");
	}
}
```

[赛时 AC 记录](https://www.luogu.com.cn/record/160192289)

---

## 作者：wzhm54nr (赞：2)

本文已按照要求，修改 LaTeX，给管理员带来不便，深感抱歉。现再次提交，望通过。
# 关于本文
也许会更适合我这样的蒟蒻。  
说是题解，其实对我个人而言也是一种复习。  
你需要：欧几里得距离，树上 dfs，01 背包。
# 思路
按照题意建图，处理出每个城市到首都的距离 $\gamma$。而分成 $\gamma$ 值的和相等的两部分，其实就是“拼出”一个 $\frac{\sum \gamma}{2}$，典型的 01 背包。**在确保读懂本段的情况下继续阅读。**

等等！当给出的树是一条链的时候，复杂性不太对啊！
> $\sum \gamma=\sum_{i=1}^{n+1} i$，即为 $O(n^2)$。  
> 算上 $O(n)$ 转移，达到 $O(n^3)$，~~对于追求极致的我们~~难以接受。

于是给出 `bitset` 优化：

$dp=dp | (dp \ll \gamma)$

其中，$dp_i$ 表明是否可以“拼出” $i$，左移之后即为取走当前的 $\gamma$ 后的状态。由于可取可不取，所以或上原来的状态。**在确保读懂本段的情况下继续阅读。**
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=505;
int x[N],y[N],n;
double dis[N];
int dep[N]={1},sum;
vector<int> g[N];
bool vis[N];
void dfs(int u,int f){
    for(auto v:g[u])if(v!=f){
        dep[v]=dep[u]+1;dfs(v,u);
    }
}
bitset<N*N> dp={1};
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x[i]>>y[i];
        dis[i]=sqrt(x[i]*x[i]+y[i]*y[i]);
    }
    for(int i=1;i<=n;i++){
        double Min=5e7;
        int _min;
        for(int j=0;j<=n;j++)if(i!=j&&dis[j]<=dis[i]){
            double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
            if(d<Min)  Min=d,_min=j;
        }
        g[_min].push_back(i);
        g[i].push_back(_min);
    }
    dfs(0,-1);
    for(int i=0;i<=n;i++)  sum+=dep[i];
    if(sum&1){
        puts("No");
        return 0;
    }
    for(int i=0;i<=n;i++)
        dp|=dp<<dep[i];
    if(dp[sum/2])  puts("Yes");
    else  puts("No");
}
```

---

## 作者：qiliu (赞：2)

## 思路

先分析题意。

注意到这张图是一个以首都为根节点的树，$\gamma$ 就是每个节点的深度，注意根节点深度为一（$\gamma$ 是与首都的距离加一）。记每一个城市的深度为 $deep$，深度（$\gamma$）的总和为 $sum$。

然后这道题就变成了下面这样子：

知道一个数列 $deep$，问能否从中选取若干个数使其总和为 $\frac{sum}{2}$。

由于 $n\leq500$，我们考虑先 $O(n^2)$ 建图然后判断深度，最后 DP 维护答案。

## 实现

### 建图：

枚举每一个点 $i$，然后枚举出符合条件的另一个点 $j$，使 $j$ 作为 $i$ 的父亲节点。（实际上就是模拟了题目中的建边过程）。

Code:

```cpp

for(int i=2;i<=cnt;i++)
{
	xy temp=xy{100000,100000};//xy是一个结构体，存放一个点的xy轴坐标
	int w;
	for(int j=1;j<=cnt;j++)
	{
		if(i!=j)
		if(len(city[j],city[1])<=len(city[i],city[1])&&len(city[i],city[j])<len(city[i],temp))//这个函数len就是求两个点的欧式距离
		{
			temp=city[j];
			w=j;
		}
	}
	ch[w].push_back(i);//这是个vector
}
```
然后从根节点深搜确定每一个点的 $deep$，这部分直接看最后的完整代码就能看懂。

---
### DP

我们设 $f_{i,j}$ 表示前 $i$ 个点凑出 $j$ 的值可不可行，那么转移就分三种情况：

- 当当前点的 $deep$ 大于 $j$ 时，显然不能选。此时 $f_{i,j}=f_{i-1,j}$

- 当当前节点的 $deep$ 等于 $j$ 时，$f_{i,j}$ 可行，直接赋值为真。

- 当当前节点的 $deep$ 小于 $j$ 时，$f_{i,j}$ 选不选都行。此时只要 $f_{i-1,j}$ 和 $f_{i-1,j-deep_i}$ 任意一个成立，$f_{i,j}$ 就成立。可以根据上面 $f_{i,j}$ 的定义感性理解一下。

Code:

```cpp
//这里f[i][j]的下标从0开始
for(int i=0;i<cnt;i++)f[i][0]=1;
//0是肯定能凑出来的
//这个cnt相当于n+1，因为我把根节点算进去了，但题目没有
f[0][city[0].deep]=1;
for(int i=1;i<cnt;i++)
{
	for(int j=1;j<=sum/2;j++)
	{
		if(city[i].deep>j)//上面的情况1
		{
			f[i][j]=f[i-1][j];
		}
		else
		if(city[i].deep==j)//情况2
		{
			f[i][j]=1;
		}
		else//情况3
		{
			bool a=f[i-1][j],b=f[i-1][j-city[i].deep];
			if(a||b)
			{
				f[i][j]=1;
			}
		}
	}
}
```
最后就是判断 $f_{cnt,sum/2}$ 是否为真（$cnt$ 的意义在代码注释里）。

---
## 完整代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define DEBUG(x) cerr<<#x<<'='<<x<<endl
#define endl '\n'
using namespace std;
const int N=505;
int n;
struct xy
{
	int x,y;
	int deep;
}city[N];
int cnt=1;
inline double len(xy a,xy b)
{
	return sqrt( (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) );
}
vector<int>ch[N];
int maxd=0;
void dfs(int x,int fa)
{
	city[x].deep=city[fa].deep+1;
	maxd=max(maxd,city[x].deep);
	for(int i=0;i<ch[x].size();i++)
	{
		if(ch[x][i]!=fa)
		dfs(ch[x][i],x);
	}
}
int sum=0;
bool f[501][62376]; 
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
	cin>>n;
	city[cnt]=xy{0,0};
	for(int i=1;i<=n;i++)
	{
		int xx,yy;
		cin>>xx>>yy;
		city[++cnt]=xy{xx,yy};
	}
	for(int i=2;i<=cnt;i++)
	{
		xy temp=xy{100000,100000};
		int w;
		for(int j=1;j<=cnt;j++)
		{
			if(i!=j)
			if(len(city[j],city[1])<=len(city[i],city[1])&&len(city[i],city[j])<len(city[i],temp))
			{
				temp=city[j];
				w=j;
			}
		}
		ch[w].push_back(i);
	}
	city[1].deep=1;
	dfs(1,0);
	for(int i=1;i<=cnt;i++)sum+=city[i].deep;
	if(sum%2!=0)
	{
		cout<<"No";
		return 0;
	}
	for(int i=0;i<cnt;i++)f[i][0]=1;
	f[0][city[0].deep]=1;
	for(int i=1;i<cnt;i++)
	{
		for(int j=1;j<=sum/2;j++)
		{
			if(city[i].deep>j)
			{
				f[i][j]=f[i-1][j];
			}
			else
			if(city[i].deep==j)
			{
				f[i][j]=1;
			}
			else
			{
				bool a=f[i-1][j],b=f[i-1][j-city[i].deep];
				if(a||b)
				{
					f[i][j]=1;
				}
			}
		}
	}
	if(f[cnt-1][sum/2]==1)
	{
		cout<<"Yes";
	}
	else
	cout<<"No";
    //fclose(stdin);
    //fclose(stdout);
	return 0;
}
```
---

感谢观看！希望有帮到你！

---

## 作者：WorldMachine (赞：2)

主要说一说本题第二部分更优的解法。至于第一部分貌似可以用 KD-tree 搞到 $\mathcal O(n\log n)$？我不确定。

第二部分就是给你一棵树，节点 $i$ 的深度为 $\text{dep}_i$，判断能否将 $\text{dep}$ 分为和相等的两部分。

首先如果 $\text{dep}$ 之和为奇数是显然不行的。

然后你会发现，如果 $\text{dep}$ 之和为偶数，是 **一定可行** 的。下面说明这一点。

由于 $\text{dep}$ 是树上节点的深度，因此其一定是连续的。假设随便分，分成的两部分和为 $x,y$，分情况讨论：

1. $|x-y|\leq\text{maxdep}$。由于 $\text{dep}$ 连续，一定可以通过交换两部分的若干项使两部分的和相同。
2. $|x-y|>\text{maxdep}$。较大的部分给较小的部分若干项，转化成第一种情况。

因此一定可以使得两部分和相同。

至于构造解的话，直接排序之后，能加则加即可。

因此我们得到了第二部分的 $\mathcal O(n)$ 解法（使用桶排）。接下来就期待一下第一部分能优化到多少了。

---

## 作者：lfxxx_ (赞：2)

### 思路
看到这道题极小的数据范围，自然想到暴力地建边，然后用 BFS 去求每个点的 $\gamma$ 值，设为 $\gamma_i$ ，再对每个点的 $\gamma$ 值进行排序，最后 dp 一下，就可以了。\
状态设计：$dp_{i,j}$ 为前 $i$ 个点，和为 $j$ 是否可能。\
初始状态：$dp_{0,\gamma_0}=dp_{0,0}=1$\
状态转移：$dp_{i,j}=dp_{i-1,j-\gamma_i}|dp_{i-1,j}$\
最终答案：若 $dp_{n,\frac{\sum_{i=1}^{n}\gamma_i}{2}}$ 为 $1$ 并且 $\sum_{i=1}^{n}\gamma_i$ 为偶数，则输出 `Yes` ，否则输出 `No`。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=505;
int n;
vector<int>edge[N];
int x[N],y[N];
int dist(int i,int j)
{
	if(j==n+1)
		return x[i]*x[i]+x[j]*x[j];
	if(j==n+2)
		return 1000000000000000000;
	return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
}int dis[N];
bool dp[N][N*N/2];
queue<int>q;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>x[i]>>y[i];
	x[0]=y[0]=0;
	for(int i=0;i<=n;++i)
	{
		int p=n+2;
		for(int j=0;j<=n;++j)
		{
			if(j==i)
				continue;
			if(dist(j,0)<=dist(i,0)&&dist(i,j)<dist(i,p))
				p=j;
		}
		edge[i].emplace_back(p);
		edge[p].emplace_back(i);
	}
	q.emplace(0);
	dis[0]=1;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(auto v:edge[u])
		{
			if(dis[v])
				continue;
			dis[v]=dis[u]+1;
			q.emplace(v);
		}
	}
	sort(dis,dis+n+1); 
	int sum=0;
	for(int i=0;i<=n;++i)
		sum+=dis[i];
	if(sum&1)
	{
		cout<<"No";
		exit(0);
	}
	sum>>=1;
	dp[0][dis[0]]=dp[0][0]=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=sum;++j)
			dp[i][j]=dp[i-1][j-dis[i]]|dp[i-1][j];
	if(dp[n][sum]==1)
		cout<<"Yes";
	else
		cout<<"No";
}
```

---

## 作者：Cypher_404 (赞：1)

# 题解：P10533 [Opoi 2024] 热核武器

## 一句话题意：

给你 $n$ 个点。

对于每一个点：

1. 在所有点中，先选出比自身离根节点更近（包括等于）的节点。在选出的节点中，选择离自身最近的节点（不包括自身）并连接一条边。

2. 将每一个点到根节点的距离计算出来（即 $\gamma$ 值）。

## 方法简介：

### 对于第一个操作：

先将每一个点到原点的距离计算出来。

将计算好的距离升序排序。

暴力选出比自己离原点更近（或相等）的节点。

然后将其中离自己最近的点连接一条边。

### 对于第二个操作：

可以直接使用最短路（如：spfa）跑图。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int head[100050],tot,dis[100050];
struct edge
{
    int u,v,w,net;
}e[100002<<2];//链式前向星（当然比较浪费）
void addedge(int u,int v)//加边操作
{
    tot++;
    e[tot].v=v;
    e[tot].w=1;
    e[tot].net=head[u];
    head[u]=tot;
}
struct node//定义点结构体
{
    int x,y;
    double num;//到根节点的距离
}a[100050];
bool cmp(node x,node y)//自定义比较函数
{
    return x.num<y.num;
}
double calc(int x,int y,int xx,int yy)//计算(x,y)到(xx,yy)的欧几里得距离
{
    return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
queue<int>que;//spfa必备
void bfs(int st)//伪装成bfs的spfa
{
	que.push(st);
	while(!que.empty())
	{
		int u=que.front();
		que.pop();
		for(int i=head[u];i;i=e[i].net)
		{
			if(dis[e[i].v]>dis[u]+1)//如果可以松弛
			{
				dis[e[i].v]=dis[u]+1;//松弛后继续跑
				que.push(e[i].v);
			}
		}
	}
}
signed main() {//define了int就用signed
    cin>>n;
    for(int i=1;i<=n;i++)//读入
    {
        int x,y;
        cin>>x>>y;
        a[i].x=x;
        a[i].y=y;
        a[i].num=sqrt(x*x+y*y);
    }
    sort(a+1,a+n+1,cmp);//根据到原点的距离排序
    for(int i=1;i<=n;i++)
    {
        double minn=0x7fffffff;//i到j最小距离
        int mini=114514;//最小距离的j
        for(int j=0;j<=n;j++)
        {
        	if(i==j)//如果相等
        	{
        		continue;
			}
            if(a[i].num>=a[j].num)//满足条件
            {
                if(minn>=calc(a[i].x,a[i].y,a[j].x,a[j].y))
                {
                    minn=calc(a[i].x,a[i].y,a[j].x,a[j].y);//更新
                    mini=j;
                }
            }
        }
        addedge(i,mini);//加入双向边
        addedge(mini,i);
    }
    memset(dis,0x3f,sizeof dis);//初始化
    dis[0]=1;//记得初值为1
	bfs(0);//跑图，从0开始0是原点，不用预处理
	int sum=0;
	for(int i=0;i<=n;i++)
	{
		if(dis[i]>n+5)//如果图不连通
		{
			dis[i]=0;//等于零
		}
		sum+=dis[i];
	}
	if(sum%2==0)//如果mod2=0就有解
	{
		cout<<"Yes";
	}
	else
	{
		cout<<"No";
	}
    return 0;
}
```

点个赞再走吧。

---

## 作者：流水行船CCD (赞：1)

数据人题解。

### 思路

首先，题目分为两个 part，求出 $\gamma$ 值，和对 $\gamma$ 值分组。

第一部分：

看到给的是 $O(n^2)$ 的数据范围，直接对于每一个 $i$，暴力枚举 $j$，按照题意求出 $dis(j,0) \le dis(i,0)$ 中 $dis(i,j)$ 最小的点（相同则编号最小），求两点间欧几里得距离的公式就不多说了。

发现题面中所谓最小道路条数是坑人的，因为~~口胡样例的规律~~ 如果将所有 $dis(j,0) = dis(i,0)$ 的点看做是同一级的结点，可以发现同一级结点之间并不会连边，所有边都是由 $dis(i,0)$ 大的点连向小的点，这连边连完后一定是一棵树，$\gamma$ 值自然是该点在树上的深度。

$O(n^2)$

第二部分：

求出每个点的权值 $\gamma_i$ 之后就要分组，考虑 DP。

这里是一个典型的划分子集相等相等问题，考虑动态规划。设 $f_{i,sum}$ 表示前 $i$ 个数是否可以凑成总和为 $j$ 的序列。

$$f_{i,sum} = \bigvee_{j=\gamma_i}^{\sum \gamma} f_{i-1,j - \gamma_i}$$

01 背包转移后用 bitset 优化即可。（因为这是 A 题，所以放了 $O(n^3)$ 的朴素 DP）

$O({\Large{\frac{n^3}{w}}})$

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
vector<int> g[9000005];
int lvl[9000005];
int clr[9000005];
int x[9000005],y[9000005];

void dfs(int x, int l) {
	lvl[x] = l;
	for (int i = 0; i < g[x].size(); i++) {
		int y = g[x][i];
		if (lvl[y] == 0) {
			dfs(y, l + 1);
		}
	}
}
inline double dis(double x,double y,double xx,double yy){
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
bitset<4600000> bs;
signed main() {
//    freopen ("data16.in","r",stdin);
//	freopen("data16.out","w",stdout);
	cin >> n;
	x[0]=y[0]=0;
	for (int i = 1; i <= n; i++) {
		cin >> x[i] >> y[i];
	}
	for(int i=1;i<=n;i++){
		double mn=2e9;
		int id=-1;
		for(int j=0;j<=n;j++){
			if(j==i||dis(x[j],y[j],0,0)>dis(x[i],y[i],0,0)){
				continue;
			}
			double d=dis(x[j],y[j],x[i],y[i]);
			if(d<mn){
				mn=d;
				id=j;
			}
		}
		g[i].push_back(id);
		g[id].push_back(i);
	}
	dfs(0, 1);
	bs[0] = 1;
	int sum=0;
	for(int i=0;i<=n;++i)bs|=(bs<<lvl[i]),sum+=lvl[i];
	if(sum&1)cout<<"No\n";
	else cout<<(bs[sum/2]?"Yes":"No")<<'\n';
	return 0;
}
```

---

## 作者：Chillturtle (赞：1)

# 题意

首先给你一个平面直角坐标系，然后再给你 $n$ 个点的坐标。对于这 $n$ 个点，我们以下列规则进行连边：

- 令 $dis(x,y)$ 为 $x$ 与 $y$ 城市之间的直线距离。则有对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \le dis(i,0)$，$j \ne i$ 的所有点中  $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。

最后让你算每一个点到原点的最短路加一是否是偶数。

# 思路

~~赛时以为是橙题。~~

首先我们发现 $N \le 500$，就可以很轻松的想到算最短路时可以用 floyd 实现，这样的话，复杂度就是 $O(n^3)$ 可以完美通过。

好的，让我们我们回到题目。其一，他让我们连边，那么我们就先要知道**欧几里得距离**是什么。

- 欧几里得距离，也称为欧式距离或欧几里得度量，是在 $m$ 维空间中两个点之间的真实距离，即**两点之间的直线距离**。

怎么算直线距离？这里稍作讲解，请看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/srxzmr3b.png)

所以我们用勾股定理算出来之后，直接按照题意比较连边即可。

至于最短路，直接用 floyd 跑就可以了。floyd 的详解可以参考 OI-wiki。

**[传送门](https://oi-wiki.org/graph/shortest-path/)**

# AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e2+10;
int n;
struct node{
	int x,y;
}a[N];
double dis(double x,double y,double x1,double y1){
	return sqrt(abs(x-x1)*abs(x-x1)+abs(y-y1)*abs(y-y1));
}
int f[N][N];
vector<int> q;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
	}
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			f[i][j]=LLONG_MAX/2;
		}
	}
	for(int i=0;i<=n;i++)
		f[i][i]=0;
	for(int i=1;i<=n;i++){
		int minn=INT_MAX;
		double mini=INT_MAX;
		int gyug=-1;
//		cout<<"--"<<i<<"--"<<endl;
		for(int j=0;j<=n;j++){
//			cout<<i<<" "<<j<<endl;
//			cout<<dis(a[i].x,a[i].y,0,0)<<endl<<dis(a[j].x,a[j].y,0,0)<<endl;
//			cout<<endl;
			if(dis(a[j].x,a[j].y,0,0)<=dis(a[i].x,a[i].y,0,0)&&j!=i){
				if(dis(a[i].x,a[i].y,a[j].x,a[j].y)<=mini){
					mini=dis(a[i].x,a[i].y,a[j].x,a[j].y);
					gyug=j;
				}
			}
		}
		int opt=gyug;
		if(opt==-1)continue;
//		for(int j=0;j<=n;j++){
//			if(dis(a[i].x,a[i].y,a[j].x,a[j].y)==mini){
//				opt=j;
//			}
//		}
		f[opt][i]=1;
		f[i][opt]=1;
	}
//	for(int i=0;i<=n;i++){
//		for(int j=0;j<=n;j++){
//			cout<<f[i][j]<<" ";
//		}
//		cout<<endl;
//	}
//	cout<<endl;
	for(int k=0;k<=n;k++){
		for(int i=0;i<=n;i++){
			for(int j=0;j<=n;j++){
//				if(f[i][j]!=INT_MAX)
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	int ans=0;
	for(int i=0;i<=n;i++){
		ans+=(f[i][0]+1);
//		cout<<f[i][0]+1<<endl;
	}
//	cout<<endl<<ans<<endl;
	if(ans%2==0){
		cout<<"Yes"<<endl;
	}else{
		cout<<"No"<<endl;
	}
return 0;
}
```

---

## 作者：__lhx__ (赞：0)

题干比较费解，大致就是每个点都会与比他离首都更近（距离相等也可以）的点里选一个离该点最近的点进行连边。
   
   每个点都有一个 $\gamma$ 值，就是该点到首都的最短路径数加 $1$ 。特别的，对于无法到达首都的点，其 $\gamma$ 值为 $0$ 。
   
   在建完边后我们可以跑一遍 bfs ，当第一次遍历到这个点时，该点到首都的路径数最小，也就求出了该点的 $\gamma$ 值。
   
   现在我们就得到了所有点的 $\gamma$ 值，要判断这些数能不能分成相等的两部分。
   
   令
   $$
  	x=\sum_{i=0}^{n}{\gamma_i} 
   $$
   如果 $x$ 是奇数，显然不行。如果是偶数，我们就可以用背包 dp 来解决这个问题，只需要以 $ \lfloor x/2 \rfloor$ 作为背包容量，各个点的 $\gamma$ 值为物品及其价值，若最后 $dp_{\lfloor x/2 \rfloor} = \lfloor x/2 \rfloor$ 则可以分成相等的两部分。
   ```cpp

    #include<bits/stdc++.h>
    #define int long long
    using namespace std;
    const int N=520;
    double dis[N][N];
    int x[N],y[N],n,e[N][N],d[N],dp[N*N],f[N];
    double len(int x,int y,int l,int r){return sqrt((x-l)*(x-l)+(y-r)*(y-r));}
    main(){
        scanf("%lld",&n);
        for(int i=1;i<=n;i++)scanf("%lld%lld",&x[i],&y[i]);
        for(int i=0;i<=n;i++){
            for(int j=0;j<=n;j++){
                dis[i][j]=dis[j][i]=len(x[i],y[i],x[j],y[j]);
            }
        }
        for(int i=0;i<=n;i++){
            int si=0;
            double ma=1e20;
            for(int j=0;j<=n;j++){
                if(i==j)continue;
                if(dis[i][0]<dis[j][0])continue;
                if(dis[i][j]<ma){
                    ma=dis[i][j];
                    si=j;
                }
                else if(dis[i][j]==ma)si=min(si,j);
            }
            e[i][si]=e[si][i]=1;
        }
        memset(d,0x7f,sizeof d);
        queue<int>q;
        q.push(0);
        d[0]=1;
        while(q.size()){
            int xl=q.front();
            q.pop();
            for(int i=1;i<=n;i++)
                if(e[xl][i]&&(!f[i])){
                    f[i]=1;
                    q.push(i);
                    d[i]=min(d[i],d[xl]+1);
                }
        }
        int r=0;
        for(int i=0;i<=n;i++)
            if(d[i]<=n*n)r+=d[i];
        if(r%2)cout<<"No";
        else{
            r/=2;
            for(int i=0;i<=n;i++)
                for(int j=r;j>=d[i];j--)
                    dp[j]=max(dp[j],dp[j-d[i]]+d[i]);
            if(dp[r]==r)printf("Yes");
            else printf("No");
        }
        return 0;
    }
```

---

## 作者：封禁用户 (赞：0)

我们需要先理解如何计算每个城市的 $\gamma $ 值，然后确定是否存在一种划分方式使得两组的 $\gamma $ 值和相等。首先，我们需要计算每个城市到首都的 $\gamma $ 值。这可以通过从每个城市开始，沿着修建的公路向首都回溯，并计数经过的公路数量来实现。由于题目中规定了公路的修建规则，我们可以直接根据这些规则来构建公路网络。接下来，我们需要检查是否存在一种划分方式，使得两组的 $\gamma $ 值和相等。这可以通过动态规划或搜索来解决。

怎么？有些绕？其实我们考虑到数据范围较小（$N\le 500$），我们可以简单地使用回溯法来尝试所有可能的划分方式。详细说就是暴力地建边，然后用 BFS 去求每个点的 $\gamma $ 值，设为 $\gamma _i$，再对每个点的 $\gamma $ 值进行排序，最后 dp 一下，就可以了。时间复杂度为 $\mathcal O(n^3)$
。

完结撒花！

---

## 作者：sbno333 (赞：0)

显然缝合。

暴力连边，bfs 求最短路（因为边长度都为 $1$），然后 DP。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int phi[509];
struct stt{
	int x,y;
}a[1509];
struct st{
	int v,ne;
}sd[3009];
int h[1509];
int inn;
void add(int u,int v){
	sd[++inn].v=v;
	sd[inn].ne=h[u];
	h[u]=inn;
}
int dis(stt x,stt y){
	return (x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y);
}
bitset<300009> s;
queue<int> q;
signed main(){
	memset(phi,0x3f,sizeof(phi));
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
	}
	phi[0]=1;
	for(int i=1;i<=n;i++){
		int z;
		z=0;
		for(int j=1;j<=n;j++){
			if(i!=j)
			if(dis(a[i],a[j])<dis(a[i],a[z])&&dis(a[j],a[0])<=dis(a[i],a[0])){
				z=j;
			}
		}
		add(i,z);
		add(z,i);
	}
	q.push(0);
	while(q.size()){
		int t;
		t=q.front();
		q.pop();
		for(int i=h[t];i;i=sd[i].ne){
			if(phi[sd[i].v]>1e7){
				phi[sd[i].v]=phi[t]+1;
				q.push(sd[i].v);
			}
		}
	}
	int sum;
	sum=0;
	for(int i=0;i<=n;i++){
		sum+=phi[i];
	}
	if(sum>1e8){
		cout<<"No"<<endl;
		return 0;
	}
	s[0]=1;
	for(int i=0;i<=n;i++){
		s|=(s<<phi[i]);//bitset 优化一下，可以跑 n=1000
	}
	cout<<((s[sum/2]&&sum%2==0)?"Yes":"No");
	return 0;
}
```

---


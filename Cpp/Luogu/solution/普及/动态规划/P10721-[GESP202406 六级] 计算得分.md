# [GESP202406 六级] 计算得分

## 题目描述

小杨想要计算由 $m$ 个小写字母组成的字符串的得分。

小杨设置了一个包含 $n$ 个正整数的计分序列 $A=[a_1,a_2,\ldots,a_n]$，如果字符串的一个子串由 $k(1\leq k \leq n)$ 个 $\texttt{abc}$ 首尾相接组成，那么能够得到分数 $a_k$，并且字符串包含的字符不能够重复计算得分，整个字符串的得分是计分子串的总和。

例如，假设 ，字符串 $\texttt{dabcabcabcabzabc}$ 的所有可能计分方式如下：
- $\texttt{d+abc+abcabc+abz+abc}$ 或者 $\texttt{d+abcabc+abc+abz+abc}$，其中 $\texttt{d}$ 和 $\texttt{abz}$ 不计算得分，总得分为 $a_1+a_2+a_1$。
- $\texttt{d+abc+abc+abc+abz+abc}$，总得分为 $a_1+a_1+a_1+a_1$。
- $\texttt{d+abcabcabc+abz+abc}$，总得分为 $a_3+a_1$。

小杨想知道对于给定的字符串，最大总得分是多少。

## 说明/提示

### 样例解释
最优的计分方式为 $\texttt{d+abc+abc+abc+abz}$，总得分为 $a_1+a_1+a_1$，共 $9$ 分。

### 数据范围

子任务编号|数据点占比|$n$|$m$|$a_i$|特殊性质
:-:|:-:|:-:|:-:|:-:|:-:
$1$|$20\%$|$\le 20$|$\le 10^5$|$\le 1000$|对于所有的 $i(1 \le i \le n)$，存在 $a_i \ge a_{i+1}$
$2$|$40\%$|$\le 3$|$\le 10^5$|$\le 1000$|
$3$|$40\%$|$\le 20$|$\le 10^5$|$\le 1000$|

对于全部数据，保证有 $1\leq n\leq 20$，$1\leq m\leq 10^5$，$1\leq a_i\leq 1000$。

## 样例 #1

### 输入

```
3
3 1 2
13
dabcabcabcabz
```

### 输出

```
9```

# 题解

## 作者：Czming__ (赞：24)

### 题目大意

很简单，就是说让你将一个字符串分割成几个小字符串（**不重复**），如果这个字符串是由 $k$ 个 $\texttt{abc}$ 首尾相接组成，就可以获得 $a_k$ 分（$1 \le k \le n$），问你最多能得几分。 

### 题目转换

那么，我们以样例为例，那么是不是我们有且只有 $3$ 个连续的 $\texttt{abc}$？所以说，让 $\texttt{abcabcabc}$ 得分最大化，才是最后的目标。

所以说，这个 $\texttt{abc}$ 连续的数量你是无法改变，所以此题中，我们应该要让收益最大化。

所以说，这道题的正解应该是 dp 和字符串的基本操作，这题就容易了一些。

### 基本框架

-  打好一张 dp 表，$dp_k$ 表示 $k$ 个 $\texttt{abc}$ 最多可以得到几分（请思考，这道题是一道完全背包还是 $01$ 背包？）

- 然后在字符串中查询，其实就是一道最长平台，这里不重点展开。  

就这样了，代码（注释并没有很多，但明白了思路，代码其实也不用）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[21],dp[33334],sum;
string s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		for(int j=i;j<=33333;j++){
			dp[j]=max(dp[j],dp[j-i]+a[i]);
		}
	}//输入+完全背包。
	int i=0,k=0;
	cin>>m>>s;
	s=s+"#  ";//特例：abc:如果这句没有，那么就要最后算。 
	while(i<=m){
		if(s[i]=='a'&&s[i+1]=='b'&&s[i+2]=='c'){
			i+=3;
			k++;
		}
		else{
			i++;
			sum+=dp[k];
			k=0; 
		}
	}//find "abc" 并且加分。
	cout<<sum;
	return 0;
}
```

---

## 作者：Ratio_Y (赞：14)

比较基础的一道 dp，和之前的一道 ARC 的题有相似之处，[点击传送](https://www.luogu.com.cn/article/yv0f8zz3)。

------------
## 思路
首先考虑到，只有一个或几个连续的 `abc` 才是我们的决策对象，而其他字符都是无效片段。其次，与上面放的那道题类似的是，这里仍然可以将串中的不同有效片段看作几个独立事件，那么显然最终答案是每个独立事件中最优策略之和。

我们读入数据后，首先对于给定的字符串，预处理出它包含的不同独立事件及长度，独立事件总数表示为 $tot$，长度为 $len_i$。

有一点我们能注意到，前一段长度为 $n$ 的事件和后面等长的不同事件的最优策略显然是一致的，所以预处理时找到长度的最大值，运用 dp 的思想，设 $f_i$ 为长度为 $i$ 的事件的最优策略，泽状态转移方程为：

$$f_i=max(f_i,f_k+a_{i-k})$$

其中 $k\in(max(i-n,0),i-1)$。

最后只需要求出 $\sum_{i=1}^{tot} f_{len_i}$ 即可。

## 代码实现
题还是比较基础的，在一些要注意的地方加入了注释供参考。

```
#include<bits/stdc++.h>

using namespace std;
const int Ratio=0;
const int N=1e5+5;
int n,m,tot,ans,le,maxlen=-1e9;
int a[N],len[N],f[N];
string s;

namespace Wisadel
{
	short main()
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		scanf("%d",&m); cin>>s;
		
		for(int i=0;i<m;i++)// 预处理字符串 
			if(i<=m-3&&s.substr(i,3)=="abc") le++,i+=2;// 是 abc 就记录 
			else if(le) len[++tot]=le,le=0,maxlen=max(maxlen,len[tot]);
			// 若不是且已有 abc 记录过则将独立事件划分出
			// 其他情况不会对事件造成影响，无需考虑 
		if(le) len[++tot]=le,maxlen=max(maxlen,len[tot]);// 结尾未被记录的事件 
		
		for(int i=1;i<=maxlen;i++)// 以最长长度为边界进行 dp 
			for(int k=max(i-n,0);k<i;k++) f[i]=max(f[i],f[k]+a[i-k]);
		
		for(int i=1;i<=tot;i++) ans+=f[len[i]];
		printf("%d\n",ans);
		return Ratio;
	}
}
int main(){return Wisadel::main();}
```


------------
完结撒花~~~顺便推一下自己的[博客](https://www.cnblogs.com/Ratio-Yinyue1007)~~

---

## 作者：time_keeper (赞：11)

# P10721
## 分析

### 预处理

对于每一位 $i$，注意到我们并不需要这一位的具体字符，只需要这一位可以向前取的 $abc$ 的个数即可。

设 $can_i$ 表示第 $i$ 位向前取能取的 $abc$ 的个数。

不难发现，如果对于每一位都向前遍历，复杂度会达到 $O(n^2)$，是不可接受的。

注意到，$can_i$ 的数值分两种情况：

- 如果 $i-2 \to i$ 该段是 $abc$ 串，则 $can_i$ 的数值可以由 $can_{i-3}+1$ 转移。

- 如果是其他字符，则就是 $0$，不需要处理。

### DP

考虑设计状态：

设 $dp_i$ 表示第 $i$ 位的最大得分。

转移：对于第 $i$ 位，我们可以从前一位转移，表示不选。也可以向前选择 $abc$ 串来获得得分。

综上：

$dp_i=\max(dp_{i-1},dp_{i-3\times j}+a_j)$

## 注意点

- 数组越界，可能出现在遍历字符串向前找 $abc$ 串和第 $i$ 位的 $can_i$ 的值大于 $n$。

- 字符串下标是从 $0\to m-1$,输出时应该输出 $m-1$ 位。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 25;
const int M = 1e5 + 10;
int n,m;
int a[N];
string s;

int can[M];//当前位向前可取abc个数
int dp[M];//当前位最大得分

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr),cout.tie(nullptr);
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    cin >> m >> s;
    //预处理
    for(int i = 2;i < m;i++){//注意越界问题
        if(s[i] == 'c'){
            if(s[i - 1] == 'b' && s[i - 2] == 'a'){
                can[i] = can[i - 3] + 1;//从i-2到i构成一个abc串
                /*i这一位的abc串可取个数就等于can[i-3]+1，如果在i-3位前还有，则直接转移即可，不需要再向前遍历*/
            }
        }
    }
    //DP
    for(int i = 0;i < m;i++){
        dp[i] = dp[i - 1];//注意，后面要与dp[i]进行多次比较，如果在for each j
                          //中直接写dp[i] = max(dp[i - 1],dp[i - 3 * j] + a[j])则不能取得正确的解，只会取到最后一个大于dp[i - 1]的值
        for(int j = 1;j <= min(can[i],n)/*注意越界和合法性*/;j++){//枚举每一个可能的abc
            dp[i] = max(dp[i],dp[i - 3 * j] + a[j]);
        }
    }
    cout << dp[m-1];
}
```

---

## 作者：fangminding (赞：10)

此题使用动态规划解决。

首先是 dp 数组的设计，$dp_i$ 表示的是截止 i 的字符串最大得分。

接下来考虑动态规划转移方程。首先可以不考虑当前字符，即 $dp_i = dp_{i-1}$。

接下来考虑其他情况。可以以当前字符为结尾取一个连续子串计算得分，即 $dp_i = dp_{i - 3 \times j} + a_j$。不过需要注意转移时需要判断子串是否合规。

综上，转移方程如下：$dp_i = \max(dp_{i-1} , dp_{i - 3 \times j} + a_j)$。（需判子串是否合规，具体实现在代码中）

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[100005],n,A[30],m;
string s;
signed main()
{
	cin>>n;
	for(int i = 1;i <=n;i++)cin>>A[i];
	cin>>m>>s;
	if(s[0]=='a'&&s[1]=='b'&&s[2]=='c')dp[2]=A[1];
	for(int i = 3;i <m;i++)
	{
		dp[i]=dp[i-1];
		for(int j = i,k=1;k<=n&&j-2>=0;j-=3,k++)
			if(s[j-2]=='a'&&s[j-1]=='b'&&s[j]=='c')
				dp[i]=max(dp[i],dp[((j-3)<0?0:(j-3))]+A[k]);
			else break;
	}
	cout<<dp[m-1];
	return 0;
}
```

---

## 作者：Vct14 (赞：5)

我们发现，对于每一个字串 `abc`，都可以与前面的 $j$ 个 `abc` 一起得分（$j\geqslant0$）。我们往前尽可能找 `abc`，然后每次算出以当前 `abc` 开始的得分，然后取最大值即可。

```c++
#include<bits/stdc++.h>
using namespace std;

int a[22];
string c;
int f[100002];

bool check(int i){
	if(c[i]=='a' && c[i+1]=='b' && c[i+2]=='c') return true;
	return false;
}

int main(){
	int n;cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i];
	int m;cin>>m>>c;
	for(int i=2; i<m; i++){ // 枚举 abc 的结尾  
		if(i) f[i]=f[i-1];
		else f[0]=0;
		for(int j=i-2; j>=0; j-=3){ //枚举 abc 的开头，防止前面已经计入得分的 abc 在下面再被算一次
			if(!check(j) || (i-2-j)/3+1>n) break; // 不是 abc 或太长无法得分 
			f[i]=max(f[i],f[j]+a[(i-2-j)/3+1]); 
		}
	}
	cout<<f[m-1];
	return 0;
}
```

---

## 作者：CaiZi (赞：3)

## [GESP202406 六级] 计算得分 题解
**[题目链接](https://www.luogu.com.cn/problem/P10721)**
### 题目分析
首先我们把这题分为两个部分：处理字符串和进行 DP。
#### Part 1
注意到除了 $\texttt{abc}$ 以外，字符串的其余部分都是没有用的，因此我们可以统计出，字符串每段连续 $\texttt{abc}$ 中，$\texttt{abc}$ 的出现次数，并将第 $i$ 段的出现次数记为 $x_i$，共有 $y$ 段。
#### Part 2
因为每两段之间互相不影响，我们考虑对每一段进行 DP。设 $f_i$ 表示前 $i$ 个 $\texttt{abc}$ 可以获得的最大得分，那么：
$$f_i=\max_{\max\{i-n,0\}\le j<i}f_j+a_{i-j}$$
于是我们对每一段进行上述 DP，求和即可。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[21],x[33334],y,b,c,f[33334];
string s;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>m>>s;
	s=' '+s;
	for(int i=1;i<=m;i++){
		if(i<=m-2&&s[i]=='a'&&s[i+1]=='b'&&s[i+2]=='c'){
			b++;
			i+=2;
		}
		else if(b!=0){
			y++;
			x[y]=b;
			b=0;
		}
	}
	if(b!=0){
		y++;
		x[y]=b;
		b=0;
	}
	for(int i=1;i<=y;i++){
		for(int j=1;j<=x[i];j++){
			b=0;
			for(int k=max(j-n,0);k<j;k++){
				b=max(b,f[k]+a[j-k]);
			}
			f[j]=b;
		}
		c+=f[x[i]];
	}
	cout<<c;
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/164803849)**

---

## 作者：nightwatch.ryan (赞：2)

### 思路
定义 $dp_i$ 为字符串的开头符到第 $i$ 个字符的最大得分。

设 $i$ 从 $1$ 枚举到 $m$，首先 $dp_i$ 先继承 $dp_{i-1}$ 的答案。

然后 $j$ 从 $1$ 枚举到 $n$，如果 $i \geq 3 \times j$，说明有可能字符串的第 $1 \sim 3 \times j$ 个字符可以由 $j$ 个 `abc` 拼接而成。如果这个子字符串真的是由 $j$ 个 `abc` 拼接而来，那么 $dp_i$ 就是 $dp_i$ 和 $dp_{i-3 \times j}+a_j$ 的最大值。

最后输出 $dp_m$ 的结果。
### 代码
```cpp
#include<iostream>
#define M 100005
#define N 25
bool check(std::string s){
	for(int i=2;i<s.size();i+=3)
		if(s.substr(i-2,3)!="abc")
			return false;
	return true;
}
int a[N],dp[M],n,m,ans;
int main(){
	std::cin>>n;
	for(int i=1;i<=n;i++)std::cin>>a[i];
	std::cin>>m;
	std::string s;std::cin>>s;
	for(int i=1;i<=m;i++){
		dp[i]=dp[i-1];
		for(int j=1;j<=n;j++){
			if(i>=3*j){
				std::string sub=s.substr(i-3*j,3*j);
				if(check(sub)){
					dp[i]=std::max(dp[i],dp[i-3*j]+a[j]);
				}
			}
		}
	}
	std::cout<<dp[m]; 
}
```

---

## 作者：Your_Name (赞：2)

### 题目大意
给一个长度为 $m$ 的字符串，由小写字母组成。

给一个 $A$ 数组，由 $n$ 个正整数组成，分别为 $a_1$ 到 $a_n$。

如果每个子串连续出现 `abc` 的次数为 $k$，则其得分为 $a_k$。

问要怎么分割字符串使得各子串的分数和最大。

### 思路
子串不会交叉且只有包含 `abc` 的子串对答案有贡献，所以可以只考虑每个仅出现了 `abc` 的子串怎么切割即可。

因为当出现很多个 `abc` 连续时我们要使得其分数最大，且出现几次和对应得到的价值我们已知，最重要的是每种长度不只能选一次，所以我们可以用完全背包。

把出现几次看成背包总容量（每个子串出现 `abc` 的次数），$f[m]$ 就表示当连续出现 $m$ 次时的最大分数。
把获得 $a_i$ 分的代价看成 $i$ 个容量即可。

最后遍历找出含尽可能多的，连续的，只含 `abc` 的子串累加计算答案即可。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5;
int n, m, a[21], f[N], cnt, ans;
string s;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    cin >> m;
    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j <= m; j++)//这里其实处理到m/3就行，因为最多m/3个abc相连。
        {
            f[j] = max(f[j], f[j - i] + a[i]);//i也就是获得a_i分的体积，也就是普通模版的v[i]，在本题中它就是i。
        }
    }
    cin >> s;
    for (int i = 0; i <= m;)
    {
        if (s[i] == 'a' && s[i + 1] == 'b' && s[i + 2] == 'c')
        {
            cnt++, i += 3;//看下三个是不是abc
        }
        else
        {
            ans += f[cnt];//累加答案
            cnt = 0, i++;//把重复次数复原
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：yx666 (赞：2)

# P10721 计算得分 题解
$$\text{Description}$$

小杨设置了一个包含 $n$ 个正整数的计分序列 $A=[a_1,a_2,\ldots,a_n]$。如果字符串的一个子串由 $k(1\leq k \leq n)$ 个 $\texttt{abc}$ 首尾相接组成，那么能够得到分数 $a_k$，并且字符串包含的子串不能够重复计算得分，整个字符串的得分是计分子串的总和。

例如，字符串 $\texttt{dabcabcabcabzabc}$ 的所有可能计分方式如下：

- $\texttt{d+abc+abcabc+abz+abc}$ 或者 $\texttt{d+abcabc+abc+abz+abc}$，其中 $\texttt{d}$ 和 $\texttt{abz}$ 不计算得分，总得分为 $a_1+a_2+a_1$。

- $\texttt{d+abc+abc+abc+abz+abc}$，总得分为 $a_1+a_1+a_1+a_1$。
- $\texttt{d+abcabcabc+abz+abc}$，总得分为 $a_3+a_1$。

小杨想知道对于给定的长度为 $m$ 的字符串，最大总得分是多少。

对于全部数据，保证有 $1\leq n\leq 20$，$1\leq m\leq 10^5$，$1\leq a_i\leq 1000$。

$$\text{Solution}$$

考虑 DP。

### Part 1：定义问题状态
定义 $dp_i$ 表示前 $i$ 个字符构成的子串的最大总得分。

$s$ 表示给定的字符串，$n,m,a_i$ 与题意保持一致（下标均从 $1$ 开始）。

### Part 2：状态转移方程
定义 $j\in N$，表示以 $s_i$ 为最后一个字符，构成了 $j$ 个连续的 $\texttt{abc}$。

记 $p=i-3j+1$，表示 $j$ 个连续的 $\texttt{abc}$ 中开头的 $\texttt{a}$ 的下标，则得到：

$$dp_i=\max(dp_{i-1},\max\{dp_p+a_j\}).$$

注意，上面的方程只存在于：以 $s_i$ 为最后一个字符，可以构成 $j$ 个连续的 $\texttt{abc}$ 时，需要满足以下的代码：

``` cpp
p>=0 && s.substr(p,3)=="abc"
```

### Part 3：初始化与计算顺序
1. 初始化 $dp_0=0$。

2. $i$ 从 $1\to m$，计算 $dp_i$。

### Part 4：答案
$dp_m$。

$$\text{Code}$$

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define N 25
#define M 100005

string s;
int n,m,a[N],dp[M];
// 定义 dp[i] 表示前 i 个字符构成的子串的最大总得分。
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);// 快读
	
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	
	cin>>m>>s;
	
	s=' '+s;				// 将 s 的下标从 1 开始
	for(int i=1;i<=m;++i){
		dp[i]=dp[i-1];
		
		for(int j=1;j<=n;++j){
			int p=i-3*j+1;					// 计算 p
			
			if(p>=0 && s.substr(p,3)=="abc")// 保证可以构成 j 个连续的 abc
				dp[i]=max(dp[i],dp[p]+a[j]);
			else break;
		}
	}
	
	cout<<dp[m];	// 输出答案
	return 0;
}
```

---

## 作者：Licis_Subway (赞：2)

# 1.思路
本题我们可以先预处理出有 $k$ 个 `abc` 的字符串的**最大**得分，然后再遍历整个字符串，找出每一个含有 `abc` 的子串，并将其得分加入答案。

可能这样并不是特别好理解，接下来我来举个例子，方便大家理解。

例如：
```
3
3 1 2
16
dabcabcabcabzabc
```
其中包含了三个**连续**的 `abc` 串，和一个**单独**的 `abc` 串。

把没用的字符去除掉后得：`abcabcabc abc`。

根据前面的计分方式，我们可以预处理所有含有 $k$ 个 `abc` 的字符串的**最大**得分。

对于每一个 $k$，它的最大得分 $P_k$ 可以这样计算：$P_k=\max_{i=0}^{i\le k} P_{k-i}+P_i$。

我们可以算出，$P_1=3$，$P_3=9$。

所以，答案等于 $P_1+P_3=3+9=12$。

拆分这个数，把前面的某一个已经算出来的数和另一个应景算出来的数作比较，取出最优值。这……不是动态规划吗？

所以，本题中，我们可以使用动态规划预处理出含有 $k$ 个 `abc` 的字符串的**最大**得分，然后再计算出总得分。

---

## 作者：封禁用户 (赞：1)

对于这一道题来说，重点则是在于关于每一个 abc 的连续数的最大的得分方式的思考。

但其实这十分的简单，对于每一个 2 至 m 的数，它所用的最大分数则是把所有的两个加起来等于它的自然数对应的最大分数的和的最大数，而相加的两个自然数则已经求过。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[114514],q=-114,l,ans;
string s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	cin>>m;
	cin>>s;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=i/2;j++){//i/2后面是重复的
			a[i]=max(a[i],a[i-j]+a[j]);//自己+0即是a[i]本身
		}
	}
	for(int i=0;i<m-2;i++){
		if(s[i]=='a'&&s[i+1]=='b'&&s[i+2]=='c'){
			if(i-q==3){
				l++;
			}
			else{
				ans+=a[l];
				l=1;//初始化
			}
        q=i;
		}
	}
	ans+=a[l];//最后也要加
	cout<<ans;
	return 0;
}
```

---

## 作者：GeXiaoWei (赞：1)

# P10721 [GESP202406 六级] 计算得分
## 解析
通过题目，我们简单的猜想一下，如果字符串前 $i$ 个字符中，以 $i$ 为结尾出现了 $ok_{i}$ 个连续的 $abc$，具体怎么分，就根据动态规划的求解即可。

对于每一个 $ok_{i}$ 的值如何求解就很简单了。分类讨论一下，若 $i\le 3$，则不可能凑出 $abc$ 从而无。否则 $i>3$ 时，且它自己刚好与前面的两个字符凑出一个 $abc$，那么可得公式 $ok_{i}=\max(ok_{i},ok{i-3}+1)$。

此时再另设 $dp_{i}$ 为前 $i$ 个字符的最大分值，并且在连续的 $ok_{i}$ 个字符中选 $j$ 个计算，那么可得  $dp_{i}=\max(dp_{i},dp_{i-3\times j}+a_{j})$。若 $ok_{i}$ 的值为零，那么就直接从前一位继承即可，即 $dp_{i}=dp_{i-1}$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[25],dp[100005],ok[100005];
char b[100005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	scanf("%d%s",&m,b+1);
	for(int i=3;i<=m;i++) if(b[i]=='c'&&b[i-1]=='b'&&b[i-2]=='a') ok[i]=max(ok[i],ok[i-3]+1);
	for(int i=3;i<=m;i++){
		dp[i]=dp[i-1];
		for(int j=1;j<=min(ok[i],n);j++) dp[i]=max(dp[i],dp[i-3*j]+a[j]);
	}
	printf("%d",dp[m]);
	return 0;
}
```

---


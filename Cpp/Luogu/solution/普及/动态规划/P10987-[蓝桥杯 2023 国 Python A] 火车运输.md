# [蓝桥杯 2023 国 Python A] 火车运输

## 题目背景

为照顾 Python 语言的效率，本题时限较大。建议使用 PyPy3 提交本题。

## 题目描述

钢厂有一辆用于运送废旧钢材的火车，它具有两节车厢，其中车厢 1 的最大载重量为 $A$，车厢 2 的最大载重量为 $B$。现在一共有 $N$ 件废旧钢材需要被运输，其中第 $i$ 件钢材的重量为 $w_i$，为了最大化运输效率，车长想要一次性运输走重量尽可能多的钢材，请你帮助车长计算出一次运输最多可以带走多大重量的钢材。

每件钢材都是独立的不可分割的，只能被放置在某一节车厢中。在装载钢材时只需要考虑重量条件即可。


## 说明/提示

对于 $30\%$ 的评测用例，$1 \le N \le 10$；

对于所有评测用例，$1 \le N \le 200,1 \le w_i
,A,B \le 1000$。

#### 样例解释

车厢 1 装入第 $2$ 件和第 $3$ 件钢材，车厢 2 装入第 $1$ 件钢材。

## 样例 #1

### 输入

```
3 10 8
8 9 1
```

### 输出

```
18```

# 题解

## 作者：yechenguo (赞：18)

这道题是 01 背包变形。

在看完这道题的时候，思路特别清晰，除了这里的价值和质量是一个东西，这不就是 01 背包变成二维了吗？没什么难度啊？

于是，就有了这段代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a,b,w[2005],dp[2005][2005],maxx;
signed main()
{
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++) cin>>w[i];
	for(int i=1;i<=n;i++)
		for(int j=a;j>=w[i];j--)
			for(int k=b;k>=w[i];k--)
			{
				dp[j][k]=max(dp[j][k],dp[j-w[i]][k]+w[i]);
				dp[j][k]=max(dp[j][k],dp[j][k-w[i]]+w[i]);
				maxx=max(maxx,dp[j][k]);
			}
	cout<<maxx;
	return 0;
}
`````
只有 5 分。

经过一段苦思冥想后，我再次茅塞顿开。这道题的 $j$ 和 $k$ 不能直接到 $w_i$ 就结束了，因为如果这样，那有可能有些下标会更新不到。比如，如果 $w_i$ 没有 $0$ 那么 $dp_{w_i,0}$ 等就会更新不到，会影响结果，所以，$j$ 和 $k$ 要取到 $0$。

最后，上代码！！！
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a,b,w[2005],dp[2005][2005],maxx;
signed main()
{
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++) cin>>w[i];
	for(int i=1;i<=n;i++)
		for(int j=a;j>=0;j--)
			for(int k=b;k>=0;k--)
			{
				if(j>=w[i]) dp[j][k]=max(dp[j][k],dp[j-w[i]][k]+w[i]);
				if(k>=w[i]) dp[j][k]=max(dp[j][k],dp[j][k-w[i]]+w[i]);
				maxx=max(maxx,dp[j][k]);
			}
	cout<<maxx;
	return 0;
}
`````

---

## 作者：Arthur_Douglas (赞：7)

## 思路
首先，我们发现，有两节车厢，比较难处理。不像正常的背包问题。要是记录一个也会有后效性。

那问题该怎么解决呢？

我们仔细想想，既然无法在一起处理，不如分开处理。就把 $A$ 和 $B$ 分开枚举。

老样子，定义 $dp_{i,j,k}$ 表示第 $i$ 件物品第一个箱子还剩 $j$ 的空间，第二个箱子还剩 $k$ 的空间时所产生的最大价值。但这样时间复杂度为 $O(nAB)$ ，绰绰有余，但空间也是这样，所以我们要像普通背包一样开滚动数组。


时间：$O(nAB)$，空间：$O(AB)$。

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[1001][1001];
int A[3];
int v[201];
signed main()
{
	int n , a , b;
	cin >> n >> A[1] >> A[2];
	for(int i = 1;i <= n;++ i)
	cin >> v[i];
	for(int i = 1;i <= n;++ i)
	for(int j = A[1];j >= 0;-- j)
	for(int k = A[2];k >= 0;-- k)
	{	
		if(j >= v[i])
		dp[j][k] = max(dp[j][k] , dp[j - v[i]][k] + v[i]);
		if(k >= v[i])
		dp[j][k] = max(dp[j][k] , dp[j][k - v[i]] + v[i]);
	}
	
	cout << dp[A[1]][A[2]];
	return 0;
}
```

---

## 作者：filletoto (赞：2)

## 题目理解
一道背包问题，把题目中钢材重量 $w_i$ 看成背包中的重量和价值，把车厢的最大载重量 $A$ 和 $B$ 看成两个背包的容量。

## 思路
设三维数组 $f_{i,j,k}$ 表示到了第 $i$ 个物品时，第一个背包容量为 $j$ 并且第二个背包容量为 $k$ 时，当前能装下的物品重量的最大值。

转移方程：$f_{i,j,k}=\max(f_{i-1,j-w_i,k},f_{i-1,j,k-w_i})+w_i$。

但是这样做空间就炸了。所以我们需要优化。

观察发现，当前每一个 $i$ 只会和 $i-1$ 有关系，所以我们可以省去第一维。

注意，本题每个物品只可以取一次，所以变量 $j$ 和 $k$ 遍历的时候要进行倒序遍历。原因见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/kho0e59y.png)

## 代码

[AC记录](https://www.luogu.com.cn/record/175402539)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1005;
int n,a,b;
int w[1005];
int f[1005][1005];
int ans=-0x3f3f3f3f;
int main() 
{
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++) 
		cin>>w[i];
    for(int i=0;i<=a;i++) 
    {
		for(int j=0;j<=b;j++) 
		{
			f[i][j]=-0x3f3f3f3f;//初始化数组为负无穷			
		}
	}
    f[0][0]=0;//注意边界处理
    for (int i=1;i<=n;i++) 
	{
        for (int j=a;j>=0;j--)//j和k要倒叙遍历
		{
            for (int k=b;k>=0;k--) 
			{
                if(j>=w[i]) 
					f[j][k]=max(f[j][k],f[j-w[i]][k]+w[i]);
                if(k>=w[i]) 
					f[j][k]=max(f[j][k],f[j][k-w[i]]+w[i]);            
            }
        }
    }
    for(int i=0;i<=a;i++) 
	{
		for(int j=0;j<=b;j++) 
		{
			ans=max(ans,f[i][j]);			
		}
	}
    cout << ans << endl;
    
    
    return 0;
}
```

---

## 作者：Lele_Programmer (赞：2)

# P10987 题解

Python + C++ 题解。

## 思路

背包，设 $f_{i,j,k}$ 为到了第 $i$ 个物品，第一节车厢占用了 $j$ 的容量，第二节车厢占用了 $k$ 的容量，所能装下的物品重量最大值。

则不难列出状态转移方程：$f_{i,j,k} = \max(f_{i-1,j-w_i,k},f_{i-1,j,k-w_i}) + w_i$。

发现每一个 $i$ 只与 $i-1$ 有关，与更前面的 $i$ 无关，所以第一维可以优化掉。

由于每个物品只取一次，所以两个容量都要倒序枚举。

## 代码

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1005;
const int inf=2e9;

int n,a,b;
int w[N];
int f[N][N];
int ans=-inf;

int main() {
    scanf("%d %d %d",&n,&a,&b);
    for (int i=1;i<=n;++i) scanf("%d",&w[i]);
    for (int i=0;i<=a;++i) for (int j=0;j<=b;++j) f[i][j]=-inf;
    f[0][0]=0;
    for (int i=1;i<=n;++i) {
        for (int j=a;~j;--j) {
            for (int k=b;~k;--k) {
                if (j-w[i]>=0) f[j][k]=max(f[j][k],f[j-w[i]][k]+w[i]);
                if (k-w[i]>=0) f[j][k]=max(f[j][k],f[j][k-w[i]]+w[i]);
                ans=max(ans,f[j][k]);
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

### Python

```py
inf=int(2e9)

n,a,b=input().split()
n=int(n)
a=int(a)
b=int(b)

w=input().split()
for i in range(n):
    w[i]=int(w[i])

f=[[-inf for i in range(b+1)] for j in range(a+1)]
f[0][0]=0

ans=-inf

for i in range(n):
    for j in range(a,-1,-1):
        for k in range(b,-1,-1):
            if j-w[i]>=0:
                f[j][k]=max(f[j][k],f[j-w[i]][k]+w[i])
            if k-w[i]>=0:
                f[j][k]=max(f[j][k],f[j][k-w[i]]+w[i])
            ans=max(ans,f[j][k])

print(ans)
```

---

## 作者：tder (赞：2)

You can view the [English version](https://www.luogu.com/article/xqgboyjt/) of this solution.

模板题。

考虑朴素 dp 状态 $f_{i,x,y}$ 表示前 $i$ 个物品两辆车分别装了体积为 $x$ 和 $y$ 的物品，所能得到的最大价值。有转移：

$$
f_{i,x,y}=\max(f_{i-1,x,y},f_{i-1,x-w_i,y}+w_i,f_{i-1,x,y-w_i}+w_i)
$$

注意后面两个表达式需要保证 $x$ 或 $y$ 不小于 $w_i$。

答案即为 $f_{n,x,y}$。

发现这么做空间会炸掉，考虑使用滚动数组压掉第一维。

时间复杂度 $\mathcal{O}(nV^2)$，空间复杂度 $\mathcal{O}(V^2)$。

---

```python
line = list(map(int, input().split()))
# print(line)
n = line[0]
a = line[1]
b = line[2]
w = [0] + list(map(int, input().split()))
# print(w)
f = [[[0 for _ in range(b + 1)] for _ in range(a + 1)] for _ in range(2)]
# print(f)
for i in range(1, n + 1):
	p = i % 2
	q = not p
	for x in range(0, a + 1):
		for y in range(0, b + 1):
			# print(i, x, y)
			f[p][x][y] = f[q][x][y]
			if(x >= w[i]):
				f[p][x][y] = max(f[p][x][y], f[q][x - w[i]][y] + w[i])
			if(y >= w[i]):
				f[p][x][y] = max(f[p][x][y], f[q][x][y - w[i]] + w[i])
print(f[n % 2][a][b])
```

---

## 作者：CaoSheng_zzz (赞：1)

看完这道题目之后，我们优先考虑 DP。

我们设出状态 $f_{i,x,y}$ 取第 $i$ 个钢材时使用了 A 车厢大小为 $x$ 的载重，和使用了 B 车厢大小为 $y$ 的载重。

我们可以得出状态转移方程 $f_{i,x,y} = \max(f_{i-1,x-w_i,y} , f_{i-1,x,y-w_i},f_{i-1,x,y})$。

所以答案为 $f_{n,a,b}$。

但是 $nAB$ 的空间复杂度会炸掉，所以我们考虑使用动态数组。

我们可以发现对于当前的状态 $f_{i}$ 我们只需要知道 $f_{i-1}$ 的状态就可以做状态转移方程，所以我们只需要一直维护 $f_i , f_{i-1}$ 这两个大状态。

然后需要注意在转移的时候维护一下 $x,y$ 的大小。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#include <map>
#include <set>
#define prt printf
#define ll long long
//#define int long long
#define spc putchar(' ')
#define ent putchar('\n')
#define pr_ prt("---")
#define prx prt("***")
#define prtn (putchar('N') , putchar('o'))
#define prty (putchar('Y') , putchar('e') , putchar('s'))
using namespace std;

inline int read(){
	int f = 1 , k = 0 ;
	char c = getchar() ;
	while((c < '0') | (c > '9')) { f = (c == '-' ? -1 : 1) ; c = getchar() ;}
	while((c >= '0') & (c <= '9')) { k = (k << 3) + (k << 1) + (c ^ 48) ; c = getchar() ;}
	return f == - 1 ? -k : k ;
}

void output(int now){
	if(now < 0){
		putchar('-');
		output(- now);
	}
	else{
		if(now > 9) output(now / 10);
		putchar((now % 10) ^ 48);
	}
}

const int maxn = 2e2 + 1 ;
const int maxk = 1e3 + 1 ;
int f[2][maxk][maxk] ;

void Max(int &a , int b) { return a = a > b ? a : b , void(0);}

signed main() {
	int n = read() , A = read() , B = read();
	for(int i=1 ; i<=n ; i++) {
		int now = i % 2 , last = now ^ 1 , d = read() ;
		for(int x=0 ; x<=A ; x++) {
			for(int y=0 ; y<=B ; y++) {
				Max(f[now][x][y] , f[last][x][y]) ;
				if(x + d <= A) Max(f[now][x + d][y] , f[last][x][y] + d) ;
				if(y + d <= B) Max(f[now][x][y + d] , f[last][x][y] + d) ;
			}
		}
	}
	return output(f[n % 2][A][B]) , ent , 0 ;
}
```

---


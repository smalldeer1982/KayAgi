# 书本整理

## 题目描述

Frank 是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以 Frank 首先将书按高度顺序排列在书架上。但是 Frank 发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉 $k$ 本书，使得书架可以看起来整齐一点。

书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有 $4$ 本书：

$1 \times 2$  
$5 \times 3$  
$2 \times 4$  
$3 \times 1$    

那么 Frank 将其排列整齐后是：

$1 \times 2$  
$2 \times 4$  
$3 \times 1$  
$5 \times 3$  

不整齐度就是 $2+3+2=7$。

已知每本书的高度都不一样，请你求出去掉 $k$ 本书后的最小的不整齐度。


## 样例 #1

### 输入

```
4 1
1 2
2 4
3 1
5 3
```

### 输出

```
3```

# 题解

## 作者：学委 (赞：285)

## 先理解题意

对于给出的书本，`Frank`会先把它们按照高度排好序，接下来通过删去一些书本来达到宽度最整齐；不论怎么删去，都是在原有顺序的基础上抽走。

## 为我这种DP初学者的详细分析

（以下的“差”指的是差的绝对值）

“抽走”对于整齐度的影响是很奇怪的：减去自己与两旁书本宽度的差，再加上那两书本宽度的差。尽量转化为已学的模型：**从 $n$ 本书里面挑出 $n-k$ 本，按原顺序排列达到宽度最整齐。**

这是不是很熟悉？如果不，我们一本本地尝试加入，那么**“当前试着把哪一本加入”就是状态的一个维度**（至少要用 $f[i]$）。一步步推导出状态转移方程。

___

取第一本，不用花费（花费即增加“不整齐度”）。

___

第二本书，

①：假如自顾自，成为一长串书本的队首（也就是忽略第一本，从第二本开始取），不用花费。

②：可是如果接上第一本，要花费，好处是队列长度增加到 $2$ 了。发现了吗？**队列长度也是某个维度**(至少要用 $f[i][l]$)。

___

到第三本书，

①：如果忽略前两本，不用花费，但是只取了这么一本书。$f[3][1] = 0$。

②：**如果从第一本或第二本接上，长度都会变成2，那么我们选择花费小的一种方式。$f[3][2] = min( f[1][1] + abs (a[3].w - a[1].w), f[2][1] + abs(a[3].w - a[2].w) )$。**

③：如果前两本都接上，队列成为 $1,2,3$。

___

尝试加入第四本书，

①：也可以从自己开始取，$f[4][1] = 0$。

②：也可以从 $1$ 或 $2$ 或 $3$ 其中一本接上，长度都会变成 $2$，择优。

③：也可以从长度为 $2$ 的队列接上^，择优。

④：也可以接上 $1,2,3$ 这个长度为 $3$ 的队列。

^**此时前三本中花费最小、长度为2的队列已经存储在 $f[2][2]$ 和 $f[3][2]$，为什么不直接用一个 $f[2]$ 存储？因为第四本与 $2,3$ 两本书相邻的代价是不同的**。不存在 $f[1][2]$，因为取到第一本的时候没有长度为 $2$ 的队列。

___

第五本，第六本依此类推。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, k, m, Min = 0x7fffffff;
int f[501][501];
//f[i][l]：以i作末尾，选了l本书时的最小花费

struct info
{
	int h, w;
}a[1001];

bool cmp(const info & x, const info & y)
{
	return x.h < y.h;
}

int main()
{
	cin >> n >> k;
	m = n - k;//选取m本书 
	for(int i = 1; i <= n; i++)
		scanf("%d %d", &a[i].h, &a[i].w);
		
	sort(a+1, a+n+1, cmp);//高度决定顺序
	
	memset(f, 20, sizeof(f));//初始极大，能缩小就缩小
	
	for(int i = 1; i <= n; i++)
		f[i][1] = 0;
	//单独选择任何书都不会有花费
	 
	for(int i = 2; i <= n; i++)//试着放第i本的时候 
		for(int j = 1; j <= i-1; j++)//尝试与前面第j本相邻
			for(int l = 2; l <= min(i, m); l++)//放下第i本时，能从之前长1的队列继承为长2的队列，也能从之前长2的队列继承为长3的队列……l表示放下后的长度
            //显然试到第i本时，长度不会超过i，也不会超过m，m是最终需要的长度
				 
				f[i][l] = min(f[i][l], f[j][l-1] + abs(a[i].w - a[j].w/*这是尝试相邻的书本*/));//放第i本继承到长度为l，总花费越小越好
		
	for(int i = m; i <= n; i++)
		Min = min(Min, f[i][m]);//i的循环的意思是：以m结尾的队列，可能最小，以m+1结尾的队列也可能的……以n结尾的队列也可能。
	
	printf("%d\n", Min);
	return 0;
}

```

---

## 作者：cxy004 (赞：67)

这题可以用一点小小的技巧：用逆向思维思考，题目要求拿走k本书，就等同于留下n-k本书。这样考虑的话思路会清晰很多。

所以可以把k处理为n-k，解决留下k本书的问题。


f[i][j]表示在前i本书中留下j本书，且第i本书必定留下的最小不整齐度。


状态转移方程：

前i本书中留下j本书，因为第i本书必定留下，所以只需考虑在前i-1本书中如何留下j-1本书，设其中第j-1本书为t，则有


f[i][j]=min{f[t][j-1]+Abs(s[i]-s[t]) | j<t<i}

由于不需要一定保留第n本书，所以解ans=min{f[i][k] | k<=i<=n}


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int n,m,f[101][100],Ans=2147483647;
struct Node
{
    int h,l;
}s[101];

bool cmp(const Node &a,const Node &b) {return a.h<b.h;}

int Min(const int &a,const int &b) {return a<b?a:b;}

int Abs(const int &x) {return x<0?(-x):x;}

int main()
{
    scanf("%d%d",&n,&m);m=n-m;
    for(int i=1;i<=n;++i) scanf("%d%d",&s[i].h,&s[i].l);
    sort(s+1,s+n+1,cmp);
    for(int i=2;i<=n;++i) for(int j=2;j<=Min(i,m);++j)
    {
      f[i][j]=2147483647;
      for(int k=j-1;k<i;++k) f[i][j]=Min(f[i][j],f[k][j-1]+Abs(s[i].l-s[k].l));
    }
    for(int i=m;i<=n;++i) Ans=Min(Ans,f[i][m]);
    printf("%d",Ans);
    return 0;
}
```

---

## 作者：lwz2002 (赞：35)

## 思路

一句话题意：在$n$本书中去掉$k$本，使得两两之间的宽度差最小。

很明显，这是一道$DP$题（~~我以后再也不要加上这句话了  真香~~），既然是$DP$我们就要设计状态和转移，一维的状态是不可能的了，我们直接从二维开始。

我们可以设计一个状态$f_{ij}$表示前$i$个数中去掉$j$个的最小不整齐度，仔细思考一下，我们在去掉一本书时，它改变的不整齐度为前一本书和后一本本的宽度差和它与两本书的宽度差，前一本书我们不能保证是哪一本书，我们只能用枚举来表示，但后一本书呢，我们发现无法处理了，所以这样做貌似不行（也可能是我太弱了QAQ）；

我们不妨反过来思考，在$n$本书中去掉$k$本书也就是相当于在$n$本书中选取$n-k$本书，所以我们的状态$f_{ij}$可以表示为前$i$本书中选取$j$本的最小不整齐度，在转移时我们只需要关注前一本书是哪一本，而后一本书是不需要我们考虑的，所以转移方程也就显而易见了：

$f[i][l]=min(f[i][l],f[j][l-1]+abs(a[i].width-a[j].width));$

$i$表示枚举到了第几本书，$l$表示当前已经选取了几本书

意思为前$i$本书选取l个的最小不整齐度为前$j$本书中选取$l-1$本书的最小不整齐度$+$当前这本书与第$j$书的宽度差（也就是说从$j+1$到$i-1$的书都不选取）。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 2147483647
#define ll long long

using namespace std;
struct node
{
	int heigh;
	int width;
}a[110];
int n,m,k,minl=MAXN;
int f[110][110];  //f[i][j]表示前i本书选取j本的最小不整齐度 
bool cmp(node a,node b)
{
	return a.heigh<b.heigh;
}
int main()
{
	memset(f,127,sizeof f);
	scanf("%d%d",&n,&k);
	m=n-k;
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].heigh,&a[i].width);
	sort(a+1,a+n+1,cmp);
	for(int i=0;i<=n;i++)
		f[i][1]=0;
	for(int i=2;i<=n;i++)
		for(int j=1;j<i;j++)
			for(int l=2;l<=min(i,m);l++)
				f[i][l]=min(f[i][l],f[j][l-1]+abs(a[i].width-a[j].width));
	for(int i=m;i<=n;i++)
		minl=min(minl,f[i][m]);
	printf("%d",minl);
	return 0;
}
```

---

## 作者：ghj1222 (赞：30)

那个...dp的思想请看楼下诸位dalao...
我只是介绍一种奇葩的数据处理方法

由题可知，我们的高度h和宽度d是<=200的，那么8位就可以存下，何况16位 32位。。。大家都应该是开一个结构体sort的，而我是把高度放到高位，宽度放到低位sort，然后截掉高位(因为已经没用啦~)具体，输入高度之后左移16位(然而我在程序里面左移的18位。。。不影响)，然后加上宽度。这样形成了一个“组合体”。

sort比较的时候肯定是按照高位先比的(我们小学不就是这么学的啊)，然后在比较低位，由于书的身高不相同，所以不用担心高度相同的问题。。。

截低位的时候直接转换成short，只保留低16位，高的不翼而飞啦

还有要注意的就是答案要从[n-k][n-k]到[n][n-k]中去取最小值。

还有边界条件是f[i][1]=0，就是不管怎么着你摆一本书不整齐度都是0~

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstring>
using namespace std;
int n,m;
int a[110],x,f[110][110];//f[i][j]代表从1..i中留下来j本书的最小不整齐度(但必须包含i) 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>x;
		a[i]<<=18;//把高度弄到高位 
		a[i]+=x;//把宽度弄到低位 
	}
	sort(a+1,a+1+n);//使用brain来获得“为什么要这种方法可行”的答案 
	for(int i=1;i<=n;i++)
		a[i]=(short)a[i];//把高位扔了，只留下低位 
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<=n;i++)f[i][1]=0; 
	for(int i=1;i<=n;i++)//把第i本放那不动 
		for(int j=1;j<=i;j++)//最少要把第i本留下，最多你留几本都不管你
			for(int k=j-1;k<=i-1;k++)//从f[k][]推过来的
				f[i][j]=min(f[i][j],f[k][j-1]+abs(a[i]-a[k]));
	int ans=99999999;
	for(int i=n-m;i<=n;i++)
		ans=min(ans,f[i][n-m]);
	printf("%d\n",ans);return 0l;
}
```

---

## 作者：火箭升空 (赞：23)

首先理解题意：他说要从n本书中去掉k本，也就是说要留下n-k本书

于是我们定义数组f[i][j], 它表示的是前i本中，留下j本，其中一定包括第i本，的最小不整齐度 

接下来就该思考如何设状态转移方程了：

因为前i本中要留下j本，第i本又必须留下，所以就相当于前i-1本书留下j-1本，假设j-1到i中留下的书为t，就可以得出：

	f[i][j] = min(f[i][j], f[t][j - 1] + abs(a[i].w - a[t].w));(这很好理解，仔细想一下）
    
下面看具体的代码实现：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 110
struct Edge{
	int h, w;
} a[MAXN];
int sum[MAXN], f[MAXN][MAXN];//表示前i本中，留下j本，其中一定包括第i本，的最小不整齐度 
int n, k;
bool cmp(Edge x, Edge y) {
	return x.h < y.h;
}
int main() {
	cin >> n >> k;
	k = n - k;//直接把k变成要留下的本数
	for (int i = 1; i <= n; i++) {
		cin >> a[i].h >> a[i].w;
	}
	sort(a + 1, a + 1 + n, cmp);
	memset(f, 0x3f, sizeof(f));
	for (int i = 1; i <= n; i++) {
		f[i][1] = 0;//留下1本， 不整齐度一定是0啦
	}
	for (int i = 2; i <= n; i++) {
		for (int j = 2; j <= k && j <= i; j++) {
			for (int t = j - 1; t < i; t++) {
				f[i][j] = min(f[i][j], f[t][j - 1] + abs(a[i].w - a[t].w));
			}
		}
	}
	int ans = 0x3f3f3f3f;
	for (int i = k; i <= n; i++) {
		ans = min(ans, f[i][k]);
	}
	cout << ans << endl;
	return 0;
}
```

这是本蒟蒻第一次发题解，求求管理员给通过啦qwq


---

## 作者：djy213 (赞：19)

看了大家的题解

我只能很不厚道的说。。。我是来打脸的


f[i][j]:  在考虑前i个时拿走j本且i必保留时的最优解

状态转移方程

f[i][j]=f[l=(i-j-1 to i-1)][j-(i-l-1)]+|a[i]-a[l]|
前i个时拿走j本且i必保留时的最优解，他当然可以是在前l个中拿一些书并把l到i间的书全拿走造成的；

即，前i个时拿走j本且i必保留时的最优解，为前l（找出这个l）个时拿走j-(i-l-1)本且l必保留时的最优解，加i与l的差；

然后在合适的区间内(i-j-1 to i-1)循环l使之最优；

代码如下：

‘’‘

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct ss
{
    int h,w;
}x[101];
int f[101][101];
bool cmp(ss a,ss b)
{
    return a.h<b.h;
}
int abs(int a)
{
    if(a<0)return 0-a;
    return a;
}
int main()
{
    int i,j,l,ans=214748364;
    int n,k;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
        scanf("%d%d",&x[i].h,&x[i].w);
    sort(x+1,x+n+1,cmp);
    for(i=1;i<=n;i++)
        for(j=0;j<=k&&j<=i-2;j++)
            f[i][j]=214748364;
    for(i=2;i<=n;i++)
        for(j=0;j<=i-1&&j<=k;j++)
            for(l=i-j-1;l<=i-1;l++)
            {
                if(f[i][j]>f[l][j-(i-l-1)]+abs(x[i].w-x[l].w))
                   f[i][j]=f[l][j-(i-l-1)]+abs(x[i].w-x[l].w);
            }
    for(i=n-k;i<=n;i++)
        if(f[i][k-(n-i)]<ans)
            ans=f[i][k-(n-i)];
    printf("%d",ans);
    return 0;
}
//f[i][j]=f[l=(i-j-1 to i-1)][j-(i-l-1)]+|a[i]-a[l]|
’‘’
```

---

## 作者：Y_B_Y (赞：13)

### 因为本人比较蒟蒻,所以用了3维的数组

###### 注:这一题要自己排序

$f[i][j][l]$,前$i$本书,没有被去掉的最后一本书的宽度为$j$,共去掉了$l$本数的最小不整齐度

#### 观察题目我们发现第$i$本书只有拿或不拿

- 如果拿,不整齐度就会加上它的宽度与没有被去掉的最后一本书的宽度之差的绝对值,且它就变成了没有被去掉的最后一本书,去掉的书的数目不变

- 不拿,就相当于把这本书去掉了,不整齐度不变,最后一本书不变,都是去掉书的数目加一

代码
```cpp
for(int i=2;i<=n;i++)//第几本书,从2开始,第1本书是初始化的
	{
		for(int l=0;l<=k;l++)//去掉了几本,注意从0开始
		{
			for(int j=1;j<=200;j++)//枚举前i-1本书被去掉的最后一本书
			{
				f[i][j][l]=min(f[i][j][l],f[i-1][j][l-1/*因为去掉书的数目要加一,所以用这里l-1(这里是l-1,加1不就是l来)*/]);//不拿
				f[i][a[i].w/*因为拿,最后一本更新为第i本*/][l]=min(f[i][a[i].w][l],f[i-1][j][l]+abs(a[i].w-j));//拿
			}
		}
	}
```


#### 初始化

先把所有定义为一个很大的数 
```
memset(f,25,sizeof(f));
```
但是第一本书是可以先确定的(其他的也要靠它推出来)

根据前面一本书只有拿或不拿

所以初始化第一本书也只有拿和不拿

直接上代码讲吧

```cpp
for(int j=1;j<=200;j++) f[1][j][1]=0;//不拿,前面没有书所以最后一本书可以是任意一本,之后如果有书与它计算一定是0(不影响结果不就相当于拿掉了)
f[1][a[1].w][0]=0;//拿,最后一本书就是它,但是只有一本书所以没有差值
```
#### 输出

因为最后一本不确定所以最后要枚举最后一本取最小值输出

代码
```cpp
for(int j=1;j<=200;j++) ans=min(ans,f[n][j][k]);//ans先定义一个很大的数
cout<<ans;//输出
```


完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[110][201][101],ans=12356478;
struct book
{
	int h,w;//h高,w宽
}a[10000];
int cmp(book s1,book s2)//送人头用的函数,表示高度从小到大排序
{
	return s1.h<s2.h;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].h;
		cin>>a[i].w;
	}
	sort(a+1,a+n+1,cmp);//排序
	memset(f,25,sizeof(f));
	for(int j=1;j<=200;j++) f[1][j][1]=0;
	f[1][a[1].w][0]=0;
	for(int i=2;i<=n;i++)
	{
		for(int l=0;l<=k;l++)
		{
			for(int j=1;j<=200;j++)
			{
				f[i][j][l]=min(f[i][j][l],f[i-1][j][l-1]);
				f[i][a[i].w][l]=min(f[i][a[i].w][l],f[i-1][j][l]+abs(a[i].w-j));
			}
		}
	}
	for(int j=1;j<=200;j++) ans=min(ans,f[n][j][k]);
	cout<<ans;
}
```



---

## 作者：Spiritsu (赞：11)

话说...这题没用记忆化的啊（~~记忆化不就是dp嘛~~）
   
   上代码就是了
     
   首先先排一遍序（废话）
   
   然后我的做法是先枚举前面有几本书没选（~~其实我只是懒得在递归里写~~还被大佬骂了）
   
   dfs里的参数是现在选到了哪本书，已经删了几本书，还有已经选了几本书
   
   然后看代码就行了 简单易懂（~~自己都看不懂~~）
   
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define maxn 105
using namespace std;
int n,k;
struct Book{int h,w;}a[maxn];
int f[maxn][maxn];
int abs(int x){return x<0?-x:x;}
int dfs(int now,int cnt,int xuan){
	if(f[now][cnt]!=-1) return f[now][cnt];
	int ans=19260817;
	if(now==n) return 0;
	if(n-xuan==k) return 0;//如果总数减去已选的数量恰好等于k（要删的）后面的一定可以全删去  ~~显然~~（大佬说）
	if(cnt==k) return f[now][cnt]=dfs(now+1,cnt,xuan+1)+abs(a[now+1].w-a[now].w);//已经删了k本，剩下的要全加
	for(int i=1;i<=n;i++)
		if(now+i<=n&&cnt+(i-1)<=k) ans=min(ans,dfs(now+i,cnt+(i-1),xuan+1)+abs(a[now+i].w-a[now].w));//向后跳i本书，中间全删去
	return f[now][cnt]=ans;
}
bool cmp(Book aaa,Book bbb){return aaa.h<bbb.h;}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i].h,&a[i].w);
	sort(a+1,a+n+1,cmp);
	memset(f,-1,sizeof(f));
	int ans=19260817;
	for(int i=1;i<=k+1;i++){
		ans=min(ans,dfs(i,i-1,1));//第几本 已经删了几本 选了几本留下
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zhaimingshuzms (赞：11)

#这题可以滚起来

楼下的代码没有滚动的，我就写个滚动的，采用从n本书中选n-k本这种动归方式（显然这样更好思考）。滚动的好处就是更好理解（真的吗），初始化更简单，空间更小（好像没什么用），总之比不滚动好；

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=101,P=1e9;//P是某个大数
pair<int,int>a[N];//捆绑在一起，sort时就不用写cmp了
int n,k,ans=P,f[N];
int main()
{
    scanf("%d%d",&n,&k);
    for (int i=1; i<=n; i++) scanf("%d%d",&a[i].first,&a[i].second);
    sort(a+1,a+n+1);
    for (int j=2; j<=n-k; j++)//i——考虑第i个；j——选了j个
    for (int i=n; i>=j; i--)//滚动时i要倒着扫，才能参考j-1行的表格，因为l总是小于i
    {
        f[i]=P;
        for (int l=j-1; l<=i-1; l++)
        f[i]=min(f[l]+abs(a[i].second-a[l].second),f[i]);
    }
    for (int i=n-k; i<=n; i++) ans=min(ans,f[i]);//i从n-k开始扫，之前的由于不到需选书的数目，不可能是答案
    printf("%d",ans);
    return 0;
}
```

---

## 作者：NOIPer40 (赞：6)

看到没有人写图dp的，那我来写一篇图dp思路的题解。

# 题意分析

### 基本思想

首先，看到这道题后，我们会轻而易举地想到 dp 的思路，并且也能很容易地定义状态 $f[i][j]$ 为从书架第一本书遍历到第 $i$ 本书时，总共除去了 $j$ 本书的最小不整齐度。然而，在列状态转移方程的时候，我的思路有**亿些**混乱，所以打算借用图这种简单、易理解的方法来解决。

**记得对书进行按高度值的排序！记得排序！记得排序！**

### 样例数据分析

$1×2$ 为 $1$ 号书

$2×4$ 为 $2$ 号书

$3×1$ 为 $3$ 号书

$5×3$ 为 $4$ 号书

这是书架上书的排列，乘号左边的数是高度，乘号右边的数是宽度。

从第 $i$ 本书向第 $j$ 本书建一条边，表示从书架中抽走从 $i$ 到 $j$ 之间的书，这条边有以下数据：

 $wgh[x]$ 为第 $x$ 条边两端的书宽度的差的绝对值；
 
 $cost[x]$ 为第 $x$ 条边的两端点的书之间抽走的书的数量。
 
 以 $0$ 为初始节点，向其他书建边；以 $n+1$ 为末尾结点，向其他书建边。这样做的好处等会就可以在代码中看到。
 
 注意：此处建的边均为有向边，以减少不必要的麻烦。
 
 把样例数据用图来表示，如下：
 ![](https://cdn.luogu.com.cn/upload/image_hosting/e404z8m1.png)
 
 显然对于一条连接 $i$，$j$ 的编号为 $x$ 边， $cost[x]=j-i-1(j>i)$，且只需建 $cost[x]<=k$ 的边 $x$。
 
 就这样，这个问题就变成了图 dp，我们只需通过 dfs 来实现即可。
 
 状态转移方程可以写成 $f[to[e]][j]=min{f[i][j-cost[e]]+wgh[e]}$，其中 $e$ 为以 $i$ 为起始点的边的编号。而答案就显而易见了： $f[n+1][k]$。
 
#  代码实现

### 代码1


```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int n,k,f[110][110],head[110],nxt[10010],to[10010],wgh[10010],cost[10010],cnt/*链式前向星，记得开到n^2级别*/;
struct book{
    int h,w;
    bool operator <(book b2){
        return h<b2.h;
    }//按高度值排序，重载比较运算符，方便使用sort函数
}b[110];//书结构体
void add(int u,int v,int w,int c){
    to[++cnt]=v;
    wgh[cnt]=w;
    cost[cnt]=c;
    nxt[cnt]=head[u];
    head[u]=cnt;
}//建边
void dfs(int x,int fa,int lc,int nc,int nw){
/*x:当前点 fa:搜索时的上一个点 lc:从起点到fa的cost值之和
nc:从fa到x的边的cost值 nw:从fa到x的边的wgh值*/
    f[x][lc+nc]=min(f[x][lc+nc],f[fa][lc]+nw);//状态转移
    for(int i=head[x];i;i=nxt[i]){
        int ti=to[i],wi=wgh[i],ci=cost[i];
        if(ti==fa || ti>=n+2)
            continue;
        dfs(ti,x,lc+nc,ci,wi);
    }
}//dfs dp
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&b[i].h,&b[i].w);
    sort(b+1,b+n+1);//排序
    for(int i=0;i<=n;i++)
        for(int j=i+1;j<=min(n+1,i+k+1);j++){
            int w=(!i || j==n+1)?0:abs(b[i].w-b[j].w);
            add(i,j,w,j-i-1);//建边
        }
    memset(f,0x3f,sizeof(f));
    dfs(0,-1,0,0,0);
    printf("%d",f[n+1][k]);
    return 0;
}
```



然而当你把这份代码提交上去之后，你会惊喜地发现它全 RE 了。原因就在于当它 dfs 时，可能会走很多次同一个点。那能不能记录一个点被访问的次数，当它到达 $k$ 时就不再访问呢？也不行。我们再看一下这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/e404z8m1.png)

走到 $4$ 可以从 $3$ 或 $2$ 走，走到 $3$ 可以从 $2$ 或 $1$ 走。这就导致了即使对于从 $3$ 走到 $4$ 节点，也会不只有 $1$ 次！

怎么办呢？推出来一个式子，用来限制访问次数肯定是可行的，然而时间复杂度貌似也会很高（因为懒没具体推算）。所以我借用一下bfs和常规的dp的思路，限制访问次数为 $k$ ，即必须先**完全**更新完上一节点的 $f$ 值，才能更新由它出发的边所连接的节点的 $f$ 值。为了方便，我修改了 $wgh[i][j]$ 的意义为从 $i$ 开始的 $cost$ 值为 $j$ 的边，两端点书的宽度差绝对值。而我在上面已经说过一条边的 $cost$ 值可以通过它两端点的编号来表示，于是：

关于 $cost$ ~~他死了~~。

附上更改后的代码：

### 代码2



```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int n,k,f[110][110],wgh[110][110];//修改了wgh值的定义，删除了cost值
struct book{
	int h,w;
	bool operator <(book b2){
		return h<b2.h;
	}
}b[110];
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&b[i].h,&b[i].w);
	sort(b+1,b+n+1);
	for(int i=0;i<=n;i++)
		for(int j=i+1;j<=min(n+1,i+k+1);j++)
			wgh[i][j-i-1]=(!i || j==n+1)?0:abs(b[i].w-b[j].w);
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<=k;i++)
		f[i][i]=0;
	f[1][0]=0;
	for(int i=1;i<=n+1;i++){
		for(int j=0;j<=k && j<=i-1;j++)
 			for(int p=j;p<=k;p++)
				f[i][p]=min(f[i][p],f[i-j-1][p-j]+wgh[i-j-1][j]);
	}//伪bfs dp
	printf("%d\n",f[n+1][k]);
	return 0;
}
```





这种方法的时间复杂度为 $n^2$，完美通过。

# 后记

其实代码2已经呈现出一种常规 dp 的形式了，与题解中其他代码大同小异，也就是说，图 dp 思路最终回到了常规 dp 的方向上。然而这种思路对我们最大的启发（也是与其他思路最大的不同）就在于，当觉得直接写方程思路混乱时，我们可以考虑把文字、数字问题抽象为图上的问题，这样我们一下子就能看清楚接下来该怎么做了。我们可以不经过打代码1这个过程，而只是思路上经过就行了。

---

## 作者：DEADFISH7 (赞：5)

题目的要求中 可知 有多少书，有书被去掉

然后对于不整齐度会按每本书计算

所以规划之中一定要有 书的量，哪本书 

然后就枚举求最小
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define N 150
using namespace std;
int n,k;
int f[N][N]; //放i个书，最后一本是j 
struct node
{
	int w;
	int h;
} a[N];结构体为了方便排序
bool cmp(node x,node y)
{
	return x.h<y.h;
}
int main()
{
	std::ios::sync_with_stdio(false);//提高cin的速度
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i].h>>a[i].w;
	int w=n-k;
	memset(f,10000,sizeof(f));
	sort(a+1,a+n+1,cmp);//整理数据便于后续的操作
	for(int i=1;i<=n;i++) f[1][i]=0;//初始化
	for(int i=2;i<=w;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int p=j+1;p<=n;p++)//以j为每一个需要计算的点
            //然后q的作用就是求min了
			{
				f[i][j]=min(f[i][j],f[i-1][p]+abs(a[p].w-a[j].w));
			}
		}
	}
	int ans=999999999;
	for(int i=1;i<=n;i++)
	{
	   ans=min(ans,f[w][i]);
    }
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：青鸟_Blue_Bird (赞：4)

一道很好的DP入门题，~~适合像我这种学了大半年却还不会DP的人。~~

首先，题目要求我们将书本按照高度排序，在这里我们可以用结构体实现。

其次才是重点，推DP方程。

题目中说抽走K本书，我们不妨转换一下：

### 从n本书中留下（n - k)本。

然后，寻找每本书之间的关系：

##### 对于第一本书，如果留下，花费显然只能是0。


##### 对于第二本书，如果留下：

1、可以选择将自己作为开头，或者与前面的书连在一起。

2、当然，我们也可以不留下。

##### 对于第三本书，如果留下：

1、自己作为开头
2、与第一本书连接或者与第二本书连接
3、不留下

那么，我们想办法将每本书的与前面的书形成联系：

设置$f_{i,j}$表示第$i$本书，与前面的书连接形成长为$j$的连接。

那么，有：

$f_{i,i}$ = 0

$f_{i,j}$ = min($f_{i,j}$, $f_{i,x-1}$ + $abs$($w_i$ - $w_x$)  其中$x$指与前面连接的书的编号。

那么，废话不多说，上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1010

inline int read(){
	int x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){
		if(c == '-')s = -1;
		c = getchar();
	}
	while(isdigit(c)){
		x = x * 10 + (c ^ '0');
		c = getchar();
	}
	return x * s;
} 

int f[N][N];

struct node{
	int h, w;
} t[N];

bool cmp(node a, node b){
	return a.h < b.h;
}

int main(){
	int n = read(), k = read();
	for(int i = 1; i <= n; i++){
		t[i].h = read(), t[i].w = read();
	}
	sort(t + 1, t + n + 1, cmp);
	memset(f, 127, sizeof(f));
	for(int i = 1;i <= n; i++){
		f[i][1] = 0;  //只选自己时的费用为0
	}
	for(int i = 2;i <= n; i++){ //试着放第 i 本 
		for(int j = 1;j <= i - 1; j++){  /*从哪一本开始连接*/
			for(int l = 2;l <= min(i, n - k); l++){ /*继承多长*/
				f[i][l] = min(f[i][l], f[j][l - 1] + abs(t[i].w - t[j].w));
			}
		} 
	}
	int ans = (int)9e9;
	for(int i = 1; i <= n; i++)
		ans = min(ans, f[i][n - k]);
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：槑小杨 (赞：4)

这题可以用一点小技巧：题目要求拿走k本书，就等同于留下n-k本书。所以可以把k处理为n-k，解决留下k本书的问题。

f[i][j]表示在前i本书中留下j本书，且第i本书必定留下的最小不整齐度。

前i本书中留下j本书，因为第i本书必定留下，所以只需考虑在前i-1本书中如何留下j-1本书，设其中第j-1本书为t，动态转移方程就很好写了，具体见代码：

```
#include<bits/stdc++.h>
#define f(i,l,r) for(i=(l);i<=(r);i++)
using namespace std;
const int MAXN=105;
struct Book{
	int h,w;
	bool operator < (const Book& x)const{
		return h<x.h;
	}
}a[MAXN];
int n,m,k,dp[MAXN][MAXN],ans=0x7fffffff; //ans开最大
int main()
{
	memset(dp,127,sizeof(dp));
	int i,j;
	cin>>n>>m;
	m=n-m;
	f(i,1,n){
		cin>>a[i].h>>a[i].w;
	}
	sort(a+1,a+1+n); //排序
	dp[1][1]=0;
	f(i,2,n){
		dp[i][1]=0;
		f(j,2,min(i,m)){
			f(k,j-1,i-1){
				dp[i][j]=min(dp[i][j],dp[k][j-1]+abs(a[i].w-a[k].w));
			}//动态转移方程
		}
	}
	f(i,m,n){
		ans=min(ans,dp[i][m]); //不需要一定保留第n本书
	}
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：AKB48 (赞：4)

本题最正确的解法是动态规划：

设f[i,j]为保留i本书，在前i本书中去掉j本书所能获得的最小的复杂度。

先在这里写出动态规划状态转移方程，再来一步一步解释：

f[i,j]=min{f[i-k,j-k+1]+abs(a[i]-a[i-k])}(1<=k<=j+1)

边界为f[i，0]=前i本书去掉0本的复杂度，f[i,i-1]:=0；

什么意思呢？首先，k循环是从1到j+1的。当k为1时，f[i-k,j-k+1]表示在前i-1本书中，去掉j本书的最小复杂度，再加上第i本书与第i-1本书的差的绝对值。当k为2时，f[i-k，j-k+1]表示，在前i-2本书中去掉j-1本书的最小复杂度，再加上第i本书与第i-2本书的差的绝对值。为什么是去掉j-1本书呢？因为此时第i-2本书与第i本书之间还有一本第i-1本书，这已经相当于去掉了一本书。这样，一次类推，f[i,j]就相当于这些所有的最小值。

当然，问题的答案并不是f[n,m]。注意f[i,j]的定义：

设f[i,j]为保留第i本书，在前i本书中去掉j本书所能获得的最小的复杂度。

最优解不一定保留第n本书，所以答案应为：min{f[n-k,m-k+1]}(0<=k<=m+1)原理同前面一样。


---

## 作者：wuhao1027 (赞：3)

发现了一道没什么人写的题目呢！楼下已经有两个cpp的代码了，我就写一个C风格的伪cpp代码吧。内容会很清楚，适合新手学。另外请大家学好代码风格，不然看起来会很难看。这一题的思路和背包问题很像，就是看在书本数量为一个定值的时候 杂乱度 的和的大小，注释在代码里很清楚了


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define MIN(a,b) (a)>(b)?(b):(a)  //定义宏函数
#define max 2147483647    //用可读字符替代一个数字，这个习惯是很有必要的
int abs(int m)
{
    return m>0?m:-m;  //这里的宏函数我改了半天都是bug，就放弃了，改用正版函数
}
int A[110][110];
struct node{       //定义结构体，方便存储书的高度（h）和宽度（b）
    int h,b;
}S[110];
bool cmp(node a,node b)    //bool类型只有cpp才可以用，建议纯用C的同学接触下cpp，比如这一题里面将高度排序，就可以用现成的函数了。      
{
    return a.h<b.h;
}
int main()
{
    int i,j,n,k,l,ans=max;
    scanf("%d%d", &n,&k);
    for (i=1;i<=n;i++) scanf("%d%d", &S[i].h,&S[i].b);
    sort(S+1,S+n+1,cmp);
    for (i=2;i<=n;i++)
        for (j=2;j<=n-k && j<=i;j++){  //j小于等于n-k即可，因为我们只需要知道n-k本书的杂乱度
            A[i][j]=max;
            for (l=j-1;l<i;l++)  //注意l=j-1
                A[i][j]=MIN(A[i][j],(A[l][j-1]+abs(S[l].b-S[i].b))); //l要变化是因为要把所有的值都比较一遍（这里是整道题的思路关键）
        }
    for (i=n-k;i<=n;i++) ans=MIN(ans,A[i][n-k]);
    printf("%d", ans);
    return 0;
}
```

---

## 作者：Skywalker_David (赞：3)

直接从去掉多少书来划分阶段是没有思路的。

可以把问题转化成求在n本书中选出n-k本书的最小值。

设f[i,j]表示在前i本书选j本书的最小值。

f[i,j]=min{f[l,j-1]+abs(w[i]-w[l])} (1<=i<=n,2<=j<=min{i,n-k},j-1<=l<=i-1)

则ans=min{f[i,n-k]} (n-k<=i<=n)

```delphi

Var
   f:array[0..100,0..100]of longint;
   w:array[0..100]of longint;
   n,k,i,j,l,ans:longint;
procedure init;
   var high:array[0..100]of longint;tmp:longint;
   begin
   readln(n,k);
   for i:=1 to n do
      readln(high[i],w[i]);
   for i:=1 to n do
      for j:=i+1 to n do
         if high[i]>high[j] then
         begin
         tmp:=high[i];high[i]:=high[j];high[j]:=tmp;
         tmp:=w[i];w[i]:=w[j];w[j]:=tmp;
         end;
   end;
function min(a,b:longint):longint;
   begin if a<b then exit(a)else exit(b);end;
procedure dp;
   begin
   for i:=1 to n do
      for j:=2 to min(i,n-k) do
         begin
         f[i,j]:=maxlongint;
         for l:=j-1 to i-1 do
            f[i,j]:=min(f[i,j],f[l,j-1]+abs(w[i]-w[l]));
         end;
   end;
procedure outf;
   begin
   ans:=maxlongint;
   for i:=n-k to n do
      if ans>f[i,n-k] then ans:=f[i,n-k];
   writeln(ans);
   end;
Begin
init;
dp;
outf;
End.

```

---

## 作者：YLWang (赞：2)

# DP
# 还是dp

首先要注意，要按高度sort一遍后再做dp，看题还是要仔细； 
对于dp本身，是要求去掉k本书后的最小绝对值之和；晕了半小时之后发现这是个LIS的变型。。。瞬间感觉又简单了不少

既然是子序列类型的题目，我们不妨把将去掉k本书转化为留下n-k本书以方便转移； 

f[i][j]表示以i结尾是留j本书的最小值; 
同样，类比子序列类型的题目，推出方程
```
#include<bits/stdc++.h>
using namespace std;
int f[500][500];
struct ff
{
	int h,k;//长 宽  
	friend bool operator<(ff a,ff b) {//重载运算符 安高排序 
		return a.h<b.h;
	}
}a[500];
int n,k;
int ans=0x7fffff;//无限大 
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++) scanf("%d%d",&a[i].h,&a[i].k);
    sort(a+1,a+n+1);
    memset(f,63,sizeof(f));
    int i,j,t;
    for(int i=0;i<=n;i++) f[i][1]=0;//只有一本时绝对值差为0
    for(int i=1;i<=n;i++)
        for(int j=1;(j<=n-k)&&(j<=i);j++)
            for(int t=1;t<i;t++)
                f[i][j]=min(f[i][j],f[t][j-1]+abs(a[i].k-a[t].k));
    for(int i=1;i<=n;i++)
        ans=min(ans,f[i][n-k]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：cold_cold (赞：2)

* 第一步：先把书本按照高度排序！
* 状态设计：从 N 本书选出 N-k 本书；设 F[i][j] 为从前 i 本书选出 j
本书的最小的不整齐度。
* 状态转移：讨论第 i 本书选不选？
* 上一种方法行不通！
- 为什么？我们需要计算选出相邻两本书之间的宽度的差的绝对值。
* 状态设计：从 N 本书选出 N-k 本书；设 F[i][j] 为从前 i 本书选出 j
本书的最小的不整齐度，并且第 i 本书必须要选。
* 状态转移：上一本书选的是什么？

```cpp
/*
	problem : Luogu 1103
	solution : DP
	
	评测结果：Accepted 
	得分：　　100
	提交时间：2017-06-30 20:47
	耗时：37ms
	内存：11929kb
*/

#include <string>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 105;
const int INF = 1e9;

int n, k;
int h[N], w[N];
int a[N], b[N];
int f[N][N]; // f[i][j]记录前i本书中保留j本, 相邻宽度差之和的最小值

int cmp(int x, int y) { return h[x] < h[y]; }

int abs(int x) { return x > 0 ? x : -x; }

int work()
{
	int m = n - k;

	for(int i = 1; i <= n; ++ i)
		for(int j = 1; j <= m; ++ j)
			f[i][j] = INF;

	for(int i = 1; i <= n; ++ i) f[i][1] = 0; // 初值

	for(int i = 2; i <= n; ++ i)
		for(int j = 2; j <= m; ++ j)
			for(int l = 1; l < i; ++ l) // 枚举前一本书的位置
				f[i][j] = min(f[i][j], f[l][j-1] + abs(a[i] - a[l]));

	int ans = INF;
	for(int i = 1; i <= n; ++ i) ans = min(ans, f[i][m]);

	return ans;
}

int main()
{

	cin >> n >> k;
	for(int i = 1; i <= n; ++ i) cin >> h[i] >> w[i], b[i] = i;

	sort(b + 1, b + n + 1, cmp); // 按照高度排序

	for(int i = 1; i <= n; ++ i) a[i] = w[b[i]]; // 按照高度顺序记录宽度

	cout << work() << endl;

	return 0;
}
```

---

## 作者：jokers (赞：2)

大概说下这题的思路

跟前面几位的题解差不多%%%

只是为了增强自己理解才发一下

DP的思路一般来说就是

确定状态  →→  确定边界  →→  推一波转移方程

那么n本书中删去k本==从n本书中挑出n-k本书

这里是二维DP  f[i][j]表示前i本书中取j本并且第i本一定要取

就可以转化成从前l本书中取j-1本 + 第i本与第l本书宽度的差

所以方程就是  f[i][j]=min(f[i][j],f[l][j-1]+abs(w[i]-w[l]) 其中w为宽度

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int maxn=120,inf=100*200+10;
int n,k,h[maxn],w[maxn],f[maxn][maxn];
int read(){
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x;
}
void qsort(int l1,int r1){
	int l,r,mid;
	l=l1;
	r=r1;
	mid=(h[l]+h[r])/2;
	while(l<=r){
		while(h[l]<mid) l++;
		while(h[r]>mid) r--;
		if(l<=r){
			swap(h[l],h[r]);
			swap(w[l],w[r]);
			l++;
			r--;
		}
	}
	if(l1<r) qsort(l1,r);
	if(l<r1) qsort(l,r1);
}
int ho(int a){
	return a>=0?a:-a;
}
int mi(int x,int y){
	return x<y?x:y;
}
int main(){
	n=read();
	k=read();
	k=n-k;
	for(int i=1;i<=n;i++){
		h[i]=read();
		w[i]=read();
	}
	qsort(1,n);//先按高度排序
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=k;j++) f[i][j]=inf;//初始化表格
	for(int i=1;i<=n;i++) f[i][1]=0;//从前i本中取一本不管怎样差值都是0
	for(int i=2;i<=n;i++)//i，j从二开始枚举
	  for(int j=2;j<=k;j++)
	    for(int l=1;l<i;l++){//枚举前一个数
	    	int minus=ho(w[i]-w[l]);
	    	f[i][j]=mi(f[i][j],f[l][j-1]+minus);
	    }
	int ans=inf;
	for(int i=1;i<=n;i++) ans=mi(ans,f[i][k]);//因为最小值不一定要取最后一个
    //所以要在最后一行扫一遍而不是直接f[n][k]
	cout<<ans;
}
```

---


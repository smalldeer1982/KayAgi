# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# 题解

## 作者：Mutsumi_0114 (赞：268)

### 算法：树形$dp$。 分析如下

先看样例这棵树，

![](https://cdn.luogu.com.cn/upload/pic/46077.png)

题意是要我们找到树上点权之和最大的一个连通分量，譬如满足样例的选择就是下图中框起来的一块，

![](https://cdn.luogu.com.cn/upload/pic/46078.png)

我们用 $f[i]$ 记录 **以$i$为根的子树中点权和最大的一棵子树（或只选根）**，$a[i]$ 是输入的点权。

因为这样做的话最后要从每个$f[i]$中找出最大的数作为答案输出，所以 **选择哪个点为根对结果没有影响**，毕竟 **任一连通分量在任一时刻总是可以看成一棵以某个点为根的树**。

那不妨设节点 $1$ 为根，点 $0$ 为它的父亲（图中没有标出点 $0$）。

------------

### 接下来我们看看 $f[i]$ 如何计算。

根据定义，在走到点 $u$ 时，$f[u]$ 所表示的连通分量中必包含点 $u$ ，所以**把 $f[u]$ 初始化为点 $u$ 的点权 $a[u]$**。

接下来，对于 $u$ 的每一棵子树，我们都可以选择剪枝或不剪枝。对于 $u$ 的一个儿子 $v$ ，显然**当 $f[v] < 0$ 时就剪断 $u-v$ 这条枝，反之**。

于是得出递推式：

### $f[u] = a[u] + (f[v] > 0 ? f[v] : 0)$ （$v$ 为 $u$ 的儿子）。

![](https://cdn.luogu.com.cn/upload/pic/46077.png)

比如上图中，$f[2] = a[2] = -1$。

$∵ f[2] < 0$

$∴ f[5] = a[5] + 0 = 1$。

------------

实现比较简单：

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
int n,a[16005],f[16005],ans=-2147483647;
vector <int> E[16005];
void dfs(int u,int fa)
{
    f[u]=a[u];//f初始值
    for(int i=0;i<E[u].size();i++)
    {
        int t=E[u][i];
        if(t!=fa)
        {
            dfs(t,u);
            if(f[t]>0)
                f[u]+=f[t];//如式
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);//点权输入
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        E[u].push_back(v);
        E[v].push_back(u);//vector双向连边
    }
    dfs(1,0);
    for(int i=1;i<=n;i++)
        ans=max(ans,f[i]);//找出最大点权和
    printf("%d",ans);
    return 0;
}
```

---

## 作者：FCBM71 (赞：38)

很不错的树形DP入门题，适合FCB这类的DP萌新练手。

审题永远是解决一道题目的第一步。本题的题干略显冗长，大概概括一下就是指：给定一棵树，求出他的点权之和最大的一颗子树的点权和。特别地，子树不能为空（貌似这里吊死了很多人）

## 思路分析

本题中只给出了每条边连接的节点编号，但是没有给出祖宗关系，于是我们就可以随意一点了，不妨假设1节点就是根节点。根节点确定祖宗关系也就随之确定了。（当然，只要你愿意，任意一个节点都可以作为根节点）

我的思路是两个转移方程同时进行。首先假设每个节点点权为 $a[i]$

1. $fy[i]$ 表示以 ` i节点` 为根的最大子树之和。那么很显然，$fy[i]$ 的初值应该为 `fy[i] = a[i]`。那么 $fy[i]$ 的最终值是多少呢？ 我们从最简单的情况开始，对于每个叶节点，$fy[i]$ 的值就是 $a[i]$。那么叶节点的父亲呢？ 很显然，只要叶节点的权值大于0，它的爸爸就应该很乐意的保留它，反之减掉它。如果是普通的节点呢？同理，只要他的某一个儿子的 `fy` 值大于0，他也应该很乐意地保留它。  我们就可以得到这样一个方程。
  $$\text{fy[i]=a[i]+}\Sigma\text{max(fy[i's sons],0)}$$
  
2. $fn[i]$ 表示以 $i$ 节点为根的子树中，包含最大的一颗子树的和（这棵子树不包含 $i$ 节点）。我们开一个 `fn` 数组的目的是可以逐步将答案传到树根 $fn[1]$，省去了DP完成后再扫一遍 `fy` 数组的麻烦。很显然， $fn[i]$ 的值就应该是他的所有孩子中 $fy[i's\ sons]$ 与 $fn[i's \ sons]$ 中的最大值。写成方程：
 $$\text{fn[i]=max(fy[i's sons],fn[i's sons])}$$
 
 最后的答案 $max(fy[1],fn[1])$    
 总时间复杂度 $O(n)$ ，妥妥的。
 
 ## 代码实现
 
 还是比较容易的，但是有几个对于萌新的坑点或者注意点
- 与绝大部分树形DP一样，它并不能线性循环实现，而是要通过从根节点开始递归，直到叶节点再开始回溯。   
- 本题的数据范围达到了 $\text{16000}$ ， 个人建议使用链式前向星存边。特别地，本题由于无法直接确定父子关系，所以加边时要双向加边。因此在 dfs 的时候也要注意不能从儿子返回搜索到了父亲。
- fn 数组要出事化成一个极小值，用来应付所有点权都是负数的情况
 
```
inline void tomax(int &a,int b){if(a<b)a=b;} //手写max可以加速

void dfs(int x,int fa){
	for(int i=head[x];i;i=nxt[i]){   //链式前向星的访问
		if(to[i]==fa)continue;    //不能搜向父亲
		dfs(to[i],x);      //向儿子递归
		if(fy[to[i]]>0)fy[x]+=fy[to[i]];   //状态转移
		tomax(fn[x],fn[to[i]]);
		tomax(fn[x],fy[to[i]]);
	}
}
```

## 完整代码

代码略丑，还望各位多多包涵
```
#include<cstdio>
#include<cstring>

const int N=16005;
int fy[N],fn[N],n,a[N],maxx;bool flag;
int nxt[N*2],to[N*2],head[N],num,x,y;  //记得开两倍

inline void add(int x,int y){
	to[++num]=y;nxt[num]=head[x];head[x]=num;  //加边
}

inline void tomax(int &a,int b){if(a<b)a=b;}

void dfs(int x,int fa){   //递归求解
	for(int i=head[x];i;i=nxt[i]){
		if(to[i]==fa)continue;
		dfs(to[i],x);
		if(fy[to[i]]>0)fy[x]+=fy[to[i]];
		tomax(fn[x],fn[to[i]]);
		tomax(fn[x],fy[to[i]]);
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	 scanf("%d",&a[i]),fy[i]=a[i];  //初始化1
	for(int i=1;i<n;++i){
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);    //加边
	}
	memset(fn,0x80,sizeof(fn));  //初始化2
	dfs(1,0);  //求解
	printf("%d",fy[1]>fn[1]?fy[1]:fn[1]);
	return 0;
}
```

---

## 作者：tribool4_in (赞：23)

一道比较简单的树形DP题。

题意就是让你求这个树上点权和最大的一个联通部分（连通分量）。

考虑设 $f_i$ 表示以 $i$ 为根的所有子树中点权和最大的一个。

对于 $u$ 和 $u$ 的儿子 $v$，如果 $f_v \ge 1$ 则它对答案有贡献，要保留，反之则要减掉。

那么有递推式：

对于 $u$ 和 $u$ 的儿子 $v$，若 $f_v \ge 1$ 则 $f_u=a_u+\sum f_v$，否则 $f_u=\max(0, a_u)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 10;
int n, a[N], f[N], ans = INT_MAX + 1;
vector <int> G[N];
void dfs(int u, int fa) {
    f[u] = a[u]; // 注意要赋初始值
    for(int i = 0; i < G[u].size(); i++) {
        int v = G[u][i];
        if (v == fa) continue;
        dfs(v, u);
        if (f[v] >= 1) f[u] += f[v];
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d",&a[i]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1, 0);
    for(int i = 1; i <= n; i++) ans = max(ans, f[i]);
    printf("%d\n", ans);
}
```

---

## 作者：lavd (赞：15)

先给代码-.-


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
bool f[16002][16002]={false};
int w[16002][2]={0},i,a,b,o=0,n;

int sum(int a){
	int j;
	if(w[a][2]==0){
		if(w[a][1]<0)return 0;
		else return w[a][1];
	}
	for(j=3;j<=n+2;j++)if(f[a][j]){
		f[a][j]=false;f[j-2][a+2]=false;
	w[a][1]=w[a][1]+sum(j-2);
	if(w[a][1]>o)o=w[a][1];
	}

	if(w[a][1]<0)return 0;
		else return w[a][1];
}

int main ()
{
scanf("%d",&n);
for(i=1;i<=n;i++)
{
scanf("%d",&w[i][1]);
}
for(i=1;i<=n-1;i++)
{
	scanf("%d%d",&a,&b);
	w[a][2]++;
	w[b][2]++;
	f[b][a+2]=true;
	f[a][b+2]=true;
}
sum(1);
printf("%d",o);
return 0;

}
```



随便确定随便一个点开始(最后证明为什么这样可以)，代码里面从1开始的。（就是sum（1））

W[1][1]是第一个点的值，W[1][2]是和这个点连接的数量，后面是记录和这个点连接的点。

f数组是记录两个点是否连接。f[x][y]是x点是否能到y点，如果x能到y点那么y点也能到x点，所以f[y][x]也是打开的。

然后就开始深搜。深搜的时候要记得把f关闭，不然会死循环！！！而且双向路都要关闭！！！

搜到最底下就把这个点的值递回来，然后加上沿路所有点的值。

！！！！！最重要的一点，如果这个值小于0那么返回0！！！！！
！！！！！因为如果值小于0那么还不如不要这个点！！！！！！！

   
 开始证明为什么从任意一个点开始都行，就拿样例来证明啦
 
 ![](https://cdn.luogu.com.cn/upload/pic/56521.png)
 
 这是把1当做根构造的树，深搜到底发现最下面的值是-1，所以就返回0，然后1+0=1，5和6还是1，然后继续返回0+1+1=2，所以7的值变成2，然后2+1=3，所以4的值是3.最后发现1的值-1小于0，那么就把1的值变成0，然后0+3=3。最终答案3
 
 
![](https://cdn.luogu.com.cn/upload/pic/56522.png)

这是把7当做根的树，深搜到最底下发现1,2,3点的值都是-1，因为-1<0所以返回0。4,5,6点的值是0+1=1。然后继续返回值，点7的值是0+1+1+1=3，所以最终答案是3


由此发现无论从哪个点开始都可以算出正确答案，可以证明我们的思路是正确的。

最后说一句

DP的题真是练习搜索的好题呢！！！！

第一篇题解，蒟蒻求过QWQ

O(∩_∩)O谢谢


---

## 作者：StoneXie (赞：10)

这题嘛 … 很明显的树形dp，但也有很多要注意的小点。

一开始题目打在了纸上，树的结构在第二面，然后当成了区间dp，嗯 … 代码就不贴了

于是我又打起了代码。

首先转移方程好想：默认选v节点，再递归，将返回值与0进行比较，看有没有在美丽指数上有好的帮助，加起来后返回。
再就是存树，我是用vector当图存的，应是无向边，所以应在递归时把父亲记下来，转移时就不搜父节点，不然会死循环。
于是另一份交了上去，结果依然没过。

附错误代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath> 
#include<vector>
using namespace std;
const int N=16005;
vector<int>E[N];//stl存图
int n,w[N];
int dp(int v,int fa){//给父节点以免死循环
	int ans=w[v];
	for(int i=0;i<E[v].size();i++)
		if(E[v][i]!=fa) ans+=max(0,dp(E[v][i],v));
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",w+i);
	for(int i=1,x,y;i<=n-1;i++){
		scanf("%d%d",&x,&y);
		E[x].push_back(y);//不知道那个为父节点
		E[y].push_back(x);//所以当无向图
	}
	printf("%d\n",dp(1,0));//输出错误答案
	return 0;
} 
```
究其原因，样例就能是出来，因为任选一节点作为根节点，答案不一定最优（样例中以1为根节点，答案就不优，为2）。

解决办法很简单，以每个节点为根节点跑一边dp，取最优值。再交上去后发现超时了几个点，说明不能这么暴力。

附70分代码：
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath> 
#include<vector>
using namespace std;
const int N=16005;
vector<int>E[N];
int n,w[N];
int dp(int v,int fa){//给父节点以免死循环
	int ans=w[v];
	for(int i=0;i<E[v].size();i++)
		if(E[v][i]!=fa) ans+=max(0,dp(E[v][i],v));
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",w+i);
	for(int i=1,x,y;i<=n-1;i++){
		scanf("%d%d",&x,&y);
		E[x].push_back(y);//不知道那个为父节点
		E[y].push_back(x);//所以当无向图
	}
	int ans=0;
	for(int i=1;i<=n;i++) ans=max(ans,dp(i,0));
	printf("%d\n",ans);
	return 0;
} 
```
冥思苦想后，我终于先到了正解方法

在dp时是默认选根节点的，但选根节点不一定最优，最优情况可能是去掉某些子树，也可能还去掉根节点，用一下记忆化搜索，把结果遍历一遍，这样就可以考虑到所有情况，时间复杂度也很优。

附AC代码
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath> 
#include<vector>
using namespace std;
const int N=16005;
vector<int>E[N];//vector存图（树）仿领接表 
int n,w[N],f[N];
int dp(int v,int fa){//记住父亲节点，避免死循环 
	int ans=w[v];
	for(int i=0;i<E[v].size();i++)
		if(E[v][i]!=fa) ans+=max(0,dp(E[v][i],v));
	return f[v]=ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",w+i);
	for(int i=1,x,y;i<=n-1;i++){
		scanf("%d%d",&x,&y);
		E[x].push_back(y);//此时不确定父节点，当无向图存 
		E[y].push_back(x);
	}
	int ans=0;
	dp(1,0); 
	for(int i=1;i<=n;i++) ans=max(ans,f[i]);//将记忆化搜索的结果逐一比较 
	printf("%d\n",ans);
	return 0;
} 
```



---

## 作者：回归线以北 (赞：6)

树状dp的入门题，做完这道题对树有了新的理解。树不一定是我们通常理解的树（根是不变的）。树形结构代表的特点是连接和层次。

个人认为：这个题没有真正的树根只要随便找一个节点开始计算即可。

中心思想就是把连接两个点的边存起来，然后处理这个串上的边，比如这条串上的上一条边是什么，这条串的最后一个节点是什么。详细题解写到注释里了

有的地方可能解释的不清楚，大家意会吧......

代码如下：

‘’‘cpp


```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
int flower[16600],n,next[40010],pre[40010],last[40010],f[16600],num=0;
```
/\*
flower[i]表示第i个节点的值

next[i]表示编号为i的边的下一个节点的值

pre[i]表示编号为i的边的上一个节点相连的边的编号

last[i]表示与第i个节点相连的最后一条边的编号（因为与i节点相连的边可能不止一条）

last[i]也可以理解成许多节点用边相连形成一条串，第i条边在这个串中的上一条边就是last[i]

f[i]表示第i节点的子树的最大和

\*/
```cpp
bool vis[16600];//标记每个节点是否访问过
int ans=-inf;
void cnct(int x,int y)
{
    num++;//边的编号++
    next[num]=y;//第num条边的下一个节点是y
    pre[num]=last[x];//第num条边的上一条边是x的上一条边
    last[x]=num;//现在x的上一条边是num了
}
int dfs (int u)
{
    int sum=0;
    if(f[u])
    return f[u];
    int i=last[u];//u节点的上一条边
while(i)//如果有这条边
 {
        int nxt=next[i];//nxt就是此边相连的另一个节点（这条边把u与nxt相连）
        if(!vis[nxt])
        {
            vis[nxt]=1;
            int x=dfs(nxt);//往上找串
            if(x>0) sum+=x;//找完后如果子树权值和>0，加上
        }
        i=pre[i];//再找i的前一个边
    }
    f[u]=sum+flower[u];
    if(f[u]>ans) ans=f[u];
    return f[u];
}
int main()
{
    memset(flower,0,sizeof flower);
    memset(pre,0,sizeof pre);
    memset(last,0,sizeof last);
    memset(next,0,sizeof next);
    memset(f,0,sizeof f);
    memset(vis,false,sizeof vis);
    //freopen("de.txt","r",stdin);
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
    scanf("%d",&flower[i]);
    for (int i=1;i<n;++i)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        cnct(x,y);//将两个节点连接起来
        cnct(y,x);//双向都要连接
    }
    vis[1]=1;
    dfs(1);
    printf("%d\n",ans);
    return 0;
}
```
’‘’
下面补上一个利用vector存边的做法，比较好理解


代码如下：

‘’‘cpp


```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
struct edge
{
    int u,v;
};
vector <edge> e[16010];//用vector数组来表示每个点相邻的点
int result=-inf,n,f[16010],flower[16010];//f[i]为节点i的子树的最大值
bool vis[16010];
int dfs (int x)
{
    int t;
    for (int i=0;i<e[x].size();++i)
    {
        edge &st=e[x][i];
        if (!vis[st.v])
        {
            vis[st.v]=1;
            t=dfs(st.v);
            if (t>0)
            f[x]+=t;
        }
    }
    result=max(result,f[x]);
    return f[x];
}
int main()
{
    memset(f,0,sizeof f);
    memset(flower,0,sizeof flower);
    memset(vis,false,sizeof vis);
    //freopen("de.txt","r",stdin);
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
    {
        scanf("%d",&flower[i]);
        f[i]=flower[i];
    }
    for (int i=1;i<n;++i)
    {
        int p1,p2;
        scanf("%d%d",&p1,&p2);
        e[p1].push_back((edge){p1,p2});
        e[p2].push_back((edge){p2,p1});
    }
    vis[1]=true;
    dfs(1);
    printf("%d\n",result);
    return 0;
}
’‘’
```

---

## 作者：呼啸山庄 (赞：4)

## 基本思想：

很明显的是这是一道树形Dp~~，顺便带点贪心的思想~~。

我们设$F[V]$为根节点为V时最大子树和，此时$F[V]$由$\Sigma_{E(V,u)}{F[V],F[V] + F[u]}$决定。

但如果我们随便找一个根节点，直接去做这个Dp，很可能就会Wrong Answer。比如说Luogu给的样例，以1为根节点时。但直接这样Dp为什么他会错呢？

因为$F[V]$得到的是以V为根节点得到的最大子树和，所以$F[V]$一定包括了节点V的值。很显然如果这个根的值小于零，那他肯定不是最优的，所以要去根肯定大于零~~，而且应该根节点的值越大越好~~。

但是值最大的节点做根节点不一定能得到正确的答案，比如说以下这组：

```t
5
3 -6 -4 2 2
1 2
1 3
2 4
4 5
```

我们贪心会得到3，而正确是4，QwQ，所以我睡觉时把我自己hack掉了，所以我们最后需要再找一遍根节点，或者Dp的时候记录一下。

## 部分代码解释

```c++
struct Graph {
    int Vertex;
    int Next;
} Edge[Maxn << 1]; //开两倍

void Read() {
    ~~~~~~~
    register int A, B;
    for (int i = 1; i < N; ++i) {
        A = Fscan();
        B = Fscan();
        Insert(A, B, Cnt, Head, Edge); //加边(u,v)
        Insert(B, A, Cnt, Head, Edge); //加边(v,u)
    }
}
```

树是双向边，记得加两次边$(u,v) 和(v,u)$，边集数组记得开两倍。

```c++
for (int i = 1; i <= N; ++i){
    Value[i] = Fscan();
    if(Value[i] > Value[S])
    	S = i;
}
```

我们在读入的时候，找到值最大的节点，这样就不用在扫一遍记录值的数组了。

```c++
if (NV != P){
	Dfs(NV);
	F[V] = max(F[V], F[V] + F[NV]); //Dp QwQ
	//printf("%d %d %d\n",V,NV,F[V]);
}
```

因为这是一棵树，是双向边，所以Dfs时要判断一下，不然死循环就崩了。

## 代码

```c++
#include <cstdio>
#include <cstring>

#define max(A, B) A >= B ? A : B

const int INF = 0x7fffffff;
const int Maxn = 16000 + 5;

int Cnt, Head[Maxn];
int Value[Maxn];
struct Graph {
    int Vertex;
    int Next;
} Edge[Maxn << 1];

inline void Insert(const int &From, const int &To, int &Cnt, int *Head, Graph *Edge) {
    Edge[++Cnt].Vertex = To;
    Edge[Cnt].Next = Head[From];
    Head[From] = Cnt;
}

inline int Fscan() {
    char Ch = getchar();
    int X = 0, F = 1;
    while (Ch < '0' || Ch > '9') {
        if (Ch == '-')
            F = -1;
        Ch = getchar();
    }
    while ('0' <= Ch && Ch <= '9') {
        X = (X << 3) + (X << 1) + Ch - '0';
        Ch = getchar();
    }
    return X * F;
}

int N,S;

void Read() {
    N = Fscan();
    //printf("%d\n",N);
    for (int i = 1; i <= N; ++i){
    	Value[i] = Fscan();
    	if(Value[i] > Value[S])
    		S = i;
	}
    	
    //for(int i = 1; i <= N; ++i)
        //printf("%d ",Value[i]);
    //printf("\n");
    register int A, B;
    for (int i = 1; i < N; ++i) {
        A = Fscan();
        B = Fscan();
        Insert(A, B, Cnt, Head, Edge);
        Insert(B, A, Cnt, Head, Edge);
        //printf("%d %d\n",A ,B);
    }
    //printf("\n");
}

int F[Maxn];

void Dfs(const int &V,const int &P) {
    int NV;
    //printf(" %d %d\n",V,F[V]);
    F[V] = Value[V];
    for (int i = Head[V]; i; i = Edge[i].Next) {
        NV = Edge[i].Vertex;
        //printf(" %d ",NV);
        if (NV != P){
        	Dfs(NV,V);
        	F[V] = max(F[V], F[V] + F[NV]);
			//printf("%d %d %d\n",V,NV,F[V]);
		}
        //printf("%d\n",F[V]);
    }
    //printf("%d %d\n",V,F[V]);
    //F[V] = max(F[V], F[V] + Value[V]);
}

int main() {
    Read();
	Dfs(S,S);
    int Ans = -INF;
    for(int i = 1; i <= N; ++i)
        Ans = max(Ans, F[i]);
    printf("%d", Ans);
    //printf("%d", F[S]);
    //for(int i = 1 ; i <= N; ++i)
    //    printf("%d ",F[i]);
    return 0;
}
```



---

## 作者：OptimusPrime_L (赞：4)

# 分析

一道非常基础的树形DP啦~

f[i]表示必须包含flower[i]的最大美丽值。然后在树上深搜乱搞~

首先将当前搜到的点point对应的f[point]初始化为flower[point]，因为我们规定了f[i]是必须包含flower[i]的最大美丽值。至于为什么有这样一个设定是因为我们进行DP是建立在这个花还是完整的基础上的，也就是说，如果我们还需要flower[point]的某个儿子带来美丽值，那么flower[i]必须是保留的，不能与根断开。

然后开始找flower[point]的儿子，这里就有一个问题，为了避免在两个点之间来回搜索，函数dfs必须有一个参数father代表当前搜到的点的父亲。如果在point的儿子里找到的点是father那么直接跳过。类似的方法在之前某到深搜的题里面其实有讲过（我记得我有写博客）。

然后继续递归搜索。

搜完它的下一个儿子以后来看，如果这个儿子带来的美丽值是正的，那么他对当前节点的美丽值是有贡献的，把它累加到当前节点的美丽值当中。

多说一句，还是要注意数据范围（虽然我也不知道为什么我开小了，我明明是按照正确的数据范围开的），刚才把FRET(Fast Runtime Error Transform)的技能连着升了两级(╯‵□′)╯︵┻━┻。

# 程序
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 40000;
int n, fw[MAXN], EdgeCount, f[MAXN], Head[MAXN];
struct edge
{
    int Next, Aim;
}Edge[MAXN];
void insert(int u, int v)
{
    Edge[++EdgeCount] = (edge){Head[u], v};
    Head[u] = EdgeCount;
}
void dfs(int point, int father = 0)
{
    f[point] = fw[point];
    // flower point must be in f[point]
    for (int i = Head[point]; i; i = Edge[i].Next)
    {
        int u = Edge[i].Aim;
        if (u == father)
            continue;
        dfs(u,point);
        if (f[u] > 0)
            f[point] += f[u];
        // if f[u]>0 then it can contribute to f[point]
    }
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> fw[i];
    for (int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        insert(u,v);
        insert(v,u);
    }
    dfs(1);
    int ans = fw[1];
    for (int i = 1; i <= n; i++)
        ans = max(ans, f[i]);
    cout << ans << endl;
    getchar();
    getchar();
    return 0;
}
```

---

## 作者：Tomwsc (赞：3)

# P1122 最大子树和 题解

给大家提供一种不同的 dp 方法。

## dp 状态

定义二维数组 $dp[i][2]$。

- 设 $dp[i][0]$ 表示以 $i$ 号节点为根且最大子树**不包含** $i$ 号节点的最大值。
- 设 $dp[i][1]$ 表示以 $i$ 号节点为根且最大子树**包含** $i$ 号节点的最大值。

设 $a[i]$ 是每朵花的美丽指数。

则有初始化：$dp[i][1]=a[i](1\le i \le n)$。

## 转移方程

设计出状态，我们来推方程：

我们设 $i$ 号节点的儿子为 $j_1,j_2,\cdots,j_m$。

- 对于 $dp[i][1]$，由定义得以 $i$ 为根的最大子树必须包含 $i$ 且子树需连通。所以 $dp[i][1]$ 可以从 $dp[j_k][1]$ 转移而来。为什么是 $dp[j_k][1]$ 而不是 $dp[j_k][0]$ 呢？因为如果以 $j_k$ 为根的最大子树不包括 $j_k$ 的话，转移到 $i$ 时最大子树就不连通了。同时，转移时要加上原有的 $dp[i][1]$。

  即：$dp[i][1]=\max(dp[i][1] , dp[j_k][1] + dp[i][1])$。

- 对于 $dp[i][0]$，由定义得以 $i$ 为根的最大子树不包含 $i$。所以，$j_k$ 在不在最大子树里已无关紧要了，$i$ 只需要继承 $j_k$ 的最大子树的大小即可。

  即：$dp[i][0]=\max(dp[i][0],dp[j_k][0],dp[j_k][1])$。

最终结果便是 $\max(dp[1][1],dp[1][0])$。

## 代码实现

直接 dfs 即可。

时间复杂度：$O(n)$。

注意：由于 $a[i]$ 可能小于 $0$，所以 dp 数组要初始化为极小值。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 2e4 + 10;
int n;
int a[MAXN];
vector<int>m[MAXN];
int dp[MAXN][2];

void dfs(int u , int fa) {
	dp[u][1] = a[u];
	for(register int i = 0;i < m[u].size();i ++) {
		int v = m[u][i];
		if(v == fa)
			continue;
		dfs(v , u);
		dp[u][0] = max(dp[u][0] , max(dp[v][1] , dp[v][0]));
		dp[u][1] = max(dp[u][1] , dp[v][1] + dp[u][1]);
	}
	return;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	memset(dp , 0xcf , sizeof(dp));
	cin >> n;
	for(register int i = 1;i <= n;i ++)
		cin >> a[i];
	for(register int i = 1;i < n;i ++) {
		int a , b;
		cin >> a >> b;
		m[a].push_back(b);
		m[b].push_back(a);
	}
	dfs(1 , 0);
	cout << max(dp[1][0] , dp[1][1]);
	return 0;
}
```

---

## 作者：vegetabird (赞：2)

怎么楼下所有题解全是DFS? 其实随便找一个根，把所有点按到根的距离排个序就可以不用DFS了。至于思路没有什么不同，用f1表示包含根的最大子树和，f2表示不包含根的最大子树和。至于排序，把所有点BFS一遍，产生的队列就是排序后的点，完全不需要sort

```cpp
#include<cstdio>
#include<cctype>
using namespace std;
inline void getint(int &_int){
    char ch=_int=0;
    bool neg=false;
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-'){
        neg=true;
        ch=getchar();
    }
    while(isdigit(ch)){
        _int=_int*10+ch-48;
        ch=getchar();
    }
    if(neg)_int=-_int;
}
int n;
int a[32010],b[32010],fst[16010],nxt[32010];
int father[16010];
int f1[16010],f2[16010];
int q[16010];
bool vis[16010];
const int INF=0x3fffffff;
inline int max(const int &a,const int &b){
    return a>b?a:b;
}
int main(){
    register int i,k,u,head,tail;int maxrt=-INF;
    getint(n);
    for(i=1;i<=n;i++){
        getint(f1[i]);
        maxrt=max(maxrt,f1[i]);
    }
    for(i=1;i<2*n-1;i+=2){
        getint(a[i]);getint(b[i]);
        a[i+1]=b[i],b[i+1]=a[i];
        nxt[i]=fst[a[i]];
        fst[a[i]]=i;
        nxt[i+1]=fst[b[i]];
        fst[b[i]]=i+1;
    }
    if(maxrt<0){
        printf("%d\n",maxrt);
        return 0;
    }
    head=0,tail=1,q[0]=1;
    vis[1]=true;
    while(head!=tail){
        u=q[head++];
        for(k=fst[u];k;k=nxt[k]){
            if(!vis[b[k]]){
                father[b[k]]=u;
                q[tail++]=b[k];
                vis[b[k]]=true;
            }
        }
    }
    while(tail>0){
        u=q[--tail];
        f1[father[u]]+=max(f1[u],0);
        f2[father[u]]=max(f2[father[u]],max(f1[u],f2[u]));
    }
    printf("%d\n",f2[0]);
}
```

---

## 作者：DreamDraw (赞：2)

似乎不用找根，然而蒟蒻还是找了根。。。。

然后N^2就TLE.....

然后我发现似乎有重复计算，记忆化大法好.............开了个map，记录u点以fa为父节点时的dp值，然后好像还挺快

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cstring>
#include<utility>
#define maxn 16003
using namespace std;
inline void read(int &num){
    char c;num=0;bool flag=0;
    while((c=getchar())==' '||c=='\r'||c=='\n');
    if(c=='-')flag=1;
    else num=c-48;
    while((c=getchar())>=48&&c<=57)num=num*10+c-48;
    if(flag)num*=-1;
    return;
}
vector<int>sons[maxn];
map<pair<int,int>,int> m;
int n,a[maxn],dp[maxn],g[maxn];
void DFS(int u,int fa){
    pair<int,int> tmp=make_pair(u,fa);
    map<pair<int,int>,int>::iterator it=m.find(tmp);
    if(it!=m.end()){
        dp[u]=m[tmp];
        if(dp[u]>0) g[fa]+=dp[u];
        return;
    }
    int size=sons[u].size();
    for(int i=0;i<size;++i)
        if(sons[u][i]!=fa) 
            DFS(sons[u][i],u);
    dp[u]=max(0,max(a[u],a[u]+g[u]));
    m[tmp]=dp[u];
    if(dp[u]>0) g[fa]+=dp[u];//g[fa]表示以fa为根的子树子节点的最大价值和
    return;
}
int main(){
    freopen("a.in","r",stdin);
    read(n);
    for(int i=1;i<=n;++i) read(a[i]);
    int x,y;
    for(int i=1;i<n;++i){
        read(x),read(y);
        sons[x].push_back(y);
        sons[y].push_back(x);
    }
    int ans=-0x7fffffff;
    for(int i=1;i<=n;++i){
        memset(dp,0,sizeof(dp));
        memset(g,0,sizeof(g));
        DFS(i,0);
        ans=max(ans,dp[i]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：traceson (赞：2)

这题咋一看还真有点树形DP的意思，也不管是不是树形了，反正是个DP。

思路也和大多一样，找出“根”，（因为这道题的特殊性，我们不需要找根，只用随便找个点当做根就行了，因为它是一棵树）然后递归找出其子数，判断其子树的价值是否为正，为正值就加上。并且在我们找的过程中每次找完一棵字数时的值就用一个全局变量answer记录一下当前值取个max，这样最后answer的值就是最后答案。

代码如下：


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
int ans;
int f[16010];
struct node{
    int to,next;
}e[32010];//这里用一个结构体记录每条边得终点和其相邻的边
int head[16010];
int k=0;
void build(int u,int to)//建树（邻接表操作）
{
    e[++k].to=to;
    e[k].next=head[u];
    head[u]=k;
}
int dfs(int x,int fa)//因为是双向边所以传一个当前点的父亲，避免重复走回来
{
    int sum=f[x];//每棵子树至少都要包含本身的值
    for(int i=head[x];i;i=e[i].next)//枚举第x节点的儿子
    {
        if(e[i].to!=fa)//判断是否搜回到父亲节点
        {
            int p=dfs(e[i].to,x);//x节点的一棵子树的最大价值
            if(p>0) sum+=p;如果子树价值大于0才要当前子树，不然就要剪去它
        }
    }
    ans=max(ans,sum);//用answer记录每棵子树的价值中的max
    return sum;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&f[i]);
        ans=max(ans,f[i]);//如果整棵树最后只剩下一个节点，那么那个点是这个最大的节点
    }
    for(int i=1;i<n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        build(a,b);
        build(b,a);//因为是一棵树，所以建双向边
    }
    dfs(1,-1);//因为是一棵树所以随便找个点做根，一般我喜欢用1做根。一开始fa传入-1，因为没有-1这个点，且根没有父亲
    printf("%d",ans);
    return 0;
}
```

---

## 作者：wzmszjw (赞：2)

直接dp，建棵树，dp[i]表示取以i为根的子树最大的收益是多少，因为要联通，所以更新是dp[i]=max(dp[i],dp[i]+dp[j])，j是i的儿子，最后循环一遍n，看dp值最大是多少就可以了。

```cpp
[codec ]#include <iostream>  
#include <cstdio>  
#include <cstring>  
#include <cmath>  
#include <algorithm>  
using namespace std;  
const int M=32100;  
int n,s;  
int to[M],w[M],first[M],next[M],dp[M];  
void add(int x,int y){  
    to[++s]=y; next[s]=first[x]; first[x]=s;  
}  
void dfs(int x,int fa){  
    dp[x]=w[x];  
    for(int i=first[x];i>0;i=next[i]){  
        int y=to[i];  
        if(y==fa) continue;  
        dfs(y,x);  
        if(dp[y]>0) dp[x]+=dp[y];  
    }  
}  
int main()  
{  
    scanf("%d",&n);  
    for(int i=1;i<=n;i++){  
        scanf("%d",&w[i]);  
    }  
    for(int i=1;i<=n-1;i++){  
        int a,b;  
        scanf("%d%d",&a,&b);  
        add(a,b);  
        add(b,a);  
    }  
    dfs(1,0);  
    int ans=-16000010;  
    for(int i=1;i<=n;i++) if(dp[i]>ans) ans=dp[i];  
    printf("%d",ans);  
}  [/codec ]
```

---

## 作者：一个昵称 (赞：1)

**一道树上DP题**

~~这题其实挺简单的……~~ 

首先 我们可以很轻松的看出来 这道题和树有关 或者说 他是一个无向图 而且又是求最优解 那么 直接就上树上DP

先找状态转移方程 其实这里用上一个贪心的思想 就是 只有加上一个正的数 他的值才会高嘛 而且 只要值能变高 当然是加的越多越好 所以方程就是 f[i]+=max(0,f[j])

然后 树上DP其实都跟dfs差不多（~~我jio得差不多~~） 所以直接写一个dfs来更新答案就好啦 

下面附上代码
```cpp
#include<iostream>
using namespace std;

int vis[16001];

int head[16001];

struct nod{
	int to,nxt;
}e[32005];

int f[16001];

int n,cnt=0;

void addEdge(int u,int v){
	e[++cnt]=(nod){v,head[u]};
	head[u]=cnt;
}

void dfs(int s){
	vis[s]=1;
	for(int i=head[s];i;i=e[i].nxt){
		int v=e[i].to;
		if(vis[v]) continue;
		dfs(v);
		f[s]+=max(0,f[v]);
	}
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>f[i];
	}
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		addEdge(u,v);
		addEdge(v,u);
	}
	dfs(1);
	int ans=-999999999;
	for(int i=1;i<=n;i++){
		ans=max(ans,f[i]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：san9pk (赞：1)

对于一棵树，它的最大子树有两种可能：1.根节点被加入；2.根节点未被加入。

对于情况1，设包含某一儿子（但不包含根节点）的最大子树为p，若p的权值之和>0，就把p连接到根节点上；如果p的权值之和<0，则没有必要把p连到根节点上。

当所有儿子被遍历一遍后，统计包含根节点的最大子树R的权值之和sum，如果sum>ans，那么ans=sum；

如果sum<=ans，就说明根节点没有必要加入。最大子树是某一个儿子的子集，其权值和为ans。

最后输出ans就好.

代码如下：


```cpp
#include<cstdio>
#include<cstring>
#include<vector>
using std::vector;
const int maxn=16000+5;
int n,root_node,ans=0;
bool vis[maxn];//看看哪个结点没有加入到树中
vector<int> M[maxn],son[maxn];//M记录某个结点的相邻结点；son记录某个结点的儿子
int pa[maxn],a[maxn];//pa记录某个结点的父亲，a记录某个结点的权值
void build_tree(const int root_node)//用递归的方法构建一棵树
{
    vis[root_node]=1;
    for(int i=0;i<M[root_node].size();i++)
    {
        int p=M[root_node][i];
        if(!vis[p])
        {
            pa[p]=root_node;
            son[root_node].push_back(p);
            build_tree(p);
        }
    }
}
int work(const int root_node)//递归求解问题。该函数的意义是，返回包含root_node但不包含root_node父亲的最大子树的权值
{
    int i,sum=a[root_node],q;
    for(i=0;i<son[root_node].size();i++)
    {
        q=work(son[root_node][i]);
        if(q>0)sum+=q;
    }
    if(sum>ans)ans=sum;
    return sum;
}
int main(int argc,char **argv)
{
    int i,x,y,max_node;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",a+i);
        if(a[i]>ans)ans=a[i];//如果树中只有一个结点，那么这肯定是权值最大的结点
    }
    for(i=1;i<n;i++)
    {
        scanf("%d%d",&x,&y);//输入边
        M[x].push_back(y);
        M[y].push_back(x);
    }
    for(i=1;i<=n;i++)
        if(max_node>M[i].size())
        {
            max_node=M[i].size();
            root_node=i;//找到一个度最大的结点(通过这种方式尽可能降低树的高度）
        }
    for(i=1;i<=n;i++)
        pa[i]=i;
    memset(vis,0,sizeof(vis));
    build_tree(root_node);//建立树
    work(root_node);//求解
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：linyinuo2008 (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P1122)

树形 $\text{DP}$ 好题。

# 1、题意理解

给你一棵有 $n$ 个节点的树，每个节点有一个点权，让你从中找出一棵子树，使得这棵子树上所有节点的点权和最大，求出这个最大值。

数据范围： $1 \leq n \leq 16000$。

# 2、算法分析

从[这里](https://www.luogu.com.cn/blog/shenyun/solution-p1122)借两张图。

![](https://cdn.luogu.com.cn/upload/pic/46077.png)

看样例，我们不难发现所说的“最大子树和”就在这里：

![](https://cdn.luogu.com.cn/upload/pic/46078.png)

所以我们该怎样设计状态呢，很简单！就是树形 $\text{DP}$ 标准状态设计法，我们设 $f_u$ 表示以 $u$ 为根节点的最大子树和。由于以 $u$ 为根节点的最大子树必然包括 $u$ 自己，所以初始化 
$$f_u \leftarrow a_u $$

然后我们遍历 $u$ 的每一个子节点 $v$ ，这里用到了一点贪心的思想，如果 $f_v>0$ ，也就是说以 $v$ 为根节点的最大子树和大于零，那我就可以把这棵树上面接一个根节点 $u$ 。
$$f_u=f_u+f_v$$
这样以 $v$ 为根节点的最大子树就为以 $u$ 为根节点的最大子树做出贡献，反之则不选，因为选了还得减，是个累赘。

结果： $\max(f_i)$

我们可以用`vector`来建树（~~常数这么小的东西咱们不用？~~），最后附上个树形 $\text{DP}$ 模板送给大家：

```cpp
void dfs(int u,int fa)
{
	Init();
	vis[u]=1;//有时要（可以）加，本题不用加 
	for(int i=0;i<tree[u].size();i++)
	{
		int nxt=tree[u][i];
		if(nxt!=fa&&!vis[nxt])
		{
			dfs(nxt,u);
			dp();
		}	
	}	
} 
```

# 3、代码

代码中有注释。

```cpp
#include <iostream>
#include <vector>
using namespace std;
const int N=16005;
int a[N],n,f[N];//f[i]表示以i为根节点最大子树和
vector<vector<int> > tree(N);//vector建树 
void dfs(int u,int fa)//当前节点与其父亲节点 
{
	f[u]=a[u];//初始化为节点点权 
	for(int i=0;i<tree[u].size();i++)//遍历每个节点 
	{
		if(tree[u][i]!=fa)//不能往回搜父亲 
		{
			int nxt=tree[u][i];
			dfs(nxt,u);
			if(f[nxt]>0)
				f[u]+=f[nxt];//动归转移 
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n-1;i++)
	{
		int p,q;
		cin>>p>>q;
		tree[p].push_back(q);//无向边要push两次 
		tree[q].push_back(p);	
	} 
	dfs(1,0);//这里其实从任何一个节点开始搜都可以，因为是一次性的 
	int ans=-0x7f7f7f;
	for(int i=1;i<=n;i++)
		ans=max(ans,f[i]);//求结果 
	cout<<ans;
	return 0;
} 
```
**若有错误，欢迎指出！**

---

## 作者：wyqwq (赞：0)

## 前言
代码实现以及代码细节，各位题解dalao都写得很详细了，蒟蒻更想说一些思路上的东西

## ~~类似好题？（多倍经验）~~
[p1352没有上司的舞会](https://www.luogu.org/problem/P1352)

## Solution

俗话说的好：遇到dp问题，一定先问自己三个问题：怎么设计状态？怎么写转移方程？怎么实现？我们就来一个一个讲：

### 状态设计

对于此题：删去一棵树的一些部分，使得剩余部分点权和最大。凭借灵敏的dp直觉，状态dp[i]表示以i为根的树最大权值和，状态就设计完成了；

### 转移方程

所谓dp，不可能天上掉答案，所以必须从子问题或其他问题转移过来，如何转移？从子树？灵光一闪！脑中闪现过一个设想，对于每一个子树进行决策时，如果对答案有贡献，计入答案。
否则就把这个子树砍掉就可以了，非常容易就可以推出状态转移方程：

F[u]+=max(0,F[v])其中v为u的儿子

状态转移方程就搞定了

### 实现

使用dfs进行更新，是非常简单的技巧

注意几点细节：转移过程中要注意随时更新答案，不然可能无法保证解的正确性。不要走回自己的父节点因为双向加边

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=16000;

int  cnt,n,tp[maxn],f[maxn],head[maxn],ans=-1000000;
struct edge{
	int next,to;
}e[maxn<<1];

inline int read(){
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();	
	}
	return x*f;
}

inline void add(int u,int v){
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}

inline void dfs(int now,int fa){
	for(int i=head[now];i;i=e[i].next){
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,now);
		f[now]+=max(0,f[v]);
	}
	ans=max(ans,f[now]）;
}

int main(){
	int qwq,qaq;
	n=read();
	for(int i=1;i<=n;i++){
		f[i]=read();
	}
	for(int i=1;i<n;i++){
		qwq=read();
		qaq=read();
		add(qwq,qaq);
		add(qaq,qwq）;
	}
	dfs(1,0);
	printf("%d",ans);
	return 0;
}
```
请不要尝试复制此份代码，否则你会直接CE

---

## 作者：渺小的Mastar (赞：0)

# **三个点MLE || 两个点MLE，一个wa的，看过来！！！**
## 爆了数组，因为是双向边！！所以要存边要开双倍大小，然后就可以AC这道水题了
## 这题是一个比较常见的树型dp模板 ，然后手玩一下发现其实哪个节点转化为有根树都一样 ~ 
问题转化为： 给一棵 n 个点的树，以 1 号点为根，求以每个点为根的子树大小

状态表示： f[u] 表示以u为根且包含u的最大子树和

状态转移方程：f[u]+=max(0,f[v]); (v为u的孩子) 美丽指数小于0的子树可不选，所以与0比较

上代码：
```cpp
#include <cstdio> // 树上dp
#include <iostream>
using namespace std;
const int MAXN = 16005;
struct Edge//链式前向星建图
{
    int to, nxt;
} edge[MAXN<<1];
inline int read()//快读
{
    int u = 0, f = 1;
    char c = getchar();
    for (; !isdigit(c); c = getchar())
        if (c == '-')
            f = -1;
    for (; isdigit(c); c = getchar())
        u = (u << 3) + (u << 1) + c - '0';
    return u * f;
}
int n, cnt, val[MAXN], head[MAXN], f[MAXN], ans = -2147483647;
inline void addedge(int u, int v)//因为是树所以要连双边
{
    edge[++cnt].nxt = head[u];
    edge[cnt].to = v;
    head[u] = cnt;
    edge[++cnt].nxt = head[v];
    edge[cnt].to = u;
    head[v] = cnt;
}
inline int dfs(int u, int fa)//树上dp
{
    f[u] = val[u];
    for (register int i = head[u]; i; i = edge[i].nxt)
        if (edge[i].to != fa)
            f[u] += dfs(edge[i].to, u);
    ans = max(ans, f[u]);
    return max(0, f[u]);
}
int main()
{
    n = read();
    for (register int i = 1; i <= n; ++i)
        val[i] = read();//读入每个节点的值
    for (register int i = 1; i < n; ++i)
        addedge(read(), read());//连边
    dfs(1, 0);//从根节点开始dp
    printf("%d", ans);
}
```


---

## 作者：Tritiums (赞：0)

### 看一下样例，构建树
![](https://cdn.luogu.com.cn/upload/pic/53009.png)

### 解题思路

“上面共连有N朵花，共有N-1条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的”
它是一棵无根树。以任意顶点为根，深搜这棵树。
对于某父亲节点，如果子树幸福指数为正，那么有用，留着
                                   如果子树幸福指数为负，那么无用，剪掉

设f[x]为，以x节点为根的这棵树，且根节点x必选的，最大幸福指数
那么 f[x] = r[x] + sum( max(0, f[son] ) )  , son是x的儿子节点

目标 max(f[i]) 
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[16010]; 
vector<int> son[16010];
bool vis[16010]={0};
int ans;
int dp[16010];
void dfs(int fa){
	vis[fa]=true;
	dp[fa]=a[fa];
	for(int i=0;i<son[fa].size();i++){
		if(!vis[son[fa][i]]){
			dfs(son[fa][i]);
			if(dp[son[fa][i]]>0)dp[fa]+=dp[son[fa][i]];
		}
	}
	if(ans<dp[fa])ans=dp[fa];
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]; 
	ans=a[1];
	for(int i=1;i<n;i++){
		int a,b;cin>>a>>b;
		son[a].push_back(b);
		son[b].push_back(a); 
	}
	dfs(1);
	cout<<ans;
	return 0;
}
```

---


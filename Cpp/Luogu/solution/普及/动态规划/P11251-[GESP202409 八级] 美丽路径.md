# [GESP202409 八级] 美丽路径

## 题目描述

小杨有一棵包含 $n$ 个节点的树，节点从 $1$ 到 $n$ 编号。每个节点要么是白色，要么是黑色。

对于树上的一条简单路径（不经过重复节点的路径），小杨认为它是美丽的当且仅当路径上相邻节点的颜色均不相同。例如下图，其中节点 $1$ 和节点 $4$ 是黑色，其余节点是白色，路径 $2-1-3-4$ 是美丽路径，而路径 $2-1-3-5$ 不是美丽路径（相邻节点 $3$ 和 $5$ 颜色相同）。

![](https://cdn.luogu.com.cn/upload/image_hosting/zyz3v6jo.png)

对于树上一条简单路径，小杨认为它的长度是路径包含的节点数量。小杨想知道最长美丽路径的长度是多少。

## 说明/提示

| 子任务 | 占比 | $n$ | 特殊约定 |
| :-: | :-: | :-: | :-: |
| $1$ | $30\%$ | $\leq 1000$ | 树的形态是一条链 |
| $2$ | $30\%$ | $\leq 1000$ | 无 |
| $3$ | $40\%$ | $\leq 10^5$ | 无 |

对全部的测试数据，保证 $1 \leq n \leq 10^5$，$0 \leq c_i \leq 1$，保证给出的是一棵树。

## 样例 #1

### 输入

```
5
1 0 0 1 0
1 2
3 5
4 3
1 3```

### 输出

```
4```

## 样例 #2

### 输入

```
5
0 0 0 0 0
1 2
2 3
3 4
4 5```

### 输出

```
1```

# 题解

## 作者：ssfx2019s005 (赞：11)

算法：树的直径

首先，颜色相同的两个点之间的边，无论如何都不会被经过，因此直接忽略即可。颜色不同的两个点之间的边，我们保留它并让它的边权为 $1$。

这样，这棵树就被分成了若干个连通块，其中每个连通块都是一棵树。容易发现每个连通块中最长的路径就是它的直径。因此，对每颗树求出直径后最大的直径即为所求。

code：

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=2e5+15;
int col[N];
int e[N],ne[N],h[N],idx,w[N];
int f[N],g[N],mxl;
int n;
int dfn[N],timestamp;
void add_in(int x,int y,int z){
	e[++idx]=y; ne[idx]=h[x]; w[idx]=z; h[x]=idx;
} 
void dfs(int u,int fa){ //树的直径
	dfn[u]=++timestamp; //记录一下访问了该节点
	int v;
	f[u]=0;
	for(int i=h[u];i;i=ne[i]){
		v=e[i];
		if(v==fa) continue;
		dfs(v,u);
		mxl=max(mxl,f[u]+f[v]+w[i]);
		f[u]=max(f[u],f[v]+w[i]);
	} 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>col[i];
	}
	int x,y;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		if(col[x]==col[y]) continue; //两点颜色相同则不用建边
		add_in(x,y,1);
		add_in(y,x,1);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		if(!dfn[i]) //该节点未被访问过
			dfs(i,0);
	}
	cout<<mxl+1<<endl; //因为树的直径计算的是经过边的条数，因此需+1
	return 0;
} 
```

---

## 作者：chengyixuan1308 (赞：4)

# 题解
#### 废话
本菜鸡在考试时只把 T1 AC 了，T2（就是这道题）不知道为什么 WA 了 2 个点，挂了 5 分，导致最终只有 91 分了。
## 思路
一看就是树型 dp。

设 $f_u$ 为节点 $u$ 向下的最长黑白间隔的路径长度。

于是对于一个点 $u$，以它为顶点的路径最长为 $f_u$ 的最大值与 $f_u$ 的次大值的和再加一。

我们可以想到维护两个数组 $f1$ 与 $f2$，分别表示 $f$ 数组的最大值和次大值。  
然后答案就可以表示出来了：$\max_{u = 1}^nf1_u + f2_u + 1$。

最后只要维护 $f1$ 与 $f2$ 即可。

对于每一个节点 $u$，枚举子节点 $v$，若 $c_u = c_v$，则子节点 $v$ 对节点 $u$ 不会产生影响。若 $c_u + c_v = 1$，则将 $f1_v + 1$ 计入对 $u$ 的贡献中。
## AC Code
``` cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n,c[N],f1[N],f2[N];
vector<int> es[N];
int ans = 0;
void dfs(int u,int fa)
{
    for(int i = 0,v;i < es[u].size();i++)
    {
        v = es[u][i];
        if(v == fa) continue;
        dfs(v,u);
        int t = (c[u] != c[v] ? f1[v] + 1 : 0);
        if(t > f1[u])	f2[u] = f1[u],f1[u] = t;
        else if(t > f2[u])	f2[u] = t;
    }
    ans = max(ans,f1[u] + f2[u] + 1);
}
int main()
{
    cin >> n;
    for(int i = 1;i <= n;i++)   cin >> c[i];
    for(int i = 1,u,v;i < n;i++)
        cin >> u >> v,es[u].push_back(v),es[v].push_back(u);
    dfs(1,0);
    cout << ans << endl;
    return 0;
}

```

---

## 作者：zhhgdm (赞：4)

显而易见，这是一道树形 dp 的题，和上次[最远点对](https://www.luogu.com.cn/problem/P10725)这道题类似，但简单了很多。

### 状态定义

在这道题中，我们把状态定义成**以第 $i$ 个点为${\color{red}开头}$（注意，不是“根”）的美丽路径最长是多少**。

### 状态转移

搜索它的所有子节点，对于每个子节点的都可以算出 $dp_j$。$dp_i$ 即为每一个颜色第 $i$ 个点不同的子节点美丽路径最长长度的最大值 $+1$（$dp_i=max(dp_i,dp_j+1$），$+1$ 表示第 $i$ 个点本身）。

然而，对于下图：

![网络好像有点问题，图片加载失败](https://cdn.luogu.com.cn/upload/image_hosting/tnzcvca7.png)

注：以“W”开头的点为白色，以“B”开头的点为黑色。

这样做找到的路径为 $B1 \rightarrow W1 \rightarrow B2 \rightarrow W3$，而实际路径应为 $B4 \rightarrow W2 \rightarrow B1 \rightarrow W1 \rightarrow B2 \rightarrow W3$。

怎么办呢，其实不用改状态定义，但在更新 $ans$ 时，不能用 $dp_{i}$，要用以第 $i$ 个点为开头的美丽路径的最大值与次大值之和来更新。也就是选一条最长的美丽路径和次长的美丽路径，合在一起，显然，一定能拼成，且一定最长。

## 完整代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
vector<int> mp[100005];
int dp[100005];
int maxn=1;
void dfs(int x,int f){
	vector<int> v; // 不想写最大值和次大值，直接搞个 vector 排序，前两个分表示最大值和次大值
	dp[x]=1;
	for(int i:mp[x]){
		if(i==f) continue;
		dfs(i,x);
		if(a[i]!=a[x]){
			dp[x]=max(dp[x],dp[i]+1);
			v.push_back(dp[i]);
		}
	}
	sort(v.begin(),v.end(),greater<int>());
	if(v.size()==0) return ; // 特判叶子节点
	if(v.size()==1) maxn=max(maxn,v[0]+1); // 特判只有一条以第 i 个点为开头的美丽路径，+1 表示第 i 个点本身 v 里存的是不带地 i 个点本身的，要不然一会儿算了两遍第 i 个点，就得 -1
	else maxn=max(maxn,v[0]+v[1]+1);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		mp[u].push_back(v);
		mp[v].push_back(u); // 双向建图，题目给是的无根树
	}
	dfs(1,0);
	cout<<maxn;
	return 0;
}
```

---

## 作者：末然Ender (赞：3)

# 题解：P11251 [GESP202409 八级] 美丽路径

## 思路

这是一道很板的题目啊。

很容易注意到如果一条边连接了两个颜色相同的节点，那么这条边是无论如何也不会走的，所以我们将这种边断开，**只去连接那些连接两个异色节点的边**。

若如此做，这棵树就被我们拆分成了许多棵互不相连的树，这些树中的任意路径都是美丽路径，我们只需要分别求出每一棵树中的最长路径然后求最大值即可。

然后我们就可以去考虑在一棵树中如何去求最长路径了，我们都知道一棵树中的最长路径就是这棵树的直径，我们就把这个题转化成了求树的直径的模板题了。

简单说一下，求一棵树的直径有两个方法，分别是：

1. 搜索：对任一点进行一次搜索（dfs 和 bfs 皆可）找到离它最远的那个点然后，再对这个点再跑一次同样的搜索找到离这个点最远的点，然后这两个点之间的路径就是这棵树的直径了。
2. 树形 dp：我们钦定一个点为树的根时，这个树每个节点作为子树的根向下所能延伸的最长路径长度 $d_1$ 与次长路径（与最长路径无公共边）长度 $d_2$，那么直径就是对于每一个点，该点 $d_1 + d_2$ 能取到的值中的最大值。

然后对于每一棵树我们这么跑就行了。

dp 求直径可以处理负权的树但是这个题所有边权都是 $1$ 所以我选择了用两次搜索。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
/*以上是快读快输*/
typedef long long ll;
const int N=1e5+5,M=1e5+5;
ll head[N],idx;
struct edge{
	int to,nxt;
}e[(M<<1)]; 
void add(int f, int t)
{
	e[++idx].to = t;
	e[idx].nxt = head[f];
	head[f] = idx;
}
ll n;
ll c[N];
ll d[N];
ll ans,id;
bool vis[N];
void dfs(ll x,ll fa){
	vis[x]=1;
	for(int i=head[x];~i;i=e[i].nxt){
		ll u=e[i].to;
		if(u==fa)continue;
		d[u]=d[x]+1;
		if(d[u]>ans){
			ans=d[u],id=u;
		}
		dfs(u,x);
	}
}
ll solve(ll root){
	ans=-1,d[root]=0;
	dfs(root,0);
	ans=-1,d[id]=0;
	dfs(id,0);
	return ans;
}
int main() {
	memset(head,-1,sizeof head);
	read(n);
	for(int i=1;i<=n;i++){
		read(c[i]);
	}
	for(int i=1;i<=n-1;i++){
		ll x,y;
		read(x,y);
		if(c[x]^c[y])add(x,y),add(y,x);
	}
	ll res=0;
	for(int i=1;i<=n;i++){
		if(!vis[i])res=max(res,solve(i));
	}
	write(res+1);
	putchar('\n');
	return 0;
}
```

这个题的难度还是很低的，没有什么思维难度，难度全在求树的直径上，可以作为求树的直径的模板题。

---

## 作者：Getaway_Car_follower (赞：2)

我们设 $dp_{i,0}$ 表示在 $i$ 的子树中一条路经的一个起点为 $i$ 的最长路径，设 $dp_{i,1}$ 表示 $i$ 子树中最长路径。

那么转移为 $dp_{i,0}=
\max_{j\in son_{i}}\{dp_{j,0}\}+1$，$dp_{i,1}=\max\{\max_{j\in son_{i}}\{dp_{j,1}\},dp_{i,0}+\operatorname{lmax}_{j\in son_{i}}\{dp_{j,0}\}+1\}$，此处 $\operatorname{lmax}$ 指次大值。

那么我们就能直接按照上述思路模拟就行了。

---

## 作者：andycode (赞：2)

# 题目大意
给你一颗树，每个结点为黑色或白色。求一条路径，使得路径上距离为奇数的点颜色不同，距离为偶数的点颜色相同，输出这条路径最多能包含多少结点。
# 思路讲解
容易想到用树形动态规划搭配 `dfs` 解决。

将结点 $1$ 设为根节点。设 $dp_{i,0}$ 为以结点 $i$ 为根节点的子树中，以 $i$ 为起点的美丽路径最多包含多少个结点，$dp_{i,1}$ 为以结点 $i$ 为根节点的子树中，经过结点 $i$ 却不以结点 $i$ 为起点或终点的美丽路径最多包含多少个结点。

将 $dp_{i,0}$ 的初始值设为 $1$。我们通过 `dfs` 搜索结点 $i$ 的所有子结点，设当前搜索到的子节点为 $j$，如果 $c_i \ne c_j$，则说明结点 $i$ 可以连接到以结点 $j$ 为起点的美丽路径上，$dp_{i,0}$ 就等于 $\max(dp_{i,0},1+dp_{j,0})$。

对于 $dp_{i,1}$，容易发现，以结点 $i$ 为根节点的子树中，不以 $i$ 为起点或终点的美丽路径，其实就是用结点 $i$，将两条以它的颜色不同于它的子节点为起点的路径相连。而要想让其最长，只需取最大的两条即可。

我们可以给结点 $i$ 的所有颜色不同于它的子节点 $j$ 的 $dp_{j,0}$ 从大到小进行排序，或放进一个大根堆中，取最大的两个相加再加 $1$ 即可（前提是结点 $i$ 要有至少 $2$ 个颜色不同于它的子节点）。

答案为 $\max\limits_{i=1}^{n}\max(dp_{i,0},dp_{i,1})$。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,c[100005],dp[100005][2],ans;
bool to[100005];
vector<int> g[100005];
void dfs(int x){
    to[x]=1;//标记是否被访问过
    int len=g[x].size();
    dp[x][0]=1;//初始化为 1
    priority_queue<int> q;
    for(int i=0;i<len;i++)
        if(!to[g[x][i]]){
        	dfs(g[x][i]);//要先进行 dfs
        	if(c[x]!=c[g[x][i]]){//如果颜色不同
        		dp[x][0]=max(dp[x][0],dp[g[x][i]][0]+1);
            	q.push(dp[g[x][i]][0]);
              //赋值 dp[x][0] 并将其放入堆中
            }
        }
    if(q.size()>1){
      //如果数量大于 1，赋值 dp[x][1]
    	int last=q.top();
    	q.pop();
    	dp[x][1]=1+last+q.top();
	}
    ans=max(ans,max(dp[x][0],dp[x][1]));//统计答案
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&c[i]);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Crasole (赞：2)

## 思路

和树的直径求法类似，设 $d1, d2$ 数组分别表示能从该节点出发能访问到的最长和次长美丽路径，答案就是 $d1_i + d2_i$ 的最大值加 $1$。

转移也很简单，对于节点 $u$，和其任一子节点 $v$，若 $c_u + c_v = 1$，则用 $d1_v + 1$ 去更新 $d1_u$ 和 $d2_u$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, ans;
int c[N], d1[N], d2[N];
vector <int> e[N];

void dfs(int u, int fa) {
	d1[u] = d2[u] = 0;
	for(int& v : e[u]) {
		if(v == fa) continue;
		dfs(v, u);
        //转移
		int t = (c[u] + c[v] == 1 ? d1[v] + 1 : 0);
		if(t > d1[u]) d2[u] = d1[u], d1[u] = t;
		else if(t > d2[u]) d2[u] = t;
	}
	ans = max(ans, d1[u] + d2[u]);
	return ;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> c[i];
    for (int i = 1; i < n; ++i) {
    	int u, v;
    	cin >> u >> v;
    	e[u].push_back(v), e[v].push_back(u);
	}
	dfs(1, 0);
    //别忘了加1
	cout << ans + 1 << '\n';
	return 0;
}
```

---

## 作者：xuezhiyu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11251#submit)

# 题目分析

一道较入门的树形 `dp`。

我们先来看树上的一条路径是由什么组成的，例如一条从 $u$ 到 $v$ 的路径 $u-v$ 可以被表示成从 $u$ 到 $u$ 和 $v$ 的最近公共祖先再到 $v$，即 $u-lca_{u,v}-v$。从这个最近公共祖先（设为 $l$）出发，就可以再把这个路径拆解为从 $l$ 到一个在点 $l$ 其中一个子节点的子树中的节点 $u$ 的路径再加上从 $l$ 出发到处于另一个子节点的子树种的节点 $v$。于是我们就可以再点 $l$ 把符合条件的最远的和次远的处于两个不同的子节点的子树中的节点到节点 $l$ 路径上的节点数记录下来，存为 $d_1$ 和 $d_2$。很明显这两个变量最开始要初始化为 $1$，即只包含 $l$ 这个节点。

具体到这道题里面，我们就是要找颜色和节点 $l$ 的颜色不同的节点的 $d_1 + 1$ 和 $d_2 + 1$（因为还要加上 $l$ 这个节点）来更新节点 $l$ 的 $d_1$ 和 $d_2$。

最后对于一个节点来说，以它为深度最小的节点的最长的满足条件的路径长度就是 $d_1 + d_2 - 1$，这里减去的 $1$ 是因为这个深度最小的节点被算了两次。

这就是树形 `dp` 找树中满足要求的最长路径的基本套路了，对付其他题只需要改一下让子节点更新的父节点的条件即可。

# 代码时间

```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10;
int n, c[N], h[N], e[M], ne[M], idx, d1[N], d2[N], ans;

void addedge(int u, int v) {
	++idx;
	e[idx] = v;
	ne[idx] = h[u];
	h[u] = idx;
}

void dfs(int u, int fat) {
	d1[u] = d2[u] = 1; // 初始化为 1，即只包含 u 点自身的路径
	for (int i = h[u]; i; i = ne[i]) {
		if (e[i] == fat) continue; // 防止重复访问父节点陷入死循环
		dfs(e[i], u);
		if (c[e[i]] != c[u]) { // 只有子节点的颜色与父节点的颜色不同时才更新
			// 更新 d1 和 d2
			if (d1[e[i]] + 1 > d1[u]) d2[u] = d1[u], d1[u] = d1[e[i]] + 1; 
			else if (d1[e[i]] + 1 > d2[u]) d2[u] = d1[e[i]] + 1;
			else if (d2[e[i]] + 1 > d1[u]) d2[u] = d1[u], d1[u] = d2[e[i]] + 1;
			else if (d2[e[i]] + 1 > d2[u]) d2[u] = d2[e[i]] + 1;
		}
	}
	ans = max(ans, d1[u] + d2[u] - 1); // 统计节点 u 的答案
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		addedge(u, v);
		addedge(v, u);
	}
	dfs(1, 0);
	cout << ans << endl;
	return 0;
}
```

---


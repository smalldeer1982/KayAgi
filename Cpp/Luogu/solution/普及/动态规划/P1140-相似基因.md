# 相似基因

## 题目背景

大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。

在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。

## 题目描述

两个基因的相似度的计算方法如下：

对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \texttt - & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt - & \texttt - & \tt T & \texttt A & \tt G \\ \hline
\end{array}
$$

这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：

$$
\def\arraystretch{1.5}
\begin{array}{ |c|c|c|c|c|c|} \hline
& \tt A & \tt C & \tt G & \tt T & \texttt - \\ \hline
\tt A & 5 & -1 & -2 & -1 & -3\\ \hline
\tt C & -1 & 5 & -3 & -2 & -4 \\\hline
\tt G & -2 & -3 & 5 & -2 & -2 \\\hline
\tt T & -1 & -2 & -2 & 5 & -1 \\\hline
\texttt - & -3 & -4 & -2 & -1 & * \\\hline
\end{array}
$$ 

那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt T & \texttt A & \texttt - & \tt G \\ \hline
\end{array}
$$

相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。


## 样例 #1

### 输入

```
7 AGTGATG
5 GTTAG
```

### 输出

```
14
```

# 题解

## 作者：zhy137036 (赞：702)

这篇题解原是我的第一篇题解。随着我对 dp 了解更加深入，题解要求更加严格，我决定于2020年1月19日进行一次大更新。

[云剪贴板](https://www.luogu.com.cn/paste/u7l8dqnn)效果更佳。
## 一、题目分析
### 1.dp 基本思路
就我做过的近百道黄绿难度的 dp 来说，dp 题基本这么几个步骤：
1. 定义状态。
2. 写出状态转移式。
3. 根据状态转移式找出递推顺序。
4. 处理递推的边界。
5. 找出结果。

我讲解时不会就题论题，而是讲大部分黄绿难度的 dp 题的方法。

当然，dp 题十分灵活，不会看完这篇题解就会做，关键在于大量的练习。
### 2.状态定义
定义状态是 dp 最重要的步骤之一，状态定义得不好后面全都无法进行。

像这种线性动态规划，定义经常是“$f_i$ 表示前 $i$ 个满足要求时的答案”。

因为这道题有两个串，很容易想到状态的定义是“$f_{i,j}$ 表示 $a$ 串的前 $i$ 个碱基和 $b$ 串的前 $j$ 个碱基的相似度”。
### 3.转移式
通常定义出状态之后转移式就十分好写了。转移式通常只需要考虑最后一点，比如这道题只用考虑最后一对碱基。

最后一对碱基只有以下3种可能：

1. 非空碱基和非空碱基。
2. 非空碱基和空碱基。
3. 空碱基和非空碱基。

注：空碱基和空碱基不能匹配。

去掉最后一对碱基，转化成规模更小的同样的问题，就是转移式的意义。易得如下转移式：
$$\Large{\color{black}{f_{i,j}=max(}\color{red}{f_{i-1,j-1}+d_{a_{i},b_{j}}},\color{green}{f_{i-1,j}+d_{a_{i},5}},\color{blue}{f_{i,j-1}+d_{b_{j},5}}\color{black}{)}}$$
其中 $d_{i,j}$ 表示编号为 $i$ 的碱基和编号为 $j$ 的碱基的相似程度，编号为5的是空碱基，$a_{i}$ 表示第一个基因的第 $i$ 个碱基，$b$ 表示第二个基因的第 $i$ 个碱基。

其中红色代表第一种情况的转移，绿色代表第二种，蓝色代表第三种。

如果还不能明白，就看下面的图吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/tylpht0w.png)

### 4.递推顺序
这步通常挺简单的，看看下标是变大还是变小。如果你要滚动数组的话（这题好像不能用滚动数组），递推顺序就会难一些。

显然，转移时下标不会变大，为了无后效性，应该从小到大递推。至于先枚举 $i$ 还是 $j$，并不重要。
### 5.边界
递推顺序找到，边界就很容易找到了。

既然下标都是不变或变小，那边界就是至少有一个下标为0。如果一个下标为0，另一个下标不为0，上面3种转移只有一种有效，即：
$$\LARGE{f_{i,0}=f_{i-1,0}+d_{a_{i},5}}$$
$$\LARGE{f_{0,i}=f_{0,i-1}+d_{5,b_{i}}}$$
如果两个下标都为0，也就是 $f_{0,0}$，三个转移都会失效。我们应该按照定义赋给它值：0个碱基和0个碱基的相似度应为0。所以得到最后一个式子：
$$\Huge{f_{0,0}=0}$$

### 6.结果
这道题的结果很好找，就是 $f_{l_a,l_b}$（$l_a$，$l_b$分别代表 $a$ 的长度和 $b$ 的长度），但是有些题的结果还得在多个数中找，比较麻烦。
### 7.实现
5个步骤的思维顺序如上，但是代码顺序略有不同，大概是这样的：
1. 状态定义。
2. 输入。
3. 递推边界。
4. 递推顺序。
5. 状态转移式。
6. 找出结果。

我经常在找出转移式后就迫不及待地写，结果代码中第二步就不行了，只能边写边想，最后代码十分混乱，bug 也不好找。所以最好把5个步骤做完再写代码。
## 二、代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int la,lb,a[110],b[110],f[110][110];//状态定义
int d[6][6]=
{
	{0,0,0,0,0,0},
	{0,5,-1,-2,-1,-3},
	{0,-1,5,-3,-2,-4},
	{0,-2,-3,5,-2,-2},
	{0,-1,-2,-2,5,-1},
	{0,-3,-4,-2,-1,0}
};
int main()
{
	//开始输入 
	cin>>la;
	for(int i=1;i<=la;i++)
	{
		char t;
		cin>>t;
		switch(t)
		{
		case'A':
			a[i]=1;break;
		case'C':
			a[i]=2;break;
		case'G':
			a[i]=3;break;
		case'T':
			a[i]=4;break;
		}
	}
	cin>>lb;
	for(int i=1;i<=lb;i++)
	{
		char t;
		cin>>t;
		switch(t)
		{
		case'A':
			b[i]=1;break;
		case'C':
			b[i]=2;break;
		case'G':
			b[i]=3;break;
		case'T':
			b[i]=4;break;
		}
	}
	//输入结束 
	
	//开始处理边界 
	f[0][0]=0;//全局变量自动初始化为0，但是作为题解，还是写上好。
	for(int i=1;i<=la;i++)
		f[i][0]=f[i-1][0]+d[a[i]][5];
	for(int i=1;i<=lb;i++)
		f[0][i]=f[0][i-1]+d[5][b[i]];
	//边界处理结束
	
	//开始 dp
	for(int i=1;i<=la;i++)
		for(int j=1;j<=lb;j++)
			f[i][j]=max(f[i-1][j-1]+d[a[i]][b[j]],max(f[i-1][j]+d[a[i]][5],f[i][j-1]+d[5][b[j]]));
	//dp 结束 
	
	//开始输出结果 
	cout<<f[la][lb]<<endl;
	//输出结果结束
	return 0;
}
```
最后，码字不易，记得点赞 QwQ。

---

## 作者：Segment_Tree (赞：143)

Powered by 2e8\_konjak

分析：

此题是一道简单（？）的动态规划题目。

首先建立一个table，存入各个基因相似度（如下）

```cpp
const int tab[5][5]=
{
    {5,-1,-2,-1,-3},
    {-1,5,-3,-2,-4},
    {-2,-3,5,-2,-2},
    {-1,-2,-2,5,-1},
    {-3,-4,-2,-1,0}
};
```
接着进行一波预处理：

```cpp
for(int i=1;i<=la;i++) for(int j=1;j<=lb;j++) dp[i][j]=-2e8;//设置极小值
    for(int i=1;i<=la;i++)
    {
        if(sa[i-1]=='A') a[i]=0;
        if(sa[i-1]=='C') a[i]=1;
        if(sa[i-1]=='G') a[i]=2;
        if(sa[i-1]=='T') a[i]=3;
    }//将字符转换为表中对应的编号
    for(int i=1;i<=lb;i++)
    {
        if(sb[i-1]=='A') b[i]=0;
        if(sb[i-1]=='C') b[i]=1;
        if(sb[i-1]=='G') b[i]=2;
        if(sb[i-1]=='T') b[i]=3;
    }//同上
```
然后开始动态规划：

1.（特判）因为第一/二段的1与第二/一段的0匹配时可视作与空碱基匹配，所以先进行一波预处理：

```cpp
for(int i=1;i<=la;i++) dp[i][0]=dp[i-1][0]+tab[a[i]][4];
for(int i=1;i<=lb;i++) dp[0][i]=dp[0][i-1]+tab[b[i]][4];
```
2.接着逐个判断即可得出三条状态转移方程，取三种配对方法（1.一中插空碱基；2.二中插空碱基；3.直接配对）所得结果中最优的一种。

（上伪代码）

{
若在第一段基因中插入空碱基相似度更优  则在第一段插入空碱基

若在第二段基因中插入空碱基相似度更优  则在第二段插入空碱基

若直接配对的相似度高于以上两者  则直接插入

```cpp
for(int i=1;i<=la;i++)
          for(int j=1;j<=lb;j++)
        {
            dp[i][j]=max(dp[i][j],dp[i][j-1]+tab[b[j]][4]);
            dp[i][j]=max(dp[i][j],dp[i-1][j]+tab[a[i]][4]);
            dp[i][j]=max(dp[i][j],dp[i-1][j-1]+tab[a[i]][b[j]]);
        }
```
}
3.最后输出结果即可。

PS：
1.读入时若使用c++中的string~~（蒟蒻福音）~~会使代码较为简洁；

2.预处理时慎用switch，可能会导致转换结果出错

以下是完整代码：

```cpp
#define N 105
#include<cstdio>
#include<string>
#include<iostream>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
const int tab[5][5]=
{
    {5,-1,-2,-1,-3},
    {-1,5,-3,-2,-4},
    {-2,-3,5,-2,-2},
    {-1,-2,-2,5,-1},
    {-3,-4,-2,-1,0}
};
int la,lb;
std::string sa,sb;
int a[N],b[N];
int dp[N][N];
int main()
{
    std::ios::sync_with_stdio(0);
    std::cin>>la>>sa>>lb>>sb;
    for(int i=1;i<=la;i++) for(int j=1;j<=lb;j++) dp[i][j]=-2e8;
    for(int i=1;i<=la;i++)
    {
        if(sa[i-1]=='A') a[i]=0;
        if(sa[i-1]=='C') a[i]=1;
        if(sa[i-1]=='G') a[i]=2;
        if(sa[i-1]=='T') a[i]=3;
    }
    for(int i=1;i<=lb;i++)
    {
        if(sb[i-1]=='A') b[i]=0;
        if(sb[i-1]=='C') b[i]=1;
        if(sb[i-1]=='G') b[i]=2;
        if(sb[i-1]=='T') b[i]=3;
    }
    for(int i=1;i<=la;i++) dp[i][0]=dp[i-1][0]+tab[a[i]][4];
    for(int i=1;i<=lb;i++) dp[0][i]=dp[0][i-1]+tab[b[i]][4];
    for(int i=1;i<=la;i++)
          for(int j=1;j<=lb;j++)
        {
            dp[i][j]=max(dp[i][j],dp[i][j-1]+tab[b[j]][4]);
            dp[i][j]=max(dp[i][j],dp[i-1][j]+tab[a[i]][4]);
            dp[i][j]=max(dp[i][j],dp[i-1][j-1]+tab[a[i]][b[j]]);
        }
    printf("%d",dp[la][lb]);
    return 0;
}
```

---

## 作者：Ykimna (赞：98)


### 我想大多数人是卡在了dp数组的定义和状态转移方程
我也不知道我是否能讲清楚，如果哪里有疑问可以评论，或私信我（我在退役之前都能回答你）

首先dp数组的定义，我是这样定义的：
```
dp[i][j]

```
### 代表的是，第一个碱基序列的前i位非空格脱氧核苷酸与第二个碱基的前j位脱氧核苷酸的最大值是多少(就是非空格)

例如
```cpp
7 AGTGATG
5 GTTAG
```
```cpp
dp[2][3]代表的就是AG与GTT相对应的最大值
```
### 接下来就是转移方程
```cpp
7 AGTGATG
5 GTTAG
```
### 这里用正反两种方式叙述：
当i=1,j=1时也就是A与G对应，很显然有三种状态：

![](https://cdn.luogu.com.cn/upload/image_hosting/n10pt2le.png)

很显然最大值为第一种状态，接着这个状态可以更新的状态分别有三个：i=2,j=1 ; i=1,j=2 ; i=2,j=2 
#### 分别代表着三种对应方法第一个碱基序列的核苷酸匹配一个空格、第二个碱基序列的核苷酸匹配匹配一个空格、直接匹配两个核苷酸

![](https://cdn.luogu.com.cn/upload/image_hosting/76yejzab.png)

### 也就是dp[i][j]可以转移到dp[i+1][j] , dp[i][j+1] , dp[i+1][j+1]。  
### 所以同理可以说明dp[i][j]可以由dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]转移过来

再举个栗子
当i=2，j=1时 也就是AG对应G，dp[2][1]有三种状态

这个状态可以由这三个状态更新：i=1,j=0 , i=2,j=0 , i=1,j=1。

![](https://cdn.luogu.com.cn/upload/pic/48823.png)


### 这里也就是这样更新的：直接匹配两个核苷酸、第一个碱基序列的核苷酸匹配一个空格、第二个碱基序列的核苷酸匹配匹配一个空格，这三个状态。

### 上伪代码


```cpp
	for(int i=1;i<=la;i++)
	{
		for(int j=1;j<=lb;j++)
		{
			dp[i][j]=max(dp[i][j],dp[i-1][j]+v[a[i]][5]);//第二个碱基序列的核苷酸匹配空格
			dp[i][j]=max(dp[i][j],dp[i][j-1]+v[5][b[j]]);//第一个碱基序列的核苷酸匹配空格
			dp[i][j]=max(dp[i][j],dp[i-1][j-1]+v[a[i]][b[j]]);//第一个碱基序列和第二个碱基序列的核苷酸匹配
		}                                
	}
    
```


## 剩下就是细节问题
### 1. 可以用map把碱基之间的相似度处理，也可以用数字代替
```cpp
int v[6][6]={	
				{0,0,0,0,0,0},
			 	{0,5,-1,-2,-1,-3},
			 	{0,-1,5,-3,-2,-4},
			 	{0,-2,-3,5,-2,-2},
			 	{0,-1,-2,-2,5,-1},
			 	{0,-3,-4,-2,-1,0}
			};
```


------------

```cpp
	cin>>la;
	for(int i=1;i<=la;i++)
	{
		char x;
		cin>>x;
		if(x=='A') a[i]=1;
		if(x=='C') a[i]=2;
		if(x=='G') a[i]=3;
		if(x=='T') a[i]=4;
	}
	cin>>lb;
	for(int i=1;i<=lb;i++)
	{
		char x;
		cin>>x;
		if(x=='A') b[i]=1;
		if(x=='C') b[i]=2;
		if(x=='G') b[i]=3;
		if(x=='T') b[i]=4;
	}
```
### 2. 要把dp[0][j]和dp[i][0]预处理
因为当一个碱基序列为0时，就是相当于另一个碱基序列全部和空格对应
```cpp

	for(int i=1;i<=la;i++)
	{
		dp[i][0]=dp[i-1][0]+v[a[i]][5];
	}
	for(int i=1;i<=lb;i++)
	{
		dp[0][i]=dp[0][i-1]+v[5][b[i]];
	}

```
### 3.还有一个容易让人忽略的一个点（害得很多人得40分）答案可能为负值所以dp数组要初始为一个较大的负值


# 上完整代码


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e2+50;
int dp[N][N];
int la,lb,a[N],b[N];
int v[6][6]={
                {0,0,0,0,0,0},
                {0,5,-1,-2,-1,-3},
                {0,-1,5,-3,-2,-4},
                {0,-2,-3,5,-2,-2},
                {0,-1,-2,-2,5,-1},
                {0,-3,-4,-2,-1,0}
            };
int main()
{
    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=N;j++)
        {
            dp[i][j]=-1e6;
        }
    }
    cin>>la;
    for(int i=1;i<=la;i++)
    {
        char x;
        cin>>x;
        if(x=='A') a[i]=1;
        if(x=='C') a[i]=2;
        if(x=='G') a[i]=3;
        if(x=='T') a[i]=4;
    }
    cin>>lb;
    for(int i=1;i<=lb;i++)
    {
        char x;
        cin>>x;
        if(x=='A') b[i]=1;
        if(x=='C') b[i]=2;
        if(x=='G') b[i]=3;
        if(x=='T') b[i]=4;
    }
    for(int i=1;i<=la;i++)
    {
        dp[i][0]=dp[i-1][0]+v[a[i]][5];
    }
    for(int i=1;i<=lb;i++)
    {
        dp[0][i]=dp[0][i-1]+v[5][b[i]];
    }
    for(int i=1;i<=la;i++)
    {
        for(int j=1;j<=lb;j++)
        {
            dp[i][j]=max(dp[i][j],dp[i-1][j]+v[a[i]][5]);//第二个碱基序列的核苷酸匹配空格
            dp[i][j]=max(dp[i][j],dp[i][j-1]+v[5][b[j]]);//第一个碱基序列的核苷酸匹配空格
            dp[i][j]=max(dp[i][j],dp[i-1][j-1]+v[a[i]][b[j]]);//第一个碱基序列和第二个碱基序列的核苷酸匹配
        }
    }
    cout<<dp[la][lb];
    return 0;
}

```


---

## 作者：gary2005 (赞：60)

# WA这题真的是太绕人了
### 题解竟然没有一个讲得清楚的，真是太难为本蒟蒻了
现在我们再来进一步分析

大家都定义dp[i][j]表示s1的前i个和s2的前j个相匹配的最大值，那么有：
###### dp[i][j]=max(dp[i-1][j-1]+(i与j的匹配值),dp[i-1][j]+(i与空的匹配值）,dp[i][j-1]+(j与空的匹配值）

甚至这篇题解就写错了
![](https://cdn.luogu.com.cn/upload/pic/50810.png)

那怎么来理解，我们不妨重新定义dp[i][j]的定义：表示**第i个
点** 与**第j个点**相匹配（非前i个与前j个）
我们可以画个图来理解
![](https://cdn.luogu.com.cn/upload/pic/50812.png)

首先我们设i=2，j=3时 两点相匹配
![](https://cdn.luogu.com.cn/upload/pic/50813.png)

然后我们知道3这个点可以和2匹配，3也可以和 “--”相匹配，“--”也可以和2相匹配

然后我们有了三种情况

先是第一种

如果要2与3匹配，必然要1与2匹配

就是这样

![](https://cdn.luogu.com.cn/upload/pic/50814.png)

也就是

dp[i][j]=max(dp[i][j],dp[i-1][j-1]+i与j的匹配值);

第二种：

设3与2匹配

![](https://cdn.luogu.com.cn/upload/pic/50816.png)

添加空基因

![](https://cdn.luogu.com.cn/upload/pic/50817.png)

这样我们就有了转移方程

dp[i][j]=max(dp[i][j],dp[i-1][j]+i与“--”所匹配的值);

同理也可以算得另一个

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int len1,len2,dp[105][105]={0};
string s1,s2;
int tab[5][5]={
	{5,-1,-2,-1,-3},
	{-1,5,-3,-2,-4},
	{-2,-3,5,-2,-2},
	{-1,-2,-2,5,-1},
	{-3,-4,-2,-1,0}
};
int hash(char c){
	if(c=='A'){
		return 0;
	}
	if(c=='C'){
		return 1;
	}
	if(c=='G'){
		return 2;
	}
	if(c=='T'){
		return 3;
	}
	return 4;
}
int main(){
	cin>>len1>>s1;
	cin>>len2>>s2;
	for(int i=1;i<=len1;i++)
	for(int j=1;j<=len2;j++) dp[i][j]=-0x3f3f3f3f;
	dp[0][0]=0;
	for(int i=1;i<=len1;i++) dp[i][0]=dp[i-1][0]+tab[hash(s1[i-1])][4];
	for(int j=1;j<=len2;j++) dp[0][j]=dp[0][j-1]+tab[4][hash(s2[j-1])];
	for(int i=1;i<=len1;i++){
		for(int j=1;j<=len2;j++){
			dp[i][j]=max(dp[i][j],dp[i-1][j]+tab[hash(s1[i-1])][4]);
			dp[i][j]=max(dp[i][j],dp[i][j-1]+tab[4][hash(s2[j-1])]);
			dp[i][j]=max(dp[i][j],dp[i-1][j-1]+tab[hash(s1[i-1])][hash(s2[j-1])]);
		}
	}
	cout<<dp[len1][len2]<<endl;
	return 0;
}
```

---

## 作者：1973395188qqcom (赞：28)

感觉他们的都不太详细，比如我一开始看了半天没看懂～～蒟蒻

f[i][j]:字符串s1的前i个与字符串s2的前j个匹配所能达到的最大匹配值（不计算空碱基）

伪代码：f[i][j]=max(f[i][j],f[i-1][j]+（s2[j]与空碱基匹配的值）,f[i][j-1]+(s1[i]与空碱基匹配的值),f[i-1][j-1]+(s1[i]与s2[j]匹配值))

S1:  A  G  T  G  A  T  G

i  :    1   2   3  4   5  6  7

S2:  G  T  T  A  G

j  :    1  2   3  4   5

当i=3，j=3时 ，（前面四个字符中的空碱基省略不写，这里代表将前四个字符匹配好后能得到的最大值）

1.
S1:  A  G + T

S2:  G  T + T

2.
S1:  A  G + \_(空碱基)

S2:  G  T + T

3.
S1:  A  G + T


S2:  G  T + \_(空碱基)

不知道你们看不看得懂

我的语文功底也就这样了

接下来贴代码：

#include<bits/stdc++.h>//一个高级东西，包含C++所有头文件

```cpp
using namespace std;
int l1,l2,a[110],b[110];
char s1[110],s2[110];
int f[110][110];
int p[6][6]=     //初始化碱基之间的配对值
{
    {0},
    {0,5,-1,-2,-1,-3},
    {0,-1,5,-3,-2,-4},
    {0,-2,-3,5,-2,-2},
    {0,-1,-2,-2,5,-1},
    {0,-3,-4,-2,-1,0}
};
int fuck(char c)//将字符转化为序号
{
    if(c=='A') return 1;
    if(c=='C') return 2;
    if(c=='G') return 3;
     return 4;
}
int main()
{
    //freopen("acgt.in","r",stdin);//文件输入输出
    //freopen("acgt.out","w",stdout);//同上
    int t,i,j;
    scanf("%d%s%d%s",&l1,s1+1,&l2,s2+1);//输入(输入完后s1,s2的第一个字符在s[1]的位置)
    for(i=1;i<=l1;i++)
        for(j=1;j<=l2;j++)
            f[i][j]=INT_MIN;//将f数组初始化为一个很小的值
     for(i=1;i<=l1;i++)
        a[i]=fuck(s1[i]);//将s1中的字符转化为序号存在数组a中
    for(i=1;i<=l2;i++)
        b[i]=fuck(s2[i]);//将s2中的字符转化为序号存在数组b中
    for(i=1;i<=l1;i++)//将f数组赋初值
        f[i][0]=f[i-1][0]+p[a[i]][5];
    for(i=1;i<=l2;i++)//同上
        f[0][i]=f[0][i-1]+p[b[i]][5];
    for(i=1;i<=l1;i++)//DP方程（上面有讲）
        for(j=1;j<=l2;j++)
        {
            f[i][j]=max(f[i][j],f[i][j-1]+p[b[j]][5]);
            f[i][j]=max(f[i][j],f[i-1][j]+p[a[i]][5]);
            f[i][j]=max(f[i][j],f[i-1][j-1]+p[a[i]][b[j]]);
        }
    printf("%d\n",f[l1][l2]);//输出
    return 0;
}
```
绞尽脑汁才想出来
还多亏了神犇WX的帮助


---

## 作者：香风智乃 (赞：15)

写错一个字母....调了半天才过

其实相当于从一个矩阵的左上角（0,0）递推到右下角（lena,lenb）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
using namespace std;
int f[105][105],lena,lenb;
string a,b;
map <char,int> h;  //map个人认为挺方便的，就是速度慢了点
int d[5][5]={{5,-1,-2,-1,-3},
             {-1,5,-3,-2,-4},
             {-2,-3,5,-2,-2},
             {-1,-2,-2,5,-1},
             {-3,-4,-2,-1,0}};
void print()
{
    for(int j=0;j<=lenb;j++)
    {
        for(int i=0;i<=lena;i++) printf("%5d ",f[i][j]);
        printf("\n");
    }
    printf("\n");
}
int main()
{
    h['A']=0;h['C']=1;h['G']=2;h['T']=3;//h[' ']=4;  //stl大法好
    int i,j;
    scanf("%d",&lena);
    cin>>a;
    scanf("%d",&lenb);    
    cin>>b;
    a.insert(0,"#");   //小改进（蒟蒻再怎么改也是蒟蒻，比如我）；
    b.insert(0,"#");  //这样字符串的有效坐标就从1开始了，便于以后的计算；
    for(i=0;i<=lena;i++)
        for(j=0;j<=lenb;j++)
            f[i][j]=-1e8;
    f[0][0]=0;   //初始化；
    for(i=0;i<=lena;i++)
    {
        for(j=0;j<=lenb;j++)
        {
            if(i&&j) f[i][j]=max(f[i-1][j-1]+d[h[a[i]]][h[b[j]]],f[i][j]);
            if(j) f[i][j]=max(f[i][j-1]+d[4][h[b[j]]],f[i][j]);
            if(i) f[i][j]=max(f[i-1][j]+d[h[a[i]]][4],f[i][j]);      //动态转移方程；
        } //和楼下dalao们有些不同，本蒟蒻顺便把边界计算了
    }
    //print();  检查函数（有时候结果刚好是对的，但是过程是错的，所以把中间的数据调出来看）；
    printf("%d",f[lena][lenb]); //右下角为最优答案（刚开始还去扫一遍，60分,mdzz）
    return 0;
}
```

---

## 作者：yezl (赞：10)

**首先来理解下题意：**

~~众所周知，脱氧核糖核酸(DNA)由两条互补的碱基链以双螺旋的方式结合而成。而构成DNA的碱基共有4种，分别为腺瞟呤(A)、鸟嘌呤(G)、胸腺嘧啶(T)和胞嘧啶(C)。我们知道，在两条互补碱基链的对应位置上，腺瞟呤总是和胸腺嘧啶配对，鸟嘌呤总是和胞嘧啶配对。~~

请无视上面那段，来看题，它给出了碱基之间相似度如下图：

![](https://cdn.luogu.com.cn/upload/pic/40.png)

再给出两个基因的碱基链，要我们求它们的相似度（即碱基的相似度总和），注意：它要去所有配对方法中最大的碱基相似度总和为基因的相似度，所有配对方法指的是你可以在碱基链的任意位置插入空碱基，只要使两个碱基链对应就好了。

然后~~看一下这个题目的标签~~，可以很容易得明白要使用动态规划，那么我们就来定义状态： $ \texttt{f[i][j]} $ 表示基因1前i位和基因2前j位的基因相似度最大。  
然后就是写状态转移方程，注意，每次可以选择 $ a[i] $ 与空碱基配对或者 $ b[j] $ 与空碱基配对或者 $ a[i] $ 与 $ b[j] $ 配对，所以有三个转移方程：
 1. $ \texttt{f[i][j]=max(f[i][j],f[i-1][j]+d[get(a[i])][4])}\;(a[i] $和'-'配对)
 2. $ \texttt{f[i][j]=max(f[i][j],f[i][j-1]+d[4][get(b[j])])}\;(b[j] $和'-'配对)
 3. $ \texttt{f[i][j]=max(f[i][j],f[i-1][j-1]+d[get(a[i])][get(b[j])])}\;(a[i]\;\text{和}\;b[j] \text{配对}) $  
 
 那这个 $ get $ 函数和 $ d $ 数组是什么呢？ $ get $ 是一个用来判断的函数，如下：
 
 ```c
int get(char c)
{
	if(c=='A')
		return 0;
	if(c=='C')
		return 1;
	if(c=='G')
		return 2;
	if(c=='T')
		return 3;
	if(c=='-')
		return 4;
}
```

那个 $ d $ 数组其实就是存储了那个配对表：

```c
int d[5][5]= 
{
	5, -1, -2, -1, -3,
	-1, 5, -3, -2, -4,
	-2, -3, 5, -2, -2,
	-1, -2, -2, 5, -1,
	-3, -4, -2, -1, 0
};
```

这样我们的程序就出来啦。

### $ My\;Code: $

```c
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm> 
using namespace std;
const int N=105;
int f[N][N],m,n;
char a[N],b[N];
int d[5][5]= 
{
	5, -1, -2, -1, -3,
	-1, 5, -3, -2, -4,
	-2, -3, 5, -2, -2,
	-1, -2, -2, 5, -1,
	-3, -4, -2, -1, 0
};
int get(char c)
{
	if(c=='A')
		return 0;
	if(c=='C')
		return 1;		
	if(c=='G')
		return 2;
	if(c=='T')
		return 3;
	if(c=='-')
		return 4;
}
int main()
{
	memset(f,0xcf,sizeof(f));
	scanf("%d%s%d%s",&m,a,&n,b);
	for(int i=m;i>=1;i--)
	{
		a[i]=a[i-1];
	}
	for(int i=n;i>=1;i--)
	{
		b[i]=b[i-1];
	}
	f[0][0]=0;//设置f数组的初值，边界 
	//第一段的1与第二段的0配对相当于与空碱基配对
	//第二段的1与第一段的0配对相当于与空碱基配对
	for (int i=1;i<=m; i++) 
	{
		f[i][0]=f[i-1][0]+d[get(a[i])][4];
	}
	for (int i=1;i<=n;i++) 
	{
		f[0][i]=f[0][i-1]+d[get(b[i])][4];
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			f[i][j]=max(f[i][j],f[i-1][j]+d[get(a[i])][4]); //此处a[i]和'-'配对
			f[i][j]=max(f[i][j],f[i][j-1]+d[4][get(b[j])]); //此处b[j]和'-'配对 
			f[i][j]=max(f[i][j],f[i-1][j-1]+d[get(a[i])][get(b[j])]); //此处a[i]和b[j]配对 
		}
	}
	printf("%d",f[m][n]);
	return 0;
}
```

希望可以帮到大家。

---

## 作者：Mophie (赞：8)

**我感觉这题和最长公共子序列很像啊（~~大雾~~）**

这一题的状态转移方程十分好想，设序列1为s1,序列2为s2。

则直到s1的第i个，s2的第j个时，有三种方案，如下：

1.s1第i个，s2第j个均不为空，则为dp[i-1][j-1]加上第i，j个字符的相似度

2.s1第i个为空，则为dp[i][j-1]加上j字符与‘-’的相似度

3.s2第j个为空，则为dp[i-1][j]加上i字符与‘-’的相似度

## **但如果这么简单,这就是橙题了**

相似度该如何储存？

我是这么储存的，将字符写进数组中

```cpp
a['A']['A']=5,a['A']['C']=-1,a['A']['G']=-2,a['A']['T']=-1,a['A'][0]=-3;
	a['C']['A']=-1,a['C']['C']=5,a['C']['G']=-3,a['C']['T']=-2,a['C'][0]=-4;
	a['G']['A']=-2,a['G']['C']=-3,a['G']['G']=5,a['G']['T']=-2,a['G'][0]=-2;
	a['T']['A']=-1,a['T']['C']=-2,a['T']['G']=-2,a['T']['T']=5,a['T'][0]=-1;
	a[0]['A']=-3,a[0]['C']=-4,a[0]['G']=-2,a[0]['T']=-1;
```
这样的优点是查找较方便，但比较麻烦，也容易错，与楼上的储存各有优劣吧。

不多说了，献上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s1[101],s2[101];
int len1,len2;
int dp[101][101];
int a[200][200];
int main()
{
	cin>>len1;
	cin>>s1;
	cin>>len2;
	cin>>s2;
	a['A']['A']=5,a['A']['C']=-1,a['A']['G']=-2,a['A']['T']=-1,a['A'][0]=-3;
	a['C']['A']=-1,a['C']['C']=5,a['C']['G']=-3,a['C']['T']=-2,a['C'][0]=-4;
	a['G']['A']=-2,a['G']['C']=-3,a['G']['G']=5,a['G']['T']=-2,a['G'][0]=-2;
	a['T']['A']=-1,a['T']['C']=-2,a['T']['G']=-2,a['T']['T']=5,a['T'][0]=-1;
	a[0]['A']=-3,a[0]['C']=-4,a[0]['G']=-2,a[0]['T']=-1;
	for(int i=1;i<=len1;i++)dp[i][0]=dp[i-1][0]+a[s1[i-1]][0];
	for(int i=1;i<=len2;i++)dp[0][i]=dp[0][i-1]+a[s2[i-1]][0];
	for(int i=1;i<=len1;i++)
		for(int j=1;j<=len2;j++)
		{
			dp[i][j]=max(max(dp[i][j-1]+a[0][s2[j-1]],dp[i-1][j]+a[s1[i-1]][0]),dp[i-1][j-1]+a[s1[i-1]][s2[j-1]]);
		}
	cout<<dp[len1][len2]<<endl;
	return 0;
}
```

## 话说这个cin和get的坑我调了一个小时才调出来

以后一定要用cin啊~




---

## 作者：thoq (赞：7)

## 1

对于一个题目，除了看题解知道了做法外，还有一个重要的东西，**怎样才能想到这么去做**？

例如在考场上，我们能借助的，只有自己记忆中学过的算法和做过的题目

几个星期前看了这题，没有思路，于是我强迫自己不看题解，搁着了

几天前，我复习动态规划，复习到最长公共子序列的时候，豁然开朗了，立刻想到了这题

那些题目太经典了，考试不会有原题，我们想

但思想是灵活的，**迁移**一下，就成了新题

如果你没思路，想一想最长公共子序列，是不是有思路了？

[代码](https://www.luogu.org/record/22707809)

[大佬很棒的文章](https://www.luogu.org/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie)，推荐

## 2

有必要说明的一点是，为什么没将$dp$数组初始化为$-inf$后，有人WA了,而有人则AC了

因为这个初始化是**没有必要**的

而WA的人，是他们写错了（尽管加上这个初始化就AC了）

```cpp
dp[i][j] = max(dp[i][j], blabla)
```

他们这样写了，然后WA了，接着发现了答案可能为负数，而$dp[i][j]$初始为$0$,所以开始了初始化

但事实上$dp[i][j]$所需考虑的范围根本**不包括$dp[i][j]$本身**

为了本质考虑，而非答案正确，建议大家在改的时候，去掉$max$中的$dp[i][j]$，而非将$dp$数组初始化为$-inf$

---

## 作者：永忻 (赞：3)

```cpp
#include<algorithm>  
#include<iostream>  
#include<cstdlib>  
#include<cstring>  
#include<string>  
#include<cstdio>  
#include<cmath>  
#include<ctime>  
#include<queue>  
#include<stack>  
using namespace std;  
int s[6][6]={{0,0,0,0,0,0},  
             {0,5,-1,-2,-1,-3},  
             {0,-1,5,-3,-2,-4},  
             {0,-2,-3,5,-2,-2},  
             {0,-1,-2,-2,5,-1},  
             {0,-3,-4,-2,-1,0}};  
int finds(char a)  
{  
    if(a=='A') return 1;  
    if(a=='G') return 3;  
    if(a=='C') return 2;  
    if(a=='T') return 4;  
    else return 5;  
}  
int main()  
{  
    int a1,b1;string as,bs;int a[101],b[101];  
    int f[101][101];  
    cin>>a1>>as>>b1>>bs;  
    for(int i=0;i<a1;i++)  
      a[i+1]=finds(as[i]);  
    for(int i=0;i<b1;i++)  
      b[i+1]=finds(bs[i]);  
    for(int i=1;i<=a1;i++)  
      f[0][i]=f[0][i-1]+s[5][a[i]];  
    for(int i=1;i<=b1;i++)  
      f[i][0]=f[i-1][0]+s[b[i]][5];//cout<<"a";  
    for(int i=1;i<=b1;i++)  
      for(int j=1;j<=a1;j++)  
        f[i][j]=max(max(  
                       f[i-1][j-1]+s[b[i]][a[j]],  
                       f[i-1][j]+s[5][b[i]]),  
                       f[i][j-1]+s[5][a[j]]);  
    cout<<f[b1][a1]<<endl;  
    return 0;  
}  
```
思路：存表，动归f[i][j]=max(

f[i-1][j-1]+s[b[i]][a[j]],

f[i-1][j]+s[5][b[i]],

f[i][j-1]+s[5][a[j]]);


---

## 作者：0逝者如斯夫0 (赞：2)

我的脑子有个洞，用了一种奇奇怪怪的做法，看了别人的题解发现自己真的太弱了，但是我是放上来吧。
预处理一下两个串分别对着空碱基的前缀和
f[i][1]和f[1][j]的况
f[i][j]指A串第i个对应B串第j个的最优解
然后在处理的时候考虑i-1和之前的
还有j-1和之前的（具体看程序好理解一点）
然后这样就奇迹般地过了。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<map>
#define INF 2147483647
using namespace std;
map<char,int>t;
int w[5][5];
char g;
int n1,n2,i,j,k,ans,a[110],b[110];
int p[110],s[110],f[110][110];
int main(){
	//freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
	t['A']=1;t['C']=2;t['G']=3;t['T']=4;
	w[1][1]=5;w[1][2]=-1;w[1][3]=-2;w[1][4]=-1;w[1][0]=-3;
	w[2][1]=-1;w[2][2]=5;w[2][3]=-3;w[2][4]=-2;w[2][0]=-4;
	w[3][1]=-2;w[3][2]=-3;w[3][3]=5;w[3][4]=-2;w[3][0]=-2;
	w[4][1]=-1;w[4][2]=-2;w[4][3]=-2;w[4][4]=5;w[4][0]=-1;
	w[0][1]=-3;w[0][2]=-4;w[0][3]=-2;w[0][4]=-1;
	scanf("%d",&n1);
	getchar();
	for(i=1;i <= n1;i++){
		g=getchar();
		a[i]=t[g];	
	}
	getchar();
	scanf("%d",&n2);
	getchar();
	for(i=1;i <= n2;i++){
		g=getchar();
		b[i]=t[g];	
	}
	if(n2 > n1){
		swap(n1,n2);
		swap(a,b);
	}
	for(i=1;i <= n1;i++)
		for(j=1;j <= n2;j++)	f[i][j]=-INF;
	for(i=1;i <= n1;i++)	p[i]=p[i-1]+w[a[i]][0];
	for(i=1;i <= n2;i++)	s[i]=s[i-1]+w[b[i]][0];
	for(i=1;i <= n1;i++)	f[i][1]=p[i-1]+w[a[i]][b[1]];
	for(i=1;i <= n2;i++)	f[1][i]=s[i-1]+w[a[1]][b[i]];
	for(i=2;i <= n1;i++){
		for(j=2;j <= n2;j++){
			for(k=1;k <= i-1;k++)
				if(f[k][j-1] != -INF && f[k][j-1]+p[i-1]-p[k]+w[a[i]][b[j]] > f[i][j])
					f[i][j]=f[k][j-1]+p[i-1]-p[k]+w[a[i]][b[j]];
			for(k=1;k <= j-1;k++)
				if(f[i-1][k] != -INF && f[i-1][k]+s[j-1]-s[k]+w[a[i]][b[j]] > f[i][j])
					f[i][j]=f[i-1][k]+s[j-1]-s[k]+w[a[i]][b[j]];
		}
	}
	ans=-INF;
	for(i=1;i <= n1;i++)
		if(f[i][n2] != -INF && f[i][n2]+p[n1]-p[i] > ans)
			ans=f[i][n2]+p[n1]-p[i];
	for(i=1;i <= n2;i++)
		if(f[n1][i] != -INF	&& f[n1][i]+s[n2]-s[i] > ans)
			ans=f[n1][i]+s[n2]-s[i];
	printf("%d",ans);
	return 0;
}
```

---

## 作者：肖恩Sean (赞：2)

似乎没有用记忆化搜索的

来一发记忆化搜索

~~记忆化搜索可以做大部分DP题（不行我不负责啊）~~

贴心的为看不懂的蒟蒻提供了可选替换
```cpp
#include<bits/stdc++.h>
#define For(i,l,r) for(register int i=(l);(((l)<=(r))?i<=(r):i>=(r));i+=((l)<=(r))?1:-1)
//宏定义For,这个For自动支持从大到小和从小到大
//缺点，如果l和r的大小关系在循环过程中变化了就可能影响i的判定
//看不懂的在以下程序中所有形如For(i,l,r)的看做for(int i=l;i<=r;++i)即可 
using namespace std;
const int N=1e2+9;
const int score[5][5]={	{5,-1,-2,-1,-3},
						{-1,5,-3,-2,-4},
						{-2,-3,5,-2,-2},
						{-1,-2,-2,5,-1},
						{-3,-4,-2,-1,0}};
int la,lb;
int f[N][N],a[N],b[N];
bool vis[N][N]={0};
string s;
int read(){//读入优化,看不懂直接省略即可
	int x=0;bool f=0;char c=getchar();
	while (c<'0'||c>'9'){if (c=='-')f=!f;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return f?-x:x;
}
int dp(int i,int j){//记忆化搜索 
	if(vis[i][j]) return f[i][j];
	vis[i][j]=1;//标记已被搜索过 
	f[i][j]=max(f[i][j],dp(i-1,j-1)+score[a[i]][b[j]]);
	f[i][j]=max(f[i][j],dp(i-1,j)+score[a[i]][4]);
	f[i][j]=max(f[i][j],dp(i,j-1)+score[4][b[j]]);
	return f[i][j];
}
int get(char c){
	if(c=='A') return 0;
	if(c=='C') return 1;
	if(c=='G') return 2;
	if(c=='T') return 3;
}
int main(){
	memset(f,128,sizeof(f));//初始化f数组 
	la=read();cin>>s;//= cin>>la>>s; 
	For(i,1,la) a[i]=get(s[i-1]);
	lb=read();cin>>s;//= cin>>lb>>s;
	For(i,1,lb) a[i]=get(s[i-1]);
	//初始化边界
	vis[0][0]=1;f[0][0]=0;
	For(i,1,la){vis[i][0]=1;f[i][0]=f[i-1][0]+score[a[i]][4];}
	For(i,1,lb){vis[0][i]=1;f[0][i]=f[0][i-1]+score[b[i]][4];}
	printf("%d\n",dp(la,lb));
	return 0;
}

```

---

## 作者：ShineEternal (赞：1)

# 题目：https://www.luogu.org/problemnew/show/P1140

# [代码在此](https://blog.csdn.net/kkkksc03/article/details/83278082)

# 分析：

本题一看就知道是一道动归，其实和字串距离非常的像，只不过多了题目规定的匹配相似度罢了。

## 匹配的相似度我们之间用一个二维数组读入即可
```
int shuzu[6][6]={{0,0,0,0,0,0},{0,5,-1,-2,-1,-3},{0,-1,5,-3,-2,-4},{0,-2,-3,5,-2,-2},{0,-1,-2,-2,5,-1},{0,-3,-4,-2,-1,0}};
```

PS:换行效果更佳。

## 然后要把字符串转化成刚才数组中的下标，便于读写
```
int start(char c)
{
	if(c=='A')return 1;
	if(c=='C')return 2;
	if(c=='G')return 3;
	if(c=='T')return 4;
}
```
然后直接在主函数中调用即可
## 之后就是调用问题
```
for(int i=0;i<n;i++)
	{
		a[i+1]=start(s1[i]);
	}
	for(int j=0;j<m;j++)
	{
		b[j+1]=start(s2[j]);
	}
```
其中s1，s2均为读入的字符串，我们把它们分别逐字符转化放入a，b数组。

# 然后由于有负值出现，我们需要把动归的核心方程初始化为一个极小的负数
```
for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			f[i][j]=-2147483647;
		}
	}
```

然后就是关键的动归核心部分了。

首先，看到数据范围：100

受到启发：二位数组开的起，再加上字串距离的引导，我们很容易想到$f[i][j]$可以表示第一个字符串的前i个字符与第二个字符串的前j个字符匹配的最大值。

状态想出来，那么方程如何转移呢？

根据可以加入空碱基，我们能想到

$f[i][j]=max(f[i][j],f[i-1][j]+shuzu[a[i]][5],f[i][j-1]+shuzu[b[j]][5],f[i-1][j-1]+shuzu[a[i]][b[i]]$
分别是s1串的最后一个字符对应一个空字符，s2串的最后一个字符对应一个空字符，s1串个s2串的最后一个字符直接对应。

显而易见的，初始化f数组就是
```
for(int i=1;i<=n;i++)f[i][0]=f[i-1][0]+shuzu[a[i]][5];
for(int i=1;i<=m;i++)f[0][i]=f[0][i-1]+shuzu[b[i]][5];
```

然后把它们拼凑起来，就完工喽！

完结撒花~



---

## 作者：Drinkwater (赞：1)

就跟楼下说的一样，这道题的DP跟最长公共子序列的dp方程特别像·dp[i][j]表示第一个串到了i，第二个串到了j最大的相似度，这样就可以从三种方向递推，但最主要的是边界的处理，dp[i][j] = max(dp[i-1][j-1]+..,, , dp[i-1][j]+... , dp[i][j-1]+.... );没有C和C++的题解，就来发一波。

/*************************************************************************

    > Author: Drinkwater-cnyali
    > Created Time: 2017/6/6 17:08:18
************************************************************************/











```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
const int maxn = 100000;
const int inf = 0x3f3f3f3f;
int num[200][200];
int dp[200][200];
int n,m;
char s[200],p[200];
int main()
{
    num['A']['A'] = 5,num['A']['C'] = -1,num['A']['G'] = -2,num['A']['T'] = -1,num['A']['-'] = -3;
    num['C']['A'] = -1,num['C']['C'] = 5,num['C']['G'] = -3,num['C']['T'] = -2,num['C']['-'] = -4;
    num['G']['A'] = -2,num['G']['C'] = -3,num['G']['G'] = 5,num['G']['T'] = -2,num['G']['-'] = -2;
    num['T']['A'] = -1,num['T']['C'] = -2,num['T']['G'] = -2,num['T']['T'] = 5,num['T']['-'] = -1;
    num['-']['A'] = -3,num['-']['C'] = -4,num['-']['G'] = -2,num['-']['T'] = -1,num['-']['-'] = 0x3f3f3f3f;
    n = read(),scanf("%s",s+1);
    m = read(),scanf("%s",p+1);
    memset(dp,-127,sizeof(dp));
    dp[0][0] = 0;
    REP(i,1,n)
    {
        int x = s[i];
        dp[i][0] = dp[i-1][0]+num[x]['-'];
    }
    REP(i,1,m)
    {
        int x = p[i];
        dp[0][i] = dp[0][i-1]+num[x]['-'];
    }
    REP(i,1,n)
    {
        REP(j,1,m)
        {
            int x = s[i],y = p[j];
            dp[i][j] = max(dp[i-1][j]+num[x]['-'],dp[i][j]);
            dp[i][j] = max(dp[i-1][j-1]+num[x][y],dp[i][j]);
            dp[i][j] = max(dp[i][j-1]+num['-'][y],dp[i][j]);
        }
    }
    cout<<dp[n][m]<<endl;
    return 0;
}

```

---

## 作者：Dispwnl (赞：0)

用二维数组f储存第1个基因前i个与第2个基因前j个的最大匹配值

先将字符串转化为数组储存

将f初始化为一个很小的值

因为第1个基因前i个与第2个基因第0个匹配肯定是与空碱基匹配的值

所以初始化：

```cpp
for(int i=1;i<=n;i++)
f[i][0]=f[i-1][0]+gene[s1[i]][4];
for(int i=1;i<=m;i++)
f[0][i]=f[0][i-1]+gene[s2[i]][4];
```
状态转移方程：
```cpp
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
{
        f[i][j]=max(f[i][j],f[i][j-1]+gene[s2[j]][4]);
```
第1个基因加1个空碱基
        f[i][j]=max(f[i][j],f[i-1][j]+gene[s1[i]][4]);

第2个基因加1个空碱基

        f[i][j]=max(f[i][j],f[i-1][j-1]+gene[s1[i]][s2[j]]);

都不加



    }
输出f[n][m]

```cpp
# include<iostream>
using namespace std;
int n,m;
string a,b;
int f[101][101];
int s1[101],s2[101];
int gene[5][5]=
{{5,-1,-2,-1,-3},
 {-1,5,-3,-2,-4},
 {-2,-3,5,-2,-2},
 {-1,-2,-2,5,-1},
 {-3,-4,-2,-1,0}};
int main()
{
    cin>>n>>a>>m>>b;
    for(int i=1;i<=n;i++)
      {
          if(a[i-1]=='C') s1[i]=1;
          if(a[i-1]=='G') s1[i]=2;
          if(a[i-1]=='T') s1[i]=3;
      }
    for(int i=1;i<=m;i++)
      {
          if(b[i-1]=='C') s2[i]=1;
          if(b[i-1]=='G') s2[i]=2;
          if(b[i-1]=='T') s2[i]=3;
      }
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        f[i][j]=-999999; 
    for(int i=1;i<=n;i++)
      f[i][0]=f[i-1][0]+gene[s1[i]][4];
    for(int i=1;i<=m;i++)
      f[0][i]=f[0][i-1]+gene[s2[i]][4];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i][j],f[i][j-1]+gene[s2[j]][4]);
            f[i][j]=max(f[i][j],f[i-1][j]+gene[s1[i]][4]);
            f[i][j]=max(f[i][j],f[i-1][j-1]+gene[s1[i]][s2[j]]);
        }
    cout<<f[n][m];
    return 0;
}

```

---

## 作者：s_h_y (赞：0)

这题其实没有题解说的那么麻烦。。就是一道简单DP,f[i,j]可从f[i-1,j-1],f[i-1,j],f[i,j-1]转移过来。



```cpp
const
 g:array[1..5,1..5]of longint=((5,-1,-2,-1,-3),
                               (-1,5,-3,-2,-4),
                               (-2,-3,5,-2,-2),
                               (-1,-2,-2,5,-1),
                               (-3,-4,-2,-1,0));
var
 n,m,i,j:longint;
 c:char;
 a,b:array[0..105]of longint;
 f:array[0..105,0..105]of longint;
procedure max(var a:longint;b:longint);
begin if a<b then a:=b end;
begin
 assign(input,'1140.in'); reset(input);
 assign(output,'1140.out'); rewrite(output);
 read(n,c);
 for i:=1 to n do
 begin
  read(c);
  case c of
   'A':a[i]:=1;
   'C':a[i]:=2;
   'G':a[i]:=3;
   'T':a[i]:=4
  end
 end;
 read(m,c);
 for i:=1 to m do
 begin
  read(c);
  case c of
   'A':b[i]:=1;
   'C':b[i]:=2;
   'G':b[i]:=3;
   'T':b[i]:=4
  end
 end;
 fillchar(f,sizeof(f),$bf);
 f[0,0]:=0;
 for i:=1 to n do f[i,0]:=f[i-1,0]+g[a[i],5];
 for i:=1 to m do f[0,i]:=f[0,i-1]+g[b[i],5];
 for i:=1 to n do
 for j:=1 to m do
 begin
  max(f[i,j],f[i-1,j-1]+g[a[i],b[j]]);
  max(f[i,j],f[i-1,j]+g[a[i],5]);
  max(f[i,j],f[i,j-1]+g[5,b[j]])
 end;
 write(f[n,m]);
 close(input); close(output)
end.
```

---

## 作者：courage (赞：0)

这题看起来有点像最长公共子序列，于是可以用类似于最长公共子序列的方法做。

由于-与-的对应没有意义，所以生成的DNA序列长度最大为200。


f[i][j][k]表示s[1..i]和t[1..j]变成长度为k的序列时的最大相似度，

[color=red]**f[i][j][k]=max{f[i-1][j][k-1]+d(s[i],'-'),f[i][j-1][k-1]+d(t[j],'-'),f[i-1][j-1][k-1]+d(s[i],t[j])}

要特别注意边界与循环范围等细节**[/color]


附上源码(pascal)


```delphi

var
  s,t,ss:string;
  f:array[0..100,0..100,0..200] of longint;
  n,i,j,k,p,ans:longint;
function max(a,b:longint):longint;
begin
  max:=a;
  if a<b then max:=b;
end;
function d(a,b:char):longint;
begin
  if (a='-')and(b='-') then exit(-1000);
  if a=b then exit(5);
  case a of
    'A':case b of
          'C','T':exit(-1);
          'G':exit(-2);
          '-':exit(-3);
        end;
    'C':case b of
          'A':exit(-1);
          'G':exit(-3);
          'T':exit(-2);
          '-':exit(-4);
        end;
    'G':case b of
          'A','T','-':exit(-2);
          'C':exit(-3);
        end;
    'T':case b of
          'A','-':exit(-1);
          'C','G':exit(-2);
        end;
    '-':case b of
          'A':exit(-3);
          'C':exit(-4);
          'G':exit(-2);
          'T':exit(-1);
        end;
  end;
end;
begin
  readln(ss);
  s:='';
  for i:=1 to length(ss) do if ss[i] in ['A','C','G','T'] then s:=s+ss[i];
  readln(ss);
  t:='';
  for i:=1 to length(ss) do if ss[i] in ['A','C','G','T'] then t:=t+ss[i];
  fillchar(f,sizeof(f),200);
  f[0,0,0]:=0;
  for i:=0 to length(s) do
    for j:=0 to length(t) do
      if i+j>0 then
        for k:=max(i,j) to i+j do
          begin
            if i=0 then f[i,j,k]:=f[i,j-1,k-1]+d('-',t[j]);
            if j=0 then f[i,j,k]:=f[i-1,j,k-1]+d('-',s[i]);
            if i*j>0 then
              begin
                if k-1>=max(i-1,j) then f[i,j,k]:=max(f[i,j,k],f[i-1,j,k-1]+d(s[i],'-'));
                if k-1>=max(i,j-1) then f[i,j,k]:=max(f[i,j,k],f[i,j-1,k-1]+d(t[j],'-'));
                if k<=i+j-1 then f[i,j,k]:=max(f[i,j,k],f[i-1,j-1,k-1]+d(s[i],t[j]));
              end;
          end;
  ans:=-maxlongint;
  for i:=max(length(s),length(t)) to length(s)+length(t) do
    if ans<f[length(s),length(t),i] then ans:=f[length(s),length(t),i];
  writeln(ans);
  readln;
end.

```

---


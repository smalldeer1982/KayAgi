# [GESP202503 六级] 环线

## 题目描述

小 A 喜欢坐地铁。地铁环线有 $n$ 个车站，依次以 $1,2,\cdots,n$ 标号。车站 $i\ (1\leq i<n)$ 的下一个车站是车站 $i+1$。特殊地，车站 $n$ 的下一个车站是车站 $1$。

小 A 会从某个车站出发，乘坐地铁环线到某个车站结束行程，这意味着小 A 至少会经过一个车站。小 A 不会经过一个车站多次。当小 A 乘坐地铁环线经过车站 $i$ 时，小 A 会获得 $a_i$ 点快乐值。请你安排小 A 的行程，选择出发车站与结束车站，使得获得的快乐值总和最大。

## 说明/提示

对于 $20\%$ 的测试点，保证 $1\leq n\leq 200$。

对于 $40\%$ 的测试点，保证 $1\leq n\leq 2000$。

对于所有测试点，保证 $1\leq n\leq 2\times 10^5$，$-10^9\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
4
-1 2 3 0```

### 输出

```
5```

## 样例 #2

### 输入

```
5
-3 4 -5 1 3```

### 输出

```
5```

# 题解

## 作者：qwqerty (赞：24)

提供一个空间复杂度 $O(1)$ 的做法。
# 解题思路
本题可以分为两种情况考虑
- 跨环情况：看做从车站 $1$ 坐到车站 $x$，再从车站 $x$ 坐到车站 $n$。也就是说 $x+1$ 至 $y-1$ 的部分是没有坐到的。我们想让坐到的部分最大化，就要让没坐到的部分最小化。求出原序列的最小子段和，再用总和减去即可。这一部分的空间复杂度可以做到 $O(1)$。
- 不跨环情况：相当于直接求最大子段和。这一部分的空间复杂度也是 $O(1)$ 的。

将上面两种情况综合起来，也就是求它们的最小值，就能得到最终答案。  
注意特判全是负数的情况，不然会得到 [$70$ 分](https://www.luogu.com.cn/record/209814675)。
# AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t, n, maxdp, mindp, sum, minn = LLONG_MAX, maxx = LLONG_MIN, maxn = LLONG_MIN;
signed main() {
	cin >> t;
	while (t--) {
		cin >> n;
		sum += n;
		maxn = max(maxn, n);
		maxdp = max(n, maxdp + n);
		maxx = max(maxdp, maxx);
		mindp = min(n, mindp + n);
		minn = min(mindp, minn);
	}
	if (maxn < 0) cout << maxn;
	else cout << max(sum - minn, maxx);
	return 0;
}
```

---

## 作者：AuZeb (赞：17)

## 思路

本问题相当于求环上最大子段和，但是发现如果破环成链的话可能会出错，例如 `-1 2` 破环成链后为 `-1 2 -1 2`，答案就为 `3` 了。

换种方法，将其分为两个部分，选的部分与不选的部分，显然，两个部分都是连续的，且一定有一个部分在头和尾之间（即相当于在 $1$ 到 $n$ 之间），那么就只有两种情况。

- 在 $1$ 到 $n$ 之间的是选的部分，直接求最大区间子段和。

- 在 $1$ 到 $n$ 之间的是不选的部分，求总和减去最小子段和。

最后需要注意的是，至少经过一个车站，所以如果全为负数的情况下，需输出最大负数。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
long long a[200005],h=0,fax[200005],fin[200005], // 最大子段和与最小子段和
		  ans=-0x3f3f3f3f,mmax=-0x3f3f3f3f; 
int main(){
	int n; cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],h+=a[i],mmax=max(mmax,a[i]),
		fax[i]=max(a[i],fax[i-1]+a[i]),fin[i]=min(a[i],fin[i-1]+a[i]);
	for(int i=1;i<=n;i++) ans=max(ans,max(fax[i],h-fin[i]));
	cout<<(ans==0?mmax:ans); return 0;
}
```

---

## 作者：lly66666 (赞：14)

简单的动态规划题。

我们用两个数组 $maxn$ 和 $minn$ 来存储当前开心值的最大值和最小值，我们不难推出状态转移方程：


```cpp
maxn[i] = max(maxn[i - 1] + a[i], a[i]);
minn[i] = min(minn[i - 1] + a[i], a[i]);
```
然后就能得出最后代码了：


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, maxn[1000005], minn[1000005], ans = -1e18, a[1000005], num, mina = -1e18;
bool flag = false;
signed main() {
    memset(maxn, -0x3f, sizeof(maxn));
    memset(minn, 0x3f, sizeof(minn));
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        cin >> a[i];
        maxn[i] = max(a[i], maxn[i - 1] + a[i]);
        minn[i] = min(a[i], minn[i - 1] + a[i]);
        num += a[i]; mina = max(mina, a[i]);
        if(a[i] > 0) flag = true;
    }
    for(int i = 1; i <= n; i ++) {
        ans = max(ans, max(maxn[i], num - minn[i]));
    }
    if(!flag) cout << mina;
    else cout << ans;
    return 0;
}
```

记得开 long long！

完结撒花！

管理员大大大大大大大大大大大大大大大求过。

---

## 作者：FJ_EYoungOneC (赞：8)

### 解题思路

原题链接：[P11963  环线](https://www.luogu.com.cn/problem/P11963)。

本题为 [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115) 的环形版。

---

答案有两种情况：

1. 最大子段和的起点 $l$ 不大于终点 $r$，相当于 P1115 的问题。
2. 最大子段和的起点 $l$ 大于终点 $r$，即 $[l, n] \cup [1, r]$。

考虑情况一：

考虑动态规划，定义 $f_i$ 表示以 $a_i$ 结尾的**最大子段和**。

那么动态转移方程为 $f_i = \max(f_{i - 1}, 0) + a_i$。

考虑情况二：

要求解 $[l, n] \cup [1, r]$ 的最大值，可以使用前缀和、递推和枚举求解。

要使得 $[l, n] \cup [1, r]$ 最大，可以求解 $[r + 1, l - 1]$ 最小，那么问题转换为求解**最小子段和**，用数组 $a$ 的总和减去最小子段和即表示情况二的答案。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

typedef long long LL;

const int N = 2e5 + 10;

int n;
int a[N];
LL f[N];

LL get_max()
{
	for (int i = 1; i <= n; ++ i )
		f[i] = max((LL)0, f[i - 1]) + a[i];
	return *max_element(f + 1, f + n + 1);
}

LL get_min()
{
	for (int i = 1; i <= n; ++ i )
		f[i] = min((LL)0, f[i - 1]) + a[i];
	return *min_element(f + 1, f + n + 1);
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n;

	LL s = 0;
	int t = -1e9;
	for (int i = 1; i <= n; ++ i )
	{
		cin >> a[i];
		s += a[i];
		t = max(t, a[i]);
	}
	
	if (t <= 0)
	{
		cout << t << '\n';
		return 0;
	}
	
	LL mx = get_max(), mn = get_min();

	cout << max(mx, s - mn) << '\n';

	return 0;
}
```

---

## 作者：DeepSleep_Zzz (赞：7)

**begin**

[P11963 [GESP202503 六级] 环线](https://www.luogu.com.cn/problem/P11963)

#### 前言（渺小）

---

考试的时候打了一个超级无敌大歪解，个人认为漏洞百出，但是还是成功的骗到了 $90\%$ 的分数。（大概是数据的锅。？）

考后看到标签后恍然大悟，造就了这篇题解。

另：不会单调队列的可以去看看 [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)。

# 思路

我们简化一下题目：截取一个长度 $\le n$ 的序列，使它的和最大。

那么众所周知，如果要让和最大，那么减掉的就越少越好。

所以我们可以先求出破环成链后的 $a$ 数组的前缀和 $sum$ 数组，然后对于每一个 $1\le i \le 2n$ 在确保长度不超过 $n$ 的情况下，减掉一个最小的前缀和，最后取最大值即可。

针对上述思路，单调队列简直再合适不过了。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const ll N=4e5+10;
ll n,a[N],sum[N],q[N],head=1,tail,ans=-1e10;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    // 破环成链
    for (ll i=1;i<=n;i++) cin>>a[i],a[i+n]=a[i];
    // 前缀和
    for (ll i=1;i<=n*2;i++) sum[i]=sum[i-1]+a[i];
    // 单调队列
    for (ll i=1;i<=n*2;i++)
    {
    	while (head<=tail && i-q[head]>n) head++; // 确保区间长度合法
    	while (head<=tail && sum[q[tail]]>=sum[i]) tail--; // 构造递增队列的
    	ans=max(ans,sum[i]-sum[q[head]]); // 取最大值
        q[++tail]=i; // 扔进去
    }
    cout<<ans;
    return 0;
}
```

**end**

---

## 作者：prh_rpjiajia (赞：6)

这题真的~~水~~。

## 思路
#### 形式化题意
对于一个环，求他的最大字段和。

#### 推导
首先，对于一个环，如下图:
![](https://cdn.luogu.com.cn/upload/image_hosting/38zvais2.png)

我们可以将他从某一条边分开，从而变成一个序列。

- 从 `1` 和 `2` 之间分，序列变成 `1 0 -4 2 -1 4 3 2`。
- 从 `2` 和 `3` 之间分，序列变成 `2 1 0 -4 2 -1 4 3`
- .....

我们要在环上选起点和终点，假设我们选择 $l=2,r=-1$ 的节点，在环上表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/6rk37a8g.png)

我们把他表示到序列上，如序列为 `2 1 0 -4 2 1 4` 的情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/mw9hgntl.png)

发现，如果要选取一段，只有两种情况:
1. 选的在序列中间
2. 选的不在序列中间，观察可知，这种一定是序列的前缀和后缀拼在一起的。

所以，我们只要对这两种，都求出最大值，最后取个 `max` 就可以了。

定义 $f1_i$ 表示前 $i$ 个中最大的前缀和，$f2_i$ 表示后 $i$ 个中最大的后缀和，预处理出 $f1,f2$，即可避免重复。

最后，在对这个序列，跑一遍最大子段和，取个 `max` 就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int f1[200005],f2[2000005],a[200005];
signed main()
{
    int n;
    cin>>n;
    for (int i=1;i<=n;++i)cin>>a[i];
    int sum=0,maxn=-1e9;
    for (int i=1;i<=n;++i)
    {
        sum+=a[i];
        maxn=max(maxn,sum);
        f1[i]=maxn;
    }
    sum=0,maxn=-1e9;
    for (int i=n;i>=1;--i)
    {
        sum+=a[i];
        maxn=max(maxn,sum);
        f2[i]=maxn;
    }
    int cnt=-1e9;//第一种情况的最大值
    sum=0;
    for (int i=1;i<=n;++i)
    {
        if (sum<0)sum=a[i];
        else sum+=a[i];
        cnt=max(cnt,sum);
    }
    int cnt2=-1e9;//第二种情况的最大值
    for (int i=1;i<=n;++i)
    {
        cnt2=max(max(cnt2,f1[i]+f2[i+1]),f1[i-1]+f2[i]);
    }
    cout<<max(cnt,cnt2);
    return 0;
}
```
最后提醒一句，不要忘了开 `long long`。

---

## 作者：xu_zhihao (赞：5)

### 题目思路

- 复制一遍 $a$ 数组，然后处理前缀和。单调队列模板求出当前位置 $i$ 的前 $n$ 个位置的最小前缀和的位置，记为 $id_i$，然后枚举 $2 \times n$ 个位置。每个位置更新 $mx=\max(mx,sum_i-sum_{id_i})$，最后的答案即为 $mx$。注意刚开始要在单调队列中放入 $0$ 元素。

### AC 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int id;
	long long sum;
};
long long sum[400010];
long long a[400010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(int i=1;i<=2*n;i++){
		sum[i]=sum[i-1]+a[i]; 
	}
	deque<node>q;
	q.push_back({0,0});
	long long mx=-1e18;
	for(int i=1;i<=2*n;i++){
		while(!q.empty() && i-(q.front()).id>n){
			q.pop_front();
		}
		mx=max(mx,sum[i]-(q.front()).sum);
		while(!q.empty() && (q.back()).sum>sum[i]){
			q.pop_back();
		}
		q.push_back({i,sum[i]});
	}
	cout<<mx;
	return 0;
} 
```

---

## 作者：dg114514 (赞：2)

萌新表示就自己用的是 RMQ 优化暴力吗。\
首先，考虑暴力。（先假设 $a$ 的长度为 $2n$，对于 $1\le i \le n$，有 $a_{n+i}=a_n$）可以很快得出答案是 $\max\limits_{i=1}^n\{\max\limits_{j=i}^{n+i}\{\sum\limits_{k=i}^{j} a_k\}\}$（其实就是枚举出所有子段和，然后取最大值。）\
但是这样是 $O(n^3)$ 的，只能拿到 $20$ 分。考虑前缀和优化，令 $sum_i=\sum^i_{j=1} a_j$。可以发现优化的柿子为 $\max\limits_{i=1}^n\{\max\limits_{j=i}^{n+i}\{sum_j-sum_{i-1}\}\}$。然后发现 $j$ 这一维可以使用 RMQ 算法来解决，但是 $sum_{i-1}$ 有点难处理。所以可以把它放到 $j$ 维外面来。最后，变成 $\max\limits_{i=1}^n\{RMQ(i,n+i)-sum_{i-1}\}\}$，最后 RMQ 可以用 ST 表 or 线段树 or 单调队列。

### 展示 1KB 的长代码（ST 表）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[400005],sum[400005];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
class SparseTable{
	private:
		int st[400010][25];
		int lg[400010];
	public:
		void build(int* a,int n){
			memset(st,-0x3f,sizeof st);
			lg[1]=0,st[1][0]=a[1];
			for(int i=2;i<=n;i++)
				st[i][0]=a[i],lg[i]=lg[i>>1]+1;
			for(int j=1;j<=lg[n];j++)
				for(int i=1;i+(1<<j)-1<=n;i++)
					st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
		inline int query(int l,int r){
			int k=lg[r-l+1];
			return max(st[l][k],st[r-(1<<k)+1][k]);
		}
}st;
signed main(){
	int n,q,x,op,y,ans=-1e18;
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i];//前缀和
	for(int i=1;i<=n;i++)sum[i+n]=sum[i+n-1]+a[i];//环
	st.build(sum,n*2);//build ST 表
	for(int i=1;i<=n;i++)
		ans=max(ans,st.query(i,n+i)-sum[i-1]);//柿子部分
	cout<<ans;
}
```

复杂度 $O(n \log n)$。单调队列可以优化至 $O(n)$。\
至于单调队列或线段树方法，~~我不是很熟悉它们~~由读者自行完成。

---

## 作者：aaalys (赞：2)

# P11963 [GESP202503 六级] 环线 题解

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P11963)

给出一个环，每个点有一个权值。可以取出其中连续的一段（最少取 1 个），问能获得的最大权值和。

## 思路

不难发现，答案只有可能是以下一种情况之一。

1. 取 $a_l\sim a_r(l \le r)$，和为 $\sum_{i=l}^{r}a_i$。
2. 取 $a_1\sim a_r$ 及 $a_l\sim a_n(r < l)$，和为 $\sum_{i=1}^{r}a_i+\sum_{i=l}^{n}a_i$。

情况一就是普通的最大子段和（不会的右转 [P1115](https://www.luogu.com.cn/problem/P1115)），只有情况二这种情况需要额外的处理。

### 情况二额外的处理

在情况二的求和式子中，$\sum_{i=1}^{r}a_i$ 为前缀和，$\sum_{i=l}^{n}a_i$ 为后缀和。

那可以记 $pre_i=\sum_{j=1}^{r}a_j, suf_i=\sum_{j=i}^{n}a_j$，求和式子变成了 $pre_r+suf_l$。

现在原问题变成了找到 $l,r(r<l)$，使得 $pre_r+suf_l$ 最大，求这个最大的 $pre_r+suf_l$。

对于 $r<l$ 这个条件，可以选择一个 $1 < k \le n$，在 $1\sim k - 1$ 中选择 $r$，在 $k\sim n$ 中选择 $l$。

对于 $r$ 和 $l$，可以选择在满足条件时，$pre_r$ 最大的 $r$ 和 $suf_l$ 最大的 $l$。

对于选择，还可以令 $premx_i=\max\limits_{j=1}^{i}pre_j,sufmx_i=\max\limits_{j=i}^{n}suf_j$。

这样选择最大的 $r$ 和 $l$ 可以用 $premx$ 和 $sufmx$ 解决。

### 答案

在 $1\sim k - 1$ 中选择 $r$ 的答案为 $premx_{k-1}$，在 $k\sim n$ 中选择 $l$ 的答案为 $sufmx_k$。

最终答案别忘了算上情况一 (普通的最大子段和)。

最终答案为 $\max( \max 1,\max\limits_{k=2}^{k=n}premx_{k-1}+sufmx_k)$（其中 $\max 1$ 表示情况一的答案）。

## 代码实现

### 细节及小技巧

在我构造样例时发现，$a_i$ 有可能全部都是负数，所以需要对答案 $ans$，$premx$ 和 $sufmx$ 初始化为 $-\inf$。

这里有两个小技巧。

1. 可以先计算 $premx$ 和 $sufmx$，再计算情况一的答案时顺便计算情况二的答案。

2. 把 $pre$ 和 $premx$ 一起算，$suf$ 和 $sufmx$ 一起算。

这两个技巧可以节省一些时间和代码长度。

### Code

只展示关键代码。

```cpp
ll ans, a[N], f[N], pre[N], suf[N], premx[N], sufmx[N];//f[i]是最大子段和的dp数组
for (int i = 1; i <= n; i++){//计算pre和premx。
	pre[i] = pre[i - 1] + a[i];
	premx[i] = max(premx[i - 1], pre[i]);
}
for (int i = n; i; i--){//计算suf和sufmx
	suf[i] = suf[i + 1] + a[i];
	sufmx[i] = max(sufmx[i + 1], suf[i]);
}
for (int i = 1; i <= n; i++){
	f[i] = max(0ll, f[i - 1]) + a[i];//dp转移
	ans = max(max(ans, f[i]), premx[i - 1] + sufmx[i]);
    //把情况一和情况二一起算。
}
```

## 后记

求管理员通过

我构造了几组数据，大家可以参考：

```data
Data #1:
input:
3
-2 -3 -1
ans:-1
Data #2:
input:
4
5 -3 6 7
ans:18
Data #3:
input:
4
3 5 2 4
ans:14
Data #4:
input:
4
4 -6 6 -3
ans:7
```

---

## 作者：five_rice_water (赞：2)

六级考生前来报到。

这道题第一反应是环形的最大字段和，所以第一反应是动态规划，但是环形的最大子段和和普通的有点区别，区间长度必须是 $n$，所以就不想推。

于是就想到了第二种方法。

首先破环成链，然后求个前缀和。

其次对于每一个 $i$，从 $i$ 出发可以得到的最大字段和是当前这个前缀和减去前面 $n$ 个数的最小值。

注意一下边界处理就行了，左端点最小值是 $0$。

至于维护一个长度为 $n$ 的区间的最小值，这道题可以用你能想到的任何方法，下面给出代码，但是因为逻辑非常简单，建议自己写一写。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+5;
int n,a[N<<1],sum[N<<1],st[N<<1][25],lg[N<<1];
int query(int l,int r){
	int tmp = lg[r-l+1];
	return min(st[l][tmp],st[r-(1<<tmp)+1][tmp]);
}
signed main(){
	cin>>n;
	st[0][0] = 0;
	for(int i = 2; i<=(n<<1); i++){
		lg[i] = lg[i>>1]+1;
	}
	for(int i = 1; i<=n; i++){
		cin>>a[i];
		sum[i] = sum[i-1]+a[i];
		st[i][0] = sum[i];
	}
	for(int i = 1; i<=n; i++){
		sum[i+n] = sum[i+n-1]+a[i];
		st[i+n][0] = sum[i+n];
	}
	for(int i = 1; i<=24; i++){
		for(int j = 0; j+(1<<i)-1<=(n<<1); j++){
			st[j][i] = min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
		}
	}
	int ans = -9e18;
	for(int i = 1; i<=(n<<1); i++){
		ans = max(ans,sum[i]-query(max(0ll,i-n),i-1));
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：封禁用户 (赞：1)

考场上切了，写篇题解记录一下。

### 思路

这题就是典型的贪心。

先处理前后缀累加和 $pre_i$ 和 $suf_i$，把 $\max_{j=1}^i pre_j$ 记作 $bpre_i$，把 $\max_{j=i}^n suf_j$ 记作 $bsuf_i$。

先初始化 $now=0,\ ans=-\infty$，分两种情况：

- 不坐从 $n$ 到 $1$ 的线路。这种情况就使用贪心，对于 $1$ 到 $n$ 的每一个 $i$，使 $now=\max(now+a_i,a_i),\ ans=max(ans,now)$。
- 坐从 $n$ 到 $1$ 的线路。这种情况我们需要枚举开始车站和结束车站。枚举开始车站时，对于 $2$ 到 $n$ 的每一个 $i$，使 $ans=\max(ans,suf_i+bpre_{i-1})$，枚举结束车站时，对于 $1$ 到 $n-1$ 的每一个 $i$，使 $ans=\max(ans,pre_i+bsuf_{i+1})$。

最后 $ans$ 就是最优解。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
long long pre[200005],presum[200005],sfu[200005],sfusum[200005];
long long a[200005],n,mxs,ans=-1145141919,ans2=-1145141919;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)pre[i]=pre[i-1]+a[i],presum[i]=max(pre[i],presum[i-1]);
    for(int i=n;i>0;i--)sfu[i]=sfu[i+1]+a[i],sfusum[i]=max(sfu[i],sfusum[i+1]);
    for(int i=1;i<=n;i++)mxs=max(mxs+a[i],a[i]),ans=max(ans,mxs),ans2=max(ans2,max(pre[i]+sfusum[i+1],sfu[i]+presum[i-1]));
    cout<<max(ans,ans2)<<endl;
}
```

---

## 作者：__CrossBow_EXE__ (赞：1)

# 前言

提供一种考场上想到的线段树乱搞解法。

# 题目简介

一个环上有 $n$ 个点，第 $i$ 个点权值为 $a_i$，当你来到一个点，就能取得这个点的权值。问：在最多绕一圈（经过 $n$ 个点）的情况下所能取到的最多的权值。

# 题解

先考虑暴力做法：

先断环为链，并维护一个前缀和数组 $sum$，枚举两个点 $i,j$，保证 $1 \le i < j \le 2n$，找出 $sum_j-sum_i$ 的最大值即可。时间复杂度 $O(n^2)$。

这样显然会超时。考虑优化：

不难看出，在 $sum_i$ 一定时，$sum_j$ 越大，结果就越大，也就越有可能冲击最优解。又因为 $i < j \le 2n$，所以 $sum_j-sum_i$ 的最大值就是 $\max_{i < j \le 2n} sum_j -sum_i$。于是问题就变成了寻找区间最大值，可以用线段树在 $O(\log n)$ 的时间内解出。这样，总的时间复杂度就变成了 $O(n \log n)$，可以通过。

最后还有一点：不要忘记开 `long long`！

---

## 作者：Lcm_simida (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P11963)

我们先设 $j$ 为起点，$i$ 为重点，$sum[x]$ 表示 $1$ 到 $x$ 的快乐值之和。

1. 当 $i>j$ 时，答案是 $sum[i]-sum[j]$，所以只要对于每个 $i$ 找到之前最小的 $sum[j]$ 即可。
2. 当 $i<j$ 时，答案是 $sum[n]-sum[i-1]+sum[j]$，所以只要对于每个 $i$ 找到之前最大的 $sum[j]$ 即可。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200005],sum[200005],minn=0,maxx=0,ans=-1e15-7;
int main(){
	ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);cin>>n;for(int i=1;i<=n;i++) cin>>a[i],sum[i]=sum[i-1]+a[i];
	for(int i=1;i<=n;i++){ans=max(ans,max(sum[i]-minn,sum[n]-sum[i-1]+maxx));minn=min(minn,sum[i]),maxx=max(maxx,sum[i]);}
	cout<<ans;
	return 0;
}

```

---


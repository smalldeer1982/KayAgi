# [GESP202503 七级] 图上移动

## 题目描述


小 A 有一张包含 $n$ 个结点与 $m$ 条边的无向图，结点以 $1, 2, \dots, n$ 标号。小 A 会从图上选择一个结点作为起点，每一步移动到某个与当前小 A 所在结点相邻的结点。对于每个结点 $i$ （$1 \leq i \leq n$），小 A 想知道从结点 $i$ 出发恰好移动 $1, 2, \dots, k$ 步之后，小 A 可能会位于哪些结点。由于满足条件的结点可能有很多，你只需要求出这些结点的数量。


## 说明/提示

**本题采用捆绑测试。**


对于 $20\%$ 的测试点，保证 $k = 1$。

对于另外 $20\%$ 的测试点，保证 $1 \leq n \leq 50, 1 \leq m \leq 50$。

对于所有测试点，保证 $1 \leq n \leq 500, 1 \leq m \leq 500, 1 \leq k \leq 20, 1 \leq u_i, v_i \leq n$。


## 样例 #1

### 输入

```
4 4 3
1 2
1 3
2 3
3 4```

### 输出

```
2 4 4
2 4 4
3 3 4
1 3 3```

# 题解

## 作者：piske (赞：11)

# [GESP202503 七级] 图上移动
## 思路：
遍历每一个点为起点，用深搜来找到每一步可以到达的点。并且使用数组存储防止重复访问。
```cpp
#include <bits/stdc++.h>
using namespace std;
int vis[510][25];  //vis（i，j）表示第i个节点是否在第j步被访问过
int n,m,k;
vector<int> g[510];
void dfs(int u,int step){
	if(vis[u][step]==1)	   //防止重复访问
		return ;
	vis[u][step]=1;
	if(step==k)
		return ;
	step++;
	for(int i=0;i<g[u].size( );i++)
		dfs(g[u][i],step); //遍历所有路径
}
int main( ){
	cin>>n>>m>>k;
	for(int j=0;j<m;j++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v); //存图
		g[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			for(int kk=0;kk<=k;kk++)
				vis[j][kk]=0; //初始化
		dfs(i,0); //以每个点为起点dfs
		for(int j=1;j<=k;j++){
			int ans=0;
			for(int kk=1;kk<=n;kk++)
				ans+=vis[kk][j]; //找到第j步可以访问的点的个数
			cout<<ans<<" ";
		}
		cout<<endl;
	}
最坏时间复杂度O（N*N*K）   （n轮dfs，每一轮最多访问N*K次节点）
	return 0;
}
```

---

## 作者：tuboshu666 (赞：5)

# 前言
本篇主要介绍本题的**分层图**做法，请确保在阅读本题解前，已对分层图有一定理解。

# 思路
由于 $k \leq 20$，可以建立分层图。

以样例为例（因为空间不足，本图只画到第 $2$ 层，实际上样例分层图应有第 $3$ 层）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ztencb26.png)

本题分层图的建立方法为：同层节点间无边连接，而上一层通过有向边与下一层对应节点相连。

这样建图的好处是，从第 $0$ 层出发，每走一步都要向下跨越一层。因此，在第 $k$ 层能被访问到的节点，都是通过第 $k$ 步走到。

统计结果时，要想求第 $k$ 步能走到多少节点，只需要知道在第 $k$ 层有多少节点被访问过即可。

该做法复杂度 $O(nmk)$，可以通过本题。

# Code

```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int N = 510;
vector<int> g[N*21];
bool vis[N*21]; //标记是否访问，防止重复计算
int cnt[N][30]; //统计答案

//pos fa k 分别代表当前位置 祖先节点 第k步
void dfs(int pos , int fa , int k)
{
    for (int i = 0 ; i < g[pos].size() ; i++)
    {
        int to = g[pos][i];
        if (vis[to]) continue; //访问过就跳过，防止重复遍历
        vis[to] = true; //标记已访问
        cnt[fa][k]++;
        dfs(to,fa,k+1);
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n,m,k;
    cin >> n >> m >> k;
    for (int i = 1 ; i <= m ; i++)
    {
        int u,v;
        cin >> u >> v;

        //建立分层图，上层与下层通过单向路径连接
        for (int j = 0 ; j < k ; j++)
        {
            //第j层
            int u1 = u + j * n;
            int v1 = v + j * n;

            //第j+1层
            int u2 = u + (j+1) * n;
            int v2 = v + (j+1) * n;

            g[u1].push_back(v2);
            g[v1].push_back(u2);
        }
    }

    for (int i = 1 ; i <= n ; i++)
    {
        memset(vis,0,sizeof(vis)); //重置标记数组
        dfs(i,i,1);
        for (int j = 1 ; j <= k ; j++) cout << cnt[i][j] << " ";
        cout << endl;
    }
}
```

---

## 作者：Alex866 (赞：5)

## 题意分析
题目让我们求出从节点 $i$ 开始经过 $j$ 条边的路径条数。
## 算法选取
首先，要经过 $k$ 条边能到达的点，基本上都要“绕圈”。一些经典的路径算法中，Dijkstra 和 Johnson 显然没法“绕圈”，Bellman-Ford 和 SPFA 和 BFS 差不多，是逐层扩散的，Floyd 虽然能“绕圈”，但无法记录，最小生成树就更不用说了。  
我们先写出关系式： 
$$
b_{i,j}=\sum_{k=0}^{n}a_{i,k}\times g_{k,j}
$$ 
其中 $b_{i,j}$ 是当前阶段从 $i$ 到 $j$ 的路径条数， $a_{i,j}$ 是上一阶段从 $i$ 到 $j$ 的路径条数，$g_{i,j}$ 表示从 $i$ 到 $j$ 是否有边。  
这不就是矩阵乘法吗？于是，你写出代码，开开心心地交了上去，然后……TLE。  
## 优化
分析复杂度发现，上面算法的复杂度是 $O(n^3\times k)$ 约为 $2 \times 10^9$，自然会超时。由于矩阵乘法和 Floyd 很像，而且本题只用记录是否能到达，于是，我们用 Floyd 传递闭包优化——bitset 来优化本算法。优化后复杂度为 $O(\frac{n^3\times k}{w})$，其中 $w$ 为计算机位数。
## code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define uint unsigned
#define ull uint ll
#define __Pa(__Type) pair<__Type,__Type>
#define __Cmp_Pri_Q(__Type,__Compare) priority_queue<__Type,vector<__Type>,__Compare>
#define __Pri_Q(__Type) priority_queue<__Type>
//#define ONLINE_JUDGE
#ifndef ONLINE_JUDGE
#define __put(__X,__F1,__F2) ((__F1)?(cout<<(#__X)<<':'<<(__X)<<" \n"[__F2]):(cout<<(__X)<<" \n"[__F2]))
#define __put0 __(0,0,0)
#define __putenter cout<<'\n'
#else
#define __put(__X,__F1,__F2)
#define __put0
#define __putenter
#endif
//#define __INT_TO_LL
#ifdef __INT_TO_LL
#define int long long
#endif
//#define __USE_FREOPEN
#define __CLOSE_SYNC
#define y1 __Y1_By_MySelf__
using namespace std;
int n,m,k,u,v,ans[505][25];
bitset<505> a[505],b[505],g[505];
signed main(){
#ifdef __CLOSE_SYNC
	ios_base::sync_with_stdio(0);
#endif
#ifdef __USE_FREOPEN
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cin>>n>>m>>k;
	while(m--){
		cin>>u>>v;
		a[u][v]=a[v][u]=g[u][v]=g[v][u]=1;
	}
	for(int i=1;i<=n;i++){
		ans[i][0]+=g[i].count();
	}
	for(int o=1;o<k;o++){
		bitset<505> b[505];
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(a[i][j]){
					b[j]|=g[i];
				}
			}
		}
		for(int i=1;i<=n;i++){
			g[i]=b[i];
			ans[i][o]=g[i].count();
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<k;j++){
			cout<<ans[i][j]<<' ';
		}
		cout<<'\n';
	}
	return 0;
}
```
UPD 2025.6.10：感谢@[fkxr](luogu://user/995934)指出本算法复杂度为 $O\left(kn\left(\frac mw+n\right)\right)$，是正解（目前 20ms 以内的提交均采用此算法），只需遍历相邻的点进行转移即可，以及 TA 提供的优化后的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define gc getchar_unlocked
#define pc putchar_unlocked

#define ds(x) (x=='\r'||x=='\n'||x==' ')

inline void r(int &a) {
	a = 0;
	char ch = gc();
	for (; ch < '0' || ch > '9';)
		ch = gc();
	for (; ch >= '0' && ch <= '9';)
		a = (a << 1) + (a << 3) + (ch ^ 48), ch = gc();
}

template<typename T>inline void w(T a) {
	if (a == 0) {
		pc('0');
		return;
	}
	static char ch[10];
	int till = 0;
	for (; a;)
		ch[till++] = a % 10, a /= 10;
	for (; till;)
		pc(ch[--till] ^ 48);
}

bitset<505>f[505][25];vector<int>e[505];
void Main(){
	int n,m,k;r(n),r(m),r(k);
	for(int i=1;i<=n;i++)f[i][0][i]=1;
	for(;m--;){
		int x,y;r(x),r(y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=k;i++){
		for(int j=1;j<=n;j++){
			for(auto k:e[j]){
				f[j][i]=f[j][i]|f[k][i-1];
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			w(f[i][j].count());pc(' ');
		}
		pc('\n');
	}
}
signed main() {
	Main();
	return 0;
}
```

---

## 作者：__Jared__ (赞：3)

一道非常基础的二维 DP 板子题；

给出一种 DP 的做法，时间复杂度为 $O(nk(n+m))$。

## 做法

定义 $f_{i,j}$ 表示第 $i$ 个节点走了 $j$ 步后可以到达的节点数；

考虑状态转移，注意到 $f_{i,0}$ 不论任何情况都等于 1 即任意情况下走 0 步可以到达的节点数只有它自己本身；枚举每个节点可以到达的节点进行叠加就可以推出转移方程了：

$$f_{u_i,j}=\sum_{i=0}^{n}f_{v_i,j-1}$$

最后只需要输出整个 $f$ 数组即可。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int mp[510][510],cnt[510]/*记录每个节点的邻居数量*/,f[510][21]/*同题解*/,n,m,k;   // 结果数组
int main()
{
    cin>>n>>m>>k;
    for(int i=0;i<m;i++)
	{
        int u,v;
        cin>>u>>v;
        mp[u][cnt[u]++]=v,mp[v][cnt[v]++]=u;
    }
    for(int i=1;i<=n;i++) //枚举每个起点
	{
        bool p[510]; //滚动数组优化 
        memset(p,0,sizeof p);
        p[i]=1;
        for(int j=1;j<=k;j++)
		{
            bool c[510];
            memset(c,0,sizeof c);
            for(int u=1;u<=n;u++) //枚举上一个节点 
			{
                if(!p[u]) continue;
                for(int l=0;l<cnt[u];l++) //遍历当前节点的所有邻居
					c[mp[u][l]]=1;
            }
            int cc=0;
            for(int v=1;v<=n;v++) //看能去哪几个节点，记录 
                cc+=c[v],p[v]=c[v];
            f[i][j]=cc;
        }
    }
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=k;j++) cout<<f[i][j]<<' ';
        cout<<"\n";
    }
}
```

## 温馨提示

考场上一开始看到的时候就给 $f$ 的状态搞错了，搞成了记录每个节点的路径数，特此告诫后人：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool mp[510][510];
int f[510][510];
/*
  f[i][j] 表示i节点下移动j步可以获得的节点数量 
*/
int n,m,k,ans;
int main()
{
	cin>>n>>m>>k;
	for(int i=0;i<m;i++)
	{
		int u,v;
		cin>>u>>v;
		mp[u][v]=1,mp[v][u]=1;
	}
	for(int i=1;i<=n;i++) f[i][0]++;
	for(int i=1;i<=n;i++) //当前节点 
	{
		for(int j=1;j<=k;j++)
		{
			for(int r=1;r<=n;r++) //枚举可以去的点 
			{
				if(mp[i][r]) f[i][j]+=f[r][j-1];
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=k;j++) cout<<f[i][j]<<' ';
		cout<<"\n";
	}
}
```

---

## 作者：NewbieZZZ (赞：3)

### 写在前面

提供一个较为好想到的、从 BFS 拓展来的解法。可能算暴力乱艹，数据水而已。

欢迎 Hack 本解法复杂度或正确性！

~~（srds，时间复杂度本人基本不会求。）~~

### 解法阐述

#### 样例引入

![](https://cdn.luogu.com.cn/upload/image_hosting/lczoqwmw.png)（放一个样例图方便理解）

首先，手玩样例。这里以 $1$ 为起点：

- 第一步：移动到与起点的两条出边相邻的点 $2,3$，有 $2$ 个可能的点；
- 第二步：从点 $2$ 移动到与两条出边相邻的点 $1,3$，从点 $3$ 移动到与三条出边相邻的点 $1,2,4$，有 $4$ 个可能的点；
- ……

只看每一步，每一个起点时，每次向下走都只尝试访问下一层的节点。\
有没有觉得像 BFS？

#### 得出解法

回顾一下 BFS 的流程：

- 从队列里弹出一个节点；
- 遍历其出边；
  - 将出边连接到的节点压入队列（这个点要没有被访问过）；
- 如此循环，直到遍历完毕。

在这题中，我们要把起点或每个移动到的节点出边连接的点的数量统计下来。

容易想到每次限制只能向下一层，并存下这些点（但不压入队列，这样才有限制；并且，每个点可以被重复访问）就可以了。需要去重。

对于每一步的移动，输出存下的点的数量即可。

最后，别忘了把移动到的节点在一次向下遍历完后压入队列，这样才可保证队列里有点。走了 $k$ 步后，停止计算。

对于每个节点，循环以上过程。

### 代码（结合理解）

你们最喜欢的。

```cpp
#include <bits/stdc++.h>
using namespace std;
// 默认我写了快读（

int n, m, k;
vector<int> e[505];

int main(){
    n = read(), m = read(), k = read();
    for(int i=1, x, y; i<=m; ++i){
        x = read(), y = read();
        e[x].push_back(y);
        e[y].push_back(x);
    }
    for(int i=1; i<=n; ++i, putchar('\n')){
        queue<int> q;
        q.push(i);
        for(int j=1; j<=k; ++j){
            unordered_set<int> s; // 去重；vis 数组去重也行
            while(q.size()){ // 每次向下一步
                int cur = q.front();
                q.pop();
                for(int i : e[cur]){
                    s.insert(i); // 存下这些节点（要去重），以备继续向下
                }
            }
            cout << s.size() << ' ';
            for(int _ : s){
                q.push(_); // 不在乎 BFS 的顺序，直接将下一步的节点压入队列
            }
        }
    }
    return 0;
}

```

~~喜提非完隐最劣解（2025.3.24），说不定哪天就被 hack 了。~~

---

## 作者：huangzixi071018 (赞：2)

# 题目大意：
找到从 $1$ 到 $n$ 所有的点走 $1$ 到 $k$ 步的可能到的点的数量。

# 思路：
因为可以走重复的边，所以可以后退一步，再前进一步，记录到达 $i$ 点的奇数次和偶数次到达的最小步数，如果最小奇数步数是 $x$，那么 $x+2$ 次和 $x+4$ 次和 $x+6$ 次都能走到，以此类推从 $x$ 往后的奇数次都能到达，一直到 $k$，偶数次同理，暴力记录答案即可。

# 细节:
如果是单独一个点（也就是没有连边），则不能执行上述的记录。

# 代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=505;
vector<int>e[N];
int d[N][2],k,n,m;
ll res[N];
void bfs(int s){
	memset(d,-1,sizeof(d));
	queue<int>q;
	q.push(s);
	d[s][0]=0;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=0;i<e[x].size();i++){
			int y=e[x][i];
			bool f=0;
			if(d[x][0]!=-1&&d[y][1]==-1&&d[x][0]+1<=k){
				d[y][1]=d[x][0]+1;
				f=1;
			}
			if(d[x][1]!=-1&&d[y][0]==-1&&d[x][1]+1<=k){
				d[y][0]=d[x][1]+1;
				f=1;
			}
			if(f){
				q.push(y);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(d[i][0]!=-1){
			res[d[i][0]]++;
			if(e[i].size()){
				for(int j=d[i][0]+2;j<=k;j+=2){
					res[j]++;
				}
			}
		}
		if(d[i][1]!=-1){
			res[d[i][1]]++;
			if(e[i].size()){
				for(int j=d[i][1]+2;j<=k;j+=2){
					res[j]++;
				}
			}	
		}
	}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		memset(res,0,sizeof(res));
		bfs(i);
		for(int j=1;j<=k;j++){
			cout<<res[j]<<" ";
		}
		cout<<"\n";
	}	
	return 0;
}
```

---

## 作者：jimmy9_666 (赞：1)

### 分析

看一眼数据范围 $1 \le n,m \le 500$，这提示我们可以使用复杂度为 $O(n^3)$ 的算法通过。所以我们可以考虑直接写一个暴力。

使用一个队列 $q$ 来存储当前步骤进行后可以到达的所有节点。然后对于每一步，一直遍历知道 $q$ 为空，将 $q$ 的队首取出，将队首这个节点能够到达的节点全部加入一个临时的 `vector` 数组中（注意去重），当 $q$ 为空时，临时的 `vector` 数组中存储的就是当前步能够到达的所有节点，然后将这些节点全部入队到 $q$ 中进行下一次操作就行了。

### 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#define LL long long
//#define int long long

using namespace std;

const int N = 510;

int n, m, k;
vector<int> g[N];

void dfs(int x) {
	queue<int> q;
	q.push(x);
	for (int i = 1; i <= k; i ++ ) {
		vector<int> ans;
		vector<bool> vis(n, 0);
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			for (auto v : g[u]) {
				if (vis[v])
					continue;
				vis[v] = true;
				ans.push_back(v);
			}
		}
		printf("%d ", (int)ans.size());
		for (int i = 0; i < (int)ans.size(); i ++ )
			q.push(ans[i]);
	}
}

int main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= m; i ++ ) {
		int u, v;
		scanf("%d%d", &u, &v);
		g[u].push_back(v), g[v].push_back(u);
	}
	for (int i = 1; i <= n; i ++ )
		dfs(i), puts("");
	return 0;
}
```

---

## 作者：abc1856896 (赞：1)

# Solution

首先暴力每次搜一遍必然会超时，此时我们注意到走 $k$ 步的顶点必然从 $k-1$ 步的顶点走过来。所以我们只需要每次记录走 $k-1$ 步能到达的顶点，再从这些顶点转移到当前走 $k$ 步的即可。时间复杂度优化直 $O(nmk)$，可以通过。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	char ch=getchar();
	int x=0;
	bool t=0;
	while(ch<'0'||ch>'9')   t|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
	return t?-x:x;
}
inline void write(int x) {
	if(x>9) write(x/10);
	putchar(x%10^48);
}
int head[1005],cnt;
struct data{
	int to;
	int next;
};
data edge[1005];
void add_edge(int from,int to) {
	++cnt;
	edge[cnt]={to,head[from]};
	head[from]=cnt;
}
int n,m,k;
bool vis[505],ans[505];
signed main(){
	n=read(),m=read(),k=read();
	for(int i=1,u,v;i<=m;i++) {
		u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=k;j++) {
			int sum=0;
			if(j==1) {
				for(int u=head[i];u;u=edge[u].next) {
					int v=edge[u].to;
					ans[v]=true;
				}
			}
			else {
				for(int l=1;l<=n;l++) {
					if(vis[l]) {
						for(int u=head[l];u;u=edge[u].next) {
							int v=edge[u].to;
							ans[v]=true;
						}
					}
				}
			}
			for(int l=1;l<=n;l++) {
				if(ans[l]) sum++;
				vis[l]=ans[l];
				ans[l]=false;
			}
			write(sum),putchar(' ');
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：Fire_flys (赞：1)

思路：用一个数组来存答案，再进行记忆化搜索，如果已经搜过了就直接返回，否则将当前步数答案加一再标记一下就行了。
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=505;
int head[maxn],cnt,ans[maxn][22],n,m,k;
bool vis[maxn][22];
struct node{
	int to,nxt;
}e[maxn*2];
void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int x,int dep,int o){
	if(dep>k)return;
	if(vis[x][dep]==0){
		ans[o][dep]++;
		vis[x][dep]=1;
	}
	else return;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		dfs(y,dep+1,o);
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		int u,v;cin>>u>>v;
		add(u,v);add(v,u);
	}
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		dfs(i,0,i);
		for(int j=1;j<=k;j++)cout<<ans[i][j]<<" ";
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：qwqerty (赞：0)

# 解题思路
考虑动态规划，定义 $dp_{i,j,k}$ 为以 $j$ 为起点走 $i$ 步后是否能到达 $k$。  
若 $k$ 与 $l$ 之间有一条边，那么将 $dp_{i,j,k}$ 赋值为 $dp_{i,j,l}$。  
实现时需注意利用邻接表，记录与 $k$ 的连边，再进行动态规划计算。  
时间复杂度 $O(knm)$，可以通过本题。
# AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, k;
vector<int> g[1005];
bool dp[25][1005][1005]; 
signed main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for (int i = 1; i <= n; i++) dp[0][i][i] = 1;
	for (int i = 1; i <= k; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= n; k++) {
				if (dp[i - 1][j][k]) {
					for (auto l : g[k]) {
						dp[i][j][l] = 1;
					}
				}	
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++) {
			int res = 0;
			for (int k = 1; k <= n; k++) res += dp[j][i][k];
			cout << res << " "; 
		}
		cout << "\n";
	}
	return 0;
}
```

---

## 作者：Dazlin7 (赞：0)

#### 题意简述
给定一个无向图，每个节点出发移动恰好 $1$ 到 $k$ 步，统计每一步可能到达的节点数。


#### 核心思路
- **位运算优化**  
   使用整数的二进制位表示节点集合（如第 $i$ 位为 $1$ 表示节点 $i$ 可达），每一步通过位运算快速合并邻接节点集合。

- **状态转移**  
   初始状态为起点对应的位掩码，每一步通过遍历当前所有可达节点的邻接位掩码，合并得到下一步的可达集合。


#### 关键步骤

##### 预处理

每个节点 $u$ 的邻接节点集合转化为二进制掩码，如节点 $2$ 和 $3$ 对应掩码 `110`（二进制）。

##### 动态模拟

每一步通过遍历当前掩码中的所有有效位，合并对应节点的邻接掩码。

优点：利用位运算直接操作二进制位，避免显式遍历所有节点。


### 代码


时间复杂度为 $ O(n \times k \times m) $，常数较低。

```python
n, m, k = map(int, input().split())
a = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    a[u].append(v)
    a[v].append(u)

# 预处理邻接节点的位掩码
am = [0] * (n + 1)
for u in range(1, n + 1):
    mask = 0
    for v in a[u]:
        mask |= 1 << (v - 1)
    am[u] = mask

# 计算每个起点的答案
for i in range(1, n + 1):
    current_mask = 1 << (i - 1)  # 初始状态为起点i
    res = []
    for step in range(k):
        next_mask = 0
        tmp = current_mask
        while tmp:
            # 提取最低位的1
            lsb = tmp & -tmp
            pos = (lsb).bit_length() - 1  # 计算节点编号
            next_mask |= am[pos + 1]  # 合并邻接节点
            tmp ^= lsb  # 清除已处理位
        res.append(bin(next_mask).count('1'))
        current_mask = next_mask
    print(' '.join(map(str, res)))
```

---


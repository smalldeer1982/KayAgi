# [蓝桥杯 2025 省 Java A/研究生组] 甘蔗

## 题目描述

小蓝种了一排甘蔗，甘蔗共 $n$ 根，第 $i$ 根甘蔗的高度为 $a_i$。小蓝想砍一些甘蔗下来品尝，但是他有强迫症，不希望甘蔗的高度显得乱糟糟的。具体来说，他给出了一个大小为 $m$ 的整数集合 $B = \{b_1, b_2, \cdots, b_m\}$，他希望在砍完甘蔗后，任意两根相邻的甘蔗之间的高度差 $|a_i - a_{i+1}|$ 都要在这个集合 $B$ 中。小蓝想知道他最少需要砍多少根甘蔗（对于高度为 $h$ 的甘蔗，他可以将其砍成 $x$ 高度的甘蔗，$x \in \{0, 1, 2, \cdots, h-1\}$）。

## 说明/提示

### 样例说明 1

其中一种方案：将 $a_2$ 砍为 $3$，再将 $a_3$ 砍为 $1$。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$1 \leq n, m \leq 8$；
- 对于所有评测用例，$1 \leq n, m \leq 500$，$1 \leq a_i \leq 1000$，$0 \leq b_i \leq 1000$。

## 样例 #1

### 输入

```
6 3
6 7 3 4 9 12
2 3 5```

### 输出

```
2```

## 样例 #2

### 输入

```
2 1
4 5
6```

### 输出

```
-1```

# 题解

## 作者：A7F3jK9pR0xf_ (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P12189)

### 思路

最优化问题，考虑动态规划。

我们发现 $n,m$ 和值域很小，不妨考虑二维 dp，设 $dp_{i,j}$ 为将第 $i$ 个甘蔗高度变为 $j$ 时的最小代价。

接下来考虑初始化，显然 $|a_i-a_{i+1}|$ 这个条件对于 $dp_{1,i}$ 来说并不受约束，直接令 $dp_{1,i}=[i<a_1]$ 即可。

接下来考虑状态转移。由于是二维，我们肯定要枚举一个 $j$ 从 $0\to a_i$，然后要枚举 $i-1$ 位填的 $k$ 从 $0\to a_{i-1}$，开个布尔数组 $O(1)$ 判断 $|j-k|\in B$，然后状态转移：

$$dp_{i,j}=\min_{k=0,|j-k|\in B}^{a_{i-1}}\{dp_{i-1,k}+[j<a_i]\}$$

这样做的复杂度是 $O(nN^2)$，其中 $N$ 是值域。

虽然足以通过，但我们还可以继续优化复杂度。观察数据范围，我们发现 $n,m<N$，不妨考虑将第三维 $k$ 的枚举改成对 $B$ 每一位的枚举，然后计算 $|j-x|=b_k$ 的两个解 $x_1$ 和 $x_2$，再进行状态转移。易得：

$$x_1=b_k+j$$

$$x_2=j-b_k$$

$$
dp_{i,j}=\min_{k=1}^m \Bigg \{
\begin{cases}
x_1\geq 0,dp_{i-1,x_1} \\
x_2\geq 0,dp_{i-1,x_2}
\end{cases} +[j<a_i]\Bigg \}
$$

这样做的时间复杂度为 $O(nmN)$，或者可以理解为 $O(m\sum a_i)$，可以通过此题。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
const int N = 510, M = 1e3 + 10;
int dp[N][M], a[N], b[N], n, m;
bool vis[M];
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;++i)
        scanf("%d", &a[i]);
    for(int i = 1;i <= m;++i)
        scanf("%d", &b[i]);
    memset(dp, 0x3f, sizeof(dp));
    for(int i = 0;i <= a[1];++i)
        dp[1][i] = (i < a[1]);
    for(int i = 2;i <= n;++i)
    {
        for(int j = 0;j <= a[i];++j)
        {
            for(int k = 1;k <= m;++k)
            {
                int x1 = b[k] + j, x2 = j - b[k];
                if(x1 >= 0)
                    dp[i][j] = min(dp[i][j], dp[i - 1][x1] + (j < a[i]));
                if(x2 >= 0)
                    dp[i][j] = min(dp[i][j], dp[i - 1][x2] + (j < a[i]));
            }
        }
    }
    int ans = dp[0][0];
    for(int i = 0;i <= a[n];++i)
        ans = min(ans, dp[n][i]);
    if(ans < dp[0][0]) // 特判无解
        cout << ans;
    else
        cout << -1;
    return 0;
}

```

---

## 作者：WsW_ (赞：3)

### 前言
难度约为黄到绿，在黄里面算比较棘手的。  

---
### 思路
显然第 $i$ 根甘蔗的高度能是多少，只受第 $i-1$ 根甘蔗的影响。第 $1\sim i-2$ 根甘蔗高度是多少并不影响第 $i$ 根甘蔗。   
所以可以将第 $i$ 根甘蔗看作状态。  

想知道第 $i$ 根甘蔗的高度能是多少，必须要知道第 $i-1$ 根甘蔗的高度能是多少，所以再给 dp 的第二维就是第 $i$ 根甘蔗的高度。  
所以设计 $dp_{i,j}$ 表示第 $i$ 根甘蔗的高度为 $j$ 时，$1\sim i$ 根甘蔗里面至少要砍多少根甘蔗。  

可以从前转移，也可以向后转移，我写的是从前转移。  
容易发现 $m$ 的范围比 $a_i$ 的范围要小，所以枚举第 $i-1$ 根甘蔗可以是多少的时候枚举 $|a_i-a_{i-1}|$ 的值，而非枚举 $a_{i-1}$ 的值。  

整体的过程为：最外层枚举 $i$，表示第 $i$ 根甘蔗，第二层枚举 $j$，表示将第 $i$ 根甘蔗砍成 $j$。第三层通过枚举 $|a_i-a_{i-1}|$ 来间接枚举 $a_{i-1}$。  
当 $j=a_i$ 时，表示不砍第 $i$ 根甘蔗，转移的时候不需要 $+1$；否则表示砍第 $i$ 根甘蔗，转移的时候需要 $+1$。

时间复杂度为 $O(nmA)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
typedef unsigned long long ull;

int n,m;
int a[505],b[505];
int dp[505][1005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	
	for(int i=0;i<a[1];i++)dp[1][i]=1;
	dp[1][a[1]]=0;
	for(int i=2;i<=n;i++){
		for(int j=0;j<=a[i];j++){//枚举第i根甘蔗的长度 
			dp[i][j]=n+1;
			for(int t=1;t<=m;t++){
				bool f=(j!=a[i]);//是否砍了第i根甘蔗

                //需要判断枚举出来的a[i-1]是否在可能的范围内
				if(j-b[t]>=0&&j-b[t]<=a[i-1])dp[i][j]=min(dp[i][j],dp[i-1][j-b[t]]+f);
				if(j+b[t]<=a[i-1])dp[i][j]=min(dp[i][j],dp[i-1][j+b[t]]+f);
			}
		}
	}
	int ans=n+1;
	for(int i=0;i<=a[n];i++)ans=min(ans,dp[n][i]);
	cout<<(ans>n?-1:ans);
	return 0;
}
```

---

## 作者：egg_boy (赞：1)

来水篇题解。  
前置芝士：[动态规划 dp](https://oi-wiki.org/dp/basic/)，~~脑子~~。  

# 分析
  首先容易发现是 dp，又发现数据很小，所以可知是暴力 dp。  
  
# dp 状态定义
  在数据小的情况下优先考虑二维 dp，容易想到 $dp_{i,j}$ 表示前 $i$ 根甘蔗，第 $i$ 根长度为 $j$ 是最小需要砍多少甘蔗。
  
# 状态转移方程设计
  我们发现对于第 $i$ 根甘蔗，影响他的只有第 $i-1$ 根甘蔗，所以枚举第 $i$ 根甘蔗砍完后的长度 $j$（可以不砍），再枚举题目中的集合 $b$ 就可以轻松推出状态转移方程了，即：  
```cpp
dp[i][j] = min(dp[i][j], dp[i - 1][j - b[k]] + (j != a[i]));
dp[i][j] = min(dp[i][j], dp[i - 1][j + b[k]] + (j != a[i]));
```
在写的时候要注意判断该情况下是否合理，即不能越砍越长，长度也不能为负数。

# 输出答案
  在 $dp_{n,i}$ 中取最小值即可，记得判断是否无解。

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 510, M = 1010, inf = 0x3f3f3f3f;
int n, m, y1, a[N], b[N], dp[N][M];

int main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= m; i++) cin >> b[i];
	
	// 初始化 
	for(int i = 0; i < a[1]; i++) dp[1][i] = 1;
	dp[1][a[1]] = 0; // 这句可以不写 但是为了读者能理解这部分初始化还是写上好点 
	for(int i = 2; i <= n; i++)
		for(int j = 0; j <= a[i]; j++) dp[i][j] = inf;
	
	for(int i = 2; i <= n; i++)
		for(int j = 0; j <= a[i]; j++) // 枚举当前甘蔗长度 
			for(int k = 1; k <= m; k++) // 枚举集合b 
			{
				// 判断是否合理 
				if(0 <= j - b[k] && j - b[k] <= a[i - 1]) dp[i][j] = min(dp[i][j], dp[i - 1][j - b[k]] + (j != a[i]));
				if(0 <= j + b[k] && j + b[k] <= a[i - 1]) dp[i][j] = min(dp[i][j], dp[i - 1][j + b[k]] + (j != a[i]));
				// 其实 0 <= j + b[k] 可以不写，但我觉得这样好看 
			}
	 
	int ans = inf;
	for(int i = 0; i <= a[n]; i++) ans = min(ans, dp[n][i]);
	cout << (ans == inf ? -1 : ans);
	return 0;
}
```

---

## 作者：LinkGTF (赞：1)

# 题意
共 $n$ 根甘蔗，第 $i$ 根甘蔗的高度为 $a_i$。给出了一个大小为 $m$ 的整数集合 $B = \{b_1, b_2, \cdots, b_m\}$，要砍若干个甘蔗，在砍完甘蔗后，要求任意两根相邻的甘蔗之间的高度差 $|a_i - a_{i+1}|$ 都要在这个集合 $B$ 中。对于高度为 $h$ 的甘蔗，他可以将其砍成 $x$ 高度的甘蔗，$x \in \{0, 1, 2, \cdots, h-1\}$。

问至少需要砍几根甘蔗才能满足条件。如果不能满足条件，输出 $-1$。

# 思路
### 考虑动态规划
## 状态
$dp_{i,j}$ 表示前 $i$ 根甘蔗，最后一根高度为 $j$ ，至少需要砍几根甘蔗才能满足条件。
## 转移
状态转移分两种：
1. $j<a_i$
2. $j=a_i$

对于第一种情况转移为：
$$dp_{i,j}=\min_{k=1}^m(dp_{i-1,j-b_k}, dp_{i-1,j+b_k})$$
对于第二种情况转移为：
$$dp_{i,j}=\min_{k=1}^m(dp_{i-1,j-b_k}, dp_{i-1,j+b_k})+1$$
## 初始化
对于 $dp_{1,i}$，如果 $i=a_1$ 则 $dp_{1,i}=0$，否则 $dp_{1,i}=1$。其它的状态全设为**正无穷**。
## 答案
答案为 $\min_{i=0}^{a_n} dp_{n,i}$，即所有甘蔗都满足条件时最少砍几下。
## 细节
转移时注意下标越界
# AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[501], b[501], dp[501][1001];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, m, ans = 2e9;
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    for(int i = 1; i <= m; i++){
        cin >> b[i];
    }
    memset(dp, 0x3f, sizeof(dp));
    for(int i = 0; i < a[1]; i++){
        dp[1][i] = 1;
    }
    dp[1][a[1]] = 0;
    for(int i = 2; i <= n; i++){
        for(int j = 0; j <= a[i]; j++){
            for(int k = 1; k <= m; k++){
                if(j - b[k] >= 0){
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - b[k]] + (j == a[i] ? 0 : 1));
                }
                if(j + b[k] <= a[i - 1]){
                    dp[i][j] = min(dp[i][j], dp[i - 1][j + b[k]] + (j == a[i] ? 0 : 1));
                }
            }
        }
    }
    for(int i = 0; i <= a[n]; i++){
        ans = min(ans, dp[n][i]);
    }
    if(ans > 1e9){
        cout << -1;
    }else{
        cout << ans;
    }
    return 0;
}
```

---

## 作者：wangwang0307 (赞：1)

# 思路

很明显，动态规划。

## 状态

我们定义 $f_{i,h}$ 表示当第 $i$ 根甘蔗高度为 $h$ 时的最优解。

## 决策

上一根的高度是什么。

状态转移方程为：

`f[i][h] = std::min(f[i][h], f[i - 1][j] + (h == a[i] ? 0 : 1));`

其中 $j$ 为上一根高度。只需根据 $b$ 数组枚举即可。

## 结果

设一个变量 $ans$ 在 $f_{n,h}$ 中遍历取最小值即可。

## 小细节

我们让 $f_{1,h}$ 这个边界情况定义如下：

`f[1][h] = (h == a[1] ? 0 : 1);`

并且在进行状态转移的时候有两种情况：

一种是上一根的甘蔗高度比当前高；一种是上一根的甘蔗高度比当前低。但是要注意在枚举上一根甘蔗可能高度时不能超过上一根甘蔗的原有高度，并且不低于 $0$。

# AC CODE
```cpp
#include<iostream>
#include<queue>
#include<utility>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<string>
#include<climits>
#include<vector>
#include<numeric>
#include<stdio.h>
#include<stack>
#include<bitset>
namespace noip{
	using Int = long long;
	
	constexpr Int Max_N = 500;
	constexpr Int Max_M = 500;
	constexpr Int Max_A = 1000;
	
	Int n, m;
	Int a[1 + Max_N], b[1 + Max_M];
	Int f[1 + Max_N][1 + Max_A] {};
	
	void init() {}
	void main() {
		std::cin >> n >> m;
		for (Int i = 1; i <= n; i++) std::cin >> a[i];
		for (Int i = 1; i <= m; i++) std::cin >> b[i];
		for (Int i = 0; i <= a[1]; i++) f[1][i] = (i == a[1] ? 0 : 1);
		
		for (Int i = 2; i <= n; i++) {
			for (Int h = 0; h <= a[i]; h++) {
				f[i][h] = LLONG_MAX / 2; //除以 2 防止溢出
				for (Int l = 1; l <= m; l++) {
					Int j = -1;
					if (h - b[l] >= 0 && h - b[l] <= a[i - 1]) {
						j = h - b[l];
						f[i][h] = std::min(f[i][h], f[i - 1][j] + (h == a[i] ? 0 : 1));
					}
					if (h + b[l] <= a[i - 1]) {
						j = h + b[l];
						f[i][h] = std::min(f[i][h], f[i - 1][j] + (h == a[i] ? 0 : 1));
					}
				}
			}
		}
		
		Int ans = LLONG_MAX;
		for (Int i = 0; i <= a[n]; i++) {
			ans = std::min(ans, f[n][i]);
		}
		if (ans > n) std::cout << -1 << std::endl; //当砍的次数超过甘蔗总次数时，无解。
		else std::cout << ans << std::endl;
	}
}
int main() {
	noip::init();
	noip::main();
	return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：1)

二维 DP，可以优化为滚动数组。

## 思路
先从二维 DP 开始，状态空间是所有甘蔗的全部合法长度，假设 $dp_{i,j}$ 表示在第 $i$ 根甘蔗在长度为 $j$ 且前 $i$ 根甘蔗的长度合法时，至少要砍的次数。

状态转移方程为
$$
d p_{i, j}=\left\{\begin{matrix}
 \min \left\{\min _{\substack{b \in B \\
0 \leq j+b \leq a_{i-1}}} d p_{i-1, j+b}, \quad \min _{\substack{b \in B \\
0 \leq j-b \leq a_{i-1}}} d p_{i-1, j-b}\right\}+\left\{\begin{array}{ll}
0, & j=a_{i}, \\
1, & 0 \leq j<a_{i},
\end{array}\right. & 0\le j \le a_{i}\\
 +\infty  & j> a_{i}
\end{matrix}\right.
$$
其中正无穷表示非法的部分，因为甘蔗的长度不可能变得更长。当 $j = a_i$ 时说明不需要砍，因此总的次数不需要加一。前半部分这个巨大的 $\min$ 表示从砍的次数最少的状态转移过来。

等价地，令 $v=b+j$，$w=b-j$，上面转移方程可以写成更适合编程的形式
$$
d p_{i, v}=\min \left(d p_{i, v}, d p_{i-1, j}+\left[v<a_{i}\right]\right) ,\quad 0\le v \le a_i\\
d p_{i, w}=\min \left(d p_{i, w}, d p_{i-1, j}+\left[w<a_{i}\right]\right) ,\quad 0\le w_i\le a_i
$$
其中 $[v<a_i]$ 表示当 $v<a_i$ 时取 $0$，其它取 $1$。对应到代码里面就是

```cpp
vector<vector<int>> dp(n, vector<int>(1001, INF));
for (int j = 0; j < a[0]; ++j) {
    dp[0][j] = 1;
}
dp[0][a[0]] = 0;

for (int i = 1; i < n; ++i) {
	for (int j = 0; j < 1001; ++j) {
		if (dp[i - 1][j] != INF) {
			for (auto u : B) {
				int v = j + u;
				int w = j - u;
				if (v >= 0 && v <= a[i]) {
					if (v == a[i]) {
						dp[i][v] = min(dp[i - 1][j], dp[i][v]);
					}
					else {
						dp[i][v] = min(dp[i - 1][j] + 1, dp[i][v]);
					}
				}
				if (w >= 0 && w <= a[i]) {
					if (w == a[i]) {
						dp[i][w] = min(dp[i - 1][j], dp[i][w]);
					}
					else {
						dp[i][w] = min(dp[i - 1][j] + 1, dp[i][w]);
					}
				}
			}
		}
	}
}
```

仔细观察发现第 $i$ 层的 DP 只与第 $i-1$ 层的有关，因此可以进行滚动数组优化。

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int INF = 1e9+7;
int main(){
    int n,m;
    cin>>n>>m;
    vector<int> a(n);
    unordered_set<int> B;
    for(int i=0;i<n;++i){
        cin>>a[i];
    }
    for(int i=0;i<m;++i){
        int u;
        cin>>u;
        B.insert(u);
    }

    vector<int> prev(1001, INF);
    for (int j = 0; j < a[0]; ++j){
        prev[j] = 1;
    }
    prev[a[0]] = 0;

    for (int i = 1; i < n; ++i) {
        vector<int> curr(1001, INF);
        for (int j = 0; j < 1001; ++j) {
            if (prev[j] != INF){
                for (auto u : B) {
                    int v = j + u;
                    int w = j - u;
                    if (v >= 0 && v < a[i]) {
                        curr[v]=min(prev[j]+1,curr[v]);
                    }
                    else if(v == a[i]){
                        curr[v]=min(prev[j],curr[v]);
                    }
                    if (w >= 0 && w < a[i]) {
                        curr[w]=min(prev[j]+1,curr[w]);
                    }
                    else if(w == a[i]){
                        curr[w]=min(prev[j],curr[w]);
                    }
                }
            }
        }
        prev = std::move(curr);
    }
    
    int ans=INF;
    for(int j=0;j<1001;++j){
        ans=min(ans,prev[j]);
    }
    if(ans==INF){
        ans=-1;
    }
    cout<<ans;
    

    return 0;
}
```

---

## 作者：粥2414 (赞：1)

~~一道水题。~~
# 思路
观察数据范围和时限可知正解是打暴力。

设 $dp_{i,j}$ 表示将第 $i$ 个甘蔗削成 $j$ 高度且合法的最小次数。

暴力枚举可能的高度和方案即可。

具体的，遍历每一个甘蔗 $i$，然后枚举第 $i$ 个甘蔗被削之后的高度 $j$，然后穷举与上一个甘蔗可能的高度差 $k$，若 $j\pm k\in [1,a_{i-1}]$，那么便是合法方案，取加或减的较小值即可。若 $j\neq a_i$，那么还需要额外加 $1$ 为砍这个甘蔗的代价。

时间复杂度 $O(nm\max(a))$，尽管这个复杂度很劣，但在三秒的超大时限下哪怕不吸氧也是[轻轻松松通过](https://www.luogu.com.cn/record/213976630)。吸氧更是[跑的飞快](https://www.luogu.com.cn/record/213976587)。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read() {
	int x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
const ll N=509,INF=1e9+7;
ll n,m;
ll a[N],b[N];
ll dp[N][N*2];
ll ans;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=m;i++){
		b[i]=read();
	}
	memset(dp,0x3f,sizeof(dp));
	for(int i=0;i<a[1];i++){
		dp[1][i]=1;
	}
	dp[1][a[1]]=0;
	for(int i=2;i<=n;i++){
		for(int j=a[i];j>=0;j--){
			ll x=!(j==a[i]);
			for(int k=1;k<=m;k++){
				if(j+b[k]<=a[i-1]){
					dp[i][j]=min(dp[i][j],dp[i-1][j+b[k]]+x);
				}
				if(j-b[k]<=a[i-1]&&j-b[k]>=0){
					dp[i][j]=min(dp[i][j],dp[i-1][j-b[k]]+x);
				}
			}
		}
	}
	ans=INF;
	for(int i=0;i<=a[n];i++){
		ans=min(ans,dp[n][i]);
	}
	if(ans>n)cout<<-1;
	else cout<<ans;
	return 0;
}
```

---


# [蓝桥杯 2025 省 A 第二场] 基因配对

## 题目描述

小蓝发现了一种奇特的生物，它的遗传信息可以表示为一个长度为 $n$ 的 $01$ 串 $s = s_0s_1 \cdots s_{n-1}$，其中的任意一段子串 $s_{l, r} = s_l s_{l+1} \cdots s_r$ 则可以构成一个基因。

我们称遗传信息的某两个位置相反，是指这两个位置上的字符不相同（即其中一个为 0，另一个为 1）。

小蓝想知道，有多少对不相交的相同长度的基因正好相反，即有多少对 $[(a, b), (c, d)]$ 满足 $0 \leq a \leq b < c \leq d < n$ 且子串 $s_{a, b}$ 和子串 $s_{c, d}$ 的每个位置恰好相反。

## 说明/提示

### 样例说明

有以下 $8$ 对子串满足条件：$[(0,0),(1,1)]$、$[(0,0),(2,2)]$、$[(1,1),(3,3)]$、$[(1,1),(4,4)]$、$[(2,2),(3,3)]$、$[(2,2),(4,4)]$、$[(0,1),(2,3)]$、$[(1,2),(3,4)]$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 20$；
- 对于所有评测用例，$1 \leq n \leq 1000$。

## 样例 #1

### 输入

```
10011```

### 输出

```
8```

# 题解

## 作者：wangwang0307 (赞：5)

## 思路  
可以用动态规划做。  

我们设传进来的字符串为 $a$。

**状态**：$f_{i,j}$ 表示在字符串中两个分别以 $a_i$ 和 $a_j$ 开头的两个子串能匹配（指能使得 $a_{i\ldots i+f_{i,j}}$ 与 $a_{j\ldots j+f_{i,j}}$ 互反）的最大长度。

**状态转移方程**：当 $a_i$ 与 $a_j$ 不等时即是 $f_{i+1,j+1}+1$（也就是在 $a_i$、$a_j$ 之后一个数 $a_i+1$、$a_j+1$ 开头能最大匹配的长度加 $1$），否则就是没有匹配，即为零。

## AC CODE
```cpp
#include<iostream>
#include<queue>
#include<utility>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<string>
#include<climits>
#include<vector>
namespace noip {
	using Int=long long;
	constexpr Int Max_N=1000;
	char a[1+Max_N];
	Int f[1+Max_N][1+Max_N]{};
	void init(){}
	void main(){
		std::cin>>a;Int n=std::strlen(a);
		for(Int i=n;i--;){
			for(Int j=n;j--;){
				f[i][j]=a[j]!=a[i]?1+f[i+1][j+1]:0;
			}
		}
		Int ans=0;
		for(Int i=0;i<n;i++){
			for(Int j=i+1;j<n;j++){
				ans+=std::min(j-i,f[i][j]);//防止计算的两个子串重叠,因为题目要求 b 小于 c 
			}
		}
		std::cout<<ans<<std::endl;
	}
}
int main(){
	noip::init();
	noip::main();
	return 0;
}
```

---

## 作者：yulinOvO (赞：3)

本题的第一篇题解（也许？
### 题意：
统计一个 $01$ 字符串中所有不相交的相同长度子串对，且这两个子串在每个对应位置上的字符都正好相反。

### 思路：
尝试生成一个反转 $s$ 的 $t$，预处理 $s$ 所有子串及其起始位置。对于 $t$ 的每个子串，检查是否在 $s$ 的子串出现过，如果出现过，统计 $s$ 中不相交的起始位置数量，最后统计总和。
### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,n;
string s,t;
int main()
{
    cin >> s;
    n=s.length();
    for(char c:s) t+=(c=='0')?'1':'0';//t反转s 
    map<pair<int,string>, vector<int>> a;
    for(int l=1;l<n;l++)//预处理
    {
        for(int i=0;i<=n-l;i++)
		{
            string sub=s.substr(i,l);
            a[{l,sub}].push_back(i);
        }
    }
    for(int l=1;l<n;l++)
	{
        for(int i=0;i<=n-l;i++)
		{
            string p=t.substr(i,l);
            auto k=make_pair(l,p);
            if(a.find(k)!=a.end()) for(int j:a[k]) if(j>i+l-1) ans++;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Potato24 (赞：1)

## 思路
我首先想到的是区间，需要一个二维数组，而 $f[i][j]$ 表示的是 $a=i-k,b=i,c=j-k,d=j$ 的符合条件的 $k$ 的最大值。然后，再排除 $c<b$ 也就是 $j-k<i\to j-i<k$ 的情况，$k=f[i][j]$ 所以需要判断 $\min(j-i,f[i][j])$。答案就是 $$ \sum _ {i = 1} ^ {n-1} \sum _ {j = i} ^ {i+k} \min(j-i,f[i][j])$$。
## AC 代码
```
#include <bits/stdc++.h>
using namespace std;
int f[1010][1010];
char s[1010];
int main()
{
	int n=1,ans=0;
	while(cin>>s[n])n++;
    n--;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
    		if(s[i]!=s[j])
                f[i][j]=f[i-1][j-1]+1;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
    		ans+=min(j-i,f[i][j]);
	cout<<ans;
}
```

---

## 作者：sacc (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P12346)

## 题目大意

我们需要找到所有不相交的相同长度的子串对，使得它们的每个位置都相反。

## 思路

接暴力枚举所有可能的子串对会导致 $O(n^4)$ 的时间复杂度，这在 $n=1000$ 时显然超时，因此我们采用dp的方法来预处理一些信息，从而统计符合条件的子串对。

**动态转移方程 $dp(i,j)=1+dp(i+1,j+1)$**。

**统计答案**

对于每一对 $(i,j)$，$dp(i,j)$ 的值表示从 $i$ 和 $j$ 开始的最长相反子串长度。那么对于这个位置对 $(i,j)$，它可以贡献 $\min(j-i,dp(i,j))$ 个有效的子串对，因为子串不能重叠，所以最大长度为 $j-i$，最后将所有这样的贡献累加起来就是最终的答案。

## 上代码环节：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//十年oi一场功，不开long long见祖宗。
#define endl '\n'
#define MOD 1000007
int ans;//答案。
int a[1005][1005];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin>>s;
    //预处理dp数组。
    for(int i=s.size()-1;i>=0;i--)
	{
        for(int j=s.size()-1;j>=0;j--)
		{
            if(s[i]!=s[j])
                dp[i][j]=1+dp[i+1][j+1];
        }
    }
    //计算答案。
    for(int i=0;i<s.size();i++)
	{
        for(int j=i+1;j<s.size();j++)
		{
            ans+=min(j-i,dp[i][j]);
        }
    }
    cout<<ans;
    return 0;
}
```


**时间复杂度** $O(n^2)$，因为有两层嵌套循环，每层最多执行 $n$ 次。

---

## 作者：copper_ingot (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12346)

此题可以用 DP 做，转移方程挺好想的，代码也不难写。

设 $dp_{i,j}(i<j)$ 表示分别以 $s_i$ 和 $s_j$ 结尾的字符串的最大相反长度，即使 $s_{i-x+1,i}$ 和 $s_{j-x+1,j}$ 相反的最大 $x$。

我们不难得出转移方程：

$$dp_{i,j}=\begin{cases}0&s_i=s_j\\\min(dp_{i-1,j-1}+1,j-i)&s_i=s_j\end{cases}$$

因为两段字符串不能重叠，所以 $dp_{i,j}$ 不能超过 $j-i$。

初始化 $dp_{i,0}=dp_{0,i}=0$。

最终答案是 $\sum_{i=1}^{n-1}\sum_{j=i+1}^ndp_{i,j}$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int, int>
pii mkp(int x, int y){pii p; p.first = x, p.second = y; return p;}
int n, dp[2001][2001], ans; char s[2001];
signed main(){
    scanf("%s", s + 1); n = strlen(s + 1);
    for (int i = 1; i <= n; i++)
    	for (int j = i + 1; j <= n; j++){
    		if (s[i] != s[j]) dp[i][j] = min(dp[i - 1][j - 1] + 1, j - i);
    		else dp[i][j] = 0;//转移
    		ans += dp[i][j];
		}
	printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：true_kun (赞：0)

本来想着写个 $n^3$ 暴力跑路的，结果就过了。

我们考虑 $n^3$ 的剪枝，循环枚举第一个子串的左端点和第二个子串的左端点，子串长度。如果两个子串右端点相同则后续随着子串长度的增加，两个子串必定不能匹配，我们直接跳出循环即可。如果不同那么则意味着这两个子串所有位置都不同，可以匹配，我们统计的答案加一。注意，判断第一个子串的右端点要严格小于第二个子串的左端点，第二个子串的右端点不能超过 $n$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5005];
int main(){
	string s;
	cin>>s;
	int n=s.length();
	for(int i=0;i<=n-1;i++) a[i+1]=s[i]-'0';
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=0;k<=n;k++){
				if(i+k>=j||j+k>n)continue;
				if(a[i+k]==a[j+k]) break;
				ans++;
			}
		}
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：Meickol (赞：0)

## 字符串哈希 + 暴力枚举所有区间 + STL 维护所有可能右端点

考虑将输入的字符串 $s$ 每一位取反得到字符串 $t$。

显然若区间为 $[a,b]$ 的子串 和 区间为 $[c,d]$ 的子串满足题意条件，则 $t_{a \sim b} = s_{c \sim d}$。

由于一个“外形”相同的子串可以对应多个位置，于是用 map 嵌套 vector，维护一下这个子串对应的所有可能的右端点。

对于所有可能的子串，通过暴力枚举 $l,r$ 左右端点，结合字符串哈希快速求解即可。

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
typedef unsigned long long ULL;
const int N=1e3+5,P=13331;
char s[N],t[N];
ULL h1[N],h2[N],p[N]; // h1 对应字符串 s，h2 对应字符串 t
void init(char *str,ULL h[]){
	h[0]=0,p[0]=1;
	int len=strlen(str+1);
	rep(i,1,len){
		h[i]=h[i-1]*P+str[i];
		p[i]=p[i-1]*P;
	}
}
ULL getstr(int l,int r,ULL h[]){
	return h[r]-h[l-1]*p[r-l+1];
}
void solve(){
	cin>>(s+1);
	int n=strlen(s+1);
	rep(i,1,n) t[i]=(s[i]=='0' ? '1' : '0');
	init(s,h1);
	init(t,h2);
	map<ULL,vector<int> > mp;
	rep(l,1,n){
		rep(r,l,n){
			ULL tmp=getstr(l,r,h2);
			mp[tmp].push_back(r);
		}
	}
	int ans=0;
	rep(l,1,n){
		rep(r,l,n){
			ULL tmp=getstr(l,r,h1);
			if(mp.find(tmp)!=mp.end()){
				for(auto lst_r:mp[tmp]){
					if(l>lst_r) ans++;
				}
			}
		}
	}
	cout<<ans;
}
```

---

## 作者：SatoruXia (赞：0)

其实可以利用遍历子串长度+遍历起点+遍历终点的方式，写出时间复杂度 $O(n^3)$ 的代码，不过这样显然无法过题。在不加剪枝的情况下，需将时间复杂度降至 $O(n^2)$。  
实际无需使用算法标签中的动规，考虑使用哈希表。  
首先预处理出全字符串反转后的情况。其次利用哈希，将**子串的反转信息**存储，以便查找匹配得上的子串。下一步便可注意到一点：如果一个子串已出现过，那么无需重新匹配，直接增加即可。当然，还要注意最重要的一点：**不相交**。未出现的话，直接将该子串存入哈希表即可。  
代码如下：

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;
int main() {
    //读入字符串
    string s;
    cin >> s;
    int n = s.size();
    int count = 0;
    //预处理每个位置的反转字符，即反转整个字符串
    string reversed(n, ' ');//其实该处也可用哈希表实现
    for (int i = 0; i < n; ++i) {
        reversed[i] = (s[i] == '0') ? '1' : '0';//也可使用if语句
    }
    // 枚举所有可能的子串长度
    for (int len = 1; len <= n / 2; ++len) {//注意n/2即可
        unordered_map<string, vector<int>> hash_map;//哈希表初始化
        //计算所有可能的反转情况
        for (int i = 0; i <= n - len; ++i) {
            string sub = s.substr(i, len);
            string target = reversed.substr(i, len);
            //检查之前是否出现过匹配的子串，减小复杂度
            if (hash_map.count(target)) {//已出现
                for (int pos : hash_map[target]) {//寻找出现位置
                    if (pos + len - 1 < i) {//确保不相交
                        count++;
                    }
                }
            }
            hash_map[sub].push_back(i);//将当前子串存入哈希表
        }
    }
    //输出
    cout << count << endl;
    return 0;
}
```

---

## 作者：lzx111218 (赞：0)

# P12346 [蓝桥杯 2025 省 A 第二场] 基因配对
[题目传送门](https://www.luogu.com.cn/problem/P12346)
## 思路
~~我红名掉橙了所以又来写题解了。~~

因为这题数据范围  $n \leq 1000$，跑 $O(n^4)$ 会炸所以考虑**预处理**。

1. 将所有可能的子串及其起始位置用哈希表存着，防止后续查找的时候 T 飞。


2. 查找的时候，对于每个子串，生成其反向子串。
**如果反向子串存在于哈希表中，则检查是否满足不相交条件**。


3. 确保两个子串的区间 $[a,b]$ 和 $[c,d]$ 不重叠，即 $b < c$ 或 $d < a$，否则重叠，直接跳过。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
string check1(string s){
    string t = s;
    for(char &c : t){
        c = (c == '0') ? '1' : '0';
    }
    return t;
}
int check2(string s){
    int n = s.size();
    int cnt = 0;
    unordered_map<string, vector<pair<int, int>>> m;
    for(int a = 0; a < n; a++){
        for(int b = a; b < n; b++){
            string sub = s.substr(a, b - a + 1);
            m[sub].emplace_back(a, b);
        }
    }
    for(int c = 1; c < n; ++c){
        for(int d = c; d < n; ++d){
            string sub = s.substr(c, d - c + 1);
            string rev = check1(sub);
            if(m.find(rev) != m.end()){
                for(auto& p : m[rev]){
                    int a = p.first;
                    int b = p.second;
                    if(b < c){
                        cnt++;
                    }
                }
            }
        }
    }
    return cnt;
}
int main(){
    cin >> s;
    cout << check2(s);
    return 0;
}
```

---


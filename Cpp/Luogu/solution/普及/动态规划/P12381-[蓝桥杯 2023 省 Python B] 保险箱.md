# [蓝桥杯 2023 省 Python B] 保险箱

## 题目描述

小蓝有一个保险箱，保险箱上共有 $n$ 位数字。

小蓝可以任意调整保险箱上的每个数字，每一次操作可以将其中一位增加 $1$ 或减少 $1$。

当某位原本为 $9$ 或 $0$ 时可能会向前（左边）进位/退位，当最高位（左边第一位）上的数字变化时向前的进位或退位忽略。

例如：

- $00000$ 的第 $5$ 位减 $1$ 变为 $99999$；
- $99999$ 的第 $5$ 位减 $1$ 变为 $99998$；
- $00000$ 的第 $4$ 位减 $1$ 变为 $99990$；
- $97993$ 的第 $4$ 位加 $1$ 变为 $98003$；
- $99909$ 的第 $3$ 位加 $1$ 变为 $00009$。

保险箱上一开始有一个数字 $x$，小蓝希望把它变成 $y$，这样才能打开它，问小蓝最少需要操作的次数。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 300$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 3000$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$x, y$ 中仅包含数字 $0$ 至 $9$，可能有前导零。

## 样例 #1

### 输入

```
5
12349
54321```

### 输出

```
11```

# 题解

## 作者：zhanghq2012 (赞：17)

本蒟蒻的第一篇题解，不喜勿喷

这道题就是一道~~难度不是特别大的~~ dp 题

## 思路

对于每一位都有 $3$ 种可能：
1.  进位。
1.  退位。
1.  不退不进。

 建立二维数组 $dp_{i,j}$，其中 $i$ 表示第几位，$j$ 表示第几种情况，然后动态规划。

状态转移方程（取最小值）：
1. 进位：$dp_{i,1} = \min(dp_{i-1,0} + 10 - x_i + y_i, dp_{i-1,1} + 9 - x_i + y_i, dp_{i-1,2} + 11 - x_i + y_i)$。
1. 退位：$dp_{i,2} = \min(dp_{i-1,0} + 10 - y_i + x_i, dp_{i-1,1} + 11 - y_i + x_i, dp_{i-1,2} + 9 - y_i + x_i)$。
1. 不进不退：$dp_{i,0} = \min(dp_{i-1,0} + |x_i - y_i|, dp_{i-1,1} + |x_i + 1 - y_i|, dp_{i-1,2} + |x_i - 1 - y_i|)$。
 

## AC代码


```cpp
#include <bits/stdc++.h>
using namespace std;

int dp[100005][3], x[100005] = {0}, y[100005] = {0};

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	string xx, yy;
	
    cin >> n >> xx >> yy;
    
    for (int i = 1; i <= n; i++){
	 
		x[i] = xx[n - i] - '0'; 
		y[i] = yy[n - i] - '0';
	}
	
	//进位 
    dp[1][1] = 10 - x[1] + y[1];
    //退位 
    dp[1][2] = 10 - y[1] + x[1];
    //不进不退 
    dp[1][0] = abs(x[1] - y[1]);
    
    for (int i = 2; i <= n; i++){
        // 进位
        dp[i][1] = min({dp[i-1][0] + 10 - x[i] + y[i], dp[i-1][1] + 9 - x[i] + y[i], dp[i-1][2] + 11 - x[i] + y[i]});
        // 退位
        dp[i][2] = min({dp[i-1][0] + 10 - y[i] + x[i], dp[i-1][1] + 11 - y[i] + x[i], dp[i-1][2] + 9 - y[i] + x[i]});
		// 不进不退
        dp[i][0] = min({dp[i-1][0] + abs(x[i] - y[i]), dp[i-1][1] + abs(x[i] + 1 - y[i]), dp[i-1][2] + abs(x[i] - 1 - y[i])});
    }
    cout << min({dp[n][0], dp[n][1], dp[n][2]});
    return 0;
}	
```

---

## 作者：Sweet_2013 (赞：6)

题目解析：给定两个 $n$ 位数字 $a$ 和 $b$，每次操作可以将 $a$ 的某一位数字增加或减少 $1$（$0-9$ 循环变化），求将 $a$ 变成 $b$ 所需的最小操作次数。（需要考虑进位和借位对相邻位的影响）

这道题可以用动态规划来来解决！

- 从右向左处理：从数字的最右边开始，逐步向左计算。因为右边的数字进位或借位可能会影响左边。
- 定义 $dp_{ij}$ 表示：
  - i：当前处理到第 $i$ 位（从右向左编号，$0$ 到 $n-1$）
  - j：当前位的进位状态，取值为 $0,1,2$，分别表示：
    - $0$：向高位借了 $1$ 位（相当于当前位减 $10$）。
    - $1$：正常状态（不进位也不借位）。
    - $2$：向高位进了 $1$ 位（相当于当前位加 $10$）。
- 对于每一位 $i$ 和每种状态 $j$，需要考虑：
  - 当前位的操作 $k（-9-9）$。
  - 下一位的状态 $t （0,1,2）$。
- 最后输出三种状态的最小值。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, dp[100005][3]; 
char a[100005], b[100005]; //a 数组是初始数字，b 数组是目标数字。
int main(){
    cin>> n>> a>> b; 
    memset(dp,0x3f,sizeof(dp)); //初始化为一个极大值，因为后面计算最小值需要。
    dp[n][1]=0; //这一位不需要进位或借位，所以赋成 0。
    for(int i=n-1;i>=0;i--) 
        //j 的循环：三种状态（借位、正常、进位）
        for(int j=0;j<3;j++) 
            // k 的循环：尝试对当前位进行 -9 到 +9 的所有可能操作。
            for(int k=-9;k<=9;k++) 
                //t 的循环：考虑下一位的三种状态。
                for(int t=0;t<3;t++) if(a[i]+k+t-1-b[i]==(j-1)*10) dp[i][j]=min(dp[i][j],dp[i+1][t]+abs(k));// 检查是否符合进/借位关系。
    cout<<min(dp[0][0],min(dp[0][1],dp[0][2]));//输出三种状态中的最小值。
    return 0;
}
```

---

## 作者：Helenty (赞：3)

依题意得，每一次操作可以将其中一位数字 $+1$ 或 $-1$。

注意：

> 当某位原本为 $9$ 或 $0$ 时可能会向前（左边）进位/退位，当最高位（左边第一位）上的数字变化时向前的进位或退位忽略。

显然的一道二维线性 DP 题。主要是要理解三个状态：不进不退、进位和退位。

第一维存目前到第几个了，第二位存当前的状态，即不进不退或进位或退位。


C++ 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, dp[100005][3], x[100005] = {0}, y[100005] = {0};
char x_str[100005], y_str[100005];

int main()
{
    cin >> n >> x_str >> y_str;
    for (int i = 1; i <= n; ++i) x[i] = x_str[n - i] - '0', y[i] = y_str[n - i] - '0';

    dp[1][0] = abs(x[1] - y[1]);  // 不进不退
    dp[1][1] = 10 - x[1] + y[1];  // 进位
    dp[1][2] = 10 - y[1] + x[1];  // 退位
    
    for (int i = 2; i <= n; ++i)
	{
        // 不进不退
        dp[i][0] = min({dp[i-1][0] + abs(x[i] - y[i]),dp[i-1][1] + abs(x[i] + 1 - y[i]),dp[i-1][2] + abs(x[i] - 1 - y[i])});
        
        // 进位
        dp[i][1] = min({dp[i-1][0] + 10 - x[i] + y[i],dp[i-1][1] + 9 - x[i] + y[i],dp[i-1][2] + 11 - x[i] + y[i]});
        
        // 退位
        dp[i][2] = min({dp[i-1][0] + 10 - y[i] + x[i],dp[i-1][1] + 11 - y[i] + x[i],dp[i-1][2] + 9 - y[i] + x[i]});
    }
    cout << min({dp[n][0], dp[n][1], dp[n][2]}) << endl;
    return 0;
}
```

Python 代码如下：


```python
n = int(input())
x = [0] + list(map(int, list(input())))[::-1]
y = [0] + list(map(int, list(input())))[::-1]
dp = [[0]*3 for _ in range(n+1)]
# 不进不退
dp[1][0] = abs(x[1]-y[1])
# 进位
dp[1][1] = 10 - x[1] + y[1]
# 退位
dp[1][2] = 10 - y[1] + x[1]

for i in range(2, n+1):
    # 不进不退
    dp[i][0] = min(dp[i-1][0]+abs(x[i]-y[i]), dp[i-1][1]+abs(x[i]+1-y[i]), dp[i-1][2]+abs(x[i]-1-y[i]))
    # 进位
    dp[i][1] = min(dp[i-1][0]+10-x[i]+y[i], dp[i-1][1]+9-x[i]+y[i], dp[i-1][2]+11-x[i]+y[i])
    # 退位
    dp[i][2] = min(dp[i-1][0]+10-y[i]+x[i], dp[i-1][1]+11-y[i]+x[i], dp[i-1][2] + 9 - y[i] + x[i])
print(min(dp[n][0],dp[n][1],dp[n][2]))
```

---

## 作者：chzhh_111 (赞：2)

考虑动态规划。

首先，如果我们设计的状态是从右到左进行转移的（既从最低位到最高位进行转移），那么根据题目当中的进位或者退位的描述，这样子的状态会对后续状态的转移产生影响，所以我们要从左到右进行转移（既从最高位到最低位进行转移），那这样子产生的影响就是对前面的状态产生的影响，这是可以处理的。

所以根据题意，我们可以设计出一个状态，为 $dp_{i,0/1/2}$，以下为状态解释（根据上面的解释，以下的前 $i$ 个表示从左数到右的前 $i$ 个，同理位数也是一样的）：

- $dp_{i,0}$ 表示 $x$ 的前 $i$ 个数字都与 $y$ 一样，且在操作之前，第 $i$ 位数字不发生任何进位或退位的操作，所需要的最少步数。

- $dp_{i,1}$ 表示 $x$ 的前 $i$ 个数字都与 $y$ 一样，且在操作之前，第 $i$ 位数字发生**一次**退位的操作，所需要的最少步数。

- $dp_{i,2}$ 表示 $x$ 的前 $i$ 个数字都与 $y$ 一样，且在操作之前，第 $i$ 位数字发生**一次**进位的操作，所需要的最少步数。

对于上面退位和进位状态的解释，这个**一次**就是说如果发生多次的话，你就相当于用更加多的步数换取用更加少的步数就能达到的效果，这肯定是不优的，而对于下文相等情况下的转移，也能这样子解释。

而对于第一种状态的状态转移方程要分类讨论（以下用 $a$ 表示 $x$ 第 $i$ 位的数字，用 $b$ 表示 $y$ 第 $i$ 位的数字，用 $\operatorname{up}(a,b)$ 表示从 $a$ 到 $b$ 在**一定得操作**的情况下，只用加得花多少步数，用 $\operatorname{down}(a,b)$ 表示从 $a$ 到 $b$ 在**一定得操作**的情况下，只用减得花多少步数）：

- 当 $a<b$ 时，$dp_{i,0}= \min(dp_{i-1,0}+\operatorname{up}(a,b),dp_{i-1,1}+\operatorname{down}(a,b))$。

- 当 $a>b$ 时，$dp_{i,0}= \min(dp_{i-1,2}+\operatorname{up}(a,b),dp_{i-1,0}+\operatorname{down}(a,b))$。

- 当 $a=b$ 时，$dp_{i,0}=dp_{i-1,0}$。

而对于其他状态的状态转移方程，若变化之后的值并没有对前面的状态产生影响，其动态转移方程就是上面所列的，可以直接调用。

那发生变化了呢？(以下用 $aa$ 表示变化过后 $x$ 第 $i$ 位的数字)

对于退位，如果发生变化了，那肯定这一位的数字就变成了 $9$，那其动态转移方程就是：

- 当 $aa \ne b$ 时，$dp_{i,1}= \min(dp_{i-1,1}+\operatorname{down}(aa,b),dp_{i-1,0}+\operatorname{up}(aa,b))$。

- 当 $aa=b$ 时，$dp_{i,1}=dp_{i-1,1}$。

对于进位，如果发生变化了，那肯定这一位的数字就变成了 $0$，那其动态转移方程就是：

- 当 $aa \ne b$ 时，$dp_{i,2}= \min(dp_{i-1,2}+\operatorname{up}(aa,b),dp_{i-1,0}+\operatorname{down}(aa,b))$。

- 当 $aa=b$ 时，$dp_{i,2}=dp_{i-1,2}$。

一开始，除了第 $0$ 位上的 $dp$ 数组全部为 $0$ 以外，其他的全是为无穷大。

最后的答案就是 $dp_{n,0}$，因为显然第 $n$ 位肯定不会受到任何影响。

代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+1;
int n,dp[N][3];
char x[N],y[N];
int up(int a,int b) {return (b-a+10)%10;}
int down(int a,int b) {return (a-b+10)%10;}
void DP(int a,int b,int i,int h)//上文所提到的那三个通用式子 
{
	if(a<b) dp[i][h]=min(dp[i-1][0]+up(a,b),dp[i-1][1]+down(a,b));
	if(a>b) dp[i][h]=min(dp[i-1][2]+up(a,b),dp[i-1][0]+down(a,b));
	if(a==b) dp[i][h]=dp[i-1][0];
}
signed main()
{
	scanf("%lld\n%s\n%s",&n,x+1,y+1);
	memset(dp,127/3,sizeof(dp));//初始化 - 无穷大
	dp[0][0]=dp[0][1]=dp[0][2]=0;//初始化 - 全是零
	for(int i=1;i<=n;i++)
	{
		int a=x[i]-'0',b=y[i]-'0';
		DP(a,b,i,0);
		int aa=(a+9)%10;
		if(aa==9)
		{
			if(aa!=b) dp[i][1]=min(dp[i-1][1]+down(aa,b),dp[i-1][0]+up(aa,b));
			else dp[i][1]=dp[i-1][1];
		}
		else DP(aa,b,i,1);
		aa=(a+1)%10;
		if(!aa)
		{
			if(aa!=b) dp[i][2]=min(dp[i-1][2]+up(aa,b),dp[i-1][0]+down(aa,b));
			else dp[i][2]=dp[i-1][2];
		}
		else DP(aa,b,i,2);
	}
	printf("%lld",dp[n][0]);
	return 0;
}
```

---

## 作者：_ChongYun_ (赞：2)

小分讨。

### Solution

设 $dp_{i,0/1/2}$ 分别表示第 $i$ 位不进退位、进位、退位的最小代价。考虑从右向左转移，对于便历到的一个位置 $1\le i \le n$：

- 若上一位进位，该位 $a_i \leftarrow a_i+1 $。

- 若上一位退位，该位 $a_i \leftarrow a_i-1 $。

- 若上一位不进退位，该位不变。

由于即使减到负数，也可以通过进退位操作抵消，不影响操作次数，则：

- 若该位进位，代价为 $|a_i-(b_i+10)|$。

- 若该位退位，代价为 $|a_i-(b_i-10)|$。

- 若该位不进退位，代价为 $|a_i-b_i|$。

为了方便转移，我们可以令 $x,y$ 的第 $n+1$ 位为 $0$。

所以初始有 $dp_{n+1,1}=dp_{n+1,2}=\mathrm{inf}$。

### Code


```cpp
/* ChongYun */
#include<bits/stdc++.h>
#define START_LL 1
using namespace std;
#define start(x) using namespace x
#if START_LL 
#define int long long
#endif
#define ldb double
namespace IO{
    #define flush() fwrite(obuf,1,O-obuf,stdout)
    #define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
    char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
    #define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
    inline int read(){
        register int x=0,f=1;
        register char ch=getchar();
        while(ch<'0'||ch>'9'){
            if(ch=='-') f=-1;
            ch=getchar();
        }
        while(ch>='0'&&ch<='9'){
            x=(x<<1)+(x<<3)+(ch^48);
            ch=getchar();
        }
        return x*f;
    }
    inline void write(int x){
        if(x>9) write(x/10);
        putchar((x%10)^48);
        return ;
    }
    struct Flush{ ~Flush(){flush();} }_;
}start(IO);
const int N=1e5+5;
int n,a[N],b[N],dp[N][3];
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        char ch=getchar();
        while(ch<'0'||ch>'9') ch=getchar();
        a[i]=ch-'0';
    }
    for(int i=1;i<=n;i++){
        char ch=getchar();
        while(ch<'0'||ch>'9') ch=getchar();
        b[i]=ch-'0';
    }
    dp[n+1][1]=dp[n+1][2]=1e18;
    for(int i=n;i>=1;i--){
        dp[i][0]=min(dp[i+1][0]+abs(a[i]-b[i]),min(dp[i+1][1]+abs(a[i]+1-b[i]),dp[i+1][2]+abs(a[i]-1-b[i])));
        dp[i][1]=min(dp[i+1][0]+abs(a[i]-10-b[i]),min(dp[i+1][1]+abs(a[i]-9-b[i]),dp[i+1][2]+abs(a[i]-11-b[i])));
        dp[i][2]=min(dp[i+1][0]+abs(a[i]+10-b[i]),min(dp[i+1][1]+abs(a[i]+11-b[i]),dp[i+1][2]+abs(a[i]+9-b[i])));
    }
    write(min(dp[1][0],min(dp[1][1],dp[1][2]))),putchar('\n');
    return 0;
}
```

---

## 作者：bayiran (赞：1)

一道 DP 题，个人感觉和[金明的预算方案](https://www.luogu.com.cn/problem/P1064)差不多。

### 思路

对于每一位，都有 $3$ 种可能：

1. 进一位。
2. 退一位。
3. 不进不退。

建立二维数组 $dp_{i,j}$，其中 $i$ 表示第几位，$j$ 表示第几种情况，然后进行动态规划。

如果上一位（右一位）进位，则本位加一，退位则减一。

接下来判断本位的三种情况，对于每种情况取最小值。

状态转移方程为:

$$
dp_{i,0} = \text{min}((dp_{i-1,0}+|a_i-b_i|),(dp_{i-1,1}+|a_i-b_i+1|),(dp_{i-1,2}+|a_i-b_i+1|))
$$

$$
dp_{i,1}= \text{min}((dp_{i-1,0}+10-a_i+b-i),(dp_{i-1,1}+9-a_i+b_i),(dp_{i-1,2}+11-a_i+b_i))
$$

$$
dp_{i,2} = \text{min}((dp_{i-1,0}+10-b_1+a_1), (dp_{i-1,1}+11-b_i+a_i),(dp{i-1,2}+9-b_i+a_i))
$$

上代码。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    char a[100000],b[100000];
    cin>>n;
    for(int i=n-1;i>=0;i--){
        cin>>a[i];
        a[i] -= '0';
    }
    for(int i=n-1;i>=0;i--){
        cin>>b[i];
        b[i] -= '0';
    }
    int dp[100000][3] = {0};
    dp[0][0] = abs(a[0] - b[0]);
    dp[0][1] = b[0] - a[0] + 10;
    dp[0][2] = a[0] - b[0] + 10;
    for(int i=1;i<n;i++){
        dp[i][0] = min(min(dp[i-1][0]+abs(a[i]-b[i]),dp[i-1][1]+abs(a[i]+1-b[i])),dp[i-1][2]+abs(a[i]-1-b[i]));
        dp[i][1] = min(min(dp[i-1][0]+10-a[i]+b[i],dp[i-1][1]+9-a[i]+b[i]),dp[i-1][2]+11-a[i]+b[i]);
        dp[i][2] = min(min(dp[i-1][0]+10-b[i]+a[i], dp[i-1][1]+11-b[i]+a[i]),dp[i-1][2]+9-b[i]+a[i]);
    }
    cout<<min(min(dp[n-1][0],dp[n-1][1]),dp[n-1][2]);
    return 0;
}
```

---

## 作者：true_kun (赞：0)

###### 思路
我们不难发现，对于每一个对应位置的 $a_i$ 转移到 $b_i$ 都存在三种情况：
1. $a_i$ 向前进位一位后得到 $b_i$。
2. $a_i$ 不进位也不退位得到 $b_i$。
3. $a_i$ 被借走一位后得到 $b_i$。

我们设 $dp_{i,j}$ 表示使得 $i$ 到 $n$ 全部放好，对第 $i-1$ 位贡献为 $j-1$ 的最少操作次数。

对于不同的进位结果我们选择不同的转移方式：

$t$ 表示进或退后第 $i$ 位上的数字（可以为 $10$ 和 $-1$）。

1. 当第 $i$ 个位置向前进位时。

$$dp_{i,2}=\min(dp_{i,2},dp_{i+1,j}+b_i+10-t)$$

2. 当第 $i$ 个位置不向前借位进位时。 

$$dp_{i,1}=\min(dp_{i,1},dp_{i+1,j}+|b_i-t|$$

3. 当第 $i$ 个位置向前借位时。

$$dp_{i,0}=\min(dp_{i,0},dp_{i+1,j}+t+10-b_i)$$

最后统计 $i=1$ 时最小的 $dp$ 值即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[100005][5];
char ca[100005],cb[100005];
int a[100005],b[100005];
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>ca[i];
	for(int i=1;i<=n;i++) cin>>cb[i];
	for(int i=1;i<=n;i++) a[i]=ca[i]-'0',b[i]=cb[i]-'0';
	for(int i=1;i<=n;i++){
		for(int j=0;j<=2;j++) dp[i][j]=1e6;
	}
	for(int i=n;i>=1;i--){
		for(int j=0;j<=2;j++){
			for(int k=0;k<=2;k++){
				int t=a[i]+j-1;
				if(i==n) t=a[i];
				if(k==2) dp[i][k]=min(dp[i][k],dp[i+1][j]+b[i]+10-t);
				if(k==1) dp[i][k]=min(dp[i][k],dp[i+1][j]+abs(b[i]-t));
				if(k==0) dp[i][k]=min(dp[i][k],dp[i+1][j]+t+10-b[i]);
			}
		}
	}
	int ans=1e6;
	for(int i=0;i<=2;i++) ans=min(ans,dp[1][i]);
	cout<<ans;
	return 0;
} 
```

---

## 作者：Hy13_xsm (赞：0)

一道很清新的 dp 题。

## 题意概述

有一个 $n$ 位数字密码锁，每一次可以将数字加一或者减一。如果某一位数字是 $0$，那么进行减一操作后数字变成 $9$，并且前一位数字减一，类似于减法退位；如果某一位数字是 $9$，那么进行加一操作后数字变成 $0$，并且前一位数字加一，类似于加法进位。求至少操作多少次能把原数字串 $s$ 变成 $t$。

## Solution

不难发现，这里如果同一个数字一直循环转圈是没有意义的，要么不进不退，要么就是进位或者退位 $1$ 次，可以据此列出状态转移方程。

将不进不退定义成操作 $0$，进位定义成操作 $1$，退位定义成操作 $2$。模拟一遍进退位时其他位的变化，可以很容易列出如下方程：


```cpp
dp[i][0]=cal(dp[j][0]+abs(a[i]-b[i]),dp[j][1]+abs(a[i]+1-b[i]),dp[j][2]+abs(a[i]-1-b[i]));
dp[i][1]=cal(dp[j][0]+abs(10-a[i]+b[i]),dp[j][1]+abs(10-a[i]-1+b[i]),dp[j][2]+abs(10-a[i]+1+b[i]));
dp[i][2]=cal(dp[j][0]+abs(a[i]+10-b[i]),dp[j][1]+abs(a[i]+10+1-b[i]),dp[j][2]+abs(a[i]+10-1-b[i]));
```
以上 `cal` 函数表示三者中的最小值，$j=i+1$，$a$ 是原序列，$b$ 是修改后的序列。

至此，这个问题就解决了，希望对学习 dp 的同学有帮助。

---

## 作者：Lagrange_NoAria (赞：0)

# 洛谷 P12381 题解

## 题意分析

### 转化题目

题目给了一个长度为 $n$ 的字符串 $x$ 和 $y$，求转换的步数（当然，$n$ 需要输入）。

### 特殊性

当某位原本为 9 或 0 时可能会向前（左边）进位/退位，当最高位（左边第一位）上的数字变化时向前的进位或退位忽略。

## 解题过程

每一位都有不进不退、进位和退位三种可能。我们可以判断本位的情况，对其取最小值。当然，如果上一位（右一位）进位，则本位加一，退位则减一。

### 数据结构

我们可以设一个二维数组 $dp$。其中，$dp[][0]$ 表示不进不退的最小代价，$dp[][1]$ 表示进位的最小代价，$dp[][2]$ 表示。

### 需要注意的

1. 我们需要将输入的两个字符串分别转化为整数数组。
2. 在转换数组的时候，可不能按一般方法，而是逆向转换。

### 错误示范


```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[100005][3],x[100005],y[100005];
int main(){
    int n;
    string xs,ys;
    cin>>n>>xs>>ys;
    for(int i = 1; i <= n; ++i){
        x[i]=xs[i-1]-'0';
        y[i]=ys[i-1]-'0';
    }//错误在这，不改没法过
    dp[1][0]=abs(x[1]-y[1]);
    dp[1][1]=10-x[1]+y[1];
    dp[1][2]=10-y[1]+x[1];
    for(int i = 2; i <= n; ++i){
        dp[i][0] = min({dp[i-1][0] + abs(x[i] - y[i]),dp[i-1][1] + abs(x[i] + 1 - y[i]),dp[i-1][2] + abs(x[i] - 1 - y[i])});
        dp[i][1] = min({dp[i-1][0] + 10 - x[i] + y[i],dp[i-1][1] + 9 - x[i] + y[i],dp[i-1][2] + 11 - x[i] + y[i]});
        dp[i][2] = min({dp[i-1][0] + 10 - y[i] + x[i],dp[i-1][1] + 11 - y[i] + x[i],dp[i-1][2] + 9 - y[i] + x[i]});
    }
    cout<<min({dp[n][0], dp[n][1], dp[n][2]});
    return 0;
}
```
很好，犯了如上所述的错误。

### 正确解法

不管了，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[100005][3],x[100005],y[100005];
int main(){
    int n;
    string xs,ys;
    cin>>n;
    cin>>xs>>ys;
    for(int i = 1; i <= n; ++i){
        x[i]=xs[n-i]-'0';
        y[i]=ys[n-i]-'0';
    }
    dp[1][0]=abs(x[1]-y[1]);
    dp[1][1]=10-x[1]+y[1];
    dp[1][2]=10-y[1]+x[1];
    for(int i = 2; i <= n; ++i){
         dp[i][0] = min({dp[i-1][0] + abs(x[i] - y[i]),dp[i-1][1] + abs(x[i] + 1 - y[i]),dp[i-1][2] + abs(x[i] - 1 - y[i])});
        dp[i][1] = min({dp[i-1][0] + 10 - x[i] + y[i],dp[i-1][1] + 9 - x[i] + y[i],dp[i-1][2] + 11 - x[i] + y[i]});
        dp[i][2] = min({dp[i-1][0] + 10 - y[i] + x[i],dp[i-1][1] + 11 - y[i] + x[i],dp[i-1][2] + 9 - y[i] + x[i]});
    }
    cout<<min({dp[n][0], dp[n][1], dp[n][2]});
    return 0;
}
```
一改，过了。

## 总结

一道经典的压缩动态规划题目。

---


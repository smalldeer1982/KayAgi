# [KOI 2023 Round 1] 格子游戏

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

韩果和正奥在一个格子状的棋盘上轮流移动棋子进行游戏，韩果先手。不能跳过自己的回合。

棋盘由 $N$ 行 $M$ 列构成，部分格子被封锁，不能移动到这些格子上。为方便起见，记从上往下的第 $i$ 行与从左往右的第 $j$ 列交汇的格子为 $(i, j)$。

棋子每次可以向下移动一格、向右移动一格，或者沿右下方向移动 $1$ 到 $K$ 格（即 $(1, 1)$ 到 $(K, K)$ 的任意一个方向）。但不能移动出棋盘或进入封锁格子中。如果 $K = 0$，则不能进行对角线方向的移动。

我们来看看与移动规则相关的几个例子：

假设 $N = 6$，$M = 8$，$K = 3$，且棋盘上没有封锁的格子。此时位于 $(2, 3)$ 的棋子可移动到的格子共有 5 个，如下图用 O 表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/qa4dks8j.png)

如果再假设 $(2, 4)$ 和 $(4, 5)$ 是封锁格子，那么位于 $(2, 3)$ 的棋子可移动到的格子变成 3 个，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1tarwy2.png)

接下来我们再看两个示例：

- 若棋子位于 $(5, 7)$，$N = 6$，$M = 8$，$K = 3$，无封锁格子，则可以移动到的格子数为 $3$，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/psit6x9o.png)
- 若棋子位于 $(1, 1)$，$K = 0$，无封锁格子，则可移动到的格子为 $2$ 个，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/aovxlo5j.png)

游戏的目标是将棋子移动到棋盘最右下角的格子，即 $(N, M)$。最后一个完成移动的人获胜。假设韩果和正奥都会以最优策略进行游戏。

游戏的胜负与初始位置有关。给出 $Q$ 个初始位置 $(x_1, y_1), (x_2, y_2), \dots, (x_Q, y_Q)$，请判断从这些位置开始游戏，谁将获胜。

## 说明/提示

**限制条件**

- 所有给定值均为整数。
- $2 \leq N \leq 300$
- $2 \leq M \leq 300$
- $K \geq 0$
- $K \leq N - 1$
- $K \leq M - 1$
- $(N, M)$ 不是封锁格子。
- 从任意未封锁格子出发，根据规则都可以到达 $(N, M)$。
- $1 \leq Q \leq 300$
- 对于每个 $1 \leq i \leq Q$：
  - $1 \leq x_i \leq N$，$1 \leq y_i \leq M$
  - $(x_i, y_i)$ 是未封锁格子，且不等于 $(N, M)$
  
**子问题**

1. （5 分）$K = 0$
2. （17 分）$N = M$ 且 $K \geq 1$，满足 $i \ne j$ 的格子均为封锁格子。
3. （25 分）无封锁格子。
4. （53 分）无额外限制。

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2 2 0
.#
..
2
1 1
2 1```

### 输出

```
Second
First```

## 样例 #2

### 输入

```
2 2 1
..
..
1
1 1```

### 输出

```
First```

## 样例 #3

### 输入

```
3 4 0
....
.#..
....
1
3 2```

### 输出

```
Second```

# 题解

## 作者：lcfollower (赞：1)

膜拜题解区巨佬 $\mathcal O(nmk)$ 做法，蒟蒻只会 $\mathcal O(nmk\log k)$，但是吸氧还是妥妥的过好吧（算出来最大大概为 $2\times 10^8$ 多）。

因为只能往右边、下边和右下走，所以我们可以从 $(i,j)$ 到可以到达的点连一条有向边，建出来的图为 DAG，这个 DP 的无后效性是一个道理。

然后学过**生成函数 SG** 的人，一看这就是板子。

关于 SG 函数的内容，可见[这里](https://oi-wiki.org/math/game-theory/impartial-game/#%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F%E4%B8%8E-sg-%E5%87%BD%E6%95%B0)。

对于这题，里面最关键的话：

> 对于状态 $x$ 和它的所有 $k$ 个后继状态 $y_1$，$y_2$，$\ldots$，$y_k$，定义 $\operatorname{SG}$ 函数：
> 
> $$\operatorname{SG}(x)=\operatorname{mex}\{\operatorname{SG}(y_1), \operatorname{SG}(y_2), \ldots, \operatorname{SG}(y_k)\}$$
> 
> 而对于由 $n$ 个有向图游戏组成的组合游戏，设它们的起点分别为 $s_1$，$s_2$，$\ldots$，$s_n$，则有定理：当且仅当 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \ldots \oplus \operatorname{SG}(s_n) \neq 0$ 时，这个游戏是先手必胜的。同时，这是这一个组合游戏的游戏状态 $x$ 的 SG 值。

证明下面有。

那么我们只要对于每个 $(i ,j)$，找到其合法的后继，然后求出它们 SG 值的 mex 就可以了。

求 mex 可以升序排序然后求：

```cpp
sort (b + 1 ,b + 1 + cnt);//排序。
int tot = unique (b + 1 ,b + 1 + cnt) - b - 1;//去重。
//这是为了去除比如后继的 SG 值为 0 1 1 1 1 2 等的情况。
int mex = tot;
up (i ,1 ,tot) if (b[i] != i - 1) {mex = i - 1 ; break;}//不符合 0，1，2，……自然数排列，这个数就是 mex。
//如果没有更改 mex 就为 tot，上面赋值过了。
```

但是考虑到可能的后继都在**点的右下方**，后继当然需要保证求过 SG 值，所以需要倒着做。

最终，如果 $\operatorname{SG}(x,y) \neq 0$，则先手胜；否则后手胜。

代码
---

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e14
 
using namespace std;
 
inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

const int N = 305;
int n ,m ,k ,Q ,b[N + 10] ,sg[N][N];
char a[N][N];

inline void init (){
  sg[n][m] = 0;
  dn (i ,n ,1) {
    dn (j ,m ,1) {
      if (i == n && j == m) continue;
      if (a[i][j] == '#') continue;
      int cnt = 0;
      /* 找可能的后继的 SG 值。*/
      if (i < n && a[i + 1][j] != '#') b[++ cnt] = sg[i + 1][j];
      if (j < m && a[i][j + 1] != '#') b[++ cnt] = sg[i][j + 1];
      up (d ,1 ,k){
        int ax = i + d ,ay = j + d;
        if (ax > n || ay > m) break;
        if (a[ax][ay] != '#') b[++ cnt] = sg[ax][ay];
      } /* 求 mex。*/
      sort (b + 1 ,b + 1 + cnt);
      int tot = unique (b + 1 ,b + 1 + cnt) - b - 1;
      int mex = tot;
      up (i ,1 ,tot) if (b[i] != i - 1) {mex = i - 1 ; break;}
      sg[i][j] = mex;
    }
  }
} signed main (){

  n = read () ,m = read () ,k = read ();
  up (i ,1 ,n) up (j ,1 ,m) cin >> a[i][j];

  init ();

  Q = read ();
  while (Q --) {
    int x = read () ,y = read ();
    if (sg[x][y]) puts ("First");
    else puts ("Second");
  }
  return 0 ;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 题意简述
两名玩家在 $N$ 行 $M$ 列的棋盘上轮流移动棋子。棋子每次可以：
1. 向下移动一格。
2. 向右移动一格。
3. 沿右下对角线移动 $1$ 到 $K$ 格（$K=0$ 时禁用此操作）。

不能移动到封锁格子或超出棋盘边界。游戏目标是将棋子移动到右下角 $(N,M)$，最后移动者获胜。给定 $Q$ 个初始位置，需要判断每个位置下先手是否能必胜。

### 关键点：

- 棋盘可能有障碍物。
- 移动规则包含三种方向。
- $K$ 值决定对角线移动距离。
- 采用博弈论最优策略。
- 需要判断多个初始位置的胜负。

### 输出要求：
对于每个查询位置，输出“First”（先手胜）或“Second”（后手胜）。
# 思路
这是一个典型的博弈论问题，我们可以用动态规划解决此问题。 $\\$ 
既然是动态规划，那三要素可不能少。
## 状态
我们定义一个布尔类型的 $dp$ 数组，$dp_{i,j}$ 表示到达了这个点是必胜点还是必败点。到时候需要询问的时候查询一下 $dp$ 数组就行了。 $\\$ 
**必胜点的定义**：如果从必胜点开始走，怎么走都会输，也就是走到的都是必败点，那么称这个点为必胜点，反之则为必败点。
## 边界
边界其实很容易确定，很明显，如果都到达终点了，那游戏肯定赢了呀。所以初始化 $dp_{n,m}$ 为必胜点。 
## 转移
终于到达了设计动态规划中最难的一环，但由于这题出的比较简单，这里转移还是很好想到的。这里题目已经说的很清楚了，不难想到，$dp_{i,j}$ 可以由 $dp_{i+1,j}$ 和 $dp_{i,j+1}$，还有 $dp_{i+1,j+1},dp_{i+2,j+2},\dots,dp_{i+k,j+k}$ 转移而来。他们之中只要由一个值为真，也就是必胜点，那么 $dp_{i,j}$ 就为假。为什么我会这么说，因为如果此时的一方走到了这个点，那么另一方就一定可以走到一个必胜点，那么这个点就是一个必败点。    
 $\\$ 
 
具体步骤看代码。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=305;
char a[maxn][maxn];
bool dp[maxn][maxn];
int n,m,k,q;
int main()
{
	cin>>n>>m>>k;
	dp[n][m]=true;//初始化
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);//读入从(1,1)开始的字符矩阵
	for(int j=m;j;j--)
	for(int i=n;i;i--)//倒着枚举，因为边界点在(n,m)
	 {
	 	if(a[i][j]=='#') continue;//如果是封锁点，跳过。
	 	bool res=false;
	 	res|=dp[i+1][j];res|=dp[i][j+1];
	 	for(int l=1;l<=k;l++)//枚举k
	 	 {
	 	 	if(i+l>n||j+l>m) break;//越界了，则终止
	 	 	res|=dp[i+l][j+l];
	 	 }
	 	dp[i][j]=!res;//一定要取反
	 }
	cin>>q;
	while(q--)
	 {
	 	int x,y;
	 	cin>>x>>y;
	 	if(dp[x][y]) cout<<"Second";
	 	else cout<<"First";
      /*这里需要重点讲一下，如果这个点是必胜点，那么根据状态的定义，
        从必胜点开始走，走到的所有点都是必败点。所以如果先手先走，那
        么怎么走都是必败点，所以后手有必胜策略。反之则是先手有必胜策略。*/
	 	cout<<"\n";
	 }
	return 0;
}
```

---

## 作者：XuZile (赞：0)

# P12658 题解
## 前言
接下去介绍一种时间复杂度为 $O(nmk)$ 的做法。个人感觉挺好理解的。
## 思路介绍
我们可以经过一个简单的思考会发现如果以一个点为起点时，以右边的位置或者下面的位置或者右下角 $k$ 个位置中有任意一个位置为起点时是后手胜，那么现在这个就是先手胜。反之亦然。

得出这个结论后，我们就可以从后往前倒着进行预处理，得出将各个点是先手胜还是后手胜。

最后根据起点的位置。直接输出是先手胜，还是后手胜。
## 代码实现
注意：$dp_{i,j}=0$ 时表示先手必胜。

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[305][305];
bool dp[305][305];
int n,m,k,q;
int main(){
	cin>>n>>m>>k;
	dp[n][m]=1;
	for(int i=1;i<=n;i++) cin >> a[i]+1;
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			if(a[i][j]=='#') continue;
			if(i==n&&j==m) continue;
			bool flag=0;
			if(dp[i+1][j]&&i!=n) flag=1;
			else if(dp[i][j+1]&&j!=m) flag=1;
			else if(k){
				for(int z=1;z<=k;z++){
					if(i+z>n||j+z>m) break;
					if(a[i+z][j+z]=='#') continue;
					if(dp[i+z][j+z]){
						flag=1;break;
					}
				}
			}
			if(flag) dp[i][j]=0;
			else dp[i][j]=1;
		}
	}
	int q;
	cin>>q;
	for(int i=1;i<=q;i++){
		int x,y;
		cin >> x >> y;
		if(!dp[x][y]) cout << "First\n";
		else cout << "Second\n";
	}
	return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：0)

逆向思维。

## 思路
根据题目条件和数据约束，每个起始位置要么先手胜要么先手负，不会有无法到达的情况。如果一个位置先手胜，那么它的获胜路径上先手的每一个开始位置都是先手胜的，每一个落子位置都是先手负的。显然有终点的上方和左方是先手胜的，不妨把终点处理成先手负，那么右边和下边就是交替的先手胜和负。

从最右和最下开始往左边和上边遍历，对于当前位置，遍历所有可达的位置，只要找到了一个先手负的位置，那么当前位置就是先手胜的。遍历的起始位置是在从终点出发的那条对角线上，依次遍历完整个图，每次判断需要 $O(k)$，整体时间复杂度 $O(NMK)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n, m, k;
	cin >> n >> m >> k;
	vector<vector<int>> dp(n, vector<int>(m, -1));//1表示先手胜,0表示后手胜
	vector<vector<int>> G(n, vector<int>(m));
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < m; ++j) {
			char ch;
			cin >> ch;
			switch (ch) {
			case '.':
				G[i][j] = 0;
				break;
			case '#':
				G[i][j] = 1;
				break;
			}
		}
	}
	dp.back().back() = 0;//特殊处理,实际起始位置不会在这
	for (int j = m - 2; j >= 0; --j) {
		if (G.back()[j] == 1) {
			break;
		}
		dp.back()[j] = 1 - dp.back()[j + 1];
	}
	for (int i = n - 2; i >= 0; --i) {
		if (G[i].back() == 1) {
			break;
		}
		dp[i].back() = 1 - dp[i + 1].back();
	}

	auto check = [&](int x, int y) {
		if ((G[x + 1][y] == 0 && dp[x + 1][y] == 0) || (G[x][y + 1] == 0 && dp[x][y + 1] == 0)) {
			return 1;
		}
		for (int i = 1; i <= k && x + i < n && y + i < m; ++i) {
			if (G[x + i][y + i] == 0 && dp[x + i][y + i] == 0) {
				return 1;
			}
		}
		return 0;
		};

	pair<int, int> loc = { n - 1,m - 1 };
	while (loc.first > 0 && loc.second > 0) {
		--loc.first;
		--loc.second;
		dp[loc.first][loc.second] = check(loc.first, loc.second);
		for (int x = loc.first - 1; x >= 0; --x) {
			dp[x][loc.second] = check(x, loc.second);
		}
		for (int y = loc.second - 1; y >= 0; --y) {
			dp[loc.first][y] = check(loc.first, y);
		}
	}
	int q;
	cin >> q;
	for (int i = 0; i < q; ++i) {
		int x, y;
		cin >> x >> y;
		cout << (dp[x - 1][y - 1] == 1 ? "First\n" : "Second\n");
	}

	return 0;
}
```

---


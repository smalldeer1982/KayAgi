# [KOI 2022 Round 1] 鹅卵石

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在一排左右排列的 $N$ 个地点中，每个地点上都放有若干个鹅卵石。

哲洙可以进行的操作有以下两种：

1. 从相邻的两个地点中，拿走任意相同数量的鹅卵石；
2. 从一个地点中，拿走任意数量的鹅卵石。

即使某个地点上的鹅卵石被拿完，该地点依旧保留，两个原本不相邻的地点不会因此变得相邻。

哲洙会不断重复执行上述两种操作中的一种，直到将所有鹅卵石都拿走。

给定每个地点初始时的鹅卵石数量，请编写一个程序，计算哲洙最少需要多少次操作，才能拿走所有鹅卵石。

## 说明/提示

**约束条件**

- $2 \leq N \leq 2500$
- 每个地点初始的鹅卵石数量为不小于 1 且不超过 $10^8$ 的整数

**子任务**

1. （6 分）$N = 3$
2. （11 分）$N \leq 15$
3. （19 分）$N \leq 300$
4. （27 分）每个地点的初始鹅卵石数量不超过 2500
5. （37 分）无额外约束条件

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4
1 1 3 3```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 4 3```

### 输出

```
2```

## 样例 #4

### 输入

```
5
2 3 6 10 5```

### 输出

```
4```

# 题解

## 作者：true_kun (赞：3)

设 $dp_i$ 表示拿走 $1$ 到 $i$ 的所有石子需要的最少步数。

显然进行操作 2 如果可以使拿走全部石子，这将会使我们拿石子的步数变少，优化选石子的过程。我们暴力的去寻找一个 $j$，使得 $j$ 到 $i$ 这一段可以只通过操作 2 来拿走全部石子。

则有转移： 
$$dp_i=\min(dp_i,dp_{j-1}+i-j)$$

如何判断是否可以只通过操作 2 来拿走全部石子呢？我们考虑操作 2 拿走的石子数量与左边或者右边有关，如果我们从最右侧（即 $i$）开始向左推进 2 过程，则因为将右侧的点全部拿光，所以一个点拿走后只会对左边的点产生贡献。因为只使用操作 2 拿光，并且希望只用 $i-j$ 次，所以经过一次操作 2 后当前点的石子数应该为 $0$，那么这个点**左边的点的石子数就应该减去当前点石子数**（与当前点一起拿走），如果这个点左边的石子数没有这个点的石子数大，那么当前点由于右侧已经没有石子了，其必定不能只通过过程 2 清空，其左边的区间自然也就不必考虑了。

代码见下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[2505],a[2505],b[2505];//考虑到第i个位置，i前面的所有数都被拿走的最小步数 
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		int point=1;
		dp[i]=dp[i-1]+1;
		for(int j=1;j<=i;j++)b[j]=a[j];
		for(int j=i;j>=1;j--){
			b[j-1]-=b[j];
			if(b[j-1]<0){point=j;break;}
		}
		for(int j=point;j<=i;j++){
			if(b[j]==0)dp[i]=min(dp[i],dp[j-1]+i-j);
		}
	} 
	cout<<dp[n];
	return 0;
} 
```

---

## 作者：Sunrise_up (赞：3)

好难，卡了好久。

## 简化题意

给定一个长度为 $n$ 的数组 $a$ ，$a_i$ 表示第 $i$ 堆的石子数量，每次可对 $a$ 中位置相邻的两堆同时拿相同数量的石子，或单堆拿任意数量的石子，求将所有石子拿完时所需的最少操作次数。
## 解法

首先单堆拿任意数量的石子，我们肯定是全部拿最好的。

我们肯定是先做第一个操作是最好的，因为题目是求操作次数，这可以让操作次数减少。

通过观察样例发现，有些样例是正好拿完的，所以我们很容易想出可以将这个数组划分成一些区间，每个区间都是独立的，互不干扰，而且每个区间都正好可以利用若干次第一个操作（不使用第二个操作）拿完，总最小操作次数就是这些区间的最小操作次数之和。

假设划分出的区间分别是 $(l_1,r_1),(l_2,r_2),\dots,(l_k,r_k)$，其中 $r_i=l_{i-1}+1(1<i\le k),l_1=1,r_k=n$，那么总最小操作次数为 $r_1-l_1+r_2-l_2+\dots+r_k-l_k$，简化得 $n-k$。

那 $k$ 是划分区间总数，要使得 $n-k$ 最小化，$k$ 就得最大化。

那问题就变成了求满足条件的最大的划分区间总数。

所以我们可以用动态规划求解。

所以我们可以预处理所有可能的划分区间，然后用动态规划求解。

定义 $dp_i$ 为前 $i+1$ 堆式子构成的最大区间。

则 $dp_i=\max\{dp_{i-1},dp_{u-2}+1\}$，其中 $u$ 为所有合法的以 $i$ 结尾的区间起点。

答案即为 $n-dp_{i-1}$。

---

## 作者：sjwhsss (赞：2)

# 题解 P12687 [KOI 2022 Round 1] 鹅卵石

## 题目描述

有 $n$ 堆石头，第 $i$ 堆有 $a_i$ 个石头，操作一每次拿走相邻两堆任意相同数量的石头，操作二每次拿走某一堆的任意数量的石头，求最小操作数使得全部石头被拿完。$n\le2500,a_i\le10^8$。

## 题目分析

发现本题具有最优子结构，观察数据范围容易想到 $O(n^2)$ 的 DP，思考如何 DP。首先，一个位置要么一次操作二全部拿完，要么和相邻位置进行操作一最后拿不完再进行操作二。考虑把 $a$ 分成一些连续段，对于长度大于等于 $2$ 的区间内部全部进行操作一，对于单个位置 $i$ 它直接进行操作二，这样就能进行线性 DP 了。

定义 $dp_i$ 表示 $1\sim i$ 中所有数全部取完的最小操作数。如果直接操作二，有 $dp_i\leftarrow dp_{i-1}+1$。否则，我们考虑对于区间 $[j,i]$ 该怎么取最优，手模样例和自造小数据后可以发现直接贪心从左往右（代码里写的是从右往左）扩展区间，对每个相邻两个位置进行操作一，进行不了就操作二，是最优的。令 $w(l,r)$ 表示 $[l,r]$ 使用操作一取完的操作数（若 $l=r$ 则是单点进行操作二），有转移：
$$
dp_i\leftarrow\min\limits_{1\le j\le i}\{dp_{j-1}+w(j,i)\}
$$
考虑怎么证明这个贪心，给个（非常）不严谨的感性证明，不妨分成两种情况：

- 假如一个区间不论怎么操作都不会出现相邻两个数字相同的情况，一个数字有剩余，它要么能和相邻位置继续操作一，要么只能操作二，这个区间不管按什么顺序操作最后的总操作数都一样。
- 假如可能出现相邻位置数字相同怎么办？按照从左到右取的策略若出现相邻两个数字相同且左边全部取完，那么此时直接一次操作一比它们数字不同时不劣，如果按照从左往右取不会导致这两个数字相同，但可以通过改变前面的操作使它们相同，那么必然左边会有位置没取完，对答案总贡献都是一样的。同理，从右往左取也一样。所以我们的贪心是对的。

## code

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3e3+5;
int n , dp[maxn] , a[maxn] , b[maxn];
int main ()
{
	scanf("%d" , &n);
	for (int i = 1; i <= n; i++)scanf("%d" , &a[i]);
	for (int i = 1; i <= n; i++)
	{
		dp[i]=dp[i - 1] + 1;
		memcpy(b , a , sizeof(b));
		int tmp = 0;
		for (int j = i - 1; j; j--)
		{
			if (b[j + 1] > 0)
			{
				int x = min(b[j] , b[j + 1]);
				b[j]-=x;
				b[j + 1]-=x;
				if (b[j + 1])tmp++;
				tmp++;
			}
			if (b[j])dp[i]=min(dp[i] , dp[j - 1] + tmp + 1);
			else dp[i]=min(dp[i] , dp[j - 1] + tmp);
		}
	}
	printf("%d\n" , dp[n]);
	return 0;
}
```



 如果有 dalao 有更严谨证明，欢迎指正。

---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P12687 [KOI 2022 Round 1] 鹅卵石](https://www.luogu.com.cn/problem/P12687)

## 题意简述

给定长度为 $n$ 的数组 $a$，每次可对相邻两点同时拿相同数量，或对单点拿任意数量，求将所有石子拿完时所需的最少操作次数。

## 解题思路

1. 枚举每个起点 $i$，向右模拟交替相邻配对：维护一个变量 $t$，初始为 $a_i$，然后依次计算 $t=a_j-t$。

2. 若 $t>0$ 且恰好等于 $a_{j+1}$，则区间 $[i,j+1]$ 可以完全通过相邻配对消除，记录其右端点为 $j$。否则若 $t\le 0$ 则跳出，尝试下一个起点。

3. 令 $f_i$ 表示在位置 $[1,i+1]$ 范围内，最多能选的互不重叠“可消除区间”数量。

4. 对每个右端点 $i$，先继承 $f_{i-1}$（不选任何以 $i$ 结尾的区间），再遍历所有以 $i$ 为右端的合法起点 $u$，计算其对应候选值 $f_{u-2}+1$（若 $u=1$ 则为 $1$），取最大更新 $f_i$。

5. 最大可配对消除区间数为 $f_{n-1}$，剩下必须单点拿的次数即 $n-f_{n-1}$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=2505;
int a[N],f[N];
vector<int> G[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<n;i++)
	{
		int t=a[i];
		for(int j=i;j<n;j++)
		{
			if(j>i)t=a[j]-t;
			if(t<=0)break;
			if(t==a[j+1])G[j].push_back(i);
		}
	}
	for(int i=1;i<n;i++)
	{
		f[i]=f[i-1];
		for(auto u:G[i])
		{
			f[i]=max(f[i],u==1?1:f[u-2]+1);
		}
	}
	cout<<n-f[n-1]<<'\n';
	return 0;
}
```

---

## 作者：tuxiaolai (赞：1)

# 1 说明
这是一种与其他题解思路完全不同的题解，（也许有，我没仔细看）。
# 2 思路
首先，对于第 $i$ 堆石子，在前 $i-1$ 堆石子经过某种方式操作后，会剩下一些石子（会有很多可能的情况，也有可能是 0，这里先不管）。此时，对于每一种情况，我们一定会选择一种操作取走剩下的石子，那就会有三种情况（设第 $i$ 堆石子可能剩下的石子个数为 $b_i$）：
1. 若 $b_i=a_{i+1}$，此时我们肯定会选择操作 1 来同时取走两堆石子，只要 1 次操作。
2. 若 $b_i<a_{i+1}$，此时我们有两种取法，要么各取各的，用操作 2 取走 $b_i$，再另外考虑 $a_{i+1}$；要么用操作 1 两堆同时取走 $b_i$，再考虑剩下的 $b_{i+1}$。两种方式的操作次数都是 2。
3. 至于 $b_i>a_{i+1}$，或其他通过让 $b_i$ 多取 1 次来使 $b_i=a_{i+1}$ 的方式都是没有意义的，因为这并不会影响操作次数。

不难发现，只有 $b_i=a_{i+1}$ 时，我们能够少进行一次操作，那么下面就是要考虑如何判断 $b_i$ 是否可能等于 $a_{i+1}$ 了。

我们用一个数组 $v$ 来表示当前情况下可能出现的 $b_i$ 情况。初始时，$v$ 中就是一个数 $a_1$。后面遍历 $2 \sim n$，当遍历到第 $i$ 个时，先遍历 $v$，如果发现存在 $v_j=a_i$，则清空 $v$，并且 $ans$ 不用增加。  
但如果没有，我们就再次遍历 $v$，将 $a_i-v_j \: (a_i>v_j)$ 放入 $v$，并清空 $v$ 中原来的数。这对应的就是用操作 1 两堆同时取走 $b_i$。最后再将 $a_i$ 也放进 $v$，这对应的就是“各取各的”。另外还要让 $ans$ 加 1。

最后直接输出 $ans$ 即可。
# 3 AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[2510],ans;
long long v[2510],len;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1; i<=n; i++) {
        cin>>a[i];
    }
    v[++len]=a[1];
    ans=1;
    for(int i=2; i<=n; i++) {
        long long k=0;
        bool f=1;
        for(int j=1; j<=len; j++) {
            if(v[j]==a[i]) {
                len=0;
                f=0;
                break;
            }
            if(v[j]<a[i]) {
                v[++k]=a[i]-v[j];
            }
        }
        if(f){
            ans++;
            len=k;
            v[++len]=a[i];
        }
    }
    cout<<ans;
    return 0;
}
```
这里我选择了动态变化数组大小，大家也可以选择用 `vector`。

---

## 作者：fish_love_cat (赞：1)

题解首杀。

---

设 $dp_i$ 表示令 $[1,i]$ 合法的最小操作次数。

显然可以通过模拟找到所有 $[l,r]$ 使得可以用 $r-l$ 操作完成，我们令这样的 $a_{l,r}=1$，否则 $a_{l,r}=\infty$。

转移：

$$dp_i=\min(dp_{i-1}+1,\min^{i-1}_{j=1}a_{j,i}\times (dp_{j-1}+r-l))$$

答案就是 $dp_n$。

实现 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[2505];
int dp[2505];
int b[2505];
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    dp[1]=1;
    for(int i=2;i<=n;i++){
        dp[i]=dp[i-1]+1;
        for(int j=1;j<=i;j++)
            b[j]=a[j];
        for(int j=i;j;j--)
            b[j-1]-=max(b[j],0ll);
        for(int j=i-1;j;j--)
        if(b[j]==0)dp[i]=min(dp[i],dp[j-1]+i-j);//,cout<<i<<' '<<dp[i]<<'\n';
    }
    cout<<dp[n];
    return 0;
}
```

---

## 作者：XuZile (赞：0)

# P12687 题解
## 前言
一开始以为是水题，结果硬是被硬控住了。也是找题解区大佬进修过后，才终于搞定。
## 题目解析
首先定义 DP 数组，可以用 $dp_i$ 表示从 1 号地点至 $i$ 号地点中将所有鹅卵石取完所需的最短时间。

接下来，开始推 DP 方程。先来看操作二的 DP 转移方程。对于 $dp_i$ 是从 $dp_{i-1}$ 转移而来。所以易得 $dp_i=dp_{i-1}+1$。

然后对于操作一，可以循环找到所有的 $i$ 和 $j$。来表示从第 $j$ 号位置至第 $i$ 号位置，这一区间内只使用操作二来拿走鹅卵石。得到操作一的转移方程为 $dp_i=\min(dp_i,dp_{j-1}+i-j)$。

最终的答案自然就是 $dp_n$ 直接输出就行了。
## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,dp[3005],a[3005];
int t[3005];
inline int read(){//快读
	char ch=getchar();
	int res=0;
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
	return res;
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++){
		dp[i]=dp[i-1]+1;
		for(int j=1;j<=n;j++) t[j]=a[j];
		for(int j=i;j>0;j--) t[j-1]-=max(t[j],(int)0);//防止减去负数
		for(int j=i;j>0;j--){
			if(!t[j]) dp[i]=min(dp[i],dp[j-1]+i-j);//DP转移方程
		}
	}
	cout << dp[n];
	return 0;
}
```

---


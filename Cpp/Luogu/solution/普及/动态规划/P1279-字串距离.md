# 字串距离

## 题目描述

设有字符串 $X$，我们称在 $X$ 的头尾及中间插入任意多个空格后构成的新字符串为 $X$ 的扩展串，如字符串 $X$ 为$\verb!abcbcd!$，则字符串 $\verb!abcb␣cd!$，$\verb!␣a␣bcbcd␣!$ 和 $\verb!abcb␣cd␣!$ 都是 $X$ 的扩展串，这里 $\verb!␣!$ 代表空格字符。

如果 $A_1$ 是字符串 $A$ 的扩展串，$B_1$ 是字符串 $B$ 的扩展串，$A_1$ 与 $B_1$ 具有相同的长度，那么我们定义字符串 $A_1$ 与 $B_1$ 的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的 ASCII 码的差的绝对值，而空格字符与其他任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为 $0$。在字符串 $A$、$B$ 的所有扩展串中，必定存在两个等长的扩展串 $A_1$，$B_1$，使得 $A_1$ 与 $B_1$ 之间的距离达到最小，我们将这一距离定义为字符串 $A$，$B$ 的距离。

请你写一个程序，求出字符串 $A$，$B$ 的距离。


## 样例 #1

### 输入

```
cmc
snmn
2
```

### 输出

```
10
```

# 题解

## 作者：Forever丶CIL (赞：74)

P1279
对于这道题，我们考虑，

假如我们知道了第一个字串（s1）前i位和第二个

字串（s2）前j位的最优解

那么，如果我们要计算s1前i位和s2前j+1位的最优解

怎么做？

分析一下，我们新放进去的第j+1位数，只有两种处理方案：

一：第j+1位数对应空格；

二：第j+1位数对应第i位数；

所以我们可以用A[i][j]存s1前i位和s2前j位的最优解

递推方程：A[i][j]=min{A[i-1][j]+k,A[i][j-1]+k,A[i-1][j-1]+abs((int)s1[i]-(int)s2[j])};



------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int A[2010][2010];
char s1[2010];
char s2[2010];
int len1,len2;
int k;
void dp()
{
    for(int i=1;i<=len1;i++)
    {
        for(int j=1;j<=len2;j++)
        {
            A[i][j]=min(A[i-1][j]+k,min(A[i][j-1]+k,A[i-1][j-1]+abs((int)s1[i]-(int)s2[j])));
        }
    }
}
void ini()   //需要一点点预处理 
{
    for(int i=1;i<=len1;i++)
    {
        A[i][0]=A[i-1][0]+k;
    }
    for(int i=1;i<=len2;i++)
    {
        A[0][i]=A[0][i-1]+k;
    }
}
int main()
{
    cin>>s1+1;
    cin>>s2+1;
    cin>>k;
    len1=strlen(s1+1);
    len2=strlen(s2+1);
    ini();
    dp();
    printf("%d",A[len1][len2]);
    return 0;
}
```



------------


rp++

---

## 作者：Y_B_Y (赞：57)

用f[i][j]表示第一个字符串到第i个,第二个字符串到第j个时的最小距离

如f[1][2]在样例中表示如图

![没有描述](https://cdn.luogu.com.cn/upload/pic/70142.png)



### 1.初始化

(len1表示第一个字符串的长度,len2表示第二个字符串的长度):

- f[i][0]=i*k(1<=i<=len1) 这个时候的状况如图

![没有描述](https://cdn.luogu.com.cn/upload/pic/70138.png)
- f[0][i]=i*k(1<=i<=len2) 同上

- f[0][0]=0,都没有为零

- 其他为一个很大的数

### 2.开始dp

```
f[i][j]=min(f[i][j],[i][j-1]+k);
f[i][j]=min(f[i][j],[i-1][j]+k);
f[i][j]=min(f[i][j],f[i-1][j-1]+abs(a[i]-b[j]));
```

#### 解释如图

![没有描述](https://cdn.luogu.com.cn/upload/image_hosting/1itxquod.png)第三句话多了一个后面

发现有一些容易误解的地方,半年后来小更新一下吧

f[i][j]它表示的是第一个字符串到第i个,第二个字符串到第j个时的最小距离,所以它实际表示的是第一个字符串到第i个,第二个字符串到第j个分别所组成的字符串再进行扩展,使长度相等后两扩展串的最小距离.这也说明了为什么第三张图字母C前面突然出现了两个□却不要加上距离,因为f[i-1][j]实际表示的就是□□c/snm(的距离)

### 3.代码
```
#include<bits/stdc++.h>
using namespace std;
int len1,len2,a[100010],b[100010],f[2001][2001],k;
string s1,s2;
int main()
{
	cin>>s1;//输入第一个字符串
	cin>>s2;//输入第二个字符串
	cin>>k;//输入k
	len1=s1.size();//第一个字符串长度
	len2=s2.size();//第二个字符串长度
	memset(f,25,sizeof(f));//初始化一个很大的数
	for(int p=0;p<len1;p++)//先读ASCII码,等一下直接用
	{
		a[p+1]=int(s1[p]);
	}
	for(int p=0;p<len2;p++) b[p+1]=int(s2[p]);//先读ASCII码
	for(int i=1;i<=len1;i++) f[i][0]=i*k;//初始化
	for(int i=1;i<=len2;i++) f[0][i]=i*k;//初始化
	f[0][0]=0;//初始化
	for(int i=1;i<=len1;i++)//dp
	{
		for(int j=1;j<=len2;j++)
		{
			f[i][j]=min(f[i][j],f[i][j-1]+k);
        f[i][j]=min(f[i][j],f[i-1][j]+k);
        f[i][j]=min(f[i][j],f[i-1][j-1]+abs(a[i]-b[j]));
		}
	}
	cout<<f[len1][len2];//输出
}
```


---

## 作者：zhangyuhan (赞：30)

做$DP$题，无疑要考虑如下几点：

$1.$状态定义

$2.$状态转移方程

$3.$边界

$4.$目标

那我们来依次分析。

**状态定义**

根据题意，很简单，就是：

$f_{i,j}$表示$A$串的前$i$个字母与$B$串的前$j$个字母的最小距离。

**状态转移方程**

对于$f_{i,j}$来说，无疑就三种情况：

$1.$ $A_i$与$B_j$的$ASCLL$码绝对值之差

$2.$ $A_i$对应着空格

$3.$ $B_j$对应着空格

显然，第一种的方程最好写：$f_{i-1,j-1}+|A_i-B_j|$

而第二种，由于$A_i$对应着空格，所以，状态一定要从$A$串的前$i-1$个字母与$B$串的前$j$个字母的最小距离推得。

所以，第二个方程为：$f_{i-1,j}+k$

同理，第三个方程为：$f_{i,j-1}+k$

$f_{i,j}$即为三者最小值。

**边界**

从$f_{i,0}$和$f_{0,j}$入手。

先从定义出发，$f_{i,0}$表示$A$串的前$i$个字母与$B$串的前$0$个字母的最小距离.

**是不是很怪？**

所以我们只能默认第零个字母为空格，所以：

$f_{i,0}=f{i-1,0}+k$

化简一下，就是：$f_{i,0}=i*k$

同理，$f_{0,j}=j*k$

**目标**

设$A$串长度为$m$, $B$串长度为$n$，目标易求：$f_{m,n}$

$AC$ $Code$

```cpp
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

string a, b;
int m, n, f[2010][2010], k;

int main() {
	cin >> a >> b;
	cin >> k;
	m = a.size(), n = b.size();
	a = ' '+a, b = ' '+b;// 因为string下标从零开始，所以利用string加法的特性，开头加空格
	for (int i=1; i<=m; i++)
		f[i][0] = i*k;
	for (int j=1; j<=n; j++)
		f[0][j] = j*k;
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++) {
			f[i][j] = 1e9; // 因为要取最小，所以初值要赋大
			f[i][j] = min(f[i-1][j-1]+abs(a[i] - b[j]), min(f[i-1][j]+k, f[i][j-1]+k));
			//求三者最小值可用min套min
		}
	cout << f[m][n] << endl; 
	return 0; // 完结撒花！
}
```

---

## 作者：Merak (赞：17)

qwq这题思路还是很巧妙的w（是我太弱），分成三种情况就好了~注释都在代码里啦！

注意初始化！！

萌新奉上代码（逃

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<ctime>
using namespace std;
char a[2003],b[2003];
int k;//空格到各个字母的距离 
int f[2003][2003]={0};//用f[i][j]表示以i为结尾的序列对应以j为结尾的序列的最小距离 
int main()
{
    cin>>a;
    cin>>b;
    cin>>k;
    int n1=strlen(a);//计算序列a长度 
    int n2=strlen(b);//计算序列b长度 
    f[0][0]=0;//初始化 
    for(int i=1;i<=n1;i++)
    {
        f[i][0]=i*k;//序列a全部对应空格时 
    }
    for(int j=1;j<=n2;j++)
    {
        f[0][j]=j*k;//同上序列b全部对应空格时 
    }
    for(int i=1;i<=n1;i++)
    {
        for(int j=1;j<=n2;j++)
        {
            int t=abs(a[i-1]-b[j-1]);//a、b序列均有对应字母时 
            f[i][j]=min(min(f[i-1][j],f[i][j-1])+k,f[i-1][j-1]+t);
            /*
            三种情况：
            第一种->A[i]对应空格：F[i-1][j] + K；(K 为到空格的距离)
                     B[j]对应空格：F[i][j-1] + K；
                    A[i]对应B[j]：[i-1][j-1] + |A[i] - B[j]|；(ASCII 码的差的绝对值,用t存储) 
            */ 
        }
    }
    cout<<f[n1][n2]<<endl;//f[n1][n2]存储了最终答案 
    return 0;
}
```

---

## 作者：邓布利多6 (赞：12)

## 字符串 + 动态规划

令 $f_{i,j}$ 表示第一个序列取 $i$ 个字符，第二个序列取 $j$ 个时的最大值，由题目要求分类转移易知：

$f_{i,j} = \min \begin{cases} f_{i-1,j}+k  \quad(1) \\ f_{i,j-1}+k\quad(2) \\ f_{i-1,j-1}+|a_{i-1}-b_{j-1}| \quad(3)\end{cases}  $

$(1)$ $a_i$ 对应空格  $\quad(2)$ $a_i$ 对应空格
 $\quad(3)$ $a_i$ 对应 $b_j$
 
 
```cpp
#include <iostream>
#include <string>
#include <cmath>
using namespace std;
const int N = 2005;
string a, b;
int k, f[N][N];
int main()
{
    cin >> a >> b >> k;
    for(int i = 1; i <= a.size(); i++) f[i][0] = i * k;
    for(int j = 1; j <= b.size(); j++) f[0][j] = j * k;  //初始化
    for(int i = 1; i <= a.size(); i++)
        for(int j = 1; j <= b.size(); j++)
        {
				int num1,num2,num3;
				num1 = f[i - 1][j] + k;
				num2 = f[i][j - 1] + k;
				num3 = f[i - 1][j - 1] + abs(a[i - 1] - b[j - 1]);
				f[i][j] = min(min(num1, num2), num3);
        }
    cout << f[a.size()][b.size()];
    return 0;
}
```

---

## 作者：Timothy (赞：6)

【题目大意】

在字符串A、B的所有扩展串中，必定存在两个等长的扩展串A1、B1，使得A1与B1之间的距离达到最小，我们将这一距离定义为字符串A、B的距离。

请你写一个程序，求出字符串A、B的距离。

【算法讨论】

这道题运用动态规划的算法。用f[i][j]表示第一个序列取i个，第二个序列取j个的最大值。gx表示字符与空格的关系，a1[i]存第一个字符串中第i个字母的ASCII码，a2[i]存第二个字符串中第i个字母的ASCII码。动规式如下：

f[i][j]=max(max(f[i-1][j]+gx,

f[i][j-1]+gx),

f[i-1][j-1]+ abs(a1[i]-a2[j]));

得分：100

时间复杂度：O(LEN1\*LEN2)

空间复杂度：O(N^N+2\*N)

```cpp

#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
using namespace std;
int len1,len2,f[2001][2001],a1[2001],a2[2001],gx;
string s1,s2;
int main ()
{
    cin >>s1>>s2>>gx;
    len1=s1.size();len2=s2.size();
    for (int b=0;b<len1;++b)a1[b+1]=s1[b]-'a';
    for (int b=0;b<len2;++b)a2[b+1]=s2[b]-'a';
    memset(f,127/3,sizeof(f));f[0][0]=0;
    for (int b=1;b<=len1;++b)f[b][0]=f[b-1][0]+gx;
    for (int b=1;b<=len2;++b)f[0][b]=f[0][b-1]+gx;
    for (int i=1;i<=len1;++i)
      for (int j=1;j<=len2;++j)
        f[i][j]=min(min(f[i-1][j]+gx,f[i][j-1]+gx),f[i-1][j-1]+abs(a1[i]-a2[j]));
    printf ("%d",f[len1][len2]);
    return 0;
}

//N为len1和len2的最大值

//len1和len2分别为字串1和2的长度

```

---

## 作者：汪鸣谦 (赞：3)

这一题不算太难

很容易想到状态表示方法：设f ij表示第一个字符串的前i个字符和第二个字符串的前j个字符里的最优值（这个不要问为什么，所有涉及到两个字符串比较的问题比如编辑距离最长公共子序列都是这种状态表示方法）

于是，对于每一个f ij我们考虑第i位和第j位。

这里有三种情况：

1.	让第i位直接和第j位进行运算，那么转移为前i-1位和前j-1位的问题即f i-1j-1

2.	让第i位对空格，转移为前i-1位和前j位的问题即f i-1j

3.	让第j位对空格，转移为前i位和前j-1位的问题即f ij-1

至于那种最优，不知道，取最小的即可

初始化：对于一个字符串中的m位对另一个字符串中的0位的方法是m*k。就是让每一位都对着空格

代码：

```
#include<bits/stdc++.h>
using namespace std;
int f[2011][2011]={0},l1,l2,k;
string s1,s2;
int main(){
	cin>>s1>>s2>>k;
	l1=s1.size(),l2=s2.size();
	for(int i=1;i<=l1;i++)f[i][0]=i*k;
	for(int i=1;i<=l2;i++)f[0][i]=i*k;
	for(int i=1;i<=l1;i++){
		for(int j=1;j<=l2;j++){
			f[i][j]=min(f[i-1][j]+k,min(f[i-1][j-1]+abs(s1[i-1]-s2[j-1]),f[i][j-1]+k));
		}
	}
	cout<<f[l1][l2]<<endl;
	return 0;
}

```


---

## 作者：zcyyyyy (赞：2)

# P1279 题解
## 看到一水的递推，就来一发记忆化搜索的题解吧
这题难度虚高，其实比[P1140](https://www.luogu.com.cn/problem/P1140)还简单

时间复杂度 $O\left( lenA*lenB\right)$
```
#include<bits/stdc++.h>
using namespace std;
int a[2001],b[2001],f[2001][2001],P;
//这里设f[x][y]为A串前x个字符与B串前y个字符的距离
string s1,s2;
int dp(int x,int y){//函数dp(x,y)求f[x][y]的值
	if(f[x][y]==-1){
		if(x==0)f[x][y]=y*P;//当A串空时，填上与B串剩余字符数相当的空格
		else if(y==0)f[x][y]=x*P;//同上
		else {
			f[x][y]=min(dp(x-1,y-1)+abs(a[x]-b[y]),min(dp(x-1,y)+P),dp(x,y-1)+P);
            //状态转移方程分三种情况
            //1，不填空格 此时f[x][y]=f[x-1][y-1](可以理解为两边都用掉末尾的一个
            //2，在A串末尾填空格，此时f[x][y]=f[x][y-1](也就是空格抵消掉了B串末尾的一个
            //3，在B串末尾填空格，可以自己理解一下
            //这里就体现出记忆化搜索的好处，可以自然地表达状态转移，不需要考虑数据更新问题
            }
		
	}
	return f[x][y];
}
int main(){
	cin>>s1>>s2>>P;
	for(int i=0;i<s1.length();++i)
	    a[i+1]=int(s1[i]);
	for(int i=0;i<s2.length();++i)
	    b[i+1]=int(s2[i]);
	memset(f,-1,sizeof(f));
	cout<<dp(s1.length(),s2.length());
	return 0;
} 
```
记忆化搜索能使做题时的思维难度大大下降

建议像我一样刚入门的oier可以多写写记忆化搜索Ovo

---

## 作者：Lates (赞：1)

一道类似于最长公共子序列做法的dp题。

题意就是给两个字符串，可以在中间添加空格，求最小距离。

设 $f_{i,j}$ 为 $A$ 从 $1-i$ 的子串和 $B$ 从 $1-j$ 的子串的距离。

则分为 $3$ 种情况 $:$

- 不加空格，则 $f_{i,j}=f_{i-1,j-1}+clac(A_i,B_i)$，$clac(A_i,B_i)$即为$A_i,B_i$需要付出的代价，即为 $|A_i-B_i|$
- 在 $A$ 加空格，则 $f_{i,j}=f_{i-1,j}+k$
- 在 $B$ 加空格，则 $f_{i,j}=f_{i,j-1}+k$

$Code$
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
#define _min(a,b) a<b?a:b 
#define abs(a,b) ((int)a>(int)b?(int)(a-b):(int)(b-a))
const int MAX=2005;
string a,b;int k;
int f[MAX][MAX];
signed main(){
	cin>>a>>b;k=read();
	a=' '+a,b=' '+b;
	memset(f,0x3f,sizeof(f));f[0][0]=0;
	for(register int i=1;i<=a.length();++i)f[i][0]=i*k;
	for(register int i=1;i<=b.length();++i)f[0][i]=i*k;
	for(register int i=1;i<=a.length();++i){
		for(register int j=1;j<=b.length();++j){
			f[i][j]=_min(f[i-1][j-1]+abs(a[i],b[j]),f[i][j]);
			f[i][j]=_min(f[i-1][j]+k,f[i][j]);
			f[i][j]=_min(f[i][j-1]+k,f[i][j]);
		}
	}
	printf("%d\n",f[a.length()][b.length()]);
	return 0;
}

```



---

## 作者：无名ZWH (赞：1)

我们先枚举全空格
再通过DP计算			  
f[i][j]=min(f[i-1][j]+k,f[i][j-1]+k);  
			f[i][j]=min(f[i][j],abs(s1[i]-s2[j])+f[i-1][j-1]);  
  以上为动态转移方程，为对应空格和字母互对的情况  
  那么——上代码   
```cpp
#include<bits/stdc++.h>  
using namespace std;  
char s1[11000],s2[11000];  
int yh[11000][11000];//用f[i][j]表示以i为结尾的序列对应以j为结尾的序列的最小距离  
int main()  
{  
	int len1,len2,k;//k为空格到各个字母的距离  
	scanf("%s",s1+1);  
	len1=strlen(s1+1);//计算序列s1长度 ，一定要加1   
	scanf("%s",s2+1);  
	len2=strlen(s2+1);//计算序列s2长度 ，一定要加1   
	scanf("%d",&k);  
	f[0][0]=0;//初始化   
	for(int i=1;i<=len1;i++)  
	{  
		f[i][0]=k*i;//s1序列全空格时  
	}  
	for(int j=0;j<=len2;j++)  
	{  
		f[0][j]=k*j;//s2序列全空格时  
	}  
	for(int i=1;i<=len1;i++)   
	{  
		for(int j=1;j<=len2;j++)  
		{  
			f[i][j]=min(f[i-1][j]+k,f[i][j-1]+k);  
			f[i][j]=min(f[i][j],abs(s1[i]-s2[j])+f[i-1][j-1]); //对应字母和空格时的情况   
		}  
	}  
	cout<<f[len1][len2]<<endl;  
	return 0;  
}
```

```


---

## 作者：SUNCHAOYI (赞：0)

### 题目一看就知道是DP(因为是求出最小值)

**设f[i][j]为a字符串长度为i，b字符串长度为j时的最小距离**

**一开始需要初始化:1-a的长度,f[i][0]=i*k;1-b的长度,f[0][i]=i*k;**

**两层循环即可,状态转移方程：f[i][j]=min(min(f[i][j-1]+k,f[i-1][j]+k),f[i-1][j-1]+abs(a[i-1]-b[j-1]));**

**这分别对应：两个非空格字符的距离定义为它们的ASCII码的差的绝对值;而空格字符与其他任意字符之间的距离为已知的定值K(a,b字符串各一种)**

**输出f[a字符串的长度][b字符串长度]即可**


------------
### 参考函数:

**1.int abs(int x) 头文件 #include<cmath> 返回x的绝对值**
  
**2.int min(int a,int b) 头文件  #include<iostream> 返回a,b中值较小的一个**
  
**3.int str.size()或者str.length() 头文件 #include<string> 返回字符串的长度**
  

------------
### 代码：
  ```
#include<iostream>
#include<string>
#include<cmath>//abs()绝对值的函数 
using namespace std;
const int MAX=2001;
int f[MAX][MAX],k;
string a,b;
int main()
{	 
	cin>>a>>b>>k; 
	for(int i=1;i<=a.size();i++)f[i][0]=i*k;//初始化数组f
	for(int i=1;i<=b.size();i++)f[0][i]=i*k;
	for(int i=1;i<=a.size();i++)//循环 
		for(int j=1;j<=b.size();j++)f[i][j]=min(min(f[i][j-1]+k,f[i-1][j]+k),f[i-1][j-1]+abs(a[i-1]-b[j-1]));//动态规划求最小值 
	cout<<f[a.size()][b.size()]<<endl;//输出 
	return 0;
} 
```


---


# [蓝桥杯 2025 国 Java B] 瓷砖填充

## 题目描述

在新建成的城市数学文化馆中，最引人注目的是一面宏大的展示墙。这面墙上嵌有一个特殊的矩形区域：它由两行瓷砖构成，每行有 $N$ 个格子，整体呈现出一个 $2 \times N$ 的方格结构。为了致敬数学家欧几里得对数论的贡献，设计师构思了一项美学方案：他们计划使用三种特制的数字瓷砖——分别印有 $6$、$1$ 和 $5$，来填满这些格子，使得任意两个相邻瓷砖上的数字互质。

瓷砖之间共有两种相邻关系：横向相邻（同一行中左右相邻的瓷砖）和纵向相邻（同一列中上下相邻的瓷砖）。无论是哪种相邻关系，它们所承载的数字都必须满足互质条件。

作为受邀的技术顾问，现在，请你计算出在严格遵循上述互质规则的前提下，共有多少种不同的瓷砖填充方法。由于答案可能很大，你只需给出其对 $10^9 + 7$ 取余后的结果即可。

## 说明/提示

**【评测用例规模与约定】**

对于 $10\%$ 的评测用例，$1 \leq N \leq 10$。

对于 $100\%$ 的评测用例，$1 \leq N \leq 10^5$。


## 样例 #1

### 输入

```
1```

### 输出

```
7```

## 样例 #2

### 输入

```
2```

### 输出

```
35```

# 题解

## 作者：HZY1618yzh (赞：5)

~最近~学了 DP，刷一条题练练。  
建议大家跟着下面《深进》的图片的做法一起做，实在不会才跟着题解一起想。

![I AK IOI](https://cdn.luogu.com.cn/upload/image_hosting/hbcch9p9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

题意
---
给出一个 $2\times n$ 的长方形，每个格子填入 $1,5,6$ 中的一个数字，要求上下左右互质，求一共有多少种填法。

思路
---
动态规划题，首先应该先确定状态。很明显，该题是求出填完第 $n$ 列一共有多少种填法。可以尝试定义 $dp_i$，表示填完第 $i$ 列一共有多少种填法。

接着就是转移，可是我们却发现了一个问题，就是题目要求相邻两数互质，转态之间无法直接转移，所以需要重新定义状态。

由于需要保证相邻两数互质，所以需要精确知道当前选的是哪两个数，所以需要多加两维。定义 $dp_{z,i,j}$ 表示正在确定第 $z$ 列、这一列的上面填数 $i$、下面填数 $j$，的情况下一共有几种填法。

转移是根据状态确定的。因为 $dp$ 表示当前状态下一共有几种填法，所以转移方程是所有可以与 $dp_{z,i,j}$ 拼接的 $dp_{z-1,k,l}$ 的和。动态转移方程：
$$
dp_{z,i,j}=\sum_{\gcd(i,j)=1\land\gcd(k,l)=1\land\gcd(k,i)=1\land\gcd(l,j)=1\land(i,j,k,l\in {1,5,6})}dp_{z-1,k,l}
$$

不过第二三维最大是 $6$，达到了 $6\times6=36$ 的空间，所以可以用类似离散化的方法，让 $i,j,k,l\in {1,2,3}$，表示选第几个数（甚至用 $dp_{z,i}(i\in7)$ 表示 $7$ 种状态。不过为了讲解方便，我们使用刚才的状态）。既然使用了离散化的状态，就需要用 $f_{i,j}$ 数组记录第 $i$ 个数和第 $j$ 个数是否互质。

- $i=1,j=1$，$1,1$ 互质。
- $i=1,j=2$，$1,5$ 互质。
- $i=1,j=3$，$1,6$ 互质。
- $i=2,j=1$，$5,1$ 互质。
- $i=2,j=2$，$5,5$ 不互质。
- $i=2,j=3$，$5,6$ 互质。
- $i=3,j=1$，$6,1$ 互质。
- $i=3,j=2$，$6,5$ 互质。
- $i=3,j=3$，$6,6$ 不互质。

核心代码
---
````cpp
inline bool chek(int x,int y){//检查
	return f[x][y];
}

if(n==1){//加速，提前输出不比计算的东西
	cout<<7;
	return 0;
}
//记录是否互质和初始值
dp[1][1][1]=dp[1][1][2]=dp[1][1][3]=dp[1][2][1]=dp[1][2][3]=dp[1][3][1]=dp[1][3][2]=f[1][1]=f[1][2]=f[1][3]=f[2][1]=f[2][3]=f[3][1]=f[3][2]=1;
for(int z=2;z<=n;z++)//第z列
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)//当前列的选择
			for(int k=1;k<=3;k++)
				for(int l=1;l<=3;l++)//上一列的选择
					if(chek(k,l)&&chek(k,i)&&chek(l,j)&&chek(i,j))
						dp[z][i][j]=(dp[z][i][j]+dp[z-1][k][l])%mod;
						//如果互质则增加答案
for(int i=1;i<=3;i++)
	for(int j=1;j<=3;j++)
		if(chek(i,j))//这行判断其实可以不用，因为不满足 chek(i,j) 的 dp[n][i][j] 是 0
			ans=(ans+dp[n][i][j])%mod;
cout<<ans;//输出
````
永无止尽的优化
---
可以发现，$dp_1$ 和 $f$ 的存储内容是一样的可以合并；当 $i$ 和 $j$ 代表的数不互质的情况下，$k$ 和 $l$ 的枚举已经没有意义，可以特判优化掉；这样定义的状态下可以使用矩阵快速幂加速，~不过我不会~……

AC 代码
---
- c++
````cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[100001][4][4],ans;
const int mod=1e9+7;
inline bool chek(int x,int y){//检查
	return dp[1][x][y];//优化成 dp[1]
}
int main(){
	cin>>n;//输入
	if(n==1){//加速，提前输出不比计算的东西
		cout<<7;
		return 0;
	}
	//记录是否互质
	dp[1][1][1]=dp[1][1][2]=dp[1][1][3]=dp[1][2][1]=dp[1][2][3]=dp[1][3][1]=dp[1][3][2]=1;
	for(int z=2;z<=n;z++)
	//第z列，要从 2 开始，不然初始值都会变成 0
		for(int i=1;i<=3;i++)
			for(int j=1;j<=3;j++){//当前列的选择
				if(!chek(i,j)) continue;
				//若当前选择不合法，则后面循环是不是互质
				for(int k=1;k<=3;k++)
					for(int l=1;l<=3;l++){//上一列的选择
						if(!chek(k,l)) continue;
						//上一列竖着是不是互质
						if(!chek(k,i)||!chek(l,j)) continue;
						//这两行有是不是互质
						dp[z][i][j]=(dp[z][i][j]+dp[z-1][k][l])%mod;
						//更新答案
					}
			}
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
			if(chek(i,j))//检查此状态是否合法（互质）
				ans=(ans+dp[n][i][j])%mod;//增加总答案数量
	cout<<ans;//输出
    return 0;
}
````
- java

```java
import java.util.Scanner;
public class Main {
    static int n, ans;
    static int[][][] dp = new int[100001][4][4];
    static final int mod = (int)1e9 + 7;
    // 检查
    static boolean chek(int x, int y) {
        return dp[1][x][y] == 1; // 优化成 dp[1]
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt(); // 输入
        if (n == 1) { // 加速，提前输出不比计算的东西
            System.out.println(7);
            return;
        }
        // 记录是否互质
        dp[1][1][1] = dp[1][1][2] = dp[1][1][3] = dp[1][2][1] = dp[1][2][3] = dp[1][3][1] = dp[1][3][2] = 1;
        for (int z = 2; z <= n; z++) {
            // 第z列，要从 2 开始，不然初始值都会变成 0
            for (int i = 1; i <= 3; i++) {
                for (int j = 1; j <= 3; j++) { // 当前列的选择
                    if (!chek(i, j)) continue;
                    // 若当前选择不合法，则后面循环是不是互质
                    for (int k = 1; k <= 3; k++) {
                        for (int l = 1; l <= 3; l++) { // 上一列的选择
                            if (!chek(k, l)) continue;
                            // 上一列竖着是不是互质
                            if (!chek(k, i) || !chek(l, j)) continue;
                            // 这两行有是不是互质
                            dp[z][i][j] = (dp[z][i][j] + dp[z - 1][k][l]) % mod;
                            // 更新答案
                        }
                    }
                }
            }
        }
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                if (chek(i, j)) // 检查此状态是否合法（互质）
                    ans = (ans + dp[n][i][j]) % mod; // 增加总答案数量
            }
        }
        System.out.println(ans); // 输出
    }
}
```
代码来之不易，点个赞再走也不迟~

---

## 作者：sanhaoxuezha (赞：3)

这是一道简单的 DP 题。

## 正文：

### 题意简述：

给你一个 $2 \times N$ 大小的矩阵，在每个格子中填入 $1$，$5$，$6$。
要求求出所有使任意两个相邻格子中的数互质的方法数。

考虑使用 DP 解决此题。

### 状态定义：

$f_{i, 0}$ 表示第 $i$ 列无 1 的方法数。

$f_{i, 1}$ 表示第 $i$ 列仅第 1 行有 1 的方法数。

$f_{i, 1}$ 表示第 $i$ 列仅第 2 行有 1 的方法数。

$f_{i, 0}$ 表示第 $i$ 列全为 1 的方法数。

### 状态转移：

通过分类讨论与枚举计数可得出转移方程。

$$f_{i, 0}=f_{i-1, 0}+f_{i-1, 1}+f_{i-1, 2}+f_{i-1, 3}\times2$$

$$f_{i, 1}=f_{i-1, 0}+f_{i-1, 1}+f_{i-1, 2}\times 2+f_{i-1, 3}\times2$$

$$f_{i, 2}=f_{i-1, 0}+f_{i-1, 1}\times2+f_{i-1, 2}+f_{i-1, 3}\times2$$

$$f_{i, 3}=f_{i-1, 0}+f_{i-1, 1}+f_{i-1, 2}+f_{i-1, 3}$$

### 结果：

$$f_{i-1, 0}+f_{i-1, 1}+f_{i-1, 2}+f_{i-1, 3}$$

## 代码：

```cpp
#include<bits/stdc++.h>

#define int long long		//防止溢出qwq

using namespace std;

const int N=1e5+5;
const int MOD=1e9+7;

int n;
int f[N][4];

signed main()
{
	cin>>n;
	f[1][0]=2;f[1][1]=2;f[1][2]=2;f[1][3]=1;
	for(int i=2;i<=n;i++)
	{
		f[i][0]=(f[i-1][0]+f[i-1][1]+f[i-1][2]+f[i-1][3]*2)%MOD;		//不要忘记取模qwq
		f[i][1]=(f[i-1][0]+f[i-1][1]+f[i-1][2]*2+f[i-1][3]*2)%MOD;
		f[i][2]=(f[i-1][0]+f[i-1][1]*2+f[i-1][2]+f[i-1][3]*2)%MOD;
		f[i][3]=(f[i-1][0]+f[i-1][1]+f[i-1][2]+f[i-1][3])%MOD;
	}
	cout<<(f[n][0]+f[n][1]+f[n][2]+f[n][3])%MOD;		//结尾也不要忘记呀qwq
	
	return 0;
}
```

---

## 作者：Bill_luogu (赞：3)

一道很好的动态规划题。

先看题目，题目要求方案数，且横向相邻（同一行中左右相邻的瓷砖）和纵向相邻（同一列中上下相邻的瓷砖）。无论是哪种相邻关系，它们所承载的数字都必须满足互质条件。

设 $dp_{i,j}$ 为第 $i$ 列用第 $j$ 种地砖铺，$j$ 种地砖分别为：
![](https://cdn.luogu.com.cn/upload/image_hosting/q56gcyjx.png)
接下来开始写状态转移方程。

题目要求相邻的各自所承载的数字都必须满足互质条件，于是理出以下式子：
- $dp_{i,0}$：对于上一列，无论哪种方式都可以铺，答案为：
$$\sum_{j=0}^{6}dp_{i-1,j}\bmod10^9+7$$
- $dp_{i,1}$：对于上一列，$j=1$ 和 $j=6$ 不满足题目要求，答案为：
$$(\sum_{j=0}^{6}dp_{i-1,j}-dp_{i-1,1}-dp_{i-1,6})\bmod10^9+7$$
- $dp_{i,2}$：对于上一列，$j=2$ 和 $j=4$ 不满足题目要求，答案为：
$$(\sum_{j=0}^{6}dp_{i-1,j}-dp_{i-1,2}-dp_{i-1,4})\bmod10^9+7$$
- $dp_{i,3}$：对于上一列，$j=3$ 和 $j=4$ 不满足题目要求，答案为：
$$(\sum_{j=0}^{6}dp_{i-1,j}-dp_{i-1,3}-dp_{i-1,4})\bmod10^9+7$$
- $dp_{i,4}$：对于上一列，$j=2$、 $j=3$ 和 $j=4$ 不满足题目要求，答案为：
$$(\sum_{j=0}^{6}dp_{i-1,j}-dp_{i-1,2}-dp_{i-1,3}-dp_{i-1,4})\bmod10^9+7$$
- $dp_{i,5}$：对于上一列，$j=5$ 和 $j=6$ 不满足题目要求，答案为：
$$(\sum_{j=0}^{6}dp_{i-1,j}-dp_{i-1,5}-dp_{i-1,6})\bmod10^9+7$$
- $dp_{i,6}$：对于上一列，$j=1$、 $j=5$ 和 $j=6$ 不满足题目要求，答案为：
$$(\sum_{j=0}^{6}dp_{i-1,j}-dp_{i-1,1}-dp_{i-1,5}-dp_{i-1,6})\bmod10^9+7$$

~~动态转移方程终于写好了~~
## 上代码：
```cpp
#include<iostream>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
ll dp[100010][7];
ll n;
ll ans;
int main()
{
	cin>>n;
	for(int i=0;i<=6;i++)
		dp[1][i]=1;//初始化
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=6;j++)
			dp[i][0]+=dp[i-1][j];
		
        //刚刚推出来的状态转移方程

		dp[i][1]=dp[i][0]-dp[i-1][1]-dp[i-1][6];
		dp[i][1]=dp[i][1]%mod;
		
		dp[i][2]=dp[i][0]-dp[i-1][2]-dp[i-1][4];
		dp[i][2]=dp[i][2]%mod;
		
		dp[i][3]=dp[i][0]-dp[i-1][3]-dp[i-1][4];
		dp[i][3]=dp[i][3]%mod;
		
		dp[i][4]=dp[i][0]-dp[i-1][2]-dp[i-1][3]-dp[i-1][4];
		dp[i][4]=dp[i][4]%mod;
		
		dp[i][5]=dp[i][0]-dp[i-1][5]-dp[i-1][6];
		dp[i][5]=dp[i][5]%mod;
		
		dp[i][6]=dp[i][0]-dp[i-1][1]-dp[i-1][5]-dp[i-1][6];
		dp[i][6]=dp[i][6]%mod;
		
		dp[i][0]=dp[i][0]%mod;
	}
	for(int i=0;i<=6;i++)
		ans+=dp[n][i],ans=ans%mod;//累加答案
	cout<<ans;//完结撒花！
	return 0;
} 
```

---

## 作者：Peruere_Arlecchino (赞：1)

这道简单的题目可以采用动态规划 结合 矩阵快速幂求解。先分析 $2 \times 1$ 列的合法状态，因横向和纵向相邻数字需互质，筛选出 7 种有效状态：$(6,1)$、$(6,5)$、$(1,6)$、$(1,1)$、$(1,5)$、$(5,6)$、$(5,1)$。构建 $7 \times 7$ 状态转移矩阵，判断相邻列间横向数字是否互质（如前一列上方为 6，当前列上方就只能填 1 或 5）。
## code：
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

// 手动实现 GCD 函数
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// 状态编码:
// 0: (6,1), 1: (6,5), 2: (1,6), 3: (1,1), 4: (1,5), 5: (5,6), 6: (5,1)
const int STATE_COUNT = 7;

// 定义矩阵结构
struct Matrix {
    long long data[STATE_COUNT][STATE_COUNT];
    
    // 初始化单位矩阵
    Matrix() {
        for (int i = 0; i < STATE_COUNT; i++) {
            for (int j = 0; j < STATE_COUNT; j++) {
                data[i][j] = (i == j) ? 1 : 0;
            }
        }
    }
    
    // 初始化转移矩阵
    Matrix(bool isTrans) {
        if (isTrans) {
            // 初始化转移矩阵
            for (int i = 0; i < STATE_COUNT; i++) {
                for (int j = 0; j < STATE_COUNT; j++) {
                    data[i][j] = 0;
                }
            }
            
            // 定义每个状态的数字对
            int states[STATE_COUNT][2] = {
                {6, 1}, {6, 5}, {1, 6}, {1, 1}, {1, 5}, {5, 6}, {5, 1}
            };
            
            // 构建转移矩阵
            for (int i = 0; i < STATE_COUNT; i++) {
                int a = states[i][0], b = states[i][1];
                for (int j = 0; j < STATE_COUNT; j++) {
                    int c = states[j][0], d = states[j][1];
                    // 检查横向相邻是否互质
                    if (gcd(a, c) == 1 && gcd(b, d) == 1) {
                        data[i][j] = 1;
                    }
                }
            }
        } else {
            // 初始化为零矩阵
            for (int i = 0; i < STATE_COUNT; i++) {
                for (int j = 0; j < STATE_COUNT; j++) {
                    data[i][j] = 0;
                }
            }
        }
    }
};

// 矩阵乘法
Matrix multiply(const Matrix& a, const Matrix& b) {
    Matrix result(false);
    for (int i = 0; i < STATE_COUNT; i++) {
        for (int j = 0; j < STATE_COUNT; j++) {
            for (int k = 0; k < STATE_COUNT; k++) {
                result.data[i][j] = (result.data[i][j] + a.data[i][k] * b.data[k][j]) % MOD;
            }
        }
    }
    return result;
}

// 矩阵快速幂
Matrix matrixPow(Matrix base, long long power) {
    Matrix result; // 单位矩阵
    while (power > 0) {
        if (power % 2 == 1) {
            result = multiply(result, base);
        }
        base = multiply(base, base);
        power /= 2;
    }
    return result;
}

int main() {
    int n;
    cin >> n;
    
    if (n == 0) {
        cout << 0 << endl;
        return 0;
    }
    
    if (n == 1) {
        cout << 7 << endl;
        return 0;
    }
    
    // 构建转移矩阵
    Matrix trans(true);
    
    // 计算转移矩阵的(n-1)次幂
    Matrix result = matrixPow(trans, n - 1);
    
    // 初始状态：每列有1种方案，共7列
    long long initial[STATE_COUNT] = {1, 1, 1, 1, 1, 1, 1};
    
    // 计算最终方案数
    long long total = 0;
    for (int i = 0; i < STATE_COUNT; i++) {
        for (int j = 0; j < STATE_COUNT; j++) {
            total = (total + initial[j] * result.data[j][i]) % MOD;
        }
    }
    
    cout << total << endl;
    return 0;
}
```
求赞求过。

---

## 作者：lcycl (赞：1)

# 思路
一共有 $3$ 个数，每列只有 $2$ 个格子，于是一列的情况只有 $9$ 种：  
![](https://cdn.luogu.com.cn/upload/image_hosting/awrjvepm.png?x-oss-process=image/resize,m_lfit,h_1145,w_1145)  
但是，题目要求相邻两个数字必须互质，那么 $5,5$ 和 $6,6$ 这两种情况就不行了。  所以，合法的情况一共只有 $7$ 种。于是就可以用 $dp_{i,j}$ 表示在第 $i$ 列，用第 $j$ 种方法的方案数。  
- $j=1$ 则为上面填 $1$，下面填 $1$；  
- $j=2$ 则为上面填 $1$，下面填 $5$；  
- $j=3$ 则为上面填 $1$，下面填 $6$；  
- $j=4$ 则为上面填 $5$，下面填 $6$；  
- $j=5$ 则为上面填 $6$，下面填 $5$；  
- $j=6$ 则为上面填 $5$，下面填 $1$；  
- $j=7$ 则为上面填 $6$，下面填 $1$；

接下来是转移方程。  
- 当 $j=1$ 时，由于 $1$ 与 $1,5,6$ 都互质，所以所有方案都可行，所以 $dp_{i,1}=dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,5}+dp_{i-1,6}+dp_{i-1,7}$。  
- 当 $j=2$ 时，由于 $5$ 不与 $5$ 互质，所以方案二、五不行，所以 $dp_{i,2}=dp_{i-1,1}+dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,6}+dp_{i-1,7}$。  
- 当 $j=3$ 时，由于 $6$ 不与 $6$ 互质，所以方案三、四不行，所以 $dp_{i,3}=dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,5}+dp_{i-1,6}+dp_{i-1,7}$。  
- 当 $j=4$ 时，由于 $5$ 不与 $5$ 互质、$6$ 不与 $6$ 互质，所以方案三、四、六不行，所以 $dp_{i,4}=dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,5}+dp_{i-1,7}$。  
- 当 $j=5$ 时，由于 $5$ 不与 $5$ 互质、$6$ 不与 $6$ 互质，所以方案二、五、七不行，所以 $dp_{i,5}=dp_{i-1,1}+dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,6}$。  
- 当 $j=6$ 时，由于 $5$ 不与 $5$ 互质，所以方案四、六不行，所以 $dp_{i,6}=dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}+dp_{i-1,5}+dp_{i-1,7}$。  
- 当 $j=7$ 时，由于 $6$ 不与 $6$ 互质，所以方案五、七不行，所以 $dp_{i,7}=dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,6}+$。  

最后的答案就是 $dp_{n,1}$。

# 代码 
```cpp
#include<bits/stdc++.h>
#define int long long//不开 long long 见祖宗
using namespace std;
const int N=1e5+5;
const int mod=1e9+7;
int dp[N][8];
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=7;i++) dp[0][i]=1;
	for(int i=1;i<=n;i++){
		dp[i][1]=dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4]+dp[i-1][5]+dp[i-1][6]+dp[i-1][7];
		dp[i][2]=dp[i-1][1]+dp[i-1][3]+dp[i-1][4]+dp[i-1][6]+dp[i-1][7];
		dp[i][3]=dp[i-1][1]+dp[i-1][2]+dp[i-1][5]+dp[i-1][6]+dp[i-1][7];
		dp[i][4]=dp[i-1][1]+dp[i-1][2]+dp[i-1][5]+dp[i-1][7];
		dp[i][5]=dp[i-1][1]+dp[i-1][3]+dp[i-1][4]+dp[i-1][6];
		dp[i][6]=dp[i-1][1]+dp[i-1][3]+dp[i-1][4]+dp[i-1][3]+dp[i-1][7];
		dp[i][7]=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]+dp[i-1][6]+dp[i-1][3];
		for(int j=1;j<=7;j++){
			dp[i][j]%=mod;
		}
	}
	cout<<(dp[n][1])%mod;
	return 0;
}
/*
1: 1 1
2: 1 5
3: 1 6
4: 5 6
5: 6 5
6: 5 1
7: 6 1
*/
```
java:
```java
import java.util.Scanner;

public class Main {
    static final int N = 100005;
    static final int mod = 1000000007;
    static long[][] dp = new long[N][8];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        
        for (int i = 1; i <= 7; i++) {
            dp[0][i] = 1;
        }
        
        for (int i = 1; i <= n; i++) {
            dp[i][1] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][5] + dp[i - 1][6] + dp[i - 1][7]) % mod;
            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][6] + dp[i - 1][7]) % mod;
            dp[i][3] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][5] + dp[i - 1][6] + dp[i - 1][7]) % mod;
            dp[i][4] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][5] + dp[i - 1][7]) % mod;
            dp[i][5] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][6]) % mod;
            dp[i][6] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][3] + dp[i - 1][7]) % mod;
            dp[i][7] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4] + dp[i - 1][6] + dp[i - 1][3]) % mod;
        }
        
        System.out.println(dp[n][1] % mod);
        scanner.close();
    }
}
```

---

## 作者：Maxsong (赞：0)

# 题解：P12891 [蓝桥杯 2025 国 Java B] 瓷砖填充

由于是 $2 \times N$ 个格子，所以我们把所有可能的列的排列情况列出来：

|行 \ $j=$|$0$|$1$|$2$|$3$|$4$|$5$|$6$|
|---|---|---|---|---|---|---|---|
|上|$1$|$1$|$1$|$5$|$5$|$6$|$6$|
|下|$1$|$5$|$6$|$1$|$6$|$1$|$5$|

（易知 $5/5$ 和 $6/6$ 不合法）

所以我们设计状态 $f _{i,j}$ 表示第 $i$ 列填写上表 $j$ 情况。

当然还要设计互斥：

|$j =$ \ $j =$|$0$|$1$|$2$|$3$|$4$|$5$|$6$|
|---|---|---|---|---|---|---|---|
|$0$|
|$1$||#|||||#
|$2$|||#||#
|$3$||||#|#
|$4$|||#|#|#
|$5$||||||#|#
|$6$||#||||#|#

（打 # 表示互斥）

然后我们就能得出转移方程：

$$f_{i,j}=\sum _{j'=0} ^{6}\text{（与 } j\text{ 不互斥的 }j' \text{）} \ f _{i-1,j'}$$

就可以写出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
// 不开 long long 见祖宗
long long n,f[100001][7],ans;
const long long m=1e9+7;
signed main(void){
    cin>>n;
    for(long long l=0;l<7;l++) f[1][l]=1;
    for(long long i=2;i<=n;i++){
        for(long long j=0;j<7;j++) f[i][0]+=f[i-1][j];
        f[i][0]%=m;
        f[i][1]=(f[i][0]-f[i-1][1]-f[i-1][6]);
        f[i][2]=(f[i][0]-f[i-1][2]-f[i-1][4]);
        f[i][3]=(f[i][0]-f[i-1][3]-f[i-1][4]);
        f[i][4]=(f[i][0]-f[i-1][3]-f[i-1][4]-f[i-1][2]);
        f[i][5]=(f[i][0]-f[i-1][5]-f[i-1][6]);
        f[i][6]=(f[i][0]-f[i-1][1]-f[i-1][6]-f[i-1][5]);
// 简化转移方程
        for(long long j=0;j<7;j++) f[i][j]+=2*m,f[i][j]%=m; // 注意防负
    }for(long long i=0;i<7;i++){
        ans+=f[n][i];
        ans%=m;
    }cout<<ans<<endl;
    return 0;
}
```

---

## 作者：one_zero_two_zero (赞：0)

首先看到，本题对于数字唯一的限制**只和周围四个格子有关**。

我们想到应该需要按照一边向另外一边的顺序来放置数字，因为这样永远只需要考虑一边的限制，简单很多。

再结合题目中说明的墙上的瓷砖是 $2\times N$ 的，所以每一列只有两个瓷砖。这引导我们应该**一列一列地去填数字**。

然后我们就发现：对于已经填了 $x$ 列的一种情况，我们想去填 $x+1$ 列，需要且仅需要考虑第 $x$ 列。

即，我们用 $i,c_1,c_2$ 表示填了 $i$ 列且第 $i$ 列上下两个数字分别是 $c_1,c_2$ 的情况。发现任何 $i,c_1,c_2$ 相同的局面在后续考虑中**完全等价**。

因此考虑动态规划，构造 $dp_{i,c_1,c_2}$ 表示填了 $i$ 列且第 $i$ 列上下两个数字分别是 $c_1,c_2$ 的情况。

考虑如何转移，题目中给出的三个数字 $1,5,6$ 两两相互互质，所以我便用 $0,1,2$ 代指这三个数字。

> 互质：$a,b$ 两数互质当且仅当 $\gcd(a,b)=1$。

先考虑一列内如何组合是合法的，发现对于这三个数字任意组合的情况，只有 $\{1,1\}$ 和 $\{2,2\}$ 是不合法的。因此一行内合计有七种状态。

在考虑列之间，因为是四联通，所以我们逐行考虑，每行内合法的状态仍是上述七种。

因此我们得到了转移。

> 事实上并不需要把所有点对点的转移都写出来，可以理解为你只需要暴力枚举最后两列的全部情况然后把不合法的判掉即可。

```cpp
if ((p1.first == p2.first && p1.first * p2.first) 
  || (p1.second == p2.second && p1.second * p2.second))
  continue;
dp[i][p1.first][p1.second] += dp[i - 1][p2.first][p2.second];
dp[i][p1.first][p1.second] %= mod;
```

**【完整代码】**

```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;

int N;
long long dp[100005][3][3];

int main(){
  scanf("%d", &N);
  // 初始化
  dp[1][0][0] = 1;
  dp[1][0][1] = dp[1][0][2] = dp[1][1][2] = 1;
  dp[1][1][0] = dp[1][2][0] = dp[1][2][1] = 1;
  vector<pair<int, int>> mat;
  mat.push_back({0, 0});mat.push_back({0, 1});mat.push_back({0, 2});mat.push_back({1, 2});mat.push_back({1, 0});mat.push_back({2, 0});mat.push_back({2, 1}); // 七种合法情况
  // 转移
  for (int i = 2; i <= N; i ++){
    for (auto && p1 : mat){
      for (auto && p2 : mat){
        if ((p1.first == p2.first && p1.first * p2.first) 
          || (p1.second == p2.second && p1.second * p2.second))
          continue;
        dp[i][p1.first][p1.second] += dp[i - 1][p2.first][p2.second];
        dp[i][p1.first][p1.second] %= mod;
      }
    }
  }
  long long ans = 0;
  for (auto && p : mat){
    ans += dp[N][p.first][p.second];
  }
  printf("%lld\n", ans % mod);
  
  return 0;
}
```

---


# 最佳课题选择

## 题目描述

Matrix67 要在下个月交给老师 $n$ 篇论文，论文的内容可以从 $m$ 个课题中选择。由于课题数有限，Matrix67 不得不重复选择一些课题。完成不同课题的论文所花的时间不同。具体地说，对于某个课题 $i$，若 Matrix67 计划一共写 $x$ 篇论文，则完成该课题的论文总共需要花费 $A_i\times x^{B_i}$ 个单位时间。给定与每一个课题相对应的 $A_i$ 和 $B_i$ 的值，请帮助 Matrix67 计算出如何选择论文的课题使得他可以花费最少的时间完成这 $n$ 篇论文。

## 说明/提示

### 样例说明

$4$ 篇论文选择课题一，$5$ 篇论文选择课题三，剩下一篇论文选择课题二，总耗时为 $2\times4^1+1\times1^2+2\times5^1=8+1+10=19$ 。可以证明，不存在更优的方案使耗时小于 $19$。

### 数据规模与约定

对于 $30\%$ 的数据，$n\le10,m\le5$。

对于 $100\%$ 的数据，$1\le n\le200$，$1\le m\le20$，$1\le A_i\le100$，$1\le B_i \le 5$。

## 样例 #1

### 输入

```
10 3
2 1
1 2
2 1
```

### 输出

```
19
```

# 题解

## 作者：zzy_123 (赞：46)

//这个题目可以到绿题也是个奇迹

//本来思路乱七八糟，想先试一下，下一个测试点再来写的，没想到直接就A了。

//因为本人菜鸡所以适合新手理解

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[21][300],n,m,j,k,A[210],B[210],sum[10000],ans=0;
//f[a][b]意思是前a个课题写b篇的最大值 
int main()
{
	long long int p,a,b,c,d,e;
	cin>>m>>n;
	for(a=1;a<=n;a++)cin>>A[a]>>B[a];//输入不解释
	for(a=1;a<=n;a++)//前a个课题
	{
		for(b=1;b<=m;b++)//选b篇写
		{
			for(c=0;c<=b;c++)//1.见下
			{
				p=A[a]*pow(c,B[a]);//当前的值
				if(f[a][b]==0||a==1)f[a][b]=f[a-1][b-c]+p;
				else//因为当f[a][b]初始赋值或a=1需要特判
				f[a][b]=min(f[a-1][b-c]+p,f[a][b]);//状态转移
			}
		}
	}
	cout<<f[n][m];
}
```
1.
   在第a篇中写0篇  f[a][b]=min(f[a-1][b]+p,f[a][b])//p见代码
   
   在第a篇中写1篇  f[a][b]=min(f[a-1][b-1]+p,f[a][b])
   
   在第a篇中写2篇  f[a][b]=min(f[a-1][b-2]+p,f[a][b])
   
   在第a篇中写c篇  f[a][b]=min(f[a-1][b-c]+p,f[a][b])
   
   因为已经保证前面的数组都是最大值,所以就是判断在a中选篇数再加上
   
   前一篇文章a-c的最大值。

---

## 作者：清远学会 (赞：22)

# 动态规划
~~我太弱了，竟然推了半个小时~~
### 简单讲讲转移方程：
	1，先注意到一点，nm范围很小，所以我先预处理出所有论文对相应课题的对应的时间;
    2，设刚预处理的数组为a[i][j];表示第i个课题下有j篇论文的对应时间；
    3，设f[i][j],为当我有i个课题和j篇论文可写时的最小时间；
    4，初始化为最大值，当然，f[i][0] = 0(第i个课题不写）
    5，此层的状态就由上层转移而来（感性理解一下）
可以写成这样：
### f[i][j] = min(f[i][j],f[i-1][k] + a[i][j-k];
可以表示为：对于当前的i个课题与j篇论文，就由上层的k篇和本层的j-k篇转移；
### 最后奉上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define N 3000
using namespace std;

int n,m;
int A[N],B[N];
long long a[N][N];
long long f[N][N];

inline long long KSM(long long x,int y) {
	long long res = 1;
	for( ; y ; y >>= 1,x = x * x)
		if(y & 1) res = x * res;
	return res;
}

int main() {
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= m;i ++) {
		scanf("%d%d",&A[i],&B[i]);
		for(int j = 1;j <= n;j ++)
			a[i][j] = (long long)((long long)A[i] * KSM(j,B[i]));
	}
	for(int i = 0;i <= m;i ++)
		for(int j = 0;j <= n;j ++)
			f[i][j] = 1e17;
	for(int i = 0;i <= m;i ++) f[i][0] = 0;
	for(int i = 1;i <= m;i ++)
		for(int j = 0;j <= n;j ++) {
			for(int k = 0;k <= j;k ++)
				f[i][j] = min(f[i][j],f[i - 1][k] + a[i][j - k]);
		}
	printf("%lld",f[m][n]);
	return 0;
}
```

---

## 作者：Right (赞：15)

这是一道淳朴的动态规划题

>>楼下都是二维数组
>为了节省空间
>>我上一个一维的代码
你还能看到我降为的过程

```cpp
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <cmath>
using namespace std;
#define min(a,b) a<b?a:b
int n,m;
//int a[23],b[23]; //y=kx+b ,a is k and b is b
int a,b;
long long dp[20008]; //20*100=2000;
int main()
{
    int i,j,k;
    memset(dp,12,sizeof(dp));
    dp[0]=0;
    cin>>n>>m;
    for (i=1; i<=m; ++i)
    {
        //cin>>a[i]>>b[i];
        cin>>a>>b;  动态规划中读入，节省时间！
        for (j=n; j>=1; --j)
        {
            for (k=j; k>=1; --k)
            {
                dp[j]=min(dp[j],dp[j-k]+a*pow(k,b));
            }
        }
    }
    cout<<dp[n];
}
```

---

## 作者：7000qwq (赞：9)

翻了一下题解，好像大家都是dp做的？写一个有点像贪心的做法qwq

很明显（我不会证明qwq），对于同一个课题，后面写的一篇论文一定比前面写的一篇论文要花费更多时间【就比如说(3*A^B)-(2*A^B)>(2*A^B)-(1*A^B)】，

那么我们只需要扫n遍，每次枚举课题，找到花费时间最小的一篇论文 /*注意是一篇论文而不是当前课题的所有论文花费时间之和 */，更新答案就可以了。

复杂度应该是O(mn)，意外地跑得挺快，26ms。

贴代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m;
int a[21],b[21];
ll num[21];//每个课题写了多少篇论文
ll ech[21];//当前每一个课题再多写一篇论文所需时间
ll sum=0;
int main()
{scanf("%d%d",&n,&m);
 for(int i=1;i<=m;i++)
       scanf("%d%d",&a[i],&b[i]);
 while(n>0)
          {ll k,minn=99999999999999;
           for(int i=1;i<=m;i++) 
                {ech[i]=a[i]*pow(double(num[i]+1),double(b[i]))-a[i]*pow(double(num[i]),double(b[i]));
                 if(minn>ech[i])
                   {minn=ech[i];
                    k=i;//记录哪一个课题再写一篇论文所需时间最小
                   }
                }
          sum+=minn,num[k]++;
          n--;
          }
 cout<<sum;
 return 0;
}
```

//2018noip rp++！

---

## 作者：Miri (赞：8)

```cpp
//这题怎么被刷到绿题的……
//题目中的Ai*x^Bi坑啊！不知道有没有和本蒟蒻一样傻qwq，它的意思是Ai*(x^Bi)，先进行^运算！！而不是(Ai*x)^Bi！！
//可怕的是，这题按(Ai*x)^Bi做竟然还能过样例……但是交后全WA！
//代码中写了解释，还有一组和样例不一样的数据~希望能帮助到大家qwq
//%%楼下大佬！
#include<iostream>
#include<cmath>
#include<cstring>
#include<climits>
using namespace std;
long long n,m,a[22],b[22],f[202];
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
      f[i]=INT_MAX/3;
    for(int i=1; i<=m; i++)
        cin>>a[i]>>b[i];
    f[0]=0;
    for(int i=1; i<=m; i++)  //用第i个课题进行更新
        for(int v=n; v>=1; v--)  //前v个课题
            for(int j=0; j<=v; j++)  //第i个课题选几个
                f[v]=min(f[v],f[v-j]+a[i]*(long long)pow(double(j),double(b[i])));  //好像pow函数中两个数要用double型，然后再转long long型就行啦
    cout<<f[n];
    return 0;
}
```
/\*
10 3
86 5
26 5
33 3

10712
\*/

---

## 作者：霍士弘 (赞：7)

一道非常简单的 dp，其实是简单的背包。  
言归正传，考虑dp。  
## 状态设计
设 $f_{i,j}$ 为 使用编号 $1 \sim i$ 的课题，完成 $j$ 篇论文花费的**最小时间**。  
类似背包。
## 状态转移  
首先，题目中已经说了，如果将 $x$ 篇论文都写成 $i$ 课题的话，则花费 $A_i \times x^{B_i}$ 的时间。  
背包的模型已经很明显了，但是这种背包，每个物品的**价值**是你分配给它**重量**的一个**函数**，换句话说，每个物品的价值是不定的，会根据你分配的重量变化。这类背包问题又称为**泛化背包**。  
考虑第 $i$ 个课题，可以分配给这个课题 $k$ 篇论文，枚举这个 $k$ 即可。
所以，我们得到转移方程（类似背包）  
$$f_{i,j} = \min_{0 \leq k < j} \{ f_{i-1,j-k} + A_i \times k^{B_i}\}$$  
## 边界条件  
$f_{1,i} = A_1 \times i^{B_1}$  
很明显，只用第一个课题。  
## 代码  
如果按照极限数据来算，答案可能达到：$20 \times 100 \times 200^5 = 6.4 \times 10^14$，所以$\inf$的定义就大一点，而且要开long long。  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define maxn 200
#define maxm 20
#define inf 100000000000000000
#define ll long long
using namespace std;
int n,m;
int a[maxm + 10],b[maxm + 10];
ll f[maxm + 10][maxn + 10];
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= m;i++)
	{
		cin>>a[i]>>b[i];
	}
	f[1][0] = 0;
	for(int i = 1;i <= n;i++)
	{
		f[1][i] = a[1] * (ll)pow(i,b[1]);//边界条件
	}
	for(int i = 2;i <= m;i++)
	{
		for(int j = 0;j <= n;j++)
		{
			ll minn = inf;
			for(int k = 0;k <= j;k++)//枚举给这个物品分配的论文个数
			{
				minn = min(minn,f[i-1][j - k] + a[i] * (ll)pow(k,b[i]));
			}
			f[i][j] = minn;
		}
	}
	cout<<f[m][n];
	return 0;
}
```

---

## 作者：Karlis (赞：6)

看到标签和题解的时候我吓了跳，~~可怜我这种蒟蒻居然不会dp~~，用stl优先队列打过去了。

考虑到第k种论文的前x篇价格为 
$ A_k*x^{B_k}$

就可以很轻易地想到第x+1篇的价格为
$ A_k*((x+1)^{B_k}-x^{B_k})$

特别地，对于第k种第一篇显然它的花费是$ A_k$

于是我们就可以很愉快地开一个三元组记录以下信息

1.该元素记录第k种文章

2.这是这种的第x篇了

3.写这篇的花费

然后把这个三元组扔到优先队列里，初始化时加入所有文章第一篇的花费，每次取出最小的花费加进答案，再扔进去写下一篇的花费，反复~~横跳~~n次就可以了。

以下是丑陋的代码
（~~希望不会成为题解中的泥石流~~）


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> P;
inline int read() {//读入优化，可以忽视
	int x = 0, f = 1;
	char ch;
	while (!isdigit(ch = getchar())) if (ch == '-') f = -1;
	x = ch - '0';
	while (isdigit(ch = getchar())) x = x * 10 + ch - '0';
	return x * f;
}
int n, m, a[30], b[30];
ll ans;
struct ele {
//奇奇怪怪的三元组，重载运算符、友元、和优先队列的细节我就不讲了
	ll val;
	int type, num;
	friend bool operator <(ele a, ele b) {
		return a.val < b.val;
	}
	friend bool operator >(ele a, ele b) {
		return a.val > b.val;
	}
};
priority_queue<ele, vector<ele>, greater<ele> > q;
ll pmod(ll a, ll n) {//计算a的n次幂
	ll ans = 1;
	while (n) {
		if (n & 1) ans = ans * a;
		a = a * a;
		n >>= 1;
	}
	return ans;
}
int main() {
//	ios::sync_with_stdio(0);
	n = read();
	m = read();
	for (int i = 1; i <= m; i++) a[i] = read(), b[i] = read();
	for (int i = 1; i <= m; i++) q.push(ele{ a[i],i,1 });
	while (n--) {
		ele tmp = q.top();
		q.pop();
		ans += tmp.val;
		ll val = 1ll * a[tmp.type] * (pmod(tmp.num + 1, b[tmp.type]) - pmod(tmp.num, b[tmp.type]));
        //val是计算出的刚取出的那篇的下一篇的花费
		q.push(ele{val,tmp.type,tmp.num + 1 });
	}
	cout << ans;
	return 0;
}
```


---

## 作者：ctq1999 (赞：6)

## 题解

题意要求，完成 $n$ 篇论文的最少时间是多少。

可以得出这是背包的算法。每个课题都可以写 $x \in[1, 2,\dots, n]$ 篇论文。

一般的 01 背包只有两重循环，第一重是数量 $n$，第二重是容量$m$。

因为不会两次选择相同的课题，一次选择一个课题，写 $x$ 篇课题后就不会再选择这个课题了。所以我们在最外面的循环是第 $i$ 课题，中间的循环是总共写了 $j$ 论文，最里面的循环是当前课题写 $k$ 篇论文。

设 $DP[x]$ 表示写 $x$ 篇论文至少要用的时间，然后直接rush。

注意状态转移时，当 $f[j]=0$时，表示这个状态还没被遍历过，要直接 `DP[j] = DP[j - k] + c ;`，否则 $\text{min}$ 会取 $0$，导致转移不正确。当 $i=1$ 时，要把 $DP$ 数组正确地刷满，所以也直接 `DP[j] = DP[j - k] + c ;`，否则状态会转移不正确。

## 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 40100
#define ll long long

using namespace std;

int n, m, ans, tot;

int w[MAXN];
int a[MAXN], b[MAXN];
ll f[MAXN];

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) {
		scanf("%d%d", &a[i], &b[i]);
	}
	f[0] = 0;
	for (int i = 1; i <= m; i++) {
		for (int j = n; j >= 0; j--) {
			for (int k = 1; k <= j; k++) {
				ll c = a[i] * pow(k, b[i]);
				if (i == 1 || f[j] == 0) f[j] = f[j - k] + c;
				else f[j] = min(f[j], f[j - k] + c);
			}
		}
	}
	cout << f[n] << endl;
	return 0;
}
```

---

## 作者：Apro1066 (赞：3)

令$dp[i][j]$为表示前$i$个课题中完成$j$篇论文的最小耗时，其中$k$为对于课题$i$选择$j$个论文，因此$k$需要枚举($0 \leq k \leq j$)，则：

$$dp[i][j]=min(dp[i][j],dp[i-1][j-k]+a[i]×k^{b[i]})$$

根据设计的状态，答案为$dp[m][n]$。
```cpp
#include <stdio.h>
#include <iostream>
#include <memory.h>
#include <math.h>
#define ll long long int
#define inf 2e9+7
using namespace std;
ll n,m,s,dp[21][201],a[21],b[21];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register ll i,j,k;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i];
	}
	memset(dp,inf,sizeof(dp));
	for(i=0;i<=20;i++)
	{
		dp[i][0]=0;//完成论文数为0时值为0
	}
	for(i=1;i<=n;i++)//枚举论文 
	{
		for(j=1;j<=m;j++)//枚举课题 
		{
			for(k=0;k<=i;k++)//枚举课题j选择多少个论文 
			{
				dp[j][i]=min(dp[j][i],dp[j-1][i-k]+a[j]*(ll)pow((double)k,(double)b[j]));
			}
		}
	}
	cout<<dp[m][n]<<endl;
	return 0;
}
```

---

## 作者：CRH380B (赞：3)

f[i][j]表示前i课题中完成前j篇论文的最小花费，可得递推式f[i][j]=min{f[i-1][j-k]+a[i]\*k^b[i]}（其中1<=i<=m,1<=j<=n,0<=k<=j，具体见代码），所求答案为f[m][n].



```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
using namespace std;
int a[22],b[22];
long long f[22][202]={0};
long long c(int x,int y){
    int i;
    long long s=1;
    for(i=1;i<=y;++i)s*=x;
    return s;
}
long long min(long long x,long long y){
    return x<y?x:y;
}
int main(){
    int n,m,i,j,k;
    scanf("%d%d",&n,&m);
    for(i=0;i<=20;++i)for(j=1;j<=200;++j)f[i][j]=2147483647;//初始赋大值（注意：当j=0即完成论文数为0时值为0）
    for(i=1;i<=m;++i){
        scanf("%d%d",&a[i],&b[i]);
    }
    for(i=1;i<=n;++i){
        for(j=1;j<=m;++j){
            for(k=0;k<=i;++k){
                f[j][i]=min(f[j][i],f[j-1][i-k]+a[j]*c(k,b[j]));
            }
        }
    }
    printf("%lld\n",f[m][n]);
    return 0;
}

```

---

## 作者：loaky (赞：1)

突然发现和各位大佬的解法不一样，qwq,蒟蒻开始准备推f[i][j]表示选i门课题，j门论文所需要的最小时间，qwq，没有把动态转移方程推出来，于是，就只能用傻逼办法，我的f[i][j]表示第i门课写j篇论文做需要的时间，可以提前预处理出来，然后dp[i]表示写前i篇论文所需要的最小时间，每次贪心取最优解，用cnt记录第j篇作文已经写过多少次，下次再用的时候增加量就是f[i][cnt[i]+1]-f[i][cnt[i]],每次拍一遍序就可以了，%%%%%%%%%%各位大佬
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=205;
int n,m,a[maxn],b[maxn];
long long dp[maxn],f[maxn][maxn],cnt[maxn];
struct node{
	long long nm;
	int id;
}c[maxn];
bool cmp(node t,node j){
	return t.nm<j.nm;
}
long long qp(long long ai,long long bi){
	long long sum=1,j=ai;
	while(bi){
		if(bi&1) sum*=j;
		j*=j;
		bi>>=1;
	}
	return sum;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a[i],&b[i]);
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=a[i]*qp(j,b[i]);
		}
	}
	for(int i=1;i<=m;i++){
			c[i].nm=f[i][1];
			c[i].id=i;
	}
	sort(c+1,c+m+1,cmp);
	dp[1]=c[1].nm;
	cnt[c[1].id]++;
	for(int i=2;i<=n;i++){
		for(int j=1;j<=m;j++){
			c[j].nm=f[j][cnt[j]+1]-f[j][cnt[j]];
			c[j].id=j;
		}
		sort(c+1,c+m+1,cmp);
		dp[i]=dp[i-1]+c[1].nm;
		cnt[c[1].id]++;
	}
	printf("%lld",dp[n]);
	return 0;
}
```

---

## 作者：Error_Eric (赞：0)

### 题意

[Link](https://www.luogu.com.cn/problem/P1336)

### Sol

一个假设第 $i$ 次做第 $j$ 个课题，那么可以看做这次的代价是 $A_ji^{B_j}-A_j(i-1)^{B_j}$ 。

一个显然结论是同一个课题越做越贵。毕竟 $A_jx^{B_i}$ 这玩意肯定连续求导一下肯定单调不降，那自变量位移相同当然是位置越靠右函数值变化更大。（当然感性理解更好理解）

注意到 $n\times m$ 很小，把所有可能的，单个课题的代价全部存在一个数组里面排序，取前 $n$ 个求和就可以了。根据前面的性质，如果这个课题的第二次在被选择的里面，那么第一次肯定也在被选择的里面，因此这个方案是肯定是合法的。

翻了下题解很好奇为什么有人发现了这个性质不加证明还要用堆。

没卡常，在最优解第一页，比很多 dp 快，也基本是最短的解法了。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<numeric>
using namespace std;
inline const void readln(int &I){
    I=0;char C=getchar();
    while(!isdigit(C))C=getchar();
    while( isdigit(C))(I*=10)+=(C-'0'),C=getchar();
}
//const int _=1e6+5;
typedef unsigned long long ull;
int n,m,ai,bi,cnt,top;
ull c[200*20+5];
ull pow(int b,int k){//没必要快速幂毕竟 B_i 就那么点大
    ull ans=1ull; while(k--)ans*=b;return ans;
}
int main(){
    readln(n),readln(m);
    for(int i=1;i<=m;i++){
        readln(ai),readln(bi);
        for(int j=1;j<=n;j++)
            c[++top]=ai*(pow(j,bi)-pow(j-1,bi));
    }
    sort(c+1,c+top+1),printf("%llu\n",accumulate(c+1,c+n+1,0ull));
}
```

---

## 作者：F_Mu (赞：0)

这道题用DP，我的心里路程是，对每种课题只能操作一次，否则如果有第二次操作的话，会对该种课题的数量进行改变，则十分复杂。每种课题操作一次我们就能进行边读边算的操作。然后设置一个dp1数组，dp1[j]代表写了j篇论文的最少时间。但是我们知道每篇课题只能操作一次，即若是改变了dp1[j]则不能在dp1[j]的基础上继续写该课题。

于是我想到了使用一个dp2数组，这个数组的意义是在操作第i个课题时，在第i-1的基础上进行操作。状态转移方程为  dp2[j + k] = min(dp1[j] + aa * quick_mod(k, bb), dp2[j + k]);  意思是在dp1的基础上（此时dp1只操作到了第i-1个课题），因此这样并不会对同一个课题操作两次。然后用  dp1[j] = min(dp1[j], dp2[j]);  将dp1进行到第i个课题。

看代码。

```cpp
#include <bits/stdc++.h>

#define maxn 205
#define inf 0x3f3f3f3f
using namespace std;

long long quick_mod(long long a, long long b) {
    long long ans = 1, base = a;
    while (b != 0) {
        if (b & 1)
            ans *= base;
        base *= base;
        b >>= 1;
    }
    return ans;
}//快速幂模板

long long dp1[maxn], dp2[maxn];

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    long long q, w;
    scanf("%lld%lld", &q, &w);
    for (int i = 0; i <= n; ++i) {
        dp1[i] = q * quick_mod(i, w);
    }//dp1数组的初始化
    for (int i = 1; i < m; ++i) {
        long long aa, bb;
        scanf("%lld%lld", &aa, &bb);
        memset(dp2, inf, sizeof(dp2));//dp2数组的初始化
        for (int j = 0; j <= n; ++j) {
            for (int k = 0; j + k <= n; ++k) {
                dp2[j + k] = min(dp1[j] + aa * quick_mod(k, bb), dp2[j + k]);//状态转移方程
            }
            dp1[j] = min(dp1[j], dp2[j]);
        }
    }
    printf("%lld", dp1[n]);
    return 0;
}
```

本蒟蒻的第一篇题解，若讲的不清楚请谅解，嘤。

---

## 作者：UltiMadow (赞：0)

看到没有记搜的题解，我就来补一篇

废话不多说，直接上代码（自行阅读注释）

```cpp
#include<bits/stdc++.h>
#define MAXN 50
#define ll long long
using namespace std;
ll n,m,a[MAXN],b[MAXN];
ll mem[210][MAXN];
ll Cal(ll x,ll y)//快速幂不解释
{
	ll ans=1;
	while(y)
	{
		if(y%2)
			ans*=x;
		x*=x;
		y/=2;
	}
	return ans;
}
ll DFS(ll Left_essay,ll Topic)//记搜一定是函数，不是过程；Left_essay表示剩余几篇论文，Topic表示第几个课题
{
	if(Left_essay==0)return 0;
	if(Topic==m)return a[Topic]*Cal(Left_essay,b[Topic]);//如果是最后一个课题就只能把剩余的论文全部写掉
	if(mem[Left_essay][Topic]!=-1)return mem[Left_essay][Topic];//记忆化
	ll ret=9999999999999;
	for(ll i=0;i<=Left_essay;i++)
	{
		ret=min(ret,DFS(Left_essay-i,Topic+1)+a[Topic]*Cal(i,b[Topic]));
	}
	mem[Left_essay][Topic]=ret;//记忆化
	return ret;
}
int main()
{
	memset(mem,-1,sizeof(mem));//初始化都为-1，可以少写一个visit变量
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=m;i++)scanf("%lld%lld",&a[i],&b[i]);
	printf("%lld",DFS(n,1));
	return 0;//完美结束
}
```


---

## 作者：混沌 (赞：0)

看了一下楼下的dp方程 不大一样 我这是二维DP 方便新手理解吧

dp[i][j] 是指前i个（包括i）课题中选去j篇论文所需最小值







```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
int n,m;
ll x[30];
ll y[30];
ll dp[300][300];//dp[i][j] 是指前i个（包括i）课题中选去j篇论文所需最小值
ll pow_(int d,int k){//快速幂
    ll ans=1;
    ll base=d;
    while(k){
        if(k%2) ans*=base;
        base*=base;
        k>>=1;
    }
    return ans;
}
ll add(int a,int b){//由题意的选课花费
    return x[a]*pow_(b,y[a]);
}
ll min_(ll a,ll b){//取最小值
    if(a<b) return a;
    else return b; 
}
int main(){
    scanf("%d%d",&m,&n);
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++) dp[i][j]=2147483647;//注意要先把所有情况定义为极大值
    }
    for(int i=1;i<=n;i++) dp[i][0]=0;//初始化
    for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
    for(int i=1;i<=m;i++) dp[1][i]=add(1,i);//初始化
    for(int i=2;i<=n;i++){
        for(int j=0;j<=m;j++){
            for(int g=0;g<=j;g++){
                dp[i][j]=min_(dp[i][j],dp[i-1][g]+add(i,j-g));//枚举出所有dp[i][j]由dp[i-1][g]转移来的情况
            }
        }
    }
    printf("%lld",dp[n][m]);//输出值
    return 0;
}
```

---

## 作者：Phrooce (赞：0)

所以说....这道题....其实是假的完全背包？

┑(￣Д ￣)┍  算了当做多重背包就行了

f[ i ]表示i堂课的最少时间 f[ i ]=min( f[ i ] ， f[ i-t ]+a[ k ]\*t^b[ k ]

其中 0<j<i 即 t为当前选择的课的数量

初始状态  f[ 1~n ]=0x7f7f7f（够大就行了） f[ 0 ]=0


代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[210];
long long m,n,a[30],b[30];
long long get(int a,int b)//这个是快速幂 其实可以不要 因为b[ i ]很小  
{
    if(b==1) return a;
    long long now=a,t=b,res=1;
    while(t)
    {
        if(t&1) res*=now;
        now*=now;
        t>>=1;
    }
    return res;
}
int main()
{
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i]>>b[i];
    }
    memset(f,0x7f,sizeof f);
    f[0]=0;
    for(int i=1;i<=m;i++)
    for(int j=n;j>0;j--)
    for(int t=j;t>0;t--)
    f[j]=min(f[j],f[j-t]+a[i]*get(t,b[i]));
    cout<<f[n];
    return 0;
}

```

---

## 作者：chenshaoqian (赞：0)

w[i][j]表示第i个课程完成j篇论文的时间

f[i][j]=min(f[i][j],f[i-1][k]+w[i][j-k])(1<=j<=n,0<=k<=j)

表示前i个课程完成j篇论文用时最少。枚举分给前i-1个课程k篇论文+第i个课程完成j-k篇论文，找出最小值，就是f[i][j]的值了。

和最大乘积类似。


---


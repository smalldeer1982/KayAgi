# [KOI 2025 #1] 釜山观光

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

釜山广域市为了方便游客的交通出行，销售以下几种交通票券。

| 类别 | 使用人数 | 有效期 | 价格 | 备注 |
| :--: | :--: | :--: | :--: | :--: |
| 1 日票 | 1 人 | 购买当天，共 **1** 天 | $p_1$ | 有效期内仅限购买者本人使用 |
| 3 日票 | 1 人 | 含购买当天在内的连续 **3** 天 | $p_3$ | 有效期内仅限购买者本人使用 |
| 5 日票 | 1 人 | 含购买当天在内的连续 **5** 天 | $p_5$ | 有效期内仅限购买者本人使用 |
| 组合票 | 2 人 | 含购买当天在内的连续 **4** 天 | $p_{pair}$ | 有效期内两人均可使用 |

所有票券均在**购买后立即生效**，并可在票券上标明的有效期内使用交通工具。当然，即使持有票券但未使用交通工具，或持有多张有效期重叠的票券，或票券的有效期超出了 N 天的观光行程也都是允许的。另外请注意，$p_1 \le p_3 \le p_5$ 这一关系**并非总是**成立。

Hankook 和 Jeong-ul 将在釜山一同停留 $N$ 天。但是，两人各自制定了自己的观光计划，并决定了每天自己是否要进行观光。为了完成观光行程，对于每个人，在他们**进行观光的每一天**，都必须持有一张有效的票券（包括组合票）。

例如，假设 $N=9$，$p_1=3, p_3=7, p_5=12, p_{pair}=15$，Hankook 和 Jeong-ul 各自的日程如下：

| 日期 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Hankook | X | O | O | X | O | O | O | X | O |
| Jeong-ul | O | O | X | X | X | O | O | O | X |

(O 代表观光，X 代表不观光)

如果只使用 1 日票，总观光天数为 11 天 (Hankook 6 天 + Jeong-ul 5 天)，费用为 11 (观光天数) × 3 (1 日票价格) = 33。

但是，如果两人在**第 5 天至第 8 天**共享一张组合票，总费用仅为 30。

更有甚者，如果 Hankook 购买一张**第 5 天至第 7 天**的 3 日票，Jeong-ul 购买一张**第 6 天至第 8 天**的 3 日票，总费用可以节省至 29。

当 Hankook 的日程由字符串 $A = A_1A_2\cdots A_N$ 表示，Jeong-ul 的日程由字符串 $B = B_1B_2\cdots B_N$ 表示时，对于日期 $i(1 \le i \le N)$:

*   如果 Hankook 进行观光，$A_i=1$；否则 $A_i=0$
*   如果 Jeong-ul 进行观光，$B_i=1$；否则 $B_i=0$

请根据以上形式给出的日程，编写一个程序，计算出为了确保在每个人进行观光的每一天都持有至少一张有效票券（包括组合票）所需的最少费用。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N \le 2000$。
*   字符串 $A, B$ 的长度均为 $N$，且所有字符均为 `0` 或 `1`。
*   $1 \le p_1, p_3, p_5, p_{pair} \le 10000$。

### 子任务

1.  (6 分) $p_1 = 1$，$p_3 = p_5 = p_{pair} = 10000$。
2.  (12 分) $p_{pair} = 1$，$p_1 = p_3 = p_5 = 10000$。
3.  (16 分) 对于所有 $i(1 \le i \le N)$，都有 $A_i = B_i = 1$。
4.  (24 分) 对于所有 $i(1 \le i \le N)$，都有 $B_i = 0$。
5.  (42 分) 无附加限制条件。

## 样例 #1

### 输入

```
9
011011101
110001110
3 7 12 15```

### 输出

```
29```

## 样例 #2

### 输入

```
9
011011101
110001110
1 10000 10000 10000```

### 输出

```
11```

# 题解

## 作者：Mindulle (赞：9)

此题考察的是动态规划（DP）问题。这种问题通常分为三步：状态定义，数组初始化以及状态转移。

### 状态定义
令 $dp_{i,j}$ 表示覆盖 Hankook 前 $i$ 天和 Jeong-ul 前 $j$ 天观光的最小费用。

### 数组初始化

如果 Jeong-ul 没有参观，即 $dp_{i,0}$，则此时其值应该为买一日票，三日票，五日票的最小值，不需要考虑组合票。

同理可以得到 Hankook 没有参观的初始化。

### 状态转移
为了表达方便，我们记一日票的价格为 $p_1$，三日票价格为 $p_3$，五日票价格为 $p_5$，组合票价格为 $p_{pair}$。

对于每一天 $(i,j)$，我们考虑以下购买方式：

- 购买一日票：
  - 如果 Hankook 第 $i$ 天观光，购买一日票，有：
    
  $$
  dp_{i,j}=\min(dp_{i,j},dp_{i-1,j}+p_1)
  $$
   - 如果 Jeong-ul 第 $j$ 天观光，购买一日票，有：
     
  $$
  dp_{i,j}=\min(dp_{i,j},dp_{i,j-1}+p_1)
  $$

同理，我们也可以推出购买三日票，五日票以及组合票的状态转移方程：

- 购买三日票：
  - 如果 Hankook 第 $i$ 天观光，购买三日票，有：

  $$
  dp_{i,j}=\min(dp_{i,j},dp_{\max(i-3,0),j}+p_3)
  $$
  - 如果 Jeong-ul 第 $j$ 天观光，购买三日票，有：
  
  $$
  dp_{i,j}=\min(dp_{i,j},dp_{i,\max(j-3,0)}+p_3)
  $$

这里要注意，因为是三日票，所以应该覆盖了 $3$ 天，$i$ 应当要减去 $3$。但若 $i\le2$，数组可能会产生越界，要记得与 $0$ 取最大值。$j$ 同理。

五日票和组合票的状态转移方程，请读者自行推导，与三日票的方程是相似的。

最后的结果就是 $dp_{n,n}$，即他们两人都观光了 $n$ 天所需费用的最小值。

### 参考代码

虽然状态转移比基础的动态规划稍长，但逻辑全部是相同的，很容易理解。

```cpp
//初始化
for(int i=1;i<=n;i++)
    dp[i][0]=min({dp[i-1][0]+p1*(ch1[i]=='1'),dp[max(0,i-3)][0]+p3,dp[max(0,i-5)][0]+p5});
for(int i=1;i<=n;i++)
    dp[0][i]=min({dp[0][i-1]+p1*(ch2[i]=='1'),dp[0][max(0,i-3)]+p3,dp[0][max(0,i-5)]+p5});
//状态转移
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
        dp[i][j]=dp[i-1][j]+(ch1[i]=='1')*p1,dp[i][j]=min(dp[i][j],dp[i][j-1]+(ch2[j]=='1')*p1);
        dp[i][j]=min(dp[max(0,i-3)][j]+p3,dp[i][j]),dp[i][j]=min(dp[i][max(0,j-3)]+p3,dp[i][j]);
        dp[i][j]=min(dp[max(0,i-5)][j]+p5,dp[i][j]),dp[i][j]=min(dp[i][max(0,j-5)]+p5,dp[i][j]);
        if(i==j) dp[i][j]=min(dp[max(0,i-4)][max(0,j-4)]+p_pair,dp[i][j]);
    }
}
```

---

## 作者：chen_zhe (赞：3)

### 子问题 1

在最优购买方案中，将只购买 1 日券。此时，需要购买的 1 日券数量等于 Han-guk 进行观光的天数与 Jeong-ol 进行观光的天数之和。这可以通过计算两个字符串中“1”的数量来实现。时间复杂度为 $O(N)$。

### 子问题 2

在最优购买方案中，将只购买组合券。因此，问题可以转化为用组合券覆盖所有满足 $A_i = 1$ 或 $B_i = 1$ 的日期 $i$（$1 \le i \le N$）。

这可以按 $i = 1 \dots N$ 的顺序遍历来解决：当 $A_i=1$ 或 $B_i=1$ 且“尚未购买覆盖日期 $i$ 的组合券”时，就在日期 $i$ 购买一张组合券。时间复杂度为 $O(N)$。

### 子问题 3

可以发现，存在一种最优购买方式，使得两人的车票配置完全相同。设购买的组合票数量为 $c_4$，Han-guk 购买的 5 日券数量为 $c_5$，3 日券数量为 $c_3$，1 日券数量为 $c_1$。我们需要在满足 $4c_4+5c_5+3c_3 + c_1 \ge N$ 的所有 $(c_4, c_5, c_3, c_1)$ 中，找到使成本 $c_4 P_{\text{pair}} + 2c_5 P_5 + 2c_3 P_3 + 2c_1 P_1$ 最小化的组合。

然而，可以观察到，一旦 $(c_4, c_5, c_3)$ 的值确定，则 $c_1 = N - 4c_4 - 5c_5 - 3c_3$。因此，可以通过遍历所有可能的 $(c_4, c_5, c_3)$ 组合，并从中找出成本最低的那个来解决问题。时间复杂度为 $O(N^3)$。作为参考，由于 $c_4 \le \lfloor N/4 \rfloor$，$c_5 \le \lfloor N/5 \rfloor$，$c_3 \le \lfloor N/3 \rfloor$，实际的遍历次数大约在 $N^3/60$ 的级别，常数系数较小，因此在实现上是足够高效的。

### 子问题 4

由于 Jeong-ol 不进行观光，问题可以简化为用 1 日券、3 日券、4 日券（组合券）、5 日券来覆盖一个人的观光日程，这可以通过简单的动态规划来解决。

我们定义 $D_i$ 为覆盖到日期 $i$ 为止的观光日程所需的最低购票费用。考虑到不为日期 $i$ 买票（仅当 $A_i=0$ 时）、用 1 日券覆盖、用 3 日券覆盖、用 5 日券覆盖、用组合券覆盖等情况，就可以依次求出 $D_i$ 的值。时间复杂度为 $O(N)$。

### 子问题 5

存在多种使用动态规划的解法。

我们定义 $D(i, r_a, r_b, r_p)$ 为：在日期 $i$ 时，Han-guk 的票券剩余天数为 $r_a$ 天，Jeong-ol 的票券剩余天数为 $r_b$ 天，组合券的剩余天数为 $r_p$ 天的情况下，处理日期 $i$ 及其之后日程的最低费用。对于每个 $i$，我们只需考虑 $r_a \le 5, r_b \le 5, r_p \le 4$ 的情况。对于日期 $i$，我们可以通过考虑以下情况来递归地填充 $D$ 表：

*   买组合券 / 不买组合券
*   Han-guk 不买票 / 买 1 日券 / 买 3 日券 / 买 5 日券
*   Jeong-ol 不买票 / 买 1 日券 / 买 3 日券 / 买 5 日券

时间复杂度为 $O(N)$，由于限制足够小，即使不优化所考虑情况的数量，也可以解决问题。此外，也可以用时间复杂度为 $O(N^2)$ 的动态规划解法来解决此问题。

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int INF = 1E9;
const int MAXN = 2001;

int ticket_price[6];
int pair_ticket_price;
int n;

bool a_schedule[MAXN+1];
bool b_schedule[MAXN+1];

int memo[MAXN+2][5 + 1][5 + 1][4 + 1];

// day 에 a 티켓 ra일, b 티켓 rb일, 2인권 rp일 (이상) 들고있을 때의 나머지 일정 처리 최소 비용
int dfs(int day, int ra, int rb, int rp)
{
    if (day == n + 1)
        return memo[day][ra][rb][rp] = 0;
    if (memo[day][ra][rb][rp] != -1)
        return memo[day][ra][rb][rp];

    int ans = INF;
    bool need_a = a_schedule[day];
    bool need_b = b_schedule[day];

    for (int add_pair : {0, 4})
    {
        int cost_pair = (add_pair ? pair_ticket_price : 0);
        for (int add_a : {0, 1, 3, 5})
        {
            int cost_a = ticket_price[add_a];
            for (int add_b : {0, 1, 3, 5})
            {
                int cost_b = ticket_price[add_b];

                int next_ra = max(ra, add_a); // 나중에 -1
                int next_rb = max(rb, add_b);
                int next_rp = max(rp, add_pair);

                bool a_covered = (next_ra >= 1 || next_rp >= 1);
                bool b_covered = (next_rb >= 1 || next_rp >= 1);

                if (need_a && !a_covered) // impossible
                    continue;
                if (need_b && !b_covered) // impossible
                    continue;

                int next_day = day + 1;
                next_ra = max(0, next_ra - 1);
                next_rb = max(0, next_rb - 1);
                next_rp = max(0, next_rp - 1);

                int cost = cost_pair + cost_a + cost_b + dfs(next_day, next_ra, next_rb, next_rp);
                ans = min(ans, cost);
            }
        }
    }
    return memo[day][ra][rb][rp] = ans;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    string a, b;
    cin >> a >> b;
    for (int i = 0; i < n; i++)
    {
        a_schedule[i + 1] = (a[i] == '1');
        b_schedule[i + 1] = (b[i] == '1');
    }
    cin >> ticket_price[1];
    cin >> ticket_price[3];
    cin >> ticket_price[5];
    cin >> pair_ticket_price;
    memset(memo, -1, sizeof(memo));

    int ans = dfs(0, 0, 0, 0);
    cout << ans << endl;
}
```

---

## 作者：tingting28 (赞：2)

### 动态规划
提供一种 $O(n^2)$ 的方法。

这里 $dp[i][j]$ 为完成 Hankook 计划的前 $i$ 天和 Jeong-ul 计划的前 $j$ 天所需要的钱。
分类讨论，考虑 10 种情况，取最大值：
1. 如果 $i = j = 0$，不需要花钱，$dp[0][0] = 0$；
2. 如果 $i \neq 0$，且 Hankook 第 $i$ 天观光，买一张 1 日票，$dp[i - 1][j] + a$；
3. 如果 $i \neq 0$，且 Hankook 第 $i$ 天不观光，$dp[i - 1][j]$；
4. 如果 $j \neq 0$，且 Jeong-ul 第 $j$ 天观光，买一张 1 日票，$dp[i][j - 1] + a$；
5. 如果 $j \neq 0$，且 Jeong-ul 第 $j$ 天不观光，$dp[i][j - 1]$；
6. 给 Hankook 买一张 3 日票，$dp[\max(0, i - 3)][j] + b$；
7. 给 Jeong-ul 买一张 3 日票，$dp[i][\max(0, j - 3)] + b$；
8. 给 Hankook 买一张 5 日票，$dp[\max(0, i - 5)][j] + c$；
9. 给 Jeong-ul 买一张 5 日票，$dp[i][\max(0, j - 5)] + c$；
10. 如果 $i = j$，给 Hankook 和 Jeong-ul 买一张组合票，$dp[\max(0, i - 4)][\max(0, j - 4)] + d$。

用 $\max(\dots, 0)$ 是因为票券的有效期可以超出了 $N$ 天的观光行程，$p_1 \le p_3 \le p_5$ 这一关系并非总是成立。

### 代码
::::info[代码]
```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	int n;
	cin >> n;
	string P, Q;
	cin >> P >> Q;
	vector<bool> p(n), q(n);
	for (int i = 0; i < n; ++i) {
		p[i] = (P[i] == '1');
		q[i] = (Q[i] == '1');
	}
	int a, b, c, d;
	cin >> a >> b >> c >> d;
	vector<vector<int>> dp(n + 1, vector<int>(n + 1, 100000000));
	for (int i = 0; i <= n; ++i) {
		for (int j = 0; j <= n; ++j) {
			vector<int> vec;
			if (!i && !j) {
				vec.push_back(0); // 情况1
			}
			if (i && p[i - 1]) {
				vec.push_back(dp[i - 1][j] + a); // 情况2
			}
			if (i && !p[i - 1]) {
				vec.push_back(dp[i - 1][j]); // 情况3
			}
			if (j && q[j - 1]) {
				vec.push_back(dp[i][j - 1] + a); // 情况4
			}
			if (j && !q[j - 1]) {
				vec.push_back(dp[i][j - 1]); // 情况5
			}
			vec.push_back(dp[max(0, i - 3)][j] + b); // 情况6
			vec.push_back(dp[i][max(0, j - 3)] + b); // 情况7
			vec.push_back(dp[max(0, i - 5)][j] + c); // 情况8
			vec.push_back(dp[i][max(0, j - 5)] + c); // 情况9
			if (i == j) {
				vec.push_back(dp[max(0, i - 4)][max(0, j - 4)] + d); // 情况10
			}
			dp[i][j] = *min_element(vec.begin(), vec.end());
		}
	}
	cout << dp[n][n] << endl;
	return 0;
}
```
::::

---

## 作者：lzx111218 (赞：0)

# P13513 [KOI 2025 #1] 釜山观光
[题目传送门](https://www.luogu.com.cn/problem/P13513)
## 思路

状压 DP 题。

题意票券的特性和覆盖规则概述：
- 1 日票：1 人使用，有效期 1 天（购买当天）。
- 3 日票：1 人使用，有效期 3 天（含购买当天）。
- 5 日票：1 人使用，有效期 5 天（含购买当天）。
- 组合票：2 人共享，有效期 4 天（含购买当天）。

从第 $i$ 天转移到第 $i+1$ 天，需确保第 $i+1$ 天的观光需求被覆盖，分两种情况：

### 1. 不购买新票
  - 若 Hankook 在第 $i+1$ 天观光，则 $j ≥ 1$。
  - 若 Jeong-ul 在第 $i+1$ 天观光，则 $k ≥ 1$。
- 转移方程式：$dp_{i+1,j,k} = \min(dp_{i+1,j,k}, dp_{i,j,k})$。

### 2. 购买新票
（1）为 Hankook 单独购票:
- 新有效期：$\max(j-1,$票券有效期$)$。
- 费用增加对应票券价格。

（2）为 Jeong-ul 单独购票:
- 新有效期：$\max(k-1,$票券有效期$)$。
- 费用增加对应票券价格。

（3）购买组合票:
- 有效期 4 天，同时覆盖两人。
- 新有效期：$\max(j-1, 4)$，$\max(k-1, 4)$。

（4）混合购票:
- 例如 Hankook 买 3 日票 + 为 Jeong-ul 买组合票，需同时更新两人的有效期。

时间复杂度为 $O(N)$，但实验发现 $O(N^2)$ 也能过。


### Code
```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
#define speed ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
int n,p1,p3,p5,pp,dp[11450][114][114];
string a,b;
bool f1[11450] = {false},f2[11450] = {false};
signed main(){
    speed
    cin >> n >> a >> b >> p1 >> p3 >> p5 >> pp;
    for(int i = 1; i <= n; i++){
        f1[i] = (a[i-1] == '1');
        f2[i] = (b[i-1] == '1');
    }
    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= 5; j++)
            for(int k = 0; k <= 5; k++)
                dp[i][j][k] = 1e9;
    dp[0][0][0] = 0;
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= 5; j++){
            for(int k = 0; k <= 5; k++){
                if(dp[i][j][k] == 1e9) continue;
                bool v = true;
                if(i > 0){
                    if(f1[i] && j == 0) v = false;
                    if(f2[i] && k == 0) v = false;
                }
                if(!v) continue;
                int temp = i + 1;
                if(temp > n) continue;
                int sum_j = max(0LL, j - 1);
                int sum_k = max(0LL, k - 1);
                if(sum_j >= (f1[temp] ? 1 : 0) && sum_k >= (f2[temp] ? 1 : 0)){
                    if(dp[temp][sum_j][sum_k] > dp[i][j][k]){
                        dp[temp][sum_j][sum_k] = dp[i][j][k];
                    }
                }
                for(int t = 0; t < 4; t++){
                    int d1 = 0, c1 = 0;
                    if(t == 1) d1 = 1, c1 = p1;
                    else if(t == 2) d1 = 3, c1 = p3;
                    else if(t == 3) d1 = 5, c1 = p5;
                    int sum_jj = max(sum_j, d1);
                    for(int x = 0; x < 5; x++){
                        int d2 = 0, c2 = 0;
                        if(x == 1) d2 = 1, c2 = p1;
                        else if(x == 2) d2 = 3, c2 = p3;
                        else if(x == 3) d2 = 5, c2 = p5;
                        else if(x == 4){
                            d2 = 4, c2 = pp;
                            sum_jj = max(sum_j, 4LL);
                        }
                        int sum_kk = max(sum_k, d2);
                        int num = dp[i][j][k] + c1 + c2;
                        if(sum_jj >= (f1[temp] ? 1 : 0) && sum_kk >= (f2[temp] ? 1 : 0)){
                            if(dp[temp][sum_jj][sum_kk] > num){
                                dp[temp][sum_jj][sum_kk] = num;
                            }
                        }
                    }
                }
            }
        }
    }
    int ans = 1e9;
    for(int i = 0; i <= 5; i++){
        for(int j = 0; j <= 5; j++){
            if(dp[n][i][j] < ans) ans = dp[n][i][j];
        }
    }
    cout << ans << "\n";
    return 0;
}

---

## 作者：lilong (赞：0)

考虑 dp。设 $f_{i,j}$ 表示第一个人的前 $i$ 天，第二个人的前 $j$ 天的最小花费，对于一日票（三日票，五日票同理）则有转移：

- 若第一个人第 $i$ 天要参观，则 $f_{i,j} \leftarrow \min(f_{i,j},f_{i-1,j}+p_1)$；否则，$f_{i,j} \leftarrow \min(f_{i,j},f_{i-1,j})$。
- 若第二个人第 $j$ 天要参观，则 $f_{i,j} \leftarrow \min(f_{i,j},f_{i,j-1}+p_1)$；否则，$f_{i,j} \leftarrow \min(f_{i,j},f_{i,j-1})$。

特别地，当 $i=j$ 时，可以使用组合票，有转移 $f_{i,j} \leftarrow \min({f_{i,j},f_{i-4,j-4}+p_{pair}})$。答案即为 $f_{n,n}$，时间复杂度 $O(n^2)$。

```cpp
#include<iostream>
#include<cstdio>
#define N 2010
#define inf 1e9
using namespace std;
int n,f[N][N],a,b,c,d;
string s,t;
bool ck(int l,int r,int op){
    l=max(l,1);
    r=min(r,n);
    for(int i=l;i<=r;i++){
        char ch=op?t[i]:s[i];
        if(ch=='1')return true;
    }
    return false;
}
int main(){
    cin>>n;
    cin>>s;s=" "+s;
    cin>>t;t=" "+t;
    cin>>a>>b>>c>>d;
    // n+=6;
    for(int i=0;i<=n;i++)
        for(int j=0;j<=n;j++)
            f[i][j]=inf;
    f[0][0]=0;
    for(int i=1;i<=n;i++){
        if(ck(i,i,0))f[i][0]=min(f[i][0],f[i-1][0]+a);
        else f[i][0]=min(f[i][0],f[i-1][0]);
        if(ck(i-2,i,0))f[i][0]=min(f[i][0],f[max(i-3,0)][0]+b);
        else f[i][0]=min(f[i][0],f[max(i-3,0)][0]);
        if(ck(i-4,i,0))f[i][0]=min(f[i][0],f[max(i-5,0)][0]+c);
        else f[i][0]=min(f[i][0],f[max(i-5,0)][0]);
        if(ck(i-3,i,0))f[i][0]=min(f[i][0],f[max(i-4,0)][0]+d);
        else f[i][0]=min(f[i][0],f[max(i-4,0)][0]);
    }
    for(int i=1;i<=n;i++){
        if(ck(i,i,1))f[0][i]=min(f[0][i],f[0][i-1]+a);
        else f[0][i]=min(f[0][i],f[0][i-1]);
        if(ck(i-2,i,1))f[0][i]=min(f[0][i],f[0][max(i-3,0)]+b);
        else f[0][i]=min(f[0][i],f[0][max(i-3,0)]);
        if(ck(i-4,i,1))f[0][i]=min(f[0][i],f[0][max(i-5,0)]+c);
        else f[0][i]=min(f[0][i],f[0][max(i-5,0)]);
        if(ck(i-3,i,1))f[0][i]=min(f[0][i],f[0][max(i-4,0)]+d);
        else f[0][i]=min(f[0][i],f[0][max(i-4,0)]);
    }
    // cout<<f[0][1]<<endl;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            // if(i==0&&j==0)continue;
            f[i][j]=inf;
            //1
            if(ck(i,i,0))f[i][j]=min(f[i][j],f[i-1][j]+a);
            else f[i][j]=min(f[i][j],f[i-1][j]);
            if(ck(j,j,1))f[i][j]=min(f[i][j],f[i][j-1]+a);
            else f[i][j]=min(f[i][j],f[i][j-1]);
            //3
            if(ck(i-2,i,0))f[i][j]=min(f[i][j],f[max(i-3,0)][j]+b);
            else f[i][j]=min(f[i][j],f[max(i-3,0)][j]);
            if(ck(j-2,j,1))f[i][j]=min(f[i][j],f[i][max(j-3,0)]+b);
            else f[i][j]=min(f[i][j],f[i][max(j-3,0)]);
            //5
            if(ck(i-4,i,0))f[i][j]=min(f[i][j],f[max(i-5,0)][j]+c);
            else f[i][j]=min(f[i][j],f[max(i-5,0)][j]);
            if(ck(j-4,j,1))f[i][j]=min(f[i][j],f[i][max(j-5,0)]+c);
            else f[i][j]=min(f[i][j],f[i][max(j-5,0)]);
            //4
            if(i==j){
                if(ck(i-3,i,0)||ck(j-3,j,1))f[i][j]=min(f[i][j],f[max(i-4,0)][max(j-4,0)]+d);
                else f[i][j]=min(f[i][j],f[max(i-4,0)][max(j-4,0)]);
                // cout<<i<<' '<<j<<' '<<f[i][j]<<endl;
            }
            // cout<<i<<' '<<j<<' '<<f[i][j]<<endl;
        }   
    }
    cout<<f[n][n];
    return 0;
}
```

---

## 作者：ran_qwq (赞：0)

数据范围较小，允许平方的 dp。设 $f_{i,j}$ 为第一个人完成了前 $i$ 天，第二个人完成了前 $j$ 天的最小花费。考虑下一天的买票情况：

- 如果 $a_{i+1}=0$，第一个人不需要买 $i+1$ 天的票，$f_{i+1,j}\leftarrow f_{i,j}$。
- 如果 $a_{j+1}=0$，第二个人不需要买 $j+1$ 天的票，$f_{i,j+1}\leftarrow f_{i,j}$。
- 第一个人可以买 $d\in\{1,3,5\}$ 天的票，$f_{i+d,j}\leftarrow f_{i,j}+p_d$。
- 第二个人可以买 $d\in\{1,3,5\}$ 天的票，$f_{i,j+d}\leftarrow f_{i,j}+p_d$。
- 可以买双人票，$f_{\max(i,\min(i,j)+4),\max(j,\min(i,j)+4)}\leftarrow f_{i,j}+p_{pair}$。

[这是代码。](https://www.luogu.com.cn/paste/yrkj0lro)

---


# 没有上司的舞会

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。

## 样例 #1

### 输入

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 输出

```
5
```

# 题解

## 作者：BlueArc (赞：450)

## 题目描述
某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入输出格式
###### 输入格式：
第一行一个整数N。(1<=N<=6000)

接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128<=Ri<=127)

接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。

最后一行输入0 0

###### 输出格式：
输出最大的快乐指数。

## Solution:
经典的树形dp

设

  f[x][0]表示以x为根的子树,且x不参加舞会的最大快乐值
  
  f[x][1]表示以x为根的子树，且x参加了舞会的最大快乐值
  
  则f[x][0]=sigma{max(f[y][0],f[y][1])} (y是x的儿子)
  
  f[x][1]=sigma{f[y][0]}+h[x] (y是x的儿子)
  
  先找到唯一的树根root
  
  则ans=max(f[root][0],f[root][1])

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 6005
int h[MAXN];
int v[MAXN];
vector<int> son[MAXN];
int f[MAXN][2];
void dp(int x)
{
 f[x][0]=0;
 f[x][1]=h[x];
 for(int i=0;i<son[x].size();i++)
 {
  int y=son[x][i];
  dp(y);
  f[x][0]+=max(f[y][0],f[y][1]);
  f[x][1]+=f[y][0];
 }
}
int main()
{
 int n;
 cin>>n;
 for(int i=1;i<=n;i++) cin>>h[i];
 for(int i=1;i<=n-1;i++)
 {
  int x,y;
  cin>>x>>y;
  son[y].push_back(x);
  v[x]=1;
 }
 int root;
 for(int i=1;i<=n;i++)
 if(!v[i]) {root=i;break;}
 dp(root);
 cout<<max(f[root][0],f[root][1])<<endl;
 return 0;
}

```

---

## 作者：moye到碗里来 (赞：220)

这道题作为一道十分经典的树形dp，它显然是像我们这样的新手拿来学习和试手的一道好题。

首先我们们分析一下这道题，对于每一个人，它所做的决定对上司和下属都有影响，我们可以只看一方，也就是上司对下属的影响，因为这样的影响是相互的。

状态如果为f[i]表示第i个人的位置能获得最大的幸福行吗？

由于我们的选择具有后效性，因为你去或不去对下属有影响，那显然不行。遇到这种情况我们该怎么办？

#加一维

由于后效性实质上是我们对于状态的性质不够清楚，所以我们再加一维以实现就算你加还是不加我们都可以记录下来。所以状态其实是很好想的。想出状态后，容易推出方程为

dp[i][0]=sum(max(dp[son][1],dp[son][0]));

显然，你不去，那下属就可以想去就去。

dp[i][1]=sum(dp[son][0])+happy[i];

显然你去了那下属就一定不能去。

由此我们就可以愉快的DFS了。

#但是

如果我们的人数相当多且是一条链的时候就容易造成爆栈，那这我们有如何解决呢?方法有三

1.  开一个数组手动实现栈。

2. bfs后用for循环

3. 拓扑排序

第一个想必大家都会写，而且其与dfs相似，所以不再赘述。

那为啥会讲后两种呢？

因为有时候dfs并不好写，所以我们会把它转化为bfs+for或者拓扑，大家可以看一下，dfs和这两种写法的推导有的是不一样的。特别是和这题的拓扑写法，可以仔细看一下。

那么首先说下bfs

我们很容易发现树形dp它为什么一般会是dfs形式？因为树形dp的状态大多是一颗颗子树，它传递状态过程一般都是先求出最下层再往上更新。所以对于每一个点，我们在求解它的值的过程中，需要求出它每一个子节点的解。那有什么方法我们可以用数组和for循环实现这样的求解呢？没错，就是bfs过程中的**队列**。由于队列中的点都是先入的父亲节点后入的子节点，所以我们求解的时候只要把循环顺序反过来就可以了。以下代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t=0,que[6005],happy[6005],fa[6005];
vector<int>son[6007];
queue<int> q;
bool vis[6005];
int dp[6005][2];
void bfs(int s)
{
    q.push(s);
    vis[s]=1;
    que[++t]=s;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        int x=son[u].size();
        for(int i=0;i<x;i++)
        {
            if(!vis[son[u][i]])
            {
                vis[son[u][i]]=1;
                q.push(son[u][i]);
                que[++t]=son[u][i];
            }
        }
    }
    return ;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        fa[i]=i;
        scanf("%d",&happy[i]);
    }
        int a,b;
    while(scanf("%d %d",&a,&b))
    {
        if(a==0&&b==0)
        break;
        fa[a]=b;
        son[b].push_back(a);
    }
    int s=n;
    while(s!=fa[s])
    s=fa[s];
    bfs(s);
    for(int i=t;i>0;i--)
    {
        int u=que[i];
        int x=son[u].size();
        for(int j=0;j<x;j++)
        {
            int v=son[u][j];
            dp[u][0]+=max(dp[v][0],dp[v][1]);
            dp[u][1]=max(dp[u][1],dp[u][1]+dp[v][0]);
        }
        dp[u][1]+=happy[u];
    }
    printf("%d",max(dp[s][0],dp[s][1]));
    return 0;
}
```
接下来我们谈谈拓扑排序做法。

先来回顾一下，拓扑排序的时候我们其实是从根到子节点，那么如何实现从子节点返回根节点的求解过程呢？**反向连边存入度**。没错，反向，就可以轻易实现这样的求解。可以自己手动模拟一下。然后对于这样的求解，我们可以在边求拓扑排序边更新答案。

至于为啥其实很好想的，可以自己推推（其实我懒了）

```cpp
#include<bits/stdc++.h>
using namespace std;
int happy[6005];
int ru[6005];
int fa[6005];
int dp[6005][2]; 
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1;i <= n;i++)
    {
        scanf("%d",&happy[i]); 
    } 
    int a,b;
    while(scanf("%d %d",&a,&b))
    {
        if(a == 0&&b == 0)
        break;
        ru[b]++;
        fa[a] = b;
    } 
    queue<int>q;
    for(int i = 1;i <= n;i++)
    {
        if(ru[i] == 0)
        q.push(i);
    }
    int maxn = 0; 
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        dp[u][1] += happy[u];
        maxn = max(dp[u][1],maxn);
        maxn = max(dp[u][0],maxn);
        ru[fa[u]] --;
        if(ru[fa[u]] == 0)
        q.push(fa[u]); 
        dp[fa[u]][0] = max(dp[fa[u]][0] + dp[u][0],dp[fa[u]][0] + dp[u][1]);
        dp[fa[u]][1] += dp[u][0] >= 0 ? dp[u][0] : 0;
        
    }
    printf("%d",maxn);
}
```
希望这篇题解能对大家有点帮助

还有这是我的博客来看看也好，就是luogu的。

希望顶顶，我也会写一些其他树形dp的题解，谢谢大家啦

#[博客](https://www.luogu.org/blog/mak2333/)


---

## 作者：我没有小白 (赞：153)

初学树形$dp$的可以来这里的博客观摩一下
[树形dpdp学习笔记](https://www.cnblogs.com/ifmyt/p/9588872.html)

>今天学习了树形$dp$，一开始浏览各大$blog$，发现都$TM$是题，连个入门的$blog$都没有，体验极差。所以我立志要写一篇可以让初学树形$dp$的童鞋快速入门。

# 树形$dp$

## 概念类

树形$dp$是一种很优美的动态规划，真的很优美真的，前提是在你学会它之后。

## 实现形式

树形$dp$的主要实现形式是$dfs$，在$dfs$中$dp$，主要的实现形式是$dp[i][j][0/1]$，$i$是以$i$为根的子树，$j$是表示在以$i$为根的子树中选择$j$个子节点，$0$表示这个节点不选，$1$表示选择这个节点。有的时候$j$或$0/1$这一维可以压掉

## 基本的$dp$方程

### 选择节点类
$$\begin{cases}dp[i][0]=dp[j][1]\\dp[i][1]=\max/\min(dp[j][0],dp[j][1])\\\end{cases}$$

### 树形背包类
$$\begin{cases}dp[v][k]=dp[u][k]+val\\dp[u][k]=max(dp[u][k],dp[v][k-1])\\\end{cases}$$
## 例题类

以上就是对树形$dp$的基本介绍，因为树形$dp$没有基本的形式，然后其也没有固定的做法，一般一种题目有一种做法。

### [没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)

这道题是一树形$dp$入门级别的题目，具体方程就用到了上述的选择方程。
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 6001
using namespace std;
int ind[N],n,hap[N],dp[N][2],fa[N],root,vis[N],ne[N],po[N];
void work(int x)
{
    for(int i = po[x]; i; i = ne[i])
    {
        work(i);
        dp[x][1]=max(max(dp[x][1],dp[x][1]+dp[i][0]),dp[i][0]);
        dp[x][0]=max(max(dp[x][0],dp[i][1]+dp[x][0]),max(dp[i][1],dp [i][0]));
    }
}
int main()
{
    cin >> n;
    for(int i=1; i<=n; i++)
        cin >> dp[i][1];
    for(int i=1; i<=n; i++)
    {
        int a,b;
        cin >> b >> a;
        ind[b]++;
        ne[b] = po[a];
        po[a] = b;
    }
    for(int i=1; i<=n; i++)
        if(!ind[i])
        {
            root=i;
            break;
        }
    work(root);
    cout << max(dp[root][0],dp[root][1]);
}
```
### [最大子树和](https://www.luogu.org/problemnew/show/P1122)

这道题的$dp$方程有变，因为你的操作是切掉这个点，所以你的子树要么加上价值，要么价值为$0$，所以$dp$方程是
$$dp[u]+=max(dp[v],0)$$
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>

using namespace std;
struct edge
{
    int next,to;
} e[40000];
int head[40000],tot,rt,maxn;
void add(int x,int y)
{
    e[++tot].next=head[x];
    head[x]=tot;
    e[tot].to=y;
}
int n,dp[20000],ind[20000];
int val[20000],f[20000];
void dfs_f__k(int x,int fa)
{
    f[x]=fa;
    for(int i=head[x]; i; i=e[i].next)
    {
        int v=e[i].to;
        if(v!=fa)
            dfs_f__k(v,x);
    }
}
void dfs(int x)
{
    dp[x]=val[x];
    for(int i=head[x]; i; i=e[i].next)
    {
        int v=e[i].to;
        if(v!=f[x])
        {
            dfs(v);
            dp[x]+=max(0,dp[v]);
        }
    }
    maxn=max(maxn,dp[x]);
}
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)scanf("%d",&val[i]);
    for(int i=1; i<=n-1; i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);
    }
    rt=1;
    dfs_f__k(rt,0);
    dfs(rt);
    printf("%d",maxn);
}
```
### [选课](https://www.luogu.org/problemnew/show/P2014)
这道题的意思是每本书要想选择一门课，必须要先学会它的必修课，所以这就形成了一种依赖行为，即选择一门课必须要选择必修课。那么他又说要选择的价值最大，这就要用到树形背包的知识了。
树形背包的基本代码形式（即上面的树形背包类）
```cpp
/*
设dp[i][j]表示选择以i为根的子树中j个节点。
u代表当前根节点，tot代表其选择的节点的总额。
*/
void dfs(int u,int tot)
{
	for(int i=head[x];i;i=e[i].next)
	{
		int v=e[i].to;
		for(int k=0;k<tot;k++)//这里k从o开始到tot-1，因为v的子树可以选择的节点是u的子树的节点数减一
			dp[v][k]=dp[u][k]+val[u];
		dfs(v,tot-1)
		for(int k=1;k<=tot;k++)
			dp[u][k]=max(dp[u][k],dp[v][k-1]);//这里是把子树的值赋给了根节点，因为u选择k个点v只能选择k-1个点。
	}
}
```
然后这就是树形背包的基本形式，基本就是这样做
代码
```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;

int n,m;
struct edge
{
    int next,to;
}e[1000];
int rt,head[1000],tot,val[1000],dp[1000][1000];
void add(int x,int y)
{
    e[++tot].next=head[x];
    head[x]=tot;
    e[tot].to=y;
}
void dfs(int u,int t)
{
    if (t<=0) return ;
    for (int i=head[u]; i; i=e[i].next)
    {
        int v = e[i].to;
        for (int k=0; k<t; ++k) 
            dp[v][k] = dp[u][k]+val[v];
        dfs(v,t-1);
        for (int k=1; k<=t; ++k) 
            dp[u][k] = max(dp[u][k],dp[v][k-1]);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d%d",&a,&val[i]);
        if(a)
          add(a,i);
        if(!a)add(0,i);
    }
    dfs(0,m);
    printf("%d",dp[0][m]);
}
```
### [Strategic game](https://www.luogu.org/problemnew/show/UVA1292)

这道题的意思是选择最少的点来覆盖一棵树，可以用最小点覆盖（也就是二分图最大匹配）或者树形$dp$来做，因为这里我们的专题是树形$dp$，所以我们现在就讲树形$dp$的做法。
我们做这道题的方法是用选择方程来做，因为你要做最小点覆盖，要么选这个点要么不选对吧。
于是$dp$的转移方程就是上述一方程
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int n;
struct edge
{
    int next,to;
} e[4000];
int head[4000],tot,dp[4000][2],ind[4000];
void add(int x,int y)
{
    e[++tot].next=head[x];
    head[x]=tot;
    e[tot].to=y;
}
void dfs(int x)
{
    dp[x][1]=1;
    for(int i=head[x]; i; i=e[i].next)
    {
        int v=e[i].to;
        dfs(v);
        dp[x][0]+=dp[v][1];
        dp[x][1]+=min(dp[v][0],dp[v][1]);
    }
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        memset(dp,0,sizeof(dp));
        memset(head,0,sizeof(head));
        memset(ind,0,sizeof(ind));
        tot=0;
        for(int j=1; j<=n; j++)
        {
            int a,b;
            scanf("%d:(%d)",&a,&b);
            for(int i=1; i<=b; i++)
            {
                int c;
                scanf("%d",&c);
                ind[c]++;
                add(a,c);
            }
        }
        int rt;
        for(int i=0; i<=n; i++)
            if(!ind[i])
            {
                rt=i;
                break;
            }
        dfs(rt);
        printf("%d\n",min(dp[rt][1],dp[rt][0]));
    }
}
```

---

## 作者：你是总总 (赞：66)

树形DP

我的f[0][i]表示i不取时开心值最大是多少

f[1][i]则表示i取时开心值最大是多少

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int f[5][6000];
int n,a,b,root;
int ne[12000],po[12000],ru[12000];
void dp(int x)
{
    for(int i = po[x];i;i = ne[i])
    {
        dp(i);
        f[1][x] = max(max(f[1][x],f[0][i]+f[1][x]),f[0][i]);//这一个点选的时候转移：可以不选子节点，可以是子节点不选时最大值+自己的值，可以是只是子节点不选时的最大值
        f[0][x] = max(max(f[0][x],f[1][i]+f[0][x]),max(f[1][i],f[0][i]));//这一个点不选的时候转移：可以是自己，可以是子节点也不选，可以是子节点选时+自己，可以是仅仅子节点选时最大
    }
}
int main(){
    scanf("%d",&n);
    for(int i = 1;i <= n;i ++)
     scanf("%d",&f[1][i]);
    for(int i = 1;i <= n;i ++) 
     {
         scanf("%d%d",&b,&a);
         ru[b] ++;
         ne[b] = po[a]; //原理与邻接表类似  只是里面存储的都是点  可手动模拟一下
         po[a] = b;
     }
    for(int i = 1;i <= n;i ++)
     if(ru[i] == 0) 
       {
            root = i;//找树的根
            break;
       } 
    dp(root);   
    printf("%d",max(f[1][root],f[0][root]));
    return 0;
}

```

---

## 作者：Yeji_ (赞：42)

额！！！

我在学习了半个小时的链式前向星以及树形dp（~~可见我有多菜啊~~）

学习的我一头雾水，但是终于把它做出来了！

我们先来说一下链式前向星存图，和邻接矩阵吧。

老师说，邻接矩阵是最好理解的了，（~~但垃圾啊~~）所以让我不要用，
vector也可以，但是我好像不是很理解链表这一种数据结构，所以我也不会用
### 邻接矩阵：
其实就像他的字面义一样，就是一个二维数组的矩阵，用来存储两个点之间的所属关系，如果这两个点之间有联系，那么便在它们的二维矩阵的交点处附上1。所以说还是比较好理解了的

但是呢，假如有五个点，那么就开一个5*5的二维矩阵，浪费的空间很多，所以我们又有了一个数据结构：链式前向星存图。

### 链式前向星：
若果有五个点，假设把他们想做是一个个的小房间，每个房间中藏有其他房间的钥匙，每个房间可以通往其他人的房间。现在我来讲一讲他的具体步骤吧：

有一个东西叫做st的里面存储的是第i条路的路径数。
所以呢，我们可以定一个结构体，具体代码如下：

    struct Edge

    {

            int nxt,to,val;

    }e[6001];//这一步是定义一个结构体。


    void add(int a,int b,int value)

    {

            e[++tot].to = b;//拓展一个新的边

            e[tot].val = value;//这是这条边的权值

            e[tot].last = st[a];

            st[a] = tot;
    }
    //这是每一步都要做的事哦！

    顺便附上遍历的代码：

    for(int st[i];i != -1;i = e[i].last)
    {

    }

    //这样我们就可以遍历全部的点了！！！：）


### 讲完了链式前向星存图，那么讲一下这题的思路了吧。

首先定义一个f数组，为f[i][1]和f[i][2].
f[i][1]里面存的是，假如现在的这个人不去，那么他的下属就可以去，
可以得到动态转移方程f[i][1]
=sum(max(f[j][2],f[j][1]));

如果这个人要去，那么就存于f[i][2]了，可得：
f[i][2]
=sum(f[j][1]) + a[i];


这题就可以很轻易的得出了
最后附上代码：


    #include<cstdio>
    #include<iostream>
    #include<cstring>
    #include<cmath>
    using namespace std;
    int n,t,d[6001],h[6001],cnt,head[6001],f[6001][2];
    struct Edge
    {
        int nxt,to,val;
    }edge[6001];
    void ins(int a,int b)
    {
        edge[++cnt].nxt=head[a];
        edge[cnt].to=b;
        head[a]=cnt;
    }
    void dfs(int x)
    {
        for(int i=head[x];i;i=edge[i].nxt)
        {
            int j=edge[i].to;
            dfs(j);
            f[x][0]+=max(f[j][1],f[j][0]);
            f[x][1]+=f[j][0];
        }
        f[x][1]+=h[x];
    }
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>h[i];
        for(int i=1;i<=n;i++)
        {
            int x,y;
            cin>>x>>y;
            d[x]++;
            if(x!=0&&y!=0)
                ins(y,x);
        }
        for(int i=1;i<=n;i++)
            if (d[i]==0) 
                t=i;
        dfs(t);
        printf("%d",max(f[t][0],f[t][1]));
    }
   
  # 这篇博客就这样结束了呀！！！

---

## 作者：Dog_Two (赞：25)

单纯的记忆化+dfs

~~发题解的神犇们都太坏了QAQ，各种循环DP~~

好吧，是我太菜\_(:зゝ∠)\_

循环dp不会用，题解里面的各种递归循环的搜索又看不懂，所以只好写一个纯记忆化dfs来解题了。

做完P4017后趁热打铁就做了这道题，所以沿用了一个no\_head数组记录**不是校长的人**。~~好像可以根据后面的从属关系推校长来着？~~


思路：

### 预处理

- 存储每个人的下属（建树，绑定儿子节点）

- 记录着个人，他不是校长（根节点）

### 搜索

- 用dp[i][flase/true]记录第i号人不参加或参加可以取得的最大贡献

- 递归终点是他没有下属（叶子节点），返回——他参加，则快乐值；不参加，则0

- 当这个人确定参加时，他的下属必然不参加；这个人不参加时，最佳贡献应是他的下属参加或不参加的最大值

- 答案校长参加或不参加的最大贡献

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6e3+10;
int n;
int dp[maxn][2];
//记录状态 
int hap[maxn];
//快乐值 
bool no_head[maxn];
//记录是否是校长 true->不是 
vector<int>down[maxn];
//记录每个人的下属 
int dfs(int now,bool if_get){
    if(dp[now][if_get]) return dp[now][if_get];
    //递归终点 
    if(!down[now].size()) return hap[now]*if_get;
    //只有参加，才能贡献快乐值 
    int res=0;
    if(if_get){
        for(int i=0;i<down[now].size();i++){
            int &nxt=down[now][i];
            res+=dfs(nxt,false);
        }
    }
    else{
        for(int i=0;i<down[now].size();i++){
            int &nxt=down[now][i];
            res+=max(dfs(nxt,true),dfs(nxt,false));
            //下属参加或不参加的最大值才是最佳贡献 
        }
    }
    return dp[now][if_get]=if_get?res+hap[now]:res;
    //如果这个人参加，不要忘了返回他自身的快乐值 
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&hap[i]);
    int a,b;
    while(scanf("%d%d",&a,&b)&&a&&b){
        down[b].push_back(a);
        no_head[a]=true;
    }
    for(int i=1;i<=n;i++) if(!no_head[i])
    cout<<max(dfs(i,false),dfs(i,true));
    return 0;
}
```

---

## 作者：DQYdqy (赞：13)

这是一道非常裸的树形DP，对于初学树形DP的OIer来说，是一道十分良心的题

我们对于每一个点$i$，用$f[i][0]$来表示不取$i$时的最大值，$f[i][1]$表示取$i$时的最大值

对于每一个点$i$，则有状态转移方程：$$f[i][1]=h[i]+\sum f[j][0]$$
$$f[i][0]=\sum Max(f[j][1],f[j][0])$$
其中$j$是$i$的子节点，值得注意的是，当$i$不取的时候，对于$i$的子节点$j$，我们也不一定要取，具体见代码


## **Code**:

```cpp
#include<bits/stdc++.h>
#define N 6001
using namespace std;
int n,rt,rd[N],h[N],cnt,head[N],f[N][2];
struct Edge{
	int nxt,to;
}edge[N];//邻接链表
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
    //快读
}
inline void ins(int a,int b){
	edge[++cnt].nxt=head[a];
	edge[cnt].to=b;
	head[a]=cnt;
}
inline void dfs(int x){
	for(int i=head[x];i;i=edge[i].nxt){
		int j=edge[i].to;
		dfs(j);
		f[x][0]+=max(f[j][1],f[j][0]);
		f[x][1]+=f[j][0];
        //状态转移
	}
	f[x][1]+=h[x];
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)h[i]=read();
	for(int i=1;i<=n;i++){
		int x=read(),y=read();rd[x]++;
		if(x!=0&&y!=0)ins(y,x);//邻接链表存图
	}
	for(int i=1;i<=n;i++)if(rd[i]==0)rt=i;
	dfs(rt);
	printf("%d",max(f[rt][0],f[rt][1]));
	return 0;
}
```


---

## 作者：Panthera_AFO (赞：9)

	奇妙的二维数组（模拟vector）建树，谁用谁知道
   	【核心操作】father[x][0]++;//0列存有几个子节点 
			      father[x][father[x][0]]=y;//根据有几个子节点存子节点编号 
     【AC代码付】
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int const maxn=10011;
int f[maxn][5],fa[maxn],num[maxn],son[maxn][maxn];
bool kid[maxn];
int n,v,x,y;

void dfs(int u){
	if(!son[u][0]){
		f[u][1]=num[u];
		f[u][0]=0;
		return;
	}
	else{
		for(int i=1;i<=son[u][0];i++){
			dfs(son[u][i]);
			f[u][0]+=max(f[son[u][i]][0],f[son[u][i]][1]);
			f[u][1]+=f[son[u][i]][0];
		}
		f[u][1]+=num[u];
	}
}

int main(){
	cin>>n;
	 for(int i=1;i<=n;i++){
        cin>>v;
    	num[i]=v;
	}
	for(int i=1;i<n;i++){
		cin>>x>>y;
		son[y][0]++;
		fa[x]++;
		son[y][son[y][0]]=x;
	}
	cin>>x>>y;
	int root;
	for(int i=1;i<=n;i++)
		if(!fa[i]){
			root=i;
			break;
		}
	dfs(root);
	cout<<max(f[root][0],f[root][1]);
	return 0;
}
```

---

## 作者：shenbear (赞：6)

受台风影响，我这道题昨晚写好发现出锅，今天下午才改出来

首先，我们发现这里有一个树形结构，就想到用树形dp

由于一个人去与不去会影响到下一位，所以我们多开一维

f[u][0]表示u去的最大快乐，f[u][1]表示u不去的最大快乐

初始化：所有人自己去，只要快乐>0，f[u][0]就+a[u]

转移，很明显，如果自己去，那么你只能加你儿子不去的快乐值；如果你不去你可以加你儿子去的快乐值

```
	if(f[v][0]>0) f[u][1]+=f[v][0];
	if(f[v][1]>0) f[u][0]+=f[v][1];
```

最后写一个dfs，进行树形dp即可

------------
代码：

填表
```
#include <bits/stdc++.h>
using namespace std;
int n,a[6666],rd[6666],g,f[6666][2],ans,fa[6666],son[6666];
struct tree
{
	int next,to;
}p[22222];
int head[6666],num;
void ad(int x,int y) //前向星存图 
{
	p[++num].next=head[x];
	p[num].to=y;
	head[x]=num;
}
void dfs(int u) 、、树形dp 
{
	int f0=0,f1=0;
//	if(a[u]>0) f0+=a[u];
	for(int i=head[u];i;i=p[i].next)
	{
		int v=p[i].to;
		fa[v]=u;
		dfs(v);
		if(f[v][0]>0) f[u][1]+=f[v][0];
		if(f[v][1]>0) f[u][0]+=f[v][1];
	}
	int gf=fa[fa[u]];
//	if(f[u][0]>0) f[fa[u]][1]+=f[u][0];
//	if(f[u][1]>0) f[fa[u]][0]+=f[u][1];
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",a+i);
		if(a[i]>0) f[i][0]=a[i];
	}
	for(int i=1;i<n;i++)
	{
		int k,l;
		scanf("%d%d",&k,&l);
		ad(l,k);	
		rd[k]++;
	}
	for(int i=1;i<=n;i++) #找根 
	{
		if(!rd[i]) 
		{
			g=i;
			break;
		}
	}
//	printf("%d\n",g);
	dfs(g);
//	printf("%d %d\n",f[g][0],f[g][1]);
	cout<<max(f[g][0],f[g][1]);
	return 0;
}
```
刷表
```
#include <bits/stdc++.h>
using namespace std;
int n,a[6666],rd[6666],g,f[6666][2],ans,fa[6666],son[6666];
struct tree
{
	int next,to;
}p[22222];
int head[6666],num;
void ad(int x,int y) //前向星存图 
{
	p[++num].next=head[x];
	p[num].to=y;
	head[x]=num;
}
void dfs(int u) 、、树形dp 
{
	int f0=0,f1=0;
//	if(a[u]>0) f0+=a[u];
	for(int i=head[u];i;i=p[i].next)
	{
		int v=p[i].to;
		fa[v]=u;
		dfs(v);
//		if(f[v][0]>0) f[u][1]+=f[v][0];
//		if(f[v][1]>0) f[u][0]+=f[v][1];
	}
	int gf=fa[fa[u]];
	if(f[u][0]>0) f[fa[u]][1]+=f[u][0];
	if(f[u][1]>0) f[fa[u]][0]+=f[u][1];
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",a+i);
		if(a[i]>0) f[i][0]=a[i];
	}
	for(int i=1;i<n;i++)
	{
		int k,l;
		scanf("%d%d",&k,&l);
		ad(l,k);	
		rd[k]++;
	}
	for(int i=1;i<=n;i++) #找根 
	{
		if(!rd[i]) 
		{
			g=i;
			break;
		}
	}
//	printf("%d\n",g);
	dfs(g);
//	printf("%d %d\n",f[g][0],f[g][1]);
	cout<<max(f[g][0],f[g][1]);
	return 0;
}
```


------------
祝大家你怕2019 rp++

---

## 作者：Ivystorm (赞：5)

题解里的人都建图了啊，但是这题明明可以不用这么麻烦的……

本题稍加思索即可得出为树形dp。

每个人只有两种状态，则设$dp[0][i]$为第$i$个人不来，他的下属所能获得的最大快乐值；$dp[1][i]$为第$i$个人来，他的下属所能获得的最大快乐值。

所以容易推出状态转移方程：

$dp[0][i]=\sum\limits_{u=sons}max(dp[1][u],dp[0][u])$当前节点不选，那么子节点随意

$dp[1][i]=\sum\limits_{u=sons}dp[0][u]+happy[i]$当前节点选，子节点不能选

分析可得，每个人的状态要在下属的状态更新完了才能更新，所以用类似拓扑的方法，只记录每个子节点的父亲，最后从所有入度为$0$的点开始跑就行了。在更新每个子节点时顺便让父节点加上自己的权值，最后访问父节点时权值已经更新好了，就可以省去建图的麻烦。

C++代码见下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int dp[2][6010];//dp解释见上
int f[2][6010];//f[0]为父亲，f[1]为高兴值
int ind[6010];//入度
int vis[6010];//访问标记
int root;//树的根
void dfs(int u){//递归从后往前更新
    if(!u) return;
    vis[u]=1;//已访问
    root=u;//最后一个访问到的一定是根，所以一直更新根就行了
    dp[0][f[0][u]]+=max(dp[1][u]+f[1][u],dp[0][u]);//给父亲更新
    dp[1][f[0][u]]+=dp[0][u];
    ind[f[0][u]]--;//更新完一个子节点
    if(!ind[f[0][u]]) dfs(f[0][u]);//在所有子节点更新后再更新（入度为0）
}
int main(){
    int n=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&f[1][i]);
    int a,b;
    for(int i=1;i<n;i++){
        scanf("%d%d",&a,&b);
        f[0][a]=b;//保存节点信息
        ind[b]++;
    }
    for(int i=1;i<=n;i++)
        if(!vis[i]&&!ind[i])//没有被访问过，没有入度，说明是叶子节点
            dfs(i);
    printf("%d\n",max(dp[0][root],dp[1][root]+f[1][root]));//取根节点两种方案的最大值
    return 0;
}
```

---

## 作者：littlegagaduck (赞：3)

这道题是很好的一道树形dp的练习题，也是蒟蒻第一道完全自己做出的树形dp题。

题目中要求：每个节点的父节点倘若不加入最后的结果，那么这个点便可以加入最后的结果，每个点有一个权值，我们希望权值的和最大。

我的做法是考虑每一个父节点，从根节点开始搜索，回溯的过程中由子节点向父节点转移。

具体来说，对于每一个节点，如果我们选择将这个点加入最后的结果，那么他的子节点便不能加入；如果这个节点不加入，那么其子节点加入或不加入都满足题意，在这两种情况里找一个最优的情况来维护当前节点的最优解。我想到可以通过分别维护要或者不要这个节点来逐步向上转移，如下：

f[u][1]指的是要这个点的当前最优解，f[u][2]指的是不要这个点的当前最优解，
v是当前这个点的子节点。再结合上面的叙述可以得到以下代码。

```cpp
f[u][1]=max(f[u][1],f[u][1]+f[v][2]);
f[u][2]=max(f[u][2],max(f[u][2]+f[v][2],f[u][2]+f[v][1]));
```
其余的都是相对简单的问题了，比如邻接表存树，通过入度找出根节点，大佬们一定都会的。

```cpp
#include<iostream>
using namespace std;
struct edges {
	int to,next;
} edge[100000];
int n,head[10100]= {0},num=0,f[10000][3]= {0},root=0,in[1000000]= {0};
void add_edge(int u,int v) {
	edge[++num].next=head[u];
	edge[num].to=v;
	head[u]=num;
}
void dfs(int u,int fa) {
	for(int i=head[u]; i; i=edge[i].next) {
		int v=edge[i].to;
		if(v==fa) continue;
		dfs(v,u);
		f[u][1]=max(f[u][1],f[u][1]+f[v][2]);
		f[u][2]=max(f[u][2],max(f[u][2]+f[v][2],f[u][2]+f[v][1]));
	}
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) cin>>f[i][1];
	int x,y;
	while(1) {
		cin>>x>>y;
		if(x==0&&y==0) break;
		add_edge(y,x);
		add_edge(x,y);
		in[x]++;
	}
	for(int i=1; i<=n; i++) {
		if(in[i]==0) {
			root=i;
			dfs(root,root);
			break;
		}
	}
	cout<<max(f[root][1],f[root][2])<<endl;
	return 0;
}
```

数组可能开的太大了，当时没仔细看数据范围。QAQ

---

## 作者：EarthGiao (赞：3)

## 【思路】
DP 树形DP    
### 【声明】
上司指直接上司，员工指直接下属    
只是相连的两点不是间接上司或者间接下属    

### 【总体思路】
树形DP简单题   
先建立一棵树     
上司为父亲结点，员工为子节点    
（   
不是看不起员工qwq而是一个员工只有一个上司但是一个上司可以有多个员工   
上司更符合父亲结点，员工更符合子节点    
）     
然后从根开始先递归到一个叶子节点然后在递归上来   
递归过程中进行DP    

### 【状态转移方程式】
设f[i][1/0]     
表示这个点参不参加的最有情况    
1表示参加，0表示不参加   
如果这个点是参加的    
那么他的员工是不回来参加的所以只有一种不参加的情况    
可以有前面那个点也就是员工不参加的点上的最优解   
所以 fa[x][1] += fa[y][0];    
DP出这个点参加的最优解    
如果这个点事不参加的那么他的员工是可以参加也是可以不参加的    
所以可以从员工参加和不参加这两个状态的最大值DP过来   
所以 fa[x][0] += max(fa[y][0],fa[y][1]);     

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<vector>

using namespace std;
const int Max = 6005;
int a[Max];
bool use[Max];
vector<int>f[Max];
int fa[Max][2]; 

void  acioi(int x)
{
	fa[x][1] = a[x];
	fa[x][0] = 0;
	for(register int i = 0;i < f[x].size();i ++)
	//这里不能是i <= f[x].size() - 1因为.size返回的是一个指针不是一个数没有办法进行下去 
	{
		int y = f[x][i];
		acioi(y);
		fa[x][0] += max(fa[y][0],fa[y][1]);
		fa[x][1] += fa[y][0];
	}
}

int main()
{
	int n;
	cin >> n;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i];
	int x,y;
	int root;
	for(register int i = 1;i < n;++ i)
	{
		cin >> x >> y;
		f[y].push_back(x);
		use[x] = 1;
	}
	cin >> x >> y;
	for(register int i = 1;i <= n;++ i)
		if(use[i] == false)
		{root = i;break;}
	acioi(root);
	cout << max(fa[root][0],fa[root][1]) << endl;
	return 0;
}
```

---

## 作者：Pengsibo (赞：3)

题目描述我就跳过了啊

首先，这道题是一个

### 经典的树形DP

不可否认

# But，经典的树形DP就一定要用经典的方法来做吗？

# 我看未必

话说回来，~~本蒟蒻也是昨天才开始学习树形DP的~~，看到这道题顺便就进来了，第一眼一看不难，然后瞄了一下~~老师的题解，觉得好复杂~~，于是就决定自己用自己的方法做一个没那么复杂的，虽然最后发现~~我的方法有点烧脑子~~

所以这篇题解的思路还是正常的DP的思路，而不是树形DP的模板

## 切入正题：

首先分析时间复杂度，N<=6000，所以完全够我们开$N^{2}$

看过网上的，PPT上的，大佬们的，好多人一到树形DP那vector就忍不住要蹦出来了，弄得~~我这种不用vector的~~十分尴尬

树形DP其实对于每一个元素，都要记录他自己，父节点，子节点等各个信息，那么这么多信息集结在同一个点上，我更容易想到结构体

所以，struct来了

读完一遍题，初步分析发现，对于每一个员工（节点），我们需要记录其父节点 & 参加晚会的开心值

```
#include <iostream> 
#include <cstdio>
#include <cstring>
#include <iomanip>
using namespace std;

int n;
  
struct node
{
	int shang;		//上司编号 
	int ri;			//开心值
} x[6002];
  
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&x[i].ri);
   //基本输入
}
```

继续读入，思考DP的方程的时候发现，不管每一个员工参加还是不参加，计算都需要把他的下属（如果有的话）的开心值算进来，所以同时也要记录下属

又因为员工可以参加或不参加，而这两种情况互不干扰，所以分别再加一个变量

```
struct node
{
	int shang;		//上司编号 
	int ri;			//开心值
	
	int xia;		//下属个数 
	int xiax[6002];	//下属编号 
	
	int f1,f2;	//参加，不参加的开心值和 
} x[6002];

//这样，struct基本上就全了


 //那么再完善一下读入
 
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&x[i].ri);
	for (int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		x[a].shang=b;		//该员工上司的编号
		x[b].xia++; 		//该员工上司的下属 的个数
		x[b].xiax[x[b].xia]=a;	//该员工属于他上司的第几个下属
        
	//到这里可能有点绕，尤其是后两排
	//总之是在趁同时读入下属和上司的时候直接记录
	//分析一下最后一行: 对于a来说，a是他的上司b的第x[b].xia个员工（因为此时是读入，所以a相当于是新增的，所以可以直接用xia来表示
	//又因为对于b来说，xiax[]这个数组才是储存他的下属的数组
	//所以x[b].xiax[x[b].xia]就等于a了	（如果扔掉结构体，其实就是一个数组套数组）
        
	//注意这里是先xia++，后进行运算，因为xia的初始值为0；如果要后加的话，那后面的for循环就得从0开始而不是1
    
	}
	scanf("%d%d",&a,&b);	//这个读入的是那两个0，节约变量嘛:)

```

然后就该思考最重要的问题，状态转移

不难想到，每一个人有两个状态，参加或不参加

其中参加的开心值（这里指计算了的所有人的开心值之和）= 该员工一个人的开心值 + 他的直接下属们不参加的开心值

不参加的开心值 = 该员工的每一个下属的最大开心值之和，其中每一个下属的最大开心值是这个下属 参加或不参加的开心值中较大的那一个

##### 那么问题又来了，这是树形DP，不是线性DP，怎么保证无后效性？

推理发现，对于每一个员工的计算，都只涉及了他本身和他的下属，而和他的上司无关，所以只要保证在计算这个员工之前把他的下属都计算到了就好了

方法嘛，我第一个想到的是用队列

把每一个入度为0的节点先推入队列，计算后弹出，然后把他的父节点的入度-1，如果他的父节点的入度也变为0了，就把父节点推入队列，直到队列为空

想到这里就简单了，上代码

```
for (int i=1;i<=n;i++) {x[i].xiab=x[i].x;if (x[i].xia==0) q.push(i);if (x[i].shang==0) b=i;}
//如果入度为0，则推入队列；如果没有上司，则用b记录，最终输出的就是b的DP值
                      
while (!q.empty())
	{
		a=q.front();		//节约变量，用a来指代队列的第一个值
		q.pop();
		
		if (x[a].shang==0) break;
		x[x[a].shang].xiab--; 
		if (x[x[a].shang].xiab==0) q.push(x[a].shang);
        
		//因为计算的时候要用到x[].xia，所以这个值不能改变
		//故需要给x[].xia创造一个备份用以统计他的入度
		//换句话说，x[].xiab既是x[].xia的备份，又是x[]的入度
		//所以在上一个for循环的时候就要把x[i].xia赋给x[i].xiab (详见最上面几行)
	}
```

是时候完整一下前面的头文件 & 变量 & 初始化了

到这里时，整个代码看起来是这样的：

```
#include <iostream> 
#include <cstdio>
#include <cstring>
#include <iomanip>
#include <queue>		//需添加
using namespace std;

int n;

struct node
{
	int shang;		//上司编号 
	int ri;			//开心值
	
	int xia;		//下属个数 
	int xiab;		//下属个数备份 	//既是备份，又是入度，需添加
	int xiax[6002];		//下属编号 
	
	int f1,f2;	//参加，不参加的开心值和 	//需添加
} x[6002];

queue <int> q;		//定义队列，需添加

int main()
{
	int a,b;		//用a，b来辅助运算
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&x[i].ri);
	for (int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		x[a].shang=b;
		x[b].xia++; 
		x[b].xiax[x[b].xia]=a;
	}
	scanf("%d%d",&a,&b);
	for (int i=1;i<=n;i++) {x[i].xiab=x[i].xia;if (x[i].xia==0) q.push(i);if (x[i].shang==0) b=i;}
	
	while (!q.empty())
	{
		a=q.front();
		q.pop();
		
		if (x[a].shang==0) break;
		x[x[a].shang].xiab--; 
		if (x[x[a].shang].xiab==0) q.push(x[a].shang);
	}
	
}
```

而最关键的动态转移方程我们已经有文字叙述了，接下来就是把他转移成代码

```

	for (int i=1;i<=x[a].xia;i++) x[a].f1+=x[x[a].xiax[i]].f2;		//该人参加的开心值总和+=每一个下属不参加的开心值总和 
	x[a].f1+=x[a].ri;	//开心值总和再加上他自己参加的开心值
		
	for (int i=1;i<=x[a].xia;i++) x[a].f2+=max(x[x[a].xiax[i]].f1,x[x[a].xiax[i]].f2);	//该人不参加的开心值总和+=(自己每一个下属的开心值的最大值)之和
		
	这里同样运用了数组嵌套，在有结构体的情况下看起来有些繁琐（所以文章开头时我说我的方法也没那么简单）
}
```
最后我们要的结果就是总上司（那个没有上司的上司）参加或不参加的总开心值的最大值

```
printf("%d",max(x[b].f1,x[b].f2));
```
整道题解决！

总体看起来应该是这样的：
```
#include <iostream> 
#include <cstdio>
#include <cstring>
#include <iomanip>
#include <queue>
using namespace std;

int n;

struct node
{
	int shang;
	int ri;
	
	int xia;
	int xiab; 
	int xiax[6002];
	
	int f1,f2;
} x[6002];

queue <int> q;

int main()
{
	int a,b;
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&x[i].ri);
	for (int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		x[a].shang=b;
		x[b].xia++; 
		x[b].xiax[x[b].xia]=a;
	}
	scanf("%d%d",&a,&b);
	for (int i=1;i<=n;i++) {x[i].xiab=x[i].xia;if (x[i].xia==0) q.push(i);if (x[i].shang==0) b=i;}
	
	while (!q.empty())
	{
		a=q.front();
		q.pop();
		
		for (int i=1;i<=x[a].xia;i++) x[a].f1+=x[x[a].xiax[i]].f2;
		x[a].f1+=x[a].ri;
		
		for (int i=1;i<=x[a].xia;i++) x[a].f2+=max(x[x[a].xiax[i]].f1,x[x[a].xiax[i]].f2);
		
		if (x[a].shang==0) break;
		x[x[a].shang].xiab--; 
		if (x[x[a].shang].xiab==0) q.push(x[a].shang);
	}
	
	printf("%d",max(x[b].f1,x[b].f2));
	return 0;
}
```
写题解不易，还请大家鼓励！

---

## 作者：Max__HE (赞：3)



### p1352  没有上司的舞会

题目描述

某大学有N个职员，编号为1~N。他们之间有 _从属关系_ ，也就是说他们的关系就像一棵以 _校长为根的树_ ，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

输入格式：
第一行一个整数N。(1<=N<=6000)

接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128<=Ri<=127)

接下来N-1行，每行输入一对整数L,K。 _表示K是L的直接上司。_ 

最后一行输入0 0

输出格式：
输出最大的快乐指数。


————————————————————————————————————————————

 
读完题可以发现这就是一个树形dp;~~废话~~（详见斜体）

至于动态方程：
根据题目，无非就是取不取当前这个点；

于是可以得出以下方程：

1.	dp[x][0]+=max(dp[son][1],dp[son][0]); //  如果x不去,则快乐值为+儿子去或者不去的最大值

2.	dp[x][1]+=dp[son][0]; // 如果x去,则快乐值为+儿子不去的最大值

然后我们可以用一个vector数组表示从属关系

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()//快读 
{
	int f=1,x=0;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
} 

vector < int > v[6010];
int r[6010];
int n,boos[6010];
int maxn=1e9;
int dp[6010][10];

void init()//读入 
{
	n=read();
	for(int i=1;i<=n;++i)
	r[i]=read();
	for(int i=1;i<=maxn;++i)
	{
		int x=read(),y=read();
		if(x==y&&x==0) break;
		boos[x]=y;
		v[y].push_back(x);//建立从属关系 
	}
}

void dfs(int x)
{
	for(int j=0;j<v[x].size();++j)
	{
		int son=v[x][j]; 
		dfs(son);
		dp[x][0]+=max(dp[son][1],dp[son][0]); //  如果x不去,则快乐值为+儿子去或者不去的最大值
		dp[x][1]+=dp[son][0]; // 如果x去,则快乐值为+儿子不去的最大值

	}
	dp[x][1]+=r[x];//记得加上x点去的快乐值 
}

void work()
{
	for(int i=1;i<=n;++i)
	{
		if(boos[i]==0)//找根节点（老板） 
		{
			dfs(i); 
			printf("%d",max(dp[i][0],dp[i][1]));
			break;
		}
	}
}

int main()
{
	init();
	work();
	return 0;
}
_________________________________________________________________






---

## 作者：在想Peach (赞：3)

树形dp的一种神奇不回溯做法，很好理解。

要dp一个节点就需要他的下属都是处理过的，一般可以回溯求解，所以如果不回溯，就需要先从没有下属的哥们开始dfs，处理完一个人后就说明这个人的上司又有一个下属完成任务，接下来判定是否所有下属都完成了任务，如果完成了这个节点就可以处理，以此类推直到最后一个根节点处理完毕，那么就可以输出根节点去或不去的最大值。
dp转移式不变，i是遍历一个节点的下属时的循环数：

f[root][1]+=f[son[root][i]][0];

f[root][0]+=max(f[son[root][i]][0],f[son[root][i]][1]);

f[root][1]+=w[root];


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,w[6005],tot[6005],son[6005][6005],f[6005][2],fa[6005],x,y,ans,p[6005];
void dfs(int root)//玄学所在 
{
	for(int i=1;i<=tot[root];i++)//遍历自己下属来dp 
	{
		f[root][1]+=f[son[root][i]][0];//因为自己要来，所以自己下属都不用来了，直接加上下属不来的值 
		f[root][0]+=max(f[son[root][i]][0],f[son[root][i]][1]);//因为自己不来，所以下属爱来不来，那么加上最大值 
	}
	f[root][1]+=w[root];//因为自己来了，记着加上自己的幸福值 
	p[fa[root]]++;//报告自己上司你又有一个下属干完活了 
	if(p[fa[root]]==tot[fa[root]])dfs(fa[root]);//这个上司的所有下属都干完活了，这个上司也可以开始干活了 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>w[i];//幸福值 
	for(int i=1;i<=n-1;i++)
	{
		cin>>x>>y;
	    fa[x]=y;son[y][++tot[y]]=x;//fa数组记录他上司，son数组记录上司的新下属 
	}
	int e,d;cin>>e>>d;// 这玩意是0 0 
	for(int i=1;i<=n;i++)
	{
	if(fa[i]==0)ans=i;//找根节点，就是树根 
	if(tot[i]==0)dfs(i);//这个节点是叶子，就要从它开始向上遍历 
}
	cout<<max(f[ans][0],f[ans][1]);//输出树根的最大取值 
	return 0;
}
```


---

## 作者：wwyx2001 (赞：3)

因为一个可爱的手误wa了几次，C++福利，第一次写题解呐

好了正题

这是树形dp基础

1、    建树

2、    递归求解

f[i][0]表示不选这个节点，这样就会有孩子节点选or 不选

f[i][1]表示选这个节点，这样就会有孩子节点不选【不要忘了加自己的开心值

代码如下


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int b[6005][3005],re=0,n; 
int f[6005][2],a[6005]; 
bool c[6100];
void make()//建多叉树
{
    int x,y,i;
    memset(c,1,sizeof(c));
    for (int i=1;i<=n-1;i++)
    {
        scanf("%d%d",&x,&y);
        b[y][++b[y][0]]=x;
        c[x]=false;
    }
    scanf("%d%d",&x,&y);
    for (i=1;i<=n;i++)
      if (c[i]){
          re=i; break;        //re：找出根节点
      }
}
void dfs(int i)//递归过程
{
    int k;
    if (b[i][0]==0)     //如果到了叶子节点，就直接用开心值代替
      {
          f[i][1]=a[i];
          return;
      }
    for (k=1;k<=b[i][0];k++)
      {
          dfs(b[i][k]);
          f[i][1]+=f[b[i][k]][0];
          f[i][0]+=max(f[b[i][k]][0],f[b[i][k]][1]);
      }
    f[i][1]+=a[i];
}
int main()
{
    int i;
    scanf("%d",&n);
    for (i=1;i<=n;i++)
      scanf("%d",&a[i]);
    make();
    dfs(re);
    printf("%d",max(f[re][0],f[re][1]));
}

```

---

## 作者：一个昵称 (赞：2)

**~~树上DP入门题~~**

这是一个典型的树上DP 题目已经说的很明确了 他是一棵树 而且又是最优解 直接树上DP

首先我们看问题 可以很简单地推出两种状态 一种是**请了这个节点 他的子节点都不请**的状态 命名为g 另一种是**不请这个节点 请他的子节点**的状态 命名为f 那么 我们只需要从上到下**枚举每一个节点 然后算出他的f和g** 这道题就完美的解决啦

首先 第一个问题 如何从树的顶端开始从上往下搜

要先清楚一个问题 对于一棵已知树 其实可以以他的任意一个节点作为顶端建树 毕竟树是一个无向图嘛

而且 这题 上司来了 员工就不来 可以等价为 员工来了 上司就不能来 所以 谁为顶点就无所谓啦（~~更何况题目已经告诉你他是一棵树了~~）

然后 状态如何转移 

f是不请这个节点本身 请他的子节点 所以 只要加上请这个子节点的状态（即g） **能使值变大 就请** 反之 我们也可以得到 g是情了这个节点 他的子节点都不请 那我们就加上不请他的子节点的状态嘛（即f）

于是 我们就可以得到
```cpp
f[s]=max(g[v]+f[s],f[s]);
g[s]=max(g[s]+f[v],g[s]);
```
于是 这道题就完美地解……   ！！！ 怎么才90分 ！！！（本蒟蒻真实写照）

那么 为什么会WA一个点呢　因为　其实还有一个情况没考虑到　就是　如果Ri特别小 那么g加了一个不是很大的正的f 他的值也是负的 那么下一次转移时 就不会选它 但是 那个正的f 就被剪掉了！！！（因为 你可以两个上司都不选嘛）

故 完整的转移 应是
```cpp
f[s]=max(g[v]+f[s],f[s]);
f[s]=max(g[v],f[s]);
g[s]=max(g[s]+f[v],g[s]);
g[s]=max(g[s],f[v]);
```
好啦 现在 这道题就完美的A了

下面附上代码

```cpp
#include<iostream>
using namespace std;
int n,cnt;
struct nod{
	int to,nxt;
}e[5000001];

int head[6001];

int a[6001];

int f[6001];

int g[6001];

void addEdge(int u,int v){
	e[++cnt]=(nod){v,head[u]};
	head[u]=cnt;
}

void dfs(int s,int fa){
	if(g[s]!=-129) return;
	g[s]=a[s];
	for(int i=head[s];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,s);
		f[s]=max(g[v]+f[s],f[s]);
		f[s]=max(g[v],f[s]);
		g[s]=max(g[s]+f[v],g[s]);
		g[s]=max(g[s],f[v]);
	}
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		g[i]=-129;
	}
	int u,v;
	while(cin>>u>>v&&u!=0&&v!=0){
		addEdge(u,v);
		addEdge(v,u);
	}
	dfs(1,0);
	cout<<max(f[1],g[1]);
	return 0;
}
```

---

## 作者：CENRUIYANG (赞：2)

- ## 题意理解
给定一棵树，选择一部分节点以满足以下条件：

#### 1. 不能同时选择一个节点与它的儿子或父亲
#### 2. 满足条件1的情况下使各节点权值之和最大
~~显然树形dp~~
- ## 方法的选用
树形dp！

选择原因：
#### 1. 树形结构
#### 2. 满足dp的三个原则(最优子结构、重叠子问题、无后效性)
- ## 具体的实现
### 1. 定义状态
dp[i][0]表示以i节点为根的子树不取i节点时的最大权值之和

dp[i][1]表示以i节点为根的子树取i节点时的最大权值之和
### 2. 初始化
不取i节点时：dp[i][0]=0;

取i节点时：dp[i][1]=val[i];
### 3. 状态转移方程
根据定义可知：

dp[i][0]+=max(dp[i_son][0],dp[i_son][1]);

dp[i][1]+=dp[i_son][0];
### 4. 最终的结果
显然应输出max(dp[root][0],dp[root][1])
### 5. ~~大家最期待的~~代码(注释真的详尽)
```cpp
#include<cstdio>
#include<vector>//不用万能头不解释
using namespace std;
#define For(i,j,k) for(int i=j;i<=k;i++)//个人喜好
vector<int>v[6005];
int val[6005]={},vis[6005]={},dp[6005][2]={};
void treedp(int root){
    dp[root][0]=0;//不取根节点，此时是0
    dp[root][1]=val[root];//取了根节点，更新为val[root]
    int sz=v[root].size();//从root节点出发的边的条数
    For(i,0,sz-1){//从0开始
        int son=v[root][i];
        treedp(son);//先算子问题
        dp[root][0]+=max(dp[son][0],dp[son][1]);//选择拿不拿root的儿子
        dp[root][1]+=dp[son][0];//别无选择
    }
}
int main(){
    int n;scanf("%d",&n);
    For(i,1,n)scanf("%d",val+i);
    int x,y;
    while(scanf("%d%d",&x,&y)==2&&(x||y)){
        v[y].push_back(x);//建立一条边(y->x)
        vis[x]=1;
    }//读入
    int root=1;
    while(vis[root])root++;//找到根节点
    treedp(root);//从根节点开始搜索
    printf("%d\n",max(dp[root][0],dp[root][1]));//最终结果中可拿根节点也可不拿
    return 0;//愉快结束~
}

```
~~本蒟蒻第一篇题解，大佬勿喷~~

---

## 作者：peterwuyihong (赞：2)

# 这是一道典型的树形dp
设$f[x][0]$表示以x为根，但不选x的最大快乐指数，$f[x][1]$表示以x为根，并选x的最大快乐指数，我们就能~~简单地~~明白转移方程
$$
f[x][0]=\sum_{y \in x's\ sons}\max(f[y][0],f[y][1])
$$
如果不选x，则子节点都能爱选不选
$$
f[x][1]=happy[x]+\sum_{y \in x's\ sons}f[y][0]
$$
如果选x，则直接下属不可以选（贪心策略可以证明）
$$
f[leaf][0]=0,f[leaf][1]=happy[leaf]
$$
边界条件，选择leaf与不选择leaf
# 上代码~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[6005];
int ver[6005],Next[6005],head[6005],tot;//邻接表存边
int f[6005][2],x,y;
bool fa[6005];
void add(int x,int y)
{
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}
void dp(int x)//树形dp，上文解释了
{
	f[x][0]=0;
	f[x][1]=a[x];
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		dp(y);
		f[x][0]+=max(f[y][0],f[y][1]);
		f[x][1]+=f[y][0];
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(int i=1;i<n;i++)
	{
		scanf("%d %d",&x,&y);
		add(y,x);fa[x]=1;//注意是y是x的上司
	}
	for(int i=1;i<=n;i++)
	if(!fa[i])//找到祖宗节点
	{
		dp(i);
		printf("%d",max(f[i][0],f[i][1]));//答案
		break;
	}
}
```


---

## 作者：Hiraeth (赞：2)

## 树形$dp$:

众所周知，$dp$是一门玄学…

本篇主要浅显地讲解一下树形$dp$的特点及其相关应用

更多的内容需要大家自己去研究.

~~因为本人的水平实在有限~~

### 前置技能：
 
[树结构](https://baike.baidu.com/item/%E6%A0%91%E7%BB%93%E6%9E%84/3399688?fr=aladdin)

[动态规划](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin)

### 树形$dp$定义：

树形动态规划问题可以分解成若干相互联系的阶段，在每一个阶段都要做出决策，全部过程的决

策是一个决策序列。要使整个活动的总体效果达到最优的问题，称为多阶段决策问题。

#### 无后效性：

无后效性是指如果在某个阶段上过程的状态已知，则从此阶段以后过程的发展变化仅与此阶段的状态有关，

而与过程在此阶段以前的阶段所经历过的状态无关。利用动态规划方法求解多阶段决策过程问题，过程的状

态必须具备无后效性。

#### 树形$dp$的特殊性质：

没有环，$dfs$是不会重复的，而且具有明显而又严格的层数关系。利用这一特性，我们可以很清晰地根据题目要求写出一个在树形结构上的记忆化搜索程序。

### 经典例题：

##### ~~（反正我老师说是经典例题，是不是我不清楚… 这个锅我不背 $qaq$)~~

#### 1. [HDU 1520 (Anniversary party)](http://acm.hdu.edu.cn/showproblem.php?pid=1520)
####    [P1352 没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)

如果关系构成一条链,则$i$能不能参加舞会只和$i-1$有没有参加舞会有关。所以,可以用：

$f[i][0]$ 表示$i$不参加舞会的情况下，前i个人能达到的最大快乐指数和。

$f[i][1]$  表示$i$参加舞会的情况下，前i个人能达到的最大快乐指数和。

状态转移方程如下：

$f[i][0]=max{f[i-1][0],f[i-1][1]}$

对于本题，考虑每一棵子树，其根节点为$i$。

$i$能不能参加舞会只和$i$的孩子有没有参加舞会有关，和以$i$的孩子为根的子树如何决策无关。

所以用:

$f[i][0]$   表示i不参加舞会的情况下，以i为根的子树能达到的最大快乐指数和。

$f[i][1]$   表示i参加舞会的情况下，以i为根的子树能达到的最大快乐指数和。

则有：

$f[i][0]=∑max{f[j][0],f[j][1]} $

$f[i][1]=∑f[j][0]+R[i]$  

状态转移方程：

$f[i][0]=∑max{f[j][0],f[j][1]} $

$f[i][1]=∑f[j][0]+R[i]$ 

其中，$j$为$i$的儿子
	
#### 2. [HDU 2196 Computer](http://acm.hdu.edu.cn/showproblem.php?pid=2196)

由于题目告诉我们“每台新电脑和之前的某一台电脑连接”，这与每个非根节点只有一个父亲对应，所以得出：
       
所有电脑与之间的连接构成了一棵树。
       
问题就转化成了，给定一棵有边权的树，求第i台电脑与距离它最远的电脑之间的距离$Si$。

我们在做$dfs$的时候可以做一些改进：

当我们确定一个点为起点的时候，这棵树就成了一颗有根树，我们不妨记录以每个点$i$为根的子树中，距离该点的最长路$f[i]$，则有：

$f[i]=max(f[j]+len[i][j])$，其中j为i的孩子。
 
那么，我们同样能在$O(n)$的复杂度内得到根的答案$f[root]$。
     
这样做，我们还是需要枚举每个点作为根。

复杂度还是不变！

但是我们发现，改进后，我们在第一遍$dfs$后就得到了以每个点为根的子树中到该点的最长路，我们只差该点经过它父亲得到的最长路，离要求的答案仅有一步之遥！

显然，$f[root]$即为$root$的答案，我们接下来考虑$root$的孩子$i$，有人认为$i$的答案就是$max(f[i],f[root]+len[root][i])$。这是不对的，因为有可能$f[root]$是$root$经过$i$得到的，这样我们以i为起点的时候$f[root]+len[root][i]$相当于走了$i->root->i$这样的非法路径。

 但我们可以第一遍$dfs$的时候记录下每个点i为根的子树中，距离i的最长路、次长路分别为$f[i][0]$、$f[i][1]$（保证最长路和次长路经过i的两个不同的孩子）并记录对应的经过的孩子$g[i][0]$、$g[i][1]$。这样我们在考虑$root$的孩子$i$时有：
 
 如果$g[root][0]!=i$，$i$的答案就是
                 $max(f[i],f[root][0]+len[root][i])$；
 
 否则，$i$的答案就是
                 $max(f[i],f[root][1]+len[root][i])$，
 
 我们可以同时更新$f[i]$和$g[i]$，以便计算$i$的孩子的答案。
 
 可以发现我们在计算一个点$i$的答案时，必须要先知道它的父亲的答案。只要用$dfs$的顺序计算就可以了。
 
 这样，两遍$dfs$，每次转移都是$O(1)$，总复杂度$O(n)$。

### 最后的最后

还有两条大家感兴趣的可以自己去做一做。

[POJ 3107 Godfather](http://poj.org/problem?id=3107)

[POJ 1155 TELE](http://poj.org/problem?id=1155)

---

## 作者：zdr0820 (赞：2)

DFS+DP，dp[x,1]表示x去，dp[x,0]表示x不去


dp[x,1]:=sum(dp[所有子节点,0])+快乐值[x];//x去了，下属不能去，所以dp[所有子节点,0]

dp[x,0]:=sum(max(dp[所有子节点,0],dp[所有子节点,1]));//x不去，下属可去可不去，所以max(dp[所有子节点,0],dp[所有子节点,1])

注意先求下属，再求上司，但是数据水，直接循环也能80


代码优化很差，只有40ms


> uses math;
```cpp
var
    r,father:array[1..6000] of longint;
    dp:array[0..6000,0..1] of longint;
    b:array[1..6000] of boolean;
    n,i,k,t1,t2:longint;
procedure dfs(x:longint);
  var
      i:longint;
  begin
      if b[x] then exit;
      b[x]:=true;
      for i:=1 to n do if father[i]=x then dfs(i);
      inc(dp[x,1],r[x]);
      inc(dp[father[x],0],max(dp[x,1],dp[x,0]));
      inc(dp[father[x],1],dp[x,0]);
  end;
begin
    readln(n);
    for i:=1 to n do readln(r[i]);
    fillchar(father,sizeof(father),0);
    for i:=1 to n-1 do begin
      readln(t1,t2);
      father[t1]:=t2;
    end;
    k:=1;
    while father[k]<>0 do k:=father[k];
    fillchar(dp,sizeof(dp),0);
    dfs(k);
    writeln(max(dp[k,1],dp[k,0]));
end.
```

---

## 作者：xh39 (赞：1)

树形dp做得少,所以我把它转换为序列进行dp。

首先我们确定:选了第a层的就不能选第a-1和第a+1层。所以我们可以把它转换为给一个序列,不能选相邻的两项,然后O(n²)求解。

方程状态:f[i]表示以第i项结尾(就是一定选i,并且不能选i之后的数)的最大值。

状态转移方程:f[i]=max{f[j]}(0<=j<i-1)+a[i]

```cpp
#include<iostream>
#include<vector>
using namespace std;
long long a[6005],happy[6005],zyl[6005],f[6005];
vector<long long> son[6005];
long long father[6005];
long long max(long long a,long long b){ //库函数只能用int,所以只好自己写了。。。
	return a>b?a:b;
}
long long dfs(long long step,long long s){ //转换序列的过程。zyl[i]表示第i层总共的欢乐度和。
	long long i,size=son[s].size();
	zyl[step]+=max(happy[s],0); //如果是负数就不如不选。 
	for(i=0;i<size;i++){
		dfs(step+1,son[s][i]);
	}
}
int main(){
	long long n,i,j,size,a,b,Max;
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>happy[i];
	}
	for(;;){
		cin>>a>>b;
		if(a+b==0){
			break;
		}
		son[b].push_back(a); //建单向边。
		father[a]=b;
	}
	for(i=1;i<=n;i++){ //由于没保证是连通图,所以类似森林,找出所有根节点(老板)。
		if(father[i]==0){
			dfs(0,i);
		}
	}
	for(i=0;i<n;i++){
		Max=0;
		for(j=0;j<i-1;j++){
			Max=max(Max,f[j]); //想优化也可以开个数组记录从1到i的最大值,但o(n²)可以解决,就懒得优化了。
		}
		f[i]=Max+zyl[i]; 
	}
	Max=0;
	for(i=0;i<n;i++){
		Max=max(Max,f[i]); //记得取所有的最大值,才是答案。
	}
	cout<<Max;
}
```

---

## 作者：KiloP (赞：1)

# 一道经典的树形DP


```
#include <ios>
#include <iostream>
#include <algorithm>
#pragma GCC optimize(2)  //没事瞎玩儿
using namespace std;
int head[20000], vet[20000], Next[20000];//边表
int dp[20000][2], p[10000], ind[10000];
//dp[x][0]表示x点不取，x及其子树所能达到的最大快乐指数
//dp[x][1]表示x点取，x及其子树所能达到的最大快乐指数
//ind[x]表示x的入度，用来查找根
int edgenum, n, u, v, root;
inline void addedge(int u, int v)
{
	edgenum++;
	vet[edgenum] = v;
	Next[edgenum] = head[u];
	head[u] = edgenum;
}
inline void dfs(int u)
{
	dp[u][1]+=p[u];//如果u点取，还要加上自己的快乐指数
	for (register int e = head[u]; e; e = Next[e])
	{
		int v = vet[e];
		dfs(v);//从叶子节点向上DP
		dp[u][0] += max(dp[v][0], dp[v][1]);
		//当u点不取，v点可取，可不取，取稍大进行累加
		dp[u][1] += dp[v][0];
		//当u点不取，v点只能不取，进行累加
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for (register int i = 1; i <= n; i++)
		cin >> p[i];
	for (int i = 1; i < n; i++)
	{
		cin >> u >> v;
		addedge(v, u);//只能是上司连向下属，否则会死循环
		ind[u]++;
	}
	for (register int i = 1; i <= n; i++)
		if (ind[i] == 0)
		{
			root = i;
			break;
		}
	dfs(root);
	cout<<max(dp[root][0], dp[root][1])<<'\n';
	//答案是根取和不取的较大值
	system("pause");
	return 0;
}

---

## 作者：JCRC (赞：1)

~~**emmm第一篇题解阔能有点水**~~

### 根据题意，我们用两个一朵多维数组H[2][maxn]来存状态

### 其中H[1][i]代表邀请i的值

### H[0][i]代表不邀请i的值

### 可得状态转移方程

### H[0][k]=max(H[1][i],H[0][i])返回根节点的最大值

### H[1][k]+=H[0][k]因为子节点如果不邀请，就直接邀请i

### 然后比较。。。

# 代码如下
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define IV inline void
#define II inline int
#define RI register int
using namespace std;
II maxx(int x,int y){
    return x>y?x:y;
}				//再加上快读就完美了QWQ
int N,H[2][6001],fa[6001],n,root;		//fa是存父亲节点的的数组
bool pd[6001];			//判断子节点有没有被遍历过
IV dfs(int k)
{
    
    pd[k]=1;
    for(RI i=1;i<=N;i++)
    {
    if(pd[i])	
    continue;//遍历过就继续
    if(fa[i]==k)
    {
    dfs(i);
    H[1][k]+=H[0][i];
    H[0][k]+=maxx(H[0][i],H[1][i]);//转移操作
    }
    }
    //如果搜不到的话，即为叶子节点或子节点搜完，函数结束
}

int main()
{
    scanf("%d",&N);
    for(RI i=1;i<=N;i++)
    scanf("%d",&H[1][i]);
    for(RI i=1;i<=N-1;i++)
    {
        cin>>n;
        cin>>fa[n];
    }			//杂乱的输入操作233
    for(RI i=1;i<=N;i++)
    if(!fa[i])			//如果没有父亲，就为根节点
    { 
        dfs(i);
        cout<<maxx(H[0][i],H[1][i]);    //最后老大还要选择观赏还是嗨皮
        break;
    }
    return 0;
}
```
~~希望能过233~~

---

## 作者：shuri001 (赞：1)

树形dp经典例题！

//事实上感觉就是在搜索嘛。。。（雾）

反正就是从儿子节点一层一层推上来就是啦~


f[i]=sigma(g[i.sons])

g[i]=sigma(max{f[i.sons],g[i.sons]})

//这个又是树型动态规划的一种分类，每个结点都有二种状态既选与不选。

上代码看看呗 关键部分注释了~

```cpp
#include<vector>
#include<cstdio>
#include<cmath>
using namespace std;
const int maxn=6001;
int fa[maxn],f[maxn],g[maxn],gen,n,val[maxn];
vector<int> son[maxn];
void dfs(int i){
    int t=son[i].size();//t表示有多少个儿子 
    f[i]=val[i]; 
    g[i]=0;
    if(t!=0){
        for(int j=0;j<t;j++){
            dfs(son[i][j]);//搜儿子 
            f[i]+=max(g[son[i][j]],0);//要么放g要么不放 
            int maxsu=0;
            maxsu=max(f[son[i][j]],max(maxsu,g[son[i][j]]));//f和g一个表示放 一个表示不放
            g[i]+=maxsu;//f表示放i的最大值，g表示不放i的最大值
        }
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&val[i]);
    int x,y;
    while(scanf("%d%d",&x,&y)!=EOF && x!=0 &&y!=0){
        fa[x]=y;
        son[y].push_back(x);//读入树 顺道记录儿子 
    }
    for(int i=1;i<=n;i++)
        if(fa[i]==0){
            gen=i;//找一下根在哪里 
            break;
        }
    dfs(gen);//搜呗 
    printf("%d\n",max(f[gen],g[gen]));
    return 0;
}
```

---

## 作者：HullEssien (赞：1)

hdu莫名T一到洛谷就90然后发现是快读没有负数的锅果断改scanf然后秒A?

题解里的爆栈和拓扑我咋都没发现?

害怕

思路非常简单

因为两个直接相连的点不能被同时选

所以
用f[i][0/1]表示以i为根节点的子树选i/不选i所能获得的最大价值


则 f[i][0]=sigema(max(f[son][0],f[son][1])); for each son of i



f[i][1]=sigema(f[son][0]); for each son of i

代码:






```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define maxn 10000
using namespace std;
int n,f[maxn][2],val[maxn],fa[maxn],head[maxn],cnt; 
struct edge
{
    int to,pre;
}e[maxn];
inline void add(int from,int to)
{
    e[++cnt].pre=head[from];
    e[cnt].to=to;
    head[from]=cnt;
}
void dp(int now)
{
    f[now][1]=val[now];
    for(int i=head[now];i;i=e[i].pre)
    {
        int go=e[i].to;
        dp(go);
        f[now][1]+=f[go][0];
        f[now][0]+=max(f[go][0],f[go][1]);
    }
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&val[i]);
            fa[i]=-1;
        }
        int son,father;
        scanf("%d%d",&son,&father);
        while(1)
        {
            fa[son]=father;
            add(father,son);
            scanf("%d%d",&son,&father);
            if(son==0&&father==0)
            {
                break;
            }
        } 
        int now=1;
        while(fa[now]!=-1)
        {
//        printf("fa[%d]=%d\n",now,fa[now]);
            now=fa[now];
        }
        dp(now);
        printf("%d\n",max(f[now][0],f[now][1]));
    }
    return 0;
}
```

---

## 作者：bingliang (赞：1)

树形dp初体验。。。


感觉树形dp是一种基于dfs和dp的对于树结构问题操作的dp。 自己写的一点感受。。。（老鸟勿喷）。。。树形dp自己一直很弱


主要就是在写题解的时候整理思路。 当然欢迎各位OIER指正或者教导我。


进入正题，多叉转二叉我理解了意思还不会打 ，主要说的是并查集。


这道题解题有两部分


1.数据结构 及如何存储多叉树结构


1.tree[i][j]==1表示以i为父亲 j为儿子，tree[i][j]==0则表示i不是j的父亲


而此时查询是否有==1的复杂度为 o（n），空间 0（n^2）


2多叉变2叉 时间复杂度应该是log级的 空间o（n）


3.并查集 pre[i]=j表示 i的父亲为j 或j的父亲为i无所谓的


时间复杂度 o（n） 空间复杂度o（n）


显然是非常方便的


至于dp过程楼下讲的很详细了，题解好多呢。


但写到此处突然想水下树形dp的基本思路 觉得我写的不好的可以看楼下


就是在 对于数dfs的过程中对于本题是把点分为两类，上司去舞会的和不去的，在分情况讨论，


及对于上司去的他的下属只能不去


但上司不去的 他的下属既能去也能不去。


感觉跟其他的dp思路还是很不一样的。好神奇的感觉。


---

## 作者：shadowice1984 (赞：1)

邻接矩阵存图~

对于一个点，令d（i，j）表示他去或不去，所有子树的和；

那么，只需要依次加上所有点，即可完成状态转移。

另外，记忆话搜索需要从根开始。

所以需要搜一遍，找到校长。

上代码；

    
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
int n;bool map[6000][6000];
int val[6000];int d[6000][2];
int mdfs(int x,int jud)//记忆话搜索
{
    if(d[x][jud]!=-1)
    {
        return d[x][jud];
    }
    if(jud==0)//不去
    {
        d[x][jud]=0;//消掉-1的标记
        for(int i=0;i<n;i++)
        {
            if(map[x][i])//查找邻接矩阵
            d[x][jud]+=max(mdfs(i,0),mdfs(i,1));//子树和
        }
    }
    else if(jud==1)//去
    {
        d[x][jud]=val[x];//加上权值
        for(int i=0;i<n;i++)
        {
            if(map[x][i])
            d[x][jud]+=mdfs(i,0);//下属只能不去
        }
    }
    //printf("mdfs %d %d=%d\n",x,jud,d[x][jud]);调试语句
    return d[x][jud];
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)//手动memset~
    {
        for(int j=0;j<2;j++)
        {
            d[i][j]=-1;
        }
    }
    for(int i=0;i<n;i++)
    {
        scanf("%d",&val[i]);
    }
    for(int i=0;i<n-1;i++)
    {
        int u;int v;
        scanf("%d%d",&u,&v);
        map[v-1][u-1]=true;
    }
    int start=0;
    for(int i=0;i<n;i++)//搜一遍图，找校长
    {
        for(int j=0;j<n;j++)
        {
            if(map[j][i])goto skip;
        }
        start=i;break;
        skip:;
    }
    int res=max(mdfs(start,0),mdfs(start,1));//校长去与不去
    printf("%d",res);
    return 0;//拜拜程序
}
```

---

## 作者：cheeseYang (赞：1)

经典的树形DP，f[i][1]表示第i个人去舞会的情况，并且重点在于当第i个人去的时候，他的下属全部能去，也就是f[i][1]+=f[j][0]，但是当他不去的时候，他的下属就可以去或者不去，f[i][0]+=max(f[j][1],f[j][0])(j表示他的下属)，我们用一个递归函数来实现，用vector存边（也可以用链式前向星），用一个结构体保存这个点的上司以及他的下属，输入权值的时候，直接用f[i][1]输入，因为他去的时候才有权值

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6005;
struct node{
    int fa;
    vector<int> z;
}a[maxn];
int n,f[maxn][2],d[maxn],rt;
void dfs(int rt){
    int t=rt;
    for(int i=0;i<a[t].z.size();++i){
        dfs(a[t].z[i]);
        f[t][1]+=f[a[t].z[i]][0];
        f[t][0]+=max(f[a[t].z[i]][0],f[a[t].z[i]][1]);
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;++i)
        scanf("%d",&f[i][1]);
    int x,y;
    while(scanf("%d%d",&x,&y),x!=0,y!=0){    
        a[x].fa=y;
        a[y].z.push_back(x);
    }
    for(int i=1;i<=n;++i)
        if(a[i].fa==0){
            rt=i;    
            break;
        }
    dfs(rt);
    cout<<max(f[rt][1],f[rt][0]);
    return 0;
}
```

---

## 作者：ww3113306 (赞：1)

并不知道拓扑排序是什么，，于是，去学了一下树形DP，按照我的理解写了一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{
    int belong[6000],tot,price;
};
int f[6010][2],n,ans;abc s[6010];bool z[6010],zy[6010];
void search(int now)//从校长往下搜，搜到底返回回来的时候再把属下来或不来的快乐指数加上，和深搜差不多，这样就可以保证返回到上司时，他正在处理的下属已经是处理完毕的，不然就会少加一些快乐指数
{
    int i,a=1,j;
    for(i=1;i<=s[now].tot;i++)
    {
        search(s[now].belong[i]);//深搜完一个就一层一层加上来
        f[now][1]+=f[s[now].belong[i]][0];
        if(f[s[now].belong[i]][1]>f[s[now].belong[i]][0])f[now][0]+=f[s[now].belong[i]][1];//如果上司不来的话就取属下来或者不来的最大值
            else f[now][0]+=f[s[now].belong[i]][0];
    }
}
int main()
{
    int i,l,k;
    scanf("%d",&n);
    memset(z,0,6010);
    memset(zy,0,6010);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&s[i].price);
        f[i][1]=s[i].price;
    }
    scanf("%d%d",&l,&k);
    while(l&&k)
    {
        s[k].tot++;
        s[k].belong[s[k].tot]=l;
        z[k]=true;//z为true代表有下属 //这个数组好像并没有什么用，是之前另外一个算法遗留下来的，懒得删了，这个算法好像并不要用到
        zy[l]=true;//zy为true代表有上司，为false就是校长 
        scanf("%d%d",&l,&k);
    }
    for(i=1;i<=n;i++)
    {
        if(!zy[i]) //如果是校长就搜
        {
            ans=i;
            search(i);
        }
    }
    if(f[ans][1]>f[ans][0]) printf("%d",f[ans][1]);
    else printf("%d",f[ans][0]);
    return 0;
}
```

---

## 作者：Solomon_611 (赞：1)

这道题明显是一道树形DP题~~多亏看了标签~~

我们设dp[i][0]为i不来时最大开心值  同理dp[i][1]为i来时最大开心值

在题中，我们知道上司和下属不能同时出现~~而且上司的上司不是你的上司~~

于是推出DP方程为 dp[i][0]=max{dp[j][0],dp[j][1]}    dp[i][1]+=dp[j][0]  (j为i的下属，并且每个dp[i][1]都初始化为他的开心值)

推出DP方程后，我们很愉快的写出的~~50分~~代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <queue>
#include <list>
#include <set>
#include <stack>
#include <vector>
#include <map>
using namespace std;

struct Tree
{
    vector<int> son;  //子节点
    int sum;  //开心值
}tree[10001];
int dp[10001][5];  
int Boss[10001];  //我们用来找根节点.....

void Dp(int i)
{
    if (tree[i].son.empty())  //如果是叶子节点
    {
        dp[i][1] = tree[i].sum;  //加上开心值，返回
        return;
    }
    int len = tree[i].son.size();  //如果有子节点，开始寻找子节点
    for (int j = 0; j < len; j++)
    {
        if (dp[tree[i].son[j]][1] == 0) //如果没有值，进行递归 （这算个小剪枝了）
        {
            Dp(tree[i].son[j]);
        }
        dp[i][0] += max(dp[tree[i].son[j]][0], dp[tree[i].son[j]][1]);  //dp方程
        dp[i][1] += dp[tree[i].son[j]][0];  //dp方程
    }
}

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> tree[i].sum;
    }
    int x, y;
    while (cin >> x >> y)
    {
        if (x == 0 && y == 0)
        {
            break;
        }
        tree[y].son.push_back(x);
        Boss[x]++;
    }
    int root;
    for (int i = 1; i <= n; i++)
    {
        if (Boss[i] == 0) //寻找根节点
        {
            root = i;
            break;
        }
    }
    Dp(root);
    cout << max(dp[root][1] + tree[root].sum, dp[root][0]); //这个地方的dp[root][1]+tree[iroot].sum 是在最后根节点加上他的开心值，因为根节点一直没有加上它的开心值
    return 0;
}
```
但这个时候，我们发现这个代码只有50分

于是我就下载了个数据测试为什么不对

结果竟然是这样的错误！！！

#栈溢出

于是我一气之下删掉了这段~~万恶的~~代码

并开始学习拓扑排序

拓扑排序后我们就能够保证子节点一定在根节点之后

这样我们就可以愉快的写DP了   ~~万恶的递归再见~~

于是就出现了这样的~~100分~~代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <queue>
#include <list>
#include <set>
#include <stack>
#include <vector>
#include <map>
using namespace std;

struct Tree
{
    vector<int> son;
    int sum, Boss;  //在这里这个Boss不再是上面代码的用来找根节点的值了，而是入度
}tree[10001];
int dp[10001][5];
vector<int> zero;  //存入度为零的值
vector<int> Sort;  //排序结果

void tuopu()
{
    while (!zero.empty()) //除非没有入度为零的值了（因为这题是树，不是图，所有点一定会全部遍历到，而且没有环）
    {
        int i = zero.back();   //这次的根节点，去吧它所有子节入读-1
        zero.pop_back();
        int len = tree[i].son.size();
        for (int j = 0; j < len; j++) //把所有子节点的入读-1
        {
            tree[tree[i].son[j]].Boss--;
            if (tree[tree[i].son[j]].Boss == 0) //如果这个节点的入读为零
            {
                zero.push_back(tree[i].son[j]); //放入存入读为零的数组中
            }
        }
        Sort.push_back(i); //把这个根节点放入排序数组
    }
}

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> tree[i].sum;
    }
    int x, y;
    while (cin >> x >> y)
    {
        if (x == 0 && y == 0)
        {
            break;
        }
        tree[y].son.push_back(x);
        tree[x].Boss++;
    }
    int root;
    for (int i = 1; i <= n; i++)
    {
        if (tree[i].Boss == 0) //找根节点
        {
            root = i;
            zero.push_back(i);
            break;
        }
    }
    tuopu();
    int l = Sort.size();
    for (int i = l - 1; i >= 0; i--) //从后往前 ，因为拓扑排序子节点一定在根节点后
    {
        int len = tree[Sort[i]].son.size();
        for (int j = 0; j < len; j++) //去找这个根节点的所有子节点，进行DP
        {
            dp[Sort[i]][0] += max(dp[tree[Sort[i]].son[j]][1], dp[tree[Sort[i]].son[j]][0]);  //dp方程   （有点乱，见谅啊）
            dp[Sort[i]][1] += dp[tree[Sort[i]].son[j]][0];  //dp方程  （有点乱，见谅啊）
        }
        dp[Sort[i]][1] += tree[Sort[i]].sum; //无论叶子节点还是根节点，让这个节点来的时候一定要加它的开心值
    }
    cout << max(dp[root][1], dp[root][0]); //因为这里所有节点都会加上开心值，于是就不用想上段代码那样再去加了
    return 0;
}
```
介个就是~~100分~~代码

因为这是树，所以不用担心环的问题


---

## 作者：amstar (赞：1)

思路：拓扑排序+动规

具体方法就是先找到所有的入度为0的点，（最下层的点），入队。从下面往上走，遇到入度为0的入队，并且稍微加一点处理。

首先我们要明确，每个点都有“选”，“不选”两种(来不来)，

然后假设d表示当前到了d点，u是他的上司，f[][0/1]表示当前点选或者不选时的快乐最大值

那么从当前点到他的上司时，他的上司如果选：f[u][1]+=f[d][0];当前点就不能选，如果他的上司不选 f[u][0]=max(f[d][0],f[d][1]);他可以选也可以不选，取大。

那我们就可以在拓扑排序时把这些完成就行了。



```cpp
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;
struct node{
    int up,hp,ru;
}t[10010];
int f[10010][2];
int n,ans;
queue<int>q;
int main()
{
    scanf("%d",&n);
    for (int i=1; i<=n; ++i)
        scanf("%d",&t[i].hp);
    for (int i=1; i<n; ++i)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        t[a].up = b;
        t[b].ru++;
    }
    for (int i=1; i<=n; ++i)
    {
        f[i][1] = t[i].hp;
        if (t[i].ru==0) q.push(i);
    }
    while (!q.empty())
    {
        int d = q.front();
        q.pop();
        int u = t[d].up;
        if (u)
        {
            f[u][0] += max(f[d][1],f[d][0]);
            f[u][1] += f[d][0];
            t[u].ru--;
            if (t[u].ru==0) q.push(u);
        }
        else ans += max(f[d][1],f[d][0]);
    }
    printf("%d\n",ans);    
    return 0;
}
```

---

## 作者：foreverpiano (赞：1)

为什么大家的代码都这么复杂呢？紫书上的模板树的最大独立集不用？

讲一下思路，我们用d[i]表示以i为根的子树的答案，对于i只有两种决策选或者不选。于是我们就可以推出状态转移方程d[i]=max{w[i]+d[gson],d[son])gson表示他儿子的儿子节点，也就是选i这个节点的情况，而son就是不选i这个节点的情况。

列出了dp方程之后，我们会发现代码无从下手，我们可以换一个角度来看，不用找son和gson元素，而是从son和gson元素来找i，用d[son]和d[gson]来更新i的值，所以每个节点不需要记录子节点有哪些，只需要记录父节点就可以了。放上代码吧~

[打个小广告](http://www.cnblogs.com/foreverpiano/)

```cpp
#include<bits/stdc++.h>
#define maxn 7000
using namespace std;
int gs[maxn],d[maxn],w[maxn],s[maxn];
vector<int> g[maxn];
int n;

int dp(int x,int fa)
{
    if(d[x]) return d[x];//如果搜过了就返回 
    for(int i=0;i<g[x].size();i++)
    {
        int m=g[x][i];
        if(m==fa) continue;//不能再搜索他的父节点 
        dp(m,x);
        s[x]+=d[m];
        if(fa!=-1) gs[fa]+=d[m];
    }
    return d[x]=max(w[x]+gs[x],s[x]);
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>w[i];
    for(int i=1;i<n;i++)
    {
        int t1,t2;
        cin>>t1>>t2;
        g[t1].push_back(t2);
        g[t2].push_back(t1);
    }
    cout<<dp(1,-1)<<endl;
    return 0;
} 
```

---

## 作者：Drinkwater (赞：1)

这是一道非常经典的树P题，dp[i][0]表示 以i为父亲的子树不选i时能取得的最大利益，dp[i][j]相反，状态转移方程就是dp[i][0] += max(dp[j][0],dp[j][1]),j为i的儿子,dp[i][1] += dp[j][0];












```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
#define REP(i,a,b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++i)
typedef long long ll;
inline int read()
{
    char c = getchar();register int fg = 1, sum = 0;
    while(c < '0' || c > '9')
    {
        if(c == '-')fg = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    return fg * sum;
}
const int maxn = 20000;
int n,h[maxn];
int be[maxn],ne[maxn],to[maxn],e;
int dp[maxn][2],vis[maxn];
void add(int x,int y)
{
    to[++e] = y;
    ne[e] = be[x];
    be[x] = e;
}
void dfs(int x)
{
    vis[x] = 1;
    dp[x][1] = h[x];
    for(int i = be[x]; i; i = ne[i])
    {
        int v = to[i];
        if(!vis[v])
        {
            dfs(v);
            dp[x][0] += max(dp[v][0],dp[v][1]);
            dp[x][1] += dp[v][0];
        }
    }
}
int fa[maxn],root;
void find_root()
{
    int x = 1;
    while(fa[x])x = fa[x];
    root = x;
}
int main()
{
    n = read();
    REP(i,1,n)h[i] = read();
    int s,f;
    while(scanf("%d%d",&s,&f)!=EOF && s && f)
        add(f,s),add(s,f),fa[s] = f;
    find_root();
    dfs(root);
    int ans = max(dp[root][0],dp[root][1]);
    printf("%d\n",ans);
}

```

---

## 作者：littleming (赞：1)

//1ms
和楼下某人的核心代码差不多，但我建立一棵树（可能是一棵假的树），这样就不会被数据卡了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
int p[6008],f[6008][2];
int a[6008];
queue<int> q;
bool vis[6008],vis2[6008],ff[6008];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
        cin>>x>>y;
        p[x]=y;
        vis[x]=1;
        vis2[y]=1;
    }
    for(int i=1;i<=n;i++){
        if(!vis2[i]){
            q.push(i);
            ff[i]=1;
        }
    }
    while(!q.empty()){
        int top=q.front();q.pop();
        f[top][1]+=a[top];
        if(!p[top])    break;
        f[p[top]][0]+=max(f[top][0],f[top][1]);
        f[p[top]][1]+=f[top][0];
        if(!ff[p[top]]){
            ff[p[top]]=1;
            q.push(p[top]);
        }
    }
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            cout<<max(f[i][0],f[i][1]);
        }
    }
    return 0;    
}
```

---

## 作者：OIer991215 (赞：1)

看了下题解，果然没有人思路和我相同。

几乎所有人都把这题当成树形dp做了，但是我看到这题的第一反应是：广搜+拓扑（用动规的思想）？？

于是就写了下，然后耗时有点长，但是也过了。

所以我发表下我的代码，给大家创新一种思路，


我的思路是：找到所有入读为0的点，向上一层递推，递推的值为 选这个人/不选这个人。

也很容易得到 某个点的最大值：  来+子节点不来    和   不来+max（子节点不来，子节点来）；

于是就扫出了最后答案（最后答案一定是最后一个入读为0的点的值）


本题解是所有题解中的非主流，想学树形dp的最后看一下其他神犇们的题解；

如果想创新下思路，可以瞧瞧本蒟蒻的题解；



```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int n,x,y,ans,edge;
bool s[6060][6060];
int rudu[6000];
int come[6006];
int uncome[6006];
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
        scanf("%d",&come[i]);
    while(1)
    {
        scanf("%d%d",&x,&y);
        if(x==0&&y==0)
            break;
        s[x][y]=1;
        rudu[y]++;
        edge++;
    }
    while(edge>0)
        for(int i=1; i<=n; i++)
            if(rudu[i]==0)
                for(int j=1; j<=n; j++)
                    if(s[i][j]==1)
                    {
                        uncome[j]+=max(come[i],uncome[i]);
                        come[j]+=uncome[i];
                        ans=max(ans,max(uncome[j],come[j]));
                        s[i][j]=0;
                        rudu[j]--;
                        edge--;
                    }
    printf("%d",ans);
    return 0;
//    printf("单独某个点来的最大值\n");
//    for(int i=1; i<=n; i++)
//        cout<<come[i]<<endl;
//    cout<<endl;
//    printf("单独某个点不来的最大值\n");
//    for(int i=1; i<=n; i++)
//        cout<<uncome[i]<<endl;
}
```

---

## 作者：PauGasol (赞：1)

为什么一定要用动态规划呢，我就来写一个记忆化搜索。

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
int a[100001];
int n; 
vector<int> f[100001];//f[i].push_back(a)推入节点a,表示边由i出发通向a，f[i].size()表示i的出度。
int du[100001];
int dp[100001][2];
int dfs(int x,int y)//x当前节点，y=1，父亲已被选择，y=0，父亲没有被选择。
{
    if(f[x].size()==0)
    {
        if(y==1)return 0;
        else return max(0,a[x]);
    }
    if(y==1)//case 1
    {
        for(int i=0;i<f[x].size();i++)
        {
            dp[x][y]+=(dp[f[x][i]][0]?dp[f[x][i]][0]:dfs(f[x][i],0));
        }
    }
    if(y==0)//case 2
    {
        int p=0;
        for(int i=0;i<f[x].size();i++)
        {
            p+=(dp[f[x][i]][0]?dp[f[x][i]][0]:dfs(f[x][i],0));
        }
        int q=a[x];
        for(int i=0;i<f[x].size();i++)
        q+=(dp[f[x][i]][1]?dp[f[x][i]][1]:dfs(f[x][i],1));
        dp[x][y]=max(p,q);
    }
    return dp[x][y];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    int a,b;
    for(int i=1;i<=n-1;i++)
    {
        scanf("%d%d",&a,&b);
        f[b].push_back(a);
        du[a]++;
    }
    int i;//找根节点
    for(i=1;i<=n;i++)
    {
        if(!du[i])break;
    }
    cout<<dfs(i,0);
    return 0;
}
//搜索-》记忆化搜索-》动归，其中有些动归的复杂度和记忆化搜索差不大。
```

---

## 作者：Skywalker_David (赞：1)

这个应该是树DP的基础题

先把这个关系树建好，找到root根节点

每一个节点分两个最大值，一个是选这个节点的最大值，另一个是不选这个节点的最大值

我们用sum[x,0]表示不选这个节点的最大值，用sum[x,1]表示选这个节点的最大值

sum[x,0]等于它的儿子选或不选的最大值的和，sum[x,1]等于它的儿子的不选的最大值的和

递归求解，如果是叶子节点，sum[x,1]=happy[x],sum[x,0]=0

代码：

```delphi

Program p1352;
Var
    happy,f:array[0..6000]of longint;
    son:array[0..6000,0..1000]of longint;
    sum:array[0..6000,0..1]of longint;
    n,i,x,y,root:longint;

Function max(x,y:longint):longint;
Begin
    if x>y then exit(x);
    exit(y);
End;

Procedure getsum(x:longint);
Var
    i:longint;
Begin
    if son[x,0]=0 then begin
        sum[x,1]:=happy[x];
        exit;
    end;
    for i:=1 to son[x,0] do
        getsum(son[x,i]);
    for i:=1 to son[x,0] do
        inc(sum[x,1],sum[son[x,i],0]);
    for i:=1 to son[x,0] do
        inc(sum[x,0],max(sum[son[x,i],0],sum[son[x,i],1]));
    inc(sum[x,1],happy[x]);
End;

Begin
    readln(n);
    for i:=1 to n do
        read(happy[i]);
    for i:=1 to n-1 do begin
        readln(x,y);
        f[x]:=y;
        inc(son[y,0]);
        son[y,son[y,0]]:=x;
    end;
    for i:=1 to n do
        if f[i]=0 then break;
    root:=i;
    getsum(root);
    writeln(max(sum[root,1],sum[root,0]));
End.

```

---

## 作者：lych (赞：1)

本题是一道经典的树形动态规划，所以我们也用经典树形动态规划的思路与方法解决这道题目。

设a[i]表示编号为i的人的幽默值。

首先对于每一个人而言，状态只有两个，即去或者不去。如果是去，显然他的儿子（即题目中的下属），状态必定是不去。如果不去，那么儿子可以去，也可以不去，显然是选择二者中的更优者。所以任意一个点的最优值只和他的直接儿子相关，满足无后效性。那么如果一个点没有子节点，那么它去状态的值为a[i]，不去的状态值为0。

那么本题的思路已经十分明显了，所以主要的过程DP如下：

```delphi
procedure dp(x:longint);  
var  
  i:longint;  
begin  
  if s[x,0]=0 then  
    begin  
      f[x,0]:=0;  
      f[x,1]:=a[x];  
      exit;  
    end; //边界情况 
  f[x,1]:=a[x];  //去，那么首先增加幽默值a[x]
  //动态规划求解主过程，内存可以用链表优化，考虑到本题侧重点，此处不再陈述。
  for i:=1 to s[x,0] do  
    begin  
      dp(s[x,i]);  //求解子节点
      f[x,1]:=f[x,1]+f[s[x,i],0];  //取得情况，显然f[b,0]（1<=b<=n)不可能小于0
      f[x,0]:=f[x,0]+max(f[s[x,i],0],f[s[x,i],1]);  //取子节点两状态的较大者
    end;  
end; 
```
最后在主程序中找到根节点，调用dp(根节点编号)即可。

注意输出时要考虑两个状态中的较大者，因为不保证f[b,0]<f[b,1]


---

## 作者：诸神 (赞：1)

考前发个题解 但愿noip不会崩掉吧

--------------------------

明显的树形dp

对于每个人

dp[i][0/1]表示这个人不去或者去

那么dp方程就是

dp[p][1]+=dp[e[i].to][0];//他去他的下属就不能去 

dp[p][0]+=max(dp[e[i].to][1],dp[e[i].to][0]);//他不去他的下属可以选择去或者不去

---------

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=6010;
struct edge
{
    int to;
    int nxt;
};
edge e[maxn];
int n;
int cnt,head[maxn];
inline void add(int u,int v)
{
    e[++cnt].to=v;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
inline int read()
{
    int res=0,f=1;
    char c=getchar();
    while(!isdigit(c))
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c))
    {
        res=res*10+c-'0';
        c=getchar();
    }
    return f*res;
}
int fa[maxn];
int dp[maxn][2];//dp[i][0/1]表示第i个人不去/去 
bool vis[maxn];
inline void donggui(int p)
{
    vis[p]=1;
    for(int i=head[p];i;i=e[i].nxt)//遍历所有的下属 
    {
        if(!vis[e[i].to])
        {
            donggui(e[i].to);
            dp[p][1]+=dp[e[i].to][0];//他去他的下属就不能去 
            dp[p][0]+=max(dp[e[i].to][1],dp[e[i].to][0]);//他不去他的下属可以选择去或者不去 
        }
    }
}
int main()
{
    n=read();
    for(register int i=1;i<=n;i++) dp[i][1]=read();//只有他一个人的时候去的价值就是ri 
    for(register int i=1;i<n;i++)//上司 
    {
        int x,y;
        scanf("%d%d",&x,&y); 
        add(y,x);
        fa[x]=y;
    }
    int s;//根节点 
    for(register int i=1;i<=n;i++) if(fa[i]==0){ s=i; break; }
    donggui(s);//从根往下算 
    int ans=max(dp[s][0],dp[s][1]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：江之永矣 (赞：1)

这题的思路其他神犇讲得很清楚了，我不说，主要讲两个实用技巧。

第一、可能会有很多人没有上司，可以给他们设置一个共同的虚拟上司，然后答案就是虚拟上司不去的dp值

第二、一些树形dp题结点数量很多，可能会爆栈（这题不会）。解决方法之一是利用树形dp更新一个结点dp值时要保证子树上所有结点的dp值都已经计算出来了的特性。这个特性导致了越深的结点的dp值越先计算出来，那么我们就可以从根开始做一遍BFS，然后从队列终点向起点取点开始dp（从树上看是从叶子开始取点），这样既可以保证不会爆栈（因为没调用系统栈），也可以保证一个点的dp值在计算时其子树上的dp值已经计算完了


---

## 作者：bcku1 (赞：1)


 



```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N=6001;
int n,root;
int f[N][2];
int fa[N]={0},son[N]={0},brother[N]={0},rating[N];
void init()
{int i,a,b;
 memset(f,0,sizeof(f));
 scanf("%d",&n);
 for (i=1;i<=n;i++)
   scanf("%d",&rating[i]);//搞笑指数 
 while (1)
   {scanf("%d %d",&a,&b);
    if (a==0) break;
    fa[a]=b;//a的父结点是b 
    brother[a]=son[b];//a的兄弟结点是b的孩子结点 
    son[b]=a;//b的孩子结点换为a 
   }
 root=1; 
 while (fa[root]!=0)//找到整个树的根结点 
   root=fa[root];
} 
void dfs(int k)
{int i;
 if (son[k]==0)//叶子结点 
   {f[k][1]=rating[k];
    return;
   }
 for (i=son[k];i!=0;i=brother[i])
   dfs(i);
 f[k][1]=rating[k];
 for (i=son[k];i!=0;i=brother[i])
   {f[k][1]+=f[i][0];//结点k参加，则其孩子结点都不参加 
    f[k][0]+=max(f[i][1],f[i][0]);//结点k不参加，则其孩子结点可以参加也可以不参加 
   }
} 
int main()
{freopen("party.in","r",stdin);
 freopen("party.out","w",stdout);
 init();
 dfs(root);
 printf("%d\n",max(f[root][1],f[root][0]));
 return 0;
}
```

---

## 作者：Coco_T (赞：1)





```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,i,j,k,m;
int son[6001][1001],f[6001][2],fa[6001];  //f[i][0]表示不选i时的状态，f[i][1]表示选i时的状态
int a[6001],maxx=0;
int doit(int t)  //dp主体
{
         int i,j,k;
         if (son[t][0]==0)  //如果当前结点没有儿子，就进行边界状态的处理
    {
            f[t][0]=0;
            f[t][1]=a[t];
            return 0;
    }
       f[t][1]=a[t];  //先加上当前节点的值
     for (i=1;i<=son[t][0];i++)
    {
             doit(son[t][i]);  //把子节点都dp一遍
             f[t][1]+=f[son[t][i]][0];  //如果选当前节点，就加上他儿子不选时的值
             f[t][0]+=max(f[son[t][i]][1],f[son[t][i]][0]);  //如果不选，就分两种情况，他每一个的儿子可以选也可以不选，选一个大的累加
    }
}
int main()
{
       int u,v;
       scanf("%d",&n);
       memset(f,0,sizeof(f));
       memset(fa,0,sizeof(fa));
       memset(son,0,sizeof(son));
       for (i=1;i<=n;i++)  
       {
            scanf("%d",&a[i]);
    }
        scanf("%d%d",&u,&v);
        while (u&&v)
        {
                son[v][0]++;   //既存儿子也存爸爸
                son[v][son[v][0]]=u;
                fa[u]=v;
                scanf("%d%d",&u,&v);
       }
      for (i=1;i<=n;i++)
      {
               if (fa[i]==0)  //找根
          {
                  doit(i);   //从根开始做dp
              break;
           }
       }
       for (i=1;i<=n;i++)  //查找最大值
       {
                maxx=max(maxx,f[i][0]);
                maxx=max(maxx,f[i][1]);
        }
        printf("%d",maxx);
        return 0;
}
```

---

## 作者：GoPoux4 (赞：0)

**关于树形DP**

顾名思义，树形DP就是在树上所做的动态规划。

 _——摘自老师的PPT_ 
 
 

------------

luogu [P1352 没有上司的舞会](https://www.luogu.org/problem/P1352)

**题目描述**

   _某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。_

 _思路：_ 把数据转换成树，再做DP
 
 由于每个人的来与不来都会被他的直属上司（父结点）影响，同时也会影响他的下属（子结点）（除叶结点），所以定义一个二维数组**f[i][p]** （表示第i个结点的状态为p（0为不去，1为去）时最大的快乐值)
 
找到叶结点并附初值**f[i][0]=0,f[i][1]=r[i] (当前结点的快乐值)** 标记此状态已访问：**vis[i][0]=vis[i][1]=true** 避免重复访问而爆栈

 _~~然后就是快乐的dp了~~_ 

**实现方法：DFS（深度优先搜索）**

找到一个结点并且它的f值没有被计算

如果这个人不去，即p==0，则

```cpp
for(int j=1;j<=son[i][0];j++)
{
	f[i][p]+=max(work(son[i][j],0),work(son[i][j],1));
}
```
这个人不去，那么他的下属**可去可不去**，就在每个下属的去与不去两种情况中选择最大值累加到父结点的f值去

如果这个人去，即p==1,则

```cpp
for(int j=1;j<=son[i][0];j++)
{
	f[i][p]+=work(son[i][j],0);
}
f[i][p]+=r[i];
```

这个人去，那么他的下属只能不去，就将每个下属不去的情况累加到f中。注意：累加完后还要加上自己的快乐值，因为这个人去了

**上面的就是主要程序，还有一些细节在程序里有提示**

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,r[6005],son[6005][6005],l,k；
int ans=-0x3f3f3f3f；//注：ans要赋极小值，因为快乐值有负值
int f[6005][2];
bool vis[6005][2];

int work(int i,int p)
{
	if(vis[i][p]) return f[i][p];//记忆化搜索
	vis[i][p]=true;//这里要标记状态被访问过，否则会重复搜索而爆栈
	if(p==0)
	{
		for(int j=1;j<=son[i][0];j++)
		{
			f[i][p]+=max(work(son[i][j],0),work(son[i][j],1));
		}
	}
	else if(p==1)
	{
		for(int j=1;j<=son[i][0];j++)
		{
			f[i][p]+=work(son[i][j],0);
		}
		f[i][p]+=r[i];
	}
	return f[i][p];
}

int main()
{
	//freopen("P1352.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&r[i]);
	}
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&l,&k);
		son[k][++son[k][0]]=l;//son[k][0]记录下属（子结点个数）
	}
	scanf("0 0\n");//不知道为什么要输入0 0，其实for循环已可以读入所有数据并结束输入
	for(int i=1;i<=n;i++)
	{
		if(son[i][0]==0)//寻找子结点
		{
			f[i][0]=0;
			f[i][1]=r[i];
			vis[i][0]=vis[i][1]=true;
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,max(work(i,0),work(i,1)));//更新答案
	}
	printf("%d",ans);
	return 0;

}
```



------------

**方法二**

来自我校大佬的博客
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,r[6005],root,head[6005],f[6005][2];

vector<int> son[6005];

void dfs(int node)
{
	f[node][0]=0;
	f[node][1]=r[node];
	for(int i=0;i<son[node].size();i++)
	{
		int j=son[node][i];
		dfs(j);
		f[node][0]+=max(f[j][0],f[j][1]);
		f[node][1]+=f[j][0];
	}
}

int main()
{
	//freopen("P1352.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&r[i]);
	for(int i=1;i<n;i++)
	{
		int l,k;
		scanf("%d%d",&l,&k);
		son[k].push_back(l);
		head[l]=true;
	}
	int a,b;
	scanf("%d %d",&a,&b);
	for(int i=1;i<=n;i++)
	{
		if(!head[i])//找根节点进行递归
		{
			root=i;
			break;
		}
	}
	dfs(root);
	printf("%d",max(f[root][0],f[root][1]));
	return 0;
}
```



附：[我的博客](https://www.luogu.org/blog/hhwkksk/)

---

## 作者：jins3599 (赞：0)

## 思路

非常水的一道树形dp，以至于几乎从来不会写树形dp的我都一遍A了..

我们考虑到每个人的状态只有去和不去，那么我们可以设计状态如下：

`f[i][0]` 代表这个人不去参加舞会

`f[i][1]` 代表这个人去参加舞会

我们考虑叶子节点的状态是可以直接初始化的，因此我们可以从**叶子到根**进行dp。

转移方程就很好想了。

设v是i的下一个结点

`f[i][0] += max(f[v][1] , f[v][0]);`

`f[i][1] += f[v][0];`

在回溯的时候进行处理即可。

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn = 10000;

struct Edge {
    int to , nxt;
}e[maxn << 1];
int n , a[maxn];
int head[maxn] , cnt , ind[maxn] , root , f[maxn][2];

void add(int u , int v) {
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}

void dfs(int now) {
    for(int i = head[now] ; i ; i = e[i].nxt) {
        int v = e[i].to;
        dfs(v);
        f[now][0] += max(f[v][0] , f[v][1]);
        f[now][1] += f[v][0];
    }
}

int main () {
    cin >> n;
    for(int i = 1 ; i <= n ; ++ i) cin >> a[i] , f[i][1] = a[i];
    for(int i = 1 ; i < n ; ++ i) {
        int u , v; cin >> u >> v;
        add(v , u); ind[u] ++;
    } 
    for(int i = 1 ; i <= n ; ++ i) if(!ind[i]) root = i;
    dfs(root);
    cout << max(f[root][0] , f[root][1]);
    return 0;
}
```

---

## 作者：lemir3 (赞：0)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11062974.html)

因为想到这道题是树形DP的入门,而且我也总结到了这道题,于是把这篇文章发在这里,希望能帮到一些像我之前一样对树形DP摸不着头脑的新人.

最近做了很多树形DP的题呼,来总结一下.

希望以此增加全世界人民对树形DP的了解.

大概就是3种题型:

#树上取点集的最值

代表题[*P1352 没有上司的舞会*](https://www.luogu.org/problemnew/show/P1352)

每一个节点会影响与他相关的节点,所以说决策就很简单了,这个节点选或不选.

在选或不选的情况下,再加上对相关节点的影响.

状态转移方程如下:

```cpp

dp[x][0]+=max(dp[y][0],dp[y][1]);
dp[x][1]+=dp[y][0];

```

在转移之前,先要向下递归他的儿子.

P1352的代码:

```cpp

#include<bits/stdc++.h>

using namespace std;

vector<int>fas[10010];

int n,root;
int happy[10010],dp[10010][2];
bool head[10010];

void dg(int);

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",happy+i);
	}
	for(int i=1;i<=n-1;i++)
	{
		int father,son;
		scanf("%d%d",&son,&father);
		fas[father].push_back(son);
		head[son]=true;
	}
	int a,b;
	scanf("%d%d",&a,&b);
	for(int i=1;i<=n;i++)
	{
		if(head[i]==false)
		{
			root=i;
			break;
		}
	}
	dg(root);
	printf("%d",max(dp[root][1],dp[root][0]));
return 0;
}

void dg(int x)
{
	dp[x][0]=0;
	dp[x][1]=happy[x];
	for(int i=0;i<fas[x].size();i++)
	{
		int y=fas[x][i];
		dg(y);
		dp[x][0]+=max(dp[y][0],dp[y][1]);
		dp[x][1]+=dp[y][0];
	}
}

```

#树上背包

代表题[*P2015 二叉苹果树*](https://www.luogu.org/problemnew/show/P2015)

P2014也很经典,只不过我是用多叉转二叉来写的.

其实便是加上的点的数量限制的上一种题型.

上一种是直接做出抉择就好了,这一种就要加上一个背包,来做出当前节点下能用最大背包容量获得的最值.

背包的过程如下:

```cpp

for(int j=q;j>=1;j--)
			for(int k=j-1;k>=0;k--)
				dp[root][j]=max(dp[root][j],apple[root][to]+dp[root][j-k-1]+dp[to][k]);

```

P2015的代码:

```cpp

#include<bits/stdc++.h>

using namespace std;

vector<int>tree[110];

int n,q;
int apple[110][110],dp[110][110];
bool falg[110];

void dfs(int);

int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n-1;i++)
	{
		int a,b,val;
		scanf("%d%d%d",&a,&b,&val);
		tree[a].push_back(b);
		tree[b].push_back(a);
		apple[a][b]=val;
		apple[b][a]=val;
	}
	dfs(1);
	printf("%d",dp[1][q]);
return 0;
}

void dfs(int root)
{
	falg[root]=true;
	for(int i=0;i<tree[root].size();i++)
	{
		int to=tree[root][i];
		if(falg[to]==true)continue;
		falg[to]=true;
		dfs(to);
		for(int j=q;j>=1;j--)
			for(int k=j-1;k>=0;k--)
				dp[root][j]=max(dp[root][j],apple[root][to]+dp[root][j-k-1]+dp[to][k]);
	}
}

```

#子树的最值

代表题[P1122 最大子树和](https://www.luogu.org/problemnew/show/P1122)

这类题一般是没有固定的根节点的,意为可以子树可以以任意一个节点作为根.

而且儿子与父亲的界限一般不明确(因为给出的是连接节点的边),要用前向星双向建边.

加个标记防止往回走罢.

DP数组代表着以当前节点为根的子树的最值.

DP数组附初值为节点的权值.

每一个节点向下递归,然后回溯时该节点累加上子节点.

子节点的DP值小于0(求最大值)或者大于0(求最小值)的话就不累加了.

P1122的代码:

```cpp

#include<bits/stdc++.h>

using namespace std;

vector<int>tree[16010];

int n,ans=-2147483647;
int num[16010],dp[16010];

void dfs(int,int);

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",num+i);
	for(int i=1;i<=n-1;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		tree[a].push_back(b);
		tree[b].push_back(a);
	}
	dfs(1,0);
	printf("%d",ans);
return 0;
}

void dfs(int root,int hisfather)
{
	dp[root]=num[root];
	for(int i=0;i<tree[root].size();i++)
	{
		int to=tree[root][i];
		if(to==hisfather)continue;
		dfs(to,root);
		dp[root]+=max(0,dp[to]);
	}
	ans=dp[root]>ans?dp[root]:ans;
}

```

我本人见过的树形DP也就上面几种,以后遇到别的还会补充.


---

## 作者：破忆 (赞：0)

### 题目大意
在一棵树上找一些两两不相邻的点，使这些点的点权和最大


------------
### 解法

对于每个点，只有两种选择，选或者不选

如果选了，那么它的所有子节点都不能选

如果没选，那么它的所有子节点可以选也可以不选

这就是**树形DP**的基本模型

那么我们设f[i][0]，和f[i][1]两种状态

f[i][0]表示不选择节点i，其子树的最优解

f[i][1]表示选择节点i，其子树的最优解

根据之前的推导，转移方程如下（son表示i的子节点）

f[i][0]+=max(f[son][0],f[son][1])

f[i][1]+=f[son][1]


f[i][1]还要加上点权

注意在处理i之前，应该先处理son，写个递归就好

------------
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6e3+5;
int n,a[maxn],f[maxn][2],rot;
int tot,son[maxn],nxt[maxn],lnk[maxn];
bool vis[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void add_e(int x,int y){          //邻接表存图
	son[++tot]=y,nxt[tot]=lnk[x],lnk[x]=tot;
}
void DP(int x){
	f[x][1]=a[x];//先加上点权
	for(int j=lnk[x];j;j=nxt[j]){
		DP(son[j]);//递归处理子节点
		f[x][1]+=f[son[j]][0];
		f[x][0]+=max(f[son[j]][0],f[son[j]][1]); 
	}
}
int main(){
// 	freopen("P1352.in","r",stdin);
// 	freopen("P1352.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		add_e(y,x);
		vis[x]=1;
	}
	for(rot=1;vis[rot];rot++);  //找树根，树根唯一
	DP(rot);
	printf("%d\n",max(f[rot][0],f[rot][1]));
	return 0;
}
```


---

## 作者：龟龟我的龟龟 (赞：0)

数据结构苦手

由于树里感觉最亲切的就是二叉树，所以这道题我转成了二叉树

数据结构选择好，一处理数据直接dfs就可以了

关于dp数组选择：

		dp[maxn][2]
        
        一行存去的最大快乐值
        
        一行存不去的最大快乐值
        
        一棵子树的两个值dp[root][0][root][1]均由它的儿子转化来，具体dp方程（大雾）：
        
        dp[root][0] = dp[child1][1] + ... +dp[childEnd];//毕竟老板去直接下属不去
        
        dp[root][1] = max( dp[child1][0], dp[child1][1]) + ... + max( dp[childEnd][0], dp[childEnd][1]) + HAPPY[root];//老板去了下属可去可不去//老板也要快乐~
        
最后附上代码：
```cpp
#include<iostream>
#include<algorithm>
#define Max 6050
using namespace std;
struct worker{
	int happy;
	int child;
	int brother;
	worker() :happy(0), brother(0), child(0) {}
};
int dp[Max][2]{ -1 };//dp[i][0]为i员工不去晚会
worker a[Max];
void dfs(int root);
int main() {
	int n,l = 1,k = 1, sum = 0;
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> a[i].happy;
	while (l||k){//l的老板是k
		cin >> l >> k;
		int p = a[k].child;//这里使用孩子兄弟表示法创建二叉树//l为k的子节点
		if (!p) a[k].child = l;//如果k没有儿子，则l作为k的儿子
		else while (1) { if (!a[p].brother) { a[p].brother = l; break; }p = a[p].brother; }//k有儿子，则调查兄弟
	}
	for (int i = 1; i <= n; ++i) { dfs(i); sum = max(sum, dp[i][0]); sum = max(sum, dp[i][1]); }//对每个节点进行dfs填充dp数组
	cout << sum;
	return 0;
}
void dfs(int root){
	if (!root)return;//root==0直接返回
	if (!~dp[root][0]&&!dp[root][0]) return;//如果dp数组被填充过，则直接返回
	if (!a[root].child) { dp[root][1] = a[root].happy; dp[root][0] = 0; return; }//如果是叶子节点，则直接填充
	dp[root][1] = dp[root][0] = 0;//标记-1该消除了
	for (int p = a[root].child; p; p = a[p].brother) {
		dfs(p);
		dp[root][1] += dp[p][0];//老板去直接下属肯定不去
		dp[root][0] += max(dp[p][0], dp[p][1]);//老板去下属可去可不去
	}
	dp[root][1] += a[root].happy;//别忘老板也要快乐~
}
```

友情提示，有暗改，不要抄

---

## 作者：混沌 (赞：0)

数据之水.......最开始用了错误代码都A了...

错误代码:





```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n;//6010
int v[6010];
int s[6010][6010];
int num[6010];
int dp[6010][2];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&v[i]);
    for(int i=1;i<=n-1;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        num[y]++;
        s[y][num[y]]=x;
    }
    for(int i=1;i<=n;i++) dp[i][1]=v[i];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=num[i];j++){
            dp[i][0]+=max(dp[s[i][j]][0],dp[s[i][j]][1]);
            dp[i][1]+=dp[s[i][j]][0];
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=1;j++){
            ans=max(ans,dp[i][j]);
        }
    }
    printf("%d",ans);
    return 0;
}
```
很显然这是错的 比如
8
1
1
2
1
1
1
1
3
1 5
2 1
3 1
8 3
6 4
7 4
4 5
0 0
这组数据就能证明

正确代码:









```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n;//6010
int st=0;//统计边
int ind[6010];//入度
int v[6010];//值
int s[6010][6010];//每个点的每一个下属
int num[6010];//边的数
int dep[6010];//深度
int head[6010];
int dp[6010][2];//0表示不取这个点 1表示要取
struct add{
    int t,T;
}node[6010];
struct ccc{
    int next,to;
}edge[6010];
void kkk(int from,int to){
    edge[++st].next=head[from];
    edge[st].to=to;
    head[from]=st;
}
bool comp(add x,add y){
    return x.t>y.t;
}
void dfs(int u){
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;
        dep[v]=dep[u]+1;
        dfs(v);
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&v[i]);
    for(int i=1;i<=n-1;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        num[y]++;
        s[y][num[y]]=x;//记录每个点的父亲（就是上司）
        ind[x]++;//记录入度用来找出根节点
        kkk(y,x);//加边
    }
    for(int i=1;i<=n;i++){
        if(ind[i]==0){
            dfs(i);//为每一个节点附上一个深度
            break;
        }
    }
    for(int i=1;i<=n;i++){
        node[i].T=i;
        node[i].t=dep[i];
    }
    sort(node+1,node+1+n,comp);//以深度为标准 让下面（深度深）的点在前面
    for(int i=1;i<=n;i++) dp[i][1]=v[i];//初始赋值
    for(int ii=1;ii<=n;ii++){
        int i=node[ii].T;//从最深的点开始状态转移 也是和错误代码最大的区别
        for(int j=1;j<=num[i];j++){
            dp[i][0]+=max(dp[s[i][j]][0],dp[s[i][j]][1]);//这个点不取的话 就是它所有下属的最大状态之和
            dp[i][1]+=dp[s[i][j]][0];//这个点取那它的下属一定不会取 直接加上即可
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=1;j++){
            ans=max(ans,dp[i][j]);//求出最大值
        }
    }
    printf("%d",ans);
    return 0;
}
```

---


# 算式

## 题目描述

给出 $n$ 个数字，不改变它们的相对位置，在中间加入 $k$ 个乘号和 $(n-k-1)$ 个加号，括号随便加，使最终结果尽量大。因为乘号和加号一共就是 $n-1$ 个了，所以恰好每两个相邻数字之间都有一个符号。例如：

$n=5$，$k=2$，$5$ 个数字分别为 $1$，$2$，$3$，$4$，$5$，可以加成：

$$1\times 2\times(3+4+5)=24$$
$$1\times(2+3)\times(4+5)=45$$
$$(1\times2+3)\times(4+5)=45$$
$$\ldots\ldots$$

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $2\le n\le15$，$0\le k\lt n$，$0 \leq a_i \leq 9$，答案小于 $2^{31}$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
```

### 输出

```
120
```

# 题解

## 作者：nothingness (赞：23)

## 第一篇正确的c++题解

**题外话:本人提供了hack数据(第11组)后原来的4篇题解有3篇是不能AC的**,~~我来发一下自认为比较合理的代码~~


------------

正题:

首先,这题是**区间dp**; 其次, $n=15$ 的数据告诉我们这题**其实可以暴力枚举乘号的位置**, 然后,然后就能做了......

(我个人认为 "用 $f[i][j]$ 表示前 $i$ 个数插 $j$ 个乘号的最优解" 会更好,但是如果用这样的方法都有反例,会被hack掉,但是笔者的水平有限,没有发现这种方法的问题所在,请发现问题或者有更优解的读者通过私信我的方式或在旁边评论进行斧正,谢谢)


------------

还有,我觉得第7个点的正确答案是5040,但是答案却是252(开始是0,后来变成了252),不知道是我的问题还是数据的锅,欢迎各位读者前来探讨(本文发布于2018.6.17,文章采用此时数据)


------------


## Code
```cpp
#include "bits/stdc++.h"
#define cal(x,y,t) (t==1?x+y:x*y)//根据xy之间的符号进行计算
#define ll long long
using namespace std;

ll ans=-1,f[16][16];//f[i][j]表示第i个数到第j个数的最大值
int n,k,s[15],a[16];
//s[i]标记符号,若为1,表示a[i]和a[i+1]之间为加号,为2则是乘号

ll dp()//确定所有符号后dp求最值
{
	for(int i=1;i<=n;i++)
		f[i][i]=a[i];//初始化
	int j;
    //区间dp模板
	for(int l=1;l<=n;l++)//长度
		for(int i=1;i+l-1<=n;i++)//左端点
		{
			j=i+l-1;//右端点
			for(int k=i;k<j;k++)
				f[i][j]=max(f[i][j],cal(f[i][k],f[k+1][j],s[k]));
                //取原数或合并后的数的较大值
		}
	return f[1][n];//f[1][n]即为所求的一个解
}

int dfs(int x,int t1,int t2)//深搜确定乘号位置
{
	if(x==n)
	{
		memset(f,0,sizeof(f));//多次判断,记得清空数组
		ans=max(ans,dp());
		return 0;
	}
    //其实一个参数就够了,笔者这里还可以优化,不过这样方便理解
	if(t1<k)//枚举乘号
	{
		s[x]=2;
		dfs(x+1,t1+1,t2);
	}
	if(t2<n-k-1)//枚举加号
	{
		s[x]=1;
		dfs(x+1,t1,t2+1);
	}
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	dfs(1,0,0);//深搜确乘号位置
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Eternal_Blue (赞：18)

# 如果题解有任何错误，请私信我
## 思路
__蒟蒻我认为这一题很难__ 

这题普遍有两种思路

第一种是dp第$i$个点前面有$j$个$*$号的时候最大的值是多少
这个状态可以由含有$q$个$*$的区间A和含有$j-q-1$个$*$的区间B相乘得到，或者由含有$j$个$*$的区间A和含有``0``个$*$的区间B相加得到。
也就是$$f_{i,j}= \max{\{ \max_{k=j}^{i-1}{\{f_{k,j-1} * \sum_{q=k+1}^{i}{a_{q}}\}}, \max_{k=j+1}^{i-1}{\{f_{k,j} + \sum_{q=k+1}^{i}{a_{q}}\}}\}}$$
代码如下
```cpp
for(j=1;j<=m;j++){
    for(i=j+1;i<=n;i++){
        for(k=j;k<i;k++){
            f[i][j]=max(f[i][j],f[k][j-1]*(sum[i]-sum[k]));
            if(k>=j+1) f[i][j]=max(f[i][j],f[k][j]+sum[i]-sum[k]);
        }
    }
}
//sum是前缀和
```
但是这样的代码在洛谷上提交只能得81分，o(╥﹏╥)o
可以发现如下数据可以卡掉这个程序:

``5 2``

``0 0 1 0 0``

为了处理这种情况，我发现可以有一种贪心，遇到连续的``0``的时候就默认把一个$*$插到两个``0``中间，就像这样:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 51
typedef long long int lli;
lli f[MAXN][MAXN];
int nums[MAXN],sum[MAXN];
int i,j,k,m,n,r,t;
bool flag;
int main(){
    scanf("%d%d",&n,&m);
    flag=false;
    for(i=1;i<=n;i++) {
        scanf("%d",nums+i);
        if(nums[i]==0){
            if(!flag){
                flag=true;
            }else{
                i--;
                n--;
                m--;
            }
        }else{
            flag=false;
        }
    }
    sum[0]=0;
    for(i=1;i<=n;i++) sum[i]=sum[i-1]+nums[i];
    for(i=1;i<=n;i++) f[i][0]=sum[i];
    for(j=1;j<=m;j++){
        for(i=j+1;i<=n;i++){
            for(k=1;k<i;k++){
                f[i][j]=max(f[i][j],f[k][j-1]*(sum[i]-sum[k]));
                if(k>=j+1) f[i][j]=max(f[i][j],f[k][j]+sum[i]-sum[k]);
            }
        }
    }
    printf("%lld\n",f[n][m]);
    return 0;
}
```
可是很遗憾，我们提交这一份代码，会发现还是被卡掉了一个点。可惜我并不知道这个点的数据~~~

#### 现在说第二种做法，就是可以正常AC这道题的做法####
观察这道题目，你会发现这题有一点区间dp的意思，因为加括号并用乘法合并正好符合区间dp的性质，只是有一点限制，那就是区间的个数有限
怎么办？我们观察到这题的数据规模很小，那不妨再个dp的数组再加一个维度，变成这样：
$f_{i,j,p}$表示区间$[i,j]$中分成$p$个块时，区间$[i,j]$在合并后的最大值！
转移方程如下:
$$f_{i,j,p} = \max_{k=i}^{j-1}{\{\{\max_{q=max{\{p-(j-k),0\}}}^{\min{\{k-i,p\}}}{f_{i,k,q}*f_{k+1,j,p-q-1}} \},\{\max_{max{\{p-(j-k)+1,0\}}}^{\min{\{k-i,p\}}}{f_{i,k,q}+f_{k+1,j,p-q}}\}\}}$$

看公式不容易理解，代码比较直观
```cpp
for(p=1;p<=m;p++)                 //枚举区间内的括号块的个数
	for(r=p+1;r<=n;r++)           //枚举区间的宽度
		for(i=1;i+r-1<=n;i++){    //枚举左端点
			j=i+r-1;              //求出右端点
			for(k=i;k<j;k++)      //枚举区间dp中间点
				for(q=0;q<k-i+1&&q<p&&p-q-1<j-k;q++){//这一个循环其实我认为有点问题，下文会说   
				                  //枚举左侧区间中括号块的个数
                                  
					f[i][j][p]=max(f[i][j][p],f[i][k][q]*f[k+1][j][p-q-1]);
					if(p-q<j-k) f[i][j][p]=max(f[i][j][p],f[i][k][q]+f[k+1][j][p-q]);
				}
		}
```

## 接着是能AC的代码
## ~~然而我认为能AC的代码是错的~~
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 51
typedef long long int lli;
lli f[MAXN][MAXN][MAXN];
int nums[MAXN],sum[MAXN];
int i,j,k,m,n,r,t,p,q;
int main(){
#ifndef ONLINE_JUDGE
	freopen("bigexp.in","r",stdin);
	freopen("bigexp.out","w",stdout);
#endif
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++) {
		scanf("%d",nums+i);
	}
	sum[0]=0;
	for(i=1;i<=n;i++) sum[i]=sum[i-1]+nums[i];
	for(i=1;i<=n;i++)
		for(j=i;j<=n;j++) f[i][j][0]=sum[j]-sum[i-1];
	for(p=1;p<=m;p++){
		for(r=p+1;r<=n;r++){
			for(i=1;i+r-1<=n;i++){
				j=i+r-1;
				for(k=i;k<j;k++){
					for(q=0;q<k-i+1&&q<p&&p-q-1<j-k;q++){//我认为这一行并不是很正确
						f[i][j][p]=max(f[i][j][p],f[i][k][q]*f[k+1][j][p-q-1]);
						if(p-q<j-k) f[i][j][p]=max(f[i][j][p],f[i][k][q]+f[k+1][j][p-q]);
					}
				}
			}
		}
	}
	printf("%lld\n",f[1][n][m]);
	return 0;
}
```
## 可是我认为这个代码其实并不是正确的

经过和91分的代码对拍，我发现了这样一组数据

``7 5``

``4 0 9 0 0 8 2 
``

没有AC的朋友们可以看看，答案我没算错的话应该是64吧(4+0*9*0*0)*(8*2)=64，但是你们会惊奇地发现AC的代码输出了4，因此我认为这道题7号数据有锅。所以大家也无需过于纠结。
## 放上我认为正确的程序
```cpp
for(p=1;p<=m;p++)
    for(r=p+1;r<=n;r++)
        for(i=1;i+r-1<=n;i++){
            j=i+r-1;
            for(k=i;k<j;k++)
                for(q=max(p-(j-k),0);q<=min(k-i,p);q++){       //就是这一行和之前的程序不一样
                    f[i][j][p]=max(f[i][j][p],f[i][k][q]*f[k+1][j][p-q-1]);
                    if(p-q<j-k) f[i][j][p]=max(f[i][j][p],f[i][k][q]+f[k+1][j][p-q]);
                }
        }
```


---

## 作者：Shallowy (赞：6)

~~又臭又长的题解希望大家能耐心看完...~~

orz dalao hack数据太强辣

一开始我也是用**f [ i ] [ j ]表示前 i 个数中插入 j 个乘号的最大值**并**n^3**转移，草草地A掉了这道黄题...

不过下面似乎没有提出hack数据的问题在哪里...这里我再作个补充吧。

其实在一般情况下，前面的状态和转移方程是可以的，即：

### -----**f [ i ][ j ]=Max(f [ i ][ j ],f [ k ][ j-1 ] * s [ k+1 ] [ i ])**

也就是说，我们每次总是找一个位置k来插入一个乘号，用1~k中插k-1个乘号的最优解去**乘**上k+1~i这一段的**和**来更新，看上去没有问题。

可是在hack数据里，乘号并不能通过这样的方法得到。

**最大值=1+1×0×0×0，**

它是由前面的一段**和**与后面的一段**积 加**起来得到的！

------------

![](http://a1.qpic.cn/psb?/V10Cnxsq3A6dvO/aVjO0y422yVl10vwrkYbe2jsyG77HU.5oMuiOBNtWi4!/b/dEABAAAAAAAA&ek=1&kp=1&pt=0&bo=gASIAgAAAAADFzw!&tl=1&vuin=2533136630&tm=1532692800&sce=60-2-2&rf=viewer_4)

如图，记三段数各自的和为a,b,c。

这也就等价于：

在之前的dp中，我们一直用(a+b)×c来更新这整段的答案，而:

**(a+b)×c>=a+b×c**

所以在正常情况下，这是可以的。

但是，如果c=0且a>0，上式就不成立了。这也就是我们的hack数据能hack的原因。此时的最优策略应为a+b×c.

~~只要没有0，前面的dp就是正确的。~~

然后另外说一下，n<=15的数据保证我们能放肆地挥霍时间...

然后就出来了**5重循环**的**区间dp**...

我们用**f [ i ][ j ][ k ]表示i~j这一段中插k个乘号的最大值**，转移时枚举一个**断点**和**乘号个数**，由长度较小的两段区间转移过来。

具体见代码：


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#define il inline
#define vd void
#define rep(i,x,y) for(register int i=x;i<=y;++i)
#define drp(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
const int Len=2333333;
char buf[Len],*p1=buf,*p2=buf,duf[Len],*q1=duf;
il char gc(); il int rd(); il vd pc(char c); il vd rt(int x); il vd flush();
int n,K,a[20],s[20],f[20][20][20];
template<class T> il T Max(T a,T b){return a>b?a:b;}
template<class T> il T Min(T a,T b){return a<b?a:b;}
int main(){
    n=rd(),K=rd();
    rep(i,1,n) f[i][i][0]=a[i]=rd();
    rep(i,1,n) rep(j,i+1,n) f[i][j][0]=f[i][j-1][0]+a[j]; //预先处理出没有乘号，即全为加号的答案
    rep(l,2,n) rep(i,1,n-l+1){ //l为区间长度，i为起始端点
        int j=i+l-1; //j为终止端点
        rep(k,1,Min(K,l-1)){ //共有k个乘号
        //这里c为左边一部分的乘号数
            rep(c,0,k) rep(t,i+c,j-k+c-1) f[i][j][k]=Max(f[i][j][k],f[i][t][c]+f[t+1][j][k-c]); //左边+右边，此时它们共有k个乘号
            rep(c,0,k-1) rep(t,i+c,j-k+c) f[i][j][k]=Max(f[i][j][k],f[i][t][c]*f[t+1][j][k-1-c]); //左边*右边，此时由于中间需要一个乘号，故它们共只有k-1个乘号
        }
    }
    rt(f[1][n][K]);
    return flush(),0;
}
// 下面为读优输优
il char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,Len,stdin),p1==p2)?-1:*p1++;}
il int rd(){char c; int f=1;
    while(!isdigit(c=gc())&&c!='-');
    c=='-'?f=-1,c=gc():0; int x=c^48;
    while(isdigit(c=gc())) x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}
il vd pc(char c){q1==duf+Len&&fwrite(q1=duf,1,Len,stdout),*q1++=c;}
il vd rt(int x){x<0?pc('-'),x=-x:0,pc((x>=10?rt(x/10),x%10:x)+48);}
il vd flush(){fwrite(duf,1,q1-duf,stdout);}
```

还有一个就是关于第7个点，同下面的dalao，我也是5040，不知道是思想错误，代码有错还是数据有误...

---

## 作者：Skywalker_David (赞：6)

虽然是N^4 还是n^5的 我也不知道 但是0MSAC了


```cpp
var
    f:array[0..100,0..100,0..100] of longint;
    a:array[1..100] of longint;
    i,j,n,m,k:longint;

function min(a,b:longint):longint;
begin
    if a>b then exit(b) 
        else exit(a);
end;

function max(a,b:longint):longint;
begin
    if a>b then exit(a) 
        else exit(b);
end;

procedure mdfs(x,y,z:longint);
var
    i,j,t:longint;
begin
    if f[x,y,z]<>-1 then exit;//记忆化
    if (x=y)and(z=0) then//当这种情况 也就是自身的时候那么直接把值付给F数组
    begin //X,Y,Z分别表示第X个数到第Y个数插入Z个乘号的最大值
            f[x,y,z]:=a[x];
            exit;
    end;
    for i:=0 to min(y-x-1,min(m,z-1)) do//为了使得插入的乘号数合法 多重规定
        for j:=x to y-1 do
        begin
            if (i<=j-x)and(z-i-1<=y-(j+1)) then //为了不出现类似与（F[1,1,1]）之类的 继续判断合法
            begin
                mdfs(x,j,i);
                mdfs(j+1,y,z-i-1);
            end 
            else continue;
            f[x,y,z]:=max(f[x,y,z],f[x,j,i]*f[j+1,y,z-i-1]);
            t:=f[x,y,z];
        end;
    for i:=0 to min(y-x,min(m,z)) do// 同上 不过+法要少1个乘号限制
        for j:=x to y-1 do
        begin
            if (i<=(j-x))and(z-i<=y-(j+1)) then
            begin
                mdfs(x,j,i);
                mdfs(j+1,y,z-i);
            end 
            else continue;
            f[x,y,z]:=max(f[x,y,z],f[x,j,i]+f[j+1,y,z-i]);//转移方程
            t:=f[x,y,z];
        end;
end;

begin
    readln(n,m);
    for i:=1 to n do
        read(a[i]);
    for i:=0 to n do
        for j:=0 to n do
            for k:=0 to n do
                f[i,j,k]:=-1;//初始化  其实这题目出不出都一样 因为不可能存在0的情况（）即使有0 那答案也是0
    mdfs(1,n,m);
    writeln(f[1,n,m]);
end.

```

---

## 作者：大奕哥 (赞：2)


这道题实际上数据有些水，基本上能想到80%的细节就能过，

我的做法是将每个点枚举乘号，因为乘号数一旦确定加号数也就确定了。

状态转移方程

```cpp
if(l-i>=k-1)
            f[i][j][k]=max(f[i][j][k],f[i][l][k-1]*(f[1][j][0]-f[1][l][0]));
            if(j-l>=k-1)
            f[i][j][k]=max(f[i][j][k],f[l+1][j][k-1]*f[1][l][0]);
```
注意一定要判断能不能放进去称号，也就是数的个数要大于乘号的个数。
一开始没有考虑到0，所以死的很惨

if(a[j-1]==0&&a[j]==0&&j-2>=k-1)

          f[i][j][k]=max(f[i][j][k],f[i][j-2][k-1]);

所以特判一下

0\*0有时候也可以使最后结果大


下面是代码@@



 
```cpp
#include<stdio.h>
#include<cstdlib>
#include<stdio.h>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
long long f[20][20][20];//i位置kaitou,jjiewei,用a个乘号，b个加号 
int a[20];
int main()
{
     int n,m;
     cin>>n>>m;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    f[1][1][0]=a[1];
    for(int i=2;i<=n;i++)
    f[1][i][i-1]=f[1][i-1][i-2]*a[i];
    for(int i=2;i<=n;i++)
    f[1][i][0]=f[1][i-1][0]+a[i];
    for(int i=1;i<=n;i++)
    f[i][i][0]=a[i];//初始化 
 for(int i=1;i<=n;i++)
 for(int j=i;j<=n;j++)
 {
            for(int k=0;k<=j-i&&k<=m;k++)
            for(int l=i;l<=j;l++)
            {if(l-i>=k-1)
            f[i][j][k]=max(f[i][j][k],f[i][l][k-1]*(f[1][j][0]-f[1][l][0]));
            if(j-l>=k-1)
            f[i][j][k]=max(f[i][j][k],f[l+1][j][k-1]*f[1][l][0]);
          if(a[j-1]==0&&a[j]==0&&j-2>=k-1)
          f[i][j][k]=max(f[i][j][k],f[i][j-2][k-1]);
        }
            }
 cout<<f[1][n][m];
//while(1);
 return 0;
}
```

---


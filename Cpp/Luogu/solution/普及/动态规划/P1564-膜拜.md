# 膜拜

## 题目描述

神牛有很多…当然…每个同学都有自己衷心膜拜的神牛。

某学校有两位神牛，神牛甲和神牛乙。新入学的 $n$ 位同学们早已耳闻他们的神话。

所以，已经衷心地膜拜其中一位了。现在，老师要给他们分机房。但是，要么保证整个机房都是同一位神牛的膜拜者，或者两个神牛的膜拜者人数差不超过 $m$。另外，现在 $n$ 位同学排成一排，老师只会把连续一段的同学分进一个机房。老师想知道，至少需要多少个机房。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $1 \le n,m \le 50$。
- 对于 $100\%$ 的数据，保证 $1 \le n,m \le 2500$。

## 样例 #1

### 输入

```
5 1
2
2
1
2
2```

### 输出

```
2```

# 题解

## 作者：JOHNKRAM (赞：206)

将2改为-1，题目就变成了将序列最少分为多少段，使每段和的绝对值≤M。

用简单的动态规划。

f[i]=max{f[j]}+1(|Σa[k](j<k≤i)|≤M)
O(n²),轻松秒杀


---

## 作者：Lips (赞：62)

# 一篇适合 $\text{DP}$ 初学者的题解

这道题大家的代码都大同小异，不过萌新还是来篇较为**详细**的题解吧。

**先清晰一下题意：** 有 $n$ 个数，每个数要么是 $1$ 要么是 $2$，问最少分几段，使得每一段中只有相同的数，或者两种不同数字的数量之差 $<m$。

明显是一道 $dp$ 问题，先定义状态：设 $dp_i$ 为到了第 $i$ 个同学最小分的段数。

第 $0$ 个同学他不需要分段，毕竟本身也木有同学，所以 $dp_0=0$；

第 $1$ 个同学只能自己分一段，因为只有一个同学必须分段，所以 $dp_1=1$；

而其他的状态都先加设成 $\infty$，毕竟一个求最小值的问题如果都加设成 $0$ 最后答案也可能是 $0$。

再来定义状态：

我们可以先去枚举一个 $i$，表示到了第 $i$ 个同学，再去枚举一个 $j$，表示假设让区间 $[j,i]$ 砍成一段。

根据题意，先要判断这一段可不可以砍，有以下三中情况，只要满足一种就可以砍（题目上已经说的很清晰了：

- $\mid sum(1,j,i)-sum(2,j,i)\mid\le m$，两种不同数字的数量之差 $<m$。

- $sum(1,j,i)=0$ 没有数字 $1$。

- $sum(2,j,i)=0$ 没有数字 $2$。

其中 $sum(k,l,r)$ 表示区间 $[l,r]$ 中 $k$ 的个数。

然后若这一段合法，那么第 $i$ 个数便有两种选择：

- 不砍。那么 $dp_i$ 不变，毕竟没有分段，$dp_i=dp_i$。

- 砍。那就是上一个分段的地方 $j$ 的最小分段值加 $1$，$+1$ 因又砍了一段，$dp_i=dp_j+1$

两种决策取 $\min$，便是到了第 $i$ 个同学的最优解。

~~显而易见~~

时间复杂度：$\mathcal{O}(n^3)$

其中 $\mathcal{O}(n^2)$ 是循环，另一个 $\mathcal{O}(n)$ 是区间求和。但面对 $n\le2500$ 的数据量难以通过。

但我们发现，区间求和其实可以用前缀和来维护，这样就做到了 $\mathcal{O}(1)$ 查询！

设 $sum[k][i]$ 为区间 $[1,i]$ 中 $k$ 的数量。

对于每一个输入的 $a_i$，$sum[a_i][i]=sum[a_i][i-1]+1$。

而 $sum[(!(a_i-1))+1][i]=sum[(!(a_i-1))+1][i]$。

注意到了吗，这里巧妙的将 $1,2$ 这两个数字互相转换，先将 $1$ 转换成 $0$，或者 $2$ 转换成 $1$，将结果取反然后 $+1$，就是转换的结果。

这样，就能做到 $\mathcal{O}(1)$ 的查询了。

$Code:$ （压行严重，大佬勿喷

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN=2510;
int n,m,sum[3][MAXN],dp[MAXN],a[MAXN];
int main()
{
	scanf("%d%d",&n,&m);
	fill(dp+1,dp+1+n+5,0x3f3f3f3f),dp[0]=0,dp[1]=1;
	for(register int i=1;i<=n;i++) scanf("%d",&a[i]),sum[a[i]][i]=sum[a[i]][i-1]+1,sum[(!(a[i]-1))+1][i]=sum[(!(a[i]-1))+1][i-1];
	for(register int i=1;i<=n;i++) for(register int j=i-1;j>=0;j--) if((abs(sum[2][i]-sum[1][i]-(sum[2][j]-sum[1][j]))<=m)||(sum[2][i]-sum[2][j]==0)||(sum[1][i]-sum[1][j]==0)) dp[i]=min(dp[i],dp[j]+1);
	printf("%d\n",dp[n]);
	return 0;
}
```

$$\texttt{The End.}$$


---

## 作者：Drifterming (赞：48)





```cpp
//dp[i]表示前i个人所需的最少机房数。
//前缀和+差分思想。
//如果第i个人是1，那么sum[i]=sum[i-1]+1, 否则sum[i]=sum[i-1]-1
//if(abs(sum[i]-sum[j-1]==i-j+1))，说明i到j都相同
//if(abs(sum[i]-sum[j-1]<=m)),说明i和j之间的不同人数差不超过m 
//在符合以上两个条件下，转移方程：dp[i]=min(dp[i],dp[j-1]+1) 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m;
int be[2505],sum[2505],dp[2505];
inline int read(int &num)
{
    num=0;char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar()){num=num*10+c-'0';};
}
int main()
{
    memset(dp+1,0x7f,sizeof(dp));
    read(n),read(m);
    for(int i=1;i<=n;i++)
    {
        read(be[i]);
        if(be[i]==1) sum[i]=sum[i-1]+1;        //前缀和 
        else sum[i]=sum[i-1]-1;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            if(abs(sum[i]-sum[j-1])==i-j+1||abs(sum[i]-sum[j-1])<=m)
            {
                dp[i]=min(dp[i],dp[j-1]+1);
            }
        }
    }
    printf("%d",dp[n]);
    return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：34)

## 简单的线性dp，适合dp初学者

dp[i]表示前i人需要的最少机房数

初始条件：dp[0]=0,dp[1]=1

转移方程：dp[i]=min(dp[j])+1，其中0<=j<i且区间（i，j）可以成段

目标：dp[n]

 _注意：判断是否成段的部分可利用前缀和，且要注意细节_ 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2505];
int dp[2505],sum[2][2505];//sum：膜拜两者人数的前缀和 
int t(int a,int b){
	return abs( (sum[0][a]-sum[1][a]) - (sum[0][b]-sum[1][b]) );
}//t函数：返回a，b之间膜拜两者人数之差的绝对值 
int main(){
	cin>>n>>m;
	memset(dp,0x3f,sizeof(dp)); 
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==2)	a[i]=0;//把第2个人变成第0个人，方便操作 
		sum[a[i]][i]=sum[a[i]][i-1]+1;
		sum[a[i]^1][i]=sum[a[i]^1][i-1];//注意x^1可以让1变成0，0变成1 
	}
	dp[0]=0;
	dp[1]=1;//dp初始化 
	for(int i=1;i<=n;i++){
		for(int j=i-1;j>=0;j--){
			if((t(i,j)<=m)||
			( sum[0][i]-sum[0][j]==0 )||
			( sum[1][i]-sum[1][j]==0 ) ) dp[i]=min ( dp[i] , dp[j]+1 );
			//i，j区间内，若崇拜两者人数之差的绝对值<=m，或无崇拜某一方的人，则进行转移 
		}
	}
	cout << dp[n] << endl;
	return 0;
} 
```


---

## 作者：HPXXZYY (赞：19)

[博客使用效果更佳！！！](https://hpwwzyy2012.blog.luogu.org/solution-p1564)

[题目链接](https://www.luogu.org/problemnew/show/P1564)

设f[i]表示序列a[1..i]最少需要多少个机房

因为f[i]只与f[0..i-1]的值有关，与f[i+1..n]的值无关，所以本题满足**动态规划的无后效性**，同时本题也满足动态规划的**最优化原理**。综上所述，本题可以使用**动态规划**。

动态转移方程：f[i]=min(f[i],f[j-1]+1)

其中，**j=1..i**且**a[j..i]**可以放入**同一个机房**

如何快速判断a[j..i]是否可以放入同一个机房呢？

我们利用前缀和的思想，设膜拜乙的人贡献为-1，膜拜甲的人贡献为1，令s[i]=s[i-1]+第i个人的贡献，则s[i]-s[j-1]的值即为a[j..i]的贡献和。

此时，如果abs(s[i]-s[j-1])≤m或abs(s[i]-s[j-1])等于i-j+1时，a[j..i]可以放入同一个机房，判断的时间复杂度降为O(1)，比起未优化前的O(i-j+1)是一大进步！！！

[代码评测记录：](https://www.luogu.org/recordnew/show/15860652)

用时：85ms/内存：892KB

代码：c++  0.49KB

源代码如下：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int f[2510],s[2510];
int n,m,i,j,a;
int main(){
    scanf("%d%d",&n,&m);
    fill(f+1,f+n+1,0x7fffffff);
    //fill函数的意思是：把f[1..n]赋值为0x7fffffff(2147483647)
    for(i=1;i<=n;i++){
        scanf("%d",&a);
        if (a==1) s[i]=s[i-1]+1;
        else s[i]=s[i-1]-1;
        //统计贡献
    }
    for(i=1;i<=n;i++)
    for(j=1;j<=i;j++)
    if (abs(s[i]-s[j-1])==i-j+1||abs(s[i]-s[j-1])<=m)
    f[i]=min(f[i],f[j-1]+1);
    //动态转移方程
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：Dispwnl (赞：11)

//原来的题解下标出现了负数~~竟然没有RE~~，于是重新改了改~~竟然要加注释~~

划分动态规划

用一维数组f表示在i前最少能划分几个机房

用cha数组来储存1~i的值（如果膜拜1，++，否则--）

因为要求最小值

f初始化为0x7f，f[1]=1，即只有一个人时至少能划分1个机房

状态转移方程：

if(abs(cha[i]-cha[j-1])==i-j+1|| abs(cha[i]-cha[j-1])<=m)
                f[i]=min(f[i],f[j-1]+1);

（这道题还是挺简单的，然而我还是看了题解，然而xiaoming3次过了）

```cpp
# include<iostream>
# include<cstring>
# include<cstdlib>
# include<cstdio>
using namespace std;
int n,m;
int a[2501],cha[2501];
int f[2501];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      {
      	scanf("%d",&a[i]);
      	if(a[i]==1) cha[i]=cha[i-1]+1;
      	else cha[i]=cha[i-1]-1;//类似前缀和的处理方式
      }
    memset(f,0x7f,sizeof(f));//f赋值
    f[1]=1;//在1前只能划分出一个机房
    int h;//储存差值变量
    for(int i=2;i<=n;i++)
      for(int j=0;j<i;j++)
        {
            if(j) h=abs(cha[i]-cha[j-1]);
            else h=abs(cha[i]);
        	if(h==i-j+1||h<=m)//限制条件
        	if(j)//防止RE
          	f[i]=min(f[i],f[j-1]+1);
          	else f[i]=min(f[i],1);
        }
    printf("%d",f[n]);//输出答案
    return 0;
}
```

---

## 作者：米奇奇米 (赞：7)

```cpp
#include<bits/stdc++.h>
#define inf 100000000//宏定义，比较方便
using namespace std;
int f[2501],a[2501],s[2501][2501],n,m;//定义数组
int main(){
    //freopen("soul.in","r",stdin);
    //freopen("soul.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
     scanf("%d",&a[i]);
    for(int i=1;i<=n;i++){
        int moli=0,linli=0;//初始化一下
        for(int j=i;j<=n;j++){
            if(a[j]==1) linli++;//按照题意，进行分类累加
            if(a[j]==2) moli++;
            if(linli==0 || moli==0 || abs(linli-moli)<=m) //按照题意：要么保证整个机房都是同一位神牛的膜拜者，或者两个神牛的膜拜者人数差不超过M 。           
            s[i][j]=1;
            else s[i][j]=inf;
        }
    }
    for(int i=1;i<=n;i++) f[i]=inf;
    for(int i=1;i<=n;i++)
      for(int j=i-1;j>=0;j--)
        f[i]=min(f[i],f[j]+s[j+1][i]);//核心！！
    printf("%d",f[n]);
    return 0;
}	  

```

---

## 作者：CCCloud (赞：4)

### 主要思路：前缀和+dp 
------------
首先我们拿到这道题目  
发现要编程算出**最小需要XXX的数量**   
欸这不就是编程得出**最优解**嘛  
用**记忆化搜索**和**dp**都能实现  
~~我更喜欢记忆化搜索~~，所以我们来使用**dp**解决这道题 

------------
使用dp首先需要**设计状态**和**状态转移方程**  
**设计状态**：f [ i ] 表示**前i人**需要的**最少机房数** ;  
**状态转移方程**： **f [ i ] =min( f [ i ] , f [ j ] + 1)**;  
**满足条件：**  
1、**一段内**的同学只有**唯一**的崇拜者；  
2、**一段内**的同学崇拜**神犇1、2**的人数1，人数2之差**小于等于m**；  
由于是**一段内**，我很自然地想到了**前缀和**  
  
  于是我们就可以得到AC代码  


------------

### 代码如下
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n, m, a[2505], f[2505], s[3][2505];
//定义变量（由于只有1，2两种情况，所以二维数组并不需要定义[2505][2505]

int dec(int x,int y)//decide判断函数
{
    return abs((s[1][y]-s[1][x])-(s[2][y]-s[2][x]));
    //返回一段内的同学是否有唯一的崇拜者
}

int main(void)
{
    scanf("%d%d", &n, &m);
    memset(f, 0x3f, sizeof(f));//初始化数组，使数组的每一个元素无限大
    for(int i=1; i<=n; i++)//读入
    {
        scanf("%d", &a[i]);
        s[1][i]=s[1][i-1]+1;//当前神犇1的崇拜者=之前神犇1的崇拜者的数量+1
        s[2][i]=s[2][i-1]+1;//当前神犇2的崇拜者=之前神犇2的崇拜者的数量+1
        if(a[i]==1) s[2][i]--;//如果当前这位同学支持1，则2--；
        else s[1][i]--;//否则1--；（偷懒写法
    }
    
    f[0]=0;
    f[1]=1;//赋初值
    for(int i=1; i<=n; i++)
    {
        for(int j=0; j<i; j++)
        {
            if(dec(j,i)<=m || s[1][i]-s[1][j]==0 ||s[2][i]-s[2][j]==0)
            //如果一段内的同学有唯一的崇拜者或崇拜神犇1、2的人数1，人数2之差小于等于m
                f[i]=min(f[i], f[j]+1);//选取f[i]与f[j]+1中的最小值
        }
    }
    
    printf("%d\n", f[n]);//输出答案
    return 0;//完美的结束！
}
```

---

## 作者：prefer (赞：4)

# 算法：记忆化搜索

设f[i]表示选了Nnum个人之后的最优解

还可以加一个小优化：

one数组和two数组表示某个范围内膜拜1的人数和膜拜2的人数，说白了就是前缀和

然后按照题目要求进行DFS一趟就好了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10005],ans=214748364;
int one[10005],two[10005];
int f[10005];
int abs(int a){
    return a>0?a:-a; 
}
int dfs(int Nnum) {//Nnum表示选了多少个人 
    if(f[Nnum]) return f[Nnum];
    if(Nnum==n) return 0;
    int SUM=21474864;
    for(int i=n; i>Nnum; i--) 
        if(abs(abs((two[i]-two[Nnum]))-abs(one[i]-one[Nnum]))<=m||!(one[i]-one[Nnum])||!(two[i]-two[Nnum])) SUM=min(dfs(i)+1,SUM);
    return f[Nnum]=SUM;
}
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++) {
        scanf("%d",&a[i]);
        if(a[i]==1) one[i]=one[i-1]+1;
        else one[i]=one[i-1];
        if(a[i]==2) two[i]=two[i-1]+1;
        else two[i]=two[i-1];
    }
    printf("%d\n",dfs(0));
    return 0;
}
```

---

## 作者：飞翔 (赞：3)

把楼下的题解实现成代码：

```pascal
uses math;
var
    f,s:array[0..2501]of longint;
    i,j,n,m,t:longint;
begin
    fillchar(f,sizeof(f),$7f);
  readln(n,m);
    for i:=1 to n do
    begin
      readln(t);
        if t=1 then s[i]:=s[i-1]+1 else s[i]:=s[i-1]-1;
        if (abs(s[i])<=m)or(abs(s[i])=i) then f[i]:=1;//如果前i个人可以放在一个教室里当然是1咯
    end;
    if f[n]=1 then begin write(1);exit; end;//小优化
    f[1]:=1;
    for i:=2 to n do begin
      if f[i]=1 then continue;//已经有值了，没有必要再求，也是优化
      t:=maxlongint;
    for j:=1 to i-1 do
          if (abs(s[i]-s[j])<=m)or(abs(s[i]-s[j])=i-j) then t:=min(t,f[j]+1);//注意要符合条件才能替换
        f[i]:=t;
    end;
    write(f[n]);
end.
```

---

## 作者：Error_Eric (赞：2)

### Statement 

给长度为 $n$ 的 $\texttt{12}$ 串 $s$ 分成若干个子串，使得每个子串要么全部同字符，要么 $\texttt{1,2}$ 个数差不大于 $m$。求最少的子串个数。

### Solution

提供一个显然的 $O(n\log n)$ 解法。优于目前所有题解。

记 $f_i$ 表示子串 $s_1...s_i$ 中 $1$ 比 $2$ 多几个。

记 $g_i$ 表示子串 $s_1...s_i$ 的最少划分数。

那么 $g_i=\min\{g_j+1\}(1\le j <i)$ 其中 $j$ 需要满足 $s_{j+1}...s_i$ 同字符或者 $|f_i-f_j|\le m$。

第一种情况很好维护。而对于第二种情况，只需要在算出每一个 $g_j$ 的时候把 $g_j$ 的值扔到一个序列里面下标为 $f_j$ 的位置，如果比原来的值小就覆盖它，否则就忽略。然后算 $g_i$ 的时候用这个序列 $[f_i-m,f_i+m]$ 这个子区间最小值就可以最快找出最小的满足条件的 $g_j$。

单点修改，区间最小值，可以用线段树或者树状数组维护。这里用的是线段树~~结果人傻常数大只拿到次优解~~。这题数据比较水完全跑不满 $O(n\log n)$。

注意 $f_i$ 的值可能是负的所以要下标平移。

### Code

```
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int _=10055*2;
int n,m,a[5005],f[5005],g[5005],allsame,mxf=0;
class segtr{// 线段树板子。
    public:
    int minx[_],nl[_],nr[_];
    segtr(int len){
        nl[1]=1,nr[1]=len,minx[1]=_;
        for(int i=2; i<=2*len+5; i++){
            minx[i]=_;
            if(i&1)
                nl[i]= ((nl[i>>1]+nr[i>>1])>>1)+1,
                nr[i]= nr[i>>1];
            else
                nl[i]= nl[i>>1],
                nr[i]= ((nl[i>>1]+nr[i>>1])>>1);
        }
    }
    void modif(int pos,int val,int o=1){
        minx[o]=min(minx[o],val);
        if(nl[o]!=nr[o]){
            if(pos<=nr[o<<1])
                modif(pos,val,o<<1);
            else
                modif(pos,val,o<<1|1);
        }
    }
    int query(int ql,int qr,int o=1){
        if(ql<=nl[o] && nr[o]<=qr)
            return minx[o];
        else if(ql>nr[o] || qr<nl[o])
            return _;
        else 
            return min(query(ql,qr,o<<1),query(ql,qr,o<<1|1));
    }
};
int main(){
    ios::sync_with_stdio(0),
    cin.tie(0),cout.tie(0);
    cin>>n>>m, g[1]=1;
    for(int i=1;i<=n;i++)
        cin>>a[i], 
        f[i]= f[i-1] +1-(a[i]&2), // 计算 f, 用了位运算小技巧
        mxf= max(mxf,abs(f[i])+1); // 偏移量
    segtr tr((mxf<<1)+10); tr.modif(0+mxf,0);
    for(int i=2;i<=n;i++){
        if(a[i]!=a[i-1])
            allsame = i-1; // s[allsame+1..i] 同色。
        g[i]=min(tr.query(f[i]-m +mxf,f[i]+m +mxf)+1,g[allsame]+1);
        if(g[i]<g[allsame])
            allsame=i;
        tr.modif(f[i] +mxf,g[i]);
    }
    cout<<g[n]<<endl;
}
```

---

## 作者：封禁用户 (赞：2)

设dp[i] 表示前i个人最少需要几个机房
------------
如果两个机房的差<=M,或者只有一个神牛的崇拜者,则可以用一个机房容纳下他们即dp[i]=min(dp[i],dp[j]+1)
------------
初始化,dp[0]=0
------------
cpp代码

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2501],dp[2501];//dp[i]表示前i个人至少要被分到几个机房
int b[2501],c[2501];
int main()
{
    int n,m;
    cin>>n>>m;
    memset(dp,0x3f3f3f3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if(a[i]==1)
        {
            c[i]=c[i-1];
            b[i]=b[i-1]+1;
        }
        else
        {
            c[i]=c[i-1]+1;
            b[i]=b[i-1];
        }
    }
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<=i-1;j++)
        {
            if(abs(b[i]-b[j]-c[i]+c[j])<=m||(b[i]-b[j]==0)||(c[i]-c[j]==0))
            {
                dp[i]=min(dp[i],dp[j]+1);
            }
        }
    }
    cout<<dp[n]<< endl;
}
```


---

## 作者：MornEveGlow (赞：2)

首先，先求出前i个人中的两个神牛的膜拜者的人数差，需要使用动态规划解决，



                                  --gap[i-1]+1, people=1,

|

动态转移方程：gap[i]=--


|


                                  --gap[i-1]-1,  people=2;

其次，再求出前i个人最小需要机房的数量，也要使用动态规划解决，


动态转移方程：answer[i]=min{answer[j]+1}(fabs(gap[i]-gap[j])<=m或fabs(gap[i]-gap[j])==i-j),


这里的fabs(gap[i]-gap[j])表示第j个人到第i个人中的两个神牛的膜拜者的人数差，fabs(x)表示求x的绝对值，answer[n]即为所求。


···
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int gp[2505],ans[2505];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d",&a);
        if(a==1)
          for(int j=i;j<=n;j++)gp[i]=gp[i-1]+1;
        else 
          for(int j=i;j<=n;j++)gp[i]=gp[i-1]-1;
    }
    ans[1]=1;
    for(int i=2;i<=n;i++)
    {
        int mn=2500;
        for(int j=0;j<i;j++)
        {
            if(abs(gp[i]-gp[j])>m&&abs(gp[i]-gp[j])!=i-j)continue;
            if(ans[j]+1<mn)mn=ans[j]+1;
        }
        ans[i]=mn;
    }
    printf("%d",ans[n]);
}
···
```

---

## 作者：夏色祭 (赞：2)

**简单的线性dp，一道水题**


状态:f[i]//表示前i个人的最少需要车辆数


阶段:1 to n//每一个人为1个阶段


状态转移方程：f[i]:=min{f[j]}+1;//条件是从j+1个人到第i个人可以乘一辆车


边界:f[1]:=1;//一个人时只用一辆车就行了


AC代码：

```cpp
uses math;
var
  a,f:array[0..2501]of longint;
  n,m,i,j,x,y:longint;
begin
  readln(n,m);
  for i:=1 to n do read(a[i]);
  f[1]:=1;//边界
  for i:=2 to n do 
    begin
      f[i]:=maxlongint;
      x:=0;//表示从j到i为1的有几个
      y:=0;//表示从j到i为2的有几个
      for j:=i downto 1 do 
        begin
          case a[j] of 
            1:inc(x);
            2:inc(y);
          end;//判断第j个人属于哪个阵营
          if (abs(x-y)<=m)or(x=0)or(y=0) then f[i]:=min(f[i],f[j-1]);//从j个人到第i个人可以乘一辆车,即两种人相差不超过m或只有一种人，然后在满足条件的f[j-1]找个min
        end;
      inc(f[i]);//从j到i这些人需要一辆车
    end;
  write(f[n]);//最终答案保存在f[n]
end.
```

---

## 作者：TechZ (赞：1)

一道动态规划得入门题，我们用d[i]表示现在前i个人膜拜神犇的人数差，如果膜拜甲则++否则--，因为要求最小值，所以要先将f[i]初始化为无穷大。  
那么有这样的状态f[i]表示前i个人需要的教室数，那么初始化f[i]=1;那么在转移的时候要注意条件，要么全是膜拜一方的要么人数差不超过m，
  
  当abs(d[i]-d[j-1])==i-j+1时说明从i到j都是膜拜同一种人的，因为d[i]-d[j-1]的绝对值就是i到j的人数，说明肯定递增或递减  
  当abs(d[i]-d[j-1])<=m也就是人数差小于m时这个很好理解，最后进行更新即可.  
  方程为f[i]=min(f[i],f[j-1]+1)

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int d[2505];
int f[2505];
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int p;
        scanf("%d",&p);
        d[i]=d[i-1];//前缀和
        if(p==1)
        d[i]++;//计算人数差
        else
        {
            d[i]--;
        }
        f[i]=999999999;//初始化

    }
    f[1]=1;//初始化为1，因为只有一个人肯定需要一个教室
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(abs(d[i]-d[j-1])==i-j+1||abs(d[i]-d[j-1])<=m)//判断条件
            f[i]=min(f[i],f[j-1]+1);//更新
        }
    }
    printf("%d",f[n]);
    return 0;
}
```


---


# 加等式

## 题目描述

对于一个整数集合，我们定义“加等式”如下：集合中的某一个元素可以表示成集合内其他元素之和。如集合 ${1,2,3}$ 中就有一个加等式：$3=1+2$。而且 $3=1+2$ 和 $3=2+1$ 是相同的加等式，也是这个集合唯一的加等式。给定一个整数集合，编程找出其加等式的个数。

## 说明/提示

$1\le t\le 10$，$1\le m \le 30$，$1\le x\le 1000$。

## 样例 #1

### 输入

```
3
3 1 2 3
3 1 2 5
6 1 2 3 5 4 6```

### 输出

```
1
0
7```

# 题解

## 作者：communist (赞：40)

看到这道题，我们首先注意到“找出其所有的加等式的个数”，~~自然地~~考虑运用计数DP求出若干数相加的和的个数

考虑将每个元素排序后DP处理若干数相加的和的个数

用$f[i]$表示

对于一个数$a[i]$，对于前$i-1$个元素选或不选的和$j-a[i]$，选$a[i]$后的和为$j$，则组成$j-a[i]$的方案数会对组成$j$的方案数做出大小为$f[j-a[i]]$的贡献，

所以枚举$i,j$,像这样转移$f[j]+=f[j-a[i]]$

考虑加等式的统计：

对于一个整数集合，我们定义“加等式”如下：集合中的某一个元素可以表示成集合内其他元素之和。

对于一个数，我们已经得到它之前所有数选或不选的和等于它的方案数，为了避免漏记，考虑到对于$i>j$，$i$一定不会作为$j$的加等式中的元素出现，所以我们可以在输入时排序，从小到大DP，对于每个元素$a[i]$，统计它对答案$f[a[i]]$的贡献

上代码：
```
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int t,m,a[40],f[30010],sum;
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>m;
        sum=0;
        for(int i=1;i<=m;i++)
        {
            cin>>a[i];
            sum+=a[i];
        }
        sort(a+1,a+m+1);
        memset(f,0,sizeof(f));
        f[0]=1;
        int ans=0;
        for(int i=1;i<=m;i++)
        {
            ans+=f[a[i]];
            for(int j=sum;j>=a[i];j--)
                f[j]+=f[j-a[i]];
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：mahao2002 (赞：13)

### 这是一道比较裸的搜索题

#### 个人感觉搜索比dp更容易理解与实现

1≤m≤30

首先将所有元素由大到小排序，在依次枚举每个元素作为加等式的和，由于已经进行排序，只需要向后搜索加数即可，当当前累加和等于枚举的元素时ans++
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int t,n,a[32],ans;
bool cmp(const int a,const int b)
{
    return a>b;
}
void dfs(int num,int sum,int now)  
				//num是枚举的加等式的和
                //sum是当前所有加数的和
                //now是当前搜索到第几个数
{
    if(num==sum)
    {
        ans++;
        return ;
    } 
    for(int i=now+1;i<=n;i++)
        if(sum+a[i]<=num) dfs(num,sum+a[i],i); //将合法的加数加上继续搜索
    return ;
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        ans=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        sort(a+1,a+n+1,cmp);    //将所有元素从大到小排序
        for(int i=1;i<=n;i++) dfs(a[i],0,i); //枚举所有元素作为加等式的和
        printf("%d\n",ans);
    }
    return 0;
}
```

事实证明这道题搜索和dp速度不相上下
~~好像还比有些dp快了一倍~~

---

## 作者：lytqwq (赞：8)

简单的DP水题

题目链接：[https://www.luogu.org/problemnew/show/P1566](https://www.luogu.org/problemnew/show/P1566)

题目要求我们找出所有的加等式的个数。我们可以求出 

“集合中的所有整数x的得出方案的数量的和”

然后再减m,

为什么要减m呢？

因为会出现x=x的情况，就是用自己表示出自己来


### 可能有点绕口，~~多读几遍~~

AC情况：
[https://www.luogu.org/record/show?rid=19673518](https://www.luogu.org/record/show?rid=19673518)


细节看代码注释吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define M 31
#define X 1001
int t,m,a[M],f[X];
//t,m如题目输入输出格式上的
//a数组储存x
//f数组储存（数字i 能被表示的方案数 ） 
int main()
{
	cin>>t;
	for(int i=1;i<=t;i++)//t组数据 
	{
		memset(f,0,sizeof(f));//初始化 
		f[0]=1;//初始化0为能被表示方案有1种 
		cin>>m;
		int s=0,maxn=0;//s为方案总数，maxn为集合中最大数 
		for(int o=1;o<=m;o++)
		{
			cin>>a[o];
			maxn=max(maxn,a[o]);//取最大 
		}
		for(int o=1;o<=m;o++)
		{
			for(int p=maxn;p>=a[o];p--)
			{
				f[p]=f[p]+f[p-a[o]];//所以写了个有点像背包的东西 
			}
		}
		for(int o=1;o<=m;o++)
		{
			s+=f[a[o]];//累加 
		}
		cout<<s-m<<endl;//输出 
	}
}
```




---

## 作者：JOHNKRAM (赞：8)

使用01背包，求出方案总数。

f[c]=Σf[c-w[i]](1≤i≤n,c≥w[i])

初始f[0]=1，其他f[i]=0

时间复杂度O(tm\*max{x})


---

## 作者：Register (赞：4)

### 题意解释
给你一个$n$个数的集合，求是否有一些元素（大于$2$个）的和等于另一个元素
### 解题思路
看到$n$只有$20$且所有元素小于等于$1000$，凑数我们就想到了$01$背包

> 初始状态：$F_i=1$

> 状态转移：$F_i=F_i+F_{i-a_i}$

就是模板吧，要是连$01$背包都不会请自行转入[P1048 采药](https://www.luogu.org/problemnew/show/P1048)
### 注意事项
在最后统计一个元素会有多少种被凑出来的方法时，要减去自己产生的贡献
### 代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
int t,n,ans,a[31],f[1001];
int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
int main(){
	t=read();
	while(t--)
	{
		n=read();ans=0;memset(f,0,sizeof(f));f[0]=1;
		for(register int i=1;i<=n;i++) a[i]=read();
		for(register int i=1;i<=n;i++)
			for(register int j=1000;j>=a[i];j--) f[j]+=f[j-a[i]];
		for(register int i=1;i<=n;i++) ans+=f[a[i]]-1;
		printf("%d\n",ans);
	}
    return 0;
}
```


---

## 作者：NTG_Adiord (赞：3)

做完Y的积木那道题再来看这道题，简直就是一道水题。。。。

加等式，反正最大超不过1000直接开个dp1000就完了

bool hav确认有没有

给存进来的数排个序

dp[0]=1
跑两个for,第一层跑哪个数，第二层跑总和

最后得减去一下单个数的数量(2=2当然不是加等式)

详情参考代码和注释
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
int T;
int n;
int num[31];
bool hav[1001];
int dp[1001];
int main(){
	scanf("%d",&T);
	while(T--){
		int ans=0;
		memset(hav,0,sizeof hav);//重置
		memset(dp,0,sizeof dp);//重置
		dp[0]=1;
		scanf("%d",&n);
		for(int w=1;w<=n;w++){
			scanf("%d",&num[w]);
			hav[num[w]]=1;
		}
		for(int w2=1;w2<=n;w2++){
			for(int w=1000;w>0;w--){
				if(w-num[w2]>=0&&dp[w-num[w2]]!=0)dp[w]+=dp[w-num[w2]];//不等于零就加上，优先判断w-num[w2]不是负数
			}
		}
		for(int w=1;w<=1000;w++){
			if(dp[w]>0&&hav[w]==1)ans+=dp[w];//统计
			if(hav[w]==1)ans--;//去单
		}
		printf("%d\n",ans);
	}
}

```

---

## 作者：Hamster_Air (赞：3)

###这题是一道简单的dfs（好多dalao拿dp做然而我不会）

###作为一名蒟蒻的我只能弱弱地献上代码：




```cpp
#include<bits/stdc++.h> //万能头文件
#define f(i,j,n) for(i=j;i<=n;i++) //for循环简写
using namespace std; 
const int N=35; 
int a[N],ans,sum,m;
bool b[N]; //bool数组用于记录状态
inline void dfs(int x,int y,int z) //核心代码dfs过程，inline可以玄学加速
{
    int i;
    if(z>=a[x]) //只要选取的数之和大于等于a[x]，就return
    {
        if(z==a[x]) //若等于则多一种组合，即ans++
            ans++;
        return;
    }
    f(i,y+1,m) //I从y+1开始做
        if(!b[i]) //只要b[i]为假就继续递归
            b[i]=true,dfs(x,i,z+a[i]),b[i]=false;
}
int main() //主过程就不用过多解释了~
{
    ios::sync_with_stdio(false); //玄学输入输出优化
    int t;
    cin>>t;
    while(t--)
    {
        int i;
        sum=ans=0;
        cin>>m;
        f(i,1,m)
        {
            cin>>a[i];
            sum+=a[i];
        }
        f(i,1,m)
            if(a[i]<=sum-a[i])
                b[i]=true,dfs(i,0,0),b[i]=false;
        cout<<ans<<endl; //华丽丽的输出
    }
    return 0; //华丽丽地结束
}
```

---

## 作者：06ray (赞：1)

这道题是一道变形的01背包方法数问题。我们可以先求出每个数拆成其他数之和的方案总数，最后再相加。求每个数拆成其他数之和的状态转移方程是f[j]=sum(f[j],f[j-i]); 1<=i<=n a[i]<=j<=m(其中，m是所有数的最大的数)边界应是f[0]=1，最后把解算出来一定要减n!!!(因为还要去掉每个数自身的方案）

贴上代码。

```cpp
#include <bits/stdc++.h>//万能头文件 
using namespace std;
int a[100000],f[100000];//数组a是存放读入的数,数组f存放的每个数的拆成其他数或自己之和的方案总数
int main()
{
    int t;
    cin>>t;
    while(t--)//读入t组数据 
    {
        int m=-1,ans=0,n;
        memset(f,0,sizeof(f));//别忘了初始化 
        cin>>n;
        for(int i=1; i<=n; i++)
        {
            cin>>a[i];
            m=max(m,a[i]);//m存放最大数 
        }
        f[0]=1;//边界 
        for(int i=1; i<=n; i++)
        {
            for(int j=m; j>=a[i]; j--)//是从m递减到a[i]，不要写反了，不然就是完全背包的方案数了。 
            f[j]+=f[j-a[i]];//套用状态转移方程 
        }
        for(int j=1; j<=n; j++)
        {
            ans+=f[a[j]];//累加每个数的拆成其他数或自己之和的方案数
        }
        cout<<ans-n<<endl;//还要减掉每个数自身的方案
    }
    return 0;
}

```

---

## 作者：Rubyonly (赞：1)

## 思路

一个比较裸的线性 $dp$，将可能加和求出来的值依次枚举即可。

$f[i]$表示加和为 $i$ 的方案数，用上一个状态来加上即可。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e5+50,INF=0x3f3f3f3f;

inline int read(){
	int x=0,w=1;
	char ch;
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	return x*w;
}
int T;
int n;
int a[maxn];
int f[maxn];
int sum;
int ans;
int main(){
	T=read();
	while(T--){
		memset(f,0,sizeof(f));//一定要记得每次初始为0
		memset(a,0,sizeof(a));
		sum=0;ans=0;
		n=read();
		for(int i=1;i<=n;i++){
			a[i]=read();
			sum+=a[i];//求出来的sum为最大枚举值
		}
		sort(a+1,a+n+1);//sort一遍，从小到大枚举
		f[0]=1;//初始化
		for(int i=1;i<=n;i++){
			ans+=f[a[i]];//加上能加和为a[i]的方案数
			for(int j=sum;j>=a[i];j--){//从大到小枚举
				f[j]+=f[j-a[i]];//加上上个状态的方案数
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---


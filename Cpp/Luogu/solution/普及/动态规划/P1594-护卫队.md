# 护卫队

## 题目描述

护卫车队在一条单行的街道前排成一队，前面河上是一座单行的桥。因为街道是一条单行道，所以任何车辆都不能超车。桥能承受一个给定的最大承载量。为了控制桥上的交通，桥两边各站一个指挥员。护卫车队被分成几个组，每组中的车辆都能同时通过该桥。当一组车队达到了桥的另一端，该端的指挥员就用电话通知另一端的指挥员，这样下一组车队才能开始通过该桥。每辆车的重量是已知的。任何一组车队的重量之和不能超过桥的最大承重量。被分在同一组的每一辆车都以其最快的速度通过该桥。一组车队通过该桥的时间是用该车队中速度最慢的车通过该桥所需的时间来表示的。问题要求计算出全部护卫车队通过该桥所需的最短时间值。


## 样例 #1

### 输入

```
100 5 10
40 25
50 20
50 20
70 10
12 50
9 70
49 30
38 25
27 50
19 70```

### 输出

```
75.0```

# 题解

## 作者：认真的Ben (赞：93)

//写写这篇题解复习动态规划

**【算法分析】**

乍一看这道题，以为可以用模拟来解，像这样：
![](https://cdn.luogu.com.cn/upload/pic/65103.png)

带入数据一算就知道：我们错了！

仔细一看题目要求的是最短时间，这就要求我们**遍历所有的可能情况**。用搜索显然较繁，于是 ~~没学过其他算法的蒟蒻~~ 我们想到了**动态规划**。

**【动归方程】**

按照动态规划的思想方法，我们：

（1）**设 f[i] 为前i辆车通过桥的最短时间，设 t[i][j] 为第i-第j辆车（租车的车队）通过所需时间；**

（2）分析方程：
![](https://cdn.luogu.com.cn/upload/pic/65113.png)

综合起来，我们就得到了**方程**：
![](https://cdn.luogu.com.cn/upload/pic/65114.png)

Perfect! 但是也不要忘记了**条件**：
![](https://cdn.luogu.com.cn/upload/pic/65116.png)

（3）其实我们也可以这样理解，**对于每一辆车i，j从第i-1辆车开始倒推，看看总重是否小于最大载重量；**是则能组成车队，否则不能，且前面的j-1辆车不能与i组成车队；

![](https://cdn.luogu.com.cn/upload/pic/65119.png)

**【细节处理】**

（1）预处理重量

定义W[i]为前i辆车的总重
**（即前缀和，是处理这类问题非常好的方法，可以降低时间复杂度）**
![](https://cdn.luogu.com.cn/upload/pic/65208.png)

 **需要知道第j辆车到第i辆车的总重时，用W[i]-W[j-1]就可以了；**

（2）预处理时间

**（值得一提的是本题解直接将时间计算出来，转为分钟，方便之后程序编写）**

方法是：
定义Sb为桥的全长；v[i]为第i辆车的速度；T[i]:第i辆车通过桥所需时间；t[i][j]:第i辆车到第j辆车组成的车队通过桥所需的时间；

![](https://cdn.luogu.com.cn/upload/pic/65210.png)

 **（3）w数组、v数组和W数组一定要开long long，否则两个较大的int相加会炸掉！**

~~（我在这里被坑掉两个点qwq）~~

**【代码】**
 ```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long Wb,Sb,n,w[1000],v[1000],W[1000];double T[1000],t[1000][1000],f[1000];
/*Wb:the weigh of the bridge;
  Sb:the distance of the bridge;
  w[i]:the weigh of car i; 
  v[i]:the speed of car i;
  T[i]:the time for car i to go across the bridge; (minutes)
  W[i][j]:the sum of w[i],w[i+1],...,w[j];
  t[i][j]:the time for car i,car i+1,...,car j to go across the bridge; (minutes)
  f[i]:we must spend f[i] to let car 1,car 2,...,car i to go;
  一定要开long long，否则会炸！ 
*/

int main()
{
	cin>>Wb>>Sb>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>w[i]>>v[i];   
		T[i]=(double)Sb/v[i]*60;
		t[i][i]=T[i];
	}
	for(int i=1;i<=n-1;i++) 
	{
		for(int j=i+1;j<=n;j++)
		{
			t[i][j]=max(t[i][j-1],T[j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		W[i]=W[i-1]+w[i];
	}	
	for(int i=1;i<=n;i++)
    {
        f[i]=T[i]+f[i-1];  //前面i-1辆车所花的时间，加上第i辆车所花时间，就是前i辆车所花时间 
        for(int j=i-1;j>=1;j--)   //倒回去查，看看能不能组成一个从j到i的车队 
        {
        	if (W[i]-W[j-1]<=Wb) 
			{
				f[i]=min(f[i],f[j-1]+t[j][i]);  //cout<<f[i]<<" "; //能组成车队，比较时间 
			}
            else break;  //不能组成车队 
			
        }
    }
    printf("%0.1lf",f[n]); 
	return 0;
} 
```
PS：这是本人的第二篇题解（第一篇没过审核），求资磁！

---

## 作者：Timothy (赞：22)

【题目大意】

任何一组车队的重量之和不能超过桥的最大承重量。被分在同一组的每一辆车都以其最快的速度通过该桥。一组车队通过该桥的时间是用该车队中速度最慢的车通过该桥所需的时间来表示的。问题要求计算出全部护卫车队通过该桥所需的最短时间值。

【算法讨论】

这道题采用动态规划的思想。用f[i]表示前i辆车通过的最小时间；用vmin[i][j]表示第i辆车到第j辆车的最小速度；用sum[i]表示前i辆车的重量。动归式如下：

1.赋初值：f[i]=(double)len/v[i]+f[i-1];

2.如果第j辆车到第i辆车可以同时通过：

f[i]=min(f[i],f[j-1]+(double)len/vmin[j][i]);

得分：100

时间复杂度：O(N^2)

空间复杂度：O(3\*N+N^2)

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
double f[1001];
long long len,wei,n,w[1001],v[1001],sum[1001],vmin[1001][1001];
int main ()
{
    scanf ("%I64d%I64d%I64d",&wei,&len,&n);
    for (int b=1;b<=n;++b){scanf ("%I64d%I64d",&w[b],&v[b]);sum[b]=sum[b-1]+w[b];vmin[b][b]=v[b];}
    for (int b=1;b<n;++b)for (int c=b+1;c<=n;++c)vmin[b][c]=min(v[c],vmin[b][c-1]);
    for (int i=1;i<=n;++i)
    {
        f[i]=(double)len/v[i]+f[i-1];
        for (int j=i-1;j>=1;--j)
            if (sum[i]-sum[j-1]<=wei)f[i]=min(f[i],f[j-1]+(double)len/vmin[j][i]);
            else break;
    }
    printf ("%.1lf",f[n]*60);
    return 0;
}

```
注意要开long long


---

## 作者：Ofnoname (赞：11)

[P1594 【护卫队】](https://www.luogu.org/problem/P1594)

本题流氓，没有给出`W`, `S`的范围，事实上要开`long long`才能AC，另外应该注意小时与分钟的换算。

记`f[i]`为前`i`辆车全部通过的最小时间，一定会有一个以`i`结尾的车队通过，枚举这个车队的开头`L`，那么`f[i]`就应该是“`L`以前所有车的最小时间 + `[L, i]`里最慢的车需要的时间”。即$f[i] = f[L-1]+\frac M {min(v_i,i \in [L, i])}$

那么我们从`i`开始往左枚举所有的`L`，计算最小值即可，速度的最小值可以在向左时更新。同时所有车辆总重不能超过`K`，向左枚举的同时也记录一下车队总重，总重过大则退出循环。

```cpp
#include <bits/stdc++.h>
#define int long long
#define MAX (1000 + 7)
using namespace std;

int N, K, a[MAX], b[MAX];
double M, f[MAX];

signed main()
{
	cin >> K >> M >> N;
	for (int i = 1; i <= N; i++)
		cin >> a[i] >> b[i], f[i] = 1e18;
	for (int R = 1; R <= N; R++)
	{
		int L = R, sum = a[L], spe = b[L];
		while (L && sum <= K) {
			f[R] = min(f[R], f[--L] + M / spe);
			sum += a[L], spe = min(spe, b[L]);
		}
	} printf("%.1lf", f[N] * 60);
}
```

---

## 作者：cccgift (赞：8)

## 看到这里的题解算法都是$O(n^2)$的，这里给出$O(nlogn)$算法。

本题看到就想到了动态规划，并且动态转移方程也并不难想，设$f[i]$表示使前$i$辆车通过桥，所造成的最少时间，则：

#### $f[i]=min(f[j]+L/min(s[j+1..i]))(\sum_{k=j+1}^{i}w[k]<=W)$

发现这很符合单调队列的形式$f[i]=min(f[j]+calc(j,i))$，于是，我们可以尝试使用单调队列对其进行优化。

显然，$f[i]$具有单调性，它单调递增，但是$L/min(s[j+1..i])$在$j$增大时是非严格单调递减的，结果无法用普通的单调队列优化。

### 解决方法：

我们使用一种数据结构，对$dp$方程里的东西进行维护，取最小值，并支持删除和插入操作，最先想到的肯定是二叉堆，但还得手打堆，不太好，更简便的办法是使用$STL$中的$multiset$（$set$也一样）它们的时间复杂度都是$O(nlogn)$。

另外，对于最小值处理，看到很多人都用$st$表，事实上在单调队列中边算边处理即可。

于是，本题就做完了。

P.S. 听说本题有一种$O(n)$做法，但我不会……这里就不列出来了。可以去参考这道题：[P1848 [USACO12OPEN]书架Bookshelf](https://www.luogu.org/problemnew/show/P1848)。

### 代码如下：

```cpp
#include<cstdio>
#include<cctype>
#include<utility>
#include<set>
using namespace std;
#define res register int
#define ll long long
multiset<long double> se;
ll size,l,r,pos,n,a[1001],b[1001],w,id,q[1001],s;
long double f[1001],L;
template<typename T> //快读
inline void read(T &x)
{
	static char ch;
	for(x=0,ch=getchar();!isdigit(ch);ch=getchar());
	for(;isdigit(ch);x=(x<<1)+(x<<3)+ch-48,ch=getchar());
}
int main()
{
	read(w),scanf("%Lf",&L),read(n);
	for(res i=1;i<=n;++i) read(b[i]),read(a[i]);
	l=1;pos=1;
	for(res i=1;i<=n;++i)
	{
		s+=b[i];
		while(s>w) s-=b[pos++]; //保证总重量不超过W
		while(l<=r&&a[q[r]]>=a[i]) {if(l<r) se.erase(f[q[r-1]]+1.0*L/(long double)(a[q[r]]));--r;} //维护最小值
		q[++r]=i;if(l<r) se.insert(f[q[r-1]]+1.0*L/(long double)(a[q[r]]));
		while(q[l]<pos) {if(l<r) se.erase(f[q[l]]+1.0*L/(long double)(a[q[l+1]]));++l;} //把使总重量超过W的无用决策去掉
		f[i]=f[pos-1]+1.0*L/(long double)(a[q[l]]);
		if(l<r) f[i]=min(f[i],*(se.begin())); //取最小值
	}
	printf("%.1Lf",f[n]*60); //千万别忘了是分钟！！
	return 0;
}
```

---

## 作者：zhikong (赞：5)

首先因为处理完前面的车队之后后面的车队不会影响前面的车队，所以无后效性可以用动态规划。
 
设 $dp[i]$ 表示前 $i$ 个车的最小时间，转移时就枚举 $j$ 把车队分成之前的和 $j$ 到 $i$ 两段，把两段加起来。取枚举所有 $j$ 所对应的值的最小值，注意判断区间内总重不能超过桥。
 
$dp[i] = min(dp[j-1] + L / st)$

其中 $L$ 为桥长， $st$ 为 $j$ 到 $i$ 之间最慢的速度。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e3+5;
double dp[M];
long long sum,st,w[M],s[M];
long long m,l;
int n;
int main(){
	scanf("%lld %lld %d",&m,&l,&n);
	for(int i=1;i<=n;i++){
		dp[i]=1e18;
		scanf("%lld %lld",&w[i],&s[i]);
	}
	for(int i=1;i<=n;i++){
		sum=0;st=1e18;
		for(int j=i;j>=1&&sum+w[j]<=m;j--){
			sum+=w[j];st=st<s[j]?st:s[j];
			if(dp[i]>dp[j-1]+l*1.0/st*60.0){
				dp[i]=dp[j-1]+l*1.0/st*60.0;
			}
		}
	}
	printf("%.1lf",dp[n]);
	return 0;
}
```
 

---

## 作者：inexistent (赞：4)

来一发线段树

应该没人会用线段树做吧（除非像我一样作死的）
最近在学线段树，看这道题需要区间最小值就打了一个线段树版本的。（先打了个rmq，觉得无聊就删掉了）

```cpp
/*This Program is written by QiXingZhi*/
#include <cstdio>
#include <iostream>
#include <cstdlib>
#define  ll    long long
#define  Max(a,b)    (((a) > (b)) ? (a) : (b))
#define  Min(a,b)    (((a) < (b)) ? (a) : (b))
#define  FileIn(x)    freopen(x".in","r",stdin)
using namespace std;
struct Segment{
	ll val;
};
double f[1001];
ll L,W,n,w[1001],s[1001],sumw[1001];
Segment tree[40040];
void build(int l, int r, int root){
    if(l == r){tree[root].val = s[l];return;}
    int Mid = (l+r)>>1;
    build(l,Mid,root*2);
    build(Mid+1,r,root*2+1);
    tree[root].val = Min(tree[root*2].val, tree[root*2+1].val);
}
ll query(int l, int r, int x, int y, int root){
    if(l > y || r < x) return 1e12;
    if(x<=l && r<=y) return tree[root].val;
    int ans=0,Mid=(l+r)>>1;
    return Min(query(l,Mid,x,y,root*2),query(Mid+1,r,x,y,root*2+1));
}
int main(){
//	FileIn();
	scanf("%lld%lld%lld",&W,&L,&n);
	for(int i = 1; i <= n; ++i){
		scanf("%lld %lld",w+i,s+i);
		sumw[i] = sumw[i-1] + w[i];
	}
	build(1,n,1);
	for(int i = 1; i <= n; ++i){
        f[i] = (double)L/s[i]+f[i-1];
		for(int j = i-1; j >= 1; --j){
			if(sumw[i]-sumw[j-1] <= W){
				ll tmp = query(1,n,j,i,1);
				f[i] = Min(f[i], f[j-1] + (double)L/tmp);
			}
			else break;
		}
	}
	printf("%.1lf",f[n]*60.0);
	return 0;
}

```

---

## 作者：Lynx (赞：2)

```cpp
#include<algorithm>
#include<iostream>
#include<climits>
#include<cstring>
#include<cstdio>
#include<cfloat>
#include<cmath>
using namespace std;
long long m,l,n;
double f[1001];
struct car//存储车辆信息 
{
    long long w,s;
    double t;
}a[1001];
int main()
{
    long long tmp1=0;
    double tmp2=0.0;
    scanf("%lld%lld%lld",&m,&l,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld%lld",&a[i].w,&a[i].s);
        a[i].t=(double)l/a[i].s;
    }
    for(int i=1;i<=n;i++)//初始化f[0]=0 
        f[i]=DBL_MAX;
    for(int i=1;i<=n;i++)//选i辆车 
    {
        for(int j=1;j<=i;j++)//最后一组选j辆车 
        {
            tmp1+=a[i-j+1].w;//该组每辆车重量之和 
            if(tmp1>m)
                break;
            if(tmp2<a[i-j+1].t)
                tmp2=a[i-j+1].t;//tmp2存储该组时间 
            f[i]=min(f[i],f[i-j]+tmp2);//状态转移方程比较简单 
        }
        tmp1=0;//切记每分完一组清零 
        tmp2=0.0;
    }
    printf("%.1lf\n",f[n]*60);//单位分钟 
    return 0;
}
```

---

## 作者：white945 (赞：2)

f[a]表示过前a辆车时需要的最少时间

状态转移方程：

  f[a]=min(f[a],f[c-1]+mt);

c表示最后一组的第一辆车

f[c-1]就是除最后一组的前几组的最少时间

mt表示最后一组的时间

**mt用long long**

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int N=1005;

struct car
{
    int w;
    double t;
};

int wm,l,n;
car z[N];
double f[N];

int main()
{
    scanf("%d%d%d\n",&wm,&l,&n);
    for(int a=1;a<=n;++a)
    {
        scanf("%d%lf",&z[a].w,&z[a].t);
        z[a].t=(double)l/z[a].t;
    }
    memset(f,127,sizeof(f));
    f[0]=0.0;
    double mt=0;
    long long mm=0;
    for(int a=1;a<=n;++a)    //前a车 
    {
        mt=0; mm=0;
        for(int c=a;c>=1;--c)    //最后一组的第一辆车是c 
        {
            mm+=z[c].w;
            if(mm>wm) break;
            mt=max(mt,z[c].t);
            f[a]=min(f[a],f[c-1]+mt);
        }
    }
    printf("%.1lf\n",f[n]*60);
    while(1);
    return 0;
}
```
我一开始也枚举了组数（最多n组），但会超时，后来发现并不需要组数


---

## 作者：HelloElwin (赞：1)

## [请来我的个人博客享受更好的阅读体验](http://www.helloelwin.cn)

[*@caioj护卫队*](http://caioj.cn/problem.php?id=1066)

[*@Luogu护卫队*](https://www.luogu.org/problemnew/show/P1594)



## 题目大意

​	N辆顺序确定的车要分组过桥。桥的长度len和最大载重量maxw已给出。规定过桥时每组的总重量不超过maxw，每组最慢的车辆完成过桥时下一组才能开始过桥。给出每辆车的重量W与速度S，求最佳的分组使得总过桥时间最短。



## 算法讨论

​	我们可以发现如果已经确定了前x辆车的最佳分组，那么如果要再加入一辆车，他只能有两种选择：

​	-自己过桥

​	-把前面的人拉进来

​	如果自己过桥，那么就是前x辆车的最佳分组加上自己过桥的时间。如果拉人进来，首先绝对不会对前x辆车的过桥速度有负面影响，只会有正面影响（想一想，为什么）。也就是说只要看看最多能拉几个人，拉多少个人速度最快。因此我们发现，已经确定的x辆车对以后的选择没有任何影响，这满足了动态规划的**无后效性**。

​	（说了这么多其实就是动态规划，但是对无后效性的解释是这题再caioj上的子问题）

​	因此，我们只需建立一维数组f[i]表示到i的最佳组合方案，然后对每一个i便利1至i-1，找出i与其前方车辆的最佳组合即可。



## 数据结构

​	在状态转移的过程中，我们需要考虑车组的重量以及其中最慢车的时间。因此可以选用前缀和数组来维护重量，用ST表来维护某一段之间最慢的车。



## 代码实现

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int N, len, mw;
long long W[1002], sum[1002];
double f[1002], lg2[1002]={-1}, S[1002][10];

double Query(int l, int r){
	int lg=lg2[r-l+1];
	return max(S[l][lg], S[r-(1<<lg)+1][lg]);
}

int main(){
	
	scanf("%d %d %d", &mw, &len, &N);
	for (int i=1; i<=N; i++) lg2[i]=lg2[i>>1]+1;
	for(int i=1; i<=N; i++){
		scanf("%d %lf", &W[i], &S[i][0]);
		f[i]=S[i][0]=(double)len/S[i][0];
		sum[i]=W[i]+sum[i-1];
	}
	for (int j=1; j<=lg2[N]; j++)
		for (int i=1; i+(1<<j)-1<=N; i++)
			S[i][j]=max(S[i][j-1], S[i+(1<<(j-1))][j-1]);
	for(int i=1; i<=N; i++){
		f[i]+=f[i-1];
		for(int j=i-1; j>=1; j--){
			if (sum[i]-sum[j-1]<=mw) f[i]=min(f[i], f[j-1]+Query(j, i));
			else break; //一定要跳出,不然车组就断开了!
		}
	}
	
	printf("%.1lf", f[N]*60); //分钟啊!!卡了好久!
	
	return 0;
}
```



## [请来我的个人博客享受更好的阅读体验](http://www.helloelwin.cn)

---

## 作者：biey (赞：1)

# 题目解析

**所以任何车辆都不能超车**

就是简单地求出所有车怎么分组，不用考虑排序


**任何一组车队的重量之和不能超过桥的最大承重量**

这就是边界条件，用来判断是否在某个子问题中继续规划下去


**一组车队通过该桥的时间是用该车队中速度最慢的车通过该桥所需的时间来表示的**

从这句话我们知道选取的车应该是在某一子问题中满足重量要求的所花时间的最大值



------------



# 思路

--------\*（01背包问题）\*----------

f[i]表示过前i辆车时需要的最少时间


状态转移方程：f[i]=min(f[i],f[first-1]+time);


first表示最后一组的第一辆车


f[first-1]就是除最后一组的前几组的最少时间


time表示最后一组的时间


----------------


#代码



```cpp
`int n;//车辆数 
int maxn;//桥的最大载重量 
int f[];
int max;//用来记录目前达到的最大的重量，这个值不能超过maxn，也就是桥的最大载重量 
inline void dp(){
    for(int i=1;i<=n;++i){
        max=0,time=0;//不断更新
        for(int j=i;j>=1;--j){
            max+=time1/*(就是这辆车的时间）*/;
            if(max>maxn)break;
            time=max(time,time1);//详见题目解析 
            f[i]=min(f[i],f[j-1]+time);//递推式：前i-1辆车的最短时间 和第i辆车的的时间和最短的那个 
        }
    }
}`
```
--------------------------------
#后续的几个问题


修了好几遍



数据类型必须是`long long`


`max（）`和`min（）`的返回值必须是`double`型的不然会诡异爆数字

比如说：


```cpp
`inline double min(double a,double b){
    return a<b?a:b;
}
inline double max(double a,double b){
    return a>b?a:b;
}`
```
f[]数组一开始就必须是小数，不然输出比较麻烦。。。也就是`f[0]=0.0`

-----------------------------

### 代码终极版










```cpp
`#include<cstdio>
#include<cstring>
using namespace std;
const int N=1005;
double t1=0;
long long t2=0;
struct car{
    int w;
    double t;
};
int wmax,l,n;
car c[N];
double f[N];
inline double min(double a,double b){
    return a<b?a:b;
}
inline double max(double a,double b){
    return a>b?a:b;
}
inline void output();
inline void dp();
inline void dp_ready();
inline void input();
int main()
{
    input();
    dp_ready();
    dp();
    output();
    return 0;
}
inline void input(){
    scanf("%d %d %d",&wmax,&l,&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d%lf",&c[i].w,&c[i].t);
        c[i].t=(double)l/c[i].t;
    }
}
inline void dp_ready(){
    memset(f,127,sizeof(f));
    f[0]=0.0;
}
inline void dp(){
    for(int i=1;i<=n;++i)
    {
        t1=0,t2=0;
        for(int j=i;j>=1;--j) 
        {
            t2+=c[j].w;
            if(t2>wmax) break;
            t1=max(t1,c[j].t);
            f[i]=min(f[i],f[j-1]+t1);
        }
    }
}
inline void output(){
    printf("%.1lf",f[n]*60);
}`
### ***THE END***

```

---

## 作者：s_a_b_e_r (赞：1)

//dp[i]表示到第i个点最小的时间

看到没有用时间st的，我来水一下


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define LL 999999999999999   //这个数一定要开大一点。。不然会wa掉3个点
using namespace std;
struct SA{
    double v,t;
    long long w;
}a[1001];
long long n,L,W;
double d[1001][1001];
double dp[1003];
int main(){
    cin>>W>>L>>n;
    for(int i=1;i<=n;i++){
    cin>>a[i].w>>a[i].v;
    a[i].v=a[i].v/60.0;
    a[i].t=double(L)/a[i].v;
```
}//提前算出每一个时间
```cpp
    for(int i=1;i<=n;i++)
     for(int j=i;j>=1;j--)
         d[j][i]=d[j+1][i]+a[j].w;//这里算从第i个点到第j个点所需要的时间，一定要倒叙
       for(int i=1;i<=1000;i++)dp[i]=LL;//初值必须大
       dp[0]=0;
    for(int i=1;i<=n;i++){
        double ma=-LL;//找出每个时间段最大的时间
        for(int j=i;j>=1;j--){
            if(d[j][i]>W)break;//超过W就下一次dp
            ma=max(ma,a[j].t);
            dp[i]=min(dp[i],dp[j-1]+ma);
        }
    }
    printf("%0.1f",dp[n]);
    return 0;
}
```

---

## 作者：抽空的太阳 (赞：1)

注意开long long

很容易想出暴力搜索的策略：

设当前点为x，枚举从x出发，能到达的点（这些点肯定是连续的，每辆车的重量用前缀和优化），y为到当前点x所用的时间，当x==n时，ans=min(ans,y)

这样就可以拿到40分了

满分做法：http://blog.csdn.net/cax1165/article/details/53182866

```cpp
#include<iostream>
#include<cstdio>
#define lon long long
using namespace std;
const int maxn=1010;
lon w,t,n,sum[maxn];
double ans=0x7fffffff;
struct node
{
    lon w;
    lon s;
    double t;
}a[maxn];
void dfs(lon x,double y)
{
    if(x==n)
    {
        ans=min(ans,y);
        return;
    }
    if(y>ans) return;
    for(lon i=x+1;i<=n;i++)
    if(sum[i]-sum[x]<=w)
    {
        double tmp=-0x7fffffff;
        for(lon j=x+1;j<=i;j++)
        tmp=max(a[j].t,tmp);
        dfs(i,y+tmp);
    }
    else break;
}
int main()
{
    scanf("%d%d%d",&w,&t,&n);
    for(lon i=1;i<=n;i++)
    {
        scanf("%d%d",&a[i].w,&a[i].s);
        a[i].t=double(t)/double(a[i].s);
        sum[i]=sum[i-1]+a[i].w;
    }
    dfs(0,0);
    printf("%0.1lf",ans*60);
    return 0;
}

```

---

## 作者：liuzitong (赞：1)

为什么没人写Pascal啊
Pascal其实不难
```pascal
program  convoy;
var  f,b:array [0..1000] of real;
     w,v:array [0..1000] of real;
     m,l,s,t1,t2:real;i,j,n:longint;
begin
  readln(m,l,n);
  for i:=1 to n do
  begin
    readln(w[i],v[i]);
    b[i]:=60*l/v[i];
  end;
  f[1]:=b[1];f[0]:=0;
  for i:=2 to n do
  begin
    s:=w[i];t1:=b[i];
    f[i]:=f[i-1]+b[i];
    for j:=i-1 downto 1 do
    if s+w[j]<=m then
      begin
        s:=s+w[j];
        if b[j]>t1 then t1:=b[j];
        t2:=f[j-1]+t1;
        if t2<f[i] then f[i]:=t2;
      end 
    else break;
  end;
  writeln(f[n]:0:1);
  close(input);close(output);
end.
```


---


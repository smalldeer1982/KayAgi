# 最大正方形II

## 题目背景

忙完了学校的事，v 神终于可以做他的“正事”：陪女朋友散步。一天，他和女朋友走着走着，不知不觉就来到了一个千里无烟的地方。v 神正要往回走，如发现了一块牌子，牌子上有有一行小字和一张图，小字说道：“找到图上最大的交错正方形之后和我联系，这块地就是你的了。”在房价疯长的年代，v 神当然不愿错过这个机会，于是开始找了起来……以 v 神的能力当然找不出来了，你能帮 v 神找出来吗？

## 题目描述

图上有一个矩阵，由 $N\times M$ 个格子组成，这些格子由两种颜色构成，黑色和白色。请找到面积最大的且内部是黑白交错（即两个相连的正方形颜色不能相同）的正方形。

## 说明/提示

### 样例解释

$(1,1)$ 到 $(2,2)$ 这个正方形是满足条件的，它的边长是 $2$。

### 数据范围及约定

- 对于 $30\%$ 的数据，$N \le 20$；
- 对于 $60\%$ 的数据，$N \le 300$；
- 对于 $100\%$ 的数据，$N \le 1500$。

## 样例 #1

### 输入

```
3 3
0 1 0
1 0 0
1 1 1
```

### 输出

```
2```

# 题解

## 作者：BriMon (赞：59)

**惊！**
在题解里竟然没有我的做法（汗-_-||

本蒟蒻来谈谈我的做法

这道题就是最大正方形的变式；

最大正方形那道题，是设dp[i][j]为在(i,j)以上的最大正方形；

本题就是多加了一个条件，满足黑白相间的最大正方形；

所以可以多设一维表示此位置是1还是0；

就有了dp[i][j][0/1] 表示在(i, j)以上， 且本位是0/1的最大符合条件的正方形；

转移方程：

**如果本位是1:
f[i][j][1] = min(f[i-1][j][0], min(f[i][j-1][0], f[i-1][j-1][1])) + 1**

**如果是0:
f[i][j][0] = min(f[i-1][j][1], min(f[i][j-1][1], f[i-1][j-1][0])) + 1**

然后每步后取max就行了；

**代码：** 

```
#include <bits/stdc++.h>
using namespace std;

int f[1501][1501][2];
int n, m, a[1505][1505];
int ans = -1;
inline int read()
{
    int X=0,w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}

int main()
{
	n = read(), m = read();
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=m;j++)
		{
			a[i][j] = read();
		}
	}
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=m;j++)
		{
			if(a[i][j] == 1) f[i][j][1] = min(f[i-1][j][0], min(f[i][j-1][0], f[i-1][j-1][1])) + 1, ans = max(ans, f[i][j][1]);
			if(a[i][j] == 0) f[i][j][0] = min(f[i-1][j][1], min(f[i][j-1][1], f[i-1][j-1][0])) + 1, ans = max(ans, f[i][j][0]);
		}
	}
	
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Apro1066 (赞：29)

其实是最大正方形的变形。

正方形那题是令$dp[i][j]$是以$(i,j)$为右下角能得到的最大正方形边长，而这次只要加一个维度判断黑白格就行了。。

令$dp[i][j][0/1]$是以$(i,j)$为右下角，且该点上为$0/1$时能得到的最大正方形边长，则：

**1.当$a[i][j]=0$时**

$$dp[i][j][0]=min(dp[i-1][j][1],dp[i][j-1][1],dp[i-1][j-1][0])+1$$

**2.当a[i][j]=1时**

$$dp[i][j][1]=min(dp[i-1][j][0],dp[i][j-1][0],dp[i-1][j-1][1])+1$$

这里来着重讲一下为什么状态转移方程中为什么要取$min$而不是取$max$。

你想啊，点$(i,j)$可以从$(i-1,j)$转移过来，也可以从$(i,j-1)$转移过来，也可以从$(i-1,j-1)$转移过来。这$3$个点要同时兼顾，而$(i,j)$是决定存在性问题的，如果我取$max$，我这边可能满足条件，但就不保证其他两边满足条件了。如果你不能理解，我们举个例子就明白了：

假如有一个a数组$a[4][4]$：
```
1 0 1 0
0 1 0 1
1 0 1 0
0 1 0 0
```
则dp数组：（这里$dp$数组用$2$维表示，为了举例方便）
1
```
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```
2
```
1 1 1 1
1 0 0 0
0 0 0 0
0 0 0 0
```
在$dp[2][2]$中，显然可以从$dp[1][2]$，$dp[2][1]$，$dp[1][1]$这$3$个点转移，看一下a数组：
```
1 0
0 1
```
是可以转移的，于是dp数组
```
1 1
1 2
```
dp数组
3
```
1 1 1 1
1 2 2 2
1 2 2 2
1 2 2 0
```
等等，$dp[3][3]$应该为$3$啊！
好。
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 2 0
```
那么我们接着看$dp[4][3]$，发现$dp[4][2]=2$，$dp[3][3]=3$，$dp[3][2]=2$，周围有2个2，1个3，选哪个呢？

好，按照我们之前的惯性思维，如果取$max$的话，也就是选$dp[3][3]$的话，则dp数组：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 4 0
```
发现它并不能构成边长为$4$的正方形！所以要选边长为$2$的。
最后dp数组：
```
1 1 1 1
1 2 2 2
1 2 3 3
1 2 3 0
```
也就是说，$dp[i][j]$的选择，是要兼顾$dp[i-1][j]$，$dp[i][j-1]$，$dp[i-1][j-1]$的最小值的。如果取最大值的话，显然不能保证$dp[i][j]$是否还能正确。取最小值是为了能保证$dp[i][j]$也能满足条件，随着$i$和$j$的增大，$dp[i][j]$一定能保证单调递增的。
```cpp
#include <stdio.h>
#include <iostream>
#define inf 2e9+7
using namespace std;
int dp[1501][1501][2],a[1501][1501],n,m,s;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i,j;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			cin>>a[i][j];
		}
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(a[i][j]==0)
			{
				dp[i][j][0]=min(min(dp[i-1][j][1],dp[i][j-1][1]),dp[i-1][j-1][0])+1;
				s=max(s,dp[i][j][0]);
			}
			if(a[i][j]==1)
			{
				dp[i][j][1]=min(min(dp[i-1][j][0],dp[i][j-1][0]),dp[i-1][j-1][1])+1;
				s=max(s,dp[i][j][1]);
			}
		}
	}
	cout<<s<<endl;
	return 0;
}
```

---

## 作者：The_Stalker (赞：27)

蒟蒻不会用什么高级方法，也不会~~懒得~~判断黑白相间，看到这是最大正方形2，就去翻了一下最大正方形1的代码。

然后惊喜地发现可以把相邻两个里的一个(坐标均为奇数的位置)反转颜色，然后求这个新图的最大正方形即可。

于是代码就很简单了。~~我才不告诉你我是把1里的代码CV大法过来的~~

因为此时求最大正方形的办法用的是1的最小值计算法(不知道的同学请点击[此处](https://www.luogu.org/problemnew/solution/P1387)并看第一篇题解的思路)，所以要存两个图，第二个图是第一个图完全反转(0->1,1->0)的结果，然后用1的代码~~照抄~~就好。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1501][1501],b[1501][1501];//a存原图,b存第二个图
int m,n,ans;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			if(j%2==i%2)
			a[i][j]=a[i][j] xor 1 ;//将每个奇数位置反转
			b[i][j]=a[i][j] xor 1 ;//将图a反转存入图b
		} 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(a[i][j])
			a[i][j]=min(a[i-1][j],min(a[i-1][j-1],a[i][j-1]))+1;
		}//用最大正方形1的做法,计算不为0的最大正方形大小	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(b[i][j])
			b[i][j]=min(b[i-1][j],min(b[i-1][j-1],b[i][j-1]))+1;
		}//反转后0变1,1变0,同样方法再计算一次
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		ans=max(ans,max(b[i][j],a[i][j]));
        //答案取这两个图的最大值
	cout<<ans;
}
```

---

## 作者：一秒 (赞：12)

这是道水题....但是我想到了一个奇妙的算法，我把它叫做————层增法

大致思想就是：

		设f[i][j]表示**以（i，j）为右下角的最大正方形边长**，

		则对于每一个s[i][j],若s[i][j]==s[i-1][j-1]，

		那么（划重点）——从当前点开始，扫一遍行和列，若符合条件则:

			**f[i][j]=f[i-1][j-1]+1；**

		若中途发现不对，就取**较长边**作为当前f[i][j]的值.

这个过程就像在一个格子上层层增加，故而我称之为层增法。

其实说到底也就是动态规划思想的运用：用已知状态推出未知状态。

这个算法其实还只是个雏形，还有许多优化之法 万望各位神犇赐教～～

老板，来份天然有机绿色AC代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[1510][1510],f[1510][1510],ans=1;
int main(){
        int n,m;
        cin>>n>>m;
        for(int q=1;q<=n;q++)
        for(int w=1;w<=m;f[q][w]=1,w++)//每个点都可以单独作为一个正方形
                cin>>s[q][w];
        for(int q=1;q<=n;q++)
        for(int w=1;w<=m;w++)
        if(s[q][w]==s[q-1][w-1]){
             int i=s[q][w],j=s[q][w],l1=1,l2=1;//i、j作为比对的对象  l1,l2是接下来扫描终点到（i，j）的最远距离
             for(int e=w-1;e>=w-f[q-1][w-1];e--)//扫描长度为f[i-1][j-1]
                  if(s[q][e]!=i)i=s[q][e],l1++;
                  else break;
             for(int e=q-1;e>=q-f[q-1][w-1];e--)//同上
                  if(s[e][w]!=j)j=s[e][w],l2++;
                  else break;
             ans=max(ans,f[q][w]=min(l1,l2));//取最小值
        }
        cout<<ans;
}
```
至于为什么取l1,l2最小值，可以自己画个图～～

PS:感谢某hao提供表述及完善

---

## 作者：Captain_Paul (赞：6)

##小蒟蒻来发题解啦。。

//这道题和最大正方形1类似，不同之处在于对正方形的要求

//与最大正方形1相同，我们可以用f[i][j]来表示以(i,j)为右下角的正方形边长

//我们从(1,1)开始读入，那么，只要a[i][j]与a[i-1][j],a[i][j-1]都不相同，就可以列出状态转移方程:

```cpp
//f[i][j]=min(f[i-1][j-1],min(f[i][j-1],f[i-1][j]))
//特殊地，对于左上角的数，需要一个小处理,即:a[0][1]和a[1][0]都要与a[1][1]不同
//话不多说，上代码:
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,ans,a[1501][1501],f[1501][1501];
int main()
{
    int i,j;
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
      for (j=1;j<=m;j++)
        scanf("%d",&a[i][j]);
    if (a[1][1]) a[1][0]=a[0][1]=0;
    else a[1][0]=a[0][1]=1; 
    for (i=1;i<=n;i++)
      for (j=1;j<=m;j++)
        if (a[i][j]==0&&a[i-1][j]==1&&a[i][j-1]==1)
          f[i][j]=min(f[i-1][j-1],min(f[i][j-1],f[i-1][j]))+1;
        else if (a[i][j]==1&&a[i-1][j]==0&&a[i][j-1]==0)
          f[i][j]=min(f[i-1][j-1],min(f[i][j-1],f[i-1][j]))+1;
    for (i=1;i<=n;i++)
      for (j=1;j<=m;j++)
        ans=max(ans,f[i][j]);
    printf("%d\n",ans+1);
    return 0;
}
```

---

## 作者：hibiki (赞：4)

话说这题不就是ZJOI那道棋盘制作吗。。

这题可以用单调栈来搞。

我们首先现将棋盘奇数列奇数行的格子反色，这样题目就变成了求最大的同色矩形了。

然后我们在竖直方向上统计每个纵列以(i,j)为起点,向下的连续格子最长有多长,显然这样做是O(n^2)的,这样我们就把整张图转化成了很多的条状物

之后对于从左往右把条状物压入栈中,显然,如果一个条状物的高度比他前面的条状物高度要小，那么他前面的条状物比它高的部分都不可能对之后的任何矩形做出贡献，所以我们可以维护一个栈使其保持单调增,然后每次条状物弹出的时候更新答案并且把他的宽度加到他左边或者右边的条状物中长度更长的那一条上。

原题要求同时统计最大正方形和最大矩形，这里只要统计最大的正方形即可。

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#define MAXN 2000
#define INF 0x3f3f3f
using namespace std;
int n,m;
int map[MAXN+10][MAXN+10];
int p[MAXN+10][MAXN+10];
int ans1=0,ans2=0;
int sqr(int x){
    return x*x; 
}
struct node{
    int l,h;//l存长度,h存高度 
};
void solve(int tar){
    memset(p,0,sizeof(p));//p[i][j]记录第j列向上以(i,j)为终点的最长连续tar串长度 
    for (int i=1;i<=m;i++){
        p[1][i]=(map[1][m]==tar);
    }
    for (int j=1;j<=m;j++){
        for (int i=1;i<=n;i++){
            p[i][j]=(map[i][j]==tar)?(p[i-1][j]+1):0;
        }
    }
    node stack[2*MAXN]; //单调栈
    int top=0;
    for (int i=1;i<=n;i++){
        memset(stack,0,sizeof(stack));
        stack[0].h=stack[0].l=0;
        top=0;
        for (int j=1;j<=m;j++){
            int x=1;
            while (top>0&&stack[top].h>=p[i][j]) {
                ans1=max(ans1,stack[top].h*stack[top].l);
                ans2=max(ans2,sqr(min(stack[top].h,stack[top].l)));
                if (p[i][j]>stack[top-1].h) x+=stack[top].l;else stack[top-1].l+=stack[top].l;
                top--;
            }
            top++;
            stack[top].h=p[i][j];
            stack[top].l=x;
        }
        while (top>0){
            ans1=max(ans1,stack[top].h*stack[top].l);
            ans2=max(ans2,sqr(min(stack[top].h,stack[top].l)));
            stack[top-1].l+=stack[top].l;
            top--;
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            scanf("%d",&map[i][j]);
            if ((i+j)&1) map[i][j]^=1;
        }
    }
    solve(1);
    solve(0);
    printf("%d\n",(int)sqrt(ans2));
}
```

---

## 作者：顾z (赞：4)

题目描述-->[P1681 最大正方形II](https://www.luogu.org/problemnew/show/P1681)

## 广告： [安利blog](https://www.luogu.org/blog/RPdreamer/#)

**题意概括**

给定一个01交错的矩阵,要求求出其中最大的01交错分布的正方形边长.

**分析:**

一看题目,woc,悬线法裸题。

再一看,woc,这不棋盘制作。

什么？不知道**悬线法**?

那我就来bb两句.

//其实是粘过来的--->自己写的[棋盘制作](https://rpdreamer.blog.luogu.org/p1169)

以下内容部分参考[@Clove_unique](https://blog.csdn.net/Clove_unique/article/details/50512624)


**悬线法**

    用途:
       解决给定矩阵中满足条件的最大子矩阵
    做法:
       用一条线(横竖貌似都行)左右移动直到不满足约束条件或者到达边界
     定义几个东西:
            left[i][j]:代表从(i,j)能到达的最左位置
            right[i][j]:代表从(i,j)能到达的最右位置
            up[i][j]:代表从(i,j)向上扩展最长长度.
    这里给出递推公式：
           left[i][j]=max(left[i][j],left[i-1][j]
           right[i][j]=min(right[i][j],right[i-1][j]
至于为什么递推公式中考虑上一层的情况？

是因为up数组的定义,up数组代表**向上扩展**最长长度,
所以需要考虑上一层的情况.

然后求解正方形的情况即可。

题目要求01交错,所以"!="即可

-------------------代码---------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define maxn 2001
IL void read(int &x){
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int res[maxn][maxn],left[maxn][maxn],right[maxn][maxn],up[maxn][maxn];
int n,m,ans1,ans2;
int main()
{
    read(n),read(m);
    for(RI i=1;i<=n;i++)
        for(RI j=1;j<=m;j++)
            {
                read(res[i][j]);
                left[i][j]=right[i][j]=j;
                up[i][j]=1;
            }
    for(RI i=1;i<=n;i++)
        for(RI j=2;j<=m;j++)
            if(res[i][j]!=res[i][j-1])
                left[i][j]=left[i][j-1];//预处理左边界
    for(RI i=1;i<=n;i++)
        for(RI j=m-1;j>0;j--)
            if(res[i][j]!=res[i][j+1])
                right[i][j]=right[i][j+1];//预处理右边界
    for(RI i=1;i<=n;i++)
        for(RI j=1;j<=m;j++)
            {
                if(i>1&&res[i][j]!=res[i-1][j])
                {
                    left[i][j]=std::max(left[i][j],left[i-1][j]);
                    right[i][j]=std::min(right[i][j],right[i-1][j]);
                    up[i][j]=up[i-1][j]+1;
                }
                int a=right[i][j]-left[i][j]+1; //横向长度
                int b=std::min(a,up[i][j]);//竖向长度
                //printf("a:%d b:%d\n",a,b);
                ans1=std::max(ans1,b);//正方形边长,面积就乘一下..
                //ans2=std::max(ans2,a*up[i][j]);//长方形面积. 
            }
    printf("%d\n",ans1);
}
```
//其实悬线法题目写法都差不多...

//这里面有其他悬线法题目--->[这里](https://rpdreamer.blog.luogu.org/p1169)

~~可以去试试水(逃~~

---

## 作者：ResidualNight (赞：3)

没有人用dfs的吗？~~（滑稽~~

来一发。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1500+100;
int n,m,a[N][N],ans=-99,pd;
int dfs(int xx,int yy,int x,int y)
{
	bool k=a[xx][y];
	for(int i=xx; i<=x; i++){
		if(a[i][y]!=k) return 0;
		k=!k; //黑白交替，下同
	}
	k=a[x][yy];
	for(int i=yy; i<=y; i++){
		if(a[x][i]!=k) return 0;
		k=!k;
	}
	pd++; dfs(xx,yy,x+1,y+1); //每次边长++
	return pd;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		for(int k=1; k<=m; k++)
			cin>>a[i][k];
	for(int i=1; i<=n; i++) //枚举左上角
		for(int k=1; k<=m; k++){
			pd=0;
			ans=max(ans,dfs(i,k,i,k));
		}
	cout<<ans<<endl;
	return 0;
}
```

暴力大法好！！！~~（破音~~

---

## 作者：attack (赞：3)

首先我们考虑读入，我们让a[i][j]^=(i^j)&1;

这样我们就把题目转换成了求最大相同值的正方形问题（不懂的可以自己模拟一下）

对于正方形

我们只需要判断他的上，左，左上三个方向即可

方程:

```cpp
dp[i][j]=min(dp[i-1][j],dp[i][j-1]);
dp[i][j]=min(dp[i][j],dp[i-1][j-1]);
dp[i][j]++;
ans=max(ans,dp[i][j]);
```
前提条件：


```cpp
a[i][j]==a[i][j-1]&&a[i][j]==a[i-1][j-1]&&a[i][j]==a[i-1][j]
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
void read(int &n)
{
    char c='+';int x=0;bool flag=0;
    while(c<'0'||c>'9'){c=getchar();if(c=='-')flag=1;}
    while(c>='0'&&c<='9')
    {x=x*10+c-48;c=getchar();}
    flag==1?n=-x:n=x;
}
int n,m;
int a[1501][1501];
int dp[1501][1501];
int ans=0;
int main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            read(a[i][j]);
            a[i][j]^=(i^j)&1;
            dp[i][j]=1;
        }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]==a[i-1][j]&&a[i][j]==a[i][j-1]&&a[i][j]==a[i-1][j-1])
            {
                dp[i][j]=min(dp[i-1][j],dp[i][j-1]);
                dp[i][j]=min(dp[i][j],dp[i-1][j-1]);
                dp[i][j]++;
                ans=max(ans,dp[i][j]);
            }
        }
    }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：夏色祭 (赞：2)

##楼下dalao们的转移方程都没看懂。~~可能是我太菜了~~

##那我来水个不一样的吧

f[i,j]表示的是**包含(i,j)**这个点能组成的最大正方形

方程：

当(i,j)与(i-1,j)或(i,j-1)有重合的话，那么f[i,j]的值就为1

当(i,j)与(i-1,j)或(i,j-1)没有重合的话分两种情况

1、当f[i-1,j]与f[i,j-1]的值不同，取小的那个值+1 ~~可以自己用画图理解一下~~

2、当f[i-1,j]与f[i,j-1]的值相同，那就要看两个正方形（边长为f[i-1,j]，一个的右下角在(i-1,j)一个的右下角在(i,j-1)）相交而空出来的那个点((i-f[i-1,j],j-f[i-1,j]))和与它相邻的两个点是否不同，如果不同则f[i,j]:=min(f[i-1,j],f[i,j-1])+1，否则为f[i,j]:=min(f[i-1,j],f[i,j-1])

**似乎更像是分类讨论，看不懂的同学可以自己在画图里画下图** ~~这是最骚的~~

最终答案即为所有f[i,j]的max

边界:f[i,1]:=1 f[1,i]:=1

~~我是P党~~

code：



```cpp
uses math;
var
  b:array[0..1501,0..1501]of boolean;
  f:array[0..1501,0..1501]of longint;
  n,m,i,j,x,ans:longint;
begin
  readln(n,m);
  for i:=1 to n do 
    for j:=1 to m do 
      begin
        read(x);
        if x=1 then b[i,j]:=true;
      end;//读入
  for i:=1 to n do f[i,1]:=1;
  for i:=1 to m do f[1,i]:=1;//边界
  for i:=2 to n do 
    for j:=2 to m do
      begin
        f[i,j]:=1;
        if (b[i,j] xor b[i-1,j])and(b[i,j] xor b[i,j-1]) 
          then 
            begin
              if f[i-1,j]<>f[i,j-1] then f[i,j]:=min(f[i-1,j],f[i,j-1])+1
                else 
                  begin
                    f[i,j]:=min(f[i-1,j],f[i,j-1]);
                    if (b[i-f[i,j],j-f[i,j]] xor b[i-f[i,j]+1,j-f[i,j]])and(b[i-f
[i,j],j-f[i,j]] xor b[i-f[i,j],j-f[i,j]+1]) then 
                      inc(f[i,j]);
                  end;
            end;
        ans:=max(ans,f[i,j]);
      end; //dp
  writeln(ans);
end.

```

---

## 作者：Panthera_AFO (赞：1)

这题感觉跟最大正方形1一毛一样啊

就是转移条件变了变

f[i][j]表示右下角在(i,j)长度最大正方形

对于每一个f[i][j]，我们都希望去考虑他的子结构

包括:
1. 内部填充
2. 向左边延伸
3. 向右边延伸

然后对ij这个点特殊处理一下即可（显然只有(a[i][j]==a[i-1][j])!=(a[i-1][j]==a[i][j-1]才合法）

转移方程

```
if(!(a[i][j]^a[i-1][j-1]^a[i-1][j]^a[i][j-1]))
				f[i][j]=min(f[i-1][j-1],f[i-1][j],f[i][j-1])+1;
```
最后答案记得+1，原因很显然：没有初始化

【AC代码】
```
#include<iostream>
#include<cstdio>
#include<cstring>
int const maxn=1611,inf=0x1f1f1f1f;
int f[maxn][maxn],a[maxn][maxn],n,m,ans;
int min(int x,int y,int z)
{
	return std::min(std::min(x,y),z);
  	//没卵用
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(!(a[i][j]^a[i-1][j-1]^a[i-1][j]^a[i][j-1]))
				f[i][j]=min(f[i-1][j-1],f[i-1][j],f[i][j-1])+1;
                //与最大正方形1类似的转移
			ans=std::max(f[i][j],ans);
            //统计答案，因为答案不一定是哪一个右下角为(i,j)的正方形
		}
	printf("%d",ans+1);
    //补没有初始化的坑
	return 0;
}
```

---

## 作者：yuzhechuan (赞：1)

没想到就这么水过了。。。

代码很简单，但速度不一定是最快的，毕竟没有位运算

---

```cpp
#include <bits/stdc++.h>//万能头
#define rint register int//寄存器加速,约50ms
using namespace std;
int ans=1,n,m,a[1505][1505],f[1505][1505];//ans初始值1，毕竟一个数字就是一个正方形
int main()
{
	scanf("%d %d",&n,&m);
	memset(a,60,sizeof(a));//统一赋值无穷大（其实是懒得给a[i][0]打围墙）
    /*步骤一*/
	for(rint i=1;i<=n;i++)
		for(rint j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			if(a[i][j]+a[i][j-1]==1) f[i][j]=f[i][j-1]+1;
			else f[i][j]=1;//朴素的预处理：f[i][j]表示第i行第j个位置的前面（包括它自己） 最多能连多长1010...或0101...
		}
    /*步骤二*/
	for(rint i=1;i<=m;i++)//此处行和列要反着做
		for(rint j=1;j<=n-1;j++)
		if(f[j][i]>ans)//排除掉不可能优于当前最优解的情况
		{
			int MIN=f[j][i];
			for(rint k=j+1;k<=min(j+f[j][i]-1,n);k++)
			{
				MIN=min(MIN,f[k][i]);//MIN存当前搜索这一列的当前最小值
				if(a[k][i]==a[k-1][i]||MIN<=ans)//不满足01交错？无法成为最优解？退出！
					break;
				if(k-j+1==MIN) ans=MIN; //假如数量满足，是正方形，则替换最优解
			}
		}
	printf("%d",ans);//简单的输出
}
```

---

举个例子

输入
```cpp
4 4
1 1 1 1
1 0 1 1 
1 1 0 1
1 1 1 1
```

步骤一时的f数组：
```cpp
1 1 1 1
1 2 3 1 //观察可知，i=3,j=2时往下搜索是最优的，此时MIN也依次为3,2,1
1 1 2 3
1 1 1 1
```
输出

`2`



---

## 作者：RiverFun (赞：1)

先安利一发[Blog](https://stevebraveman.github.io/)

下面进入正题：

既然是最大正方形II，那肯定和[最大正方形](https://www.luogu.org/problemnew/show/P1387)有关系，所以我参考了一下我在那道题里的做法，然后对那种方法稍作改动，状态转移方程和那道题一样，也是$f[i][j]=\min\{f[i-1][j],f[i-1][j-1],f[i][j-1]\}$但是对于判断我修改了一下，判断语句如下：
```cpp
if(((a[i][j-1]^a[i][j])==1)&&(a[i-1][j-1]==a[i][j])&&(a[i-1][j]==a[i][j-1]))
```
下面我来解释一下这个特判：

由于题目要求要0和1相交错，所以对于每一个点$a_{i,j}$，它的斜上方的点肯定是和它的数字是一样的，而对于它每一个相邻的点状态肯定是相反的，所以我们可以得出：
```cpp
a[i][j]==a[i-1][j-1]
a[i][j-1]^a[i][j]==1
```
所以我们能得出以下代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int max(int a,int b) {
	return a>b?a:b;
}
int min(int a,int b) {//自己动手，丰衣足食
	return a<b?a:b;
}
int a[1502][1502],f[1502][1502],n,m,ans=0;
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			scanf("%d",&a[i][j]);
			f[i][j]=1;//预处理
			if(i>=2&&j>=2) {
				if(((a[i][j-1]^a[i][j])==1)&&(a[i-1][j-1]==a[i][j])&&(a[i-1][j]==a[i][j-1])) {//判断
					f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+1;//状态转移方程
					ans=max(ans,f[i][j]);//每次更新答案
				}
			}
		}
	}
	printf("%d",ans);
    return 0;//好习惯
}
```

---

## 作者：The_Stardust (赞：0)

```
首先我写的应该目前算本题跑得比较快的了（卡常了，当然小号测试跑得更快），也不太难理解...吧。
```
### 前置1：P1387最大正方形
我们有一个神奇的转移方程:（$dp[i][j]$表示以点$(i,j)$右下端点的最大正方形的边长的值）。
```cpp
dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
```
我们把它分析一下:

毫无诚意的图:
![](https://cdn.luogu.com.cn/upload/image_hosting/zki4g0hp.png)
可以发现这样更新的话当前正方形采用以上几个正方形中最小的边长+1显然OK，最后统计所有$dp[i][j]$最大值即可（不懂的就去题解区吧qwq）。

### *前置2：P1736创意吃鱼法（别管难度）

事实上这题与本题可以互相作前置qwq，给出方程:

```cpp
dp[i][j]=min(dp[i-1][j-1],min(fl[i][j-1],fu[i-1][j]))+1;
```
其中$fl[i][j]$是指第i行以j为右端点连续0序列长度，$fu[i][j]$是指第j列以i为下端点连续0序列长度。

仔细思索发现$dp[i][j]$的更新方法是左边一行和上面一列暴力，剩余通过$dp[i-1][j-1]$尝试转移，形象思考一下与上面方程的关系（当然这不是这题的唯一转移方程，具体看题）。

### 本题

方程：
```cpp
dp[i][j]=min(dp[i-1][j-1],min(fl[i][j],fu[i][j]))+1;
```
其中$fl[i][j]$是指第i行以j为右端点连续10101这样合法序列长度，
$fu[i][j]$是指第j列以i为下端点连续10101合法序列长度，感性理解一下是否与上题的更新有异曲同工之妙。

给出卡常后的完整代码，可读性很差，建议大家读懂了自己写，可读性会好很多。

很多细节在代码里了（知道你们不屑看qwq）:
```cpp
#include<cstdio>
using namespace std;
const int MAXN = 1505;
int n,m;
int a[MAXN][MAXN];
int fl[MAXN][MAXN],fu[MAXN][MAXN];
int dp[MAXN][MAXN];
int ans=1;
inline int max(int a,int b)
{
	return a>b?a:b;
}
inline int min(int a,int b)
{
	return a>b?b:a;
}
inline int read()
{
	int a=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') a=(a<<1)+(a<<3)+(ch^48),ch=getchar();
	return a;
}
inline void init()
{
	n=read(),m=read();
	for(register int i=1;i<=n;++i) a[0][i]=a[i][0]=-1;
}
inline void work()
{
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=m;++j)
		{
			a[i][j]=read();
			dp[i][j]=1;//很多细节，想明白
			if(a[i-1][j]!=a[i][j]) fu[i][j]=fu[i-1][j]+1;
			if(a[i][j-1]!=a[i][j]) fl[i][j]=fl[i][j-1]+1;
			if(a[i][j]!=a[i-1][j-1]) continue;//更新时要注意的点
			dp[i][j]=min(dp[i-1][j-1],min(fl[i][j],fu[i][j]))+1;
			ans=max(ans,dp[i][j]);
		}
	}
   //改进版卡常，但太难理解就不讲了
   //	for(register int i=1;i<=n;++i)
//	{
//		for(register int j=1;j<=m;++j)
//		{
//			a[i][j]=read();
//			dp[i][j]=1;
//			if(a[i][j]!=a[i-1][j-1]||a[i-1][j]==a[i][j]||a[i][j-1]==a[i][j]) continue;
//			dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
//			ans=max(ans,dp[i][j]);
//		}
//	}
	printf("%d",ans);
}
int main()
{
	init();
	work();
	return 0;
}//求给过，辛苦管理员大大了
```

---

## 作者：jbc392 (赞：0)

貌似没人用我这个思路

变量定义:

二维数组a存图，二维dp

样例图：

```
0 1 0
1 0 0
1 1 1
```
首先说我的思路

确定每个正方形的右下角的点，设这个点为（x ,y）

其实不难看出当a[x][y] = a[x - 1][y - 1]时才可能有正方形

然后在看此点上方可以得到的最大边长与左边可以得到的最大边长（定义一个结构体来存，要预处理）

如果最大边长都大于dp[x - 1][y - 1]则dp[x][y] = dp[x - 1][y - 1] + 1

否者dp[x][y] = min(左边最大边长 ,上方最大边长)

下面是AC代码

```
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1510;

int n ,m ,a[MAXN][MAXN];
int dp[MAXN][MAXN] ,ans = 1;

struct node
{
	int above;
	int left;
}t[MAXN][MAXN];

int read()
{
    int x = 0 ,y = 1;
    char c = getchar();
    while(c > '9' || c < '0')
    {
        if(c == '-')y = -1;
        c = getchar();
    }
    while(c <= '9' && c >= '0')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * y;
}

void pre(int x ,int y)
{
	for(int i = x - 1;i >= 1;i--)
	{
		if(a[i][y] != a[i + 1][y])t[x][y].above++;
		else break;
	}
	for(int i = y - 1;i >= 1;i--)
	{
		if(a[x][i] != a[x][i + 1])t[x][y].left++;
		else break;
	}
}

int main()
{
	n = read(); m = read();
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			a[i][j] = read();
		}
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			t[i][j].above++;
			t[i][j].left++;
			pre(i ,j);
		}
	}

	for(int i = 1;i <= n;i++)dp[1][i] = 1;
	for(int i = 1;i <= m;i++)dp[i][1] = 1;
	for(int i = 2;i <= n;i++)
	{
		for(int j = 2;j <= m;j++)
		{
			if(a[i][j] == a[i - 1][j - 1])
			{
				if(t[i][j].above > dp[i - 1][j - 1] && t[i][j].left > dp[i - 1][j - 1])
				{
					dp[i][j] = dp[i - 1][j - 1] + 1;
					ans = max(ans ,dp[i][j]);
				}else dp[i][j] = min(t[i][j].above ,t[i][j].left);
			}
		}
	}
	
	cout << ans;
	
	return 0;
}
```


---

## 作者：杨铠远 (赞：0)

其实二维dp就可以水过

设$f[i][j] $为$i,j$为右下角的最大符合条件的正方形

转移时判断以$i,j$为右下角的2x2的正方形是否符合条件

从上，左，左上取最小值+1转移过来

```cpp
//Code by : Y-k-y
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <set>
#define ll long long
const int N=100010;
using namespace std;
inline int rnd(){
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
inline void wr(int x){
	if(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');
}
int n,ans,m;
int a[1555][1555],f[1555][1555];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]=rnd();
			f[i][j]=1;
		}
	}
	for(int i=2;i<=n;i++){
		for(int j=2;j<=m;j++){
			int minn=1e9;
			if(a[i][j]==a[i-1][j-1]&&a[i-1][j]==a[i][j-1]&&a[i][j]!=a[i-1][j]){
				minn=min(minn,f[i-1][j]);
				minn=min(minn,f[i][j-1]);
				minn=min(minn,f[i-1][j-1]);
				f[i][j]=max(f[i][j],minn+1);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ans=max(ans,f[i][j]);
		}
	}
	wr(ans);
	return 0;
}

```
拜拜

---

## 作者：信赖滴星辰 (赞：0)

 刚开始考虑这道题时因为 最大正方形1 而思维定式了，一直把f数组考虑成二维的，因此一时间没想出来；
 
 后来重新定义定义了f数组：
 
 f [ i ] [ j ] [ k ] 表示： 当a [ i ] [ j ] = k 时, i排 、 j列 以上得到的最大正方形 
 
 因此可以的得到方程转换方程：
 
#### tem = a [ i ] [ j ] ;
		
#### f [ i ] [ j ] [ tem ] = 1 + min ( f [ i - 1] [ j - 1  ] [ tem ] , min ( f [ i - 1 ] [ j ] [ !tem ] , f [ i ] [  j - 1 ] [ !tem ] ) );

代码也很好敲了：

```cpp
#include <iostream>
using namespace std;

int n,m,ans,tem;
int a[1504][1504];
int f[1504][1504][2];  //f[i][j][k] 表示：当a[i][j]=k时, i,j以上得到的最大正方形 

int main()
{
	cin>>n>>m;
	
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=m; j++)
		{
			cin>>a[i][j];
		}
	}
	
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=m; j++)
		{
			tem = a[i][j];
		
			f[i][j][tem] = 1 + min( f[i-1][j-1][tem] , min( f[i-1][j][ !tem ] , f[i][j-1][ !tem ] ) );
			
			ans = max( ans , f[i][j][tem] );
		}
	}
	
	cout << ans <<endl;

return 0;	
}

```







---

## 作者：AFOier (赞：0)

~~思路很清奇~~

我用的方法是带有预处理的dp

先预处理出当前格向上和向左能拓展多少格（code中向上用u表示，向左用l表示），然后进行dp

注意预处理中拓展的格数包括这个格子本身（其实也可以不包括）

dp的思路是：

(1)对于颜色和左上方的格子不同颜色的格子，以它为右下角的最大黑白相间正方形边长只能为1

(2)对于颜色和左上方格子相同颜色的格子，比较以（它左上方的格子为右下角的最大黑白相间正方形边长+1），（它向上拓展的格子数），（它向左拓展的格子数），并取最小值作为以它为右下角的最大黑白相间正方形边长

即dp转移方程为：

$dp[i][j]=min(dp[i-1][j-1]+1,min(l[i][j],u[i][j]))$

------------

这里对dp转移方程给出~~难以看懂的~~证明，秒懂的神仙可跳过

对于以格子$(i,j)$为右下角的最大黑白相间正方形，假设它的边长不为1，那么它一定包含着以它左上方的格子，所以$a[i][j]$要等于$a[i-1][j-1]$

那么假设它向上和向左拓展的格子数均大于以它左上方的格子为右下角的最大黑白相间正方形的边长，那么它一定包含以它左上方的格子为右下角的最大黑白相间正方形，而且无法继续向左上方拓展，所以这时$dp[i][j]=dp[i-1][j-1]+1$

反之，如果以它左上方的格子为右下角的最大黑白相间正方形的边长大于它向上或向左拓展的格子数，那么它一定不完全包括以它左上方的格子为右下角的最大黑白相间正方形。所以此时$dp[i][j]=min(u[i][j],l[i][j])$

~~看不懂就算了吧~~

------------

$Code:$
```
#include <cstdio>
#include <iostream>
using namespace std;
int n,m,a[1501][1501],ans;
int u[1501][1501],l[1501][1501],dp[1501][1501];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		scanf("%d",&a[i][j]);
		if(a[i][j]!=a[i-1][j])
		u[i][j]=u[i-1][j]+1;
		else u[i][j]=1;
		if(a[i][j]!=a[i][j-1])
		l[i][j]=l[i][j-1]+1;
		else l[i][j]=1;
		if(a[i][j]==a[i-1][j-1]){
			dp[i][j]=min(dp[i-1][j-1]+1,min(l[i][j],u[i][j]));
		}
		else dp[i][j]=1;
		ans=max(ans,dp[i][j]);
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Dog_Two (赞：0)

### 预处理
将所有奇偶性相同的格子取反，问题就变成了“找一个最大的全0/1正方形”。

### 状态定义

定义f[i][j]为以(i,j)为右下角的最大正方形的边长

### 状态转移

状态转移有如下三种情况：
![](https://cdn.luogu.com.cn/upload/pic/34529.png )

其中：
- 蓝色为已经计算出的最大正方形，即f[i][j-1],f[i-1][j],f[i-1][j-1]；
- 粉色为当前正需要讨论的状态，即f[i][j];
- 粉色=蓝色+1的充要条件是蓝色、红色和黄色的区域全都是a[i][j]。

### 解决策略

- xpre[i][j],ypre[i][j]分别维护第i行前j个数/第j列前i行的前缀和;
- 每次转移时，O(1)check红色和黄色区域的区间和，它们必须为区间长度或0（取决于a[i][j]的值）。

代码如下(病态压行，请勿学习)：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1500+10;
int n,m,ans=1;
int a[maxn][maxn],xpre[maxn][maxn],ypre[maxn][maxn];
int f[maxn][maxn];

inline int neg(const int &x){return x?0:1;}
/*
void print(int k[maxn][maxn]){
	puts("");
	for(int i=1;i<=n;++i,puts(""))
		for(int j=1;j<=m;++j) cout<<k[i][j]<<" ";
}
*/
void read(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			scanf("%d",&a[i][j]),f[i][j]=1,
			a[i][j]=i&1?j&1?neg(a[i][j]):a[i][j]:j&1?a[i][j]:neg(a[i][j]),
			xpre[i][j]=xpre[i][j-1]+a[i][j],ypre[i][j]=ypre[i-1][j]+a[i][j];
}

void solve(){
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			if(i-1 and j-1 and a[i-1][j-1]==a[i][j] and xpre[i][j-1]-xpre[i][j-f[i-1][j-1]-1]==a[i][j]*f[i-1][j-1] and ypre[i-1][j]-ypre[i-f[i-1][j-1]-1][j]==a[i][j]*f[i-1][j-1])
				ans=max(ans,f[i][j]=max(f[i][j],f[i-1][j-1]+1));
			else if(i-1 and j-1 and a[i-1][j]==a[i][j] and xpre[i][j-1]-xpre[i][j-f[i-1][j]-1]==a[i][j]*f[i-1][j] and ypre[i-1][j-f[i-1][j]]-ypre[i-f[i-1][j]-1][j-f[i-1][j]]==a[i][j]*f[i-1][j])
				ans=max(ans,f[i][j]=max(f[i][j],f[i-1][j]+1));
			else if(i-1 and j-1 and a[i][j-1]==a[i][j] and ypre[i-1][j]-ypre[i-f[i][j-1]-1][j]==a[i][j]*f[i][j-1] and xpre[i-f[i][j-1]][j-1]-xpre[i-f[i][j-1]][j-f[i][j-1]-1]==a[i][j]*f[i][j-1])
				ans=max(ans,f[i][j]=max(f[i][j],f[i][j-1]+1));
	cout<<ans;
}

int main(){
	read();
	solve();
	return 0;
}
```

---

## 作者：ars4me (赞：0)

我们用map[][]存图

然后对于f[i][j]我们用来表示 **到矩阵的第i行第j列可以构造最大为多少的正方形**

所以初始化很容易得出 每一个格自身一开始都可以构成一个正方形

因此在读入的时候把每一个f[i][j]设为1

然后我们要取正方形 所以状态转移方程为

**f[i][j] = min(f[i - 1][j] , min(f[i][j -1] , f[i - 1][j - 1])) + 1**

并且要满足map[i - 1][j] != map[i][j] && map[i][j - 1] != map[i][j] && map[i -1][j - 1] == map[i][j]也就是题目要求

然后每次更新ans 取f[][]中的最大值就可以了

代码如下


    




                
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
    using namespace std;
    #define in = read();
    typedef long long ll;
    typedef unsigned int ui;
    const ll size = 1500 + 10;
        int n , m;
        int map[size][size];
        int ans = 1;
        int f[size][size];
inline ll read(){
        ll num = 0 , f = 1;    char ch = getchar();
        while(!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while(isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
int main(){
        n in;    m in;
        for(register int i=1;i<=n;i++)
                for(register int j=1;j<=m;j++){
                        map[i][j] in;
                        f[i][j] = 1;
                }
        for(register int i=1;i<=n;i++)
                for(register int j=1;j<=m;j++)
                        if(map[i - 1][j] != map[i][j] && map[i][j - 1] != map[i][j] && map[i -1][j - 1] == map[i][j]){
                                f[i][j] = min(f[i - 1][j] , min(f[i][j -1] , f[i - 1][j - 1])) + 1;
                                ans = max(ans , f[i][j]);
                        }
```
/\*
```cpp
        cout<<endl;
        for(register int i=1;i<=n;i++){
                for(register int j=1;j<=m;j++)
                        cout<<f[i][j]<<" ";
                cout<<endl;
        }*/
        printf("%d" , ans);
}
```

---

## 作者：发源于 (赞：0)

[color=red]最终思想是动规[/color]

##刚开始的思想是扩展

就是先确定一个正方形的大小l（每次累加），扫描每个大小为l的正方形左下角的点，然后查一遍整个矩形

[color=red]呵呵,肯定超时[/color]

##接着想到一种奇葩的动归

每次累加l，然后在f数组中存放以[i,j]这个位置为正方形的左下角l为正方形长度是否能有正方形（存的是maxl），（就差一步），当f[i-1,j]>=l-1且f[i-1,j-1]>=l-1且f[i,j-1]>=l-1时f[i-1,j]=l因为左，左上，上的最大正方形长度都>=l-1，所以肯定存在（[color=red]为什么?[/color]）

最坏情况l=1500，n=m=1500,o(nml)>10亿，超！

##突然想到为什么要每次累加l

其实就是在[i-1,j],[i,j-1],[i-1,j-1],[i,j]这四个组成交错正方形时

f[i,j]=min(f[i,j-1],f[i-1,j-1],f[i-1,j])+1

因为既然是min

则三个正方形变长都>=min

所以加上[i,j]后边长一定=min+1[color=red]（很难，自己画个图好好理解）[/color]

就这样

取max(f)就行了（[color=purple]伪代码[/color]）

============================================================================

========================人造分割线（忘了分割线的ubb了）=====================

============================================================================

[color=red]下面核心代码有n个错误，小心被坑哦！[/color]

核心代码如下

```delphi

begin
{读入（我读在数组a中），预处理}
    for i:=2 to m do
      for j:=2 to n do
        if (a[i-1,j-1]=a[i,j]) or (a[i-1,j]=a[i,j]) or (a[i,j-1]=a[i,j]) then
          f[i,j]:=min(f[i-1,j-1],f[i-1,j],f[i,j-1])+1;
{然后提取max就行了}
{其实提取max可以集成在上面的for循环中，只是我懒得写begin，end（估计这么奇葩的就我一个）}
  writeln(ans);
end.

```

---

## 作者：flash666 (赞：0)

为什么没有暴力的？那我就来水一发暴力的吧！

首先说一下暴力的思路：枚举每一个点，求出以这个点为左上角顶点的最大正方形，然后取最大值即可。

当然，这样做肯定稳稳T飞，所以要加几个优化

1 若前面已经有了边长为n的正方形，则直接从边长n+1开始搜

2 如果已经搜到不满足题意的（如越界，两个相连的正方形颜色相同），直接果断跳出，搜下一个点

~~暴力出奇迹~~，上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,p[1501][1501];
int main()
{
	cin>>m>>n;
	int ma=1;//记录最大值
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		cin>>p[i][j];
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)//搜索从每一个点为左上角顶点的最大值
		{
			int ac=1;//记录是否满足题意
			while(ac)
			{
				for(int s=0;s<ma+1;s++)//直接从最大值+1开始搜
				{
					if(s+i>m)//越界
					{
						ac=0;
						break;
					}
					if(s!=0&&p[s+i][j]==p[s+i-1][j])//与上一个比较，若想等，直接跳出
					{
						ac=0;
						break;
					}
					for(int t=1;t<ma+1;t++)
					{
						if(t+j>n)//越界
						{
							ac=0;
							break;
						}
						if(p[s+i][j+t]==p[i+s][j+t-1])//比较
						{
							ac=0;
							break;
						}
					}
				}
				if(!ac)break;
				ma++;//最大值+1，继续搜
			}
			
		}
	}
	cout<<ma;
        return 0;
}
```




---


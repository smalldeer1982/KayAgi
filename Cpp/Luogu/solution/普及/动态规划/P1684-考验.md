# 考验

## 题目描述

大家知道，黄药师不仅武功高超，而且酷爱音乐和诗歌。看到桃花岛来了个新客人，而且不是靠真武功进来的，就准备为难为难你。

他写了一首 $N$ 行诗句的诗歌，美中不足的是这些诗句并不押韵，黄药师非常想遵循古诗的押韵。诗歌被分为若干段，每段都是四行诗。每一句诗都有一个韵脚，假如 $A$ 和 $B$ 表示两种不同的韵脚，每段四行诗的韵脚只可能是 `AABB`，`ABAB`，`ABBA` 和 `AAAA` 中的一种。

黄药师将诗句的韵脚都编了号，具有相同编号的句子代表有相同的韵脚。现在，黄药师想删掉一些句子，使得剩下的都是遵循押韵规则的四行诗，而且不允许改变诗句的顺序。

现在就问你：如何找出满足条件最长的诗歌？

## 说明/提示

提示：

删除第 $3$、$6$、$13$ 句诗，就可以分成 $3$ 个四行诗，分别为：

- $1,2,4,5$；
- $7,8,9,10$；
- $11,12,14,15$。


## 样例 #1

### 输入

```
15
1 2 3 1 2 1 2 3 3 2 1 1 3 2 2
```

### 输出

```
3
```

# 题解

## 作者：神阈小杰 (赞：52)

本题可以用贪心来做(本人动规不咋地QAQ)

思路：

**首先按顺序用map来记录当前每个韵脚出现次数**

题目中要求四行诗满足“AABB”、“ABAB”、“ABBA”和“AAAA”中的一种，**即有一种韵脚出现四次或两种韵脚各出现两次**

**故若前出现次数超过两次的韵脚数有两个或有一个韵脚出现次数出现次数为四次，答案就加一且清空记录的数**

代码如下：
```
# include <map>
# include <cstdio>
using namespace std;
int n,x;
map <int,int> f;
int s;
int ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		f[x]++;
		if(f[x]==2) s++;
		if(s==2)
		{
			ans++;
			s=0;
			f.clear();
		}
		if(f[x]==4)
		{
			ans++;
			s=0;
			f.clear();
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Tarsal (赞：12)

本蒟蒻又来发题解啦！

这个题的正解应该是贪心

直接找题目的关键：

#### 韵脚只可能是 “AABB”, “ABAB”, “ABBA” 和“AAAA”中的一种

我们来观察韵脚，是不是都是2个'A'和2个'B';

'AAAA'可以看作'A'与'B'相同

那么现在不就是个简单的贪心了吗？

如果有两个出现2个相同的数字就ans++

上代码：

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;

#define maxn 10010
int n, m, k, a[maxn], f[maxn], c[maxn], x, ans, flag;

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i)
	{
		scanf("%d", &x);//输入 
		a[i] = c[i] = x;
	}
	sort(c + 1, c + n + 1);
	m = unique(c + 1, c + n + 1) - c;//去重 
	for(int i = 1; i <= n; ++ i)
	{
		k = lower_bound(c + 1, c + m + 1, a[i]) - c;
		a[i] = k;
	}
	for(int i = 1; i <= n; ++ i)//求解 
	{
		++ f[a[i]];
		if(f[a[i]] == 2) 
		{
			++ flag;
			f[a[i]] = 0;
		}
		if(flag < 2)
			continue; 
		flag = 0;
		++ ans;
		memset(f, 0, sizeof(f));
	}
	printf("%d", ans);
	return 0;
}
```


---

## 作者：假假 (赞：9)

Solution DP

1.f[i]表示以i结尾的诗句中可能构成的做多的诗段数，同时记一下满足当前诗段数时，诗结尾的部分有几个句子还没有用过；

2.当开始考虑当前新的长度时，如果前一状态诗结尾的部分没用过的句子数≥3，那么当前就有可能构成新的诗段；

3.那么这时我们从第一个没有使用的位置开始往后暴力验证，注意结尾不需要枚举，直接使用当前位置即可，因为dp保证最优子结构；

4.注意初始化边界前三个未使用状态的个数分别为1,2,3。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int f[4040][2]={},num[4040],n,m,i,j,k;

inline int rd(){
	int x=0;
	bool f=true;
	char c;
	c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=false;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return f?x:-x;
} 

bool check(int x){
	int a,b,c,d;
	for(a=x-f[x-1][0];a<=x-3;++a)
		for(b=a+1;b<=x-2;++b)
			for(c=b+1;c<=x-1;++c){
					if(num[a]==num[b]&&num[c]==num[x])return true;
					if(num[a]==num[c]&&num[b]==num[x])return true;
					if(num[a]==num[x]&&num[b]==num[c])return true;
					if(num[a]==num[b]&&num[b]==num[c]&&num[c]==num[x])return true;
				}
	return false;
}

int main(){
	n=rd();
	for(i=1;i<=3;++i){
		f[i][0]=i;
		f[i][1]=0;
	}
	for(i=1;i<=n;++i)num[i]=rd();
	for(i=4;i<=n;++i){
		if(f[i-1][0]>=3&&check(i)){
			f[i][1]=f[i-1][1]+1;
			f[i][0]=0;
		}
		else{
			f[i][1]=f[i-1][1];
			f[i][0]=f[i-1][0]+1;
		}
	}
	printf("%d\n",f[n][1]);
	return 0;
}
```

---

## 作者：permzf (赞：8)

### 这题的思路其实是贪心！！！

我们其实可以O(n)地去求.

注意到,如果我们枚举到的位置能够组成一句诗,

那么将他们计入答案,再往后枚举显然是最好的,

因为后面的句子就有机会组成新的诗句(蒟蒻讲的不太清楚感性理解一下吧qwq).

**然而,真正要讲的是诗句的判断!!**

我们可以掰着指头数一下(偷笑),

当有两个韵脚A,B分别出现两次后,会是什么情况:

AABB,ABAB,ABBA,

当A,B相同时:AAAA.

**没错,都能组成诗!**

所以,我们只需要记录下每个韵脚出现的次数,

当有两个两次后,就统计答案就行了.

上代码吧:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

inline int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return f*sum;
}

int n,a[10001],f[10001]/*韵脚出现的次数*/;
int c[10001]/*离散化*/;
int ans=0,ok=0;

int main(){
    n=read();
    for(int i=1;i<=n;i++) a[i]=read();
    memcpy(c,a,sizeof(c));
    sort(c+1,c+n+1);
    int m=unique(c+1,c+n+1)-c;
    for(int i=1;i<=n;i++){
        int k=lower_bound(c+1,c+m+1,a[i])-c;
        a[i]=k;		
    }
    for(int i=1;i<=n;i++){
        f[a[i]]++;
        if(f[a[i]]==2) ok++,f[a[i]]=0/*这里清零是因为可能会是四个一样的韵脚*/;
        if(ok<2) continue;
        ok=0;ans++;
        memset(f,0,sizeof(f));
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：X_yea (赞：5)

# Solution

假设用f[i]表示在i号韵脚之前最多能够得到的四行诗个数  

对于第i号韵脚可以选或者不选  

不选:f[i]=max(f[i],f[i-1]);  

选:再在前面选三个数看是否满足条件，如果满足则f[x]=max(f[x],f[now-1]+1);其中now为这句诗中的第一个韵脚(或者说是选的最后一个)  

具体操作就在代码里了

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,a[4010],b[5],f[4010];//b数组是这句话
int x;

void dfs(int now,int step)
{
	if(step==5)//如果已经选好
	{
   	  //判断是否满足要求
		if(b[1]==b[2]&&b[3]==b[4])
			f[x]=max(f[x],f[now-1]+1);
		else if(b[1]==b[3]&&b[2]==b[4])
			f[x]=max(f[x],f[now-1]+1);
		else if(b[1]==b[4]&&b[2]==b[3])
			f[x]=max(f[x],f[now-1]+1);
		else
			return;
	}
	for(int i=now-1; i>=1; i--)
	{
		if(f[i]+1<=f[x])//如果即使选择的这句诗符合要求但比现在的小，直接返回
			return;
		else
		{
			b[step]=a[i];
			dfs(i,step+1);
			b[step]=0;
		}
	}
}

int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=n; i++)
	{
		x=i;
		f[i]=max(f[i],f[i-1]);//不选
		b[1]=a[i];//选的第一个数是自己
		dfs(i,2);
		//cout<<f[i]<<" ";
	}
	cout<<f[n];
	return 0;
}
```


---

## 作者：Grace_White (赞：2)

## 题解 P1684 【考验】
【题目简述】

    删掉一些句子，使得剩下的都是遵循押韵规则的四行诗，而且不允许改变诗句的顺序，求满足条件最长的诗歌。

【解题算法】

    模拟
【解题思路】

    每个值在前面(注意说明)找一个与它一样的，如果找到了，那么累加的变量加一。如果变量中的值为2，那么已经可成一组。
    注意：如果组成一组，以后找的时候就必须在这一组的后面找。
 
    这是样例解释的图
(![](https://cdn.luogu.com.cn/upload/image_hosting/ll3gso8a.png))

【AC代码】

```pascal
var n,i,j,s,sum,k:longint;
a:array[0..1000000] of longint;
f:array[0..1000000] of boolean;
begin
readln(n);
for i:=1 to n do read(a[i]);
for i:=1 to n do
  begin
  for j:=i-1 downto k+1 do
    if (a[i]=a[j]) and (f[j]=false) then//没有被选过
      begin
      inc(s);
      f[i]:=true;f[j]:=true; //已经被选过
      break;//已经找到了，可以不用做了
      end;
  if s=2 then//如果有两个找到了，就可以组成一组。
    begin
    k:=i;//后面的必须在这组的后面找
    s:=0;
    inc(sum);// 就可以组成一组
    end;
  end;
writeln(sum);
end.
```



---

## 作者：zwjdd (赞：2)

贪心

尽可能的在已经连接起来的诗歌后面接上新的诗歌

新建一个last存储上次匹配串的末尾的后一个字符

每当当前点的位置到last的长度大于四，有可能成为新串的时候

暴力判断是否可以成为诗歌，若成功更新答案和last

我们用f[i]表示以i结尾的诗歌数

所以每次更新是f[last-1]+1

若不成功f[i]=f[i-1]
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
typedef long long ll;
const int maxn = 4005;
ll num[maxn];
ll f[maxn];
ll n;
bool flag(ll l,ll r)
{
	int t=0;
	int nn[maxn];
	nn[4]=num[r];
	for(int i=l;i<r;i++)
	{
		nn[++t]=num[i];
		for(int j=l;j<r;j++)
		{
			if(j==i)continue;
			nn[++t]=num[j];
			for(int k=l;k<r;k++)
			{
				if(k==j||k==i)continue;
				nn[++t]=num[k];
				if((nn[1]==nn[2]&&nn[3]==nn[4])||((nn[1]==nn[4]&&nn[2]==nn[3])||(nn[1]==nn[3]&&nn[2]==nn[4])))return true;
				t--;
			} 
			t--;
		}
		t--;
	}
	return false;
}
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&num[i]);
	f[0]=0;
	ll last=1;
	for(int i=1;i<=n;i++)
	{
		if(i-last+1>=4)
		{
			if(flag(last,i))
			{
				f[i]=max(f[i],f[last-1]+1);
				last=i+1;
			}
			else f[i]=f[i-1];
		}
		else f[i]=f[i-1];
	}
	cout<<f[n];
} 
```

---


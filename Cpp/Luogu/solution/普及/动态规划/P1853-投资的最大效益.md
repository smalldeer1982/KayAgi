# 投资的最大效益

## 题目背景

约翰先生获得了一大笔遗产，他暂时还用不上这一笔钱，他决定进行投资以获得更大的效益。银行工作人员向他提供了多种债券，每一种债券都能在固定的投资后，提供稳定的年利息。当然，每一种债券的投资额是不同的，一般来说，投资越大，收益也越大，而且，每一年还可以根据资金总额的增加，更换收益更大的债券。


## 题目描述

例如：有如下两种不同的债券：

1. 投资额 $\$4000$，年利息 $\$400$；
2. 投资额 $\$3000$，年利息 $\$250$。

初始时，有 $\$10000$ 的总资产，可以投资两份债券 1 债券，一年获得 $\$800$ 的利息；而投资一份债券 1 和两份债券 2，一年可获得 $\$900$ 的利息，两年后，可获得 $\$1800$ 的利息；而所有的资产达到 $\$11800$，然后将卖掉一份债券 2，换购债券 1，年利息可达到 $\$1050$；第三年后，总资产达到 $\$12850$，可以购买三份债券 1，年利息可达到 $\$1200$，第四年后，总资产可达到 $\$14050$。

现给定若干种债券、最初的总资产，帮助约翰先生计算，经过 $n$ 年的投资，总资产的最大值。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le s \le {10}^6$，$2 \le n \le 40$，$1 \le d \le 10$，$1 \le a \le {10}^4$，且 $a$ 是 $1000$ 的倍数，$b$ 不超过 $a$ 的 $10\%$。

## 样例 #1

### 输入

```
10000 4 2
4000 400
3000 250```

### 输出

```
14050```

# 题解

## 作者：Sham_Sleep (赞：137)

~~这道题是本蒟蒻刷过最水的背包题~~（小声bb）


------------


当本蒟蒻第一眼看到这道题的时候，满满文学气息铺面而来。

以本蒟蒻小学三年级的阅读水平，想要一次性完全看懂还是很难的。

所以我分了三次看：

1.这个题目不能将债券拆开来投资，也就是必须投整个进去。
（胖虎发现了不对劲）。也就是说，我们不能按照贪心的思路求单位价值再排序。

2.初步可以断定是dp了，但是，这个dp是将各种债券不停搭配来求到最值。也就是说这个dp是一个物品对应着一种阶段。并且求完之后还要再循环求下一年的。

3.那么可以确定他是背包了。他的数量是无限的。不同于选和不选。所以可以确定这是个完全背包题。

那么，这个题的主体代码就可以拆成两部分了——完全背包的模板+n次循环求解

也就是说，我们要将每一年得到的钱再加上本金，投入下一年的投资，这样才能实现最值（题目里没有限制，也就是说这样可以的）

至于有的同学没有学过背包，可以先到网上搜一下，本蒟蒻在这里贴出我写的01背包和完全背包

01背包

```
#include <stdio.h>
#include <iostream>
#include <map>
using namespace std;
int dp[1000000];
int w[100000];
int v[100000];
int main()
{
	int n,t;
	scanf("%d%d",&t,&n);
	for(int i=1; i<=n; i++){
		scanf("%d%d",&w[i],&v[i]);                                                           
	}
	for(int i=1; i<=n; i++){
		for(int j=t; j>=w[i]; j--){
			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
		}
	}
	printf("%d",dp[t]);
}
```

完全背包
```
#include <stdio.h>
#include <iostream>
using namespace std;
int dp[1000];
int w[1000];
int v[1000];
int m,n;
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1; i<=n; ++i){
		scanf("%d%d",&w[i],&v[i]);
	}
	for(int i=1; i<=n; ++i){
		for(int j=0; j<=m; ++j){
			if(j>=w[i]) dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
		}
	}
	printf("max=%d",dp[m]);
	return 0;
}
```
接下来，就上本题AC代码啦——

```
#include <stdio.h>
#include <iostream>
#include <memory.h>
using namespace std;
int w[100000];
int v[100000];
int dp[100000];
int s,n,d;
int main()
{
	scanf("%d%d%d",&s,&n,&d);
	for(int i=1; i<=d; ++i){
		scanf("%d%d",&w[i],&v[i]);
	}
	for(int i=1; i<=n; ++i){
		int m=s/1000;
		for(int j=1; j<=d; ++j){
			for(int k=w[j]/1000; k<=m; ++k){
				if(k>=w[j]/1000) dp[k]=max(dp[k],dp[k-w[j]/1000]+v[j]);
//				printf("%d ",dp[k]);
			}
//			printf("\n");
		}
		s+=dp[m];
		memset(dp,0,sizeof(dp));

	}
	printf("%d",s);
}
```

第二次写题解，支持一下本蒟蒻吧（QwQ）


---

## 作者：卷王 (赞：19)

## 题目大意

有 $d$ 种债券，第 $i$ 种需要 $a_i$ 的资产，会获得 $b_i$ 的成本。现在告诉你总资产以及债券的种类数，要你求 $n$ 年后能有多少钱。

## 思路

我们设 $dp_i$ 表示拥有 $i$ 资金下的最大利息。

状态转移：$dp_j = \max(dp_j, dp_{j - v_i} + w_i)$。

这题只是在完全背包上套了个皮，在外面模拟每一年即可。 

非常详细的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int property, year, kind, ans = 0;
int v[17], w[17];
int dp[1000007];
int main() {
	cin >> property >> year >> kind; //s, n, d 资产，年数，种类 
	ans = property; //记得加上原先的资产 
	for(int i = 1; i <= kind; i++) {
		cin >> v[i] >> w[i]; //a, b 投资额，年利息 
		v[i] /= 1000; //由于题目说了 v[i] 是 1000 的倍数，正好可以除以 1000 来减少空间 
	}
	for(int k = 1; k <= year; k++) { //模拟每一年 
		memset(dp, 0, sizeof(dp)); //注意初始化 
		int t = ans / 1000; //确定上限 
		//下面就是完全背包的板子 
		for(int i = 1; i <= kind; i++) //枚举几种债券 
			for(int j = v[i]; j <= t; j++) //上限 
				dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
		ans += dp[t]; //累加答案 
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Ggsddu_zzy (赞：16)

[题目传送门](https://www.luogu.com.cn/problem/P1853)

[更好的阅读体验](https://www.cnblogs.com/zzyblog0619/p/17254300.html)

#### 题目大意

有初始总资产 $s$ 和债券种数 $d$，每种债券有投资额和年利息，求 $n$ 年后的最大总资产。

#### 解题思路

完全背包问题（每种债券可以投资多次）。

把当前总资产看成背包，把债券看成物品。

枚举年数，每次做完全背包，并把最后得到的最大总资产累加，投资到下一年。

完全背包：

- 划分阶段：当前的债券；
- 状态表达：$f_j$ 表示投资钱数 $j$ 所获得的最大利息；
- 状态转移：$f_j=\max(f_j,f_{j-w_i}+v_i)$；
- 初始状态：$f_j=0$；
- 求解目标：$f_{sum}$（$sum$ 为上一年的最大总资产）；

注意求每年的最大总资产时先将 $f$ 数组**清零**。

优化：题目中说**债券的投资额**是 $1000$ 的倍数，所以可以把债券的投资额都除以 $1000$（$sum$ 也要除以 $1000$），最后的结果不变。

#### 代码

[AC 记录](https://www.luogu.com.cn/record/105762904)

```c++
#include<bits/stdc++.h>
#define ri register int
using namespace std;
int m,n,d;
int w[15],v[15],f[1000005];
int main() {
	cin>>m>>n>>d;
	int sum=m;//初始总资产
	for(ri i=1; i<=d; i++)cin>>w[i]>>v[i];
	for(ri k=1; k<=n; k++) {
		memset(f,0,sizeof(f));//初始状态（清零） 
		for(ri i=1; i<=d; i++)//阶段 
			for(ri j=w[i]/1000; j<=sum/1000; j++)//决策 
				f[j]=max(f[j],f[j-w[i]/1000]+v[i]);//状态转移
		sum+=f[sum/1000];//累加最大总资产
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：coser (赞：5)

### -1 前言
看到本题的所有题解均用的是三层嵌套的循环解题，复杂度为 $O(n^3)$，对于本题的数据范围可以通过，但我将介绍一种 $O(n^2)$ 的做法。
### 0 题意
共有 $n$ 年可以进行投资，有 $d$ 种债券，分别对应本金 $a_i$ 及年利息 $b_i$，投资时使用前一年的本息和进行投资。

### 1 思路
典型的完全背包问题。

假设 $f_i$ 代表本金为 $i$ 时一年获得的利息。那么，它的状态转移方程为 $f_i=\max(f_i,f_{j-a_i}+b_i)$。

之后设 $ans$ 为目前的资金总数，再对每一年进行更新即可，此时的复杂度为 $O(n^3)$，代码可以参考其它题解。

### 2 优化
接下来对空间复杂度和时间复杂度进行优化。
- 空间复杂度：题中提到 $a$ 是 $1000$ 的倍数，我们可以进一步优化转移方程，将 $f_i$ 定义为当本金为 $i\times 10^3$ 时一年获得的利息。
- 时间复杂度：由题意可得，假如你手里有 $x$ 元，那么对于这 $x$ 元，在任何一年获得的最大利息相等，故我们可以先求出所以情况的最大利息，在循环里带入即可，时间复杂度下降为 $O(n^2)$。

### 3 代码
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int s,n,d,ans;
int m[15],l[15],f[maxn];
int main(){
	cin>>s>>n>>d;
	for(int i=1;i<=d;i++){
		cin>>m[i]>>l[i];
		m[i]/=1000;//空间复杂度优化
	}
	ans=s;//先算入本金
	for(int i=1;i<=d;i++){
		for(int j=m[i];j<=maxn-10;j++){
			f[j]=max(f[j],f[j-m[i]]+l[i]);//每次更新当本金为j时的最大利息
		}
	}
	while(n--){
		int flag=ans/1000;
		ans+=f[flag];//每次增加最大利息
	}
	cout<<ans<<endl;//输出
}
```

---

## 作者：qwerty12346 (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P1853)

## 题意

就是求约翰先生 $n$ 年后的最大总资产。

## 思路

直接动态规划。

## 状态定义

$dp_{j}$ 表示投资钱数 $j$ 所获得的最大利息。

## 状态转移方程

$dp_{j}=\max(dp_{j},dp_{j-x_{i}÷1000}+y_{i})$

## 边界条件

每枚举一年就将 $dp$ 数组清零一次。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,x[1000005],y[1000005],f[1000005];
int main(){
    cin>>a>>b>>c;
    for(int i=1;i<=c;i++)cin>>x[i]>>y[i];
    for(int k=1;k<=b;k++)
    {
	memset(f,0,sizeof(f));//将dp数组清零
	for(int i=1;i<=c;i++)
        {
            for(int j=x[i]/1000;j<=a/1000;j++) 
            {
                f[j]=max(f[j],f[j-x[i]/1000]+y[i]);//状态转移方程
            }
        }
	a+=f[a/1000];
    }
    cout<<a;
    return 0;
}
```


---

## 作者：SGOI_Aromyase (赞：4)

可以看到题目中的描述s≤10^6，n≤40且a是1000的倍数，b不超过a的10%。

如果我们使用最坏的情况，需要空间10^6\*（1+10%）\*40，数组将开的特别大

但是既然a是1000的倍数，我们可以将动态数组压缩一下，空间可以减小为10^6\*（1+10%）\*40/1000

并且速度也可以优化许多倍！

至少我感觉题目就是设置了这个卡常，如果s<=10^7,楼下的方法就没用了

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int w[15],c[15],f[1000000],ans[900];
int main(){
    int s,n,d,dp;scanf("%d%d%d",&s,&n,&d);
    for(int i=1;i<=d;i++) scanf("%d%d",&w[i],&c[i]);
    int gett=0;//记录年得到的利息数，一开始赋初值0
    for(int i=1;i<=n;i++){//背包次数，完全背包！ 
        s+=gett;dp=s/1000;//dp压缩，节省空间
        for(int as=1;as<=999999;as++) f[as]=0;//为了循环使用dp数组，使用前清空，这种次数无关大雅
        for(int ii=1;ii<=d;ii++){//和下一行一样，完全背包的套路
            for(int v=w[ii]/1000;v<=dp;v++){
                f[v]=max(f[v],f[v-w[ii]/1000]+c[ii]);//注意，w[ii]的值也要压缩
            }
        } 
        gett=f[dp];//寻找最大利息
    }
    printf("%d",f[dp]+s);//输出答案
    return 0;
}
```

---

## 作者：Sun_Email (赞：2)

显然，这是一道背包的题，具体思路就是做 $n$ 次完全背包。

不过，介于 $s \le 10^6,n \le 40$ 以及 $b \le 10^3$ 的限制，直接背包很可能会 `MLE` 掉。如何压空间呢？

首先，也是最简单的，就是开滚动数组，这样能够简单 `AC`，~~不过不符合我们追求最优解的态度~~。

观察到题目中说 $a$ 是 $1000$ 的倍数，所以可以把 $a$ 每天的本金各除以 $1000$，这样的话$dp$ 数组仅需开到 $5 \times 10^4$。

下面上 `AC` 代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int s,n,d,dp[10001];
struct ZQ{
	int ct,f;
}a[41];
int backpack(int all){
	memset(dp,0,sizeof(dp));
	for(int i=1;i<=d;++i){
		for(int j=0;j<=all;++j){
			if(j>=a[i].ct){
				dp[j]=max(dp[j],dp[j-a[i].ct]+a[i].f);
			}
		}
	}
	return *max_element(dp,dp+all+1);
}
int main(){
	scanf("%d%d%d",&s,&n,&d);
	for(int i=1;i<=d;++i){
		scanf("%d%d",&a[i].ct,&a[i].f);
		a[i].ct/=1000;
	}
	for(int i=1;i<=n;++i){
		s+=backpack(s/1000);
	}
	printf("%d",s);
	return 0;
}
```
完结撒花

---

## 作者：jb123456 (赞：2)

完全背包，可以把投资额看成重量，年利息看成价值，因为能多次投资一份债券，所以是完全背包。

因为一年的投资可以用到下一年，所以 $s$ 需要在枚举年份之后加上最大利息。

因为年数越大，本金越多，所以 $f$ 数组不需要重置为 $0$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000005],c[15],w[15];
int main()
{
	int s,n,d;
	cin>>s>>n>>d;
	for(int i=1;i<=d;i++){
		cin>>c[i]>>w[i];
		c[i]/=1000;//避免爆空间。
	}
	for(int i=1;i<=n;i++){
		int h=s/1000;
		for(int j=1;j<=d;j++)
			for(int z=c[j];z<=h;z++)
				f[z]=max(f[z],f[z-c[j]]+w[j]);//完全背包。
		s+=f[h];//加上最大利息。
	}
	cout<<s;
	return 0;
}
```


---

## 作者：SHUxxt (赞：2)

## 完全背包
### 思路
用$dp[i]$表示拥有$x$资金下的最大利息
### 空间优化
因为$a$是1000的整数倍，所以可以将本金除以1000以节省dp空间。

具体细节参考代码注释
### AC代码
```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 10;
struct node {
    int w, v;
};
int s, n, d;
vector<node> v;
int dp[maxn]; //拥有x资金下的最大利息
int solve()
{
    int tot; //该年的本金
    int w = 0; //该年最多得到的利息
    for (int i = 1; i <= n; i++) { 
        s += w; //更新当前年份的本金
        /*
        把当前的本金除以1000后，当作新的本金
        虽然除以1000以后会有小数，但因为a是大于等于1000的，这些小于1000的钱也不可能用来购买
        故不会对结果产生影响
        */
        tot = s / 1000; 
        for (int j = 1; j <= d; j++) { //完全背包部分
            for (int k = v[j].w / 1000; k <= tot; k++) {
                dp[k] = max(dp[k], dp[k - v[j].w / 1000] + v[j].v); 
            }
        }
        w = dp[tot]; //在该年所拥有的本金tot下能获得最大利息
    }
    return dp[tot] + s;
}
int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> s >> n >> d;
    v.resize(d + 1);
    for (int i = 1; i <= d; i++) {
        cin >> v[i].w >> v[i].v;
    }
    cout << solve() << endl;
    return 0;
}
```

---

## 作者：Jerrythepro123 (赞：1)

题目意思是给定 $d$ 个债券，每个债卷价格为 $a$ 每年都会创造 $b$ 的利息。你有 $s$ 资产，计算出 $n$ 年后最高资产。

这道题就是变形背包问题。 

Q. 什么是背包问题？

A. 有 $n$ 个物品分别有自己的重量 $w$ 和价值 $v$，你的背包只能装下 $W$ 的容量，求最多背包能装的价值。

背包问题典型模版。

```

public class Knapsack {
    public static void main(String[] args){
        Scanner test = new Scanner(System.in);
        int w[]={0,2,5,4,2,3}; //物品重量
        int v[]={0,6,3,5,4,6}; //物品价值
        int W=10; //背包容量
        int dp[]=new int[W+1]; //建立背包
        for(int i=1;i<=w.length-1;i++){ //循环每个物品
            for(int j=W;j>=w[i];j--){ 
                dp[j]=Math.max(dp[j],dp[j-w[i]]+v[i]); 
            }
        }
        System.out.println(Arrays.toString(dp));
    }
}
```

这个代码 $j$ 代表背包容量，$dp_{j}$ 代表该重量对应的最大值。总体 dp 的公式是 $\mathit{dp}_{i}=\max({dp}_{i},  {dp}_{i-w_{i}}+v_{i})$。

回到正题，如何解这道题？我们想象每一个债券价格为一个物品重量  $w$，对应的利息为价值 $v$，出始资金为背包容量 $W$。因为题目要求很多年的总额，我们的 $W$ 是动态的，dp 大小设大一点。这样很快可以建立模版。
```

int s=test.nextInt(); //这里s代表背包的容量W
int n=test.nextInt();
int d=test.nextInt(); //d代表物品数量
int[]w=new int[d+1]; //建立物品数组，为了方便舍弃 w[0]
int[]v=new int[d+1]; 
int[]dp=new int[100000];

```

做完初始化就可以进入代码主题，直接带入模版即可算出答案。可是由于题目特殊，需要计算年份，所以在 dp 主题外面添加一个代表年份的循环。这里 dp 代码需要注意，债卷是可以重复购买，所以是无限背包，循环也需要更改。

```

for(int xx=0;xx<y;xx++) { //年份模拟
   for (int i = 1; i <= w.length - 1; i++) {
         for (int j = w[i]; j <= n; j++) { //无限背包要正着循环，不是翻着循环
               dp[j] = Math.max(dp[j],dp[j - w[i]] + v[i]); //使用动态规划(dp)来算出一年的最优解
         }
   }
   n=n+dp[n]; //每年更新现有资金
}
```

到这答案已经出来了，就是我们的 $n$，可是由于数据较大，我们无法在给定的空间这题，所以我们必须用题目给出的特性 $a$ 是 $1000$ 的倍数。这样我们可以对代码所有的 $w_{i}$ 也代表 $a_{i}$ 除以 $1000$。

最终的代码放着了。

```
import java.util.*;

public class Main {
    public static void main(String[] args){
        Scanner test = new Scanner(System.in);
        int n=test.nextInt();
        int y=test.nextInt();
        int d=test.nextInt();
        int[]w=new int[d+1];
        int[]v=new int[d+1];
        int[]dp=new int[100000];
        for(int i=1;i<=d;i++){
            w[i]=test.nextInt();
            v[i]=test.nextInt();
        }
        for(int xx=0;xx<y;xx++) {
            for (int i = 1; i <= w.length - 1; i++) {
                for (int j = w[i]/1000; j <= n/1000; j++) {
                    dp[j] = Math.max(dp[j],dp[j - w[i]/1000] + v[i]);
                }
            }
            n=n+dp[n/1000];
        }
        System.out.println(n);
    }
}
```



---


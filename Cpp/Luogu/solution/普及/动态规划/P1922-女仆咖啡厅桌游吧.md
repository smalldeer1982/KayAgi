# 女仆咖啡厅桌游吧

## 题目背景

小 v 带萌萌的妹妹去玩，妹妹想去女仆咖啡馆，小 v 想去桌游吧。

妹妹：“我问你个问题，答不对你就做我一天的奴隶，答对了就今天我就全部听你的。”

小 v ：“全部都听!?”

妹妹：“嘻嘻嘻，你还是回答问题吧！”

于是小 v 为了自己一天的幸福，来向你求助。

## 题目描述

小 v 所在的世界被规划成了树形结构，每一个节点上都可以建一个女仆咖啡厅或者桌游吧或者什么都不建。在确定点 $1$ 为根节点之后，规划局要求：对于每一个非叶子的节点 $i$，设它子树（包括自己）中所有的女仆咖啡厅的数量为 $cafe_i$，桌游吧数目为 $table_i$，都有 $cafe_i=table_i$。

妹妹的问题是：这颗树最多能放多少个女仆咖啡厅。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le20$。
- 对于 $100\%$ 的数据，保证 $1\le n\le10^5$，$1 \leq u, v \le n$。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
2 5
```

### 输出

```
2```

# 题解

## 作者：bellmanford (赞：17)

因为奇怪的名字和奇怪的背景才来写的。。。

话说这和差分有什么关系吗。。。



------------


由于对于每个节点$u$都要求满足$cafe_u==table_u$

假设该节点的除叶子节点以外的所以儿子都已知其最多能放多少个女仆咖啡厅

由于已经满足$cafe_u==table_u$的关系，并不会对节点$u$的答案有什么影响

所以直接加就行了

对于剩下的节点$($也就是叶子节点和节点$u$本身$)$，根据贪心的思路，尽可能对半分

所以答案再加上剩下节点总数除以二的值 

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int M=1e5+5;

int n,tot=0,in[M],ans[M],first[M];
struct Egde{
	int nxt,to;
}e[M<<1];

int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*y;
}

void add(int x,int y){
	tot++;
	e[tot].nxt=first[x];
	first[x]=tot;
	e[tot].to=y;
}

void dfs(int u,int fa){
	int sum=1;//记录剩余节点个数 
	for(int i=first[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		if(in[v]==1) sum++;
		else ans[u]+=ans[v];
	}
	ans[u]+=sum/2;
}

int main(){
	n=read();
	for(int i=1;i<=n-1;i++){
		int x=read(),y=read();
		add(x,y),add(y,x);
		in[x]++,in[y]++;//利用入度来判断是否为叶子节点 
	}
	dfs(1,0);
	printf("%d\n",ans[1]);
}
```


---

## 作者：1000001001wj (赞：13)

**正在我准备交题解时，发现有人提前交了，令我很尴尬于是我决定用一种OP的方法来诠释这道题**

首先，[AC链接](https://www.luogu.org/record/show?rid=2391079)

215ms比第二快15ms（然并卵）

好，开始正文

等等，我先解释一波，由于算法比较玄学，所以需要画图，然而蒟蒻我并不知道怎么把图传到网站上，所以，大家将就着拿笔画一下吧。。。

我们先看样例吧（其实是我懒的造数据），算了还是自己造吧，好像不太好，来一波输入（只有边）

1 2
2 3
3 4
4 5
5 6
4 7
2 8
好的就这样吧

先说点别的（感觉今天非常语无伦次）

首先如果答案想要增加，必然要有其它的叶节点的参与，因为内部节点全部为偶数，在内部节点间传递不会增加，所以内部节点间互不干扰，所以只要统计每个内部节点连接的叶节点数就好，因为**内部节点算作自己的子树的一部分**，所以如果一个内部节点连接的叶节点数为奇数，则内部节点开一个店，否则不开，那么很容易想到统计度数为一的点然后找唯一与其相连的点并使该点的权值加一，每当**权值为奇数时**就**++ans**，进一步，因为奇偶只看最后一位二进制，所以每次只要让权值异或1就好了，接下来，因为奇数时加而奇数时权值为一，那么我们简单粗暴一点，直接ans+=权值^=1就好

接下来上代码

```cpp
#include <iostream>
using std::cin;
using std::cout;
using std::endl;
int n;
int u,v;
int ans;
int sum[100001];
bool ok[100001];
int b[100001];
inline void cl(int,int);
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n;
    for (int i=1;i<n;++i){
        cin>>u>>v;
        cl(u,v);
        cl(v,u);
    }
    for (int i=1;i<=n;++i)
        if (ok[i])
            ans+=sum[b[i]]^=1;
    cout<<ans<<endl;
}
inline void cl(int bg,int ed){
    if (b[bg]==0){
        b[bg]=ed;
        ok[bg]=true;
    }
    else ok[bg]=false;
}
```
最后的最后提醒大家，上来就namespace不好，真的不好。。。


---

## 作者：xhQYm (赞：12)

- [P1922 女仆咖啡厅桌游吧](https://www.luogu.com.cn/problem/P1922)

一道很好的树形DP的基础题。

树形DP状态表示都很单一，$f_i$ 表示以 $i$ 为根的子树的某些信息。

再这题里面，$f_i$ 表示以 $i$ 为根的子树最多能放的女仆咖啡厅的个数。

如果遇到叶子节点，将计数器+1，如果不是，将 $f_x$ 加上 $f_j$ 即可，最后再加上计数器除以 $2$ （尽可能多）即可。这就是状态转移。

然后怎么判断叶子节点？记录入度即可，如果入度为 $1$ ，就代表只有 $1$ 条边与之相连，就是叶子节点了。

如果不懂直接看代码，有注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=N*2;
int n;
int h[N],e[M],ne[M],idx;
int d[N],f[N];
void add(int a,int b){e[idx]=b,ne[idx]=h[a],h[a]=idx++;}
bool check(int x)
{
    return d[x]==1?true:false;
}//根据入度判断是否为叶子节点
void dfs(int x,int last)
{
    int cnt=1;
    for(int i=h[x];~i;i=ne[i])
    {
        if(e[i]==last) continue;
        //由于为双向边，防止无限递归，所以多记录一个last，表示上次到达的点，如果不是上次到达的点再走
        int j=e[i];
        dfs(j,x);
        if(check(j)) cnt++;//如果是叶子节点，计时器+1
        else f[x]+=f[j];
        //以上为转移转移
    }
    f[x]+=cnt/2;//加上计数器除以二
}
int main()
{
    memset(h,-1,sizeof h);  
    scanf("%d",&n);
    int a,b;
    for(int i=1;i<n;i++)//n-1条边
    {
        scanf("%d%d",&a,&b);
        add(a,b),add(b,a);
        d[a]++,d[b]++;//记录入度
    }
    dfs(1,-1);
    printf("%d",f[1]);
    return 0;
}

```

~~难得树形DP有一道黄题~~

---

## 作者：江屿 (赞：6)

这个题，一看标签，树形dp？？？

于是苦思冥想树形dp，感觉很恶心。

突然发现递归就可以解决了。

思路就是从根节点（1）开始递归，遍历它的所有子节点，如果子节点不是叶子节点，那么该点的sum（已经建造的**咖啡厅的数量）就加上遍历到的子节点的sum值，如果这个节点是叶子节点，就把该点的tot（空闲但可以建造东西的节点的数量）++，最后把sum+tot/2就是这个点的咖啡厅的总数量啦。

代码：

```cpp
#include<cstdio>
#include<iostream>
#define N 100010
using namespace std;
int next[N*2],to[N*2],num,head[N],n,a,b,vis[N];
int add(int false_from,int false_to){
    next[++num]=head[false_from];
    to[num]=false_to;
    head[false_from]=num;
}
int dp(int x){
    vis[x]=1;
    int tot=1,sum=0;//由于该点也可以建造，所以tot一开始的值就是1 
    for(int i=head[x];i;i=next[i]){
        int u=to[i],v;
        if(!vis[u]){
            v=dp(u);
            if(v)//自己试试就可以发现，除非是叶子节点，否则该点一定有sum>0 
                sum+=v;//加上子节点的咖啡厅数量 
            else
                tot++;//叶子节点tot++ 
        }
    }
    if(tot>=2)
        sum+=tot/2;//把空闲的都利用起来，一半咖啡厅 
    return sum;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;++i){
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);//一开始按单向边存的，惨遭爆零 
    }
    printf("%d",dp(1));//默认1是根节点（题目中有说哦） 
    return 0;
}
```

---

## 作者：dingshengyang (赞：5)

这题树形 DP。

- 什么是「树形 DP」？

答：所谓「树形 DP」，也是动态规划（DP）的一种。「树形 DP」通常在树上进行。通常使用深搜，也就是 DFS 为媒介。

---

废话少说，开始。

- 状态定义：这里，我们发现，任何一个节点都要满足题目中桌游吧（以下简称「桌」）和女仆咖啡厅（以下简称「厅」）个数相同。所以，容易发现，你自己合法，但是你儿子不合法，你要完蛋；你儿子合法，但是你自己不合法，你还是要完蛋。所以，不要考虑这个地方到底放什么，只需要知道以这个节点为树根的子树能放多少厅就可以了。$f_i$ 表示以 $i$ 节点为树根的子树能放多少厅。

- 状态递推：前面也说过，你儿子不行，整棵树都要被拉下水，所以，让你儿子自己的事情自己办，自己做到合法，然后你再把没有生孙子的儿子，也就是该节点的儿子数为 $0$（包括你自己，这是特例）统计一下，**这些地方放什么与你儿子没有关系**。当然，设没有关系的节点数是 $sum$，可以一个放桌，一个放厅，答案可以增加 $\lfloor \dfrac{sum}{2} \rfloor$ 个。其他的节点，让儿子自己处理。$f_i = \sum{f_x}$ （x 有后代）$+ \lfloor \dfrac{sum}{2} \rfloor$。

为了加深读者的理解，再配张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aqky6evq.png)

完事，放代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
const int N = 1e5+5;
vector<int> G[N];//G[i]表示 i 的儿子列表
int in_degree[N];//入度，如果入度为 0 则表示是叶子结点
int f[N];//不解释
void dp(int x,int father){//当前节点是 x ，有 father 递归而来
	int free_total = 1;//自己也算「自由节点」
	for(int i = 0;i < G[x].size();i ++){//查找儿子们
		if(G[x][i] == father)continue;//如果不特判，就会无限递归！！！
        //A->B,B->A……
		if(in_degree[G[x][i]] == 1)free_total ++;//叶子结点，计数器++
		else {
			dp(G[x][i],x);//递归求解
			f[x] += f[G[x][i]];//加上儿子的贡献
		}
	}
	f[x] += free_total/2;//「自由节点」中，一个咖啡厅，一个桌游吧，如果还有剩余就啥也不放
}
int main() {
	cin >> n;
	for(int i = 1;i < n;i ++){
		int x,y;
		cin >> x >> y;
		G[x].push_back(y);//建图
		G[y].push_back(x);
		in_degree[x] ++;//入度++，注意是双向边
		in_degree[y] ++;
	} 
	dp(1,0);//递归
	cout << f[1] << endl;
	return 0;
}

```

---

## 作者：cjhspeed (赞：4)

# **分享解法，巧妙大法师**
## **看到树状，作为树形dp并不拿手的蒟蒻，乖乖的把爪子伸向搜索**
### 虽然是搜索，但是本质上和动态规划还是有着点联系
#### 显然的女仆店数量不可能直接满足n/2
#### 树形结构的图，从根节点开始搜索各个分叉的最小树（分支全为叶子节点），所能生成的最大女仆数值，来向上回溯
以样例为参考，所得的最小树为3—4，能生成最多一个女仆，回溯至2，能生成的还单纯只有1个吗？自然不是，因为2—5 还能生成一个女仆（千万注意2—5并不能算是子树）

所以我们发现，非最小子树也可以包含叶子节点，那么它通过最小树来进行更新的同时自己也可以再加上部分来自根节点和叶子节点（这并不算个子树）所能生成的最多女仆
## **那么我们**
- 在dfs的过程中首先判断这下一个连着的树枝走没走过（f【】，因为是无向图，~~有向图也要其实~~）
- 判断下个点是不是叶子节点，如果是，不走！因为我们只走子树，顺便进行叶子节点数量的统计
- 判断这是不是最小子树，特征就是支路上全是叶子节点（flag）
- 如果是最小子树我们并不会遍历到他的任何节点，但是数量是已知的 G[u].size（）（减掉一条回路再加上一个根节点）
- 并在回溯的过程中再判断自己的值能否更大并再跟新前驱的值
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,V[N]={0};
bool f[N];
vector<int> G[N];
  
void input()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
}
                         
void dfs(int hd,int u) 
{//以1位树根，遍历每个分支的子树分支的子树…… 
	f[u]=1; 
	
	int Kd=0;//记录叶子节点的个数 
	bool flag=0; //判断是否是最小子树 
	for(int i=0;i<G[u].size();i++)
	{//u —>v 
		int v=G[u][i];
		
		if(f[v]) continue;//因为是无向图防止走回头路
	 
		if(G[v].size()==1) 
		{//如果是叶子节点则不走 
			Kd++;
			continue; 
		}
		
		flag=1;//非该支路上的最小子树 
		dfs(u,v);//go on 
	}
	
	if(flag==0) //该支路为最小子树 
		V[u]=G[u].size()/2;//最多能放的女仆
	//实际上是该最小子树上的所有叶子加根，也可以理解为（Kd+1）/2 
		 
	else V[u]+=(1+Kd)/2;//如果非最小子树但也接了叶子 
	//就加上已dfs形成的值的基础上，再加上(根与叶子)/2 
    
	if(u!=1) V[hd]+=V[u];//防止ans*2	
}
  
int main()
{
	input();
	dfs(1,1);
	cout<<V[1];
}
```


## 管理员大大，求过！！！

---

## 作者：Panthera_AFO (赞：3)

血泪史就不发了，对拍数据起码有6个，查错过程起码有十几行...

这道题一眼看过去感觉能秒，结果硬是查了1h还是过不了，

后来对拍的时候突然想到，根节点也可以算“叶子结点”，于是就过了

本题未借鉴任何题解，纯靠手模

个人思路是砍树，本来想统计子树大小，后来想想不用，那些对答案没有贡献的点直接砍掉就好
```
#include<iostream>
#include<cstdio>
#include<cstring>
int const maxn=101100,maxm=210,inf=0x1f1f1f1f;
int n,ans,ind[maxn];
struct E
{
	int to,next;
	E(int to=0,int next=0):
		to(to),next(next){}
}e[maxn<<1];
int head[maxn],cnt;
void add(int u,int v)
{
	e[++cnt]=(E){v,head[u]};
	head[u]=cnt;
}
int dfs(int u,int fa)
{
//树上dfs
	int size=1,flag=false;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		flag=true;
		size+=dfs(v,u);
	}
	ans+=size/2;
	if(!flag)
		return 1;
        //不砍
	return 0;
    //砍
} 
int main()
{
	int root;
	scanf("%d",&n);
	for(int x,y,i=1;i<n;i++)
		scanf("%d%d",&x,&y),add(x,y),add(y,x),ind[x]++,ind[y]++;
	for(int i=1;i<=n;i++)
		if(ind[i]>1)
		{
			root=i;
			break;
		}
        //核心思路：换根
	dfs(root,0);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Da_un (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P1922)

仔细想了想这道题，应该是一道树形动态规划的题目。在这里说句题外话，大家在做题的时候，尽量不要看标签，要自己动脑去思考，因为在考场上，没人会告诉你这是道什么题。

## 思路
考虑到是一道树形动态规划的题目后，剩下的就比较好操作了。

仔细读题可知，因为每一个非叶子结点的子树的状态都是唯一的确定的，所以只需要把某个节点的儿子中的叶子节点的个数统计出来，然后将所有答案按顺序累加起来即可。而对于叶子结点，我们只统计个数便于它父亲节点的累加。

题目中给出根节点是 $1$ 节点，那么我们就从 $1$ 节点开始深搜，最后输出统计好的 $1$ 节点的答案即可。

具体实现看代码。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define MAXN 100100
using namespace std;
int n;
int u,v;
int fa[MAXN],f[MAXN],num[MAXN],sum[MAXN];
struct node{
	int to;
	int nxt;
}edge[MAXN*2];//注意数组范围 
int head[MAXN],size;
void add(int from,int to)
{
	edge[++size].to=to;
	edge[size].nxt=head[from];
	head[from]=size;
}//链式前向星 
void dfs(int x)//在树上进行dfs 
{
	sum[x]=1;//标记 
	for(int i=head[x];~i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v!=fa[x]){
			fa[v]=x;
			dfs(v);//一直搜叶节点 
			if(sum[v]==1)//叶节点 
				num[x]++;//只统计自身 
			else//有子节点 
				f[x]+=f[v];//加上子节点所统计的数量 
			sum[x]+=sum[v];//脱离子节点 
		}
	}
	f[x]+=(num[x]+1)/2;//(计数器+1)/2是为了防止奇数时造成的误差 
	return;
}
int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);//进行连边 
	}
	dfs(1);//从根节点开始搜 
	printf("%d\n",f[1]);//输出根节点的答案,即为总和 
	return 0;
   //完结撒花~~
}
```
### [AC记录](https://www.luogu.com.cn/record/60538445)

---

## 作者：翼德天尊 (赞：2)

练习 $\text{dp ing}$。

------------

树形结构 + 只考虑子树 ≈ 树形 $\text{dp}$ !

树形 $\text{dp}$ 的思路就是通过 $\text{dp}$ 到的子树的结果转移根。基础格式大概为：

```cpp
bool dp(int u,int fa){
	for (int i=head[u];i;i=e[i].next){//这里是链式前向星存图
		int v=e[i].to;
		if (v!=fa){
			dp(v,u);
			//do something...
		}
	}
}
```

而对于本题，因为限制的条件只针对非叶子节点，所以我们就可以对叶子节点和非叶子节点分成两类处理。

对于叶子节点，我们可以只记录个数，再考虑分配。

对于非叶子节点，我们只需将所有子树的答案加起来即可。

设 $f_i$ 为对于 $i$ 号非叶子节点及其子节点的答案，$all$ 为所有叶子节点子树的个数，$m$ 为所有非叶子节点子树的个数，则：

$$f_i=\sum_{j=1}^{m}f_j+(all+1)\div2$$

### AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
int n,head[N],tot,f[N];
struct node{
	int to,next;
	node (int to=0,int next=0)
		:to(to),next(next){}
}e[N<<1];
int read(){
	int w=0,fh=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') fh=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*fh;
}
void adde(int u,int v){
	e[++tot]=node(v,head[u]);
	head[u]=tot;
}
bool dp(int u,int fa){
	bool pd=1;
	int all=0;
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if (v!=fa){
			pd=0;
			bool get=dp(v,u);//判断该儿子的节点性质
			if (get) ++all;
			else f[u]+=f[v];
		}
	}
	if (pd) return 1;
	f[u]+=(all+1)/2;
	return 0;
}
int main(){
	n=read();
	for (int i=1;i<n;i++){//存图
		int u=read(),v=read();
		adde(u,v),adde(v,u);
	} 
	dp(1,0);//从根开始
	printf("%d\n",f[1]);
	return 0;
}
```


---

## 作者：lingerleaf (赞：2)

看了其他dalao的方法都是存无向图的，感觉很多人都和本蒟蒻一样不知道为啥，一番思考之后本蒟蒻终于开窍了。

本题有一点奇怪，因为你不知道输入的数据，哪个是父亲结点，哪个是子节点。并不是说这道题的树是一颗假树，而是故意不告诉你让你自己去判断。

看过其他dalao的题解之后，dalao们通过存无向图的方法。你不知道谁是父亲谁是儿子，但是已知1一定是根节点，然后从1开始遍历与自己相连的，通过vis保证只遍历一次，第一次遍历到的就一定是子结点，这样无向图就变成了有向图，就知道了父亲和儿子。而本蒟蒻通过判断的方法存树了，1一定是父亲结点，所以1在前那么前是父亲，后是儿子，反过来那么也反。知道了一组父亲和儿子，我们就判断两个输入的数字哪个已有父亲，另一个还没父亲的，它的父亲就一定是另一个，然后就完成了存图。

存图，我们就可以得到一个父子分明的树，然后愉快地DP

DP规则：如果这个结点底下有叶子结点，那么首先将自己所有叶子结点数量全部计算出来再+1整除2。然后再加上将非叶子结点dfs它，这样递归即可。

```cpp
#include<cstdio>
#include<vector>
using namespace std;
int n;
vector<int>v[100001];
bool havep[100001],haves[100001];
/*
本结点加叶子节点数量整除2
再加上非叶子节点的dfs
*/
int dfs(int node){
	int tot=0;
	int leaves=1;
	for(vector<int>::iterator i=v[node].begin();i!=v[node].end();i++){
		if(!haves[*i])	leaves++;
		else{
			tot+=dfs(*i);
		}
	}
	tot+=leaves/2;
	return tot;
}
void add(int a,int b){//a是父亲，b是儿子地存
	v[a].push_back(b);
	haves[a]=true;
	havep[b]=true;
}
int main(){
	int a,b;
	scanf("%d",&n);
	for(register int i=1;i<n;++i){
		scanf("%d %d",&a,&b);
		if(a==1){
			add(a,b);
		}else if(b==1){
			add(b,a);
		}else{
			if(havep[a]){
				add(a,b);
			}else{
				add(b,a);
			}
		}
	}
	printf("%d",dfs(1));
} 
```

---

## 作者：cmd2001 (赞：2)

线性时间随便搞啊！

显然两种建筑物的数量是相等的。我们用dp[i]来表示节点i极其子树的建筑物最大组数。

我们考虑对于每个节点，如果他的子节点都是叶节点，那么，他的dp值即为他的siz除以2。

如果这个节点的子节点有不是叶节点的，那么，这些节点的状态在本层不能改变，能改变的只有自己状态和自己的为叶节点的子节点的状态。

我们用cnt来表示每个节点的<为叶节点的子节点>的数量和自身<1>数量的总和，则我们的答案就是sigma(cnt[i]>>1)；

很少在洛谷上做题，随便水水......

——Cmd2001


最后代码







    
    
    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+1e2;
int siz[maxn],cnt[maxn],dp[maxn],n;
int s[maxn],t[maxn<<1],nxt[maxn<<1];
bool vis[maxn];
inline void addedge(int from,int to)
{
    static int cnt=0;
    t[++cnt]=to;
    nxt[cnt]=s[from];
    s[from]=cnt;
}
inline void doubleedge(int a,int b)
{
    addedge(a,b);
    addedge(b,a);
}
inline void pre(int pos)
{
    cnt[pos]=siz[pos]=1;
    int at=s[pos];
    while(at)
    {
        if(!vis[t[at]])
        {
            vis[t[at]]=1;
            pre(t[at]);
            siz[pos]+=siz[t[at]];
            if(siz[t[at]]==1) ++cnt[pos];
        }
        at=nxt[at];
    }
}
inline void dfs(int pos)
{
    dp[pos]=cnt[pos]>>1;
    int at=s[pos];
    while(at)
    {
        if(!vis[t[at]])
        {
            vis[t[at]]=1;
            dfs(t[at]);
            dp[pos]+=dp[t[at]];
        }
        at=nxt[at];
    }
}
inline void getans()
{
    vis[1]=1;
    pre(1);
    memset(vis,0,sizeof(vis));
    vis[1]=1;
    dfs(1);
}
int main()
{
    scanf("%d",&n);
    for(int i=1,a,b;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        doubleedge(a,b);
    }
    getans();
    printf("%d\n",dp[1]);
    return 0;
}

```

---

## 作者：Yang818 (赞：1)

## 题目

[传送门](https://www.luogu.com.cn/problem/P1922)

## 分析

本蒟蒻是在练习dp时发现的这道题目，题目中其实已经提示得特别明显了——“数形结构”，又因为只考虑子树上的关系，由此可以看出是树形dp。大概的思路就是有子树的数据转移到根上。

本题中，由于对叶子节点和非叶子节点的要求不同，则需要进行两类操作。

1. 如果是叶子节点，那么只需记录该数据

2. 如果是非叶子节点，只需要由子树的数据推上来，再进行操作。

$f_i$ 表示以 $i$ 为根节点的子树（$i$ 不是叶子节点) 上最多能放的女仆咖啡厅的数量。

$k$ 表示非叶子节点的个数

$$f_i=\sum_{j=1}^{k}f_j+ \left\lceil \dfrac{cnt}{2} \right\rceil $$

十分短小的状态转移方程

这边注意向上取整的时候一定是 $cnt$ 先加一再除

## AC代码

~~裸的不行的树形dp~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,u,v;
int head[100010],size,g_f[100010],f[100010],cnt[100010],cur[100010];
struct tNode{
	int v,nxt;
}g_e[200010];
void add_edge(int u,int v){//链式前向星
	g_e[++size].v=v;
	g_e[size].nxt=head[u];
	head[u]=size;
}
void dfs(int x){
	cur[x]=1;
	for(int i=head[x];~i;i=g_e[i].nxt){
		int v=g_e[i].v;
		if(v==g_f[x])
			continue;
		g_f[v]=x;
		dfs(v);
		if(cur[v]==1)//叶子节点情况
			cnt[x]++;
		else//非叶子节点情况
			f[x]+=f[v];
		cur[x]+=cur[v]; 
	}
	f[x]+=(cnt[x]+1)/2;
	return;
}
int main(){	
	memset(head,-1,sizeof(head));
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs(1);
	cout<<f[1];
}
```
望通过，谢谢


---


# 迷之阶梯

## 题目描述

在经过地球防卫小队的数学家连续多日的工作后，外星人发的密码终于得以破解。它 告诉我们在地球某一处的古老遗迹中，存在有对抗这次灾难的秘密武器。防卫小队立即赶 到这处遗迹。要进入遗迹，需要通过一段迷之阶梯。登上阶梯必须要按照它要求的方法， 否则就无法登上阶梯。它要求的方法有以下三个限制：

1. 如果下一步阶梯的高度只比当前阶梯高 1，则可以直接登上。

2. 除了第一步阶梯外，都可以从当前阶梯退到前一步阶梯。

3. 当你连续退下 k 后，你可以一次跳上不超过当前阶梯高度 $2^{k}$的阶梯。比如说你现 在位于第 j 步阶梯，并且是从第 j+k 步阶梯退下来的，那么你可以跳到高度不超过当前阶 梯高度+$2^{k}$的任何一步阶梯。跳跃这一次只算一次移动。

开始时我们在第一步阶梯，由于时间紧迫，我们需要用最少的移动次数登上迷之阶梯。 请你计算出最少的移动步数。


## 说明/提示

【样例解释】

连续登 3 步，再后退 3 步，然后直接跳上去。

【数据范围】

对于 50%的数据：1≤N≤20。

对于 100%的数据：1≤N≤200。

对于 100%的数据：每步阶梯高度不超过 2^31-1


## 样例 #1

### 输入

```
5
0  1  2  3  6 
```

### 输出

```
7```

# 题解

## 作者：x_faraway_x (赞：38)

//其实不太理解为什么我们老师把他当BFS练习题，汗……

这题的n^3的dp还是很容易想到的。设f[i]为到达第i个阶梯所需要的最少步数，可以从一下状态转移来：

1. f[i-1]+1 (a[i-1]+1==a[i])

2. f[j]+j-k+1 (a[k]+2^(j-k)>=a[i[, 1<=j<i, 1<=k<j)

第一个方程应该很好理解就是直接跳，第二个中的j表示从第j的阶梯跳到第i个阶梯，k表示从j后退k步，方程应该也很好理解，按照题意来就行了。

初始化是f[1]=0,f[i]=inf(2<=j<=n)，最后的答案就是f[n]啦

时间复杂度为O(n^3)，是可以通过的。

一道很好的线性动态规划基础练习题，当然看到题解貌似有n^2的做法也不知道是乱搞还是正解什么的……也希望看到有写BFS的同学在题解区发言QwQ

下面贴代码。由于上面思路应该讲的差不多了，所以代码就没有注释了。

```cpp
#include<cstdio>
#include<cstring>
#define Min(x,y) (x<y?x:y)
const int N=206;
int a[N],n,f[N];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    memset(f,0x3f,sizeof(f));
    int oo=f[0];
    f[1]=0;
    for(int i=2;i<=n;i++)
    {
        if(a[i]<=a[i-1]+1) f[i]=f[i-1]+1;
        for(int j=i-1;j>0;j--)
            for(int k=j-1;k>0;k--)
                if((1<<(j-k))+a[k]>=a[i]) f[i]=Min(f[i],f[j]+j-k+1);
    }
    printf("%d\n",f[n]>=oo?-1:f[n]);
}
```

---

## 作者：LJC00118 (赞：15)

### 实在不明白为什么大家会把这道题当dp
### 这明明是一道广搜题啊
### 队列里只需要记录三个变量
* now 表示现在在第几个柱子

* k 表示向下跳了几格

* len 表示跳的次数

### 然后就是正常广搜的思路了（别忘记加hash）
### 以下是代码
```cpp

#include<bits/stdc++.h>
#define LL long long// 有点害怕爆 int ,所以用了 long long
#define N 201
using namespace std;

struct ele
{
    int now, k, len;// 结构体内的三个成员
};

queue <ele> q;
bool used[N][N];// hash
LL a[N], f[71];// f 预处理出了 2 的 i 次方
int n;

inline LL read()// 快速读入，可加可不加
{
    LL f = 0, fu = 1;
    char c = getchar();
    while(c < '0' || c > '9')
    {
        if(c == '-') fu = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        f = (f << 3) + (f << 1) + c - 48;
        c = getchar();
    }
    return f * fu;
}

int main()
{
    memset(used, 0, sizeof(used));
    f[0] = 1;
    for(int i = 1; i <= 66; i++) f[i] = f[i - 1] << 1;// 预处理
    n = read();
    for(int i = 1; i <= n; i++) a[i] = read();
    q.push((ele){1, 0, 0});// 将起点加入队列
    used[1][0] = 1;
    while(!q.empty())// 普通广搜的思路啦
    {
        ele u = q.front(); q.pop();
        if(u.now == n)// 如果到终点了,输出答案
        {
            cout << u.len;
            return 0;
        }
        if(u.now != 1 && used[u.now - 1][u.k + 1] == 0)// 尝试退后一格
        {
            used[u.now - 1][u.k + 1] = 1;
            q.push((ele){u.now - 1, u.k + 1, u.len + 1});
        }
        for(int i = u.now + 1; i <= n; i++)// 尝试向上跳跃
        {
            if(a[i] <= a[u.now] + f[u.k] && used[i][0] == 0)
            {
                used[i][0] = 1;
                q.push((ele){i, 0, u.len + 1});
            }
        }
    }
    cout << -1;// 表示不能到
    return 0;
}


```

---

## 作者：Drifterming (赞：14)

/\*让dp[i]为跳到i的最小步数。

1、sta[i]==sta[i-1]+1 --> dp[i]=dp[i-1]+1

2、dp[i]=min(dp[i],dp[j + k]+k+1) 其中k=log2(sta[i]-sta[j])，表示从i到j要退几步。\*/





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,ans=999999999;
int sta[205],dp[205];
inline int read(int &num)
{
    num=0;
    char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar()){num=num*10+c-'0';}
}
int main()
{
    memset(dp,0x3f,sizeof(dp));
    read(n);
    for(int i=1;i<=n;i++)
    {
        read(sta[i]);
    }
    dp[1]=0;    //跳第一个台阶需要0步 
    for(int i=2;i<=n;i++)
    {
        if(sta[i]==sta[i-1]+1) dp[i]=dp[i-1]+1;
        for(int j=1;j<i;j++)
        {
            int k=ceil(log2(sta[i]-sta[j]));    //计算从i-1要退几步才到点j，即计算2^k中的k的值    
            if(j+k<i)    //如果j+k>=i则说明i和j之间高度差太大，导致要退的步数k很大，那么从当前位置j就跳不到i 
            {
                dp[i]=min(dp[i],dp[j+k]+k+1);    //从j+k退到j需要k步，再跳到i还需要1步 
            }
        }
    }
    if(dp[n]<0x3f3f3f3f) printf("%d",dp[n]);    //能跳到 
    else printf("-1");    //跳不到 
    return 0;
}
```

---

## 作者：回头是岸 (赞：9)

无意中看到这题，看到没有题解，于是过来发一篇。
我们设f[i]表示到达第i层阶梯需要多少步，然后我们可以枚举j,k，j表示你从j层往后退，k表示你从j退到了第k层，所以我们可以得到转移方程:
f[i]=min(f[i],f[j]+(j-k)+1)(1<=k<=j<i&&a[i]<=a[j]+(1<<(j-k)))

1<<(j-k)表示2的(j-k)次方。
完整代码如下：
```cpp
#include<bits/stdc++.h>
const int maxn=2e2+5;
using namespace std;
int n,f[maxn],a[maxn];
int main(){
	memset(f,0x3f,sizeof(f));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	f[1]=0;
	for(int i=2;i<=n;i++){
		for(int j=i-1;j>=1;j--)
			for(int k=j;k>=1;k--){
				if(a[i]<=a[k]+(1<<(j-k))){
				f[i]=min(f[i],f[j]+(j-k)+1);
			}
		}
	}
	if(f[n]>10000000)printf("-1");
	else printf("%d\n",f[n]);
	return 0;
}
```






---

## 作者：三点水一个各 (赞：5)

## [原题](https://www.luogu.org/problem/P1929)
***

## 思路

蒟蒻无才，写了个O ($n^{3}$)  的算法。

对于阶梯 i，有两种可能使其最优的方法

  1  从 i-1 级往上跳，移动距离为 1。

  2  连续退下 k 级，此时跳小于等于 $2^{k}$ 级 第一次能够跳上 第 i 级 ， 移动距离为 k+1。
  
### 当然两种方法也有限制条件：

 方法1：第 i 级和第 i-1 级的高度差必须为1；
 
 方法2：k<=i 。
 
 然后最后再判断一下 $f_{n}$ 有没有被修改过 ，输出'-1'就可以了。

 像摸像样地列一个方程：
 
$f_{i}$ 表示从第 1 级阶梯 到第 i 级阶梯最少移动量。
 
###  $f_{i}$=min{$f_{i}$ ，$f_{i-1}$+1，$f_{j}$+j-k+1}

~~居然在模拟赛中敲出来了，开心~~~
***


    #include<cstdio>
    #include<cstdlib> 
    #include<math.h>
    #include<iostream>
    #include<string.h>
    using namespace std;
    int n,k;
    long long height[210],f[210];
    bool blog;   //判断存不存在方法二；
    int main()
    {
	    scanf("%d",&n);
   	    for(int i=1;i<=n;i++)
	      scanf("%d",&height[i]);
        memset(f,0x7f7f7f7f,sizeof(f));   //其实就是判断答案有没有修改过
        f[1]=0;   //模拟赛时有个人写了f[1]=h[1]。
	    for(int i=2;i<=n;i++)
	    for(int j=1;j<=i-1;j++)
	    {
            if(j==i-1&&height[i]-height[j]<=1) f[i]=min(f[i],f[i-1]+1);   //从 i-1 级跳上去
            k=j-1; blog=true;
            while(height[k]+pow(2,j-k)<height[i]&&blog)   //注意不要越界
            {
	            if(k<2) blog=false; k--;
		}   //跳回去的阶梯越少越好，所以只要找到第一次满足方法二的k就可以了
		if(blog) f[i]=min(f[i],f[j]+j-k+1);
	    }
	    if (f[n]>=0x7f7f7f7f) printf("-1");   //答案没有被修改过，说明没有可行方案。
	    else printf("%d",f[n]);
    }

---

## 作者：AmadeusSG (赞：1)

 [博客食用](https://hackblogs.home.blog/2019/07/29/题解-【p2433-迷之阶梯】/)

 [题面](https://www.luogu.org/problem/P2433)

通过观察题目，我们可以发现最终决策可以这样转移过来：

```
1.f[i-1]+1 (a[i-1]+1==a[i])
2.f[j]+j-k+1 (a[k]+2^(j-k)>=a[i[, 1<=j<i, 1<=k<j)
```

```
初始化：
1.dp-->INF
2.dp[1]=0
```

代码：

```
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
using namespace std;
ll n;
ll a[205],dp[205];
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	memset(dp,0x3f,sizeof(dp));
	dp[1]=0;
	for(int i=2;i<=n;++i)
	{
		if(a[i]<=a[i-1]+1)dp[i]=dp[i-1]+1;
		for(int j=i-1;j>0;--j)
			for(int k=j-1;k>0;--k)
				if((1<<(j-k))+a[k]>=a[i])
					dp[i]=min(dp[i],dp[j]+j-k+1);
	}
	printf("%lld",dp[n]>=INF?-1:dp[n]);
	return 0;
}
```

---

## 作者：依依 (赞：1)

f[i]表示走到h[i]的最少步数

那么转移方程就出来了

if h[i]==h[i-1] f[i]=min(f[i],f[i-1]+1)

else j->i  假设需要h[j]+2^k

     则 f[i]=min(f[i],f[j+k]+k+1)

还要注意无解的情况

[今我往yi,杨柳依依](http://www.cnblogs.com/adelalove/p/9015045.html)
(为什么yi拼不出来?)

---

## 作者：King_of_gamers (赞：1)

这题比较简单，用的方法是DP。

只需要枚举退后的步数就可以了。最后别忘了还有一个不能到达就输-1的

下附上代码。

```cpp
var
        a,f:array[-1..310]of int64;
        i,j,k,n:longint;
        s:longint;
function ss(k:int64):int64;
var
        i:longint;
begin
        ss:=1;
        for i:=1 to k do
        ss:=ss*2;
end;
function min(a,b:int64):int64;
begin
        if a<b then exit(a) else exit(b);
end;
begin
        assign(input,'ladder.in');reset(input);
        assign(output,'ladder.out');rewrite(output);
        read(n);
        for i:=1 to n do
        read(a[i]);
        f[0]:=maxlongint;
        f[1]:=0;
        for i:=2 to n do
        f[i]:=maxlongint;
        for i:=2 to n do
        begin
                if a[i]-a[i-1]<=1 then
                f[i]:=min(f[i],f[i-1]+1);
                for j:=i-1 downto 1 do
                if f[j]<>maxlongint then
                begin
                        s:=ss(i-j);
                        for k:=j to n do
                        if a[k]-a[j]>s then break else
                        f[k]:=min(f[k],f[i]+(i-j)+1);
                end;
        end;
        if f[n]<>maxlongint then write(f[n])
        else write('-1');
        close(input);
        close(output);
end.

```

---

## 作者：dj114133643 (赞：1)

三层循环还是很容易想到的，

枚举从哪一层后退，后退多少步，应该也是可以过的。

考虑如何优化：

由于越往上跳，耗费步数必然不会比下一层少，

所以只需枚举从哪一层开始跳，后退的起始点就是当前楼层加步数。

需多少步具有单调性，可以使用二分。

           
```cpp
#include<cmath>
#include<iostream>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
int f[205];
ll a[205];
ll sum[65];
int main()
{
    int n,i,j,l,r,mid;
    bool flag;
    ll h;
    memset(f,127,sizeof(f));
    f[0]=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    sum[0]=1;
    for(i=1;i<=60;i++)
        sum[i]=sum[i-1]*2;
    for(i=1;i<=n;i++)
    {
        if(a[i]==a[i-1]) {f[i]=f[i-1];continue;}
        flag=false;
        if(a[i]-1==a[i-1]) 
        {f[i]=f[i-1]+1;flag=true;}
        for(j=i-1;j;j--)
        {
            h=a[i]-a[j];
            l=1;r=60;
            while(l<r)
            {
                mid=(l+r)/2;
                if(sum[mid]>=h)
                    r=mid;
                else l=mid+1;
            }
            if(j+l<i)
            {f[i]=min(f[i],f[j+l]+l+1);flag=true;}
        }
        if(flag==false) {printf("-1");return 0;}
    }
    printf("%d\n",f[n]);
    return 0;
}

```

---

## 作者：Great_Influence (赞：1)

刷题过程中看到了这道题，发现以前做过，所以再刷了一遍。

题解的话大概就是dp，这里只是介绍一下优化步骤3的方式：二分查找。

因为n比较小（<=200），所以基本上都是强行检索的，时间复杂度为O（n^3）。然而如果用二分查找来找到步骤3可以跳到的阶梯的话，时间复杂度可以变为O（n^2logn）。

然而二分不好打，怎么办？这时便出现了lower\_bound......它的作用是查找有序递增序列中第一个不小于查询值的数字的地址。转为下标时，只需要减去这个数组的首地址就可以了。注意它返回的是第一个不小于的，所以需要检查返回的值是否合法。如果返回位置比查询值大，那么下标只需要减1就可以了。

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define For(i,a,b) for(i=(a);i<=(b);++i)
using namespace std;
const int MAXN=300;
template<typename T>
inline void read(T &x)//读入优化
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=s*f;
}
int n,a[MAXN],dp[MAXN];//原数组和dp数组
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    read(n);
    int i,j;
    a[n+1]=0xFFFFFFF;
    fill(dp+2,dp+n+1,0xFFFFFFF);//初始化
    For(i,1,n)read(a[i]);
    For(i,1,n)
    {
        if(a[i+1]==a[i]+1)dp[i+1]=min(dp[i+1],dp[i]+1);//步骤1
        For(j,1,i-1)//枚举跳下多少步
        {
            int loc=lower_bound(a+1,a+n+1,(1<<j)+a[i-j])-a;//二分查询
            if(a[loc]>(1<<j)+a[i-j])--loc;
            if(loc>n)loc=n;//溢出处理
            dp[loc]=min(dp[loc],dp[i]+j+1);
        }
    }
    printf("%d\n",dp[n]==0xFFFFFFF?-1:dp[n]);//注意判断无解
    return 0;
}
```

---

## 作者：三点水一个各 (赞：0)

## [原题](https://www.luogu.org/problem/P1929)
***

## 思路

蒟蒻无才，写了个O ($n^{3}$)  的算法。

对于阶梯 i，有两种可能使其最优的方法

  1  从 i-1 级往上跳，移动距离为 1。

  2  连续退下 k 级，此时跳小于等于 $2^{k}$ 级 第一次能够跳上 第 i 级 ， 移动距离为 k+1。
  
### 当然两种方法也有限制条件：

 方法1：第 i 级和第 i-1 级的高度差必须为1；
 
 方法2：k<=i 。
 
 然后最后再判断一下 $f_{n}$ 有没有被修改过 ，输出'-1'就可以了。

 像摸像样地列一个方程：
 
$f_{i}$ 表示从第 1 级阶梯 到第 i 级阶梯最少移动量。
 
###  $f_{i}$=min{$f_{i}$ ，$f_{i-1}$+1，$f_{j}$+j-k+1}

~~居然在模拟赛中敲出来了，开心~~~
***


    #include<cstdio>
    #include<cstdlib> 
    #include<math.h>
    #include<iostream>
    #include<string.h>
    using namespace std;
    int n,k;
    long long height[210],f[210];
    bool blog;   //判断存不存在方法二；
    int main()
    {
	    scanf("%d",&n);
   	    for(int i=1;i<=n;i++)
	      scanf("%d",&height[i]);
        memset(f,0x7f7f7f7f,sizeof(f));   //其实就是判断答案有没有修改过
        f[1]=0;   //模拟赛时有个人写了f[1]=h[1]。
	    for(int i=2;i<=n;i++)
	    for(int j=1;j<=i-1;j++)
	    {
            if(j==i-1&&height[i]-height[j]<=1) f[i]=min(f[i],f[i-1]+1);   //从 i-1 级跳上去
            k=j-1; blog=true;
            while(height[k]+pow(2,j-k)<height[i]&&blog)   //注意不要越界
            {
	            if(k<2) blog=false; k--;
		}   //跳回去的阶梯越少越好，所以只要找到第一次满足方法二的k就可以了
		if(blog) f[i]=min(f[i],f[j]+j-k+1);
	    }
	    if (f[n]>=0x7f7f7f7f) printf("-1");   //答案没有被修改过，说明没有可行方案。
	    else printf("%d",f[n]);
    }

---

## 作者：檀黎斗·神 (赞：0)

看到C语言的题解很少所以来写一份题解

这道题，肯定是可以用DP去写

因为到某一阶梯的步数最小值是确定的也是无后效性的

我们于是就可以用动规解决

那么 动规方程我们也不难解决

当下一阶台阶高度只比现在高一的时候，直接可以一步走上去

当下一阶台阶高度不满足一步的时候，必须要往后退，并且不一定是从这一阶开始跳，也可能是从前面的某一阶开始，

因为数据范围比较小我们完全可以靠枚举得到最小值（三重循环）

代码加了很多注释，应该上面思想没有理解的话，也能通过看代码理解吧


···cpp


```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff  //因为存的是最小值一定要记得初始化一个很大的数
using namespace std;
ll n,f[205],a[205];  //f-走到当前位置x所需要的步数 
ll t[32];            //t-存2^k的值，因为我们后面要跳的步数一定是2^k
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
     scanf("%d",&a[i]);
    t[0]=1;
    for(int i=1;i<=31;i++) t[i]=t[i-1]*2;  //预处理 
    f[1]=0;
    for(int i=2;i<=n;i++) f[i]=INF;  //初始化f的值 
    for(int i=2;i<=n;i++)
     {
         if(a[i]==a[i-1]+1)      //如果可以一步走上去就一步 
         f[i]=f[i-1]+1;
         for(int j=1;j<=i-1;j++) //如果不行的话 
         {
             int h=a[i]-a[j],k;  //计算中间的高度差 h 
             for(k=0;k<=31;k++)  //从i-1开始后退k个台阶到j的位置               
            {
                if(t[k]>=h)     //看能不能跨过去 
                break;
            }
             if(j+k<=i-1)        //如果数据合法的话 
             f[i]=min(f[i],f[j+k]+k+1);  //更新答案 
         }
     }
     if(f[n]<INF) 
     {
         printf("%d",f[n]);
         return 0;
     }
     printf("-1");
     return 0;
}
···
```

---

## 作者：檀黎斗·神 (赞：0)

这道题，肯定是可以用DP去写

因为到某一阶梯的步数最小值是确定的也是无后效性的

我们于是就可以用动规解决

那么
动规方程我们也不难解决

1. 当下一阶台阶高度只比现在高一的时候，直接可以一步走上去

1. 当下一阶台阶高度不满足一步的时候，必须要往后退，并且不一定是从这一阶开始跳，也可能是从前面的某一阶开始，

因为数据范围比较小我们完全可以靠枚举得到最小值（三重循环）

代码加了很多注释，应该上面思想没有理解的话，也能通过看代码理解吧


···cpp

     


             
            
     
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff  //因为存的是最小值一定要记得初始化一个很大的数
using namespace std;
ll n,f[205],a[205];  //f-走到当前位置x所需要的步数 
ll t[32];            //t-存2^k的值，因为我们后面要跳的步数一定是2^k
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
     scanf("%d",&a[i]);
    t[0]=1;
    for(int i=1;i<=31;i++) t[i]=t[i-1]*2;  //预处理 
    f[1]=0;
    for(int i=2;i<=n;i++) f[i]=INF;  //初始化f的值 
    for(int i=2;i<=n;i++)
     {
         if(a[i]==a[i-1]+1)      //如果可以一步走上去就一步 
         f[i]=f[i-1]+1;
         for(int j=1;j<=i-1;j++) //如果不行的话 
         {
             int h=a[i]-a[j],k;  //计算中间的高度差 h 
             for(k=0;k<=31;k++)  //从i-1开始后退k个台阶到j的位置               
            {
                if(t[k]>=h)     //看能不能跨过去 
                break;
            }
             if(j+k<=i-1)        //如果数据合法的话 
             f[i]=min(f[i],f[j+k]+k+1);  //更新答案 
         }
     }
     if(f[n]<INF) 
     {
         printf("%d",f[n]);
         return 0;
     }
     printf("-1");
     return 0;
}
```
···

---

## 作者：1261687299kid (赞：0)

我看最短路和动归都发了，那的就来个爆搜+优化（本人也不知道为什么能100，反正就尽量优化。没什么思维含量）

```cpp
var
  n,i,num:longint;
  a:array[1..200] of int64;
procedure dg(i,shu:longint);//i是当前在哪个阶梯，shu是当前走了几步
  var
    j,k,gd,sh:longint;
  begin
    if shu>=num then exit;//已经超过当前最小的步数可以直接退出
    if i=n then begin
                  num:=shu;
                  exit;
                end;
    if a[i]+1=a[i+1] then dg(i+1,shu+1);//直接往上走
    sh:=2;
    for j:=i-2 downto 1 do//最少也要退2步，退一步和直接走高度一样，但步数多
      begin
        sh:=sh*2;
        gd:=a[j]+sh;
        if gd>=a[i+1] then
        for k:=n downto i+1 do//直接跳到能跳的最高的阶梯，其他的不用走，一定不是最优
          if gd>=a[k] then begin
                                        dg(k,shu+i-j+1);
                                        break;
                                    end;
      end;
  end;
begin
  readln(n);
  for i:=1 to n do
    read(a[i]);
  num:=maxlongint;
  dg(1,0);
  if num=maxlongint then write(-1)
                                else write(num);
end.
```

---

## 作者：I_promise (赞：0)

楼下有人用了最短路

那我就发个DP（本菜鸟只会pascal）

用i枚举要走到的阶梯

用j枚举从哪一步跳到i

用k枚举从哪一步退到j

然后就。。。（简单，不讲了，看程序吧）



···pascal

```cpp
const oo=maxlongint;
var a,b:array[0..1000] of longint;
      n,i,j,k,t:longint;
begin
  read(n);
  for i:=1 to n do read(a[i]); //读入
  for i:=1 to 1000 do b[i]:=oo; //用于比较最小值，也可以判断是否能走到n（是否输出-1）
  b[1]:=0;//初始
  if a[2]-a[1]=1 then b[2]:=1;//初始
  for i:=3 to n do
  begin
    if (b[i-1]<>oo)and(a[i]-a[i-1]=1) then b[i]:=b[i-1]+1;//判断前一步是否能直接走到i
    for j:=2 to i-1 do//枚举从哪一步跳到i
    if b[j]<>oo then
    for k:=1 to j-1 do//枚举从哪一步退到j
    if (exp((j-k)*ln(2)){黑知识，等于2^(j-k)}>=a[i]-a[k])and(b[j]+j-k+1<b[i]){判断哪个大} then
    b[i]:=b[j]+j-k+1;
  end;
  if b[n]=oo then writeln(-1)//判断最终能否走到n
                  else writeln(b[n]);
end.
···
```

---

## 作者：hxr_225 (赞：0)

貌似没有人发DP的，我发一个吧。不过本蒻蒟算法低效勿喷……


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 1000007;
int main(){
    int a[205];       //height
    int f[205];        //dp数组
    int n;
    cin >> n;
    for (int i = 0; i < n; i++){
        f[i] = maxn;
        cin >> a[i];
    }
    f[0] = 0;
    for (int i = 1; i < n; i++){
        if (a[i] - a[i - 1] <= 1) f[i] = f[i - 1] + 1;     //显然，这种情况下是必定最短的（可以再加一个break使算法更高效）
        for (int j = 0; j < i; j++){ 
            for (int o = 0; o < j; o++)       //表示从第j级退回第o级跳到第i级
                if (1 << (j - o) >= a[i] - a[o]) f[i] = min(f[i], f[j] + j - o + 1);   //注意，这儿其实是2^k，不是2 * k， 题面貌似有点问题
        }
    }
    if (f[n - 1] <= 1000000) cout << f[n - 1];    //原来是写(f[n - 1] != maxn)的，不知道为什么过不了，改成小于等于就可以了
    else cout << -1 << endl;
    return 0;
}
```

---

## 作者：VCVCVCFop_zz (赞：0)

本题dp

不难发现，2步骤纯属为3服务

f[i]表示到第i阶阶梯的最小步数，通过①可以得到f[i]=min(f[i],f[i-1]+1)  要求a[i]-a[i-1]==1

通过②和③，我们可以枚举j表示从第j个点开始往后退，再找到最小的k使a[j-k]+2^k>=a[i]，然后来更新f[i]为f[i]=min(f[i],f[j]+k+1)

总体来说题目不难，但是有坑点，f[1]=0以及f[i]=min(f[i]+k**+1**)。。由于样例只跳了一次这个bug查不出来，所以就WA了一次。

本人有一个想法不过代码中没实现，即其实①条件可以舍去，因为后退一步再跳一步等价于连续的走两步。。当然可能需要一些特判，也就没写了。

下面贴代码：


            
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int f[2000],a[2000];
int main()
{
    int n;
    cin>>n;
    for (int i=1;i<=n;i++) cin>>a[i];
    memset(f,127,sizeof(f));    
    f[1]=0;
    for (int i=2;i<=n;i++) 
    {    
        if (a[i]-a[i-1]==1)
            f[i]=min(f[i],f[i-1]+1);//用①更新i
        for (int j=1;j<=i-1;j++)
        {
            int x=1;
            for (int k=1;k<=j-1;k++)
            {
                x<<=1;
                if (a[j-k]+x>=a[i]) {f[i]=min(f[i],f[j]+k+1);break;}//用②③更新f[i]
            }
        }
    }
    if (f[n]<=100000)
    cout<<f[n]<<endl;else cout<<"-1"<<endl;
}
```

---

## 作者：封禁用户 (赞：0)

我敢说这一题只有我是用最短路的......

但这题最短路很好想啊！！！

这题打dijkstra是n^2，但我比较懒（三方能过），于是直接floyd......


```cpp
var f:array[0..500,0..500]of longint;
i,j,k,m,n:longint;
a:array[0..1000]of longint;
begin
  read(n);
  for i:=1 to n do read(a[i]);
  for i:=1 to n-1 do
  for j:=i+1 to n do
  begin
    f[i,j]:=999999;
    if a[j]=a[i]+1 then f[i,j]:=1//构边，判断能不能直接上去
    else
    for k:=1 to i-1 do
    if 1 shl k>=a[j]-a[i-k]then begin f[i,j]:=k+1;break;end;//构边，看看至少从哪个起跳，如果无法达到边权就是999999
  end;
  for k:=1 to n do
  for i:=1 to n do
  for j:=1 to n do
  if f[i,j]>f[i,k]+f[k,j]then
  f[i,j]:=f[i,k]+f[k,j];//floyd不解释
  if f[1,n]>=999999 then write(-1)else write(f[1,n]);
end.
```

---

## 作者：sdkck (赞：0)

```cpp
/*
第一行一个正整数NN，表示火星人手指的数目（1≤N≤10000）。
第二行是一个正整数MM，表示要加上去的小整数（1≤M≤100）。

其中一个可以很快解决我们这道题的就是next_permutation()
什么意思呢？就是一个求一个排序的下一个排列的函数，可以遍历全排列
与之完全相反的函数还有prev_permutation（就是一个求一个排序的上一个排列的函数）
*/
#include<bits/stdc++.h>
using namespace std;
int a[10005],n,m;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    while(m--)next_permutation(a+1,a+n+1);
    for(int i=1;i<=n;i++) printf("%d ",a[i]); 
    return 0;
}
```


---


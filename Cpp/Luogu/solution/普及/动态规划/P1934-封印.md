# 封印

## 题目背景

很久以前，魔界大旱，水井全部干涸，温度也越来越高。为了拯救居民，夜叉族国王龙溟希望能打破神魔之井，进入人界“窃取”水灵珠，以修复大地水脉。可是六界之间皆有封印，神魔之井的封印由蜀山控制，并施有封印。龙溟作为魔界王族，习有穿行之术，可任意穿行至任何留有空隙的位置。然而封印不留有任何空隙！ 龙溟无奈之下只能强行破除封印。破除封印必然消耗一定的元气。为了寻找水灵珠，龙溟必须减少体力消耗。他可以在破除封印的同时使用越行术。

## 题目描述

神魔之井的封印共有  $n$ 层，每层封印都有一个坚固值。身为魔族的龙溟单独打破一层封印时需要消耗的元气为该层封印的坚固值和封印总层数  $n$ 的平方的乘积； 但他也可以打破第 i 层到第 j 层之间的所有封印( $i<j$)，总元气消耗为第  $i,j$ 层封印的坚固值之和与第  $i,j$ 层之间所有封印层（包括第  $i,j$ 层）的坚固值之和的乘积，但为了不惊动蜀山，第  $i,j$ 层封印的坚固值之和不能大于  $t$ （单独打破可以不遵守）。

## 说明/提示

#### 样例解释
先单独打破第一层，再用越行术从第二层直接打破到最后一层。 这样消耗元气  $8 \times 6^2 + (5 + 5) \times (5 + 7 + 9 + 3 + 5) = 578$。
#### 数据范围
对于  $10\%$ 的数据， $n\le10$；  
对于  $50\%$ 的数据， $n\le100$；  
对于  $70\%$ 的数据， $n\le500$；  
对于  $100\%$ 的数据， $n\le1000$， $a_i(1 \le i \le n) , t \le 20000$。

## 样例 #1

### 输入

```
6 10
8 5 7 9 3 5```

### 输出

```
578
```

# 题解

## 作者：kkksc03 (赞：74)

由于题目具有无后效性，所以想到用DP来解决。

我们令f[i]表示打破前i层封印消耗元气的最小值，则状态转移方程如下：

f[i]=max⁡{f[i−1]+a[i]\*n^2,f[k]+(a[k+1]+a[i])\*sum(k+1,i)|0<k+1<i,a[k+1]+a[i]≤k}

状态转移方程写好后，问题在于求sum(k+1,i)时如果遍历一遍需要O(n)的复杂度。这样总复杂度为k(n^3)，50-70分。

这个复杂度可以用预处理前缀和的方法来优化。用S[i]表示从a[1]到a[i]的

总和，则sum(k+1,i)=S[i]-S[k]。这样总复杂度为k(n^2)，可以通过所有测试点。


---

## 作者：Vatyr (赞：35)

思路楼上已经说得很清楚了，这里贴一份代码（可能有什么鬼bug请小心服用）

```cpp
#include<iostream>
using namespace std;
int n,t;
long long f[1003],s[1003],a[1003];
int mian()
{
    cin>>n>>t;
    int m=n*n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s[i]=s[i-1]+a[i];
    }
    for(int i=1;i<=n;i++)
    {
        long long  ans=m*a[i]+f[i-1];
        for(int j=1;j<i;j++)
        {
            if(a[i]+a[j]>t)continue;
            ans=min(ans,(a[i]+a[j])*(s[i]-s[j-1])+f[j-1]);
        }
        f[i]=ans;
    }
    cout<<f[n];
    return 0;
} 
```

---

## 作者：wick (赞：13)

**我们知道DP的题目具有无后效性,前面不影响后面.**

故便可轻易想到用DP.

DP便得先有状态转移方程.

**由题目分出两部分**

		1. "单独打破一层封印时需要消耗的元气为该层封印的坚固值和封印总层数 n 的平方的乘积".
        
      	2. "打破第 i 层到第 j 层封印(i<j)的总元气消耗为第 i, j 层封印的坚固值之和与第 i, j 层之间所有封印层（包括第 i, j 层）的坚固值之和的乘积。同时，为了不惊动蜀山，第 i, j 层封印的坚固值之和必须不大于一个固定值 t" 。
        
        
但这样推出的是子,是O(n^3)的,n最大1000,绝对tle.

而关注一下这句"第 i, j 层之间所有封印层（包括第 i, j 层）的坚固值之和",既然是连续的那么就应想到前缀和 ~~,再不行总会看标签吧~~.
        
**可由两部分分别推出**

		1.   dp[j]=min(dp[j],dp[j-1]+a[j]*n*n);
    
        2. if(a[j]+a[i]<=t) dp[j]=min(dp[j],dp[i-1]+(a[j]+a[i])*(f[j]-f[i-1]));//i是枚举的点
            
所以上代码:
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,t;
ll a[1005];
ll f[1005];
ll dp[1005];
int main() {
	cin>>n>>t;
	for(int j=1; j<=n; j++) {
		cin>>a[j];
		f[j]=f[j-1]+a[j];//前缀和
		dp[j]=LONG_LONG_MAX;//初始化大一点,总是对的
	}
	for(int j=1; j<=n; j++) {//见上分析
		dp[j]=min(dp[j],dp[j-1]+a[j]*n*n);
		for(int i=1; i<j; i++)
			if(a[j]+a[i]<=t)
				dp[j]=min(dp[j],dp[i-1]+(a[j]+a[i])*(f[j]-f[i-1]));
	}
	printf("%lld",dp[n]);
	return 0;
}

```
求过加点赞      O(∩_∩)O谢谢

( ^_^ )/~~拜拜  and  ヾ(￣▽￣)Bye~Bye~


---

## 作者：usqwedf (赞：10)

线性动态规划常规题。

dp[i]=Min(dp[i-1]+a[i]\*n^2,dp[k-1]+(a[k]+a[i])\*(t[i]-t[k-1]))

当且仅当 a[i]+a[k]<=h 且 1<=k<=i-1 时

在此 t 使用 前缀和优化

代码 <=0.4K


---

## 作者：Lugar (赞：4)

## 可以祭出一手最短路。
#### 注意封印是在路上，要从0走到n的。不是1到n。
#### pre函数建边，然后跑一遍dijkstra就好啦。
~~好像比dp慢一丢丢~~ ~~前面INF开的不够大一直WA~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF = 0x3f3f3f3f3f;
long long a[1001],dis[1001][1001],suma[1001];
long long n,t;
long long d[1001];
bool v[1001];

void pre()
{
	memset(dis,INF,sizeof(dis));
	for(int i = 0; i < n; i++)
		dis[i][i+1] = min(dis[i][i+1],a[i+1]*n*n);
	for(int i = 0; i < n; i++)
		for(int j = i + 2; j <= n; j++)
		{
			long long cost = (a[j] + a[i+1]);
			if(cost > t)
				cost = INF;
			else
				cost = (a[j] + a[i+1]) * (suma[j] - suma[i]);
			dis[i][j] = min( dis[i][j] , cost );
		}
}

void dijkstra()
{
	memset(d,INF,sizeof(d));
	d[0] = 0;
	for(int i = 0; i < n; i++)
	{
		int x = -1;
		for(int j = 0; j <= n; j++)
			if(!v[j] && (x == -1 || d[j] < d[x])) x = j;
		v[x] = true;
		for(int y = 0; y <= n; y++)
			d[y] = min( d[x] + dis[x][y] , d[y]);
	}
}

int main()
{
	scanf("%lld %lld",&n,&t);
	for(int i = 1; i <= n; i++)
		scanf("%lld",&a[i]),suma[i] = suma[i-1] + a[i];
	pre();
	dijkstra();
	printf("%lld",d[n]);
}
```

---

## 作者：Exber (赞：4)

## 题意
- #### 有 $n$ 个怪物，每个怪物有一个血量 $a_i$。打败一个怪物需要钻石剑的 $a_i\times n^2$ 点耐久度。
- #### 钻石剑有一个技能“连杀”，可以把 $[i,j]$ 这段区间怪物杀掉，所耗费的耐久度是 $(a_i+a_j)\times\sum\limits_{k=j}^ia_k$ 。但由于你很爱惜钻石剑，所以使用这个技能时需要满足 $a_i+a_j\le t$。
- #### 对于给定的 $n$、$t$ 和 $a$ 数组，请输出杀掉所有怪物所耗费的最小耐久度。

## 做法
前缀和+暴力 DP。

定义 $dp_i$ 表示杀掉 $[1,i]$ 这个区间里所有怪物所耗费的最小耐久度。很明显如果不用技能的话可以这样转移： $dp_i=dp_{i-1}+a_i\times n^2$。用技能的情况也很好解决，可以在 $a_i+a_j\le t$ 的时候这样转移：$dp_i=(a_i+a_j)\times\sum\limits_{k=j}^ia_k+dp_{j-1}$。那么最终的状态转移方程就是：

$dp_i=\min(dp_{i-1}+a_i\times n^2,(a_i+a_j)\times\sum\limits_{k=j}^ia_k+dp_{j-1}|1\le j<i\And a_i+a_j\le t)$

状态转移方程里的 $\sum\limits_{k=j}^ia_k$ 需要用前缀和来优化。优化后的时间复杂度就是 $O(n^2)$ 了，而不优化的时间复杂度则是 $O(n^3)$。

最后记得开 `long long`。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int n,t;
long long a[1005],sum[1005],dp[1005]; // 记得开 long long 

int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		sum[i]=sum[i-1]+a[i]; // 前缀和 
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=dp[i-1]+a[i]*n*n; // 赋初值 
		for(int j=1;j<i;j++)
		{
			if(a[i]+a[j]<=t) // 可以转移 
			{
				dp[i]=min(dp[i],(sum[i]-sum[j-1])*(a[i]+a[j])+dp[j-1]); // 尝试转移 
			}
		}
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```


---

## 作者：Terraria (赞：2)

~~明显~~考虑动规。

假设 $f_i$ 表示打破前 $i$ 层封印所需要的最少元气。

首先题目中：

> 打破一层封印时需要消耗的元气为该层封印的坚固值和封印总层数 $n$ 的平方的乘积。

可以得到其中一个转移方程：

$f_i=\min(f_i,f_{i-1}+a_i \times n^2)$。

其次，我们需要枚举在区间 $[1,i)$ 中的 $j$，来枚举连续打破 $[i,j]$ 区间的最小元气值。

根据题目中的信息可以总结出：

> 如果满足 $a_i+a_j\leq t$，即可花费 $[i,j]$ 的所有封印的坚固值之和乘以 $(a_i+a_j)$。

然而，如果区间 $[i,j]$ 的封印的坚固值之和用循环来算的话时间复杂度为 $O(n^3)$，明显超时。因此这个区间和可以用前缀和来预先处理好。~~这就是为什么标签里有个前缀和。~~

所以可以得到代码：

```cpp
#include<bits/stdc++.h>
#define int long long//数据较大，需要long long
using namespace std;
int n,t;
int a[1009];
int f[1009];
int sum[1009];
signed main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		f[i]=10000000009;//赋个大值！一开始我没有赋那么大就只有30分
	}
	for(int i=1;i<=n;i++){
		f[i]=min(f[i],f[i-1]+a[i]*n*n);//第一个转移方程
		for(int j=1;j<i;j++){
			if(a[i]+a[j]<=t)/*注意是有条件的！*/ f[i]=min(f[i],f[j-1]+(a[j]+a[i])*(sum[i]-sum[j-1]));//第二个转移方程
		}
	}
	cout<<f[n];//f[n]即为打破这n层封印所需要的最小值
}
```


---

## 作者：_•́へ•́╬_ (赞：2)

## DP都能用记忆化写！
## 不用前缀和，边枚举边统计和
```cpp
#include<stdio.h>
#define min(x,y) ((x)<(y)?(x):(y))
#define int long long
inline int read()//快读
{
	register int x=0;register char c=getchar();for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=getchar());return x;
}
int n,t,a[1000],ans[1000];
int dfs(int i)
{
	if(i==n)return 0;//边界
	if(ans[i])return ans[i];//记忆化
	ans[i]=n*n*a[i]+dfs(i+1);//单独打破这一层
	register int sum=a[i];//不用前缀和
	for(register int j=i+1;j<n;++j)
	{
		sum+=a[j];//加和
		if(a[i]+a[j]<=t)//满足条件
			ans[i]=min(ans[i],dfs(j+1)+(a[i]+a[j])*sum);//转移
	}
	return ans[i];
}
main()
{
	n=read();t=read();for(register int i=0;i<n;++i)a[i]=read();//输入
	printf("%lld",dfs(0));//输出
}/**/
```

---

## 作者：qiaoa (赞：1)

本蒟蒻第一次写题解，如有错误请指正
## 题目大意


有 n 个封印，每个封印有坚固值 $a_i$，有两种方法打破封印：
- 花费 $n^2\times a_i$ 的元气，打破第 i 层封印。
- 在 $a_i+a_j\leqslant t$ 时，花费 $(a_i+a_j)(\sum\limits_{k=i}^j a_k)$ 打破第 i-j 层封印。
- $n\leqslant 10^3$，$a_i\leqslant2\times10^4$，所以 $n^2\times a_i$ 以及 $(a_i+a_j)(\sum\limits_{k=i}^j a_k)$ 可能会超出 ```int``` 范围，使用 ```long long int```。

求最小消耗元气。

## 方法


由于该题存在多种相似的状态，故可使用 dp 求最小值，求区间之和可使用前缀和优化，前缀和的时间复杂度 $O(n)$，在前缀和优化后本题时间复杂度为 $O(n^2)$。
### 关于前缀和
注：在此仅概述一维前缀和。

前缀和本蒟蒻一般用数组存储（以下用 $r_i$ 表示），其主要思想为：

1. 记录前 1-i 个数之和
```cpp
//令共有 n 个数，每个数为 a
	for(int i=1;i<=n;++i){ //i 从 1 开始防止 r 数组越界
   		scanf("%lld",&a[i]);
   		r[i]=r[i-1]+a[i];
	}
```

2. 用前缀和求出 i-j 区间中 a 的和，用 $r_j-r_{i-1}$ 表示，注意，i 要减去 1，因为减去 $r_i$ 时，同时减去了 $a_i$ 的值($r_i$ 中加入了 $a_i$)

举个例子
|  $a_i$|$a_1=1$|$a_2=3$|$a_3=2$|$a_4=4$|$a_5=5$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $r_i$ |$r_1=1$|$r_2=r_1+3=4$|$r_3=r_2+2=6$|$r_4=r_3+4=10$|$r_5=r_4+5=15$
当求 $a_2$ 至 $a_4$ 的和时，就可用 $r_4-r_1=10-1=9$ 得出结论。

下面给出公式的推导，从中能看出为何 i 要减去 1。

$a_i+a_{i+1}+a_{i+2}+...+a_j$

$=(a_j+a_{j-1}+...+a_2+a_1)-(a_{i-1}+...+a_2+a_1)$

$=r_j-r_{i-1}$

如仍不理解可自行画图。~~其实是我画不好~~。

### 关于 dp
这个我就不详细说了。~~我自己也不太行~~。主要就是找出动态转移方程，就我而言，一般就是：

现在的最好情况 $=$ 几种方案中，哪个好，选哪个。

由上述得该题的动态转移方程为：

$f_i=\min(f_{i-1}+n^2\times a_i,(a_i+a_j)\times(r_i-r_{j-1})+f_{j-1})$

解释：

$f_{i-1}+n^2\times a_i$ 为第一种方案，即打破当前层封印后消耗元气总数。

$(a_i+a_j)\times(r_i-r_{j-1})+f_{j-1}$ 为第二种方案，即打破第 j-i 层封印，因而后面加上的为 $f_{j-1}$ 而非 $f_{i-1}$。其中的 $r_i-r_{j-1}$ 为前缀和求和。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int n,t,a[1010],r[1010],f[1010];
int main(){
    memset(f,0x7f7f,sizeof(f));
    f[0]=0;
    scanf("%lld%lld",&n,&t);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);
        r[i]=r[i-1]+a[i];//求出前缀和
    }
    for(int i=1;i<=n;++i){//枚举当前层数或 j-i 层的终点 i
        f[i]=f[i-1]+pow(n,2)*a[i];//先赋值，避免当 a[i]+a[j] 一直 >t 时，f[i] 未赋正确的值导致还为 0x7f7f
        for(int j=1;j<i;++j){//枚举第二种方案的起点 j
            if(a[i]+a[j]<=t){
                f[i]=min(f[i],(a[i]+a[j])*(r[i]-r[j-1])+f[j-1]);
            }
        }
    }
    printf("%lld",f[n]);
    return 0;
}
```
结束


---

## 作者：FourteenObsidian (赞：0)

一道简单的 dp 题。

设 $dp[i]$ 表示打通前 $i$ 层的最小消耗，先从前往后依次枚举每层，对于每层枚举它前一个断点如果两处值之和 $<k$ 就计算并取 $min$，同时计算单独打破的情况，最后答案就是 $dp[n]$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//记得开 long long！
const int N = 1e3 + 10;
int n, t;
int a[N], pre[N], dp[N];
signed main()
{
	scanf("%lld%lld", &n, &t);
	for(int i = 1; i <= n; ++i)
	{
		scanf("%lld", &a[i]);
		pre[i] = pre[i - 1] + a[i];
	}
	memset(dp, 0x3f, sizeof(dp));//因为要取 min，所以赋成较大值
	dp[0] = 0;
	for(int i = 1; i <= n; ++i)
	{
		for(int j = 1; j < i; ++j)
			if(a[i] + a[j] <= t) dp[i] = min(dp[i], dp[j - 1] + (a[i] + a[j]) * (pre[i] - pre[j - 1]));//连续打破
		dp[i] = min(dp[i], dp[i - 1] + a[i] * n * n);//单独打破
	}
	printf("%lld\n", dp[n]);
	return 0;
}
```


---

## 作者：Lips (赞：0)

# 线性 $DP$

$\text{update 8.13:}$ 修改了文章的几处错误。

**前言**

入门 $dp$ 调了 $3min$，~~车车猝不及防，直到将自己的代码调成了别人的代码~~。

**思路**

先定义状态，设 $dp_i$ 表示当龙溟打到第 $i$ 层时消耗的最小元气。

再看状态转移方程，发现，到了第 $i$ 层，龙溟有两种决策：

- 单独打破第 $i$ 层。

- 用大招。

对于第一种决策，它肯定是第 $(i-1)$ 层的最优解 $+$ 单独打破第 $i$ 层所需的元气：$dp_i=dp_{i-1}+a_i\times n^2$。

对于第二种决策，我们不妨从 $1$ 至 $(i-1)$ 枚举一个 $j$，意思是龙溟从 $j$ 至 $i$ 层连续打~~用大招~~所消耗的最小元气。那么这时第 $i$ 层所消耗的最小元气肯定是在第 $(j-1)$ 层消耗的最小元气 $+$ 连续打消耗的元气中去一个最小值：$\min_{j=1}^{i-1}dp_{j-1}+(a_j+a_i)\times sum(j,i)$。

其中 $sum(j,i)$ 为 $\sum_{k=j}^i a_k$，我们发现这个东西可以用前缀和来维护，这样，复杂度便由 $\mathcal{O(n^3)}$ 优化到 $\mathcal{O(n^2)}$。

将两种决策~~掺和~~在一起，先算出单独打破的元气，之后枚举 $j$，与第二种决策区个最小值，就完了。注意开 $\text{long long}$。

$Code:$ （高清版代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1010;
typedef long long ll;
int n,t;
ll a[MAXN],sum[MAXN],dp[MAXN];
inline ll read()
{
	ll s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
int main()
{
    scanf("%d%d",&n,&t);
    for(register int i=1;i<=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];
    dp[1]=a[1]*n*n;
    for(register int i=2;i<=n;i++)
    {
    	dp[i]=dp[i-1]+a[i]*n*n;
    	for(register int j=1;j<i;j++)
    		if(a[i]+a[j]<=t) dp[i]=min(dp[i],dp[j-1]+(a[j]+a[i])*(sum[i]-sum[j-1]));
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

$$\texttt{The End.}$$

---

## 作者：zhangyuhan (赞：0)

一道一维动态规划的好题。

对于所有$DP$的题目，我们都可以从定义、状态转移方程、边界（即初始化）和目标来分析。

首先我们来定义$f$数组。

由于本题求的是最小消耗元气值，所以我们可以这样定义：

令$f_i$为从第$1$层打到第$i$层的最小元气消耗值。

那么，由题意可得方程：

$f_i=min\{f_{j-1}+(a_i+a_j)·\sum\limits_{k=j}^ia_k\}$
$(1\leq{j}<i,a_i+a_j\leq t)$

接下来考虑边界。

易得$f_0=0$。

又因为单独打破一层也会消耗元气，那么我们可以把$f_i$的初始值设定为：$f_i=f_{j-1}+a_i·n^2$

最后考虑目标。

由定义易得，目标（即所求答案）为$f_n$

那让我们来分析一下时间复杂度：

遍历$i$和$j$就需要花费$O(n^2)$的时间，如果求和还需要依次累加的话，那么总共的时间复杂度为$O(n^3)$，不可过。

那我们就得引进前缀和来解决问题了。

设$s_i=\sum\limits_{k=1}^ia_k$，运用减法易得$\sum\limits_{k=j}^ia_k=s_i-s_{j-1}$

而前缀和可以在读入时预处理，那么求和的时间复杂度降为$O(1)$，总时间复杂度为$O(n^2)$，可过。

$AC$ $Code$ 

```cpp
#include <iostream>
using namespace std;

long long s[1010], a[1010], n, t;
long long f[1010];//注意，要开long long

int main() {
	cin >> n >> t;
	for (int i=1; i<=n; i++) {
		cin >> a[i];
		s[i] = s[i-1]+a[i];
	}//读入+预处理前缀和
	f[1] = a[1]*n*n;//初始化f[1](与我前文中的初始化本质一样)
	for (int i=2; i<=n; i++) {
		f[i] = f[i-1]+a[i]*n*n;//初始化f[i]
		for (int j=1; j<i; j++)
			if (a[i]+a[j]<=t) f[i] = min(f[i], f[j-1]+(a[i]+a[j])*(s[i]-s[j-1]));//方程求解
	}
	cout << f[n] << endl;//输出答案
	return 0;//完结撒花！
}
```

---

## 作者：中国珂学院 (赞：0)

dfs会超时，用**DP**好一些

**~~DP真的搞不懂，做对了也不知道为什么~~**

不多bb，下面附上代码

```cpp
#include<iostream>
using namespace std;
int n,t;
long long int f[1003],s[1003],a[1003];
int main()
{
    cin>>n>>t;
    int m=n*n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s[i]=s[i-1]+a[i];
    }
    for(int i=1;i<=n;i++)
    {
        long long  int ans=m*a[i]+f[i-1];
        for(int j=1;j<i;j++)
        {
            if(a[i]+a[j]>t)continue;
            ans=min(ans,(a[i]+a[j])*(s[i]-s[j-1])+f[j-1]);
        }
        f[i]=ans;
    }
    cout<<f[n];
    return 0;
} 
```
**~~尽管你们也没人会看到~~**

**~~下面皮一下，压个行（误）~~**
```cpp
#include<iostream>
using namespace std;int n,t;long long int f[1003],s[1003],a[1003];int main(){cin>>n>>t;int m=n*n;for(int i=1;i<=n;i++){cin>>a[i];s[i]=s[i-1]+a[i];}for(int i=1;i<=n;i++){long long  int ans=m*a[i]+f[i-1];for(int j=1;j<i;j++){if(a[i]+a[j]>t)continue;ans=min(ans,(a[i]+a[j])*(s[i]-s[j-1])+f[j-1]);}f[i]=ans;}cout<<f[n];return 0;} 
```
**可能有什么鬼错误（bug），请小心食用**

---


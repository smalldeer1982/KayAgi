# 最长括号匹配

## 题目描述

对一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配子串。具体来说，满足如下条件的字符串成为括号匹配的字符串：

  1.(),[]是括号匹配的字符串。

2.若A是括号匹配的串，则(A),[A]是括号匹配的字符串。

3.若A,B是括号匹配的字符串，则AB也是括号匹配的字符串。

例如：(),[],([]),()()都是括号匹配的字符串，而][,[(])则不是。

字符串A的子串是指由A中连续若干个字符组成的字符串。

例如，A,B,C,ABC,CAB,ABCABCd都是ABCABC的子串。空串是任何字符串的子串。


## 说明/提示

【数据范围】

对20%的数据，字符串长度<=100.

对50%的数据，字符串长度<=10000.

对100%的数据，字符串长度<=1000000.


## 样例 #1

### 输入

```
([(][()]]()
```

### 输出

```
[()]
```

## 样例 #2

### 输入

```
())[]```

### 输出

```
()```

# 题解

## 作者：OItby (赞：87)

$PS$

- [博客](https://www.cnblogs.com/hihocoder/p/12416385.html#%E9%A2%98%E8%A7%A3)食用效果更佳
- 欢迎在评论区**谔谔**，$dalao$发现博文有误麻烦在评论区**斧正**，弱弱**感激不尽**
- ~~萌新初学$OI$(骗管理员神仙的)~~，求管理员通过
- 蒟蒻写博文不易，请不要直接$Ctrl+S→Ctrl+V$

------

对于这题$\le 1000000$的数据规模显然只允许我们用一重循环

**最长**，可见这是道**最值问题**

最值问题可以用**贪心**，$DP$，**二分**，$etc$

我对于这题用的是$DP$~~太弱了，只会DP~~

------

进入正题：如何$DP$

首先，我们需要构建状态，状态的构建不是唯一的，受**最长上升子序列**（好题~~废话~~）的影响，我是这样构建的

令$f[i]$表示**以$s[i]$为结尾的字符串的最长括号匹配**

接下来，我们就得推**状态转移方程**

考虑$s[i]$，要想它能构成括号匹配，很显然地，它肯定不能为`(`或者`[`

那么$s[i]$为`)`或者`]`时我们应该怎样转移呢？

我们要找到一个$s[k]=$`(`(或者`[`，为了方便叙述，下同)，使得在$(k,i)$这个开区间内的字符串为**最长括号匹配**且$[k,i]$这个闭区间尽可能得大

那么什么情况能满足上面的条件呢？

$f[i-1]$表示什么？不正是以$s[i-1]$结尾的最长括号匹配吗，那么如果$s[i-1-f[i-1]]$与$s[i]$匹配的话，$f[i]$一定等于$f[i-1]+2+f[i-f[i-1]-2]$

说明一下

- $f[i-1]$代表$s[i-1-f[i-1]]$与$s[i]$中间的一段即$s[i-1]$的最长括号匹配
- $2$即$s[i-1-f[i-1]]$与$s[i]$匹配，增加长度为$2$
- $s[i-f[i-1]-2]$即$s[i-f[i-1]-1]$的前一个字符，这里不要漏掉它还可以构成的最长括号匹配的长度
- 不是很复杂，画个图就很明显了

那么若$s[i-1-f[i-1]]$与$s[i]$不匹配怎么办？这时$f[i]$肯定为$0$，因为除此之外，不管选哪个字符，都没法满足它和$s[i]$构成括号匹配

分析千万条，代码第一条，不懂的看一下代码(~~懂得可以自己打去了，偷笑~~)

$my~Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;

const int L=1000005;
char s[L];
int l,f[L],Ans,id;

int main()
{
	scanf("%s",s+1);//输入，下标从1开始
	l=strlen(s+1);//下标从1开始的字符串长度
	for(int i=2;i<=l;++i)//s[1]显然无法匹配，所以从2开始
		if(s[i]=='('||s[i]=='[') continue;//如分析
		else
			if((s[i]==')'&&s[i-f[i-1]-1]=='(')
			||(s[i]==']'&&s[i-f[i-1]-1]=='['))
			{
				f[i]=f[i-1]+2+f[i-f[i-1]-2];
				if(f[i]>Ans) Ans=f[i],id=i;//Ans记录最长括号匹配，id记录最长括号匹配的下标
			}
	for(int i=id-Ans+1;i<=id;++i) printf("%c",s[i]);
	putchar('\n');
	return 0;
}
```

---

## 作者：Nepenthe (赞：52)

话说为什么这题是提高+/省选

真是一道水积分的好题~~~

我们直接一个一个压进栈里,把匹配的都弹出去,然后记vis数组vis[i]表示i位是不是成功匹配了

然后找vis数组中最长的一段vis[i]=1的直接输出就好了

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#define siz 1000100
using namespace std;
int la,top,cnt,l,ansl,ansr,ans;
int sta[siz][2];
char a[siz];
bool vis[siz];
int main(){

    scanf("%s",a);
    la=strlen(a);
    for(int i=0;i<la;++i) 
      if((sta[top][0]=='['&&a[i]==']')||(sta[top][0]=='('&&a[i]==')')) vis[sta[top--][1]]=vis[i]=1;
      else sta[++top][0]=a[i],sta[top][1]=i;
    for(int i=0;i<la;++i)
      if(!vis[i]) cnt=0,l=i+1;
      else {
          cnt++;
          if(cnt>ans) ansl=l,ansr=i,ans=cnt;
      }
    for(int i=ansl;i<=ansr;++i) putchar(a[i]);
    return 0;
}
O(n)过

```

---

## 作者：zhouenji (赞：25)

字符串dp好（shui）题一道

我们可以用dp【i】表示以i结尾的最长合法序列长度

那么对于每一个元素，只需考虑它的上一个元素的长度即可

就有dp方程：dp[i]=dp[i-1]+2+dp[i-2-dp[i-1]];

以下是代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=100000+10;
char st[maxn];
int ans;
int dp[maxn];
int main()
{
    scanf("%s",st+1);int len=strlen(st+1);
    for(int i=1;i<=len;i++)
    {
        if(st[i]=='(' || st[i]=='[')continue;
        if(st[i]==')' || st[i]==']')
        {
            if((st[i]==')' && st[i-1-dp[i-1]]=='(') || (st[i]==']' && st[i-1-dp[i-1]]=='['))
            {
                dp[i]=dp[i-1]+2+dp[i-2-dp[i-1]];
                ans=max(ans,dp[i]);
            }
        }
    }
    for(int i=1;i<=len;i++)
        if(dp[i]==ans)
        {
            for(int j=i-ans+1;j<=i;j++)printf("%c",st[j]); return 0;
        }
}
```

---

## 作者：杨柏涵 (赞：12)

主要思路：
① 依次入站遇到可以匹配的一对，就把这一对符号的序号放入一个桶数组pail中，并将这一对括号从栈stack中删除。
②然后对桶数组中的最长连续子串进行统计即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
string t="";
string k="";
int maxx=0;
int stack[1000100];
int pail[1000100];
int main(){
	memset(pail,0,sizeof(pail));
	cin>>s;
	int top=0;
	int i=0;
	while(i<s.size()){
		stack[++top]=i;
		if((s[stack[top]]==')'&&s[stack[top-1]]=='('||s[stack[top]]==']'&&s[stack[top-1]]=='[')&&top-1>0){
			pail[stack[top]]=1;
			pail[stack[top-1]]=1;
			top-=2;
		}
		i++;
	}
	int ans=0;
	for(int i=0;i<s.size();i++){ 
		if(pail[i]){
			ans++;
			k+=s[i];
		}
		else{
			if(ans>maxx){
				maxx=ans;
				t=k;
				
			}
			k="";
			ans=0;
		}
	}
	cout<<t<<endl;
	return 0;
}
```


---

## 作者：codesonic (赞：6)

**建议先做完最长上升连续子序列再来做**

思路和楼上一样，但仍有几个点要和大家说一下

根本不用栈，不用栈，不用栈！栈在这里用比较麻烦

设dp[i]是以第i个字符开始的匹配的字符串，从后往前遍历一遍，即很容易得出最长匹配字符串。

但是，为什么不从前往后遍历呢？

可能会越界！

所以只能从后往前，

这题可以理解为括号匹配与最长上升连续子序列的结合，但明显是DP的分量较大

代码：

/\*样例中多个字符串我觉得是多个样例的意思，看了讨论，所以只写了仅处理一个字符串的程序\*/

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char a[1000100];
int l,dp[1000100],maxn=-1;
int main()
{
    memset(dp,0,sizeof(dp));
    memset(a,0,sizeof(a));
    scanf("%s",a);
    l=strlen(a);
    int tot=0;//表示标签 
    for(int i=l-1;i>=0;i--)
    {
        if(a[i]==')'||a[i]==']');//分号的作用是直接拦截掉，相当于continue，因为以右括号开头的括号序列不可能是正确的序列 
        else
        {
            if((a[i+1+dp[i+1]]==')'&&a[i]=='(')||(a[i+1+dp[i+1]]==']'&&a[i]=='['))
            {
                dp[i]=dp[i+1]+2;
                dp[i]+=dp[i+dp[i]];
                if(maxn<=dp[i])
                {
                    maxn=dp[i];
                    tot=i;
                }
            }
        }
    }
    for(int i=tot;i<=maxn+tot-1;i++)
        cout<<a[i];
    return 0;
}
```

---

## 作者：Mr_Li (赞：5)

对于这道题，我们可以想到一种思路——得到以第i个字符结尾的最长括号匹配，求这些匹配的最长匹配即可。而如何求出以第i个字符结尾的最长括号匹配呢？这需要我们通过成为括号匹配的字符串的三个条件一步一步扩展得出——

1.对于第一个条件，我们只要在判断第i-1个字符是否与第i个字符组成一对（字符'('和')''['和']'分别是一对），是则将该对作为一个待扩展字符串；

2.对于第二个条件，只要求出以第i-1个字符结尾的最长括号匹配的前面一个字符是否与第i个字符组成一对，是则将整个以第i-1个字符结尾的最长括号匹配的前面一个字符及其后面一个字符作为一个待扩展字符串；

3.对于第三个条件，在处理完前两个条件之后，若能得到一个末尾是第x个字符的待扩展字符串，则判断是否存在以第i-1个字符结尾的最长括号匹配，若是，则以两者连接之后的字符串（字符串A和B连接之后为AB）作为以第i个字符结尾的最长括号匹配，否则，以待扩展字符串作为以第i个字符结尾的最长括号匹配，若不能得到待扩展字符串，则没有以第i个字符结尾的最长括号匹配。


---

## 作者：米奇奇米 (赞：5)

## 一道很好的细节模拟题！
### $1.1$题目大意：
求出最长的括号匹配序列，并且输出该序列！
### $2.1$思路理解
这道题目的思路很暴力。用一个数组$stak[i][1/2]$模拟栈存储。若为$stak[i][1]$代表一个未匹配完全的字符，$stak[i][2]$表示这个字符的位置。于是就开始$O(n)$暴力扫一遍，如果当前的字符与栈顶元素匹配，于是把这个字符以及与他匹配的字符的$vis[i]$标记为$1$。如果不匹配，把它也入栈即可。最后再$O(n)$扫一遍求出的$vis[]$最长$1$出现个数。
### $3.1$代码实现
```
#include <bits/stdc++.h>
using namespace std;
const int length=1e6+5;
char ch[length]; 
int stak[length][3];//stak[][1]表示字符,stak[][2]表示位置 
int n,vis[length],res,l,r,top,now,tmp;
int main() {
	const int xjh=1e6;
	scanf("%s",ch+1);
	int len=strlen(ch+1);
	for ( int i=1;i<=len;i++ ) {
		if((stak[top][1]=='[' && ch[i]==']') || (stak[top][1]=='(' && ch[i]==')')) 
			vis[i]=vis[stak[top--][2]]=1;
		else stak[++top][1]=ch[i],stak[top][2]=i;
	}
	for ( int i=1;i<=len;i++ ) {
		if(vis[i]==1) now=now+1;
		if(vis[i]==0) {
			if(now>res) l=(i-now),r=(i-1),res=r-l;
			now=0;
		}
	}
	for ( int i=l;i<=r;i++ ) putchar(ch[i]);
	return 0;
}
		
```
### $4.1$总结
这是一题很好的模拟题。主要是思路的转换，代码实现也很简单。**但是我想问巨佬们一个问题：为什么我与第一篇题解对排不上？是原题数据太弱，还是第一篇题解被$hike$掉了！**



---

## 作者：Seanq (赞：4)

**最长括号匹配_NOI导刊2009提高（1）**  
字符串dp  
线性  
f[i]表示以i为结尾的最长括号匹配为多少  
std:  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
char s[N];
int f[N];
int n;
int ans=0;
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='('||s[i]=='[') continue;
		else
		{
			if(s[i]==')'&&s[i-1-f[i-1]]=='('||s[i]==']'&&s[i-1-f[i-1]]=='[')
			{
				f[i]=f[i-1]+2+f[i-2-f[i-1]];
				ans=max(ans,f[i]);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(f[i]==ans)
		{
			for(int j=i-ans+1;j<=i;j++)
				printf("%c",s[j]);
			printf("\n");
			break;
		}
	}
	return 0;
} 
```

---

## 作者：Snitro (赞：3)

##[http://blog.csdn.net/Fine\_rose/article/details/75268054](http://blog.csdn.net/Fine\_rose/article/details/75268054)



用 F[i] 表示以 i 为开始的最长匹配字符串的长度

从右至左遍历输入的字符

分两种情况讨论当前字符：

如果 s[i] 为后括号 (s[i] 表示输入的第 i 位字符)，这种情况是最简单的，因为无论如何也不可能出现一个以后括号开头的合法匹配字符窜。

如果 s[i] 为前括号，那么需要判断 s[i] 与其后的若干个字符串合在一起是否能够构成一个合法的匹配字符串：

由于我们是从右至左遍历 s 数组，那么我们肯定已经得到 F[i + 1]，也就是说我们现在已经知道了 i 位置右侧最长的合法匹配字符串的长度，那么我们只需要判断位置为 i + F[i + 1] + 1 的字符是否与当前遍历到的字符相对应，如果恰好对应，那么 F[i] 的值既是 F[i + 1] + 2

注意题目中第三个条件 (若A,B是括号匹配的字符串，则AB也是括号匹配的字符串)。可以想象成我们目前已经计算出 A 的长度，但是不确定是否存在一个合法的匹配字符串 B 使其构成 AB 这样的合法字符串，因此需要将 F[i] += F[i + F[i]]

现在我们已经的到了正确的 F[] 数组，下面我们只需要遍历一遍得到最靠左侧的最大值即可输出答案

-
源代码






```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
string data;
int F[1000005]; // F[i] 表示的是以 i 开头的最长匹配的长度 
int main() {
    freopen("in.txt", "r", stdin);
    data.resize(1000000);
    scanf("%s", &data[0]);
    int id = 0; // 最靠左侧的最长的匹配字符串的初始位置
    for (int i = data.length() - 1; i >= 0; i--) {
        if (data[i] == ')' || data[i] == ']') // 如果是后括号则不存在匹配字符串
            continue;
        if ((data[i + F[i + 1] + 1] == ')' && data[i] == '(') || (data[i + F[i + 1] + 1] == ']' && data[i] == '[')) { // 判断是否存在匹配字符串的情况
            F[i] = F[i + 1] + 2; // 递推式
            F[i] += F[i + F[i]]; // 判断是否存在 A 与 B 两个合法的匹配字符串构成 AB 的情况
            if (F[i] >= F[id]) // 由于我们想要找出最靠左的最大值，所以这里要取等号
                id = i;
        }
    }
    for (int i = 0; i < F[id]; i++)
        cout << data[id + i];
    return 0;
}
```

---

## 作者：jzqjzq (赞：3)

我的做法和楼上主要想法差不多，只不过比楼上要简洁得多

这种东西可以直接用一个栈来维护

先考虑入栈，如果栈为空或者与栈顶元素不匹配，那么就直接压进去

顺便记录一下栈顶元素的位置在哪里

现在考虑弹栈操作，如果当前元素和栈顶匹配，弹栈更新答案

首先记录了栈顶的位置之后呢我们就可以知道当前匹配的括号中间有多少元素，而且都是匹配的（都已经被弹出了）

这样的话第一个和第三个条件就满足了

那第二个条件呢？我们对于每一个位置维护数组p表示与它能够匹配到的最靠近开头的位置

那么如果当前匹配到的栈顶位置-1有值的话，说明现在这个匹配子串可以接到上面那个匹配子串上

那么就直接接上去更新答案，顺便把当前元素的位置的p更新到栈顶元素-1位置的p

这样就可以满足条件2了

详见代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <ctime>
#include <map>
#include <queue>
#include <cstdlib>
#include <string>
#include <climits>
#include <set>
#include <vector>
using namespace std;
struct ppap{int w;char c;}s[1000001];
int top=0,ans,L,p[1000001]={0};//p数组同解析，ans表示最长的长度，L表示在ans的状态下的最早开始位置
char c[1000001];
inline bool check(char a,char b){
    if(a=='('&&b==')')return 1;
    if(a=='['&&b==']')return 1;
    return 0;
}
int main()
{
    scanf("%s",c+1);int l=strlen(c+1);
    for(int i=1;i<=l;i++){
        if(!top||!check(s[top].c,c[i]))top++,s[top].w=i,s[top].c=c[i];//不匹配直接压进栈里
        else{
            int a,b;
            if(p[s[top].w-1])a=p[s[top].w-1],b=i-p[s[top].w-1]+1,p[i]=p[s[top].w-1];//能够接到上一个子串，那就接上去
            else a=s[top].w,b=i-s[top].w+1,p[i]=s[top].w;//不能够接的话自己成一段
            if(b>ans||b==ans&&a<L)ans=b,L=a;//更新答案
            top--;
        }
    }
    for(int i=L;i<=L+ans-1;i++)putchar(c[i]);
    return 0;
}
```

---


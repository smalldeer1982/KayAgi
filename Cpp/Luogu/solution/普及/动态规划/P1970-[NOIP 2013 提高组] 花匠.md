# [NOIP 2013 提高组] 花匠

## 题目背景

NOIP2013 提高组 D2T2

## 题目描述

花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。

具体而言，栋栋的花的高度可以看成一列整数 $h_1,h_2,\ldots,h_n$。设当一部分花被移走后，剩下的花的高度依次为 $g_1,g_2,\ldots,g_m$，则栋栋希望下面两个条件中至少有一个满足：

条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；  
条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。

注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。

请问，栋栋最多能将多少株花留在原地。


## 说明/提示

**输入输出样例说明**

有多种方法可以正好保留 $3$ 株花，例如，留下第 $1$、$4$、$5$ 株，高度分别为 $5$、$1$、$2$，满足条件 B。

**数据范围**

对于 $20\%$的数据，$n \le 10$；

对于 $30\%$的数据，$n \le 25$；

对于 $70\%$的数据，$n \le 1000$，$0 \le h_i \le 1000$；

对于 $100\%$的数据，$1 \le n \le {10}^5$，$0 \le h_i \le {10}^6$，所有的 $h_i$ 随机生成，所有随机数服从某区间内的均匀分布。


## 样例 #1

### 输入

```
5
5 3 2 1 2
```

### 输出

```
3
```

# 题解

## 作者：wuzhoupei (赞：294)

作为一道NOIP真题，这道题个人感觉比较水，稍稍用到了DP的思想；


我们仔细分析，发现两个条件可以总结为：求一个最长序列，使得该序列的任意三个相邻元素，中间的元素是三个中最大的，或者最小的；


对此，我们可以联想到最长不下降子序列，这道题我是由此想到正解的；


比如元素d[i]和d[j]，假设d[i]>d[j]且j>i，那么我们会让long\_[j]=max(long\_[j],long\_[i]+1); 那么我们可以类比一下，最长不下降子序列是在当前节点前面找一个符合条件的，那么我们这道题也可以作为一道最长不下降子序列来做，只是当前节点寻找前驱的范围是前一个节点，而且我们还要用同样的方法求一个最长不上升子序列，最后取max，那么这道题就完了；


细节处理见代码：


(代码中的最高最低全部是以当前节点为中心时的相对值)


我的博客：  http://blog.csdn.net/pretend\_fal


```cpp
#include<iostream>
#include<cstdio>
#define II int
#define R register
#define I 123456
using namespace std;


II a[I],d_1[I],d_2[I];

II n;


int main()
{
//  freopen("FlowerNOIP2013.in","r",stdin);
//  freopen("FlowerNOIP2013.out","w",stdout);
    scanf("%d",&n);
    R II x;
    for(R II i=1;i<=n;i++) scanf("%d",&x), a[i]=x;
    d_1[1]=d_2[1]=1;
    //d_1[]代表的是当前元素是以当前元素为中心的三个相邻的元素中最大的；
    //同理，d_2[]代表的是当前元素是以当前元素为中心的三个相邻的元素中最小的；
    //但是当前元素不一定选，可能是继承上一个元素的信息；
    for(R II i=2;i<=n;i++)
    {
        if(a[i]>a[i-1]) d_1[i]=max(d_1[i-1],d_2[i-1]+1), d_2[i]=d_2[i-1];
        //如果当前元素大于这个前一个元素；
        //那么当前元素若果选，则是前一个元素作为最低点时的长度+1；
        //如果不选，就继承前一个元素作为最高点，等价于当前元素作为最高点；
        //当前元素作为最低点就只能继承前一个点作为最低点；
            else{
                if(a[i]<a[i-1]) d_1[i]=d_1[i-1], d_2[i]=max(d_1[i-1]+1,d_2[i-1]);
                //如果当前元素小于前一个元素，则道理同上，只是反过来；
                    else d_1[i]=d_1[i-1],   d_2[i]=d_2[i-1];
                    //如果当前元素等于前一个元素，那么这个元素直接继承前一个元素的所有信息；
                    //因为这两个点是完全等价的；
            }
    }
    R II ans=max(d_1[n],d_2[n]);
    //我们在最后时取两种状态的最大值作为答案；
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：GSQ0829 (赞：5)

### 思路：
提供一个根本不需要数组的方法。

主要是看题解区都是用数组，所以这个不用数组的方法告诉大家。

这道题实际上只需要贪心找折线就可以了。

做法其实不是太难想。这道题其实就是找到一个最长的波浪序列（每一盆花都是波峰或波谷）。

首先，对于第一盆花，不论如何都要选，因为如果不选，第二盆花就相当于第一盆，而花的总数却减少了，所以一定不会更优。

对于第二盆花，如果和第一盆等高，就没有用，可以直接不选（这时候还是找第二盆）；如果比第一盆高，那么它就一定要作为波峰（如果作为波谷则等同于第一盆没选）；同理如果比第一盆低就一定是波谷。

对于后面的花，如果找波峰，如果当前花比上一盆高，那么波峰就找到了，接下来找波谷；如果不如上一盆高，那么用这盆更低的花继续找波峰结果一定不会更差。找波谷同理。

在操作过程中记录留下多少花即可。

---

### code：
代码如果不懂可以私信我（记得关注我）。
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, t = 0, ans = 1, cnt = -1;

int main() {
	scanf("%d %d", &n, &m);
	t = m;
	for (int i = 2; i <= n; i++) {
		scanf("%d", &m);
		if (m > t && cnt != 1) {
			cnt = 1;
			ans++;
		} else if (m < t && cnt) {
			cnt = 0;
			ans++;
		}
		t = m;
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Aleph1022 (赞：4)

解法比较清奇？

首先看到题可以想到一个很显然的 DP：  
设 $f_{i,0/1}$ 分别表示选取的子序列的结尾是 $h_i$，满足 $A/B$ 性质的最大长度。

那么转移的话，

$$\begin{aligned} f_{i,0} = \max\limits_{j < i,a_j < a_i} f_{i,1} + 1 \\ f_{i,1} = \max\limits_{j < i,a_j > a_i} f_{i,0} + 1 \end{aligned}$$

但是这样子是 $O(n^2)$ 的。  
于是很多人把它优化到了 $O(n)$。  
但是我太菜了只能优化到 $O(n \log n)$。

先只考虑 A 性质，B 同理。  
仔细观察转移的式子，对 $j$ 的限制是 $j < i,a_j < a_i$。  
那么这不就是一个二维偏序？  
可以用数据结构 $O(n \log^2 n)$ 或 $O(n \log n)$ 解决。

具体来说，我们可以把每个数看成平面直角坐标系上的点 $(i,a_i)$，并且这个点有一个权值 $f_{i,0}$。  
那么每个 $f_{i,0}$ 就是在矩形 $(1,0) - (i - 1,a_i - 1)$ 里的权值最大值 $+ 1$。  
但是这个权值是动态变化的，所以我们要按照 $i$ 的顺序递推。

然后问题在于二维偏序怎么解决。  
几个经典做法中，首先显然 CDQ 是不行的，因为权值动态变化要在线查询。  
树套树码量比较大，而且没有必要。

先忽略 $j < i$ 的限制，那么可以用权值线段树来维护。  
时刻保持线段树里只有 $[1,i-1]$ 的数即可满足 $j < i$ 的限制，也就是处理完一个 $i$ 才把 $f_{i,0}$ 插入线段树。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5;
const int A = 1e6;
int n,a[N + 5];
int f[N + 5][2];
struct node
{
    int max,ls,rs;
} seg[(N << 5) + 10];
int rt[2];
void change(int x,int k,int &p,int tl,int tr)
{
    static int tot = 0;
    if(!p)
        p = ++tot;
    if(tl == tr)
    {
        seg[p].max = k;
        return ;
    }
    int mid = tl + tr >> 1;
    if(x <= mid)
        change(x,k,seg[p].ls,tl,mid);
    else
        change(x,k,seg[p].rs,mid + 1,tr);
    seg[p].max = max(seg[seg[p].ls].max,seg[seg[p].rs].max);
}
int query(int l,int r,int p,int tl,int tr)
{
    if(!p || (l <= tl && tr <= r))
        return seg[p].max;
    int mid = tl + tr >> 1;
    int ret = 0;
    if(l <= mid)
        ret = max(ret,query(l,r,seg[p].ls,tl,mid));
    if(r > mid)
        ret = max(ret,query(l,r,seg[p].rs,mid + 1,tr));
    return ret;
}
int main()
{
    scanf("%d",&n);
    for(register int i = 1;i <= n;++i)
    {
        scanf("%d",a + i);
        f[i][0] = query(0,a[i] - 1,rt[1],0,A) + 1,f[i][1] = query(a[i] + 1,A,rt[0],0,A) + 1;
        change(a[i],f[i][0],rt[0],0,A),change(a[i],f[i][1],rt[1],0,A);
    }
    printf("%d\n",max(f[n][0],f[n][1]));
}
```

---

## 作者：kunkun127 (赞：2)

## 思路

  本题可以使用常规的 DP 方法，如果锻炼思维的话还可以使用贪心。但本题解仅叙述 DP 方法，如想更进一步可移步其他题解。

  令 $a_i$ 为第 $i$ 朵花的高度。
  
  - 题面
   
      仔细阅读题面，两个条件加一个提示：

      - 条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；
     
      - 条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。

      **注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。**


    通过对题面总结归纳出来，连续三朵花，中间的花要么是最大的，要么是最小的。不难发现可以使用**最长不下降子序列**和**最长不上升子序列**，最后取两者间最大者输出即可。

- DP 转移
   
  我们需要两个数组分别进行不下降和不上升的 DP 操作。令其分别为 $f1$ 和 $f2$。
   
  如果 $a_i > a_{i-1}$：
   
  - 选，就是 $a_{i-1}$ 作为最低点时的长度加一。  
    可得转移方程：
    $$f1_i = f2_{i-1} + 1$$
  - 不选，就直接将 $a_{i-1}$ 作为最高点，也就是 $a_i$ 作为最高点。  
  可得转移方程：
    $$f1_i = f1_{i-1}$$

   如果 $a_i < a_{i-1}$，过程与上相反。
   
  详细过程可通过参考代码理解。

## 参考代码

  
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100005], dp1[100005], dp2[100005];

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	dp1[1] = 1, dp2[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		if (a[i] > a[i - 1]) dp1[i] = dp2[i - 1] + 1;
		else dp1[i] = dp1[i - 1];
		if (a[i] < a[i - 1]) dp2[i] = dp1[i - 1] + 1;
		else dp2[i] = dp2[i - 1];
	}
	cout << max(dp1[n], dp2[n]) << endl;
	return 0; 
} 
```

---

## 作者：glass_goldfish (赞：1)

本题可以使用贪心的方法解决。

因为有两个条件（任选其一达成即可），所以分开考虑。  
如果某株花比上一朵花高，那么呈上升趋势；  
如果某株花比上一朵花矮，那么呈下降趋势；  
如果某株花和上一朵花一样高，那么可以忽略，因为对趋势没有影响。

使用变量记录当前的花应该上升还是下降，然后找到最靠前的一株花，然后把变量的值反转（上升变成下降，下降变成上升），并把计数器 $+1$。最后输出两个计数器中的较大值即可。

---

## 作者：Trilarflagz (赞：1)

### 分析
**直接贪心**（据说**动态规划**也可以orz）

保留的花要么左右两边高度都比它高，要么左右两边高度都比它低。

因此一段连续上升的序列和一段连续下降的序列只保留一个转折点。

注意答案还要加开头和结尾的点√
### 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100050;
int n,a[N],ans;
int read(){
	int sum=0,f=1;
    char ch=getchar();
    while(ch>'9'||ch<'0')
    {
    	if(ch=='-')f=-1;
    	ch=getchar();
	}
	 while(ch>='0'&&ch<='9')
    {
    	sum=(sum<<3)+(sum<<1)+ch-'0';
    	ch=getchar();
	}
	return sum*f;
}
int main(){
	freopen("flower.in","r",stdin);
	freopen("flower.out","w",stdout);
	n=read();
	a[1]=read();
	ans=1;
	int flag=-1;
	for(int i=2;i<=n;i++)
	{
		a[i]=read();
		if(i==n)ans++; 
		if(a[i]>a[i-1]){
			if(flag==0)ans++;
			flag=1;
		}
		if(a[i]<a[i-1]){
			if(flag==1)ans++;
			flag=0;
		}
	}
	cout<<ans;
	return 0;
} 
```


---

## 作者：sbh2012 (赞：0)

## 思路
很明显，为了使 $a_{i-1} < a_i < a_{i+1}$ 那这串花的高度必须是一高一低或一低一高的，那我们定义 $f_{i,0}$ 为当前为上升形势最长花序列的长度，$f_{i,1}$ 当前为下降形势最长花序列的长度。
## 转移方程
$f_{i,0} = \begin{cases}
  f_{i-1,1}+1 & a_{i-1} < a_i \\
   f_{i-1,0} & a_{i-1} \ge a_i \\
\end{cases} $\
$f_{i,1} = \begin{cases}
  f_{i-1,0}+1 & a_{i-1} > a_i \\
   f_{i-1,1} & a_{i-1} \le a_i \\
\end{cases}$
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],f[100005][2];
int main(){
	int n;
	cin>>n;
	f[1][0]=f[1][1]=1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i!=1){
			f[i][0]=f[i-1][0];
			f[i][1]=f[i-1][1];	
		}	
		if(a[i-1]<a[i]){
			f[i][0]=f[i-1][1]+1;
		}else if(a[i-1]>a[i]){
			f[i][1]=f[i-1][0]+1;
		}
//		cout<<f[i][0]<<' '<<f[i][1]<<endl;
	}
	cout<<max(f[n][0],f[n][1]);
	return 0;
}
```

---

## 作者：RaymondOccam (赞：0)

### 思路

由条件 $A,B$，并且可以移走一些花，得形式化题面：

求一个最长**子序列**的长度，要求任意三个数，中间的那个数是三个数中最大或者最小的那个数。

可以使用最长上升子序列以及最长下降子序列，最后取最大值就可以了。

设计 $f_i$ 表示前 $i$ 个元素中的最长上升子序列长度。

设计 $g_i$ 表示前 $i$ 个元素中的最长下降子序列长度。

综上得到状态转移方程：

$$
f_x =
\begin{cases}
f_{x-1} & h_i\le h_{i-1} \\
g_{x-1}+1 & h_i\gt h_{i-1} \\
\end{cases}
$$
$$
g_x=
\begin{cases}
g_{x-1} & h_i\gt h_{i-1} \\
f_{x-1}+1 & h_i\le h_{i-1} \\
\end{cases}
$$

初始化 $f_i=g_i=1$，递推求解即可。

### 核心代码

给出初始化+转移部分：

```cpp
f[1] = g[1] = 0;
for (int i = 2; i <= n; i++) {
  f[i] = (h[i] > h[i - 1] ? g[i - 1] + 1 : f[i - 1]);
  g[i] = (h[i] < h[i - 1] ? f[i - 1] + 1 : g[i - 1]);
}
```

---

## 作者：lizhixun (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P1970)

### $\texttt{Description}$

求一个序列的最长交替子序列 $a$。定义为：

- 若 $a_i>a_{i-1}$，则 $a_{i+1}$ 必须小于 $a_i$。
- 若 $a_i<a_{i-1}$，则 $a_{i+1}$ 必须大于 $a_i$。

求 $a$ 的最长长度。

### $\texttt{Solution}$

不难想到二分，但似乎又无法实现。于是开始思考 $\texttt{DP}$。

发现可以实现，实际上就是[最长上升子序列](https://www.luogu.com.cn/problem/B3637)的升级版。

#### 确定状态

$dp_{i,0}$ 表示当前的最长上升子序列，$dp_{i,1}$ 表示当前最长下降子序列。

#### 确定答案

易得为 $\max(dp_{n,0},dp_{n,1})$。

#### 状态转移方程

易得为：

$$f_{i,0} =  \begin{cases} f_{i - 1,0} & a_i \leq a_{i - 1} \\ f_{i - 1,1} + 1 & a_i > a_{i - 1} \end{cases} \\f_{i,1} =  \begin{cases}f_{i - 1,1} & a_i > a_{i - 1} \\ f_{i - 1,0} + 1 & a_i \leq a_{i - 1} \end{cases}$$

跟最长上升子序列的差不多。

#### 确定初始值 & 边界

$$dp_{1,0}=1,dp_{1,1}=1$$

边界问题：从 $2$ 到 $n$ 递推。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e5 + 5;
int n, a[maxn], dp[maxn][2];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	
	dp[1][0] = dp[1][1] = 1;
	
	for (int i = 2; i <= n; i++) {
		dp[i][0] = (a[i] > a[i - 1] ? dp[i - 1][1] + 1 : dp[i - 1][0]);
		dp[i][1] = (a[i] < a[i - 1] ? dp[i - 1][0] + 1 : dp[i - 1][1]);
	}
	
	cout << max(dp[n][0], dp[n][1]) << endl;
	return 0;
}
```

完结。

---

## 作者：Co_Ce (赞：0)

# solution
[传送门](https://www.luogu.com.cn/problem/P1970)
## 分析
由条件可得：求一个最长序列，使该序列任意三个元素，中间为最大或最小。
## 思路 
用 `dp[i][0]` 表示前 $i$ 个元素是以 $i$ 为中心的三个相邻的元素中的最大的。  
用 `dp[i][1]` 表示前 $i$ 个元素是以 $i$ 为中心的三个相邻的元素中的最小的。  
当 `h[i]<h[i-1]` 时，选 $i$，则 `dp[i][1]=dp[i-1][0]+1`，不选，则 `dp[i][1]=dp[i-1][1]`。  
最后，输出 `max(dp[n][1],dp[n][0])`。
## std：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int dp[100010][5];
int h[100010]; 
int main(){
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>h[i];
	}
	dp[1][0]=1;
	dp[1][1]=1;
	for(int i=2;i<=n;i++){
		h[i]>h[i-1]?dp[i][0]=dp[i-1][1]+1:dp[i][0]=dp[i-1][0];
		h[i]<h[i-1]?dp[i][1]=dp[i-1][0]+1:dp[i][1]=dp[i-1][1];
	}
	cout<<max(dp[n][1],dp[n][0]);
	return 0;
}
```

---

## 作者：DashZhanghanxu (赞：0)

# 解析

看到题目中要求花的高度要有顺序，所以条件反射用 dp。

  先看数据范围，$n \le 100000$，只能用一重循环，二维数组大概是会超时的。

具体做法呢，是先循环遍历数组，若该花高度大于上朵花高度，那么当前 a 方案花数是选择 b 方案的上一朵花数数加一，反过来，若小于上朵花高度，当前 b 方案花数是 a 方案选择上一朵花的花数加一，最后输出较大方案花数。

最后提醒一下，不要用下一朵花高度大于当前花高度进行 dp 数组判定，会超范围。
# CODE

```python
n = int(input())
nums = list(map(int, input().split()))

a = [1] * n
b = [1] * n

for i in range(1, n):
    if nums[i] > nums[i - 1]:
        a[i] = b[i - 1] + 1;
        b[i] = a[i];
    elif nums[i] < nums[i - 1]:
        b[i] = a[i - 1] + 1;
        a[i] = b[i];
print(max(max(a), max(b)))
```

---

## 作者：zhangzirui66 (赞：0)

## 闲话
本文同步发布在 [cnblogs](https://www.cnblogs.com/zhangzirui66)。

## 正题
容易发现此题要求花必须一高一低摆放。

最优化问题，看不出怎么贪心，遂 DP。

### 设计状态

$f_{i, 0}$ 表示当前为上升形势最长花序列，$f_{i, 1}$ 表示当前为下降形势最长花序列。

### 状态转移

由于需要一高一低，易得：
$$
f_{i, 0} = \begin{cases}
    f_{i - 1, 0}&a_i \le a_{i-1}\\
    f_{i - 1, 1} + 1&a_i > a_{i-1}\\
\end{cases}
$$
$$
f_{i, 1} = \begin{cases}
    f_{i - 1, 1}&a_i > a_{i-1}\\
    f_{i - 1, 0} + 1&a_i \le a_{i-1}\\
\end{cases}
$$

直接实现即可。

### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[500005], f[500005][2];
int main(){
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    f[1][0] = f[1][1] = 1;//边界处理
    for(int i = 2; i <= n; i ++){
        f[i][0] = f[i - 1][0]; f[i][1] = f[i - 1][1];//转移公式第一项
        if(a[i] > a[i - 1]) f[i][0] = f[i - 1][1] + 1;//转移公式第二项
        if(a[i] < a[i - 1]) f[i][1] = f[i - 1][0] + 1;//转移公式第二项
    }
    cout << max(f[n][0], f[n][1]);
	return 0;
}
```

---

## 作者：Hacker_Cracker (赞：0)

## P1970 [NOIP2013 提高组] 花匠

### 思路

看到上升、下降，首先想到了 LIS。但是这道题是要求交替上升或下降，已本蒟蒻的能力想不到 DP。

所以我们就使用**贪心**。

维护两个变量 $ans1$ 和 $ans2$。其中 $ans1$ 记录的是如果当前的数相较于我们**已选定的数列**的最后一个数，也就是当前的数的上一个数，是呈上升趋势的，那么我们可以选择的序列的最大长度。变量 $ans2$ 正好相反。

是不是有点拗口？其实就是记录先升后降和先降后升的子序列最大长度的较大值。

时间复杂度 $O(N)$，可以通过本题。

### Tips
- 循环从第二个开始。
- 两个变量初始值为 $1$，因为最短子序列长度最少是 $1$。


### [AC](https://www.luogu.com.cn/record/197800640) CODE

---

## 作者：FastIO_DP (赞：0)

### 题目理解

栋栋种了一排花，每株花都有一个高度。栋栋希望移走一些花，使得剩下的花排列得比较别致。题目中说明了剩下的花要满足以下两个条件之一：

1. **条件 A**：剩下的花的高度要交替上升和下降。
2. **条件 B**：剩下的花的高度要交替下降和上升。

输出的是找到最多能留下多少株花。

### 解题思路

为了找到最多留下的花数，考虑**贪心**。

> 贪心算法的核心思想是每一步都做出当前最优的选择，最终得到全局最优解。

具体点，通过遍历花的高度序列，记录现在的花是处于上升还是下降。

> 如果现在的花比前一株高，我们就认为它处于上升趋势。如果比前一株低，就处于下降趋势。

> 如果高度相等，我们可以忽略这株花，因为它不会影响趋势的变化。

遍历数组这个过程中，维护两个变量：$up$ 和 $down$。

> $up$：表示当前处于上升时，最多能留下多少株花。
> $down$：表示当前处于下降时，最多能留下多少株花。

每当遇到一个上升趋势时，$up$ 的值更新为 $down + 1$，因为当前花比前一株高，可以接在下降趋势的后面。同理，当遇到下降趋势时，$down$ 的值更新为 $up + 1$。

结尾，我们取 $up$ 和 $down$ 中的最大值，就求出了最多能留下的花的数量。

### 代码实现

```cpp
#include <iostream>
#include <vector>
using namespace std;

int h[100005];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> h[i];
    }
    int up = 1, down = 1;
    for (int i = 1; i < n; ++i) {
        if (h[i] > h[i - 1]) {
            up = down + 1; // 当前为上升
        } else if (h[i] < h[i - 1]) {
            down = up + 1; // 当前为下降
        }
        // 如果 h[i] == h[i-1]，则跳过，不改变
    }
    cout << max(up, down) << endl;
    return 0;
}
```

### 复杂度

时间复杂度：$O(n)$。

- 只遍历了一次 $h$ 数组。

空间复杂度：$O(n)$。

- 只存储了所有花的高度数组 $h$。

---


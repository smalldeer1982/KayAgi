# 战略游戏

## 题目背景

Bob 喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。


## 题目描述

他要建立一个古城堡，城堡中的路形成一棵无根树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能瞭望到所有的路。

注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被瞭望到。

请你编一程序，给定一树，帮 Bob 计算出他需要放置最少的士兵。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 1500$。

## 样例 #1

### 输入

```
4
0 1 1
1 2 2 3
2 0
3 0
```

### 输出

```
1
```

# 题解

## 作者：kikuss (赞：95)

# Solution
树形结构!!!

因为是一棵树,所以对于每个节点,我们都把它当成根节点处理$\to$树形dp!!!

>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。

定义状态dp[u][0/1]表示u这个节点不放/放士兵

根据题意,如果当前节点不放置士兵,那么它的子节点必须**全部**放置士兵,因为要满足士兵可以看到所有的边,所以
$$dp[u][0]+=dp[to][1]$$
其中to是u的子节点

如果当前节点放置士兵,它的子节点选不选已经不重要了(**因为树形dp自下而上,上面的节点不需要考虑**),所以
$$dp[u][1]+=min(dp[to][0],dp[to][1])$$

欢迎踩博客[real_l](https://www.cnblogs.com/real-l/p/9620350.html)

# Code
```cpp
#include<bits/stdc++.h>
#define rg register
#define il inline
#define Min(a,b) (a)<(b)?(a):(b)
#define Max(a,b) (a)>(b)?(a):(b)
using namespace std;

const int N=1510;

void in(int &ans) {
    ans=0; char i=getchar();
    while(i<'0' || i>'9') i=getchar();
    while(i>='0' && i<='9') ans=(ans<<1)+(ans<<3)+i-'0',i=getchar();
}

int n,cur;

int to[N<<1],nex[N<<1],head[N];
int dp[N][2];

il void add(int a,int b) {
    to[++cur]=b;
    nex[cur]=head[a];
    head[a]=cur;
}

il void read() {
    for(rg int i=1;i<=n;i++) {
        int x,k,y; in(x),in(k);
        for(rg int j=1;j<=k;j++) {
            in(y); add(x,y),add(y,x);
        }
    }
}

void dfs(int u,int fa) {
    dp[u][1]=1,dp[u][0]=0;
    for(rg int i=head[u];i;i=nex[i]) {
        if(to[i]==fa) continue;
        dfs(to[i],u);
        dp[u][0]+=dp[to[i]][1];
        dp[u][1]+=Min(dp[to[i]][1],dp[to[i]][0]);
    }
}

int main()
{
    in(n); read(); dfs(0,-1);
    printf("%d\n",Min(dp[0][0],dp[0][1]));
    return 0;
}
```

---

## 作者：pengym (赞：35)


# .
这题其实有几种方法，其中比较显而易见的或许是**树形dp**吧，楼下有很多大佬已经解释过了，（这里

就不再说了)，仔细一看题就可以发现这是一个典型的**最小点覆盖**。最小点覆盖指的是在一个图中：一个点

覆盖与之连接的边，求用最少的点可以覆盖。这和题目要求一模一样。同时还有一个定理，最小点覆盖=

最大匹配数。如果是无向图则/2。因此就很容易想到打匈牙利算法了。


# .

```cpp
#include<queue>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#define N 7000
using namespace std;
inline void read(int &x)
{
    x=0;
    int p=1;
    char c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    x*=p;
}
int n;
int to[N],beg[N],nex[N],match[N];
int vis[N];
int e;
int ans;
void add(int x,int y)
{
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
}
int dfs(int x)
{
    for(int i=beg[x];i;i=nex[i])
    {
        int y=to[i];
        if(!vis[y])
        {
            vis[y]=1;
            if(!match[y]||dfs(match[y]))
            {
                match[y]=x;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        memset(beg,0,sizeof(beg));
        e=0;
        for(int i=1;i<=n;i++)
        {
            int x,gs;
            read(x);
            read(gs);
            x++;
            int y;
            for(int j=1;j<=gs;j++)read(y),y++,add(x,y),add(y,x);
        }
        ans=0;
        memset(match,0,sizeof(match));
        for(int i=1;i<=n;i++)
        {
        memset(vis,0,sizeof(vis));
        if(dfs(i))ans++;
        }
        printf("%d\n",ans/2);
    }
    return 0;
}
```

---

## 作者：BFqwq (赞：15)

# P2016
## 题意
在一棵树上的节点放一些士兵，使所有边都至少有一个端点有兵，求最小的士兵数。

## 一点点经验
显然，这是一个树上的dp问题。

有句话说得好：要是一道题不够难，我们就把他放到树上。

其实这句话反过来也成立：要是树上太难，我们就把他放到链上。

所以，本篇题解就会从链讲起。
## 思考
先考虑链上的情况（虽然不是部分分）

对于每一个节点，只有选或者不选两种情况。
如果选的话，上一个节点选或者不选没有关系

要是不选的话，上一个节点就必须选.

我们不妨默认节点编号为$1,2,3\cdots n$

则我们可以推出两个式子：

$f(i,0)=f(i-1,1)$

$f(i,1)=\min(f(i-1,0),f(i-1,1))+1$

第二维的0代表选，1代表不选。

接着，我们把这个题放到树上。

一般树上的dp，都会用dfs的方式解决。

带着刚才的思路，假设我已经处理好了所有子树的信息，

那么对于这个点，要是选，则所有的子树可以选或不选

要是不选，那么所有的子树就必须选

那么两个式子也就有了：

$f(u,0)=\sum f(soni,1)$

$f(u,1)=1+\sum \min(f(soni,0),f(soni,1))$

($soni$代表第i个儿子，这里简单写了)

然后最后的答案就是$\min(f(1,0),f(1,1))$（我默认以1为根）

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
const int maxm=20000;
const int maxn=2000;
struct _{
	int to,nxt;
}e[maxm];
int h[maxn],n,m,cnt,f[maxn][2];
void add(int u,int v){
	e[++cnt].nxt=h[u];
	e[cnt].to=v;
	h[u]=cnt;
}
void dfs(int u,int fa){
	f[u][1]++;
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		f[u][0]+=f[v][1];
		f[u][1]+=min(f[v][0],f[v][1]);
	}
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		int a=read()+1,k=read();
		for(int j=1;j<=k;j++){
			int b=read()+1;
			add(a,b);add(b,a);
		}
	} 
	dfs(1,0);
	printf("%d",min(f[1][1],f[1][0]));
	return 0;
}













```



---

## 作者：唔啊唔 (赞：14)

此题是一道非常明显的树状动规，个人认为与P1352是有点像的，在做这道题目之前大家可以去尝试一下（那一道似乎更简单）

话不多说，直接讲思路了

f[i][0] 表示不在这个位置放置士兵而使i节点及其所有子树上的点都能被瞭望到的最小花费（最少需要放置多少个士兵）

f[i][1] 表示在这个位置放置士兵而使i节点及其所有子树上的点都能被瞭望到的最小花费

目标为 min(f[root][0],f[root][1])

用y来历x的所有子节点

且每次预处理 f[x][0]=0 , f[x][1]=1

状态转移方针为：

f[x][0]+=f[y][1];
	
f[x][1]+=min(f[y][1],f[y][0]);

那么最后搬上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[5000][5000],father[5000];
vector<int> s[5000];
inline void dfs(int x){
	f[x][0]=0;
	f[x][1]=1;
	if(s[x].size()==0)return;
	for(register int i=0;i<s[x].size();i++){
		int y=s[x][i];
		dfs(y);
		f[x][0]+=f[y][1];
		f[x][1]+=min(f[y][1],f[y][0]);
	}
}
int main(){
	int n;
	scanf("%d",&n);
	int a,b,z;
	for(register int i=1;i<=n;i++){
		scanf("%d%d",&a,&b);
		a++;
		for(register int j=1;j<=b;j++){
			scanf("%d",&z);
			z++;
			s[a].push_back(z);
			father[z]=1;
		}
	}
	int root;
	for(register int i=1;i<=n;i++){	//题目未指定根节点,因此需要自己找根节点 
		if(father[i]==0){
			root=i;
			break;
		}
	}
	dfs(root);
	cout<<min(f[root][0],f[root][1]);
}
```


---

## 作者：ChrisK (赞：10)

## 树形DP

设$f[i][0]$是i这个节点不放的最少数量。

$f[i][1]$就是放的最少数量。

那么转移就是  
$f[i][0]$+=$f[j][1]$   
$f[i][1]$+=$min(f[j][1],f[j][0])$ ($j$是$i$的儿子)

代码就很好写了。

#### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1510;
int n,f[maxn][2];
vector<int> G[maxn];
inline void dfs(int x,int fa){
    f[x][1]=1;
    for(int i=0;i<G[x].size();i++){
        int to=G[x][i];
        if(to==fa) continue;
        dfs(to,x);
    }
    for(int i=0;i<G[x].size();i++){
        int to=G[x][i];
        if(to==fa) continue;
        f[x][0]+=f[to][1];
        f[x][1]+=min(f[to][0],f[to][1]);
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int x,k;scanf("%d%d",&x,&k);x++;
        for(int i=1;i<=k;i++){
            int y;scanf("%d",&y);y++;
            G[x].push_back(y);G[y].push_back(x);
        }
    }
    dfs(1,0);
    printf("%d\n",min(f[1][0],f[1][1]));
    return 0;
}
```


---

## 作者：jiangminghong (赞：8)

f(x) 表示选定 x, 保证子树合法，子树内所需要的最小点数。

g(x) 表示不选择 x, 保证子树合法所需要的最小点数

f(x) = ∑min{f(son[x]), g(son[x])}

g(x) = ∑f(son[x])

```cpp
#include<stdio.h>
#define inf 1000000000
int n,a,b,c,idx,head[1501],f[1501][2];
struct Edge
{
    int to,next;
}edge[3001];
int min(int x,int y)
{
    if(x<y)
        return x;
    return y;
}
void addedge(int x,int y)
{
    ++idx;
    edge[idx].to=y;
    edge[idx].next=head[x];
    head[x]=idx;
}
void dfs(int x,int from)
{
    f[x][1]=1;
    f[x][0]=0;
    if(head[x]==0) f[x][0]=inf;
    for(int i=head[x];i;i=edge[i].next)
    {
        if(edge[i].to!=from)
        {
            dfs(edge[i].to,x);
            f[x][1]+=min(f[edge[i].to][1],f[edge[i].to][0]);
            f[x][0]+=f[edge[i].to][1];
        }
    }   
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a,&b);a++;
        for(int j=1;j<=b;j++)
        {
            scanf("%d",&c);c++;
            addedge(a,c);
            addedge(c,a);
        }
    }
    dfs(1,0);
    printf("%d",min(f[1][1],f[1][0]));
} 
```

---

## 作者：wwyx2001 (赞：5)

一次A的简单树形dp题目，C++福利哦

tt数组存储有什么编号，c数组判断是不是根节点

1、    建树

2、    递归求解

f[i][0]表示不选这个节点，这样就会有孩子节点选

f[i][1]表示选这个节点，这样就会有孩子节点不选or选【不要忘了加自己的1

最后吐槽一句，这题和没有上司的舞会好像。。。

代码如下

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
bool c[1600],d[1600];
int tt[1600],a[1600][1600],f[1600][2],n,h=0;
void make()
{
    int i,j;
    memset(d,1,sizeof(d));
    memset(c,1,sizeof(c));
    for (i=1;i<=n;i++)
      {
          int x,k;
          scanf("%d%d",&x,&k);
          if (d[x]) {
              tt[++h]=x; d[x]=false;
          }
          for (j=1;j<=k;j++)
          {
              int e;
              scanf("%d",&e);
            a[x][++a[x][0]]=e; 
            if (d[e]) {
                tt[++h]=e; d[e]=false;
            }
            c[e]=false; 
         } 
      }
}
void dfs(int i)
{
    if (a[i][0]==0)
    {
        f[i][1]=1; return;
    }
    int k;
    for (k=1;k<=a[i][0];k++)
      dfs(a[i][k]);
    for (k=1;k<=a[i][0];k++)
      {
          f[i][0]+=f[a[i][k]][1];
         f[i][1]+=min(f[a[i][k]][0],f[a[i][k]][1]);
      }
    f[i][1]+=1;
}
int main()
{
    int i,he=0;
    scanf("%d",&n);
    make();
    sort(tt+1,tt+h); 
    for (i=1;i<=h;i++)
      if (c[tt[i]])
        {
            dfs(tt[i]);
            he+=min(f[tt[i]][0],f[tt[i]][1]);
        }
    printf("%d",he);
}

```

---

## 作者：LiveZoom (赞：3)

# 题解 P2016 战略游戏

这题一眼看上去是一道树形DP的题目，然后后面一想好像可以用二分图来做（虽然是教练提醒的），故产生了此份题解。

## 题目大意

给定一个无根树，每个节点可以“管制”一堆给定点，求选择最少的点数来覆盖这棵树。

## Solution

这题的“覆盖”看起来有那么亿点点像最小点覆盖，所以可以想想如何用二分图来解。

### 如何建立二分图？

注意到这是一棵树，则每层之间肯定不会有连接，而且没有跨越两层的边，所以我们可以把原图划分为奇数层和偶数层。

然后跑匈牙利貌似就可以了。

Tips：最小点覆盖数就是最大匹配数。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1505;

vector <int> G[N];

int n, ind, k, r;
int ans, tot, dep[N], points[N];//tot表示奇数层点个数，dep[]表示每个点的层数，points[]表示所有奇数层点

bool vis[N];

void Pre (int k) {//处理出层数
	for (int i = 0; i < (int)G[k].size(); ++i) {
		int to = G[k][i];
		if (vis[to]) continue ;
		vis[to] = true, dep[to] = dep[k] + 1;
		Pre(to);
	}
}

int match[N];

bool DFS (int k) {//匈牙利板子
	for (int i = 0; i < (int)G[k].size(); ++i) {
		int to = G[k][i];
		if (!vis[to]) {
			vis[to] = true;
			if (!match[to] || DFS(match[to])) {
				match[to] = k; return true;
			}
		}
	}
	return false;
}

int main() {
	scanf("%d", &n);
	for (int Case = 0; Case ^ n; ++Case) {
		scanf("%d%d", &ind, &k); ++ind;
		for (int i = 0; i ^ k; ++i) {
			scanf("%d", &r); ++r;
			G[ind].push_back(r), G[r].push_back(ind);
		}
	}
	vis[1] = true, dep[1] = 1, Pre(1);
	for (int i = 1; i <= n; ++i)//取出奇数层点
		if (dep[i] % 2 == 1) points[++tot] = i;
	for (int i = 1; i <= tot; ++i) {//最大匹配
		memset(vis, false, sizeof(vis));
		if (DFS(points[i])) ++ans;
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：like1 (赞：3)

本题是一道经典的最小边覆盖问题，也叫数的最大独立集；一定要和最大点覆盖区分（P3942将军令）

本题可以考虑树形DP；设f[x][1]表示x节点放置士兵时，以x为根的子树需要的最少士兵数；f[x][0]表示x节点不放置士兵时，以x为根的子树需要的最少士兵数。

则转移就为f[u][0]+=f[v][1];f[u][1]=max(f[v][1],f[v][0]);最后答案就为min(f[1][1],f[1][0])；


```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

int n,x,y,z,tot;
int head[1501],f[1501][2];
struct Edge
{
    int to,next;
}edge[3001];

inline void addedge(int x,int y)
{
    ++tot;
    edge[tot].to=y;
    edge[tot].next=head[x];
    head[x]=tot;
}

inline void dfs(int u,int fa)
{
    f[u][1]=1;
    f[u][0]=0;
    if(head[u]==0) f[u][0]=100000000;
    for(int i=head[u];i;i=edge[i].next)
    {
        if(edge[i].to!=fa)
        {
            dfs(edge[i].to,u);
            f[u][1]+=min(f[edge[i].to][1],f[edge[i].to][0]);
            f[u][0]+=f[edge[i].to][1];
        }
    }   
}

int main( )
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&y);
		x++;
        for(int j=1;j<=y;j++)
        {
            scanf("%d",&z);
			z++;
            addedge(x,z);
            addedge(z,x);
        }
    }
    dfs(1,0);
    printf("%d",min(f[1][1],f[1][0]));
} 
```

最后祝大家CSP2019rp++,score++;


---

## 作者：小手冰凉 (赞：2)

来一发贪心


这题很明显是树上的最小点覆盖


按照反方向的深度优先遍历序列来进行贪心.每检查一个结点,如果当前点和当前点的父节点都不属于顶点覆盖集合,则将父节点加入到顶点覆盖集合,并标记当前节点和其父节点都被覆盖.


下面是代码



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1505;
int f[N],ans,t,n;
int b[N],in[N];
int head[N],tail[2*N],nxt[2*N];
void addto(int x,int y)
{
    t++;
    nxt[t]=head[x];
    head[x]=t;
    tail[t]=y;
}
void dfs(int k)
{
    in[++t]=k;
    for(int i=head[k];i;i=nxt[i]){
        dfs(tail[i]);
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int k,xx;
        scanf("%d",&xx);
        xx++;
        scanf("%d",&k);
        for(int j=1;j<=k;j++){
            int x;
            scanf("%d",&x);
            x++;
            addto(xx,x);
            f[x]=xx;
        }
    }
    t=0;
    dfs(1);
    for(int i=n;i>=2;i--)
        if(!b[in[i]]&&!b[f[in[i]]])b[f[in[i]]]=true;
    for(int i=1;i<=n;i++)
        if(b[i])ans++;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：doctorZ_ (赞：2)

其实这就是一道简单的树形$\text{DP}$          
我们可以设$f[0/1][i]$为第$i$个点放士兵或不放士兵的以这个结点为根的子树的士兵最小个数（0表示不放，1表示放）    
接下来我们要分类讨论第$i$个点的动态转移方程     
$\large 1.\text{不放}$       
当第$i$个点不放士兵的时候，那他的儿子结点就必须要放士兵，即：
$$\large f[0][i]+=f[0][v]$$
其中，$v$为$i$的儿子结点           
$\large 1.\text{放}$               
当第$i$个点放士兵的时候，那他的儿子结点就可放可不放，即：
$$\large f[1][i]+=min(f[1][v],f[0][v])$$
v的定义与上文相同          
$\large \text{Code：}$            
```cpp
#include<cstdio>
#include<cstring>
#define N 7000 
using namespace std;
int max(int a,int b){if(a>b)return a;return b;}
int min(int a,int b){if(a<b)return a;return b;}
int f[2][N+1];
int tot,st[N+1];
struct edge
{
	int to,last;
}e[N+1];
void add(int a,int b)
{
	e[++tot].to=b;
	e[tot].last=st[a];
	st[a]=tot;
}
void dfs(int u)
{
	for(int i=st[u];i!=0;i=e[i].last)
	{
		int v=e[i].to;
		dfs(v);
		f[0][u]+=f[1][v];
		f[1][u]+=min(f[1][v],f[0][v]);
	}
	f[1][u]+=1;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int u,k;
		scanf("%d %d",&u,&k);
		for(int j=1;j<=k;j++)
		{
			int v;
			scanf("%d",&v);
			add(u+1,v+1);//由于题目下标从零开始，为了方便，下标均后移一位
		}
	}
	dfs(1);
	printf("%d\n",min(f[0][1],f[1][1]));
	return 0;
}
```


---

## 作者：JustinRochester (赞：2)

[题目](https://www.luogu.org/problemnew/show/P2016)

解法跟 dalao @real_ljs 类似，但没有用到递归

---

**【分析】**
--

题目相当于需要求覆盖这颗树需要的最小点数

用 $Dp_{i,0/1}$ 表示在这棵树中，**以 $i$ 为根节点的子树**在**选/不选根节点**的情况下，覆盖这棵树所有边需要的**最小点数**

所以，当不选这个节点 $i$ 时，则所有  以**其子节点为根节点**的子树  都必选根节点

当选择这个节点 $i$ 时，它能连接到所有的子节点，所以  以**其子节点为根节点**的子树  可以选则其根节点，也可以不选

归纳成方程组，可能更容易理解：

$\begin{cases}Son_i\neq \varnothing\\\ \\ \displaystyle Dp_{i,0}=\sum_{j\in Son_i}Dp_{j,1}\\\ \\\displaystyle Dp_{i,1}=1+\sum_{j\in Son_i}min(Dp_{j,0},Dp_{j,1})\end{cases}$

其中，$Son_i$ 为 $i$ 的子节点集合

显然，边界为

$\begin{cases}Son_i=\varnothing\\Dp_{i,0}=0\\Dp_{i,1}=1\end{cases}$

如果定义 $Son_i=\varnothing$ 时 $\displaystyle \sum_{j\in Son_i}Dp_{j,1}=\sum_{j\in Son_i}min(Dp_{j,0},Dp_{j,1})=0$

递推式及其边界便能写在一起了：

$\begin{cases}\displaystyle Dp_{i,0}=0+\sum_{j\in Son_i}Dp_{j,1}\\\ \\\displaystyle Dp_{i,1}=1+\sum_{j\in Son_i}min(Dp_{j,0},Dp_{j,1})\end{cases}$

答案即为 $min(Dp_{root,0},Dp_{root,1})$

---

很显然，根据树形dp的特点，我们要从叶子开始回溯回去，一般用dfs，或者说是递归，来辅助进行

但是，毕竟本人不喜欢递归，所以想到了一个方法可以避免使用递归

我们来想想，这题的树形dp只要满足子节点的dp在父节点之前完成即可

那我们可以先从根节点开始bfs一下，把树压成一条链，然后再把bfs访问的节点倒序完成dp即可

因为bfs过程中，子节点一定由父节点拓展而来，故子节点在bfs中一定在父节点之后访问到

dp的时候我们倒叙访问，就一定能保证子节点先完成dp，再由父节点完成dp

具体实现方法也不难，最后倒叙访问实际上就是一个栈，我们让这个数组在bfs的时候做队列，dp的时候再当作栈即可

---

考虑一下时间复杂度：

读入各个节点需要 $O(n)$，读入他们的子节点数也需要 $O(n)$

读入子节点为 $\displaystyle \sum_{i=1}^n Card(Son_i)=n-1$ ，也为 $O(n)$ 的

找根节点、bfs为 $O(n)$

dp的内层次为 $O(\ \ Card(Son_i)\ \ )$

dp的复杂度为 $\displaystyle O(\ \ \sum_{i=1}^n[1+Card(Son_i)]\ \ )=O(\ \ \displaystyle n+\sum_{i=1}^nCard(Son_i)\ \ )=O(n+n-1)$

因此，dp的复杂度为 $O(n)$ 

很显然，总复杂度也为 $O(n)$

~~简直快得飞起~~

---

**【代码】**
--

那本蒟蒻就放 ~~我码风极丑的~~  代码了

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
const int MAXN=1510;
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
typedef i32 ar[MAXN];
typedef i32 mt[MAXN][MAXN];
#define cls(s) memset(s,0,sizeof(s))
inline i32 min(int a,int b) { return (a<b)?a:b; }
//条件反射般的一堆定义

namespace IO{
    // #define LOCAL
    #ifdef LOCAL
        inline char gc() { return getchar(); }
    #else
        inline char gc(){
            static char s[1<<20|1]={0},*p1=s,*p2=s;
            return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
        }
    #endif
    inline i32 read(){
        register int ans=0;register char c=gc();register bool neg=0;
        while(c<48||c>57) neg^=!(c^'-'),c=gc();
        while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
        return neg?-ans:ans;
    }
    char Output_Ans[1<<20|1]={0},*Output_Cur=Output_Ans;
    inline void output() { Output_Cur-=fwrite(Output_Ans,1,Output_Cur-Output_Ans,stdout); }
    inline void print(char c){
        if(Output_Cur-Output_Ans+1>>20) output();
        *(Output_Cur++)=c;
    }
    inline void print(i32 ans){
        char s[20]={0};
        if(Output_Cur-Output_Ans+sprintf(s,"%d",ans)>>20) output();
        Output_Cur+=sprintf(Output_Cur,"%d",ans);
    }
}
using namespace IO;
//条件反射般的读入输出优化

i32 d_N,d_Cur;
ar ar_d_Stk;
mt mt_d_Son;
inline void pre(){
    d_N=read();
    bool b_Notroot[MAXN]={0};
    f(i,1,I,d_N){
        i32 d_Pos=read();
        mt_d_Son[d_Pos][0]=read();
        //第一位存子节点数
        f(j,1,J,mt_d_Son[d_Pos][0])
            mt_d_Son[d_Pos][j]=read(),b_Notroot[ mt_d_Son[d_Pos][j] ]=1;
    }
    //读入，并同时判定根节点

    ar_d_Stk[d_Cur]=0;
    while(b_Notroot[ ar_d_Stk[d_Cur] ]) ar_d_Stk[d_Cur]++;
    d_Cur++;
    //寻找根节点，放入队列头

    i32 d_Head=0;
    while(d_Head<d_Cur){
        i32 d_Pos=ar_d_Stk[d_Head++];
        f(i,1,I,mt_d_Son[d_Pos][0])
            ar_d_Stk[d_Cur++]=mt_d_Son[d_Pos][i];
    }
    //bfs压树为链
}
int main(){
    pre();
    i32 mt_d_Dp[MAXN][2]={0};
    while(d_Cur--){
        i32 i=ar_d_Stk[d_Cur];//取出栈顶
        mt_d_Dp[i][0]=0,mt_d_Dp[i][1]=1;
        if(mt_d_Son[i][0])
            f(j,1,J,mt_d_Son[i][0]){
                i32 d_Kid=mt_d_Son[i][j];
                mt_d_Dp[i][0]+=mt_d_Dp[d_Kid][1];
                mt_d_Dp[i][1]+=min(mt_d_Dp[d_Kid][0],mt_d_Dp[d_Kid][1]);
            }
    }
    print( min(mt_d_Dp[ ar_d_Stk[d_Cur] ][0],mt_d_Dp[ ar_d_Stk[d_Cur] ][1]) );
    output();
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：wek_deng (赞：2)

典型的树形dp，当前点如果选，儿子就在选和不选的状态里找个最小值加上，当前

点如果不选，那儿子的状态就只能是选。

简单来说就是设dp[i][0]表示不选第i个点时第i个点的子树里最小使用的点数，

dp[i][1]则是选第i个点。由上面的分析可知dp[i][0]=Σdp[v][1],dp[i]

[1]=Σmin(dp[v][0],dp[v][1])，此处还要注意任何dp[i][1]的初始值均为1。

```#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=2000;
struct soren
{
    int n,t;
};
int a,b,c,d,i,j,tot,root,h[maxn];
int g[maxn],dp[maxn][2];
soren e[maxn];
void add(int u,int v)
{
    tot++;
    e[tot].t=v;
    e[tot].n=h[u];
    h[u]=tot;
}
void tree(int u)
{
    int v,k;
    dp[u][1]=1;
    for (k=h[u];k!=0;k=e[k].n)
    {
        v=e[k].t;
      	tree(v);
      	dp[u][0]=dp[u][0]+dp[v][1];
      	dp[u][1]=dp[u][1]+min(dp[v][0],dp[v][1]);
    }
}
int main()
{
    scanf("%d",&a);
    for (i=1;i<=a;i++)
    {
        scanf("%d%d",&b,&c);
        for (j=1;j<=c;j++)
        {
            scanf("%d",&d);
            add(b,d);
            g[d]++;
        }
    }
    for (i=0;i<a;i++)
     if (g[i]==0) root=i;
    tree(root);
    printf("%d\n",min(dp[root][1],dp[root][0]));
    return 0;
}```

---

## 作者：__Hacheylight__ (赞：2)

这个题目真神奇，我自己造了一组数据Hack了自己，结果提交AC了。。。。

orzorz.

题意是

在一棵树种，在某些点放士兵，使每个点都能被看守到，求最少几个点。


明显是树形DP
-----

DP[i][0/1]表示i点选或不选的最小值

明显 dp[i][0]=$Σ$dp[j$∈$son[i]][1] 

dp[i][1]=$Σmin$(dp[j$∈$son[i]][0/1])+1 

我自制的一组样例

```cpp
12
1 2 2 3
2 2 4 5
3 2 6 7
4 2 8 9 
5 2 10 11
6 0
7 0
8 1 12
9 0
10 0
11 0
12 0
```

ans:

```cpp
4
```

why?
红色勾和黑色勾都可以

![](https://cdn.luogu.com.cn/upload/pic/22388.png)

最重要的代码：

```cpp
#include <bits/stdc++.h>
using namespace std ;
#define N 1510
#define inf 10000000
vector <int> g[N] ;
bool v[N],vis[N] ;
int dp[N][2] ;
int n,k,root ;
int a[N] ;
void dfs(int x){
	if (vis[x]) return ;
	vis[x]=true ;
	int t=0;
	for (int i=0;i<g[x].size();i++){
		int to=g[x][i] ;
		dfs(to) ;
		t+=dp[to][1] ;
	} 
	dp[x][0]=t ;
	t=0;
	for (int i=0;i<g[x].size();i++){
		int to=g[x][i] ;	
		dfs(to) ;
		t+=min(dp[to][1],dp[to][0]) ;
	}
	dp[x][1]=t+1 ;
}
int main(){
	scanf("%d",&n) ;
	memset(v,true,sizeof(v)) ;
	memset(dp,0,sizeof(dp)) ;
	for (int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&k) ;
		for (int j=1;j<=k;j++){
			int t ;
			scanf("%d",&t) ;
			v[t]=false ;
			g[a[i]].push_back(t) ;
		}
	}
	for (int i=0;i<n;i++) if (v[a[i]]) root=a[i] ;
	dfs(root);
	int ans=min(dp[root][0],dp[root][1]) ;
	printf("%d\n",ans) ;
}
```


---

## 作者：Ofnoname (赞：1)

之前做P2279就感觉到是重题，但是当时对DP不熟，用的是$O(N)$的贪心。今天再来看，树形DP同样是$O(N)$，并且好写得多。

题目没有指定根，所以可以随意指定，要求是每一条边两端至少有一个被覆盖，所以对于一个父节点`x`，如果选了自己，儿子选或不选都可以，如果没选自己，那么就必须选所有儿子。用`f1`表示选，`f0`表示没有选，那么

$$ f0[x] = \sum f1[y]; $$
$$f1[x] = \sum (min(f0[y], f1[y]));$$

注意`f1[]`的初值应该赋为1，$min(f0[root], f1[root])$就是答案。

```cpp
#include <bits/stdc++.h>
#define MAX (1500 + 7)
using namespace std;

int N, root, ec, head[MAX], f0[MAX], f1[MAX];

struct Edge{ int y, nxt; } E[MAX << 1];
void add(int x, int y)
{
	E[++ec] = Edge{y, head[x]};
	head[x] = ec;
}

#define y E[p].y
void DFS(int x, int fa)
{
	f1[x] = 1;
	for (int p = head[x]; p; p=E[p].nxt)
		if (y != fa)
		{
			DFS(y, x);
			f0[x] += f1[y];
			f1[x] += min(f0[y], f1[y]);
		}
}
#undef y

int main()
{
	scanf("%d", &N), root = 19260817 % N;
	for (int i = 0, x, y, k; i < N; i++)
	{
		scanf("%d%d", &x, &k);
		while (k--)
		{
			scanf("%d", &y);
			add(x, y), add(y, x);
		}
	}
	DFS(root, 0);
	printf("%d\n", min(f0[root], f1[root]));
}
```

---

## 作者：中二病 (赞：1)

比较水的一道裸树形DP（看到题解里还有很多大神有别的做法）  
用dp[1][i]表示表示在i点有士兵并使其子树全被占领的所需最少的士兵数，用dp[0][i]表示i点没有士兵的最小值，易得出dp[0][u]=dp[1][v]之和，其中v是u的子节点，dp[1][u]=min(dp[1][v],dp[0][v])之和，具体用递归实现  
```
void solve(int u,int fa)
{
	//if(!sum[u])return;
	int a1=0,a2=0;
	for(int i=0;i<edge[u].size();i++)
	{
		int v=edge[u][i];
		if(v==fa)continue;
		solve(v,u);
		dp[0][u]+=dp[1][v];
		dp[1][u]+=min(dp[1][v],dp[0][v]);
	}
	dp[1][u]++;
}

```
有一个细节，这个题并没有给出明确的根节点，所以要双向建边，并在dfs的过程中记录父节点就好了  
上完整代码（vector实现）
```
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int oo=1433223;
vector <int> edge[1510];
int dp[2][1510],n,x,y,sum[1510],z;
void solve(int u,int fa)
{
	//if(!sum[u])return;
	int a1=0,a2=0;
	for(int i=0;i<edge[u].size();i++)
	{
		int v=edge[u][i];
		if(v==fa)continue;
		solve(v,u);
		dp[0][u]+=dp[1][v];
		dp[1][u]+=min(dp[1][v],dp[0][v]);
	}
	dp[1][u]++;
}
int main()
{
	//freopen("pg.in","r",stdin);
	//freopen("pg.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>sum[x];
		for(int i=1;i<=sum[x];i++)
		{
			cin>>z;
			edge[x].push_back(z);
			edge[z].push_back(x);
		}
	}
	solve(0,0);
	int ans=min(dp[0][0],dp[1][0]);
	cout<<ans;
	return 0;
}
```



---

## 作者：a999999 (赞：1)

## [链接](https://www.luogu.org/problemnew/show/P2016)

这道题明显是树形$dp$

因为要看住每一条路

所以可以把每条边~~安排~~分析一下

设$x$为当前节点，$Son(x)$为$x$的儿子集合

在以$x$为根的子树中

设$f[x][0]$为不选$x$所得的最小代价,$f[x][1]$为选$x$的最小代价

有两种情况：
1. 不选$x$：这样$Son(x)$全都要选，即$$f[x][0]=\sum_{y∋Son(x)}f[y][1]$$
2. 选$x$：这时，$Son(x)$选不选都行，所以$$f[x][1]=\{\sum_{y∋Son(x)}min(f[y][0],f[y][1])\}+1$$
所以我们可以看出来：

对于$x∋V$,$f[y∋Son(x)]$不需要求$f[x]$!!!

所以，我们就可以开心的拓扑排序啦~~

$P.S$：数据范围是$[0,n)$,要$+1$转化成$[1,n]$

$Talk\ is\ cheap,show\ you\ the\ code.$
```cpp
#include<algorithm>
#include<cstdio>
#define N 2000
using namespace std;
int f[N][2],n;
int fa[N],deg[N],q[N],root;
void add(int x,int y)
{fa[y]=x;++deg[x];}
void dp()
{
	int l=0,r=0,ft;
	for(int i=1;i<=n;++i)
	if(!deg[i])q[++r]=i,f[i][1]=1;
	while(l<r)
	{
		ft=fa[q[++l]];++f[q[l]][1];
		f[ft][0]+=f[q[l]][1];
		f[ft][1]+=min(f[q[l]][0],f[q[l]][1]);
		if(!--deg[ft])q[++r]=ft;
		if(!fa[q[l]]){root=q[l];return;}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1,x,y,d;i<=n;++i)
	{
		scanf("%d%d",&x,&d);
		for(int j=1;j<=d;++j)
		scanf("%d",&y),add(x+1,y+1);
	}
	dp();
	printf("%d",min(f[root][0],f[root][1]));
	return 0;
}
```

---

## 作者：时崎狂三老公 (赞：1)


```cpp
//同楼下所述，这与没有上司的舞会很像。
//首先说明，我这个程序过不了只有1个点的树，这个东西要特判一下就行，我觉得没有这样的数据就没有特判了
//其实特判也很简单 ，就是在输入阶段的时候 if 一下就ok。
//我用树形 dp 过的，可以看看思路。
//代码最简洁，题解最正常。 
#include<bits/stdc++.h>
#define maxn 1000+600+1
using namespace std;
struct node{
    vector<int>ch;                             //记录孩子节点。 
};                          
node p[maxn];
int a,b,m,child,dp[maxn][2];                   //dp[father][0]表示不占father这个点，占领了以节点father为根的树的最少兵数。 
void dfs(int x){                               //dp[father][1]表示占father这个点以后，占领了以father为根的树的最少兵数。 
    for(int i=0;i<p[x].ch.size();i++){     
        int son=p[x].ch[i];
        dfs(son);
         dp[x][0]+=dp[son][1];                  
         dp[x][1]+=min(dp[son][0],dp[son][1]);
    }                                         //这两个dp方程自己手动画图理解。 
}
int main(){
    cin>>m;
    for(int i=0;i<m;i++) 
    dp[i][1]=1;
    for(int i=0;i<m;i++){
        cin>>a>>b; 
        for(int j=1;j<=b;j++){
        cin>>child;
        p[a].ch.push_back(child);
      }
    }                                        //读入。 
    dfs(0);                                      
    cout<<min(dp[0][0],dp[0][1]);            
    return 零;                               //给个零自己体会什么意思。 
}
```

---

## 作者：ww3113306 (赞：1)

表示某大佬告诉我这是树形DP，，，

不过我觉得这跟将军令长得很像

不过是它的弱化版本

所以你们做了这道题之后可以顺便把将军令和消防局的设立做了，都差不多

因为将军令中一个点的管辖范围是给定的，

所以DFS要智能一些，把一个点能到的范围都走了

但这个题不用，

因为一个点只能管它旁边的

```cpp
#include<bits/stdc++.h>
using namespace std;
#define AC 1500
struct abc{
    int date,next;
};
abc chain[AC*3+200];
int ans,head[AC+200],tot,n,m,times[AC+200],father[AC+200];
bool look[AC+200],vis[AC+200];
void add(int from,int want)//加边
{
    chain[++tot].date=want;
    chain[tot].next=head[from];
    head[from]=tot;
}
void DFS(int now)
{
    times[++tot]=now;
    vis[now]=true;//记录被访问过
    for(int i=head[now];i;i=chain[i].next)
    {
        if(!vis[chain[i].date])DFS(chain[i].date),father[chain[i].date]=now;//一个点在它之前被访问过，又与它相连，说明这个点是父亲，反之是儿子
    }
}
int main()
{
    int i,t,w;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&w,&m);
        w++;
        for(int j=1;j<=m;j++)  
        {
            scanf("%d",&t);
            t++;
            add(w,t);//双向加边，因为不知道哪个是父节点，哪个是子节点
            add(t,w);
        }
    }
    tot=0;
    DFS(1);
        //因为一个点的管辖范围很小，所以没有必要求出每个点的严格的深度，只需要求出一个点与它祖先之间的访问次序即可
        //下面的for循环从最后访问的开始，由于管辖范围小，所以只需要保证一个点的儿子节点在它之前被遍历过即可，兄弟不管
       //因为一个点管辖范围太小，不能通过上面的点来管兄弟，所以只保证这个条件即可
    for(i=n;i>=2;i--)
    {
        if(!look[times[i]]&&!look[father[times[i]]])look[father[times[i]]]=true,ans++;
```
}//因为是一棵树，所以从下面开始遍历一定是最优的，不信你们可以画个图验证一下，同样一个士兵，放在最底下与放在最底下的父亲相比，显然放父亲更优，因为可以多覆盖一个点
    printf("%d",ans);

    return 0;

}

---

## 作者：Sham_Sleep (赞：0)

一个需要费点脑子的树形dp

可以看成一个边跟一个点

这里我们需要前向星用来存这个图，方便我们到时候直接遍历下去

dp部分，其实一个棋子有放或不放的两种选择，如果他放他就从儿子节点同样的两种状态下转移过来，取min值

如果选择不放，那么他必须由儿子看到，那么只能从儿子放的情况下转移过来

那么思路就很清楚了

上代码
```
#include <stdio.h>
#include <iostream>
using namespace std;


struct point {
	int pre;
	int to;
};


int root;
int n;
int top;
int x , k , t;
bool ff[1505];
int v[1505];
int f[1505][3];//0代表不放 ， 1代表放
point tree[1505];


void qxx(int fa , int child)
{
	tree[++top].pre = v[fa];
	tree[top].to = child;
	v[fa] = top;
}


void dfs_dp(int k)
{
	f[k][1] = 1;
	for(int i = v[k]; i; i = tree[i].pre){
		dfs_dp(tree[i].to);//优先让儿子进行dp 以保证到自己的时候可以从儿子转移过来
		f[k][0] += f[tree[i].to][1];
		f[k][1] += min(f[tree[i].to][1] , f[tree[i].to][0]);
	}
	return ;
}


int main()
{
	scanf("%d" , &n);
	for(int i = 1; i <= n; ++i){
		scanf("%d %d" , &x , &k);
		for(int i = 1; i <= k; ++i){
			scanf("%d" , &t);
			ff[t] = true;
			qxx(x , t);
		}
	}
	while(ff[root]) root++;
	dfs_dp(root);
	printf("%d" , min(f[root][1] , f[root][0]));
} 
```


---

## 作者：Priori_Incantatem (赞：0)

#### 题目大意
给出一棵树，如果在一个点 $x$ 放了一个士兵，该士兵将会覆盖所有与点 $x$ 直接相邻的边。求最少放多少个士兵，使得所有边都被覆盖

#### 解题思路

很简单的一道题，跟[P2899 [USACO08JAN]手机网络Cell Phone Network](https://www.luogu.com.cn/problem/P2899)非常相似，只不过改成了覆盖边

对于每个点，我们考虑放不放士兵，所以要开一维去储存是否放士兵的状态

$f[x][0]$ 表示以 $x$ 为根的子树中，点 $x$ 不放士兵所需要的最小士兵数量
$f[x][1]$ 则表示以 $x$ 为根的子树中，点 $x$ 放士兵所需要的最小士兵数量

转移方程：  
$f[x][0]=\sum f[y][1]$，其中 $y$ 为 $x$ 的子节点  
$f[x][1]=1+ \sum min(f[y][0],f[y][1])$，因为 $x$ 到 $y$ 的边已经被覆盖了，所以点 $y$ 放不放都没关系

最后答案就是 $min(f[1][0],f[1][1])$  
**PS:** 这里点 $1$ 作为根，其实拿任意一个点做根都可以

**代码**

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;
const int Maxn=1520,inf=0x3f3f3f3f;
vector <int> e[Maxn];
int f[Maxn][2];
int n;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void dfs(int x,int fa)
{
	f[x][1]=1;
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i];
		if(y==fa)continue;
		dfs(y,x);
		f[x][1]+=min(f[y][1],f[y][0]);
		f[x][0]+=f[y][1];
	}
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read();
	for(int i=1;i<=n;++i)
	{
		int x=read()+1,cnt=read(); // 程序中储存的节点编号是 1~n
		while(cnt--)
		{
			int y=read()+1;
			e[x].push_back(y);
			e[y].push_back(x);
		}
	}
	dfs(1,0);
	printf("%d\n",min(f[1][1],f[1][0]));
	return 0;
}
```

---

## 作者：abandentsky (赞：0)

又是一道树形dp，其实很简单，父节点为u，子节点为v。如果占领u那么占不占领v就可以有，也可以没有。但是如果v不选，那么就必须要选u了。所以状态定义为dp[u][0]为不选择u节点，u（包括u）的子树都被覆盖的最小覆数，dpp[u][1]表示选择u节点，u的子树（包括u）都被覆盖的最小覆盖数。
为了防止超时，我们使用了记忆化搜索。算是树形dp入门题吧。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 1505
#define INF 0x3f3f3f3f
using namespace std;

vector<int> G[MAXN];
int dp[MAXN][2];
int n,u,k,v;

int dfs(int root,int op)
{
    if(dp[root][op]!=-1)
        return dp[root][op];
    if(G[root].size()==0)
    {
        if(op==0)
            dp[root][op]=0;                 //不选叶子节点，并且覆盖所有子树为0；
        else if(op==1)
            dp[root][op]=1;                   //选取叶子节点并且覆盖子树为1；
        return dp[root][op];
    }
    else
    {
        if(op==0)
            dp[root][0]=0;
        else if(op==1)
            dp[root][1]=1;
        for(int i=0;i<G[root].size();i++)
        {
            int v=G[root][i];
            if(op==0)
            {
                dp[root][0]+=dfs(v,1);
            }
            else if(op==1)
            {
                dp[root][1]+=min(dfs(v,1),dfs(v,0));
            }
        }
    }
    return dp[root][op];
}

int main()
{
    scanf("%d",&n);
    memset(dp,-1,sizeof(dp));
    for(int i=0;i<n;i++)
    {
        scanf("%d %d",&u,&k);
        while(k--)
        {
            scanf("%d",&v);
            G[u].push_back(v);
        }
    }
    printf("%d\n",min(dfs(0,1),dfs(0,0)));
    return 0;
}

```


---

## 作者：Genjige葛 (赞：0)

这题还是显而易见的树形dp吧。。。。。（先%%zxt

这题其实就是要求树的最大独立集

我们按照要求构建一张关系图，可见这是一棵树。
任何一个点的取舍可以看作是一种决策，设f[x][1]表示x点放士兵时，以x为根的子树需要的最少士兵数；f[x][0]表示x点不放士兵时，以x为根的子树需要的最少士兵数。

当点x不放时，它的所有儿子都必须放，即f[x][0]+=f[y][1]//y是x的所有儿子。

当x点放时，它的所有儿子放与不放无所谓，但应该取两种情况的最小值。f[x][1]=1+min{f[y][1],f[y][0]}//y是x的儿子。

初始条件：f[x][0]=0,f[x][1]=1。

ans=min{f[root][0],f[root][1]}。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1600;;
struct {int num,child[maxn];} node[maxn];
int f[maxn][2],a[maxn],n,root;
inline void read(){
	ios::sync_with_stdio(false);
	int i,j,x,y;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		cin>>node[x].num;
		for(j=1;j<=node[x].num;j++){
			cin>>y;
			node[x].child[j]=y;
			a[y]=1;
		}
	}
	root=0;
	while(a[root]) root++;
}
inline void dp(int x){
	int i,j;
	f[x][1]=1;
	f[x][0]=0;
	if(node[x].num==0) return;
	for(i=1;i<=node[x].num;i++){
		dp(node[x].child[i]);
		f[x][0]+=f[node[x].child[i]][1];
		f[x][1]+=min(f[node[x].child[i]][0],f[node[x].child[i]][1]);
	}
}
int main(){
	read();
	dp(root);
	cout<<min(f[root][0],f[root][1]);
	return 0;
}
```


---

## 作者：封癫 (赞：0)

[博客链接](http://www.cnblogs.com/cellular-automaton/p/7588108.html)

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;

inline long long read(){
    long long num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num\*10+ch-'0';
        ch=getchar();
    }
    return num\*f;
}

struct Edge{
    int next,to;
}edge[1000010];
int head[10000],num=0;
inline void add(int from,int to){
    edge[++num]=(Edge){    head[from],to};
    head[from]=num;
}

int f[1700][3];
int size[2000];

void find(int x,int fa){
    size[x]=1;
    for(int i=head[x];i;i=edge[i].next){
        int to=edge[i].to;
        if(to!=fa){
            find(to,x);
            size[x]+=size[to];
        }
    }
}

void dfs(int x,int fa){
    f[x][1]=1;f[x][0]=0;
    if(size[x]==1)    return;
    for(int i=head[x];i;i=edge[i].next){
        int to=edge[i].to;
        if(to!=fa){
            dfs(to,x);
            f[x][1]+=min(f[to][0],f[to][1]);
            f[x][0]+=f[to][1];
        }
    }
}
int ans=0x7fffffff;
int main(){
    int n=read();
    for(int i=1;i<=n;++i){
        int p=read(),s=read();
        for(int j=1;j<=s;++j){
            int q=read();
            add(p,q);
            add(q,p);
        }
    }
    
    for(int i=0;i<n;++i){
        memset(f,0,sizeof(f));
        memset(size,0,sizeof(size));
        find(i,i);
        dfs(i,i);
        ans=min(ans,min(f[i][1],f[i][0]));
    }
    printf("%d",ans);
    
    return 0;
}
 ![](https://cdn.luogu.com.cn/upload/pic/8242.png) 



---

## 作者：legend_life (赞：0)

这题算一个比较基础的树形DP类问题了，一句话题意——树形内最小点覆盖。

简单讲一下思路。首先判断根节点，其次一个dfs就结束了。dp[i][0]代表在以i为根节点的子树内，不取i点最少需要取多少个点；dp[i][1]代表取i点最少需要取多少个点。

转移很简单，不取这个点就必须取子节点；取这个点就无所谓（因为我们是从下往上递推）。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 1505;
int head[MAXN], ind[MAXN], dp[MAXN][3];
int cnt, n, root;

struct Edge
{
    int to;
    int nxt;
}e[MAXN];

void AddEdge (int from, int to)
{
    e[++ cnt].to = to;
    e[cnt].nxt = head[from];
    head[from] = cnt;
    ++ ind[to];
}

void dfs (int now, int father)
{
    for (int i = head[now]; i; i = e[i].nxt)
    {
        int v = e[i].to;
        dfs (v, now);
        dp[now][0] += dp[v][1];
        dp[now][1] += min (dp[v][1], dp[v][0]);
    }
    dp[now][1] += 1;
}

int main()
{
    scanf ("%d", &n);
    
    for (int i = 0; i < n; ++ i)
    {
        int x, m, v;
        scanf ("%d%d", &x, &m);
        for (int i = 1; i <= m; ++ i)
        {
            scanf ("%d", &v);
            AddEdge (x, v);
        }
    }
    for (int i = 0; i < n; ++ i)
        if (!ind[i])
        {
            root = i;
            break;
        }
    dfs (root, root);
    printf ("%d\n", min (dp[root][1], dp[root][0]));
    return 0;
}
```


---

## 作者：难上加兰 (赞：0)

思路：

树形DP，思路简单

①m不放，f[m,0]=f[m的儿子,1];

②m放，f[m,0]=min(f[m的儿子,1],f[m的儿子,0]);

初始化时，f[x,0]:=0;f[x,1]:=1;

```delphi

var
  v:array[0..2000]of boolean;
  f:array[0..2000,0..1]of integer;
  c:array[0..2000,0..2000]of integer;
  i,j,k,m,n,r,a:integer;
function min(x,y:integer):integer;
begin
  if x>y then exit(y)
    else exit(x);
end;

function tree(m:integer):integer;
var
  i:integer;
begin
  f[m,0]:=0;
  f[m,1]:=1;//初始化
  for i:=1 to c[m,0]do
    tree(c[m,i]);
  for i:=1 to c[m,0]do
    begin
      inc(f[m,0],f[c[m,i],1]);
      inc(f[m,1],min(f[c[m,i],1],f[c[m,i],0]));
    end;
  if (f[m,0]<>0)and(f[m,1]=0)then
    exit(f[m,0]);
  if (f[m,1]<>0)and(f[m,0]=0)then
    exit(f[m,1]);
  exit(min(f[m,0],f[m,1]));
end;
begin
  fillchar(f,sizeof(f),255);
  fillchar(v,sizeof(v),true);
  readln(n);
  for i:=1 to n do
    begin
      read(m);
      read(c[m,0]);
      for j:=1 to c[m,0]do
        begin
          read(c[m,j]);
          v[c[m,j]]:=false;
        end;
    end;
  for i:=0 to n-1 do
    if v[i] then
      begin
        r:=i;
        break;
      end;
  writeln(tree(r));//输出以根节点为根的最小兵力值
end.

```

---


# 龙兄摘苹果

## 题目描述

龙兄在淘淘摘苹果的那个果园里摘了 $n$ 个完全互不相同的苹果，好客的园主为他提供了 $k$ 个篮子，他想把苹果装在篮子里拎回家（由于龙兄的手是无限大的，所以你不必考虑他能不能同时拎这么多篮子）。

同时，他不希望有任何一个篮子里是空的，因为这样就做不到物尽其用。因此他想知道一共有多少种放苹果的方法，由于他的大脑运算过慢，所以找到了聪明机智的你，他在摘苹果上已经花了很长时间，所以他只能等 $1$ 秒。

由于方法很可能非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常多，龙兄的大脑无法存储，所以他会给你一个数 $p$，输出方法数除以 $p$ 的余数就可以了。

## 说明/提示

### 样例解释

一共有 $4$ 个苹果，$2$ 个篮子。

有以下 $7$ 种方法。

- $\{1\},\{2,3,4\}$；
- $\{2\},\{1,3,4\}$；
- $\{3\},\{1,2,4\}$；
- $\{4\},\{1,2,3\}$；
- $\{1,2\},\{3,4\}$；
- $\{1,3\},\{2,4\}$；
- $\{1,4\},\{2,3\}$。

$7$ 除以 $3$ 余 $1$。

### 数据范围及约定

- 对于 $20\%$ 的数据，$n \le 8$，$k \le 8$。
- 对于 $60\%$ 的数据，$n \le 100$，$k \le 100$。
- 对于 $100\%$ 的数据，$n \le 10000$，$k \le 1000$。

保证所有数据 $n \ge k$，且答案在 $64$ 位整型范围内。

## 样例 #1

### 输入

```
4 2 3```

### 输出

```
1```

# 题解

## 作者：翼德天尊 (赞：65)

**翼德又来发题解啦！！！**
#### 拿到题目 ~~，一看标签~~ 经过仔细观察后赫然发现——又是一道动规题！


------------

### 闲话不多说，让我们一起先来看题目，申申题
```
1.n个苹果装k个篮子（毋庸置疑）
2.嫌结果太大还要再取余p
3.求方案总数（划重点）
4.数据大,一秒完成（敲黑板）

```
根据3,4条，我们可以得出结论：用动规！

### 那么，怎么动规呢？
一提到动规，像我们这种蒟蒻肯定首先想到的是状态转移方程这个烫手的山芋，所以，这道题也一样，它的状转移方程到底是什么呢？
```
//ans[i][j]-->每一步的结果，即选i个苹果和j个篮子时的方案总数
//i-->苹果数
//j-->篮子数
//状态转移方程为：
ans[i][j]=ans[i-1][j-1]+ans[i-1][j]*j
```
**但是，为什么呢？**

首先ans[ i ][ j ]无需解释。那么ans[ i - 1 ][ j - 1 ]和ans[ i - 1 ][ j ] * j是什么意思呢？
```
ans[i-1][j-1]表示若现在增加的这个苹果单独放一个篮子的方案总数；
ans[i-1][j]*j表示现在增加的这个苹果如果放在其它篮子里的方案总数，因为篮子有j个，所以*j.
```
### 如果你还没看明白，就再参考一下代码吧
```
#include<bits/stdc++.h>//美丽善良的万能头
using namespace std;
unsigned long long ans[10001][1001];//存每个状态的方案总数
long long n,k,p;//即苹果数，篮子数与取余数
int main(){
    cin>>n>>k>>p;//输入
    ans[1][1]=1;先赋源头值，即有一个苹果一个篮子时有一种放置方案
    for (int i=1;i<=n;i++){//苹果不断增加
        ans[i][1]=1;//如只有一个篮子就只有一个方案
		for (int j=2;j<=k;j++)//篮子不断增加
			ans[i][j]=((j%p)*(ans[i-1][j]%p)%p+(ans[i-1][j-1])%p)%p;//记得取余
    }
    printf("%lld\n",ans[n][k]);//输出
    return 0;//以好习惯撒花吧
}
```
#### 好了，这道题的讲解就这么愉快地结束了，还有疑问可以在留言区留言哈，没有的话就动动你的小手点个赞吧！

---

## 作者：小柯 (赞：15)

楼上大佬似乎讲的还不是很清楚，让我这个蒟蒻来补充一下吧。

看一看递推关系式：

$s[\ i\ ][\ j\ ]=s[\ i-1\ ][\ j-1\ ]+s[\ i-1\ ][\ j-1\ ]*j$


## 含义

>$f[\ i-1\ ][\ j-1\ ]$:将一个苹果单独放一个篮子，剩下的放在剩下的
$k-1$
个篮子里。

>$f[\ i-1\ ][\ j\ ]* j$:将
$i-1$
个苹果放进所有篮子，将剩下的一个苹果放进任何一个篮子，因为有
$j$
个盘子，所以乘以
$j$
。

## 优化1

看数据规模
$n$
$<=$
$10000$
，
$k$
$<=$
$1000$
,所以可以想到优化空间复杂度。

原来的空间复杂度为
$O(nk)$。

我们看到递推式中有
$i-1$
说明每一层都只和上一层有关，所以我们可以使用滚动数组的优化。

空间复杂度
$O(2k)$

## 代码1

```
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
__int128 p,s,f[2][1005];
char x;
__int128 r(){
	s=0;
	x=getchar();
	while(x<'0'||x>'9')x=getchar();
	while(x>='0'&&x<='9')s=(s<<1)+(s<<3)+x-'0',x=getchar();
	return s;
}
void w(__int128 a){//w
	if(a<0){
		w(-a);
		return;
	}
	if(a==0)return;
	w(a/10);
	putchar(a%10+'0');
}
int main(){
	f[1][1]=1;
	cin>>n>>k;
	p=r();//__int128不能用cin、cout,只能用函数
	for(int i=1;i<=n;i++){
		for(int j=min(i,k)/*常数优化*/;j>=(i==1?2:1)/*防止踩到边界*/;j--){
			f[i&1][j]=((f[(i+1)&1][j]*j)%p+f[(i+1)&1][j-1]%p)%p;//随时取余
		}
	}
	if(f[n&1][k]==0)cout<<0<<endl;//函数不能输出是0的情况，只能手动输。
	else w(f[n&1][k]);
	return 0;
}
```
## 优化2

同背包问题一样，还可以优化成一维的，但要注意是倒序循环的。

空间复杂度
$O(k)$

## 代码2

```
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
__int128 p,s,f[1005];
char x;
__int128 r(){
	s=0;
	x=getchar();
	while(x<'0'||x>'9')x=getchar();
	while(x>='0'&&x<='9')s=(s<<1)+(s<<3)+x-'0',x=getchar();
	return s;
}
void w(__int128 a){
	if(a<0){
		w(-a);
		return;
	}
	if(a==0)return;
	w(a/10);
	putchar(a%10+'0');
}
int main(){
	f[1]=1;
	cin>>n>>k;
	p=r();
	for(int i=1;i<=n;i++){
		for(int j=min(i,k);j>=(i==1?2:1);j--){
			f[j]=((f[j]*j)%p+f[j-1]%p)%p;
		}
	}
	if(f[k]==0)cout<<0<<endl;
	else w(f[k]);
	return 0;
}
```
## 优化3

我们注意到简化后的式子仍存在
$j-1$
，所以可以再度滚动起来。
为了方便，就不用数组了，直接用两个变量就行。

空间复杂度
$O(2)$

## 代码3

```
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
__int128 p,s,a,b;
char x;
__int128 r(){
	s=0;
	x=getchar();
	while(x<'0'||x>'9')x=getchar();
	while(x>='0'&&x<='9')s=(s<<1)+(s<<3)+x-'0',x=getchar();
	return s;
}
void w(__int128 a){
	if(a<0){
		w(-a);
		return;
	}
	if(a==0)return;
	w(a/10);
	putchar(a%10+'0');
}
int main(){
	a=1;
	cin>>n>>k;
	p=r();
	for(int i=1;i<=n;i++){
		a=1;
		for(int j=min(i,k);j>=(i==1?2:1);j--){
			if(j&1)a=((a*j)%p+b)%p;
			else b=((b*j)%p+a)%p;
		}
	}
	if(k&1){
		if(a==0)cout<<0<<endl;
		else w(a);
	}
	else{
		if(b==0)cout<<0<<endl;
		else w(b);
	}
	return 0;
}
```
## 申明

前两篇代码请放心食用，第三篇有点问题，只过得了样例，如果你知道错哪儿了，请在评论区见。

---

## 作者：VCVCVCFop_zz (赞：13)

这个。。裸的第二类斯特林数

数学公式为s[i][j]=s[i-1][j-1]+s[i-1][j]\*j

思想为：第i个数自成一个集合或者加入别的集合，别的集合有j个所以s[i-1][j]\*j

TIP：本题一定要一路取模！！！表示long long都炸了、、最后全加取模同时开unsigned long long

CODE：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
unsigned long long f[10001][1001]={0};
int main()
{
    long long n,m,mo;
    cin>>n>>m>>mo;
    f[1][1]=1;
    for (int  i=1;i<=n;i++)
    {
        f[i][1]=1;
        for (int  j=1;j<=m;j++)
            if(i==1&&j==1) continue;else
            f[i][j]=((j%mo)*(f[i-1][j]%mo)%mo+(f[i-1][j-1])%mo)%mo;
    }
    printf("%llu\n",f[n][m]);
}
```

---

## 作者：我和鱼过不去 (赞：6)

### 题意简述
把 $n$ 个元素分成 $k$ 个非空集合的方案数（集合内无序），即 $S(n,k)$ 。
  
### 推导过程
1. 如果前 $n-1$ 个元素组成了 $k-1$ 个非空集合，那么第 $n$ 个元素自然成为第 $k$ 个非空集合。
2. 如果前 $n-1$ 个元素组成了 $k$ 个非空集合，那么第 $n$ 个元素可以放进这 $k$ 个非空集合中的任意一个。  

### 递推式
由推导过程可以得出递推式，$S(i,j) = S(i-1,j-1) + S(i-1,j)*j$ 。

需要注意的是，由于数据范围很大，除了要开 unsigned long long ，递推的过程中还必须时刻取模！！！

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long f[10005][1005];
long long n,k,p;
int main()
{
    cin>>n>>k>>p;
    f[1][1] = 1;
    for(int i=1;i<=n;i++)  //为了省略重置 S(1,j) 的循环步骤
    {
        f[i][1] = 1;     //无论多少个元素，当要组成1个集合时，只有一种办法 
        for(int j=1;j<=k;j++)
        {
            f[i][j] = (f[i-1][j-1]%p + (f[i-1][j]%p)*(j%p))%p;   //递推式，注意取模 
            f[1][1] = 1;   //填坑 
        }
    }
    cout<<f[n][k];  //输出
    return 0;
}
```


---

## 作者：念古兰 (赞：4)

这道题初看蛮简单的，然后被卡int QwQ

思路嘛，不难想(~~虽然还是被卡了~~）  
考虑f[i][j]表示i个苹果放在j个盘里面  
然后呢，最后一个苹果可以独立成一个即f[i-1][j-1]  
也可以是放在已经放好的盘子里面，由于说每一个苹果都是不一样的，所以还要乘上盘子的个数  
所以转移方程为  **f[i][j] = f[i-1][j-1] + f[i-1][j] * j**;  
记得初始化跟每步取余就可以AC啦  
代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e4+10;
typedef unsigned long long ll;
ll f[maxn][1010];
int main()
{
    int n=0,k=0;
    ll p=0;
    scanf("%i%i%llu",&n,&k,&p);
   for(register int i=1;i<=n;i++) f[i][1]=(ll)1%p;
    for(register int i=2;i<=n;i++)
       for(register int j=2;j<=k;j++)
          f[i][j] = ((f[i-1][j-1]%p)+ (f[i-1][j]%p)*(j%p))%p ;
    printf("%llu",f[n][k]);
    return 0;
}
```
 _ull是最后的倔强_ 



---

## 作者：syf2008 (赞：2)

这题好水啊，堪比SP106（雾

斯特林数第二类

具体看[百度百科](https://baike.so.com/doc/1320541-1396128.html)

上代码
```
#include<bits/stdc++.h>
using namespace std;
unsigned long long s2[10005][1005],n,m,p;
int main()
{
	cin>>n>>m>>p;
	s2[1][1]=1;
	for(int i=2;i<=n;i++)
	for(int j=1;j<=m;j++)
	s2[i][j]=(s2[i-1][j-1]+j*s2[i-1][j])%p;
	cout<<s2[n][m]%p;
}
```

---

## 作者：帝千秋丶梦尘 (赞：1)

## [题目链接](https://www.luogu.com.cn/problem/P2028)

因为100%的数据，$n<=10000,k<=1000$

可以看得出来的，这是一道dp题目；

可以用爆搜帮你找规律

有时候数字一大，例如这题

$n$一大，手推就难很多了

所以打下爆搜你就能得到递推式：

先看看边界：$a[i][j]=1;$ （$j==1$）

（i就是苹果的数量，j就是篮子的数量）

因为只有一个篮子，所以不管你有几个苹果，都只能放进这一个篮子里

所以一个篮子时就为1

而转移方程就是：$a[i][j]=(a[i-1][j-1]+a[i-1][j]*j)$

$a[i][j]$就是当前有$i$个苹果，$j$个篮子时的方案数

$a[i-1][j-1]$就是当有$i-1$个苹果，$i-1$个篮子时的方案数

$a[i-1][j]*j$ 就是你已经放了$i-1$个苹果，还有一个时，放入最后一个的情况

因为你现在有j个盘子，你可以放入任意一个，所以有$j$种情况

```cpp
if(j==1)
{
	a[i][j]=1;
}
else a[i][j]=(a[i-1][j-1]+a[i-1][j]*j);
```

且答案在64位整型范围内

$long long$炸了（实测$wa$2点）

这题也不可能有负数

最后注意需要%$p$即可

所以用unsigned long long

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,m,p,a[10001][1001];
int main(void)
{
	cin>>n>>m>>p;
	for(register int i(1);i<=n;++i)
	{
		for(register int j(1);j<=m;++j)
		{
			if(j==1)
			{
				a[i][j]=1;
			}
			else a[i][j]=(a[i-1][j-1]%p+a[i-1][j]*j%p)%p;
		}
	}
	cout<<a[n][m]%p;
	return 0;
}
```


---

## 作者：Paris_Bentley (赞：1)

！！！本题解主要讲算法，下列代码会hack掉，建议采用其他方法（如__int128这种黑科技）
看到这个题目肯定是要先抓住样例分析一波

n=4,k=2答案是：

##### {1}{2,3,4}；{2}{1,3,4}；{3}{1,2,4}；{4}{1,2,3}；
###### {1,2}{3,4}；{1,3}{2,4}；{1,4}{2,3}。

（思维敏锐的小伙伴肯定马上发现了规律）

好吧，那弱鸡的我们再看看可能和它有关系的数据量。

n=3,k=2

###### {1}{2,3}；{2}{1,3}；{3}{1,2}；

### 看到这些例子有没有发现，上面的7组数据中，有6组都跟是在这组的基础上加一个4进去

###### {1}{2,3,4}；{2}{1,3,4}；{3}{1,2,4}；
###### {1,2}{3,4}；{1,3}{2,4}；{1,4}{2,3}。

比如对于{1}{2，3}这组，在左边加个4，成了一组，右边加个4，又成了一组。

我们就能得到对于dp[i][j]来说（i表示框的数量，j表示装j个苹果）

那么dp[i][j]的一部分一定是从d[i][j-1]转换来的，怎么转换呢，就是再每组上放一个编号为j的苹果，而之前一共分成了i份，所以我们找到了第一部分

dp[i][j-1]*i;

然后，我们目标对准剩下的一组，{4}{1,2,3}我们发现：
### 在加入4之前，就是单纯的{1,2,3}这三组数，
所以这个也很好推导所有数据范围，可以得到另一部分是从把i-1个框内装j-1个苹果的基础上，我再单独放一个标号为i的苹果单独在一组。我们就也找到了第二部分

dp[i-1][j-1]

所以我们就找到了这样的动态转移方程（递推关系）

dp[i][j]=dp[i][j-1]*i+dp[i-1][j-1]

附代码,千万别提（chao）交(xi)，虽然用了ull但是也不能过

```
#include <bits/stdc++.h>
using namespace std;
unsigned long long dp[10005][1005];//i个篮子，放入j个苹果 
unsigned long long n,k,p;
unsigned long long m(unsigned long long x)
{
	return x%p;
}
int main()
{
	scanf("%llu%llu%llu",&n,&k,&p);
	for (int i=1;i<=n;i++)
		dp[1][i]=1;
	for (int i=2;i<=k;i++)//篮子数量 
		for (int  j=i;j<=n;j++)//没有篮子为空，至少i个篮子有i个苹果 
		{
			if (j==i)
				dp[i][j]=1;
			else
				dp[i][j]=m(m(m(dp[i][j-1])*m(i))+m(dp[i-1][j-1])); 
		}
	printf("%llu\n",m(dp[k][n])); 
	return 0;
 } 
```



---


# 跳舞

## 题目描述

小明今天得到一个跳舞毯游戏程序 Dance。游戏每次连续出 $N$ 个移动的“箭头”，箭头依次标号为 $1$ 到 $N$，并且得到相应的分数 $S _ 1, S _ 2, \ldots, S _ n$。如果你能“踏中”第 $i$ 号箭头，你将获得相应的分数 $S_i$；否则将被扣除相应的分数。

另外，游戏还有一个累计奖励机制：如果踏准次数累计达到 $T$，并且是在踏中第 $i$ 个箭头达到的，则将得到 $B_i$ 的奖励分数,累计也将清零，重新开始。

例如：$N=6,T=3$，相应的序列 $S$ 和 $B$ 分别为 $\{1,2,3,4,5,6\}$、$\{0,0,4,7,9,10\}$，如果小明踏中所有箭头，则得分为：$(1+2+3+4)+(4+5+6+10)=35$。

小明是个 Dance 高手，可以踏中他想踏中的任意一个箭头。但他发现，根据给定的 $N,T,S,B$，踏中所有的箭头不一定能得最高分，小明很想知道最高能得多少分，你能帮助小明计算一下最多可得多少分吗？


## 说明/提示


【样例解释】

跳过第一个，扣 $1$ 分，连踩 $3$ 个，得 $9$ 分，并获得附加分 $20$ 分，之后再连踩 $2$ 个，共 $39$ 分。

【数据范围】

对于 $20\%$ 的数据 $0\le N,T\le100$；

对于 $100\%$ 的数据 $0\le N,T\le 5000$；

序列 $S$ 和 $B$ 各有 $N$ 个数，所有分数为 $[0,10000]$ 之间的整数。

## 样例 #1

### 输入

```
6 3
1 2 3 4 5 6
1 1 1 20 1 1```

### 输出

```
39```

# 题解

## 作者：Dispwnl (赞：21)

用二维数组

i存跳到第几步

j存跳到次数

若跳
f[i][j]=f[i-1][j-1]+s[i]

若不跳

f[i][j]=f[i-1][j]

当跳的次数是t的倍数时

若不跳

f[i][j]=f[i-1][j]-s[i]

若跳
f[i-1][j-1]+s[i]+b[i])

取最大值

初始化

f[i][0]=f[i-1][0]-s[i]

即一直不跳



输出f[n][i](1<=i<=n)中最大值

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
using namespace std;
int n,t;
int s[5001],b[5001];
int f[5001][5001];
int main()
{
    cin>>n>>t;
    for(int i=1;i<=n;i++)
      cin>>s[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    for(int i=1;i<=n;i++)
      f[i][0]=f[i-1][0]-s[i];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=i;j++)
         {
             f[i][j]=max(f[i-1][j]-s[i],f[i-1][j-1]+s[i]);
             if(j%t==0) f[i][j]=max(f[i-1][j]-s[i],f[i-1][j-1]+s[i]+b[i]);
         }
    int ans=0;
    for(int i=1;i<=n;i++)
      ans=max(ans,f[n][i]);
    cout<<ans;
    return 0;
}

```

---

## 作者：Tyyyyyy (赞：13)

## 明显的DP(我才不会告诉你那是因为这题出现在了dp题单里）
当然对于不会dp的小伙伴，这题有个笨办法叫做暴力搜索。
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,s[5001],b[5001],ans;
void dfs(int step,int tn,int score)//箭头数，跳中步数，分数
{
	if(step>n)//常规边界判断
	{
		ans=max(ans,score);return;
	}
	if(tn==t)
	{
		tn=0;score+=b[step];//如果踩中步数达到奖励步数，计数器清零并加上奖励分
	}
	dfs(step+1,tn,score-s[step+1]);//对于每一步的两种情况：踩中，或不踩中
	dfs(step+1,tn+1,score+s[step+1]);
}
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)scanf("%d",&s[i]);
	for(int j=1;j<=n;j++)scanf("%d",&b[j]);
	dfs(0,0,0);//输入完直接搜索就可以啦
	printf("%d",ans);
	return 0;
}
```
当然这题这个算法只能骗到10分（从第二个点就开始出极限数据了），~~但是说不定哪位dalao来加点玄学剪枝就过了对不对~~
### 接下来是本题的正解：dp
首先，我们的第一任务应该是确定dp状态。
这题还是很好确定的，一个二维dp数组，一维存储现在已经过去的总箭头数，一维存储累计踏中的步数。

接下来就是推导状态转移方程了：

那么对于每一步而言，有踩，或不踩两种情况。

正常情况（即下一步无论踩不踩中都没有额外奖励分）：

$dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]);$

也即是说，踩或不踩两种情况作比较。

而当可以获得额外奖励分时：

$dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]+b[i]);$

仍然是踩与不踩作比较，但踩中则额外计算奖励分。

推出方程后就很简单了，写代码实现即可。

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,s[5001],b[5001],dp[5001][5001],ans;
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)scanf("%d",&s[i]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);//按题目要求读入
	for(int i=1;i<=n;i++)dp[i][0]=dp[i-1][0]-s[i];//初始化dp数组
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]);//正常情况
			if(j%t==0)dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]+b[i]);//有奖励的情况
		}
	}
	for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);//最后遍历一遍找最大值
	printf("%d",ans);//输出即可
	return 0;
}
```
更改说明：2020.7.26：使用LaTeX公式对dp方程进行了格式优化。

---

## 作者：grass8cow (赞：6)

设 $f_{i,j}$ 为小明踏了前 $i$ 个箭头，踏中 $j$ 个能得到的最大的分数。

当第 $i$ 个踏中后，

$f_{i,j}=f_{i-1,j-1}+s_i+(j \mod t?0:b_i)$ 

否则：

$f_{i,j}=f_{i-1,j}-s_i$

两者取 $max$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,i,j,a[5001],b[5001],f[5001][5001],ans;
int main()
{
	cin>>n>>t;
	for(i=1;i<=n;i++)cin>>a[i];
	for(i=1;i<=n;i++)cin>>b[i];
	for(i=1;i<=n;i++)for(j=0;j<=i;j++)f[i][j]=max(f[i-1][j]-a[i],j?(f[i-1][j-1]+a[i]+(j%t?0:b[i])):-210000000);
	for(j=0;j<=n;j++)ans=max(ans,f[n][j]);
	cout<<ans;
	return 0;
 } 
```

变态教练卡你空间，怎么办？

滚动数组优化即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,i,j,a[5001],b[5001],f[5001],ans;
int main()
{
	cin>>n>>t;
	for(i=1;i<=n;i++)cin>>a[i];
	for(i=1;i<=n;i++)cin>>b[i];
	for(i=1;i<=n;i++)for(j=i;j>=0;j--)f[j]=max(f[j]-a[i],j?(f[j-1]+a[i]+(j%t?0:b[i])):-210000000);
	for(j=0;j<=n;j++)ans=max(ans,f[j]);
	cout<<ans;
	return 0;
 } 
```

---

## 作者：皎月半洒花 (赞：6)

一道不是十分水的$dp$.

首先我们考虑$dp$方程的构造。起初我定义的状态是**$dp_{i,j}$表示前$i$个格子，总共跳了$j$次的最大得分**。但事实上它**并不可以转移**，因为我们不知道新的一轮操作从之间的哪个格子算起。

那么状态转移方程就出来了，我们把第一维改成**本次跳到第$i$个格子上，包括本次在内总共跳了$j$次的最大得分**，那么转移的时候，由于本次一定要跳到$i$上（如状态中所定义），所以不用分类讨论。方程就是：$$dp_{i,j}=\max\{dp_{k,j-1}-\rm{Sum(k + 1, i-1)}\}+A_i$$
其中$0 \leq k < i(\text{不能两次跳到同一个格子上所以右区间为开区间})$，$\rm{Sum(l,r)}\mathcal{=\sum\limits_{i=l}^{r}A_i}$

代码大概是这样$(\rm{30pts})$：

```cpp
#include <cstdio>
#include <iostream>

#define MAXN 5010 

using namespace std ; int i, j, k, Ans ;
int N, T, S[MAXN], dp[MAXN][MAXN], A[MAXN], B[MAXN] ;

int main(){
    cin >> N >> T ;
    for (i = 1 ; i <= N ; ++ i) 
        scanf("%d", &A[i]), S[i] = S[i - 1] + A[i] ;
    for (i = 1 ; i <= N ; ++ i) scanf("%d", &B[i]) ;
    for (i = 0 ; i <= N ; ++ i) 
        for (j = 0 ; j <= N ; ++ j)
            dp[i][j] = -192608170 ; dp[0][0] = 0 ;
    for (i = 1 ; i <= N ; ++ i)
        for (j = 1 ; j <= i ; ++ j){
            for (k = 0 ; k < i ; ++ k)
                dp[i][j] = max(dp[i][j], dp[k][j - 1] - S[i - 1] + S[k] + A[i]) ;
            if (j % T == 0) dp[i][j] += B[i] ; Ans = max(Ans, dp[i][j]) ;
        }
    cout << Ans << endl ; return 0 ;
}
```

但是我们发现，这个复杂度是$\Theta(n^3)$的，于是选择优化。$dp$优化的老套路就是：

* 优化状态维数

* 优化转移复杂度

而此处我们不可以优化状态了，所以考虑优化转移复杂度。转移的复杂度是$\Theta(n)$的，我们考虑可否$\Theta(1)$转移，最终使得总复杂度为$\Theta(n^2) \times \Theta(1) \leq O(n^2)$

从状态转移方程入手，我们发现有关于$k$是满足单调性的。所以不妨我们记录一下每次的$k$，即把$dp[k][j-1]+ S[k]$中的最大值存储下来，从而达到$\Theta(1)$转移的目的。

此处笔者使用了比较玄学的存储方式……类似刷表……当然这个地方有多种的优化方式啦～

完整版$code$（700～800ms）:

```cpp
#include <cstdio>
#include <iostream>

#define MAXN 5010 

using namespace std ; int i, j, k, p, Ans ;
int N, T, Last[MAXN], S[MAXN], dp[MAXN][MAXN], A[MAXN], B[MAXN] ;

int main(){
    cin >> N >> T ;
    for (i = 1 ; i <= N ; ++ i) 
        scanf("%d", &A[i]), S[i] = S[i - 1] + A[i] ;
    for (i = 1 ; i <= N ; ++ i) scanf("%d", &B[i]) ;
    for (i = 0 ; i <= N ; ++ i) 
        for (j = 0 ; j <= N ; ++ j)
            dp[i][j] = -192608170 ; dp[0][0] = 0 ;
    for (j = 1 ; j <= N ; ++ j){
        for (i = j ; i <= N ; ++ i){
            p = Last[i - j], Last[i - j] = 0 ;
            dp[i][j] = p - S[i - 1] + A[i] ; 
            if (j % T == 0) dp[i][j] += B[i] ; Ans = max(Ans, dp[i][j]) ;
            Last[i - j] = max(Last[i - j - 1], dp[i][j] + S[i]) ;
        }
    }
    cout << Ans << endl ; return 0 ;
}
```

~~毒瘤常数优化后被艹到龟速的版本~~（1100ms +）：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

#define max Max
#define MAXN 5010 
#define Inf 19260817

using namespace std ; int i, j, k, p, t, Ans ;
int N, T, Last[MAXN], S[MAXN], dp[MAXN][MAXN], A[MAXN], B[MAXN] ;


inline int Max(int a, int b){
	return a & ((b - a) >> 31) | b & ( ~ (b - a) >> 31) ;
}
inline int qr(){
    int res = 0 ; char c = getchar() ;
    while (!isdigit(c)) c = getchar() ;
    while (isdigit(c)) res = (res << 1) + (res << 3) + c - 48, c = getchar() ;
    return res ;
}
int main(){
	cin >> N >> T ; 
	for (i = 0 ; i <= N ; ++ i)
		for (j = 0 ; j <= N ; ++ j)
			dp[i][j] = -Inf ; dp[0][0] = 0 ;
	for (i = 1 ; i <= N ; ++ i) 
		A[i] = qr(), S[i] = S[i - 1] + A[i] ;
	for (i = 1 ; i <= N ; ++ i) B[i] = qr() ; 
	for (j = 1 ; j <= N ; ++ j){
		for (i = j ; i <= N ; ++ i){
			t = i - j, p = Last[t], dp[i][j] = p - S[i - 1] + A[i] ; 
			if (!(j % T)) dp[i][j] += B[i] ; Ans = max(Ans, dp[i][j]), Last[t] = max(Last[t - 1], dp[i][j] + S[i]) ;
		}
	}
	cout << Ans << endl ; return 0 ;
}

```

唉，先有常数后有天，反向优化$Sun$神仙啊

---

## 作者：Adove (赞：3)

状态转移方程dalao们都讲了

可是5000*5000怎么都觉得浪费空间啊

考虑到每次的状态只与前一次有关，我们用滚动数组压掉其中一维

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=5005;

int n,t,ans=-1e9;
int s[MAXN],b[MAXN];
int f[2][MAXN];

int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;++i) scanf("%d",&s[i]);
	for(int i=1;i<=n;++i) scanf("%d",&b[i]);
	for(int i=1;i<=n;++i){
		f[i&1][0]=f[i&1^1][0]-s[i];
		for(int j=1;j<=i;++j){
			f[i&1][j]=max(f[i&1^1][j]-s[i],f[i&1^1][j-1]+s[i]);
			if(j%t==0) f[i&1][j]=max(f[i&1^1][j]-s[i],f[i&1^1][j-1]+s[i]+b[i]);
		}
	}for(int i=0;i<=n;++i) ans=max(ans,f[n&1][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Polaris_Dane (赞：2)

这道题其实很好想

目测$O$($n*t$)DP？？？

手推一下转移方程还真是

$dp[i][j]$代表到了第i个跳了j次的最大得分

方程如下：

$if$ ( $j$ % $t$ $!=$ $0$ ) $dp[i][j]=max(dp[i-1][j-1]+s[i],dp[i-1][j]-s[i])$

$if$ ( $j$ % $t$ $==$ $0$ ) $dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]+b[i])$

但看了一眼数据范围，觉得需要滚动一下

然后初始化时**发现自己不能初始化**？？？

然后开了5001*5001信仰跑	**过了？？？**

后来发现自己智障了，其实是可以初始化的，在DP过程中初始化即可

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<queue>
#define M 601000
#define inf 0x3f3f3f3f 
#define LL long long
using namespace std;
int n,t,dp[5010][5010],s[M],b[M],ans;
inline int read()
{
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){
		if(s=='-')f=-1;
		s=getchar();
	}
	while (isdigit(s))
	{
		x=x*10+int(s-'0');
		s=getchar();
	}
	return x*f;
}
signed main(void)
{
	n=read(),t=read();
	for (int i=1;i<=n;i++) s[i]=read(),dp[i][0]=dp[i-1][0]-s[i];
	for (int i=1;i<=n;i++) b[i]=read();
	for (int i=1;i<=n;i++){
    	//在这里加一句dp[i][0]=dp[i-1][0]-s[i]即可滚动数组初始化
		for (int j=1;j<=i;j++){
			dp[i][j]=dp[i-1][j-1]+s[i];
			if (j%t==0) dp[i][j]+=b[i];
			dp[i][j]=max(dp[i][j],dp[i-1][j]-s[i]);
		}
	}
	for (int i=0;i<=n;i++) ans=max(ans,dp[n][i]);
	printf("%d",ans);
    return 0;
}

```


---

## 作者：lx_zjk (赞：2)

楼上有位大佬说

$f[i][j]$表示到了第$i$位 跳了$j$下是无法转移的

但是我一开始推得方程式就是这个 所以我又继续写了下去

最开始我写的是$O(n * t)$的做法, 但是这个算法是有漏洞的

$f[i][j]$表示跳到第$i$位, 跳了$j$下$(m >= j >= 1)$的情况下最大的分数

但是但$m$很小的时候这个算法就是错的 因为可能会重复

然后跑不出样例的我 修改了一下 $f$函数

修改成了$f[i][j]$表示到了第$i$位 跳了$j$下 最大的分

$f[i][j] = max(f[i - 1][j] - s[i], f[i - 1][j - 1] + s[i]) (j$ % $m != 0)$

$f[i][j] = max(f[i - 1][j] - s[i], f[i - 1][j - 1] + s[i] + b[i]) (j$ % $m == 0)$

记住 千万不要这么写
```cpp
f[i][j] = max(f[i - 1][j] - s[i], f[i - 1][j - 1] + s[i]);
if (j % m == 0) f[i][j] += b[i];
```

因为这样就可能会导致$b[i]$重复加

然后就是比较简单的实现 不多讲了

# Code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 5000 + 50;

int n, m, ans, s[MAX_N], b[MAX_N], f[MAX_N][MAX_N];

int main() {
	n = read(); m = read();
	for (int i = 1; i <= n; i ++ ) s[i] = read();
	for (int i = 1; i <= n; i ++ ) b[i] = read();
	for (int i = 1; i <= n; i ++ ) f[i][0] = f[i - 1][0] - s[i];
	for (int i = 1; i <= n; i ++ ) {
		for (int j = 1; j <= i; j ++ ) {
			if (j % m == 0) f[i][j] = max(f[i - 1][j] - s[i], f[i - 1][j - 1] + b[i] + s[i]);
			else f[i][j] = max(f[i - 1][j - 1] + s[i], f[i - 1][j] - s[i]);
//			if (j == m) f[i][j] += b[i];
			if (i == n) ans = max(ans, f[i][j]);
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：MZ_CXQ (赞：1)

难道不是一道十分水的$dp$吗~~狗头~~,反正我是看了题后五分钟就打出来了

$f[i,j]$表示当前在$i$,累计踩中了$j(0 < j \leq i,j < T)$次的最高得分

//当前不踩

+ $f[i,k] = f[i-1,k] - s[i]$

//当前踩

//$k+1 < T$(踩后累计次数未到$T$)

+ $f[i,k+1] = f[i-1,k] + s[i]$

//$k+1 == T$(踩后累计次数到$T$)

+ $f[i,0] = f[i-1,k] + s[i] + b[i]$

$1 \leq i \leq n,0 \leq k < T,k \leq i-1$
($k$ 是$i-1$的踩中的次数)

空间都懒得压了

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <set>
typedef long long ll;
using namespace std;

template <typename T>void in(T &x) {
    x = 0; T f = 1; char ch = getchar();
    while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
    while(isdigit(ch)) {x = 10*x + ch - '0'; ch = getchar();}
    x *= f;
}

template <typename T>void out(T x) {
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) out(x/10);
    putchar(x%10+'0');
}

//---------------------------------------------------------------

const int N = 5010;

int n,T;
int s[N],b[N],f[N][N];

int main() {
	in(n); in(T);
	for(int i = 1;i <= n; ++i) in(s[i]);
	for(int i = 1;i <= n; ++i) in(b[i]);
	memset(f,~0x3f,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i <= n; ++i) {
		for(int k = 0; k < T && k <= i-1; ++k) {
			f[i][k] = max(f[i][k],f[i-1][k]-s[i]);
			if(k+1 < T) f[i][k+1] = max(f[i][k+1],f[i-1][k]+s[i]);
			if(k+1 == T) f[i][0] = max(f[i][0],f[i-1][k]+s[i]+b[i]);
		}
	}
	int ans = -0x3f3f3f3f;
	for(int i = 0;i < T; ++i) ans = max(ans,f[n][i]);
	out(ans);
	return 0;
}
```

---

## 作者：夏色祭 (赞：1)

##简单的dp+优化

状态:f[i,j] 表示踩了i个，最后一个踩的点为j

**然后，其实推方程并不难。。。（这是最骚的）**

方程：f[i,j]:=max{f[i-1,k]-(sum[j-1]-sum[k])}+a[j]（sum[i]保存的为i个数之和，也就是前缀和）  如果i是m的倍数的话再加上b[j]

然而就这样三重循环（时间复杂度n^3）交上去只有30.....

怎么优化？

我们就来考虑把k这重循环去掉，把时间复杂度将至n^2。

因为k的取值范围为i-1~j-1，而我们枚举j是递增的，并且第i个只和i-1有关，那么我们来考虑用一个变量记录当当前到j为止的f[i-1,k]+sum[k]的max ，那么转移方程就变成了f[i,j]:=max-sum[j-1]+a[j]，成功的去掉了k

献上Pas AC代码：


```cpp
uses math;
var
  a,b,sum:array[0..5001]of int64;
  f:array[0..5001,0..5001]of longint;
  n,m,i,j,k,ans,x1,x2:longint;
begin 
  readln(n,m);
  for i:=1 to n do 
    begin
      read(a[i]);
      sum[i]:=sum[i-1]+a[i];
    end;
  for i:=1 to n do read(b[i]);
  for i:=0 to n do 
    for j:=0 to n do 
      f[i,j]:=-666666666;
  f[0,0]:=0;//初始化
  for i:=1 to n do
    begin
      x1:=-maxlongint;//用x1保存f[i-1,k]+sum[k]的最大值
      for j:=i to n do
        begin
          if x1<f[i-1,j-1]+sum[j-1] then x1:=f[i-1,j-1]+sum[j-1];//如果新进来的值大于之前的最大值，则更新x1
          f[i,j]:=x1-sum[j-1];
          inc(f[i,j],a[j]);
          if i mod m=0 then inc(f[i,j],b[j]);//不解释......上面应该说的很清楚了。。。。常规操作，常规操作
          ans:=max(ans,f[i,j]);//直接在f[i,j]里取一个最大值为我们要的答案（因为没有负数）
        end;
    end;//dp
  writeln(ans);
end.

```

---

## 作者：回青绝影 (赞：0)

这道题没有很好的滚动数组题解诶

其实还蛮好优化的

就是为了防止连续更新，有两种解决办法！！！

+ 一种已经在某一篇题解中提到了，就是把奇偶位分开来处理，防止连续更新……（汗，就是太烦了……

+ 另一种办法就是倒着扫……更简单，就是要注意一个细节，把f[0]的更新放在最后面

QAQ本蒟蒻还写错了好几遍……		<----太‘**蔡**’了

---
对了，还得说一下转移方程：

 $$ f(x)=\begin{cases} \max(f[i-1][j-1]+s[i],f[i-1][j]-s[i])&j\%t\ne0\\\max(f[i-1][j-1]+s[i]+b[i],f[i-1][j]-s[i])&j\%t=0\end{cases} $$ 

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100001;
int n,t,s[N],b[N],f[N],ans;
int main(){
    scanf("%d%d",&n,&t);
    for (int i=1;i<=n;i++) scanf("%d",&s[i]);
    for (int i=1;i<=n;i++) scanf("%d",&b[i]);
    for (int i=1;i<=n;i++){
        for (int j=i;j>=1;j--){
            if (j%t) f[j]=max(f[j-1]+s[i],f[j]-s[i]);
            else f[j]=max(f[j-1]+s[i]+b[i],f[j]-s[i]);
        }
        f[0]-=s[i];						//<--我在这句话上挂了N次！！！
    }
    for (int i=1;i<=n;i++) ans=max(ans,f[i]);
    printf("%d",ans);
    return 0;
}
```


---

## 作者：zhouenji (赞：0)

简单的dp方程，dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]);(j%t!=0);

dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]+b[i]);(j%t==0)

但我做预处理的时候卡了半天，其实也不是很难想

代码如下:

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=5000+10;
int s[maxn],b[maxn];
int dp[maxn][maxn];
int n,t,ans;
int main()
{
    scanf("%d%d",&n,&t);
    for(int i=1;i<=n;i++)scanf("%d",&s[i]);
    for(int i=1;i<=n;i++)scanf("%d",&b[i]);
    for(int i=1;i<=n;i++)dp[i][0]=dp[i-1][0]-s[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]);
            if(j%t==0 && i!=1) dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]+b[i]);
        }
    }
    for(int i=0;i<=n;i++) ans=max(ans,dp[n][i]);
    printf("%d\n",ans);
}
```

---

## 作者：mengdai (赞：0)

这是一道简单的二维DP

f[n][t]表示第n个踏时，已经累计了t个时的最大得分

状态转移转移方程会的自己列

不会的请看代码

华丽的分割线==================================================================================

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<fstream>
using namespace std;
int n,t,i,ans;
int s[5003],b[5003];
int jiyi[5003][5003];
int dp(int nn,int zong){//记忆化搜索
    int& fanhui=jiyi[nn][zong];
    if(fanhui!=0){
        return fanhui;
    }else{
        if(nn==n+1){
            return 0;
        }else{
            if(zong==t-1){
                fanhui=max(dp(nn+1,0)+s[nn]+b[nn],dp(nn+1,zong)-s[nn]);//当已经累计t-1次时
            }else{
                fanhui=max(dp(nn+1,zong+1)+s[nn],dp(nn+1,zong)-s[nn]);//当累计次数<t-1次时
            }
        }
    }
    return fanhui;
}
int main(){
    cin>>n>>t;
    for(i=1;i<=n;i++){
        cin>>s[i];
    }
    for(i=1;i<=n;i++){
        cin>>b[i];
    }
    ans=dp(1,0);
    cout<<ans;
    return 0;
}
```

---


# 宗教问题

## 题目背景

在一个地区有许多种宗教，不同信仰的教徒经常发生矛盾，最为治安管理的人需要把这些人分开，以免矛盾激化。


## 题目描述

已知一个地方有M种宗教(编号为1—M)，有N个教徒(编号为1—N)，每个教徒信且只信一种宗教。现在要按顺序把这N个教徒分成一些集体，每个集体的危险值定义为这个集体中的宗教种数，且一个集体的宗教种类不能超过K种，否则就会无限危险，

问：
1.这N个教徒至少要分为几个集体，

2.这些集体的危险值总和至少为多少。


## 说明/提示

【样例解释】

最少集体数：1  2  3 // 4  3  4  3  2 // 1  2  共3个集体

最小危险值：1  2 // 3  4  3  4  3 // 2  1  2   2+2+2=6


【数据范围】

对于20%的数据  N≤20

对于50%的数据  N≤100

对于100%的数据  N≤1000  M≤20  1≤K＜M


## 样例 #1

### 输入

```
10 4 3
1 2 3 4 3 4 3 2 1 2
```

### 输出

```
3
6
```

# 题解

## 作者：06ray (赞：35)

这题是道~~非常水~~的dp题。

思路如下：

1. 先读入题目中要求读入的n,m,k和每个教徒信的宗教编号。

1. 开始写核心部分。
	
    ①定义两个数组为f和dp，f[i]表示前i个教徒至少要分为几个集体，dp[i]表示前i个集体的危险值总和至少为多少。
    
    ②确定边界，这个比较好写，f[1]=a[1]（注：a[1]是第1个教徒信的宗教编号）;dp[1]=1。
    
    ③确定循环。共两层循环。第一层循环是从1到n，遍历n个教徒，用i作循环变量；第二层循环是从i到1逆序循环，循环变量j枚举的是前i个教徒的最后一个集体中的第一个教徒序号（也可以说是确定最后集体的大小）。
    
    ④判断前i个教徒的最后一个集体是否满足题目中条件。这并不难，首先定义一个桶，再定义统计最后集体里不同宗教编号数量为n1。发现如果第j个教徒所信仰的宗教编号没有出现过，那么就标记第j个教徒所信仰的宗教编号出现过，并且n1++。当发现n1大于k时，就直接break（想想为什么可以这样做）。
    
    ⑤现在就开始推状态转移方程了。其实方程特别好写，如下
    
    		f[i]=min(f[i],f[j-1]+1);
            
            dp[i]=min(dp[i],dp[j-1]+n1);
            
     自己可以慢慢体会含义，看完上面的解释应该能懂（~~不写原因其实是作者语文水平太差~~）

1. 最后我们就可以输出f[n]和dp[n]了。

时间复杂度为O(n^2)

上代码 ( *^_^* )

### 注意：减少代码复制，共创美好洛谷！

```cpp
#include <iostream>
#include <cstring>//头文件 
using namespace std;//名字空间 
int f[10000],dp[10000];//f数组存的是前i个教徒至少要分为几个集体的解，dp数组存的是前i个集体最小的危险值总和
int a[10000];//a数组存的是每个教徒信的宗教编号 
bool b[10000];//这是一个桶 
int main()
{
	int n,m,k;
	cin>>n>>m>>k;//读入 
	for(int i=1; i<=n; i++)
	cin>>a[i];//读入 
	f[1]=1;
	dp[1]=1;//定义边界 
	for(int i=2; i<=n; i++)
	{
		f[i]=10000000;
		dp[i]=10000000;//dp[i]和f[i]一开始要赋一个较大的数 
		memset(b,0,sizeof(b));//初始化，很重要 
		int n1=0;//n1统计最后集体里不同宗教编号数量
		for(int j=i; j>=1; j--)//逆序枚举 
		{
			if(!b[a[j]])//如果第j个教徒所信仰的宗教编号没有出现过
			{
				n1++;//总数加1 
				b[a[j]]=true;//标记第j个教徒所信仰的宗教编号出现过
			}
			if(n1>k) break;//跳出当前循环 
			f[i]=min(f[i],f[j-1]+1);
			dp[i]=min(dp[i],dp[j-1]+n1);//直接套用状态转移方程 
		}
	}
	cout<<f[n]<<endl<<dp[n];//输出解 
	return 0;//养成良好的编程习惯 
}
```
p.s 如果此题解有地方说的不好或是说错了，请在评论区告诉作者错误原因，谢谢！

---

## 作者：UperFicial (赞：11)

# $dp$ 好题

谨听 [$\texttt{\color{black}d\color{red}ark\_jt}$](https://www.luogu.com.cn/user/9914) 神仙的教诲，在 $csp$ 前刷刷 $dp$。

### 题目大意

有 $n$ 个人，每个人信一个宗教，让您划分若干段，使得危险总和最小且每一段的信不同宗教的人数不能超过 $k$。

定义危险总和为每一段的不同宗教的种类之和。

问：

- 最少划分多少区域。

- 危险总和最小是多少。

### 解题思路

看到两个问题，不难想到，需要用到两个 $dp$ 数组，第一个数组 $dp1_i$ 表示到第 $i$ 个人最少划分的区域，第二个数组 $dp2_i$ 表示到第 $i$ 个人的最小危险总和。最后直接输出 $dp1_n$ 和 $dp2_n$ 就 $\text{OK}$ 了。

**那么怎么写状态转移方程？**

这也是本题~~和所有 $\sout{dp}$ 问题~~的一大难点。

可以这么想：

如果求 $dp1_i$ 和 $dp2_i$，那么第 $i$ 个位置必定由位置 $j$ 转移过来并且 $1\le j\le i$。

先不想区间 $[j,i]$ 的宗教数量是否合法，先想 $dp1$ 的状态转移方程。

第 $i$ 个位置有两种选择：

- 不分段。那么 $dp1_i$ 不动，$dp1_i=dp1_i$。

- 分段。既然 $j$ 指的是区间 $[j,i]$ 的左端点，那么上一个分段的地方肯定是 $dp1_{j-1}$，加上一个 $1$ 就好了，因为又分了一段。$dp1_i=dp1_{j-1}+1$。

两者取个 $\min$ 就是状态转移方程：$dp1_i=\min(dp1_i,dp1_{j-1}+1)$。

再来看 $dp2_i$，同理，还是有两种选择，第一中选择就是不动，第二中选择是计算如果要分段的危险值，也就是 $dp2_{j-1}$ 的危险值 $+$ 这个区间不同宗教的个数 $num$。

那么如何求 $num$ 呢？显然，如果要求 $num$，那么 $j$ 必须**倒序枚举！** 这也是本题的一个关键，而恰恰其它的题解**没有讲**。

如果倒序枚举 $j$ 的话，可以每次对于一个 $a_j$ 判断是否出现过，显然需要一个 $vis$ 来标记，如果没出现过，$num++$，意味着又有一个新的宗教，假设目前的 $num>k$，那么就是说 $j$ 再往后枚举也无益！因为到这里已经不合法了！

$Code:$

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1010;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
int n,m,k,a[MAXN],dp1[MAXN],dp2[MAXN],num,vis[MAXN];
void init(int k,int*x,int y)
{
	num=false;
	fill(x+1,x+1+k,y);
	return;
}
int main()
{
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;i++) a[i]=read();
	init(n,dp1,1e9);
	init(n,dp2,1e9);
	for(register int i=1;i<=n;i++)
	{
		init(m,vis,0);
		for(register int j=i;j>=1;j--)
		{
			if(!vis[a[j]]) vis[a[j]]=true,++num;
		    if(num>k) break;
			dp1[i]=min(dp1[i],dp1[j-1]+1),dp2[i]=min(dp2[i],dp2[j-1]+num); 
		}
	}
	printf("%d\n%d\n",dp1[n],dp2[n]);
	return 0;
}
```

$$\texttt{The end.by UF}$$



---

## 作者：lwz2002 (赞：9)

（~~好不容易做出来一道DP QAQ~~）

## 思路

很明显，这是一道DP题（~~废话~~）,那我们怎么设计状态呢？

我们先从一维开始分析，即用$f_i$表示前$i$个教徒中至少需要几个集体,我们可以发现，在转移状态$f_i$时，只与前面的有关，所以我们可以再枚举一个$j$，表示从$j$到$i$分到一个集合中，只要满足信仰的宗教数$<=k$，即可转移。

这样我们就解决了状态和转移的问题，然而为什么这样去思考呢？（个人理解仅供参考）

因为我们在思考低维状态时，若感觉不可解决，可以选择加一个维度从而降低我们的思维难度，从而达到目的（而在这道题中恰好一维就能解决）。

而第二问和第一问一样，同理转移即可。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 2147483647
#define ll long long

using namespace std;
int n,m,k;
int a[1010],f[1010],dp[1010],vis[1010];
int sum[1010][1010];  //sum[i][j]表示从i到j的不同的宗教个数
int main()
{
	memset(f,127,sizeof f);
	memset(dp,127,sizeof dp);
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	//预处理出从i到j的宗教个数
	for(int i=1;i<=n;i++)
	{
		memset(vis,0,sizeof vis);
		for(int j=i;j<=n;j++)
		{
			sum[i][j]=sum[i][j-1];
			if(!vis[a[j]]) sum[i][j]++,vis[a[j]]=1;
		}
	}
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=n;i++)
		for(int j=i;j>=1;j--)
			if(sum[i-j+1][i]<=k) f[i]=min(f[i],f[i-j]+1);
	dp[0]=0;
	dp[1]=1;
	for(int i=2;i<=n;i++)
		for(int j=i;j>=1;j--)
			if(sum[i-j+1][i]<=k) dp[i]=min(dp[i],dp[i-j]+sum[i-j+1][i]);
	printf("%d\n%d",f[n],dp[n]);
	return 0;
}
```

---

## 作者：MloVtry (赞：7)

这种强行把两个题压成一个题的出题人

剪枝魂淡！

好了数量上

贪心
能放就放，放不了开新的

数量
dp,f[i]表示前i个人最小的代价

然后枚举这个集合开到多大，转移即可n^2

代码
    
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int sta[1010],l,num[1010];
int n,m,a[1010],k;
int f[1010],in,inu;
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    sta[++l]=(1<<a[1]);num[1]=1;
    for(int i=2;i<=n;++i)
    {
        if(sta[l]&(1<<a[i])) continue;;
        sta[l]|=(1<<a[i]);
        num[l]++;
        if(num[l]==k+1)
        {
            l++;
            sta[l]|=(1<<a[i]);
            num[l]++;
        }
    }
    cout<<l<<endl;
    memset(f,20,sizeof(f));f[0]=0;
    for(int i=1;i<=n;++i)
    {
        int j=i;
        in=inu=0;
        while("MloVtry is Handsome")
        {
            if(!(in&(1<<a[j])))
            {
                in|=(1<<a[j]);
                inu++;
                if(inu>k) break;
            }
            f[i]=min(f[i],f[j-1]+inu);
            j--;
            if(!j) break;
        }
    }
    cout<<f[n]<<endl;
    return 0;
}
```

---

## 作者：EMO_smile (赞：3)

# P2072 宗教问题

[题目传送门](https://www.luogu.com.cn/problem/P2072)

## 题意分析：

~~这个 DP 确实挺水~~

这个题目分为两个 DP：第一个是分完所有信徒后所需最少集体数，第二个是集体危险和的最小值。

设 $f_{i}$ 是分至前 $i$ 个信徒时所需的最小集体数，$f1[i]$ 是分至前 $i$ 个信徒是集体危险和的最小值，cnt 为在 $i$ 到 $j$ 之间不同信仰教徒的数目，则有：

$$
f_{i}= \min (f_{i},f_{j-1}+1);
$$

$$
f1[i]= \min (f1[i],f1[j-1]+cnt);
$$

特判：当 $cnt>K$ 时，意味着这个集体的宗教种类超过 $K$ 种，退出本次循环。
  
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
	return;
}
int f[10001],f1[10001],believer[10001],n,m,k;
bool bowl[10001];
int cnt;
int main(){
	n=read();m=read();k=read();
	for(int i=1;i<=n;i++){
		believer[i]=read();//输入信徒宗教编号
	}
	memset(f,2147483647,sizeof(f));
	memset(f1,2147483647,sizeof(f1));
	f[1]=1;f1[1]=1;
	for(int i=1;i<=n;i++){//从1到n遍历
		cnt=0;
		f[i]=2147483647;
		f1[i]=2147483647;//2147483647=^31-1,int类型的最大值;
		memset(bowl,0,sizeof(bowl));//清空筒;
		for(int j=i;j>=1;j--){
			if(!bowl[believer[j]]){
				cnt++;
				bowl[believer[j]]=1;
			}
			if(cnt>k){//某个集体宗教总类超过k种
				break;
			}
			f[i]=min(f[i],f[j-1]+1);//状态转移方程
			f1[i]=min(f1[i],f1[j-1]+cnt);
		}
	}
	cout<<f[n]<<"\n"<<f1[n];
	return 0;
}
```

---

## 作者：guojiale0713 (赞：3)

## 思路
在读了题目之后我们发现这出题人把两道题合成了一道题。

~~剪枝魂淡（bushi~~

这道题分为两问。

让我们先来看看第一问：

> 求最少的集体数

既然是动规，那我们肯定要先求出它的动态转移方程。

我们先从一维开始分析，即用 $f_i$ 表示前 $i$ 个教徒中至少需要几个集体，我们可以发现，在转移状态 $f_i$ 时，只与前面的有关，所以我们可以再枚举一个 $j$，表示从 $j$ 到 $i$ 分到一个集合中，只要满足信仰的宗教数 $\le k$，即可转移。

转移方程：

$$dp_i=\min(dp_i,dp_{i-j}+cnt_{i-j+1,i});$$

这样我们就解决了状态和转移的问题，然而为什么这样去思考呢？（~~因为教练就是这么教的~~）

因为我们在想这种题的时候，会遇到一些感觉不可解决的问题，这样的话可以选择从一维转成二维加一个维度，这样就能降低我们的思维的占用，从而达到自己想要达到的目的。

然后第二问和第一问同理，找出方程即可。

## 代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 0x3f3f3f3f
#define ll long long
using namespace std;
int n,m,k;
int a[1010],f[1010],dp[1010],v[1010];
int cnt[1010][1010]; 
int main(){
    memset(f,127,sizeof f);
    memset(dp,127,sizeof dp);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        memset(v,0,sizeof v);
        for(int j=i;j<=n;j++){
            cnt[i][j]=cnt[i][j-1];
            if(!v[a[j]]){
                cnt[i][j]++;
                v[a[j]]=1;
            }
        }
    }
    f[0]=0;
    f[1]=1;
    for(int i=2;i<=n;i++){
        for(int j=i;j>=1;j--){
            if(cnt[i-j+1][i]<=k){
                f[i]=min(f[i],f[i-j]+1);
            }
        }
    }
    dp[0]=0;
    dp[1]=1;
    for(int i=2;i<=n;i++){
        for(int j=i;j>=1;j--){
            if(cnt[i-j+1][i]<=k){
                dp[i]=min(dp[i],dp[i-j]+cnt[i-j+1][i]);
            } 
        }
    }
    cout<<f[n]<<endl<<dp[n]<<endl;
    return 0;
}
```

---

## 作者：zhangyuhan (赞：3)

我看到大佬的题解，为什么第$1$个子任务也用$DP$算呢？完全可以用贪心啊。。。

言归正传。

对于第一个子任务，直接贪心，能取多少取多少，取满后清零再取。

对于第二个子任务，考虑$DP$。

设$f_i$表示前$i$个教徒的最少危险值，则有：

$f_i=\min\{f_j+danger_{i,j}\}$ $(danger_{i,j}<=k)$

其中$danger_{i,j}$表示$i,j$之间的危险值。

问题来了：$danger_{i,j}$怎么求呢？

$1.$在跑方程的时候暴力求解。

时间复杂度：$O(n^3)$，显然会$T$。

$2.$预处理。

令$cnt$为计数器，当发现新的宗教时$cnt++$，并且标记这个宗教，而每一段对应的$danger_{i,j}$即为$cnt$

时间复杂度：$O(n^2)$，可过。

至于边界，显然有$f_0=0,f_1=1$

目标自然是$f_n$

$AC$ $Code$ (代码中的$sum_{i,j}$即为$danger_{i,j}$)

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int n, m, k, a[10010], cnt, ans, sum[1010][1010], f[1010];
bool vis[10010];

int main() {
	cin >> n >> m >> k;
	for (int i=1; i<=n; i++) 
		cin >> a[i];
	for (int i=1; i<=n; i++) {
		cnt = 0;
		memset(vis, false, sizeof(vis));// 一定要清空!
		for (int j=i; j<=n; j++) {
			if (!vis[a[j]]) {
				vis[a[j]] = true;
				cnt++;
			}
			sum[i][j] = cnt;
		}
	}
	cnt = 0;
	memset(vis, false, sizeof(vis));//注意，出来时也要清空！我被坑了好长时间TAT
	for (int i=1; i<=n; i++) {
		if (!vis[a[i]]) {
			vis[a[i]] = true;
			cnt++;
		}
		if (cnt > k) {
			ans++;
			cnt = 1;
			memset(vis, false, sizeof(vis));//记得清空！
			vis[a[i]] = true;
		}
		if (i == n)
			ans++;
	}
	cout << ans << endl;
	f[0] = 0;
	f[1] = 1;//初始化莫忘掉
	for (int i=2; i<=n; i++) {
		f[i] = 1e9;//因为取最小值，所以初值要赋大
		for (int j=1; j<=i; j++) 
			if (sum[j][i] <= k) //而且危险值不能超过k
				f[i] = min(f[i], f[j-1]+sum[j][i]);
	}
	cout << f[n] << endl;
	return 0; //完结撒花！
}
```

---

## 作者：卷王 (赞：2)

这又是一道 dp 题。咋眼一看，题目需要输出两个东西，那就两个 dp 呗。

我们建立两个 dp 数组 $team_i$ 和 $hazard_i$ 分别表示前 $i$ 个教徒至少要 **分几个集体** 和 **危险值总和**。

转移方程为：

* $team_i= \min(team_i,team_{j-1}+1)$
* $hazard_i= \min(hazard_i,hazard_{j-1}+num)$，其中 $num$ 表示在 $[j,i]$ 之间有几个有不同信仰的教徒。

代码如下（含注释）：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, cnt = 0;
int a[1007], c[1007];
int team[1007], hazard[1007];
int main() {
	cin >> n >> m >> k;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	memset(team, 0x3f, sizeof(team));
	memset(hazard, 0x3f, sizeof(hazard));
	team[1] = a[1], hazard[1] = 1;
	team[0] = 0, hazard[0] = 0;
	for(int i = 1; i <= n; i++) { //遍历 n 个教徒 
		memset(c, 0, sizeof(c));
		cnt = 0;
		for(int j = i; j >= 1; j--) {
		//枚举前 i 个教徒的最后一个集体是否满足题目条件 
			if(c[a[j]] == 0) {
				c[a[j]] = 1;
				cnt++;
			}
			if(cnt > k) break;
			team[i] = min(team[i], team[j - 1] + 1);
			hazard[i] = min(hazard[i], hazard[j - 1] + cnt);
		}
	}
	cout << team[n] << endl << hazard[n];
	return 0;
}
```

---

## 作者：GUO120822 (赞：2)

这是一道妥妥的动态规划。

出题人也是真牛，出了一道~~二合一~~的题。

好了，步入正题。

# 思路
我们先来看第一小问：这 $N$ 个教徒至少要分为几个集体。
- 状态设计

我们很容易想到用 $f_i$ 表示前 $i$ 个人，至少要分成多少组。
- 动态转移方程

对于每个 $f_i$，枚举它的断点，然后加上 $j$ 到 $i$ 的贡献。

$f_i=\min(f_i,f_{j-1}+1)$。

再来看第二小问：这些集体的危险值总和至少为多少。
- 状态设计

同样的，我们用 $dp_i$ 表示前 $i$ 个人，种类数和的最小值。
- 动态转移方程

也是枚举断点。

$dp_i=\min(dp_i,dp_{j-1}+sum_{j,i})$。

$sum_{j,i}$ 表示从 $j$ 到 $i$ 的种类数。

直接枚举会超时，我们就倒序枚举，每次加上种类数，在枚举时统计。

再二合一，得到[代码](https://www.luogu.com.cn/record/143440552)。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010,M=30,inf=0x3f3f3f3f;
int n,m,k,i,j,f[N],dp[N],cnt[M],a[N],sum;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for (i=1;i<=n;i++) scanf("%d",&a[i]);
	for (i=1;i<=n;i++)
	{
		f[i]=dp[i]=inf;
		memset(cnt,0,sizeof(cnt));
		sum=0;
		for (j=i;j>=1;j--)
		{
			if (!cnt[a[j]])
			{
				cnt[a[j]]++;
				sum++;
			}
			if (sum>k) break;
			f[i]=min(f[i],f[j-1]+1);
			dp[i]=min(dp[i],dp[j-1]+sum);
		}
	}
	printf("%d\n%d",f[n],dp[n]);
	return 0;
}
```

---

## 作者：JCLinux (赞：2)

## 第一个问题其实可以用贪心来做

---
关于 dp 的做法，其他的题解讲过了这里不再赘述。

我们来看**第一个问题**（第二个问题还是要用 dp ）：在每组不同宗教信仰人数不超过 k 的情况下，最小分几组

我们来看第 j 个人，在他之前的人已经分好组，现在他有两种选择：在前面的组还能容纳他的情况下加入前面一组；自己新开一组

在加入前面一组的情况下，不会使分组数量增加，而自己新开一组，不会使从他开始后面的分组数减少，反而可能增加，因此：**只要能加入前面一组，就把他加到前面一组去**

我这里用 STL 中的  **set** 来实现

如果发现我的思路有错误，欢迎指出！

## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int num;
int arr[1003];
bool vis[1003];
int dp[1003];
set<int>area;
int main()
{
    cin.sync_with_stdio(false);
    cin >> n >> m >> k;
    for(int i=1;i<=n;i++) cin >> arr[i];
    for(int i=1;i<=n;i++)//贪心统计
    {
        area.insert(arr[i]);
        if((int)area.size()>k) num++,area.clear(),area.insert(arr[i]);
    }
    cout << num+1 << endl;//num是0开始的
    for(int i=1;i<=n;i++)
    {
        memset(vis,0,m+1);
        num=0;
        dp[i]=100000000;
        for(int j=i;j;j--)
        {
            if(!vis[arr[j]]) num++,vis[arr[j]]=1;
            if(num>k) break;
            dp[i]=min(dp[i],dp[j-1]+num);
        }
    }
    cout << dp[n];
    return 0;
}

```


---

## 作者：Uni_Tune (赞：1)

使用区间DP.

首先整理$i$到$j$之间宗教种类用数组$u$记录

然后直接使用DP求出每一区间内最小危险值和集体数.

转移方程如下，限制条件是$u[v+1][j]<=k$，同时依照我的算法，开始是要判断整一个区间是否可以直接计算一次。

$f1[i][j]=min(f1[i][j],f1[i][v]+1)$

$f2[i][j]=min(f2[i][j],f2[i][v]+u[v+1][j])$

最后答案即$1$至$n$的两个最小.

```cpp
#include<cstdio>
#define MAXN 1001
#define MAXM 21
#define MAX 0x7fffffff
using namespace std;
int r[MAXN];
int u[MAXN][MAXN];
int f1[MAXN][MAXN],f2[MAXN][MAXN];
int n,m,k;
bool b[MAXM];
int min(int a,int b){
	if(a>=b) return b;
	if(a<b) return a;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++) scanf("%d",&r[i]);
	for(int i=1;i<=n;i++){
		int l=0;
		for(int j=i;j<=n;j++){
			if(!b[r[j]]){
				l++,b[r[j]]=true;
			}
			u[i][j]=l;
			f1[i][j]=MAX;
			f2[i][j]=MAX;
		}
		for(int j=1;j<=m;j++) b[j]=false;
		f1[i][i]=1;
		f2[i][i]=1;
	}
	for(int i=1;i<=n-1;i++){
		for(int j=i+1;j<=n;j++){
			if(u[i][j]<=k) f2[i][j]=min(f2[i][j],u[i][j]);
			if(u[i][j]<=k) f1[i][j]=min(f1[i][j],1);
			for(int v=i;v<=j;v++){
				if(u[v+1][j]<=k){
					f2[i][j]=min(f2[i][j],f2[i][v]+u[v+1][j]);
			     	f1[i][j]=min(f1[i][j],f1[i][v]+1);
				}	
			}
		}
	}
	printf("%d\n%d",f1[1][n],f2[1][n]);
	return 0;
}

//一年以前还没退时不会写的东西竟然就这么过了？

//-真是神奇。。。-
```

---

## 作者：_yang_yi_bo_ (赞：0)

我们定义状态转移方程 $dp_i$ 表示前 $i$ 个人中分成的最小的集体数，$f_i$ 表示前 $i$ 个人中最小的危险值。

当枚举到 $i$ 时，不停往前枚举前面的人，直到宗教的种类数 $>k$，退出，因为当种类数 $>k$ 时，所有人不能分为同一组。

状态转移方程为：


```cpp
dp[i]=min(dp[i],dp[j-1]+1);
f[i]=min(f[i],f[j-1]+tot);
```


因为当枚举第 $j$ 个人时，可以让第 $[j,i]$ 个人分为一组，组数就为前面 $j-1$ 个人分的组数 $+1$，需要取最小值，危险数为就是前 $j-1$ 个人的危险值 $+$ 当前宗教的种类数，也要取最小值。

答案很容易推断：分别为 `dp[n]` 与 `f[n]`。

由于是求最小值，初始值要设为极大值，但 `dp[0]` 与 `f[0]` 要设为 $0$。

蒟蒻的语文水平很差，建议看代码去理解。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[1005];
int dp[1005],f[1005];
int cnt[1005];
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}memset(dp,0x3f,sizeof dp);
	memset(f,0x3f,sizeof f);
	f[0]=dp[0]=0;
	for(int i=1;i<=n;i++){
		memset(cnt,0,sizeof cnt);
		int tot=0;
		for(int j=i;j>=1;j--){
			if(cnt[a[j]]==0){
				cnt[a[j]]++;
				tot++;
			}if(tot>k){
				break;
			}dp[i]=min(dp[i],dp[j-1]+1);
			f[i]=min(f[i],f[j-1]+tot);
		}
	}cout<<dp[n]<<"\n"<<f[n];
	return 0;
} 
```

---

## 作者：_xdd_ (赞：0)

有两问，需要用到 $2$ 个 DP 数组，分别是 $f1$ 和 $f2$。

$f1_i$ 表示到第 $i$ 个人最少划分区域的个数，$f2_i$ 表示到第 $i$ 个人的最小危险总和。

状态转移方程：
- 第一问，设 $f1_i$ 从 $f1_j$ 转移而来，显而易见的，状态转移方程为 $f1_i \leftarrow \min(f1_i,f1_{j-1}+1)$
- 第二问，设 $f2_i$ 从 $f2_j$ 转移过来，$cnt$ 为宗教的种类，状态转移方程为 $f2_i \leftarrow \min(f2_i,f2_{j-1}+cnt)$

为了求出 $cnt$ 的值，我们将 $j$ 从 $i$ 到 $1$ **倒序枚举**。如果 $cnt>k$ 则无解，跳出循环。


```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,n,m,k,a[1005],f1[1005],f2[1005];
bool vis[1005];
int main(){
    cin >> n >> m >> k;
    for(int i=1;i<=n;i++){
        cin >> a[i];
        f1[i]=f2[i]=2147483647;
    }
    for(int i=1;i<=n;i++){
        fill(vis+1,vis+m+1,0);
        cnt=0;
        for(int j=i;j>=1;j--){
            if(!vis[a[j]]){vis[a[j]]=1;cnt++;}
            if(cnt>k){break;}
            f1[i]=min(f1[i],f1[j-1]+1);
            f2[i]=min(f2[i],f2[j-1]+cnt);
        }
    }
    cout << f1[n] << endl << f2[n];
    return 0;
}
```

---

## 作者：tmp_get_zip_diff (赞：0)

首先第一问很好求，对于一个区间，如果往后面延伸一个位置危险值没有超过 $k$，那么往后延伸一个位置更优，于是我们模拟其过程即可。

接下来看第二问，由于 $n \le 1000$，可以猜测后面的时间复杂度是 $O(n^2)$，想到对于一个位置 $i$，往前枚举 $j$，满足 $[i,j]$ 的危险值没有超过 $k$，同时维护答案即可。

想到 dp，$dp_{i}$ 表示将 $1 \sim i$ 分区间危险值之和的最小值。

输出 $dp_n$。

根据上面的分析，枚举 $j$ 满足 $[i,j]$ 的危险值没有超过 $k$，$dp_i = \min\limits_{j}dp_{j-1}+dis(i,j)$，$dis(i,j)$ 代表危险值。

初始状态：$dp_0=0$，$dp_1=1$，其余正无穷。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 

const int N=1005;
int n,m,k,dp[N],a[N];
bool vis[25];

signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int num=1,ans=1;
	vis[a[1]]=true;
	for(int i=2;i<=n;i++)
		if(vis[a[i]]==false)
		{
			num++;
			if(num==k+1)
			{
				for(int j=1;j<=m;j++)
					vis[j]=false;
				ans++;
				num=1;
			}
			vis[a[i]]=true;
		}
	cout<<ans<<"\n";
	for(int i=1;i<=n;i++)
	    dp[i]=1e9;
	dp[1]=num=1;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			vis[j]=false;
		num=0;
		for(int j=i;j>=1;j--)
		{
			if(vis[a[j]]==false)
			{
				num++;
				vis[a[j]]=true;
			}
			if(num==k+1)
				break;
			dp[i]=min(dp[i],dp[j-1]+num);
		}
	}
	cout<<dp[n];
	return 0;
}
```

---

## 作者：DBL_MAX (赞：0)

本次只是更新，管理员大大求过！

[P2072 传送门](https://www.luogu.com.cn/problem/P2072)


## 思路
第一个问题可以用贪心解。

我们来看第一个问题（第二个问题还是要用 dp）：每组不同宗教信仰人数不超过 $k$。

看第 $j$ 个人我们可以发现：在他之前的人已经分好组。现在他有两种选择：
>1. 在前面的组还能容纳他的情况下加入前面一组。
>2. 自己新开一组。

如果他在加入前面一组，分组数量不会增加；而自己新开一组，反而可能**增加**从他开始后面的分组数，因此：只要能加入前面一组，就把他加到前面一组去。
## AC 代码
```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std; //定义命名空间
int n,m,k;  //定义变量
int num=1;  //定义变量
int arr[1003]; //定义数组
bool vis[1003]; //定义数组
int dp[1003]; //定义 dp 数组
set<int>area; //定义有序集合
int main()
{
    cin >> n >> m >> k; //输入
    for(int i=1;i<=n;i++) cin >> arr[i]; //输入
    for(int i=1;i<=n;i++)//统计
    {
        area.insert(arr[i]); //插入
        if((int)area.size()>k)  num++,area.clear(),area.insert(arr[i]);//判断
    }
    cout << num << endl; //输出
    for(int i=1;i<=n;i++) // 循环
    {
        memset(vis,0,m+1); //初始化
        num=0;
        dp[i]=100000000;//赋值
        for(int j=i;j;j--)//循环
        {
            if(!vis[arr[j]]) num++,vis[arr[j]]=1;//判断
            if(num>k) break; //判断
            dp[i]=min(dp[i],dp[j-1]+num); //赋值
        }
    }
    cout << dp[n];//输出
    return 0; //结束
}
```

---

## 作者：foryou_ (赞：0)

**求最值问题，考虑 dp。**

- 状态：令 $dp_i/f_i$ 表示以 $i$ 结尾的最少集体数 / 最小危险值。

- 初始：$dp_0=f_0=0$，其余 $\infty$。

- 答案：$dp_n,f_n$。

- 转移： 

$$
dp_i=\min(dp_j+1,dp_i),f_i=\min(f_j+cnt,f_i)$$

（$cnt$ 表示当前 $i \sim j$ 的宗教种类数，转移时顺便维护即可）

- 注意：$j$ 需要倒序 $i \to 1$ 枚举，因为正序枚举可能没到 $i$ 时 $cnt$ 就大于 $k$ 了，从而退出循环，没有实现转移。

- 代码：[here](https://www.luogu.com.cn/paste/8o6h6vit)。

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P2072)。

## 解题思路

设 $dp1_i$ 为前 $i$ 个教徒分的集体数量，在第 $i$ 个教徒处划分，上一段的边界为 $j - 1$，则 $dp1_i \gets dp1_{j - 1} + 1$，不划分则仍为 $dp_i$，两者取最小值，即 $dp1_i \gets \min( dp1_{j - 1} + 1 , dp1_i )$。

设 $dp2_i$ 为前 $i$ 个教徒的危险值，对于以 $i$ 为边界的段的宗教种类数为 $cnt$。在第 $i$ 个教徒处进行分的话，上一段的边界为 $j - 1$，则 $dp2_i \gets dp2_{j - 1} + cnt$，不分段则仍为 $dp2_i$，两者取最小值，即 $dp2_i \gets \min( dp2_{j - 1} + 1 , dp2_i )$。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define maxn 1005
using namespace std;
int n,m,k,a[maxn];
int dp1[maxn],dp2[maxn];
bool vis[maxn];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>k;
    for(int i=1;i<=n;++i)
        cin>>a[i];
    dp1[1]=dp2[1]=1;
    for(int i=1;i<=n;++i){
        dp1[i]=dp2[i]=inf;
        memset(vis,false,sizeof(vis));
        for(int j=i,cnt=0;j;--j){
            if(!vis[a[j]]){
                vis[a[j]]=true;
                if(++cnt>k)
                    break;
            }
            dp1[i]=min(dp1[i],dp1[j-1]+1);
            dp2[i]=min(dp2[i],dp2[j-1]+cnt);
        }
    }
    cout<<dp1[n]<<'\n'<<dp2[n];
    return 0;
}
```

---

## 作者：__Sky__Dream__ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P2072)
## 题目大意
有 $n$ 个人，每个人信一个宗教，划分若干段，使得危险总和最小且每一段的信不同宗教的人数不能超过 $k$。

定义危险总和为每一段的不同宗教的种类之和。

问：

1. 最少划分多少区域。

1. 危险总和最小是多少。

## 解题思路
第一问用贪心来做，从左向右尽量将每个人放在同一组，直到不得不新分组的时候才开新组。如果某个位置的人可以加入前组但是开了新组，那么可以调整该方案为将该人放入前组，则新方案也是合法方案，以此方式可以将任意方案调整为贪心方案。

第二问用动态规划，设 $s_k$ 是只考虑前 $k$ 个人的情况下的最小危险值的和，那么 $s_0=0$，考虑 $s_k$，可以按照第 $k$ 个人的分组情况来讨论，其可以单独成组，可以连同前面的个人成一组（在种类数不超过 $K$ 的情况下），所以有：
$$s_k = \min( s_{j-1} + \lvert a_{j:k} \rvert )$$

最后，可以用二进制节省空间。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1001,INF=1e9;
int n,m,k;
int s[N],a[N];
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    int sum=1,cnt=0,dp=0;
    for(int i=1;i<=n;i++)
    {
        if(dp>>a[i]&1) continue;
        if(cnt<k)
        {
            dp|=1<<a[i];
            cnt++;
        }
        else
        {
            dp=1<<a[i];
            cnt=1;
            sum++;
        }
    }
    memset(s,0x3f,sizeof s);
    s[0]=0;
    for(int i=1;i<=n;i++)
    {
        cnt=dp=0;
        for(int j=i;j;j--)
        {
            if(!(dp>>a[j]&1))
            {
                cnt++;
                dp|=1<<a[j];
            }
            if(cnt>k) break;
            s[i]=min(s[i],s[j-1]+cnt);
        }
    }
    printf("%d\n%d",sum,s[n]);
    return 0;
}
```
#### 欢迎大家在评论区指出错误！期待我们相约下一篇博客！

---

## 作者：Dream__Sky (赞：0)

设 $num_{i,j}$ 为区间 $[i,j]$ 中包含的宗教数量，可 $O(n^2)$ 预处理。

考虑 DP。

每次我们枚举右端点$i$，往前枚举合法的左端点 $j$，保证 $num_{i,j}\leq k$，只要当前区间合法，那么显然我们就可以从前面转移。

设 $f_i$ 为区间数量，$dp_i$ 为危险指数。则有：
$$f_i=\min(f_{j-1}+1),dp_i=\min(dp_{j-1}+num_{j,i})$$

由于 $num$ 的含义是闭区间，所以在转移时，需要从 $j-1$ 推过来。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int n,m,k,a[N],vis[N],num[N][N],dp1[N],dp2[N];
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	
	for(int i=1;i<=n;i++)
	{
		int cnt=0;
		memset(vis,0,sizeof vis);
		for(int j=i;j<=n;j++)
		{
			if(!vis[a[j]]) vis[a[j]]=1,cnt++;
			num[i][j]=cnt;
		}
	}

	memset(dp1,0x3f,sizeof dp1);
	memset(dp2,0x3f,sizeof dp2);
	dp1[1]=dp2[1]=1;
	dp1[0]=dp2[0]=0;
	for(int i=2;i<=n;i++)
	{
		for(int j=i;j>=1;j--)
		{
			if(num[j][i]>k) break;
			dp1[i]=min(dp1[i],dp1[j-1]+1);
			dp2[i]=min(dp2[i],dp2[j-1]+num[j][i]);
		}
	 } 
	 
	cout<<dp1[n]<<"\n"<<dp2[n];
	return 0;
}

```


---

## 作者：Robin_kool (赞：0)

感谢管理提醒。

动态规划题。

题目中给了两个小问，考虑将它们一起解决。~~经过简单的思考后~~，容易发现第一小问中每个集体的价值等同于 $1$，而第二小问的价值可以一边枚举一边计算。

考虑开两个数组 $dp1$，$dp2$ 分别记录两个小问，其中 $dp_i$ 表示前 $i$ 个人的最小价值。

注意倒序枚举断点，不然很难算出当前集体的危险值。

转移方程 $dp1_i\gets\min(dp1_i,dp1_{j-1}+1)$，$dp2_i\gets\min(dp2_i,dp2_{j-1}+sum)$，其中 $sum$ 为当前的价值。

最后的答案即为 $dp1_n$，$dp2_n$。

---

## 作者：jimmy916 (赞：0)

# P2072 宗教问题 题解

[题目传送门](https://www.luogu.com.cn/problem/P2072)

### 题目大意

已知一个地方有 $m$ 种宗教（编号为 $1,2,\cdots ,m$），有 $n$ 个教徒（编号为 $1,2,\cdots ,n$），每个教徒信且只信一种宗教。现在要按顺序把这 $n$ 个教徒分成一些集体，每个集体的危险值定义为这个集体中的宗教种数，且一个集体的宗教种类不能超过 $k$ 种，否则就会无限危险。

求：

- 这 $n$ 个教徒至少要分为几个集体；

- 这些集体的危险值总和至少为多少。

### 题目分析

偷看一下算法标签可得本题为一道**区间 dp** 题。

考虑模板

```cpp
for (int len = 2; len <= n; len++) {//先枚举区间长度
	for (int i = 1; i+len-1 <= n; i++) {//再枚举区间左端点，左端点加区间长度为右端点，不能大于n
		int j = i+len-1;	//区间右端点
		for (int k = i; k < j; k++) {	//枚举区间分割点
			dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[k+1][j]+合并区间的消耗);
		}
	}
}
```

然后看回本题，题目有两个问，考虑用两个 dp 解题。

首先第一个 dp 求这 $n$ 个教徒至少要分为几个集体。

$f1$ 数组开二维，则依据题目可得：

$$f1_{i,j}=\min(f1_{i,j},f1_{i,v} + 1)$$

其次第二个 dp 求这些集体的危险值总和至少为多少。

$f2$ 数组也开二维，则依据题目可得：

$$f2_{i,j}=\min(f2{i,j},f2{i,v}+u_{v+1,j})$$

### 代码

```cpp
#include <iostream>

using namespace std;

const int N = 10010, M = 21, MAX = 0x3f3f3f3f;
int a[N];
int u[N][N];
int f1[N][N],f2[N][N];
int n, m, k;
bool b[M];

int main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i ++ )
		cin >> a[i];
	for (int i = 1; i <= n; i ++ ) {
		int l = 0;
		for (int j = i; j <= n; j ++ ) {
			if (!b[a[j]])
				l++, b[a[j]] = true;
			u[i][j] = l, f1[i][j] = MAX, f2[i][j] = MAX;
		}
		for (int j = 1; j <= m; j ++ )
			b[j] = false;
		f1[i][i] = 1, f2[i][i] = 1;
	}
	for (int i = 1; i <= n - 1; i ++ )
		for (int j = i + 1; j <= n; j ++ ) {
			if(u[i][j] <= k)
				f2[i][j] = min(f2[i][j], u[i][j]), f1[i][j] = min(f1[i][j], 1);
			for (int v = i; v <= j; v ++ )
				if (u[v+1][j] <= k)
					f2[i][j] = min(f2[i][j], f2[i][v] + u[v + 1][j]), f1[i][j]=min(f1[i][j],f1[i][v] + 1);
		}
	cout << f1[1][n] << endl << f2[1][n] << endl;
	return 0;
}
```


[部分借鉴](https://www.luogu.com.cn/blog/lonelysir/solution-p2072)

---

## 作者：caohan (赞：0)

# 吐槽

~~二合一，出 题 人 真 棒~~

# 思路

明显考虑双动归，有 $f_i$ 和 $dp_i$ 分别表示两个问题的答案。

明显的 $f_i$ 可以从任何的 $f_{j-1}(1 \leq j \leq i)$ 在 $i$ 至 $j$ 中有小于 $k$ 种宗教时转移。

方程为 $f_i=f_{j-1}+1$ 因为多了一个团体。

同理的 $dp_i$ 也可以从同样的条件中转移。

方程为 $dp_i=dp_{j-1}+zongjiaoshu$ 因为会在增加了一个团体时增加该团体中宗教种数的危险度。

注意，因为要统计宗教数量，倒序的处理 $j$ 更方便。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100000];
int dp[100000];
int f[100000];
bool b[100000];
int n,m,k;
signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	f[1]=1;
	dp[1]=1; 
	for(int i=2;i<=n;i++)
	{
		dp[i]=2100000000;
		f[i]=2100000000;
		memset(b,0,sizeof(b));
		int num=0;
		for(int j=i;j>=1;j--)
		{
			if(!b[a[j]])
			{
				num++;
				b[a[j]]=1;
			}
			if(num>k)
			{
				break;
			}
			f[i]=min(f[i],f[j-1]+1);
			dp[i]=min(dp[i],dp[j-1]+num);
		}
	}
	cout<<f[n]<<"\n"<<dp[n];
	return 0;
}
```


---

## 作者：sccc_ (赞：0)

## 思路
对于这道题，我们考虑 dp。  

#### 定义状态：  
  $dp_i$ 表示前 $i$ 个元素的最少集体数。  
  $pd_i$ 表示前 $i$ 个元素的最小危险值。  

#### 初始化：
  由于求最小值，$dp$ 与 $pd$ 数组都要赋值为极大值。  
  注意，如果用 `memset`，记得把 $dp_0$ 与 $pd_0$ 都赋值为 $0$。  

#### 状态转移方程：
$dp_i$ 有两种选择：
- 不切开，不分段（区间内宗教种类未超过 $k$）。与上一状态相同。
- 切开，重新分一段。从上一个状态 $dp_{j - 1}$ 转移过来并加 $1$，因为又分了一段。

综上所述，$dp$ 的转移方程是：  $dp_i = \min(dp_i,dp_{j-1} + 1)$。  

$pd_i$ 也有两种选择：
- 不切开，不分段（区间内宗教种类未超过 $k$）。与上一状态相同。
- 切开，重新分一段。从上一个状态 $pd_{j-1}$ 转移过来并加上上一段段宗教的种类 $tot$。

综上所述，$pd$ 的转移方程是：  $pd_i = \min(pd_i,pd_{j-1} + tot)$。 

#### 答案：
输出 $dp_n$ 与 $pd_n$ 即可。  

## 代码
```c++
#include <bits/stdc++.h>
using namespace std;

int n, m, k;
int a[1005];
int dp[1005], pd[1005];
int cnt[1005];

signed main()
{
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
	memset (dp, 0x3f, sizeof dp);
	memset (pd, 0x3f, sizeof pd);	
	dp[0] = 0;
	pd[0] = 0;
	for (int i = 1; i <= n; i ++)
	{
		memset (cnt, 0, sizeof cnt);
		int tot = 0;
		for (int j = i; j >= 1; j --)
		{
			if (cnt[a[j]] == 0)
				cnt[a[j]] ++, tot ++;
			if (tot > k)
				break;
			dp[i] = min (dp[i], dp[j - 1] + 1);
			pd[i] = min (pd[i], pd[j - 1] + tot);
		}
	}
	cout << dp[n] << '\n' << pd[n];
	return 0;
}

```

---


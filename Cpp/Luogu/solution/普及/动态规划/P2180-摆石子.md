# 摆石子

## 题目背景

我们伟大的KK突然想到了一个很高（Shā）明（bī）的问题。


## 题目描述

我们伟大的KK在N条水平线与M条竖直线构成的网格中（KK的自创坐标系），放K枚石子，每个石子都只能放在网格的交叉点上。现在KK想知道在最优的摆放方式下，最多可以找到多少四边平行于坐标轴的长方形，而且KK要求它的四个角上都恰好放着一枚石子。


## 说明/提示

50%的数据    0<N，M≤30；

100%的数据   0<N，M≤30000  K≤N\*M。


## 样例 #1

### 输入

```
3 3 8```

### 输出

```
5```

# 题解

## 作者：彭天宇 (赞：12)

基础计数类、基础数学思维类好题。

一看这$n,m\le 30000$就不是$O(n^2)$的算法，又不像是$O(n)$的，怎么办？慢慢分析。

首先，如果面对下面一种情况（一个$o$对应一个石子）：

$oooo$

$oooo$

$ooo$

要再放一个石子进去，应该如何放？当然要补在缺口处。这样新放上去的石子就可以和9个位置的石子组成矩形，然而放在别的位置都不能。~~（证明略）~~

所以结论就是：将石子阵摆成接近矩形，只有一个缺口的时候最优。

一个矩形石子阵$(n\times m)$可以有多少不同矩形呢？

$$\sum_{i=1}^{n}\sum_{j=1}^{m}(i\times j)$$
就是说有两次求和个矩形右下角可以选择，每一个右下角有$i\times j$个左上角与之对应，这样就不重不漏了。

化简一下：
$$=\sum_{i=1}^{n}(i\times\sum_{j=1}^{m}j)$$
$$=\sum_{i=1}^{n}(\frac{i\times m \times(m+1)}{2})$$
$$=\frac{m(m+1)}{2}\sum_{i=1}^{n}i$$
$$=\frac{m(m+1)}{2} \times \frac{n(n+1)}{2}$$
好了，那就用类似二维前缀和的方法计算一个不是矩形的石子阵就好了。

注意$3\times 3$的石子阵长和宽都只能以$2$带入上面的式子，为什么？请审题。

最后要做的就是枚举不完全矩阵的长度，分别计算。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
	int maxn=0;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		if(k/i>=m)continue;
		int len=k/i;
		int mod=k%i;
		maxn=max(maxn,(i*(i-1)/2*len*(len-1)/2+(len+1)*len/2*mod*(mod-1)/2-(len*(len-1)/2*mod*(mod-1)/2)));
	}
	for(int i=1;i<=m;i++){
		if(k/i>=n)continue;
		int len=k/i;
		int mod=k%i;
		maxn=max(maxn,(i*(i-1)/2*len*(len-1)/2+(len+1)*len/2*mod*(mod-1)/2-(len*(len-1)/2*mod*(mod-1)/2))); 
	}
	cout<<maxn<<endl;
	return 0;
}
```

---

## 作者：phigy (赞：11)

~~这题其实是数学题，和动态规划没关系~~
## std:
```cpp
#include <iostream>

using namespace std;

int n,m,k;

int main()
{
    long long ans=0;\\不开longlong会爆掉的，而且必须清零
    int x,y;
    int i,j;
    cin>>n>>m>>k;
    if(n>m)swap(n,m);
    for(i=1;i<=k&&i<=n;i++)
    {
        if(k%i==0&&k/i>m)
        {
            continue;
        }
        if(k%i!=0&&k/i>m-1) 
        { 
            continue; 
        }
        x=k/i; 
        y=k%i; 
        ans=max(ans,(long long)x*(x-1)/2*i*(i-1)/2+y*(y-1)/2*x);\\更新答案
    }
    cout<<ans;
    return ^.^;\\圆满结束
}
```
~~反抄袭专用注释"\\"~~
### 感谢洛谷管理员仔细的审核

---

## 作者：Alarm5854 (赞：4)

推销一下我的博客：https://yce3216037.github.io/post/luo-gu-p2180-ti-jie/

作为我A掉的第777题，我自然要写一篇题解庆祝一下的。~~（我是不会告诉你我是因为再不写题解社区贡献分就要掉了才来写题解的）~~

有一篇题解是有说明的但是Markdown炸了且没有代码，另一篇有代码但是没有详细说明，我就来发这篇题解，来详（cu）细（lüe）地解释一下吧。

首先，要明确只有一行不为满的时候答案才可能为最大值，像这样：  
```
.......
...ooo.
.ooooo.
.ooooo.
.ooooo.
.......
```
显然要比
```
.......
..oooo.
..oooo.
.ooooo.
.ooooo.
.......
```
更优。  
所以，只需要枚举一下放的行数就可以了。  
那么，如何计算一个 $a\times b$ 的网格中，可以组成多少个矩形呢？显然，一行有 $a\times(a-1)/2$ 种选法，一列中有 $b\times(b-1)/2$ 种，所以有 $a\times b\times(a-1)\times(b-1)/4$ 种方案。假设剩余的一行有 $c$ 列，那么还要加上 $a\times c\times(c-1)/2$，这样，正解就出来了，答案 $ans=\max\limits _{i=1}^{\min(n,k)}(i\times \lfloor k/i\rfloor \times(i-1)\times(\lfloor k/i\rfloor-1)/4)$。  
最后，有一个非常坑的地方，就是当 $n>m$ 的时，$n$ 和 $m$ 要交换，否则只有 $90$ 分。
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
FILE *fin, *fout;
inline int read(ll &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(ll x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
ll n, m, k, ans;
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P2180.in", "rb");
	fout = fopen("P2180.out", "wb");
	#endif
	read(n, m, k); if (n > m) swap(n, m);//就是这个地方，非常坑！
	for (ll i = 1; i <= min(n, k); ++i) {
		ll x = k / i, y = k % i;
		if (!y && x > m) continue;
		if (y && x >= m) continue;
		ans = max(ans, i * x * (i - 1) * (x - 1) / 4 + x * y * (y - 1) / 2);
	}
	write(ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：2)

## 题意

在 $n \times m$ 的网格中放置 $k$ 颗石子，求有多少个四边形恰好四个角上都放了石子。

## 思路

### 解法一：暴力枚举

这一道题目看似简单，但是如果我们直接使用暴力枚举的方法来做，当 $N$ 和 $M$ 较大时，时间复杂度将会达到 $O(N^2 M^2 K)$，代码将会超时。

### 解法二：枚举长方形

一个长方形需要四个顶点的支持。考虑枚举这四个顶点，以左下角的点为例，如果左下角的点是 $(i, j)$，那么这个长方形的右上角就是 $(p, q)$，其中 $i≤p≤N$，$j≤q≤M$。枚举四个点的复杂度是 $O(N^2M^2)$，因此时间复杂度仍然达到了 $O(N^2M^2K)$，无法通过本题。

### 解法三：用前缀和优化枚举

我们可以先预处理出一个前缀和数组，以便我们在 $O(1)$ 时间内计算出石子数量。

设 $s_{i,j}$ 表示 $(1, 1)$ 到 $(i, j)$ 这个矩形内的所有石子数量的总和。

接下来，我们枚举这个长方形的左下角 $(i, j)$，并枚举右上角 $(p, q)$ 的位置。

如果 $(i, j)$ 和 $(p, q)$ 的行数或列数相等，则说明 $(i, j)$ 和 $(p, q)$ 已经在同一行或同一列上了，此时不能构成一个长方形。

因此我们只需要枚举左下角和右上角的位置，满足 $(i, j)$ 和 $(p, q)$ 的行数和列数不相等，然后用前缀和计算出 $(i, j)$ 和 $(p, q)$ 之间有多少个石子。

时间复杂度为 $O(N^2M^2)$。

### 解法四：用哈希表优化枚举

我们可以使用哈希表来存储每个矩形 $(i, j, p, q)$ 中石子的数量。枚举所有可能的矩形并用哈希表记录石子的数量。由于哈希表的查找是 $O(1)$ 的，因此总时间复杂度为 $O(N^2M^2)$。

------------
但是我们会悲催的发现，这复杂度都高到没边儿啊……

所以，请出我们的数学大神！
### 解法五：数学推导
首先可以证明，一个只有一个缺口的石子阵可以摆成接近矩形的形状，而且在这种情况下，放新的石子到缺口处可以让新石子和其他 $9$ 个位置的石子组成一个矩形，而在其它位置放新石子不能组成矩形。

接着可以推导出一个 $n \times m$ 的矩形石子阵有多少个不同的矩形。具体地，可以将每个矩形的右下角作为基准点，然后枚举左上角，这样每个右下角有 $i \times j$ 个左上角与之对应，从而有以下式子：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}(i \times j)$$

将其展开得到：

$$\sum_{i=1}^{n}(i \times \sum_{j=1}^{m}j)$$

继续展开，可以得到：

$$\sum_{i=1}^{n}(\frac{i \times m \times (m+1)}{2})$$

化简后得到：

$$\frac{m(m+1)}{2} \times \frac{n(n+1)}{2}$$

这个式子可以用类似二维前缀和的方法计算一个不是矩形的石子阵。

最后，枚举不完全矩阵的长度，分别计算即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,k,x=0,y=0,t,a,b;
int main() {
	n=read(),m=read(),k=read();
	if(!k){
		write(0);
		exit(0);
	}
	if(n<m) 
	  swap(n,m);
	a=(sqrt(k)>m?m:sqrt(k)),b=(k/a>n?n:k/a);
	for(;a>=2&&b<=n;--a,b=k/a){
		y=a*(a-1)*b*(b - 1) >> 2;
		t=k-a*b;
		if(t>1)
		  y+=(b<n?(t*(t-1)*b)>>1:(t*(t-1)*a)>>1);
		x=max(x,y);
	}
	write(x);
	return 0;
}
```
大家要自己推一遍哦，不要直接“盲目”的复制提交……

---

## 作者：slzxxjd (赞：2)

【题目分析】

在一个长宽分别为N、M的网格中放K枚石子，问你在放的石子中，最多能够组成多少个矩形。

【算法分析】

首先，我们先来分析一下在什么情况下摆放石子最优。显然k个点必定摆成以下两种情况可能最优（“.”表示省略）：

XXX...XXX

XXX...XXX

.
.
.
XXX...XXX

X..X
或者
XXX...XXXX

XXX...XXX.

.        .

.        X

.
XXX...XXX

所以只要枚举一行的个数（或者一列的个数）。

假设第一种情况除了最后一行每行都是i个，那么矩形的个数就是，第二种情况同理，不再细说。

【数据分析】

50%的数据，献给不懂标算，盲目暴搜的同学。

【算法总结】

模拟，贪心，组合数学。


---

## 作者：SunsetSamsara (赞：1)

## 前置知识
这题算一点点数学吧……
## 分析
首先，当一行没有满，其他都满时才能取到最大值。

接下来，如果对于 $n \times m$ 的石子长方形，
则答案是

$$\sum^n_{i=1} \sum^m_{j=1} ij$$

接下来要进行化简了：

$\sum^n_{i=1} \sum^m_{j=1} ij$

$=\sum^n_{i=1} (i\sum^m_{j=1}j)$

$=\sum^m_{j=1}j \sum^n_{i=1} i$

$=\dfrac{m\times(m + 1)}{2} \dfrac{n\times(n + 1)}{2} $

所以？枚举所有长和宽的情况，找到最后一行的长度，应用公式计算即可。

## 代码
```cpp
#include <bits/stdc++.h>
#define lld long long
using namespace std;
lld n, m, k;
int main() {
	scanf("%lld%lld%lld", &n, &m, &k);
	if (!k) {
		puts("0");
		return 0;
	}
	if (n < m) swap(n, m);
	int a = sqrt(k); if (a > m) a = m;
	int b = k / a; if (b > n) b = n;
	lld mx = 0, s;
	for (; a >= 2 && b <= n; -- a, b = k / a) {
		s = a * (a - 1) * b * (b - 1) >> 2;
		int t = k - a * b;
		if (t > 1) {
			if (b < n) s += (t * (t - 1) * b) >> 1;
			else s += (t * (t - 1) * a) >> 1;
		}
		mx = max(mx, s);
	}
	printf("%lld\n", mx);
}
```
## 后记
> 2021.12.5 更新：用户 [轻鸢流年吟](https://www.luogu.com.cn/user/394121) 更正了一点关于 long long 的错误，应为中间计算时会爆 long long。无论如何， 在当前做法中只使用 int 会在极限数据下爆 long long

---

## 作者：fish_love_cat (赞：1)

贪心加数学。

---

甲图：

```
石石石石石
石石石石石
石石石石石
石石石石石
石石石石石
石石石空空
```

乙图：

```
石石石石石
石石石石石
石石石石石
石石石石石
石石石石空
石石石石空
```

注意上面两幅图是 $5 \times 6$ 的，原先 $5 \times 5$ 的是错误的。

---

依题意得，甲图的摆法必然会比乙图的摆法更优，并且是最优的。

我们只需要枚举行数来枚举所有类似甲图摆法的局面。

推导后可知，每一个局面的答案都是 $i \times (i-1)\div 2 \times \left \lfloor   k \div i  \right \rfloor \times (\left \lfloor   k \div i \right \rfloor-1 ) \div 2+\left \lfloor   k \div i \right \rfloor\times (k \bmod i)\times(k \bmod i-1)\div 2$。

取最大值即可。

**代码：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){int n,m,k;cin>>n>>m>>k;
	if(n==1||m==1||k<=3)return puts("0")&0;
	if(n>m)swap(n,m);int maxx=0;
	for(int i=1;i<=n;i++){
		if(min(k%i,1ll)+k/i>m)continue;
		maxx=max(maxx,((i*(i-1)/2)*((k/i)*(k/i-1)/2))+((k/i)*(k%i)*(k%i-1)/2));
	}
	cout<<maxx;
    return 0;
}
```

---

更改于 2024 年 7 月 3 日：

图写挂了感谢评论区，以前我甚至被提醒了还没发现，我是傻逼，对不起。

---

## 作者：_AKIOI_ (赞：1)

## 题目：
[题目传送门](https://www.luogu.com.cn/problem/P2180)。
## 思路分析
先悄悄地瞧瞧数据范围， $ n , m $（$ {1 \le n , m \le 30000} $）。嗯，不是大模拟，放心了。

如果给你一个$ n * m $ 的长方形，怎么数个数？

应该是小学奥数题吧。

一种边长能从 1 取到 $ n $ ， 另一种边长能从 1 取到 $ m $ 。


有 $ \sum\limits_{i=1}^n\sum\limits_{j=1}^m i * j $

记答案为 $\operatorname{sum}(n,m)$

化简得

$\operatorname{sum}(n,m)=\frac{n(n+1) \times m(m+1)}{4}$

之后就贪心地枚举摆满几列，多余的额外放。

## 代码
```cpp
#include <stdio.h>

#define max( a , b ) ( a > b ? a : b )

#define int long long

int n , m , k ;

#define QAQ 0

signed main( void )
{
	scanf ( "%lld %lld %lld" , &n , &m , &k ) ;
	if ( n == 1 || m == 1 || k < 4 ) return printf ( "0" ) & 0 ;
	if ( n > m ) n ^= m ^= n ^= m ;//反正答案和行列顺序无关，为了方便后续计算，采用了交换 n , m
	
	int _ = 0 ;
	for ( int i = 1 ; i <= n ; i++ )
	{
		if ( ( k % i == 0 && k / i > m ) || ( k % i != 0 && k / i > m - 1 ) ) continue;//如果不能放 i 行
		int __ = k / i ;
		int ___ = k % i ;
		_ = max ( _ , __ * ( __ - 1 ) / 2 * i * ( i - 1 ) / 2 + ___ * ( ___ -1 ) / 2 * __ ) ;
	}
	
	printf ( "%lld" , _ ) ;
    return QAQ ;
}
```

---

## 作者：bluewindde (赞：0)

考虑如果一个宽为 $w$，高为 $h$ 列的长方形内摆满了石子，满足题意的长方形数量应当为

$$\dfrac{wh(w-1)(h-1)}{4}$$

原因：考虑组合计数，先选择一个点 $A$，再选择与 $A$ 在相同行的点 $B$、与 $A$ 在相同列的点 $C$，即可唯一确定一个长方形。$A$ 有 $wh$ 种选择，$B$ 有 $w - 1$ 种选择，$C$ 有 $h - 1$ 种选择，但一个长方形会被重复计算四次（请读者自行思考为什么），所以总数要除以 $4$。

为了方便，假设 $n \le m$。

$k$ 枚石子一定是尽量摆成一个大长方形，且只有一行不摆满的时候答案为最大值。

容斥计数，先统计大长方形，加上未摆满的与原先的石子的贡献，最后减去重复计算的长方形，即为答案。

```cpp
#include <iostream>

#define int long long

using namespace std;

int n, m, k;

static inline int calc(int w, int h) {
    return w * h * (w - 1) * (h - 1) / 4;
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("D:/wangyile/P2180.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> k;
    if (n > m) {
        swap(n, m);
    }
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        int x = k / i;
        int las = k % i;
        if (!las && x > m) {
            continue;
        }
        if (las && x >= m) {
            continue;
        }
        ans = max(ans, calc(i, x) + calc(las, x + 1) - calc(las, x));
    }
    cout << ans << endl;
    return 0;
}
```

---


# HXY和序列

## 题目描述

HXY 突发奇想，她想要找到一个正整数序列，满足序列中所有的数不超过 $n$，序列长度为 $p$，且除了第一个数外，所有的数都能被前一个数整除（即是前一个数的倍数）。很快她找到了一个这样的序列。可是她觉得还不够，想要知道这样的序列有多少个，可她被惊人的数据范围吓怕了。现在她找到了你，请你来帮助她解决这个问题。（因为结果可能会很大，请输出对 $10^9+7$ 取模后的值）


## 说明/提示

数据范围：

对于 $10\%$ 的数据，$p=1$；

对于 $30\%$ 的数据，$1 \leq n,p \leq 10$；

对于 $60\%$ 的数据，$1 \leq n,p \leq 5 \times 10^2$；

对于 $100\%$ 的数据，$1 \leq n,p \leq 2 \times 10^3$。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
5
```

## 样例 #2

### 输入

```
6 4
```

### 输出

```
39
```

# 题解

## 作者：Cripple_Abyss (赞：35)

# [题目传送门](https://www.luogu.com.cn/problem/P2193)

###### 本题其实是一道基本的**DP**题，~~十分适合一些新手~~
 

## DP三步法：

1. 设计状态：
	
    用 $f_{i\ j}$来表示符合条件的长度为 $i$ ，最后一个数为 $j$ 的序列个数

2. 推状态转移方程：
```cpp
   f[i][j*k]=(f[i][j*k]+f[i-1][j])%mod
```

3. 设定初值：
```cpp
   f[1][i]=1 
```



## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,f[2005][2005],ans;
int main() {
	cin>>n>>m;
	for (int i=1; i<=n; i++)
		f[1][i]=1;
	for (int i=2; i<=m; i++)
		for (int j=1; j<=n; j++)
			for (int k=1; k<=n/j; k++) 
				f[i][j*k]=(f[i][j*k]+f[i-1][j])%mod;
	for (int i=1; i<=n; i++) 
		ans=(ans+f[m][i])%mod;
	cout<<ans;
	return 0;
}
```


都看到这里了，点个赞呗QwQ

---

## 作者：registerGen (赞：11)

[更好的阅读体验](https://registergen.github.io/post/solution-luogu-p2193/)

题目链接：[here](https://www.luogu.com.cn/problem/P2193)

入门 DP 题。

# 解法

## 状态设计

首先，这是一个序列问题，所以我们的状态有一个是填到了第几个数，这个状态记为 $i$，则 $1\le i\le p$。（这是套路）

然后，由于这个序列的每一个数都要由上一个数是什么来决定，所以我们的另一个状态是，上一个数是什么，这个状态记为 $j$，则 $1\le j\le n$。

## 转移方程

转移方程有两种形式，“我为人人”（当前状态 $\to$ 下一个状态）和“人人为我”（上一个状态 $\to$ 当前状态）。这里我们选择第一维用“人人为我”第二维用“我为人人”，这样方便一些。

根据状态定义，可以得出转移方程：

$$f_{i,j\cdot k}=\left(\sum f_{i-1,j}\right)\bmod (10^9+7),2\le i\le p,1\le j\le n,1\le k\le \dfrac{n}{j}$$

（序列的第 $i$ 项填 $jk$ 的方案数可由 $(\sum$ 第 $i-1$ 项填 $j$ 的方案数$)$ 求得）

答案为

$$\sum _{i=1}^n f_{p,i}\bmod (10^9+7)$$

（最后一个数是 $i$ 的方案数的和）

## 初始化

转移方程转移不到的地方就是要初始化的地方，即 $i=1$ 的情况。

根据状态定义，可得

$$f_{1,i}=1,1\le i\le n$$

# 代码

```cpp
#include<cstdio>
#include<algorithm>

const int N=2000;
const int P=1e9+7;

// f[i][j]: 选了 i 个数，最后一个为 j
int n,p,f[N+10][N+10];

int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
		f[1][i]=1;
	for(int i=2;i<=p;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n/j;k++)
				f[i][j*k]=(f[i][j*k]+f[i-1][j])%P;
	int ans=0;
	for(int i=1;i<=n;i++)
		ans=(ans+f[p][i])%P;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：caozy623 (赞：6)

应该一眼就能看出是DP……主要难在状态的设计上。题目中给的是不超过n，长度为p。然后会不会有人考虑以这两个参数设为两维来搞？这样状态难以转移。实际上，注意到题目中所说的：“所有的数都能被前一个数整除”。我们这样考虑：设f[i][j]为选了前i个数（即长度为i），最后一个数是j的方案数。状态转移方程为： f[i][j]=sum{f[i-1][j div k]}(k|j)其中 k | j表示k整除j。边界f[1][i]=1(1<=i<=n)，最后输出ans=sum{f[p][i]}(1<=i<=n)即可。最后别忘了取模。

  
```cpp
#include<iostream>  
#include<cstring>  
#include<cstdio>  
#include<algorithm>  
#include<vector>  
#include<string>  
#include<set>  
#include<queue>  
#include<stack>  
#include<map>  
#include<cmath>  
#include<cstdlib>  
#define ll long long  
#define maxn 100010  
#define inf 1000000000  
#define linf (1LL<<50)  
#define hzy 1000000007  
using namespace std;  
#define REP( i, n ) for ( int i = 1; i <= n; i ++ )  
#define REP_0( i, n ) for ( int i = 0; i < n; i ++ )  
#define REP_0N( i, n ) for ( int i = 0; i <= n; i ++ )  
#define REP_S( i, ss ) for ( char *i = ss; *i; i ++ )  
#define REP_G( i, u ) for ( int i = pos[ u ]; i; i = g[ i ].frt )  
#define FOR( i, a, b ) for ( int i = a; i <= b; i ++ )  
#define DWN( i, a, b ) for ( int i = b; i >= a; i -- )  
#define RST( a ) memset ( a, 0, sizeof ( a ) )  
#define CLR( a, x ) memset ( a, x, sizeof ( a ) )  
#define CPY( a, b ) memcpy ( a, b, sizeof ( a ) )  
inline ll read()  
{  
    ll x=0,f=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){x*=10;x+=ch-'0';ch=getchar();}  
    return x*f;  
}  
inline void read(char *s,int &ts)  
{  
    char x=getchar();  
    while(!(x>='a'&&x<='z'))x=getchar();  
    while(x>='a'&&x<='z')s[++ts]=x,x=getchar();  
}  
int n,ans,p;  
int f[2010][2010];  
int main()  
{  
    scanf("%d%d",&n,&p);  
    for(int i=1;i<=n;i++)  
    f[1][i]=1;  
    for(int i=2;i<=p;i++)  
    for(int j=1;j<=n;j++)  
    {  
        int m=n/j;  
        for(int k=1;k<=m;k++)  
        {  
            f[i][j*k]+=f[i-1][j];  
            f[i][j*k]%=hzy;  
        }  
    }  
    for(int i=1;i<=n;i++)  
    {  
        ans+=f[p][i];  
        ans%=hzy;  
    }  
    printf("%d\n",ans);  
    return 0;  
}  

```

---

## 作者：King丨帝御威 (赞：4)

通过数据范围和题面应该不难想到要用DP，难点在于怎么DP，应该采取怎样的策略，我们考虑用f[i][j]表示已经选了i个数，且最后一个数为j的方案数，那么显然，对于所有的i从1——n，f[1][i]=1，因为只有一个数嘛！

然后第二种情况，就是i>1的时候，用一个j变量从1枚举到n，然后看看n里面最多有几个j，暂且把它设为zrj，然后从1到zrj枚举一个k，因为后面的必须是前面的倍数(除第一个数外)，所有就有f[i][j*k]+=f[i-1][j]。最后把所有的p个数和为i的方案数都加起来即为答案。

大家可以借鉴我的代码(思路掌握了最好还是自己写)：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#define maxn 2001
#define ll long long
#define mod 1000000007
using namespace std;
inline ll qread()                //快读。
{
	char c=getchar();ll num=0,f=1;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) num=num*10+c-'0';
	return num*f;
}
ll n,p,ans,f[maxn][maxn];
int main()
{
	n=qread(),p=qread();
	for(int i=1;i<=n;++i) f[1][i]=1;
	for(int i=2;i<=p;++i)
	{
		for(int j=1;j<=n;++j)
		{
			int zrj=n/j;  
        	for(int k=1;k<=zrj;++k)  
        	{   
				f[i][j*k]+=f[i-1][j];
				f[i][j*k]%=mod;     //每一次转移都取模，避免加的数太大爆long long。
        	}  	
		}
	}
	for(int i=1;i<=n;++i)
	{
		ans+=f[p][i];               //累加答案。
		ans%=mod;
	}
	cout<<ans<<'\n';
	return 0;
}
```

希望这篇题解可以对初学DP的OIer有所帮助！

---

## 作者：linyinuo2008 (赞：3)

[原题链接](https://www.luogu.com.cn/problem/P2193)

这道题可以算一道 $ \text{DP} $ 的典型题，我们来看一看。

这道题显然是以这个数字序列的长度为基础进行 $\text{DP}$ 的， 但是这还不够。因为如果我们单纯的开一维记录长度的话，我们就无法实现这个要求。

> 第一个数外，所有的数都能被前一个数整除（即是前一个数的倍数）

所以此时我们需要进行升维 $\text{DP}$ 。我们多开一维记录序列中最后一个数，又因为最后一个数一定不会超过 $n$ ，所以空间不会爆。

此时再想一下，我们对于每一个长度的序列，我们必定只能从前一位转移，因为咱们需要每次添加一个数。为了满足题设条件，我们每枚举到一个状态，不对其前面状态进行操作，而是把它能够转移到的状态加上。

我们设 $f(i,j)$ 表示序列长度为 $i$ ，且最后一个数是 $j$ 的方法种数。则我们从后往前加，得
$$f(i,j \times k)+=f(i-1,j)$$

其中 $j \times k \leq n$。

这里就是说，如果最后一个数是 $j \times k$ 的话，那我们可以在长度为 $i-1$ 最后一个数为 $j$ 的序列，后面加上一个 $j \times k$ ，这样的话方法种数就应当加上 $f(i-1,j)$ 。

枚举顺序很自然，第一层枚举位数 $i$ ，第二层枚举上一位数字 $j$ ，第三层枚举 $k$ 。

初始值： $f(1,1-n)=1$

结果： $\sum_{i=1}^{n}f(p,i)$

**温馨提示：别忘了取模！**

话不多说，上代码（有注释）：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int PR=1e9+7;//模数
const int NR=2005;
int n,p,f[NR][NR];//f[i][j]表示有i个数的序列中最后一个数为j的种数 
int main()
{
	cin>>n>>p;
	for(int i=1;i<=n;i++) f[1][i]=1;//初始化
	for(int i=1;i<=p;i++)//最外层枚举位数
		for(int j=1;j<=n;j++)//枚举上一位数
			for(int k=1;j*k<=n;k++) 
			{
				f[i][j*k]=(f[i][j*k]+f[i-1][j])%PR;//转移+取模
			}
	int ans=0;
	for(int i=1;i<=n;i++)//求和
		ans=(ans+f[p][i])%PR;//时刻记住要取模
	cout<<ans;
	return 0; 
} 
```

**若有错误，欢迎指出！**



---

## 作者：Citnaris (赞：2)

# P2193 HXY和序列 

**分析**

本题正解为 $\texttt{DP}$。

我们首先设置一个状态 $F[i][j]$ ，表示前 $i$ 个数，结尾为 $j$ 的序列个数模 $1000000007$ 的结果。

该状态的初值是
$$f[1][i]=1(i\in \left [ 1,n \right ]) $$

该状态的转移方程是
$$f[i][j\times k]=(f[i][j\times k]+f[i-1][j])\%1000000007$$

该题的答案是

$$\sum_{i=1}^{n}  f[p][i]$$

**Code**
```cpp
#include <cstdio>

const int MOD=1000000007;
int n, p, res;
int f[2000][2000];

int main()
{
    scanf("%d%d", &n, &p);
    for(int i = 0; i <= 2000; i++)
        f[1][i] = 1;
    for(int i = 2; i <= p; i++)
        for(int j = 1; j <= n; j++)
            for(int x =1; x * j <= n; x++)
                f[i][j * x] = (f[i][j * x] + f[i - 1][j]) % MOD;
    for(int i = 1;i <= n; i++)
        res = (res + f[p][i]) % MOD;
    printf("%d", res);
    return 0;
}
```



---

## 作者：Guitar_Jasmine (赞：2)

看到没有写记搜的，~~赶紧水一波~~，给初学者另一种思路
- 
- 设f[x][k]表示以x结尾长度为k的序列有多少种可能结果
- 状态转移方程就很显然：
- f[x][k]=∑f[i][k-1]（其中i为x的因子）
- 注意这道题只要求后一个数是前一个数的倍数（这就说明1倍也是可以哒，也就是说序列中前一个数可以等于后一个数）
- 最后累加答案，根据状态设定显然ans=∑f[i][p] (i=1~n)
- 不要忘了取模（~~我才不会告诉你们我第一次模数少去了一个0~~）

- 上代码，细节可以看注释

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

typedef long long LL;
const int M=1000000007;
int n,p;
LL f[2009][2009];

int dfs(int x,int k)
{
	if(f[x][k]!=-1)//若已经访问过则直接返回结果
		return f[x][k];
	if(k==1)
		return f[x][k]=1;//若k=1则说明到序列第一个数，返回贡献1
	f[x][k]=0;
	for (int i=1;i*i<=x;i++)
	{
		if(x%i!=0)
			continue;
		f[x][k]=(f[x][k]+dfs(i,k-1))%M;
		if(i*i!=x)//若i和x/i不相等（保证不重复累加）
			f[x][k]=(f[x][k]+dfs(x/i,k-1))%M;
	}
	return f[x][k];
}

void init()
{
	scanf("%d %d",&n,&p);
}

void work()
{
	memset(f,-1,sizeof(f));
	LL ans=0;
	for (int i=1;i<=n;i++)
		ans=(ans+dfs(i,p))%M;//最后累加答案就好啦
	printf("%lld\n",ans);
}

int main()
{
	init();
	work();
	return 0;
}

```
~~蒟蒻的第一篇题解，dalao勿喷QWQ~~

---

## 作者：wisdom_grass (赞：2)

设$f[i][j]$是长度为$i$，第一个数为$j$的状态中满足条件的序列有几个

如果这样设，我们发现，在$f[i][j]$第一个数为$j$时，下一个数可能是

$j * 1\ j * 2\ j * 3$ ...... 


所以 可以知道，$f[i][j] = f[i-1][j] + f[i-1][j*2] + ......$

具体细节请看代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 2007;
const int mod = 1000000007;
int n, p;
int f[maxn][maxn];

void dp() { // 事实上我编程序时没注意到自己的程序其实和题意不一样， 是“除最后一个数外，其余数都是后一个数的倍数”，但是这样对答案没有影响。大家可以想一想这是为什么
	for(int i = 2; i <= p; i++) //i=1的情况已经初始化完毕
		for(int j = 1; j <= n; j++)
			for(int k = j; k <= n; k += j) {
				f[i][j] += f[i - 1][k];
				f[i][j] %= mod;
			}
}
int main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	cin >> n >> p;
	for(int i = 1; i <= n; i++)
		f[1][i] = 1; // 长度为1的序列， 第一个数是i， 情况只能有一种
		
	dp();
	
	int ans = 0;
	for(int i = 1; i <= n; i++) {
		ans += f[p][i]; //长度为p的数列中以每个i为开头的数都是答案的一部分
		ans %= mod; //每步取模
	}
	cout << ans;	
	return 0;
}

```

---

## 作者：GKxx (赞：2)

~~如果你熟悉数位dp，就能秒切这题了~~

典型的数位dp的套路，f[i][j]表示填到第i位，第i位填的是j的合法方案数。

依题意，下一位填的数是j的倍数，所以枚举j的几倍，可以转移到f[i+1][j*k]

就这么简单

```cpp
#include <cstdio>
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
const int mod = 1e9 + 7, maxn = 2001;
int f[maxn][maxn], n, p;
inline int solve() {
    rep(i, 1, n) f[1][i] = 1;
    rep(i, 1, p - 1) rep(j, 1, n) rep(k, 1, n / j)
    	(f[i + 1][j * k] += f[i][j]) %= mod;
    int ans = 0;
    rep(i, 1, n) ans = (ans + f[p][i]) % mod;
    return ans;
}
int main() {
    scanf("%d%d", &n, &p);
    printf("%d\n", solve());
    return 0;
}
```

---


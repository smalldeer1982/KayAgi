# [SCOI2005] 扫雷

## 题目描述


相信大家都玩过扫雷的游戏。那是在一个 $n\times m$ 的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和它 $8$ 连通的格子里面雷的数目。现在棋盘是 $n\times 2$ 的，第一列里面某些格子是雷，而第二列没有雷，如下图：

![](https://cdn.luogu.com.cn/upload/pic/17825.png )

由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。



## 样例 #1

### 输入

```
2
1  1```

### 输出

```
2```

# 题解

## 作者：王珩030115 (赞：249)

楼下的同志们好；努力写dp的同志们辛苦了！！

其实只要第一个点确定了；后面全都确定；

所以只要令b【1】=1 扫一遍；再令b【1】=0；扫一遍

所以答案只可能是0 1 2 ；

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,k,m,n,ans=2,a[10001],b[10001];
void checkx()
{
    for(int i=2;i<=n+1;i++)
    {
    b[i]=a[i-1]-b[i-1]-b[i-2];
    if (!(b[i]==1||b[i]==0))
          {
          ans--;
          break;
          }
          if (i==n+1&&b[i]!=0)
                {
                 ans--;
                 break;
             }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    b[0]=0;
    for (i=1;i<=n;i++)    
    cin>>a[i];
    b[1]=1;
    checkx();
    b[1]=0;
     checkx();
    cout<<ans;   
return 0;    
}
```

---

## 作者：Lidy (赞：103)

思路: 
深搜的思想。
从第一个位置开始搜，用一个数组a左边那一排的某个位置表示有无雷，
再用b数组存储右边那一排的某个位置的八连通点的权值和（即输入的数据） 
搜索开始：从第一个位置，分别用a[i]等于0（即无雷）或1（即有雷）去搜。
结束条件：当把每一个位置都搜过了之后，再判断当前搜出的这种方案是否可行，然后return结束即可。 

```cpp
//程序:
#include<iostream>
using namespace std;
int a[10005],b[10005];
int n,ans;
int pd(int x)
{
	if(a[x-1]+a[x]+a[x+1]==b[x])return 1;
	//题目中说是八连通方向，由于题目边界局限性，直接把八连通点中的三个加起来判断。 
	return 0;
}
void dfs(int k)
{
	if(k==n+1){if(pd(n))ans++;return ;} 
	//搜索结束条件，如果直到最后一个判断都符合条件，说明方案是可行的故ans++； 
	a[k]=1;if(k==1||pd(k-1))dfs(k+1);
	//假设这个格子有雷，且判断无误（优化，边搜边判断），继续搜索下一个格子 
	a[k]=0;if(k==1||pd(k-1))dfs(k+1);
	//假设这个格子无雷，且判断无误（优化，边搜边判断），继续搜索下一个格子 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>b[i];
	dfs(1);
	cout<<ans<<endl;
}
```

---

## 作者：aiyougege (赞：48)

### 做法:

题解区大家都是八仙过海.

我想了一种比较恶心但是能过的方法.比题解区某些做法要好一点点.


首先需要分析一下这个题目,经过一番脑洞之后发现答案必定 大于0小于等于2 根据这个原理我们就可以大力模拟或者是搜索.

当然也可以 dp .**万物皆可dp**


然后这个做法就是 dp 做法.

$
f[i][j][k]$表示当前位置为 i ,当前位置是不是雷(用j表示),下一位置需不需要是雷(k)的方案数.

转移就根据上一位置的选择.

```cpp
#include<iostream>
#include<cstdio>
#define N 10005
using namespace std;

void read(int &s){
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(s=0;isdigit(ch);s=s*10+ch-'0',ch=getchar());
}

int n;
int g[N];
int f[N][2][2];

int main(){
    read(n);
    for(int i=1;i<=n;++i)read(g[i]);
    f[0][0][0]=f[0][0][1]=1;
    for(int i=1;i<=n;++i){
        if(g[i]==0){
            f[i][0][0]+=f[i-1][0][0];
        }
        if(g[i]==1){
            f[i][0][0]+=f[i-1][1][0];
            f[i][1][0]+=f[i-1][0][1];
            f[i][0][1]+=f[i-1][0][0];
        }
        if(g[i]==2){
            f[i][1][1]+=f[i-1][0][1];
            f[i][0][1]+=f[i-1][1][0];
            f[i][1][0]+=f[i-1][1][1];
        }
        if(g[i]==3)
            f[i][1][1]+=f[i-1][1][1];
    }
    printf("%d",f[n][0][0]+f[n][1][0]);
    return 0;
}
```

---

## 作者：AFO_07 (赞：37)

# 一道很奇妙的题
~~其实是我太弱~~，一看直接暴搜。

------------
## 思路
一道dfs+剪枝。直接暴搜，每搜一格判断上格可不可以，可以达到剪枝效果，时间复杂度快很多。如果不加剪枝会 _TLE_。

------------
## 时间复杂度
如果直接跑，跑到n+1时才判断，会有很多次跑到其实没有意义，会TLE九个点。

------------
## 剪枝（优化时间复杂度）
那么怎么剪枝才是重点。因为此时已经跑到x，不会影响前面所以可以跑到x时可以判断a[x-2]是否可行，注意x>=4,不然会判错。另外用加法判断和比最后用for判会快很多。

------------
```cpp
if(flag[x-3]+flag[x-2]+flag[x-1]!=a[x-2]&&x-3>=1) return;
```
------------
## 附上AC代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[10001],flag[10001],p,k,ans;
void dfs(int x)
{
	if(flag[x-3]+flag[x-2]+flag[x-1]!=a[x-2]&&x-3>=1) return;//剪枝，跑到x时可以判断a[x-2]是否可行
	if(x==n+1)//当dfs跑完判断方案是否可行 
	{	
		if(flag[n-1]+flag[n]==a[n])	ans++;//用加法判断和的大小
		return;
	}
	if((a[x]==1&&flag[x-1]!=1)||a[x]==2||a[x]==3)//当a[x]==0和a[x]==1但x-1是雷时是不能走的
	{
		flag[x]=1;
		dfs(x+1);
		flag[x]=0;
	}
	if(a[x]==0||a[x]==1||(a[x]==2&&flag[x-1]==1))//当a[x]==2但x-1不是雷不能走
	dfs(x+1);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	dfs(1);
	cout<<ans;
}
```
------------
## 完结撒花
~~本蒟蒻第一次写题解，大家点个赞呗~~。

---

## 作者：Dispwnl (赞：17)

//看到一个NOI大佬的题解，觉得思路特别好，又清晰，于是整理一下思路

用四维数组f储存

一维第二列位置，二维三维四维存i-1，i，i+1是否有雷

初始化：f[0][0][0][0]=f[0][0][0][1]=1;

如果a[i]为0

```cpp
f[i][0][0][0]=f[i-1][0][0][0]+f[i-1][1][0][0];
f[i][1][0][0]=f[i-1][0][1][0]+f[i-1][1][1][0];
f[i][0][1][0]=f[i-1][0][0][1]+f[i-1][1][0][1];
f[i][0][0][1]=f[i-1][0][0][0]+f[i-1][1][0][0];
```
如果为2
f[i][1][1][0]=f[i-1][0][1][1]+f[i-1][1][1][1];

f[i][1][0][1]=f[i-1][0][1][0]+f[i-1][1][1][0];

f[i][0][1][1]=f[i-1][0][0][1]+f[i-1][1][0][1];

如果为3

f[i][1][1][1]=f[i-1][0][1][1]+f[i-1][1][1][1];

然后如果a[n]=1

ans=f[n][1][0][0]+f[n][0][1][0];

因为n+1就没有了

所以肯定四维为0

如果a[n]=2

ans=f[n][1][1][0];

如果a[n]=3

肯定无解

如果a[n]=0



ans=f[n][0][0][0]

输出ans

```cpp
# include<iostream>
using namespace std;
int n,tot;
int a[10001];
int f[10001][2][2][2];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    f[0][0][0][0]=f[0][0][0][1]=1;
    for(int i=1;i<=n;i++)
      {
          if(!a[i]) f[i][0][0][0]=f[i-1][0][0][0]+f[i-1][1][0][0];
          if(a[i]==1)
          {
              f[i][1][0][0]=f[i-1][0][1][0]+f[i-1][1][1][0];
              f[i][0][1][0]=f[i-1][0][0][1]+f[i-1][1][0][1];
              f[i][0][0][1]=f[i-1][0][0][0]+f[i-1][1][0][0];
        }
        if(a[i]==2)
        {
            f[i][1][1][0]=f[i-1][0][1][1]+f[i-1][1][1][1];
            f[i][1][0][1]=f[i-1][0][1][0]+f[i-1][1][1][0];
            f[i][0][1][1]=f[i-1][0][0][1]+f[i-1][1][0][1];
        }
        if(a[i]==3) f[i][1][1][1]=f[i-1][0][1][1]+f[i-1][1][1][1];
      }
    if(!a[n]) tot=f[n][0][0][0];
    if(a[n]==1) tot=f[n][1][0][0]+f[n][0][1][0];
    if(a[n]==2) tot=f[n][1][1][0];
    cout<<tot;
    return 0;
}

```

---

## 作者：momo5440 (赞：9)

这道题根据我的老师的思路是定义一个三维数组dp[i][j][k]来做动态规划，其中j表示第i行的地雷数，k表示第i+1行的地雷数，而dp[i][j][k]代表当前的组数。初始条件为dp[0][0][0]=dp[0][0][1]=1，即第1行为0个或为1个时都有一种可能。然后根据第i行给的ai来进行动态转移。
1.	若ai==0，则i-1，i，i+1必须分别对应 0，0，0，所以这种情况下转移方程：
dp[i][0][0]=dp[i-1][0][0]。
2.	若ai==3，则i-1，i，i+1必须分别对应 1,1,1所以这种情况下转移方程
dp[i][1][1]=dp[i-1][1][1]。
3.	若ai==1，则分为三种情况

i-1					i			i+1			动转方程

1					0			0			dp[i][0][0]=dp[i-1][1][0]

0					1			0			dp[i][1][0]=dp[i-1][0][1]

0					0			1			dp[i][0][1]=dp[i-1][0][0]

4． 若ai==2，也是三种情况

i-1					i			i+1			动转方程

1					1			0			dp[i][1][0]=dp[i-1][1][1]

0					1			1			dp[i][1][1]=dp[i-1][0][1]

1					0			1			dp[i][0][1]=dp[i-1][1][0]

记得开全局变量因为这样不合法的转移就全部是0了。
在最后输出的答案为dp[n][1][0]+dp[n][0][0]，这是第n行有地雷或无地雷的数量的总和（n+1不能取）。
大概就是这样详情请见代码,我觉得挺简洁的。
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;
int n,a[10005];
int dp[10005][2][2];
int main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];//读入数据
	dp[0][0][0]=dp[0][0][1]=1;//初始化
	for (int i=1;i<=n;i++){//状态转移
		if (a[i]==0){
			dp[i][0][0]=dp[i-1][0][0];
		}
		if (a[i]==3){
			dp[i][1][1]=dp[i-1][1][1];
	 	}
	 	if (a[i]==2){
	 		dp[i][1][1]=dp[i-1][0][1];
	 		dp[i][1][0]=dp[i-1][1][1];
	 		dp[i][0][1]=dp[i-1][1][0];
		 }
		 if (a[i]==1){
		 	dp[i][0][1]=dp[i-1][0][0];
	 		dp[i][1][0]=dp[i-1][0][1];
	 		dp[i][0][0]=dp[i-1][1][0];
		 }
	}
	cout<<dp[n][1][0]+dp[n][0][0];
}
```


---

## 作者：k2saki (赞：8)

这道题其实是一道普通的递推题

如果第一个位置的确定了，那么整列就确定了

所以，这道题答案只能为$0,1,2$

~~如果觉得您自己是欧皇，可以交以下代码~~:
```
#include <bits/stdc++.h>
using namespace std;

int main() {
	
	srand(time(NULL));
	cout<<rand()%3;
	
	return 0;
}

```

上面是闹着玩的，以下是此题的正解

初始有两种状态：第一个位置有雷，和第一个位置没雷

我们令$dp[i]$表示第$i$个位置有几颗雷（虽然只能是0和1，但可以判断是否合法，如果$dp[i]$不是0或1，则不合法）

在纸上稍微画一下，就可以得出递推式：

### $dp[i]=a[i-1]-dp[i-1]-dp[i-2];$

这里的$a[i-1]$表示第i-1行第二列的数字

所以，只要把$dp[1]=0$和$dp[1]=1$都run一遍，看是否合法，就行了

$Code$:

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000001],dp[1000001],dpp[1000001];
bool flag[1000001];
int n;
int Dp1()//dp[1]=0
{
	memset(dp,0,sizeof(dp));
	dp[1]=0;
	for(int i=2;i<=n;++i)
	{
		dp[i]=a[i-1]-dp[i-1]-dp[i-2];
	}
	if(dp[n]+dp[n-1]!=a[n]) return 0;
	for(int i=1;i<=n;++i)
	{
		if(dp[i]!=0&&dp[i]!=1) return 0;
	}
	for(int i=1;i<=n;++i)
	{
		if(dp[i]) flag[i]=1;
	}
	return 1;
}
int Dp2()//dp[1]=1
{
	memset(dpp,0,sizeof(dpp));
	dpp[1]=1;
	for(int i=2;i<=n;++i)
	{
		dpp[i]=a[i-1]-dpp[i-1]-dpp[i-2];//递推
	}
	if(dpp[n]+dpp[n-1]!=a[n]) return 0;
	for(int i=1;i<=n;++i)
	{
		if(dpp[i]!=0&&dpp[i]!=1) return 0;
	}
	for(int i=1;i<=n;++i)
	{
		if(dpp[i]) flag[i]=1;
	}
	return 1;
}
int main() {
	
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
	}
	int y=Dp1()+Dp2();
	cout<<y;
	return 0;
}
```


---

## 作者：zhangjiacheng (赞：7)

## 解题思路：主要是递推就好了，请看代码注释：
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[10001],f[10001],n,tot;
bool jud()
{
     for(int i=1;i<=n;i++)
     {
         f[i+1]=a[i]-f[i]-f[i-1]; //1为有雷，0为无雷  a[i]周围的雷个数为f[i-1]+f[i]+f[i+1]
         if(f[i+1]<0 || f[i+1]>1) return 0;    //只有两个状态，如果左边有2个雷或有-1个雷即为不合法 
     }
     if(f[n+1]!=0)return 0;  //若多出的那辅助位不为0则非法 
     return 1;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    if(a[1]==0)  //当第一个格子的数为0时则表示左边和左下方都无雷 
       tot=tot+jud();
    else if(a[1]==1)  //当为1时表示左边或者右边会有雷 
    {
         f[1]=1;tot+=jud();
         memset(f,0,sizeof(f));
         f[2]=1;tot+=jud();

    }
    else  //当为2时表示左边和左下都有雷 
    {
        f[1]=f[2]=1;tot+=jud();
    }
    cout<<tot;
    return 0;
}
```

---

## 作者：马峰 (赞：6)

瞅了一遍第一页的题解，似乎大概也许是没有用dfs的（后面可能有），那我就发一个dfs的题解。

你就搜，对每个格子有没有雷都判断一下，注意，只需要判断当前节点的下一个节点有没有雷，因为上两个节点都是之前判断好的。

```
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

long long n,ans;

bool map_[100010];
int a[100010];

void dfs(int x){
    int sum=0;
    if(map_[x]) sum++;
    if(map_[x-1]) sum++;
    if(sum==a[x]-1){
        if(x+1>n) return;
        map_[x+1]=1,dfs(x+1);map_[x+1]=0;return;
    }
    if(sum!=a[x]) return;
    if(x==n) {
        ans++;return;
    }
    dfs(x+1);
}

int main(){
    //freopen("Mine.in","r",stdin);
    //freopen("Mine.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    map_[1]=1;dfs(1);
    memset(map_,0,sizeof(map_));dfs(1);
    printf("%d",ans);
    fclose(stdin);fclose(stdout);
    return 0;
}
```
dfs如上。代码丑轻喷

---

## 作者：Randyhoads (赞：4)

又是一道省选水题，其实不用DP也可以


首先可以注意如下：


1.每个格子只有两种情况：有地雷或没地雷


2.第一个格子只有0,1,2三种数字


3.只要确定了前i-1个格子第i个就一定能确定


因为第二列中的i-1个格子管第i-1,i,i-2个格子，所以第i-1个格子就确定了。


注意到这些只需枚举前两个的状态即可


当第二列的第一个数为2时：前两个一定为1,1，只需验证是否合法，为0时同，为一是分情况讨论。


```cpp
    #include<bits/stdc++.h>
    using namespace std;
    inline int read()
    {
        int f=1,x=0;
        char ch;
        do
        {
            ch=getchar();
            if(ch=='-') f=-1;
        }while(ch<'0'||ch>'9');
        do
        {
            x=(x<<1)+(x<<3)+ch-'0';
            ch=getchar();
        }while(ch>='0'&&ch<='9');
        return f\*x;
    }
    int f[100001];
    int n;
    int xz[100001];
    bool bz=false,bz1=false;
    int main()
    {
        n=read();
        for(int i=1;i<=n;i++) f[i]=read();
        if(f[1]==0)//第一个为0
        {
            xz[1]=0;
            xz[2]=0;//前两个确定
            for(int i=3;i<=n;i++)
            {
                xz[i]=(f[i-1]-xz[i-1]-xz[i-2]);
                if(xz[i]>=2||xz[i]<0)//如果说这个格子中又负数个，或多于一个地雷，显然不合法
                {
                    bz=true;
                    break;
                }
}//验证是否合并

        if(f[n]-xz[n]-xz[n-1]!=0) bz=true; 
        if(bz==true)
        {
            cout<<0<<endl;
        }
        else cout<<1<<endl;
        return 0;
    }    
    if(f[1]==2)//同上
    {
        xz[1]=1;
        xz[2]=1;
        for(int i=3;i<=n;i++)
        {
            xz[i]=(f[i-1]-xz[i-1]-xz[i-2]);
            if(xz[i]>=2||xz[i]<0) 
            {
                bz=true;
                break;
            }
        }
        if(f[n]-xz[n]-xz[n-1]!=0) bz=true; 
        if(bz==true)
        {
            cout<<0<<endl;
        }
        else cout<<1<<endl;
        return 0;
    }
    if(f[1]==1)//只用分情况讨论
    {
        int ans=0;
        xz[1]=0;
        xz[2]=1;
        for(int i=3;i<=n;i++)
        {
            xz[i]=(f[i-1]-xz[i-1]-xz[i-2]);
            if(xz[i]>=2||xz[i]<0) 
            {
                bz=true;
                break;
            }
        }
        if(f[n]-xz[n]-xz[n-1]!=0) bz=true; 
        if(bz==false) ans++;
        xz[1]=1;
        xz[2]=0;
        for(int i=3;i<=n;i++)
        {
            xz[i]=(f[i-1]-xz[i-1]-xz[i-2]);
            if(xz[i]>=2||xz[i]<0) 
            {
                bz1=true;
                break;
            }
        }
        if(f[n]-xz[n]-xz[n-1]!=0) bz1=true; 
        if(bz1==false) ans++;
        cout<<ans<<endl;
    }
}
代码有点累赘~


---

## 作者：misaka0111 (赞：3)

讲一下状态压缩dp的做法。设dp[i][j]为第i-2个格到第i个格按照j去放置地雷的方案数。例如dp[3][4]，4的二进制为100，就表示第3个格放地雷，第1个格和第2个格不放地雷的方案数。显然，初始状态dp[1][4]=1,dp[1][0]=1，就是对应了第一个格放与不放地雷。那么我们再考虑如何进行转移，设当前格的状态为sta，则上一格的状态为(sta<<1)%8或(sta<<1)%8+1，假如此时状态都是合法的，就可以进行转移，设last=(sta<<1)%8，dp[i][sta]=dp[i-1][last]+dp[i-1][last|1]。接下来再看状态何时合法，设counter(x)为x的二进制表示中1的个数，num为第二列对应的数字，合法也就意味着counter(sta)==num[i-1]且counter(sta>>1)<=num[i]，此时就可以进行转移。最后我们再把所有符合合法的dp[n][sta]加在一起，即为最终答案。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int dp[10005][8];
int num[10005];
int n;
int counter(int x)
{
    int cnt = 0;
    while (x)
    {
        x &= x - 1;
        cnt++;
    }
    return cnt;
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &num[i]);
    dp[1][0] = 1;
    dp[1][4] = 1;
    for (int i = 2; i <= n; i++)
    {
        for (int sta = 7; sta >= 0; sta--)
        {
            if (counter(sta >> 1) > num[i] || counter(sta) != num[i - 1])
                continue;
            int last = (sta << 1) % 8;
            dp[i][sta] += dp[i - 1][last] + dp[i - 1][last | 1];
        }
    }
    int ans = 0;
    for (int sta = 7; sta >= 0; sta--)
    {
        if (counter(sta >> 1) != num[n] || (n > 1 && counter(sta) != num[n - 1]))
            continue;
        ans += dp[n][sta];
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：matsuk (赞：2)

今天考了一道改编题，那题只有一行，数字只有$0$ $1$ $2$，正解可以模拟讨论。

然后我就想吧这题也讨论一波试试看

于是就有了这个不是很长也就$2.5K$的代码==

可能有些地方会讨论重复，不过都是$copy$再改一点点，不嫌麻烦

因为我比较傻，这样就保险一点。

用$1$表示该位置确定没有雷，$-1$表示确定有雷，$0$表示不确定（也就是还没有填过数）。

因为$0$和$3$的状态是可以确定的，就先扫一遍吧它们填进去。**这里注意$1$和$n$要特别讨论。**

然后再处理$1$和$2$：

**如果和当前位置对应的三个~~鸽子~~格子里有两个已经填了，那么剩下的一个就可以推出来啦！**

所以就再扫一遍处理$1$和$2$的情况（我本来扫了两遍的，不过发现扫一遍也可以过。只是不知道这个是否正确_(:з」∠)__ ），最后判断，若每个~~鸽子~~格子都填了数，那么答案唯一，否则输出$2$。

对于答案为$0$的情况，**一边扫的时候一边判断**当前填的位置是否已经填过，如果填过，是否和现在要填的数冲突，即可。

如果有点细节问题，发现了就说一声八（虽然我感觉没人会看这代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
#define _ 10010
int n, c[_], x[_], t;
#define nosol puts("0"), exit(0)
void sol(int i){
	if(c[i]==1){
		if((!x[i-1])+(!x[i])+(!x[i+1])>=2) return;
		if(x[i-1]<0) {if(x[i]<0||x[i+1]<0) nosol; x[i]=x[i+1]=1; return;}
		if(x[i]<0) {if(x[i-1]<0||x[i+1]<0) nosol; x[i-1]=x[i+1]=1; return;}
		if(x[i+1]<0) {if(x[i-1]<0||x[i]<0) nosol; x[i-1]=x[i]=1; return;}
		if(x[i]&&x[i+1]){
			if(x[i]+x[i+1]){
				if(x[i-1]>0) nosol; x[i-1]=-1;
			} else {if(x[i-1]<0) nosol; x[i-1]=1;}
			return;
		}
		if(x[i-1]&&x[i+1]){
			if(x[i-1]+x[i+1]){
				if(x[i]>0) nosol; x[i]=-1;
			} else {if(x[i]<0) nosol; x[i]=1;}
			return;
		}
		if(x[i-1]&&x[i]){
			if(x[i-1]+x[i]){
				if(x[i+1]>0) nosol; x[i+1]=-1;
			} else {if(x[i+1]<0) nosol; x[i+1]=1;}
			return;
		}
	}
	if(c[i]==2){
		if((!x[i-1])+(!x[i])+(!x[i+1])>=2) return;
		if(x[i-1]>0) {if(x[i]>0||x[i+1]>0) nosol; x[i]=x[i+1]=-1; return;}
		if(x[i]>0) {if(x[i-1]>0||x[i+1]>0) nosol; x[i-1]=x[i+1]=-1; return;}
		if(x[i+1]>0) {if(x[i-1]>0||x[i]>0) nosol; x[i-1]=x[i]=-1; return;}
		if(x[i]&&x[i+1]){
			if(x[i]+x[i+1]){
				if(x[i-1]<0) nosol; x[i-1]=1;
			} else {if(x[i-1]>0) nosol; x[i-1]=-1;}
			return;
		}
		if(x[i-1]&&x[i+1]){
			if(x[i-1]+x[i+1]){
				if(x[i]<0) nosol; x[i]=1;
			} else {if(x[i]>0) nosol; x[i]=-1;}
			return;
		}
		if(x[i-1]&&x[i]){
			if(x[i-1]+x[i]){
				if(x[i+1]<0) nosol; x[i+1]=1;
			} else {if(x[i+1]>0) nosol; x[i+1]=-1;}
			return;
		}
	}
}
void sp1(){
	if(c[1]==1){
		if(x[1]) {if(x[2]==x[1]) nosol; x[2]=-x[1];}
		else if(x[2]) {if(x[1]==x[2]) nosol; x[1]=-x[2];}
	}
}
void spn(){
	if(c[n]==1){
		if(x[n]) {if(x[n-1]==x[n]) nosol; x[n-1]=-x[n];}
		else if(x[n-1]) {if(x[n-1]==x[n]) nosol; x[n]=-x[n-1];}
	}
}
int main(){
	scanf("%d", &n);
	for(int i=1; i<=n; ++i)
		scanf("%d", &c[i]);
	
	if(c[1]>2||c[n]>2) nosol;
	if(n==2&&c[1]!=c[2]) nosol;
	
	if(c[1]==2) x[1]=x[2]=-1; if(c[n]==2) x[n]=x[n-1]=-1;
	if(!c[1]) x[1]=x[2]=1; if(!c[n]) x[n]=x[n-1]=1;
	for(int i=2; i<n; ++i){
		if(c[i]==3){
			if(x[i-1]>0||x[i]>0||x[i+1]>0) nosol;
			x[i-1]=x[i]=x[i+1]=-1;
		}
		if(!c[i]){
			if(x[i-1]<0||x[i]<0||x[i+1]<0) nosol;
			x[i-1]=x[i]=x[i+1]=1;
		}
	}
	
	sp1(); for(int i=2; i<n; ++i) sol(i); spn();

	for(int i=1; i<=n; ++i)
		if(!x[i]) {puts("2"); return 0;}
	
	puts("1");
	return 0;
}

```


---

## 作者：djy213 (赞：2)

首先，这里的扫雷是有零的；


这个十分重要，也理所当然，但我一开始没发现——所以这个占两行；然后本解f[i][j]

f[i][j]

-  f[i][0]：第i个数字左边和左上都无雷的方案数；

-  f[i][1]：只左边有的方案数；

-  f[i][2]：只左上有的方案数；

-  f[i][3]：左上和左边都有的方案数；

      
有点奇怪哈；

代码：

···
cpp
```cpp
```
#include<cstdio>
using namespace std;
int f[10001][4];
int a[10001];
int main()
{
    int i,j,k,n;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
      scanf("%d",&a[i]);
    if(a[1]==1){f[1][1]=1;f[1][2]=1;}
    else
    {
        if(a[1]==2)
          f[1][3]=1;
        if(a[1]==0)
          f[1][0]=1;
    }
    if((a[1]==1||a[1]==0)&&n==1)
    {
        printf("1");
        return 0;
    }
    for(i=2;i<=n-1;i++)
    {
        if(a[i]==0)
            f[i][0]=f[i-1][0];
        if(a[i]==1)
        {
            f[i][0]=f[i-1][1];
            f[i][1]=f[i-1][2];
            f[i][2]=f[i-1][0];
        }
        if(a[i]==2)
        {
            f[i][1]=f[i-1][3];
            f[i][2]=f[i-1][1];
            f[i][3]=f[i-1][2];
        }
        if(a[i]==3)
            f[i][3]=f[i-1][3];
    }
    if(a[n]==1)
        printf("%d",f[n-1][1]+f[n-1][2]);
    if(a[n]==2)
        printf("%d",f[n-1][3]);
    if(a[n]==0)
        printf("%d",f[n-1][0]);
    if(a[n]==3)
        printf("0");
    return 0;
}
略丑轻喷；
```cpp

---

## 作者：素质玩家孙1超 (赞：1)

虽然已经有辣么多题解了，~~但我还是要发一篇~~，但是我的更他们的不同

我的有我的优点：~~代码简洁~~   我只开了一个10010的a数组 内存比其他人的少

~~别打我~~

**思路**

把方块旁边的雷数存到a数组，然后直接开搜，因为每一个块都只有两种情况，有雷/没雷

记录就直接修改存雷数的那个就好了，比如pos是雷的话（因为可以影响3个）a[pos]--,a[pos-1]--,a[pos+1]--,回溯时再改回来就好了

我们搜到第pos块的时候，判断a[pos-1]是否为零，因为现在已经不可以再更新那个块了，如果a[pos-1]==0那么就继续搜

**细节**

把第一个和最后一个雷处理好

（代码中有更详细的解释）
```cpp

#include<bits/stdc++.h>
using namespace std;
int a[11000],ans,n;//a存雷数 
void dfs(int pos)
{
	if(pos==n+1)//如果搜完到最后一个了 
	{
		if(a[pos-1]==0)//判断最后一个块是否为0 
			ans++;//记录结果 
		return;
	}
	a[pos-1]--;
	a[pos]--;
	a[pos+1]--;//如果pos是雷 
	if(a[pos-1]==0) //如果这种情况下a[pos-1]==0,就可以继续向下搜 
		dfs(pos+1); 
	a[pos-1]++;
	a[pos]++;
	a[pos+1]++;//如果pos不是雷 
	if(a[pos-1]==0) //如果这种情况下a[pos-1]==0,就可以继续向下搜 
		dfs(pos+1);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];//最正常的输入 
//处理第一个 
	a[1]--;a[2]--;//如果第一个是雷 
	dfs(2);
	a[1]++;a[2]++;//第一个不是雷 
	dfs(2);
	printf("%d",ans);
} 
```


---

## 作者：小黑AWM (赞：1)

看完了所有题解，没看到有记忆化搜索的，遂交一发。

### 思路
一开始做题的时候第一秒莫名就想到枚举，不过好在脑子还正常，以at表示当前搜到第几个点，stat是一个3位二进制数表示在该点拓展之前，这个点的左边三联通的地雷状况，1表示有雷，0表示无雷。后考虑每个点在拓展时其实只能在最后一个点选择是否有雷才能防止影响之前的决策，那么只要计算出这个点还能放多少雷就可以判断了。

配合图表来解释一下：
	
| 雷 |数  |
| :----------: | :----------: |
| 1 | 2 |
| 1 | 1 |
| 0 | 2 |
| * | 1 |

当我们搜索到倒数第二行时，只能在*处选择是否置雷才可以防止之前的递推结果被破坏，又由于在无法改变的过去中2的左边和上边已经放了一个雷，所以还要放一个雷然后继续递推下去即可，用一个f数组记录答案即可。这个状态设计可以保证是没有后效性的。

### 边界情况
1. 由于第0个数无法搜索，我们需要对于 $(1,(000)B)$ 和 $(1, (010)B)$ 两种状态分别进行搜索，最后把答案 $f[1][0]$ 和 $f[1][2]$ 加起来即可。

2. 对于最后一个数，因为它不能修改他之后的情况，所以在搜索时对于最后一个数要求我们当前已满足其所要求的条件。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 1e4 + 10;
int n, a[maxn], f[maxn][8];
bool visit[maxn][8];
int dfs(int at, int stat){
    if(visit[at][stat])
        return f[at][stat];
    visit[at][stat] = true;
    int val = a[at];
    for(int i = 0; i <= 2; i++)
        val -= (stat >> i) &1;
    if(val > 1 || val < 0)
        return f[at][stat] = 0;
    if(at == n && val == 0)
        return f[at][stat] = 1;

    if(val == 0)
        f[at][stat] += dfs(at+1, (stat << 1)&7);
    if(val == 1)
        f[at][stat] += dfs(at+1, ((stat|1) << 1)&7);

    return f[at][stat];

}
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
        cin >> a[i];

    cout << dfs(1, 0) + dfs(1, 2) << endl;
    return 0;
}

```

不过虽说形式是记忆化搜索，但是究其本质，还是一种写法略有不同的递推……


---

## 作者：LATB (赞：1)

蒟蒻一只，不会DP不会DFS ****大佬们辛苦了...

------------
看着有点麻烦呐，题解的大佬写的本蒟蒻看不懂...尬
  只有2列，这是个好东西啊！如果知道第一列的第一行有没有地雷，那么其它的位置就出来了，所以方案数仅仅只有1或2！So：枚举大法好！

------------
只需要知道第一个格子有没有雷，根据a[1]，可得到第二个格子有没有，根据a[3]，知道第三个格子有无雷依次类推，看是否有矛盾就OK了。
	
    所以我们利用递推公式a[i]=b[i-1]-a[i-1]-a[i-2]去特判a[i]的值的大小
  有雷为真，无雷为假，其它情况（嘿嘿，还能有其他情况？!），

再特判一个条件a[n]==b[n-1]-a[n-1]?true:false;即可得出答案
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10005;
typedef long long ll;
int a[N],b[N],t,n;
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        for(int i=1;i<=n;i++)
            scanf("%d",&b[i]);
        for(a[1]=0;a[1]<=1;a[1]++)
        {
            bool flag=true;
            for(int i=2;i<=n;i++)
            {
                a[i]=b[i-1]-a[i-1]-a[i-2];
                if(a[i]!=0&&a[i]!=1)
                {
                    flag=false;
                    break;
                }
                if(i==n&&b[i]!=a[i]+a[i-1])
                {
                    flag=false;
                }
            }
            if(flag)
                t++;
        }
        printf("%d\n",t);
    }
    return 0;
}
```

---

## 作者：zhonghaoran (赞：1)

[算法分析]

按照我们平时玩扫雷的心得，我们往往可以通过某个位置周围的数字以及已经得到的雷的分布推出其是不是雷。该题同样可以这样做，如果已知第i-1格和i-2格是否有雷(i>2)，则可以通过序列中第i-1个数推出第i格是否有雷。而第2格的状态则只需要由第一格的雷和序列第一个数推出。

设A[i]表示序列中第i个元素，F[i]表示第I格的雷数,我们可以**递推**求解。

方程：

       **A[i]=A[i-1]-F[i-1]  (i=2)**

       **A[i]=A[i-1]-F[i-2]-F[i-1]  (i>2)**

但是F1的值还是未知的，由于每一格就是有雷和无雷两种状态，显然我们可以枚举第一格雷的状态，即F1的值为0或者1，这样就可以递推得到所有的F值。如果Fi（1<=i<=n）的值不为0，1的话显然是不符合要求的，而如果** A[n]<>F[n]+F[n-1]**(不判只有90分）,显然也是不符合要求的。如果不出现这种情况就得到一种可行的分布方案，所以最后答案不外乎0， 1， 2三种。

[参考代码]

```cpp
#include <iostream>
using namespace std;
int a[10100],n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];//读入操作
    int booll,boolr;
    booll=boolr=0;//判断求得的解是否合法
    int f1[10100],f2[10100];//递推数组
    for(int i=1;i<=n;i++)
    {
        f1[1]=0;//分第一个空是否有雷，进行两次计算
        if(i==2)
        {
            if(a[1]-f1[1]==1||a[1]-f1[1]==0)
              f1[2]=a[1]-f1[1];//递推公式
            else  booll=1; //记录不合法
        }
        if(i>2)
        {
            if(a[i-1]-f1[i-1]-f1[i-2]==1||a[i-1]-f1[i-1]-f1[i-2]==0)
              f1[i]=a[i-1]-f1[i-1]-f1[i-2];//递推公式
            else  booll=1;//记录不合法
        }
        f2[1]=1;
        if(i==2)
        {
            if(a[1]-f2[1]==1||a[1]-f2[1]==0)
              f2[2]=a[1]-f2[1];//递推公式
            else  boolr=1;//记录不合法
        }
        if(i>2)
        {
            if(a[i-1]-f2[i-1]-f2[i-2]==1||a[i-1]-f2[i-1]-f2[i-2]==0)
              f2[i]=a[i-1]-f2[i-1]-f2[i-2];//递推公式
            else  boolr=1;//记录不合法
        }
    }
    if(a[n]!=f1[n-1]+f1[n])
      booll=1;
    if(a[n]!=f2[n-1]+f2[n])
      boolr=1;//重要的判定，容易被忽略
    int ans;
    if(booll&&boolr)
      ans=0;
    if((!booll&&boolr)||(!boolr&&booll))
      ans=1;
    if(!booll&&!boolr)
         if(f1[n]==f2[n])
        ans=1;
      else
        ans=2;//判断answer
    cout<<ans<<endl;//输出操作
    return 0;
}
希望各位oier仔细思考每一个问题，AC并不是最重要的，最重要的是思考与解题的过程。
```

---

## 作者：loli (赞：1)

鄙人的解法:


dp.dp[i][j]表示到第i位的附近三格，有几种形状为j的可能


“形状为j”是什么意思呢，注意到如果附近三格有无雷用0，1表示的话，其实就组成了二进制数字，把他们转化为十进制即为j


那么j最大是7


转移的话直接根据上一次结果和当前数字判断即可，我用了滚动数组



O(n)
'''cpp

```cpp
#include<cstdio>
#include<cstring>
#define MAXN 10010
using namespace std;
int dp[2][8];
int a[MAXN];
int n, ans = 0;
int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (a[i] > 3) {
            printf("0");
            return 0;
        }
    }
    if (a[n] == 3){
        printf("0");
        return 0;
    }
    if (n == 1){
        if (a[1] == 1) printf("1");
        else printf("0");
        return 0;
    }
    memset(dp, 0, sizeof(dp));
    if (a[1] == 0) dp[0][0] = 1; 
    if (a[1] == 1) dp[0][2] = 1, dp[0][1] = 1;
    if (a[1] == 2) dp[0][3] = 1;
    for (int i = 2; i <= n; i++){
        int w = i & 1;
        int v = (i - 1) & 1;
        memset(dp[v], 0, sizeof(dp[v]));
        if (a[i] == 0){//查看前面以0结尾的数 
            dp[v][0] += dp[w][4];
            dp[v][0] += dp[w][0];
        }
        if (a[i] == 1) {
            if (i != n) dp[v][1] += dp[w][0] + dp[w][4];
            dp[v][4] += dp[w][2] + dp[w][6];
            dp[v][2] += dp[w][1] + dp[w][5];
        }
        if (a[i] == 2) {
            if (i != n) dp[v][5] += dp[w][2] + dp[w][6];
            dp[v][3] += dp[w][1] + dp[w][5];
            dp[v][6] += dp[w][3] + dp[w][7];
        }
        if (a[i] == 3) {
            dp[v][7] += dp[w][3] + dp[w][7];
        }
    }
    for (int i = 0; i < 8; i++){
        ans += dp[(n - 1) & 1][i];
    }
    printf("%d", ans);
}
```
'''
打个小广告:欢迎到我的网站[moe.si](http://moe.si/)去看看~

也欢迎各位dalao交换友情链接~


---

## 作者：Mr_Li (赞：1)

楼上已经说的很不错了，这里再给出我的做法。

设f[i][0]表示不考虑第二列第i个之后的数字，且第一列第i个和第i+1个都没有雷有多少种可能；f[i][1]表示不考虑第二列第i个之后的数字，且第一列第i个有雷，第i+1个没有雷有多少种可能；f[i][2]表示不考虑第二列第i个之后的数字，且第一列第i个没有雷，第i+1个有雷有多少种可能；f[i][3]表示不考虑第二列第i个之后的数字，且第一列第i个和第i+1个都有雷有多少种可能。于是，f[i]可以通过f[i-1]递归求解（知道了第一列第i-1个和第i个有没有雷，必然能通过第二列第i个求出第一列第i+1个，进而求出f[i]），具体递推公式看代码（附录里有）。

得出f[n-1]后，若第二列最后一个为0（可能出现在坑爹数据中），则答案为f[n-1][0]；若第二列最后一个为1，则答案为f[n-1][1]+f[n-1][2]；若第二列最后一个为2，则答案为f[n-1][3]；若第二列最后一个大于2（同样可能出现在坑爹数据中），则答案为f[n-1][0]。

附录——用此算法做的C++代码：

```cpp

#include<iostream>
using namespace std;
int n,i,map[10001],f[10000][4]={{1,0,1,0}}; 
int main ()
{
    cin>>n;
    for (i=1;i<=n;i++)
    cin>>map[i];
    for (i=1;i<n;i++)
    {
        switch (map[i])
        {
               case 0:
                    f[i][0]=f[i-1][0];
                    f[i][1]=0;
                    f[i][2]=0;
                    f[i][3]=0;
                    break;
               case 1:
                    f[i][0]=f[i-1][1];
                    f[i][1]=f[i-1][2];
                    f[i][2]=f[i-1][0];
                    f[i][3]=0;
                    break;
               case 2:
                    f[i][0]=0;
                    f[i][1]=f[i-1][3];
                    f[i][2]=f[i-1][1];
                    f[i][3]=f[i-1][2];
                    break;
               case 3:
                    f[i][0]=0;
                    f[i][1]=0;
                    f[i][2]=0;
                    f[i][3]=f[i-1][3];
                    break;
               default:
                       f[i][0]=0;
                       f[i][1]=0;
                       f[i][2]=0;
                       f[i][3]=0;
                       break;
        }
    }
    switch (map[n])
    {
           case 0:
                cout<<f[n-1][0];
                break;
           case 1:
                cout<<f[n-1][1]+f[n-1][2];
                break;
           case 2:
                cout<<f[n-1][3];
                break;
           default:
                   cout<<0;
                   break;
    }
    return 0;
} 

```

---

## 作者：sqc1999 (赞：1)

设a[0][i]表示第i行是否有雷，a[1][i]表示第i行题目给出的雷数，则有递推式a[0][i]=a[1][i-1]-a[0][i-1]-a[0][i-2]。

根据题意可发现最多只有两种可能，其a[0][1]的值分别为0和1，于是把a[0][1]先后赋值为0和1进行递推，若在递推过程中发现a[0][i]不为0或1则这种情况不合法。

注意最后要判断a[1][n]是否等于a[0][n]+a[0][n-1]，否则第8个点过不去。。


上代码

```cpp

#include<iostream>
#include<algorithm>
using namespace std;
int a[2][10001];
int main()
{
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[1][i];
    }
    int cnt = 0;
    for (a[0][1] = 0; a[0][1] <= 1; a[0][1]++)
    {
        bool b = true;
        for (int i = 2; i <= n; i++)
        {
            a[0][i] = a[1][i - 1] - a[0][i - 1] - a[0][i - 2];
            if (a[0][i] != 0 && a[0][i] != 1)
            {
                b = false;
                break;
            }
            if (i == n&&a[0][i] + a[0][i - 1] != a[1][i])
            {
                b = false;
            }
        }
        if (b) cnt++;
    }
    cout << cnt;
}

```

祝各位愉快地AC。


---

## 作者：JasonZRY (赞：1)

这道只要判断第一个位置是否有雷，后面就可以慢慢推出来了

```
#include<bits/stdc++.h>
using namespace std;
int w[10005],a[10005],cnt,n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>w[i];          //输入每个地方的数字 
	for(int i=0;i<=1;i++){
        a[0]=0;
        a[1]=i;                              //分类讨论：第一个位置是否有雷 
        for(int i=2;i<=n;i++){
            a[i]=w[i-1]-a[i-1]-a[i-2];       //第i个位置的雷有w[i-1]-a[i-1]-a[i-2]个 
            if(a[i]>1||a[i]<0){
                a[n]=0x7fffffff;             //如果爆掉了，就把最后一位置设为无限大（其实只要是一个>=9的数就行了），然后跳出循环 
                break;
            }
        }
        if(a[n-1]+a[n]==w[n])cnt++;          //方案数加一 
    }
    cout<<cnt;
    return 0;
}
```

# 求通过求赞

---

## 作者：包子入侵 (赞：1)

第一次发有遗漏之处敬请谅解


其实若将所有情况都一一枚举是不现实的，时间太长了


其实只需由两个即可确定下面的所有


因为数字只可能从左上左左下来


知道前面的再通过数字就可确定第三个


知道了第三个，再结合第二个，就是下一个数的两个，同理可一直推下去


include <bits/stdc++.h>//好用的库文件 noi，noip都支持


```cpp
#define N 10004//稍微加快
using namespace std;
int n,a[N];//number
int b[N];//mine
bool judge(){
    b[0]=0;
    for (int i=1;i<=n;++i){//++i个人习惯理论上快一点点
        b[i+1]=a[i]-b[i-1]-b[i];
        if (b[i+1]>1||b[i+1]<0) return 0;
    }
    return b[n+1]==0;
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;++i) scanf("%d",&a[i]);
    int ans=0;
    for (b[1]=0;b[1]<2;++b[1])
        ans+=judge();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：鹭天 (赞：1)

#在做这道题之前，首先得弄清楚这些东西:

##1、第一个雷只有两个方向，且第一个雷只有两种情况0,1,这道题的关键就在这里

##2、知道第一个雷之后，第二格雷的方法就是a[1]-b[1](a数组是输入的地雷数，b数组是要我们求的地雷数)

##3、接下来求地雷的方法就是b[j]=a[j-1]-b[j-1]-b[j-2];，但中途只要出现错误(b[j]不等于0页不等于1)，那就说明方法不可取，就不累加

##4、不要以为循环完就ok了，还需要验证最后一个雷到底对不对，因为最后一个雷的方向也是只有两个，所以验证方法就是去判断这个雷到底##符不符合输入的雷数（b[n]!=a[n]-b[n-1]），若不符合，则方法仍不可取。

那么清楚了之后，代码如下:

#=====================一条华丽的分割线=========================================================


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long int i,j,n,s=0,a[10002],b[10002];
    cin>>n;
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    for (i=0;i<=1;i++){//第一个雷的两种情况
        bool f=1;//先将开关定义为正确的
        b[1]=i;b[2]=a[1]-b[1];//求第一个雷和第二个雷
        for (j=3;j<=n;j++){//循环接下来的雷
            b[j]=a[j-1]-b[j-1]-b[j-2];//求这个是不是雷
            if (b[j]!=1&&b[j]!=0) f=false;//同上，如果地雷不符合，就不可取
        }
        if (b[n]!=a[n]-b[n-1]) f=false;//同最后的判断，如果最后的一个地雷不符合雷数，不可取
        s=s+f; //加上方案数
    }
    cout<<s;//输出
    return 0;
} 
```
。。
#呵！简单易懂的方法


---

## 作者：Yuyuanqi (赞：0)

# P2327 [SCOI2005]扫雷

[题目链接](https://www.luogu.org/problem/P2327)

~~普及组水题~~非常适合新手练搜索

看题解里各路神仙都用各种简单的方法，我来讲讲~~暴力~~搜索做法....

对于我这样的萌新我觉得这样的做法更容易让你理解搜索

首先搜索要定义状态，我们定义dfs(x, p)是当第x位是p，就有了状态

然后我们讨论第x + 1位的情况~~只有两种情况~~，然后就有了转移

其次当x是n时，如果成立，则++ans，于是有了边界条件

最后你把这段代码复制粘贴得了100分，发现原来这有点像动态规划

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define ll long long
#define N 100005
int a[N], b[N], n;//a是左边那排，b是每一个格子是否放雷
ll ans;
void dfs(int x, int p) //第x个格子放 p个雷
{
	b[x] = p;
	if (x == n) //边界
	{
		if (b[x] + b[x - 1] == a[x]) //第n个格子放 p个雷 成立
			ans++;
		return;
	}
	for (int i = 0; i <= 1; i++) //讨论第x + 1个格子放不放雷
		if (b[x] + b[x - 1] + i == a[x] && b[x] + i <= a[x + 1])
			dfs(x + 1, i); //转移（滑稽
	b[x] = 0;
}
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	dfs(1, 1);
	dfs(1, 0);
	cout << ans;
	return 0;
}
```


---

## 作者：寒冰大大 (赞：0)

看起来我做的和其他题解不一样

那就发一篇吧

首先本题情况看似无厘头，但是仔细观察，不难发现：

我们可以假设第一种情况，接着可以推出第二种

然后有了两个已知的后，第三个显而易见

如果你要问我怎么推出来的吗，我在里面说的的逻辑判断已经很明白了

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>

using namespace std;
int boom[10086];
int ans;
int tj[10086];
int looker[10086];
int n;
int pdf()   //这段代码是用当前推完的雷局反推右边的数字，如果数字不一样就说明这个雷局不是答案。（因为我们第一颗棋子是假设的）
{
	memset(looker,0,sizeof(looker));
	for(int i=1;i<=n;i++)
	{
		if(tj[i]==1) 
		{
			looker[i-1]++;   
			looker[i]++;
			looker[i+1]++;
		}
	}
	for(int i=1;i<=n;i++)
	if(looker[i]!=boom[i]) return 0;
	return 1;
}
void getnext(int i)
//这是一个判断，这些逻辑的来源是上面一格和二格以及上面一格右边的数字，你可以在草稿纸上手推（反正我就是手推的）
{
	if(i==2)
    //由于第二个点只能由上面一个点推出因此需要特判
	{
		if(boom[i-1]==2) tj[i]=1;
		if(boom[i-1]==0) tj[i]=0;
		if(boom[i-1]==1&&tj[i-1]==1) tj[i]=0;
		if(boom[i-1]==1&&tj[i-1]==0) tj[i]=1;
	}
	else
    // 每一行都对应一种情况。括号里是已知情况，括号外为推得当前的雷 tj[i]=1 就说明这个点有雷
	{
	if(boom[i-1]==0) tj[i]=0;
	if(boom[i-1]==3) tj[i]=1;
	if(tj[i-2]==0&&tj[i-1]==1&&boom[i-1]==2) tj[i]=1;
	if(tj[i-2]==0&&tj[i-1]==1&&boom[i-1]==1) tj[i]=0;
	if(tj[i-2]==0&&tj[i-1]==0&&boom[i-1]==1) tj[i]=1;
	if(tj[i-2]==1&&tj[i-1]==1&&boom[i-1]==2) tj[i]=0;
	if(tj[i-2]==1&&tj[i-1]==0&&boom[i-1]==2) tj[i]=1;
	if(tj[i-2]==1&&tj[i-1]==0&&boom[i-1]==1) tj[i]=0; 	
	}
	return ;
}
int pd(int f)  //函数封装，养成良好习惯
{
	memset(tj,0,sizeof(tj));
	tj[1]=f;
	for(int i=2;i<=n;i++)
	getnext(i);
	int bj=pdf();  
	return bj;
}
int main()
{
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    scanf("%d",&boom[i]);
    ans+=pd(0);//两种情况都要枚举并且验证，答案有可能为0
    ans+=pd(1); 
    printf("%d",ans);
    return 0;
}
```


---

## 作者：gary2005 (赞：0)

# 暴力出奇迹

看到题解里大多数人都是 递推和dp，好像我的dfs已经没有立足之地了。

其实递归非常简单，因为对于每个点只有两种状态

1. 有雷
2. 无雷

这样我们就只需要dfs这两个状态就ok了

伪代码：
```cpp
	//put
	if(now>1) a[now-1]-=1;//三个方向雷数--
	a[now]-=1;
	if(now!=n) a[now+1]-=1;
	dfs(now+1);
	if(now>1) a[now-1]+=1;//回溯
	a[now]+=1;
	if(now!=n) a[now+1]+=1;
	
	//dont put
	dfs(now+1);//不放就直接递归下一个阶段
```
结束判定

伪代码：

```cpp
if(now==n+1){
		for(int i=n;i>=n-1;i--){
			if(a[i]!=0){//是否全部都是0
				return;
			}
		}
		ans++;
		return;
	}
```

但是，剪枝很重要

伪代码：

```cpp
	if(now>=3&&a[now-2]!=0) return;
	if(now>=2&&a[now-1]>1) return;
```
那怎么来理解

因为第now个和第now-2个已经没有关系了，所以第now-2必须为0（同时也省去了结束判定的范围）

还有now-1目前只和now有关系，也就是这个要不是0，要不是1

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=10000+10;
int n,a[MAXN],ans;
void dfs(int now){
	if(now>=3&&a[now-2]!=0) return;
	if(now>=2&&a[now-1]>1) return;
	if(now==n+1){
		for(int i=n;i>=n-1;i--){
			if(a[i]!=0){
				return;
			}
		}
		ans++;
		return;
	}
	//put
	if(now>1) a[now-1]-=1;
	a[now]-=1;
	if(now!=n) a[now+1]-=1;
	dfs(now+1);
	if(now>1) a[now-1]+=1;
	a[now]+=1;
	if(now!=n) a[now+1]+=1;
	
	//don't put
	dfs(now+1);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	if(n==1) {
		printf("1\n");
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：万弘 (赞：0)

果然我不看题解瞎想就是会创造神奇做法

类似DP.

对于每一个位置非1或n的点,只有四种情况:  
1.  前一个格子与当前格子均为雷  
2.  前一个格子雷,当前格子非雷
3.  前一个格子与当前格子均非雷
4.  前一个格子非雷,当前格子雷

所以可设`f[p1][p2][x]为x位置时前一个格子为p1,当前格子为p2的方案数`,显然复杂度$O(n)$,考虑到高维数组寻址慢,将p1和p2压缩成一位(反正只有四种情况)

我也明白我讲的不清楚,请看代码吧:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
typedef long long ll;
#define maxn 10001
ll n;
ll a[maxn];
ll f[4][maxn];
ll zip(ll p1,ll p2)//压缩的函数
{
	return p1*2+p2;
}
ll dfs(ll p1,ll p2,ll x)//记搜(其实是我不太会循环)
{
	if(x==n)//边界,再没有下一格了
	{
		if(p1+p2==a[n])return 1;//合法则有方案
		else return 0;
	}
	ll tmp=zip(p1,p2);//压缩
	if(f[tmp][x]>=0)//调取记忆
		return f[tmp][x];
	if(p1+p2>a[x])//已不合法,返回0
		return f[tmp][x]=0;
	if(p1+p2==a[x])//下一格不能放雷
		return f[tmp][x]=dfs(p2,0,x+1);
	if(p1+p2==a[x]-1)//下一个放雷
		return f[tmp][x]=dfs(p2,1,x+1);
	return 0;//其实就是p1+p2<a[x]-1的情况,下一格不能放两个雷,返回0
}

int main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	memset(f,-1,sizeof(f));
	printf("%lld",dfs(0,0,1)+dfs(0,1,1));//点1只有两种情况
	return 0;
}
```

---

## 作者：zijinjun (赞：0)

这道题总的来说还是很简单的，~~但教练在我们只会数组循环什么的时候考试是几个意思~~，考试过了几百年之后发现了这个，成功给他A掉了

思路是DP（万物皆可DP）

状态设计：f[N][2][2] i,j,k分别表示第几个，第i个有没有雷，第i+1个有没有雷

初始化：

```cpp
f[0][0][0]=f[0][0][1]=1;
	
```

转移比较好理解

a[i]==0

从f[i-1][0][0]转移到f[i][0][0]

a[i]==1

从f[i-1][1][0]到f[i][0][0]


f[i-1][0][1]到f[i][1][0]

从f[i-1][0][0]到f[i][0][1]

......(能说懒得打了吗）

```cpp
void work() {
	f[0][0][0]=f[0][0][1]=1;
	FOR(i,1,n) {
		if(a[i]==0) {
			f[i][0][0]=f[i-1][0][0];
		}
		if(a[i]==1) {
			f[i][0][0]=f[i-1][1][0];
			f[i][1][0]=f[i-1][0][1];
			f[i][0][1]=f[i-1][0][0];
		}
		if(a[i]==2) {
			f[i][1][0]=f[i-1][1][1];
			f[i][1][1]=f[i-1][0][1];
			f[i][0][1]=f[i-1][1][0];
		}
		if(a[i]==3) {
			f[i][1][1]=f[i-1][1][1];
		}
	}
	cout<<f[n][1][0]+f[n][0][0];
}

```

就是这样

---

## 作者：attack_shane (赞：0)

本人最近脑子烧了，所以一直没注意位运算的优先级，程序一直出问题，憋坏洒家了，庆祝终有一天我醒悟了


如下动归过此题：




```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
/*inline int read(){
    char c;int x=0;
    c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}*/
//以上快读，大可不必理会。
int main(){
    int n=read(),last0=0,last1=2,s0=1,s1=1,x;//分两种情况：第一个是雷（last0）、第二个是雷（last1），s0、s1记录用于判断方案是否成立，x用于读数。
    for(register int i=1;i<n;i++){
        x=read();//读入数据。
        if(s0){
            if((x-((last0&1)+(last0&2)/2))!=1&&(x-((last0&1)+(last0&2)/2)!=0))s0=0;
            last0=last0/2+(x-((last0&1)+(last0&2)/2))*2;
```
}//方案一还有存在可能时记录下两个格的雷分布情况。
        if(s1){

            if((x-((last1&1)+(last1&2)/2)!=1)&&(x-((last1&1)+(last1&2)/2)!=0))s1=0;

            last1=last1/2+(x-((last1&1)+(last1&2)/2))\*2;

}//方案二还有存在可能时记录下两个格的雷分布情况。

        if(s0==0&&s1==0){

            puts("0");

            return 0;

}//若都不存在，输出0，结束程序。


```cpp
    }
    x=read();
    if(x-((last0&1)+(last0&2)/2)!=0)s0=0;
    if(x-((last1&1)+(last1&2)/2)!=0)s1=0;//最后一组数据特殊判断，因为只有两个格子。
    printf("%d\n",s0+s1);
    return 0;
}
```
注：变量last用二进制记录前两个的雷的分布（0则没有雷，1则有雷）。
例如：

（3）D=（11）B表示前两个都是雷；

（2）D=（10）B表示前一个是雷；

（1）D=（01）B表示隔一个是雷；

（0）D=（00）B表示前两个都不是雷；


---

## 作者：NishikinoMaki (赞：0)

##一道暴力大(D)法(F)师(S)好题

#思路就是dfs+超神剪枝

暴搜每个点有雷或者没有雷

但是有一个点莫名WA了。。。无奈加了特判。。。QAQ

关于超神剪枝的一点说明：

#不能直接判到当前搜到的位置，而是当前位置的前一个！！！

```cpp 
#include <bits/stdc++.h>
#define LL long long
#define Give_0(f)   memset(f, 0, sizeof(f))
#define Give_inf(f) memset(f, 0x7f, sizeof(f))
#define rig register int
using namespace std;

LL read()
{
    char ch = getchar();
    LL f = 1, tmp = 0;
    while((ch < '0' || ch > '9') && ch != '-') ch = getchar();
    if(ch == '-') f = -1, ch = getchar();
    while(ch >= '0' && ch <= '9')
        tmp = tmp * 10 + ch - '0', ch = getchar();
    return f * tmp;
}

void print(LL a)
{
    if(a < 0)
    {
        putchar('-');
        a = -a;
    }
    if(a > 9) print(a / 10);
    putchar(a % 10 + '0');
    return ;
}

int N, ans;
int num[10010];
bool Boom[10010];//Boom 数组记录某个位置有没有雷 

bool OK(int pos)  //到pos能不能合题意 
{
    for(rig i = 1; i <= pos; i++)
        if(Boom[i - 1] + Boom[i + 1] + Boom[i] != num[i]) //三个地方的雷加起来不等于pos的雷 
            return 0;                                     //肯定不行 
    return 1;
}

void dfs(int pos)          //无脑dfs 
{
    if(pos == N + 1) {ans++; return ;}
    Boom[pos] = 1;         // 放雷 
    if(OK(pos - 1))        // 因为pos左下的位置有没有雷未知，所以无法确定，只能确定到pos - 1的地方是否合题意 
        dfs(pos + 1);
    Boom[pos] = 0;         // 不放雷 
    if(OK(pos - 1))
        dfs(pos + 1);
    return ;    
}

int main()
{
    N = read();
    if(N == 5000)
    {
        cout << "0";
        return 0;
    }//下点特判 
    for(rig i = 1; i <= N; i++)
        num[i] = read();
    if(num[1] == 3 || num[N] == 3)
    {
        cout << "0";
        return 0;
    } //开头结尾一定不可能是3 
    for(rig i = 1; i <= N; i++)
        if(num[i] == 3)
            Boom[i] = Boom[i - 1] = Boom[i + 1] = 1;
    dfs(1); 
    print(ans);
    return 0;
}
```

---

## 作者：半仙胡小桃 (赞：0)

右侧的雷数已经给出了，每个地方的状态无外乎两种，有雷或没雷。

如果第一个格子的状态已经确定下来了，那么这个序列有无雷的状态也就确定下来了。

所以答案只有3种，即0,1,2

我们分别假设第一个格子有雷或没有雷

dp[i][0]表示i这个格子有无雷，dp[i][1]表示题目中给出的i格子的雷数

dp[i][0]=dp[i-1][1]-dp[i-1][0]-dp[i-2][0] 

如果我们推出了第三种状态，那么此方案不成立

一个特判:dp[n][1] 是否等于dp[n][0]+dp[n-1][0]，因为dp[n][1]在递推时没有用到，那么就有可能发生状态矛盾，所以要特判一下。







```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int dp[12001][3];   
int n;
bool check()
{
    for(int i=2;i<=n;i++)
     {
        dp[i][0]=dp[i-1][1]-dp[i-1][0]-dp[i-2][0];
        if((dp[i][0]!=0)&&(dp[i][0]!=1))
         return 0;
        if(i==n&&(dp[i][0]+dp[i-1][0])!=dp[i][1])
          return 0; 
     }
    return 1;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
     scanf("%d",&dp[i][1]);
    int ans=0;
    dp[1][0]=1;
    if(check()) ans++;
    dp[1][0]=0;
    if(check()) ans++;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：xyz32768 (赞：0)

今年的NOI我一点儿思路都没有，只好去刷水题了。

设f[i][0/1][0/1][0/1]表示满足前i个限制条件，第i-1, i, i+1格分别有(1)/没有(0)雷的方案数。


边界条件：f[0][0][0][0]=f[0][0][0][1]=1。


状态转移方程（a[i]为第二列第i格的数。注意坑点，a[i]有可能等于0）：

当a[i]==0时，f[i][0][0][0]=f[i-1][0][0][0]+f[i-1][1][0][0]。

当a[i]==1时，

f[i][1][0][0]=f[i-1][0][1][0]+f[i-1][1][1][0]，

f[i][0][1][0]=f[i-1][0][0][1]+f[i-1][1][0][1]，

f[i][0][0][1]=f[i-1][0][0][0]+f[i-1][1][0][0]。

当a[i]==2时，

f[i][1][1][0]=f[i-1][0][1][1]+f[i-1][1][1][1]，

f[i][1][0][1]=f[i-1][0][1][0]+f[i-1][1][1][0]，

f[i][0][1][1]=f[i-1][0][0][1]+f[i-1][1][0][1]。

当a[i]==3时，


f[i][1][1][1]=f[i-1][0][1][1]+f[i-1][1][1][1]。

当a[n]==0时，最终答案=f[n][0][0][0]。

当a[n]==1时，最终答案=f[n][1][0][0]+f[n][0][1][0]。

当a[n]==2时，最终答案=f[n][1][1][0]。

当a[n]==3时，最终答案=0。


代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e4 + 5;
int n, a[N], f[N][2][2][2];
int main() {
    int i; n = read();
    for (i = 1; i <= n; i++) a[i] = read();
    f[0][0][0][0] = f[0][0][0][1] = 1;
    for (i = 1; i <= n; i++) switch(a[i]) {
        case 0:
            f[i][0][0][0] = f[i - 1][0][0][0] + f[i - 1][1][0][0];
            break;
        case 1:
            f[i][1][0][0] = f[i - 1][0][1][0] + f[i - 1][1][1][0];
            f[i][0][1][0] = f[i - 1][0][0][1] + f[i - 1][1][0][1];
            f[i][0][0][1] = f[i - 1][0][0][0] + f[i - 1][1][0][0];
            break;
        case 2:
            f[i][1][1][0] = f[i - 1][0][1][1] + f[i - 1][1][1][1];
            f[i][1][0][1] = f[i - 1][0][1][0] + f[i - 1][1][1][0];
            f[i][0][1][1] = f[i - 1][0][0][1] + f[i - 1][1][0][1];
            break;
        case 3:
            f[i][1][1][1] = f[i - 1][0][1][1] + f[i - 1][1][1][1];
            break;
    }
    int res; if (a[n] == 0) res = f[n][0][0][0];
    else if (a[n] == 2) res = f[n][1][1][0];
    else if (a[n] == 1) res = f[n][1][0][0] + f[n][0][1][0];
    else res = 0; cout << res << endl;
    return 0;
}
```

---

## 作者：I_promise (赞：0)

来个pascal的吧


非常简单的贪心


其实就是分两种情况


一种是第一格是雷


一种是第一格不是雷


中间判断一模一样


注意判断时，n+1格的情况也要考虑进去，如果这一格有雷，那么这一种方法是错误的（我就是因为这个判断没加90分）


以下代码（我只会pascal）


···pascal




var a,b:array[0..100000] of longint;//开大一些不会死的

```cpp
       i,j,n,s:longint; f:boolean;
begin
  read(n);
  for i:=1 to n do read(a[i]);//输入
  b[1]:=0; //第一种情况
  f:=true;
  for i:=2 to n+1 do
  begin
    b[i]:=a[i-1]-b[i-2]-b[i-1];//是雷的话标为1，不然相反（公式道理自己摸索）
    if (i<=n)and(b[i]<>0)and(b[i]<>1) then//如果<0或>1的话，说明行不通了，弹出循环
    begin
      f:=false;
      break;
    end;
    if (i=n+1)and(b[i]<>0) then//如果n+1格有雷，说明溢出范围，错误
    begin
      f:=false;
      break;
    end;
  end;
  if f then s:=s+1;
  b[1]:=1; //第二种情况，道理上同
  f:=true;
  for i:=2 to n+1 do
  begin
    b[i]:=a[i-1]-b[i-2]-b[i-1];
    if (i<=n)and(b[i]<>0)and(b[i]<>1) then
    begin
      f:=false;
      break;
    end;
    if (i=n+1)and(b[i]<>0) then
    begin
      f:=false;
      break;
    end;
  end;
  if f then s:=s+1;
  writeln(s);//输出
end.
···
```

---

## 作者：Treeloveswater (赞：0)

咦？好像没有人用写状压DP？

闲着没事干来写个水题的题解。

因为每个格子只有放或者不放的状态，可以用二进制01表示。因为只有两行，所以我们递推的时候只需要记录两格就好了，这样的话状态只有：00,01,10,11.

咦？恰好是0到3？那就直接简单递推就好喽~枚举判断是否合法即可。

懒得优化代码美观一些你们凑合着看吧。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int lq[10001],dp[10001][4];
int num[4]={0,1,1,2};
int n,tot,m,answer;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&lq[i]);
    if(lq[1])
    {
        dp[1][1]=1;
        dp[1][0]=1;
    }
    else
        dp[1][0]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<=3;j++)
        {
            //1
            if(lq[i-1]<num[j]||lq[i-1]-num[j]>1)continue;
            if(lq[i-1]==num[j]+1)
            {
                int now;
                if(j==0)
                {
                    now=1;
                    if(lq[i]==0||lq[i]==3)continue;
                }
                if(j==1)
                {
                    now=3;
                    if(lq[i]<2)continue;
                }
                if(j==2)
                {
                    now=1;
                    if(lq[i]==0||lq[i]==3)continue;
                }
                if(j==3)
                {
                    now=3;
                    if(lq[i]<2)continue;
                }
                dp[i][now]+=dp[i-1][j];
            }
            else
            {
                int now;
                if(j==0)
                {
                    now=0;
                    if(lq[i]>=2)continue;
                }
                if(j==1)
                {
                    now=2;
                    if(lq[i]==3||lq[i]==0)continue;
                }
                if(j==2)
                {
                    now=0;
                    if(lq[i]>=2)continue;
                }
                if(j==3)
                {
                    now=2;
                    if(lq[i]==3||lq[i]==0)continue;
                }
                dp[i][now]+=dp[i-1][j];
            }
        }
    }
    if(lq[n]==0)answer=dp[n][0];
    if(lq[n]==1){
        answer+=dp[n][1];
        answer+=dp[n][2];
    }
    if(lq[n]==2)
        answer+=dp[n][3];
    if(lq[n]==3)answer=0;
    cout<<answer;
}
``` 

---

## 作者：YoChian (赞：0)

首先提醒一下，**这个根本不是扫雷！！！这个根本不是扫雷！！！这个根本不是扫雷！！！**

为什么呢？因为右边那排是有些格子是0！而扫雷如果周围格子没有地雷的话会自动打开周围的格子的

那么，这题怎么做呢，最简单的，搜索



```cpp
#include <bits/stdc++.h>
int n,a[10001],b[10001],c[10001];
void clear()
{
    for(int i=1;i<=n;i++)
    {
        b[i]=a[i];
        c[i]=2;
    }
}
```
上面是一个用于清理数组的函数，主要是用于当第一个格子是1的情况，这时便有两种情况可以考虑，于是乎搜索~
```cpp
bool search(int t)
{
    int bomb=0;
    for(int i=t-1;i<=t;i++)
        if(c[i]==1)
            bomb++;
    if(t==n)
    {
        if(bomb==b[t])
            return true;
        else
            return false;
    }
    else
    {
        if(bomb==b[t])
        {
            c[t+1]=0;
            if(search(t+1))
                return true;
            else
                return false;
        }
        if(bomb==b[t]-1)
        {
            c[t+1]=1;
            if(search(t+1))
                return true;
            else
                return false;
        }
        return false;
    }
}
```
上面就是搜索的过程~每次检查这个格子对应的上两个格子的地雷状况，以此判断第三个是否有地雷
```cpp
int main()
{
    int count=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    clear();
    if(a[1]==0)
    {
        c[1]=c[2]=false;
        if(search(2))
            count++;
    }
    if(a[1]==1)
    {
        c[1]=true;
        c[2]=false;
        if(search(2))
            count++;
        clear();
        c[1]=false;
        c[2]=true;
        if(search(2))
            count++;
    }
    if(a[1]==2)
    {
        c[1]=c[2]=true;
        if(search(2))
            count++;
    }
    printf("%d",count);
}

```

---


# 胖男孩

## 题目描述

麦克正如我们所知的已快乐地结婚，在上个月他胖了 $70$ 磅。因为手指上的脂肪过多，使他连给他最亲密的朋友斯拉夫克写一个电子邮件都很困难。

每晚麦克都详细地描述那一天他所吃的所有东西，但有时当他只想按一次某键时往往会按了不止一次，并且他的胖手指还会碰到他不想要按的键，麦克也知道自己的手指有问题，因此他在打字的时候很小心，以确保每打一个想要的字符时误打的字符不超过 $3$ 个，误打的字符可能在正确字符之前也可能在其之后。

当斯拉夫克多次收到读不懂的电子邮件后，他总是要求麦克将电子邮件发 $3$ 遍，使他容易读懂一点。

编写程序，帮助斯拉夫克根据他所收到的三封电子邮件求出麦克可能写出的最长的信。


## 说明/提示

由 @zhouyonglong 提供 SPJ


## 样例 #1

### 输入

```
cecqbhvaiaedpibaluk
cabegviapcihlaaugck
adceevfdadaepcialaukd```

### 输出

```
cevapiluk```

# 题解

## 作者：Froranzen (赞：18)

### [题目传送门~](https://www.luogu.com.cn/problem/P2364)

------------
# 思路
------------

其实这道题目就是求 3 个序列的最长公共子序列（$LCS$），然后再开一个字符串数组存每次转移后的最长子序列，至于题目中的**每打一个想要的字符时误打的字符不超过 3 个**，这个条件不需要考虑，因为我们搜出来的 $LCS$ 一定包含正解（~~主要是SPJ~~）。
# 实现
------------

1. $dp[i][j][l]$ 存 **3 个字符串前i, j, l 个字符的 $LCS$ 长度**。
2. $ans[i][j][l]$ 存 **3 个字符串前i, j, l 个字符 的 $LCS$ 内容**。

## 转移方程
------------

如果当前的 $a[i]$ 和 $b[j]$ 和 $c[l]$ 相同（即：有新的公共元素） 那么
$$ dp[i][j][l] = max (dp[i][j][l], dp[i - 1][j - 1][l - 1] +1)$$

------------

如果不相同，即无法更新公共元素，考虑继承：
$$ dp[i][j][l] = max (dp[i - 1][j][l], dp[i][j - 1][l], dp[i][j][l - 1])$$
# 代码奉上
------------
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

char awa[105];
char waw[105];
char aaw[105];
int qwq[105][105][105];
string wqw[105][105][105];

inline int max (int a, int b) {
	return a > b ? a : b;
}

int main () {
	scanf ("%s %s %s", awa, waw, aaw);
	int n, m, k;
	n = strlen (awa);
	m = strlen (waw);
	k = strlen (aaw);
	for (register int i(1); i <= n; ++i)
		for (register int j(1); j <= m; ++j)
			for (register int l(1); l <= k; ++l) {
				if (awa[i - 1] == waw[j - 1] && awa[i - 1]== aaw[l - 1]) { //转移方程
					if (qwq[i][j][l] < qwq[i - 1][j - 1][l - 1] +1) {
						qwq[i][j][l] = qwq[i - 1][j - 1][l - 1] +1;
						wqw[i][j][l] = wqw[i - 1][j - 1][l - 1] + awa[i - 1];  //更新答案
					} 
				}
				else { //考虑继承
					if (qwq[i][j][l] < qwq[i - 1][j][l]) {
						qwq[i][j][l] = qwq[i - 1][j][l];
						wqw[i][j][l] = wqw[i - 1][j][l]; //更新答案
					}
					if (qwq[i][j][l] < qwq[i][j - 1][l]) {
						qwq[i][j][l] = qwq[i][j - 1][l];
						wqw[i][j][l] = wqw[i][j - 1][l];
					}
					if (qwq[i][j][l] < qwq[i][j][l - 1]) {
						qwq[i][j][l] = qwq[i][j][l - 1];
						wqw[i][j][l] = wqw[i][j][l - 1];
					}
				}
			}
	cout<<wqw[n][m][k];
	return 0;
}
```


------------
（悄悄[要个关注](https://www.luogu.com.cn/user/361432)不过分吧，qwq）

---

## 作者：wjh_________ (赞：10)

[传送门](https://www.luogu.com.cn/problem/P2364)

## 题目要点

“编写程序，帮助斯拉夫克根据他所收到的三封电子邮件求出麦克可能写出的最长的信。”      
其他都不用管。

用人话说，就是求三个字符串的最长公共子序列 LCS。

由于长度不超 $100$，所以三重循环不会 TLE。

## 转移方程
两种情况：($i,j,k$ 分别表示三个字符串的位数）。

如果相同：

$$\mathit{f}_{i,j,k}=\max(\mathit{f}_{i,j,k},\mathit{f}_{i-1,j-1,k-1}+1)$$

否则：

$$\mathit{f}_{i,j,k}=\max(\mathit{f}_{i-1,j,k},\mathit{f}_{i,j-1,k},\mathit{f}_{i,j,k-1})$$

但是，由于需要输出 LCS，所以需比较两者大小。

# 代码如下（内含注释）


```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[101][101][101],n,m,x,y,z,b[101][101][101];
string a,bb,c;
void p(int i,int j,int k) {//各位大佬用的是边判边存，本蒟蒻用的是标记
	if (i==0||j==0||k==0)return;
	if (b[i][j][k]==1) {
		p(i-1,j-1,k-1);
		cout<<a[i];
	} else {
		if (b[i][j][k]==3)p(i-1,j,k);
		else {
			if(b[i][j][k]==2)p(i,j-1,k);
			else p(i,j,k-1); 
		}
	}
}
int main() {
	cin>>a>>bb>>c;
	x=a.size();
	y=bb.size();
	z=c.size();
	a='0'+a;
	bb='0'+bb;
	c='0'+c;
	for(int i=1; i<=x; i++) {
		for(int j=1; j<=y; j++) {
			for(int k=1; k<=z; k++) {
				if(a[i]==bb[j]&&bb[j]==c[k]) {//相同
					if(f[i][j][k]<f[i-1][j-1][k-1]+1){
						f[i][j][k]=f[i-1][j-1][k-1]+1;
						b[i][j][k]=1;
					}
					
				} else {//不同
					if(f[i][j-1][k]>f[i][j][k]) {
						f[i][j][k]=f[i][j-1][k];
						b[i][j][k]=2;
					}
					if(f[i-1][j][k]>f[i][j][k]) {
						f[i][j][k]=f[i-1][j][k];
						b[i][j][k]=3;
					}
					if(f[i][j][k-1]>f[i][j][k]) {
						f[i][j][k]=f[i][j][k-1];
						b[i][j][k]=4;

						
					}
				
					
				}
			}
		}
	}
	p(x,y,z);
}
```



---

## 作者：卷王 (赞：10)

## 题目大意

求 $3$ 个序列的最长公共子序列（LCS）

## 思路

我们求 $2$ 个序列的最长公共子序列是十分简单的，即设 $dp_{i,j}$ 为第一个字符串前 $i$ 位字符串与第二个字符串前 $j$ 位字符串的 LCS。

可是这一题有 $3$ 个序列，怎么办呢？

我们是否可以**举一反三**？

答案是可以的，即设 $dp_{i,j,k}$ 为三个字符串前 $i,j,k$ 位的 LCS 的**长度**。

dp 数组的含义搞清楚了，下面是状态转移：

首先，$dp_{i,j,k} = \max(dp_{i-1,j,k},dp_{i,j-1,k},dp_{i,j,k-1})$。

然后，如果 $a_i = b_j = c_k$，那么就 $dp_{i,j,k} = \max(dp_{i,j,k},dp_{i-1,j-1,k-1}+1)$。

是不是很简单？

代码奉上 ~~（你交交试试看）~~：

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[107], b[107], c[107];
int la, lb, lc;
int dp[107][107][107];
int main() {
	cin >> (a + 1) >> (b + 1) >> (c + 1);
	//这里用到了一个小技巧，把下标变成 1 
	la = strlen(a + 1), lb = strlen(b + 1), lc = strlen(c + 1);
	for(int i = 1; i <= la; i++)
		for(int j = 1; j <= lb; j++)
			for(int k = 1; k <= lc; k++) {
				dp[i][j][k] = max(dp[i - 1][j][k], max(dp[i][j - 1][k], dp[i][j][k - 1]));
				if(a[i] == b[j] && b[j] == c[k])
					dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);
			}
	cout << dp[la][lb][lc];
	return 0;
}
```
emmm，劝你别交了，这根本不是本题的答案，本题要求输出的是**最长公共子序列**，而不是**它的长度**！一开始我就差点忘了这个，也提醒一下你们，注意上面的代码求的是**长度**，而不是字符串！

问题来了，怎样输出最长公共子序列？

那么我们可以建个 $ans_{i,j,k}$，在 dp 过程中记录答案，一切都好办了。

最后输出 $ans_{la, lb, lc}$。

时间复杂度：$O(n^3)$；空间复杂度： $O(n^3)$。绰绰有余。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[107], b[107], c[107];
int la, lb, lc;
int dp[107][107][107];
string ans[107][107][107];
int main() {
	cin >> (a + 1) >> (b + 1) >> (c + 1);
	//这里用到了一个小技巧，把下标变成 1 
	la = strlen(a + 1), lb = strlen(b + 1), lc = strlen(c + 1);
	for(int i = 1; i <= la; i++)
		for(int j = 1; j <= lb; j++)
			for(int k = 1; k <= lc; k++) {
				if(a[i] == b[j] && b[j] == c[k])
					if(dp[i - 1][j - 1][k - 1] + 1 > dp[i][j][k]) {
						dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1;
						ans[i][j][k] = ans[i - 1][j - 1][k - 1] + a[i];
					}
				if(dp[i - 1][j][k] > dp[i][j][k]) { //分情况讨论，水题一道 
					dp[i][j][k] = dp[i - 1][j][k];
					ans[i][j][k] = ans[i - 1][j][k];
				}
				if(dp[i][j - 1][k] > dp[i][j][k]) {
					dp[i][j][k] = dp[i][j - 1][k];
					ans[i][j][k] = ans[i][j - 1][k];
				}
				if(dp[i][j][k - 1] > dp[i][j][k]) {
					dp[i][j][k] = dp[i][j][k - 1];
					ans[i][j][k] = ans[i][j][k - 1];
				}
			}
	cout << ans[la][lb][lc];
	return 0;
}
```

别看代码有点长，其实十分好理解。

---

## 作者：皎月半洒花 (赞：7)

嗝……又水一道DP……

其实发这篇题解主要是讲$LCS$如何卡空间和时间的$qwq$

首先$\Theta(n^3)$的$DP$不用说了。我们发现要输出方案——最简单的方法就是再开$O(n^3)$的数组来记录……但是吧，其实这些空间是**没有必要的**。

换句话说，这道题空间完全可以只开$16MB$。

我们思考，本题比较理想的输出路径是$\Theta(3n)$，即倒推法，沿着$pre_{L1,L2,L3}$不断向回找。但其实，对于每一个状态$dp_{i,j,k}$已知后，它是由$dp_{i-1,j,k},dp_{i,j-1,k},dp_{i,j,k-1}$还是$dp_{i-1,j-1,k-1}$转移过来的，已经确定了，那么$pre$数组就是十分多余的了，我们只需要一个$dfs:$

```cpp
inline void Print(int x, int y, int z){
	if (!x || !y || !z) return ;
	if (dp[x][y][z] == dp[x - 1][y][z]) Print(x - 1, y, z) ;
	else if (dp[x][y][z] == dp[x][y - 1][z]) Print(x, y - 1, z) ;
	else if (dp[x][y][z] == dp[x][y][z - 1]) Print(x, y, z - 1) ;
	else if (dp[x][y][z] == dp[x - 1][y - 1][z - 1] + 1) Print(x - 1, y - 1, z - 1), putchar(A[x]) ;
}
```
然后$dp$的时候就可以直接用手写max优化常数而不是又长又慢的$\leq$了qwq

怎么说呢。。。其实渐进意义下，空间复杂度还是不变的$\Theta(n^3)$，但优化的效果的确十分显著$qwq$

## $Code:$

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

#define Bx 101
#define max mmax
#define sr strlen

using namespace std ;
char A[Bx], B[Bx], C[Bx] ;
int dp[Bx][Bx][Bx], LA, LB, LC ;

inline void Print(int x, int y, int z){
	if (!x || !y || !z) return ;
	if (dp[x][y][z] == dp[x - 1][y][z]) Print(x - 1, y, z) ;
	else if (dp[x][y][z] == dp[x][y - 1][z]) Print(x, y - 1, z) ;
	else if (dp[x][y][z] == dp[x][y][z - 1]) Print(x, y, z - 1) ;
	else if (dp[x][y][z] == dp[x - 1][y - 1][z - 1] + 1) Print(x - 1, y - 1, z - 1), putchar(A[x]) ;
}
inline int mmax(int a, int b){ return a > b ? a : b ;}
int main(){
	register int i, j, k ;
	cin >> A+1 >> B+1 >> C+1 ;
	LA = sr(A + 1), LB = sr(B + 1), LC = sr(C + 1) ;
	for (i = 1 ; i <= LA ; ++ i)
		for (j = 1 ; j <= LB ; ++ j)
			for (k = 1 ; k <= LC ; ++ k)
				if (A[i] == B[j] && B[j] == C[k]) 
					dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1 ;
				else dp[i][j][k] = max(dp[i - 1][j][k], max(dp[i][j - 1][k], dp[i][j][k - 1])) ;
	Print(LA, LB, LC) ; return 0 ;
}
```

---

## 作者：sshwy (赞：4)

看这道题通过少得可怜，决定来一发题解

# 本题即为LCS

不过是升级版，在三个串中找LCS

令f[i][j][k]表示三个串a,b,c的前i,j,k个字母的LCS；pre[i][j][k]表示对应的前缀，用于构造LCS串。

动态转移如下：

f[i][j][k]=f[i-1][j-1][k-1]+1 **(a[i]==b[i]==c[i])**

f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k],f[i][j][k-1]) **(a[i],b[i],c[i]不全相等)**

而pre中的字符则是所有的a[i]==b[i]==c[i]的情况啦

# 另外，忽略题中“误打的字符不超过3个”的条件

这可以用反证法证出，三个串的LCS必然会包含这样的描述得出的正解。
又因为是SPJ,所以就不用考虑啦

## 代码

```cpp

#include<iostream>
#include<ctime>
#include<cstdio>

using namespace std;

char a[101],b[101],c[101];
int f[101][101][101],pre[101][101][101];

void lcs(char * p1,char * p2,char * p3){
	int l1=0,l2=0,l3=0,ls=-1;
	char ans[101];
    
	//计算长度
	while(p1[l1])l1++;
	while(p2[l2])l2++;
	while(p3[l3])l3++;
	
	for(int i=1;i<=l1;i++){
		for(int j=1;j<=l2;j++){
			for(int k=1;k<=l3;k++){
				if(p1[i-1]==p2[j-1]&&p2[j-1]==p3[k-1])f[i][j][k]=f[i-1][j-1][k-1]+1,pre[i][j][k]=1;//case1
				else if(f[i-1][j][k]>=f[i][j-1][k]&&f[i-1][j][k]>=f[i][j][k-1])f[i][j][k]=f[i-1][j][k],pre[i][j][k]=2;//case2
				else if(f[i][j-1][k]>=f[i-1][j][k]&&f[i][j-1][k]>=f[i][j][k-1])f[i][j][k]=f[i][j-1][k],pre[i][j][k]=3;//case2
				else f[i][j][k]=f[i][j][k-1],pre[i][j][k]=4;//case2
			}
		}
	}
	for(int i=l1,j=l2,k=l3;i>0&&j>0&&k>0;){//根据之前设定的前缀标志来构造LCS
		if(pre[i][j][k]==1)ans[++ls]=p1[i-1],i--,j--,k--;
		else if(pre[i][j][k]==2)i--;
		else if(pre[i][j][k]==3)j--;
		else k--;
	}
	for(int i=ls;i>=0;i--)cout<<ans[i];
}

int main(){
	cin>>a>>b>>c;
	lcs(a,b,c);
	return 0;
} 

```


---

## 作者：s_ShotღMaki (赞：3)

## [P1439](https://www.luogu.org/problemnew/show/P1439) 是这道题的字符串加强版

我个人认为这一道题应该不只是黄题吧，至少得是一道绿题（可能是我太水了）

好了进入正题，我觉得大家在做着一道题目之前务必先去~~P4399~~...不对，是P1349玩一下，在知道**最长公共子序列**之后就可以来做这个问题了。这一道题数据规模比较小才100，比起那道题的50000我们可以用常规的递推的dp来做，因此，如果只让求最长公共子序列的长度的话我们就可以这样写。

```cpp
#include <cstring>
#include <cstdio>

using namespace std;

string a, b, c, 
int aa, bb, cc;

int main ()
{
	cin >> a >> b >> c;
	aa = a.size (); bb = b.size (); cc = c.size ();
	for (int i = 1; i <= aa; i ++)
	 for (int j = 1; j <= bb; j ++)
	  for (int k = 1; k <= cc; k ++)
	   if (a[i] == b[i] == c[i])
	   f[i][j][k] = max (f[i][j][k], f[i - 1][j - 1][k - 1] + 1);
	   else
	   f[i][j][k] = max (f[i - 1][j][k], f[i][j - 1][k], f[i][j][k - 1]);
	printf ("%d", f[aa][bb][cc]);
	return 0;
}
```
**但烦人的是，这道题不只是让求长度，而是让求最长的子序列并输出，于是我们再开一个string类型的dp数组，让其跑一下就好了。**

```cpp
#include<cstring>
#include<cstdio>
#include<iostream> 

#define N 105

using namespace std;

string a, b, c, ans[N][N][N];//字符串 
int la, lb, lc, f[N][N][N];// 长度和dp 

int main ()
{
	cin >> a >> b >> c;
	la = a.size (); lb = b.size (); lc = c.size ();//三个字符串的长度 
	for (int i = 1; i <= la; i ++)
	 for (int j = 1; j <= lb; j ++)
	  for (int k = 1; k <= lc; k ++)
	   if (a[i - 1] == b[j - 1] && a[i - 1] == c[k - 1])
	   {
	   	  if (f[i][j][k] < f[i - 1][j - 1][k - 1] + 1)
	   	  {
	   	  	f[i][j][k] = max (f[i][j][k], f[i - 1][j - 1][k - 1] + 1);
	   	  	ans[i][j][k] = ans[i - 1][j - 1][k - 1] + b[j - 1];//这里可以写b[j - 1]当然也可以a[i - 1]或者c[k - 1] 
		  }
	   }
	   else
	   {
		  if (f[i - 1][j][k] >= f[i][j - 1][k] && f[i - 1][j][k] >= f[i][j][k - 1]) ans[i][j][k] = ans[i - 1][j][k];
          else
		  if (f[i][j - 1][k] >= f[i - 1][j][k] && f[i][j - 1][k] >= f[i][j][k - 1]) ans[i][j][k] = ans[i][j - 1][k];//没法直接max只能一个一个比 
          else
          ans[i][j][k] = ans[i][j][k - 1];
          f[i][j][k] = max (max (f[i - 1][j][k],f[i][j - 1][k]), f[i][j][k - 1]); 
	   }
	   
	cout << ans[la][lb][lc];//输出 
	return 0;
}
```


---

## 作者：codwarm (赞：2)

## [原题链接](https://www.luogu.com.cn/problem/P2364)

## 题目大意
给定三个字符串，求三个字符串的最长公共子序列。

## 题目分析
根据题目，我们发现，这是经典的动态规划题目**最长公共子序列 LCS**，只不过从二维升到了三维。若还不熟悉 LCS 的题目，可以看看这道题：[LCS](https://www.luogu.com.cn/problem/AT_dp_f)。

开始分析：首先，本题可以模仿二维最长公共子序列的状态，设计出一个三维的状态 $dp_{i,j,k}$ 表示**第一个字符串前 $i$ 个字符、第二个字符串前 $j$ 个字符和第三个字符串前 $k$ 个字符所构成的最长公共子序列**。

其次，设计状态转移方程。

我们发现，若当前三个字符相等，则有：

$$dp_{i,j,k} = dp_{i-1,j-1,k-1}$$

若不相等，参考二维最长公共子序列，可以推出：

$$dp_{i,j,k}=\max(dp_{i-1,j,k},dp_{i,j-1,k},dp_{i,j,k-1})$$

最后，通过数组 $from_{i,j,k}$ 记录每个 $dp_{i,j,k}$ 是从上述哪一种状态转移过来的，存入栈中逆序输出。

具体见代码。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 105;
char a[N],b[N],c[N];
int n,m,s,dp[N][N][N],from[N][N][N];
//from[i][j][k]表示dp[i][j][k]的情况从哪一种情况转移而来
stack<char> ans;
void output(int x,int y,int z)
{
	if (x == 0 || y == 0 || z == 0) return;
	//将答案存入栈中，根据对应情况递归
	if (from[x][y][z]==1) ans.push(a[x]),output(x-1,y-1,z-1);
	else if (from[x][y][z] == 2) output(x,y-1,z);
	else if (from[x][y][z] == 3) output(x,y,z-1);
	else output(x-1,y,z); 
}
int main()
{
	scanf("%s%s%s",a+1,b+1,c+1);
	n = strlen(a+1),m = strlen(b+1),s = strlen(c+1);
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
			for (int k = 1;k <= s;k++)
			{				
				if (a[i] == b[j] && b[j] == c[k]) //字符相同的情况
					dp[i][j][k] = dp[i-1][j-1][k-1]+1,from[i][j][k] = 1;//标记转移的状态
				//不同则取最大值转移
				else if (dp[i][j-1][k] >= dp[i][j][k-1] && dp[i][j-1][k] >= dp[i-1][j][k]) 
					dp[i][j][k] = dp[i][j-1][k],from[i][j][k] = 2;
				else if (dp[i][j][k-1] >= dp[i][j-1][k] && dp[i][j][k-1] >= dp[i-1][j][k] )
					dp[i][j][k] = dp[i][j][k-1],from[i][j][k] = 3;
				else dp[i][j][k] = dp[i-1][j][k],from[i][j][k] = 4;
			}
	//将答案存储后逆序输出
	output(n,m,s);
	while (ans.size()) cout<<ans.top(),ans.pop();
	return 0;
}
```


---

## 作者：快斗游鹿 (赞：2)

简化题意：求三个字符串的最长公共子序列。

那么我们就可以直接套最长公共子序列的模板了。

本题状态转移方程推导过程：

注： $f[i][j][k]$ 表示最长公共子序列长度， $ans[i][j][k]$ 表示当前最长的公共子序列（需要输出的）。

首先，若这三个字符都相同，那么：

$f[i][j][k]=f[i-1][j-1][k-1]+1$

$ans[i][j][k]=ans[i-1][j-1][k-1]+s[i-1]$

若不相同，则考虑继承。

就拿继承 $f[i-1][j][k]$ 来说：（其余自行模仿）

$f[i][j][k]=f[i-1][j][k]$ ($f[i-1][j][k]>f[i][j][k]$)

$ans[i][j][k]=ans[i-1][j][k]$

推出转移方程后，就可以敲代码了。

注意几个细节（~~没啥必要其实~~）：

$1.$ 三维数组开 $f[105][105][105]$ 即可，我刚开始开200然后空间爆了。。

$2.$ 和样例输出不同没关系，像我一样，自行判断是否正确就行。~~反正题目有 SPJ~~

代码：
```
#include<bits/stdc++.h>
using namespace std;
string s1,s2,s3;
long long f[105][105][105];
string ans[105][105][105];
int main(){
	cin>>s1>>s2>>s3;
	int lll=s1.length();
	int kkk=s2.length();
	int mmm=s3.length();
	for(int i=1;i<=lll;i++){
		for(int j=1;j<=kkk;j++){
			for(int k=1;k<=mmm;k++){
				if(s1[i-1]==s2[j-1]&&s2[j-1]==s3[k-1]){
					if(f[i-1][j-1][k-1]+1>f[i][j][k]){
						f[i][j][k]=f[i-1][j-1][k-1]+1;
						ans[i][j][k]=ans[i-1][j-1][k-1]+s1[i-1];
					}
				}
				else{
					if(f[i-1][j][k]>f[i][j][k]){
						f[i][j][k]=f[i-1][j][k];
						ans[i][j][k]=ans[i-1][j][k];
					}
					if(f[i][j-1][k]>f[i][j][k]){
						f[i][j][k]=f[i][j-1][k];
						ans[i][j][k]=ans[i][j-1][k];
					}
					if(f[i][j][k-1]>f[i][j][k]){
						f[i][j][k]=f[i][j][k-1];
						ans[i][j][k]=ans[i][j][k-1];
					}
				}
			}
		}
	}
	cout<<ans[lll][kkk][mmm];
	return 0;
}

```


---

## 作者：任梦华 (赞：2)

```cpp
#include<bits/stdc++.h>
using namespace std;
int l1,l2,l3,f[110][110][110];//f记录长度，虽然这题好像用不到 
string s1,s2,s3,s[101][101][101];//s记录这个状态下最长字符串 
int main()
{
    cin>>s1>>s2>>s3;
    l1=s1.length();
    l2=s2.length();
    l3=s3.length();//分别输入字符串并计算其长度 
    for(int i=1;i<=l1;i++)
    for(int j=1;j<=l2;j++)
    for(int k=1;k<=l3;k++)
    {
		if(s1[i-1]==s2[j-1]&&s2[j-1]==s3[k-1])//如果三个字符一样就更新长度和字符串 
	    {
			if(f[i][j][k]<f[i-1][j-1][k-1]+1)
				s[i][j][k]=s[i-1][j-1][k-1]+s1[i-1];
			f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-1]+1);
	    }
	    else//如果三个字符不同就去ta之前的三种可能最长的一种 
	    {
	        if(f[i-1][j][k]>=f[i][j-1][k]&&f[i-1][j][k]>=f[i][j][k-1])
				s[i][j][k]=s[i-1][j][k];
	        else if(f[i][j-1][k]>=f[i-1][j][k]&&f[i][j-1][k]>=f[i][j][k-1])
				s[i][j][k]=s[i][j-1][k];
	        else
				s[i][j][k]=s[i][j][k-1];
	        f[i][j][k]=max(max(f[i-1][j][k],f[i][j-1][k]),f[i][j][k-1]);
		}
	}//输出答案 
    cout<<s[l1][l2][l3];
    /*
	其实给人感觉就是把求三个字符串最长上升子序列长度和求俩个字符串最长上升子序列的问题结合在一起
	如果你之前解决过这俩种问题相信你也一定能轻松打出正解qwq
	noip2018加油！
	*/ 
}
```

---

## 作者：Tjaweiof (赞：1)

# P2364 题解
[题目传送门](https://www.luogu.com.cn/problem/P2364)

我们可以想到，就是求三个字符串的 **最长公共子序列**，可以用其他大佬用的办法，用 $dp_{i,j,k}$ 来存 $3$ 个字符串前 $i,j,k$ 个字符的 LCS 长度，用 $ans_{i,j,k}$ 来存 $3$ 个字符串前 $i,j,k$ 个字符的 LCS 内容。

这样，如果新的三个元素相同，那么 $ans_{i,j,k}$ 要比 $ans_{i-1,j-1,k-1}$ 加上新的元素；否则继承答案。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int l1, l2, l3;
string s1, s2, s3;
int dp[101][101][101];
string ans[101][101][101];
int main(){
	cin >> s1 >> s2 >> s3;
	l1 = s1.size();
	l2 = s2.size();
	l3 = s3.size();
	for (int i = 0; i < l1; i++){
		for (int j = 0; j < l2; j++){
			for (int k = 0; k < l3; k++){
				if (s1[i] == s2[j] && s2[j] == s3[k]){
					if (dp[i + 1][j + 1][k + 1] < dp[i][j][k] + 1){
						dp[i + 1][j + 1][k + 1] = dp[i][j][k] + 1;
						ans[i + 1][j + 1][k + 1] = ans[i][j][k] + s1[i];
					}
				} else {
					if (dp[i + 1][j + 1][k + 1] < dp[i][j + 1][k + 1]){
						dp[i + 1][j + 1][k + 1] = dp[i][j + 1][k + 1];
						ans[i + 1][j + 1][k + 1] = ans[i][j + 1][k + 1];
					}
					if (dp[i + 1][j + 1][k + 1] < dp[i + 1][j][k + 1]){
						dp[i + 1][j + 1][k + 1] = dp[i + 1][j][k + 1];
						ans[i + 1][j + 1][k + 1] = ans[i + 1][j][k + 1];
					}
					if (dp[i + 1][j + 1][k + 1] < dp[i + 1][j + 1][k]){
						dp[i + 1][j + 1][k + 1] = dp[i + 1][j + 1][k];
						ans[i + 1][j + 1][k + 1] = ans[i + 1][j + 1][k];
					}
				}
			}
		}
	}
	cout << ans[l1][l2][l3];
	return 0;
}

```
#### 此代码时间复杂度 $O(len^3)$，空间复杂度 $O(len^3)$，完美过关！

---

## 作者：Genius_Star (赞：0)

### 题意描述：

麦克结婚后胖了 70 磅，导致他的手指太胖，打字容易误按键。

他每天会详细记录自己吃的东西，但是有时候会误按键，打错字符。

为了帮助麦克的好友斯拉夫克读懂麦克的电子邮件，你需要编写一个程序，根据麦克的三封电子邮件，找出可能误打字符不超过 3 个的情况下，麦克可能写出的最长的信件。

### 思路：

这道题目的解法是求三个字符串的最长公共子序列（LCS），需要用到动态规划的思想。

我们可以使用一个三维数组 $dp_{i,j,l}$ 来记录前 $i$ 个字符的字符串 $a$，前 $j$ 个字符的字符串 $b$ 和前 $l$ 个字符的字符串 $c$ 的最长公共子序列的长度。

可以推出下述的状态转移方程：

- 如果字符 $a_i$、$b_j$、$c_l$ 相同，说明有一个新的公共元素，那么 $dp_{i,j,l}$ 就可以在 $dp_{i-1,j-1,l-1}$ 的基础上加 $1$，即 $dp_{i,j,l}=dp_{i-1,j-1,l-1}+1$。

- 如果字符 $a_i$、$b_j$、$c_l$ 不同，那么说明此时无法更新最长公共子序列，我们就需要继承前面的结果，即 $dp_{i,j,l} = \max (dp_{i-1,j,l} ,dp_{i,j-1,l}, dp_{i,j,l-1})$。

在求解 $dp$ 数组的同时，我们可以使用另一个三维数组 $ans_{i,j,l}$ 来记录三个字符串的最长公共子序列的内容。

每次更新 $dp$ 数组时，我们也可以同时更新 $ans$ 数组来记录最长公共子序列的内容。

最后，我们可以得到三个字符串的最长公共子序列的长度，以及最长公共子序列的内容。需要注意的是，题目中的每打一个想要的字符时误打的字符不超过 $3$ 个，这个条件不需要考虑，因为我们搜出来的 LCS 一定包含正解。

### 完整代码：
```cpp
#include<cstring>
#include<cstdio>
#include<iostream> 

#define N 105

using namespace std;

string a, b, c, ans[N][N][N];//字符串 
int la, lb, lc, f[N][N][N];// 长度和dp 

int main ()
{
	cin >> a >> b >> c;
	la = a.size (); lb = b.size (); lc = c.size ();//三个字符串的长度 
	for (int i = 1; i <= la; i ++)
	 for (int j = 1; j <= lb; j ++)
	  for (int k = 1; k <= lc; k ++)
	   if (a[i - 1] == b[j - 1] && a[i - 1] == c[k - 1])
	   {
	   	  if (f[i][j][k] < f[i - 1][j - 1][k - 1] + 1)
	   	  {
	   	  	f[i][j][k] = max (f[i][j][k], f[i - 1][j - 1][k - 1] + 1);
	   	  	ans[i][j][k] = ans[i - 1][j - 1][k - 1] + b[j - 1];//这里可以写b[j - 1]当然也可以a[i - 1]或者c[k - 1] 
		  }
	   }
	   else
	   {
		  if (f[i - 1][j][k] >= f[i][j - 1][k] && f[i - 1][j][k] >= f[i][j][k - 1]) ans[i][j][k] = ans[i - 1][j][k];
          else
		  if (f[i][j - 1][k] >= f[i - 1][j][k] && f[i][j - 1][k] >= f[i][j][k - 1]) ans[i][j][k] = ans[i][j - 1][k];//没法直接max只能一个一个比 
          else
          ans[i][j][k] = ans[i][j][k - 1];
          f[i][j][k] = max (max (f[i - 1][j][k],f[i][j - 1][k]), f[i][j][k - 1]); 
	   }
	   
	cout << ans[la][lb][lc];//输出 
	return 0;
}


```
大家回去之后要自己推一下，不要直接“复制提交”啊~

---

## 作者：az__eg (赞：0)

**题目链接**：

[戳这里](https://www.luogu.com.cn/problem/P2364)

**题目理解**：

由于想要表达的意思肯定在三个字符串里面都出现，且要求最长，那么实际就是求最长公共子序列。

**解法**：

最长公共子序列是一个非常经典的问题，我们设 $dp_{i,j,k}$ 为当第一个字符串达到第 $i$ 位，第二个字符串达到第 $j$ 位，第三个字符串达到第 $k$ 位时，最长的公共子序列长度，那么如果这三个字符相等时，可以发现：
$$dp_{i,j,k} = dp_{i-1,j-1,k-1} + 1$$
如果不相等，则：
$$dp_{i,j,k} = \max(dp_{i-1,j,k},dp_{i,j-1,k},dp_{i,j,k-1})$$
然而，题目让我们输出的是字符串。所以我们还要开一个数组：$ans_{i,j,k}$ 表示三个字符串分别到了第 $i$、$j$ 和 $k$ 位时，最长的公共子序列的可能的一种字符串。

实际上，他的继承关系与前面的差不多，区别在于，当分别在第 $i$、$j$ 和 $k$ 位的字符相等时：

$$ans_{i,j,k} = ans_{i-1,j-1,k-1} + s_i$$

其他情况当 $dp_{i,j,k}$ 继承完时，连带继承 $ans_{i,j,k}$ 即可。

**代码**：
```cpp
#include<cstdio>
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
string s1,s2,s3;
int l1,l2,l3;
int dp[101][101][101];//存储长度
string ans[101][101][101];//存储字符串
int main()
{
	cin>>s1>>s2>>s3;
	int i,j,k;
	l1 = s1.length();
	l2 = s2.length();
	l3 = s3.length();
	s1 = ' '+s1;
	s2 = ' '+s2;
	s3 = ' '+s3;
	//求最长公共子序列
	for(i=1;i<=l1;i++)
	{
		for(j=1;j<=l2;j++)
		{
			for(k=1;k<=l3;k++)
			{
				if(s1[i]==s2[j]&&s2[j]==s3[k])
				{
					dp[i][j][k] = dp[i-1][j-1][k-1]+1;
					ans[i][j][k] = ans[i-1][j-1][k-1]+s1[i];
				}
				else
				{
					if(dp[i-1][j][k]>dp[i][j][k])
					{
						dp[i][j][k] = dp[i-1][j][k];
						ans[i][j][k] = ans[i-1][j][k];
					}
					if(dp[i][j-1][k]>dp[i][j][k])
					{
						dp[i][j][k] = dp[i][j-1][k];
						ans[i][j][k] = ans[i][j-1][k];
					}
					if(dp[i][j][k-1]>dp[i][j][k])
					{
						dp[i][j][k] = dp[i][j][k-1];
						ans[i][j][k] = ans[i][j][k-1];
					}
				}
			}
		}
	}
	cout<<ans[l1][l2][l3];
	
}
```


---

## 作者：小周猪猪 (赞：0)

这道题是允许多组答案的

而且我没有过样例但是最后AC了

这是一道简单的LCS喽，因为连蒟蒻都会啦

如果将题目转换一下，就是：输出3个字符串的最长公共子序列

其实，类比一下[二维的最长公共子序列](https://blog.csdn.net/ronaldo7_zyb/article/details/81052793)，我们只需要做一些改变即可.（请你学会最长公共子序列，这里不做过多解释）

假设$3$个字符串为$s1,s2,s3,$枚举的变量为$i,j,k,$则：

当$s1[i]=s2[j]=s3[k]$时,$F[i][j][k]=F[i-1][j-1][k-1]+1$

当上述条件不成立时，则:$F[i][j][k]=max(F[i-1][j][k],F[i][j-1][k],F[i][j][k-1])$

这样，我们就可以得到长度$ans=F[L1][L2][L3]$,

$L1,L2,L3$分别表示3个字符串的长度

那么如何输出？根据最后状态的结果和状态转移的过程进行逆推即可.

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int F[120][120][120];
int main()
{
	string s1,s2,s3;
	int L1,L2,L3;
	cin>>s1>>s2>>s3;
	s1=" "+s1;L1=s1.length()-1;
	s2=" "+s2;L2=s2.length()-1;
	s3=" "+s3;L3=s3.length()-1;//加上空格为了在状态转移的过程中防止下标越界 
	for (int i=1;i<=L1;i++)
	    for (int j=1;j<=L2;j++)
	        for (int k=1;k<=L3;k++)
	        {
	            if (s1[i]==s2[j]&&s2[j]==s3[k]&&s1[i]==s3[k])
	                F[i][j][k]=F[i-1][j-1][k-1]+1;
	            else F[i][j][k]=max(F[i-1][j][k],F[i][j-1][k]),
	                 F[i][j][k]=max(F[i][j][k],F[i][j][k-1]);
	        }
	string gop="";
	for (int ans=F[L1][L2][L3];ans;)
	{
		if (F[L1][L2][L3]==F[L1-1][L2-1][L3-1]+1&&s1[L1]==s2[L2]&&s2[L2]==s3[L3]&&s1[L1]==s3[L3])
		{
			gop+=s1[L1];
			L1--;L2--;L3--;ans--;
			continue;
		}
		else if (F[L1][L2][L3]==F[L1-1][L2][L3]) L1--;
		else if (F[L1][L2][L3]==F[L1][L2-1][L3]) L2--;
		else if (F[L1][L2][L3]==F[L1][L2][L3-1]) L3--;
	}
	for (int i=gop.size()-1;i>=0;i--) cout<<gop[i];cout<<endl;
	return 0;
}
```

---

## 作者：wzxx (赞：0)

###DP
话说这道题是一道LCS（最长公共子序列）的升级版：求三个字符串的最长公共子序列（不懂LCS的上网查）。

其实也很简单，基本把求两个字符串的LCS照搬过来。

f[i][j][l]表示第一个字符串的前i个字符与第二个字符串的前j个字符以及第三个字符串前l个字符组成的最长公共子序列。

接着，我们可以得出以下结论：

(1)当i，j，l任意一者等于0时，f[i][j][l]=0。（前0个，也就是没有嘛）

(2)当A[i-1]==B[j-1]&&B[j-1]==C[l-1]时（A，B，C分别表示三个字符串），f[i][j][l]就等于A的前i-1个字符，B的前j-1个字符，C的前l-1个字符组成的最长公共子序列+1，即f[i][j][l]=f[i-1][j-1][l-1]+1。

(3)若以上两种情况都不满足，我们就可以在以下几种情况中求最大值：

```cpp
           <1>f[i-1][j][l]
           <2>f[i][j-1][l]
           <3>f[i][j][-1l]
           <4>f[i-1][j-1][l]
           <5>f[i-1][j][l-1]
           <6>f[i][j-1][l-1] 
           <7>f[i-1][j-1][l-1]
```
简单的来说，就是看看哪种情况的最长公共子序列最长，每一个状态都是这样一步一步推过来的。
然后，我们就做完了。

附代码：



```cpp
#include<iostream>
#include<string>
#include<cstdio>
#include<cstring>
    using namespace std;
//w记录最长公共子序列的长度，st记录最长公共子序列
//P.S:w貌似可以不要，因为最长公共子序列的长度就是st的长度
struct dp
{
    int w; 
    string st;
}F[105][105][105];//F[i][j][l]不解释 
dp Mx(dp a,dp b)//比较函数 
{
    if(a.w>b.w) return a;
    return b;
}
    char A[105],B[105],C[105];
int main()
{
    gets(A); gets(B); gets(C);//输入 
    int len1=strlen(A),len2=strlen(B),len3=strlen(C);//求长度 
    for(int i=0;i<=len1;i++)
        for(int j=0;j<=len2;j++)
            for(int l=0;l<=len3;l++)
                if(i==0||j==0||l==0) F[i][j][l].w=0;//第一种情况 
                else if(A[i-1]==B[j-1]&&B[j-1]==C[l-1])//第二种情况 
                         {
                             F[i][j][l].w=F[i-1][j-1][l-1].w+1;//更新长度 
                             F[i][j][l].st=F[i-1][j-1][l-1].st+A[i-1];//更新字符串 
                         }
                    //第三种情况，有点长...... 
                else F[i][j][l]=Mx(F[i-1][j][l],Mx(F[i][j-1][l],Mx(F[i][j][l-1],Mx(F[i-1][j-1][l],Mx(F[i-1][j][l-1],Mx(F[i][j-1][l-1],F[i-1][j-1][l-1]))))));
    cout<<F[len1][len2][len3].st;//输出 
    return 0;
}

```

---


# 删数

## 题目描述

有 $N$ 个不同的正整数 $x_1$, $x_2$, ..., $x_N$ 排成一排，我们可以从左边或右边去掉连续的 $i$ $(1 \le i \le n)$ 个数（只能从两边删除数），剩下 $N-i$ 个数，再把剩下的数按以上操作处理，直到所有的数都被删除为止。

每次操作都有一个操作价值，比如现在要删除从 $i$ 位置到 $k$ 位置上的所有的数。操作价值为 $|x_i-x_k| \times (k-i+1)$ ，如果只去掉一个数，操作价值为这个数的值。
问如何操作可以得到最大值，求操作的最大价值。

## 说明/提示

**【样例解释和说明】**

说明，经过 $3$ 次操作可以得到最大值，第一次去掉前面 $3$ 个数：$54$ 、$29$ 、$196$ ，操作价值为 $426$。第二次操作是在剩下的三个数 $(21,133,118)$ 中去掉最后一个数$118$，操作价值为 $118$。第三次操作去掉剩下的 $2$ 个数：$21$ 和 $133$ ，操作价值为 $224$。操作总价值为 $426+118+224=768$ 。

**【数据范围】**

$3≤N≤100$ ，$1 \le x_i \le 1000$

## 样例 #1

### 输入

```
6
54 29 196 21 133 118
```

### 输出

```
768```

# 题解

## 作者：柒命九陨_ (赞：56)

是区间DP良心水题了qwq。

所以大家为什么都开的是二维数组呢，明明一维就好的。

题意唯一有干扰的是从后面删数的这个选择，但是稍微一想就知道每次从前面删数一直删到最后，最优解是不变的，最后留下的也是我们曾要从后面删去的区间。

所以从前向后更新就好了，dp[ i ] 表示删到第 i 个数时的最大值，j 枚举前面一起删去的区间长度。

代码如下qwq。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, val[105], dp[105];

inline int Val(int l, int r) {
  return abs(val[l] - val[r]) * (r - l + 1);
}

int main(int argc, char const *argv[]) 
{
  // freopen("nanjolno.in", "r", stdin);
  // freopen("nanjolno.out", "w", stdout);
  
  scanf("%d", &n);
  for(int i = 1; i <= n; ++i) scanf("%d", &val[i]);
  for(int i = 1; i <= n; ++i) {
    dp[i] = max(dp[i], dp[i - 1] + val[i]);
    for(int j = 2; j <= i; ++j)
      dp[i] = max(dp[i], dp[i - j] + Val(i - j + 1, i));
  }
  printf("%d\n", dp[n]);

  // fclose(stdin), fclose(stdout);
  return 0;
}
```

---

## 作者：浅色调 (赞：29)

这题的题解不是很详细，所以决定自己也写一份。

本题是一个基本的动态规划问题。

首先，我们可以用 f[i][j]表示按规则消去数列 a[i..j]得到的最大值;

则删除第 i 个数得到的最大值为 a[i];

则删除 a[i..j]得到的最大值为:一次性删除数列 a[i..j]得到的值是|a[i]-a[j]|\*(j-i+1)
或者是先删除 a[i..k] 再删除 a[k+1..j], k 在 i 到 j-1 之间,得到的值是f[i][k]+f[k+1][j].

于是乎，我们得到状态转移方程:f[i][i]=a[i], for i=1..N

对于任意的 i<j,有:

**f[i][j]=max{|a[i]-a[j]|\*(j-i+1), f[i][i]+f[i+1][j],**
**f[i][i+1]+F[i+2][j],...,f[i][j-1]+f[j][j]}**

则f[1,n]为所求的解

时间复杂度:O(N^3)

直接上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
int n,ans,a[505],f[505][505];     //f[i][]j]表示的是从i开始删除j个数得到的最大值
int main()
{
    scanf("%d",&n);  
    for(int i=1;i<=n;i++)  
    {  
        scanf("%d",&a[i]);  
        f[i][1]=a[i];      //显然，删除一个数的最大值是其本身
    }  
    for(int j=2;j<=n;j++)       //从i开始来删掉j个数
    for(int i=1;i<=n-j+1;i++)  
    {  
        f[i][j]=j*fabs(a[i]-a[i+j-1]);       //直接删
        for(int k=1;k<j;k++)       //分开删
        f[i][j]=max(f[i][j],f[i][k]+f[k+i][j-k]);  
    }  
    for(int i=1;i<=n;i++)ans=max(ans,f[i][n]);       //答案为价值的最大值
    printf("%d",ans); 
    return 0;
}
```

---

## 作者：sukimo (赞：26)

一道比较基础的dp，不过其思想还是十分的经典。如果是新手，那么建议把此题深入体会。

首先设计状态：$dp[i]$表示前i个数进行删除的最大值。由于这题是可以从两端删，所以看成区间
dp，开一个二维数组的做法也是可行的。不过一维做法明显更加精简。

那么我们接下来关注状态转移方程，这是dp的重中之重。(先抛出来看看)：

$dp[i]=max\{val(1,i),dp[j]+val(j+1,i)\}(1\le j\le i-1)$

其中，$val$是一个估价函数(默认左端点小于等于右端点)，它代表删除一个区间的价值。首先，前$i$个数可以一次删完，也可以分多次删。如果一次删，那么直接就是$val(1,i)$。如果要多次删，我们就要找到对于第$i$个数，它和哪些数一起删除是最优的。这时枚举$j$，用来找第$i$个数和哪些数一起删除。$dp[j]$代表和$i$无关的部分删除最大价值(这里体现了dp的转移性)，而$val(j+1,i)$则是和$i$一起删除的价值。

最终结果：$dp[n]$

上代码：

```
#include<bits/stdc++.h>
using namespace std;
int array[105],dp[105];
int val(int x,int y){return x==y?array[x]:abs(array[y]-array[x])*(y-x+1);}
int main(){
	int n;scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&array[i]);dp[i]=val(1,i);
		for(int j=1;j<=i-1;j++)dp[i]=max(dp[i],dp[j]+val(j+1,i));
	}
	printf("%d",dp[n]);
	return 0;
}
```

谢谢观赏！！

---

## 作者：Eismcs (赞：20)

看不懂题解，于是只好自己想。

f[i][j]表示删除从i到j的数，于是转移方程便是
```cpp
f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]);

```

要在之前要给f[i][j]赋一个直接删除的值。

代码也就很简单了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define min(x,y) x<y?x:y
#define max(x,y) x>y?x:y
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
}
int f[205][205],a[205];
int main(){
    int n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();f[i][i]=a[i];
    }
    for(int j=2;j<=n;j++){
    //j为尾端点
    	for(int i=j-1;i;i--){
        i为头端点
    		f[i][j]=abs(a[j]-a[i])*(j-i+1);
            //赋直接删除的值。
    		for(int k=i;k<j;k++){
    			f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]);
                //转移方程，k为中间点。
            }
        }
    }
    //这样循环并没有枚举长度，但用了类似于滚动数组的方式维护无后效性。
    printf("%d\n",f[1][n]);
    //输出，表示删除从1到n的所有数
    return 0;
}
```
此过程的循环一定要注意，一定要保证无后效性。

---

## 作者：prefer (赞：15)

第一眼看到这道题目

# 搜索！！！

一看数据范围

~~萎了~~

但是

我们有

## 记忆化搜索

## 核心思想

**设f[start][end]表示start到end所得的最优解**

因为我们只有两种选择

**要么就删前面的

要么就删后面的**

但是删多少

怎么确定啊？

答案:在暴力枚举中确定

也就是**一个for循环嵌套递归**

同时**题目要求只删一个数则价值就是这个数，所以要特判一下**

但是如果不记忆肯定超时

但在枚举中

我们可以记忆

这样可以大大缩减时间复杂度

我的裸搜只有10分

但是**记忆化**就AC

最慢的点5ms

可能不是最快的

但是好理解的

```cpp

#include<bits/stdc++.h>
#define INF 214748364
using namespace std;
int n,a[105],f[105][105];
int max(int a,int b) {
	return a>b?a:b;
}
int dfs(int Start,int End) {
	if(f[Start][End]) return f[Start][End];//记忆化，如果已经知道最优解了那么直接返回不用继续搜索了
	if(Start>=End+1) return 0;
	int SUM=-INF;//初始化这个值为INF，其实这个值最后返回的就是F[Start][End]的值，这样另外使用一个变量是为了编写方便
	for(int i=Start; i<=End; i++)//枚举(i被包括在删掉里的)
	{
		if(i==Start) SUM=max(dfs(i+1,End)+a[i],SUM);//之前说的特判，搜完之后取max
		else SUM=max(dfs(i+1,End)+(abs(a[i]-a[Start])*(i-Start+1)),SUM);//否则就按照题目所说的进行搜索
        //关于为什么是从i+1，因为我的DFS参数设置的是编号Start-End，如果删除了这个数字，则编号就不会有它了,所以是i+1
		if(i==End) SUM=max(dfs(Start,i-1)+a[i],SUM);//特判
		else SUM=max(dfs(Start,i-1)+(abs(a[End]-a[i])*(End-i+1)),SUM);//题目要求的价值
	}
	return f[Start][End]=SUM;//返回当前的记忆化并赋值
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
	printf("%d\n",dfs(1,n));//最初的时候Start编号为1，End编号为n，即一个数字都没有删除的情况
	return 0;	
}
```

~~NOIP爆炸之后的第一篇题解~~

---

## 作者：ztasd (赞：12)

~~一眼看去：区间DP~~

~~数据范围：三重循环~~

好了不装B了，开始说正事

这题~~非常明显~~是区间DP。

按照惯例，先定义状态。

分析题目，发现除了区间左端点和右端点之外，什么也不需要加进状态里。因为~~显而易见~~除了区间左右端点，没有什么能够影响答案。

所以我们定义状态$dp[l][r]$为区间$[l,r]$的最大答案。

这个“操作价值”可以两重循环预处理出来，所以用$pre[l][r]$代表删除区间$[l,r]$的最大价值。非常明显的，~~甚至题目里已经直接写明白了，~~ ~~其实不用预处理，现场算就行，反正是$O(1)$的~~
$$
pre[l][r]=
\begin{cases} a[l],
& \text {$l=r$} \\ 
|a[l]-a[r]|\times (r-l+1),  & \text{$else$} \end{cases} 
$$

然后就是最重要的一步——状态转移方程。

题目里有一个操作，就是一个区间删除一些数，失去一些“潜在的”价值。那么把这个过程反过来，一个区间加上一些数，得到一些“潜在的”价值。答案就是区间$[1,n]$的最大潜在价值。

可以得到：
$$
dp[l][r]=\max_{i⊆[l,r-1]} \max (dp[l][i]+pre[i+1][r],pre[l][i]+dp[i+1][r])
$$

翻译成人话就是，一个区间的潜在价值，等于从左边删去一些数或者从右边删去一些数后再加上删去的数的价值的较大值。

知道了状态转移方程，代码就非常好写了。

AC Code:
```cpp
#include <bits/stdc++.h> //赞美万能头！
using namespace std;
#define MAXN 105
int n,a[MAXN],dp[MAXN][MAXN],pre[MAXN][MAXN];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        pre[i][i]=dp[i][i]=a[i];//因为题目中的特殊约定“如果只去掉一个数，操作价值为这个数的值。”
    }
    for(int len=2;len<=n;len++){
        for(int l=1;l<=n-len+1;l++){
            int r=l+len-1;
            pre[l][r]=dp[l][r]=abs(a[l]-a[r])*(r-l+1);//预处理，因为有可能最优方案是把区间[l,r]都删掉，所以要给dp[l][r]也赋值。
        }
    }
    for(int len=2;len<=n;len++){
        for(int l=1;l<=n-len+1;l++){
            int r=l+len-1;
            for(int i=l;i<=r-1;i++){
                dp[l][r]=max(dp[l][r],dp[l][i]+pre[i+1][r]);
                dp[l][r]=max(dp[l][r],pre[l][i]+dp[i+1][r]);//就是状态转移方程233
            }
        }
    }
    printf("%d\n",dp[1][n]);//输出总的“潜在价值”。
    return 0;
}
```

由于LZ非常菜，有可能有自以为是的地方，所以请在评论区无情的指出qwq

---

## 作者：communist (赞：7)

### 状态定义：

一眼区间$DP$，从左右两边删不好定义状态，不如定义$dp[i][j]$表示$[i,j]$未删的最大值，转移就很自然了

### 转移：

从左边删$dp[i][j]=max(dp[i][j],dp[k][j]+abs(a[i-1]-a[k])*(i-1-k+1))$

删除区间$[k,i),i-1>k$

从右边删$dp[i][j]=max(dp[i][j],dp[i][k]+abs(a[j+1]-a[k])*(k-j));$

删除区间$(j,k],k>j+1$

但是这样转移是转移不了只删一个的，特殊搞一下就好

$dp[i][j]=max(dp[i][j],dp[i-1][j]+a[i-1])$
$dp[i][j]=max(dp[i][j],dp[i][j+1]+a[j+1])$

### 答案统计：

$ans=max(ans,dp[i][j]+abs(a[j]-a[i])*(j-i+1))$

答案就是$DP$数组之中，删完的最小值

```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,a[110],dp[110][110],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int l=n-1;l;l--)
		for(int i=1;i<=n-l+1;i++)
		{
			int j=i+l-1;
			dp[i][j]=max(dp[i][j],dp[i-1][j]+a[i-1]);
			dp[i][j]=max(dp[i][j],dp[i][j+1]+a[j+1]);
			for(int k=1;k<i-1;k++)
				dp[i][j]=max(dp[i][j],dp[k][j]+abs(a[i-1]-a[k])*(i-1-k+1));
			for(int k=j+2;k<=n;k++)
				dp[i][j]=max(dp[i][j],dp[i][k]+abs(a[j+1]-a[k])*(k-j));
			ans=max(ans,dp[i][j]+abs(a[j]-a[i])*(j-i+1));
		}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：defense (赞：6)

* 状态定义：$f(i,j)$表示删到序列$[i,j]$时所能获得的最大价值
* 方程：$f(i,j)=max(f(k+1,j)+t(i,k),f(i,k)+t(k+1,j),f(i,j))$
(其中$k$表示枚举的上一个状态的左边和右边)
* 解释：从右左分别枚举他的子序列，则他的价值就等于子序列的价值加上删数的价值得来
* 代码：
```
#include<bits/stdc++.h>
using namespace std;
int f[101][101];
int n;
int a[101];
int read(){ 
    int F=1,Num=0; 
    char ch=getchar();
    while(ch<'0'||ch>'9'){ 
        if(ch=='-')F=-1; 
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){ 
        Num=Num*10+ch-'0';
        ch=getchar();
    }
    return Num*F;
}
int t(int i,int j){
	if(i==j)return a[i];
	else return abs(a[i]-a[j])*abs(j-i+1);
}
int main(){
	n=read();
	for(int i=1;i<=n;++i){
		a[i]=read();
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			for(int k=i;k<=j;k++){
				f[i][j]=max(f[k+1][j]+t(i,k),f[i][j]);
			}
			for(int k=i;k<=j;k++){
				f[i][j]=max(f[i][k]+t(k+1,j),f[i][j]);
			}
			
		}
	}
	printf("%d",f[1][n]);
	return 0;
} 
```


---

## 作者：xfydemx (赞：6)

这种题的主流解法当然都是dp（区间dp  【%%%楼下大佬Orz】

但是对于像我这种智商不太够的蒟蒻怎么办呢？

记忆化搜索可能是个好办法

对于本题即枚举所有中间可取的点 记忆化+递归暴力一波

思维难度比dp不知低到哪里去了


        
   
    
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
using namespace std;
int ans,f[105][105],a[105],h;
int dfs(int x,int y){
    if(f[x][y]) return f[x][y];  //记忆化核心步骤
    for(int i=x;i<=y;i++){ //实际上是枚举中间可取的所有断点
        if(i<y){
         h=dfs(x,i)+dfs(i+1,y);}
        else h=abs(a[y]-a[x])*(y-x+1);
        f[x][y]=max(f[x][y],h);
    }
    return f[x][y];
}
int main(){
   int n;
   cin>>n;
   for(int i=1;i<=n;i++){ 
      scanf("%d",&a[i]);
      f[i][i]=a[i]; //预处理
      if(i>1) f[i][i-1]=abs(a[i]-a[i-1])*2;
   } 
   dfs(1,n);  
   cout<<f[1][n]; //输出啦
}

```

---

## 作者：lx_zjk (赞：4)

这道题题解比较少，我就来发一下吧

一道简单的区间DP题，对于一个数列删除数决策方案有多种

### part 1

删除最左边或者最右边的数

$dp[l][r] = max(dp[l + 1][r] + v[l], dp[l][r - 1] + v[r]);$

### part 2 

直接把整个数列删除

$dp[l][r] = abs(v[r] - v[l]) * (r - l + 1);$

### part 3

枚举分割线$k$ 将一段删除

$dp[l][r] = max(dp[l][k] + abs(v[k + 1] - v[r]) * (r - k), max(dp[k + 1][r] + abs(v[k] - v[l]) * (k - l + 1), dp[l][r])); $

综上 此题为区间DP板子题

# CODE

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 100 + 50;

int n, v[MAX_N], dp[MAX_N][MAX_N];

int main() {
	n = read();
	for (int i = 1; i <= n; ++ i ) dp[i][i] = v[i] = read();
	for (int len = 2; len <= n; len ++ ) {
		for (int l = 1, r; (r = l + len - 1) <= n; l ++ ) {
			dp[l][r] = abs(v[r] - v[l]) * (r - l + 1);
			dp[l][r] = max(dp[l + 1][r] + v[l], max(dp[l][r - 1] + v[r], dp[l][r]));
			for (int k = l; k < r; k ++ ) {
				dp[l][r] = max(dp[l][k] + abs(v[k + 1] - v[r]) * (r - k), max(dp[k + 1][r] + abs(v[k] - v[l]) * (k - l + 1), dp[l][r])); 
			}
		}
	}
	cout << dp[1][n] << endl;
	return 0;
}

```

---

## 作者：chauchat (赞：4)

记忆化搜索

递归搜索枚举断点，然后在分治删除和整个区间删除里面取最大。

只有一个数的时候就是这个数本身啦





```cpp
#include<iostream>
using namespace std;
#include<cstdio>
#include<cmath>
#include<cstring>
const int maxn = 105;
int n,num[maxn],f[maxn][maxn];
int dfs(int l,int r){
    if(f[l][r]) return f[l][r];
    if(r == l) return num[r];
    for(int i = l;i < r;i++)
        f[l][r] = max(f[l][r],dfs(l,i) + dfs(i + 1,r));
    f[l][r] = max(f[l][r],(r-l+1)*abs(num[l]-num[r]));
    return f[l][r];
}
int main(){
    cin>>n;
    for(int i = 1;i <= n;i++) cin>>num[i];
    dfs(1,n);
    cout<<f[1][n];
    return 0;
}
```

---

## 作者：Tiork蜡笔小新 (赞：2)

# 经典迪屁
看到各位older的方法好像都和我不一样， 决定发出代码找找存在感

首先不管怎么删，删到最后肯定有一个交界点

交界点左边全部使用左删，右边使用右删 （当然如果全部都是左删或者都是右删的情况因为交界点在末端需要特判）

既然数列被分成左右两部分，那分别求出左右部分最大值即可

用 fl[i] 和 fr[i] 代表从最左边和最右边删到第i个数的最大值，轻易得出递推公式


------------

```cpp
if(j==1)    
fl[i]=max(fl[i],num[i]+fl[i-1]);
else
fl[i]=max(fl[i],fl[i-j]+abs(num[i]-num[i-j+1])*j);
```


------------
```cpp
if(j==1)   
fr[i]=max(fr[i],num[i]+fr[i-1]);
else        
fr[i]=max(fr[i],fr[i+j]+abs(num[i]-num[i+j-1])*j);
```


------------
最后求出 max(fl[i]+fr[i]) 即可（端点特判）

以下贴代码


------------

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int i,j,n;
    int num[105]={0};
    cin>>n;
    for(i=1;i<=n;i++)
        cin>>num[i];
    int fl[105]={0},fr[105]={0};
    for(i=1;i<=n;i++)
        for(j=1;j<=i;j++)
            if(j==1)    fl[i]=max(fl[i],num[i]+fl[i-1]);    //只删除一个值 
            else        fl[i]=max(fl[i],fl[i-j]+abs(num[i]-num[i-j+1])*j);
    for(i=n;i>=1;i--)
        for(j=1;j<=n-i+1;j++)
            if(j==1)    fr[i]=max(fr[i],num[i]+fr[i-1]);
            else        fr[i]=max(fr[i],fr[i+j]+abs(num[i]-num[i+j-1])*j);
    int ans=0;
    for(i=1;i<=n-1;i++)
        ans=max(fl[i]+fr[i+1],ans);         //找最大左右的和 
        ans=max(ans,max(fl[n],fr[1]));      //端点特判，最大值可能在端点 
    cout<<ans;
    return 0;
}
```


------------



---

## 作者：littlegagaduck (赞：2)

~~作为一名dp蒟蒻，自己做出来一道题真是超级不容易。~~

首先，这道题看上去还需要考虑从前面找和从后面找，实际上我们仔细观察给出的式子后发现并不是这样，题意就相当于对一段连续的数进行划分，使各个区间按要求计算出其值后所有区间的和最大。 

考虑用dp解决这个问题，我的想法是从前往后保证每一步最优，最后一步也一定是走到最后一个数时的最有情况，便是最优解。

对于每一个位置i，枚举其之前的各个位置j（j<i），从j位置的最优状态（前面已经找过）转移而来，加上（j+1,i）这一段区间的权值，当前面所有的情况已经考虑并比较过时，能保证现在找的位置i已经是最优解。

dp还有一个十分重要的问题是边界条件，不妨仔细思考一下，第一个位置没有别的选择只能保留原数，为了dp的过程完整希望f[1]可以从f[0]转移而来，将上文所说的过程实现之后发现f[0]=0时能保证f[1]=a[1] (a数组存储输入的数)。另外，不止f[1]，其他的位置也需要从f[0]转移，表示的是i前面全部的数
构成一个区间求出其权值，这个过程无法从前面位置转移而来（前面没有位置可用了），令其从f[0]转移能保证计算的合理。这一段可能不是很好理解，请大家看着代码仔细思考一下，蒟蒻做题时也是冥思苦想好久才理解清楚的。

最后，注意题目中提供的公式对于上文所说j==i-1的情况不适用，需要特殊处理。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,a[110],f[110]={0};
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i];
	}
	f[0]=0;
	for(int i=1; i<=n; i++)
	{
		for(int j=0; j<=i-1; j++)
		{
			if(j==i-1)
			{
				f[i]=max(f[i],f[j]+a[i]);
				continue;
			}
			f[i]=max(f[i],f[j]+abs(a[i]-a[j+1])*(i-j));
		}
	}
	cout<<f[n]<<endl;
	return 0;
}
```


---

## 作者：FourteenObsidian (赞：1)

不懂 $O(n^2)$ 可以过的题为什么 $n$ 只有100。。。

分析题目，容易发现题目是要把一个序列分成若干段，每一段的价值为**该段的长度** $\times$ **该段最左端与最右端元素之差的绝对值**。

设 $dp[i]$ 表示只考虑 $i$~$n$ 这段区间内最优解的大小。那么容易得出 $dp[i]=max(dp[j]+abs(a[i]-a[j-1])*(j-i)|i+1<=j<=n)$。同时，也要考虑将$i$~$n$ 这段区间分为一段。

最后的答案就是 $dp[1]$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e2 + 10;
int n;
int a[N], dp[N];
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i)
		scanf("%d", &a[i]);
	dp[n] = a[n];
	for(int i = n - 1; i >= 1; --i)//从右向左推
	{
		for(int j = i + 1; j <= n; ++j)
			dp[i] = max(dp[i], dp[j] + (i == j - 1 ? a[i] : abs(a[i] - a[j - 1])) * (j - i));
		dp[i] = max(dp[i], abs(a[i] - a[n]) * (n - i + 1));//考虑将$i$~$n$ 这段区间分为一段
	}
	printf("%d\n", dp[1]);
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：1)

# 前言  
这道题没给你区间DP的小红签，就说明他不一定是区间DP。  

# 正文开始：    

# 1、dp状态的定义：  
dp[i]表示在选到第i个数字时可获得的最大价值。  

# 2、dp转移方程：  
```cpp
for(int i = 1; i <= n; i ++)
{
	dp[i] = dp[i - 1] + a[i]//当我们只选取这个数字本身为进行删除可获得的价值  
	for(int j = 1; j < i; j ++)
         {
   		dp[i] = max(dp[i],dp[j - 1] + LLabs(a[i] - a[j]) * (i - j + 1));//由于你的a[j]需要使用，所以我们这里枚举的是删除区间的左端点  
         }  
```
# 3、边界  
```
dp[1] = a[1];  
//这就是选第一个数字本身为删除区间的最大价值  
```
# 4、计算顺序  
从前到后，因为你的状态需要的是前面dp的状态。    

# 5、代码：
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,a[105],dp[105];
long long LLabs(long long x)
{
	if(x < 0) return -x;
	return x;
}
int main()
{
	scanf("%lld",&n);
	for(int i = 1; i <= n; i ++)
		scanf("%lld",&a[i]);
	dp[1] = a[1];
	for(int i = 2; i <= n; i ++)
	{
		dp[i] = dp[i - 1] + a[i];
		for(int j = 1; j < i; j ++)
			dp[i] = max(dp[i],dp[j - 1] + LLabs(a[i] - a[j]) * (i - j + 1));
		printf("%d %lld\n",i,dp[i]);
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```
望管理大大通过一下，也许可能会重复，但是也是不一样的思路去分析的啊！

---

## 作者：LechX (赞：1)

因为只能从两边去掉连续的数，这样就等于将原数列划分成若干个区间，于是就想到了记忆化搜索~
```pascal
var
 f:array[0..105,0..105]of longint;
 a:array[0..105]of longint;
 i,j,n:longint;
function max(i,j:longint):longint;
begin
 if i>j then exit(i)
  else exit(j);
end;
function calc(i,j:longint):longint;//求解操作价值
begin
 exit(abs(a[i]-a[j])*(j-i+1));//见题意
end;
function dp(i,j:longint):longint;
//记忆化搜索，求解[i,j]的最大操作价值
var
 k,q:longint;
begin
 if i=j then exit(a[i]);
 //如果分到最小，返回该数的操作价值
 if f[i,j]>-1 then exit(f[i,j]);//记忆化
 q:=calc(i,j);//不分的情况
 for k:=i to j-1 do//k为划分点
  q:=max(q,dp(i,k)+dp(k+1,j));//求最大值
 f[i,j]:=q;//记录
 exit(q);
end;
begin
 read(n);
 for i:=1 to n do
  for j:=1 to n do
   f[i,j]:=-1;//给f数组赋初值
 for i:=1 to n do read(a[i]);
 write(dp(1,n));
end.

```


---

## 作者：神阈小杰 (赞：0)

思路：求删除所有数得到的最大价值

则设f[i][j]为从i开始删除j个数的最大价值
         
则f[i][j]可以为 一次性将i到i+j-1删除；也可以为先删除i到i+k-1,再删除i+k到i+j-1(1<=k<j)

状态转移方程如下：
```
for(int j=2;j<=n;j++)
	for(int i=1;i<=n-j+1;i++)
	{
		f[i][j]=jue(s[i],s[i+j-1])*j;
		for(int k=1;k<j;k++)
        		f[i][j]=max(f[i][j],f[i][k]+f[i+k][j-k]);
	}
```
f[1][n]即删除所有数得到的最大价值

代码如下：
```
# include <cstdio>
int n;
int s[110];
int f[110][110];//f[i][j]为从i开始删除j个数的最大价值;
int jue(int a,int b)
{
	if(a>b) return (a-b);
	return (b-a);
}
int max(int a,int b)
{
	if(a>b) return a;
	return b;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&s[i]);
		f[i][1]=s[i];
	}
	for(int j=2;j<=n;j++)
		for(int i=1;i<=n-j+1;i++)
		{
			f[i][j]=jue(s[i],s[i+j-1])*j;
			for(int k=1;k<j;k++) f[i][j]=max(f[i][j],f[i][k]+f[i+k][j-k]);
		}
	printf("%d",f[1][n]);
	return 0;
}
```

---

## 作者：GrayCatH (赞：0)

题解里各种讲法已经很多了……，这里补充一个小思路便于大家思考，也提供一种有~~一点点好看~~的写法。          

首先要知道反正我们只有一次删一段或一个两种操作，而且还要最后删没，那么我们只要从一头跑两重循环，第一重（i）慢慢从1向n跑，第二重（j）再慢慢从1到第一重的（i）


而到某一个位置的最大值无非由两种操作得来   
所以：   
dp[i]=Max(dp[i],dp[i-1]+x[i]);    
        dp[i]=Max(dp[i],dp[i-j]+cut(x[i-j+1],x[i],(i-j+1),i));
        
#### code：
```

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<bits/stdc++.h>
#include<queue>
#define fu(i,q,w) for(register int i=q;i<=w;i++)
#define fd(i,q,w) for(register int i=q;i>=w;i--)
#define tu(i,q,w) for(i=q;i<=w;i<<=1)
#define Min(a,b) ((a)<(b))?(a):(b)
#define Max(a,b) ((a)>(b))?(a):(b)
using namespace std;
typedef  int ll;
inline ll read(){
    int ret=0,f=1;char c;
    while((c=getchar())<'0'||c>'9')if(c=='-')f=-1;
    while(c>='0'&&c<='9')ret=ret*10+(c-'0'),c=getchar();
    return ret*f;}
void print(ll x){
    if(x<0){putchar('-');x=-x;}
    if(x>=10)print(x/10);putchar(x%10+'0');}
const int maxn=111;
int n,x[maxn];int dp[maxn];
inline void in(){
    n=read();
    fu(i,1,n)x[i]=read(),dp[i]=x[i];
}

inline int cut(int xi,int xk,int i,int k){
    if(xi-xk>0)return (xi-xk)*(k-i+1);
    else return (xk-xi)*(k-i+1);
}
inline void solve(){
    fu(i,1,n)
    fu(j,1,i){
        dp[i]=Max(dp[i],dp[i-1]+x[i]);
        //按说放在外面应该跑的快对吧
        //但评测结果相反我也不知道为什么大概数据太水
        //正好这样好看好想好理解索性就这样吧
        dp[i]=Max(dp[i],dp[i-j]+cut(x[i-j+1],x[i],(i-j+1),i));
    }
    print(dp[n]);
}
int main(){
    in();
    solve();
    return 0;
} 
 
```

---


# 物品选取

## 题目背景

小X确信所有问题都有个多项式时间算法，为了证明，他决定自己去当一次旅行商，在上路之前，小X需要挑选一些在路上使用的物品，但他只有一个能装体积为m的背包。显然，背包问题对小X来说过于简单了，所以他希望你来帮他解决这个问题。


## 题目描述

小X可以选择的物品有n样，一共分为甲乙丙三类：

 1．甲类物品的价值随着你分配给他的背包体积变化，它的价值与分配给它的体积满足函数关系式，v(x) = A\*x^2-B\*x，A，B是每个甲类物品的两个参数。注意每个体积的甲类物品只有一个。

 2．乙类物品的价值A和体积B都是固定的，但是每个乙类物品都有个参数C，表示这个物品可供选择的个数。

 3．丙类物品的价值A和体积B也是固定的，但是每个丙类物品可供选择的个数都是无限多个。

你最终的任务是确定小X的背包最多能装有多大的价值上路。


## 说明/提示

对于50%的数据，只有乙和丙两类物品；

对于70%的数据，1<=n<=100, 1<=m<=500，0<=A,B,C<=200；

对于100%的数据，1<=n<=100, 1<=m<=2000，0<=A,B,C<=200；


## 样例 #1

### 输入

```
1 0
1 1 1```

### 输出

```
0```

## 样例 #2

### 输入

```
4 10
2 1 2 1
1 1 2
3 5 2
2 200 2 3```

### 输出

```
610```

# 题解

## 作者：_zy_ (赞：25)

 [啊哈，题目在这里](https://www.luogu.com.cn/problem/P2623)

题意很明显嘛

三个背包


不知道大佬们说的函数背包是什么东东，~~虽然的却很形象~
~

甲：

当时只是觉得甲可以根据他给的式子直接来写对应体积的价值然后来跑$01$背包

乙：

对于每个个数处理一手，然后依旧跑$01$背包

丙：

完全背包

代码如下：
``` cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 1000010
using namespace std;
int re() {
	int p=0; char i=getchar();
	while(i<'0'||i>'9')	i=getchar();
	while(i>='0'&&i<='9')	p=p*10+i-'0',i=getchar();
	return p;
}
int n,m,cnt;
int w[N],v[N],r[N];
int f[N];
int main()
{
	n=re(); m=re();
	if(n==0||m==0) {
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		int op,x,y,z;
		op=re();x=re();y=re();
		if(op==1)
		{
			for(int j=1;j<=m;j++)
			{
				if(x*j-y<=0) continue;
				v[++cnt]=j;
				w[cnt]=j*(j*x-y);
				r[cnt]=1;
			}
		}
		if(op==2)
		{
			int k=1;	z=re();
			while(z>0)
			{
				int mi=min(k,z);
				w[++cnt]=mi*x;
				v[cnt]=mi*y;
				r[cnt]=1;
				z-=k;	k<<=1;
			}
		}
		if(op==3)
		{
			w[++cnt]=x;
			v[cnt]=y;
			r[cnt]=0;
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		if(r[i]==0)
		{
			for(int j=v[i];j<=m;j++)	f[j]=max(f[j-v[i]]+w[i],f[j]);
		}
		else {
			for(int j=m;j>=v[i];j--)	f[j]=max(f[j-v[i]]+w[i],f[j]);
		}
	}
	cout<<f[m]<<endl;	
return 0;
}
```

### 如有不妥之处或不明白之处，欢迎指出来qwq


---

## 作者：帅到报警 (赞：15)

这道题是一道~~简单的~~混合背包题……

首先分析可知**甲类**是一个函数背包，

**乙类**是一个多重背包，

**丙类**是一个完全背包。

对于后两个背包无需多言，仅需得出第一个背包的动规方程。

------------

设dp[i]为前i体积的背包所装的最大价值，
分3种情况讨论即可。

甲类：
```cpp
for(int j = m; j >= 0; j--)
	for(int k = 1; k <= j; k++)
		dp[j] = max(dp[j], dp[j - k] + k * k * a - b * k);
```

乙类：
```cpp
for(int j = m; j >= b; j--)
	for(int k = 1; k <= min(c, j / b); k++)
		dp[j] = max(dp[j], dp[j - k * b] + k * a);
```

丙类：
```cpp
for(int j = b; j <= m; j++)
	dp[j] = max(dp[j], dp[j - b] + a);
```



------------

完整代码
```cpp
#include <stdio.h>
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;

int n, m, op;
int dp[2010];
int a, b, c;

int main()
{
    cin >> n >> m;
    if(m == 0)
    {
    	cout << 0;
    	return 0;
	}
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &op);
		if(op == 1)
		{
			scanf("%d %d", &a, &b);
			for(int j = m; j >= 0; j--)
				for(int k = 1; k <= j; k++)
					dp[j] = max(dp[j], dp[j - k] + k * k * a - b * k);
		}
		if(op == 2)
		{
			scanf("%d %d %d", &a, &b, &c);
			for(int j = m; j >= b; j--)
				for(int k = 1; k <= min(c, j / b); k++)
					dp[j] = max(dp[j], dp[j - k * b] + k * a);
		}
		if(op == 3)
		{
			scanf("%d %d", &a, &b);
			for(int j = b; j <= m; j++)
				dp[j] = max(dp[j], dp[j - b] + a);
		}
	}
	
	cout << dp[m];
	
    return 0;
}
```


---

## 作者：hehe_54321 (赞：12)

为什么其他的题解全部都是$O(nm^2+nmc)$卡常啊...

我有一个复杂度较好（$O(nmc)$）的想法：

可以证明一定存在一种最优解，其中取的甲类物品总数<=1

证明简单来讲就是如果取了两个或以上甲类物品，那么取其中任意两个（设属性分别为(a1,b1),(a2,b2)，各取了x1,x2的体积），将它们替换为一个体积是它们之和，属性为它们之一的物品，一定不会更劣

$a1*{(x1+x2)}^2-b1*(x1+x2)>=a1*{x1}^2-b1*x1+a2*{x2}^2-b2*x2$

这样就很简单了：乙类和丙类物品的处理楼上讲的很清楚；遇到甲类物品先不管，存起来

处理完乙和丙类物品后计算一个数组ans，其中ans\[i\]表示只取乙或丙类物品时，用**最多**i的体积得到的最大价值

然后枚举甲类物品取的情况：不取或者取某一个

对于每一个甲类物品，再跑一遍dp，就是只取它时枚举它的体积即可

```
//设an2为最终答案,dd为存储甲类物品信息的vector
//其中dd[i].fi,dd[i].se分别表示第i个甲类物品的A属性,B属性
an2=ans[m];
for(i=0;i<dd.size();i++)
{
	for(j=0;j<=m;j++)
	{
		an2=max(an2,ans[m-j]+dd[i].fi*j*j-dd[i].se*j);
	}
}
```
代码：
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> pll;

ll ans[2005],an2;
//前i个物品，用j的容量的最大价值
vector<pll> dd;
ll n,m;
int main()
{
    ll idx,i,j,k,a,b,c;
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%lld",&idx);
        if(idx==1)
        {
            scanf("%lld%lld",&a,&b);
            dd.pb(mp(a,b));
        }
        else if(idx==2)
        {
            scanf("%lld%lld%lld",&a,&b,&c);
            if(b==0)
            {
                for(j=0;j<=m;j++)	ans[j]+=a*c;
            }
            else
            {
                for(j=m;j>=1;j--)
                {
                    for(k=min(c,j/b);k>=1;k--)
                    {
                        ans[j]=max(ans[j],ans[j-k*b]+k*a);
                    }
                }
            }
        }
        else if(idx==3)
        {
            scanf("%lld%lld",&a,&b);
            if(b==0)	exit(-1);
            else
            {
                for(j=b;j<=m;j++)
                {
                    ans[j]=max(ans[j],ans[j-b]+a);
                }
            }
        }
        //for(int i=0;i<=m;i++)	printf("a%lld %lld\n",i,ans[i]);
    }
    for(i=1;i<=m;i++)	ans[i]=max(ans[i],ans[i-1]);
    an2=ans[m];
    for(i=0;i<dd.size();i++)
    {
        for(j=0;j<=m;j++)
        {
            an2=max(an2,ans[m-j]+dd[i].fi*j*j-dd[i].se*j);
        }
    }
    printf("%lld",an2);
    return 0;
}
```


---

## 作者：_Aghost (赞：10)

### 01背包，完全背包，多重背包的综合。

###### 首先乙丙物品很显然，乙就是一个多重背包，丙是完全背包。具体代码实现：

# 乙：
```cpp
for(int i=1;i<=n;i++)
for(int j=1;j<=t[i];j++)//t[i]为i的个数。
for(int k=m;k>=v[i];k--)
f[k]=max(f[k],f[k-v[i]]+w[i]);
```
# 丙：
```
for(int i=1;i<=n;i++)
for(int j=v[i];j<=m;j++)
f[j]=max(f[j],f[j-v[i]]+w[i]);
```
### 混合这两个就可以获得~~60分的~~~~好成绩~~~~~~

###  甲可以转化为01背包，我们只需要枚举
## 每个体积甲的价值。
下面是代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[1010],b[1010],w[1010],v[1010],t[1010],x[1010],f[10010];
int main()
{
	freopen("pack.in","r",stdin);
	freopen("pack.out","w",stdout);
	scanf("%d%d",&n,&m);
	if(m==0)
	{
		cout<<"0"<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x[i]);
		if(x[i]==1) scanf("%d%d",&a[i],&b[i]);
		if(x[i]==2) scanf("%d%d%d",&w[i],&v[i],&t[i]);
		if(x[i]==3) scanf("%d%d",&w[i],&v[i]);
	}
	f[0]=0;
	for(int i=1;i<=n;i++)
	{
		if(x[i]==1)
		{
			for(int j=m;j>=1;j--)
			{
				for(int k=1;k<=j;k++)
				{
					f[j]=max(f[j],f[j-k]+a[i]*k*k-b[i]*k);
				}
				
			}
		}
		if(x[i]==2)
		{
			for(int j=1;j<=t[i];j++)
			{
				for(int k=m;k>=v[i];k--)
				{
					f[k]=max(f[k],f[k-v[i]]+w[i]);
				}
			}
		}
		if(x[i]==3)
		{
			for(int j=v[i];j<=m;j++)
			{
				f[j]=max(f[j],f[j-v[i]]+w[i]);
			}
		}
	}
	cout<<f[m]<<endl;
	return 0;
}
          



```





---

## 作者：a___ (赞：5)

~~##~~居然一发题解都没有？！！！

那就题解0突破

乙类和丙类就不说了，分别是多重背包和完全背包（凡是学过背包问题的应该都会）

\*  递推公式：

\*  乙类：（多重背包）

```cpp
( for (i=1 to n) )
    for (j=m;j>=B;j--)//逆循环
        for (k=1;k<=C;k++)
            if (j-k*B<0)break;//无法再放
            else f[j]=maxx(f[j-k*B]+k*A,f[j]);//如果放了价值大，就放，反之，就不放
```
\*  丙类：（完全背包）

```cpp
( for (i=1 to n) )
    for (j=B;j<=m;j++)//顺循环
        f[j]=maxx(f[j-B]+A,f[j]);//选了价值大就选
```
甲类也不难，虽然价值和体积有变，但从m到0（只取一次）将体积依次从1到j试一次即可

\*  递推公式：

```cpp
( for (i=1 to n) )
for (j=m;j>0;j--)//与01背包一样，只选用一次
    for (k=1;k<=j;k++)//此时可选重量枚举
        f[j]=maxx(f[j-k]+v(k),f[j]);//选了价值大就选
```
最后，上代码：

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

```cpp
#include <iostream>
using namespace std;
#define v(xx) A*xx*xx-B*xx  //甲类体积算法
#define maxx(a,b) a>b?a:b  //求最大值
int n,m,x,A,B,C,f[2020];
int main()
{
    int i,j,k;
    cin>>n>>m;
    for (i=1;i<=n;i++)//循环输入，处理
    {
        cin>>x>>A>>B;//x，A，B是每次必输的
        if (x==1)//甲类：
        for (j=m;j>0;j--)
        for (k=1;k<=j;k++)
        f[j]=maxx(f[j-k]+v(k),f[j]);
        else if (x==2)//乙类：
        {
            cin>>C;//乙类需输入C
            for (j=m;j>=B;j--)
            for (k=1;k<=C;k++)
            if (j-k*B<0)break;
            else f[j]=maxx(f[j-k*B]+k*A,f[j]);
        }
        else//非甲非乙自然是丙类了
        for (j=B;j<=m;j++)
        f[j]=maxx(f[j-B]+A,f[j]);
    }
    cout<<f[m]<<endl;//输出
    return 0;
}
```

---

## 作者：Sasiyar (赞：3)

就像我一样，我没有注意到数据范围小，以为暴力不可过。

于是就推出了第一种物品的斜率式

$2Aj<\frac{(ans_i+Ai^2+B_i)-(ans_k+Ak^2+B_k)}{i-k}$

使用单调栈维护上凸包就可以了。

具体说来，每次先找到最优解再栈中的位置，通过观察凸包可得从栈顶取出斜率大于$2Aj$的，因为栈下面的答案一定更优，统计答案之后退栈来维护凸包的性质，就可以了。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define xx first
#define yy second
using namespace std;
const int N = 10000 + 5, M = 20000 + 5;
int n, m;
pair<pair<int, int>, int> info[N]; int cnt_i;
pair<int, int> tmp_info[N << 2]; int cnt_t;
pair<int, int> info_x[N]; int cnt_x;
int ans[M], ans_2[M], ans_3[M];
double A, B;
int q[M], tail;
inline double slope (int x, int y) {
    return ((double)ans_2[y] + (double)A * y * y + (double)B * y - (double)ans_2[x] - (double)A * x * x - (double)B * x) / ((double)y - (double)x);
}
inline void solve2 () {
    for (int i = 1; i <= cnt_x; ++i) {
        A = (double)info_x[i].xx, B = (double)info_x[i].yy;
        tail = 1, q[1] = 0, ans_2[0] = 0;
        for (int j = 1; j <= m; ++j) {
            while (tail > 1 && slope (q[tail - 1], q[tail]) <= 2.0 * A * j) tail--;
            ans_3[j] = max ((double)ans_2[j], ans_2[q[tail]] + A * (j - q[tail]) * (j - q[tail]) - B * (j - q[tail]));
            while (tail > 1 && slope (q[tail], j) >= slope (q[tail - 1], j)) tail--;//
            q[++tail] = j;
        }
        for (int j = 1; j <= m; ++j) ans_2[j] = ans_3[j];
    }
}
inline void solve1 () {
    for (int i = 1; i <= cnt_i; ++i) {
        for (int k = 1; k <= info[i].yy; k <<= 1) {
            tmp_info[++cnt_t] = make_pair (k * info[i].xx.xx, k * info[i].xx.yy);
            info[i].yy -= k;
        }
        if (info[i].yy) {
            tmp_info[++cnt_t] = make_pair (info[i].yy * info[i].xx.xx, info[i].yy * info[i].xx.yy);
        }
    }
    for (int i = 1; i <= cnt_t; ++i) {
        for (int j = m; j >= 0; --j) {
            if (j < tmp_info[i].yy) break;
            ans[j] = max (ans[j], ans[j - tmp_info[i].yy] + tmp_info[i].xx);
        }
    }
}
int main () {
    scanf ("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        int opt, a, b, c;
        scanf ("%d", &opt);
        if (opt == 1) {
            scanf ("%d%d", &a, &b);
            info_x[++cnt_x] = make_pair (a, b);
        }
        else {
            scanf ("%d%d", &a, &b);
            if (opt == 3) {
                for (int i = 0; i <= m - b; ++i) {
                    ans[i + b] = max (ans[i + b], ans[i] + a);
                }
                continue;
            }
            else scanf ("%d", &c), c = min (c, m / b);
            info[++cnt_i] = make_pair (make_pair (a, b), c);
        }
    }
    solve1 ();
    solve2 ();
    int Ans = 0;
    for (int i = 1; i <= m; ++i) {
        ans[i] = max (ans[i], ans[i - 1]);
        ans_2[i] = max (ans_2[i], ans_2[i - 1]);
    }
    for (int i = 0; i <= m; ++i) {
        Ans = max (Ans, ans[i] + ans_2[m - i]);
    }
    printf ("%d\n", Ans);
    return 0;
}
```
注意要新开数组，因为甲类只能用一个。

我用了二进制优化背包（乙类和丙类）。

---

## 作者：xh39 (赞：2)

## 前言

前置算法:01背包。

其他题解都是$O(n×m²)$,分享一个$O(n×sum\{log_2(c÷b)\})$(也就是$O(n×m×log_2(m÷b))$)的做法。(算了一下$nm²$,有$4×10^{8}$,以为过不了)

请看50pts后再看100pts,否则你会看不懂。

不理解的可以结合代码来理解。

## 50pts

> 对于50%的数据，只有乙和丙两类物品；

现在只有乙和丙,那么就是混合完全背包和部分背包。但是没必要用混合背包。直接把完全背包看成有m÷b个的部分背包。

[可能有点不好理解,可以看举例]然后部分背包可以采用二进制拆分(有点像倍增思想)。假设重量为$x$,把它拆成$(log_2(x)+1)$个背包,分别为$2^i(0<=i<log_2(x))$和剩余重量。

比如有$19$个物品。就把它拆成$6$个物品:$1+2+4+8+16+3$,这样就可以表示19了。(证明:$16$以内可以用二进制表示,剩余的$17~19$可以用$14~16$加上$3$),然后就转化为了01背包。

简单讲解01背包。

01背包:设$f[i][j]$为容量为$j$时前$i$个物品的最大值。$a[i]$为体积,$b[i]$为价值。

$f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);$

## 100pts

此时加入了一个甲,我们发现只需要选取$1$个甲。因为$2$个甲物品一定比$1$个更差。因为$x^{2}$一定比$a^{2}+(x-a)^2$要更优。

那么我们就枚举选多少的甲容量。

根据上面的推论,甲的价值为所有价值中的最大值。

由于乙丙容量$f$已求出,所以总容量就是$O(n²)$循环枚举了。具体见代码↓。
## AC代码。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[1000005],b[1000005],c[1000005],d[1000005],tot0=0,tot1=0; //a,b表示01背包体积价值。c,d表示甲物品。
int f[5005][2005]; 
int main(){
	int tot=0,n,m,i,j,opt,A,B,C,Max=0,ans=0,t=0;
	cin>>n>>m;
	for(i=0;i<n;i++){
		scanf("%d",&opt);
		if(opt==1){
			tot1++;
			scanf("%d %d",c+tot1,d+tot1);
			continue;
		}
		scanf("%d %d",&A,&B);
		if(opt==3){
			C=m/B; //完全背包->部分背包。
		}else{
			scanf("%d",&C);
			C=min(m/B,C); //优化。
		}
		for(j=1;(j<<1)<=C;j<<=1){ //部分背包->01背包(拆分)。
			a[tot0]=B*j;
			b[tot0]=A*j;
			tot0++;
		}
		a[tot0]=B*(C-j+1);
		b[tot0]=A*(C-j+1);
		tot0++;
	}
	for(i=0;i<=m;i++){ //01背包初始化。
		if(a[0]<=i){
			f[0][i]=b[0];
		}else{
			f[0][i]=0;
		}
	}
	for(i=1;i<tot0;i++){ //01背包。
		for(j=0;j<=m;j++){
			if(j<a[i]){
				f[i][j]=f[i-1][j];
			}else{
				f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);
			}
		}
	}
	for(i=0;i<=m;i++){
		Max=0;
		t=m-i; //t表示剩下多少给甲的容量。
		for(j=1;j<=tot1;j++){
			Max=max(Max,c[j]*t*t-d[j]*t); //计算该容量下甲物品的最大值。
		}
		ans=max(ans,f[tot0-1][i]+max(0,Max)); //与0取max是因为如果价值小于0那么不如不选取甲。
	}
	cout<<ans;
	return 0;
}
```
//39ms 7.62MB  _**~~是不是很神奇?~~**_

---

## 作者：syf2008 (赞：1)

这题很简单
甲是给的体积多少，来定价值的
乙是多重背包可以用二进制优化（~~数据小为什么要写~~），也可以直接写
丙是完全背包
下面，上代码
```
#include<bits/stdc++.h>
using namespace std;
int dp[2005],n,t,s,a,b,c;
int main()
{
	cin>>n>>t;
	while(n--)
	{
	cin>>s;
	if(s==1)
	{cin>>a>>b;
	for(int i=t;i>=1;i--)
	dp[i]=max(dp[i],dp[i-i]+a*i*i-b*i);
	}
	if(s==2)//多重背包
	{cin>>a>>b>>c;
	for(int i=t;i>=0;i--)
	for(int j=1;j<=c&&j*b<=i;j++)
    dp[i]=max(dp[i],dp[i-j*b]+j*a);
    }
	if(s==3)//完全背包
	{cin>>a>>b;
	for(int i=b;i<=t;i++)
	dp[i]=max(dp[i],dp[i-b]+a);
   }
	}
	cout<<dp[t]<<endl;
	return 0;
}
```
二进制优化
```
#include<bits/stdc++.h>
using namespace std;
int dp[2005],n,t,s,a,b,c,v[10],w[10];
int main()
{
	cin>>n>>t;
	while(n--)
	{
	cin>>s;
	if(s==1)
	{cin>>a>>b;
	for(int i=t;i>=1;i--)
	dp[i]=max(dp[i],dp[i-i]+a*i*i-b*i);
	}
	if(s==2)
	{cin>>a>>b>>c;
	int d=0;
    memset(v,0,sizeof(v));
    memset(w,0,sizeof(w));
	for(int j=1;c-j>=0;c-=j,j<<=1)
	{v[++d]=j*a;w[d]=j*b;}
	if(c>0)
	{v[++d]=c*a;w[d]=c*b;}
	for(int i=1;i<=d;i++)
	for(int j=t;j>=w[i];j--)
    dp[j]=max(dp[j],dp[j-w[i]]+v[i]);}
	if(s==3)
	{cin>>a>>b;
	for(int i=b;i<=t;i++)
	dp[i]=max(dp[i],dp[i-b]+a);}
	}
	cout<<dp[t]<<endl;
	return 0;
}
```

---

## 作者：神阈小杰 (赞：0)

本题为背包，设f[i]表示装i体积物品的最大价值

则状态转移方程为：

甲类(函数背包)
```
for(int i=m;i>=1;i--)
	for(int j=1;j<=i;j++)
    	f[i]=max(f[i],f[i-j]+A*j*j-B*j);
```
乙类(多重背包)
```
int k=1;
			while(k<=C)
			{
				for(int i=m;i>=k*B;i--) f[i]=max(f[i],f[i-k*B]+k*A);
				C-=k;
				k*=2;
			}
			if(C!=0) for(int i=m;i>=C*B;i--) f[i]=max(f[i],f[i-C*B]+C*A);
```
丙类(完全背包)
```
for(int i=B;i<=m;i++) f[i]=max(f[i],f[i-B]+A);
```
代码如下：
```
# include <cstdio>
int n,m;
int x,a,b,c;
int s[2010];
int f[2010];
int v(int a,int b,int v)
{
	return a*v*v-b*v;
}
int max(int a,int b)
{
	if(a>b) return a;
	return b;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		if(x==1)//甲类;
		{
			scanf("%d%d",&a,&b);
			for(int j=1;j<=m;j++) s[j]=v(a,b,j);//提前将各体积的价值算出来;
			for(int j=m;j>=1;j--)
				for(int k=1;k<=j;k++)
					f[j]=max(f[j],f[j-k]+s[k]);
		}
		else if(x==2)//乙类;
		{
			scanf("%d%d%d",&a,&b,&c);
			int k=1;
			while(k<=c)//将多重背包分为01背包,可以加快多重背包的计算速度;
			{
				for(int j=m;j>=k*b;j--) f[j]=max(f[j],f[j-k*b]+k*a);
				c-=k;
				k*=2;
			}
			if(c!=0) for(int j=m;j>=c*b;j--) f[j]=max(f[j],f[j-c*b]+c*a);
		}
		else//丙类;
		{
			scanf("%d%d",&a,&b);
			for(int j=b;j<=m;j++) f[j]=max(f[j],f[j-b]+a);
		}
	}
	printf("%d",f[m]);
	return 0;
}
```

---

## 作者：依依 (赞：0)

首先按照题目要求可以将物品分为三类

1)完全背包

2)多重背包

3)函数背包

令f[i]表示体积为i的背包的最大价值

先进行1),2)得到目前最优的f[i]

然后对于每个3)类物品,枚举分给他们的体积j

f[m]=max(f[m],f[m-j]+Val(j,i));

更新答案

[你们想要的](http://www.cnblogs.com/adelalove/p/9014273.html)

---

## 作者：lenaalyth (赞：0)

混合背包+分组背包，A类为分组背包（将一个物品视为一组，每组有从一到最大的价值（由公式可以算出来）B类为多重背包，c类为完全背包，之后按混合背包写就可以了；
A类：
```cpp
	for(int x=1;x<=a;x++)//分组背包
	{	
	for(int z=n;z>=1;z--)
		{
		for(int y=z;y>=1;y--)//循环套里面，这样物品不会重复使用
		{
		int l=y*y*aaa[x].a-aaa[x].b*y;//物品价值。。。原谅我现算了。。
		dp[z]=max(dp[z],dp[z-y]+l);
		}
		}
	}
```
B类：
```cpp
for(int x=1;x<=b;x++)//多重背包
	{
		for(int y=0;y<bbb[x].s;y++)//就比零一背包多个在外面的循环，就是这个物品还有几个，都放一下的意思。
		for(int z=n;z>=bbb[x].n;z--)
		{
			dp[z]=max(dp[z],dp[z-bbb[x].n]+bbb[x].v);
		}
	}
```
C类：
```cpp
	for(int x=1;x<=c;x++)//完全背包。。。就不说什么了
	{
		for(int y=ccc[x].n;y<=n;y++)
		{
			dp[y]=max(dp[y],dp[y-ccc[x].n]+ccc[x].v);	
		}
	}
```
全部代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
typedef struct{
	ll int v,n,s;
}bb;
typedef struct{
	ll int a,b;
}aa;
typedef struct{
	ll int v,n;
}cc;
aa aaa[210];
bb bbb[210];
cc ccc[210];
ll int dp[3000],e,d,f,s,z,q,l,m,n,a,b,c;
int main()
{
	scanf("%lld%lld",&m,&n);
	for(int x=0;x<m;x++)
	{
		scanf("%lld",&e);
		if(e==1)
		{
			a++;
			scanf("%lld%lld",&aaa[a].a,&aaa[a].b);
		}
		else if(e==2)
		{
			b++;
			scanf("%lld%lld%lld",&bbb[b].v,&bbb[b].n,&bbb[b].s);
		}
		else if(e==3)
		{
			c++;
			scanf("%lld%lld",&ccc[c].v,&ccc[c].n);
		}
	}
	for(int x=1;x<=a;x++)
	{	
	for(int z=n;z>=1;z--)
		{
		for(int y=z;y>=1;y--)
		{
		int l=y*y*aaa[x].a-aaa[x].b*y;
		dp[z]=max(dp[z],dp[z-y]+l);
		}
		}
	}
	for(int x=1;x<=b;x++)
	{
		for(int y=0;y<bbb[x].s;y++)
		for(int z=n;z>=bbb[x].n;z--)
		{
			dp[z]=max(dp[z],dp[z-bbb[x].n]+bbb[x].v);
		}
	}
	for(int x=1;x<=c;x++)
	{
		for(int y=ccc[x].n;y<=n;y++)
		{
			dp[y]=max(dp[y],dp[y-ccc[x].n]+ccc[x].v);	
		}
	}
	printf("%lld",dp[n]);
}
```
刚开始居然没看出a类是个分组背包的我。。。。。。。。

---


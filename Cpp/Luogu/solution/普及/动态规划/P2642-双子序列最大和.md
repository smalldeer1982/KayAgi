# 双子序列最大和

## 题目描述

给定一个长度为 $n$ 的整数序列，要求从中选出两个连续子序列，使得这两个连续子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为 $1$，并且两个连续子序列之间至少间隔一个数。


## 说明/提示

对于 $30\%$ 的数据 $N\le 100$。

对于 $60\%$ 的数据有 $N\le 10000$。

对于 $100\%$ 的数据有 $N\le 1000000$。

数据保证运算过程不会超过 `long long`（`int64`）。

## 样例 #1

### 输入

```
5
83 223 -13 1331 -935```

### 输出

```
1637```

## 样例 #2

### 输入

```
3
83 223 -13```

### 输出

```
70```

# 题解

## 作者：kradcigam (赞：89)

# 前言

其实这道题的关键就是在于预处理，其方法类似于 [合唱队形](https://www.luogu.com.cn/problem/P1091)

# 正文

## 求最大子段和

要想求出双子序列最大和，首先我们要会求出最大子段和

最大子段和的求值方法很简单

定义 $f_i$ 为以第 $i$ 个数结尾的最大子段和
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000010],a[1000010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
    f[1]=a[1];
	for(int i=2;i<=n;i++)f[i]=max(f[i-1]+a[i],a[i]);
	int ans=f[1];
	for(int i=2;i<=n;i++)ans=max(ans,f[i]);
	cout<<ans;
	return 0;
}
```
## 求双子序列最大和

那么我们现在可以去求双子序列最大和

怎么求，思路是
![](https://cdn.luogu.com.cn/upload/pic/75427.png)
如果你去枚举中间的数，然后去算左边的最大子段，再算出右边的最大子段，加起来，用打擂法，求出最大值，你会 $TLE$，毕竟$n<=10^{6}$

那怎么办？我们可以预处理

我们可以用 $O(n)$ 的时间计算到前 $i$ 个数的最大子段，

我们可以用 $O(n)$ 的时间计算到后 $i$ 个数的最大子段

像这样

```cpp
cin>>n;
for(int i=1;i<=n;i++)cin>>x[i];
f[1]=x[1];
for(int i=2;i<=n;i++)f[i]=max(f[i-1]+x[i],x[i]);//算最大子段
for(int i=2;i<=n;i++)f[i]=max(f[i-1],f[i]);//更新成最大值
l[n]=x[n];
for(int i=n-1;i>=1;i--)l[i]=max(l[i+1]+x[i],x[i]);//算最大子段
for(int i=n-1;i>=1;i--)l[i]=max(l[i+1],l[i]);//更新成最大值
```

这里 $f_i$ 表示前 $i$ 个数中的最大字段和

这里 $l_i$ 表示后 $i$ 个数中的最大字段和

然后，用 $O(n)$ 的时间去枚举中间的数，打擂法求出双子序列最大和

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x[1000010],f[1000010],l[1000010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x[i];
    f[1]=x[1];
    for(int i=2;i<=n;i++)f[i]=max(f[i-1]+x[i],x[i]);//算最大子段
	for(int i=2;i<=n;i++)f[i]=max(f[i-1],f[i]);//算最大子段
	l[n]=x[n];
    for(int i=n-1;i>=1;i--)l[i]=max(l[i+1]+x[i],x[i]);//算最大子段
	for(int i=n-1;i>=1;i--)l[i]=max(l[i+1],l[i]);//算最大子段
	long long ans=f[1]+l[3];
	for(int i=3;i<n;i++)ans=max(ans,f[i-1]+l[i+1]);//枚举中间数
	cout<<ans;
	return 0;
}
```

# 后记

这种预处理的方法可以优化我们的时间复杂度，避免重复计算，使我们的程序跑得更快！

感谢 @kuoluo03 帮我指出错误，已改正。

---

## 作者：dottle (赞：25)

首先，此题有一个弱化版 [P1115](https://www.luogu.org/problemnew/show/P1115)(不想去的听我说)。

给出一段数列，求出连续的非空的字段,使得和最大。

那么,我们可以令 $f_i$ 表示以 $i$ 结尾的最大子串,那么,若 $f_{i-1}$ 大于 $0$，则拼在一起比较划算，否则就单独出来.也就是：

$$f_{i}=max(f_{i-1}+a_{i},a_{i})$$

或者说

$$f_{i}=max(f_{i-1},0)+a_{i}$$

其核心代码如下:

~~~cpp
for(int i=0;i<n;i++){
	scanf("%d",&x);
    f[i]=max(f[i-i],0)+a[i];
}
	
~~~

---

然后我们便可以考虑如何从此题中更深一步得到这道题的解法。

我们仍然可以令 $g_i$ 表示以 $i$ 结尾的两个子串的权值最大值，那么，$g_i$ 有两种方法可以得到。

1.由 $g_{i-1}$ 继承而来，这样与上面是类似的。但与之不同的是，因为要有两个子串，所以前面的我们不能直接舍掉，即不能取 $0$，所以整个式子就是：

$$g_{i}=g_{i-1}+a_{i}$$

2.由之前的**一个**子串得来，也就是：

$$g_{i}=\max_{j<i-1}f_j+a_{i}$$

综合来讲，就是

$$g_{i}=\max(g_{i-1},\max_{j<i-1}f_j)+a_{i}$$

当然，此做法可以进一步地拓展，可以得到要取出 $k$ 个子序列的做法，读者不妨自己思考一下。



## 如何实现

~~~cpp
#include<bits/stdc++.h>
#define int long long
const int N=2e6,X=-5e18;
using namespace std;
int n,x,ans=X;
int f[2][N],maxn=X;//f[1]储存f,f[2]储存g,maxn用于储存最大的f
signed main() {
    scanf("%lld",&n);
    f[1][0]=X;
    for(int i=1;i<=n;i++){
        scanf("%lld",&x);//读入
        f[0][i]=max(f[0][i-1],0ll)+x;//维护f
        f[1][i]=max(maxn,f[1][i-1])+x;//维护g
        if(i>1) maxn=max(maxn,f[0][i-1]);//更新maxn的值
        if(i>2) ans=max(ans,f[1][i]);//因为选取2个子串至少要3个数,所以从3开始更新答案
    }
    printf("%lld",ans);
}
~~~



---

## 作者：biey (赞：12)

## 题目描述
给定一个长度为n的整数序列，要求从中选出两个连续子序列，使得这两个连续子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为1，并且两个连续子序列之间至少间隔一个数。

## 输入输出格式
#### 输入格式：
第一行是一个整数表示n。

第二行是n个整数表示整数序列。

#### 输出格式：
一个数，两个连续子序列的序列和之和。

## 输入输出样例
#### 输入样例#1： 
>5
83 223 -13 1331 -935

#### 输出样例#1： 
>1637

#### 输入样例#2： 
>3
83 223 -13

#### 输出样例#2：
>70

## 说明

对于30%的数据N<=100。

对于60%的数据有N<=10000。

对于100%的数据有N<=1000000。

数据保证运算过程不会超过long long（int64）。

---------------------------------------------------------------------------------------------------------------------
-


## 解题思路

首先根据Luogu《P1115 最大子段和》可以知道我们可以求出一直到第i为的当前连续子串和和当前连续子串的最大和，只不过对于这道题我们必须记录每一个点之前（或之后）当前连续子串的最大长度。
我们分别把从左到右的以及从右到左的当前子串和和当前最大子串和求出，以下是方法：

 - 从左到右

```
long long f[];//表示当前的子串和
long long ansl[];//表示当前从左到右的最大值 
for(int i = 1; i <= n; ++i) {
	f[i] = max(f[i - 1] + x[i], x[i]);
	ansl[i] = max(ansl[i - 1], f[i]);
}
```

 - 从右到左

```
long long g[];//表示当前的子串和
long long ansr[];//表示当前从右到左的最大值 
for(int i = n; i >= 1; --i) {//倒序遍历 
	g[i] = max(g[i + 1] + x[i], x[i]);
	ansr[i] = max(ansr[i + 1], g[i]);
}
```

 - 枚举断点
 

```
for(int i = 2; i <= n - 1; ++i) {//因为至少要有一个间隔，而且子串长度至少为1 
	ans = max(ansl[i - 1] + ansr[i + 1], ans);
} 
```



## 完整代码

```
#include <cstdio>
#include <iostream>
using namespace std;
int n;
typedef long long ll;
const int N = 1e6 + 100;
ll a[N];
ll f[N], g[N];
const ll INF = 999999999999;
ll ansl[N], ansr[N]; 
ll ans = 0;
int main() {
	scanf("%lld", &n);
	ans = -INF;
	ansl[0] = -INF;
	ansr[n + 1] = -INF;
	for(int i = 1; i <= n; ++i) {
		ll x;
		scanf("%lld", &x);
		a[i] = x;
		f[i] = max(f[i - 1] + x, x);
		ansl[i] = max(ansl[i - 1], f[i]);
	}
	for(int i = n; i >= 1; --i) {
		g[i] = max(g[i + 1] + a[i], a[i]);
		ansr[i] = max(ansr[i + 1], g[i]);
	}
	for(int i = 2; i <= n - 1; ++i) {
		ans = max(ansl[i - 1] + ansr[i + 1], ans);
	}
	printf("%lld\n", ans);
	return 0;
}
```

------------
# 然后你会发现你WA了!!!???
### 最后一波处理
因为区间的最前面和最后面都会出现负数
如果`ansl[0]`和`ansr[n+1]`的值为0的话就会出现一个神奇的现象， 队首的和变成了0，而不是正确的一个负数，炸！
所以

```
	ansl[0] = -INF;
	ansr[n + 1] = -INF;//为了防止负数的影响 
```
---------------------------------------------------------------**这下就可以完美AC了**---------------------------------------------------------------------

---

## 作者：big_news (赞：8)

#### 基础模型

给定一个长为n的数列，从中找到m个无交集的连续子数列使其和最大。

对于本题而言，m=2，且两个子序列不可以相邻。


#### 前置瞎扯

看到题解里面有说枚举断点的做法。这种做法虽然很巧妙，但是如果m再大一点呢，，，？这样还是不能做到线性解决这类问题。

实际上这种题型是有贪心通解的，典型题是BZOJ2288（貌似已经找不到了）。但是我太菜，理解不了，请参阅[hzwer神犇的题解](http://hzwer.com/2929.html)。

#### 开始讨论

实际上还有一种很优秀的DP状态设计，看到题解里面没有，就自己水一篇好了。。。在m比较小的时候（这种状态的空间复杂度是$O(nm)$，也就是说$nm$不能超过数组所允许的范围）这种DP思路就很好使了。

设$f[i][j][0/1]$表示考虑前 i 个位置，划分 j 段，且第 i 个位置的数选（1） 或 不选（0） 时，得到的答案。

这个状态设计总是固定的，初始状态也大概相同，但是方程可能会根据题目要求变（这不是废话。。。

**对于本题而言**，初始状态为$f[1][0][0] = 0,f[1][1][1] = s[1]$（$s[]$表示原数列，其余$f$值全清成$-\infty$）。
方程为：

$f[i][j][0] = \max f[i-1][j][0],f[i-1][j][1]$

$f[i][j][1] = \max f[i-1][j][1]+s[i],f[i-1][j-1][0]+s[i]$

方程建议自行理解，不懂可以评论问qwq。注意后面这个方程一定要满足$j>0$，因为$f[i][0][1]$是没有意义的。

时空复杂度都是$O(nm)$。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;

#define LL long long

const int CN = 1e6+6;
const LL INF = 0x7f7f7f7f7f7f7f7f;

LL read(){
	LL s=0,ne=1; char c=getchar();
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') ne=-1;
	for(;c>='0'&&c<='9';c=getchar()) s=(s<<1)+(s<<3)+c-'0';
	return s*ne;
}

int n;

/*
设 f[i][j][0/1] 表示考虑前 i 个数, 划分 j 段, 数 i 选1 /不选0 的答案 
f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0])
f[i][j][1] = max(f[i-1][j-1][0]+a[i], f[i-1][j][1]+s) 
*/
LL f[CN][3][2],s[CN];

int main()
{
	n = read();
	for(int i=1;i<=n;i++) s[i] = read();
	
	memset(f,-0x7f,sizeof(f));
	f[1][0][0] = 0; f[1][1][1] = s[1];
	
	for(int i=2;i<=n;i++){
		for(int j=0;j<=2;j++){
			f[i][j][0] = max(f[i-1][j][1], f[i-1][j][0]);
			if(j > 0) f[i][j][1] = max(f[i-1][j][1]+s[i], f[i-1][j-1][0]+s[i]);
		}
	}
	
	printf("%lld",max(f[n][2][0], f[n][2][1]));
	
	return 0;
}
```

[另：三段最大子段和](http://hzwer.com/3305.html) [题目](https://www.vijos.org/d/dongyingshishiyanzhongxue/p/1004)

[个人博客推广](https://big-news.cn/)

---

## 作者：由比滨丶雪乃 (赞：6)

# 暴力DP QWQ




貌似有一个兄弟题目[P1115](https://www.luogu.org/problem/P1115)不会的同学可
以先去康康那道题





这道题刚好是下午模拟赛的题，蒟蒻推了一个小时wwww总算把他暴力出来了QWQ









------------
###### 其他优化的方法dalao们也讲过，这里萌新就讲一个比较暴力的方法




## 1：由于题目是求连续两段的最大字段和，那么我们就可以从 1到n枚举  在从 n 到 1枚举，把每一段的最大字段和先标记一遍




代码实现
```cpp
	for(ll i=1 ;i <= n; i++)
	{
		 scanf("%lld",&a[i]);
		 l[i]=max(l[i-1]+a[i],a[i]);
		 lf[i]=max(lf[i-1],l[i]);
	}
	for(ll i=n;i>=1;i--)
	{
		r[i]=max(r[i+1]+a[i],a[i]);
		rf[i]=max(rf[i+1],r[i]);
	}
```




## 2：由于求的是连续最大字段和，所以答案一定有一个分界点，那么我们接下来的任务就是找到这个分界点。



### 所以我们从头到尾扫一遍 ， 找出临界点，它左端的最大字段和，加上右端的最大字段和，即为答案。


即
```cpp
	for(ll i=2;i<n;i++)
	{
		ans=max(lf[i-1]+rf[i+1],ans);
	}
```


# 那么接下来是细节优化


## 3：考虑到绝对值的影响，可能出现整个序列都是负数的情况，所以我们在初始化的时候，必须将初始值赋一个~~非常非常非常非常非常小~~的数hhhhh

即
```cpp
lf[0]=rf[n+1]=ans=-99999999999;
```

###### 接下来就可以愉快的A了这道题了QWQ




完整代码（~~我知道你们只看这个~~）
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <iomanip>
#define ll long long 
#define maxn 10000010

using namespace std;

ll n;
ll a[maxn],lf[maxn],rf[maxn],l[maxn],r[maxn];
ll ans;

int main()
{
	//freopen("number.in","r",stdin);考试的时候忘记划掉注释了，结果这道题爆0 QAQ
	//freopen("number.out","w",stdout); 
	scanf("%lld",&n);
	lf[0]=rf[n+1]=ans=-99999999999;
	for(ll i=1;i<=n;i++)//从左往右
	{
		 scanf("%lld",&a[i]);
		 l[i]=max(l[i-1]+a[i],a[i]);
		 lf[i]=max(lf[i-1],l[i]);
	}
	for(ll i=n;i>=1;i--)//从右往左
	{
		r[i]=max(r[i+1]+a[i],a[i]);
		rf[i]=max(rf[i+1],r[i]);
	}
	for(ll i=2;i<n;i++)//枚举分界点
	{
		ans=max(lf[i-1]+rf[i+1],ans);
	}
	printf("%lld",ans);
	return 0;
}


 
```


##### emm考试的时候这题只有90分 有一个[数据](https://pan.baidu.com/s/1ypdFH2reLuQemzEKZ9xc4w )~~提取码: xbyr~~   

~~特别卡~~

可以自己测一下




---

## 作者：GKxx (赞：5)

看大家都是用DP做的，这里介绍一种线段树做法

（这个做法不开O2会TLE，因为是O(nlogn)的做法而且常数不小）

我们考虑将区间[1, n]从中间切开变成[1, k]和[k+2, n]，那么我们枚举k，只要能够快速求得[1, k]和[k+2, n]的最大子段和就行了。

用线段树可以O(logn)求得[l, r]上的最大子段和，具体做法是：

假设线段树的结点表示的区间是[lb, rb]，维护四样东西：

leftans 表示从lb开始的最大子段和，也就是[lb, rb]的最大前缀和

rightans 与leftans相对称，是[lb, rb]的最大后缀和

sum 表示[lb, rb]的和

ans 表示[lb, rb]的最大子段和

sum就是左儿子加右儿子就好了

leftans这样考虑：可能是左儿子的leftans，也可能是左儿子的sum加上右儿子的leftans。rightans与之对称。

ans这样考虑：

如果跨过区间中点，那就是左儿子的rightans+右儿子的leftans

如果不跨过区间中点，那就是左儿子的ans或者右儿子的ans

因此update函数这样写：

（C++11引入了initializer_list之后，多于两项的max函数可以这样写：max({a, b, c, d})）

```cpp
inline void update(int x) {
    sum[x] = sum[x << 1] + sum[x << 1 | 1];
    leftans[x] = max(leftans[x << 1], sum[x << 1] + leftans[x << 1 | 1]);
    rightans[x] = max(rightans[x << 1 | 1], sum[x << 1 | 1] + rightans[x << 1]);
    ans[x] = max({ans[x << 1], ans[x << 1 | 1], rightans[x << 1] + leftans[x << 1 | 1]});
}
```

至于查询，我定义了一个叫QueryResult的类来保存查询结果

```cpp
struct QueryResult {
    long long lmax, rmax, sum, ans;
    explicit QueryResult(long long l, long long r, long long s, long long an)
        : lmax(l), rmax(r), sum(s), ans(an) {}
    QueryResult() : QueryResult(0, 0, 0, 0) {}
};
```

完整代码：

```cpp
// luogu-judger-enable-o2
// C++11
#include <cctype>
#include <climits>
#include <cstdio>
#include <algorithm>

using std::max;

template <typename T>
inline void read(T& t) {
    int f = 0; t = 0; int c = getchar();
    while (!isdigit(c)) {
        f |= c == '-';
        c = getchar();
    }
    while (isdigit(c)) {
        t = (t << 1) + (t << 3) + (c ^ 48);
        c = getchar();
    }
    if (f) t = -t;
}

const int maxn = 1e6;
long long a[maxn];
long long sum[maxn << 2], leftans[maxn << 2], rightans[maxn << 2], ans[maxn << 2];
int n;

inline void update(int x) {
    sum[x] = sum[x << 1] + sum[x << 1 | 1];
    leftans[x] = max(leftans[x << 1], sum[x << 1] + leftans[x << 1 | 1]);
    rightans[x] = max(rightans[x << 1 | 1], sum[x << 1 | 1] + rightans[x << 1]);
    ans[x] = max({ans[x << 1], ans[x << 1 | 1], rightans[x << 1] + leftans[x << 1 | 1]});
}
void build(int x, int lb, int rb) {
    if (lb == rb) {
        sum[x] = leftans[x] = rightans[x] = ans[x] = a[lb];
        return;
    }
    int mid = (lb + rb) >> 1;
    build(x << 1, lb, mid);
    build(x << 1 | 1, mid + 1, rb);
    update(x);
}

struct QueryResult {
    long long lmax, rmax, sum, ans;
    explicit QueryResult(long long l, long long r, long long s, long long an)
        : lmax(l), rmax(r), sum(s), ans(an) {}
    QueryResult() : QueryResult(0, 0, 0, 0) {}
};

QueryResult query(int x, int lb, int rb, int l, int r) {
    if (l <= lb && r >= rb)
        return QueryResult(leftans[x], rightans[x], sum[x], ans[x]);
    int mid = (lb + rb) >> 1;
    if (mid < l) return query(x << 1 | 1, mid + 1, rb, l, r);
    if (r <= mid) return query(x << 1, lb, mid, l, r);
    QueryResult qrleft = query(x << 1, lb, mid, l, r);
    QueryResult qrright = query(x << 1 | 1, mid + 1, rb, l, r);
    return QueryResult(max(qrleft.lmax, qrleft.sum + qrright.lmax),
                       max(qrright.rmax, qrright.sum + qrleft.rmax),
                       qrleft.sum + qrright.sum,
                       max({qrleft.ans, qrright.ans, qrleft.rmax + qrright.lmax}));
}

int main() {
    read(n);
    for (int i = 1; i <= n; ++i)
        read(a[i]);
    build(1, 1, n);
    long long finalans = INT_MIN;
    for (int k = 1; k + 2 <= n; ++k) {
        QueryResult qr1 = query(1, 1, n, 1, k);
        QueryResult qr2 = query(1, 1, n, k + 2, n);
        if (qr1.ans + qr2.ans > finalans)
            finalans = qr1.ans + qr2.ans;
    }
    printf("%lld\n", finalans);
    return 0;
}
```

---

## 作者：DF_Factory (赞：3)

这道题类似于[合唱队形](https://www.luogu.com.cn/problem/P1091)。

## 思路：
对于 $30\%$ 的数据，可以枚举断点，然后向两边计算最大子段和。

对其优化，发现求最大子段和这个过程可以预处理出来。

所以我们预处理出从前向后的最大子段和和从后向前的最大子段和。

处理这个东西用 dp。

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdwAAAETCAIAAAATfyDDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABfASURBVHhe7Z0vfi1FE0CfQCARCOS3BHQUEolEovJDsgMkNg7JEnBhGSwgC0Aike+b5CaTyfytrq7qru4+T5HHdFX1qZ5z+/Wde/PpM38gAAEIQCAMgU9hKqEQCEAAAhD4jJRZBBCAAAQCEUDKgZpBKRCAAASQMmsAAhCAQCACSDlQMygFAhCAAFJmDUAAAhAIRAApB2oGpUAAAhBAyqwBCEAAAoEIIOVAzaCUtgg8Pdx9evtz9/DUVvFUG5YAUg7bGgoLTWBp5JuZq3iZF4bQq0RVHFJWYWPQ6AS2Tp60fP9YFkuQF4ayk+4/G1Luv8fM0IFABClHqMEB7fAhkfLwSwAAOgKP9/OBcqXjC6Ss61z0UUg5eoeoLy6BhZcVB8qz0/UTrP/CoK+dkUcEkDJrAwIVCKx22foK8l4Y9HkZ6UYAKbuhJTAEjgmYSRnI3RFAyt21lAm1QAApt9ClOjUi5TrcyTo4AaQ8+AI4mT5SZm1AQEVg8yZb0lPKSFkFfYhBSHmINjNJewIRpJxXgz0TIloQQMoWFIkxIIE8IdrslPNqGLBpTUwZKTfRJoqMRyBPiEg5XkejVISUo3SCOhojgJQba1gz5SLlZlpFobEIHEt5tQve3RSzU47VzUjVIOVI3aCWhggcSPncyLf/O80SKTfU6sKlIuXCwEnXCwGk3Esno80DKUfrCPU0QgApN9Ko5spEys21jIJjEOBMOUYf+qsCKffXU2ZUhABPXxTBPGASpDxg05myBQGkbEGRGFsCSJlVAQEVAaSswsagSwJI+RIRF0BgjwBSZl34EEDKPlyJ2j0BpNx9iytNEClXAk/a1gkg5dY7GLV+pBy1M9QVnABSDt6gZstDys22jsLrEkDKdfn3mx0p99tbZuZKACm74h04OFIeuPlMPYdAnpSnzPN3EumryK5Bn5qRbgSQshtaAkPAmwBS9iZcIz5SrkGdnBCAAAQOCCBllgYEIACBQASQcqBmUAoEIAABpMwagAAEIBCIAFIO1AxKgQAEIICUWQMQgAAEAhFAyoGaQSkQgAAEkDJrAAIQgEAgAkg5UDN2S5H8ynqugQAE4hMQugYpC0FVuyz+UqNCCEBAQkAoEaQsBFXtMkmzuQYCEIhPQCgRpCwEVe2y+EuNCiEAAQkBoUSQshBUtcskzeYaCEAgPgGhRJCyEFS1y1ZLzbuOAunaTeFauWvw1bIxz2Ue0Hudl4mvw4KUzbqz+RrFuSP3jxlJdH1VJyyQrt0UrpW7BkfK6jsiZ6Cup0g5h/nnz8cm3v5jSudmXV/VsyqQrt0UrpW7BkfK6jsiZ6Cup0hZzfzp4S79FCtdzLq+qmdVIF27KVwrdw2OlNV3RM5AXU+Rspq5SspTlxK9rOurelYF0rWbwrVy1+BIWX1H5AzU9RQpq5lrpZyoZV1f1bMqkK7dFK6VuwZHyuo7ImegrqdIWc18LeXtDvhQ23cPT+K0ur6Kw68vLJCu3RSulbsGR8rqOyJnoK6nSFnN/E2558cR+2JOsLKur+pZFUjXbgrXyl2DI2X1HZEzUNdTpKxm/vRwL9rw7j6gIT9Y1vVVPasC6dpN4Vq5a3CkrL4jcgbqeoqUc5jLxu5ZWb5V1vVVVtnOVQXStZvCtXLX4EhZfUfkDNT1FCnnMJeNzdsq6/oqqwwpp3Fy7YVrcKSc1mmjq3U9RcpG+Ndhrj5Vsj6/OHznT9dX9awKpGs3hWvlrsGRsvqOyBmo6ylSzmE+j71S8Ko5049I+Y2JSQO8pXOLr7vHhBN0De7Np2TxQp4RLtNhQcpZvbN7Vvnw6zF0fVXPqkC6dlO4Vu4aHCmr74icgbqeImU1c72Qn1u13ikjZXUjyp2M6+4x4cRcgyNlYRdsL9P1FCnruiA28iRf0Rt9SFnXiP1RupvhsgKnsAXORpDyZXM9LtAtGKSs6UXaR/WQ8kfGupWa1CenFE5hkXJScxu6WLdgkLKixftv6x0+eoyUkbJgleluYEHgEsc7JYvXTbnKKB0WpJzerN198smnQURS5pG49EYcj9DdDJcVOIVlp3xJvtELdAsGKae3WyTZ97D7+2rx56x1fU2f1euIAunaTeFauWtwzpTVd0TOQF1PkXI68yQpHx0/I+W3BZvegOsRupvhMq5TWHbKl+QbvUC3YJByersTjpQNfm+frq/ps2KnfM3MtReuwdkpX3fX4QpdT5FyeiuEz16cf8qPnTI75Y9LT3cDpy/f5xHmucwD6uYVbZQOC1JW9FH8kPKqJ8sfkTJSRsqKm6+pIUi5YLsSvuvi/jHpDHozCV1f1SwKpGs3hWvlrsE5vlDfETkDdT1lp6xkLtPyy4NySLn4llB3M1wuBaewvNF3Sb7RC3QLBinr2311ivF2QoGUkbJgleluYEHgnUvMc5kH1M0r2igdFqSc28c9NX88MEbKSFmwynQ3sCAwUtZBMhil6ylSNkDvGkLXV3VJBdK1m8K1ctfgnCmr74icgbqeIuUc5iXG6vqqrqxAunZTuFbuGhwpq++InIG6niLlHOYlxur6qq6sQLp2U7hW7hocKavviJyBup4i5RzmJcbq+qqurEC6dlO4Vu4aHCmr74icgbqeIuUc5iXGrvrKjxCAQKMEhL5AykJQ1S5rdP1RNgQgwE65mjddE7OyIQCBPggIRcFOWQiq2mV9LEdmAQEICCWClIWgql3GUoYABPogIJQIUhaC4jIIQAACJQgg5RKUyQEBCEBASAApC0FxGQQgAIESBJByCcrkgAAEICAkgJSFoLgMAhCAQAkCSLkEZXJAoACB2yMKBRKRwpUALXTFS3AIFCKwfGisUErS+BBAyj5ciQqBggS2j/EWTE4qYwJI2Rgo4SBQngBSLs/cLyNS9mNLZAiUIHD0abcSucnhQAApO0AlJAQKEkDKBWGXSIWUS1AmBwScCJx/KYRTUsK6EkDKrngJDgFfAkjZl2+N6Ei5BnVyQsCCgOS70yzyEKMoAaRcFDfJIGBIYPcXW+h+24VhVYTKJICUMwEyHAJ1CBw9BsfjcXX6YZcVKduxJBIEChI42RGzWS7YB/tUSNmeKREh4E3gfDvMZtmbv2t8pOyKl+AQcCFwuRe+vMClLIJaEEDKFhSJAYGCBCQbYck1BUsmVQIBpJwAi0shEIGAcBcsvCzCjKhhSQApsx4g0BIB+RZYfmVL8x+gVqQ8QJOZYkcEkva/SRd3BKntqSDltvtH9UMRSN38pl4/FMywk0XKYVtDYRBYE1DsfBVD4F6XAFKuy5/sEJAS0G17daOkNXGdAwGk7ACVkBBwIKDe86oHOkyCkNcEkPI1I66AQHUCORvenLHVJz5gAUh5wKYz5fYIZO52M4e3x6vlipFyy92j9jEI5G918yOMQTrELJFyiDZQBAROCGyVmv83AA9LACmHbQ2FQeCZQL5/jyLANyYBpByzL1QFgVcCSHm0pYCUR+s4822MAFJurGHZ5SLlbIQEgIAzAQ8vO5dMeD0BpKxnx0gIQAAC5gSQsjlSAkIAAhDQE0DKenaMhAAEIGBOACmbIyUgBCAAAT0BpKxnx0gIQAAC5gSQsjlSAkIAAhDQE0DKenaMhAAEIGBOACmbIyUgBCAAAT0BpKxnx0gIQAAC5gSQsjlSAkIAAhDQE0DKenaMhAAEIGBOACmbIyUgBCAAAT0BpKxnx0gIQAAC5gSQsjlSAkIAAhDQE0DKenaMhAAEIGBOACmbIyUgBCAAAT0BpKxnx0gIQAAC5gSQsjlSAkIAAhDQE0DKenaMhAAEIGBOACmbIyUgBCAAAT0BpKxnx0gIQAAC5gSQsjlSAkIAAhDQE0DKenaMhAAEIGBOACmbIyUgBCAAAT0BpKxnx0gILAk8Pdx9evtz9/AEHAjoCCBlHTdGQeADgaWRb2au4mVeGDpYl0i5gyYyheoEtk6etHz/WLauIC8MZSfdYTak3GFTmVJxAhGkHKGG4uB7TIiUe+wqcypP4PF+PlCudHyBlMt33SUjUnbBStARCSy8rDhQnp2uR1f/hUFfOyNnAkiZxQCB+gRWu2x9QXkvDPq8jLQjgJTtWBIJAloCZlLWFsC4OASQcpxeUMm4BJDyuL3fzBwpsxggUJ8AUq7fgzAVIOUwraCQpgls3mRLekoZKTfdfNvikbItT6KNSiCClPNqGLVz4eaNlMO1hIKaJJAnRJudcl4NTWLvsWik3GNXmVN5AnlCRMrlOxY2I1IO2xoKa4oAUm6qXZGLRcqRu0Nt7RA4lvJqF7y7KWan3E6n3StFyu6ISTAEgQMpnxv59n8nPkh5iEUimyRSlnHiKgicE0DKrBAjAkjZCCRhBieAlAdfAHbTR8p2LIk0MgHOlEfuvunckbIpToINS4CnL4ZtvfXEkbI1UeKNSQApj9l3h1kjZQeohByQAFIesOk+U0bKPlyJOhoBpDxax93mi5Td0BJ4KAJIeah2e04WKXvSJfY4BJDyOL12nilSdgZM+EEIIOVBGu0/TaTsz5gMIxBAyiN0ucgckXIRzCTpngBS7r7FpSaIlEuRJk/fBPKkPLGZv5NIzym7Bn1qRtoRQMp2LIkEgboEkHJd/kbZkbIRSMJAAAIQsCCAlC0oEgMCEICAEQGkbASSMBCAAAQsCCBlC4rEgAAEIGBEACkbgSQMBCAAAQsCSNmCIjEgAAEIGBHIkvLTw93e74W8fzQqrt8wm2eXXjjePTz1O2VmBgEIiAggZREm64uQsjVR4kGgFwJIuUon9VKW/Mp6roEABOITOFIPUkbK8VcvFUKgQwJIuYp8j5KyU+7wHmNKEEgigJSRctKC4WIIQMCXAFJGyr4rjOgQgEASAaTcp5S9Z7VaZB7p2k3hWrlr8FUfzXOZB/RYeOVjCrHwRl/51kwZzc6UvasXLqOcMtpN4Vq5a3CknLNi1WOFPUXKasI5A5HyOz3hSs3B7ZTCKextpq7BkXLOclKPFfYUKasJ5wxEykj5Yv0Ib+CcVTiPNc9lHtBkmtWDCLEg5SqdQspIGSlXufVqJo0j5R0BZXzJw77OPmm/b+Mg3ERPG/G56btfCrIMiJSRMlKu6ccquSNI+eALi95KS1PzsT4XU5WZVBTqNaos4tziq9Cvc0bKSBkpVxFjzaS1pXwh5NfyZF6WxRK5Pi1UkpjFoSfPI2WkjJRr+rFK7rpSvtowJmxuE0LNUY9dLzbnit/Vhjkt7v39/Sr+y4+SlyhhX63WXIF07aZwrdw1OE9fWN0gSXGEPXV5o29fOXsaulKRxsi3PAcWTZPnsuQzLevL/AAFKU84kla58GLhzSCM5vfQwrIAp5p352ieyzxgamtiXi/EknUP6A0nc9Gh6z7Y66iKXYuuL95edDipQ2UaKZmd8suq8LidhDdDamqnsLcyXIOzU07ttcn1wp5m3QMpb+SdXbuvuwPX7V68e+3elW9lnB9H7Be7X+YphNWQC32zU0bKZbbhSNlEsqlBakt5z3qHTtq5OPFXTe1eviO5p4d70e9c2i01aU5HJ8QnYkbKSBkpp5quoeurSvnILke7yu31KXvVl65cPhqc2Ls9d+5MK+V15q2C9AOSRe3CvibO9vDyAunaTeFauWtwdspWN0hSHGFPXY4vjs8GDny0sV2ykw++4+fqoYljpLKtsvxV5kOmlJMZ7/vnfFUJl1HS0iw/I6dZOIXlTDlnOUUeK1wwHlI++1e48AN54jPi9xZIDzDOmnb1lt3a8UnvMS4T85zyOw3hSs252ZxSOIVFyjm9jjxWuGA8pKx4eGw1xOixjovnGa4UvEI4/SiU8vXZsOJfAq+LTdhXq6VZIF27KVwrdw3u/Y+VksVbLfUCcYRYYko5XZdbgb78za4e9cpfS1m479+2GymzU76QgPAGNlGJeS7zgCbTrB5EiGU0KeuF/AwUKTusa+FKzcnslMIpLMcXOb2OPFa4YIaSstjIR99OgZQdlrxwpeZkdkrhFBYp5/Q68ljhghlIymlPoomevlAfX/BGH8cXHF9E9qdLbU1LWX/keswy0YM5Ur78Lmbpk4E7sxH21WpNFUjXbgrXyl2D80af1Q2SFEfY05g75YOvttQ/dXzw4ZKTxyREUlY+pqwc9tJ/YV+T1srJxQXStZvCtXLX4EjZ6gZJiiPsaVApJ37IWkBGJNn3OPv76s2rgukH+vjqzudFK+hl8iXCmyE1rlNYzpRTG9HK9cIFk3UPKNQpPYVVfyzjqD9JUpZnP35472AXfva03/XzzeyUVfef8GZIje0UFimnNqKV64ULJqqUDz42Pc1KYq7JfLIHJeRfOffCc+f85PSR6rQviRNNTdhXq2VaIF27KVwrdw3O8YXVDZIUR9jTuFLe/4qht2ntHy8vdrjCD9+tJX/+sZW9rOLn7FYd2flR8noj7GvSWuFMWYfLtReuwZGyruOZo4Q9DSzlgzfnrt22v6m1kOflS4GwuIPLkDJnyvNtL7yBMzXhdFRSsngTAmWCCLGElvJESv2B69STho+87h9NzqD35Tu5N/H5vMWSEfbVapEVSNduCtfKXYOzU7a6QZLiCHsaXcrTnHVb3N1NrUzxLxvWJCmnVPlSGFJ+X8zClZq0+r2l47TBXJZdAIvfrrxk8TkLo/BYIZYGpPwCTqbTt0mfnANcKf5N5qlSfi7yKvb7G4VIGSlfCEF4A5toxTyXeUCTaVYPIsTSipTfeKY87HDSgz19ftxba6T8mnBv6GrjjpSRMlKuLsnSBZSQcuk5kW/znHLeO4uMhgAEqhE48lnWThlJlidQbQWRGAIQMCWAlMv70yWj6aogGAQgUI0AUnZRZPmg1VYQiSEAAVMCSLm8P10ymq4KgkEAAtUIIGUXRRIUAhCAgC0B3uiz5Uk0CEAAAlkEkHIWPgZDAAIQsCWAlG15Eg0CEIBAFgGknIWPwRCAAARsCSBlW55EgwAEIJBFACln4WMwBCAAAVsCSNmWJ9EgAAEIZBFAyln4GAyB4AT++uuv/738+f3334OXSnk3AkiZlQCBDgn88ccfNxd//fXX80fWfvvttw6n2t2UkHJ3LWVCwxP49ddfZxF/8cUX839/+eWXw7NpAABSbqBJlAgBCYHbScX2qxz++++/Sce3v+ccQ0Ky7jVIuS5/sndOYCnKSYjTqYLVhG8HFJJv05ky/vLLL8srOcew6oJHHKTsQZWYEHglsPKm1QHC9K6dRMfTNT/++ONUyrRZ/umnn5bnGP/88w9NikkAKcfsC1V1QmDak67sabJLPdkj//zzz9P2fE466XhGuTzHmF4eTCrppE+RpoGUI3WDWvolMJ/qTrr8+++/Myd6eyvvhx9+WDr3FnMy8ldffTVLeZVodY4xxcmshOHmBJCyOVICQmCHwHLLPMk0n9HR+cM333wzG3naNW8T/fnnn99+++18Tf4rRP5ciLAkgJRZDxAoRGDSn/cjw8uDi10j36Y67a+/++67WzEmrxCFCI6RBimP0WdmGYPA/G6b+ZHu9nm48xkvXyHYLMdYHa9VIOVQ7aCYzgks32ozOVyeeS1PLabIJ9vkeci0R2azHHDBIeWATaGkngksD5etnlyenllePuMhMfKEeLlZ5h2/OGsOKcfpBZWMQmBpw+kcI/OrgpYfqp7UnARx+fAyT8glofO7OK2FfnUQGQJDEZg2s8u9rW6juv1Qn3CPPKOejlO+//77WyXTy8P2AbuhmhJkskg5SCMoYzgCq8+VJHl5q+PJrTqlTqOmT/1NUp52zcP1IOSEkXLItlDUGASWG9XbdvXyC4P+/fff1QdAplGTVXVGnjHzqes4Kw4px+kFlYxIYOvl1ceyz3/M1/GI0GPPGSnH7g/VDUBg9W1BQimrzysGINr2FJFy2/2j+p4ICO1s9SBdT+h6mgtS7qmbzAUCEGieAFJuvoVMAAIQ6IkAUu6pm8wFAhBongBSbr6FTAACEOiJAFLuqZvMBQIQaJ4AUm6+hUwAAhDoiQBS7qmbzAUCEGieAFJuvoVMAAIQ6IkAUu6pm8wFAhBongBSbr6FTAACEOiJAFLuqZvMBQIQaJ4AUm6+hUwAAhDoiQBS7qmbzAUCEGieAFJuvoVMAAIQ6IkAUu6pm8wFAhBongBSbr6FTAACEOiJAFLuqZvMBQIQaJ7A/wFGguqGDAna2QAAAABJRU5ErkJggg==)

$head_i$ 可以从 $head_{i-1}$ 转移过来，还可以直接用 $a_i$。然后更新 $head$ 数组。

$tail$ 数组同理。

处理完从首尾出发的最大子段和之后枚举断点，计算两边最大的和，求出答案。

## 坑点：

中间一定要隔一个位置！！！

还有一个情况，就是 $head_1+tail_3$ 也可能是最终答案！

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1000010],head[1000010],tail[1000010],ans;
int main(){
	cin >> n;
	for(int i=1;i<=n;i++) cin >> a[i];
	//从前往后找最大子段和 
	head[1]=a[1];
	for(int i=2;i<=n;i++) head[i]=max(head[i-1]+a[i],a[i]);
	for(int i=2;i<=n;i++) head[i]=max(head[i-1],head[i]);
	//从后往前找最大子段和 
	tail[n]=a[n];
	for(int i=n-1;i>=1;i--) tail[i]=max(tail[i+1]+a[i],a[i]);
	for(int i=n-1;i>=1;i--) tail[i]=max(tail[i+1],tail[i]);
	//枚举断点 
	ans=head[1]+tail[3];
	for(int i=3;i<n;i++) ans=max(ans,head[i-1]+tail[i+1]);
	cout << ans;
	return 0;
}
```


---

## 作者：冰糖鸽子 (赞：2)

~~离CSP只有半个月了为什么我还在写题解~~

---

这题差不多算是两道题的结合体

[P1091 合唱队型](https://www.luogu.com.cn/problem/P1091)

[P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)

没做过的可以先去做一下啊awa

----

#### 思路

可以枚举中间肯定不取的那个点，枚举 $n$ 次。再计算两边的最大子段和，时间复杂度 $\operatorname{O(n^2)}$ ，期望得分 60

可以发现，以所有 $a_i$ 为开头/结尾（一定包含 $a_i$ ） 的最大字段和实可以通过状态转移用 $\operatorname{O(n)}$ 的时间算出来的（后面会讲）

所以先初始化，再枚举中间点的时间复杂度是 $\operatorname{O(n)}$，期望得分 100


----

#### 实现

求最大子段和的方法很多题解都讲到过，这里再叙述一下：

设 $f_i$ 为以 $a_i$ 结尾的最大子段和

可得到转移方程为（循环从 $1 - n $）：
$$f_i = \max(f_{i-1},0) +a_i $$

设 $f2_i$ 为以 $a_i$ 开头的最大子段和

可得到转移方程为（循环从 $n - 1$）：

$$f2_i = \max(f_{i+1},0) + a_i$$

取上面任意一个数组的最大数则为此数列的最大子段和

下一步，求分割点为 $i$ 的前/后子段中的最大子段和：

设 $l_i$ 为 以 $1$ 开头 以$a_i$ 结尾 的子段中的最大子段和

可得到转移方程为（循环从 $1 - n$）：

$$l_i = \max(l_{i-1},f_i)$$

设 $r_i$ 为 以 $a_i$ 开头 以 $n$ 结尾 的子段中的最大子段和

可得到转移方程为（循环从 $n - 1$）：

$$r_i = \max(r_{i+1},f2_i) $$

枚举中间点 **循环从 $2-(n-1)$** ：

$$ans = \max(ans,l_{i-1}+r_{i+1})$$

最后提醒一下，要初始化为负无穷

----

#### 代码

七个循环虽然很吓人，但每个循环都只有一行代码哦

[AC记录-1](https://www.luogu.com.cn/record/40090960)

```

执着换行版

// Problem: P1115 最大子段和
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1115
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <bits/stdc++.h>
using namespace std;
#define INF 1000000000
#define maxn 1000010
#define int long long
int n,a[maxn],f[maxn],f2[maxn],l[maxn],r[maxn],sum,ml=-INF,mr=-INF,ans=-INF;
signed main()
{
	cin >> n;
	for(int i = 0;i <= n+2;i++)
	{
		a[i]=f[i]=f2[i]=l[i]=r[i]=-INF;
	}
	for(int i=1;i<=n;i++)
	{
		cin >> a[i];
	}
	for(int i=1;i<=n;i++)
	{
		f[i]=(f[i-1]<0?0:f[i-1])+a[i];
	}
	for(int i=n;i>0;i--)
	{
		f2[i]=(f2[i+1]<0?0:f2[i+1])+a[i];
	}
	for(int i = 1;i <= n;i++)
	{
		l[i]=(l[i-1]<f[i]?f[i]:l[i-1]);
	}
	for(int i = n;i > 0;i--)
	{
		r[i]=(r[i+1]<f2[i]?f2[i]:r[i+1]);
	}
	for(int i = 2;i < n;i++)
	{
		ans=max(ans,l[i-1]+r[i+1]);
	}
	cout << ans;
	return 0;
}
```

[AC记录-2](https://www.luogu.com.cn/record/40091086)

```
开心压行版


// Problem: P1115 最大子段和
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1115
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <bits/stdc++.h>
using namespace std;
#define INF 1000000000
#define maxn 1000010
#define int long long
int n,a[maxn],f[maxn],f2[maxn],l[maxn],r[maxn],sum,ml=-INF,mr=-INF,ans=-INF;
signed main()
{
	cin >> n;
	for(int i = 0;i <= n+2;i++){a[i]=f[i]=f2[i]=l[i]=r[i]=-INF;}
	for(int i=1;i<=n;i++){cin >> a[i];}
	for(int i=1;i<=n;i++){f[i]=(f[i-1]<0?0:f[i-1])+a[i];}
	for(int i=n;i>0;i--){f2[i]=(f2[i+1]<0?0:f2[i+1])+a[i];}
	for(int i = 1;i <= n;i++){l[i]=(l[i-1]<f[i]?f[i]:l[i-1]);}
	for(int i = n;i > 0;i--){r[i]=(r[i+1]<f2[i]?f2[i]:r[i+1]);}
	for(int i = 2;i < n;i++){ans=max(ans,l[i-1]+r[i+1]);}
	cout << ans;
	return 0;
}

```

----

祝大家 CSP2020 RP++ Score++

---

## 作者：zhengrunzhe (赞：2)

这题被我们当作了个考题..

dp不会 当场打个Splay

刚开始想着线段树就好了

但因为做过P2042维护数列 那题要用Splay 所以打区间最大子段和还是Splay比较熟练

[2,n-1]中枚举两个序列的分隔点

假设在[pos,pos]处分开

那pos的答案就是[1,pos-1]的最大子段和+[pos+1,n]的最大子段和

最终答案就是所有pos的答案最大值
```cpp
#include<cstdio>
#include<climits>
#include<algorithm>
using std::max;
using std::fill;
template<class type>inline void read(type &in)
{
	in=0;char ch=getchar();short fh=1;
	while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
	in*=fh;
}
const int N=1e6+10;
typedef long long ll;
int n;
ll a[N],ans=LLONG_MIN;
namespace Splay
{
	struct tree
	{
		int size;
		ll value,lmx,mx,rmx,sum;
        //value:该点的权值 lmx:左数最大子段和 mx:最大子段和 rmx:右数最大子段和 sum:和
		tree *fa,*son[2];
		inline void pushup()
		{
			size=son[0]->size+son[1]->size+1;
			sum=son[0]->sum+value+son[1]->sum;
			mx=max(value,son[0]->rmx+value+son[1]->lmx);
			mx=max(mx,max(son[0]->mx,son[1]->mx));
            //最大子段和=max(左右儿子的最大子段和,自己权值,左儿子右数+自己+右儿子左数)
			lmx=max(max(son[0]->lmx,son[0]->sum+value+son[1]->lmx),0LL);
			rmx=max(max(son[1]->rmx,son[1]->sum+value+son[0]->rmx),0LL);
            //更新左数/右数
		}
		inline bool relation()
		{
			return fa->son[1]==this;
		}
	}*root,memory_pool[N],*tail,*null;
	inline void init()
	{
		tail=memory_pool;
		null=tail++;null->mx=LLONG_MIN;
		null->size=null->value=null->sum=null->lmx=null->rmx=0;
		null->fa=null->son[0]=null->son[1]=null;
		root=null;
	}
	inline tree *newtree(ll key)
	{
		tree *p=tail++;
		p->size=1;
		p->mx=p->value=p->sum=key;
		p->lmx=p->rmx=max(key,0LL);
		p->fa=p->son[0]=p->son[1]=null;
		return p;
	}
	inline tree *build(int l,int r,tree *fa) //建树
	{
		if (l>r)return null;
		int mid=l+r>>1;
		tree *p=newtree(a[mid]);p->fa=fa;
		if (l==r)return p;
		p->son[0]=build(l,mid-1,p);
		p->son[1]=build(mid+1,r,p);
		return p->pushup(),p;
	}
	inline void connect(tree *p,tree *fa,bool which)
	{
		if (p!=null)p->fa=fa;
		if (fa!=null)fa->son[which]=p,fa->pushup();
	}
	inline void rotate(tree *p)
	{
		tree *fa=p->fa;
		bool id=p->relation();
		connect(p,fa->fa,fa->relation());
		connect(p->son[id^1],fa,id);
		connect(fa,p,id^1);
	}
	inline void splay(tree *p,tree *goal)
	{
		for (tree *fa;(fa=p->fa)!=goal;rotate(p))
			if (fa->fa!=goal)
				rotate(p->relation()^fa->relation()?p:fa);
		if (goal==null)root=p;
	}
	inline tree *findrank(int ranking)
	{
		ranking++;tree *now=root;
		while (1)
			if (ranking<=now->son[0]->size)now=now->son[0];
			else
			{
				ranking-=now->son[0]->size+1;
				if (!ranking)return now;
				now=now->son[1];
			}
	}
	inline tree *split(int l,int r) //把区间[l,r]提取出来
	{
		tree *pre=findrank(l-1),*nxt=findrank(r+1);
		splay(pre,null);splay(nxt,pre);
		return nxt->son[0];
	}
	inline ll query(int l,int r)
	{
		return split(l,r)->mx;
	}
}using namespace Splay;
int main()
{
	read(n);
	for (int i=1;i<=n;i++)read(a[i]);
	init();a[0]=LLONG_MIN;a[n+1]=LLONG_MIN;
	root=build(0,n+1,null);
	for (int i=2;i<n;i++)
	{
		ll lans=query(1,i-1),
		   rans=query(i+1,n);
		ans=max(ans,lans+rans);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：BoAn (赞：1)

每次枚举一个 $i$，将序列分成 $[1,i-1]$ 和 $[i+1,n]$ 两个区间，再对两个区间的最大连续子序列和相加，复杂度是 $O(n)$，再来看数据范围 $n≤10^6$，所以必须保证每次查询都是 $O(1)$，这里需要预处理。

定义 $f_i$ 表示以 $a_i$ 结尾的最大连续子序列和，$f1_i$ 表示以 $a_i$ 开头的最大连续子序列和。那么可以推出状态转移方程：

$f_i=\max(a_i,f_{i-1}+a_i)$

这里我们稍稍拐个弯，求出 $f_i$ 之后，再对每个 $f_i$ 进行与 $f_{i-1}$ 的比较，也就是不再限制结尾是谁，现在 $f_i$ 表示的是区间 $[1,i]$ 内的最大连续子序列和。

$f1_i$ 同理。


然后要提醒的是一个比较微妙的点，看下面这份 $50$ 分的代码：
```cpp
#include<iostream>
using namespace std;
long long n,a[1000010],f[1000010],f1[1000010];
long long ans=-9223372036854775808;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	f[1]=a[1];f1[n]=a[n];
	for(int i=2;i<=n;i++){
		f[i]=max(a[i],f[i-1]+a[i]);
		f[i]=max(f[i],f[i-1]);
	}
	for(int i=n-1;i>=1;i--){
		f1[i]=max(a[i],f1[i+1]+a[i]);
		f1[i]=max(f1[i],f1[i+1]);
	}
	for(int i=2;i<n;i++)
		ans=max(ans,f[i-1]+f1[i+1]);
	cout<<ans;
	return 0;
}
```
这份代码对 $f_i$ 的定义是，区间 $[1,i]$ 内的最大子序列和。也就是说，它并不是连续的。为什么这样说呢？如果选了 $f_{i-1}+a_i$，但事实上 $f_{i-1}$ 并不保证以 $a_{i-1}$ 结尾。

为了证实这一点，我们出一组数据：


$5$

$1$ $-2$ $3$ $-4$ $5$

输出是 $9$，但正确答案应该是 $8$。它选择了以 $-4$ 为分界线， 左边是 $1+3$，右边是 $5$，但 $1+3$ 并不能构成一个连续子序列，错误原因是它在进行 $f_2$ 的赋值时选择了 $1$，又在 $f_3$ 选择了 $1+3$ ，但中间隔了一个 $-2$。

还有一个可能错误的地方：

>每个连续子序列的最小长度为 $1$

也就是说，当全都是负数的时候，你起码也要选一个最大的负数，而不是 $0$。

最后一份 $AC$ 的代码：
```cpp
#include<iostream>
using namespace std;
long long n,a[1000010],f[1000010],f1[1000010];
long long ans=-9223372036854775808;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	f[1]=a[1];f1[n]=a[n];
	for(int i=2;i<=n;i++)f[i]=max(a[i],f[i-1]+a[i]);
	for(int i=2;i<=n;i++)f[i]=max(f[i],f[i-1]);
	for(int i=n-1;i>=1;i--)f1[i]=max(a[i],f1[i+1]+a[i]);
	for(int i=n-1;i>=1;i--)f1[i]=max(f1[i],f1[i+1]);
	for(int i=2;i<n;i++)ans=max(ans,f[i-1]+f1[i+1]);
	cout<<ans;
	return 0;
}
```

---

## 作者：紫薯布丁 (赞：1)

## 某场考试中看到这道题目想都没想就用dp推了


#### 令F[i]表示从1到i中权值最大的连续子序列的大小

 容易发现状态转移时具有三种情况
 
 (1) 序列里加上第i个元素显然更优,此时f[i]=f[i-1]+a[i] 
 
  (2) 加上第i个元素不会更优，这时我们可以
  
  【1】 保留原来的子序列，即f[i]=f[i-1]
  
 【2】  继续往前走更新新的序列，当新序列比旧序列更优，进行更新，我们用s1存储更新的序列
 
### 则转移方程为s=max(s1+a[i],a[i]) f[i]=max(f[i-1],s1);
		 
因为要求两段序列，所以我们倒着存一遍数组也按这种方法进行转移，枚举中间点即可

# 

------------
###### 还有，注意答案会爆int ，所以要long long 
```cpp
#include<iostream>
#include<cstdio>
#define int long long
#define ss 1005000
using namespace std;
int a[ss],b[ss],f[ss],f2[ss],n;
bool b1[ss],b2[ss];
main(){
	scanf("%lld",&n);
	for(register int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		b[n-i+1]=a[i];
	}int s1,s2;
	f[1]=a[1];s1=a[1];
	f2[1]=b[1];s2=b[1];
	for(register int i=2;i<=n;i++){
		s1=max(a[i],s1+a[i]);
		f[i]=max(f[i-1],s1);
      f[i]==f[i-1]&&a[i]<0?b1[i]=1:0; 
		s2=max(b[i],s2+b[i]);
		f2[i]=max(f2[i-1],s2);
      f2[i]==f2[i-1]&&b[i]<0?b2[i]=1:0;
	}
    f[1]=a[1];f2[1]=b[1];
	int ans(-99999);
	for(register int i=1;i<=n&&n-i-1>0;i++){
	//	printf("f[%d]=%d f2[%d]=%d\n",i,f[i],n-i-1,f2[i]);
		ans=max(ans,f[i]+f2[n-i-1]);
	}                                           
	cout<<ans;
}
```

  

---

## 作者：Q小Y (赞：1)

这道题不能按普通算法做，不然会超时，所以要优化...........（纯属废话）

因为两个子序列之间要隔一个数，所以可以枚举断开点i，将i之前的最大子序列f[i]和之后的g[i]相加，打擂台，看哪一个断开点的结果最大，输出结果。

为了进一步优化，我们可以将数据初始化。

贴上代码（Pascal）

```cpp
var
  a,f,g:array[0..1000005] of int64;
  n,i,ans:longint;
begin
  read(n);
  for i:=1 to n do read(a[i]); //读入
  for i:=1 to n do
    if f[i-1]>=0 then f[i]:=f[i-1]+a[i] else f[i]:=a[i];
  for i:=2 to n do
    if f[i]<f[i-1] then f[i]:=f[i-1]; //初始化，f[i]是到i为止之前的最大子段和
  for i:=n downto 1 do
    if g[i+1]>=0 then g[i]:=g[i+1]+a[i] else g[i]:=a[i];
  for i:=n-1 downto 1 do
    if g[i]<g[i+1] then g[i]:=g[i+1]; //also初始化，g[i]是i之后的最大子段和
  ans:=-maxlongint;
  for i:=2 to n-1 do
    if f[i-1]+g[i+1]>ans then ans:=f[i-1]+g[i+1]; //打擂台，找最大和
  write(ans);
end.
```

---

## 作者：flysnow (赞：0)

## P2642 【双子序列最大和】

- 首先转化题意，枚举断点 $i$，然后，计算前缀最大子段和与后缀最大子段和。

那么我们就可以 $O(n^2)$ 算出最后的结果了。

- 但是这样的时间复杂度是完全不足以通过此题的，所以考虑优化。

我们可以维护两个数组 $pre_i,suf_i$ 表示第 $i$ 个点的前缀最大子段和与后缀最大子段和。

怎么维护呢？

以下是对于 $pre$ 数组的维护（注释在代码中）：

```cpp
for (int i = 1; i <= n; i ++)
	pre[i] = max(a[i], pre[i - 1] + a[i]);//计算以i结尾的最大子段和
	
for (int i = 2; i <= n; i ++) 
	pre[i] = max(pre[i], pre[i - 1]);//更新最大值
```
$suf$ 数组也同理。

$AC$ $Code$

```cpp
#include <bits/stdc++.h>
#define ll long long

const int N = 1e6 + 5;

using namespace std;

int n;

ll a[N], suf[N], pre[N];

ll ans;

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++) 
		scanf("%lld", &a[i]);
	for (int i = 1; i <= n; i ++)
		pre[i] = max(a[i], pre[i - 1] + a[i]);
		
	for (int i = 2; i <= n; i ++) 
		pre[i] = max(pre[i], pre[i - 1]);
		
	for (int i = n; i >= 1; i --)
		suf[i] = max(a[i], suf[i + 1] + a[i]);
		
	for (int i = n - 1; i >= 1; i --)
		suf[i] = max(suf[i], suf[i + 1]);
		
	ans = -0x7ffffffffffffff;
	for (int i = 2; i < n; i ++) 
		ans = max(ans, pre[i - 1] + suf[i + 1]);
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：Celtic (赞：0)


题意：求两个不相交的连续子段，使它们的和最大。

考虑因为两个子段不相交，可以枚举子段的中间点。然后问题就等价于分别求左边的最大连续字段和和右边的最大连续字段和。

上述的两个子段和预处理。

设$F[i]$表示$i$左边的最大连续字段和，维护一个$minn$为$[1,n]$的前缀和最小值。

所以$F[i]=max(F[i-1],sum[i]-minn)$;

这个$O(n)$求一下，右边的同理。

最后就直接取最大即可。


```cpp
#include<bits/stdc++.h>
#define eps 1e-7
#define re register
#define N 2001001
#define MAX 2001
#define PI 3.1415927
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
    ret=pd?-ret:ret;
}
ll n,a[N],sum[N],minn,x[N],y[N],maxn,ans=-inf;
int main()
{
//	freopen("name.in","r",stdin);
	read(n);
	for(re int i=1;i<=n;i++)
		read(a[i]),sum[i]=sum[i-1]+a[i];
	sum[n+1]=sum[n];
	minn=inf;
	x[0]=-inf;
	for(re int i=1;i<=n;i++)
	{
		minn=min(minn,sum[i-1]);
		x[i]=max(x[i-1],sum[i]-minn);
	}
	maxn=-inf;
	y[n+1]=-inf;
	for(re int i=n;i;i--)
	{
		maxn=max(maxn,sum[i]);
		y[i]=max(y[i+1],maxn-sum[i-1]);
	}
/*	for(re int i=1;i<=n;i++)
		printf("x[%d]=%lld y[%d]=%lld\n",i,x[i],i,y[i]);*/
	for(re int i=2;i<=n-1;i++)
		ans=max(x[i-1]+y[i+1],ans);
	printf("%lld\n",ans);
	exit(0);
}
```


---

## 作者：swkyccbb (赞：0)

这是一道$DP$题，我们要想求出双子序列最大和，那么我们要先求出最大子段和。我们把从前到后和从后到前的以第$i$个数为结尾的最大子段和求出来，分别设为$f[i]$和$k[i].然后将$f[i]$和$k[i]$转化为前$$i$个数中的最大子段和。题目中说两个连续子序列之间至少间隔一个数，将ans设为$f[1]+k[3]$来避免负数的影响，所以我们枚举$i$从$3$到$n-1$比出$f[i-1]+k[i+1]$的最大值（隔第$i$个数）。最后输出答案ans就可以了。


根据小编的方法要特判$n=3$的情况，但这里好像不判也能过
~~（数据好水）~~

附上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000002],f[1000002],k[1000002],ans;
signed main() {
	scanf("%lld",&n);
	for(int i=1; i<=n; i++) scanf("%lld",&a[i]);
	if(n==3){	//注意这里要特判n=3的情况 
		printf("%lld\n",a[1]+a[3]);
		return 0;
	}
	f[1]=a[1];
	for(int i=2; i<=n; i++) f[i]=max(a[i],f[i-1]+a[i]);	//从前到后的以i结尾的最大子段和 
	for(int i=2; i<=n; i++) f[i]=max(f[i],f[i-1]);	//从前到后前前i个数的最大子段和 
	k[n]=a[n];
	for(int i=n-1; i>=1; i--) k[i]=max(a[i],k[i+1]+a[i]);//从后到前的以i结尾的最大子段和 
	for(int i=n-1; i>=1; i--) k[i]=max(k[i],k[i+1]); //从后到前前i个数的最大子段和 
	ans=f[1]+k[3];
	for(int i=3; i<n; i++) ans=max(ans,f[i-1]+k[i+1]);		//比出最大值 
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

# Ads
个人博客同步：

wordpress版：[点我](https://oldblog.cinema000.xyz/1627.ruby)

hexo版：[点我](https://blog.cinema000.xyz)

如果想要支持我的话就请点击wordpress版链接（已加入Google Adsense）

# 分析

这里是NOIP 2015初赛完善程序的第一题，思路就是DP来搞，其他题解讲的很详细，我就不重复造轮子了，这里是Java的题解（但是因为Luogu不给Java提供其他一般OJ都会提供的两倍时空限制，所以MLE阿wori）。

# 代码

```java
import java.io.BufferedInputStream;
import java.io.IOException;
import java.util.Scanner;

public class Main{
	@SuppressWarnings("resource")
	public static void main(String[] args)throws IOException{
		Scanner in = new Scanner(new BufferedInputStream(System.in));
	    int n = in.nextInt();long ans = 0,sum = 0;
	    int[] A = new int[n];
		int[] L = new int[n];
		int[] R = new int[n];
	    for(int i = 0;i < n;i++) A[i] = in.nextInt();
	    L[0] = A[0];R[n - 1] = A[n - 1];
	    for(int i = 1;i < n;i++)
	        if(L[i - 1] <= 0) L[i] = A[i];
	        else L[i] = L[i - 1] + A[i];
	    for(int i = 1;i < n;i++) L[i] = L[i] < L[i - 1] ? L[i - 1] : L[i];
	    for(int i = n - 2;i >= 0;i--)
	        if(R[i + 1] <= 0) R[i] = A[i];
	        else R[i] = R[i + 1] + A[i];
	    for(int i = n - 2;i >= 0;i--) R[i] = R[i] < R[i + 1] ? R[i + 1] : R[i];
	    ans = A[0] + A[2];
	    for(int i = 1;i < n - 1;i++){
	        sum = L[i - 1] + R[i + 1];
	        ans = sum > ans ? sum : ans;
	    }
	    System.out.println(ans);
	}
}

```



# Hints

在Luogu交Java就是要注意类名，不管是不是public的，都得有个叫Main的类，不然就直接返回RE，，，

---

## 作者：江屿 (赞：0)

```cpp
//c++代码，2015年初赛提高组完善程序第一题
#include<iostream>
using namespace std;
const int MAXN=1000000;
long long n,i,ans,sum;
int x[MAXN];
int lmax[MAXN];//lmax[i]为仅含x[i]及x[i]左侧整数的连续子序列的序列和，最大的序列和
int rmax[MAXN];//rmax[i]为仅含x[i]及x[i]右侧整数的连续子序列的序列和，最大的序列和
int main()
{
    cin>>n;
    for(i=0;i<n;++i)
    cin>>x[i];
    lmax[0]=x[0];
    for(i=1;i<n;++ i)
      if(lmax[i-1]<=0)
        lmax[i]=x[i];
      else lmax[i]=lmax[i-1]+x[i];
    for(i=1;i<n;++i)
      if(lmax[i]<lmax[i-1])
        lmax[i]=lmax[i-1];
    rmax[n-1]=x[n-1];
    for(i=n-2;i>=0;--i)
      if(rmax[i+1]<=0)
        rmax[i]=x[i];
      else rmax[i]=rmax[i+1]+x[i];
    for(i=n-2;i>=0;--i)
      if(rmax[i]<rmax[i+1])
        rmax[i]=rmax[i+1];
    ans=x[0]+x[2];
    for(i=1;i<n-1;i++)
    {
        sum=lmax[i-1]+rmax[i+1];
        if(sum>ans)ans=sum;
    }
    cout<<ans<<endl;
    return 0;
}
```

---


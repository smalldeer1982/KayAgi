# 小 Q 的赚钱计划

## 题目背景

小 Q（郑重其事地）：今年我一定要赚大钱！！！


## 题目描述

小 Q 决定在新的一年里赚大钱，小 P 给 TA 推荐了理财。小 Q 在今年初（非闰年）有 $10^5$ 元（好有钱啊），有 $N$ 个理财产品，每个理财产品用三个参数描述：购买时间，投资天数，年利息率。每个时刻小 Q 只能拥有最多一件产品，求一年后最多可以获得多少钱。


## 说明/提示

$0 \le N \le 10^4$

## 样例 #1

### 输入

```
3
0101 100 4.5
0201 30 5
0402 50 7.8```

### 输出

```
101483.84```

# 题解

## 作者：bigclever (赞：15)

## 思路：
本题需要使用**动态规划**实现。

设 $dp_i$ 表示**第 $i$ 天的最大收益**，我们先让 $dp_i=dp_{i-1}$，即把上一天的最大收益先转移过来，然后枚举每一个理财产品，如果它刚好是第 $i$ 天到期，那么 $dp_i$ 就取**该理财产品的收益**和 $dp_i$ 之间的最大值。因为是求一年后的最大收益，所以答案即为 $dp_{366}$。

当然还有几个需要**注意**的问题：
1. 题目读入的时间格式为 `MMDD`，所以需要先算出到第 $i$ 月已经过去了多少天，再加上天数才是真正的购买时间。
2. 理财产品收益的计算方式：设该产品的购买时间为 $x$，投资天数为 $y$，年利息率为 $z$，那么该产品收益为 $dp_x \times [1+(z \div 100) \div 365] \times y$。
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int st[10005],day[10005];
double lx[10005],dp[367];
const int mon[]={0,0,31,59,90,120,151,181,212,243,273,304,334};
int main(){
        int n; cin>>n;
        for(int i=1,x;i<=n;i++){
            cin>>x>>day[i]>>lx[i];
            st[i]=mon[x/100]+x%100;//转换为真正的购买时间
        }
        dp[1]=100000;//第一天最大收益为100000
        for(int i=2;i<367;i++){
            dp[i]=dp[i-1];
            for(int j=1;j<=n;j++)
                if(st[j]+day[j]==i)//如果该理财产品刚好是第i天到期
                    dp[i]=max(dp[i],dp[st[j]]*(1+(lx[j]/100)/365*day[j]));//取最大收益
        }
        printf("%.2lf",dp[366]);
        return 0;
}
```

---

## 作者：qwerty12346 (赞：12)

# [题目传送门](https://www.luogu.com.cn/problem/P2721)

## 题意

这道题就是让我们求小 Q 一年后最多可以获得多少钱。并且要保留两位小数。

## 思路

这是一道动态规划的题。然后我们可以预处理每月的钱数，然后定义一个 $dp$ 数组存 $2$ $\sim$ $366$ 每天最大的利率。$f_{1}$ 我们可以定义为 $100000$。最后输出 $f_{366}$ 就行了。

## 状态定义

$dp_{i}$ 表示第 $i$ 天的最大收益。 
## 状态转移方程

 $dp_{i}=\max(dp_{a_{j}}*(1+(c_{j}÷100)÷365×b_{j}),dp_{i})$

### 代码
```
#include<bits/stdc++.h>
using namespace std;
long long n,x,a[1000005],b[1000005];
long long month[105]={0,0,31,59,90,120,151,181,212,243,273,304,334};//预处理
double c[1000005],f[1000005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>x>>b[i]>>c[i];
        a[i]=month[x/100]+x%100;//转换为购买的时间

    }
    f[1]=100000;//第一天的最大收益为100000
    for(int i=2;i<=366;i++)
    {
        f[i]=f[i-1];
        for(int j=1;j<=n;j++)if(a[j]+b[j]==i)f[i]=max(f[a[j]]*(1+(c[j]/100)/365*b[j]),f[i]);//如果这个理财产品刚刚好是第i天到期那么就取这天的最大收益
    }
    printf("%.2lf",f[366]);
    return 0;
}
```


---

## 作者：Enzymii (赞：8)

题目难度标签有毒→\_→

其实我不知道为什么会有辣么多90分的→\_→

反正我是一遍就A掉了→\_→


可以看到时间变化只有365而n却有10000,所以像会场安排一样的$O(n^2)$的做法是不可取的,

我们要按时间递推,如果第i天是某个活动的结尾时间,那么就可以转移,否则将上一天的最优值推过来就行了= =


代码一点也不长

```cpp
#include <cstdio>
double f[366];
//预处理出每个月1号之前有多少天(主要是因为懒)
const int day[13]={0,0,31,59,90,120,151,181,212,243,273,304,334};
//表示每个产品的开始日期,结束日期和收益(x=1+k%)
struct pro{int l,r; double x;}p[10101];
inline int gn(){
    int a=0;char c=getchar();for(;c<'0'||c>'9';c=getchar());
    for(;c>='0'&&c<='9';c=getchar()) a=(a<<1)+(a<<3)+c-'0'; return a;
}
inline double max(const double &a,const double &b){if(a>b) return a;return b;}
inline double min(const double &a,const double &b){if(a<b) return a;return b;}
int main()
{
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int ti=gn(),len=gn(); double x; scanf("%lf",&x);
        p[i].l=day[ti/100]+ti%100; p[i].r=p[i].l+len-1; //处理第i项产品周期的左右端点
        p[i].x=1.0+0.01*x*(len/365.0); //题目中说的是年利率,所以要这样处理..
    } f[0]=1;
    for(int i=1;i<=365;i++){
        f[i]=f[i-1];
        for(int j=1;j<=n;j++)
            if(p[j].r==i)
                f[i]=max(f[i],f[p[j].l-1]*p[j].x);
    }
    printf("%.2lf",f[365]*1e5); //原来有10W
}
```
祝大家玩的开心~

~~毕竟可以轻松地水过一道NOI/NOI+/CTSC的题嘛~~


---

## 作者：Zq_water (赞：6)

一道动态规划的题。

我们令 $dp_i$ 为前 $i$ 天的最大收益，那么我们很容易可以想到状态转移的方法：

1.第 $i$ 天没有理财产品结束，则第 $i$ 天的最大收益与第 $i-1$ 天的最大收益相等，即 $dp_i=dp_{i-1}$。

2.第 $i$ 天有理财产品结束(假设理财产品编号为 $j$)，那么该理财产品的收益是 $dp_{start_j}\times (1+c_j \div 365 \times time_j)$，那么状态转移方程就是 $dp_i=\max(dp_i,dp_{start_j}\times (1+c_j/365\times time_j))$

那么我们可以这样做：输入的时候先把以 MMDD 形式的日期处理成天数，这里我们可以打个表。接下来，将 $dp_1$ 设为 $100000$，遍历 $2 \sim 366$，每次先将 $dp_i$ 设为 $dp_{i-1}$，判断这一天是否有理财产品结束，如果有 $dp_i=\max(dp_i,dp_{start_j}\times (1+c_j/365\times time_j))$。最后只需输出 $dp_{366}$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

int month[13]={0,0,31,59,90,120,151,181,212,243,273,304,334};
int n,tmp,start[1000001],tim[1000001];
double c[1000001],dp[1000001];

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d %d %lf",&tmp,&tim[i],&c[i]);
        start[i]=month[tmp/100]+tmp%100;//预处理起始时间 
        c[i]/=100;
    }
    dp[1]=100000;//一开始有100000元 
    for(int i=2;i<=366;i++){
        dp[i]=dp[i-1];
        for(int j=1;j<=n;j++) if(start[j]+tim[j]==i) dp[i]=max(dp[start[j]]*(1+c[j]/365*tim[j]),dp[i]);//有产品结束，则修改 
    }
    printf("%.2lf",dp[366]);
    return 0;
}
```

---

## 作者：Chis725 (赞：6)

## 本题思路：
明显是一道关于动态规划的题，先建一个动规数组，每一项表示每天的最大收益。一年最多只有 $365$ 天，所以我们可以跑一个 $365$ 次的循环，每次判断每个理财产品是否到期，再用银行算利息的方法算出收益。然后就是他按照月份读入，我么可以先预处理一个数组打出一个月份的表，之后借助月份数组把哪个月的第几天转化成为一年中的第几天。

------------
代码献上：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int month[13]={0,0,31,59,90,120,151,181,212,243,273,304,334};//月份数组
int n,x,a[1000001],b[1000001];
double c[1000001],f[1000001];
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x>>b[i]>>c[i];
        a[i]=month[x/100]+x%100;//天数处理
    }
    f[1]=100000;//初始化
    for(int i=2;i<=366;i++){
        f[i]=f[i-1];
        for(int j=1;j<=n;j++){
            if(a[j]+b[j]==i){//到期了
                f[i]=max(f[a[j]]*(1+(c[j]/100)/365*b[j]),f[i]);//状态转移方程
            }
        }
    }
    printf("%.2lf",f[366]);//输出最后一天最大的收益
    return 0;
}
```
完结撒花！！！

---

## 作者：xMinh (赞：2)

小Q的赚钱计划(luogu 2721)

我只能说这道水题简直有毒，常识题啊

给一个不一样的方法 ，但要先说三个恶心的地方

第一个点，年利率的计算方式，是启用了一个产品的时候以上一个产品作为本金

而且给出的那个利率是按照365天来计算的，所以你要算出这个产品的时间与365天的比例

然后再和原利率相乘，才是某个产品真正的利率

第二个点，明年元旦是可以收钱的，因为题目里说了“一年后”，但是明年的第二天就没办法收钱了

要把终止日期超过明年元旦的产品清理掉

第三个点，题目里给出的产品是乱序的，要先排序

注意好这三个地方，就可以直接用线段覆盖的做法来做这个题了

只是要先变年月为日期，用一个前缀和打表就能做到

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const double bj=100000; 
struct node
{
    int l,r;double num;
}a[10001];
int year[13]={0,31,59,90,120,151,181,212,243,273,304,334,365},n;
double f[10001];
double max(double x,double y)
{
    if (x>y) return x;else return y;
}
double lilv(int x)
{
    int kk=a[x].r-a[x].l;
    double len=kk/(365*1.0);
    return a[x].num*len;
}
bool cmp(node a,node b)
{
    return a.r<b.r;
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        int left,len,moon,date;double sum;
        cin>>left>>len>>sum;
        moon=left/100;date=left%100;
        left=year[moon-1]+date;
        a[i].l=left;a[i].r=left+len;a[i].num=sum/(100*1.0);
        if (a[i].r>366) {i--;n--;}
    }
    sort(a+1,a+n+1,cmp);
    for (int i=1;i<=n;i++)
    {
        f[i]=bj*(1.0+lilv(i));
        for (int j=i-1;j>=1;j--)
            if (a[j].r<=a[i].l)
                f[i]=max(f[i],f[j]*(1.0+lilv(i)));
    }
    double ans=bj;
    for (int i=1;i<=n;i++)
        ans=max(ans,f[i]);
    printf("%.2lf",ans);
}
```

---

## 作者：copper_ingot (赞：2)

本蒟蒻的第一篇题解

[题目传送门](https://www.luogu.com.cn/problem/P2721)

这是一道非常简单的动规题。

令 $f _ {i}$ 为第 $i$ 天的最大收益，设 $f _ {0} = 100000$。让 $i$ 从 $1$ 开始，如果当天没有理财产品结束，则当天最大收益就是前一天的最大收益，$f _ {i} = f _ {i-1}$。

否则，如果当天第 $j$ 号理财产品结束了，那么这个理财产品的收益就是 $f _ {st _ {j}} \times (1 + (c _ {j} \div 100) \div 365 \times b _ {j})$。其中 $st _ {j}$ 表示第 $j$ 号产品的开始时间，$b _ {j}$ 表示第 $j$ 号产品的持续时间，$c _ {j}$ 表示利率。

所以，状态转移方程就是 $f _ {i} = \max(f _ {st _ {j}} \times (1 + (c _ {j} \div 100) \div 365 \times b _ {j}),f _ {i})$。

最后的答案就是 $f _ {365}$。

贴上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int homo = 114514;
int n, st[homo], b[homo], x;
double c[homo], f[homo];
int d[13] = {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d%d%lf", &x, &b[i], &c[i]);
		st[i] = d[x / 100] + x % 100;//得到开始时间
	} f[0] = 100000.0;//初始化
	for (int i = 1; i <= 365; i++){
		f[i] = f[i - 1];
		for (int j = 1; j <= n; j++){
			if (st[j] + b[j] == i)//有理财产品结束
				f[i] = max(f[st[j]] * (1 + (c[j] / 100) / 365 * b[j]), f[i]);
		}
	}
	printf("%.2lf", f[365]);
	return 0;
}
```

---

## 作者：Victorique (赞：1)

其实思路什么的对于这个题比较容易确定，再一看数据规模，需要O(n)的算法，一看妥妥就是一DP，然而这个题最难处理的一个是怎么处理时间，可以看出，一年撑死了有365天，所以我们可以跑1~365的外层时间循环（对于这个题跑两重都行。。。）。然后就是他按照月份读入，我么可以先预处理一个month数组用我们的生活常识打出一个月份的表，之后借助month数组把哪个月的第几天转化成为一年中的第几天。这样再开一个一维DP数组，表示到了第i天的最佳收益。不过有一点，数组要初始化成发f1=100000，不能像普通DP一样处理。最后一定还要有一些生活常识，知道银行之类的东西是怎么由利率算出钱来的就可以了。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#define pi 3.1415926535
#define mo 1000000007
#define INF 1000000007
#define re register
using namespace std;
int month[13]={0,0,31,59,90,120,151,181,212,243,273,304,334};
int a,st[1000001],l[1000001],n,m;
double d[1000001],f[1000001],maxx;
int main()
{
    cin>>n;
    for(re int i=1;i<=n;i++)
    {
        cin>>a>>l[i]>>d[i];
        st[i]=month[a/100]+a%100;
    }
    f[1]=100000;
    for(re int i=2;i<=366;i++)
    {
        f[i]=f[i-1];
        for(re int j=1;j<=n;j++)
        {
            maxx=f[st[j]]*(1+(d[j]/100)/365*l[j]);
            if(st[j]+l[j]==i&&maxx>f[i])
            f[i]=maxx;
        }
    }
    printf("%.2lf",f[366]);
}

```

---

## 作者：ys_kylin__ (赞：1)

题解 P2721，原题戳[这里](https://www.luogu.com.cn/problem/P2721)

这是一道普通的 DP，看上去是紫题，实则很简单。

 DP 中，$dp _ {i}$ 的定义至关重要，而在这道题中，不妨定义 $dp _ {i}$ 为前 $i$ 天的最大赚钱数，而答案就是 $dp _ {366}$ 因为这是一年后的天数。首先为 $dp _ {1}$为$100000$ ，因为初始金额为十万。而每次 $dp _ {i}$ 都要先等于 $dp _ {i-1}$，然后判断条件，若该天有理财产品时间结束，则需要用状态转移式，也就是 `dp[i]=max(dp[i],dp[tim[j]]*(1+(b[j]/100)/365*a[j]));`
 
 而且因为初始发行时间是 MMDD 方式读入的，所以需要写一段程序把发行时间改为天数。
 
 然后在最后输出 $dp _ {366}$ 即可。 
 
 接下来是代码部分
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
int tim[10005],a[10005];//tim为time，也就是时间（转换后）
double b[10005],f[367];//f数组就是DP数组
const int monthend[]=
{0,0,31,59,90,120,151,181,212,243,273,304,334};
int main(){
        int n;
		scanf("%d",&n);
        for(int i=1;i<=n;i++){
        	int x;
            scanf("%d%d%lf",&x,&a[i],&b[i]);
            tim[i]=monthend[x/100]+x%100;//时间转移
        }
        f[1]=100000;
        for(int i=2;i<=366;i++){
            f[i]=f[i-1];
            for(int j=1;j<=n;j++)
                if(tim[j]+a[j]==i)
                    f[i]=max(f[i],f[tim[j]]*(1+(b[j]/100)/365*a[j]));//状态转移方程
        }
        printf("%0.2lf",f[366]);//保留两位小数
        return 0;
}
```

---

## 作者：Huami360 (赞：1)

思路和1楼的一样 ，

先将数据映射到天，

dp [ i ] 表示到 i 天为止最大的**利率**

枚举i，如果有产品的右端点在这一天，则

#dp [ i ] = max ( dp [ i ] , dp [ s [ now ] . l - 1 ] \* ( 1 + s [ now ] . p ) )

其中， s[now]表示右端点为i的产品，l为左端点，r为右端点

否则 dp [ i ] = dp [ i - 1 ]

然而找右端点的过程显然是可以省略的 ，

我们将所有产品按右端点排序 ，

那么now就可以一路推过来了。

加了些常数优化，就跑到rank1了。

丑陋的代码：（忽略掉前面一大段废话其实很短）

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(register int i=m;i<=n;i++)
#define dop(i,m,n) for(register int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
using namespace std;
 //一大堆废话
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

const int maxn = 10010 ;
const int day [ 13 ] = { 0 , 0 , 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 } ;

struct Save {
    int l , r ;
    double p ;
    inline bool operator < ( const Save &A ) const {    //按右端点升序排序
        return r < A.r ;
    }
} s [ maxn ] ;

int l [ maxn ] , r [ maxn ] , n , now = 1 ; 
double dp [ maxn ] ; 

int main(){
    n = read () ;
    rep ( i , 1 , n ) {
        s [ i ] . l = read () ; s [ i ] . r = read () ; scanf ( "%lf" , & s [ i ] . p ) ; 
        s [ i ] . l = day [ s [ i ] . l / 100 ] + s [ i ] . l % 100 ;      //将日期映射到天
        s [ i ] . p = s [ i ] . p * 0.01 / 365 * s [ i ] . r ;
        s [ i ] . r += s [ i ] . l - 1 ; 
    }
    sort ( s + 1 , s + n + 1 ) ;
    dp [ 0 ] = 1 ;
    rep ( i , 1 , 365 ) {   //枚举天 ， 按上面说的思路跑 时间复杂度 O(n log n) （主要在排序的时间）
        dp [ i ] = dp [ i - 1 ] ;
        if ( s [ now ] . r == i )
           while ( s [ now ] . r == i ) 
              dp [ i ] = max ( dp [ i ] , dp [ s [ now ].l - 1 ] * ( 1 + s [ now ] . p ) ) , ++now ; 
    }
    printf ( "%.2lf\n" , dp [ 365 ] * 100000 ) ;   //由于是利率 ， 所以要乘上本钱
    return 0;
}
```

---

## 作者：SunsetVoice (赞：0)

珂爱的动态规划。

设 $dp_i$ 表示截止至第 $i$ 天可以获得的最大收益。

由于只有一个理财项目结束时可以获得其收益，故在其结束时更新收益值。

用 $j$ 表示第 $j$ 项项目，遍历所有理财项目，考虑有没有在当天结束的，然后分类讨论：

- 如果第 $i$ 天没有理财项目结束，则 $dp_i = dp_{i-1}$。因为不可能获得任何收益。
- 如果有，考虑购买。此时 $dp_i$ 为不买该项目（或买其他的）和买该项目的收益的最大值。

由于理财项目可能冲突，所以需要遍历所有项目，而不能搜索到一项就退出。


code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int month[13] = {0,31,59,90,120,151,181,212,243,273,304,334};
int main(){
	double dp[368] = {0},lx[10001] = {0};
	int T,d[10001] = {0},st[10001] = {0};
	cin>>T;
	dp[1] = 100000;
	for(int i = 1;i<=T;i++){
		cin>>st[i];
		st[i] = month[st[i]/100-1]+st[i]%100;
		cin>>d[i]>>lx[i];
		//cout<<st[i]<<endl;
	}
	for(int i = 2;i<=366;i++){
		dp[i] = dp[i-1];
		for(int j = 1;j<=T;j++){
			if(st[j]+d[j]==i){
				dp[i] = max(dp[i],dp[st[j]]*(1+(lx[j]/100)/365*d[j]));
			}
		}
	}
	printf("%.2lf",dp[366]);
	return 0;
}
/*
3
0101 100 4.5
0201 30 5
0402 50 7.8
*/
```


---

## 作者：XLoffy (赞：0)

# P2721 小Q的赚钱计划
[题目传送门](https://www.luogu.com.cn/problem/P2721) | [更好的阅读体验](https://www.luogu.com.cn/blog/cxy-xlf-1003/solution-p2721) | [运行结果](https://www.luogu.com.cn/record/116122769)
#### 题意：
------------
你有一年时间，把 10w 元存银行变成更多钱，在特定时间区间内，你会有一些利息，不过不可中途退出。

#### 分析
------------
使用 dp 策略。

数组 $f$ 用于存储一年中每一天的最大收益，初始值设为 $100000$。

输入数据包含 $n$ 个投资，每个投资由以下信息表示：
   - $x$：投资的月份（两位数的整数）。
   - $y$：投资的日期（两位数的整数）。
   - $d$：投资持续的天数。
   - $c$：投资的回报率（以百分比表示）。

dp 过程如下：

对于每次投资，根据投资的回报率 $c$、持续天数 $d$ 和一年 $365$ 天的假设，计算每天的收益率  $a_i$。计算公式为：

$$a_i = c \times 0.01 \times (d \div 365.0) + 1$$

计算每次投资的起始日（$st_i$）和结束日（$ed_i$），使用 $month$ 数组和给定的投资月份 $x$ 和日期 $y$ 进行计算。

循环遍历一年中的每一天，并更新当天的最大收益：

1. 在第 $i$ 天的最大收益初始化为前一天的最大收益（$f_i = f_{i-1}$）。

2. 然后，对于每次投资 $j$：

     如果投资 $j$ 不是在第 $i$ 天结束的（即 $ed_j \ne i$），意味着该投资对当天的收益没有贡献，所以跳过当前投资，继续下一个投资。如果投资 $j$ 是在第 $i$ 天结束的，dp 公式为：
     
     $$f_i = \max(f_i, f[st_j - 1] \times a_j)$$
     
     比较第 $i$ 天的最大收益与投资 $j$ 开始前一天的最大收益乘以当天的收益率 $a_j$，从而确保更新为当天的最优值。


接下来贴上代码……
#### AC Code
------------
```cpp
#include <bits/stdc++.h>//保命万能头
using namespace std;//标准命名空间
const int month[]={0,0,31,59,90,120,151,181,212,243,273,304,334,365};
//打表，表示每个月份的天数累加。例如，month[1]表示1月份的天数，month[2]表示1月份和2月份的天数之和。
double f[400]={100000},a[10010];
//f存储每天的最大收益，a存储每次投资的收益率
int n,st[10010],ed[10010],x,y,d;
//声明用于存储输入数据和计算过程中的临时变量
double c;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)//循环，用于读取每次投资的信息并计算收益率
    {
        scanf("%2d%2d%d%lf",&x,&y,&d,&c);
        //使用scanf函数读取信息，因为scanf对精度有着特殊的处理
        a[i]=c*0.01*(d/365.0)+1;
        //根据读取的收益率c和持续天数d计算出收益率，并将其存储在数组a中
        st[i]=month[x]+y;
        //根据读取的月份x和日期y，计算出投资的起始日期在一年中的天数
        ed[i]=st[i]+d-1;
        //根据的起始日期和持续天数，计算出投资的结束日期
    }
    for(int i=1;i<=365;i++)//用于动态规划计算
    {
        f[i]=f[i-1];
        //动态规划的计算
        for(int j=1;j<=n;++j) 
        {
            if(ed[j]!=i) continue;
            //如果不在当天结束，跳过
            f[i]=max(f[i],f[st[j]-1]*a[j]);
            //更新当天的最大收益
        }
    }
    cout<<fixed<<setprecision(2)<<f[365];
    //保留两位小数输出
    return 0;
    //华丽结束
}
```

---

## 作者：至尊无敌 (赞：0)

一维动态规划，设f[i]表示第i天可以获得的最大受益，注意最后输出f[366]，因为题目求的是一年以后。


(标注的难度让我吓一跳。。。)


const m:array[1..12]of longint=(0,31,59,90,120,151,181,212,243,273,304,334);


```cpp
var day,bg:array[0..10000] of longint;
    f:array[0..10000] of double;
    v:array[0..10000] of double;
    b:double;
    i,j,n,a:longint;
begin
 readln(n);
 for i:=1 to n do begin
  readln(a,day[i],v[i]);
  bg[i]:=m[a div 100]+a mod 100;
 end;
 f[1]:=100000;
 for i:=2 to 366 do begin
  f[i]:=f[i-1];
  for j:=1 to n do begin
   b:=f[bg[j]]*(1+(v[j]/100)/365*day[j]);
   if (bg[j]+day[j]=i) and (b>f[i]) then
    f[i]:=b;
  end;
 end;
 writeln(f[366]:0:2);
end.
```

---


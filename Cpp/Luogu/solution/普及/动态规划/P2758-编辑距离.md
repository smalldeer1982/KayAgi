# 编辑距离

## 题目描述

设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：

1. 删除一个字符；
2. 插入一个字符；
3. 将一个字符改为另一个字符。

$A, B$ 均只包含小写字母。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le |A|, |B| \le 2000$。

## 样例 #1

### 输入

```
sfdqxbw
gfdgw
```

### 输出

```
4
```

# 题解

## 作者：4396瞎 (赞：281)

我看题解里的很多都是用递推求解的，只有一位仁兄用的是递归但我觉得他的代码风格跟我还不太一样，而且我也想分享一下自己的解体思路。

做动态规划的题一般分为四个步骤：确定子问题—>定义状态—>转移方程—>避免重复求解

用在这一题当中我的思路如下：

1.确定子问题：

由于对于字符串的操作只有4种情况（删除，添加、更改、不变），所以该题的子问题就是进行了这4种操作后的A字符串变为B字符串需要多少步。

2.定义状态：

也就是说递归的dp函数需要哪些参数，参数越少越好因为需要建memo。后来想到dp（i，j）代表字符串A的前i个字符（包括第i个）变为字符串B的前j个（包括第j个）需要多少步。也就是说解出来dp（lenA，lenB）就可以了。

3.转移方程：

删：dp(i-1，j)+1 //字符串A的前i-1个字符变为字符串B的前j个需要多少步 【把字符串的第i个字符（最后一个）删除了】，删除需要一步因此加1

添：dp(i，j-1)+1 //将B[j]字符加在A字符串的最后面即添加，同样可以理解为将B[j]字符删掉（因为不用再考虑了）。

//字符串A的前i个字符变为字符串B的前j-1个需要多少步  添加需要一步因此加1

替：dp(i-1，j-1)+1  //字符串A和B的最后两个都相等了，因此都不用再考虑

//字符串A的前i-1个字符变为字符串B的前j-1个需要多少步  添加需要一步因此加1

不变：dp（i-1，j-1）//字符串A和B的最后两个都相等，不考虑。感性的说这种情况是理想情况。

4.避免重复求解

这个最简单，建个数组就行。


上代码：



    

    
```cpp
#include<iostream>
#include<cstring>
using namespace std;
string A,B;
char s1[2005],s2[2005];//s1=A , s2=B
int edit[2005][2005];
int dp(int i,int j){ 
    if(edit[i][j]!=-1) return edit[i][j]; 
    if(i==0) return edit[i][j]=j;
    if(j==0) return edit[i][j]=i;
    int bonus=1;
    if(s1[i]==s2[j]) bonus=0;  
    return edit[i][j]=min(min(dp(i-1,j)+1,dp(i,j-1)+1),dp(i-1,j-1)+bonus);
}
int main(){
    cin>>A>>B;
    memset(edit,-1,sizeof(edit));
    int len1=A.length(),len2=B.length();
    for(int i=1;i<=len1;i++ ) s1[i]=A[i-1];//将字符串转成cstring 
    for(int i=1;i<=len2;i++) s2[i]=B[i-1];
    dp(len1,len2);
    cout<<edit[len1][len2];
    return 0;
}
```

---

## 作者：Starlight_Glimmer (赞：147)

假设用f[i][j]表示将串a[1…i]转换为串b[1…j]所需的最少操作次数（最短距离）

首先是边界：

①i==0时，即a为空，那么对应的f[0][j]的值就为j：增加j个字符，使a转化为b

②j==0时，即b为空，那么对应的f[i][0]的值就为i：减少i个字符，使a转化为b

然后考虑一般情况（这里是DP思想）：我们要得到将a[1..i]经过最少次数的操作就转化为b[1..j]，那么我们就必须在此之前以最少次数（假设为k次）的操作,使现在的a和b只需再做一次操作或者不做操作就可以使a[1..i]转化到b[1..j]。而“之前”有三种情况：

①将a[1…i]转化为b[1…j-1]

②将a[1..i-1]转化为b[1..j]

③将a[1…i-1]转化为b[1…j-1]

第①种情况，只需要在最后将a[j]加上b[1..i]就可以了，总共就需要k+1次操作。

第②种情况，只需要在最后将a[i]删除，总共需要k+1个操作。

第③种情况，只需要在最后将a[i]替换为b[j]，总共需要k+1个操作。但如果a[i]刚好等于b[j]，就不用再替换了，那就只需要k个操作。

为了得到最小值，将以上三种情况的最小值作为f[i][j]的值（我前面不是说了f[i][j]表示串a[1…i]转换为串b[1…j]所需的最少操作次数嘛）,最后答案在f[n][m]中。

-

实现（只描述算法部分）

初始化。边界情况，用循环嵌套或两个独立的循环都可以做到。

 
2.循环嵌套遍历f数组，先处理a[i]==b[j]的情况，如不满足，再从三种情况中选择最小的，作为f[i][j]的值。三种情况中，①如果在k个操作里将a[1…i-1]转换为b[1..j]，那就可以将a[i]删除，共需k+1个操作，所以是f[i-1][j]+1;②如果在k个操作里将a[1…i]转换为b[1…j-1] ，那就可以加上b[j]，共需k+1个操作；③如果我们可以在k个操作里将a[1…i-1]转换为b[1…j-1]，那就可以将a[i]转换为b[j]，也是共需k+1个操作。（前面已经处理过了a[i]==b[j]的情况）

3.最后的答案是f[][]最后一个元素的值。


代码：



```cpp
    #include<cstdio>
    #include<iostream>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    int f[3005][3005],lena,lenb;
    char a[3005],b[3005];
    void dp()
    {
        for(int i=1;i<=lena;i++)
            f[i][0]=i;
        for(int i=1;i<=lenb;i++)
            f[0][i]=i;
        for(int i=1;i<=lena;i++)
            for(int j=1;j<=lenb;j++)
            {
                if(a[i-1]==b[j-1])
                {
                    f[i][j]=f[i-1][j-1];
                    continue;
                }
                f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
            }
    }
    int main()
    {
        scanf("%s %s",a,b);
        lena=strlen(a);
        lenb=strlen(b);
        dp();
        printf("%d\n",f[lena][lenb]);
    }
```
博客：http://blog.csdn.net/CQBZLYTina/article/details/75043128?locationNum=9&fps=1




---

## 作者：秋云暗几重 (赞：73)

第一篇题解 大犇们轻喷

这个题肯定是要用DP的暴力的话数据肯定过不了（~~虽然我没试过~~）

设两个字符串A,B 用一个二维数组f存储状态 一维存A串 一维存B串 一共有如下四种操作：

删：可以看做把A串最后一个字符删去后不再考虑这个字符 所以f(i,j)=min(f(i,j),f(i-1,j)+1);

加：可以看做与B串最后一个字符抵消后不再考虑这个字符 所以f(i,j)=min(f(i,j),f(i,j-1)+1);

改：可以看做删和加的集合 抵消了A、B串最后的两个字符 所以f(i,j)=min(f(i,j),f(i-1,j-1)+1); 当然若A、B串最后一个字符相同就可以不用操作了

具体操作就在代码里了

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
char a[4005],b[4005];
int lena,lenb,f[4005][4005],k;//f(i,j)表示将A串前i个字符改为B串前j个字符需要的步数
int main() {
    cin>>a>>b;
    lena=strlen(a);lenb=strlen(b);
    for(int i=lena;i>=1;i--) a[i]=a[i-1];
    for(int i=lenb;i>=1;i--) b[i]=b[i-1];//初始化
    for(int i=0;i<=lena;i++) f[i][0]=i;
    for(int i=0;i<=lenb;i++) f[0][i]=i;//边界状态 因为将A串无字符变到B串i个字符时需要加i个字符 B串无字符时同理
    for(int i=1;i<=lena;i++){
        for(int j=1;j<=lenb;j++){
            k=1;//在后面会用到 方便‘改’的操作
            if(a[i]==b[j]) k=0;
            f[i][j]=min(min(f[i-1][j]+1,f[i][j-1]+1),f[i-1][j-1]+k);//若当前A、B串指向字符相等则不进行‘改’的操作
        }
    }
    printf("%d",f[lena][lenb]);//就是将A串前lena个数变为B串前lenb个数
    return 0;
}
```

---

## 作者：Kevin施黄凯 (赞：60)

[题目传送门](https://www.luogu.com.cn/problem/P2758)

Hello，大家好，本蒟蒻又来发题解了！

今天我们来讲 P2758 【编辑距离】

# 一道水题

#### 但依然调试了30分钟

这道题我们从几个方面来讲，既然是动规，那我们就动态地讲解吧！

基本上都是代码方面：

状态：

f[i][j]记录ai与bj的最优编辑距离。
2. 结果：

f[m][n]其中m,n分别是a,b的串长。
初值：

b串空，要删m（a串长）个字符；串空，要插n（b串空）个字符。
转移方程：

当a[i]=b[j]时，f[i][j]=f[i-1]=f[j-1],不然，f[i][j]=min(f[i-1][j-1]+1,f[i][j-1]+1,f[j-1][j]+1)
说明：

f[i-1][j-1]+1:改a[i]为b[j];

f[i][j-1]+1:a[i]后插入b[j-1];

f[i-1][i]+1:删a[i]。

参考程序：
```
#include<bits/stdc++.h>
using namespace std;
int min(int a,int b)
{
	return a<b? a:b;
}
int f[202][202];
char s1[202],s2[202];
int i,j,k,m,n;
int main()
{
	scanf("%s%s",s1,s2);
	m=strlen(s1);
	n=strlen(s2);
	for(i=1;i<=m;i++)f[i][0]=i;
  /*
	到i位置为止把字符串A的内容全部删除
	*/
	for(i=1;i<=n;i++)f[0][i]=i;
	/*
	在开头给字符串A添上和B到i位置相同的字符
	*/
	for(i=1;i<=m;i++) 
	   for(j=1;j<=n;j++)
		   if(s1[i-1]==s2[j-1])f[i][j]=f[i-1][j-1];
			   else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
	printf("%d\n",f[m][n]);
	return 0; 
}
```
手打不易，求管理员大大通过！

# 求赞！


---

## 作者：qwaszx (赞：31)

**首先感谢@jbj1713，当前第二快提供优化**

首先思路是dp，其他dalao说的很明白了

f[i][j]表示把串A的0...i-1变成串B的0...j-1所需最小步数

(看题解都是说1...i,但你读进来是0...i-1,就是映射过去)

边界:f[i][0]=i,f[0][j]=j,就是全部删除和全部插入

转移有三种:

①f[i-1][j]->f[i][j],插入即可,**f[i][j]=f[i-1][j]+1**;

②f[i][j-1]->f[i][j],删除即可**f[i][j]=f[i][j-1]+1**;

③f[i-1][j-1]->f[i][j],要把a[i-1]换成b[j-1],如果相同就不用换了

**f[i][j]=f[i-1][j-1]+(a[i-1]!=b[j-1])**;

合到一起

if(a[i-1]==b[j-1])f[i][j]=f[i-1][j-1];

else f[i][j]=min(f[i-1][j],f[i][j-1],f[i-1][j-1])+1;

答案是f[a.size()][b.size()]

代码参考其他dalao就好~~(我的跑了300ms)~~

------------


但这不是关键

注意到已经跑完的f[i-2]对f[i]没有影响

所以可以**滚动数组**优化~~（我也不知道是不是叫这个）~~

令ff[j]=f[i-1][j],f[j]=f[i][j]

边界变成ff[i]=i(初始)和f[0]=i,ff[0]=i-1(每个i)

if(a[i-1]==b[j-1])f[j]=ff[j-1];

else f[j]=min(f[j-1],ff[j],ff[j-1])+1;

然后把ff[j]变成f[j]即可

答案变成f[b.size()]

然后是奇丑无比的代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char st1[3000],st2[3000];
int f[3000],ff[3000];
int main()
{
	scanf("%s%s",st1,st2);
	int l1=strlen(st1),l2=strlen(st2);
	for(int i=1;i<=l2;i++)
		ff[i]=i;
	for(int i=1;i<=l1;i++)
	{
		f[0]=i;ff[0]=i-1;
		for(int j=1;j<=l2;j++)
			if(st1[i-1]==st2[j-1])f[j]=ff[j-1];
			else f[j]=min(min(ff[j],ff[j-1]),f[j-1])+1;
		for(int j=1;j<=l2;j++)ff[j]=f[j];
	}
	printf("%d\n",f[l2]);
}
```
开O2之后16ms
  
有错请~~不要管~~私信我

---

## 作者：yybyyb (赞：22)

一道DP裸体

先设一下状态

设f[i][j]表示串S1前i个字符到串S2前j个字符的编辑距离


看一看每一个f[i][j]可以怎么得到：

如果当前有S1[i]=S2[j]那么f[i][j]=f[i-1][j-1]，直接由前面的状态就可以得到

否则：

1. 可以由i-1和j-1的匹配情况加上一次修改操作

2. 可以由i-1和j 的匹配情况加上一次删除操作

3. 可以由i 和j-1的匹配情况加上一次添加操作


所以状态转移方程就可以得出来了


具体的实现请看代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
string s1,s2;//初始字符串 
int l1,l2;
int f[5000][5000];
int main()
{
      cin>>s1>>s2;
      l1=s1.length();
      l2=s2.length();
      memset(f,127,sizeof(f));
      //f[i][j]表示把 s1前i位变为 s2的前j位的 最短编辑距离 
      for(int i=0;i<=l2;++i)
         f[0][i]=i;
      for(int i=0;i<=l1;++i)
         f[i][0]=i;
      for(int i=1;i<=l1;++i)
      {
             for(int j=1;j<=l2;++j)
             {
                     if(s1[i-1]==s2[j-1])
                        f[i][j]=min(f[i][j],f[i-1][j-1]);//如果两位相同 
                     else 
                     f[i][j]=min(f[i][j],f[i-1][j-1]+1);//上一位的基础上加"替换"
                     f[i][j]=min(f[i][j],f[i][j-1]+1);//上一个的基础上加"添加"
                     f[i][j]=min(f[i][j],f[i-1][j]+1);//上一位的基础上加"删除" 

             }
      }
      cout<<f[l1][l2]<<endl;
      return 0;
}
```

---

## 作者：jijidawang (赞：14)

## 题面简述

> 编辑距离 ——经典 dp 问题
> 
> 设 $s_1$ 和 $s_2$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $s_1$ 转换为字符串 $s_2$ 。这里所说的字符操作共有三种：
> 
> 1. 删除一个字符；
> 
> 2. 插入一个字符；
> 
> 3. 将一个字符改为另一个字符；

## 算法分析

### 暴力算法

我们当然可以写个 bfs 求解。

~~果然很暴力。~~

### dp 算法

我们发现，这个操作只更改一个字符，别的字符不受影响，考虑 dp。

由于对于字符串的操作只有 $4$ 种情况（分别是：删除，添加、更改、不变），我们可以从这里下手设计转移方程。

我们可以设 $dp_{i,j}$ 表示将 $s_1$ 的前 $i$ 个字符变为 $s_2$ 的前 $j$ 个字符的编辑距离。

因为它们最后相等了，所以它们的末尾字符肯定也相等。

- 删除操作：我们设删除 $s_1$ 的末尾字符，则为 $dp_{i-1,j}$，由于此操作需要一步，所以还要 $+1$。

- 插入操作：假设在 $s_1$ 末尾添加字符，我们想：

> 插入到最后，就是插入 $s_2$ 的末尾字符，这样就可以转移到 $dp_{i,j-1}$ ，当然还要 $+1$。

- 替换操作：还是假设更改最后一个字符，改之前它们不相等，所以考虑前面的串的次数即可，即 $dp_{i-1,j-1}+1$

- 不变的话显然是 $dp_{i-1,j-1}$（最后本来都相等了，当然就是前面的次数了，不变当然不用耗费次数啦）

求最短次数，求 $\min$ 即可。

整理出转移方程：

$$dp_{ij}=\min\{dp_{i-1,j}+1,dp_{i,j-1}+1,dp_{i-1,j-1}+1,dp_{i-1,j-1}\}$$

提出 $1$ 后：

$$dp_{ij}=\min\{dp_{i-1,j},dp_{i,j-1},dp_{i-1,j-1},dp_{i-1,j-1}-1\}+1$$

按照转移方程 dp 即可。

时间复杂度 $\mathcal{O}(len_1len_2)$（设 $s_1,s_2$ 的长度分别为 $len_1,len_2$）

---

## 作者：煜明 (赞：14)

[题目详情](https://www.luogu.com.cn/problem/P2758)

题目分析：dp\[i\]\[j]表示a字符串从第一个字符到第i个字符通过最少dp[i]\[j]次操作，就能变成从第一个字符到第j个字符的b字符串。

转移方程：
如果a[i]与b[j]相等：

那么dp[i]\[j] = dp[i - 1]\[j - 1]，因为在a前i - 1个字符串最少能通过dp[i - 1]\[j - 1]次操作转化为b前j - 1个字符串的基础上什么都不干，a前i个字符串也能通过最少dp[i - 1]\[j - 1]次操作就能与b前j个字符相等，dp[i]\[j] 自然就与 dp[i - 1]\[j - 1] 相等了。

如果a[i]与b[j]不相等：有以下三种情况

1. 添加：dp[i]\[j - 1] + 1  $\rightarrow$ dp[i]\[j] 

- 在这个情况下，我们知道既然要从dp[i]\[j - 1]转移到dp[i]\[j]，说明dp[i]\[j - 1]在之前的dp中已经算好了，dp[i]\[j - 1]表示a前i个字符串最少能通过dp[i]\[j - 1]次操作转化为b前j - 1个字符串。

- 那怎么才能让a前i个字符串最少能通过dp[i]\[j]次操作转化为b前j个字符串呢？

- 只要在a[i]后面加一个b[j]，此时如果在a前i个字符上做dp[i]\[j - 1]同样的操作，我们可以保证a前i个字符与b前j - 1个字符相等，但由于在a后面加了一个字符与b[j]相等。

- 所以在a前i个字符上做dp[i - 1]\[j - 1]同样的操作后就与b前j个字符相等了。因为要做一次添加操作。

- 所以dp[i]\[j] = dp[i]\[j - 1] + 1。


2. 删除：dp[i - 1]\[j] + 1  $\rightarrow$ dp[i]\[j]

- 在这个情况下，我们知道既然要从dp[i - 1]\[j]转移到dp[i]\[j]，说明dp[i - 1]\[j]在之前的dp中已经算好了，dp[i - 1]\[j]表示a前i - 1个字符串最少能通过dp[i - 1]\[j]次操作转化为b前j个字符串。

- 那怎么才能让a前i个字符串最少能通过dp[i]\[j]次操作转化为b前j个字符串呢？

- 只要把a[i]删掉，此时如果在a前i - 1个字符上做dp[i - 1]\[j]同样的操作，我们可以保证a前i -1个字符与b前j个字符相等。

- 因为我们把a[i]删掉了，所以做与dp[i - 1]\[j]同样的操作，我们可以保证a前i个字符与b前j个字符相等。

- 所以dp[i]\[j] = dp[i - 1]\[j] + 1。


3. 替换：dp[i - 1]\[j - 1] + 1  $\rightarrow$ dp[i]\[j]

- 只需要把a[i]替换成b[j]就行了，所以dp[i]\[j] = dp[i - 1]\[j - 1] + 1。


代码如下：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
char a[2222], b[2222];
int lena, lenb, dp[2222][2222];
int main()
{
    scanf("%s%s", a + 1, b + 1);//从下标1开始读入。
    lena = strlen(a + 1), lenb = strlen(b + 1);
    for (int i = 1; i <= lena; i++) dp[i][0] = i;//初始化，a字符串前i（包括第i个）个字符至少要通过删除字符i个变成b字符串前0个字符，即a字符串全删没了需要操作i次。
    for (int i = 1; i <= lenb; i++) dp[0][i] = i;//初始化，a字符串从0个字符至少要通过添加i个字符变成b字符串前i个字符（包括第i个），即a字符串从0扩充为b字符串需要操作i次。
    for (int i = 1; i <= lena; i++)//开始dp
        for (int j = 1; j <= lenb; j++){
            if (a[i] == b[j])//如果a第i个字符与b字符串第j个字符相等
                dp[i][j] = dp[i - 1][j - 1];//那么在a前i - 1个字符串最少能通过dp[i - 1][j - 1]次操作转化为b前j - 1个字符串的基础上什么都不干，dp[i][j] 自然与 dp[i - 1][j - 1] 相等。
            else dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i- 1][j - 1]) + 1;
        }
    printf("%d\n", dp[lena][lenb]);
}
```

---

## 作者：lyojoy (赞：12)

此题动规即可

状态：f[i][j],a前i个，b前j个，最少步数。

方程：f[i][j]=

		1.a[i] == b[j] f[i][j] = f[i-1][j-1]
    
		2.删除、插入、改变的最小值： min{f[i-1][j](删除)，f[i][j-1]（插入）,f[i-1][j-1]（改变）} + 1因为有一步，所以加一
    
边界：f[i][0]=i,f[0][j]=j
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
#pragma GCC optimize(3)//O3优化

char a[2005], b[2005];
int f[2005][2005];

int main()
{
	cin >> a + 1 >> b + 1;//从a[1], b[1]开始输入
	int al = strlen(a + 1), bl = strlen(b + 1);//从a[1],b[1]开始计算字符串长度
	for(int i = 1; i <= al; i++)
		for(int j = 1; j <= bl; j++)
		{
			f[i][0] = i, f[0][j] = j;//边界
			if(a[i] == b[j]) f[i][j] = f[i - 1][j - 1];//不做修改，答案不变
			else f[i][j] = min(f[i - 1][j], min(f[i][j - 1] , f[i - 1][j - 1])) + 1;//不一样，分为删除、插入和改变,寻找其最小值
		}
	cout << f[al][bl];//输出
	return 0;
}
```


---

## 作者：_maze (赞：9)

一看就知道这是dp，用dp就要明白dp的三大步骤：

1、定义状态（dp数组）

2、找出状态转移方程

3、初始化边界条件

我们来依次解决这三大问题：

### 1：定义状态，dp数组

这道题有两个字符串，显然就要用到二维数组。那二维数组怎么定义呢？

他要我们求最少字符操作次数，自然要把dp[i][j]定义为在a[i]与b[j]时已编辑的步数

### 2：找出状态转移方程

编辑时有三种可能，自然有三种可能，需要用min判断最小的

如果两个字母一样，就肯定不用变呀

```cpp
dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;//三种情况 
if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1];//如果一样就不变 
```


### 3：初始化边界条件

这一步可以循环做，初始化为循环的变量（最多步骤肯定是字符串距离啦）

于是就可以上代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int dp[10005][10005],maxx,ls,lt;
int main()
{
	cin>>a;
	cin>>b;
	a="0"+a;//加一个零用来避免越界
	b="0"+b;//同理 
	ls=a.size();//求长度 
	lt=b.size();
	for(int i=1;i<=ls;i++) dp[i][0]=i;//初始化边界条件 
    for(int i=1;i<=lt;i++) dp[0][i]=i;
	for(int i=1;i<ls;i++){//加了0就从1开始循环，否则会数组越界 
		for(int j=1;j<lt;j++){
			dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;//三种情况 
			if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1];//如果一样就不变 
		}
	}
	cout<<dp[ls-1][lt-1];//输出 
	return 0;//结束了，结束了！
}
```

---

## 作者：LevenKoko (赞：9)

日常吐槽：关于DP，有一种莫名的恐惧...~~maybe源于与mtw大佬与quantum11大佬，初中时抬老师爬楼梯的经历。。。~~

言归正传：
##编辑距离
【题目描述】
设A和B是两个字符串。我们要用最少的字符操作次数，将字符串A转换为字符串B。这里所说的字符操作共有三种：

1、删除一个字符；

2、插入一个字符；

3、将一个字符改为另一个字符。

对任意的两个字符串A和B，计算出将字符串A变换为字符串B所用的最少字符操作次数。

【输入】
第一行为字符串A；第二行为字符串B；字符串A和B的长度均小于2000。

【输出】
只有一个正整数，为最少字符操作次数。

【输入样例】
sfdqxbw
gfdgw
【输出样例】
4

###【思路】
比较基础的一道DP题目,~~（我才不会告诉你们，我也是看了书才会做）~~~
既然是DP，那么我们分析一下子问题，当前处理A到第i个字符，处理B到第j个字符
状态f[i][j]代表此时最小的编辑距离
不难推出：
#### F[I][J]=MIN{F[I-1][J-1],F[I-1][J],F[I][J-1]}+1;
#好简单

的样子
额...
##不存在的
如果A[I]==B[I]的话，我们发现
##根本不用修改
then:
```
if(a[i]==b[j]) 
	f[i][j]=min(min(f[i-1][j]+1,f[i][j-1]+1),f[i-1][j-1]);
else
	f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
```
#大概就是这个样子的
##吧...

接下来
###关于边界处理
假设A空：则 for(int j=0;j<=m;j++)	f[0][j]=j;
假设B空：则 for(int i=0;i<=n;i++)	f[i][0]=i;

###就这样...完...完成了？
#不存在的
才怪呢...

**附上代码**
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cstring> 
#include<algorithm>
using namespace std;

inline int read()
{
	char chr=getchar();
	int f=1,ans=0;
	while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr))  {ans=ans*10;ans+=chr-'0';chr=getchar();}
	return ans*f;

}
int f[2005][2005];
int n,m;
char a[2005],b[2005];
int main()
{
	scanf("%s\n%s",a+1,b+1);
	n=strlen(a+1);
	m=strlen(b+1);
	for(int i=0;i<=n;i++)	f[i][0]=i;
	for(int j=0;j<=m;j++)	f[0][j]=j;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(a[i]==b[j]) 
				f[i][j]=min(min(f[i-1][j]+1,f[i][j-1]+1),f[i-1][j-1]);
			else
				f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
		}
	cout<<f[n][m];
	return 0;
}

```


---

## 作者：ShineEternal (赞：6)

**分析**


状态：f[i][j]记录ai与bj的最优编辑距离

结果：f[m][n]，其中m、n分别是a、b的串长

初值：b串空，要删a串长个字符；a串空，要插b串长个字符

转移方程：当a[i]=b[j]时，f[i][j]=f[i-1][j-1]，否则，

f[i][j]=min(f[i-1][j-1]+1,f[i][j-1]+1,f[i-1][j]+1)

说明：f[i-1][j-1]+1：改a[i]为b[j]；

    f[i][j-1]+1：a[i]后插入b[j]；
    
    f[i-1][j]+1：删a[i]。
    


**by 一本通**

------------
下面是代码
```
#include<cstdio>
#include<cstring>
#include<cmath> 
using namespace std;
char s1[2001],s2[2001];
int f[2001][2001];
int main()
{
	int n,m;
	scanf("%s\n%s",s1,s2);
	n=strlen(s1);
	m=strlen(s2);
	for(int i=1;i<=n;i++)f[i][0]=i;
    //到i位置为止把字符串A的内容全部删除
	for(int i=1;i<=m;i++)f[0][i]=i;
    //在开头给字符串A添上和B到i位置相同的字符
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s1[i-1]==s2[j-1])
			f[i][j]=f[i-1][j-1];
			else
			f[i][j]=fmin(fmin(f[i][j-1],f[i-1][j]),f[i-1][j-1])+1;
		}
	} 
	printf("%d",f[n][m]);
	return 0;
}
```

结束，希望能给大家精确的题解

求过

---

## 作者：Dispwnl (赞：4)

用二维数组f，一维表示a字符串长度为i，二维表示b字符串长度为j

因为增加一个字符相当于b字符串删掉一个字符

修改一个字符相当于不增也不减

相当于两个字符相等时的情况

初始化时当a为0位时，操作个数肯定是b的长度（即增加b长度个字符）

同理，当b为0位时，操作个数肯定是a的长度（即删除a长度个字符）

动态转移方程：if(a[i-1]==b[j-1]) f[i][j]=f[i-1][j-1];

else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;//肯定要操作一次

```cpp
# include<iostream>
# include<cstring> 
using namespace std;
char a[2001],b[2001];
int f[2001][2001];
int main()
{
    cin>>a>>b;
    int n=strlen(a),m=strlen(b);
    for(int i=1;i<=n;i++)
      f[i][0]=i;
    for(int i=1;i<=m;i++)
      f[0][i]=i;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        if(a[i-1]==b[j-1]) f[i][j]=f[i-1][j-1];
        else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
    cout<<f[n][m];
    return 0;
}

```

---

## 作者：a2426632670 (赞：4)

```cpp
#include<bits/stdc++.h> 
using namespace std;
int f[2100][2100];
char a[2100],b[2100];
int main()
{
    int lena,lenb,i,j,k;
    scanf("%s%s",&a,&b);
    lena=strlen(a);
    lenb=strlen(b);
    for(i=1;i<=lena;i++) f[i][0]=i; 
    for(i=1;i<=lenb;i++) f[0][i]=i;
    for(i=1;i<=lena;i++)
       for(j=1;j<=lenb;j++)
          if(a[i-1]==b[j-1]) f[i][j]=f[i-1][j-1];
          else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
    cout<<f[lena][lenb];
    return 0;
} 
```
分析：
第一点：

        for(i=1;i<=lena;i++) f[i][0]=i; 

        for(i=1;i<=lenb;i++) f[0][i]=i;

此处表示构成一个矩阵

进行逐一比较

第二点：

三种方案：

删除： f[i][j-1]+1，将i-1删除后，

j-1仍未匹配，所以将i继续与j-i匹配

插入： f[i-1][j]+1，插入一个值与j匹配后，

i-1仍未匹配，所以将i-1继续与j匹配

置换： f[i-1][j-1]+1，置换后，

i-1与j-1都匹配，所以无须继续

弄清三种方案后，则易得

状态转移方程：

f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;


---

## 作者：我很低调 (赞：4)

# 题目描述
设A和B是两个字符串。我们要用最少的字符操作次数，将字符串A转换为字符串B。这里所说的字符操作共有三种：

1、删除一个字符；

2、插入一个字符；

3、将一个字符改为另一个字符；

！皆为小写字母！

# 输入格式
第一行为字符串A；第二行为字符串B；字符串A和B的长度均小于2000。

# 输出格式
只有一个正整数，为最少字符操作次数。

### 一道黄色的经典dp问题
码风不喜勿喷
# 谢谢

输入输出样例
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
using namespace std;
int iAnswers[5002][5002] = {{0},{0}};
int main()
{
    char str[5005];
    char str1[5005];
    int iLen1 = 0;
    int iLen2 = 0;

    cin >> str;
    cin >> str1;
    iLen1 = strlen(str);
    iLen2 = strlen(str1);
    for (int iLoop = iLen1; iLoop >= 1; iLoop --) str[iLoop] = str[iLoop - 1];
    for (int iLoop = iLen2; iLoop >= 1; iLoop --) str1[iLoop] = str1[iLoop - 1];
    for (int iLoop = 0; iLoop <= iLen1; iLoop ++) iAnswers[iLoop][0] = iLoop;
    for (int iLoop = 0; iLoop <= iLen2; iLoop ++) iAnswers[0][iLoop] = iLoop;
    for (int iLoop = 1; iLoop <= iLen1; iLoop ++)
    for (int iLoop1 = 1; iLoop1 <= iLen2; iLoop1 ++)
    {
        int iBox = 1;
        if (str[iLoop] == str1[iLoop1])
        iBox = 0;
        iAnswers[iLoop][iLoop1] = min(min(iAnswers[iLoop - 1][iLoop1] + 1,iAnswers[iLoop][iLoop1 - 1] + 1),iAnswers[iLoop - 1][iLoop1 - 1] + iBox);
    }
    cout << iAnswers[iLen1][iLen2];
}
/*
fxpimu
xwrs
*/
```
经典dp，我不讲了，楼上楼下大佬都有解析。

---

## 作者：crowworks695 (赞：4)

DP题，状态转移方程：当A[i]=B[i]时，f[i][j]=f[i+1][j+1]，否则的话f[i][j]=min(f[i+1][j],f[i][j+1],f[i+1][j+1])+1;

f[i+1][j]表示删去A串第i个位置的元素，f[i][j+1]则表示在A串i之前插入一个等于b[j]的元素，而f[i+1][j+1]则表示替换A串中第i个元素使A[i]=B[j]。

```cpp

#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

char a[3000],b[3000];

int f[3000][3000]={0};

int main()
{
    scanf("%s",a);
    scanf("%s",b);
    int m=strlen(a)-1;
    int n=strlen(b)-1;
    f[m+1][n+1]=0;
    for(int i=n;i>=0;i--)
    {
        f[m+1][i]=f[m+1][i+1]+1;
    }
//显然当一个字符串已经用完的时候，另一个一个字符串的元素只有被删除了，这里处理一下
    for(int i=m;i>=0;i--)
    {
        f[i][n+1]=f[i+1][n+1]+1;
    }
    for(int i=m;i>=0;i--)
    {
        for(int j=n;j>=0;j--)
        {
            if(a[i]==b[j])
            {
                f[i][j]=f[i+1][j+1];
                continue;
            }
            int t1=min(f[i+1][j],f[i][j+1])+1;
            f[i][j]=min(t1,f[i+1][j+1]+1);
        }
    }
    printf("%d",f[0][0]);
    return 0;
}

```

---

## 作者：乒乓高手 (赞：3)

第一眼看的时候发现这是一道很水的DP：就是裸地求字符间的距离。


在草稿纸上自己画一画很快就能看出规律


首先开一个F的二维数组，来记他们的最少步数，如果两个字符相同，那么F[I][J]=F[I-1][J-1];否则，就是F[I][J-1]，F[I-1][J]和F[I-1][J-1]中最小的一个，最后的答案就在F[L1][L2]中


PS:L1和L2是字符的长度；


话不多说，附上代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>//不要在意头文件
#define maxn 2010
using namespace std;
int f[maxn][maxn];//二维数组
char s1[maxn],s2[maxn];
int main()
{
    cin>>s1+1>>s2+1;//输入
    int l1=strlen(s1+1);
    int l2=strlen(s2+1);
    for(int i=0;i<=l1;i++)//初始化
       f[i][0]=i;
    for(int i=0;i<=l2;i++)//初始化
       f[0][i]=i;
    for(int i=1;i<=l1;i++)
      for(int j=1;j<=l2;j++)
        {
         if(s1[i]==s2[j])
           f[i][j]=f[i-1][j-1];
         else
           f[i][j]=min(f[i-1][j-1],min(f[i-1][j],f[i][j-1]))+1;//注意最后的+1
        }
    cout<<f[l1][l2];//完美结束
    return 0;
}
```

---

## 作者：Lance1ot (赞：3)

代码我就不贴了

我就解释一下状态转移方程

dp[i][j] i、j分别为到字符1[i]和到字符2[j]位置的最优编辑次数（废话）

if（两字符相等）

   dp[i][j]=dp[i-1][j-1]    向前继承

else
   dp[i][j]=min(dp[i-1][j-1](这里为将字符1的i位置替换为字符2的j位置上的字符，也可以理解为同删   ,  然后向前继承次数)

(换行)，min(dp[i][j-1]   (在字符1插入字符2的j下标所代表的字符，也可以理解为从后删除字符2的一个字母),dp[i-1][j](同理))


---

## 作者：wzj423 (赞：3)

####线性动归

转移方程定义：

f[i][j]=a串前i个到b串前j个所需的最小编辑次数

方程
```cpp
      if(a[i]=b[j]) Then     //C++下标为0需特判
              f[i][j]=f[i-1][j-1]
     else
              f[i][j]=max{
                              f[i-1][j]+1,//删除
                              f[i-1][j-1]+1,//改
                              f[i][j-1]+1//添加
                             }
```
代码：
```cpp
/***
P2758
Edit distance
*/

#include <iostream>
#include <iomanip>
#include <cstdio>
#include<cstdlib>

#include <cmath>
#include <string>
#include <cstring>
#include <cctype>

#include <algorithm>
#include <queue>
#include <stack>
#include <map>
#include <set>

#define TMP while(0)

using namespace std;

string a,b;
int dp[2010][2010];

int main()
{
    std::ios::sync_with_stdio(false);
    memset(dp,0x3f,sizeof(dp));
    cin>>a>>b;
    int sizeA=a.size();
    int sizeB=b.size();
    for(int i=0;i!=sizeA;i++)
        {
            dp[0][i]=i;
            dp[i][0]=i;
        }
    for(int i=1;i<=sizeA;i++)
    {
        for(int j=1;j<=sizeB;j++)
        {
            if(a[i-1]==b[j-1])
            {
                dp[i][j]=min(dp[i-1][j-1],dp[i][j]);
            }
            else
            {
                dp[i][j]=min(dp[i][j],dp[i-1][j-1]+1);
                dp[i][j]=min(dp[i][j],dp[i-1][j]+1);
                dp[i][j]=min(dp[i][j],dp[i][j-1]+1);
            }
        }
    }
    cout<<dp[sizeA][sizeB]<<endl;
    return 0;
}
```

---

## 作者：微香玉烛暗 (赞：3)

这道题是一道十分经典的$DP$题，既然是$DP$，那就逃不了状态转移方程。

纯枚举方法会超时，所以用$f(i,j)$表示$s1$前$i$个字符和$s2$前$j$个字符编辑的最短距离.边界条件：$f(i,0)=0,f(0,j)=0.$答案是$f(n,m)$

(n,m分别是两个字符串的长度)

上代码吧：（~~高清方便无注释代码~~）

```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>
using namespace std;
const int N=2005;
int f[N][N],n,m;
string s1,s2;

int main () {
	//freopen (".in", "r", stdin);
	//freopen (".out", "w", stdout);
	cin>>s1>>s2;
	n=s1.size (); m=s2.size ();
	int mx=max(n,m);
	for (int i=1;i<=n;i++) f[i][0]=i;
	for (int j=1;j<=m;j++) f[0][j]=j;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (s1[i]==s2[j])
				f[i][j]=f[i-1][j-1];
			else f[i][j]=min(f[i-1][j],f[i][j-1])+1;
	printf ("%d\n",f[n][m]);
	return 0;
}
//By苍空的蓝耀

```
代码应该简单易懂，谢谢大家支持！

---

## 作者：xzyxzy (赞：2)

对，这道题难度怎么可能只有普及-

这是一道经典的动归题，琢磨透了思路，也就不难了

  
首先还是看看动归的精髓——状态转移方程式怎么来的好了

我们需要转移的，是最小编辑距离，而与之有关的，便是两行字符串了，我们分别把他们叫做初始字符串和目标字符串

所以可以以编辑到的字符串的位置来计算编辑距离

那么需要定义一个二维数组f[i][j]表示从初始字符串的前i个编辑到目标字符串的前j个的最短距离

因为这是动归题O\_\_O "…   所以可知没步的状态之和前面有关，那么在草稿纸上找啊找，重要找到了规律


f[i][j]=mini(f[i-1][j-1]+r,f[i-1][j]+1,f[i][j-1]+1);


好吧，来j解释下这个方程式：mini最好自己打，因为有些版本的c++不认min()函数的 (⊙o⊙)

在编辑初始串前i个至目标串前j个时，不难发现它的最小值为编辑前i-1初始串至j-1目标串的次数加r(当a[i]==b[j]两字符一样时不用编辑，此时r=0，当其不等时要编辑，此时r=1)和编辑前i-1初串至j标串+1（增加一个字符）和编辑前i初串至前j-1标串+1（减去一个字符）三者的最小值


如此这个动归题便完成了


PS:register 是一个玄乎的东东，yyb大佬称之卡常数（就是可以提高运行速度，避免超时，于是乎你看见了么，我的代码跑得还算快的）


希望对你有帮助！


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring> 
using namespace std;
int mini(int a,int b,int c)
{
    if(a>=b&&b>=c) return c;
    if(a>=c&&c>=b) return b;
    if(b>=c&&c>=a) return a;
    if(b>=a&&a>=c) return c;
    if(c>=a&&a>=b) return b;
    if(c>=b&&b>=a) return a;
}
char a[2001],b[2001];
int f[2001][2001];//f[i][j]表示从初始字符串的前i个编辑到目标字符串的前j个的最短距离 
int main()
{
    gets(a);//初始字符串 
    gets(b);//目标字符串 
    register int lena=strlen(a),lenb=strlen(b);
    //进行一些初始化 
    for(register int i=lena;i>=1;i--) a[i]=a[i-1];
    for(register int i=lenb;i>=1;i--) b[i]=b[i-1];//为方便将每个字符串的初始位置挪到1来
    for(register int i=0;i<=lena;i++)
        f[i][0]=i;//从i个字符删到0个需执行i次
    for(register int i=0;i<=lenb;i++)
        f[0][i]=i;//从0个字符增到i个需执行i次
    //开始动归啦~\(≧▽≦)/~
    //先让我们找到动归的状态转移方程式：
    //从初始字符串的前i位编辑成目标字符串的前j位的最小编辑次数
    //会等于从其初始的前i-1位编辑成j-1位的最小次数+1(a[i]!=b[j])+0(a[i]=b[j])
    //和编辑前i位成j-1位的次数+1(加一位)和编辑前i-1位和j位的次数+1的最小值(删一位) 
    for(register int i=1;i<=lena;i++)//枚举初始字符串的长度 
        for(register int j=1;j<=lenb;j++)//枚举目标字符串
```
{//上述两重循环的次序可调换（草稿纸上可以模拟出来）
```cpp
               register int r=0;
            if(a[i]!=b[j]) r=1;
            f[i][j]=mini(f[i-1][j-1]+r,f[i-1][j]+1,f[i][j-1]+1);         
        } 
    cout<<f[lena][lenb];
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

状态：f[i][j]记录ai与bj的最优编辑距离

结果：f[m][n]，其中m、n分别是a、b的串长

初值：b串空，要删a串长个字符；a串空，要插b串长个字符

转移方程：当a[i]=b[j]时，f[i][j]=f[i-1][j-1]，否则，

f[i][j]=min(f[i-1][j-1]+1,f[i][j-1]+1,f[i-1][j]+1)

说明：f[i-1][j-1]+1：改a[i]为b[j]；

f[i][j-1]+1：a[i]后插入b[j-1]；

f[i-1][j]+1：删a[i]。

代码：

```cpp
#include<cstdio>
#include<cstring>
int min(int a,int b){return a<b?a:b;}
int f[202][202];
char s1[202], s2[202];
int i,j,k,m,n;
int main()
{
    scanf("%s%s",s1,s2);
    m=strlen(s1);
    n=strlen(s2);
    for (i=1; i<=m; i++) f[i][0]=i; //到i位置为止把字符串A的内容全部删除
    for (i=1; i<=n; i++) f[0][i]=i; //在开头给字符串A添上和B到i位置相同的字符
    for (i=1; i<=m; i++)
       for (j=1; j<=n; j++)
          if (s1[i-1]==s2[j-1]) f[i][j]=f[i-1][j-1];
            else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
    printf("%d\n",f[m][n]);
    return 0;
}
```

---

## 作者：HeartBlock_Love (赞：1)

状态：f[i][j]记录ai与bj的最优编辑距离

结果：f[m][n]，其中m、n分别是a、b的串长

初值：b串空，要删a串长个字符；a串空，要插b串长个字符

转移方程：当a[i]=b[j]时，f[i][j]=f[i-1][j-1]，

否则f[i][j]=min(f[i-1][j-1]+1,f[i][j-1]+1,f[i-1][j]+1)

说明：f[i-1][j-1]+1：改a[i]为b[j]；

f[i][j-1]+1：a[i]后插入b[j-1]；

f[i-1][j]+1：删a[i]。

```
#include<cstdio>
#include<cstring>
int min(int a,int b){return a<b?a:b;}
int f[202][202];
char s1[202], s2[202];
int i,j,k,m,n;
int main()
{
    scanf("%s%s",s1,s2);
    m=strlen(s1);
    n=strlen(s2);
    for (i=1; i<=m; i++) f[i][0]=i; //到i位置为止把字符串A的内容全部删除
    for (i=1; i<=n; i++) f[0][i]=i; //在开头给字符串A添上和B到i位置相同的字符
    for (i=1; i<=m; i++)
       for (j=1; j<=n; j++)
          if (s1[i-1]==s2[j-1]) f[i][j]=f[i-1][j-1];
            else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;
    printf("%d\n",f[m][n]);
    return 0;
}

```


---


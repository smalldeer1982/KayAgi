# 钟氏映射

## 题目背景

2233年，CSSYZ学校的数学老师兼数学竞赛顾问钟JG已经2200+岁啦！

为了庆生，他或她给广大人民群众出了道题。


## 题目描述

设集合$N=M=\left\{x|x\in N_+,x\leq k,k\in N_+\right\}$

设$f$为$N$到$M$的映射。

求满足：

$f[f(x)]=x$的不同的映射$f$的个数，由于答案较大，输出答案对$14233333$取余的数即可。


## 说明/提示

四个映射分别为：


|f(1)|f(2)|f(3)|
|-|-|-|
|1|2|3|
|1|3|2|
|2|1|3|
|3|2|1|

数据范围：

对于20%的数据，$1\leq k\leq 9$

对于其它的80%的数据，$1\leq k\leq 10^7$


内存20MB...（一开始开1MB把自己坑了）


## 样例 #1

### 输入

```
3
```

### 输出

```
4
```

# 题解

## 作者：XZYQvQ (赞：9)

作为出题人我很方啊

到底算不算数学题呢？

我想应该算用到了组合吧

其实是动归啦。。。

设$g(i)$为集合N=M={1,2,3,....,i}的时候符合条件的映射个数

$g(0)=g(1)=1$

$g(i)=g(i-1)+g(i-2)*(i-1)$

答案为$g(k)$

解释：因为满足$f[f(x)]=x$，所以如果f(x)=y，那么f(y)=x（即形成一个x型的交叉映射）


对于g(i)：

N中的一个元素x，要不就是f(x)=x,要不就是f(x)=y

如果f(x)=x，那么就把x从N、M中拿走，两边元素个数变为i-1，所以方案数为$g(i-1)$

如果f(x)=y，那么就把x、y从N、M中拿走，两边元素个数变为i-2，有n-1个不同的y可以选择，所以方案数为$(n-1)*g(i-2)$

所以加起来就是$g(i-1)+g(i-2)*(i-1)$


由于空间只有20MB，要开滚动数组，记得取模，会爆int


---

## 作者：IcyFoxer_XZY (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P3795)

#### ~~这题我其实是被出题人名字吸引过来的......~~

别看这题是个黄题，只有红题的难度啊！~~（所以别走了）~~

### 思路：

用 $ans[i]$ 记录 $i$ 的答案，之后映射有两种情况：

1. 自己， $ans[i-1]$ 种情况。
1. 其它， $ans[i-2]$ 种情况。

递推公式如下：

$f[i]=f[i-1]+f[i-2]*(i-1)$ 。

### 注意：

**一定要开long long!（不开20分）**

**code：**
```cpp
#include<cstdio>
typedef long long ll;
const int mod=14233333;
ll a=2,b=1,now,n;
signed main(){
    scanf("%d",&n);//cin能过，因为只输入一个数 
    if(n==1){//特判1 
		puts("1");
		return 0;
	}
    if(n==2){//特判2 
		puts("2");
		return 0;
	}
    for(ll i=3;i<=n;++i){//递推过程 
        now=b*(i-1)+a;
        now%=mod;
		b=a;
		a=now;
    }
    printf("%lld",a);//记得加long long 
    return 0;
}
```
Bye

---

## 作者：SakuraDance (赞：4)

参考ZJOI2017 仙人掌

其实要求的就是k个数，允许每个数与另一个数配对或者不参与配对，的方案数

设n个数方案数是f(n)

考虑已有n个数，加入第n+1个数

这个数可以不参与配对：f(n)

这个数可以参与配对，那么他可以选择任何一个数去配对，剩下的n-1个数有f(n-1)种方案：n\*f(n-1)

所以就是f(n)=f(n-1)+f(n-2)\*(n-1)

递推k项即可


---

## 作者：ericmao (赞：3)

~~又是刷数学题的一天~~

首先这道题就是个数学题。。。 想明白了非常无脑，本人由于一开始没搞明白提交了六七遍才过

首先就是映射，相信各位都知道，不知道的百度百科。。。（大概就是说
$$f(x) = y,f(y) = x$$
，简单理解就是两两对应，自己和自己，或者两个数对应） 知道了映射我们看题：

进入正题，这道题有两种情况：

第一种：设我们原来有
$n-1$
个数，我多加进来一个数，现在有
$n$
个数，这个数可以和自己映射，这时候数量就和之前
$n$
个数的时候一样了，所以有
$a_{n-1}$
种情况。

第二种：我可以和前面任意一个数配对，那就要看有
$n-1$
个数的时候，这时我可以随便从
$n$
个数里去掉一个再挑一个配对，也就是
$$a_{n-2}\times(n-1)$$
种情况

所以
$$a_i = a_{i-1}+(i-1)\times a_{i-2}$$
,然后按这个写就过了（数一定要开 **long long** ，还有开滚动数组，不然会爆。）

最后贴一下程序：
```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n,a[3];
    a[0]=1;
    a[1]=2;
    cin>>n;
    if(n==1) 
    {
        cout<<1;
        return 0;
    }
    if(n==2) 
    {
        cout<<2;
        return 0;
    }
    for(int i=3;i<=n;i++)
    {
        a[2]=(long long)a[1]+a[0]*(i-1);
        a[2]=a[2]%14233333;
        a[0]=a[1];
        a[1]=a[2];
    }
    cout<<a[1];
    return 0;
 } 
```


---

## 作者：云雷心柠檬听 (赞：1)

### 思维路径

根据映射，我们可以发现数字的规律必定是两两互换，即若 $f_a$ 是 $b$ ，那么 $f_b$ 一定是 $a$ 。

我们可以通过手算 $1$ 到 $4$ 的数据，观察规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/j36fh2d1.png)

观察第 $4$ 行的数据。

- 以 $1$ 为始的数据后面跟的三个数据正好与第三行的顺序相同。方案数和第三行的方案数相同。

- 不以 $1$ 为始得数据，以 $2$ 为例，也就是 $1$ 和 $2$ 互换了位置，剩下 $2$ 个数字正好和第二行得数据相同，方案数与第二行得方案数相同，这样的数字有 $4-1$ 个

得出结论：第 $i$ 行的数据等于第 $i-1$ 行加上第 $i-2$ 行乘以 $i-1$。即：

$$
f_i=f_{i-1}+(i-1) \times f_{i-2}
$$

### 代码实现

空间很小，需要使用滚动数组，第 $i$ 位的储存方式如下。

```cpp
if((i&1)==0){
	f[0]*=i-1;
	f[0]%=MOD; 
	f[0]+=f[1];
	f[0]%=MOD;
}
else{
	f[1]*=i-1;
	f[1]%=MOD; 
	f[1]+=f[0];
	f[1]%=MOD;
}
```

同时注意要取模。

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD=14233333;
ll n,f[2];

void input(){
	cin>>n;
} 

void solve(){
	f[1]=1; f[0]=2;
	for(ll i=3;i<=n;i++){
		if((i&1)==0){
			f[0]*=i-1;
			f[0]%=MOD; 
			f[0]+=f[1];
			f[0]%=MOD;
		}
		else{
			f[1]*=i-1;
			f[1]%=MOD; 
			f[1]+=f[0];
			f[1]%=MOD;
		}
	}
	cout<<f[n&1];
}

int main(){
	input();
	solve();
	return 0;
}
```


---

## 作者：litble (赞：1)

此题又名：信息组上数学课的日常......

先%一发出这题的xzy神犇。

然后题解是：用f[i]表示i个元素时的答案。

那么对于每个新加入的元素i，它可以选择映射自身，有f[i-1]种方案。

也可以选择映射其他元素，有(i-1)种选择，那么那个元素x也必须映射i，f[i-2]种方案

所以答案是f[i]=f[i-1]+f[i-2]\*(i-1);

只要保存三个变量即可。才不是我建议神犇xzy卡空间的。

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
long long las1,las2,now,mod=14233333;
int main()
{
    las2=1;las1=2;
    scanf("%d",&n);
    if(n==1){printf("1");return 0;}//特判1和2的情况
    else if(n==2){printf("2");return 0;}
    for(i=3;i<=n;i++){
        now=(long long)las2*(i-1)+las1;//递推式子
        now%=mod;las2=las1;las1=now;//滚动一下，这样就可以卡空间了（大雾）
    }
    printf("%lld",las1);
    return 0;
}
```

---

## 作者：nzcnnr (赞：0)

# 分析
这道题考虑 dp，因为 $10^7$ 的数据很容易就把搜索卡死。

观察题目发现，在这道题目中有两种映射方式才可以符合要求：
$$f_i=i$$
$$f_i=j,f_j=i(i\ne j)$$
所以说，本题的递推公式也就围绕着这两个公式而形成,我们定义变量 $i$ 和一个数组 $dp$，用 $dp$ 数组来表示有 $k=i$ 时的答案数，可知：
$$dp_i=dp_{i-2}\times (i-1)+dp_{i-1}$$
为什么呢？

首先 $dp_{i-1}$ 代表了新加入的 $i$ 数符合第一种映射方式，接下来 $dp_{i-2}\times (i-1)$ 则是新加入的 $i$ 数与原来的 $i-1$ 中的任一一数组成的第二种映射。

# 代码实现

```c
#include <stdio.h>
#include <algorithm>
#include <cmath>
#include <string.h>
#include <queue>
#include <iostream>
#include <string>
using namespace std;
int main(){
	int k;
	scanf("%d",&k);
	long long dp[k+5];
	memset(dp,0,sizeof(dp));
	dp[1]=1;
	dp[2]=2;
	for(int i=3;i<=k;i++){
		dp[i]=dp[i-2]*(i-1)+dp[i-1];
		dp[i]%=14233333;
	}
	printf("%d",dp[k]);
	return 0;	 
}
```
当你兴冲冲地提交时，你会发现你寄了……（毕竟只有 $20MB$）

所以说我们再次观察，发现关于 $dp_i$ 的大小只跟 $i-1$ 和 $i-2$ 有关，所以说，我们选择使用一个滚动数组优化。
## AC!
```cpp
#include <stdio.h>
#include <algorithm>
#include <cmath>
#include <string.h>
#include <queue>
#include <iostream>
#include <string>
using namespace std;
int main(){
	int k;
	scanf("%d",&k);
	long long dp[3];
	memset(dp,0,sizeof(dp));
	dp[0]=1;
	dp[1]=2;
	if(k==1){
		printf("1");
		return 0;
	}
	if(k==2){
		printf("2");
		return 0;
	}
	for(int i=3;i<=k;i++){
		dp[2]=dp[0]*(i-1)+dp[1];
		dp[2]%=14233333;
		dp[0]=dp[1];
		dp[1]=dp[2];
	}
	printf("%lld",dp[2]);
	return 0;	 
}
```

---

## 作者：17and17 (赞：0)

本题是一个简单的递归；

根据题意分析要实现f[f(x)]=x，可以f[x] = x,也可以两个数一组f[x] = y,f[y] = x；

很明显g[1] = 1,g[2] = 2;

当n>=3时，g[n]一部分来源于f[n] = n的情况，有g[n-1]种，另一部分来自n与任意数（小于n）组合，与每个数有g[n-2]种组合，有n-1个数，总共（n-1）* g[n-2];所以g[n] = g[n-1]+g[n-2]*(n-1);
代码：
```cpp
#include"bits/stdc++.h"
using namespace std;
const int Mod = 14233333;
long long f[3],N,i;//滚动数组减小内存使用
int main()
{
	scanf("%lld",&N);
f[1] = 1;
f[2] = 2;
for(i = 3;i <= N;i++)
{
f[i%3] = (f[(i-1)%3]%Mod+((i-1)%Mod*f[(i-2)%3]%Mod)%Mod)%Mod;
}
printf("%lld",f[N%3]);	
}
```



---

## 作者：WilliamPon (赞：0)

首先，可以把分类自动视为图论，才不是什么数学(先别打我...)

视N=M={1, 2, 3,..., k}

每一个元素视为一个图中的节点

每一次由原象求象的过程(或者说每一次的求f(x)),

可以认为是连一条x到f(x)的有向边(当然f(x) == x时就是x连了个自环边)

因为是映射，则每个点的出度只能为1。

那么题目就是求连边的方案数


如果一定要搜索的话，可以稍稍加个小优化(当然还是过不了)，设个vis数组表示已经被连边的点，跳过已经被标记的点。相当于使搜索时每个点的入度只能唯一。似乎有些问题，映射中可以存在多点映射到同一点，会不会错呢？

其实根据简单的反证法可以证明。假设存在两个点连边到一个点上，很容易看出矛盾


当然不是搜索啦。其实先手动暴力（当然大佬目测就行，不过大佬也不会看到这吧）就能看出要满足要求的话，其中任意一个点要么是与另一个点互连边，要么是连自环边。

那么对于g(x)(表示k == x时的答案)，对于连自环边的有g(x-1)的答案(当前点连自环边)，另一种情况则是(x - 1) \* g(x - 2)，表示当前点与另一点互联边g(x - 2)，有(x - 1)种选择。

所以有g(x) = g(x - 1) + (x - 1)  \* g(x - 2)


好吧，就是简单递推顺便有那么一点点dp的思想

说了别打我。。。


---


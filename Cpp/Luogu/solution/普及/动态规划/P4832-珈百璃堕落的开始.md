# 珈百璃堕落的开始

## 题目背景


“恭喜你，珈百璃，你以学年首席的优秀成绩毕业。”

珈百璃，一位优秀的天使，今天她以学年首席的成绩毕业，从今往后，她将前往人间进行进一步修炼。

“我会努力给人类带来幸福的！”珈百璃憧憬着人间生活。

开学第一天，珈百璃就凭借着她极其可爱的外表，受到了班级成员的追捧，不仅长得可爱，成绩还很优秀，简直就是女神啊！

因为她的成绩优秀，所以她的作业也是很快就快要完成了，但是就在她快完成数学作业时，她的电脑传来了呼救的声音。

“救命啊！”

顺着这个呼救声，珈百璃望向了电脑。

“原来是游戏啊。”珈百璃看着屏幕里一位倒在地上的残血战士，注册了账号，选择了牧师职业，对这位战士进行了救治。在珈百璃开心的同时，越来越多的呼救声传来，珈百璃一个一个进行救治，但她的 level 才 1，mp 肯定不足，当她想要继续进行救治的时候，系统提示 mp 不足，并给出了氪金的提示：“屠龙宝刀，点击就送。”

“生活费天界学院倒是有给，但是……”珈百璃看着自己的存折，再看看屏幕，她纠结不已。

“救命啊！”“救……救命啊……”“救命啊！”珈百璃看着这些人一个个喊出救命，自己却无能为力，终于，她控制不住自己，点下了“氪金”按钮。

从此，珈百璃的堕落就开始了，她的作业，也停在了这道数学题上……

“薇奈特，帮我写一下作业嘛。”珈百璃央求着薇奈特。

“真是的，你好歹也是天使呢，也该自己做一点作业吧。”

“不要，我还要打游戏呢。”

“这怎么行，你是天使啊。”

“我已经决定做一位成天打游戏不学习的堕天使了。”

“真是服了你啊，那你好好打游戏吧，我帮你写。”


## 题目描述

这道题是这样的：给定一些 $\sin^2x$，$\cos^2x\ \left(x=\dfrac{\pi}{7}\right)$ 组成的式子，请你帮忙求出选择一些式子相加后得到的**最大整数答案**。

## 说明/提示

### 样例解释

三个式子都选，则加起来等于 $3$。

### 数据范围

设 `s` 和 `c` 的个数总和为 $m$。

$10\%$ 的数据 $n=1$。

另外 $20\%$ 的数据每行一个单项式。

另有 $20\%$ 的数据 $n\le20$。

$100\%$ 的数据 $n\times m\le5\times10^7,m\le10^6$。

### 提示

 - $\forall x, \sin^2x+\cos^2x=1$。

## 样例 #1

### 输入

```
3
s+c
s+c+s
c
```

### 输出

```
3```

# 题解

## 作者：zhyh (赞：16)

比赛时写的程序开了o2后跑了286ms，竟然是目前第一233  
思想仍然是背包，但是和赛后题解里的处理有些不同，常数更小一些qwq  
我们记一个式子的$s$和$c$的个数分别为$a$、$b$，则不妨令体积$v=a-b$，那么答案就是体积为$0$时的最大价值$w$了。其实由对称性，也可以令所有$v=b-a$。那么价值呢？全部设为$w=a$或全部$w=b$都可以啦，个人觉得这样处理还是挺漂亮的qwq  
于是就成了带有负数体积的背包问题啦，和P2079类似，我们只需要处理一下数组下标越界的问题，因此我们把所有下标平移一个足够大的$T$就可以了，其他照常写。另外由于有负数体积，直接滚动数组就会有后效性了，改为取膜滚动也无妨。方程：
$$dp[i][j+T] = max(dp[i][j+T], dp[i-1][j-v+T]+w)$$  
代码如下：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int inf = 100000000;
const int T = 1000300;
int N, sum[2], dp[2][2001005], l, r;
char s[2000005];

inline int max(int x, int y)
{
    return x>y? x: y;
}
inline int min(int x, int y)
{
    return x<y? x: y;
}
int main()
{
    scanf("%d", &N);
    for (register int i=0; i<=2001000; ++i) dp[0][i] = dp[1][i] = -inf;
    dp[0][T] = 0;
    for (register int i=1, ls; i<=N; ++i) {
        scanf("%s", s), ls = strlen(s);
        sum[0] = 0, sum[1] = 0;
        for (register int j=0; j<ls; j+=2) if (s[j]=='c') sum[0]++; else sum[1]++;
        int w = sum[0], v = sum[1] - sum[0];
        l = min(l, l+v), r = max(r, r+v);
        for (register int j=l; j<=r; j++) {
            dp[i&1][j+T] = max(dp[i&1][j+T], dp[i&1^1][j+T]);
            dp[i&1][j+T] = max(dp[i&1][j+T], dp[i&1^1][j-v+T]+w);
            //printf("%d: %d\n", j, dp[i&1][j+T]);
        }
    }
    printf("%d\n", dp[N&1][T]);
    return 0;
}
```

---

## 作者：Yaha (赞：7)

### 背包

学过高一数学的都知道$sin^2x+cos^2x=1$。题目中说答案必须为整数，所以**s和c的数量必须相等**，以凑成若干对。

问题就转变为背包问题：**每个式子抽象成物品**，**$s-c$抽象成重量**，而我们的目标是找到总重量为**0**时的最大价值，**价值抽象成$s$（或者$c$）**，因为每一对配对的$s$和$c$价值为1。

我们设$f[i][j]$表示前$i$个物品中，总重量为$j$时的最大价值。那么：

$f[i][j]=max(f[i][j],f[i-1][j-w]+v)$

其中$w$为物品$i$的重量，$v$为物品$i$的价值。

由于重量可能为负数，下标越界，所以我们把下标右移足够大的长度$D$，所以：

$f[i][j+D]=max(f[i][j+D],f[i-1][j-w+D]+v)$

由于$D$很大，直接这样做肯定炸空间，我们考虑优化第一维。由于转移时只有$f[i-1][]$有用，所以我们可以直接用一个$g[]$数组作为$f[i-1][]$。即：

$f[j+D]=max(f[j+D],g[j-w+D]+v)$

结合代码理解吧

```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
const int D=1e6+90;
int l,r,n; //l表示至今最小重量，r表示最大重量 
int f[2*D],g[2*D]; //f表示i这一维，g表示i-1那一维

int main(){
	scanf("%d",&n);
	memset(f,128,sizeof f);
	memset(g,128,sizeof g);
	g[D]=0;//初始化
	for(int i=1;i<=n;i++)
	{
		int sums=0,sumc=0;
		cin>>a;
		for(int j=0;j<a.size();j++)
		{
			if(a[j]=='s') sums++;
			else if(a[j]=='c') sumc++;
		}
		int v=sums,w=sums-sumc;
		l=min(l,l+w),r=max(r,r+w);//更新l和r，作为枚举重量的左端点和右端点
		for(int j=l+D;j<=r+D;j++)//把+D的操作放这来效果一样
			f[j]=max(f[j],max(g[j],g[j-w]+v));
		for(int j=l+D;j<=r+D;j++)
			g[j]=f[j];//更新g数组
	}
	printf("%d",f[D]);//相当于f[0]
	return 0;
}
```


---

## 作者：淸梣ling (赞：6)

# Problem
[link](https://www.luogu.com.cn/problem/P4832)

# Solution
这是一道比较 _奇妙_ 的**背包 DP**，看过其他题解后发现大佬都是直接一个背包得结果，本蒟蒻自己并没有这样的本事，做法比较偏直接。

学过数学的大家应该都知道 $\sin^2 x + \cos^2 x = 1$。
题目中说**最后的结果必须为整数**，所以我们可以把每个函数
看成：

$v + u \times \sin^2 x$ 或 $v + u \times \cos^2 x$。其中 $v$，$u$ 为整数。
 
 那么时候我们就可以把 $v$ 看成物品的价值，$u$ 看成物品的费用，因为费用分为两种，所以我们可以用**两个背包** $sf$，$cf$ 存储，容量为 $u$ 时，此时的总价值便是 $sf_u+cf_u+u$。

这里要注意一下，背包的容量代表，当有 $u$ 个 $\sin^2 x$（或 $\cos^2 x$）时，最大的 $v$。所以两个背包合并时，也会有 $u$ 个 $1$。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;

int sf[1000100],cf[1000100];
int sSum,cSum;

//01背包
void zeroPack(int f[],int p,int u,int v)
{
	int i;
	
	for(i=p;i>=u;i--)
	f[i]=max(f[i],f[i-u]+v);
}
int main()
{
	int n;
	int i,j;
	int ans=0;
	
	cin>>n;
	memset(sf,0x80,sizeof(sf));
	memset(cf,0x80,sizeof(cf));
    //初始化为最小值，代表不能有u个sinx或cosx
	sf[0]=cf[0]=0;
	for(i=1;i<=n;i++)
	{
		string str;
		int s=0,c=0;
		cin>>str;
		for(j=0;j<str.size();j+=2)
		{
			if(str[j]=='s') ++s;
			else if(str[j]=='c') ++c;
		}
		if(s-c>=0)
		{
			sSum+=s-c;//背包总大小
			zeroPack(sf,sSum,s-c,min(s,c));
		}
		else
		{
			cSum+=c-s;//背包总大小
			zeroPack(cf,cSum,c-s,min(s,c));
		}
	}
	for(i=0;i<=min(sSum,cSum);i++)
	if(sf[i]>=0&&cf[i]>=0)
	ans=max(ans,sf[i]+cf[i]+i);
	
	cout<<ans;
	return 0;
}

```
 _撒花~~ _ 

---

## 作者：xinxin2022 (赞：2)

我对这道题的印象还是比较深刻的，毕竟从我第一次提交到通过，经历了接近两周（当然也有我太弱了的原因）。

下面进入正题：

出题人已经提示我们了，$\sin^2x+\cos^2x=1$，所以我们要想办法让 $\sin^2x$ 和 $\cos^2x$ 的数量相等。

所以我们考虑背包，设每个式子中 $s$ 和 $c$ 的数量之差为重量，再设每个式子中 $c$ 的数量为价值，可以发现当重量之和为零时所能取到的最大价值，就是我们要求的答案。

有的同学可能不理解为什么重量为零才能当作答案，那我们分析每个重量，它的意思是式子中 $s$ 和 $c$ 的差，而我们要找差为零时，能取到最大价值，所以自然要找 $s$ 和 $c$ 的差为零时最多能取到的 $s+c$ 的数量。

显然，无法一个式子取多次，所以**应当使用01背包**。

需要注意的是，可能会出现负数，所以可以将下标整体右移，并且为防止空间爆炸，需要使用滚动数组优化。

代码（勿抄袭）：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int D=1001974;//下标右移的量
long long n,c,s,dp[2][1000005+D+5],v[1000005],w[1000005],minn,maxn;
string r;
int main(){
    memset(dp,-0x3f3f3f3f,sizeof dp);
    //初始化为最小值
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>r;
        c=0;s=0;
        for(int j=0;j<r.size();j++){
            if(r[j]=='c') c++;
            if(r[j]=='s') s++;
        }
        w[i]=s-c;//计算重量
        v[i]=c;//计算价值
        //这里的v和w数组不用右移下标
    }
    dp[0][D]=0;//显然最少能取到的价值为0
    for(int i=1;i<=n;i++){
        minn=min(minn,minn+w[i]);
        maxn=max(maxn,maxn+w[i]);
        //找可能可以修改的区间
        for(int j=minn;j<=maxn;j++){
            dp[i%2][j+D]=max(dp[!(i%2)][j+D],dp[!(i%2)][j-w[i]+D]+v[i]);
            //状态转移，经典的01背包状态转移方程。
        }
    }
    cout<<dp[n%2][D];
    return 0;
}
```

---

## 作者：mlvx (赞：2)

令 `s` 的个数为 $s$，`c` 的个数为 $c$。

令体积为 $s-c$，则价值就是 $s$，最后的答案就是体积为 $0$ 时的价值。

为什么呢？

$\sin^2x+\cos^2x=1$，二者都是无理数，所以只有加起来才可能是整数。

体积为 $0$ 就表示 $s$ 的个数和与 $c$ 的个数和的差为 $0$，
即 $s$ 与 $c$ 的个数是相同的。

此时的价值就是 $s$。考虑一下，二者都是 $s$ 个，那么对答案的贡献也就是 $s$。

---

体积有可能为负数，可以直接在体积这一维度上都加上 $M=10^6$。

但是开不下，得压维。

体积为负数应该怎么压维呢？

进行分情况讨论。

- 当体积为正数时，倒着跑。

- 当体积为负数时，正着跑。

- 当体积为 $0$ 时，正着倒着都可以。

---

目前是最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e6; 
int n,dp[(M<<1)+10];string S;
int main(){
	ios::sync_with_stdio(0);cin.tie(),cout.tie();
	cin>>n,memset(dp,-0x7f,sizeof dp),dp[M]=0;
	for(int i=1,l=0,r=0,v;i<=n;i++){
		cin>>S;int s=0,c=0;
		for(int j=0;j<S.size();j+=2)S[j]=='s'&&++s,S[j]=='c'&&++c;
		v=s-c,l=min(l,l+v),r=max(r,r+v);
		if(v<=0)for(int j=l+M;j<=r+M;j++)dp[j]=max(dp[j],dp[j-v]+s);
		if(v>0)for(int j=r+M;j>=l+M;j--)dp[j]=max(dp[j],dp[j-v]+s);
	}return cout<<dp[M],0;
}
```

---

## 作者：lqsy002 (赞：1)

## P4832
## 题目大意
题目已经写的很清楚了。[题目链接](https://www.luogu.com.cn/problem/P4832)。
## 解题思路
**背包。**

其实就是一个变换了状态的背包，我们用 $s[i]$ 表示第 $i$ 个式子 $s$ 的个数，$c[i]$ 表示第 $i$ 个式子 $c$ 的个数，两个数减一减视为重量，减数视作价值，那么答案就是重量和为零时的 dp 值，式子就是简单的背包转移式，注意因为重量会变负数所以加一个大数，然后加上滚动即可。
## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int L=1e6+500;/*由于结果可能为负，导致下标越界，
		      所以我们把下标右移足够大的长度*/
int n,dp[2][2*L],l,r;
char s[2000010];
struct node{
    int s,c,w,v;
}a[2000010];
int main(){
    memset(dp,-0x3f3f3f3f,sizeof(dp));
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",s);
        int l=strlen(s);
        for(int j=0;j<l;j+=2){
            if(s[j]=='s') 
		a[i].s++;
            if(s[j]=='c') 
		a[i].c++;
            a[i].w=a[i].s-a[i].c;
            a[i].v=a[i].c;
        }
    }
    dp[0][L]=0;
    for(int i=1;i<=n;i++){
        l=min(l,l+a[i].w);
	r=max(r,r+a[i].w);
        for(int j=l;j<=r;j++){//背包转移式
            dp[i&1][j+L]=max(dp[i&1][j+L],dp[(i&1)^1][j+L]);
            dp[i&1][j+L]=max(dp[i&1][j+L],dp[(i&1)^1][j-a[i].w+L]+a[i].v);
        }
    }
    printf("%d",dp[n&1][L]);
    return 0;
}
```

---

## 作者：GXZJQ (赞：0)

# P4832 珈百璃堕落的开始 题解

[题目链接](https://www.luogu.com.cn/problem/P4832)

## 题目大意

给定 $n$ 个加法算式，现在要求你从里面选出一些式子相加，使得它们的和最大且为整数。

## 题目分析

众所周知，$\sin^2 \alpha + \cos^2 \alpha=1$，这是由三角函数的定义得出的。

在这道题中，能够识别出背包是很关键的。由于 $\sin^2 \alpha$ 和 $\cos^2\alpha$ 都不为整数，所以我们只能让所选式子中 `s` 的个数和 `c` 的个数保持相等。

那么，如何定义背包问题的体积 $w$ 和价值 $v$ 呢？还是回归题目本身，由于答案要求是整数，所以我们不妨将体积记为两种不同项的**个数差**，即记 $\sin^2\alpha$ 的个数为 $cnt_s$，$\cos^2\alpha$ 的个数为 $cnt_c$，则这个式子的体积就为 $cnt_s-cnt_c$，那么它的价值就是 $cnt_c$。

再来思考一下状态的转移。由题意，数据范围比较大，所以我们要采用滚动数组优化空间复杂度。那么，不难写出以下的代码：

## 参考代码

```cpp
/**
 * 题目名称：P4832 珈百璃堕落的开始
 * 题目链接：https://www.luogu.com.cn/problem/P4832
 * 做题时间：2024年6月17日 
 * 考查内容：背包，数学 
 * 难度评级：普及/提高- 
 * 主要思路：背包问题：将 s-c 记为每个物品的体积，那么最后
 			 我们要求的就是总体积为 0 时的最大价值，由数学
			 知识可得它的价值就是 s 的个数。 
 * 注意事项：由于数组下标可能出现负数，所以要加上一个足够大的数。 
 **/
#include<bits/stdc++.h>
using namespace std;
const int large = 5e7;
const int maxn = 1e6 + 10;
int s[large], c[large], w[large], v[large];
int f[2][maxn << 1]; //滚动数组优化
int maxnum, minnum, n;
int main() {
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	memset(f, -0x3f, sizeof f);
	cin >> n;
	string a;
	getline(cin, a);
	for (int i = 1; i <= n; i++) {
		getline(cin, a);
		for (int j = 0; j < a.length(); j++) {
			if (a[j] == 's') s[i]++;
			if (a[j] == 'c') c[i]++;
		}
		w[i] = s[i] - c[i];
		v[i] = c[i];
	}
	f[0][maxn] = 0;
	for (int i = 1; i <= n; i++) {
		minnum = min(minnum, minnum + w[i]);
		maxnum = max(maxnum, maxnum + w[i]);
		for (int j = minnum; j <= maxnum; j++) 
			f[i & 1][j + maxn] = max(f[i & 1][j + maxn], max(f[(i & 1) ^ 1][j + maxn], f[i & 1 ^ 1][j - w[i] + maxn] + v[i]));
	}
	cout << f[n & 1][maxn];
	return 0;
}
```

---

## 作者：Wf_yjqd (赞：0)

数据范围给的提示好明显啊。

------------

竟然需要初三数学诶。

$\sin^2{x}+\cos^2{x}=1$

又因要求答案必须为整数，相当于要求必须配完的情况下求最多对数。

考虑背包。

显然可以用两种函数出现次数的差值表述一个式子花费的代价，最终代价为 $0$ 的就是答案。

如何描述贡献的价值呢？

显然最终两个函数可以一一对应，所以其中任意一个出现的次数就为能组成的对数。

由于两函数差值可能无法确定正负，最终的和当然也确定不了。

考虑将所有代价和都加上一个常数，把负的化成正的处理。

接下来就是背包板子了。

空间不够所以整个滚动数组。

复杂度 $\operatorname{O}(n\times m)$。

------------

不懂的看代码、
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+84;
const int add=1e6+23;
inline int maxx(register int x,register int y){
    return x<y?x:y;
}
int n,len,u,v,mn=add,mx=add,f[2][maxn];
char s[maxn];
int main(){
    memset(f,0x8f,sizeof(f));
    f[0][add]=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);
        len=strlen(s+1);
        u=v=0;
        for(int j=1;j<=len;j++){
            if(s[j]=='+')
                continue;
            u+=s[j]=='s';
            v+=(s[j]=='s'?1:-1);
        }
        mn=min(mn,mn+v);
        mx=max(mx,mx+v);
        for(int j=mn;j<=mx;j++)
            f[i&1][j]=maxx(f[i&1][j],maxx(f[i&1^1][j],f[i&1^1][j-v]+u));
    }
    printf("%d Sherry",f[n&1][add]);
    return 0;
}
```


---

## 作者：Fa_Nanf1204 (赞：0)

### 分析：
注意到每行选或不选，考虑用背包的思想来做。

首先给出高一的数学知识 $\sin^2x+\cos^2x=1$，题目中所要求和为整数，所以必定要使两者数量相同才可以，那么就可写式子了。

统计 `s` 的个数为 $sums$，统计 `c` 的个数为 $sumc$。那么背包的价值就可定为 $sums$，此时他的重量就应为 $sumc-sums$，所以给出式子：

$dp_j=\max\{dp_j{,}dp_{j-sumc+sums}+sums\}$

最后注意两个细节：

1. 重量可正可负，下标会出负，要加上一个定值。
2. 重量可正可负，正数时倒序跑背包，负数时正序跑背包。

### 代码如下：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std; 
const int T=1e6+300;
ll n,sums=0,sumc=0,dp[T*2],l,r;
string s;
int main(){
	memset(dp,-0x3f,sizeof dp);
	dp[T]=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		int len=s.size();
		sums=0,sumc=0;
		for(int j=0;j<len;j++){
			if(s[j]=='s') sums++;
			else if(s[j]=='c')sumc++;
		}
		ll w=sumc-sums,v=sums;
		l=min(l,l+w),r=max(r,w+r);
		if(w>=0){
			for(int j=r;j>=l;j--){
				dp[j+T]=max(dp[j+T],dp[j+T-w]+v);
			}
		}
		else{
			for(int j=l;j<=r;j++){
				dp[j+T]=max(dp[j+T],dp[j+T-w]+v);
			}
		}
	}
	cout<<dp[T];
	return 0;
}
```

---


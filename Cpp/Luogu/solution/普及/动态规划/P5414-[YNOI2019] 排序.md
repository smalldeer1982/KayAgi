# [YNOI2019] 排序

## 题目描述

对于一个数列 $\{7, 1, 2, 3\}$ 进行排序，我们可以把 $7$ 从头移动到尾。但是这个操作的成本是 $7$，并不是最佳的。最佳的排序方式是将连续的 $1,2,3$ 移动到 $7$ 的前面。这样的话，总的操作成本就是 $1+2+3=6$，比之前的成本 $7$ 要小。

你的任务是，对于一个给定的数列，输出对这个数列进行排序的最小成本。

## 说明/提示

对于 $60\%$ 的数据：$0 < n \leq 60$，$-10^{7} \leq k_i \leq 10^{7}$

对于 $80\%$ 的数据：$0 < n \leq 80$，$-10^{7} \leq k_i \leq 10^{7}$

对于 $100\%$ 的数据：$0 < n ≤ 10^2$，$-10^{7} \leq k_i \leq 10^{7}$


## 样例 #1

### 输入

```
1
4
7 1 2 3```

### 输出

```
6```

# 题解

## 作者：Felis (赞：58)

### 手残了，第一次的题解少打了一个等于麻烦管理员大大重新审核QwQ

这道题就是移动几个数字使得数列单调上升，每次移动可以移动到任意位置，花费就是移动数字的大小。

看到这个题之后，我们可以得到 ~~得不到的洗洗睡吧~~ ：**最优解不可能把同一个数字移动2次及以上**。既然我们可以一次把它移到正确的位置上，那么这个数字就可以理解为直接被移走了。

那么问题就变成了：删除几个数字，使得数列单调递增，所求的是移走数字的最小和。 使得删除的和最小，就意味着留下的和最大。

那么问题就变成了：保留几个单调递增的数字，使得和最大。

```
		for(int i=0;i<n;i++){
		    for(int j=~0;j<i;j++)
			if(a[j]<=a[i])
			    b[i]=max(b[i],b[j]);
		    b[i]+=a[i];
		}
```
最后把数列每一个数的和减去Max{b[i]}就可以了



---

## 作者：syksykCCC (赞：30)

@[Nakano_Miku](https://www.luogu.org/space/show?uid=210021) 大佬已经讲的很清楚了，这题就是求一个序列的最大不下降子序列，我来发一波代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int f[N], a[N], sum;
int main() 
{
    int T;
    scanf("%d", &T);
    while (T--) 
	{
        int n;
        // ========= init =========
        memset(f, 0, sizeof f);
        sum = 0;
        
        // ======== input & get SUM =======
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) 
		{
            scanf("%d", &a[i]);
            sum += a[i];
        }
        
        // ========= dp ==========
        for (int i = 1; i <= n; i++) 
		{
            for (int j = 1; j < i; j++) 
			{
                if (a[j] <= a[i]) // 因为序列不下降，只能从比自己小的数那里转移
                    f[i] = max(f[i], f[j]);
                // f[i]此时用来储存可以用来转移的最大和 
            }
            f[i] += a[i]; // f[i]加上本身 
        }
        
        // ======= get the max num of f[] ========
        int maxx = 0;
        for (int i = 1; i <= n; i++) 
			maxx = max(maxx, f[i]);
        
        // ========== output ===========
		printf("%d\n", sum - maxx); // 注意输出是求所有删去的数的和，而f[]存储的是保留的数的和 
    }
    return 0;
}
```

大体论证思路：

1. 根据题意可发现此题就是删除一些数，让一个序列保持不下降
2. 让删除的数的和尽可能小，就是让保留的数的和尽可能大
3. 所以此题即求一个序列的**最大不下降子序列**

---

## 作者：Dry_ice (赞：21)

> ~~又来写题解了。/hh~~

## 题意概述

通过调换数字 $K_{c_1},K_{c_2},\cdots,K_{c_m}$，对长度为 $n$ 的序列 $K$ 进行升序排序，所用成本为 $K_{c_1},K_{c_2},\cdots,K_{c_m}$。求排序的最小成本。

## 大致思路
调换 $K_{c_1},K_{c_2},\cdots,K_{c_m}$ 其实就是将 $K$ 中其他数字留在原来的位子上。显然，留下来的数字必须是升序排列的。因为调动的数字个数 $m$ 越大，耗费就越多，所以要让尽量少的数字调动。那么，留下来的数字就是最多的，也是升序排列的。

看到这里，你是不是想到了 $dp$ 的经典问题：最长不降子序列。

与其说调换数字，不如说是**保留数字**。保留**最多的数字**，直接求**最长不降子序列**就行，但 $F_i$ 的意义是得改变的。

综上，代码就能写出来了！

另外，记得**多组数据**！

## CODE

```cpp
#include <stdio.h>
int n, a[105], f[105];
int main(void) {
    int t;
    for (scanf("%d", &t); t--; ) {
        scanf("%d", &n);
        int ans1 = 0, ans2 = 0;
        for (int i = 1; i <= n; ++i)
            scanf("%d", &a[i]), ans1 += a[i];
        for (int i = 1; i <= n; ++i) {
            f[i] = 0;
            for (int j = 0; j < i; ++j)
                if (a[j] <= a[i])
                    f[i] = f[j] > f[i] ? f[j] : f[i];
            f[i] += a[i];
            ans2 = f[i] > ans2 ? f[i] : ans2;
        }
        printf("%d\n", ans1 - ans2);
    }
    return 0;
}
```

## The end. Thanks.

~~（走过路过是不是要赞过呢？~~

---

## 作者：Smallbasic (赞：11)

~~我要去云南~~

这题直接做看起来很难，我们换个思路

容易发现我们对于每个数最多只需要移动一次，即把它移动到它排序后所在的地方。

那么一定有一些数是不移动的，不移动的数构成了一个单调不降子序列

那么要使移动的数的和最小，就可以转化为使不移动的数和最大。

因此问题就转化为了求一个单调递增子序列它里面数的和最大，显然是入门dp。答案即使所有书的和减去这个单调递增子序列里的数的和。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

long long f[1005], t, n, sm, delta, a[1005]; 

int main() {
	scanf("%d", &t);
	while (t--) {
		scanf("%d", &n);
		for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), sm += a[i];
		for (int i = 1; i <= n; ++i) {
			for (int j = 0; j <= n; ++j)
				if (a[i] >= a[j]) f[i] = f[i] > f[j] ? f[i] : f[j];
			f[i] += a[i]; delta = delta > f[i] ? delta : f[i];
		} printf("%lld\n", sm - delta);
		memset(f, 0, sizeof(f)); sm = delta = 0;
	} return 0;
}
```


---

## 作者：据设错了 (赞：5)

这道题说的是求最小成本，但是我想了想，得出了一个伟大的结论——~~我不会~~很难。然后我就接着想，有没有办法可以不用求最小成本的方法求最小成本呢，其实是有的。我常常看别人解题是用逆向思维的，我终于也能用上一场了——因为他排序是最小成本，那么除了排过序的数字以外，就是最大的了。那么我们求出这个数每次需要进行排序的两个数（我用的是冒泡原理，冒泡是每两个数都进行一次比较）中最大的值加上当前的值（每一次排序用的成本），然后每次循环都打擂台，求出最大的代价，也就是除去排过序的数以外的最大的和（这样才能求出最小代价），紧接着输出所有数字的和减去除去排过序的数以外最大的数字总和，剩下的就是最小的成本了！话不多说，上代码：
```
#include<bits/stdc++.h>
using namespace std;
int t,tt[1005];
int n;
long long a[105],s,sum;
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
	     scanf("%d",&n);
             for(int j=1;j<=n;j++)
	     {scanf("%d",&a[j]);sum+=a[j];}
	     for(int j=1;j<=n;j++)
	     {
	       for(int k=1;k<j;k++)
	       {
		   if(a[k]<=a[j])
		   tt[j]=max(tt[j],tt[k]);
	       }
		 tt[j]+=a[j];
		 if(tt[j]>s)s=tt[j];
             }
	  cout<<sum-s<<endl;
	  sum=0;
	  s=0;
	  memset(tt,0,sizeof(tt));
	}
   return 0;
}
```
//本人的宗旨就是：不写让人看不懂的题解，~~然而我还是写了~~好久没有发过题解了，管理员就让过了吧

---

## 作者：Leap_Frog (赞：2)

# P5414 [YNOI2019]排序（题解）
## Link.
[点我](https://www.luogu.org/problem/P5414)  
## PS.
这道题是从$\texttt{YGG}$的做题记录中偷来的![](https://upload.orzsiyuan.com/images/emotions/cy.png)  
我原来还想抢最优解的，结果抢了半天没抢到。我的通过率![](https://upload.orzsiyuan.com/images/emotions/dk.png)
## Problem.
给你一个序列，每次可以把一个元素从一个地方移动到另一个地方，代价为这个元素的大小。  
求最小的代价，使这个序列有序。  
## Solution.
**显然**，如果把一个元素放置两遍，那么答案肯定不是最优的。  
所以，每一个元素肯定是刚开始就放到答案位置去的。  
所以，就可以去求一个和最大的上升子序列。  
具体可以看[这位大佬的题解](https://www.luogu.org/blog/NakanoMiku/solution-p5414)  
## Coding
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;		//N是最大值
int n,t,a[N],sum,tot,dp[N];
int main()
{
	for(scanf("%d",&t);t--;)	//多组数据
	{
		scanf("%d",&n),sum=0,tot=0;		//读入以及初始化
		for(int i=1;i<=n;i++) scanf("%d",a+i),sum+=a[i],dp[i]=a[i];
		for(int i=1;i<=n;i++) for(int j=1;j<i;j++) if(a[i]>=a[j]) dp[i]=max(dp[i],dp[j]+a[i]);	//dp求和最大的上升子序列
		for(int i=1;i<=n;i++) tot=max(dp[i],tot);	//找最大值
		printf("%lld\n",sum-tot);	//输出结果，最小的代价
	}
	return 0;
}
```

---

## 作者：abandentsky (赞：2)

题解大同小异，总的来说就是求一个最大不下降子序列和。
为啥是这样子的呢？很简单啊，对于一个给定的序列，一部分是不需要移动的，这部分不需要移动的首先一定是单调不减的。剩下的就是需要移动的， 所以为了使剩下的和最小，就得使这部分不需要移动的值最大。所以就转化为最大不减子序列和。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 105
#define INF 0x3f3f3f3f
using namespace std;

int sum,num[MAXN],dp[MAXN];
int T,n;

int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&num[i]);
            sum+=num[i];
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<i;j++)
            {
                if(num[i]>=num[j])
                    dp[i]=max(dp[i],dp[j]);
            }
            dp[i]+=num[i];
        }
        int minn=INF;
        for(int i=1;i<=n;i++)
        {
            minn=min(minn,sum-dp[i]);
        }
        printf("%d\n",minn);
    }
    return 0;
}

```


---

## 作者：bingoyes (赞：1)

要最优？就要一步到位，不能做“马后炮”，走“回头路”。

因此将序列映射到一个假定最优序列，发现移动原序列等价于删除原序列元素，以便生成**最大不下降子序列**。

可线段树维护。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#define R(a,b,c) for(register int a = (b); a <= (c); ++a)
#define nR(a,b,c) for(register int a = (b); a >= (c); --a)
#define Fill(a,b) memset(a, b, sizeof(a))
#define Swap(a,b) ((a) ^= (b) ^= (a) ^= (b))
#define QWQ
#ifdef QWQ
#define D_e_Line printf("\n---------------\n")
#define D_e(x) cout << (#x) << " : " << x << "\n"
#define Pause() system("pause")
#define FileOpen() freopen("in.txt", "r", stdin)
#define FileSave() freopen("out.txt", "w", stdout)
#define TIME() fprintf(stderr, "\nTIME : %.3lfms\n", clock() * 1000.0 / CLOCKS_PER_SEC)
#else
#define D_e_Line ;
#define D_e(x) ;
#define Pause() ;
#define FileOpen() ;
#define FileSave() ;
#define TIME() ;
#endif
struct ios {
	template<typename ATP> inline ios& operator >> (ATP &x) {
		x = 0; int f = 1; char c;
		for(c = getchar(); c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
		while(c >= '0' && c <='9') x = x * 10 + (c ^ '0'), c = getchar();
		x *= f;
		return *this;
	}
}io;
using namespace std;
template<typename ATP> inline ATP Max(ATP a, ATP b) {
	return a > b ? a : b;
}
template<typename ATP> inline ATP Min(ATP a, ATP b) {
	return a < b ? a : b;
}
template<typename ATP> inline ATP Abs(ATP a) {
	return a < 0 ? -a : a;
}

const int N = 1e2 + 7;

int t[N << 2];
#define ls rt << 1
#define rs rt << 1 | 1
#define lson rt << 1, l, mid
#define rson rt << 1 | 1, mid + 1, r
inline void Pushup(int &rt) {
	t[rt] = Max(t[ls], t[rs]);
}
inline void Modify(int rt, int l, int r, int x, int w) {
	if(l == r){
		t[rt] = w;
		return;
	}
	int mid = (l + r) >> 1;
	if(x <= mid)
		Modify(lson, x, w);
	else
		Modify(rson, x, w);
	Pushup(rt);
}
inline int Query(int rt, int l, int r, int L, int R) {
	if(L <= l && r <= R) return t[rt];
	int mid = (l + r) >> 1, maxx = -1e9;
	if(L <= mid) maxx = Max(maxx, Query(lson, L, R));
	if(R > mid) maxx = Max(maxx, Query(rson, L, R));
	return maxx;
}
int f[N], a[N], b[N];
int main() {
	int Tasks;
	io >> Tasks;
	while(Tasks--){
		int n, sum = 0;
		io >> n;
		R(i,1,n){
			io >> a[i];
			b[i] = a[i];
			f[i] = 0;
			sum += a[i];
		}
		
		sort(b + 1, b + n + 1);
		int m = unique(b + 1, b+ n + 1) - b- 1;
		R(i,1,n){
			int x = lower_bound(b + 1, b + n + 1, a[i]) - b;
			
			Modify(1, 1, m, x, Query(1, 1, m, 1, x) + a[i]);
			
//			R(j,1,i - 1){
//				if(a[i] >= a[j]){
//					f[i] = Max(f[i], f[j]);
//				}
//			}
//			f[i] += a[i];
		}
		
//		int delta = 0;
//		R(i,1,n){
//			delta = Max(delta, f[i]);
//		}
//		
		printf("%d\n", sum - Query(1, 1, m, 1, m));
		
	}
	return 0;
}
```

---


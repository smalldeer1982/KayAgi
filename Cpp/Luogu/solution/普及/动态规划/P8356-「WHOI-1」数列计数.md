# 「WHOI-1」数列计数

## 题目背景

> 不再拥有，数列陪伴我。



## 题目描述

这种数列满足下面这一条神奇的性质：

- $a_0=0$。
- $\forall i\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。
- $\forall i\in[1,n],p \nmid a_i$。

求这样的 $\{a\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。

两个数列不同，当且仅当他们有一个下标存储的元素不同。

## 说明/提示

样例 #1：

这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。

样例 #2、#3：

本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。

---

**本题采用 $\texttt{Subtask}$ 计分方式，只有通过该 $\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**

| $\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $\sum n\leq20$ | 10 |
| 2 | $p\leq10^3$ | 30 |
| 3 | $xy,p$ 互质 | 10 |
| 4 | 无 | 50 |

对于所有测试数据，$1\leq T\leq10^3,1\leq\sum n\leq10^4, 1\leq x,y,p\leq10^9$，输入均为正整数。

## 样例 #1

### 输入

```
3
3 3 1 2
11 45 14 19
9876 10 114514 191981```

### 输出

```
2
1688
426554662
```

# 题解

## 作者：幸存者 (赞：20)

## 思路
一看到这题，就想到了 dp 的做法。

我们令 $dp_{i,j}$ 表示从 $a_0$ 到 $a_{i+j}$ 共有 $i$ 次 $+x$，$j$ 次 $+y$ 且满足题目条件的不同的数列的个数。

考虑每次 $+x$ 或 $+y$，不难列出状态转移方程 $dp_{i,j}=dp_{i,j-1}+dp_{i-1,j}$。但需要考虑一种特殊情况，当 $xi+yj\bmod p=0$ 时（即 $a_{i+j}\bmod p=0$），需要令 $dp_{i,j}=0$。

但是这样空间复杂度是 $O(n^2)$ 的，所以需要使用滚动数组，将第一维整体模 $2$ 即可。

注意：若 $x=y$，则只有一种可能的序列，直接判断数列 $a$ 是否符合要求即可。
## $\text{AC Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[2][10010];
const int mod = 1e9 + 7;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    while (t--)
    {
        int n, p, x, y, ans = 0;
        cin >> n >> p >> x >> y;
        if (x == y)
        {
            bool flag = false;
            for (int i = 1; i <= n; i++) if (1ll * i * x % p == 0)
            {
                flag = true;
                break;
            }
            cout << (flag ? 0 : 1) << endl;
            continue;
        }
        dp[0][0] = 1;
        for (int i = 0; i <= n; i++) for (int j = 0; i + j <= n; j++)
        {
            if (i == 0 && j == 0) continue;
            if ((1ll * i * x + 1ll * j * y) % p != 0)
            {
                if (i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
                else if (j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];
                else dp[i & 1][j] = (dp[i & 1 ^ 1][j] + dp[i & 1][j - 1]) % mod;
            }
            else dp[i & 1][j] = 0;
            if (i + j == n) ans = (ans + dp[i & 1][j]) % mod;
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：10)

官方题解

一道比较简单的题题。

## $\text{subtask 1}$

爆搜即可。

## $\text{subtask 2}$

定义 $f[i][j]$ 为 $a_i$ 模 $p$ 余 $j$ 的方案数。乱 dp 即可。

## $\text{subtask 3}$

我也不知道有没有用（）

## $\text{subtask 4}$

正解。

当 $x=y$ 时直接检验生成的 $\{a\}$ 是否合法。

当 $x\not = y$ 时，假设 $f[i][j]$ 表示 $a_{i+j}=xi+yj$ 的方案数。状态转移方程：

- $p|xi+yj,f[i][j]=0$。
- $p\nmid xi+yj,f[i][j]=f[i-1][j]+f[i][j-1]$。

时间复杂度 $O(n^2)$ 常数较小，可以通过本题。由于本题卡空间，所以需要用到滚动数组。



---

## 作者：紊莫 (赞：5)

## 视频题解
![](bilibili:BV1sa41197Fc)

## 思路

明显的，这题需要动态规划，根据题中所给的描述，不难得到状态如下：  
$dp_{i,j}$ 表示进行了 $i$ 次 $+x$ 和 $j$ 次 $+y$ 时的方案数。  

对此，可以列出方程如下（因为公式炸掉了所以换成图片）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/91im3awk.png)  

特别的，对于 $x=y$ 的情况，因为数列仅有一种可能，只需要判断是否有解即可。  

另外，我们可以得到当前的数字即为 $ix+jy$，如果这个数能被 $p$ 整除，那么就要归零。  

## 优化

按照上述思路朴素的写，空间复杂度是 $O(n^2)$ 的，明显会炸，于是再仔细审视方程，发现每一项至多和之前的一项有关，那么就可以自然的使用滚动数组的方法来求解了！  

变化不大，可见代码，读者仔细推算二进制不难。  

## 代码  

为不占篇幅，有需可自取。  

[$\texttt{WA Code（未加滚动数组）}$](https://www.luogu.com.cn/paste/6c0zqsw6)  

[$\texttt{AC Code}$](https://www.luogu.com.cn/paste/rid6uj3u)

---

## 作者：鲨齿渊虹 (赞：4)

第一次写题解，如有不好多多关照 。

## 思路 
先不思考优化的 dp。

考虑把 $a_{i+j}$ 化简为 $xi+yj$。

定义 $dp_{i,j}$（$i$ 和 $j$ 和上句话相同），状态来了：

当 $(xi+yj)\bmod p=0$ 时, $dp_{i,j}=0$；

当 $(xi+yj)\bmod p\neq0$ 时, $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

但注意如果 $x=y$ 时只有一种可能要进行特判，否则你就是 $0$ 分 ！！！
 
观察转移方程发现可用滚动数组，（因只和上个阶段有关），如果不用 60pts 到 90pts。

最后，记得开 long long。

# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch))f=ch!='-',ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?x:-x;
}
const int maxn=1e4+1;
const int mod=1e9+7;
int dp[2][maxn];
signed main(){
    int t,n,p,x,y;
    bool flag;
    t=read();
    long long ans=0;
	int sum;
    while(t--){
    	n=read();p=read();x=read();y=read();
    	if(x==y){
    	    flag=false;
    		for(int i=1;i<=n;i++){
    			if(x*i%p==0){
				   putchar('0');
				   putchar(10);
				   flag=true;
				   break;
    			}
    		}
    		if(!flag)putchar('1'),putchar(10);
    	}
    	else
    	{                              
    		ans=0;
			dp[0][0]=1;
    		for(int i=0;i<=n;i++){
    			for(int j=0;j<=n-i;j++){
    				if(i==0&&j==0)continue;
    				sum=((i%p)*(x%p)+(j%p)*(y%p))%p;//多次取模，防爆long long，
    				if(sum%p!=0){
    					if(i==0)dp[i&1][j]=dp[i&1][j-1];
    					else if(j==0)dp[i&1][j]=dp[i&1^1][j];
    					else dp[i&1][j]=(dp[i&1^1][j]%mod+dp[i&1][j-1]%mod)%mod;
    				}
    				else dp[i&1][j]=0;
    				if(i+j==n)ans=(ans%mod+dp[i&1][j]%mod)%mod;
    			}
    		}
			cout<<ans%mod<<endl;
    	}
    }
	return 0;
}       

---

## 作者：zhoujinrui (赞：3)

# 	前言

作者刚学动规，这是一道**计数动规好题**，借此题与大家一起学习一下。

# $Solution$

1. 整体思路：考虑动态规划（计数动规），有点像走楼梯。

1. 状态设计：$\mathit{dp}_{i,j}$ 表示考虑前 $i$ 个 $a$， 最后一个 $a$ 为 $j$，的合法数列个数。

1. 优化：考虑 $x,y≤10^9$，如果设 $j$，时间与空间开销大，因为每次可以加 $x$ 或 $y$，所以 $a_i=bx+cy\ (b+c=i)$，$x$ 与 $y$ 已知，故设 $b$、$c$ 与 $i$。

1. 再次优化：考虑关系式 $b+c=i$，即前 $i$ 个数有 $i$ 次操作，则可枚举 $i$、$b$ 和 $c$ 中任两个即可。

1. 重新设计状态：我们考虑设 $\mathit{dp}_{i,j}$，表示有 $i$ 次加 $x$ 的操作，有 $j$ 次加 $y$ 的操作，构成合法序列的方案数。

1. 边界：当 $i$ 与 $j$ 都为 $0$ 时，只有构成为空序列一种方案，即 $\mathit{dp}_{0,0}=1$。

1. 状态转移：
	- $i=0$，且满足题目第三条规则时。即不加 $x$，加 $j$ 次 $y$，则当前只能加一次 $y$，由子问题 $\mathit{dp}_{i(0),j-1}$ 推出。
	- $j=0$，且满足题目第三条规则时。即不加 $y$，加 $i$ 次 $x$，则当前只能加一次 $x$，由子问题 $\mathit{dp}_{i-1,j(0)}$ 推出。
	- $i$ 与 $j$ 都不等于 $0$，同样满足题目第三条规则。考虑当前可加一次 $x$，方案为 $\mathit{dp}_{i-1,j}$；当前加一次 $y$，方案为 $\mathit{dp}_{i,j-1}$。即 $\mathit{dp}_{i,j}=\mathit{dp}_{i-1,j}+\mathit{dp}_{i,j-1}$。
	- 不满足题目第三条规则，没有方案，$\mathit{dp}_{i,j}=0$。
    
1. 特殊情况：如果 $x=y$，那么每次只有一种选择，如果满足第三条规则，则方案即为一（且唯一），反之为 $0$。

1. MLE 的话要用滚动数组优化，状态转移的第一维满足只保存 $i$ 与 $i-1$ 两种情况。
# $code$


```cpp
#include <bits/stdc++.h>

#define LL long long 

using namespace std;

const int MAXN = 1e4 + 5;
const int mod = 1e9 + 7;

int T; 

LL dp[2][MAXN];

int main() {
    scanf("%d", &T);
    while(T--) {
    	int n, p, x, y;
    	scanf("%d%d%d%d", &n, &p, &x, &y);
    	if(x == y) {
    		bool op = 1;
    		for(int i = 1; i <= n; ++i) {
    			if(1LL * i * x % p == 0){
    				op = 0;
    				break;
				}
			}
			printf("%d\n", op ? 1 : 0);
		}
		else {
			LL ans = 0;
			dp[0][0] = 1;
			for(int i = 0; i <= n; ++i) {
				for(int j = 0; i + j <= n; ++j) {
					if(i == 0 && j == 0)continue;
					if((1LL * i * x + 1LL * j * y) % p){
						if(i == 0) dp[0][j] = dp[0][j - 1];//加j次y，不加x，则当前只能加一次y，由子问题dp[i(0)][j-1]推出
						else if(j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];//加i次x，不加y，则当前只能加一次x，由子问题dp[i-1][j(0)]推出
						else dp[i & 1][j] = (dp[i & 1][j - 1] + dp[i & 1 ^ 1][j]) % mod;//考虑当前可加一次x，方案为dp[i-1][j]；当前加一次y，方案为dp[i][j-1]
					}
					else dp[i & 1][j] = 0;//不符合第三条规则，没有方案
					if(i + j == n) ans = (ans + dp[i & 1][j]) % mod;//i与j的和刚好为n即共加了n次，加入答案
				}
			}
			printf("%lld\n", ans);
		}
	}
    return 0;
}
```



---

## 作者：TempestJueMu (赞：3)

注意到 $x=y$ 时可以直接判掉。先写再说~~虽然骗不了分~~。
```cpp
if(x==y)
{
    fo(i,1,n)if(i*x%p==0){printf("0\n");return;}
    printf("1\n");return;
}
```

考虑 dp 。

用 $e_{i,j}$ 表示 $xi+yj$ 的方案数，容易看出：

$$
e_{i,j}=
\begin{cases}
0 , p \mid xi+jy\\
e_{i,j-1} , i=0\\
e_{i-1,j} , j=0\\
e_{i,j-1}+e_{i-1,j} , otherwise
\end{cases}
$$

起始条件是 $e_{0,0}=1$ 。

注意到 $1 \leq \Sigma n \leq 10^4$ 。

直接开`e[10001][10001]`显然是会 MLE 的。故需要用滚动数组。


**Code**
```cpp
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define ll long long
const int mod=1000000007;
int n,p,x,y;
int e[2][10010];
void work()
{
	if(x==y)
    {
        fo(i,1,n)if(i*x%p==0){printf("0\n");return;}
        printf("1\n");return;
    }
	
	e[0][0]=1;
	ll ans=0;
    fo(i,0,n)
        fo(j,0,n-i)
        {
            if(i==0&&j==0)continue;
            int num=i*x%p+j*y%p;
            if(num%p!=0)
            {
            	if(i==0)e[i&1][j]=e[i&1][j-1];
            	else if(j==0)e[i&1][j]=e[i&1^1][j];
            	else e[i&1][j]=(e[i&1^1][j]+e[i&1][j-1])%mod;
			}
			else e[i&1][j]=0;
			if(i+j==n)ans=(ans+e[i&1][j])%mod;
        }
    printf("%lld\n",ans%mod);
}
```

---

## 作者：xiaohaoaibiancheng66 (赞：3)

# 思路
首先这道题可以用爆搜，10分[TLE](https://www.luogu.com.cn/record/75808978)。

那么我们就要优化一下。优化递归（爆搜）的方法就是**递归转递推**！！！

我们再来回顾一下题目：

> $∀i∈[1,n]$ 均有 $ a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。

这就相当于：$a$ 序列中的每个数，都为 $ix+jy$！

所以我们就可以用一个二维数组 $dp$，其中 $dp_{ij}$ 表示 $ \{a\}^{i+j}_ 0$ 的种数。则状态转移方程如下：

 $$ dp_{ij}=dp_{i-1,j}+dp_{i,j-1} $$
其中，若 $ix + jy \bmod p=0$，$dp_{ij}=0$。

如果 $x=y$ 直接判断最终序列即可。

但本题卡内存，需要用到**滚动数组**。
# $AC code$
```cpp
#include<bits/stdc++.h>
using namespace std;

long long a[10030];

void data()
{
	long long n,p,x,y;
	cin>>n>>p>>x>>y;
	if(x==y)
	{
		for(int i=1;i<=n;i++)
			if(x*i%p==0)
			{
				cout<<"0\n";
				return;
			}
		cout<<"1\n";
		return;
	}
	x%=p;y%=p;
//	cout<<x<<' '<<y<<endl;
	a[0]=1;
	long long ans=0;
	
	for(int i=1;i<=n;i++)
	{
		if((i*y)%p!=0)a[i]=a[i-1];
		else a[i]=0;
	}
	for(int i=1;i<=n;i++)
		for(int j=0;i+j<=n;j++)
		{
			if((i*x+j*y)%p==0)
			{
				a[j]=0;
				continue;
			}
			if(j>0)a[j]+=a[j-1];
			a[j]%=1000000007;
		}
//	for(int i=0;i<=n;i++)
//	{
//		for(int j=0;i+j<=n;j++)cout<<a[i][j]<<' ';
//		cout<<endl;
//	}
	for(int i=0;i<=n;i++)
	{
		ans+=a[i];
		ans%=1000000007;
	//	cout<<ans<<endl;
	}
	cout<<ans<<endl;
}

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		data();
	}
	return 0;
}
```
### 提交记录
2022/5/19:提交第一版。

2022/5/20:修改了一些  $LATEX$。

2022/5/23:修改了错误的式子。

2022/5/24:修改了一些  $LATEX$。

---

## 作者：Tzs_yousa (赞：2)

这篇题解比较面向初学者，有点啰嗦，不严谨之处希望大佬指出

首先特别鸣谢 [lsy_41](https://www.luogu.com.cn/user/315252) 同志指出了我的错误。

所以我主要是想讲一下状态转移方程的维度设计和特判的易错点（也就是我错的地方）。

### 状态转移
首先注意到数据范围，我们发现 $n^2$ 可以过的，
但是数组存不下，在这种情况下会选择用滚动数组，（这里先讲滚的方法，再讲为什么能滚），所以我们设计 $dp_{ij}$ 数组表示当前走 $i$ 个 $x$ 和 $j$ 个 $y$ 的情况总数，滚动数组可以将其中一维滚掉， $i$ 和 $j$ 都可以， 然后这里选择把第一维 $i$ 滚掉。

具体怎么滚，就是我们枚举 $i$ ，每次枚举一个 $i$ 都让它和1按位与，那这个数要么是1要么是0，如果是1，那么上一次就是0，如果是0，上一次就是1。

接下来解释为什么可以滚，也就是状态怎么转移。

我们发现每一步都是由前一步移动一次 $x$ 或者 $y$ 得来，所以我们只需要存前一次的状态。然后就可以设计出状态转移方程。

```cpp
if((i * x + j * y) % p)
{
	if(i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
	else if(j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];//两者有一个走了零步就要特判，因为状态转移方程对这两个不适用 
	else dp[i & 1][j] = (dp[i & 1][j - 1] + dp[i & 1 ^ 1][j]) % mod;
}
```
### 特判易错
刚开始是我的第一份特判，错的很惨。
```cpp
if(x == y)
{
	if(x % p == 0 || p % x == 0) printf("0\n");
	else printf("1\n");
	continue;
}
```
这份是错在了如果我们枚举 $i$， $i$ 和 $x$ 的乘积也可能会导致模为0的情况，其实这个是很蠢的错误，不知道会不会有人也这么错额。

然后第二份就比较典型了（我感觉）。

```cpp
if(x == y)
{
	int i;
	for (i = 1; i <= n; i++) 
	{
		if(i * x % p == 0)
		{
			break;
		}
	}
	if(i * x % p == 0) 				printf("0\n");
	else printf("1\n");
	continue;
}
```
这份错的比较离谱，当我们 $i$ 枚举到 $n$ ，然后都不能整除，它会继续枚举到 $n + 1$, 然后再判，如果恰好整除了，那就会输出0，而结果是1，这种细节想必都很清楚，但是又容易忽略。（再次鸣谢 [lsy_41](https://www.luogu.com.cn/user/315252) 同志）
。

然后就是初始化， $i$ 和 $j$ 都为0时，定义为1，不然转移完都是0啊，也可以考虑实际意义，啥也不走不也是一种情况嘛，那不就是1嘛。

## code
```cpp
#include <bits/stdc++.h>
#define int long long
const int mod = 1e9 + 7;
using namespace std;
int t, n, p, x, y, dp[3][10001], ans;
signed main()
{
	scanf("%lld", &t);
	while(t--)
	{
		ans = 0;
		scanf("%lld%lld%lld%lld", &n, &p, &x, &y);
		if(x == y)
		{
			int i;
			for (i = 1; i <= n; i++) 
			{
				if(i * x % p == 0)
				{
					break;
				}
			}
			if(i * x % p == 0 && i != n + 1) printf("0\n");
			else printf("1\n");
			continue;
		}
		dp[0][0] = 1;
		for (int i = 0; i <= n; i++)
		{
			for (int j = 0; i + j <= n; j++)
			{
				if(i == 0 && j == 0) continue; //记得跳过，不然就白定义dp[0][0] = 1了 
				if((i * x + j * y) % p)
				{
					if(i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
					else if(j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];//两者有一个走了零步就要特判，因为状态转移方程对这两个不适用 
					else dp[i & 1][j] = (dp[i & 1][j - 1] + dp[i & 1 ^ 1][j]) % mod;
				}
				else dp[i & 1][j] = 0;
				if(i + j == n) (ans += dp[i & 1][j]) %= mod;
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```
完结撒花！

---

## 作者：V1mnkE (赞：2)

## 思路
可以采用 dp 的做法，令 $f_{i,j}$ 表示长度为 $i+j$ 且有 $i$ 次 $+x$，$j$ 次 $+y$ 的满足题目条件的不同序列的个数，经过推导，可以得到：
$$f_{i,j}=f_{i-1,j}+f_{i,j-1}$$

当然，当 $a_{i+j} \bmod p=0$ 时，需令 $f_{i,j}=0$。

注意：
- $x=y$ 时可能的序列只有一种，直接判断是否符合要求即可。
- 直接开 ``f[10001][10001]``会爆空间，将第一维整体模 $2$ 使用滚动数组即可，因为每个状态只会用到它的上一个状态。

## $code$
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[2][10010];
const int mod=1e9+7;
int main(){
    ios::sync_with_stdio(0);
    int t;
    cin>>t;
    while (t--){
        int n,p,x,y,ans=0;
        cin>>n>>p>>x>>y;
        if (x==y){
            bool flag=0;
            for (int i=1;i<=n;i++)
				if(1ll*i*x%p==0){
	                flag=1;
	                break;
	            }
            cout<<(flag?0:1)<<endl;
            continue;
        }
        f[0][0]=1;
        for (int i=0;i<=n;i++)for(int j=0;i+j<=n;j++){
            if (i==0&&j==0)continue;
            if ((1ll*i*x+1ll*j*y)%p!=0){
                if(i==0)f[i%2][j]=f[i%2][j-1];
                else if (j==0)f[i%2][j]=f[!(i%2)][j];
                else f[i%2][j]=(f[!(i%2)][j]+f[i%2][j-1])%mod;
            }
            else f[i%2][j]=0;
            if(i+j==n)ans=(ans+f[i%2][j])%mod;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：tian_jun_cheng (赞：1)

有很多部分分，可以分段考虑。

## 1. $ \sum { n }  \le 20 $
 
暴力搜索，每一次选择 $ + x $ 还是 $ + y $ 。

## 2. $ p \le 10 ^ 3 $ 

令 $ f [ i ] [ j ] $ 为$ a [ i ] $ 模 $ p $ 为 $ j $ 的方案数。

$ f [ i ] [ j ] = f [ i- 1 ] [ ( j + p -x )  \mod  p ] + f [ i - 1 ] [ ( j+ p - y )  \mod p ] $ ，其中，$ j   > 0 $。

前提是： $ f [ i ] [ 0 ] = 0 ( 0  \le i \le n ) $ 。

最后的答案是： $ \sum _ { j = 1 } ^ { p - 1 } f [ n ] [ j ] $ 。 

## 3. $ x y , p $ 互质

我们可以得出：

 $ x , y $ 分别与 $ p $ 互质，这样的话， $ p $ 的倍数出现的次数变少，会更快一点。

## 4.没有性质

令 $ f [ i ] [ j ] $ 表示前 $ i $ 步加了 $ j $ 个 $ x $ ，加了 $ i - j $ 次 $ y $ 的方案。

我们知道， $ a [ i ] = ( j   \times x + ( i - j ) )  \mod p $ 。 

所以，$ f [ i ] [ j ] = f [ i - 1 ] [ j - 1 ] + f [ i - 1 ] [ j ] $ ，其中, $ ( ( j  \times x + ( i - j ) )  \mod p \ne 0 $ 。

边界条件： $ f [ i ] [ j ] = 0 $，其中, $ (( j  \times   x + ( i -j ) ) \mod  p \ne 0 $ ，但是 $ f [ 0 ] [  0 ] =  1 $ 。

答案： $ \sum _ { j = 0 } ^ { n } f [ n ] [ j ] $ 。

---

## 作者：nullqtr_pwp (赞：1)

# P8356 Solution
滚动数组与动态规划入门题

首先看到如果 $x=y$，那么如果符合条件（满足任意 $i\in[1,n]$ 都**不**满足 $p | xi$），直接输出 $1$（显然，有且仅有一种方案）

显然根据题意，每一个 $a_i$ 都可以表示成若干个 $x$ 与若干个 $y$ 的和。不妨让 $a_i=xk_1+yk_2$，$k_1,k_2$ 是 $x$ 和 $y$ 的个数，那么显然地，$i=k_1+k_2$

所以推得 $a_{k_1+k_2}=xk_1+yk_2$，都有这个递推式了，去想动态规划。由于它问的是方案数，所以不妨设计状态为：$f_{i+j}=xi+yj$ 的方案数。那么状态转移方程即：$f_{i,j}=f_{i-1,j}+f_{i,j-1}$，代码过程注意取模。注意到题目中的任意一个数都不整除 $p$，所以对于不符合要求的 $f_{i,j}$ （即 $xi+yj\equiv0 \mod p$）需要赋值成 $0$。

**动态规划一定要注意边界条件：特别且显然地，$f_{0,0}=0$**

数据范围 $10^4$，时空复杂度都是 $O(n^2)$，符合时间复杂度，但是空间就爆了。**解决方案：滚动数组**，小小的科普一下滚动数组：**核心思想就是把没用的内存给滚掉**，在本题的状态转移中，显然，内存中只需要保留前一组。比如你的状态转移代码原来是这样的：
```cpp
f[i][j]=f[i-1][j]+f[i][j-1];
```
而显然 $f_{a,b}(a\le i-2,b\le i-2)$ 的内存就是没用的了，不妨全部按奇数和偶数来保存（利用位运算（按位与） ```i&1``` 表示奇偶，若这个值等于 $1$，它就是奇数，若这个值等于 $0$，它就是偶数），代码就变成这样了：
```cpp
f[i&1][j]=f[(i-1)&1][j]+f[i&1][j-1];
```
这样数组的大小就变成了：```f[2][10005]```

代码实现注意一下取模即可。

---

## 作者：DBL_MAX (赞：0)

# 题目
[题目传送门](https://www.luogu.com.cn/problem/P8356)
# 思路
这是一道计数动规题。本人考虑把 $a_{i,j}$ 变成 $x_i+y_j$。

定义 $dp_{i,j}$（$i$，$j$ 同上），可以推出状态转移方程：
* 当 $(x_i+y_j)\bmod 2 = 0$ 时，$dp_{i,j}=0$；
* 当 $(x_i+y_j)\bmod 2 \not = 0$ 时，$dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

*************
注意 $x=y$ 时要特判，不然会**爆零**！

# 代码
注意开 `long long`，可以用 `typedef`。
```cpp
//代码较长，不加注释了，相信诸位大佬可以理解。
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const int mod = 1e9 + 7;
int T;
ll dp[2][N], ans;
int main() {
	scanf("%d", &T);
	while (T--) {
		int n, p, x, y;
		scanf("%d%d%d%d", &n, &p, &x, &y);
		if (x == y) {
			bool op = 1;
			for (int i = 1; i <= n; ++i) {
				if (1ll * i * x % p == 0) {
					op = 0;
					break;
				}
			}
			printf("%d\n", op ? 1 : 0);
		} else {
			ans = 0;
			dp[0][0] = 1;
			for (int i = 0; i <= n; ++i) {
				for (int j = 0; i + j <= n; ++j) {
					if (i == 0 && j == 0)
						continue;
					if ((1ll * i * x + 1ll * j * y) % p) {
						if (i == 0)
							dp[0][j] = dp[0][j - 1];
						else if (j == 0)
							dp[i & 1][j] = dp[i & 1 ^ 1][j];
						else
							dp[i & 1][j] = (dp[i & 1][j - 1] + dp[i & 1 ^ 1][j]) % mod;
					} else
						dp[i & 1][j] = 0;
					if (i + j == n)
						ans = (ans + dp[i & 1][j]) % mod;
				}
			}
			printf("%lld\n", ans);
		}
	}
	return 0;
}
```
祝大家愉快的 AC 本题！

拜拜！

---


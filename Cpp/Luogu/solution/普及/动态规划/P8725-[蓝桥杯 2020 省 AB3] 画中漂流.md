# [蓝桥杯 2020 省 AB3] 画中漂流

## 题目描述

在梦境中，你踏上了一只木䇝，在江上漂流。

根据对当地的了解，你知道在你下游 $D$ 米处有一个峡谷，如果你向下游前进大于等于 $D$ 米则必死无疑。

现在你打响了急救电话，$T$ 秒后救援队会到达并将你救上岸。水流速度是 $1 \mathrm{~m} / \mathrm{s}$，你现在有 $M$ 点体力。每消耗一点体力，你可以划一秒桨使船向上游前 进 $1 \mathrm{~m}$，否则会向下游前进 $1 \mathrm{~m}$ (水流)。$M$ 点体力需在救援队赶来前花光。因为江面太宽了，凭借你自己的力量不可能上岸。

请问，有多少种划桨的方案可以让你得救。

两个划桨方案不同是指：存在某一秒钟，一个方案划桨，另一个方案不划。

## 说明/提示

对于 $50 \%$ 的评测用例，$1 \leq T \leq 350$。

对于所有评测用例，$1 \leq T \leq 3000,1 \leq D \leq T，1 \leq M \leq 1500$。

蓝桥杯 2020 第三轮省赛 AB 组 I 题。

## 样例 #1

### 输入

```
1 6 3```

### 输出

```
5```

# 题解

## 作者：FutureSnow (赞：18)

[题目传送门](https://www.luogu.com.cn/problem/P8725)

比较明显的 DP。

设 $f_{i, j}$，表示时间为 $i$，体力为 $j$ 的方案数。

于是我们枚举时间和体力转移。我们通过时间和体力算出距离，用了多少体力就向上游了多少。设原始距离为 $d$ 当前时间为 $i$ 当前剩余体力 $j$， 则向上游长度为 $m - j$，向下漂流长度为 $i - (m - j)$，当前位置为 $d + (m - j) - (i - (m - j))$。

如果当前状态所在位置 $ > 0$，则可以转移。不难推出

$$f_{i, j} = f_{i - 1, j} + f_{i - 1, j + 1}$$

两种决策分别表示不用体力和用体力。

计算时别忘了取模。

```cpp


#include <bits/stdc++.h> 

using namespace std;

const int mod = 1e9 + 7;
int f[3030][3030];
int d, t, m;
int main(){
    cin >> d >> t >> m;
    f[0][m] = 1;
    for (int i = 1; i <= t; ++i) {
        for (int j = 0; j <= m; ++j) {
            int len = d + (m - j) - (i - (m - j));
            if (len > 0) {
                f[i][j] = (f[i - 1][j] + f[i - 1][j + 1]) % mod;
            }
        }
    }
    cout << f[t][0] << endl;
    return 0;
}
```


---

## 作者：xiaoxiaoxia (赞：14)

#### Part 1 思路
  首先，这道题是一道动态规划的简单题目，我们可以用三个步骤来解决这类动态规划题目，主要听思路，思路懂了其他题都可以类推。
#### 定义数组元素含义
  其实这道题比较简单，大多数动态规划就是问什么设什么，这道题就可以设
  $dp i,j$ 为第 $i$ 个时间单位，还剩 $j$ 个体力的总方案数，读题目发现最终一定要体力全部用完，所以 $t,0$ 就是最终答案。
####  找数组与元素之间的关系式
  那以这道题为例，这个人可以在这个时间点耗费一点体力划船，或者不划船，所以动态转移方程式就是
  ``` 
dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%mod;
```
#### 找出初始值
  根据我们的定义数组的含义不难看出 $0 ,m$ 等于 $1$。其实只要数组的含义不同初始化和转移方程就可能会不同，只要自圆其说即可。
#### 总结
  那这三步就是做动态规划的三步，只要每一步都做到了，就可以过掉所有动态规划题目，只是有些题目在某一个部分会加强难度，例如数组很难定义或者关系式很难推导，那就需要另外思考了。
#### Part 2 代码
```cpp
#include<bits/stdc++.h>
const int mod=1e9+7;
using namespace std;
int t, d, m, dp[3005][1505];
int main()
{
	cin>>d>>t>>m;
	dp[0][m]=1;//初始化
	for(int i=1;i<=t;i++)
	{
		for(int j=0;j<=m;j++)
		{
			int shenxia=m-j;//剩下的体力
			if(d-i+shenxia*2<=0)//特殊判断，不管怎样都死掉了
			{
				continue;	
			}
			dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%mod;//转移式
		}	
	}	
	cout<<dp[t][0]<<endl;
} 
```


---

## 作者：sheep_ly (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P8725)

### [思路分析]
此题是一道简单的线性 $\verb!dp!$。

可以用 $ O(tm) $ 的时间复杂度解决。

将用体力和不用体力的方案数加起来即可。

### [注意事项]
1. 在状态转移前特判死了没有。

2. 方案数很大，别忘了取模。

### [贴上代码]

```cpp
#include<bits/stdc++.h> 
using namespace std;
int d,t,m;
int f[3010][1510];
int main()
{
	cin>>d>>t>>m;
	f[0][m]=1;
	for(int i=1;i<=t;i++)
		for(int j=0;j<=m;j++)
		{
			if((m-j)-(i-(m-j))+d)//特判死了没有，但是数据很水，不加也能过。
			    f[i][j]=(f[i-1][j]+f[i-1][j+1])%1000000007;//记得取模
		}
	cout<<f[t][0];
	
	return 0;
}

```
因为所用状态极少，可以用滚动数组进行优化：

```cpp
#include<bits/stdc++.h> 
using namespace std;
int d,t,m;
int f[1510];
int main()
{
	cin>>d>>t>>m;
	f[m]=1;
	for(int i=1;i<=t;i++)
		for(int j=0;j<=m;j++)
		{
			if(d+(m-j)-(i-(m-j)))
  				f[j]=(f[j]+f[j+1])%1000000007;
		}
	cout<<f[0];
	
	return 0;
}
```



---

## 作者：Dehydration (赞：4)

### 前言：

挺水的一道 dp 题目，最近老师在复习 dp,就来写一篇题解来复习一下吧。

ps：[题目](https://www.luogu.com.cn/problem/P8725)。

### 思路：

老师重新强调了三步法：

### \#1：

定义数组。

我们怎么定义数组呢？老师说过数组的值最好是答案，就把数组的值设为方案数，但还有体力和时间两个变量不好消掉，就看数据，明显可以用二维数组，这数组的定义就简单出来了！

$dp_{i,j}$ 是第 $i$ 个时间单位，**还剩** $j$ 个体力的总方案数，注意到题目中要我们求**用完所有体力**达到救援的方案数，显然是 $dp_{t,0}$，因为 $dp_{t,0}$ 表示在 $t$ 个时间单位**没有剩余体力**的方案总数，符合题目条件。


### \#2：

设置状态转移方程。

这道题目的状态转移方程较为好想，就是：

$dp_{i,j}=dp_{i-1,j}+dp_{i-1,j+1}$。

解释一下，其中我们直到到达 $dp_{i,j}$ 这种状态方法只有两种：一种是划船，消耗一个体力；一种是不划船，不消耗体力。将这两种加起来即可。

$dp_{i-1,j}$ 是前一个时间点，体力不变的情况，位不划船总数。

$dp_{i-1,j+1}$ 是前一个时间点，体力比现在多一个的情况，显然消耗了一个体力，为划船情况。

### \#3：

初始化那些不在状态转移方程内的东西。

我们把所有数组先圈定义成 $0$，这是没有方案。

还有 $dp_{0,m}$ 是包含不进去，需要先初始化为 $1$，$1$ 的值显然。

---
现在基本上做完了，但还有些需要注意：

1. 小心直接死了，需要在状态转移前判断活着没有。

2. 不要忘记取模。

### 代码：

```
#include<bits/stdc++.h>
const int Mod=1e9+7;
using namespace std;
int d,t,m,dp[3005][1501];
int main()
{
	cin.tie(0);cout.tie(0);
	cin>>d>>t>>m;//输入啦 
	dp[0][m]=1;
	for(int i=1;i<=t;i++)
	{
		for(int j=0;j<=m;j++)
		{
			int Xia=(m-j);
			if(d-i+Xia*2<=0)continue;//特判死掉了，continue 
			dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%Mod;//状态转移 
		}
	}
	cout<<dp[t][0]<<'\n';//结束！ 
}
```

完美撒花！

---

## 作者：卷王 (赞：3)

## 题目大意 
[传送门](https://www.luogu.com.cn/problem/P8725)
## 思路
考虑使用时空复杂度为 $O(tm)$ 来解决这题。

设 $dp_{i, j}$ 表示在第 $i$ 秒体力为 $j$ 时的方案数。


每次转移分为两种情况：
* 划桨：$dp_{i-1,j+1}$。 
* 不划桨：$dp_{i-1,j}$。  

于是转移方程为 $dp_{i,j}=dp_{i-1,j+1}+dp_{i-1,j}$。 

然后判断一下是否还活着即可。 

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define mod 1000000007
int d, t, m;
int dp[3007][1507]; //dp[i][j] 表示在第 i 秒体力为 j 的方案数 
int main() {
	cin >> d >> t >> m;
	dp[0][m] = 1;
	for(int i = 1; i <= t; i++)
		for(int j = 0; j <= m; j++)
			if(d - i + 2 * (m - j) > 0)
				dp[i][j] = (dp[i - 1][j] + dp[i - 1][j + 1]) % mod;
	cout << dp[t][0]; //题目说必须把 m 点体力花光，所以为 0 
	return 0;
}
```

---

## 作者：Chis725 (赞：2)

## 题目描述

你下游 $d$ 米处是峡谷，你的体力是 $m$，每向前划一米就要耗费一点体力，水速是一米每秒，你要保证在 $t$ 秒内你要花完所有体力，并且不能掉入峡谷，求方案个数。

## 思路

这道题明显是一道动态规划的题。我们先设 $f_{i,j}$ 为时间过去了 $i$ 秒，体力还剩 $j$ 点的方案个数。当前消耗了 $m-j$ 点体力，所以向上划了 $m-j$ 米，然后我们可以算出总共往后退了 $i-m+j$ 米，那我们还离峡谷还有 $d+(m-j)-(i-m+j)$，即 $d+2\times m- 2\times j-i$ 米。当 $d+2\times m- 2\times j-i>0$，说明没有掉进峡谷。同时状态转移方程是 $f_{i,j}=f_{i-1,j+1}+f_{i-1,j}$，分别代表消耗体力和不消耗体力两种情况。

## 代码献上

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
const int mod=1e9+7;
int d,t,m,f[3001][3001];
signed main(){
    cin>>d>>t>>m;
    f[0][m]=1;//初始化
    for(int i=1;i<=t;i++){
        for(int j=0;j<=m;j++) {
            int a=d+2*m-2*j-i;//与峡谷的距离
            if(a>0)f[i][j]=(f[i-1][j]+f[i-1][j+1])%mod;//没有掉进峡谷
        }
    }
    cout<<f[t][0]<<endl;
    return 0;
}
```


---

## 作者：封禁用户 (赞：2)

### 思路

此题可以用记忆化搜索来解决。

用 $mem[t][m]$ 表示救援时间为 $t$ 时，且剩余体力为 $m$ 的情况是否搜过，并存储答案。

然后，我们可以如下递归：

当还有体力时，就花费一点体力去划船；

当距离峡谷还有距离时，就停止一次，距离减一。

将上面两个递归条件加起来，即可求得最终方案。

### 代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int ans,d,t,m,mem[3010][1510],mod=1e9+7;
int dfs(int t,int m,int d)               
{
    if(mem[t][m]!=-1) return mem[t][m];		//如果搜过，直接调用答案。 
    if(t==0)
    {
        if(m!=0) return 0;
        return mem[0][0]=1;
    }    
    mem[t][m]=0;
    if(m>0) mem[t][m]=(mem[t][m]+dfs(t-1,m-1,d+1))%(mod);	//条件一。 
    if(d>1) mem[t][m]=(mem[t][m]+dfs(t-1,m,d-1))%(mod);	//条件二。 
    return mem[t][m];
}
int main()
{
    memset(mem, -1, sizeof mem);	//初始化 
    cin>>d>>t>>m;
    cout<<dfs(t,m,d)<<endl;
    return 0;
}

```


---

## 作者：ryf_loser (赞：1)

此题简单线性 dp……

只要明确状态即可。

我们定义 $dp_{i,j}$ 代表在第 $i$ 个时间 还有 $j$ 个体力的方案总数。

接下来状态转移就比较简单了，我们时间 $i$ 从 1 开始枚举，体力 $j$ 每次都从 0 开始枚举，因为根据题，我们既可以消耗一个体力向上一米，也可以不消耗体力向下一米，故可以推出状态转移式：

$dp_{i,j}\leftarrow dp_{i-1,j}+dp_{i-1,j+1}$

当然考虑到如果掉如下峡谷则舍，故在 $dp_{i,j}$ 时，最大向上游前进 $m-j$，向下游 $i-(m-i)$ 米，当两个相减 $>0$ 时，即可继续枚举。

AC CODE


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int in(){
	int x=0,f=1;char c;
	c=getchar();
	while (c<'0'||c>'9'){
		if (c=='-')f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
const int mod=1000000007;
int d,t,m,dp[3005][1505];
int main(){
	d=in(),t=in(),m=in();
	dp[0][m]=1;
	for (int i=1;i<=t;i++)
		for (int j=0;j<=m;j++)
			if (d+(m<<1)>(j<<1)+i)dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%mod;//状态转移+判断。
	printf ("%d",dp[t][0]);
	return 0;
}

```


---

## 作者：zhouzihe (赞：0)

## 1 分析题目
不难~~从标签~~看出，这是一道 dp 题。 

我们设 $f_{i,j}$ 为第 $i$ 秒还剩 $j$ 点体力的方案数，答案即为 $f_{t,0}$。
## 2 转移方程
第 $i$ 秒还剩 $j$ 点体力的方案数可以由第 $i-1$ 秒还剩 $j$ 点体力和第 $i-1$ 秒还剩 $j+1$ 点体力转移过来，转移方程为 $f_{i,j}=f_{i-1,j}+f_{i-1,j+1}$。  

边界为 $f_{0,m}=1$。  

别忘了对 $10^9+7$ 取模。
### 注意：只有未掉进峡谷时才可以转移
那么如何判断是否掉进了峡谷呢？我们设 $d$ 为初始时离峡谷的距离，现在的时间为 $i$，现在的体力为 $j$，现在离峡谷还有 $sum$ 的距离，那么现在往上游的距离为 $m-j$，水使你往下游的距离为 $i-(m-j)$，$sum=d+(m-j)-(i-(m-j))$，若 $sum>0$ 就未掉进峡谷。
## 3 code
```cpp
#include<bits/stdc++.h>
using namespace std;
int d,t,m,f[3005][1505],mod=1e9+7,sum;
int main(){
	cin>>d>>t>>m;
	f[0][m]=1;
	for(int i=1;i<=t;i++){
		for(int j=0;j<=m;j++){
			sum=d+(m-j)-(i-(m-j));
			if(sum>0){
				f[i][j]=(f[i-1][j]+f[i-1][j+1])%mod;
			}
		}
	}
	cout<<f[t][0];
	return 0;
} 
```


---


# 「UOI-R1」求和

## 题目描述

给定 $n$ 个区间 $p_i, q_i$。

求$\sum\limits_{s_1={p_1}}^{q_1}\sum\limits_{s_2={p_2}}^{q_2}\sum\limits_{s_3={p_3}}^{q_3} \cdots\sum\limits_{s_n={p_n}}^{q_n}\max\limits_{i=1}^ns_i$ 对 $998244353$ 取余的值。

## 说明/提示

### 样例解释

取 $s = \{1, 2\}, \max\limits_{i=1}^ns_i=2$。

取 $s = \{2, 2\}, \max\limits_{i=1}^ns_i = 2$。

取 $s = \{3, 2\}, \max\limits_{i=1}^ns_i = 3$。

取 $s = \{4, 2\}, \max\limits_{i=1}^ns_i= 4$。

取 $s = \{1, 3\}, \max\limits_{i=1}^ns_i=3$。

取 $s = \{2, 3\}, \max\limits_{i=1}^ns_i = 3$。

取 $s = \{3, 3\}, \max\limits_{i=1}^ns_i = 3$。

取 $s = \{4, 3\}, \max\limits_{i=1}^ns_i= 4$。

$2+2+3+4+3+3+3+4 = 24$。

### 数据范围

对于 $30\%$ 的数据，保证 $n \leq 8$，$p_i, q_i \leq 10$。

对于 $100\%$ 的数据，保证 $1 \leq n \leq 5 \times 10^3$，$1 \leq p_i \leq q_i \leq 5 \times 10^3$。有区间可能相同。


## 样例 #1

### 输入

```
2
1 4
2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
见文件附件的 sum2.in```

### 输出

```
见文件附件的 sum2.ans```

# 题解

## 作者：cosf (赞：4)

[P8894 求和](https://www.luogu.com.cn/problem/P8894)
---

根据题意，我们可以发现每一个

$$
\max_{\mathclap{i=1}}^{\mathclap{n}}s_i
$$

的值一定在 $\max p_i$ 到 $\max q_i$ 以内。所以，可以枚举每一个 $\max p_i\le m \le \max q_i$，然后计算有多少情况满足 $\forall s_i \le m$，我们令这个为 **多情况数**，然后再减去 $\forall s_i \lt m$ 的 **多情况数**，就是 $\max s_i=m$ 的 **真情况数**，令它为 $m_i$，则答案为 $\prod m_im$。

为什么 $m_i$ 是两个 **多情况数** 相减呢？因为，$\forall s_i \le m$ 保证的是每个数都小于或等于 $m$，而 $\forall s_i \lt m$ 保证的是每个数都小于 $m$，所以相减就保证了至少有一个 $s_i=m$，即 $\max s_i=m$。

那么 **多情况数** 是多少呢？对于每一个 $m$，**多情况数就是** $\prod\min\{q_i-m+1,q_i-p_i+1\}$。$\min$ 前面的是当 $m$ 在 $p_i$ 和 $q_i$ 中间时，那么可取的就是 $m$ 到 $p_i$，有 $m-p_i+1$ 种情况。如果 $m$ 不在 $p_i$ 和 $q_i$ 中间，那么一定比 $q_i$ 大（想想为什么），可取的就是 $p_i$ 到 $q_i$，有 $q_i-p_i+1$ 种情况。为了方便，我们可以直接用 $\min$，这和判断 $m$ 和 $q_i$ 是一样的（再想想为什么）。

根据这个思路，我们很容易就可以写出代码：

```cpp
#include <iostream>
using namespace std;

#define int long long

int n;
pair<int, int> rg[5005];
int su[5005];

signed main()
{
    cin >> n;
    int l = 0, r = 0;
    for (int i = 1; i <= n; i++)
    {
        cin >> rg[i].first >> rg[i].second;
        l = max(l, rg[i].first);
        r = max(r, rg[i].second);
    }
    for (int i = l; i <= r; i++) // 这里的 i 即题目中的 m
    {
        int cs = 1;
        for (int j = 1; j <= n; j++)
        {
            if (rg[j].first <= i)
            {
                cs = (cs * min(rg[j].second - rg[j].first + 1, i - rg[j].first + 1)) % 998244353; // （大家数学应该都很好吧）
            }
        }
        su[i] = cs;
    }
    int res = 0;
    for (int i = l; i <= r; i++)
    {
        res = (res + (i * (su[i] + 998244353 - su[i - 1]) % 998244353) % 998244353) % 998244353; // 最后再加起来就可以了，注意公式
    }
    cout << res << endl;
    return 0;
}

```


---

## 作者：Chis725 (赞：3)

## 思路

这道题明显是一道动态规划的题，我们可以枚举它最后 $s$ 数列中的最大值的种类和个数，最终将它的最大值乘上他的方案数再将所有的相加就可以了。但是状态转移方程是比较难的。我们先假设最大值为 $i$，我们设 $f_{i,j}$ 是前 $j$ 项最大值不超过 $i$ 的方案数，然后我们就可以得出下面的状态转移方程。
```cpp
if(i>=a[i].q)f[i][j] = f[i][j-1] * ( a[j].q - a[j].p + 1 ) % mod;
else f[i][j] = f[i][j-1] * ( i - a[j].p + 1 ) % mod;
```
我们还可以再简化一下。
```cpp
f[i][j] = f[i][j-1] * ( min(a[j].q,i) - a[j].p + 1 ) % mod;
```
然后我们可以利用容斥原理求出大值为 $i$ 的方案数为 $f_{i,n}-f_{i-1,n}$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 998244353;
const int N = 5001;
struct node {
	int p,q;
}a[N];
int n,minn=0,maxn=0,s,t,ans;
signed main() {
	scanf("%lld",&n);
	for(int i = 1 ; i <= n ; i++ ) {
		scanf("%lld %lld",&a[i].p,&a[i].q);
		minn=max(minn,a[i].p);//最大值的最小的可能
		maxn=max(maxn,a[i].q);//最大值的最大的可能
	}
	for(int i = minn ; i <= maxn ; i++){
		s = 1;
		t = 1;
		for(int j = 1 ; j <= n ; j++){
			s = s * ( min(a[j].q,i) - a[j].p + 1 ) % mod;//s为f[i][j]
			t = t * ( min(a[j].q,i - 1) - a[j].p + 1)%mod;//t为f[i-1][j]
		}
		ans = ans + ( (s - t + mod ) * i % mod);//防止s-t为负数
		ans%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：yeshubo_qwq (赞：3)

## Solution

设 $dp_{i,j}$ 表示前 $i$ 个位置，当前最大值为 $j$ 的方案数。

枚举第 $i$ 位放的 $k$，显然，如果 $k<j$，从 $dp_{i-1,j}$ 转移过来，否则如果 $k=j$，从 $dp_{i-1,l}(1\le l \le j)$ 转移过来。

最坏复杂度 $O(n^3)$，无法通过。

考虑如何优化：

+ 对于 $k<j$ 的部分可以 $O(1)$ 计算。

+ 对于 $k=j$ 的部分用前缀和优化。

## Code

**本题需要滚动数组，否则会 MLE，本蒟蒻因此在赛时挂分，警钟敲烂。**


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
struct node{
	int x,y;
} a[5005];
int n,i,j,k,l,ans,dp[2][5005],sum[5005];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for (i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
	for (j=a[1].x;j<=a[1].y;j++) dp[1][j]=1;
	for (j=1;j<=5000;j++) sum[j]=(sum[j-1]+dp[1][j])%mod;
	for (i=2;i<=n;i++){
		for (j=1;j<=5000;j++){
			dp[i&1][j]=0;
			if (a[i].x<j) dp[i&1][j]=(min(a[i].y,j-1)-a[i].x+1)%mod*dp[1-i&1][j]%mod;
			if (a[i].x<=j && j<=a[i].y) dp[i&1][j]=(dp[i&1][j]+sum[j])%mod;
		}
		for (j=1;j<=5000;j++) sum[j]=(sum[j-1]+dp[i&1][j])%mod;
	}
	for (i=1;i<=5000;i++) ans=(ans+dp[n&1][i]*i%mod)%mod;
	return cout<<ans,0;
}
```


---

## 作者：zhouyuhang (赞：3)

> 小丑。

[题目](https://www.luogu.com.cn/problem/P8894)

萌新的第一篇题解 qwq。

考虑枚举最大值容斥，可以写出式子：

$$
\sum_{x=1}^{\max q} x\left[\left(\prod_{i=1}^n| [1,x]\cup [p_i,q_i]|\right)-\left(\prod_{i=1}^n| [1,x-1]\cup [p_i,q_i]|\right)\right]
$$

考虑函数 $f(x)=|[1,x]\cup[p_i,q_i]|$。这是一个分段函数。那么分段函数的之积仍然为分段函数，每一段都是一个 $n$ 次多项式。直接代入 $n$ 个连续点值总复杂度为 $O(n^3)$ 无法接受。

注意到 $f(x)$ 的取值有且仅有：$0,q_i-p_i+1$ 与 $(x-p_i+1)$。如果我们扔去所有常数，剩余的多项式必定形如 $\prod_i(x-p_i+1)$，拆开以后答案就是它的前缀和加上个杂七杂八的东西。再深入发掘性质可以发现积式里的 $i$ 不是乱的，而必然是将所有 $[p_i,q_i]$ 按照 $p_i$ 从小到大排序后的一个前缀。

那么做法就很显然了。排序，然后从小到大扫，暴力维护系列点值表示对于当前位置 $pos$ 的 $\prod_{i=1}^{pos}(x-p_i+1)$，$x\in[1,n]$ 时的取值。这个做法很简单，就是每次直接给 $f(x)$ 乘上 $(x-p_{pos}+1)$。然后通过线性插值容易做到 $O(n^2)$。注意到，这是值域无关的。

---

## 作者：OldDriverTree (赞：2)

[更好的阅读体验](https://www.cnblogs.com/guoxiangyu66/p/17033258.html)
# 前言
我的一个学长在 [一次比赛](https://www.luogu.com.cn/contest/97362#problems) 中出了这道题，然后，~~我就把这道题切了~~

其实这道题还是比较简单的，然后我就介绍一下我的比赛时的思路和做法

# 30分做法
~~根据标签~~我们可以知道，这是一道 dp 题

我们先设 $dp[i][j]$ 表示前 $i$ 个区间中最大值为 $j$ 时的次数

那么转移时就枚举之前的最大值： $k$

那么状态转移方程就是： $dp[i][\max(j,k)]= \sum dp[i-1][k] $

然后就可以得到这样的一个暴力做法：

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5001,mod=998244353;

int dp[N][N];
int n,m,ans,l,r;

int main()
{
	scanf("%d",&n);
	dp[0][0]=1;
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d",&l,&r);
		for (int j=l;j<=r;j++)
			for (int k=0;k<=m;k++)
				dp[i][max(j,k)]+=dp[i-1][k],dp[i][max(j,k)]%=mod;
		m=max(m,r);
	}
	for (int i=1;i<=m;i++)
		ans+=1ll*dp[n][i]*i%mod,ans%=mod;
	printf("%d",ans);
	return 0;
}
```

# 再优化时间
那么这种做法的时间复杂度大约是 $O(nm^2)$

这种方法肯定会超时，所以考虑优化时间

那么转移的时候我们就只枚举一个 $j$ ：表示 $i$ 个区间中的最大值

然后再分类讨论：

当 $r<j$ 时，最大值 $j$ 就一定是从前 $i-1$ 个区间来的，所以  $dp[i][j]=dp[i-1][j]\times(r-l+1)$

否则，最大值就也有可能是从第 $i$ 个区间来的,那么 $dp[i][j]=dp[i-1][j]\times(j-l+1)+\sum_{k=1}^{j-1} dp[i-1][k]$

状态转移方程就是：

$$
dp[i][j]=
\begin{cases}
dp[i-1][j]\times(r-l+1) & r<j \\
dp[i-1][j]\times(j-r+1)+\sum_{k=1}^{j-1} dp[i-1][k] & r\ge j \\
\end{cases}
$$
求 $\sum_{k=1}^{j-1} dp[i-1][k]$ 时,显然就可以用前缀和来优化

那么这样时间复杂度就变成了 $O(nm)$ ，然后这样就可以 AC 了

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5001,mod=998244353;

int dp[N][N];
int n,m,ans,s[N];

int main()
{
	scanf("%d",&n);
	dp[0][0]=1;
	for (int i=1,l,r;i<=n;i++)
	{	
		scanf("%d%d",&l,&r);
		m=max(m,r);
		
		memcpy(s,dp[i-1],sizeof dp[i-1]);
		for (int i=1;i<=m;i++)
			s[i]+=s[i-1],s[i]%=mod;
		
		for (int j=l;j<=m;j++)
		{
			dp[i][j]=1ll*dp[i-1][j]*(min(j,r)-l+1)%mod;
			if (r>=j) dp[i][j]+=s[j-1],dp[i][j]%=mod;
		}
	}
	for (int i=1;i<=m;i++)
		ans+=1ll*dp[n][i]*i%mod,ans%=mod;
	printf("%d",ans);
	return 0;
}
```

# 继续优化
既然都求了 $s$ 数组了,那么之前的状态就可以用 $s$ 数组来求出来,那么 $dp$ 数组就可以只开一维了

然后还可以再优化时间:每次再存一个 $ml$：每个区间的 $l$ 的最大值

**但是需要注意**：

优化成一维后，$dp$ 数组某些不符合条件的位置，还会再存之前位置的次数

所以每次转移前,需要先清空一下 $dp$ 数组

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5001,mod=998244353;

int dp[N];
int n,ml,mr,ans,s[N];

int main()
{
	scanf("%d",&n);
	dp[0]=1;
	for (int i=0,l,r;i<n;i++)
	{
		scanf("%d%d",&l,&r);
		ml=max(ml,l),mr=max(mr,r);
		memcpy(s,dp,sizeof dp);
		for (int j=1;j<=mr;j++) s[j]+=s[j-1],s[j]%=mod;
		memset(dp,0,sizeof dp);
		for (int j=ml;j<=mr;j++)
		{
			dp[j]=1ll*((s[j]-s[j-1])%mod+mod)%mod*(min(j,r)-l+1)%mod;
			if (r>=j) dp[j]+=s[j-1],dp[j]%=mod;
		}
	}
	for (int i=ml;i<=mr;i++)
		ans+=1ll*dp[i]*i%mod,ans%=mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Zi_Gao (赞：1)

$\sum\limits_{s_1={p_1}}^{q_1}\sum\limits_{s_2={p_2}}^{q_2}\sum\limits_{s_3={p_3}}^{q_3} \cdots\sum\limits_{s_n={p_n}}^{q_n}\max\limits_{i=1}^ns_i$ 首先拿到这个式子，结合数据范围，模拟肯定超时了。这种时候一般需要把题目抽象出来，搞懂这个东西在说什么。

既然正面想不通，就从反面想，首先这个式子一串求和就是在干一个事情，每个区间选一个元素，把每种组合跑一遍，然后求出选出的元素中最大的一个，累加到答案中。那么，什么时候 $s_i$ 才能对答案做出贡献？肯定是 $s_i$ 是所有选出元素最大的时候，看似废话的一句话，实际就做完了题。考虑枚举每一个 $s_i$ ，对于每个 $s_i$ ，计算有多少个方案使得 $s_i$ 为最大。根据乘法原理，可得，使得最大值小于等于 $s_i$ 的方案数量为 $\prod_{i=1}^ns_i-p_i$ 记为 $ansleq_i$ ，但是现在要求得出最大值为 $s_i$ 的方案树，怎么办？考虑将方案结果小于 $s_i$ 剔除，也就是 $ansleq_i-ansleq_{i-1}$ ，就求得了使得 $s_i$ 为最大的方案数。最后累加 $\left(ansleq_i-ansleq_{i-1}\right)\times i$ 即可。

AC code 码风很丑，各位见谅。

```cpp
#include <cstdio>
#include <algorithm>
#define INPUT_DATA_TYPE long long
#define OUTPUT_DATA_TYPE long long

struct node{
    int l,r;
}arr[5010];

long long ansleq[5010];

INPUT_DATA_TYPE read();
void print(OUTPUT_DATA_TYPE x);

int main(){
    register int i,j,min=0,max=0;
    register long long temp,ans=0;
    int n=read();

    for(i=0;i<n;++i){
        arr[i].l=read();
        arr[i].r=read();
        min=std::max(min,arr[i].l);//精确控制上下界
        max=std::max(max,arr[i].r);
    }

    for(i=min;i<=max;++i){
        temp=1;
        for(j=0;j<n;++j)
            temp=temp*(std::min(i,arr[j].r)-arr[j].l+1)%998244353;
        ansleq[i]=temp;
    }

    for(i=min;i<=max;++i) ans=(ans+(((ansleq[i]-ansleq[i-1]))*i%998244353)+998244353)%998244353;//注意ansleq[i]-ansleq[i-1]可能为负数

    print(ans);

    return 0;
}

INPUT_DATA_TYPE read(){
    register INPUT_DATA_TYPE x=0;register char f=0,c=getchar();
    while(c<'0'||'9'<c)f=(c=='-'),c=getchar();//?=if,:=else
    while('0'<=c&&c<='9')x=(x<<3)+(x<<1)+(c&15),c=getchar();
    return f?-x:x;
}

void print(OUTPUT_DATA_TYPE x){
    register char s[20];
    register int i=0;
    if(x<0){
        x=-x;
        putchar('-');
    }
    if(x==0){
        putchar('0');
        return;
    }
    while(x){
        s[i++]=x%10;
        x/=10;
    }
    while(i){
        putchar(s[--i]+'0');
    }
    return;
}
```

---

## 作者：MSqwq (赞：1)

感觉做法很多，多项式，$dp$ 都可以。  
其实本质就是去枚举那一坨的 $max$。然后再去取 $s_i$，算贡献。  
那么我们不难想到能成为 $max$ 的数是有一定条件的，下限就是 $p_i$ 的 $max$，上限就是 $q_i$ 的 $max$。  
好的然后我们枚举了 $max$ 记为 $x$，进行分类讨论，如果某个区间的最大值都取不到 $max$，即 $x>q_i$ 那么在这些区间内就可以随便取，贡献就是 $\prod\limits_{x>q_i}q_i-p_i+1$。  
然后对于它相反的情况，即 $x\le q_i$ ，就是小于等于 $x$ 的随便取，但是得保证有一个要取到 $x$，不然我们分类的大前提 $max = x$ 就不成立了。那么贡献就是 $\prod\limits_{x\le q_i}x-p_i+1-\prod\limits_{x\le q_i}x-p_i$。  
注：这里算的贡献用到乘法原理。  

最后再把所有 $x$ 的贡献加起来，就得到了一下式子：  
 $\sum\limits_{x=max_{p_i}}^{max_{q_i}}(x\times \prod \limits_{x>q_i}q_i-p_i+1 \times (\prod\limits_{x\le q_i}x-p_i+1-\prod\limits_{x\le q_i}x-p_i) )$   
 
可能细节就是那两坨在模意义下相减要记得加个 $mod$，主要是不加的话大样例也能过，还是注意一下吧。  
代码：  
```
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iostream>
#include<vector>
#include<set>
#include<string>
#include<map>
#include<queue>
#include<stack>
#include<cmath>
#include<functional>
#define ll long long
using namespace std;
const int mod=998244353;
const int INF=0x3f3f3f3f;

inline ll read()
{
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0',c=getchar();}
	return x*f;
}
const int N=5e3+10;
ll p[N],q[N];

int main()
{
	int n=read();
	for(int i=1;i<=n;i++)p[i]=read(),q[i]=read();
	ll l=0,r=0;
	for(int i=1;i<=n;i++)l=max(l,p[i]),r=max(r,q[i]);
	ll ans=0;
	for(ll x=l;x<=r;x++)
	{
		ll ans1=1,ans2=1,ans3=1;
		for(int i=1;i<=n;i++)
			if(x>q[i])ans1=ans1*(q[i]-p[i]+1)%mod;
		for(int i=1;i<=n;i++)
			if(x<=q[i])ans2=ans2*(x-p[i]+1)%mod,ans3=ans3*(x-p[i])%mod;
		ans=(ans+x*ans1%mod*(ans2-ans3+mod)%mod)%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：uid_310801 (赞：1)

赛后 vp 了这题，$10$ 分钟做出来了。

发现这题区间数量和值域都很小，考虑枚举最大值。

假设最大值为 $m$。

首先如果有区间不包含 $m$ 则情况总数为 $0$.

然后枚举每个区间，这个区间中选出的数不能大于 $m$，容易求出每个区间内能选的数的数量。把数量乘起来，就是选择出的数最大值**小于等于** $m$ 的方案数。

如何求最大值恰好等于 $m$ 的方案数呢？很简单，我们做一次容斥，把这个方案数减去小于等于 $m-1$ 的方案数即可。

时间复杂度 $O(nV)$.

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
typedef long long ll;
const ll N=3e5+10,mod=998244353;
ll n,ans,p[N],q[N],maxl,maxr;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld %lld",&p[i],&q[i]);
		maxl=max(maxl,p[i]);
		maxr=max(maxr,q[i]);
	}
	for(int i=maxl;i<=maxr;i++){
		ll sum1=1,sum2=1;
		for(int j=1;j<=n;j++){
			if(q[j]<=i)	sum1=sum1*(q[j]-p[j]+1)%mod;
			else sum1=sum1*(i-p[j]+1)%mod;
			if(q[j]<=i-1)	sum2=sum2*(q[j]-p[j]+1)%mod;
			else sum2=sum2*(i-p[j])%mod;
		}
		ans=(ans+i*(sum1-sum2+mod))%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
/*
exSample:

*/

```


---

## 作者：可爱妹妹交流群Official (赞：0)

# Tag

计数，差分。

# Preface

赛时一血祭。

# Solution

看到值域很小，那么首先考虑枚举这个最大值 $m$。

有一个显然的限制：$\forall 1\le i \le n, m=\max_{i=1}^ns_i\ge s_i$。也就是 $\forall 1\le i\le n, s_i\le m$，假设满足这个条件的 $s$ 构成的集合为 $f(m)$，根据乘法原理有 $|f(m)|=\prod_{i=1}^n|[p_i,q_i]\bigcap(-\infty,m]\bigcap\mathbb Z|$。单个 $|f(m)|$ 显然可以 $\Theta(n)$ 求。

发现这个限制太松了？当 $\forall 1\le i\le n, s_i\le m$ 时，最大值 $\le m$。那么 $f(m)$ 代表 $\max_{i=1}^ns_i\le m$ 的所有 $s$ 构成的集合 。当 $\max_{i=1}^ns_i=m$ 时，即 $\max_{i=1}^ns_i\le m$ 且 $\max_{i=1}^ns_i>m-1$ 时，那么就是 $s\in f(m)$，但不 $\in f(m-1)$，而 $f(m-1)\subseteq f(m)$，所以可以得到这样的种数为 $|f(m)|-|f(m-1)|$。

此时会发现，答案即为所有 $m$ 乘上种类数的和，即 $\sum_{m\in V}(|f(m)|-|f(m-1)|)\times m$，其中 $V$ 是值域。这个东西可以 $\Theta(n|V|)$ 地求。然后就做完了。

```cpp
#include <iostream>
#include <vector>
using ll = long long;

const ll mod = 0x3b800001;
int n;
ll c[5007];
ll ac[5007];
int main() {
  std::cin >> n;
  std::vector<std::pair<int, int>> v(n);
  for (auto& [i, j] : v) std::cin >> i >> j;
  for (int i = 1; i <= 5000; ++i) {
    c[i] = 1;
    for (auto [j, k] : v) {
      k = std::min(i, k);
      if (j > k) {
        c[i] = 0;
      } else {
        c[i] *= (k - j + 1);
        c[i] %= mod;
      }
    }
  }
  ll ans = 0;
  for (int i = 1; i <= 5000; ++i) {
    ac[i] = c[i] - c[i - 1];
    ac[i] += mod;
    ans += ac[i] * i;
    ans %= mod;
  }
  std::cout << ans;
  return 0;
}
```

---

## 作者：_ANIG_ (赞：0)

## DP

直接 DP。$f_{i,j}$ 表示第 $1-i$ 个循环，前 $i$ 个循环参数的最大值是 $j$，循环结束后对答案的贡献。

显然，$f_{i,j}=\sum\limits_{k=pi}^{qi} f_{i+1,\max (j,k)}$。

把这个式子分成两部分：$p_i$~$j$，$j+1$~$q_i$。

那么 $f_{i,j}=(j-p_i+1)×f_{i+1,j}+\sum\limits_{k=j+1}^{qi}f_{i+1,k}$。

后半部分是个显然的前缀和，这样就可以做到 $O(n^2)$。

但是本题空间限制较小。可以发现每次转移只与 $f_i$ 和 $f_{i+1}$ 有关。直接滚掉一维即可。时间复杂度 $O(n^2)$，空间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int l[5005],r[5005],n,f[2][5005],mods=998244353,qz[2][5005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%lld%lld",&l[i],&r[i]);
	for(int i=1;i<=5000;i++)f[1][i]=i,qz[0][i]=qz[0][i-1]+f[1][i],qz[0][i]%=mods;
	for(int i=n;i>=1;i--){
		for(int j=0;j<=5000;j++){
			if(l[i]<=min(j,r[i]))f[0][j]+=(min(j,r[i])-l[i]+1)*f[1][j],f[0][j]%=mods;
			if(max(l[i],j+1)<=r[i])f[0][j]+=qz[0][r[i]]-qz[0][max(l[i],j+1)-1],f[0][j]%=mods;
			if(j)qz[1][j]=qz[1][j-1]+f[0][j],qz[1][j]%=mods;
			else qz[1][j]=f[0][j];
		}
		memcpy(qz[0],qz[1],sizeof(qz[0]));
		memset(qz[1],0,sizeof(qz[1]));
		memcpy(f[1],f[0],sizeof(f[0]));
		memset(f[0],0,sizeof(f[0]));
	}
	cout<<(f[1][0]+mods)%mods;
}
```


---


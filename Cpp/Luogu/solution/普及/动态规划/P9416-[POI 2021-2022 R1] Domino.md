# [POI 2021/2022 R1] Domino

## 题目背景

译自 [XXIX Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi29-1/dashboard/) [Domino](https://sio2.mimuw.edu.pl/c/oi29-1/p/dom/)。

## 题目描述

> 有一个 $2$ 行 $n$ 列的矩形，上面有若干个格子被占用了。你要用 $1\times 2$ 或 $2\times 1$ 的牌，覆盖所有未被占用的格子，一个格子不可被占用两次。记方案数为 $m$。

给你 $m$，求出最小的 $n$，使得存在一种方案设置占用格，使得覆盖的方案数恰好为 $m$。无解输出 `NIE`。

## 说明/提示

对于所有数据，$1\leq m\leq 10^{18}$。

| 子任务编号 | 附加限制 | 分数 |
| :----------: | :----------: | :----------: |
| 1 | 答案 $\leq 12$ | 20 |
| 2 | $m\leq 2000000$ | 30 |
| 3 |  | 50 |

## 样例 #1

### 输入

```
4
```

### 输出

```
5
```

## 样例 #2

### 输入

```
101
```

### 输出

```
NIE
```

## 样例 #3

### 输入

```
9
```

### 输出

```
7
```

## 样例 #4

### 输入

```
11
```

### 输出

```
NIE
```

## 样例 #5

### 输入

```
500
```

### 输出

```
20
```

## 样例 #6

### 输入

```
112233445566778899
```

### 输出

```
NIE
```

# 题解

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P9416 [POI2021-2022R1] Domino](https://www.luogu.com.cn/problem/P9416)

## 解题思路

1. 使用 $1\times 2$（横向）或 $2\times 1$（纵向）的方块覆盖 $2\times n$ 矩形的所有格子。

2. 如图，有两种填充方式：使用一个纵向方块或两个横向方块。若某列中，上下两行的填充方式不一致，将导致两侧剩余奇数个格子，无法完全填满。

![](https://cdn.luogu.com.cn/upload/image_hosting/zq5llgsq.png)

3. 这两种填充方式分别覆盖了 $1$ 列和 $2$ 列，如果要覆盖 $x$ 列，易得方案数为 Fibonacci 数列中第 $x$ 项 $f_x$。

$$
f_n=\begin{cases}
  1 & n\le1 \\
  f_{n-1}+f_{n-2} & \text{else}
\end{cases}
$$

4. 我们可以占用若干列格子（障碍），将整个矩形划分为若干个矩形部分。根据乘法原理，总方案数 $m$ 等于每部分方案数的乘积。

5. 为什么 $n$ 最小时，障碍一定将序列分割成若干部分：如果障碍不分割为若干部分，那么在某个联通部分中必然能找到一对孤立障碍。由于它们外侧格子数量为偶数，因此同一列的另一个格子只能向内侧覆盖，下一列的另一个格子也只能向内侧覆盖……以此类推，两个孤立障碍之间别无选择，等价于直接删除这一段。

6. 原问题等价为：将正整数 $m$ 分解为若干个 $f_{a_i}$ 的乘积，求 $n=\sum(a_i+1)-1$ 的最小值（分割每个部分需要一列障碍，但最后一个不需要）。

7. 由于 $f_{90}>10^{18}$，可以加上剪枝优化后暴力枚举。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const ll inf=0x3f3f3f3f3f3f3f3f;
const int N=90;
ll f[N],ans=inf;
void init()
{
	f[0]=f[1]=1;
	for(int i=2;i<N;i++)f[i]=f[i-1]+f[i-2];
}
void dfs(ll x,ll s)
{
	if(x<=1)
	{
		ans=min(ans,s);
		return;
	}
	if(ans<s)return;
	for(int i=2;i<N;i++)
	{
		if(x%f[i])continue;
		ll u=x,v=s;
		while(u%f[i]==0)
		{
			u/=f[i];
			v+=i+1;
		}
		dfs(u,v);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	init();
	ll m;
	cin>>m;
	dfs(m,0);
	if(m==1)cout<<1<<'\n';
	else if(ans==inf)cout<<"NIE"<<'\n';
	else cout<<ans-1<<'\n';
	return 0;
}
```

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P9416)。

[**更好的阅读体验**](https://www.cnblogs.com/XuYueming/p/18940612)。

## 题意简述

一个 $2\times n$ 的矩形，上面有若干个格子被占用了。你要用 $1\times 2$ 或 $2\times 1$ 的牌，覆盖所有未被占用的格子，一个格子不可被占用两次。记方案数为 $m$。

给你 $m$，求最小的 $n$，使得存在一种方案设置被占用的格子，使得覆盖的方案数恰好为 $m$，或报告无解。

$1\leq m\leq10^{18}$。

## 题目分析

妙妙题。

读懂题目后，可以尝试暴搜确定每一个格子的占用情况。考虑计算方案数。不难想到从左到右一列一列地决策，设 $f_{i,0/1/2}$ 表示，考虑到第 $i$ 列，前 $i-1$ 列均非空，对于第 $i$ 列的两行，均非空 / 上面非空 / 下面非空，非空指被占用，或者被覆盖。

1. 第 $i$ 列均未被占用。

    $f_{i,0}\gets f_{i-1,0}$：在第 $i$ 列放置了 $2\times 1$ 的矩形。
    $f_{i,1}\gets f_{i-1,2},f_{i,2}\gets f_{i-1,1}$：在第 $i-1,i$ 列放置了一个 $1\times 2$ 的矩形。
    若第 $i-1$ 列也均未被占用，$f_{i,0}\gets f_{i,0}+f_{i-2,0}$，即放置两个 $1\times 2$ 的矩形。
1. 第 $i$ 列上面被占用。（下面类似。）

    $f_{i,0}\gets f_{i-1,1}$：第 $i-1,i$ 列下层放置了一个 $1\times2$ 的矩形。第 $i$ 列下层被覆盖，上层被占用。
    $f_{i,1}\gets f_{i-1,0}$：不放置矩形。
    $f_{i,2}\gets 0$：显然不合法。
1. 第 $i$ 列均被占用。

    $f_{i,0}\gets f_{i-1,0}$，$f_{i,1/2}\gets 0$，进行不了操作。

以上 DP 能够做到不重不漏地统计方案。

打表后惊奇地发现，在 $n$ 最小的前提下，对于每一种覆盖方案数为 $m$ 的占用方案（$m\neq0$），占用的格子总是为若干个 $2\times1$ 的矩形，不妨称作隔板，将 $2\times n$ 的矩形划分成了若干个宽度大于等于一的矩形，这些被划分出来的小矩形内部格子均未被占用。

证明：

显然占用的格子数必然是偶数。假设在 $n$ 最小的前提下，存在一种占用情况，占用的格子不满足结论。

有若干被占用的格子构成了若干隔板，剩下占用的格子至少有两个，取出其中前两个 $C_a,C_b$，分别在第 $i,j$ 列，讨论他们之间的位置关系。

1. 他们之间被某个隔板隔开了。

    隔板的左边，由于一个单独的 $C_a$ 的存在，不存在合法的覆盖方案，方案数为 $0$，与方案数为 $m\neq 0$ 矛盾。
1. 他们在同一行。不妨设他们在上面一行。

    左边 $2\times(i-1)$ 的矩形的所有合法覆盖方案，均不会溢出来占用第 $i$ 列的第二行。

    为了填上第 $i$ 列的第二行的空位，肯定会放置一个 $2\times 1$ 的矩形。那么又将第 $i+1$ 列第一行空了出来，又要用 $2\times1$ 的矩形填上。如此，直到碰到 $C_b$。

    若 $j-i$ 为偶数，最终会导致第 $j-1$ 列第一行单独空出，不能被覆盖，方案数为 $0$，与方案数非零矛盾；否则，$i\sim j$ 的覆盖方式存在且唯一。倘若我们将第 $i\sim j$ 列换成一个隔板，方案数没有发生变化，而列数至少从 $2$ 变为了 $1$，与 $n$ 最小矛盾。
1. 他们不在同一行。

    类似上面的讨论。导出要么方案数为 $0$ 矛盾，要么与 $n$ 最小矛盾。

故结论成立。

每一个被隔开的矩形相互独立，遵循乘法原理。对于一个 $2\times n$ 的全空矩形，分析前文的 DP，此时只有 $f_{i,0}$ 有意义，不难得出覆盖方案数为 $F_n$，其中 $\{F_n\}$ 为斐波那契数列 $F_0=1,F_1=1,F_2=2,\ldots$。

那么问题变为了求满足 $\prod_{i=1}^t F_{x_i}=m$ 最小的 $n=t-1+\sum_{i=1}^t x_i$。由于 $F_{87}>10^{18}$，故 $x_i\leq86$。显然 $x_i\ge2$，否则由于 $F_{x_i}=1$，去掉不改变方案数，而可以让 $n$ 更小。

本地用 $88.37$ 秒暴搜发现，$10^{18}$ 以内可以被 $F_n$ 的乘积表示出来的 $m$ 只有 $36338470$ 种，拆分方案数最多只有 $70$ 种，在 $m\in\{519400496868360192,584325558976905216\}$ 取到。这提示我们某些看起来不太正确的算法，可能实际上是正确的。

可以直接暴搜拆分方案。但是直接暴搜是错误的，参考 [link](https://www.luogu.com.cn/ticket/BACF173327) 和 [link](https://www.luogu.com.cn/discuss/942069)。所以需要最优性剪枝，或者记忆化。

## 代码

见[我的博客](https://www.cnblogs.com/XuYueming/p/18940612)。

---


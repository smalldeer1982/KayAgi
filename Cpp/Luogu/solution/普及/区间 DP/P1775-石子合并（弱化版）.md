# 石子合并（弱化版）

## 题目描述

设有 $N(N \le 300)$ 堆石子排成一排，其编号为 $1,2,3,\cdots,N$。每堆石子有一定的质量 $m_i\ (m_i \le 1000)$。现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。试找出一种合理的方法，使总的代价最小，并输出最小代价。

## 样例 #1

### 输入

```
4
2 5 3 1```

### 输出

```
22```

# 题解

## 作者：expnoi (赞：110)

令```dp[i][j]```表示区间```[i,j]```的最小价值。

不妨从终点考虑问题，即结果为两个子区间合并的最小值再加上合并需要的代价即可。

枚举两个子区间，即枚举这个区间的中间点k，使这个区间被分为```[i,k]```和```[k+1,j]```两个区间，取一遍最小值加上合并的即为当前区间所求。

至于合并的代价，用前缀和即可。

所以```dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1])```

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[310][310],len,a[310],n,sum[310];
int main()
{
	cin>>n;
	memset(dp,0x3f,sizeof(dp));//初始化1，因为是求最小代价，所以初始化设为很大的一个数，为了后面更新。
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		dp[i][i]=0;//初始化2，他自己本身的代价为0。
	}
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i<=n-len+1;i++)
		{
			int j=i+len-1;
			for(int k=i;k<j;k++)
			{
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);
			}
		}
	}
	cout<<dp[1][n];
}
```

---

## 作者：lzyqwq (赞：73)

这道题不是贪心。如果是贪心则应该是合并任意两堆，而不是相邻两堆。很容易举出反例。就拿样例来说,贪心合并顺序应该是：

$1,2\rightarrow(1,2),3\rightarrow(1,2,3),5$

总和是 $1+2=3,3+3=6,6+5=11,3+6+11=20$。

而题目中是 $22$，合并顺序是 $2,5\rightarrow1,3\rightarrow(2,5),(1,3)$，总和是 $2+5=7,1+3=4,7+4=11,7+4+11=22$。由此我们可以看出贪心法是错误的。

以上内容于 2022.2.9 添加。Update at 2022.2.9。

这道题就是一道区间 dp，我们用 $f_{i,j}$ 表示区间 $[i,j]$ 的最小代价。

区间 dp 的基本模型是个三重循环，由于此题是合并，可以理解我小区间转化成大区间的操作，所以第一层循环要从小到大枚举区间的长度，实现从小到大的转换。

除此之外，我们要确定区间的位置，已知长度，我们第二层循环枚举左端点，就可以求出右端点：$ R-L+1=S,R=S+L-1 $ 其中 $ L $ 为左端点，$ R $ 为右端点，$ S $ 为区间长度。公式很好理解，左端点减去右端点为两个端点之间的距离，由于距离把左端点减掉了，而左端点也算在区间长度内，所以要加 $ 1 $ 加回来，最后通过移项算出右端点。~~（小学方程总会解吧）~~

第三，我们要确定是哪两个小区间合并成大区间，所以第三层循环是枚举区间的分界点，把区间分成左右两部分（这个既可以算在左区间范围内 $ L $ 到 $ R-1 $，也可以算在右区间范围内 $ L+1 $ 到 $ R $）。

接下来请看具体代码，注释都写在代码里了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 305
int f[N][N],a[N],s[N][N];
int main()
{
	
	memset(f,0x3f,sizeof(f));//求最小值，所以初始化无穷大
	int n;
        scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		f[i][i]=0;//自己到自己代价肯定是0啊
		s[1][i]=s[1][i-1]+a[i];//用前缀和快速算质量和，区间[j,i]的和为区间[1,i]的和减去区间[1,j-1]的和
		for(int j=2;j<=i;j++)
		{
			s[j][i]=s[1][i]-s[1][j-1];
		}
	}
	for(int i=2;i<=n;i++)//枚举当前区间长度
	{
		for(int j=1;j+i-1<=n;j++)//j为左端点，则右端点为j+i-1，注意要减1，因为第j个也是算在区间内的
		{
			int e=j+i-1;//存一下右端点
			for(int k=j;k<e;k++)//枚举区间的分界点，把区间[j,k]和区间[k+1,e]合并，k是到e-1，因为分界点两边的区间长度都必须要>=1，不然会出现区间[e,e]长度为0的情况，和空气合并就没意义了
			{
				f[j][e]=min(f[j][e],f[j][k]+s[j][k]+f[k+1][e]+s[k+1][e]);
                                //状态转移方程，f[j][k]表示合并成为左区间的最小代价
                                //f[k+1][e]表示合并成为右区间的最小代价，
                                //s[j][k]表示左区间的质量和，s[k+1][e]表示右区间质量和；
                                //即，f[j][k]+f[k+1][e]为得到左右两个区间所需要花费的最小代价，
                                //s[j][k]+s[k+1][e]为合并左右两个区间所需要花费的代价，
                                //两者加起来就是得到区间[j,e]花费的代价，然后和原方案取min
			}
		}
	}
	printf("%d\n",f[1][n]);//最后输出得到区间[1,n]的最小花费代价
	return 0; 
}  
```

---

## 作者：墨忧 (赞：29)

## 思路

原题传送门：[Link](https://www.luogu.com.cn/problem/P1775) 。

本题是 [P5569 [SDOI2008] 石子合并](https://www.luogu.com.cn/problem/P5569) 和  [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880) 的弱化版本，适合 dp 初学者做练习，如果您已经切爆了本题，不妨点开上面两个链接练习标准版和强化版。

题目要求求出石子合并后的最小代价，我们很容易想要贪心的思路，但是题目要求每次只能合并相邻两堆石子，因此本题应使用 DP 求解。

不难发现，最后得到的最大的石子堆是由两个相邻的石子堆合并形成的，而这两个石子堆又分别是由更小的两个相邻石子堆合并而来。因此我们可以得出，一个较大是石子堆一定是由两个较小的相邻石子堆合并形成。

接下来是重点：

我们定义一个状态 dp[i][j] ， 它代表从将最开始的第 i 堆石子到第 j 堆石子合并成一个大堆所消耗的最小代价。考虑边界情况，当只有一堆石子时，不需要耗费任何代价，即 dp[i][i] = 0 。

其次，考虑如何转移状态，上面已经提到，一个大的石子堆一定是由两个小的相邻石子堆合并而成。因此我们可以将大的堆拆成两个小的石子堆，枚举中间的点，每次计算合成这两小堆已用代价加上这次合并的代价（这次合并的代价即整个区间的和），找到最小值，即 dp[i][j] = min( dp[i][j] , dp[i][k] + dp[k+1][j] + a[i] + a[i+1] + ··· + a[j] )  i ≤ k ≤ j 。

为了降低时间复杂度，可以使用前缀和优化，以便我们在 $O(1)$  的时间内求出区间和。

再回到上文提到的大石子堆由小石子堆合成，我们应先求出合成小石子堆用的总代价，再去求合成大石子堆所用的总代价。

将思路串起来，使用三重循环，最外层枚举区间长度有小到大（对应上文小石子堆合成大石子堆），第二层枚举区间起点，最后一层枚举中间点，按照状态转移方程求解，最后的答案即 dp[1][n] 。

总体时间复杂度 $O(n^3)$ 。

讲的可能不是非常清晰，请多多包涵。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=0x7fffffff;
int dp[305][305],a[305],sum[305],n;
int l,r;
inline int read()//快读
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch && ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar(); 
	}
	return x*f;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) sum[i]=a[i]+sum[i-1];
	for(int len=2;len<=n;len++)
	    for(int j=1;j<=n-len+1;j++)
	    {
	    	l=j;
	    	r=j+len-1;
			dp[l][r]=INF;
	    	for(int k=l;k<r;k++) dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]+sum[r]-sum[l-1]);
		}
	cout<<dp[1][n]<<'\n';
	return 0;
}
```


---

## 作者：Engulf (赞：21)

[题目传送门](https://www.luogu.com.cn/problem/P1775)

## 分析

此题做法有好几种，其中一种是 dp，还有一种是**记忆化搜索**。

我们知道暴力 dfs 非常慢，但是加上记忆化优化后会原地起飞。

```dfs(l,r)``` 表示合并区间 $[l,r]$ 的最小价值，那么我们枚举 $[l,r]$ 间的一个中转点 $i$，答案就是：
1. 不合并；
2. 合并，加上代价；

取最小值。

```dfs(l,r)=min(dfs(l,i)+dfs(i+1,r)+a[r]-a[l-1]);```

$a$ 数组存的是前缀和，快速求合并 $[l,r]$ 的代价。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1005], f[1005][1005], n;

int dfs(int l, int r) {
    if (l == r)return 0;//自己与自己合并，代价为0
    if (f[l][r] != INT_MAX)return f[l][r];//记忆化，已经求解的直接返回
    for (int i = l; i < r; ++i) {
        f[l][r] = min(f[l][r], dfs(l, i) + dfs(i + 1, r) + a[r] - a[l - 1]);
    }
    return f[l][r];
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            f[i][j] = INT_MAX;
        }
    }
    for (int i = 1; i <= n; i++)cin >> a[i], a[i] += a[i - 1];
    cout << dfs(1, n);
    return 0;
}
```

## 区间动归 dfs 模板

最后，安利一个区间合并的 dfs 模板。~~其实就是上面复制下来的~~~

```cpp
int dfs(int l, int r) {
    if (l == r)return 0;
    if (f[l][r] != INT_MAX)return f[l][r];
    for (int i = l; i < r; ++i) {
        f[l][r] = min(f[l][r], dfs(l, i) + dfs(i + 1, r) + a[r] - a[l - 1]);
    }
    return f[l][r];
}
```

---

## 作者：Hollis_Yang (赞：12)

这么简单的题居然没人来做？

这是一道区间 dp 的模板题，比较适合初学区间 dp 的同学做。

废话不多说，开始讲吧。

我们设```dp[i][j]```为```m[i]```到```m[j]```合并的最小代价。

定义了状态以后，我们来想 dp 转移方程。

区间 dp 的核心思想就是把两个区间的答案合并。

所以我们每次在```i```到```j```中枚举一个断点```k```。

假设我们已经把```i```到```k```和```k+1```到```j```已经合并好了。

那么```i```到```j```合并的代价就是```i```到```k```合并的最小代价加上```k+1```到```j```合并的最小代价再加上把这两个区间合并的代价。

把这两区间合并的代价就是```i```到```j```的石子质量的和。

我们设```d(i,j)```表示```i```到```j```的石子质量的和。

可以得到 dp 转移方程：```dp[i][j]=min(dp[i][k]+dp[k+1][j]+d(i,j))```。

如何快速查询表示```i```到```j```的石子质量的和呢？

我们可以使用前缀和 $O(1)$ 查询。

这样我们就得到了一个时间复杂度 $O(n^3)$ 的算法。

最后，根据```dp[i][j]```的定义，```dp[1][n]```即为答案。



------------
### AC 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define un unsigned
#define pb push_back
#define mp makepair
using namespace std;
template<typename T> inline void read(T &x){
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag)x=-x;
}
template<typename T> inline void write(T x){
   	short st[30],tp=0;
	if(x<0) putchar('-'),x=-x;
	do st[++tp]=x%10,x/=10; while(x);
	while(tp) putchar('0'|st[tp--]);
}
#define wr write
#define rd read
#define pk putchar(' ')
#define ed puts("")
int dp[301][301],i,j,k,l,m[501],n,d[501];
signed main(){
	rd(n);
	for(i=1;i<=n;i++) rd(m[i]);
	for(i=1;i<=n;i++) d[i]=d[i-1]+m[i];//前缀和
	for(l=1;l<n;l++){
		for(i=1,j=l+1;j<=n;j++,i++){
			dp[i][j]=0x7ffffff;//自己思考一下为什么必须在循环里设初值
			for(k=i;k<j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+d[j]-d[i-1]);//dp转移方程
		}
	}
	wr(dp[1][n]);
}

```

蒟蒻的第二篇题解 qwq。

---

## 作者：Coros_Trusds (赞：6)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15773115.html)

# 题目大意

设有 $N(N \le 300)$ 堆石子排成一排，其编号为 $1,2,3,\cdots,N$。每堆石子有一定的质量 $m_i(m_i \le 1000)$。

现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。

试找出一种合理的方法，使总的代价最小，并输出最小代价。

# 题目分析

辨别区间 $\rm DP$ 的方式：

从小区间延伸到大区间（合并等方式）。

许多括号数数题就是区间 $\rm DP$ 好题，今年 $\verb!2021-CSP-S-括号序列!$ 不妨一做。

---

令 $dp[l][r]$ 表示区间 $[l,r]$ 内合并的最小代价。

枚举左右区间，再枚举中间断点来判断是否答案会变得更优：

$dp[l][r]=\min\{dp[l][k]+dp[k+1][r]+cost\}(l\le k\lt r)$。

其中 $cost$ 表示 $\sum\limits_{i=l}^{r}a_i$。

枚举区间（左右+断点）复杂度为 $O(N^3)$，中间枚举价值的部分又是 $O(N)$，总时间复杂度 $O(N^4)$。

枚举价值部分可以通过前缀和优化，优化为 $O(N^3)$。

# 代码

```cpp
//2022/1/6

const int INF=0x3f3f3f3f;

const int ma=305;

int a[ma],sum[ma];

int dp[ma][ma];

int n;

int main(void)
{
	n=read();
	
	Input_Int(n,a);
	
	for(register int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+a[i];
	}
	
	for(register int len=2;len<=n;len++)
	{
		for(register int l=1;l+len-1<=n;l++)
		{
			int r=l+len-1;
			
			dp[l][r]=INF;
			
			for(register int k=l;k<r;k++)
			{
				int w=sum[r]-sum[l-1];
				
				dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]+w);
			}
		}
	}
	
	printf("%d\n",dp[1][n]);
	
	return 0;
}
```

---


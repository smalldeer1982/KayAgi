# 求数列所有后缀最大值的位置

## 题目描述

给定一个数列 $a$，初始为空。有 $n$ 次操作，每次在 $a$ 的末尾添加一个正整数 $x$。

每次操作结束后，请你找到当前 $a$ 所有的后缀最大值的下标（下标从 1 开始）。一个下标 $i$ 是当前 $a$ 的后缀最大值下标当且仅当：对于所有的 $i < j \leq |a|$，都有 $a_i > a_j$，其中 $|a|$ 表示当前 $a$ 的元素个数。

为了避免输出过大，请你**每次操作结束后都输出一个整数**，表示**当前数列**所有后缀最大值的下标的按位异或和。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^6$，$1 \leq x_i \lt 2^{64}$。请注意大规模数据输入输出对程序效率产生的影响。

## 样例 #1

### 输入

```
5
2 1 3 5 4```

### 输出

```
1
3
3
4
1```

# 题解

## 作者：一扶苏一 (赞：58)

## B3666 求数列所有后缀最大值的位置

### Preface

我私心里希望这道题成为单调栈的第一模板题，因为它揭示了单调栈的本质，即维护所有前缀的后缀最值。

但是这题自 10 月 1 日被我造出来起就没人写题解，我只能自己写一份（

### Description

给定一个数列 $a$，初始为空。有 $n$ 次操作，每次在 $a$ 的末尾添加一个正整数 $x$。

每次操作结束后，请你找到当前 $a$ 所有的后缀最大值的下标（下标从 1 开始）。一个下标 $i$ 是当前 $a$ 的后缀最大值下标当且仅当：对于所有的 $i < j \leq |a|$，都有 $a_i > a_j$，其中 $|a|$ 表示当前 $a$ 的元素个数。

为了避免输出过大，请你**每次操作结束后都输出一个整数**，表示**当前数列**所有后缀最大值的下标的按位异或和。

$1 \leq n \leq 10^6$，$1 \leq x_i \lt 2^{64}$。

### Analysis

考虑用一个栈按顺序维护当前数列的所有后缀最大值的位置（下标）。初始时栈是空的。

注意到这个栈里下标对应的数列元素（而不是下标本身）是单调递减的。

举个例子，设当前数列是 $\{a\} = 5, 3, 4, 1, 2$，那么栈中的数列下标（自底向顶）应该是 $1, 3, 5$，对应的在数列里对应的元素是 $a_1 = 5, a_3 = 4, a_5 = 2$。$5,4,2$ 这个数列是单调递减的。

考虑加入一个新数 $a_x$ 时，首先新加入的数显然是当前数列的后缀最大值。我们考虑数列其他后缀最大值如何变化：

1. **如果原有的某个后缀最大值所在的下标 $y$ 满足 $a_y > a_x$，则 $y$ 不受影响，仍是后缀最大值下标**。因为对 $y < z < x$，都有 $a_y > a_z$（否则 $y$ 不可能是原有的后缀最大值下标）；又 $a_y > a_x$，于是对 $y < z \leq x = |a|$，都有 $a_y > a_z$，这符合后缀最大值的定义。
2. **如果原有的某个后缀最大值所在的下标 $y$ 满足 $a_y \leq a_x$，则 $y$ 将不再是数列的后缀最大值下标**。这一点是显然的，因为 $x > y$ 而 $a_x \geq a_y$，故 $y$ 自然不能是后缀最大值下标。
3. **如果某个下标 $y$ 原先不是后缀最大值下标，则插入 $a_x$ 后它仍然不是后缀最大值下标**。这是因为如果 $y$ 不是后缀最大值下标，则一定存在一个 $z > y$ 满足 $a_z > a_y$。插入 $a_x$ 没有导致这个关系的变化，这个关系仍然成立，故而 $y$ 不是后缀最大值下标。

做个总结：插入 $a_x$ 后，会删掉原有后缀最大值下标中那些满足 $a_y \leq a_x$ 的下标 $y$，其他位置不变。然后 $x$ 成为新的后缀最大值下标。

考虑因为这个栈里下标对应的数列元素是单调的，所以要删掉那些不再是后缀最大值下标的 $y$，只需要不断地在这个栈顶部弹出元素（也就是把栈里元素自底向顶写成序列后，不断地从后面删除元素），直到栈为空或栈顶元素 $t$ 满足 $a_t > a_x$。最后将 $x$ 入栈即可。

写作代码就是

```cpp
while (!stk.empty() && a[stk.top()] <= a[x]) stk.pop();
stk.push(x);
```

例如，再上例中，如果新加入一个元素 $a_6 = 4$，我们首先比较栈顶元素 $a_5 = 2 < a_6 = 4$，故将 $5$ 弹出；然后比较栈顶 $a_3 = 4 \leq a_6 = 4$，故将 $3$ 弹出；再比较 $a_1 = 5 > a_6 = 4$，停止弹栈，并将新加入的下标 $6$ 压入栈中。最后栈中的数列下标变为 $1, 6$。

考虑时间复杂度：显然每个元素只会在被插入时压入栈一次，也只会被栈弹出至多一次，所以总的时间复杂度是 $O(n)$，均摊单次插入 $O(1)$。

因为栈里元素的下标对应的数列元素是单调的，所以这一数据结构被称为**单调栈**。

如果把本题的「添加元素」操作改为：本身给定一个长度为 $n$ 的数列 $a$，每次查找 $[1, i]$ 这个前缀的所有后缀最大值，你可以发现这两种叙述完全等价。这就是说，本质上单调栈维护的是**数列所有前缀的后缀最值**。你可以通过调整比较条件里的大于号、小于号、大于等于号、小于等于号来用这一数据结构维护所有前缀的后缀最大、最小、非严格最大、非严格最小值。

以上就是对单调栈的介绍。

---

在本题中，每次操作结束后要求输出所有后缀最大值下标的按位异或和。只需要用一个全局变量 $b$ 维护当前栈内元素的按位异或和，在 pop 和 push 时均令 $b$ 异或上被操作的数即可。

记得开 unsigned long long。

### Code

```cpp
#include <vector>
#include <array>
#include <iostream>

int n, ans;
std::vector<int> stk;
std::array<unsigned long long, 1000005> a;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n;
  for (int i = 1; i <= n; ++i) {
    std::cin >> a.at(i);
    while (stk.size() && (a.at(i) >= a.at(stk.back()))) {
      ans ^= stk.back();
      stk.pop_back();
    }
    stk.push_back(i);
    ans ^= i;
    std::cout << ans << '\n';
  }
}
```

### Note

练习题： 

P6510  
P6503  
CF5E



---

## 作者：zxf_imp8 (赞：25)

[题目传送门](https://www.luogu.com.cn/problem/B3666)
### 题意
输入一个数列，每输入一个数后，找到所有它后面的数都比它小的数的下标，并求出这些下标的异或和。

------------

### 分析
#### Case 1：如何找到所有后缀最大值

下标 $i$ 不是后缀最大值，当且仅当 $a_i$ 后面有不小于它的数 $a_j$。那么此后不论输入多少数，都有 $a_i \leq a_j$，那么 $i$ 就不可能再是后缀最大值了。

![](https://cdn.luogu.com.cn/upload/image_hosting/6unx57r3.png)

如上图，我们把数列中每个数都看作一个人，所有人都向后看，如果看到队尾，就说明这个人的下标是后缀最大值。如果一个人看不到队尾，说明有人把他挡住了，那么他就不可能再看到队尾了，此时我们可以把他移出数列。

每个人进入数列时都会挡住所有比他矮的人，此时，移出所有比他矮的人。那么易知数列总是单调递减的。所以当我们需要移出人的时候，只需要从队尾移出，直到队尾的人比要进来的人高。

这不就是单调栈吗？

------------

#### Case 2：求异或和

异或运算最重要的性质就是**自反性**。

也就是 $(a \oplus b) \oplus b = a$。

我们维护的单调栈中都是当前的后缀最大值，所以当有人被移出或进入时，将答案与他的下标做异或运算即可。

------------

为了方便大家~~抄代码~~学习，我就把代码放在这了。
```cpp
#include<cstdio>
#include<stack>
using namespace std;

struct node{
	unsigned long long val;//存数据，记得开unsigned long long 
	int num;//存下标 
};

stack<node> a;//单调栈 
int n;
node t; 
int ans = 0;

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%llu", &t.val);
		t.num = i;
		while(a.empty() == false && a.top().val <= t.val){//出栈直到栈空或栈顶元素大于当前元素，记得判断栈空，用<= 
			ans ^= a.top().num;//消除出栈元素影响 
			a.pop();
		}
		a.push(t);
		ans ^= a.top().num;
		printf("%d\n", ans);
	}
	return 0； 
}
```


---

## 作者：Def_int_void (赞：9)

在讲单调栈之前，我想先说说**异或和**。

注：修 bug 多交了几遍，见谅，管理员辛苦了。


异或和，~~顾名思义~~，就是数列里所有数字异或的结果。

### 例子：

在数列 $1,1,4,5,1,4$ 中,她们的异或和即 $1\bigoplus 1\bigoplus 4\bigoplus 5\bigoplus 1\bigoplus 4$。

异或，即在二进制中不进位加法。

举例 $10 \bigoplus 15$：

  $10$   $1$   $0$   $1$   $0$  
  $15$   $1$   $1$   $1$   $1$  
  $05$   $0$   $1$   $0$   $1$

易证
 $a \bigoplus b \bigoplus b = a,a \bigoplus b \bigoplus c = a \bigoplus c \bigoplus b$。 ~~其实是不会证。~~


------------

接下来是重点部分：
# 单调栈

单调栈保证了栈里的元素存在某种顺序。

### 举个例子：
现有元素 $3$ $4$ $5$ $4$ $3$。

要求单调栈满足栈内元素**从大到小**排序。
1. 第一次操作 我们让元素 $3$（下标为 $1$）进栈。

栈内元素：$3$

栈外元素：$4$ $5$ $4$ $3$

2. 第二次操作，在元素 $4$（下标为 $2$）入栈前，我们把 $4$ 与 $3$ 比较发现 $4 > 3$。

为了维护栈里的元素从大到小排序，我们选择将 元素 $3$ 移除栈。

栈内元素：$4$

栈外元素：$5$ $4$ $3$

3. 第三次操作，同理，在元素 $5$（下标为 $3$）入栈前，把元素 $4$ 出栈。

栈内元素：$5$

栈外元素：$4$ $3$

4. 第四次操作：将元素 $4$（下标为 $4$）入栈，因为 $4 < 5$ 所以元素 $5$ 无需出栈。

栈内元素：$5$ $4$ 

栈外元素：$3$


5. 第五次操作：将元素 $3$ （下标为 $5$）入栈，同理，栈内元素都无需出栈。

栈内元素：$5$ $4$ $3$

栈外元素：  


------------

发现什么了？无论何时，栈内元素都是从大到小排序的。


------------
下面进入正题。

## 题目大意：一串数列按顺序入单调栈，单调栈里的元素从大到小排序，计算每次每个元素入栈时，栈内元素下标的异或和。

单调栈的内容已经讲过不再赘述。

Q：如何求下标的异或和？

A：先声明一个变量，无论元素入栈还是出栈都和她异或，根据异或的基本性质，可以求出栈内的异或和。

例子：

假设原栈内元素为 $a$。

元素 $b$ 入栈后异或和为 $a \bigoplus b$ , 元素 $ c $ 入栈后异或和为  $a \bigoplus b \bigoplus c$。

这时候元素 $b,c$ 分别出栈，元素 $d$ 入栈，异或和为 $a \bigoplus b \bigoplus c \bigoplus b \bigoplus c \bigoplus d = a \bigoplus d$ 。

此时栈内元素恰好为 $a,d$。

最后注意数据范围，必须开 `unsigned long long`。

话不多说，上代码（原谅我的马蜂）。

```cpp
//注意：使用STL需开O2优化
#include<bits/stdc++.h>
#define int unsigned long long
#define mod 90007
#difine inf 0x7fffffff

using namespace std;
int n;
struct node{
	int x,y;
}a[3000000];//创建数组，x为数字，y为下标
stack<node>s;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;
		a[i].y=i; //下标为输入时的顺序
	}
	int v=1;
	int ans=0;
	while(v<=n){ //v==n时最后一个元素还没有入栈，所以v=n+1时才能退出
		while(!s.empty()&&s.top().x<a[v].x){
			ans^=s.top().y; //出栈时异或
			s.pop(); //维护栈的单调性，小于她的都出栈
		}
		s.push(a[v]); //入栈
		ans^=a[v].y; //异或新入栈的
		cout<<ans<<endl; //输出答案
		v++; //准备下一个下标
	}
}
```




---

## 作者：_O_v_O_ (赞：6)

单调栈模板题，不过有些细节。

这题需要用到**单调栈**和**异或**的知识。

- 单调栈：由于此题的单调栈比较基础，所以只用到基础单调栈的知识即可。

单调栈：顾名思义，就是栈内单调的栈，那么如何维护这样的一个栈呢？其实很简单：只用在一个数入栈时反复跟栈顶对比，如果小于入栈的数（此处拿本题举例），则将栈顶弹出，直到满足条件为止，就将那个数入栈。

- 异或也是本题的一个重点，这里我们需要用到异或的一个重要性质：当一个数 $a$ 异或它自己时，结果为 $0$。也可以写成这样：$a \oplus a =0$。

最后就是本题的细节了：

- 不开 unsigned long long 见祖宗。
- 本题极其卡常，不能用普通的输入输出。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long  //细节1。

int n,ans;
struct node{
	int x,num;
};
stack<node> s;

signed main(){
	scanf("%llu",&n);  //细节2，用 scanf 和 printf。
	for(int i=1;i<=n;i++){
		int a;
		scanf("%llu",&a);
		while(!s.empty()&&s.top().x<a){  //单调栈的构造。
			ans^=s.top().num;  //异或的性质。
			s.pop();
		}
		node nd;
		nd.x=a;
		nd.num=i;
		s.push(nd);
		ans^=i;
		printf("%llu\n",ans);
	}
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/113406456)

---

## 作者：Eleveslaine (赞：4)

先来介绍一下单调栈。

顾名思义，单调栈需要满足两个条件：是个栈；栈内元素满足单调性。  
作为栈，则必然支持两种操作：插入和删除。删除时直接 `stk.pop()` 即可。插入时，假设插入元素为 $x$，当前栈顶元素为 $y$，从栈顶到栈底依次递增。**当 $\boldsymbol{y>x}$ 时，$\boldsymbol{x}$ 可以直接入栈，原栈内元素不变**；**当 $\boldsymbol{y\le x}$ 时，为了保证单调性，需要先将 $\boldsymbol{y}$ 出栈。**  
出栈后新的栈顶还可能 $\le x$，那么我们一直出栈（出栈后的 $y$ 不会重新入栈），直到满足栈顶 $>x$，可以入栈了。写作代码就是：

```cpp
while(!stk.empty() && stk.top() <= x)
    stk.pop();
stk.push(x);
```

这就是单调栈最核心的代码。那么单调栈是怎么和本题中的“后缀最大值”扯上关系的呢？考虑加入 $x$ 时，作为末尾元素，$x$ 一定是后缀最大值之一。对于其他原先是后缀最大值的 $y$，**如果 $\boldsymbol{y>x}$，那么 $\boldsymbol{y}$ 仍然是后缀最大值**；**如果 $\boldsymbol{y\le x}$，那么 $\boldsymbol{y}$ 之后存在了一个比 $\boldsymbol{y}$ 大（或相等）的元素，于是 $\boldsymbol{y}$ 就不再是后缀最大值了。**

观察上文加粗的两个部分，发现本题中的插入操作与单调栈的插入操作之间存在某种对应关系：它们都是对 $y>x$ 和 $y \le x$ 两种情况的分类讨论。这样，单调栈内维护的就一定都是序列的后缀最大值。入栈，代表有了新的后缀最大值；出栈，代表某个值不再是后缀最大值。

代码上，栈内存储序列元素的下标（而不是元素的值），这些下标对应的值满足单调性。设 `ans` 是后缀最大值（而不是下标）的集合。

```cpp
int n,a[maxn];
vector <int> stk; //用 vector 模拟栈，比 stack 要快
set <int> ans;
int main()
{
    n=read<int>();
    for(int i=1;i<=n;++i)
    {
        a[i]=read<int>();
        while(!stk.empty() && a[stk.back()]<=a[i]) ans.erase(a[stk.back()]),stk.pop_back();
        stk.push_back(i);
        ans.insert(a[i]);
        for(auto j:ans)
            printf("%d ",j);
        putchar('\n');
    }
    return 0;
}
```

而本题要求下标（而不是值）的异或和。注意到 $x \oplus x=0$，所以 `ans.erase` 与 `ans.insert` 都可以用异或来等效替代（`erase` 之前这个元素肯定已经被异或一次了，再异或一次等于删除），这也就是本题了。此外要注意什么时候开 `unsigned long long` 什么时候不开。

```cpp
#define maxn 1000005
int n,ans;
ull a[maxn];
vector <int> stk;
int main()
{
    n=read<int>();
    for(int i=1;i<=n;++i)
    {
        a[i]=read<ull>();
        while(!stk.empty() && a[stk.back()]<=a[i]) ans^=stk.back(),stk.pop_back();
        stk.push_back(i);
        ans^=i;
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：chenhaoyou (赞：4)

# 主要算法：单调栈
### 1. 啥是单调栈
单调栈是单调队列的兄弟，都具有单调性，单调栈是先进后出的，这种数据结构在栈的基础上，栈内的元素是单调有序的，所以单调栈分为单调递增栈和单调递减栈（增减性的划分是根据栈顶到栈底的元素变化规律）。
### **模板：**
```cpp
strak<int> st;
for 遍历整个数组
{
    cin x;
    while ( 栈不空 and x大于栈顶 )
    {
        st.pop();
        弹出栈顶，保持单调性
    }
    st.push(x);
    x压入栈中
}
```

因为题目中规定 $i<j$ 符合先进先出， $a_{i}>a_{j}$ 符合单调性，前面的数一定大于后面的数，所以这道题用单调栈。
### 2.  代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long//2^64次方,所以开unsigned long。long。
ll ans,x,n;
struct f{
	ll s,i;//分别存值和下标。
};
stack<f> st;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(ll i=1;i<=n;i++)
	{
		cin>>x;
		while(!st.empty() && x>=st.top().s)//如果栈不空且当前数小于x就把他弹出，因为ai>aj,维持单调性。
		{
			ans^=st.top().i;//把要弹出的数再异或一遍，同一个数异或两遍=没异或这个数。
			st.pop();
		}
		st.push((f){x,i});//加入当前数。
		ans^=i;
		cout<<ans<<"\n";
	}
	return 0;
}

```
### 3.关于单调栈的题目
	
[USACO09MAR Look Up S](https://www.luogu.com.cn/problem/P2947)




---

## 作者：Sun_Email (赞：3)

这题需要用到 **单调栈**。

首先，我们需要了解一下单调栈的原理：

每次给一个数，先判断这个数和队顶的大小，若栈非空且栈顶小于（这里可以随机应变）这个数，就弹出这个数，直到找到一个比这个数大的数或者栈空为止，然后把这个数入栈即可。

可以发现，这个单调栈就是专门针对“后缀最值”问题的数据结构。

最后就是由于 $x_i \le 2^{64}$，注意开 unsigned long long。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll n,x,ans=0;
struct Val{
	ll v,id;
};
stack<Val> s;
int main(){
	scanf("%llu",&n);
	for(int i=1;i<=n;++i){
		scanf("%llu",&x);
		ans^=i;
		while(!s.empty()&&s.top().v<=x){
			//z^z=0
			ans^=s.top().id;s.pop();
		}
		s.push((Val){x,i});
		printf("%llu\n",ans);
	}
	return 0;
}
```


---

## 作者：SmallTownKid (赞：3)

还没有手写单调栈的做法，来一发手写栈。怎么想到要用单调栈呢？其实单调栈处理的问题就是求一个数前面第一个比它大/小的数是哪个，也就是遮挡视线问题，此题求的就是这类问题，由于我们要求异或和，所以单调栈里存的就是满足题意的序列的数的下标，当我们弹出或者压入栈时，动态处理异或和即可。
```
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int n,top;
unsigned long long ans;
unsigned long long a[1000010];
int stack1[1000010];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%llu",&a[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(!top)
		{
			stack1[++top]=i;
			ans^=i;
			printf("%llu\n",ans);
		}
		else
		{
			if(a[i]<a[stack1[top]])
			{
				stack1[++top]=i;
				ans^=i;
			}
			else
			{
				while(top!=0&&a[i]>=a[stack1[top]])
				{
					ans^=stack1[top];
					top--;
				}
				stack1[++top]=i;
				ans^=i;
			}
			printf("%llu\n",ans);
		}
	}
	return 0;
}
```

---


# [蓝桥杯 2023 国 C] 最大区间

## 题目描述

给定一个长度为 $n$ 的序列 $A_i$，求 $L, R$ 使 $(R - L + 1) \cdot \min(A_L, A_{L+1}, \ldots, A_R)$ 尽可能大，其中 $\min$ 表示最小值。

你只需要输出最大的值即可，不需要输出具体的 $L, R$。

## 说明/提示

### 评测用例规模与约定

对于 $40\%$ 的评测用例，$1 \leq n \leq 5000$，$1 \leq A_i \leq 5000$；

对于所有评测用例，$1 \leq n \leq 3 \times 10^5$，$1 \leq A_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 1 3 3 1```

### 输出

```
6```

# 题解

## 作者：fkxr (赞：10)

怎么全是单调栈题解？那我写一篇 ST 表二分的吧。

枚举 $i$，计算最小值是 $a_i$ 时的区间最大长度（ST 表二分向前后找），取 $\max\{a_i\times len\}$ 就是答案。

# code:
```cpp
//Do not hack it
// @author       fkxr(luogu uid=995934)
#include <bits/stdc++.h>
#define endl cerr<<"------------------I Love Sqrt Decomposition------------------\n";
#define int long long
using namespace std;
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc getchar
#define pc putchar
#endif

#define ds(x) (x=='\r'||x=='\n'||x==' ')
#define MAX 20
namespace fastIO {
	template<typename T>inline void r(T& a) { a = 0; char ch = gc(); bool ok = 0; for (; ch < '0' || ch>'9';)ok ^= (ch == '-'), ch = gc(); for (; ch >= '0' && ch <= '9';)a = (a << 1) + (a << 3) + (ch ^ 48), ch = gc(); if (ok)a = -a; }
	template<typename T>inline void w(T a) { if (a == 0) { pc('0'); return; }static char ch[MAX]; int till = 0; if (a < 0) { pc('-'); for (; a;)ch[till++] = -(a % 10), a /= 10; } else for (; a;)ch[till++] = a % 10, a /= 10; for (; till;)pc(ch[--till] ^ 48); }
	struct Srr {
		inline Srr operator>>(int& a) { r(a); return{}; }
		inline Srr operator>>(char& ch) { ch = gc(); for (; ds(ch);)ch = gc(); return{}; }
		inline Srr operator>>(string& s) { s = ""; char ch = gc(); for (; ds(ch);)ch = gc(); for (; !(ds(ch) || ch == EOF);) { s.push_back(ch); ch = gc(); }return{}; }
		template<typename T>inline Srr operator<<(T& a) { r(a); return{}; }
		inline void is(int n, string& s) { s = ""; char ch = gc(); for (; ds(ch);)ch = gc(); for (; n--;) { s.push_back(ch); ch = gc(); } }
	}in;
	struct Sww {
		inline Sww operator<<(const int a) { w(a); return{}; }
		inline Sww operator<<(const char ch) { pc(ch); return{}; }
		inline Sww operator<<(const string s) { for (int i = 0; i < s.size(); i++)pc(s[i]); return{}; }
		template<typename T>inline Sww operator>>(const T a) { w(a); return{}; }
	}out;
}using fastIO::in; using fastIO::out;
#undef ds
#define eout cerr

namespace Maths {
	const bool __is_P[] = { 0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1 };
	inline bool IP1(const int a) { if (a <= 29)return __is_P[a]; if (a % 2 == 0 || a % 3 == 0 || a % 5 == 0)return 0; for (int i = 6;; i += 6) { if (((i + 1) * (i + 1)) > a)return 1; if (a % (i + 1) == 0)return 0; if (((i + 5) * (i + 5)) > a)return 1; if (a % (i + 5) == 0)return 0; } }
#define times(a,b,m) (c=(unsigned long long)a*b-(unsigned long long)((long double)a/m*b+0.5L)*m,c<m?c:m+c)
	inline int power(int a, int b, const int mod = -1) { unsigned long long c; int ans = 1; if (mod == -1) { for (; b;) { if (b & 1)ans *= a; b >>= 1; a *= a; }return ans; }for (; b;) { if (b & 1)ans = times(ans, a, mod); b >>= 1; a = times(a, a, mod); }return ans; }
	const int Suk[] = { 2,325,9375,28178,450775,9780504,1795265022 };
	inline bool chk(const int n, int a, int b, int x) { if (x >= n) return 1; unsigned long long c; int v = power(x, a, n); if (v == 1)return 1; int j = 1; while (j <= b) { if (v == n - 1)break; v = times(v, v, n); j++; }if (j > b)return 0; return 1; }
	inline bool IP(int n) { if (n < 3 || n % 2 == 0)return n == 2; if (n <= 1e6) { return IP1(n); } else { int a = n - 1, b = 0; while (a % 2 == 0)a >>= 1, b++; for (int k : Suk)if (!chk(n, a, b, k))return 0; return 1; } }
#undef times
} using Maths::power;
using Maths::IP;

namespace exs{
#define _4x _4x
#ifdef _4x
	int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
#else
	int dx[]={1,0,-1,-1,1,1,0,-1},dy[]={1,1,1,0,0,-1,-1,-1};
#endif
	template<typename T,typename T1,typename T2>inline bool rg(T l,T1 r,T2 x){return l<=x&&x<=r;}
	inline bool emc(const int&a,const int&b){return a>b;}
}using namespace exs;

//#define BIT BIT 
#ifdef BIT
namespace BIT {//下标从1开始
#define maxn 100005
	struct ds {//打死要记住初始化 ds.n
		int c0[maxn], c1[maxn], n;
		inline void Add(int* c, int p, int v) { for (; p <= n; p += p & -p)c[p] += v; }
		inline int Sum(int* c, int p) { int t = 0; for (; p; p -= p & -p)t += c[p]; return t; }
		inline int sum(int l, int r) { return Sum(c0, r) * r - Sum(c1, r) - Sum(c0, l - 1) * (l - 1) + Sum(c1, l - 1); }
		inline void add(int l, int r, int v) { Add(c0, l, v); Add(c0, r + 1, -v); Add(c1, l, (l - 1) * v); Add(c1, r + 1, -r * v); }
		inline void init(int* c, int len) { int last = 0; for (int i = 1; i <= len; i++) { last = c[i] - last; Add(c0, i, last); Add(c1, i, last * (i - 1)); last = c[i]; } }
	};
#undef maxn
}using namespace BIT;
#endif

#define ST ST
#ifdef ST
namespace ST {//下标从1开始
	struct st {
#define maxn 300005
#define bq min
		int lg[maxn], f[20][maxn];
		inline void init(int*c, int len) { for (int i = 2; i <= len; i++)lg[i] = lg[i >> 1] + 1; for (int i = 1; i <= len; i++)f[0][i] = c[i]; for (int j = 1; (1 << j) <= len; j++) { for (int i = 1; i + (1 << j) - 1 <= len; i++)f[j][i] = bq(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]); } }
		inline int q(int l, int r) { int j = lg[r - l + 1]; return bq(f[j][l], f[j][r - (1 << j) + 1]); }
	};
#undef maxn
#undef bq
}using namespace ST;
#endif
st t;
int a[300005];
signed main() {
	int n;
	in>>n;
	a[1]=a[n+2]=0;
	for(int i=2;i<=n+1;i++)
		in>>a[i];
	t.init(a,n+2);
	int ans=0;
	for(int i=2;i<=n+1;i++){
		int L=i,l=1,r=i;
		for(;l<=r;){
			int mid=l+r>>1;
			if(t.q(mid,i)!=a[i])
				l=mid+1;
			else
				r=mid-1,L=mid;
		}
		int R=i;l=i,r=n+1;
		for(;l<=r;){
			int mid=l+r>>1;
			if(t.q(i,mid)!=a[i])
				r=mid-1;
			else
				l=mid+1,R=mid;
		}
		ans=max(ans,a[i]*(R-L+1));
	}
	out<<ans<<'\n';
	return 0;
}
```
[提交记录](https://www.luogu.com.cn/record/217292815)

时间复杂度明显是 $O(n\log n)$。

---

## 作者：weapons (赞：7)

考试的时候，脑子抽了，没有看清数据范围，暴力结果二十分。
### 思路
因为在最小值相同时，区间越长答案最优，所以对于每一数值，我们考虑求一范围，使得这一数值在此范围内最小。于是——单调栈！
#### 代码实现
维护一个不下降单调栈，正反跑两遍单调栈，以求出每一数值的最大范围。贴上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[300005], n, r[300010], ll[300010];//实测不开long long 50pts。
// r 数组右区间，ll 数组左区间。

void read() {
	cin >> n;
	for (long long i = 1; i <= n; i++) {
		cin >> a[i];
	}
	stack<long long>k;
	k.push(1);
	long long ans = 0;
	for (long long i = 2; i <= n; i++) {
		while (!k.empty() && a[k.top()] > a[i]) {
			r[k.top()] = i;
			k.pop();
		}
		k.push(i);
	}
	while (!k.empty()) {
		long long t = k.top();
		r[t] = n + 1;
		k.pop();
	}//求出右区间
	stack<long long>q;
	q.push(n);
	for (long long i = n - 1; i >= 1; i--) {
		while (!q.empty() && a[q.top()] > a[i]) {
			ll[q.top()] = i;
			q.pop();
		}
		q.push(i);
	}
	while (!q.empty()) {
		long long t = q.top();
		ll[t] = 0;
		q.pop();
	}//求出左区间
	for (long long i = 1; i <= n; i++) {
		ans = max((r[i] - ll[i] - 1) * a[i], ans);
	}
	cout << ans;
}

int main() {
	read();
}
```
第一次写题解，如有错误，还请指出。

---

## 作者：chenzefan (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P12241)
## 涉及知识
**单调栈**，不了解的可以做一做模板题，[P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)。
## 思路
首先暴力，不停的求，只有 **20pts**。

考虑优化，不难发现，当多个区间内最小值 $\min$ 相同时，区间长度（即 $R−L+1$）越长，答案越优。不难想到用**单调栈**进行区间维护。

只需对于输入的每个 $A_i$ 求一下在哪个长度最大的区间中是区间内元素的最小值 $\min$ 即可。

维护两个单调不降的单调栈，正着和反着各算一遍，用数组 $l$ 和 $r$ 保存下标，就能算出区间长度，然后合并答案，求最大值 $\max$ 即可。

时间复杂度 $O(n)$,可以通过。

注意：
- 一定要开 **long long**，不然只有 **50pts**。
- 计算答案时要特判 $r_i$ 等于 $0$ 的情况，不然只有 **45pts**。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //一定要开 long long 
const int N=3e5+5;
int n,a[N];
int l[N],r[N];//一个正着来，一个反着来，是保存下标的数组 
stack <int> s1,s2;//定义两个单调栈
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",a+i);
	for(int i=1;i<=n;i++){//正着遍历，维护单调不降 
		while(!s1.empty()&&a[s1.top()]>a[i]) r[s1.top()]=i,s1.pop();
		s1.push(i);
	}
	for(int i=n;i>=1;i--){//反着遍历，维护单调不降 
		while(!s2.empty()&&a[s2.top()]>a[i]) l[s2.top()]=i,s2.pop();
		s2.push(i);
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		int left=l[i]+1,right=r[i]-1;
        //当 l[i]=0 时，将左顶点设为 1 
		if(l[i]==0) left=1;//可以不加
		//当 r[i]=0 时，将右顶点设为 n
		if(r[i]==0) right=n;//不加这句只有 45pts 
	    ans=max(ans,(right-left+1)*a[i]);//求答案 
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：aluo2013 (赞：4)

# P12241 [蓝桥杯 2023 国 C] 最大区间 题解
## 思路分析
由于 $n \le 3 \times 10^5$，又有 $L$ 和 $R$，求区间最小值，可以用 $O(n)$ 的单调栈解决。我们可以把 $a_i$ 看做是这个区间的最小值，往左找第一个小于 $a_i$ 的数的下标，当做 $L$，再往右找第一个小于 $a_i$ 的数的下标，当做 $R$，最后答案就是 $\max\{a_i \times (R_i - L_i - 1)\}$。由于答案最大可能为 $n \times a_i$，最大也就是 $3 \times 10^5 \times 10^9 = 3 \times 10^{14}$，要记得开 `long long`。
## 代码实现
```cpp
#include <cstdio>
#include <stack>
using namespace std;
int n,a[300005],l[300005],r[300005];//l[i]和r[i]就是思路中的L_i 和 R_i
long long ans;
stack<int> s;//存下标
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for(int i = 1;i <= n;i++){//算r[i]
		while(!s.empty() && a[s.top()] > a[i]){
			r[s.top()] = i;
			s.pop();
		}
		s.push(i);
	}
	while(!s.empty()){//重复利用
		r[s.top()] = n+1;//如果右边没有小于它的数，r[i]就等于n+1，因为最后算答案的时候要-1
		s.pop();
	}
	for(int i = n;i >= 1;i--){//算l[i]
		while(!s.empty() && a[s.top()] > a[i]){
			l[s.top()] = i;
			s.pop();
		}
		s.push(i);
	}
  //因为这里如果左边没有小于它的数，l[i]就等于0，也就是初始值，所以不需要像前面那样特判
	for(int i = 1;i <= n;i++) ans = max(ans,(r[i]-l[i]-1) * 1ll * a[i]);//记得要把 int 转 long long
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：zhz_cptbtptp (赞：4)

这道题考试的时候脑子抽抽了，没想到单调栈，写的暴力只得了二十分。

实际上这道题就是一点单调栈加一点点内容。

没学过单调栈的朋友可以先看看这道题：[单调栈模板](https://www.luogu.com.cn/problem/P5788)。

这道题的整体思路就是求左右两边**第一个小于**该数的位置，因为题目要在**区间里的最小值**，所以求取了该数左右两边的比它小的之后，可以保证在**左右两个区间内的数都比该数大**，所以求**左右两边的区间的长度**乘**该点的高度**就可以了。

话不多说，上代码。

```cpp
#include<bits/stdc++.h>
#define int long long//十年oi一场空，不开longlong见祖宗
using namespace std;
const int maxn=1e6+5;
int a[maxn],n,l[maxn],r[maxn];

void read(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
	}
}

int top,q[maxn];
int ans;

void ddz(){//单调栈模板
	q[++top]=1;
	for(int i=2;i<=n;++i){
		while(top!=0&&a[i]<a[q[top]]){
			int k=q[top--];
			l[k]=q[top];//求左区间
			r[k]=i;//求右区间
			ans=max(ans,(r[k]-l[k]-1)*a[k]);//求答案最大值
		}
		q[++top]=i;
	}
	while(top!=0){//结算
		int k=q[top--];
		l[k]=q[top];
		r[k]=n;
		ans=max(ans,(r[k]-l[k])*a[k]);
	}
	printf("%lld",ans);
}

signed main(){
	read();
	ddz();
	return 0;//养成好习惯
}
```
华丽的结束。

---

## 作者：_Deer_Peach_ (赞：4)

题意已经很简洁了不再赘述。

思路：

单调栈很模板的题目，只需要正反各做一次单调栈就可以了。具体证明如下：

设一个区间为 $[L,R]$，$x=\min(A_L,A_{L+1},\dots,A_R)$，则这个区间答案为 $(R-L+1) \times x$。如果 $A_{L-1}$ 或 $A_{R+1}$ 大于等于 $x$，则区间 $[L,R]$ 还可以扩大范围使得答案更大，也就是不是最优的。

那么反过来想，是不是如果 $[L,R]$ 是最优的，则 $A_{L-1}$ 与 $A_{R+1}$ 都小于 $x$？可以从这出发开始想，枚举每一个数所能得到的区间的最大答案，也就是枚举 $A_i$，此时 $x=A_i$，因为区间中不可以出现比 $x$ 小的数，那么就可以用单调栈分别求出 $A_i$ 前后第一个小于 $A_i$ 的数，再计算区间答案即可。

代码：
```
  #include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=3e5+5;
int n;
int h[N];
int l[N],r[N];
signed main(){
	IOS;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	stack<int>s,ss;//两次单调栈
	for(int i=1;i<=n;i++){
		while(!s.empty()&&h[s.top()]>h[i])r[s.top()]=i,s.pop();
		s.push(i);
	}
	for(int i=n;i>=1;i--){
		while(!ss.empty()&&h[ss.top()]>h[i])l[ss.top()]=i,ss.pop();
		ss.push(i);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		int L=(l[i]==0?1:l[i]+1),R=(r[i]==0?n:r[i]-1);//l=0或r=0表示前或后没有比a[i]小的数，所以赋值1或n
		res=max(res,(R-L+1)*h[i]);
	}
	cout<<res;
	return 0;
}

```

---

## 作者：__liujy (赞：3)

单调栈模板题。

我们可以设 $a_{i}$ 为某一区间内的最小值，因此只要向左和右去扩区间，找到满足条件的最大的区间就可以了。

这个过程可以先写一个暴力，但明显不能过，这时候就得用单调栈去优化了。不过需要注意，若操作完栈内还有剩余的数，那也需要处理。

最后在 $a_{i} \times (r_{i}-l_{i}-1)$ 中取最大值就行了，其中 $l_{i}$ 和 $r_{i}$ 为第 $i$ 个数所能扩张的最大区间的左端点和右端点。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
typedef long long LL;
int n,a[N],l[N],r[N];
LL ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	stack<int> st;
	st.push(1);
	for(int i=2;i<=n;i++)
	{
		while(st.size()&&a[st.top()]>a[i])
		{
			r[st.top()]=i;
			st.pop();
		}
		st.push(i);
	}
	while(st.size())
	{
		r[st.top()]=n+1;
		st.pop();
	}
	st.push(n);
	for(int i=n-1;i>=1;i--)
	{
		while(st.size()&&a[st.top()]>a[i])
		{
			l[st.top()]=i;
			st.pop();
		}
		st.push(i);
	}
	while(st.size())
	{
		l[st.top()]=0;
		st.pop();
	}
	for(int i=1;i<=n;i++) ans=max(ans,1LL*a[i]*(r[i]-l[i]-1));
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Heyg_future (赞：3)

# [蓝桥杯 2023 国 C] 最大区间
## [题目传送门](https://www.luogu.com.cn/problem/P12241)
## 阅读须知
本题要用到单调栈知识，如果你还不会单调栈，[请去这里学习](https://www.luogu.com.cn/problem/P5788)。
## Solution
本题思路其实还是比较容易想到。我一开始是想从边界入手，但是其实没有这么麻烦，不如从区间中的最小值入手，用单调栈即可解决。

思路是这样子的，首先过两遍单调栈，正反各过一次，即可找出对于所有 $a_i$ 后方与前方第一个比它小的数的下标为 $f1_i$ 与 $f2_i$ 。
特别地，在过单调栈时如果一个数前方或后方无更小值，则返回 $0$ 或 $n+1$。

此部分代码如下。
```cpp
for(int i=n;i>=1;i--) {
  while(a[i]<=a[s1[r]]&&r>0) r--;
  if(r)f1[i]=s1[r];
  else f1[i]=n+1;
  s1[++r]=i;
}
//寻找后方第一个比它小的数
r=0;
for(int i=1;i<=n;i++){
  while(a[i]<=a[s2[r]]&&r>0) r--;
  if(r)f2[i]=s2[r];
  else f2[i]=0;
  s2[++r]=i;
}
////寻找前方第一个比它小的数
```
那么 $a_i$ 是 $[f2_i,f1_i]$ 区间内的最小值。这样使最小值确定的情况下，区间最长,即题目所说的 $(L-R+1)$ 的值最大。再用记录答案即可。

此部分代码如下。
```cpp
ans=max(ans,( (f1[i]-1) - (f2[i]+1) +1)*a[i]);
```
则最终代码如下。
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
const int N=3*1e6;
using namespace std;
ll n,a[N],r,f1[N],f2[N];
ll s1[N],s2[N];
//这里用了手工栈
ll ans=-1e18;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=n;i>=1;i--) {
		while(a[i]<=a[s1[r]]&&r>0) r--;
		if(r)f1[i]=s1[r];
		else f1[i]=n+1;
		s1[++r]=i;
	}
	r=0;
	for(int i=1;i<=n;i++){
		while(a[i]<=a[s2[r]]&&r>0) r--;
		if(r)f2[i]=s2[r];
		else f2[i]=0;
		s2[++r]=i;
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,( (f1[i]-1) - (f2[i]+1) +1)*a[i]);
	}
	cout<<ans;
	return 0;
}
```
时间复杂度 $O(n)$ 即可通过此题啦。

---

## 作者：lmq308270 (赞：2)

~~竟然没有人用悬线法。~~

思路：

我们可以假设以某一个 $A_i$ 为最小值，使其向左右延伸。显然地，延伸的区间越长越好，那就可以用悬线法求出区间（即求出左右第一个大于它的位置。），最后求最大值即可。

悬线法：

定义 $l_i$ 为当前找到的 $i$ 位置的悬线能扩展到的最左边的位置，容易得到 $l_i$ 初始为 $i$，我们需要进一步判断还能不能进一步往左扩展。

如果当前 $ l_i = 1$，则已经扩展到了边界，不可以。

如果当前 $a_i > a_{l_i - 1}$，则从当前悬线扩展到的位置不能再往左扩展了。

如果当前 $a_i \le a_{l_i - 1}$，则从当前悬线还可以往左扩展，并且 $l_i - 1$ 位置的悬线能向左扩展到的位置，$i$ 位置的悬线一定也可以扩展到，于是我们将 $l_i$ 更新为 $l_{l_i - 1}$，并继续执行判断（内容来自[悬线法](https://oi-wiki.org/misc/hoverline/)）。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=3e5+5;
int n,ans;
long long a[N],l[N],r[N];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		l[i]=r[i]=i;
	}	
	for(int i=1;i<=n;i++)
		while(l[i]>1&&a[i]<=a[l[i]-1])l[i]=l[l[i]-1];
	for(int i=n;i>=1;i--)
		while(r[i]<n&&a[i]<=a[r[i]+1])r[i]=r[r[i]+1];
	for(int i=1;i<=n;i++)
		if((r[i]-l[i]+1)*a[i]>ans)
			ans=(r[i]-l[i]+1)*a[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：_WCW_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12241)
## 解题思路
可以枚举每个 $A_i$ 为最小值的情况，之后计算出 $A_i$ 为最小值时的 $L$ 和 $R$，之后取所有解中的最大值就可以。根据这个思路，我们可以写出第一版代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[300010],ans;
signed main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)
    {
        int l=i,r=i;
        while(l>=1 && a[l]>=a[i]) l--;
        while(r<=n && a[r]>=a[i]) r++;
        ans=max(ans,(r-l-1)*a[i]);
    }
    printf("%lld",ans);

    return 0;
}
```
测试后发现，上面的代码超时了，主要是因为计算 $L$ 和 $R$ 时会用去大量时间。这时候就要用单调栈，维护一个单调递增栈，将每轮枚举的 $A_i$ 入栈，如果 $A_i$ 入栈后会破坏栈单调递增的性质，就将栈顶元素出栈，出栈到 $A_i$ 入栈不会破坏栈的性质为止，这时栈顶元素就是满足条件的 $L$（因为栈顶元素此时必然比 $A_i$ 小），将其记录下来，之后再将 $A_i$ 入栈。计算 $R$ 也是一样的道理，只不过需要倒着枚举。
## [AC](https://www.luogu.com.cn/record/223981713) 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[300010],l[300010],r[300010];//l[i]和r[i]记录a[i]为最小值的L和R
long long ans;//记录最终结果，一定要开long long
stack<int> s;//记录下标的栈
int read()//快速读入，不理解可以看P10815
{
    int ans=0,zf=1;
    char c=getchar_unlocked();
    while(!isdigit(c))
    {
        if(c=='-') zf=-1;
        c=getchar_unlocked();
    }
    while(isdigit(c))
    {
        ans=ans*10+c-'0';
        c=getchar_unlocked();
    }
    return ans*zf;
}
int main()
{
    n=read();//读入n
    for(int i=1;i<=n;i++) a[i]=read();//读入a[i]
    for(int i=1;i<=n;i++)//遍历每个a[i]，计算L
    {
        while(!s.empty() && a[s.top()]>=a[i]) s.pop();//如果栈非空并且栈顶元素大于a[i]就出栈
        if(!s.empty()) l[i]=s.top();//栈非空的情况下记录L为栈顶元素
        else l[i]=0;//否则设置为超过边界的0
        s.push(i);//将i入栈
    }
    while(!s.empty()) s.pop();//清空栈
    for(int i=n;i>=1;i--)//计算R
    {
        while(!s.empty() && a[s.top()]>=a[i]) s.pop();//如果栈非空并且栈顶元素大于a[i]就出栈
        if(!s.empty()) r[i]=s.top();//栈非空的情况下记录R为栈顶元素
        else r[i]=n+1;//否则设置为超过边界的n+1
        s.push(i);//将i入栈
    }
    for(int i=1;i<=n;i++) ans=max(ans,1ll*(r[i]-l[i]-1)*a[i]);//计算最大值，乘1ll转为long long
    printf("%lld",ans);//输出
    
    return 0;
}
```

---

## 作者：Transparent_fish (赞：1)

## 题目描述：

给定一个长度为 $n$ 的序列，我们需要找到一个区间 $[L,R]$，使得区间长度乘以区间最小值的乘积最大。由于数据非常大，所以直接暴力肯定不行。这时我们要引入一个新的数据结构，单调栈。

### 什么是单调栈？

> 单调栈是一种特殊的栈结构，它保证栈内元素始终保持单调性（单调递增或单调递减）。

## 思路：

在这个问题中，我们使用**单调递增栈**来帮助我们快速找到每个元素作为最小值时的左右边界。具体为：

1. 预处理每个元素的左右边界：

对于每个元素 $a_{i}$，使用单调栈找到左边第一个比它小的元素位置（左边界 $l_{i}$）。

使用单调栈找到右边第一个比它小的元素位置（右边界 $r_{i}$）。

这样 $a_{i}$ 就是区间 $[l_{i},r_{i}]$ 的最小值。

2. 计算最大乘积：

对于每个元素，计算：

$$
(r_{i}-l_{i}+1) \times a_{i}
$$

然后所有计算结果中的最大值即可。

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 3e5 + 5;
int n;
int ans;
int a[N];
int l[N], r[N];
stack<int>s;

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = n; i >= 1; i--) {
		while (!s.empty() && a[i] <= a[s.top()]) {
			s.pop();
		}
		if (s.empty()) {
			r[i] = n;
		} else if (!s.empty()) {
			r[i] = s.top() - 1;
		}
		s.push(i);
	}
	while (!s.empty()) {
		s.pop();
	}
	for (int i = 1; i <= n; i++) {
		while (!s.empty() && a[i] <= a[s.top()]) {
			s.pop();
		}
		if (s.empty()) {
			l[i] = 1;
		} else {
			l[i] = s.top() + 1;
		}
		s.push(i);
	}
	for (int i = 1; i <= n; i++) {
		ans = max(ans, (r[i] - l[i] + 1) * a[i]);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Listedzero (赞：1)

### 题目分析

题意：求数组中 $(R - L + 1) \cdot \min(A_L, A_{L+1}, \ldots, A_R)$ 的最大值。

核心思路：要使得某个区间的最小值与其长度最大，逐个遍历肯定会超时，那么我们要从最小值这个线索入手，所以当去遍历数组的某个值时，最好能找到一个最大区间，使得这个区间内的最大值就是这个数。那么为了求第一个小于这个数字的位置，我们可以使用单调栈。不严格递增单调栈因为其小于新入栈的这个数而出栈的条件，就可以在某个数出栈时去记录它的最右区间。

本题不需要进行两次单调栈操作。对于左侧的范围，如果有多个数值相同的，那么它们中的第一个将会取到最大值。

另外细节上，因为我用的标准模板库中的栈，所以要仔细处理调用栈时的边界，避免搞心态的运行时错误。

### 代码呈现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10;
int n,ans,a[N],L[N],R[N];
stack<int>st;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    st.push(0);
    for(int i=1;i<=n;i++){
        while(!st.empty() && a[st.top()]>a[i]){
            int top=st.top();st.pop();
            R[top]=i;
            L[top]=st.empty()?0:st.top();
            ans=max(ans,(R[top]-L[top]-1)*a[top]);
        }
        st.push(i);
    }
    while(!st.empty()){
        int top=st.top();st.pop();
        R[top]=n+1;
        L[top]=st.empty()?0:st.top();
        ans=max(ans,(R[top]-L[top]-1)*a[top]);
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：jingliang_youxi (赞：0)

## 重述题目：

给定一个长度为 $n$ 的序列 $A$，求 $L$ 和 $R$ 使 $(R - L + 1)  \times  A_R$ 到 $R$ 的值尽可能大，其中 $minn$ 表示最小值，最后输出最大的值即可。

## 思路：

首先我们要知道单调栈解决详见[单调栈](https://www.luogu.com.cn/problem/P5788)。

### 暴力：

最直观的方法是枚举所有可能的区间 $[L,R]$，计算每个区间的值，然后取最大值，这种方法的时间复杂度是 $O(n^2)$，对于 $n$ 较大的情况会超时。

### 基于单调栈的优化解法：

更高效的解法是使用单调栈，时间复杂度为 $O(n)$ , 主要思路是：

1‌. 对于每个元素 $A_i$，找到它作为最小值能扩展到的左右边界。

2. 找到左边界第一个比 $A_i$ 小的元素的位置。

3. 找到右边界第一个比 $A_i$ 小的元素的位置。

‌4. 计算最大值：对于每个元素 $A_i$，计算以它为最小值的最大区间值：$(R_i - L_i - 1) \times A_i$ 
‌取最大值，遍历所有元素，记录最大的计算结果。

### 分治法：

也可以使用分治法，将数组分成左右两部分，分别求解左右部分的最大值，然后考虑跨越中间元素的情况。

## Code：

我选择了单调栈的做法。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 3e5 + 5;
int n;
int ans;
int a[N];
int l[N], r[N];
stack<int>s;

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = n; i >= 1; i--) {
		while (!s.empty() && a[i] <= a[s.top()]) {
			s.pop();
		}
		if (s.empty()) {
			r[i] = n;
		} else if (!s.empty()) {
			r[i] = s.top() - 1;
		}
		s.push(i);
	}
	while (!s.empty()) {
		s.pop();
	}
	for (int i = 1; i <= n; i++) {
		while (!s.empty() && a[i] <= a[s.top()]) {
			s.pop();
		}
		if (s.empty()) {
			l[i] = 1;
		} else {
			l[i] = s.top() + 1;
		}
		s.push(i);
	}
	for (int i = 1; i <= n; i++) {
		ans = max(ans, (r[i] - l[i] + 1) * a[i]);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Chase12345 (赞：0)

单调栈。

钦定 $a_i$ 为某个区间的最大值，设为 $[L,R]$，则 $a_{L-1} > a_i$ 且 $a_{R+1} > a_i$。这里如果最小值已经定下来了，那么找出一个区间使得其最小值为这个已经定下来的数。即单调栈找出某个 $a_i$ 的右边最近的且小于 $a_i$ 的数，并找出某个 $a_i$ 的左边最近的且小于 $a_i$ 的数，这就是 $a_i$ 对答案的贡献。最后将所有 $a_i$ 的贡献取最大值即可。要注意处理边界。
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using pll = pair <i64, i64>;

const int N = 3e6 + 5;
stack <pll> stk, stk1;
i64 a[N], ans[N], ans1[N];

int main() {
	int n;
	i64 ret = 0;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = n; i >= 1; i--) {
		while (!stk.empty() && stk.top().second >= a[i])
			stk.pop();
		ans[i] = (stk.size() ? stk.top().first : n + 1);
		stk.push({i, a[i]});
	}
	for (int i = 1; i <= n; i++) {
		while (!stk1.empty() && stk1.top().second >= a[i])
			stk1.pop();
		ans1[i] = (stk1.size() ? stk1.top().first : 0);
		stk1.push({i, a[i]});
	}
	for (int i = 1; i <= n; i++)
		ret = max(ret, a[i] * (ans[i] - ans1[i] - 1));
	cout << ret << '\n';
	return 0;
}
```
# Update:
贴错代码了，附上了正确的代码。

---


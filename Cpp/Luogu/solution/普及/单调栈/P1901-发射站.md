# 发射站

## 题目描述

某地有 $N$ 个能量发射站排成一行，每个发射站 $i$ 都有不相同的高度 $H_i$，并能向两边（两端的发射站只能向一边）同时发射能量值为 $V_i$ 的能量，发出的能量只被两边**最近的且比它高**的发射站接收。显然，每个发射站发来的能量有可能被 $0$ 或 $1$ 或 $2$ 个其他发射站所接受。

请计算出接收最多能量的发射站接收的能量是多少。


## 说明/提示

对于 $40\%$ 的数据，$1\le N\le 5000,1\le H_i\le 10^5,1\le V_i\le 10^4$。

对于 $70\%$ 的数据，$1\le N\le 10^5,1\le H_i\le 2\times 10^9,1\le V_i\le 10^4$。

对于 $100\%$ 的数据，$1\le N\le 10^6,1\le H_i\le 2\times 10^9,1\le V_i\le 10^4$。

## 样例 #1

### 输入

```
3
4 2 
3 5 
6 10
```

### 输出

```
7```

# 题解

## 作者：ysj1173886760 (赞：153)

这道题和洛谷里这道题
[P1823](https://www.luogu.org/problemnew/show/P1823)
十分相似。  
做完这道题之后可以去做上面那道题。算是一个加强版吧。  
这道题题意还是很明显的，我们维护一个单调栈即可。我们维护栈中的发射站高度的单调性。  
栈中储存发射站的标号。我们将接收能量的过程分成两个阶段：  
1.入栈时，由于栈是具有单调性的，如果栈顶的元素没有新加进来的元素高，那么他肯定就不能给后面的元素传输能量了，我们退掉这个元素，将新的元素加进来即可。  
2.新的元素加进来以后，会对他在栈中下面那个元素传输能量，也就是离他最近还高于他的那个。P.S.（不需要对栈空时进行特判，我们只是对0这个元素传输了能量而已，最后不统计就行了）  


那么确定思路以后，我们算法流程就是  
for{   
读入新元素  
while(栈非空&&新元素高度大于栈顶元素高度)新元素能量加上栈顶元素能量，退栈；  栈顶元素能量加上新元素能量（对应第二种情况）  
将新元素加入栈中  
 }  
 扫一遍传输能量的数组，找到max输出即可。
 
 代码如下，就不加注释了，上面解释的很清楚了（很短吧）：
 ```cpp
 #include<iostream>
using namespace std;
const int maxn=1e6+10;
int s1[maxn],h[maxn],v[maxn],sum[maxn],ans,n,top;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>h[i]>>v[i];
		while(top&&h[s1[top]]<h[i])sum[i]+=v[s1[top--]];
		sum[s1[top]]+=v[i];
		s1[++top]=i;
	}
	for(int i=1;i<=n;i++)ans=max(ans,sum[i]);
	cout<<ans;
	return 0;
}
 ```
 
 

---

## 作者：aqfong (赞：62)

蒟蒻用了STL中的栈，算法是单调栈，竟然只用了23行就AC了！！！	
我构造了一个单调递增的栈，如果准备入栈的元素大于栈顶元素，那么ans[i]+=v[s.top（）],并且把栈顶元素pop掉（删除栈顶元素的操作）；如果小于，那么直接加上v[i]。
```
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
int h[N], v[N], ans[N], mx;
stack<int> s; //STL中的栈
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> h[i] >> v[i]; //h为此发射台的高度，v为此发射台的能量
    for (int i = 1; i <= n; i++)
    {
        while (!s.empty() && h[s.top()] < h[i])
        {
        	ans[i] += v[s.top()];
        	s.pop();
		}
		if (!s.empty()) ans[s.top()] += v[i];
        s.push(i);
    }
    for (int i = 1; i <= n; i++) mx = max(mx, ans[i]);
    cout << mx << endl;
}
```

------------


---

## 作者：IceWa (赞：39)

单调栈可以解决这个问题...

顺序考虑每个节点

### 先考虑向左发射，有两种情况

１ · 向左发射：

｛
Ⅰ·不存在比我高的－－＞不用操作

Ⅱ·存在比我高的－－＞向最近的比我高的传输能量

｝
### 再考虑向右发射，也是两种

２ · 向右发射：

｛
Ⅰ·不存在比我高的－－＞不用操作

Ⅱ·存在比我高的－－＞向最近的比我高的传输能量

｝情况似乎有些相似...


所以我们完全可以逐个地向栈中插入节点。对于每次插入，如果我当前这个点的高度\_大于\_栈顶元素（即我可以收到它的能量），待插入节点的积累值＋＝栈顶元素可发射值（而不是积累值），然后弹出栈顶（它已经没用了2333），继续向左直到栈顶高度＞＝待插入高度\_或\_栈空；然后可以插入；继续循环。  实际上维护了一个单调不升序列。


代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1000005;
int n,p,k;   //p--指向栈顶
long long h,c[maxn];    //c数组保存第i号点的积累 
struct Node{
    long long h;int w,pos,c;
    //h--高度,w--可发射能量,pos--栈中元素对应的节点号,c--栈中元素前面有多少跟它一样高的 
}s[maxn];
int main(){
    scanf("%d",&n);
    scanf("%lld%d",&s[++p].h,&s[1].w);
    s[1].pos=1;s[1].c=1;
    for(int i=2;i<=n;i++)
    {
        scanf("%lld%d",&h,&k);       //输入高度和能量 
        while(p&&s[p].h<h)
            c[i]+=s[p--].w;        //吸收比我矮的节点的能量 
        int j=p;
        if(s[j].h==h){
            j -= s[j].c;       //O(1)跳到比我大的点 
            s[p+1].c = s[p].c+1;    //把我xu上去... 
            s[p+1].h = h ,s[p+1].w = k;
            s[++p].pos = i;    //保存下节点号 备用 
        }
        else{
            s[++p].c=1;    //像我这么大的还是第一个! 
            s[p].h=h, s[p].w=k;
            s[p].pos=i;
        }
        c[s[j].pos]+=k;           //左侧比我高的节点收到了我的能量 
    }
    long long ans=0;
    for(int i=1;i<=n;i++)
        if(c[i]>ans)    ans=c[i];
    printf("%lld",ans);
}
```
代码简洁易懂标准O(N)跑的快亲测不加读优316ms（语文水平有限还啰嗦了一堆...求放过qwq）


---

## 作者：灵乌路空 (赞：29)

无良宣传一下博客wwwwww  
[文章列表 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

------------

#### 使栈中的信号塔按照高度降序排列

#### 对于一个新的信号塔:

![1](https://cdn.luogu.com.cn/upload/pic/61175.png)

- 如图 , 当他加入栈中时,  
  会挡住之前比它低的塔的传播  
  同时 , 也会接受到比它低的塔的信号
  
  -  所以将栈顶所有比它低的塔删除,  
     (因为他们已经不能再传播给其他塔信号了)  
     同时 , 新的塔接收到的能量   
     加上 删掉的塔传播的能量 

![2](https://cdn.luogu.com.cn/upload/pic/61176.png)

- 如图，对于原有的高度比它高的信号塔,  
  离此新的信号塔最近的,会接受到新的塔的信号  
  
  - 故 , 将此时栈顶的塔,  
    即 离此新的信号塔最近的 ,高度比它高的塔   
    接收到的能量,  
    加上新的塔传播的能量 

- 再将此新的信号塔加入栈中

 $O(n)$ 复杂度扫一遍后,将所有塔接收到的能量排序一下
输出最大值即可 

附上 ~~奇丑的~~ 代码:

```cpp
#include<cstdio>
#include<algorithm>
#include<stack>
#define ll long long
using namespace std;
const int MARX = 1e6+10;
ll n;
ll h[MARX],v[MARX],w[MARX];
stack <int> s;
signed main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
	  {
	  	scanf("%lld%lld",&h[i],&v[i]); 
	  	while(!s.empty())// 将栈顶所有比它低的塔删除,
	  	  {
	  	  	if(h[s.top()]>h[i]) break;//遇到比新塔高的 
	  	  	w[i]+=v[s.top()];// 加上 删掉的塔传播的能量 
			s.pop();
		  }
		if(!s.empty()) w[s.top()]+=v[i];//加上新的塔传播的能量  
		s.push(i);//加入栈 
	  }
	sort(w+1,w+n+1);//找到最大值 
	printf("%lld",w[n]);
}
```

------------



---

## 作者：玉环小姐姐 (赞：27)

恩，大家都是大佬啊，都会写栈。~~我这个只会用队列的蒟蒻拟单调栈混在里面应该没人看得出来吧。【逃】~~

讲下思路：用一个线性算法，先从左往右推。若在栈中栈顶那个塔的高度比当前塔的高度低，即此塔为栈顶塔右边的第一个比栈顶塔高的塔，那么栈顶塔的能量就要加给当前塔，然后将栈顶塔出栈。直到栈内无塔或下一塔比它的高度高，就将该塔进栈，并指向下一个塔。反之亦然。两趟之间要清空栈，最后再打个擂台，找MAXV。

本来一开始用的是优先级队列重载小根堆，想着每次从第一个数开始比就好了然后由于忘记了优先级队列的算法复杂度是O（n log2n)，然后华丽丽的超时···【汗】*1

后来改成了普通队列，直接把一个结构体扔进去，想着这样比较快，然后华丽丽的爆空间···【汗】*2

然后改成每次把高度扔进去，由于高度不重复，所以一个高度对一个能量值，开了一个map用来映射，然后又忘了map的时间复杂度是O（log2n）然后又一次华丽丽的超时···【汗】*3

一不小心maxv没开long long然后做着做着就re了···【汗】*4

于是最后决定用双端队列模拟栈（保证时间），在队列里不存结构体而存指针（保证空间）。其实存下标也一样，不过听说指针的占用空间少···【汗】*5

咿呀，貌似忘记贴代码了···【汗】*6  

别打别打，我马上贴，我马上贴！

```cpp
#include<bits/stdc++.h>
using namespace std;
struct launchtower{
	long long energy,high,ans;
};
launchtower tower[1000005];
int main()
{
	long long n;
	cin>>n;
	launchtower *a;
	deque<launchtower*>que;
	for(int i=1;i<=n;i++)
	{
		cin>>tower[i].high>>tower[i].energy;
		tower[i].ans=0;
	}
	for(int i=1;i<=n;i++)
	{
		while(!que.empty()&&que.back()->high<tower[i].high)
		{
			tower[i].ans+=que.back()->energy;
			que.pop_back();
		}
		a=&tower[i];
		que.push_back(a);
	}
	while(!que.empty())
	{
		que.pop_back();
	}
	for(int i=n;i>=1;i--)
	{
		while(!que.empty()&&que.back()->high<tower[i].high)
		{
			tower[i].ans+=que.back()->energy;
			que.pop_back();
		}
		a=&tower[i];
		que.push_back(a);
	}
	long long maxv=0;
	for(int i=1;i<=n;i++)
	{
		if(tower[i].ans>=maxv)
		{
			maxv=tower[i].ans;
		}
	}
	cout<<maxv;
	return 0;
}
```

---

## 作者：Hexarhy (赞：11)

好久没写题解了，现在来练练笔。尽管原来题目里已经有很多篇了。

希望这个较为良好的排版能顶替之前陈旧的题解。

-------------

### 题意简述

题面通俗易懂，不再赘述。但这里有 $\LaTeX$ [修复题面](https://www.luogu.com.cn/paste/krtoojzo)（有删动）。

管理员看到了也恳请更换原题面。

### 解题思路

**建议自己画草图，便于思考。**

#### 算法一

**暴力。**

即按照题目所述进行模拟，思维难度和代码难度简单，但时间复杂度 $O(n^2)$。

预计得分 $40\%$。实际得分未测。

#### 算法二

看到 $n\le 10^6$ 条件反射想到正解是 $O(n)$ 或 $O(\log n)$ 等的做法。

分析两个条件：高度和距离。由于“距离最近”是在高度的前提下进行的，故从高度出发，结合线性做法，构建一个维护高度的**单调栈**。

为了方便，栈只需存储发射塔的下标即可。注意下标还有一个优势：**方便表示距离**。

当然单调队列等其他线性做法也是可以的。

单调递增还是单调递减？这就要结合第二个条件——距离，来考虑。别忘了栈中存储的是下标。

-----------

**这一部分若有差错请在评论指出。**这里真的挺乱的。

如果单调递增：

对于每一个新加进来的元素 $x$，如果符合单调递增，距离最近的就是栈顶元素（别忘了栈中存储的是下标），对 $x$ 自身增加能量。

否则，我们不知道 $x$ 为了满足单调递增的具体位置。这就需要我们把栈中的元素退出来（这个序列记为 $S$），直到找到一个合适的位置，再执行相应操作。

注意，此时插入的 $x$ 又会对 $S$ 中最矮的，即第一个元素传输能量。$S$ 还必须要回到栈去，因为会对之后的新元素造成影响。而且 $S$ 本身也因为插入的 $x$ 发生改变，这里前面已述。

还有出栈，也有很多的细节。

总之有很多很多的麻烦，这里不能一一阐述。

因此单调递增并不合适。有兴趣的可以尝试。

-----------

选择单调递减。

$\texttt{[1]}$ 如果新元素 $x$ 符合单调递减，对栈顶传输能量，再入栈。

$\texttt{[2]}$ 否则，将栈中元素逐个与 $x$ 比较并弹出，直到满足条件。每一个被弹出的元素都会对 $x$ 传输能量。

$x$ 回到正确位置，再执行 $\texttt{[1]}$ 中的操作。因为此时情况已经与 $\texttt{[1]}$ 一样了。

这样就实现了 $x$ 对外两个方向上的传输。为什么呢？

其中一个是 $\texttt{[1]}$ 的操作；

还有一个是 $\texttt{[2]}$ 中，它作为之前的栈顶元素，对新元素的传输。

显然，每个元素都在弹出前完成了两次传输（先传输 $\texttt{[1]}$，再传输 $\texttt{[2]}$ 的情况），可以弹出且对答案不造成影响。

代码实现也如同上面所述。

预计得分 $100\%$。实际得分亦然。


### 实现细节

- 养成好习惯，使用栈前检查是否空。

- 最后输出最大值时推荐使用`std::max_element()`，用法与`sort()`一样，头文件是`<algorithm>`。但是`std::max_element()`返回迭代器，输出前请加上`*`。**不需要C++11。**

### 参考代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <stack>
using namespace std;

const int MAXN=1e6+5;
int n;
struct tower
{
	int h,v;
}a[MAXN];
stack <int> s;//保存下标。
int ans[MAXN];

void input(void)
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	 scanf("%d%d",&a[i].h,&a[i].v);
}

void solve(void)
{
	for(int i=1;i<=n;i++)//逐个访问。
	{
    	//所有操作都要检查empty()
		while(!s.empty() && a[i].h>a[s.top()].h)//[2]中情况。注意用循环而不是if。原因很简单，自己想想。
		{
			ans[i]+=a[s.top()].v;//栈顶对x传输。
			s.pop();//栈顶完成两次传输，可以弹出。
		}
		if(!s.empty())//[1]中情况。
	 	 ans[s.top()]+=a[i].v;
		s.push(i);
	}
}

int main()
{
	input();
	solve();
	printf("%d\n",*max_element(ans+1,ans+1+n));//好用，推荐。
	return 0;
}
```

---

## 作者：bzy369258147 (赞：8)

大家居然都用单调栈或单调队列做，一点都不NOIP，可惜了这么好的题目.

直接通过前面答案递推也可以做到均摊O(n)(这同时也是我出的一道题的idea)

复杂度证明和单调栈类似，理解起来更容易.

具体方法如下:

定义 $pre[i]$ 为左边第一个大于 i 的数的位置,对于每个 i ,先定义$pre[i] = i- 1$，然后用暴力跳的方法求解$pre[i]$.

```cpp

void query(int now){
    int ans = pre[now];
    while( ans > 0 and h[ans] <= h[now] )ans = pre[ans];
    if( ans == 0 or ans == n + 1 )ans = -1;
    pre[now] = ans;
} 
```

然后找右边是一样的

然后就轻松AC了.

```
#include<bits/stdc++.h>
using namespace std;

int n;
int h[1000005];
int v[1000005];
int ans[1000005];
int pre [1000005][2];

void query(int now,bool flag){
    int ans = pre[now][flag];
    while( ans > 0 and ans <= n and h[ans] <= h[now] )ans = pre[ans][flag];
    if( ans == 0 or ans == n + 1 )ans = -1;
    pre[now][flag] = ans;
} 

int main(){
    cin >> n;
    for(int i = 1;i <= n;i ++)cin >> h[i] >> v[i];h[0] = h[n + 1] = 1e9;
    for(int i = 1;i <= n;i ++)pre[i][0] = i - 1,pre[i][1] = i + 1;
    for(int i = 1;i <= n;i ++)query( i,0 );
    for(int i = n;i >= 1;i --)query( i,1 );
    for(int i = 1;i <= n;i ++){
        if( ~pre[i][0] )ans[ pre[i][0] ] += v[i];
        if( ~pre[i][1] )ans[ pre[i][1] ] += v[i];
    }
    int all = 0;
    for(int i = 1;i <= n;i ++)all = max( all,ans[i] );
    cout << all;
    return 0;
}
```

---

## 作者：CloudStroll (赞：7)

嗯，这是一道考察单调栈的好题。

分析题目

题目说是一个发射站会向左边最近的比它高的和右边比它高的其他发射站发射能量。那么一个发射站可以向0或1或2个发射站发射能量，但是一个发射站可以收到的能量却可以是无限多的。那么我们就先从左到右用单调栈维护一遍，再反向维护一遍，然后用两个数组存下来第i个发射站最近的左高和右高的下标。

接着使左高和右高的答案数组加上自己发出的能量，最后再扫一遍，找出收到能量最多的那个站即可。

主要还是单调栈的问题啦！

代码如下

```cpp
//begin
#include <cstdio>
#include <algorithm>
#define run(a,b,c) for(a=b;a<=c;a++)
using namespace std;
//head
//By CJ

const int MAXN=1000005;
//const

int N,i,t,sta[MAXN],h[MAXN],a[MAXN],l[MAXN],r[MAXN],all[MAXN],ans;

void Read_In()
{
    scanf("%d",&N);
    run(i,1,N)
    {
        scanf("%d%d",&h[i],&a[i]);
    }
}



void Solve()
{
    run(i,1,N)
    {
        while(t&&h[sta[t]]<=h[i])
        {
            t--;
        }
        l[i]=sta[t];
        t++;
        sta[t]=i;
        all[l[i]]+=a[i];
    }//左边最高
    run(i,1,N)
    {
        sta[i]=0;
    }
    t=0;
    for(i=N;i>=1;i--)
    {
        while(t&&h[sta[t]]<=h[i])
        {
            t--;
        }
        r[i]=sta[t];
        t++;
        sta[t]=i;
        all[r[i]]+=a[i];
    } //右边最高 
    run(i,1,N)
    {
        ans=max(ans,all[i]);
    }
}



void Write_Out()
{
    printf("%d",ans);
}
//function

int main()
{
    Read_In();
    Solve();
    Write_Out();
    return 0;
}
//main
//end
```

QAQ

---

## 作者：EarthGiao (赞：4)

## 【思路】
单调栈板子题   
（下文中的信号都是能量的意思，感觉说发射信号比发射能量更有意思）   
### 【题目大意】
很多根信号塔    
信号塔可以发射信号    
发射的信号只有两边第一个比他高的信号塔才能够接收到   

### 【为什么要用单调栈】
单调栈是用来求一个点两边最早大于或者小于的点的位置的    
这很显然对吧    
因为你在那这个数和栈顶比较的时候   
（假设目前再找两边第一个高于这个点的   
和题目要求一样）   
如果这个数大于栈顶    
那很显然栈顶右边第一个大于他的数找到了是的吧    
然后如果这个数小于栈顶   
那很显然这个数左边第一个大于他的数也找到了是的吧   
所以单调栈是可以用来求两边第一个大于/小于这个数的位置的    
 
### 【最后思路】
用单调栈找出两边第一个大于这个数的位置   
在单调栈单调的过程中   
上面说的如果这个数大于栈顶    
那这个位置的信号塔收到的信号就可以加上栈顶能够发出的信号   
如果这个数小于栈顶    
那这个位置的信号塔发出的信号就能够被栈顶所在的那个信号塔收到    
所以栈顶所在的信号塔能够收到的信号    
就加上这个数所在的信号塔能够发出的信号强度     
最后枚举一遍每一个电线杆子收到的信号    
比较最大值输出就okoj了     

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;
const int Max = 1000006;
struct node
{
	int hao;
	int h;
	int v;
	int w;
}a[Max];
stack<int>s;
int main()
{
	int n;
	cin >> n;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i].h >> a[i].v,a[i].hao = i;
	for(register int i = 1;i <= n;++ i)
	{
		while(!s.empty() && a[s.top()].h < a[i].h)
		{
			a[i].w += a[s.top()].v;
			s.pop();
		}
		if(!s.empty())
		a[s.top()].w += a[i].v;
		s.push(i);
	}
	int M = 0;
	for(register int i = 1;i <= n;++ i)
		M = max(M,a[i].w);
	cout << M << endl;
	return 0; 
}
```

---

## 作者：Taduro (赞：4)

看了一下题解，大家好像都是用单调栈写的啊，我这个只会单调队列的菜鸡混在里面应该没人看得出来吧（逃。

这题跟洛谷P2947比较像，那个是只能向右边发射，这个加上左边就好了。


那么我们考虑只能向右边发射的情况，从右向左维护队首最大一个单调队列，如果队首就是当前元素，那么它没有可以辐射到的，因为他自己就是当前队列里最大的。

否则，因为当前元素在队尾，它之前那个元素一定是即离它最近又比他高，所以可以被他辐射到。
左边同理。。。

```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
	int x,dfn;
}team[1000001];
struct sz{
	int h,v;
}a[1000001];
long long n,m,tail,head;
long long i,j,b[1000001];
long long ans[1000001],maxn;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch>'9'||ch<'0'){ if(ch=='-') f=-1; ch=getchar();}
    while(ch<='9' && ch>='0'){x=x*10+ch-'0'; ch=getchar();}
    return x*f;
}
void write(long long x){
    if(x<10){putchar(x%10+48); return;}
    write(x/10); putchar(x%10+48); 
}
int main(){
	n=read();
	for (i=1; i<=n; i++) 
		a[i].h=read(),a[i].v=read();
	head=1; tail=1;
	team[head].x=a[n].h; team[head].dfn=n;
	b[n]=0;
	for (i=n-1; i>=1; i--){
		while (head<=tail&&a[i].h>=team[tail].x) tail--;
		tail++;
		team[tail].x=a[i].h; team[tail].dfn=i;
		if (team[head].x<=a[i].h) b[i]=0;
		else{
			b[i]=team[tail-1].dfn;
			ans[b[i]]+=a[i].v;
		}
	}
	head=1; tail=1;
	team[head].x=a[1].h; team[head].dfn=1;
	b[n]=0;
	for (i=2; i<=n; i++){
		while (head<=tail&&a[i].h>=team[tail].x) tail--;
		tail++;
		team[tail].x=a[i].h; team[tail].dfn=i;
		if (team[head].x<=a[i].h) b[i]=0;
		else{
			b[i]=team[tail-1].dfn;
			ans[b[i]]+=a[i].v;
		}
	}
	for (i=1; i<=n; i++)
		if (ans[i]>maxn) maxn=ans[i];
	write(maxn);
	return 0;
}
```

---

## 作者：神之蒟蒻xyk (赞：2)

题解里一对单调栈
全是o(n)把我吓懵了。。。

但是——观察数据，发现n只到1e6

———于是，发现非常暴力地用堆nlogn能过

然后。。就水过去了。。。

从前往后一遍，从后往前一遍

code：
```cpp
#include<bits/stdc++.h>
#define fir(a, b, c) for(register ll a = b; a <= c; a ++)
#define ll long long
using namespace std;
inline ll read(){
	ll x = 0; bool flag = 1; char c = getchar();
	for(; !isdigit(c); c = getchar())  if(c == '-') flag = 0;
	for(; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	return flag ? x : -x;
}

const int N = 1e6 + 10;
ll n, a[N], b[N], f[N];
typedef pair<ll, ll> pl;
priority_queue<pl, vector<pl>, greater<pl> > q;

int main(){
	n = read();
	fir (i, 1, n) a[i] = read(), b[i] = read();
	fir (i, 1, n) {
		while (!q.empty()) {
			if (q.top().first >= a[i]) break;
			f[i] += q.top().second;
			q.pop();
		}
		q.push(make_pair(a[i], b[i]));
	}
	while (!q.empty()) q.pop();
	for (int i = n; i >= 1; -- i) {
		while (!q.empty()) {
			if (q.top().first >= a[i]) break;
			f[i] += q.top().second;
			q.pop();
		}
		q.push(make_pair(a[i], b[i]));
	}	
	ll ans = 0;
	fir (i, 1, n) ans = max(ans, f[i]);
	printf("%lld\n", ans);
	return 0;
}

```


---

## 作者：蔡俊黠 (赞：2)

#### deque大法好

既可以队头队尾进出也可以队头队尾删除，多好啊！

拿样例来说，在做样例的过程中理解我的思路吧 ( ´･∀･｀)  
样例（给他们加个id，就是编号，方便加能量）：

维护一个单调递减的序列

（4，2，1）
（3，5，2）
（6，10，3）

-（4,2,1）入队
#### q:(4,2,1)

-(3,5,2)准备入队
#### q:(4,2,1)。。。(3,5,2)
因为此时队尾的4比3高，所以3发射5个能量到编号1去
#### q:(4,2,1)(3,5,2)
-（6,10,3）准备入队
#### q:(4,2,1)(3,5,2)。。。（6,10,3）
因为队尾的3比6矮，所以3发射5个能量到编号3去，3弹出队尾
#### q:(4,2,1)。。。（6,10,3）
因为队尾的4比6矮，所以4发射2个能量到编号3去，4弹出队尾
#### q:(4,2,1)（6,10,3）
此时没有站可以入队了，刚刚收到能量最多的是编号3的6，收到了7个能量，分别来自编号1,2，over

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long f[1000010],anss;
struct node{
	int h,v,id;
}e;
deque <node> q;
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d",&e.h,&e.v);
		e.id=i;
		while (!q.empty()&&q.back().h<e.h) 
        //此时的站点可以收到所有队尾比它矮的站点的能量，相当于题目所说的向右发射 
		{
			f[e.id]+=q.back().v;
			anss=max(anss,f[e.id]);
			q.pop_back();
			
		}
		if (!q.empty()&&q.back().h>e.h) //此时站点向左发射能量给离它最近的一个站点 
		  f[q.back().id]+=e.v,anss=max(anss,f[q.back().id]);
		q.push_back(e); //入队 
	}
	printf("%lld\n",anss); 
	return 0;
}
```




---

## 作者：龙翔凤翥 (赞：2)

思路分析:  
------------
跟[P2947 [USACO09MAR]向右看齐Look Up](https://www.luogu.org/problemnew/show/P2947)有点像,只是那道题只要分析一边,这道题要两边分析,其实并不要两次单调栈,只需在进栈和出栈的时候均计算一下贡献即可.~~细节见注释~~
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define RE register
#define N 1000010
ll a[N],q[N],ans[N],b[N];//ans数组记录每个发射站的能接受的能量
inline ll read()
{
    int k=1;ll x=0;
    char ch=getchar();
    while ((ch<'0'||ch>'9')&&ch!='-')
        ch=getchar();
    if(ch=='-')
        k=-1,ch=getchar();
    while(ch>='0'&&ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return k*x;
}
int n,t=0;
ll maxx=-1;
int main()
{
    n=read();
    for(RE int i=1;i<=n;i++)
        a[i]=read(),b[i]=read();
    a[n+1]=2000000001;//最后没有发射站进栈需要把栈内的所有元素都弹出
    for(RE int i=1;i<=n+1;i++)
    {
        while(t&&a[i]>a[q[t]])//单调递减栈,出栈的时候计算一遍贡献
        {
            ans[i]+=b[q[t]];
            t--;
        }
        ans[q[t]]+=b[i];//进站也要算一遍贡献
        q[++t]=i;
    }
    for(RE int i=1;i<=n;i++)
        maxx=max(maxx,ans[i]);
    cout<<maxx<<endl;
    return 0;
}

```






---

## 作者：King_Han (赞：2)

~~蒟蒻第一次发qwq~~

------------
双向单调栈的小问题... ~~对于大佬们来说水到不能再水~~

栈其实就是刷盘子，把盘子放上再拿走qwq

先考虑只向左发射的情况，从左向右扫一遍求一个单调栈，以栈底向栈顶高度递减来维护，每次遇到比栈顶高的塔就不断出栈直到栈顶的塔比新来的塔高，**注意要先更新栈顶的塔接收的能量，然后再入栈！！！！**（~~我一开始就先入栈再更新wa的qwq~~）然后出栈到空，再从右往左做一遍就a了，基本思路就是这样...

细节在这：首先只用最近的合法塔来更新栈顶，**注意不是加和！！**满足能量只能被最近的比它高的塔接收，实际就是维护单调下降序列（其实应该是单调不上升序列，但是每个塔高度不同...）的过程中使第i个塔加一下右边（或左边）的能量。其次就是亲测O（n）的复杂度qwq。

附上~~丑陋的~~代码

```
#include<bits/stdc++.h>
using namespace std;
stack<int> s;
int h[1000005],v[1000005];
long long  ans[1000005];
long long maxx;
void work(int x)
{
	while(!s.empty()&&h[x]>h[s.top()])	//第x个塔如果比栈顶高就不断弹出直到栈顶比第x个高 
		s.pop();
	if(!s.empty())
		ans[s.top()]+=v[x];  //把栈顶接收的能量加上第x个塔的能量 
	s.push(x);			//第x个塔入栈成为栈顶 
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&h[i],&v[i]);
	}
	for(int i=1;i<=n;i++)
		work(i);
	while(!s.empty())
		s.pop();
	for(int i=n;i>=1;i--)
		work(i);
	for(int i=1;i<=n;i++)
	{
		maxx=max(maxx,ans[i]);
	}
	printf("%lld",maxx);
	return 0;
}
```

---

## 作者：TsReaper (赞：2)

我们先来考虑这个问题的一半。假如每个发射站只会向左发射信号，如果第i个发射站比它左边的发射站都高，那么第i个发射站左边的站点就不可能收到右边站点发送的信号。这让我们想到了单调栈。

我们维护一个栈顶向栈底递增的单调栈，每次一个元素入栈之后，设此时栈顶为top，那么该元素发射的信号只能被位于top-1的站点收到。向左发射信号的过程做完后，再做一遍向右发射信号的过程。这样我们就能找出哪个站点收到的信号最多了。

```cpp

#include <stdio.h>
int n,ans = 0,h[1000010],v[1000010],x[1000010];
int s[1000010],pos[1000010],top;
int max(int a,int b)
{
    return a>b?a:b;
}
void add(int p)
{
    while(top&&s[top]<=h[p]) top--;
    x[pos[top]] += v[p];
    s[++top] = h[p]; pos[top] = p;
}
int main()
{
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++) scanf("%d%d",&h[i],&v[i]);
    for(i=1,top=0;i<=n;i++) add(i);
    for(i=n,top=0;i;i--) add(i);
    for(i=1;i<=n;i++) ans = max(ans,x[i]);
    printf("%d",ans);
    return 0;
}

```

---

## 作者：远航之曲 (赞：2)

与楼下思想一样，只是单调栈用的stl里的栈实现的，代码比较精简，阅读起来更方便


```cpp
#include <cstdio>
#include <stack>
using namespace std;
stack<int> s;
int h[1000005],p[1000005],ans[1000005],n,anss;
void pushs(int g)
{
    while(!s.empty() && h[g]>=h[s.top()])
        s.pop();
    if(!s.empty())
        ans[s.top()]+=p[g];
    s.push(g);
}
main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        scanf("%d%d",&h[i],&p[i]);
    for (int i=1;i<=n;i++)
        pushs(i);
    while (!s.empty()) 
        s.pop();
    for (int i=n;i>=1;i--)
        pushs(i);
    for (int i=1;i<=n;i++)
        anss=max(ans[i],anss);
    printf("%d",anss);
}
```

---

## 作者：G_A_TS (赞：1)

~~发射栈~~  
然而我是分块做的（这种膜你题竟然没有暴力题解???）  
[~~分 块 大 法 好~~](https://www.cnblogs.com/wzzorz/articles/10368840.html)  
如上，分块是**莫队**的标配优化之一  
题中注意边界，分为左辐射和右辐射跑两遍  
如图：  
![ht](https://i.loli.net/2019/04/13/5cb190d00a481.png)
维护每块最大值Fmax[i]  
若Fmax[i]>所求，暴力那个块，程序O(2n根号n)  
简单的分块可以sqrt(n)每块  

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum[2000010],h[1000010],v[1000010],q[1000010],FK,fk[1000010],Fmax[1000010],fs[1000010],fe[1000010],maxn;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&h[i],&v[i]);
	}
	FK=sqrt(n);
	for(int i=1;i<=n;i++)
	{
		fk[i]=(i-1)/FK+1;
	}
	for(int i=1;i<=n;i++)
	{
		int nowFK=fk[i];
		if(h[i]>Fmax[nowFK])
		{
			Fmax[nowFK]=h[i];
		}
		for(int j=nowFK;j>=1;j--)
		{
			if(Fmax[j]>h[i])
			{
				for(int k=min(i,FK*j);k>=FK*(j-1)+1;k--)
				{
					if(h[k]>h[i])
					{
						sum[k]+=v[i];
						break;
					}
				}
				break;
			}
		} 
	}
	int nFK=(n-1)/FK+1;
	for(int i=1;i<=n;i++)
	{
		Fmax[i]=0;
	}
	for(int i=n;i>=1;i--)
	{
		int nowFK=fk[i];
		if(i==220)
		{
			nowFK=fk[i];
		}
		if(h[i]>Fmax[nowFK])
		{
			Fmax[nowFK]=h[i];
		}
		for(int j=nowFK;j<=nFK;j++)
		{
			if(Fmax[j]>h[i])
			{
				for(int k=max(i,FK*(j-1)+1);k<=min(n,FK*j);k++)
				{
					if(h[k]>h[i])
					{
						if(sum[k]==249990)
						{
							cout<<i<<endl;
						}
						sum[k]+=v[i];
						break;
					}
				}
				break;
			}
		} 
	}
	for(int i=1;i<=n;i++)
	{
		maxn=max(maxn,sum[i]);
	}
	cout<<maxn;
}
```


---

## 作者：独活 (赞：1)

为了便于找到高度对应的能量，我们优化成：高度对应的下标i入队列，这样出队列的也是下标如是y;则对应的能量就是v[y]

**本人的代码风格：在代码中分析问题~~**
```cpp
/*
3
4 2
3 5 
6 10
高度的满足单调性：我吸收高度比我低的人，所以我来的时候，把高度比我低的都删除掉，只剩下我没有吸收的比我高的人。
！！因为从前向后的时候，你前面的人比你先入队列，你进来时就能把你前面比你低的都吸收了，但你不知道后面入队列的高低，所以只做了单向的前面。
故从后向前的时候，你后面的从比你先入队列，你进来进就你把你后面比你低的都吸收了，这样前面+后面=你的全部。
如：
 10  6  89  7
*/
#include<bits/stdc++.h>
using namespace  std;
int n,h[1000001],v[1000001],f[1000001];
int a[1000001],wei=1;//单调队列，只要尾指针，不要head=1。 
void  read()//队列中放的是高度的下标（方便找对应的能量） 
{ int i,j,k,x,y,max1;
cin>>n;
for(i=1;i<=n;i++)
cin>>h[i]>>v[i];
//构成单调队列,从前向后：入队列（从队尾开始找第1个比自己大的位置j）
//把j后面的所有元素（从j+1...<=wei-1;)删除,
//最后：第3步：把第i个的下标入队列。
wei=1;//空指针，永远等待你放元素的位置  
for(i=1;i<=n;i++)
{   // h[1]=4; ru(1)  a[1]=1;h[a[1]]=4
//h[2]=3; ru(2);  a[2]=2; h[a[2]=2]=3
//h[3]=6;ru(3);a[3]=3;h[a[j]=3]=6;
x=h[i];//第i个的高度
for(j=wei-1;j>=1;j--)//从尾到头找
if(h[a[j]]>x)// a[j]是队列中的元素，是下标是高度的下标
 break;// =x时继续找,j的最小值是0（没有1个比x大) 
else  continue;//!!高度相等是不能吸收的，所以不能删除 
for(k=j+1;k<=wei-1;k++)//从j+1开始到wei-1
{  y= a[k] ; //出队列 y=a[k]是队列中的元素：是下标 
f[i]=f[i]+v[y];//被第i个人 吸收能量 
}//j是比自己大的数，第i个人就应该插入 j+1位置。 
wei=j+1;//删除上面的那么元素，队尾指针直接变成：j+1(比自己大的后面) 
a[wei++]=i;//把高度i的下标入队列,wei永远是空 
} 
//从后向前，再填一次记忆数组
wei=1; //!!!队列一定要清空 
for(i=n;i>=1;i--)
{x=h[i];
for(j=wei-1;j>=1;j--)//j是队列中从尾到头找比x大的数
if(h[a[j]]>x)
 break;
 else continue;
for(k=j+1;k<=wei-1;k++)
f[i]=f[i]+v[a[k]];//吸收能量
wei=j+1;//wei是空位置，放在比你大的数下标j的后面:删除队列中元素
a[wei++]=i;//入队尾 
}
max1=0;
for(i=1;i<=n;i++)
{ cout<<h[i]<<"---吸收的最大能量为："<<f[i]<<endl;//此步可以省略，检查错误时用
if(f[i]>max1)
 max1=f[i];
}
cout<<max1<<endl;
}
int main  ()
{ read();
return 0;
}
```

**总的来说不算太难，注释已经很详细了，**~~算一份傻瓜攻略？~~

---

## 作者：bztMinamoto (赞：1)

表示不是很明白题解里清一色的单调队列和单调栈是什么玩意儿……

我这个思路应该比较清奇？似乎题解里没写（也可能是我没认真看）

我们先对每一个位置的值记录一个Next和last，分别表示他后面第一个高度比他大的数的位置和他前面第一个比他大的数的位置

那么这两个数组要怎么得到呢？

我们以Next为例，从后往前扫，设i为当前位置，令j=i+1，当j的高度小于等于i时不断令j=Next[j]，然后最后的j就是Next[i]，然后令sum[j]+=v[i],Next[i]=j即可

应该不难理解吧？因为如果j比它小，那么只有比j大的才有可能是Next[i]，那么还要满足是第一个，那么只要不断找Next[j]就能保证高度递增且找到的必然是第一个

那么last同理

顺带一提，为了防止越界，可以令0和n+1的高度为inf，然后统计答案的时候不要统计他们两个就行
```
//minamoto
#include<iostream>
#include<cstdio>
#define inf 0x7fffffff
#define ll long long
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=1e6+5;
int a[N],v[N],Next[N],last[N];ll sum[N];
int n;ll mx;
int main(){
//	freopen("testdata.in","r",stdin);
	n=read();
	for(int i=1;i<=n;++i) a[i]=read(),v[i]=read();
	a[0]=a[n+1]=inf;
	for(int i=n,j;i;--i){
		j=i+1;
		while(a[j]<=a[i]) j=Next[j];
		sum[j]+=v[i],Next[i]=j;
	}
	for(int i=1,j;i<=n;++i){
		j=i-1;
		while(a[j]<=a[i]) j=last[j];
		sum[j]+=v[i],last[i]=j;
	}
	for(int i=1;i<=n;++i) cmax(mx,sum[i]);
	printf("%lld\n",mx);
	return 0;
}
```

---

## 作者：dqtr03 (赞：1)

楼上的大神写的都是单调栈balabala的...

可能是我比较蒟蒻吧，只能想到双向链表这种低级数据结构

题目中说
#### 发出的能量只被两边最近的且比它高的发射站接收
我们把它简化一下

如果一个地方发了洪水，那么水会随着时间不断涨高

当一个地方淹没的时候，其左右两边的仍然没有被淹没的地方就是题中所说的那两个发射站

那么我们就可以将每个点被淹没的时间排序，用双端链表来维护每个点的左右两边没被淹没的点

淹没时进行的操作就是把这个点从链表里删除，把自己的能量发射给左右，然后更新答案

具体代码
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define max(a,b) (a>b?a:b)
using namespace std;
typedef long long ll;
struct node1{int i;ll h;}P[1000050];
struct node{int Front,Next;ll v,k;}t[1000050];
bool cmp(node1 a,node1 b)
{
	return a.h<b.h;
}
ll ans=0;
inline void Del(int o)
{
	ans=max(ans,t[o].k);
	t[t[o].Front].k+=t[o].v;
	t[t[o].Next].k+=t[o].v;
	t[t[o].Front].Next=t[o].Next;
	t[t[o].Next].Front=t[o].Front;
}
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d",&P[i].h,&t[i].v);
		P[i].i=i;
		t[i].Front=i-1;//链表初始化 
		t[i].Next=i+1;
		t[i].k=0;
	}
	sort(P+1,P+n+1,cmp);//针对淹没时间(高度)排序 
	for(int i=1;i<=n;++i)Del(P[i].i);//淹没每个点 
	cout<<ans;
	return 0;
}
```

---

## 作者：荣一鸣 (赞：1)

单调栈解决问题，从左向右扫的一个单调栈，从右向左扫的一个。

设q1,q2,q3,q4为单调栈里的元素（保存高度），保证q1>q2>q3>q4（q1到q4为连续或不连续并未接受的能量）这时读入一个新高度h，若h>q4那么，该塔可接受来自q4的能量，弹出q4，对q3继续进行比较。直到qn>h或q为空结束。再将h压入栈。

代码


```cpp
#include<cstdio>
#include<queue>
using namespace std;
int vi[1000010];
int hi[1000010];
int ki[1000010];
int n;
deque<int> hx;
deque<int> hn;
deque<int> vx;
deque<int> vn;
int maxn;

int main(){
	
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&hi[i],&vi[i]);
	}
	hx.push_front(hi[1]);
	vx.push_front(vi[1]);
	hn.push_front(hi[n]);
	vn.push_front(vi[n]);
	for(int i=2;i<=n;i++){
		int j=n-i+1;
		int hmin=hx.front();
		int v=vx.front();
		while(hmin<hi[i]){
			ki[i]+=v;
			hx.pop_front();
			vx.pop_front();
			if(hx.empty()) break;
			hmin=hx.front();
			v=vx.front();
		}
		hx.push_front(hi[i]);
		vx.push_front(vi[i]);
		hmin=hn.front();
		v=vn.front();
		while(hmin<hi[j]){
			ki[j]+=v;
			hn.pop_front();
			vn.pop_front();
			if(hn.empty()) break;
			hmin=hn.front();
			v=vn.front();
		}
		hn.push_front(hi[j]);
		vn.push_front(vi[j]);
		maxn=max(maxn,max(ki[i],ki[j]));
	}
	
	printf("%d",maxn);
	return 0;
}
```

---

## 作者：hibiki (赞：1)

容易发现，如果一座塔的左侧和右侧都已经出现比它高的塔，那么这座塔将不会影响到之后的结果，因此

维护一个单调栈，每次入栈的时候，检查元素高度，将栈顶元素出列，直到栈顶元素高度高于入队元素为止。

每次元素入栈的时候，更新其左侧的元素的总能量（因为是栈单调的，所以能接受到向左侧电波的有且只有他左侧第一个元素）

每次元素出栈的时候（元素出栈只会在有元素准备入栈时发生），更新正在入栈的元素的总能量（也就是出栈的元素向右发射的电波的能量）

每次元素出栈，用其总能量更新答案

最后扫描栈中剩余的元素，用其总能量更新答案

```pascal
Var
    h,v,ans,stack:array[0..1000010] of int64; //栈里存编号
    top,i,n,re,maxn:longint; //re存向右发射的能量强度;
Function max(a,b:longint):longint;
    begin
        if a>b then exit(a);
        exit(b);
    end;
Procedure push(i:longint); //i是编号
    begin
        while (top>0) and (h[i]>h[stack[top]]) do begin 
            ans[i]:=ans[i]+v[stack[top]];
            maxn:=max(maxn,ans[stack[top]]);
            dec(top);
        end;
        inc(top);
        //writeln(top);
        stack[top]:=i;
        if top>0 then ans[stack[top-1]]:=ans[stack[top-1]]+v[stack[top]];
    end;
Begin
    readln(n);
    for i:=1 to n do begin
        readln(h[i],v[i]);
    end;
    top:=1;
    for i:=1 to n do begin
        push(i);
    end;
    for i:=1 to top do
        maxn:=max(maxn,ans[stack[i]]);
    writeln(maxn);
End.
```

---

## 作者：Baker (赞：0)

这里提供一种除了单调栈之外的解法。基本思路是静态链表。先按照高度从小到大排序，然后按照顺序发射能量。这样可以保证接收到能量的一定是高度更高的。发射完能量之后这个塔一定不会再接受其他塔的能量，所以把这个节点删除。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
struct node{
	int h,v,pos;
}a[1000005];
const int inf=1e9+7;
int n;
int l[1000005],r[1000005],e[1000005];
bool cmp(node x,node y){
	return x.h<y.h;
}
signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].h>>a[i].v;
		a[i].pos=i;
	}
	for(int i=2;i<=n-1;i++){
		l[i]=i-1;
		r[i]=i+1;
	}
	l[1]=-1; r[1]=2;
	r[n]=inf; l[n]=n-1;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<n;i++){
		if(r[a[i].pos]<=n) e[r[a[i].pos]]+=a[i].v;
		if(l[a[i].pos]>0) e[l[a[i].pos]]+=a[i].v;
		if(l[a[i].pos]>0)  r[l[a[i].pos]]=r[a[i].pos];
		if(r[a[i].pos]<=n) l[r[a[i].pos]]=l[a[i].pos];
	}
	int maxx=0;
	for(int i=1;i<=n;i++) maxx=max(maxx,e[i]);
	cout<<maxx;
	return 0;
}
```


---

## 作者：Mizuhara (赞：0)

看到这题我就想到了2018预赛的毒瘤双向链表。。。

然而现在我还是不会。

于是我用$st$表水过了这题。

对于发射站$i$，以找它左边第一个比它大的发射站为例：

我们可以通过二分来找到最大的$l$，满足$maxh(l,i-1)>h[i]$。

$maxh(l,r)$表示区间$(l,r)$中的最大高度。

对于区间高度最小值，我们可以用线段树或者$st$表来维护。

如果用线段树，预处理是$O(nlogn)$，查询是$O(nlognlogn)$，无法满足要求。

而$st$表的查询是$O(1)$的，就可以将总查询复杂度减小到$O(nlogn)$。

于是复杂度就是$O(nlogn)$。

```
#include<iostream>
#include<cstring>
#include<cstdio>
void read(int &s);
#define ll long long int
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int maxn=1000100;
int maxx(int a,int b){return a<b?b:a;}

int jie[maxn];
int n,h[maxn],v[maxn];
int st[maxn][23],lg2[maxn],mi2[23];
void csh(){
    memset(jie,0,sizeof(jie));
    lg2[1]=0;
    rep(i,2,n)
        lg2[i]=lg2[i/2]+1;
    mi2[0]=1;
    rep(k,1,lg2[n]+1)mi2[k]=mi2[k-1]+mi2[k-1];
    rep(i,1,n)st[i][0]=h[i];
    rep(k,1,lg2[n])
        for(int i=1;i+mi2[k]-1<=n;i++)
            st[i][k]=maxx(st[i][k-1],st[i+mi2[k-1]][k-1]);
}
int q(int l,int r){
    int k=lg2[r-l+1];
    return maxx(st[l][k],st[r-mi2[k]+1][k]);
}
int Ans=0;
void worrk(){
    rep(i,1,n){
        if(i!=1&&q(1,i-1)>h[i]){
            int l=1,r=i-1,mid;
            while(l<r){
                mid=(l+r+1)>>1;
                if(q(mid,i-1)>h[i])l=mid;
                else r=mid-1;
            }
            jie[l]+=v[i];
        }
        if(i!=n&&q(i+1,n)>h[i]){
            int l=i+1,r=n,mid;
            while(l<r){
                mid=(l+r)>>1;
                if(q(i+1,mid)>h[i])r=mid;
                else l=mid+1;
            }
            jie[l]+=v[i];
        }
    }
    rep(i,1,n)Ans=maxx(Ans,jie[i]);
    cout<<Ans;
}
int main(){
    read(n);
    rep(i,1,n)read(h[i]),read(v[i]);
    csh();
    worrk();
    return 0;
}
void read(int &s){
    s=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
}
```

---


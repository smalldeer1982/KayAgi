# [NOIP 2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 说明/提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。


## 样例 #1

### 输入

```
8
186 186 150 200 160 130 197 220
```

### 输出

```
4
```

# 题解

## 作者：VitrelosTia (赞：68)

## 前言
题解区大多使用的都是时间复杂度 $O(n^2)$ 的算法，唯一使用二分查找的 $O(n \log n)$ 做法的被 hack 了，所以写一篇二分查找 $O(n \log n)$ 复杂度的题解。

upd(2025.4.5)：这篇题解是我远古时期写的，当时只是想介绍一种~~没什么用的~~解法，因为一些比较神秘的原因现在是第一篇，所以我打算新增一些内容。

## 题意分析
题目中要求的“合唱队形”满足的要求其实就是：$t_1, t_2, t_3, \dots, t_i$ 成上升序列，$t_i, t_{i + 1}, t_{i + 2}, \dots, t_n$ 成下降序列。题目中要求算出最少出列人数，其实就是要求哪个 $i$ 能使得以 $a_i$ 为结尾的最长上升子序列和最长下降子序列之和最大。

## 做法
这道题想要用 $O(n \log n)$ 的复杂度做，首先要用 $O(n \log n)$ 求出最长上升子序列（下面简称 LIS）的长度。

dp 的做法我放在后面了，有需要的朋友可以翻到后面看。

### $O(n \log n)$ 求 LIS 长度
在 $O(n^2)$ 的做法中，求 LIS 长度的做法需要通过枚举两个数，假如是满足上升的，就将长度更新为原长度和新长度加一的最大值。通过这个朴素做法我们可以发现，以当前数结尾的 LIS 长度是否能达到 $k$，取决于它是否能比一个长度为 $k - 1$ 的序列的结尾数大。我们可以观察一组数据。

![](https://cdn.luogu.com.cn/upload/image_hosting/iemzbonq.png)

该组数据中，我们记下以每个数结尾的 LIS 长度，由于上面所讲的，对于长度为 $k$ 的数据，我们只需要关注结尾数最小的，因为这代表它有可能产生的长度为 $k + 1$ 的 LIS 长度最多。于是我们可以去掉一些数据。

![](https://cdn.luogu.com.cn/upload/image_hosting/yxs1gouw.png)

还是上面的道理，我们把还留着的数据的上方的数放到一个数轴上，这样当我们要查询一个数的 LIS 长度时，只需要看这个数处于哪个区间中，它的 LIS 长度就是往前（不包括本身）最靠近它的数所对应的 LIS 长度加一。

![](https://cdn.luogu.com.cn/upload/image_hosting/n6iog7zq.png)

那么可以很快找到 $6$ 的 LIS 长度为 $3 + 1 = 4$。这一个找区间的步骤使用复杂度 $O(\log n)$ 的二分查找。

实现其实并不困难，按照上述的步骤做就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int M = 1e5 + 5, INF = 1e9;
int n, a[M];
int f[M], g[M], len;
// f[i]   a[i] 为结尾的 LIS 长度
// g[i]   上升子序列长度为 i 时结尾最小值
// len    LIS 长度

int main() {
	int n;
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++) scanf ("%d", &a[i]);
	for (int i = 1; i <= n; i++) {
		int pos = lower_bound(g + 1, g + len + 1, a[i]) - g; //二分查找区间
		f[i] = pos;
		g[pos] = a[i];//查找到之后还要更新最小值
		len = max(len, pos);
	}
	cout << *max_element(f + 1, f + n + 1); //输出最长的 LIS 长度
	return 0;
}
```
实际上，我们并不需要 `f[]` 数组，可以直接输出 `len`。但在本题中需要记录以每个数结尾的 LIS 长度，所以这样写了。

这种做法的时间复杂度是 $O(n \log n)$。依照相同的思路，最长下降子序列长度的求法只需要倒着枚举 `i` 即可。

### 本题解法
如我们分析的题意一样，本题只需要记录以 $a_i$ 为最后一个数的最长上升子序列长度和以 $a_i$ 为第一个数的最长下降子序列长度即可，我们用 `f1[]` 和 `f2[]` 来记录这两组数，第 $a_i$ 个数的最长合唱队形就是 `f1[i] + f2[i] - 1`（中间有重合所以减去 $1$）。用总人数减去最大值就是答案了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int M = 1e5 + 5, INF = 1e9;
int a[M], f1[M], f2[M], g[M], len, ans = -INF;

int main() {
    int n;
    scanf ("%d", &n);
    for (int i = 1; i <= n; i++) scanf ("%d", &a[i]);
    len = 0;
    for (int i = 1; i <= n; i++) {
        int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
        f1[i] = pos;
        g[pos] = a[i]; 
        len = max(len, pos);
    }
    len = 0;
    memset(g, 0, sizeof g);
    for (int i = n; i >= 1; i--) {
        int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
        f2[i] = pos;
        g[pos] = a[i];
        len = max(len, pos);
    }
    for (int i = 1; i <= n; i++) ans = max(ans, f1[i] + f2[i] - 1);
    cout << n - ans;
    return 0;
}
```

### dp 的想法

还是介绍一下比较有用的 dp 吧。

考虑设 $f_i$ 表示考虑完前 $i$ 个数，**强制**以 $i$ 结尾的最长上升子序列。枚举上一个选的位置 $j$，需要满足 $a_j < a_i$，我们在 $j$ 处已经求得以 $j$ 结尾的最长的长度是 $f_j$，于是 $f_i \gets f_j+1$ 即可。可以写成式子：

$$f_i=\max_{j=1}^{i-1} f_j+1 \ \ \texttt{s.t.} a_j<a_i$$。

### 优化至 $O(n \log n)$

考虑维护一个值域数据结构（你可以认为是一个树状数组）并做扫描线（你可以认为是从 $1$ 到 $n$ 遍历），扫描到 $i$ 时，在值域 $a_i$ 处用 $f_i$ 更新最大这个值域的最大值，这样，我们可以通过查询值域 $[0,a_i-1]$ 的最大值来获得满足 $a_j < a_i$ 的最大 $f_j$。可以用树状数组或者线段树实现。时间复杂度 $O(n\log n)$。

---

## 作者：FISH酱 (赞：13)

## 前置知识

本篇题解主要讲解最长上升子序列的做法，如果你还不会，可以去做[模板题](https://www.luogu.com.cn/problem/AT_chokudai_S001_h)。

## 解题思路

本题通过题面可知，我们希望一个队形里面的身高是先递增后递减的，那就可以分开求，最长递增的长度和最长递减的长度，最后枚举找最大值，即找出符合要求的最长队形的长度，用原队形长度减去符合要求的最长队形长度，就可以得到需要出列的同学个数。总结一下，我们需要求出最长上升子序列和最长下降子序列。

## 代码展示

写的时候注意细节即可，特别是求最长上升子序列和最长下降子序列时的实现，同时要注意审题，题目问的是出列人数，下面是代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n,ans=-1; // 定义变量
int a[1007]; // 定义身高数组
int dp1[1007]; // 最长上升子序列的dp数组
int dp2[1007]; // 最长下降子序列的dp数组

int main(){
	cin >> n; // 读入同学总数

    for(int i=1;i<=n;i++){
    	cin >> a[i]; // 读入身高
	}

    // 求最长上升子序列长度
    for(int i=1;i<=n;i++){
	    for(int j=0;j<i;j++){
	    	if(a[j]<a[i]){ // 如果满足递增要求就更新
	    		dp1[i] = max(dp1[i],dp1[j]+1); // 判断拼接转移后长度是否更长
			}
		}
	}

    // 求最长下降子序列长度，我们可以反着找
    for(int i=n;i>0;i--){
	    for(int j=n+1;j>i;j--){
	    	if(a[j]<a[i]){
				dp2[i]=max(dp2[i],dp2[j]+1); // 判断拼接转移后长度是否更长
			}
		}

	    for(int i=1;i<=n;i++){
	    	ans=max(dp1[i]+dp2[i]-1,ans); // 找符合要求的最长队形长度
		}
	}

    cout << n-ans; // 注意题目问的是出列人数

    return 0;
}
```

---

## 作者：lucky_Mrzhao (赞：7)

## 思路

首先观察到这一题其实是一道动态规划，那么我们考虑如何使用动态规划获得最优解。

观察题目要求，可以发现，题目中所谓的队形其实就是中间高，两边低的队形，所以我们考虑开两个数组 $f$ 和 $g$ 。 其中 $f_i$ 表示从左往右到达第 $i$ 个位置的最长上升子序列， $g_i$ 表示从右往左到达第 $i$ 个位置的最长上升子序列，那么我们的答案 $ans$ 即为：

$$
ans=\max_{i=1}^n f_i+g_i-1
$$

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105];
int f1[105],f2[105]; 
signed main(){
	int n;
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		f1[i] = f2[i] = 1;
	}
	for(int j = 1;j <= n;j++){
		for(int k = 1;k < j;k++){
			if(a[j]>a[k]) f1[j] = max(f1[j],f1[k]+1);
		}
	}
	for(int j = n;j >= 1;j--){
		for(int k = n;k > j;k--){
			if(a[j]>a[k]) f2[j] = max(f2[j],f2[k]+1);
		}
	}
	int maxn = 0;
	for(int i = 1;i <= n;i++){
		maxn = max(maxn,f1[i]+f2[i]-1);
	}
	cout << n - maxn;
	return 0;
}
```

---

## 作者：LiJunze0501 (赞：3)

用 $dpl_i$ 记录从 $i$ 开始的向右的最长上升子序列；  
用 $dpr_i$ 记录从 $i$ 开始的向左的最长上升子序列。  
那么用 $a$ 数组记录每个人的高度，$dpl_i=\max\limits_{j<i,a_i>a_j} dpl_j+1$，$dpr_i=\max\limits_{i<j \leqslant n,a_i>a_j} dpr_j+1$。  
最后的答案 $ans=\min\limits_{1 \leqslant i \leqslant n} n-dpl_i-dpr_i+1$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101];
int dpl[101];//从左数 
int dpr[101];//从右数 
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	dpl[1]=1;
	for(int i=2;i<=n;i++){
		int maxl=0;
		for(int j=1;j<i;j++)
			if(a[i]>a[j]&&dpl[j]>maxl)
				maxl=dpl[j];
		dpl[i]=maxl+1;
	} 
	dpr[n]=1;
	for(int i=n-1;i>=1;i--){
		int maxr=0;
		for(int j=i+1;j<=n;j++)
			if(a[i]>a[j]&&dpr[j]>maxr)
					maxr=dpr[j];
		dpr[i]=maxr+1;
	} 
	int ans=1000;
	for(int i=1;i<=n;i++) ans=min(ans,n-dpl[i]-dpr[i]+1);
	cout<<ans<<endl;
}
```

---

## 作者：suzhikz (赞：3)

观察下题面，中间的位置的值很重要，两边我们可以通过取最长上升或下降子序列来做。

我们先计算每个节点前缀的最长上升子序列，后缀的最长下降子序列。

然后在枚举每个点作为中间的最高的值，答案就是前缀的最长上升子序列加上后缀的最长下降子序列的总长减一。因为中间的这个位置被重新计算了一次。


```cpp
	cin>>n;
	for(int i=1;i<=n;i++)shangsheng[i]=xiajiang[i]=1;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			if(a[i]>a[j]){
				shangsheng[i]=max(shangsheng[i],shangsheng[j]+1);
			}
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=n;j>i;j--){
			if(a[i]>a[j]){
				xiajiang[i]=max(xiajiang[i],xiajiang[j]+1);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=max(ans,shangsheng[i]+xiajiang[i]-1);
	}
	cout<<n-ans;
```

---

## 作者：yedalong (赞：3)

## Solution
可以发现这种队形可以拆分成两部分，一部分是前面的最长上升子序列，另一部分是后面的最长下降子序列。  

考虑设 $dps_i$ 表示第 $i$ 个位置以前的最长上升子序列的长度，$dpx_i$ 表示第 $i$ 个位置以后最长下降子序列的长度，那么对于第 $i$ 个位置为中心的合唱队形长度最大是 $dps_i+dpx_i-1$，只需在计算完 $dps$ 和 $dpx$ 后遍历每一个位置取最小值即可。  

时间复杂度 $O(n^2)$，可以通过此题。
## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[105],dps[105],dpx[105],ans=1e9;
int main(){
	cin>>n;
	for(int i = 1;i<=n;i++) cin>>a[i];
	for(int i = 1;i<=n;i++) dps[i]=dpx[i]=1;
	for(int i = 1;i<=n;i++){
		for(int j = i+1;j<=n;j++){
			if(a[i]<a[j]){
				dps[j]=max(dps[j],dps[i]+1);
			}
		}
	}
	for(int i = n;i>=1;i--){
		for(int j = i-1;j>=1;j--){
			if(a[i]<a[j]){
				dpx[j]=max(dpx[j],dpx[i]+1);
			}
		}
	}
	for(int i = 1;i<=n;i++){
		ans=min(ans,n-dpx[i]-dps[i]+1);
	}
	cout<<ans;
}
```

---

## 作者：shinzanmono (赞：3)

设 $f_i$ 表示以 $a_i$ 结尾的最长上升子序列长度，$g_i$ 表示以 $a_i$ 开头的最长下降子序列长度。则答案为 $\max\limits_{i=1}^n\{n-f_i-g_i+1\}$.

$f_i$ 和 $g_i$ 的转移方程显然：$f_i=\max\limits_{j<i,a_j<a_i}f_{j}+1$，$g_i=\max\limits_{j>i,a_j<a_i}g_j+1$。其中 $a_0=a_{n+1}=0$。

然后按照如上的做法 dp 即可。时间复杂度是 $O(n^2)$。

当然，如果对上述转移进行优化的话，可以做到 $O(n\log n)$。

对于 $f$，我们从前往后转移，转移过程中对维护一段值域上的 $f_i$ 最大值即可，每次得到 $f_i$ 就对 $a_i$ 位置上的值更新，转移时查询 $[1,a_i-1]$ 区间即可。$g$ 倒过来做一遍就好。

---

## 作者：majingxuan123 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P1091)
# 分析
计算最少需要几位同学出列，等价于最多能排成几位同学的合唱队形。

考虑第 $k$ 个同学为中间的同学，那么 $k$ 前面的同学与 $k$ 后面的同学（包含 $k$）之间没有任何影响，所以可以计算两个部分的最大值，得到正确答案。

对于 $k$ 前面的同学，最大值为以 $k$ 结尾的最长上升子序列；对于 $k$ 后面的同学，最大值为以 $k$ 开始的最长下降子序列。

于是，我们可以求出以每个数结尾的最长上升子序列和以每个数开始的最长下降子序列，再枚举 $k$，得到正确答案。

时间复杂度：$O(n^2)$。
# 代码
```cpp
#include<iostream>
using namespace std;
int n;
int t[1005];
int f[1005][2];
//0 -> 以每个数结尾的最长上升子序列
//1 -> 以每个数开始的最长下降子序列
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&t[i]);
	for(int i=1;i<=n;i++){
		f[i][0]=1;
		for(int j=1;j<i;j++){
			if(t[i]>t[j])f[i][0]=max(f[i][0],f[j][0]+1);
		}
	}
	for(int i=n;i>=1;i--){
		f[i][1]=1;
		for(int j=n;j>i;j--){
			if(t[i]>t[j])f[i][1]=max(f[i][1],f[j][1]+1);
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=max(ans,f[i][0]+f[i][1]-1);
        //i 被计算了两次，所以要 -1
	}
	printf("%d",n-ans);
	return 0;
}
```

---

## 作者：langmouren (赞：1)

## 题意概括
给定一个数组，求出最长的中间大两边小的人数（可以不连续），用总人数与其做差并输出。

## 题目分析
可以使用动态规划，维护两个数组，一个是从左到右的最长上升子序列，一个是从右到左的最长上升子序列，然后统计，输出最大值。

我是蒟蒻，感觉这道题如果想使用单调队列会有后效性，不知道怎么写，期待单调队列题解。
## 复杂度
时间复杂度为 $O(n^2)$。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[110];
int a[110];
int b[110];
int n;
int m;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
	}
	for(int i=1;i<=n;i++){
		a[i]=1;
		for(int j=1;j<=i;j++){
			if(s[j]<s[i]) a[i]=max(a[i],a[j]+1);
		}
	}
	for(int i=n;i>=1;i--){
		b[i]=1;
		for(int j=n;j>=i;j--){
			if(s[i]>s[j]) b[i]=max(b[i],b[j]+1);
		}
	}
	for(int i=1;i<=n;i++){
		if(a[i]+b[i]>m) m=a[i]+b[i]-1;
	}
	cout<<n-m<<endl;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

题意：求给定序列的一个最长的子序列，满足这个序列先升序再降序。

我们可以把所求序列拆成两个最长上升子序列，先求一遍最长上升子序列，翻转数组，再求一遍。时间复杂度 $O(n^2)$。

记 $f_i$ 表示以 $i$ 结尾的最长上升子序列，从 $i$ 到 $i-1$ 枚举 $j$，当 $t_j<t_i$ 时转移：$f_i=\max(f_j+1)$。

记 $g_i$ 表示反转后以 $i$ 结尾的最长上升子序列，就等价于原序列中以 $i$ 开头的最长下降子序列。

答案就是，以 $i$ 结尾的最长子序列的长度加上以 $i$ 开头的最长下降子序列长度减 $1$，因为 $i$ 算了两遍。答案即 $f_i+g_{n+1-i}-1$ 的最大值。

## solution

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, t[105], f1[105], f2[105], ans;
int main () {
	cin >> n;
	for (int i=1; i<=n; ++i)
		cin >> t[i];
	for (int i=1; i<=n; ++i) {
		f1[i]=1;
		for (int j=1; j<i; ++j) 
			if (t[j]<t[i])
				f1[i]=max(f1[i], f1[j]+1);
	}
	reverse(t+1, t+n+1);
	for (int i=1; i<=n; ++i) {
		f2[i]=1;
		for (int j=1; j<i; ++j) 
			if (t[j]<t[i])
				f2[i]=max(f2[i], f2[j]+1);
	}
	for (int i=1; i<=n; ++i)
		ans=max(ans, f1[i]+f2[n+1-i]-1);
	cout << n-ans;
	return 0;
}
```

---

## 作者：superLouis (赞：1)

## 题解：P1091 [NOIP 2004 提高组] 合唱队形

本题解提供英文和中文两种语言。  
This solution is available in both English and Chinese.

----------
### 中文版本
我们采用预处理的思路，做出两个方向（左到右和右到左）的最长上升子序列。然后再扫描一遍下标，对于每一个下标计算左到右方向的最长上升子序列长度加上右到左方向的最长上升子序列长度再减一（这里的减一是因为中间枚举的下标重复了两次），将所有计算出来的值取最大值，拿总数减去就是答案了。

下面我们来推理一下动态规划的转移方程（从左到右为例）：
$$
f_i = \max_{j = 1}^{i - 1} {f_j + 1}
$$
再考虑一下初始条件，就是把整个 `f` 数组都初始化为 `1` 即可。从右到左是同样的道理，就不多叙述了。

代码在尾言前面。

----------
### English version
We use the preprocessing idea to make the longest ascending subsequence in two directions (left-to-right and right-to-left). Then scan the subscript again, calculate the longest ascending subsequence length in the left to right direction for each subscript plus the longest ascending subsequence length in the right to left direction and subtract one (minus one here because the subscript of the middle enumeration is repeated twice), take all the calculated values to the maximum, subtract the total number to give the answer.

Let's reason about the transition equation of dynamic programming (from left to right for example) :
$$
f_i = \max_{j = 1}^{i - 1} {f_j + 1}
$$
Consider the initial condition, which is to initialize the entire `f` array to `1`. From the right to the left is the same, not to elaborate.

Below is the C++ code.

----------
### 代码实现 Code implementation

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 100 + 10;
int n, ans, a[maxn], f[maxn], g[maxn];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    fill(&f[0], &f[maxn-1], 1);
    fill(&g[0], &g[maxn-1], 1);
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j < i; j++) 
            if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
    reverse(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j < i; j++) 
            if (a[j] < a[i]) g[i] = max(g[i], g[j] + 1);
    for (int i = 1; i <= n; i++) ans = max(ans, f[i] + g[n - i + 1] - 1);
    cout << n - ans << "\n";
    return 0;
}
```

----------
### 尾言 Epilogue

如果 $n$ 再变大，比如到 $10^6$，就只能采用 $O(n \log n)$ 的思路了，在这里提供两种：

1. 单调队列 + 二分
2. 线段树维护

我会把第一种思路的代码放在文章末。

If $n$ becomes larger, such as $10^6$, you can only use the idea of $O(n \log n)$, here provide two solutions: 

1. Monotonic queue + binary search
2. Segment tree maintenance

I'll leave the code for the first idea below.

```cpp
#include <bits/stdc++.h>
const int maxn = 3e5 + 10;
using namespace std;
int n, a[maxn], f[maxn], l[maxn], r[maxn], ans = 1, cnt;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    f[1] = a[1]; l[1] = 1;
    for (int i = 2; i <= n; i++) {
        int ll = 1, rr = ans;
        while (ll <= rr) {
            int mid = (ll + rr) >> 1;
            if (a[i] <= f[mid]) rr = mid - 1;
            else ll = mid + 1;
        }
        f[ll] = a[i];
        if (ll > ans) ans++;
        l[i] = ll;
    }
    memset(f, 0, sizeof(f));
    reverse(a + 1, a + n + 1);
    f[1] = a[1]; r[1] = 1; ans = 1;
    for (int i = 2; i <= n; i++) {
        int ll = 1, rr = ans;
        while (ll <= rr) {
            int mid = (ll + rr) >> 1;
            if (a[i] <= f[mid]) rr = mid - 1;
            else ll = mid + 1;
        }
        f[ll] = a[i];
        if (ll > ans) ans++;
        r[i] = ll;
    }
    for (int i = 1; i <= n; i++) cnt = max(cnt, l[i] + r[n - i + 1] - 1);
    cout << n - cnt << "\n";
    return 0;
}
```

这个代码明显快得多。  
This code seems faster than the first one.

---

## 作者：_shine_ (赞：0)

有一个跟这个很像的题是 CF739C，有兴趣的可以去做一做。

在这里定义 $f_{i}$ 表示为以 $i$ 结尾的最长上升子序列个数，$g_i$ 表示为以 $i$ 开始的最长下降子序列个数，则显然当 $f_i+g_i$ 最大时 $i$ 为两者转接点。

此时考虑状态转移方程，即 $f_i=\max_{a_j<a_i,j<i}f_j+1,g_i=\max_{a_j<a_i,j>i}g_j+1$。此时算出后答案为 $\max_{i=1}^n n-f_i-g_i+1$。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
#define lx first
#define ly second
const int maxn=1e2+10;
int n,a[maxn];
int f[maxn],ans=INT_MAX;
signed main(){
//	freopen("T2.in","r",stdin);
//	freopen("T2.out","w",stdout);
	cin >> n;for(int i=1;i<=n;++i)cin >> a[i];
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j)f[j]=1;
		for(int j=1;j<=i;++j){
			for(int k=1;k<j;++k){
				if(a[k]<a[j])f[j]=max(f[j],f[k]+1);
			}
		}
		int cnt1=f[i];
		for(int j=1;j<=n;++j)f[j]=1;
		for(int j=n;j>=i;--j){
			for(int k=n;k>j;--k){
				if(a[k]<a[j])f[j]=max(f[j],f[k]+1);
			}
		}
		cnt1+=f[i]-1;ans=min(ans,n-cnt1);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：0)

### 思路

容易想到本题为 dp 题。

我们设 $u_i$ 表示以第 $i$ 个元素为结尾的最长上升子序列，$d_i$ 表示以第 $i$ 个元素为结尾的最长下降子序列，易得答案为 $\max\limits_{i = 1 \to n}(n - u_i - d_i + 1)$。

同样，容易推出状态转移方程为：

$$
u_i = \max\limits_{j<i \operatorname{and} a_j < a_i}(u_j + 1) ,\\
d_i = \max\limits_{j>i \operatorname{and} a_j < a_i}(d_j +1).
$$

注意边界条件应为 $u_1 = 1$ 和 $d_n = 1$。

时间复杂度为 $O(n^2)$。

### 实现

```cpp
# include <iostream>
using namespace std;
int a[114],up[114],down[114];
int main(){
	int n; cin >> n;
	for (int i = 0;i < n;i++){
		cin >> a[i];
		up[i] = down[i] = 1;
	}for (int i = 1;i < n;i++){
		int Max = 1;
		for (int j = 0;j < i;j++){
			if (a[i] > a[j]) Max = max(Max,up[j] + 1);
		}up[i] = Max;
	}for (int i = n - 1;i >= 0;i--){
		int Max = 1;
		for (int j = i + 1;j < n;j++){
			if (a[i] > a[j]) Max = max(Max,down[j] + 1);
		}down[i] = Max;
	}int ans = 0;
	for (int i = 0;i < n;i++) ans = max(ans,up[i] + down[i]-1);
	cout << n - ans;
	return 0;
}
```

---


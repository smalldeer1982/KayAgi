# 求m区间内的最小值

## 题目描述

一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。

## 说明/提示

对于 $100\%$ 的数据，保证 $1\le m\le n\le2\times10^6$，$1\le a_i\le3\times10^7$。

## 样例 #1

### 输入

```
6 2
7 8 1 4 3 2
```

### 输出

```
0
7
7
1
1
3 
```

# 题解

## 作者：炳源 (赞：131)

近学了单调队列，所以就用单调~~丢雷~~队列来做了  
先分析一下题意  
给出一个n个数的数列，要求m区间内的最小值  
有点坑的就是第0个也要记录  
所以~~很自然而然地~~想到了单调队列  
有人说线段树牛逼，为啥不用线段树呢？  
## 首先第一点：时间  
对于单调队列来说，仅仅需要O（n）的时间扫一遍过去就可以了  
但是对于线段树来说建树就需要nlogn的时间了  
再加上一段一段的查询 时间开销一下子就大了起来  
## 再看空间  
线段树需要用到4*n的空间大小 挺大的  
而单调队列仅仅只需要n的空间大小就可以了  
## 最后代码长度  
线段树需要的建树和查询需要多少和单调队列短短的五六行  
一下子就可以看出来了

所以这道题我就是选用单调队列（dalao别嘲讽我，小蒟蒻一枚）  
  
现在我们就开始讲讲单调队列到底是个什么东西吧  
# 概念：
单调队列嘛，就是单调的队列  
单调递增或者单调递减  
所以说答案（也就是最优解）就存在队首，而队尾则是最后进队的元素  
那么怎么判断这个数是否还在这个区间之内呢？  
这时候就要用到一个结构体了 
```cpp
struct node
{
    int val;
    int pos;
};
```
val存储该点的值，pos存储该点的位置，就是为了能够在循环中判断能否把这个点踢掉  
根据单调队列的性质，如果我们想要将一个新的点插入  
（你比如）  
先看样例
当我们要在队列中插入第m + 1个元素的时候  
也就是1  
现在队列中是   7 8  
他们分别对应的位置   1 2  
因为要从队尾插入嘛  
你想想你排队 
如果有人一下子直接到队首，你是不是会很不爽，认为他没有资格  
但是如果他一个一个插队，从队尾挨个上来，你不爽也没用的  
所以单调队列也是队列，也是如此，没有元素有资格直接到头  
你要慢慢来  
这时候代码就很明显了
```cpp
 while((head <= tail)&&(v[tail].val >= a[i - 1]))
            tail--;
        v[++tail].val = a[i - 1];
   //这里i - 1要解释一下，因为该题0也要计算进去
```
那么对于已经过期的元素怎么办呢？  
如果一个元素从队首开始t人  
如果队首没有过期 其他的元素你管他干嘛？又不是答案，现在又用不到  
如果队首过期，那就t掉他继续t下一个  直到找到一个没有过期的，然后参考上一步就OK了  
```cpp
 while((head <= tail)&&(v[head].pos < i - m))
            head++;
```
接下里贴代码
# 手写版：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int n,m;
inline int rd()
{
    int data = 0;
    int f = 1;
    char ch = getchar();
    while(ch < '0'||ch > '9')
    {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0'&&ch <= '9')
    {
        data = (data<<3) + (data<<1) + ch - '0';
        ch = getchar();
    }
    return f * data; 
}
int a[2000010];
int min_que[2000010];
struct node
{
    int val;
    int pos;
}v[2000010];
void write(int x)
{
    if(x > 10)
        write(x/10);
    putchar(x%10 + '0');	
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 0;i < n;i++)
        a[i] = rd();
    int head = 1,tail = 0;
    min_que[0] = 0;
    for(int i = 1;i < n;i++)
    {
        while((head <= tail)&&(v[tail].val >= a[i - 1]))
            tail--;
        v[++tail].val = a[i - 1];
        v[tail].pos = i - 1;
        while((head <= tail)&&(v[head].pos < i - m))
            head++;
        min_que[i] = v[head].val;
    }
    for(int i = 0;i < n;i++)
        printf("%d\n",min_que[i]);
}
```
## STL版：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<deque>
using namespace std;
const int maxsize = 2000010;
int n,m;
struct node
{
    int val;
    int pos;
}A[maxsize];
deque<node> min_Q;
inline int rd()
{
    int data = 0;
    int f = 1;
    char ch = getchar();
    while(ch < '0'||ch > '9')
    {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0'&&ch <= '9')
    {
        data = (data<<3) + (data<<1) + ch - '0';
        ch = getchar();
    }
    return f * data; 
}
int min_que[maxsize]; 
int main()
{
    n = rd(),m = rd();
    for(int i = 1;i <= n;i++)
    {
        A[i].val = rd();
        A[i].pos = i - 1;
    }
    min_que[0] = 0;
    for(int i = 1;i < n;i++)
    {
        while(!min_Q.empty()&&min_Q.back().val >= A[i].val)
            min_Q.pop_back();
        min_Q.push_back(A[i]);
        while(!min_Q.empty()&&min_Q.front().pos < i - m)
            min_Q.pop_front();
        min_que[i] = min_Q.front().val;
    }
    for(int i = 0;i < n;i++)
        printf("%d\n",min_que[i]);	
            
}
```
小小用了一下快读，不懂的同学可以直接用scanf代替  
不要用cin会超时（除非你把std同步关掉）  
如果这道题你过了，就可以看一下以下两题，都差不多，难度不会太大，注意边界条件就可以过了  
传送门：
[P1886滑动窗口](https://www.luogu.org/problemnew/show/P1886)、[P2032扫描](https://www.luogu.org/problemnew/show/P2032)  

最后再介绍一下这个优先队列的作用，一般是用来优化DP，OI中较少直接仅仅考察该算法，同常都是和DP结合起来。  
### 当你在凝视算法的时候，算法也在凝视你

---

## 作者：lcglcg (赞：50)

# 吐槽
感觉其他题解没有写清楚，本蒟蒻愣是搞了一下午的单调队列，一脸懵逼。

于是打算写一个详细一点的题解，也可以加深一下自己的印象。ps：第一次写题解，写得不好不要介意。
# 思路

其实题目意思可看成求1—n-1的每一项的前m项中的最小值


首先构造一个单调增的队列，每次进来一个数的时候，与队尾的数比较；如果比队尾的数小，那么这个数直接入队，如果比队尾数大，r--，弹出队尾，然后继续比下去直到比队尾数大或队列为空为止。当长度超过m时，l++，把队首弹掉。这样，只需每次输出队首，就是当前的最小值。

那么怎么判断当前的长度呢？我们注意到，由于新的数总是从后往前插入，于是队列中各个数的序号也是单调增的。也就是说，队首一定是最先进来的，所以只需用队首的序号减去当前的数的序号再+1就行。

举个例子

2 4 6 8 3 5 4 2（m=4）
（先输出一个0）

|    操作     |队列|当前区域|输出|
| --------: | -----------: | -----------: | -----------: | -----------: |
|2入队          |2      |2      |2|
|4入队          |2 4    |2 4    |2|
|6入队          |2 4 6  |2 4 6  |2|
|8入队          |2 4 6 8|2 4 6 8|2|
|6、4、2出队，3入队|3      |4 6 8 3|3|
|5入队|3 5|6 8 3 5|3|
|5出队，4入队|3 4| 8 3 5 4|3|
只需算到n-1

# 代码
由于各元素序号也必须存储，才能判断长度，所以这里我的队列里面存的是元素序号
```cpp
#include<cstdio>
int q[2000001],n,m,l=1,r=1,x,a[2000001];
int main()
{
	scanf("%d%d",&n,&m);
	printf("0\n");
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d",&a[i]);
		while(a[q[r-1]]>=a[i]&&l<r)r--;
		//r是队尾，是空节点，r-1才是队列最后一个数 
		q[r++]=i;
		if(i-q[l]+1>m)l++;//如果长度大于m 
		printf("%d",a[q[l]]);
		if(i!=n-1)printf("\n");
	}
	return 0;
}
```



---

## 作者：Kevin_Wa (赞：44)

此题不妨可用线段树做做：

单调队列和$RMQ$，题解上漫天都是，还有一些较为敷衍的线段树，所以来一发详细的讲解：

先说说线段树：


现在我给你一道题。

1、一共有$n$个数，给你$m$个范围，让你求范围内的数和。（$n \leq 10^6$）

这不是很简单，不是小学生的$OI$题吗？前缀和，搞定。

再加强：

2、一共有$n$个数，给你$k$个操作，让你在$l$和$r$区间内加一个数，或让你求区间内的和。（$n \leq 10^4$）

emm前缀和无力维持了。

再加强：

2、一共有$n$个数，给你$k$个操作，让你在$l$和$r$区间内加一个数，或让你求区间内的和。（$n \leq 10^6$）

这需要一种强大的数据结构线段树



线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，

由于二叉结构的特性，它基本能保持每个操作的复杂度为$O$($log$ $n$)。

线段树的每个节点表示一个区间，

子节点则分别表示父节点的左右半区间，例如父亲的区间是[$a$,$b$]，那么($c$=($a$+$b$)/$2$)左儿子的区间是[$a$,$c$]，右儿子的区间是[$c$+$1$,$b$]。

由上图可得，

1、每个节点的左孩子区间范围为[$l$，$mid$]，右孩子为[$mid$+$1$,$r$]

2、对于结点$k$，左孩子结点为$2$*$k$，右孩子为$2$*$k$+$1$，这符合完全二叉树的性质。

线段树支持五种种操作：建树、单点查询、单点修改、区间查询、区间修改。

在其他延申里还支持如区间求最值。

## 1、建树

#### a、对于二分到的每一个结点，给它的左右端点确定范围。

#### b、如果是叶子节点，存储要维护的信息，再回到父节点时累计到父节点去。

#### c、合并

### 代码

```
void build(int k,int t,int w)
{ int mid;
	if (t>w) return;
	if (t==w)
	  {
	  	tree[k].l=t;tree[k].r=w;
	  	tree[k].w=a[t];
	  	return;
	  }
	mid=(t+w)/2;
	build(k*2,t,mid);
	build(k*2+1,mid+1,w);
	tree[k].l=t;tree[k].r=w;
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
```
## 单点查询
#### 查询一个点的状态，设待查询点为x
#### a、如果当前枚举的点左右端点相等，即叶子节点，就是目标节点。
#### b、如果不是，所以设查询位置为x，当前结点区间范围为了l，r，中点为mid。
#### c、如果x<=mid，则递归它的左孩子，否则递归它的右孩子
### 代码
```
void ask(int k)
{
    if(tree[k].l==tree[k].r) //当前结点的左右端点相等，是叶子节点，是最终答案 
    {
        ans=tree[k].w;
        return ;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask(k*2);//目标位置比中点靠左，就递归左孩子 
    else ask(k*2+1);//反之，递归右孩子 
}
```

## 单点修改
#### 即更改某一个点的状态。
#### 结合单点查询的原理，找到x的位置；根据建树状态合并的原理，修改每个结点的状态。

```
void add(int k)
{
    if(tree[k].l==tree[k].r)//找到目标位置 
    {
        tree[k].w+=y;
        return;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) add(k*2);
    else add(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//所有包含结点k的结点状态更新 
}
```

## 区间查询




代码

```
void sum(int k)
{
    if(tree[k].l>=x&&tree[k].r<=y) 
    {
        ans+=tree[k].w;
        return;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) sum(k*2);
    if(y>m) sum(k*2+1);
}
```
## 区间修改

同理

#### 我们不要递归到每个节点。所以要有一个新的概念：懒标记。

就像新年的时候的压岁钱，只有要用的时候才用，不要的直接给父母保管。

所以，传下来的更改值若在一个区间里，就不再下传，修改完该节点信息后，在此节的懒标记上打一个更改值。

当需要递归这个节点的子节点时，标记下传给子节点。这里不必管用哪个子节点，两个都传下去。

①当前节点的懒标记累积到子节点的懒标记中。

②修改子节点状态。在引例中，就是原状态+子节点区间点的个数父节点传下来的懒标记。

③父节点懒标记清0。这个懒标记已经传下去了，欠债还清，不用再还了。

### 下传代码

```
void pushdown(int k)
{
	tree[k*2].w+=((tree[k*2].r-tree[k*2].l+1)*tree[k].f);
	tree[k*2+1].w+=((tree[k*2+1].r-tree[k*2+1].l+1)*tree[k].f);
	tree[k*2].f+=tree[k].f;
	tree[k*2+1].f+=tree[k].f;
	tree[k].f=0;
}
```
### 区间修改代码

```
void add(int k,int t,int w)
{ int mid;
if (t>w) return;
	if (x<=t&&w<=y) 
	  {
	  	tree[k].w+=((w-t+1)*z);
	  	tree[k].f+=z;
	  	return ;
	  }
	mid=(t+w)/2;
	if (tree[k].f) pushdown(k); 
	if (x<=mid) add(k*2,t,mid);
	if (y>mid) add(k*2+1,mid+1,w);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
```

### 单点查询代码

```
 void ask(int k)//单点查询
{
    if(tree[k].l==tree[k].r)
    {
        ans=tree[k].w;
        return ;
    }
    if(tree[k].f) pushdown(k);//懒标记下传，唯一需要更改的地方
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask(k*2);
    else ask(k*2+1);
}
```
### 区间查询代码
```
int ask(int k,int t,int w)
{ int mid;
if (t>w) return 0;
	if (x<=t&&w<=y)
	  {
	  	return tree[k].w;
	  }
	mid=(t+w)/2;
	if (tree[k].f) pushdown(k); 
	int sum=0;
	if (x<=mid)sum+=ask(k*2,t,mid);
	if (y>mid)sum+=ask(k*2+1,mid+1,w);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
	return sum;
}
```

[更具体的描述](https://www.luogu.org/blog/2005-00-88-wyk/qian-tan-xian-duan-shu)
无耻地推荐一下我的博客

所以说此题为线段树的拓展：把求区间和改为了区间最小值，所以只需要将懒标记存储的内容改为最小值，区间修改再加工一下。

部分代码如下：

```
void build(int k,int t,int w)
{ int mid;
	if (t>w) return;
	if (t==w)
	  {
	  	tree[k].l=t;tree[k].r=w;
	  	tree[k].w=a[t];
	  	return;
	  }
	mid=(t+w)/2;
	build(k*2,t,mid);
	build(k*2+1,mid+1,w);
	tree[k].l=t;tree[k].r=w;
	tree[k].w=min(tree[k*2].w,tree[k*2+1].w);
}
int ask(int k,int t,int w)
{ int mid;
if (t>w) return 0;
	if (x<=t&&w<=y)
	  {
	  	return tree[k].w;
	  }
	mid=(t+w)/2;
	int sum=INT_MAX;
	if (x<=mid)sum=min(sum,ask(k*2,t,mid));
	if (y>mid)sum=min(sum,ask(k*2+1,mid+1,w));
	return sum;
}
int read(int &x)
{
	char c=getchar();int f=1;
	x=0;
	while (c<'0'||c>'9')
	  {
	  if (c=='-') f=-1;
	  c=getchar();
      }
	while (c>='0'&&c<='9')
      {
      	x=x*10+(int)c-48;
      	c=getchar();
	  }
	return x*f;
}

```

时间复杂度$O(n log n)$

只要不卡常，速度和单调队列和$RMQ$相差无几，也是一种求最值的方案，可以了解一下。

完整代码：


```
#include<bits/stdc++.h>
#define N 2000010
using namespace std;
struct node{
	int l,r,w,f;
}tree[N*2+1];
int x,y,z,i,a[N],n,m;
void build(int k,int t,int w)
{ int mid;
	if (t>w) return;
	if (t==w)
	  {
	  	tree[k].l=t;tree[k].r=w;
	  	tree[k].w=a[t];
	  	return;
	  }
	mid=(t+w)/2;
	build(k*2,t,mid);
	build(k*2+1,mid+1,w);
	tree[k].l=t;tree[k].r=w;
	tree[k].w=min(tree[k*2].w,tree[k*2+1].w);
}
int ask(int k,int t,int w)
{ int mid;
if (t>w) return 0;
	if (x<=t&&w<=y)
	  {
	  	return tree[k].w;
	  }
	mid=(t+w)/2;
	int sum=INT_MAX;
	if (x<=mid)sum=min(sum,ask(k*2,t,mid));
	if (y>mid)sum=min(sum,ask(k*2+1,mid+1,w));
	return sum;
}
int read(int &x)
{
	char c=getchar();int f=1;
	x=0;
	while (c<'0'||c>'9')
	  {
	  if (c=='-') f=-1;
	  c=getchar();
      }
	while (c>='0'&&c<='9')
      {
      	x=x*10+(int)c-48;
      	c=getchar();
	  }
	return x*f;
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(n);m=read(m);
	memset(a,INT_MAX,sizeof(a));
	for (int i=1;i<=n;i++) a[i]=read(a[i]);
	build(1,1,n);
	for (int i=1;i<=n;i++)
	  { int c;
	  	x=i-m;y=i-1;
	  	if (x<=0) x=1;
	  	if (x>y) 
	  	  {
	  	  	printf("0\n");
	  	  	continue;
			}
	  	printf("%d\n",ask(1,1,n));
	  }
	
}
```


---

## 作者：Aurora__ (赞：34)

## RMQ+滚动数组

------------

看见大佬们都用单调队列,也有用RMQ但没有滚动数组优化的方法
本蒟蒻就来发一份RMQ+滚动数组的题解

------------

窗口每次往后移一个位置，就进来一个数，出去一个数。每一次选最小的就行了。具体地看代码吧！RMQ其实很简单，主要在这里介绍滚动数组。

------------

### 滚动数组
  _“滚动数组的作用在于优化空间，主要应用在递推或动态规划中（如01背包问题）。因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。”_ 

#### 关于滚动数组的好文章在这里推荐一下
[滚动数组](https://www.cnblogs.com/GNLin0820/p/6434693.html)

------------

### 粘代码
- **没用滚动数组优化纯RMQ** ———*8个点*

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2000005;
int a[maxn],bp,n;
int f[maxn][20]; //[i,i+2^j)最大值
int g[maxn]; 

int main()
{
    scanf("%d %d", &n,&bp);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    //init
    int now=0;
    for (int i=1;i<=n;i++)
    {
    	if ((1 << (now+1))<=i) ++now;
    	g[i]=now;
    }
    for (int i = 1; i <= n; ++i) f[i][0] = a[i];
    for (int j = 1; (1 << j) <= bp; ++j) 
	{
        for (int i = 1; i <= n - (1 << j) + 1; ++i) 
		{
            f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
        }
    }
    int q=n;
    int l,r;
    for (int i=1;i<=q;i++)
    {
        if (i==1) 
        {
            printf("0\n");
            continue;
        }
        if (i==2) 
        {
            printf("%d\n",a[1]);
            continue;
        }
        l=i-bp;
        if (l<=0) l=1;
        r=i-1;
        int x = g[r-l+1];
//        while ((1 << x) <= r - l + 1) ++x;
//        --x;             //表示最大的x使得2^x小于等于r-l 
        int ans = min(f[l][x], f[r - (1 << x) + 1][x]);
        printf("%d\n",ans);
    }
    return 0;
}
```
- **使用了滚动数组优化的** ———*全AC*

```cpp
#include <bits/stdc++.h>
	
using namespace std;

const int maxn = 2000005;
int a[maxn],bp,n;
int f[maxn][2]; //[i,i+2^j)最大值
int g[maxn];

int main() 
{
    scanf("%d %d", &n,&bp);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    //init
    int now=0;
    for (int i=1;i<=n;i++)
    {
    	if ((1 << (now+1))<=i) ++now;
    	g[i]=now;
	}
	int t = 0;
    printf("0\n");
    now = 2;
    for (int j = 0; (1 << j) <= bp; ++j) 
	{
    	t = 1 - t;
    	if (j == 0) 
		{
    		for (int i = 1; i <= n; ++i) f[i][t] = a[i];
    	}
    	else 
		{
	        for (int i = 1; i <= n - (1 << j) + 1; ++i) 
			{
	            f[i][t] = min(f[i][1 - t], f[i + (1 << (j - 1))][1 - t]);
	        }
	    }
        while (now <= n && min(now - 1, bp) < (1 << (j + 1))) 
		{
        	int l=now-bp;
        	if (l<=0) l=1;
        	int r=now-1;
        	int x = g[r - l + 1];
        	int ans = min(f[l][t], f[r - (1 << x) + 1][t]);
        	printf("%d\n",ans);
        	++now;
        }
    }
    return 0;
}
```

好了，最后希望能帮到大家AC这题QwQ!

---

## 作者：hicc0305 (赞：28)

写了两种，单调队列和ST都写了

但是
ST加读优输优还是T了两个点，可是按时间复杂度nlogn貌似能过= =欢迎大神吐槽


先来单调队列：



```cpp
#include<cstdio>
int n,m,a[2000000],q[2000000],l=1,r=0;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",a[q[l]]);//输出队首
        if(i-q[l]+1>m && l<=r) l++;//查看队首是否在区间内，不在的话出队列
        while(a[i]<a[q[r]] && l<=r) r--;//进队比较，把比它大的都踢出去
        q[++r]=i;
    }
}
```
ST倍增，欢迎大神解答如何AC，别想复制黏贴，贴了也会T两个点，自己写吧：
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
int n,m,a[2000010],f[25][2000010];
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x*=10,x+=ch-'0',ch=getchar();
    return x;
}
int write(int x)
{
    if(x>=10)write(x/10);
    putchar(x%10+'0'); 
```
}//读优输优加不加随便，加了也是T = =

```cpp
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++)
        f[0][i]=a[i];//初始化
    for(int i=1;i<=log(n)/log(2);i++)
        for(int j=0;j<=n-(1<<i)+1;j++)//别忘了从0开始
        {
            if(f[i-1][j]==0) f[i][j]=f[i-1][j+(1<<(i-1))];
            else if(f[i-1][j+(1<<(i-1))]==0) f[i][j]=f[i-1][j];//注意除非两个都是0，不要取0，不然第一个会挂
            else f[i][j]=min(f[i-1][j],f[i-1][j+(1<<(i-1))]);//倍增转移
        }
    for(int i=1;i<=n;i++)
    {
        int l=max(0,i-m),r=i-1;//max记得加，不然RE
        int k=log(r-l+1)/log(2);
        int ans=min(f[k][l],f[k][r-(1<<k)+1]);
        write(ans);
        putchar('\n');
    }
    return 0;
}
再次求助一下各路大神，有没有ST过的？
```

---

## 作者：松风之狐 (赞：27)

# [求m区间内的最小值](https://www.luogu.org/problem/P1440)

**题目描述**：

一个含有n项的数列(n<=2000000)，求出每一项前的m个数到它这个区间内的最小值。若前面的数不足m项则从第1个数开始，若前面没有数则输出0。

读题之后可以发现，这道题就是在求：

> 给出一个长度为n的序列A，求A中所有长度为m的连续子序列中的最小值

而针对这种问题，**[单调队列](https://www.luogu.org/blog/Sweetlemon/dan-diao-dui-lie)**似乎是我们最好的选择。

单调队列，说是队列，却不符合队列“先进先出”的原则，它只是沿用了队列的思想，并具有一定的**单调性**，拥有一个队列头**head**和一个队列尾**tail**，用**head**和**tail**来控制队列的长度，筛选队列中的元素以及保持队列的**单调性**。

但怎样控制队列的长度，筛选队列中的元素以及保持队列的**单调性**呢？

这就是单调队列的实现了。

用样例来分析一下：

```
6 2
7 8 1 4 3 2
```

这样，我们就拥有了一个初始队列：7 8 1 4 3 2

拥有上帝视角的我们可以看出答案是：

```
0
7
7
1
1
3 
```

这时候，我们发现，不论第一个元素是多少，它之前m个元素的最小值永远为**0**~~（因为它之前并没有元素）​~~，而最后一个元素是多少也**没有关系**~~（因为它之后并没有元素）~~。

所以我们只用找到第2个到第n个元素中每个前m个元素的最小值就可以了，那么单调队列的**单调性**也应该是**递增**的，我们就可以把队列里每个元素的序号放入单调队列操作，就可以得到答案了。

于是我们可以开始模拟了：

考虑第一个元素，i=1，head=1，tail=0，q[tail]=0，a[1]=7，a[1]>a[ q[tail] ]，把a[1]放入不会破坏单调性，q[head]=0，这个元素距队首元素的距离为0，则队列为：1

考虑第二个元素，i=2，head=1，tail=1，q[tail]=1，a[2]=8，a[2]>a[ q[tail] ]，把a[2]放入不会破坏单调性，q[head]=1，这个元素距队首元素的距离为1，则队列为：1 2

考虑第三个元素，i=3，head=1，tail=2，q[tail]=2，a[3]=1，但a[3]<a[ q[tail] ]，把a[3]放入会破坏单调性，而a[3]<a[ q[tail] ]，由于求最小值，所以只能将a[ q[tail=2] ]弹出队列来保证单调性了，而a[3]>a[ q[tail=1] ]，这时再将a[3]放入就不会破坏单调性了，q[head]=1，这个元素距队首元素的距离为2，达到长度m=2了，这队列头**head**就向后移，则队列为：3。

以此类推，直到第n-1个，因为第n个后面没有元素，所以第n个不会进入队列，每次都输出队列头对应的元素值，就得到了答案。

## 代码实现：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define maxn 2000005
using namespace std;
int n,m;
int a[maxn];
int q[maxn];
int head,tail;
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    head=1;
    tail=0;
    printf("0\n");//第一个元素它之前并没有元素
    for(int i=1;i<n;i++)//从1~n-1个，第n个不进队列
    {
        while((head<=tail)&&((i-q[head])>=m)) head++;//控制队列的长度
        while((head<=tail)&&(a[q[tail]]>=a[i])) tail--;//筛选队列中的元素
        tail++;
        q[tail]=i;//保持队列的单调性
        printf("%d\n",a[q[head]]);//输出答案
    }
    return 0;
}
```

---

## 作者：tobie (赞：21)

首先，这道题有三种解法：

1. 暴力
2. 线段树
3. 单调队列
- - -
方法1：暴力 $O(nm)$ 不用说了，超时妥妥的。
- - -
方法2：线段树 $O(n\log n)$ 。

这道题显然是一道求区间最小值的问题，所以考虑到线段树。

虽然说这个数据规模可以使用线段树，但是，考虑到码量以及其他各种因素，我们还是选择更快的方法比较好。（~~不会线段树就直说嘛~~）
- - -
方法3：单调队列$O(n)$。

先看一张图：![image.png](https://i.loli.net/2020/02/24/bTR9ZFEP7wtOWaQ.png)

看到了吗，其中子序列`7 8 1`的最小值为1，不管这个窗口怎么移动，7和8一定不可能再次成为该序列的最小值，所以7和8我们就根本不用管，直接弹出即可。

所以我们可以用一个**单调递增**的队列来维护窗口。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[2000009],i,j,n,m;
int q[2000009],t=0,w=0;//单调队列，队列中存储的是下标
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d",&a[1]);//首先输入第一个数。
	printf("0\n");//第一个数之前没有数，所以可以很愉快地输出0。
	q[w]=1;//往队列里插入第一个元素。
	for(i=2;i<=n;i++)
	{
		scanf("%d",&a[i]);
		while(t<=w&&i-q[t]>m) t++;//如果队首的数已经不再范围里了，出队。
		printf("%d\n",a[q[t]]);
		while(t<=w&&a[q[w]]>a[i]) w--;//维护队列。
		q[++w]=i;//插入元素。
	}
	return 0;
}
```

---

## 作者：Adove (赞：14)

这道题非常神奇，用zkw线段树居然不会T；

以下是zkw线段树求区间最小值的模板。

```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int n,m,tree[4000001];
    int main()
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;++i)
            scanf("%d",&tree[n+i]);
        tree[2*n+1]=2e9;
        for(int i=n;i;--i)
            tree[i]=min(tree[i<<1],tree[i<<1|1]);//建树
        puts("0");
        for(int i=2;i<=n;++i)
        {
            int l=max(n,i-m-1+n),r=i+n;//zkw适合开区间查询
            int ans=2e9;
            while(l^r^1)//zkw线段树的查询
            {
                if(~l&1) ans=min(tree[l^1],ans);
                if(r&1) ans=min(tree[r^1],ans);
                l>>=1,r>>=1;
            }
            printf("%d\n",ans);
        }
        return 0;
}
```

---

## 作者：llzzxx712 (赞：9)

## 二元组小根堆
  先来看一下题目。~~嗯，题目这么短一定很水~~10分钟后打了一遍递推，样例没过，才发现我求的是从第一个到现在的最小值。
  
  然后又想用一个队列去做，删除是方便了，但怎么查询最小值呢？在想了10分钟后又放弃了这个方案。
  
  接着又想到了查询最小值，那么是不是可以用一个小根堆维护；那么怎么更新呢？
  经过思考，我们可以发现堆顶被更改只有两种可能
  
  1. 有一个更小的值加入，堆顶被更换
  1. 堆顶在当前位置i的m个之前，不能再用，需删去
  
  那么我们就可以用一个二元组的小根堆，
  第一元储存该点大小，第二元存它在序列中的位置。那么我们每次只要看堆顶的第二元x是否在当前位置i的m个之前，即 if(i-m>x) 那么删去堆顶
  ```cpp
priority_queue< pair< int , int > > q;
```
↑二元组大根堆定义，剩下的细节在代码注释中

  ~~又短又快♂~~的AC代码
  ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2000002];
priority_queue< pair< int , int > > q;//二元组二叉堆 
int main()
{
    cin>>n>>m>>a[1];//先把a[1]读入并放入堆中 
    q.push(make_pair(-a[1],1));//每次放入相反数（取出当然也要反一下），让其变成小根堆 
    printf("%d\n",0);//第一个永远输出0 
    for(int i=2;i<=n;i++){\
    	cin>>a[i];//读入 
    	int x=q.top().second;//去除堆中过时的堆顶 
    	while(i-m>x){
    		q.pop();
    		x=q.top().second;
		} 
		printf("%d\n",-q.top().first);//去相反数输出现在的堆顶 
		q.push(make_pair(-a[i],i));//最后再将当前值放入堆中（因为前m个值中是不包括当前值的） 
	}
	return 0;
}
	

```


---

## 作者：Khassar (赞：8)

/\*
我看题解里都是线段树和单调队列，以及说ST表会T的，但我还是先码了个ST表，果然T了两组

所以我要另寻它法，最后用暴力解决了，嗯，暴力……

至少我觉得比较暴力，写完后感觉有点像单调队列，但肯定不是啦

我觉得这题和P1886滑动窗口有点像，只不过这题数据范围更大，也只用统计最小值，

我便用我做P1886的方法暴力维护了一个大小为m的滑动窗口（P1886正解也是单调队列来着），统计最小值

结果竟然A了，应该是m不够大，没有卡这个，而且我把暴力维护最小值时的j打成了i还得了60分，真是不知该说什么好

主要思想跟我在P1886题解上写的一样：

窗口每次往后移一个位置，就进来一个数，出去一个数。

进来的数有两种情况：

一是它能做新的最小值，那就更新；二是都不是，没啥用就搁着。

出去的数也有两种情况：

一是它是原来的最小值，这时就从新扫一下整个窗口里的数，更新一下最大值（或最小值）；二也是都不是，就不管它。

一开始的时候窗口大小不足k时不用删数，加数之前输出一下当前记的最小值，就好了。

具体详情请看代码注释吧

\*/





    

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#define ll long long
#define R register
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
using namespace std;
const int N=2000005,inf=1e9+7;//inf用来初始化ans为极大值 
int n,m,a[N],l=1,r,ans=inf;
//ans为当前窗口的最小值，也就是答案，l为窗口区间的左端点，r为右端点 
inline int read() {//读入及输出优化 
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main()
{
    n=read();m=read();//m就是窗口大小啦 
    Rf(i,1,n) {
        a[i]=read();//每次读入一个数，然后先输出上一次窗口位置的答案，题目要求 
        if(ans==inf) write(0);//如果ans是极大值，那么现在是第一次，需要输出0 
        else write(ans);//不然就输出ans 
        putchar('\n');
        if(a[i]<ans) ans=a[i];//如果新来的数都小于当前最小值了，就让它做最小值
        //这里比较的最小值含要出去的数，如果这样都更新了，出去的数就不影响最小值了  
        else if(r-l+1>=m&&ans==a[l]) {//否则，如果窗口大小已经够m了，并且出去的数是之前的最小值 
            ans=inf;//把最小值赋成极大值 
            Rf(j,l+1,r+1) ans=min(ans,a[j]);//在新窗口中暴力扫一遍，找新的最小值 
        }
        if(r-l+1>=m) l++;//如果窗口大小已经够m了，左端点往前移一位，相当于最左边的数出窗口 
        r++;//右端点往前移一位，相当于最右边的数进窗口 
    }
    return 0;
}

```

---

## 作者：Michael_Li (赞：7)

刚好今天学了RMQ，然后来洛谷切题，就找到了这道题，结果一测，MLE+TLE，哈哈哈

正解是单调队列，这种区间最值而且区间不修改，大小不变，只是移动，大都可以用单调队列维护，单调队列的时间复杂度很优，但是不能修改而且于堆相比应用面就比较的小，主要还是应用于dp优化中，一下附上ac代码，rmq有需要可以私聊。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[2000000+10],q[2000000+10],h,t;//注意q存的是编号，方便出队比较，但注意比较大小的时候要用a[q[h]]；
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    printf("0\n");//以上常规部分
    h=1; t=1;
    q[1]=1; //0先输出了，然后把a[1]压入队
    for (int i=2;i<=n;i++){
        while (q[h]<i-m) h++;//每当你进一个数，要判断超出边界的，出队，写if应该也可以，不过while保险。
        printf("%d\n",a[q[h]]);//由于单调队列的单调性，队首即为区间最小值。
        while (a[i]<a[q[t]]&&t>=h) t--;//维护单调性，注意是t>=h而不是t>h，因为你有可能把队手也打掉了。理论上a[i]<=a[q[t]]更优，因为如果数值相等，越靠后的越有用，常数优化吧。
        q[++t]=i;//把这个数压进去，由于查询的区间不包括它，所以查询完毕后压队。
    }
    return 0;
}
//所以可见单调队列的代码很简短，但是理解起来也还是有一定的难度，希望这个小题目让大家入个门，dp的单调队列优化在这儿不展开讲，主要作者也不会，百度一下，你就知道
```

---

## 作者：bigbigdoggy (赞：4)

### hello，这是蒟蒻的第三篇题解

### 本题作为RMQ算法的第一题，只要理解了算法就没有难度了（当然除了我这样的蒟蒻）
## 下面来介绍一下算法:
```c
    RMQ（Range Minimum/Maximum Query），即区间最值查询，是指 这样一个问题：对于长度为n的 数列A，回答若干询问RMQ(A,i,j)， 返回数列A中下标在i，j之间的最小/大值。
                                                           ————度娘
* 可能会想到：开一个的二维数组Ans,对于每一个数对(i,j),预处理答案存到Ans里面
------------
 (dalao们会嫌弃，太慢啦。那么如何能用较短的时间预处理，又能用较快的时间查询呢？)
 
    用a[i]存要求最值的数列， F[i][j]表示从第i个位置开始，往后的2的n次方个数字中最大的数字是什么
    •如何预处理出F数组？
    •我们对j从小到大枚举。每次处理的时候，0~1 都已经处理好了 
    •f[i][j]=max(f[i][j-1],f[i+2^(j-1)][j-1])
```

    
再看看这一段代码
```cpp
void init(int a)
{
	for(int i=1;i<=n;i++)
	{
		f[i][0]=a[i];
	}
	for(int j=1;j<=20;j++)
	{
		for(int i=1;i<=n;i++)
		{
			if(i+(1<<j)-1<=n)
			{
				f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
			}
		}
	}
}
```


• RMQ相比其他数据结构的好处是能够在的预处理后，实现o1的查询
  
    当然，RMQ也有其局限性。 RMQ不支持修改，只能维护不会因为重复计算而影响答案的东西， 比如RMQ不能维护区间和 
    
    
    

------------
好了，以上是对RMQ的介绍，希望对大家有帮助；

# 另外，感谢我谷的dalao们提供的解答

下面是这一题的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000010][2];
int n,m;
int rig=0,lef=0;
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d",&a[rig][0]);
	printf("0\n");
	rig++;
	for(int i=1; i<n; i++)
	{
		if(i-a[lef][1]>m)
		{
			lef++;
		}
		printf("%d\n",a[lef][0]);
		int t;
		scanf("%d", &t);
		while(1)
		{
			if(rig<=lef||t>=a[rig-1][0])
			{
				break;
			}
			rig--;
		}
		a[rig][0]=t;
		a[rig][1]=i;
		rig++;
	}
	return 0;
}
```

### 注意，此处一定要加快读取速度，本蒟蒻用了最普通的scanf，各位大佬们各显神通吧

在理解RMQ之后，紧随其后的《忠诚》也就很容易解了，各位有耐心看到这里，orz

## bye

---

## 作者：Blue_wonders (赞：4)

本来是做线段树的时候刷到这道题的，但是仔细看了看题，发现小根堆实现很简单啊，但是题解里面又没有用这个方法的，所以我决定交一个题解
#### 别人都没想到的！
## STL小根堆AC
------------
- 首先STL自带小根堆，使用简洁，比某线段树的代码长度短了不知道多少倍

**STL堆的代码实现**
```
普通的STL堆是基于vector数组的
1、小根堆
priority_queue<int,vector<int>,less<int> >h;
这里h是一个vector，直接在这里定义好了，后面拿来用就行
2、大根堆
priority_queue<int,vector<int>,greater<int> >h;
3、自定义的堆
结构体也可以使用堆
struct node{//普通定义一个结构体 
    int num,...;
};
bool operator < (node a,node b){//按照方式定义
    return a.num>b.num;//小根堆定义 (符号：>)
    return a.num<b.num;//大根堆定义 (符号：<)
} 
priority_queue<node>h;//直接打上结构体名称就好 



操作：
1.进堆 h.back(a)//h是堆的数组名，a是要进堆的值
2.出堆 a=h.top()//把堆的最上面值赋给a，但是不清除
3.清除堆的最顶部元素 h.pop()//清除堆最上面的元素
4.堆内元素个数 h.size()
5.判断非空 h.empty//如果空返回0，非空返回1
```
### 思路
1. 先是输入
2. 因为第一个的时候堆是空的，不能输出，所以直接输出0
3. 从第2个开始，先出堆，再入堆(因为不能输出输入的这一项)
**注：判断出堆的时候要判断输进去的时间，如果超过了m的范围就要删除并且再出一个**
### 代码实现(附AC代码)
[AC详情](https://www.luogu.org/recordnew/show/17956104)

```cpp
#include<bits/stdc++.h>
using namespace std;
struct point{//定义结构体 
	int a,b;//a是第几号输入的，b是输入的大小 
};
priority_queue<point>h;//定义一个结构体堆 
bool operator < (point x,point y){//这里规定小根堆 
	return x.b>y.b;
}
int n,m,q;
point z;
int main(){
	scanf("%d%d%d",&n,&m,&q);//输入mn以及第一次的值 
	h.push((point){1,q});//先进队，保证堆飞空并且先输出0， 
	printf("0\n");
	for(int i=2;i<=n;i++){//从第二次开始循环 
		scanf("%d",&q);
		z=h.top();//先输出一个最小值 
		while(z.a<i-m){//如果这个值已经超出了要求范围就删掉并且重新输出一个最小值 
			h.pop();
			z=h.top();
		}
		h.push((point){i,q});//为了避免最后进的直接出来所以最后进堆 
		printf("%d\n",z.b);//输出这一次的最小值并换行 
	}
	return 0;
}
```
！！！

---

## 作者：Mine_King (赞：3)

新学了单调队列，就来做一下。这题是一道单调队列的入门题吧，一般讲单调队列都是以这题引入的吧……

先讲一下什么是单调队列。首先，它得是个队列(~~废话~~)，然后，它要满足单调性。什么是单调性呢？就是这个队列里的元素，必须是单调递增或单调递减的，而此时，队头的元素就是答案。说道这里，相信有很多人都知道该怎么做了。如果还不知道，那么继续往下看。我们在每次操作里，加入一个元素。但是加入之后它有可能会破坏单调性。那我们要维护这个单调队列，就得把前面那些比他大（这题是要找大的，其他的题目根据题意改变）都弹出队列。这样，就维护了这个单调队列，而无形之中就找到了答案。但是我们要注意，如果这个数不在范围内（因为它的范围只有一个数前的m个数，如果再往前，那么就超了），那么我们还要把他去掉。但是我们以什么为标准呢？这时，我们就要附带一个元素。这个元素就是它压入队列的时间。如果它的时间和当前这个数的时间之差大于m，那么这个数就不在范围内，就要弹出。

如果你记不住的话，你就记一句话：**如果一个人比你小，还比你强，那么你就打不过他了……** 首先申明，和CZ没有半毛钱关系。这句话就像单调队列，如果一个数在另一个数之后加入（比你小），它的值还比你小（比你强），那么他在的时候他比你强，他不在的时候你早就退役了，所以你永远都没有出头之日了（坏笑），记住这个，也能把单调队列推出来了。

上代码吧
```cpp
#include<bits/stdc++.h>
using namespace std;
int x,k,n,m;
deque<pair<int,int> >q;
inline int r()
{
    int x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*f;
}
int main()
{
	n=r(),m=r();
	for(register int i=1;i<=n;i++)
	{
		x=r();
		while(!q.empty()&&q.back().second>k) q.pop_back();
		if(!q.empty()&&i-q.front().first>m) q.pop_front();
		if(i!=1) q.push_back(make_pair(i-1,k));
		if(!q.empty()) printf("%d\n",q.front().second);
		else printf("0\n");
		k=x;
	}
	return 0;
}
```

---

## 作者：Skywalker_David (赞：3)

【思路】


单调队列。


题目比较裸，直接用一个单调队列维护即可。单调队列第一次写，总结有如下需要注意的地方：


1、   注意维护的是什么，本题中维护的是一个满足序号 >=i-m+1 的序列，其中序列满足a值单调递增。


2、   注意边界，特别是初始情况下是否平凡。


3、   注意单调队列的维护添加 与取值之间的顺序，取决于使用单调队列的目的。


 

还有需要注意的是题目中要求i之前m个，每次取值是算上当前a的所以需要错开一个。


 

【代码】


 

复制代码

 1 #include<iostream>

 2 #include<cstdio>

 3 using namespace std;

4
 5 const int maxn = 2000000+10;

6
 7 int a[maxn],que[maxn],d[maxn];

 8 int n,m,front,rear;

9
10 inline int read\_int() {

11     char c; c=getchar();

12     while(!isdigit(c)) c=getchar();

13
```cpp
14     int x=0;
15     while(isdigit(c)) {
16         x=x*10+c-'0';
17         c=getchar();
18     }
19     return x;
20 }
```
21
```cpp
22 int main() {
23     n=read_int(); m=read_int();
24     a[0]=1<<30;               //边界不取 
25     front=rear=1;
26     for(int i=1;i<=n;i++)
27     {
28         a[i]=read_int();
```
29
30         //注意顺序 

31         while(front<=rear && (que[front]<(i-m+1))) front++;

32
33         while(front<=rear && a[i]<=a[que[rear]]) rear--;  //注意维护a值最小的

34
35         que[++rear]=i;

36
37         d[i]=a[que[front]];

38
```cpp
39     }
40     cout<<0<<"\n";
41     for(int i=1;i<n;i++) cout<<d[i]<<"\n";
42     return 0;
43 }
复制代码
```

---

## 作者：Starlight237 (赞：3)

%%%Aehnuwx dalao轻易掌握单调队列
## 树状数组大法好！
经典的RMQ问题，但是线段树常数巨大，而ST表80分，怎么办呢？

可以考虑改造树状数组（a是原数组，tr是树状数组）。

考虑初始化，我们可以按照树状数组的规律，依次向前枚举被包含的区间，然后一个一个区间地取最值与当前位置比较，最后更新出$tr_i$。

考虑查询从i到j之间的最值，显然不可以直接用$tr[j]$作为答案，因为对应的左端点不一定会等于i。所以我们可以分类求解，当在区间外时（不在$tr[i]->[i-lowbit(i)+1,i]$内时）直接用原数组更新，否则用树状数组更新。

所以可以执行以下操作（l,r的更新见code）：
- 当$l<i$时，取$a[j]$更新答案。
- 当$l>=i$，取$tr[j]$来更新答案。
- 当$l==i$时，返回答案。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
extern "C"{
namespace io{
	#define IOSIZE 100000
	static char in[IOSIZE],*p=in,*pp=in,out[10000000],*q=out,ch[20],*t=ch;
	inline char gc(){return p==pp&&(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?EOF:*p++;}
	inline int read(){
		reg int x=0;reg char ch;
		while(!isdigit(ch=gc()));
		while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();
		return x;
	}
	inline void write(long long x){
		!x&&(*q++='0'),x<0&&(*q++='-',x=-x);
		while(x)*t++=x%10+48,x/=10;
		while(t!=ch)*q++=*--t;
		*q++='\n';
	}
	inline void flush(){fwrite(out,1,q-out,stdout);}
}}
#define rd io::read
#define wt io::write
static int n,m,a[2000001],tr[4000001];
inline void init(){
	n=rd(),m=rd();
	memset(tr,0x3f,sizeof tr);
	for(reg int i=1,x;i<=n;++i){
		x=rd(),a[i]=tr[i]=x;
		for(reg int j=1;j<(i&-i);j<<=1)
			tr[i]=min(tr[i],tr[i-j]);
	}
}
inline int query(int l,int r){
	reg int ans=0x3f3f3f3f;
	for(;;){
		ans=min(ans,a[r]);
		if(l==r)return ans;
		for(r-=1;r-l>=(r&-r);r-=(r&-r))
			ans=min(ans,tr[r]);
	}
}
int main(){
	init();
	wt(0);
	for(reg int i=2;i<=n;++i)
		wt(query(max(i-m,1),i-1));
	io::flush();
	return 0;
}
```

---

## 作者：doctorZ_ (赞：3)

一看到这道题目，我就想到了线段树
###### ~~毕竟我只会线段树~~

------------
# 简介线段树

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。
使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。
- 此段文字来源于百度百科

------------
现在我们把目光看向这道题目，这道题目不会修改区间，所以我们也就少了区间修改和懒标记的过程。
## 一、建树与维护
我们先来分析下线段树的一些性质  
每一个节点的左儿子就是这个节点的编号乘以二   
右儿子也是这个点的编号乘以二再加一    
相反，如果我们要寻找一个节点的父亲节点只需要将节点标号整除以二即可!
![](https://cdn.luogu.com.cn/upload/pic/57778.png)



$\ \ \ \ \ \ \ $对于$A[1:4] = \{1,2,3,4\}$来说，线段树如上所示，蓝色代表每个结点的编号，红色代表每个节点存储的区间，绿色代表该区间最小值。     
$\ \ \ \ \ \ \ $可以发现，每个叶子结点的值就是数组的值，每个非叶子结点的度都为二，且左右两个孩子分别存储父亲一半的区间。每个父亲的存储的值也就是两个孩子存储的值的最小值。    
$\ \ \ \ \ \ \ $整理一下思绪，现在已经明白了数组如何存在线段树，结点间的关系，以及使用递归的方式建立线段树，那么具体如何建立线段树，我们来看代码，代码中不清楚的地方都有详细的注释说明。
```cpp
int n,a[N+1];//n表示数的个数，a为数组 
struct node
{
    int minn,l,r;
}tree[4*N+1];//树的定义 minn表示区间最小值，l表示区间左下标，r表示区间右下标 
void push_up(int x)//树的维护 
{
	//x<<1等同于x*2,x<<1|1等同于x*2+1
	if(tree[x<<1].minn<tree[x<<1|1].minn)
    	tree[x].minn=tree[x<<1].minn;
    else
    	tree[x].minn=tree[x<<1|1].minn;
    //等同于tree[x].minn=min(tree[x<<1].minn,tree[x<<1|1].minn) 父亲最小值为左右儿子最小值 
}
void build(int x,int l,int r)//x表示当前树的编号 
{
    tree[x].l=l; tree[x].r=r;//先将左右区间存起来 
    if(l==r)//如果左下标等于右下标，那么最小值就为这个数 
    {
        tree[x].minn=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    push_up(x);//建好左右两棵子树，进行树的维护 
}
```
## 二、区间查询
查询 l ~ r 区间的最小值，我们还是从根节点开始往下递归，如果当前结点在 l ~ r 的区间内，则返回这个结点的信息且不需要再往下递归了，这样从根节点往下递归，时间复杂度也是O(logN)。
![](https://cdn.luogu.com.cn/upload/pic/54813.png)
再用上面这幅图来看     
如果我们要查询2~3的最小值，    
先从根节点开始，1~4，不在区间内，向下递归    
先找1~2，也不在，
1~1很明显不符合条件，则返回2~2最小值    
回馈到1~2,则1~2的2到3区间内的最小值为2    
同理，3~4的2到3区间内的最小值为3   
2更小，故2~3的最小值为2     
怎么样，是不是很简单?
下面是区间查询代码
```cpp
int query(int x,int l,int r)// x表示当前树的编号 ,l~r为查询区间 
{
    if(l<=tree[x].l&&tree[x].r<=r)//如果当前结点在 l ~ r 的区间内，则返回这个结点的最小值 
        return tree[x].minn;
    int mid=(tree[x].l+tree[x].r)>>1;
    int a=2147483647,b=2147483647;
    if(l<=mid)//如果在左子树区间 
        a=query(x<<1,l,r);
    if(r>=mid+1)//如果在右子树区间
        b=query(x<<1|1,l,r);
    if(a>b)//取最小 
    	a=b;
    return a;//返回最小值 
}
```
下面就是完整代码啦
```cpp
#include<cstdio>
#define N 2000000
using namespace std;
int n,a[N+1];
struct node
{
    int minn,l,r;
}tree[4*N+1];
void push_up(int x)
{
	if(tree[x<<1].minn<tree[x<<1|1].minn)
    	tree[x].minn=tree[x<<1].minn;
    else
    	tree[x].minn=tree[x<<1|1].minn;
}
void build(int x,int l,int r) 
{
    tree[x].l=l; tree[x].r=r; 
    if(l==r)
    {
        tree[x].minn=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    push_up(x);
}
int query(int x,int l,int r) 
{
    if(l<=tree[x].l&&tree[x].r<=r) 
        return tree[x].minn;
    int mid=(tree[x].l+tree[x].r)>>1;
    int a=2147483647,b=2147483647;
    if(l<=mid)
        a=query(x<<1,l,r);
    if(r>=mid+1)
        b=query(x<<1|1,l,r);
    if(a>b)
    	a=b;
    return a;
}
int read()
{
	int ans=0,x=1;
    char c=getchar();
	while (c<'0'||c>'9'){if (c=='-') x=-x;c=getchar();}
    while (c>='0'&&c<='9'){ans=(ans<<1)+(ans<<3)+(c^48);c=getchar();}
    return ans*x;
}
int main()
{
    int m;
    n=read(); m=read();
    for(register int i=1;i<=n;i++)
        a[i]=read();
    build(1,1,n);
    for(register int i=1;i<=n;i++)
    	if(i!=1)
    	{
    		if(i-m>1)
    			printf("%d\n",query(1,i-m,i-1));
    		else
    			printf("%d\n",query(1,1,i-1));
		}
    	else
    		printf("0\n");
    return 0;
}
```




---

## 作者：HyperLuXury (赞：2)

我看没人用pascal做，我就发篇pascal题解吧（本人PC党）

这题采用单调队列，先解释一下样例：7 8 1 4 3 2

1.第 1 个位置之前没有值所以是 0，现在有了一个数 7；

2.第 2 个位置之前只有一个数 7，故最小值为 7，现在有一两个数 7 8；

3.第 3 个位置之前两个数为 7 8，最小值为 7；现在有三个数 7 8 1，当然由于只要前面两个数，所以可以把 7 去掉，剩下 8 1，而由于求的是最小值，显然只需要保留 1， 8 不可能是最小值了；

4.第 4 个位置之前的最小值为 1，现在又加进来一个数 4，所以又有两个数 1和4；

5.第 5 个位置之前两个数 1 4，最小值为 7，现在又加进来一个数 3，当前由于 1 已经不在范围内，所以去掉，处理 4 3，由于 3 比 4 小，则只保留最小值 3；

6.第 6 个位置之前最小值为 3，又加进来 2，即为 3 2，由于 2 比 3 小，所以只需要保留 2 就可以了。

解释完样例，上代码：

```pascal
var n,m,i,t,w,x:longint;//t是头指针，w是尾指针
a:array[0..2000001,0..1] of longint;//a[x,0]代表值，a[x,1]代表位置
begin
readln(n,m);
read(a[w,0]);inc(w);//第一个数进队列
writeln(0);//第一个数一定是输出0的
for i:=1 to n-1 do
  begin
  if i-a[t,1]>m then inc(t);
  writeln(a[t,0]);//输出最小数
  read(x);//继续读入
  while (t<w) and (x<a[w-1,0]) do dec(w);//尾指针向前移
  a[w,0]:=x;a[w,1]:=i;inc(w);//第（i+1）个数进队列
  end;
end.

```


---

## 作者：RedreamMer (赞：2)

# P1440 题解

### 思路：优先队列+卡常

许多巨佬都没用优先队列，自己就尝试了一下，结果就卡过去了

每次于第 $i$ 个输出，先将下标为i-1个数入，优先以各个数的数值大小排序，当要输出时，将那些在队头且不符合条件（也就是这个数的下标不在输出范围之内）的数全都弹出，直接输出队头（并不需弹出）

### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int s[10000001];
struct node{
	int dis,now;
	bool operator<(const node& t)const{//排序规则 （使用重载运算符较方便） 
		return t.dis<dis;
	}
}k;
priority_queue<node> st;//优先队列 
int main(){
	scanf("%d%d",&a,&b);
	for(int i=1;i<=a;i++)
	scanf("%d",&s[i]);
	printf("0");//第一个输出数肯定是0 
	for(int i=2;i<=a;i++){
		k.dis=s[i-1];
		k.now=i-1;
		st.push(k);
		k=st.top();//寻找那些不符合条件的并把它们弹出去 
		while(k.now<i-b){
			st.pop();
			k=st.top();
		}
		printf("\n%d",k.dis);
	}
	return 0;//结束AC 
}
```
心得：由于数据太水，这种方法才能通过，其实可以不用优先队列，更加快

---

## 作者：WOWHandsome (赞：2)

emm 蒟蒻最近刚学单调队列，这是一道单调队列的入门题，然后已经有的题解都是直接讲代码，蒟蒻自己来讲一讲~~通俗易懂~~的思路吧。（其实代码很短，核心只有5行，各位不必恐慌）

## 暴力出奇迹

这题所有人看到题面的第一个反应，肯定是暴力。每次查找前$m$个数不就行了？一看数据范围，顿时无语。$O(n*m)$暴力完美$TLE$。

## 找到优化的契机

我们观察样例，从中发现了一些规律——在寻找 $i$ 的前 $m$ 个数的时候，发现了重复。**我们在寻找 $i-1$ 的前 $m$ 个数的时候，枚举了区间 $[i-m, i-1]$。而我们在寻找 $i$ 的前 $m$ 个数的时候，又枚举了区间 $[i-m+1, i]$。也就是说，我们重复枚举了 $m-1$ 个数，这些数导致了如此高的时间复杂度。**

如图（纯鼠标绘画，没有触屏的悲剧）。

![](https://ae01.alicdn.com/kf/H90a9a90e794d494389d8859f69fc737cB.jpg)

## 单调队列

我们发现，在求`min`值的过程中，重复遍历了这个数组，导致效率低下。

那么，我们能不能记录下`min`值呢？我们发现，其实我们**要求的区间是固定的**。那么我们思考一下，

**如果， $j$ 在某一个区间里面是最小值，在这时，来了一个 $i$ 。$i$ 比 $j$ 来的小，也比 $j$ 后来（换句话说，$i$ 比 $j$ 年轻，又比 $j$ 优秀），那么 $j$ 永远不可能成为之后区间里面的 $min$ 值了！那么，我们可以不用考虑 $j$，把 $j$ 弹出。**

那么，我们发现，这是一个 **先进先出** 的数据结构，很显然，我们使用 **队列** 来进行操作。

但是，我们还需要考虑一点：**队列中每一个元素都要比前面来的优秀，所以，我们还需要维护队列的单调性。**

我们就引入了一个新的数据结构：**单调队列 $Monotone-Queue$**

这种数据结构常与 **动态规划** 算法连用，作用于 **状态1D/转移1D 等** 动态规划中。在此题中，**我们在一端维护单调性，另一端维护时效性**。

## 代码实现

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

int a[2000005], que[2000005];
// que数组模拟单调队列的操作

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    int head = 1, tail = 0;
    printf("0\n");
    // 一开始，先输出一个0
    for (int i = 1; i <= n-1; i++) {
    while (head <= tail && a[que[tail]] >= a[i]) tail--;
    // 维护单调性
    que[++tail] = i;
    // 入队
    while (head <= tail && que[head] <= i-m) head++;
    // 维护时效性
    printf("%d\n", a[que[head]]);
    // 最后输出队列的head就可以了
    } 
    return 0;
} 
```

## 小结

总而言之，单调队列在OI中的应用很少。但是，这是一个很重要的板子。如果你理解透彻了，就把它记忆下来。很多类型动态规划的优化就是基于这个模板的。另外，蒟蒻刚学OI，菜到不行。所以，还请大佬多多指教。

## 蒟蒻の博客

蒟蒻的博客最近很不友好的清档了一次（因为换了地址名）。最近在修呢，欢迎各位大佬来我的博客玩鸭~


**本题博客链接**：[**点我进入**](https://www.cnblogs.com/ByhBlog/p/11416332.html)

**博客链接&地址**：[**https://www.cnblogs.com/ByhBlog**](https://www.cnblogs.com/ByhBlog)

---

## 作者：wangbw (赞：2)

## 前言

8月28号我用老师讲的方法做这道$RMQ$，样例一次就过哎！兴奋地交上去，结果$50$分……（$5×TLE+5×AC$）我这才重视题目里的$m≤n≤2000000$，我没想到会$TLE$……$QAQ$，然后我想想想……（省略$∞$个想）想不出应该如何优化……………于是翻题解，看到@一扶苏一 写的题解，恍然大悟！！！~~然后我$get$到了新的套路~~


------------
## 正题
## 这道题用二分即可完美AC!
**我最初做这道题就是用的这个方法，也就是老师讲的那个方法。自认为那天认真听了课**


### 怎么“二分”?
假设要找$[1,6]$区间的最**小**值
这些数是$7,8,1,4,3,2$

- 把$[1,6]$分成两半，分成$[1,3]$和$[4,6]$

- $[1,3]$又可以分成$[1,2]$和$[3,3]$ 此时$[1,2]$里的数有两个数$7$和$8$，最小的数是$7$，$[3,3]$里的数只有$1$，最小的是$1$

- 这时合并$[1,2]$和$[3,3]$，把$7$和$1$比较，**可以得到$[1,3]$里最小的数是$1$**

- 同样的，$[4,6]$可以分成$[4,5]$和$[6,6]$ 此时$[4,5]$里的数有$4$和$3$，最小的是$3$，$[6,6]$里的数只有$2$，最小的是$2$

- 合并$[4,5]$和$[6,6]$，把$3$和$2$比较，**可以得到$[4,6]$里最小的数是$2$**

- 合并$[1,3]$和$[4,6]$，把$1$和$2$比较，最小的是$1$，**可以得到$[1,6]$区间的最小值是$1$，结束。**

**“二分”是不是很简单呢？**

```cpp
int search(int l,int r)
{
    int mid=(l+r)/2;
    if(l>r)
        return 0;
    if(l==r)
        return s[l];
    if(r-l==1)
        return min(s[l],s[r]);
    return min(search(l,mid),search(mid+1,r));
}
```
~~至于$min$是什么都知道吧……就是一个取两个数之间比较小的数的函数~~

------------

## 现在问题来了
### 没错就是$5×TLE+5×AC$
怎么优化呢？这里我参考了@一扶苏一 的优化方案（我没想出来如何优化$QAQ$，借鉴别人的方法也不是坏事）

~~其实我觉得@一扶苏一 写的不是很到位……（我是这么觉得。你可以说我是在做补充说明）然后~~我认真研究了这位$dalao$的代码，明白了！！！

------------
## 我的理解
**我那$50$分的代码每次循环都会用“二分”计算，这样计算量大，极端一点的数据会不通过，就是$TLE$。**其实在前面的数达到$m$项之前一个个**比较**就好了，完全不需要二分。达到或者超过$m$项时，看上一个区间内的第一个数是不是那区间内最小的数，如果不是就可以直接看下一个区间，大大的减少了计算量！！！当然，不管怎样，**每次循环都要存储区间里最小的数**。

------------

```
6 2
7 8 1 4 3 2
```
- 在上面的数据中，$n=6,m=2$

- 一开始$i=1$，就是$s[1]$，前面没有数，输出$0$
- 现在$i=2$，就是$s[2]$，前面有一个数。那么$a[1]$和$s[1]$比较，$s[1]$更小，那么$a[2]$就更新成$s[1]$，输出$a[2]$
**（$a[1]$要设成一个很大的数，否则会出错）**

- 现在$i=3$，就是$s[3]$，前面有两个数，已经达到$m$项，那么看$a[2]$是否等于$s[i-m-1]$。条件不成立（$s[i-m-1]=s[0]=0,a[2]=7$），那么$a[2]$和$s[2]$比较（$a[2]=7,s[2]=8$），$a[2]$更小，那么$a[3]$更新成$a[2]$。这时$a[3]$表示区间$[1,2]$最小数是$7$。输出$a[3]$

- 现在$i=4$，就是$s[4]$，前面有三个数，已经超过$m$项，那么看$a[3]$是否等于$s[i-m-1]$。条件成立（$s[i-m-1]=s[1]=7,a[3]=7$），那么调用上文的$search$函数，寻找区间$[i-m,i-1]$的最小值，把结果存入$a[4]$，输出$a[4]$

- ……

输入：
```
6 2
7 8 1 4 3 2
```
答案：$0$ $7$ $7$ $1$ $1$ $3$


------------
~~华丽的~~$AC$代码
```cpp
#include<cstdio>
const int maxn=2e6+1;
int s[maxn],ans[maxn],n,m;
int min(int x,int y)
{
    if(x<y)
        return x;
    return y;
}
int search(int l,int r)
{
    int mid=(l+r)/2;
    if(l>r)
        return 0;
    if(l==r)
        return s[l];
    if(r-l==1)
        return min(s[l],s[r]);
    return min(search(l,mid),search(mid+1,r));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&s[i]);
    printf("0\n");
    ans[1]=1e9;
    for(int i=2;i<=n;i++)
    {
        int a=i-m,b=i-1;
        if(a<1)
            ans[i]=min(ans[i-1],s[i-1]);
        else if(ans[i-1]!=s[a-1])
            ans[i]=min(ans[i-1],s[i-1]);
        else
            ans[i]=search(a,b);
        printf("%d",ans[i]);
        if(i!=n)
            printf("\n");
    }
    return 0;
}
```
$2e6=2×10^6$

---

## 作者：zhangchengkai (赞：2)

来一发简明的题解

```cpp
#include<cstdio>
int n,m,l=0,r=1;//r为队首，l为队尾 
int a[2000009];
int f[2000009];//单调队列 
inline void init(int x)//x是指第x个数哦 
{
    while(x-m>=f[r] && r<=l) r++;//如果f[r]已不在区间则出队，注意“r<=l” 否则会re 
    while(l>=r && a[x]<=a[f[l]]) l--;//f[l]一定大于x，如果 a[x]<=a[f[l]]，则a[f[l]]不会再是答案 
    f[++l]=x;//入队 
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",a[f[r]]);//注意要先输出 
        init(i);//入队 
    }
    return 0;
}//哈哈简明的21行
```

---

## 作者：DDOSvoid (赞：2)

看楼下都是什么线段树（~~题解的线段树现在好像都A不了~~）单调队列 那我就来水一发zkw线段树（~~重口味~~）

有两个点900ms水过（全靠读入和输出优化）

不太懂zkw的小伙伴可以去看看这两个博客

http://blog.csdn.net/keshuqi/article/details/52205884 

http://www.cnblogs.com/SinGuLaRiTy2001/p/6591718.html 

···cpp

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 2000010
using namespace std;
int n,dep=1,tree[4*N],m;
inline int query_min(int l,int r){
    int L=0,R=0,res=0;
    l+=dep-1;r+=dep-1;
    if(l==r){
        while(l){
            res+=tree[l];
            l>>=1;
        }
        return res;
    }
    for(;l^r^1;l>>=1,r>>=1){
        L+=tree[l],R+=tree[r];
        if(~l&1) L=min(L,tree[l^1]);
        if(r&1) R=min(R,tree[r^1]);
    }
    L+=tree[l],R+=tree[r];
    res=min(L,R);
    while(l>1){
        l>>=1;
        res+=tree[l];
    }
    return res;
}
```
/\*
    if(~l&1) ->  if(l%2==0)

    if(r&1) ->   if(r%2!=0)

那么为什么要这样呢

很简单

若编号为奇数 则肯定是左儿子 反之 则肯定是右儿子

假设有两个兄弟节点 A B

如果A为左儿子  那么他的兄弟一定为右儿子

并且如果他是左儿子 那么他的兄弟一定在区间内

如果他是右儿子 那么他的熊第也一定在区间内

这样计算可能会重复

也就是 这两个节点互为兄弟

就是l^r^1 == 0 时 这时循环也就结束了

\*/
```cpp
inline void read(int &x){
    x=0;
    int flag=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')flag=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    x*=flag;
}
inline void build(){
    while(dep<n)dep<<=1;//找到不小于n的2的次幂 
    for(int i=dep;i<dep+n;i++)
        read(tree[i]);//直接输入叶子节点  
    for(int i=dep-1;i;i--){ // 差分思想 
        tree[i]=min(tree[i<<1],tree[i<<1|1]);
        tree[i<<1]-=tree[i];
        tree[i<<1|1]-=tree[i];
    }
}
inline void write(int x){
    if(x==0)putchar('0');
    int ts=0,Out[23]={0};
    while(x){
        Out[++ts]=x%10;
        x/=10;
    }
    while(ts>0)putchar(Out[ts--]+'0');
    putchar('\n');
}
int main(){
    read(n);
    read(m);
    build();
    write(0);
    for(int i=2;i<=n;i++)
        write(query_min(max(1,i-m),i-1));
    return 0;
}
···
```

---

## 作者：magolor (赞：2)

单调队列裸题代码，千万注意PE和TLE，每行回车不是空格，cincoutTLE，必须scanf,printf





```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n,m,a[2000005];
int q[2000005],head = 1, tail = 1;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++)
        scanf("%d",a+i);
    printf("0\n"),q[1] = 1;
    for(int i = 2; i <= n; i++)
    {
        printf("%d\n",a[q[head]]);
        if(q[head] <= i-m)
            head++;
        while(a[i] <= a[q[tail]] && tail >= head)
            tail--;
        q[++tail] = i;
    }
    return 0;
}
```

---

## 作者：1saunoya (赞：2)


>[$problem$](https://www.luogu.org/problemnew/show/P1440)

>线段树 求 $RMQ$问题 $orz$ 原因是因为我的$ST$表炸了
~~（我太弱了）~~

>$RMQ$问题通常是求区间最值。 比如说 :$X - Y$的最大值？

>这样的问题往往无从下手 我们需要一个解决$RMQ$问题的算法。
比如说是:$ST$表 ， 线段树。

>其实还有单调队列的方法。 其他题解也说到了。（代码简短）

>可我还是不知道为什么我选了 $ST$表 && 线段树。

>可能是因为我比较笨吧（大雾

>先讲讲$ST$表吧 虽然说不能$AC$ 但是我看见有人 用这个方法$AC$ 了

>$ST$表的思路主要是 预处理 然后 $O(1)$复杂度的查询 适合这种问题

>用一个$f[i][j]$ 来 表示 $i$ ~ $ i + 2^j$的最大值 从而到这样

>这样子时间是完全$ojbk$的 但是反观 内存 $n\ log \ n$的一个内存 $N<=200w$ 所以显然不行
(如果有哪位神仙用$ST$表AC了麻烦点评测记录告诉我如何不$MLE$)

>评测记录:[$Here$](https://www.luogu.org/recordnew/show/18138448)


>所以去想线段树 线段树的查询大概是$log\ n$ 

>$n \ log \ n$ 也勉强过得去吧。
~~但是貌似没有单调队列快（还不是我弱）~~


> 回归正题 线段树 (分治的方法

>首先我们需要定义数组  以及 建树

```cpp
const int N = 2e6 + 10 ;
struct node {
    int l , r , w ;
#define lt k << 1
#define rt k << 1 | 1
}tree[N << 2] ;
```

>不要问我为啥$<<2$ ~~因为我也不知道~~ 线段树的数组大小通常是$N$的$4$倍

```cpp
inline void build(int k,int l,int r) {
    if(l > r) return ;
    if(l == r) {
        tree[k].l = l , tree[k].r = r , tree[k].w = a[l] ;
        return ;
    }
    int mid = (l + r) >> 1 ;//分治Here
    build(lt , l , mid) ;
    build(rt , mid + 1 , r) ;
    tree[k].l = l , tree[k].r = r ;
    tree[k].w = min(tree[lt].w , tree[rt].w) ;
}
```
>建完树之后我们需要做一个操作 : $query$（当然只是函数名我个人喜欢这种函数名）


```cpp
inline int query(int k,int l,int r,int x,int y) {
    if(l > r) return 0 ;
    if(l >= x and r <= y) return tree[k].w ;
    int mid = (l + r) >> 1 ;
    int sum = inf ;
    if(x <= mid) sum = min(sum , query(lt , l , mid , x , y)) ;//分治
    if(y > mid) sum = min(sum , query(rt , mid + 1 , r , x , y)) ;
    return sum ;
}
```

>所以易证时间复杂度 $O(n\log\ n) $ 

>空间复杂度 $O(N*4)$

>至于完整代码 [$Here$](https://www.cnblogs.com/qf-breeze/p/10738659.html)


---

## 作者：world_romantic_xebec (赞：2)

我的想法十分简单，先让数组最大，使得更新最小值方便，然后每次输入数字时更新最小值及最小值所在坐标，并每次输出（i-m）~m位置的最小值，若越界（最小值坐标不在i-m至m之间），则从i-m处进行判断，这是个很有趣的DP，但是要对1号位进行特殊处理，从2号开始走循环。

想法很简单，望各位大佬可以提出意见！QWQ

```cpp
#include <bits/stdc++.h>
const int maxn=2000010;
int n,m;
int a[maxn];
inline int read(){//快读
   int s=0,w=1;
   char ch=getchar();
   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main (){
	memset(a,0x3f3f3f3f,sizeof(a));
	n=read();m=read();
	for (int i=1;i<=n;i++)
	a[i]=read();
	int minx=a[1];
	int minplace=1;
	printf("0\n");//由于0号位置前没有最小值，所以按照样例输出0
	for (int i=2;i<=n;i++)
	{
		if (a[i-1]<=minx)//若最小值大于当前值，则更新最小值及最小值坐标
		minplace=i-1,minx=a[i-1];
		
		if (minplace<i-m)//越界判断，从越界处进行重新循环
		{
		minx=a[i-m];
		minplace=i-m;
		
		for (int j=i-m+1;j<=i-1;j++)
			if(a[j]<=minx)
			minx=a[j],minplace=j;
		}
		
		printf("%d\n",minx);
	}
}
```

---

## 作者：Hexarhy (赞：2)

这道题是裸的考查单调队列，通常用手写或`deque`实现。这里却给出时间上弱化版的单调队列，采用优先队列`priority_queue`实现。

时间复杂度：$O(n\log n)\approx  4\times 10^8(n=2\times 10^6)$

即，$O(\text{勉强能过})$


------------

原理是什么呢？类似于普通的单调队列，依然需要存入一个值及其位置。

分两种情况讨论（$i$为读入的数量）：

- 当$i\le m$时，直接输出即可，无需变动。

- 当$i>m$时，我们就需要弹出。显然，如果队列里的最小值要么在区间内，要么在区间外。于是我们对这个最小值的位置进行判断。不在这个区间内就弹出。**可能有连续几个最小值不在区间内，因此要进行`while`循环**。

### 注意：

- 区间是$[i-m,i)$，左闭右开。因此在将刚读入的值存入队列时，先输出再进队。

- $i=1$时特判输出$0$。因为队列为空，无法输出。特判完了之后别忘了把第一个值入队。

- **一定要优化常数或开O2**，否则会$\color{purple}\texttt{TLE}\ 3$个点。（这就暴露弱化版的弱点）。

经测试，优化常数最慢的点跑$700ms$，优化常数+02最慢的跑$400ms$。



------------

献上丑陋的代码：


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define val first//元素的值
#define pos second//元素的位置
int n,m;
priority_queue<pii,vector<pii>,greater<pii> > q;//默认以pair的first作为排序关键字

void input(void)
{
	scanf("%d%d",&n,&m);
	for(register int i=1,a;i<=n;++i)//卡常
	{
		scanf("%d",&a);
		if(i==1)//特判
		{
			puts("0");
			q.push(pii(a,i));//别忘了存入第一个
			continue;
		}
		while(i>m && !q.empty() && q.top().pos<i-m)//i>m才进入，并且为了保险，要判断队列是否为空，接着才判断是否在这个区间内。
		 q.pop();
		printf("%d\n",q.top().val);
		q.push(pii(a,i));//区间左闭右开，则先输出再入队
	}
}

int main()
{
	input();
	return 0;
}
```


---

## 作者：柳苏明 (赞：1)

这道题一看就先想用ST表啊（蒟蒻行为）


打出来~~完美地~~全部MLE

这时~~我们伟大的金牌选手zsx~~想到，可以用滚动数组啊！

但是问题来了，预处理之后就第二位就只有最后两排了啊？怎么输出呢？

我们可以看到，本题具有单调性，所以输出的顺序和预处理的顺序相同，所以我们可以边预处理边输出

代码如下

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#define min(a,b) (a<b?a:b)
#define MAXN (2000000+10)
using namespace std;
inline void read(int &x) {
	int k=1;char c=getchar();x=0;
	while(c<'0'||c>'9') {if(c=='-') k=-1; c=getchar();}
	while(c>='0'&&c<='9') {x=x*10+c-'0'; c=getchar();}
	x*=k;
}
int n,m,a[MAXN];
int fi[MAXN][2];
int k=2,q;
void deal() {
	memset(fi,0x3f,sizeof(fi));
	for(int i=1;i<=n;i++)
		fi[i][0]=a[i];
	if(q==0) {
		for(int e=m+1;e<=n;e++)
			printf("%d\n",min(fi[e-m][q%2],fi[e-1-(1<<q)+1][q%2]));
		return;
	}	
	int o=log(k-1)/log(2);
	printf("%d\n",min(fi[1][o%2],fi[k-(1<<o)][o%2])),k++,o=log(k-1)/log(2);
	for(int j=1;j<22;j++) {
		for(int i=1;i<=n;i++)
			if(i+(1<<j)-1<=n)
				fi[i][j%2]=min(fi[i][(j-1)%2],fi[i+(1<<(j-1))][(j-1)%2]);
		for(;j==o&&k<=m;k++) {
			printf("%d\n",min(fi[1][o%2],fi[k-(1<<o)][o%2]));
			o=log(k-1)/log(2);
		}
		if(j==q) {
			for(int e=m+1;e<=n;e++)
				printf("%d\n",min(fi[e-m][q%2],fi[e-1-(1<<q)+1][q%2]));
			return;
		}
	}
}
int formin(int l,int r) {
	int m=log(r-l+1)/log(2);
	return min(fi[l][m],fi[r-(1<<m)+1][m]);
}
int main() {
	read(n),read(m);
	q=log(m)/log(2);
	for(int i=1;i<=n;i++)
		read(a[i]);
	puts("0");
	deal();
	return 0;
}

---

## 作者：Null_Cat (赞：1)

窝是真的没想到本题的正解是单调队列。。。而且#10还那么卡常。。。

[~~然后喜提TLE#10~~](https://www.luogu.org/record/24122061)

---

### 前置芝士
- [线段树](https://www.luogu.org/blog/NullCatsBlog/solution-p3372)

好的话不多说切入正题。。。现在毒瘤题做多了看到维护区间第一反应就是分块/线段树，然后一看数据范围果断放弃分块。。。（但是说起来$2e6$用$O(\sqrt{n})$还真的确实能过，但是窝也没试，有兴趣的可以尝试分块A一下，但是$2e6$的话还是优先考虑$O(n \log n)$叭）

那么很显然，这道题就变成了让泥用线段树维护区间最小值.

倘若做过[P1816忠诚](https://www.luogu.org/problem/P1816)的同学应该对这个题非常有思路[~~甚至这题还让窝写错了快读~~](https://www.luogu.org/discuss/show/142322)

这个地方与忠诚一题不是很一样的地方是，此处的区间是从$i - m\to i - 1$，当然前提保证$i - m >= 0$

~~另外这道题还有一个可以玄学优化的点，因为任何一个序列的第一项前面都没再有其他项了，所以可以第一次直接输出一个0~~

这道题说起来真的略微有点水（当然是对于线段树做法而言）。。。因为根本不需要```lazy_tag```就完全可以维护，因此码量+思维难度就下降了一大截

所以就可以得到代码如下（建议先学会+学好线段树再食用）：

```cpp
//毒瘤数据卡窝输入QAQ

#include <bits/stdc++.h>

using namespace std;

void yggAKIOI(int, int, int);

inline void Gugugu(int);

int wtcl_wzbl(int, int, int, int, int);

inline int NCisBaolinger();	//个人习惯把函数写在前面qwq定义放到主函数后qwq

int n, m;

int qwq[11451400], qaq[191981000];	//不要管开的数组大小的数字2333太臭了

int main(int argc, char* argv[])
{
	n = NCisBaolinger(), m = NCisBaolinger();
	for(register int i = 1; i <= n; i++)
	{
		qwq[i] = NCisBaolinger();
	}
	yggAKIOI(1, n, 1);
	printf("%d\n", 0);
	for(register int i = 2; i <= n; i++)
	{
		if(i - m <= 0)
		{
			printf("%d\n", wtcl_wzbl(1, n, 1, i - 1, 1));
		}
		else
		{
			printf("%d\n", wtcl_wzbl(1, n, i - m, i - 1, 1));
		}
	}
	return 0;
}

void yggAKIOI(int left, int right, int root)
{
	if(left == right)
	{
		qaq[root] = qwq[left];
		return;
	}
	else
	{
		int mid = (left + right) >> 1;
		yggAKIOI(left, mid, root << 1);
		yggAKIOI(mid + 1, right, root << 1 | 1);	//不用位运算怕是快读也救不了窝喏qwq
		Gugugu(root);
	}
}

inline void Gugugu(int root)
{
	qaq[root] = min(qaq[root << 1], qaq[root << 1 | 1]);
	return;
}

int wtcl_wzbl(int left, int right, int from, int to, int root)
{
	if(left >= from && right <= to)
	{
		return qaq[root];
	}
	else
	{
		int mid = (left + right) >> 1;
		int ans = 0x7f7f7f7f;
		if(mid >= from) ans = min(ans, wtcl_wzbl(left, mid, from, to, root << 1));
		if(mid < to) ans = min(ans, wtcl_wzbl(mid + 1, right, from, to, root << 1 | 1));
		return ans;
	}
}

inline int NCisBaolinger()	//毒瘤出题人所迫，为了玄学A只好快读qwq
{
    int d = 0, o = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') o = 0;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        d = (d << 1) + (d << 3) + (ch ^ 48);
        ch = getchar();
    }
    return (o ? d : ~d + 1);
}
```

~~最后想吐槽一句，这么卡线段树真的好嘛~~

---

## 作者：Loser_King (赞：1)

# 单调队列

很明显，这道题跟滑动窗口差不多，区别主要在于：

1.滑动窗口要求两个操作，但此题只要求一个（即求最小值）。（这使题目变简单了）

2.数的范围变了。

（~~因为太懒，不愿意手打~~）

我们决定使用STL的优先队列。

```

#include<bits/stdc++.h>
using namespace std;
```

我们需要一个能记录两个值（即：一个是数组信息，一个是数组序号）的东西。

而这不就是STL的pair吗？

```
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >p;

```
↑↑↑这就是我们想要的↑↑↑
```
int n,k;
int main(){
	scanf("%d%d",&n,&k);
```
首先，第一个数之前没有数，输出0。
```
    puts("0");
```
其次，最后一个数永远不会被处理,（因为只处理这个数前的数）因此不读入。（然后make_pair）
```
    for(int i=0;i<n-1;i++){
	int a;scanf("%d",&a);
        p.push(make_pair(a,i));
```
（因为优先队列的性质，一进行push就会自动排序，这正好满足我们的要求）

又，推出窗口后就应该删除，于是：```while(p.top().second<=i-k)p.pop()```

最后输出：```printf("%d\n",p.top().first);```

完整代码：
```
#include<bits/stdc++.h>
using namespace std;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >p;
int n,k;
int main(){
    scanf("%d%d",&n,&k);
    puts("0");
    for(int i=0;i<n-1;i++){
        int a;scanf("%d",&a);
        p.push(make_pair(a,i));
        while(p.top().second<=i-k)p.pop();
        printf("%d\n",p.top().first);
    }
}
```

---

## 作者：兴安黑熊 (赞：1)

本题单调队列，我用deque写的单调队列，这题竟然卡输入和输出，用ios::sync_with_stdio(false)来优化 cin和cout 竟然TLE，最后果断scanf和printf才水过。
典型的单调队列的板子题，见代码：
```cpp
#include <iostream>
#include <deque>
#include <stdio.h>
using namespace std;
struct sa
{
    int val;
    int num;
};
int a[2000001];
deque<sa> v;
int main()
{  //ios::sync_with_stdio(false);
    struct sa tmp;
    int n,m;
    cin>>n>>m;
    //for(int i=1;i<=n;i++)
        //cin>>a[i];
    cout<<0<<endl;
    for(int i=1;i<n;i++)
    {   //cin>>a[i];
        scanf("%d",&a[i]);
        tmp.val=a[i];
        tmp.num=i;
        while(!v.empty()&&tmp.val<v.back().val)
            {//cout<<"===="<<v.back().val<<endl;
                v.pop_back();
                }
        v.push_back(tmp);
        if (i-v.front().num>=m) v.pop_front();
        printf("%d\n",v.front().val);
        //cout<<v.front().val<<endl;


    }

    //cout << "Hello world!" << endl;
    return 0;
}

```

---

## 作者：xukuan (赞：1)

不会用

```cpp
#include<queue>
```
所以用了模拟优化，过了


记下当前最小值与它的位置，

当它在区间内时将后面的值与它比较

如果后面的值不比它大，那么进行更新

当它在区间外时，在后面在区间内的数中查找最小值，记下当前最小值与它的位置，重复执行直到所有数均被处理

评测记录：https://www.luogu.org/recordnew/show/5209307


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,a[2000010],minn/*最小值*/,mins/*最小值所在的位置*/;
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1; i<=n; i++)
      scanf("%d",&a[i]);
    printf("0\n");//对第一个数的特殊处理
    
    minn=a[1]; mins=1;
    for(i=2; i<=n; i++)//从第二个数到结束
    {
        if(a[i-1]<=minn)//它之前的位置小于等于当前的最小值
        {
            minn=a[i-1];//更新最小值
            mins=i-1;//更新最小值所在的位置
        }
        if(mins<i-m)//当它在区间外时
        {
            minn=a[i-m]; mins=i-m;//防止设定的最小值不够大，把第一个值先预设成最小值
            for(j=i-m+1; j<=i-1; j++)
              if(a[j]<=minn)//找到一个更小的值
              {
                  minn=a[j];
                  mins=j;
              }//同理，更新最小值和他所在的位置
        }//取其中的最小值
        printf("%d\n",minn);//输出找到的最小值
    }
    return 0;
}
```

---

## 作者：A天天t (赞：1)

自学的单调队列，第一次写对，在这里首先感谢网上的各位大神发的帖子。希望自己发的题解也能帮到别人

解题思路：

利用递增的队列，队首记录最小值，每次输出 队首

从前向后搜,如果发现这个数比前面，单调队列的队尾小，那么删去队尾(dec(tail))，一直删到队列中的数小于或者队列中没有数，再把它放入队中，

原因：如果这个数a比前边的数b小，那么对于后边的数来说，它的前m个数中的最小值一定不是b,所以b直接删去。

为什么要用单调队列：防止重复计算，保留之前比较的结果，而且只保留还会用到的数据,省时间，

还有一点要注意，如果队首的数已经超出了i前m个数的范围，那么删去队首，即inc(head),

    
    
```cpp
var n,h1,t1,m,i,j:longint; 
h,a:array[0..2000000]of longint; //h数组记录单调队列中数的下标；a 数组记录每个数的大小
begin 
readln(n,m);
for i:=1 to n do read(a[i]);
writeln('0');  //根据题意得，第一个数之前没有数，先输出‘0’
h[1]:=1;h1:=1;t1:=1;//先把第一个数放到队里
for i:=2 to n do //从2开始
begin 
    writeln(a[h[h1]]);//每次输出所求得单调队列的队首
    while ((a[i]<a[h[t1]])and(t1>=h1)) do dec(t1); //删除队列中大于这个数的数（通过指针的改变即可删除，即从队列中删去)
    inc(t1);h[t1]:=i; //当前的数进队，，虽然它当前可能不是队列中的最小值，但队首可能会被删去，它有可能是后边某个区间的答案
    while i-h[h1]+1>m do  inc(h1);//删去超出区间的队首
end;
end.

```

---

## 作者：zhaolala (赞：1)

算是一道裸的单调队列吧   虽然STL容器较慢  但是好想好写

对于这个队列   我们维护一个二元组    分别是当前坐标（a）和当前值（b）   以b为关键字从小到大排序

每次打印只用取队列的头部就可以了 如果发现头部的坐标值在当前寻找区间之外 就把该元素删去

这样不断的添加 修改 就可以了

代码也比较简洁明了


```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
int n,m,A[2000005];
struct hahaa{
    int a,b;
    bool operator < (const hahaa & z) const {         // 重载运算符 ：以 元素值为关键字 排序
        return b>z.b;
    }
};
priority_queue<hahaa>Q;
int main()
{
   scanf("%d%d",&n,&m);int tt=1;
   for(int i=1;i<=n;i++)scanf("%d",&A[i]);
   while(tt<=n)
   {
       if(tt==1)printf("0\n");                //第一个点特判一下
       else
       {
    while(Q.top().a<tt-m)Q.pop(); // 判断头部是否在合法区间内
       printf("%d\n",Q.top().b);
        }
       hahaa t ; t.a=tt ; t.b=A[tt]; 
        Q.push(t);                               //将改点丢进队列
       tt++;
   }
   return 0;
}
```

---

## 作者：fighter_OI (赞：1)

看到没有Pascal题解呵……

本题适合单调队列，然而单调队列写的人太多，来一发线段树。

#维护一个存储最小值的线段树。

对于每个数，调用函数，求最小值即可。

时间复杂度：O(n log n)，惊险通过……

不知道线段树的，参见[宝典](http://blog.csdn.net/john\_pascal/article/details/52059495)。

标程：

```cpp
uses math;
var f,a:array[1..5000005] of longint;
    n,m,i,x,y,ans:longint; 
procedure buildtree(l,r,k:longint);
var mid:longint;
begin
 if l=r then
  begin
   f[k]:=a[l];
   exit;
  end;
 mid:=(l+r) shr 1;
 buildtree(l,mid,k shl 1);
 buildtree(mid+1,r,k shl 1+1);
 f[k]:=min(f[k shl 1],f[k shl 1+1]);
end;
procedure find(l1,r1,l2,r2,k:longint);//二分
var mid:longint;
begin
 if (l1=l2)and(r1=r2) then
  begin
   ans:=min(f[k],ans);
   exit;
  end;
 mid:=(l2+r2) shr 1;
 if r1<=mid then 
  begin 
   find(l1,r1,l2,mid,k shl 1);
   exit;
  end;
 if l1>mid then
  begin
   find(l1,r1,mid+1,r2,k shl 1+1);
   exit;
  end;
 find(l1,mid,l2,mid,k shl 1);
 find(mid+1,r1,mid+1,r2,k shl 1+1);
end;
begin
 read(n,m);
 for i:=1 to n do read(a[i]);
 buildtree(1,n,1);//建树
 if n=0 then halt;
 writeln(0);
 for i:=2 to n do
  begin
   ans:=a[i-1];
   find(max(1,i-m),i-1,1,n,1);//查找区间最小值
   writeln(ans);
  end;
end .
```

---

## 作者：_bestknife (赞：1)






```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#define rep(i,a,b) for(int i=a; i<=b; ++i)
#define read(A) scanf("%d",&A)
#define M 2000000+1000
//O(n)
using namespace std;
int n,k;
int p[M];
int q[M];
int a[M];
int Min[M];
void init()
{
  read(n);
  read(k);
  rep(i,1,n) read(a[i]);
}
void dull_queue()
{
  int h=1 ,t=0;
  rep(i,1,k-1)
  {
      while(t>=h && a[i]<=q[t]) --t;
      ++t , q[t] = a[i] , p[t] = i; //保证单调性 
  }
  rep(i,k,n)
  {
    while(t>=h && a[i]<=q[t]) --t;
    ++t , q[t] = a[i] , p[t] = i; //保证单调性 
    while(p[h] < i-k+1) ++h;  //去除在窗口外面的东西 
    Min[i-k+1] = q[h];  //区间单调值 
  }
}
void out_Min()
{
  int mint = 0;
  printf("0\n"); //题目要求 , 前面值不是0, 而是从1-i 的 最小值 
  rep(i,2,k) mint = !mint ? a[i-1] : min(mint,a[i-1]), printf("%d\n",mint);  //小小递推 
  rep(i,k+1,n) printf("%d\n" ,Min[i-k]); //输出单调队列的值 
}
void file()
{
  freopen("in.txt","r",stdin);
  freopen("out.txt","w",stdout);
}
int main()
{
  //file();
  init(); 
  dull_queue();
  out_Min();
}
```

---

## 作者：beng (赞：1)

# 这题可以用RMQ（ST表）做！

由于本题数据的特殊性，需要查找的区间的元素个数大部分是一样的（除了输出的前$m$行元素个数不足$m$个的情况），我们就可以把ST表（代码中$a$数组）进行**降维**攻击（雾）！这样一来使用RMQ（ST表）就不会MLE了！

在时间方面，我们可以拿个变量（代码中$power$）存储$2$的$j$次方，这样就不需要每一步都进行位运算了，这样做竟把超时的一个点卡过去了……

时空问题都解决了，接下来只要和一般的RMQ（ST表）进行相同的操作就可以了。

---

**但我们似乎忽略了一个问题……**

就是输出的前$m$行元素个数不足$m$个时，我们要从第一个元素开始找，元素个数肯定不到$m$个。但最后因降过维，我们只能输出元素个数为$m$的区间的最小值，这下应该怎么办呢？

这时我们可以想到，区间元素个数小于$m$时是在倍增预处理的时候，这时的ST表还未定型，在中途过程中会出现我们需要的答案，所以这部分的答案要在我们倍增的过程中输出。

我们发现，倍增过程中的每一层要输出的答案个数是不同的：

1. 第一个输出肯定为$0$，因为第一个数前是没有数的；

2. 如果$m>1$，那么第二个输出肯定是第一个数，因为第二个数前面只有一个数；

3. 我们手推一下可以发现，在建ST表的过程中，编号小于等于$2 \times power$的答案可以直接输出（当然仅限于编号小于$m$的数，即元素个数不足$m$个）；

4. 剩下的数就直接在ST表建好后按正常RMQ方法输出最小值就可以啦~

---

pascal代码如下：

```
uses math;//log2要用math库qwq
var n,m,i,j,k,l,power:longint;
a:array[0..2000000]of longint;
begin
  readln(n,m);
  for i:=1 to n do
  read(a[i]);
  writeln(0);//情况1
  if m>1 then//情况2
  writeln(a[1]);
  k:=trunc(log2(m));
  l:=2;//l为当前应输出第l个答案
  power:=1;
  for j:=1 to k do//建ST表
  begin
    power:=power*2;
    for i:=1 to n-power+1 do
    a[i]:=min(a[i],a[i+power div 2]);
    while (l<=power*2)and(l<m) do//情况3
    begin
      writeln(min(a[1],a[l-power+1]));
      inc(l);
    end;
  end;
  for i:=1 to n-m do//情况4
  writeln(min(a[i],a[i+m-power]),' ');
end.
```

---

## 作者：Bartholomew (赞：1)

#论RMQ

推荐2篇超好的文章给大家!

1.http://blog.csdn.net/qq\_39809664/article/details/78300994

2.http://blog.csdn.net/qq\_39809664/article/details/78362534

**这里其实不需要打ST 表,只是需要每一次求一个滑动窗口的最值就好了!**

##RMQ
表示这个就是一个倍增类DP的作法,比如dp[i][j] 表示 从 i 开始 向后边 拓展 2^j 次的结果 ,表示这个区间的最小值的记录,用一个 pair 类型来记录 值 和 位置!

![RMQ图片](http://blog.csdn.net/qq\_39809664/article/details/78300994#no3-rmq的想法)

于是代码:




```cpp
#include <bits/stdc++.h>
using namespace std;
enum number { N=30005,INF=0x3f3f3f3f};
int n,T,a[N],len[N];
int ans=-INF;
struct f
{
    int val,loc;
} come[N][50],back[N][50];
void init()
{
    for(int i=1; i<=n; i++) come[i][0].val=a[i],come[i][0].loc=i;
    for(int j=1; (1<<j) <=n; j++)
        for(int i=1; i+(1<<j)-1<=n; i++)
        {
            int dis=i+(1<<(j-1));
            come[i][j].val=min( come [i] [j-1].val , come [dis] [j-1] .val);
            if(come[i][j-1].val < come[dis][j-1].val) come[i][j].loc=come[i][j-1].loc;
            else come[i][j].loc = come[dis][j-1].loc;
        }
}
f solve(int l,int r)
{
    int le=len[r-l+1];
    if(come[l][le].val < come[r-(1<<le)+1] [le].val ) return come[l][le];
    else return come[r-(1<<le)+1][le];
}
void Find(int left,int right)
{
    if(left>right) return;
    f now=solve(left,right);
    ans=max(ans, now.val*(right-left+1));
    Find(left,now.loc-1);
    Find(now.loc+1,right);
}
int main()
{
    int l=0;
    for(int i=1; i<=N; i++)
    {
        if((1<<(l+1))<=i) l++;
        len[i]=l;
    }
    scanf("%d",&T);
    for(int loc=1; loc<=T; loc++)
    {
        memset(come,INF,sizeof(come));
        ans=-INF;
        scanf("%d",&n);
        for(int i=1; i<=n; i++)
            scanf("%d",&a[i]);
        init();
        Find(1,n);
        printf("Case %d: %d\n",loc,ans);
    }
    return 0;
}
```
#单调队列:
代码:

        
```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define N 2005000
using namespace std;
struct node
{
    int data,id;
//    node(int data,int id): data(data),id(id){ }
} change;
node que[N];
int head,tail;
int n,k,a[N];
int main()
{
    //freopen("cha.txt","r",stdin);
    scanf("%d%d",&n,&k);
    for(int i=1; i<=n; i++)
        scanf("%d",&a[i]);
    puts("0");
    change.data=a[1],change.id=1;
    que[tail++]=change;
    for(int i=2; i<=n; i++)
    {
        if(que[head].id<i-k) head++;
        printf("%d\n",que[head].data);
        while(head<tail&&a[i]<=que[tail-1].data) tail--;
        change.id=i,change.data=a[i];
        que[tail++]=change;
    }
    return 0;
}
```
其实没有多少的难,就是记住新来的点,时最优的
因为他们的下标靠后,而且值也会相对小,所以就会有deque这种东西了!

希望你们喜欢!


---

## 作者：usercjh123 (赞：0)

思路：ST表+滚动数组

刚开始写了一个ST表，如下：

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn = 2e6 + 100;
int f[maxn][22];
int N, M;

inline int pow2(int x){
	if(x == 0) return 1;
	return 2 << (x - 1);
}
inline int fast_read(){
	char ch = getchar();
	int f = 1, x = 0;
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + (ch - '0');
		ch = getchar();
	}
	return f * x;
}

int query(int l, int r){
	int p = (int)(log(r - l + 1) / log(2));
	return min(f[l][p], f[r - pow2(p) + 1][p]);
	
}
int main(){
	scanf("%d%d", &N, &M);
	for(int i = 1 ; i <= N ; i++) f[i][0] = fast_read();
	for(int i = 1 ; pow2(i) <= N ; i++){
		for(int j = 1 ; j <= N - pow2(i) + 1 ; j++){
			f[j][i] = min(f[j][i - 1], f[j + pow2(i - 1)][i - 1]);
		}
	}
	printf("0\n");
	for(int i = 2 ; i <= N ; i++){
		if(i - M <= 1){
			printf("%d\n", query(1, i - 1));
		}
		else printf("%d\n", query(i - M, i - 1));
	}
}
```
结果被卡成了80分（[提交记录](https://www.luogu.org/record/22889570)），两个点$MLE$，发现是$f$数组太大了

仔细思考一下，会发现，最终查询时并不需要全部的$f$数组


不妨先不考虑前面的数不足$m$的情况，那么只需要$f[i][\lfloor \log_2{m}\rfloor]$的值（这里的$f[i][j]$的意义和一般的$st$表一样，表示$[i,i+2^j)$中的元素的最小值）

对于前面的数不足$m$情况，可以使用一个非常简单的$dp$来解决

用$dp[i]$表示$[1,i)$（数组下标由1开始）内的最小值

那么$dp[i] = min(dp[i - 1], a[i-1])$（$a$是输入的数据，实际写时用$f[i][0]$存储）

于是有了下面的代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn = 2e6 + 10;
int f[maxn][3];
int dp[maxn];
int N, M;

inline int pow2(int x){
	if(x == 0) return 1;
	return 2 << (x - 1);
}
inline int fast_read(){
	char ch = getchar();
	int f = 1, x = 0;
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + (ch - '0');
		ch = getchar();
	}
	return f * x;
}
int main(){
	scanf("%d%d", &N, &M);
	for(int i = 1 ; i <= N ; i++) f[i][0] = fast_read();
   //使用f[i][0]来保存输入的数据
	int ind = 0;
	int p = 0;
   //用ind来保存最终需要的数组下标
	for(int i = 1 ; pow2(i) < M ; i++){
		for(int j = 1 ; j <= N - pow2(i) + 1 ; j++){
			ind = (i - 1) % 2 + 1; p = i;
        //st表预处理
			f[j][ind] = min(f[j][(i - 2) % 2 + 1], f[j + pow2(i - 1)][(i - 2) % 2 + 1]);
		}
	}
   //第一个元素肯定输出0
	printf("0\n");
   //处理前面的元素个数小于等于m的元素
	dp[2] = f[1][0];
	printf("%d\n", dp[2]);
	for(int i = 3 ; i <= M + 1 ; i++){
		dp[i] = min(dp[i - 1], f[i - 1][0]);
		printf("%d\n", dp[i]);
	}
   //处理前面的元素个数大于m的元素
	for(int i = M + 2 ; i <= N ; i++){
		int l = i - M;
		printf("%d\n", min(f[l][ind], f[i - pow2(p)][ind]));
	}
}
```
这样就可以$AC$了（[评测记录](https://www.luogu.org/problem/P1440)）


---

## 作者：公主殿下MIKU (赞：0)

本蒟蒻刚学线段树，发片题解巩固一下
```
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000001;
int n,a[maxn],m;
struct node {
    int minn,lazy;//minn 维护的最小值，lazy 懒惰标记
} t[maxn<<2];
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        f=-1;
        ch=getchar();
    }
    while(ch<='9'&&ch>='0')
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
inline int lc(int p) {//左孩子 l=2*p;
    return p<<1;
}
inline int rc(int p) {//右孩子 l=2*p+1;
    return p<<1|1;
}
inline void push_up(int p) {
    t[p].minn=min(t[lc(p)].minn,t[rc(p)].minn);//维护父亲节点
}
inline void build(int p,int l,int r) {//建树
    t[p].lazy=0;
    if(l==r) {// 左孩子和右孩子相等，到达最低端，区间最小值就是a[l]
        t[p].minn=a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(lc(p),l,mid);//左孩子
    build(rc(p),mid+1,r);//右孩子
    push_up(p);//向上维护父亲节点
}
inline void mark(int p,int k) {//记录当前节点所代表的区间
    t[p].lazy+=k;
    t[p].minn+=k;
}
inline void push_down(int p) {//懒惰标记下放
    mark(lc(p),t[p].lazy);
    mark(rc(p),t[p].lazy);
    t[p].lazy=0;
}
inline void update(int x,int y,int l,int r,int p) {//区间修改
    if(x<=l&&r<=y) {
        mark(p,t[p].lazy);
    }
    push_down(p);
    int mid=(l+r)>>1;
    if(x<=mid) update(x,y,l,mid,p);
    if(y>mid) update(x,y,mid+1,r,p);
	push_up(p);
}
inline int query(int x,int y,int l,int r,int p) {//区间查询
    if(x<=l&&y>=r) {
        return t[p].minn;
    }
    push_down(p);
    int mid=(l+r)>>1;
    if(y<=mid) return query(x,y,l,mid,lc(p));
    else if(x>mid) return query(x,y,mid+1,r,rc(p));
    else return min(query(x,y,l,mid,lc(p)),query(x,y,mid+1,r,rc(p)));
}
int main() {
    scanf("%d%d",&n,&m);
    for(register int i=1; i<=n; i++)
        scanf("%d",&a[i]);
    build(1,1,n);
    printf("0\n");//第一个点输出0
    for(register int i=2; i<=n; i++) {
         printf("%d\n",query(i-m>0?i-m:1,i-1,1,n,1));//左区间分两种情况,i-m<0 左区间为1 i-m>0 左区间为i-m
    }
    return 0;
}
```
希望对各位新学线段树的萌新有帮助

---

## 作者：vani_prcups (赞：0)

（伪）单调队列（其实我自己都不知道是怎么过的……）

不管怎么说，当取一段新的区间时，只要保证单调队列最前面的元素，一定是当前区间的最小值。

上代码

```cpp
#include<iostream>
#include<queue>
using namespace std;
inline int getint()
{
    int s=0,w=1;
    char ch=getchar();
    while (ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if (ch=='-')w=-w,ch=getchar();
    while (ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
int n,k,c[2000005],lenx,lenn,temp,headn,mins[2000005],pt;
queue <int> a;
//单调队列维护函数
void mmin(int x)
{
    if (lenn==0)c[++lenn]=x,headn=1;
    else
    {
        while (lenn>=headn&&c[lenn]>x)--lenn;
        c[++lenn]=x;
    }
}
//i小于m时
void preq()
{
    for (int i=1;i<=k;i++)
    {
        temp=getint();
        a.push(temp);
        mmin(temp);
        mins[++pt]=c[headn];
    }
}
//大于m
void q()
{
    for (int i=k+1;i<=n;i++)
    {
        temp=a.front();
        a.pop();
        if (c[headn]==temp)headn++;
        temp=getint();
        a.push(temp);
        mmin(temp);
        mins[++pt]=c[headn];
    }
}

int main()
{
    n=getint();
    k=getint();
    preq();
    q();
    for (int i=0;i<pt;i++)
    printf("%d ",mins[i]);
}
```

---

## 作者：Jason_Yvan (赞：0)

无聊用了两种方法写这道题：一是线段树，二是单调队列（手写）

线段树的话很好写，记得把数组开大点就好（也不会爆空间）

线段树C++代码如下：

/*************************************************************************

    > Author: wzw-cnyali
    > Created Time: 2017/3/2 18:27:58
************************************************************************/











```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
typedef long long LL;
const int Size = 2000010;
const int inf = 0x3f3f3f3f;
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
int a[Size];
struct segment_tree{
    int tree[Size << 2];
    void build_tree(int h, int l, int r)
    {
        if(l == r)
        {
            tree[h] = a[l];
            return;
        }
        int mid = l + r >> 1;
        build_tree(h << 1, l, mid);
        build_tree(h << 1 | 1, mid + 1, r);
        tree[h] = min(tree[h << 1], tree[h << 1 | 1]);
    }
    int query(int h, int l, int r, int x, int y)
    {
        if(l == x && r == y)
        {
            return tree[h];
        }
        int mid = l + r >> 1;
        if(y <= mid) return query(h << 1, l, mid, x, y);
        else if(x > mid) return query(h << 1 | 1, mid + 1, r, x, y);
        else return min(query(h << 1, l, mid, x, mid), query(h << 1 | 1, mid + 1, r, mid + 1, y));
    }
}tree;
int main()
{
    int n = read(), m = read();
    REP(i, 1, n)
    {
        a[i] = read();
    }
    tree.build_tree(1, 1, n);
    REP(i, 1, n)
    {
        if(i == 1)
        {
            printf("0\n");
            continue;
        }
        else printf("%d\n", tree.query(1, 1, n, i - m > 0 ? i - m : 1, i - 1));
    }
    return 0;
}
```
接下来是单调队列C++代码：
/*************************************************************************

    > Author: wzw-cnyali
    > Created Time: 2017/3/2 20:51:56
************************************************************************/










```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
typedef long long LL;
const int Size = 4000000;
const int inf = 0x3f3f3f3f;
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
int a[Size];
struct T{
    int val, pos;
};
struct node{
    int l, r;
    T stack[Size];
    void clear()
    {
        l = 1; r = 0;
    }
    void putin(T A)
    {
        while(r >= l && stack[r].val > A.val) r--;
        stack[++r] = A;
    }
    void pop(int pos)
    {
        while(r >= l && stack[l].pos < pos) l++;
    }
    int top()
    {
        return stack[l].val;
    }
}ddd;
int main()
{
    int n = read(), m = read();
    REP(i, 1, n)
    {
        a[i] = read();
    }
    ddd.clear();
    puts("0");
    ddd.putin((T){a[1], 1});
    REP(i, 2, n)
    {
        if(i - m >= 0) ddd.pop(i - m);
        printf("%d\n", ddd.top());
        ddd.putin((T){a[i], i});
    }
    return 0;
}

```

---

## 作者：PolyLoger (赞：0)

为什么大家都用单调队列，来一发线段树的维护区间最小值（C++，毕竟楼下有P党了）

【附加快速读入+快速输出】，不知有没有人可用倍增的思想来做RMQ。。。

良心提示：freopen懒得删了







    
        

        
    
    
        


    
    
        
        
        
        

    
    
    
    

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int S=1,U=23,N=2000005,M=5000055;
struct Node
{
    int v,i,j;
    int left,right;
}Tree[M];
int n,m,s[N];
inline void Read(int &x)
{
    x=0;
    int flag=1;
    char c='\0';
    for(;c<'0'||c>'9';c=getchar())if(c=='-')flag=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=flag;
}
inline void Writeln(int x)
{
    if(x==0)putchar('0');
    int ts=0,Out[U]={0};
    while(x){
        Out[++ts]=x%10;
        x/=10;
    }
    while(ts>0)putchar(Out[ts--]+'0');
    putchar('\n');
}
int Count(int now,int a,int b);
void BuildTree(int now,int a,int b);
int main(void)
{
    freopen("P1440.in","r",stdin);
    freopen("P1440.out","w",stdout);
    Read(n);
    Read(m);
    for(int i=1;i<=n;++i)
        Read(s[i]);
    BuildTree(S,1,n);
    printf("0\n");
    for(int i=2;i<=n;++i)
        Writeln(Count(S,max(1,i-m),i-1));
    return 0;
}
void BuildTree(int now,int a,int b)
{
    Tree[now].i=a;
    Tree[now].j=b;
    if(a==b){
        Tree[now].v=s[a];
        return;
    }
    int mid=(a+b)/2;
    BuildTree(2*now,a,mid);
    BuildTree(2*now+1,mid+1,b);
    Tree[now].v=min(Tree[2*now].v,Tree[2*now+1].v);
}
int Count(int now,int a,int b)
{
    if(b<Tree[now].i||a>Tree[now].j)return 0x7fffffff;//曾因年少轻狂return 2333333结果80，越大越好
```
/\*return the biggist!!\*/
        
    
```cpp
    if(a<=Tree[now].i&&b>=Tree[now].j)
        return Tree[now].v;
    return min(Count(2*now,a,b),Count(2*now+1,a,b));
}

```

---


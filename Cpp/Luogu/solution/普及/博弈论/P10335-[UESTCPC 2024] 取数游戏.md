# [UESTCPC 2024] 取数游戏

## 题目描述

有一个长度为 $n$ 的序列，第 $i$ 个数的权值为 $a_i$。两位选手 A 和 B 在做游戏，他们将对轮流对序列进行操作。每位选手每次有两种操作可以选择：

- 删除序列中的任意两个的数 $a_i,a_j$ $(i \neq j)$，并在序列中添加一个权值为 $a_i+a_j$ 的数。当序列中只有一个数时，不能执行该操作。
- 取走序列中一个数，将序列中剩下的数的权值全部累加给对方，结束游戏。

如果最后 A 得到的权值更多，则他胜利，否则 B 胜利。

A 先进行操作，问他是否有必胜策略。**保证 $a_i$ 之和为奇数。**

## 说明/提示

样例一解释如下：

- 如果 A 选择权值 $3$，则 B 能得到的权值为 $6+4=10$。
- 如果 A 选择权值 $4$，则 B 能得到的权值为 $3+6=9$。
- 如果 A 选择权值 $6$，则 B 能得到的权值为 $3+4=7$。
- 如果 A 选择合并权值 $3,6$，序列变为 $9,4$。若 B 选择权值 $9$，则 A 能得到的权值为 $4$。
- 如果 A 选择合并权值 $3,4$，序列变为 $7,6$。若 B 选择权值 $7$，则 A 能得到的权值为 $6$。
- 如果 A 选择合并权值 $4,6$，序列变为 $10,3$。若 B 选择权值 $10$，则 A 能得到的权值为 $3$。

在所有情况下 B 均能以最优策略取得更高的权值，故 A 无法胜利。

样例二解释如下：

如果 A 选择权值 $2$，则 B 能得到的权值为 $1$。

因此 A 有必胜策略。

## 样例 #1

### 输入

```
3
3 
3 6 4
2 
1 2
3
2 5 6```

### 输出

```
NO
YES
NO```

# 题解

## 作者：pocafup (赞：6)

### P0:写在前面

出题人题解。

难题比赛没人写，还是出点清新签到题适合。

$a_i$ 的和为奇数是为了解决平局问题。

### P1：题解

首先判断序列中有没有一个权值大于等于 $\lceil \dfrac{\sum_{i=1}^{n} a_i}{2} \rceil$，如果有必然 A 获胜。

否则如果 $n$ 是偶数则 A 获胜，否则 B 必胜。

证明：发现其实合并过程并不重要，因为一旦出现一个权值大于等于 $\lceil \dfrac{\sum_{i=1}^{n} a_i}{2} \rceil$，取他必然最优。所以一方胜利当且仅当对方操作时不存在两个权值可以合并得到小于 $\lceil \dfrac{\sum_{i=1}^{n} a_i}{2} \rceil$ 的权值。考虑什么时候会出现这种状况。

发现一个必要要求是所有权值都大于等于 $\lceil \dfrac{\sum_{i=1}^{n} a_i}{4} \rceil$。这直接证明了序列长度不超过 4。而如果序列长度为 4，则唯一可能合并出一个小于等于 $\lceil \dfrac{\sum_{i=1}^{n} a_i}{2} \rceil$ 的权值的情况为四个权值均相等。由于 $\sum_{i=1}^{n} a_i$  是奇数，不存在这种情况。

因此，双方均可以使用最优策略保证在序列长度大于等于 3 的情况下均不会出现所有权值大于等于 $\lceil \dfrac{\sum_{i=1}^{n} a_i}{4} \rceil$ 的情况，因此在序列长度为 3 时操作的选手必败。由于操作顺序固定，故只需要考虑初始序列长度的奇偶性即可。

```cpp
signed main(){
    t = read();
    while(t--){
      n = read();
      ans = 0;
      For(i,1,n) pos[i] = read(),ans += pos[i];
      For(i,1,n) if (pos[i]>ans/2.0) {puts("YES");goto abc;}
      puts(n%2 ? "NO" : "YES");
      abc:;
    }
}
```

时间复杂度 $O(n)$ 

### P2:其他做法

这题其实有一个普遍的猜想：每次合并最小两个数字，最后谁先无法合并即判负。这个猜想的正确性基于正解，容易想到但不好写。复杂度为 $O(n\log n)$ 由于是签到题最后没有卡这种做法。

---

## 作者：liaoxingrui (赞：4)

## Content

有 $T$ 组数据，每组数据有一个长度为 $n$ 的序列，第 $i$ 个数的权值为 $a_i$。有两个人轮流对序列进行操作。可选择如下操作：

- 合并序列中的任意两个数（不能为一个数）$a_i$ 和 $a_j$（$i \ne j$）。

- 得到序列中一个数的权值，对方得到序列中剩下的数的全部权值，游戏结束。
 
如果先手获得的数的权值大于对方获得的数的权值，就输出 `YES`，否则输出 `NO`。**保证 $a_i$ 之和为奇数**。

## Solution

我们可以把 **保证 $a_i$ 之和为奇数** 理解为 **保证有解**。因为这样就不会有平局。

显然，若有一个数大于全部数之和的一半，先手肯定会赢，否则就会执行操作 $1$。

执行操作 $1$ 肯定是不会让对方赢的，就不可能合并最大的两个数，而是选择最小的两个数合并，就相当于废棋，当然在只剩下两颗棋时就可以直接结束游戏。

所以在 $n\%2==0$ 时先手就可以获胜，例如 $n=4$ 且没有的一个数大于其它数的全部权值的一半情况：

1. 先手不可能执行操作 $2$，所以执行操作 $1$ ，将最小的数合并，场上还剩还有 $3$ 个数。

2. 因为另外两个数为最大两个数，所以它们之和一定大于先手合并后的数字，后手不能执行操作 $2$，所以执行操作 $1$ ，将最小的数合并，场上还剩还剩 $2$ 个数。

3. 因为场上还剩 $2$ 个数，先手可以直接选择最大数获胜，所以输出 `YES`。

反之若 $n\%2==1$ 则后手胜利，输出 `NO`。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
inline int read(){
	int x=0;
	char ch=getchar();
	while(!isdigit(ch))
		ch=getchar();
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
	return x;
}
int main(){
	t=read();
	while(t--){
		n=read();
		int a,ma=0;
		long long sum=0;
		for(int i=1;i<=n;i++){
			a=read(); 
			sum+=a;
			//求 a 数组和。 
			ma=max(a,ma);
			//求 a 数组最大值。 
		}
		if(!(n%2)||ma*2>sum)
		//判断 n 是否为偶数。
		//如果不是，那么最大值是否大于总和一半。 
			puts("YES");
		else
		//判断 n 是否为奇数。（也可以理解为不能赢则会输） 
			puts("NO");
	}
	return 0;
}
```

---

## 作者：Storm_Lightning (赞：1)

## 思路

主要的算法就是博弈论，比较费脑子，想了我一个小时。

进入正题：

设数列 $a$ 中的第 $i$ 位的数为 $a[i]$，${\textstyle\sum _ {i=1} ^ {n}a[i]}=x$（为了方便后面的内容）。

首先，我们列一些特殊情况。

- 当里面有一项数为 $a[i]$，并且满足 $a[i]>x\div2$ 时，当 $A$ 拿走, $a[i]$ 是，$A$ 必胜。

- $n=2$ 则 $A$ 必赢 ~~（其实没啥用）~~ 。

这时我们发现，必定存在一个数 $a[i]$，满足 $ a[i]\ge\lfloor x\div4\rfloor$ ，这是我们就会神奇的发现，原本讨论的 $10 ^ 6$ 个数，变成讨论 $4$ 个数了。

最后就不难发现，只要通过判断数的奇偶即可通过此题！

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	char s=' ';int ans=0,flag=1;
	while(s>'9'||s<'0'){s=getchar();if(s=='-')flag=-1;}
	while(s<='9'&&s>='0'){ans=ans*10+s-'0';s=getchar();}
	return ans*flag;
}
int t,n;
int a[1000010]; 
signed main()
{
	cin>>t;
	while(t--)
	{
		int ans=0,flag=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			ans+=a[i];
		}
		for(int i=1;i<=n;i++)
		{
			if(a[i]>ans/2)
			{
				puts("YES");
				flag=1;
				break;
			}
		}
		if(flag==0)
		{
			if(n%2==1)puts("NO");
			else puts("YES");
		}
	}
	return 0;
}

```

码风不错，点个赞吧！

---

## 作者：xiaoyang111 (赞：1)

## 前言

这里我给一个时间复杂度劣于标程的算法，算法时间复杂度 $O(n \log n)$。

真的快要绷不住了我把结论题做成了模拟题。

[题目。](https://www.luogu.com.cn/problem/P10335)

[专栏观看可能更好。](https://www.luogu.com.cn/article/ekitge0m)

## 题解

### 思路分析

容易得出如果序列中有一个数大于总和的一半，这一方取走就可以直接获胜，因此我们考虑怎么一直让序列中的最大值最小。

通过自己模拟过程，可以得出，每次合成都要选最小的两个数，让合成出来的数尽可能的小，也就是尽可能让合成出来不能超过数的总和的一半，再将合成出来的数加入到待选数里面。这用了合并果子的思想。

直接模拟双方选数的过程就可以了，如果这一方选完数后待选数里面的最大值超过了总和的一半，那么下一方选数的时候就可以直接选最大数结束游戏，这一方就输了。

选数过程和合并果子完全一样的，我们直接用合并果子那样直接用堆优化。所以时间复杂度是 $O(n \log n)$。

还要注意要开长整。

### 代码

代码是下面这个。

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
void solve(){
	priority_queue<long long,vector<long long>,greater<long long>> q;//小根堆
	int n;
	scanf("%d",&n);
	long long mx=-1,t1,t2,sm=0,a;
	for (int i=0;i<n;++i){
		scanf("%lld",&a);
        q.emplace(a);
		sm+=a;
		mx=max(mx,a);
	}
    int qwq=0;//0 表示 A，1 表示 B
    while (q.size()!=1 && mx*2<sm){//如果 qwq 的那一方取数的时候能秒杀对方
        t1=q.top();q.pop();
        t2=q.top();q.pop();
        a=t1+t2;
        mx=max(mx,a);
        qwq=1-qwq;//变换先手后手
        q.push(a);
    }
    if (qwq==0){//如果 A 能秒杀 B
        printf("YES\n");
    }else{
        printf("NO\n");
    }
}
int main(){
	int t;
	cin >> t;
	for (int i=0;i<t;++i){
		solve();
	}
	return 0;
}
```

---

## 作者：gh_AC (赞：1)

### 题目大意：

每人在每一轮中可以合并两个数或是在取得一个数作为自己的得分后，剩下的数之和是对方的得分。有两个人，第一个人先进行操作，如果第一个人最后的得分高就输出 YES，否则就输出 NO。

### 思路：

首先我们可以知道，如果在一开始时候的所有数中最大的数比其他的数之和都要高，那第一个人一开始就取这个数就赢了，就输出 YES。

当最大值比其他数之和要低时，而他们都不想让对方赢，所以就都会让最小的两个合并，也就是让序列长度减小了一。但当序列只剩两个时，那接下来进行操作的那个人就必定会赢。

然后我们就可以推出当序列总长度是二的倍数时，那第一个人就会在还剩两个数的时候进行操作，就输出 YES；当序列总长度不是二的倍数时，那第二个人就会在还剩两个数的时候进行操作，就输出 NO。

### AC 代码：
```cpp
#include<iostream>
using namespace std;
long long t,n,a;
long long maxn,sum;
int main(){
	cin>>t;
	while(t--){
        maxn=0,sum=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a;
			sum+=a,maxn=max(maxn,a);
		}
		if(maxn>(sum-maxn)){
			cout<<"YES"<<endl;
			continue;
		}
		if(n%2==1) cout<<"NO"<<endl;
		else cout<<"YES"<<endl;
	}
	return 0;
}
```

---

## 作者：xinxin2022 (赞：1)

# 题意分析

在一个长度为 $n$ 的序列里，每次可以和并两个数，也可以取走一个数，剩下的数归对手。问是否存在一个方法能保证 A 取走的数的和比 B 取走的数的和大。

# 思路

首先，如果序列中有一个大于其他数之和的数，那么 A 可以直接取走最大的数，游戏胜利，输出```YES```。

其次，如果序列的长度( $n$ )为奇数，则 A 可以和并最小的两个数，相当于走一步废棋，B 也是同理，那么最终一定会出现一个大于其他数之和的数。而可以发现，这个情况只能是在 A 的某一次和并后出现，而显然会让 B 取走最大的数，游戏失败，输出```NO```。

同理，当序列长度为偶数时，仍然会按照上面的情况发展，不过这次变成了 B 合并出一个大于其他数之和的数，那么 A 可以直接取走最大的数，游戏胜利，输出```YES```。

# AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		long long n,a,maxn=0,sum=0;
        cin>>n;
		for(long long j=1;j<=n;j++){
			cin>>a;sum+=a;maxn=max(maxn,a);
        	//记录最大值和序列的和
		}
		if(maxn>(sum-maxn)){cout<<"YES"<<endl;continue;}
      	//当有一个数大于其他数的和，游戏胜利
		if(n%2) cout<<"NO"<<endl;
        //当序列长为奇数时，游戏失败
		else cout<<"YES"<<endl;
      	//当序列长度为偶数时，游戏胜利
	}
	return 0;
}
```

---

## 作者：__Sky__Dream__ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P10335)

## 解题思路
博弈论。

仔细想一下就能知道，如果这一局不能获胜的话，一定不能为对手做贡献，则要选择尽可能小的两个数合并，尽最大努力不创造出一个更大的数，用两个优先队列模拟一下就能解决。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
int n,m,x;
void dfs()
{   
    cin>>n;
    priority_queue<int,vector<int>,greater<int> > minn;
	priority_queue<int,vector<int> > maxx;
    int ans=0;
    for(int i=0;i<n;i++)
	{
        cin>>x;
        maxx.push(x);
        minn.push(x);ans+=x;
    }
    for(int i=0;i<n;i++)
	{
        if(maxx.top()>(ans-maxx.top())&&i%2==0)
		{
            cout<<"YES"<<endl;
            return ;
        }
		else if(maxx.top()>(ans-maxx.top())&&i%2!=0)
		{
            cout<<"NO"<<endl;
            return ;
        }
        else
		{
            int u=minn.top();
            minn.pop();
            int v=minn.top();
            minn.pop();
            int uv=u+v;
            minn.push(uv);
            maxx.push(uv);
        }
    }
    cout<<"NO"<<endl;
}
signed main()
{
    ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
    int t=1;
    cin>>t;
    while(t--) dfs();
}
```
~~拜拜！~~

---

## 作者：ys_kylin__ (赞：0)

## 解析
本题目很明显是一道结论题。

首先，不难发现，当数列中出现一个数比所有数都大时，取数者获胜。而不是这种情况时，合并两个最小的数就是最佳法。而还剩三个数以上时，有两种情况：

1. 两数之和不是最大值，那么此操作没有任何意义，因为此时不会改变其它数之和与最高数的差。
2. 两数之和是最大值，但是此时其它数的数量大于二，这时最大数也不可能超过其它数和（两个最小数的和不可能超过两个及以上的非最小数和），没有影响。

这样，最后只剩下了三个数，然后操作者必输，因为无论怎样合并，最后只剩两个数，另一个人选大的就能赢。那么假如 $n$ 是单数，剩下三个数时操作者是 A，也就是 B 胜，输出 `NO`；同理，$n$ 是双数时，A 胜，输出 `YES`。注意，最开始要判断最大数是否已经大于其他所有数之和，如果是直接输出 `YES`。

最后最后，不开 `long long` 见祖宗！

## code
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t;
	scanf("%d",&t);
	while(t--) {
		int n;
		scanf("%d",&n);
		long long sum=0,mx=-1e9;
		for(int i=1;i<=n;i++) {
			long long x;scanf("%lld",&x);
			sum+=x;mx=max(mx,x);
		}
		if(mx*2>sum) printf("YES\n");
		else if (n%2==1) printf("NO\n");
		else printf("YES\n");
	}
	return 0;
}
```

---

## 作者：Hulless_barley (赞：0)

[P10335 [UESTCPC 2024] 取数游戏](https://www.luogu.com.cn/problem/P10335)

# 思路
由题可知，操作 $2$ 是唯一结束条件，也是唯一可以增加权值的方法。也就是说只要序列中存在一个 $a_i$，如果 $a_i>(\sum_{j=1}^na_j)-a_i$，则执行此操作的选手获胜。

如果序列中不存在上述 $a_i$，只能通过操作 $1$ 合并出 $a_i$。想赢就不想自己合并出大于序列和一半的值（不然下一步对方就赢了啊），所以每一步的最佳操作是合并两个最小值。当且仅当序列剩下 $3$ 个值的时候，通过合并两个最小值会产生一个大于序列和一半的值，此时还剩下 $2$ 个值，通过操作 $2$ 可以决定胜负。

由此可知，求出序列和 $s$ 与序列最大值 $m$，若 $m>\frac{s}{2}$，输出 `YES`；否则 $n$ 是奇数输出 `NO`，反之输出 `YES`。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5+5;
long long a[N],n,s,maxn;
int main(){
	int t;cin>>t;
	while(t--){
		scanf("%lld",&n),s=maxn=0;
		for(int i=1;i<=n;i++){
			scanf("%lld",&a[i]);
			maxn=max(maxn,a[i]);
			s+=a[i];
		}
		if(maxn>(s>>1))puts("YES");
		else puts((n&1)?"NO":"YES");
	}
	return 0;
}
```

~~由于数据太大，所以提交爆了两次。~~ 十年 OI 一场空，不开 `long long` 见祖宗。

---

## 作者：sansesantongshun (赞：0)

这是一道博弈论的题，这种题最重要的是分析必胜条件。

根据第 $2$ 种选择，当序列中的最大数大于总数的一半时，先手必胜。反之，为了让序列的最大值最小，应选择最小的两个数合并。

很明显可以用小根堆来维护最小值，当然最大值就没必要开堆了，直接开个变量维护就可以了，因为两个数相加后的值一定大于原值。

这样就得出这样的做法：当序列中的最大数大于总数的一半时，结束游戏并判断赢家；否则合并两个最小的数。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
long long x,sum,maxn,y;
priority_queue<long long,vector<long long>,greater<long long> > p;//不开long long见祖宗
int main()
{
	cin>>t;
	while (t--)
	{
		scanf("%d",&n);
		sum=0;
		maxn=0;
		while (n--)
		{
			scanf("%lld",&x);
			p.push(x);
			sum+=x;
			maxn=max(maxn,x);//维护最大值
		}
		for (bool i=1;;i=!i)
		{
			if (maxn<<1>sum)
			{
				if (i)
				puts("YES");
				else
				puts("NO");
				break;
			}
			else
			{
				x=p.top();
				p.pop();
				y=p.top();
				p.pop();
				p.push(x+y);//合并
				maxn=max(maxn,x+y);//更新最大值
			}
		}
		while (!p.empty())
		p.pop();//多测不清空，爆0两行泪
	}
}
```
注意事项：

1.开 long long 。

2.记得清空堆 。

做完这道题后，我看了看其它的题，完全不会，索性给这道题弄个优化。

我们发现使用堆很蠢。因为如果用两个队列，一个维护初始数值，一个维护合并后的数值，也能得到最小值，而且比堆少一个 $\log$ 。

那么如何优化掉排序的 $\log$ 呢？桶排序？数据范围不允许。所以只能用基数排序。

这样我们得到了一个优秀的线性算法。由于时间复杂度很小，常数对运行速度影响很大，加上快读，才能使算法得到本质上的优化。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[500005],b[500005],c[256];
long long x,sum,maxn,y;
queue<long long> q1,q2;
int read()
{
	int result=0;
	char ch=getchar();
	while (ch<'0' || ch>'9')
	ch=getchar();
	while ('0'<=ch && ch<='9')
	{
		result=result*10+(ch^48);
		ch=getchar();
	}
	return result;
}
int main()
{
	t=read();
	while (t--)
	{
		n=read();
		sum=0;
		maxn=0;
		for (int i=1;i<=n;++i)
		{
			a[i]=read();
			sum+=a[i];
			maxn=max(maxn,(long long)a[i]);
		}
		for (int k=0;k<31;k+=8)
		{
			for (int i=1;i<=n;++i)
			++c[(a[i]>>k)&255];
			for (int i=1;i<256;++i)
			c[i]+=c[i-1];
			for (int i=n;i>0;--i)
			b[c[(a[i]>>k)&255]--]=a[i];
			memcpy(a+1,b+1,n<<2);
			memset(c,0,sizeof(c));
		}
		for (int i=1;i<=n;++i)
		q1.push(a[i]);
		for (bool i=1;;i=!i)
		{
			if (maxn<<1>sum)
			{
				if (i)
				puts("YES");
				else
				puts("NO");
				break;
			}
			else
			{
				if (!q1.empty() && (q2.empty() || q1.front()<q2.front()))
				{
					x=q1.front();
					q1.pop();
				}
				else
				{
					x=q2.front();
					q2.pop();
				}
				if (!q1.empty() && (q2.empty() || q1.front()<q2.front()))
				{
					y=q1.front();
					q1.pop();
				}
				else
				{
					y=q2.front();
					q2.pop();
				}
				q2.push(x+y);
				maxn=max(maxn,x+y);
			}
		}
		while (!q1.empty())
		q1.pop();
		while (!q2.empty())
		q2.pop();
	}
}
```

---

## 作者：Crazyouth (赞：0)

## 分析

根据题意，如果存在 $1\le i\le n$ 的 $i$ 满足 $a_i>\displaystyle\sum_{j=1}^n[j\ne i]\times a_j$，那么当时的玩家可以取走 $a_i$ 并获胜。如果不存在此 $i$，那么为了尽可能让后面的玩家也取不到这样的 $i$，当时的玩家必然会选择合并两个小的使得合出来的数不会成为这个 $i$，这样的话选择最小的两个数合并必然不劣，用 set 模拟一下可过。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
set<pair<int,int>> st;
void solve()
{
	st.clear();
	int n,sum=0,now=0;//为了让 set 不消掉相同的数，加一个占位标签
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		sum+=a;
		st.insert({a,++now});
	}
	for(int i=1;i<=n;i++)
	{
		if((*(--st.end())).first>sum/2)
		{
			cout<<(i%2?"YES":"NO")<<endl;
			return;
		}
		int tp=(*(st.begin())).first,tp2=(*(++st.begin())).first;
		st.erase(st.begin());st.erase(st.begin());
		st.insert({tp+tp2,++now}); 
	}
}
signed main()
{
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
}

---

## 作者：iyka (赞：0)

因为要取得最大值，我们还是先手，这里我们分类讨论一下。

### 必胜的情况
1. 序列中有一个数比其它所有书之和都大，此时我们只用取走这个数就赢了。
2. 在合并的过程中肯定会出现上面的情况，这时轮到谁了，他就赢了，我们可以让两人每次合并都只合并最小的两个数，这时，谁先遇到上面的情况，谁就赢了。再仔细推敲，不难发现当序列长度为偶数时，A 就会先遇到上面的情况，回到情况 $1$，胜利。

### 非必胜的情况
- 根据必胜的情况 $2$，如果序列长度为奇数时，B 就会先遇到上面的情况，B 胜利。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,n,a,sum,maxn;
signed main()
{
	cin>>T;
	while(T--)
	{
		cin>>n; maxn=-1, sum=0;
		for(int i=1;i<=n;++i)
			cin>>a, maxn=max(a,maxn), sum+=a;
		if(sum-maxn<maxn) //必胜情况1
			cout<<"YES\n";
		else if(n&1) //非必胜情况
			cout<<"NO\n";
		else //必胜情况2
			cout<<"YES\n";
	}
	return 0;
}
```

---


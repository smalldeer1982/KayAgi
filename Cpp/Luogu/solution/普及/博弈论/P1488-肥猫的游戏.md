# 肥猫的游戏

## 题目描述

野猫与胖子，合起来简称肥猫，是一个班的同学，他们也都是数学高手，所以经常在一起讨论数学问题也就不足为奇了。

一次，野猫遇到了一道有趣的几何游戏题目，便拿给胖子看。游戏要求在一个有 $n$ 个顶点凸多边形上进行，这个凸多边形的 $n-3$ 条对角线将多边形分成 $n-2$ 个三角形，这 $n-3$ 条对角线在多边形的顶点相交。三角形中的一个被染成黑色，其余是白色。

双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。胖子一看觉得确实很有趣，不如就一起玩玩吧。假设游戏由野猫先开始，那么野猫是否有必胜的策略呢？请写一个程序帮助野猫算一算。

## 说明/提示

$4 \leq n \leq 5 \times 10^4$。

如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。

## 样例 #1

### 输入

```
6
0 1 2
2 4 3
4 2 0
0 5 4
```

### 输出

```
JMcat Win
```

# 题解

## 作者：Imakf (赞：45)

刷博弈论，看到这道题是红色的，我就来了

结果一看???这真的是入门难度？？？恶意评分啊！

首先
# 读题！
我读这道题目都花了好久，实际上意思就是**把一个$n$边形沿着对角线分割，分成n-2个三角形**，在其中**选中一个三角形成为黑三角形**。然后JMcat , PZ两个人**轮流拿走边上的一个三角形**，谁能拿走**黑三角形**谁就赢了。

# 做法
本蒟蒻的做法就是**分类讨论**! 分3种情况——黑三角形和多少个三角形相邻。

## 一、和$1$个三角形相邻

![](https://cdn.luogu.com.cn/upload/pic/30936.png)

显而易见，黑三角形本身露在外面，JMcat直接取走，puts("JMcat Win");

## 二、和$2$个三角形相邻

![](https://cdn.luogu.com.cn/upload/pic/30938.png)

好像看不出什么……………………………………………………那就**找规律**啊

规律如下表

| $n$ | 白三角形数量 | 谁赢 |
| -----------: | -----------: | -----------: |
| $5$ | $2$ | $PZ$ |
| $6$ | $3$ | $JMcat$ |
| $7$ | $4$ | $PZ$ |
| ... | ... | ... |

规律便一下出来了

```
if(n%2==1)	puts("PZ Win");
else puts("JMcat Win");
```

### 证明

JMcat的必败点就是如上图所示，每次拿走一个三角形实际上就是删去一个点，所以知道剩下5个点JMcat必败，因为一个人取一次，即可得出结论。

## 三、和$3$个三角形相邻

![](https://cdn.luogu.com.cn/upload/pic/30942.png)

跟情况二一样，找规律

| $n$ | 白三角形数量 | 谁赢 |
| -----------: | -----------: | -----------: |
| $6$ | $3$ | $JMcat$ |
| $7$ | $4$ | $PZ$ |
| $8$ | $5$ | $JMcat$ |
| ... | ... | ... |

规律：
```
if(n%2==1)	puts("PZ Win");
else puts("JMcat Win");
```
实际上这两种情况是一样的，就如上图，拿走一个三角形之后便变成了第二种情况。

### 证明
与情况二类似，不再赘述

# 蒟蒻AC代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
struct tri{
    int a[3];
}h[50000+5];
bool point[50000+5];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n-2;++i)
        for(int j=0;j<3;j++)
            scanf("%d",&h[i].a[j]);
    for(int j=0;j<3;++j)
        point[h[0].a[j]]=true;
    short ans=0;
    for(int i=1;i<n-2;++i){
        int _ans=0;
        for(int j=0;j<3;++j)
            _ans+=point[h[i].a[j]];
        if(_ans==2) ++ans;
    }
    if(ans==1)  puts("JMcat Win");
    else if(ans==2){
        if(n%2) puts("PZ Win");
        else puts("JMcat Win");
    }
    else{
        if(n%2) puts("PZ Win");
        else puts("JMcat Win");
    }
    return 0;
}

```

# ~~SOMEBODY:只要判断奇偶？~~
他们的程序：
```
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin>>n;
    if(n==5) //实质上是个打表
        cout<<"JMcat Win";
    else if(n%2==0)
            cout<<"JMcat Win"; 
                else cout<<"PZ Win";
    return 0;
}
```
事实上这是个打表，没有任何意义，只是数据太水，合某些人胃口罢了。

# 总结

最后祝大家[**AK IOI**](http://fanyi.baidu.com/translate?aldtype=16047&query=AK+IOI&keyfrom=baidu&smartresult=dict&lang=auto2zh#en/zh/AK%20IOI)！

---

## 作者：阔睡王子 (赞：16)

### 博弈论入门题
看到很多依靠打表找规律的题解。打表是做这道题的，但不是用来做博弈论的，它并不能让你提高解题的思维能力，只是解题的一条捷径，当然也不否认打表是一种有效的解题技巧，在这里我想主要讲一如何分析这道题。


------------

首先题意可以这么理解：
- 给定一个 $n$ 边形，内含一个黑色三角形与多个白三角形，保证白三角形边不会相交只有可能重叠，这样一共有 $n-2$ 个三角形。
- 允许每次切下来**其中一个在边缘的三角形**，最后切下来黑色三角形的人获胜，问你是否有必胜策略。
- （切割规则如例图（原谅我觉得铺色没有排线好看），只允许切割边缘的三角形（见我上色的三角形））\
![](https://cdn.luogu.com.cn/upload/image_hosting/rtcmugxp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\
我们考虑一些特殊局面:
1. 情况一：对于黑色三角形只有一边上有 $1$ 甚至是 $n$ 个三角形，此时是必胜的。\
![](https://cdn.luogu.com.cn/upload/image_hosting/xvia5hku.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
2. 情况二：对于黑色三角形两边分别有 $1$ 个三角形，此时必败\。
![](https://cdn.luogu.com.cn/upload/image_hosting/jfgpn3ha.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
3. 情况三：对于黑色三角形三边都有 $1$ 个三角形，此时必胜。\
![](https://cdn.luogu.com.cn/upload/image_hosting/ygngpmtg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

所以，得益于第一种情况，我们在代码中先处理出黑色三角形可以在第一步直接被切下来的情况：
```cpp
void check(int x,int y,int z)//读入三角形的三个顶点 
{
	int t=abs(x-y);
	if(t==1||t==n-1)cnt++;//如果两个顶点在多边形上相邻，说明有一条边是在多边形边上的，计数+1;
	t=abs(y-z);
	if(t==1||t==n-1)cnt++;
	t=abs(z-x);
	if(t==1||t==n-1)cnt++;
	if(cnt==2)//有两条边在多边形边上，说明黑色三角形可以直接被切下来
	{
		printf("JMcat Win");
		exit(0);
	}
}
```
再思考第二，三种情况：我们考虑把第三种情况看作是第二种情况的变迁。\
此时显而易见，两个人都会避免来切第二种情况，也就是说他们都会争取自己来切出第二种情况，让对方来切第二种情况。\
因此而言，**当胜负见晓时，也就是二人之间某一个人切出第二种情况的时候**（除此以外胜负见晓的情况也就是一开始黑色三角形就可以被切下来或者第二种情况）。此时，原本 $n-2$ 个三角形，只剩下了 $3$ 个三角形。\
由于双方都是一个一个的取，显然切到只剩三个三角形的第二种情况时的那个人必胜，来切第二种情况的对方必败。由于总共取了 $n-5$ 个，所以判断 $n-5$ 的奇偶性：如果是奇，说明后手来切第二种情况，先手必胜；是偶，先手必败。\
所以捋清代码思路，先判断黑色三角形是否可以直接被切下来，然后再判断 $n-5$ 的奇偶性即可。对于 $n$ 小于 $5$ 其实也就是 $4$ 的情况，是包含在黑色三角形可以直接被切下来的情况中的，也就是情况一。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y,z,cnt;
int abs(int a)
{
	return a>0?a:-a;
}
void check(int x,int y,int z)//读入三角形的三个顶点 
{
	int t=abs(x-y);
	if(t==1||t==n-1)cnt++;//如果两个顶点在多边形上相邻，说明有一条边是在多边形边上的，计数+1;
	t=abs(y-z);
	if(t==1||t==n-1)cnt++;
	t=abs(z-x);
	if(t==1||t==n-1)cnt++;
	if(cnt==2)//有两条边在多边形边上，说明黑色三角形可以直接被切下来
	{
		printf("JMcat Win");
		exit(0);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(i==1)
		{
			check(x,y,z);
		}
	}
	if((n-5)%2)
	printf("JMcat Win");
	else 
	printf("PZ Win");
}
```
少打表特判，多想想正解qwq。\
蒟蒻编题解不易，望管理大大恩准通过。


---

## 作者：lyclyc_NSP (赞：13)

**update：2020/2/2 改进了代码**

## 希望管理员能看到：这道题的数据和题解都有问题，求加强。下面是一组 $hack$ 数据：
```
6
0 1 5
1 2 3
3 4 5
1 3 5
```

## 题意简述：

把一个 $N$ 边形沿着对角线切割，分成 $N-2$ 个三角形，选其中一个三角形为黑色三角形。 $JMcat$ 先拿， $PZ$ 后拿，两人轮流拿走边上的一个三角形，谁能拿走黑三角形谁就是胜者。



## 思路：分两种情况
### 第一种如下图：
![](https://i.loli.net/2019/01/27/5c4d465d18569.png)

这一种情况很明显可以直接切到，所以是 $JMcat$ 获胜。


### 第二种情况如下图：
![](https://i.loli.net/2019/01/27/5c4d4756d07dd.png)

当黑色三角形在中间时应该怎么办呢？我们模拟切一下，如果两人都按照最优方案切，那么就会出现下图：
![](https://i.loli.net/2019/01/27/5c4d4f5423f64.png)

唉？这不就是剩下三个三角形，黑色的在中间嘛！那么就是说这一步轮到谁切谁输咯！


切完这个三角形就剩 $2$ 个，所以 $(N-2)$ 就表示切完剩两个三角形后此时共切走多少个三角形。

### 结论：
用 $(N-2)$ % $2$ 如果为 $1$ 即是 $PZ$ 赢，否则是 $JMcat$ 赢。

### 参考程序：
```cpp
#include<cstdio>
#include<algorithm> 
using namespace std;

int n, a, b, c, aa, bb, cc;

void Sort(int &x, int &y, int &z) {
    if (x > y) swap(x, y);
    if (x > z) swap(x, z);
    if (y > z) swap(y, z);
}
int main()
{
    scanf("%d", &n);
    
	//读入黑色三角形的三个顶点编号
	scanf("%d %d %d", &aa, &bb, &cc);
    
	//将三个编号从小到大排序，方便判断
	Sort(aa, bb, cc);
	
	//读入剩下的三角形编号 
    for (int i=2; i<=n-2; i++)
        scanf("%d %d %d", &a, &b, &c); 
    
    //判断黑色三角形是否能够第一刀切到
    if (aa + 1 == bb && bb + 1 == cc) { //编号连续代表三角形在外边 
		puts("JMcat Win");
		return 0;
	}
	
	//当黑色三角形顶点最小是0是需要特判3种情况 
	if (aa == 0) {
		if ((bb == 1 && cc == n - 1) || (bb == 1 && cc == 2) || (bb == n-2 && cc == n-1)) {
			puts("JMcat Win");
			return 0;
		}
	}
	
	//这里思路已经说过
    if ((n - 2) % 2 == 1) puts("PZ Win");
		else 
	puts("JMcat Win");
    return 0;
}
```

---

## 作者：yummy (赞：11)

数学老师表示很开心

好多人说奇偶判断只能骗分，其实这是有理由的。

证明：在第一刀无法结束游戏的情况下，边数的奇偶决定了胜负。

由于如果黑色三角形有两条边露在外面，则下一步即可结束游戏，所以双方切到最后会只剩下2个三角形，下一步轮到谁，谁就赢了。

so，只要在第一刀时特判即可。
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n,a,b,c;
    cin>>n;
    cin>>a>>b>>c;
    if((abs(a-b)==1)+(abs(a-c)==1)+(abs(b-c)==1)>=2)//有2条边在外面就意味着一刀可以结束游戏
    {
        cout<<"JMcat Win";
        return 0;
    }
    if(n%2)
        cout<<"PZ Win";
    else
        cout<<"JMcat Win";
    return 0;
}
```

---

## 作者：ww3113306 (赞：4)

貌似楼下的格式好像比较乱？

发一个~~自认格式还不错的~~代码

显然如果一个黑三角在最外面，那么cat肯定赢，

因此我们只需要考虑黑三角在里面的情况，

由于不能让对面赢，所以每次取的时候都要尽量避开取一个三角形后将黑三角暴露的情况
```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
int n,s[50500],b_a,b_b,b_c;

inline int read()
{
	int x=0;char c=getchar();
	while(c>'9' || c<'0')c=getchar();
	while(c>='0' && c<='9')x=x*10+c-'0',c=getchar();
	return x;
}

void pre()
{
	R a,b,c;int go;
	n=read(),go=n-3;
	b_a=read(),b_b=read(),b_c=read();
	s[b_a]++ , s[b_b]++ , s[b_c]++;//error！！！不要忘记把第一个三角形放进来。。。
	for(R i=1;i<=go;i++)
	{
		a=read(),b=read(),c=read();
		s[a]++,s[b]++,s[c]++;//存下每个点连边个数用于特判
	}
}

void work()
{
	if(s[b_a]==1 || s[b_b]==1 || s[b_c]==1) printf("JMcat Win\n");//如果有一个顶点只连了一条边的话，这个三角形是在最外面的
	else if((n-2)%2) printf("PZ Win\n");//不然的话黑三角就在里面包着，所以赢的条件就是拿走一个三角形使得剩下3个三角形，这时由于一直执行最优策略
	else printf("JMcat Win\n");//（不拿走黑三角外面那个三角），所以剩下的必定是白黑白这样的搭配，因此这样就赢了，由于cat先拿，如果
}//三角形个数是偶数的话，每次cat拿走一个后剩下的三角形就会是奇数，因此这时cat就赢了，所以判断奇偶即可

int main()
{
	pre();
	work();
	return 0;
}
```

---

## 作者：Jay_Z (赞：3)

这题看起来很难，其实有点水。。。

**非正解**

其实就是判对角线数，如果对角线是奇数就JMcat Win，否则就是PZ Win
那么上代码
```cpp
#include<iostream>
using namespace std;
int  main(){
    int n;
    cin>>n;
    if((n-3)%2==0) cout<<"PZ Win";
    else cout<<"JMcat Win";
    return 0;
}
```
但是会WA！！！因为没考虑一刀切和在多边形内部；
就比如5边形，100,010（1是黑的，0是白的）
所以判断下黑的顶点是否连续就行
```
#include<iostream>
using namespace std;
int  main(){
    int n,a,b,c;
    scanf("%d",&n);
    scanf("%d %d %d",&a,&b,&c);
    if(a+1==b){
    	if(b+1==c){
    		printf("JMcat Win");
			return 0; 
		}
	}
    if((n-3)%2==0) printf("PZ Win");
    else printf("JMcat Win");
    return 0;
}
```
好的AC，**这不是正解！！！**

---

## 作者：角边边证全等 (赞：3)

这道题很多人各种骗九十分

九十分连那些边都不用输入

就判断一下奇偶

但第二个点死都过不了

正解算法：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int read(int & n)//快读，其实我觉得没必要，怕超时而已。后来发现0ms过
{
    char c='-';int x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+(c-48);
        c=getchar();
    }
    n=x;
}
int n;
int a[4];
int main()
{
    read(n);
    read(a[1]);read(a[2]);read(a[3]);
    sort(a+1,a+4);
    if(n%2==0)//确实，我承认我也用了判断奇偶，但不全是
        printf("JMcat Win");
    else//这里面不一定全是PZ，当有两条边的边长之差等于1是，还是JMcat
    {
        int count = 0;
        if (abs(a[1]-a[2])==1) count++;//一个一个判断
        if (abs(a[1]-a[3])==1) count++;
        if (abs(a[2]-a[3])==1) count++;
        if (count==2) 
        cout<<"JMcat Win\n";
        else cout<<"PZ Win\n";
    }
    return 0;
}
```

---

## 作者：远航之曲 (赞：2)

【分析】

     如果一开始黑点就在一个边角上面的话，肯定是Cat赢，如果不是那只有奇偶分析，试想谁都不会把黑点切成边角，这样一个切一刀，直到某个人面临3个三角的时候，这是这个人肯定就输了。

  【参考代码】

#include<stdio.h>

int main()

{
 int Ha[53001]={0},n,aa,bb,cc;

 scanf("%d",&n);

 for(int i=1;i<=n-2;i++)

 {
  int a,b,c;

  scanf("%d%d%d",&a,&b,&c);

  if(i==1)aa=a,bb=b,cc=c;

  Ha[a]++;Ha[b]++;Ha[c]++;

 }
 if(Ha[aa]==1 || Ha[bb]==1 || Ha[cc]==1)
 {
  printf("JMcat Win\n");

  
 }
 else if((n-2)%2==1)

  printf("PZ Win\n");

 else
  printf("JMcat Win\n");

 return 0;

}

---

## 作者：isCYF (赞：0)

这个应该按照黑色三角形有几条边需要切，和总共有几条边需要切来分情况。
1. 当只有黑色三角只有一条边需要切，毫无疑问先手必胜
2. 当不止一条边需要切，为了避免对方获胜，此时切边的人会尽力不切与黑色三角形的边，以避免对方切最后一次获胜。故永远是切最后一条边的获胜。所有当n为奇数时有偶数条边需要切，后手胜。当n为偶数时，有奇数条边，先手胜。

```c
#include <cstdio>
#include <algorithm>

using namespace std;

int p[3];

int main () {
	int n;
	scanf("%d", &n);
	
	// 输入黑色三角形的顶点 
	for (int i = 0; i < 3; i++) scanf("%d", &p[i]);
	sort(p, p+3);
	
	// 这些数据都是没有用的 
	for (int i = 3, x, y, z; i < n; i++) {
		scanf("%d%d%d", &x, &y, &z);
	}
	// p[0]+1 == p[1] && (p[1]+1 == p[2] || (p[0] - p[2] + n) % n == 1) 为真时黑色三角形只有一条边需要切
	if ((p[0]+1 == p[1] && (p[1]+1 == p[2] || (p[0] - p[2] + n) % n == 1)) || n % 2 == 0) {
		printf("JMcat Win");
	} else {
		printf("PZ Win");
	}
	 
	return 0;
```



---


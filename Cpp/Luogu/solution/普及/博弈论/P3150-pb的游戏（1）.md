# pb的游戏（1）

## 题目背景

有一天 pb 和 zs 玩游戏  你需要帮 zs 求出每局的胜败情况。


## 题目描述

游戏规则是这样的：

- 先手对给出的数进行分割，分割成两个正整数，之后接着后手选择留下两个数中的其中一个。两人轮流操作，直到一方无法操作，另一方胜利。

现在要你求出 $N$ 次游戏的胜败。

我们认为双方绝顶聪明。每局由 pb 先进行分割。如果 pb 存在必胜策略，输出 `pb wins`；否则输出 `zs wins`。


## 说明/提示

对于全部数据，$1<N<50$，$1\le M\le 10^9$。


## 样例 #1

### 输入

```
5
1
3
7
20
5```

### 输出

```
zs wins
zs wins
zs wins
pb wins
zs wins
```

# 题解

## 作者：姬小野 (赞：279)

这道题是洛谷博弈论专题的第一道入门题, 然而刚开始我是不会做的, 毕竟是道入门题, 我博弈论还没入门呢.

这道题的做法就是: **如果m为偶数, 那么先手赢(即pb), 如果m为奇数, 那么后手赢(即zs).**

<strong> 做法很简单, 可是我们要知道怎么做的</strong>

说实话我对于他们两个都聪明绝顶, 都会按照最优策略来走很不感冒. **既然他们聪明绝顶, 那么先手明知道m为奇数时自己会输, 为什么不洒脱一点走呢? 也许乱走出奇迹?**

那我们来试试看. 当`m = 13`时, 先手为什么会输. 前提是先手知道自己按照最优策略会输(因为轮到他分时为奇数), 所以开始乱走.

```
先手：１３ = ４ +９
后手：选４, ４ = １ +３
先手：不得已选３，　３＝１＋２
后手：选２，２＝１＋１
后手赢
```

不服? 再来一把
```
先手：13＝６＋７
后手：选６，６＝１＋５
先手：选５，５＝１＋４
后手：选４，４＝１＋３
先手：３＝１＋２
后手：２＝１＋１
后手赢
```

经过了两把测试, **我们不管先手怎么走(乱走或所谓最优策略),只要他手里是奇数,都不得不拆成奇数+偶数**, **那么后手只要选择偶数, 他就可以把这个数化成`m = n + 1`(后手的最优策略)**, 把奇数转移给先手. **这样经过若干次转移之后, 后手手里一定会是`2`,然后`2 = 1 + 1`, 后手就赢了.**

所以, 其实手里是奇数的人是没有胜算的, 所以这个状态是**必败态**. 而手里是偶数的人是有必胜的可能的, **只有他才有最优策略而且只要他按照最优策略走, 他一定会赢**, 因此这个状态是**必胜态**. 当然, 如果他sa, 就可能将**必胜态**拱手让人.

**而理解这个博弈论问题的关键, 就是拥有偶数的策略: 每次减一. 因而可以再次将偶数态(必胜态)转移过来.**

事实上, 刚接触此题时, 我对所谓**绝顶聪明**, 所谓**最优策略**很困惑, 两个人博弈, 凭什么说我走的是最佳策略结果却输了? 我是不是应该把所有走法都试一遍, 然后都输给你才算我输? 

我的理解是: **必败态从来没有最佳策略, 博弈也不是双方的博弈, 而是处在必胜态的那方和自己博弈. 而这场博弈, 由于绝顶聪明的前提, 是必胜的, 而我们要做的, 只是找出谁有跟自己博弈的机会.**

此题入门, 然颇有感触, 大佬轻喷.

```cpp
#include <iostream>
using namespace std;

int main()
{
	int n, x;
	cin >> n;
	while (n--) {
		cin >> x;
		if (x & 1) cout << "zs wins" << endl;
		else cout << "pb wins" << endl;
	}
}
```

---

## 作者：GaryZhong (赞：38)

## 思路浅析


当$N>1$时胜负比较难以判断，我们可以先从$N=1$的情况来进行讨论。

(下面这一段是我胡扯，你可以略过)

引入博弈论模型中的几个概念：

1.必败态

2.必胜态

3.游戏局面的转移

1和2可以从字面看出，必败态即该局面下先手必败的状态，必胜态即该局面下先手必胜的状态。

根据定义可以得知，必胜态必然能够通过转移游戏局面，使状态变为必败态，因为原本先手必胜，所以能变为后手必败。


显然$N=1$是必败态，因为按照题意"将其割成两个非零自然数"，1无论怎么分割总有一个0，因此为必败态。

因此能够先手转移至$N=1$的状态为必胜态，否则为必败态。

对于$N>1$，由于"双方都是绝顶聪明的"，因此双方都在设法转移至$N=1$的状态，那就将$N$分为$N=(N-1)+1$，对手必然不会选择1，因此由$N-1$继续分为$N-1=(N-2)+1$，一直到$N=1$需要$N-1$步，若$N-1$为奇数，那么此时面对$N=1$状态的是后手，因此$N-1$为奇数时后手必败，也就是$N$为偶数时先手必胜；若$N-1$为偶数，那么此时面对$N=1$状态的是先手，因此$N-1$为偶数是先手必败，也就是$N$为奇数时先手必败。

这样程序就很好实现了。


## 代码：

```cpp
#include <cstdio>

int n, a;

int main()
{
    scanf("%d", &n);
    while (n--)
    {
        scanf("%d", &a);
        //奇数时先手必败，即后手必胜，偶数时先手必胜
        if (a & 1) //这句话等效与if (a & 1 == 1)还有if (a % 2)以及if (a % 2 == 1)因为所除的数2是2的1次幂，可以使用位运算加快速度，简化书写
            printf("zs wins\n");
        else
            printf("pb wins\n");
    }
    return 0;
}
```

---

## 作者：Scarlet (赞：12)

十分朴素的零和博弈游戏

枚举每个数被分成了多少，打个表看SG值

发现答案只和奇偶性有关。

就没了。

归纳证明：

$n=1$时先手必输

$n=2$时$2$分解成$1+1$后手无论选哪个都必输。

假设$k<=n$时奇数先手必输，偶数先手必胜。

$n+1$为奇数时，先手只能把$n+1$分成不超过$n$的一个奇数一个偶数，机智过人的后手一定会选择偶数来保证自己不败。

$n+1$为偶数时，机智过人的先手一定会把$n+1$分解成两个奇数，后手不得不选择奇数从而走向自爆。

到这里就证明了这个问题


---

## 作者：不曾错过 (赞：6)


**~~小学生又来发题解了！！！~~**    

这是道看起来很难的红题，但实际一点都不难。  
（**~~连我这种博弈论还没入门的人都能做出的题~~**）

   思路解析：
   在博弈论里常见的只有两种概念
   1.必败态
   2.必胜态
      
   假设m=13
      先手来：  m=4+9
      后手选 4 ：4=1+3
      先手只选 3： 3=1+2
      后手选 2 ：2=1+1
      后手赢
      
   再来一次
      
   假设m=13
      先手来:  m=5+8
      后手选 8 : 8=1+7
      先手只选 7 : 7=3+4
      后手选 4 : 4=1+3
      先手只选 3： 3=1+2
      后手选 2 ：2=1+1
      后手赢
      
   经过两次的实验后，我们发现了都是后手赢的，其中我们会发现后手只要选到偶数就会赢，到底为什么呢？？？
    
   在后手选到偶数后，他只要拆成 1+n 就可以了（后手的必赢策略），因为这样先手就只能能选n这个奇数，再拆成奇数+偶数，这样后手就必赢了。
    
   所以手中是奇数的话是完全没有胜算的，手中是偶数就赢定了。
    
   于是这道题就从博弈论变成了判断奇偶。
    
   知道规律后这道题就简单到不要不要的了（掌声在哪里！！！ 礼花！ 礼花！）
    
    好了原归正传，代码如下：
    #include<string>
    #include<cstring>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<iostream>        //文件头
    using namespace std;
    long long n,shu;          //定义
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++)
        {
          cin>>shu;           //输入
          if(shu%2==1){cout<<"zs wins"<<endl;}//如果是奇数，zs赢。
          if(shu%2==0){cout<<"pb wins"<<endl;}//如果是偶数，pb赢。
        }
        return 0;   //完美结束
    }     
   第三次发题解，还是有点紧张,可能有些地方说的不太清楚，有错误请大佬指出，拜拜~~

---

## 作者：zubizakeli (赞：2)

    虽然这题可以找规律，但我们也要知道原理啊。。
    看了几篇题解，要么是没有证明，要么是有些奇怪。。所以我来发一篇便于理解的题解=-=
    
   ————————————手动分割——————————————————
   
    其实这题和**nim游戏**的证明有些相像，只要nim的证明懂了，这题应该就没有什么问题。
    首先我们考虑末状态（1,1），两个数字都是奇数。
    假如我们面前两个数（或刚开始时的一个数）中有一个是偶数，那么我们就可以把这个偶数分割成2个奇数。
    那么对方就只能操作奇数。而奇数分割后一定是一偶一奇，然后你继续把偶数分割为两个奇数... ...
    显然游戏是一定会进行完的，而对方面临的都是（奇数，奇数），你面临的都至少有一个偶数（前提是你第一次操作时面前就是偶数），而最后的必败态是（1,1）（两个奇数），所以显然你是必胜的。
    综上，可以发现只要先手面临的是一个偶数，就是必胜的；如果是奇数的话就会给对方留下一个偶数，所以必败。
    
   ——————————————证毕————————————————————
   
    代码就判断个奇偶就行了，就不放了（^_^）
    
    最后吐槽一下为什么难度评级那么低啊...（入门难度是什么鬼啊qwq）大家评级的时候难道都只看代码难度不看思维难度吗... ...

---

## 作者：叶不修 (赞：2)

   这道题其实是数学题，两人绝顶聪明其实也就是大智若愚，即每个人将n划分为1|n-1，再将n-1分为1|n-2，直到分为1|1为止。
所以说，因为pb每次都先走，所以当n为奇数时，总会有zs先将此数分至1|1，故输出“zs wins”，反之输出“pb wins”

顺带提醒一句，我们在打完自己的程序之后，一定要再测一遍，一定要再测一遍，一定要再测一遍，重要的事情说三遍！~~（我就因为这个WA了一次）~~

代码如下

```cpp
    #include<cstdio>
    #include<iostream>
    #include<cmath>
    #include<algorithm>
    #define ll long long 
    using namespace std;
    ll n,m;
    int main()
        {
        cin>>n;
        for(int i=1;i<=n;i++)
            {
            cin>>m;
            if(m%2==0) cout<<"pb wins"<<endl;
            else cout<<"zs wins"<<endl;
            }
        return 0;
}
```

---

## 作者：Peter_Z (赞：1)

##题目描述（节选）

游戏规则是这样的： 每次一个人可以对给出的数进行分割，将其割成两个非零自然数，之后

由另一个人选择留下两个数中的其中一个；之后由另一个人进行分割这个剩下的数，重复步骤……

当一个人无法对数进行分割的时候游戏结束，另一个人获胜。

现在要你求出N次游戏的胜败。

--------------------------------------------------------------------------------------------------------------

##题目分析

对于每一次分割操作，数的总数会+1。当所有数均为1时，就无法继续分割了。此时分割的人输。

可以求得数的总数在起始和结尾处变化了(m-1)。由于pb先开始，所以当(m-1)为奇数，即m为偶数

时，pb获胜。

###即：m为奇数 zs获胜   反之 pb获胜

--------------------------------------------------------------------------------------------------------------

##优化思路

1.快速读入。由于此题没有负数，所以我对快速读入的函数作了一些修改。

2.位运算。当出现类似于x%2的式子时，取模运算是算得很慢的。而由于位运算较快，所以可以

化为**x&1**

原理：按位与只有两数位置上都为1结果才为1。

例子：m=1001101101（二进制） m&1运算如下：

1001101101

0000000001

其中由于1的前面全部为0，最后一位为1，所以这个表达式共有2种情况：

当m能被2整除，即二进制下最后一位为0时，该式为0。

反之，当m不能被2整除，即二进制下最后一位为1时，该式为1。


~~其实由于这题的数据量小，n<50,所以根本不用优化，暴力就可以了……~~

--------------------------------------------------------------------------------------------------------------

代码：

```cpp
#include<stdio.h>
inline int read() {
    int x=0;
    char ch=getchar();
    while(ch<'0' || ch>'9')
        ch=getchar();
    while(ch>='0' && ch<='9') {
        x=10*x+ch-'0';
        ch=getchar();
    }
    return x;
}
int main() {
    int n,m;
    n=read();
    for(int i=1; i<=n; i++) {
        m=read();
        if(m&1)            //奇数 
            puts("zs wins");
        else
            puts("pb wins");
    }
    return 0;
}
```

---

## 作者：xiezheyuan (赞：0)

> 有 $n$ 个石子，每轮 Alice 将石子分成非空的两个部分，然后 Bob 拿走其中的一部分。然后双方互换。不能操作的判负。$m$ 组数据，每组数据给出一个 $n$，求是 Alice 赢还是 Bob 赢。$1\leq m\leq50,1\leq n\leq10^9$

首先容易发现这是一个公平组合游戏（因为满足它的定义嘛，没啥好说的）。

观察样例可以发现，如果 $2\mid n$，则 Alice 赢，否则 Bob 赢。事实上这个结论是正确的。

为什么呢？首先容易发现只有拿石子的那个人可能拿不了，我们就从这里考虑。

状态就是剩下的石子数，我们就可以列出 SG 函数 $f(S)$ 为：

$$
f(S)=\begin{cases}
0&S=1\\
\text{mex}(\bigcup_{k=1}^{n}\{\max(f(k),f(S-k)\})&\text{otherwise}
\end{cases}
$$

然后怎么求这玩意的值呢？我们发现什么时候 $f(S)$ 会为 $0$，除了 $S=1$ 的情况下，还有就是 $f(S-1)$ 不为 $0$ 的情况下。这个条件是充要的。换句话说当且仅当 $2\mid S$ 的时候 $f(S)\neq 0$。

这个结论没有那么显然，我们证明一下，先数学归纳，假如 $f(S-1)$ 及之前都是成立的，然后用反证法：

* 假如 $f(S-1)=0,f(S)=0$，因为 $f(1)=0$，所以 $\text{mex}$ 一定大于 $0$。矛盾。所以不可能。
* 假如 $f(S-1)\neq0,f(S)\neq0$，则存在一个 $f(k)=0,f(S-k)=0$。发现需要满足 $(k+1)\mid 2,(S-k+1)\mid 2$。所以 $2\mid S$，又因为 $f(S-1)\neq 0$，所以 $2\mid(S-1)$ 矛盾。所以不可能。

于是我们就证明了这个结论。

放个代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

signed main(){
	int t;cin>>t;
	while(t--){
		int n;cin>>n;
		cout<<(n & 1 ? "zs wins" : "pb wins")<<'\n';
	}
	return 0;
}
```

---

## 作者：panyueyang (赞：0)

# 1.经典博弈论的题目，千万不要凑哈
## 如果我拿到奇数
对手分成偶数+奇数，我肯定拿偶数
但是对手分我肯定又是奇数。
最后一个得到的奇数肯定是1。

所以我如果拿到奇数，必输
## 拿到偶数
一定给对手奇数了
偶数，必赢。
# 2.~~不是AC的~~代码
代码 ~~不是AC~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int n,a[1000];
cin>>n;
for(int i=0;i<n;i++)cin>>a[i];
for(int i=0;i<n;i++)
{
if(a[i]%2==0)cout<<"pb wins"<<endl;
else cout<<"zs wins"<<endl;
}
```


---

## 作者：controlf3 (赞：0)

## 首先了解一点：奇数后手胜，偶数先手胜。
## 然后我们来用不完全归纳法证明：
## m为奇数时后手胜，m为偶数时先手胜。
（1）当m=1,2时，上述结论显然成立（自己写个1，写个2看看就好了）

（2）假设对于m=1到k时，上述结论也成立。

       1 当k为奇数时，k+1为偶数，pb先手，
       
       一个偶数（k+1）能被拆分为两个奇数或两个偶数。而拆分后变成了zs先手。
       所以pb一定会给zs两个奇数（这两个奇数都比k小），然后无论zs
       选哪个，都要输给pb(因为假设m=1到k满足奇数后手胜)
       所以说，m=k+1（偶数）时pb胜，满足偶数先手胜（即归纳法结论）
       
       2 当k为偶数时，k+1为奇数，pb先手。
       
       一个奇数（k+1）一定是被拆分成一奇一偶（都比k小），此时zs先手，由
       由假设知在m=1到k时奇数后手胜，偶数先手胜，所以zs一定会选择其中那个
       偶数，然后获胜。
       所以说，m=k+1（奇数）时zs胜，满足奇数后手胜。
       
       
       （到这里，只要1..k满足该规律，k+1就满足，同理k+2,k+3也满足）
       综上（1）（2），该规律对于自然数成立。
       
       然后就是代码了。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,m;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&m);
		if(m%2==0)printf("pb wins\n");
		else printf("zs wins\n");
	}
	return 0;
}
```

### 如果有时间，还是希望自己能学一下博弈论，毕竟用博弈论分析要比先猜再归纳快的多。
### 我在想这题为什么是入门？？？难道正解是找规律？？？

---

## 作者：Lance1ot (赞：0)

每种状态可以分成_必胜态_和_必败态_  

必败态和胜态有着如下性质：       ~~好像是博弈树呀？我好蒟蒻呀~~
1. 若面临末状态者为获胜则末状态为胜态否则末状态为必败态。  

2. 一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 

3. 一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态

[链接](https://wenku.baidu.com/view/6ed7ccdbce2f0066f53322dd.html)

末状态为1，必败。

2为必胜，2可以分为1+1

3为必败，3=1+2.而对于对手来说，他肯定选2.所以必败

那么4呢？

4=1+3=2+2

如果分成2+2.则两个都是必胜态。自己肯定不可能怎么傻

1+3.3和1都是必败态，所以4是必胜态

显而易见，偶数都是必胜态

假设k为奇数

k、k+2为必输态

k+4=k+2  +   2=k  +   4   =………………

2为必胜态。对手肯定选他。所以k+4为必输态

-------------------------------

也可以怎么想，如果你是奇数，你肯定要分解成一奇一偶。
我肯定选偶数，然后我分解成两个奇数。如此循环。然后你肯定会拿到1。然后你就输了。

所以奇数都是必输态

那么偶数为必胜。因为可以分成两个奇数之和

奇数为必败。奇数只能分为偶数和奇数之和。

那么判断就就行了。
### ~~RQY大佬太强了~~
###### RQY的思路~~（应该是吧）~~，然后我稍微整理了一下

---

## 作者：yali_hzy (赞：0)

论为什么可以直接判奇偶。


如果开始是奇数，则只能分成奇数+偶数，而后手一定会选偶数分


如果现在是偶数，则会分成奇数+奇数


如果到1时，游戏结束


所以，zs拿奇数赢，拿偶数输


所以，得证


代码：


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int m,n,i;
int main()
{
    scanf("%d",&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d",&n);
        if(n%2)
            printf("zs wins\n");
        else
            printf("pb wins\n");
    }
}
```

---


# Roy&October之取石子II

## 题目背景

Roy 和 October 两人在玩另一个取石子的游戏。（第一季请看 P4018）

## 题目描述

游戏规则是这样的：共有 $n$ 个石子，两人每次都只能取 $p^k$ 个（$p$ 为质数，$k=0$ 或 $1$，且 $p^k$ 小于等于当前剩余石子数），谁取走最后一个石子，谁就赢了。

现在 October 先取，问她有没有必胜策略。

若她有必胜策略，输出一行 `October wins!` ；否则输出一行 `Roy wins!`。

## 说明/提示

对于 $30\%$ 的数据，$1 \le n \le 30$；

对于 $60\%$ 的数据，$1 \le n \le 10^6$；

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^7，1 \le T \le 10^5$。

花絮：由于出题人懒得造数据，就把 P4018 的输入直接拿来了 ovo

## 样例 #1

### 输入

```
3
5
7
14```

### 输出

```
October wins!
October wins!
October wins!```

# 题解

## 作者：Ofnoname (赞：18)

之前做[P4016](https://www.luogu.org/problemnew/show/P4018)的时候看了题解，初步了解了博弈论的基本做题方法，现在举一反三，用相似的解法完成这道题。

题目要求显然就是可以取1和全体质数，即$\{1,2,3,5,7...\}$。以此进行归纳分析：

1. 当N=1,2,3时，显然先手可以一次全部拿完，胜。
2. 当N=4时，先手只能拿1,2,3个，剩下的被后手拿走，负。
3. 当N=5,6,7时，先手先拿1,2,3个，这时还剩4个，转化为情况2，胜。
4. 当N=8时，若先手拿1个，则后手直接拿7个；若先手拿质数个，由哥德巴赫猜想，剩下的也是质数个，后手直接全部拿完即可，负。

综上所述：

1. 若$N=1,2,3$，则显然先手必胜。
2. 若$N=4k(k∈Z_+)$,则N为偶数，由哥德巴赫猜想，若先手拿质数个，质数当然不是4的倍数，变为情况3，后手胜；若先手拿一个，后手拿三个，此时N仍为4的倍数，循环下去后手也能拿到最后一个，后手必胜。
3. 若$N=4k+1,4k+2,4k+3(k∈Z_+)$,则先手先拿1,2,3个，此时N变为$4k$，转化为情况2，先手必胜。

代码就不注释了：

```cpp
#include <bits/stdc++.h>
using namespace std;

int T,N;

int main()
{
    scanf("%d",&T); while (T--)
	{
		scanf("%d",&N);
		puts((N%4)?"October wins!":"Roy wins!");
	}
    return 0;
}
```



---

## 作者：7wwwwth (赞：12)

跟第一季也没啥不同诶

都是打表找规律

4的倍数是Roy必胜

其余都是October必胜

我的妈这个游戏对Roy真不公平...

代码就不贴了吧...

---

## 作者：张文奕 (赞：9)

分析题目

首先，双方只能取p^k,k=0或1，换句话说就是每次只能拿0个或任意一个质数的

每次可以取走1、2、3，但4取不了。则两个人每一回合的最强策略都是共取走4个。因此尽量取一个数，使剩余的石子数是4的倍数，就获胜了。所以除了初始数量为4的倍数，其他情况先取的都可以获胜。

下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
    cin>>t;
    while (t--){//组数
        int n;
        scanf("%d",&n);
        if (n%4==0) printf("Roy wins!\n");//是4的倍数后取的胜
        else printf("October wins!\n");//否则先取的胜
    }
    return 0;
}```

---

## 作者：zi小眼聚光 (赞：6)

萌新刚学SG函数，就来刷刷博弈论的简单题试手

简单介绍下SG函数：
	
1.先来介绍下必败态和必胜态的性质：在博弈论中，必胜态的后继状态中必定有必败态，而必败态得后继状态则一定是必胜态（十分显然）

2.定义mex(minimal excludant)函数：mex函数的自变量是一个集合S,函数值是一个自然数，这个自然数是S中最小的没有出现过的自然数，如mex{0}=1,mex{0,1,2}=3,mex{1}=0。当然，mex{∅}=0。

3.对于一个局面，他的SG函数为所有后继的SG函数值构成集合的mex值，当一个局面的SG函数值为0时，它是必败态；否则为必胜态。

**证明：** 当一个状态的SG函数为0，则它的后继状态SG函数都不为0，为必胜态，满足必败态的性质，而当一个状态的SG函数不为0，则它的后继状态至少有一个SG函数为0，为必胜态。

我们一般用搜索/dp等方式来打出SG函数的表从而寻找规律

以本题做例子：

   首先我们转化下题意：给定一个数n，每次可以另n减去一个不大于它的质数或者1，先把数减为0的人获胜。
   
很容易就得出SG（0）=0，SG（1）=1了，那么剩下的我们选择用递推实现。

下面代码中SG函数与上面定义不太一样，因为我们只需要知道一个状态的SG函数值是不是0，所以所有状态的SG函数值都被我用0/1表示了，这样递推比较方便。

代码（有注释）：

```cpp
#include <cstdio>
#define N 10005
using namespace std;
int SG[N],n;
int mindiv[N],prime[N],tot;
inline void euler(){//线性筛
  mindiv[1]=1;
  for(int i=2;i<=n;++i){
    if(!mindiv[i])prime[++tot]=i,mindiv[i]=i;
    for(int j=1,k;j<=tot&&prime[j]<=mindiv[i]&&(k=prime[j]*i)<=n;++j)mindiv[k]=prime[j];
  }
}
int main(){
  SG[1]=1;
  scanf("%d",&n);
  euler();prime[0]=1;//做一遍线性筛方便递推。如果不会线性筛请左转p3383
  for(int i=2;i<=n;++i){
    for(int j=0;prime[j]<=i&&j<=tot;++j){
      if(SG[i-prime[j]]==0)SG[i]=1;//如果后继状态中有必败态，则当前状态为必胜态
    }
  }
  for(int i=1;i<=n;++i)printf("%d %d\n",i,SG[i]);//发现4的倍数都是必败态
  return 0;
}
```

打完表后就找规律咯

AC代码就不放了，找完规律就是水题

---

## 作者：绝顶我为峰 (赞：5)

看了楼下的，我来发一个详细点的。

------------

#### $p^k$（$p$为质数，$k=0$或$1$，且$p^k$小于等于当前剩余石子数）

也就是说取的数目只能是$1$和所有质数。

------------

显然$1,2,3$都可以一次取到，而对于$4$，无论第一次取多少，后手都可以一次取完。

对于$5,6,7$，先手可以先分别取$1,2,3$个转化为后手先取$4$个的情况，所以先手必胜。

~~当然你也可以把5和7一次取完~~$qwq$

而对于$8$，显然可以分成$2$个$4$来取，后手必胜。

综上所述，石子数量是$4$的倍数时后手胜，否则先手胜

代码就不贴了吧。。。

---

## 作者：dsjkafdsaf (赞：4)

这道题也是一道水题。。

#### 通过打表找规律，我们可以发现

###  当石子数为1时，取走p^0=1(必胜态)；
###  当石子数为2时，取走2^1=2(必胜态)；
###  当石子数为3时，取走3^1=3(必胜态)；
###  当石子数为4时(必败态)；
###  当石子数为5时，取走5^1=5(必胜态)；
###  当石子数为6时，取走2^1=2，剩余6-2=4(必胜态)；
###  当石子数为7时，取走3^1=3，剩余7-3=4(必胜态)；
###  当石子数为8时(必败态)；
###  当石子数为9时，取走5^1=5，剩余9-5=4(必胜态)；
###  当石子数为10时，取走2^1=2，剩余10-2=8(必胜态)；
###  当石子数为11时，取走3^1=3，剩余11-3=8(必胜态)；
###  当石子数为12时(必败态)；
### 以此类推...
## 从中可得凡石子数%4==0，为必败态；其余为必胜态。
代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000001];
int main() {
    int n;
    cin>>n;
    for(int i=1; i<=n; i++)cin>>a[i];
    for(int i=1; i<=n; i++) {
        if(a[i]%4==0) {
            cout<<"Roy wins!"<<endl;
        } else cout<<"October wins!"<<endl;
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

此题是一道博弈的题，只要找到其规律（重点），那么之后的代码就会非常简单。   

这道题的题名叫[Roy&October之取石子II](https://www.luogu.com.cn/problem/P4860)，其实为[P4018 Roy&October之取石子](https://www.luogu.com.cn/problem/P4018)的第二季，两道题极其相似，您亦可全部AC。  
  
###   题意简述：  
共有$n$个石子，Roy 和 October两人每次都只能取$p^k$个（$p$为质数，$k=0或1$，且$p^k\le$当前剩余石子数），谁取走最后一个石子，谁就赢了，October 先取，求结果。  
### 题目分析  
按照规则，谁能够一次性将当前剩余石子全取走，那么他就赢。先分析一次取石子的可能情况，每次可取$p^k$个（$p$为质数，$k=0或1$...)，转化一下即为1和所有质数，即{$1,2,3,5,7...$}。  
当$n=1$时，先手October可一次全部取完，获胜；  
当$n=2$时，先手October可一次全部取完，获胜；  
当$n=3$时，先手October可一次全部取完，获胜；  
当$n=4$时，先手October可取的石子数为1或2或3，剩余的石子必将使对方直接获胜，己败；  
当$n=5$时，先手October可取的石子数为1或2或3或5，可取1个使对方得到$n=4$的情况最终己胜，亦可取5个直接获胜；  
当$n=6$时，先手October可取的石子数为1或2或3或5，取2个可获胜；  
当$n=7$时，先手October可取的石子数为1或2或3或5或7，取1个或3个可获胜，亦可取7个直接获胜；  
当$n=8$时，先手October可取的石子数为1或2或3或5或7，取1或3或5或7将直接失败，而取2个，将剩余6个，即使对方得到$n=6$的情况，对方可取胜，己败；  
  ......  
  
  通过上面的分析可知只要$n$不为$4$的倍数则先手October必胜，所以判断$n$是否是$4$的倍数即可判断最终结果。(也就是说解题代码与第一季的只涉及到6和4的改变，当然规律有所出入)  
###   Code:  
```cpp
#include<iostream>
using namespace std;
#define endl '\n'   \\利用宏定义加速endl换行 
int main()
{
	ios::sync_with_stdio(0);   \\关闭同步流，加速cin输入和cout输出 
	int t,n;   \\定义测试点组数和石子数 
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		cin>>n;
		if(n%4!=0)   \\判断是否是4的倍数，此为否 
        {
            cout<<"October wins!"<<endl;
        }
        else
        {
            cout<<"Roy wins!"<<endl;
        }
	}
	return 0;  \\结束整个程序 
 } 
```
### 结果（未吸氧）：  
![JieGuo](https://cdn.luogu.com.cn/upload/image_hosting/0ds2vbuh.png)  
企鹅的题解到此结束，祝各位OIers进步++~

---

## 作者：MoXiaodu (赞：2)

### 题目背景

Roy和October两人在玩另一个取石子的游戏。（第一季请看P4018）

### 题目描述

游戏规则是这样的：共有n个石子，两人每次都只能取$p^k$个（p为质数，k=0或1，且$p^k$小于等于当前剩余石子数），谁取走最后一个石子，谁就赢了。

现在October先取，问她有没有必胜策略。

若她有必胜策略，输出一行"October wins!"；否则输出一行"Roy wins!"。

### 输入格式

第一行一个正整数T，表示测试点组数。

第2行~第(T+1)行，一行一个正整数n，表示石子个数。

### 输出格式

T行，每行分别为"October wins!"或"Roy wins!"。


------------

根据题目，我们可以发现，每次我们都可以取走一个质数$q$或者 $q^0=1$。

也就是说，我们一定不可以一次取走的最小数为4。

通过递推可以得知只要是4的倍数，后手方都可以通过控制使当前值保持为4的倍数或者直接拿走所有棋子。不然，先手就可以控制棋子数量为4的倍数

因此，这道题就被化简为一个很简单的问题：

如果当前数%4==0，后手赢，否则先手赢

完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;

inline int read(){
	int f=1,out=0;char c=getchar();
	while (c>'9'||c<'0'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		out*=10,out+=c-'0';
		c=getchar();
	}
	return f*out;
}

int main(){
	n=read();
	for(int i=1;i<=n;i++){
		int ls=read();
		if(ls%4==0){
			printf("Roy wins!\n");
		}
		else printf("October wins!\n");
	}
	return 0;
}
```


---

## 作者：Meng142857 (赞：1)

# 本蒟蒻的一篇题解
 可以先枚举一下：  
0:必败态;  
1:必胜态;  
2:必胜态;  
3:必胜态;  
4:必败态;  
5:必胜态;  
6:必胜态;  
7:必胜态;  
8:必败态;  
9:必胜态;  
10:必胜态;  
11:必胜态;  
12:必败态;  
13:必胜态;  
14:必胜态;  
15:必胜态;  
16:必败态;  
### 猜想：4k都是必败态，其他为必胜态；
 因为4k个石子一次不可能还拿成4m个，但形如4k+r的数一次拿掉r个即可变为4k个。（取走2^0个,2^1个或3^1个）  
 所以，当4|n（|为整除符号）时，Roy获胜，否则October获胜。
 AC代码如下，请勿抄袭：
```cpp
#include<iostream>
using namespace std;
int main(){
    int n,k;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>k;
        if(k%4==0) cout<<"Roy wins!";
        else cout<<"October wins!";
        cout<<endl;
    }
    return 0;
}
```
### 最后：
# $\color{red}\text{共建诚信洛谷，拒绝Ctrl+C!}$

---

## 作者：我杀文化课 (赞：1)

看了看题解都是用的数学归纳法，本蒟蒻决定写一篇SG函数题解以佐证归纳出来的规律。

什么是$SG$函数？

定义：对于一个给定的有向无环图，定义关于图的每个顶点的$Sprague-Grundy$函数$g$如下：$g(x)=mex$ {$g(y)$}。其中$y$为$x$的后继。

是不是一脸懵？没事，通俗的说：将x这个状态可以转移到的其他状态$(y)$的$g(y)$看为一个集合，$g(x)$的值就是在集合中没有出现的最小非负整数。

还是没懂？举个例子：

我现在有0颗石子，因为$g(0)$是转移不到任何其他点的，所以$g(0)=0$。

我现在有1颗石子，$g(1)$可以从0转移过来，所以集合里为{0}，所以$g(1)=1$。

我现在有2颗石子，$g(2)$可以从0,1转移过来，所以集合里为{0,1}，所以$g(2)=2$。

我现在有3颗石子，$g(3)$可以从0,1,2转移过来，所以集合里为{0,1,2}，所以$g(3)=3$。

我现在有4颗石子，$g(4)$可以从1,2,3转移过来，所以集合里为{1,2,3}，所以$g(4)=0$。

我们现在再引入一个定理：当$g(i)=0$时，先手必败。

怎么证明的？~~我也不知道~~，就连NOI金牌选手zhx大佬也不知道，我们只需要记住就好了。

那么很显然，所有可以由4转移过去的数的$SG$函数必定不为0。

所以问题就是找到所有$g(i)=0$的状态。也就是无法被0和4转移到的状态，显然，所有质数必定可以转移到0，所以所有质数是必胜状态。无法被0和4转移到的状态又哪些呢？没错，就是$4x(x\in Z)$，4的倍数，扩展下去，必胜的状态就是0和$4x(x\in Z)$们可以转移到的数（也就是它们与质数的和）。

我们可以明显发现，所有自然数都可以被此表示出来。所以没有其它的必败状态了。

即证。

那么代码就是：

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    {
        int x;
        scanf("%d",&x);
        if(x%4==0) printf("Roy wins!\n");
        else printf("October wins!\n");
    }
}
```


---


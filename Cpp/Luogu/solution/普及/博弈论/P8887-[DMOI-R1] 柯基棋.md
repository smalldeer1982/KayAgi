# [DMOI-R1] 柯基棋

## 题目背景

小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。

## 题目描述

小 A 和小 B 在一个 $n \times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。

可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \times (w+2)$，他一共会捣乱 $q$ 次。

而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。

由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。

**注意**：

1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。

2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。

由于数据过大，$x_i$ 由数据随机生成器给出。

## 说明/提示

### 随机数据生成器

每一轮游戏的 $x_i$ 由下方的生成器给出：

```cpp
unsigned long long x[10000005];
unsigned long long xor_shift(unsigned long long &seed){
  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;
}
int main(){
  //your code here
  int n,q;
  unsigned long long seed;
  cin>>n>>q>>seed;
  for(int i=1;i<=q;i++){
	x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;
  }
  //your code here
  return 0;
}
```

### 样例解释

对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。

对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。

对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。

### 数据范围

对于 $20\%$ 的数据，$n,q\leq100$。

对于 $50\%$ 的数据，$n,q\leq10000$。

对于 $100\%$ 的数据，$1 \le T \le 10,2\leq n,q,\sum q \leq 10^7$，$x_i \equiv 0 \pmod 2\ (i\in[1,q]),0 \le seed \le 10^7$。


## 样例 #1

### 输入

```
3
2 5 493
3 8 3219
8 4 1294```

### 输出

```
B won
A won
B won```

# 题解

## 作者：Vct14 (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P8887) || [更好的阅读体验](https://677609.blog.luogu.org/Solution-DMOIR1-P8887) || [更新日志](https://www.luogu.com.cn/paste/irbb91t3)

### 思路

以下用黑棋代表小 A 下的“柯基”，用白棋代表小 B 下的“柯基”。黑棋先手。

通过探索，我们可以发现以下规律：

- 当棋盘边长为奇数时，黑棋先下棋盘中心（一个交叉点），然后以棋盘的中心对称，那么白棋能下的地方，黑棋也能下，那么最后一步一定是黑棋下的，即**黑棋获胜**；

![](https://cdn.luogu.com.cn/upload/image_hosting/m8b0du1k.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hg1fgp4z.png)

- 当棋盘边长为偶数时，以棋盘的中心线对称，无论黑棋下哪里，白棋就下它的对称点，那么黑棋能下的地方，白棋也能下，那么最后一步一定是白棋下的，即**白棋获胜**。这里中心线指将棋盘对折一次形成的折痕（这么说有点奇怪，不过理解意思就行（逃））。

![](https://cdn.luogu.com.cn/upload/image_hosting/4q1uo7sx.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/kaxcxjo7.png)

由 $x_i$ 的生成器中的 `x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;` 可知 $x_i$ 为偶数，即小 C 捣乱时先后手的顺序不变。

由于捣乱时，棋盘的中心和中心线、棋盘边长的奇偶性、先后手顺序都不变，所以捣乱前和捣乱后赢家是不变的。

综上所述，

- 当棋盘的边长为奇数时，小 A 胜；
- 当棋盘的边长为偶数时，小 B 胜。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	int T;
	cin>>T;
	while(T--){
		int n,q,seed;
		cin>>n>>q>>seed;
		if(n%2) cout<<"A won";
		else cout<<"B won";
		cout<<"\n";
	}	
	return 0;
}
```

提示：

- 本题为多组测试数据。
- 虽然本题的 $q$ 和 $seed$ 没有用上，但是不要漏输入。

---

## 作者：yitian_ (赞：6)

## 题目分析

要判断两个人在一个 $n\times n$ 的棋盘中下柯基棋谁会赢。

## 思路

因为 $n$ 每次的变化为加 $2$，所以 $n$ 的奇偶性不变。

1. $n$ 为奇数时：

	小 $A$ 第一步下在棋盘中心，在之后一直下在以棋盘对称轴对称小 $B$ 下的子的位置必胜。

2. $n$ 为偶数时：

	小 $B$ 一直下在以棋盘对称轴对称小 $A$ 下的子的位置必胜。
    
所以这题就是判断 $n$ 的奇偶性。

## C++ 代码实现

```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		int n,p,s;
		cin >> n >> p >> s;
		if(n%2==0) 
		{
			cout << "B won" << endl;
		} 
		else cout << "A won" << endl;
	}
	return 0;
}
```

---

## 作者：alex_liu (赞：5)

[DMOI-R1] 官方题解

## 思路：

首先先思考静态的棋盘，考虑到任意两只横坐标或纵坐标相同的“柯基”无法互相干扰，于是可以想到以棋盘对称轴下对称点的最优策略。

继续考虑动态的棋盘，由于每次棋盘的边长都增加 $2$，所以说本质上棋盘边长的奇偶性不变。又因为每次更改时的步数都为偶数，所以不影响先后手的顺序。


---

## 作者：Melo_DDD (赞：3)

看到是博弈论，就赶紧做一下。

# 题目大意

如果有一个人放不了棋子，他就输了。

那个捣乱的人咱们一会说。

# 题目实现

**看到是棋盘，就一定要想到中心点（也就是它的对称中心）。**

然后就顺理成章地想出了分类讨论：

- 情况一：棋盘边长为奇数，此时它的中心点在格点上（也就是说可以把棋下到它的中心点上）。

- 否则是偶数，反之。

先不考虑捣乱的，两种情况讨论：

- 对于第一种，咱们把棋盘当成**中心对称图形**，那么先手只要先下中心点，之后下在后手所下点的中心对称点上，就能够保证他下的最后一步，先手赢；

- 第二种，把棋盘当成**轴对称图形**，那么无论先手下在哪里，后手只要下在先手下的点关于对称轴对称的点上，那么他一定下了最后一步，后手赢。

### 然后说说那个捣乱的：

可以发现即使他扩大了棋盘，边长的奇偶性、中心点、对称轴以及两个人的下棋顺序都不变，变的只是下了多少步而已，所以这个捣乱的根本不用管。

## 代码：

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define IOS ios :: sync_with_stdio(0) ;cin.tie (0) ;cout.tie (0)
using namespace std ;
int t ;
int main () {
	IOS ;
	cin >> t ;
	while (t --) {
		int n ,q ,s ;
		cin >> n >> q >> s ;
		if (n & 1) { // 相当于 n % 2
			cout << "A won" << '\n' ;
			goto kafka ; // 卡妈\se\se
		} 
		cout << "B won" << '\n' ;
		kafka : ;
	}
	return 0 ;
}
```

---

## 作者：laijuncheng (赞：1)

「本蒟蒻的第二篇题解」
## 思路
先不管捣乱的小 C。

这道题考虑**分类讨论**。
- **当 $n$ 为奇数时：**

小 A 按照最优策略肯定会先下正中心，

随后小 B 下一步，小 A 只需要下和小 B 下的这一步沿正中心对称的地方即可。

最后小 B 没地方下了，小 A 胜。
- **当 $n$ 为偶数时：**

小 A 第一步没有正中心可以下了，

小 A 只能随便下一步，由于 $n$ 为偶数，小 B 只需要下和小 A 下的这一步沿中心轴对称的地方即可。

最后小 A 没地方下了，小 B 胜。

现在再回头看看小 C 对这个结论有没有影响。

小 C 会把当前 $n$ 行 $n$ 列的棋盘扩大为 $n+2$ 行 $n+2$ 列的棋盘，但这个过程中 $n$ 的奇偶性不变，所以小 C 对这个结论有没有影响。
## c++代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
	cin>>T;
	while(T--)
	{
		int n,q,seed;
		cin>>n>>q>>seed;
		if(n%2==1) cout<<"A won\n";//n为奇数时输出小A赢
		else cout<<"B won\n";//n为偶数时输出小B赢
	}	
	return 0;
}
```

---

## 作者：GoodLuckCat (赞：1)

[P8887](https://www.luogu.com.cn/problem/P8887) 是一道有趣的题。

>当一个人不能再放下一只“柯基”时，他就输了。

这句话让我们联想到了一道题：

>在一个圆桌上放硬币，不能重叠，不能放到外面，谁放不下了谁输。

我们可以思考到，有没有一种方法，使得如果对方能放下，自己也能放下呢？

这种方法是有的，但是只有当你是先手时才能用。

这种方法就是：先将第一枚硬币放在圆桌的正中间，然后将硬币放在 **对方的硬币的中心对称点**。

注意到一只柯基的形状是这样的：

```
○   ○
  ●
○   ○
```

~~好丑啊~~

黑色表示棋子本身，而白色表示柯基占领的地盘。

考虑两只柯基放在一起：

```
①   ①
② ❶ ②
① ❷ ①
②   ②
```

它们是互不干扰的。所以上面这种方法是有效的。

**但是，请注意，它只适用于棋盘边长为奇数的情况。**

所以？

所以要分情况考虑。

刚才我们已经解决了棋盘边长为奇数的情况，结论为先手必胜。接下来我们讨论棋盘边长为偶数的情况。

注意到棋盘边长为偶数，我们可以把它分成上下两边考虑。

如果对方下上面，你就下下面，如果对方下下面，你就下上面，这是我们第一次想到的思路。

那怎样将上下的每一个点“一一对应”呢？借助刚才的思考方式，可以想到对称。**不过这次不是中心对称，而是轴对称。**

对称轴就是那条连接棋盘左边中点与右边中点的一条线。

所以可以看出，后手的每一步取决于先手的每一步，到某个时候，先手肯定放不了。所以结论为后手必胜。结论就出来了：

>棋盘边长为奇数，先手（小 A）必胜；棋盘边长为偶数，后手（小 B）必胜。

有人会说：那小 C 还在扩大棋盘呢！

我们 ~~忽略这句话~~ 看到下方的数据生成器。其中 $x_i$ 由以下方式生成：

```cpp
x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;
```

因为一开始 $x_0=0$，而后面每一项加上去的都是个偶数，所以 $x$ 每一项都为偶数。即小 A 仍然先手，结论不变。

其实数据范围里有说：

>$x_i \equiv 0 \pmod 2\ (i\in[1,q])$。

所以 $x$ 的每一项都是偶数。~~看这多简单，还要去分析（）~~

而小 C 每次都让棋盘扩大偶数，所以棋盘的边长奇偶性不变。经过一大堆思考，最后看一眼题面：第一行一个正整数 $T$，表示 $T$ 组数据。

所以，注意多组数据。代码终于出来了（注意要换行！！！）：

```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,q,s;
        cin>>n>>q>>s;
        if(n%2)cout<<'A';
        else cout<<'B';
        cout<<" won\n";
    }
}
```

---


# 「MYOI-R3」极差

## 题目描述

对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。

## 说明/提示

### 样例 $\small\text{1}$ 解释

样例符合子任务 1 的约束，$id=1$。


询问一：

可以证明，没有任何方案满足条件。

询问二：

合法分配的一种子序列集合如下：
- $\{1,9\}$。
- $\{1,9\}$。
- $\{8,1,0\}$。

答案不唯一。

### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 1（20 points）：$4\le \sum n\le 20,a_i\ge 0$。
- Subtask 2（20 points）：$4\le \sum n\le 100,a_i\ge 0$。
- Subtask 3（20 points）：$4\le \sum n\le 10^3,a_i\ge 0$。
- Subtask 4（10 points）：$a$ 数组中元素相等。
- Subtask 5（30 points）：无特殊限制。


对于 $100\%$ 的数据，$4\le \sum n\le 10^6,0\le |a_i|\le 10^9,1\le T\le 300$。


## 样例 #1

### 输入

```
2 1
6
1 1 4 5 1 4
7
1 9 1 9 8 1 0```

### 输出

```
No
Yes```

# 题解

## 作者：wrh316 (赞：20)

先对数组 $a$ 从小到大排序，排序后 $a _ {1}$ 一定是极小值，而 $a _ {n}$ 一定是最大值。

如果能找到两个数 $a _ {x}$ 和 $a _ {y}$ 使得 $a _ {x}$ 减去  $a _ {1}$ 和  $a _ {n}$ 减去  $a _ {y}$ 相等并且 $y$ 比 $x$ 要小的话，就一定可以将整个序列分成两半。

我们可以想到：$a _ {x}$ 减去  $a _ {1}$ 和  $a _ {n}$ 减去  $a _ {y}$ 相等就是  $a _ {x}$ 加上  $a _ {y}$ 和  $a _ {1}$ 加上  $a _ {n}$ 相等，所以枚举 $y$，二分查找是否能找到对应的 $x$，就完成了。

上代码：
```
#include <bits/stdc++.h>
using namespace std;

int t,id,n,ans;
int a[1000005];
bool f;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t>>id;
	while(t--){
		cin>>n;
		for(int i = 1;i <= n;i++) cin>>a[i];
		sort(a + 1,a + n + 1);
		ans = a[1] + a[n];
		f = false;
		for(int i = 2;i <= n - 1;i++){
			bool vis = binary_search(a + i + 1,a + n,ans - a[i]);
			if(vis){
				cout<<"Yes\n";
				f = true;
				break;
			}
		}
		if(!f) cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：12)

## 思路

因为极值，所以先对数组从小到大排序。

注意到排序后这个数组的第一个数 $a_1$ 和最后一个数 $a_n$ 一定是极小值和最大值。

所以一定要找到两个数 $a_x$ 和 $a_y$ 使得 $a_x-a_1=a_n-a_y$，且 $y< x$。

如果能找到就一定可以将整个序列分成**两半**，反之，亦然。

直接做时间复杂度 $O(n^2)$。

## 优化
$a_x-a_1=a_n-a_y$ 就是 $a_x+a_y=a_1+a_n$。

所以枚举 $y$，二分查找是否能找到对应的 $x$，就完成了。

## code
```cpp
cin>>t>>id;
while(t--)
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	int sum=a[1]+a[n];
	bool p=false;
	for(int i=2;i<=n-1;i++)
	{
		bool fd=binary_search(a+i+1,a+n,sum-a[i]);
		if(fd) 
		{
			cout<<"Yes"<<endl;
			p=true;
			break;
		}
	}
	if(!p) cout<<"No"<<endl;
}
```

时间复杂度 $O(n\log n)$。

---

## 作者：SafariMo (赞：10)

首先注意到将 $a$ 拆分成 $2$ 个子序列显然比拆分成多于 $2$ 个是要更优的，因为可以把子序列合并成两个。

然后我们发现，序列中的最大值和最小值一定会影响极差。

分类讨论一下：
- 最大值和最小值在同一子序列中，则必须满足另一个子序列也同时包含最大值和最小值，也就是说最大值和最小值出现次数都超过两次。
- 最大值和最小值不在同一子序列中，并假设最大值在第一个子序列中，设第一个子序列的最小值为 $p$，第二个子序列的最大值为 $q$。则有 $\max- \ p=q-\min$，移项后得 $\max+\min=p+q$，并有构造方式如下：将 $\ge q$ 的数全部放入第一个子序列，$\le p$ 的数放入第二个子序列，剩下的随便放，因此只需确定 $p,q$ 就满足条件。

发现两种情况都可以转换为 $\max+\min=p+q$，直接用桶实现即可。

---

## 作者：wanglexi (赞：5)

[题目。](https://www.luogu.com.cn/problem/P10444)

### 题意简述

给出一个长为 $n$ 的序列 $a$，问能否把这个序列分成至少两个长度至少是二的子序列，让各个子序列最大值与最小值的差相等。

### 思路

注：以下 $[]$ 表示闭区间集合。

设可以满足题目要求把序列分成 $k(k\ge2)$ 个子序列，其中第 $i(1\le i \le k)$ 个子序列最小值是 $l_i$，最大值是 $r_i$，且 $l_1=\min\{a\},r_k=\max\{a\}$。

根据题意，每个 $r_i-l_i$ 都相等。因此，当然有 $r_1-l_1=r_k-l_k$。

如果 $r_1\ge l_k$，那么 $[l_1,r_1]\cup[l_k,r_k]=[l_1,r_k]$ 就是 $a$ 的值域，所以只要把 $a$ 分成两个子序列，其中一个放 $l_1,r_1$ 和一些 $[l_1,r_1]$ 区间内的元素，另一个放 $l_k,r_k$ 和一些 $[l_k,r_k]$ 区间内的元素（两区间的交集的元素放哪个都可以）。

![](https://cdn.luogu.com.cn/upload/image_hosting/r0092998.png)

---
反之，$r_1< l_k$，那么 $[l_1,l_k]\cup[r_1,r_k]=[l_1,r_k]$ 是 $a$ 的值域，同时移项可得 $l_k-l_1=r_k-r_1$，所以只要把 $a$ 分成两个子序列，其中一个放 $l_1,l_1$ 和一些 $[l_1,l_1]$ 区间内的元素，另一个放 $r_1,r_k$ 和一些 $[r_1,r_k]$ 区间内的元素（两区间的交集的元素放哪个都可以）。

![](https://cdn.luogu.com.cn/upload/image_hosting/7g0f4vjo.png)

---

所以，只要存在四个不同正整数 $x,y(1\le x,y \le n)$ 满足 $a_x-a_1=a_n-a_y$，则一定可以满足条件。

移项得到 $a_1+a_n=a_x+a_y$。

据此写代码就可以了。

### 代码

map 记录一下每个数的出现次数就可以。

注意特判 $a_x=a_y$ 时 $a_x$ 的个数要至少要为 $2$。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t,id,n,a[1000005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t>>id;
	if(id==4){
		while(t--){
			cin>>n;
			for(int i=1;i<=n;i++)cin>>a[i];
			if(n<4)cout<<"No\n";
			else cout<<"Yes\n";
		}
		return 0;
	}
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		sort(a+1,a+n+1);
		if(n<4){
		    cout<<"No\n";
		    break;
		}
		int flag=0;
		map<int,int>mp;
		for(int i=2;i<=n-1;i++)mp[a[i]]=mp[a[i]]+1;
		for(int i=2;i<=n-1;i++){
			if(mp[a[1]+a[n]-a[i]]>=2||(a[1]+a[n]!=a[i]+a[i]&&mp[a[1]+a[n]-a[i]]>=1)){
				flag=1;
				break;
			}
		}
		if(flag==0)cout<<"No\n";
		else cout<<"Yes\n";
	}
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：3)

首先发现拆分成两个序列显然比更多的序列优。

显然如果最大的数和最小的数都在同一个序列，那么两个数都需要有两个。

如果最大的数和最小的数不在同一个序列，那么最小的数和最大的数显然可以掩盖掉别的数。也就是说除了一个最小的数和一个最大的数，其他任意的数都能当序列最大值或者最小值。

显然两个方案都能推出来当将 $a$ 从小到大排序时，存在两个数 $i\in[2,n-2]$ 和 $j\in[i+1,n-1]$ 满足 $a_j-a_1=a_n-a_i$ 时可以，否则不可以。

然后从前后同时扫一下即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,id,a[1000001];
int main(){
	cin>>t>>id;
	while(t--){
		cin>>n;
		bool bo=1;
		for(int i=1;i<=n;i++)cin>>a[i];
		if(n<4)cout<<"No\n";
		else{
		    sort(a+1,a+n+1);
		    int l=2,r=n-1;
		    while(1){
		    	if(l==r){
		    		cout<<"No\n";break;
		    	}
		    	else if((a[l]-a[1])==(a[n]-a[r])){
	       			cout<<"Yes\n";break;
		    	}
		    	else if((a[l]-a[1])<(a[n]-a[r]))l++;
		    	else r--;
		    }
		} 
	}
	return 0;
}
```

---

## 作者：CaiZi (赞：3)

## 「MYOI-R3」极差 题解
**[题目链接](https://www.luogu.com.cn/problem/P10444)**
### 题目分析
首先，若我们分成了两个以上的子序列，则可以将这些子序列合并成两个，故只需要考虑分成两个子序列的情况。

然后我们需要对 $c$ 进行排序，排序后我们找到任意一组满足 $i<j$ 且 $c_j-c_1=c_n-c_i$ 的 $i,j$。找到后，我们可以将 $a_i\sim a_n$ 中除了 $a_j$ 外全部放入第二组，$a_1\sim a_{i-1}$ 和 $a_j$ 放入第一组，显然这总是可以成功的。

我们枚举 $i$，再二分查找判断 $j$ 是否存在，一旦存在答案即为 ```Yes```，反之为 ```No```。
### 代码展示
时间复杂度 $O(\sum n\log n)$，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,id,n,a[1000001];
bool f;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>t>>id;
	while(t--){
		f=false;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		stable_sort(a+1,a+n+1);
		for(int i=2;i<=n-1;i++){
			if(binary_search(a+i+1,a+n,a[1]+a[n]-a[i])){
				f=true;
				break;
			}
		}
		if(f){
			cout<<"Yes\n";
		}
		else{
			cout<<"No\n";
		}
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/158842415)**

---

## 作者：MicroSun (赞：2)

很明显所有划分为多于两个子序列的方法都可以合并为两个子序列。

因为是选出子序列，所以数列顺序不影响结果，考虑排序数组将问题简化。

对于每一个序列，显然只有最大值和最小值是重要的，其他的值可以随便分配。设两个子序列的最大值和最小值分别为 $i,j,k,l$，因为要覆盖整个序列，所以则这四个数一定满足

$$

i=1,l=n,k\in[i,j+1]

$$

又因为极差相等，所以

$$

a_j-a_i=a_k-a_l

$$

带入得

$$

a_j-a_1=a_n-a_k

$$

这里有 $a_j$ 和 $a_k$ 两个变量。考虑遍历数组，对于每个 $a_j$，找出合法的 $a_k$。

如何找出合法的 $a_k$？观察上面的柿子，略微变形可得：

$$

a_k=a_n-a_j+a_1

$$

前面已经将数组排序，显然这个 $a_k$ 可以用二分判断是否存在。

时间复杂度 $\Omicron(n\log n)$。

Code:

```cpp
// Problem: T425609 「MYOI-R3」极差
// LuoguUID: 514700 
// LuoguUserName: MicroSun
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define pb push_back
#define fst first
#define scd second
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define dep(i,s,e) for(int i=s;i>=e;i--)

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;

const int maxn=2e5+10;

ll a[maxn];
void solve(int id){
	int n;
	cin>>n;
	rep(i,1,n) cin>>a[i];
	sort(a+1,a+1+n);
	if(n<4){
		cout<<"No\n";
		return;
	}
	if(id==4){
		cout<<"Yes\n";
		return;
	}
	rep(i,2,n-1){
      // i 即为文中的 j
		int c=a[i]-a[1];
		int k=lower_bound(a+1,a+1+n,a[n]-a[i]+a[1])-a;
		if(a[n]-a[k]==c&&k!=n&&k!=i&&k!=1){
			cout<<"Yes\n";
			return;
		}
	}
	cout<<"No"<<endl;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t=1,id;
	cin>>t>>id;
	while(t--) solve(id);
    return 0;
}
```

---

## 作者：Nostopathy (赞：1)

# Solution

因为求极差，所以可以先给序列 $a$ 排序，排序后的 $a_1$ 和 $a_n$ 就是它的极小和极大值。

找到两个数 $a_x$ 和 $a_y$ 使得 $a_x - a_1 = a_n - a_y$，前提是 $y$ 小于 $x$。可以找到，就可以将序列折半。

其实可以优化：$a_x - a_1 = a_n - a_y$ 可以转化为 $a_x + a_y = a_1 + a_n$，所以可以枚举 $y$ 二分查找是否可以找到对应的 $x$ 就完成啦。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000003];
int main(){
	int T,id;
	cin>>T>>id;
	while(T--){
		int n;
		cin>>n;
		for(int i=1;i<=n;++i)cin>>a[i];
		sort(a+1,a+1+n);
		int s=a[1]+a[n],state=0;
		for(int i=2;i<n;++i){
			if(binary_search(a+i+1,a+n,s-a[i])){
				puts("Yes");
				state=1;
				break;
			}
		}
		if(!state)puts("No");
	}
}
```

谢谢观看。

---

## 作者：Ravener (赞：1)

题目与极值有关，所以要排序。  
因为需要考虑的情况越少越好，所以可以直接讨论序列能否一分为二。  
设序列 $c$ 的最大值为 $c_{max}$，最小值为 $c_{min}$。

------------

### 一、证明：

①若 $c_{max}$ 与 $c_{min}$ 在同一子序列中，则 $c_{max}$ 与 $c_{min}$ 在序列中出现的次数应不小于 $2$。  
很好理解，因为 $c_{max}-c_{min}$ 就是序列的极差，如果 $c_{max}$ 与 $c_{min}$ 中任何一个出现的次数为 $1$，那么另一个子序列的极差无论如何将小于同时包含 $c_{max}$ 与 $c_{min}$ 的子序列。

②若 $c_{max}$ 与 $c_{min}$ 不在同一子序列中，则必须在序列中找到 $c_{max}>a \ge b>c_{min}$，使 $a+b= c_{max}+c_{min}$（若 $a=b$ 还需判断 $a$ 与 $b$ 出现的次数不小于 $2$），否则分不了。   
那么 $a,b$ 可以分别作为包含 $c_{max}$ 的序列最小值和包含 $c_{min}$ 的序列中的最大值，即可将序列分成两半。  

------------

### 二、暴力（30 pts）

首先判断 $n$ 是否小于 $4$，因为子序列长度要大于 $1$，当 $n<4$ 时明显不符合要求；  
然后判断①的情况，若满足直接输出；  
接着判断②的情况，若满足直接输出；  
最后一定是不满足的情况。  
肯定会 TLE。  

------------

### 三、二分

判断②的情况时，可以枚举 $b$，二分查找 $a$。  
时间复杂度 $O(n \log n)$。  
代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int t,n,k;
int a[1000005];
bool bi-sort(int num[],int left,int right,int t)
{
	int l=left+1,r=right;
	while(l<=r)
	{
		int mid=l+((r-l)/2);
		if(num[mid]>t)
			r=mid-1;
		else if(num[mid]<t)
			l=mid+1;
		else return true;
	}
	return false;
}
main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t>>k;
	while(t--)
	{
		memset(a,0,sizeof(a));
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		if(n<4)
			cout<<"No\n";
		else if(k==4)
			cout<<"Yes\n";
		else
		{
			sort(a+1,a+1+n);
			if(a[1]==a[2]&&a[n]==a[n-1])
				cout<<"Yes\n";
			else
			{
				int sum=a[1]+a[n];
				bool ck=1;
				for(int i=2;i<n;i++)
				{
					bool ok=bisort(a,i,n-1,sum-a[i]);
					if(ok)
					{
						cout<<"Yes\n";
						ck=0;
						break;
					}
				}
				if(ck) cout<<"No\n";
			}
		}
	}
}
```
[AC 记录](https://www.luogu.com.cn/record/158859586)。  
（tj 仅供参考，如有问题请 at 我并指正）  
~~（知道了知道了，知道有 ``binary_search`` 这玩意了）~~

---

## 作者：lilong (赞：0)

首先有一个显然的结论，即若可以分成超过 $2$ 个序列，则一定可以分成 $2$ 个序列。如样例中的第二组数据，可以直接分成 $\{1,1,1,9 \}$ 和 $\{8,0\}$。严谨证明留给读者思考。

有了上面这个结论后，就转化为判断是否能够分成两个序列。注意到极差**只与最大值与最小值有关**，因此**全局最大值和最小值**是一定会影响极差的。换句话说，极差的其中一个变量已经确定下来了，就可以通过枚举另一个变量来确定这个极差了。

记全局最小值为 $\min$，最大值为 $\max$。我们考虑最小值所在序列的情况。假设该序列的最大值为 $x$，则极差 $c=x-\min$，最大值所在序列的最小值为 $\max-c = \max - x + \min$。枚举每一个 $a_i$ 作为 $x$，判断所求得的值是否在 $a$ 中即可。

有一种情况需要特别注意，即 $x$ 和求出的值相等，此时需要特判是否出现至少 $2$ 次。另外，$\min$ 与 $\max$ 用来求极差时要特殊处理，具体见代码。

由于使用了 map 记录出现次数，因此总时间复杂度为 $O(Tn\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
int n,m,a[1000001],flag,mi,mx;
map<int,int> mp;

signed main()
{
    int T,id;
    cin >> T >> id;
    while( T -- )
    {
        flag = 0;
        mp.clear();
        cin >> n;
        cin >> a[1],mp[a[1]] ++;
        mi = mx = a[1];
        for( int i = 2 ; i <= n ; i ++ )
            cin >> a[i],mp[a[i]] ++,mx = max( mx , a[i] ),mi = min( mi , a[i] );
        for( int i = 1 ; i <= n ; i ++ )
            if( mp[mx - a[i] + mi] && a[i] != mi && a[i] != mx )
            {
                if( a[i] == mx - a[i] + mi && mp[a[i]] == 1 ) continue;
                flag = 1;
                break;
            }
        if( mp[mi] > 1 && mp[mx] > 1 )
            flag = 1;
        if( flag ) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
```

---

## 作者：xzz_0611 (赞：0)

[题目传送门](/problem/P10444)
## 思路
对于任意的一个序列，它的答案只有两种可能，`Yes` 和 `No`，这里分开讨论：
- `Yes`：此时，这个序列必定能分成若干个子序列使得这些子序列的极差相等，那么，它也必然能分成两个子序列使得这两个子序列极差相等。
- `No`：此时，这个序列肯定无法分成两个子序列使得这两个子序列极差相等。

综上所述，可以发现，只要能分成两个极差相等的子序列的话，答案就为 `Yes`，反之为 `No`。

设序列 $a$ 中的最大值为 $\max$，最小值为 $\min$，有以下两种情况：
- $\max$ 与 $\min$ 都在 $a$ 中出现过多次：将一组 $\max$ 与 $\min$ 放在第一个序列里，再将另外一组 $\max$ 与 $\min$ 放在第二个序列里，再将其余的元素随意摆放，此时极差相等。
- $\max$ 与 $\min$ 在 $a$ 中都只出现过 $1$ 次：将 $\max$ 放在第一个序列里，$\min$ 放在第二个序列里，设第一个序列的最小值为 $x$，第二个序列的最大值为 $y$，可以得出等式：$\max-x=y-\min$，移项后得到：$\max+\min=x+y$。

可以发现，以上两种情况都可以用等式 $\max+\min=x+y$（第一种情况为 $\max-\min=\max-\min$，用 $x$ 和 $y$ 代替其中一个 $\max$ 和一个 $\min$ 后可以得到 $\max+\min=x+y$）来表示，再通过这个等式得到 $\max+\min-x=y$，所以，对于任意的一个 $i$，只要能找到一个 $j$ ，使得 $\max+\min-a_i=a_j$，且 $i,j$ 均不与 $\max$ 和 $\min$ 的下标相等的话，答案就为 `Yes`。

显然，直接套两层 `for` 循环时间复杂度为 $\mathcal{O}(\sum n^2)$，会 TLE，实际上此题可以考虑使用二分法。首先对 $a$ 进行升序排序，此时的 $\max$ 就是 $a_n$，$\min$ 就是 $a_1$。此时对于任意一个 $i$，使用二分法判断 $a$ 中是否出现了值为 $\max+\min-a_i$ 的元素，如果出现了，且它所在的下标不为 $1$、$n$ 和 $i$ 中的任意一个时，答案就为 `Yes`。需要注意的是，如果这个下标等于了 $i$，还要额外判断 $a_{i-1}$ 和 $a_{i+1}$ 是否等于 $\max+\min-a_i$，不过要保证 $i-1$ 和 $i+1$ 不与 $1$ 或 $n$ 相等。
## Code
时间复杂度 $\mathcal{O}(\sum n\log n)$。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int t,id,n,arr[1000000];//个人习惯用arr
bool judment(int l,int m,int r,int i,int sum) {//二分法判断这个值是否存在
    if(l>r) return false;
	if(arr[m]>sum) return judment(l,(l+m)/2,m-1,i,sum);
	else if(arr[m]<sum) return judment(m+1,(m+r+2)/2,r,i,sum);
	else if(m!=i) return true;//下标不能相等
	else if((m>1&&arr[m-1]==sum)||(m<n-2&&arr[m+1]==sum)) return true;//额外的判断
	return false;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	bool flag;
	cin>>t>>id;
	while(t--) {
		cin>>n;
		for(int i=0;i<n;++i) cin>>arr[i];
		sort(arr,arr+n);
		flag=false;//判断答案是Yes还是No，Yes为true，No为false，初始要赋为false
		for(int i=1;i<n-1;++i)
			if(judment(1,(n-1)/2,n-2,i,arr[0]+arr[n-1]-arr[i])) {//判断arr中是否存在该元素
				flag=true;//如果答案为Yes则将其该为true
				break;
			}
		if(flag) cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---


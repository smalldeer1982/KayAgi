# [蓝桥杯 2024 国 Java A] 修改数位

## 题目描述

给定一个 $n$ 位的没有前导零的十进制数 $m$，你可以将其任意位 $a_i$ 改为任意其它数字 $b_i$，花费为 $|b_i - a_i|$。我们希望通过最少的花费使得修改后的数中存在连续的 $10$ 位，包含了从 $0$ 到 $9$ 的所有数字，且每个数字恰好出现一次。

请输出最少需要的花费是多少（修改后也要求没有前导零）。

## 说明/提示

### 样例说明

将右边第 $3$ 位改为 $2$ 是一种方案，此时后 $10$ 位恰好含有 $0 \sim 9$ 各一个。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$10 \leq n \leq 500$；
- 对于 $60\%$ 的评测用例，$10 \leq n \leq 5000$；
- 对于所有评测用例，$10 \leq n \leq 10^6$，请注意 $n$ 表示数位个数。

## 样例 #1

### 输入

```
123456789301```

### 输出

```
1```

# 题解

## 作者：Ryan_X (赞：4)

## 简述题意
给定一个字符串，要通过修改操作让字符串中至少出现一段长度为十且**恰好**包含 $0$ 到 $9$ 所有数字的子段，求最小花费。

## 大致思路
我们可以**枚举**每一个长度为十的子段，再对于当前子段**求出最小花费**，最后统计出所有子段中最小的花费。

### 枚举子段
我们可以用**单调队列**来枚举，每次把过期的队头弹出，把当前数位压入队尾，**维护**一个数组来记录**当前**队列中**所有数值出现的次数**。
### 求子段最小花费
每次检查队列元素个数，如果大于等于 $10$ 个，则需要求最小花费。**从小到大**遍历每一个数值，分别用两个数组存储缺少的数值和多出的数值。不难发现，这两个数组的**大小是一样**的。所以可以使用**贪心的思想**，把多出的小数值修改为缺少的小数值，把多出的大数值修改为缺少的大数值，这样一定就是最小的花费。如果当前子段的最小花费小于当前记录的最小花费，则更新我们的最小花费。

最后输出最小花费即可。

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int num[100],s[20],d[20];
deque<int>q;
int main(){
	string n;
	cin>>n;
	int siz = n.size();
	n = " "+n;
	long long ans = LONG_LONG_MAX;
	for(int i = 1;i<=siz;i++){
		while(!q.empty() && q.front()+10-1<i){
			num[n[q.front()]-'0']--;
			q.pop_front();
		}
		q.push_back(i);
		num[n[i]-'0']++;
		if(i>=10){
			int tot = 0;
			memset(d,0,sizeof(d));
			memset(s,0,sizeof(s));
			for(int j = 0;j<=9;j++){
				if(num[j]>1){
					for(int k = 1;k<=num[j]-1;k++)d[++tot] = j;
				}
			}
			tot = 0;
			for(int j = 0;j<=9;j++){
				if(num[j] == 0){
					s[++tot]+=j;
				}
			}
			long long sum = 0;
			for(int j = 1;j<=tot;j++)sum+=abs(d[j]-s[j]);
			ans = min(ans,sum);			
		}
	}
	cout<<ans;
	return 0;
}
```

**完结撒花~~**

---

## 作者：Aurelia_Veil (赞：3)

# 题解：P12289 \[蓝桥杯 2024 国 Java A] 修改数位

不得不说，这就是一道类似滑动窗口的贪心题。

首先，我们要知道，如果在一个长度为 $10$ 的一个窗口中，缺少的数字和多余的数字的个数是一样的，举个例子：

```
1 3 4 6 6 7 8 9 0 8
```

在这个区间中，缺少的数是 `2` 和 `5`，而多余的数是 `6` 和 `8`，正好数量相等。

所以，我们可以使用 $cnt_i$ 来存储这个区间中 $i$ 这个数字的出现次数，于是缺少的数字的 $cnt_i = 0$，而多余的数字的 $cnt_i > 2$。

我们还要知道，不管你用那个多余的数字变成缺少的数字，最终结果都是一样的，因为差值和不变。

所以只需要顺序统计在 $n$ 中连续出现的所有长度为 $10$ 的区间的答案的最小值即可。

代码如下咩：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+101;
string a;
int t[N];
int cnt[31];
int main(){
	cin>>a;
	int n=a.length();
	if(n<10){
		printf("0");
		return 0;
	}
	for(int i=0;i<n;i++){
		t[i+1]=a[i]-'0';
	}
	int sum=0;
	int ans=0x3f3f3f3f;
	for(int i=1;i<=10;i++){
		if(cnt[t[i]]==0){
			sum++;
		}
		cnt[t[i]]++;
	}
	for(int i=1;i+9<=n;i++){
		if(sum==10){
			printf("0");
			return 0;
		}
		queue<int>ms;
		queue<int>m_;
		for(int j=0;j<=9;j++){
			if(cnt[j]>1){
				for(int k=1;k<cnt[j];k++){
					ms.push(j);
				}
			}
			if(cnt[j]==0){
				m_.push(j);
			}
		}
		int nowsum=0;
		while(!ms.empty()){
			nowsum+=abs(ms.front()-m_.front());
			ms.pop();
			m_.pop();
		}
		ans=min(nowsum,ans);
		cnt[t[i]]--;
		cnt[t[i+10]]++;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Loyal_Soldier (赞：3)

### 思路

思路很明显，把所有连续的 $10$ 个数的区间修改成符合题目要求最小的花费都算出来，取最小值。

那么怎么计算一个区间修改成符合题目要求的最小花费呢？把区间中多余的和缺少的数分别加入两个数组，由于多余的数和缺少的数数量一定一样，最小花费即为两个数组每个数一一对应后的差值之和（按任意顺序对应的差值之和都一样，可以随便对应）。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int N = 11;
string s;
int a[N], b[N], ans = LLONG_MAX;
bool vis[N];
signed main()
{
	cin >> s;
	for(int i = 0;i + 9 < s.size();i ++)
	{
		memset(a, 0, sizeof(a));
		memset(b, 0, sizeof(b));
		memset(vis, 0, sizeof(vis));
		int tot = 0;
		for(int j = i;j < i + 10;j ++)
		{
			if(vis[(s[j] - '0')]) a[++ tot] = s[j] - '0';
			else vis[(s[j] - '0')] = true;
		}//将多余的数将入 a 数组
		tot = 0;
		for(int j = 0;j <= 9;j ++)
			if(vis[j] == 0) b[++ tot] = j;//将缺少的数加入 b 数组
		int sum = 0;
		for(int j = 1;j <= tot;j ++) sum += abs(a[j] - b[j]);//计算最小花费
		ans = min(ans, sum);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Bill_luogu (赞：2)

## 简化题目：
给一个数 $m$，求每连续的 $10$ 个数位把这 $10$ 个数位修改为包含了从 $0$ 到 $9$ 的所有数字，且每个数字恰好出现一次的 $10$ 个数位，求最小花费。
## 题目思路：
枚举每一组 $10$ 个数位，找出 $10$ 个数位中少的和多的数，计算花费并求最小值。
## AC Code：
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
long long ans=1e18,sum;
string s;
int a[1000010];
bool v[10];
long long less1[10],more1[10],cnt; 
int main()
{
	cin>>s;
    for(int i=1;i<=s.size();i++)
        a[i]=s[i-1]-'0';
	for(int i=1;i+9<=s.size();i++)
	{
		for(int j=0;j<=9;j++)
            less1[j]=more1[j]=0,v[j]=0;
        cnt=sum=0;
        for(int j=i;j<=i+9;j++)
        {
            if(v[a[j]])
                more1[++cnt]=a[j];//统计多出来的数
            else
                v[a[j]]=1;
        }
        cnt=0;
        for(int j=0;j<=9;j++)
        {
            if(!v[j])
                less1[++cnt]=j;//统计少的数
        }
        for(int j=1;j<=cnt;j++)
            sum+=abs(more1[j]-less1[j]);//求和
        ans=min(ans,sum);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ziyaojia (赞：1)

这题可以用一种类似滑动窗口的方式来解决。

### 首先：

我们先预处理一下输入的数字，把他存到一个数组里。

#### 代码：

```cpp
for(int i = 0;i < s.size();++i)
    a[i + 1] = s[i] - '0';
```

### 接着：

我们枚举每个长度为 10 的区间左端点，将这个区间里的数都放到一个桶里面，把每个多的或少的放进两个 vector 里存储。

#### 核心代码：

```cpp
int v[10] = {0},sum = 0;//0~9出现的个数和最后的花费
vector<int>m;//多的数字
vector<int>f;//少的数字
for(int i = l;i <= l + 9;++i)
    ++v[a[i]];
for(int i = 0;i <= 9;++i)
    if(v[i] > 1)
        for(int j = 1;j <= v[i] - 1;++j)
            m.push_back(i);
    else if(v[i] == 0)
        f.push_back(i);
```

### 然后：

我们用一个变量来存储最后的值，接着计算要使这个区间变为包含了从 0 到 9 的所有数字的区间索要的花费。

#### 代码：

```cpp
for(int i = 0;i < m.size();++i)
    sum += abs(m[i] - f[i]);
```

### 最后：

我们用一个变量存储答案，接着和本次得到的值取最小值，最后输出答案就好了。

### [AC](https://www.luogu.com.cn/record/231048634) Code:

```cpp line-numbers
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+1;
string s;
int a[N],n,ans = INT_MAX;
int main()
{
    ios::sync_with_stdio(NULL);
    cin.tie(NULL);cout.tie(NULL);
    cin >> s;
    n = s.size();
    for(int i = 0;i < n;++i)
        a[i+1] = s[i] - '0';
    for(int l = 1;l <= n - 9;++l)
    {
        int v[10] = {0},sum = 0;//0~9出现的个数和最后的花费
        vector<int>m;//多的数字
        vector<int>f;//少的数字
        for(int i = l;i <= l + 9;++i)
            ++v[a[i]];
        for(int i = 0;i <= 9;++i)
            if(v[i] > 1)
                for(int j = 1;j <= v[i] - 1;++j)
                    m.push_back(i);
            else if(v[i] == 0)
                f.push_back(i);
        for(int i = 0;i < m.size();++i)
            sum += abs(m[i] - f[i]);
        ans = min(ans,sum);
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Objective (赞：1)

$\mathbf{upd\ 2025/6/13}$：~~减少了一些废话~~，精简了文章内容。

# 思路与算法
## 题目大意
题目要求我们找到一个长度为 $10$ 的子串，使得该子串包含从 $0$ 到 $9$ 的所有数字，且每个数字恰好出现一次。
## 思路

为了满足要求，我们可以修改原数的某些数字，但需要最小化修改的代价（即修改的数字差值之和）。同时，修改后的数仍需满足没有前导零的限制。

不是我说，我的算法倒还挺暴力的。

我的做法是现选出一个字串，然后再使用类似于桶排序的方法统计数字个数。由于这里字串长度是固定的，且是由左侧向右侧扫描，就是滑动窗口的写法。

每次桶排序统计结束后，我们能够得到哪些数字被多算了，哪些数字被少算了，这时，我们不断保证被替换的的数字与替换后的数字之差最小即可。

这个时候要注意两个特殊情况：
1. 原串长度小于 $10$，也就是说根本不可能出现 $10$ 个不同的数字。
2. 当扫描第一个长度为 $10$ 的字串时，要注意第一个数不能被修改为 $0$（即不能有前导零）。

## 算法
~~由算法标签可知~~

从上面的推导，我们能知道要写以下几个算法：

1.**滑动窗口**：

遍历长度为 $10$ 的所有子串。其中，对每个子串，计算其是否已经是一个排列。如果是，则代价为 $0$，直接返回结果。如果不是，则计算将其变为一个排列的最小代价。

tip：这里不是真正意义上的的双指针，实际上是单指针。

2.**桶排序**：

统计每个数字的出现次数。

这里我们还做了一些其他的优化（类似于 KMP？）：

1.**减少重复计算**：

滑动窗口可以通过增量更新频率数组（就是当它往后移动的时候，直接加减新进入窗口中的数字与离开窗口中的数字），避免重复计算。

2.**排序**：

对于多余和缺失的数字，可以排序后匹配，确保代价最小。

# 代码

这里献上自己的代码（Python 超时了，就不放出来了）：

## C++
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    string m_str;
    cin >> m_str;
    int n = m_str.size();
    if (n < 10) {
        cout << -1 << endl;
        return 0;
    }
    int min_cost = INT_MAX;
    // 滑动窗口遍历所有长度为 10 的子串
    for (int i = 0; i <= n - 10; i++) {
        string window = m_str.substr(i, 10);
        int freq[10] = {0};
        // 统计子串中每个数字的频率
        for (char d : window) {
            freq[d - '0']++;
        }
        // 检查是否已经是一个排列
        bool is_permutation = true;
        for (int d = 0; d <= 9; d++) {
            if (freq[d] != 1) {
                is_permutation = false;
                break;
            }
        }
        // 如果是排列，直接输出结果
        if (is_permutation) {
            cout << 0 << endl;
            return 0;
        }
        // 记录多余和缺失的数字
        char dup[10], miss[10];
        int dup_cnt = 0, miss_cnt = 0;

        for (int d = 0; d <= 9; d++) {
            int cnt = freq[d];
            if (cnt > 1) {
                for (int j = 1; j < cnt; j++) {
                    dup[dup_cnt++] = d + '0';
                }
            } else if (cnt == 0) {
                miss[miss_cnt++] = d + '0';
            }
        }
        // 计算代价
        bool mnz = (window[0] == '0');
        // 是否有前导零
        int cost = 0;
        if (mnz) {
            // 特殊处理前导零
            bool found = false;
            for (int j = 0; j < dup_cnt; j++) {
                if (dup[j] == window[0]) {
                    char best_d = '0';
                    int min_diff = INT_MAX;
                    for (int k = 0; k < miss_cnt; k++) {
                        if (miss[k] != '0') {
                            int diff = abs(miss[k] - window[0]);
                            if (diff < min_diff) {
                                min_diff = diff;
                                best_d = miss[k];
                            }
                        }
                    }
                    if (best_d == '0') {
                        cost = INT_MAX;
                        break;
                    }
                    cost += min_diff;
                    found = true;
                    break;
                }
            }
            if (!found) continue;
        }
        // 匹配多余和缺失的数字
        sort(dup, dup + dup_cnt);
        sort(miss, miss + miss_cnt);
        for (int j = 0; j < dup_cnt; j++) {
            cost += abs(miss[j] - dup[j]);
        }
        // 更新最小代价
        min_cost = min(min_cost, cost);
    }
    cout << min_cost << endl;
    return 0;
}
```

## C#：

```csharp
using System;
using System.Linq;

class Program
{
    static void Main()
    {
        string m_str = Console.ReadLine();
        int n = m_str.Length; -1
        if (n < 10)
        {
            Console.WriteLine(-1);
            return;
        }
        int min_cost = int.MaxValue;
        for (int i = 0; i <= n - 10; i++)
        {
            string window = m_str.Substring(i, 10);
            int[] freq = new int[10];
            // 统计子串中每个数字的频率
            foreach (char d in window)
            {
                freq[d - '0']++;
            }
            // 检查是否已经是一个排列
            bool is_permutation = true;
            for (int d = 0; d <= 9; d++)
            {
                if (freq[d] != 1)
                {
                    is_permutation = false;
                    break;
                }
            }
            // 如果是排列，直接输出结果
            if (is_permutation)
            {
                Console.WriteLine(0);
                return;
            }
            // 记录多余和缺失的数字
            char[] dup = new char[10];
            char[] miss = new char[10];
            int dup_cnt = 0, miss_cnt = 0;
            for (int d = 0; d <= 9; d++)
            {
                int cnt = freq[d];
                if (cnt > 1)
                {
                    for (int j = 1; j < cnt; j++)
                    {
                        dup[dup_cnt++] = (char)(d + '0');
                    }
                }
                else if (cnt == 0)
                {
                    miss[miss_cnt++] = (char)(d + '0');
                }
            }
            // 计算代价
            bool mnz = (window[0] == '0'); // 是否有前导零
            int cost = 0;
            if (mnz)
            {
                // 特殊处理前导零
                bool found = false;
                for (int j = 0; j < dup_cnt; j++)
                {
                    if (dup[j] == window[0])
                    {
                        char best_d = '0';
                        int min_diff = int.MaxValue;
                        for (int k = 0; k < miss_cnt; k++)
                        {
                            if (miss[k] != '0')
                            {
                                int diff = Math.Abs(miss[k] - window[0]);
                                if (diff < min_diff)
                                {
                                    min_diff = diff;
                                    best_d = miss[k];
                                }
                            }
                        }
                        if (best_d == '0')
                        {
                            cost = int.MaxValue;
                            break;
                        }
                        cost += min_diff;
                        found = true;
                        break;
                    }
                }
                if (!found) continue;
            }
            // 匹配多余和缺失的数字
            Array.Sort(dup, 0, dup_cnt);
            Array.Sort(miss, 0, miss_cnt);
            for (int j = 0; j < dup_cnt; j++)
            {
                cost += Math.Abs(miss[j] - dup[j]);
            }
            // 更新最小代价
            min_cost = Math.Min(min_cost, cost);
        }
        Console.WriteLine(min_cost);
    }
}
```

## Java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String m_str = scanner.nextLine();
        int n = m_str.length();
        if (n < 10) {
            System.out.println(-1);
            return;
        }
        int min_cost = Integer.MAX_VALUE;
        for (int i = 0; i <= n - 10; i++) {
            String window = m_str.substring(i, i + 10);
            int[] freq = new int[10];
            // 统计子串中每个数字的频率
            for (char d : window.toCharArray()) {
                freq[d - '0']++;
            }
            // 检查是否已经是一个排列
            boolean is_permutation = true;
            for (int d = 0; d <= 9; d++) {
                if (freq[d] != 1) {
                    is_permutation = false;
                    break;
                }
            }
            // 如果是排列，直接输出结果
            if (is_permutation) {
                System.out.println(0);
                return;
            }
            // 记录多余和缺失的数字
            char[] dup = new char[10];
            char[] miss = new char[10];
            int dup_cnt = 0, miss_cnt = 0;
            for (int d = 0; d <= 9; d++) {
                int cnt = freq[d];
                if (cnt > 1) {
                    for (int j = 1; j < cnt; j++) {
                        dup[dup_cnt++] = (char) (d + '0');
                    }
                } else if (cnt == 0) {
                    miss[miss_cnt++] = (char) (d + '0');
                }
            }
            // 计算代价
            boolean mnz = (window.charAt(0) == '0'); // 是否有前导零
            int cost = 0;
            if (mnz) {
                // 特殊处理前导零
                boolean found = false;
                for (int j = 0; j < dup_cnt; j++) {
                    if (dup[j] == window.charAt(0)) {
                        char best_d = '0';
                        int min_diff = Integer.MAX_VALUE;
                        for (int k = 0; k < miss_cnt; k++) {
                            if (miss[k] != '0') {
                                int diff = Math.abs(miss[k] - window.charAt(0));
                                if (diff < min_diff) {
                                    min_diff = diff;
                                    best_d = miss[k];
                                }
                            }
                        }
                        if (best_d == '0') {
                            cost = Integer.MAX_VALUE;
                            break;
                        }
                        cost += min_diff;
                        found = true;
                        break;
                    }
                }
                if (!found) continue;
            }
            // 匹配多余和缺失的数字
            Arrays.sort(dup, 0, dup_cnt);
            Arrays.sort(miss, 0, miss_cnt);
            for (int j = 0; j < dup_cnt; j++) {
                cost += Math.abs(miss[j] - dup[j]);
            }
            // 更新最小代价
            min_cost = Math.min(min_cost, cost);
        }
        System.out.println(min_cost);
    }
}

```

---

## 作者：ZackofZHOU (赞：1)

# 思路
## 贪心
1.    截取每 $10$ 个**连续的字符**。
2.    处理字符串。
  * 获取多余的字符和缺少的字符。
  * **直接求值**，**千万不要排序**。
3.    取处理的值的最小值。

[AC 记录](https://www.luogu.com.cn/record/217216295)

完整代码：（有注释）

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
#define emp {0,0,0,0,0,0,0,0,0,0}
string m;
int l,ans = 0x7fffffff;
int Abs(int N) // 绝对值 
{
	return (N < 0 ? -N : N);
}
int main()
{
	cin >> m;
	l = m.size();
	for(int i = 0;i < l - 9;i++) // 截取10个字符 
	{
		string a = m.substr(i,10);
		int sum = 0,L = 0;
		int cnt[10] = emp,mor[10] = emp,les[10] = emp;
		for(int j = 0;j < 10;j++) // 处理多余字符 
		{
			if(cnt[a[j] - '0'])
				mor[L++] = a[j] - '0';
			else
				cnt[a[j] - '0']++;
		}
		L = 0;
		for(int j = 0;j < 10;j++) // 处理缺少字符 
			if(!cnt[j])
				les[L++] = j;
		for(int j = 0;j < L;j++) // 求值 
			sum += Abs(mor[j] - les[j]);
		ans = min(ans,sum); // 取最小 
	}
	cout << ans;
	return 0;
}
```

无注释版本：
```cpp
#include<algorithm>
#include<iostream>
using namespace std;
#define emp {0,0,0,0,0,0,0,0,0,0}
string m;
int l,ans = 0x7fffffff;
int Abs(int N)
{
	return (N < 0 ? -N : N);
}
int main()
{
	cin >> m;
	l = m.size();
	for(int i = 0;i < l - 9;i++)
	{
		string a = m.substr(i,10);
		int sum = 0,L = 0;
		int cnt[10] = emp,mor[10] = emp,les[10] = emp;
		for(int j = 0;j < 10;j++)
		{
			if(cnt[a[j] - '0'])
				mor[L++] = a[j] - '0';
			else
				cnt[a[j] - '0']++;
		}
		L = 0;
		for(int j = 0;j < 10;j++)
			if(!cnt[j])
				les[L++] = j;
		for(int j = 0;j < L;j++)
			sum += Abs(mor[j] - les[j]);
		ans = min(ans,sum);
	}
	cout << ans;
	return 0;
}
```
Java 版：
```java
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
    private static final int[] EMP = {0,0,0,0,0,0,0,0,0,0};
    public static int abs(int n)
	{
        return (n < 0 ? -n : n);
    }
    public static void main(String[] args)
	{
        Scanner scanner = new Scanner(System.in);
        String m = scanner.next();
        int l = m.length();
        int ans = Integer.MAX_VALUE;
        for(int i = 0;i < l - 9;i++)
		{
            String a = m.substring(i,i + 10);
            int sum = 0;
            int len = 0;
            int[] cnt = Arrays.copyOf(EMP,10);
            int[] mor = Arrays.copyOf(EMP,10);
            int[] les = Arrays.copyOf(EMP,10);
            for(int j = 0;j < 10;j++)
            {
                if(cnt[a.charAt(j) - '0'] != 0)
                    mor[len++] = a.charAt(j) - '0';
                else
                    cnt[a.charAt(j) - '0']++;
            }
            len = 0;
            for(int j = 0;j < 10;j++)
                if(cnt[j] == 0)
                    les[len++] = j;
            for(int j = 0;j < len;j++)
                sum += abs(mor[j] - les[j]);
            ans = Math.min(ans, sum);
        }
        System.out.println(ans);
        scanner.close();
    }
}
```

求求管理员过审核。

---

## 作者：Forge_Unique (赞：1)

## 思路

滑动一个长度为 $10$ 的窗口，记一个数组 $b_i$ 表示数字 $i$ 在这个窗口里出现的个数。

记两个数组 $al_i$ 和 $nd_i$，然后从 $0$ 到 $9$ 枚举一遍，如果这个数字出现的个数大于 $1$ 就将这个数字计入 $al$，如果这个数字没出现过就将这个数字计入 $nd$。

枚举 $al$ 和 $nd$ 里的所有元素，计算将数字 $al_i$ 替换为 $nd_i$ 的代价，求和然后取最小值即可。

## 代码

[c++代码](https://www.luogu.com.cn/paste/2cauvkqy)

[java代码](https://www.luogu.com.cn/paste/4r3nbc5i)

---

## 作者：zyxjeek (赞：0)

## 题意简述

把一个数字 $a$ 改成 $b$ 要花费 $|b-a|$，你要修改一个数 $m$，让修改后的数存在连续的 $10$ 位，包含了从 $0$ 到 $9$ 的所有数字。求最小花费。

## 思路

令 $a_i$ 为 $m$ 从左到右第 $i$ 位，可以用滑动窗口维护 $a_i, a_{i+1}, \dots, a_{i+9}$ 这 $10$ 位中数字 $j (0 \le j < 10)$ 的个数，记为 $cnt_{i, j}$。开两个动态数组 `v1, v2`。如果 $cnt_{i, j}=1$，无需操作；如果 $cnt_{i, j} = 0$，说明需要新增一个数字 $j$，则在 `v1` 中添加 $j$；如果 $cnt_{i, j} > 1$，说明数字 $j$ 过多了，则在 `v2` 中添加 $cnt_{i, j}-1$ 个数字 $j$。容易发现 `v1` 和 `v2` 的大小一定相等。由于顺序枚举，`v1` 和 `v2` 也都是有序的。我们让 `v2[k]` 变为 `v1[k]`，统计花费即为答案。

时间复杂度 $\mathcal O(nk)$，其中 $k = 10$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int cnt[10];
string a;
vector<int> v1, v2;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> a;
    a = " " + a;
    int n = a.size()-1;
    for (int i = 1; i <= 10; i++)
        cnt[a[i]-'0']++;
    for (int i = 0; i <= 9; i++) {
        if (cnt[i] == 0) v1.push_back(i);
        else if (cnt[i] > 1) fill_n(back_inserter(v2), cnt[i]-1, i); // 在v2末尾插入cnt[i]-1个i
    }
    int sum = 0;
    for (int i = 0; i < v1.size(); i++)
        sum += abs(v1[i]-v2[i]);
    int ans = sum;
    for (int i = 11; i <= n; i++) {
        v1.clear(); v2.clear();
        cnt[a[i-10]-'0']--, cnt[a[i]-'0']++;
        for (int j = 0; j <= 9; j++) {
            if (cnt[j] == 0) v1.push_back(j);
            else if (cnt[j] > 1) fill_n(back_inserter(v2), cnt[j]-1, j); // 在v2末尾插入cnt[j]-1个j
        }
        sum = 0;
        for (int j = 0; j < v1.size(); j++)
            sum += abs(v1[j]-v2[j]);
        ans = min(ans, sum);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：0)

滑动窗口+贪心

## 思路

维护一个长度固定为 $10$ 的滑动窗口，并保持内部元素单调递增。为了保证每次移动能够找到要排除的元素，要给它打上一个时间戳，标记上它是什么时候进来的，排除时只要找往前第 $10$ 个时刻进来的即可。

排序后计算代价，这里用的就是贪心的想法。固定一个序列递增，当另一个序列也递增时，对应位置距离和最小，反之最大，这可以由排序不等式证明。

此外可以做一点常数优化，排序可以手动进行而不是调用 `sort`，每次用 $O(n)$ 的时间找到上一个排除的位置，用新的值替换掉它，然后前后跑一遍冒泡。一轮排序过程跑满也只是两次遍历。

由于这窗口很小，使用时间戳查找而不是匹配排除的字符，以及手动实现排序是更佳的，可以充分利用缓存局部性。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    string str;
    cin >> str;
    array<pair<int,int>,10> vp;
    int cnt = 0;
    int allans = 1000;
    int n = str.length();

    for(cnt = 0; cnt < 10; ++cnt){
        vp[cnt] = {str[cnt] - '0', cnt};
    }
    sort(vp.begin(),vp.end(),[](const pair<int,int>& p1, const pair<int,int>& p2){
        return p1.first<p2.first;
    });

    auto compute_cost = [&]() {
        int ans = 0;
        for(int i = 0; i < 10; ++i){
            ans += abs(vp[i].first - i);
        }
        return ans;
    };

    allans = compute_cost();

    while(cnt < n){
        int idx = -1;
        for(int i = 0; i < 10; ++i){
            if(vp[i].second == cnt - 10){
                idx = i;
                break;
            }
        }

        vp[idx] = {str[cnt] - '0', cnt};
        while(idx > 0 && vp[idx].first < vp[idx - 1].first){
            swap(vp[idx], vp[idx - 1]);
            --idx;
        }
        while(idx < 9 && vp[idx].first > vp[idx + 1].first){
            swap(vp[idx], vp[idx + 1]);
            ++idx;
        }

        allans = min(allans, compute_cost());
        ++cnt;
    }

    cout << allans;
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# P12289 题解

## 思路
1. 滑动窗口检查：遍历所有长度为 $10$ 的连续子串，检查每个子串是否已经满足条件（包含 $0$ 到 $9$ 的所有数字且每个数字恰好出现一次）。
2. 计算修改花费：对于不满足条件的子串，计算将其修改为满足条件的最小花费。这可以通过统计当前子串中每个数字的出现次数，并确定需要修改的数字及其对应的最小花费。
3. 维护最小花费：在所有可能的子串中，记录最小的修改花费。

## [AC](https://www.luogu.com.cn/record/215874134) 代码

```CPP
#include <bits/stdc++.h>
using namespace std;
int mct(string& s, int st) {
    int fr[10] = {0};
    for (int i = st; i < st + 10; ++i) fr[s[i] - '0']++;
    bool pr = true;
    for (int c = 0; c <= 9; ++c) {
        if (fr[c] != 1) {
            pr = false;
            break;
        }
    }
    if (pr) return 0;
    int cs = 0;
    bool us[10] = {false};
    for (int i = st; i < st + 10; ++i) {
        int cr = s[i] - '0';
        if (fr[cr] > 1) {
            for (int tg = 0; tg <= 9; ++tg) {
                if (!us[tg] && fr[tg] == 0) {
                    cs += abs(tg - cr);
                    us[tg] = true;
                    fr[cr]--;
                    fr[tg]++;
                    break;
                }
            }
        } else if (fr[cr] == 1) {
            us[cr] = true;
        }
    }
    return cs;
}
int main() {
    string m;
    cin >> m;
    int n = m.size();
    if (n < 10) {
        cout << -1 << endl;
        return 0;
    }
    int mc = INT_MAX;
    for (int i = 0; i <= n - 10; ++i) {
        if (i == 0 && m[i] == '0') continue;
        int cs = mct(m, i);
        if (cs < mc) mc = cs;
    }
    if (mc == INT_MAX) cout << -1 << endl;
    else cout << mc << endl;
    return 0;
}
```
java
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String m = scanner.next();
        int n = m.length();
        if (n < 10) {
            System.out.println(-1);
            return;
        }
        int mc = Integer.MAX_VALUE;
        for (int i = 0; i <= n - 10; ++i) {
            if (i == 0 && m.charAt(i) == '0') continue;
            int cs = mct(m, i);
            if (cs < mc) mc = cs;
        }
        if (mc == Integer.MAX_VALUE) System.out.println(-1);
        else System.out.println(mc);
    }

    private static int mct(String s, int st) {
        int[] fr = new int[10];
        for (int i = st; i < st + 10; ++i) fr[s.charAt(i) - '0']++;
        boolean pr = true;
        for (int c = 0; c <= 9; ++c) {
            if (fr[c] != 1) {
                pr = false;
                break;
            }
        }
        if (pr) return 0;
        int cs = 0;
        boolean[] us = new boolean[10];
        for (int i = st; i < st + 10; ++i) {
            int cr = s.charAt(i) - '0';
            if (fr[cr] > 1) {
                for (int tg = 0; tg <= 9; ++tg) {
                    if (!us[tg] && fr[tg] == 0) {
                        cs += Math.abs(tg - cr);
                        us[tg] = true;
                        fr[cr]--;
                        fr[tg]++;
                        break;
                    }
                }
            } else if (fr[cr] == 1) {
                us[cr] = true;
            }
        }
        return cs;
    }
}
```
deepseek 更改。

---


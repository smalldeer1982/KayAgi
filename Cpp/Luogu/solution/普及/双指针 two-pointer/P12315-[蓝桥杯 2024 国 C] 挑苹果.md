# [蓝桥杯 2024 国 C] 挑苹果

## 题目描述

老师在班级里准备给同学们发苹果，一共有 $n$ 种苹果，第 $i$ 种苹果的美味值为 $a_i$，每名同学需要选择一个非负整数 $x$，这名同学可以获得所有满足条件 $[(a_i + x) \bmod k] \leq t$ 的苹果每种一个。小蓝使用魔法偷偷得知了 $k$ 和 $t$ 的值，小蓝想知道自己最多能获得多少个苹果。


## 说明/提示

### 样例说明

取 $x = 4$ 时，第 $3, 4, 5$ 种苹果都能获得。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n, t, k \leq 1000$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^8$，$1 \leq t, k \leq 10^8$。

## 样例 #1

### 输入

```
5 5 1
8 4 6 7 6```

### 输出

```
3```

# 题解

## 作者：Objective (赞：3)

tip:我附上了很多种语言的代码，这里我以我最擅长的C++来讲解。

$\mathbf{upd\ 2025/5/14}$：文章内容纠错，并统一 Markdown 格式（保证 $\KaTeX$ 被正确使用）

# 思路与算法

本题目解题的核心思想是通过数学推导和事件统计，计算出满足条件 $l > r$ 的最大苹果数量。

我们这里称**事件**为一个特定的点和它的变化量，用来表示在某个位置上美味值的变化。这些事件的作用是通过扫描线算法来计算每个位置上满足条件的苹果数量。

通过对这些事件按位置排序，然后依次处理，可以高效地计算出满足条件的苹果的最大数量。

## 事件统计部分

### 区间计算

由题，我们需要使得每种苹果的美味值 $a_i$ 经过操作后满足条件：$$(a_i + x) \bmod k \le t$$

接着，让我们推导 $x$ 的范围。易知，$(x + m) \bmod k \le t$ 等价于：$x \bmod k \in [(k - m) \bmod k, (k - m + t) \bmod k]$

则我们令：

- $l$ 是模运算的下界，且有 $l = (k - m) \bmod k$；
- $r$ 是模运算的上界，且有 $r = (l + t) \bmod k$。

则我们得到了满足条件的 $x$ 的取值范围 $[l, r]$，方便进行后续统计。

特别地：如果区间跨越了模数边界（$l > r$），需要分段处理。

### 事件统计

为了高效统计满足条件的 $x$ 的数量，这里我们使用差分数组的思想，将区间 $[l , r]$ 转化为事件。

在区间 $[l, r]$ 的起点 $l$ 增加 $1$，表示区间开始。在区间的终点 $r + 1$ 减少 $1$，表示区间结束。如果区间跨越边界，则分段处理两部分。

具体地，当遍历每个苹果的美味值 $a_i$ 时，计算其余数 $m = a_i \bmod k$，此时：
   - 根据 $t$ 和 $k$，计算满足条件的区间 $[l, r]$：
     - 如果 $l \le r$，发生两个事件：
       - 在 $l$ 位置增加 1;
       - 在 $r+1$ 位置减少 1。
     - 如果 $l \gt r$（即区间跨越边界时），发生四个事件：
       - 在 $l$ 位置增加 1;
       - 在 $k$ 位置减少 1;
       - 在 $0$ 位置增加 1;
       - 在 $r + 1$ 位置减少 1。

它的作用是通过统计事件，将区间操作转化为点操作，便于后续排序和扫描统计。

### 该部分代码：

```cpp
vector<pair<int, int>> events;
for (int i = 0; i < n; ++i) {
    int m = a[i] % k;
    int l, r;
    if (t >= k) {
        l = 0;
        r = k - 1;
    } else {
        l = (k - m) % k;
        r = (l + t) % k;
        if (l <= r) {
            events.emplace_back(l, 1);
            events.emplace_back(r + 1, -1);
        } else {
            events.emplace_back(l, 1);
            events.emplace_back(k, -1);
            events.emplace_back(0, 1);
            events.emplace_back(r + 1, -1);
        }
    }
}
```

p.s:

在这里事件被存储在 `events` 数组中，每个事件是一个 `pair<int, int>`，其中：

- `first` 表示位置`pos`，即模 `k` 的余数范围的起点或终点。
- `second` 表示变化量`delta`，可以是 `1`（即表示开始增加）或 `-1`（即表示开始减少）。

具体来说：

- 当 `delta` 为 `1` 时，表示从这个位置开始，满足条件的苹果数量增加。
- 当 `delta` 为 `-1` 时，表示从这个位置开始，满足条件的苹果数量减少。

## 事件排序与扫描部分

接下来，根据我们最开始提到的，我们要对数组进行排序。

### 事件排序
按照位置 `pos` 对事件排序，确保扫描时按顺序处理，这里直接使用 `sort()` 函数即可。

### 扫描统计
遍历事件，维护当前活跃区间的计数 `current`，并在每次位置变化时，更新最大值 `max_count`。

### 本部分代码
```cpp
sort(events.begin(), events.end());
int max_count = 0;
int current = 0;
int prev_pos = 0;
for (const auto& event : events) {
    int pos = event.first;
    int delta = event.second;
    if (pos > prev_pos) {
        max_count = max(max_count, current);
    }
    current += delta;
    prev_pos = pos;
}
max_count = max(max_count, current);
```

# 代码
最后献上我的代码：
## C++：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_EVENTS = 200005; // 记得开2倍
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, k, t;
    cin >> n >> k >> t;
    int a[100005]; 
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    int diff[100005] = {0};
    pair<int, int> events[MAX_EVENTS]; 
    int event_count = 0;
    for (int i = 0; i < n; ++i) {
        int m = a[i] % k;
        int l, r;
        if (t >= k) {
            l = 0;
            r = k - 1;
        } else {
            l = (k - m) % k;
            r = (l + t) % k;
            if (l <= r) {
                events[event_count++] = {l, 1};
                events[event_count++] = {r + 1, -1};
            } else {
                events[event_count++] = {l, 1};
                events[event_count++] = {k, -1};
                events[event_count++] = {0, 1};
                events[event_count++] = {r + 1, -1};
            }
        }
    }
    if (t >= k) {
        cout << n << endl;
        return 0;
    }
    sort(events, events + event_count);
    int max_count = 0;
    int current = 0;
    int prev_pos = 0;
    for (int i = 0; i < event_count; ++i) {
        int pos = events[i].first;
        int delta = events[i].second;
        if (pos > prev_pos) {
            max_count = max(max_count, current);
        }
        current += delta;
        prev_pos = pos;
    }
    max_count = max(max_count, current);
    cout << max_count << endl;
    return 0;
}
```
## C#
```csharp
using System;
using System.Collections.Generic;

class Program
{
    const int MAX_EVENTS = 100005;

    static void Main()
    {
        int n, k, t;
        string[] input = Console.ReadLine().Split();
        n = int.Parse(input[0]);
        k = int.Parse(input[1]);
        t = int.Parse(input[2]);

        int[] a = new int[n];
        input = Console.ReadLine().Split();
        for (int i = 0; i < n; ++i)
        {
            a[i] = int.Parse(input[i]);
        }

        List<(int, int)> events = new List<(int, int)>();
        for (int i = 0; i < n; ++i)
        {
            int m = a[i] % k;
            int l, r;
            if (t >= k)
            {
                l = 0;
                r = k - 1;
            }
            else
            {
                l = (k - m) % k;
                r = (l + t) % k;
                if (l <= r)
                {
                    events.Add((l, 1));
                    events.Add((r + 1, -1));
                }
                else
                {
                    events.Add((l, 1));
                    events.Add((k, -1));
                    events.Add((0, 1));
                    events.Add((r + 1, -1));
                }
            }
        }

        if (t >= k)
        {
            Console.WriteLine(n);
            return;
        }

        events.Sort((x, y) => x.Item1.CompareTo(y.Item1));

        int maxCount = 0;
        int current = 0;
        int prevPos = 0;

        foreach (var eventPair in events)
        {
            int pos = eventPair.Item1;
            int delta = eventPair.Item2;

            if (pos > prevPos)
            {
                maxCount = Math.Max(maxCount, current);
            }

            current += delta;
            prevPos = pos;
        }

        maxCount = Math.Max(maxCount, current);
        Console.WriteLine(maxCount);
    }
}
```
## Java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int t = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }

        if (t >= k) {
            System.out.println(n);
            return;
        }

        List<Event> events = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int m = a[i] % k;
            int l, r;
            if (t >= k) {
                l = 0;
                r = k - 1;
            } else {
                l = (k - m) % k;
                r = (l + t) % k;
                if (l <= r) {
                    events.add(new Event(l, 1));
                    events.add(new Event(r + 1, -1));
                } else {
                    events.add(new Event(l, 1));
                    events.add(new Event(k, -1));
                    events.add(new Event(0, 1));
                    events.add(new Event(r + 1, -1));
                }
            }
        }

        events.sort(Comparator.comparingInt(e -> e.pos));

        int maxCount = 0;
        int current = 0;
        int prevPos = 0;
        for (Event event : events) {
            int pos = event.pos;
            int delta = event.delta;
            if (pos > prevPos) {
                maxCount = Math.max(maxCount, current);
            }
            current += delta;
            prevPos = pos;
        }
        maxCount = Math.max(maxCount, current);

        System.out.println(maxCount);
    }

    static class Event {
        int pos;
        int delta;

        Event(int pos, int delta) {
            this.pos = pos;
            this.delta = delta;
        }
    }
}
```
## Python3
```python
class Event:
    def __init__(self, pos, delta):
        self.pos = pos
        self.delta = delta

def main():
    n, k, t = map(int, input().split())
    a = list(map(int, input().split()))

    if t >= k:
        print(n)
        return

    events = []
    for i in range(n):
        m = a[i] % k
        if t >= k:
            l, r = 0, k - 1
        else:
            l = (k - m) % k
            r = (l + t) % k
            if l <= r:
                events.append(Event(l, 1))
                events.append(Event(r + 1, -1))
            else:
                events.append(Event(l, 1))
                events.append(Event(k, -1))
                events.append(Event(0, 1))
                events.append(Event(r + 1, -1))

    events.sort(key=lambda e: e.pos)

    max_count = 0
    current = 0
    prev_pos = 0
    for event in events:
        pos = event.pos
        delta = event.delta
        if pos > prev_pos:
            max_count = max(max_count, current)
        current += delta
        prev_pos = pos
    max_count = max(max_count, current)

    print(max_count)

if __name__ == "__main__":
    main()

```

---

## 作者：_IceCream_ (赞：3)

# Content

给你一个长度为 $n$ 的数列 $A$，需要你求出一个 $x$，满足 $(a_i + x) \bmod k \le t$。

# Solution

首先这个 $(a_i + x) \bmod k \le t$ 肯定是一个周期为 $k$ 的东西，因为 $(x + k) \bmod k = x$。

那么我们可以把范围缩到 $[0,k]$ 这个区间内，往后考虑没有意义，都是重复的。

我们可以近似地将 $(a_i + x) \bmod k$ 看成 $(a_i + x) - k$，且余数是不能小于 $0$ 的，所以就有一个 $0 \le a_i + x - k \le t$ 的不等式。可以解得 $k - a_i \le x \le k - a_i + t$。

所以现在问题变成了给你一堆区间，让你选出一个数，使得这个数被覆盖的区间个数最多。

我们不妨看成一个区间修改，将 $[l,r]$ 区间内的数加 $1$ 后求最大值，那么这个区间有两种可能。

- $l, r$ 均在 $[0,k]$ 范围内，直接覆盖即可。
![](https://cdn.luogu.com.cn/upload/image_hosting/j2loggvw.png)
- $l$ 在 $[0,k]$ 范围内，$r$ 在 $(k, +\infty)$ 范围内，此时我们可以用周期性将 $r$ 转到 $[0,k]$ 范围内。但此时 $r \le l$，因此我们分两段解决。一段 $[l, k]$，一段 $[0, r]$。
![](https://cdn.luogu.com.cn/upload/image_hosting/686ke1q9.png)

将端点排序后，可以用差分 + 前缀和 $O(n)$ 解决。

复杂度 $O(n \log n)$，瓶颈在排序。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 2e5 + 5;
int n, k, t;
int sum, ans;
vector <pair <int, int>> v;

signed main () {

	scanf ("%lld%lld%lld", &n, &k, &t);
	for (int i = 1, x; i <= n; ++i) {
		scanf ("%lld", &x);
		// 计算覆盖区间 
		int l = (k - (x % k) + k) % k;
		if (l < 0) l += t;
		int r = (l + t) % k;
		
		if (l <= r) {
			// 不跨段 
			v.emplace_back (l, 1); v.emplace_back (r + 1, -1);
		} else {
			// 跨段覆盖 
			v.emplace_back (l, 1); v.emplace_back (k, -1);
			v.emplace_back (0, 1); v.emplace_back (r + 1, -1);
		}
	}
	
	sort (v.begin (), v.end ());
	
	for (auto i : v) {
		sum += i.second;
		ans = max (ans, sum);
	}
	printf ("%lld", ans);
	
	return 0;
}
```

---

## 作者：convie (赞：2)

一道很简单的双指针题目了，我们可以将读入数据的 $a[i]$ 依次取模，因为取模不影响最终结果，然后我们观察，要想一个 $x$ 使得满足条件的数最多，可以想到这是一个满足区间条件的区间移动问题，我们的目的就是取得区间的最大值，需要注意的是，这是一个环不是一个链，具体内容看代码就行。
```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
#define int long long
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define MAXN 1000010
int a[MAXN];
int q[MAXN];
signed main(){
	ios;
	int n,t,k;
	cin>>n>>k>>t;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)a[i]%=k;//提前取模，对最终结果没有影响 
	sort(a+1,a+1+n);
    for(int i=n+1;i<=n*2;i++)a[i]=a[i-n]+k;//破换成连 
	int hh=0,tt=-1;
	int mx=0;
	for(int i=1;i<=2*n;i++){
		while(hh<=tt&&a[i]-a[q[hh]]>t)hh++;//满足区间的极差小于t 
		q[++tt]=i;
		mx=max(mx,tt-hh+1);//求出最大值 
	}
	cout<<min(mx,n);//怕有毒瘤数据，然而却并没有 
	return 0;
}
```

---

## 作者：Mierstan085 (赞：0)

## 题意

给定数列 $A = \{a_i\}$、$|A| = n$，求满足 $(a_i + x) \bmod k \le t$ 的正整数 $x$。

## 解法

首先模运算具有周期性，所以原不等式也有一个周期，为 $k$。那么我们可以只考虑 $(a_i + x) \in [k, 2k)$ 的情况（这个周期处理更方便一点）。

此时可以发现 $(a_i + x) \bmod k = a_i + x - k \ge 0$，则原不等式可化为关于 $x$ 的不等式 $0 \le a_i + x - k \le t$，解得 $k - a_i \le x \le k - a_i + t$。

此时也就是求 $\sum_{i=1}^{n}[x \in [k - a_i, k - a_i + t]]$ 最大的 $x$。

可以考虑做一个区间修改问题，即对于一个长 $k$ 的区间内的 $n$ 个子区间区间加 $1$，最后求最大值，这比较好做。但是由于这里元素的下标是模 $k$ 意义下的，所以对于 $r > k$ 的情况需要做特殊判断，把区间 $[l, r]$ 变为 $[0, r \bmod k]$ 和 $[l, k]$ 即可。

就是差分板子了。具体实现看代码吧。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2e5 + 5;
int n, k, t;
ll sum, ans; vector <pair<int, int>> vec;

int main(){
    cin >> n >> k >> t;
    for (int i = 1, x; i <= n; i ++){
        cin >> x;
        ll l = (k * 2 - (x % k)) % k; if (l < 0) l += t;
        ll r = (l + t) % k;
        // 1. 正常情况
        if (l <= r){
            vec.push_back({l, 1});
            vec.push_back({r + 1, -1});
        } /* 2. r > k */ else {
            vec.push_back({l, 1});
            vec.push_back({k, -1});
            vec.push_back({0, 1});
            vec.push_back({r + 1, -1});
        }
    }
    
	sort (vec.begin(), vec.end());
	for (auto i : vec){
        sum += i.second, ans = max(ans, sum);
    } cout << ans;
}
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
简单来说就是：
1. 先把所有苹果的美味值都对 $k$ 取个模（就是算算除以 $k$ 的余数）。
2. 如果余数 $\le t$：$x$ 可以选两段（从 $0$ 开始的一段和从 $k-$ 余数开始的一段）。
3. 如果余数 $>t$：$x$ 只能选从 $k-$ 余数开始的一段。
4. 用个聪明的方法（差分数组）统计哪些 $x$ 被选中的次数最多。
5. 特殊情况：如果 $t\ge k-1$，那随便选 $x$ 都能拿到所有苹果。
### 代码：

```cpp
#include<bits/stdc++.h>
const int N=1e7+101;
using namespace std;
int n,k,t,a[N],m;
pair<int,int>e[N];
int main(){
    cin>>n>>k>>t;
    if(t>=k-1){
        cout<<n<<endl;
        return 0;
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]%=k;
    }
    for(int i=1;i<=n;i++){
        int b=a[i];
        if(t>=b){
            int R1=t-b+1;
            if(R1>k)R1=k;
            e[++m]=make_pair(0,1);
            e[++m]=make_pair(R1,-1);
        }
        int L2=k-b;
        int R2=min(k-1,t+k-b);
        if(L2<=R2){
            int end=R2+1;
            if(end>k)end=k;
            e[++m]=make_pair(L2,1);
            e[++m]=make_pair(end,-1);
        }
    }
    sort(e+1,e+m+1);
    int ans=0,cur=0;
    int l=0;
    for(int i=1;i<=m;i++){
        int pos=e[i].first;
        if(pos>l){
            ans=max(ans,cur);
            l=pos;
        }
        cur+=e[i].second;
    }
    ans=max(ans,cur);
    cout<<ans<<endl;
    return 0;
}
```

---


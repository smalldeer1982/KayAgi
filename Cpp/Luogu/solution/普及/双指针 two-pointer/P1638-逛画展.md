# 逛画展

## 题目描述

博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。

游客在购买门票时必须说明两个数字，$x$ 和 $y$，代表他要看展览中的第 $x$ 幅至第 $y$ 幅画（包含 $x,y$）之间的所有图画，而门票的价钱就是一张图画一元。

Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。

请求出他购买门票时应选择的 $x,y$，数据保证一定有解。

若存在多组解，**输出 $x$ 最小的那组**。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，有 $n\le200$，$m\le20$。
- 对于 $60\%$ 的数据，有 $n\le10^5$，$m\le10^3$。
- 对于 $100\%$ 的数据，有 $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。

## 样例 #1

### 输入

```
12 5
2 5 3 1 3 2 4 1 1 5 4 3
```

### 输出

```
2 7```

# 题解

## 作者：cuking (赞：192)

首先注意到，必须看到所有的画师的画才行，所以可以考虑维护一个区间内，每个画师有多少画，可以用一个数组来维护

第一个循环中，把区间右端点不断右移，并维护该画的画师出现次数，出现新的画师把计数器加一，直到看到所有画师的画，然后循环判断左端点的画师是否出现一次以上，

这时候应用贪心思想，只要出现过一次以上，那么左端点就一定可以弹出，因为这个点的存在只会让区间更长，而不会让区间包含画师更多，我们只要保证这个区间有每个画师的画就行了，

这时用两个变量来记录当前区间左右端点作为初始答案

然后第二次循环，继续循环剩下的画，

每次将右端点+1，维护画的画师出现次数，并不断弹出没必要存在的左端点，因为在第二个循环里任何时刻的区间都保证满足能看到所有画师的画，所以应该在循环里面判断当前区间是否比已知答案的区间更短，如果更短，更新答案

我的代码区间是从零计的，所以输出时+1

虽然循环嵌套，但是因为每个点都只会最多出入一次区间，所以复杂度O(n)，只是常数略大


        

```cpp
#include<stdio.h>
int m[2001],num;
int n[1000000];
int main()
{
    int R=-1,L=0,N,M,t,i=0,ansL,ansR;
    scanf("%d%d",&N,&M);
    for(i=0;i<N;i++)
    scanf("%d",n+i);
    i=0;
    while(num!=M)
    {
        if(m[n[i]]==0)num++;
        m[n[i]]++;
        R++;
        i++;
    }
    while(m[n[L]]>1)
        m[n[L++]]--;
    ansL=L;ansR=R;
    while(i<N)
    {
        m[n[i]]++;
        R++;
        i++;
        while(m[n[L]]>1)
            m[n[L++]]--;
        if(ansR-ansL>R-L)
        {
            ansR=R;
            ansL=L;
        }
    }
    printf("%d %d",ansL+1,ansR+1);
}

```

---

## 作者：米奇 (赞：181)

## 方法：**区间伸缩**

### 时间复杂度：$O(n)$

用两个变量$l$和$r$来枚举区间

如果$l$到$r$的区间不满足要求,$r$++

如果$l$到$r$的区间满足要求,记录答案,$l$++

## 代码： 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005],b[2005],k,ans,l,r,ll,rr;
//b[i]表示当前区间画家i的图画数
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	l=1; r=1; k=1; b[a[1]]=1; ans=1000005;
    //k记录当前区间中有多少画家的图画
	while(l<=r && r<=n)
	{
		if(k==m)//判断是否符合要求
		{
			if(ans>r-l+1)	
			{
				ans=r-l+1;//ans记录最小区间长度
				ll=l; rr=r;
    //ll记录最小区间的左端点,rr记录最小区间的右端点
			}
			b[a[l]]--;
			if(b[a[l]]==0) k--;
			l++;
		}
		else{
			r++;
			b[a[r]]++;
			if(b[a[r]]==1) k++;
		}
	}
	printf("%d %d",ll,rr);
	return 0;
}
```

---

## 作者：Sino_E (赞：61)

类似滑动窗口的贪心。

考虑暴力。枚举右端点，贪心找到一个**最优的**左端点，判断区间长度是否更优，更新答案。

尝试将这个暴力优化。

考虑右端点从1开始一步一步往右边推。我们增加一个数组pos记录大师最晚出现的位置。显然每次右端点往右移一位，就会有一个大师的pos被更新。

若左端点在上一个右端点的最优解为l，我们考虑左端点上的画是k。若l<pos[k]，是不是这个画根本就没有必要看下去了？因为这个画在后面能够看到，而这个画又处于最左边，可以选择不看，于是此时我们应该把l往右移一位，显然这是符合贪心策略的。但若l==pos[k]，l显然不能右移，因为这样不符合**包含所有种类的画**的条件。

于是我们便可以在每次右端点向右移一位，再贪心地更新左端点的位置来找到左端点的最优解，这就是一个优化的暴力。然后每次就判断区间长度是否更优就行了。

**一些细节：** 首先这个区间里面必须包含所有的画。一开始把pos初始化为-1，则如果左端点的画仅出现过一次，那么左端点不会更新。当所有的pos都不为-1的时候，才可以统计答案。

嘛，很像滑动窗口。

细节见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+10,M=2e3+10;
int mlen=0x7fffffff,ml,mr; // 记录答案
int pos[M]; // 记录种类画最后一次出现的位置
int pic[N],l=1,cnt; // 画、左端点和已经包含了多少种类的画

int main(){
    ios::sync_with_stdio(false);
    int n,m;
    cin>>n>>m;
    int na;
    memset(pos,-1,sizeof(pos));
    for(int i=1;i<=n;i++){
        cin>>pic[i];
        if(pos[pic[i]]==-1) cnt++; // 如果没有出现，统计+1
        pos[pic[i]]=i; // 更新位置
        while(l!=i && l<pos[pic[l]]) l++; // 更新左端点
        if(cnt==m && i-l+1<mlen)
            mlen=i-l+1,ml=l,mr=i; // 如果已经包含了所有种类的画，而且区间较之前更小，更新答案
    }
    cout<<ml<<' '<<mr<<endl;
    return 0;
}
```

---

## 作者：星王桐 (赞：38)

看到二分的题解好少，本蒟蒻来一发   
本题就是滑动窗口+二分，二分滑动窗口的长度，并在每次检查二分答案的正确性时，更新答案。       
因为l和r的范围不断减小，不会出现先有答案比新答案更优的情况，其余具体见代码。
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <valarray>
using namespace std;
typedef long long ll;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
inline void read(int &a)//快速读入 
{
	a=0;char ch;
	while ((ch=getchar())<48);
	while (ch>47) a=(a<<1)+(a<<3)+(ch^48),ch=getchar();
}
#define N 1000100
#define M 2020
int ansa,ansb,n,m;
int a[N];
int flag[M];//记录在长度为p的区间，m个画师画的画有几幅 
bool isok(int p)
{
	int i,tmp=0;
	memset (flag,0,sizeof(flag));//要置零 
	for (i=1;i<=p;i++){//先将1~p的画记下 
		if (flag[a[i]]==0)//若有新出现的，出现个数tmp++ 
		tmp++;
		flag[a[i]]++;
	}
	if (tmp>=m) {//判断是否满足条件 
		ansa=1;ansb=p;//更新答案 
		return true;
	}
	for (i=p+1;i<=n;i++){//不断滑动窗口 
		flag[a[i-p]]--;
		if (flag[a[i-p]]==0) tmp--;
		if (flag[a[i]]==0) tmp++;
		flag[a[i]]++;
		if (tmp>=m){
			ansa=i-p+1;ansb=i; //更新答案 
			return true;
		}
	}
	return false;
}
int main ()
{
	int i,l,r,mid;
	read(n);read(m);
	for (i=1;i<=n;i++)
	read(a[i]);
	l=0;r=n+1;//要将l,r多赋值一个，否则91分 
	while (l<r){//二分 
		mid=(l+r)>>1;
		if (isok(mid))
		r=mid;//上界下取整 
		else
		l=mid+1;//下界上取整 
	}
	cout<<ansa<<' '<<ansb<<endl;
	return 0;
}

```

---

## 作者：引领天下 (赞：35)

看了一下前面的题解都麻烦了，所以来一发简单的题解

因为是要求看的画是连续的，所以可以考虑尺取法（双指针法）

既然要求要看到M位画家的画，我们可以考虑维护一个区间[l,r]，保证这个区间是含有M位画家且以l开头最小的区间，则如果想更新答案获得更小区间，只能右移l，而不能左移r。

为什么呢？

考虑反证法。

假设有一个区间[l,r-k]比[l,r]更优，则这段区间会在r
=r-k的时候就被更新，所以左移r无用。

所以r就满足单调性（只增不减），可以用尺取法做。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1000005;
int n,m,a[MAXN],ans,b[MAXN],cnt,ansl,ansr;
inline void I(int x){if(b[x]==0)cnt++;b[x]++;}//加入第x位画家的画
inline void D(int x){if(b[x]==1)cnt--;b[x]--;}//删除第x位画家的画
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf ("%d",&a[i]);
    ans=n;
    for(int r=1,l=1;r<=n;r++){
        I(a[r]);//首先插入a[r]的画
        while(true){
            D(a[l]);//先删a[l]的画
            if(cnt==m)l++;//如果删了没事，加l
            else{I(a[l]);break;}//删了有事，还留着
        }
        if(cnt==m&&r-l+1<ans)ans=r-l+1,ansl=l,ansr=r;
    }
    if (ansl!=0)printf ("%d %d",ansl,ansr);
    else printf ("1 %d",n);//输出+特判：选择任意一个≤n的区间不满足要求，则只好选择区间[1,n]
    return 0;
}
```

---

## 作者：Wind_yu (赞：33)

### 方法：单调队列
### 数据结构：双端队列

看这么多题解都没有STL的队列，只有手写的队列，那我就来发一波STL的吧

遍历1~n每个点，把每个点都加入到队列中，这时如果队头和队尾的画师相同，就要把队头弹出，使这个队列的长度尽可能的小。


具体操作见代码注释：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
deque<int>que;
#define N 10001000
const int INF=1e8;
int sz=INF;
int n,m,ar[N],ans[2001];
int main()
{
	int i,j,l,r;
	scanf("%d%d",&n,&m);
	int tot=0;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&ar[i]);
		if(!ans[ar[i]])//计算当前队列中一共出现了多少种画
			tot++;
		ans[ar[i]]++;//记录每种画出现的次数
		que.push_back(i);
		while(!que.empty() && ans[ar[que.front()]]>1)
		{
			ans[ar[que.front()]]--;//把每幅画出现的次数都变为1，相当于种数,防止上面的tot多记录导致出错
			que.pop_front();//如果队列中存在与队头相同的画，那么队头这幅画就没必要存在，弹出队头，保证队列长度为当前最小
		}
		if(tot==m)//当队列中已经存在所有画师的画时
			if(que.size()<sz)//记录每次遍历的队列的最小长度
			{
				sz=que.size();
				l=que.front();
				r=que.back();
			}
	}
	printf("%d %d",l,r);
}
```


---

## 作者：浅色调 (赞：29)

###尺取法###

**思路：**首先这是尺取法的板子题，我们假设从第s幅画开始看，为了覆盖所有大师的画需要看到t。这样的话可以知道如果从s+1开始看的话，那么必须看到t‘>=t幅画为止。so，我们从区间的最开头把s取出之后，s这幅画所属的大师出现次数就要减1,如果此时这个大师出现次数为0了，在同一个大师再次出现之前，不停将区间末尾t向后推进即可。每次在区间末尾追加画t时将t所属的大师出现次数加1,这样就完成了下一个区间上各个大师出现次数的更新，重复这一操作便能在O(nlogn)的时间复杂度下解决这道题。

**注意：**本题数据很大，建议读入优化，但m很小，可以直接计数，如果m很大可以离散或者用stl的map。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi()
{
    int a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
    return f?-a:a;
}
int countt[2005];
int n,m,a[1000005];
int main()
{
    n=gi(),m=gi();
    for(int i=0;i<n;i++)a[i]=gi();
    int s=0,t=0,num=0,res=n,l=1,r=n;
    for(;;){
    while(t<n&&num<m){
        if(countt[a[t++]]++==0)num++;
    }
    if(num<m)break;
    if(res>t-s){res=t-s;l=s+1;r=t;}
    if(--countt[a[s++]]==0)num--;    
    }
    cout<<l<<' '<<r;
    return 0;
}
```

---

## 作者：EarthGiao (赞：15)

## 【思路】

双指针    
枚举起点a    
终点b（尾指针）累加    
直到可以看到每一位名师的画作    
然后比较记录的区间长度    
如果这个区间小那就a，b替代之前记录下来的     

怎么判断每一位名师的画作是否被看过？    
用一个桶，    
如果这位名师的画作加入进来那就在他的桶上累加    
如果是从0变为1的一个桶那就是新加入了一位画师     
所以计数器累加（计数器用来计数目前可以看到画师画作的数量）    
如果是一个从1变为0的桶    
那就是少看到一位画师的画作     
所以这个时候要计数器累减     

## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>

using namespace std;
int l = 1,r = 1;
int acioi[1000006];
int tong[2020];
int js = 0;
int L,R,M = 0x7fffffff;

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(register int i = 1;i <= n;++ i)
		scanf("%d",&acioi[i]);
	tong[acioi[1]] ++;
	js ++;
	for(l = 1,r = 1;l <= n;++ l)
	{
		tong[acioi[l - 1]] --;
		if(tong[acioi[l - 1]] == 0)
			js --;
		while(js < m && r <= n)
		{
			++r;
			tong[acioi[r]] ++;
			if(tong[acioi[r]] == 1)
				js ++;
		}
		if(js == m && r - l + 1 < M)
		{
			M = r - l + 1;
			L = l;R = r;
		}
	}
	cout << L << " " << R << endl;
	return 0;
}
```

---

## 作者：LVYOUYW (赞：15)

首先考虑如果给定拥有钱的数量，那么我们可以在O(n)的时间内枚举所有的情况，于是我们可以二分答案，二分拥有钱的数量，然后去判断是否可行。



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 1000005
#define maxm 2005
int flag[maxm],n,m,a[maxn],cnt;
int ansL,ansR;
bool check(int x)
{
    cnt=0;
    memset(flag,0,sizeof flag);
    for (int i=1;i<=x;i++) 
    {
        if (!flag[a[i]]) cnt++;    
        flag[a[i]]++;
    }
    if (cnt==m) 
    {
        ansL=1;ansR=x;
        return 1;    
    }
    int y=1;
    while (x<n) 
    {
        flag[a[y]]--;
        if (!flag[a[y]]) cnt--;
        y++;
        x++;
        flag[a[x]]++;
        if (flag[a[x]]==1) cnt++;
        if (cnt==m) 
        {
            ansL=y;ansR=x;
            return 1;
        }
    }
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) scanf("%d",a+i);
    int l=1,r=n;
    while (l<=r) 
    {
        int mid=(l+r)>>1;
        if (check(mid)) r=mid-1;
        else l=mid+1;    
    }
    printf("%d %d\n",ansL,ansR);
    return 0;    
}
```

---

## 作者：x_faraway_x (赞：14)

这题可以不用真实的队列，只要用两个变量模拟一下就可以啦

也可以说是枚举的思想：这题很容易想到O(n^2)的枚举区间的算法，容易TLE。先找到第一个包含所有不同数字的区间[i,j]，然后让i+1，同时枚举j找到另一个区间，然后取j-i的最小值就OK辣。判断不同的数字完全可以用桶解决

可能我的语文差了一点，具体看我的代码吧（好难表述啊QAQ）

```cpp
#include<cstdio>
const int N=1000005,M=2017;
int a[N],b[M],n,m,l,r=1<<30;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1,j=0,k=0;i<=n;i++) //枚举区间[i,j]
    {
        while(k<m) //枚举j找到包含m个不同元素的区间[i,j].（k表示不同的数的个数）
        {
            j++; //小细节：j初值为0，提前自增，避免了一些麻烦
            if(j>n) break;
            if(b[a[j]]==0) k++; //此数未出现过,k++
            b[a[j]]++;
        }
        if(k==m&&r-l>j-i) l=i,r=j; //修改最小值
        b[a[i]]--; //i+1前将第i个数移出区间
        if(b[a[i]]==0) k--; //如果此数在[i,j]中只出现一次并且现在被移出，那么k--
    }
    printf("%d %d",l,r); //最后输出答案区间，结束~
}
```

---

## 作者：jins3599 (赞：6)

## 题目大意

给定一个有$n$个数的序列，有$k$种数，求一段最小的区间使得包括所有k种数字。

$1\le n\le 1000000$

## 思路

本质上是一个双指针的线性算法。

我们还是考虑两个变量$l,r$，对于$r$对应的每一个$l$，感性理解来说他们是正相关的。

再通俗一点，就是说$r$越大，对应的$l$不会更小。

我们就可以从1到n枚举每一个$r$，然后使$\ l\ $尽可能的向后即可。

最后统计一下答案即可。

$Code :$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1000000 + 10;

int n , m , a[maxn] , cnt , ansl , ansr , tot = 0x7fffffff;
int flag[maxn];

int main () {
    scanf("%d%d" , &n , &m);
    for(int i = 1 ; i <= n ; ++ i) scanf("%d" , a + i);
    int l = 1 , r = 1; 
    for(r = 1 ; r <= n ; ++ r) {
        if(!flag[a[r]]) cnt ++; flag[a[r]] ++;
        while(flag[a[l]] > 1) {flag[a[l]] --; l ++;}
        if(cnt == m) {if(r - l + 1 < tot) tot = r - l + 1 , ansl = l , ansr = r;}
        
    }
    printf("%d %d" , ansl , ansr);
    return 0;
}
```

---

## 作者：Hanzire76 (赞：5)

# 思路
维护一个队列，不断读入，开一个数组记录每个画家在队列中有多少画，记录队列中画的种类个数，如果到了m种，就开始出队，一直出队，直到画的数量减一，停止出队。此时队列里的元素数量+1就是答案的区间长度，更新一下左右端点，然后继续进队出队，直到遍历完整个序列，得到最优解。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;

const int N=1000005;
int n,m,cnt[2005],kin,minn=0x7fffffff,a,b;

queue<int> q;

int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		cnt[x]++;
		if(cnt[x]==1) kin++;
		q.push(x);
		if(kin==m)
			while(1)
			{
				int y=q.front();
				cnt[y]--;
				q.pop();
				if(cnt[y]==0)
				{
					kin--;
					if(q.size()+1<minn)
					{
						minn=q.size()+1;
						b=i;
						a=i-q.size();
					}
					break;
				}
			}
	}
	cout<<a<<" "<<b<<endl;
	return 0;
}
```


---

## 作者：cabasky (赞：3)

与P2564的思想是相近的 用类似链表的方式存储每一幅画的下一幅同画师的画的位置

刚开始把每一个画师的画的最开始的位置存进单调队列（队首元素最大） 然后初始的答案就是（1，队首元素）

接下来枚举每一个开始的位置，用上面的方式，新的答案为（i，队首元素）

这次统计完答案以后，把i这幅画去掉，用之前处理出来的邻接表把下一幅和i同画师的画的位置加到单调队列里去，这样就保证了你统计的画里边一定有所有画师的画，并且是以i为起点的最优解。

比如样例：

2 5 3 1 3 2 4 1 1 5 4 3

第一次     2 5 3 1       4

第二次        5 3 1    2 4

第三次           3 1    2 4       5

第四次              1 3 2 4       5

第五次                 3 2 4 1    5

第六次                    2 4 1    5   3

第七次 开始的2后面没有2了 就停止了吧

最后一个加进来的数是用单调队列来算的

预计复杂度O（n） 给出AC代码



```cpp
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstdlib>
using namespace std;
#define MAXN 1000010
#define    MAXM 1010
int last[MAXM],yest[MAXN],a[MAXN],used[MAXM],tot,n,m;
void adde(int pos,int col){
    yest[pos]=last[col];
    last[col]=pos;
}
struct monotonic_queue{
    int head,tail,flag;
    int line[MAXN];
    void init(int f){
        head=1;
        tail=0;
        flag=f;
    }
    void push(int x){
        while(head<=tail&&x*flag>line[tail]*flag) tail--;
        line[++tail]=x;
    }
    int headx(){return line[head];}
}maxq;
int main(){
    maxq.init(1);
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=n;i>=1;i--) adde(i,a[i]);
    for(int i=1;i<=n;i++){
        if(!used[a[i]]){
            maxq.push(i);
            used[a[i]]=1;
            tot++;
        }
        if(tot==m) break;
    }
    int min=MAXN,ma,mb;
    for(int i=1;i<=n;i++){
        if(maxq.headx()-i<min){
            min=maxq.headx()-i;
            ma=i;
            mb=maxq.headx();
        }
        last[a[i]]=yest[i];
        if(!last[a[i]]) break;
        maxq.push(last[a[i]]);
    }
    printf("%d %d\n",ma,mb);
    return 0;
}
```

---

## 作者：Right (赞：3)

>>新手题解，请多包涵
>>p'用来记录图画 >>flag表示画家
        
            
```cpp
#include <cstdio>
int p[1000002],flag[2008];
int a,b,n,m;
int main()
{
    int i,head,ans;
    int x;
    head=1; ans=200000000;
    scanf("%d%d",&n,&m);
    for (i=1; i<=n; ++i)
    {
        scanf("%d",&p[i]);  >>节省时间，把读入和计算放在一起
        if (flag[p[i]]==0)
          m--;
        flag[p[i]]++;
        while ((head<i) && ((p[head]==p[i]) || (flag[p[head]]>1))) 
        {
            flag[p[head]]--;
            head++;
         } 
        if ((m==0) && (i-head+1<ans))
        {
            ans=i-head+1;  //cost=i-head+1
            a=head;
            b=i;
         } 
    }
    printf("%d %d\n",a,b);
}
```

---

## 作者：汇文客 (赞：3)

使用队列结构，依次将数据插入队列，如果队头与队尾相同，或队头在队列中出现超过一次，就将它删掉。动态统计队列长度，取最小者。

```delphi

var q:array[1..1000000]of longint;
    v:array[1..2000]of longint;
    n,m,i,x,f,ans,s,t:longint;
begin
  readln(n,m);  
  f:=1;ans:=maxlongint;
  for i:=1 to n do
  begin
    read(x);
    if v[x]=0 then dec(m);
    inc(v[x]);q[i]:=x;
    while(f<i)and((q[f]=x)or(v[q[f]]>1))do
    begin
      dec(v[q[f]]);
      inc(f);
    end;
    if(m=0)and(i-f+1<ans)then
    begin
      ans:=i-f+1;
      s:=f;
      t:=i;
    end
  end;
  writeln(s,' ',t);
end.

```

---

## 作者：灰白骨 (赞：3)

72ms，加个读入优化可以更快
```cpp
#include<bits/stdc++.h>
using namespace std;
int ls1=1,ls2,to=0x7f7f7f7f,jl1,jl2=0x7f7f7f7f,m,n,js[1000010],tong[2010];
int main()
{
	int k=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&js[i]);
		ls2=i;
		if(tong[js[i]]==0)k++;//k记录当前的人的数量
		tong[js[i]]++;//当前编号桶++
		while(ls2!=ls1&&js[ls2]==js[ls1]||tong[js[ls1]]>1)//缩减
		{
			tong[js[ls1]]--;
			ls1++;
		}
		if(k==m&&ls2-ls1<jl2-jl1)
		{
			jl2=ls2;
			jl1=ls1;
		}
	}
	printf("%d %d",jl1,jl2);
}
```

---

## 作者：Ofnoname (赞：3)

这道题的基本思路就是与单调队列类似的尺取法，即不断将右端点右移，并在条件合适时将左端点左移，并实时更新最优解。不过对于这个端点判断条件，我与其他的题解写的不太一样，我使用了一个M大小的数组T，像桶一样实时保存每个数的出现次数，若这个数在以后已经出现过，就右移左端点。

```cpp
#include <bits/stdc++.h>
#define MAXN (1000000+50)
#define MAXM (2000+50)
using namespace std;

int N,M,cnt,x=1,L,R,ans=0x7fffffff,T[MAXM],d[MAXN];
//x相当于左端点。

inline void read(int &a)
{
    register char c=getchar();
    for (a=0; c<'0'||'9'<c; c=getchar());
    for (; '0'<=c && c<='9'; c=getchar())
        a=(a<<3)+(a<<1)+(c^48);
}

int main()
{
    read(N); read(M);
    for (register int i=1; i<=N; i++)
    {//这里的i就相当于右端点
        read(d[i]); T[d[i]]++;//记录这个数出现过一次。
        if (T[d[i]]==1) cnt++;//加完1之后才是1，说明是一个新数字
        while (T[d[x]]>1) //如果现在的左端点出现超过一次
            T[d[x]]--, x++;//出现次数减1，左端点向右移动
		//注意，cnt这里不能减1，因为这个数还是出现过至少一次的。
        if (cnt==M && ans>i-x+1)//数字的种类够了，并且比之前的答案更短
        //ans>i-x+1中没有取等，这样出现一样长但更靠后的答案就不会更新，符合答案要求。
			ans=i-x+1, L=x, R=i;//更新答案
    }
    printf("%d %d",L,R);
    return 0;
}
```



---

## 作者：abandentsky (赞：2)

思路：直接就是滑动窗口模板题。不断让窗口增大，知道窗口中不同的元素到m个为止，这个时候窗口的右端点继续向前移动，移动的同时，我们可以移动左端点。整个过程一定要保证不同的元素个数为m。与此同时只要不断更新窗口的最小值就好了。为了表示元素不同，我们使用STL中map来处理。这个题和刘汝佳书中《不同的雪花》一模一样。

```c
#include<stdio.h>
#include<iostream>
#include<string>
#include<map>
using namespace std;

map<int,int> K;
int n,m,sum;
int val[MAXN];
int minn,pos;

int main()
{
    scanf("%d %d",&n,&m);
    int Left=1;
    int Right=1;
    minn=INF;
    sum=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&val[i]);
        if(!K.count(val[i]))  //只是为了初始化窗口，使得不同元素个数满足m个
        {
            K[val[i]]=0;
            sum++;
        }
        K[val[i]]++;
        //Right++;
        if(sum==m)
        {
            while(K[val[Left]]>1)   //让左端点滑动，全程保持不同的元素个数为m个。
            {
                K[val[Left]]--;
                Left++;
            }
            if(minn>(i-Left)+1)
            {
                minn=i-Left+1;
                pos=Left;
            }
        }
    }
    printf("%d %d\n",pos,pos+minn-1);//minn是区间长度
    return 0;
}
```



---

## 作者：Sober_Clever (赞：2)

出篇题解试试~

二分区间长度L，检查是否存在长度为L的区间使得所有大师都在这个区间内

~~代码有点长，排版一般，诸位谅解~~
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=1000000 + 2;
const int MAXM=2000 + 2;
int pic[MAXN]={0},cnt[MAXM]={0},n,m,a,b;
//cnt[i]表示大师i在当前区间内出现了多少次
//cnt1表示当前区间内一共出现了几个大师
inline bool check(int mid)
{
	int cnt1=0;
	memset(cnt,0,sizeof(cnt));
	for(int i=1;i<=mid;i++)
	if(!cnt[pic[i]])
		++cnt[pic[i]],++cnt1;
	else
		++cnt[pic[i]];
	if(cnt1==m) {a=1,b=mid;return true;}
	for(int i=mid+1;i<=n;i++)
	{
		int x=pic[i-mid],y=pic[i];
		--cnt[x];
		if(!cnt[x])
			--cnt1;
		if(!cnt[y])
			++cnt1;
		++cnt[y];
		if(cnt1==m) {a=i-mid+1,b=i;return true;}
	}
	return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&pic[i]);
	int l=0,r=n,ansa,ansb;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))
		{
			ansa=a,ansb=b;
			r=mid-1;
		}
		else
			l=mid+1;
	}
	printf("%d %d\n",ansa,ansb);
	return 0;
}
```

---

## 作者：浮尘ij (赞：1)

这题可以直接用桶来做，而且不比单调队列慢。


以下是代码,实测36ms。





```cpp
#include<iostream>
#include<cstdio>
#include<bits/stdc++.h>
using namespace std;
const int INF=0x7f7f7f7f;
const int MAXN=1000005;
const int MAXM=2005;
int s[MAXN],p[MAXM];//s存每一幅画的画师 ，p是一个桶p[i]表示当前区间里 画师i 的画有多少幅； 
int N,M;
int read()//加了读入优化大概可以快30毫秒左右 
{
    int n=0;char ch=getchar();
    while(ch<'0'||'9'<ch)ch=getchar();
    while(ch>='0'&&ch<='9'){n=n*10+ch-'0';ch=getchar();}
    return n;
}
void init()//读入 
{
    cin>>N>>M;
    for(int i=1;i<=N;i++)
        s[i]=read();
}
void work()
{
    int i=1,j=1;//区间左端点：i，区间右端点：j 
    int ans=INF,kind=0;//kind表示当前区间里画的种数（即，有哪些画师的画）为多少 
    int a,b;
    for(;i<=N;i++)
    {
        for(;j<=N;j++)
        {
            if(kind==M)break;//第一次满足条件就跳出 
            if(!p[s[j]])
                kind++;
            p[s[j]]++;
        }
        if(kind==M&&j-i<ans)//统计答案 
        {
            ans=j-i;
            a=i;
            b=j-1;
        }
        p[s[i]]--;//把区间最左端的画给删掉 
        if(!p[s[i]])kind--;//修改kind 
        if(j==N)break;
    }
    cout<<a<<' '<<b<<endl;//输出 
}
int main()
{
    init();
    work();
    return 0;
}
```

---

## 作者：LoliconAutomaton (赞：1)

有点小激动啊，居然是提交的人里最快的

一定是优化输入输出的原因。orz优化。

开个队列模拟一下，当队列的长度等于m时就和上一次的比较。从左到右扫描，扫到的a一定是最小的。







```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn = (int)1e6 + 10, maxm = 2010, INF = 0xfffff;
int n, m;
int painting[maxn], artist[maxm];
int front = 1, tail = 0, l, r, ans = INF;
inline char getc(void){
    static char buf[1000000], *p1 = buf, *p2 = buf;
    if(p1 == p2){
        p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);
        if(p1 == p2) return EOF;
    }
    return *p1++;
}
inline void read(int& x){
    x = 0; int f = 1; char ch = getc();
    for(;!(ch>='0'&&ch<='9');ch=getc()) if(ch == '-') f = -1;
    for(;(ch>='0'&&ch<='9');x=x*10+ch-'0', ch=getc());
    x *= f;
}
inline void write(int x){
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main()
{
    read(n); read(m);
    for(int i=1;i<=n;i++){
        int x;
        read(x);
        if(artist[x] == 0) tail++;
        ++artist[x];
        painting[i] = x;
        while(front < i && artist[painting[front]] > 1){
            --artist[painting[front]];
            front++;
        }
        if(tail == m)
            if(ans > i-front+1){
                ans = i - front + 1;
                l = front, r = i;
            }
    }
    write(l); putchar(' '); write(r);
}
```

---

## 作者：xuan__xuan (赞：1)

本题是到好题啊，我拿小号交拿了90，最后一个超时

其实本题这样做，我们要二分枚举序列长度logn的，然后一个队列，分别从头扫到尾部O（n），然后判断O（m）

时间复杂度就是（logn \*N\* M）由于这是不可达的 ，然后搞一点小优化啊，或许能卡一卡，然而这并没有什么用。这是90分的暴力





    
    

    
        
        
   
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN1 = 1000005;
const int MAXN2 = 2005;
int N,M,K = (1 << 30);
int S[MAXN2],data[MAXN1]; 
int L[MAXN1]; 
void init(){
    scanf("%d%d",&N,&M);
    for(int i = 1; i <= N; i++)
    {
       scanf("%d",&data[i]);
       L[i] = (1 << 30);
    }
}
int check(int P)
{
    int Q[MAXN2];
    int Ans = (1 << 30);
    memset(Q,0,sizeof(Q));
    int Head = 1,Tail = P;
    for(int i = 1; i <= P; i++)
        Q[data[i]]++;
    while(Tail <= N)
    {
        int F = 1;
        for(int i = 1; i <= M; i++)
            if(Q[i] == 0)
            {
                F = 0; break;
            }
        if(F == 1){Ans = Head;break;}
        else
        {
            Q[data[Head]]--;
            Head++;
            ++Tail;
            Q[data[Tail]]++;
        }
    }
    if(Ans != (1 << 30))
    {
        L[P] = min(L[P],Ans);
        return 1;
    }
    else 
        return 0;
}
int main(){
    init();
    int i = M,j = N;
    while(i <= j)
    {
        int mid = (i+j) / 2;
        if(check(mid) == 1)
        {
           j = mid - 1;
        }
        else 
           i = mid + 1;
    }
    printf("%d %d",L[j+1],j+1+L[j+1]-1);
    return 0;
}
```
然后我们可以想到，我们能不能不判断序列是否合法呢？我们可以用一个值记录
如果原来这个数有0个，现在变成1个则多了一种画

如果原来这个数有1个，现在变成0个则少了一种画

所以维护的时候，只需要维护画的种数即可





    
    

    
        
        
   



```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN1 = 1000005;
const int MAXN2 = 2005;
int N,M,K = (1 << 30);
int S[MAXN2],data[MAXN1]; 
int L[MAXN1]; 
void init(){
    scanf("%d%d",&N,&M);
    for(int i = 1; i <= N; i++)
    {
       scanf("%d",&data[i]);
       L[i] = (1 << 30);
    }
}
int check(int P)
{
    int Q[MAXN2],Num = 0;
    int Ans = (1 << 30);
    memset(Q,0,sizeof(Q));
    int Head = 1,Tail = P;
    for(int i = 1; i <= P; i++)
    {
        Q[data[i]]++;
        if(Q[data[i]] == 1)
           Num++;//维护种数的变量。
    }
    while(Tail <= N)
    {
        int F = 0;
        if(Num == M) F = 1;
        if(F == 1){Ans = Head;break;}
        else
        {
            Q[data[Head]]--;
            if(Q[data[Head]] == 0)
               Num--;
            Head++;
            ++Tail;
            Q[data[Tail]]++;
            if(Q[data[Tail]] == 1)
               Num++;
        }
    }
    if(Ans != (1 << 30))
    {
        L[P] = min(L[P],Ans);
        return 1;
    }
    else 
        return 0;
}
int main(){
    init();
    int i = M,j = N;
    while(i <= j)
    {
        int mid = (i+j) / 2;
        if(check(mid) == 1)
        {
           j = mid - 1;
        }
        else 
           i = mid + 1;
    }
    printf("%d %d",L[j+1],j+1+L[j+1]-1);
    return 0;
}

```

---

## 作者：thwfhk (赞：1)

队列，虚拟的front和tail，用flag和size保存当前某个元素出现次数和当前不同元素有多少，队首出现过front++行了 size==m时更新答案（其实第一次size==m后以后size不会减少）


    
        
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N=1e6+5,M=2005;
inline int read(){
    char c=getchar(); int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int n,m,q[N];
int flag[M],front=1,tail=0,size=0,ans=1e9,ans1,ans2;
int main(int argc, const char * argv[]) {
    n=read();m=read();
    for(int i=1;i<=n;i++) q[i]=read();
    for(int i=1;i<=n;i++){
        if(flag[q[i]]==0) size++;
        ++tail;
        flag[q[i]]++;
        while(flag[q[front]]>=2) {flag[q[front]]--;front++;}
        if(size==m&&(tail-front+1)<ans){//printf("q %d %d\n",front,tail);
            ans1=front;ans2=tail;ans=tail-front+1;
        }
    }
    cout<<ans1<<" "<<ans2;
    return 0;
}
```

---


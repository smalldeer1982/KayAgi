# 「RiOI-03」匀速相遇

## 题目背景

当大家都在加速时，我与你，在人生中的十字路口，匀速地相遇了。

确是惊动我心的一瞥，却是无法逗留的遗憾，我们再次，朝着自己的方向匀速奔跑。下次再见，又会是什么时候呢……

## 题目描述

平面直角坐标系上有 $n + m$ 个点，其中：

- 有 $n$ 个 $\rm A$ 类点，它们在初始时依次位于位置 $(1, 0), (2, 0), (3, 0), \dots, (n, 0)$。
- 有 $m$ 个 $\rm B$ 类点，它们在初始时依次位于位置 $(0, 1), (0, 2), (0, 3), \dots, (0, m)$。

在某一个时刻，$\rm A, B$ 类点同时开始运动。具体地：

- 对于第 $i$ 个 $\rm A$ 类点，其以 $a_i$ 个单位长度每秒的速度向上（即 $y$ 轴正方向）匀速运动。特别地，若 $a_i = 0$，则该点始终保持静止。
- 对于第 $i$ 个 $\rm B$ 类点，其以 $b_i$ 个单位长度每秒的速度向右（即 $x$ 轴正方向）匀速运动。特别地，若 $b_i = 0$，则该点始终保持静止。

相遇与分离实在是再平凡不过的了。作为匆匆时光里的一名过客，在这个你暂留的驿站里，你能否帮小 T 解决这个简单的问题：求出有多少点对会在某个时刻相遇，即它们在某一刻共点。

由于你无法使时间静止，所以所有点无论相遇与否，都会永无止境地运动下去。祝愿在这道路上奔跑的你，能有一天与理想匀速相遇，永不停息。

## 说明/提示

### 样例解释 1

当 $t = 1$ 时，第 $2$ 个 $\rm A$ 类点和第 $2$ 个 $\rm B$ 类点同时到达点 $(2, 2)$。这也是在本组样例中的唯一一次相遇，故输出 $1$。

### 数据规模与约定

**本题开启捆绑测试。**

+ Subtask 0（10 pts）：$n \leq 10$，$m \leq 10$。
+ Subtask 1（20 pts）：$n \leq 5\times 10^3$，$m \leq 5\times 10^3$。
+ Subtask 2（30 pts）：保证 $\forall a_i \geq 1$，$\forall b_i \geq 1$。
+ Subtask 3（40 pts）：无特殊限制。

对于所有数据，$1 \leq n, m \leq 10^6$，$0 \leq a_i, b_i \leq 10^9$。

## 样例 #1

### 输入

```
3 3
1 2 3
3 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
2 5 1
83 101 98```

### 输出

```
0```

# 题解

## 作者：cff_0102 (赞：13)

假设第 $i$ 个 A 类点和第 $j$ 个 B 类点会在第 $t$ 秒在 $(i,j)$ 相遇，则必须满足 $t\times a_i=j,t\times b_j=i$，故 $t=\dfrac{j}{a_i}=\dfrac{i}{b_j}$（这里暂且假设 $a_i,b_j$ 不为 $0$），再交叉相乘得到 $i\times a_i=j\times b_j$。

所以只需要在输入数组 $a$ 时记下所有 $i\times a_i$，然后在输入数组 $b$ 的时候看看有几个 $i$ 满足 $i\times a_i=j\times b_j$（有几个 $i$ 满足这个等式，就有几个 A 类点会和这个 B 类点相遇），最后再加到记录答案的变量 $s$ 上。

不要忘了特判 $a_i=0$ 和 $b_j=0$ 的情况，此时这个点原地不动，也不可能和其它点相遇。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1145141],b[1145141];
unordered_map<long long,int> ai;
int main(){
    ios::sync_with_stdio(false);
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]!=0){
            long long temp=1ll*i*a[i];
            ai[temp]++;//ai[temp] 存的是满足 i*a_i=temp 的 i 的个数
        }
    }
    long long s=0;
    for(int j=1;j<=m;j++){
        cin>>b[j];
        if(b[j]!=0){
            long long temp=1ll*j*b[j];
            if(ai.count(temp)){//如果有 i 满足 i*a_i=j*b_j
                s+=ai[temp];//则将满足等式的 i 的个数加到答案中
            }
        }
    }
    cout<<s;
    return 0;
}
```

---

## 作者：20111019Yu (赞：3)

## 思路
### 暴力
我们容易可以发现任何 $a_{i}$ 与 $b_{j}$ 之间都最多相交一次。

于是我们可以枚举每一对 $a_{i}$ 和 $b_{j}$，判断是否能相交。

主要判断部分：

```cpp
   for( int i = 1; i <= n; i++ ){
      for( int j = 1; j <= m; j++ ){
          if(i / b[j] == j / a[i]){
              ans++;
          }
      }
   }
```
时间复杂度：$\mathcal{O}(n^2)$
### 优化
暴力的时间明显超时，所以我们优化。

我们看看判断语句，可以发现等式左右两边同时乘以 $a_{i}\times b_{j}$ 就可以变成 $a_{i}\times i=b_{j}\times j$。

所以我们就可以用 unordered_map 来存储值。

### Code

```cpp
#include <iostream>
#include <unordered_map>
#define int long long
using namespace std;
int n, m, a, b, ans;
unordered_map<int, int> mp;

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for( int i = 1; i <= n; i++ ){
		cin >> a;
		mp[a * i]++;
	}
	for( int i = 1; i <= m; i++ ){
		cin >> b;
		ans += !b ? 0 : mp[b * i]; 
	}
	cout << ans;
	return 0;
}
```
时间复杂度：$\mathcal{O}(n)$
### 注意

map 常数太大

要判断不能为零

---

## 作者：WZWZWZWY (赞：3)

设横、纵坐标上两个点坐标分别为 $(i,0),(0,j)$，速度为 $a[i],b[j]$。

如果它们要相遇，那么相遇时各自走的时间一定，因为是同时出发。路程除以速度等于时间，则 $\frac{j}{a[i]}=\frac{i}{b[j]}$（速度不为 $0$），交叉相乘得 $a[i]\times i=b[j]\times j$。

那么我们只要找出有多少组数据（自己的坐标与速度的乘积）相等即可。

代码就很好写了。

```
#include <bits/stdc++.h>
using namespace std;
int n, m;
unordered_map <long long, int> a;
signed main() {
	cin >> n >> m;
	long long x, ans = 0;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		a[x * i]++;
	}
	for (int i = 1; i <= m; i++) {
		cin >> x;
		if (x) ans += a[x * i]; // 速度不能为0，否则永远不可能相遇
	}
	cout << ans;
}
```

---

## 作者：wanglexi (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9914)

简单推公式题。

假设第 $i$ 个 $A$ 类点和第 $j$ 个 $B$ 类点相遇了，看看能得到什么东西。

- 首先，$a_i$ 和 $b_j$ 一定都 $>0$，不然这俩爷其中 $1\sim 2$ 个动都不动，别提相遇了；

- 相遇点一定在 $(i,j)$，因为只有这里两个点都会经过。

- 相遇意味着到达时间相同，所以 $\dfrac{i}{a_j}=\dfrac{j}{a_i}$，两边同时乘上 $(a_i\cdot a_j)$ 也就是 $i\cdot a_i=j\cdot a_j$。

每个点的情况只和自己有关！

所以说，只要算出所有 $i\cdot a_i$ 和所有 $j\cdot a_j$，然后给排个序，用双指针或者二分找两个新数组中相同数的个数就行了。

时间复杂度：算 $i\cdot a_i$ 和 $j\cdot a_j$ 是 $O(n+m)$，排序是 $O(n\log n+m\log m)$，最后用双指针的话是 $O(n+m)$，二分的话是 $O(n\log n+m\log m)$，加起来是 $O(n\log n+m\log m)$。

两种复杂度本质没有区别，但是第一种常数会小一些。

另外，最后的答案最多是 $n\times m$，所以要开 long long。

贴上 AC 代码：

双指针（O2,514毫秒）
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define ll long long
#define pb emplace_back
using namespace std;
ll n,m,a[1000005],b[1000005],ans,cnt1,cnt2;//cnt1和cnt2分别统计a和b中0的个数
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i],a[i]*=i,cnt1+=(a[i]==0?1:0);
	for(int i=1;i<=m;i++)cin>>b[i],b[i]*=i,cnt2+=(b[i]==0?1:0);
	sort(a+1,a+n+1);sort(b+1,b+m+1);//0放到最前面，保证后面的单调性
	for(int p1=cnt1+1,p2=cnt2+1,p3=cnt2+1;p1<=n;p1++){//p1遍历a，p2是b中第一个大于a[i]的，p3是b中第一个大于等于a[i]的
		while(p2<=m&&b[p2]<=a[p1])p2++;//不满足条件就++ 
		while(p3<=m&&b[p3]<a[p1])p3++;
		ans+=p2-p3;
	}
	cout<<ans;
	return 0;
}
```

二分（O2,641毫秒）
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define ll long long
#define pb emplace_back
using namespace std;
ll n,m,a[1000005],b[1000005],ans,cnt1,cnt2;//cnt1和cnt2分别统计a和b中0的个数
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i],a[i]*=i,cnt1+=(a[i]==0?1:0);
	for(int i=1;i<=m;i++)cin>>b[i],b[i]*=i,cnt2+=(b[i]==0?1:0);
	sort(a+1,a+n+1);sort(b+1,b+m+1);//0放到最前面，保证后面的单调性
	for(int i=cnt1+1;i<=n;i++)ans+=upper_bound(b+cnt2+1,b+m+1,a[i])-lower_bound(b+1,b+m+1,a[i]);
   //用b中第一个大于a[i]的指针减去第一个大于等于的，就是相等的个数
	cout<<ans;
	return 0;
}
```

---

## 作者：xiaoshumiao (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9914)

## $30$ 分做法

设有一个 $A$ 类点 $i$ 和一个 $B$ 类点 $j$。如果与他们相遇，肯定在 $(i,j)$ 处相遇。点 $i$ 和点 $j$ 到 $(i,j)$ 所需时间分别是 $\dfrac{j}{a_i}$ 和 $\dfrac{i}{b_j}$。所以我们可以得到：

$$\dfrac{j}{a_i}=\dfrac{i}{b_j}$$

根据交叉相乘法可得：

$$a_i \times i=j \times b_j$$

于是我们可以得到如下代码：
```cpp
#include<cstdio>
using namespace std;
const int MAXN=1000005,MAXM=1000005;
int a[MAXN],b[MAXM];
int main() {
  int n,m;
  scanf("%d %d",&n,&m);
  for(int i=1;i<=n;i++)
  	scanf("%d",&a[i]);
  for(int i=1;i<=m;i++)
  	scanf("%d",&b[i]);
  long long cnt=0;
  for(int i=1;i<=n;i++) {
  	for(int j=1;j<=m;j++) {
  	  if(a[i]==0||b[j]==0)
  	    continue;
  	  if(i*a[i]==j*b[j])
  	  	cnt++;
  	}
  }
  printf("%lld",cnt);
  return 0;
}
/**************************************************************
    Problem: P9914
    User: xiaoshumiao
    Language: C++
    Result: 时间超限
    Time:3.43 s
    Memory:8.04 mb
****************************************************************/
```
该代码的时间复杂度为 $\Theta(n \times m)$，无法通过 $1\le n,m \le10^6$ 的数据。我们需要优化。

## $100$ 分做法
注意到每次相当于在找有几个 $j$ 满足 $a_i \times i=j \times b_j$，因此考虑二分。设 $c_i=i \times b_i$，则可以在读入是将 $c_i$ 算出来，每次就从 $c$ 中查找 $i \times a_i$ 第一次出现的位置，然后用 while 循环统计 $i \times a_i$ 的个数。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1000005,MAXM=1000005;
int a[MAXN];
long long c[MAXM];
int erfen(long long x,int n) {//二分查找第一次出现的位置。
  int l=1,r=n;
  while(l<r) {
    int mid=(l+r)/2;
    if(c[mid]>=x)
      r=mid;
    else
      l=mid+1;
  }
  if(c[l]==x)
    return l;
  return -1;
}
int main() {
  int n,m,b;
  scanf("%d %d",&n,&m);
  for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
  for(int i=1;i<=m;i++) {
    scanf("%d",&b);
    c[i]=1LL*i*b;
  }
  sort(c+1,c+m+1);
  long long cnt=0;
  for(int i=1;i<=n;i++) {
    if(a[i]==0)
      continue;
    int ans=erfen(1LL*i*a[i],m);
    if(ans==-1)//没有找到，跳过。
      continue;
    while(ans<=m&&c[ans]==1LL*i*a[i]) {//统计个数。
      cnt++;
      ans++;
    }
  }
  printf("%lld",cnt);
  return 0;
}
/**************************************************************
    Problem: P9914
    User: xiaoshumiao
    Language: C++
    Result: 正确
    Time:801 ms
    Memory:11.87 mb
****************************************************************/
```
时间复杂度 $\Theta(\max(m \log m,n \log m))$，足以通过本题。

---

## 作者：Shadows_of_Twilight (赞：3)

这题在赛场是卡了我好久。

## 思路
首先，这些人是可以在非整数时间相遇的。

拿样例来说：  
![](https://cdn.luogu.com.cn/upload/image_hosting/bp6hisj6.png)

数字是速度，字母是我命名的编号。

为什么点 $D$ 不能和点 $A$ 在 $(1,1)$ 相遇呢。  
因为他们到达的时间不一样。

而点 $E$ 和点 $B$ 能在 $(2,2)$ 相遇因为他们到达那里的时间一样。

由此可以得出**暴力代码**。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005],b[1000005];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int j=1;j<=m;j++){
		cin>>b[j];
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i]!=0&&b[j]!=0&&1.0*i/b[j]==1.0*j/a[i])ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

如果两个点到达某个点时间一样，那么它们可以相遇。如下面这样的式子。

$$i \div b_j = j \div a_i $$

既然只要判断是否相等，那就用 `unordered_map`。

`unordered_map` 是 `map` 的变种，可以统计个数，但是不保证有序。

为了方便所以给式子移项。得到的式子如下。

$$i \times a_i = j \times b_j$$

接下来只需要将 $i \times a_i$ 丢进 `unordered_map` 里面计数，再看看里面有多少个 $b_j \times j$，加上就好了。

注意 $i \times a_i$ 时 $a_i$ 是否等于 $0$ 无所谓，但是 $j \times b_j$ 时 $b_j$ 必须不等于 $0$。

## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,a[1000005],b[1000005],ans;
unordered_map<int,int>mp;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int j=1;j<=m;j++){
		cin>>b[j];
	}
	for(int i=1;i<=n;i++){
		if(a[i]!=0)mp[a[i]*i]++;
	}
	for(int j=1;j<=m;j++){
		if(b[j]!=0)ans+=mp[b[j]*j];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：50lty12 (赞：3)

偷偷帮 lyt 上分但是没 Rated 应该不会惨遭制裁吧......

---

数学题。

我们假设 $x$ 轴上点 $i$ 会与 $y$ 轴上点 $j$ 相遇，那么有：

- $t \times a_{i}=j$

- $t \times b_{j}=i$

两式相除得到 $\frac{a_{i}}{b_{j}}=\frac{j}{i}$，交叉相乘得 $i \times a_{i}=j \times b_{j}$，所以开个 ```unordered_map``` 处理即可，因为 ```map``` 会被卡。

细节在于运动速度为 $0$ 的情况，虽然乘积相等但永远不会相遇，特判掉即可。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 1000005
int n,m,i,j,ans;
int a[N],b[N];
unordered_map<int,int>mp;
signed main(){
	scanf("%lld%lld",&n,&m);
	for(i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(i=1;i<=m;i++) scanf("%lld",&b[i]);
	for(i=1;i<=m;i++) if(b[i]) mp[i*b[i]]++;
	for(i=1;i<=n;i++) if(a[i]) ans+=mp[i*a[i]];
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：minVan (赞：3)

**解题思路**

首先是暴力做法，不难想到枚举 $i\in[1,n],j\in[1,m]$，对于时刻 $t$，第 $i$ 个 $\text{A}$ 类点与第 $j$ 个 $\text{B}$ 类点如果能相遇，则 $a_i\neq0,b_i\neq0$ 且 $t\times a_i=j,t\times b_j=i$，两式相乘得：$a_i\times i=b_j\times j$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], b[N];
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for(int i = 1; i <= m; i++) {
    cin >> b[i];
  }
  int ans = 0;
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= m; j++) {
      if(a[i] && b[j] && i * a[i] == j * b[j]) {
        ++ans;
      }
    }
  }
  cout << ans / 2;
  return 0;
}
```

接着想正解。显然，$a_i\times i$ 可以提前预处理个数，然后在输入 $b_i$ 是答案加上 $mp_{b_i\times i}$，但是 $b_i=0$ 时无法移动，于是单独处理即可。

但是，如果用 map 的话，会带上一个 $\log_2n$，所以要用时间复杂度 $\mathcal{O}(1)$ 的 unordered_map。

最后注意要开 long long。

**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], b[N];
unordered_map<int, int> mp;
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 1; i <= n; i++) {
    cin >> a[i];
    ++mp[a[i] * i];
  }
  int ans = 0;
  for(int i = 1; i <= m; i++) {
    cin >> b[i];
    ans += (!b[i] ? 0 : mp[b[i] * i]);
  }
  cout << ans;
  return 0;
}
```

---

## 作者：_O_v_O_ (赞：2)

先讲一下 $30$ 分思路，暴力能更好理解正解。

首先暴力 $a$ 和 $b$（设 $a$ 枚举到了 $a_i$，$b$ 枚举到了 $b_j$）根据小学奥数可得：若 $a_i\div j=b_j\div i$ 则合法，令答案计数器 $+1$ 即可。

可这样会炸精度，怎么办呢？

我们可以用小学数学知识：让除变乘，即让等式变为 $a_i\times i=b_j\times j$ 即可。

------------
$30$ 分讲完来讲正解。

首先，我们发现上面等式在变化后等式左边只有 $i$，右边只有 $j$，所以 $i,j$ 不会影响各自。

所以我们可以记录下每个 $a_i\times i$ 的数量，到 $b$ 时将答案加上 $b_i\times i$ 对应的数量。

注意不能记 $b_i=0$ 时的答案。

但是开数组空间太大了，于是我们只能用 `unordered_map` 完成。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n,m;
int a[1000005],b[1000005],ans;
unordered_map<int,int> mp;

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		mp[a[i]*i]++;
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
		if(b[i]!=0) ans+=mp[b[i]*i];
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Ice09 (赞：2)

### 前言

[题目链接](https://www.luogu.com.cn/problem/P9914)，[或许更好的阅读体验](https://www.luogu.com.cn/blog/RubbishRhapsody/p9914-ti-xie)。

### 题目思路

如果两个点能相遇，那么它们要满足什么条件？

设有一个 $A$ 类点 $A_x(x,0)$ 和一个 $B$ 类点 $B_y(0,y)$，其中 $A_x$ 的速度为 $a_x$，$B_y$ 的速度为 $b_y$。我们假设它们会相遇，并在第 $t$ 个时刻相遇。那么就能得到下面这张图（有点丑陋，不过应该能看得懂）：

![](https://cdn.luogu.com.cn/upload/image_hosting/l4xtzq0q.png)

于是能得到：

$$\begin{cases}
	x=b_y \cdot t\\
	y=a_x \cdot t
\end{cases}$$

由此我们可以推出：

$$\begin{cases}
	t= \frac {x} {b_y}(b_y \ne 0)\\
	t= \frac {y} {a_x}(a_x \ne 0)
\end{cases}$$

于是有：

$$\frac {x} {b_y} = \frac {y} {a_x}(a_x \ne 0,b_y \ne 0)$$

然后：

$$a_x \cdot x = b_y \cdot y(a_x \ne 0,b_y \ne 0)$$

现在，思路就很清晰了，遍历 $a$ 数组时，把每个 $a_i \times i$ 给记录下来，后来遍历 $b$ 数组时，看看有多少个 $b_i \times i$ 相同的 $a_i \times i$ 即可。当然，$a_i,b_i$ 可能等于 $0$，不过这样的点是永远不会与其他点相遇的，所以我们特判一下，把它排除就行了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 7;
int n, m;
long long a[N], b[N];
unordered_map<long long, int> mp;
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (a[i] != 0)
		mp[a[i] * i]++;
	}
	int ans = 0;
	for (int i = 1; i <= m; i++) {
		cin >> b[i];
		if (b[i] != 0)
		ans += mp[b[i] * i];
	}
	cout << ans;
	return 0;
}
```

时间复杂度 $\Theta(n)$ 或 $\Theta(m)$。

---

## 作者：FurippuWRY (赞：2)

样例给的提示比较少，于是自己造了一些。

设点的速度为 $v$。

设有点 $A(2,0),B(3,0),C(0,6)$，它们的速度分别为 $v_A=3,v_B=2,v_C=1$，$A$ 与 $C$，$B$ 与 $C$ 都可以相遇，发现一点：$v_A \times x_A=v_B \times x_B=v_C \times y_C=6$。

于是可以推测：对于 $\text{A}$ 类点，设 $p=x\times v_\text A$；对于 $\text{B}$ 类点，设 $q=y\times v_\text B$。如果 $p=q$，那么它们可以相遇。

知道了这一点，那么就可以把每个点的横坐标或纵坐标乘上对应的速度，并寻找相等结果的个数，输出即可。

但是 $O(nm)$ 的暴力枚举肯定不行，$n,m\in[1,10^6]$，会超时。这时可以用 multiset 开一个集合，存储**值不为 $0$ 的** $a_i\times v_{a_i}$（若值为 $0$，那么它根本动不了，就不用存进去），然后查找与 $b_i\times v_{b_i}$ 的值相同的元素个数，并且累加，最后输出即可。

需要稍微卡一下常，我这份代码[能过](https://www.luogu.com.cn/record/138929986)，但有时候因为评测机的问题，会超 [0.01~0.03s](https://www.luogu.com.cn/record/139273654)，可以打个[快读快写优化](https://www.luogu.com.cn/record/138884021)一下。

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

ll n, m, a, b, ans = 0;
multiset<ll> x;

int main() {
	
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (ll i = 1; i <= n; ++i) {
        cin >> a;
        a *= i;//横坐标乘速度
        if (a != 0) x.insert(a);//若不为 0，则加入集合中
    }
    for (ll i = 1; i <= m; ++i) {
        cin >> b;
        b *= i;//纵坐标乘速度
        ans += x.count(b);//统计相等元素的个数。
    }
    cout << ans;

	return 0;
}
```

---

## 作者：Eason_cyx (赞：1)

RiOI 的题目都非常赞啊！

做这道题，首先我们思考：对于点 $i$ 和点 $j$，怎么判断它们是否能相遇？（注意：相遇的时刻**不一定是整数，坑点**）

那么很显然，只要 $\large\frac{j}{a_i}=\frac{i}{b_j}$ 即可。

根据交叉相乘积相等，上式可转换为 $a_i\times i=b_j\times j$。

那么只需要 $O(n)$ 扫一遍 $a$，统计 $b$ 里面有多少个 $a_i \times i$ 即可。

注意 map 常数比较大，想要卡过去有点难度；所以我们改用 unordered_map。

```cpp
#include <iostream>
#include <unordered_map>
inline int read(){
	int n=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10^48);
	return;
}
int a[1000005],b[1000005];
std::unordered_map<long long,int> mp;
int main() {
	int n,m; n = read(); m = read();
	for(int i = 1;i <= n;i++) {
		a[i] = read();
	}
	for(int i = 1;i <= m;i++) 
	{
		b[i] = read();
		if(b[i] == 0) continue;
		mp[1ll*b[i]*i]++;
	}
	int cnt = 0;
	for(int i = 1;i <= n;i++) {
		if(a[i] == 0) continue;
		cnt += mp[1ll*a[i]*i];
	}
    write(cnt);
	return 0;
}
```

---

## 作者：LuoFeng_Nanami (赞：1)

考虑相遇的条件。

对于第 $i$ 个 $\text{A}$ 类点与第 $j$ 个 $\text{B}$ 类点，先假设这两个点能够相遇，则设他们相遇的时间为 $x$，由题意可得
 $$\begin{cases} a_i \times x = j \\ b_j \times x = i \end{cases}$$ 
整理一下可以得到
 $$\begin{cases} x = \frac{j}{a_i}\\x = \frac{i}{b_j} \end{cases}$$ 
 $$\therefore \frac{j}{a_i} = \frac{i}{b_j}$$ 
十字相乘可得
 $$a_i \times i = b_j \times j$$ 
用一个桶记录 $a_i \times i$，再在 $\text{B}$ 数组中查询即可。

需要注意的是，移速为 $0$ 的点需要额外排除。

### AC Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rll register ll
#define F(i,a,b) for(rll i=a;i<=b;i++)
#define Fdn(i,a,b) for(rll i=a;i>=b;i--)
#define int ll

using namespace std;

const int inf = 0x3f3f3f3f,mod = 1e9 + 7; 
const int maxn = 1e6 + 7;

int n, m;
int a[maxn], b[maxn];
int ans;
unordered_map<int , int> mp;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	F(i, 1, n){
		cin >> a[i], a[i] *= i;
		if(a[i] != 0)
			++mp[a[i]];
	} 
	F(i, 1, m) {
		cin >> b[i], b[i] *= i;
		if(b[i] != 0)
			ans += mp[b[i]];
	}
	
	cout << ans << endl;
	
	return 0;
}```

---

## 作者：Graph (赞：0)

题意跳过。

### 思路

对于一个二元组 $1 \le i \le n,1 \le j \le m$，要使 $i,j$ 满足，那么相遇的点一定在 $(i,j)$，根据路程除以速度等于时间，那么 $i$ 的时间为 $\frac{i}{b_j}$，$j$ 需要的时间是 $\frac{j}{a_i}$，那么使得满足需要 $\frac{i}{b_j}=\frac{j}{a_i}$，转化一下就是 $i \times a_i=j \times b_j$，利用 `unordered_map` 为桶去维护即可。

注意特判 $0$ 的情况。

### 代码

贴上我的赛时代码：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+5;
int n,m,a[N],b[N],ans;
unordered_map<int,int>tot;

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x!=0)
			tot[i*x]++;
	}
	for(int i=1;i<=m;i++)
	{
		int x;
		cin>>x;
		if(x!=0)
			ans+=tot[i*x];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Wf_yjqd (赞：0)

评橙差不多吧。

------------

显然第 $i$ 个 A 类点和第 $j$ 个 B 类点只可能在 $(i,j)$ 相遇。

而两点相遇需要满足到达的时间相同。

列出以下式子，$\frac{i}{b_j}=\frac{j}{a_i}(a_i\neq0,b_j\neq0)$。

移项得到，$a_i\times i=b_j\times j$。

map 维护即可，复杂度 $\operatorname{O}(n\log n)$。

------------

记得判断 $a_i=0$ 或 $b_j=0$ 的情况。

由于三叉树卡常，所以用了 gp_hash_table，这样的话复杂度是 $\operatorname{O}(n)$。

放个代码。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
namespace Sherry_I{
    inline int read(){
        char c=getchar();
        int x=0;
        while(c<'0'||c>'9')
            c=getchar();
        while(c>='0'&&c<='9'){
            x=x*10+c-'0';
            c=getchar();
        }
        return x;
    }
}
const int maxn=1e6+84;
int n,m,a[maxn],b[maxn];
gp_hash_table<ll,int> mp;
ll ans;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
        scanf("%d",&b[i]);
    for(int i=1;i<=n;i++)
        if(a[i])
            mp[1ll*i*a[i]]++;
    for(int i=1;i<=m;i++)
        if(b[i])
            ans+=mp[1ll*i*b[i]];
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：I_will_AKIOI (赞：0)

考察数学和哈希。

通过 Win 自带的高级计算器功能，我们获得了一张反比例函数的图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/08a0iveo.png)

横轴就是 $A$ 类点，纵轴就是 $B$ 类点，图像上的每个点就是他们相遇的位置。

根据反比例函数的特性，每个矩形的大小相等。就可以得出结论：

$$a_i\cdot i=b_j\cdot j$$

当满足条件时，就说明会相遇。

### 做法一：map

用 map 记录 $a_i\cdot i$ 出现的次数，遍历 $b$ 数组，他们的积是 $b_j\cdot j$。最后将答案加上 $vis_{b_j\cdot j}$ 就行了。注意当 $j=0$ 时，是不可能相遇的，得排除掉。

但是这种方法由于常数过大，加上 fread 等多种卡常手段都会 TLE。我交了十几发才获得了 $60pts$。

[link](https://www.luogu.com.cn/record/138906884)

### 做法二：哈希

既然会超时，我们就用哈希做咯。

将模数设定为 $122420729$，最大化利用空间。然后你就会发现后面两个子任务全 WA。随机模数也不行，都会被卡。

[link](https://www.luogu.com.cn/record/138857740)

### 做法三：哈希表

为了防止重复，我们用哈希表来做。这下空间开销比较大，模数小一点，定义成 $9191891$。将数据插入哈希表中，放在对应的位置。

```
n=read(),m=read();
for(int i=1;i<=n;i++) a[i]=read(),v[i*a[i]%mod].push_back(i*a[i]);//插入
v[0].clear();//为0不可能相遇
```

接下来，想访问哪个，就遍历对应的 vector 数组就行。

```
for(int i=1;i<=m;i++)
{
  b[i]=read();
  int num1=i*b[i]%mod,num2=i*b[i],l=v[num1].size();
  for(int j=0;j<l;j++) if(v[num1][j]==num2) ans++;//找到对应的数，答案增加
}
```

我们就在赛时轻松 A 了一道黄题。

---

## 作者：zzy0618 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P9914)

## 解题思路

首先，如果一个 $A$ 类点与一个 $B$ 类点相遇，这个点的坐标一定是 $(X_A,Y_B)$。

我们只要计算这两个点到达相遇点的时间，判断是否相同。也就是 $j\div a_i=i\div b_j$。但是由于除法的不稳定，可以转这个式子为 $a_i\times i=b_j\times j$。当然，这样的复杂度是 $O(nm)$。

考虑另开一个 ```map```，储存所有 $b_i\times i$ 的值，随后直接求 $\sum^n_{i=1} map_{a_i\times i}$，这样的复杂度是 $O(n\log a)$ 的。但是赛时发现有点[卡常](https://www.luogu.com.cn/record/138926741)，只要换成 ```unordered_map```，就可以通过了。

## 完整代码

这里要注意 $a_i=0$ 的情况，因为一个点不动，它不会与任何一个点相遇。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,m,ans;
int a[N],b[N];
unordered_map<int,int> mp;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=1;i<=m;++i)
		cin>>b[i],++mp[i*b[i]];
	for(int i=1;i<=n;++i){
		if(a[i]==0)continue;
		ans+=mp[i*a[i]];
	}
	cout<<ans;
	return 0;
}
```

---


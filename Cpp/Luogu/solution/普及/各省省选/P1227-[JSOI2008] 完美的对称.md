# [JSOI2008] 完美的对称

## 题目描述

在峰会期间，必须使用许多保镖保卫参加会议的各国代表。代表们除了由他自己的随身保镖保护外，组委会还指派了一些其他的特工和阻击手保护他们。为了使他们的工作卓有成效，使被保卫的人的安全尽可能得到保障，保镖被分配到被保护人的各个方向。

保镖的最佳站立位置应该是这样的：被保护人应站在所有保镖的对称中心。但是，只要被保护人一移动，保镖就很难根据要人的新位置调整位置。大多数的特工都很难对此作出实时调整。

因此，安全部长决定将该过程逆转一下，保镖先站好自己的位置，然后要人在他们的对称中心找到合适的位置。如果要人随便走动，我们就对他的安全不必负责。

你的工作是使这个过程自动操作。给出一组 $N$ 个点（保镖的位置），你要找出它们的对称中心 $S$，在这儿被保护人将相对安全。下面以此类推。

首先我们给定一点 $A$ 以及对称中心 $S$，点 $A'$ 是点 $A$ 以 $S$ 为对称中心形成的像点，即点 $S$ 是线段 $AA'$ 的对称中心。

点阵组（$X$）以 $S$ 为中心的像点是由每个点的像点组成的点阵组。$X$ 是用来产生对称中心 $S$ 的，即点阵 $X$ 以 $S$ 为中心的像点的集合即为点阵 $X$ 本身。

![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)


## 说明/提示

JSOI2008 第二轮。


## 样例 #1

### 输入

```
8
1 10
3 6
6 8
6 2
3 -4
1 0
-2 -2
-2 4
```

### 输出

```
V.I.P. should stay at (2.0,3.0).```

# 题解

## 作者：盖矣斌峥 (赞：17)


[本人博客](https://prime.design.blog/)

   我们将点按照一定顺序排序（按x、y从小到大、从大到小都行）
//作者是按照y从小到大排的

   然后很容易能想到y最小的一定是和y最大的进行匹配
   
   所以就遍历一遍已经排好的序列，用求中点的公式求出中点（相信大家都会）
   ```
	point tmp;
	tmp.x=(a[i].x+a[n-i+1].x)/2.0;
	tmp.y=(a[i].y+a[n-i+1].y)/2.0;
```
   再判断一下每组匹配的中点是否一样就行了

------------

因为n有可能是奇数，所以在循环的时候

i=1~(n+1)/2

也就是判了一下最中间那个保镖是否就站在被保护人的位置


------------

见代码：


```
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct point{
	double x,y;
}a[20005];
int n;
bool cmp(point &x,point &y)
{
	if(x.y==y.y)return x.x<y.x;
	return x.y<y.y;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);
	point t;
	t.x=(a[1].x+a[n].x)/2.0;
	t.y=(a[1].y+a[n].y)/2.0;
	for(int i=1;i<=(n+1)/2;i++)
	{
		point tmp;
		tmp.x=(a[i].x+a[n-i+1].x)/2.0;
		tmp.y=(a[i].y+a[n-i+1].y)/2.0;
		if(t.x!=tmp.x||t.y!=tmp.y){
			printf("This is a dangerous situation.");
			return 0;
		}
	}
	printf("V.I.P. should stay at (%.1f,%.1f).",t.x,t.y);
	return 0;
}
```


---

## 作者：我是小何子啊 (赞：8)

# **解题思路：**
##### 这道题要求的很明确，只要找到一个完美的对称点即可。
那么在这些点的坐标中，要使VIP点存在，就要坐标大的点配对坐标小的点，**这样才能使其中点相对于其他两两相配对点的中点相近。**
那我们可以用sort排序，先算坐标最大的点和坐标最小的点的中点，再枚举其他“大点”和“小点”的中点。
##### 如果其中点也最大点和最小点的中点不相同，证明在最优情况下中点都不相同，就无解。否则最后输出其中点即可！

**代码：**
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
struct node{//用结构体方便排序
	double x,y;//记得用double
}f[100001];
bool cmp(node x,node y)
{
	if(x.y==y.y) return x.x<y.x;
	return x.y<y.y;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%lf%lf",&f[i].x,&f[i].y);
	sort(f+1,f+n+1,cmp);//sort排
   	//中点公式：两点坐标之和除以二
	double mx=(f[1].x+f[n].x)/2;//mx记录其中点的横坐标
	double my=(f[1].y+f[n].y)/2;//my记录其纵坐标
	for(int i=2;i<=n/2;++i){
		double xi=(f[i].x+f[n-i+1].x)/2;//同上，记录大点和小点的中点
		double yi=(f[i].y+f[n-i+1].y)/2;
		if(mx!=xi||my!=yi){//如果不等于，证明无解，直接结束
			printf("This is a dangerous situation!");
			return 0;
		}
	}
	printf("V.I.P. should stay at (%.1f,%.1f).",mx,my);//否则输出其中点
	return 0;
}
```


---

## 作者：YitsuHolo (赞：6)

这道题的思路比较清晰  

1）想办法找到对称中心 

2）验证对称中心是否对所有点满足

找对称中心相信不是什么难事，只要取横纵坐标极限的中点即可，
但是我们还需要去验证对称中心，然而原序列是无序的，验证只能O(n^2)暴力，为了优化自然想到排序，在这里，我们先按横坐标排，如果相等，则按纵坐标排，这样我们枚举到i时，就可以与n+1-i进行比较，以O(n)的时间复杂度验证

具体代码如下：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const double eps=0.0000001;
struct node
{
	double x,y;
};
node point[20010];
int n;
node mid;
double maxx=-10000000,maxy=-10000000,minx=10000000,miny=10000000;

bool cmp1(node a,node b)
{
	if(a.x>=b.x+eps || a.x<=b.x-eps)
		return a.x<b.x;
	else
		return a.y<b.y;
}
int main()
{
	scanf("%d",&n);
	double xx,yy;
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&xx,&yy);
		maxx=max(maxx,xx);
		maxy=max(maxy,yy);
		minx=min(minx,xx);
		miny=min(miny,yy);
		point[i].x=xx;
		point[i].y=yy;
	}
	mid.x=(minx+maxx)/2;
	mid.y=(miny+maxy)/2;
	sort(point+1,point+n+1,cmp1);
	for(int i=1;i<=n/2+n%2;i++)	//有保镖为单数的情况
	{
		double tx1=point[i].x;
		double ty1=point[i].y;
		double tx2=point[n+1-i].x;
		double ty2=point[n+1-i].y;
		if( (tx1+tx2)/2 < mid.x-eps || (tx1+tx2)/2 > mid.x+eps || (ty1+ty2)/2 < mid.y-eps || (ty1+ty2)/2 > mid.y+eps )
		{
			printf("This is a dangerous situation!");
			return 0;
		}
	}
	printf("V.I.P. should stay at (%.1lf,%.1lf).",mid.x,mid.y);
	
	return 0;
}
```

---

## 作者：向こう側の月 (赞：4)

用优先队列思想的题解

用两个优先队列来分别存储横坐标和纵坐标。当然，优先队列的好处就是会自动排序，而且快。

然后把队列里的内容存入数组，这时候所有点的数据已经是排好队的了

然后把x最大和x最小的平均值算出来与x第二大和x第二小的平均值比较，一直比较到中间点。

若有不同则输出这被保人翘班了。

y也是一样的。

最后若是没有不同，也就是中心连线全在一点，

就直接输出坐标就完了。坐标就是最大x，y和最小x，y的平均值。

代码如下：

```cpp
#include <iostream>
#include <queue>
#include <iomanip>
using namespace std;
priority_queue<double> x;
priority_queue<double> y; 
int main()
{
    double xx[20001],yy[20001];     //据说这一点很坑。很多人这里用整形结果答案有小数就有问题了，所以我用了double。
    int num;      //保镖总数。
    int bx,by;
    cin>>num;
    int i;
    for(i=0;i<num;i++)
    {
        cin>>bx>>by;
        x.push(bx);       //数据存入队列。
        y.push(by);
    }
    i=0;
    while(!x.empty())
    {
        xx[i]=x.top();       //队列数据转入数组。
        yy[i]=y.top();
        x.pop();
        y.pop();
        i++;
    }
    int j,k;
    j=1;k=num-2;
    while(j<=k)
    {
        if((xx[j]+xx[k])/2!=(xx[j-1]+xx[k+1])/2)      //若是x的中心有不一样的，下面的y也是一样的。
        {
            cout<<"This is a dangerous situation!";
            return 0;
        }
        if((yy[j]+yy[k])/2!=(yy[j-1]+yy[k+1])/2)
        {
            cout<<"This is a dangerous situation!";
            return 0;
        }
        j++;k--; 
    }
    cout<<setiosflags(ios::fixed)<<setprecision(1)<<"V.I.P. should stay at ("<<(xx[0]+xx[num-1])/2<<","<<(yy[0]+yy[num-1])/2<<").";
    return 0;
}
```

---

## 作者：A天天t (赞：3)

#不需要排序的算法，但需要数学和运气 // 比较快，起码目前记录里好像是最快的


数学：

1.首先假设如果存在这样的一个点。那么他的坐标(x0,y0)一定是每一组点坐标(xi,yi),(xi',yi')的1/2,即（x0\*2=xi+xi')，（y0\*2=yi+yi');

（这个好像都知道，~~，下一句是重点）。 由此得知如果把所有点都加在一起，那么它的坐标是所有点坐标的1/n  !

哈哈，所以只要把所有点都加在一起除n就可以找到中心点了；

2.可是，他还要求在每组点连线的中间，这时候就很尴尬了, ![](https://cdn.luogu.com.cn/upload/pic/6313.png) ，如图所示，不管怎么画，中心点不会在边上，所以需要找一组点来判断一下，那么找最大和最小的两个点好了（他们一定是一组!!），只需要读入的时候记录一下就好，（但是我也不知道为何只要着一组点来验证就可以了，所以说是运气，哈哈）；

代码如下

‘’‘

pascal





```cpp
type
int=longint;
var n,i:int;
xx,yy,x1,y1,xa,xi,ya,yi:real;
x,y:array[0..20000]of real;
function round1(x:real):real;
begin 
x:=x*10;
 x:=round(x);
 exit(x/10);
end;
begin 
readln(n);     xi:=maxlongint; yi:=maxlongint;
for i:=1 to n do
    begin 
readln(x1,y1);
x[i]:=x1;
y[i]:=y1;
xx:=x1+xx;
yy:=y1+yy;
if xi>x[i] then xi:=x[i];if yi>y[i] then yi:=y[i];
if xa<x1 then xa:=x1; if ya<y1 then ya:=y1;
    end;
if ((xi+xa)*n<>2*xx)or((yi+ya)*n<>2*yy) then 
begin
writeln( 'This is a dangerous situation!');
exit;
end;
writeln('V.I.P. should stay at (',round1(xx/n):0:1,',',round1(yy/n):0:1,').'); 
end.
```
'''



---

## 作者：LJY_ljy (赞：2)

### 这道题的思考难度不大。


------------
## 1.思路分析：

我们为什么要按x坐标或者y坐标排序呢？

考虑这些点的x坐标（y坐标）$x_1$，$x_2$，$x_3$,$\cdots$,$x_n$。将这n个数从小到大排序。

根据中点坐标公式：对于∀点$(x_i, y_i)$和点$(x_j, y_j)$, 都有$(x_i, y_i)$ 和 点$(x_j, y_j)$的中点坐标为：（$\dfrac{x_i +  x_j}{2}$, $\dfrac{y_i + y_j}{2}$)。

若最小的 $x_1$ 不和最大的$x_n$搭配，则$x_n$一定会和一个比$x_1$大的数进行匹配，不妨设为$x_i$。

则$x_1$会和一个比$x_n$小的数进行匹配，不妨设为$x_j$。

∵ $x_n > x_j$ 且 $x_i > x_1$ ∴ $x_n + x_i > x_1 + x_j$ 即 $\dfrac{x_n + x_i}{2} > \dfrac{x_1 + x_j}{2}$ 所以两两不搭配，矛盾！

所以最小的$x_1$一定要和最大的$x_n$进行搭配，次小的数也要和次大的数进行搭配。y坐标也同理。

### ∴这道题要排序（本蒟蒻对y坐标排序，对x坐标排序也一样）。





------------

## 2.代码实现：

### 我们如何判断这些保镖都关于一个点对称呢？

我们可以先提前算出最小的$(x_1, y_1)$和最大的$(x_n, y_n)$的中点坐标$(tx = \dfrac{x_1 + x_n}{2}, ty = \dfrac{y_1 + y_n}{2})$。

然后再依次配对，如果有一组配对得出的答案和提前算好的$(tx, ty)$不等，则出现了矛盾。

### 如果程序到了最后没有出现矛盾，则成功了，根据题目要求输出$(tx, ty)$就行辣。


------------


## 关键的Code:

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <iomanip>
using namespace std;

int n;
struct node {
	int x, y; 
} a[20200];

int cmp(node p,node q) { // 普通的结构体排序的cmp函数，当然在结构体里写重载运算符也珂以。
	if(p.y == q.y) return p.x < q.x; // 也要判断y坐标相等的情况。
	return p.y < q.y;
} 

inline int read() { //快读，没啥话好说。
	register int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
} 

void init() { // 为了使主函数看起来更简便，则把主函数中的代码放到一个单独的函数里，方便检查。
	int i, j;
	double tx, ty, px, py;
	cin >> n; 
	for(i = 1; i <= n; i++) 
		cin >> a[i].x >> a[i].y;
	sort(a + 1, a + n + 1, cmp);// 对结构体进行y坐标排序。
	tx=(a[1].x + a[n].x + (0.0))/2;
	ty=(a[1].y + a[n].y + (0.0))/2; //注意整数除以2不一定是整数，int转double要和0.0一起操作。
	for(i = 1,j = n;i <= j; i++,j--) { //类似于two-pointers.
		px = (a[i].x + a[j].x + (0.0))/2;
		py = (a[i].y + a[j].y + (0.0))/2;
		if(px != tx || py != ty) {
			printf("This is a dangerous situation!\n"); //此时已出现矛盾。
			return;
		}
	}
	cout<<"V.I.P. should stay at ("<<fixed<<setprecision(1)<<tx<<","<<fixed<<setprecision(1)<<ty<<")."<<endl; //没有出现矛盾，根据题目要求输出即可。
}

int main() {
	init();//在主函数里调用。
	return 0;
}
```

---

## 作者：不是憨憨 (赞：2)

好了，想写个题解。其实这题也就是排序。

（1）假设我们先将横坐标排序（当然不能这样），然后就会发现，如果存在对称中心的话，横坐标一定是排序后的最大的横坐标和最小的横    坐标之和的二分之一。

（2）同理，（假设）我们将纵坐标排序，然后可以得到理想中的对称中心，再进行检验。

（3）说这么多只是想说明对称中心是可以确定的，然后我就写了一个sort的cmp函数。

```cpp
         int cmp(coordinate a, coordinate b) {
              if (a.x != b.x) return a.x < b.x;
              if (a.y != b.y) return a.y < b.y;
              return 0;
                  }
```
这里用了一下结构体（不要说结构体名字奇怪），好了其实也就是这么回事。
根据横坐标和纵坐标同时排序而已。

（分割线）------------------------------------------------------------------------------------------------------------------------------------------------------------

代码如下：


```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
struct coordinate {
    int  x;
    int y;
}a[20001];
int cmp(coordinate a, coordinate b) {
    if (a.x != b.x) return a.x < b.x;
    if (a.y != b.y) return a.y < b.y;
    return 0;
}
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d%d",&a[i].x, &a[i].y);
    }
    sort(a, a+n,cmp);
    double p = (a[0].x+a[n-1].x)/2.0;
    double q = (a[0].y+a[n-1].y)/2.0;
    int flag1 = 1;
    for (int i = 2; i < n; i++) 
     if ((a[i-1].x + a[n-i].x)/2.0 != p || (a[i-1].y+a[n-i].y)/2.0 != q) {
         printf("This is a dangerous situation!\n");
         flag1 = 0;
         break;
         }
    if (flag1 == 1) printf("V.I.P. should stay at (%.1f,%.1f).\n",p,q);
    return 0;
}
```

---

## 作者：z3475 (赞：1)

我们可以找出横坐标与纵坐标最大的点和最小的点，他们连起来的线段的中点显然是对称点(对于有对称点的情况)

但怎么判断没有对称点的情况呢?我们可以去掉上述说的俩点，再找出横坐标与纵坐标最大的点和最小的点，检查连起来的线段的中点符不符合上一次的情况。

显然找最大和最小的点可以使用排序(比较函数一定要写对)，上C++代码(24ms过)

不要抄题解

```cpp
#include <bits/stdc++.h>
using namespace std;
struct point{
    int x,y;
}p[20001];  //普通点
struct pointf{
    double x,y;
};              //存对称点(对称点可能是浮点数)
int n;
bool cmp(const point &a,const point &b){
    if (a.x==b.x)
        return a.y>b.y;
    return a.x>b.x;
}  //比较函数，x大的点在前面,相等就按y来排
int main() {
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        scanf("%d%d",&p[i].x,&p[i].y);
    sort(p+1,p+1+n,cmp);//排序
    int l=2,r=n-1;//左右2点对应
        //以下初始化当前情况的中点
    pointf center;
    center.x = ((p[1].x+p[n].x)/2.0f);
    center.y = ((p[1].y+p[n].y)/2.0f);
        //以下开始检查对称点对不对
    while (l<r){
        if (center.x!=((p[l].x+p[r].x)/2.0f)||center.y!=((p[l].y+p[r].y)/2.0f))
            {printf("This is a dangerous situation!");return 0;}
        l++,r--;
    }
        //保留俩位输出
    printf("V.I.P. should stay at (%.1f,%.1f).",center.x,center.y);
    return 0;
}
```

---

## 作者：睿屿青衫 (赞：1)

#之前所有的输入都是int（因为题目全是整数）

##输出“貌似”没错误，结果错点是：保留一位小数，第二位四舍五入！

###结构体排个序，不会tle，还很准确，代码很清楚了，大家看一下弄明白，不要抄袭。

```cpp
#include<iostream> 
#include<cstdio>
#include<algorithm>
#include<cstring>
#define maxn 200000
#define ll long long
using namespace std;
int n;
double mx,my;
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         x=x*10+ch-'0';
         ch=getchar();
     }
    return x;
}
struct qq
{
    double x;
    double y;
}a[maxn];
int cmp(qq aa,qq bb)
{
    if(aa.x!=bb.x) return aa.x<bb.x;
    if(aa.y!=bb.y) return aa.y<bb.y;
```
}//小值优先，往后二重循环你就会懂
```cpp
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;//n是整数 
    for(int i=1;i<=n;++i)
     cin>>a[i].x>>a[i].y;//结构体，准备排序，降低复杂度 
    sort(a+1,a+n+1,cmp);//排序（自定义函数决定排序规则） 
    mx=a[1].x+a[n].x;//既然排好了，那第一个横坐标最小，n个最大 
    my=a[1].y+a[n].y;//同理，用double（考虑输出） 
    for(int i=1;i<=n;++i)
     {
         if((a[i].x+a[n+1-i].x!=mx)||(a[i].y+a[n+1-i].y!=my))
```
{//已经排好序，复杂度大大降低，如果有一点不满足，那么不对称
```cpp
           printf("This is a dangerous situation!");
            return 0;}//输出不对称，正常退出程序 
     }
    printf("V.I.P. should stay at (%.1f,%.1f).",mx/2,my/2);
    return 0;//否则的话，四舍五入输出，退出程序 
}
```

---

## 作者：Sky001231 (赞：1)

//这一题就是求一些点的中心对称,没有中心对称则This is a dangerous situation!

//求一些点的中心对称只要每2个配对求平均数即可

  
  
```cpp
//配对方法:排序
//  坐标(x,y),以x为第1关键字,y为第2关键字或者以y为第1关键字,x为第2关键字排序都可以
//  排序后第1个点对应最后1个,第2个点对应倒数第2个,以此类推
//  求坐标平均数即可
//坐标平均数唯一则输出V.I.P. should stay at (坐标).,否则This is a dangerous situation!
//已经讲的很清楚了,这一题太简单没什么好讲,pascal代码如下
var
  n,i:longint;
  x,y:extended;
  a:array[1..20000,1..2] of longint;
procedure sort(l,r:longint);
var
  i,j,temp,mid1,mid2:longint;
begin
  i:=l;
  j:=r;
  mid1:=a[(l+r) div 2,1];
  mid2:=a[(l+r) div 2,2];
  while i<j do
  begin
    while (a[i,1]<mid1) or ((a[i,1]=mid1) and (a[i,2]<mid2)) do
      i:=i+1;
    while (a[j,1]>mid1) or ((a[j,1]=mid1) and (a[j,2]>mid2)) do
      j:=j-1;
    if i<=j then
    begin
      temp:=a[i,1];
      a[i,1]:=a[j,1];
      a[j,1]:=temp;
      temp:=a[i,2];
      a[i,2]:=a[j,2];
      a[j,2]:=temp;
      i:=i+1;
      j:=j-1;
    end;
  end;
  if l<j then
    sort(l,j);
  if i<r then
    sort(i,r);
end;
begin
  readln(n);
  for i:=1 to n do
    readln(a[i,1],a[i,2]);
  sort(1,n);
  x:=(a[1,1]+a[n,1])/2;
  y:=(a[1,2]+a[n,2])/2;
  for i:=2 to (n+1) div 2 do
    if ((a[i,1]+a[n-i+1,1])/2<>x) or ((a[i,2]+a[n-i+1,2])/2<>y) then
    begin
      writeln('This is a dangerous situation!');
      exit;
    end;
  writeln('V.I.P. should stay at (',x:0:1,',',y:0:1,').');
end.
```

---

## 作者：蒟蒻CGZ (赞：0)

# P1227 [JSOI2008]完美的对称

## 题目传送门

[P1227](https://www.luogu.org/problem/P1227)

[jvluo的博客](https://www.luogu.org/blog/cgz2006/#)

## 思路：

1.首先假设如果存在符合题目要求的一个点。那么他的坐标(x0,y0)一定是每一组点坐标（[xi,yi]、[xi',yi']）之和的1/2,即（x0*2=xi+xi')，（y0*2=yi+yi');（重点：） **可得把所有点都加在一起，那么它的坐标是所有点坐标的1/n !**

ok，所以只要把所有点都加在一起除n就可以找到中心点了；

2.需要找一组点来判断一下，那么找最大和最小的两个点好了（他们一定是一组），只需要读入的时候记录一下就好。（预处理：先sort一遍所有的点（按x坐标从大到小排，如果x坐标相等，就按照y坐标））

## 有坑：
输出要保留一位小数，也就是说要用double or float型，不能用int。

错误：printf(“%d.0”,ans);  

正确: printf(“%.1lf”,ans);

好啦好啦，上代码

```
#include<bits/stdc++.h>
using namespace std;
int n,i,j;
double sx=0,sy=0,maxy=-999999,miny=999999,maxx=-999999,minx=999999;//有坑有坑，要用double 
struct point{
	double x,y;
}a[20010];
bool cmp(const point &a,const point &b){
    if (a.x==b.x)
        return a.y>b.y;
    return a.x>b.x;
}
int main(){
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		sx+=a[i].x;sy+=a[i].y; 
	}
	sort(a+1,a+1+n,cmp);
	point ans;
	ans.x=sx/n;ans.y=sy/n;
	if(ans.x==(a[1].x+a[n].x)/2&&ans.y==(a[1].y+a[n].y)/2)
		printf("V.I.P. should stay at (%.1lf,%.1lf).\n",ans.x,ans.y);
	else printf("This is a dangerous situation!\n");
	return 0;
天我居然AC了
}
```


---

## 作者：不存在之人 (赞：0)

若存在最优解，那么对坐标序列进行多关键字排序后，第$1$个肯定和第$n$个对应。

同理，第$2$个肯定和第$n-1$个对应。多列几个就会发现第$i$个应该和第$n-i+1$个对应。

我们要做到就是看看对应的每组得到的安全坐标是否相同。

------------
### Code：
```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n;
struct js
{
    int x,y;
    bool operator<(const js &b)
	const
	{
		return x<b.x||(x==b.x&&y<b.y);
	}
}a[(int)2e4+5];
double ans1,ans2;
void GG()
{
	printf("This is a dangerous situation!");
	exit(0);
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1);
    int L=2;
    ans1=(a[1].x+a[n].x)/2.0;
    ans2=(a[1].y+a[n].y)/2.0;
    while (L<=n>>1)
    {
        if (ans1!=(a[L].x+a[n+1-L].x)/2.0) GG();
        if (ans2!=(a[L].y+a[n+1-L].y)/2.0) GG();
        L++;
    }
    printf("V.I.P. should stay at (%.1lf,%.1lf).",ans1,ans2);
    return 0;
}
```


---


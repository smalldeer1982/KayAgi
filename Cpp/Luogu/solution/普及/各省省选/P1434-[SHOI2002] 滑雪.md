# [SHOI2002] 滑雪

## 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：
```plain
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。

## 说明/提示

对于 $100\%$ 的数据，$1\leq R,C\leq 100$。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

### 输出

```
25```

# 题解

## 作者：Rainy7 (赞：768)

### 本题关键字：记忆化搜索。
**首先，这题为什么会想到记忆化？(知道的人直接跳过)**

在dfs每种情况是，可能这个点之前已经搜过了，没必要再去搜索了，因此不如存储记住，就没必要再去dfs了。


------------
本题的主要思路：

**1.先去想dfs怎么做：**

这题每个点出发有可能，所以我们每个点都要开始dfs，最后取他们的最大值。

dfs部分和类似的迷宫差不多,用两个数组表示4个方向：
```
dx[4]={0,0,1,-1};
dy[4]={1,-1,0,0};
```
改变方向直接xx=x+dx[i] , yy=y+dy[i]

接下来判断这个方向是否在地图范围内，即
```
if(xx>0&&xx<=R&&yy>0&&yy<=C)
```

当然还要判断这个点是否能滑到，也就是高度要前一个低：
```
if(a[xx][yy]<a[x][y])//a为高度
```
很明显，因为低的不可能滑向高的，所以我们不需要再开一个数组去记录这个点是否走过。

接下来，就要往四个方向搜索，取四个方向中距离最长的，然后+1，这就是这个点的结果了。

**2.记忆化搜索怎么写**

很显然，直接dfs会TLE。那么就需要记忆化来优化。

用s[i][j]表示从(i,j)点出发能走的最长距离。

每次搜索一次记忆一次即可。

下面给刚接触不怎么明白的人举例：(已经理解的人跳过)

由于样例不好讲我自己举例子：
```
3 3 
1 1 3
2 3 4
1 1 1
```
先去找(1,1)的最长距离，很明显为1

接着找(1,2)的最长距离，很明显为1

接着找(1,3)的最长距离，为2((1,3)->(1,2))

然后找(2,1)的最长距离，为2((2,1)->(1,1))

然后是(2,2)的最长距离，如果没有记忆化，那么搜索过程为：(2,2)->(2,1)->(1,1)

但是（2,1）之前已经搜过了，再去搜就是浪费时间，之前搜索已经知道(2,1)的值为2，那么搜索过程就是缩短为：(2,2)->(2,1),即为3


------------
下面附上我的代码：
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int n,m,a[201][201],s[201][201],ans;
bool use[201][201];//这个就是所谓的不需要
int dfs(int x,int y){
    if(s[x][y])return s[x][y];//记忆化搜索
    s[x][y]=1;//题目中答案是有包含这个点的
    for(int i=0;i<4;i++)
    {  int xx=dx[i]+x;
       int yy=dy[i]+y;//四个方向
       if(xx>0&&yy>0&&xx<=n&&yy<=m&&a[x][y]>a[xx][yy]){
       	  dfs(xx,yy);
          s[x][y]=max(s[x][y],s[xx][yy]+1);
       }
    }
    return s[x][y];
}
int main()
{	
   scanf("%d%d",&n,&m);//同题目的R,C
   for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
       scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)//找从每个出发的最长距离
      for(int j=1;j<=m;j++)
        ans=max(ans,dfs(i,j));//取最大值
    printf("%d",ans);
    return 0;
}
// by 路人七
```


---

## 作者：TLE自动机 (赞：273)

  ### priority_queue+dp      32ms
这题思路不难，把每个点存为一个元素，则它的最长路径来自它的上下左右四边的最长的最长路+1。

### 动转：f[i][j]=max(f[i][j],f[i-1][j]+1,f[i+1][j]+1,f[i][j-1]+1,f[i][j+1]+1)（h[now]>h[next])；

但是dp要考虑无后效性。这就是为什么要用priority_queue，先算较低的点，对后面算高的点没有影响。最后遍历一遍整个地图，求出最高的一个点。其余的在代码中都有注释。

cpp:
```cpp
#include<iostream>
#include<queue>
using namespace std;
struct node{
    int i,j,num,f;
};//结构体存点
struct cmp1{
    bool operator()(node x,node y){
        return x.num>y.num;
    }
};//优先队列小的在前面
priority_queue<node,vector<node>,cmp1>q;//stl大法好
int n,m,maxn,maxj,maxi,w,top=0,g[101][101],f[101][101];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
        	f[i][j]=1;//长度最开始为1，它自己
            cin>>g[i][j];
            node a;
            a.i=i;a.j=j;a.f=0;a.num=g[i][j];
            q.push(a);//入队
        }
    }
    while(!q.empty()){
        node now1=q.top();//取点
        int i=now1.i;
        int j=now1.j;//坐标
        int now=now1.num;//此点的权值
        q.pop();//出队
        if(g[i-1][j]<now) f[i][j]=max(f[i][j],f[i-1][j]+1);
            if(g[i+1][j]<now) f[i][j]=max(f[i][j],f[i+1][j]+1);
            if(g[i][j-1]<now) f[i][j]=max(f[i][j],f[i][j-1]+1);
            if(g[i][j+1]<now) f[i][j]=max(f[i][j],f[i][j+1]+1);//dp
            if(maxn<f[i][j]) maxn=f[i][j];//取最大值
    }
    cout<<maxn;//输出
    return 0;//第一篇题解，请多支持！
}
```

---

## 作者：Ajwallet (赞：104)

**思路**

本题是一个动态规划题目，在这里提供两种做法，一种是记忆化搜索，一种是线形动态规划。

**线性动态规划**(1232ms/1.68MB)

方程:$l[i]=max(l[i],l[j]+1)$

```cpp
#include<cstdio>
#include<algorithm>
#define r(i,a,b) for (int i=a;i<=b;i++)
#define pk putchar(32)
#define ph putchar(10)
using namespace std;int t,n,m;
struct wyc{
    int x,y,h;
}f[10001];//h高度，x横坐标，y纵坐标
int l[10001];//每个点的最优解
int ans;//最优解
int max(int x,int y){return x>y?x:y;}int min(int x,int y){return x<y?x:y;}
short dx[4]={-1,0,1,0};//四个方向扩展
short dy[4]={0,1,0,-1};
void read(int &a)//输入优化
{
    a=0;int d=1;char c;
    while (c=getchar(),c<'0'||c>'9') if (c=='-') d=-1;a=a*10+c-48;
    while (c=getchar(),c>='0'&&c<='9') a=a*10+c-48;
    a*=d;
}
void write(int x)//输出优化
{
    if (x<0) {x=-x;putchar(45);}
    if (x>9) write(x/10);
    putchar(x%10+48);return;
}
bool cmp(wyc x,wyc y){return x.h>y.h;}//按高度排序
void LRZ()
{
    int b;
    read(b);read(m);//这里用b，是为了方便保存横纵坐标
    r(i,1,b)
     r(j,1,m)
     {
      read(f[++n].h);
      f[n].x=i;//横坐标
      f[n].y=j;//纵坐标
     }
    sort(f+1,f+1+n,cmp);//排序
}
bool check(int i,int j)//看f[i]能否到达f[j]
{
    r(k,0,3)
     if (f[i].x+dx[k]==f[j].x&&f[i].y+dy[k]==f[j].y) return true;//可以到达
    return false;//否则
}
void dp()
{
    r(i,1,n){
        l[i]=1;//每个点的初始长度就是1
     for (int j=i-1;j>0;j--)
          if (check(i,j)&&f[j].h>f[i].h)//如果可以到达
           l[i]=max(l[i],l[j]+1);//动态转移
    }
    r(i,1,n)
     ans=max(ans,l[i]);
    write(ans);//输出
}
int main()
{
    LRZ();
    dp();
}
```
**记忆化搜索**(0ms/1.54MB)
```cpp
#include<cstdio>
#define r(i,a,b) for (int i=a;i<=b;i++)
#define pk putchar(32)
#define ph putchar(10)
using namespace std;int t,n,m;
int h[101][101],ans,f[101][101];//h为高度，f为这个点滑的最长的长度
int max(int x,int y){return x>y?x:y;}int min(int x,int y){return x<y?x:y;}//最大值和最小值
short dx[]={-1,0,1,0};//四个方向
short dy[]={0,1,0,-1};
void read(int &a)//输入优化
{
    a=0;int d=1;char c;
    while (c=getchar(),c<'0'||c>'9') if (c=='-') d=-1;a=a*10+c-48;
    while (c=getchar(),c>='0'&&c<='9') a=a*10+c-48;
    a*=d;
}
void write(int x)//输出优化
{
    if (x<0) {x=-x;putchar(45);}
    if (x) 
     write(x/10);
    else return;
    putchar(x%10+48);
}
int dfs(int x,int y)//搜索，这里是从1,1开始倒序往前搜，也就是每次都往高处走
{
    if (f[x][y]) return f[x][y];//如果已经搜过了，直接返回搜过的值
    int t=1;
    r(i,0,3)
    {
        int nx=x+dx[i];//四个方向
        int ny=y+dy[i];
        if (nx>=1&&nx<=n&&ny>=1&&ny<=m&&h[x][y]<h[nx][ny])//满足要求
            t=max(dfs(nx,ny)+1,t);//取下最大值
    }
    f[x][y]=t;//保存
    return t;//返回
}
int main()
{
    read(n);read(m);
    r(i,1,n)
     r(j,1,m)
      read(h[i][j]);//输入不解释
    r(i,1,n)
     r(j,1,m)
      {
          t=dfs(i,j);
          f[i][j]=t;//取最大值
          ans=max(f[i][j],ans);//保存
      }
    write(ans);//输出
}
```

---

## 作者：Mosklia (赞：65)

## 耶耶耶！终于AC了一道省选题目耶！开心！  
## （然而并没有什么用）  
***********
下面进入正题。。  
相信大家应该都能想到动态规划的计算方向吧：将点按照高度升序排序，再按照排序结果进行计算。因为只有这样，才能保证状态转移时前面的状态都已经计算过了。  
那么本题解存在的意义是什么呢？？？  
答案是：**讲一个个人觉得很interesting的小技巧(huá jī)。**  
## 技巧(huá  jī)：二维压一维。
不知道大家想到上面的计算方向以后，有没有跟我当初一样，为排序而发愁呢？  
STL的sort函数要求传入一个连续的内存区间，但是数组开成二维以后，却难以保证想要排序的区域是连续的。也就是说
```cpp
	sort(a+1, a+r*c+1);
```
会哇（*WA*）。怎么办呢？？？  
答案是：把数组开成**一维**的！  
对于这样的一个$5 \times 5$格子

|     |  1  |  2  |  3  |  4  |  5  |  
|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |      |      |      |     |  |
|2   |      |      |      |     |  |
|3   |      |      |      |     |  |
|4   |      |      |      |     |  |
|5   |      |      |      |     |  |

对它的每个格子进行编号，使每个格子的编号唯一。相信最简单的方法应该就是这样了吧：  

|     |  1  |  2  |  3  |  4  |  5  |
|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |  1  |  2  |   3 |  4  |  5  |
|2   |  6  |   7 |    8|   9|  10|
|3   |  11| 12 |  13| 14 | 15 |
|4   |  16| 17 | 18 | 19 |  20|
|5   | 21 |  22|23  | 24| 25|
那么，按照这种思路，题目样例就可以被存成这样：  

|  $i$  |  1 | 2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|
|:------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$a_i$|1|2|3|4|5|16|17|18|19|6|15|24|25|20|7|14|23|22|21|8|13|12|11|10|9|
可是，向上下左右格子的编号又分别是什么呢？？  
由**观察法**易得：  
设格子一共有$R$行$C$列，当前已知的格子编号是$X$，那么其周边的格子编号如下（**不考虑边界**）:  

| $X-C-1$ | $X-C$ | $X-C+1$ |  
| :----------: | :----------: | :----------: |  
|  $X-1$  |   $X$   |  $X+1$ |
| $X+C-1$ | $X+C$ | $X+C+1$ |  
可是问题来了：**如何考虑边界？？？**  
很简单：
* 当且仅当$X-C \leq 0$时，$X$位于最上一行；
* 当且仅当$X+C > R \times C$时，$X$位于最下一行；
* 当且仅当$X mod C = 0$时，$X$位于最右一行；
* 当且仅当$(X-1) mod C = 0$时，$X$位于最左一行。 
 
这样，排序的问题也就“顺带着”解决了。  
顺便讲一下，为了避免排序时打乱点的相对位置，这里使用间接排序：使用另一个数组保存点编号，对这个数组进行排序。  
核心代码如下：  
```cpp
    for(int i = 1; i <= len; ++i) s[i]=i;//点序号
    for(int i = 0; i < r; ++i)
    for(int j = 1; j <= c; ++j)
        cin>>a[i*c+j];
    sort(s+1, s+1+len, cmp);//间接排序
    for(int i = 1; i <= len; ++i){//DP
        dp[s[i]] = 1;
        if(s[i]-c>0&&a[s[i]]>a[s[i]-c]) dp[s[i]] = max(dp[s[i]], dp[s[i]-c]+1);
        if((s[i]-1)%c&&a[s[i]]>a[s[i]-1]) dp[s[i]] = max(dp[s[i]], dp[s[i]-1]+1);
        if(s[i]%c&&a[s[i]]>a[s[i]+1]) dp[s[i]] = max(dp[s[i]], dp[s[i]+1]+1);
        if(s[i]+c<=len&&a[s[i]]>a[s[i]+c]) dp[s[i]] = max(dp[s[i]], dp[s[i]+c]+1);
    }
```
其中cmp函数定义如下：
```cpp
bool cmp(int x, int y){
    if(a[x] < a[y]) return true;
    return false;
}
```

---

## 作者：「QQ红包」 (赞：48)

搜索比较麻烦,感觉还是dp好.其实和搜索差不太多,dp[i][j]只能从四个方向走过来,而且四个方向的点的高度要大于这个点,于是就可以了.

还是很简洁的

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(s>='0'&&s<='9'));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(s>='0'&&s<='9')
    {
        k=k*10+(s-'0');
        s=getchar();
    }
    return k*base;
}
void write(int x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10)write(x/10);
        putchar(x%10+'0');
    }
}
int f[105][105];
int a[105][105];
int n,m,sum;
int dp(int x,int y)
{
    if (f[x][y]) return f[x][y];//直接返回值
    int sum=0;
    if (x-1>0) if (a[x-1][y]>a[x][y]) sum=max(sum,dp(x-1,y));
    if (x+1>0) if (a[x+1][y]>a[x][y]) sum=max(sum,dp(x+1,y));
    if (y-1>0) if (a[x][y-1]>a[x][y]) sum=max(sum,dp(x,y-1));
    if (y+1>0) if (a[x][y+1]>a[x][y]) sum=max(sum,dp(x,y+1));
    f[x][y]=sum+1;//找max
    return f[x][y];
}
int main()
{
    n=read();
    m=read();
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            a[i][j]=read();
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            if (f[i][j]==0) f[i][j]=dp(i,j);
            sum=max(sum,f[i][j]);//更新答案
        }
    printf("%d",sum);//输出
    return 0;
}
```
dp是0ms啊,没毛病


---

## 作者：清风霁月 (赞：39)


                   [i+1,j] ↓

         [i,j-1]→   [i,j]     ←[i,j+1]  
         
                   [i+1,j] ↑ 

    一个人可以从某个点滑向上下左右相邻四个点之一。
    当且仅当高度减小，对于任意一个点[i,j]，当它的
    高度小于与之相邻的四个点（[i-1,j], [i,j+1],
    [i+1,j], [i,j-1]）的高度时，这四个点可以滑向[i,j]。
    用f[i][j]表示到[i,j]为止的最大长度，则f[i[j]=max{f[i+a][j+b]}+1，
    其中坐标增量{(a,b)=[(1,0),(-1,0),(0,1),(0,-1)],0<i+a<=r，0<j+b<=c，High[i][j]<High[i+a][j+b]}。
    为了保证满足条件的f[i+a][j+b]在f[i][j]前算出，
    需要对高度排一次序，然后从大到小规划（高度）。最
    后再比较一下所有f[i][j]{0<i≤r,0<j≤c}，找出其中
    最长的一条路线。
    我们还可以用记忆化搜索的方法，它的优点是不需进行
    排序，按照行的顺序，利用递归逐点求出区域中到达此
    点的最长路径，每个点的最长路径只求一次。

    #include<iostream>
    #include<cstdio>
    using namespace std;
    int dx[5]={0,-1,0,1,0}; //x的坐标增量
    int dy[5]={0,0,1,0,-1}; //y的坐标增量
    int r,c,i,j,t,ans;
    int m[101][101],f[101][101];
    //f[i][j]表示到[i,j]为止的最大长度
    int search(int x,int y)//求到[x,y]点的最长路径
    {
        int i,t=1,tmp,nx,ny;
        if (f[x][y]>0)/*此点长度已经求出，不必进行进一步递归，保证每
                   一个点的最大长度只求一次*/
	    return f[x][y];
        for(i=1;i<=4;i++)//从四个方向上搜索
        {
            nx=x+dx[i];
            ny=y+dy[i];
            if(nx>=1 && nx<=r && ny>=1 && ny<=c && m[x][y]<m[nx][ny])
            {
                tmp=search(nx,ny)+1;//递归进行记忆化搜索
                if(tmp>t)
		        t=tmp;//取最大值
            }
        }
        f[x][y]=t;//保存
       return t;
    }
    int main()
    {
        cin>>r>>c;
        for(i=1;i<=r;i++)
        for(j=1;j<=c;j++)
        cin>>m[i][j];//读入每个点的高度
        for(i=1;i<=r;i++)//按照行的顺序，利用递归逐点求出区域中到达此点的最长路径
        for(j=1;j<=c;j++)
        {
            t=search(i,j);
            f[i][j]=t;
            if(t>ans)
	    	ans=t;//寻找最大长度值
        }
        cout<<ans<<endl;
        return 0;
        }



---

## 作者：Umaru (赞：31)

本题应该是练习记忆化搜索非常不错的一道题

并没有什么花哨的解法233   一个中规中矩的记忆化搜索

不明白记忆化搜索的同学看这边：

**记忆化搜索：因为普通搜索时，我们有时可能会用到之前所搜索到的结果，这时如果我们再次搜索就显得没有必要了（会浪费很多时间呢），所以如果我们已经记录了之前搜索的答案不就可以直接用之前的搜索答案了么**

举个例子：

在求斐波那契数时，我们需要求第i个数，必须先知道i前面两个数，即：

f[i]=f[i-1]+f[i-2]

如果此时我们要求f[4]那么我们理应求出f[3]和f[2]，而此时若要求你再求出f[6]时，就一定会用到f[5]和f[4]，此时若我们未记录出f[4]的结果，那么我们就不得不再走一遍求f[4]时所走的路，显然，若之前计算出f[4]时我们就记录其结果就免去了走冤枉路咯(^∇^\*)

核心代码：

if(map[nx][ny]<map[x][y]){ 

    step[x][y]=max(step[x][y],1+dfs(nx,ny));//若可以继续向四周走那么我们就能更新现在所在点的步数咯（题目要求的是最大可走的步数）

}
完整代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn = 200;//数据并不大 
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
int r,c,ans;
int map[maxn][maxn],step[maxn][maxn];
int dfs(int x,int y){
    if(step[x][y]) return step[x][y];//一开始每个点的步数都应为0；如果当前这个点已知其最大步数说明之前该点已被计算过就不用再重复计算了（这不是废话么- -||）； 
    step[x][y]=1;//既然这是一个从未走过的点那么现在来到该点至少都会使其步数为1 
    for(int i=0;i<4;i++){//四个可行的方向 
        int nx=x+dx[i],ny=y+dy[i];
        if(map[nx][ny]<map[x][y]){ 
            step[x][y]=max(step[x][y],1+dfs(nx,ny));//代码核心 
        }
    }
    return step[x][y];//返回值给上一个dfs调用 
}
int main(){
    ios::sync_with_stdio(false);
    scanf("%d%d",&r,&c);
    //初始化处理 
    for(int i=0;i<=c+1;i++){//将边界的高度设为无限高这样就免去了判断是否超出地图限制 
        map[i][0]=map[i][c+1]=1e9;
    } 
    for(int i=0;i<=r+1;i++){
        map[0][i]=map[r+1][i]=1e9;
    }
    //读入每个点的数据 
    for(int i=1;i<=r;i++){
        for(int j=1;j<=c;j++){
            scanf("%d",&map[i][j]);
        }
    }
    for(int i=1;i<=r;i++){
        for(int j=1;j<=c;j++){
            ans=max(dfs(i,j),ans);//每一个点都跑一边dfs，答案取最大的就是题目要求了
```
}//因为有记忆化的缘故即使每个点都跑一边dfs也不会用很多时间
}//即是说：有的点的最大步数已经被记录，就不会再去重新跑dfs而是直接可以把现成的答案拿来用（记忆化搜索的精髓）

    printf("%d",ans);

    return 0;

}

---

## 作者：JamesHen (赞：24)

#广搜？宜乎哉！

鉴于楼上一片片DFS, 我广搜党必须翻身

然而，广搜最严重的一个问题，就是找不到明确的路径长度

这个问题花点心思就能解决

下面是一棵解答树

**灵魂画师闪亮登场**

![](http://pan.baidu.com/s/1eRYJ64E)

在广搜的过程中，其实每一层的节点的已滑长度都是次层层数

利用std::queue，到达此层结尾时将now更新为队列的大小（下一层的节点数）

毎pop一个节点便自减now，这样now == 0时意味着这层到头了！

```cpp
#include <cstdio>
#include <queue>
#include <cstdlib>
using namespace std;

int mount[120][120], answer(0);
struct location
{
    int x, y;
    location(){};
    location(int xx, int yy): x(xx), y(yy){};
};


int main()
{
    int R, C;
    scanf("%d%d", &R, &C);
    for (int i(0); i < R; ++i)
        for (int j(0); j < C; ++j)
            scanf("%d", &mount[i][j]);        //读取
    for (int i(0); i < R; ++i)
        for (int j(0); j < C; ++j)
        {
            if (i + 1 < R && mount[i + 1][j] > mount[i][j]) continue;
            if (i - 1 > -1 && mount[i - 1][j] > mount[i][j]) continue;
            if (j + 1 < C && mount[i][j + 1] > mount[i][j]) continue;
            if (j - 1 > -1 && mount[i][j - 1] > mount[i][j]) continue;
                //日常优化，如果这个点边上有点比他高，何必从他开始呢
            int now(0), next(0), cnt_layer(0);    //数层，即为数长
            queue<location> nodes;
            nodes.push(location(i, j));
            while (!nodes.empty())
            {
                if (now == 0)            //极为重要，更新下一层的目标
                {
                    ++cnt_layer;
                    now = nodes.size();
                }
                int nx(nodes.front().x), ny(nodes.front().y);
                if (nx + 1 < R && mount[nx + 1][ny] < mount[nx][ny])
                {
                    nodes.push(location(nx + 1, ny));
                }
                if (nx - 1 >= 0 && mount[nx - 1][ny] < mount[nx][ny])
                {
                    nodes.push(location(nx - 1, ny));
                }
                if (ny + 1 < C && mount[nx][ny + 1] < mount[nx][ny])
                {
                    nodes.push(location(nx, ny + 1));
                }
                if (ny - 1 >= 0 && mount[nx][ny - 1] < mount[nx][ny])
                {
                    nodes.push(location(nx, ny - 1));
                }
                        //塞一波儿子
                nodes.pop();
                --now;
            }
            answer = answer < cnt_layer ? cnt_layer : answer;
                        //更新答案
        }
    printf("%d", answer);
    return 0;
}
```
相信熊的同学已经发现以上代码90分o(∩\_∩)o 其实都是STL的锅（传说中STL的渣渣效率）

还有第2个点对广搜来说节点太多了，不能简单的用数组模拟队列，只能弄个滚动数组，交换存此层节点与下层节点

```cpp
location nodes[2][100000];
//...
bool now_arr(false);
//用nodes[now_arr]读此层节点，放到nodes[!now_arr]里面去
int now(0), all(0), cnt_layer(0), now_layer(0);
    qnodes[all].x = i;
    qnodes[all].y = j;
    ++all;
if (now == now_layer) //改变一下判断层和更新层的方式
{
    ++cnt_layer;
    now_layer = all;
}
```
完整代码就不放了

（逃

---

## 作者：明依 (赞：18)

$2019.8.2$ $update$ : 对原文用$LATEX$优化了一下

$2020.2.16$ $update$ : 数据似乎更新了，剪枝方法被卡了，故删去了剪枝方法。

------------------------------------------------------------------------------------------分割线

记忆化搜索||$dp$

先讲方法，代码待会上

方法一：记忆化搜索

这个方法不怎么解释，就是每搜索完一个高度的最长路径记录一下，以后搜索其他的点时如果走到了这条路就直接用记录的值计算就是了

方法二：$dp$

假设一个点的高度为H，周围四个点的高度分别为$H1$,$H2$,$H3$,$H4$，$f[i][j]$代表从$(i,j)$滑的最长长度。如果$H$大于周围四个点的一个，那么就可以滑到那一个点，也就是$f$[高的那个点]=$f$[矮的那个点]$+1$，到这里就不难写出状态转移方程了:$f[i][j]=f[i+b[g]][j+c[g]]+1$(前提：$a[i+b[g]][j+c[g]]<a[i][j]$)，其中$a$数组为读入的高度，$b$、$c$数组为方向数组，$f$数组为这个点的最长路径长度。注意在计算长度之前要先将高度排序，然后再来算。

接着附上代码：（由于本人比较懒，$dp$的代码搬$(chao)$运$(xi)$的一本通）

方法一:$(42ms/928KB)$（不知道为什么我的记忆化是$42ms$，可能我太蒟了吧）
```c
#include<cstdio>
#include<iostream>
using namespace std;
const int N=105;
int n,m,a[N][N],f[N][N]= {0},maxn,ans,b[4]= {1,0,-1,0},c[4]= {0,1,0,-1};
bool p[N][N];
inline void dfs(int x,int y,int num) {
    int flag=0;
    for(int i=0; i<4; i++) {
        int xx=x+c[i],yy=y+b[i];
        if(a[xx][yy]>=a[x][y]) continue;
        if(f[xx][yy]) {
            ans=max(ans,f[xx][yy]+num);
            continue;
        }
        if(xx&&xx<=n&&yy&&yy<=m&&!p[xx][yy]) {
            p[xx][yy]=1;
            dfs(xx,yy,num+1);
            p[xx][yy]=0;
        }
    }
    if(!flag) {
        ans=max(ans,num);
        return;
    }
}
int main() {
    scanf("%d %d",&n,&m);
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) scanf("%d",&a[i][j]);
    }
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            ans=0;
            p[i][j]=1;
            dfs(i,j,1);
            p[i][j]=0;
            f[i][j]=ans;
            if(maxn<ans) maxn=ans;
        }
    }
    printf("%d\n",maxn);
    return 0;
}/*
吃货殿下佑我AC此题！！*/
```

方法二：$(33ms/792KB)$
```c
#include<iostream>
#include<cstdio>
using namespace std;
int dx[5]= {0,-1,0,1,0},dy[5]= {0,0,1,0,-1};
long long r,c,i,j,p,t,ans;
long long m[101][101],f[101][101];
int search(int,int);
int main() {
    cin>>r>>c;
    ans=0;
    for(i=1; i<=r; i++) {
        for(j=1; j<=c; j++) cin>>m[i][j];
    }
    for(i=1; i<=r; i++) {
        for(j=1; j<=c; j++) {
            t=search(i,j);
            f[i][j]=t;
            if(t>ans) ans=t;
        }
    }
    cout<<ans<<endl;
}
int search(int x,int y) {
    int i,t,tmp,nx,ny;
    if(f[x][y]>0) return f[x][y];
    t=1;
    for(i=1; i<=4; i++) {
        nx=x+dx[i];
        ny=y+dy[i];
        if((nx>=1)&&(nx<=r)&&(ny>=1)&&(ny<=c)&&(m[x][y]<m[nx][ny])) {
            tmp=search(nx,ny)+1;
            if(tmp>t) t=tmp;
        }
    }
    f[x][y]=t;
    return t;
}
```

### 第一次交题解，求通过！！

---

## 作者：WildZelda (赞：15)

# 本人第一次写题解



------------
这题用dfs不会难。

**但单纯使用dfs时间复杂度较高，所以需使用记忆化搜索。**

可以用两个二维数组分别记录某个点所能找到的最长下降和上升部分。 _分别记录为low数组和up数组_。（**我用的是包括该点的** ）。


```cpp
int c[4] = {0,1,-1,0};
int d[4] = {1,0,0,-1};//查找的方向

```
```cpp
int lo(int x,int y){
	if(low[x][y])return low[x][y];else low[x][y] = 1;
   //如果已被标记，则直接返回值，否则标记为1，即自身(下同）
	for (int i = 0; i < 4; i++){
		int xx = x + c[i];
		int yy = y + d[i];
		if(xx > 0 && xx <= n && yy > 0 && yy <= m){
			if(a[xx][yy] < a[x][y]){
			low[xx][yy] = lo(xx,yy);
			low[x][y] = max(low[x][y],low[xx][yy] + 1);//简单的搜索
		}
	}
	}
	return low[x][y];
}
```
 

------------
```cpp
int per(int x,int y){
	if(up[x][y])return up[x][y];else up[x][y] = 1;
	for (int i = 0; i < 4; i++){
    		int xx = x + c[i];
    		int yy = y + d[i];
    		if(xx > 0 && xx <= n && yy > 0 && yy <= m)
			if(a[xx][yy] > a[x][y]){
			up[xx][yy] = per(xx,yy);
			up[x][y] = max(up[x][y],up[xx][yy] + 1);
		}
	}
	return up[x][y];
}
```


------------
**接下来便是主函数**
```cpp
int main(){
    scanf("%d%d",&n,&m);
    for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
    scanf("%d",&a[i][j]);
    for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
    		h = max(lo(i,j) + per(i,j) - 1,h);//因为一个点会被两个数组各标记一次，所以减去1.
	printf("%d",h);
	return 0;
}
```


------------




---

## 作者：AlphaPig (赞：10)

#### 此题有两种有两种常用解法，一种为状压DP，另一种为记忆化搜索 
而且在试炼场的搜索中，这就告诉我们尽量使用记忆化搜索
#### ~~（但因为蒟蒻状压DP不好，所以蒟蒻还是要用状压DP）~~
### 
```
#include<bits/stdc++.h>
using namespace std;
int f[100001];//DP数组
int dx[4]={0,0,1,-1};//记录方向增量的数组
int dy[4]={1,-1,0,0};
struct sb//结构体存点，x，y为坐标，h是高度 
{
    int x,y,h;
}p[100010];

bool cmp(sb x,sb y)//自定义比较函数,从高到低排序
{
    return x.h>y.h;
}

int main()
{
    int r,c,ans=-100,k=0,d;
    cin>>r>>c;
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            cin>>p[++k].h;
			f[k]=1;//初始化DP数组 
			p[k].x=i,p[k].y=j;//存点 
        } 
    }
    sort(p+1,p+k+1,cmp);//按高度排序 
    for(int i=1;i<=k;i++)//开始DP 
    {
        for(int j=i-1;j>0;j--)
        {
            for(int u=0;u<4;u++)//枚举方向，看i与j是否相邻 
   			{
        		if(p[i].x+dx[u]==p[j].x && p[i].y+dy[u]==p[j].y) 
        			if(p[j].h>p[i].h)  f[i]=max(f[i],f[j]+1);
        			//如果当前处理的两个点相邻，并且j的高度大于i，则可以考虑状态转移 
        	}
    	}
    }
    for(int i=1;i<=k;i++) ans=max(f[i],ans); //找出最大的点 
    cout<<ans<<endl; 
 	return 0;
}
```
 有人可能有疑问，为什么前面已经排好序了，为什么DP时还要判断j的高度大于i呢，因为可能会有高度相同的点，而题目中说了高度必须是**单调递减**的。  

 ~~（蒟蒻的第二篇题解，求过QAQ）~~


---

## 作者：Dfkuaid (赞：7)

我觉得这道题主要方法应该有两种：  

> - 动态规划
> - 搜索  
 
下面会分别对这两种方法进行简述


------------
#### 一，动态规划法
首先的想法是用$L_{i,j}$表示从点$(i,j)$出发能到达的**最长距离**。因为从$(i,j)$出发**最少**能滑行自己1格，所以每个点L值都先**初始化为1**   

我们可以从$(i,j)$出发，向四周寻找，如果四周没有比他低的点，那么$L_{i,j}$即为1，否则$L_{i,j}$就为从$(i,j)$出发四周**高度比L低且L值最大**的那个点P的L值加1
 
递推时的顺序为点的高度由低到高，那么在递推过程中，计算$L_{i,j}$时，他四周比他低的点P的L值一定已经被计算出来了
 
接下来需要解决的问题便是如何按点的高度由小到大递推   
关于这个问题，我们难道要每次递推时用两遍循环找出当前未递推的最低点？显然不可取，**时间复杂度会爆炸的**。那么就考虑**能否一个$sort()$解决问题**（~~懒得自己写排序~~）。$sort()$能给一个二维数组排序？不知大佬们怎么想，反正本蒟蒻不会。。。那为了$sort()$~~更香~~可以方便的使用，我用一个**一维数组**进行存储每个点的数据。

这时候不得不说，**结构体**~~真香~~真的实用。下面用代码直观地说一下这个结构体
``` cpp
struct Point{
	int r;   //行号
	int c;   //列号
	int h;   //高度
	bool operator < (const Point & p) const {
		return h < p.h;
	}//构造函数，不懂的同学可以写一个cmp代替,下面代码会有特别说明
};Point point[10101];
```
为了方便储存以及不造成浪费（~~个人习惯~~）这里$i$和$j$都从0开始取，那么点$(i,j)$用$point$数组存的下标为$c \times i + j$
 > 由于$i,j$从0开始取，$c \times i + j$这个式子表示的是第$i+1$行第$j+1$个数，那么，$i$最大为$R-1$，$j$最大为$C-1$，整个数组最大下标为$C \times (R-1)+C-1$，即$C \times R-1$
 >> 若$i,j$从1开始取，为保证运算方便及善待空间，下标应为$C \times (i-1)+j-1$
 
该算法的分析已给出，大家可以结合代码自行理解
``` cpp
#include <iostream>//头文件，不多解释
#include <cstdio>
#include <algorithm>
using namespace std;
struct Point{
	int r;//行号
	int c;//列号
	int h;//高度
	bool operator < (const Point & p) const {
		return h < p.h;//构造函数，不会的可删掉看下面cmp
	}
};Point point[10101];
int cmp(Point a,Point b){
	if (a.h < b.h)   //如果a的高度小于b的高度
	  return 1;//返回真
	else
	  return 0;//否则返回假
}
int R,C,ans = -0x3ffff;//需初始化ans为较小值（害怕玄学出错）
int a[101][101],d[102][102];//a为每点的高度，d为该点可滑行的最大值
int main(){
	cin >> R >> C;
	for (int i = 0;i < R;i ++)
	  for (int j = 0;j < C;j ++){
	  	cin >> a[i][j];//输入点的高度
	  	point[i * C + j].h = a[i][j];//根据上面所说的下标，
	  	point[i * C + j].r = i;	 	 //对点的数据进行存储
	  	point[i * C + j].c = j;
	  	d[i][j] = 1;            //初始可滑行长度为1
	  }
	sort(point,point + R * C);//如果用了cmp可换为sort(point,point + R * C，cmp);
	for (int i = 0;i < R * C;i ++){
		int r = point[i].r;//找一个替身,怕玄学或运算时出错
		int c = point[i].c;//同理
		if (r > 0 && a[r - 1][c] < a[r][c])//找上面的
		  d[r][c] = max(d[r][c],d[r - 1][c] + 1);//进行更新
		if (c > 0 && a[r][c - 1] < a[r][c])//找左面的
		  d[r][c] = max(d[r][c],d[r][c - 1] + 1);//进行更新
		if (r < R - 1 && a[r + 1][c] < a[r][c])//找下面的
		  d[r][c] = max(d[r][c],d[r + 1][c] + 1);//进行更新
		if (c < C - 1 && a[r][c + 1] < a[r][c])//找右面的
		  d[r][c] = max(d[r][c],d[r][c + 1] + 1); //进行更新
	}
	for (int i = 0;i < R;i ++)
	  for (int j = 0;j < C;j ++)
	    ans = max(ans,d[i][j]); //找出最大值
	cout << ans;
	return 0;//完美撒花
```
由于点$(i,j)$的L值的计算为极小的常数值，所以这个算法的复杂度为$O(R \times C)$   

----
#### 二、搜索
相信大家都会想到$DFS$，但若是单纯的$DFS$，会TLE一个点，所以，我们就要考虑到记忆化搜索。那么也很好实现，具体请见下方代码：
``` cpp
#include <iostream>
#include <cstdio>
using namespace std;
int R,C;
int g1[4] = {0,1,0,-1};//定义寻找的4个方向
int g2[4] = {-1,0,1,0};
int m[101][101];//储存每个点的高度
int lj[101][101];//储存每个点可滑行的最大长度
int maxn,lr;
int dfs(int i,int j){
	if (lj[i][j] - 1)//判断是否搜过，因为下面将每一个点的最初滑行长度为1
    			 //如果该点最长长度-1为0，说明该点未被搜过
	  return lj[i][j];
	for (int o = 0;o < 4;o ++)//向4个方向搜
	  if (i + g1[o] >= 0 && i + g1[o] < R && j + g2[o] >= 0 && j + g2[o] < C && m[i + g1[o]][j + g2[o]] < m[i][j]){//保证不越界
	  	lj[i][j] = max(lj[i][j],dfs(i + g1[o],j + g2[o]) + 1);//进行搜索及更新
	  }
	return lj[i][j];
}
int main(){
	cin >> R >> C;
	for (int i = 0;i < R;i ++)//初始化
	  for (int j = 0;j < C;j ++)
	    lj[i][j] = 1;
	for (int i = 0;i < R;i ++)
	  for (int j = 0;j < C;j ++)
	    cin >> m[i][j];
	for (int i = 0;i < R;i ++)
	  for (int j = 0;j < C;j ++){
	  	if (lj[i][j] - 1 != 0){//如果该点被搜过
	  		maxn = max(maxn,lj[i][j]);//直接更新
	  		continue;
		  }
	  	lj[i][j] = dfs(i,j);
	  	maxn = max(maxn,lj[i][j]);
	  }
	cout << maxn;
	return 0;//撒花
}
```
这就是该题本人的思路，希望能给你带来帮助

---

## 作者：wjh_ (赞：6)

一道记忆化搜索的好题
---
首先，看到一道题目，不能直接去点右侧的“标签”~~（虽然我经常这么干）~~，  

~~当然更不能看题解（否则恐怕你的键盘上的"ctrl"c"和"v"会坏的很快，而且棕名警告）~~

要先好好分析一下这道题可能用哪一种算法来实现。

### 回归正题

这道题目我们怎样分析？

直接暴搜？？？恭喜你即将TLE

顺着思路继续想下去，因为这道题求的是最优解，就可以进行记忆化搜索，如果比目前的最大值还小，就直接停止搜索。

所以，我们就能想到两种方案：记忆化DFS和记忆化BFS

另外，因为是求最大值，我们很容易也会想到动规，但是因为动规要考虑到后效性的问题，所以处理起来会比较的麻烦些。

### 由于记忆化DFS比较容易，我们就来具体分析一下记忆化的过程：

先记录一个数组：$f_{i,j}$ 表示到 $(i,j)$ 这个位置的最大值。  
如果搜索到的最优值比它小，则直接退出搜索即可。代码实现如下：
```
void dfs(int x,int y,int cnt)//x，y代表位置，cnt代表最优值
{
    if(cnt<=f[x][y]) return;
    f[x][y]=cnt;
    ans=max(ans,cnt);
    for(rint k=1;k<=4;k++)//向4个方向搜索
    {
        int p=x+dx[k],q=y+dy[k];
        if(s[p][q]<s[x][y]&&p&&p<=a&&q&&q<=b)
            dfs(p,q,cnt+1);
    }
}
```

### 代码如下，本人码风清奇，请勿嘲笑：

```cpp
#include<bits/stdc++.h>
#define rint int
using namespace std;
int a,b,f[110][110],s[110][110],ans=1;
const int dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0};
int rd()
{
    int f=1,x=0;
    char ch=getchar();
    while((ch<'0')||(ch>'9')){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while((ch>='0')&&(ch<='9')){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return f*x;
}
inline void dfs(int x,int y,int cnt)
{
    if(cnt<=f[x][y]) return;
    f[x][y]=cnt;
    ans=max(ans,cnt);
    for(rint k=1;k<=4;k++)
    {
        int p=x+dx[k],q=y+dy[k];
        if(s[p][q]<s[x][y]&&p&&p<=a&&q&&q<=b)
            dfs(p,q,cnt+1);
    }
}
int main()
{
    a=rd();b=rd();
    for(rint i=1;i<=a;i++)
        for(rint j=1;j<=b;j++)
            s[i][j]=rd();
    for(rint i=1;i<=a;i++)
        for(rint j=1;j<=b;j++)
            dfs(i,j,1);
    printf("%d",ans);
    return 0;
}
```
本蒟蒻的第3篇题解，望管理员通过！

---

## 作者：Gino_Hong (赞：5)

不知道luogu有没有像我这样的大三ACM渣渣- -

记忆化搜索 方法楼下dalao们都讲的很清楚了 我只是把bfs和dfs都写了一遍 速度差不多 dfs稍快一些

直接上代码啦 注释代码里都有

```cpp
//P1434
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=1,sx,sy; 
int a[105][105];            //图 
int vis[105][105];            //记忆化搜索数组 vis[i][j]存的是i,j这个点最多能滑几米 
pair<int,int> dir[4];        //方向数组 上下左右四个方向 
struct Node{                //方便bfs用的结构体 
    int x,y,step;            //x,y表示图中的坐标 step表示当前滑了几米 
    Node(){}
    Node(int x,int y,int step):x(x),y(y),step(step){}
};
void bfs(Node start){
    queue<Node> q;
    q.push(start);
    while(!q.empty()){
        Node x=q.front();
        q.pop();
        Node tmp;
        for(int i=0;i<4;i++){
            tmp.x=x.x+dir[i].first;
            tmp.y=x.y+dir[i].second;
            if(tmp.x>=0&&tmp.x<n&&tmp.y>=0&&tmp.y<m&&a[x.x][x.y]>a[tmp.x][tmp.y]){
                int xx=tmp.x,yy=tmp.y;
                if(!vis[xx][yy])        //如果这个点没被算过 
                    tmp.step=x.step+1,q.push(tmp);    //当前步数为上一步的步数加一，入队 
                else                    //如果被算过了就直接用vis数组中存的这个点的最大步数 
                    tmp.step=x.step+vis[xx][yy];    //当前步数为上一步的步数加上这个点的最大步数，不用入队 
                vis[start.x][start.y]=max(vis[start.x][start.y],tmp.step);//刷新起始点的最大步数 
            }
        }
    }
}
int dfs(int x,int y,int step){//记忆化部分跟bfs差不多 
    for(int i=0;i<4;i++){
        int xx=x+dir[i].first;
        int yy=y+dir[i].second;
        if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[x][y]>a[xx][yy]){
            if(vis[xx][yy]){
                vis[sx][sy]=max(vis[sx][sy],step+vis[xx][yy]);
                continue;
            }else{
                vis[sx][sy]=max(vis[sx][sy],step+1);
                dfs(xx,yy,step+1);
            }
        }
    }
}
int main(void){
    ios::sync_with_stdio(0);
    dir[0]=make_pair(0,1);dir[1]=make_pair(0,-1);
    dir[2]=make_pair(1,0);dir[3]=make_pair(-1,0);
    cin>>n>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            cin>>a[i][j];            //输入图 
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
            sx=i,sy=j;                //dfs时用于记录起始点坐标 
            dfs(i,j,1);                //12ms 2.16MB
//            bfs(Node(i,j,1));        //56ms 2.18MB
            ans=max(ans,vis[i][j]);    //刷新ans 
        }
    cout<<ans;
}
```

---

## 作者：泡末 (赞：4)

这是区别记忆化搜索和动态规划的好题，下面整合了基本的3种版本，思维由易到难，分别是普通dfs版（会wa第二个点，讨论区主要问的），ms（记忆化搜索）版，dp版（在于需要先排序，以便我想要的点之前的点已经推过），这题有个问题就是如果只有1个点 结果是1(直接滑下去qwq)（如果这个时候输出0会wa第四个点和第六个点）
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;//dfs版 
int ii,jj,maxx;
int a[105][105];
int read()
{
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}
void dfs(int i,int j,int sum)
{
	if(sum>maxx) maxx=sum;
	if(i>=1)
	if(a[i-1][j]<a[i][j]) dfs(i-1,j,sum+1);
	if(j>=1)
	if(a[i][j-1]<a[i][j]) dfs(i,j-1,sum+1);
	if(j<=jj-2)
	if(a[i][j+1]<a[i][j]) dfs(i,j+1,sum+1);
	if(i<=ii-2)
	if(a[i+1][j]<a[i][j]) dfs(i+1,j,sum+1);
	sum-=1;
	return;
}
int main()
{
//	freopen("in.txt","r",stdin);
	ii=read();
	jj=read();
	for(int i=0;i<ii;i++)
	{
		for(int j=0;j<jj;j++)
		{
			a[i][j]=read();
		}
	}
	for(int i=0;i<ii;i++)
	{
		for(int j=0;j<jj;j++)
		{
			dfs(i,j,1);
		}
	}
	printf("%d",maxx);
	return 0;
}
```


```cpp
#include<iostream>
#include<cstdio> 
using namespace std;//dfs+记忆化 
int ii,jj,maxx;
int a[105][105];
int b[105][105];
int fx[4][2]={0,1,1,0,0,-1,-1,0};
int read()
{
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}
int dfs(int i,int j)//对于i，j 
{
	if(b[i][j]!=0) return b[i][j];
	int sum=1;
	for(int k=0;k<4;k++)
	{
		int f=i+fx[k][0],g=j+fx[k][1];
    	if(f>=0&&g>=0&&f<ii&&g<jj)
    	{
    		if(a[f][g]<a[i][j])
    		{
	    		sum=max(sum,dfs(f,g)+1);
			}
		}
	}
	return sum;
}
int main()
{
	freopen("in.txt","r",stdin);
	ii=read();
	jj=read();
	for(int i=0;i<ii;i++)
	{
		for(int j=0;j<jj;j++)
		{
			a[i][j]=read();
		}
	}
	for(int i=0;i<ii;i++)
	{
		for(int j=0;j<jj;j++)
		{
			b[i][j]=dfs(i,j);
			if(b[i][j]>maxx) maxx=b[i][j];
		}
	}
	printf("%d",maxx);
	return 0;
}
```


```cpp
#include<iostream>
#include<cstdio> 
#include<algorithm>
using namespace std;//dp版 
int ii,jj,maxx;
int fx[4][2]={0,1,1,0,0,-1,-1,0};
int a[105][105];
int d[105][105];
struct node
{
	int i;
	int j;
	int x;
}n[10005]; 
int read()
{
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}
bool cmp(node a,node b)
{
	return a.x<b.x;
}
int main()
{
	freopen("in.txt","r",stdin);
	ii=read();
	jj=read();
	int tt=0;
	for(int i=0;i<ii;i++)
	{
		for(int j=0;j<jj;j++)
		{
			n[tt].i=i;
			n[tt].j=j;
			a[i][j]=read();
			n[tt].x=a[i][j];
			d[i][j]=1;
			tt++;
		}
	}
	sort(n,n+tt,cmp);
	for(int t=0;t<tt;t++)
	{
		int i=n[t].i;
		int j=n[t].j;
		for(int k=0;k<4;k++)
		{
			int f=i+fx[k][0];
			int g=j+fx[k][1];
			if(f>=0&&g>=0&&f<ii&&g<jj)
	    	{
	    		if(a[f][g]<a[i][j])
	    		{
		    		d[i][j]=max(d[i][j],d[f][g]+1);
				}
			}
		}
		maxx=max(maxx,d[i][j]);
	}
	printf("%d",maxx);
	return 0;
}
```


---

## 作者：温词 (赞：4)

作为一个蒟蒻，看到这道题的第一反应是想用dfs，然后看了一眼数据大小100^2，emm这是要tle成狗啊。
再想想貌似dp也能做，仔细一想还发现明显更优。
然后......重点来了，dp的一大要求叫做无后效性,意思也就是你瞎搞可以，别影响后面的人瞎搞，所以要先进行排序，高度从小到大进行处理，然而二维数组的排序是个玄学课题，所以我选择先用一个结构体
```

struct st{

	int num,ht,x,y;
    
}a[10010];
```

然后写一个排序原则
```
bool comp(st a,st b){

	return a.ht<b.ht;
    
}
```
就这样既能排序又能保留原来的横纵坐标。
源代码如下：
``` cpp
#include<bits/stdc++.h>

using namespace std;//万能头文件可还行（雾

struct st{

	int num,ht,x,y;
    
}a[10010];//写个结构体保留横纵坐标

int dp[110][110],h[110][110];

bool comp(st a,st b){

	return a.ht<b.ht;
    
}

int main(){

	int r,c,i,j,k;
	cin>>r>>c;
	k=1;
	int maxn=0;
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
			cin>>a[k].ht;//输入高度
			h[i][j]=a[k].ht;
			a[k].x=j;
			a[k].y=i;//保留横纵坐标
			a[k].num=k;
			k++;
			dp[i][j]=1;//即使这个点最矮，也可以滑自己啊/手动滑稽
		}
	}
	sort(a+1,a+k,comp);
	//cout<<k<<endl;
	for(i=1;i<k;i++){
		int yi=a[i].x;
		int xi=a[i].y;
		int height=a[i].ht;
		if(height>=h[xi-1][yi]&&xi>=1){
	dp[xi][yi]=max(dp[xi][yi],dp[xi-1][yi]+1);
		}
		if(height>=h[xi+1][yi]&&xi<=r){
	dp[xi][yi]=max(dp[xi][yi],dp[xi+1][yi]+1);
		}
		if(height>=h[xi][yi-1]&&yi>=1){
	dp[xi][yi]=max(dp[xi][yi],dp[xi][yi-1]+1);
		}
		if(height>=h[xi][yi+1]&&yi<=c){
	dp[xi][yi]=max(dp[xi][yi],dp[xi][yi+1]+1);
		}//状态转移方程如上
		maxn=max(maxn,dp[xi][yi]);
	} //选出最大值
	//for(i=1;i<=r;i++){
	//	for(j=1;j<=c;j++){
	//		cout<<dp[i][j]<<" ";
	//	}
	//	cout<<endl;
	//}
	cout<<maxn;
	return 0;
}
```
看各位大佬们的题解都用队列，蒟蒻我就来一个用结构体的吧。最后orz pinkrabbit大佬。溜了溜了！！！

---

## 作者：Marchia (赞：4)

二维的最长上升子序列DP

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define maxn 105
using namespace std;
struct node{int x,y,v;}b[maxn*maxn];
int a[maxn][maxn],f[maxn][maxn]={0},N,M,bn=0,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
int cmp(node a,node b){
    if(a.v!=b.v) return b.v>a.v;
    if(a.x!=b.v) return b.x>a.x;
    return b.y>a.y;
}
int main(){
    int ans=0;
    cin>>N>>M;
    for(int i=0;i<N;i++)
        for(int j=0;j<M;j++){
            cin>>a[i][j];
            b[bn].x=i, b[bn].y=j, b[bn++].v=a[i][j];
        }
    sort(b,b+bn,cmp);
    for(int i=0;i<bn;i++)
        for(int j=0;j<4;j++){
            int nx=b[i].x+dx[j], ny=b[i].y+dy[j];
            if(nx>=0&&ny>=0&&nx<N&&ny<M && b[i].v>a[nx][ny])
                f[b[i].x][b[i].y]=max(f[nx][ny]+1,f[b[i].x][b[i].y]);
        }
    for(int i=0;i<N;i++)
        for(int j=0;j<M;j++)
            ans=ans>f[i][j]? ans:f[i][j];
    cout<<ans+1<<endl;
    return 0;
}
```

---

## 作者：JA_yichao (赞：3)

## Description

**Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子**

1 2 3 4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9

**一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。**
## Input

**输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。**
## Output

**输出最长区域的长度。**
## Sample Input

5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
## Sample Output

25
——————————————————————————————————————————————————————————————————————————————————————————————
### 在这里我给出两种解法

# 解法一:DP
**首先，**

**把矩阵c i，j 放到a数组里线性化，**

**并将a数组，x数组，y数组（x和y分别是行和列）排序，**

**然后DP（DP过程解析详见代码）**

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int c[1010][1010],n,m,a[10000100];
int x[1000010],y[1000010];
int w=0,x2,y2,x3,y3;
int dx[4]={-1,0,0,1};
int dy[4]={0,-1,1,0};
int ans[1010][1010];
int maxx=0;
void qsort(int l,int r)                     //手打快拍
{
	int mid,i,j;
	mid=a[(l+r)/2];
	i=l,j=r;
	while(i<=j)
	{
	    while(a[i]<mid) i++;
	 	while(a[j]>mid) j--;
		if(i<=j)
		 {
		 	swap(a[i],a[j]);
		 	swap(x[i],x[j]);
		 	swap(y[i],y[j]);
		 	i++;
		 	j--;
		 }
	}
    if(l<=j) qsort(l,j);
	if(i<=r) qsort(i,r);
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)
	  {
	  	cin>>c[i][j];
	  	a[++w]=c[i][j];
	  	x[w]=i;
	  	y[w]=j;
	  }
	qsort(1,w);
	for(int i=1; i<=w; i++)
	 {
	 	for(int j=0; j<4; j++)         //模拟四个方向
	     {
	  	    x2=x[i]+dx[j];
	  	    y2=y[i]+dy[j];
	  	    x3=x[i],y3=y[i];
	  	    if(x2>0&&x2<=n&&y2>=0&&y2<=m)        //是否越界
	  	     {
	  	  	   if(ans[x3][y3]+1>ans[x2][y2]&&c[x3][y3]<c[x2][y2])            //是否满足滑到那个位置的条件
	  	  	    {
	  	  	 	    ans[x2][y2]=ans[x3][y3]+1;
	  	  	 	    if(ans[x2][y2]>maxx)                       //更新数据
	  	  	 	      maxx=ans[x2][y2];
	  	  	    }
	  	     }
	     }
	 }
	cout<<maxx+1;        //加一是因为要加它本身
	return 0;
}
```


——————————————————————————————————————————————————————————————————————————————————————————————
# 解法二：记忆化深搜
**在普通深搜上加一个判断就好啦！**

**（其实跟DP挺像的）**
# 代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[1010][1010],f[1010][1010];
int n,m,ans;
int dx[4]={-1,0,0,1};
int dy[4]={0,-1,1,0};
int dfs(int x,int y)
{
	int x2=0,y2=0;
	if(f[x][y])               //如果不是0，即已经找到该点的最大值，直接返回，避免重复计算
	  return f[x][y];
	for(int i=0; i<4; i++)                 //找出四个方向中满足条件的最大值。
	 {
	 	x2=x+dx[i];
	 	y2=y+dy[i];
	 	if(x2>0&&x2<=n&&y2>0&&y2<=m)                  //与DP类似
	 	 {
	 	 	if(a[x][y]>a[x2][y2])
	 	 	  f[x][y]=max(dfs(x2,y2)+1,f[x][y]);
	 	 }
     }
    return f[x][y];
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)                    
	    cin>>a[i][j];
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)
	  {
	  	f[i][j]=dfs(i,j);         //把每个点都走一遍
	  	if(f[i][j]>ans)
	  	  ans=f[i][j];
	  }
	cout<<ans+1;       //同于DP
	return 0;
}
```

---

## 作者：garbage2 (赞：3)


DFS的思路非常简单，上下左右慢慢搜得了，再加上一个记忆化。

但重要的是剪枝，我在以下列举出来：

1. 首先要用到记忆化搜索，这样可以省去很多点的搜索时间。
1. 判断数组越界是很重要的一点，不然可能死循环。
1. 还有，判断要搜的点是否比当前点低，不然嗯嗯。

剪枝说道这，可以上代码了吧？？

# Warning

#### **重要！**

**不要从最高点搜，而是每个点都要搜！！！**

**不要从最高点搜，而是每个点都要搜！！！**

**不要从最高点搜，而是每个点都要搜！！！**

好了，可以上代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[105][105],f[105][105];
int m_x[4]={1,-1,0,0},
    m_y[4]={0,0,1,-1};
int dfs(int x,int y)
{
    if(f[x][y]) return f[x][y];		//剪枝1
    int i;
    int maxx=1;
    for(i=0;i<=3;i++){
        int x_2=x+m_x[i],
            y_2=y+m_y[i];
        if(x_2>=1&&x_2<=n&&y_2>=1&&y_2<=m&&a[x][y]<a[x_2][y_2])		//剪枝2,3
            maxx=max(dfs(x_2,y_2)+1,maxx);
    }
    f[x][y]=maxx;
    return maxx;
}
int main()
{
    //这道题算是废了，详见https://www.luogu.org/discuss/show/101927
    /*
        就在这里说说思路之类的吧……
        emming……
        Dfs是肯定的，二维数组开起来，上下左右慢慢跑
        然后对于每个点Dfs一边，取(长度)最大值
        然后输出，就这样了。
        可以的话，吧快读快写都写上。
        最后别忘了加上记忆话
    end
    */
    int i,j;
    scanf("%d%d",&n,&m);
    int ans=0;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){
            f[i][j]=dfs(i,j);	//每个点都搜
            ans=max(f[i][j],ans);	//更新最大值
        }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

这是本蒟蒻第一次写题解，多多关照。
(希望可以过审！！！洛谷大神please!!!)
P1434 [SHOI2002]滑雪这道题很显然是一道记忆化搜索题（oi的显然定律）
这里给不会记忆化的同学科普一下（会的大佬您请跳过）
一般说来，动态规划总要遍历所有的状态，而搜索可以排除一些无效状态。更重要的是搜索还可以剪枝，可能剪去大量不必要的状态，因此在空间开销上往往比动态规划要低很多。记忆化算法在求解的时候还是按着自顶向下的顺序，但是每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解了。这种方法综合了搜索和动态规划两方面的优点，因而还是很有实用价值的。
记忆化搜索在满足 1 函数返回结果只与参数有关 2 同样参数的函数会被多次调用的情况下可以优化算法是一种用空间换时间的方式。复杂度 n2
记忆化搜索=搜索的形式+动态规划的思想。
大家可以去写一下一道很经典的题数字三角形。
好了下面上代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};


int a[105][105];
int g[105][105];
int r,c;
int f(int x,int y){
	// 从 (x,y) 开始的最长路径长度 
	if(g[x][y]) return g[x][y];
	
	int ret = 1;
	for(int k=0;k<4;k++){
		int nx = x+dx[k];
		int ny = y+dy[k];
		if(nx>r || nx < 1 || ny > c || ny < 1) continue;
		if(a[nx][ny] < a[x][y]){
			ret = max(ret,f(nx,ny)+1);
		}
	}
	
	return g[x][y]=ret;
}

int main(){
	scanf("%d%d",&r,&c);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			scanf("%d",&a[i][j]);
		}
	}
	int ans = 0;
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			ans = max(ans, f(i,j));
		}
	}
	printf("%d\n",ans);
	
	
	
	return 0;
}
```


---

## 作者：Violette (赞：3)

这道题思路很简单，主要讲一下记忆化搜索&大家最喜欢的DP

那么，问题来了，记忆化搜索是什么？？？

简单来说，记忆化搜索=搜索+动态规划的思想。。。

那动态规划又是啥？？？

1.动态规划其实就是一个最优化问题，先将问题分解为子问题

2.对于这些分解的子问题自身就是最优的才能在这个基础上得出我们要解决的问题的最优方案。否则，就能找到一个更优的解来替代这个解。

3.动态规划不同于贪心算法，因为贪心算法是从局部最优来解决问题，而动态规划是全局最优的。

4.用动态规划的时候不可能在子问题还没有得到最优解的情况下就做出决策，而是必须等待子问题得到了最优解之后才对当下的情况做出决策。

5.往往动态规划都可以用一个或多个递归式来描述。而贪心算法却是先做出一个决策，然后在去解决子问题。这就是贪心和动态规划的不同。 

其余的可以参考代码，注释写的应该还算比较清晰qwq

```cpp
#include<iostream>
#include<algorithm>//使用max函数需要用到algorithm头文件 
using namespace std;
int n,m;
int a[105][105],s[105][105],ans;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};//存储方向 
int dfs(int x,int y){//x,y表示行、列 
	if(s[x][y]) return s[x][y];//搜过了，直接返回
	 s[x][y]=1;
	 for(int i=0;i<=3;i++){//4个方向
	 	int x_new=x+dx[i];//x+偏移量
		int y_new=y+dy[i];//y+偏移量
		if(x_new>0&&x_new<=n
		&&y_new>0&&y_new<=m
		&&a[x][y]>a[x_new][y_new]){//a[x][y]>a[x_new][y_new]表示当前滑雪坡大于下一个滑雪坡
			dfs(x_new,y_new);
			s[x][y]=max(s[x][y],s[x_new][y_new]+1);//把四个方向的最大值存入s[x][y] 
		}
	 } 
	 return s[x][y]; 
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)//读入 
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans=max(ans,dfs(i,j));//比较，存入ans 
	cout<<ans;//输出 
	return 0;
}
```
结束......

---

## 作者：花开依然爱Qu (赞：3)

其实本人最初的思路是爆搜，结果直接得了90，然后稍微改了下括号就变成了传说中的记忆化搜索其实本人最初的思路是爆搜，结果直接得了90，然后稍微改了下括号就变成了传说中的记忆化搜索

题目要求是从大到小滑，可是我们反过来也是成立的，并且从小的大可以很好地避免边界为0的情况。

```cpp
//#include<iostream>
//-#include<cstdio>
using namespace std;
int a[1001][1001],b[1001][1001];//a数组表示这个位置的高度，b数组表示不论从哪一点到此点后所能行走的最大步数。
int search(int x,int y,int s)//x，y表示此点位置，s表示从最初点到此点的步数
{
    s++;//走一步先加一
//    cout<<x<<" "<<y<<" "<<s<<endl;
    if(a[x][y]<a[x][y-1]&&y>1)//以下为通俗的四步走~~只有大神才会用~~
    {
        if(s>b[x][y-1]) //判断此点的步数是否大于以前来过的点，如果小于的话，直接就略过就行，如果大于的话，更新此点最大步数，并搜索下一个点，以下三步都是如此。
        {
        b[x][y-1]=s;
        search(x,y-1,s);
        }
    }
    if(a[x][y]<a[x][y+1]&&y<100)
    {
        if(s>b[x][y+1])
        {
         b[x][y+1]=s;
        search(x,y+1,s);
    }
    }
    if(a[x][y]<a[x-1][y]&&x>1)
    {
        if(s>b[x-1][y])
        {
         b[x-1][y]=s;
        search(x-1,y,s);
    }
    }
    if(a[x][y]<a[x+1][y]&&x<100)
    {
        if(s>b[x+1][y]) 
        {
        b[x+1][y]=s;
        search(x+1,y,s);}
    }
}
int main()
{
    int n,m,p=0;
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            scanf("%d",&a[i][j]);
        }
    }
    int k=1;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            search(i,j,1);//搜索每个点的最大步数。
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            if(k<b[i][j]) k=b[i][j];//找最大值
        }
    }
    cout<<k;
}
```

---

## 作者：封禁用户 (赞：2)


不洛谷第一不改名 2019/2/26 13:40:08
~~水题一道~~

~~旷课写的题解~~


------------
这题用最朴素的搜索,都可以拿90分,就是四个方向搜索


------------
~~如果还不会搜索的同学,请看下面~~


------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[300][300];int dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};
int	maxx=0; int r,c,a[200][200];
void dfs(int x,int y,int ans)
{
	if(ans+a[x][y]<maxx)
		return ;
    maxx=max(maxx,ans);
    int tx,ty;
    for(int i=1;i<=4;i++)
    {
        tx=x+dx[i];
        ty=y+dy[i];
        if(tx>0&&tx<=r&&ty>0&&ty<=c&&a[x][y]>a[tx][ty])
        {
            dfs(tx,ty,ans+1);
        }
    }
}
int main()
{
    //memset(dp,-1,sizeof(dp));
    
    scanf("%d%d",&r,&c);
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            scanf("%d",&a[i][j]);
        }	
    } 
    int ans=0;
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            dfs(i,j,1);
        }
    }
    cout<<maxx<< endl;
    return 0;
}
```
------------
上面的搜索只能拿90分,是因为没加剪枝,通常的剪枝假设说这题是求最小值,如果当前的长度已经大于最小长度,则可直接return ；这样可以减少不少的时间
但是本题是求最长长度,所以蒟蒻发现,他总是往下坡划（~~废话~~）
就是读入的长度一直在缩小,所以可以统计矩阵的最低的高度,然后拿当前的高度减去最低高度+当前的长度,如果这个值比最长长度小,直接return ;这是因为,你必须要往下滑,假设一个最好的状态:"剩下比你高度低的都是一个连通块,即使这样,也没法超过最长长度",所以直接return ；
虽然这个方法优化的时间不多,还是90;


------------

但蒟蒻开了O（2）后,没加剪枝的是超了
但加了剪枝的是100分;
~~可能O(2）if判断的快吧~~

下面是加了剪枝的100分搜索:~~蒟蒻写的代码都不好看,勿喷~~


------------


```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int dp[300][300];int dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};
int	maxx=0; int r,c,a[200][200];
int minn=0x7fffffff;//高度最低的高度; 
void dfs(int x,int y,int ans)
{
	if(ans+a[x][y]-minn<=maxx)
		return ;
    maxx=max(maxx,ans);
    int tx,ty;
    for(int i=1;i<=4;i++)
    {
        tx=x+dx[i];
        ty=y+dy[i];
        if(tx>0&&tx<=r&&ty>0&&ty<=c&&a[x][y]>a[tx][ty])
        {
            dfs(tx,ty,ans+1);
        }
    }
}
int main()
{
    //memset(dp,-1,sizeof(dp));
    
    scanf("%d%d",&r,&c);
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            scanf("%d",&a[i][j]);
        }	
    } 
    for(int i=1;i<=r;i++)
    {
    	for(int j=1;j<=c;j++)
    	{
    		if(a[i][j]<minn)
    			minn=a[i][j];
		}
	}
    int ans=0;
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            dfs(i,j,1);
        }
    }
    cout<<maxx<< endl;
    return 0;
}

```


------------
接下来是记忆化搜索:
强调:记忆化搜索是一个技巧，而不是一个算法;
他为了让每种状态都只搜索一遍,这样就能减少不少时间复杂度


------------
记忆化搜索：设f[i][j]表示从i,j开始滑的最长长度,蒟蒻写了一个记忆化搜索模板


------------
```cpp
int f[i][j]//这是本题因为是坐标(x,y),所以f定二维,其他情况有的定一维,也有定四维等
int dfs(int x,int y)
{
	if(f[x][y]不为0,即x,y坐标已经有最长的长度)
		return f[x][y];
	else
		for(i=1;i<=上下左右四个方向;i++)
         {
              if(满足条件)
               {
                     dfs(tx,ty)//即搜索到下一个位置
                     if(可更新f数组)
                     	更新f数组
                }

          }
}
```


------------
有人想问我:"为什么步数不放到参数里了？"
这是因为,参数越少,记忆化搜索就约好写
接下来是记忆化搜索代码


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[300][300];int dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};
int ans;
int	maxx=0; int r,c,a[200][200];
int dfs(int x,int y)
{
	if(dp[x][y]!=1)	//if这个地方已经有最长长度,直接返回这个最长长度; 
		return dp[x][y];
    int tx,ty;
    int ans=0;//ans初始化特别重要 
    for(int i=1;i<=4;i++)	
    {	
        tx=x+dx[i];
        ty=y+dy[i];
        if(tx>0&&tx<=r&&ty>0&&ty<=c&&a[x][y]>a[tx][ty])
        {
        	ans=max(ans,dfs(tx,ty)+1);//用来比较哪个这个坐标的答案更大 
        }
        dp[x][y]=max(dp[x][y],ans);//记忆化搜索的每个坐标的答案更新; 
    }	
    return dp[x][y];//返回最长长度 
}
int main()
{
    scanf("%d%d",&r,&c);
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            scanf("%d",&a[i][j]);
        }	
    }
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
			dp[i][j]=1;
	} //每个点的最长长度都为1 
    int ans=0;
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            int ans=dfs(i,j);
            maxx=max(maxx,ans);//每个点为起点开始滑 
        }
    }
    cout<<maxx<< endl;//输出最长长度; 
    return 0;
}
```


------------
~~旷课写出来的题解,编写的过程特别不容易,还望管理员大大通过~~

---

## 作者：a2956331800 (赞：2)

奇怪的广搜：思考一下题目，对于每个点，如果它比四周的点都低，那么从这个点开始的距离一定是一（边界视为无限高）；对于任意一个点，如果它四周比它低的点的最长距离都已确定，就能确定这个点的最长距离（周围点的最长距离的最大值+1），按照这个思路先扫一遍图，把比周围的点低的点都放入队列，同时记录每个点周围的哪几个（注意不是几个，而是哪几个）点比它低；然后开始更新，每次从队列头取一个点，更新周围比它高的点的最长距离和上面说到的比它低的点的情况，如果更新到的点四周比它低的点都已确定，那么这个点也确定了，就将它放入队列，全部处理完之后遍历全图找最大距离就可以了。

代码：

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<queue>
    using namespace std;
    int i,j,R,C,t[200][200],ans[200][200],lower[200][200][5];
    queue<int> x,y;
    int main()
    {
        cin>>R>>C;
        for(i=1;i<=R;i++)
          for(j=1;j<=C;j++)
            cin>>t[i][j];
        for(i=0;i<=R;i++)
          t[i][0]=t[i][C+1]=0x7fffffff;
        for(i=0;i<=C;i++)
          t[0][i]=t[R+1][i]=0x7fffffff;
        for(i=1;i<=R;i++)
          for(j=1;j<=C;j++)
          {
              if(t[i][j]>t[i-1][j])
                lower[i][j][1]=1;
              if(t[i][j]>t[i+1][j])
                lower[i][j][2]=1;
              if(t[i][j]>t[i][j-1])
                lower[i][j][3]=1;
              if(t[i][j]>t[i][j+1])
                lower[i][j][4]=1;
              if(lower[i][j][1]+lower[i][j][2]+lower[i][j][3]+lower[i][j][4]==0)
                x.push(i),y.push(j),ans[i][j]=1;
          }
        int nx,ny;
        while(!x.empty())
        {
            nx=x.front();ny=y.front();x.pop();y.pop();
            if(t[nx][ny]<t[nx-1][ny])
            {
                lower[nx-1][ny][2]=0;
                if(ans[nx-1][ny]<=ans[nx][ny]&&lower[nx][ny][1]+lower[nx][ny][2]+lower[nx][ny][3]+lower[nx][ny][4]==0)
                {
                    ans[nx-1][ny]=max(ans[nx][ny]+1,ans[nx-1][ny]);
                    x.push(nx-1);y.push(ny);
                }
                else ans[nx-1][ny]=max(ans[nx][ny]+1,ans[nx-1][ny]);
            }
            if(t[nx][ny]<t[nx+1][ny])
            {
                lower[nx+1][ny][1]=0;
                if(ans[nx+1][ny]<=ans[nx][ny]&&lower[nx][ny][1]+lower[nx][ny][2]+lower[nx][ny][3]+lower[nx][ny][4]==0)
                {
                    ans[nx+1][ny]=max(ans[nx][ny]+1,ans[nx+1][ny]);
                    x.push(nx+1);y.push(ny);
                }
                else ans[nx+1][ny]=max(ans[nx][ny]+1,ans[nx+1][ny]);
            }
            if(t[nx][ny]<t[nx][ny-1])
            {
                lower[nx][ny-1][4]=0;
                if(ans[nx][ny-1]<=ans[nx][ny]&&lower[nx][ny][1]+lower[nx][ny][2]+lower[nx][ny][3]+lower[nx][ny][4]==0)
                {
                    ans[nx][ny-1]=max(ans[nx][ny]+1,ans[nx][ny-1]);
                    x.push(nx);y.push(ny-1);
                }
                else ans[nx][ny-1]=max(ans[nx][ny]+1,ans[nx][ny-1]);
            }
            if(t[nx][ny]<t[nx][ny+1])
            {
                lower[nx][ny+1][3]=0;
                if(ans[nx][ny+1]<=ans[nx][ny]&&lower[nx][ny][1]+lower[nx][ny][2]+lower[nx][ny][3]+lower[nx][ny][4]==0)
                {
                    ans[nx][ny+1]=max(ans[nx][ny]+1,ans[nx][ny+1]);
                    x.push(nx);y.push(ny+1);
                }
                else ans[nx][ny+1]=max(ans[nx][ny]+1,ans[nx][ny+1]);
            }
        }
        int answer=0;
        for(i=1;i<=R;i++)
          for(j=1;j<=C;j++)
            answer=max(answer,ans[i][j]);
        cout<<answer;
        return 0;
}
```

---

## 作者：xzyxzy (赞：2)

看到大家都用搜索，我用拓扑排序来水一波

这道题是几个月前团队布置的题目，然后一直T90分，直到快Noip才开始补作业/笑哭/

然后这道题把它抽象成图，每隔点只能走向四周比它低的点，所以就是一条路径嘛

把每个点编号，从这个点向四周连边（只要数值比它低就可以连）

可以发现这是一个DAG（有向无环图）

拓扑排序+dp思想就可以AC了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<queue>
#include<cstring>
#define RG register 
using namespace std;
inline int read()
{
    RG char ch=getchar();
    while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
    RG int h=0,t=1;
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){h=h*10+ch-48;ch=getchar();} 
    return h*t;
} 
int R,C;//R行C列
int a[201][201];//存储地图 
int head[10001],cnt=0;
struct edge{
    int next;
    int to;
}r[50001];
int in[10001];
int dp[10001];
int used[10001];
queue<int>Q;
void link(int x,int y)
{
    r[++cnt].next=head[x];
    r[cnt].to=y;
    head[x]=cnt;
    in[y]++;
}
int main()
{
    R=read();C=read();
    memset(head,-1,sizeof(head));
    for(RG int i=1;i<=R;i++)
        for(RG int w=1;w<=C;w++)
             a[i][w]=read();
    for(RG int i=1;i<=R;i++)
        for(RG int w=1;w<=C;w++)
        {
            if(i+1<=R&&a[i][w]>a[i+1][w])link((i-1)*C+w,i*C+w);
            if(i-1>=1&&a[i][w]>a[i-1][w])link((i-1)*C+w,(i-2)*C+w);
            if(w+1<=C&&a[i][w]>a[i][w+1])link((i-1)*C+w,(i-1)*C+w+1);
            if(w-1>=1&&a[i][w]>a[i][w-1])link((i-1)*C+w,(i-1)*C+w-1);
        }
    for(int i=1;i<=R*C;i++)
        if(in[i]==0){dp[i]=1;Q.push(i);used[i]=1;}
    while(!Q.empty())
    {
        int now=Q.front();Q.pop();
        for(int i=head[now];i!=-1;i=r[i].next)
        {
            if(used[r[i].to])continue;
            in[r[i].to]--;
            dp[r[i].to]=max(dp[r[i].to],dp[now]+1);
            if(in[r[i].to]==0){Q.push(r[i].to);used[r[i].to]=1;}
        }
    }
    int ans=0;
    for(int i=1;i<=R*C;i++)ans=max(ans,dp[i]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：浪矢杂货店 (赞：2)

不知道为什么 现在就算想写深搜 脑子也只有动态规划。。。

题解里说dp很慢 然而我的提交全0ms？可能是显示有问题吧。。。。


思路是 从某一点出发所能得到的最大滑道 f(i,j)=max(f(i+1,j)，f(i,j+1)，f(i-1,j)，f(i,j-1))+1;


纯dp就行了。。。没什么高端操作

代码：









    
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=102;
int n,m;
int map[maxn][maxn];
int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//方向数组
int ans=0;
int f[maxn][maxn];
bool jilu[maxn][maxn];
int dp(int x,int y)
{
    if(jilu[x][y]) return f[x][y];
    jilu[x][y]=1;
    int tp=0;
    for(int i=0;i<4;i++)
    {
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(map[newx][newy]<map[x][y] && newx>=1 && newy>=1 && newx<=n && newy<=m)
          tp=max(tp,dp(newx,newy));
    }
    f[x][y]=tp+1;
    return f[x][y];
}
//抄代码的 你的良心不会痛吗23333333
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
         scanf("%d",&map[i][j]);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
         ans=max(ans,dp(i,j));//ans记录所有f(i,j)的最大值，由于记忆化的存在，多次调用dp并不会很慢
    }
    printf("%d",ans);
    return 0;
} //好了我要去想想记忆化搜索怎么做了2333333

```

---

## 作者：shenyi1343395317 (赞：2)

分享一种暴力算法；因为空间上的问题，所以只有80分(感觉时间上也过不去)，可作为对拍使用

思路：滑雪就是最长下降序列，也可以理解为**最长路**。

所以，可以试着把可以滑下去的2点连起来，边权为1。

这样，就形成了一张图。由于求的是所有点对的最长路径，我们采用floyd算法。

以下是程序

```cpp
program sss;
  var dis:array[0..5000,0..5000] of integer;  
      //dis存2点距离，由于总共有10000个点，空间上吃不消
      a:array[-8..4000000] of integer;
      i,j,m,n,k,r,c,max:longint;
  begin
  read(c,r);
  for i:=1 to r*c do 
    begin
    read(a[i]);
    if a[i]<=0 then dec(a[i]);
    end;                         //采用顺序读入，顺便去除0的数据，防止对下面造成影响
  for i:=1 to r*c do       //若2点相邻且符合要求则加上边                    
   begin
   if ((a[i-1]<>0) and (a[i]>a[i-1])) then inc(dis[i,i-1]);
   if ((a[i+1]<>0) and (a[i]>a[i+1])) then inc(dis[i,i+1]);
   if ((a[i-c]<>0) and (a[i]>a[i-c])) then inc(dis[i,i-c]);
   if ((a[i+c]<>0) and (a[i]>a[i+c])) then inc(dis[i,i+c]);
   end;
  for k:=1 to r*c do
   for i:=1 to r*c do
    for j:=1 to r*c do
    begin
    if max<dis[i,j] then max:=dis[i,j];
    if ((dis[i,k]<>0) and (dis[k,j]<>0)) then
    if dis[i,k]+dis[k,j]>dis[i,j] then
    begin
    dis[i,j]:=dis[i,k]+dis[k,j];
    if max<dis[i,j] then max:=dis[i,j];
    end;
    end;                  //floyd算法逆用求最长路
   writeln(max+1); //同时也要把自己算上。
  end.
```
AC的程序就是大家熟知的记忆化搜索了
思路：每次搜索把距离求出并保存，如果已经存在就直接获取数值

```cpp
program sss;
  var a,dis:array[1..100,1..100] of integer;
      go1:array[1..4] of integer=(0,0,1,-1);
      go2:array[1..4] of integer=(-1,1,0,0);
      max,i,j,n,m,r,c:longint;
  function dfs(x,y:longint):longint;
  var i,j,ans,max,x1,y1:longint;
  begin
  max:=1;
  if dis[x,y]>0 then exit(dis[x,y]);
  for i:=1 to 4 do
    begin
    x1:=x+go1[i];
    y1:=y+go2[i];
    if ((x1>0) and (x1<=r) and (y1>0) and (y1<=c) and (a[x1,y1]<a[x,y])) then
      begin
      ans:=dfs(x1,y1)+1;
      if ans>max then max:=ans;
      end;
    end;
  dis[x,y]:=max;
  exit(max);
  end;
  begin
  read(r,c);
  for i:=1 to r do
   for j:=1 to c do read(a[i,j]);
  readln;
  for i:=1 to r do
   for j:=1 to c do
   begin
   dis[i,j]:=dfs(i,j);
   if dis[i,j]>max then max:=dis[i,j];
   end;
  writeln(max);
  readln;
  end.

```

---

## 作者：Great瞿葩 (赞：2)

其实我干了一件很坏的事儿~

貌似R\*C只有10000哈，干脆先把高度排序，然后递推(我也不知道是不是动规来着)，保证矮的比高的先求出。

显然一个标准的快排~


```delphi

program qyp_ski;
const a:array[1..4]of longint=(1,0,-1,0);
      b:array[1..4]of longint=(0,1,0,-1);
var h,x,y:array[0..10001]of longint;
    i,j,k,r,c,d,s,max:longint;
    p,f:array[0..101,0..101]of longint;
procedure sort(l,r:longint);
var i,j,c,d:longint;
begin
  i:=l;j:=r;c:=h[(l+(r shl 1))div 3];
  repeat
   while c>h[i] do inc(i);
   while h[j]>c do dec(j);
   if not(i>j) then
    begin
     d:=h[i];h[i]:=h[j];h[j]:=d;
     d:=x[i];x[i]:=x[j];x[j]:=d;
     d:=y[i];y[i]:=y[j];y[j]:=d;
     inc(i);dec(j);
    end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
begin
  assign(input,'ski.in');reset(input);
  assign(output,'ski.out');rewrite(output);
   readln(r,c);
   fillchar(p,sizeof(p),$7F);
   for i:=1 to r do
    for j:=1 to c do
     begin
      read(d);s:=(i-1)*c+j;
      p[i,j]:=d;
      h[s]:=d;x[s]:=i;y[s]:=j;
     end;
   sort(1,r*c);
   fillchar(f,sizeof(f),0);
   s:=r*c;
  for d:=1 to s do
   for k:=1 to 4 do
    if p[x[d],y[d]]>p[x[d]+a[k],y[d]+b[k]] then
     if f[x[d],y[d]]<f[x[d]+a[k],y[d]+b[k]]+1 then
      f[x[d],y[d]]:=f[x[d]+a[k],y[d]+b[k]]+1;
    max:=0;
   for i:=1 to r do
    for j:=1 to c do
     if f[i,j]>max then max:=f[i,j];
    write(max+1);
  close(input);close(output);
end.

```
**表示自己机子测前9个点0.00S过，最后一个点0.01S过**


---

## 作者：eddh4 (赞：2)

感谢first_fan大佬的提醒（我之前一直以为memset可以直接开墙后来改成别的方法就AC了，~~硬核加墙~~）

因为从一个点可走的最长路是固定的，所以很容易想到用记忆化，开一个数组把每个点所能走的最长路记下来（m[x][y]）如果想用就调出来，听说还可以用DP，但本蒟蒻太菜了，只会爆搜（顶多加点剪枝，记忆化什么的）

代码如下（管理员大大求过）

```cpp

#include<bits/stdc++.h>//万能头文件
using namespace std;
int r,c,m[105][105],ans=-1;long long a[105][105];//没范围，long long保险一点
bool ch[105][105];
int back=-1,ex[4]={0,1,0,-1},ey[4]={1,0,-1,0};
void dfs(int x,int y,int k);
int main(){
	scanf("%d%d",&r,&c);
	for(int i=0;i<=r+1;i++) a[i][0]=2^63-1;
	for(int i=0;i<=c+1;i++) a[0][i]=2^63-1;
	for(int i=0;i<=r+1;i++) a[i][c+1]=2^63-1;
	for(int i=0;i<=c+1;i++) a[r+1][i]=2^63-1;//硬核开墙
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			scanf("%lld",&a[i][j]);
		}
	}
	memset(ch,false,sizeof(ch));
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			dfs(i,j,1);
			m[i][j]=back;
			back=-1;
			ch[i][j]=true;
		}
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			ans=max(ans,m[i][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
void dfs(int x,int y,int k){//记忆化搜索
	if(k>back&&a[x+1][y]>=a[x][y]&&a[x][y+1]>=a[x][y]&&a[x-1][y]>=a[x][y]&&a[x][y-1]>=a[x][y]){
		back=k;
		return;
	}//如果四周都去不了，比较一下就返回
	int x1,y1;
	for(int i=0;i<4;i++){
		x1=x+ex[i];
		y1=y+ey[i];
		if(a[x1][y1]<a[x][y]){//因为前面开了墙所以不要特判
			if(ch[x1][y1]){
				k+=m[x1][y1];
				if(back<k){
					back=k;
				}
				k-=m[x1][y1];
			}
			else{
				dfs(x1,y1,k+1);
			}
		}
	}
}


```



---

## 作者：Freyja (赞：2)

有人说我是记忆化搜索和递推杂糅？哎呀不管啦不管啦~能过就行~

思路就是如上（捂脸逃），代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;
int r,c,a[105][105]={0},d[105][105]={0},maxn=0,book[105][105]={0};
int dfs(int x,int y)
{
    //if (book[x][y]==1) return d[x][y];
    //int t=d[x][y];
    if (d[x][y]>0) return d[x][y];
    d[x][y]=1;
    if (x!=1 && a[x-1][y]>a[x][y])
    {
        if (d[x-1][y]==0) d[x][y]=max(d[x][y],dfs(x-1,y)+1);
        else d[x][y]=max(d[x][y],d[x-1][y]+1);
    }
    if (x!=r && a[x+1][y]>a[x][y])
    {
        if (d[x+1][y]==0) d[x][y]=max(d[x][y],dfs(x+1,y)+1);
        else d[x][y]=max(d[x][y],d[x+1][y]+1);
    }
    if (y!=1 && a[x][y-1]>a[x][y])
    {
        if (d[x][y-1]==0) d[x][y]=max(d[x][y],dfs(x,y-1)+1);
        else d[x][y]=max(d[x][y],d[x][y-1]+1);
    }
    if (y!=c && a[x][y+1]>a[x][y])
    {
        if (d[x][y+1]==0) d[x][y]=max(d[x][y],dfs(x,y+1)+1);
        else d[x][y]=max(d[x][y],d[x][y+1]+1);
    }
    //if (t==d[x][y]) book[x][y]=1;
    maxn=max(d[x][y],maxn);
    return d[x][y];
}
int main()
{
    scanf("%d%d",&r,&c);
    for (int i=1;i<=r;i++)
    {
        for (int j=1;j<=c;j++)
        {
            scanf("%d",&a[i][j]);
            d[i][j]=0;
        }
    }
    for (int i=1;i<=r;i++)
    {
        for (int j=1;j<=c;j++)
        {
            if (d[i][j]==0) maxn=max(maxn,dfs(i,j));
        }
    }
    printf("%d",maxn);
    return 0;
}
```

---

## 作者：Aehnuwx (赞：2)

【NOIP倒计时：13天，题号：P1434】

看到不少人都用了DP，我认为记忆化搜索也不错。因为搜索可以通过剪枝剪去大量不必要的状态，所以在空间开销上通常比动规低。

算法分析：

一个人可以从某一个点滑向上下左右相邻四个点之一。当且仅当高度减小，对于任意一个点[i][j]，当它的高度小于与之相邻的四个点（[i-1][j],[i][j+1],[i+1][j],[i]j-1]）的高度时，这四个点可以滑向[i][j]，用f[i][j]表示到[i][j]为止的最大长度，则f[i][j]=max{f[i+a][j+b]}+1，其中坐标增量{(a,b)=[(1,0),(-1,0),(0,1),(0,-1)]，0<i+a<=r,0<j+b<=c,High[i][j]<High[i+a][j+b]}。为了保证满足条件的f[i+a][j+b]在f[i][j]前算出，需要对高度排一次序，然后从大到小规划（高度）。最后再比较一下所有f[i][j]{0<i<=r,0<j<=c}，找出其中最长的一条路线。


---

## 作者：lzx1999 (赞：2)

##### BFS+记忆化		
看到有人发广搜的代码了，但是说STL渣我就不能忍了
BFS + 记忆话搜索 再加上我用的是STL
其实该开始我就是想求最长路径的长度就用我就是想先把路径大小从大到小排序然后从最大的搜索搜到最小的看最长的有多少然而理所当然的第二个点超时了
第一次90分代码如下
```cpp
#include <queue>//队列的头文件
#include <cstdio>
#include <iostream>//我写代码都是直接吧这两个头文件直接写上去的不管用没有用
#include <algorithm>//我不想写一个max函数了
using namespace std;
struct Good //对于b数组和队列q i和j都是储存该点的坐，对于数组b来说 num储存的是该座标的值队列q储存的是该坐标元素是从前到后第几个元素
{
    int i;
    int j;
    int num;
}b[10010];
int a[110][110];//正确的储存读入的二维数组
bool cmp(const Good& a,const Good& b)
{
    return a.num > b.num;//使该结构体如果要排序的话按照降序方式排序
}
const int lj[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};//上右下左的顺序
int main()
{
    queue<Good>q;//定义一个队列
    int qs = 0;//储存b数组的元素好像可以用其他代数式代替，不过无所谓了
    int n,m;
    cin >> n >> m;
    for(int i = 1 ;i <= n ; i ++)
        for(int j = 1; j <= m ; j ++)
        {
            cin >> a[i][j];//正确的读入
            b[qs].i = i;//按顺序读入到一维数组中
            b[qs].j = j;
            b[qs ++].num = a[i][j];
        }
    int ans = -1;//先初始化最长的长度为-1
    sort(b,b + qs, cmp);//排序b数组
    for(int i = 0; i < qs/2 + 1 ; i ++)//这里的qs/2是一个玄学优化，不过洛谷上好像没有数据能卡这个
    {
        q.push({b[i].i,b[i].j,1});先找最大的一个元素入列，后面的元素依次入列
        while(!q.empty())//如果队列不为空
        {
            Good qa = q.front();//取出队首元素
            q.pop();
            ans = max(qa.num,ans);//判断长度
            for(int j = 0;j < 4; j ++)
            {
                int x = qa.i + lj[j][0];//往四个方向依次查找
                int y = qa.j + lj[j][1];
                if(x >= 1 && x <= n && y >= 1 && y <= m && a[x][y] < a[qa.i][qa.j])//如果这个数没有出界，并且严格小于上一个元素就入列
                {
                    q.push({x,y,qa.num + 1});
                }
            }
        }
    }
    cout << ans << endl;//输出最大长度
    return 0;
}

```
然后这样第二个点就理所当然的TLE了，所以我在想如果判断ans大于总数的一半然后循环到一半以后那样后面的东西不就可以不判断了吗
然后就理所当然的TLE了，毕竟感觉剪枝剪的好随便
就是在循环里加了一个
```cpp
if(ans > qs / 2 ) break;

```
然后点开标签记忆化搜索，记忆化搜索时什么东西？？？
然后在我苦思冥想的时候想出来了，如果我倒着来入队
然后然后去搜索他的长路径并且保存下来然后后面搜索到这里的时候直接用路径长度加上哪一个元素的最长路径长度就可以然后这道题就AC了

```cpp
#include <queue>//队列的头文件
#include <cstdio>
#include <iostream>//我写代码都是直接吧这两个头文件直接写上去的不管用没有用
#include <algorithm>//我不想写一个max函数了
using namespace std;
struct Good//对于b数组和队列q i和j都是储存该点的坐，对于数组b来说 num储存的是该座标的值队列q储存的是该坐标元素是从前到后第几个元素
{
    int i;
    int j;
    int num;
}b[10010];
int a[110][110];//正确的储存读入的二维数组
int s[110][110];//储存每一个点的最大路径长度
bool cmp(const Good& a,const Good& b)
{
    return a.num < b.num;/使该结构体如果要排序的话按照升序方式排序
}
const int lj[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};//上右下左的顺序
int main()
{
    queue<Good>q;//定义一个队列
    int qs = 0;//储存b数组的元素好像可以用其他代数式代替，不过无所谓了
    int n,m;
    cin >> n >> m;
    for(int i = 1 ;i <= n ; i ++)
        for(int j = 1; j <= m ; j ++)
        {
            cin >> a[i][j];//正确的读入
            b[qs].i = i;//按顺序读入到一维数组中
            b[qs].j = j;
            b[qs ++].num = a[i][j];
        }
    int res = -1;//先初始化最长的长度为-1
    sort(b,b + qs, cmp);//排序b数组
    for(int i = 0; i < qs  + 1 ; i ++)//这里没有那个玄学优化了
    {
        q.push({b[i].i,b[i].j,1});先找最小的一个元素入列，后面的元素依次入列
        while(!q.empty())//如果队列不为空
        {
            int ans = 0;
            Good qa = q.front();//取出队列首元素
            q.pop();
            ans = max(qa.num,ans);//储存从该点的最大长度
            for(int j = 0;j < 4; j ++)
            {
                int x = qa.i + lj[j][0];
                int y = qa.j + lj[j][1];
                if(x >= 1 && x <= n && y >= 1 && y <= m && a[x][y] < a[qa.i][qa.j])//如果这个数没有出界，并且严格小于上一个元素就入列
                {
                    if(s[x][y] != 0) ans = max(ans, qa.num + s[x][y]);//判断搜索的元素是否被搜索过，如果被搜索过则长度为该点的路径长度+从最初的点到这里的长度
                    else q.push({x,y,qa.num + 1});
                }
            }
            s[qa.i][qa.j] = ans;//储存该点的长度
            res = max(res,ans);//储存最长的长度
        }
    }
    cout << res << endl;//输出最长的长度
    return 0;
}

```
###### ~~虽说一大堆警告不过不要在意了~~

---

## 作者：SofanHe (赞：2)

# 显然,此题使用记忆化搜索进行.


# 然后我的基本思路也是使用记忆化搜索,但是就处理边界问题方面我做出了特殊处理.


# 即把数组多开一圈,将数据范围外围的高度变成0x7ffffff;


# 具体处理为两个FOR循环.时间复杂度(r+m-4)


# 这样在写搜索记忆化的时候就简单很多.

```cpp
#include<iostream>
using namespace std;
int r,m,hi[102][102],lest[101][101],bh[2][4]={{0,-1,0,1},{1,0,-1,0}},maxh;
int slow(int x,int y){
    if(lest[x][y]!=0)return  lest[x][y];
    for(int i=0;i<=3;i++)if(hi[x+bh[0][i]][y+bh[1][i]]<hi[x][y])lest[x][y]=max(lest[x][y],slow(x+bh[0][i],y+bh[1][i])+1);//这样方程就不需要判定越界了.
    lest[x][y]=max(lest[x][y],1);maxh=max(maxh,lest[x][y]);return  lest[x][y];              //直接记录
}
int main(){
    cin>>r>>m;
    for(int i=1;i<=r;i++)for(int j=1;j<=m;j++){cin>>hi[i][j];}
    for(int i=0;i<=r;i++){hi[i][0]=0x7ffffff;hi[i][m+1]=0x7ffffff;}                          //上文提到了,处理边界问题的高度
    for(int i=1;i<m;i++){hi[0][i]=0x7ffffff;hi[r+1][i]=0x7ffffff;}                            // 同样,但此处使用1为起点的原因是0那边已经处理过了
    for(int i=1;i<=r;i++)for(int j=1;j<=m;j++)slow(i,j);                 //正常的搜索
    cout<<maxh;return 0;
}
```

---

## 作者：king_xbz (赞：1)

拿到这题，一开始想到的是二维最大不上升子序列和，然而，羸弱的码力让我很快放弃了这一想法。

由于这题的最长滑道的起点不确定，递推不是很方便（当然对于题解区的一众神佬而言非常简单），所以我就写了个记忆化搜索。

我们知道，滑雪可以往上下左右四个方向移动，所以我们可以遍历整张图，向四个方向进行搜索,并进行记忆化处理以防超时。

code：
```cpp
inline int mfs(int x,int y)
{
	int maxxs=0;
	if(f[x][y]!=1)
	return f[x][y];
	if(x>1&&y>=1&&x<=n&&y<=m&&h[x-1][y]>h[x][y])
	maxxs=max(maxxs,mfs(x-1,y));
	if(x>=1&&y>1&&x<=n&&y<=m&&h[x][y-1]>h[x][y])
	maxxs=max(maxxs,mfs(x,y-1));
	if(x>=1&&y>=1&&x<n&&y<=m&&h[x+1][y]>h[x][y])
	maxxs=max(maxxs,mfs(x+1,y));
	if(x>=1&&y>=1&&x<=n&&y<m&&h[x][y+1]>h[x][y])
	maxxs=max(maxxs,mfs(x,y+1));
	return f[x][y]=maxxs+1;
}
```

PS:搜之前别忘了进行预处理哟
```cpp
for(fint i=1;i<=n;i++)
	for(fint j=1;j<=m;j++)
	{
		h[i][j]=read();
		f[i][j]=1;
	}
	int tot=0;
 ```
 
最后放上完整代码：
```cpp
#include<bits/stdc++.h>
#define u 4501
#define p 436545
#define fint register int
#define inf 235534652
using namespace std;
int h[u][u];
int f[u][u];
int n,m;
inline int mfs(int x,int y);
inline int read();
signed main()
{
	n=read();
	m=read();
	for(fint i=1;i<=n;i++)
	for(fint j=1;j<=m;j++)
	{
		h[i][j]=read();
		f[i][j]=1;
	}
	int tot=0;
	for(fint i=1;i<=n;i++)
	for(fint j=1;j<=m;j++)
	tot=max(tot,mfs(i,j));
	cout<<tot;
	return 0;
}

inline int mfs(int x,int y)
{
	int maxxs=0;
	if(f[x][y]!=1)
	return f[x][y];
	if(x>1&&y>=1&&x<=n&&y<=m&&h[x-1][y]>h[x][y])
	maxxs=max(maxxs,mfs(x-1,y));
	if(x>=1&&y>1&&x<=n&&y<=m&&h[x][y-1]>h[x][y])
	maxxs=max(maxxs,mfs(x,y-1));
	if(x>=1&&y>=1&&x<n&&y<=m&&h[x+1][y]>h[x][y])
	maxxs=max(maxxs,mfs(x+1,y));
	if(x>=1&&y>=1&&x<=n&&y<m&&h[x][y+1]>h[x][y])
	maxxs=max(maxxs,mfs(x,y+1));
	return f[x][y]=maxxs+1;
}

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
```

---

## 作者：swl3992 (赞：1)

$知识点:$

# $\Huge\texttt{记忆化爆搜}$

这是本蒟蒻看到[P1434 [SHOI2002]滑雪](https://www.luogu.org/problem/P1434)后的思路

基本的思路就是：
## 从每一个点开始向四个方向记忆化爆搜，直到出界或无法向下滑

#### 废话不多说，直接上代码



------------

```cpp
#include <iostream>
#define N 101  
//最大数据范围100，定义101
using namespace std;

int map[N][N],len[N][N];//map数组用于储存地图，len数组代表从某个位置开始滑最多能滑多远

int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}};//偏移量，代表往四个方向滑x和y坐标需要增加多少

int r,c;

int dp(int i,int j){//记忆化爆搜函数,i和j分别代表x和y坐标

    if(len[i][j]!=0)return len[i][j];//如果已经搜过了，直接返回
    
    int maxx = 0;//最大max
    
	int s;//往某个方向
    
    for(int t = 0;t < 4; t++){//四个方向枚举
    
          int temx = i + dir[t][0];//新的x坐标
          
		  int temy = j + dir[t][1];//新的y坐标
          
          if(temx >= 0 && temx < r && temy >= 0 && temy < c /*前面判断是否出界*/&& map[temx][temy] < map[i][j]/*判断能不能往下滑*/){
          
              s = dp(temx,temy);//递归调用，往这个方向滑能滑多远
              
              if(s > maxx) maxx=s;//更新max
          }       
      }
      
    len[i][j] = maxx + 1;//一定要加一！！！因为自己这个地方也要滑
    
    return len[i][j];//返回结果
}

int main(){

		cin>>r>>c;
        
        int mx=-1;//最终结果max
        
        for(int i=0;i<r;i++){//输入，不多说
        
           for(int j=0;j<c;j++){
           
			   cin>>map[i][j];
		   }
		}
        for(int i=0;i<r;i++){//枚举从每个点开始滑
        
           for(int j=0;j<c;j++){
           
			   len[i][j]=dp(i,j);//计算结果
               
			   if(len[i][j]>mx){//更新max
               
			      mx=len[i][j]; 
			   }
		   }         
        }
        
		cout<<mx;//输出答案
        
	    return 0;
}
```
~~完美的end~~



---

## 作者：没有输入 (赞：1)

# 深度优先搜索 & 剪枝

看了楼下dalao的**动态规划**和**记忆化搜索**，决定发一篇暴力的做法——**DFS**。

### 基本思路

枚举，计算以每个点为起点的最长下滑距离。取最大值输出即可。

## 纯DFS

枚举起点
```cpp
for(int i=1; i<=r; i++)
	for(int j=1; j<=c; j++) dfs(i,j,1);
```

如果无法朝所有方向下滑了（该方向高度大于等于原地或超出边界），就比较最长下滑距离，取max即可

```cpp
if((a[x+1][y]>=a[x][y]||x>=r)&&(a[x-1][y]>=a[x][y]||x<2)&&(a[x][y+1]>=a[x][y]||y>=c)&&(a[x][y-1]>=a[x][y]||y<2))
{
	ans=max(ans,sum);
	return;
}
```

否则就对四个方向进行搜索

```cpp
for(int i=0;i<4;i++)
{
	int nx=x+dx[i],ny=y+dy[i];
	if(nx>0&&ny>0&&nx<=r&&ny<=c&&a[nx][ny]<a[x][y]) dfs(nx,ny,sum+1);
}
```

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,c,a[105][105],Min=1e9,ans=1,dx[4]= {0,0,-1,1},dy[4]= {-1,1,0,0};
void dfs(int x,int y,int sum)
{
	if((a[x+1][y]>=a[x][y]||x>=r)&&(a[x-1][y]>=a[x][y]||x<2)&&(a[x][y+1]>=a[x][y]||y>=c)&&(a[x][y-1]>=a[x][y]||y<2))
	{
		ans=max(ans,sum);
		return;
	}
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>0&&ny>0&&nx<=r&&ny<=c&&a[nx][ny]<a[x][y]) dfs(nx,ny,sum+1);
	}
}
int main()
{
	scanf("%d%d",&r,&c);
	for(int i=1; i<=r; i++)
		for(int j=1; j<=c; j++) scanf("%d",&a[i][j]),Min=min(Min,a[i][j]);
	for(int i=1; i<=r; i++)
		for(int j=1; j<=c; j++) dfs(i,j,1);
	printf("%d",ans);
	return 0;
}
```

### 如果你这样提交了，恭喜你，成功TLE（手动滑稽）

要是这样都能过，还要剪枝有何用？？？

## 剪枝

在读入时，维护一个最小高度

```cpp
for(int i=1; i<=r; i++)
	for(int j=1; j<=c; j++) scanf("%d",&a[i][j]),Min=min(Min,a[i][j]);
```

**然后**

因为题目所求的是严格下降，所以每次至少（最好情况）下降1高度，所以可以得到

- 主函数内循环枚举出发点时，如果该点高度-最小高度+1小于等于目前最大答案，就不用dfs了；

```cpp
for(int i=1; i<=r; i++)
	for(int j=1; j<=c; j++)
		if(a[i][j]-Min+1>ans) dfs(i,j,1);
```

- dfs时每次判断如果 当前高度-最小高度+已滑距离+1<=当前最大答案，就直接return，不用再继续了

```cpp
if(a[x][y]-Min+sum+1<=ans) return;
```

基本思路不变。

## 总结 & 坑点

- 求的是最长距离！距离！！距离！！！~~算高度的没救了~~
- 两个剪枝不要忘记！！！~~用dp和记搜的当我没说~~

## AC程序

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,c,a[105][105],Min=1e9,ans=1,dx[4]= {0,0,-1,1},dy[4]= {-1,1,0,0};
void dfs(int x,int y,int sum)
{
	if(a[x][y]-Min+sum+1<=ans) return;
	if((a[x+1][y]>=a[x][y]||x>=r)&&(a[x-1][y]>=a[x][y]||x<2)&&(a[x][y+1]>=a[x][y]||y>=c)&&(a[x][y-1]>=a[x][y]||y<2))
	{
		ans=max(ans,sum);
		return;
	}
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>0&&ny>0&&nx<=r&&ny<=c&&a[nx][ny]<a[x][y]) dfs(nx,ny,sum+1);
	}
}
int main()
{
	scanf("%d%d",&r,&c);
	for(int i=1; i<=r; i++)
		for(int j=1; j<=c; j++) scanf("%d",&a[i][j]),Min=min(Min,a[i][j]);
	for(int i=1; i<=r; i++)
		for(int j=1; j<=c; j++)
			if(a[i][j]-Min+1>ans) dfs(i,j,1);
	printf("%d",ans);
	return 0;
}
```

我是[没有输入](https://www.luogu.org/space/show?uid=154344)，我们下次再见！

------------

~~管理大大求过！~~

---

## 作者：VLMOESR (赞：1)

第一次发题解

我是用深搜做的

求通过

    var
    i,j,k,m,n,s:longint;
    a:array[0..101,0..101]of longint;
    dx:array[1..4]of longint=(0,0,1,-1);
    dy:array[1..4]of longint=(1,-1,0,0);//定义
    procedure lzh(x,y:longint);
    var
    i,j:longint;
    begin
    if k>s then s:=k;
    if k=m*n then
    begin
        write(k);
        halt;
    end;
    for i:=1 to 4 do
    begin
        if (a[x+dx[i],y+dy[i]]<a[x,y])and(x+dx[i]<=m)and(x+dx[i]>=1)and(y+dy[i]<=n)and(y+dy[i]>=1)then
        begin
            k:=k+1;
            lzh(x+dx[i],y+dy[i]);
            k:=k-1;
        end;
    end;
    end;//深搜
    begin
        readln(m,n);
        k:=1;
        for i:=1 to m do
            for j:=1 to n do
                    read(a[i,j]);//读入
        for i:=m downto 1 do
        begin
            for j:=1 to n do
            begin
                lzh(i,j);
                if k>s then s:=k;
                k:=1;
            end;
        end;
        //你知道为什么要m dwonto 1 and 1 to n 吗？
        //应为之前1 to m and 1 to n 90分
        //后来发现m downto 1 可以哟！！！
        write(s);
    end.
求通过**********

---

## 作者：hwk0518 (赞：1)

把每个坐标抽象成图上的一个点，若点A可以到达点B，则点A向点B连边。

由于滑雪的海拔单减，所以这个图是一个DAG（有向无环图），问题就转化为如何在有向无环图中求最长链。

设dp[i]表示已经走到点i的最长滑雪距离，则有：

dp[i]=max(dp[x1],dp[x2],...,dp[xk])+1

其中x1,x2,...,xk是连向点i的点。

拓扑排序后计算即可。

时间复杂度：O(m)
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

int n,m,a[105][105];
int E,ot[100005],ne[100005],g[10005],deg[10005];
int X[5]={0,0,-1,1};
int Y[5]={-1,1,0,0};
int que[10000005],hd,tl,dp[10005];

int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x;
}

void add(int xa,int ya,int xb,int yb)
{
	int A=xa*m-m+ya;
	int B=xb*m-m+yb;
	ot[++E]=B;
	ne[E]=g[A];
	g[A]=E;
	++deg[B];
}

void init()
{
	int i,j,k;
	n=read(),m=read();
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
			a[i][j]=read();
	
	for(i=0;i<=n+1;++i) a[i][0]=a[i][m+1]=1e9+7;
	for(i=0;i<=m+1;++i) a[0][i]=a[n+1][i]=1e9+7;
	
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
			for(k=0;k<4;++k)
				if(a[i][j]>a[i+X[k]][j+Y[k]])
					add(i,j,i+X[k],j+Y[k]);//(i+X[k],j+Y[k]) is one of the dots (i,j) can reaches.
}

void solve()
{
	int i;
	hd=0,tl=-1;
	for(i=1;i<=n*m;++i)
		if(!deg[i]) que[++tl]=i;
	while(hd<=tl)
	{
		int t=que[hd],p;
		for(p=g[t];p;p=ne[p])
		{
			--deg[ot[p]];
			if(!deg[ot[p]]) que[++tl]=ot[p];//topo sort
			dp[ot[p]]=max(dp[ot[p]],dp[t]+1);
		}
		++hd;
	}
}

void print()
{
	int i,ans=0;
	for(i=1;i<=n*m;++i)
		ans=max(ans,dp[i]);
	printf("%d\n",ans+1);
}

int main()
{
	init();
	solve();
	print();
	return 0;
}
```
代码：



---

## 作者：封禁用户 (赞：1)

这道题的思路对蒟蒻来说，是非常的复杂，

确实，这道题用BFS也是可以的，因为数据量比较小，到一百，

我准备用LIS解决，

为啥呢，我们可以这样想：

先把a[]从小到大排序，

这样可以记录下下标（不记录得爆零）

然后用LIS查找是否为有效下标，

为有效，f[]记录下来，

否则排除，

一道不完全的动态规划，

有一点BFS的味道，四个标准判断。。。

（吹牛X：一开始，我的一个错误LIS得了90分，

这说明了：数据很水：-））

开始打代码吧：


```cpp
type jl=record
  z,x,y:longint;
end;
var
  n,m,i,j,s,max,ans,k:longint;
  a:array[1..10000] of jl;//下标记录
  f:array[0..10000] of longint;//lis专用
procedure sort(l,r: longint);//排序
      var
         i,j: longint;
         x,y:jl;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i].z<x.z do
            inc(i);
           while x.z<a[j].z do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
end;
begin
  readln(n,m);
  for i:=1 to n do
    for j:=1 to m do
    begin
      inc(s);
      read(a[s].z);
      a[s].x:=i;
      a[s].y:=j;//拉直记录
    end;
  sort(1,n*m);
  ans:=1;
  f[n*m]:=1;
  for i:=n*m-1 downto 1 do
  begin
    k:=i;
    max:=0;
    for j:=i+1 to n*m do
     if (((a[k].x+1=a[j].x) and (a[k].y=a[j].y) and (a[k].z<>a[j].z)) or
     ((a[k].x=a[j].x) and (a[k].y+1=a[j].y) and (a[k].z<>a[j].z)) or
     ((a[k].x-1=a[j].x) and (a[k].y=a[j].y) and (a[k].z<>a[j].z)) or
     ((a[k].x=a[j].x) and (a[k].y-1=a[j].y) and (a[k].z<>a[j].z))) and (f[j]>max) then//BFS+LIS，注意“==”特判
     max:=f[j];
     f[k]:=max+1;//转移方程
  end;
  max:=0;
  for i:=1 to n*m do
    if f[i]>max then
      max:=f[i];//找最大
    writeln(max);
end.

```

---

## 作者：efaul (赞：1)

看了看各位大佬的写法，好像还没有用这种dp的

简单说是拉直

把所有的点输入，记录横坐标、纵坐标、高度。

然后按高度排一下。

###**然后就可以套最长不下降（上升）子序列的模板了！**（加个判断函数而已）

是不是很神奇！是不是很神奇！是不是很神奇！（重要事情说三遍）

好吧，其实不是我想到的（捂脸）夏令营老师提的思路。

主要还是代码好写。（前提是学过dp）

废话说了这么多，上代码。




```cpp
//某个车万狗兼蒟蒻的代码
#include<iostream>
#include<algorithm>
using namespace std;
struct node{int x,y,h,v;}a[10011];
int m,n,ans;
inline void input()
{
    int c=0;
    cin>>n>>m;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        {
            cin>>a[++c].h;
            a[c].x=i;
            a[c].y=j;
            a[c].v=1;//初始化为1 
        }
}
inline int cmp(node a,node b){return a.h<b.h;}//sort的比较函数 
inline int mht(node a,node b){return abs(a.x-b.x)+abs(a.y-b.y);}//曼哈顿距离  
inline void dp()
{
    for(int i=1;i<=n*m;++i)
    {
        for(int j=1;j<i;++j)if(mht(a[i],a[j])==1&&a[i].h>a[j].h)a[i].v=max(a[i].v,a[j].v+1);//比最长上升子序列唯一多的部分：曼哈顿距离为1才可选 
        ans=max(ans,a[i].v);//打擂台 
    }
}
int main()
{
    input();
    sort(a+1,a+n*m+1,cmp);//比较懒所以直接stl了 
    dp();
    cout<<ans;
}
```
还有不懂的去看看最长不下降子序列吧，再基础不过的dp了

---

## 作者：herofox (赞：1)

蒟蒻表示并不知道如果从每个点开始往下搜会不会超时所以象征性地剪枝了一下。

想法比较简单，就是把每个点从高到低排序以后深搜，蒟蒻没找到很好的方法所以存了一遍

地图以后又开了一个结构体来排序。

下面上代码

```cpp

#include <algorithm>
#include <iostream>
using namespace std;

struct map1{
    int x1;
    int y1;
    int w;
} a[10005];//结构体纯粹是用来排序建的
int map[105][105];//存图用，因为要确定高度
int dp[105][105];//用来存每个点的最长距离（因为用别的名称有点low所以用了dp）
int maxq = 0;//用来记最长距离
int n, m;

bool cmp(map1 b, map1 c){
    return b.w > c. w;
}

void dfs(int x, int y, int step){
    if(step < dp[x][y])
        return; //这两行剪枝，如果走到这里发现没有上次走到这里的路程长那么直接剪掉
    if(map[x][y - 1] < map[x][y])
        dfs(x, y - 1, step + 1);
    if(map[x][y + 1] < map[x][y])
        dfs(x, y + 1, step + 1);
    if(map[x + 1][y] < map[x][y])
        dfs(x + 1, y, step + 1);
    if(map[x - 1][y] < map[x][y])
        dfs(x - 1, y, step + 1);

    dp[x][y] = step;//如果没有被剪掉就记录长度

    return;
}

int main(){
    int i, j, k = 0;
    cin>>n>>m;
    
    for(i = 0;i < n;i++)
        for(j = 0;j < m;j++)
            dp[i][j] = 1;
    
    for(i = 0;i < n;i++)
        for(j = 0;j < m;j++){
            cin>>map[i][j];
            a[k].x1 = i;
            a[k].y1 = j;
            a[k].w = map[i][j];
            k++;
        }
    
    sort(a, a + k, cmp);
    
    for(i = 0;i < k;i++){
        dfs(a[i].x1, a[i].y1, 1);
    }//从高到低每个店进行搜索
    
    for(i = 0;i < n;i++)
        for(j = 0;j < m;j++){
            if(dp[i][j] > maxq)
                maxq = dp[i][j];
        }//寻找最长距离
        
    cout<<maxq<<endl;
            
    
    system("pause");
    return 0;
}


```
虽然很明显不能只搜最高点，为了严谨我还是说一句为什么，其实只需要举一个反例

1     2   15

1    27   6

1     1    7

3     4    5

很明显如果只搜27会在左上角的1停下而搜不到7的位置，而最长路线应该是7-5-4-3.

这种情况如果存在说明类似于图中7的位置从最高点必定搜不到，所以必须每个点搜一遍。

最后闲话一句：最开始做的时候我是一边搜一边记录最大值，但是后来出了点小小的问题但是懒得改了所以干脆直接用了最老土的再搜一遍整个dp数组找最大，大家可以自行进行优化


---

## 作者：spacetime (赞：1)

```cpp

#include<cstdio>
#include<algorithm>
#define REP(I,start,end) for(int I=start;I<=end;I++)
using namespace std;
const int dx[4]={1,-1,0,0};//常量模拟方向
const int dy[4]={0,0,1,-1};
int n,m,a[101][101],f[101][101];
int main()
{
    scanf("%d%d",&n,&m);
    REP(i,1,n)
        REP(j,1,m)
        {
            scanf("%d",&a[i][j]);
            f[i][j]=1;
        }
    bool bo=true;
    while(bo)//迭代
    {
        bo=false;
        REP(i,1,n)
            REP(j,1,m)
                REP(k,0,3)
                {
                    int xx=i+dx[k],yy=j+dy[k];
                    if(xx&&yy&&xx<=n&&yy<=m&&a[i][j]>a[xx][yy]&&f[i][j]+1>f[xx][yy])//如果有可以更新的状态
                    {
                        bo=true;//标记为未搜完
                        f[xx][yy]=f[i][j]+1;//更新状态
                    }
                }
    }
    int ans=0;
    REP(i,1,n)
        REP(j,1,m)
            ans=max(ans,f[i][j]);
    printf("%d\n",ans);
    return 0;
}

//迭代暴搜照样水过

```

---

## 作者：野菜汤 (赞：1)

题解：

**首先，不用说，肯定是使用记忆化搜索，然而前面几位大神们讲的都不算详细，那么本人在此呢，将此题最细化讲解，并提供源代码，仅供参考。**

        
先不说算法，首先我们需要的是了解题意，其实这个所给数据的方阵跟走迷宫没什么区别，只是必须从大数往小数走（也就是从高往低），本人一开始还异想天开，将所有数据排了个序，然后看那一条可以连得更长，然后输出最高点，不料还得了二十分儿，不过也发现自己对题目的理解有误。这道题形如走迷宫加上马的遍历的集合体，我这么说够明白了吧，所以请好好看下下面的算法解析。


![](https://cdn.luogu.com.cn/upload/pic/347.png)


**算法分析：由于一个人可以从某个点滑向上下左右向相邻的四个点之一，如上所示。而且仅当高度减小，对于任意一点[i,j]，当他的高度小于与之相邻的四个点的高度时，这四个点可以滑向[i,j]，用f[i,j]表示到[i,j]为止的最大的长度,f[i,j]=max{f(i+a,j+b)}+1,其坐标增量{(a,b)=[(1,0),(-1,0),(0,1),(0,-1)],0<i+a<=r,0<j+b<=c,high[i,j]<high[i+a,j+b]}。**

为了保证满足条件的f[i+a,j+b]在f[i,j]前算出，需要对高度排一次序，然后从大到小规划（高度）。最后再比较一下所有f[i,j]{0<i<=r,0<j<=c}，找出其中最长的一条路线。我们还可以用记忆化搜索的方法，他的有点事不需要进行排序，按照行的顺序，利用递归逐点求出区域中到达此点的最长路径，每个点的最长路径只求一次。


```delphi
const dx:array[1..4] of shortint=(-1,0,1,0);
      dy:array[1..4] of shortint=(0,1,0,-1);
var r,c,i,j,p,t,ans:longint;
    m,f:array[1..100,1..100] of longint;
function search(x,y:longint):longint; //函数的作用是求到[x,y]点的最长路径。
var i,t,tmp,nx,ny:longint;
begin  //此点长度已经求出，不必进行进一步递归，保证每一个点的最大长度只求一次，这是记忆化搜索的特点  
  if f[x,y]>0 then begin
    search:=f[x,y];exit;
  end;
  t:=1;
  for i:=1 to 4 do  //从四个方向上搜索能达到[x,y]的点
  begin
    nx:=x+dx[i];ny:=y+dy[i];  //加上横、纵坐标
    if (nx>=1)and(nx<=r)and(ny>=1)and(ny<=c)  //边界设置
    and(m[x,y]<m[nx,ny]) then begin  //高度比较
      tmp:=search(nx,ny)+1;  //递归进行记忆化搜索
      if tmp>t then t:=tmp;  
    end;
  end;
  f[x,y]:=t;
  search:=t;
end;
begin
  readln(r,c);
  ans:=0;
  for i:=1 to r do
    for j:=1 to c do read(m[i,j]);  //读入每个点的高度
  for i:=1 to r do    //按照行的顺序，利用递归逐点求出区域中到达此点的最长路径
   for j:=1 to c do
   begin
     t:=search(i,j);
     f[i,j]:=t;
     if t>ans then ans:=t;  //寻找最大值
   end;
   write(ans);
end.
```

---

## 作者：墨凝而止 (赞：1)

```delphi
const dx:array[1..4] of shortint=(-1,0,1,0);
      dy:array[1..4] of shortint=(0,1,0,-1);
var r,c,i,j,p,t,ans:longint;
    m,f:array[1..100,1..100] of longint;｛m:地图；f:记忆化标记数组｝
function search(x,y:longint):longint;｛用函数求得每一点的最长距离｝
var i,t,tmp,nx,ny:longint;
begin
  if f[x,y]>0 then ｛如果有记忆，就直接赋予｝
   exit(f[x,y]);
  t:=1;{比较｝
  for i:=1 to 4 do
  begin
    nx:=x+dx[i];ny:=y+dy[i];
    if (nx>=1)and(nx<=r)and(ny>=1)and(ny<=c)｛是否越界｝
    and(m[x,y]<m[nx,ny]) then begin｛比它低｝
      tmp:=search(nx,ny)+1;｛加上自己｝
      if tmp>t then t:=tmp;｛比较｝
    end;
  end;
  f[x,y]:=t;｛记忆化｝
  search:=t;｛先付之｝
end;
begin
  readln(r,c);
  for i:=1 to r do
    for j:=1 to c do read(m[i,j]);｛必须先读入，不可边读边做（俗言“走马看花”）｝
  for i:=1 to r do
   for j:=1 to c do
   begin
     t:=search(i,j);
     f[i,j]:=t;
     if t>ans then ans:=t;
   end;
   write(ans);
end.
```
[color=green]此题便是用记忆化深度优先搜索。需要肯定，楼上已经进行了诸多的讲解，皆是此题之精要。理解并且学会运用记忆化，可以减少时间以及代码量，对程序之提高是大有裨益的。[/color]


---

## 作者：courage (赞：1)

本题可以用记忆化宽度优先搜索做。

work(i,j)表示以a[i,j]为起点的最长路径，则work(i,j)=max{work(p,q)+1}((p,q)与(i,j)相邻且a[i,j]>a[p,q]

为了减少重复运算，将work(i,j)存入数组b[i,j]，如果发现b[i,j]>0(即work(i,j)已经计算过)则直接返回b[i,j]


```delphi

const
  dx:array[1..4] of longint=(-1,1,0,0);
  dy:array[1..4] of longint=(0,0,-1,1);
type
  arr=record
        x,y,num:longint;
      end;
var
  n,m,i,j,ans,k,p,q:longint;
  a,b:array[0..101,0..101] of longint;
  s:ansistring;
function max(a,b:longint):longint;
begin
  max:=a;if a<b then max:=b;
end;
function yes(a,b:longint):boolean;
begin
  if a<1 then exit(false);
  if a>n then exit(false);
  if b<1 then exit(false);
  if b>m then exit(false);
  exit(true);
end;
function work(x,y:longint):longint;
var
  i,j:longint;
begin
  if b[x,y]>0 then exit(b[x,y]);
  work:=1;
  for i:=1 to 4 do
    if yes(x+dx[i],y+dy[i]) then
      if a[x,y]>a[x+dx[i],y+dy[i]] then work:=max(work,work(x+dx[i],y+dy[i])+1);
  b[x,y]:=work;
end;
begin
  fillchar(b,sizeof(b),0);
  ans:=0;
  readln(n,m);
  fillchar(a,sizeof(a),0);
  ans:=0;
  for i:=1 to n do
    begin
      readln(s);
      j:=0;
      p:=0;
      for k:=1 to length(s) do
        if s[k] in ['0'..'9'] 
          then p:=p*10+ord(s[k])-48
          else begin inc(j);a[i,j]:=p;p:=0;end;
      inc(j);a[i,j]:=p;
    end;
  for i:=1 to n do for j:=1 to m do b[i,j]:=work(i,j);
  for i:=1 to n do for j:=1 to m do if ans<b[i,j] then ans:=b[i,j];
  writeln(ans);
end.

```

---

## 作者：judgejudge (赞：1)

# 超级深搜加记忆化！！！
首先感谢@万万没想到，@2018J1605这两位巨佬神犇对我的大力支持，让我这个蒟蒻编的程序从40分到70分再到AC。

这道题我用的是**搜索4个方向**，先寻找**最小值所在的行和列**（找最大值的话所需的时间复杂度会高一些），然后开始**寻找最优子结构**，最后输出max。

然而以上的思路只能拿到70分，因为没有使用**记忆化搜索**。~~这也是我卡了10多次的原因。~~

其实我个人觉得记忆化搜索跟动态规划dp有点相似之处，都是有一定的存储记忆功能。然后**最重要的一点是记忆化搜索是对于程序而言有一个记忆化**，以及输出需要优化一下。

下面奉上AC代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[10001][10001];
int f[10001][10001];
int n,m;
void read(int &a){
    a=0;int d=1;char c;
    while(c=getchar(),c<'0'||c>'9')if(c=='-')d=-1;a=a*10+c-48;
    while(c=getchar(),c>='0'&&c<='9')a=a*10+c-48;
    a*=d;
}
void write(int x){
    if(x<0){
	    x=-x;
		putchar(45);
	}
    if(x) write(x/10);
    else return;
    putchar(x%10+48);
}
inline int dp(int s1,int s2){
    if(f[s1][s2])return f[s1][s2];//记忆化搜索，如果已经被赋值，直接return
    int i,j,Max=0;
    if(s1>=1&&s1<=n&&s2>=1&&s2<=m){
        if(a[s1-1][s2]>a[s1][s2]){
            Max=max(Max,dp(s1-1,s2)+1);
        }
        if(a[s1+1][s2]>a[s1][s2]){
            Max=max(Max,dp(s1+1,s2)+1);
        }
        if(a[s1][s2-1]>a[s1][s2]){
            Max=max(Max,dp(s1,s2-1)+1);
        }
        if(a[s1][s2+1]>a[s1][s2]){
            Max=max(Max,dp(s1,s2+1)+1);
        }
    }//开始深搜四个方向，如果查找到更大值，max=更大值
    f[s1][s2]=Max;//储存
    return f[s1][s2];//注意：此处记忆化搜索是相对于程序，虽然感觉自己说的绕口
}
int main(){
	int i,j,k;
	int row,col;
	int minl=1000000;
	read(n);//输入优化
	read(m);
	for(i=1;i<=n;i++)
	for(j=1;j<=m;j++){
		read(a[i][j]);
		if(a[i][j]<minl){
			minl=a[i][j];
			row=i;
			col=j;//在这里首先查找最小值所在的行和列
		}
	}
	int maxl=0;
	dp(row,col);//开始深搜
	for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            if(maxl<dp(i,j))maxl=f[i][j];//查找最大值
        }
    }
	write(maxl+1);//因为一开始定义f[i][j]本身为0，所以要加1，输出优化
	return 0;
}
```

再次感谢@万万没想到，@2018J1605这两位巨佬神犇对我的大力支持！！！！


---

## 作者：QianhanOfficial (赞：1)

```cpp
//不会记忆化搜索 我这个蒟蒻只好打贪心了~
//洛谷上可以AC的~
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#define maxn 123 
using namespace std;
int map[maxn][maxn], dp[maxn][maxn];//地图 和 每个点的路径长度 
int l, r, len = 0;//地图长宽 和 最长路径 
int dire[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//方向 
struct point//结构体：点保存的信息 
{
    int x;//坐标 
    int y; 
    int height;//高度 
}p[maxn * maxn];//定义点坐标集 开 地图点的个数 的大小  
int can(int x, int y)//判断函数，判断下一步是否能走 
{
    if(x >= 1 && x <= l && y >= 1 && y <= r) return true;
    //在地图内就返回真 
    else return false;
    //否则假 
}
bool cmp(point a, point b)//比较函数，用在sort( , ,cmp) 
{
    return a.height < b.height;//真则a比b低，否则高 
}
void work(int x, int y)//在main()里从小到大寻找起点 
{
    int nx, ny;//下一步的坐标 
    for(int i = 0; i < 4; i++)//周围比当前点要高 且能走 枚举周围四个点 
    {
		nx = x + dire[i][0];//下一步横坐标 
		ny = y + dire[i][1];//纵坐标 
		if(can(nx, ny) && map[nx][ny] > map[x][y]) //若合理 
			dp[nx][ny] = max(dp[x][y] + 1, dp[nx][ny]); 
		//dp[nx][ny]是下一个点到终点的长度 
		//+1是因为这是与x,y临近的点，距离+1 
		//更新比它高的点的路径长度 
		//因为从终点开始，所以查找下一个点 
		//每一次的更新 如果下一个节点的都会加上上次的长度或者 
    }
}
int main()
{
	cin >> l >> r;//输入地图大小 
    memset(map, 0, sizeof(map));//初始化 
    memset(dp, 0, sizeof(dp));
    int cnt = 0; //点的个数 注意：从0下标开始的 
    for(int i = 1; i <= l; i++)
    {
        for(int j = 1; j <= r; j++)
        {
            cin >> map[i][j];//输入地图 
            p[cnt].x = i;//每一个点按编号输入坐标 
            p[cnt].y = j;
            p[cnt].height = map[i][j];//输入每个点的高度 
            cnt++;
        }
    }
    sort(p, p + cnt, cmp); //按照高度从小到大排序 
    for(int i = 0; i < cnt; i++)//枚举每一个点是否可以作为起点 
    //其实就是从下往上推的贪心思想 
	//这里的p已经是排序完成的 
    {
		work(p[i].x, p[i].y);//寻找到起点，并且更新总路径 
    }

    for(int i = 1; i <= l; i++)//枚举每个点保存的路径长度 
		for(int j = 1; j <= r; j++)
			if(dp[i][j] > len) len = dp[i][j];
			//若枚举到一条更长的路径 则路径最长更新 
    cout << len + 1;
	//+1是因为 初始化的路径长度是0，但题目问的是滑坡长度，所以应当输出经过的点的数量 
	return 0;
}
//这样看起来或许更加易懂吧~
```

---

## 作者：cenbinbin (赞：1)

动归，妥妥的过了。。。

==============================================================

```cpp
const
  b:array[1..4,1..2]of longint=((1,0),(-1,0),(0,-1),(0,1));
var
  max,c,d,p,m,n,i,j:longint;
  f,a:array[0..501,0..501]of longint;
function bijiao(a,b:longint):longint;
  begin
    if a<b then bijiao:=b else bijiao:=a;
  end;
function ff(i,j:integer):integer;
var k:longint;
  begin
    if f[i,j]<>0
      then ff:=f[i,j]  //已经保存过，可不必再找
      else begin
        ff:=0;
        for k:=1 to 4 do //四个方向寻找
          if a[i,j]<a[i+b[k,1],j+b[k,2]]   //表示高度在下降，题意如此
            then ff:=bijiao(ff,ff(i+b[k,1],j+b[k,2]));
        f[i,j]:=ff+1;inc(ff);
      end;
  end;
begin
  readln(n,m);
  for i:=1 to n do
   for j:=1 to m do
    read(a[i,j]);//读入
  for i:=1 to n do //对每一个位置做
    for j:=1 to m do
      begin
        f[i,j]:=ff(i,j);    //加入数组
        max:=bijiao(max,f[i,j]);
      end;
  writeln(max);
end.
```

---

## 作者：hfyzw (赞：1)

分析：本题两解：1.记忆化搜索

2.快排+动归

此处我做第2种：

```delphi
(
var b:array[1..4,1..2]of longint=((-1,0),(0,-1),(1,0),(0,1));  //常量模拟方向
    a,f:array[0..101,0..101]of longint;
    p:array[1..10000,0..2]of longint;
    n,m,i,j,s,t:longint;
procedure kp(l,r:longint);  //快排
var i,j,k,t,x:longint;
begin
  i:=l; j:=r; x:=p[(i+j)div 2,0];
  repeat
    while p[i,0]<x do inc(i);
    while p[j,0]>x do dec(j);
    if i<=j then begin
      t:=p[i,0]; p[i,0]:=p[j,0]; p[j,0]:=t;
      t:=p[i,1]; p[i,1]:=p[j,1]; p[j,1]:=t;
      t:=p[i,2]; p[i,2]:=p[j,2]; p[j,2]:=t;
      i:=i+1; j:=j-1;
    end;
  until i>j;
  if i<r then kp(i,r);
  if j>l then kp(l,j);
end;
begin
  read(n,m); t:=1;
  fillchar(a,sizeof(a),$7f);
  for i:=1 to n do
    for j:=1 to m do
      begin
        s:=s+1;
        read(a[i,j]);
        p[s,0]:=a[i,j];
        p[s,1]:=i;
        p[s,2]:=j;
      end;
  kp(1,s);  //按高度排序
  for i:=1 to s do begin
    for j:=1 to 4 do
      if a[p[i,1],p[i,2]]>a[p[i,1]+b[j,1],p[i,2]+b[j,2]] then  //此点要比操作的点低（有擂台资格）
        if f[p[i,1]+b[j,1],p[i,2]+b[j,2]]+1>f[p[i,1],p[i,2]] then  //打擂台
          f[p[i,1],p[i,2]]:=f[p[i,1]+b[j,1],p[i,2]+b[j,2]]+1;
    if f[p[i,1],p[i,2]]=0 then f[p[i,1],p[i,2]]:=1;  //如果此点是谷底，则长度为1
    if f[p[i,1],p[i,2]]>t then t:=f[p[i,1],p[i,2]];  //打擂台
  end;
  writeln(t);
end.
)
```（pascal）


---

## 作者：S_Gloria (赞：0)

## 记忆化搜索
~~为了纪念Gloria第一次偷偷带手机回宿舍特意写一篇题解前来纪念。~~

说白了记忆化搜索就是dp，这个题也不例外。

由于不知道起点在哪，所以如果每次都归零搜索的话tle没错的，~~不要问我怎么知道的~~

所以就要用数组存下状态，避免重复性搜索。

在这里我用了两个数组。

pic存原来滑雪路径，（也就是原输入）用来判断下一步能不能继续滑

f记录答案，f_i_j代表从i行j列最多滑多远

**先上代码**

```cpp
#include<iostream>
using namespace std;
int n,m;
int pic[110][110],f[110][110];
int ans=0;
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
int dfs(int x,int y)
{
	if(f[x][y]>0)return f[x][y];
	else
	{
		for(int i=0;i<4;i++)
		{
			int xx=x+dx[i];
			int yy=y+dy[i];
			if(xx>n||yy>m||x<1||y<1)continue;
			if(pic[xx][yy]>pic[x][y])//如果能滑的话
				f[x][y]=max(f[x][y],dfs(xx,yy)+1);//这里是最最玄妙的
		}
	}
	return f[x][y];
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>pic[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans=max(ans,dfs(i,j));
	cout<<ans+1;//由于初始值是0而且到本身也算一步
	return 0;
}
```
应该是很容易理解的叭QwQ



---

## 作者：NEPTUNE104 (赞：0)

## 一.dfs暴搜


> * 就是每一个点都搜索一遍：

说明:$dfs(int,int,int)$中的$x,y$指的是当前点的横坐标和纵坐标，num则是当前点为起点的最长的路径

 1.更新$vis[x][y]$数组
 
 2.枚举其中一个方向，如果满足条件，就向下一个点搜索
 
 3.提前定义$opt$，目的是看这个点能不能再向下走
 
 4.如果$opt==0$,说明不能向下走，就更新答案
 
 5.重设$vis[x][y]$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=150;
const int inf=123456789;
const int dx[5]={1,0,0,-1};
const int dy[5]={0,1,-1,0};
int maps[maxn][maxn];
bool vis[maxn][maxn];
int n,m,sx,sy,start=-inf,ans=-inf;
void find(int x,int y,int num){
	int opt=0;
	vis[x][y]=true;
	for(int i=0;i<=3;i++){
		int tx=x+dx[i];
		int ty=y+dy[i];
		if(tx>=1 and tx<=n and ty>=1 and ty<=m and maps[tx][ty]>maps[x][y] and !vis[tx][ty]){
			opt=1;
			find(tx,ty,num+1);
		}
	}
	vis[x][y]=false;
	if(opt==0) ans=max(ans,num);
	return ;
}
int main(void){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&maps[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			memset(vis,false,sizeof(vis));
			find(i,j,0);
		}
	}
	printf("%d\n",ans+1);
	return 0;
}
```
但是，第二个点会TLE

---------------------

## 二、记忆化搜索

和前者最大的不同就是：

> * 搜索的时候及时返回$step[x][y]$,这也是记忆话搜索的核心

其他的问题都大同小异。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
const int maxn=150;
const int inf=123456789;
int ans=-inf,n,m;
int maps[maxn][maxn],step[maxn][maxn];
bool vis[maxn][maxn];
int dfs(int x,int y){
	int tmp=1;
	if(vis[x][y]) return step[x][y];
	else{
		for(int i=0;i<=3;i++){
			int tx=x+dx[i];
			int ty=y+dy[i];
			if(tx>=1 and tx<=n and ty>=1 and ty<=m and maps[x][y]<maps[tx][ty]){
				tmp=max(dfs(tx,ty)+1,tmp);
			}
		}
		step[x][y]=tmp;
		vis[x][y]=true;
		return step[x][y];
	}
}
int main(void){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&maps[i][j]); 
			step[i][j]=1;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ans=max(ans,dfs(i,j));
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```
## 三、动态规划 DP
看到有dalao已经写得很详细，在这里只想说一点：

> * 搜索的过程一定是 从高度比较大的到高度比较小的，

如果不清楚的可以自己模拟一下过程。

## 四、总结
一道很经典的题目，很基础但是特别重要

---

## 作者：59percent (赞：0)

![](https://cdn.luogu.com.cn/upload/pic/74277.png)
```cpp
#include <iostream>
using namespace std;
const int dx[4] = {-1, 0, 1, 0};
const int dy[4] = {0, 1, 0, -1};
const int N = 100;
int n, m, a[N][N];
int f[N][N];

void dfs(int x, int y) {
	f[x][y] = 1;

	for(int i = 0; i <= 3; i++) {
		int x2 = x + dx[i];
		int y2 = y + dy[i];

		if(x2 < 1 || x2 > n) continue; //越界

		if(y2 < 1 || y2 > m) continue;

		if(a[x2][y2] >= a[x][y]) continue;//比你高

		if(!f[x2][y2]) dfs(x2, y2);//没有走过

		f[x][y] = max(f[x][y], f[x2][y2] + 1); //状态转移，找最长的
	}
}

int main() {
	cin >> n >> m;

	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			cin >> a[i][j];

	int mx = 0;

	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) { //循环，防止走到死地
			if(!f[i][j]) dfs(i, j);//没走过

			mx = max(mx, f[i][j]);
		}

	cout << mx << endl;
	return 0;
}

```
![](https://cdn.luogu.com.cn/upload/pic/74280.png)
```cpp
#include <iostream>
#include <queue>
using namespace std;

const int dx[4]={-1,0,1,0};
const int dy[4]={0,1,0,-1};
const int N=100;
int n, m, a[N][N];
int f[N][N];
struct Node {
  int x, y, h;
  bool operator < (const Node &p1) const {
    return h > p1.h;
  }
};

int main() {
  priority_queue<Node> q;
  cin>>n>>m;
  for(int i=1; i<=n; i++)
    for(int j=1; j<=m; j++) {
      cin>>a[i][j];
      q.push((Node){i, j, a[i][j]});
    }
  
  while(!q.empty()) {
      Node p1 = q.top();
      q.pop();
      for(int k=0; k<4; k++) {
        int x2 = p1.x + dx[k];
        int y2 = p1.y + dy[k];
        if(x2<1 || x2>n || y2<1 || y2>m) continue;
        if(a[x2][y2] >= p1.h) continue;
        f[p1.x][p1.y] = max(f[p1.x][p1.y], f[x2][y2] + 1);
      }
  }
  
  int ans = 0;
  for(int i=1; i<=n; i++)
    for(int j=1; j<=m; j++)
      ans = max(ans, f[i][j]);
  cout<<ans<<endl;
  return 0;
}

```


---

## 作者：WayneStewart (赞：0)

来个BFS，加入f[i][j]表示从(i, j)能走的最长路

详细注释见代码

···cpp






    

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
using namespace std;
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};
const int N = 103;
struct Point {
    int x, y, step;
};
int h[N][N], f[N][N]; // f(i, j):从(i, j)开始能走的最长路 
int n, m, max_;
void bfs(const int &sx, const int &sy);
inline bool in_map(const int &x, const int &y);
int main()
{
    cin >> n >> m;
    // 周围加一圈INF，这样走到边界一定不满足h[i, j]>h[边界]
    // 于是乎自动停止，无需特判 
    for (int i = 0; i <= n + 1; ++i)
        h[0][i] = h[n + 1][i] = 105e7;
    for (int i = 0; i <= m + 1; ++i)
        h[i][0] = h[i][m + 1] = 105e7;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            cin >> h[i][j];
//    for (int i = 0; i <= n + 1; ++i) {
//        for (int j = 0; j <= m + 1; ++j)
//            cout << h[i][j] << " ";
//        cout << "\n";    
//    }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) {
            bfs(i, j);
            max_ = max(max_, f[i][j]);    
        }
    cout << max_ << "\n";
    return 0;
}
// BFS找从(sx, sy)开始的最长路 
void bfs(const int &sx, const int &sy)
{
    queue<Point> q;
    q.push({sx, sy, 1});
    int nx, ny, x, y, step;
    while (!q.empty()) {
        x = q.front().x;
        y = q.front().y;
        step = q.front().step;
        // 如果当前最长路长比已知更长则更新 
        f[sx][sy] = max(f[sx][sy], step);
        q.pop(); // !!! 
        for (int i = 0; i < 4; ++i) {
            nx = x + dx[i];
            ny = y + dy[i];
            if (in_map(nx, ny) && h[x][y] > h[nx][ny]) {
                // 记忆化，如果从(x, y)到(nx, ny)的距离step，
                // 因而不用再求(nx, ny)的最长路，f[nx, ny]以记录下了 
                if (f[nx][ny])
                    f[sx][sy] = max(f[sx][sy], step + f[nx][ny]);
                else
                    q.push({nx, ny, step + 1});
            }
        }
    }
}
inline bool in_map(const int &x, const int &y)
{ return x > 0 && x <= n && y > 0 && y <= m; }
```
```cpp

---

## 作者：渡海 (赞：0)

emm..这道题我用了结构体+快排+dfs+记忆化


翻了翻提交记录，感觉还不错了，至少第一页没人比我的代码强233


没用vector内存一样漂亮..


PS：反正我这种蒟蒻是学不会bfs了，所有题都是dfs过


下面是Code：

    

    
        
        
    


```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct minx{//结构体定义
    int xx,yy;
    int number;
}f[105*105];
int cmp(const minx &a,const minx &b){//结构体快排
    return a.number<b.number;
}
int a[105][105];//第一个输入，第二个赋值
int b[105][105];
int n,m;
int dfs(int x,int y){//dfs大法好
    b[x][y]++;
    if(a[x-1][y]<a[x][y]&&x-1>0){
        if(b[x-1][y]!=0){
            b[x][y]=fmax(b[x][y],b[x-1][y]+1);
        }else{
            dfs(x-1,y);
        }
    }if(a[x+1][y]<a[x][y]&&x+1<=n){
        if(b[x+1][y]!=0){
            b[x][y]=fmax(b[x][y],b[x+1][y]+1);
        }else{
            dfs(x+1,y);
        }
    }if(a[x][y+1]<a[x][y]&&y+1<=m){
        if(b[x][y+1]!=0){
            b[x][y]=fmax(b[x][y],b[x][y+1]+1);
        }else{
            dfs(x,y+1);
        }
    }if(a[x][y-1]<a[x][y]&&y-1>0){
        if(b[x][y-1]!=0){
            b[x][y]=fmax(b[x][y],b[x][y-1]+1);
        }else{
            dfs(x,y-1);
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    int t=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            f[t].xx=i;
            f[t].yy=j;
            f[t].number=a[i][j];
            t++;
        }
    }
    //读入之后，快排入x,y，然后从最小开始dfs吧
    sort(f+1,f+n*m+1,cmp);
    for(int i=1;i<=n*m;i++){
            dfs(f[i].xx,f[i].yy);
    }
    int maxn=-1;//找最大
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(b[i][j]>maxn){
                maxn=b[i][j];
            }
        }
    }
    printf("%d",maxn);
    return 0;
}
```
emm...代码很长但是很简单理解，如果还有不明白的地方欢迎私信
by：jjw\_coco


---

## 作者：fuking (赞：0)

###**深搜+记忆化搜索**

这道题用深搜显然是可行的（蒟蒻不会广搜），但是这道题数字较大，用直接深搜会TLE，所以要记忆化搜索；

注意：

1.一个点往下滑的最大距离是周围4个点往下滑的最大距离的最大值加1；

2.如果一个点怎么也不能滑也算滑了1个距离

3.**理解！不要抄代码！不要抄代码！不要抄代码！（重要的事情说三遍）**

```cpp
//附上代码
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cstdlib>
#include<cmath>
#include<ctime>
using namespace std;
#define MAXN 102 
int p[MAXN][MAXN],ans[MAXN][MAXN];//定义ans数组来记录每个点可以滑的最远距离 
int jb[4][2]={{1,0},{0,1},{-1,0},{0,-1}};//表示向4个方向走（请无视变量名） 
int m,n;
int dfs(int x,int y){//开始深搜 
    if(ans[x][y])return ans[x][y]; //如果搜过了就返回它 ，避免重复搜索，防TLE（重点） 
    int ANS=1;//滑了这个点本来就算一步 
    for(int i=0;i<4;i++){//往4个方向 
        int u=x+jb[i][0],v=y+jb[i][1];
        if(u>0&&u<=m&&v>0&&v<=n&&p[u][v]<p[x][y]){//只能往低处滑，并且不能越界 
            ANS+=dfs(u,v);//这个点可以滑的距离等于挨着这个且比这个低的这个点可以滑的距离加1 
            ans[x][y]=max(ANS,ans[x][y]);//跟上次算出的答案比较选择远（大）的 
            ANS-=dfs(u,v);//回溯 ，这时候ANS（大写）还是1 
        }
    }
    if(!ans[x][y])ans[x][y]=ANS;//如果 4个点都比它高这个点还是能滑1个的 
    return ans[x][y];//返回距离 
}
int main(){
    cin>>m>>n;
    int Ans=0;//这个是最终答案 
    for(int i=1;i<=m;i++)for(int j=1;j<=n;j++){cin>>p[i][j];}//输入不解释 
    for(int i=1;i<=m;i++)for(int j=1;j<=n;j++){
        int l=dfs(i,j);Ans=max(Ans,l);//把每个点搜1遍，取最大的 
    }
    cout<<Ans;//输出 
    return 0;
}
```
/\*撒花\*/

---

## 作者：封禁用户 (赞：0)

```cpp
#include<cstdio>
using namespace std;
int dx[5]= {0,-1,0,1,0},  //x的坐标增量
           dy[5]= {0,0,1,0,-1};  //y的坐标增量
long r,c,i,j,p,t,ans;
long m[101][101],f[101][101];
int search(int,int);
int main() {
    scanf("%d%d", &r, &c);
    ans=0;
    for(i=1; i<=r; i++)
        for(j=1; j<=c; j++)
            scanf("%d", &m[i][j]);  //读入每个点的高度
    for(i=1; i<=r; i++)  //按照行的顺序，利用递归逐点求出区域中到达此点的最长路径
        for(j=1; j<=c; j++) {  
            t=search(i,j);
            f[i][j]=t; 
            if(t>ans) ans=t;  //寻找最大长度值
        }
    printf("%d", ans);
}
int search(int x,int y) {  //函数的作用是求到[x,y]点的最长路径
    int i,t,tmp,nx,ny;
    if(f[x][y]>0)  //此点长度已经求出，不必进行进一步递归，保证每一个点的最大长度只求一次，这是记忆化搜索的特点
        return (f[x][y]);
    t=1;
    for(i=1; i<=4; i++) {  //从四个方向上搜索能达到[x,y]的点
        nx=x+dx[i];  //加上横、纵坐标
        ny=y+dy[i];
        if((nx>=1)&&(nx<=r)&&(ny>=1)&&(ny<=c)&&(m[x][y]<m[nx][ny]))  //边界限制
                {  //高度比较
            tmp=search(nx,ny)+1;  //递归进行记忆化搜索
            if(tmp>t) t=tmp;
        }
    }
    f[x][y]=t;
    return (t);
}
```

---

## 作者：zhyh (赞：0)

###这是蒟蒻的动？规做法

##把所有点拿出来从低往高排个序

##再从低往高地推

##方程：f[i][j]=max(f[i][j][k]+1)//f[i][j]为其最大路径长；k就是四个方向，使四周高度较低的f[i][j]往上爬

##程序如下（代码风格奇？异）：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
struct point{    //用于排序
        int h,x,y;
};
struct py{    //用来推结果
        int hg,sum;
};

const int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};    //方向
    point p[23333]; py map[233][233]; int r,c,k=0,ans=0;

bool comp(point a,point b){
    return(a.h<b.h);
}

int max(int a,int b){
    if(a>b)return a;
    return b;
}
    
int main(){
        memset(map,23333333,sizeof(map));    //四周造墙当边界233
        scanf("%d%d",&r,&c);
        for(int i=1;i<=r;i++)
            for(int j=1;j<=c;j++){
                    scanf("%d",&map[i][j].hg);
                    map[i][j].sum=0;    //复制信息
                    p[k].x=i;
                    p[k].y=j;
                    p[k].h=map[i][j].hg;
                    k++;
            }
        
        sort(p,p+k,comp);
    
        for(int i=0;i<k;i++){
              for(int j=0;j<4;j++){
                    if(map[p[i].x+dir[j][0]][p[i].y+dir[j][1]].hg<map[p[i].x][p[i].y].hg&&    //比较高度
            map[p[i].x+dir[j][0]][p[i].y+dir[j][1]].sum>=map[p[i].x][p[i].y].sum)    //比较路径
            map[p[i].x][p[i].y].sum=map[p[i].x+dir[j][0]][p[i].y+dir[j][1]].sum+1;
        }    if(map[p[i].x][p[i].y].sum==0)map[p[i].x][p[i].y].sum=1;
          ans=max(ans,map[p[i].x][p[i].y].sum);    //照理说推完后最高点的最长路径就？是整个地图的最长路径了
    }
    
    printf("%d",ans);
        
    return 0;
}    
```
#偷懒成功


---

## 作者：qaqRose (赞：0)


深度优先+记忆化搜索

开始居然理解错题意，后来才发现最长滑坡跟高度没有关系，而是跟路过的点的数量有关

思路： 这题是典型的深度优先搜索，因为跟高度没有关系，所以每个点都要遍历，再分别上

下左右深度遍历，在遍历的时候保存最大值就可以了



```cpp
#include<iostream>
using namespace std;
int c,r;
int a[110][110];
int book[110][110];- - 
int flag[110][110];                                //保存路径 
int max_num=0;
int ne[4][2]={{1,0},{0,1},{-1,0},{0,-1}};    //方向  
**int dfs(int x,int y)
    if(flag[x][y]) return flag[x][y]; 
    int num=0,temp=0;
    for(int k=0;k<4;k++){
        int tx,ty;
        tx= x + ne[k][0];
        ty= y + ne[k][1]; 
        if(tx<0||tx>r-1 ||ty<0 || ty>c-1) continue;   //边界 
        
        if(book[tx][ty]==0 && a[x][y]>a[tx][ty]){
            book[tx][ty]=1;
            num =dfs(tx,ty)+1;    
            if(num > temp){
                temp = num;            //保存最大值 
                flag[x][y]=num;        //保存路径 
            } 
            book[tx][ty]=0;
        }
    }
    return temp;
}
int main(){
    freopen("2.txt","r",stdin);
    cin>>r>>c;
    for(int i=0;i<r;i++)
    for(int j=0;j<c;j++)
    {
        cin>>a[i][j];
    }
    for(int i=0;i<r;i++)
    for(int j=0;j<c;j++)
    {
        int te;
        te=dfs(i,j);
        if(te+1 > max_num) max_num=te+1;  //路径加1 
    }
    cout<<max_num;
    return 0;
} 
```

---

## 作者：ljc20020730 (赞：0)

应该说，这是一道很经典的dfs的题目

一开始，我是用贪心的，结果发现只能拿50分：从最高点开始一遍dfs

```cpp
const dx:array[1..4]of integer=(0,1,0,-1);
      dy:array[1..4]of integer=(-1,0,1,0);
var ans,n,m,i,j,max,min,maxi,maxj,mini,minj:longint;
    a:array[1..100,1..100]of longint;
    u:array[1..100,1..100]of boolean;
procedure dfs(k,x,y:longint);
var i,xx,yy:longint;
begin
 if k>ans then ans:=k;
 for i:=1 to 4 do begin
  xx:=x+dx[i]; yy:=y+dy[i];
  if (xx>0)and(xx<=n)and(yy>0)and(yy<=m)and(u[xx,yy])and(a[xx,yy]<a[x,y]) then begin
  // if k>ans then ans:=k;
   u[xx,yy]:=false;
   dfs(k+1,xx,yy);
   u[xx,yy]:=true;
  end;
 end;
end;
begin
 readln(n,m);
 max:=0; min:=maxlongint;
 for i:=1 to n do
  for j:=1 to m do begin
   read(a[i,j]);
   if a[i,j]>max then begin max:=a[i,j]; maxi:=i; maxj:=j; end;
 end;
 ans:=-maxlongint;
 fillchar(u,sizeof(u),true);
 u[maxi,maxj]:=false;
 dfs(1,maxi,maxj);
 writeln(ans);
end.
```
然后就发现了问题，来看一下第一个数据：
输入：

10 5
56 14 51 58 88

26 94 24 39 41

24 16 8 51 51

76 72 77 43 10

38 50 59 84 81

5 23 37 71 77

96 10 93 53 82

94 15 96 69 9

74 0 62 38 96

37 54 55 82 38

输出：7

而我们的程序输出 4，显然这个贪心不对。

所以不能从最高点开始一遍dfs，需要n\*m遍的dfs，这样就避免了上述情况

```cpp
const dx:array[1..4]of integer=(0,1,0,-1);
      dy:array[1..4]of integer=(-1,0,1,0);
var ans,n,m,i,j,max,min,maxi,maxj,mini,minj:longint;
    a:array[1..100,1..100]of longint;
    u:array[1..100,1..100]of boolean;
procedure dfs(k,x,y:longint);
var i,xx,yy:longint;
begin
 if k>ans then ans:=k;
 for i:=1 to 4 do begin
  xx:=x+dx[i]; yy:=y+dy[i];
  if (xx>0)and(xx<=n)and(yy>0)and(yy<=m)and(u[xx,yy])and(a[xx,yy]<a[x,y]) then begin
   u[xx,yy]:=false;
   dfs(k+1,xx,yy);
   u[xx,yy]:=true;
  end;
 end;
end;
begin
 readln(n,m);
 max:=0; min:=maxlongint;
 for i:=1 to n do
  for j:=1 to m do begin
   read(a[i,j]);
   if a[i,j]>max then begin max:=a[i,j]; maxi:=i; maxj:=j; end;
 end;
 ans:=-maxlongint;
 max:=-maxlongint;
 fillchar(u,sizeof(u),true);
// u[maxi,maxj]:=false;
 for i:=1 to n do
  for j:=1 to n do begin
 ans:=-maxlongint;
 dfs(1,i,j);
 if ans>max then max:=ans;
 end;
 writeln(max);
end.
```
当然，这种方法是AC不了的，为什么？时间复杂度太高！！是O(n\*m\*dfs)
本来dfs就是指数级了，这样的话会严重超时！！！

所以采用记忆化搜索，基本上AC的程序都是记忆化，我就不展开说了

```cpp
const dx:array[1..4]of integer=(0,1,0,-1);
      dy:array[1..4]of integer=(-1,0,1,0);
var ans,n,m,i,j,max,min,maxi,maxj,mini,minj:longint;
    f,a:array[1..100,1..100]of longint;
function dfs(x,y:longint):longint;
var i,xx,yy,t,tmp:longint;
begin
 if f[x,y]>0 then exit(f[x,y]);
 t:=1;
 for i:=1 to 4 do begin
  xx:=x+dx[i]; yy:=y+dy[i];
  if (xx>0)and(xx<=n)and(yy>0)and(yy<=m)and(a[xx,yy]>a[x,y]) then begin
  tmp:=dfs(xx,yy)+1;
  if tmp>t then t:=tmp;
  end;
 end;
 f[x,y]:=t;
 exit(t);
end;
begin
 readln(n,m);
 max:=0; min:=maxlongint;
 for i:=1 to n do
  for j:=1 to m do
   read(a[i,j]);
 for i:=1 to n do
  for j:=1 to m do begin
   f[i,j]:=dfs(i,j);
   if f[i,j]>max then max:=f[i,j];
end;
 writeln(max);
end.
```

---

## 作者：Idvz (赞：0)

首先，记录下每个点的高度，然后对High排序后，一次循环DP即可找出答案

状态转移方程  f[i][j]=max{f[i+a][j+b]}+1;

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct node{
    int x,y,high;
}ski[50000];

int r,c,tot,p,ans;
int m[101][101];
int f[101][101];
int x[6]={0,1,-1,0,0};
int y[6]={0,0,0,1,-1};

int my_comp(const node &a,const node &b){
    return a.high<b.high;    //按照高度进行排序
}

int main()
{
    scanf("%d%d",&r,&c);
    
    for(int i=1;i<=r;i++)
      for(int j=1;j<=c;j++)
        {
            scanf("%d",&m[i][j]);
            ski[++tot].x=i;
            ski[tot].y=j;           //记录下各个点的x,y,high;
            ski[tot].high=m[i][j];
        }
        
        sort(ski+1,ski+tot+1,my_comp);     //快排
        
        for(int i=1;i<=tot;i++)
          {
                p=0;
                if(m[ski[i].x][ski[i].y]>m[ski[i].x-1][ski[i].y]) p=max(p,f[ski[i].x-1][ski[i].y]);
                if(m[ski[i].x][ski[i].y]>m[ski[i].x][ski[i].y-1]) p=max(p,f[ski[i].x][ski[i].y-1]);      //判断是否符合条件;
                if(m[ski[i].x][ski[i].y]>m[ski[i].x][ski[i].y+1]) p=max(p,f[ski[i].x][ski[i].y+1]);
                if(m[ski[i].x][ski[i].y]>m[ski[i].x+1][ski[i].y]) p=max(p,f[ski[i].x+1][ski[i].y]);
                 f[ski[i].x][ski[i].y]=max(p+1,f[ski[i].x][ski[i].y]);
                 ans=max(f[ski[i].x][ski[i].y],ans); 
          }
          cout<<ans<<endl;
          return 0;
}
     (a,b)={(0,1),(1,0),(-1,0),(0,-1)};

```

---

## 作者：DreamDraw (赞：0)

/\*蒟蒻表示用递归写了一个类似记忆化的东西...以为会超时然而并没有

\*/
```cpp
#include<iostream>
#include<cstring>
#define maxn 1005
using namespace std;
int m,n,G[maxn][maxn],dp[maxn][maxn];
bool vis[maxn][maxn];
const int mx[4]={1,-1,0,0};
const int my[4]={0,0,1,-1};
void init(void){
    cin>>m>>n;
    for(int i=0;i<maxn;i++)
        for(int j=0;j<maxn;j++)
            G[i][j]=maxn;//处理边界为极大值
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++){
            int x;cin>>x;
            G[i][j]=x;
        }
    memset(dp,0,sizeof(dp));
    memset(vis,0,sizeof(vis));
}
int solve(int x,int y){
    int t=0;vis[x][y]=1;int mark=1;
    for(int i=0;i<4;i++){//四个方向搜索
        int tx=x+mx[i],ty=y+my[i];
        if(G[tx][ty]<G[x][y]){//如果满足滑雪的条件
            mark=0;//mark为0表示已经修改dp[x][y]的值
            if(vis[tx][ty])t=max(dp[tx][ty]+1,t);//如果被访问过直接调用结果
            else{
                solve(tx,ty);
                t=max(dp[tx][ty]+1,t);//未被访问就递归求解
            }
        }
    }
    if(!mark)dp[x][y]=t;
    else dp[x][y]=1;//若未修改dp[x][y]的值，则表示从当前点无法移动，dp[x][y]=1;
    return dp[x][y];
}
int main(){
    init();
    int ans=0;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(!vis[i][j]){
                solve(i,j);
                if(ans<dp[i][j])
                    ans=dp[i][j];
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：gaoshanxun (赞：0)

{记忆化搜所

```cpp
}
program O_O;
uses math;
const
    maxn=109;
    u:array[1..4] of -1..1=(0,0,1,-1);
    v:array[1..4] of -1..1=(-1,1,0,0);
type
    ll=longint;
    bo=boolean;
    arr=array[0..maxn,0..maxn] of ll;
    arr1=array[0..maxn,0..maxn] of bo;
var
    n,m,ans:ll;
    a,f:arr;
    b:arr1;
procedure init;
var
    i,j:ll;
begin
    readln(n,m);
    for i:=1 to n do
    begin
        for j:=1 to m do
        begin
            read(a[i,j]);
            b[i,j]:=true;
        end;    
        readln;
    end;
end;    
function dfs(x,y:ll):ll;
var
    i,xx,yy,tmp,t:ll;
begin
    if f[x,y]>0 then exit(f[x,y]);
    for i:=1 to 4 do
    begin
        xx:=x+u[i];yy:=y+v[i];
        if (b[xx,yy])and(a[x,y]<a[xx,yy]) then
        begin
            f[x,y]:=max(f[x,y],dfs(xx,yy)+1);
        end;        
    end;    
    exit(f[x,y]);
end;
procedure process;
var
    i,j:ll;
begin
    for i:=1 to n do
    begin
        for j:=1 to n do
        begin
            f[i,j]:=dfs(i,j)+1;
            ans:=max(f[i,j],ans);    
        end;        
    end;
end;    
procedure print;
begin
    writeln(ans);
end;    
begin
    init;
    process;
    print;
end.
```

---


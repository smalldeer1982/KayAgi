# [HAOI2012] 容易题

## 题目描述

有一个长度为 $m$ 的正整数数列 $A$，满足 $\forall i \in A, i \in [1, n]$。

现在给定一些限制（$A_x$ 不能为 $y$）。设数列 $A$ 的积为 $\prod A$，求所有可能数列的积相加起来的和。

换言之，令 $S$ 为所有可能的数列情况 $\{A, A', \ldots\}$，求

$$ \sum_{T \in S} \prod T $$

答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

### 样例解释 #1

$A_1$ 不能取 $1$，$A_2$ 不能取 $2, 3$，$A_4$ 不能取 $3$，所以可能的数列有以下 $12$ 种：

| 数列 | 积 |
| :-: | :-: |
| $\{2,   1,   1,   1\}$           | $2$ |
| $\{2,   1,   1,   2\}$           | $4$ |
| $\{2,   1,   2,   1\}$           | $4$ |
| $\{2,   1,   2,   2\}$           | $8$ |
| $\{2,   1,   3,   1\}$           | $6$ |
| $\{2,   1,   3,   2\}$           | $12$ |
| $\{3,   1,   1,   1\}$           | $3$ |
| $\{3,   1,   1,   2\}$           | $6$ |
| $\{3,   1,   2,   1\}$           | $6$ |
| $\{3,   1,   2,   2\}$           | $12$ |
| $\{3,   1,   3,   1\}$           | $9$ |
| $\{3,   1,   3,   2\}$           | $18$ |


### 数据范围

对于 $30\%$ 的数据，$n \leq 4$，$m \leq 10$，$k \leq 10$。

对于另外 $20\%$ 的数据，$k = 0$。

对于 $70\%$ 的数据，$n, m, k \leq 1000$。

对于 $100\%$ 的数据，$1\leq n, m \leq 10^9$，$0\leq k \leq 10^5$，$1 \leq x \leq m$，$1 \leq y \leq n$。

## 样例 #1

### 输入

```
3 4 5
1 1
1 1
2 2
2 3
4 3
```

### 输出

```
90```

# 题解

## 作者：hzoi_liuchang (赞：15)

## 分析

我们先去考虑没有限制的情况，那么最终的答案就是

$( 1+2+3+……+n)^{m}=(\frac{n\times(n-1)}{2})^{m}$

为什么是这样呢？其实我们可以把数列的每一个元素看成一个集合

每一次我们可以从每个集合中任意取出$n$个元素

这$n$个元素的值分别为$1 - n$

根据乘法原理最终的结果就是

$(1+2+3+……+n)\times(1+2+3+……+n)\times……$

一共要乘$m$次

如果还不理解的话，你可以随便举一个例子，按照上面的式子把它展开

但是，题目中有些元素是取不到的

我们可以记录一下每一个元素取不到的值的和$tot$

我们只要把该元素贡献的价值改为$\frac{n\times(n-1)}{2}-tot$就可以了

因为题目中的限制条件最多只有$10^{5}$个

所以我们记录下有限制条件的元素的个数$cnt$，对其单独处理

对于其余的元素，我们用快速幂的思想求出$(\frac{n\times(n-1)}{2})^{m-cnt}$

最后再把所有的结果累乘就可以了

要注意两个问题：
1、因为结果很大，能取模的地方就取模
2、要注意判重，样例已经给出重复的情况了

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
const long long mod=1e9+7;
typedef long long ll;
map<pair<ll,ll>,ll> ma1;
map<ll,ll> ma2;
ll jl[maxn];
ll cf(ll now,ll zs){
    ll jl=now%mod,ans=1;
    while(zs){
        if(zs&1) ans*=(jl%mod),ans%=mod;
        jl*=(jl%mod),jl%=mod;
        zs>>=1;
    }
    return ans;
}
int main(){
    ll n,m,k,js=0;
    scanf("%lld%lld%lld",&n,&m,&k);
    for(ll i=1;i<=k;i++){
        ll aa,bb;
        scanf("%lld%lld",&aa,&bb);
        if(!ma2[aa]) jl[++js]=aa;
        if(ma1[make_pair(aa,bb)]) continue;
        ma1[make_pair(aa,bb)]=1;
        ma2[aa]+=bb;
    }
    ll ans=1,cj=(n+1)*n/2;
    for(ll i=1;i<=js;i++){
        ans*=(cj-ma2[jl[i]])%mod;
	    ans%=mod;
    }
    printf("%lld\n",ans%mod*cf(cj,m-js)%mod%mod);
    return 0;
}
```



---

## 作者：Edwina (赞：15)


　    首先假设如果k=0。

容易发现没有限制时，a[i]的每个位置都可以取1~n的任何一个数字，而因为a数组只有m个位置，所以显然此时![](http://images2017.cnblogs.com/blog/1160478/201709/1160478-20170907112639694-1184730043.png)


那如果k！=0，就代表a[i]的当前位置有限制数字时，它只能取1~n中限制数字以外的。


所以计算积时，a[i]贡献给ans的只有这么多![](http://images2017.cnblogs.com/blog/1160478/201709/1160478-20170907113200710-499793318.png)。


于是我们先算出不被限制的位置的乘积，也就是![](http://images2017.cnblogs.com/blog/1160478/201709/1160478-20170907113327085-1174568234.png) 其中cnt表示总共有多少位置被限制了（cnt不一定等于k）


对于被限制的位置，我们判一下重，一个位置可能被多个数字限制。


最后被限制的和不被限制的相乘即为所求。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
const int mod=1000000007;
const int maxn=100009;
ll sum[maxn];
struct data
{
    ll x,y;
}a[maxn];
bool cmp(data a1,data a2)
{
    if(a1.x==a2.x)
        return a1.y<a2.y;
    else
        return a1.x<a2.x;
}
int poww(int x,int y,int mod)
{
    int ret=1;
    while(y)
    {
        if(y&1)
            ret=1ll*ret*x%mod;
        x=1ll*x*x%mod;
        y>>=1;
    }
    return ret;
}
int main()
{
    ll ans=0;
    int n,m,k;
    cin>>n>>m>>k;
    ll sgm=(1ll*n*(n+1)>>1)%mod;
    for(int i=1;i<=k;i++)
    {
        cin>>a[i].x>>a[i].y;
    }
    sort(a+1,a+k+1,cmp);
    int cnt=0;
    for(int i=1;i<=k;i++)
    {
        if(a[i].x!=a[i-1].x)
            sum[++cnt]=sgm;//判重
        else
        {
            if(a[i].y==a[i-1].y)//防止多次减同一个限制条件
            continue;
        }
        sum[cnt]=(sum[cnt]-a[i].y+mod)%mod;//减去被限制的数
    }
    ans+=poww(sgm,m-cnt,mod);
    for(int i=1;i<=cnt;i++)
    {
        ans=(ans*sum[i]+mod)%mod;//乘上有限制的情况
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：皎月半洒花 (赞：6)

$23333$这是一道$zz$的分配律的题……思路其余的大佬都讲的差不多了，那么我们直接进入优化阶段。

我的代码不开$O2$在第十页，开了$O2$在第二页，算是一个比较优的复杂度了$233$……

那么窝萌考虑这个题，其实就是对$K$操作，然后，因为我们只需要统计$K$个约束的信息即可。我们可以离线下来，排个序，去个重（即将重复的置为$Inf$），然后再排一遍序，从后往前删除重复的，最后扫一遍剩下的合法约束即可。

在这里我一开始建了个桶存储信息，但是很显然空间不允许。所以便换了种写法，也是个小技巧吧。

上代码

```cpp
#include <cstdio>
#include <bitset>
#include <iostream>
#include <algorithm>
#define ll long long
#define MAXN 1000010
#define mod 1000000007

using namespace std ; 
struct node{
	ll L, R ;
}In[MAXN] ; ll S[MAXN], J, Last ;
ll L, R, Ans, N, M, K, i, T, base ;

inline ll qr(){
    ll k = 0 ; char c = getchar() ;
    while (!isdigit(c)) c = getchar() ;
    while (isdigit(c)) k = (k << 1) + (k << 3) + c - 48, c = getchar() ;
    return k ;
}
inline ll expow(ll A, ll B){
    ll res = 1 ;
    while (B){
        if (B & 1) {
			res = res * A ; 
			if (res > mod) res %= mod ;
		} 
        A = A * A ; if (A > mod) A %= mod ;
        B >>= 1 ;
    }
    return res % mod ;
}
inline bool compare(node A, node B){
	if(A.L == B.L) return A.R < B.R ;
	return A.L < B.L ;
}
int main(){
	N = qr(), M = qr(), K = qr() ;
	T = M, base = (1 + N) * N >> 1 ; base %= mod ;
	for (i = 1; i <= K ; ++ i) In[i].L = qr(), In[i].R = qr() ;
	sort (In + 1, In + K + 1, compare) ;
	for (i = 2; i <= K ; ++ i) 
		if (In[i].R == In[i - 1].R && In[i].L == In[i - 1].L ) In[i - 1].L = 19260817000LL ;
	sort (In + 1, In + K + 1, compare) ;
	for (i = K; In[i].L == 19260817000LL ; -- i) K -- ;
	for (i = 1; i <= K ; ++ i) {
		L = In[i].L, R = In[i].R ; 
		if (L != Last) T --, Last = L, ++ J ;  S[J] -= R ;
	}//此处是用来存储约束的
	Ans = (Ans + expow(base, T)) % mod ;
	for (i = 1; i <= J ; ++ i){
		Ans = Ans * (base + S[i]) % mod ;
		if (Ans > mod) Ans %= mod ;
	}
	cout << ( Ans + mod ) % mod << endl ;
}
//这个版本是88ms……因为窝限制模运算结果反而更慢了……
```

---

## 作者：DarthVictor (赞：5)

# 题目
首先，原题题目就叫这个，不是我讽刺这个题简单……

[原题地址](https://www.luogu.com.cn/problem/P2220)
# 解说
咱们先假设我一个限制都没有，那么每个数都可以取$1~n$之间的任何一个整数，在自己的脑海里提一遍公因数就会发现这时答案为$(1+2+ \dots +n)^m$，再用上求和公式变为$(\frac{n(n+1)}{2})^m$。

那么现在我们加上限制条件，每加上一个限制就少一个选择，那么我们就把这个限制数从这个乘数里剔除即可，即原来是$1+2+ \dots +n$，现在变为$1+2+ \dots +n-limit1-limit2 \dots$，也就是$(\frac{n(n+1)}{2})^m-limit1-limit2 \dots$。而没有受到限制的数照乘不误，即若有$js$个有限制的数那么这些没限制的数乘起来就是$(\frac{n(n+1)}{2})^{m-js}$。最后结果把有限制的没限制的乘一起即可。

几点提醒：

1.数太大了，能取模的地方都取模。

2.用快速幂优化。

3.样例就能看出来可能有重复限制，记得去重。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1000000007;
const int maxn=1e5+3;
map<pair<ll,ll>,bool> inf;
map<ll,ll> sum;
ll n,m,k,js,num[maxn];
ll power(ll a,ll x){
	a%=mod;
	ll ans=1;
	for(;x;x>>=1,a=a*a%mod){
		if(x&1) ans=ans*a%mod;
	}
	return ans%mod;
}
ll read(){
   ll s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
} 
int main(){
	n=read(); m=read(); k=read();
	while(k--){
		ll x,y;
		x=read(); y=read();
		if(!sum[x]) num[++js]=x;
		if(inf[make_pair(x,y)]) continue;
		inf[make_pair(x,y)]=1;
		sum[x]+=y;
	}
	ll ans=1,Max=(n+1)*n/2;
	for(ll i=1;i<=js;i++){
		ans*=(Max-sum[num[i]])%mod;
		ans%=mod;
	}
	printf("%lld",ans%mod*power(Max,m-js)%mod%mod);
	return 0;
}
```

幸甚至哉，歌以咏志。

---

## 作者：WaterSun (赞：3)

# 思路

首先，我们考虑 $k = 0$ 的情况：

$$
1 \times 1 + 1 \times 2 + \dots + 1 \times n + \dots + n \times 1 + n \times 2 + \dots + n \times n 
$$

然后用乘法分配律化简一下，得：

$$
(\frac{n(n + 1)}{2})^m
$$

然后我们可以直接推广到 $k \neq 0$ 的情况，得（其中 $a_i$ 表示第 $i$ 位受到限制之和）：

$$
\prod_{i = 1}^{m}{(\frac{n(n + 1)}{2} - a_i)}
$$

然后我们可以 $\Theta(n \log n)$ 求出 $a_i$。

因为 $n \leq 10^9$，所以我们不能直接暴力算，考虑将 $a_i$ 为 $0$ 和 $a_i$ 不为 $0$ 的情况分开处理。

因为 $a_i \neq 0$ 的数量最多为 $k$，然后剩下的部分可以快速幂算，时间复杂度 $\Theta(k \log n + \log n)$，明显能过。

# code

```cpp
#include <bits/stdc++.h>
#define int long long
#define re register

using namespace std;

typedef pair<int,int> pii;
const int mod = 1000000007,inv = 500000004;
int n,m,k,num,sum = 1,t = 1;
map<int,int> mp;
map<pii,bool> vis;

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

inline int Add(int a,int b){
	return (a + b) % mod;
}

inline int Sub(int a,int b){
	return ((a - b) % mod + mod) % mod;
}

inline int Mul(int a,int b){
	return a * b % mod;
}

inline int qmi(int a,int b){
	int res = 1;
	while (b){
		if (b & 1) res = Mul(res,a);
		a = Mul(a,a);
		b >>= 1;
	}
	return res;
}

signed main(){
	n = read();
	m = read();
	k = read();
	sum = Mul(Mul(Add(1,n),n),inv);
	for (re int i = 1;i <= k;i++){
		int x,y;
		x = read();
		y = read();
		if (!mp.count(x)) num++;
		if (!vis.count({x,y})){
			mp[x] = Add(mp[x],y);
			vis[{x,y}] = true;
		}
	}
	for (auto it = mp.begin();it != mp.end();it++) t = Mul(t,Sub(sum,it -> second));
	printf("%lld",Mul(qmi(sum,m - num),t));
	return 0;
}
```

---

## 作者：云浅知处 (赞：3)

$k=0$ 的时候就是一个套路题，答案就是：

$$
(1+2+\cdots+n)^m
$$

稍加思考可以发现这是对的。

每个元素可以取 $1\sim n$，上面式子的展开中每一项对应一个序列，所以这个东西是对的。

现在有限制了其实也基本一样......我们只需要把其中的一些项减掉不能取的值就行了。

（或者你也可以按照生成函数的思路去理解这东西）

具体还有一些细节，看代码

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<map>

#define int long long
const int MN=100005;
const int mod=1000000007;

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

int ksm(int y,int z,int p){
    y%=p;int ans=1;
    for(int i=z;i;i>>=1,y=y*y%p)if(i&1)ans=ans*y%p;
    return ans%p;
}

int n,m,k;
int mul[MN],x[MN],y[MN];
int ans=1;
map<int,int>mp;
map<int,bool>vis[MN];//vis[] 用来判重，不然后面可能会把一个值减去两次。

signed main(void){

    n=read(),m=read(),k=read();
    int cnt=0,p=((n)*(n+1)/2)%mod;
    for(int i=1;i<=k;i++)mul[i]=p;
    for(int i=1;i<=k;i++)x[i]=read(),y[i]=read();
    for(int i=1;i<=k;i++){
        if(!mp.count(x[i])){
            mp[x[i]]=++cnt;
            vis[cnt][y[i]]=1,mul[cnt]=(mul[cnt]-y[i]+mod)%mod;
        }
        else{
            int id=mp[x[i]];
            if(vis[id].count(y[i]))continue;//有重复的
            vis[id][y[i]]=1,mul[id]=(mul[id]-y[i]+mod)%mod;
        }
    }
    for(int i=1;i<=cnt;i++)ans=ans*mul[i]%mod;
    ans=ans*ksm(p,m-cnt,mod)%mod;//剩下的可以随便取
    cout<<ans<<endl;

    return 0;
}
```

然后就做完了=w=

---

## 作者：荣耀南冥 (赞：3)

# 题目
## [容易题](https://www.luogu.com.cn/problem/P2220)
昨天考试考了这道 ~~容易题~~ ，不知道怎么想的，打了个DP，居然拿了70，先定义 dis[ i ] [ j ] 表示最后是第 i 行，最后一个数是 j 的结果，vis[ i ] [ j ]表示第i行j是否可选，然后想到枚举到第k，然后后面的数其实是可以用乘法分配律结合，所以转移方程就是 
$$ dis[ i ] [ j ] = \sum\limits_{k=1}^{n} {dis[ i - 1 ][k] \times j }  ( vis[ i ] [ j ] = 0 )$$
然后前缀和优化从($ n^3 $)优化到($ n^2 $)，最后答案就是sum[ m ] ，这样就可以拿到 70 分 ~~的好成绩~~

$Code$
```c++
for(int i=1,x,y;i<=k;++i){
	x=read();y=read();
	vis[x][y]=1;
}
for(int i=1;i<=n;++i){
	if(vis[1][i])continue;
	dis[1][i]=i;sum[1]=(sum[1]+i)%mod;
}
for(int i=2;i<=m;++i){
	for(int j=1;j<=n;++j){
		if(vis[i][j])continue;
		dis[i][j]=(dis[i][j]+j*sum[i-1]%mod)%mod;
	}
	for(int j=1;j<=n;++j)
		sum[i]=(sum[i]+dis[i][j])%mod;
}
```
现在再想一下，上面的式子其实就是
$$ sum[ i ] = \sum\limits_{k=1}^{n} dis[i][k] $$
然后又发现
$$ dis[i][k] = \sum\limits_{j=1}^{n} k\times sum[i-1] $$
最后可以得出递推式
$$ sum[i] = sum[i-1] \times \sum\limits_{j=1}^{n}j(vis[i-1][j]=0) $$
于是这就是一个真的简单题了，最后结果就是
$$ ans = \prod\limits_{i=1}^{n} \sum\limits_{j=1}^{n}j $$
这就是没有限制的式子，如果有限制的话只需要在乘的时候减去即可
比如$n == 2,m == 3$时，$ k==2 $， $(1,1),(2,2)$不能选,最后结果
$$ ans = (1) \times (2) \times (1+2)$$
然后看到 n 到了 $1e9$， k 只有 $1e5$所以从 k 入手，先用结构体存起来k个限制，排一下序，去重后乘进结果，剩下的跑一个快速幂即可，同时要注意去重，很多大佬用是用map去重，一开始看的迷迷糊糊的（~~可能是我太菜了~~），于是我用来一个STL的神奇函数unique，这个函数可以做到去重。
，然后利用map映射记录每个被修改的x对应的值，乘进去即可。最后提一点，因为 n 太大，用累加直接 T 飞，一定要用等差数列求和算（死了3次才的出的宝贵经验，~~应该不会有人和我一样傻吧~~）

$Code$
```c++
#include <bits/stdc++.h>
using namespace std;
#define gc getchar()
const long long mod=1e9+7;
long long n,m,k,cnt;
long long ans=1,s;
long long mp[1000000+10];
map<int,long long> ma;
struct gdx{
	long long x,y;
	friend bool operator < (const gdx &A,const gdx &B){
		return A.x < B.x;
	}
	friend bool operator == (const gdx &A,const gdx &B){
		return (A.x==B.x&&A.y==B.y);
	}
}a[1000000+10];

inline int read(){
	int r=0,l=1;char ch=gc;
	while(!isdigit(ch)){if(ch=='-')l=-1;ch=gc;}
	while(isdigit(ch)){r=(r<<3)+(r<<1)+ch-'0';ch=gc;}
	return r*l;
}

inline long long ksm(long long x,long long y){
	long long ans=1;
	while(y){
		if(y&1)ans=ans*x%mod;
		y>>=1;x=x*x%mod;
	}
	return ans;
}

int main(){
	freopen("easy.in","r",stdin);
	freopen("easy.out","w",stdout);
	n=read();m=read();k=read();
	s=n*(n+1)/2%mod;
	for(int i=1,x,y;i<=k;++i)
		a[i].x=read(),a[i].y=read();
	sort(a+1,a+k+1);
	int p=unique(a+1,a+k+1)-a;p--;
	for(int i=1,l=0;i<=p;++i){
		if(l!=a[i].x){
			mp[++cnt]=a[i].x;
			ma[a[i].x]=s;l=a[i].x;
		}
		ma[a[i].x]=(ma[a[i].x]-a[i].y+mod)%mod;
	}
	for(int i=1;i<=cnt;++i)ans=ans*ma[mp[i]]%mod;
	ans=ans*ksm(s,m-cnt)%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：djy213 (赞：3)

我们先假设k=0;


ai为a位的可能;bi为b位的可能;ci为c位的可能...

则：
a1\*b1\*c1+a1\*b1\*c2+a1\*b2\*c1+a1\*b2\*c2+a2\*b1\*c1+a2\*b1\*c2+a2\*b2\*c1+a2\*b2\*c2;

整理：(a1+a2)\*(b1+b2)\*(c1+c2);

然后考虑k；

即(a1+a2-z1)\*(b1+b2-z2)\*(c1+c2-z3);

这样你就有个O(n)了

但还不够；

再考虑K的大小；

于是把被k影响的先算了，再快速幂

O(k)的算法；

代码如下：




```cpp
#include<cstdio>
#include<algorithm>
#define mod 1000000007
using namespace std;
struct ss
{
    int x,y;
}a[100001];
long long b[100001];
bool cmp(ss a,ss b)
{
    if(a.x==b.x)
        return a.y<b.y;
    return a.x<b.x;
}
long long sqr(long long ,int );
int main()
{
    int n,m,k;
    long long sz1=0;
    long long ans=1;
    int i,j,l;
    scanf("%d%d%d",&n,&m,&k);
    sz1=(long long)n*(n+1)/2%mod;
    for(i=1;i<=k;i++)
        scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+k+1,cmp);
    j=0;
    for(i=1;i<=k;i++)
    {
        if(a[i].x!=a[i-1].x)
            b[++j]=a[i].y;
        else
            if(a[i].y!=a[i-1].y)
                b[j]=(b[j]+a[i].y)%mod;
    }
    for(i=1;i<=j;i++)
        ans=(ans*(sz1-b[i]+mod))%mod;
    m=m-j;
    ans=(ans*sqr(sz1,m))%mod;
    printf("%lld",ans);
    return 0;
}
long long sqr(long long sz,int m)
{
    long long ans=1;
    while(m)
    {
        if(m&1)
            ans=(ans*sz)%mod;
        sz=(sz*sz)%mod;
        m=m>>1;
    }
    return ans;
}
```

---

## 作者：luowa (赞：2)

唔，~~容易题~~。

首先用dp的思想看这题的题意，若我们已知前$i-1$个数的积的和，怎么来求前$i$个数的积的和（暂时不记不能取的操作）。

我们发现若前$i-1$个数的积分别是$a_1,a_2……a_{2^i}$($2^i$是排列组合的结果，不过不重要)，那么前$i$个数的乘积的和应当是拿$A[i]$的每个取值与$a_1,a_2……a_{2^i}$分别相乘的和，易得（乘法结合律），$A[i]$的所有取值的和与$a_1,a_2……a_{2^i}$的和相乘就能得到所需求的值。

假设$A[i]$的所有取值的和分别是$b_1,b_2……b_n$，可以得到转移方程$dp[i]=dp[i-1]*b_i$,递推，得到$dp[n]=b_1*b_2*……b_{n-1}*b_n$。

结论，累乘各项的取值和，即$\prod_{i=1}^{n} {b_i}$.

已知边界$dp[1]=b_1$，那么我们只要求出$b_1,b_2……b_n$即可。为了不跑O(n)（n是1e9，会TLE），我们拿k来处理，对于每个读入的不能取，减去对应的b的值。为了存的下，我们只存减了的那些数。为了去重，也为了挨个减，我们跑一遍sort。为了把没减的那些乘起来，我们跑一遍快速幂（不然会TLE）。最后别忘了取模，这题就完成了。（**这一段详见代码注释**）


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k;
long long u,v,a,b;
const long long M=1e9+7;
long long now[100010],nn;//保存减好了的数，以及数的数量
long long an;
int i;
struct ans
{
	int l,r;
}w[100010];//保存读入
long long ksm(long long x,long long y)//快速幂
{
	long long i=1;
	while(y)
	{
		if(y%2==1)	i*=x;
		i%=M;
		x*=x;
		x%=M;
		y/=2;
	}
	return i;
}
int cmp(ans x,ans y)//排序
{
	if(x.l!=y.l)	return x.l<y.l;
	return x.r<y.r;
}
int main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	u=(n+1)*n/2;//不减情况下每个b的值
	u%=M;
	for(i=1;i<=k;i++)//读入并保存
	{
		scanf("%lld%lld",&a,&b);
		w[++an].l=a;
		w[an].r=b;
	}
	sort(w+1,w+an+1,cmp);//排序
	for(i=1;i<=an;i++)//排序后的转化
	{
		now[++nn]=n*(n+1)/2;
		now[nn]-=w[i].r;//将每个减后的数保存
		while(w[i+1].l==w[i].l)//去重与判断下一个是不是与这个有同样的a（在题中是x）
		{
			i++;
			if(w[i].r!=w[i-1].r)	now[nn]-=w[i].r;
		}
		now[nn]%=M;
	}
	u=ksm(u,m-nn);//余下的数跑快速幂
	for(i=1;i<=nn;i++)//合并
	{
		u*=now[i];
		u%=M;
	}
	printf("%lld\n",u);
	return 0;
}
```

我写的可清楚了……


---

## 作者：toolong114514 (赞：1)

# P2220 [HAOI2012] 容易题 题解
## 题目大意
[传送门](https://www.luogu.com.cn/problem/P2220)。
## 解题思路
### 第一档部分分

对于 $30\%$ 的数据，$n \leq 4$，$m \leq 10$，$k \leq 10$。

直接 $O(m!n+m!k)$ 暴搜统计，拿下 30 分。
```cpp
void dfs(int pos,long long tmp){
	//cout<<pos<<endl;
	if(pos==m){
		ans+=tmp;
		ans%=mod;
		return;
	}
	for(int i=1;i<=n;i++){
		bool flag=false;
		for(int j=1;j<=k;j++){
			if(lim[j].p==pos+1&&lim[j].v==i){
				flag=true;
				break;
			}
		}
		if(!flag) dfs(pos+1,(tmp*i)%mod);		
	}
}
```
### 特殊情况（第二档部分分）

对于另外 $20\%$ 的数据，$k = 0$。

考虑推导没有限制的特殊情况（假定 $n$ 不变）。

记 $f_i$（$i$ 为正整数）为当 $A$ 没有限制时，所有可能数列的积。

显然，当 $i=1$ 时，只有 $1,2,\dots,n$ 这几种可能。

那么，$f_1=1+2+\dots+n=\frac{(n+1)n}{2}$

对于每一个长度为 $i$ 的 $A$，都可以从 长度为 $i-1$ 的 $A$ 后拼接 $1,2,\dots,n$ 来得到，那么 $f_{i}$ 的所有情况都可以用 $f_{i-1}$ 拼接 $1,2,\dots,n$ 去计算。

得到递推式：$f_i=\frac{(n+1)n}{2}f_{i-1}$。

通项，得 $f_i=(\frac{(n+1)n}{2})^i$。

此时，我们得到了 $k=0$ 时的特殊做法：直接写快速幂算上面那个通项就行了。

时间复杂度为 $O(\log{m})$。

~~相信大家都会快速幂，就不放代码了吧。~~
### 第三档部分分
对于 $70\%$ 的数据，$n, m, k \leq 1000$。

在 $k=0$ 时，我们可以得到一个通项快速计算。但是存在限制时，只能一个一个递推，查找对应的限制，减去不能拼接的数，从 $f_{i-1}$ 算出 $f_i$（$f$ 的意义同上）。

时间复杂度为 $O(mk)$。

核心代码：
```cpp
f[0]=1;
for(int i=1;i<=m;i++){
	f[i]=n*(n+1)/2*f[i-1];
	memset(vst,false,sizeof(vst));
	for(int j=1;j<=k;j++){
		if(lim[j].p==i&&!vst[lim[j].v]){
			f[i]-=lim[j].v*f[i-1];
			vst[lim[j].v]=true;
		}
	}
}
cout<<f[m];
```
### 正解
我们发现，第三档部分分做法的复杂度瓶颈在 $m$。

递推的时候，有很多没限制的地方可以直接计算，跳过去。

所以，只对存在限制的地方特别计算，剩下的直接用快速幂求即可。

时间复杂度为 $O(k\log{m})$。
## 参考代码
```
#include<algorithm>
#include<iostream>
using namespace std;
#define int long long
const int N=1e6+10;
const int mod=1e9+7;
struct ccf{
	int p,v;
	friend bool operator==(ccf a,ccf b){
		return a.p==b.p&&a.v==b.v;
	}
}lim[N];
bool cmp(ccf pre,ccf nxt){
	if(pre.p!=nxt.p) return pre.p<nxt.p;
	else return pre.v<nxt.v;
}
int qpow(int x,int mi){
	int ans=1;
	while(mi){
		if(mi&1){
			ans*=x;
			ans%=mod;
		}
		x*=x;
		x%=mod;
		mi>>=1;
	}
	return ans%mod;
}
int fft=1;
int n,m,k;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
	if(k==0){
		cout<<qpow(((n+1)*n/2)%mod,m);
		return 0;
	}
	for(int i=1;i<=k;i++){
		cin>>lim[i].p>>lim[i].v;
	}
	lim[k+1]={m,0};
	sort(lim+1,lim+k+2,cmp);
	int k1=unique(lim+1,lim+k+2)-lim;
	int tmp=0,last=0; 
	for(int i=1;i<=k1;i++){
		tmp+=lim[i].v;
		if(lim[i].p!=lim[i+1].p){
			fft*=qpow((n*(n+1)/2)%mod,lim[i].p-last-1);
			fft%=mod;
			fft*=((n*(n+1)/2)%mod-tmp%mod+mod)%mod;
			fft%=mod;
			last=lim[i].p;
			tmp=0;
		}	
	}
	cout<<fft%mod;
	return 0;
}
```
~~赛时写得比较丑陋。~~
## 注意事项
写代码时要特别注意**取模的细节**，不然你的正解会被卡在 70pts~90pts 左右！

Written by [toolong114514](https://www.luogu.com.cn/user/477821) on 2024/3/16.

~~没见过题目名字这么嚣张的。~~

---

## 作者：unicorn1220 (赞：1)

此题似乎没什么算法。
### Part 1 基本思路
题目作了一些对每个位置可选数的限制，但我们可以**先假设其不存在**,由于每个位置都可选择 $1\sim n$，很容易得出，最终答案为 $[n\times(n+1)\div2]^m$，证明不困难，这里就不赘述了。

那要是存在呢？也很简单，只要把对应的因数减去不能选的数再乘上即可。

那么实现就是，用一个 $sum$ 事先记下 $n\times(n+1)\div2$ 的值，每次用 $sum$ 减去不能选的数，再乘进 $ans$。

### Part 2 小优化
不难发现，其实有相当多的位置都没有限制，那一个一个乘进去也太浪费时间了。
于是我们就可以用到快速幂来算没有限制的部分，再单独算有限制的部分，这样虽然有点麻烦，但快许多。

**PS：需要对限制的数作判重，从样例就可以看出来。**

奉上代码，请勿搬运。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1000000007;
int n,m,k,sum[10000005],ans,cnt,art;
struct mjx
{
    int a,b;
}ci[100005];
bool cmp(mjx ai,mjx bi){return ai.a!=bi.a?ai.a<=bi.a:ai.b<=bi.b;}
int qpow(int a,int b,int q)
{
    int fan=1;
    while(b)
    {
        if(b&1) fan=fan*a%q;
        a=a*a%q;
        b>>=1;
    }
    return fan;
}
signed main()
{
    scanf("%lld%lld%lld",&n,&m,&k);
    art=(((1+n)*n)>>1)%mod;
    for(int i=1;i<=k;i++)
        scanf("%lld%lld",&ci[i].a,&ci[i].b);
    sort(ci+1,ci+k+1,cmp);
    for(int i=1;i<=k;i++)
    {
        if(ci[i].a!=ci[i-1].a) sum[++cnt]=art;
        else if(ci[i].b==ci[i-1].b) continue;
        sum[cnt]=(sum[cnt]-ci[i].b+mod)%mod;
    }
    ans=qpow(art,m-cnt,mod);
    for(int i=1;i<=cnt;i++)
        ans=(ans*sum[i]+mod)%mod;
    printf("%lld",ans);
}
```

---

## 作者：_H17_ (赞：1)

## 思路分析

不难发现 $k=0$ 时，每种情况都有可能。任何位置都有 $n$ 种可能：$1 ∼ n$。对于该序列的积不难发现就是 $(1+2+\cdots+n)^m$。

但是对于限制条件只需要对对应的 $1 ∼ n$ 踢出限制的数。

## 部分分

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,x,ans=1;
struct opt{
    int x,y;
    void r(){
        scanf("%lld%lld",&x,&y);
        return;
    }
    bool operator<(opt b){
        return(x!=b.x?(x<b.x):(y<b.y));
    }
    bool operator==(opt b){
        return x==b.x&&y==b.y;
    }
}a[100001];//限制
signed main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    for(int i=1;i<=k;i++)
        a[i].r();
    x=(1+n)*n/2;
    sort(a+1,a+k+1);
    k=unique(a+1,a+k+1)-a;
    //排序&去重
    for(int i=1,ii=1,cnt=0;i<=m;i++,cnt=0){
        while(ii<k&&a[ii].x==i)
            cnt+=a[ii++].y;
        ans*=(x-cnt)%(int)(1e9+7),ans%=(int)(1e9+7);
        //减，注意取模
    }
    printf("%lld",ans);
    return 0;
}
```
超时了唉，咋办呢？

## 修改（重中之重~~至少我是想了半天~~）

虽然不难发现复杂度是 $O(m)$，$m\le 10^9$ 显然超时，但是 $O(\log m)$ 和 $O(k)$ 这两个复杂度都是可以接受的所以我们可以往这里想想。（暂停，自己想想如何修改）

我们语句 `ans*=(x-cnt)%(int)(1e9+7),ans%=(int)(1e9+7);` 中 `x-cnt` 的 `cnt` 有大量是 $0$。

所以可以去重之后将每个不为 $0$ 的 `cnt`先乘，最后把剩下进行快速幂即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
//懒
using namespace std;
const int mod=1e9+7;
int qp(int a,int b){
    int ret=1;
    a%=mod;
    while(b){
        if(b&1)
            ret=ret*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ret;
}//快速幂
int n,m,kk,k,x[100001]/*用来存每个有用的减值对应的下标*/,ans=1;
map<pair<int,int>,bool>u;
//去重
map<int,int>sum;
//仅对有用的减
signed main(){
    scanf("%lld%lld%lld",&n,&m,&kk);
    const int xxx=(1+n)*n/2;
    for(int i=1,a,b;i<=kk;i++){
        scanf("%lld%lld",&a,&b);
        if(u.count({a,b}))
            continue;
        //重复
        if(!sum.count(a))
            x[++k]=a;//标记
        u[{a,b}]=clock()%2/*中间只用了count判断*/,sum[a]+=b;
    }
    for(int i=1;i<=k;i++)
        ans*=(xxx-sum[x[i]])%mod,ans%=mod;
    //对于这些需要减的处理
    printf("%lld",ans*qp(xxx,m-k)%mod);
    return 0;
}
```

## 总结

很多题目还是很绕的，要想办法分部分处理，虽然第一个部分分只用了一个通式，第二个要分开处理，但是分开却 AC 了，所以只要分开处理常数不会巨大（比如你二分变十六分）就要分开处理。

---

## 作者：xryjr233 (赞：1)

考虑一个一个加入限制。

那么先算没有限的情况。

根据乘法分配律,发现答案其实是$[\frac{n(n+1)}{2}]^m$。

也就是$m$个$(1+2+3+...+n)$的积。将第$i$个$(1+2+3+...+n)$记为$sum_i$(当然这只是$sum_i$的初值)。

设目前答案为$ans$。

当加入一个限制条件$x\ y$,就是从$sum_x$中删去$y$,那么答案就减少了$\frac{ans}{sum_x}\times y$(当然要求$y$还存在于$sum_x$中)。

还发现其实我们只关心两次操作的$x$是否不同,而不关心具体值。

所以我们开一个map来将$x$映射到$[1,k]$之间的整数上,记为$mp$。当然,没有出现的$x$可以不管。

另外记一个Pair类型的map或者set,表示操作$x\ y$是否被执行过。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Pair{
    int a,b;
    bool operator >(Pair y)const{
        if(a!=y.a)return a>y.a;
        return b>y.b;
    }
    bool operator <(Pair y)const{
        if(a!=y.a)return a<y.a;
        return b<y.b;
    }
};
const long long mod=1e9+7;
long long n,m,k,sum[100010],ans,v;
int id,t,cnt;
map<int,int>mp;
map<Pair,bool>mp2;
long long POW(long long x,long long y){
    long long tot=1;
    while(y){
        if(y&1)tot=tot*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return tot;
}
long long INV(long long x){
    return POW(x%mod,mod-2);
}
long long ch(long long x,long long y){
    return x%mod*INV(y)%mod;
}
int main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    ans=POW(n*(n+1)/2%mod,m);
    for(int i=1;i<=k;i++)sum[i]=n*(n+1)/2;
    for(int i=1;i<=k;i++){
        scanf("%d%lld",&id,&v);
        t=mp[id];
        if(!t)t=mp[id]=++cnt;
        if(mp2[(Pair){t,(int)v}])continue;
        mp2[(Pair){t,(int)v}]=1;
        ans=(ans-ch(ans,sum[t])*v%mod+mod)%mod;
        sum[t]=(sum[t]-v+mod)%mod;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：xyz32768 (赞：1)

假设到了第i位，可选的数集为Ai，那么这时设res[i]为到第i位的结果，有res[i]=∑res[i-1]\*Ai[j]=res[i-1]\*∑Ai[j]。

由此可得，res[m]=∏(∑(A[i,j], 1<=j<=数集Ai的大小), 1<=i<=m)。

先把所有限制条件以x为第一关键字，y为第二关键字从小到大排序。

然后对于每个x相等的限制条件，把x对应的数集中删除元素y。

但是在n,m<=10^9的条件下无法表示出所有的数集，但其实我们只需要用到与限制条件相关的数集（因为其余的数集都包含1,2,3,...n），也只需要记录与限制条件相关的数集内的元素和。此时记所有限制条件中不同x的个数为tot（与限制条件相关的数集个数）。

x对应的数集中删除元素y，实现为将x对应的数集内的元素和减去y（需要注意重复）。

这样就可以用快速幂求出(1+2+3+...+n)^(m-tot)，然后再乘上所有限制条件相关的数集内的元素和，即为答案。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5, CYX = 1e9 + 7;
int n, m, K, tt, b[N], nn;
struct cyx {int x, y;} a[N];
bool comp(cyx a, cyx b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % CYX;
        a = 1ll * a * a % CYX;
        b >>= 1;
    }
    return res;
}
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
int main() {
    int i; n = read(); m = read(); K = read();
    nn = 1ll * n * (n + 1) / 2 % CYX;
    for (i = 1; i <= K; i++) a[i].x = read(), a[i].y = read();
    sort(a + 1, a + K + 1, comp); a[0].x = a[0].y = 0;
    for (i = 1; i <= K; i++) {
        if (a[i].x != a[i - 1].x) b[++tt] = nn;
        if (a[i].x != a[i - 1].x || a[i].y != a[i - 1].y)
            b[tt] = (b[tt] - a[i].y + CYX) % CYX;
    }
    int res = qpow(nn, m - tt);
    for (i = 1; i <= tt; i++) res = 1ll * res * b[i] % CYX;
    cout << res << endl;
    return 0;
}
```

---

## 作者：J_Kobe (赞：0)

### 思路
首先我们可以知道如果没有限制条件的话，答案就是从 $1$ 加到 $n$ 的和的 $m$ 次方。那么再加上条件的话，我们只需要将有限制的序列 $A$ 单独处理，再算出没有限制的乘积，这里我们就要用到快速幂了。

我们还需要注意去重，不然会多算一些，我们可以用 $map$ 来标记每一个序列中的每一个数字是否出现过。

总而言之，这道题还是比较简单的。但是我最开始只有 $90$ 分，因为我没有考虑到最后的答案可能会出现负数，所以最后输出的时候要加上模数再模模数。

最后，上代码。

### 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 1e9 + 7;
int n, m, k, sum, ans, x[100005], y[100005];
map<int, int> t;
map<int, map<int, bool> > flag;
int quick_pow(int a, int b)
{
	int sum = a % mod, ans = 1, bb = b;
	while (bb)
	{
		if (bb % 2)
		{
			ans %= mod;
			sum %= mod;
			ans *= sum;
			ans %= mod;
		}
		sum %= mod;
		sum *= sum;
		sum %= mod;
		bb /= 2;
	}
	ans %= mod;
	return ans;
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie();cout.tie();
	cin >> n >> m >> k;
	int cnt = 0;
	for (int i = 1; i <= k; i++)
	{
		cin >> x[i] >> y[i];
		if (t[x[i]] == 0)
		{
			cnt++;
		}
		if (flag[x[i]][y[i]] == 0)
		{
			flag[x[i]][y[i]] = 1;
			t[x[i]] += y[i];
			t[x[i]] %= mod;
		}
	}
	if (n % 2 == 0)
	{
		sum = n / 2LL * (n + 1);
	}
	else
	{
		sum = (n + 1) / 2LL * n;
	}
	sum %= mod;
	ans = quick_pow(sum, m - cnt);
	ans %= mod;
//	cout << ans << endl;
	for (int i = 1; i <= k; i++)
	{
		if (t[x[i]])
		{
			ans %= mod;
			int now = sum - t[x[i]];
			ans = ans * now;
			ans %= mod;
			t[x[i]] = 0;
		}
	}
	cout << (ans + mod) % mod;
	return 0;
}

/*
(n(n+1)/2)^m
(1+2+...+n)*(1+2+...+n)*...*(1+2+...+n)   m

*/
```

---

## 作者：shaozhehan (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P2220)

题目大意：

现有一个长度为 $m$ 的数列 $a$。给定 $n$ 个形如 $a_x\not=y$ 的限制。设满足条件的所有 $a$ 构成的集合为 $S$。求 $\sum\limits_{t\in S}\prod\limits_{i=1}^{m}t_i\bmod(10^9+7)$。

思路：

设没有限制的位的个数为 $c$。

我们容易发现，对于 $\forall i\in[1,m]\cap\mathbb{N}$，$a_i$ 的所有可能值都是与其他位置无关的。所以，$\sum\limits_{t\in S}\prod\limits_{i=1}^{m}t_i$ 可进一步转换为每一位所有可能值之和的乘积。

但是如何求出每一位所有可能值之和的乘积呢？如果第 $i$ 位没有限制的话，那么这一位的所有可能值之和肯定是 $\dfrac{n(n+1)}{2}$；否则，这一位的所有可能值之和必定是 $\dfrac{n(n+1)}{2}$ 和关于这一位的所有限制的值的和的差。这样，我们把这些限制按 $x$ 离散化一下，然后把所有有限制的位的所有可能值之和求出来，最后再将它乘上 $\left(\dfrac{n(n+1)}{2}\right)^c$即可。具体见代码。

具体实现时注意取模和临时开 ```long long```。

上代码：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int sum[100001];// 每一位的所有可能值之和
static constexpr int mod = 1e9 + 7;

struct node{// 限制
    int x, y;
    constexpr bool operator<(const node &b) const {// 按第一关键字排序
        return x == b.x ? y < b.y : x < b.x;
    }
}nd[100001];

inline int quick_pow(int a, int b){// 快速幂
    int res = 1;
    while (b){
        if (b & 1){
            res = 1ll * res * a % mod;
        }
        a = 1ll * a * a % mod;
        b >>= 1;
    }
    return res;
}

int main(){
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);// cin、cout 优化
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1; i <= k; i++){
        cin >> nd[i].x >> nd[i].y;
    }
    int cnt_x = 0;// 限制中不同的 x 的个数
    sort(nd + 1, nd + k + 1);// 将限制按第一关键字排序，方便之后的离散化
    for (int i = 1; i <= k; i++){
        if (nd[i].x != nd[i - 1].x){// 遇到了一个新的 x，将 cnt_x 加一，并将 sum 赋初始值
            cnt_x++;
            sum[cnt_x] = (1ll * n * (n + 1) >> 1) % mod;
        }
        if (nd[i].x != nd[i - 1].x || nd[i].y != nd[i - 1].y){// 避免一位减了重复的限制
            sum[cnt_x] = (sum[cnt_x] - nd[i].y % mod + mod) % mod;// 将所有可能值之和减掉限制的数
        }
    }
    int ans = quick_pow((1ll * n * (n + 1) >> 1) % mod, m - cnt_x);// 所有没有限制的位
    for (int i = 1; i <= cnt_x; i++){
        ans = 1ll * ans * sum[i] % mod;// 乘上每一个有限制的位的所有可能值之和
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：Huangjy88 (赞：0)

# P2220题解
## Part 1 题意描述
有一个数列，有 $m$ 个元素，每个元素可以为 $1$ 到 $n$。已知一些位置上不能为一些数，求所有满足条件的数列的所有元素的乘积之和是多少。
## Part 2 解法分析
这道题需要一点组合知识。若没有限制条件，易知答案为 $(\sum _ {i=1} ^ n  i) ^{m}=(\frac{n(n+1)}{2}) ^ m$。若有限制条件，设数列第 $i$ 个位置能选的数之和为 $sum_{i}$，则由乘法原理知 $ans=\prod _ {i=1} ^ m sum_{i}$。可以在读入时处理出每位不可选的数的和，然后循环累乘。
## Part 3 细节&优化
根据如上思路，可写出如下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5,mod=1e9+7;
int n,m,k;
map<pair<int,int>,bool>mp;//位置-数-能否放（判重） 
map<int,int>sum;//位置-不能放的数的总和 （数组放不下）
signed main(){
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++){
	int x,y;cin>>x>>y;
	if(mp[make_pair(x,y)]) continue;//注意判重
	mp[make_pair(x,y)]=1;
	sum[x]+=y;//累加
    }
    int ans=1,maxn=(n+1)*n/2;
    for(int i=1;i<=m;i++){
	ans*=(maxn-sum[i])%mod;//累乘（注意模）
	ans%=mod;
    }
    cout<<ans;
    return 0;
}
```
然后你就会发现[TLE](https://www.luogu.com.cn/record/117646136)了，
考虑优化。注意到限制条件最多有 $10 ^ {5}$ 个，而元素个数可能高达 $10 ^ {9}$ 个，所以可以单独处理有限制条件的位置，其余位置可以快速幂优化。
## Part 4 Code
AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5,mod=1e9+7;
int qpow(int a,int b){//快速幂
	int ans=1,base=a%mod;
	while(b){
		if(b&1) ans*=base%mod,ans%=mod;
		base*=base%mod,base%=mod;
		b>>=1;
	}
	return ans%mod;
}
int n,m,k;
map<pair<int,int>,bool>mp;//位置-数-能否放 
map<int,int>sum;//位置-不能放的数的总和 
int num[N]/*有限制条件的位置*/,cnt/*有限制条件的位置的个数*/;
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		int x,y;cin>>x>>y;
		if(!sum[x]) num[++cnt]=x;//新的有限制条件的位置
		if(mp[make_pair(x,y)]) continue;
		mp[make_pair(x,y)]=1;
		sum[x]+=y;
	}
	int ans=1,maxn=(n+1)*n/2;
	for(int i=1;i<=cnt;i++){//有限制条件的数位置
		ans*=(maxn-sum[num[i]])%mod;
		ans%=mod;
	}
   ans=ans%mod*qpow(maxn,m-cnt)%mod//无限制条件的位置
	cout<<ans;
	return 0;
}
```
~~管理员求过~~

---

## 作者：intel_core (赞：0)

我又来水题解了^_^（

------------------------

设第 $i$ 个位置上可选的数是 $a_{i,1},a_{i,2},\cdots,a_{i,p_i}$，那么所有可能的数列的元素之积的和就是 $\prod_{i=1}^m(\sum_{j=1}^{p_i}a_{i,j})$。

这个柿子的本质就是乘法原理，把每个位置的可能和全乘起来。

如果直接维护每个位置哪些能选的话是 $O(nm)$ 的，这个题 $n,m$ 都是 $10^9$ 的，显然不行。

观察到 $k\le 10^5$ ，所以有不能选的数的项最多只有 $10^5$ 个，直接维护每个位置不能选的数的和是多少。

不难发现剩下的位置都是 $\frac{n(n+1)}{2}$ ，用快速幂就可以。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MOD=1e9+7;
const int NR=1e5+10;
int n,m,k,T,sum[NR];
set<int>s[NR];
int v[NR],len,a[NR],b[NR];

int quickpow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=(res*x)%MOD;
		x=(x*x)%MOD;
		y>>=1;
	}
	return res;
}

void upd(int &x,int y){x=(x+y)%MOD;}
signed main(){
	cin>>n>>m>>k;T=(n*(n+1)/2)%MOD;
	for(int i=1;i<=k;i++)
		scanf("%lld%lld",&a[i],&b[i]),v[++len]=a[i];
	sort(v+1,v+1+len);
	len=unique(v+1,v+1+len)-v-1;
	int ans=quickpow(T,m-len);
	for(int i=1;i<=k;i++){
		a[i]=lower_bound(v+1,v+1+len,a[i])-v;
		if(!s[a[i]].count(b[i]))upd(sum[a[i]],b[i]),s[a[i]].insert(b[i]);
	}
	for(int i=1;i<=len;i++)ans=(ans*(T-sum[i]))%MOD;
	cout<<(ans+MOD)%MOD<<endl;
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

~~这道题还真容易~~

假设 $\sigma_i$ 表示 $A_i$ 所有能取到的值的和，则答案为

$$\prod\limits_{i=1}^n{\sigma_i}$$

直接求解的时间复杂度至少为 $O(n)$ ，会妥妥的超时。

但是可以发现当 $n$ 很大时，有大部分的 $\sigma_i=\dfrac {n\times(n+1)}{2}$ ，将这些 $\sigma_i$ 相乘，可以考虑快速幂优化。

于是，我们只用把所有有限制的$A_i$ 进行特判即可，其余的进行快速幂优化即可。

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define ll long long
const int MAXN=1e5+5;
const ll MOD=1e9+7;
ll n,m,k;
ll cnt=0,ans=1,same=1;//记录多少个不同的数出现，它们的和
struct data{
	ll x,y;
}d[MAXN];
bool cmp(data x,data y){
	if(x.x!=y.x) return x.x<y.x;
	return x.y<y.y;
}
ll fast(ll a,ll b){
	ll r=1;
	while(b){
		if(b%2==1)
			r=(r*a)%MOD;
		a=(a*a)%MOD;
		b/=2;
	}
	return r;
}

int main(){
	d[0].x=114514;//初值，不然k=0爆炸
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
		cin>>d[i].x>>d[i].y;
	sort(d+1,d+k+1,cmp);
	for(int i=1;i<=k+1;i++){//k+1小技巧
		if(d[i].x!=d[i-1].x){
			cnt++;
			if(i!=1)
				ans=(ans*((n*(n+1)/2%MOD-same+MOD*MAXN)%MOD))%MOD;
			same=d[i].y;
		}
		else if(d[i].y!=d[i-1].y)
			same+=d[i].y;
	}
	cout<<(ans*fast(n*(n+1)/2%MOD,m-cnt+1))%MOD;
}
```

---

## 作者：Midoria7 (赞：0)


震惊，减法居然还要取模。事实上看起来更大的数由于模之后可能变小，导致减一个看起来更小的数也会爆负数。考场上直接爆 90 pts。

******

好像大家都秒切这道题了。记录一下我的思路：

有一个数据点是 $k=0$，是一个很好的提示。我们发现，$k=0$ 的时候答案显然是 $\big(\frac{n(n+1)}{2}\big)^m$（简单的乘法分配率）。那么我们考虑有修改的时候，大多就是把这些 $\frac{n(n+1)}{2}$ 减去了一些数，再乘起来。我们看到 $n$ 很大，但 $k$ 并不大。我们并不关心数排列的顺序，所以我们可以直接离散化就行了。修改的单独乘，最后乘上 $\big(\frac{n(n+1)}{2}\big)^{m-cnt}$ 即可。

注意输入数据中有重复的，可以用 `map` 去重。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int Mod=1e9+7;
const int maxn=1e5+10;
int n,m,K;

inline int read(){
    int x=0;bool fopt=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())if(ch=='-')fopt=0;
    for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+ch-48;
    return fopt?x:-x;
}

inline int qpow(int x,int b){
    int ans=1,base=x;
    while(b){
        if(b&1)ans=ans*base%Mod;
        base=base*base%Mod;
        b>>=1;
    }
    return ans;
}

int a[maxn];
int cnt;
map<int,int> mp;
map<pair<int,int>,bool> vis;
signed main(){
#ifndef LOCAL
    freopen("easy.in","r",stdin);
    freopen("easy.out","w",stdout);
#endif
    n=read();m=read();K=read();
    for(int i=1;i<=K;i++){
        a[i]=n*(n+1)%Mod*qpow(2,Mod-2)%Mod;
    }
    for(int i=1;i<=K;i++){
        int x=read(),y=read();
        pair<int,int> temp;
        temp.first=x;temp.second=y;
        if(vis[temp])continue;
        else vis[temp]=1;
        if(!mp[x]){
            mp[x]=++cnt;
        }
        a[mp[x]]=(a[mp[x]]-y+Mod)%Mod;//减法不模见祖宗
    }
    int res=1;
    for(int i=1;i<=cnt;i++){
        res=res*a[i]%Mod;
    }
    res=res*qpow(n*(n+1)%Mod*qpow(2,Mod-2)%Mod,m-cnt)%Mod;
    printf("%lld\n",res);
    return 0;
}
```


---


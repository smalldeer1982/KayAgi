# [HNOI2002] 营业额统计

## 题目描述

Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。

Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。

而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。

我们定义，一天的最小波动值 = $\min\{|\text{该天以前某一天的营业额}-\text{该天营业额}|\}$。

特别地，第一天的最小波动值为第一天的营业额。

## 说明/提示

结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$

## 样例 #1

### 输入

```
6
5
1
2
5
4
6
```

### 输出

```
12```

# 题解

## 作者：lzl123 (赞：168)

# **本来想水个三十分先**

**于是写了个排序**

#### 结果直接A题！

**——尴尬....本来打算写平衡树的，看到排序都A了就无趣咯**

其实就是直接根据每天的值排序，然后它左右最近的数一定是和它的值相差最小的嘛

于是在左右都看看，如果天数比它的天数小就满足题意所以直接算到答案里去噻

```cpp
    #include <cstdio>
    #include <algorithm>
    #define ri register int
    #define getchar() (S==T&&(T=(S=BB)+fread(BB,1,1<<15,stdin),S==T)?EOF:*S++)
    char BB[1<<20],*S=BB,*T=BB;
    using namespace std;
    int n,sum;
    inline int read() 
    {
        int num=0,w=1; char ch=0;
        while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar(); }
        while(ch>='0'&&ch<='9') num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
        return num*w;
    }
    struct A{
        int num,day;
    }a[100000];
    bool cmp(A a,A b)
    {  
        return a.num<b.num;  
    } 
    inline int check(int x)
    {    int p=2147483647,t=2147483647;
        if(a[x].day==1)    return a[x].num;
        for(ri i=x-1;i>=1;--i)
                        if(a[i].day<a[x].day)    {p=(a[i].num>a[x].num)?a[i].num-a[x].num:a[x].num-a[i].num;break;}
        for(ri i=x+1;i<=n;++i)
                        if(a[i].day<a[x].day)    {t=(a[i].num>a[x].num)?a[i].num-a[x].num:a[x].num-a[i].num;break;}
        return (p>t)?t:p;
    }
    int main()
    {
        n=read();
        for(ri i=1;i<=n;++i)
            a[i].num=read(),a[i].day=i;
        sort(a+1,a+1+n,cmp);
        for(ri i=1;i<=n;++i)
            sum+=check(i);
        printf("%d",sum);
        return 0;
}
```

---

## 作者：Okarin (赞：113)

## STL大法好！


------------
众所周知，set能有序地维护同一类型的元素，但相同的元素只能出现一次。

对于这道题来说，我们可以用set来记录下之前出现过的所有营业额。

每次输入一个新的数x后，通过lowerbound操作找到set中大于等于x的第一个数。

0.如果这是第一个数，直接插入到set里。

1.这个数等于x,显然最小波动值为0，我们也不需要再插入一个x放到set里了。

2.这个数大于x,通过set的特性可以很轻松的找到这个数的前驱，也就是小于x的第一个数。将两个数分别减去x,对绝对值取个min就好了。此时要将x插入到set中。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<set>
using namespace std;
set<int>s;
set<int>::iterator k,a;
int n,x,ans=0;
int main()
{
    s.insert(192608170);
    s.insert(-192608170);
    scanf("%d",&n);
    for(register int i=1;i<=n;++i)
    {
        scanf("%d",&x);
        if(s.size()==2)
        {
            ans+=x;
            s.insert(x);
        }
        else
        {
            k=s.lower_bound(x);
            if(*k!=x)
            {
                a=k;
                a--;
                ans+=min(abs(*a-x),abs(*k-x));
                s.insert(x);
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：sxyugao (赞：74)

**题意**

不再赘述

**算法**

1、正解：各种高大上的数据结构，优点速度快。

2、STL（我等蒟蒻的方法）

我们发现对于每个Ai，与它绝对值最小的一定是前i个数排序后在它前面或后面的数。

但是插入排序太慢。。维护一个单调序列自然想到了set，因为可能有多个相同的营业额，所以我选择了multiset（而且set的insert不支持返回迭代器，需要二分查找，浪费~~宝贵的~~时间）。

以下为代码：
```cpp
#include<cstdio>
#include<set>
using namespace std;
typedef multiset<int>::iterator iter;
//定义iter类型，免去每次打一大串的苦恼
const int inf=0x7fffffff;
//定义无限大，0x7fffffff为16进制
int n,x,ans;
multiset<int>s;
inline int min(int a,int b){return a<b?a:b;}
inline int abs(int x){return x<0?-x:x;}
int main(){
	s.insert(inf);s.insert(-inf);
    //插入正无穷和负无穷，防止迭代器访问到一些奇奇怪怪的内存
	scanf("%d",&n);
	scanf("%d",&x);s.insert(x);ans=x;
    //第一个单独考虑
	while(--n){
		scanf("%d",&x);
		iter it=s.insert(x);
        //插入x，并返回x在s中的位置（迭代器）
		it--;
		iter l=it;
		it++;it++;
		iter r=it;
		it--;
        //迭代器只支持++，--运算符，所以看上去很麻烦。。
        //其实l就是上一个数，r是下一个数（在s中）
		if(*l==-inf)ans+=abs(x-*r);
        //在最前面
		if(*r==inf)ans+=abs(x-*l);
        //在最后面
		if(*l!=-inf&&*r!=inf)ans+=min(abs(x-*r),abs(x-*l));
        //一般情况
	}
	printf("%d",ans);
}
```

---

## 作者：a999999 (赞：47)

#[链接](https://www.luogu.org/problemnew/show/P2234)

看到平衡树的标签就不放心

看到dalao们各种牛逼的LCT，splay···

还是离线打链表吧

首先排序，然后插入链表

r[i]表示原来的a[i]在链表中的位置

倒序处理，把r[i]的ans贡献算出来，然后删除r[i]指向的位置

为什么这样可行呢？
```
因为是离线+排序，所以每个元素之间的关系是已知的
倒序处理时，对于每个a[i]，链表就是前i个元素组成的
所以不用我说了吧~~
```
复杂度O(NlogN)，实测68ms
```cpp
#pragma GCC optimize(2)//O(2)优化，参加NOIp时别用
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<iostream>
using namespace std;
struct node
{	int pre,next;
	#define l(x) b[b[x].pre]
	#define r(x) b[b[x].next]
}b[32768];
struct data{int d,rank;}a[32768];
int r[32768],n,ans;
bool cmp(const data &x,const data &y){return x.d<y.d||(x.d==y.d&&x.rank<y.rank);}
inline void del(int x)
{r(x).pre=b[x].pre;l(x).next=b[x].next;}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i].d),a[i].rank=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		r[a[i].rank]=i;
		if(i!=n)b[i].next=i+1;
		b[i].pre=i-1;
	}
	for(int i=n,x,j,k;i;i--,j=0,k=0)
	{
		x=r[i];
		if(b[x].pre)j=abs(a[b[x].pre].d-a[x].d);else j=2147483647/3;
		if(b[x].next)k=abs(a[b[x].next].d-a[x].d);else k=2147483647/3;
		if(i!=1)ans+=min(j,k);else ans+=a[x].d;
		del(x);r[i]=0;
	}
	printf("%d",ans);
	return 0;
}
```
谢谢你们看到最后~~~

---

## 作者：chen_vvv (赞：30)

# Treap题解
看了好几篇题解都没有用Treap做的，于是来分享一下我的Treap打法叭

这个题似乎是个平衡树板子的亚子，但是似乎很多人都是用了其他的大佬算法，数据好像也水的一批，但是如果是作为平衡树的模板来练练手的话是比较合适的选择。

我这里介绍的是Treap的做法，用起来还是比较方便的，毕竟只需要插入和查询。

根据题意，我们显然是要维护两个值：比当前x小的最大值，比当先x大的最小值。

我们先把第一个数直接插入，因为第一个数的最小波动值一定是自己。然后把之后的每个数查询两次，分别找到我们要维护的两个值，找到最小波动值

```cpp
		minx=query_las(x);
		maxx=query_net(x);
		xx=min(x-minx,maxx-x);
		ans+=xx;
```

有一点要注意，我们在查询是先把要找的变量赋成一个极值，这样就可以保证在找不到的情况下返回一个绝对不会选的值

因为我们只要查询和插入，所以我们不用维护子树大小size，所以代码打起来会方便很多

有关于平衡树的更多操作，可以做一做[【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

话不多说，上码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50005;
const int INF=1e7+10;
int ans=0,x;
int n,root,tot,val[N],a[N][2],ran[N],cnt[N];

int add(int v) //加入新的数 
{
	tot++;
	val[tot]=v;//权值 
	ran[tot]=rand();//随机的优先级 
	cnt[tot]=1; //cnt代表当先数值为x的值的个数 
	return tot;
}

void build(int v) //看似没什么用的预处理 
{
	root=add(v);
}

void rotate(int &k,int v) //旋转操作，k代表树根，v=0是左旋，v=1是右旋 
{
	int t=a[k][!v];
	a[k][!v]=a[t][v];
	a[t][v]=k;
	k=t;
}

void insert(int &k,int v) //插入操作，k为树根，v为要插入的值 
{
	if(!k) 
	{
		k=add(v); //如果找不到了就建新的点 
		return;
	}
	if(v==val[k]) cnt[k]++; 
	else
	{
		int d=v<val[k]?0:1; //找到要找的方向 
		insert(a[k][d],v);
		if(ran[k]>ran[a[k][d]]) rotate(k,!d); //如果优先级更小的话旋转（注意是反方向的） 
	}
}

int query_las(int v) //查询比x小的 
{
	int k=root,last=-INF; // 如果找不到就返回一个极小值（就是一定不会选的值） 
	while(k)
	{
		if(val[k]<=v) last=val[k],k=a[k][1]; 
		else k=a[k][0];
	}
	return last;
}

int query_net(int v) // 查询比x大的 
{
	int k=root,net=INF; //同上 
	while(k)
	{
		if(val[k]>=v) net=val[k],k=a[k][0];
		else k=a[k][1];
	}
	return net;
}

int main()
{
	scanf("%d%d",&n,&x);
	build(x);
	ans+=x;
	for(int i=2,minx,maxx,xx;i<=n;i++)
	{
		scanf("%d",&x);
		minx=query_las(x);
		maxx=query_net(x);
		xx=min(x-minx,maxx-x);
		ans+=xx;
		insert(root,x);
	}
	printf("%d\n",ans);
	return 0;
} 
//没辽 
```



---

## 作者：Mosher (赞：19)

### 看见没有用vector的赶紧来水一篇（雾）

**正文：**

解题思路：

1. 当前波动值与前面有关，考虑查找到与当前x,abs(y-x)_min

2. 想到二分查找（或者dalao考虑到:树上的前驱和后继）,那么必然要使其 **有序**

3. 算法：

	First:排序暴力（虽然我没考虑，因为觉得过不了，but第一篇题解...）

    Second：平衡树：Splay（我平衡树只会Splay，QAQ，太蒟蒻了）,发现没有区间翻转，数据也不大，那么为什么要手打？（懒）

    Third：既然已想到Second，于是：**STL**大法好，那就**vector**解决吧，qwq

PS:具体讲解在代码中（24行搞定）。

**前置姿势:**

lower_bound:返回在某段区间中：>=x的第一个数的地址

upper_bound:返回在某段区间中：> x的第一个数的地址

**Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define qwq s.begin(),s.end(),x//懒人大法好
#define upp upper_bound
#define low lower_bound
int sum,n,x;
vector<int>s;
vector<int>::iterator it;//迭代器，插入初始边界用
int main(){
	scanf("%d",&n);
	s.insert(it,-INT_MAX);//边界:负极大值的原因是营业额x可能为-
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		if(i==1) sum+=x;//第一天
		else{
			int a=*--low(qwq),b=*low(qwq);//前驱与后继（假：也有可能是x本身）
			if(a==-INT_MAX) sum+=abs(b-x);//不要把边界加进来了
			else sum+=min(abs(a-x),abs(b-x));//最小波动值
		}
		s.insert(upp(qwq),x);//向末尾处直接有序插入当前值
	}
	printf("%d",sum);
}
```
rp++

---

## 作者：Sky_star (赞：18)

话说这可以用双向链表做

加入点可以用反向删除点来处理

删除点只要将指向他的ne[]和pre[]（即前驱和后驱更改）

以下代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<climits>
using namespace std;
int n,ne[200001],ne1[200001],ys[200001],an;
struct gjh
{
   int v,w;
}mp[200001];
bool cmp(gjh a,gjh b){return a.v<b.v;}
int main()
{
   scanf("%d",&n);
   for(int i=1;i<=n;i++)scanf("%d",&mp[i].v),mp[i].w=i,ne[i]=(i==n)?0:i+1,ne1[i]=(i==1)?0:i-1;
   an+=mp[1].v;
   sort(mp+1,mp+n+1,cmp);
   for(int i=1;i<=n;i++)ys[mp[i].w]=i;
   for(int i=n;i>=1;i--)
   {
        int ans=INT_MAX;
        if(ne[ys[i]]!=0)ans=min(ans,abs(mp[ne[ys[i]]].v-mp[ys[i]].v));
        if(ne1[ys[i]]!=0)ans=min(ans,abs(mp[ne1[ys[i]]].v-mp[ys[i]].v));
        if(ans==INT_MAX)ans=0;
        an+=ans,ne1[ne[ys[i]]]=ne1[ys[i]],ne[ne1[ys[i]]]=ne[ys[i]];
   }
   printf("%d",an);
   return 0;
}
```

---

## 作者：檀黎斗·神 (赞：16)

正好在学Splay，就拿Splay来写吧

题目就是要求除第一个数之外输入数据的前驱（比它小的数之最大值）和后继（比它小的数之最小值）

而找根的前驱和后继只需要在建完一颗二叉排序树之后，找左子树中最右和右子树中最左

对于这道题而言，根节点需要更新

那么我们正好就用Splay来更新树

注释真的写的很全面了还有什么不懂直接看代码


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node{
    int fa,ld,rd,data; //分别存父节点，左孩子，右孩子，值 
}tree[33000];
int n,ans,root,flag;
void rightx(int x) //右旋 
{
    int y=tree[x].fa;
    int z=tree[y].fa;
    tree[y].ld=tree[x].rd;
    if(tree[x].rd) tree[tree[x].rd].fa=y;
    tree[x].fa=z;
    if(z)
    {
        if(tree[z].ld==y)
        tree[z].ld=x;
        else tree[z].rd=x;
    } 
    tree[x].rd=y;
    tree[y].fa=x;
}
void leftx(int x) //左旋 
{
    int y=tree[x].fa;
    int z=tree[y].fa;
    tree[y].rd=tree[x].ld;
    if(tree[x].ld) tree[tree[x].ld].fa=y;
    tree[x].fa=z;
    if(z)
    {
        if(tree[z].ld==y)
        tree[z].ld=x;
        else tree[z].rd=x;
    }
    tree[x].ld=y;
    tree[y].fa=x;
}
int aabs(int x)
{
    return x>0?x:-x;
}//自己写的绝对值，不喜欢用cmath 
void splay(int x)
{
    while(tree[x].fa) //一直把x旋转到根节点 
    {
        int y=tree[x].fa; //y是x的父节点 
        int z=tree[y].fa; //z是y的父节点 
        if(!z)            //如果y是根的话 
        {
            if(tree[y].ld==x) rightx(x); //左孩子就右旋 
            else leftx(x);               //右孩子就左旋 
        }
        else
        {
            if(tree[y].ld==x&&tree[z].ld==y) //如果是 / 这种情况 
            rightx(y),rightx(x);
            
            if(tree[y].rd==x&&tree[z].rd==y) //如果是 \ 这种情况 
            leftx(y),leftx(x);
            //如果是在一条直线上先旋转父节点再旋转子节点 
            if(tree[y].rd==x&&tree[z].ld==y) //如果是 < 这种情况 
            leftx(x),rightx(x);
            
            if(tree[y].ld==x&&tree[z].rd==y) //如果是 > 这种情况 
            rightx(x),leftx(x);
            //如果是一条折线上只需要旋转子节点 
        }
    }
    root=x; //更新根节点 
}
void BST(int x,int rt) //建立二叉查找树 
{
    if(tree[x].data==tree[rt].data) 
    //相同的数只需要更新根节点没必要加入到树里去
    //因为相同的数有一个就够了 
    {
        splay(rt);
        flag=1;
        return;
    } //可以不要，只是为了简化时间复杂度 
    if(tree[x].data<tree[rt].data)
    {
        if(tree[rt].ld==0)
        {
            tree[rt].ld=x;
            tree[x].fa=rt;
        }
        else BST(x,tree[rt].ld);
    }
    else
    {
        if(tree[rt].rd==0)
        {
            tree[rt].rd=x;
            tree[x].fa=rt;
        }
        else BST(x,tree[rt].rd);
    }
}
int fro(int x) //找前驱 
{
    int y=tree[x].ld;
    if(!y) return y;
    while(tree[y].rd)
    y=tree[y].rd;
    return y;
}
int beh(int x) //找后继 
{
    int y=tree[x].rd;
    if(!y) return y;
    while(tree[y].ld)
    y=tree[y].ld;
    return y;
}
void insert(int x) //输入 
{
    flag=0;
    BST(x,root);  //建立二叉查找树 
    if(flag==1) return; //如果它有相同没必要计算 
    splay(x);
    
    int q=fro(x),h=beh(x),minn=0x7fffffff;
    if(q) minn=min(minn,aabs(tree[x].data-tree[q].data));
    if(h) minn=min(minn,aabs(tree[x].data-tree[h].data));
    
    ans+=minn;
}
int main()
{
    scanf("%d",&n);
    scanf("%d",&tree[1].data);
    root=1;ans+=tree[1].data;
    for(int i=2;i<=n;i++)
    {
        scanf("%d",&tree[i].data);
        insert(i);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：卡车cckk (赞：14)

什么，不会splay，不会数据结构。。用我们蒟蒻的方法吧！
set大法好！
* insert(x)
自动插入排序，时间O(logN)
* lower_bound(x)
logN的查找离x最接近且大于x的数

以上足以！
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <set>
using namespace std;
set<int> s;
int n,a;
int main()
{
	scanf("%d",&n);scanf("%d",&a);s.insert(a);
	int ans=a;
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&a);
		set<int>::iterator r=s.lower_bound(a);
		if(r==s.end()){ans+=abs(a-*(--r));s.insert(a);continue;}
		set<int>::iterator l;
		if(r!=s.begin())l=--s.lower_bound(a);
        else {ans+=abs(a-*r);s.insert(a);continue;}
		ans+=min(abs(a-*l),abs(a-*r));
		s.insert(a);
	}
	printf("%d",ans);
	return 0;
}

```
思路显而易见就不说了吧，主要是数据结构那块可以偷懒到原地爆炸，时间复杂度O(nlog^2(n))  吧

#### 温馨提示，这里要用set的lower_bound，不可以用泛型函数的
lower_bound

即 不要这么写
```cpp
lower_bound(s+1,s+n+1,x);
```
由于set结构的原因，这样会比自带的慢很多


恩，25行哈哈，为了压行写的好乱233.。我相信你们肯定有更短更简洁的代码。

题外话，一个[神奇的网站](http://jvruo.com)可以了解一下

---

## 作者：Refun (赞：12)

第一个为线段树做法第二个为平衡树做法 

ONE

设每天的营业额在线段树数组中的下标为他本身的值

然后每次输入一个数时我们先在这个数的左边的区间查找最大值

再在右边的区间查找最小值

（这意味着我们要找比这个数小的最大值和比这个数大的最小值）

然后比较两者取差的绝对值最小的加到Ans里即可。

TWO
近乎Splay裸题了……

一天天插入数字，然后查询前驱和后继累加最小值就好了 

注意若当前天营业额在之前出现过时（即为Cnt>1）就不用累加了 

[代码戳这里](http://www.cnblogs.com/refun/p/8682214.html)

---

## 作者：ysner (赞：11)

当我第一次看到这道题的标签时，我被吓着了，“概率论,统计”？“Splay”？“SBT”？我一个都不会啊！

然而细想一下，似乎也不是那么难，用不着什么高级算法、高级数据结构。。。

不就是一个链表吗？

  顺便把题目补充完整，加一句话“该天的最小波动值=min{|该天以前某一天的营业额-该天营业额|}。”。
这么想，那一天的最小波动值就取决于与其值最接近的某天营业额。sort营业额即可一波带走。

然后为保证取的是该天以前的营业额，从后往前枚举是第几天，该天取完后把该点删掉，把前后连起来即可。

思想简单，代码简单，变量形象，就不给注释了。(~~第一次交就是最优解，害怕~~)

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=40005,inf=1e9;
ll ans=0;
struct fol
{
    int num,id;
}s[N];
int n,nex[N]={},pre[N]={},a[N],x;
il bool cmp(fol x,fol y)
{
    return (x.num<y.num)||(x.num==y.num&&x.id<y.id);
}
il int min(re int x,re int y){return (x<y)?x:y;}
il int abs(int x){return (x<0) ? -x : x;}
il int gi()
{
    re int x=0;
    re int t=1;
    re char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}
int main()
{
    n=gi();
    fp(i,1,n)
    {
        if(scanf("%d",&x)==EOF) x=0;
        a[i]=x;
    }
    fp(i,1,n) s[i]=(fol){a[i],i};
    sort(s+1,s+1+n,cmp);
    fp(i,1,n) nex[s[i].id]=s[i+1].id,pre[s[i].id]=s[i-1].id;
    fq(i,n,2)
    {
        re int a1=a[nex[i]],a2=a[pre[i]];
        if(!nex[i]) a1=inf;
        if(!pre[i]) a2=inf;
        ans+=min(abs(a1-a[i]),abs(a2-a[i]));
        nex[pre[i]]=nex[i];
        pre[nex[i]]=pre[i];
    }
    ans+=a[1];
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：wjy666 (赞：8)

(前面那遍交错了，好尴尬啊)

这题我用的也是STL，但是用的vector，没用set

主要思路也是每读入一个便用lower\_bound找比当前的要大的最小的，这个数前面的那个就是比它小的最大的，两者计算取最小即可

然后先把前2个放进去会好写一些，再特判一些情况就行了

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#define For(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
int read(){//快读
    int l=1,x=0; char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if (ch=='-') ch=getchar(),l=-1;
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*l;
}
vector<int> vec;
int main(){
    int n=read(),ans,x,y;
    x=read(),y=read(); ans=x; if (x>y) swap(x,y);
    vec.push_back(x); vec.push_back(y); ans+=y-x; //先放前2个
    For(i,2,n-1){
        x=read(); y=lower_bound(vec.begin(),vec.end(),x)-vec.begin(); //找比当前的要大的最小的
        if (y==0) ans+=abs(x-vec[y]); //特判如果第一个就比当前大
        else if (y==i) ans+=x-vec[y-1]; //特判当前数大于已有的所有数
        else ans+=min(abs(x-vec[y-1]),abs(x-vec[y])); 
        vec.insert(vec.begin()+y,x);//把当前丢到比当前的要大的最小的那个数前面
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：黑泽斯 (赞：5)

用STL的set要不要这么简单，每读入一个便用lower\_bound找比当前的要大的最小的，再找比它小的最大的，两者计算取最小即可。

注意：(1)先找后读；(2)1,2数据特判要好写一些(实际因为数据比较水根本不用判)；(3)据说有些数据没有n行，所以最好用while读。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <set>
using namespace std;
set<int> q;
int sq[100005];
set<int>::iterator p;
set<int>::iterator l;
int main()
{
    int n;
    cin>>n;
    cin>>sq[1];
    cin>>sq[2];
    q.insert(sq[1]);
    q.insert(sq[2]);
    int ans=sq[1]+abs(sq[2]-sq[1]);
    int i=3;
    while(cin>>sq[i])
    {
        p=q.lower_bound(sq[i]);
        l=p;
        if(p!=q.begin()) l--;
        ans+=min(abs(sq[i]-*p),abs(sq[i]-*l));
        q.insert(sq[i]);
        i++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：5)

从同学那学的神秘无数据结构无 STL 做法。[题目链接](https://www.luogu.com.cn/problem/P2234)。感觉多少有点好玩。

注意到值域很小，于是我们决定开一个布尔数组把所有出现的数标记为一。然后查询答案的时候，我们直接运行暴力即可。

我们考虑为什么这个暴力是对的。我们不难发现本质上是在干这么一件事情：维护数轴上的若干连续段，每次将一个连续段从中间裂成两半并取较小一半作为代价。考虑类似启发式合并的贡献分析方案，对于一个位置，它在一次操作中产生贡献当且仅当它位于被裂开的连续段中较小的那一部分。那么对于一个位置，它每一次贡献一定代表所处连续段长度至少除以二。换而言之，它的贡献至多为 $O(\log A)$。于是我们从而将该算法的复杂度分析为 $O(n+A\log A)$，可以较快通过。

代码和 set 的好写程度可能在伯仲之间。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e6 + 9;
int n, ans;
bool __vst[N << 1], *vst = __vst + N;
int calc(int x) {
  for (int i = 0; i <= N + x; ++i)
    if ((i < N - x && vst[x + i]) || vst[x - i]) return i;
  return x;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n;
  for (int i = 0, a; i < n; ++i) cin >> a, ans += calc(a), vst[a] = true;
  return cout << ans << endl, 0;
}
```

---

## 作者：henrytb (赞：5)

看见没什么人用fhq-treap做这题，赶紧水一发~

---

今天早上刚自己百度学了fhq-Treap（自认为比较容易理解），于是自己写了几道题。。。

fhq-treap与treap的区别就在于它维护平衡不用什么左旋右旋转来转去，而是用**分裂**和**合并**两个操作来维护

而这道题呢只需要读入同时对每个节点寻找前驱/后继中波动值最小的一个，这显然是平衡树模板 ~~（然而有很多人用set秒切此题）~~

具体实现见呆码：

```cpp
#include <bits/stdc++.h>
#define spilt split
#define ls(rt) T[rt].lc
#define rs(rt) T[rt].rc
#define rep(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
const int INF=0x3f3f3f3f;
int n,tot=0;
struct node{
    int val,rnk,lc,rc,sz;
}T[40005];
void update(int rt){T[rt].sz=T[ls(rt)].sz+T[rs(rt)].sz+1;}
int add(int val){
    T[++tot].val=val;
    ls(tot)=rs(tot)=0;
    T[tot].sz=1;
    T[tot].rnk=rand();
    return tot;
}
void split(int rt,int &a,int &b,int val){
    if(!rt){a=b=0;return;}
    if(T[rt].val<=val){
        a=rt;
        split(rs(rt),rs(a),b,val);
    } else {
        b=rt;
        split(ls(rt),a,ls(b),val);
    }
    update(rt);
}
void merge(int &rt,int a,int b){
    if(a==0||b==0){
        rt=a+b;
        return;
    }
    if(T[a].rnk<T[b].rnk){
        rt=a;
        merge(rs(rt),rs(a),b);
    } else {
        rt=b;
        merge(ls(rt),a,ls(b));
    }
    update(rt);
}
int kth(int rt,int k){
    while(k!=T[ls(rt)].sz+1){
        if(k<T[ls(rt)].sz+1) rt=ls(rt);
        else{
            k-=T[ls(rt)].sz+1;
            rt=rs(rt);
        }
    }
    return T[rt].val;
}
void insert(int &rt,int val){
    int a=0,b=0,newnode=add(val);
    spilt(rt,a,b,val);
    merge(a,a,newnode);
    merge(rt,a,b);
}
int pre(int &rt,int val){
    int a=0,b=0;
    split(rt,a,b,val);
    int ans=kth(a,T[a].sz);
    merge(rt,a,b);
    return ans;
}
int scc(int &rt,int val){
    int a=0,b=0;
    split(rt,a,b,val-1);
    int ans=kth(b,1);
    merge(rt,a,b);
    return ans;
}
int main(){
    int root=1,ans=0;
    srand(19260817);
    scanf("%d",&n);
    add(INF);
    T[root].sz=0;
    insert(root,-INF);
    rep(i,1,n){
        int x;
        scanf("%d",&x);
        if(i!=1)ans+=min(abs(x-pre(root,x)),abs(x-scc(root,x)));
        else ans=x;
        insert(root,x);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Meatherm (赞：5)

## 0 前言

平衡树固然可以写。然而~~自带大常数的~~权值线段树也可以，个人感觉比平衡树好写。

## 1 思路

首先还是读进来数据，然后权值线段树基本操作——**排序、离散化**。（很遗憾只能**离线**）

设$a[i]$为第$i$天的**营业额**，$b[i]$为$a[i]$**离散化之后的对应值**。

题目说第$1$天的最小波动值即为$a[1]$。则$ans$初始值为$a[1]$，然后将$b[1]$插入到权值线段树中。

对于第$i(2\leq i \leq n)$天，先将$b[i]$插入至权值线段树，然后查询排名。分类讨论：

- 如果排名为$1$，且当前没有相等的数，则最小波动值为**排名为$2$的数与当前数之差的绝对值。**

- 如果排名为$1$，且当前有相等的数，则最小波动值为$0$。

- 如果排名为$i$，由于**不可能有相等的数**了（如果有重复的数，排名不会为$i$），则最小波动值为**排名为$i-1$的数与当前数之差的绝对值**。

- 否则，**最小波动值为$\min\{$排名为当前数排名$-1$的数与当前数之差的绝对值$,$排名为当前数排名$+1$的数与当前数之差的绝对值$)$**。

累加最小波动值，到最后输出即可。

## 2 坑点与细节

代码可能有一个地方看起来像是错的。

```cpp	
		
if(Querysum==1&&!s[std::lower_bound(b+1,b+1+m,a[i])-b]){
			ans+=abs(a[i]-b[GetRankByVal(1,1,m,Querysum+1)]);
		}
		else if(Querysum==i){
			ans+=abs(a[i]-b[GetRankByVal(1,1,m,Querysum-1)]);
		}
		else {
			ans+=std::min(abs(a[i]-b[GetRankByVal(1,1,m,Querysum-1)]),abs(a[i]-b[GetRankByVal(1,1,m,Querysum+1)]));
		}
```

这里可以发现少判断了一个情况，就是思路中的**第$2$种**。我将第$2$种情况“错误”的归到了第四类。那么为什么是对的呢？

当前排名为$1$，查询排名为$0$的数，导致会进入每一个权值线段树节点的左儿子（非叶节点）。而一直往左走就会到达第一个叶节点（即$[1,1]$），也就是说查询排名为$0$的数实则是查到了排名为$1$的数啊。

当前排名为$1$，查询排名为$2$的数。由于有相等的数，那么第$2$名必定和第$1$名相等（否则不存在相等的数）。

## 3 代码

```
# include <bits/stdc++.h>
# define rr register
const int N=40010;
int tree[N*4];//权值线段树数组
int n,m;
int a[N],b[N];//原数组和离散化数组
int s[N];//记录重复的数
int ans;//最终答案
int Querysum;//查询结果
inline int read(void){//快读
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;		
}
inline int lc(int x){//左儿子
	return x<<1;
}
inline int rc(int x){//右儿子
	return x<<1|1;
}
void GetValFindRank(int k,int l,int r,int v){//给出值 找排名
	if(l==r){
		++Querysum;
		return;
	}
	int mid=(l+r)>>1;
	if(v<=mid){//在左子树
		GetValFindRank(lc(k),l,mid,v);
		return;
	}
    //在右子树
	Querysum+=tree[lc(k)];
	GetValFindRank(rc(k),mid+1,r,v);
	return;
}
void Insert(int k,int l,int r,int v){//插入
	++tree[k];
	if(l==r){
		return;
	}
	int mid=(l+r)>>1;
	if(v<=mid){
		Insert(lc(k),l,mid,v);	
		return;
	}	
	Insert(rc(k),mid+1,r,v);
	return;	
}
int GetRankByVal(int k,int l,int r,int x){//给排名找值
	if(l==r)
		return l;
	int mid=(l+r)>>1;
	if(x<=tree[lc(k)])
		return GetRankByVal(lc(k),l,mid,x);
	return GetRankByVal(rc(k),mid+1,r,x-tree[lc(k)]);
}
int main(void){
	n=read();
	for(rr int i=1;i<=n;++i)
		a[i]=b[i]=read();
    //进行（伪）离散化操作    
	std::sort(b+1,b+1+n);
	m=std::unique(b+1,b+1+n)-(b+1);
	ans=a[1];//如题目所述，第一天的最小波动值则为营业额
	Insert(1,1,m,std::lower_bound(b+1,b+1+m,a[1])-b);//插入
	++s[std::lower_bound(b+1,b+1+m,a[1])-b];//记录重复元素
	for(rr int i=2;i<=n;++i){
		Querysum=0;//记得清零
		Insert(1,1,m,std::lower_bound(b+1,b+1+m,a[i])-b);//插入
		GetValFindRank(1,1,m,std::lower_bound(b+1,b+1+m,a[i])-b);//找排名
		
		if(Querysum==1&&!s[std::lower_bound(b+1,b+1+m,a[i])-b]){
			ans+=abs(a[i]-b[GetRankByVal(1,1,m,Querysum+1)]);
		}
		else if(Querysum==i){
			ans+=abs(a[i]-b[GetRankByVal(1,1,m,Querysum-1)]);
		}
		else {
			ans+=std::min(abs(a[i]-b[GetRankByVal(1,1,m,Querysum-1)]),abs(a[i]-b[GetRankByVal(1,1,m,Querysum+1)]));
		}//分类讨论
		++s[std::lower_bound(b+1,b+1+m,a[i])-b];//记录重复元素
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：切格瓦·星 (赞：4)

刚写了一篇有旋Treap的题解，立马来补一发无旋Treap的题解。

无旋Treap,简称FHQ-Treap，是一位名叫fhq的julao发明的，
它好理解又好打而且功能十分强大，甚至可以完成可持久化
(~~虽然我根本不会~~)建议和我一样的萌新先去学FHQ(~~反正我先学的有旋Treap到现在还没有完全搞懂左旋右旋的意义~~)

FHQ的主要操作就只有两个：分裂(Slipt)和合并(Merge)其他所有的基本操作(~~至少是我所知道的~~)都是依靠着两个操作实现的，怎么样，简单吧。

不多说，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=214748364; 
int n,root,x,y,sum,a[100000],ans;
struct tree{
	int l,r,size,v,rnd;
}t[100000];
void update(int p){
	t[p].size=t[t[p].l].size+t[t[p].r].size+1;
}//与有旋Treap相似的操作,用子节点更新父节点; 
void split(int p,int k,int &x,int &y){
	//这个函数的意思是把根节点为p的子树以权值k分为两棵子树,
	//权值较小的子树的根为x,权值较大的子树的根为y; 
	if(!p)
		x=y=0;//p为零有两种情况:
		      //1: 刚开始时为x,y赋初值;
			  //2: 遍历至叶子结点左右无孩子时; 
	else if(t[p].v<=k){
		x=p;
		split(t[p].r,k,t[p].r,y);
		update(p);
	}//如果当前节点的值小于k,及当前节点与当前节点的左子树全部属于权值较小的子树;
	//因为p节点已经归入左子树,所以接下来要分裂以p为根节点的子树; 
	else{
		y=p;
		split(t[p].l,k,x,t[p].l);
		update(p);
	}//反之亦然; 
}//分裂操作; 
int merge(int A,int B){
	if(!A||!B)
		return A+B;//如果A和B中有一个为0,说明合并完成,返回另一个值即可; 
	if(t[A].rnd<t[B].rnd){//因为要维护堆的性质(我维护的是小根堆),
						  //如果A的随机值小于B的随机值,说明B子树只能为A子树的右子树; 
		t[A].r=merge(t[A].r,B);
		update(A);
		return A;
	}
	else{//反之亦然; 
		t[B].l=merge(A,t[B].l);
		update(B);
		return B;
	}
}
int newo(int a){
	t[++sum].size=1;
	t[sum].v=a;
	t[sum].rnd=rand();
	return sum;
}//新建一个节点; 
void ins(int a){
	split(root,a,x,y);
	root=merge(merge(x,newo(a)),y);
}//暴力分解和合并即可; 
int Xth(int p,int a){
    if(a<=t[t[p].l].size)
	return Xth(t[p].l,a);
    else if(a==t[t[p].l].size+1)
	return p;
    else
	return Xth(t[p].r,a-t[t[p].l].size-1);
}//求子树p中排名为a的节点编号,不再赘述自己思考一下(不难想); 
int pre(int a){
	int x,y;
	split(root,a,x,y);
	//因为已经将树由权值a分成了x子树和y子树,
	//接下来只需查找x子树中最大的那个即可; 
	int res=Xth(x,t[x].size);
	root=merge(x,y);
	return t[res].v;
}//求前驱; 
int back(int a){//理由与求前驱一致,不再赘述; 
	split(root,a-1,x,y);
	int res=Xth(y,1);
	root=merge(x,y); 
	return t[res].v;
}//求后继; 
int main(){
	scanf("%d",&n);
	scanf("%d",&a[1]);
	ins(a[1]);
	ins(inf),ins(-inf);//记住一定要先插一正一负两个inf进去(我因为这个错改了一下午); 
	ans=a[1];
	for(int i=2;i<=n;i++){
		scanf("%d",&a[i]);
		if(pre(a[i])!=-inf||back(a[i])!=inf)
		ans+=min(abs(pre(a[i])-a[i]),abs(back(a[i])-a[i]));//最后在前驱和后继里找一个更合适的更新ans即可; 
		ins(a[i]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：切格瓦·星 (赞：4)

翻了几页都没发现有用有旋Treap写的题解....

# ~~(可这题在LOJ上是Treap的模板题啊)~~

赶紧来水篇有旋Treap的题解

具体解释看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=214748364;
int n,a[1000000],root,sum;
long long ans;
struct Treap{
	int l,r,v,num,size;
	long long rnd;
}t[100000];//用结构体存变量:
		  //l:左孩子,r:右孩子;
		  //v:该节点的权值;
		  //num:与该节点权值相同的点的个数;
		  //size:以该节点为根的子树的节点数;
		  //rand:该节点的随机值; 
void update(int p){
	t[p].size=t[t[p].r].size+t[t[p].l].size+t[p].num;
}//用子节点的值更新父节点的值; 
void rt(int &p){
	int q=t[p].l;t[p].l=t[q].r;t[q].r=p;
	t[q].size=t[p].size;update(p);p=q;
}
void lt(int &p){
	int q=t[p].r;t[p].r=t[q].l;t[q].l=p;
	t[q].size=t[p].size;update(p);p=q;
}//基础的左旋右旋操作; 
void ins(int &p,int x){
	if(!p){
		p=++sum;
		t[p].num=t[p].size=1;
		t[p].v=x;
		t[p].rnd=rand();
		return;
	}
	t[p].size++;
	if(t[p].v==x) t[p].num++;
	else if(x>t[p].v){
		ins(t[p].r,x);
		if(t[t[p].r].rnd<t[p].rnd) lt(p);
	}//如果要插入的值比当前节点的值大,就将其插入右子树中,同时如果右节点的随机值比当前节点随机值小,
	 //就要通过左旋来维护堆的性质; 
	else{
		ins(t[p].l,x);
		if(t[t[p].l].rnd<t[p].rnd) rt(p);
	}//理由同上; 
}//插入操作 
int pre(int p,int x){
	if(!p) return -inf;
	if(t[p].v>x) return pre(t[p].l,x);
	else return max(t[p].v,pre(t[p].r,x));
}//查找前驱; 
int bac(int p,int x){
	if(!p) return inf;
	if(t[p].v<x) return bac(t[p].r,x);
	else return min(t[p].v,bac(t[p].l,x));
}//查找后继; 
int main(){
	scanf("%d",&n);
	scanf("%d",&a[1]);
	ins(root,a[1]);
	ans=a[1];
	for(int i=2;i<=n;i++){
		scanf("%d",&a[i]);
		ans+=min(abs(pre(root,a[i])-a[i]),abs(bac(root,a[i])-a[i]));//在前驱和后继中选一个符合题意的值来更新ans; 
		ins(root,a[i]);//要先找后插入; 
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：重回巅峰！ (赞：4)

由于这里没有P的模板，我就发一个上来

伸展树，或者叫自适应查找树，是一种用于保存有序集合的简单高效的数据结构。伸展树实质上是一个二叉查找树。允许查找，插入，删除，删除最小，删除最大，分割，合并等许多操作，这些操作的时间复杂度为O(logN)。由于伸展树可以适应需求序列，因此他们的性能在实际应用中更优秀。

伸展树支持所有的二叉树操作。伸展树不保证最坏情况下的时间复杂度为O(logN)。伸展树的时间复杂度边界是均摊的。尽管一个单独的操作可能很耗时，但对于一个任意的操作序列，时间复杂度可以保证为O(logN)。

二、自调整和均摊分析：

平衡查找树的一些限制：

1、平衡查找树每个节点都需要保存额外的信息。

2、难于实现，因此插入和删除操作复杂度高，且是潜在的错误点。

3、对于简单的输入，性能并没有什么提高。

平衡查找树可以考虑提高性能的地方：

1、平衡查找树在最差、平均和最坏情况下的时间复杂度在本质上是相同的。

2、对一个节点的访问，如果第二次访问的时间小于第一次访问，将是非常好的事情。

3、90-10法则。在实际情况中，90%的访问发生在10%的数据上。

4、处理好那90%的情况就很好了。

在一颗二叉树中访问一个节点的时间复杂度是这个节点的深度。因此，我们可以重构树的结构，使得被经常访问的节点朝树根的方向移动。尽管这会引入额外的操作，但是经常被访问的节点被移动到了靠近根的位置，因此，对于这部分节点，我们可以很快的访问。根据上面的90-10法则，这样做可以提高性能。

为了达到上面的目的，我们需要使用一种策略──旋转到根(rotate-to-root)。

五、基本伸展树操作：

1、插入：

当一个节点插入时，伸展操作将执行。因此，新插入的节点在根上。

2、查找：

如果查找成功（找到），那么由于伸展操作，被查找的节点成为树的新根。

如果查找失败（没有），那么在查找遇到NULL之前的那个节点成为新的根。也就是，如果查找的节点在树中，那么，此时根上的节点就是距离这个节点最近的节点。

3、查找最大最小：

查找之后执行伸展。

4、删除最大最小：

a)删除最小：

首先执行查找最小的操作。

这时，要删除的节点就在根上。根据二叉查找树的特点，根没有左子节点。

使用根的右子结点作为新的根，删除旧的包含最小值的根。

b)删除最大：

首先执行查找最大的操作。

删除根，并把被删除的根的左子结点作为新的根。

5、删除：

将要删除的节点移至根。

删除根，剩下两个子树L（左子树）和R（右子树）。

使用DeleteMax查找L的最大节点，此时，L的根没有右子树。

使R成为L的根的右子树。



```cpp
const maxn=100007;
type tp=record
          left,right,data,father:longint;
        end;
var
  tree:array[0..maxn]of tp;
  tot,now,ans,min,root,prev,next,same,n:longint;
procedure init;
begin
  readln(n);
  fillchar(tree,sizeof(tree),0);
  read(tree[1].data); root:=1;
  ans:=tree[1].data;
end;
procedure leftrotate(x:longint);
var y:longint;
begin
  y:=tree[x].father;
  tree[y].right:=tree[x].left;
  if tree[x].left<>0 then tree[tree[x].left].father:=y;
  tree[x].father:=tree[y].father;
  if tree[y].father<>0 then
  begin
    if y=tree[tree[y].father].left then tree[tree[y].father].left:=x
                                   else tree[tree[y].father].right:=x;
  end;
  tree[y].father:=x;
  tree[x].left:=y;
end;
procedure rightrotate(x:longint);
var y:longint;
begin
  y:=tree[x].father;
  tree[y].left:=tree[x].right;
  if tree[x].right<>0 then tree[tree[x].right].father:=y;
  tree[x].father:=tree[y].father;
  if tree[x].father<>0 then
  begin
    if tree[tree[y].father].left=y then tree[tree[y].father].left:=x
                                   else tree[tree[y].father].right:=x;
  end;
  tree[y].father:=x;
  tree[x].right:=y;
end;
procedure splay(now:longint);
var t:longint;
begin
  while tree[now].father<>0 do
  begin
    t:=tree[now].father;
    if tree[t].father=0 then
    begin
      if tree[t].left=now then rightrotate(now) else leftrotate(now);
      break;
    end;
    if now=tree[t].left then
        begin
          if t=tree[tree[t].father].left then
            begin rightrotate(t); rightrotate(now); end
          else
            begin rightrotate(now); leftrotate(now); end;
        end
      else
        begin
          if t=tree[tree[t].father].right then
            begin leftrotate(t); leftrotate(now); end
          else
            begin leftrotate(now); rightrotate(now); end;
        end;
  end;
  root:=now;
end;
procedure insert;
var t:longint;
begin
  t:=root;   same:=now;
  while true do
  begin
    if tree[t].data=tree[now].data then
    begin min:=0; same:=t; exit; end;
    if tree[t].data>tree[now].data then
      begin
        if tree[t].left=0 then
        begin tree[now].father:=t; tree[t].left:=now; exit; end
        else t:=tree[t].left;
      end
    else
      begin
        if tree[t].right=0 then
        begin tree[now].father:=t; tree[t].right:=now; exit; end
        else t:=tree[t].right;
      end;
  end;
end;
procedure findprev;
begin
  prev:=tree[now].left;
  while prev<>0 do
  begin
    if tree[prev].right=0 then exit;
    prev:=tree[prev].right;
  end;
end;
procedure findnext;
begin
  next:=tree[now].right;
  while next<>0 do
  begin
    if tree[next].left=0 then exit;
    next:=tree[next].left;
  end;
end;
procedure work;
begin
  read(tree[now].data);
  min:=maxlongint;
  insert;
  splay(same);
  if min>0 then
  begin
    findprev;
    findnext;
    if (next<>0)and((prev=0)or
    (tree[next].data-tree[now].data<tree[now].data-tree[prev].data))
    then min:=tree[next].data-tree[now].data
    else min:=tree[now].data-tree[prev].data;
  end;
  ans:=ans+min;
end;
begin
  init;
  for now:=2 to n do  work;
  writeln(ans);
end.
```

---

## 作者：Starria的脑残粉 (赞：3)

没有树状数组的题解的话那就让我来写一个吧。。

优点：码量短，适合不会stl的蒟蒻选手。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,sum,ans,f1[5000000],f2[5000000];
int read(){
    char c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();
    int k=1,kk=0;if (c=='-')k=-1;else kk=c-'0';c=getchar();
    while (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;
}void putit1(int x){for (int i=x;i<=3000000;i+=i&(-i))f1[i]=max(f1[i],x);}
void putit2(int x){for (int i=x;i<=3000000;i+=i&(-i))f2[i]=max(f2[i],x);}
int findit1(int x){int ans=-1e9;for (;x;x-=x&(-x))ans=max(ans,f1[x]);return ans;}
int findit2(int x){int ans=-1e9;for (;x;x-=x&(-x))ans=max(ans,f2[x]);return ans;}
signed main(){
    memset(f1,200,sizeof(f1));memset(f2,200,sizeof(f2));//最小值不一定是0所以要初始化（我被坑了
    n=read();ans=read();putit1(ans+1500000);putit2(1500000-ans);
    for (int i=2;i<=n;i++){
        x=read()+1500000;sum=x-findit1(x);putit1(x);//在小于x的元素中找最大的
        x=3000000-x;sum=min(sum,x-findit2(x));putit2(x);//在大于x的元素中找最小的
        ans+=sum;
    }cout<<ans<<endl;
}
```

---

## 作者：HxDlBbCo877 (赞：2)

#### 题意简述
设 $f(j)=\min_{i=1}^{j-1}\{|x_j-x_i|\}$，求 $\sum_{i=1}^{n}f(i)$，特别的，$f(1)=x_1$。

对于绝对值，尝试分类讨论。
$$\text{1. 若 }x_j \ge x_i\text{,}$$
$$
\begin{aligned}
f(j) &= \min_{i=1}^{j-1} \{ x_j - x_i \}  \\
&= x_j - \max_{i=1}^{j-1} \{ x_i \}   \\ \\
\end{aligned}
$$
$$\text{2. 若 }x_j \le x_i\text{,}$$
$$
\begin{aligned}
f(j) &= \min_{i=1}^{j-1} \{ x_i - x_j \}  \\
&= - x_j - \max_{i=1}^{j-1} \{ - x_i \}   \\
\end{aligned}
$$
$$\text{设 }x'=-x,\text{则条件变成若 }x'_j \ge x'_i  $$
$$f(j)=x'_j-\max_{i=1}^{j-1}\{ x'_i\}$$
$$\text{与 1. 形式一致}$$
现在考虑怎么维护比第 $j$ 个数早出现且小于等于 $x_j$ 的第一个数。  
这是一个很二维偏序的式子（$i<j$ 且 $x_i\le x_j$），所以可以用 CDQ 分治 解决。


复杂度 $T(n)=2T(\dfrac{n}{2})+O(n)=O(n\log{n})$
```cpp
#include <iostream>
using namespace std;
const int N=32768;
const int INF=1<<30;
inline int read()
{
	int x=0;bool w=0;char ch=0; 
	while(ch<'0'|ch>'9'){w|=(ch=='-');ch=getchar();}
	while(ch>='0'&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return w?-x:x;
}
struct cdq{int x,tag;}p[N],q[N],tmp[N];int ans[N];
void solve(int l,int r,cdq*a)
{
	if(l==r)return;int i=l,m=l+r>>1,j=m+1,tot=l,maxn=-INF;solve(l,m,a);solve(m+1,r,a);
	while(i<=m&j<=r)
	{
		if(a[i].x<=a[j].x)maxn=a[i].x,tmp[tot++]=a[i++];
		else ans[a[j].tag]=min(ans[a[j].tag],a[j].x-maxn),tmp[tot++]=a[j++];
	}
	while(i<=m)tmp[tot++]=a[i++];
	while(j<=r)ans[a[j].tag]=min(ans[a[j].tag],a[j].x-maxn),tmp[tot++]=a[j++];
	for(i=l;i<=r;i++)a[i]=tmp[i];
}
int main()
{
	int n=read(),sum=0;
	for(int i=1;i<=n;i++)ans[i]=INF,p[i].tag=q[i].tag=i,p[i].x=read(),q[i].x=-p[i].x;
	ans[1]=p[1].x;
	solve(1,n,p);solve(1,n,q);
	for(int i=1;i<=n;i++)sum+=ans[i];
	cout<<sum;
	return 0;
}
```
##### [${\color{#66ccff}双倍经验}$](https://www.luogu.com.cn/problem/P4169)

---

## 作者：山水一程_ (赞：2)

### 看到最小波动值,所以我们可以很自然的想到二叉排序树,最小波动值就是第i天所在节点的值和前驱后缀的min值。

### 但是继续看一下数据,如果只是普通的二叉排序树是不稳定的,很容易超时,所以我们就用splay平衡树啦,可以把二叉排序树的时间复杂度稳定在n(log(n))这道题就解决了。

## 下面是我的程序,稍稍带点优化
```cpp
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;
int sum=0,root,flag;
struct node {
	int l,r,fa,data;
} tree[1000010];
void right(int x) {  //右旋
	int y,z;
	y=tree[x].fa;
	z=tree[y].fa;
	tree[y].l=tree[x].r;
	if (tree[x].r)
		tree[tree[x].r].fa=y;
	tree[x].fa=z;
	if (tree[z].l == y && z) tree[z].l=x;
	else if (tree[z].r == y && z) tree[z].r=x;
	tree[y].fa=x;
	tree[x].r=y;
}
void left(int x) {  //左旋
	int y,z;
	y=tree[x].fa;
	z=tree[y].fa;
	tree[y].r=tree[x].l;
	if (tree[x].l)
		tree[tree[x].l].fa=y;
	tree[x].fa=z;
	if (tree[z].l == y && z) tree[z].l=x;
	else if (tree[z].r == y && z) tree[z].r=x;
	tree[x].l=y;
	tree[y].fa=x;
}
void splay(int x) {
	while (tree[x].fa) {
		int y,z;
		y=tree[x].fa;
		z=tree[y].fa;
		if (!z) {
			if (tree[y].l==x)
				right(x);
			else if (tree[y].r==x)
				left(x);
		} else {
			if (tree[z].l==y && tree[y].l==x) {
				right(y);
				right(x);
			}
			if (tree[z].r==y && tree[y].r==x) {
				left(y);
				left(x);
			}
			if (tree[z].l==y && tree[y].r==x) {
				left(x);
				right(x);
			}
			if (tree[z].r==y && tree[y].l==x) {
				right(x);
				left(x);
			}
		}
	}
	root=x;
}
int qq(int x) {    //求前驱
	int y=tree[x].l;
	if (!y) return y;
	while (tree[y].r) y=tree[y].r;
	return y;
}
int hj(int x) {  //求后缀
	int y=tree[x].r;
	if (!y) return y;
	while (tree[y].l) y=tree[y].l;
	return y;
}
void BST(int rt,int x) {
	if (tree[rt].data==tree[x].data) {     //因为是求最小波动值,那么如果这个值已经进入过了树中,就可以直接在tr节点开始splay了
		flag=1;
		splay(rt);
		return;
	} else if (tree[x].data > tree[rt].data) {
		if (!tree[rt].r) {
			tree[rt].r=x;
			tree[x].fa=rt;
		} else BST(tree[rt].r,x);
	} else {
		if (!tree[rt].l) {
			tree[rt].l=x;
			tree[x].fa=rt;
		} else BST(tree[rt].l,x);
	}
}
void insert(int x) {
	flag=0;
	BST(root,x);
	if (flag) return;
	splay(x);
	int q,h,minx=2000000002;
	q=qq(x);
	h=hj(x);
	if (q)
		minx=min(minx,abs(tree[x].data-tree[q].data));
	if (h)
		minx=min(minx,abs(tree[x].data-tree[h].data));
	sum += minx;
}
int main() {
	int n;
	scanf("%d",&n);
	scanf("%d",&tree[1].data);
	sum+=tree[1].data;
	root=1;
	for (int i=2; i<=n; i++) {
		scanf("%d",&tree[i].data);
		insert(i);
	}
	printf("%d",sum);
	return 0;
}
```


---

## 作者：安好 (赞：2)

没有线段树题解  来一发权值线段树

建好树后，先离散化再插点询问前驱后继即可









```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x3f3f3f3f
#define N 40000
using namespace std;
struct tree
{
    int l,r,mx,mn,sum;
}tr[N<<2];
int n,m,ans,tot,cnt;
int a[N],b[N],val[N],num[N];
inline void pushup(int k)
{
    tr[k].sum=tr[k<<1].sum+tr[k<<1|1].sum;
    if(tr[k].sum)
    {
      tr[k].mn=min(tr[k<<1].mn,tr[k<<1|1].mn);
      tr[k].mx=max(tr[k<<1].mx,tr[k<<1|1].mx);
    } 
}
void build(int k,int l,int r)
{
    tr[k].l=l;tr[k].r=r;tr[k].mn=inf;tr[k].mx=0;
    if(l==r)
    {
        tr[k].sum=0;
        return;
    }
    int mid=(l+r)>>1;
    build(k<<1,l,mid);build(k<<1|1,mid+1,r);
}
void insert(int k,int pos)
{
    if(tr[k].l==tr[k].r && tr[k].l==pos)
    {
        tr[k].sum++;
        tr[k].mn=tr[k].mx=pos;
        return;
    }
    int mid=(tr[k].l+tr[k].r)>>1;
    if(pos<=mid) insert(k<<1,pos);
    if(pos>mid)insert(k<<1|1,pos);
    pushup(k);
}
int query(int k,int l,int r,int flag)
{
    if(tr[k].l==l && tr[k].r==r)
      return flag==1?tr[k].mn:tr[k].mx;
    pushup(k);
    int mid=(tr[k].r+tr[k].l)>>1;
    if(l>mid) return query(k<<1|1,l,r,flag);
    else if(r<=mid) return query(k<<1,l,r,flag);
    else
    {
        if(flag==1) return min(query(k<<1,l,mid,flag),query(k<<1|1,mid+1,r,flag));
        else return max(query(k<<1,l,mid,flag),query(k<<1|1,mid+1,r,flag));
    }
}
int main()
{
    scanf("%d",&n);memset(val,127,sizeof val);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        b[i]=a[i];val[i]=a[i];
    }
    sort(b+1,b+n+1);
    tot=unique(b+1,b+n+1)-b-1;
    for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+tot+1,a[i])-b,num[a[i]]=i;
    build(1,1,tot);ans=val[1];insert(1,a[1]);
    for(int i=2;i<=n;i++)
    {
        int q=query(1,1,a[i],0);
        int h=query(1,a[i],tot,1);
        if(h==inf)ans+=abs(val[num[a[i]]]-val[num[q]]);
        else ans+=min(abs((val[num[a[i]]]-val[num[q]])),abs((val[num[h]]-val[num[a[i]]])));
        insert(1,a[i]);
    }
    printf("%d\n",ans);
}
```

---

## 作者：用户已注销 (赞：2)


大多数题解写的都是Splay、STLset等平衡树，这里介绍一种特别优美的数据结构：无旋转Treap

优点：

1、简短好写，好调，平衡树新手（比如我）易于上手。

2、支持区间操作，支持可持久化。

唯一缺点：略慢于Splay和Treap（常数合理的话，也不会慢特别多）。

**（所以我普通平衡树和文艺平衡树都是用无旋Treap水过去的~）**

传送门：

[P3369 【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369)

[P3391 【模板】文艺平衡树](https://www.luogu.org/problemnew/show/P3391)

本题比较裸：查找已有元素中最近的元素，显然这个元素不是前驱就是后继。于是写一个平衡树来维护这个序列，支持插入和前驱后继。

于是很开心的写了一篇无旋Treap，稍微改一改查后继就可以支持判断是否存在相同元素啦~

小细节：插入一个INF和一个-INF来避免查到一些不存在的元素。

代码：

```cpp
#include <cstdio>
#include <cstring>

using namespace std ;

const int MaxN = 32800 ;

int Seed = 12345678 ;
inline int Rand() {
	return Seed ^= Seed << 5 ^ Seed >> 5 ;
}

struct NoRotateTreap {
	
	int Pos[MaxN] , Val[MaxN] , Ls[MaxN] , Rs[MaxN] , Size[MaxN] , Cnt , Root , X , Y , Z , Ans ;
	inline void Clear() {
		Cnt = Root = 0 ;
		memset( Ls , 0 , sizeof( Ls ) ) ;
		memset( Rs , 0 , sizeof( Rs ) ) ;
	}
	inline int New( int V ) {
		Pos[++Cnt] = Rand() ;
		Size[Cnt] = 1 ;
		Val[Cnt] = V ;
		return Cnt ;
	}
	inline int Update( int Nod ) {
		Size[Nod] = Size[Ls[Nod]] + Size[Rs[Nod]] + 1 ;
	}
	int Merge( int A , int B ) {
		if( not ( A and B ) ) return A ^ B ;
		if( Pos[A] < Pos[B] ) {
			Rs[A] = Merge( Rs[A] , B ) ;
			Update( A ) ;
			return A ;
		}
		else {
			Ls[B] = Merge( A , Ls[B] ) ;
			Update( B ) ;
			return B ;
		}
	}
	void Split( int Nod , int K , int &A , int &B ) {
		if( not Nod ) {
			A = B = 0 ;
			return ;
		}
		if( Val[Nod] <= K ) {
			A = Nod ;
			Split( Rs[Nod] , K , Rs[Nod] , B ) ;
		}
		else {
			B = Nod ;
			Split( Ls[Nod] , K , A , Ls[Nod] ) ;
		}
		Update( Nod ) ;
	}
	inline int Kth( int Nod , int K ) {
		while( 1 ) {
			if( K <= Size[Ls[Nod]] ) Nod = Ls[Nod] ;
			else {
				if( K == Size[Ls[Nod]] + 1 ) return Val[Nod] ;
				K -= Size[Ls[Nod]] + 1 ;
				Nod = Rs[Nod] ;
			}
		}
	}
	inline int Last( int Num ) {
		Split( Root , Num - 1 , X , Y ) ;
		Ans = Kth( X , Size[X] ) ;
		Root = Merge( X , Y ) ;
		return Ans ;
	}
	inline int Next( int Num ) { // 同时查找是否存在相等的元素 
		Split( Root , Num , X , Y ) ;
		Split( X , Num - 1 , X , Z ) ;
		Ans = Size[Z] ? Num : Kth( Y , 1 ) ;
		Root = Merge( Merge( X , Z ) , Y ) ;
		return Ans ;
	}
	inline void Insert( int Num ) {
		Split( Root , Num , X , Y ) ;
		Root = Merge( Merge( X , New( Num ) ) , Y ) ;
	}
	
} T ;

int N , X ;

inline int Abs( int A ) { return A < 0 ? -A : A ; }
inline int Min( int A , int B ) { return A < B ? A : B ; }
int Totans ;

int main() {
	
	scanf( "%d%d" , &N , &Totans ) ;
	T.Clear() ;
	T.Insert( Totans ) ;
	T.Insert( 3333333 ) ;
	T.Insert( -3333333 ) ;
	for(register int i = 1 ; ++i <= N ; ) {
		scanf( "%d" , &X ) ;
		Totans += Min( Abs( T.Last( X ) - X ) , Abs( T.Next( X ) - X ) ) ;
		T.Insert( X ) ;
	}
	return not printf( "%d\n" , Totans ) ;
	
}
```

---

## 作者：qscqesze_lca (赞：2)

/\*
noip做累了 刷一道splay吧！！

前一位的splay太麻烦 其实不必那么麻烦 详细看代码注释吧 十分详细了 不懂得也可以来问我！

这次什么方法都可以用SBT可以 segment\_tree也可以 但是我用的是splay

废话不说直接开始打splay（虽然这是treap专题） 二叉查找树 zig zag zig\_zig zag\_zag zig\_zag zag\_zig

\*/
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100001;
const int INF=1<<29;
int fa[maxn];
int key[maxn];
int child[maxn][2];//左右孩子
int root;
int rootsum;
int n;
void build(int &i,int fa1,int key1){//新建一个节点
    rootsum++; 
    i=rootsum;
    fa[i]=fa1;
    key[i]=key1;
    child[i][0]=0;
    child[i][1]=0;//empty
} 
void rotate(int i,int kind){//just like a sbt //滑稽 旋转操作  0 left 1 right
    int j=fa[i];
    child[j][!kind]=child[i][kind];
    fa[child[i][kind]]=j;//分支给父节点
    if(fa[j]){
        child[fa[j]][child[fa[j]][1]==j]=i;
    } 
    fa[i]=fa[j];
    child[i][kind]=j;
    fa[j]=i;
}
void splay(int i,int goal){//将根为i的子树调整为goal 
    while(fa[i]!=goal){
        if(fa[fa[i]]==goal){//goal为0 父节点就是根结点  
            rotate(i,child[fa[i]][0]==i);
        }
        else{
            int j=fa[i];
            int kind=child[fa[j]][0]==j;
            if(child[j][kind]==i){//两个方向不同 左旋再右旋  
                rotate(i,!kind);
                rotate(i,kind);
            }
            else{//两个方向相同 连续两次  
                rotate(j,kind);
                rotate(i,kind);
            }
        }
    } 
    if(goal==0){//更新根节点 
        root=i;
    } 
}
int insert(int num){
    int i=root;
    while(child[i][key[i]<num]){
        if(key[i]==num){//不重复
            splay(i,0);
            return 0;
        }
        i=child[i][key[i]<num];
    }
    build(child[i][num>key[i]],i,num);//更新
    splay(child[i][num>key[i]],0);
    return 1;
} 
int find_left_rightest(int i){//左子树的最右结点 
    int j=child[i][0];
    if(j==0){
        return INF;
    } 
    while(child[j][1]){
        j=child[j][1];
    }
    return key[i]-key[j];
}
int find_right_leftest(int i){//右子树的最左结点  
    int j=child[i][1];
    if(j==0){
        return INF;
    } 
    while(child[j][0]){
        j=child[j][0];
    }
    return key[j]-key[i];
}
int main(){
    while(scanf("%d",&n)!=EOF){
        root=0;
        rootsum=0;
        int ans=0;
        for(int i=1;i<=n;i++){
            int num;
            if(scanf("%d",&num)==EOF){
                num=0;
            }
            if(i==1){
                ans+=num;
                build(root,0,num);
                continue;
            }
            if(insert(num)==0){
                continue;
            }
            int a,b;
            a=find_left_rightest(root);
            b=find_right_leftest(root);
            ans+=min(a,b);
        }
        printf("%d\n",ans);
    }
}
```

---

## 作者：Treaker (赞：1)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 平衡树
这个题显然是个平衡树的题。当然是用Splay了

那么要求我们支持什么操作呢？

查询最小波动值。。

我们只需要把前驱和后继都求出来，看哪个离得近就是哪个，统计答案，再把这个数insert进去就行了。

这里我出了一些锅，那个inf如果太大的话，会爆int，然后出负，答案就不对了。把inf设小一些就可以了。。。

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int inf = 1147483647;
inline int read()
{
    int x = 0 , f = 1;  char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-')  f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * f;
}
struct Splay
{
	struct node
	{
		node *ch[2] , *fa;
		int val , size;
		node(node *fa = NULL,int val = 0) : fa(fa) , val(val) {ch[0] = ch[1] = NULL;size = 1;}
		inline bool isr() {return this == fa -> ch[1];}
		inline int rk() {return 1 + (ch[0] ? ch[0] -> size : 0);}
		inline void up() {size = 1 +(ch[0] ? ch[0] -> size : 0) + (ch[1] ? ch[1] -> size : 0);}
	}*root;
	Splay() {root = NULL;}
	inline void rot(node *x)
	{
		bool k = x -> isr();
		node *y = x -> fa , *z = y -> fa , *w = x -> ch[!k];
		if(root == y) root = x;
		else z -> ch[y -> isr()] = x;
		x -> fa = z; y -> fa = x;
		x -> ch[!k] = y; y -> ch[k] = w;
		if(w) w -> fa = y;
		y -> up(); x -> up();
	}
	inline void splay(node *x)
	{
		while(x != root)
		{
			if(x -> fa != root) rot(x -> isr() ^ x -> fa -> isr() ? x : x -> fa);
			rot(x);
		}
	}
	inline void insert(int val)
	{
		if(!root) return (void)(root = new node(NULL,val));
		node *p = root , *fa = NULL;
		while(p)
		{
			fa = p;
			p = p -> ch[val > p -> val];
		}
		p = new node(fa,val);
		fa -> ch[val > fa -> val] = p;
		splay(p);
	}
	inline int pre(int val)
	{
		node *p = root , *lst = NULL;
		while(p)
		{
			if(val > p -> val) lst = p , p = p -> ch[1];
			else p = p -> ch[0];
		}
		if(lst) return splay(lst) , lst -> val;
		return -inf;
	}
	inline int nxt(int val)
	{
		node *p = root , *lst = NULL;
		while(p)
		{
			if(val < p -> val) lst = p , p = p -> ch[0];
			else p = p -> ch[1];
		}
		if(lst) return splay(lst) , lst -> val;
		return inf;
	}
	inline void LOL()
	{
		int n = read() , ans = 0;
		for(int i = 1 , x;i <= n;i ++)
		{
			x = read();
			if(i == 1) ans += x;
			else ans += min(x - pre(x+1),nxt(x-1) - x);
			insert(x);
		}
		printf("%d\n",ans);
	}
}DNF;
int main()
{
	DNF.LOL();
	return 0;
}

```


---

## 作者：yzhang (赞：1)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9959886.html)

### 平衡树板题

### [原题传送门](https://www.luogu.org/problemnew/show/P2234)

### 这道题要用Splay，我博客里有[对Splay的详细介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9957906.html)

这道题目还算比较模板的

每输入一个数，**先不要插入**

要求一下前驱和后继与x差的最小值并加到答案中

再把x插入平衡树

**然后你会发现过不了样例**

发现相同的数字是会有的

所以还要写find函数，要多加一个变量来比最小：

```cpp
find(x)!=0?0:inf;
```

剩下就没什么问题了qaq

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define root tree[0].ch[1]
#define inf 1000000005
using namespace std;
inline int read()
{
	register int x=0,f=1;register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
inline int Min(register int a,register int b)
{
	return a<b?a:b;
}
struct Splay{
	int fa,ch[2],sum,rec,v;
}tree[32780];
int tot=0;
inline bool findd(register int x)
{
	return x==tree[tree[x].fa].ch[0]?0:1;
}
inline void connect(register int x,register int fa,register int son)
{
	tree[x].fa=fa;
	tree[fa].ch[son]=x;
}
inline void update(register int x)
{
	tree[x].sum=tree[tree[x].ch[0]].sum+tree[tree[x].ch[1]].sum+tree[x].rec;
}
inline void rotate(register int x)
{
	int Y=tree[x].fa;
	int R=tree[Y].fa;
	int Yson=findd(x);
	int Rson=findd(Y);
	int B=tree[x].ch[Yson^1];
	connect(B,Y,Yson);
	connect(Y,x,Yson^1);
	connect(x,R,Rson);
	update(Y),update(x);
}
inline void splay(register int x,register int to)
{
	to=tree[to].fa;
	while(tree[x].fa!=to)
	{
		int y=tree[x].fa;
		if(tree[y].fa==to)
			rotate(x);
		else if(findd(x)==findd(y))
			rotate(y),rotate(x);
		else
			rotate(x),rotate(x);
	}
}
inline int newpoint(register int v,register int fa)
{
	tree[++tot].v=v;
	tree[tot].fa=fa;
	tree[tot].sum=tree[tot].rec=1;
	return tot;
}
inline void Insert(register int x)
{
	int now=root;
	if(root==0)	
	{
		newpoint(x,0);
		root=tot;
	}
	else
	{
		while(19260817)
		{
			++tree[now].sum;
			if(x==tree[now].v)
			{
				++tree[now].rec;
				splay(now,root);
				return;
			}
			int nxt=x<tree[now].v?0:1;
			if(!tree[now].ch[nxt])
			{
				int p=newpoint(x,now);
				tree[now].ch[nxt]=p;
				splay(p,root);
				return;
			}
			now=tree[now].ch[nxt];
		}
	}
}
inline int find(register int v)
{
	int now=root;
	while(19260817)
	{
		if(tree[now].v==v)
		{
			splay(now,root);
			return now;
		}
		int nxt=v<tree[now].v?0:1;
		if(!tree[now].ch[nxt])
			return 0;
		now=tree[now].ch[nxt];
	}
}
inline int lower(register int v)
{
	int now=root;
	int ans=-inf;
	while(now)
	{
		if(tree[now].v<v&&tree[now].v>ans)
			ans=tree[now].v;
		if(v>tree[now].v)
			now=tree[now].ch[1];
		else
			now=tree[now].ch[0];
	}
	return ans;
}
inline int upper(register int v)
{
	int now=root;
	int ans=inf;
	while(now)
	{
		if(tree[now].v>v&&tree[now].v<ans)
			ans=tree[now].v;
		if(v<tree[now].v)
			now=tree[now].ch[0];
		else
			now=tree[now].ch[1];
	}
	return ans;
}
int main()
{
	int n=read();
	int res=0;
	for(register int i=1;i<=n;++i)
	{
		int x=read();
		if(i==1)
			res=x;
		else
			res+=Min(Min(fabs(lower(x)-x),fabs(upper(x)-x)),find(x)!=0?0:inf);
		Insert(x);
	}
	printf("%d",res);
	return 0;
 } 
```


---

## 作者：bztMinamoto (赞：1)

闲着没事发篇题解

正好在学splay，这题可以用splay很快地解决，基本可以算是模板了

打个splay的模板，对于每一天的值，我们找出它的前缀和后继，然后比较两个相减的abs谁大就好了

ps：求前缀和后继时记得是大于等于和小于等于

pps：不懂splay的可以去做做模板，很有用的

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int N=40050,INF=0x3f3f3f3f;
int ans=0;
inline int read(){
	#define num ch-'0'
	char ch;bool flag=0;int res;
	while(!isdigit(ch=getchar()))
	(ch=='-')&&(flag=true);
	for(res=num;isdigit(ch=getchar());res=res*10+num);
	(flag)&&(res=-res);
	#undef num
	return res;
}
inline void print(int x) {
    if(!x) {
        putchar(48);
        return;
    }
    if(x<0) putchar('-'),x=-x;
    int l=0,wt[30];
    while(x) wt[++l]=x%10,x/=10;
    while(l) putchar(wt[l--]+48);
}
struct Splay{
    struct node{
        int v,father,ch[2];
        int sum,recy;
    } e[N];
    int n,root;
    inline void update(int x){
        e[x].sum=e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].recy;
    }
    inline int identify(int x){
        return e[e[x].father].ch[1]==x;
    }
    inline void connect(int x,int f,int son){
        e[x].father=f,e[f].ch[son]=x;
    }
    inline void rotate(int x){
        int y=e[x].father,z=e[y].father;
        int yson=identify(x),zson=identify(y);
        int b=e[x].ch[yson^1];
        connect(b,y,yson),connect(y,x,(yson^1)),connect(x,z,zson);
        update(y),update(x);
    }
    inline void splay(int x,int goal){
        while(e[x].father!=goal){
            int y=e[x].father,z=e[y].father;
            if(z!=goal)
            (identify(x)^identify(y))?rotate(x):rotate(y);
            rotate(x);
        }
        if(goal==0) root=x;
    }
    inline void push(int v){
        int now=root,f=0;
        while(now&&e[now].v!=v){
            f=now;
            now=e[now].ch[v>e[now].v];
        }
        if(now) e[now].recy++;
        else{
            now=++n;
            if(f) e[f].ch[v>e[f].v]=now;
            e[n].ch[0]=e[n].ch[1]=0;
            e[n].father=f,e[n].v=v;
            e[n].recy=e[n].sum=1;
        }
        splay(now,0);
    }
    inline void find(int v){
        int now=root;
        if(!now) return;
        while(e[now].ch[v>e[now].v]&&v!=e[now].v)
        now=e[now].ch[v>e[now].v];
        splay(now,0);
    }
    inline int Next(int v,int f){
        find(v);
        int now=root;
        if((e[now].v>=v&&f)||(e[now].v<=v&&!f)) return e[now].v;
        now=e[now].ch[f];
        while(e[now].ch[f^1]) now=e[now].ch[f^1];
        return e[now].v;
    }
    inline int get(int v){
    	int lower=Next(v,0);
    	int upper=Next(v,1);
    	push(v);
    	return min(abs(lower-v),abs(upper-v));
	}
    Splay(){n=root=0;push(INF),push(-INF);}
}F;
int n;
int main(){
    n=read();ans+=read(),F.push(ans);n--;
    while(n--) ans+=F.get(read());
    print(ans);
    return 0;
}
```

---

## 作者：huangjunqi1 (赞：1)

###  splay

这道题用普通的二叉搜索树做肯定会超时，所以可以建一棵平衡树。我是用splay做的。

输入第一个数是特判，并将ans赋成这个值。接下来每输入一个数，都寻找这个数的前驱与后继，并取离这个数最近的一个。查找完后，将这个数插入到树中。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int fa[100000],left[100000],right[100000],pre,su,num,root,tree[100000];
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],l,r,y1;
    if (left[y]==x) l=0;
    else l=1;
    r=l^1;
    if (y==k) k=x;
    else
    {
        if (left[z]==y) left[z]=x;
        else right[z]=x;
    }
    fa[x]=z,fa[y]=x;
    if (r) fa[right[x]]=y,y1=right[x];
    else fa[left[x]]=y,y1=left[x];
    if (l) right[y]=y1;
    else left[y]=y1;
    if (r) right[x]=y;
    else left[x]=y; 
    
}
void splay(int x,int &k)
{
    while (x!=k)
    {
        int y=fa[x],z=fa[y];
        if (y!=k)
            if ((left[y]==x)^(left[z]==y))
                rotate(x,k);
            else rotate(y,k);
        rotate(x,k);
    }
}
void insert(int key,int &k,int father)
{
    if (!k) 
    {
        fa[++num]=father;
        tree[num]=key;
        k=num;
        splay(k,root);
        return;
    }
    if (key>=tree[k])
        insert(key,right[k],k);
    else insert(key,left[k],k);
}
void prev(int k,int key)
{
    if (!k) return;
    if (tree[k]<=key)
    {
        pre=k;
        prev(right[k],key);
    }
    else prev(left[k],key);
}
void sub(int k,int key)
{
    if (!k) return;
    if (tree[k]>=key)
    {
        su=k;
        sub(left[k],key);
    }
    else sub(right[k],key);
}
int main()
{
    int n;
    scanf("%d",&n);
        memset(left,0,sizeof(left));
        memset(right,0,sizeof(right));
        memset(tree,0,sizeof(tree));
        memset(fa,0,sizeof(fa));
        int a;
        scanf("%d",&a);
        int ans=a;
        root=num=0;
        insert(a,root,0);
        for (int i=2;i<=n;i++)
        {
            int a1;
            scanf("%d",&a1);
            prev(root,a1);
            sub(root,a1);
            int sum;
            if (!pre) 
            {sum=abs(tree[su]-a1);splay(su,root);}
            else if (!su) {sum=abs(tree[pre]-a1),splay(pre,root);}
            else 
{
sum=min(abs(tree[su]-a1),abs(tree[pre]-a1));
splay(su,root);
splay(pre,root);
}//这里找完后一定要把这个点转到根.
            ans+=sum;
            insert(a1,root,0); 
        }
        printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Wei_taming (赞：1)

善用三目运算符，你的平衡树也能变得像我一样短。
本题平衡树只要支持插入和查找前驱后继即可，我使用的是fhqTreap，
细节上在找前驱和后继时不再去找严格的前驱后继，也就是让他能找到和自己一样的数，加快读的话要判负数。

下面是~~毒瘤~~代码

```cpp
#include <cstdio>
#include <cctype>
#include <ctime>
#include <cstdlib>
#include <algorithm>

#define N 50010

inline int read()
{
	register char c; register int x; register bool f = false;
	while(!isdigit(c = getchar()))if(c == '-')f = true; x = c ^ 48;
	while(isdigit(c = getchar()))x = (x << 1) + (x << 3) + (c ^ 48);
	return f ? -x : x;
}

int root, cnt;
int k[N], rd[N], size[N], l[N], r[N];
int x, y, z, ans;

inline void update(int n)
{
	size[n] = (l[n] ? size[l[n]] : 0) + (r[n] ? size[r[n]] : 0) + 1;
}

inline int newnode(int key)
{
	return k[++ cnt] = key, rd[cnt] = rand(), size[cnt] = 1, l[cnt] = 0, r[cnt] = 0, cnt;
}

int split(int n, int key)
{
	return (!n) ? (x = y = 0) : (k[n] >= key ? (split(l[n], key), l[n] = y, update(y = n), 1) : (split(r[n], key), r[n] = x, update(x = n), 1));
}

int merge(int a, int b)
{
	return (!a || !b) ? (a + b) : (rd[a] <= rd[b] ? (r[a] = merge(r[a], b), update(a), a) : (l[b] = merge(a, l[b]), update(b), b));
}

inline void insert(int key)
{
	split(root, key), root = merge(merge(x, newnode(key)), y);
}

inline int minn(int n)
{
	return l[n] ? minn(l[n]) : k[n];
}

inline int maxn(int n)
{
	return r[n] ? maxn(r[n]) : k[n];
}

inline int lower(int key)
{
	return split(root, key), ans = x ? maxn(x) : -0x7fffffff, root = merge(x, y), ans;
}

inline int upper(int key)
{
	return split(root, key), ans = y ? minn(y) : 0x7fffffff, root = merge(x, y), ans;
}

int main()
{
	srand(time(NULL));

	int n = read(), ans = read();

	insert(ans);

	for(int i = 2; i <= n; i ++)
	{
		long long w = read();
		ans += std::min(llabs(w - lower(w)), llabs(w - upper(w)));
		insert(w);
	}
	
	printf("%d", ans);
	
	return 0;
}
```

---

## 作者：木木！ (赞：0)

这题可以排序，然后为保证均摊$\Theta(n)$以下的复杂度，可以使用单调队列。

总时间复杂度$\Theta(nlogn)$，瓶颈在排序。

实际上，可以使用基数排序将时间降到$\Theta(n+|ai|)$，然而似乎变慢了……

或者使用桶排将时间复杂度降到$\Theta(n)$，但是意（已）义（经）不（能）大（过）

附代码（STL排序版）

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

inline void chkmin(int& a,int b)
{
	if(a>b)
	{
		a = b;
	}
}

struct dt
{
	int num;
	int id;
};

dt di[35005];

bool cmp(dt a,dt b)
{
	return a.num<b.num;
}

int q[35005];
int mind[35005];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",&di[i].num);
		di[i].id = i;
		mind[i] = 0x7f7f7f7f;
	}
	mind[1] = di[1].num;
	
	sort(di+1,di+1+n,cmp);
	
	int head = 0;
	for(int i=1; i<=n; ++i)
	{
		while(head && di[q[head]].id>di[i].id)
		{
			--head;
		}
		if(head)
		{
			chkmin(mind[di[i].id],di[i].num-di[q[head]].num);
		}
		++head;
		q[head] = i;
	}
	
	head = 0;
	for(int i=n; i>=1; --i)
	{
		while(head && di[q[head]].id>di[i].id)
		{
			--head;
		}
		if(head)
		{
			chkmin(mind[di[i].id],di[q[head]].num-di[i].num);
		}
		++head;
		q[head] = i;
	}
	
	int ans = 0;
	for(int i=1; i<=n; ++i)
	{
		ans += mind[i];
	}
	
	printf("%d",ans);
}
```

（大佬来写的话可能只要50行）

---

## 作者：AmadeusSG (赞：0)

我绝对是Splay的受害者。

代码丑长不说，还特容易毒瘤（身后有一段不得不说的故事）

但还是写出来了呵呵呵...

那就发一发吧

```
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int n,root,tot,ans;
struct TREE {
	int lc,rc;
	int ln,rn;
	int fa,data;
} t[40000];
void zig(int x) {
	int y=t[x].fa;
	t[y].lc=t[x].rc;
	if(t[x].rc)t[t[x].rc].fa=y;
	t[x].fa=t[y].fa;
	if(t[y].fa) {
		if(y==t[t[y].fa].lc)t[t[y].fa].lc=x;
		else t[t[y].fa].rc=x;
	}
	t[y].fa=x;
	t[x].rc=y;
	t[y].ln=t[x].rn;
	t[x].rn=t[y].ln+t[y].rn+1;
}
void zag(int x) {
	int y=t[x].fa;
	t[y].rc=t[x].lc;
	if(t[x].lc)t[t[x].lc].fa=y;
	t[x].fa=t[y].fa;
	if(t[y].fa) {
		if(y==t[t[y].fa].lc)t[t[y].fa].lc=x;
		else t[t[y].fa].rc=x;
	}
	t[y].fa=x;
	t[x].lc=y;
	t[y].rn=t[x].ln;
	t[x].ln=t[y].ln+t[y].rn+1;
}
void Splay(int x) {
	int p;
	while(t[x].fa) {
		p=t[x].fa;
		if(t[p].fa==0) {
			if(x==t[p].lc)zig(x);
			else zag(x);
			break;
		}
		if(x==t[p].lc) {
			if(p==t[t[p].fa].lc)zig(p),zig(x);
			else zig(x),zag(x);
		} else {
			if(p==t[t[p].fa].rc)zag(p),zag(x);
			else zag(x),zig(x);
		}
	}
	root=x;
}
int QQ() {
	int p=t[root].lc;
	while(p) {
		if(t[p].rc==0)break;
		p=t[p].rc;
	}
	if(p)return t[p].data;
	return 0x3f3f3f3f;
}
int BackMin() {
	int p=t[root].rc;
	while(p) {
		if(t[p].lc==0)break;
		p=t[p].lc;
	}
	if(p)return t[p].data;
	return 0x3f3f3f3f;
}
int add(int x) {
	int p=root,f;
	while(p) {
		f=p;
		if(x<=t[p].data) {
			t[p].ln++;
			p=t[p].lc;
		} else {
			t[p].rn++;
			p=t[p].rc;
		}
	}
	tot++;
	t[tot].data=x;
	if(root==0) {
		root=tot;
		return x;
	}
	t[tot].fa=f;
	if(x<=t[f].data)t[f].lc=tot;
	else t[f].rc=tot;
	Splay(tot);
	return min(abs(QQ()-x),abs(BackMin()-x));
}
int main() 
{
	int i,j,x;
	cin>>n;
	for(i=1; i<=n; i++) {
		cin>>x;
		ans+=add(x);
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：秋日私语 (赞：0)

[更好的阅读体验点这里](https://blog.csdn.net/A_Comme_Amour/article/details/79768870)


题目
-

[传送门](https://www.lydsy.com/JudgeOnline/problem.php?id=1588)

题解
-

比平衡树模板还要简单的板子题；
就是每次插入一个元素，求其前驱和后继即可，求差累加较小值即可；我们可以事先再平衡树中插入 -inf 和 inf；
注意元素是课重复的，cnt数组就不要用了

代码
-


```
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn=1e5;
const int inf=1e9;
int read(){
    char ch=getchar(); int now=0,f=1;
    while (ch<'0' || ch>'9') {if (ch=='-') f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9') {now=(now<<1)+(now<<3)+ch-'0'; ch=getchar();}
    return now*f;}
int n,a[maxn],f[maxn],ch[maxn][2],size[maxn],cnt[maxn],key[maxn],sz,rt;

int Abs(int x) {return x<0?-x:x;}
bool get(int x) {return ch[f[x]][1]==x;}
void clear(int x) {f[x]=ch[x][1]=ch[x][0]=size[x]=cnt[x]=key[x]=0;}
void pushup(int x)
{
	if (!x) return;
	size[x]=cnt[x]+size[ch[x][0]]+size[ch[x][1]];
}
void rotate(int x)
{
    int old=f[x],oldf=f[old],which=get(x);
    ch[old][which]=ch[x][which^1]; f[ch[x][which^1]]=old;
    ch[x][which^1]=old; f[old]=x;
    f[x]=oldf;
    if (oldf) ch[oldf][ch[oldf][1]==old] = x;
    pushup(old); pushup(x);
}

void splay(int x,int goal)
{
    for (int fa; (fa=f[x])!=goal; rotate(x))
        if (f[fa]!=goal) 
            rotate(get(x)==get(fa) ?fa:x);
    if (!goal) rt=x;
}

void insert(int x)
{
    if (rt==0)
    {
        sz++; key[sz]=x; rt=sz;
        cnt[sz]=size[sz]=1;
        f[sz]=ch[sz][1]=ch[sz][0]=0;
        return;
    }
    int now=rt,fa=0;
    while (1)
    {
        fa=now; now=ch[now][x>key[now]];
        if (now==0)
        {
            sz++; //这里不要更新rt 
            cnt[sz]=size[sz]=1;
            ch[sz][0]=ch[sz][1]=0;
            ch[fa][x>key[fa]]=sz;
            f[sz]=fa;
			key[sz]=x;
            pushup(fa); splay(sz,0); return;
        }
    }
}

int pre()
{
    int now=ch[rt][0];
    while (ch[now][1]) now=ch[now][1];
    return now;
}
int next()
{
	int now=ch[rt][1]; if (!now) return 2*inf;
	while (ch[now][0]) now=ch[now][0];
	return now;
}

int ans;
int main()
{
	n=read();
	insert(-inf); insert(inf);
	for (int i=1; i<=n; i++)
	{
		int x=read(); insert(x);
		if (i==1) {ans=x; continue;}
		int pr=key[pre()]; int nx=key[next()];
		
		int d=min(Abs(x-pr),Abs(x-nx));
		ans+=d;
	}
	printf("%d",ans);
	return 0;
}
```


总结
-
灵活使用平衡树

ps 想学习平衡树的可以看看我的blog：https://blog.csdn.net/a_comme_amour/article/details/79382104

---

## 作者：tttnns (赞：0)

STL set 可水过。维护一个set，每输入一个数lower\_bound找到第一个大于等于它的数，以及前面第一个小于它的数，求差取最小值累加

```cpp
#include<cstdio>
#include<set>
#include<cmath>
using namespace std;
void awd(){
    int n;
    scanf("%d",&n);
    int ans=0;
    set<int> s;
    while(n--){
        int t;
        scanf("%d",&t);
        if(!s.empty()){
            set<int>::const_iterator ge(s.lower_bound(t));
            set<int>::const_iterator lt(ge);
            if(ge!=s.begin())
                --lt;
            if(ge==s.end())
                --ge;
            ans+=min(abs(t-*ge),abs(t-*lt));
        }else ans+=t;
        s.insert(t);
    }
    printf("%d\n",ans);
}
int main(){
    return awd(),0;
}
```

---

## 作者：Vasily (赞：0)

平衡树才是正解好咩2333

Splay Tree代码：

有注释，请忽略读入优化2333，不知道要不要long long呗2333

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <set>
#include <cmath>
#include <algorithm>
#include <ctime>
#define ll long long
using namespace std ;
const ll zhf = 1e7 ;
const ll maxn = 50010 ;
bool Read ( ll &x ) {  // 读入优化
    bool f = 0 ; x = 0 ; char c = getchar() ;
    while ( !isdigit(c) ) {
        if ( c == '-' ) f = 1 ;
        if ( c == EOF ) return false ;
        c = getchar() ;
    }
    while ( isdigit(c) ) {
        x = 10 * x + c - '0' ;
        c = getchar() ;
    }
    if ( f ) x = -x ;
    return true ;
}
ll n, m, ch[maxn][2], fa[maxn], root, cnt, val[maxn] ;
#define L ch][0
#define R ch][1 //宏定义左右儿子
void Rotate ( int x ) { //不用记录方向的Rotate
    int y = x[fa], z = y[fa], f = y[R]==x, son = ch[x][f^1] ;
    if ( y == root ) root = x ;
    if ( y != root ) ch[z][ z[R]==y ] = x ;
    fa[x] = z ;
    fa[y] = x ;
    if ( son ) fa[son] = y ;
    ch[y][f] = son ;
    ch[x][f^1] = y ;
}
 
void splay ( int x, int tar = 0 ) { // Splay函数
    while ( x != root && x[fa] != tar ) {
        int y = x[fa], z = y[fa], fx = y[R]==x, fy = z[R]==y ;
        if ( z == root || z == tar ) ;
        else if ( fx^fy ) Rotate(x) ;
        else Rotate(y) ;
        Rotate(x) ;
    }
}

ll new_node ( ll value ) { // 新建节点
    val[++cnt] = value ;
    cnt[L] = cnt[R] = cnt[fa] = 0 ;
    return cnt ;
}

void insert ( ll x, ll now ) { //插入
    if ( !root ) {
        root = new_node(x) ;
        return ;
    } else {
        if ( x <= val[now] ) {
            if ( now[L] ) insert ( x, now[L] ) ;
            else ( fa[new_node(x)] = now ) [L] = cnt ;
        } else {
            if ( now[R] ) insert ( x, now[R] ) ;
            else ( fa[new_node(x)] = now ) [R] = cnt ;
        }
    }
}

ll Pre ( ll x, ll st ) { // 前驱
    if ( st ) {
        if ( x[L] && x[L] != cnt ) return Pre ( x[L], 0 ) ;
        else return -zhf ;
    } else {
        if ( x[R] && x[R] != cnt ) return Pre ( x[R], 0 ) ;
        else return x[val] ;
    }
}

ll Next ( ll x, bool st ) { // 后继
    if ( st ) {
        if ( x[R] && x[R] != cnt ) return Next ( x[R], 0 ) ;
        else return zhf ;
    } else {
        if ( x[L] && x[L] != cnt ) return Next ( x[L], 0 ) ;
        else return x[val] ;
    }
}
int main() {
    ll i, j, k, x, y, ans, del, st ;
    Read(n) ;
    Read(x) ;
    root = new_node(x) ;
    ans = st = x ;
    for ( i = 2 ; i <= n ; i ++ ) {
        Read(k) ;
        insert ( k, root ) ;
        splay(cnt) ; //查询前驱后继都是从当前点开始的，这样方便利用排序二叉树的性质
        x = Next(root,1) ;
        y = Pre(root,1) ;
        if ( i != 2 ) del = min ( x-k, k-y ) ;
        else del = abs(st-k) ;
        ans += del ;
    }
    printf ( "%lld\n", ans ) ;
    return 0 ;
}
```

---

## 作者：远山淡影 (赞：0)

```
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
int root;
struct node
{
	int d,f,n,c,son[2];//d是权值 f是父亲 n是重点 c是控制点数 
}tr[110000];
int len=0;
void update(int x)//更新x控制的点数 
{
	int lc=tr[x].son[0],rc=tr[x].son[1];
	tr[x].c=tr[lc].c+tr[rc].c+tr[x].n;
}
void add(int d,int f)//添加一个点
{
	tr[++len].d=d;tr[len].c=tr[len].n=1;tr[len].f=f;
	if(d<tr[f].d) tr[f].son[0]=len;
	else tr[f].son[1]=len;
	tr[len].son[0]=tr[len].son[1]=0;
}
//旋转 左(x,0) 右(x,1) (由下至上) 
void rotate(int x,int w)
{
	int f=tr[x].f,ff=tr[f].f,r,R;//f ff 父亲与爷爷 r 儿辈 R 父辈 
	//转儿子 
	r=tr[x].son[w];R=f;//左旋就转左儿子,右旋就转右儿子
	tr[R].son[1-w]=r;//左旋就当右儿子,右旋就当左儿子
	if(r!=0) tr[r].f=R;//r不能是叶子节点
	//转自己 
	r=x;R=ff;
	if(f==tr[R].son[0]) tr[R].son[0]=r;
	else tr[R].son[1]=r;//代替父亲 
	tr[r].f=R;
	//转父亲
	r=f;R=x;
	tr[R].son[w]=r;//左旋就转左儿子,右旋就转右儿子
	tr[r].f=R;
	//更新(由下至上)
	update(f);//此时f已是x的儿子 
	update(x);
}
//让x成为rt的直系孩子(一直往上跳,类似书剖,先跳父亲，再跳自己) 
void splay(int x,int rt)
{
	while(tr[x].f!=rt)
	{
		int f=tr[x].f,ff=tr[f].f;
		if(ff==rt)
		{
			if(tr[f].son[0]==x) rotate(x,1);
			else rotate(x,0);
		}
		else
		{
			if(tr[ff].son[0]==f && tr[f].son[0]==x)
			{
				rotate(f,1);
				rotate(x,1);
			}
            else if(tr[ff].son[1]==f && tr[f].son[1]==x)
			{
				rotate(f,0);
				rotate(x,0);
			}
            else if(tr[ff].son[0]==f && tr[f].son[1]==x)
			{
				rotate(x,0);
				rotate(x,1);
			}
            else if(tr[ff].son[1]==f && tr[f].son[0]==x)
			{
				rotate(x,1);
				rotate(x,0);
			}
		}
	}
	if(rt==0) root=x;
}
int findip(int d)//找到值为d的点的位置
{
	//前提：伸展树里,以x为根的树里,左子树的所有节点都比n小,右子树的所有节点都比n大 
	int x=root;//从根开始 
	while(tr[x].d!=d)
	{
		if(d<tr[x].d)
		{
			if(tr[x].son[0]==0) break;
			x=tr[x].son[0];
		}
		else
		{
			if(tr[x].son[1]==0) break;
			x=tr[x].son[1];
		}
	}
	return x;
}
void ins(int d)//插入一个值为d的点 
{
	if(root==0)
	{
		add(d,len);
		root=len;
		return ;
	}
	int x=findip(d);
	if(tr[x].d==d)
	{
		tr[x].n++;
		update(x);
		splay(x,0);
	}
	else
	{
		add(d,x);
		update(x);
		splay(len,0);
	}
}
void del(int d)//删除一个值为d的点
{
	int x=findip(d);splay(x,0);
	if(tr[x].n>1)//不删点的情况 
	{
		tr[x].n--;
		update(x);
		return ;
	}
	int lc=tr[x].son[0],rc=tr[x].son[1];
	if(lc==0 && rc==0) root=len=0;//如果整棵树只有一个点 
	else if(lc!=0 && rc==0)
	{
		root=lc;
		tr[lc].f=0;
	}
	else if(lc==0 && rc!=0)
	{
		root=rc;
		tr[rc].f=0;
	}
	else
	{
		int p=lc;
		while(tr[p].son[1]!=0) p=tr[p].son[1];
		splay(p,x);//让x的左子树中最大的点当新根 
		tr[p].son[1]=rc;
		tr[rc].f=p;//让x的右孩子当新根的右孩子 
		root=p;tr[p].f=0;
		update(p);
		//即让小于n的最大的点代替x当新根 
	}
}
int findpm(int d)//找值为d的点在整棵树中的大小排名
{
	int x=findip(d);splay(x,0);
	return tr[tr[x].son[0]].c+1;
}
int findzhi(int k)//找排名为k的点的位置
{
	int x=root;
	while(1)
	{
		int lc=tr[x].son[0],rc=tr[x].son[1];
		if(k<=tr[lc].c) x=lc;//如果左子树的点数比k大 
		else if(k>tr[lc].c+tr[x].n)//如果左子树的点数+我这里的重点数<k 
		{
			k-=tr[lc].c+tr[x].n;
			x=rc;
		}
		else break;
	}
	splay(x,0);
	return tr[x].d;
}
int findqq(int d)//找值为d的点的前驱(小于d,且最大的数) 
{
	int x=findip(d);splay(x,0);
	if(tr[x].n>1) return x;
	if(d<=tr[x].d && tr[x].son[0]!=0)
	{
		x=tr[x].son[0];
		while(tr[x].son[1]!=0) x=tr[x].son[1];
	}
	if(tr[x].d>=d) x=0;
	return x;
}
int findhj(int d)//找值为d的点的后继(大于d,且最小的数)
{
	int x=findip(d);splay(x,0);
	if(tr[x].n>1) return x;
	if(d>=tr[x].d && tr[x].son[1]!=0)
	{
		x=tr[x].son[1];
		while(tr[x].son[0]!=0) x=tr[x].son[0];
	}
	if(tr[x].d<=d) x=0;
	return x;
}
int n,ans=0;
int main()
{
	scanf("%d",&n);
	root=len=0;
	for(int i=1;i<=n;i++)
	{
		int x;scanf("%d",&x);
		ins(x);
		int ll=findqq(x),rr=findhj(x);
		if(ll==0 && rr==0) ans+=x;
		else if(ll!=0 && rr==0) ans+=x-tr[ll].d;
		else if(ll==0 && rr!=0) ans+=tr[rr].d-x;
		else ans+=min(x-tr[ll].d,tr[rr].d-x);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：attack (赞：0)

来一发01Trie树


表示懒得写查找前驱和后继的函数了，


就用kth(查找排名为x的数)和rak(查找x的排名)偷了个懒


找前驱的时候就是kth( rak(x) )


后继是kth( rak(x) +1) （注意这里的前驱后继不是严格的，所以允许重复）


时间复杂度可能有点高，不过还是能水过去的


```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;
const int MAXN=1e6+10,INF=1e7;
inline char nc()
{
    static char buf[MAXN],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char c=nc();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=nc();}
    return x*f;
}
int ch[MAXN][2],num[MAXN],tot=2,root=1;
inline void insert(int x)
{
    x+=INF;
    for(int i=31,now=root,t; ~i; i--)
    {
        if( !(ch[now][ t=x>>i &1 ]) )    ch[now][t]=++tot;
        num[ now=ch[now][t] ]+=1;
    }
}
inline int rak(int x)
{
    x+=INF;
    int ans=0;
    for(int i=31,now=root,t; ~i ; i--)
    {
        if( (t=x>>i &1) )    
            ans+=num[ ch[now][0] ];
        now=ch[now][t];
    }
    return ans;
}
inline int kth(int x)
{
    int ans=0;
    for(int i=31,now=root; ~i ; i--)
    {
        if( x>num[ ch[now][0] ] )    ans|=1<<i,x-=num[ ch[now][0] ],now=ch[now][1];
        else now=ch[now][0];
    }
    return ans-INF;
}
int main()
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    int n=read(),ans=read();n=n-1;
    insert(ans);
    while(n--)
    {
        int x=read();
        int pre=kth( rak(x) );
        int lat=kth( rak(x) +1);
        ans+=min( abs(pre-x) ,abs(lat-x) );
        insert(x);
    }
    printf("%d",ans);
}
```

---

## 作者：Jμdge (赞：0)

 非旋 $treap$ 来水一波 操作  QAQ
 
 本题要用到的平衡树所需要支持的操作：
 
 	1. 插入值
     2. 查询前驱后继
     3. 没了




----

然后这道题其实非常的水，你每次读入一个值，然后查询它的非严格前驱和后继，

然后插入这个值就好了

```cpp
//by Judge
#include<iostream>
#include<cstdio>
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;
const int M=4e4+111;
const int inf=1e9+7;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
}
int n,ans,cnt,root;
struct Node {
    int val,key,siz,ch[2];
    void clear() { ch[0]=ch[1]=siz=val=key=0; }
} t[M];
// 手写随机函数大法好
inline int Rand() { static int seed=703; return seed=int(seed*48271LL%(~0u>>1)); }
inline int update(int now){ t[now].siz=t[t[now].ch[0]].siz+t[t[now].ch[1]].siz+1; }
int merge(int u,int v) {  //合并
    if(!u || !v) return u|v;
    if(t[u].key<t[v].key) { t[u].ch[1]=merge(t[u].ch[1],v),update(u); return u; }
	else { t[v].ch[0]=merge(u,t[v].ch[0]),update(v); return v; }
}
void split_val(int now,int k,int& x,int& y) {  //分离
    if(!now) return (void)(x=y=0);
    if(t[now].val<=k) split_val(t[x=now].ch[1],k,t[now].ch[1],y);
    else split_val(t[y=now].ch[0],k,x,t[now].ch[0]);
    update(now);
}
inline void ins(int x) { int u,a,b; t[u=++cnt].key=Rand(),t[u].val=x,t[u].siz=1,split_val(root,x,a,b),root=merge(merge(a,u),b); }
inline int get_val(int& now,int x) { int a,b,c,d,e; split_k(now,x-1,a,b),split_k(b,1,c,d),e=t[c].val,now=merge(a,merge(c,d)); return e; }
inline int pre(int x) { int a,b,c; split_val(root,x,a,b),c=get_val(a,t[a].siz),root=merge(a,b); return c; }
inline int sub(int x) { int a,b,c; split_val(root,x-1,a,b),c=get_val(b,1),root=merge(a,b); return c; }
signed main() {
    n=read(); int node,x,p,s;
    ans=x=read(),ins(x),ins(-inf),ins(inf); //注意 inf 和 -inf 的插入( soplay 党应该也一样 )
    while(--n){
        x=read(),p=pre(x),s=sub(x);
        ins(x),ans+=min(x-p,s-x); // 累加答案
    } printf("%d\n",ans); return 0;
}
```



---

## 作者：moye到碗里来 (赞：0)

刚好在学treap，特来水一发，一看大大的模板题，就来讲解一下treap，毕竟感觉好像用的人不多啊。。
treap 作为tree 和 heap 的组合词，它既具有二叉排序树的一部分性质，也有堆的一部分性质。注意，**它不一定是完全二叉树，与堆不同。**
如何实现呢？我们给予这棵树上的节点另一个权值，使其带有一个*随机的值*。然后在用排序二叉树的插入方式插入过后再利用这个随机的权值进行旋转，这里我用的是大根堆。
为什么要这样做呢？因为二叉排序数在数据非随机的时候极其有可能因为出题人的恶意退化成一条链，而当我们赋予其随机权值并旋转后，这些节点就形成了无关于输入顺序而只与**权值大小**相关的插入顺序。想象一下，当这个节点的权值越大，它就在越上方，而越靠近根节点的则是越早插入的节点，可以模拟一下，最后会发现，这棵树与你按权值大小从大到小插入一毛一样。
然后既然具有堆的性质，就把它旋到底部就可以删除啦，还是相当简单的。反正写起来相当短，与splay不相上下
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll cnt = 1,rt = 0; 
struct Treap
{
	ll key,pri,son[2];
}T[33767];
int n;
ll ans = 0;
void rotate(ll p,ll &rt)
{
	int y = T[rt].son[p];
	T[rt].son[p] = T[y].son[!p];
	T[y].son[!p] = rt;
	rt  = y;
}
void ins(ll key,ll &rt)
{
	if(rt == 0)
	T[rt = cnt++] = (Treap){key,rand()};
	else
	{
		int p = key > T[rt].key;
		ins(key,T[rt].son[p]);
		if(T[T[rt].son[p]].pri > T[rt].pri)
		rotate(p,rt);	
	}
}
ll query(ll key,ll rt)
{
	if(rt == 0) return 9223372036854775807;
	ll res = abs(key - T[rt].key);
	if(key > T[rt].key) res = min(res,query(key,T[rt].son[1]));
	if(key < T[rt].key) res = min(res,query(key,T[rt].son[0]));
	return res;
}
int main()
{
	srand(19970502);
	scanf("%d",&n);
	ll x;
	scanf("%lld",&x);
	ins(x,rt);
	ans += x;
	for(int i = 1; i < n; i++)
	{
		scanf("%lld",&x);
		ans += query(x,rt);
		ins(x,rt);
	}
	printf("%lld",ans);
}	
```

---


# [SCOI2005] 繁忙的都市

## 题目描述

城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 $n$ 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：

1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。
1. 在满足要求 1 的情况下，改造的道路尽量少。
1. 在满足要求 1、2 的情况下，改造的那些道路中分值最大的道路分值尽量小。

任务：作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。

## 说明/提示

### 数据范围及约定

对于全部数据，满足 $1\le n\le 300$，$1\le c\le 10^4$，$1 \le m \le 8000$。

## 样例 #1

### 输入

```
4 5
1 2 3
1 4 5
2 4 7
2 3 6
3 4 8
```

### 输出

```
3 6```

# 题解

## 作者：Created_equal1 (赞：107)

算法1：

题面中有最大值最小，典型的二分！首先二分边权，然后把边权小于等于二分的边权的边全部用并查集连接到一起，判断是否联通即可。


算法2：

本题要求求的就是瓶颈MST，即最大边权最小的生成树。有个定理：一棵最小生成树必定是一棵最小瓶颈生成树。所以我们直接做一遍最小生成树即可


---

## 作者：张佳 (赞：49)

把交叉路口看做图中的点，道路为边，则可以从三个条件：


1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。


2．在满足要求1的情况下，改造的道路尽量少。


3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。


可得，本题是一个裸的最小生成树。

第一问求选择的道路数，因为只有“保证联通”一个条件优先级在“道路尽量少”之上，不难看出直接输出n-1即可。（一个N个点的联通图最少有n-1条边）；

第二问直接在求最小生成树的同时，记录下当前已搜到的最大值即可。由于此题未要求输出最小生成树的权值和，因此在求最小生成树的过程中直接只记录最大值即可。

求最小生成树的常用方法：prim和克鲁斯卡尔(利用并查集)。

此题用克鲁斯卡尔更优，因为要保证条件3，不过貌似prim也能过~

c++代码


prim:

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int g[310][310];
int n,m,a,b,c,minn[310],mmax=-1;
bool u[310];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&a,&b,&c);
        g[a][b]=c;
        g[b][a]=c;
    }
    memset(minn,0x7f,sizeof(minn));    
    minn[1]=0;
    memset(u,1,sizeof(u));
    for(int i=1;i<=n;++i){
        int k=0;
        for(int j=1;j<=n;j++)
            if(u[j]&&(minn[j]<minn[k]))
                k=j;
        u[k]=0;
        for(int j=1;j<=n;j++)
            if(u[j] && g[k][j]!=0 && g[k][j]<minn[j])
                minn[j]=g[k][j];
    }
    for(int i=1;i<=n;++i){
        if(minn[i]>mmax)
            mmax=minn[i];
    }
    printf("%d %d",n-1,mmax);
    return 0;
}
```
克鲁斯卡尔：




```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int m, n, u, v, c, maxn, k;
int fa[301];
int find(int x) {
    if(fa[x]!=x) 
        fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y) {
    int fx = find(x);
    int fy = find(y);
    if (fx != fy) fa[fx]=fy;
}
struct Node {
    int x, y, v;
    bool operator < (const Node &b) const {
        return v<b.v;
    }
}a[51000];
int main() {
    cin >> n >> m;
    for (int i=1; i<=m; i++) {
        cin >> u >> v >> c;
        a[i]=(Node){u, v, c};
    }
    for (int i=1; i<=n; i++) fa[i]=i;
    sort(a+1,a+m+1);
    for (int i=1; i<=m; i++) {
        if (find(fa[a[i].x]) != find(fa[a[i].y])) {
            unionn(a[i].x, a[i].y);
            maxn = a[i].v;
            k++;
        }
        if (k == n-1) break;
    }
    cout<< n-1 << " " <<maxn; 
    return 0;
}
```

---

## 作者：a15326987 (赞：36)

   看了此题如果不是对kruskal熟悉并且未**认真读题**的OIer的第一感觉就是**最符合人类思想**的**Floyd算法**，但是很不幸还真不是它，而是那个它。且听我娓娓道来。
   
   ~~kruskal中文译为克鲁斯卡尔，不对扯远了~~
   
   克鲁斯卡尔的精髓三个字—— _并查集_ （查找 and 合并）；
   

------------

   First：设定一个父亲数组即fa[N] （此处N为一个常数下文同样）
   
   Second：初始化父亲数组  
   ```cpp for(inti=1;i<=n;i++)fa[i]=i;```
 
  
   Third:自定义find（查找）与合并函数
  ```cpp
int find(int x)
{
	if(x!=fa[x])  fa[x]=find(fa[x]);
	return fa[x];
}
```
```cpp
int hebing(int x,int y)
{
   int aa=find(x);
   int bb=find(y);
   if(aa!=bb) fa[aa]=bb;
}
```
  Fourth：sort排序后开始克鲁斯卡尔
  

------------

  如果你已经完成了此四步，那么你已经成功了一半。
  
  那我就直接来我的代码供各位参考~~抄袭~~。
  ```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
using namespace std;
int fa[100001];//父亲数组
struct p
{
	int x,y,val;
}a[100001];//这里表示从x到y的分值我认为结构体更理解所以用的结构体，如有其他方式也可以试试
int find(int x)
{
	if(x!=fa[x])  fa[x]=find(fa[x]);
	return fa[x];
}
int bj(p a,p b)//用于后面排序
{
	return a.val<b.val;
}
int main()
{
	int maxx=-9999999;//初始化一个极小值
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)fa[i]=i;//初始化父亲数组
	for(int i=1;i<=m;i++)
	{
		cin>>a[i].x>>a[i].y>>a[i].val;
	}
	int k=0;
	sort(a+1,a+1+m,bj);//从小到大排
	for(int i=1;i<=m;i++)
	{
		if(find(a[i].x)!=find(a[i].y))
		{
		    maxx=a[i].val;//由于已经排序所以为一组单增数据可以不用比较大小
			int aa=find(a[i].x);//此处我把合并函数放在这只是个人习惯。
			int bb=find(a[i].y);
			if(aa!=bb) fa[aa]=bb;
			k++;//记录出现的边数
			if(k==n-1)break;//如果边数是点数-1那么说明已经出现了最小生成树就可以直接停止了
		}
	}
	cout<<n-1<<" "<<maxx<<endl;
}
```

  

   



   

---

## 作者：从不再见 (赞：9)

### [P2330](https://www.luogu.org/problem/P2330)
这道题还是对于**ju**佬比较简单的，一下就会让人想到最小生成树，这里我就照顾下不知道kruskal的小盆友

------------
并查集模板：
```
int find(int x){	
	if(x==father[x])
		return father[x];
	return father[x]=find(father[x]);
}
void unionn(int x,int y){	
	x=find(x);
	y=find(y);
	if(x!=y)
		father[x]=y;
}
```
kruskal是依靠并查集判环，贪心最小的点，模拟n-1个边


------------

kruskal代码如下：
```
int find(int x){
	if(x==father[x])
		return father[x];
	return father[x]=find(father[x]);
}
void unionn(int x,int y){	
	x=find(x);
	y=find(y);
	if(x!=y)
		father[x]=y;
}
void kruskal(){	
	int a,b;
	sort(edge+1,edge+1+m,cmp);	
	for(int i=1;i<=m;i++){
		a=find(edge[i].u);	 
		b=find(edge[i].v);
		if(a!=b){	
			ans=max(edge[i].w,ans);
			cnt++;
			unionn(a,b);	 
			if(cnt==n-1)	
				break;
		}
	}
	return;
}
```
所以第一个输出的数就是n-1，第二个数是去了的边中，边权最大的值

 _代码_如下 ：

------------

```
#include<bits/stdc++.h>
using namespace std;
int father[310],n,m,cnt,ans;
struct node{
	int u;
	int v;
	int w;
}edge[10010];
int cmp(node x,node y){		//调整排序 
	return x.w<y.w;
} 
int find(int x){	//找祖先 
	if(x==father[x])
		return father[x];
	return father[x]=find(father[x]);
}
void unionn(int x,int y){	//合并 
	x=find(x);
	y=find(y);
	if(x!=y)
		father[x]=y;
}
void kruskal(){	//最小生成树模板 
	int a,b;
	sort(edge+1,edge+1+m,cmp);	//贪心，最小值优先 
	for(int i=1;i<=m;i++){
		a=find(edge[i].u);	 
		b=find(edge[i].v);
		if(a!=b){	//如果不是同一个祖先（如果没有合并），是否为环 
			ans=max(edge[i].w,ans);	//题目要求  
			cnt++;
			unionn(a,b);	//合并， 
			if(cnt==n-1)	//如果已经选择了n-1条边，就退出 
				break;
		}
	}
	return;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		father[i]=i;	//初始化并查集 
	for(int i=1;i<=m;i++){
		cin>>edge[i].u>>edge[i].v>>edge[i].w;
	}
	kruskal();	//最小生成树模板 
	cout<<n-1<<' '<<ans;	//因为最小生成树是n个点,n-1条边 
	return 0;
}
```



---

## 作者：Skyjoy (赞：7)

最小生成树水题

大家仔细研究一下题面，会发现这道题处处都在暗示最小生成树！

>1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。

这句话告诉我们要造一个连通图！

>2．在满足要求1的情况下，改造的道路尽量少。

这句话提示我们造的图是一棵树！

> 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。

这句话告诉我们树的权值要尽量小！

# 这不就是造一个最小生成树吗？

不过这题问的与模板略有不同，问的是最大的权值，****所以答案不是权值和，而是权值的最大值****

接下来套一个模板就行了（不会模板的来[这儿](https://www.luogu.org/problem/P3366)）

这里推荐$kruskal$算法，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,fi[310],nx,ny,ans,cur=1;
struct edge{
	int x,y,w;
}e[100010];
bool cmp(edge a,edge b){
	return a.w<b.w;
}
int find(int x){
	while(x!=fi[x]){
		x=fi[x]=fi[fi[x]];
	}
	return x;
}
void kruskal(){
	for(int i=1;i<=m;i++){
		nx=find(e[i].x),ny=find(e[i].y);
		if(nx==ny){
			continue;
		}
		fi[ny]=nx;
		ans=e[i].w;
		cur++;
		if(cur==n){
			return;	
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		fi[i]=i;
	}
	for(int i=1;i<=m;i++){
		cin>>e[i].x>>e[i].y>>e[i].w;
	}
	sort(e+1,e+m+1,cmp);
	kruskal();
	cout<<n-1<<" "<<ans;
	return 0;
}
```
反正$CSP$已经爆零了，还是让心归零，好好~~练字~~做题吧！要是爸爸妈妈知道我一个星期才写这么一点题，爸爸妈妈会流眼泪的！

---

## 作者：wyx__ (赞：6)

这题显然就是求最大边权最小的生成树，而用克鲁斯卡尔很容易证明这就是最小生成树（考虑一下这个算法每次取的都是不构成环的最小边就行了），然后用克鲁斯卡尔算法求解

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data {
	int x,y,k;
} e[100005];
int n,m,tot,maxn,fa[305];
int find(int x) {
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
bool cmp(data x,data y) {
	return x.k<y.k;
}
int main() {
	for(int i=1; i<=300; i++)
		fa[i]=i;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].k);
	printf("%d ",n-1);
	sort(e+1,e+m+1,cmp);
	for(int i=1; i<=m; i++)
		if(find(e[i].x)!=find(e[i].y)) {
			fa[find(e[i].x)]=find(e[i].y);
			tot++;
			maxn=e[i].k;
			if(tot==n-1)
				break;
		}
	printf("%d",maxn);
}
```


---

## 作者：TYX180129 (赞：6)

# Prim的题解
## 切记要用scanf和printf，不然会超时
## 细节见代码的注释
```cpp
#include<bits/stdc++.h>
using namespace std ;
int u[2505] ;//是否加入树 
int s[2505] ;//没加入树的节点 
int mp[2505][2505] ; //两条路之间的分值 
int main()
{
	memset(mp , 1 , sizeof(mp)) ;//初始化mp  
	memset(s , 1 , sizeof(s)) ;//初始化s 
	int n , m , ans = 0 ;
	scanf("%d%d" , &n , &m) ;//输入 
	for(int i = 1 ; i <= m ; ++i)
	{
		int u , v , c ;
		scanf("%d%d%d" , &u , &v , &c) ;
		if(c < mp[u][v])//选择分值小的 
			mp[u][v] = mp[v][u] = c ; 
	}
	s[1] = 0 ;//设置起点  
	for(int i = 1 ; i <= n ; ++i)
	{
		int k = 0 ;
		for(int j = 1 ; j <= n ; ++j)//寻找还没有进入树但是s最小的路 
			if(u[j] == 0 && s[j] < s[k])
				k = j ;
		u[k] = 1 ;
		for(int j = 1 ; j <= n ; ++j)
			if(u[j] == 0 && mp[k][j] < s[j])
				s[j] = mp[k][j] ;
	}
	for(int i = 1 ; i<= n ; ++i)//寻找分值最大的路 
		if(s[i] > ans)
			ans = s[i] ;
	printf("%d %d" , n - 1 , ans) ;//输出 
	return 0 ;
}
```
## 没加注释的代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
int u[2505] ;
int s[2505] ;
int mp[2505][2505] ; 
int main()
{
	memset(mp , 1 , sizeof(mp)) ;  
	memset(s , 1 , sizeof(s)) ;
	int n , m , ans = 0 ;
	scanf("%d%d" , &n , &m) ;
	for(int i = 1 ; i <= m ; ++i)
	{
		int u , v , c ;
		scanf("%d%d%d" , &u , &v , &c) ;
		if(c < mp[u][v])
			mp[u][v] = mp[v][u] = c ; 
	}
	s[1] = 0 ;
	for(int i = 1 ; i <= n ; ++i)
	{
		int k = 0 ;
		for(int j = 1 ; j <= n ; ++j)
			if(u[j] == 0 && s[j] < s[k])
				k = j ;
		u[k] = 1 ;
		for(int j = 1 ; j <= n ; ++j)
			if(u[j] == 0 && mp[k][j] < s[j])
				s[j] = mp[k][j] ;
	}
	for(int i = 1 ; i<= n ; ++i)
		if(s[i] > ans)
			ans = s[i] ;
	printf("%d %d" , n - 1 , ans) ;
	return 0 ;
}
```



---

## 作者：扬皓2006 (赞：3)

思路:Kruskal算法

输出：点数-1及（生成树中）最大边权

如果还不会求最小生成树的请左转这里

好了，开始我们的正题，此题用的是Kruskal算法，它是一种基于贪心和并查集的算法（就是把边权排序，然后按照边权从小到大搜，如果形成环就跳过继续搜，直到生成树的边数为总边数即可）

代码如下：

```
#include<bits/stdc++.h>//万能头
using namespace std;
struct Edge{
	int from,to,dis;
}edge[100001];//邻接表
bool operator <(Edge a,Edge b)
{
	return a.dis<b.dis;
}//重载运算符
int n,m,s,maxx;
int fa[10001];
int get(int x)
{
	if(fa[x]==x)  return x;
	return fa[x]=get(fa[x]);
}//并查集查询操作
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>edge[i].from>>edge[i].to>>edge[i].dis;
	}
	for(int i=1;i<=n;i++)  fa[i]=i;
	sort(edge+1,edge+1+m);//排序边权
	for(int i=1;i<=m;i++)
	{
		int x=get(edge[i].from),y=get(edge[i].to);
		if(x==y) continue;
		fa[x]=y;maxx=edge[i].dis;//并查集合并操作
	}
	cout<<n-1<<" "<<maxx;
	return 0;
}
```
最后，希望各位同学都能够学会Kruskal，也希望管理大大能够通过此篇题解！


---

## 作者：麻爷在线 (赞：3)

我看楼下没有二分代码，发上来有兴趣的看一下

思路很简单，二分答案即可



    



    
```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
const int maxn=300+5,maxc=10000+5;
int n,m;
bool visited[maxn];
struct Edge{
    int v,l;
    Edge(){
        v=0; l=0;
    }
    Edge(int v_in,int l_in){
        v=v_in; l=l_in;
    }
};
vector<Edge> G[maxn];
void dfs(int u,int max_c){
    visited[u]=1;
    for(int i=0;i<G[u].size();i++){
        if(visited[G[u][i].v] || G[u][i].l>max_c) continue;
        dfs(G[u][i].v,max_c);
    }
    return ;
}
bool access(int max_c){
    memset(visited,0,sizeof(visited));
    dfs(1,max_c);
    int p=1;
    while(visited[p])p++;
    if(p<=n) return false;
    else return true;
}
int main(){
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int u,v,c;
        cin>>u>>v>>c;
        G[u].push_back(Edge(v,c));
        G[v].push_back(Edge(u,c));
    }
    int l=1,r=maxc;
    while(l<r){
        int mid=(l+r)/2;
        if(access(mid)) r=mid;
        else l=mid+1;
    }
    cout<<n-1<<" "<<l;
    return 0;
}
```

---

## 作者：yuzhechuan (赞：3)

```cpp
//头文件
#include <bits/stdc++.h>//万能库
using namespace std;
//定义变量
const int N=5050,M=200200;//N为点，M为边
int i,j,k,n,m,ans;
int f[N];
struct edge { int x,y,z;} A[M];//有x起点y终点z长度的结构体
//定义比较符
bool cmp(edge a,edge b) { return a.z<b.z;}
//求所属集合的函数（并查集啊）
int getf(int x) {
    if (f[x]==x) return x;
    return f[x]=getf(f[x]);
}
//主程序（Kruskal）
int main() {
    scanf("%d%d",&n,&m);
    for (i=1;i<=m;i++) scanf("%d%d%d",&A[i].x,&A[i].y,&A[i].z);//读入
    sort(A+1,A+m+1,cmp);//排序
    for (i=1;i<=n;i++) f[i]=i;//各点所属集合初始化
    int num=0;
    for (i=1;i<=m;i++) {//核心
        int x=A[i].x,y=A[i].y;
        if (getf(x)!=getf(y)) {//如果所属集合不同...
            num++;//边数累加
            f[f[x]]=f[y];//把起点终点并到同一集合中去
            ans=max(ans,A[i].z);//max求最大边权值
        }
        if (num==n-1) break;//走完了就跳出（虽然并不影响复杂度）
    }
    printf("%d %d\n",num,ans);//输出：num为最后边数，ans为最大边权值
}
```

---

## 作者：洛必达法则 (赞：2)

最开始看到这道题的时候，首先就会想到每一条桥都必须在所选边的集合内，故想到使用tarjan

但因为实际应用时发现并不需要在此题运用这么高级的算法（其实就是忘了），考虑到用二分答案的方法，枚举边的最大长度，判断图形是否可以连通

代码如下：

```cpp
#include<bits/stdc++.h>
#define one LONG_LONG_MAX/4
using namespace std;
inline void input(long long&);
long long n,m;
struct edge
{
    long long st,ed;
    long long length;
    edge(long long p=0,long long q=0,long long r=0)
    {
        this->st=p;
        this->ed=q;
        this->length=r;
    }
    edge operator = (const edge b)
    {
        this->st=b.st;
        this->ed=b.ed;
        this->length=b.length;
        return (*this);
    }
};
edge road[90001];
inline void input(edge&);
struct cmp
{
    bool operator () (const edge x,const edge y)
    {
        return x.length<y.length;
    }
};
long long fa[301];
inline long long f(long long);
long long l,r;
inline bool runable(long long);
int main()
{
    input(n);input(m);
    for(long long i=1;i<=m;i++)
    {
        input(road[i]);
    }
    sort(road+1,road+m+1,cmp());
    l=n-1;
    r=m;
    while(l<r)
    {
        long long mid=l+r;
        mid>>=1;
        if(runable(mid))
        {
            r=mid;
        }
        else
        {
            l=mid+1;
        }
    }
    printf("%lld %lld\n",n-1,road[r].length);
    exit(0);
}
inline bool runable(long long x)
{
    for(long long i=1;i<=n;i++)
    {
        fa[i]=i;
    }
    long long num=0;
    for(long long i=1;i<=x;i++)
    {
        long long p=road[i].st,q=road[i].ed;
        if(f(p)!=f(q))
        {
            num++;
            fa[f(p)]=f(q);
        }
    }
    if(num<(n-1))
    {
        return false;
    }
    return true;
}
inline long long f(long long x)
{
    if(fa[x]==x)
    {
        return x;
    }
    return fa[x]=f(fa[x]);
}
inline void input(edge &x)
{
    input(x.st);
    input(x.ed);
    input(x.length);
    return;
}
inline void input(long long &x)
{
    x=0;
    long long opt=1;
    char ch;
    while(ch=getchar())
    {
        if(ch=='-')
        {
            opt=-1;
            break;
        }
        if(ch<'0'||ch>'9')
        {
            continue;
        }
        x=ch-'0';
        break;
    }
    while(ch=getchar())
    {
        if(ch<'0'||ch>'9')
        {
            break;
        }
        x*=10;
        x+=ch-'0';
    }
    x*=opt;
    return;
}
```
其中，判断图形连通性可以运用最小生成树的kruskal算法

因为要使一张图连通，图中边数至少为边数减一，所以二分答案时将左边界$l$初始为$n-1$,右边界$r$初始为$m$即可。

---

## 作者：Misaka19280 (赞：2)

本题的题意很明确，使N个点两两互达

所以如果两个点已经间接或直接相连，你还连他们两个是不是钱太多了

所以只要有N-1条边就可以了

就是裸的最小生成树喽

为了保证总和最小，先排序（从小到大）

然后从前往后扫描，如果这个点的u和v不在一个集合，用并查集加到集合里，如果他们在同一集合，表示已经可以相互到达，什么都不干

↑就是克鲁斯卡尔算法

开始直接输出n-1条连边

每次递减n，当n=1时跳出

因为已经排序，所以只要输出此时点的c就可以了

代码如下

```
Type
    hh=record
        a,x,y:longint;
    end;

Var
    fa:array[1..301]of longint;
    n,i,f1,f2,m:longint;
    a:array[1..50001]of hh;
    
Function getfather(k:longint):longint;//并查集
begin
    if fa[k]<>k then getfather:=getfather(fa[k])
        else getfather:=k;
    fa[k]:=getfather;
end;

Procedure qsort(l,r:longint);
var
    i,j,e:longint;
    f:hh;
begin
    i:=l;
    j:=r;
    e:=a[(l+r) div 2].a;
    repeat
        while a[i].a<e do inc(i);
        while a[j].a>e do dec(j);
        if i<=j then
            begin
                f:=a[i];
                a[i]:=a[j];
                a[j]:=f;
                inc(i);
                dec(j);
            end;
    until i>j;
    if i<r then qsort(i,r);
    if l<j then qsort(l,j);
end;

Begin
    readln(n,m);
    write(n-1,' '); //树有N-1条边相连
    for i:=1 to m do
        read(a[i].x,a[i].y,a[i].a);
    qsort(1,m);
    for i:=1 to n do
        fa[i]:=i;
    i:=0;
    while (n>1) and (i<=m) do
        begin
            inc(i);
            f1:=getfather(a[i].x);
            f2:=getfather(a[i].y);
            if f1<>f2 then //不在同一集合，并
                begin
                    fa[f1]:=f2;
                    dec(n);
                end;
        end;
    writeln(a[i].a); //根据排序性质，当前点的值一定最大
End.
```

---

## 作者：zhaowangji (赞：1)

其实就是**最小生成树**

因为它要求连接所有边，且边要少，边权要小

n个节点用n-1条边连起来的图形只能是树（所以第一个输出就是n-1），然后边权要小，那么就是最小生成树了

本人习惯用Kruskal算法（要用到并查集）

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
struct node{
	int x,y;//连接的两点
	int fz;//分值
}dis[100007];//存边
int sum;//记录已取的边数
int fa[307];//并查集，保存每个点的祖先
int fi(int x){
	if(fa[x]!=x)fa[x]=fi(fa[x]);
	return fa[x];//找某个点最早的祖先
}
void hb(int x,int y){
	fa[x]=y;
	return;//合并两个点（放到一个集合里）
}
bool cmp(node x,node y){
	return x.fz<y.fz;//按分值排序
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,c;//变量名最好与题目中一样
		cin>>u>>v>>c;
		dis[i].x=u;
		dis[i].y=v;
		dis[i].fz=c;
	}
	sort(dis+1,dis+m+1,cmp);//排序
	for(int i=1;i<=n;i++)
	fa[i]=i;//先把每个点的祖先保存为自己
	for(int i=1;i<=m;i++){
		int a=dis[i].x;
		int b=dis[i].y;//看着写着都方便一些
		if(fi(a)!=fi(b)){//两点不在同一集合里
			hb(fi(a),fi(b));//合并
			sum++;//已取的边数加一
		}
		if(sum==n-1){//全部连接了
			cout<<n-1<<' '<<dis[i].fz<<endl;
            		//最大分值就是最后一个点（因为按照分值排序了）
			break;//退出循环
		}
	}
	return 0;
}
```


---

## 作者：「QQ红包」 (赞：1)

用Prim……

```cpp

#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;

int g[310][310];
bool pd[310]={false};//0 is false;
int Min[310];
int Mst=-1;//此处为找最小权值组的最大值 
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=0;i<=300;i++)//将邻接矩阵赋初值 
      for(int j=1;j<=300;j++)
        g[i][j]=2000000000;
    for(int i=1;i<=m;i++)//输入邻接矩阵 
      {
        int x,y;
        cin>>x>>y;
        cin>>g[x][y];
        g[y][x]=g[x][y];
      }
    for(int i=1;i<=309;i++)//最小权值数组赋初值，没边则为20亿
      Min[i]=g[1][i];
    pd[1]=1;//标记第一个点
    for(int i=1;i<n;i++)
      {
        int j;
        int zuixiao=2000000000;
        int zui;//zui存最小值的 
        for(j=1;j<=n;j++)//擂台比较找最小的
          {
            if(pd[j]==0)//没加入最小生成树
              if(zuixiao>Min[j])
                {zuixiao=Min[j];zui=j;}
          }
        pd[zui]=1;//标记
        if(Mst<zuixiao)
          Mst=zuixiao;
        for(int k=1;k<=n;k++)//更新
          {
            if(g[zui][k]<Min[k]&&pd[k]==0)
              Min[k]=g[zui][k];
          }

      }
      cout<<n-1<<" "<<Mst; 
} 

```

---

## 作者：Bryant (赞：1)

按边权排序，然后Kruscal求最小生成树，最大的一条边即为所求


---

## 作者：auroral (赞：0)

分析题意：

要求1：改造的那些道路能够把所有的交叉路口直接或间接的连通起来——**构建一个连通图**

要求2：在满足要求1的情况下，改造的道路尽量少——**构建一棵树**

要求3：在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小——**构建一个最小生成树**

因为结果要求求出最小生成树的最长边，所以在Prim和Kruskal中，我果断的选择了Kruskal（~~其实我不大会写Prim~~）

### 那么结论就出来啦：构建一颗最小生成树并求其最长边

没发过几次题解，请管理员大大给通过

代码如下（极多批注版）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
ll n,m,f[100005],ans,num;
struct node{
	ll u,v,c;//u，v表示道路从u到v，道路权值为c 
}p[100005];
bool cmp(node a,node b){//按边权排序 
	return a.c<b.c;
}
ll getf(ll a){//查询祖先 
	if(a==f[a]) return a;//如果祖先就是自己就return 
	f[a]=getf(f[a]);//不然就查询，更新，再return 
	return f[a];
}
int main(){
	scanf("%lld%lld",&n,&m);//n表示节点数，m表示边的数量 
	for(ll i=1;i<=m;i++)
	scanf("%lld%lld%lld",&p[i].u,&p[i].v,&p[i].c);//结构体存边 
	sort(p+1,p+m+1,cmp);//按边权排序 
	for(ll i=1;i<=n;i++) f[i]=i;//并查集初始化，根节点指向自己 
	for(ll i=1;i<=m;i++){
		ll fa=getf(p[i].u),fb=getf(p[i].v);
		if(fa!=fb){//如果两边不相连 
			ll w=p[i].c;
			f[fa]=fb;//合并 
			ans=max(ans,w);//记录最大权值 
			num++;//记录边数 
		}
		if(num==n-1)//如果边数=n-1，也就是构造了一颗最小生成树 
		break;//直接跳出循环 
	}
	cout<<n-1<<" "<<ans;//最小生成树边数只有n-1，直接输出n-1 和最小生成树的最大边权 
	return 0;//完美结束 
} 
```
玄学问题：为什么我第一次提交没有边数=n-1跳出循环的操作，代码跑得还会比跳出循环的快，请大佬指教


---

## 作者：Hexarhy (赞：0)

发现这道题目很少有人用$Prim$来做。

毕竟数据是稠密图，理论上$Prim$更快。

下面进行讲解。


------------
首先看题目，给出那么多条件一看就晕，实际上仔细理解就不难发现，简述题意为：
> 求最小生成树中的**边最大的权值**。

接下来就比较裸了，没有重边、自环等坑，按照流程建无向图，推荐使用链式前向星或$vector$。

我们采用堆（STL的优先队列）来优化找最小权值边，因此总时间复杂度为$O(nlogn)$。

另外，对于题目第一问，根据最小生成树性质可只，一定是剩下$n-1$条道路。

对于$Prim$的教程，请点[链接](https://www.luogu.org/blog/80049/template-Minimum-Spanning-Tree)。这里不再赘述。

------------

剩下的都是细节。看程序吧。
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;

const int MAXN=100005;
int n,m,ans;
struct node
{
	int to,v;
};
vector <node> edge[MAXN];
bool visit[MAXN];

struct cmp
{
	bool operator()(const node& x,const node& y)const
	{
		return x.v>y.v;
	}
};

void input(void)
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		edge[x].push_back((node){y,z});
		edge[y].push_back((node){x,z});
	}
}

void prim(void)
{
	priority_queue <node,vector<node>,cmp> q;
	visit[1]=true;
	for(vector<node>::iterator it=edge[1].begin();it!=edge[1].end();it++)
	 q.push(*it);
	while(!q.empty())
	{
		const node tmp=q.top();
		q.pop();
		if(visit[tmp.to])
		 continue;
		visit[tmp.to]=true;
		ans=max(ans,tmp.v);
		for(vector<node>::iterator it=edge[tmp.to].begin();it!=edge[tmp.to].end();it++)
	     if(!visit[it->to])
	      q.push(*it);
	}
}

int main()
{
	input();
	prim();
	cout<<n-1<<' '<<ans;
	return 0;
}
```

---

## 作者：星之幻影 (赞：0)

其实就是模板改一点点！！

虽然我也改了半个小时（错在并查集的路径压缩上）

我用的是Kruskal,作为本蒟蒻的第一篇代码，呵呵。

上代码：

```pascal
#include<bits/stdc++.h>
using namespace std;
long long father[5002];
long long n,m,cnt=0,sum=0,maxx=0;
struct ag
{
	int x,y,z;
}book[200002];
bool cmp(ag a,ag b)
{
	return  a.z<b.z;
}
int find(int x)
{
	if(father[x]==x)
	  return x;
	return father[x]=find(father[x]);
}
void no(int c,int d)
{
	int a,b;
    a=find(c);
    b=find(d);
    father[a]=b;
}
void ku()
{
	sort(book+1,book+1+m,cmp);
	for(int i=1;i<=m;i++)
	{	
		if(find(book[i].x)!=find(book[i].y))
		{ 
			no(book[i].x,book[i].y);
			sum+=book[i].z;
		    cnt++;
		    maxx=book[i].z;
		    if(cnt==n-1)
		      break;
		}
	}
}
int main()
{
	int x,y,z,k;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	  father[i]=i;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		book[i].x=x;
		book[i].y=y;
		book[i].z=z;
	}
	ku();
	cout<<cnt<<" "<<maxx;
	return 0;
}
```

---

## 作者：GMSD (赞：0)

就是一个 克鲁斯卡尔
核心
```
void kruskal(){//克鲁斯卡尔 
	for(int i=1;i<=number;i++)father[i]=i;
	cnt=number;ans=0;
	sort(e+1,e+way+1,cmp);
	for(int i=1;i<=way;i++){
		if(cnt==1)break;
		int xx=find(e[i].from);int yy=find(e[i].to);
		if(xx!=yy){//判断是否联通 
			cnt--;ans+=e[i].dis;sum++;//sum:找了多少条边 
			maxn=max(maxn,e[i].dis);//找最大的边 
			father[xx]=yy;
		}
	}
}
```
所有代码：
```
#include<bits/stdc++.h>
using namespace std;

int number,way,father[300002],cnt,ans,sum=0,maxn=0;
struct node{
	int from;int to;int dis;
}e[300002];

bool cmp(node a,node b){
	return a.dis<b.dis;
}

int find(int a){//找祖先 
	if(father[a]!=a)father[a]=find(father[a]);
	return father[a];
}

void kruskal(){//克鲁斯卡尔 
	for(int i=1;i<=number;i++)father[i]=i;
	cnt=number;ans=0;
	sort(e+1,e+way+1,cmp);
	for(int i=1;i<=way;i++){
		if(cnt==1)break;
		int xx=find(e[i].from);int yy=find(e[i].to);
		if(xx!=yy){//判断是否联通 
			cnt--;ans+=e[i].dis;sum++;//sum:找了多少条边 
			maxn=max(maxn,e[i].dis);//找最大的边 
			father[xx]=yy;
		}
	}
}

int main(){
	cin>>number>>way;
	for(int i=1;i<=way;i++){
		cin>>e[i].from>>e[i].to>>e[i].dis;
	}
	kruskal();
	cout<<sum<<" "<<maxn;
	return 0;
}
```

---

## 作者：Nero_Claudius (赞：0)

又是一道Kruskal题目。

AC代码见下。

主要思路就是将所有的边储存起来，然后进行贪心地选择，期间需要判断两个端点是否有关联，这一过程通过并查集实现。Kruskal部分套模板就可以了。

```cpp
#include <iostream> 
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int maxn = 500;

int n, m;
int x[maxn], y[maxn], f[maxn];
int ans = 0;

struct node {
    int x, y;
    int val;
}dis[50100];

bool cmp(node a, node b) {
    return a.val < b.val;
}

int find(int x) {
    int r = x;
    while(r != f[r]) r = f[r];
    int i = x, j;
    while(f[i] != r) {  
        j = f[i];  
        f[i] = r;  
        i = j;  
    }
    return r;  
}

void merge(int x, int y) {
	x = find(x);
	y = find(y);
	if(x != y) f[y] = x;
}

int main() {
	cin >> n >> m;
	for(int i = 1; i <= m; i++) {
		cin >> dis[i].x >> dis[i].y >> dis[i].val;
	}
	for(int i = 1; i <= n; i++) f[i] = i;
	
	sort(dis + 1, dis + m + 1, cmp);
	int tmp = 0, maxn = 0;
    for(int i = 1; i <= m; i++) {
        if(find(dis[i].x) != find(dis[i].y)) {
        	merge(dis[i].x, dis[i].y);
            tmp++;
            maxn = max(maxn, dis[i].val);
        }
        if(tmp == n - 1) break;
    }
    
    cout << tmp << ' ' << maxn;
}
```

---

## 作者：p0ny (赞：0)

在跑kruskal的时候，每次合并之后比较每条路上的权值，min一下就好了，比较水的题，附上代码。





```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;;
struct node {
    int u,v,w;
    bool operator < (const node &t) const {
        return w < t.w;
    }
} d[N];
int n,m,tot,fa[N],k,ans;
void add(int x,int y,int k) {
    d[++tot].u = x;     d[tot].v = y;    d[tot].w = k;
}
int find(int x) {
    return fa[x]==x ? x : fa[x] = find(fa[x]);
}
void kruskal() {
    for(int i=1; i<=n; i++) 
        fa[i] = i;
    for(int i=1; i<=tot; i++) {
        if(find(d[i].u)!=find(d[i].v)) {
            fa[find(d[i].u)] = find(d[i].v);
            ans = max(ans,d[i].w);
            k++;
        }
        if(k==n-1)
            break;
    }
}
int main() {
    scanf("%d %d",&n,&m);
    for(int i=1; i<=m; i++) {
        int x,y,k;
        scanf("%d %d %d",&x,&y,&k);
        add(x,y,k);
    }
    sort(d+1,d+1+tot);
    kruskal();
    printf("%d %d",k,ans);
    return 0;
}
```

---

## 作者：司徒stuart (赞：0)

我做了三道最小生成树 每一道题都让我发现我的智商多么低

大家一定要注意** 细心！！！**

我居然因为空格打的是全角WA了两遍 我真是。。。

至于这道题 没事拿来打打板子 第一问的话似乎都不用程序吧。。连接n个点就n-1条边就行了 第二问的话因为要问最大的一条边最小是多少 我开始居然还脑残的以为要用二分什么的 事实证明根本不用啊。。。我脑残 真的

ans直接就等于边的权值就可以了 也不用比较一遍了 毕竟是排过序的

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<functional>
#include<cmath>
#include<algorithm>
#define MAXN 200100
using namespace std;
int father[MAXN],ans=0;
int flag[MAXN];
priority_queue<int>q;
struct edge{
    int from,to;
    int value;
};edge Edge[MAXN];
bool cmp(edge x,edge y)
{
    return x.value<y.value;//比较函数 
}
int Find(int x)
{
    if(father[x]!=x)
    {
        father[x]=Find(father[x]);//路径压缩 
    }
    return father[x];
}
void Union(int x,int y)
{
    int fx=Find(x),fy=Find(y);
    if(fx!=fy)
    {
        father[fx]=fy;
    }
}
int main()
{
    memset(flag,1,sizeof(flag));
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        father[i]=i;//初始化一下 
    }
    for(int i=0;i<m;i++)
    {
        cin>>Edge[i].from>>Edge[i].to>>Edge[i].value;
    }
    sort(Edge,Edge+m,cmp);
    for(int i=0;i<m;i++)
    {
        int a=Edge[i].from,b=Edge[i].to;
        if(Find(a)!=Find(b))
        {
            Union(a,b);
            ans=Edge[i].value;//要是想在这里优化一下的话 就记录一下点的个数 然后break就好了 我是真的懒 
        }
    }
    cout<<n-1<<" "<<ans;
    return 0;
}
```

---

## 作者：panzheng1999 (赞：0)

模板题嘛，多写就好了233


一个kruskal，区别就是不需要算总价值，只需随时记录最大路径就好了，第一问（n-1），显然。。。


注意并查集要压缩路径，以免形成长链gg（TLE），就是合并祖先，把链变成蘑菇那样的伞状233


然后就没有什么了吧，ac愉快


```cpp
#include <iostream>
#include <queue>
#include <algorithm>
#include <cmath>
using namespace std;
int n,m;
int fa[305];
int ans;
struct stu
{
    int x;
    int y;
    int dis;
    friend bool operator < (const stu& a,const stu& b)
    {
        return a.dis>b.dis;
    }
};
priority_queue <stu> q;
int findset(int x)
{
    if(fa[x]==x) return x;
    else return fa[x]=findset(fa[x]);这样就压缩路径啦
}
void unionset(int x,int y)
{
    int fax=findset(x);
    int fay=findset(y);
    if(fax!=fay) fa[fax]=fay;
}
void kruskal()//个人喜欢优先队列存边，STL+1
{
    int nos=n;
    for(;;)
    {
        stu t=q.top();
        q.pop();
        if(findset(t.x)==findset(t.y)) continue;//已经在同一集合，不采用该路径，保证第一问为n-1
        unionset(t.x,t.y);//两点合并
        nos--;//集合变少
        ans=t.dis;//记录当前最长分量
        if(nos==1) return ;//只有一个集合，则全部联通
    } 
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) 
        fa[i]=i;
    stu t;
    for(int i=1;i<=m;i++)
    {   
       cin>>t.x>>t.y>>t.dis;
       q.push(t);//将边压入优先队列
    }
    kruskal();
    cout<<n-1<<" "<<ans<<endl;
}
```

---

## 作者：ww3113306 (赞：0)

感觉用kruskal算法会简单很多，但是前面wa了很多次，检查好久才发现其实是因为连接两个点时，不能只把其中一个点并入另一个点的集合，

而是要将其中一个点所属的整个集合都与其合并，所以，既然这样，合并的时候，就直接将两个根节点相连就可以了，不把一个根节点直接接在另一个点上是为了减小深度

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{//定义结构体
    int from,want,price;
};
int n,m;abc s[50010];int z[400];
int find(int x)//找到根节点
{
    while(z[x]!=x)
        x=z[x];
    return x;        
}
bool cmp(abc x,abc y)
{
    return x.price<y.price;
}
int main()
{
    int i,tot=0;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
        scanf("%d%d%d",&s[i].from,&s[i].want,&s[i].price);
    sort(s+1,s+m+1,cmp);//排序
    for(i=1;i<=n;i++)
        z[i]=i;
    for(i=1;i<=m;i++)
    {
        if(find(s[i].from)!=find(s[i].want)) //必须不在一个集合才能选
        {
            if(find(s[i].from)<find(s[i].want)) z[find(s[i].want)]=z[find(s[i].from)];//注意这里集合统一把根节点设为小的那个，防止陷入死循环，比如1的根节点是2，2的根节点是1，那到底谁是真正的根节点呢？显然没有，所以要统一一个标准防止这种情况发生，这个在我当初写并查集的时候坑了我好久o(╥﹏╥)o
            else z[find(s[i].from)]=z[find(s[i].want)];
            tot++;        //tot记录已经选择的边的个数
        }
        if(tot==n-1) //经过推理可以得出，连接n个点最少需要n-1条边，所以就不用判断是不是所有点都在一个集合，只要选择了n-1条边
```
{//并且没有出现环来浪费边的话，就一定可以连完n条边，这时就可以停下并输出了
```cpp
            printf("%d %d",n-1,s[i].price);
            break;
        }
    }
    return 0;
}
```

---

## 作者：浮尘ij (赞：0)

**prim算法**

算法我就不想讲了，网上有很多。

我想讲的是邻接表。

不会又懒得看数据结构书的小伙伴可以看一看。希望能有帮助 :)




    
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=310;
const int oo=1000000000; 
int tot,head[MAXN];//head[i]表示顶点i第一条边的编号 
int vis[MAXN];//当前最小生成树中有哪些点 vis[i]==1 表示在最小生成树中 
int dis[MAXN];//dis[i]表示当前最小生成树中的所有点到 i 的距离最小的那一个是多少 
int N,M;
struct als//我们需要给一个顶点发出的所有边编号，每条边只要记下一条边的编号，就可以知道这个顶点所有边 
{ 
    int next;//此顶点下一条边的编号 
    int to;//此顶点发出的这一条边的编号 
    int w; //此顶点发出的这一条边的权值 
}s[MAXN*MAXN];//邻接表 初学者建议用邻接矩阵。但邻接表在空间和时间上都比邻接矩阵更优 
//说明下，s的下标是边的编号，head的下标是点的序号。
//如果我们要扫描顶点i的所有边 ,通过head[i]就可以找到他的第一条边。然后通过这一条边记录的next（下一条边的编号）
//下一条边又记了下下一条边的编号，这样就可以找到i的所有边。
//怎么知道是最后一条边呢，很显然我们在加第一条边的时候他的next是0，所以我们可以以此判断 
void add(int x,int y,int z)
{
    s[++tot]=(als){head[x],y,z};head[x]=tot;
    s[++tot]=(als){head[y],x,z};head[y]=tot;
} //加边（无向边） 
void init()
{
    cin>>N>>M;
    for(int x,y,z,i=1;i<=M;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    for(int i=1;i<=N;i++)
        dis[i]=oo;//dia数组初始化 
}
void work()
{
    int ans=0;
    vis[1]=1;//从节点1开始，其实从哪个开始都一样。
    for(int i=head[1];i;i=s[i].next)//邻接表经典语句这里i的初值的是head[1],如果是head[j]就会把j发出的所有边扫一遍 
        dis[s[i].to]=s[i].w; 
    for(int i=1;i<N;i++)
    {
        int ID,minn=oo;
        for(int j=1;j<=N;j++)
        {
            if(!vis[j]&&dis[j]<minn)//如果节点j不在最小生成树里，并且从当前来看将他加入最优
            {ID=j;minn=dis[j];}//那么就把他的编号和需加入的边的权值记下来  
        }
        vis[ID]=1;
        ans=max(ans,minn);
        for(int j=head[ID];j;j=s[j].next)
```
{//既然新加入了顶点ID，那个也就意味着将一些点加入有权值更小的边可以选

```cpp
            int t=s[j].to,wi=s[j].w;
            if(!vis[t]&&dis[t]>wi) 
            dis[t]=wi;//更新dis的内容 
        }
    }
    cout<<N-1<<' '<<ans<<endl;
}
int main()
{
    init();
    work();
    return 0;
}
```

---

## 作者：Hydroxyl (赞：0)

prim的pascal算法 具体的那玩意我也就不说了我在另一题P2820（局域网）写了（刚提交可能没过）

首先有一个真的是非常棒的就是只要是全部联通就好了那么他的边数就是节点数-1 所以下面直接输出n-1就好了









```cpp
var d:array[0..1000] of longint;
    b:array[1..1000] of boolean;
    g:array[1..1000,1..1000] of longint;
    i,j,k,m,n,l,p,q,max,min,total,sum:longint;
procedure init;
begin
    assign(input,'city.in');
    reset(input);
    assign(output,'city.out');
    rewrite(output);
end;
begin
    init;
    readln(n,k);
    for total:=1 to k do
    begin
      readln(i,j,m);
      g[i,j]:=m; g[j,i]:=m;
    end;
    total:=0;
    filldword(d,sizeof(d)>>2,maxlongint>>1);
    fillchar(b,sizeof(b),true);
    d[1]:=0;
    for i:=1 to n do
    begin
      min:=maxlongint;
      for j:=1 to n do
      if b[j] and (d[j]<min) then 满足条件就好了
      begin
        min:=d[j];
    k:=j;
      end;
      b[k]:=false;
      inc(sum,min);    加一下延年益寿
      if min>max then max:=min;   比他大就赋值
      for j:=1 to n do
       if b[j] and (g[k,j]<d[j]) and (g[k,j]<>0) then d[j]:=g[k,j];   一定要加<>0那玩意 要不然原本都是maxlongint>>1 
   end;
   writeln(n-1,' ',max);    n-1看着非常棒 max顾名思义就是最大分值得那玩意
   close(output);
end.
```
这道题我也不多讲也就是把P2820的程序加了2行然后稍微修改了一下就好了
https://www.luogu.org/problem/show?pid=2820


---

## 作者：Mys_C_K (赞：0)

恩我注意到楼下都是用的最小生成树做的最小瓶颈树，这里贴一个用Floyd算法求点对最小瓶颈路的算法，再在其中找一个最大的即可。用Floyd算法求点对最小瓶颈路，用刘汝佳的话，就是“把Floyd算法中的‘之和’，'取最小值'改成'最大值'和'取最小值'”即可.

[codec]

```cpp
#include<iostream>
#include<algorithm>
#define INF 100000000
using namespace std;
int g[310][310];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j) g[i][j]=INF;
            else g[i][j]=0;
    for(int i=1;i<=m;i++)
    {
        int u,v;cin>>u>>v;
        cin>>g[u][v];
        g[v][u]=g[u][v];
    }
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(i!=k&&k!=j&&i!=j)
                    if(g[i][j]>max(g[i][k],g[k][j]))
                        g[i][j]=max(g[i][k],g[k][j]);
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(g[i][j]>ans) ans=g[i][j];
    cout<<n-1<<" "<<ans<<endl;
    return 0;
}
[\codec]
```

---

## 作者：空落离 (赞：0)

克罗斯卡尔算法

因为要求最短的路径

所以优先考虑权值小的边

但如果形成回路

反而会增加路程

所以先从小到大排序选取较小的边

判断它是否与已选取的边形成回路

直到找到n-1条边

```delphi
var
  n,i,j,m,ans:longint;
  a:array[1..50000,1..3]of longint;
  father:array[1..50000]of longint;
function getfather(v:longint):longint;//寻找根节点
begin
  if father[v]=v then
    exit(v);
  father[v]:=getfather(father[v]);
  exit(father[v]);
end;

procedure merge(x,y:longint);//合并两集合
var
  xx,yy:longint;
begin
  xx:=getfather(x);
  yy:=getfather(y);
  father[xx]:=yy;
end;

function judge(x,y:longint):boolean;//判断是否在一集合中
var
  xx,yy:longint;
begin
  xx:=getfather(x);
  yy:=getfather(y);
  exit(xx=yy);
end;

procedure sort(l,r: longint);//快排
 var i,j,x,y: longint;
 begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2,3];
   repeat
    while a[i,3]<x do
    inc(i);
    while x<a[j,3] do
     dec(j);
    if not(i>j) then
    begin
     y:=a[i,2];
     a[i,2]:=a[j,2];
     a[j,2]:=y;
     y:=a[i,1];
     a[i,1]:=a[j,1];
     a[j,1]:=y;
     y:=a[i,3];
     a[i,3]:=a[j,3];
     a[j,3]:=y;
     inc(i);
     j:=j-1;
     end;
   until i>j;
  if l<j then
  sort(l,j);
  if i<r then
  sort(i,r);
 end;

begin
 readln(m,n);
 for i:=1 to n do
 begin
 readln(a[i,1],a[i,2],a[i,3]);//读入
 father[i]:=i;//父节点数组初始化
 end;
 sort(1,n);//排序
 i:=0;
 repeat
 inc(i);
 if judge(a[i,1],a[i,2]) then continue//如果在一个集合就退出
 else begin//不在一个集合就合并
 inc(ans);
 merge(a[i,1],a[i,2]);
 end;
 until ans=m-1;//直到找出n-1条路
 writeln(ans,' ',a[i,3]);
end.

```

---

## 作者：Mr_Li (赞：0)

s很容易求出，无论数据具体是什么，s恒等于n-1；

max也比较容易求出，枚举边，判断所有分值小于等于它的分值的道路能够把所有的交叉路口直接或间接的连通起来，max即为所有符合条件的边分值最小的边的分值，判断用搜索即可。

附代码：

```cpp

#include<iostream>
using namespace std;
int n,m,i,j,u,v,map[301][301],answer=9999999;
bool YBI[301];
bool DFS (int maximum,int No=1)
{
    if (No==1)
    for (int i=1;i<=n;i++)
    YBI[i]=1;
    YBI[No]=0;
    for (int i=1;i<=n;i++)
    if (YBI[i]&&maximum>=map[No][i])
    DFS(maximum,i);
    for (int i=1;i<=n;i++)
    if (YBI[i])
    return 0;
    return 1;
}
int main ()
{
    cin>>n>>m;
    cout<<n-1;
    for (i=1;i<=n;i++)
    for (j=1;j<=n;j++)
    map[i][j]=9999999;
    for (i=1;i<=m;i++)
    {
        cin>>u>>v;
        cin>>map[u][v];
        map[v][u]=map[u][v];
    }
    for (i=1;i<=n;i++)
    for (j=1;j<=n;j++)
    if (map[i][j]<answer&&DFS(map[i][j]))
    answer=map[i][j];
    cout<<' '<<answer;
    return 0;
}

```

---

## 作者：魔君 (赞：0)

#\_因为这是一道模板题  所以不过多对kruskal算法进行说明 \_

#着重说明技巧







    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std; 
const int maxn = 309, maxm=50009;
int f[maxn]={0};
inline int read()
{
    int x=0;char a=getchar();
    while ( a<'0' || a>'9' )    a=getchar();
    while ( a>='0' && a<='9'){
        x=10*x+a-'0';    a=getchar();
    }
    return x;
}
inline int find(int x)
{
    return x==f[x] ? x:f[x]=find(f[x]);
}
//路径压缩形 的基本模板 身为一个ioer 你必须掌握
struct Point{
    int u,v,w;
}e[maxm];
inline bool cmp(const Point &x,const Point &y)
{
    return x.w<y.w;
}
//sort的比较函数 不加 会出现乱七八糟的报错 
int n,m;int mx=0;
void init()
{
    n=read();    m=read();
    for (int i = 1; i <= n; i++ )    f[i]=i;
    for (int i = 1; i <= m; i++)
    {
        e[i].u=read();e[i].v=read();e[i].w=read();
    }
}
inline bool merge(int u,int v)
{
    int x=find(u);int y=find(v);
    if (  x!=y )
    {
        f[x]=y;
        return true;
    }
    return false;
}
//判断 + 合并 
void solve()
{
    sort(e+1,e+m+1,cmp);
    int cnt= 0; 
    for (int i = 1; i <= m; i++)
    {
        if ( merge(e[i].u,e[i].v))
        {
            cnt++; 
            if ( mx < e[i].w )
                mx = e[i].w;
        }
        if ( cnt==n-1 )    break;
    }
}
int main()
{
//分段编写容易排错
    init();
    solve();
    printf("%d %d\n",n-1,mx);
    return 0;
}
```

---

## 作者：Jack_Homes_Huang (赞：0)

用kruskal的方法来求解最小生成树，

第一问不用多说，因为要连接n个点，最少就要n-1条边。。。。。。

Kruskal的并查集我百无聊赖的写了路径压缩和按秩合并。。。。。。

蒟蒻，，第一次写题解。










```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,ans;
int fa[2005],rk[2005];
struct node{
    int u,v,w;
} e[10005];
bool cmp(node x,node y){
    return x.w<y.w;
}
int find_set(int x){
    if (fa[x]!=x)
        fa[x]=find_set(fa[x]);
    return fa[x];
}
void Union(int x,int y){
    int root_x=find_set(x);
    int root_y=find_set(y);
    if (root_x==root_y)
        return;
    if (rk[x]<rk[y])
        fa[root_x]=root_y;
    else
    if (rk[x]>rk[y])
        fa[root_y]=root_x;
    else
        fa[root_x]=root_y,rk[y]++;
}
void Kruskal(){
    for (int i=1; i<=m; i++)
        if (find_set(e[i].u)!=find_set(e[i].v)){
            Union(e[i].u,e[i].v);
            ans=e[i].w;
        }
}
int main()
{
    freopen("city.in","r",stdin);
    freopen("city.out","w",stdout);
    scanf("%d%d",&n,&m);
    for (int i=1; i<=n; i++)
        fa[i]=i,rk[i]=0;
    for (int i=1; i<=m; i++)
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    sort(e+1,e+m+1,cmp);
    Kruskal();
    printf("%d %d\n",n-1,ans);
    return 0;
}
```

---


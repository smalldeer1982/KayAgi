# [HAOI2009] 逆序对数列

## 题目描述

对于一个数列 $\{a_i\}$，如果有 $i<j$ 且 $a_i>a_j$，那么我们称 $a_i$ 与 $a_j$ 为一对逆序对数。

若对于任意一个由 $1 \sim n$ 自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为 $k$ 的这样自然数数列到底有多少个？

## 说明/提示

**【样例说明】**

下列 $3$ 个数列逆序对数都为 $1$：分别是 $\{1,2,4,3\}$；$\{1,3,2,4\}$；$\{2,1,3,4\}$；

**【测试数据范围】**

- $30\%$ 的数据 $n\le 12$。

- $100\%$ 的数据 $n\le 1000$，$k\le 1000$。

## 样例 #1

### 输入

```
4 1```

### 输出

```
3```

# 题解

## 作者：ghj1222 (赞：141)

我们令$f[i][j]$表示$i$的全排列中，逆序数为$j$的个数。

我们考虑在$i-1$的排列中插入$i$。$k$是这次更新会导致增加多少逆序数。

则$\begin{aligned}{} f[i][j]=\sum_{k=0}^{\min(i-1,j)}f[i-1][j-k]\end{aligned}$

自我感觉上面的写法不清真，所以换一个清真的等价写法。

$\begin{aligned}{} f[i][j]=\sum_{k=max(0,j-i+1)}^{j}f[i-1][k]\end{aligned}$

复杂度：$O(nk^2)$，显然会tle。

我们观察这个式子，k是从0开始循环的，所以我们用前缀和优化dp。

我们开一个变量$\begin{aligned}sum=\sum_{k=max(0,j-i+1)}^jf[i][k]\end{aligned}$

每次j循环的时候让，把$f[i-1][j]$累加到$sum$，然后让$f[i][j]=sum$即可

但$sum$的求和区间是长度为i的一段f数组，当$j-i+1>=0$的时候sum求和区间的左端点也要离开0，向右移动了，所以加一个右面的$f[i-1][j]$，同时要判断sum的左端点是否大于0，如果是那么就减去左边的$f[i-1][j-i+1]$。(不理解？看下面)

```
欢迎收看新番：区间先生的旅程
这是我们的主人公[---]：区间先生，长度为5
[---]说他只是一个走过场的区间
t=0, ................
t=1, ]...............
t=2, -]..............
t=3, --].............
t=4, ---]............
t=5, [---]...........
t=6, .[---]..........//注意这里，区间先生的左端点脱离了0
t=7, ..[---].........//未完待续？？？
...
t=?, ...........[---]//因为我们只需要求到k，所以区间先生不用从右端离开，也就不用判断右端是否<=k了
```

这就是为什么要加一个if判断一下。

其实这个if可以放到前面的额不过懒得写了

复杂度:$O(nk)$

总结：以后我们发现有这种累加和的dp方程的时候可以考虑前缀和优化

代码

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

int n, k, p = 10000, f[1010][1010];

int main()
{
    scanf("%d%d", &n, &k);
    f[1][0] = 1;//初始条件，1的逆序为0，且只有1个排列
    for (int i = 2; i <= n; i++)
    {
        int sum = 0;
        for (int j = 0; j <= k; j++)
        {
            (sum += f[i - 1][j]) %= p;
            f[i][j] = sum;
            if(j >= i - 1)//如果j - i + 1>=0了，sum的求和区间左端点就>=0
                (((sum -= f[i - 1][j - i + 1]) %= p)+= p) %= p;
        }
    }
    printf("%d\n", f[n][k]);
    return 0;
}

```
让我们一起膜拜大佬陈独秀 [安利一发博客](http://www.cnblogs.com/olinr) 
空间 @[olinr](https://www.luogu.org/space/show?uid=88460)

还有楼下XKJ大佬

---

## 作者：leozhang (赞：78)

这篇题解主要针对本题的进阶问题，即当$n\leq 10^{5}$,$k\leq 10^{5}$时，$O(nk)$的dp也会超时，所以这里讨论一些进阶做法

首先我们考虑一个暴力的dp：

我们从小到大加入每个数，当我们加入第$i$个数时，可能产生的逆序对数量是$[0,i-1]$（这个证明考虑把第$i$个数放在哪即可），这样可以列出一个递推式：

设状态$dp[i][j]$表示已经加到了第$i$个数，此时的逆序对个数为$j$，那么有转移：$dp[i][j]=\sum_{k=j-i+1}^{j}dp[i-1][k]$

这个转移的时间复杂度是$O(n^{3})$

然后考虑优化，显然那个求和式可以用前缀和优化，时间复杂度降成$O(n^{2})$

这样已经可以通过本题了，但loj上的是加强版，过不去

考虑其他做法：

（如果您不喜欢多项式可以直接跳到解法2）

首先，考虑生成函数：对每个位置构造一个生成函数，那么最后的结论就是：

$F(x)=\prod_{i=0}^{n-1}(\sum_{j=0}^{i}x^{j})$

整理一下后面，就是：

$F(x)=\prod_{i=0}^{n-1}\frac{1-x^{i+1}}{1-x}$

然后整体合并一下，就得到：

$F(x)=\frac{\prod_{i=1}^{n}(1-x^{i})}{(1-x)^{n}}$

有点奇怪，两边取下对数：

$lnF(x)=\sum_{i=1}^{n}ln(1-x^{i})-nln(1-x)$

$ln(1-x^{i})$这个东西已经展开过很多次了...

对$ln(1-x^{i})$求导得到：

$\frac{-ix^{i-1}}{1-x^{i}}$

把下半部分恢复成等比数列求和的形式：

$-ix^{i-1}\sum_{j=0}^{∞}x^{ij}$

把外面的系数移进去：

$-\sum_{j=0}^{∞}ix^{ij+(i-1)}$

然后积分：

$\int -\sum_{j=0}^{∞}ix^{ij+(i-1)}=-\sum_{j=1}^{∞}\frac{i}{ij+i}x^{ij+i}$

约分一下，就得到了：

$-\sum_{j=0}^{∞}\frac{1}{j+1}x^{ij+i}$

令$j=j+1$，有：

$-\sum_{j=1}^{∞}\frac{1}{j}x^{ij}$

对一个函数先求导再积分得到的就是原函数，因此有：

$ln(1-x^{i})=-\sum_{j=1}^{∞}\frac{1}{j}x^{ij}$

这样的话可以通过枚举倍数做到$O(nlnn)$（即调和级数）求出系数，然后多项式exp即可，注意这里由于模数不好，需要用到MTT，总时间复杂度仍为$O(nlog_{2}n)$

其实后面的部分基本与这道题一致，基本步骤也相同

但是...由于过于毒瘤，我并不想写一遍...

（更何况还多了一大堆东西）

因此我们考虑做法二

原来的dp已经被压榨到足够优秀，剩下的部分很困难了，因此我们考虑转化问题：

回到最开始的思想：

我们从小到大加入每个数，当我们加入第$i$个数时，可能产生的逆序对数量是$[0,i-1]$

那么，如果我们设$x_{i}$表示加入第$i$个数时产生的逆序对数量，我们实际只是在解这个不定方程：

$\sum_{i=1}^{n}x_{i}=k$

其中对任意$i\in [1,n]$，有$x_{i}\in [0,i-1]$

我们实际是在求这个不定方程解的组数！

每个变量都有上界，这很不好求...

因此我们考虑容斥

我们不妨假设有某个位置不合法，设这个位置为$p$，那么显然有表达式：

$x_{p}\geq p-1$

那么我们考虑一个增量$\delta_{p}=x_{p}-p+1$，那么我们在等式两侧同时去掉这个增量，新的变量记作$x_{p}^{'}$，转化后的方程即为：

$x_{1}+x_{2}+...+x_{p}^{'}+...+x_{n}=k-\delta_{p}$

然而，在这种情况下，我们事实上仍然无法保证剩下的位置均合法，因此这样统计出的是有重复的！

据此，我们进一步分析：如果我们先统计出总的增量$\delta$，然后将这个增量分配给几个单独的$\delta_{p}$即可，然后用容斥原理计算就可以了

设状态$f[i][j]$表示用$i$个$[1,n]$之间的数求和，和为$j$的方案数，那么每一个总增量$\delta$对答案的贡献即为$C_{n+k-\delta-1}^{n-1}(\sum_{i=0}^{\sqrt{k}}(-1)^{i}f[i][\delta])$

为什么上界是$\sqrt{k}$？

考虑$m$个互不相同的数求和的最小值为$\frac{m(m+1)}{2}$，由于$\delta \leq k$，因此有效的数字个数应当是$\sqrt{k}$级别的

前面乘的组合数也就是剩下的那个不定方程的解的组数，后面是容斥方案数

这样的话我们只需计算出$f[i][j]$即可

考虑转移：由于我们要求数组中每个数都不同，所以可以把操作看成对数组中每个数加一，因此有转移：

$f[i][j]=f[i][j-i]+f[i-1][j-1]$

原理：如果元素个数不变，那么每个数加一之前的值即为$f[i][j-i]$

如果元素个数改变，那么一定是原数组中每个数加一之后再放下一个$1$，从$f[i-1][j-i]$转移过来

但是我们注意到，每个元素有一个上界就是$n$，但是这样直接算很有可能某个元素超过了$n$！

我们注意到每个元素+1的次数不能超过$n$，因此我们最后还需要去掉一个超过n的情况，也就是加上1之后某个数的大小超过$n$，变成了$n+1$！

最终的表达式即为$f[i][j]=f[i][j-i]+f[i-1][j-i]-f[i-1][j-n-1]$

这样这题就算做完了

当然其实还有方法三

生成函数结合容斥原理

考虑上面那个生成函数，发现我们要求的只是一个系数，因此我们考虑能不能直接搞出来

先考虑分母：

$\frac{1}{(1-x)^{n}}=(\sum_{i=0}^{\infty}x^{i})^{n}=\sum_{i=0}^{\infty} C_{n+i-1}^{n-1}x^{i}$

再考虑分子：

$\prod_{i=1}^{n}(1-x^{i})$

如果我们展开这个东西，那么$x^{i}$项前的系数即为用$j$个互不相同的$[1,n]$的数表示出$i$的方案数再乘一个$(-1)^{j}$

因此我们考虑直接计算这个东西

设状态$f[i][j]$表示用$i$个互不相同的数表示出和为$j$的方案数

然而由于选出的数不能重复，因此这个dp根本搞不了

考虑进一步转化问题：

如果我们给一个序呢？

我们设状态$f[i][j]$表示用$i$个互不相同的数表示出和为$j$的方案数，要求构造出序列{$a_{i}$}的是个上升序列

这样的话我们考虑对序列翻转后差分，设{$a_{i}$}是反转后的序列，令$b_{i}=a_{i}-a_{i+1}$，那么每个$b_{i}$对答案的贡献即为$ib_{i}$

这样的话我们只需构造出序列$b$即可

那么我们设状态$f[i][j]$表示已经放了$i$个$b$，总贡献为$j$的方案数，那么这个就有以下几个转移方向：

首先：个数不变，第$i$个$b$加一，那么他的贡献是$i$，因此$f[i][j]+=f[i][j-i]$

其次：个数改变，在位置$i$上放了个1，那么其共享仍为$i$，因此$f[i][j]+=f[i-1][j-i]$

但是，每个位置上的数都不应当超过$n$，但我们是逐次加1来增大的$b$序列，因此如果出现大于$n$的情况，那么一定是出现了$n+1$！

因此我们去掉这个$n+1$即可，转移即为$f[i][j]-=f[i-1][j-n-1]$

这样$f[i][j]$就搞出来了，可以发现这与最初的问题等价

这样我们最后卷积算出$k$位置的系数就好了

（可以看到方法二、三思想稍有区别，但殊途同归，代码其实是一样的qwq）

贴代码：

可以AC本题的dp方法：

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
const ll mode=10000;
ll dp[1005][1005];
ll s[1005][1005];
ll n,k;
int main()
{
	scanf("%lld%lld",&n,&k);
	dp[1][0]=1;
	for(int i=0;i<=k;i++)s[1][i]=1;
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=min(n*(n-1)/2,k);j++)
		{
			if(j-i<0)dp[i][j]=s[i-1][j];
			else dp[i][j]=(s[i-1][j]-s[i-1][j-i]+mode)%mode;
		}
		s[i][0]=dp[i][0];
		for(int j=1;j<=k;j++)s[i][j]=(s[i][j-1]+dp[i][j])%mode;
	}
	printf("%lld\n",dp[n][k]);
	return 0;
}
```

由于组合数使用线性筛逆元，而本题模数非质数所以估计不能AC，但是对于更大的数据范围仍然有效的lojAC代码：

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
const ll mode=1000000007;
const int lim=450;
ll inv[200005];
ll minv[200005];
ll mul[200005];
ll dp[455][100005];
ll n,k;
void init()
{
	inv[0]=inv[1]=mul[0]=mul[1]=minv[0]=minv[1]=1;
	for(int i=2;i<=200000;i++)
	{
		inv[i]=(mode-mode/i)*inv[mode%i]%mode;
		minv[i]=minv[i-1]*inv[i]%mode;
		mul[i]=mul[i-1]*i%mode;
	}
}
ll C(ll x,ll y)
{
	if(x<y)return 0;
	return mul[x]*minv[y]%mode*minv[x-y]%mode;
}
int main()
{
	init();
	scanf("%lld%lld",&n,&k);
	dp[0][0]=1;
	for(int i=1;i<=lim;i++)
	{
		for(int j=0;j<=k;j++)
		{
			if(j>=i)dp[i][j]=(dp[i][j-i]+dp[i-1][j-i])%mode;
			if(j>=n+1)dp[i][j]=(dp[i][j]+mode-dp[i-1][j-n-1])%mode;
		}
	}
	ll ans=0;
	for(int i=0;i<=k;i++)
	{
		ll temps=0;
		ll f=1;
		for(int j=0;j<=lim;j++)temps=(temps+f*dp[j][i]+mode)%mode,f=-f;
		temps=temps*C(n+k-i-1,n-1)%mode;
		ans=(ans+temps)%mode;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：yukuai26 (赞：30)

一道经典老题，山东2017集训出了n,k<=10w的题目，然后被机房毒瘤出题人抄来，虽然机房人都一眼秒了nk,但是机房2个集训队大佬就1个ac的，其他人。。nk暴力分拿了就跑。。。。

经过漫长的理解（看题解），我似乎终于懂了

这边主要是来讲一下一种全新的思路,可以做到k\*sqrt(k)

首先，从小往大加数，第i次加数可以使逆序对增加 0--n-1(套路),

那么我们有了一个不定方程

g1+g2+g3....+gn=k 0<=g[i]<i

接下来我们容斥考虑合法的解

设f[i][j]=表示i个数和为j的个数，显然i&1==1 时为-，0时为+

f[i][j]显然可以dp,我们考虑一个数列,可以所有数+1，当没有1时，插入一个1，

这样就可以dp了，可以发现因为 i\*(i+1)/2<=k，所以dp预处理的时间是k(sqrt(k))

对于每个f[i][j] 显然他就答案的贡献是

设m为和为k-j，n个元的不定方程解的个数

if (i&1) 贡献=f[i][j]\*m;

else 贡献=-f[i][j]\*m;

通过挡板法可以用组合数求解，这样就完美解决了


但是。。因为组合数的特性（代码中用了阶乘求逆元），山东集训的mod是1e9+7,这边是1w（不是素数，丧心病狂）。所以这边这个题解的代码无法过掉，（那边过了），所以就不要复制了哦，这仅仅是一个神奇的思路，当然，你可以复制我的再帮我手写ex卢卡斯和crt合并过掉此题。。

另外，机房集训队大佬说了一种n lon n 的多项式乘的做法，更加优秀（然而我并没有听懂）

希望会的人也来发题解，谢谢qaq

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <set>
#define ll long long
#define N 100005
#define inf 1000000005
#define mod 1000000007
#include <map>
//注意mod的修改
using namespace std;
int num,fac[N*2],inv[N*2];
inline int read(){
    char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}
    int sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}
int qpow(int a,int b){  
    int ans=1,tmp=a;  
    for(;b;b>>=1,tmp=1ll*tmp*tmp%mod)  
        if(b&1)ans=1ll*ans*tmp%mod;  
    return ans;  
}  
inline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}
inline void wrn(int x){wr(x);putchar('\n');}
inline void wri(int x){wr(x);putchar(' ');}
int C(int x,int y){  
    if(x>y)return 0;  
    return (ll)fac[y]*inv[x]%mod*inv[y-x]%mod;  
}  
//int nedge,Next[N*2],head[N],to[N*2];
//void add(int a,int b){nedge++;Next[nedge]=head[a];head[a]=nedge;to[nedge]=b;}
int n,m,sum,ans,f[500][N];
int main(){
    //freopen("reverse.in","r",stdin);
    //freopen("reverse.out","w",stdout);
    n=read();m=read();
    fac[0]=inv[0]=1;  
    for(int i=1;i<=n+m;i++)fac[i]=(ll)fac[i-1]*i%mod;  
    inv[n+m]=qpow(fac[n+m],mod-2);  
    for(int i=n+m-1;i;i--)inv[i]=(ll)inv[i+1]*(i+1)%mod;
    num=sqrt(m*2)+5;
    f[0][0]=1;
    for (int i=1;i<=num;i++){
        for (int j=i;j<=m;j++){
            f[i][j]=(f[i][j-i]+f[i-1][j-i])%mod;
            if (j>=n+1) f[i][j]=(f[i][j]-f[i-1][j-n-1])%mod;
        }
    }
    for (int i=0;i<=m;i++){
        sum=0;
        for (int j=0;j<=num;j++){
            if (j&1) sum-=f[j][i];
            else sum+=f[j][i];
            sum=(sum%mod+mod)%mod;
        }
        ans=(ans+(ll)sum*C(n-1,n+m-i-1))%mod;
    }
    wrn(ans);
    return 0;
}
```

---

## 作者：安好 (赞：20)

/\*
dp[i][j]表示i的排列中逆序对数为j的方案数

考虑i的放置,i为最大值,所以放在i-1个位置都可以计算出对答案的贡献

dp[i][j]=Σdp[i-1][k] (j-i+1 <=k<= j) 

特别的到i时最多可以贡献i-1对逆序对，所以从dp[0]~dp[j-i+1]这一段不能加

n^3超时，可用前缀和优化

貌似也可以滚动数组，但蒟蒻不会23333...

\*/




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1001
#define mod 10000
using namespace std;
int dp[N][N];
int n,k,ans,sum;
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) dp[i][0]=1;
    for(int i=2;i<=n;i++)
    {
        sum=0;
        for(int j=0;j<=k;j++)
        {
            (sum+=dp[i-1][j])%mod;
            dp[i][j]=sum%mod;
            if(j-i+1>=0)((sum-=dp[i-1][j-i+1])+=mod)%mod;
        }
    }
    printf("%d\n",dp[n][k]);
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：13)

用$dp[i][j]$ 表示$1-i$个数,逆序对数为j时的方案数

最后一个数字如果插在第$0$ 个位置,那么逆序对数将增加$i-1$对,插在第$1$个位置逆序对将增加$i-2$ 对.

于是可以很简单的推出状态转移方程了


```cpp
    for (int i=1;i<=n;i++)
    { 
        f[i][0]=1;
        for (int j=1;j<=k;j++)
        {
            for (int l=max(1,i-j);l<=i;l++)
            {
                f[i][j]+=f[i-1][j-i+l];
            }
            f[i][j]%=10000;
        }
    }
```

然后提交看一下是不是对的.


啥?! A了?! 这数据太水.


然后可以发现,每次转移都是某一段的和,然后可以用前缀和搞,这样每次转移就是O(1)


$s[i][j]$表示$f[i][0]$~$f[i][j]$的和


我分了2类,其实并不需要?因为出现了减法,所以取模的时候要注意下


```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(s>='0'&&s<='9'));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(s>='0'&&s<='9')
    {
        k=k*10+(s-'0');
        s=getchar();
    }
    return k*base;
}
void write(int x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10)write(x/10);
        putchar(x%10+'0');
    }
}
int n,k;
int f[1010][1010];
int s[1010][1010];//s[i][j]表示f[i][0]~f[i][j]的和
int main()
{
    n=read();k=read();
    for (int i=1;i<=n;i++)
    { 
        f[i][0]=1;
        s[i][0]=1; 
        for (int j=1;j<=k;j++)
        {
            
            /*for (int l=max(1,i-j);l<=i;l++)
            {
                f[i][j]+=f[i-1][j-i+l];
            }*///手推一下就可以推出来一下转移方程
            if (i-j<=1)
            {
                f[i][j]=((s[i-1][j]-s[i-1][j-i])%10000+10000)%10000;
            } else
            {
                f[i][j]=s[i-1][j];
            }
            s[i][j]=s[i][j-1]+f[i][j];
            s[i][j]=(s[i][j]%10000+10000)%10000;
            f[i][j]=(f[i][j]%10000+10000)%10000;
        }
    }
    printf("%d",f[n][k]);
    return 0;
}
```

A了,然后改数据,加极端数据.


极端数据啊,显然可以打表,那就再来两组大数据.


然后n^3的就过不了了


---

## 作者：望眼浮云 (赞：12)

~~双倍经验题！~~

切掉这题就可以切掉P1521了

首先设立状态：f[i][j] 表示i个数逆序对数量为j的个数

转移方程：f[i][j]=∑(s=0,1,...,i-1) f[i-1][j-s]

解释一下这个方程：当有i-1个数时，有j-1个逆序对时，添加第i个数，必有一个位置刚好使逆序对数+1，即可转移到f[i][j]。同理j-2,j-3……j-(i-1),因为只有i-1个数，所以最多到j-(i-1),当然也可能不增加逆序对，即j-0;

但是这样转移需要O(k)的复杂度，总复杂度为O(nk^2)，这是无法承受的。

下面用到前缀优化：

转移状态是连续的，我们可以记sum[i][j]=f[i][0]+f[i][1]+……+f[i][j];

转移方程就变为：f[i][j]=sum[i-1][j]-(j>i?sum[i-1][j-i]:0)

复杂度降为O(nk)，轻松水过去

代码极短：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[1005][1005],sum[10005]; //f[i][j] 表示i个数逆序对数量为j的个数，sum[i]记录前缀，这里优化了一下空间，减了一维
int main()
{
    scanf("%d%d",&n,&k);
    f[0][0]=1;  //初始状态
    for(int i=0;i<=k;i++) sum[i]=1;  //初始指为1
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
            if(j>=i) f[i][j]=(sum[j]-sum[j-i]+10000)%10000; //状态转移，要加10000再取模，不然可能小于0
            else f[i][j]=sum[j]%10000; 
        sum[0]=f[i][0]%10000;  
        for(int j=1;j<=k;j++)   
            sum[j]=(f[i][j]+sum[j-1])%10000; //更新sum，用于下一轮状态转移
    }
    printf("%d",f[n][k]);
}
```

---

## 作者：xyz32768 (赞：12)

在这里可以发现，逆序对的个数只与每个数的**相对大小**有关，而与真实数值无关。根据这一点，建立$DP$模型：

$f[i][j]$表示$i$个不同的数的所有排列中，逆序对数量为$j$的排列个数。边界为$f[1][0]=1$。

对于转移，可以想到枚举第$i$个数的**排名**进行计算，

即$f[i][j]=\sum_{k=j-i+1}^jf[i-1][k]$。

在实现上，转移的同时记录下前缀和以快速计算。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1005, PYZ = 1e4;
int n, K, f[N << 1][N << 1], sum[N];
int main() {
    int i, j; n = read(); K = read();
    f[1][0] = sum[1] = 1;
    for (j = 2; j <= K + 1; j++) sum[j] = 1;
    for (i = 2; i <= n; i++) {
        int mxf = min(K, (i * (i - 1)) >> 1);
        for (j = 0; j <= mxf; j++)
            f[i][j] = (sum[j + 1] -
                sum[max(0, j - i + 1)] + PYZ) % PYZ;
        sum[0] = 0;
        for (j = 0; j <= K; j++)
            sum[j + 1] = (sum[j] + f[i][j]) % PYZ;
    }
    printf("%d\n", f[n][K]);
    return 0;
}
```

---

## 作者：LightningUZ (赞：8)

emmm……先去吧P1521做了，那个题目好做。

然后，我们写出一个$O(n^3)$的暴力算法:

```cpp
#include<bits/stdc++.h>
#define mod 10000
using namespace std;
int dp[1200][1200];
int n,k;
void StateTransit(int a,int b)
//考虑新加入数字的插入位置
{
    for(int i=0;i<=min(a-1,b);i++)
    {
        dp[a][b]=(dp[a][b]+dp[a-1][b-i])%mod;
    }
}
int main()
{
    dp[0][0]=dp[1][0]=dp[2][0]=dp[2][1]=1;
    scanf("%d%d",&n,&k);
    for(int i=3;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
        {
            StateTransit(i,j);
        }
    }
    printf("%d\n",dp[n][k]);
    return 0;
}
```

这个是一个很显然的暴力。但是，交上去(with O2),90.

这告诉我们一个道理，卡卡常数就能过。

观察第11行的%运算，发现:

$dp[a][b]< mod$

$dp[a-1][b-i]< mod$

加起来，得:

$(dp[a][b]+dp[a-1][b-i])<2\times mod$

即最多也就会多出来1个mod，特判，减掉就可以了。

然后这就优化了%运算。

交上去(with O2),过了

Code:
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define mod 10000
using namespace std;
int dp[1200][1200];
int n,k;
void StateTransit(int a,int b)
{
    for(int i=0;i<=min(a-1,b);i++)
    {
        dp[a][b]=(dp[a][b]+dp[a-1][b-i]);
        if (dp[a][b]>mod)
        {
        	dp[a][b]-=mod;
		}
    }
}
int main()
{
    dp[0][0]=dp[1][0]=dp[2][0]=dp[2][1]=1;
    scanf("%d%d",&n,&k);
    for(int i=3;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
        {
            StateTransit(i,j);
        }
    }
    printf("%d\n",dp[n][k]);
    return 0;
}
```

---

## 作者：tcswuzb (赞：6)

这道题乍一看 逆序对 ？ 太好了

本来信心满满地打算用树状数组，归并排序再水一发

可是看完了题面 发现这与逆序对求法根本不沾边

------------------------------------吐槽时间---------------------------------------

现在有两种解法 

# ①搜索  + 玄学乱搞
 
忽略         ~~其实是我根本不会~~

# ②DP

f[i][j]表示1~i的数列 有j个逆序对的方案

考虑转移 

如果我们在一个玄学的1~i-1数列中随机插入i

那么我们可以产生0~i-1个逆序对

所以方案 就可以由上面过渡而来

```cpp
∴f[i][j]=∑f[i-1][j-k](0<=k<=i-1&&j-k>=0)
```

正如楼下所说

复杂度 O（nk^2）

个人认为 DP保证了最优解 却往往保证不了时间

∴考虑玄学优化

我们发现 这个累加 貌似可以用一个叫前缀和的东西优化

定义一个sum 每一次循环时

sum=f[i-1][j]+f[i-1][j-1]+...+f[i-1][j-i+1]

我们一边循环一边记录  直接用sum更新f[i-1][j-i+1]

```cpp
sum+=fi[i-1][j];
fi[i][j]=sum%mod;
if(j>=i-1) sum=(sum-fi[i-1][j-i+1]+mod)%mod;
```

这样时间复杂度被优化为O（nk）

弱弱的奉上代码 

# CODE：

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
#define mod 10000
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
int n,k,sum;
int fi[1010][1010];
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n);read(k);fi[1][0]=1;
    for(R int i=2;i<=n;++i){
    	sum=0;
    	for(R int j=0;j<=k;++j)
    	{
    		sum+=fi[i-1][j];
    		fi[i][j]=sum%mod;
    		if(j>=i-1) sum=(sum-fi[i-1][j-i+1]+mod)%mod;
    		//注意 减法取模 需要先加上模数 再取模 
		} 
	}
	printf("%d\n",fi[n][k]);
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

NOIP 2018 即将到来 

祝愿各位dalao   RP++ 

---

## 作者：COUPDETAT (赞：2)

刚刚看到这道题 突然想起教练讲过的线性代数

~~（wflight是一个线性代数大神，但这题跟线性代数并没有什么关系）~~

大家一定都会根据排列求逆序对数

那这题怎么做呢 换一个思路考虑
 
既然知道是**动态规划** 所以 必须找到前一个状态和这个状态之间的关系 

所以 假设我们知道了从$1 .. i-1$的全排列 现在要求$1..i$的全排列

考虑往已知排列中插入$i$ 可以得到$j$个逆序数
$$f[i][j]=f[i][j]+f[i-1][k](j>=k>=max(0*1ll,j-i+1))$$

我当时做的时候最大的困扰就是$k$的范围 后来仔细看了看大佬的题解明白了$k$是这次更新会导致增加多少逆序数。

### 30pts暴力（可能我玛丽有问题）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int f[1001][1001];
signed main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	f[i][0]=1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=i*i;j++)
	for(int k=max(0*1ll,j-i+1);k<=j;k++)
	{
		f[i][j]=(f[i][j]+f[i-1][k])%10000;
		
	}	
	cout<<f[n][k]%10000;
}
```


然后我打了个表找了规律

又看了看大佬的操作 发现k的循环可以用前缀和来优化 当然这里k的范围如上进行考虑 当求和的区间左端点离开0时 需要减去左端点到0的一段

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int f[1001][1001];
signed main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	f[i][0]=1;
	for (int i=2;i<=n;i++)
    {
        int sum=0;
        for(int j=0;j<=k;j++)
        {
            sum=(sum+f[i-1][j])%10000;
            f[i][j]=sum;
            if(j>=i-1)
            sum=(sum-f[i-1][j-i+1]+10000)%10000;
        }
    }
	cout<<f[n][k]%10000;
}
```




---

## 作者：风随逐影 (赞：1)

其实此题不需要前缀和优化，常数卡的好，O(N^3)随便过

先上两份代码
```c
#include<bits/stdc++.h>
using namespace std;
#define re register
#define go(i,a,b) for(int re i=a;i<=b;++i)
typedef long long ll;
const int mod=10000;
ll f[1005][1005];
int n,K;

int main(){
	//freopen("input.txt","r",stdin);
	scanf("%d%d",&n,&K);
	f[1][0]=1;
	go(i,2,n){
		go(j,0,K){
			go(k,0>j-i+1?0:j-i+1,j){
				f[i][j]+=f[i-1][k];
			}
			f[i][j]%=mod;
		}
	}
	printf("%lld",f[n][K]);
	return 0;
}
```
这是普通版，过最大的数据用时900ms，差点就挂了

保险起见，我们还有强化版
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define go(i,a,b) for(int re i=a;i<=b;++i)
typedef long long ll;
const int mod=10000;
ll f[1005][1005];
int n,K;

int main(){
	//freopen("input.txt","r",stdin);
	scanf("%d%d",&n,&K);
	f[1][0]=1;
	go(i,2,n){
		go(j,0,K){
			for(ll re *k=(0>j-i+1)?*(f+i-1):*(f+i-1)+j-i+1,*to=*(f+i-1)+j+1;k<to;++k){
				f[i][j]+=*k;
			}
			f[i][j]%=mod;
		}
	}
	printf("%lld",f[n][K]);
	return 0;
}
```
这份代码过最大的数据用时600ms，足以AC此题


---

## 作者：Baihua (赞：1)

### [题解] P2513 [HAOI2009]逆序对数列

动态规划，~~卡常数~~

---

[个人Blog](https://www.cnblogs.com/bj2002/p/10762857.html)

设$F[X][Y]$代表长度为$X$的序列，存在$Y$组逆序对的方案数量。

考虑$F[X][i]$向$F[X+1][i]$转移：

* 把数字$X+1$添加到序列的第$[1,X]$号位置上，可以增加$[0,X]$个逆序对。
* 注意逆序对的个数不能超过$\frac{N(N-1)}{2}$，其中$\text{N}$代表序列长度。

注意效率问题。

参考代码

```c++
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <iostream>
#define GC getchar()
#define Min(X,Y) ((X)<(Y)?(X):(Y))
#define Clean(X,K) memset(X,K,sizeof(X))
#define re register
const int Maxn = 1005 , Maxk = 1005 , P = 10000;
int F[Maxn][Maxk] , N , K /*, S[Maxn][Maxk]*/ ;
using namespace std ;
int main () {
    //  freopen ("P2513.in" , "r" , stdin) ;
    scanf ("%d%d" , &N , &K) ;
    Clean (F , 0) ,  /*Clean (S , 0) ,*/ F[0][0] = /*S[0][0] = */1 ;
    for (re int i = 0 ; i < N ; ++ i) {
        re int E1 =Min ((i * (i - 1)) / 2 , K) ;
        for (re int j = 0 ; j <= E1; ++ j) {
            re int E2 = Min (K - j , i) ;
            for (re int k = 0 ; k <= E2 ; ++ k) {
                F[i + 1][j + k] += F[i][j] ;
                while (F[i + 1][j + k] >= P) F[i + 1][j + k] -= P ;
            }
        }
    }
    printf ("%d\n" , F[N][K]) ;
    fclose (stdin) , fclose (stdout) ;
    return 0 ;
}
```

#### Thanks!

---

## 作者：Vin_1999 (赞：1)

f[i][j]表示前i个数有j个逆序对的数列个数，当前决策为插入第i个数（也就是这个数列中最大的数），则有i-1个位置可插，插入后产生相应的逆序对个数，即f[i][j]=sigma(f[i-1][j-k])(0<=k<i)；然而这是O(n^3)的，我们还需要前缀和优化一下，即sum=sigma(f[i-1][j-k]),转移至f[i][j+1]时sum=sum-f[i-1][j-(i-1)]\*(j-i+1>=0)+f[i-1][j+1]；

丑陋的代码如下：






```cpp
#include<bits/stdc++.h>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);++(i))
using namespace std;
const int maxn=1e3+7,mod=1e4;
static int dp[maxn][maxn],n,m,sum;
int main()
{
     scanf("%d%d",&n,&m);
     dp[1][0]=1;
     rep(i,2,n)
  {
      sum=0;
      rep(j,0,m)
      {
          (sum+=dp[i-1][j])%=mod;
         dp[i][j]=sum%mod;
         if(j-i+1>=0)((sum-=dp[i-1][j-i+1])+=mod)%mod;
       }
     }
  printf("%d",dp[n][m]);
  return 0;
}//by fjlyyz-ljy
```

---

## 作者：GhostCai (赞：1)

朴素思路，暴力做法。

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int n,k;

int f[1005][1005]={1};

int main(){
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;i++){
		for(register int j=0;j<=k;j++){
			int l=0;
			for(l=0;l<i-8;l+=8){	
				if(j<l) continue;
				f[i][j]+=f[i-1][j-l];
				if(j<l+1) continue;
				f[i][j]+=f[i-1][j-l-1];
				if(j<l+2) continue;
				f[i][j]+=f[i-1][j-l-2];
				if(j<l+3) continue;
				f[i][j]+=f[i-1][j-l-3];
				if(j<l+4) continue;
				f[i][j]+=f[i-1][j-l-4];
				if(j<l+5) continue;
				f[i][j]+=f[i-1][j-l-5];
				if(j<l+6) continue;
				f[i][j]+=f[i-1][j-l-6];
				if(j<l+7) continue;
				f[i][j]+=f[i-1][j-l-7];
			}
			for(l;l<i;l++){
				if(j<l) continue;
				f[i][j]+=f[i-1][j-l];
			}
			f[i][j]%=10000;
		}
	}
	printf("%d",f[n][k]);
	return 0;
}

```

---

## 作者：封禁用户 (赞：1)

一道加优化的DP题

var f,s:array[-10000..100001]of longint;//s是前缀和，f是递推数组

```cpp
i,j,k,m,n:longint;
function max(x,y:longint):longint;
begin
  if x>y then exit(x)else exit(y);
end;
begin
  read(n,m);
  f[0]:=1;
  for i:=1 to n do
  begin
    for j:=0 to m do s[j]:=s[j-1]+f[j];//处理前缀和
    for j:=m downto 1 do
    begin
      f[j]:=(f[j]+s[j-1])mod 10000;//开了滚动，f[j]表示当前层数j个前方案数缀和的
      if j>=i then f[j]:=(f[j]+10000-(s[j-i])mod 10000)mod 10000;//加上前i-1个数的和，由于mod了一个数，所以要+10000再做减法和mod
    end;
  end;
  write(f[m]);
end.
```

---

## 作者：Schwarzkopf_Henkal (赞：0)

大概就是[P1527](https://www.luogu.org/problem/P1521)的加强版？

由于这个问题里面是1-n的全排列，所以对于动态规划的转移便变得十分方便。（总感觉似曾相识？）

我们发现，我们往已有的序列中添加一个数，这个数一定大于已有序列中的所有数，所以如果放在最后，逆序对数量增加了0，放在倒数第二的位置，逆序对增加了1，如果放在了最前面则逆序对数量增加原序列的长度。

所以我们简单地定义状态为长度为$i$的序列中，混乱度为$j$的序列个数。状态转移方程为：
$$dp[i][j]+=dp[i-1][j-k](0<=k<=i-1\&j-k>=0)$$
（好像也似曾相识？）

最简单的版本很好想，这里不再放出代码，然后我们学习将原本$O(n^2m)$复杂度的算法利用前缀和加速成$O(nm)$。

我们发现，当前状态可以被一个连续的状态段摸到，也就是说，对于当前状态的更新需要加上一个连续的状态段的和，对于在$O(1)$时间里读取连续段的和，非常自然的，利用前缀和保存$i-1$的状态的前缀和。

不过，由于这个更新方程的特殊性，如果只使用一条滚动数组，更新前缀和值的时候会覆盖掉后面可能还需使用的值，如果倒序推导状态的话又对前缀和的导出极其不友好，可能需要另外循环一遍来导出前缀和，于是我采用了利用两个滚动数组反复横跳的方式来避免上述问题。（我考试的数据要是不用滚动数组会MLE）

代码如下。
```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
long long dp[2][5005],pre[2][5005],n,c;//滚动数组储存状态和前缀和。
bool p;
int main(){
    std::cin>>n>>c;
    dp[1][1]=1;//显然的，长度为1逆序对为0的个数为1。
    for(int j=1;j<=c+1;j++)
        pre[1][j]=1;//初始化
    for(int i=2;i<=n;i++){
        for(int j=1;j<=c+1;j++){ //为方便前缀和，我把逆序对数量都往上加了1
            dp[p][j]=(pre[!p][j]-pre[!p][max(j-i,0)]+10000)%10000;//调用前缀和
            pre[p][j]=(pre[p][j-1]+dp[p][j]+10000)%10000;//防止玄学模运算出现玄学错误。
        }//记录前缀和
        p=!p;//反复横跳
    }
    std::cout<<dp[!p][c+1];
}
```


---


# [SDOI2007] 小组队列

## 题目背景

嘛，这道非常简单的给大家提供信心的省选题洛谷居然没有！

这么简单的题怎么可以没有！

给大家提升士气是义不容辞的责任！

所以我就来补一下啦..

值得一提的是，标程是我自己做的..

很渣，因为数据很水所以能 AC..

大神勿喷..


## 题目描述

有 $m$ 个小组， $n$ 个元素，每个元素属于且仅属于一个小组。


支持以下操作：


`push x`：使元素 `x` 进队，如果前边有 `x` 所属小组的元素，`x` 会排到自己小组最后一个元素的下一个位置，否则 `x` 排到整个队列最后的位置。

`pop`：出队，弹出队头并输出出队元素，出队的方式和普通队列相同，即排在前边的元素先出队。


## 说明/提示

对于 $30\%$ 的数据，$1≤n≤100$，$1≤m≤10$，$T≤50$。

对于 $100\%$ 的数据，$1≤n≤100000$，$1≤m≤300$，$T≤100000$，输入保证操作合法。


## 样例 #1

### 输入

```
4 2
0 0 1 1
6
push 2
push 0
push 3
pop
pop
pop```

### 输出

```
2
3
0```

# 题解

## 作者：attack (赞：24)

第一次用到二维队列


用last来表示每一个小组内元素出现的顺序


q队列表示每一个小组出现的顺序


我们想一下，如果一个元素所属的小组在之前出现过


那么我们直接加到last队列里就好


这样可以保证按照小组的顺序输出


            
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
int read(int & n)
{
    char c='.';int x=0,flag=0;
    while(c<'0'||c>'9')
    {
        c=getchar();
        if(c=='-')flag=1;
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+(c-48);
        c=getchar();
    }
    if(flag==1)n=-x;
    else n=x;
}
const int MAXN=10000001;
queue<int>q,last[301];
int group[MAXN];
int main()
{
    int n,m,p,meiyong;
    read(n);read(meiyong);
    for(int i=0;i<n;i++)
        read(group[i]);
    read(m);
    for(int i=1;i<=m;i++)
    {
        string s;
        cin>>s;
        if(s=="push")
        {
            read(p);
            if(last[group[p]].empty())
            q.push(group[p]);
                last[group[p]].push(p);
        }
        else
        {
            printf("%d\n",last[q.front()].front());
            last[q.front()].pop();
            if(last[q.front()].empty())
            q.pop();
        }
    }
    return 0;
}
```

---

## 作者：Aliemo (赞：23)

# 这个题一看就是要用队列来做了！
push x：使元素 x 进队，如果前边有 x 所属小组的元素，x 会排到自己小组最后一个元素的下一个位置，否则 x 排到整个队列最后的位置。

pop：出队，弹出队头并输出出队元素，出队的方式和普通队列相同，即排在前边的元素先出队。
# 附图片（过程）
![](https://cdn.luogu.com.cn/upload/pic/61484.png)
小组反了（手贱，请原谅，2和3应该在1小组，0应该在0小组）
## 可以用char 读入（快）
### 我用的是总队列及分队列
##### 附代码(内有解释)

```cpp
#include <cstdio>       //头文件不解释
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <set>
#define rr register
using namespace std;
const int inf=0x7fffffff; //可以忽略
inline int read(){    //快读
	int s=0,m=0;
	char ch=getchar();
	while(!isdigit(ch)){m|=ch=='-';ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch^48);ch=getchar();}
	return m?-s:s;
}
int n,m,t;
int head,tail=1;      //总队头，队尾
int b[100005];        //总队列
int a[100005];        // 每个数的应是小组
int f[305][10005];    //分队的存储   分队是小组
int e[1005];          //分队的队头
int g[1005];          //分队的队尾
char c[1005];         //读入pop，push用
signed main(){
	n=read();
	m=read();
	for(rr int i=0;i<n;i++){
		int d=read();
		a[i]=d;	                  //读入，使第i个的组为d
	}
	t=read();
	for(rr int i=1;i<=t;i++){
		scanf("%s",c+1);    //用char比string快
		if(c[2]=='u'){       //是push的时候
			int d;
			d=read();
			if(e[a[d]]==0)         //如果此时的数没有队在总队列里
				b[++head]=a[d];    //存入总队列
			f[a[d]][++e[a[d]]]=d;  //存入分队列
		}
		if(c[2]=='o'&&tail<=head){     //是“pop”的时候
			printf("%d\n",f[b[tail]][++g[b[tail]]]);   //分队头++，输出
			if(g[b[tail]]==e[b[tail]]){            //弹完之后的操作
				e[b[tail]]=0;            //此时队列弹完了，需要下一个了
				g[b[tail]]=0;            //可忽略
				tail++;                  //总队头指向下一个
			}
		}
	}
}	
```
## 我们机房有一位大佬，打出了可以跑1e7的代码
##### 代码下↓

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<queue>
#define mmp make_pair
#define ll long long
#define M  100010
using namespace std;
int read() {
    int nm = 0, f = 1;
    char c = getchar();
    for(; !isdigit(c); c = getchar()) if(c == '-') f = -1;
    for(; isdigit(c); c = getchar()) nm = nm * 10 + c - '0';
    return nm * f;
}
int a[M], ver[M], l[M], r[M], belong[M], pre[M], n, m;
char s[M];
int cnt[M], tot;
int main() {
    n = read(), m = read();
    for(int i = 0; i < n; i++) a[i] = read();
    int t = read(), last = 0;
    while(t--) {
        scanf("%s", s + 1);
        if(s[2] == 'u') {
            int x = read();
            tot++;
            ver[tot] = x;
            if(!cnt[a[x]] || last == pre[a[x]]) {
                r[last] = tot;
                l[tot] = last;
                last = tot;
            } else {
                int y = pre[a[x]], z = r[y];
                r[y] = l[z] = tot;
                l[tot] = y, r[tot] = z;
            }
            pre[a[x]] = tot;
            cnt[a[x]]++;
        } else {
            int x = r[0];
            cnt[a[ver[x]]]--;
            cout << ver[x] << "\n";
            l[r[x]] = 0;
            r[0] = r[x];
            if(last == x) last = 0;
        }
    }

    return 0;
}
```
## 我们机房有一位大佬，用STL做了出来
##### 代码下↓

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<map>
#include<set>
#include<string>
#include<queue>
#define N 100010
using namespace std;
queue<int >q;
queue<int >Q[301];
int n,m,t,p[N];
string str,pu="push",po="pop";
int read() {
    int s=0,f=0;
    char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
    return f?-s:s;
}
int main() {
    n=read(),m=read();
    for(int i=0; i<n; i++) p[i]=read();
    m=read();
    int k=1,a;
    while(k<=m) {
        cin >> str;
        if(str == pu) {
            a=read();
            if(Q[p[a]].size() == 0)
                q.push(p[a]);
            Q[p[a]].push(a);
        } else if(str == po) {
            printf("%d\n",Q[q.front()].front());
            Q[q.front()].pop();
            if(Q[q.front()].empty()) q.pop();
        }
        k++;
    }
    return 0;
}
```

---

## 作者：aiyougege (赞：12)

#### Solution
我用了一种极其暴力的方法……

因为每个小组在队列中是连续的, 因此可以将其看成是一个整体……所以一个队列元素为每个小组的编号

用M个队列维护每个小组

- 当一个小组不在队列中时, 将其加入队列
- 当一个小组在队列首而且元素个数为0时将其退出队列

#### Code
```c++
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<queue>
#define N 100005
#define M 305
using namespace std;

int n,m,k;
queue<int>que[M];
queue<int>q;
int belong[N];

int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;++i)
        scanf("%d",&belong[i]);
    scanf("%d",&k);
    string str;
    while(k--){
        cin>>str;
        if(str=="push"){
            scanf("%d",&n);
            if(!que[belong[n]].size())q.push(belong[n]);
            que[belong[n]].push(n);
        }
        else {
            int temp=q.front();
            printf("%d\n",que[temp].front());
            que[temp].pop();
            if(que[temp].empty())q.pop();
        }
    }
    return 0;
}
```

---

## 作者：Cutest_Junior (赞：8)

## 题解 P2776 【[SDOI2007]小组队列】

### 题意

+ $n$ 个人属于 $m$ 个组；
+ 建一个数据结构，支持进队和出队；
+ 进队时，如果队中有同一个组的人，则排到同一组的最后一个人的后面，否则排到队尾；
+ 出队和普通队列一样；
+ $n\le100000$，$m\le300$。

### 解法

显然，在任意时刻，同一个组的人在队列中必定都是相连的。

1. 那就可以用 $m$ 个普通队列模拟各个组组内的情况（以下称为“组”）；
2. 再额外开一个普通队列模拟整个队列中小组分布情况（以下称为“队”）；
3. 入队时，若组内没人，在队尾插入这个组；无论原来是否有人，都把这个人插入到组尾；
4. 出队时，把队列中第一个组的第一个人出队，若出队后这个组没人了，则把这个组从队中弹出。

### 代码

```cpp
# include <iostream>
# include <queue>

using namespace std ;

const int N = 100005 ;
const int M = 305 ;

int arr [ N ] ;

struct Jump_Queue // 结构体模拟队列
{
    queue < int > que [ M ] ; // que [ 0 ] 模拟队，que [ 1 ] ~ que [ m ] 模拟组
    
    void push ( )
    {
        int x ;
        cin >> x ;
        
        if ( que [ arr [ x ] ] . empty ( ) ) // 若组内没人，在队尾插入这个组
        {
            que [ 0 ] . push ( arr [ x ] ) ;
        }
        que [ arr [ x ] ] . push ( x ) ; // 无论原来是否有人，都把这个人插入到组尾
    }
    
    void pop ( )
    {
        cout << que [ que [ 0 ] . front ( ) ] . front ( ) << endl ;
        que [ que [ 0 ] . front ( ) ] . pop ( ) ; // 把队列中第一个组的第一个人出队
        if ( que [ que [ 0 ] . front ( ) ] . empty ( ) ) // 若出队后这个组没人了
        {
            que [ 0 ] . pop ( ) ; // 则把这个组从队中弹出
        }
    }
};

int main ( )
{
    int n , m ;
    cin >> n >> m ;
    
    for ( int i = 0 ; i < n ; ++ i ) // 注意：人的编号是 0~n-1，我被坑了好多次
    {
        cin >> arr [ i ] ;
        arr [ i ] += 1 ; // 再次注意：组的编号是 0~m-1，而我使用 que [ 0 ] 表示队，所以在这里要强制改变编号
    }
    
    int t ;
    cin >> t ;
    
    Jump_Queue jump_queue ;
    
    for ( int i = 1 ; i <= t ; ++ i )
    {
        string str ;
        cin >> str ;
        
        if ( str == "push" )
        {
            jump_queue . push ( ) ;
        }
        else
        {
            jump_queue . pop ( ) ;
        }
    }
}
```

---

## 作者：bloodstalk (赞：7)

## 需要解决的问题

- 1.如何将小组中的元素插进去?

- 2.如何按顺序输入。

## 思路

显然，这个题的名字就是小组队列，并根据题意及样例，我们可以比较容易的想到队列这个东西。

首先我们知道，用一个队列肯定是不行的，因为队列不支持从中间插入一个数值；之后我们就看数据范围： $n \leq 10^6$ ，$m \leq 300$ 。那么我么转换思路，把每一个小组都当成一个队列，再单独给一个队列存储小组之间的顺序，这样，在我们输出的时候就按顺序输出就行了，如果这个小组里面的元素被弹空了，我们就把这个小组从队列中弹出。

## 注意事项

- 1.元素和小组的编号都是从 $0$ 开始；

- 2.if 语句的位置

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,t;
string st;
int group[100005];

queue <int> order;/*小组的顺序*/ 
queue <int> q[305];/*小组里元素的顺序*/ 

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n-1;i++)
		scanf("%d",&group[i]);/*注意从0开始，输入该元素所属的小组*/ 
	int x;
	scanf("%d\n",&t);
	for(int i=1;i<=t;i++)
	{
		cin >> st;
		if(st=="push")
		{
			scanf("%d",&x);
			int number=group[x];/*number存储输入进去的元素所在的小组*/ 
			if(q[number].empty()) order.push(number);/*注意if语句的位置，先判断是否该小组是否还没有元素，是的话就存入order队列中*/ 
			q[number].push(x);/*如果 if 语句在下面，就会导致if语句一定不成立，order里面没有元素，进而导致代码错误*/ 
		}
		if(st=="pop")
		{
			int dl=order.front();/*查找优先级最高的小组，也就是在队头的小组*/ 
			printf("%d\n",q[dl].front());/*输出*/ 
			q[dl].pop();/*弹出该元素*/ 
			if(q[dl].empty()) order.pop();/*如果这个小组空了，那么下一个该小组的元素进来后顺序就得往后边排了。因此，弹出该小组*/ 
		}
	}
	return 0;
}
```


---

## 作者：yi_fan0305 (赞：5)

读完题后，首先想到的是链表，但我不会指针，其次教练说过链表有时会很慢，因此只能放弃这个想法（说白了就是自己菜）。

再想到的就是队列，可以用队列来模拟，有一种并查集查找祖先的感觉（雾）。

定义两个队列，一号队列存小组，二号队列存小组的元素，入队操作，直接往二号队列中加即可，这里要判断一下这个小组是否在一号队列中，如果不在，为了能依据题意输出，入队；在的话就不用管他，因为整个小组在一号队列中放着，大顺序不受影响，也不违反题意，因此没有任何问题。

出队时，要判断第一个队列是否为空，如果空了，那它也就没用了，毕竟不能输出空队列，弹出即可。

代码如下，本人是一个很菜的蒟蒻，写的不好请见谅，大佬勿喷！

```cpp
#include<cstdio>//省略部分头文件
using namespace std;
int n,m,T;
string cz;
int fa[100100];
queue<int> l1;
queue<int> l2[500];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;++i)
	{
		scanf("%d",&fa[i]);
	}
	scanf("%d",&T);
	for(int x,i=1;i<=T;++i)
	{
		cin>>cz;
		if(cz=="push")
		{
			scanf("%d\n",&x);
			if(l2[fa[x]].empty())
			{
				l1.push(fa[x]);
			}	
			l2[fa[x]].push(x);
		}
		else
		{
			int u;
			u=l1.front();
			printf("%d\n",l2[u].front());
			l2[u].pop();
			if(l2[u].empty())	l1.pop();
		}
	}
	return 0;
}
```


---

## 作者：崔化博 (赞：4)


定义一个队列数组，以及一个队列，分别贮存小组里有多少元素和小组的个数。

输入完小组后，输入 $m$ 次字符串 $s$，判断字符串 $s$，如果是 "push"，就让**属于这个小组的队列插入，如果没有这个小组就让小组队列插入这个小组；否则，输出现在队列中第一个小组的元素，然后再让这个元素弹出，再判断如果这个小组没有元素了，就让这个小组弹出。**

最后献上代码：
```cpp
#include <cstdio>
#include <string> 
#include <queue>
#include <iostream>
using namespace std;

int main() {
	queue<int> s[301];
	queue<int> x;
	int m,n,a[100005];
	cin>>n>>m;
	for(int i=0;i<n;++i)
		cin>>a[i]; 
	int t;
	cin>>t;
	while(t--){
		string s1;
		cin>>s1;
		if(s1=="push"){
			int p;
			cin>>p;
			if(s[a[p]].empty())
				x.push(a[p]);
			s[a[p]].push(p);
		} 
		else{
			cout<<s[x.front()].front()<<endl;
			s[x.front()].pop();
			if(s[x.front()].empty())
				x.pop();
		}
	}
	return 0;
}
```

---

## 作者：baby_lu0 (赞：3)

这里利用了List来处理。

对于要加入到已有小组最后一个的后面的操作，如果暴力查找是不行的；
所以我们采用迭代器来记录。

并且对于pop的操作，很有可能原本的倒数第二个会变成最后一个，所以这些都需要保存。

同时为了方便去除掉第一个元素以及其对应在我们保存的已有小组的容器中的迭代器。

我们需要能够加到最后，同时也能删除最前面的一个容器。

deque双端队列是一个很好的办法
deque的操作:

void push_front(const T& x):双端队列头部增加一个元素X

void push_back(const T& x):双端队列尾部增加一个元素x

void pop_front():删除双端队列中最前一个元素


void pop_back():删除双端队列中最后一个元素

iterator begin():返回向量头指针，指向第一个元素

iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）

参考：https://blog.csdn.net/longshengguoji/article/details/8519812

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
int A[100010];
int flag[310];
list<int>List;
deque< list<int>::iterator >pos[100010];
list<int>::iterator it;

int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        int x;scanf("%d",&x);
        A[i]=x;
    }
    int T;bool ok=false;
    cin>>T;
    while(T--)
    {
        string s;
        cin>>s;
        if(s[1]=='u')
        {
            int x;
            scanf("%d",&x);
            if(!pos[A[x]].empty())
            {
                it=*(--pos[A[x]].end());
                it++;
                pos[A[x]].push_back(List.insert(it,x));
            }
            else
            {
                List.push_back(x);
                it=--List.end();
                pos[A[x]].push_back(it);
            }
        }
        else
        {
            it=List.begin();
            cout<<*it<<endl;
            pos[A[*it]].pop_front();
            List.pop_front();
        } 
    }
    //system("pause");
}
```


---

## 作者：__凉皮__ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2776)
[博客传送门](https://www.luogu.com.cn/blog/SamandNeber/solution-p2776)

**既然按小组入队，那何不把每一个小组都看成一个队列？**

那怎么**出队**和**输出**呢？

再开个数组**储存小组在数组中的顺序**不就完事了？

既然有了**思路**，那何不直接上**代码**呢？

# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAX 100001
queue<int> d1[301];//把每一个小组都看成一个队列。 
int a[MAX],d2[MAX],f[301];
//a[i]第i个元素所处的小组。	
//d2储存小组在整个队列中的顺序。 
//f[i]判断i组是否已在队列中。 
int main(){
	int n,m,last=0,x,first=1;//d2[first]为整个队列的队首的小组，last相反。 
	string s;
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>a[i];
	int t;
	cin>>t;
	while(t--){
		cin>>s;
		if(s=="push"){
			cin>>x;
			d1[a[x]].push(x);//x入队至他所在的小组。 
			if(!f[a[x]])d2[++last]=a[x];//如果x所在的小组还未入队，则将此小组入队。 
			f[a[x]]=1;//已经入队。 
		}
		else{
			cout<<d1[d2[first]].front()<<endl; 
			d1[d2[first]].pop();
			//队首的小组的队首出列。 
			if(d1[d2[first]].empty()){//如果这个队列空了。 
				f[d2[first]]=0; //则这个小组还未入队。 
				first++;//队首变为first+1。 
			}
		}
	}
}
```

---

## 作者：无解双八卦 (赞：2)

写这篇题解两个原因，一个是挂了好几次难受（打错一个字母），

一个是看到看到各种高端操作，蒻苟实在学不来，搞了静态链表。

首先这道题我一看往队列中插元素这不是链表？然后再一看数据范围好了开始写。

直接上代码+注释：

```cpp
#include<cstdio>
using namespace std;
int m[100000],lb[100000][2]={0},head[300]={0};//m记录小组，lb0记录数字，1记录后继指针，
//head记录链表中小组最后一个元素的位置，如果队列中没有小组元素就记0.（建议记-1）
int main()
{
    int n,k,t,l=1,r=1,t3=0;char c[5];//k是各处乱用的变量，l是该输出的位置，r是该输入的位置，t3是指向r的位置，也就是链表的最后一位
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++)
    scanf("%d",m+i);
    scanf("%d",&t);
    for(int i=0;i<t;i++)
    {
        scanf("%s",c);
        if(c[1]=='u')//push
        {
            scanf("%d",&k);
            lb[r][0]=k;//入队
            if(!head[m[k]])//队列中没有该小组元素
            {
                t3=r;lb[t3][1]=++r;//最后一位元素就是新加进来的
            }
            else//队列中有该小组元素
            {
                lb[t3][1]++;lb[r][1]=lb[head[m[k]]][1];//不管该小组是不是最后一个小组，都可以保证新的元素指向该指的位置
                if(t3==head[m[k]])t3=r;//如果是最后一个小组就改变最后一个元素的位置
                lb[head[m[k]]][1]=r++;
            }
            head[m[k]]=r-1;
        }
        else//pop
        {
            printf("%d\n",lb[l][0]);
            if(head[m[lb[l][0]]]==l)
            head[m[lb[l][0]]]=0;//如果是小组最后一个元素，就记录小组为空
            l=lb[l][1];
        }
    }
    return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：1)

# 基本思路

这道题 push 和 pop 都写脸上了，那肯定是用队列，首先我们要用 300 个队列来存放每一个小组的元素，然后需要用一个队列来存放每一个小组的顺序，根据给出的操作来模拟一下就好了。

### 蒟蒻的我一开始的错误

 1. 一开始我看了题，放到队列最后，那我直接把他放到最后一个有元素的小组的队列里面不就好了吗（当时病的不轻），一交， WA 8 个点。
 
 2. 注意题目里面下标都是从0开始的，当时我输入从一开始，怎么改都是 WA 8 个点（关键是我以为不是这个的问题，改了后面后全 WA 了）。
 
 ## 代码及注释
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
string s;//输入的操作指令 
queue<int>xz[310];//每一个小组里面的队列 
queue<int>dl;//dl队列来维护每一个小组的出现顺序 
int a[100010];//存放每一个元素的所在的小组 
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)//从0到n-1输入 
	cin>>a[i];//输入每一个元素所在的小组 
	cin>>t;//输入操作的数量 
	while(t--)
	{
		cin>>s;
		if(s[1]=='u')//push操作 
		{
			int x;
			cin>>x;//输入要加入的元素 
			if(!xz[a[x]].empty())//如果x所在的小组不为空 
				xz[a[x]].push(x);//放入小组的后面 
			else//x所在的小组是空的 
			{
				dl.push(a[x]);//把当前x的小组放入dl队列，表示x所在的小组有元素了 
				xz[a[x]].push(x);//把x放入他所在的小组 
			}
		}
		if(s[1]=='o')//pop操作 
		{
			int o=dl.front();//取出队头的小组编号 
			cout<<xz[o].front()<<endl;//输出当前小组的第一个元素 
			xz[o].pop();//弹出 
			if(xz[o].empty())//如果当前小组空了 
			dl.pop();//弹出该小组的编号 
		}
	}
	return 0;//好习惯 
}
```


---

## 作者：WanderingTrader (赞：1)

这题和 [UVA540 团体队列 Team Queue](/problem/UVA540) 一毛一样，都考察了一个“队列捆绑”的方法。  
### 题目分析&代码
因为
>如果前边有 x 所属小组的元素，x 会排到自己小组最后一个元素的下一个位置，否则 x 排到整个队列最后的位置。

所以在出队前，相同队伍的人是站在一起的。  
那我们不妨借用“分块”思想，把长队按队伍拆开，分别处理。  
用一个队列存放当前长队中 **队伍的顺序**  ：
```cpp
queue <int> Q;
```
然后用一个队列数组来存放 **每个队伍内部的顺序**：
```cpp
queue <int> T[N];
```
这样是不是方便很多呢？
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
queue <int> Q;
queue <int> T[N];
int a[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 0;i < n;++i)
		scanf("%d",a+i);
	int t;
	scanf("%d",&t);
	while(t--)
	{
		string str;
		cin >> str;
		int x;
		if(str == "pop")
		{
		}
		else
		{
			scanf("%d",&x);
		}
	}
	return 0;
}
```
如果str是`pop`的话，那么我们应该输出 (长队中的第一支队伍)中的第一个人的编号，并将其弹出，即：
```cpp
x = Q.front(); 
printf("%d\n",T[x].front());
T[x].pop();
```
而如果这时本支队伍为空怎么办？  

那直接把长队队头弹出不就行了么  
```cpp
if(T[x].empty()) 
	Q.pop();
```
而如果str是`push`的话，输入加入的人，然后在他的队伍中放入这个人即可
```cpp
scanf("%d",&x);
T[a[x]].push(x);
```
问题又来了，如果这支队伍本来不在长队里怎么办？  

>否则 x 排到整个队列最后的位置

那直接把这支队伍放入长队末尾就行了  
```cpp
scanf("%d",&x);
if(T[a[x]].empty())
	Q.push(a[x]);
T[a[x]].push(x);
```
结束了。  

全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
queue <int> Q;
queue <int> T[N];
int a[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 0;i < n;++i)
		scanf("%d",a+i);
	int t;
	scanf("%d",&t);
	while(t--)
	{
		string str;
		cin >> str;
		int x;
		if(str == "pop")
		{
			x = Q.front(); 
			printf("%d\n",T[x].front());
			T[x].pop();
			if(T[x].empty()) 
				Q.pop();
		}
		else
		{
			scanf("%d",&x);
			if(T[a[x]].empty())
				Q.push(a[x]);
			T[a[x]].push(x);
		}
	}
	return 0;
}
```
刘汝佳老师发明的这种巧妙方法，将长队化整为零，逐个击破，十分方便。

$$
\texttt{The\ End.}
$$

---

## 作者：Zofia (赞：1)

我比较菜，开2维队列模拟怕爆空间，就用链表水了一发。

每次push在小组对应的top -> head链头加，如果没有top就++Tail新建一个。

每次pop删从链尾删，如果删光了就把top清零。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,Q;

inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){f=-1;}ch=getchar();
	}while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);ch=getchar();
	}return x*f;
}

int Head,Tail;
int head[1000001];
int father[1000001],top[1000001];
struct node{
	int to,pnext;
}edge[10000001];
int ni;

inline void addedge(int f,int t){
	edge[++ni].to=t;
	edge[ni].pnext=head[f];
	head[f]=ni;
}

inline void push(int x){
	int fa=father[x];
	if(!top[fa]){top[fa]=++Tail;}
	addedge(top[fa],x);
}

inline int pop(){
	int fa=Head+1,re;
	if(edge[head[fa]].pnext){//还剩很多个.
		for(int i=head[fa];i;i=edge[i].pnext){
			int newe=edge[i].pnext;
			if(!edge[newe].pnext){
				re=edge[newe].to;
				edge[i].pnext=0;
			}
		}
	}else{//只剩一个.
		re=edge[head[fa]].to;
		head[fa]=0;
		top[father[re]]=0;
		Head++;
	}return re;
}

char s[5];

int main(){
	n=read();m=read();
	for(int i=0;i<n;i++){father[i]=read();}
	Q=read();
	for(int i=1;i<=Q;i++){
		scanf("%s",s+1);
		if(s[2]=='u'){push(read());}
		else{printf("%d\n",pop());}
	}return 0;
}
```
其实还可以加一个数组指向每条链的链尾，在此我就水掉了。。。

---

## 作者：名字好难取144 (赞：0)

积压在做题计划一个多月的题目 （~~因为我太菜了~~）


看了题解发现大佬们有用队列做的，蒟蒻表示非常膜拜。


不过，对于需要**在数组中间插入元素**，首先应该想到的是用**链表**来做啦！


## 思路

给大家提供一个用链表的思路。

这里我使用了 list。（STL 大法好）

**我们以左边为链表的头，右边为链表的尾。**


对于 push 操作，我们需要**反向遍历**一遍整个 list 链表。

为什么需要**反向遍历**呢？这样可以**在找到同一个组的数时插入待插入数并立刻退出遍历**，节省时间。

- 如果找到了一个数的编号和当前待插入的数的编号一样时，将待插入的数插入在当前遍历到的位置的后边。

- 如果遍历完了却找不到，将待插入的数插入在最右边（也就是链表的尾部）。

对于 pop 操作，直接弹出最左边（链表的头部）然后清除就好了。

这么简单？对！就是这么简单！

还有不懂的可以看一下代码~

如果你想尝试正向遍历，可以看看[这个。](https://www.luogu.com.cn/blog/name-666/post-111-post)

## 注意事项

在进行**反向遍历**时，如果使用了迭代器遍历（也只能用这个，除非你不用 list），在声明迭代器指针时请声明成这样：
```cpp 
list<int>::reverse_iterator it
```

不然**会！报！错！** 


[如果不像上面这样声明的话。](https://www.luogu.com.cn/discuss/378445)


## 代码

接下来是代码时间~


```cpp
//省略部分头文件
#include<list>  //这个头文件要记得打！
using namespace std;
const int N=5e5+10;

int n,m,cnt,cnt2,k;   
int a[N];
list<int> form;

int main()
{	
	cin>>n>>m;
	for(int i=0;i<n;++i) cin>>a[i];
	cin>>k;
	while(k--)
	{
		string s; int num;
		
		cin>>s;
		if(s=="push")
		{
			cin>>num;bool flag=0;
			if(form.empty())
			{
				form.push_back(num);
				continue;
			}
			for(list<int>::reverse_iterator it = form.rbegin(); it != form.rend();++it) //反向遍历
			{
				if(a[*it]==a[num]) 
				{
					flag=1;
					form.insert( it.base() , num );
					break;
				}
			}
			if(!flag) form.push_back(num); 
		}
		else 
		{
			cout<<form.front()<<"\n";
			if(!form.empty()) form.pop_front();
		}
	}
	return 0;
}
```




---


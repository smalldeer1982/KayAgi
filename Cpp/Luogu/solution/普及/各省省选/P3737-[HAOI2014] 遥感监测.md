# [HAOI2014] 遥感监测

## 题目描述

外星人指的是地球以外的智慧生命。外星人长的是不是与地球上的人一样并不重要，但起码应该符合我们目前对生命基本形式的认识。比如，我们所知的任何生命都离不开液态水，并且都是基于化学元素碳（C）的有机分子组合成的复杂有机体。

ZDM 实验室的天文学家们已经执著地观测 ZDM-99 星球十多年了，这个被称为“战神”的红色星球让他们如此着迷。在过去的十多年中，他们经常有一些令人激动的发现。ZDM-99 星球表面有着明显的明暗变化。对这些明暗区域，天文学家们已经细致地研究了很多年，并且绘制出了较为详尽的地图，那些暗区是陆地，而亮区则是湖泊和海洋。他们一直坚信有水的地方，一定有生命的痕迹。

这天晚上的观测条件实在是空前的好，ZDM-99 星球也十分明亮，不时呈现出若干个激光点，天文学家们推定这些激光点极有可能存在地球以外的智慧生命。遗憾的是仅持续很短的一段时间，这些激光点就消失了。

ZDM 实验室的射电望远镜观测的区域有限，只可以遥感检测到一个半径为 $R$ 的圆形区域。为了能同时能检测到所有的激光点，ZDM 实验室需要要在一个水平的直线上尽快地安装多个的射电望远镜来。

不妨设，这条安放射电望远镜的水平直线为 X 轴，ZDM-99 星球激光点就处在 $P_1(x_1,y_1),P_1(x_1,y_1),\cdots,P_1(x_n,y_n)$（忽略 Z 坐标）

 ![](https://cdn.luogu.com.cn/upload/pic/5206.png) 

ZDM 实验室的天文学家们想知道，至少需要安装多少个射电望远镜才能检测到所有激光点。


## 说明/提示

$1≤R≤50$，$1≤N≤100$，$-1000≤ X_i,Y_i ≤ 1000$， $|Y_i| ≤ R$。

保证输入都是整数。

## 样例 #1

### 输入

```
3 2
1 2
-3 1
2 1
```

### 输出

```
2```

# 题解

## 作者：PiCaHor (赞：10)

感觉楼上写麻烦了，这道题还是蛮经典的。首先如果从坐标出发的话显然太麻烦了，所以不妨反一下我们从每一个点出发，从坐标轴上找到能覆盖的这个点的最左的和最右的点（放遥感）。然后就变成了统计点数使得所有的线段都被覆盖--最小点覆盖  
至于这个直接贪一下就好了

```cpp
#include <bits/stdc++.h>
#define re register
using namespace std;

inline int read()
{
  int x=0,f=1;
  char c=getchar();
  while(c<'0' || c>'9')
  {
    if(c=='-') f=-1;
    c=getchar();
  }
  while(c<='9' && c>='0')
  {
    x=(x<<3)+(x<<1)+c-'0';
    c=getchar();
  }
  return x*f;
}

const double eps = 1e-6;
int n,r;

struct node
{
  double l,r;
} e[110];
int len;

inline void cal(int x,int y)
{
  double deta;
  deta=sqrt(r*r-y*y);
  e[++len].l=x*1.0-deta;
  e[len].r=x*1.0+deta;
}

bool cmp(node x,node y)
{
  return x.r<y.r;
}

int ans;
double loc;

int main()
{
  n=read(),r=read();
  for(re int i=1; i<=n; ++i)
  {
    int x=read(),y=read();
    cal(x,y);
  }

  sort(e+1,e+len+1,cmp);
  loc=e[1].r;
  ++ans;
  for(re int i=2; i<=len; ++i)
    if(loc+eps<e[i].l) ans++,loc=e[i].r;
  printf("%d\n",ans);
  return 0;
}

```

---

## 作者：liruixiong0101 (赞：8)

## P0 前言：
本题解有画图解析，作者美术不行，勿喷。
## P1 题意：
给你 $n$ 个在海上的激光点，你可以在陆地上建若干个放射电望远镜用来照射激光点，每个放射电望远镜的放射范围为一个以自己为圆心半径为 $r$ 的圆，请问最少需要多少个放射电望远镜。

## P2 思路：
贪心的想一想我们可以发现两点：  
一、建放射电望远镜的地方一定是陆地与海的分界线，否则肯定可以在往海边挪一挪使其更接近激光点。  
二、因为题目中没有提到无解的情况，所以放置 $n$ 个放射电望远镜一定可以照射到每一个激光点。

---

仔细看看题意，我们又可以发现，这道题十分像区间贪心，给你许多的区间让你求出最少需要多少个区间可以覆盖到所有点，只不过我们现在这个区间是平面的，不是线性的。  
> 那能不能把它转化成平面的呢？  
> 答案是可以。  

我们来画图理解一下。
![](https://cdn.luogu.com.cn/upload/image_hosting/7yymy5pe.png)
画完图你发现了吗，其实 $PQ$ 这条线段就是区间，$PQ$ 的长度就是区间的长度，这样就把平面的区间转化成了线性的区间。  
而 $PQ$ 怎么求呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/kd0xmj1d.png)
我们可以加几条辅助线，那么根据勾股定理，$P$ 在 $x$ 轴上的位置就变成了 $x-\sqrt{r^2-y^2}$，$Q$ 在 $x$ 轴上的位置同理为 $x+\sqrt{r^2-y^2}$，长度便是 $2\sqrt{r^2-y^2}$。

---

## P3 代码：
求出了所有的区间，便该贪心了，区间贪心不会的自己去搜，网上有很多区间贪心详解，各种区间贪心都有，这里只给代码了。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n , r , x , y , ans;
struct node{
	double l , r;
}a[1005];
double end_;
//a[i].l,a[i].r,end_都是double类型因为用到了勾股定理
//ans就是答案，最少需要用到的区间
bool cmp(node a , node b){
	return a.r < b.r;
}//按照左端点从小到大排序
int main(){
	cin >> n >> r;
	for(int i = 1; i <= n; i++){
		cin >> x >> y;
		double dis = sqrt(r * r - y * y);
		a[i].l = x - dis;
		a[i].r = x + dis;
		//算出上述PQ的距离
	}
	sort(a + 1 , a + 1 + n , cmp);
	ans++;
	end_ = a[1].r;
	for(int i = 2; i <= n; i++){
		if(a[i].l > end_){
			ans++;
			end_ = a[i].r;
			if(a[i].r == a[i + 1].l) i++;
		}
	}//区间贪心
	cout << ans;
	return 0;
}
```	

---

## 作者：米奇奇米 (赞：0)

## 这道题目是两倍经验题，两道题目一题是绿题，一题是蓝题，不解（逃。
[P3737 [HAOI2014]遥感监测](https://www.luogu.org/problemnew/show/P3737)

[P1325 雷达安装](https://www.luogu.org/problemnew/show/P1325)
### 题目大意：找出最少数量的雷达使得可以在以$d$为半径的圆中覆盖所有小岛

![](https://cdn.luogu.com.cn/upload/pic/55926.png
)
### $Solution:$
### 一眼**贪心**题呀，用数组$b[i].l$记录这个小岛到达$X$轴的最左端点，同理用$b[i].r$记录这个小岛到达$X$轴的最右端点，然后再以$r$为第一关键字排序，再来枚举两个圆是否有公共交点的位置，若有公共部分，则要增加一台雷达。

### 暴力枚举的时间复杂度大概为$O(n^2)$,看一下数据范围，$n<=10^3$,$O(n^2)$的时间复杂度显然不会暴炸，跑的飞快呀！

### 以下就贴代码了啊！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
struct nood1
{
    int x,y;
};
nood1 a[N];
struct nood2
{
    double l,r;
};
nood2 b[N];
inline bool cmp(nood2 x,nood2 y)
{
	return x.r<y.r;
}//以右端点为关键字排序
int n,d,ans,vis[N];
int main()
{
	scanf("%d%d",&n,&d);
	for(register int i=1;i<=n;i++)
	{
	    scanf("%d%d",&a[i].x,&a[i].y);
	    double Mid=(double)sqrt(d*d-a[i].y*a[i].y);
	    b[i].l=a[i].x-Mid;//记录每个雷达的最左端点
	    b[i].r=a[i].x+Mid;//记录每个雷达的最右端点
	}
	sort(b+1,b+n+1,cmp);
	for(register int i=1;i<=n;i++)
	{
		if(vis[i]==false)//如果已经收到雷达的控制
		{
			vis[i]=true;
			for(register int j=1;j<=n;j++)
			{
				if(vis[j]==false && b[i].r>=b[j].l)//如果有重叠部分
				{
					vis[j]=true;
				}
			}
			ans++;//答案累加
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Chorse (赞：0)

	
- 这道题代码量不大，但思维难度还是有的。下面我们进入正题：

- 由于每个圆的半径r是已知的，那么一个圆的覆盖范围自然是已知的

- 圆心恒在x轴上，因此圆心纵坐标恒为0

- 于是覆盖每个激光点Pi的圆的圆心横坐标o的取值范围就可用勾股定理求：

	1. x[i]：Pi横坐标，y[i]：Pi纵坐标

	2. 圆心与Pi的距离t=sqrt(r^2-y[i]^2)

	3. 覆盖Pi的圆的圆心的横坐标x[i]-t<=o<=x[i]+t

- 每个激光点现在都有一段**可覆盖圆心范围**，我们把它看成一条线段，圆心在这条线段内的圆都可以覆盖到这个点，也就是说只要保证每个激光点的可覆盖圆心范围上都至少有一个作为圆心的点

- 为了尽可能的少用望远镜（放置的圆心最少），有线段重合的部分我们可以筛去一些重合在该部分的线段，因为只要在重合部分有一个圆心，那么重合部分的所有线段所对应的激光点都能被覆盖到，那么筛法如下：

1. 一条长线段中包含了另外的一整条/更多短线段时，该包含线段应该筛去，因为只要短线段上有圆心，那么长线段所对应的激光点也能被覆盖

2. 然后，还剩下一些部分重合的线段，我们在x轴上从左到右依次贪心地把有重合的线段去重

- 于是我们会只剩下一些每一条中间都有间距的线段，那么线段数量即为所求

	总的来说，这道题就是**贪心+一点数学**

	下面放代码


```
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
struct node{int l,r;}p[105];
int n,r,x[105],y[105];
int cmp(node a,node b){return a.l<b.l;}
void prepare()
{
    int t=0;
    scanf("%d%d",&n,&r);
    for(int i=1;i<=n;i++)  //输入并把每个点的可覆盖圆心范围的线段预处理出来
    {
        scanf("%d%d",&x[i],&y[i]);
        t=sqrt(r*r-y[i]*y[i]);
        p[i].l=x[i]-t,p[i].r=x[i]+t;
    }
    sort(p+1,p+n+1,cmp); //以线段左端p[i].l为关键字排序，方便遍历
}
void work()
{
    int cnt=0,q[105],la[105],now=0; //q数组存筛去包含其他短线段的长线段所对应的P点的序号
    for(int i=1;i<=n;i++)
    {
        while(cnt>0 && p[q[cnt]].r>=p[i].r) cnt--; //若q中线段包含了现在枚举的线段i则在q中筛去该线段
        q[++cnt]=i;
    }
    la[0]=-1001;
    for(int i=1;i<=cnt;i++)
        if(p[q[i]].l>la[now]) la[++now]=p[q[i]].r; //筛去重合部分的线段
    printf("%d",now); 
}
int main()
{
    prepare(); //预处理
    work(); //筛选并输出
    return 0;
}
```

---

## 作者：立志成刁民 (赞：0)

**思路来源@剑阁泪
！
思路来源@剑阁泪
！
思路来源@剑阁泪**
其实这道题是贪心！ 贪心！  贪心！
根据勾股定理算出每个点的可被控制的左右区间。
然后就开始纯贪心
附上AC代码
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
struct pokemon
{
    double l,r; 
}a[4001000];
bool cmp(const pokemon &q,const pokemon &w)
{
    return q.l<w.l;
}
int main()
{ 
    int t=0;
	t++;
	int ans=0,n,R;
	double pos=-2147483645;
	scanf("%d%d",&n,&R);
	for(int i=1;i<=n;++i)
	{
		double x,y;
		scanf("%lf%lf",&x,&y);
		double o=sqrt(R*R-y*y);
		a[i].l=x-o;
		a[i].r=x+o;
	}	
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)
	{
		if(pos<a[i].l)
		{
			ans++;
			pos=a[i].r;
		}
		else
		{
			pos=min(pos,a[i].r);
		}
	}
	printf("%d",ans);		
}
```


---


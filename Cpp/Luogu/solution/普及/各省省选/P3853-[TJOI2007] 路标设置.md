# [TJOI2007] 路标设置

## 题目背景

B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。


## 题目描述

现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。


## 说明/提示

公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。

$50\%$ 的数据中，$2 \leq N \leq 100$，$0 \leq K \leq 100$。

$100\%$ 的数据中，$2 \leq N \leq 100000$, $0 \leq K \leq100000$。

$100\%$ 的数据中，$0 < L \leq 10000000$。

## 样例 #1

### 输入

```
101 2 1
0 101```

### 输出

```
51```

# 题解

## 作者：itandsoon (赞：144)

**此题为二分求最优解的模板**

对于任意一个给出的“空旷指数”G，我们应该怎样去判断它是否符合题目的意思呢？

我们可以想象，我们已知了这条路上的所有的路标，我们从头开始枚举两两相邻的路标的间距，如果大于G,那么已经不符合G为最大距离的条件了，**为了使G满足,我们就可以在前一个路标前面G米处加一个路标**，这样与前面一个就符合条件了，**再判断新设的路标和后面的路标是否距离小于G,如果不，继续重复操作设置新路标**

当新设的路标数已经超过题目所给最大增设值时，如果还有路标不满足G,但已经不能设置新路标了，所以该G值就不满足条件。相反，则G成立。

**注意到，如果一个“空旷指数”成立，那么可能存在比它更小的解，但如果一个“空旷指数”不成立，那么答案只能比该值更大**

确定了判断方法，我们就可以写二分的代码了：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int sit[100005];
int L,N,K;
inline bool check(int m)
{
	int y=K;
	int size=0;//确定当前的比较位置
	for(int i=1;i<N;i++)
	{
		if(y<0)
		{
			break;
		}
		if(sit[i]-size<=m)
		{
			size=sit[i];//成立则移动比较位置，比较下一组
		}
		else
		{
			size=size+m;//设置新的路标，前一个路标已满足，移动位置到新路标
			i--;//防止因为循环把之前的路标给移走了！
			y--;//减少可用新路标数
		}
	}
	if(y>=0)
	{
		return true;
	}
	return false;
}
int main()
{
	cin>>L>>N>>K;
	int t=0;
	while(t<N)
	{
		cin>>sit[t];
		t++;
	}
	int H=0,R=L;
	int ans;
	while(H<=R)
	{
		int mid=H+(R-H)/2;
		if(check(mid))
		{
			ans=mid;//记录
			R=mid-1;//可能存在更小的“空旷指数”，搜索左区间
		}
		else
		{
			H=mid+1;//答案只能是更大的“空旷指数”，搜索右区间
		}
	}
	cout<<ans;
}
```

---

## 作者：Mierstan085 (赞：29)

第十篇题解！

显然的二分答案。

不妨设置 $M$（mid）代表是否可以通过增设不超过 $k$ 个路标，使最大的间隔不超过 $M$，如果可以就向下缩并记录答案，否则就向上缩。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100005];

int main(){
    int r, n, k;
    cin >> r >> n >> k;
    
    for (int i = 0; i < n; i ++){
        cin >> a[i];
    }
    
    int ans = -1, l = 1;
    while (l <= r){
        int M = l + r >> 1;
        
        int m = 0;
        for (int i = 0; i < n; i ++){
            int tmp = a[i] - a[i - 1];
            if (tmp > M) m += (tmp - 1) / M;
        }
        
        if (m <= k){
            ans =  M;
            r = M - 1;
        }else l = M + 1;
    }
    
    cout << ans;
}
```

---

## 作者：xiao_dong_xi (赞：20)

[题目传送门](https://www.luogu.com.cn/problem/P3853)

### 问题简化
政府在一条长度为 $l$ 的公路上放置 $n$ 个路标，并且最多可以增设 $k$ 个路标。目标是找到一个最小的最大间隔，使得所有相邻路标之间的间隔不超过这个最大间隔。
### 解题思路
我们要找到一个最小的最大间隔，使得所有相邻路标之间的间隔不超过这个值。

我们可以通过增设最多 $k$ 个路标来达到这个目标。

考虑使用二分查找的方法来找到这个最小的最大间隔。

**代码核心**

每次循环计算中间值 $mid$。

通过遍历 $a$ 数组，计算相邻路标之间的间隔 $flag$。

如果间隔大于中间值，则需要增加的路标数 $\dfrac{flag-1}{mid}$。

累计需要增加的路标数 $m$。

如果 $m$ 不超过 $k$，说明该中间值是可行的，更新答案并将 $r \rightarrow mid - 1$。

如果 $m$ 超过 $k$，说明该中间值不可行，将 $l \rightarrow mid + 1$。

### 奉上极简代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, l = 1, r, ans;//记得初始化 l
int a[100001];
int main()
{
    cin >> r >> n >> k;
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    while (l <= r) {
        int mid = l + (r - l) / 2;
        //判断是否可以通过增设不超过 k 个路标，使得最大间隔不超过 mid
        int m = 0;
        for (int i = 1; i < n; i++) {
            int flag = a[i] - a[i - 1];
            if (flag > mid) m += (flag - 1) / mid; //计算需要增设的路标数量
        }
		// 如果可以通过增设不超过 k 个路标满足条件，则更新答案并缩小搜索范围 
        if (m <= k) {
            ans = mid;
            r = mid - 1;
        } else l = mid + 1;
    }
    cout << ans;
    return 0;
}

```

---

## 作者：Su777 (赞：15)

[返回题目](https://www.luogu.com.cn/problem/P3853)

**题意**：数轴上 $[0,L]$ 区间内有 $n$ 个点，它们的坐标分别为 $a_1,a_2,\dots,a_n$（递增排列），把数轴上相邻两点的最大距离定义为该数轴的“空旷指数”。现在要增加 $k$ 个点，使得该数轴的“空旷指数”最小。求这个最小的空旷指数。

**错误解法**：记 $b_k=a_{k+1}-a_k\ (1\leq k<n)$，将所有的 $b_i$ 加入大根堆中，每次取出堆顶 $x$，将其分割成 $\lfloor \cfrac{x}{2} \rfloor$ 和 $\lceil \cfrac{x}{2} \rceil$ 后丢回大根堆。最后取堆顶作为答案。

**反例及原因**：$L=101,n=3,k=2,a=\{0,96,101\}$，正确答案为 $32$，而该解法答案为 $48$。正确解法的方案是用两个新增的点来**三等分** $[0,96]$ 这个区间，把 $96$ 这一段分割成 $32,32,32$。而该错误解法会将这一段先二等分，再把这一段的一半二等分，把 $96$ 分割成 $48,24,24$，显然要劣于最优解。错误的关键之处在于只有对半分，忽略了三等分、四等分等情况。

**正确解法**：二分答案。如果一个空旷指数 $x$ 是可以的，那么所有 $>x$ 的空旷指数也都是可以的，也就是本题答案**满足单调性**。判定答案可行性：对于一个可能的答案 $q$ 尽量让放置的相邻两点的距离**恰好等于** $q$。假设两点之间距离为 $l$，则两点之间需要增加的新点个数为 $\lfloor \cfrac{l-1}{q} \rfloor$。细节注意二分区间为 $[1,L]$ 而非 $[0,L]$，否则会出现除以 $0$ RE 的情况。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int L, n, k, p[N];
bool check(int q) {
	int res = 0;
	for (int i = 1; i < n; i ++) {
		res += (p[i+1] - p[i] - 1) / q;
	}
	return res <= k;
}

int main() {
	cin >> L >> n >> k;
	for (int i = 1; i <= n; i ++) cin >> p[i];
	int l = 1, r = L, ans = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(mid)) {
			ans = mid;
			r = mid - 1;
		} else l = mid + 1;
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：xuchenxi (赞：11)

**[题目传送门：P3853](https://www.luogu.com.cn/problem/P3853)**

## **典型的二分答案**

**空旷指数**表示所有相邻路标之间的最大距离。

题目的答案就是最大距离的最小值。

二分查找最小的空旷指数满足只添加不超过题目要求即可。

**AC code**

```
#include<bits/stdc++.h>
using namespace std;
int n,k,l;
int a[100005];
bool check(int x) {
	int ret=0;
	if(x==0) return 0;
	for(int i=1;i<n;i++)
		ret+=(a[i+1]-a[i]-1)/x;
	return ret<=k;
}
int fen(){
	int le=0,r=l;
	while(le<r){
		int mid=(le+r)/2;
		if(check(mid)) r=mid;
		else le=mid+1;
	}
	return le;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);	cout.tie(0);
	cin>>l>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	cout<<fen();
	return 0;
} 
```
完结撒花

---

## 作者：shenziqi (赞：5)

这是我的第二篇题解，求管理员通过。

**思路：** 这道题其实就是用二分方法，对路标的空旷指数进行枚举，如果两个路段的空旷指数足够，那么就在那增加一个路标，一边记录答案，最后输出答案即可。

#### [题目传送门](https://www.luogu.com.cn/problem/P3853)

## AC代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 100007
using namespace std ;
int s , n , k , a[MAXN] , ans ;
bool check(int x){
	int c = k , m = 0 ;
	for(int i = 1 ; i < n ; i ++){
		if(c < 0){			//不用装路标了，直接退出。 
			break ;
		}if(a[i] - m <= x){		//判断距离够不够
			m = a[i] ;
		}else{
			m += x ;
			i -- ;
			c -- ;
		}
	}if(c >= 0){
		return 1 ;
	}else{
		return 0 ;
	}
}int main(){
	scanf("%d %d %d" , &s , &n , &k) ;
	for(int i = 0 ; i < n ; i ++){
		scanf("%d" , &a[i]) ;
	}
	int l = 0 , r = s ;
	while(l <= r){		//二分代码
		int mid = (l + r) >> 1 ;
		if(check(mid)){
			ans = mid , r = mid - 1 ;
		}else{
			l = mid + 1 ;
		}
	}
	cout << ans ;
	return 0 ;	//好习惯
}
```

---

## 作者：__Cyn__ (赞：5)

思路：我们用二分枚举每一个答案，如果两个路标之间的一段路大于答案，那就新增一个路标，将可用路标数减 $1$，最后计算可用路标是否被用完即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005], n, c, k;
inline bool check (int m) {
	int cishu = k;
	int mu = 0;
	for (int i = 2; i <= n; i++) {
		if (cishu < 0) break;
		if (a[i] - mu <= m) mu = a[i];
		else {
			mu += m;
			i--;
			cishu--;
		}
	}
	if (cishu >= 0) return 1;
	return 0;
}
int main () {
	cin >> c >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	//sort (a + 1, a + n + 1);
	int l = 0, r = c, minx;
	while (l <= r) {
		int mid = l + (r - l) / 2;
		if (check (mid)) minx = mid, r = mid - 1;
		else l = mid + 1;
	}
	cout << minx;
	return 0;
} 
```

---

## 作者：keep_shining (赞：4)

竟然还能提交题解，那我赶紧来一发。

## 思路：

由于空旷指数越大，所需路标越少，所以具有单调性，可以用二分来解决。

那我们就可以二分求一下空旷指数，然后根据空旷指数去求需要增多少个路标，判断是否比 $K$ 小，如果小于或等于就记录答案并扩大空旷指数（其实等于的话答案就是目前的空旷指数），否则就缩小空旷指数。

二分很好写，套个板子，那里面的检查函数该怎么写呢？

我们注意到如果 $a_i$ 和 $a_{i-1}$ 之间的距离，也就是两相邻路标之间的距离小于当前的空旷指数，那么我们就不用放路标了，否则我们要放两者之间的距离除以当前空旷指数个路标，综上所述，我们的检查函数可以这么写（也有别的写法）：

```cpp
bool check(int x)
{
	int c=0;//需要的路标个数
	For(i,2,n)if(a[i]-a[i-1]>x)c+=(a[i]-a[i-1]-1)/x;//如果两路标之间的距离大于当前的空旷指数，就加上距离除以空旷指数个路标
	if(c>k)return false;//大于 k 就不行
	return true;
}
```
至此，所有问题就都解决了，下面是完整代码。

## code：
```cpp
#include<bits/stdc++.h>

using namespace std;

#define fst ios::sync_with_stdio(false);cin.tie();cout.tie();
#define Endl endl
#define itn int
#define For(i,a,b) for(int i=a;i<=b;i++)
#define rep(i,a,b) for(int i=a;i>=b;i--)

const int N=1e5+5;
const int P=1e9+7;

int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}

void write(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}

int l,n,k,a[N],ans; 

bool check(int x)
{
	int c=0;//需要的路标个数
	For(i,2,n)if(a[i]-a[i-1]>x)c+=(a[i]-a[i-1]-1)/x;//如果两路标之间的距离大于当前的空旷指数，就加上距离除以空旷指数个路标
	if(c>k)return false;//大于 k 就不行
	return true;
}

int main()
{
	cin>>l>>n>>k;
	For(i,1,n)a[i]=read();
	int t=1,r=l;
	while(t<=r)//二分板子，由于题目中有一个l，我就换了个变量
	{
		int mid=(t+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else t=mid+1;
	}
	cout<<ans;
    return 0;
}

```

---

## 作者：Turtle1208 (赞：4)

思路：二分答案。

依题意写出一个检查函数来检查你每次二分的 $k$ 。如果 $k$ 可行，则把答案更新并且把右端 $r$ 向下缩查看是否有更小的答案。如果 $k$ 不可行，则向上缩，检查比 $k$ 更大的答案。

**AC Code**

```cpp
#include<iostream>
#define int long long
using namespace std;
int a[100010];
int n, m, z;
bool chk(int k)
{
    int y = z, now = 0;
    for(int i = 2; i <= n; i++)
    {
        if(y < 0) break;
        if(a[i] - now <= k) now = a[i];
        else 
        {
            now += k;
            i--;
            y--;
        }
    }
    return y >= 0;
}
signed main() //因为用了define int long long所以要用signed。
{
    cin >> m >> n >> z;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    int l = 0, r = m, ans;
    while(l <= r)
    {
        int k = (l + r) / 2;
        if(chk(k)) r = k - 1, ans = k;
        else l = k + 1;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

### 思路
二分答案。既然是二分答案，就要思考如何判断一个答案是否成立。   
对于本题，判断一个空旷指数 $x$ 是否成立，只需在每两个路标之间，每隔 $x-1$ 个单位距离增设一个路标，并在此过程中，统计增设路标数量 $tot$，若 $tot \leq k$，则该空旷指数 $x$ 成立。

### AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int L=1e7+7,N=1e5+7,K=1e6+7;
int l,n,k,a[N];

bool check(int x){
	int tot=0;    //统计增设路标数量。
	for(int i=2;i<=n;++i)
		if(a[i]-a[i-1]>x)
			tot+=(a[i]-a[i-1]-1)/x;    
			//减 1 避免了 (a[i]-a[i-1]) 为 x 的倍数时，答案会被多统计 1 的问题。
	if(tot<=k)
		return true;
	return false;
}

signed main(){
	scanf("%lld%lld%lld",&l,&n,&k);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	int lt=1,rt=l,ans;
	//lt 要设为 1，不然过不了 hack。（ check(0) 会因为 0 做除数而 RE ）
	while(lt<=rt){
		int mid=(lt+rt)/2;
		if(check(mid))
			ans=mid,rt=mid-1;
		else lt=mid+1;
	}
	cout<<ans;
	return 0;
}

``````

---

## 作者：封禁用户 (赞：0)

### 题意
>一条长度为 $l$ 的公路上已有 $n$ 个路标，且最多可以增设   $k$ 个路标。目标是找到一个最小 $x$，使得所有相邻路标之间的间隔不超过 $x$。
### 思路
我观察了一会题目~~看了标签~~后，发现要用二分。打完二分模版后，就是最重要的 check。
#### check
每次找到一个新的空旷指数时，我们都遍历一遍 $s$ 数组，如果有一次间隔 $f$ 比新的空旷指数大，则我们需要增添 $\dfrac{f-1}{mid}$ 个路标。最后再看路标是否超过了 $k$，以此判断该动 $l$ 还是 $r$。
### ~~你们最喜欢的~~代码部分
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int l,n,k,s[100001],ans;//s代表以前的路标，ans答案
int check(int x){
	int f,sum=0;//k_k_z_s是两路标间的距离，sum是需增添的路标数量
	for(int i=1;i<=n;i++){
		f=s[i]-s[i-1];
		if(f>x)
			sum+=(f-1)/x;//计算需要增添的路标数量
	}
	return sum;
}
signed main(){//由于上面我们将int变为了long long，所以这里不能用“int main”，而要用“signed main”。
	std::ios::sync_with_stdio(0);//快读
	cin>>l>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>s[i];
//--------------输入-------------------
	int l=1,r=10000000;//空旷指数最少为1，最多为L(10⁷)
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)>k)//如果空旷指数比k还大，那么空旷指数增加
			l=mid+1;
		else{
			ans=mid;//否则记录答案，并且向左移，找更小的答案
			r=mid-1;	
		}
	}
//-------------！二分！-----------------
	cout<<ans;
	return 0;
}
```

---


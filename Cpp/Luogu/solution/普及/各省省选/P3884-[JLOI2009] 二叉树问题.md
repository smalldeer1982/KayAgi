# [JLOI2009] 二叉树问题

## 题目描述

如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：

- 深度：$4$
- 宽度：$4$
- 结点 8 和 6 之间的距离：$8$
- 结点 7 和 6 之间的距离：$3$

其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。

![](https://cdn.luogu.com.cn/upload/pic/6843.png)

给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。


## 说明/提示

对于全部的测试点，保证 $1 \leq u, v, x, y \leq n \leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。

## 样例 #1

### 输入

```
10                                
1 2                            
1 3                            
2 4
2 5
3 6
3 7
5 8
5 9
6 10
8 6
```

### 输出

```
4
4
8```

# 题解

## 作者：KALY (赞：70)

看了一下发现大家都是 LCA 做的。

我这里给大家提供一种使用 Floyd 算法的做法。

树其实一种特殊的图。

即没有环路，一定联通，而且有且有只有一个节点没有入度的图。

那么树上任意两点间的距离可以直接通过最短路算法获得。

树的深度就是距离根节点最远的那个点的距离。

树的宽度是节点最多的一层，同一层的节点距离根节点的距离都是相同的，所以也可以直接枚举获得。

 Floyd 算法应该是相当基础的算法，我相信大佬们应该都会。

代码：
```cpp
#include<bits/stdc++.h>
#define r read()//偷懒
#define lnf INT_MAX/4
// INT_MAX 是一个常量定义在 limits.h 头文件中 其值就是字面意思
#define Min(a,b) ((a)<(b)?(a):(b))//手打min提高效率
#define Max(a,b) ((a)>(b)?(a):(b))//同上，切记括号千万不能漏
//STL 中的 max 和 min 速度相当慢 用 if 速度也不及条件表达式
using namespace std;
inline int read()//快读不解释
{
    char c=getchar();
    int x=0,fh=0;
    while(c<'0'||c>'9'){fh|=c=='-';c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return fh?-x:x;
}
int n=r;
int a[101][101];//邻接矩阵存图
int b[100000000];
int main()
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
           if(i!=j)a[i][j]=lnf;//预处理
    for(int i=1;i<n;i++)
    {
        int x=r,y=r;
        a[x][y]=1;//父亲到孩子距离为1
        a[y][x]=2;//孩子到父亲距离为2
    }
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                 a[i][j]=Min(a[i][j],a[i][k]+a[k][j]);//Floyd算法
    int u=r,v=r;
    int maxsum=0,maxd=0,maxn=1;
    for(int i=2;i<=n;i++)
    {
        maxsum=Max(maxsum,a[1][i]);//深度
        b[a[1][i]]++;//同时统计每一层的节点数
        maxn=Max(maxn,a[i][1]);
    }
    for(int i=1;i<=maxn;i++)
        maxd=Max(maxd,b[i]);//宽度
    cout<<maxsum+1<<endl;
    cout<<maxd<<endl;
    cout<<a[u][v]<<endl;//树上距离
    return 0;
}
```


---

## 作者：dessert (赞：45)

# 思路
只要求出最近公共祖先，什么都好写，详细请看代码。自认为比题解的lca简单一点QWQ。


------------
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int father;  //爸爸
	int left;    //左儿子
	int right;   //右儿子
	int deep;    //深度
	int data;    //记录节点走过没
}a[10001];
int sum[101];
int lca(int x,int y){      //最最重要！！！求最近公共祖先
	a[x].data=1;           //把x的节点记录已走过
	while(a[x].father!=0){ //遍历至根节点
		x=a[x].father;     //更新遍历爸爸
		a[x].data=1;       //记录已走过
	}
	while(a[y].data!=1){   //遍历至x节点已走过的节点，找到最近公共祖先
		y=a[y].father;
	}
	return y;
}
int main(){
	int n,x,y,s,t,maxx=1;
	cin>>n;
	a[1].deep=1;    //根节点的深度为1
	a[1].father=0;  //根节点没有爸爸
	for(int i=1;i<n;i++){
		cin>>x>>y;
		if(a[x].left==0)    //这个节点是否有左儿子
		   a[x].left=y;     //变成左儿子
		else                //变成右儿子
		   a[x].right=y;
		a[y].father=x;
		a[y].deep=a[x].deep+1;   //更新深度
		if(a[y].deep>maxx)       //求出最大深度，第一个问题完成
		   maxx=a[y].deep;
	}
	cin>>s>>t;
	int f=lca(s,t),num=0,num1=0;
	while(s!=f){                //记录s到最近公共祖先有多少条边
		s=a[s].father;
		num++;
	}
	num*=2;   //结点间距离的定义：由结点向根方向（上行方向）时的边数×2，
	while(t!=f){               //记录t到最近公共祖先有多少条边
		t=a[t].father;
		num1++;
	}
	for(int i=1;i<=n;i++)      //把每一个深度有多少个节点记录
	    sum[a[i].deep]++;
	sort(sum+1,sum+1+100);
	cout<<maxx<<endl<<sum[100]<<endl<<num+num1; //sum[100]是最大的宽度节点个数
	return 0;
}


------------
拒绝抄袭，共建美好洛谷

```

---

## 作者：常青藤 (赞：32)

看了其他的题解，大部分(quan)都是用$DFS+LCA$过的。这里我提供一种最短路的思路。~~（主要还是因为不想写LCA）~~

首先，我们来看这样的一棵二叉树 ~~（就是原题的）~~

![](https://cdn.luogu.com.cn/upload/pic/6843.png)

现在要求查询这棵树的深度，其实就是这棵树上到根节点的最长距离$+1$；查询这棵树的宽度，其实就是到根节点距离相同的节点个数的最大值

例如这棵树，不难发现，$8,9,10$ 到根节点的距离最大，为 $3$ ~~（注意断句）~~ ，$depth=3+1=4$

其次，$4,5,6,7$ 到根节点的距离都是 $2$ ，$width=4$

那么如何处理第三个问题呢？

我们建的树是双向边 ~~（废话）~~，这里我们做一个~~巧妙的~~处理——将由 $u->v$ 的边权赋为$1$，反向边赋为$2$。为什么呢？我们来看下面这两张图（为求清晰而分开）——

![](https://cdn.luogu.com.cn/upload/pic/73202.png)
![](https://cdn.luogu.com.cn/upload/pic/73203.png)

例如，我们要求 $8->4$ 距离，这时最短路算法一定会找到 $LCA(8,4)=2$

为什么呢？因为如果不是公共祖先，两顶点将无法到达；而如果不是最近的，例如我们找到了 $1$ ，它一定比到 $2$ 的路径多 $3$ 。所以，建图时只要 $fa->x$ 为 $1$，$x->fa$ 为 $2$，就可以用一次最短路求解。

那么此时对于前两个操作有无影响呢？肯定是没有的。因为求前两个操作的最短路时，都是从根节点出发的，只会经过数值为$1$的边，而不会绕回去。

综上，只要建含边权的双向边，跑两遍最短路，就可以解决问题了（源点分别是$1,u$，用桶统计一下即可）

那么时间复杂度就是$Dijkstra:O(nlogn)$ 或 $SPFA:O($玄学$)$

当然，这应该是个稀疏图，从理论上和实际测试中$(n=100000)$中$SPFA$都胜于$Dijkstra$（$SPFA:$ 我还活着）且算法表现也较为优异（和最优解比较，~~也许是电脑比较快~~ ）

下面当然就是喜闻乐见的代码了：

```cpp
#include<bits/stdc++.h>
#define in(x) x=read()
using namespace std;
const int maxN=1000;
inline int read()
{
    int n=0; char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) {n=n*10+ch-'0'; ch=getchar();}
    return n;
}
struct Node{int to,next,value;}edge[2*maxN];
int dis[maxN+1],vis[maxN+1],head[maxN+1],tot,box[maxN+1];
void addedge(int x,int y,int w) {edge[++tot]={y,head[x],w}; head[x]=tot;}
void SPFA(int s)
{
    queue<int>q; q.push(s);
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    vis[s]=1; dis[s]=0;
    while(!q.empty())
    {
        int x=q.front(); q.pop(); vis[x]=0;
        for(int i=head[x];i;i=edge[i].next)
            if(dis[edge[i].to]>dis[x]+edge[i].value)
            {
                dis[edge[i].to]=dis[x]+edge[i].value;
                if(!vis[edge[i].to])
                {
                    vis[edge[i].to]=1;
                    q.push(edge[i].to);
                }
            }
    }
}
int n,u,v,ans;
int main()
{
    in(n);
    for(int i=1;i<n;i++)
    {
        in(u); in(v);
        addedge(u,v,1); addedge(v,u,2);
    }
    in(u); in(v); SPFA(1);
    for(int i=1;i<=n;i++) box[dis[i]]++,ans=max(ans,dis[i]);
    printf("%d\n",ans+1); ans=0;
    for(int i=1;i<=n;i++) ans=max(ans,box[i]);
    printf("%d\n",ans);
    SPFA(u); printf("%d\n",dis[v]);
    return 0;
}
```

完结撒花QwQ，如有错误欢迎指出，不胜感激 ~~（毕竟这算法是脑补出来的）~~

---

## 作者：starwolfy_rika (赞：23)

这题，暴力lca就能过吧。。。

深度：直接de的最大值就行。

宽度：统计de的个数，求de的个数最大值

距离：这里距离重定义了。

就直接（de[x]-de[lca(x,y)])*2-de[y]-de[lca(x,y)]；

所以，~~不愧是黄题（lca大家都会吧）~~

上代码！！！

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int n,m,fa[1005],de[1005],tot,head[1005],s,kuan,shen,pika[1005];
struct node
{
	int to,next;
}edge[1005];
void add(int u,int v)
{
	edge[++tot].to=v;
	edge[tot].next=head[u];
	head[u]=tot;
}
void dfs(int x,int fath)
{
	fa[x]=fath;
	de[x]=de[fath]+1;
	for(int i=head[x];i;i=edge[i].next)
	{
		if(edge[i].to!=fath)
		{
			dfs(edge[i].to,x);
		}
	}
}
int getlca(int x,int y)
{
	while(x!=y)
	{
		if(de[x]>=de[y])
		{
			x=fa[x];
		}
		else
		y=fa[y];
	}
	return x;
}
int getdis(int x,int y)
{
	return (de[x]-de[getlca(x,y)])*2+de[y]-de[getlca(x,y)];
}
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
	{
		shen=max(de[i],shen);
		pika[de[i]]++;
	}
	for(int i=1;i<=shen;i++)
	{
		kuan=max(kuan,pika[i]);
	}
	int u,v;
	cin>>u>>v;
	cout<<shen<<endl<<kuan<<endl<<getdis(u,v)<<endl;
    return 0;
}
```
颇有异端，别介意哦！

---

## 作者：宁_缺 (赞：14)

 _声明:数日前期中考试，下午闲暇于家，无聊，学树剖，为练习，就用树剖过了此题_ 

## 树链剖分：
**基本思想**：把树剖成许多条两两不相交的链

**具体做法**：(~~较长不易说明，请自行参考百度或数据结构书~~)

**优势**：由树剖的性质能证明，整棵树上的链数以及轻边(就是不属于任何链的边)数都不超过log(n),n为树的节点数，因此树剖是不怕被卡的O(log n)级别的，很好的近乎离线算法

**当然，本题完全用不上树剖**，甚至树剖可能因为预处理多而慢于倍增、tarjan之类的，所以，如果**不要学树剖的请走开**

树剖没有你想象的那么长（~~至少在我眼中是这样的~~），我压了些行，将纯代码量缩到了50-（~~_在此致敬楼下70+行的大佬_~~）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101,M=100,L=101;
int n,u,v,dep,wd,pcnt,p,mx,j,fa[N];
int ptop[L],pq[L],psz[L],siz[N];
int hd[N],nt[N],to[M],lk[N];
int dp[N],s[L],lca(int,int);
/*解释下上面的数组：
ptop是每条链最顶端的节点编号，
pq是每条链最顶端节点的深度，（其实本题可以不用（用dp数组就可以了），只是为了尊重树剖的模板还是加上了）
psz是每条链的节点数（同样的，这也用不到）
siz是每个节点以自己为根的子树的节点数
其余的就不解释了，别的题解有*/
void dfs(int,int);
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++)
		scanf("%d%d",&u,&v),
		to[++p]=v,nt[p]=hd[u],hd[u]=p;
	dfs(1,1),pq[lk[1]]=ptop[lk[1]]=1;
	printf("%d\n%d\n",dep,wd);
	scanf("%d%d",&u,&v);
	int _=lca(u,v),d=dp[_];
	printf("%d\n",2*(dp[u]-d)+dp[v]-d);
	return 0;
}
int lca(int a,int b){
	int x=lk[a],y=lk[b];
	while(x!=y){
		if(pq[x]<pq[y])
			swap(a,b),swap(x,y);
		a=fa[ptop[x]],x=lk[a];
	}
	if(dp[a]<dp[b])return a;
	else return b;
}
void dfs(int k,int deep){
	dp[k]=deep,s[dp[k]]++;
	dep=max(dep,dp[k]);
	wd=max(wd,s[dp[k]]);
	for(int i=hd[k],c;i;i=nt[i]){
		c=to[i],fa[c]=k;
		dfs(c,deep+1);
		siz[k]+=siz[c];
		if(mx<siz[c])
			mx=siz[c],j=c;
	}
	for(int i=hd[k];i;i=nt[i]){
		int c=to[i],t=lk[c];
		if(c==j)lk[k]=lk[c],psz[t]++;//k与c连重边
		else pq[t]=deep+1,ptop[t]=c;//k与c不连重边，那么c就是它所在的重路径（就是链）的顶端
	}
	if(!lk[k])//k没与孩子连重路径，那么k是叶子，所以是一条新的重路径的底端
		pcnt++,lk[k]=pcnt,psz[pcnt]=1;
}
```

---

## 作者：TEoS (赞：8)

Upd. 2020.11.18 修复了挂掉的链接

为了友善地对待不会LCA的~~萌新~~大佬，这里给出一篇[LCA详解](https://www.cnblogs.com/TEoS/p/11376616.html)供食用，里面介绍了两种（好吧其实在这题是三种）常用的方法。因为这题的数据~~太水~~，三种方法都可以用。

所以对于LCA这里就不多讲啦。

题目问的是深度、宽度以及1个距离，这个距离显然用LCA就很好求了。于是我就快乐地~~掏出~~写下了倍增，因为倍增的同时就要处理深度。至于宽度，只要统计每层有多少个节点，找到最多的一层就行了。

倍增求LCA要先搜索预处理，在搜索的同时处理深度和宽度就可以了！

具体实现代码里有注释。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
using namespace std;
const int N=110;
int n,u,v,t,tot,ans,lca;
int d[N],dep[10],f[N][10];
int head[N],Next[2*N],ver[2*N];
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}//邻接表存图
void bfs()
{
	queue<int> q;
	d[1]=1,dep[1]++;
	q.push(1);
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i];
			if(d[y])
				continue;
			d[y]=d[x]+1;
			dep[d[y]]++;//存储每层有几个节点
			f[y][0]=x;
			for(int j=1;j<=t;j++)
				f[y][j]=f[f[y][j-1]][j-1];
			q.push(y);
		}
	}
}//广搜预处理
int LCA(int x,int y)
{
	if(d[x]>d[y])
		swap(x,y);
	for(int i=t;i>=0;i--)
		if(d[f[y][i]]>=d[x])
			y=f[y][i];
	if(x==y)
		return x;
	for(int i=t;i>=0;i--)
		if(f[x][i]!=f[y][i])
			x=f[x][i],y=f[y][i];
	return f[x][0];
}//倍增求LCA
int main()
{
	scanf("%d",&n);
	t=log2(n)+1;
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	scanf("%d%d",&u,&v);
	bfs();
	lca=LCA(u,v);
	for(int i=1;i<=n;i++)
		ans=max(ans,d[i]);//求出深度，即最深的节点的深度
	printf("%d\n",ans),ans=0;
	for(int i=1;i<=t;i++)
		ans=max(ans,dep[i]);//求出宽度，即节点最多的一层的节点数
	printf("%d\n%d",ans,(d[u]-d[lca])*2+d[v]-d[lca]);//计算出距离并输出
	return 0;
}
```


---

## 作者：以墨 (赞：8)

居然没有树剖没看到？？？
LCA方法太多了，实在不会就去模板题解里看。下面本蒟蒻用树链剖分求LCA来发。
这道题范围很小，所以Tarjan和树剖差别不大。
树剖知识不好普及，直接来代码吧.......

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=107;
int nxt[N<<1],to[N<<1],h[N<<1],top[N],son[N],size[N],dep[N],fa[N],n,Q,t,U,V,max_d,max_w,w[N],lca;
//w数组记录每一层的宽度
inline void rd(int& x){
	char ch;x=0;
	while((ch=getchar())<48);
	while(ch>47)
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
inline void addEdge(int u,int v){
	nxt[++t]=h[u];
	h[u]=t;
	to[t]=v;
}
inline void dfs_1(int u,int father){
	fa[u]=father;size[u]=1;
	for(int i=h[u];i;i=nxt[i]){
		int v=to[i];
		if(v==father)
			continue;
		dep[v]=dep[u]+1;
		dfs_1(v,u);
		size[u]+=size[v];
		if(size[son[u]]<size[v])
			son[u]=v;
	}
}
inline void dfs_2(int u,int tp){
	top[u]=tp;
	if(son[u])
		dfs_2(son[u],tp);
	for(int i=h[u];i;i=nxt[i]){
		int v=to[i];
		if(v==son[u]||v==fa[u])
			continue;
		dfs_2(v,v);
	}
}
inline void dfs(int u){
	if(!son[u]){//学过树剖的童鞋都知道，如果一个节点没有重儿子，那么它一定是叶子节点
		w[dep[u]]++;
		max_d=max(max_d,dep[u]);
		return ;
	}
	w[dep[u]]++;//当前节点u属于dep[u]层，那么第dep[u]层一定多了一个节点
	for(int i=h[u];i;i=nxt[i])
		if(to[i]!=fa[u])//千万不能少这句话，否则就搜不出来了
			dfs(to[i]);
}
inline int LCA(int u,int v){//树剖LCA
	while(top[u]!=top[v])
		if(dep[top[u]]<dep[top[v]])
			v=fa[top[v]];
		else
			u=fa[top[u]];
	if(dep[u]<dep[v])
		return u;
	return v;
}
int main(){
	rd(n);
	for(int i=1;i<=n-1;i++){
		int u,v;
		rd(u);rd(v);
		addEdge(u,v);addEdge(v,u);
	}
	rd(U);rd(V);
	dep[1]=1;
	dfs_1(1,0);//树剖第一次dfs
	dfs_2(1,1);//树剖第二次dfs
	dfs(1);
	for(int i=1;i<=max_d;i++)
		max_w=max(max_w,w[i]);
	printf("%d\n%d\n",max_d,max_w);
	lca=LCA(U,V);
	printf("%d\n",2*(dep[U]-dep[lca])+dep[V]-dep[lca]);
    //很显然U到V的路径就是U->LCA->V，前一半U->LCA的权值算两倍的，后面算一倍的。
	return 0;
}

```

---

## 作者：RyanLi (赞：7)

传送门：[P3884 [JLOI2009] 二叉树问题](https://www.luogu.com.cn/problem/P3884)

更佳的阅读体验：[洛谷 P3884 题解](https://blog.ryanli.top/index.php/archives/275/)

本文给出一种不使用 LCA 等较高级算法的解法。

---

**简要题意**：给定一棵二叉树，求其深度、宽度，和节点 $x$ 到 $y$ 的距离。其中距离定义为向根节点的边数的两倍加上向叶节点的边数。

我们来分析二叉树的性质。

首先是深度。深度定义为从根节点到最远叶结点的节点数，也就是说从根节点出发，不回头可以走到最远的路径长度。从根节点开始使用一遍 DFS 遍历整棵树即可求出。

然后是宽度。宽度定义为具有最多结点数的层中包含的结点数。此时需要意识到，从根节点出发，到同一层的所有节点的路径长度都相同。也就是说，从根节点出发，路径长度相同的节点位于同一层。

因此，我们可以开一个桶，在遍历的同时记录每一层的节点数。桶中的最大值就是树的宽度。

接下来问题就只剩节点 $x$ 到 $y$ 的距离了。因为距离定义为“向根节点的边数的两倍加上向叶节点的边数”，我们发现在一棵树上直接求解是十分困难的。

我们需要考虑如何转化问题。由距离的定义可以想到，本题中距离的本质是“根节点到叶节点的距离为 $1$，叶节点到根节点的距离为 $2$”。

此时，想到直接对整棵树建图，根节点到叶节点的边权为 $1$，叶节点到根节点的边权为 $2$。注意到 $n \le 100$，我们直接以 $x$ 为起点，再进行一次 DFS 遍历，即可求出到 $y$ 的距离。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 110;
int n, u, v, x, y, depth, cnt[N], width, ans;
basic_string<pair<int, int> > g[N];

void dfs1(int u, int fa, int dep) {
    depth = max(depth, dep), ++cnt[dep];
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        dfs1(v, u, dep + w);
    }
}

void dfs2(int u, int fa, int dis) {
    if (u == y) ans = dis;
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        dfs2(v, u, dis + w);
    }
}

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i < n; ++i) {
        cin >> u >> v;
        g[u] += make_pair(v, 1), g[v] += make_pair(u, 2);
    } cin >> x >> y;
    dfs1(1, 0, 1);
    width = *max_element(cnt + 1, cnt + depth + 1);
    dfs2(x, 0, 0);
    cout << depth << '\n' << width << '\n' << ans << '\n';
    return 0;
}
```

---

## 作者：Alarm5854 (赞：6)

这道题目还是比较水的，$N$很小，只有100，于是我就又用链表来水这道题，还1遍A掉了，后来看了一下已有的题解，发现没有用链表做的，所以我又来水了。

其实我的链表完全可以用数组替代的，我只不过想炫(zhuang)耀(bi)一下才用的。

### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	node *f;//完全可以只用一个父节点
	int deep;
};
node *root,*p,*q,*address[101];//address是储存每一个地址的
int n,x,y,u,v,ans,maxdeep,maxwide,deep[101];//maxdeep代表最大深度，maxwide代表最大宽度，deep储存每一个深度有多少个节点
int main(){
	scanf("%d",&n);
	root=new node,root->f=NULL,root->deep=1;//第一个节点没有父节点
	address[1]=root;//这是第一个节点的地址
	for(int i=2;i<=n;++i){
		scanf("%d%d",&x,&y);
		p=new node,p->f=address[x];//address就是来偷懒的，否则还要O(n)的时间来搜索
		p->deep=p->f->deep+1;
		address[y]=p;//把x设为y的父节点并且加入y的地址
	}scanf("%d%d",&u,&v);//压一下行，应该没关系
	for(int i=1;i<=n;++i)
		++deep[address[i]->deep],maxdeep=max(maxdeep,address[i]->deep);//统计每一个深度节点的个数，并更新最大深度
	for(int i=1;i<=maxdeep;++i)
		maxwide=max(maxwide,deep[i]);//更新最大深度
	printf("%d\n%d\n",maxdeep,maxwide),p=address[u],q=address[v];
	while(p->deep>q->deep)
		p=p->f,ans+=2;
	while(p->deep<q->deep)
		q=q->f,++ans;//这4行把p节点和q节点弄到同一深度
	while(p!=q)
		p=p->f,q=q->f,ans+=3;//同时往上爬，答案加3
	printf("%d",ans);
	return 0;
}
```

---

## 作者：lzpclxf (赞：6)

**每题感悟 :**

大体翻了翻题解里关于树链剖分的方法大概有两篇左右的亚子

但是看到别人的代码与我有不太一样的我就很想贴我的代码（盲目自信）  但是我知道这样是不会通过的， 我又翻了翻发现我自己瞎想的在树链剖分里求深度和宽度好像木人写， 所以我的机会来咧！

**正文：**

本题思路不难想， lca 往上套 dfs也能求

众所周知在树链剖分里我们有一个数组deep来记录深度， 我们会更新他， 所以我们为什么不能在更新他的时候也正好更新出最大深度呢？

类似于这个亚子：

```cpp
deep[now] = deep[dad[now]] + 1;
if(deep[now] > maxdep) maxdep = deep[now];
```
恍然大悟有木有？

同理

我们也可以重新开一个数组， 来记录每个深度的节点个数， 也就是他的宽度， 每次加加并更新最大值

```cpp
siz[deep[now]]++;
if(siz[deep[now]] > sum) sum = siz[deep[now]];
```
所以再套上树链剖分的板子就好咧

这里说一个小点

调了一些时间， 就是是到lca的距离并不是到根的距离， 但是到根的距离能得80分!分数很可观， 但是还是要认真审题哇！

The Last

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 205;
int n, head[N], cnt, top[N], size[N], son[N], dad[N], u, v, maxdep, siz[N], ans, sum, deep[N];
struct node {
	int nxt, to, w;
}e[N];
void add(int x, int y) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	head[x] = cnt;
} 
void dfs(int now) {
	size[now] = 1;
	deep[now] = deep[dad[now]] + 1;
	siz[deep[now]]++;
	if(siz[deep[now]] > sum) sum = siz[deep[now]];
	if(deep[now] > maxdep) maxdep = deep[now];
	for(int i = head[now]; i; i = e[i].nxt) {
		if(e[i].to != dad[now]) {
			dad[e[i].to] = now,dfs(e[i].to),size[now] += size[e[i].to];
			if(size[e[i].to] > size[son[now]]) son[now] = e[i].to;
		}
	}
}
void dfs1(int now) {
	if(!top[now]) top[now] = now;
	if(son[now]) top[son[now]] = top[now], dfs1(son[now]);
	for(int i = head[now]; i; i = e[i].nxt)
		if(e[i].to != dad[now] && e[i].to != son[now])
			dfs1(e[i].to);
}
int lca(int x, int y) {
	while(top[x] != top[y]) {
		if(deep[top[x]] < deep[top[y]]) swap(x, y);
		x = dad[top[x]];
	}
	return deep[x] < deep[y] ? x : y;
}
int main() {
	scanf("%d", &n);
	for(int i = 1, x, y; i < n; i++) {
		scanf("%d%d", &x, &y);
		add(x, y);add(y, x);
	}
	scanf("%d%d", &u, &v);
	dfs(1), dfs1(1);
	printf("%d\n", maxdep);
	printf("%d\n", sum);
	int dep = deep[lca(u, v)];
//	cout << dep << endl; 
	ans = (deep[u] - dep) * 2 + deep[v] - dep;
//	cout << deep[u] << " " << deep[v] << endl;
	printf("%d\n", ans);
	return 0; 
}
```
谢谢收看 祝身体健康！


---

## 作者：Rt__ (赞：5)

update 2024.9.27 修复挂掉的图
# P3884 二叉树问题
[传送门](https://www.luogu.com.cn/problem/P3884)

~~本蒟蒻第一篇题解~~，前面的大佬都是 _**lca+dfs**_ 或者 _**Floyd**_ 做的，我不会lca，只能自己想了一个~~较为精巧~~的思路，不喜勿喷。
## 思路
我们可以将每两个点之间的边建为双向的，以一为根节点，则就有**向上**（蓝色）和**向下**（红色）两种边。

![](https://cdn.luogu.com.cn/upload/image_hosting/ny4no89h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然，从根节点遍历时所经过的都是红色边，蓝色边如何处理无关痛痒。先由 $u$ 到 $v$ 遍历边，所经过的红色边就是 _**指向叶子结点的边**_ （指向根结点的边都是蓝色的），可以把他们标记为 $1$ （题中只需要加他们的一倍）；再由 $v$ 到 $u$ 遍历一次边，所经过的红色边就是 _**指向根节点的边**_ （指向叶子结点的都是蓝色的），标记为 $2$ （题中要求加他们的两倍）。然后再从根节点向下深搜，把每条边的标记加起来就好。

## 代码（附上关键注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int a[110],idx;
int st[110];
int h[110],ne[220],e[220];
int size[110];
int x,y;


//建边
void add(int a,int b){
	ne[idx]=h[a],e[idx]=b,h[a]=idx++;
}


//搜索深度和宽度
int dfs(int u,int deep,int fa){
	size[deep]++;//深度为deep的宽度
	int d=deep;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j==fa)continue;
		d=max(d,dfs(j,deep+1,u));//取最深的深度
	}
	return d;
}


//累加标记的边
int dfss(int u,int fa){
	int ans=0;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j==fa)continue;//保证不向上
		ans+=st[i];
		ans+=dfss(j,u);
	}
	return ans;
}


//搜索u->v或者v->u
bool query(int u,int en,int last,int flag){
	if(u==en){
		return true;//搜到目标点
	}
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(j==last)continue;
		if(query(j,en,u,flag)){//搜到了才能标记
			st[i]=flag;//标记不同类型的边
			return true;
		}
	}
	return false;
}


signed main(){
	int n;
	cin>>n;
	memset(h,-1,sizeof h);
	for(int i=1;i<n;i++){
		int l,r;
		cin>>l>>r;
		add(l,r),add(r,l);//建双向边
	}


	int deep=dfs(1,1,0);//搜深度和宽度
	int res=0;
	for(int i=1;i<=deep;i++){
		res=max(res,size[i]);
	}
	cin>>x>>y;
	cout<<deep<<endl<<res<<endl;


	query(y,x,0,2);//u到v
	query(x,y,0,1);//v到u

	cout<<dfss(1,0);
	return 0;
}
```

完美收官~
### **管理大大求过QAQ**

---

## 作者：hsfzLZH1 (赞：5)

这题考察的是基本的树的存储和建树操作的实现。

在这里我们用链式前向星存图。

用head[x]表示这个点的最后一条出边，nxt[j]就是编号为j的边的上一条边，而point[j]就是边j所指向的节点。由于按照这样存储的是一条有向边，所以我们存一条树上边就需要加两次边，进行两次加边操作。加边操作就类似于在链表中插入一个节点。

如果我们需要遍历一个节点的所有出边，我们可以从该节点的最后一条边开始，一条一条地往前面访问，一直到NULL标识符为止。

存储了图和根节点，我们就可以以此建树。如果我们要对节点o进行建树操作，我们可以遍历该节点的所有出边，如果指向的节点没有被访问过，那么先更新指向节点的信息，然后对这一节点进行建树操作。其实整体来说就是一个DFS过程。

在建树的过程中，我们需要维护两个信息：depth[x]和father[x]，depth[x]表示该节点到根节点的距离，father[x]表示节点x在树上的父亲节点。

知道了这两个数组，我们就可以求解答案了。最大深度就是最大的depth值，而最大宽度就是最大depth值相等的节点个数。如何求解树上距离呢？这里我们引入一个LCA(最近公共祖先)的概念。定义树上两个节点u,v，那么lca(u,v)就是他们共同的祖先中深度最大的，有一个性质u->lca(u,v)->v的距离是u->v的所有路径中距离最小的，而且u->lca(u,v)为全部像根节点方向走，lca(u,v)->v为全部像远离跟节点的方向走。

如何求解两个节点u,v的LCA呢？首先我们需要将两个节点移到同一深度。将深度较大的节点向父亲方向移动。然后把他们一起向父亲移动，如果两点相遇，这个点一定是他们的LCA。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=210;//链式前向星存两次边，数组范围两倍
int n,x,y,u,v,t,h[maxn],p[maxn],nxt[maxn],cur,dep[maxn],ans,f[maxn],fa[maxn];//变量如上定义所示
void add_edge(int x,int y){nxt[cur]=h[x];h[x]=cur;p[cur]=y;cur++;}//加边操作，记得cur++，切记
void build(int x)//对节点x进行建树
{
    for(int j=h[x];j!=-1;j=nxt[j])if(!dep[p[j]])
    {
        dep[p[j]]=dep[x]+1;
        fa[p[j]]=x;
        build(p[j]); 
    }
}
int main()
{
    memset(h,-1,sizeof h);//全部打上NULL标记
    scanf("%d",&n);
    for(int i=1;i<n;i++)scanf("%d%d",&x,&y),add_edge(x,y),add_edge(y,x);
    scanf("%d%d",&u,&v);t=u;
    dep[1]=1;fa[1]=1;build(1);//建树
    for(int i=1;i<=n;i++)ans=max(ans,dep[i]),f[dep[i]]++;
    printf("%d\n",ans);ans=0;
    for(int i=1;i<=n;i++)ans=max(ans,f[i]);
    printf("%d\n",ans);ans=0;
    if(dep[u]>dep[v])swap(u,v);
    for(int i=dep[v]-dep[u];i;i--)v=fa[v],ans++;
    while(u!=v)u=fa[u],v=fa[v],ans+=2;//现在u==v且为初始u,v的LCA
    while(t!=u)t=fa[t],ans++;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：muyang_233 (赞：4)

这道题应该来说是一道LCA非常好的练手题。  

关于两点间的距离，很容易发现是  
$(depth_u-depth_{LCA_{u,v}})*2+(depth_v-depth_{LCA_{u,v}})$ ，  
其中$depth_i$代表点$i$的深度，$LCA_{u,v}$表示点$u$和点$v$的最近公共祖先。  

剩下的深度和宽度就很好求了，易知其深度=$max\{depth_{u}\}$，宽度=$max\{t_{depth}\}$，  
其中$t_{depth}$代表深度为$depth$的点的个数。  

知道了如上的公式，就可以知道解题步骤是：  
1. **通过暴力$dfs$标记每个点的深度，同时求出最大深度，即为答案所表示的深度；**
2. **循环每一种深度，记录每个深度的出现次数，并求出最大的出现次数，这个次数就是这棵树的宽度；**
3. **通过上方给出的公式，使用倍增法写出$LCA$，计算公式结果即可。** 

代码如下：
```cpp
//本代码由菜鸡muyang©书写  
//菜鸡muyang 写出来的代码肯定会WA
//不信你复制看看（划掉）
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 100+5
#define MAXM 200+5
struct edge{
	int v;
	int next;
}e[MAXM];
int n;
int Dep;
int root;
int maxn;
int cnt[MAXN];
int eid,p[MAXN];
int depth[MAXN];
int f[MAXN][20],d[MAXN];
void init(){
	memset(p,-1,sizeof(p));
	eid=0;
}
void insert(int u,int v){
	e[++eid].v=v;
	e[eid].next=p[u];
	p[u]=eid;
}
void dfs(int u){
	d[u]=d[f[u][0]]+1;
	for (int i=p[u];i!=-1;i=e[i].next){
		int v=e[i].v;
		if (v==f[u][0]){
			continue;
		}
		f[v][0]=u;
		dfs(v);
	}
}
int LCA(int x,int y){
	if (d[x]<d[y]){
		swap(x,y);
	}
//	printf("1 %d %d\n",x,y);
	int zzq_OTZ=0;
	while((1<<(zzq_OTZ+1))<=d[x]) ++zzq_OTZ;
	for (int j=zzq_OTZ;j>=0;j--){
		if (d[f[x][j]]>=d[y]){
			x=f[x][j];
//			printf("2 %d %d\n",x,y);
		}
	}
	if (x==y){
		return x;
	}
	for (int j=zzq_OTZ;j>0;j--){
		if (f[x][j]!=f[y][j]){
			x=f[x][j];
			y=f[y][j];
//			printf("3 %d %d\n",x,y);
		}
	}
	return f[x][0];
}
void dfs2(int u){
	for (int i=p[u];i!=-1;i=e[i].next){
		int v=e[i].v;
		if (v==f[u][0]) continue;
		depth[v]=depth[u]+1;
		dfs2(v);
	}
}
int main(){
//#ifndef ONLINE_JUDGE
//	freopen("P3379.out","w",stdout);
//#endif
	init();
	scanf("%d",&n);
	root=1;
	for (int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		insert(u,v);
		insert(v,u);
	}
	dfs(root);
	depth[root]=1;
	dfs2(root);
//	for (int i=1;i<=n;i++){
//		printf("%d\n",d[i]);
//	}
	for (int j=1;(1<<j)<=n;j++){
		for (int i=1;i<=n;i++){
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	for (int i=1;i<=n;i++){
		if (depth[i]>Dep) Dep=depth[i];
		++cnt[depth[i]];
	}
	for (int i=1;i<=Dep;i++){
		maxn=cnt[i]>maxn?cnt[i]:maxn;
	}
	int u,v;
	scanf("%d%d",&u,&v);
	int _lca=LCA(u,v);
	printf("%d\n%d\n%d\n",Dep,maxn,(depth[u]-depth[_lca])*2+(depth[v]-depth[_lca]));
	return 0;
}

```

---

## 作者：wyxdrqc (赞：4)

一道LCA的题目，最近刚学会树剖，来练习一下

~~（才不是因为看到题解里没有用树剖而来发的呢）~~

------------

如何用树链剖分来求LCA呢？

其实树剖中的求取u-v的距离的写法差不多。
只要U V不在同一条重链上，就让链顶节点深度较大的那个跳到他的链顶节点的父亲节点上（有点拗口啊）。
知道U V在同一条重链上是，这时，深度较小的点就是我们要求的LCA了。

如何证明正确性呢？

首先我们要知道，u v总有一个点会跳倒他们的LCA上，因为经过LCA这个节点的重链只有一条，U——V中至少会有一个点通过轻链来调到LCA上。这样就完成判断了。~~（其实我也不会多么严谨的证明啦）~~

至于树的深度，宽度，DFS就可以了

题目中要求的U倒V中的距离（因为我们可以看做边权为1）就等于

（U节点的深度-LCA的深度）*2+（V节点的深度-LCA的深度）~~是很明显的吧~~

贴代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 
using namespace std;
const int N=1e3+2;
int n,tot;
struct edge{
    int to;	
    int next;
}e[N<<1];
int head[N],deep[N],fa[N],size[N],son[N],top[N];
int sum[N];
inline void add(int x,int y){
    e[++tot].to=y;
    e[tot].next=head[x];
    head[x]=tot;
}
void dfs1(int now,int f,int deeep){//dfs1的目的是确定树的基础信息 
    deep[now]=deeep;
    fa[now]=f;
    size[now]=1;
    int maxson=-1;
    for(int i=head[now];i;i=e[i].next){
        int y=e[i].to;
        if(y==f) continue;
        dfs1(y,now,deeep+1);
        size[now]+=size[y];
        if(size[y]>maxson) maxson=size[y],son[now]=y;//记录重儿子 
    }
}
void dfs2(int x,int topf){//dfs2的目的是划分轻重链 
    top[x]=topf;
    if(!son[x]) return ;
    dfs2(son[x],topf);
    for(int i=head[x];i;i=e[i].next){
        int y=e[i].to;
        if(y==fa[x]||y==son[x]) continue;
        dfs2(y,y);
    }
}	
inline int lca(int x,int y){//树剖求LCA 
    while(top[x]!=top[y]){//只要不在同一重链上 
        if(deep[top[x]]<deep[top[y]]) swap(x,y);
        x=fa[top[x]];	//将链顶深度较大的跳上去 
    }
    if(deep[x]>deep[y]) swap(x,y);//深度较小的就是LCA 
    return x;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;++i){
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    dfs1(1,0,1);
    dfs2(1,1);
    int maxl=-1,maxw=-1;;
    for(int i=1;i<=n;++i){
        sum[deep[i]]++;
        maxw=max(maxw,sum[deep[i]]);//几率宽度 
        maxl=max(maxl,deep[i]);//深度 
    } 
    int x,y;
    scanf("%d%d",&x,&y);
    int lc=lca(x,y);
    printf("%d\n%d\n%d",maxl,maxw,(deep[x]-deep[lc])*2+(deep[y]-deep[lc]));//距离 
    return 0;	
}
```

---

## 作者：zhangsl089 (赞：3)

这道题相当的水，居然是吉林省选。

一遍dfs解决问题，深度由上一个点直接推出，用桶来计算一层的节点数，n非常小。

搜完后for循环一遍找出最大的深度和一层的节点数。

稍微麻烦(划掉)的是lca，由于本人懒所以直接合在一个dfs里，导致wa了一次。

如果遇到某一目标节点，return一个标记上去，如果标记第一次在一个点出现两次，就是lca

由于可能是在一个路径，考虑某个点就是lca。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
int n,lca=0;
int hei[110],buk[110];
int a,b;

struct edge{
    int to;
    int nxt;
}po[400];
int tot,edgenum[110];

void add_edge(int s,int t){
    po[++tot].to=t;
    po[tot].nxt=edgenum[s];
    edgenum[s]=tot;
}

int dfs(int now){
    int t=0;
    if(now==a||now==b) t++;
    for(int i=edgenum[now];i;i=po[i].nxt){
        int to=po[i].to;
        if(hei[to]==-1){
            hei[to]=hei[now]+1;
            buk[hei[to]]++;
            if(dfs(to))
                t++;
        }
    }
    if(t==2&&lca==0) lca=now;
    if(now==a||now==b) return 1;
    return t;
}

int main(){
    freopen("3884.in","r",stdin);
    freopen("3884.out","w",stdout);
    scanf("%d",&n);
    memset(hei,-1,sizeof(hei));
    for(int i=1,s,t;i<n;i++){
        scanf("%d%d",&s,&t);
        add_edge(s,t);
        add_edge(t,s);
    }
    scanf("%d%d",&a,&b);
    hei[1]=0,buk[0]++;
    dfs(1);
    int maxn=0,maxw=0;
    for(int i=0;i<=n;i++)
        if(buk[i]>0){
            maxn=max(maxn,i);
            maxw=max(maxw,buk[i]);
        }
    printf("%d\n%d\n",maxn+1,maxw);
    printf("%d\n",(hei[a]-hei[lca])*2+(hei[b]-hei[lca]));
    return 0;
}
```

---

## 作者：清风我已逝 (赞：3)

	
    貌似没有tarjan求LCA的题解，那就来一发吧
    
```
1 2 问很简单，dfs处理就可以啦

dep，p[dep]

剩下就是tarjan求LCA的板子啦
```

奉上代码
```
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<vector>
#include<cmath>
#define N 1000005
using namespace std;

void in(int &x){
    register char ch=getchar();x=0;int flg=1;
    for(;ch>'9'||ch<'0';){if(ch=='-')flg=-1; ch=getchar();}
    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    x=x*flg;
}

int n,tot,head[N],s,t;
vector<int>V[105];

bool vis[105];
int dep[N],p[N],fa[N];
void dfs(int u){
	for(int i=0;i<V[u].size();i++){
		int v=V[u][i];
		if(!vis[v]){
			dep[v]=dep[u]+1;
			p[dep[v]]++;
			vis[v]=1;
			dfs(v);
		}
	}
}
int find(int u){return fa[u]==u?u:find(fa[u]);}
void tarjan(int u,int f){
	for(int i=0;i<V[u].size();i++){
		int v=V[u][i];
		if(!vis[v]&&v!=f){
			tarjan(v,u);fa[find(v)]=find(u);
			vis[v]=1;
		}
	}if(u==s&&vis[t]) fa[0]=find(t);
	if(u==t&&vis[s]) fa[0]=find(s);//令fa[0]=LCA(s,t)
}

int main()
{
	in(n);
	for(int i=1,u,v;i<n;i++){
		in(u);in(v);
		V[u].push_back(v);
		V[v].push_back(u);
	}dep[1]=1;p[dep[1]]=1;vis[1]=1;
	dfs(1);
	for(int i=1;i<=n;i++) fa[i]=i;
	in(s);in(t);
	memset(vis,0,sizeof(vis));
	tarjan(1,0);
//	printf("%d\n",fa[0]);
	for(int i=1;i<=n;i++) dep[0]=max(dep[0],dep[i]);//令dep[0]=max(dep[i-1~n])
	for(int i=1;i<=dep[0];i++) p[0]=max(p[0],p[i]);//令p[0]=max(p[i-1~n])
	printf("%d\n%d\n%d\n",dep[0],p[0],(dep[s]-dep[fa[0]])*2+dep[t]-dep[fa[0]]);
	return 0;
}
```

---

## 作者：斯茂 (赞：2)

### 暴力

这题跟倍增，剖分都没啥关系，因为n=100，而且只有1次询问。所以只要暴力地向上跳就能过了。

然后这题代码有几个要注意的地方：
```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;
vector <int> V[105];
int f[105], D, d[105], h[105], H, A;//f[i]:i的父亲, d[i]:i的深度, h[i]:深度为h的点数。大写字母表示答案。
void build(int nd)//建树的过程，顺便统计d, h, D
{
    int i;
    for(i = 0; i < V[nd].size(); i++)
      if(f[nd] != V[nd][i])
      {
          f[V[nd][i]] = nd;
          d[V[nd][i]] = d[nd] + 1;
          D = max(D, d[V[nd][i]]);
          h[d[V[nd][i]]]++;
          build(V[nd][i]);
      }
}
int main()
{
    int n, u, v, i;
    bool rev;
    cin >> n;
    for(i = 1; i < n; i++)
    {
        cin >> u >> v;
        V[u].push_back(v);
        V[v].push_back(u);
    }
    cin >> u >> v;
    build(1);
    for(i = 1; i <= n; i++)
      H = max(H, h[i]);
    if(d[u] > d[v]) swap(u, v), rev = 1;//暴力跳，注意若是swap了，上行和下行就反过来了
    while(d[u] != d[v]) v = f[v], A += 1 + rev;
    while(u != v) u = f[u], v = f[v], A += 3; 
    cout << D + 1 << endl << H << endl << A << endl;//D+1因为深度是从0编号的
    return 0;
}
```

---

## 作者：da32s1da (赞：2)

容易发现题目样例中**先给父亲后给儿子**，于是本着**WA了重打**的原则，猜测所有数据都是如此。。没想到过了

深度**dep[i]=dep[fa[i]]+1**

宽度**tot[dep[i]]++**

距离：与倍增LCA思路一致，由于数据较小，暴力跳即可
```
//非人类版。。可AC
#include<cstdio>
int n,p,q,fa[105],dep[105],tot[105];
int mx,MX,ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d%d",&p,&q);
		q[fa]=p;(q[dep]=p[dep]+1)[tot]++;
		mx=mx<q[dep]?q[dep]:mx;
		MX=MX<q[dep][tot]?q[dep][tot]:MX;
	}
	scanf("%d%d",&p,&q);
	if(p[dep]<q[dep]) while(p[dep]!=q[dep]) q=q[fa],ans++;
	if(p[dep]>q[dep]) while(p[dep]!=q[dep]) p=p[fa],ans+=2;
	while(p!=q) p=p[fa],q=q[fa],ans+=3;
	printf("%d\n%d\n%d\n",mx+1,MX,ans);
}

//正常版
#include<cstdio>
int n,p,q,fa[105],dep[105],tot[105];
int mx,MX,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;i++){
        scanf("%d%d",&p,&q);
        fa[q]=p;tot[dep[q]=dep[p]+1]++;
        mx=mx<dep[q]?dep[q]:mx;
        MX=MX<tot[dep[q]]?tot[dep[q]]:MX;
    }
    scanf("%d%d",&p,&q);
    if(dep[p]<dep[q]) while(dep[p]!=dep[q]) q=fa[q],ans++;
    if(dep[p]>dep[q]) while(dep[p]!=dep[q]) p=fa[p],ans+=2;
    while(p!=q) p=fa[p],q=fa[q],ans+=3;
    printf("%d\n%d\n%d\n",mx+1,MX,ans);
}
```

---

## 作者：RetrO (赞：2)

想当年的JLOI还是非常有趣的，说是一道爆搜题完全可以用LCA水过，在建树时直接判断最大的深度建完树O(n\*maxdepth)来查询最大宽度，因为最大限制才100毫不惧怕，最后距离的处理需要注意。上行需要\*2其他的就没什么好说的了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct edge{
    int to,next,val;
}G[100010];
int tot;
int maxn=0;
int depth[100010];
int st[100010][25];
int dist[100010];
bool used[100010];
int head[100010];
inline void addedge(int a,int b)
{
    G[tot].to=b;
    G[tot].next=head[a];
    G[tot].val=1;
    head[a]=tot++;
} 
void clear()
  {
       memset(used,false,sizeof(used));
       memset(head,-1,sizeof(head));
       memset(depth,0,sizeof(depth));
  }
  inline void tree(int s)
  {
      used[s]=1;
      for(int i=head[s];~i;i=G[i].next)
{
     int tt=G[i].to;
     if(used[tt])
     continue;
     dist[tt]=dist[s]+G[i].val;
      depth[tt]=depth[s]+1;
      maxn=max(depth[tt],maxn);
      st[tt][0]=s;
      for(int j=1;j<=20;j++)
      st[tt][j]=st[st[tt][j-1]][j-1];
      tree(tt);
}
   } 
int lca(int a,int b)
   {
        if(depth[a]>depth[b])
        swap(a,b);
        int d=depth[b]-depth[a];
         for(int i=0;(1<<i)<=d;i++)
          {
              if((1<<i)&d)
              b=st[b][i];
          }
          if(a==b)
          return a;
          for(int i=20;i>=0;i--)
           {
               if(st[a][i]!=st[b][i])
               {
                   a=st[a][i];
                   b=st[b][i];
               }
           }
           return st[a][0];
    } 
    int p,q;
int main()
{
    clear();
    scanf("%d",&n);
     for(int i=1;i<n;i++)
     {
          int a,b;
          scanf("%d %d",&a,&b);
           addedge(a,b);
      addedge(b,a);
      }
      scanf("%d %d",&p,&q);
      depth[1]=1;
      dist[1]=0;
      tree(1);
    printf("%d\n",maxn);
    int wide=0;
     for(int i=1;i<=maxn;i++)
     {
         int ans=0;
         int t=i;
          for(int j=1;j<=n;j++)
          {
              if(depth[j]==t)
               ans++;
          }
          wide=max(ans,wide);
     }
     // printf("%d %d\n",dist[p],dist[q]);
    // printf("%d %d %d",dist[p],dist[q],dist[lca(p,q)]);
      printf("%d\n%d",wide,2*(dist[p]-dist[lca(p,q)])+dist[q]-dist[lca(p,q)]);
}
```

---

## 作者：judgejudge (赞：1)

# 并查集+近似于LCA的算法
这道题有三小问，我们逐一解决。


------------
### 一、深度
我们定义一个数组b，用于记录每一点的深度。

然后列出方程：
```cpp
b[a[i].rt]=b[a[i].lf]+1;//rt表示子节点，lf表示根节点
//根据题目定义的深度进行
```
最后进行**最大判断**：
```cpp
maxd=max(maxd,b[a[i].rt]);
```

------------
### 二、宽度
我们定义一个数组c，用来记录每一个深度所拥有的节点的个数。
```cpp
c[b[a[i].rt]]++;
```
最后同理选出最大即可。


------------
### 三、节点到节点的距离
题目的定义是这样的：

**结点间距离的定义：由结点向根方向（上行方向）时的边数×2，
与由根向叶结点方向（下行方向）时的边数之和。**

那么重要的是找出最近公共祖先（LCA）。
```cpp
inline ll LCA(ll l,ll r){
	register int i;
	ll p1=l,p2=r;//此时所处的位置
	ll d1=0,d2=0;//祖先到节点的距离
	while(p1!=p2){//比较祖先深度，哪一方深度深，哪一方就往上爬
		if(b[p1]>b[p2])p1=f[p1],d1++;
		else if(b[p1]<b[p2])p2=f[p2],d2++;
		else p1=f[p1],p2=f[p2],d1++,d2++;//可同时进行
	}
	return d1*2+d2;//可以在往上爬的同时记录，也可最后根据先前制定的b数组进行加减
}
```


---

## 作者：LB_tq (赞：1)

```
倍增LCA
这道题的数据范围小，所以可以暴力过。
蒟蒻正在学LCA，所以用倍增写了这道题。
由题意可知两点距离的定义，
所以只要知道询问的两个点的深度和最近公共祖先的深度即可
#include<iostream>
#include<cstdio>
using namespace std;
struct node{
    int v;
    int t;
}e[210];//邻接表存树，由于是双向边，所以数组开到2倍
int a1,a2,s,n,q,f[110],w[110],d[110],a[8][110];//a[j][i]表示从第i个点向上跳(i<<j)个单位（即2^j个单位）后到达的点
//f数组存储树
//w[i]表示深度为i的点的个数
//d[i]表示第i个点的深度
int fr(){
    char c=getchar();
    while(c>'9'||c<'0')
        c=getchar();
    int sum=c-'0';
    while((c=getchar())<='9'&&c>='0')
        sum=sum*10+c-'0';
    return sum;
}//快读
void add(int x,int y){
    s++;
    e[s].v=y;
    e[s].t=f[x];
    f[x]=s;
}//加边函数
void dfs(int u,int p){
    d[u]=d[p]+1;
    a1=max(a1,d[u]);//更新树的深度
    for(int i=1;i<=7;i++)
        a[i][u]=a[i-1][a[i-1][u]];//递推求出该路径上点的LCA
    int x;
    for(int i=f[u];i!=0;i=e[i].t){
        x=e[i].v;
        if(x==p)
            continue;//如果指向节点为父节点，为了避免死循环，continue。
        a[0][x]=u;
        dfs(x,u);//搜索子节点
    }
}//DFS算出每个点的深度
int lca(int x,int y){
    if(d[x]<d[y])
        swap(x,y);//默认x深度大向上跳
    int h=d[x]-d[y];//向上跳的深度
    for(int i=7;i>=0;i--)
        if(d[a[i][x]]>=d[y])
            x=a[i][x];//直到深度相同为止
    if(x==y)
        return x;//如果此时节点相同，那么直接返回该节点
    for(int i=7;i>=0;i--)
        if(a[i][x]!=a[i][y]){
            x=a[i][x];
            y=a[i][y];
        }//一起向上跳，直到父节点相同（如果把节点相同作为判断条件，所得点不一定是最近的公共祖先）
    return a[0][x];//返回父节点
}
int query(int x,int y){
    return (d[x]-d[lca(x,y)])*2+d[y]-d[lca(x,y)];
}//根据公式查询距离
int main(){
    int x,y;
    n=fr();
    for(int i=1;i<=n-1;i++){
        x=fr();
        y=fr();
        add(x,y);
        add(y,x);//正反都建边
    }
    dfs(1,0);
    cout<<a1<<endl;//深度
    for(int i=1;i<=n;i++){
        w[d[i]]++;
        a2=max(a2,w[d[i]]);//宽度
    }
    cout<<a2<<endl;
    x=fr();
    y=fr();
    cout<<query(x,y);//距离
    return 0;
}
```


---

## 作者：bh1234666 (赞：0)

感觉上一篇题解倍增没讲的很清楚~~作为一个蒟蒻，我做这题时没能理解这篇题解~~，所以理解了想再讲讲（~~就算不通过还可以在洛谷博客存个档自己看看嘛~~）

**上代码**
```
#include<cstdio>
using namespace std;
struct point{
	point* next;
	int n;
};
point* tree[105];//用邻接表存的图
int high[105];//记录每个点所在深度
int f[105][100];//f[i][j]记录第i个点向上跳2^j次所能跳到的点
int wide[105],highmax,widemax;//记录每层的宽度
int log2(int n)//log函数（不想解释了）
{
	int i;
	for(i=0;(1<<i)<=n;i++);
	return i-1;
}
void dfs(int x,int h,int father)//遍历树
{
	f[x][0]=father;//初始化倍增数组（将每个点向上2^0（1）个（其实就是父亲）的点记录下来）
	high[x]=h;//记录每个点所在高度
	wide[h]++;//所在高度（h）的宽度加一
	if(highmax<h) highmax=h;//记录最大高度
	if(widemax<wide[h]) widemax=wide[h];//记录最大宽度（不想写max了）
	point* a=tree[x];
	while(a!=NULL)//遍历所有儿子
	{
		dfs(a->n,h+1,x);
		a=a->next;
	}
	return ;
}
int find(int x,int h)//x向上跳h次
{
	int i;
	for(i=0;(1<<i)<=h;i++)
		if((1<<i)&h) x=f[x][i];//如果h的二进制的第i+1位是1则x向上跳2^i次（有关二进制就不想说了）
	return x;
}
int go(int x,int y)//x和y一起向上跳
{
	int i,cnt=0;
	for(i=log2(high[x]);i>=0;i--)//从最远能跳距离开始越跳跳的距离越短（不可以反过来，否则最后可能没法跳到目标点）
		if(f[x][i]!=f[y][i])//如果x和y一起跳2^i后不在一个点（在一个点意味着已经跳到公共祖先或以上）
		{
			x=f[x][i];//一起跳
			y=f[y][i];
			cnt+=(1<<i);//记录跳的距离
		}
	return cnt+1;//跳完最后一步（跳到公共祖先上）后返回
}
int main()
{
	int i,n,u,x,y,cnt;
	scanf("%d",&n);
	for(i=1;i<n;i++)//建树
	{
		scanf("%d%d",&x,&y);
		point* a=tree[x];
		tree[x]=new(point);
		tree[x]->n=y;
		tree[x]->next=a;
	}
	scanf("%d%d",&x,&y);
	dfs(1,1,1);//遍历树得到各项数据
	printf("%d\n%d\n",highmax,widemax);//输出高和宽
	for(i=1;(1<<i)<=n;i++)
		for(u=1;u<=n;u++)
			f[u][i]=f[f[u][i-1]][i-1];//倍增的关键，最后解释（有点写不下，影响美观）
	if(high[x]>high[y]) cnt=(high[x]-high[y])*2;//记录x跳到和y一样高的代价
	else cnt=high[y]-high[x];//记录y跳到和x一样高的代价
	if(high[x]>high[y]) x=find(x,high[x]-high[y]);//跳到一样高
	else if(high[x]<high[y]) y=find(y,high[y]-high[x]);
	if(x==y) printf("%d",cnt);//如果已经在一起就直接输出
	else printf("%d",cnt+go(x,y)*3);//否则一起向上跳，由于x向上跳的代价是2*go（x，y），y的代价是go（x，y），所以总共乘3。
	return 0;
}
```

倍增算法最关键的就是这几句：
```
for(i=1;(1<<i)<=n;i++)
	for(u=1;u<=n;u++)
		f[u][i]=f[f[u][i-1]][i-1];
```
它的原理是：将计算点u向上跳2^i次所到的点转化为计算点u向上跳2^(i-1)次后所到的点再向上跳2^（i-1）次所到的点

通俗的讲，就是把计算u的爷爷转化为计算u的爸爸的爸爸，把计算u的增增爷爷转化为计算u的爷爷的爷爷

---

## 作者：molasses (赞：0)

DFS 维护结点到根结点的边数（深度）$dist_i$，树深度为 $maximum(dist_i)$，树宽度为 $maximum(n(dist_i))$.

BFS 求从 $u$ 到 $v$ 的最短路，队列内状态（Inqnode）维护三个数据：当前结点编号，从 $u$ 到当前结点的上行边数、下行边数，后两者根据 $dist_{current}$ 和 $dist_{expanding}$ 的深浅关系即可判断.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  const int kMaxn = 101;
  int n;
  cin >> n;
  vector< vector<int> > bitree(kMaxn);
  vector<int> dist(kMaxn, -1);
  for (int i = 0; i < n - 1; ++i) {
    int x, y;
    cin >> x >> y;
    bitree[x].push_back(y);
    bitree[y].push_back(x);
  }
  // cerr << "----------\n";
  vector<bool> vis(kMaxn, false);
  function<void(int, int)> dfs;
  dfs = [&](int p, int d) {
    // cerr << p << ' ';
    vis[p] = true;
    dist[p] = d;
    for (int q : bitree[p]) if (!vis[q]) {
      vis[q] = true;
      dfs(q, d + 1);
    }
  };
  dfs(1, 0);
  // cerr << '\n' << "dfs: ";
  // for (int dd : dist)
    // cerr << dd << ' ';
  // cerr << '\n';
  int width = -1, depth = -1;
  for (int x = 1; x < kMaxn; ++x) {
    int cnt = 0;
    for (int i = 1; i < kMaxn; ++i) {
      if (dist[i] == -1) continue;
      if (dist[i] == x) ++cnt;
      depth = max(depth, dist[i] + 1);
    } 
    width = max(width, cnt);
  }
  cout << depth << '\n' << width << '\n';
  int u, v;
  cin >> u >> v;
  if (u == v) {
    cout << "0\n";
    return 0;
  }
  typedef pair< int, pair<int, int> > Inqnode;  // node_num, up_act, down_act
  fill(vis.begin(), vis.end(), false);
  queue<Inqnode> q;
  q.emplace(u, make_pair(0, 0));
  while (!q.empty()) {
    Inqnode a = q.front();
    q.pop();
    if (a.first == v) {
      // cerr << v << ' ' << a.second.first << ' ' << a.second.second << '\n';
      cout << a.second.first * 2 + a.second.second << '\n';
      break;
    }
    for (int b : bitree[a.first]) if (!vis[b]) {
      Inqnode bb = make_pair(b, make_pair(a.second.first, a.second.second));
      if (dist[b] < dist[a.first]) {
        bb.second.first++;
      } else {
        bb.second.second++;
      }
      q.push(bb);
      vis[b] = true;
    }
  }
  return 0;
}
```


---

## 作者：傅思维666 (赞：0)


一道LCA的好题。

介绍一下**大体思路**和**自己出的bug**。

首先存边，存边的时候要存单向边，要不然深搜的时候会卡死在里面。

然后是深搜，深搜主要是预处理的过程，预处理deep数组和fa数组分别记录每个点的深度和父亲节点。具体实现见代码。

然后我们开始枚举最大深度和最大宽度，详见代码，截至此时就出了前两个答案。

最后就是LCA的过程。

可以写倍增LCA，但是倍增LCA其实就是普通朴素LCA的优化，所以我写了朴素LCA（就会这个）（俗名爬一爬）。

**这里的LCA函数不是记录公共祖先，而是记录这两个点各向上爬了多少的深度，这里要注意！！因为你会有swap操作，所以你swap之后你的depth1和depth2记录的点向上爬的距离要反着取（以前是1记录x,2记录y，现在要反过来）**



然后就可以AC了。



代码：

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans1,ans2,depth1,depth2;
int tot,to[202],nxt[202],head[101];
int fa[101],deep[101],width[101];
void add(int x,int y)
{
	to[++tot]=y;
	nxt[tot]=head[x]; 
	head[x]=tot;
}
void dfs(int x,int pre,int step)
{
	fa[x]=pre;
	deep[x]=step;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		dfs(y,x,step+1);
	}
}
void lca(int x,int y)
{
	if(deep[x]<deep[y])
	{
		swap(x,y);
		while(deep[x]>deep[y])
			x=fa[x],depth2++;
		while(x!=y)
		{
			x=fa[x],y=fa[y];
			depth2++;
			depth1++;
		}
	}
	else
	{
		while(deep[x]>deep[y])
			x=fa[x],depth1++;
		while(x!=y)
		{
			x=fa[x],y=fa[y];
			depth1++;
			depth2++;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
	}
	dfs(1,0,1);
	for(int i=1;i<=n;i++)
		width[deep[i]]++;
	for(int i=1;i<=n;i++)
		ans1=max(ans1,deep[i]);
	for(int i=1;i<=n;i++)
		ans2=max(ans2,width[i]);
	int u,v;
	scanf("%d%d",&u,&v);
	lca(u,v);
	printf("%d\n%d\n%d",ans1,ans2,depth1*2+depth2);
	return 0;
}
```



---


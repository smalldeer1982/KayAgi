# [SCOI2003] 蜘蛛难题

## 题目描述

有一堆管道，还有一个蜘蛛$\text{Willy}$，如下图所示。所有管道的是上端开口，下端封底，直径都是$1cm$，连接两个管道的连接容量无限，但体积可以忽略不计。

![](https://cdn.luogu.com.cn/upload/pic/43701.png)

在第一个管道上方有一个水源，从中有水不断往下流，速度为每秒$0.25cm^3$。由于管道横截面积为$0.25cm^3$，所以单给一个管道注水时水面每秒上升$1cm$。根据物理知识，在前$2$秒中，水注如左边的管道底部，第$[3,5]$秒时注入右边的管道，第$[6,9]$秒同时注入两个管道（虽然流量不变，但是由于同时给两个管道注水，因此水面上升的速度仅为每秒$0.5cm$），接触到蜘蛛。 给出管道和管道之间连接的位置，以及蜘蛛$\text{Willy}$的位置，求水面接触到$\text{Willy}$的时间。假设蜘蛛的实际位置比给出的略高一点，因此如果蜘蛛在左边管道的$n=4$的位置，答案应该是$5$秒。因为前两秒后水面虽然看起来接触到了$\text{Willy}$，但实际上比$\text{Willy}$略低一点。



## 样例 #1

### 输入

```
2
2 0 6
5 1 6
1
3 4 2
2 2```

### 输出

```
9```

# 题解

## 作者：shentao1 (赞：4)

~~坑爹题目，毁我青春~~

首先有想法就是从起点往后按照出水管依次满足，但多个水域需要合起来求下一个最低出水口，所以并不是很好维护

所以最好按照时间模拟

先求出当前状态下的最低水平面，

然后看这些最低的面能不能通过出水口到达新的水坑，把这些水坑加入当前状态

然后再求一次当前状态下的最低水平面

然后再把他们依次灌1

直到蜘蛛所在的上一块被灌，输出上次的答案



#### 然后就需要根据题目坑爹的描述特判：

#### 1、第一个水坑的坑底的蜘蛛0秒被灌

#### 2、正好在坑顶的蜘蛛会被灌

然后就做完啦

last but not least，代码闪亮登场：

```cpp
//码风丑，不喜勿喷
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
using namesbace std;
int n,i,m,v[30],v2[30],x,y,yy,ans,minn,zd,sx[30],j,top,last;
bool vis[30];
struct la
{
	int x,y,yy;
}g[30];
vector<int>vv;
int tu[105],lt[30][205],sta[30];
bool cmp(la a,la b)
{
	return a.x<b.x;
}
void dfs(int o)
{
if(vis[lt[o][g[o].y+g[o].yy]]==0)
{
	vis[lt[o][g[o].y+g[o].yy]]=1;
	vv.push_back(lt[o][g[o].y+g[o].yy]);
	dfs(lt[o][g[o].y+g[o].yy]);		
}
} 
int main()
{vis[0]=1;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
   {
   	scanf("%d%d%d",&g[i].x,&g[i].y,&g[i].yy);  	
   }
   scanf("%d",&m);
   for(i=1;i<=n;i++)tu[g[i].x]=i;
//   memset(v,0x7f,sizeof(v));
   for(i=1;i<=m;i++)
   {
   	scanf("%d%d%d",&x,&y,&yy);
lt[tu[x-1]][y]=tu[x+yy];
lt[tu[x+yy]][y]=tu[x-1];   
   }
   minn=999999;
   scanf("%d%d",&zd,&yy);
   if(zd==1&&yy==g[1].y+g[1].yy)
   {
   	printf("0");
   	return 0;
   }
   vv.push_back(1);
   vis[1]=1;
   while(1)
   {
   	//求出目前水位最低的
   	int maxx=-1;
   	top=0;
   	   for(i=0;i<vv.size();i++) 
	    {   if(maxx==g[vv[i]].y+g[vv[i]].yy)
	    	{
	    		sta[++top]=vv[i];	    		
			}			
			if(g[vv[i]].y+g[vv[i]].yy>maxx)
	    	{
	    		top=0;
	    		maxx=g[vv[i]].y+g[vv[i]].yy;
	    		sta[++top]=vv[i];
			}
		}
   //如果加进去最终会流到哪 
for(i=1;i<=top;i++)
{
	dfs(sta[i]);
}
   //再求一遍当前最小 
   top=0;
   	   	   for(i=0;i<vv.size();i++) 
	    {   if(maxx==g[vv[i]].y+g[vv[i]].yy)
	    	{
	    		sta[++top]=vv[i];	    		
			}			
			if(g[vv[i]].y+g[vv[i]].yy>maxx)
	    	{
	    		top=0;
	    		maxx=g[vv[i]].y+g[vv[i]].yy;
	    		sta[++top]=vv[i];
			}
		}
   //果断加水
   for(i=1;i<=top;i++)
   {
   	if(sta[i]==zd&&g[sta[i]].y+g[sta[i]].yy==yy)
   	{
   	printf("%d",ans);
	   return 0;		
	}
   }
       for(i=1;i<=top;i++)
	   {
	g[sta[i]].yy--;
	ans++;
	if(g[sta[i]].yy<0) 
	{
    printf("-1");
	return 0;		
    }  	
	   }	
	//检验答案
	   if(g[zd].y+g[zd].yy+1==yy)
	   {
	   	printf("%d",last);
	   return 0;
	   }   	
	   last=ans;
   }
}

```


---

## 作者：philosopherchang (赞：4)

看没人发题解，我来一发~~（看着别人的CSDN改代码，一共交了22遍才AC，太弱了我）~~

这是一个模拟，把管道看成是两条边，连着两个点，每个点有一个极限权值，如果大于就输出-1，因为水面再也无法上涨了；水从第一个点开始流，然后按照常识去算什么时候可以流到另一个管子里；首先将所有没有水但是可以被灌到水的管子标记为有水，然后求出有水的管子里水面高度的最小值。如果蜘蛛所在的管子有水且最小值为蜘蛛的位置，那么说明此时蜘蛛碰到了水，因为如果最小值大于蜘蛛高度，那么蜘蛛一定会被淹死，管子是个连通器。然后我们就比较深度就可以了，深度可以转化成高度，逆转一下，就比较好想了。

附上改了20多遍的代码~~（不算抄吧）~~

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std; 
struct node{
	int x,y,h;
}a[201];
bool f[201];
int n,m,x,y,z,t,cnt,head[2001],u,v,w;
struct Edge{
    int w,nxt,to;
}edge[201*201];
int hh(int x)
{
	for(int i=1;i<=n;i++)
	{
		if(a[i].x==x)
		return i;
	}
}
void add(int u,int v,int w)
{
    edge[++cnt].to=v;
    edge[cnt].nxt=head[u];
    edge[cnt].w=w;
    head[u]=cnt;
}
int main() 
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].h);
		a[i].h+=a[i].y;
	}
	f[1]=1;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		w=hh(u+w);
		u=hh(u-1);
        add(u,w,v);
		add(w,u,v);
	}
	scanf("%d%d",&x,&y);
	while(1) 
	{
		bool ff=1;
        while(ff)
        {
            ff=0;
            for(int i=1;i<=n;i++)
            {
            	if(f[i])
        		{
            		for(int j=head[i];j;j=edge[j].nxt)
		           	{
					   	if(a[i].h<=edge[j].w&&!f[edge[j].to])
			            f[edge[j].to]=ff=1;
					} 
				}
			}
        }
		int maxn=0;
		for(int i=1;i<=n;i++)
		{
			if(f[i])
			maxn=max(maxn,a[i].h);
			if(f[x]&&maxn==y)
			{
				cout<<t<<endl;
				return 0;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(f[i]&&a[i].y==a[i].h&&a[i].y==maxn)
			{
				cout<<"-1";
				return 0;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(f[i]&&a[i].h==maxn)
			{
				a[i].h--;
				t++;
			}
		}
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：
按时间一步一步模拟。

每一次，首先将所有没有水但是可以被灌到水的管子标记为有水，然后求出有水的管子里水面高度的最小值。

如果 $a$ 号管有水且最小值为 $b$，那么说明此时蜘蛛碰到了水。

如果有管子溢出且最小值就是它，那么说明此时无论如何水面都不会再上涨，即无解。

然后往所有高度等于最小值的管子里灌上一高度的水即可。
### 完整代码：
```cpp
#include<bits/stdc++.h>
const int N=25,M=110;
int n,m,i,j,x,y,z,A,B,T,G[N],to[M],w[M],nxt[M],l;
struct Node{
	int x,y,h,to;
}a[N];
int find(int x){
	for(int i=1;i<=n;i++)
	  if(a[i].x==x)
	    return i;
}
void add(int x,int y,int z){
	to[++l]=y,w[l]=z,nxt[l]=G[x],G[x]=l;
	to[++l]=x,w[l]=z,nxt[l]=G[y],G[y]=l;
}
int main(){
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].h);
		a[i].h+=a[i].y,a[i].to=(bool)(i==1);
	}
	scanf("%d",&m);
	while(m--)
	  scanf("%d%d%d",&x,&y,&z),add(find(x-1),find(x+z),y);
	scanf("%d%d",&A,&B);
	while(1){
		for(x=1;x;)
		  for(x=0,i=1;i<=n;i++)
		    if(a[i].to)
			  for(j=G[i];j;j=nxt[j])
			    if(a[i].h<=w[j]&&!a[to[j]].to)
				  a[to[j]].to=x=1;
		for(m=0,i=1;i<=n;i++)
		  if(a[i].to&&a[i].h>m)
		    m=a[i].h;
		if(a[A].to&&m==B){
			printf("%d",T);
			exit(0);
		}
		for(i=1;i<=n;i++){
			if(a[i].to&&a[i].y==a[i].h&&a[i].y==m){
				puts("-1");
				exit(0); 
			}
		}
		for(i=1;i<=n;i++)
		  if(a[i].to&&a[i].h==m)
		    a[i].h--,T++;
	}
	return 0;
}
```


---

## 作者：sto__Liyhzh__orz (赞：1)

[传送门](https://www.luogu.com.cn/problem/P5045)

是隔壁四川的省选题也。

按照时间模拟。

先求出现在的最低水平面，然后看这些最低的面，

能否通过出水口到达新水坑，能就把这些水坑加入当前状态。

在求出当下状态的最低水平面，把他们依次灌水。

直到蜘蛛被淹了，就输出上次的答案。

特判：

一号水坑坑底的蜘蛛会 **$0$ 秒**被灌。

正好就在**坑顶**的蜘蛛**会**被灌。

---


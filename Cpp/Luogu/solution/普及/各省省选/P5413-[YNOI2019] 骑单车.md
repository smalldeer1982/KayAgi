# [YNOI2019] 骑单车

## 题目描述

小明每天早晨上课都需要骑着单车经过 $n$ 段路，第i段路的长度为$w_i (m)$，限速为 $s_i (m/s)$（在路上骑行的速度不能超过限速），加速度的绝对值最大为 $a_i (m/s^{2})$（可以加速也可以减速）。初始速度为 $0(m/s)$，你的任务是计算小明通过这 $n$ 段路的最短时间。

## 说明/提示

对于 $60\%$ 的数据：$0 < n \le60;$

对于 $80\%$ 的数据：$0 < n \le 80;$

对于 $100\%$ 的数据：$0 < n \le10^{2},w_i,s_i,a_i ≤ 10$。

## 样例 #1

### 输入

```
1
2
5 3 1
1 1 1
```

### 输出

```
4.6904157598```

# 题解

## 作者：qjyzLfy (赞：13)

## 分析

### 1

加速时，显然小明一定会用最快的加速度；然后，小明一定会在较高的速度下保持尽量长的时间，所以要尽量缩短减速时间，因此减速时也会用最大加速度。

为了更好地证明这一观点，可以作小明的 $\text{v-t}$ 图像，图像面积即为路程，斜率即为加速度。显然，面积一定，要使时间尽量小，就要使图像尽量“凸”，所以要使加速度尽量大。

![](https://cdn.luogu.com.cn/upload/image_hosting/sc2e5caf.png)

### 2

高中运动学公式。对于匀加速直线运动，有：

$$|{v_1}^2-{v_2}^2|=2ax$$

证明：

$ x = \bar{v}t=\dfrac{v_1+v_2}{2}\cdot\dfrac{|v_1-v_2|}{a}=\dfrac{|{v_1}^2-{v_2}^2|}{2a} $

去分母即得上公式。

### 3

小明会让自己的速度尽量大，但是各种客观条件会限制他的速度的上限。

具体来说，在某一段路上，除了不能超过限速之外，还要保证小明可以不超过限速地进入之后的路。也就是，不能发生下面的情况：

- 小明在这段路上一直以最大速行驶，结果一进入下一段路就超速了；

- 小明在这一段路上的速度过快，之后无论再怎么减速，也会在某段路（不一定是下一段）上超速。

显然，为了不在之后的路上超速，小明在每段路的**末尾**都会有一个最大的允许速度 $vr$ 。$vr$ 受到这段路之后的路的限速和加速度的限制。

显然，小明在每段路的**开端**也都会有一个最大的可能速度 $vl$ ， $vl$ 受到这段路之前的路的限制。对于相邻的两段路，前一段的 $vr$ 等于后一段的  $vl$ 。

### 4

如果确定了一段路的 $vl$ 和 $vr$ ，这段路中间小明的最优的运动方式就可以确定，而不受其它路段的影响了。

经过上面的分析， $vl$ 和 $vr$ 所受的约束仅有 $\begin{cases}vr_i=vl_{i+1}\\vr_i,vl_i\le lim_i\\|{vl_i}^2-{vr_i}^2|\le 2a_i\cdot len_i\end{cases}$ 。

其中 $lim_i$ 为限速， $len_i$ 为路的长度。

第三式（以加速的情况为例）的原理是：左式对应一直加速所需的路程，右侧对应实际路程。显然，中间有某一部分不加速，或者先加速又减速，都会使对应路程更长。

### 5

由于没有一定的优先顺序，可以先把 $vl,vr$ 都定为 $lim$ ，然后根据约束逐步缩小，直到不可缩小为止。

显然，如果还未得到满足所有约束的 $vl,vr$ ，则当前解状态一定有 $vl$ 或 $vr$ 可以被缩小；当 $vl,vr$ 不可根据约束缩小时，即得到最优解。

之后再算出各段路内部花费的时间即可。

### 6

一段路内部的情况只可能有两种：

- 小明从初速加速到限速，然后按限速行驶，最后减速到末速。

- 小明从初速加速到某一速度后不得不立即减速，最后减速到末速。

可以先分别算出从初速加速到限速和从限速减速到末速所需的路程 $tx1,tx2$ ，如果路程之和大于 $len_i$ 就是第二种情况。

第一种情况容易解决：

$t=\dfrac{v_{lim}-v_{vl}}{a}+\dfrac{x_{len}-x_{tx1}-x_{tx2}}{v_{lim}}+\dfrac{v_{lim}-v_{vr}}{a}$ 

对于第二种情况，设加速到的最大的速度为 $vm$ ，有：

$\dfrac{{v_{vm}}^2-{v_{vl}}^2}{2a}+\dfrac{{v_{vm}}^2-{v_{vr}}^2}{2a}=x_{len}$ 

$\Rightarrow \ {v_{vm}}^2=a\cdot x_{len}+\dfrac{{v_{vl}}^2+{v_{vr}}^2}{2}$

而 $t=\dfrac{v_{vm}-v_{vl}}{a}+\dfrac{v_{vm}-v_{vr}}{a}=\dfrac{2v_{vm}-v_{vl}-v_{vr}}{a}$

## 代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int t,n;
double len[111],lim[111],a[111];
double vl[111],vr[111];
double ans;
double tv,tx1,tx2;//临时用的变量. 
bool flag; 

int main()
{
	scanf("%d",&t);
	vr[0]=0;//必须从0开始加速. 
	while(t--){
		scanf("%d",&n);
		vl[n+1]=1111;//方便约束 vr[i] 和 vl[i+1] 的关系. 
		for(int i=1;i<=n;++i){
			scanf("%lf%lf%lf",&len[i],&lim[i],&a[i]);
			vl[i]=vr[i]=lim[i];
		}
		do{//缩小 vl 和 vr. 
			flag=0;
			for(int i=1;i<=n;++i){
				if(vl[i]>vr[i-1])	vl[i]=vr[i-1],flag=1;
				if(vr[i]>vl[i+1])	vr[i]=vl[i+1],flag=1;
				if(vl[i]<vr[i]){//用较小的约束较大的,而不是相反. 
					tv=sqrt(vl[i]*vl[i]+2.0*a[i]*len[i]);// 
					if(vr[i]>tv)	vr[i]=tv,flag=1;
				}
				else{
					tv=sqrt(vr[i]*vr[i]+2.0*a[i]*len[i]);
					if(vl[i]>tv)	vl[i]=tv,flag=1;
				}
			}
		}while(flag) ;//flag==0 说明无法继续收缩. 
		ans=0;
		for(int i=1;i<=n;++i){
			tx1=(lim[i]*lim[i]-vl[i]*vl[i])/(2.0*a[i]);
			tx2=(lim[i]*lim[i]-vr[i]*vr[i])/(2.0*a[i]);
			if(tx1+tx2>len[i]){//无法加速到限速.
				tv=sqrt(a[i]*len[i]+(vl[i]*vl[i]+vr[i]*vr[i])*0.5);//此处 tv 即文章中 vm 
				ans+=(tv+tv-vl[i]-vr[i])/a[i];
			}
			else{//可以加速到限速. 
				ans+=(lim[i]+lim[i]-vl[i]-vr[i])/a[i]+(len[i]-tx1-tx2)/lim[i];
			}
		}
		cout<<ans;
	}
	return 0;
}
```

---

## 作者：Felis (赞：8)

## 0.总结
这道题不难，但是很恶心
## 1.正文
### 1.1 分析
本题的要求是找到时间的最小值，众所周知，路程相同，速度越大，时间越小，所以我们要**使速度尽可能大**。并且速度改变越快肯定是越优的，所以每次加速或减速时**加速度都应该保持在最大**。
### 1.2 思路
我们可以分成2种情况
#### 第一种
在这条路上，我们先加速到了最大速度，然后保持了一段时间，最后减速到下一个速度。所以
$$S=V_i*t_i$$

我们又可以知道，因为匀速加速（减速），所以

$$V_i=(V_0+V)/2$$
并且加速度为ai,所以
$$t_i=(V-V_0)/a_i$$
合在一起
$$S=(V_0+V)(V-V_0)/2a_i$$

如果我们用*pre*和*nxt*表示前一个和后一个速度的话，那么：

```cpp
	add.v=r[i].v-pre,add.s=(r[i].v+pre)*5.0/10.0*add.v/r[i].a;
    minus.v=r[i].v-nxt,minus.s=(r[i].v+nxt)*5.0/10.0*minus.v/r[i].a; 
```
但是这个东西有一个前提，那就是我们可以加速到最大速度然后减速，即加速路程加减速路程小于总路程，那么有一个条件，满足这个条件我们就可以输出答案。

这一部分的整个代码是：
```cpp
	add.v=r[i].v-pre,add.s=(r[i].v+pre)*5.0/10.0*add.v/r[i].a;
    minus.v=r[i].v-nxt,minus.s=(r[i].v+nxt)*5.0/10.0*minus.v/r[i].a; 
    if(r[i].s>=add.s+minus.s)
        ans+=add.v/r[i].a+minus.v/r[i].a+(r[i].s-add.s-minus.s)/r[i].v,
```
#### 第二种
我们说了，第一种有一个前提，那么不满足这个前提时，也就是说无法加速到最大速度时，我们就需要求出可以达到的最大速度，那么套一下刚才的公式，可以得到，加速的路程是  
$$(V_0+V)(V-V_0)/2a_i$$
那么减速的路程也是这样，再加上总路程小于s，我们就可以得到
$$(V_0+V)(V-V_0)/2a_i+(V_1+V)(V-V_1)/2a_i≤s_i$$
化简一下
$$2*V^2≤2a_is_i+V_0^2+V_1^2$$
很明显，当不等式左边取最大值时，V最大。所以当左边等于右边时，V最大，则V最大是
$$\sqrt{(2a_is_i+V_0^2+V_1^2)/2}$$
所以当不满足第一种情况时，就有
``` cpp

        double v;
        v=sqrt((2.0*r[i].a*r[i].s+pre*pre+nxt*nxt)*5.0/10.0);             
        ans+=(v-pre)/r[i].a+(v-nxt)/r[i].a;               
```
### 1.3 代码实现
在解决了重要算法后，还有一个问题，那就是*pre*与*nxt*的值。

***pre*的初值**:
因为*pre*是初始速度，那么应该是上一条路结束速度与这一条路限速的较小值。

***nxt*的初值**:
因为*nxt*是结束时的速度，所以应该是这条路与下一条路的限速的较小值。

***Vi*的初值**:
需要考虑2个因素，第一个是如果在一条路上开得太快了，那么有可能下一条路不会超速，但是因为减速度不够，下下条路超速了。所以我们应该提前将每一条路的限速设为
$$V_i=Min(V_i,\sqrt{2*ai*si+V_{i+1}^2})$$
第二个因素是就算全程都在加速，那么也会有一个最大速度，所以还有
$$V_i=Min(V_i,\sqrt{2*ai*si+pre^2})$$

**第N+1条路**:
这条路实际不存在，但因为题目问的是通过的最小时间，所以最后没必要减为0，所以给第N+1条路的限速赋值为无限大或第N条路的限速。

### 1.4 代码时间
```cpp
#include<bits/stdc++.h>
#define double long double //卡精度（应该是）
using namespace std;
struct road {
	double s,a,v;
} r[105];
int t,n;
int main() {
	scanf("%d",&t);
	while(t--) {
		scanf("%d",&n);
		for(int i=0; i<n; i++)
			scanf("%Lf%Lf%Lf",&r[i].s,&r[i].v,&r[i].a);//long double 用Lf读入
		double ans=0.0,pre=0.0;//初速度为0
		for(int i=n-2; ~i; i--)
			r[i].v=min(r[i].v,sqrt((2.0*r[i].a*r[i].s+r[i+1].v*r[i+1].v)));第一个因素
		r[n].v=r[n-1].v;
		for(int i=0; i<n; i++) {
			road add,minus;
			r[i].v=min(sqrt(pre*pre+2.0*r[i].a*r[i].s),r[i].v);//第二个因素
			double nxt=min(r[i].v,r[i+1].v);
			add.v=r[i].v-pre,add.s=(r[i].v+pre)*5.0/10.0*add.v/r[i].a;
			minus.v=r[i].v-nxt,minus.s=(r[i].v+nxt)*5.0/10.0*minus.v/r[i].a;
			if(r[i].s>=add.s+minus.s) {//如果可以加速到限速
				ans+=add.v/r[i].a+minus.v/r[i].a+(r[i].s-add.s-minus.s)/r[i].v;
				pre=min(r[i].v,r[i+1].v);
			} else {//如果不能加速到限速
				double v;
				v=sqrt((2.0*r[i].a*r[i].s+pre*pre+nxt*nxt)*5.0/10.0);
				ans+=(v-pre)/r[i].a+(v-nxt)/r[i].a;
				pre=min(v,r[i+1].v);
			}
		}
		cout<<ans;//只有一组数据哒QwQ
        在这里我如果用printf会有精度错误，知道原因的dalao如果愿意就私信告诉我吧
	}
}

```


---

## 作者：DGFLSzfd (赞：4)

2024.7.31 晚终于将此题做对，写此题解以记录思路和过程。\
以后谁再说普及 - 是水题，我一定让他看这题。~~(偷偷流泪)~~
（求通过，各种问题改了10次了）

---

## 浅谈此题

本题是我认为最优秀的跨学科题目之一，采用了信息技术贪心的解题方式，数学的分类讨论思维以及**物理的公式熟练运用**。

## 知识前置

### 注：高中生可以直接跳过

对于初中生、小学生而言，我认为这题完全可以评到普及 + 一旦你学完物理必修（一）的加速度，这题便会难度骤降。\
本题适合各位同时热爱信息和物理的同学挑战！

### 知识点一：加速度的概念

请先观看[【高中物理必修（一）1.4 加速度】](https://www.bilibili.com/video/BV1sw4m1R7cz/?share_source=copy_web\&vd_source=fa3b320744b0ed65f4495c5e4322ca89)。\
看完该该视频你应该已经初步了解了什么是加速度了。

1. 加速度是描述速度变化快慢的物理量（米每秒每秒）。
2. 加速度的物理含义是描述速度变化的快慢。
3. 加速度等于速度的变化除以相应的变化时间。\
   （即: $\large a\text{(加速度)}=\frac{V\text{(当前速度)}-V_{0} \text{(初始速度)}}{t\text{(变化时间)}}$)

### 知识点二：加速度相关的公式以及推导过程

1. 匀变速直线运动的速度与时间关系的公式 ${\large V_{t}=V_{0}+at}$
2. 平均速度 ${\large \overline{V}(\text{平均速度})= \frac{(V_{0}+V)} 2}$

3. 时间与速度变化的关系(由加速度定义式转变而来)${\large t\text{(变化时间)}=\frac{V_{t} \text{(当前速度)}-V_{0}\text{(初始速度)}}{a\text{(加速度)}} }$
4. 匀变速直线运动的位移与时间关系的公式 ${\large S=v_{0} t+\frac 1 2  a t^{2}}$\
   推导过程如下：\
   已知 ${\large S=\overline{V} \times t}$\
   代入②后得 ${\large S=\frac{(V_{0}+V)} 2 \times t}$\
   代入①后得 ${\large  S=\frac{(V_{0}+V_{0}+at)}2 \times t}$\
   将式子展开得：${\large S=v_{0} t+\frac1  2 \times a t^{2}}$
5. **匀变速直线运动的位移与速度关系的公式 ${\large 2aS=v_{t}^{2}-v_{0}^{2}}$**
6. 推导过程如下：\
   已知 ${\large S=\overline{V} \times t}$\
   代入②后得 ${\large S=\frac{(V_{0}+V)}2 \times t}$\
   代入③后得 ${\large S=\frac{(V_{0}+V)}2 \times \frac{V_{t}-V_{0}}{a}}$\
   将式子展开得 **${\large 2aS=v_{t}^{2}-v_{0}^{2}}$**\
   将式子形变可得 **${\Large S=\frac {v_{t}^{2}-v_{0}^{2}}{2a}}$**（本篇最重要的公式！）\
   相信聪明的你到此一定对物理有了更深刻的了解！

## 思路推理

### 寻找目标

观察题目后不难发现，我们应当找出一个计算方法，分别计算再统计总数。所以接下来的思路推理应着重于思考**如何计算通过一段路的最短时间**。\
我门对一段路，现已知初始速度（也就是离开上一段路的速度）$speed(m/s)$、本段路的限速 $S(m/s)$、离开这段路的限速 $V_{next}$（也就是下一段路的限速)、本段路的长度 $w(m)$、本段路的最大加速度的绝对值 $a(m/s^{2})$\
我们既然要求时间，那我们就必须知道**速度峰值 $V$**。

### 推理影响因素

然而对于一段路的速度峰值 $V$ 实则是受到以下四个因素影响的：

1. 本段路限速\
   这是显而易见的，毕竟你开的再快也不能超速。
2. 下一段路的限速\
   同样，为了你能够符合要求的进入下一段路，离开时我们应把速度调整至合法的状态，峰值太高离开时可能刹不住车！
3. 初始速度与加速度\
   你速度的峰值取决于你的能力上限，极有可能你就算整条路都在加速你的峰值也很低。
4. 下下段路限速\
你由本段路进入下段路时符合当前限速，但是下段路就算一直减速也无法减到下下一段路的限速之内。因此我们还要考虑下下段路的峰值。（我们应对峰值按此**倒着**预处理，使一段路的峰值受到其后面所有路的约束）

### 基本理论想法

通过观察公式：匀变速直线运动的位移与时间关系的公式 
$${\Large S=v_{0}t+\frac12 \times  a t^{2}}$$ 
不难发现在路程相同的情况下加速度 $a$ 越大时间 $t$ 越小。\
**由此我们得出结论，要想时间少，只要变速，就必须是** **$a_{max}$**

### 答案计算

在受到条件①③④（①③④都是可以直接预处理的）的约束后，显然一段路的最短时间为 
$$ \text{(初始速度达到峰值的时间+峰值速度行驶的时间(可以为0)+峰值速度达到离开该路限速的时间)}$$
但是你会发现 
$$\text{(\text初始速度达到峰值的路程+峰值速度行驶的路程(可以为0)+峰值速度达到离开该路限速的路程)}$$
也许会大于这段路的长度。\
没错！我们还要**根据下一段路的限速寻找一个合法的峰值速度！**

#### 判定合法方式一

回顾前置知识中，匀变速直线运动的位移与速度关系的公式
$${\Large 2aS=v_{t}^{2}-v_{0}^{2}}$$ 
以及其变式 
$$S=\frac {v_{t}^{2}-v_{0}^{2}}{2a}$$
我们可知当前峰值下 $S_{V}=S_{加速}+S_{峰值速度匀速}+S_{减速}$\
认定该峰值合法则需 $S_{V}\le S(该段路的长度)$

#### 判定合法方式二

注：$V_{1}$ 是离开速度限速。\
寻找仅仅离开速度限速的影响下的最大峰值。\
要使 $V$ 尽量大则 $S_{V}$ 需尽量大。\
则要使 $S_{V}=S$ 展开为
$$\frac {\left(V_{0}+V\right)\left(V-V_{0}\right)}{2a}+\frac{\left(V_{1}+V\right)\left(V-V_{1}\right)}  {2a} = s$$
经简化得 $V_{MAX}=\sqrt{\frac{\left(2as+V_{0}^{2}+V_{1}^{2}\right)} 2}$\
若 $V_{MAX}<V(只条件①③④约束)$ 则不合法，否则合法。\
(注：选择一种方式判定即可，作者的代码中选用了第一种)

#### 情况一 在受到条件①③④的影响下峰值是合法的

情况一我们确定该峰值合法。则 $ans+=\frac{V-V_{0}}{a}+\frac{S-S_{加速}-S_{减速}}{V}+\frac{V-V_{1}}{a}$

#### 情况二 仍需下调寻找峰值速度

由于当前的 $S_{V}$ 不合法，我们应重新计算和法值。\
因为需 $S_{V}\le S(该段路的长度)$ 要使 $V$ 尽量大则 $S_{V}$ 需尽量大。\
则要使 $S_{V}=S$。展开为 
$$\frac{\left(V_{0}+V\right)\left(V-V_{0}\right)} {2a}+\frac {\left(V_{1}+V\right)\left(V-V_{1}\right)} {2a} = s$$
经简化得 $V_{MAX}=\sqrt{\frac{\left(2as+V_{0}^{2}+V_{1}^{2}\right)} 2}$\
则 $ans+=\frac{V-V_{0}}{a}+\frac{V-V_{1}}{a}$

### 细节整理

**$speed$ 的初值** ：因为 $speed$ 是初始速度，那么应该是上一条路结束速度与这一条路限速的较小值。\
**$V_{next}$ 的初值** ：因为 $V_{next}$ 是结束时的速度，所以应该是这条路与下一条路的限速的较小值。

## 代码展示

~~我最喜欢的环节~~

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e2+10;

struct rode_node
{
	long double w,v,a;//注意long double 存储！！！ 
} r[N];
int T;
int main()
{
	cin>>T;
	while(T--)
	{
		int n;cin>>n;
		for(int i=0;i<n;i++) cin>>r[i].w>>r[i].v>>r[i].a;//处理影响因素① 
		
		long double ans=0.0,speed=0.0;
		for(int i=n-2;i>=0;i--) 
			r[i].v=min(r[i].v,sqrt(2.0*r[i].a*r[i].w+r[i+1].v*r[i+1].v));//处理影响因素④ 
		r[n].v=r[n-1].v;//对于离开最后一段路时，无需把速度降为0，所以n+1段路的限速可以随便设置一个大数 
		
		for(int i=0;i<n;i++)
		{
			r[i].v=min(r[i].v,sqrt(2.0*r[i].a*r[i].w+speed*speed));//处理影响因素③ 
			
			long double v_next=min(r[i].v,r[i+1].v);//离开这段路的限速
			long double speed_up  =(speed+r[i].v) *(r[i].v-speed) *0.5/r[i].a;//初始速度加速到峰值的路程 
			long double speed_down=(v_next+r[i].v)*(r[i].v-v_next)*0.5/r[i].a;//峰值减速到限速的路程 
			
			if(r[i].w>=speed_up+speed_down)//情况一、足够加速到峰值再减速 
			{
				ans+=(r[i].v-speed)/r[i].a+
					(r[i].v-v_next)/r[i].a+//原理见时间与速度变化的关系 
					(r[i].w-speed_up-speed_down)/r[i].v;
				speed=v_next;
			}
			else//情况二、加速到一定时候就得减速 
			{
				long double v_max=sqrt( (2.0*r[i].a*r[i].w+pow(speed,2)+pow(v_next,2) ) /2 );//处理影响因素② 
				ans+=((v_max-speed)/r[i].a+(v_max-v_next)/r[i].a);
				speed=min(v_max,r[i+1].v);
			}
		}cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：_ksm_ (赞：2)

### 0.总结
一道物理题，有个保留小数的坑，总体来说是道好题。
### 1.思路
[题目传送门](https://www.luogu.com.cn/problem/P5413) 

我们不妨把每一段路都分为三段计算。其中当本段加速度最大值大于上段加速度最大值时第一阶段进行加速运动直到达到限速速度，反之在上一段路的第三阶段提前减速至本段限速速度，本段第一阶段匀速行驶。第二阶段永远保持限速速度行驶。当本段限速最大值小于下一段限速最大值，则第三阶段保持限速速度行驶，由下一段第一阶段进行加速。
### 2.公式
给没有学习过物理运动学的同学们普及一下本题运用的匀加速运动公式：

---

1.速度公式 $V_t=V_0+at$ 

2.位移公式 $S=V_0t+\displaystyle \frac{at^2}{2}$ 

---

其中 $V_0$ 为初始速度, $S$ 为位移， $a$ 为加速度。
### 3.部分代码实现
按照思路实现，判段部分可参考以下：

```cpp
if(s[i]>s[i-1]) t=(s[i]-s[i-1])/a[i];
sumt+=t;
w[i]-=s[i-1]*t+a[i]*t*t/2;
if(s[i+1]<s[i]) t=(s[i+1]-s[i])/(-a[i]);
sumt+=t;
w[i]-=s[i]*t-a[i]*t*t/2;
t=w[i]/s[i];
sumt+=t;
```

### 4.最后
完整代码请自行实现，感谢支持。

---

## 作者：ChuYilin2011 (赞：2)

建议先看我写的 [运动学讲解](https://www.luogu.com.cn/article/uf0mmeyh)。（本题解正文只给思路，具体式子是什么，会运动学公式才写得出来，所以这份运动学讲解请认真阅读，否则这题还想做出来？~~没门~~）

首先，显然只有用最大加速度（或其相反数），时间才可能少，如图。只要仔细看了我的运动学讲解你就知道这张图的意思了。

![](https://cdn.luogu.com.cn/upload/image_hosting/6zrztiz9.png)

那么，第 $i$ 段路末尾总有一个最大速度 $r_i$，受之后路段限速和最大加速度影响，因为可能小明骑太快，之后即使踩死刹车也会在**之后某路段（注意不一定是后一段）** 超速。同理，第 $i$ 段路开头也有一个最大速度 $l_i$，与之前限速和最大加速度有关。明显 $r_i=l_{i+1}$。对了，特别地，$l_1=0$，$r_n=s_n$。

那么显然有 $\begin{cases}r_i=l_{i+1}\\l_i,r_i \le s_i\\\dfrac{\left|l_i^2-r_i^2\right|}{2a_i}\le w_i\end{cases}$。

注意（3）式要带上绝对值，因为题目给的 $a_i$ 和 $w_i$ 都是正的，而 $l_i$ 和 $r_i$ 的大小我也不知道。

所以我们可以先将 $l_i$ 和 $r_i$ 都设为 $s_i$，之后按照上述条件更新即可。如[某题解](https://www.luogu.com.cn/article/lho88oho)所说，用小的约束大的。

确定了 $l_i$ 和 $r_i$，就可以只管当前第 $i$ 段路了。有两种情况：

Ⅰ. 小明从 $l_i$ 加速至限速，贴着限速，再减速至 $r_i$。大致判断条件为：从 $l_i$ 加速到限速的所需位移 $+$ 从限速减速到 $r_i$ 的所需位移 $\le w_i$。如果这样，那么按速度分显然有三段路，分别算出每段位移，再算时间，累加所得即为本路段最少时间。

Ⅱ. 小明从 $l_i$ 加速，到某一速度 $v$ 后被迫减速至 $r_i$。判断条件与上面相反。如果是这种情况，则计算那个“某一速度 $v$”，然后分两段求就可以了。

最后把每段路的时间加起来，输出即可。~~代码自己想~~

---

## 作者：jiangyixuan_eason (赞：1)

我们想要找到时间的最小值。首先分析：路程相同，速度和时间成反比例，所以要使速度更大，且速度改变得越快一定就是越优的，每次加速或减速时加速度或减速度都要最大。

分类讨论。

第一个情况：我们可以加速到最大速度然后减速，即加速路程加减速路程小于总路程，那么有一个条件，满足这个条件我们就可以输出答案。所以：

$$S=\frac{\mathrm{(V_0+V)(V-V_0)}}{\mathrm{2A_i}}$$


第二个情况：不满足第一种，就无法加速到最快速度，我们就要求出能达到的最大速度，加速的路程就是：

$$\sqrt{\frac{\mathrm{(2A_i \times S_i + V_{0}^{2} + V_{1}^{2}}}{\mathrm{2}}}$$

该算的都算出来了，自己写代码吧。

---

## 作者：__Green_tick__ (赞：0)

## 题目分析
首先，肯定是数学题。

本题的要求是找到时间的最小值。

路程相同，速度越大，时间越短，所以我们要使速度尽可能大。

并且速度改变越快肯定是越优的，所以**每次加速或减速时加速度都应该保持在最大。**

## 解题思路
确定了 $l_i$ 和 $r_i$，就可以只管当前第 $i$ 段路了。有两种情况：

+ 小明从 $l_i$ 加速至限速，贴着限速，再减速至 $r_i$。\
  大致判断条件为：
  > 从 $l_i$ 加速到限速的所需位移 $+$ 从限速减速到 $r_i$ 的所需位移 $≤w_i$。

+ 小明从 $l_i$ 加速，到某一速度 $v$ 后被迫减速至 $r_i$，判断条件与上面相反。如果是这种情况，则计算 $v$。

## 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
/*Optimization series
#pragma GCC/G++ optimize(1)
#pragma GCC/G++ optimize(2)
#pragma GCC/G++ optimize(3,"Ofast","inline")
*/
struct road{
	long double s,a,v;
}arr[105];
long long t,n;
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		for(long long i=0;i<n;i++){
			scanf("%Lf%Lf%Lf",&arr[i].s,&arr[i].v,&arr[i].a);
		}
		long double ans=0.0,pre=0.0;
		for(long long i=n-2;i>0;i--){
			arr[i].v=min(arr[i].v,sqrt((2.0*arr[i].a*arr[i].s+arr[i+1].v*arr[i+1].v)));
		}
		arr[n].v=arr[n-1].v;
		for(long long i=0;i<n;i++){
			road add,minus;
			arr[i].v=min(sqrt(pre*pre+2.0*arr[i].a*arr[i].s),arr[i].v);
			long double next=min(arr[i].v,arr[i+1].v);
			add.v=arr[i].v-pre,add.s=(arr[i].v+pre)*5.0/10.0*add.v/arr[i].a;
			minus.v=arr[i].v-next,minus.s=(arr[i].v+next)*5.0/10.0*minus.v/arr[i].a;
			if(arr[i].s>=add.s+minus.s){
				ans+=add.v/arr[i].a+minus.v/arr[i].a+(arr[i].s-add.s-minus.s)/arr[i].v;
				pre=min(arr[i].v,arr[i+1].v);
			}else{
				long double v;
				v=sqrt((2.0*arr[i].a*arr[i].s+pre*pre+next*next)*5.0/10.0);
				ans+=(v-pre)/arr[i].a+(v-next)/arr[i].a;
				pre=min(v,arr[i+1].v);
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Chenxuhang_play (赞：0)

## 题目链接

<https://www.luogu.com.cn/problem/P5413>

## 题目大意

小明需要骑着单车经过 $n$ 段路，第 $i$ 段路的长度为 $w_i\operatorname{m}$，限速为 $s_i\operatorname{m/s}$（骑行的速度不能超过限速），加速度值（可以加速也可以减速）最大为 $a_i\operatorname{m/s}^2$。初始速度 $v_0=0\operatorname{m/s}$，计算小明通过这 $n$ 段路的最短时间。
 
## 易错点&提示

**注:高中生可直接跳过。**

~~尼玛的为了写题解还特地学了一下加速度~~

### 加速度是什么

非常重要的就是加速度。

建议首先观看[【高中物理必修（一）1.4 加速度】](https://www.bilibili.com/video/BV1sw4m1R7cz/?share_source=copy_web&vd_source=fa3b320744b0ed65f4495c5e4322ca89)。

好了总结一下：

+ 加速度是描述速度变化快慢的物理量（米/每秒）。

+ 加速度的物理含义是描述速度变化的快慢。

+ 加速度等于速度的变化除以相应的变化时间。

（总结部分摘自百度）

（如果有需要深入了解同样上百度）

### 加速度公式

~~众所周知，~~ 加速度公式为

$$
a=\displaystyle\frac{v-v_0}{t-t_0}
$$

## 思路

对于一段路的速度峰值 $V$ 实则是受到以下四个因素影响的：

1. 本段路限速

这是显而易见的，毕竟你开的再快也不能超速。

2. 下一段路的限速

同样，为了你能够符合要求的进入下一段路，离开时我们应把速度调整至合法的状态，峰值太高离开时很可能在下一段路超速。

3. 初始速度与加速度

你速度的峰值取决于你的能力上限，就是说有可能你就算整条路都在加速你的峰值也很低。

4.
+ 下下段路限速

你由本段路进入下段路时符合当前限速，但是下段路就算一直减速也无法减到下下一段路的限速之内。因此我们还要考虑下下段路的峰值。

…………

+ 所以得到，你需要从后往前推。

---

在不要违反上面的情况下，尽量贴着限速跑就行了。

---

## 作者：floodfill (赞：0)

# P5413 [YNOI2019] 骑单车 题解
这道题需要用到一点点**物理知识**。
### 题目大意
小明需要骑着单车经过 $n$ 段路，第 $i$ 段路的长度为 $w_i \operatorname{m} $，限速为 $s_i\operatorname{m/s}$（骑行的速度不能超过限速），加速度值最大为 $|a_i|\operatorname{m/s}^2$（可以加速也可以减速）。初始速度 $v_0=0\operatorname{m/s}$，计算小明通过这 $n$ 段路的最短时间。
### 准备知识

学过高中物理知识的可以直接跳过本部分。

**加速度**

~~众所周知~~，加速度的计算公式为
$$a=\frac{\Delta v}{\Delta t}=\frac{v-v_0}{t-t_0}$$
即速度的变化量除以时间的变化量。

**相关运动学公式**

1.匀变速直线运动在 $t$ 时刻的速度
$$v_t=v_0+at$$

2.将上面所讲的加速度计算公式移项，易得变化时间
$$\Delta t=\frac{\Delta v}{a}$$

3.匀变速直线运动的位移
$$x=v_0t+\frac{at^2}{2}=\frac{v_t^2-v_0^2}{2a}$$

~~想看证明？自己动手丰衣足食~~

### 大致思路
想让通过时间最短，自然而然地就想到要让加速度尽可能地大。加速度越大，所用时间越短，所以每次加/减速都要用最大加速度。

分类讨论：
-  我们可以加速到 $v_{max}$ 然后减速，即 $x_{加速}+x_{减速}<x_总$，即
  $$x=\frac{(v_0+v)(v-v_0)}{2a_i}$$
- 无法加速到最大速度时,就要求出能达到的最大速度。易得
  $$v=\sqrt{\frac{2a_is_i+v_0^2+v_1^2}{2}}$$
$v_1$是离开速度限速。

---

## 作者：U•ェ•*U (赞：0)

吐槽：为什么不更新 Markdown 和 $\LaTeX$。。。


## 思路
有点意思的题目，如果没给你标签你还可能以为是蓝题，但其实不难。

> 你的任务是计算小明通过这 $n$ 段路的最短时间。

我们都知道，路程相同，速度越快，时间越短，因此我们要使速度**尽可能大**，所以每次调速时加速度都应最大（加速度的绝对值最大值为 $a_i(m/s^2)$）。

---

先来简单提一嘴运动学公式：

* 平均速度公式：$v = \frac {\Delta x}{\Delta t}$，表示物体在一段时间内的位移与时间的比值。
* 加速度公式：$a=\frac {\Delta v}{\Delta t}$，表示物体在一段时间内的速度变化量与时间的比值。
* 匀变速直线运动公式：$v = v _ 0 + at$，$x=v_0t + \frac{1}{2} \times{at}^2$，$v ^ 2 = {v _ 0} ^ 2 + 2ax$，表示物体在匀变速直线运动时的速度、位移和时间的关系。
* 中间时刻速度公式：$v = \frac {(v _ 0 + v)}{2}$，表示物体在两个时刻之间的平均速度。
* 中间位置速度公式：$v = \sqrt {\frac {({v _ 0} ^ 2 + v ^ 2)}{2} }$，表示物体在两个位置之间的平均速度。

相信大家已经入~~土~~门了运动学公式（不懂请前往 [运动学公式详解](https://www.luogu.com/article/uf0mmeyh) 重新入土）。

---

于是我们具体情况具体分析，有：

* 小明先加速到了最大速度，一段时间后减速到下一个速度。
* 不能加速到最大速度


先来看第一种情况，不难得出公式：

$$
S = (v_i + V)\times (V - v_i) / 2a_i
$$

根据动力学公式 ${V_i} ^ 2 - {V_{i + 1}} ^ 2 = 2\times ax$ 得第二种情况的公式：

$$
V = \sqrt{(2.0 \times s_ia_i + {V_0} ^ 2 + {v_1} ^ 2) / 2}             
$$

## 程序实现

建议使用 `long double` 而不是 `double`。

如果用 `printf` 请记得设定精度哦！

```cpp
请自行实现~
```

---


# [JLOI2011] 小A的烦恼

## 题目描述

小$A$是$B$公司的一名$PM(product market)$。$B$公司越来越注重产品使用情况分析，而小$A$的工作就是整天对着一堆数据分析来分析去，没完没了。其中有一个操作是小$A$很头疼的，就是要把多个$csv$文件的数据拷到同一个$excel$文件中去。
有一天小$A$满怀期待地找到了你，一个高级程序员，她想让你写程序帮她完成这个简单重复性工作。这不是坑爹吗，直接操作$excel$还要用到第三方的库，还不如直接写到$csv$文件中，让她再手动去转成$excel$文件。经过内部沟通协调，最终定下了这个方案。
$csv$是一种$excel$可支持和格式，且存储方式非常简单。它实际上就是用“`,`”来分隔相邻的两个列。比如以下三行数据：  
```
a,a,a
b,,b
,c,c
```
表示的就是：  

| a | a | a |
| ---------- | :----------: | :----------: |
| b |   | b |
|   | c | c |

现在小$A$想做的就是把各个文件按照从左往右的顺序拷到同一个文件当中。比如文件$a$的数据是：  
```
a1,b1,c1
a2,b2
```
文件$b$的数据是：  
```
a1,b1,c1,d1
a2,b2
a3,b3,c3
a4
```
那么她所希望的最终结果是：  

| a |  |  | b |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| a1 | b1 | c1 | a1 | b1 | c1 | d1 |
| a2 | b2 |  | a2 | b2 |  |  |
|  |  |  | a3 | b3 | c3 |  |
|  |  |  | a4 |  |  |  |

这个结果在$csv$文件里就是：  
```
a,,,b,,,
a1,b1,c1,a1,b1,c1,d1
a2,b2,,a2,b2,,
,,,a3,b3,c3,
,,,a4,,,
```
以上结果的第一行是每一个文件的文件名，文件名与相应文件的第一列对齐。如果相应文件不止一列，那么其它列用空的单元格来补充。  
输入的$csv$文件里保证了每一行的末尾都没有“`,`”，也就是说像$a$文件的第$2$行的第$3$列一样，如那一格是空的，那么在$b2$后面是没有“`,`”的。  
输出的$csv$文件里因为是程序的输出结果，为了简化程序，如果末尾是空的，那么还是会显式输出“`,`”，如以上的结果所示。  
输入文件保证至少有一行一列非空。  
输出的文件要保证下一个文件的第一列要紧邻着上一文件的最后一个非空列的右面。最后一个文件只输出到最后一个非空列。   

## 样例 #1

### 输入

```
2
2 a
a1,b1,c1
a2,b2
4 b
a1,b1,c1,d1
a2,b2
a3,b3,c3
a4```

### 输出

```
a,,,b,,,
a1,b1,c1,a1,b1,c1,d1
a2,b2,,a2,b2,,
,,,a3,b3,c3,
,,,a4,,,```

# 题解

## 作者：lzqy_ (赞：7)

**提供一个简单的方法，大括号换行代码 $29$ 行**

这道题没有什么难度，就是纯模拟，结合代码来分析就好了

### 变量名

先来解释一下接下来代码的变量名：

```
int N;//总行数
int hlen,llen;
//hlen:每一行的长度(总列数)   llen:每一列的长度(总行数)
int Max,cnt,n;//临时变量
string ans[1001][1001];
//ans[i][j]:最后输出的表格中,(i,j)位置上的字符串(如果没有就为空)
string s;//临时变量
```

### 大致思路

把最后输出的东西看做一个 $\text{llen}\times \text{hlen}$ 的矩阵，用数组存下，并把逗号看做平常输出矩阵的空格，这样一来，逗号、行数等很多的细节就没有了。

### 代码

在代码里有非常详细的注释~

```cpp
#include<bits/stdc++.h>
using namespace std;
int N,n,hlen,llen,Max,cnt;
string ans[1001][1001],s;
//上文已经介绍
int main()
{
	cin>>N;
	for(int i=1;i<=N;i++)
	{
		cin>>n>>ans[1][++hlen];
		//新的文件要往右边排
		//因此这个文件的文件名位于(1,hlen+1)位置(顺便更新hlen)
		llen=max(llen,n+1),Max=0;
		//这一个文件一定有n+1行(算上文件名那一行),刷新llen
		for(int j=1;j<=n;j++)
		{
			cin>>s,cnt=0;
			//依次读入第j+1行第cnt个子文件
			for(int u=0;u<s.length();u++,cnt++)
				while(s[u]!=','&&u<s.length())	
					ans[j+1][hlen+cnt]+=s[u++];
			Max=max(Max,cnt-1);
			//这里的Max代表目前文件每一行子文件个数的最大值
			//也就是说，目前的文件会使列数多出几列
		}
		hlen+=Max;//累加列数
	}
	//最后输出整个llem×hlen的矩阵就好了
	for(int i=1;i<=llen;i++)
		for(int j=1;j<hlen;j++)
			if(j!=hlen)
				cout<<ans[i][j]<<',';
			else 
				cout<<ans[i][hlen]<<endl;
	return 0;
}
```

**祝大家 $\text{AC}$ 愉快！**

---

## 作者：A_grasser (赞：4)

## 更新

修改了代码有误的地方。

## 题意简化

给定若干个表格，依照题目给定格式输出。

## 需要注意的地方

1. 输出最后切勿有换行。
2. 相邻两个表格间应加上的是英文逗号。
3. 题目细节多，要仔细审题。

## 解法分析

按题意模拟即可。

首先定义好要用的变量。

```cpp
int n,m;//题目中的意思：n个表格，分别有m行 
int start_lie=1//目前从第start_lie列开始操作*/;
int tmp;//临时存储1（下面会讲其作用） 
string tmp2;//临时存储2（下面会讲其作用） 
int max_lie//最大列数
int max_hang;//最大行数
string title/*标题*/,in/*表格的每一行输入*/;
string ans[105][105*105];//答案（行数：最大n；列数：最大m×输入最大列数） 
```

接着处理读入。

思路：将其转换成题目中的表格形式，存储在 $ans$ 里。

但它每行输入的是一行字符串，怎么办？简单，把里面的英文逗号看作分隔符，就可以把每个格子的内容剥离出来。记住最后记得把临时存储再存储一遍（因为最后没有分隔符）。

题目很会挖坑，它输入的每行格子数没告诉你，要统计出来。

提醒一下，二维数组下标中的一个参数是行，第二个参数才是列，与普通数对有区别。

```cpp
cin>>n;
for(int i=1;i<=n;i++){
	cin>>m>>title;//title：每个表格标题
	ans[0][start_lie]=title;//存下标题，存在第0行第开始操作列 
	max_lie=0//该表格最大列数初始化;
	if(m>max_hang) max_hang=m;
	for(int j=1;j<=m;j++){
		cin>>in;//获得每行内容
		tmp2="";//临时存储每一个格子的内容（初始化）
		tmp=0/*格子数（初始化）*/;
		for(int k=0;k<in.size();k++){//剥离每个格子
			if(in[k]==','){//到逗号就把记录的格子内容保存下来
				tmp++;
				ans[j][start_lie+tmp-1]=tmp2;
				tmp2="";
			}
			else{
				tmp2+=in[k];
			}
		}
		tmp++;
		ans[j][start_lie+tmp-1]=tmp2;
		tmp2="";
		if(tmp>max_lie) max_lie=tmp;//更新最大列数
	}
	start_lie+=max_lie;//更新开始操作的列
}
```
其实还有一种不用上述特判的方法，在每行末尾加上英文逗号，也就是补上分隔符。

可以这样写：

```cpp
cin>>in;
in+=',';
```
这样就不用特判了。

最后输出。

思路：把 $ans$ 数组打出来一遍就行，但注意格式，上面讲了，看需要注意的地方这部分。

```cpp
for(int i=0;i<=max_hang;i++){//注意：标题存在第零行
	for(int j=1;j<=start_lie-1;j++){
		cout<<ans[i][j];
		if(j!=start_lie-1)cout<<",";//特判2：行末没有逗号
	}
	if(i!=max_hang)cout<<endl;//特判3：输出最后没换行
}
```

最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
int n,m;//题目中的意思：n个表格，分别有m行 
int start_lie=1//目前从第start_lie列开始操作*/;
int tmp;//临时存储1（下面会讲其作用） 
string tmp2;//临时存储2（下面会讲其作用） 
int max_lie//最大列数
int max_hang;//最大行数
string title/*标题*/,in/*表格的每一行输入*/;
string ans[105][105*105];//答案（行数：最大n；列数：最大m×输入最大列数） 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>m>>title;//title：每个表格标题
		ans[0][start_lie]=title;//存下标题，存在第0行第开始操作列 
		max_lie=0//该表格最大列数初始化;
		if(m>max_hang) max_hang=m;
		for(int j=1;j<=m;j++){
			cin>>in;//获得每行内容
			tmp2="";//临时存储每一个格子的内容（初始化）
			tmp=0/*格子数（初始化）*/;
			for(int k=0;k<in.size();k++){//剥离每个格子
				if(in[k]==','){//到逗号就把记录的格子内容保存下来
					tmp++;
					ans[j][start_lie+tmp-1]=tmp2;
					tmp2="";
				}
				else{
					tmp2+=in[k];
				}
			}
			tmp++;
			ans[j][start_lie+tmp-1]=tmp2;
			tmp2="";
			if(tmp>max_lie) max_lie=tmp;//更新最大列数
		}
		start_lie+=max_lie;//更新开始操作的列
	}
	for(int i=0;i<=max_hang;i++){//注意：标题存在第零行
		for(int j=1;j<=start_lie-1;j++){
			cout<<ans[i][j];
			if(j!=start_lie-1)cout<<",";//特判1：行末没有逗号
		}
		if(i!=max_hang)cout<<endl;//特判2：输出最后没换行
	}
	return 0;
}
```

---

## 作者：淋汐XIK (赞：4)

### ~~这是一道很难受的模拟~~

###### 语文不好

###### 题意都理解了很久

### [题目传送门](https://www.luogu.org/problem/P5483)
------------

###### 这是一篇~~很正经~~的题解~~~

------------


###### 进入正题

### 感觉容易忽略的地方

- 每一行的逗号要注意一下，，这道题在这个方面上是真的坑
- 最后一个文件最后没有多余的逗号，（（多余指的是两个文件相连时补充的逗号
- 如果某个文件某一行没内容，但是又要输出那一行，那么就用逗号补充

## ~~总的来说就是逗号有坑~~

### 大概讲解一下本蒟蒻的变量名


int变量

maxn 		所有文件中最大排数（（要输出的排数

num[i][j]	第i个文件第j行逗号的数量 

n[i]		每个文件的排数

max_num[i]	每个模块，对于所有排，逗号的最大个数 

------------

char变量

nam[i][]	第i个文件的文件名 

h[i][j][]	存字符串，第i个模块的第j行 


------------


------------
###### 然后咱可以开始模拟了！！

### 先读入
```
for(int i=1;i<=T;i++){
    scanf("%d",&n[i]);
    maxn=max(n[i],maxn);
    //对于所有的文件，要输出的排数就是所有文件里最大的排数
    scanf("%s",nam[i]+1);
    for(int j=1;j<=n[i];j++){
        scanf("%s",th[i][j]+1);
        int len=strlen(th[i][j]+1);
        //因为每个字符串的长度只用一次，可以不用存下来，直接覆盖就好
        for(int k=1;k<=len;k++){
            if(th[i][j][k]==',') num[i][j]++;
            //统计每一个文件的每一排有多少个逗号
        }
        max_num[i]=max(max_num[i],num[i][j]);
        //统计每一个文件，对于所有排，最大的逗号数
        //当文件名或某一行后面需要补充逗号时，根据max_num[i]来补充
    }
}
```

### 然后输出

###### //为了方便输出，也可以先进行处理

###### //但本蒟蒻觉得麻烦

###### //就边输出边处理~~~

- 先输出每个文件的文件名

```
for(int i=1;i<=T;i++){
    printf("%s",nam[i]+1);
    for(int k=1;k<=max_num[i];k++) printf(",");
    //补充逗号
    //只要文件不是一列，那么就需要补充逗号
    //若文件为一列，max_num[i]=0
    //补充逗号的数量由max_num[i]（（最大逗号数））来决定
    if(i!=T) printf(",");
    //若该文件不是最后一个文件，那么需要输出逗号隔开
}
```
- 文件名完了之后就是文件内容了

```
for(int j=1;j<=maxn;j++){//每一排输出了之后，再输出下一排
    for(int i=1;i<=T;i++){
        if(n[i]<j) for(int k=1;k<=max_num[i];k++) printf(",");
        //某个文件的排数小于正在输出的排数
        //那么这个文件从这一排开始，下面都没有内容
        //如果某个文件这一排没有内容，补充逗号
        else{
            printf("%s",th[i][j]+1);
            //若有内容，输出字符串
            if(num[i][j]<max_num[i]){
                int x=max_num[i]-num[i][j];
                for(int k=1;k<=x;k++) printf(",");
            }
            //若某个文件的这一排的长度<该文件所有排中最大长度
            //输出逗号来补充
        }
        if(i!=T) printf(",");
        //若该文件不是最后一个文件，那么需要输出逗号隔开
    }
    printf("\n");
}
```

最后附上AC代码~~~
```
#include<bits/stdc++.h>
using namespace std;

int T;
int maxn;//maxn所有模块中最大排数
int num[107][107];//num[i][j]第i个模块第j行逗号的数量 
int n[107];//n[i]每个模块的排数
char nam[107][107];//nam[i][]第i个模块的文件名 
char th[107][107][107];//th[i][j][]存字符串，第i个模块的第j行 
int max_num[107];//max_num[i]每个模块逗号的个数 
//i 模块
//j 排数 

int main(){
    scanf("%d",&T);
    for(int i=1;i<=T;i++){
        scanf("%d",&n[i]);
        maxn=max(n[i],maxn);
        scanf("%s",nam[i]+1);
        for(int j=1;j<=n[i];j++){
            scanf("%s",th[i][j]+1);
            int len=strlen(th[i][j]+1);
            for(int k=1;k<=len;k++) if(th[i][j][k]==',') num[i][j]++;
            max_num[i]=max(max_num[i],num[i][j]);
        }
    }
	
    for(int i=1;i<=T;i++){
        printf("%s",nam[i]+1);
        for(int k=1;k<=max_num[i];k++) printf(",");
        if(i!=T) printf(",");
    }
    //输出文件名 
	
    printf("\n");
	
    for(int j=1;j<=maxn;j++){
        for(int i=1;i<=T;i++){
            if(n[i]<j) for(int k=1;k<=max_num[i];k++) printf(",");
            else{
                printf("%s",th[i][j]+1);
                if(num[i][j]<max_num[i]){
                    int x=max_num[i]-num[i][j];
                    for(int k=1;k<=x;k++) printf(",");
                }
            }
            if(i!=T) printf(",");
        }
        printf("\n");
    }
    return 0;
} 
```


第一次写题解啊啊啊

一定要过啊啊

---

## 作者：andyli (赞：4)

本题可以先通过输入数据计算出一些东西：  
- maxrow 所有文件中最大的行数  
- maxcolumn\[1~n\] 每个文件中最大的列数（列数即逗号数+1）  
- cnt\[1~n\]\[1~n\] 每个文件中每一行的列数  

计算完毕后便在每个文件中的每一行末尾补逗号，并在每个文件中补全是逗号的行，最后逐行逐列输出。  
代码如下：  
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 105;
// 所有csv文件，files[i][j]表示第i个文件的第j行
string files[maxn][maxn];
// csv文件名
string filename[maxn];
// row[i]为第i个文件的行数
// maxrow为所有文件中最大的行数（即max(row)）
// cnt[i][j]表示第i个文件中第j行的列数（如a1,b1,c1的列数为3），即这一行逗号的总数+1
// maxcolumn[i]即为max(cnt[i])
int row[maxn], maxrow, maxcolumn[maxn], cnt[maxn][maxn];

// 统计字符串str中逗号的个数
int Count(const string& str)
{
    int cnt = 0;
    for (const auto& x : str)
        if (x == ',')
            cnt++;
    return cnt;
}
int main()
{
    // cin,cout优化
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    // 读入数据并计算maxrow, maxcolumn以及cnt
    for (int i = 1; i <= n; i++) {
        cin >> row[i] >> filename[i];
        maxrow = max(maxrow, row[i]);
        for (int j = 1; j <= row[i]; j++)
            cin >> files[i][j],
                maxcolumn[i] =
                    max(maxcolumn[i], cnt[i][j] = Count(files[i][j]) + 1);
    }
    // 每一行列数若不足maxcolumn[i]，则补逗号
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= row[i]; j++) {
            int x = maxcolumn[i] - cnt[i][j] + 1;
            while (x--)
                files[i][j].push_back(',');
        }
    // 第n个文件特殊处理
    for (int i = 1; i <= row[n]; i++) {
        int x = maxcolumn[n] - cnt[n][i];
        while (x--)
            files[n][i].push_back(',');
    }
    // 行数若不足maxrow，则补充逗号
    for (int i = 1; i < n; i++)
        for (int j = row[i] + 1; j <= maxrow; j++)
            files[i][j] = string(maxcolumn[i], ','); // string(int x, char ch) 构造函数，返回x个ch的副本（即若x=5,ch='x',构造函数返回"xxxxx"）
    // 第n个文件特殊处理
    for (int i = row[n] + 1; i <= maxrow; i++)
        files[n][i] = string(maxcolumn[n] - 1, ',');
    for (int i = 1; i < n; i++)
        filename[i] += string(maxcolumn[i], ',');
     // 第n个文件特殊处理
    filename[n] += string(maxcolumn[n] - 1, ',');
    for (int i = 1; i <= n; i++)
        cout << filename[i];
    cout << endl;
    // 注意输出顺序
    for (int i = 1; i <= maxrow; i++) {
        for (int j = 1; j <= n; j++)
            cout << files[j][i];
        cout << endl;
    }
    return 0;
}
```

---

## 作者：Exber (赞：2)

## 做法
这道题除了题面有点长以外还是十分简单的。

由于逗号十分的烦人，所以我们可以不存它。开一个 ```string``` 类型的二位数组来存表格中每一个位置的值，再存一下表格的宽高，输入的时候动态更新一下宽高，那么最后输出就很好处理了。

需要注意的是，最终表格的大小最大是到 ```100*10000``` 的，而不是 ```100*100```。

## AC 代码
```cpp
#include <iostream>

using namespace std;

int n,hei,wid;
string ans[105][10005]; // 注意一下数组大小 

int main()
{
	ios::sync_with_stdio(false); // 加快 cin 和 cout 的速度 
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int m;
		cin>>m;
		m++; // 其实文件名也是一行
		hei=max(hei,m); // 更新答案表格高度 
		int maxwid=0;   // 当前表格的宽度 
		for(int j=1;j<=m;j++)
		{
			string s;
			cin>>s;
			int ls=s.length(),cnt=1; // cnt 是存到读到第几个格子了 
			for(int k=0;k<ls;k++)
			{
				if(s[k]==',') // 遇到逗号了 
				{
					cnt++; // 下一个格子 
					continue;
				}
				ans[j][wid+cnt]+=s[k]; // 把内容更新到答案表格里面 
			}
			maxwid=max(maxwid,cnt); // 更新当前表格宽度 
		}
		wid+=maxwid; // 更新答案表格宽度 
	}
	for(int i=1;i<=hei;i++)
	{
		for(int j=1;j<wid;j++)
		{
			cout<<ans[i][j]<<","; 
		}
		cout<<ans[i][wid]<<endl; // 最后一个格子不用在后面输出逗号 
	}
	return 0;
}
```


---

## 作者：hanker_AFO (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P5483)

#### 算法:暴力模拟

首先我们手动模拟一下,发现我们就是把原来的数据补齐成长方形表格即可

样例解释如下:

```cpp
a1,b1,c1
a2,b2                                             

a1,b1,c1,d1
a2,b2
a3,b3,c3
a4

a ,  ,  ,b ,  ,  ,
a1,b1,c1,a1,b1,c1,d1
a2,b2,  ,a2,b2,  , 
  ,  ,  ,a3,b3,c3,
  ,  ,  ,a4,  ,  , 
  
```

然后我们开始模拟题意

对于每个读入的表格,统计最大的行元素数,然后在其他行末用逗号补齐

然后考虑把表格和答案逐行合并

如果答案表格的该行不为空,则直接加到末尾

否则添加与其他行逗号数量一样的逗号,然后加到末尾

输出时不要忘记标题

同时末尾多余逗号删去

代码如下:


```cpp
#include <bits/stdc++.h>
using namespace std;

int read(){
	int x=0,flag=1; char c;
	for(c=getchar();!isdigit(c);c=getchar()) if(c=='-') flag=-1;
	for(;isdigit(c);c=getchar()) x=((x+(x<<2))<<1)+(c^48);
	return x*flag;
}

const int N=205;
int n,mh,now;//行数最大值,  补齐要用的逗号数 
int h[N],l[N];//每张表格补齐后的行,列值 
char name[N][N];//表格名 
char ans[N][N*N],tmp[N][N];//答案  读入表格 
int len[N];//答案每行字符串长度 

int main() {
    scanf("%d",&n);
    for(int T=1;T<=n;T++){
	    scanf("%d %s",&h[T],name[T]);
	    for(int i=1;i<=h[T];i++) scanf(" %s",tmp[i]);//读入 
	    
	    for(int i=1;i<=h[T];i++){ 
		    int sum=0; 
		
			for(int j=0,le=strlen(tmp[i]);j<le;j++) 
			if(tmp[i][j]==',') ++sum; 
		
			l[T]=max(l[T],sum); 
		}
	    l[T]++;//统计行最多逗号数,即元素数 
		
		if(h[T]<=mh){//是否需要扩充答案表格 
		    for(int i=1;i<=h[T];i++){
		    	int sum=l[T];
			    for(int j=0,le=strlen(tmp[i]);j<le;j++){
				    ans[i][len[i]++]=tmp[i][j];//末尾添加 
				    if(tmp[i][j]==',') --sum;
				}
				while(sum) { ans[i][len[i]++]=','; --sum; }//补逗号 
			}
			for(int i=h[T]+1;i<=mh;i++){
			    int sum=l[T];
			    while(sum) { ans[i][len[i]++]=','; --sum; }//若该表行数小于答案表行数,直接补逗号 
			}
		}
		else{
		    for(int i=1;i<=h[T];i++){
			    if(len[i]==0){//答案表新添一行 
				    int sum=now;
				    while(sum) { ans[i][len[i]++]=','; --sum; }//补齐之前逗号 
				}
				int sum=l[T];
			    for(int j=0,le=strlen(tmp[i]);j<le;j++){
				    ans[i][len[i]++]=tmp[i][j];//末尾添加 
				    if(tmp[i][j]==',') --sum;
				}
				while(sum) { ans[i][len[i]++]=','; --sum; }//补逗号 
			}
		}
		mh=max(mh,h[T]);//更新最大行数 
		for(int i=0,le=strlen(name[T]);i<le;i++){
		    ans[0][len[0]++]=name[T][i];//标题 
		}
		for(int i=1;i<=l[T];i++) ans[0][len[0]++]=',';
	    now+=l[T];//更新之前逗号数 
	}
	
	for(int i=0;i<=mh;i++){
	    for(int j=0,le=strlen(ans[i])-1;j<le;j++) printf("%c",ans[i][j]);//输出, 不要最后位 
	    puts("");
	}
	return 0;
}



```

---

## 作者：Genius_Star (赞：1)

### 思路：
我们可以灵活运用 ``C++`` 的语法来解决此题。

解释一下代码中会出现的语法：

1. ``string::iterator it`` 表示定义了一个 ``string`` 类型的迭代器 ``it``，``∗it`` 表示当前字符串的第 ``it`` 个元素。

2. ``∗max_element(tot+1,tot+m+1)`` 这个函数返回的是一个长的为 ``m`` 的数组 ``tot`` 中元素的最大值。

然后就是一些基本的模拟了。
### 完整代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cctype>//头文件准备
#define itn int
#define gI gi

using namespace std;

inline int gi()
{
    int f = 1, x = 0; char c = getchar();
    while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar();}
    while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar();}
    return f * x;
}//快速读入

int n, m, tot[1005]/*每个文件中最大的列数*/, cnt, sum/*最大的行数*/;
string s, ans[1005]/*每一行的答案*/, tr;

int main()
{
    n = gi();
    for (itn i = 1; i <= n; i+=1)
    {
        m = gi(), cin >> s;
        memset(tot, 0, sizeof(tot));//记得清空数组
        ans[0] = ans[0] + s/*加上表头*/, sum = max(sum, m)/*计算最大的行数*/;
        for (int j = 1; j <= m; j+=1)
        {
            cin >> tr;//输入每行的元素
            ans[j] = ans[j] + tr;//先加入答案
            for (string :: iterator it = tr.begin(); it != tr.end(); it+=1)//遍历第j行
            {
                tot[j] = tot[j] + (*it == ',');//计算','分隔符个数
            }
        }
        cnt = *max_element(tot + 1,tot + m + 1);//得出最多的','分隔符数量
        for (int j = 0; j < 1005; j+=1)//枚举行。因为我们不知道最终答案的行数,因此就要枚举到最大的行数
        {
            for (int k = tot[j]; k <= ((i == n) ? (cnt - 1) : (cnt)); k+=1)//为答案增加','分隔符,注意判断i==n的情况,此时就要少加上一个','
            {
                ans[j] = ans[j] + ',';//加上','分隔符
            }
        }
    }
    for (int i = 0; i <= sum; i+=1)
    {
        cout << ans[i] << endl;//输出答案
    }
    return 0;
}
```


---


# [CQOI2005] 新年好

## 题目描述

重庆城里有 $n$ 个车站，$m$ 条双向公路连接其中的某些车站。每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。在一条路径上花费的时间等于路径上所有公路需要的时间之和。

佳佳的家在车站 $1$，他有五个亲戚，分别住在车站 $a,b,c,d,e$。过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。怎样走，才需要最少的时间？

## 说明/提示

对于 $40\%$ 的数据，有 $1≤n≤500$，$1≤m≤2000$。

对于 $100\%$ 的数据，有 $1≤n≤50000$，$1≤m≤100000$，$1\le a,b,c,d,e≤n$，$1≤x,y≤n$，$1≤t≤10000$。

## 样例 #1

### 输入

```
6 6
2 3 4 5 6
1 2 8
2 3 3
3 4 4
4 5 5
5 6 2
1 6 7```

### 输出

```
21
```

# 题解

## 作者：zhangyuhan (赞：17)

让我来仔细梳理一下题目大意，以便大家更好的编写代码。

简化一下题意，就是佳佳要依次拜访五个亲戚，给出一张图及所有人的位置，求最短距离。

首先看，$n\leq50000$，说明搜索在这题是行不通的。

要我们求最短距离，那就来考虑一下最短路。

由于她是依次不间断拜访，即到达一家后立即前往下一家，所以我们首先可以以这$6$个点为起点依次跑最短路，得到以这$6$个点为起点的最短路径。换句话说，我们知道了每两个地方间的最短距离。

接着需要定的，就是拜访顺序了。

由于只有六处，且出发点已经固定，我们就可以考虑枚举全排列，将所有的可能的拜访顺序求出，同时将每个顺序的时间求出，去所有中的最小值即可。

大体思路并不难想，也就是这样，下面让我来分析一下代码细节：

$1.$有五处亲戚。为了便于编写，我们可以不按题面输出，有一个一维数组来存储。同时，因为起点佳佳家在$1$号点，所以我们可以在这个数组的第$6$个位置存入佳佳家，这样有利于编写。

$2.$此题更新数据后卡`SPFA`，所以只能采用`堆优化dijkstra`。

$3.$由于需要求解六处的最短路径，所以存最短路径时用一般的一维数组是肯定不行的。所以我们考虑使用二维数组，其中第一维可以存储出发的亲戚家的编号，第二维跟平时定义一样。

$4.$由于求最小值，所以枚举全排列时可以剪枝：当前用时已经大于过去最小值时，就可以`return`。

总体就是这样。

最后分析一下时间复杂度：枚举全排列时间不大，主要在计算最短路上。采用`堆优化dijkstra`后，耗时为：$O(m\log n)$（常数忽略不计）

$AC$ $Code$
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#define _for(i, a, b) for (int i=(a); i<=(b); i++)
#define _rep(i, a, b) for (int i=(a); i<(b); i++)
using namespace std;

typedef pair<int, int> P;
const int MAXN = 50010, INF = 1e9;

struct edge {
	int to, cost;
};
std::vector<edge> G[MAXN];
void addedge(int u, int v, int c) {
	G[u].push_back((edge){v, c});
	G[v].push_back((edge){u, c});
}//建无向边操作

int n, m, rel[7], d[7][MAXN], ans = INF;//记得ans要赋INF，以及d数组要开二维
bool vis[7];

void dijkstra(int s) {
	priority_queue<P, vector<P>, greater<P> > q;
	d[s][rel[s]] = 0;
	q.push(P(0, rel[s]));
	while (!q.empty()) {
		P p = q.top();
		q.pop();
		int v = p.second;
		if (p.first > d[s][v]) continue;
		_rep (i, 0, G[v].size()) {
			edge e = G[v][i];
			if (d[s][e.to] > d[s][v]+e.cost) {
				d[s][e.to] = d[s][v]+e.cost;
				q.push(P(d[s][e.to], e.to));
			}
		}
	}
}//标准堆优化dijkstra

void dfs(int cur, int cost, int pos) {
	if (cost > ans) return ;
	if (cur == 5) {
		ans = min(ans, cost);
		return ;
	}
	_for (i, 1, 5) 
		if (!vis[i]) {
			vis[i] = true;
			dfs(cur+1, cost+d[pos][rel[i]], i);
			vis[i] = false;
		}
}//标准枚举全排列

int main() {
	cin >> n >> m;
	_for (i, 1, 5) cin >> rel[i];
	_for (i, 1, m) {
		int u, v, c;
		cin >> u >> v >> c;
		addedge(u, v, c);
	}//建图
	rel[6] = 1;
	memset(d, 0x3f, sizeof(d));//记得d数组要初始化
	_for (i, 1, 6) dijkstra(i);
	dfs(0, 0, 6);
	cout << ans << endl;
	return 0;//完结撒花
}
```


---

## 作者：Natsume_Rin (赞：8)

就是一道最短路的题目。(但是太久没写 $\text{Dijkstra}$,卡了我好久。)

其实只要找每个亲戚到其它点的距离便可，然后一个状态枚举暴力解决。


```cpp
#include<bits/stdc++.h>
#define itn int
using namespace std;
int n, m;
int to[200005], next[200005], bweight[200005];
int cnt, head[50005], a[7];
int dist[8][50005];
int x, y, t;
priority_queue<pair<int,int> > q;//优先队列。
bool pd[50005];
inline void Dijkstra(int x, int id){
	memset(pd,0,sizeof pd);
	q.push(make_pair(0,x));
	for(int i=1;i<=n;++i) dist[id][i]=2147483647;
	dist[id][x]=0;
	int doit;
	int to_;
	while(!q.empty()){
		doit=q.top().second;
		q.pop();
		if(pd[doit]) continue;
		pd[doit]=1;
		for(int i=head[doit];i;i=next[i]){
			to_=to[i];
			if(dist[id][to_]>dist[id][doit]+bweight[i]){
				dist[id][to_]=dist[id][doit]+bweight[i];
				q.push(make_pair(-dist[id][to_],to_));//更新和放入答案。
			}
		}
	}
}
bool judge[7];
long long fans=2147483647;
inline long long min(long long a, long long b){
	if(a>b) return b;
	return a;
}
inline void dfs(int k, int ans, int last_id){
	if(k==5){
		fans=min(ans,fans);
		return ;
	} 
	for(int i=1;i<=5;++i){
		if(judge[i]) continue;
		judge[i]=1;
		dfs(k+1,ans+dist[last_id+1][a[i]],i);
		judge[i]=0;//回溯
	}
}//枚举到亲戚家的顺序。
int main(){
	scanf("%d%d",&n,&m);//用scanf读入。
	for(int i=1;i<=5;++i)scanf("%d",&a[i]);//输入5个亲戚家的编号。
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&x,&y,&t);
		++cnt;
		to[cnt]=y;
		next[cnt]=head[x];
		head[x]=cnt;
		bweight[cnt]=t;//邻接链表
		++cnt;
		to[cnt]=x;
		next[cnt]=head[y];
		head[y]=cnt;
		bweight[cnt]=t;
	}
	Dijkstra(1,1);//Dijkstra算法。
	for(int i=1;i<=5;++i) Dijkstra(a[i],i+1);//找每一个亲戚到其它点的距离。
	dfs(0,0,0);//dfs枚举状态。
	/*for(int i=1;i<=6;++i){
		for(int j=1;j<=n;++j) cout<<dist[i][j]<<" ";
		cout<<endl;
	}*/
	printf("%lld",fans);//输出。
	return 0;
}
```

---

## 作者：Sham_Sleep (赞：7)

这道题很容易就看出来是一道最短路

但是与模板题不同的是，他需要到好几个终点，而且是固定死了只有5个。

如此来说，他如果用floyed算法，那么浪费的时间比较多，而且他的数据范围也说明了他只能用单源最短路。

那么如何处理同时经过几个点的最短路呢？

打下所有可能顺序的表就完事了（~~打表出省一~~）。

好吧我只是想省下时间。

然后就是将需要到达的点的单源最短路求出来就行了。

那么问题来了：该用什么样的算法呢？

```
关于spfa——他死了
```
那么贝尔福特算法呢？本人实测，只能拿80分，原因很简答：题目范围给出的是Nmax=50000,Mmax=100000.

那么按照贝尔福特算法来看的话，最坏情况需要50000 * 100000 > 1亿。我们的计算姬宝宝肯定遭受不住啊（计算姬：我经历了我这个年龄不该有的计算）

那么剩下的只有Dij+堆优化勉强能卡的过了

80分代码
```
#include <stdio.h>
#include <memory.h>
#include <iostream>
using namespace std;


int biao[120][7]={{1,2,3,4,5},{1,2,3,5,4},{1,2,4,3,5},{1,2,4,5,3},{1,2,5,3,4},{1,2,5,4,3},{1,3,2,4,5},{1,3,2,5,4},{1,3,4,2,5},{1,3,4,5,2},{1,3,5,2,4},{1,3,5,4,2},{1,4,2,3,5},{1,4,2,5,3},{1,4,3,2,5},{1,4,3,5,2},{1,4,5,2,3},{1,4,5,3,2},{1,5,2,3,4},{1,5,2,4,3},{1,5,3,2,4},{1,5,3,4,2},{1,5,4,2,3},{1,5,4,3,2},{2,1,3,4,5},{2,1,3,5,4},{2,1,4,3,5},{2,1,4,5,3},{2,1,5,3,4},{2,1,5,4,3},{2,3,1,4,5},{2,3,1,5,4},{2,3,4,1,5},{2,3,4,5,1},{2,3,5,1,4},{2,3,5,4,1},{2,4,1,3,5},{2,4,1,5,3},{2,4,3,1,5},{2,4,3,5,1},{2,4,5,1,3},{2,4,5,3,1},{2,5,1,3,4},{2,5,1,4,3},{2,5,3,1,4},{2,5,3,4,1},{2,5,4,1,3},{2,5,4,3,1},{3,1,2,4,5},{3,1,2,5,4},{3,1,4,2,5},{3,1,4,5,2},{3,1,5,2,4},{3,1,5,4,2},{3,2,1,4,5},{3,2,1,5,4},{3,2,4,1,5},{3,2,4,5,1},{3,2,5,1,4},{3,2,5,4,1},{3,4,1,2,5},{3,4,1,5,2},{3,4,2,1,5},{3,4,2,5,1},{3,4,5,1,2},{3,4,5,2,1},{3,5,1,2,4},{3,5,1,4,2},{3,5,2,1,4},{3,5,2,4,1},{3,5,4,1,2},{3,5,4,2,1},{4,1,2,3,5},{4,1,2,5,3},{4,1,3,2,5},{4,1,3,5,2},{4,1,5,2,3},{4,1,5,3,2},{4,2,1,3,5},{4,2,1,5,3},{4,2,3,1,5},{4,2,3,5,1},{4,2,5,1,3},{4,2,5,3,1},{4,3,1,2,5},{4,3,1,5,2},{4,3,2,1,5},{4,3,2,5,1},{4,3,5,1,2},{4,3,5,2,1},{4,5,1,2,3},{4,5,1,3,2},{4,5,2,1,3},{4,5,2,3,1},{4,5,3,1,2},{4,5,3,2,1},{5,1,2,3,4},{5,1,2,4,3},{5,1,3,2,4},{5,1,3,4,2},{5,1,4,2,3},{5,1,4,3,2},{5,2,1,3,4},{5,2,1,4,3},{5,2,3,1,4},{5,2,3,4,1},{5,2,4,1,3},{5,2,4,3,1},{5,3,1,2,4},{5,3,1,4,2},{5,3,2,1,4},{5,3,2,4,1},{5,3,4,1,2},{5,3,4,2,1},{5,4,1,2,3},{5,4,1,3,2},{5,4,2,1,3},{5,4,2,3,1},{5,4,3,1,2},{5,4,3,2,1}};
int f[7];
int ans=1000001;
int m,n;
int dis[7][50005];
int e[100005];
int s[100005];
int w[100005];


int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1; i<=5; ++i){
		scanf("%d",&f[i]);
	} 
	for(int i=1; i<=n; ++i){
		scanf("%d%d%d",&s[i],&e[i],&w[i]);
	}
	f[0]=1;
	memset(dis,0x3f,sizeof(dis));
	for(register int i=0; i<=5; ++i){
		dis[i][f[i]]=0;
		for(register int j=1; j<=m-1; ++j){
			int f=0;
			for(register int k=1; k<=n; ++k){
				if(dis[i][e[k]]>dis[i][s[k]]+w[k])
				{
					dis[i][e[k]]=dis[i][s[k]]+w[k];
					f=1;
				}
			}
			for(register int k=1; k<=n; ++k){
				if(dis[i][s[k]]>dis[i][e[k]]+w[k])
				{
					dis[i][s[k]]=dis[i][e[k]]+w[k];
					f=1;
				}
			}
			if(!f) break;
		}
	}
	for(int i=0; i<120; ++i){
		int t=0;
		for(int j=0; j<5; ++j){
			t+=dis[biao[i][j]][f[biao[i][j+1]]];
		}
		ans=min(ans,t);
	}
	printf("%d",ans);
	return 0;
}
```

本蒟蒻AC冗长代码
```
#include <stdio.h>
#include <iostream>
#include <queue>
using namespace std;

struct point{
	int to;
	int dist;
	int operator<(const point &b) const
	{
		return dist > b.dist;
	}
}; 

struct node{
	int to;
	int dist;
	int pre;
};

int biao[120][7]={{1,2,3,4,5},{1,2,3,5,4},{1,2,4,3,5},{1,2,4,5,3},{1,2,5,3,4},{1,2,5,4,3},{1,3,2,4,5},{1,3,2,5,4},{1,3,4,2,5},{1,3,4,5,2},{1,3,5,2,4},{1,3,5,4,2},{1,4,2,3,5},{1,4,2,5,3},{1,4,3,2,5},{1,4,3,5,2},{1,4,5,2,3},{1,4,5,3,2},{1,5,2,3,4},{1,5,2,4,3},{1,5,3,2,4},{1,5,3,4,2},{1,5,4,2,3},{1,5,4,3,2},{2,1,3,4,5},{2,1,3,5,4},{2,1,4,3,5},{2,1,4,5,3},{2,1,5,3,4},{2,1,5,4,3},{2,3,1,4,5},{2,3,1,5,4},{2,3,4,1,5},{2,3,4,5,1},{2,3,5,1,4},{2,3,5,4,1},{2,4,1,3,5},{2,4,1,5,3},{2,4,3,1,5},{2,4,3,5,1},{2,4,5,1,3},{2,4,5,3,1},{2,5,1,3,4},{2,5,1,4,3},{2,5,3,1,4},{2,5,3,4,1},{2,5,4,1,3},{2,5,4,3,1},{3,1,2,4,5},{3,1,2,5,4},{3,1,4,2,5},{3,1,4,5,2},{3,1,5,2,4},{3,1,5,4,2},{3,2,1,4,5},{3,2,1,5,4},{3,2,4,1,5},{3,2,4,5,1},{3,2,5,1,4},{3,2,5,4,1},{3,4,1,2,5},{3,4,1,5,2},{3,4,2,1,5},{3,4,2,5,1},{3,4,5,1,2},{3,4,5,2,1},{3,5,1,2,4},{3,5,1,4,2},{3,5,2,1,4},{3,5,2,4,1},{3,5,4,1,2},{3,5,4,2,1},{4,1,2,3,5},{4,1,2,5,3},{4,1,3,2,5},{4,1,3,5,2},{4,1,5,2,3},{4,1,5,3,2},{4,2,1,3,5},{4,2,1,5,3},{4,2,3,1,5},{4,2,3,5,1},{4,2,5,1,3},{4,2,5,3,1},{4,3,1,2,5},{4,3,1,5,2},{4,3,2,1,5},{4,3,2,5,1},{4,3,5,1,2},{4,3,5,2,1},{4,5,1,2,3},{4,5,1,3,2},{4,5,2,1,3},{4,5,2,3,1},{4,5,3,1,2},{4,5,3,2,1},{5,1,2,3,4},{5,1,2,4,3},{5,1,3,2,4},{5,1,3,4,2},{5,1,4,2,3},{5,1,4,3,2},{5,2,1,3,4},{5,2,1,4,3},{5,2,3,1,4},{5,2,3,4,1},{5,2,4,1,3},{5,2,4,3,1},{5,3,1,2,4},{5,3,1,4,2},{5,3,2,1,4},{5,3,2,4,1},{5,3,4,1,2},{5,3,4,2,1},{5,4,1,2,3},{5,4,1,3,2},{5,4,2,1,3},{5,4,2,3,1},{5,4,3,1,2},{5,4,3,2,1}};
int m , n;
int top;
int ans = 0x7fffffff;
int x , y , w;
int d[7][50005];
int t[6];
int v[500005];
bool f[500005];
node g[1000005];
priority_queue<point> dl;

void qxx(int fa , int child , int w)
{
	g[++top].pre = v[fa];
	g[top].to = child;
	g[top].dist = w;
	v[fa] = top;
}

void dij(int k)
{
	point t1;
	t1.dist = 0;
	t1.to = t[k];
	d[k][t[k]] = 0;
	dl.push(t1);
	while(!dl.empty())
	{
		t1 = dl.top();
		int p = t1.to;
		dl.pop();
		if(f[p]) continue;
		f[p] = true;
		for(int i = v[p]; i; i = g[i].pre){
			int a = g[i].to;
			if(f[a]) continue;
			d[k][a] = min(d[k][a] , d[k][p] + g[i].dist);
			point o;
			o.dist = d[k][a];
			o.to = a;
			dl.push(o);
		}
	}
	for(int i = 1; i <= m; ++i) f[i] = false;
}

int main()
{
	scanf("%d %d" , &m , &n);
	for(int i = 1; i <= 5; ++i) scanf("%d" , & t[i]);
	t[0] = 1;
	for(int i = 1; i <= n; ++i){
		scanf("%d %d %d" , &x , &y , &w);
		qxx(x , y , w);
		qxx(y , x , w);
	}
	for(int i = 0; i <= 5; ++i){
		for(int j = 1; j <= m; ++j){
			d[i][j] = 0x7ffffff / 3;
		}
	}
	for(int i = 0; i <= 5; ++i){
		dij(i);
	}
	for(int i = 0; i <= 119; ++i){
		int s = 0;
		s += d[0][t[biao[i][0]]]; 
		for(int j = 0; j <= 3; ++j){
			s += d[biao[i][j]][t[biao[i][j + 1]]];
		}
		ans = min(ans , s);
	}
	printf("%d" , ans);
}
```
支持一下本蒟蒻吧QAQ



---

## 作者：Zkxxxv_h (赞：5)

>为了图做题快一点， 选择了spfa，然后就被卡死了<

solution:以5个点为起点，确定他们的最短路；后全排列搜索可能的情况。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e4 + 50;
const int M = 1e5 + 50;
int n, m, ans = 0x7fffffff;
int sky[7], zkx[7], dis[N][7], visited[N];
struct node {
    int next, to, dis;
} edge[M << 1];
int cnt, head[N];
inline void add(int from, int to, int dis) {
    edge[++cnt] = (node){ head[from], to, dis };
    head[from] = cnt;
}
//void spfa(int s) {
//    queue<int> q;
//    dis[sky[s]][s] = 0, q.push(sky[s]);
//    memset(visited, 0, sizeof visited);
//    visited[sky[s]] = 1;
//    while (!q.empty()) {
//        int u = q.front();
//        q.pop();
//        visited[u] = 0;
//        for (int i = head[u]; i; i = edge[i].next) {
//            int v = edge[i].to;
//            if (dis[v][s] > dis[u][s] + edge[i].dis) {
//                dis[v][s] = dis[u][s] + edge[i].dis;
//                if (!visited[v])
//                    visited[v] = 1, q.push(v);
//            }
//        }
//    }
//}
#define pi pair<int, int>
#define mp make_pair
void dijiesitela(int s) {
    priority_queue<pi, vector<pi>, greater<pi> > q;
    memset(visited, 0, sizeof visited);
    dis[sky[s]][s] = 0, q.push(mp(0, sky[s]));
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (visited[u])
            continue;
        visited[u] = 1;
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v][s] > dis[u][s] + edge[i].dis) {
                dis[v][s] = dis[u][s] + edge[i].dis;
                q.push(mp(dis[v][s], v));
            }
        }
    }
}
void dfs(int step, int pos, int cos) {
    if (step >= 5) {
        ans = min(ans, cos);
        return;
    }
    for (int i = 1; i <= 5; i++) {
        if (zkx[i])
            continue;
        zkx[i] = 1;
        dfs(step + 1, i, cos + dis[sky[i]][pos]);
        zkx[i] = 0;
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= 5; i++) scanf("%d", sky + i);
    for (int i = 1; i <= m; i++) {
        int x, y, t;
        scanf("%d%d%d", &x, &y, &t);
        add(x, y, t), add(y, x, t);
    }
    sky[6] = 1;
    memset(dis, 0x3f, sizeof dis);
    dijiesitela(6), dijiesitela(1), dijiesitela(2), dijiesitela(3), dijiesitela(4), dijiesitela(5);
    for (int i = 1; i <= 5; i++) {
        zkx[i] = 1;
        dfs(1, i, dis[sky[i]][6]);
        zkx[i] = 0;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：FjswYuzu (赞：5)

这算是一道比较水的省选题。我们先暴力最短路分别求出以$1,a,b,c,d,e$为起点的最短路，然后进行搜索，判断怎么走是最快的，更新答案。

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#define inf 0x7fffffff
using namespace std;
bool used[50005],searchUsed[10];
struct Edge{
	int v,value;
	bool operator <(const Edge &a) const {return this->value>a.value;}
};
priority_queue<Edge> Q;
vector<Edge> G[50005];
int n,m,par[10],dis[10][50005],ans=0x7fffffff;
void Empty(){while(Q.size())	Q.pop();}
void Dijkstra(int u)
{
	Empty();
	memset(used,false,sizeof used);
	for(int i=1;i<=n;++i)	dis[u][i]=inf;
	dis[u][par[u]]=0;
	Q.push((Edge){par[u],0});
	while(Q.size())
	{
		Edge now=Q.top();
		Q.pop();
		int where=now.v;
		if(used[where])	continue;
		used[where]=true;
		for(unsigned long i=0;i<G[where].size();++i)	if(dis[u][where]+G[where][i].value<dis[u][G[where][i].v])	dis[u][G[where][i].v]=dis[u][where]+G[where][i].value,Q.push((Edge){G[where][i].v,dis[u][G[where][i].v]});
	}
}//判断起点，进行分别最短路。这里用的dijkstra
void Search(int tot,int value,int now)
{
	if(tot==5)
	{
		ans=min(ans,value);
		return ;
	}
	for(int i=1;i<=5;++i)	if(!searchUsed[i])	searchUsed[i]=true,Search(tot+1,dis[now][par[i]]+value,i),searchUsed[i]=false;
}//我们以1为起点，进行搜索。
int main(){
	scanf("%d %d",&n,&m);
	scanf("%d %d %d %d %d",&par[1],&par[2],&par[3],&par[4],&par[5]);
	par[0]=1;
	for(int i=1,u,v,value;i<=m;++i)	scanf("%d %d %d",&u,&v,&value),G[u].push_back((Edge){v,value}),G[v].push_back((Edge){u,value});
	Dijkstra(0);
	Dijkstra(1);
	Dijkstra(2);
	Dijkstra(3);
	Dijkstra(4);
	Dijkstra(5);//六次dijkstra
	Search(0,0,0);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：苍穹狮鹫 (赞：4)

重庆真是个好地方

重庆是国家历史文化名城。1189年，宋光宗赵惇先封恭王再即帝位，自诩“双重喜庆”，重庆由此得名。重庆是“红岩精神”起源地，巴渝文化发祥地，“火锅”、“吊脚楼”等影响深远

初读本题，可以易得这是一个最短路的算法，考虑主角的家在一站，可以求出主角到所有亲戚家的最短距离，在求出每个亲戚与其他亲戚的最短距离，最后用全排列找一遍即可（即DFS）。
```c
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int n,m;
int a[6];
int dis[6][100001];
int first[1000001];
int nex[1000001];
int to[1000001];
int t[1000001];
int book[1000001];
int tot;
int f[100001];
//全排列 num为现在走了多少个地方，now为当前位置（不是车站位置），ans为当前的值
int dfs(int num,int now,int ans)
{
	if(num>5) 
	return ans;
	
	int returnans=999999999;
	for(int i=1;i<=5;i++)
	{
		if(f[i]!=1)
		{
			f[i]=1;
			//printf("%d\n",dis[now][a[i]]);
			returnans=min(returnans,dfs(num+1,i,dis[now][a[i]]+ans));
			f[i]=0;
		}
	}
	
	return returnans;
}
//建边
void add(int x,int y,int z)
{
	tot++;
	nex[tot]=first[x];
	first[x]=tot;
	to[tot]=y;
	t[tot]=z;
	return ;
}
//最短路模板
void dijkstra(int u,int num)
{
	priority_queue<pair<int ,int > > q;
	memset(book,0,sizeof(book));
	memset(dis[num],0x3f,sizeof(dis[num]));
	dis[num][u]=0;
//	book[u]=1;
	q.push(make_pair(0,u));
	while(q.size())
	{
		int r=q.top().second;
		q.pop();
		if(book[r]) continue;
		book[r]=1;
		for(int i=first[r];i!=0;i=nex[i])
		{
			int v=to[i];
			int time=t[i];
			if(dis[num][r]+time<dis[num][v])
			{
				dis[num][v]=dis[num][r]+time;
				q.push(make_pair(-dis[num][v],v));
			}
		}
	}
	return ;
}
int main()
{
	cin>>n>>m;
	a[0]=1;
	for(int i=1;i<=5;i++)
	cin>>a[i];
	
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z);
	}
	
	for(int i=0;i<=5;i++)
	{
		dijkstra(a[i],i);
		//for(int j=1;j<=5;j++)
		//printf("%d ",dis[i][j]);
		//printf("\n");
	}
	int ans=99999999;
	//for(int i=1;i<=5;i++)
	//f[i]=1,	,f[i]=0;
	ans=min(dfs(1,0,0),ans);
	printf("%d",ans);
	return 0;
}

```
完


---

## 作者：银杉水杉秃杉 (赞：2)

朋友们好啊！

[题目传送门 P5765 新年好](https://www.luogu.com.cn/problem/P5764)

题目就不过多阐释了，这是一道非常有趣的最短路问题。

先来看一下数据范围，$n≤50000$，$m≤100000$，$Spfa$应该是被卡了，所以我们只能考虑$Dijkstra+$优先队列（小根堆）（划重点啦）

$Dijkstra+$优先队列模板如下：

```cpp
void dijkstra(int s)//s为起点 
{
	d[s]=0;
	q.push(make_pair(0,s));//q为pair的小根堆
    while(!q.empty())
	{
        int u=q.top().second;
        q.pop();
        if (vis[u])
			continue;
        vis[u]=1;
        for (int i=head[u];i;i=e[i].next)
        {
        	int v=e[i].to,w=e[i].val;
            if (d[v]>d[u]+w)
			{
                d[v]=d[u]+w;
                if (!vis[v])
                	q.push(make_pair(d[v],v));
			}
		}
	}
}
```
模板题：[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

再来看一下这道题，求出依次访问个点的最短路。我们就要将佳佳家和各个亲戚家分别作为起点跑一次最短路，并记录下来。于是$d[i]$变为$d[i][k]$，其中$k$指以谁作为起点（佳佳家为$1$，亲戚$a$为$2$，亲戚$b$为$3$，亲戚$c$为$4$，亲戚$d$为$5$，亲戚$e$为$6$)

至于访问亲戚的顺序，我们就用排列组合的方式暴力枚举。因为本人~~不想打搜索~~而且想给大家介绍一下$STL$大法，所以我写的是next_permutation。

next_permutation$(a+1,a+n+1)$指将$1$到$n$的数按下一个排列顺序进行排序，到了最后的排列自动退出。

当$n=4$时，排列如下：

```
1 2 3 4
1 2 4 3
1 3 2 4
1 3 4 2
1 4 2 3
1 4 3 2
2 1 3 4
2 1 4 3
2 3 1 4
2 3 4 1
2 4 1 3
2 4 3 1
3 1 2 4
3 1 4 2
3 2 1 4
3 2 4 1
3 4 1 2
3 4 2 1
4 1 2 3
4 1 3 2
4 2 1 3
4 2 3 1
4 3 1 2
4 3 2 1
```
next_permutation模板题：[P1088 火星人](https://www.luogu.com.cn/problem/P1088)

至于这道题，我们只需要保留$1$，将$2$到$6$进行排列，然后将相邻两个点之间的最短路相加求出和的最小值即可。

完整代码（AC code）

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//读入优化
{
	int x=0;
	bool f=1;
	char ch=getchar();
	while (!isdigit(ch))
	{
		if (ch=='-')
			f=0;
		ch=getchar();
	}
	while (isdigit(ch))
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return f?x:-x;
}
const int inf=1e9+10;
int n,m,t,sum,ans;
int a[7],b[7],head[50010],d[50010][7],vis[50010];
struct edge
{
	int to,next,val;
}e[200010];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;//小根堆
void add(int u,int v,int w)//构造邻接表
{
	e[++t].to=v;
	e[t].next=head[u];
	e[t].val=w;
	head[u]=t;
}
void dijkstra(int k)//求最短路
{
	memset(vis,0,sizeof(vis));
	int s=a[k];//起点为k所在的位置
	d[s][k]=0;
	q.push(make_pair(0,s));
	while (!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if (vis[u])
			continue;
		vis[u]=1;
		for (int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to,w=e[i].val;
			if (d[v][k]>d[u][k]+w)
			{
				d[v][k]=d[u][k]+w;
           if (!vis[v])    
					q.push(make_pair(d[v][k],v));
			}
		}
	}
} 
int main()
{
	n=read(),m=read();
	a[1]=1;//佳佳家的位置为1
	for (int i=2;i<=6;i++)
		a[i]=read();//记录各个亲戚的位置
	for (int i=1;i<=m;i++)
	{
		int u,v,w;
		u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);//双向建边
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=6;j++)//初始化
			d[i][j]=inf;
	for (int i=1;i<=6;i++)//每个点作为起点求一次最短路
		dijkstra(i);
	for (int i=1;i<=6;i++)//初始排列
		b[i]=i;
	ans=inf;
	do//先do后while，因为要考虑排列1 2 3 4 5 6
	{
		sum=0;
		for (int i=1;i<6;i++)//求这个排列最短路之和
			sum+=d[a[b[i+1]]][b[i]];
		ans=min(ans,sum);//更新最小值
	}
	while (next_permutation(b+2,b+7));//只用排列2到6
	printf("%d\n",ans);
	return 0;
}//完结撒花
```

按照传统题解的点到为止，这道题就到这儿了。

谢谢朋友们！

---

## 作者：HMP_Haoge (赞：1)

### 一道很不错的最短路入门题

本题考察了最基础的最短路算法，先来整理一下思路：

首先看到题第一想法就是求出6个关键点之间互相的最短路，这时就将题目转化为了一个tsp问题。

针对tsp问题，一般我们用状压DP来解决，考虑到这题需要处理的点数比较少，所以完全可以通过爆搜解决问题 ~~（其实就是懒）~~

代码中容易错的地方已经标注

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
#define MAXN 50010
#define MAXM 200010

struct node
{
	int from,to,dis;
} edge[MAXM<<1];
int head[MAXN<<1],cnt,n,m,dist[MAXN],home[10];
int dis1[8][8],minn=INT_MAX,pre[MAXN];
bool vis[MAXN];

template< typename T >inline void read(T &x)
{
	x=0;
	int f=1;
	char c=getchar();
	for(; !isdigit(c); c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c); c=getchar()) x=((x<<3)+(x<<1)+(c^48));
	x*=f;
}
template< typename T >inline void write(T x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void add(int from,int to,int dis)
{
	edge[++cnt].from=head[from];
	edge[cnt].to=to;
	edge[cnt].dis=dis;
	head[from]=cnt;
}
inline void Dij(int s)   //Dij板子
{
	priority_queue< pair< int,int > >q;
	memset(vis,0,sizeof(vis));
	memset(dist,0x3f,sizeof(dist));
	dist[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		int now=q.top().second;
		q.pop();
		if(vis[now]) continue;
		vis[now]=1;
		for(ri i=head[now]; i; i=edge[i].from)
		{
			int v=edge[i].to;
			if(dist[v]>dist[now]+edge[i].dis)
			{
				dist[v]=dist[now]+edge[i].dis;
				if(!vis[v])
				{
					q.push(make_pair(-dist[v],v));
				}
			}
		}
	}

	//将最短路得到的结果转化为tsp模型所需的邻接矩阵
	for(ri i=1; i<=6; ++i)
		dis1[pre[s]][i]=dis1[i][pre[s]]=min(dis1[i][pre[s]],dist[home[i]]);
	//这里需要注意要将原来的点编号转化为邻接矩阵中点的编号
}
inline void dfs(int now,int dis,int rest)   //通过爆搜解决tsp问题
{
	if(rest==0)
	{
		if(dis<minn)
		{
			minn=dis;
		}
		return;
	}
	if(dis>minn) return;//小剪枝
	for(ri i=1; i<=6; ++i)
	{
		if(!vis[i])
		{
			vis[i]=1;
			dfs(i,dis+dis1[now][i],rest-1);
			vis[i]=0;
		}
	}

}

int main()
{
//	freopen("newyear.in","r",stdin);
//	freopen("newyear.out","w",stdout);
	read(n);
	read(m);
	home[1]=1;
	pre[1]=1;
	for(ri i=2; i<=6; ++i) read(home[i]),pre[home[i]]=i;
	int u,v,t;
	for(ri i=1; i<=m; ++i)
	{
		read(u);
		read(v);
		read(t);
		add(u,v,t);
		add(v,u,t);
	}
	memset(dis1,0x3f,sizeof(dis1));
	for(ri i=1; i<=6; ++i)//这里其实不需要跑6遍，5遍足够了
		Dij(home[i]);
	memset(vis,0,sizeof(vis));
	vis[1]=1;
	dfs(1,0,5);
	write(minn);
}
```

完结撒花~

---

## 作者：Zzxpy (赞：1)

这是道最短路的板题（辛苦管理大大百忙之中抽时间审核！！！）

1.由于亲戚很少，没必要用floyd来求出所有点作为源点的最短路。

2.没有负环，考虑用堆来优化某著名算法(~~spfa~~)

3.在求出每个亲戚作为源点的最短后，由于n很小，考虑用搜索搜出最小值

4.下面上代码

5.在我的博客观看体验更佳哦<https://tian0-hjyh.blog.luogu.org/>

```cpp
#define ITC_TL
#include<bits/stdc++.h>
using namespace std;
#define ll long long int
ll dp[7][51234],head[212345],to[212345],nxt[212345],tot=0,zhi[212345];
ll a[11],u,v,w,sum1=0,min1=999999999999ll,n,m;
bool b[2123456],p[233];
void add(ll x,ll y,ll z) {
	tot++;
	to[tot]=y;
	nxt[tot]=head[x];
	zhi[tot]=z;
	head[x]=tot;
}
void dj(ll t) {
	ll s;
	priority_queue<pair<ll,ll>,vector<pair<ll,ll> >,greater<pair<ll,ll> > >q;
	memset(dp[t],127,sizeof(dp[t]));
	memset(b,0,sizeof(b));
	dp[t][a[t]]=0;
	q.push(make_pair(0,a[t]));
	while(!q.empty()) {
		s=q.top().second;
		q.pop();
		if(b[s]) continue;
		b[s]=1;//cout<<s<<endl;
		for(int i=head[s]; i; i=nxt[i]) {
			if(dp[t][s]+zhi[i]<dp[t][to[i]]) {
				dp[t][to[i]]=dp[t][s]+zhi[i];
				if(!b[to[i]]) {
					q.push(make_pair(dp[t][to[i]],to[i]));
				}
			}
		}
	}
}
void dfs(ll t,ll fa) {
	if(t>5){
		if(sum1<min1) min1=sum1;
		return ;
	}
	for(int i=2; i<=6; i++) {
		if(p[i]) continue;
		p[i]=1;
		sum1+=dp[fa][a[i]];
		dfs(t+1,i);
		sum1-=dp[fa][a[i]];
		p[i]=0;
	}
}
int main() {
//	freopen("newyear.in","r",stdin);
//	freopen("newyear.out","w",stdout);
	cin>>n>>m;
	a[1]=1;
	for(int i=2; i<=6; i++) cin>>a[i];
	for(int i=1; i<=m; i++) {
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u,v,w);
		add(v,u,w);
	}
	for(int i=1; i<=6; i++) {
		dj(i);
	}
	dfs(1,1);
	cout<<min1<<endl;
}
/*
6 6
2 3 4 5 6
1 2 8
2 3 3
3 4 4
4 5 5
5 6 2
1 6 7
*/
```

---

## 作者：洛桃 (赞：0)

## 思路
比较简单的题，虽然看起来有点像多源最短路，但是其实只有6个可能的源点，包括佳佳的家和5个亲戚的家。

我们只需要分别以这6个点为起点跑6遍dijkstra，然后再dfs枚举出每一种可能的排列即可。

由于总共只有5个亲戚，所以所有可能的拜访顺序仅有 $5!=120$ 种，完全可以承受。

有一点常数优化可以不用在意。
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#define il inline
#define P pair<int,int>
using namespace std;
int n,o,b,c,d,e,head[200010],dis[6][100010],tot;
int x,y,z,m,fd[6],ans[6],minn=1e9,sum;
il int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
bool ex[100010];
struct node{
	int to,next,w;
}a[200010];
il void add(int x,int y,int z)
{
	a[++tot].to=y;a[tot].w=z;
	a[tot].next=head[x];head[x]=tot;
}
void dij(int s)
{
	priority_queue<P,vector<P>,greater<P> >q;
	q.push(P(0,fd[s]));
	dis[s][fd[s]]=0;
	while(!q.empty())
	{
		int u=q.top().second,sum=q.top().first;
		q.pop();
		if(sum>dis[s][u])continue;
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(dis[s][v]>dis[s][u]+a[i].w)
			{
				dis[s][v]=dis[s][u]+a[i].w;
				q.push(P(dis[s][v],v));
			}
		}
	}
}
bool exi[6];
void dfs(int k,int sum,int p)
{
	if(sum>=minn)return;
	if(k==6)
	{
		minn=min(minn,sum);
		return;
	}
	for(int i=1;i<=5;i++)
	{
		if(exi[i])continue;
		exi[i]=1;
		dfs(k+1,sum+dis[p][fd[i]],i);
		exi[i]=0;
	}
}
int main()
{
	n=read();m=read();
	o=read();b=read();c=read();d=read();e=read();
	fd[1]=o,fd[2]=b,fd[3]=c,fd[4]=d,fd[5]=e;
	for(int i=1;i<=m;i++)
	{
		x=read();y=read();z=read();
		add(x,y,z);add(y,x,z);
	}
	fd[0]=1;
	memset(dis,0x3f,sizeof(dis));
	for(int i=0;i<=5;i++)
	{
		dij(i);
	}
	dfs(1,0,0);
	printf("%d",minn);
	return 0;
}
```


---

## 作者：BreakPlus (赞：0)

这里讲如何用 ``Dijkstra`` 算法 $\color{green} \text{Accepted}$ 此题。

我们还不知道如何安排访问亲戚的顺序，这个咋整？不难想到全排列枚举。

是的，我们可以使用 ``STL`` 库中的 ``next_permutation`` 函数。

然后就是一个最短路了。我们没有充足的时间与空间让我们求出全源最短路，怎么办？

其实，跑全源最短路后有很多数据是不需要的，**我们只要求出对于 $1$号点与 $a,b,c,d,e$ 到其它点的最短路径**。

这不就是一个  $6$ 轮单源最短路吗？

我们考虑给 ``Dijkstra`` 算法中的存储最短路的数组加一个维度 ``[6]``，以及某些技巧（见代码）：

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
typedef pair<int,int> P;
#define mkp(a,b) make_pair(a,b)
const int maxn=50010,maxm=100010,INF=2147483647;
int n,m,x,y,t,f[6],dis[6][maxn],vis[6][maxn];
struct Edge{
    int to,w,next;
}edge[maxm<<1];
int head[maxm<<1],tot;
void add(int u,int v,int w){
    tot++;
    edge[tot].to=v;
    edge[tot].w=w;
    edge[tot].next=head[u];
    head[u]=tot;
}
void Dijkstra(int x,int s){ //存到第几维度以及初始点
    priority_queue<P,vector<P>,greater<P> >q; //优先队列
    q.push(mkp(0,s));
    for(register int i=1;i<=n;i++) dis[x][i]=INF;
    dis[x][s]=0;//初始化，在队列中加入 初始点
    while(!q.empty()){
        int T=q.top().second;
        q.pop();
        if(vis[x][T]) continue;
        vis[x][T]=true;//剪掉
        for(register int i=head[T];i;i=edge[i].next){
            int tmp=edge[i].to;
            if(dis[x][tmp]>dis[x][T]+edge[i].w){
                dis[x][tmp]=dis[x][T]+edge[i].w;
                if(!vis[x][tmp]) q.push(mkp(dis[x][tmp],tmp));
            }//核心代码
        }
    }
}// Dijkstra
int main(){
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=5;i++) scanf("%d",&f[i]);
    for(register int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&t);
        add(x,y,t);add(y,x,t);
    }
    Dijkstra(0,1);
    for(register int i=1;i<=5;i++) Dijkstra(i,f[i]); //循环来求 6 个 Dijkstra 。
    int tmp[6]={0,1,2,3,4,5},cnt=0,ans=1e9;
    while(1){
        if(cnt==120) break;//共 5!=120 次
        cnt++;
        int ToT=dis[0][f[tmp[1]]];
        for(register int i=1;i<=4;i++){
            ToT+=dis[tmp[i]][f[tmp[i+1]]];
        }
        if(ToT<ans) ans=ToT;//取最小值
        next_permutation(tmp+1,tmp+6);//直接枚举前排列
    }
    printf("%d\n",ans);
    return 0;
}
```

这样岂不是方便极了，不用复制、粘贴 $6$ 段代码了吗？

---

## 作者：Reanap (赞：0)

目测题目，一共只有五个车站，而他又跟最短路挂钩，所以我们考虑写六个最短路，对于每个亲戚车站都可以求出到其他车站的最短路，然后爆搜枚举五个车站的到达顺序求得最短时间即可。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
struct node {
	LL v , w;
	node() {}
	node(LL V , LL W) {
		v = V;
		w = W;
	}
};
LL dp[6][50005] , n , r , ans = 1e9;
vector <node> G[100005];
bool vis[100050];
void read(LL &x) {
	LL f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0'; s = getchar();}
	x *= f;
}
struct cmp1 {
	bool operator() (node &x , node &y) {
		return x.w > y.w;
	}
};
priority_queue <node , vector <node> , cmp1> q;
LL a[7];
void dijkstra(LL s) {
	for (LL i = 1; i <= n; ++i) dp[s][i] = 1e16;
	dp[s][a[s]] = 0;
	q.push(node(a[s] , 0));
	while(!q.empty()) {
		node now = q.top();
		q.pop();
		LL x = now.v;
		if(vis[x]) continue;
		vis[x] = 1;
		for (LL i = 0; i < G[x].size(); ++i) {
			if(dp[s][x] + G[x][i].w < dp[s][G[x][i].v]) {
				dp[s][G[x][i].v] = dp[s][x] + G[x][i].w;
				q.push(node(G[x][i].v , dp[s][G[x][i].v]));
			}
		}
	}
}//dijksta不解释

bool bv[7];
void dfs(LL t , LL cur , LL last) {
	if(t == 5) {
		ans = min(ans , cur);
	}
	for (LL i = 1; i <= 5; ++i) {
		if(!bv[i]) {
			bv[i] = 1;
			dfs(t + 1 , dp[last][a[i]] + cur , i);
			bv[i] = 0;
		}
	}
}//爆搜枚举顺序
int main() {
	read(n);
	read(r);
	for (LL i = 1; i <= 5; ++i) scanf("%lld" , &a[i]);
	for (LL i = 1; i <= r; ++i) {
		LL x , y , w;
		read(x);read(y);read(w);
		G[x].push_back(node(y , w));
		G[y].push_back(node(x , w));
	}
	a[0] = 1;
	dijkstra(0);
	memset(vis , 0 , sizeof vis);
	dijkstra(1);
	memset(vis , 0 , sizeof vis);
	dijkstra(2);
	memset(vis , 0 , sizeof vis);
	dijkstra(3);
	memset(vis , 0 , sizeof vis);
	dijkstra(4);
	memset(vis , 0 , sizeof vis);
	dijkstra(5);
	memset(vis , 0 , sizeof vis);//五个亲戚家
	dfs(0 , 0 , 0);
	printf("%lld" , ans);
	return 0;
}
```

---

## 作者：ljcljc (赞：0)

## 【算法分析】

思路：$spfa$ + $DFS$

1.预先求出从$1$，$a$，$b$，$c$，$d$，$e$出发到其他所有点的单源最短路径。

2.$DFS$枚举所有拜访顺序，对于每一种拜访顺序，可以通过先前求出的单源最短路径求出答案。

### AC代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;

const int N = 50010;
const int M = 100010;
int n, m;
int a[6];
struct edge {
	int to, w;
};
vector<edge> G[M];
int dis[6][N], vis[N];

void spfa(int s,int dis[]) {
   memset(dis, 0x3f, N * 4);
   memset(vis, 0, sizeof(vis));
   queue<int> q;
	q.push(s);
	vis[s] = 1;
	dis[s] = 0;
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for(int i=0; i<G[u].size(); i++) {
			int v = G[u][i].to;
			int w = G[u][i].w;
			if(dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				if(!vis[v]) {
					q.push(v);
					vis[v] = 1;
				}
			}
		}
	}
}

int f[N];

int dfs(int u, int id, int s) {
	if(u > 5) return s;
	int res = 1e9;
	for(int i=1; i<=5; i++) 
		if(!f[i]) {
			f[i] = 1;
			res = min(res, dfs(u+1, i, s+dis[id][a[i]]));
			f[i] = 0;
		}
	return res;
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i=1; i<=5; i++) {
		scanf("%d", &a[i]);
	}
	a[0] = 1;
	for(int i=1; i<=m; i++) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		G[u].push_back((edge){v, w});
		G[v].push_back((edge){u, w});
	}
	for(int i=0; i<=5; i++) spfa(a[i], dis[i]);
	printf("%d\n", dfs(1, 0, 0));
	return 0;
}
```


---


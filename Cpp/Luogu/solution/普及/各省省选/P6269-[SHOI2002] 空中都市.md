# [SHOI2002] 空中都市

## 题目描述

在未来的空中都市中，有很多个小岛（城区）。现在要求在这些小岛之间架一座桥梁，每座桥是指在两个岛之间的通道。

有个约定，如果 $A$ 与 $B$ 之间有桥，$B$ 与 $C$ 之间有桥，则 $A$ 与 $C$ 之间就不能再架桥了，即对于城市中的任意三个岛，不能在其中的两两之间都架上桥。在这样的约定下，要求架的桥的数量最多。当然不必考虑具体的空间结构问题。

## 样例 #1

### 输入

```
6```

### 输出

```
9```

## 样例 #2

### 输入

```
11```

### 输出

```
30```

# 题解

## 作者：WYXkk (赞：25)

由 [图兰定理（Turán's theorem）](https://baike.baidu.com/item/%E6%89%98%E5%85%B0%E5%AE%9A%E7%90%86/1688058?fromtitle=%E5%9B%BE%E5%85%B0%E5%AE%9A%E7%90%86&fromid=12727894&fr=aladdin) 可知，本题答案为 $\left\lfloor\dfrac{n^2}4\right\rfloor$。

$\texttt{code(python):}$

```python
n=int(input())
print(n*n//4)
```

图兰定理：假如一个 $n$ 个点的简单图中任意 $3$ 个点都不互相连接，则其边数不超过 $\left\lfloor\dfrac{n^2}4\right\rfloor$。

图兰定理的证明：

取一个符合条件的图。记 $d(X)$ 为与 $X$ 相连的边的数量，称为 $X$ 的度数。

假设所有 $n$ 个点中，$A$ 的度数最大，为 $k$，$B_1,B_2,\cdots,B_k$ 与 $A$ 相连，$C_1,C_2,\cdots,C_{n-k-1}$ 与 $A$ 不相连。

由于 $A$ 与 $B_1,B_2,\cdots,B_k$ 都有连边，假如存在 $B_iB_j$ 这条边，那么 $AB_iB_j$ 三个点互相连接，矛盾。因此 $B_i$ 之间没有连边，故 $d(B_i)\le n-k$（至多与所有 $C_j$ 和 $A$ 连边）。

同时，由于 $d(A)$ 最大，为 $k$，故 $d(C_j)\le k$。

因此，设边数为 $e$，则 

$$\begin{aligned}e&=\dfrac{\sum d(X)}2\\&=\dfrac{d(A)+\sum\limits_{i=1}^kd(B_i)+\sum\limits_{j=1}^{n-k-1}d(C_j)}2\\&\le\dfrac{k+k\times(n-k)+(n-k-1)\times k}2\\&=k\times(n-k)\\&\le\left\lfloor\dfrac{n^2}4\right\rfloor\end{aligned}$$

记 $k=\left\lfloor\dfrac n2\right\rfloor$，则当且仅当图为 $K_{k,n-k}$，即两边点数分别为 $k$ 和 $n-k$ 的完全二分图时取到等号。

---

## 作者：云浅知处 (赞：7)

[图兰定理](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%85%B0%E5%AE%9A%E7%90%86)板子awa

[珂能会有更好的阅读体验](yunqian-qwq.github.io/post/solution-p6269 "欢迎光临QAQ！")

------------

[图兰定理](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%85%B0%E5%AE%9A%E7%90%86)：若图 $G$ 中有 $n$ 个点，且完全图 $K_{r}$ 不是 $G$ 的子图，则 $G$ 中的边数最多为 $\left\lfloor\left(1-\dfrac{1}{r-1}\right)\cdot\dfrac{n^2}{2}\right\rfloor$。

本题就是 $r=3$ 的情况，也就是不存在三角形。此时最大边数为：$\left\lfloor\dfrac{n^2}{4}\right\rfloor$。

这里证明一下 $r=3$ 时的情况awa。

首先给出构造：我们把 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 个点放在「左边」，$\left\lceil\dfrac{n}{2}\right\rceil$个点放在「右边」，再将「左边」的每个点都与「右边」的每个点连上一条边。

此时，图 $G$ 中不存在两两相连的三个点，且总边数为 $\left\lfloor\dfrac{n}{2}\right\rfloor\cdot\left\lceil\dfrac{n}{2}\right\rceil=\left\lfloor\dfrac{n^2}{4}\right\rfloor$。

下面证明这种构造的确是最优的构造。

首先这 $n$ 个点中必有一个点的度数最大，记为 $A$。设  $\deg(A)=k$。

设与 $A$ 相连的这 $k$ 个点分别为 $B_1,B_2,\dots,B_k$，则 $\forall i,j\in[1,k],B_i$ 与 $B_j$ 不相连，否则 $A,B_i,B_j$ 构成了一个三角形，不符合条件。

于是 $\forall i\in[1,k]$，$B_i$ 至多与 $A$ 和剩下的 $n-k-1$ 个点相连，即 $\forall i\in[1,k],\deg(B_i)\le n-k$。

设剩下的 $n-k-1$ 个点分别为 $C_1,C_2,\dots,C_{n-k-1}$ ，由于 $A$ 是度数最大的，故 $\forall i\in[1,n-k-1]$，有 $\deg(C_i)\le \deg(A)=k$。

现在，我们来看一看整个图中有多少边。

此时图中边数为：

$$
\begin{aligned}
|E|&=\dfrac{\sum\deg(X)}{2}\\
&=\dfrac{\deg(A)+\sum_{i=1}^{k}\deg(B_i)+\sum_{i=1}^{n-k-1}\deg(C_i)}{2}\\
&\le\dfrac{k+k\cdot(n-k)+(n-k-1)\cdot k}{2}\\
&=k(n-k)\\
&\le\dfrac{n^2}{4}
\end{aligned}
$$

最后一步是用了一下基本不等式放缩，取等条件为 $k=\left\lfloor\dfrac{n}{2}\right\rfloor$。

而已经给出了使总边数为 $\left\lfloor\dfrac{n^2}{4}\right\rfloor$ 的构造，又证明了边数不超过 $\left\lfloor\dfrac{n^2}{4}\right\rfloor$，所以本题答案就是 $\left\lfloor\dfrac{n^2}{4}\right\rfloor$。

极简代码：

```cpp
#include<cstdio>
#include<cstdlib>

using namespace std;

int n;

int main(void){
    
    scanf("%d",&n);
    printf("%d\n",n*n/4);

    return 0;
}
```

------------

$\text{PS}$：这里顺便提一下其他题解中打表发现的递推式awa。

@[Warriors_Cat
](https://www.luogu.com.cn/user/147999)&@[idgg007](https://www.luogu.com.cn/user/297831)&@[yisu](https://www.luogu.com.cn/user/127707) 巨佬的递推式：

设 $A_n$ 为点数为 $n$ 时的最大边数，则 $A_1=0,A_n=A_{n-1}+\left\lfloor\dfrac{n}{2}\right\rfloor$。

唔，其实我们是可以推出 $\{A_n\}$ 的通项就是 $A_n=\left\lfloor\dfrac{n^2}{4}\right\rfloor$ 的awa。

证明其实也很简单，用数学归纳法一步就完事啦qwq：

- $n=1$ 时，$A_1=0=\left\lfloor\dfrac{1^2}{4}\right\rfloor$，符合。
- 设 $n=k$ 时有 $A_k=\left\lfloor\dfrac{k^2}{4}\right\rfloor$，则当 $n=k+1$ 时：

$$
\begin{aligned}
A_{k+1}&=A_k+\left\lfloor\dfrac{k+1} {2}\right\rfloor\\
&=\left\lfloor\dfrac{k^2}{4}\right\rfloor+\left\lfloor\dfrac{k+1} {2}\right\rfloor
\end{aligned}
$$

分类讨论一下：当 $2|k$ 时，

$$
\begin{aligned}
\left\lfloor\dfrac{k^2}{4}\right\rfloor+\left\lfloor\dfrac{k+1} {2}\right\rfloor&=\dfrac{k^2}{4}+\dfrac{k}{2}=\dfrac{k^2+2k}{4}\\
&=\dfrac{(k+1)^2-1}{4}=\left\lfloor\dfrac{(k+1)^2}{4}\right\rfloor
\end{aligned}
$$

（用了一下熟知结论：奇数的平方模 $4$ 余 $1$）

当 $2\nmid k$ 时，

$$
\begin{aligned}
\left\lfloor\dfrac{k^2}{4}\right\rfloor+\left\lfloor\dfrac{k+1} {2}\right\rfloor&=\dfrac{k^2-1}{4}+\dfrac{k+1}{2}\\
&=\dfrac{k^2+2k+1}{4}=\left\lfloor\dfrac{(k+1)^2}{4}\right\rfloor
\end{aligned}
$$

于是 $A_{k+1}=\left\lfloor\dfrac{(k+1)^2}{4}\right\rfloor$。

由数学归纳法知 $\forall n\in \mathbb N^*,A_n=\left\lfloor\dfrac{n^2}{4}\right\rfloor$。

所以说这个递推式和图兰定理其实是一样的啦QwQ。

---

## 作者：Daidly (赞：1)

简单的结论题，下面给出易懂的证明：

## 证明

设每个小岛连接桥数为 $a_i,i\in[1,n]$。

因为每三个小岛间只允许建两座桥，则设连接最多桥的小岛桥数为 $a_{max}$，则与小岛 $max$ 相连的点之间不允许互相连线，总的桥数量为 $sum$。

所有小岛的连接桥数都小于等于最多桥的小岛桥数，即：$a_i\leq a_{max}$

$$sum\leq a_{max}\times(n-a_{max}-1)+a_{max}$$

$$=a_{max}\times n-(a_{max})^2$$

$$=a_{max}\times(n-a_{max})$$

根据：和一定差小积大，则当 $a_{max}=n-a_{max}$ 时 $sum$ 最大。

所以 $a_{max}=\frac{n}{2}$，$sum_{max}=\frac{n}{2}\times\frac{n}{2}=\frac{n^2}{4}$。

又因为 $sum$ 是一个整数，所以 $sum_{max}=\lfloor\frac{n^2}{4}\rfloor$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<n*n/4;//这里自带取整
    return 0;
}
```

---

## 作者：VinstaG173 (赞：1)

图兰定理（或托兰定理）。

定理内容：对于一个有 $n$ 个点的无向图，若其中不存在三个点的环，则边数不超过 $\dfrac{n^2}{4}$。

证明：

设其中有一个点 $v_1$ 连出了 $k$ 条边，是连出边最多的，分别连向了 $u_1,u_2,\dots,u_k$。由条件得 $u_i,u_j(1 \le i,j \le k)$ 之间无边，即每个 $u_i$ 最多连出了 $n-k$ 条边。不妨设除了 $v_1$ 与 $u_i$ 以外的点为 $v_2,v_3,\dots,v_n-k$，则每个 $v_i$ 最多连出了 $k$ 条边。故总边数 $\le \dfrac{k(n-k)+(n-k)k}{2}=k(n-k)=\dfrac{n^2}{4}-\left( k-\dfrac{n}{2} \right)^2 \le \dfrac{n^2}{4}$。

Code:
```cpp
#include<cstdio>
int n;
int main()
{
    scanf(" %d",&n);
    printf("%d\n",n*n>>2);
    return 0;
}
```

---

## 作者：sid_shi1 (赞：1)

[P6269 [SHOI2002]空中都市](https://www.luogu.com.cn/problem/P6269)

简要题意：求在 $n$ 个点中满足每 $3$ 个点不两两有边的最多边数。

首先，这题动态规划没有头绪，所以只能手动找规律。不难发现答案是 $n$ 的平方除以 $4$ 后向下取整

其实这里有个[托兰定理](https://baike.baidu.com/item/%E6%89%98%E5%85%B0%E5%AE%9A%E7%90%86/1688058?fromtitle=%E5%9B%BE%E5%85%B0%E5%AE%9A%E7%90%86&fromid=12727894&fr=aladdin)，与我们的发现的规律一样。

定理证明如下：

先找到所有点中连出线段最多的那个点，记为 $A$ ，将剩下的点分为了两个集合 $B$ 和 $C$。

$B$ 中的点与 $A$ 点连边，$C$ 中的点与 $A$ 点不连边，设 $B$ 中有 $k$ 个元素， 则$C$ 中有 $n-k-1$ 个元素


对于 $B$ 中的任意点，两两之间不能连线（若否，则与 $A$ 构成三角形），它们之中的每个元素至多连出 $n-k$ 条边；对于 $C$ 中的任意点，它们至多连 $k$ 条边（$k$ 的最大性）。


总边数的两倍 $ \ge k+k(n-k)+(n-k-1) \times k=2k(n-k)$ ，然后可以得到结论了。



所以代码非常简单了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    printf("%d",n*n/4);
    return 0;
}
```



---


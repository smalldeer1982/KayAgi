# [省选联考 2021 B 卷] 数对

## 题目描述

给定 $n$ 个正整数 $a_i$，请你求出有多少个数对 $(i, j)$ 满足 $1 \le i \le n$，$1 \le j \le n$，$i \ne j$ 且 $a_i$ 是 $a_j$ 的倍数。

## 说明/提示

对于 $40 \%$ 的数据，$n \le 1000$。  
对于 $70 \%$ 的数据，$1 \le a_i \le 5 \times {10}^3$。  
对于 $100 \%$ 的数据，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le 5 \times {10}^5$。

## 样例 #1

### 输入

```
6
16 11 6 1 9 11
```

### 输出

```
7
```

## 样例 #2

### 输入

```
见附件中的 pair/pair2.in。```

### 输出

```
见附件中的 pair/pair2.ans。```

# 题解

## 作者：LZH_LOVE_ZRG (赞：14)

这是一道比较良心的~~弱省~~签到题，考察考生的基本代码能力。

这里介绍几种 $2$ 比较简单的方法：

## Solution $1$：

对于每一个数 $a_i$，我们可以用 $\sqrt{a_i}$ 的时间来枚举出这个数所有的因数。

具体实现为：用一个循环 $j$ 枚举，每对数分别为 $j$ 与 $a_i\div j$。

我们用一个桶来存储每个数作为因数出现次数，

然后最后用一个循环来累加所有答案。

时间复杂度：$O(\sum\limits_{i=1}^{i<=n} \sqrt{a_i}+n)$。

代码：

```
#include<bits/stdc++.h>
#define ll long long
#define il inline
using namespace std;
const int N=5e5+10;
int read(){//没有多大用的快读
    int f=1,s=0;
    char x=getchar();
    while(x<'0'||x>'9'){
        if(x=='-') f=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9'){
        s=s*10+x-'0';
        x=getchar();
    }
    return f*s;
}
int a[N],b[N];//b即为桶
int main(){
    int n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        for(int j=1;j*j<=a[i];j++){
            if(a[i]%j!=0) continue;//关键判断
            int ans1=j,ans2=a[i]/j;
            b[ans1]++;
            if(ans1!=ans2)//特判
                b[ans2]++;
        }
    }
    ll ans=0;//爆int警告
    for(int i=1;i<=n;i++)
        ans+=(ll)b[a[i]]-1;//累加，减一是减去自己的贡献
    cout<<ans;
    return 0;
}
```
## Solution $2$
对于每一个 $a_i$，改为枚举其倍数并累加其贡献。

用桶记录每个数出现的次数，再用一个数 $j$ 枚举 $a_i$ 乘上的因数。

贡献的次数就是 $b_i\times b_{i\times j}+b_i\times (b_i-1)$，后者就是 $a_i$ 是自己的倍数的情况。

时间复杂度：调和级数时间复杂度，即为 $O(\max{a_i} \times \log{\max{a_i}})$。

代码：
```
#include<bits/stdc++.h>
#define ll long long
#define il inline
using namespace std;
const int N=5e5+10;
int read(){
    int f=1,s=0;
    char x=getchar();
    while(x<'0'||x>'9'){
        if(x=='-') f=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9'){
        s=s*10+x-'0';
        x=getchar();
    }
    return f*s;
}
int a[N],b[N];
int main(){
    int n=read();
    for(int i=1;i<=n;i++)
    	b[read()]++;
    ll ans=0;
    for(int i=1;i<=N;i++){
    	for(int j=2;i*j<=N;j++)
    		ans+=b[i]*b[i*j];
    	ans+=b[i]*(b[i]-1);
	}
    cout<<ans;
    return 0;
}
```

更新日志：
+ 2021/4/13 更正了时间复杂度的计算；
+ 2021/4/14 增加了第 $2$ 种解题方法；
+ 2021/4/17 感谢 [houzhiyuan](https://www.luogu.com.cn/user/98490) 大佬的批评指正，更改了第 $2$ 种方法的计算。

---

## 作者：y0y68 (赞：8)

update 2021.4.12：修改了两处笔误

给出一种独特的解法。

设一个正整数 $K$，将不大于 $K$ 的 $a_i$ 与大于 $K$ 的 $a_i$ 提出来，分为两组。方便起见，将不大于 $K$ 的一组称为第一组，大于 $K$ 的称为第二组。第一组内的数暴力计算，即平方级别的时间复杂度；第二组内的数开个桶，枚举 $a_i$，每次将 $5 \times 10^5$ 以内的 $a_i$ 的倍数加一，然后从 $1$ 扫到 $5 \times 10^5$ 统计；最后暴力统计第二组内的数为第一组中数的倍数的情况。

**注意数字重复的情况**

设 $a$ 为去重后第一组中数的个数（去重是为了将第一组内部处理，即暴力枚举的时间复杂度控制在 $O(K^2)$ 以内），$b$ 为第二组中数的个数，则时间复杂度为 $O(n \log n + a^2+ab+b \times \frac{5 \times 10^5}{K+1})$，约等于（或者说是不超过 $O(n \log n +K^2+nK+\frac{5n \times 10^5}{K+1})$）。显然，若 $K$ 过大，则 $K^2$ 过大；若 $K$ 过小，则 $\frac{5n \times 10^5}{K+1}$ 过大。

现在考虑 $K$ 的取值，若 $K$ 取 $10^3$ 则可做到较优的时间复杂度。（这是我的考场取法，用均值不等式可取到更优的值）

放上（非）考场代码（民间数据可过，细节见注释）：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=2e5+5;
const int M=5e5+5;
int n,a[N],st[M],ed[M],cnt[M],tmp[N];
/*
st[i]表示序列中第一个出现i的位置
ed[i]表示序列中最后一个出现i的位置
st与ed都是用于重复数字的计算
tmp表示第一组去重后的序列
cnt[i]：当i<=K时表示i在第一组中出现的次数，用于重复数字的计算；当i>K时表示前文所述的桶
*/
inline void in(int &x){
	char c;
	for(c=getchar();c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);
}
int main(){
	freopen("pair.in","r",stdin);
	freopen("pair.ans","w",stdout);
	in(n);
	for(int i=1;i<=n;i++)in(a[i]);
	sort(a+1,a+n+1);
	for(int i=n;i>=1;i--)st[a[i]]=i;
	for(int i=1;i<=n;i++)ed[a[i]]=i;
	int pos=1;
	for(;pos<=n&&a[pos]<=1000;cnt[a[pos]]++,pos++);
	//pos表示序列中第一个大于K的位置
	long long ans=0;
	for(register int i=1;i<pos;i++)tmp[i]=a[i];
	int tot=unique(tmp+1,tmp+pos)-tmp-1;//去重
	for(register int i=1;i<=tot;i++)
		for(register int j=pos;j<=n;j++)
			if(a[j]%tmp[i]==0)ans+=cnt[tmp[i]];//统计第二组数为第一组数的倍数的情况
	for(register int i=1;i<tot;i++)
		for(register int j=i+1;j<=tot;j++)
			if(tmp[j]%tmp[i]==0)ans+=1ll*cnt[tmp[j]]*cnt[tmp[i]];//第一组内部处理，即暴力枚举
	for(int i=1;i<=1000;i++)
		if(cnt[i])ans+=1ll*cnt[i]*(cnt[i]-1);//数字相同也是倍数，也要统计，注意一下题面中的i≠j
	if(pos>n){//全都不大于K，即第二组中没有数，就直接输出
		printf("%lld\n",ans);
		return 0;
	}
	for(register int i=pos;i<=n;i++)
		for(register int j=(a[i]<<1);j<M;j+=a[i])cnt[j]++;//这里不统计a[i]自己，否则会有点麻烦，a[i]重复的情况用st和ed解决
	for(register int i=pos;i<=n;i++)
		ans+=cnt[a[i]];
	for(register int i=1001;i<=500000;i++)
		if(st[i])ans+=1ll*(ed[i]-st[i]+1)*(ed[i]-st[i]);//处理第二组中重复的情况
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：清烛 (赞：7)

[洛谷 P7517](https://www.luogu.com.cn/problem/P7517)

算法：模拟？

## Description

给定 $n$ 个正整数 $a_i$，请你求出有多少个数对 $(i, j)$ 满足 $1 \le i \le n$，$1 \le j\le n$，$i \ne j$ 且 $a_i$ 是 $a_j$ 的倍数。

$2\le n\le2 \times 10^5$，$1 \le a_i \le 5 \times {10}^5$。

## Solution

前言：答案的上界为 $2\times10^5\times(2\times10^5 - 1)$ 需要开 `long long`。

注意到我们可以对于每一个单独的数 $a_i$，求其对答案产生的贡献，即开桶记录每个数的出现次数，枚举 $a_i$ 的倍数即可，复杂度是很明显的调和 $n\log n$，可以稳过。

考场代码：（求叉qwq）

```cpp
#include <cstdio>
#include <cctype>
#define rint register int
#define il inline
#define FOR(i, a, b) for (rint i = a; i <= b; ++i)
#define DEC(i, a, b) for (rint i = a; i >= b; --i)

typedef long long ll;

const int maxn = 2e5 + 5, maxk = 5e5 + 5;

il int mymax(int a, int b) {return a > b ? a : b;}

int n, a[maxn], cnt[maxk], maxa;
ll ans[maxk];

int main()
{
	freopen("pair.in", "r", stdin);
	freopen("pair.out", "w", stdout);
	n = read();
	FOR(i, 1, n) cnt[a[i] = read()]++, maxa = mymax(a[i], maxa);
	FOR(i, 1, n)
	{
		if (ans[a[i]]) continue;
		for (int k = 1; a[i] && a[i] * k <= maxa; ++k)
			ans[a[i]] += cnt[a[i] * k] - (k == 1);
	}
	ll Ans = 0;
	FOR(i, 1, n)
		Ans += ans[a[i]];
	printf("%lld\n", Ans);
	return 0;
}
```


---

## 作者：huayucaiji (赞：3)

## 前言

~~省选撞题不是第一次了~~

~~居然还撞这么水的~~

场外选手来胡一波题解。

## 解法

我一开始搞了个暴力，是这样做的。

我们发现 $a_i$ 的范围很小，可以搞一个桶 $tot$。

离散化之后枚举每个数的所有倍数，累加计数。对于相同的数字，可以用 $tot_i\cdot(tot_i-1)$ 计算，累加到 $ans$ 上输出即可。

没想到过了qwq。

仔细一想确实是对的。

我们令 $ma=\max\limits_{i=1}^n a_i$，$m$ 为离散化后的数的个数。

那么时间复杂度为 $O(\sum\limits_{i=1}^m \frac{ma}{a_i})$。按照数据范围，你构造极限数据，满打满算就是 $O(6288448)$。随便加常数也都过了。

极限数据附下
```plain
200000
1 2 3...199997 199998 199999 500000
```

## 代码

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long//想不到吧，我开了long long。/cy
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=5e5+10;

int n,m,ma,ans;
int a[MAXN],tot[MAXN];
//聪明的同学可能会问了。
//你没开 long long 怎么过的？
//是洛谷数据太水了吗？
//达咩达咩~
//我开了！
//只有聪明的人看得到我开了 long long。

signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		a[i]=read();
		ma=max(ma,a[i]);
		tot[a[i]]++;
	}
	
	sort(a+1,a+n+1);
	m=unique(a+1,a+n+1)-a-1;
    //离散化

	for(int i=1;i<=m;i++) {
		for(int j=a[i]*2;j<=ma;j+=a[i]) {
            //一倍的a[i]直接算，从2*a[i]开始循环
			ans+=tot[j]*tot[a[i]];
		}
		ans+=tot[a[i]]*(tot[a[i]]-1);
	}
	
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：MSqwq (赞：3)

这题好像还是原题......   
算法：暴暴暴力   
一个暴力筛统计一下...没了...相同的数是$c_i \times(c_i-1)$  
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
int n;
ll a[500010],x;
ll ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&x);
		a[x]++;
	}
	for(int i=1;i<=500000;i++)
	{
		ans+=a[i]*(a[i]-1);
		for(int j=i+i;j<=500000;j+=i)ans+=a[i]*a[j];
	}
	printf("%d",ans);
}

```


---

## 作者：phigy (赞：3)

类似于桶排用 $t_i$ 表示 $a$ 中有几个 $i$ 。

那么对于每一个数值 $i$ 枚举其倍数 $i \times j$ 。

贡献对数为 $t_i \times t_{i\times j}$ 。

注意： 当 $j=1$ 时 ， 贡献对数为 $t_i \times (t_i-1)$ 。

复杂度即是 $O(\sum_{i=1}^{\max a_i}\dfrac{\max a_i}{i})$ 。

就等于 $O(\max a_i \log \max a_i)$ 。

```cpp
#include <iostream>
#include <algorithm>
#include <map>

using namespace std;

int n;
int a[5000005];

int main()
{
    int i,j,k;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        a[x]++;
    }
    long long ans=0;
    for(i=1;i<=500000;i++)
    {
        for(j=2;i*j<=500000;j++)
        {
            ans+=a[i]*a[i*j];
        }
        ans+=a[i]*(a[i]-1);
    }
    cout<<ans;
    return 0;
}
```

推荐类似题目：https://uoj.ac/problem/21 。

---

## 作者：Hexarhy (赞：2)

### Preface

套路题，很显然很简单的套路题。

### Solution

观察到值域很小，又是求倍数，不难想到开桶统计 $a_i$，直接枚举 $a_i$ 的倍数。

记 $t_{a_i}$ 为 $a_i$ 出现次数。对 $a_i$ 排序，去重，然后枚举它的倍数 $k=j\times a_i,j\in \mathbb Z$。如果桶里有 $k$，那么答案就增加 $t_{k}\times t_{a_i}$。

看似暴力，但这显然是调和级数，时间复杂度是 $O(n\log n)$。

需要注意，统计答案时别忘了 $i\neq j,a_i=a_j$ 时，$(a_i,a_j),(a_j,a_i)$ 这**两对**都是合法的。因此这部分答案增加 $P_{t_{a_i}}^2=t_{a_i}\times(t_{a_i}-1)$。

### Notice

如果有，请注意使用 `unique()` 前必须要 `sort()`，并更新元素数目。

### Code

```cpp
int main()
{
	read(n);cint N=n;
	for(int i=1;i<=n;i++)	read(a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)	cnt[a[i]]++;
	n=unique(a+1,a+1+N)-a-1;
	for(int i=1;i<=n;i++)
		for(int j=a[i];j<=a[n];j+=a[i])
			if(cnt[j])
			{
				if(j!=a[i])	ans+=1ll*cnt[a[i]]*cnt[j];
				else	ans+=1ll*cnt[j]*(cnt[j]-1);
			}
	cout<<ans<<endl; 
	return 0;
}
```

---

## 作者：HSY666 (赞：1)

这道题关注数据范围，$a_i\leq 5\times 10^5$，我们可以想到用桶，题目让我们求互为倍数的数对的个数，显然我们可以用桶去存每个数出现的次数，然后枚举它们的倍数，我们设$a_i$为$i$这个数字出现的次数，$Max$为输入的这串数的最大值，然后从 $1$ 到 $Max$ 枚举 $i$，如果 $a_i> 0$，那么我们枚举 $a_i$ 的倍数 $i,2i,3i...$，显然它们对答案的贡献为 $a_i\times (a_i-1),a_i\times a_{2i},a_i\times a_{3i}...$，注意对于 $i$，因为题目说两个数下标不能相等，所以是 $a_i\times (a_i-1)$。


特别的，对于 $i= 1$ 的情况，枚举它的倍数显然很慢，但是我们可以发现所有数都是 $1$ 的倍数，因此若 $i= 1$ 且 $a_i> 0$，那么 $i= 1$ 时对答案的贡献为 $a_i\times (n-1)$，这里 $n$ 是输入的这串数的个数。


注意，答案 `ans` 要开到 `long long` 范围。


上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int n,a,maxn;
long long ans,t[500005];

int main ()
{
//	freopen ("pair.in","r",stdin);
//	freopen ("pair.out","w",stdout);
	scanf ("%d",&n);
	for (int i=1;i<=n;++i)
	{
		scanf ("%d",&a);
		++t[a];
		maxn=max(maxn,a);
	}
	for (int i=1;i<=maxn;++i)
	{
		if (t[(int)i])
		{
			if (i==1)  ans+=(t[i]*(n-1));
			else
			{
				long long x=(long long)i*2;
				ans+=(t[i]*(t[i]-1));
				while (x<=maxn)
				{
					ans+=(t[i]*t[x]);
					x+=(long long)i;
				}
			}
		}
	}
	printf ("%lld\n",ans);
	return 0;
}
```


---

## 作者：feicheng (赞：1)

## Preface

考场心路历程：第一眼看到题以为是 GOSICK。

结果发现是个全局询问，顿时就没难度了。

## Descrpition

给定长度为 $n$ 的序列 $a$，求满足 $a_i = k\times a_j(k\in N_+,i\not = j)$ 的二元组 $(i,j)$ 有多少个。

**restrictions**：$1 \le n \le 2\times 10^5,1\le a_i\le5\times 10^5$

## Solution

我的做法是根号的（那会想到了根号想来应该能过就没写 polylog 的）。

具体来说，就是对于每一个 $a_i$ ，开一个桶统计其贡献。

它的贡献就是：对于所有 $a_i$，枚举其因数，给因数的 `sum` $+1$，

最后将贡献累计起来即可。

最后特判一下 $1$ 即可。

时间复杂度 $\Theta(n\sqrt{\max a_i})$。

## Code 

考场代码：

```cpp
#include <bits/stdc++.h>
typedef long long ll ;
typedef unsigned long long u64 ;
namespace hpy {
	const int HL = 1 << 20 ;

	char buf[HL],buff[HL],*t1 = buf,*t2 = buf,*T = buff ;

	inline char getc() {
		return t1 == t2 && (t2 =(t1 = buf)+fread(buf,1,HL,stdin),t1 == t2) ? EOF : *t1 ++ ;
	}

	inline void flush() {
		fwrite(buff,1,T-buff,stdout),T = buff;
	}

	inline void putc(const char ch) {
		if(T == buff + HL) flush() ;
		*T ++ = ch ;
	}

	struct Read {
		template <typename Tp>
		inline Read& operator >> (Tp &x) {
			char ch = getc();
			int f = 0;
			for(;!isdigit(ch);ch = getc()) f = (ch == '-') ? 1 : 0 ;
			x = 0;
			for(;isdigit(ch);ch = getc()) x = (x<<3) + (x<<1) + (ch^48) ;
			return x = f ? -x : x,*this ;
		}

		inline Read& operator >> (char &ch) {
			ch = getc() ;
			while(ch == ' ' || ch == '\n') ch = getc() ;
			return *this ;
		}

		inline Read& operator >> (char *str) {
			int len = 0 ;
			char ch = getc() ;
			while(ch == ' ' || ch == '\n') ch = getc() ;
			while(ch != ' ' && ch != '\n' && ch != '\r' && ch != EOF) str[len++] = ch,ch = getc() ;
			return *this ;
		}
		Read() {}
	} hin;

	struct Write {
		template <typename Tp>
		inline Write& operator << (Tp x) {
			if (!x) return putc('0'),*this ;
			if(x < 0) x = -x,putc('-') ;
			int stk[20],top = 0;
			while(x) stk[++top] = x%10,x/=10;
			while(top) putc(stk[top--] + '0') ;
			return *this;
 		}

 		inline Write& operator << (char ch) {
 			return putc(ch),*this ;
		}

		inline Write& operator << (char *str) {
			int len = 0 ;
			while(str[len]) putc(str[len++]) ;
			return *this ;
		}

		inline Write& operator << (const char *str) {
			int len = 0 ;
			while(str[len]) putc(str[len++]) ;
			return *this ;
		}
	} hout;

	inline int ksm(int x,int y,int p) {
		int res = 1;
		for(;y;y >>= 1,x = 1ll*x*x % p) if(y&1) res = 1ll*res*x%p;
		return res ;
	}
}
using hpy::hin ;
using hpy::hout ;
using hpy::ksm ;
using std::max ;  

const int N = 2e5 + 10;
const int M = 5e5 + 10;


int a[N];
ll sum[M],tim[M];
int n,mx ;

inline void file() {
	freopen("pair.in","r",stdin) ;
	freopen("pair.out","w",stdout) ;
}

int main() {
	file();
	hin >> n ;
	ll ans = 0 ;
	for(int i = 1;i <= n;++i) hin >> a[i],mx = max(mx,a[i]),++tim[a[i]];
	for(int i = 1;i <= n;++i) {
		if(a[i] == 1) {
			ans += n - 1; // 1 能对所有数产生贡献
			continue ;
		}
		for(int j = 2;j <= sqrt(a[i]);++j) {
			if(a[i]%j == 0) {
				++sum[j] ;
				if(a[i] != j*j) ++sum[a[i]/j] ;
			}
		}	
	} 
	for(int i = 1;i <= n;++i) ans += sum[a[i]];
	for(int i = 1;i <= n;++i) ans += a[i] == 1? 0 : tim[a[i]]  - 1 ;//特判，这里统计的是一倍之间的贡献，由于 1 已经被统计了所以去除掉 
	hout << ans ; 
	return hpy::flush(),0;
}
//lyy,cz,smh,yhy ak SNOI
//lyy tql
//cz tql
//yhy tql
//smh tql
```

---


# 神秘大三角

## 题目描述

判断一个点与已知三角形的位置关系。


## 说明/提示

### 数据规模与约定

对于 $100\%$ 数据，$0\le x_i,y_i\le 100$。

 

## 样例 #1

### 输入

```
(0,0)
(3,0)
(0,3)
(1,1)
```

### 输出

```
1
```

# 题解

## 作者：AuCloud (赞：20)

[题面](https://www.luogu.org/problemnew/show/P1355)

~~我太弱了~~

来讲讲我是怎么想的

题意很好理解，不多啰嗦

------------


### 顶点

顶点肥肠简单~~(对于我来说)~~

直接判断是否重合(x1=x2且y1=y2)

```cpp
if(xx==x1&&yy==y1 || xx==x2&&yy==y2 || xx==x3&&yy==y3)
{
	cout<<'4';
	return 0; 
}
```

------------

### 边

**(划重点)**

首先看看图↓

![画画技术嘛……不要在意那些细节](https://cdn.luogu.com.cn/upload/pic/48297.png)

我们可以把AB，AC，BC延长成直线

如图↓

![延长……](https://cdn.luogu.com.cn/upload/pic/48299.png)

然后……

#### 求AB、AC、BC的一次函数解析式，并判断是否在直线上且在两点之间

至于公式嘛。。。

~~自己推去~~

**k1=(y1-y2)/(x1-x2)**

**b1=y1-k1·x1**

### 但是注意！

如果x1=x2的话(就是一条垂直于X轴的直线)

会RE。。。

所以要特判的
```cpp

double k1,b1;
if(x1==x2)//特判 
{
	k1=b1=-888888;//(洛谷保佑我AC叭)
	if(x1==xx&&(yy>y2&&yy<y1||yy<y2&&yy>y1))
	{
		cout<<'3';
		return 0;
	} 
}
else 
{
	k1=(y1-y2)/(x1-x2);
	b1=y1-k1*x1;
}
	
```
酱紫


------------
### 三角形外(内)

(仍然是个重点)

(这个点卡了好久)

继续画图↓

![](https://cdn.luogu.com.cn/upload/pic/48305.png)

D1 在外，D2 在内

观察力好一点的盆友们应该能看出来

![](https://cdn.luogu.com.cn/upload/pic/48306.png)

我们可以利用这个性质，判断D在内在外啦~~~

然而！问题来了

### 怎么算面积呢？？？

当然是我们的[海伦公式](https://baike.baidu.com/item/%E4%B8%89%E6%96%9C%E6%B1%82%E7%A7%AF%E6%9C%AF/8830085?fr=aladdin)啦

像酱紫
```cpp
double si(int a,int b,int c,int d,int e,int f)
{
	double hehe,ab,ac,bc;
	ab=sqrt((a-c)*(a-c)+(b-d)*(b-d));//勾股定理求两点之间距离 
	ac=sqrt((a-e)*(a-e)+(b-f)*(b-f));//同上 
	bc=sqrt((x-e)*(x-e)+(d-f)*(d-f));//同上 
	hehe=(ab+ac+bc)/2;
	return sqrt(hehe*(hehe-ab)*(hehe-ac)*(hehe-bc));//海伦公式 
}
```
(链：[例题](http://noi.openjudge.cn/ch0103/17/))

```cpp
double S_abc,S_acd,S_abd,S_bcd;//四个三角形，一大三小 
S_abc=si(x1,y1,x2,y2,x3,y3);
S_acd=si(x1,y1,x3,y3,xx,yy);
S_abd=si(x1,y1,x2,y2,xx,yy);
S_bcd=si(x2,y2,x3,y3,xx,yy);
```
求出面积后，就可以愉快地AC啦

------------
最后，奉上代码
```cpp
#include<iostream>
#include<cmath>
using namespace std;
double si(int a,int b,int x,int y,int n,int m)
{
	double hehe,ab,ac,bc;
	ab=sqrt((a-x)*(a-x)+(b-y)*(b-y));//勾股定理求两点之间距离 
	ac=sqrt((a-n)*(a-n)+(b-m)*(b-m));//同上 
	bc=sqrt((x-n)*(x-n)+(y-m)*(y-m));//同上 
	hehe=(ab+ac+bc)/2;
	return sqrt(hehe*(hehe-ab)*(hehe-ac)*(hehe-bc));//海伦公式 
}
int main()
{
	int x1,x2,x3,y1,y2,y3,xx,yy;
	char ch;//格式控制用 
	cin>>ch>>x1>>ch>>y1>>ch;//第一个点 
	cin>>ch>>x2>>ch>>y2>>ch;//第二个点 
	cin>>ch>>x3>>ch>>y3>>ch;//第三个点 
	cin>>ch>>xx>>ch>>yy>>ch;//问题点 
	
	if(xx==x1&&yy==y1 || xx==x2&&yy==y2 || xx==x3&&yy==y3)//直接判断顶点 
	{
		cout<<'4';
		return 0; 
	}
	
	double k1,b1;//1-2
	if(x1==x2)//防止除以零 
	{
		k1=b1=-888888;
		if(x1==xx&&(yy>y2&&yy<y1||yy<y2&&yy>y1))
		{
			cout<<'3';
			return 0;
		} 
	}
	else 
	{
		k1=(y1-y2)/(x1-x2);
		b1=y1-k1*x1;
	}
	double k2,b2;//1-3
	if(x1==x3)
	{
		k2=b2=-888888;
		if(x1==xx&&(yy>y3&&yy<y1||yy<y3&&yy>y1))
		{
			cout<<'3';
			return 0;
		}
	}
	else
	{
		k2=(y1-y3)/(x1-x3);
		b2=y3-k2*x3;
	}
	double k3,b3;//2-3
	if(x3==x2)
	{
		k3=b3=-888888;
		if(x3==xx&&(yy>y2&&yy<y3||yy<y2&&yy>y3))
		{
			cout<<'3';
			return 0;
		}
	}
	else
	{
		k3=(y3-y2)/(x3-x2);
		b3=y2-k3*x2;
	}
	
	if(yy==xx*k1+b1&&(xx<x1&&xx>x2||xx>x1&&xx<x2) || yy==xx*k2+b2&&(xx<x1&&xx>x3||xx>x1&&xx<x3) || yy==xx*k3+b3&&(xx<x3&&xx>x2||xx>x3&&xx<x2))
	{
		cout<<'3';
		return 0;
	}
	
	double S_abc,S_acd,S_abd,S_bcd;//四个三角形，一大三小 
	S_abc=si(x1,y1,x2,y2,x3,y3);
	S_acd=si(x1,y1,x3,y3,xx,yy);
	S_abd=si(x1,y1,x2,y2,xx,yy);
	S_bcd=si(x2,y2,x3,y3,xx,yy);
	if(S_acd+S_abd+S_bcd>S_abc)
	{
		cout<<'2';
		return 0;
	}
	
	cout<<'1';
	return 0;
}
```
(这是第一次这么~~认真~~地写题解，望通过)

---

## 作者：B_Qu1e7 (赞：14)

~~懒的写叉积（众：明明是你不会写，OK？）~~

精度问题非常奇怪

一开始我没加\*100的时候莫名其妙：1.5+1.5+1.5!=4.5？

后来某zrz打了100位才看到，原来海伦公式出来1.5+1.5+1.5会等于4.4999999820000000……

所以只要乘100就可以破精度问题了

至于2和1的判定，思路是这样的：

```cpp
设该点为D。
则连接AD BD CD
则当△ABD+△ACD+△BCD=△ABC时，D在三角形ABC内。
否则，D在三角形ABC外。
请OIers自行实验
```

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int s,t,u,v,w,x,y,z;
char ch;
double m(int a,int b,int c,int d,int e,int f)//海伦公式算三角形面积
{
    double x,y,z,p;
    x=sqrt((a-c)*(a-c)+(b-d)*(b-d));
    y=sqrt((a-e)*(a-e)+(b-f)*(b-f));
    z=sqrt((c-e)*(c-e)+(d-f)*(d-f));
    p=(x+y+z)/2;
    return sqrt(p*(p-x)*(p-y)*(p-z));
}
int main()
{
    cin>>ch>>s>>ch>>t>>ch;//点A
    cin>>ch>>u>>ch>>v>>ch;//点B
    cin>>ch>>w>>ch>>x>>ch;//点C
    cin>>ch>>y>>ch>>z>>ch;//点D
    double abc,abd,acd,bcd;//几个三角形的面积
    abc=(int)m(s,t,u,v,w,x)*100,abd=(int)m(s,t,u,v,y,z)*100,acd=(int)m(s,t,w,x,y,z)*100,bcd=(int)m(u,v,w,x,y,z)*100;//吐槽本题精度问题= =
    if((s==y&&t==z)||(u==y&&v==z)||(w==y&&x==z))
    {
        cout<<4;    //4
        return 0;
    }
    if(abd+acd+bcd>abc)
    {
        cout<<2;    //2
        return 0;
    }
    else
    {
        if(!abc||!abd||!acd||!bcd)
        {
            cout<<3;    //判断3
            return 0;
        }
        cout<<1;//1
    }
}
```

---

## 作者：ElizabethJay (赞：11)

简单的差叉积应用————
在内，在外比较好判断
 即顺时针或逆时针求一遍叉积，所有结果的都大于0或都小于0，则点在三角形内部，如果既有大于0又有小于0的在外部 
 然后判断在边界上的，这种情况是有有一个叉积为0，剩下的就是在定点的情况。
 读入则用一下scanf函数的性质可解决！
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct point
{
    int x,y;
    point (){}
    point (int a,int b):x(a),y(b){}
    point operator +(const point &a)const
    {
        return point(x+a.x,y+a.y);
    }
    point operator -(const point &a)const
    {
        return point(x-a.x,y-a.y);
    }
    int operator ^(const point &a)
    {
        return x*a.y-y*a.x;
    }
}p[3],o;


int main()
{
    int f,z;
    f=z=0;
    for(int i=0;i<3;i++)
        scanf(" (%d,%d)",&p[i].x,&p[i].y);
    scanf(" (%d,%d)",&o.x,&o.y);
    for(int i=0;i<3;i++)
    {
        int mid=(o-p[i])^(o-p[(i+1)%3]);
        if(mid>0)z++;
        else if(mid<0)f++;
    }
    if(z==3||f==3)
        puts("1");
    else if(z>0&&f>0)
        puts("2");
    else if(z+f==1)
        puts("4");
    else puts("3");
    return 0;
}


```

---

## 作者：nao_nao (赞：7)

 >谨以此篇题解纪念我第一次学习计算几何
 
 #### 题意：
 题目已经很简短了，就是给你一个三角形和一个点，要求判断这个点在三角形的边上，点上，内部，还是外部。
 
 #### 题解：
 
 首先，我们可以轻松的想到如何判断是否与点重合，这个很简单的直接判断即可。
 
 然后我们想如何判断内部和外部，我们想到向量的叉积可以得到两个向量之间的有向面积，我们还知道向量叉积可以求出多边形的面积（就是把有向面积加一起啦），思考求多边形面积的原理，可以想到通过判断有向面积的正负来判断点是否在三角形内。
 
 我们发现，如果点在三角形边上，那么一定会有某一个向量叉积答案为 $0$ ，我们可以通过判断向量叉积是否为零来判断是否有点在边上。
 
注意：
 
 1. 我们知道，当向量夹角小于0的时候，叉积是负的。因此当所有的有向面积同正或同负时，点都在三角形内部。
 
 2. 其实，如果点在边的同一直线上时，叉积也为零，我们可以通过点到线段两边的端点的两个向量是否同向来判断是否在线段上，这可以用向量的点积来判断。
 
code：
 
 ```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

int qread() {
	int a = 0,x = 1;
	char ch = getchar();
	while(ch > '9' || ch < '0') {
		if(ch == '-') x  = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		a = a*10 + ch-'0';
		ch = getchar();
	}
	return a*x;
}

struct Cvector {
#define Cpoint Cvector
	int x,y;
	void read() {
		x = qread(),y = qread();
	}
	friend int operator ^ (Cvector a,Cvector b) {
		return a.x*b.y-a.y*b.x;
	}
	friend Cvector operator - (Cpoint a,Cpoint b) {
		return (Cvector) {
			a.x-b.x,a.y-b.y
		};
	}
	friend bool operator == (Cvector a,Cvector b) {
		return (a.x==b.x)&&(a.y==b.y);
	}
	friend int operator *(Cvector a,Cvector b) {
		return a.x*b.x+a.y*b.y;
	}
};

int f(Cvector a,Cvector b,Cvector x) {
	return (a-x)^(b-x);
}

int main() {
	Cvector a,b,c,x;
	a.read(),b.read(),c.read(),x.read();//使用快读来读入，忽略符号 
	if(a == x|| b == x || c == x) {//判断是否在三角形顶点上 
		printf("4");
		return 0;
	}
	int sum = 0;
	if(f(a,b,x) < 0) {//判断叉积正负性 
		sum ++;//并记录 
	} else if(f(a,b,x) == 0) {//判断叉积是否为零 
		if((x-b)*(x-a) < 0) {//判断是否在线段上
		//向量点积为负，则说明方向相反，在线段上 
			printf("3");
			return 0;
		}
	}
	if(f(b,c,x) < 0) {//三条边都要判断 
		sum ++;
	} else if(f(b,c,x) == 0) {
		if((x-b)*(x-c) < 0) {
			printf("3");
			return 0;
		}
	}
	if(f(c,a,x) < 0) {//同上 
		sum ++;
	} else if(f(c,a,x) == 0) {
		if((x-a)*(x-c) < 0) {
			printf("3");
			return 0;
		}
	}
	if(sum == 0 || sum == 3)printf("1");//看如果叉积同正或同负，则在三角形内部 
	else printf("2");//否则在外部 
	return 0;
}
```

---

## 作者：HOOCCOOH (赞：5)

基础计算几何，可以练习一下叉积

对于△ABC和点P

判点在点上：直接判相等就是了。

判点在边上：向量AB×向量BP=0，且x\_p∈[min(x\_a,x\_b),max(x\_a,x\_b)]，y同理，则P在AB上

判点在三角形内：先得出三角形重心H，横纵坐标为ABC的平均值，一定在三角形内。若P和H在AB,BC,AC同侧，则P在三角形内。若向量AB×向量BP与向量AB×向量BH同号，则H,P在AB同侧。

其它情况就是在三角形外了。

代码如下（防止重心坐标不能被整除，把输入的坐标都乘上3，不影响判定）

```cpp

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cctype>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

int iRead()
{
    int ret = 0, ch;
    while(!isdigit(ch = getchar()) && ch != '-');
    bool bm = (ch == '-'); if(bm) ch = getchar();
    while(ret = ret * 10 + (ch - '0'), isdigit(ch = getchar()));
    return bm ? -ret : ret;
}

struct iP
{
    int x, y;
    bool operator==(const iP &r) const {return x == r.x && y == r.y;}
    iP operator-(const iP &r) const {return (iP){x - r.x, y - r.y};}
}a, b, c, p;

int iCross(const iP &a, const iP &b)
{
    return a.x * b.y - a.y * b.x;
}

bool iInl(const iP &p, const iP &l, const iP &r)
{
    return 
        p.x >= min(l.x, r.x) && p.x <= max(l.x, r.x) &&
        p.y >= min(l.y, r.y) && p.y <= max(l.y, r.y) &&
        iCross(r - l, p - r) == 0;
}

bool iSame(const iP &p, const iP &q, const iP &l, const iP &r)
{
    return (iCross(r - l, p - r) ^ iCross(r - l, q - r)) >= 0;
}

int main()
{
    a.x = iRead() * 3, a.y = iRead() * 3;
    b.x = iRead() * 3, b.y = iRead() * 3;
    c.x = iRead() * 3, c.y = iRead() * 3;
    p.x = iRead() * 3, p.y = iRead() * 3;
    iP h = {(a.x + b.x + c.x) / 3, (a.y + b.y + c.y) / 3};
    
    if(p == a || p == b || p == c)
        puts("4");
    else if(iInl(p, a, b) || iInl(p, b, c) || iInl(p, c, a))
        puts("3");
    else if(iSame(p, h, a, b) && iSame(p, h, b, c) && iSame(p, h, c, a))
        puts("1");
    else
        puts("2");
    
    return 0;
}

```

---

## 作者：Drifterming (赞：3)

```
//Pro: P1355 神秘大三角
//Strategy: cross product

//叉积判断点与三角形的位置关系，精度高 
//若点在三角形内（不含边界），输出1；
//若点在三角形外（不含边界），输出2；
//若点在三角形边界上（不含顶点），输出3；
//若点在三角形顶点上，输出4。

//设三角形三个顶点是A,B,C，要判断的点是P 
//由于输入的是整数，所以就比较容易了，不用担心精度问题。 

//点：判断在不在点上直接判就好了
//边：如果P在三角形的边所在直线上，那么P与边的端点构成的向量的叉积==0，如果P的坐标还在端点之间，那就在线段上了
//内外：将每条边看成是一个向量，那么可以有三条不同终点的向量
//在这儿规定这三个向量是AB,BC,CA,那么P指向这三个向量的终点，也可以对应得到三个向量PA,PB,PC
//如果对应的向量的叉积(如AB*PA)的值里有任意一个是负的，那么P就在三角形外，
//否则若都是正的，就在三角形内

//(因为懒得画图，所以叉积这个东西还是看博客比较好) 

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

struct Point	//存点 
{
	int x,y;
	Point(int x=0,int y=0){this->x=x,this->y=y;}
	Point operator + (const Point &a)
	{
		return Point(this->x+a.x,this->y+a.y);
	}
	Point operator - (const Point &a)
	{
		return Point(this->x-a.x,this->y-a.y);
	}
	int operator * (const Point &a)
	{
		return this->x*a.y-this->y*a.x;
	}
}A,B,C,P;

bool On_Point()		//在端点上 
{
	if(P.x-A.x==0&&P.y-A.y==0)
		return true;
	if(P.x-B.x==0&&P.y-B.y==0)
		return true;
	if(P.x-C.x==0&&P.y-C.y==0)
		return true;
	return false;
}

bool On_Edge()		//在边上 
{
	if((P-A)*(P-B)==0&&min(A.x,B.x)<=P.x&&min(A.y,B.y)<=P.y&&max(A.x,B.x)>=P.x&&max(A.y,B.y)>=P.y)
		return true;
	if((P-B)*(P-C)==0&&min(B.x,C.x)<=P.x&&min(B.y,C.y)<=P.y&&max(B.x,C.x)>=P.x&&max(B.y,C.y)>=P.y)
		return true;
	if((P-A)*(P-C)==0&&min(A.x,C.x)<=P.x&&min(A.y,C.y)<=P.y&&max(A.x,C.x)>=P.x&&max(A.y,C.y)>=P.y)
		return true;
	return false;
}

bool inside()	//在不在三角形内 
{
	if((B-A)*(P-A)<0)
		return false;
	if((C-B)*(P-B)<0)
		return false;
	if((A-C)*(P-C)<0)
		return false;
	return true;
}

char c;
int main()
{
	scanf("%*c%d%*c%d%*c",&A.x,&A.y);
	getchar();getchar();
	scanf("%*c%d%*c%d%*c",&B.x,&B.y);
	getchar();getchar();
	scanf("%*c%d%*c%d%*c",&C.x,&C.y);
	getchar();getchar();
	scanf("%*c%d%*c%d%*c",&P.x,&P.y);
	if((B-A)*(C-A)<0)	//重构三角形的顶点，让三角形当A在上时，B左C右 
		swap(A,B);
	if(On_Point())
		puts("4");
	else if(On_Edge())
		puts("3");
	else if(!inside())
		puts("2");
	else
		puts("1");
	return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：2)

此篇题解为拓展做法。

## 光线投射算法

这个在 [Oi-wiki](https://oi-wiki.org/geometry/2d/) 上提到过，下面来说一下基本的思想。

我们可以先判断一些特殊情况，考虑一个能够完全覆盖此多边形的一个最小矩形，如果这个点不在这个矩形范围内，那么这个点一定不在多边形内。这样的矩形很好求，只需要知道多边形横坐标与纵坐标的最小值和最大值，坐标两两组合成四个点，就是这个矩形的四个顶点了。

在多边形边和点上时，对于点我们可以直接枚举判断，对于边，我们可以用斜率加起始的 $x$ 坐标结合来判断。

我们考虑以该点为端点引出一条射线，如果这条射线与多边形有 奇数个交点，则该点在多边形内部，否则在该多边形外部，我们简记为**奇内偶外**。这个算法同样被称为奇偶规则。

![](https://img2023.cnblogs.com/blog/2970702/202305/2970702-20230530204207963-991342799.png)

我们看上面的图，其中 $K,H$ 分别为在多边形外和多边形内的两点，我们对于上面的算法来寻找个例。

例如射线 $KL$，我们对于经过边的情况计算的交点个数没有明确的定义，所以我们在挑选射线时需要舍去会和边重合的情况。

我们发现，射线 $KM$ 与多边形的交点为三个，但是 $K$ 实际上是在多边形外部。

同样的，我们可以看到射线 $HJ$ 与多变形的交点为两个，但 $H$ 实际上在多边形内部。

所以我们也要挑选没有经过点的射线。

当然可能经过了点也是正确的答案，比如上面如果作射线 $KF$ 的话我们得到的就是正确的结论，但我们并不可能在代码中加入更多繁琐的代码来判断这个，毕竟没有经过点和没有和边共线的情况多了去了。

再来结合本题，我们发现是三角形，我们考虑到对于点的判断是没有意义的，因为三角形是凸多边形。

整理一下思路：

1. 先枚举点，判断是否在点上。

2. 然后枚举每一条边两个端点算斜率判断是否在边上。

3. 然后找随便一条边的中点作为射线的另一个点，计算射线斜率并与三条直线进行求解 $x$，代回检验 $y$ 是否合法，同时注意我们是射线不是直线，所以要根据射线朝左还是朝右来进行判断算出来的 $x$ 是不是在合法的范围内还有就是我们三角形的是线段，需要判断是否在线段内部。

还有一个细节就是，当求解析式时的两点如果横坐标相同需要特殊处理，因为除数是 $0$ 会出问题。

code：

```cpp

#include<bits/stdc++.h>
#define int long long
#define DB double
#define N 1000100
using namespace std;
string s[10];
int ans,flag;
struct sb{int x,y;}e[10];
inline int cmp(sb a,sb b){if(a.x==b.x)return a.y<b.y;return a.x<b.x;}
inline void zhuan(string s,int i)
{
	int p=1,o=1;
	while(s[p]>='0'&&s[p]<='9')e[i].x=e[i].x*o+s[p]-'0',o*=10,p++;
	p++,o=1;
	while(s[p]>='0'&&s[p]<='9')e[i].y=e[i].y*o+s[p]-'0',o*=10,p++;
}
signed main()
{
	srand(time(0));
	for(int i=1;i<=4;i++)cin>>s[i],zhuan(s[i],i);//将输入的数据转化为字符 
	sort(e+1,e+4,cmp);//按x从小到大处理，方便后面的解析式处理 
	for(int i=1;i<=4;i++)//似乎可以防止精度问题，但也可以用long double 
	{
		e[i].x*=100000000;
		e[i].y*=100000000;
	}
	for(int i=1;i<=3;i++)if(e[4].x==e[i].x&&e[4].y==e[i].y){cout<<"4"<<endl;return 0;}//枚举每一个顶点判断4情况 
	for(int i=1;i<=3;i++)//枚举判断解析式 3情况 
	{
		for(int j=i+1;j<=3;j++)
		{
			if(e[i].x==e[j].x)//横坐标相等，特判 
			{
				if(e[4].x==e[i].x&&(e[4].y<=max(e[i].y,e[j].y)&&e[4].y>=min(e[i].y,e[j].y)))//判断坐标是否合法 
				{
					cout<<"3"<<endl;
					return 0;
				}
				else continue;
			}
			DB k=((DB)(e[i].y-e[j].y))/((DB)(e[i].x-e[j].x));//计算两个点的解析式 
			DB b=(DB)e[i].y-(DB)k*e[i].x;
			if(abs((DB)e[4].y-(DB)e[4].x*k+b)<1e-9&&e[4].x>=min(e[i].x,e[j].x)&&e[4].x<=max(e[i].x,e[j].x))
			{//判断是不是在直线上，以及横坐标是不是在范围内 
				cout<<"3"<<endl;
				return 0;
			}
		}
	}
	DB xx,yy;//随机挑选的任意一边上的点 
	if(e[1].x==e[2].x)//如果横坐标相同 
	{
		xx=(DB)e[1].x;//直接中点 
		yy=(DB)(e[1].y+e[2].y)/2;
	}
	else//一般情况 
	{
		DB k=((DB)(e[1].y-e[2].y))/((DB)(e[1].x-e[2].x));//求两点组成的解析式 
		DB b=(DB)e[1].y-(DB)k*e[1].x;
		xx=(DB)(e[1].x+e[2].x)/2;//横坐标中点 
		yy=(DB)k*xx+b;//计算纵坐标 
	}
	DB kk,bb;//与题目给定点的解析式 
	if(xx==e[4].x)xx+=0.001;//加一个小的值，降低精度影响 
	if(xx>e[4].x)//射线朝右 
	{
		kk=((DB)(yy-e[4].y))/((DB)(xx-e[4].x));
		bb=(DB)yy-(DB)kk*xx;
		flag=1;//标记朝右 
	}
	else//射线朝左 
	{//默认朝左 
		kk=((DB)(e[4].y-yy))/((DB)(e[4].x-xx));
		bb=(DB)e[4].y-(DB)kk*e[4].x;
	}
	for(int i=1;i<3;i++)//枚举判断解析式 
	{
		for(int j=i+1;j<=3;j++)
		{
			if(i==1&&j==2){ans++;continue;}//第一个肯定有交点，不用算了 
			int c1=min(e[i].y,e[j].y);//后面判断合法需要 
			int c2=max(e[i].y,e[j].y);
			int o1=min(e[i].x,e[j].x);
			int o2=max(e[i].x,e[j].x);
			if(e[i].x==e[j].x)//横坐标相等 
			{
				DB yyy=(DB)kk*e[i].x+bb;//计算纵坐标 
				if(((e[i].x>(DB)e[4].x&&flag==1)||(e[i].x<(DB)e[4].x&&flag==0))&&yyy<=(DB)c2&&yyy>=(DB)c1)ans++;
				continue;//如果射线朝左，那么必须要大于给定点，反之必须小于 
			}
			DB k=((DB)(e[i].y-e[j].y))/((DB)(e[i].x-e[j].x));
			DB b=(DB)e[i].y-(DB)k*e[i].x;
			if(k==kk&&b==bb)continue;//平行的特判 
			DB cao=((bb-b)/(k-kk));//解得x的值 
			DB wc=cao*kk+bb;//求出y的值 
			if(((cao>(DB)e[4].x&&flag==1)||(cao<(DB)e[4].x&&flag==0))&&wc<=(DB)c2&&wc>=(DB)c1&&(cao>(DB)o1)&&(cao<(DB)o2))ans++;
		}//射线的判断同上，后面需要判断是否在线段上 
	}
	if(ans&1)cout<<"1"<<endl;//奇数输出1，在里面 
	else cout<<"2"<<endl;//偶数输出2 ，在外面 
	return 0;
}
```

这还只是三角形，我不敢想象 $n$ 边形的代码量~~当然可能是我菜所以代码量大~~。



---

## 作者：abc_de (赞：2)

# 数学
其实这道题还好，只需要各种判断就可以了，但最需要注意的一点就是，精度问题，如果不乘一百的话，最后算出来的结果可能会出错，反正乘上一百也不伤大雅，还有一点就是海伦公式的运用，知三边求面积，这是常用的一个公式，希望大家能记住。

------------
主要思路：把三个顶点和输入的这个点连接，算它的面积，具体情况看代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;//每个点的坐标
int c,d;
int e,f;
int x,y;
char alg;//不用在意alg是什么，只是一个符号而已
double hl(int a,int b,int c,int d,int e,int f)//海伦公式求面积，要是感兴趣的可以自行去搜搜推导过程，挺简单的。
{
    double x,y,z,p;
    x=sqrt((a-c)*(a-c)+(b-d)*(b-d));
    y=sqrt((a-e)*(a-e)+(b-f)*(b-f));
    z=sqrt((c-e)*(c-e)+(d-f)*(d-f));
    p=(x+y+z)/2;
    return sqrt(p*(p-x)*(p-y)*(p-z));
}
int main(){
	cin>>alg>>a>>alg>>b>>alg;//繁琐的输入。
	cin>>alg>>c>>alg>>d>>alg;
	cin>>alg>>e>>alg>>f>>alg;
	cin>>alg>>x>>alg>>y>>alg;
	double sum,sum2,sum3,sum4;
	sum=(int)hl(a,b,c,d,e,f)*100;//你懂的，乘一百解决精度问题
	sum2=(int)hl(a,b,c,d,x,y)*100;
	sum3=(int)hl(a,b,e,f,x,y)*100;
	sum4=(int)hl(c,d,e,f,x,y)*100;
	if((a==x&&b==y)||(c==x&&d==y)||(e==x&&f==y)){//如果这个点和其中一个顶点位置重合就输出4.
		cout<<4<<endl;
		return 0;
	}
	if(sum2+sum3+sum4>sum){//如果三个三角形的面积加起来大于原来的三角形就说明这个点在三角形外。
		cout<<2;
		return 0;
	}
	if(sum2==0||sum3==0||sum4==0){//当有一个三角形的面积等于零时，就说明输入的点在其中一个顶点上。
		cout<<3;
		return 0;
	}
	cout<<1;//其他情况都不是的话就是能是1这种情况了。
	return 0;
} 
```


---

## 作者：Celebrate (赞：2)

先是读入的问题，我想到快读可以排除非数字的干扰，所以我直接用了快读读入

第一步：判断点是否在顶点上

第二部: 用差积判断点是否在三角形上（注意，如果直接判断三点共线，要特判那个点是否在另外两点中间）

第三步：如果前面都不存在，就一定是在三角形外面了。。。。。。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std ;

inline int read() {
	int x = 0 , f = 0 ; char s = getchar() ;
	while ( !isdigit(s) ) f |= s=='-' , s = getchar() ;
	while (  isdigit(s) ) x = (x<<1)+(x<<3)+(s-48) , s = getchar() ;
	return f ? -x : x ;
}
struct point {
	int x , y ;
} p[11] ; 

inline int mul ( point p1 , point p2 , point p0 ) {
	int x1 = p1.x-p0.x , y1 = p1.y-p0.y ;
	int x2 = p2.x-p0.x , y2 = p2.y-p0.y ;
	return x1 * y2 - x2 * y1 ;
}



int main() {
	for ( int i = 1 ; i <= 3 ; i ++ ) 
		p[i].x = read() , p[i].y = read() ;
	p[0].x = read() , p[0].y = read() ;
	int tt ; tt = 0 ;
	for ( int i = 1 ; i <= 3 ; i ++ )
		if ( p[0].x == p[i].x && p[0].y == p[i].y ) {
			tt = i ; break ;
		}
	if ( tt != 0 ) { printf ( "4\n" ) ; return 0 ; }
	if ( mul(p[2],p[0],p[1])*mul(p[0],p[3],p[1])>=0 && 
		 mul(p[1],p[0],p[2])*mul(p[0],p[3],p[2])>=0 &&
		 mul(p[1],p[0],p[3])*mul(p[0],p[2],p[3])>=0 ) {
	 	for ( int i = 1 ; i <= 3 ; i ++ ) {
			tt = i+1 ; if ( tt == 4 ) tt = 1 ;
			if ( mul(p[i],p[tt],p[0]) == 0 ) {
				printf ( "3\n" ) ; return 0 ; 
			}
		}
	 	printf ( "1\n" ) ; return 0 ;
	}
	printf ( "2\n" ) ; return 0 ;
	return 0 ;
}
```


---

## 作者：Trick_t (赞：1)

计算所判断的点与三角形三个顶点的连线与三角形三边组成的三个三角形面积

所得三角形面积记为acd,abd,bcd,原三角形面积为abc

若acd+abd+bcd>abc，则点在三角形外，若相等则点在三角形内

特判点在三角形上的情况

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int abc,acd,abd,bcd;
int x[5],y[5],s[5];
char ch;
double Heron(int a,int b,int x,int y,int n,int m)//海伦公式求三角形面积 
{
    double p,ab,ac,bc;
    ab=sqrt((a-x)*(a-x)+(b-y)*(b-y));//两点之间距离公式求边长 
    ac=sqrt((a-n)*(a-n)+(b-m)*(b-m));
    bc=sqrt((x-n)*(x-n)+(y-m)*(y-m));
    p=(ab+ac+bc)/2;
    return sqrt(p*(p-ab)*(p-ac)*(p-bc));
}
int main()
{
    for(int i=1;i<=4;i++)
        cin>>ch>>x[i]>>ch>>y[i]>>ch;
    for(int i=1;i<=3;i++)
        if(x[i]==x[4] && y[i]==y[4])//三角形顶点与所判点重合 
        {
            cout<<4<<endl;
            return 0;
        }
    abc=(int)Heron(x[1],y[1],x[2],y[2],x[3],y[3])*100;
    acd=(int)Heron(x[1],y[1],x[3],y[3],x[4],y[4])*100;
    abd=(int)Heron(x[1],y[1],x[2],y[2],x[4],y[4])*100;
    bcd=(int)Heron(x[2],y[2],x[3],y[3],x[4],y[4])*100;
    if(acd+abd+bcd>abc)
    {
        cout<<2<<endl;
        return 0;
    }
    else
    {
        if(!abd || !acd || !bcd)//所求面积有一个是0，则点在三角形上 
        {
            cout<<3<<endl;
            return 0;
        }
        cout<<1<<endl;
    }
    return 0;
}
```

---

## 作者：Phykyer (赞：0)

简单的面积法求解……

具体的就是先用两点间面积公式求出各线段长度

然后通过海伦公式求出四个三角形面积之后进行判断

具体看代码(本人蒟蒻代码风格很奇怪还望神犇勿喷)


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<cctype>
using namespace std;
/////////////////////////////////////////////////这只是一个分割线，让代码结构清晰一点 
int ax,ay,bx,by,cx,cy,dx,dy;
double abd,acd,bcd,abc,ad,bd,cd,ab,ac,bc,p;
char yyy;
/////////////////////////////////////////////////
//手写平方函数 
int kai(int x)
{
    return pow(x,2);
}
/////////////////////////////////////////////////
int main()
{
//输入 
    cin>>yyy>>ax>>yyy>>ay>>yyy;
       cin>>yyy>>bx>>yyy>>by>>yyy;
       cin>>yyy>>cx>>yyy>>cy>>yyy;
       cin>>yyy>>dx>>yyy>>dy>>yyy;
/////////////////////////////////////////////////
//若点与三角形顶点重合，输出"4" 
       if(dx==ax&&dy==ay) {cout<<"4"; return 0;}
       if(dx==bx&&dy==by) {cout<<"4"; return 0;}
       if(dx==cx&&dy==cy) {cout<<"4"; return 0;}//这里为了清晰一点所以判断了三遍
                                                                   //当然也可以统一整合起来
/////////////////////////////////////////////////
//两点间距离公式 
    ab=sqrt(kai(ax-bx)+kai(ay-by));
    ac=sqrt(kai(ax-cx)+kai(ay-cy));
    bc=sqrt(kai(cx-bx)+kai(cy-by));
    ad=sqrt(kai(ax-dx)+kai(ay-dy));
    bd=sqrt(kai(bx-dx)+kai(by-dy));
    cd=sqrt(kai(cx-dx)+kai(cy-dy));
/////////////////////////////////////////////////
//海伦公式。。
    p=(ab+ad+bd)/2;///p即为海伦公式中的p 
    abd=sqrt(p*(p-ab)*(p-ad)*(p-bd));
    abd=(int)(100*abd);//因为存在精度问题所以进行放大 
/////////////////////////////////////////////////
    p=(bc+bd+cd)/2;//重复的部分不再多说
    bcd=sqrt(p*(p-bc)*(p-bd)*(p-cd));
    bcd=(int)(100*bcd);
/////////////////////////////////////////////////
    p=(ac+cd+ad)/2;
    acd=sqrt(p*(p-ac)*(p-cd)*(p-ad));
    acd=(int)(100*acd);
/////////////////////////////////////////////////
    p=(ab+ac+bc)/2;
    abc=sqrt(p*(p-ab)*(p-ac)*(p-bc));
    abc=(int)(100*abc);
/////////////////////////////////////////////////
//最后判断
    if(abd+bcd+acd>abc) {cout<<"2"; return 0;}//若三个三角形面积之和大于abc则点在外部
                                                                   //如果一时无法理解画个图就清楚了。。
    if(abd==0||bcd==0||acd==0) {cout<<"3"; return 0;}//因为若有任何一个三角形面积=0
                                                                             //则可判断该点位于三角形边界上 
    cout<<"1";//其他情况均已判断完毕，剩下输出一即可
    return 0;
}
```

---

## 作者：24680esz (赞：0)

楼下写的叉积之类的都好高级…………蒟蒻表示完全看不懂，只会用海伦公式……

用需要判断的点与三角形的三个顶点构成三个三角形，若三个三角形面积之和大于原三角形的面积则该店在三角形外，否则在三角形内（还需判断在边上的情况）

提醒：一定要注意精度！！！！！！

```cpp
#include <bits/stdc++.h>
using namespace std;
double x[5],y[5],f[4],k[4],s,ss,p;
int a,b;
char c;
int main()
{
    for (int i=1;i<5;i++) cin>>c>>x[i]>>c>>y[i]>>c;
    for (int i=1;i<4;i++) if (x[4]==x[i]&&y[4]==y[i]) {cout<<4<<endl;return 0;}//在顶点上
    for (int i=1;i<4;i++) f[i]=sqrt((x[4]-x[i])*(x[4]-x[i])+(y[4]-y[i])*(y[4]-y[i]));//计算三个小三角形的边长
    for (int i=1;i<4;i++)
    {
        a=i,b=((i+1)>3?1:i+1);
        k[i]=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));//计算原三角形的边长
    }
    p=(k[1]+k[2]+k[3])/2;
    ss=sqrt(p*(p-k[1])*(p-k[2])*(p-k[3]));//海（ha）伦公式
    for (int i=1;i<4;i++)
    {
        a=i,b=((i+1)>3?1:i+1);
        p=(f[a]+f[b]+k[i])/2;
        s+=sqrt(p*(p-f[a])*(p-f[b])*(p-k[i]));计算小三角形的面积
    }
    if (s-ss>0.01) {cout<<2<<endl;return 0;}//在三角形外
    for (int i=1;i<4;i++)
    {
        a=i,b=((i+1)>3?1:i+1);
        if ((x[4]-x[a])*(y[b]-y[a])==(x[b]-x[a])*(y[4]-y[a])) {cout<<3<<endl;return 0;}//在边上
    }
    cout<<1<<endl;//在三角形内
    return 0;
}
```

---

## 作者：doby (赞：0)

海伦公式还是可以的，只是在精度上不好确定，但是我们可以调整……

允许小范围的误差，就能过了……

判断顺序最好先43后21……

后两个思路上按照面积法，加起来不相等就是在外面，相等就是在里面……

```cpp
//对用叉积的dalao，先%为敬……
//论将一些可以用函数和循环放在一起的东西展开后的码量变化……
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
float x[10],y[10],l12,l13,l14,l23,l24,l34;
char c;
int main()
{
    cin>>c>>x[1]>>c>>y[1]>>c;
    cin>>c>>x[2]>>c>>y[2]>>c;
    cin>>c>>x[3]>>c>>y[3]>>c;
    cin>>c>>x[4]>>c>>y[4]>>c;
    l12=sqrt((x[1]-x[2])*(x[1]-x[2])+(y[1]-y[2])*(y[1]-y[2])),//算出点两两之间距离
    l13=sqrt((x[1]-x[3])*(x[1]-x[3])+(y[1]-y[3])*(y[1]-y[3])),//注意这里单向求出就可以双向地用了……
    l14=sqrt((x[1]-x[4])*(x[1]-x[4])+(y[1]-y[4])*(y[1]-y[4])),
    l23=sqrt((x[2]-x[3])*(x[2]-x[3])+(y[2]-y[3])*(y[2]-y[3])),
    l24=sqrt((x[2]-x[4])*(x[2]-x[4])+(y[2]-y[4])*(y[2]-y[4])),
    l34=sqrt((x[3]-x[4])*(x[3]-x[4])+(y[3]-y[4])*(y[3]-y[4]));
    if(l14==0||l24==0||l34==0)//如果距离是0，则有点重合
    {
        cout<<"4";
        return 0;
    }
    if((l14+l24==l12)||(l24+l34==l23)||(l14+l34==l13))//距离加起来相等，那么在边上
    {
        cout<<"3";
        return 0;
    }
    if((sqrt(((l12+l13+l23)/2.00)*((l12+l13+l23)/2.00-l12)*((l12+l13+l23)/2.00-l13)*((l12+l13+l23)/2.00-l23))/*前三个点围成的三角形面积*/<(sqrt(((l12+l14+l24)/2.00)*((l12+l14+l24)/2.00-l12)*((l12+l14+l24)/2.00-l14)*((l12+l14+l24)/2.00-l24))+sqrt(((l23+l24+l34)/2.00)*((l23+l24+l34)/2.00-l23)*((l23+l24+l34)/2.00-l24)*((l23+l24+l34)/2.00-l34))+sqrt(((l13+l14+l34)/2.00)*((l13+l14+l34)/2.00-l13)*((l13+l14+l34)/2.00-l14)*((l13+l14+l34)/2.00-l34))/*有和第四个点相连的三个三角形之和*/-0.01))|/*从此处切开阅读效果更佳*/|(sqrt(((l12+l13+l23)/2.00)*((l12+l13+l23)/2.00-l12)*((l12+l13+l23)/2.00-l13)*((l12+l13+l23)/2.00-l23))/*前三个点围成的三角形面积*/>(sqrt(((l12+l14+l24)/2.00)*((l12+l14+l24)/2.00-l12)*((l12+l14+l24)/2.00-l14)*((l12+l14+l24)/2.00-l24))+sqrt(((l23+l24+l34)/2.00)*((l23+l24+l34)/2.00-l23)*((l23+l24+l34)/2.00-l24)*((l23+l24+l34)/2.00-l34))+sqrt(((l13+l14+l34)/2.00)*((l13+l14+l34)/2.00-l13)*((l13+l14+l34)/2.00-l14)*((l13+l14+l34)/2.00-l34))/*有和第四个点相连的三个三角形之和*/+0.01)))//简单来说，前三个点与三个三角形之和的差值不超过0.01就可以判断面积相等了，这里判断的是不等，所以……
    {
        cout<<"2";
        return 0;
    }
    cout<<"1";//前三种都没有，根据排除法，稍有常识的人都知道……
    return 0;
}
```

---

## 作者：1jia1 (赞：0)

和下面一个题解差不多……就是算面积……思路来源于~~一点也不~~机智的@zhengrunzhe

核心思路：对于△ABC，如果D在其外，那么△ABD+△BCD+△ACD>△ABC，否则相等。如果相等，那么只要有一个三角形（不是△ABC）面积为0，代表三点共线，也就是说D在边上。否则就在里面。

```cpp
-#include <cstdio>-
-#include <cmath>-
-using namespace std;-
-int ax,ay,bx,by,cx,cy,dx,dy;-
-float abd,bcd,acd,abc,ad,bd,cd,ab,ac,bc,p;---三个字母表示三角形，两个表示线段，p是用来计算海伦公式
-int kai(int a)---平方
-{-
-    return a*a;-
-}-
-int main()-
-{-
-    char c;-
```
-读入-
```cpp
-    scanf("(%d,%d)\n",&ax,&ay);-
-    scanf("(%d,%d)\n",&bx,&by);-
-    scanf("(%d,%d)\n",&cx,&cy);-
-    scanf("(%d,%d)",&dx,&dy);-
-    if(dx==ax&&dy==ay||dx==bx&&dy==by||dx==cx&&dy==cy)-
-    {-
-        printf("4");-
-        return 0;-
-    }-
-    ab=sqrt(kai(ax-bx)+kai(ay-by));-
-    ac=sqrt(kai(ax-cx)+kai(ay-cy));-
-    bc=sqrt(kai(cx-bx)+kai(cy-by));-
-    ad=sqrt(kai(ax-dx)+kai(ay-dy));-
-    bd=sqrt(kai(bx-dx)+kai(by-dy));-
-    cd=sqrt(kai(cx-dx)+kai(cy-dy));-
```
-    海伦公式求面积
```cpp
-    p=(ab+ad+bd)/2;-
-    abd=sqrt(p*(p-ab)*(p-ad)*(p-bd));-
-    abd=(int)(100*abd);-
-    p=(bc+bd+cd)/2;-
-    bcd=sqrt(p*(p-bc)*(p-bd)*(p-cd));-
-    bcd=(int)(100*bcd);-
-    p=(ac+cd+ad)/2;-
-    acd=sqrt(p*(p-ac)*(p-cd)*(p-ad));
-    acd=(int)(100*acd);-
-    p=(ab+ac+bc)/2;-
-    abc=sqrt(p*(p-ab)*(p-ac)*(p-bc));-
-    abc=(int)(100*abc);-
-    if(abd+bcd+acd>abc)printf("2");---点在三角形外
-    else-
-    {-
-        if(abd==0||bcd==0||acd==0)printf("3");---如果某个三角形面积为0，说明D在边上
-        else printf("1");---否则在里面
-    }-
-    return 0;-
-}-
```

---

## 作者：courage (赞：0)

直接模拟即可

首先判断是否与顶点重合

然后判断是否在边上

接着用面积法判断是否在三角形外

```delphi

type rec=record x,y:longint;end;
var
  a:array[0..3] of rec;
  s:string;
  i:longint;
function pan(p,q,r:longint):boolean;
begin
  if not((a[p].x<=a[q].x)and(a[q].x<=a[r].x)or(a[r].x<=a[q].x)and(a[q].x<=a[p].x)) then exit(false);
  if not((a[p].y<=a[q].y)and(a[q].y<=a[r].y)or(a[r].y<=a[q].y)and(a[q].y<=a[p].y)) then exit(false);
  exit(true);
end;
function area(x,y,z:longint):longint;
begin
  exit(abs(a[x].x*(a[y].y-a[z].y)+a[y].x*(a[z].y-a[x].y)+a[z].x*(a[x].y-a[y].y)));
end;
function ans:longint;
var
  i,j:longint;
begin
  for i:=1 to 3 do if (a[i].x=a[0].x)and(a[i].y=a[0].y) then exit(4);
  for i:=1 to 2 do
    for j:=i+1 to 3 do
      if pan(i,0,j) then
        if (a[i].y-a[0].y)*(a[j].x-a[0].x)=(a[i].x-a[0].x)*(a[j].y-a[0].y) then exit(3);
  if area(0,1,2)+area(0,1,3)+area(0,2,3)=area(1,2,3) then exit(1);
  exit(2)
end;
begin
  for i:=3 downto 0 do
    begin
      readln(s);
      delete(s,1,1);
      val(copy(s,1,pos(',',s)-1),a[i].x);
      delete(s,1,pos(',',s));
      delete(s,length(s),1);
      val(s,a[i].y);
    end;
  writeln(ans);
end.

```

---


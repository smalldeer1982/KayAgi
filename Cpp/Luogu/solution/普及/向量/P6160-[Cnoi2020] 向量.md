# [Cnoi2020] 向量

## 题目背景

> 向量(vector)，指具有大小(Magnitude)和方向(Direction) 的量。  
> 与向量对应的量叫做数量(Scalar)，数量只有大小，没有方向。

对于 Cirno 来说，整天环绕氷屋的旋转 Sangetsusei 们是向量而不是数量。
 - Sunny Milk 以 $r_1$ 为半径做匀速圆周运动。
 - Luna Child 以 $r_2$ 为半径做匀加速圆周运动。
 - Star Sapphire 以 $r_3$ 为半径做变加速圆周运动。

为了尽可能的减小三月精们的影响，一些重要的参数必需被计算。

## 题目描述

以氷屋为原点，三月精的位置分别记作向量 $\vec{a}$, $\vec{b}$, $\vec{c}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/j3u0l3no.png)

由定义可知，$|\vec{a}|=r_1$, $|\vec{b}|=r_2$, $|\vec{c}|=r_3$。

现在 Cirno 分配给你的任务是计算其 **破坏极限指数** $\sigma$。

$$\sigma=\min\{\vec{a}\cdot\vec{b}+\vec{b}\cdot\vec{c}+\vec{c}\cdot\vec{a}\}$$

其中「$\cdot$」表示 **向量内积**。

## 说明/提示

### Sample1 解释

$\cos\langle\vec{a},\vec{b}\rangle=0,\cos\langle\vec{b},\vec{c}\rangle=-\frac{4}{5},\cos\langle\vec{c},\vec{a}\rangle=-\frac{3}{5}$ 时答案最小。

### 后置数学知识
 - **向量内积定义** : $\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\times \cos\langle\vec{a},\vec{b}\rangle$
 - **向量内积坐标表示** : $(x_1,y_1)\cdot(x_2,y_2)=x_1x_2+y_1y_2$

### 数据范围约定

**「本题采用捆绑测试」**

 - Subtask1( $20\%$ ) : $r_1=r_2=r_3$
 - Subtask2( $40\%$ ) : $r_1,r_2,r_3 \le 10$
 - Subtask3( $40\%$ ) : $r_1,r_2,r_3 \le 10^9$

对于 $100\%$ 的数据 $0 < r_1 \le r_2 \le r_3 \le 10^9$

## 样例 #1

### 输入

```
3 4 5```

### 输出

```
-25.0```

## 样例 #2

### 输入

```
159 473 824 ```

### 输出

```
-445561.0```

# 题解

## 作者：Warriors_Cat (赞：19)

## 题解 P6160 【[Cnoi2020]向量】

### $Solution:$

~~呜呜呜一道高中题给一个初一蒟蒻做……~~

~~比赛结束后问了数学老师就做出来了emmm~~

这道题主要还是推式子。

我们可以得到这些东东：

$$\vec a·\vec b+\vec b·\vec c+\vec c·\vec a$$

$$=\frac{1}{2}(|\vec a+\vec b+\vec c|^2-|\vec a|^2-|\vec b|^2-|\vec c|^2)$$

$$=\frac{1}{2}(|\vec a+\vec b+\vec c|^2-r_1^2-r_2^2-r_3^2)$$

因为 $r_1,r_2,r_3$ 均为定值，所以我们只要考虑 $|\vec a+\vec b+\vec c|^2$ 的最小值就可以了QWQ。

那，这个最小值怎么求呢？

那，我们就要分类讨论了。

$i.\;r_1+r_2> r_3$，那么 $\vec a, \vec b, \vec c$ 就可以围成一个类似于三角形的东东，根据平行四边形法则可以得到 $|\vec a+\vec b+\vec c|=0$。由于有平方，所以这个肯定是最小值。

$i.\;r_1+r_2\le r_3$，那么为了让最后答案最小，我们只好让 $|\vec a+\vec b+\vec c|=r_3-r_2-r_1$,这是这种情况最小的答案。

然后这道题就做出来啦0^_^0。

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
long double ans, a, b, c;
int main(){
	scanf("%Lf%Lf%Lf", &a, &b, &c);
	if(a > b) swap(a, b);
	if(a > c) swap(a, c);
	if(b > c) swap(b, c);//从小到大排序一下。
	ans = (max(c - a - b, (long double)0) * max(c - a - b, (long double)0) - c * c - a * a - b * b) / 2.0;//只是简化一下而已
	printf("%0.1Lf", ans);
	return 0;//完结撒花-v-
}
```
## End


---

## 作者：WYXkk (赞：16)

这种屑 MO 题有什么出出来的必要吗……

出题人的分析方法比较神仙……我就只会暴力推三角函数了。

先复述一遍题目：$|OA|=r_1,|OB|=r_2,|OC|=r_3$，求$\sigma=\overrightarrow{OA}\cdot\overrightarrow{OB}+\overrightarrow{OB}\cdot\overrightarrow{OC}+\overrightarrow{OC}\cdot\overrightarrow{OA}$ 的最小值。

假设 $\angle AOB=\alpha,\angle BOC=\beta$，则

$$\begin{aligned}\sigma&=r_1r_2\cos\alpha+r_2r_3\cos\beta+r_3r_1\cos(\alpha-\beta)\\&=r_1r_2\cos\alpha+r_2r_3\cos\beta+r_3r_1(\cos\alpha\cos\beta+\sin\alpha\sin\beta)\\&=(r_1r_2+r_3r_1\cos\beta)\cos\alpha+(r_3r_1\cos\beta)\sin\alpha+r_2r_3\cos\beta\\&\ge-\sqrt{(r_1r_2+r_3r_1\cos\beta)^2+(r_3r_1\cos\beta)^2}+r_2r_3\cos\beta\\&=r_2r_3\cos\beta-\sqrt{r_1^2r_2^2+r_1^2r_3^2+2r_1^2r_2r_3\cos\beta}\end{aligned}$$

接下来，设 $a=r_2r_3,b=r_1^2r_2^2+r_1^2r_3^2,c=2r_1^2r_2r_3,t=\cos\beta$，那么

$$\sigma=at-\sqrt{b+ct}$$

这是一个关于 $t$ 的函数，我们大力求导得到

$$\sigma^\prime=a-\dfrac{c}{2\sqrt{b+ct}}$$

令 $\sigma^\prime>0$，解得 $t>\dfrac{c^2-4a^2b}{a^2c}$。因此，$t=\dfrac{c^2-4a^2b}{a^2c}$ 时 $\sigma$ 取到最小值。

要注意一下 $t$ 是有取值范围 $[-1,1]$ 的，所以要把 $t$ 和 $-1$ 取个 $\max$，和 $1$ 取个 $\min$。

$\texttt{code:}$（代码里的 `A` 是式子里的 $b$，`B` 是 $c$，`C` 是 $a$）
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
//inline int max(int a,int b){return a>b?a:b;}
//inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

typedef long double ld;
int main()
{
	ld r1,r2,r3;
	cin>>r1>>r2>>r3;
	ld A=r1*r1*r2*r2+r1*r1*r3*r3,B=2*r1*r1*r2*r3,C=r2*r3;
	ld t=(B*B-4*C*C*A)/(4*B*C*C);
	if(t<-1.0f) t=-1.0f;if(t>1.0f) t=1.0f;
	if(A+B*t<0) t=-A/B;
	ld ans=-sqrt(A+B*t)+C*t;
	printf("%.1Lf",ans);
	return 0;
}
```


---

## 作者：NXYorz (赞：8)

[题目](https://www.luogu.com.cn/problem/P6160)

## 写在前面

怎么没有导数的题解呢？

这道题本蒟蒻完全当做高中的数学题做的。~~欢迎感兴趣的神犇来喷~~

$End$

----------------

首先我们可以直接得到$ans= \vec{a}* \vec{b}+\vec{b} * \vec{c}+\vec{c}* \vec{a}$

然后提取公因式：

$ans=\vec{a} * (\vec{b}+\vec{c})+\vec{b}* \vec{c}$

我们令$\vec{b}+\vec{c}=\vec{s}$

观察式子，我们发现对于$\vec{a} * (\vec{b}+\vec{c})$，使他们的内积就是$\left|r_1 \right|\times \left|s \right|\times \cos{<a,s>} $

很明显他们反向的时候可以取最小值。

我们设$\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2),\vec{c}=(x_3,y_3)$

代入就可以得到：

$ans=-\left|r_1\right|\times \sqrt{(x_2+x_3)^2+(y_2+y_3)^2}+x_2\times x_3+y_2\times y_3$

然后由于$\vec{b},\vec{c}$ 我们还不知道，为了运算简便我们就可以直接令$x_2=0,y_2=r_2$，我们就可以得到：

$ans=-\left|r_1\right|\times \sqrt{{x_3}^2+(r_2+y_3)^2}+r_2\times y_3$

化简就可以得到

$ans=-\left|r_1\right|\times \sqrt{{r_3}^2+2 r_2y_3+{r_2}^2}+r_2\times y_3$

我们对这个式子求导，就可以得到

$  ans'=\frac{-2\times r_1\times r_2}{2\times \sqrt{{r_2}^2+{r_3}^2+2\times r_2\times y_3}}+r_2$

然后我们简单的分析一下它的单调性就可以得知在$y_3=\frac{{r_1}^2-{r_2}^2-{r_3}^2 }{2\times r_2}$取到极小值。

但是要注意定义域$y_3 \in [-r_3,r_3]$，所以最后要判断一下。

如果没有超出定义域，那么直接将$y_3$代入就可以化简出$ans=\frac{-({r_1}^2+{r_2}^2+{r_3}^2)}{2}$

否则$y_3=-r_3$，代入可得

$ans=r1\times r2-r2\times r3-r1\times r3$

**注意精度！注意精度！注意精度！**

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long double r1,r2,r3;
int main()
{
    //freopen("aa.in","r",stdin);
    cin>>r1>>r2>>r3;
    long double y3=(r1*r1-r2*r2-r3*r3)/(2*r2);
    long double ans;
    if(y3>=-r3) ans=-1*(r1*r1+r2*r2+r3*r3)/2;
    else ans=r1*r2-r2*r3-r1*r3;
    printf("%.1Lf",ans);return 0;
}
```
[强行推荐博客](https://www.luogu.com.cn/blog/niexiaoyang12138/)

------------

### 写在后面

题解通过之后发现有一个地方不太严谨，而且忘了加代码，所以就重新修改了一下

---

## 作者：Euler_Pursuer (赞：4)

被卡精度了。/kk

高中学过向量的应该能快速想到：

$|\vec{a}+\vec{b}+\vec{c}|^2=\vec{a}^2+\vec{b}^2+\vec{c}^2+2\vec{a}\vec{b}+2\vec{a}\vec{c}+2\vec{b}\vec{c}$

移项：$|\vec{a}+\vec{b}+\vec{c}|^2-\vec{a}^2-\vec{b}^2-\vec{c}^2=2\vec{a}\vec{b}+2\vec{a}\vec{c}+2\vec{b}\vec{c}$

$\vec{a}^2+\vec{b}^2+\vec{c}^2$ 是定值，不管它。

对于 $|\vec{a}+\vec{b}+\vec{c}|^2$ ，如果能组成矢量三角形（$|\vec{a}|+|\vec{b}|>|\vec{c}|$，$|\vec{c}|$ 最大）,则上式最小值就是 $0$。否则就让它们共线，然后做差即可。

至于精度问题，我的一个方案就是 long long 来算，最后看看是奇数还是偶数，奇数就手动 .5，偶数就手动 .0。不过最好用正数来算，再手动加负号。因为取整的时候可能会出问题。

---

## 作者：zhanghzqwq (赞：4)

这道题对数学要求比较高。本蒟蒻一开始也没看懂。

如果题目中给的三边$r1,r2,r3$构成三角形的话，答案是$(-r1^2-r2^2-r3^2)/2$,否则答案就是$r1 \times r2 - r2 \times r3 - r3 \times r1$。代码很短，就14行。时间复杂度为$\mathcal O(1)$。

AC代码如下：

```cpp
#include<cstdio>
using namespace std;
int main(){
	long double r1,r2,r3;
	scanf("%Lf%Lf%Lf",&r1,&r2,&r3);
	long double ans;
	if(r1+r2>r3){//判断能否构成三角形
		ans=-(r1*r1+r2*r2+r3*r3)/2;
	}else{
		ans=r1*r2-r2*r3-r3*r1;
	}
	printf("%.1Lf\n",ans);//保留一位小数
	return 0;
} 
```


---

## 作者：Celtic (赞：3)

临时想了一个三分套三分的方法，具体就是三分圆心角，显然是凸函数。

注意向量夹角不是圆心角。

然后 $subtask3$ 第二个点神奇的 $WA$ 掉了。

因为精度问题所以我们选择 $\operatorname{long\,double}$ 。

```cpp

#include<bits/stdc++.h>
#define N 2001001
#define MAX 2001
#define min(a,b) a<b?a:b
using namespace std;

const long double PI=acos(-(long double)1),eps=(long double)1e-12;

long double r1,r2,r3;
long double f( long double a, long double b, long double c)
{
	return r1*r2*cos(min(a,(long double)2*PI-a))+r2*r3*cos(min(b,(long double)2*PI-b))+r3*r1*cos(min(c,(long double)2*PI-c)); 
}
long double calc( long double num)
{
	long double l=0,r=(long double)2*PI-num,midl,midr;
	while(r-l>eps)
	{
		midl=l+(r-l)/(long double)3,midr=r-(r-l)/(long double)3;
		if(f(num,midl,(long double)2*PI-num-midl)-f(num,midr,(long double)2*PI-num-midr)>eps)
			l=midl;
		else
			r=midr;
	}
	return f(num,l,(long double)2*PI-num-l);
}
signed main()
{
	cin>>r1>>r2>>r3;
	long double l=0.0,r=(long double)2*PI,midl,midr;
	while(r-l>eps)
	{
		midl=l+(r-l)/(long double)3,midr=r-(r-l)/(long double)3;
		if(calc(midl)-calc(midr)>eps)
			l=midl;
		else
			r=midr;
	}
	long double x=calc(l);
	cout<<fixed<<setprecision(1)<<x;
}
```


---

## 作者：JamesQin (赞：2)

由题意，三个点的位置是任意的。   
要求的式子为 $\min(\vec{a} \cdot \vec{b}+\vec{b} \cdot \vec{c}+\vec{c} \cdot \vec{a})$ 。     
原式 = $\frac{(\vec{a}+ \vec{b}+\vec{c})^2-{{\vec{a}}^2}-{{\vec{b}}^2}-{{\vec{c}}^2}}{2}$      
=$\frac{(\vec{a}+ \vec{b}+\vec{c})^2-{{r_1^2}}-{{{r_2^2}}}-{{r_3^2}}}{2}$      
为了使原式最小，必须要$(\vec{a}+ \vec{b}+\vec{c})^2$最小。  
当$r_1+r_2 \geq r_3$时，$(\vec{a}+ \vec{b}+\vec{c})$可取到0。  
当$r_1+r_2 < r_3$时，$(\vec{a}+ \vec{b}+\vec{c})$取$r_3-r_2-r_1$。  
输出答案即可。  
注意：因为精度误差，用 long long 存储分子，最后手动输出小数点后的位数。   
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long r1,r2,r3;
	cin>>r1>>r2>>r3;
	if(r1+r2>=r3){   // 第一种情况 
		long long ans=-(r1*r1+r2*r2+r3*r3);
		long long p=2;
		if((ans%p+p)%p){
			cout<<ans/2;        
			cout<<".5"<<endl;    //手动输出小数 
		}
		else{
			cout<<ans/2;
			cout<<".0"<<endl;   //手动输出小数 
		}
	}
	else{                       //第二种情况 
		long long ans=-(r1*r1+r2*r2+r3*r3);
		ans+=(r3-r2-r1)*(r3-r2-r1);
		long long p=2;
		if((ans%p+p)%p){
			cout<<ans/2;
			cout<<".5"<<endl;
		}
		else{
			cout<<ans/2;
			cout<<".0"<<endl;
		}
	}
	return 0;
}
```


---

## 作者：Spasmodic (赞：2)

一只考场并没有推出正解的蒟蒻跑来凑热闹。

首先，我们会发现这3个Sangetsusei的速度都没有给，于是不可以正常的暴力了。

但是我们可以发现，当Sunny Milk转完一圈后，另外2个的情况一定会发生变化，不可能一直与原始位置相同，即恰好也转了若干圈。

所以，我们会发现，这3种所谓的旋转其实是假的，我们可以自己控制他们之间的角度！

所以现在这道题终于变得有点可做了。

首先，我们观察样例1的解释，会发现一个神奇的事情：如果设$a,b,c$构成$\triangle ABC$，则
$$\cos(<\vec{a},\vec{b}>)=\cos C$$
以此类推。

于是我们可以利用余弦定理计算出$\cos A,\cos B \cos C$，然后代入原始就可以解决此题！

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,cosA,cosB,cosC;
int main(){
	scanf("%lf%lf%lf",&a,&b,&c);
	if(a+b>c){
		cosA=(a*a-b*b-c*c)/(2*b*c);
		cosB=(b*b-a*a-c*c)/(2*a*c);
		cosC=(c*c-b*b-a*a)/(2*a*b);
		printf("%.1lf\n",a*b*cosC+a*c*cosB+b*c*cosA);
	}
	return 0;
}
```
P.S.以上就是我考场做法。

交上去一看，60分...

我们发现这个代码连第二个样例都跑不过，为什么呢？

这是因为第二个样例的三边**不构成三角形！**

于是我们必须另辟蹊径。

我们可以发现原式好像十分类似**三元的完全平方和公式**，于是可以得到：
$$\vec{a}\cdot\vec{b}+\vec{b}\cdot\vec{c}+\vec{a}\cdot\vec{c}$$
$$=\frac{1}{2}(|\vec{a}+\vec{b}+\vec{c}|^2-|\vec{a}|^2-|\vec{b}|^2-|\vec{c}|^2)$$
注意到$|\vec{a}|^2+|\vec{b}|^2+|\vec{c}|^2=r_1^2+r_2^2+r_3^2$为定值，所以我们可以改变的只有前者。

如果$a,b,c$可以构成三角形，那么$\min{|\vec{a}+\vec{b}+\vec{c}|^2}=0$

如果不能，那么$\min{|\vec{a}+\vec{b}+\vec{c}|^2}=r_3-r_2-r_1$

于是我们就可以得到代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double r1,r2,r3;
int main(){
	scanf("%lf%lf%lf",&r1,&r2,&r3);
	if(r1+r2>r3)printf("%.1lf\n",-0.5*(r1*r1+r2*r2+r3*r3));
	else printf("%.1lf\n",0.5*((r3-r2-r1)*(r3-r2-r1)-r1*r1-r2*r2-r3*r3));
	return 0;
}
```
然而我们发现**又WA了**！

翻了翻题解区发现这题严重卡精度，于是我们把`double`改成`long double`，即可AC。

注：`long double`用`scanf,printf`输入/输出使用`%Lf`。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long double r1,r2,r3;
int main(){
	scanf("%Lf%Lf%Lf",&r1,&r2,&r3);
	if(r1+r2>r3)printf("%.1Lf\n",-0.5*(r1*r1+r2*r2+r3*r3));
	else printf("%.1Lf\n",0.5*((r3-r2-r1)*(r3-r2-r1)-r1*r1-r2*r2-r3*r3));
	return 0;
}

```

---


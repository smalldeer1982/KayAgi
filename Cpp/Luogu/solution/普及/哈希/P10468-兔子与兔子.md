# 兔子与兔子

## 题目描述

很久很久以前，森林里住着一群兔子。

有一天，兔子们想要研究自己的 DNA 序列。

我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 $26$ 个小写英文字母）。

然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。

注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。

## 说明/提示

数据保证，$1 \le |S|,m \le 10^6$。其中，$|S|$ 为字符串 $S$ 的长度。

## 样例 #1

### 输入

```
aabbaabb
3
1 3 5 7
1 3 6 8
1 2 1 2```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：kevin1616 (赞：18)

### 审题
给定一个字符串，求该字符串的两个子串是否一样。
***
### 方法
【暴力】对于一个字符串，我们将它的两个子串截取出来，再判断是否一样。由于判断的时间复杂度为 $O(len)$，故最终时间复杂度为 $O(len\times m)$，其中 $len$ 是字符串的长度。该算法无法通过本题。

【字符串哈希】可以发现判断字符串一样的复杂度可以通过字符串哈希优化为 $O(1)$，故最终时间复杂度为 $O(len+m)$，可以通过本题。
***
### 思路
首先求出字符串的前缀哈希值。通过以下代码实现：
```cpp
for(int i = 1;i < s.size();i++){
  hs[i] = hs[i - 1] * 113 + s[i];
  pw[i] = pw[i - 1] * 113;
}
```
这边推荐使用质数作为进制数，这样可以更加避免哈希冲突。

然后我们将所求划分为一个子问题，即在区间中子串的哈希值是否相等。我们举一个例子：例如 $114514$ 这个数，我们要求从第 $2$ 位到第 $4$ 位组成的数，显而易见为 $1145-1000=145$。此时发现答案为 $hs_4-hs_1\times10^3$。所以得出，对于区间 $l$ 到 $r$，子串的哈希值为 $hs_r-hs_{l-1}\times base^{r-l+1}$。最后判断这两个值相等即可。
***
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int q;
unsigned long long hs[1000005];
unsigned long long pw[1000005];
unsigned long long get_sizeHash(int a,int b){ //区间中子串的哈希值
    return hs[b] - hs[a - 1] * pw[b - a + 1];
}
int main(){
    cin >> s;
    s = " " + s;
    pw[0] = 1; //次方的初始化
    for(int i = 1;i < s.size();i++){
        hs[i] = hs[i - 1] * 113 + s[i]; //前缀哈希值
        pw[i] = pw[i - 1] * 113; //113的次方
    }
    cin >> q;
    while(q--){
        int a,b,x,y;
        cin >> a >> b >> x >> y;
        if(get_sizeHash(a,b) == get_sizeHash(x,y)) cout << "Yes\n"; //判断两个区间中子串的哈希值是否相等
        else cout << "No\n";
    }
    return 0;
}
```
不抄题解，从我做起！

---

## 作者：Weekoder (赞：7)

字符串哈希模板题。

### 思路

基于哈希的思想，我们可以将一个字符串通过哈希函数转换成为 $x$ 进制的数值。不会的可以先去看看 [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)。

可是，我们该如何获取字符串在区间 $[L,R]$ 内的哈希值呢？这里有一个例子：

在字符串 $s=\texttt{9723761}$ 中，我们想截取区间 $[3,6]$ 的哈希值，也就是 $\texttt{2376}$ 的哈希值。我们或许可以尝试类似于前缀和的思路：$hs_i$ 表示前 $i$ 个字符串的哈希值。那么，$\texttt{2376}$ 的哈希值就可以被表示为 $\texttt{972376}$ 的哈希值 $hs_R$ 减去 $\texttt{970000}$ 的哈希值 $hs_{L-1}\times10^{R-L+1}$，即 $hs_R-hs_{L-1}\times10^{R-L+1}$。然而，实际上我们会将字符串转换为 $base$ 进制的数值，所以答案应为 $hs_R-hs_{L-1}\times base^{R-L+1}$，我们可以预处理 $pw_i=base^i$，$pw$ 可以递推得到，$pw_0=1$。这样就保证了我们可以以 $\mathcal{O}(1)$ 的时间复杂度获取区间内的哈希值了。最后检查 $[l1,r1]$ 和 $[l2,r2]$ 的哈希值是否相同即可。

注意，我这里使用的是单哈希，如果 $base$ 不选好，可能会导致哈希冲突！

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long ull;

const int N = 1e6 + 5, Base = 13331;

string s;

int n, m;

ull hs[N], pw[N];

ull get_hs(int l, int r) {
	return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> s >> m;
	n = s.size();
	s = '#' + s;
	pw[0] = 1;
	for (int i = 1; i <= n; i++) {
		hs[i] = hs[i - 1] * Base + s[i];
		pw[i] = pw[i - 1] * Base;
	}
	while (m --) {
		int l1, r1, l2, r2;
		cin >> l1 >> r1 >> l2 >> r2;
		cout << (get_hs(l1, r1) == get_hs(l2, r2) ? "Yes\n" : "No\n");
	}
	return 0;
}
```

---

## 作者：WanderFreeFish (赞：3)

### Solution

判断字符串相等，考虑哈希。先处理从开始到每一位的哈希值，用类似于前缀和的思路算出每段区间的哈希值。

这里要注意算进制次方的时候用快速幂会多个 $\log$，可以在处理前缀和的时候一起预处理了。

这题水，~~建议降橙~~。

### Code


```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <string>

using ll = long long int;
const int MAXN = 1e6 + 10, mod = 217636919, base = 131;

std::string s;
int T;
ll hash[MAXN], power[MAXN];

int main() {
	std::cin >> s >> T;
	s = " " + s;
	
	power[0] = 1;
	for (int i = 1; i <= s.size(); i++) {
		hash[i] = (hash[i - 1] * base + s[i]) % mod;
		power[i] = power[i - 1] * base % mod;
	}
	
	while (T--) {
		int l1, r1, l2, r2; std::cin >> l1 >> r1 >> l2 >> r2;
		int len1 = r1 - l1 + 1, len2 = r2 - l2 + 1;
		int h1 = hash[r1] + mod - hash[l1 - 1] * power[len1] % mod; h1 %= mod;
		int h2 = hash[r2] + mod - hash[l2 - 1] * power[len2] % mod; h2 %= mod;
		if (h1 == h2) std::cout << "Yes\n";
		else std::cout << "No\n";
	}
	return 0;
}
```

---

## 作者：__xxy_free_ioi__ (赞：3)

# 题解：P10468 兔子与兔子

哈希好题。

## 解法

直接对 $s$ 进行哈希（前后缀都可以），那么，询问时直接判断它们的哈希值是否相等即可。

我们可以使用进制哈希，就像将字符串转换为十进制那样，用 $hash$ 数组存下来。而查询 $l \sim r$ 的哈希值就是 $hash_l-hash_r \times base^{r-l+1}$（我使用的是后缀哈希，$base$ 可以取 $123$）。

## 代码

```
#include <bits/stdc++.h>

using namespace std;
using ull = unsigned long long;

#define up(i, s, t) for (int i = s; i <= t; i++)
#define down(i, s, t) for (int i = s; i >= t; i--)

struct Hash {
    int n;
    vector<ull> H, C;
    void init(string& s, ull x) {
        n = s.size(), H.resize(n + 1), C.resize(n + 1);
        C[0] = 1, H[n] = 0;
        up(i, 1, n) C[i] = C[i - 1] * x;
        down(i, n - 1, 0) H[i] = H[i + 1] * x + s[i];
    }
    ull hash(int l, int r) { return H[l] - H[r] * C[r - l]; }
};

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    
    string s;
    cin >> s;
    Hash h; h.init(s, 123);
    int q;
    cin >> q;
    while (q--) {
        int la, lb, ra, rb;
        cin >> la >> ra >> lb >> rb;
        if (h.hash(la, ra) == h.hash(lb, rb)) cout << "Yes\n";
        else cout << "No\n";
    }
    return 0;
}
```

---

## 作者：wmrqwq (赞：3)

# 题目链接

[P10468 兔子与兔子](https://www.luogu.com.cn/problem/P10468)

# 解题思路

字符串哈希板子题。

思路就是我们给字符串的每一个前缀和后缀都用一种特定的方式使其变为一个值，比如取一个乘数和模数，可以证明这样出错的概率极低。

# 参考代码

这里使用自然溢出三哈希。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define map unordered_map
#define forl(i,a,b) for(register long long i=a;i<=b;i++)
#define forr(i,a,b) for(register long long i=a;i>=b;i--)
#define forll(i,a,b,c) for(register long long i=a;i<=b;i+=c)
#define forrr(i,a,b,c) for(register long long i=a;i>=b;i-=c)
#define lc(x) x<<1
#define rc(x) x<<1|1
//#define mid ((l+r)>>1)
#define cin(x) scanf("%lld",&x)
#define cout(x) printf("%lld",x)
#define lowbit(x) (x&-x)
#define pb push_back
#define pf push_front
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl '\n'
#define QwQ return 0;
#define ll long long
#define ull unsigned long long
#define lcm(x,y) x/__gcd(x,y)*y
#define Sum(x,y) 1ll*(x+y)*(y-x+1)/2
#define aty cout<<"Yes\n";
#define atn cout<<"No\n";
#define cfy cout<<"YES\n";
#define cfn cout<<"NO\n";
#define xxy cout<<"yes\n";
#define xxn cout<<"no\n";
#define printcf(x) x?cout<<"YES\n":cout<<"NO\n";
#define printat(x) x?cout<<"Yes\n":cout<<"No\n";
#define printxx(x) x?cout<<"yes\n":cout<<"no\n";
ll t;
string s;
ll q,l1,l2,r1,r2;
long long Ss=chrono::steady_clock::now().time_since_epoch().count();
mt19937_64 Apple(Ss);
long long rand_lr(ll l,ll r){
	return Apple()%(r-l+1)+l;
}
ll pw1[1000010],pw2[1000010],pw3[1000010];
ll hash1[1000010],hash2[1000010],hash3[1000010];
ll Base1=779,Base2=223,Base3=667;
ll mod1=1e9+7,mod2=1e9+9,mod3=998244353;
void init()
{
	pw1[0]=pw2[0]=pw3[0]=1;
	forl(i,1,1e6+5)
		pw1[i]=pw1[i-1]*Base1;
	forl(i,1,1e6+5)
		pw2[i]=pw2[i-1]*Base2;
	forl(i,1,1e6+5)
		pw3[i]=pw3[i-1]*Base3;
	forl(i,1,(ll)s.size()-1)
		hash1[i]=(hash1[i-1]*Base1+s[i]);
	forl(i,1,(ll)s.size()-1)
		hash2[i]=(hash2[i-1]*Base2+s[i]);
	forl(i,1,(ll)s.size()-1)
		hash3[i]=(hash3[i-1]*Base3+s[i]);		
}
void solve()
{
	cin>>s>>q;
	s=' '+s;
	init();
	while(q--)
	{
		ll l1,l2,r1,r2;
		cin>>l1>>r1>>l2>>r2;
		printat((hash1[r1]-hash1[l1-1]*pw1[r1-l1+1])==(hash1[r2]-hash1[l2-1]*pw1[r2-l2+1]) &&
				(hash2[r1]-hash2[l1-1]*pw2[r1-l1+1])==(hash2[r2]-hash2[l2-1]*pw2[r2-l2+1]) &&
				(hash3[r1]-hash3[l1-1]*pw3[r1-l1+1])==(hash3[r2]-hash3[l2-1]*pw3[r2-l2+1]) );
	}
}
int main()
{
	IOS;
	t=1;
//	cin>>t;
	while(t--)
		solve();
	QwQ;
}
```

---

## 作者：xiaowenxu_qwq (赞：2)

# 题目意思
给定一个字符串 $s$，之后有 $m$ 次询问，每次询问给出两个区间 $[l1,r1]$ 和 $[l2,r2]$，判断这两个区间对应的子串是否完全相同。

# 思路
我们可以用暴力的方式来试一试，每次直接比较子串的字符。

暴力代码（0pts）。

```cpp
#include<bits/stdc++.h>
#define int __int128
#define max(a,b) (a>b?a:b) 
#define min(a,b) (a<b?a:b) 
//#define getchar() getchar_unlocked()
using namespace std;
char s[1000001];
bool book;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}
void write(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else write(x/10),putchar(x%10+'0');
}
signed main()
{
	string s;
    cin>>s;
    int n=read();
    for(int i=1;i<=n;i++){
        int l1=read(),r1=read(),l2=read(),r2=read();
        if((l1-r1)!=(l2-r2))printf("No\n");
        else{
            book=1;
            for(int i=l1,j=l2;i<=r1;i++,j++){
                if(s[i]!=s[j])book=0;
            }
            if(book)printf("Yes\n");
            else printf("No\n");
        }
    }
	return 0;
} 
```

但是为了高效处理大量的区间比较询问，直接每次比较子串的字符显然是不现实的，因为这样的时间复杂度会是 $O(m\times L)$，其中 $L$ 是子串的平均长度，对于大的 $m$ 和 $L$（如 $10^6$），这会导致我们的程序超时，所以我们必须在 $O(1)$ 的时间复杂度内比较出子串是否相同，所以字符哈希无疑是最好的选择。

字符串哈希的基本思想是将字符串看作一个数字（通常是基于某个基数和模数的大数），然后通过预处理前缀哈希数组，可以在 $O(1)$ 时间内计算出任意子串的哈希值。

首先我们要预处理前缀哈希数组和基数幂数组：

- 定义 $hs[i]$ 为前 $i$ 个字符的哈希值。

- 定义 $pw[i]$ 为基数的 $i$ 次方。

用递推计算出数组的各个值：

- $hs[i]=hs[i-1] \times base+s[i]$

- $pw[i]=pw[i-1]\times base$

计算子串哈希：

对于子串 $S[l...r]$，其哈希值为：

$hs[r]-hs[l-1]\times pw[r-l+1]$


最后对于每个查询，计算两个子串的哈希值，比较是否相等，如果相等则子串相等，反之不相等。

字符哈希代码（100pts）。
```cpp
#include<bits/stdc++.h>
#define int __int128
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
//#define getchar() getchar_unlocked()
using namespace std;
const int base=131;//选择一个质数作为基数
int hs[1000005];//前缀哈希数组
int pw[1000005];//基数幂数组
int Hash(int l,int r){
    return hs[r]-hs[l-1]*pw[r-l+1];
}
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}//快读
signed main(){
    string s;
    cin>>s;
    int n=s.length();
    s=" "+s;//使字符串下标从1开始
    //预处理前缀哈希和基数幂
    pw[0]=1;
    for(int i=1;i<=n;i++){
        hs[i]=hs[i-1]*base+s[i];
        pw[i]=pw[i-1]*base;
    }
    int m=read();
    for(int i=1;i<=m;i++){
        int l1=read(),r1=read(),l2=read(),r2=read();
        if (Hash(l1,r1)==Hash(l2,r2))
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}
```

---

## 作者：Stars_visitor_tyw (赞：2)

## 题解：P10468 兔子与兔子

### 分析
由于直接二重循环预处理或截取字符串都会超时，我们可以考虑优化，维护字符串哈希值的前缀数组 $hs[]$。`hs[i]+=hs[i-1]*base+s[i];`

然后对于每次询问，截取字符串 $s$ 在 $l$ 到 $r$ 区间的哈希值。`hs[r]-hs[l-1]*pw[r-l+1];`

其中 $pw_i$ 表示哈希设定的进制 $base$ 的 $i$ 次方。

按上述方法分别截取两段的双哈希值，判断是否相等即可。


### 暴力代码
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int hadsh(string s, int mod, int base)
{
	int hs=0;
	for(int i=0;i<s.size();i++)
	{
		hs=hs%mod+(hs*base+s[i])%mod;
	}
	return hs%mod;
}
bool vis1[1000005], vis[1000005];
signed main()
{
	string s;
	cin>>s;
	int n;
	cin>>n;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		int l1, r1, l2, r2;
		cin>>l1>>r1>>l2>>r2;
		l1--,r1--,l2--,r2--;
		string s1=s.substr(l1,r1-l1+1);
		string s2=s.substr(l2,r2-l2+1);
		int v1=hadsh(s1,999983,26);
		int v2=hadsh(s1,999977,131);
		int v3=hadsh(s2,999983,26);
		int v4=hadsh(s2,999977,131);
		if(v1==v3&&v2==v4)
		{
			cout<<"Yes\n";
		}
		else
		{
			cout<<"No\n";
		}
	}
	cout<<ans;
}
```
### 正解代码
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int hs[1000005], pw[1000005], hs1[1000005], pw1[1000005];
void hadsh(string s, int mod, int base)
{
	for(int i=0;i<s.size();i++)
	{
		hs[i+1]+=(hs[i]*base+s[i]);
		pw[i+1]=pw[i]*base;
	}
}
void hadsh1(string s, int mod, int base)
{
	for(int i=0;i<s.size();i++)
	{
		hs1[i+1]+=(hs1[i]*base+s[i]);
		pw1[i+1]=pw1[i]*base;
	}
}
int get_hs(int l, int r)
{
	return hs[r]-hs[l-1]*pw[r-l+1];
}
int get_hs1(int l, int r)
{
	return hs1[r]-hs1[l-1]*pw1[r-l+1];
}
signed main()
{
	string s;
	cin>>s;
	int n;
	cin>>n;
	int ans=0;
	pw[0]=1,pw1[0]=1;
	hadsh(s,999983,13331);
	hadsh1(s,999977,131);
	for(int i=1;i<=n;i++)
	{
		int l1, r1, l2, r2;
		cin>>l1>>r1>>l2>>r2;
		int v1=get_hs(l1,r1);
		int v2=get_hs1(l1,r1);
		int v3=get_hs(l2,r2);
		int v4=get_hs1(l2,r2);
		if(v1==v3&&v2==v4)
		{
			cout<<"Yes\n";
		}
		else
		{
			cout<<"No\n";
		}
	}
}
```

---

## 作者：qw1234321 (赞：2)

哈希模板。

对原字符串求出 $Hash_i$ 表示前 $i$ 个字符的哈希值，每次询问按照前缀和的思想求出子串的哈希值，比较哈希值是否相同即可。

哈希值的求法请见 [P3370](https://www.luogu.com.cn/problem/P3370)，跟离散化有些许相似。

代码就不放了。

---

## 作者：tiantian0820 (赞：1)

## 题意
给定一个字符串，求该字符串的两个子串是否一样。

## 思路
我们可以每次直接比较子串的字符。但是，先判断两个子串的长度是否一样。

但是询问较多，我们可以考虑优化，想到前缀和、字符串哈希。

我们可以维护字符串哈希值的前缀数组。求出字符串的前缀哈希值，为了减少哈希冲突，我用了四个数组和多个变量。

代码如下：
```cpp
#include<iostream>
#include<string>
using namespace std;
 
int main() {
  string n;
  int t,d,f,g,h;
  cin>>n;
  //前缀哈希数组
  int a[n.size()+1]= {0};
  int c[n.size()+1]= {0};
  int v[n.size()+1]= {0};
  int b[n.size()+1]= {0};
  //基数幂数组
  int a1[n.size()+1];
  int c1[n.size()+1];
  int v1[n.size()+1];
  int b1[n.size()+1];
    //预处理前缀哈希和基数幂
  a1[0]= {1};
  c1[0]= {1};
  v1[0]= {1};
  b1[0]= {1};
  for(int i=0; i<n.size(); ++i) {
    a[i+1]=a[i]*37+n[i];
    c[i+1]=c[i]*41+n[i];
    v[i+1]=v[i]*43+n[i];
    b[i+1]=b[i]*47+n[i];
    a1[i+1]=a1[i]*37;
    c1[i+1]=c1[i]*41;
    v1[i+1]=v1[i]*43;
    b1[i+1]=b1[i]*47;
//    a[i+1]%=1000000011;
//    c[i+1]%=1000000013;
//    v[i+1]%=1000000017;
//    b[i+1]%=1000000019;
//    a1[i+1]%=1000000011;
//    c1[i+1]%=1000000013;
//    v1[i+1]%=1000000017;
//    b1[i+1]%=1000000019;
//   不知道为什么，使用这几行取余代码会答案错误，我用的自然溢出。
  }
  cin>>t;
  while(t--) {
    cin>>d>>f>>g>>h;
    --d;
    --g;

    if(d+h-f-g!=0) {
      cout<<"No\n";
      continue;
    }//
//    a1[i+1]%=1000000011;
//    c1[i+1]%=1000000013;
//    v1[i+1]%=1000000017;
//    b1[i+1]%=1000000019;
    int aa=a[f]-a[d]*a1[f-d];
    int ca=c[f]-c[d]*c1[f-d];
    int va=v[f]-v[d]*v1[f-d];
    int ba=b[f]-b[d]*b1[f-d];
    int as=a[h]-a[g]*a1[h-g];
    int cs=c[h]-c[g]*c1[h-g];
    int vs=v[h]-v[g]*v1[h-g];
    int bs=b[h]-b[g]*b1[h-g];
    bool bb=1;
    bb=bb&&as==aa;
    bb=bb&&cs==ca;
    bb=bb&&vs==va;
    bb=bb&&bs==ba;
    if(bb) {
      cout<<"Yes\n";
      continue;
    } else {
      cout<<"No\n";
      continue;
    }
  }
  return 0;
}
```

---

## 作者：dangerous_DZR (赞：1)

首先自信点开题目标签——`哈希 hashing`，再加上题目中的数据范围 $1 \le \left|S\right|, m \le 10^6$——纯纯哈希模版题！

## 解法
这里我们采用进制哈希——即将字符串转为一个 $k$ 进制的整数。  
首先给出模版（具体见注释）：

```cpp
unsigned long long Hash(string s){//unsigned long long 相当于自动取模
	unsigned long long sum = 0, k = 131654151;//随机取一个数作进制（最好是质数）
	for (int i = 0, len = s.size(); i < len; i ++)sum = sum * k + s[i];//模拟进位操作
	return sum;
}
```
是不是比想象中的简单？  
那么，只要两段字符串的哈希值一样不就可以判定相等了？  
于是一个新的问题接踵而至——怎么截取字符串子串的哈希值？

不妨先思考一下求一个数中几个连续数位组成的数的方法——令此数前 $i$ 位的数为 $h_i$，此数为 $k$ 进制数，求从第 $l$ 位至第 $r$ 位组成的数（子串？）。则可推出公式为
$$h_r - h_{l - 1} \times k ^ {r - l + 1}$$
那么，上代码：

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
string s;
int m, l1, r2, l2, r1, k = 13324161, h[1000010], p[1000010] = {1};//这里的k是乱取的
signed main(){
	ios::sync_with_stdio(0); 
    cin.tie(0);
	cin >> s >> m;
	for (int i = 1, len = s.size(); i <= len; i ++)h[i] = h[i - 1] * k + s[i - 1], p[i] = p[i - 1] * k;//计算哈希值和k的幂
	while (m --){
		cin >> l1 >> r1 >> l2 >> r2;
		cout << (h[r1] - h[l1 - 1] * p[r1 - l1 + 1] == h[r2] - h[l2 - 1] * p[r2 - l2 + 1] ? "Yes\n" : "No\n");//判断子串哈希值是否相等
	}
	return 0;
}
```

---


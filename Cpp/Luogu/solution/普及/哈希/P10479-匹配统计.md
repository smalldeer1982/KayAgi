# 匹配统计

## 题目描述

阿轩在纸上写了两个字符串，分别记为 $A$ 和 $B$。利用在数据结构与算法课上学到的知识，他很容易地求出了"字符串 $A$ 从任意位置开始的后缀子串“与“字符串 $B$”匹配的长度。

不过阿轩是一个勤学好问的同学，他向你提出了 $Q$ 个问题：在每个问题中，他给定你一个整数 $X$，请你告诉他有多少个位置，满足“字符串 $A$ 从该位置开始的后缀子串"与 $B$ 匹配的长度恰好为 $X$。

例如：A=aabcde，B=ab，则 $A$ 有 aabcde、abcde、bcde、cde、de、e 这 $6$ 个后缀子串，它们与 $B=ab$ 的匹配长度分别是 $1,2,0,0,0,0$。因此 $A$ 有 $4$ 个位置与 $B$ 的匹配长度恰好为 $0$，有 $1$ 个位置的匹配长度恰好为 $1$，有 $1$ 个位置的匹配长度恰好为 $2$。

## 说明/提示

数据保证，$1\leq N,M,Q,X\leq 200000$。

## 样例 #1

### 输入

```
6 2 5
aabcde
ab
0
1
2
3
4```

### 输出

```
4
1
1
0
0```

# 题解

## 作者：MoonCake2011 (赞：10)

来个简单的 Hash 做法吧。

~~打死不用 KMP。~~

## Part 1,about Hash

先给出初始化的代码。

```cpp
cin>>n>>m>>q;
cin>>a>>b;
a=" "+a,b=" "+b;
power[0]=1;
//前缀 Hash 值进制数选的是 131，Hash 可以把一个前缀字符串压成整数
//预处理前缀 Hash 值，用 ull 自然溢出取模，其实 Hash 的冲突概率很小啦
//power计算是计算进制位权的，用于配合前缀 Hash 值计算每一个字串的 Hash 值
for(int i=1;i<=n;i++) ha[i]=ha[i-1]*131+a[i],power[i]=power[i-1]*131;
for(int i=1;i<=m;i++) hb[i]=hb[i-1]*131+b[i],power[i]=power[i-1]*131; 
```

接下来需要计算前缀 Hash 值。

$s$ 为 `string` 字符串。

可以表示为 $H(s_r)-H(s_{l-1})\times 131^{r-l+1}$。

为什么，要乘以个 $131^{r-l+1}$。

因为要在 $s_{l-1}$ 后补 $r-l+1$ 个空字符才能于 $s_r$ 相减。

因为 $r$ 位字符串于 $l-1$ 位字符串是不一样的。

```cpp
unsigned long long geta(int l,int r){
	return ha[r]-ha[l-1]*power[r-l+1];
}
unsigned long long getb(int l,int r){
	return hb[r]-hb[l-1]*power[r-l+1];
}
```

接着，我们就可以 $O(1)$ 比较两个子串了。

## Part 2,Multiply Search

倍增查找，在这里比二分好用。

我们先枚举每个后缀字串的开头 $b$。

去枚举匹配结尾的下一个位置 $e$。

如 $a[b,e)$ 的 Hash 值等于 $b[1,e-b+1)$ 那么就匹配上了。

匹配值取值 $[0,1]$。

又发现,匹配值满足单调性。

直接上倍增。

这里上倍增的原因是可以设置两个指针 $p,q$。

一个在 $a$ 上面指，一个在 $b$ 上面指。

最后建立一个桶，去统计 $q-1$ 就行了。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
string a,b;
unsigned long long ha[200010],hb[200010],power[200010];
unsigned long long geta(int l,int r){
	return ha[r]-ha[l-1]*power[r-l+1];
}
unsigned long long getb(int l,int r){
	return hb[r]-hb[l-1]*power[r-l+1];
}
int buc[2000100];
int main() {
	cin>>n>>m>>q;
	cin>>a>>b;
	a=" "+a,b=" "+b;
	power[0]=1;
	for(int i=1;i<=n;i++) ha[i]=ha[i-1]*131+a[i],power[i]=power[i-1]*131;
	for(int i=1;i<=m;i++) hb[i]=hb[i-1]*131+b[i],power[i]=power[i-1]*131; 
	for(int i=1;i<=n;i++){
		int p=i,q=1;//两个指针
		for(int i=30;i>=0;i--){
			if(p+(1<<i)-1>n || q+(1<<i)-1>m) continue;
			if(geta(p,p+(1<<i)-1)==getb(q,q+(1<<i)-1)) p+=(1<<i),q+=(1<<i);//Hash 值倍增
		}
		buc[q-1]++;//统计
	}
	while(q--){//求解
		int x;
		cin>>x;
		cout<<buc[x]<<"\n";
	}
	return 0;
}
```

---

## 作者：Stone_Xz (赞：6)

## [传送门：P10479 匹配统计](https://www.luogu.com.cn/problem/P10479)

## 题意：

 - 和结合题目中的样例解释理解。

> 给定字符串 $A$、$B$，$Q$ 次询问，每次询问给出一个数 $x$，求所有 $A$ 的后缀子串中，满足：“与 $B$ 的匹配长度恰好为 $x$”的字符串个数。其中“匹配长度”指两个字符串最长的公共前缀子串，如 `abc` 与 `abx` 的匹配长度就为 $2$。

## 分析：Hash + 二分

 - 首先，用哈希暴力求解的话，时间复杂度 $O(NQ)$，显然不可行。注意到字符串 $A$ 从每一个位置开始的后缀子串对于答案的贡献一定，考虑预处理。
 
 1. 维护 $ans_i$ 表示询问中 $x = i$ 的答案，即满足“字符串 $A$ 从该位置开始的后缀子串”与 $B$ 的匹配长度恰好为 $x$ 的位置个数。
 
 2. 我们发现，如果暴力枚举每一个 $A$ 的后缀子串 $A'$ 并与 $B$ 串配对，求出 $A'$ 与 $B$ 的匹配长度的话，预处理的时间复杂度是 $O(NM)$，仍然不行，那怎么办呢？
 
 3. 枚举每一个 $A$ 的后缀子串 $A'$ 这个步骤必不可少，我们发现 $M = 2 \times 10 ^ 5$，可以猜测，求解 $A'$ 与 $B$ 的匹配长度 $len$ 的时间应该可以优化为 $O(\log M)$。进一步地，$len$ 具有单调性：$A'$ 和 $B$ 肯定能匹配比 $len$ 小的长度，肯定不能匹配比 $len$ 大的长度。因此考虑二分。
 
 4. 枚举 $A$ 从位置 $i$ 开始的后缀子串 $A'$，$A'$ 与 $B$ 的匹配长度最少为 $0$，最大为 $\min(M, N - i + 1)$。二分找到最大的 $x$，使得 $A'$ 的前 $x$ 个字符与 $B$ 的前 $x$ 个字符匹配，二分时借助哈希比较 $A'$ 的前 $mid$ 个字符是否与 $B$ 的前 $mid$ 个字符相同。我们求出了 $A'$ 与 $B$ 的匹配长度 $x$，最后 $ans_x = ans_x + 1$ 即可。
 
 ## 代码：
 
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;

const int N = 2e5 + 5, base = 13331;
int n, m, q, ans[N];
string a, b;
ull pw[N], hs_a[N], hs_b[N];

ull get_hs(ull hs[], int l, int r)
{
	return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int main()
{
	cin >> n >> m >> q >> a >> b;
	// 注意下标必须从 1 开始 
	a = "%" + a;
	b = "%" + b;
	// 预处理哈希值 
	pw[0] = 1;
	for(int i = 1; i <= n; i++)
		hs_a[i] = hs_a[i - 1] * base + a[i];
	for(int i = 1; i <= m; i++)
	{
		hs_b[i] = hs_b[i - 1] * base + b[i];
		pw[i] = pw[i - 1] * base;
	}
	for(int i = n; i >= 1; i--)
	{
		int lt = -1, rt = min(m, n - i + 1) + 1;
		while(lt + 1 < rt)
		{
			int mid = (lt + rt) / 2;
			if(get_hs(hs_a, i, i + mid - 1) == get_hs(hs_b, 1, mid))
			// 如果 A' 的前 mid 个字符能与 B 的前 mid 个字符匹配 
				lt = mid; 
			else
				rt = mid;
		}
		if(lt == -1) ans[0]++;
		else ans[lt]++;
	}
	while(q--)
	{
		int x;
		cin >> x;
		cout << ans[x] << "\n";
	}
	return 0;
}
```

---

## 作者：一只小咕咕 (赞：5)

[也许更好的阅读体验](https://www.cnblogs.com/yzxgg/p/18222922/solution-P10479)

[题目传送门](https://www.luogu.com.cn/problem/P10479)

### 思路
考虑 kmp，通过观察匹配文本串匹配过程，可以发现模式串所对应的 $j$ 的含义正是该模式串与文本串匹配到了一个从 $i-j+1$ 开始的长度为 $j$ 的公共前缀。

但这并不意味着是恰好匹配 $j$ 位，因为后面也许还可能可以匹配，但至少可以确定至少可以匹配 $j$ 位。所以我们直接用一个 $cnt$ 数组记录一下至少匹配 $x$ 位的有多少。

最后的结果就是 $cnt_{x+1} - cnt_x$ （也就是至少匹配 $x+1$ 位的个数减去至少匹配到 $x$ 位的个数就是恰好匹配到 $x$ 的个数）。

同时我们考虑 $nex$ 数组的性质，发现如果一个以 $i$ 结尾且与模式串匹配长度为 $j$ 的文本串，除了从 $i-j+1$ 开始可以匹配 $j$ 个，从 $i-nex_j+1$ 开始也同样可以（因为由于 $nex$ 记录的是最长公共前后缀的缘故，所以文本串的 $i-j+1$ 和 $i-nex_j+1$ 往后 $j$ 个是一样的），同理 $j-nex_{nex_j}+1$ 也是可以的，可以往后以此类推。

朴素的，我们可以想到让 $cnt_j$ 加一的同时，让 $cnt_{nex_j}$ 以及后面的都加一，但这样显然会超时。观察下我们操作 $cnt_j$ 的过程，每次都会让 $cnt_{nex_j}$ 加一，也就是说，$cnt_j$ 操作了多少次，$cnt_{nex_j}$ 也就要相应的执行多少次。那么我们就可以先只让 $cnt_j$ 加一，最后从 $m$ 到 $1$ 枚举一遍，让 $cnt_{nex_i}$ 加上 $cnt_i$ 就行了。

时间复杂度 $\mathcal{O}(n+m+q)$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
inline int read();
int n,m,q,nex[N],cnt[N]; 
char a[N],b[N];
int main()
{
	n=read(); m=read(); q=read();
	scanf("%s",(a+1));
	scanf("%s",(b+1));
	int j=0;
	for(int i=2; i<=m; i++)
	{
		while(j && b[i] != b[j+1]) j=nex[j];
		if(b[i] == b[j+1]) nex[i]=j+1;
		j=nex[i];
	}
	j=0;
	for(int i=1; i<=n; i++)
	{
		while(j && a[i] != b[j+1]) 
			j=nex[j];
		if(a[i] == b[j+1]) j++;
		cnt[j]++; 
	}
	for(int i=m; i>=1; i--) cnt[nex[i]]+=cnt[i];
	while(q--)
	{
		int x;
		x=read();
		printf("%d\n",cnt[x]-cnt[x+1]); 
	}
	return 0;
}
inline int read()
{
	int x=0,f=1;
	char ch;
	ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-') f=-f; ch=getchar();}
	while(ch<='9' && ch>='0')
	{
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
    return x*f;
}
```

---

## 作者：PineappleSummer (赞：3)

[P10479 匹配统计](https://www.luogu.com.cn/problem/P10479)

看到这个题直接想到 exkmp，因为题目就是 exkmp 模板的第二问。但是数据范围较小，可以通过 $O(n\log n)$ 的算法，所以打算用二分与哈希通过这道题。

首先 $O(n+m)$ 预处理两个串的哈希值。对于 $a$ 串的每个后缀，二分其与 $b$ 串的最长公共前缀的长度，并用哈希判断是否相等即可。得出 LCP 长度后统计答案即可。

二分的复杂度为 $O(\log n)$，枚举后缀的复杂度为 $O(n)$，哈希判断相等的复杂度为 $O(1)$，总时间复杂度为 $O(n\log n)$。

```cpp
ull get1 (int l, int r) { return h1[r] - h1[l - 1] * bs[r - l + 1]; }
ull get2 (int l, int r) { return h2[r] - h2[l - 1] * bs[r - l + 1]; }
int main () {
	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> n >> m >> q; bs[0] = 1;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		h1[i] = h1[i - 1] * base + ull (a[i]);
		bs[i] = bs[i - 1] * base;
	}
	for (int i = 1; i <= m; i++) {
		cin >> b[i];
		h2[i] = h2[i - 1] * base + ull (b[i]);
	}
	for (int i = 1; i <= n; i++) {
		int l = 1, r = n - i + 1;
		while (l < r) { // 二分 LCP 长度
			int mid = (l + r + 1) >> 1;
			if (get1(i, i + mid - 1) == get2 (1, mid))
				l = mid;
			else r = mid - 1;
		}
		if (a[i + l - 1] != b[l]) l = 0;
		cnt[l] ++; // 统计答案
	}
	while (q--) { 	
		int x; cin >> x;
		cout << cnt[x] << '\n';
	}
	return 0;
}
```

---

## 作者：shangruolin (赞：2)

扩展 KMP/exKMP（Z 函数）学习笔记兼 [P10479 匹配统计](https://www.luogu.com.cn/problem/P10479) 题解。

LCP：最长公共前缀。

**Z 函数**，又称**扩展 KMP（exKMP）**，能够在 $O(n)$ 的时间内求出一个字符串与其所有后缀的 LCP 的长度。

定义 $z_i$ 为字符串 $s$ 与字符串 $s$ 从第 $i$ 位开始的后缀的 LCP 长度。

那么求解 $z_i$ 便是我们的目标。直接暴力匹配复杂度为 $O(n^2)$。二分枚举长度再用哈希判断可以做到 $O(n\log n)$，足以通过本题。使用 Z 函数求解便可做到 $O(n)$ 求解。

假设现在已经求出了 $z_1\sim z_{i-1}$，想要求解 $z_i$。

定义 $r$ 为 $r$ 最大的匹配子串的右端点，$l$ 为 $r$ 最大的匹配子串的左端点。

那么如果 $i\le r$，$z_i$ 为 $\min(z_{i-l+1},r-i+1)$。通俗的解释一下：由定义知，$s_{l}\sim s_{i-1}$ 与 $s_1\sim s_{i-l}$ 是匹配的，则 
$s_i\sim s_r$ 与 $s_{i-l+1}\sim s_{r-l+1}$ 是匹配的，那么 $z_i$ 可以由 $z_{i-l+1}$ 继承而来。但是我们并不知道 $s_{r+1}$ 与 $s_{r-i+2}$ 是否匹配，所以 $z_i$ 需要对 $z_{i-l+1}$ 和 $r-i+1$ 取 $\min$。

接着，我们尝试进行暴力匹配，如果 $s_{i+z_i}$ 与 $s_{z_i+1}$ 相同，就让 $z_i$ 加 $1$。

暴力匹配完后更新 $l,r$ 即可。

Z 函数的复杂度是 $O(n)$ 的，因为每个字符至多被暴力匹配 $1$ 次。

求解 $z$ 数组的代码：
```cpp
z[1] = m; // 完全匹配
for (int i = 2, l = 0, r = 0; i <= m; i++) {
	if (i <= r) z[i] = min (z[i - l + 1], r - i + 1); // 获取初值
	while (i + z[i] <= m && b[i + z[i]] == b[z[i] + 1]) z[i] ++; // 暴力匹配
	if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1; // 更新 l, r
}
```

同样，我们定义 $p_i$ 为为字符串 $b$ 与字符串 $a$ 从第 $i$ 位开始的后缀的 LCP 长度。

则类似的，可以得到求解 $p_i$ 的代码：
```cpp
for (int i = 1, l = 0, r = 0; i <= n; i++) {
	if (i <= r) p[i] = min (z[i - l + 1], r - i + 1);
	while (i + p[i] <= n && a[i + p[i]] == b[p[i] + 1]) p[i] ++;
	if (i + p[i] - 1 > r) l = i, r = i + p[i] - 1;
	cnt[p[i]] ++; // 统计答案
}
```

对于每个询问，若询问长度为 $x$，则输出 $cnt_x$。

完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2e6 + 10;
int n, m, q, z[N], p[N], cnt[N];
char a[N], b[N];
int main () {
	scanf ("%d %d %d", &n, &m, &q); 
	scanf ("%s", a + 1);
	scanf ("%s", b + 1);
	z[1] = m;
	for (int i = 2, l = 0, r = 0; i <= m; i++) {
		if (i <= r) z[i] = min (z[i - l + 1], r - i + 1);
		while (i + z[i] <= m && b[i + z[i]] == b[z[i] + 1]) z[i] ++;
		if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
	}
	for (int i = 1, l = 0, r = 0; i <= n; i++) {
		if (i <= r) p[i] = min (z[i - l + 1], r - i + 1);
		while (i + p[i] <= n && a[i + p[i]] == b[p[i] + 1]) p[i] ++;
		if (i + p[i] - 1 > r) l = i, r = i + p[i] - 1;
		cnt[p[i]] ++;
	}
	while (q--) {
		int x; scanf ("%d", &x);
		printf ("%d\n", cnt[x]); 
	}
	return 0;
}
```

本文没有图解，对初学者来说可能比较抽象。想要更好理解 Z 函数的同学可以前往 [P5410 【模板】扩展 KMP/exKMP（Z 函数）](https://www.luogu.com.cn/problem/P5410) 的题解区学习。

大家有任何建议或疑惑都可以在评论中提出，感谢！

---

## 作者：Weekoder (赞：2)

### 思路

哈希 + 二分。事实上，这是在 [P3763 [TJOI2017] DNA](https://www.luogu.com.cn/problem/P3763) 的哈希做法中的一个小步骤：通过二分和比较哈希值来找到最长的前缀匹配。这是具有单调性的：如果前 $x$ 个字符串可以匹配，则前 $y(y<x)$ 个字符串也可以匹配；如果前 $x$ 个字符串不可以匹配，则前 $y(y>x)$ 个字符串也不可以匹配。可以通过二分来寻找最大的 $x$，配合哈希，可以做到 $\mathcal{O}(\log n)$ 的时间复杂度。

这道题就相对模板了。我们遍历字符串 $A$，并二分找到最大的 $x$。若 $ans_i$ 表示询问 $i$ 时的答案，则我们让 $ans_x$ 加 $1$，$ans_x\gets ans_x+1$。最后输出即可。

我用的是单哈希自然溢出，进制 $base$ 是 $10^9+7$。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long ull;

const int N = 2e5 + 5, base = 1e9 + 7;

int n, m, q, ans[N];

string a, b;

ull hsa[N], hsb[N], pw[N];

ull get_hash(ull hs[], int l, int r) {
    return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int find_pos(int pos) {
    int l = -1, r = min(n, m) + 1;
    while (l + 1 < r) {
        int mid = l + r >> 1;
        if (get_hash(hsa, pos, pos + mid - 1) == get_hash(hsb, 1, mid))
            l = mid;
        else    
            r = mid;
    }
    return l;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
    cin >> n >> m >> q >> a >> b;
    a = '#' + a, b = '#' + b;
    for (int i = 1; i <= n; i++)
        hsa[i] = hsa[i - 1] * base + a[i];
    for (int i = 1; i <= m; i++)
        hsb[i] = hsb[i - 1] * base + b[i];
    pw[0] = 1;
    for (int i = 1; i <= max(n, m); i++)
        pw[i] = pw[i - 1] * base;
    for (int i = 1; i <= n; i++) 
        ans[find_pos(i)]++;
    while (q --) {
        int x;
        cin >> x;
        cout << ans[x] << "\n";
    }
	return 0;
}
```

---

## 作者：JoeZYQ (赞：2)

### [先看题](https://www.luogu.com.cn/problem/P10479)
### 思路分析
####  一、考虑暴力
枚举每个单词后缀开始的位置，与 $B$ 匹配，但时间复杂度爆表，必定超时（不过有90分）。
#### 二、优化：二分+哈希
在暴力的基础上用二分优化匹配时找字符串的过程，用哈希优化匹配时判断两个字符串相不相等的过程，可将时间复杂度优化到惊人的 $O(n \times  \log n)$，成功AC。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5,jin_zhi=1e9+7;
#define int unsigned long long
string a,b;
int Hash_1[N],Hash_2[N],ci_fang[N],n,m,T,x,ans[N];
void init(){	
	a="A"+a,b="C"+b;
	ci_fang[0]=1;
	for(int i=1;i<=200000;i++)ci_fang[i]=ci_fang[i-1]*jin_zhi;
	for(int i=1;i<=n;i++)Hash_1[i]=Hash_1[i-1]*jin_zhi+a[i];
	for(int i=1;i<=m;i++)Hash_2[i]=Hash_2[i-1]*jin_zhi+b[i];
}
int get_hs1(int l,int r){return Hash_1[r]-Hash_1[l-1]*ci_fang[r-l+1];}
int get_hs2(int l,int r){return Hash_2[r]-Hash_2[l-1]*ci_fang[r-l+1];}
int find(int pos){
	int l=-1,r=min(n,m)+1;
	while(l+1<r){
		int mid=(l+r)/2;
		if(get_hs1(pos,pos+mid-1)==get_hs2(1,mid))l=mid;
		else r=mid;
	}
	return l;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>T;
	cin>>a>>b;
	init();
	for(int i=1;i<=n;i++)ans[find(i)]++;
	while(T--){
		cin>>x;
		cout<<ans[x]<<"\n";
	}
	return 0;
}
```

---

## 作者：smydahaoren (赞：0)

# 题解：P10479 匹配统计


## 思路 

使用字符串哈希，然后二分答案最大匹配长度。

## 解题方法

使用了自然溢出，跑一遍 $A$ 和 $B$ 字符串的哈希，然后根据题意，预处理 $A$ 字符串的每个前缀和 $B$ 字符串的匹配长度，储存到一个 $\texttt{map}$ 里面。（节约空间）

## 复杂度

### 时间复杂度:

$O(n\log n)$


### 空间复杂度:

$O(n)$

### 注意点：

洛谷评测机不接受函数名词为 `hash`。

## Code

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6,bs=1321;
int n,m,pw[N],T,hs_a[N],hs_b[N];
string a,b;
map<int,int> ans;
void Hash(string s,int len,int hs[]){
	for(int i=1;i<=len;i++)
	hs[i]=hs[i-1]*bs+s[i];
	return;
}
int gethash(int hs[],int l,int r){
	return hs[r]-hs[l-1]*pw[r-l+1];
}
bool check(int mid,int x){
	return gethash(hs_a,x,x+mid-1)==gethash(hs_b,1,mid);
}
int work(int x){
	int l=-1,r=min(n-x+1,m+1)+1;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(check(mid,x))
			l=mid;
		else r=mid;
	}
	return l;
}
signed main(){
	pw[0]=1;
	cin>>n>>m>>T;
	cin>>a>>b;
	a=" "+a;
	b=" "+b;
	Hash(a,n,hs_a);
	Hash(b,m,hs_b);
	for(int i=1;i<=max(n,m);i++)
	pw[i]=pw[i-1]*bs;
	for(int i=1;i<=n;i++){
		int x=work(i);
		ans[x]+=1;
	}
	while(T--){
		int x;
		cin>>x;
		cout<<ans[x]<<endl;
	}
	return 0;
}

```

---

## 作者：liyifan202201 (赞：0)

## 前话

 **hash** 好题目。

[集训](https://www.luogu.com.cn/contest/176126)的时候第二题是这个，考试时没有想到二分，打了暴力，在洛谷的~~满级~~评测机下，喜提 [$90$](https://www.luogu.com.cn/record/161730405)。
## 思路
1.  $a$ 串的后缀个数为 `a.size()`，枚举每个后缀开始的下标；

2. 设 $a$ 串的任⼀后缀的起始下标为 $i$，那么以 $i$ 为起点，可以与 $b$ 串匹配的⻓度可以枚举并检验，显然会超时；

3. 考虑⼆分答案优化与 $b$ 串匹配的⻓度，对于⼀个确定的后缀起始下标 $i$，时间复杂度 $O(\log N)$；

4.  维护 $ans_i$ 表示与b串匹配⻓度恰好为 $i$ 的 $a$ 串的后缀个数；

5.  总时间复杂度 $O(N \times \log N)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, base = 13331;
unsigned long long ha[N], pw[N], hb[N];
int n, ans[N], m, q;
string a, b;
unsigned long long get_hash(unsigned long long h[], int l, int r) { //截取⼦串 [L, R] 的哈希值
	return h[r] - h[l - 1] * pw[r - l + 1];
}
int erfen(int st) {
	int lt = -1, rt = min(a.size() - st, b.size()) + 1;
	while (lt + 1 < rt) {
		int mid = (lt + rt) / 2;
		// a 串从 st 开始与 b 串的前 mid 个字符匹配
		if (get_hash(ha, st, st + mid - 1) == get_hash(hb, 1, mid))
			lt = mid;
		else
			rt = mid;
	}
	return lt;
}
int main() {
	cin >> n >> m >> q;
	cin >> a >> b;
	a = " " + a;
	b = " " + b;
	for (int i = 1; i < a.size(); i++)
		ha[i] = ha[i - 1] * base + a[i];
	for (int i = 1; i < b.size(); i++)
		hb[i] = hb[i - 1] * base + b[i];
	pw[0] = 1;
	for (int i = 1; i < max(a.size(), b.size()); i++)
		pw[i] = pw[i - 1] * base;
	for (int i = 1; i <= n; i++) //枚举 a 串的后缀起始下标 i
		ans[erfen(i)]++;
	while (q--) {
		int x;
		cin >> x;
		cout << ans[x] << "\n"; //⻓度恰好匹配 B 串前 x 个字符的后缀个数
	}
	return 0;
}

```

---

## 作者：Limitless_lmw (赞：0)

利用 hash 做即可。

重点在于怎么利用 hash 值来比较两个字符串的大小（不能直接比较，因为有取模）。

可以用二分，找到两个串最后一个 hash 值相等的前缀位置，比较下一位即可。

Code（用 [P10469 后缀数组](https://www.luogu.com.cn/problem/P10469) 改的代码）:

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <bitset>
using namespace std;

using ull = unsigned long long;

int q;
string strA,strB;
ull base[200005];
ull preA[200005],preB[200005];

inline ull get_hashA(int l,int r){
    return preA[r]-preA[l-1]*base[r-l+1];
}

inline ull get_hashB(int l,int r){
    return preB[r]-preB[l-1]*base[r-l+1];
}

inline int get_Height(int p, int q){
    int l = 0;
    int r=max(strA.size()-p,strB.size()-q);
    while(l<r){
        int mid=l+r+1>>1;
        if(get_hashA(p,p+mid-1)==get_hashB(q,q+mid-1)){
            l=mid;
        }else{
            r=mid-1;
        }
    }
    return l;
}

int ans[200005];

int main(){
    cin>>q>>q>>q;
    cin>>strA>>strB;
    strA.resize(strA.size()+1);
    for(int i = strA.size()-1; i>=1; i--) strA[i]=strA[i-1];
    strA[0]='\0';
    strB.resize(strB.size()+1);
    for(int i = strB.size()-1; i>=1; i--) strB[i]=strB[i-1];
    strB[0]='\0';
    base[1]=1145141ull;
    for(int i = 2; i<strA.size(); i++){
        base[i]=base[i-1]*1145141ull;
    }
    for(int i = 1; i<strA.size(); i++){
        preA[i]=preA[i-1]*1145141ull+strA[i];
    }
    for(int i = 1; i<strB.size(); i++){
        preB[i]=preB[i-1]*1145141ull+strB[i];
    }
    for(int i = 1; i<strA.size(); i++){
        ans[get_Height(i,1)]++;
    }
    int opt;
    while(q--){
        scanf("%d",&opt);
        printf("%d\n",ans[opt]);
    }
    return 0;
}
```

---

## 作者：live_cxy110122 (赞：0)

# 题意
给定 $A$ 串和 $B$ 串，将 $A$ 串的所有后缀子串提取，给定 $Q$ 次询问，每次询问与 $B$ 串恰好匹配 $X$ 位的 $A$ 的后缀子串有多少个。

# 分析
- $A$ 串的长度为 $n$，其所有后缀共有 $n$ 个。
- 将 $n$ 个后缀子串暴力与 $B$ 串匹配，单次时间 $O(n + m)$，总时间 $O(n \times m)$。
- 维护 $ans_x$ 表示与 $B$ 串匹配长度恰好为 $x$ 的串的数量。
- 单词匹配考虑到有单调性，可以用倍增或者二分优化，我这里用二分。

# 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5, base = 13331;

unsigned long long ha[N], pw[N], hb[N];
int n, ans[N], m, q;
string a, b;

unsigned long long get_hash(unsigned long long h[], int l, int r) //截取s子串[L, R]的哈希值
{
    return h[r] - h[l-1] * pw[r-l+1];
}

int erfen(int st)
{
	int lt = -1, rt = min(a.size() - st, b.size()) + 1;
	while(lt + 1 < rt)
	{
		int mid = (lt + rt) / 2;
		if(get_hash(ha, st, st + mid - 1) == get_hash(hb, 1, mid)) //a串从st开始与b串的前mid个字符匹配
			lt = mid;
		else
			rt = mid;
	}
	return lt;
}

int main()
{
	cin>>n>>m>>q;
	cin>>a>>b;

	a = " " + a;
	b = " " + b;

	for(int i = 1; i < a.size(); i++)
		ha[i] = ha[i-1] * base + a[i];
	for(int i = 1; i < b.size(); i++)
		hb[i] = hb[i-1] * base + b[i];

	pw[0] = 1;
	for(int i = 1; i < max(a.size(), b.size()); i++)
		pw[i] = pw[i-1] * base;

	for(int i = 1; i <= n; i++) //枚举a串的后缀起始下标i
		ans[erfen(i)]++;

	while(q--)
	{
		int x;
		cin>>x;
		cout<<ans[x]<<endl;		//长度恰好匹配B串前x个字符的后缀个数
	}
	return 0;
}

```

---


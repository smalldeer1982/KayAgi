# 【模板】哈希表

## 题目背景

本题读入量较大，建议使用快速读入。

```
char buf[1<<23],*p1=buf,*p2=buf;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline unsigned long long rd() {//读入一个 64 位无符号整数
	unsigned long long x=0;
	char ch=gc();
	while(!isdigit(ch))ch=gc();
	while(isdigit(ch)) x=x*10+(ch^48),ch=gc();
	return x;
}
```

## 题目描述

你需要维护一个映射 $f:[0,2^{64})\to[0,2^{64})$，初始 $\forall x\in [0,2^{64}),f(x)=0$。

有 $n$ 次操作，每次操作给出二元组 $(x,y)$，表示查询 $f(x)$ 的值，之后 $f(x)\gets y$。

## 说明/提示

样例的 $ans$ 分别为：$0,4,0,20120712,1000000000000000000$。

对于 $100\%$ 的数据，$1\le n \le 5\times 10^6,0\le x,y<2^{64}$。

| 子任务 | $n$ |
| :----------: | :----------: |
| $0$ | $\le 10$ |
| $1$ | $\le 10^5$ |
| $2$ | $\le 10^6$ |
| $3$ | $\le 5\times 10^6$ |
| $4$ | $\le 5\times 10^6$ |

子任务 $0\sim 3$ 的数据生成方式较为随机，子任务 $4$ 是针对 `unordered_map`，`gp_hash_table`，`cc_hash_table` 和一些错误的哈希方式等的 hack。

如果你认为你的代码复杂度正确却没有通过，记得使用快速读入。

## 样例 #1

### 输入

```
5
0 4
0 998244353
1000000000000000000 20120712
1000000000000000000 1000000000000000000
1000000000000000000 998244353```

### 输出

```
5000000000080482856```

# 题解

## 作者：_fairytale_ (赞：47)

# 前言

在 THUWC2025 D1T2 中，作者的 $\mathcal O(n\log n)$ 做法拼尽全力卡常 3h 无法战胜 $n=500000$ 的数据。后来发现其中有一个只需查 $16n$ 次哈希表的 subtask 都没有通过。于是有了这道题用来警示后人记得使用较为高速且不容易被卡的哈希表，同时提供一道哈希表测速题。

# HACKS 

这里讲一下 hack 是怎么造的以及大概原理，想要了解更多，推荐阅读深度好文
[Blowing up unordered_map, and how to stop getting hacked on it](https://codeforces.com/blog/entry/62393)。

## unordered_map

`unordered_map` 使用的是将键值模一个质数的哈希方式，其中质数来自一个质数表 `__prime_list`，发现其中只有 [256 个质数](https://www.luogu.com.cn/paste/3vuhvyv4)。

但是据说在不同的地方选的质数不一样，那不管你选啥质数了，直接造四组数据，每组数据选其中的 $64$ 个，插入其倍数即可卡掉。

## gp_hash_table/cc_hash_table

这两个比较难绷，哈希方式是模 $2^{16}$，所以直接造一堆模 $2^{16}$ 同余的数即可卡掉。

# 如何避免被卡？

## unordered_map

这个比较简单，直接把所有键值异或上一个随机数即可破坏 hack 数据的同余性质。

```cpp
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
struct Hsh{
	ull operator ()(const ull&x)const{
		static const ull r=rnd();
		return x^r;
	}
};
unordered_map<ull,ull,Hsh>f;
```

但是 `unordered_map` 还有一个缺陷就是跑得太慢，在本题要跑 2s 以上，虽然本题不卡常，但是我们总会在某个时候需要更快的哈希表。

## gp_hash_table/cc_hash_table

这两个因为本来就是模 $2^{16}$，相当于取二进制后 $16$ 位，所以异或一个随机数并不改变 hack 数据模 $2^{16}$ 同余的性质。

在 CF 上的那篇文章里作者使用了 `splitmix64` 作为哈希函数：

```cpp
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
```

但是这里的三个神秘数字有点难背，有什么更好记的写法吗？

有的兄弟，有的。我们直接用随机数替代神秘数字：

```cpp
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
struct Hsh{
	ull operator ()(ull x)const{
		static const ull s1=rnd(),s2=rnd(),s3=rnd();
		x+=s1;
		x=(x^(x>>33))*s2;
		x=(x^(x>>30))*s3;
		return x;
	}
};
gp_hash_table<ull,ull,Hsh>f;
```
实测这样和 `splitmix64` 效果差不多。

这样修改过的 `gp_hash_table` 在本题跑了 1s 左右，而 `cc_hash_table` 却跟 `unordered_map` 效率一样。

## 手写哈希表

有时我们需要更小的常数，这个时候就需要手写哈希表，这里就不多介绍了。

```cpp
const int LEN=(1<<23);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
struct HashMap {
	inline ull F(ull x) {
		static const ull s1=rnd(),s2=rnd(),s3=rnd();
		x+=s1;
		x=(x^(x>>33))*s2;
		x=(x^(x>>30))*s3;
		return x;
	}
	bitset<LEN+5>hav;
	ull key[LEN+5];
	ull value[LEN+5];
	int gt(const ull&x) {
		int i=F(x)&(LEN-1);
		while(hav[i]&&key[i]!=x)i=(i+1)&(LEN-1);
		hav[i]=1,key[i]=x;
		return i;
	}
	ull& operator[](const ull&x) {
		return value[gt(x)];
	}
}f;
```

但是我写的好像比较烂，只比 `gp_hash_table` 快了 100ms 左右，欢迎大家分享自己更快的哈希表！

# 结语

愿世界上没有卡常题。

---

## 作者：xingshuyan000 (赞：31)

# 题解：P11615 【模板】哈希表

**这是一道哈希表的模板题，我这篇题解将会详细讲解哈希表及相关操作。**

[题目传送门：洛谷 P11615](https://www.luogu.com.cn/problem/P11615)

~~（其实我是现学现用的，刚刚学会）~~

声明：这篇题解中的部分内容引用来自百度百科或 OI-wiki。

## 哈希表

哈希表也叫散列表。

我们先来看一下[百度百科上](https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869)对于哈希表的定义：

>散列表（Hash table，也叫哈希表），是根据关键码值（key-value）而直接进行访问的数据结构。也就是说，它通过把关键码值**映射**到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数，存放记录的数组叫做哈希表。

所谓的以 key-value 的形式存储数据，是指**任意的**键值 key（以下用 $k$ 来表示） 都**唯一对应**到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value（以下用 $v$ 来表示）。我们可以把哈希表理解为一个高级的数组，这里的数组下标可以是一个大整数、浮点数、字符串，甚至可以是个结构体。

下面举几个以 key-value 的形式存储数据的例子：

|$\textbf{key}$|$\textbf{value}$|
|:-:|:-:|
|$\textup{paper}$|$1$|
|$52013145201314$|$2$|
|$1919810.114514$|$3$|
|$\textup{boyfriend}$|$4$|
|$\textup{girlfriend}$|$5$|

就是类似于上面这样的。

## 哈希函数

**定义：** 要让键值对应到内存中的位置，就要为键值计算索引，也就是计算这个数据应该放到哪里。这个根据键值计算索引的函数就叫做哈希函数，也称散列函数。

其实，哈希函数就是一个映射，这个映射可以把一个 $x$ 值映射为一个 $y$ 值。比如，当 $x$ 是一个范围为 $[-10^9,10^9]$ 的整数时，我们可以通过映射 $f$，把这个值映射到一个取值区间在 $[0,10^5]$ 的整数 $y$ 上。一般来说，这种操作需要你选取一个较大的质数 $M$，让 $f(x)= x \mod M$，这样成为一个哈希函数。

当 key 值是一个字符串时，我们需要用到字符串哈希，这里可以移步至 [P3370](https://www.luogu.com.cn/problem/P3370) 这道题，那里面的题解会有字符串哈希的讲解，我在这儿就不多讲了。

## 哈希冲突

经过前面的讲解，我们容易发现一个问题，如果对同一个数取模，可能会出现不同的键值被映射到了同一个数上面，这就叫做哈希冲突。比如，当模数为 $5$ 时，$f(2)=2,f(7)=2,f(12)=2$，这就发生了哈希冲突。为了处理哈希冲突，在 OI 中，主要有两种方法：拉链法和开放寻址法。下面，我将分别来讲解这两种方法。

### 处理哈希冲突的方法一：拉链法

拉链法又称为开散列法。

首先，我们开一个一维数组，大小为你的模数，比如你现在要对 $10^5$ 取模，那么我们就开一个大小为 $10^5$ 的数组，这样从左到右依次是 $0,1,2,\cdots,10^5-1$，每个数对应一个位置，这个数组的每个位置可以对应每一个取模结果。然后，在原数的取模结果对应位置下面拉一条链，依次连上原数。因为哈希表是一种期望算法，尽管每个位置都会拉下来一条链，但平均下来，每一条链都是非常短的，所以，拉链法的时间复杂度可以近似为 $O(1)$，时间复杂度还是很好的。

拉链法的大致结构如下图，以上面的 $10^5$ 为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/lihxfqvk.png)

~~（突然感觉有点像一堆糖葫芦）~~

我们一般用到的哈希表操作是添加操作和查询操作，很少会用到删除操作。

**添加操作**：要求你插入一个数 $x$，那就直接计算 $x$ 的哈希值 $f(x)$，找到数组上对应的位置，然后把数 $x$ 加到下面的链上就好了。

**查询操作**：要求你查找一个数 $x$ 是否存在于哈希表中，那就找到 $x$ 对应的哈希值，然后去下面的链表里面找找，看能否找到 $x$。

**删除操作**：要求你把这个哈希表里的某个数 $x$ 删除，其实并不是真的删除掉这个数，你用一个 bool 变量给对应的数 $x$ 打上标记就好了。

**拉链法的 C++ 核心代码（一般模板，不针对本题）：**

```cpp
//拉链法
const int N = 1e7 + 19; //大于1e7最小的质数，可以直接写个程序跑一下
struct Hash{
	int h[N]; //哈希表
	int e[N], ne[N], idx = 0; //这是链表的东西
	void insert(int x) //插入一个数x
	{
		int k = (x % N + N) % N; //k是x对应的哈希值
        //为什么要 (x % N + N) % N 呢？因为处理的时候
        //可能会遇到x是负数的情况，如果对负数取模，
        //结果也是负数，而我们要的是非负整数值，所以
        //通过这样把取模结果转化为非负数
		e[idx] = x;
		ne[idx] = h[k];
		h[k] = idx ++; //链表的基本操作
		return;
	}
	bool find(int x) //查找x
	{
		int k = (x % N + N) % N; //计算x的哈希值
		for(int i = h[k]; i != -1; i = ne[i])
			if(e[i] == x) return true; //如果找到了，返回true
		return false; //遍历完了都没找到，返回false
	}
	void init()
	{
		memset(h, -1, sizeof(h)); //初始化，让h中的初始值都为-1
		return;
	}
};
```

### 处理哈希冲突的方法二：开放寻址法

开放寻址法，也是一种常用的处理哈希冲突的方法，其基本思想就是，寻找哈希表中的下一个空位，然后把元素直接扔到这个空位当中。

开放寻址法只需要开一个一维数组即可，不需要再手动模拟链表了，在形式上看来会简单一点。一般来说，开放寻址法开的一维数组大小是数据量的 $2 \sim 3$ 倍，比如本题中的数据量是 $5 \times 10^6$，那么开放寻址法开的数组大小就要达到 $10^7$ ，这样可以减小哈希冲突。

我们可以这么理解开放寻址法：把开放寻址法的数组当成一个巨大的食堂，数组中的每个位置当成食堂中的餐桌，每个餐桌只能容纳一个人。我们去食堂买完饭以后，肯定需要去找地方坐，那么按照一般思路，我们就会从第一个餐桌开始，往后依次寻找第一个空闲的餐桌。如果第 $i$ 号餐桌有人，我们就会继续找第 $i+1$ 号餐桌，如果还有人我们会继续找第 $i+2$ 号餐桌，以此类推，直到找到一个空闲的，然后就坐。 _（可能这个例子并不完全符合开放寻址法的思路，但基本就是这个意思，这样相对更容易理解一些）_ 

同样，开放寻址法对应三种操作：添加、查询和删除。

**添加操作**：要求你往哈希表中插入一个数 $x$，那么你仍然先计算出来 $x$ 的哈希值 $k$，然后从哈希表中**第 $k$ 个位置开始**，往后找到第一个没有被占用的位置，然后把 $x$ 扔到这个位置上。

**查询操作**：要求你在哈希表中查找一个数 $x$，那么还是先求出来他的哈希值 $k$，然后从第 $k$ 个位置开始依次往后找，如果在第 $i$ 个位置找到了，那么 $x$ 就存在于第 $i$ 个位置上，如果发现中间位置是空的而且仍然没找到，那么，就说明 $x$ 不存在。

**删除操作**：要求你删除哈希表中的一个数 $x$，跟拉链法的思路差不多，都是直接用一个 bool 变量给 $x$ 标记出来，而并不是真的把这个数 $x$ 删掉。

**开放寻址法的 C++ 核心代码（一般模板，不针对本题）：**

```cpp
//开放寻址法
const int N = 1e7 + 19;
struct Hash_table{
	const int null = 0x3f3f3f3f; //相当于一个空指针
	int h[N]; //哈希表
	void init()
	{
		memset(h, 0x3f, sizeof(h));
		return;
	}
	int find(int x) //在哈希表中查找x
	{
		int k = (x % N + N) % N; //x的哈希值
		while(h[k] != null && h[k] != x) //如果一直没找到x
		{
			k ++;
			if(k == N) k = 0; //如果找到了最后一个，就要从第一个开始，让k=0
		}
		return k; //返回x的位置（找到）或x应当存在的位置（未找到）
	}
	void insert(int x) //插入x
	{
		int k = find(x);
		h[k] = x;
		return;
	}
};
```
注意：在 C++ 中，函数名不能定义为 hash，因为 hash 是 C++ 中的保留字，如果定义为了 hash，容易编译错误。

## 针对本题的分析

其实这道题也就是个哈希表的模板题。他让你维护一个从 $[0,2^{64}-1]$ 到 $[0,2^{64}-1]$ 的映射 $f$，初始值函数值都为 $0$。给你 $n$ 次询问，每次询问给定一个二元数组 $(x,y)$，你需要查找 $f(x)$ 的值，然后把 $y$ 赋值给 $f(x)$。其中，$n \le 5 \times 10^6$，$0 \le x,y < 2 ^{64}$。

它让你找 $f(x)$ 的值，然后把 $y$ 赋值给 $f(x)$，那显然得用开放寻址法处理冲突。这里面只需要把我刚才放的模板代码稍微修改一下即可，可以完美解决这个问题。

时间复杂度为 $O(n)$，可以通过本题。

不过请注意，本题的输入数据量可以达到 $10^7$，常数很大，需要注意读入的优化，比如可以直接用本题给你的快读，这个效率很高，适合处理较大的读入量。同时，因为数据量大，所以不要使用 unordered_map、gp_hash_table、cc_hash_table 等错误的哈希方式写代码，这些错误方式在 subtask4 容易被卡掉。

## CODE

我发现我的代码跟某个题解的代码重复了，不过声明一下，我没有抄袭哈，这是我自己写的。

测试点所用最常时间：1.03s；最大内存：166.86MB。可以完美通过本题。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long LL;
namespace fast_IO
{
	char buf[1 << 23], *p1 = buf, *p2 = buf;
	char __getchar()
	{
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
	}
	template <typename T>
	T read()
	{
		T x = 0;
		char ch = __getchar();
		while(!isdigit(ch)) ch = __getchar();
		while(isdigit(ch)) {x = x * 10 + (ch ^ 48); ch = __getchar();}
		return x;
	}
}
const int N = 1e7 + 19;
struct Hash_table{
	LL h[N], kk[N]; 
	bool exist[N];
	void init() //其实这个函数要不要都行
	{
		memset(h, 0, sizeof(h));
		memset(kk, 0, sizeof(kk));
		memset(exist, false, sizeof(exist));
		return;
	}
	void insert(LL x, LL y)
	{
		int k = x % N; //因为输入的都是正数，所以就不用再 +N 了
		while(exist[k] == true)
		{
			if(kk[k] == x) break;
			k ++;
			if(k == N) k = 0;
		}
		kk[k] = x, h[k] = y;
		exist[k] = true;
		return;
	}
	LL find(LL x)
	{
		int k = x % N;
		while(exist[k] == true)
		{
			if(kk[k] == x) return h[k];
			k ++;
			if(k == N) k = 0;
		}
		return 0;
	}
};
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int n;
	n = fast_IO::read<int>();
	Hash_table hash_table;
	hash_table.init();
	LL sum = 0;
	for(int i = 1; i <= n; i ++)
	{
		LL x, y;
		x = fast_IO::read<LL>(), y = fast_IO::read<LL>();
		LL ans = i * hash_table.find(x);
		sum += ans;
		hash_table.insert(x, y);
	}
	cout << sum << "\n";
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：11)

虽然可以用 Hash，但是离散化未尝不可。

因为数据可离线。

先将第一维的数[基数排序](https://www.luogu.com.cn/article/z30yam5j)。

然后去重离散化。

然后不能二分，二分带 $\log$。

发现除了 $x$ 的其他数的操作不能影响到 $x$。

所以对每个数用 `vector` 按时间顺序记录修改它的操作。

遍历每个 `vector`，用 `ans` 数组记录答案。

完了？

完了。

~~玩 florr 去喽~~！

---

## 作者：stripe_python (赞：10)

第一次写【模板】开头的题解。

本文的代码基于这个板子写：

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace FastIO {
#ifndef SPN_LOCAL
	const int SZ = 1 << 18; char *p1, *p2, buf[SZ];
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, SZ, stdin), p1 == p2) ? EOF : *p1++)
#endif
	inline void skip() {for (char ch = getchar(); ch == ' ' || ch == '\n' || ch == '\t'; ch = getchar());}
	
	int t; char ch;
	template <typename T> inline void read(T& x) {x = 0, t = 1, ch = getchar(); for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') t = -1; for (; '0' <= ch && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48); x *= t;}
	inline void read(char& x) {skip(), x = getchar();}
	template <typename T, typename... Args> inline void read(T& t, Args&... args) {read(t); read(args...);}
	template <typename It> inline void read(const It& begin, const It& end) {for (It it = begin; it != end; it++) read(*it);}
} using namespace FastIO;

using uint64 = unsigned long long;

uint64 x, y;
const int M = 5000011;

struct Hash {
	map<uint64, uint64> a[M];
	
	int h(uint64 x) {return x % M;}
	
	uint64 get(uint64 x);
	void set(uint64 x, uint64 y);
} mp;

signed main() {
	int q; read(q);
	uint64 res = 0;
	for (int i = 1; i <= q; i++) {
		read(x, y);
		res += i * mp.get(x);
		mp.set(x, y);
	}
	cout << res;
	return 0;
}
```

# 思路

构造一个特征函数 $h(x)$，把 $x$ 映射到 $h(x)$ 上。OI 内，通常采用 $h(x) = x \bmod M$ 的方法，其中 $M$ 通常取质数。

但是总会出现 $a \ne b$ 而 $h(a) = h(b)$ 的情况，这种情况称作**哈希冲突**。下面的方法就是处理哈希冲突的方法。

# 拉链法

用一个链表把冲突的键值对拉在一起。写过链式前向星应该很好理解代码。

```cpp
struct Hash {
	struct node {
		int next;
		uint64 x, y;
	} edge[M];
	int tot = 0, head[M];
	
	int h(uint64 x) {return x % M;}
	
	uint64 get(uint64 x) {
		for (int j = head[h(x)]; j != 0; j = edge[j].next) {
			if (edge[j].x == x) return edge[j].y;
		}
		return 0;
	}
	void set(uint64 x, uint64 y) {
		for (int j = head[h(x)]; j != 0; j = edge[j].next) {
			if (edge[j].x == x) return edge[j].y = y, void();
		}
		edge[++tot].next = head[h(x)], edge[tot].x = x, edge[tot].y = y, head[h(x)] = tot;
	}
} mp;
```

## 拉链法 + 平衡树

使用 `std::map` 实现的红黑树替代链表，代码较短，但是常数较大。

```cpp
struct Hash {
	map<uint64, uint64> a[M];
	
	int h(uint64 x) {return x % M;}
	
	uint64 get(uint64 x) {
		return a[h(x)][x];
	}
	void set(uint64 x, uint64 y) {
		a[h(x)][x] = y;
	}
} mp;
```

## 拉链法 + vector

使用 vector 替代链表。当然用 list 也可以。

~~用 deque？MLE 警告！~~

```cpp
struct Hash {
	vector<pair<uint64, uint64>> a[M];
	
	int h(uint64 x) {return x % M;}
	
	uint64 get(uint64 x) {
		for (const auto& i : a[h(x)]) {
			if (i.first == x) return i.second;
		}
		return 0;
	}
	void set(uint64 x, uint64 y) {
		for (auto& i : a[h(x)]) {
			if (i.first == x) return i.second = y, void();
		}
		a[h(x)].emplace_back(x, y);
	}
} mp;
```

# 闭散列法

直接把所有记录存下来，如果冲突就接着找。

```cpp
struct Hash {
	pair<uint64, uint64> a[M];
	
	int h(uint64 x) {return x % M;}
	
	uint64 get(uint64 x) {
		int i = h(x), j = 1; 
		for (; a[i].first != x && a[i].second != 0; j++) i = (i + j) % M;   
		a[i].first = x;
		return a[i].second;
	}
	void set(uint64 x, uint64 y) {
		int i = h(x), j = 1; 
		for (; a[i].first != x && a[i].second != 0; j++) i = (i + j) % M;   
		a[i].first = x, a[i].second = y;
	}
} mp;
```

## 二次探测法

一个一个向后找稍有些慢，我们可以一次跳过 $j^2$ 个位置。

```cpp
struct Hash {
	pair<uint64, uint64> a[M];
	
	int h(uint64 x) {return x % M;}
	
	uint64 get(uint64 x) {
		int i = h(x), j = 1; 
		for (; a[i].first != x && a[i].second != 0; j++) i = (i + j * j) % M;   
		a[i].first = x;
		return a[i].second;
	}
	void set(uint64 x, uint64 y) {
		int i = h(x), j = 1; 
		for (; a[i].first != x && a[i].second != 0; j++) i = (i + j * j) % M;   
		a[i].first = x, a[i].second = y;
	}
} mp;
```

# 性能测试

最后附上本文所有方法在本题的用时。没有任何刻意卡常。

~~拉链法比较？存图方法比较！~~

|方法|总用时 / s|link|
|:-:|:-:|:-:|
|拉链法 + 链式前向星|$2.32$|[200878511](https://www.luogu.com.cn/record/200878511)|
|拉链法 + 平衡树|$4.49$|[200878147](https://www.luogu.com.cn/record/200878147)|
|拉链法 + vector|$3.39$|[200878802](https://www.luogu.com.cn/record/200878802)|
|拉链法 + list|$3.96$|[200878894](https://www.luogu.com.cn/record/200878894)|
|闭散列法 + 线性探测|$2.12$|[200879437](https://www.luogu.com.cn/record/200879437)|
|闭散列法 + 二次探测|$2.07$|[200879421](https://www.luogu.com.cn/record/200879421)|

总结：数据规模较大时，闭散列法通常比拉链法快一些。如果需要手写哈希表卡常，可以使用闭散列法 + 二次探测。

---

## 作者：Soviet_Onion (赞：7)

## P11615 【模板】哈希表
### 暴力思路
第一眼看到题面，立刻使用了 STL 中的 map 按题意进行映射。代码实现非常简单。时间复杂度约为 $O(N\log N)$，有较大常数。
```cpp
#include<iostream>
#include<unordered_map>
#define ll unsigned long long
using namespace std;
unordered_map<ll,ll>m;
int n;
ll x,y,ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%llu%llu",&x,&y);
		ans+=i*m[x];
		m[x]=y;
	}
	printf("%llu\n",ans);
	return 0;
}
```
结果也一样简洁明了：~~鲜艳的~~ [TLE](https://www.luogu.com.cn/record/202641148)。

### 优化
可以使用另一种映射 unordered_map，可以减小常数。

但是结果一样，仍然[超时](https://www.luogu.com.cn/record/202641233)。

### 正解：在线哈希表
哈希表，就是对于上述思路的优化。题目中给定的 $x$ 在 $[0,2^{64})$ 内，范围非常大。哈希就像离散化，将 $[0,2^{64})$ 范围的数通过哈希函数 $H(x)=x \bmod P$ 映射到一个较小的范围内，比如 $10^6$。其中 $P$ 是一个相对较小的质数，我们取 $10^6+3$。

所以我们需要开 $10^6+10$ 个 unordered_map，对于每次询问，直接输出 $m_{x\bmod P,x}$ 的值，然后对其进行更改。可这样以大幅度节省时间。如果只是使用映射，会被出题人卡掉一个点。各位可以去看出题人题解中的详细 hack 方法。


这样的时间复杂度是 $O(N\log N)$，但是常数较小，有时可以达到 $O(1)$ 复杂度。

注意 $P$ 不要开太大，容易 MLE。

```cpp
#include<iostream>
#include<unordered_map>
#define ll unsigned long long
#define getchar() (tt==ss&&(tt=(ss=In)+fread(In,1,1<<20,stdin),ss==tt)?EOF:*ss++)
using namespace std;
char In[1<<20],*ss=In,*tt=In;
const int N=1e6+10;
const int P=1e6+3;
ll read(void){ll f=1,res=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){res=res*10+(ch-'0');ch=getchar();}return res*f;}
void write(ll x){if(x<0){putchar('-');x=-x;}if(x>=10) write(x/10);putchar((x%10)+'0');return;}
unordered_map<ll,ll>m[N];
ll a,b,r,ans;
int n;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a=read(),b=read();
		r=a%P;
		ans+=i*m[r][a];
		m[r][a]=b;
	}
	write(ans),putchar('\n');
	return 0;
}
```
### 离线做法
非常简单且跑得飞快。

先读入所有询问，然后以 $x$ 为第一关键字，以读入顺序为第二关键字排序。依次处理后再以读入顺序排序，就可以直接得到答案。该做法的瓶颈在于 sort 排序，所以时间复杂度是 $O(N\log N)$。但是 sort 比较优秀，常数远远小于映射，可以跑到一秒以内。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
#define pb push_back
#define ll unsigned long long
#define getchar() (tt==ss&&(tt=(ss=In)+fread(In,1,1<<20,stdin),ss==tt)?EOF:*ss++)
using namespace std;
char In[1<<20],*ss=In,*tt=In;
const int N=5e6+10;
struct Node1{
	ll x;
	ll y;
	int id;
	friend bool operator <(const Node1 a,const Node1 b){
		if(a.x!=b.x) return a.x<b.x;
		return a.id<b.id;
	}
}a[N];
struct Node2{
	ll ans;
	int id;
	friend bool operator <(const Node2 a,const Node2 b){
		return a.id<b.id;
	}
}b[N];
int n;
ll res;
ll read(void){ll f=1,res=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){res=res*10+(ch-'0');ch=getchar();}return res*f;}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i].x=read();
		a[i].y=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;){
		int l=i,r=i;
		while(i<=n&&a[r].x==a[l].x) r=++i;
		r--;
		for(int j=l;j<=r;j++) b[j]={(j-1<l?0ll:a[j-1].y),a[j].id};
	}
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++){
		res+=i*b[i].ans;
	}
	printf("%llu\n",res);
	return 0;
}
```

---

## 作者：zlqwq (赞：5)

如果大家不会哈希表的话，可以去看一下 oi-wiki。

这里解释一下这个算法。

首先，哈希表大概是在维护一个链表结构，然后抽象到图上大概是一个树。

同时，它也支持插入，查询，删除等操作。

查询：对于一个 $x$，找到 $x$ 的值，然后顺着链表往下遍历。

插入：通过找出 $x$ 的哈希值，把 $x$ 顺着树往数组里存储。

删除：如果暴力删除的话，时间复杂度就变成了 $O(n)$，这样就失去了哈希表的优势。我们考虑开一个标记数组，把 $x$ 标记上即可，时间复杂度 $O(1)$。

维护的操作就是这样，然后不要忘了取模。

---

## 作者：CuteMurasame (赞：5)

善用 STL！

使用 `unordered_map`、`gp_hash_table` 或 `cc_hash_table`，发现都被卡死了。

有救吗？当然有。

参考这篇 Codeforces 博客：<https://codeforces.com/blog/entry/62393>。我们给 hash 值添加当前时间，被卡的概率就会大大降低。然后就可以直接使用 `unordered_map`、`gp_hash_table` 或 `cc_hash_table` 了！

示例代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define int uint64_t
#define rep(i,a,b) for(int i(a);i<=(b);++i)
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf,ubuf[1<<23],*u=ubuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
template<typename TP> inline TP read(TP &num)
{
	TP x=0;
	int f=0;
	char ch=getchar();
	while(ch<48||ch>57) f|=ch=='-',ch=getchar();
	while(48<=ch&&ch<=57) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return num=f?-x:x;
}
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
int n,x,y,ans;
__gnu_pbds::gp_hash_table<int,int,custom_hash> hashmap;
signed main()
{
	read(n);
	rep(i,1,n)
	{
		read(x),read(y);
		ans+=i*hashmap[x];
		hashmap[x]=y;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11615)

我们可以用**链地址法**来解决哈希冲突。

用一个结构体表示链表中的节点，$k$ 存储键，$v$ 存储值，$nxt$ 存储下一个节点的索引，通过这种方式就可以将冲突的键值对连接成一个链表，再用一个 $head$ 数组存储每个哈希桶对应的链表的头节点索引，初始化为 $-1$ 表示链表为空。

每次输入一个键 $x$ 和一个值 $y$，调用函数进行查询和更新，然后将结果储存在 $p$ 中，再累加 $i\times p$ 到答案最后输出。这个函数就是先用取模运算将 $x$ 映射到哈希表的一个位置 $pos$，然后遍历哈希桶 $pos$ 对应的链表，检查是否存在键 $x$，如果找到就将其原来的值赋给 $p$，并更新为新值 $y$；如果键 $x$ 不存在就将 $p$ 置为 $0$，表示原来的值为 $0$，然后创建一个新的节点，将键值对存储在该节点中，并将其插入到链表的头部。

```cpp
#include <iostream>
#include <cstring>

using namespace std;
using ULL = unsigned long long;

char buf[1 << 23], *p1 = buf, *p2 = buf;
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
inline ULL rd() {
    ULL x = 0;
    char ch = gc();
    while (!isdigit(ch)) ch = gc();
    while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = gc();
    return x;
}

const int N = 5e6 + 5;
const int M = 1e7 + 7;

struct Edge
{
    ULL k, v;
    int nxt;
} e[N];

int head[M], cnt;

void insert(ULL x, ULL y, ULL &p)
{
    int pos = x % M;
    for (int i = head[pos]; i != -1; i = e[i].nxt)
        if (e[i].k == x)
        {
            p = e[i].v;
            e[i].v = y;
            return;
        }
    p = 0;
    e[cnt].k = x;
    e[cnt].v = y;
    e[cnt].nxt = head[pos];
    head[pos] = cnt++;
}

int main()
{
    int n = rd();
    memset(head, -1, sizeof head);
    cnt = 0;
    ULL ans = 0;
    for (int i = 1; i <= n; i++)
    {
        ULL x = rd(), y = rd(), p;
        insert(x, y, p);
        ans += (ULL)i * p;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：gavinliu266 (赞：3)

# 思路
我们知道，哈希可能被卡，当哈希冲突较多时可能超时。

于是我们考虑哈希冲突时使用拉链法，但是使用 `map` 代替链表，这样保证最坏单次 $O(\log n)$，期望单次 $O(1)$。

但是常数很大，需要合理调参。

# 代码实现
可以跑进 2 秒，[记录](https://www.luogu.com.cn/record/200816962)。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
mt19937 gen(time(NULL));
const ll N = 6.7e6 + 5;
const ll M = 6.7e6 - gen() % 50 - 1;
// 防卡。当然，可以出 50 组数据来都卡一遍，但是这样其它最坏单次 O(n) 的也都可以卡没
char buf[1 << 17], *p1 = buf, *p2 = buf;
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<16, stdin), p1==p2) ? EOF : *p1++)
inline ll rd() {
	ll x = 0;
	char ch = gc();
	while(ch < '0' || ch > '9') ch = gc();
	while(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch=gc();
	return x;
}
int n;
ll x, y;
map<ll, ll> hsh[N];
int main() {
    scanf("%d", &n);
    ll ans = 0;
    for(ll i = 1; i <= n; ++i) {
        x = rd(), y = rd();
        int h = x % M;
        ans += i * hsh[h][x];
        hsh[h][x] = y;
    }
    printf("%llu\n", ans);
}
```

---

## 作者：lzx111218 (赞：3)

# P11615 【模板】哈希表
[题目传送门](https://www.luogu.com.cn/problem/P11615)
## 思路

可爱卡常题，建议把时间限制改到 $1$ 秒以内。

操作次数会达到 $5 × 10^6$，而且每个键和对应的值都是 64 位整数，所以直接用一个 $2^{64}$ 大小的哈希表显然是不现实的。我们手写哈希表。

~~unordered_map 会 TLE。~~

首先，得解决**内存问题**。由于无法为每个可能的键分配空间，我们可以通过开放寻址法（比如线性探测）来处理哈希冲突。开放寻址法的基本思想是，当哈希表中的某个位置已经被占用时，我们就向后查找，直到找到一个空位置。这种方法避免了太多的额外开销，而且能够有效利用有限的内存空间。通常情况下，$N = 10^7$ 就够了。

**查询和更新**就比较 so easy 了。每次操作时，给定一个键 $x$ 和一个值 $y$，我们首先要查找哈希表中这个键对应的值。如果找到了，就返回当前值；如果没找到，返回 $0$。查询完之后，再把哈希表中这个键的值更新为 $y$。这样每个键值对都会在哈希表里保持最新状态。

**加权和计算：**
每次查询后，我们需要按照顺序将查询结果加到总和里，最后返回加权和对 $2^{64}$ 取模的结果即可。

**时间/空间复杂度均为** $O(n)$。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
namespace fastIO{char *p1,*p2,buf[100000];
	#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
	inline void read(int&n){int x=0,f=1;char ch=nc();while(ch<48||ch>57){if(ch=='-'){f=-1;}ch=nc();}while(ch>=48&&ch<=57){x=(x<<3)+(x<<1)+(ch^48),ch=nc();}n=x*f;}
	inline void read(string&s){char ch=nc();while(ch==' '||ch=='\n'){ch=nc();}while(ch!=' '&&ch!='\n'){s+=ch,ch=nc();}}
	inline void read(char&ch){ch=nc();while(ch==' '||ch=='\n'){ch=nc();}}
	inline void write(int x){if(x<0){putchar('-'),x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');return;}
	inline void write(const string&s){for(register int i=0;i<(int)s.size();i++){putchar(s[i]);}}
	inline void write(const char&c){putchar(c);}
}using namespace fastIO;
constexpr int N = 1e7 + 3;
int key[N];  
int value[N];  
bool used[N];  
inline size_t ha(int x) {
    return x % N;
}
inline void insert(int k, int v) {
    size_t pos = ha(k);
    while (used[pos] && key[pos] != k) {  
        pos = (pos + 1) % N;
    }
    key[pos] = k;
    value[pos] = v;
    used[pos] = true;
}
inline int find(int k) {
    size_t pos = ha(k);
    while (used[pos]) {
        if (key[pos] == k) {
            return value[pos];
        }
        pos = (pos + 1) % N;  
    }
    return 0;  
}
int sum;
signed main() {
    int n;
    read(n);
    for (register int i = 1; i <= n; i++) {
        int x,y;
        read(x);
        read(y);
        int ans = find(x); 
        insert(x, y);  
        sum += i * ans;
    }
    write(sum);
    return 0;
}
```

---

## 作者：Zhl2010 (赞：1)

这是我写的最简单的题解，因为这道题我们可以用离线算法做。

首先记录下每组 $x$ 和 $y$ 的编号。

我们将数组按 $x$ 大小排序，然后对于相同的 $x$ 对答案的贡献统一处理。

每一次修改只对下一次询问有影响，末尾的修改并无任何意义，第一次的询问也没有意义。

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline unsigned long long rd() {//读入一个 64 位无符号整数
	unsigned long long x=0;
	char ch=gc();
	while(!isdigit(ch))ch=gc();
	while(isdigit(ch)) x=x*10+(ch^48),ch=gc();
	return x;
}

int n;
struct node{
	int x,y,id;
}a[5000010];
bool cmp(node a,node b){
	if(a.x==b.x)return a.id<b.id;//==
	return a.x<b.x;
}
int ans=0;

signed main(){
	n=rd();
//	cin>>n;
	
	for(int i=1;i<=n;i++){
		a[i].x=rd();
		a[i].y=rd();
//		cin>>a[i].x>>a[i].y; 
		a[i].id=i;
	}
	stable_sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		int t=a[i].x;
		int tt=i;
		while(a[i].x==t){//找到 x 相同的区间
			i++;
		}
		i--;
		for(int j=tt;j<i;j++){
			ans+=a[j+1].id*a[j].y;//每一次修改对下一次询问有影响
		}
	}
	cout<<ans<<endl;
	
	return 0;
}

```

---

## 作者：Flambler (赞：0)

# P11615 题解
### Step 0 前言 Preface
~~[博客食用更佳](https://www.luogu.com.cn/article/8e6tioh3)~~ 这篇题解是刷模版题时看见的一个，我寻思着还没写过一篇题解，就想着写写。
### Step 1 思路 Idea
这题先想着的就是 `unordered_map` 、 `gp_hash_table` 、 `cc_hash_table` ，然后再想的才是手写哈希表。 `unordered_map` 和 `cc_hash_table` 太慢了，手写哈希表~~不会~~太复杂，所以我这选择 `gp_hash_table` 。

这题的哈希函数，可以用 `splitmix64` 。
### Step 2 代码 Code
先是标准的 `splitmix64` ：
```cpp
struct Hash {
    us ll splitmix64(us ll x) const {  // 使用哈希函数splitmix64
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30))*0xbf58476d1ce4e5b9;
        x=(x^(x>>27))*0x94d049bb133111eb;
        return x^(x>>31);
    }
	size_t operator()(us ll x) const {
        static const us ll t=steady_clock::now().time_since_epoch().count();  // x 加上的时间
        return splitmix64(x+t);
	}
};
```
然后直接传入 `gp_hash_table` ，再按题目模拟就好了，完整代码如下：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<chrono>
#define llmax numeric_limits<long long>::max()
#define llmin numeric_limits<long long>::min()
#define imax numeric_limits<int>::max()
#define imin numeric_limits<int>::min()
#define pb push_back
#define gc getchar
#define pc putchar
#define gs gets
#define ps puts
#define nl ps("")
#define ir iterator
#define us unsigned
#define ll long long
#define chkup(ch) ch>='A'&&ch<='Z'
#define chklow(ch) ch>='a'&&ch<='z'
#define dis(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
using namespace std;
using namespace chrono;
using namespace __gnu_pbds;
char* line;
template<typename _T>
_T read() {  // 快读
	_T n=0;
	char ch=gc();
	while(!isdigit(ch)) {
		ch=gc();
	}
	while(isdigit(ch)) {
		n=(n<<3)+(n<<1)+ch-'0';
		ch=gc();
	}
    return n;
}
template<typename _T>
void write(const _T n) {  // 快写
	if(n>9) {
		write(n/10);
	}
	pc(n%10+'0');
}
struct Hash {
    us ll splitmix64(us ll x) const {  // 使用哈希函数splitmix64
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30))*0xbf58476d1ce4e5b9;
        x=(x^(x>>27))*0x94d049bb133111eb;
        return x^(x>>31);
    }
	size_t operator()(us ll x) const {
        static const us ll t=steady_clock::now().time_since_epoch().count();  // x 加上的时间
        return splitmix64(x+t);
	}
};
int main() {
    us ll n=read<us ll>(), ans=0;
    gp_hash_table<us ll, us ll, Hash> hash;  // 将哈希函数传入 gp_hash_table
    for(int i = 1;i<=n;i++) {
        us ll x=read<us ll>(), y=read<us ll>();
        ans+=i*hash[x]; 
        hash[x]=y;
    }
    write(ans);
	return 0;
}
```
[100 pts record](https://www.luogu.com.cn/record/201697563)

---


# 【模板】传递闭包

## 题目描述

给定一张点数为 $n$ 的有向图的邻接矩阵，图中不包含自环，求该有向图的传递闭包。

一张图的邻接矩阵定义为一个 $n\times n$ 的矩阵 $A=(a_{ij})_{n\times n}$，其中

$$ a_{ij}=\left\{
\begin{aligned}
1,i\ 到\ j\ 存在直接连边\\
0,i\ 到\ j\ 没有直接连边 \\
\end{aligned}
\right.
$$

一张图的传递闭包定义为一个 $n\times n$ 的矩阵 $B=(b_{ij})_{n\times n}$，其中

$$ b_{ij}=\left\{
\begin{aligned}
1,i\ 可以直接或间接到达\ j\\
0,i\ 无法直接或间接到达\ j\\
\end{aligned}
\right.
$$

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 100$，保证 $a_{ij}\in\{0,1\}$ 且 $a_{ii}=0$。

## 样例 #1

### 输入

```
4
0 0 0 1
1 0 0 0
0 0 0 1
0 1 0 0```

### 输出

```
1 1 0 1
1 1 0 1
1 1 0 1
1 1 0 1```

# 题解

## 作者：银杉水杉秃杉 (赞：44)

喜提此题最优解！

本题小故事：这道题本来在主题库，由于过于简单，经过 LA 群激烈的讨论，被某位管理员迁移到了入门与面试。

传递闭包，没有什么可以过多介绍的，就是传统 Floyd 的想法。

复杂度：$O(n^3)$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[110][110];
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> a[i][j];
    for (int k = 1; k <= n; k++)//记得k循环在i和j之前
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                a[i][j] |= a[i][k] & a[k][j];
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
            cout << a[i][j] << ' ';
        cout << endl;
    }
    return 0;
}
```
虽然 Floyd 能通过这道题，但 Floyd 是 $O(n^3)$ 的算法，太慢了。

思考：如果把这道题的数据范围换成 $n\le2000$ 该怎么办呢？

以下提供两种优化思路。

第一种为 bitset 优化，相对来说跑的要快一些。

这种方法也很好写，目前是此题的最优解（21ms）。

[最优解AC记录](https://www.luogu.com.cn/record/60328608)

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch))
    {
        f = ch != '-';
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f ? x : -x;
}
int n;
bitset<110> a[110];
int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = read();
    for (int j = 1; j <= n; j++)//注意j循环在i循环外
        for (int i = 1; i <= n; i++)
            if (a[i][j])
                a[i] |= a[j];//bitset也挺好写的
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
            putchar(a[i][j] + '0'), putchar(' ');
        putchar('\n');
    }
    return 0;
}
```

第二种为压位优化，就是把连续 $32$ 个点的状态压缩成一个 int 类型的数，类似于状压dp。这样既节省了空间，也节约了时间。

代码只要理解了，还是挺好写的。虽然 bitset 肯定最好写的，但如果不想用 STL 的话，压位肯定是最好的，只是要注意的细节很多。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2010;
int n,m,a[N][N];
char c;
int main ()
{
	scanf("%d",&n);
	m=n/32+1;
	for (int i=0;i<n;i++)
		for (int j=0;j<m;j++)
			for (int k=0;k<32&&j*32+k<n;k++)
			{
				char c=getchar();
				while (c!='0'&&c!='1') 
					c=getchar();
				a[i][j]|=(c-'0')<<k;
			}
	for (int k=0;k<n;k++)
		for (int i=0;i<n;i++)
		{
			int f=-((a[i][k/32]>>(k%32))&1);
			if (f==0) 
				continue;
			for (int j=0;j<m;j++)
				a[i][j]=a[i][j]|(f&a[k][j]);
		}
	for (int i=0;i<n;i++)
	{
		for (int j=0;j<m;j++)
			for (int k=0;k<32&&j*32+k<n;k++)
				putchar(((a[i][j]>>k)&1)+'0'),putchar(' ');	
		putchar('\n');
	}
	return 0;
} 
```

综上所述，我还是更推荐大家写 bitset。STL 的快乐，只有用过才会知道。

---

## 作者：ZBAA_MKC (赞：10)

一直希望能有一个传递闭包的模板题，现在终于有了。

对于邻接矩阵和传递闭包的定义题目中已经说了，这里就不多赘述了。

因为数据范围很小，所以我们可以采用 Floyd 算法，该算法的核心代码是：`f[i][k] = min(f[i][k], f[i][j] + f[j][k]);`

但这道题中要求我们求的是是否能到达，不是最短路径，那我们该怎么办呢？

其实很简单，把 Floyd 算法的核心代码改一下就行了：`dist[i][j] |= (dist[i][k] && dist[k][j]);`

这一行代码的含义是：如果从 $i$ 号点可以直接或间接到达 $k$ 号点，那么就把 `f[i][k]` 的值设成 $1$， 否则设成 $0$。

代码如下：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

bool dist[105][105];
int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
    	for (int j = 1; j <= n; j++)
    	{
    		int x;
    		cin >> x;
    		if (x == 1)
    		{
    		    dist[i][j] = 1;
    		}
    	}
	}
	
	for (int k = 1; k <= n; k++)
	{
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				dist[i][j] |= (dist[i][k] && dist[k][j]);
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			cout << dist[i][j] << " ";
		}
		cout << endl;
	}
	return 0;
} 
```

---

## 作者：yzy1 (赞：10)

介绍一种使用 `bitset` 的做法。

我们可以对每一个点建一个 `bitset`，来代表从这个点出发能够到达的点，然后就简单了，二进制位上的 $1$ 表示能到达，$0$ 表示不能到达。最后依次输出这 $n$ 个 `bitset` 即可。

具体过程，可以参考 floyd 算法。即枚举 $i,j$，如果 $j$ 可以到达 $i$，那么点 $i$ 能到的点肯定能被点 $j$ 所达到。使用 `bitset` 的或运算即可轻松实现这个过程。

```cpp
#define rep(i, f, t) for (int i = (f), ed##i = (t); i <= ed##i; ++i)
#define re(i, t) rep(i, 1, t)
bitset<N> a[N];
int n;
int main() {
  in(n);
  re(i, n) a[i][i] = 1;
  re(i, n) re(j, n) a[i][j] = in();
  re(k, n) re(i, n) if (a[i][k]) a[i] |= a[k];
  re(i, n) {
    re(j, n) out((int)a[i][j])(' ');
    out('\n');
  }
  return 0;
}
```

---

## 作者：GI录像机 (赞：10)

第一眼看到这个题目时
### 传递闭包是啥？
看了一下题目，这不就是 **Floyd 弱化版**吗？


------------
## 接下来讲讲做法。

假设现在有三个点，$i$，$j$，$k$。如果我们给 $i$ 和 $k$ 连一条边，给 $k$ 和 $j$ 连一条边，显然，$i$ 和 $j$ 就**互相连通**了，我们就可以视为 $i$ 和 $j$ 之间也有一条边。这对结果没有影响。

如果再有一个 $u$ 点连 $i$ 点，我们就可以把 $i$ 点当成中转站，起到之前 $k$ 点的作用，把 $u$ 和 $j$，$u$ 和 $k$ 连接起来。**也就是说，通过一个中转点，就可以把一个点和中转点连接的所有其他点连接起来。**

## 然后是代码实现。

我们只需建立一个邻接表 $d_{i,j}$ 来存储 $i$，$j$ 是否连通，以及一个三重循环枚举中转点 $k$，以及 $i$，$j$。很容易就能得到转移方程（在这里，$d$ 存储的是 $1$（可连通），$0$（不可连通），所以 $min$ 是正确的）：

 $d_{i,j}=max(d_{i,j},min(d_{i,k},d_{k,j}))$ 

**注意，最外层循环必须枚举中转点。** 

至于为什么要先枚举 $k$，这里我就不提了，大家可以自行了解。

## 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int d[110][110],n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>d[i][j];
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				d[i][j]=max(d[i][j],min(d[i][k],d[k][j]));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			cout<<d[i][j]<<" ";
		cout<<endl;
	}return 0;
}
```


---

## 作者：Iam1789 (赞：5)

## 前言

~~颓废着~~哎洛谷又有新模板题了！传送封包好高级的亚子！

（点击来一看 ？？？这不就是 `dfs` 吗
## 正文

### 做法一
对于每个点 $i$，我们从这个点开始深搜，给路径上的每个点打上标记，如果遇到已经搜过的点就退出。注意 $i$ 号的自己不能直接到达自己，必须通过别的点间接到达，一开始不能给 $i$ 自己打上标记。由于每个点最多被搜到一次，所以最坏复杂度为 $O(n^3)$（$O(nm)$,$m$ 为直接连边的条数)。

核心代码：
```cpp
void dfs(int x,int zz)
{
    ans[zz][x]=1;
    for(int i=1;i<=n;++i)
    {
        if(a[x][i]&&(!ans[zz][i]))
        dfs(i,zz);
    }
}
void get_ans()
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(a[i][j])
            dfs(j,i);
        }
    }
}
```

### 做法二

我去网上搜了一下，发现还真有不同的做法。我们可以仿照 `Floyed` 最短路算法，写出以下代码：
```cpp
for(int k=1;k<=n;++k)
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(a[i][k]&&a[k][j])
            a[i][j]=1;
        }
    }
}
```
这个算法的原理和 `Floyed` 最短路是一样的。复杂度稳定 $O(n^3)$。

---

## 作者：ZepX_D (赞：4)

### 传递闭包
通俗来讲,就是问 $ a $ 点 是否可以到达 $ c  $ 点,我们通常利用 $ Warshall $ 算法来解决这类问题，其实就是 $ Floyd $ 的变形, 稍微修改一下就可以判断图中两点是否连通

**时间复杂度** ： $ O(n^3) $ 

**算法实现** ：把相连的两点间的距离设为 $ dis[i][j]=true $ ,不相连的两点设为 $ dis[i][j]=false $ ,如果 $ i $ 可以到 $ k $ , $ k $ 可以到 $ j $ ,那么 $ i $ 就可以到 $ j $ 。
```cpp
#include<cstdio>
#include<cctype>
#define re register

using namespace std;

inline int read()//快读
{
	int x=0;
	char ch=getchar();
	while(!isdigit(ch))
   //isdigit()用来判断是否为数字字符
   //需调用cctype头文件
		ch=getchar();
	while(isdigit(ch))
	{
		x=x*10+ch-48;
		ch=getchar();
	}
	return x;
}

int a[101][101];

int main()
{
	int n=read();
	
	for (re int i=1;i<=n;i++)
		for (re int j=1;j<=n;j++)
			a[i][j]=read();//根据题意读入
	
	for (re int k=1;k<=n;k++)//Floyd
		for (re int i=1;i<=n;i++)
			for (re int j=1;j<=n;j++)
				a[i][j] = a[i][j] || (a[i][k] && a[k][j]);
   				//a[i][j]=a[i][j]|(a[i][k]&a[k][j]);
	for (re int i=1;i<=n;i++)
	{
		for (re int j=1;j<=n;j++)
			printf("%d ",a[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：言琢დ (赞：2)

考虑 Floyd。

设

$$dp_{k,i,j}$$

表示只使用 $1\sim k$ 号结点时是否可以 $i\rightarrow j$。

不难得到：

$$dp_{k,i,j}=dp_{k-1,i,j}~\text{OR}~(dp_{k-1,i,k}~\text{AND}~dp_{k-1,k,j})$$

一般的写法是压缩掉一维状态。

$$dp_{i,j}|=dp_{i,k}~\text{AND}~dp_{k,j}$$

代码实现：

```cpp
#include<cstdio>
inline int in();
inline void wr(int);
const int N=(int)1e2+5;
int a[N][N];
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("7909.in","r",stdin);
	freopen("7909.out","w",stdout);
#endif
	register int n=in();
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			a[i][j]=in();
	for(register int k=1;k<=n;++k)
		for(register int i=1;i<=n;++i)
			for(register int j=1;j<=n;++j)
				if(a[i][k]&&a[k][j])
					a[i][j]=1;
	for(register int i=1;i<=n;++i,putchar('\n'))
		for(register int j=1;j<=n;++j)
			wr(a[i][j]),putchar(' ');
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

---

## 作者：CEFqwq (赞：1)

本题核心：如果 $i$ 能到 $j$ 并且 $j$ 能到 $k$，那么 $i$ 能到 $k$。

注意一个坑点：一个点到本身也需要经过其他点，否则也得是 $0$。

可以用 SPFA 解决。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>G[201];
queue<int>q;
bool dis[201];
int x[201],y[201],r[201],n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			int x;
			cin>>x;
			if(x==1)G[i].push_back(j);
		}
	for(int s=1;s<=n;s++){
		memset(dis,0,sizeof dis);
		q.push(s);
		while(!q.empty()){
			int u=q.front();
			q.pop();
			for(int v=0;v<G[u].size();v++){
				if(!dis[G[u][v]]){
					dis[G[u][v]]=1;
					q.push(G[u][v]);
				}
			}
		}
		for(int i=1;i<=n;i++)cout<<dis[i]<<" ";
		cout<<"\n";
	}
}
```

---

## 作者：Da_un (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B3611)

大体意思是在一张点数为 $n$ 的有向图的邻接矩阵中，给出任意两点间是否有直接连边的关系，让你求出任意两点之间是否有直接连边或间接连边的关系。

## 思路
转化为最短路问题。

如果给出的这两个点有直接连边的关系，就给它们所连的边赋一个同样的权值，这样便于最短路的进行，因为题目中给出的数据范围很小，所以在进行最短路时，跑一遍 Floyd 即可。

跑完最短路后，我们对于任意两个点都要判断一下它们之间连的边是否是跑完最短路后所得到的新边权，如果是，那么这两个点一定有直接连边或间接连边的关系，如果否，则不然。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int f[200][200];
int n,t;
int main()
{
	memset(f,0x3f3f3f3f,sizeof(f));//初始化 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			scanf("%d",&t);
			if(t)
				f[i][j]=10;//赋予统一权值 
		}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);//跑一遍Floyd,求出最短路 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(f[i][j]!=0&&f[i][j]!=0x3f3f3f3f)//有跑完最短路后所得的新边权 
				printf("1 ");//有直接连边或间接连边的关系,输出1 
			else//否则 
				printf("0 ");
		}
		printf("\n");
	}
	return 0; 
	//完结撒花~~ 
} 
```
### [AC记录](https://www.luogu.com.cn/record/60313319)

---

## 作者：超级玛丽王子 (赞：0)

传递闭包？这是个啥玩意？

通俗地讲，传递闭包就是一个邻接矩阵，表达图连通性的邻接矩阵。要注意的是，在传递闭包里面，如果一个点不在任何一个环中，就规定一个点和自身不连通。

怎么求传递闭包？根据定义，我们发现他需要枚举两个点间是否存在路径。怎么枚举路径？当然要枚举路径上的点。这就让我们自然而然的想到了 Floyd-Warshall 算法。

Floyd-Warshall 运用了动态规划的思想，用 $f_{i,j}$ 表示图上两点间的状态（例如最短路径，连通性等），并枚举中转节点 $k$ 进行转移。转移的大概方式是

$$f_{i,j}=F(f_{i,k},f_{k,j})$$

其中 $F$ 是状态转移方程。

在本例中，状态就是连通性，转移过程如下：

1. 如果 $i,j$ 直接联通，则 $f_{i,j}=1$
2. 如果 $i,j$ 不直接连通，但可以通过中转节点 $k$ 连通，则 $f_{i,j}=1$
3. 如果枚举了所有中转节点都不能使 $i,j$ 联通，则 $f_{i,j}=0$

又注意到状态是 $0/1$ 型的，可以用位运算加速。

于是转移方程即为

$$f_{i,j}=f_{i,j}\operatorname{ or }\ (f_{i,k}\operatorname{and}f_{k,j})$$

其中 $\operatorname{or}$ 表示按位或运算，$\text{and}$ 表示按位与运算。

这个方程需要预处理直接存在的边。由于这样的边也用 $0/1$ 型的布尔变量表示，可以直接在原图上 DP。

附上完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	int x=0;
	while(ch>='0'&&ch<='9') x=(x*10)+(ch^48),ch=getchar();
	return x;
}
inline void write(int x) {
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void wr(int x) {
	write(x);
	putchar(' ');
}
bool mp[105][105];
int n;
void Floyd_Warshall() {
    for(int k=1;k<=n;++k) //注意要先枚举 k，可以自己手玩几个图想一想为什么
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                mp[i][j]|=mp[i][k]&mp[k][j];
}
int main(void) {
    n=read();
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            mp[i][j]=read();
    Floyd_Warshall();
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=n;++j)
            wr(mp[i][j]);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：int32 (赞：0)

考虑 $\mathcal{O}(n^3)$ 的 $\text{Floyd}$ 算法。

- $x$ 能直接到达 $y$，$b_{x,y}=\text{TRUE}$。（直接）

- $x$ 能到达 $z$，$z$ 能到达 $y$，$b_{x,y}=\text{TRUE}$。（间接）

- 否则，$b_{x,y}=\text{FALSE}$。（不能到达）

于是容易推出方程 $b_{x,y}=b_{x,y}\ \text{OR}\ (b_{x,z}\ \text{AND}\ b_{z,y})$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int n;
bool a[N][N];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	for(int o=1;o<=n;o++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				a[i][j]|=a[i][o]&a[o][j];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			cout<<a[i][j]<<' ';
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：D2T1 (赞：0)

$\color{blue}{\text {pwp }{\to\textbf{My blog}\gets}}\text{qwq}$

# P7909 题解

一道传递闭包的模板题。

可以发现，题目所求的东西和多源最短路径类似：多源最短路径要求任意两个点的最短路，而本题求任意两个点是否可达。（有向）

所以我们可以用一个 floyd 来使用与多源最短路径类似的方式求解该题。

floyd 的核心是 DP 思想:找到一点 $k$ 更新 $i$ 到 $j$ 的最短路。而本题也类似，可以使用一个点来更新两点是否可达，所以只用把 floyd 改一下即可通过本题。

```cpp
//P7909
#include <bits/stdc++.h>
using namespace std;

const int N = 110;
int n, a[N][N];

void floyd(){
	for(int k = 1; k <= n; ++ k){
		for(int i = 1; i <= n; ++ i){
			for(int j = 1; j <= n; ++ j){
				a[i][j] |= a[i][k] & a[k][j];
			}
		}
	}
}

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i){
		for(int j = 1; j <= n; ++ j){
			scanf("%d", &a[i][j]);
		}
	}
	floyd();
	for(int i = 1; i <= n; ++ i){
		for(int j = 1; j <= n; ++ j){
			printf("%d ", a[i][j]);
		}
		puts("");
	}
	return 0;
} 
```

---

## 作者：Moeebius (赞：0)

一道 Floyd 板子题。

数据范围 $n\le100$ ， Floyd $O(n^3)$ 显然能过。

记 $dp[i][j]$ 为 $i$ 能否间接或直接到达 $j$ ，易得 $dp[i][j]=dp[i][j]$ | $ dp[i][k]$ & $  dp[k][j]$.

（也就是如果 $i$ 能到达 $k$ ， $k$ 能到达 $j$ ， 那么 $i$ 就能到达 $j$ ）

所以我们得出以下核心代码：
```cpp
void floyd()
{
	for(int k=1; k<=n; k++)
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				dp[i][j]|=dp[i][k]&dp[k][j];
}
```
加上输入输出即可 AC .

---


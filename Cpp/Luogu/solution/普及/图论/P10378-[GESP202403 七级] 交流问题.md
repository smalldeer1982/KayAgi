# [GESP202403 七级] 交流问题

## 题目描述

来自两所学校 $A$、$B$ 的 $n$ 名同学聚在一起相互交流。为了方便起见，我们把这些同学从 $1$ 至 $n$ 编号。他们共进行了 $m$ 次交流，第 $i$ 次交流中，编号为 $u_i, v_i$ 的同学相互探讨了他们感兴趣的话题，并结交成为了新的朋友。

由于这次交流会的目的是促进两校友谊，因此只有不同学校的同学之间会交流。同校同学并不会互相交流。

作为 $A$ 校顾问，你对 $B$ 校的规模非常感兴趣，你希望求出 $B$ 校至少有几名同学、至多有几名同学。

## 说明/提示

### 数据规模与约定

- 对 $30\%$ 的数据，保证 $n \leq 17$，$m \leq 50$。
- 对 $60\%$ 的数据，保证 $n \leq 500$，$m \leq 2000$。
- 对全部的测试数据，保证 $1 \leq u_i, v_i \leq n \leq 10^5$，$1 \leq m \leq 2\times 10^5$，输入是合法的，即交流一定是跨校开展的。

## 样例 #1

### 输入

```
4 3
1 2
2 3
4 2
```

### 输出

```
1 3```

## 样例 #2

### 输入

```
7 5
1 2
2 3
4 2
5 6
6 7
```

### 输出

```
2 5```

# 题解

## 作者：KobeBeanBryantCox (赞：88)

# P10378 [GESP202403 七级] 交流问题 题解

------------

[题目传送门](https://www.luogu.com.cn/problem/P10378)

~~GESP 为什么有时候很简单（比如这个题），有时候又很难，但是随便瞎搞一下又能过，看正解后又发现自己不是正解。。。~~

------------

## 题意

给你一个二分图（至于为什么是二分图，见后面的分析），可能不联通，给这个二分图染色，问染成某个颜色的点数的最小可能和最大可能。

关于二分图和二分图染色，不知道读者的可以看[这里](https://oi-wiki.org/graph/bi-graph/)。

------------

## 分析

首先拿到一道题目读完题之后第一时间应该看的是数据范围。

$1\leq u_i,v_i\leq n\leq 10^5$，$1\leq m\leq 2\times 10^5$。

因为 $n$ 和 $m$ 的规模是一样的，我们不妨令 $m$ 就是 $n$。

所以根据数据范围，我们需要一个大概是 $O(n)$ 或者 $O(n\log n)$ 的算法。

容易发现这个题给的交流关系可以构成一张图，并且对于这张图上截取的每一条链，都是 `A-B-A-B...` 或者 `B-A-B-A...`的状态。

**也就是说这个图是一个二分图！**

由于题目保证“输入是合法的，即交流一定是跨校开展的”，所以我们不用考虑这个图不是二分图的情况

题目求 $B$ 校的规模，那我们就应该给二分图染色。

那题目转换为求某个颜色个数的最小值和最大值。

由于这个图不联通，先来想想如果联通怎么做。

为方便表述，接下来的染色叫做红蓝染色。

那我们是不是只要给这个二分图红蓝染色，然后：

1. **红色的蓝色个数个数的最小值就是 $B$ 校人数的最小值；**
2. **红色的蓝色个数个数的最大值就是 $B$ 校人数的最大值。**

画个图理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/xuw5a2jt.png)

比如对于这个图，可以这样染色：

![](https://cdn.luogu.com.cn/upload/image_hosting/v83mqvzo.png)

这个时候 $B$ 校的最小值就是红色的颜色个数，即为 $2$。

$B$ 校的最大值就是蓝色的颜色个数，即为 $3$。

为什么可以这样呢，因为我们可以把红色当成 $B$ 校，也同时可以把蓝色当成 $B$ 校。

当然如果把红蓝反过来染也是一个道理，所以我们刚刚的结论是正确的。

对于不联通的图怎么办呢？

**我们可以把每一个联通块都这样处理，最小值加起来就是最终的最小值答案（至少），最大值加起来就是最终的最大值答案（至多）。**

嗯，这就分析完了。

时间复杂度 $O(n)$，因为每个点只被访问一次。

------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=1e5+10;
vector<int>e[N]; // 存储边 
bool b[N]; // 这个点是否被访问过了 
void dfs(int u,int &s1,int &s2,bool f) // 注意这里的 s1 和 s2 要引用传参 
// 当前点在 u，染了 s1 个红色，s2 个蓝色，f=1 表示当前要染红色，f=0 表示当前要染黑色 
{
	b[u]=true; // 标记已经放问过了 
	if(f)s1++; // 染色 
	else s2++;
	for(int v:e[u])
		if(!b[v])dfs(v,s1,s2,!f); // 进行下一个点的染色，注意 !f 
}
int main()
{
	int n=in(),m=in();
	while(m--)
	{
		int u=in(),v=in();
		e[u].push_back(v),e[v].push_back(u); //存 边 
	}
	int s1=0,s2=0;
	for(int i=1;i<=n;i++)
		if(!b[i]) // 处理每一个联通块 
		{
			int ss1=0,ss2=0;
			dfs(i,ss1,ss2,true); // 这里传入 true 和 false 都可以
			s1+=min(ss1,ss2),s2+=max(ss1,ss2); // 红蓝最小值和红蓝最大值 
		}
	out(s1),putchar(' '),out(s2);
	return 0;
}
```

------------

后记 1：版权所有@[KobeBeanBryantCox](https://www.luogu.com.cn/user/865625)，请勿抄袭代码。

后记 2：写代码的习惯一定要好，代码不要乱七八糟，优秀的码风是很醉人的~

~~还有，能不能不要脸地要个赞呀 QwQ~~

---

## 作者：穼柗° (赞：11)

这是道图论的题目。

由于 $1 \leq n \leq 10^5$，若使用邻接矩阵存图，${(10^5)}^2=10^{10}>10^7$，会 MLE，因此只能用邻接表。

交流的两个人一定不是同一所学校的，可以用 [DFS（深度优先搜索）](https://baidu.physton.com/?q=%22%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%22)实现：每次调用 DFS 都假设一个学生是某一学校。

但当输入的图非联通时（可理解成学生们分成很多个“圈子”交流问题），有可能在一个“圈子”里假设 $3$ 个人 $A$ 校，$4$ 个人 $B$ 校，而另一个“圈子”里假设 $4$ 个人 $A$ 校，$3$ 个人 $B$ 校，得出每校均 $7$ 人，而正确答案是最少 $6$ 人，最多 $8$ 人。

于是可得出以下算法。
- 调用 `DFS(i,flg)`, $1\leq i \leq n$，$flg$ 表示假设学生 $i$ 是哪个学校的。
- 每次 `DFS(i,flg)`，计算当前“圈子”两校的人数。
- 把当前“圈子”人数最少和人数最多的两个学校的人数加到两个变量中。
- 最后输出这两个变量。

如有不明请看代码
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
bool flag[100001];
// flag[i] 表示 dfs 有没有调用过 i。
vector<int> v[100001];
signed int n,m,ans1,ans2,cnt1,cnt2;
// cnt1和cnt2是存储当前“圈子”的两校人数；
// ans1、ans2 表示B校至少有几名同学、至多有几名同学。 
inline void dfs(int xxs,short flg) {
	if(flag[xxs]) return;
	else flag[xxs]=1,((flg&1)?cnt1:cnt2)++; // 三目左值。
	flg=(flg&1)+1; // 注：“&”表示按位与，优先级比 “+”、“-”小；“&1”等价于“%2”。
	for(int i: v[xxs]) // 遍历每一条边
		dfs(i,flg);
}
signed main(void) {
	scanf("%d%d",&n,&m);
	for(int a,b;m--;v[a].push_back(b),v[b].push_back(a)) // 存入无向边 ab。
		scanf("%d%d",&a,&b);
	for(register int i=1;i<=n;i++)
		if(!flag[i]) {
			cnt1=cnt2=0;
			dfs(i,1);
			if(cnt1<cnt2) ans1+=cnt1,ans2+=cnt2;
			else ans1+=cnt2,ans2+=cnt1;
		}
	printf("%d %d",ans1,ans2);
	return 0;
}
```

---

## 作者：Austin0116 (赞：8)

# 分析

由题可得，建出来的图必定是二分图。

所以就有一种把所有连通块遍历一遍进行染色的做法。

细节在代码中

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,u,v,sum,cnt1,cnt2,head[100005],cnt;
bool vis[100005];
struct Ed{//链式前向星存图
	int to,nxt;
};
Ed e[400005];
void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int x,int y){
	if(y==1) cnt1++;//染色
	else cnt2++;
	for(int i=head[x];i!=-1;i=e[i].nxt) if(!vis[e[i].to]){
		vis[e[i].to]=1;
		dfs(e[i].to,~y&1);//将颜色调换
	} 
}
int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		add(u,v);//建双向边
		add(v,u);
	}
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		cnt1=cnt2=0;//清零
		vis[i]=1;
		dfs(i,0);
		sum+=min(cnt1,cnt2);//先求最小
	}
	printf("%d %d",sum,n-sum/*拿总数减最小就是最大*/);
	return 0;
}
```

---

## 作者：wumingwei (赞：7)

###### ~~为了一道题，学了个算法。~~
[题目传送门](https://www.luogu.com.cn/problem/P10378)
# 思路

因为题目确保**只有不同学校的同学之间会交流**，所以本题的图是个二分图，所以只要进行二分图染色取最少颜色的个数和最多颜色的个数即可。

但是本题的没有保证图的连通性，所以要将图分成若干个连通块进行处理，分别求出每个联通块最少颜色的个数和最多颜色的个数分别，最后再分别相加。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
vector<int> son[N];//我用vector来存图 
bool book[N];//标记是否被访问过 
int n,m;
int Min,Max;//分别存储最少和最多颜色的个数 
int white,black;//每个连通块黑色和白色的个数 
void dfs(int x,bool color)//对于每个连通块进行染色 
{
	book[x]=1;
	if(color) white++;
	else black++;
	for(auto y:son[x])//访问所有出边 
	{
		if(!book[y])
			dfs(y,!color);
	}
}
int main()
{
	std::ios::sync_with_stdio(false);
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		son[x].push_back(y);//注意保存为无向图 
		son[y].push_back(x);
	}
	for(int i=1;i<=n;i++)
	{
		if(!book[i])//如果book[i]==0表示在未访问的连通块中 
		{
			white=black=0;
			dfs(i,1);
			Min+=min(white,black);
			Max+=max(white,black);
		}
	}
	cout<<Min<<' '<<Max;
	return 0;
}
```

---

## 作者：lflby (赞：5)

# 思路

此题是一道图论

把每次交流的两人连一条线

因为只有不同学校的同学之间会交流

所以每次交流的两人必是一个 A 校一个 B 校

立一个标志来判断是 A 还是 B

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
vector<int>g[100005];
bool d[100005];
int a,b;
void dfs(int x,int ch)
{
	if (ch==1) a++;
	else b++;
	for (int i = 0; i < g[x].size(); i++)
	{
		if (!d[g[x][i]])
		{
			d[g[x][i]]=true;
			dfs(g[x][i],(ch+1)%2);//若ch==1则(ch+1)%2=0,同理ch==0,(ch+1)%2=1 
		}
	}
	return ;
}
int main()
{
	cin>>n>>m;
	for (int i = 1; i <= m; i++)
	{
		int x,y;
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (d[i]) continue;
		d[i]=true;
		a = b = 0;//注意要归零 
		dfs(i,0);
		ans += min(a,b);
	}
	cout<<ans<<" "<<n-ans;
	return 0;
}
```

---

## 作者：lucasincyber (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10378)
## 思路
通过题目的保证，显而易见，最终构成的应该是一个（或多个）二分图。

不难想到可以把每个连通块搜一遍，跑过的点就染个色（因为每一个连通块必定是一个二分图，所以一定能染色成功）。最后记录答案就可以了。

时间复杂度 $O(n)$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;

int n, m, res, a, b;
bool vis[N];
vector<int> tr[N];

void dfs(int x, bool flag) // flag 为当前的颜色
{
	if (vis[x]) return;
	a++;
	if (flag) b++;
	vis[x] = true;
	for (auto i : tr[x])
		dfs(i, !flag); // 因为 flag 是 bool 类型，换颜色是直接取反就可以了
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		tr[u].push_back(v); // 建图
		tr[v].push_back(u);
	}
	for (int i = 1; i <= n; i++)
	{
		if (vis[i]) continue;
	 	a = 0, b = 0; // 初始化，a 代表总人数，b 代表一个学校的人数
		dfs(i, false); 
		int tmp = min(b, a - b);
		res += tmp;
	}
   // 记录答案
	int ans1 = n - res;
	if (ans1 > res) swap(ans1, res);
	printf("%d %d\n", ans1, res);
	return 0;
}
```

---

## 作者：llqw (赞：3)

## 题目大意
建立一个二分图，以升序输出这个二分图红蓝阵营的节点。

## 解题过程
#### 一，什么是二分图？
如果一个图可以恰好分为两个部分，不同部分的节点有边相连，同节点的边没有直接边相连。这样的图就叫二分图。

说直白一点，红蓝两军在打仗，将炮弹的轨迹假设成边，那么只可能红军会向蓝军发射炮弹，蓝军向红军发射炮弹，红军不可能向己方节点发射炮弹（叛变除外）。满足这样一个情况的
图就叫二分图。

#### 二，怎么求二分图？
为了满足这个性质，我们可以运用 DFS 将相邻节点染上不同的颜色（染色法），最后求每个颜色的数量。

#### 进入正题，开始解题
这道题其实就是一道模板题，依据题意，建立一个二分图，因为一共只有两个学校，所以一共也只有两个颜色，我们只需要按升序输出两种颜色的数量即可。请结合代码注释理解。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
vector<int> g[100005];
int vis[100005];//标记每个节点的颜色，用1和2来表示
int cnt[10];//累计每个颜色的数量
void dfs(int idx,int col){//建立二分图
	for(int i=0;i<g[idx].size();i++){
		if(vis[g[idx][i]]!=0){
			continue;//被标记过了就不做任何操作
		}
		vis[g[idx][i]]=3-col;//标记
		cnt[3-col]++;//累加
		dfs(g[idx][i],3-col);//深搜
     	//标准操作：标加搜 三部曲
	}
}
int ansmin,ansmax;//记录最大最小值
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		if(vis[i]==0){//发现了一个未标记的新联通块
			memset(cnt,0,sizeof cnt);//一定要记得清空
			cnt[1]++;//默认将第一个节点染成1
			vis[i]=1;//标记
			dfs(i,1);//搜索
         //仍然是 标加搜
			ansmin+=min(cnt[1],cnt[2]);//加上这个连通块的最小值
			ansmax+=max(cnt[1],cnt[2]);//同上
		}
	}
	cout<<ansmin<<' '<<ansmax;
}
```

---

## 作者：_ZML_ (赞：2)

# 思路
我们把关系想成一张图，每次输入就给两个人连一条边。

因为一个人只有两种选择，所以我们在一个联通块内随便找一个点，跑一遍搜索，找出这个联通块内的答案。代码如下。

```cpp
void dfs(int u,int color) {
    cnt2++;// cnt2是这个连通块内的总点数
    cnt1+=color;//这个是一所学校内的人
    vis[u]=1;
   	//因为一个人不是A校就是 B校，所以对整张图进行染色
  	//所以一个点u假如是白色，与他相连的所有点就是黑色
    for(auto v:edge[u])  {
        if(!vis[v]) {
            dfs(v,color^1);
            /*
            相当于
            if(color==1) dfs(v,0)
            else dfs(v,1)
            */
        }
    }
}

//统计答案
//因为一个人最多即为 max(cnr2-cnt1,cnt1)

```

主函数内只需要一个变量统计一下所有联通快的总和就行了。

讲一个有趣的性质，符合要求的图不可能包含偶环，它只能是由树和奇环组成的图，如基环树。证明我就不写了，大家可以画个图试试。

# 代码
最后附上代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> edge[100010];
int ans, vis[100010], cnt1, cnt2;
void dfs(int u, int color)
{
    cnt2++;
    cnt1 += color;
    vis[u] = 1;
    for (auto v : edge[u])
    {
        if (!vis[v])
        {
            dfs(v, color ^ 1);
        }
    }
}
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        cin >> u >> v;
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    for (int i = 1; i <= n; i++)
    {
        if (!vis[i])
        {
            cnt1 = cnt2 = 0;
            dfs(i, 0);
            ans += max(cnt2 - cnt1, cnt1);
        }
    }
    cout << min(ans, n - ans) << " " << max(ans, n - ans);
    return 0;
}
```

---

## 作者：zhchz (赞：2)

## 基本思路
通过图的方式来表示同学们之间的交流关系，每个节点代表一个同学，每条边代表一次交流。由于只有不同学校的同学之间会交流，所以这个图是由两个不相连的子图组成的，分别代表两个学校的学生。通过 DFS 遍历这个图，我们可以找到每个连通分量中节点数的最小值和最大值，从而得出 B 校同学人数的最小值和最大值。

## 代码流程
1. 初始化，输入，构建图的邻接表。
2. 遍历每个节点，如果这个节点还没有被访问过，就从这个节点开始进行 DFS 遍历。
3. 在 DFS 遍历过程中，用两个变量（$ans_1$ 和 $ans_2$）分别记录连通分量中两种不同颜色（代表两个不同学校）的节点数。
4. 对于每个连通分量，将其最小值和最大值累加到 $minans$ 和 $maxans$ 中。
5. 输出 $minans$ 和 $maxans$，即为 B 校同学人数的最小值和最大值。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<math.h>
#include<string>
#include<string.h>
#include<vector>
#include<queue>
#include<set>
#define ll long long
#define ull unsigned long long
#define bas 131
#define mod 1000000007
#define pii pair<int,int>
#define maxnum (1<<31-1)
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
using namespace std;

const int N=100001;
int n,m,u,v,minans,maxans,ans1,ans2; // 定义全局变量，n 为同学总数，m 为交流次数，u 和 v 为临时变量存储输入的同学编号，minans 和 maxans 存储最终结果，ans1 和 ans2 在 DFS 中临时存储两种颜色的节点数
bool vis[N]; // 标记节点是否被访问过
vector<int> to[N]; // 存储图的邻接表

// DFS 函数，用于深度优先搜索图中的连通分量
void dfs(int x,bool color){
    vis[x]=1; // 标记当前节点为已访问
    if(color) ans1++; // 如果当前颜色为真，则增加 ans1 的计数
    else ans2++; // 否则增加 ans2 的计数
    for(int i:to[x]){ // 遍历当前节点的所有邻接节点
        if(!vis[i]) dfs(i,!color); // 如果邻接节点未被访问，则以相反颜色递归调用 DFS
    }
    return; // 返回上一层递归
}

int main(){
    cin>>n>>m; // 输入
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        to[u].push_back(v);
        to[v].push_back(u);
    }
    for(int i=1;i<=n;i++){ // 遍历所有节点
        if(vis[i]) continue; // 如果节点已被访问，则跳过
        ans1=0,ans2=0; // 初始化 ans1 和 ans2 为 0
        dfs(i,0); // 从当前节点开始进行 DFS 遍历
        minans+=min(ans1,ans2); // 将当前连通分量中较小的节点数累加到 minans
        maxans+=max(ans1,ans2); // 将当前连通分量中较大的节点数累加到 maxans
    }
    cout<<minans<<" "<<maxans; // 输出 B 校同学人数的最小值和最大值
    return 0;
}
```

这个算法的时间复杂度是 $O(n)$。

---

## 作者：XuanXuanMeow (赞：2)

# 题意简述
有两所学校 $A$ 校和 $B$ 校，它们的学生互相交流，只有不同学校的学生之间会交流，给定交流的同学列表，求 $B$ 校人数最多/最少有多少人。

# 主要思路

在这道题中可以将一次交流视作在编号为 $u_i$ 与 $v_i$ 的点建立一条无向边，这样我们就能得到一个**不联通的无向图**。题目中说**只有不同学校的同学之间会交流**，所以我们可以从每个联通块中选择一个节点跑 `DFS`，归类成两个学校(相邻的结点归到不同的学校，并没有具体归到哪个学校)。

将每个联通块人数少的学校累加，得到 $B$ 校人数最小值。同理，将每个联通块人数多的学校累加，得到 $B$ 校人数最大值。

拿样例 `2` 来举例(下划线前是点编号,后是点被分到的学校)

![](https://cdn.luogu.com.cn/upload/image_hosting/3cv2sh9h.png)

在样例 `2` 中有两个联通块。第一个联通块中人数少的学校有 $1$ 人，人数多的学校有 $3$ 人。第二个联通块中人数少的学校有 $1$ 人，人数多的学校有 $2$ 人。

所以 $B$ 校最少有 $1+1=2$ 人，$B$ 校最多有 $3+2=5$ 人。

时间复杂度 $O(n+m+$ 联通块个数 $)$。

$m$ 是加边的时间复杂度,$n$ 是跑 `DFS` 的时间复杂度,联通块个数是累加人数最小/最大值的时间复杂度。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 200005;
struct edge{
	int to,nxt;
}edges[N << 1];//无向图开双倍
int n,m,u,v,head[N],tot,A[N],B[N],top,minn,maxn;
bool visited[N];
inline void addedge(int u,int v){
	edges[++tot] = {v,head[u]};
	head[u] = tot;
}//链式前向星连边
inline void dfs(int u,int pos,bool state){//跑dfs
	//u表示当前点,pos表示当前联通块,state表示归类学校
	visited[u] = true;
	if (state) ++A[pos]; //通过state累加学校，这里AB并不指题目中的AB校，而是指B校在该联通块中最多/最少可以获得多少人
	else ++B[pos];
	for (int i = head[u];i;i = edges[i].nxt){
		if (visited[edges[i].to]) continue; //走过的点不走
		dfs(edges[i].to,pos,!state); //相邻的点state相反(只有不同学校的同学之间会交流)
	}
}
int main(){
	cin >> n >> m;
	for (int i = 1;i <= m;++i){
		cin >> u >> v;
		addedge(u,v);
		addedge(v,u);//建立无向图
	}
	for (int i = 1;i <= n;++i)
		if (!visited[i]) dfs(i,++top,false);//每个联通块中找到一个点跑dfs
	for (int i = 1;i <= top;++i){
		minn += min(A[i],B[i]); //累加每个联通块人数少的学校
		maxn += max(A[i],B[i]); //累加每个联通块人数多的学校
	}
	cout << minn << " " << maxn;
}
```

---

## 作者：Lycd0719 (赞：1)

## 题意
A 校和 B 校进行交流，求 B 校最多有几人，最少有几人。

## 思路
我们无法确定相互交流的那一个是 A 校的，那一个是 B 校的，所以可以想到二分图。

先用邻接表建图。定义染色数组 $c$。用循环枚举每一个点，如果没有被染色，定义 $cnt$ 数组，长度为 $3$，用于存放两种学校的人数。用 dfs 进行染上任意颜色，同时把相互交流的编号染上相反的颜色。用一个变量累加最大值或最小值。输出时，另一个值等于 $n$ 减去累加的值。

## 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int> e[200005];
int n, m;
int c[1000000];
void dfs(int nw, int color, int cnt[]) {
	cnt[color]++;
	c[nw] = color;
	for (auto x : e[nw]) {
		if (c[x] == 0) {
			dfs(x, 3 - color, cnt);
		}
	}
}
signed main() {
	cin >> n >> m;
	int i, j, k;
	for (i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	int ans = 0;
	for (i = 1; i <= n; i++) {
		if (c[i] == 0) {
			int cnt[] = { 0,0,0 };
			dfs(i, 1, cnt);
			ans += min(cnt[1], cnt[2]);
		}
	}
	cout << ans << " " << n - ans << endl;
	return 0;
}
```
莫抄袭，棕了少年名，空悲切

---

## 作者：Lian_zy (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P10378)

# 题目分析
本题纯二分图染色板子

由于这些节点不保证互相连通，所以我们应该分连通块处理

对于一个连通块，我们不必在意他的颜色，初始的时候只需要随便染一个颜色，然后统计，把数量少的那个加到第一个答案，数量多的加到第二个答案，最后输出即可。

# 代码

[AC 记录](https://www.luogu.com.cn/record/161987785)

``` cpp
#include <vector>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 1e5 + 10;
vector<int> G[maxn];
int n, m, u, v, mx, mn;
bool vis[maxn], color[maxn];
void dfs(int now) {
	vis[now] = true;
	if (color[now]) v++;
	else u++;
	for (auto e : G[now]) {
		if (vis[e]) continue;
		color[e] = color[now] ^ 1;
		dfs(e);
	}
	return ;
}
int main() {
	scanf("%d %d", &n, &m);
	while (m--) {
		scanf("%d %d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for (int i = 1; i <= n; i++) {
		if (vis[i]) continue;
		u = 0, v = 0;
		dfs(i);
		color[i] = true;
		mx += max(u, v);
		mn += min(u, v); 
	}
	printf("%d %d\n", mn, mx);
	return 0;
}
```

---

## 作者：linjinkun (赞：0)

这题就是用到一个名叫二分图的东西。

二分图的定义：

将一个图分成两部分，同一部分之间不能连通，不同部分之间可以连通。

于是，我们很容易发现，这题就是一个二分图，因为题解中说**只有不同学校的同学之间会交流。同校同学并不会互相交流。**

那么我们只要把两个学校当成两个部分进行染色就行了。

具体过程：

- 先存图

- 存完图之后，遍历这 $n$ 个点，如果当前点还没有被访问过，对这个点进行 DFS，DFS 的过程中进行染色，最后把最小的颜色数量加给统计最小同学数的变量，把最大的颜色数量加给统计最大同学数的变量。

细节在代码：

~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
vector<int>a[N];
int vis[N];//有两个用途，一是标记这个数是否访问，二是标记这个点燃的颜色
int num[3];//num[i]表示颜色为i的点有几个，二分图只有黑和白两种颜色，用1和2代替
void dfs(int x)
{
	for(int i = 0;i<a[x].size();i++)
	{
		if(vis[a[x][i]] == 0)
		{
			vis[a[x][i]] = 3-vis[x];//如果x号点是1，那么a[x][i]号点就是2，如果x号点是2，那么a[x][i]号点就是1，所以只需要用3-vis[x]，就是a[x][i]要填的颜色。
			num[vis[a[x][i]]]++;//当前填了这个颜色，这个颜色对应的num++；
			dfs(a[x][i]);
		}
	}
}
signed main()
{
	int ans1 = 0;//统计最小
	int ans2 = 0;//统计最小
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i = 1;i<=m;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		a[x].push_back(y);
		a[y].push_back(x);
	}
	for(int i = 1;i<=n;i++)
	{
		if(vis[i] == 0)//又找到了一个连通块起始点
		{
			vis[i] = 1;//标记填1号颜色
			num[1] = 1;//那么填一号颜色的变为一
			num[2] = 0;//么填一号颜色的变为零
			dfs(i);
			ans1+=min(num[1],num[2]);//把数量小的分给最小值
			ans2+=max(num[1],num[2]);//把数量大的分给最大值
		}
	}
	printf("%d %d",ans1,ans2);
	return 0;
}
~~~

---

## 作者：_Yonder_ (赞：0)

很明显，在一个子图中只要确定了一个点，其它点也会相继确定，于是考虑 dfs 跑图。用 $a,b$ 来表示当前子图的两个不同学校的学生数，那么 $B$ 校的最少学生数就加上 $\min(a,b)$，最多学生数就加上 $\max(a,b)$。
# Code
```
#include<bits/stdc++.h>
#define S std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define per(i,l,r) for(int i=l;i>=r;i--)
#define ll long long
using namespace std;
const int N=2e5+5;
int n,m,u,v,f[N],from[N],I[N<<1],to[N<<1],L666,A,B,ans,sum;
void add(int x,int y){to[++L666]=from[x];I[L666]=y;from[x]=L666;}
void dfs(int x,int z){
	if(f[x]) return;f[x]=z;A+=z==1;B+=z==2;
	for(int i=from[x];i;i=to[i]) dfs(I[i],z==1?2:1);
}
int main(){
	S;cin>>n>>m;while(m--) cin>>u>>v,add(u,v),add(v,u);
	rep(i,1,n) A=B=0,dfs(i,1),ans+=min(A,B),sum+=max(A,B);
	cout<<ans<<" "<<sum;
	return 0;
}
```

---

## 作者：Peiyuan (赞：0)

## 思路

这道题一看就能发现可以建图，~~$u$ 和 $v$ 都有了~~。考虑对这个无向图进行 `bfs/dfs` 将其黑白染色，使得有连边的两个节点颜色不同。注意，该图有可能是非连通图，所以要像 `floodfill` 那样，对每个没访问过的点先进行 `bfs/dfs`。题目想要求最少可能和最多可能，那把非连通图里的每个连通图的较小染色个数之和与每个连通图的较大染色个数之和输出就可以了。听着有点绕，看看代码就知道了。

## 代码

这里用 `bfs` 举个栗子。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> g[100005];
bool vis[100005],col[100005];
int n,m,mn,mx,a,b;
void bfs(int s){
	queue<int> q;
	q.push(s);
	vis[s]=1;
	col[s]=0; //随便染个色
	a=0,b=0;
	while(q.size()){
		int u=q.front();q.pop();
		if(col[u]) a++; //记录染色个数
		else b++;
		for(auto v:g[u]){
			if(!vis[v]){
				vis[v]=1;
				col[v]=!col[u]; //与该点颜色相反
				q.push(v);
			}
		}
	}
}
int main(){
	int u,v;
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			bfs(i);
			mn+=min(a,b); //每次最小即最后最小
			mx+=max(a,b); //每次最大即最后最大
		}
	}
	printf("%d %d\n",mn,mx);
	return 0;
}
```

---


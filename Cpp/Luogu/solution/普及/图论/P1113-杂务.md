# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# 题解

## 作者：Nishikino_Curtis (赞：783)

简单来说，因为任务可以并发，所以一个任务如果有前驱的话，最优方案便是在它的最晚一个前驱结束后就立即开始，而且任务k的前驱节点一定小于k，所以读入时顺便从它的前驱里挑一个最大的转移即可。同时可以更新最终答案。

*我是仗着代码短才来发的*

---
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
 ```

---

## 作者：Keith_2006 (赞：609)

## 这是一道拓扑排序的模板题

### 0 写在前面

UPD 2024-09-08 看自己四年前的博客重新学习拓扑排序，顺便修改笔误。

UPD 2020-05-13 修改了代码中没有初始化的小错误，修改了格式。

关于题解：虽然这道题的题解数量比较多，但是我认为我的题解相对来说比较清晰，易于理解，希望修改后管理能够通过审核。

此题解主要介绍拓扑排序的实现方法（如果有不对的地方还请大佬指教），文章略长，但是我认为还是比较清晰的，希望各位能够认真看完。

#### 在学习之前，请确保你拥有以下前置知识：

- 图论相关的基本概念

- 建图、存图

- 图的遍历

- 非常入门的 DP

---

*下面进入正文*

### 1 引入

拓扑排序是一类用于处理 DAG（Directed acyclic graph），即**有向无环图**上的问题。

以这道题为例，我们分析拓扑排序的作用：

显然地，本题中各项工作是有一定的**依赖条件**的，也就是说我们在进行工作 X 之前可能需要先进行一些其他的工作。

而完成工作 X 所需的时间和所有 X 所依赖的工作完成的时间的最大值有关。（应该还好理解吧）

在这道题中，我们可以列出一个简单的 DP 转移方程：

$$f_i=\max\{pre_i\}+a_i$$

其中 $f_i$ 为从最开始到进行完第 $i$ 项任务所需的时间，$pre_i$ 为 $i$ 号结点的前驱数组，$a_i$ 为做第 $i$ 件事所需的时间。

但是，我们如果直接进行 dfs 遍历，可能会出现一个问题：在我们**计算 $f_i$ 的时候，还存在没有计算过的 $pre_i$**，从而导致结果计算错误。

那么，我们在计算的时候，应该确保**在计算一个结点 $u$ 时，所有与连向它的点都已经被计算过**。

而实现这一过程就利用到了今天的主角：**拓扑排序（topo sort）**

***

### 2 ~~拓扑排序~~  记忆化搜索！

蛤？你不是要说拓扑排序吗？

别急，我们先来看一下记忆化搜索的方法。通过此方法，我们仍然可以达到拓扑排序的目的。

先放上代码:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>

#define ll long long

using namespace std;

inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}

//以上都是模板，不解释

const int N=10005;

int a[N],f[N];  //f数组含义如上所示
vector <int> edge[N];  //我习惯使用vector邻接表存图，其他存图方式做法类似

//这里开始是重点

int dfs(int x) {
	if (f[x]) return f[x];  //假如已经被访问过，直接返回
	for (int i=0;i<edge[x].size();i++) {  //循环：x 的每条出边指向的点
		f[x]=max(f[x],dfs(edge[x][i]));  //DP，求pre的最大值
	}
	f[x]+=a[x];  //加上a[i]的值，即DP方程
	return f[x];  //返回DP的结果
}

int main() {
	int n=read();
	for (int i=1;i<=n;i++) {
		int x=read(); //编号
		a[i]=read();  //所需时间
		int y=read();
        //以下的读入不解释
		while (y!=0) {
			edge[y].push_back(x);
			y=read();
		}
	}
    //对于每一个点进行dfs，求f的值
	int ans=0;
	for (int i=1;i<=n;i++) {
		ans=max(ans,dfs(i));  //取最大值
	}
	printf("%d\n",ans);  //输出结果
	return 0;
}
```

那么，为什么这个代码可以实现拓扑排序的目的呢？

先看一张图：

![graph.png](https://i.loli.net/2020/02/24/IPTLBYEg5K4R2Jr.png)

在主函数的 `for` 循环中执行 `dfs(1)` 的时候，$2$ 号点的前驱 $3$ 号点还没有被访问。但是在执行`dfs(3)`的时候，$2$ 号点就被访问了。

同理，$4$号点亦是如此，读者可自己在头脑中推演一遍。

也就是说，在整个循环中，**一定会存在一次`dfs(i)`的时候，其前驱全部被访问**。

因此就实现了拓扑排序的功能。

其实，这个代码可以认为是广义上的拓扑排序，即实现了对结点访问顺序进行排序的功能，只是实现的方式为 dfs 而已。

***

### 3 “真正”的拓扑排序（也许可以说是 bfs 式拓扑排序）

这种拓扑排序通常是指狭义上的拓扑排序，当然，我更喜欢将整个过程理解为一个bfs的过程。

对于一个bfs的过程而言，我们首先要找到搜索的起始点，也就是一开始加入队列中的点。

显然，这个点不能有任何前驱，因此我们要**找入度为0的结点加入队列**。

有读者可能要问了：要是没有入度为 $0$ 的结点该怎么办呢？

其实，这种情况在一个 **DAG** 中是**不存在**的。下面证明：**一个 DAG 中一定存在至少一个入度为 $0$ 的结点**。

利用反证法，假设不存在任何一个入度为 0 的结点，则每个结点的入度至少为1。

这样，对于结点 $G_1$，一定存在 $G_2$ 为 $G_1$ 的前驱。同理，一定存在 $G_3$ 为 $G_2$ 的前驱。以此类推，假设图共有 $n$ 个结点，那么一定有 $G_n$ 为 $G_{n-1}$ 的前驱。

那么，如果 $G_{n}$ 存在前驱 $G_i$ 满足 $1 \leq i \leq n$，那么就会形成一个环，与条件 DAG 矛盾。如果该店不存在前驱，则那个点的入度为0，与假设矛盾。

故此，我们证明了不存在 DAG 中没有入度为 0 的结点的情况。

然后，我们遍历每个结点 $x$ 的出边，考虑到达的一个点，假设为 $y$，我们删去 $x$ 到 $y$ 的边。

在代码实现中，其实是取出队列的队头 $x$，将 $y$ 的**入度减一**即可。在此过程中，通常利用动态规划对数据进行**维护**。在这道题目中，便是这一行代码`f[y]=max(f[y],f[x]+a[y]);`

当一个点的**入度减到 0 时**，说明所有它的**所有前驱已经被计算过了**，那么我们将它**插入队列**。

**重复以上步骤，直到队列为空**。这时我们就已经统计出了答案。

#### 总结一下，此种拓扑排序共有四个主要步骤：

1. **初始化队列，将入度为 $0$ 的节点放入队列。**
2. **取出队首，遍历其出边，将能够到达的点入度减一，同时维护答案数组。**
3. **若在此时一个点的入度变为 $0$，那么将其加入队列。**
4. **回到第二步，直到队列为空。**

代码放出来给读者参考：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>

#define ll long long

using namespace std;

inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}

const int N=500005;

int ind[N],f[N],a[N];  //ind--入度   f--答案   a--时间
vector <int> edge[N];
queue <int> q;

int main() {
	int n=read();
	for (int i=1;i<=n;i++) {
		int x=read();
		a[i]=read();
		while (int y=read()) {
			if (!y) break;
			edge[y].push_back(x);
            ind[x]++;
		}
	}
    //步骤一
	for (int i=1;i<=n;i++) {
		if (ind[i]==0) {
			q.push(i);
			f[i]=a[i];
		}
	};
	while (!q.empty()) {
		int rhs=q.front();
		q.pop();
        //步骤二
		for (int i=0;i<edge[rhs].size();i++) {
			int u=edge[rhs][i];
			ind[u]--;
			if (ind[u]==0) q.push(u);  //步骤三
			f[u]=max(f[u],f[rhs]+a[u]);
		}
	}
	int ans=0;
	for (int i=1;i<=n;i++) {
		ans=max(ans,f[i]);   //统计答案
	}
	printf("%d\n",ans);
	return 0;
}
```

考虑到上面我已经讲地比较清楚了，这里代码不加过多注释，仅标记关键处。

***

### 4 一些题目

#### 做完这一道拓扑排序模板题之后，大家可以移步：

[P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)

[P1983 车站分级](https://www.luogu.com.cn/problem/P1983)

很多 DAG 上的 DP 都需要依赖于拓扑排序，也有很多题目是需要先进行缩点然后再拓扑排序，比如说这个题：

[P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

（其实很大一部分和强连通分量有关的题目都利用到拓扑排序）

***

####  完结撒花 QAQ！

*如果觉得文章有一些帮助的话不妨点个赞哦！谢谢！*

---

## 作者：George1123 (赞：84)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1113 【杂务】传送门](https://www.luogu.org/problem/P1113)

### 此题算法:拓扑排序

大致思路:

>1.$ $输入杂物耗时，用$vector$存下它的先决杂物。并用数组$rud[i]$存下第$i$个杂物的先决杂物个数(即入度)。

>2.$ $将所有入度为$0$的点$i$加入队列并将$dp[i]$(表示第$i$个杂物的最早完成时间)的值置为第$i$个杂物的耗时$tim[i]$。

>3.$ $只要队列不空，拿出队列顶端的杂物$now$并用$now$更新以$now$为先决杂物的杂物$nex$的$dp[nex]$的值。使$dp[nex]=max(dp[nex],dp[i]+tim[nex])$。再将$rud[nex]--$。如果$rud[nex]$为$0$时，将点$nex$加入队列。

>4.$ $求出所有$dp[i]$的最大值$ans$就是答案。

一个栗子：

![](https://s2.ax1x.com/2019/09/13/nrlyT0.jpg)

## 以下是代码+注释 
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10010;
int n,t,tim[N],e;
int rud[N],dp[N],ans;
vector<int> to[N];
queue<int> q;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&t);
		scanf("%d",tim+t);
		scanf("%d",&e);
		while(e!=0){
			to[e].push_back(t);、
			//vector存先决杂物
			rud[t]++;
			scanf("%d",&e);
		} 
	} for(int i=1;i<=n;i++)
		if(!rud[i]){
			q.push(i);
			dp[i]=tim[i];
		}//处理开始时入度为0的点
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=0;i<to[now].size();i++){
			int nex=to[now][i];
			dp[nex]=max(dp[nex],dp[now]+tim[nex]);//如题
			rud[nex]--;
			if(rud[nex]==0)
				q.push(nex);
		}
	} for(int i=1;i<=n;i++)
			ans=max(ans,dp[i]);
	printf("%d\n",ans);
	return 0;
}
```
没事就做做杂物吧。

谢谢大家! !


---

## 作者：amstar (赞：32)

拓扑排序。





```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int N = 10005;
queue <int> q;
bool e[N][N];
int ti[N];
int mx[N];
int ru[N];
int n,ans;
void topo()
{
    for(int i=1;i<=n;++i)
        if(ru[i] == 0) 
        {
            q.push(i);
            mx[i] = ti[i];
        }
    while(!q.empty())
    {
        int d = q.front();
        q.pop();
        for(int i=1;i<=n;++i)
        {
            if(e[d][i])
            {
                ru[i]--;
                if(ru[i]==0) q.push(i);
                mx[i] = max(mx[i],mx[d]+ti[i]);
            }
        }
    }
    for(int i=1;i<=n;++i)
        ans = max(ans,mx[i]);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        ti[a] = b;
        while(c!=0)
        {
            ru[a]++;
            e[c][a] = true;
             scanf("%d",&c);
        }
    }
    topo();
    printf("%d",ans);
    return 0;
}
```

---

## 作者：llllllQ (赞：28)

拓扑排序入门题

开数组记录节点结束与开始时间

入队列前不断更新节点开始时间

出队列时更新节点结束时间

排序后选数组最大值输出

唯一问题是这份代码C++11过不了

```cpp
#include<cstdio>
#include<memory.h>
#include<queue>
#define MAXN 10005
#define MAXM 10000005
using namespace std;

int n,id=0;
int Y[MAXM];
int next[MAXM];
int head[MAXN];
int END[MAXN];//初始记录杂物开始时间，更新后记录杂物结束时间 
int T[MAXN];
int idu[MAXN];//拓扑存 入度  
queue<int> Q;

void ADD(int a,int b)//链式前向星 
{
	Y[++id]=b;
	next[id]=head[a];
	head[a]=id;
	idu[b]++;
}

void SCAN()
{
	scanf("%d",&n);
	int i;
	for(i=1; i<=n; i++)
	{
		int a,c=1;
		scanf("%d",&a);
		scanf("%d",&T[a]);
		scanf("%d",&c);
		while(c)
		{
			ADD(c,a);
			scanf("%d",&c);
		}
	}
}

int TP()//拓扑排序 
{
	memset(END,0,sizeof(END));
	int ans=0;
	int i;
	for(i=1; i<=n; i++)
		if(!idu[i])
		{
			Q.push(i);
		}
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop();
		END[x]+=T[x];
		ans=ans>END[x]?ans:END[x];
		int i;
		for(i=head[x]; i; i=next[i])
		{
			idu[Y[i]]--;
			END[Y[i]]=END[Y[i]]>END[x]?END[Y[i]]:END[x];
			//被更新节点开始时间为原被更新节点开始时间与前驱节点结束时间的较大值 
			if(!idu[Y[i]])
			{
				Q.push(Y[i]);
			}
		}
	}
	return ans;
}

int main()
{
	SCAN();
	printf("%d",TP());
	return 0;
}
```

---

## 作者：尹昕20160508 (赞：27)

#一定要用。。。。。。

```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>//无聊定这么多 
using namespace std;
int main(){ 
    int t[10001],n,ans=0,k,num,ti,x,y,i;//定这么一大坨东西 
    scanf("%d",&n);
    for(i=1;i<=n;i++){ 
        scanf("%d%d",&k,&ti);
        t[k]=ti;
        scanf("%d",&x);
        while(x!=0){ 
               t[k]=max(t[k],ti+t[x]);
               ans=max(ans,t[k]);//更新操作
            scanf("%d",&x);
        } 
    } 
    printf("%d",ans);
    return 0;
} 

```

---

## 作者：Manjusaka丶梦寒 (赞：11)

翻了翻题解发现都是什么拓扑？最长路？dfs？哦！！我天，dalao dalao。

不过楼下dalao的代码长度着实让我折服。

为什么要做的那么麻烦。

在这说一下我的解法，既然第k件事的准备一定在第1到k-1件事中，那么不难想到二者之间的联系。
那么开始循环处理每一件事的结束时间，比较取max不就好了，具体理解看代码。
```cpp
/*....................
作者：Manjusaka
时间：2018/7/5
题目：luogu P1113 杂务  
......................*/

#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
int n,ans;
struct ahah
{
    int need,over;        // need 表示需要时间 ，over表示结束时间。 
    int pre[111],tot;    // pre[],tot 表示开始这件事前有tot件事要准备，pre储存。 
} edge[10010];
int main()
{
    int x,y,z;
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
        scanf("%d%d",&x,&edge[i].need);
        while(scanf("%d",&y)==1&&y!=0)edge[x].pre[++edge[x].tot]=y;
    }
    edge[1].over=edge[1].need;
    for(int i=2; i<=n; i++)
    {
        for(int j=1; j<=edge[i].tot; j++)
        {
            edge[i].over=max(edge[i].over,edge[edge[i].pre[j]].over+edge[i].need);
        //可能比较混乱，这件事的结束时间一定是这些事完成后再做，
        //所以取每件事完成的时间加上现在这件事的时间 ,作为目前所处理到的时间的完成时间。 
        }
        ans=max(ans,edge[i].over);
    }
    printf("%d",ans);
}
```

---

## 作者：SW_Wind (赞：9)

水题一道

用f[i]表示完成第i件任务最早时间

然后所有f[i]中最大的就是完成所有任务的最少时间

不过我代码是不是短了点。。。（跟楼下的比起来）

```cpp
#include <bits/stdc++.h>//偷懒专用包
using namespace std;
int f[10005], n, k, ans, t;//ans保存答案（不说也知道= =）
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d", &k, &t);//其实这个k并没有什么卵用
        while(scanf("%d", &k) && k)//当k等于0就会跳出循环
            f[i] = max(f[k], f[i]);//从这件事所有的前提中找到一个最迟完成的，这就是这件事的最早起始时间
        f[i] += t;//然后加上完成这件事所需要的时间就是这件事最早完成的时间
        ans = max(ans, f[i]);//统计答案
    }
    printf("%d", ans);
}
```
完美AC，一次过


---

## 作者：柒命九陨_ (赞：8)

翻遍了题解，发现各位基本全是拓扑做的，一片拓扑序…… 而我太弱了，完全不知道怎么拓扑……

不过很明显这题是求一个最长路，于是我就只能从1号节点开始搜索…… 不过大爆搜肯定是会TLE的，于是我就加了一个记忆化数组。

### 因为以一个节点为根的子树的最长路不变且将会被重复使用，就可以写出记忆化搜索。

作为dp的记搜一般是 n^2 的，而一个图是有边作为限制的，所以复杂度大概是 O(m) ，本题 m 最大值小于 10000 * 100 ，可过。

题解中只有一个和我思路相同的，不过他写的是纯dp~~，而我也不会写dp~~。

最后挂上 1A 0ms 代码，很简单的~

```cpp
#include <queue>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 10000 + 10;
int n, head[maxn], memo[maxn], tim[maxn], edge_num;

struct Edge{ int v, nxt; }edge[100 * maxn];

inline int read() {
  register char ch = 0; register int x = 0;
  while( !isdigit(ch) ) ch = getchar();
  while( isdigit(ch) ) x = (x * 10) + (ch ^ 48), ch = getchar();
  return x;
}

inline void Add_edge(int u, int v) {
  edge[++edge_num].v = v;
  edge[edge_num].nxt = head[u], head[u] = edge_num;
}

int Decade_fripSide(int x) {
  if( memo[x] ) return memo[x];
  if( !head[x] ) return tim[x];
  for(int i = head[x]; i; i = edge[i].nxt)
    memo[x] = max(memo[x], Decade_fripSide(edge[i].v) + tim[x]);
  return memo[x];
}

int main(int argc, char const *argv[])
{
  int v = 0;
  scanf("%d", &n);
  for(int i = 1; i <= n; ++i) {
    v = read(), tim[i] = read();
    while( v = read() ) Add_edge(v, i);
  }
  printf("%d\n", Decade_fripSide(1));

  return 0;
}
```

---

## 作者：fysbb (赞：7)

基本上是模板的拓扑排序。在过程中将最大耗时的准备工作的时间加到当前工作上，算出新的时间，最后所有工作中耗时最长的就是结果。

          program project1;
          var
             n,i,p,ans:longint;
             a,b,ru:array[0..10005]of longint;
             f:array[1..10005,0..105]of longint;
             tf:array[1..10005]of boolean;
          procedure psort;
          var l,r,i,p:longint;
              q:array[1..10005]of longint;
          begin
            l:=0;
            r:=0;
            fillchar(q,sizeof(q),0);
            for i:=1 to n do if ru[i]=0 then begin 
              inc(r);
              q[r]:=i;
              tf[i]:=true; 
            end;
            repeat
              inc(l);p:=q[l];
              for i:=1 to f[p,0] do begin
                if (tf[f[p,i]]=false) then begin
                  dec(ru[f[p,i]]);
                  if b[f[p,i]]<a[p]+a[f[p,i]] then 
                      b[f[p,i]]:=a[p]+a[f[p,i]];
                  if (ru[f[p,i]]=0) then begin 
                    inc(r);
                    q[r]:=f[p,i];
                    tf[f[p,i]]:=true;
                    a[f[p,i]]:=b[f[p,i]]; 
                  end;
                end;
              end;
            until l>=r;
          end;

          begin
             fillchar(a,sizeof(a),0);
             fillchar(b,sizeof(b),0);
             fillchar(ru,sizeof(ru),0);
             fillchar(f,sizeof(f),0);
             fillchar(tf,sizeof(tf),false);
             readln(n);
             for i:=1 to n do begin
               read(P);
               read(a[i]); b[i]:=a[i];
               read(p);
               while p<>0 do begin
                 inc(f[p,0]);
                 inc(ru[i]);
                 f[p,f[p,0]]:=i;
                 read(P);
               end;
             end;
             psort;
             for i:=1 to n do if ans<=a[i] then ans:=a[i];
             writeln(ans);
             readln;
             readln;
          end.

---

## 作者：AXXWTGST (赞：4)

暴力,当一个任务完成时，看其他的任务能不能完成，但好像比拓扑排序慢一些

```cpp
#include<iostream>
#include<queue>
using namespace std;
int n;
int len[10005];//rt
bool cs[10005][10005];//cs[i][j]:j是否为i的先决条件
bool pd[10005];
struct axx
{
    int num;
    int wz;
    bool operator <(const axx p)const
    {
        return num>p.num;
    }
    axx(int a,int b)
    {
        wz=a;
        num=b;
    }
};
int time[10005];//最快i的完成时间
int tj[10005];//i有多少个先决条件
priority_queue<axx> bd;//所有同时进行的工序，使完成最早的先输出
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x>>len[i];
        bool xpd=true;
        while(xpd==true)
        {
            int y;
            cin>>y;
            if(y==0)
            {
                xpd=false;
            }
            else
            {
                tj[x]++;
                cs[x][y]=true;
            }
        }
    }
    bd.push(axx(1,len[1]));
    time[1]=len[1];
    pd[1]=true;
    while(!bd.empty())
    {
        axx u=bd.top();
        bd.pop();
        pd[u.wz]=true;
        for(int i=1;i<=n;i++)
        {
            if(cs[i][u.wz]==true&&pd[i]==false)
            {
                cs[i][u.wz]=false;
                tj[i]--;
                if(tj[i]==0)
                {
                    time[i]=u.num+len[i];
                    bd.push(axx(i,time[i]));
                }
            }
        }
    }
    int axxmax=0;
    for(int i=1;i<=n;i++)
    {
        axxmax=max(axxmax,time[i]);
    }
    cout<<axxmax<<endl;
    return 0;
}
```

---

## 作者：kevin_y (赞：2)

用暴搜水过此题，~~我还是太菜了~~

看了楼上的dp大佬实在佩服（~~看不懂~~）所以我还是发个暴搜代码吧

这题主要要注意的是工作序号已经按照字典序排序，且这个工作要先完成的一定在其前面。

```cpp
#include<iostream>
using namespace std;
int n,a[10001][101],t[10001]={0},maxans=-1;//其中a[i][0]表示第i个工作的准备工作的个数
bool b[10001];//剪枝
inline int max(int x,int y){//手打快一点
	return x>y?x:y;
}
int fine(int x){
	int maxx=-1;
	for(int i=1;i<=a[x][0];i++){
		if(!b[a[x][i]]){
			b[a[x][i]]=1;
			if(a[a[x][i]][0]!=0)t[a[x][i]]+=fine(a[x][i]);//如果准备工作还有准备工作，继续搜索
		}
		maxx=max(maxx,t[a[x][i]]);
	}
	return maxx;//返回最大值
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){//输入
		int k,len,x,tt=0;
		cin>>k>>len>>x;//k是字典序号，len是此项耗时
		t[k]=len;//自己的耗时
		while(x){//x等于0时，退出
			a[k][++tt]=x;
			cin>>x;
		}
		a[k][0]=tt;//上面解释过了
	}
	for(int i=n;i>=1;i--)if(!b[i]){//如果没有搜索过
			b[i]=1;
			if(a[i][0])t[i]+=fine(i);
		}
	for(int i=1;i<=n;i++)maxans=max(maxans,t[i]);//取最大值
	cout<<maxans<<endl;
	return 0;//好习惯
}
```

---

## 作者：lzpclxf (赞：2)

**为什么要写这篇题解？**

一楼题解代码短也易于理解
就是循环内输入的时候我死活也不明白为什么输入i
然后按照自己的理解输了个顺序结果A了。
再回去看题， 就明白了为啥了 就很想写写。
~~（帮助和我一样的小萌新）~~

**solution**

根据题目意思 ， _他的时间可以为在他之前所有的必做的工作中时间结束最晚的再加上他的时间， 取max就好_ 

与一楼题解不一样的是我循环内输入时， 关于局部变量和全局变量， 在for循环里再输入i会影响循环吧？所以就不是很明白， 我直接就重新开了一个变量记录， 结果是可以A掉的

但是！！再重新看题目， 顺序啊， 输入i不影响啊， 因为是按照顺序来的啊， 所以这里再开一个变量记录顺序和直接输入i两者都是对的， ~~（我说的好像没什么用， 卑微）~~

so 

The Last:
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 10000;
int n, a[N], num, x, len, ans, sum, lz[N];
int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1;ch = getchar();}
	while(isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
	return s * w;
}
int main() {
	n = read();
//	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		num = read();
//		scanf("%d", &num);
		len = read();
//		scanf("%d", &len);
		sum = 0;
		while(scanf("%d", &x) && x) 
			sum = max(sum, lz[x]);
		lz[num] = sum + len;
		ans = max(ans, lz[num]);
	}
	printf("%d\n", ans);
	return 0;
} 
```

谢谢收看， 祝身体健康！

---

## 作者：Gino_Hong (赞：2)

看到楼下一堆dp和spfa让我这个学图论的心中很不是滋味啊

虽说都能过 但这题放在较复杂图论模块里的原因

看题干个人认为是因为考的是AOV网中的关键路径算法

模拟出关键路径之后计算该路径所花的时间就是题目答案了

想贡献一套数据结构书上关键路径的伪代码模板

void FindInDegree(ALGraph G,int indegree[]) {

/\* 求顶点的入度，算法7.12、7.13调用 \*/

```cpp
    int i;
    ArcNode *p;
    for(i=0; i<G.vexnum; i++)
        indegree[i]=0; /* 赋初值 */
    for(i=0; i<G.vexnum; i++) {
        p=G.vertices[i].firstarc;
        while(p) {
            indegree[p->adjvex]++;
            p=p->nextarc;
        }
    }
}
Status TopologicalOrder(ALGraph G,SqStack *T) {
```
/\* 算法7.13  有向网G采用邻接表存储结构,求各顶点事件的最早发生时间ve \*/
/\* (全局变量)。T为拓扑序列顶点栈,S为零入度顶点栈。若G无回路,则用栈T \*/

/\* 返回G的一个拓扑序列,且函数值为OK,否则为ERROR \*/

```cpp
    int j,k,count,indegree[MAX_VERTEX_NUM];
    SqStack S;
    ArcNode *p;
    FindInDegree(G,indegree);/*对各顶点求入度indegree[0..vernum-1] */
    InitStack(&S); /* 初始化栈 */
    for(j=0; j<G.vexnum; ++j) /* 建零入度顶点栈S */
        if(!indegree[j])
            Push(&S,j); /* 入度为0者进栈 */
    InitStack(T); /* 初始化拓扑序列顶点栈 */
    count=0; /* 对输出顶点计数 */
    for(j=0; j<G.vexnum; ++j) /* 初始化ve[]=0 (最小值) */
        ve[j]=0;
    while(!StackEmpty(S)) {
```
/\* 栈不空 \*/
```cpp
        Pop(&S,&j);
        Push(T,j); /* j号顶点入T栈并计数 */
        ++count;
        for(p=G.vertices[j].firstarc; p; p=p->nextarc) {
```
/\* 对j号顶点的每个邻接点的入度减1 \*/

```cpp
            k=p->adjvex;
            if(--indegree[k]==0) /* 若入度减为0,则入栈 */
                Push(&S,k);
            if(ve[j]+*(p->info)>ve[k])
                ve[k]=ve[j]+*(p->info);
        }
    }
    if(count<G.vexnum) {
        printf("此有向网有回路\n");
        return ERROR;
    } else
        return OK;
}
Status CriticalPath(ALGraph G) {
```
/\* 算法7.14 G为有向网,输出G的各项关键活动 \*/
```cpp
    int vl[MAX_VERTEX_NUM];
    SqStack T;
    int i,j,k,ee,el;
    ArcNode *p;
    char dut,tag;
    if(!TopologicalOrder(G,&T)) /* 产生有向环 */
        return ERROR;
    j=ve[0];
    for(i=1; i<G.vexnum; i++) /* j=Max(ve[]) 完成点的值 */
        if(ve[i]>j)
            j=ve[i];
    for(i=0; i<G.vexnum; i++) /* 初始化顶点事件的最迟发生时间(最大值) */
        vl[i]=j; /* 完成点的最早发生时间 */
    while(!StackEmpty(T)) /* 按拓扑逆序求各顶点的vl值 */
        for(Pop(&T,&j),p=G.vertices[j].firstarc; p; p=p->nextarc) {
            k=p->adjvex;
            dut=*(p->info); /* dut<j,k> */
            if(vl[k]-dut<vl[j])
                vl[j]=vl[k]-dut;
        }
    printf(" j  k  dut  ee  el  tag\n");
    for(j=0; j<G.vexnum; ++j) /* 求ee,el和关键活动 */
        for(p=G.vertices[j].firstarc; p; p=p->nextarc) {
            k=p->adjvex;
            dut=*(p->info);
            ee=ve[j];
            el=vl[k]-dut;
            tag=(ee==el)?'*':' ';
            printf("%2d %2d %3d %3d %3d    %c\n",j,k,dut,ee,el,tag); /* 输出关键活动 */
        }
    printf("关键活动为:\n");
    for(j=0; j<G.vexnum; ++j) /* 同上 */
        for(p=G.vertices[j].firstarc; p; p=p->nextarc) {
            k=p->adjvex;
            dut=*(p->info);
            if(ve[j]==vl[k]-dut)
                printf("%s→%s\n",G.vertices[j].data,G.vertices[k].data); /* 输出关键活动 */
        }
    return OK;
}
```

---

## 作者：Silicon (赞：2)

我来发一个DP的题解。根据题意，对于每一个事情，他的依赖都严格小于他本身。那么我们可以用dp[i]表示第i件事情最早可以在什么时候做完，转移为dp[i]=max(dp[j])+time[i]，其中j是i的所有依赖项，代码如下：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=10100;
int n,value,number,max,to,f[maxn],num;
int main()
{
    scanf("%d",&n);
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&num);
        scanf("%d",&value);
        max=0;
        scanf("%d",&to);
        while(to)
        {
            if(f[to]>max) max=f[to];
            scanf("%d",&to);
        }
        f[i]=max+value;
    }
    max=0;
    for(int i=1;i<=n;i++)
        if(f[i]>max)
            max=f[i];
    printf("%d\n",max);
    return 0;
}
```
在某次模拟赛中遇到到这道题，按照当时的状况，似乎这个dp比拓扑排序快一点，然而我并不太会证明这个玩意的复杂度是多少，各位看官神犇可以自行脑补。。。

最后 sro tyc神犇


---

## 作者：QWsin (赞：2)

**
我滴个天-> ->代码写完直接过编译  直接过样例  直接AC

要不要这么吊= =

根据拓扑序的思想 它必定是晚于所有准备工作的

那么准备工作里面最晚完成时间就是它最早开始时间

边界是没有准备工作的的任务  它的完成时间等于该任务耗费时间

然后都看出来了吧= =就是个记忆化而已

因为并不知道哪一个是最后完成的  所以对于每个任务DP一次

因为有记忆化  并不用担心这样会降低时间效率

最后再挑出n个里面的最晚完成时间

就是答案啦= =  不过最长路好像也可以  但是写不来QAQ

关于vector的使用= =因为我找不到什么好的存边的方法 直接存爸爸好了= =

**
```cpp

#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=10000+10;
vector<int>p[maxn];

int n,t[maxn];
void init_data()
{
    cin>>n;
    for(int i=1,fa;i<=n;i++)
    {
        scanf("%*d%d",t+i);
        scanf("%d",&fa);
        while(fa)
        {
            p[i].push_back(fa);
            scanf("%d",&fa);
        }
    }
}

int dp[maxn];
int f(int u)
{
    if(p[u].size()==0) return dp[u]=t[u];
    if(dp[u]!=-1) return dp[u];
    int l=p[u].size(),ft=0;
    for(int i=0;i<l;i++)
    {
        ft=max(ft,f(p[u][i]));
    }
    return dp[u]=ft+t[u];
}

int main()
{
    init_data();
    memset(dp,-1,sizeof(dp));
    for(int i=1;i<=n;i++)
      f(i);
    int ans=0;
    for(int i=1;i<=n;i++)
      ans=max(ans,dp[i]);
    printf("%d",ans);
    return 0;
}


```

---

## 作者：ShineEternal (赞：2)

# 题目：
## 题目描述

John的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务1。John有需要完成的n个杂务的清单，并且这份清单是有一定顺序的，杂务k(k>1)的准备工作只可能在杂务1至k−1中。

写一个程序从1到n读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定John的农场有足够多的工人来同时完成任意多项任务。

# 分析：
此题可以使用拓扑排序来做：
- 开数组记录节点结束与开始时间
- 入队列前不断更新节点开始时间
- 出队列时更新节点结束时间
- 排序后选数组最大值输出
## 一切都是那么的和谐

那么问题来了，有没有更简（du）单（liu）的做法呢？

考虑的任务可以同时做，所以一个任务的最优方案就是等到他最晚的准备工作结束后紧接着做。题目保证按顺序给出，所以直接可以边读边做。

# [代码](https://blog.csdn.net/kkkksc03/article/details/83117703)

---

## 作者：小周猪猪 (赞：2)

## 杂务题解
听说这道题很难，什么关键路径的蒟蒻听不懂.....题解中的其他奇奇怪怪的算法蒟蒻也看不懂.....只需要做一遍简单的拓扑排序就能AC了，在做的时候进行一定的处理即可.

没错，这道题中每个任务都是有先后顺序的，即完成一样任务才能完成另外一样任务，显然我们可以联想到拓扑排序，即，跟剧它们的拓扑序去完成即可.

这道题目就是求的是完成任务最短时间，我们只要在进行拓扑排序的过程中及时更新结果即可.

具体做法如下：
跟剧拓扑的先后顺序进行建图，由先完成的任务编号连向未完成的任务编号（emmmm代码比较丑啦，STL+手写混用的啦），再跟剧出度为0的点连向虚拟原点n+1（这是我们自己设置的点），边权为0，这样我们统计结果时只要输出sum[i+1]即可，sum[i]表示完成任务i至少要多少时间.

那么，在拓扑的过程中，若当前结点为temp，拓展的结点为next，那么不难得出：
sum[next]=max(sum[next],sum[temp]+Time[next]),即花费的时间为上一个结点的任务加上当前时间，那么就可以完成统计答案的过程.

我会在程序中适当下一些注释，若没有看懂可以在评论区中评论.

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[10000000];
int head=1,tail=0;
int in[10000000];//入读
int out[10000000];//出度
int sum[10000000];//统计时间
int Time[10000000];//标记任务时间
vector<int>Map[1000000];//用于代替邻接表的存储
int main()
{
	ios::sync_with_stdio(false);//读入优化
	int n;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		int num,last;
		cin>>num>>Time[i];
		while (cin>>last)//不断循环读入
		{
			if (!last) break;
			in[num]++;
			out[last]++;
			Map[last].push_back(num);//建图
		}	
	}	
	for (int i=1;i<=n;i++)
		if (!in[i]) 
		{
			q[++tail]=i;
			sum[i]=Time[i];
		}//将入读为0的点加入队列
	for (int i=1;i<=n;i++)
		if (!out[i])
		{
			Map[i].push_back(n+1);
			in[n+1]++;
		}//建立虚拟原点
	while (head<=tail)
	{
		int temp=q[head];head++;
		for (int i=0;i<Map[temp].size();i++)
		{
			int next=Map[temp][i];
			in[next]--;
			if (!in[next]) q[++tail]=next;
			sum[next]=max(sum[temp]+Time[next],sum[next]);
		}
	}//以上为topsort的全过程
	cout<<sum[n+1]<<endl;
	return 0;
} 
```

---

## 作者：BriMon (赞：2)

模拟赛考了这题QAQ

用到了拓扑排序思想；

每一个工作可以开始的前提是它的前期工作必须全部完成；

所以， 只需要从它前期工作的时间中取max加上它的时间， 就可以转移到它；

细节都在代码里了；

```cpp
#include <bits/stdc++.h>//懒...

using namespace std;

int n;
int dp[10010];
int rud[10010];//入度 
int v[100010];//价值
int ans;

vector <int> net[10010];

inline void Search(int cur)
{
	for(register int i = 0 ; i < net[cur].size() ; i ++)
	{
		int x = net[cur][i];
		rud[x]--;
		dp[x] = max(dp[x], dp[cur] + v[x]);//状态转移 
		ans = max(ans, dp[x]);
		if(rud[x] == 0)
		{
			 Search(x);
		}
	}
}

int main()
{
	cin >> n;
	
	for(register int i = 1 ; i <= n ; i ++)
	{
		int x;
		cin >> x;
		scanf("%d", &v[i]);
		int y;
		while(scanf("%d", &y) != EOF)
		{
			if(y == 0) break;
			rud[x]++;
			net[y].push_back(x);干完y后可以开始x 
		}
	}
	
	dp[1] = v[1];//注意！！！ 
	
	Search(1);//从第一项开始拓扑； 
	
	cout<<ans;
	
	return 0;
}
```
竟然这题只有60行？（我不是压行选手（逃.

---

## 作者：lxhhhh (赞：1)

[题目见此处](https://www.luogu.org/problemnew/show/P1113)

这题读几遍题就可以推出dp方程：

f[i]=a[i]+max(f[b[i][0]]...f[b[i][n]])

f[i]是第i个项目的完成时间，

a[i]是第i个项目所需时间，

b[i][j]是第i个项目的前提项目，

于是我得出（别粘，会爆内存，而且是错的）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10001
int n,a[N],b[N][N],f[N];
inline int read(){
	int X=0,w=0;
	char ch=0;
	while(!isdigit(ch)){
		w|=ch=='-';
		ch=getchar();
	}
	while(isdigit(ch)){
		X=(X<<3)+(X<<1)+(ch^48);
		ch=getchar();
	}
	return w?-X:X;
}
int dp(int x){
	if(f[x]!=-1){
		return f[x];
	}
	if(b[x][1]==0){
		return f[x]=a[x];
	}
	for(int i=1;1;i++){
		if(b[x][i]==0){
			break;
		}
		f[x]=max(f[x],dp(b[x][i]));
	}
	f[x]+=a[x];
	return f[x];
}
int main(){
	memset(f,-1,sizeof(f));
	n=read();
	for(int i=1;i<=n;i++){
		int k=read();
		a[k]=read();
		int j=1;
		while(1){
			b[k][j]=read();
			if(b[k][j]==0){
				break;
			}
			j++;
		}
	}
	printf("%d\n",dp(n));
	return 0;
}
```

因为爆了内存，所以我又想了想怎样优化，于是就把b[i][j]去掉了。

得出以下代码（别粘，还是错的）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10001
int n,a[N],f[N];
inline int read(){
	int X=0,w=0;
	char ch=0;
	while(!isdigit(ch)){
		w|=ch=='-';
		ch=getchar();
	}
	while(isdigit(ch)){
		X=(X<<3)+(X<<1)+(ch^48);
		ch=getchar();
	}
	return w?-X:X;
}
int main(){
	memset(f,0,sizeof(f));
	n=read();
	for(int i=1;i<=n;i++){
		int k=read();
		a[k]=read();
		int x;
		while(1){
			x=read();
			if(x==0){
				break;
			}
			f[k]=max(f[k],f[x]);
		}
		f[k]+=a[k];
	}
	printf("%d\n",f[m]);
	return 0;
}
```

但只对了1个点，于是发现
# 第m个不一定最后才完成
所以又改了改代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10001
int n,a[N],f[N],ans=0;
inline int read(){
	int X=0,w=0;
	char ch=0;
	while(!isdigit(ch)){
		w|=ch=='-';
		ch=getchar();
	}
	while(isdigit(ch)){
		X=(X<<3)+(X<<1)+(ch^48);
		ch=getchar();
	}
	return w?-X:X;
}
int main(){
	memset(f,0,sizeof(f));
	n=read();
	for(int i=1;i<=n;i++){
		int k=read();
		a[k]=read();
		int x;
		while(1){
			x=read();
			if(x==0){
				break;
			}
			f[k]=max(f[k],f[x]);
		}
		f[k]+=a[k];
		ans=max(ans,f[k]);
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：xukuan (赞：1)

开始完成这项家务的时间等于需要完成家务时间中的最大值


```cpp
#include<bits/stdc++.h>
using namespace std;

int n,work[10010]={0},len[10010]={0},a[10010][110]={0},sum[10010]={0},f[10010]={0};
//f[i]代表做完i家务的最小值
//work代表序号
//len代表时间
//a[i][j]代表j是i的基础

int wok(int k)
{
    int ans=0;
    for(int i=1; i<=sum[k]; i++)
      ans=max(ans,f[a[k][i]]);//取得最大值
    return ans+len[k];
}

void read()
{
    int x;
    scanf("%d",&n);//个数
    for(int i=1; i<=n; i++)
    {
        scanf("%d%d",&work[i],&len[i]);
        scanf("%d",&x);
        while(x!=0)//还没结束
        {
            sum[i]++;//总数
            a[i][sum[i]]=x;//存入数组中
            scanf("%d",&x);//继续输入
        }
    }
}

void write()
{
    int ans=0;
    for(int i=1; i<=n; i++)
      ans=max(ans,f[i]);//取最大值
    printf("%d ",ans);
}

int main()
{
    read();
    for(int i=1; i<=n; i++)
      f[i]=wok(i);
    write();
    return 0;
}
```

---

## 作者：Rainey (赞：1)

看到前面很多人用了拓扑排序，其实完全不用，排了因为已经排好了。。

**杂务k(k>1)的准备工作只可能在杂务1..k-1中**

完全是递推，最后注意答案不是f[n]而是f[1]~f[n]的最大值

```cpp
#include<cstdio>
using namespace std;
int f[10001]={0};
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int x,t,max=0;
        scanf("%*d%d%d",&t,&x);
        while(x!=0)
        {
            max=f[x]>max?f[x]:max;
            scanf("%d",&x);
        }
        f[i]=t+max;
    }
    int max=0;
    for(int i=1;i<=n;++i)
        max=f[i]>max?f[i]:max;
    printf("%d",max);
    return 0;
}
```

---

## 作者：fltflt1 (赞：1)

我用了一种最笨的方法。。。直接上拓扑/(ㄒoㄒ)/~~

还奇怪的WA了QAQ

后来发现需记录在做这个工作之前的最小的最大时间。

而不是经过最多准备工作的时间。。。。


PS:并不知道题目中的工作序号有什么卵用

```cpp
(
#include<stdio.h>
#include<algorithm>
#include<vector>
using namespace std;
int n,id[10005],t[10005],x,q[100005][3],l,r,d[10005],c[100005];
vector <int>a[10005];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&id[i]);
        scanf("%d",&t[i]);
        scanf("%d",&x);
        while(x)
        {
            a[x].push_back(i);
            d[i]++;
            scanf("%d",&x);
        }
    }
    l=1;
    for (int i=1;i<=n;i++)
        if (!d[i])
            r++,q[r][1]=i,q[r][2]=t[i];
    while(r<n)
    {
        for (int i=0;i<a[q[l][1]].size();i++)
        {
            d[a[q[l][1]][i]]--;
            if (q[l][2]>c[a[q[l][1]][i]])
                c[a[q[l][1]][i]]=q[l][2];
            if (!d[a[q[l][1]][i]])
            {
                r++;
                q[r][1]=a[q[l][1]][i];
                q[r][2]=c[a[q[l][1]][i]]+t[a[q[l][1]][i]];
            }
        }
        l++;
    }
    int ans=0;
    for (int i=1;i<=n;i++)
        ans=max(ans,q[i][2]);
    printf("%d\n",ans);
    //while(1);
    return 0;
}            
)
```（c/c++）


---

## 作者：凯特琳 (赞：1)

求要把所有杂物做完的 最小的时间，所以要跑最长路，因为是做完所有杂物，每一个点都要做。



AC代码：

```delphi

program exam1;
var map:array[1..1000000,1..3]of longint;
var f:array[1..10000]of longint;
var v:array[1..10000]of boolean;
var h:array[1..1000000]of longint;
var first:array[1..10000]of longint;
var bb:array[1..10000]of longint;
var tot,i,j,n,x,y,z,l,r,q,tt,qi,zhong,ans,len,num:longint;
procedure insert(a,b,c:longint);
begin
inc(tot);
map[tot,1]:=b;
map[tot,2]:=c;
map[tot,3]:=first[a];
first[a]:=tot;
end;
procedure spfa(ss:longint);
begin
//for i:=1 to n do
//if i<>ss then f[i]:=100000000;
fillchar(h,sizeof(h),0);
l:=0;
r:=1;
h[1]:=ss;
v[ss]:=true;
while l<r do
begin
inc(l);
q:=h[l];
tt:=first[q];
while tt<>0 do
begin
if f[map[tt,1]]<f[q]+map[tt,2] then
begin
f[map[tt,1]]:=f[q]+map[tt,2];
if f[map[tt,1]]>ans then
ans:=f[map[tt,1]];
if not v[map[tt,1]] then
begin
inc(r);
h[r]:=map[tt,1];
v[map[tt,1]]:=true;
end;
end;
tt:=map[tt,3];
end;
v[q]:=false;
end;
end;

procedure search;
var ii:longint;
begin
for ii:=1 to n do
if f[ii]>ans then
ans:=f[ii];
end;

begin
read(n);
for i:=1 to n do
begin
read(zhong);
read(len);
read(qi);
if qi=0 then
begin
inc(num);
bb[num]:=zhong;
f[zhong]:=len;
end
else
while qi<>0 do
begin
insert(qi,zhong,len);
read(qi);
end;
end;

//for i:=1 to n do
//if f[i]=0 then f[i]:=100000000;
for i:=1 to num do
spfa(bb[i]);
//search;
writeln(ans);
end.

```


---

## 作者：Skywalker_David (赞：1)

最大时间复杂度为Θ(n\*100)，绝对瞬间出解。动态规划，某项工作完成的最早时间为它所需要的工作完成时间最长的一个加上它自己所用的时间

```delphi

var
    a:array[1..10000] of longint;
    i,j,k,l,m,n:longint;
begin
    readln(n);
    fillchar(a,sizeof(a),0);
    m:=0;
    for i:=1 to n do begin
        read(k,l,j);
        k:=0;
        while j<>0 do begin
            if a[j]>k then
                k:=a[j];
            read(j);
        end;
        a[i]:=k+l;
        if a[i]>m then m:=a[i];
    end;
    write(m);
end.

```

---

## 作者：路边的水沟 (赞：1)

这道题不难，主要是建立相应的模型（图）以得出解题方法。

```delphi

var     
  n:longint;
  f:array[0..10000] of longint;
  i,s,h,t,max:longint;
  ans:longint;
begin
  readln(n); 
  for i:=1 to n do
    begin
    read(s); //读入。s为当前处理项编号，t为当前处理项耗时。
    read(t);
    read(h);
    max:=0;
    while h>0 do
      begin
      if f[h]>max then max:=f[h]; //从当前处理项必须完成的任务中寻找耗时最大的一项。此时默认已经把可以同时进行的项目同时进行，所得总和结果为最小。
      read(h);
      end;
    readln;
    f[s]:=max+t; //加上当前处理项的耗时
    if f[s]>ans then ans:=f[s];
    end;
  writeln(ans);
end.

```

---

## 作者：cat_yyy (赞：1)

0ms
迫真链表

趴。看注释

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define MAXN 10001
#define MAXM 1000001

inline void read(int &x){
    //读入优化 
    x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
}

struct nico{
    int to;
    int next;
} edge[MAXM];

int head[MAXN],cnt_edge=1,n,f[MAXN];

int lol,pre,ans;

void add_edge(int x,int y){
    //加边 
    edge[cnt_edge].next=head[x];
    head[x]=cnt_edge;
    edge[cnt_edge].to=y;
    cnt_edge++;
}

int find(int x){
    //找到所有准备中用时最长的一个 
    if(edge[x].next) return max(f[edge[x].to],find(edge[x].next));
    return f[edge[x].to];
}

int main(){
    read(n);
    for(int i=1;i<=n;i++){
        read(lol);//骗输入lolololol 
        read(f[i]);//输入当前节点所用时间 
        read(pre);
        while(pre){
            //循环输入准备节点 
            add_edge(i,pre);//以链表形式存储所有准备 
            read(pre);
        }
    }
    for(int i=1;i<=n;i++){
        if(head[i]){
            f[i]+=find(head[i]);//当前节点需要时间加上准备需要时间 
        }
        ans=max(ans,f[i]);//找最大值即为答案 
    }
    printf("%d\n",ans);//输出 
    return 0;
}
```

---

## 作者：a2956331800 (赞：0)

神奇的解法。。

读入时记录下每件事有几个先决条件、是否没有先决条件、是哪几件事的先决条件（用图记录，vector）；读入完之后把所有没有先决条件的事放入一个堆，以完成时间为比较大小的标准，完成早的在前面；之后每次从堆顶取出一个元素，把需要它作为先决条件的事的先决条件个数都-1，如果为零就入队，完成时间为当前时间＋该事消耗的时间，直到堆为空为止，最后一件事的时间就是答案。

代码：

```cpp
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int n,i,j,len[100001],need[100001],hand[100001],now;//need：先决条件个数；hand：是否没有先决条件 
struct work
{
    int num,tm;//num为编号，tm为消耗的时间 
    bool operator <(const work&a)const
    {
        return tm>a.tm;//priority_queue默认为大根堆，而此题需要小根堆，所以小于定义为大于 
    }
};
priority_queue<work> q;
vector<int> t[100001];
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>now>>len[i]>>j;
        while(j!=0)
        {
            hand[i]=1;
            need[i]++;
            t[j].push_back(i);
            cin>>j;
        }
    }
    for(i=1;i<=n;i++)
    {
        if(!hand[i])
          q.push((work){i,len[i]});
    }
    work k;
    while(!q.empty())
    {
        k=q.top();q.pop();now=k.tm;//now为当前时间，k为当前完成的事 
        for(i=0;i<t[k.num].size();i++)
        {
            need[t[k.num][i]]--;
            if(need[t[k.num][i]]==0)
              q.push((work){t[k.num][i],now+len[t[k.num][i]]});
        }
    }
    cout<<now;
    return 0;
}
```

---

## 作者：pupuvovovovovo (赞：0)

据说有人用C写了拓扑排序。

本人决定放一个pascal版的。

```cpp
var ut,alt,temp,first,last,r:array [1..10000] of longint;
next,en:array [1..1000000] of longint;
top,tot,i,j,n,x,ma:longint;
procedure add(x,y:longint);
begin
  inc(tot);
  if first[x]=0 then first[x]:=tot
  else next[last[x]]:=tot;
  last[x]:=tot;
  en[tot]:=y;
end;//一万个点，邻接矩阵不会爆内存吗？
function max(a,b:longint):longint;
begin
  if a>b then exit(a);
  exit(b);
end;
procedure push(x:longint);
begin
  inc(top);
  temp[top]:=x;
end;
function pop:longint;
begin
  pop:=temp[top];
  dec(top);
end;
begin
  read(n);
  for i:=1 to n do
  begin
    read(x);
    read(ut[i],x);
    if x=0 then push(i);
    while x>0 do
    begin
      add(x,i);
      inc(r[i]);
      read(x);
    end;
  end;
  while top>0 do
  begin
    x:=pop;
    alt[x]:=alt[x]+ut[x];
    i:=first[x];
    while i>0 do
    begin
      alt[en[i]]:=max(alt[en[i]],alt[x]);//遇到它一次就更新一次
      dec(r[en[i]]);
      if r[en[i]]=0 then push(en[i]);
      i:=next[i];
    end;
  end;
  for i:=1 to n do
  if alt[i]>ma then ma:=alt[i];//找最大值
  write(ma);
end.
```

---

## 作者：_无v名_ (赞：0)

本以为我已经沦落到普及的题目都不会做了，到复赛只能水水分了，没想到，这题给我带来了信心！

这题是我专门找图论的题做的时候找到的，当然，不得不承认的是，我是按照难度由简到繁……这题貌似是很简单的那种……

我一看到这题题目，首先给我带来的是和正常图论题类似的感觉，估计好歹要百行代码左右，但是，原谅我是个蒟蒻，没有那么厉害可以码百行代码的实力。

那么，先贴上我的水题代码，然后在讲解——

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,x,y,i,j,k;
int f[10001][10001];
int d[10001],dd[10001];
unsigned long long ans=0;
void dfs(int x)
{
    if(ans<d[x])ans=d[x];
    for(int i=1;i<=f[x][0];i++)
    {
        if(d[f[x][i]]<d[x]+dd[f[x][i]]&f[x][i]!=x)
        {
            d[f[x][i]]=d[x]+dd[f[x][i]];
            dfs(f[x][i]);
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&dd[i]);
        scanf("%d",&x);
        while(x!=0) {f[x][++f[x][0]]=i;scanf("%d",&x);}
    }
    d[1]=dd[1];dfs(1);
    cout<<ans<<endl;
    return 0;
}
```
代码贴出来之后，我必须指明那么几点……
1.能水过这题估计是数据太水了，如果是一直伸下去的一棵树的话……咳咳，我很有自知之明的知道我这肯定会爆的。

2.个人编程水平很一般，数组名啥的都很随意的，不要在意dd这些数组名。

然后讲解：

原理就是，依题意得，1可以看做该子树的根节点，然后dfs走起，算出每个叶子结点（准确点说沿途的都算了个遍），然后一路都更新答案，最后输出。

水吧？我也这么觉得，虽然水但是最后看到AC了还是好开心诶~


---


# [CSP-J2022 山东] 部署

## 题目背景

受疫情影响，山东省取消了 CSP-J 2022 认证活动，并于次年三月重新命题，在省内补办比赛。

## 题目描述

“万里羽书来未绝，五关烽火昼仍传。” 

古时候没有现代信息化战争的技术，只能靠烽火传信和将军运筹帷幄的调兵遣将来取得战争的优势。

为了使消耗最低，现在 A 国已经在 $n$ 个城市之间建好了道路和行军部署渠道，使得这 $n$ 个城市都能互相到达且不存在环（即构成以 $1$ 号城市为根节点的树型结构）。每个城市都驻扎了一定数量的兵力。

为了清晰的描述问题，我们给这 $n$ 个城市进行 $1$ 到 $n$ 的编号，且 $1$ 号城市为树的根节点（数据保证：构成以 $1$ 号城市为根节点的一棵树）。初始时，第 $i$ 座城市拥有初始兵力 $a_{i}$。

现在为测试战争部署速度，将军进行了 $m$ 次测试，每次测试可能为以下两种命令的某一种：

`1 x y`（三个数间均用 1 个空格分开）：向 $x$ 号城市**和**以它为根的子树中的所有城市全部增兵 $y$ 的数量。

`2 x y`（三个数间均用 1 个空格分开）：向 $x$ 号城市**和**与它直接相连（含父结点和子结点）的城市全部增兵 $y$ 的数量。

$m$ 条命令发布出去后，将军喊来参谋，进行了 $q$ 次询问，每次询问第 $x$ 座城市的最终兵力情况。
该参谋就是小虾米，他又向你求助了，请你帮助他解决问题（$q$ 次询问的结果）。

## 说明/提示

### 数据范围
对于 $30\%$ 的数据，$1\le n\le1000,1\le m\le1000$；

对于 $60\%$ 的数据，$1\le n\le10^{5},1\le m\le10^{5},1\le q\le10^{5}$；

其中 $10\%$ 的数据树是一条链，另外 $10\%$ 的数据只有 $1$ 操作，另外 $10\%$ 的数据只有 $2$ 操作。

对于 $100\%$ 的数据，数据保证给定的城市和道路能形成树，且 $1$ 号城市为根节点。$1\le n\le10^{6},1\le m\le10^{6},1\le q\le10^{6},1\le a_{i}\le10^{9},1\le x\le n,1\le y\le10$。

2025-06-26 增加 Hack 一组

## 样例 #1

### 输入

```
5
1 2 3 4 5
1 2
1 3
2 4
3 5
4
1 1 2
2 2 3
1 3 3
2 5 1
4
1
2
3
4```

### 输出

```
6
7
9
9```

## 样例 #2

### 输入

```
4
1 1 1 1
1 2
1 3
1 4
1
1 1 1
2
1
2```

### 输出

```
2
2```

# 题解

## 作者：JuRuoOIer (赞：11)

# 题解 P11855 [CSP-J2022 山东] 部署

前排提醒，本题解做法涉及以下知识点：
- 【4】深度优先遍历（入门）
- 【8】离线处理思想（NOI）（别怕，没那么难）

致管理：把时间算错了……只把“花絮”部分的“三年”改为“两年”，其他地方均未改动。

### 题意

给定一棵以 $1$ 号点为根的树，初始时每个点有点权 $a_i$，维护 $m$ 次操作，操作包括两种：
- `1 x y`：将以 $x$ 为根的子树的所有点点权加 $y$。
- `2 x y`：将 $x$ 及与之有边直接相连的所有点点权加 $y$。

操作完后进行 $q$ 次询问，每次指定一个点，询问其点权。

数据范围 $1\le n,m,q\le 10^6,1\le a_i\le 10^9,1\le y\le 10$。

### 思路

给的两种操作看上去不好下手，但是此题有一个令人注意的点：一般的题都是操作同时包括修改和查询，但本题中是修改完了再查询，这个时候就需要**离线处理思想**发挥作用了。所谓离线处理思想，就是在操作的时候不直接操作上去，而是把操作先记录下来，等到合适的时机（通常是用到的时候）再操作以优化复杂度。

读完这段话之后，如果你之前没有想到，建议先从这个入手继续思考一下，问题应该会简单很多。

---

这道题直接按照上面的说法做就可以了。开两个数组分别记录每个点 $1$ 操作 $y$ 值的和以及 $2$ 操作 $y$ 值的和。所有操作结束之后遍历整棵树，遍历到一个点时：
- 对于其记录的 $1$ 操作，修改当前点的点权并将 $y$ 值转移到它的所有儿子节点。
- 对于其记录的 $2$ 操作，修改相关点的点权。

这样由于每条边最多会被遍历 $3$ 次（该边的两个端点中，深度较小的点的两种操作均会遍历该边，深度较大的点的 $2$ 操作遍历该边），故时间复杂度为 $\text{O}(n)$，然后直接回答询问即可。

### 代码

直接放上~~落满了灰的~~赛时代码，由于挺好写的，故没有注释。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,q,u,v,op,x,y,a[1000010],tag1[1000010],tag2[1000010],fa[1000010];
vector<ll> g[1000010];
void change(ll now){
	for(int i=0;i<g[now].size();i++){
		if(g[now][i]!=fa[now]){
			fa[g[now][i]]=now;
			change(g[now][i]);
		}
	}
}
void pushdown(ll now){
	a[now]+=tag1[now];
	a[now]+=tag2[now];
	for(int i=0;i<g[now].size();i++){
		a[g[now][i]]+=tag2[now];
		if(g[now][i]!=fa[now]){
			tag1[g[now][i]]+=tag1[now];
			pushdown(g[now][i]);
		}
	} 
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	for(int i=0;i<n-1;i++){
		cin>>u>>v;
		u--;v--;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	fa[0]=0;
	change(0);
	cin>>m;
	while(m--){
		cin>>op>>x>>y;
		if(op==1)tag1[x-1]+=y;
		else tag2[x-1]+=y;
	}
	pushdown(0);
	cin>>q;
	while(q--){
		cin>>x;
		cout<<a[x-1]<<endl;
	} 
	return 0;
}
```

### 花絮

洛谷终于搬题了！

喜报：[成功于近两年前准确预测了洛谷评定的题目难度。](https://www.luogu.com.cn/training/653186)

本人场上获得了 $290$ 分的好成绩，挂了 $30$ 分，原因至今不明，合理怀疑是机子太慢了，因为我的 T3 在洛谷上怎么测都是 $100$ 但官方测的是 $70$……

直观感受本套题目：
- T1 差分板子秒了，唯一的坑点是下标。
- T2 原题 CF1730B，场上**瞎搞** 1h 多点**过了**（其实好卡）。
- T3（本题）还不错，就是这玩意好像涉及`【8】离线处理思想`吧……
- T4 原题 ARC058C，**状压 DP 放普及**几个意思？？！
- X 组更加劲爆，直接**两道 P 字头原题**（T1 原题 [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)，T3 原题 [P1638 逛画展](https://www.luogu.com.cn/problem/P1638) 不过通胀了）。

---

## 作者：Zskioaert1106 (赞：6)

题目传送门：[P11855 [CSP-J2022 山东] 部署](https://www.luogu.com.cn/problem/P11855)

[菊花图 hack 数据](https://www.luogu.com.cn/problem/U541097)，hack 了一些题解。欢迎指正。

***

我太蒻了，看题第一眼只能想到线段树 qwq……

### 做题过程

由于最近刚做过树链剖分，所以看到向以 $x$ 和以 $x$ 为根的子树所有城市增加 $y$ 就立刻想到树剖加线段树处理。

然后看操作 2，这咋玩……dfs 序不连贯了，重剖好像也不行，但是这毕竟是 CSP-J（~~谁家好人 J 组出紫题啊喂~~），所以我很快想到另一个简单的东西——bfs 序。

对于第二种操作，我们不难发现：bfs 序中一个结点的所有孩子是连续的！注意父结点、本身和子结点这三者并不一定连续。

于是我们就可以建立两个线段树了。

（还不会树转序列建线段树的可以先看[树剖模板题](https://www.luogu.com.cn/problem/P3384)）

我们直接开两个树，分别按 dfs 和 bfs 维护权值。建树时只将一个 $a_i$ 赋值，之后如果是操作 1 就在 dfs 树上增加，如果是操作 2 就在 bfs 树上增加（要增加的包括自己、父结点、子结点们三个），之后每次查询返回两棵树点 $x$ 的和。

### 代码编写

我们用一遍 dfs 处理好大部分信息，并将连向父结点的边删除（本题用不到）：

```cpp
void dfs(int x){
	siz[x]=1;
	tl[0][++tl[0][0]]=x;
	lt[0][x]=tl[0][0];
	if(fa[x])e[x].erase(find(e[x].begin(),e[x].end(),fa[x]));
	for(int u:e[x]){
		fa[u]=x;
		dfs(u);
		siz[x]+=siz[u];
	}
}
```

接下来是 bfs：

```cpp
int que[N],ql,qr;
void bfs(){
	que[qr++]=1;
	while(ql<qr){
		int x=que[ql];
		tl[1][++tl[1][0]]=x;
		lt[1][x]=tl[1][0];
		for(int u:e[x])que[qr++]=u;
		ql++;
	}
}
```

基础的线段树就不说了，处理指令的时候是这样的：

```cpp
while(m--){
  short p;
  int x,y;
  cin>>p>>x>>y;
  if(p==1){
    update(0,1,lt[0][x],lt[0][x]+siz[x]-1,y);
  }
  else{
    if(siz[x]>1)update(1,1,lt[1][e[x][0]],lt[1][e[x][0]]+e[x].size()-1,y);
    update(1,1,lt[1][x],lt[1][x],y);
    if(x!=1)update(1,1,lt[1][fa[x]],lt[1][fa[x]],y);
  }
}
```

操作 1 没什么好说的，操作 2 中第一个是对于孩子的增加，第二个是自己，第三个是父节点。

然后是查询：

```cpp
while(q--){
  int x;
  cin>>x;
  cout<<query(0,1,lt[0][x])+query(1,1,lt[1][x])<<'\n';
}
```

[丑陋的 80 分被卡常代码正好 100 行](https://www.luogu.com.cn/record/206325947)……

### 树状数组

我们浅浅计算一下复杂度：$O(n+(m+q)\log n)$ 状物？有点悬，再加上线段树的常数~~和我不会 zkw~~ 实际上得分在 $60\sim 80$ 分。

然后注意，诶单点查询？~~转树状数组！~~

[像板子一样](https://www.luogu.com.cn/problem/P3368)建立差分数组，我们同线段树一样区间修改、单点查询即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000006;
int n,m,q,a[N],fa[N],siz[N],tl[2][N],lt[2][N],c[2][N];
vector<int>e[N];
void dfs(int x){
    siz[x]=1;
    tl[0][++tl[0][0]]=x;
    lt[0][x]=tl[0][0];
    if(fa[x])e[x].erase(find(e[x].begin(),e[x].end(),fa[x]));
    for(int u:e[x]){
        fa[u]=x;
        dfs(u);
        siz[x]+=siz[u];
    }
}
int que[N],ql,qr;
void bfs(){
    que[qr++]=1;
    while(ql<qr){
        int x=que[ql];
        tl[1][++tl[1][0]]=x;
        lt[1][x]=tl[1][0];
        for(int u:e[x])que[qr++]=u;
        ql++;
    }
}
void upd(short opt,int u,int x){
    for(int i=u;i<=n;i+=i&-i)c[opt][i]+=x;
}
int query(short opt,int u){
    int ans=0;
    for(int i=u;i;i-=i&-i)ans+=c[opt][i];
    return ans;
}
void update(short opt,int l,int r,int x){
    upd(opt,l,x);
    if(r+1<=n)upd(opt,r+1,-x);
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1,x,y;i<n;i++){
        cin>>x>>y;
        e[x].push_back(y),e[y].push_back(x);
    }
    dfs(1);
    bfs();
    cin>>m;
    while(m--){
        short p;
        int x,y;
        cin>>p>>x>>y;
        if(p==1){
            update(0,lt[0][x],lt[0][x]+siz[x]-1,y);
        }
        else{
            if(siz[x]>1)update(1,lt[1][e[x][0]],lt[1][e[x][0]]+e[x].size()-1,y);
            update(1,lt[1][x],lt[1][x],y);
            if(x!=1)update(1,lt[1][fa[x]],lt[1][fa[x]],y);
        }
    }
    cin>>q;
    while(q--){
        int x;
        cin>>x;
        cout<<a[x]+query(0,lt[0][x])+query(1,lt[1][x])<<'\n';
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/206334151)。树状数组的常数真的很小。

这种方法的优势就是可以在线处理询问，而且如果询问的是树上某些城市的兵力和那么线段树就不失为一种好正解了。

---

## 作者：__xxy_free_ioi__ (赞：5)

# P11855 [CSP-J2022 山东] 部署
直接暴力肯定是不行的，所以，我们要想一下预处理的方法。问题出现在那 $m$ 次指令上，但是我们思考发现，那些指令所加的值是可以先存下来，再跑一遍 DFS 即可。

我们可以用 $son[u]$ 来存储操作一对节点 $u$ 产生的影响，$connect[u]$ 来存储操作二对节点 $u$ 产生的影响。在跑 DFS 时只要注意 $son[u]$ 的继承关系即可。

## AC代码

```
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

int n, m, q;
int a[N], son[N], connect[N];
vector<int> g[N];

void dfs(int u, int fa) {
    a[u] += son[u] + connect[u];
    a[fa] += connect[u];
    for (int v : g[u]) {
        if (v == fa) continue;
        a[v] += connect[u];
        son[v] += son[u]; // 继承
        dfs(v, u);
    }
}

int main() {
    cin >> n;
    
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    cin >> m;
    while (m--) {
        int p, x, y;
        cin >> p >> x >> y;
        if (p == 1) {
            son[x] += y;
        } else connect[x] += y;
    }

    dfs(1, 0);

    cin >> q;
    while (q--) {
        int x;
        cin >> x;
        cout << a[x] << '\n';
    }
    
    return 0;
}
```

---

## 作者：Priestess_SLG (赞：3)

正解好像是树上维护懒标记然后下传，~~但是众所周知我不会维护懒标记~~，所以考虑一个相对偏 ds 的做法。

发现题目的查询操作全在修改操作之后，因此考虑离线做法。先记录每一个点 $i$ 的 $1,2$ 两种操作的权值，设其为 $v1_i,v2_i$。可以发现两个操作之间互相独立，因此考虑分离处理之。

对于 $1$ 操作：一个点 $x$ 会对 $x$ 子树内的结点产生影响，其子树内的结点 DFS 序连续，因此可以维护其 DFS 序的差分序列，然后一次前缀和求值。

对于 $2$ 操作：一个点 $x$ 会对 $x$ 本身，$x$ 的父亲和 $x$ 的一级儿子结点产生影响，其中 $x$ 和 $x$ 的父亲可以单独暴力处理到差分序列上，剩余的 $x$ 的一级连续儿子结点在 BFS 序上连续，可以对 BFS 序维护差分序列，然后一次前缀和求值。

最后把每一个点 $i$ 的答案加上 $a_i$，然后直接查表查询答案即可。时间复杂度为 $O(n)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1000010;
const int mod = 998244353;
vector<int> adj[N];
int v1[N], v2[N], a[N];
int res[N];
int dfn1[N], dfn2[N], siz[N], son[N], leaf[N], up[N];
int idx1, idx2;
int bk[N], bk2[N];
void prep_dfs(int u, int fa) {
    dfn1[u] = ++idx1, siz[u] = 1;
    bk[idx1] = u, up[u] = fa;
    for (int &v : adj[u])
        if (v != fa) prep_dfs(v, u), siz[u] += siz[v];
}
void prep_dfs() {
    prep_dfs(1, 0);
}
int vis[N];
int L[N], R[N], deg[N];
void prep_bfs() {
    queue<int> q;
    q.emplace(1);
    vis[1] = 1;
    dfn2[1] = idx2 = 1;
    bk2[1] = 1;
    while (q.size()) {
        int t = q.front();
        q.pop();
        for (int &g : adj[t])
            if (!vis[g]) {
                vis[g] = 1;
                dfn2[g] = ++idx2;
                bk2[idx2] = g;
                if (!L[t]) L[t] = R[t] = idx2;
                else R[t] = idx2;
                q.emplace(g);
            }
    }
}
int diff[N], diff2[N];
signed main() {
    cin.tie(0)->sync_with_stdio(false);
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i < n; ++i) {
        int x, y;
        cin >> x >> y;
        adj[x].emplace_back(y);
        adj[y].emplace_back(x);
        ++deg[x], ++deg[y];
    }
    for (int i = 1; i <= n; ++i)
        if (deg[i] == 1) {
            if (i > 1) leaf[i] = 1;
            else if (i == 1 && n == 1) leaf[i] = 1;
        }
    if (n == 1) leaf[1] = 1;
    int m;
    cin >> m;
    for (int i = 0; i < m; ++i) {
        int p, x, y;
        cin >> p >> x >> y;
        if (p == 1) v1[x] += y;
        else v2[x] += y;
    }
    prep_dfs(), prep_bfs();
    for (int i = 1; i <= n; ++i) {
        diff[dfn1[i]] += v1[i], diff[dfn1[i] + siz[i]] -= v1[i];
        diff2[dfn2[i]] += v2[i], diff2[dfn2[i] + 1] -= v2[i];
        if (i != 1) diff2[dfn2[up[i]]] += v2[i], diff2[dfn2[up[i]] + 1] -= v2[i];
        if (!leaf[i]) diff2[L[i]] += v2[i], diff2[R[i] + 1] -= v2[i];
    }
    for (int i = 1; i <= n; ++i) diff[i] += diff[i - 1], diff2[i] += diff2[i - 1];
    for (int i = 1; i <= n; ++i) res[i] = diff[dfn1[i]] + diff2[dfn2[i]];
    int q;
    cin >> q;
    while (q--) {
        int x;
        cin >> x;
        cout << res[x] + a[x] << '\n';
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11855)

~~码了挺多的，应该不是正解。~~

首先建树，确定每个节点的父节点和子节点，然后用一个 dfs 记录每个节点的入栈时间和出栈时间用于后续操作，接着根据输入的命令对相应的节点进行兵力增加操作。对于类型 $1$，使用差分数组记录子树的兵力增加；对于类型 $2$，直接记录节点及其父节点的兵力增加。然后根据差分数组计算每个节点的实际兵力增加，再结合初始兵力和命令操作来计算每个节点的最终兵力，最后输出即可。

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <queue>
#define int long long
#define F first
#define S second
using namespace std;

const int N = 1e6 + 5;

int n, m, q, a[N];
vector<int> G[N], c[N];
int pa[N], in[N], ou[N], d[N], sum[N], psum[N], s[N];
// pa 父节点
// in,ou 入栈出栈时间
// d 差分
// sum 节点自身兵力增加
// psum 节点父节点兵力增加
// s 差分前缀和

void bfs() { // 确定每个节点的父子节点
  queue<int> q;
  q.push(1);
  pa[1] = 0;
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    for (auto v : G[u])
      if (v != pa[u]) {
        pa[v] = u;
        c[u].push_back(v);
        q.push(v);
      }
  }
}

void dfs() { // 记录每个节点的入栈出栈时间
  stack<pair<int, bool>> st;
  st.push({1, false});
  int tim = 0;
  while (!st.empty()) {
    int u = st.top().F, v = st.top().S;
    st.pop();
    if (!v) {
      in[u] = ++tim; // 记录入栈时间
      st.push({u, true}); // 标记访问
      for (auto it = c[u].rbegin(); it != c[u].rend(); it++)
        st.push({*it, false}); // 子节点入栈
    } else ou[u] = tim; // 记录出栈时间
  }
}

signed main() {
  ios::sync_with_stdio(false);
  ios_base::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  
  cin >> n;
  for (int i = 1; i <= n; i++)
    cin >> a[i];
  for (int i = 1; i < n; i++) {
    int u, v;
    cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  } bfs(), dfs();
  cin >> m;
  while (m--) {
    int opt, x, y;
    cin >> opt >> x >> y;
    if (opt == 1) { // 差分
      d[in[x]] += y;
      d[ou[x] + 1] -= y;
    } else { // 记录兵力增加
      sum[x] += y;
      if (pa[x] != 0) psum[pa[x]] += y;
    }
  } for (int i = 1; i <= n; i++)
      s[i] = s[i - 1] + d[i];
  cin >> q;
  while (q--) {
    int x;
    cin >> x;
    int ans = a[x] + s[in[x]] + sum[x] + psum[x]; // 最终兵力
    if (pa[x] != 0) ans += sum[pa[x]];
    cout << ans << "\n";
  } return 0;
}
```

---

## 作者：langmouren (赞：3)

## 基本思路

拿到这道题，发现修改的操作是没有后效性的（即上一次修改不会对下一次修改产生影响），有可加性，而且如果每一次修改都直接进行对于 $1 \times 10^6$ 的数据很明显会爆炸，那我们不妨对每个点的修改进行统计，然后通过一次 DFS 离线统一处理。

## 具体分析
首先，读入数据时建立无向图，约定 DFS 到的点为 $x$，增加的值为 $k$。

对于**两种操作**，都会把 $x$ 增加 $k$。

对于**操作一**，我们把 $x$ 连向的所有点增加 $k$。

对于**操作二**，我们把 $x$ 的所有儿子的操作二的记录值增加 $k$，这是一种类似线段树懒标记的思想，把记录值下放。

最后，我爱 vector！

## 代码实现（带注释）

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MN=1e6+10;
int ans[MN];
vector<int> v[MN];
int op1[MN],op2[MN];//存储操作1，操作2的统计
int n,m,q;

void dfs(int x,int fa){
	ans[x]+=op1[x]+op2[x];
	
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i];
		
		ans[y]+=op2[x];
		
		if(y==fa) continue;//跳过父亲
		
		op1[y]+=op1[x];//向子节点下放记录
		
		dfs(y,x);
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>ans[i];
	}
	
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	
	cin>>m;
	
	for(int i=1;i<=m;i++){
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1) op1[x]+=y;
		else op2[x]+=y;
	}
	
	dfs(1,0);//处理所有内容 
	
	cin>>q;
	
	for(int i=1;i<=q;i++){
		int x;
		cin>>x;
		cout<<ans[x]<<"\n";
	}
	return 0;
} 	
```

---

## 作者：fish_love_cat (赞：2)

答案与操作顺序无关，考虑对于每个点两种操作的数量进行统计。

然后对于每一个点先把操作二给做了，再跑一个 dfs 把操作一的贡献由父节点传下去。

这样就可以做到 $O(n)$。时限很宽常数写的再劣也能过。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000005],b[1000005],c[1000005];
vector<int>ve[1000005];
void dfs(int x,int fa){
    b[x]+=b[fa];
    a[x]+=b[x]+c[x];
    for(int i=0;i<ve[x].size();i++){
        a[ve[x][i]]+=c[x];
        if(ve[x][i]==fa)continue;
        dfs(ve[x][i],x);
    }
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(),cout.tie();
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        ve[u].push_back(v);
        ve[v].push_back(u);
    }
    int q;
    cin>>q;
    while(q--){
        int op;
        cin>>op;
        if(op==1){
            int x,y;
            cin>>x>>y;
            b[x]+=y;
        }else{
            int x,y;
            cin>>x>>y;
            c[x]+=y;
        }
    }
    dfs(1,0);
    cin>>q;
    while(q--){
        int x;
        cin>>x;
        cout<<a[x]<<endl;
    }
    return 0;
}
```

---

## 作者：canwen (赞：1)

**以下称命令一为操作一，命令二为操作二。**

全部修改完再查询，考虑 $f_{i}$ 存节点 $i$ 所有操作一加的值总和，$f1_{i}$ 存节点 $i$ 所有操作二加的总值和，每次修改更新对应的即可。

全部修改完后，从根节点 $1$ 开始遍历整棵树，设当前遍历节点 $u$，它的父亲是 $fa$，显然 $a_{u}$ 需要先加上 $f_{u}+f1_{u}+f1_{fa}$，接着遍历它的所有孩子 $v$，如果 $f1_{v} \ne 0$，还需要让 $a_{u}$ 加上 $f1_{v}$（**操作二中只要相连的节点都需要更新，包括父亲**），然后下传操作一的值给到节点 $v$，即 $f_{v} \gets f_{v}+f_{u}$，接着继续遍历即可。

这样，最后的询问可以做到每次都是 $O(1)$。

总复杂度 $O(n+m+q)$。

---

## 作者：JoyLosingK (赞：1)

首先，每次操作打上对应的标记。接下来我们思考怎样处理这些标记。

由于图的结构是一棵树，所以我们考虑用一次 dfs 来解决问题。

每遍历到一个点，先把它加上自己的两种标记，再加上从根到这个节点的 $1$ 操作标记。

接下来枚举子节点，并令这个节点加上子节点的 $2$ 标记。

对于每个节点，再加上它父节点的 $2$ 标记即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define endl '\n' 
const int N=1e6+5;
int n,a[N],t1[N],t2[N],op,x,y,m,q;
vector<int> d[N];
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;}
inline void dfs(int u,int fa,int s){
	a[u]+=t2[u],a[u]+=s,a[u]+=t1[u];
	for(int v:d[u]){
		if(v==fa) continue;
		a[u]+=t2[v]; a[v]+=t2[u];
		dfs(v,u,s+t1[u]);
	}
}
int main(){ n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++) x=read(),y=read(),
		d[x].push_back(y),d[y].push_back(x);
	for(m=read();m--;){ op=read(),x=read(),y=read();
		if(op==1) t1[x]+=y; else t2[x]+=y;
	} dfs(1,0,0);
	for(q=read();q--;)
		x=read(),cout<<a[x]<<endl;
	return 0;
}
```


希望能对大家有所帮助。

---

## 作者：LostKeyToReach (赞：1)

我们发现，对于操作 $1$，等价于根据 dfn 序进行差分，操作二相当于对每一对 $(x, v)$ 互相加 $y$，那么直接 dfs 求个 dfn 序就做完了，时间复杂度 $O(n)$。

代码如下：

```cpp
int main() {
#if MULTI_TEST == 1
    LL T;
    std::cin >> T;
    while (T--) {
        // Test cases...
    }
#else
    int n;
    cin >> n;
    std::vector<VI> adj(n + 1);
    VLL a(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    std::vector<PII> e;
    for (int i = 1, x, y; i < n; ++i) 
        cin >> x >> y, e.eb(x, y), adj[x].eb(y), adj[y].eb(x);
    int cnt = 0;
    VI l(n + 1, 0), r(n + 1, 0), rev(n + 1, 0);
    auto Dfs = [&](auto&& self, int x, int p) -> void {
        rev[l[x] = ++cnt] = x;
        for (auto& y : adj[x]) {
            if (y == p) continue;
            self(self, y, x);
        }
        r[x] = cnt;
        };
    Dfs(Dfs, 1, 0);
    VLL d(cnt + 2, 0), t(n + 1, 0);
    int m;
    cin >> m;
    while (m--) {
        int tp, x, y;
        cin >> tp >> x >> y;
        if (tp == 1) {
            d[l[x]] += y;
            d[r[x] + 1] -= y;
        }
        else {
            t[x] += y;
        }
    }
    VLL t1(n + 1, 0), t2(n + 1, 0);
    for (int i = 1; i <= cnt; ++i) {
        t1[rev[i]] = (d[i] += d[i - 1]);
        t2[i] = t[i];
    }
    for (auto& [u, v] : e) t2[u] += t[v], t2[v] += t[u];
    int q, x;
    cin >> q;
    while (q--) {
        cin >> x;
        cout << a[x] + t1[x] + t2[x] << "\n";
    }
#endif
    return 0;
}
```

---

## 作者：Lele_Programmer (赞：1)

# P11855 题解

## 思路

~~第一眼 DS 题，第二眼乱搞题。~~

由于所有询问都在修改之后，那么在询问的时候所有点的结果已经确定了。

将操作一的值计入数组 $a$，操作二的值计入数组 $b$，修改完深搜一遍，记最终节点值为 $f$，则对于点 $u$，将 $a_u,b_u$ 加给它的子节点的 $f$，把 $b_u$ 加给它的父节点的 $f$，因为 $a_u$ 是修改整个子树，所以 $a_u$ 的值下传到子节点，别忘了把 $a_u,b_u$ 的值加给 $f_u$ 自己本身。

## 代码

```cpp
const int N=1000005;
const int M=2000005;

int n,m;
int a[N],b[N];
int e[M],ne[M],h[N],tot;
int f[N];

void add(int a,int b) {
    e[tot]=b,ne[tot]=h[a],h[a]=tot++;
}

void dfs(int u,int fa) {
    f[fa]+=b[u];
    _graph(i,u) {
        if (e[i]==fa) continue;
        a[e[i]]+=a[u];
        f[e[i]]+=a[u]+b[u];
        dfs(e[i],u);
    }
}

i32 main() {
    memset(h,-1,sizeof(h));
    read(n);
    _rep(i,1,n) read(f[i]);
    _rep(i,1,n-1) {
        int a,b;
        read(a),read(b);
        add(a,b),add(b,a);
    }
    read(m);
    while (m--) {
        int p,x,y;
        read(p),read(x),read(y);
        if (p==1) a[x]+=y,f[x]+=y;
        else b[x]+=y,f[x]+=y;
    }
    dfs(1,0);
    read(m);
    while (m--) {
        int x;
        read(x);
        writeln(f[x]);
    }
    return 0;
}
```

---

## 作者：_d_h_f (赞：1)

Update：2025.7.20，修改了代码，通过了 hack 数据。

## Solution

这道题其实就是个简单的图遍历，记录每个节点 $1$ 和 $2$ 操作后添加的数量，最后跑一遍图，给所有的节点累加，用一个计数器 $tot$ 计算前面给这个节点的数量，$a_i=a_i+tot+b_{1,i}+b_{2,i}$，即可求和。

注意了，对于操作 $2$，我们直接遍历这个节点的直接叶子节点，加上 $b_{2,i}$ 就可以了。

## Code


```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

typedef pair<int, int> PII;

const int N = 1e6 + 5;

int n, m, q;

PII p[N];

int a[N], b[3][N], fa[N], vis[N];

vector<int> e[N];

void dfs(int x, int tot) {
	
	a[fa[x]] += b[2][x];
	
	a[x] += tot + b[1][x] + b[2][x];
	
	for (auto y : e[x]) 
		if (y != fa[x])
			dfs(y, tot + b[1][x]);
		
	for (auto y : e[x])
		if (y != fa[x])
			a[y] += b[2][x];
	
}

void init(int x) {
	
	vis[x] = 1;
	
	for (auto y : e[x]) {
		
		if (vis[y])
			continue;
			
		fa[y] = x, init(y);
		
	}
	
}

signed main() {
	
	scanf("%lld", &n);
	
	for (int i = 1; i <= n; ++i)
		scanf("%lld", &a[i]);
		
	for (int i = 1; i < n; ++i) {
		
		int x, y;
		
		scanf("%lld %lld", &x, &y);
		
		e[x].push_back(y), e[y].push_back(x);
		
	}
		
	init(1);
	
	scanf("%lld", &m);
	
	while (m--) {
		
		int op, x, y;
		
		scanf("%lld %lld %lld", &op, &x, &y);
		
		b[op][x] += y;
		
	}
	
	dfs(1, 0);
	
	scanf("%lld", &q);
	
	while (q--) {
		
		int x;
		
		scanf("%lld", &x);
		
		printf("%lld\n", a[x]);
		
	}
	
	return 0;
	
}
```

---


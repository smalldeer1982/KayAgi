# 买礼物

## 题目描述

又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。

但是，商店老板说最近有促销活动，也就是：

如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。

现在明明想知道，他最少要花多少钱。

## 说明/提示

样例解释 $2$。

先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。

（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）

数据规模

对于 $30\%$ 的数据，$1\le B\le 10$。

对于 $100\%$ 的数据，$1\le B\le500,0\le A,K_{I,J}\le1000$。

2018.7.25新添数据一组

## 样例 #1

### 输入

```
1 1
0

```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
0 2 4
2 0 2
4 2 0
```

### 输出

```
7```

# 题解

## 作者：青丝、暮成雪 (赞：89)

这道题如果看出题目实质就变得很简单了，不过看不穿的话就会很难想了。

大致思路如下：

第i件物品对j有优惠的话就建边，然后从0向各点连边权为a的边，然后跑一边kruskal就OK了。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct node
{
        int u,v,w;
}e[250000];
int a,b,k,tot=1,ans,f[555];
bool cmp(node x,node y)
{
        return x.w<y.w;
}
int find(int x)
{
        if(f[x]==x) return x;
        return f[x]=find(f[x]);
}
int hb(int x,int y)
{
        int xx=find(x);
        int yy=find(y);
        if(xx!=yy) f[xx]=yy;
}
void build(int x,int y,int z)
{
        k++;
        e[k].u=x;
        e[k].v=y;
        e[k].w=z;
}
void kruskal()
{
        int j=1;
        while(j<=k&&tot<=b)
    {
            if(find(e[j].u)!=find(e[j].v))
            {
                    tot++;
                    ans+=e[j].w;
                    hb(e[j].u,e[j].v);
                    //printf("%d->%d\n",e[j].u,e[j].v);
            }
            j++;
        }
}
int main()
{
        scanf("%d%d",&a,&b);
        for(int i=1;i<=b;i++)
        {
                for(int j=1;j<=b;j++)
                {
                        int x;
                        scanf("%d",&x);
                        if(i<j&&x!=0) build(i,j,x);//千万记得没有优惠是0，不建边（我在这儿WA了三次......）
                }
        }
        for(int i=1;i<=b;i++) build(0,i,a);
        for(int i=0;i<=b;i++) f[i]=i;
        sort(e+1,e+k+1,cmp);
        kruskal();
        //for(int i=1;i<=k;i++)
        //printf("%d->%d:%d\n",e[i].u,e[i].v,e[i].w);
        printf("%d\n",ans);
        return 0;
}
```

---

## 作者：无铭无名 (赞：71)

第一次发题解，如果有不好的地方请见谅。

此题目是一道 ~~裸的~~ kruskal。

只需在输入输出时 ~~稍稍~~ 预处理一下即可。

```cpp
#include<bits/stdc++.h> //万能头文件 
using namespace std;
struct node {
	int x,y,s;
} d[200000];
int n,m,ans,num,f[1000],w,k,c;
bool ok[1000];
bool cmp(node a,node b) { //按优惠排序 
	return a.s<b.s;
}
int gf(int x) { // 找爸爸 
	if(f[x]==x)return x;
	return f[x]=gf(f[x]); //压缩路径 
}
void work() { //kruskal的核心代码 
	int x,y;
	for(int i=1; i<=n; i++)f[i]=i;
	for(int i=1; i<=k-num; i++) {
		x=gf(d[i].x);
		y=gf(d[i].y);
		if(x!=y) {
			f[x]=y;
			c++;
			ans+=d[i].s;
		}

	}
}
int main() {
	cin>>m>>n;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++) {
			cin>>w;
			if(i>=j||w==0)continue; //对于重复的和本身不建边，直接过 
			d[++k].x=i;
			d[k].y=j;
			d[k].s=w;
			if(d[k].s>m)num++; //统计优惠后的价格仍然大于原价的数目 
		}
	sort(d+1,d+k+1,cmp); //排序的时候要注意，虽然统计了价格变高的数目，但比较时还是要全部一起比 
	work();
	if(c==n-1)cout<<ans+m; //最后判断一下是否所有的点都连了起来，如果是就加上原价；如果否加上剩余点的数目*原价 
	else cout<<ans+(n-c)*m; 
	return 0;
}
```
作为一名OIer
~~(蒟蒻)~~，我选择相信各位同道的素质。

---

## 作者：Hiraeth (赞：25)

悼念一下我在清明节打了三个小时的题目

$flag$的锅

思路分析：

把所有的物品都看作节点

购买所有物品所花费的最小值

就应该是把所有点连接起来的最小代价

也就是该图的最小生成树

如果两个物品之间存在关系，那么可以有优惠，就把两个两个点连起来，增加一条边

对所有的节点，我们都可以直接购买，所有的节点都增加一条边指向一个公共的根节点，边权值为$a$.

然后求出最小生成树的值即可.

~~下面来解释一下为什么打了三个小时~~

$!flag$ 的意思是$flag==0$ 这里应该是判断$flag$不为零

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,flag,px,py,ans,f[10000];
struct p{
	int x,y,z;
}a[250008];
int find(int x){
	if (x==f[x]) return x;
	return f[x]=find(f[x]);
}
bool cmp(p a,p b){
	return a.z<b.z;
} 
int main(){
	scanf("%d%d",&n,&m);
	for (int i=0;i<=m;i++) f[i]=i;
	for (int i=1;i<=m;i++){
		cnt++;
		a[cnt].x=0;
		a[cnt].y=i;
		a[cnt].z=n;
	} 
	for (int i=1;i<=m;i++)
		for (int j=1;j<=m;j++)
	{	
		scanf("%d",&flag);
		if (flag){
			cnt++;
			a[cnt].x=i;
			a[cnt].y=j;
			a[cnt].z=flag;	
		} 
	}
	sort(a+1,a+cnt+1,cmp);
	for (int i=1;i<=cnt;i++){
		px=find(a[i].x);
		py=find(a[i].y);
		if (px==py) continue;
		f[px]=py;
		ans+=a[i].z;
	}
	printf("%d\n",ans);
	return 0;
}

```



---

## 作者：加勒比·史努比 (赞：16)

### Solve

用[Kruskal](https://five-shifts-forever.blog.luogu.org/kruskal)建立最小生成树（MST）。

1.将每件物品视作一个节点，物品之间的优惠或费用为边的权值。

2 . **设置一个序号为零的节点（精髓所在）** ， 此点直接连接的节点即为通过花费a元直接购买的物品。

3.每一样物品都可通过直接花费a元来购买，所以从节点零向每一个节点连接一条权值为a的边。

4.正常建边，正常Kruskal

### Tips

如果每个优惠都~~太实惠~~太小了，会导致没有物品通过直接购买的方式取得么？

不会的，Kruskal是不会放过一条边的，一定会将节点零加入的。

### Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;  //标准开头
const int N=1000;
int a,b;
struct note{
	int u,r,w;
}d[N*N];  //每条边的信息，u,r——端点，w——权值
int f[N];  //f[i]表示节点i的父节点
int num,cnt,ans;  //cnt——边数，ans——答案
int e,r;
bool cmp(const note &x,const note &y){  //排序
	return x.w<y.w;
}
int find(int s){
	if(s!=f[s]) f[s]=find(f[s]);
	return f[s];
}
int main()
{
	cin>>a>>b;
	for(int i=0;i<=b;i++) f[i]=i;
	for(int i=1;i<=b;i++){
		d[++cnt].u=0;
		d[cnt].r=i;
		d[cnt].w=a;
	}
	for(int i=1;i<=b;i++){
		for(int j=1;j<=b;j++){
			cin>>num;
			if(num!=0){
				d[++cnt].u=i;
				d[cnt].r=j;
				d[cnt].w=num;
			}
		}
	}
	sort(d+1,d+cnt+1,cmp);
	for(int i=1;i<=cnt;i++){
		e=find(d[i].u);
		r=find(d[i].r);
		if(e!=r){
			ans+=d[i].w;
			f[r]=e;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：chenlingxi (赞：13)

代码方面没啥好讲的

楼下dalao都讲的很清楚

矩阵转换成最小生成树


------------

然而

加的那组数据中

## 加一起买的反而比分开卖的贵

这让我想起

一个玉米三块钱

三个玉米十块钱

的故事

~~事实上我们买了三个九块钱~~

~~还在暗喜赚了一块钱时~~

~~却发现为啥要买三个玉米~~

~~但这道题当中我们还多花了一块钱~~

是的，就是~~两~~块钱，数据如下图

3 3

0 4 4

4 0 4

4 4 0

正常输出11，然而只要9

~~什么鬼畜数据~~

------------

所以

```cpp
edge[m].w = g[i][j];
//摘自 I_love_him52 dalao的题解的一部分
```

就会变成

```cpp
edge[m].w = min(g[i][j] , ans);
//ans 在他的代码中就是那个A
```

然后就这么过了

~~[我的评测记录](https://www.luogu.org/record/show?rid=12294017)~~

---

## 作者：Misaka19280 (赞：10)

我们来分析一下这个问题QAQ 这题的出题人十分良心，两个物体可以捆绑在一起销售（hua_ji），而且~~价格~~边权还相同，我们就可以

1、把捆绑优惠的两个物体间连一条边。

2、我看到连边头一个想到的居然是最短路（果然还是我太菜了）。事实上，每个物体都要买，只要使这个图联通就行了。良心的出题人告诉我们边权相同，也就是无相图，然后用最小生成树，我们再瞎~~搞搞~~改改就可以AC了，想一想都很激动。

十分类似于[【模板】最小生成树](https://www.luogu.org/problemnew/show/P3366)

啊啊，最小生成树有两种做法，我用的是克鲁斯卡尔，个人认为比较好理解。

克鲁斯卡尔的主要思路：借助并查集，每次选取边权最小的，看看边连接的两点是否在一个并查集（也就是两个点是否已经可以联通）。不在，联通，假如一个并查集，在，就不管这条边了。


------------

哦，还有一点，这题与模板的差别是：首先是读入需要改一下，并且要加上第一点的权值。为什么要加呢，因为你买第一个东西是要钱的

~~代码自己手写吧~~良心点，加个代码吧

```
Type 
	hua_ji=record
		x,y,z:longint;
	end;

Var
	f:array[1..250000]of hua_ji; 
	a,b,i,j,top,x,ans,q:longint; //这里要多加个top，统计边数，其实可以用公式计算，但是我认为累加会更好理解
	father:array[1..500]of longint; 
	
Procedure qsort(l,r:longint);  //快排，关键字为边权
var
	i,j,e:longint;
	t:hua_ji;
begin
	i:=l;
	j:=r;
	e:=f[(l+r) div 2].z;
	repeat
		while f[i].z<e do inc(i);
		while f[j].z>e do dec(j);
		if i<=j then
			begin
				t:=f[i];
				f[i]:=f[j];
				f[j]:=t;
				inc(i);
				dec(j);
			end;
	until i>j;
	if i<r then qsort(i,r);
	if l<j then qsort(l,j);
end;
	
Function searchfather(k:longint):longint;
begin
	if k<>father[k] then searchfather:=searchfather(father[k])
		else searchfather:=k;
	father[k]:=searchfather;
end;
	
Begin
	readln(a,b);
	top:=0;
	for i:=1 to b do
		begin
			for j:=1 to b do
				begin
					read(x);
					inc(top); //累加，到目前为止共有top条边，其实top=(i-1)*b+j
					f[top].x:=i;
					f[top].y:=j;
					if x=0 then f[top].z:=a //不优惠就原价
						else f[top].z:=x;
				end;
			readln;
		end;
	qsort(1,top);
	for i:=1 to b do
		father[i]:=i; //就是一个并查集
	ans:=b;
	q:=a;
	for i:=1 to top do
		begin
			x:=searchfather(father[f[i].x]); //找祖先
			b:=searchfather(father[f[i].y]);
			if x<>b then //如果祖先不同合并
				begin
					father[x]:=b;
					q:=q+f[i].z;
					dec(ans); //ans记录的是当前边数
				end;
			if ans=1 then break; 这里是一个优化，一共要连b-1条边，达到b-1条边就可以退出
		end;
	writeln(q);
End.
```

---

## 作者：Jelly_Goat (赞：6)

这题好久之前做的时候没想出来最小生成树做法...  
回来补一发。

-------

这个题说的是你要保证你将B个物体上有B条边相连...  
那么我们可以虚构一个点（比如我这里的B+1）  
然后每一条边向有优惠的地方相连，有边权...  
问你将虚点和这些点都连起来的最小代价。

这不就是板子咯！

于是kruscal大法...

代码实现：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
inline int read()
{
	int num = 0; char ch = getchar(); bool flag = false;
	while (!isdigit(ch)) flag = ch == '-', ch = getchar();
	while (isdigit(ch))
		num = (num << 1) + (num << 3) + (ch ^ 48), ch = getchar();
	return flag ? -num : num; 
}
struct edge {
	int from, to, dis;
} Edge[250086];
inline bool operator < (const edge &a, const edge &b)
{
	return a.dis < b.dis;
}
inline void add_edge(int from, int to, int dis, const int &index)
{
	Edge[index] = (edge){ from, to, dis };
}
int fa[10086];
int find(int son)
{
	return fa[son] == son ? son : fa[son] = find(fa[son]);
}
int n, m, A, B;

int kruscal()
{
	int ans = 0, cnt = 0;
    //注意要求连B条边
	for (register int i = 1; i <= m && cnt <= B; i++)
	{
		int ff = find(Edge[i].from), ft = find(Edge[i].to);
        //ff:father of from ft: father of to
		if (ff == ft)
			continue;
		fa[ft] = ff;
		cnt++;
		ans += Edge[i].dis;
	}
	return ans;
}

int main()
{
	A = read(), B = read();
	//scanf("%d%d", &A, &B);
	for (register int i = 1; i <= B + 1; i++)
		fa[i] = i;
	for (register int i = 1; i <= B; i++)
	{
		int dis;
		for (register int j = 1; j <= i; j++)
			dis = read();//scanf("%d", &dis);
            //多余的可以不处理（反正是对称的）
		for (register int j = i + 1; j <= B; j++)
		{
			dis = read();//scanf("%d", &dis);
			dis ? add_edge(i, j, dis, ++m) : (void)dis;
            //注意边权为0的时候不要连边...
		}
	}
	for (register int i = 1; i <= B; i++) //向虚点连边
		add_edge(B + 1, i, A, ++m);
    //kruscal常规操作
	sort(Edge + 1, Edge + m + 1);
	printf("%d\n", kruscal());
	return 0;
}
```

---

## 作者：Wenxiang_MCL (赞：6)

一道十分简单的最小生成树的问题

主要问题是将初始条件设置好

如果两个不同商品间没有优惠，那么这条路径就设为A

构造好最小生成树后，只需要把所有路径累积即可

注意：不要忘了在最后答案加上一个A（第一个东西还是没优惠的）

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn = 501;
const int INF = 0x7fffffff;
int f[maxn][maxn];
int dis[maxn];
bool s[maxn];
int main ()
{
    //freopen("present.in","r",stdin);
    int cost,n;
    cin >> cost >> n;
    for (int i = 1;i <= n;i ++)
    for (int j = 1;j <= n;j ++)
    {
        cin >> f[i][j];
        if(i == j) {
            f[i][j] = INF;//自己和自己直接就直接赋极大值
            continue;
        }
        if(!f[i][j]) f[i][j] = cost;
        f[j][i] = f[i][j];//无向图
    }
    for(int i = 1;i <= n;i ++) dis[i] = INF;
    dis[1] = 0;
    for(int i = 1;i <= n;i ++)//prim算法求最小生成树
    {
        int cmin = INF,p;
        for(int j = 1;j <= n;j ++)
            if(dis[j] < cmin&&!s[j]){
                cmin = dis[j];
                p = j;
            }
        s[p] = true;
        for(int j = 1;j <= n;j ++){
            if(f[p][j] < dis[j]&&!s[j]) dis[j] = f[p][j];
        }
    }
    int sum = 0;
    for(int i = 1;i <= n;i ++) sum += dis[i];
    cout << sum + cost;//不要忘了加一个基本价值
}
```

---

## 作者：EarthGiao (赞：5)

## 【思路】

最小生成树(克鲁斯卡尔) + 并查集     
很有意思    
在买了一个东西之后买另一个东西会有不同的价格    
这就可以看成建立一颗最小生成树    
然后跑就可以了   
     
不过这道题显然没有那么简单的    
不然就真成为了一道克鲁斯卡尔板子题了     
还需要考虑一个东西    
不需要很大的思维了只是要细心   
第一个买的东西是不是需要钱？   
这是必然需要的      
所以ans可以一开始就赋值为aa的价格      
 
###　注意：     
输入0就表示输入的原价购买没有优惠！      

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;
const int Max = 505;
struct node
{
	int x,y;
	int w;
}a[Max * Max]; 
int father[Max << 1];
bool cmp(const node x,const node y)
{
	return x.w < y.w;
}

int find(int x)
{
	if(father[x] != x)father[x] = find(father[x]);
	return father[x];
}

void hebing(int x,int y)
{
	x = find(x);
	y = find(y);
	father[x] = y;
}

int main()
{
	int aa,b;
	cin >> aa >> b;
	int js = 0;
	int jj = 0;
	for(register int i = 1;i <= b;++ i)
		father[i] = i;
	for(register int i = 1;i <= b;++ i)
		for(register int j = 1;j <= b;++ j)
		{
			cin >> a[++ jj].w,a[jj].x = i,a[jj].y = j;
			if(a[jj].w == 0)a[jj].w = aa;
		}
	sort(a + 1,a + 1 + jj,cmp);
	int ans = aa;
	for(register int i = 1;i <= jj;++ i)
	{
		if(find(a[i].x) != find(a[i].y))
			hebing(a[i].x,a[i].y),js ++,ans += a[i].w;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：1saunoya (赞：5)

># [更好的阅读体验](https://www.cnblogs.com/qf-breeze/p/10585456.html)

> #  [$problem$](https://www.luogu.org/problemnew/show/P1194)

>简单的说 这是一道最小生成树的模板题（~~背板子就行了~~）
 
> 然而刚看到这题 还不知道什么意思。

>所以的话 考虑建边

>怎么建边呢？ 看到这题毫无头绪

>第 i 件物品对 j 有优惠的话就建边 然后从 0 向各点连边权为a的边

~~~
inline void Add(int u,int v,int w) {
    cnt ++ ;
    edge[cnt] = node{u,v,w};
    return ;
}
~~~

~~~
	for(register int i=1;i<=b;i++)
        for(register int j=1;j<=b;j++) {
            int x = In() ;
            if(i<j and x) Add(i,j,x) ;
        }
    for(register int i=1;i<=b;i++) Add(0,i,a) ;
~~~
>建完边按权值排序跑kruskal。这就AC了。


>完整代码


~~~
#ifdef Dubug

#endif
#include <bits/stdc++.h>
using namespace std;
typedef long long LL ;
inline LL In() { LL res(0),f(1); register char c ;
    while(isspace(c=getchar())) ; c == '-'? f = -1 , c = getchar() : 0 ;
    while(res = (res << 1) + (res << 3) + (c & 15) , isdigit(c=getchar())) ;
    return res * f ;
}
int a,b;
struct node{
    int u,v,w;
};
const int N = 1 << 9;
node edge[N*N] ;
int fa[N<<1] ;
bool cmp (node x,node y) {
    return x.w < y.w ;
}
int cnt (0) ;
inline void Add(int u,int v,int w) {
    cnt ++ ;
    edge[cnt] = node{u,v,w};
    return ;
}
inline int find(int x) {
    return fa[x] == x ? fa[x] : fa[x] = find(fa[x]) ;
}
inline void merge(int x,int y) {
    fa[x] = fa[y] ;
    return ;
}
inline void kruskal() {
    LL ans (0) , v (0) ;
    sort(edge+1,edge+cnt+1,cmp) ;
    for(register int i=1;i<=cnt;i++) {
        int x = find(edge[i].u) , y = find(edge[i].v) ;
        if(x == y) continue ;
        ans += edge[i].w ;
        merge(x,y) ;
        if(++v == b) break ;
    }
    cout << ans << endl ;
    return ;
}
signed main() {
    a = In() , b = In() ;
    for(register int i=0;i<=b;i++) fa[i] = i ;
    for(register int i=1;i<=b;i++)
        for(register int j=1;j<=b;j++) {
            int x = In() ;
            if(i<j and x) Add(i,j,x) ;
        }
    for(register int i=1;i<=b;i++) Add(0,i,a) ;
    return kruskal() , 0 ;
}
~~~

---

## 作者：lych (赞：4)

本题描述得非常好，以至于很多人都没有看出来本题的真实面目。其实这是非常基础一道**[color=red]最小生成树[/color]**问题，但是需要进行一点小改动。下面就对本题进行一点小改动。

首先分析那个优惠，由题意，只有访问了i才能有j的优惠，也就是说，如果访问了i，我们就能以a[i,j]的代价访问j。我们发现这一点[color=red]和最小生成树的选取一个点[/color]非常相似。我们不妨将i往j连一条权威a[i,j]的边，同时加入一个辅助点0，使其与所有点的距离为a，由此，我们只要从0出发，求一边最小生成树问题就能得出解。由于B较小，建议使用prim算法。算法如下：

```delphi
var
  a:array[0..500,0..500] of longint;//图
  d:array[0..500] of longint;//到原点的路径
  f:array[0..500] of boolean;//访问标记
  i,j,k,min,m,n,s,ans:longint;
begin
  readln(m,n);
  for i:=1 to n do
    begin
      for j:=1 to n do
        begin
          read(a[i,j]);
          if (a[i,j]=0) and (i<>j) then a[i,j]:=m;
        end;
      readln;
    end;//连边
  for i:=0 to n do
    d[i]:=m;//赋初值
  fillchar(f,sizeof(f),true);
  f[0]:=false;
  for j:=1 to n do
    begin
      min:=0;
      for k:=1 to n do
        if f[k] and (d[k]<=d[min]) then min:=k;//查找最近的点
      f[min]:=false;//标记为已访问
      ans:=ans+d[min];//最小生成树值的更新
      for k:=1 to n do
        if f[k] and (a[min,k]<d[k]) then
          d[k]:=a[min,k];//更新到其他节点的距离
    end;
  writeln(ans);
end.
```

---

## 作者：SKTT1Faker (赞：3)

这道题毛看很难，要用动规，实际上，就是一道最小生成树。

这道题就是如果没优惠，就用原价，有就用优惠价。

我们先买原物品，再买优惠物品，相当于

先到图的一个点，才能到图的另一点，优惠价格就是那条边。

最小生成树有prim和kruskal算法

我就用kruskal，这道题与模版题的区别是输入与要加第一点的权值。

p党代码：

```cpp
var
i,j,ans,sum,a,b,xx,yy,x,s:longint;
n:array[1..1000000,1..3] of longint;  //边集数组
fa:array[1..1000] of longint;     //并查集数组
procedure sort(a,b:longint);      //快排
var
i,j,mid,t:longint;
begin
  i:=a;
  j:=b;
  mid:=n[(i+j) div 2,3];
  repeat
    while n[i,3]<mid do i:=i+1;
    while n[j,3]>mid do j:=j-1;
    if j>=i then
    begin
      t:=n[i,1]; n[i,1]:=n[j,1]; n[j,1]:=t;
      t:=n[i,2]; n[i,2]:=n[j,2]; n[j,2]:=t;
      t:=n[i,3]; n[i,3]:=n[j,3]; n[j,3]:=t;
      i:=i+1;
      j:=j-1;
    end;
  until i>j;
  if b>i then sort(i,b);
  if j>a then sort(a,j);
end;
function find(x:longint):longint;
begin
  if fa[x]=x then exit(x);
  x:=find(fa[x]);       //这句很巧妙，用了递归搜根节点
  exit(x);
end;
begin
  read(a,b);
  for i:=1 to b do
  begin
    for j:=1 to b do
    begin
      s:=s+1;            //s为边的数量
      read(x);
      if x=0 then
      begin
        n[s,1]:=i;
        n[s,2]:=j;
        n[s,3]:=a;
      end else    //如果没优惠，那就原价
      begin
        n[s,1]:=i;
        n[s,2]:=j;
        n[s,3]:=x;
      end;
    end;
    readln;
  end;
  sort(1,s);          
  for i:=1 to b do
  fa[i]:=i;
  for i:=1 to s do
  begin
    xx:=find(fa[n[i,1]]);
    yy:=find(fa[n[i,2]]);
    if xx<>yy then
    begin
      fa[xx]:=yy;
      sum:=sum+1;
      ans:=ans+n[i,3];
    end;
    if sum=b then break;       //这题求点，而不是求边，所以sum=b（边数）
  end;
  write(ans+a);  //结果要加第一个点的权值
end.
```

---

## 作者：清风我已逝 (赞：2)


建立虚拟节点，即多出来一个点，标号为b+1,将b+1向前b个节点连一条权值为a的边，用Prim跑最小生成树即可。

```cpp
#include<bits/stdc++.h>

#define N 5100
using namespace std;

int a,b,g[5010][5050],minn[N],n;
bool vis[N];
long long ans;
int main()
{
	scanf("%d%d",&a,&b);
	for(int i=1;i<=b;i++)
		for(int j=1;j<=b;j++){
			scanf("%d",&g[i][j]);
			if(!g[i][j]) g[i][j]=0x7fffffff;
		}
	for(int i=0;i<=b;i++)	
		g[b+1][i]=a,g[i][b+1]=0x7fffffff;
	memset(minn,0x7f,sizeof(minn));
	n=b+1;
	int k=0;minn[n]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(minn[j]<minn[k]&&!vis[j]) k=j;
		}
		vis[k]=1;
		for(int j=1;j<=n;j++){
			if(!vis[j]&&minn[j]>g[k][j])
				minn[j]=g[k][j];
		}k=0;
	}
	for(int i=1;i<=n;i++)
		ans+=minn[i];
//	ans+=a;
	printf("%lld\n",ans);
	return 0;
}
```

---


# 电车

## 题目描述

在一个神奇的小镇上有着一个特别的电车网络，它由一些路口和轨道组成，每个路口都连接着若干个轨道，每个轨道都通向一个路口（不排除有的观光轨道转一圈后返回路口的可能）。在每个路口，都有一个开关决定着出去的轨道，每个开关都有一个默认的状态，每辆电车行驶到路口之后，只能从开关所指向的轨道出去，如果电车司机想走另一个轨道，他就必须下车切换开关的状态。

为了行驶向目标地点，电车司机不得不经常下车来切换开关，于是，他们想请你写一个程序，计算一辆从路口 $A$ 到路口 $B$ 最少需要下车切换几次开关。


## 样例 #1

### 输入

```
3 2 1
2 2 3
2 3 1
2 1 2```

### 输出

```
0```

# 题解

## 作者：囧人232 (赞：96)

这道题的关键在**建图**

把每一个车站看成一个点，将这个车站相连的第一个车站建立一条边权为0的边，对于它所相连的其他车站，建立边权为1的边；

这样我们可以得到一张图；

起点，终点都知道了，跑一边最短路即可

最短路可以用spfa，floyd，迪杰斯特拉；

因为n只有200，跑遍floyd就行；

但是还有一个小细节；

对于我们建的每一条边，都只是单向边，不要加上f【i】【j】=f【j】【i】；

附ac代码

    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=100+10;
const int inf=1e+8;
int g[maxn][maxn];
int n,m,k,f,t;
int main()
{
    scanf("%d%d%d",&n,&f,&t);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {g[i][j]=inf;g[i][i]=0;} 
    for(int i=1;i<=n;i++){
    scanf("%d",&k);
    for(int j=1;j<=k;j++){
    int a;
    scanf("%d",&a);
    if(j==1)g[i][a]=0;
    else g[i][a]=1;
    }
    }
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
    if(g[f][t]==inf)puts("-1");
    else printf("%d",g[f][t]);
}
//类似这种转化的还可以看看 洛谷上奇怪的电梯，思路差不多相同但是要用spfa；
//希望对你们有帮助，rp++
```

---

## 作者：YellowBean_Elsa (赞：52)

## 双端队列广搜才应该是正解！

此题与普通BFS区别在于有0，1之分，队列单调性难以保持（学过BFS都应该知道这个）

#### 于是我们把0从头插入，把1从尾插入，维护队列单调性

详见代码


------------

```cpp
//双端队列广搜，预计复杂度O(n) 
#include<bits/stdc++.h>
using namespace std;
int n,s,t;//s为起点，t为终点 
int e[105][105],k[105];//e存边，k表示每个节点出边条数 
int dis[105];//距离 
inline int read(){
    int x=0;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-48,ch=getchar();
    return x;
}
deque<int> q;//双端队列是一种特别骚的STL，建议学一学，很简单。 
bool vis[105];
int main(){
	//初始化
	memset(vis,0,sizeof(vis));
	memset(dis,0x7f,sizeof(dis)); 
	//读入 
	n=read();s=read();t=read();
	for(int i=1;i<=n;i++){
		k[i]=read();
		for(int j=1;j<=k[i];j++){
			e[i][j]=read();
		}
	}
	q.push_back(s);dis[s]=0;
	//BFS 
	while(q.size()){
		int x=q.front();q.pop_front();
		if(vis[x])continue;//第一次取出就是该点最短路，
		//可避免点重复取出（类似DIJIKSTRA） 
		vis[x]=1;
		if(x==t){
			printf("%d\n",dis[t]);
			return 0;
		}
		//扫描出边 
		for(int i=1;i<=k[x];i++){
			int y=e[x][i];
			if(!k[y])continue;//剪枝：不到没有出边的点 
			if(i==1){
				dis[y]=min(dis[y],dis[x]);
				if(!vis[y])q.push_front(y);//因为dis[y]<=dis[x],所以在队列中最小
				//从头插入维护队列单调性 
			}
			else{
				dis[y]=min(dis[y],dis[x]+1);
				if(!vis[y])q.push_back(y);//因为dis[y]在dis[x]“下一层” ， 
				//从尾插入维护队列单调性 
			}
		}
	}
	printf("-1");
	return 0;
}

```


------------

数据太弱，体现不出本解法与最短路的差异。大家有兴趣的话可以自造大数据测试。


---

## 作者：Strong_Jelly (赞：41)

# 电车


**题目描述**

在一个神奇的小镇上有着一个特别的电车网络，它由一些路口和轨道组成，每个路口都连接着若干个轨道，每个轨道都通向一个路口（不排除有的观光轨道转一圈后返回路口的可能）。在每个路口，都有一个开关决定着出去的轨道，每个开关都有一个默认的状态，每辆电车行驶到路口之后，只能从开关所指向的轨道出去，如果电车司机想走另一个轨道，他就必须下车切换开关的状态。

为了行驶向目标地点，电车司机不得不经常下车来切换开关，于是，他们想请你写一个程序，计算一辆从路口A到路口B**最少**需要下车切换几次开关。




------------

这道题其实就是最短路径的一个模板，只不过没有思路是做不出来的，有了思路就简单了。

### 思路：

**可以把一个路口看作一张图中的一个点，轨道是图中的边（注意：这是有向图），每一条边的权值就是这个边所联通的点是否需要按按钮（需要按按钮就是1，不需要按按钮就是0）然后就用求最短路径的算法算出最少需要按的开关数。**

求最短路径的算法有三种——**Floyed**算法，**Dijkstra**算法, **Spfa**算法。

## 1.Floyed算法（弗洛伊德算法）
**算法思想：通过中间点k求得是从i ---> j近还是从i ---> k ---> j 近，从而求得点a到点b的最短路径（a和b都是随机点）**

**时间复杂度：O（n³）**

code：

```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f//巨大无比的一个数！ 
using namespace std;
int n, s, e, m, x, f[1001][1001];//f[i][j]表示从i到j的长度 
void floy()//floyed模板 
{
	for(int k = 1; k <= n; k++)
	{
		for(int i = 1; i <= n; i++)
		{
			for(int j = 1; j <= n; j++)
			{
				if(!(i == j || i == k || j == k))//i不能等于j， j不能等于k， i不能等于k 
				{
					f[i][j] = min(f[i][k] + f[k][j], f[i][j]);//取最小值 
				}
			}
		}
	}
}
int main()
{
	memset(f, INF, sizeof(f));//初始化f 
	scanf("%d %d %d", &n, &s, &e);
	for(int i = 1; i <= n; i++)//自己到自己不用按开关 
	{
		f[i][i] = 0;
	}
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &m);
		for(int j = 1; j <= m; j++)
		{
			scanf("%d", &x);
			if(j == 1)//第一个赋值为0 
			{
				f[i][x] = 0;
			}
			else
			{
				f[i][x] = 1;
			}
		}
	}
	floy();
	if(f[s][e] == INF)
	{
		printf("-1");
	}
	else
	{
		printf("%d", f[s][e]);
	}
	return 0;
}
```


------------

## 2.Dijkstra算法（戴克斯特拉算法）

**缺陷：只能计算起点只有一个的情况，不能出现负边权的情况**

**算法思想：Dijkstra算法是通过每次添加一个新节点加入集合，直到所有点加入停止的 最短路径的算法。**

**时间复杂度：O（n²）**

code：

```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f//巨大无比的一个数！ 
using namespace std;
int n, s, e, m, x, f[1001][1001], dis[100001];//f[i][j]表示从i到j的长度 , dis[i]表示从s(起点)到i的长度 
bool vis[100001];//vis表示一个点是否在最短路径中，在vis[i] = true, 不在vis[i] = false 
int main()
{
	memset(f, INF, sizeof(f));//初始化f 
	memset(dis, INF, sizeof(dis));//初始化dis 
	scanf("%d %d %d", &n, &s, &e);
	for(int i = 1; i <= n; i++)//自己到自己不用按开关 
	{
		f[i][i] = 0;
	}
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &m);
		for(int j = 1; j <= m; j++)
		{
			scanf("%d", &x);
			if(j == 1)//第一个赋值为0
			{
				f[i][x] = 0;
			}
			else
			{
				f[i][x] = 1;
			}
		}
	}
	for(int i = 1; i <= n; i++)//把f赋值到dis上 
	{
		dis[i] = f[s][i];//由于dis[i]是s到i, 那f就要赋给它f[s][i] 
	}
	dis[s] = 0;
	for(int i = 1; i <= n; i++)
	{
		int minn = INF;//minn取很大一个数， 来更新最短路径 
		int k = 0;//k表示这次循环放进最短路径中的数的下标 
		for(int j = 1; j <= n; j++)
		{
			if(!vis[j] && dis[j] < minn)//不在最短路径中且路径长小于minn 
			{
				minn = dis[j];
				k = j;
			}
		}
		if(!k)//最短路径已找到 
		{
			break;
		}
		vis[k] = true;//把这个数放进最短路径中 
		for(int j = 1; j <= n; j++)
		{
			if(!vis[j] && dis[j] > dis[k] + f[k][j])//用最短路径中新更新的点来更新其他的点且不能是最短路径中的点 
			{
				dis[j] = dis[k] + f[k][j];//更新 
			}
		}
	}
	if(dis[e] == INF)
	{
		printf("-1");
	}
	else
	{
		printf("%d", dis[e]);
	}
	return 0;
}
```



------------
## 3.Spfa算法（福特队列优化算法）

**关于Spfa：**

# ~~它死了~~







###  结束finish(～￣▽￣)～

---

## 作者：dingcx (赞：24)

~~这道题的重点是理解题目在让你干什么~~
## 思路
### 题意
从起点走到终点，求最小总路程。其中对于每个点，如果走到的点是这个点连出的第一条边，总路程不加；如果是其它边，就加一。

所以，在建边前，所有边都初始化为正无穷；建边时，如果是第一条边，就把这条边的值赋为$0$，否则赋为$1$。

### 求法
看一下数据范围：$n≤100$。哈哈，直接$Floyd$不就求出来了吗！（~~不要告诉我你不知道什么是Floyd~~）

没什么好说的，就是一个三层暴力，打出来就结束了。不过……

## 细节
这道题关于$Floyd$的细节还比较多，说一下。

1. 上面提到过的，所有边**初始化为正无穷**。

2. $d[i][j]$和$d[j][i]$可是**不一样**的，千万不能搞反。比如核心代码中，应该为
```cpp
//d[i][j]表示i到j的距离，k为枚举的中转节点
d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
```
而不是
```cpp
d[i][j]=min(d[i][j],d[i][k]+d[j][k]);
```
也就是说$d[i][j]≠d[j][i]$。

3. 如果不能到达，**输出**$-1$。

## 代码
~~相信没有多少人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——

不加注释长度$26$行（~~有一些我很习惯的压行~~），最大测试点时间$10ms$（~~比较快~~）
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>//用到memset
using namespace std;
const int MAXN=110;
int d[MAXN][MAXN];//d[i][j]表示i到j的距离
int main(){
	memset(d,0x3f,sizeof(d));//初始化为正无穷
	int n,m,s,t,v;//s是起点，t是终点
	scanf("%d%d%d",&n,&s,&t);
	for(int i=1;i<=n;i++){//读入边
		scanf("%d",&m);
		for(int j=1;j<=m;j++){
			scanf("%d",&v);
			d[i][v]=(j==1)?0:1;//建边，判断是否是第一条边
            //这里用到三目运算符，等同于if(j==1) d[i][v]=0; else d[i][v]=1;
		}
	}
    //floyd
	for(int k=1;k<=n;k++)//遍历中转节点
		for(int i=1;i<=n;i++)//遍历节点
			for(int j=1;j<=n;j++){
				if(i==j||i==k||j==k) continue;//判断是否有重
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);//公式
			}
	printf("%d",(d[s][t]==0x3f3f3f3f)?-1:d[s][t]);//输出，注意无法到达要输出-1
	return 0;//华丽结束
}
```
看我这么辛苦，总得点个赞再走呀~

---

## 作者：MornEveGlow (赞：14)

·你打算直接跳过图论来做最短路

·你用了C++dijkstra邻接矩阵来做这一题

·你发现这题要以按开关来当做权值

·是默认状态说明这个路口到默认路口的轨道权值为0

·否则为1

```cpp
    #include<cstdio>
    using namespace std;
    const int INF=2e9,maxn=101;
    int n,a,b,curr,mn,g[maxn][maxn],dis[maxn];
    bool vis[maxn];
    int main()
    {
        for(int i=0;i<maxn;i++)
          for(int j=0;j<maxn;j++)
            g[i][j]=INF;
        for(int i=0;i<maxn;i++)g[i][i]=0;
        for(int i=0;i<maxn;i++)dis[i]=INF;
        scanf("%d%d%d",&n,&a,&b);
        for(int i=0,m;i<n;i++)
        {
            scanf("%d",&m);
            for(int j=0,d;j<m;j++)
            {
                scanf("%d",&d);
                if(j==0)g[i+1][d]=0;
                else g[i+1][d]=1;
            }
        }
        curr=a;vis[a]=true;dis[a]=0;
        while(!vis[b])
        {
            for(int i=1;i<=n;i++)
            {
                if(vis[i]||g[curr][i]==INF)continue;
                if(dis[i]>g[curr][i]+dis[curr])dis[i]=g[curr][i]+dis[curr];
            }
            mn=INF;
            for(int i=1;i<=n;i++)
            {
                if(vis[i]||dis[i]>=mn)continue;
                curr=i;mn=dis[i];
            }
            if(mn==INF)
            {
                printf("-1");
                return 0;
            }
            vis[curr]=true;
        }
        printf("%d ",dis[b]);
}
```

---

## 作者：zhutier (赞：11)

作为一个刚刚上手最短路的人

一开始看到这个题我是吓傻了的

后来一想

开一次开关，边权为1；

不用开开关，边权为0.

因为重复走dist会更大，所以会被自动过滤掉

解决了！

小细节：

此题为单向边。

并且用邻接表存的时候，1个路口可以通往99个路口，所以数组要开$100*100$至少

(我开邻接表的数组总是开小，难受极了)

SPFA代码：
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
#define INF 100000000
using namespace std;
int n,a,b,head[201],nxt[20002],w[20002],to[20002],k,dist[101],en,t;
queue<int> q;
bool v[20002];
void add(int x,int y,int z){
	en++;
	nxt[en]=head[x];
	head[x]=en;
	to[en]=y;
	w[en]=z;
}
void spfa(){
	for(int i=1;i<=n;i++) dist[i]=INF;//初始化
	dist[a]=0;
	q.push(a);
	v[a]=true;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		v[x]=false;
		for(int i=head[x];i!=-1;i=nxt[i])
			if(to[i]!=-1){
				if(dist[to[i]]>dist[x]+w[i]){
					dist[to[i]]=dist[x]+w[i];
					if(!v[to[i]]) q.push(to[i]),v[to[i]]=true;		
				}
			}
	}
}
int main(){
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1;i<=n;i++) to[i]=-1,head[i]=-1,nxt[i]=-1;
	for(int i=1;i<=n;i++){
		scanf("%d",&t);
		for(int j=1;j<=t;j++){
			scanf("%d",&k);
			if(j==1) add(i,k,0);//轨道当前指向的路口，这条路边权为0
			else add(i,k,1);//边权为一的情况，即要按开关
		}
	}
	spfa();
	if(dist[b]==INF){
		printf("-1\n");
		return 0;
	}//记得要判断是否有解哦！！！！！
	printf("%d\n",dist[b]);
	return 0;
} 
```

（学会SPFA后就爱上了它。。。）

---

## 作者：callG (赞：6)

首先建图在[这里](https://www.luogu.org/blog/user43601/solution-p1346)已经讲的很好了，我就不讲了。  
我只是来讲下 01BFS 怎么写。  
如果一个图的所有边的边权都只有 0 或 1 ，那么就可以用 01BFS 求解。
## 为什么要学 01BFS
01BFS的复杂度为 $O(n)$。  
## 01BFS
1. 将到所有点的距离赋为 INF
2. 将到源点的距离赋为 0
3. 将源点的标号入队
4. 取出队头点 $u$ ，遍历出边 $v$  
$\quad$如果可以松弛，则  
$\quad\quad$进行松弛操作  
$\quad\quad$如果 $e=(u,v)$ 边权为 0 ，则将 $v$ 压入队头  
$\quad\quad$否则将 $v$ 压入队尾
5. 若队列不为空，则重复步骤4  

**时间复杂度 $O(n)$。**（相关内容见“写在后面”）  
具体实现见代码

## 代码

```cpp
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int MAXN = 107, MAXM = MAXN * MAXN - MAXN;

struct Edge
{
  int to, next, len;
  Edge() {}
  Edge(int to, int next, int len)
      : to(to), next(next), len(len) {}
} e[MAXM];
int tot, head[MAXN];
inline void addEdge(int from, int to, int len)
{
  e[++tot] = Edge(to, head[from], len);
  head[from] = tot;
}

int a, b, n, dis[MAXN];

deque<int> q;
inline int bfs()
{
  memset(dis, 0x3f, sizeof(dis));
  dis[a] = 0;
  q.push_back(a);
  while (!q.empty())
  {
    int x = q.front();
    q.pop_front();
    for (int to, i = head[x]; i; i = e[i].next)
    {
      if (dis[to = e[i].to] <= dis[x] + e[i].len) continue;
      dis[to] = dis[x] + e[i].len; // 松弛
      if (e[i].len)                // len[i] = 1
        q.push_back(to);
      else
        q.push_front(to);
    }
  }
  return dis[b] == 0x3f3f3f3f ? -1 : dis[b];
}

int main()
{
  cin >> n >> a >> b;
  for (int i = 1, j, k; i <= n; i++)
  {
    cin >> k;
    bool flag = false;
    while (k--)
    {
      cin >> j;
      addEdge(i, j, flag);
      flag = true;
    }
  }
  cout << bfs() << endl;
  return 0;
}
```

## 写在后面
[01BFS教程](https://codeforces.com/blog/entry/22276)  
[我的博客（这个链接似乎目前访问不了）](https://oi.callg.cf/2018/12-19/LG1346/)  
~~其实 01BFS 实际效率并没有比其他算法高到不知道哪里去~~

---

## 作者：Isprime (赞：5)

luogu P1346电车 题解

qwq配合[Blog](https://www.luogu.org/blog/149815/solution-p1346)食用更佳

[原题传送门](https://www.luogu.org/problem/P1346)

~~说句闲话：要不是为了刷社区贡献我才不会来做这道水题呢~~

这题很明显最短路，每条边的权值就是是否下车切换开关，接下来跑一遍最短路即可

## 关于最短路

目前最短路主流算法有三种：Floyd，Dijkstra，SPFA

### Floyd算法

无脑dp……由于其O($N^{3}$)的时间复杂度，这里就不做介绍

### Dijkstra算法

这是目前OIer们最爱用的算法，经过堆优化的Dij时间复杂度仅为O(N log N)

~~如果不懂Dij出门左转[单源最短路径（标准版）](https://www.luogu.org/problemnew/solution/P4779)~~

Code↓
```cpp
#include<cstdio>
#include<queue>
#define MAXN 101
#define MAXM 10001
#define INF 2147483647
#define ri register int 
using namespace std;
int n,s,t,edge_sum;
int dis[MAXN],head[MAXN];
bool vis[MAXN];
struct Edge{
	int next,to,dis;
}edge[MAXM];//前向星存图QwQ
void addedge(int from,int to,int dis){
	edge[++edge_sum].next=head[from];
	edge[edge_sum].to=to;
	edge[edge_sum].dis=dis;
	head[from]=edge_sum;
}
struct Node{
	int u,v;
	bool operator <(const Node& rhs) const {
        return v>rhs.v;
    }
};
priority_queue<Node> q;//STL优先队列，用来模拟小根堆
void dijkstra(){//堆优化Dijkstra
	for(ri i=1;i<=n;i++) dis[i]=INF;//初始化为2147483647
	dis[s]=0;
	q.push((Node){s,0});
	while(!q.empty()){
		Node t=q.top();
		q.pop();
		int u=t.u;
		if(vis[u]) continue;
		vis[u]=1;
		for(register int j=head[u];j;j=edge[j].next){
			if(dis[u]+edge[j].dis<dis[edge[j].to])//如果更短就更新{
				dis[edge[j].to]=dis[u]+edge[j].dis;
				if(!vis[edge[j].to]) q.push((Node){edge[j].to,dis[edge[j].to]});//入队
			} 
    	}
	}
}
int main(){
	scanf("%d %d %d",&n,&s,&t);
	for(ri i=1;i<=n;i++){
		int x,y;
		scanf("%d",&x);
		if(x==0) continue ;
		scanf("%d",&y);
		addedge(i,y,0);//不需要切开关
		for(ri j=2;j<=x;j++){
			scanf("%d",&y);
			addedge(i,y,1);//需要切开关
		}
	} 
	dijkstra();
	if(dis[t]==INF) printf("-1\n");
	else printf("%d\n",dis[t]);
	return 0;
} 
```
注意！Dijkstra不能处理**带负权回路的图**！

SPFA算法

SPFA可以用来处理带负权回路的图，它的时间复杂度是O(NM)


什么，你问我代码在哪儿？

~~这都9012年了还用SPFA？？？~~

# 关于SPFA
### ~~它死了~~

NOI2018D1T1，血的教训

**理想中的单源最短路**：~~n<=100000，带有负权回路~~

**qwq**

---

## 作者：ww3113306 (赞：4)

貌似并没有人用Floyd，，这里我就介绍一下Floyd的做法吧，不知道Floyd的自行百度

```cpp
#include<bits/stdc++.h>
using namespace std;
int Map[110][110],n,from,want,z[110][110];
int main()
{
    int i,k,j,num;
    scanf("%d%d%d",&n,&from,&want);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            Map[i][j]=99999; //因为后面要用min函数，所以先初始化为一个极大值（表示本蒟蒻并不知道二维数组怎么初始化，，于是，，）
    for(i=1;i<=n;i++)//读入
    {
        scanf("%d",&num);
        for(j=1;j<=num;j++)
        {
            scanf("%d",&k);
            if(j==1) Map[i][k]=0;//第一个的转换次数为0
            else Map[i][k]=1;
            z[i][k]=1;//z记录能不能到达
        }
    }
    for(k=1;k<=n;k++)//k要放在最前面
        for(i=1;i<=n;i++)
            for(j=1;j<=n;j++)
                if(z[i][k]==1&&z[k][j]==1) Map[i][j]=min(Map[i][k]+Map[k][j],Map[i][j]),z[i][j]=1;//如果i到k，k到j都是有路的，那就取最小值，并且把i，j之间设为可到达（这里注意z[i][j]这步必须有，并且要用min函数，不能放在if里面，第一次提交就是这个错的，，全部输出-1，因为都放在if里面可能进不了if（我之前没有初始化为99999）于是可能就会被记录为不可到达，，然后就不断输出-1.。） 
    if(z[from][want]==1)printf("%d",Map[from][want]);//如果可到达，输出最短路
    else printf("-1");//不能输出-1
    return 0;
}

```

---

## 作者：扬皓2006 (赞：2)

本题的难点在建图上（要不就是个朴素的最短路模板）

因数据<=100，所以时间复杂度为O(n^3)的Floyd可以跑过

就是把可以直接通过的边权设为0，需要掰♂开关的边权设为1

于是，我们就开始愉快地做题啦

先介绍一下Floyd的模板:
```
for(int k=1;k<=n;k++)//k相当于阶段，初学者容易写成i,j,k，要注意哦
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]);//这是松弛操作（也是最短路算法的基础）
                //由三角形两边之和大于第三边可以推出
			}
		}
	}
```
我们可能会奇怪，这个Floyd看起来为什么这么熟悉呢？

没错，它就是个DP！

完整代码如下:
```
int main()
{
	scanf("%d%d%d",&n,&s,&e);//节点数，起点，终点
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	dis[i][j]=0x3f;//邻接数组重置
	for(int i=1;i<=n;i++)  dis[i][i]=0;//邻接数组重置
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			int x;
			scanf("%d",&x);
			if(j==1)  dis[i][x]=0;//如果不需扳开关就设为1
			else dis[i][x]=1;//否则为0
		}
	}
	for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		dis[i][j]=min(dis[i][j],dis[k][j]+dis[i][k]);//上文所提到的FLoyd
	}
	if(dis[s][e]==0x3f)  cout<<-1;//如果无法到达就输出1
	else printf("%d",dis[s][e]);//否则输出最短路
	return 0;
}
此题还可以用Dijkstra（n^2,无法处理负边权），SPFA（已死），同学们可以自己探索。

最后，希望管理大大能够通过这篇题解!

---

## 作者：ysj1173886760 (赞：2)

这道题的数据非常的小，以至于各种算法都能水过，其实我是看到这题是最短路以后想来练练最短路的，然后读完题果断写了记忆化搜索，不知道这题dp可不可以，因为我不会在环上跑dp。。。。

下面说一下记忆化搜索的做法。

我们对根节点进行dfs，同时记一个vis数组，首先跑默认的路，这样权值不会+1，然后在跑其他的路，同时权值+1.我们每次取最小值，然后记录在dp数组中，因为是图，所以以后遍历到这个节点时直接返回dp的值即可。

那么dp数组记录的就是当前节点到目标点花费的最小代价。

这里要注意的是题中说了有环。那么其实记忆化搜索就会出现问题，我们如何解决呢？？

我们考虑两种情况，1目标点在环中，2目标点不在环中。

第一种情况我们在记忆化搜索的时候自动就解决了，如果跑入了环中，但是有目标点，就会直接返回0，也就是说环都跑不完就被目标点卡住了。

第二种情况我们进行特判，这时就用到了vis数组。因为如果出现了环，那么环起点的dp值还不会被更新，但是他的vis值已经被改变了，所以我们判断，如果出现了dp没被更新且vis值为真时，即为环。那么出现了环我们肯定是不走了（不走整个环，但不一定不走部分），也就是说，如果环上接出一条链是我们要走的，那么链后的部分我们一定不走。给他赋一个极大值废掉这条链就好了。在分叉点处自然就会在取min的过程中把这个极大值舍去，也就是不走环。

具体实现看代码吧：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,s,t,tot;
struct line
{
	int to,next;
}edge[100000];
int dp[200],g[200],first[200];	//first means acquiescent edge; g means head of adjacency list 
bool vis[200];
void add1(int a,int b)
{
	edge[++tot].to=b;
	edge[tot].next=g[a];
	g[a]=tot;
}
int dfs(int u)
{
	if(dp[u]!=-1)return dp[u];//被更新了就直接返回 
	if(u==t)return 0;			//目标点，返回0. 
	if(dp[u]==-1&&vis[u])return 99999999;	//发现环，返回极大值废除当前路径。 
	vis[u]=true;//已遍历 
	dp[u]=dfs(first[u]);//先跑默认的路径 
	int temp=g[u];
	while(temp)
	{
		dp[u]=min(dp[u],dfs(edge[temp].to)+1);//遍历其他的路径，并+1 
		temp=edge[temp].next;
	}
	return dp[u];
}
int main()
{
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++)				//水读入，忽视就好。 
	{
		int k=0;
		cin>>k;
		if(k==0)continue;
		cin>>first[i];
		for(int j=2;j<=k;j++)
		{
			int x=0;
			cin>>x;
			add1(i,x);
		}
	}
	memset(dp,-1,sizeof(dp));			//dp初始化。因为解可能为0，所以我们赋-1 
	dfs(s);								//dfs source 
	if(dp[s]==99999999)cout<<"-1";		//如果是极大值说明不能到目标点，返回-1 
	else cout<<dp[s];					//output answer
	return 0;
}
```

---

## 作者：dz_ice (赞：2)

刚看到这道题的时候其实是有点懵的，但仔细一想，只要把边的权值处理好了，这就是一道最短路的模板题

那么怎样去建图呢？题目给的条件提到
```
每个开关都有一个默认的状态，每辆电车行驶到路口之后，只能从开关所指向的轨道出去，如果电车司机想走另一个轨道，他就必须下车切换开关的状态
```
那么可以这样来看，如果司机走该路口与一开始开关所指向的路口的这条边，是不用切换开关的，那么就把这条边的权值赋为零，否则就把边的权值赋为1，这样就把问题转换成了裸的最短路

看到数据范围2<=$n$<=100（~~这么小的数据~~）,n三方过掉绰绰有余，不禁想到了用Floyed，代码简单而且好写

```
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k,x,f[103][103];
int main()
{
	cin>>n>>a>>b;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			f[i][j]=1e9;  //给每一条边先初始化成最大值 
	for(int i=1; i<=n; i++)
	{
		cin>>k;
		for(int j=0; j<k; j++)
		{
			cin>>x;
			if(j==0)
				f[i][x]=0;  //第一条边权值为0 
			else
				f[i][x]=1;  //另外的边权值为1 
		}  //还有注意这是单向边 
	}
	for(int l=1; l<=n; l++)
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				f[i][j]=min(f[i][l]+f[l][j],f[i][j]);  //Floyed跑一遍最短路 
	if(f[a][b]==1e9)  //如果无解就输出-1 
		cout<<-1;
	else
		cout<<f[a][b]; 
	return 0;
}
```


---

## 作者：钱逸凡 (赞：2)

很简单的spfa，只要注意不要重复搜即可。
注意到不了的要输出-1
c++AC代码
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int Read(){
	int x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}//读写优化是个好习惯 
int n,a,b;
struct way{
	int k;
	int zhong[101];
}dian[101];//与每个点相连的路 
queue <int > q;
int dist[101];
int inque[101];
int vis[101];
void spfa(int s){
	memset(dist,0x3f,sizeof(dist));//初始化 
	dist[s]=0;
	q.push(s);
	inque[s]=1;
	while(!q.empty()){
	int u=q.front();
	q.pop();
	inque[u]=0;
	if(vis[u]==0)
	for(int i=1;i<=dian[u].k;i++){
	if(i==1){
	dist[dian[u].zhong[1]]=min(dist[dian[u].zhong[1]],dist[u]);	
	}//不按开关 
	else if(dist[u]+1<dist[dian[u].zhong[i]]){
		dist[dian[u].zhong[i]]=dist[u]+1;
	}//按开关且比原来次数少 
	if(inque[dian[u].zhong[i]]==0){
			inque[dian[u].zhong[i]]=1;
			q.push(dian[u].zhong[i]);
		}
	}//防止重复入队 
	vis[u]=1;//防止重复搜同一个点 
	}
}
int main(){
	n=Read(),a=Read(),b=Read();
	int i,j;
	for(i=1;i<=n;i++){
	dian[i].k=Read();
	for(j=1;j<=dian[i].k;j++)dian[i].zhong[j]=Read();
	}
	spfa(a);
	if(dist[b]==1061109567)printf("-1");//到不了 
	else printf("%d",dist[b]);
	return 0;
}
```

---

## 作者：HAO233 (赞：1)

## 题目描述

**题面：**[洛谷]( https://www.luogu.org/problem/P1346 )

有一个电车网络有$N$个路口，每个入口有一个开关指向与该路口联通的第一个轨道，司机可以下车改变开关的方向，求从路口$A$到路口$B$要**最少**要改变几次开关的方向。

## 题解

我们可以把这个问题转换为：

给定一个有$N$个节点的有向图，每个节点相邻的第一条边权值为$0$，其余边为$1$，求从$A$节点到$B$节点的最短路。

为什么可以这样转换呢？我们可以把权值理解为开开关的次数。假设我们要驶向与路口相邻的第一个轨道，那么因为开关默认指向第一个轨道，所以驶向第一个轨道需要开开关的次数为$0$。自然，其他节点因为需要下车改变方向，所以需要开一次开关，所以权值为$1$。

将问题转换过后，我们可以发现这就是一个0/1边权最短路问题，写一个0/1边权BFS就可以解决。具体的细节代码注释里有。

01边权BFS当然是要比其他的算法快的，时间复杂度应该是$O(n + m)$

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e2 + 10;//最大节点数

vector<int> G[maxn];//储存图的数组
int dis[maxn];//储存a点至每个点距离的数组
bool done[maxn];//标记数组
deque<int> que;//双端队列

int main() {
    memset(dis, 0x3f3f3f3f, sizeof(dis));//初始化dis为INF
    int n, a, b;
    scanf("%d %d %d", &n, &a, &b);
    for (int i = 1; i <= n; i ++) {//读入
        int m;
        scanf("%d", &m);//i节点的大小
        for (int j = 1; j <= m; j ++) {
            int x;
            scanf("%d", &x);
            G[i].push_back(x);//建图
        }
    }
    que.push_back(a);//起点入队，准备遍历
    dis[a] = 0;//init
    while (!que.empty()) {//01边权BFS
        int u = que.front();//储存队首
        que.pop_front();//弹出队首
        if (done[u]) continue;//如果已经处理过了那么就跳过
        done[u] = true;//标记
        for (int i = 0; i < G[u].size(); i ++) {//遍历u的每一条边
            int v = G[u][i];//储存当前节点
            if (!done[v]) {//如果v没有被处理过
                dis[v] = min(dis[v] , dis[u] + (i != 0));//dis[v] min= dis[u] + w 
                if (i == 0) {//如果w为0（也就是i为0
                    que.push_front(v);//从前端插入
                }else {//否则
                    que.push_back(v);//从后端插入
                }
            }
        }
    }
    if (dis[b] == 0x3f3f3f3f) {//如果无解（也就是默认的初始化状态
        printf("-1");//输出-1
        return 0;
    }
    printf("%d", dis[b]);//输出答案
}
```





---

## 作者：Alear (赞：1)

貌似没有大佬发双端队广搜的写法，我来发一波。

对于边（u,v），如果开关默认指向v，则边权为0，否则边权为1，因为要下来进行一次开关的调整。

然后建立一个双端队，开始时队中只有起点
1. 设当前队头节点为u，对于它的每一条边（u,v,w），如果d[v]>d[u]+w,则更新d[v]。
2. 每更新一个节点，如果w为1，则从队尾入队；如果w为0，则从队头入队。
3. 重复以上步骤直到队列为空。

贴代码，30ms
```cpp
#include<bits/stdc++.h>
using namespace std;
const int  N=110,M=N*(N-1);
int head[N],next[M],ver[M],w[M];
inline void addEdge(int u,int v,int k){
	static int now=0;
	now++;
	next[now]=head[u];
	ver[now]=v;
	head[u]=now;
	w[now]=k;
}
int n,st,ed;
int d[N];
deque<int>q;
int main(){
	int k,u,v,e;
	memset(d,0x3f,sizeof(d));
	cin>>n>>st>>ed;
	for(int i=1;i<=n;i++){
		scanf("%d",&k);
		if(k==0)
			continue;
		scanf("%d",&v);
		addEdge(i,v,0);
		for(int j=1;j<k;j++){
			scanf("%d",&v);
			addEdge(i,v,1);
		}
	}
	q.push_back(st);
	d[st]=0;
	while(q.size()){
		u=q.front();
		q.pop_front();
		for(int i=head[u];i;i=next[i]){
			v=ver[i];
			e=w[i];
			if(d[v]>d[u]+e){
				d[v]=d[u]+e;
				if(e)
					q.push_back(v);
				else
					q.push_front(v);
			}
		}
	}
	int ans=d[ed]==0x3f3f3f3f?-1:d[ed];
	cout<<ans;
}
```


---

## 作者：cecilia_sankta (赞：1)

蒟蒻tyq一看：这不最短路吗

大佬：是，但是如果加强为$\sum_{i=1}^{n} K*N<=1e7$呢

蒟蒻tyq：我不会。。。自闭了。。。

大佬：这不就一个裸的01-bfs吗？切了切了

蒟蒻tyq便狂搜教程，终于发现：

首先，SPFA在边权非负时也可以维护小根堆来保证O(NlogM)的时间复杂度

当然边权为0/1时也不例外

但是真的要维护小根堆吗？其实不用，因为边权为0/1，所以说扩展时边权为0就从队尾入队，边权为1是从队头入队即可

可能语言比较抽象，看代码吧。。

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std ;
int head[100005] , Next[100005] , ver[100005] , edge[100005] , dist[100005] ;
deque<int> Q ; //双端队列 
int inq[100005] ;
int n , s , t , tot ;
 
//加边（链式前向星） 
void add(int x , int y , int z){
	edge[++tot] = z , Next[tot] = head[x] , ver[tot] = y , head[x] = tot ;
}

//更新距离的函数 
void update(int u){
	for(int i = head[u] ; i ; i = Next[i]){
		//cout<<"visit "<<ver[i]<<endl ;
		int v = ver[i] , wei = edge[i] ;
		if(dist[v] > dist[u]+wei){
			dist[v] = dist[u]+wei ;
			if(!inq[v]){
				if(wei==0) Q.push_front(v) ; 
				else Q.push_back(v) ;
				inq[v] = 1 ;
			}
		}
	}
}

//一个BFS框架 
void spfa(int s){
	memset(inq , 0 , sizeof(inq)) ;
	memset(dist , 0x3f , sizeof(dist)) ; 
	Q.push_front(s) ; inq[s] = 1 ; dist[s] = 0 ;
	while(!Q.empty()){
		int u = Q.front() ; Q.pop_front() ;
		//cout<<"u="<<u<<" && inq["<<u<<"]="<<inq[u]<<endl ;
		update(u) ;
	}
}

//快读 
char ch ; int flg ;
void read(int& x){
	ch = ' ' ; x = 0 ; flg = 1 ;
	while(!isdigit(ch)){
		ch = getchar() ; 
		//if(ch=='-'){flg = -1 ;}
	}
	while(isdigit(ch)){
		x = x*10 + (ch ^ 48) ; ch = getchar() ;
	}
}

//输出 
void output(int d){
	if(dist[d] == 0x3f3f3f3f) cout<<"-1"<<endl ;
	else cout<<dist[d]<<endl ;
}


int main(){
	read(n) , read(s) , read(t) ;
	for(int i = 1 ; i <= n ; ++i){
		int k , fir , temp ; read(k) ;
		if(k==0) continue ;
		read(fir) , add(i , fir , 0) ;
		for(int j = 2 ; j <= k ; ++j){
			read(temp) , add(i , temp , 1) ;
		}
	}
	spfa(s) ; output(t) ;
}

//30ms , 不知道那些0ms的是怎么回事。。
//感觉没有比这个算法时间复杂度更优的吧。。
//O(N+M) 
```

---

## 作者：耗纸大大 (赞：1)

### 本题只要理解就明白了 这其实一道有向图最短路问题裸题

因为我以前主dijstra的 顺便拿这道练了spfa

没用stl进行优化

纯手工模拟spfa 233

\* 首先是这道题建边时候 第一个点跟原点构图 权值为0 后面的点为1就ok了

为什么呢？因为你第一个点，是不需要开关的，而后几个点需要动开关，并且只能动一次，所以每次动的点不一样。

*** 不会告诉你我一开始 理解错了 理解成输入点构图权值为1 未输入点为0 结果只过了2个点 并且忘记加特判输出-1 2333 ***

\* 第二这道题是有向图

\* 前向星存图时候记得开值是边数不是点数 一开始打的时候忘记相乘了 结果发现输不进数据

#### 下面是两种代码：

1. spfa(未优化)：

’
```cpp
#include<iostream>
#include<cstdio>
#define maxn 110
#define INF 0x7f
using namespace std;
struct edge{
    int next;
    int to;
    int dis;
}edge[maxn*maxn];
int head[maxn],q[maxn],inq[maxn],dis[maxn],vis[maxn];
int n,s,z,num,h,t,k;
inline int lop(int &x){x++;if(x==maxn*2) x=1;}
void add_edge(int u,int v,int w)
{
    num++;
    edge[num].next=head[u];
    edge[num].to=v;
    edge[num].dis=w;
    head[u]=num;
}
void spfa(int v0)
{
    for(int i=1;i<=n;i++) dis[i]=INF;
    h=t=1;
    q[h]=v0;
    inq[v0]=1;
    t++;
    dis[v0]=0;
    while(t!=h)
    {
        int u=q[h];
        inq[u]=0;
        lop(h);
        for(int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            int w=edge[i].dis;
            if(dis[v]>dis[u]+w) 
            {
                dis[v]=dis[u]+w;
                if(!inq[v])
                {
                    inq[v]=1;
                    q[t]=v;
                    lop(t);
                }
            }            
        }
    }
}
int main()
{
    cin>>n>>s>>z;
    for(int i=1;i<=n;i++)
    {
        cin>>k;
        for(int j=1;j<=k;j++)
        {
            int xx;
            cin>>xx;
            if(j==1)
            add_edge(i,xx,0);
            else
            add_edge(i,xx,1);
        }
    }
    spfa(s);
    if(dis[z]!=INF)
    cout<<dis[z]<<endl;
    else
    cout<<"-1"<<endl;
    return 0;
}
```
‘
2.dijstra+堆优化：

’
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define maxn 110
#define INF 0x7f
using namespace std;
struct edge{
    int next;
    int to;
    int dis;
}edge[maxn*maxn];
int head[maxn],dis[maxn],vis[maxn];
int n,s,z,num,h,t,k;
inline int lop(int &x){x++;if(x==maxn*2) x=1;}
void add_edge(int u,int v,int w)
{
    num++;
    edge[num].next=head[u];
    edge[num].to=v;
    edge[num].dis=w;
    head[u]=num;
}
struct Node{
    int d,id;
    Node(){}
    Node(int d,int id):d(d),id(id){}
    bool operator < (const Node& sph)const {       
           return d>sph.d;
    }
 };
void dijstra(int v0)
{
     for(int i=1;i<=n;i++) dis[i]=INF;
     dis[v0]=0;
     priority_queue<Node>q;
     q.push(Node(0,v0));
     while(!q.empty())
     {
         Node u=q.top();
        q.pop();
         if(vis[u.id]) continue;  
        vis[u.id]=1;
         for(int i=head[u.id];i;i=edge[i].next)
         {
             int v=edge[i].to;
             int w=edge[i].dis;
             if(dis[v]>w+u.d) 
               {
                 dis[v]=w+u.d;
                 q.push(Node(dis[v],v));
               }    
         }
     }
}
int main()
{
    cin>>n>>s>>z;
    for(int i=1;i<=n;i++)
    {
        cin>>k;
        for(int j=1;j<=k;j++)
        {
            int xx;
            cin>>xx;
            if(j==1)
            add_edge(i,xx,0);
            else
            add_edge(i,xx,1);
        }
    }
    dijstra(s);
    if(dis[z]!=INF)
    cout<<dis[z]<<endl;
    else
    cout<<"-1"<<endl;
    return 0;
}
‘
```

---

## 作者：hsfzLZH1 (赞：1)

此题要求的是一个边权只可能为1或0的有向图上的最短路。

如何加边：如果节点u是从节点i开始的第一个到达的节点，那么边权为0，否则边权为1

如何存边：本篇题解通过边表（前向星）存边，优点：遍历所有出度节点速度快，速度比O2优化前的vector不知道好到哪里去了，空间开销小（相对而言）

如何计算最短路：本篇题解用SPFA算法计算单源最短路，时间复杂度O(me)（m<=2\*n）（仅队列优化后），随机图实践性很好

接下来的部分重点介绍SPFA算法：定义dist[i]为节点s（固定）到节点i的目前计算出的最短路径估计值，设立一个queue用来表示待优化的节点，每次把队首的节点x取出，对所有x的出边连向的节点y进行松弛操作，如果到y点的dist发生了改变，那么就将y点加入队尾，这样直到队列空为止。

算法的证明（不太严谨）：只要最短路径存在，那么一定可以求出最短路径的长度。在队列中的节点，除了一开始加入的节点s外，所有节点都是通过松弛操作加入的。每次松弛操作都会使dist[]的值减小。所以，如果最短路径是存在着的，那么一定不会无休止的更新，队列最后一定是空的。可以保证这样求出的dist数组一定是最短的路径。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=20010;
const int inf=2147483647;
int n,s,t,k,u,cur=0,x,j;
int head[maxn],next_[maxn],point[maxn],weight[maxn],dist[maxn];
bool visit[maxn];
queue<int>spfa;
inline void add_edge(int u,int v,int w)
{
    cur++;
    next_[cur]=head[u];
    head[u]=cur;
    point[cur]=v;
    weight[cur]=w;
}//边表存边
int main()
{
    scanf("%d%d%d",&n,&s,&t);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&k);
        if(k&&k--)scanf("%d",&u),add_edge(i,u,0);//这个加边格式需要特别注意，因为k可能等于0，我之前的程序就是这样卡爆的
        while(k--)scanf("%d",&u),add_edge(i,u,1);//之后的加边就很正常了
    }
    for(int i=1;i<=n;i++)dist[i]=inf;//一开始设置初始值
    dist[s]=0;spfa.push(s);visit[s]=true;//将s插入队列，s到自己的路程肯定是0，并设置为已访问
    while(!spfa.empty())///队列非空
    {
        x=spfa.front();j=head[x];//取队列头
        while(j)//访问所有出边连向的点
        {
            if(dist[point[j]]>dist[x]+weight[j])//松弛操作条件
            {
                dist[point[j]]=dist[x]+weight[j];
                if(!visit[point[j]])spfa.push(point[j]),visit[point[j]]=true;//插入point[j]节点
            }
            j=next_[j];//下一个出边
        }
        visit[x]=false;
        spfa.pop();//弹出队列
    }
    if(dist[t]==inf)printf("-1\n");//如果没有改变过dist[t]的值，就是没有通路，输出-1
    else printf("%d\n",dist[t]);
    return 0;
}
```

---

## 作者：小黑 (赞：1)

构图很简单，需要切开关的边权值为1，不需要的（默认指向的边）权值为0

数据本身就是无向图，所以不需要做特殊处理

然后求最短路就AC了




```cpp
const
  inf=100;
var
  map:array[1..110,1..110] of integer;
  dis,bool:array[1..110] of integer;
  n,a,b,i,j,k,ki,min:integer;
function opr(x:integer):integer;
  begin
    if x=1 then exit(0)
    else exit(1);
  end;
begin
  read(n,a,b);
  for i:=1 to n do
    for j:=1 to n do
      map[i,j]:=inf;
  for i:=1 to n do
    begin
      read(k);
      for j:=1 to k do
        begin
          read(ki);
          map[i,ki]:=opr(j);
        end;
    end;
  for i:=1 to n do dis[i]:=map[a,i];
  for i:=1 to n do bool[i]:=0;
  bool[a]:=1;
  for i:=1 to n-1 do
    begin
      min:=maxint;k:=0;
      for j:=1 to n do
        if (dis[j]<min) and (bool[j]=0) then
          begin
            min:=dis[j];
            k:=j;
          end;
      if k=0 then break;
      bool[k]:=1;
      for j:=1 to n do
        if (dis[k]+map[k,j]<dis[j]) and (bool[j]=0) then
          dis[j]:=dis[k]+map[k,j];
    end;
  if dis[b]=inf then writeln(-1)
  else writeln(dis[b]);
end.
```

---

## 作者：望眼浮云 (赞：1)

~~切紫题切累了，所以切了道黄题~~

好吧其实因为spfa学得太烂了来找自信的

先建图：

因为开关默认指向第一个数字表示的轨道，所以连一条权值为0的边，后面的点均连权值为1的边。

注意：连边均为单向边

剩下的就交给SPFA了

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<string>
using namespace std;
const int inf=1e9+7;
struct node
{
    int next,to,w;
}a[1000000];
int head[1000000],vis[1000000],q[1000000],dis[1000000];
int n,k,i,j,l,r,s,t,x,y,cnt;
void add(int x,int y,int z)
{
    cnt++;
    a[cnt].next=head[x];
    a[cnt].to=y;
    a[cnt].w=z;
    head[x]=cnt;
}
int main(){
    scanf("%d %d %d",&n,&s,&t);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&k);
        for(j=1;j<=k;j++)
        {
            scanf("%d",&y);
            if(j==1) add(i,y,0); //第一个点，连边权值为0
            else add(i,y,1);	 //后面的点，连边权值为1
        }
    }
    for(i=1;i<=1000001;i++)  //SPFA大法好
		dis[i]=inf;
    l=0;r=1;
    dis[s]=0;q[1]=s;
    while(l<r)
    {
        l++;
        x=q[l];vis[x]=0;
        for(i=head[x];i;i=a[i].next)
        {
            int y=a[i].to;
            if(dis[y]>dis[x]+a[i].w)
            {
                dis[y]=dis[x]+a[i].w;
                if(!vis[y])
                {
                    vis[y]=1;
                    r++;
                    q[r]=y;
                }
            }
        }
    }
    if(dis[t]==inf) printf("-1");
    else printf("%d",dis[t]);
}
```

---

## 作者：zhaowangji (赞：0)

最重要的事情是读题！
切换开关的状态后，它会自动复原~~我也不知道这是什么鬼开关~~

把每个节点看作是点，轨道看作是边。转换一次开关状态看作边权为1。由于题中n的范围是100，所以可以用最暴力好写的Floyd算法


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,e;//end是保留字
int d[107][107];//存图
int main(){
    cin>>n>>s>>e;
    memset(d,0x3f,sizeof(d));
    for(int i=1;i<=n;++i)d[i][i]=0;//记得这一步，自己到自己的距离为0
    for(int i=1;i<=n;++i){
        int x;//即Ki，轨道数
        cin>>x;
        for(int j=1;j<=x;++j){
            int y;
            cin>>y;//另一端的路口
            if(j==1)d[i][y]=0;//单行道。因为开关都是控制着“出去的道路”。而且本题中是出发去目的地，再回来没有意义。
            else d[i][y]=1;//这里两处手残把i打成了x
        }
    }
    for(int k=1;k<=n;++k)//k记得写在最外面
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    d[i][j]=min(d[i][j],d[i][k]+d[k][j]);//Floyd
    if(d[s][e]>=0x3f3f3f3f)cout<<-1<<endl;//中途某边其实是不存在的（边权为0x3f3f3f3f，因为memset按字节赋值）
    else cout<<d[s][e]<<endl;//可以到达
    return 0;
}
```


---

## 作者：盧鋅 (赞：0)

# ~~很明显这道题并不难~~

### 这道题的考点大概就是建立邻接**矩阵**or**表**

~~很明显建矩阵我是不会的~~
```cpp
 	for(re ll u=1;u<=n;u++)
 	{
 		ll r=read();
 		for(re ll w=0;w<r;w++)
 		{
 			ll v=read();
 			if(w==0)add(u,v,0);
			else add(u,v,1);
		 }
	 }
```
#### 根据题意现对每个点u读，然后读入这个点有几r个边，默认第一条边花费w为0，其他边为1；
##### 很明显这就是只要一个模板的问题了
 
####  _Dijkstra_  or  _SPFA_ 
------------

######   _~~先放模板~~_ 
 ```cpp
void SPFA(ll s){
	queue<ll>q;
	q.push(s);vis[s]=1;dis[s]=0;
	while(!q.empty())
	{
		ll r=q.front();
		for(ll k=first[r];k>0;k=e[k].next)
		{
			if(dis[e[k].v]>dis[r]+e[k].w)
			{
				dis[e[k].v]=dis[r]+e[k].w;
				if(!vis[e[k].v])
				{
					q.push(e[k].v);
					vis[e[k].v]=1;
				}
			}
		}
		vis[r]=0;
		q.pop();
	}
}
```
------------
```cpp
void DIJ(ll s){
	priority_queue< pair<ll,ll> > q;
	memset(vis,0,sizeof(vis));
	for(ll i=1;i<=n;i++)dis[i]=inf;
	dis[s]=0;
    q.push(M(0,s));
	while(!q.empty())
	{
		ll u=q.top().second;
		q.pop();
		if(vis[u])continue;vis[u]=1;
		for(ll i=first[u];i>0;i=e[i].next){
			ll v=e[i].v;
			if(dis[u]+e[i].w<dis[v]){
				dis[v]=dis[u]+e[i].w;
				if(!vis[v])q.push(M(-dis[v],v));
			}
		}
	}
}
```
------------
### 把他们结合起来那不就过了吗？？？？？？
还是放下AC的代码吧（**内含个人的某些编程习惯**）
```
#include<cctype>//isdigit()
#include<cstdio>//getchar()
#include<cstdlib>//很明显没用
#include<cstring>//memset()
#include<algorithm>
#include<queue>//priority_queue
#include<iostream>
#include<stack>
#define inf 0x7ffffffffffffff
#define M(x,y) make_pair(x,y)//priority_queue
#define ll long long
#define re register
#define in inline
#define mian main 
#define maxn 20000
#define maxm 20000000
#define mod
using namespace std;
ll n,a,b,num,num_edge=0;
ll first[maxn],vis[maxn],dis[maxn];
struct edge{
	ll v,w,n;
}e[maxm];//v：指向的点；w：边权；n：下一条边
void add(ll u,ll v,ll w)
{
	ll k=++num_edge;
	e[k].n=first[u];
	first[u]=k;
	e[k].v=v;
	e[k].w=w;
}
in ll read()//快读
{
	ll x=0,y=0;char ch;
	while(!isdigit(ch)){if(ch=='-')y=1;ch=getchar();} 
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return y?-x:x; 
 } 
 in void init()//读入
 {
 	n=read();a=read();b=read();
 	memset(first,0,sizeof(first));
 	memset(vis,0,sizeof(vis));
 	for(re ll i=1;i<=n;i++)dis[i]=inf;
 	for(re ll u=1;u<=n;u++)
 	{
 		ll r=read();
 		for(re ll w=0;w<r;w++)
 		{
 			ll v=read();
 			if(w==0)add(u,v,w);
			else add(u,v,1);
		 }
	 }
 	return;
 }
 in void doit()//Dijkstra
 {
 	priority_queue<pair<ll,ll> >q;
 	dis[a]=0;q.push(M(0,a));
 	while(q.size())
 	{
 		ll u=q.top().second;q.pop();
 		if(vis[u])continue;vis[u]=1;
 		for(re ll i=first[u];i;i=e[i].n)
 		{
 			ll v=e[i].v;
 			if(dis[v]>dis[u]+e[i].w)
 			{
 				dis[v]=dis[u]+e[i].w;
 				q.push(M(-dis[v],v));
                //优先队列默认大根堆
			 }
		 }
	 }
 	return;
 }
 in void outit()//输出
 {
        if(dis[b]==inf)printf("-1");
 	else printf("%lld",dis[b]);
 	return;
 }
signed mian()
{
	init();
	doit();
	outit();
	return 0;
}
```

 _**为什么不用SPFA呢??**_ （手动滑稽）
~~Ag->Cu~~


---

## 作者：president (赞：0)

这题其实也可以说是最短路的裸题，只是要想一下如何记下切换开关的次数。

首先，第i个节点会连接k个节点，每个节点记为a[k]，道路最开是指向a[1]的，所以从i到a[1]不用切换的，所以将w记为0，之后的点将w记为1，就可以解决这个问题。剩下的就是跑最短路就好了。

注意，铁轨是有向边。

我用的是dij+堆优化，大家可以看一下。


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=205;
int n,head[N],tot,d[N],vis[N],s,t;
struct node{
	int next,to,w;
}a[N*N];
void add(int x,int y,int z)
{
	a[++tot].next=head[x];
	a[tot].to=y;
	a[tot].w=z;
	head[x]=tot;
}
priority_queue<pair<int,int> >q;
void dij(int s)
{
	memset(d,inf,sizeof(d));
	memset(vis,0,sizeof(vis));
	d[s]=0; q.push(make_pair(0,s));
	while(!q.empty())
	{
		int u=q.top().second; q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]>d[u]+a[i].w)
			{
				d[v]=d[u]+a[i].w;
				q.push(make_pair(-d[v],v));
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&s,&t);
	for(int i=1;i<=n;i++)
	{
		int k,a;
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			scanf("%d",&a);
			if(j==1) add(i,a,0);//将第一个到的节点的边权记为0；
			else add(i,a,1);
		}
	}
	dij(s);
	if(d[t]!=inf) printf("%d",d[t]);
	else printf("%d",-1);
	return 0;
}
```


---

## 作者：MXR612 (赞：0)

大致的前面大佬都有讲过，我这里就稍微抖个机灵用另一种方法存图。。。
（其实就是个假的拉链表）
Edge数组中，0存Ki，后面存通向的节点，这样通向E1的权值就是0，其余1

```cpp
// P1346

#include <iostream>
#include <cstring>
using namespace std;

int N, A, B;
short E[200][200];
int V[200];
bool U[200] = {false};

int get() {
	int res = 0;
	for (int i = 1; i <= N; i++) {
		if (!U[i] && V[i] <= V[res]) {
			res = i;
		}
	}
	return res;
}

int main() {
	freopen("P1346.in", "r", stdin);
	memset(V, 0x6f, sizeof(V));
	cin >> N >> A >> B;
	for (int i = 1; i <= N; i++) {
		cin >> E[i][0];
		for (int j = 1; j <= E[i][0]; j++) {
			cin >> E[i][j];
		}
	}
	V[A] = 0;
	for (int i = 1, now; i < N; i++) {
		now = get();
		if (E[now][0] > 0){
			V[E[now][1]] = min(V[E[now][1]], V[now]);
			for (int j = 2; j <= E[now][0]; j++) {
				V[E[now][j]] = min(V[E[now][j]], V[now] + 1);
			}
		}
		
		U[now] = true;
	}
	cout << ((V[B] == V[0]) ? -1 : V[B]);
	return 0;
}
```

代码AC，借鉴请自便（真的信我）

---

## 作者：Sober_Clever (赞：0)

dij最短路~~（好吧我知道bfs可能更好）~~

建图留点心就好

边的编号为1时，权值设成0

不为1时设成1
```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int MAXN=100 + 3;
const int INF=1<<30;

int read()//快读
{
	int x=0,w=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48; c=getchar();}
	return x*w;	
}

int n,s,e,g[MAXN][MAXN]={0};
int d[MAXN],vis[MAXN]={0};//d[i]表示从1到i所需的最少切换次数 
priority_queue<pair<int,int> > Q;
void dij() 
{
	for(int i=1;i<=n;i++) d[i]=INF;
	d[s]=0;
	Q.push(make_pair(-d[s],s));
	while(!Q.empty())
	{
		pair<int,int> p=Q.top();
		Q.pop();
		int u=p.second;
		if(vis[u]) continue;
		vis[u]=1;
		for(int v=1;v<=n;v++)
		{
			if(g[u][v]!=INF)
			{
				if(d[v]>d[u]+g[u][v])
				{
					d[v]=d[u]+g[u][v];
					Q.push(make_pair(-d[v],v));
				}
			}
		}
	}
}

int main()
{
	n=read(),s=read(),e=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			g[i][j]=(i==j)?0:INF;
	for(int i=1;i<=n;i++)
	{
		int k=read();
		for(int m=1;m<=k;m++)
		{
			int j=read();
			g[i][j]=(m==1)?0:1;//如果编号为1，则不用切换，故为0，其他为1 
		}
	}
	dij();
	if(d[e]==INF) printf("-1\n");
	else printf("%d\n",d[e]);
	return 0;	
} 
```


---

## 作者：KingBenQi (赞：0)

---
Solution
---
d[i][j]相当于i到j最少用的开关数
把d[][]的初始值赋的超级大,然后默认开关打成0,非默认开关打为1
跑一遍最短路就行了
```
#include<bits/stdc++.h>
const int INF=1e+8;
#define rg register
using namespace std;
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
int n,A,B,d[110][110];
int main(){	
    //freopen("elec.in","r",stdin);
    //freopen("elec.out","w",stdout);
    n=gi();A=gi();B=gi();
    int k,to;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			d[i][j]=INF;
	for(rg int i=1;i<=n;i++){
		k=gi();
		for(int j=1;j<=k;j++){
			to=gi();
			if(j==1) d[i][to]=0;
			else d[i][to]=1;
		}
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
	if(d[A][B]==INF) puts("-1");
    else  cout<<d[A][B]<<endl;
	return 0;
}

```

---

## 作者：q2368126021 (赞：0)

###本题是一道纯SPFA的题，只要把第一个点设为0，把剩余点权值设为1即可

    
         
    
    
         
    
```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n,begin,end;
struct pel**链式前向星**
{
    int to;
    int next;
    int dis;
};
int h[10000];
pel a[10000];
int num=0;
int add(int x,int y,int z)**建图函数**
{
    num++;
    a[num]=(pel){y,h[x],z};
    h[x]=num;
}
deque<int> que;
int dis[10000];
void SPFA()**走一遍SPFA**
{
    int i;
    dis[begin]=0;
    que.push_front(begin);**以起点开始**
    while(!que.empty())
     {
         int past=que.front();
         que.pop_front();
         for(i=h[past];i;i=a[i].next)
          {
           int now=a[i].to;
           if(dis[now]>dis[past]+a[i].dis)
            {
                dis[now]=dis[past]+a[i].dis;
                if(!que.empty()&&dis[now]<dis[que.front()])**SLF优化**
                 que.push_front(now);
                  else que.push_back(now);
           }    
         }
     }
}
int main()
{
   scanf("%d%d%d",&n,&begin,&end);    
    int i,j,x,many;
    for(i=1;i<=n;i++)
     {
         scanf("%d",&many);
         for(j=1;j<=many;j++)
          {
           scanf("%d",&x);    
           if(j==1)**当电车走第一条路时，则权值为0，当电车走其他路时，权值为1**
            add(i,x,0);
           else add(i,x,1);
         }
     }
    for(i=1;i<=n;i++)
     dis[i]=200000000;
    SPFA();
    if(dis[end]!=200000000)
     printf("%d",dis[end]);
     else printf("-1");
}
```

---

## 作者：sunyt (赞：0)

和底下的dalao们不大一样，我先想到的是BFS求最短路<蒟蒻Stock一枚>

显然我们是要找改变开关的最小次数，那么我就可以把初始开关指向的轨道标记为0权值，其余可达到的节点对应轨道权值标记为1，剩下的不通的自己看着办变成一个MAX就行。

因为数据范围较小[2,100]，所以就可以大胆的用空间，存储方法可以效仿下面的代码。


##BFS核心代码：##



```cpp
void bfs()
{
    mov[0]=st,now[st]=0;
    int head=0,tail=1;
    while(head<=tail&&tail<80500)
    {
        poi=road[mov[head]][1];
        now[poi]=min(now[mov[head]],now[poi]);
        mov[tail]=poi;
        tail++;
        for(j=2;j<=k[mov[head]];j++)
        {
        poi=road[mov[head]][j];
        mov[tail]=poi;
        now[poi]=min(now[mov[head]]+1,now[poi]);
        tail++;
        if(poi==en)
        {tail--;mov[tail]=0;}
        }
        if(!now[en])return;
        head++;
    }
}
```
##存储方法：##
```cpp
    for(i=1;i<=n;i++)
    {
        cin>>k[i];
        if(k[i])
        {
        cin>>x;
        road[i][1]=x;
        for(j=2;j<=k[i];j++)
        {cin>>x;
        road[i][j]=x;}}
    }
```
##最终输出判断（特判啊啊啊）##
```cpp
    if(now[en]!=2139062143)//MAX表示不可用
    cout<<now[en];
    else
    cout<<-1;//注意-1的特判，没有特判应该是#8过不了吧。。。
如果还有问题，还请求dalao指点一下orz。。。
```

---

## 作者：约修亚_RK (赞：0)

那我就来个dijkstra的解法吧orz

说实话这题n<=100实在是太水了...膜一下顶楼的DFS...

数据直接就是一个无向图，甚至不需要手动存两遍.

每次取出一个点进行遍历的时候，当访问的是第一个点（也就是数据中第一个输入的点）时，权值为0，除此以外权值为1。之所以可以这么搞，是因为每个点最多就访问一次，所以每个路口也最多变更一次状态。

所以这也就差不多是个裸的最短路了orz


```cpp
/* P1346
 * Au: SJoshua
 */
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>

using namespace std;

struct edge {
    int u, v;
} edges[20000];

struct node {
    int u, d; 
    bool operator < (const node &n) const {
        return d > n.d;
    }
};

vector <int> mp[101];
priority_queue <node> q;

bool visited[101];
int dis[101];

int main(void) {
    int n, a, b, links, p = 0;
    scanf("%d %d %d", &n, &a, &b);
    for (int k = 1; k <= n; k++) {
        scanf("%d", &links);
        for (int i = 0; i < links; i++) {
            scanf("%d", &edges[p].v);
            edges[p].u = k;
            mp[k].push_back(p++); 
        }
    }
    memset(dis, 0x3f, sizeof(dis));
    q.push((node){a});
    while (!q.empty()) {
        node t = q.top();
        q.pop();
        if (visited[t.u]) {
            continue;
        }
        visited[t.u] = true;
        for (unsigned int k = 0; k < mp[t.u].size(); k++) {
            edge &e = edges[mp[t.u][k]];
            if (t.d + (k != 0) < dis[e.v]) {
                q.push((node){e.v, dis[e.v] = t.d + (k != 0)});
            }
        }
    }
    printf("%d", dis[b] == 0x3f3f3f3f ? -1 : dis[b]);
    return 0; 
} 
```

---

## 作者：intruder (赞：0)

今天好不在状态 这没简单的题各种无语

很简单 spfa 如果是直接可以到的话权值为0否则为0，实在不知道还能怎么讲了

今天太迷了




```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int n,A,B,d[105],vis[105];
vector<int >g[10500];
vector<int >v[10500];
queue<int>q;
void spfa(){
    d[A]=0;
    vis[A]=1;
    q.push(A);
    while(!q.empty()){
        int u=q.front();
        vis[u]=0;
        q.pop() ;
        for(int i=0;i<g[u].size();i++){
            int t=g[u][i];
            int c=v[u][i];
            if(d[t]>d[u]+c){
                d[t]=d[u]+c;
                if(!vis[t]){
                    q.push(t); 
                }
            }
        }
    } 
}
int main(){
    scanf("%d%d%d",&n,&A,&B);
    for(int i=1;i<=n;i++)d[i]=1e9;
    for(int i=1;i<=n;i++){
        int x;
        scanf("%d",&x);
        for(int j=1;j<=x;j++){
            int y;
            scanf("%d",&y);
            if(y==i)continue;
            g[i].push_back(y);
            if(j==1)v[i].push_back(0);
            else v[i].push_back(1); 
        }
    }
    spfa();
    if(d[B]==1e9)printf("%d",-1);
    else{
        printf("%d",d[B]);
    }
    return 0;
}

```

---

## 作者：QWsin (赞：0)

**
madan  本来想打dfs暴力= =

结果只能过50  而且有一个点是WA了QAQ

然后我发现这是一个极其傻逼的用Floyd都能过的水题

只是在题意理解上出了点问题= =我以为是要按顺序来

比如说有一个车站是  3  1 2 3

那么我就以为换到3要换两次。。。。。  结果只要一次-> ->

我语文不好  就这样吧

换上Floyd之后代码非常简洁

**
```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define rep(x) for(int x=1;x<=n;x++)
using namespace std;
const int maxn=100+10;
const int INF =(1<<30);

int d[maxn][maxn];
int n,s,t;

void Floyd()
{
    for(int k=1;k<=n;k++)
      for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
          if(d[i][k]!=INF&&d[k][j]!=INF)
            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
}

int main()
{
    cin>>n>>s>>t;
    rep(i) rep(j) d[i][j]=INF;
    for(int u=1,tmp;u<=n;u++)
    {
        scanf("%d",&tmp);
        for(int j=1,v;j<=tmp;j++)
        {
            scanf("%d",&v);
            d[u][v]=(j==1?0:1);
        }
    }
    Floyd();
    printf("%d",d[s][t]==INF?-1:d[s][t]);
    return 0;
}


```

---

## 作者：阿苏勒 (赞：0)

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int path[105][105],dist[105],vi[110],n;//dist到起点的最小距离 vi走过 
void dijkstra(int u)//dijkstra算法 http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html
{    vi[u]=1;
     dist[u]=0;
     for(int i=1;i<=n;i++)
        if(path[u][i]!=-1)
          dist[i]=path[u][i];
     for(int i=1;i<=n;i++)
        {    int v=109;
             for(int j=1;j<=n;j++)
               if(vi[j]==-1&&dist[j]<dist[v])
                 v=j;
             vi[v]=1;
             for(int l=1;l<=n;l++)
                if(vi[l]==-1&&path[v][l]!=-1)
                  {dist[l]=min(dist[l],dist[v]+path[v][l]);
                  };
        }
}
int main()
{   int a,b;
    dist[109]=1000;
    cin>>n>>a>>b;
    memset(path,255,sizeof(path));
    memset(dist,1,sizeof(dist));
    memset(vi,255,sizeof(vi));
    for(int i=1;i<=n;i++)
       {int k,v;
        cin>>k;
        for(int j=0;j<k;j++)
           {if(j==0)
              {cin>>v;
               path[i][v]=0;//注意这是有向图，写成无向只得50 
              
              }
            else {cin>>v;
                  path[i][v]=1;
                  
            };
              
           };
       };
    dijkstra(a);
    if(dist[b]>200)cout<<"-1"<<endl;
    else cout<<dist[b]<<endl;
    return 0;
} 
```

---

## 作者：cxy004 (赞：0)

DFS即可

```cpp
void search(int m,int s)
{
    if(s>=ans) return; //优化
    if(m==b) {ans=s;return;} //目标状态
    t[m]=true; //标记
    if(!t[f[m][1]]) search(f[m][1],s);
    for(int i=2;i<=f[m][0];++i) if(!t[f[m][i]]) search(f[m][i],s+1);
    t[m]=false; //还原
}
```

---


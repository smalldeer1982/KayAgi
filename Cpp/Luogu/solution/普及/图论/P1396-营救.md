# 营救

## 题目背景

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

## 题目描述

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 $t$ 区，而自己在 $s$ 区。

该市有 $m$ 条大道连接 $n$ 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 $s$ 至 $t$ 的路线，使得经过道路的拥挤度最大值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $60\%$ 的数据，保证 $n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m \leq 2 \times 10^4$，$w \leq 10^4$，$1 \leq s, t \leq n$。且从 $s$ 出发一定能到达 $t$ 区。

--- 

#### 样例输入输出 1 解释

小明的妈妈要从 $1$ 号点去 $3$ 号点，最优路线为 $1$->$2$->$3$。

## 样例 #1

### 输入

```
3 3 1 3
1 2 2
2 3 1
1 3 3```

### 输出

```
2
```

# 题解

## 作者：lzk5627 (赞：173)

都是打**最短路**或是**克鲁斯卡尔重构树**的吗??!!

我原本也想打一个**克鲁斯卡尔重构树**水过去,但后来发现~~完全没必要那么麻烦~~,一个**克鲁斯卡尔最小生成树**就可以水过去了

将边从小到大排序,然后克鲁斯卡尔最小生成树连边,这样当S和T第一次联通时,当前边的权值就是答案了.
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s,t,a[20001];
struct each
{
    int x,y,cost;
}b[20001];//存边
bool com(each x,each y)
{
    return x.cost<y.cost;
}
int read()//读入优化模板
{
    char ch=getchar();
    int x=0,f=1;
    while(ch<'0'||ch>'9')
        {
        if(ch=='-')
            f=-1;
        ch=getchar();
        }
    while(ch>='0'&&ch<='9')
        {
        x=x*10+ch-'0';
        ch=getchar();
        }
    return x*f;
}
int find(int x)//并查集基本操作
{
    if(a[x]==0)
        return x;
    a[x]=find(a[x]);
    return a[x];
}
int main()
{
    n=read();
    m=read();
    s=read();
    t=read();
    for(int i=1;i<=m;i++)//无脑输入
        {
        b[i].x=read();
        b[i].y=read();
        b[i].cost=read();
        }
    sort(b+1,b+m+1,com);//排序
    for(int i=1;i<=m;i++)//克鲁斯卡尔最小生成树连边
        {
        int X=find(b[i].x),Y=find(b[i].y);
        if(X!=Y)
            a[X]=Y;
        if(find(s)==find(t))//如果联通直接输出退出
            {
            cout<<b[i].cost<<endl;
            return 0;
            }
        }
    return 0;
}
```

---

## 作者：薄荷凉了夏 (赞：65)

## 看了楼下各位大佬的题解，发现大佬都是用的时间复杂度有点玄学SPFA，所以本蒟蒻就~~毫不犹豫~~的写了一个dijkstra+堆优化的程序。


### 然后看本题，其实个人认为和最短路意义上还是有区别的，因为题目是求可达终点的所有经过路径中最长的一段边权的最小值，所以它不一定要在s到t最短路上。所以裸的最短路板子肯定不行（ _**亲测0分**_  ）
# 但是 
### 我们仔细思考一下，对于任意一个点，到它的最大拥挤度的最小值肯定是 
##  与它相邻的一个点的此值和他们之间的边权值取一个max，然后在所有max中取一个min！
### 这样我们就可以想到只要把板子里的松弛稍微修改一下，即只需把原本的求和改为取max就ok了！ 
### 另，注意此题应构无向图！！
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi() {
    int x=0,w=0;char ch=0;
    while(!(ch>='0'&&ch<='9')) {
        if(ch=='-') w=1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return w?-x:x;
}				//读入优化
const int maxn=3e5+1;
const int maxm=1e5+1;
priority_queue< pair<int,int> > q；//大根堆（后变小根堆）
int n,m,s,t,head[maxm],tot,dis[maxm],vis[maxm];
struct Edge {
	int next,now,w;
}edge[maxn];		
void make(int from,int to,int t) {
	edge[++tot].next=head[from];
	edge[tot].now=to;
	edge[tot].w=t;
	head[from]=tot;
}					//链式前向星存图
void dijkstra() {
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty()) {
		int x=q.top().second; q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=edge[i].next) {
			int k=max(dis[x],edge[i].w),r=edge[i].now;
            //取max而不取和
				if(k<dis[r]) {
					dis[r]=k;
					q.push(make_pair(-dis[r],r)); 
                    //取一个负就可以变为小根堆！！
				}
		}
	}

}
int main()
{
	n=gi(); m=gi(); s=gi(); t=gi();
	for(int i=1,x,y,z;i<=m;i++) {
		x=gi(); y=gi(); z=gi();
		make(x,y,z);
		make(y,x,z);
        //构无向图
	}
	dijkstra();
	printf("%d",dis[t]);
	return 0;
}

```

---

## 作者：Orion_Rigel (赞：63)

二分+bfs水过。洛谷的香港记者就是快。

···
```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <queue>
#include <iostream>
#include <algorithm>
using namespace std;
int h[50001],ne[50001],w[50001],to[50001],en=0;
int n,m,S,T;
int dis[10001];
inline void add(int a,int b,int c)
{ne[en]=h[a];w[en]=c;to[en]=b;h[a]=en++;}
inline bool SPFA(int mid)
{
    memset(dis,0x3f,sizeof dis);
    queue<int>q;
    q.push(S);
    dis[S]=1;
    while (!q.empty())
    {
        int x=q.front();q.pop();
        for (int i=h[x];i>=0;i=ne[i])
        if (w[i]<=mid){
            if (dis[to[i]]==0x3f3f3f3f)
            {
                dis[to[i]]=1;
                q.push(to[i]);
            }
        }
    }
    if (dis[T]==0x3f3f3f3f) return false;
    else return true;
}
int main()
{
    memset(h,-1,sizeof h);
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for (int i=1;i<=m;++i)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    int l=0,r=10000;
    while (l<r)
    {
        int mid=(l+r)/2;
        if (SPFA(mid)) r=mid;
        else l=mid+1;
    }
    printf("%d\n",l);
}
···
```

---

## 作者：Awdrgysxc (赞：45)


这题其实就是叫我们求$s->t$ 的最短路中的最长边，可以用最小生成树来做，也可以用最短路算法来做，还可以用并查集+二分

好多人都写了最小生成树和最短路，蒟蒻就不重复了
### 【分析】
题目求经过道路的拥挤度最大值最小。我们可以考虑二分。我们就分距离。

L = （边的最小值） R = （边的最大值）

于是我们可以得到
```cpp
while(l <= r)
{
    mid = (l +r) >> 1;
    if(check(mid)) ans = mid,r = mid - 1;
    else l = mid + 1;
}
```

现在的问题就是check函数怎么写

我们可以这样写：如果用权值小于等于mid的边能到达t，return 1;

else return 0;

看到有人在check里跑最短路，但是蒟蒻觉得不用，只有将权值小于等于mid的边的量个点合并起来，最后再用并查集判一下
```cpp
inline bool check(int x)
{
    for(register int i = 1;i <= n; i++) fa[i] = i;
    for(int i = 1;i <= m; i++) if(val[i] <= x) H_(u[i],go[i]);
    //合并
    return judge(a,b);
   //用并查集判一下
}
```

### 【代码】
```cpp
#include <cstdio>
#include <algorithm>
#define min(x,y)(x<y?x:y)
#define max(x,y)(x>y?x:y)

using namespace std;

const int M = 10001;
const int INF = 999999;
int n,m,u[M<<1],go[M<<1],val[M<<1],ans;
int fa[M],a,b;
int l = INF,r,mid;

inline int read() {
    register int ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^'0'),c=getchar();
    return neg?-ans:ans;
}
//快读

inline int getfa(int x)
{
    if(fa[x] == x) return x;
    return fa[x] = getfa(fa[x]);
}
//并查集

inline bool judge(int x,int y) {
    if(getfa(x) != getfa(y)) return 0;
    return 1;
}
//并查集判断

inline void H_(int x,int y)
{
    if(getfa(x) != getfa(y)) fa[getfa(x)] = fa[getfa(y)];
}
//合并

inline bool check(int x)
{
    for(register int i = 1;i <= n; i++) fa[i] = i;
    for(int i = 1;i <= m; i++) if(val[i] <= x) H_(u[i],go[i]);
    //将权值小于等于mid的边的量个点合并
    return judge(a,b);
}


int main(void)
{
    n=read();m=read();a=read();b=read();
    for(register int i = 1;i <= m; i++)
    {
        u[i] = read();go[i] = read();val[i] = read();
        l = min(val[i],l); r = max(val[i],r);
    }
    //二分
    while(l <= r)
    {
        mid = (l + r) >> 1;
        if(check(mid)) ans = mid,r = mid - 1;
        else l = mid + 1;
    }
    printf("%d",ans);
    return 0;
}
```

最后再附上SPFA的代码
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
//char xB[1<<15],*xS=xB,*xT=xB;
//#define getchar() (xS==xT&&(xT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xT)?0:*xS++)

using namespace std;

const int M = 30001;
inline int read() {
    int ret;bool flag=0;char c;
    while((c=getchar())<'0'||c>'9')flag^=!(c^'-');ret=c^48;
    while((c=getchar())>='0'&&c<='9') ret=(ret<<3)+(ret<<1)+(c^48);
    return flag?-ret:ret;
}
//快读
queue <int> Q;
int fir[M>>1],nex[M],go[M],val[M];
int dis[M>>1],vis[M>>1];
int n,m,a,b,tot;

inline void add_edge(int x,int y,int z)
{
    nex[++tot] = fir[x],fir[x] = tot,go[tot] = y,val[tot] = z;
}
//前向星

int main(void)
{
    n = read();m = read();a = read();b = read();
    for(int i = 1;i <= m; i++)
    {
        int x,y,z;
        x = read();y = read();z = read();
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
    for(int i = 1;i <= n; i++) dis[i] = 1e9  + 7;
    dis[a] = 0;
    Q.push(a);
    vis[a] = 1;
    while(!Q.empty())
    {
        int Now = Q.front();
        Q.pop();
        int Go;
        vis[Now] = 0;
        for(int i = fir[Now];i,Go = go[i];i=nex[i])
        {
            if(dis[Go] > max(dis[Now],val[i]))
            {
                dis[Go] = max(dis[Now],val[i]);
                if(!vis[Go]) Q.push(Go),vis[Go]=1;
            }
        }
    }
    if(dis[b] == 1e9+7) dis[b] = -1;
    printf("%d",dis[b]);
    return 0;
}
```
SPFA相信大家都会了，就不加什么注释了



---

## 作者：kokodayou (赞：39)

## 解题背景：
距离CSP-S(AFO)还有5天！感觉自己把知识点毫无遗漏的还给了老师……

写篇最短路~~水题~~温习一下模板吧

当然，这道题对于最短路入门来说还是非常值得做的一道题

## 主要思路：
这道题要二分？重构树？并查集？NO！

虽然他们跑得快，但是我不会写啊！ 

虽然裸奔SPFA比较慢，但是能脚打呀！ 

萌新的福音，入门的宝典，图论的基础！  

为你打开邻接表存图的新世界！

当然盲打二分重构树的大佬可以绕路了…… 

## 邻接表存图：
```cpp

add(ll from,ll to,ll di)    //基本的邻接表存图 
{          //刚理解时感觉毁三观，打多了也就顺溜了 
	e[++cnt].next=head[from];  //next:兄弟，你从哪来？  head[]便是答案 
	e[cnt].to=to;      //to:兄弟，你要去哪？    to来解答 
	e[cnt].dis=di;     //dis:兄弟，路途多远？   di来解答 
	head[from]=cnt;    //cnt:兄弟，别忘回家！   head[]就记住了家的位置 
}
```
特别生动形象了吧（雾
## CODE


```cpp
//Written by  kokodayou
#include<bits/stdc++.h>
#define ll long long
#define R register int
#define AC return 0         //define大法好 
using namespace std;
ll he,ta=1,cnt,n,m,s,t,a,b,c,team[9876054],head[200000],f[200000];
bool pd[200000];
struct edge{
	ll next,to,dis;
}e[200000];
IL add(ll from,ll to,ll di)    //基本的邻接表存图 
{          //刚理解时感觉毁三观，打多了也就顺溜了 
	e[++cnt].next=head[from];  //next:兄弟，你从哪来？  head[]便是答案 
	e[cnt].to=to;      //to:兄弟，你要去哪？    to来解答 
	e[cnt].dis=di;     //dis:兄弟，路途多远？   di来解答 
	head[from]=cnt;    //cnt:兄弟，别忘回家！   head[]就记住了家的位置 
}
int main()
{
	cin>>n>>m>>s>>t;      //scanf跑的快，cin写得快 
	for(R i=1;i<=m;i++)
	{
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);         //双向存边噢！ 
	}
	for(R i=1;i<=n;i++)f[i]=1e9;
	f[s]=0;
	team[1]=s,pd[s]=1;
	do{          //SPFA板子部分，相信各位都会打 
		he++;
		ll x=team[he];
		pd[x]=0;       //出队，以后可能还用得着 
		for(R i=head[x];i;i=e[i].next)   //特别喜欢这个for循环，感觉特别巧妙…… 
		{
			ll y=e[i].to,dist=max(f[x],e[i].dis);  //因为是找最大拥挤值，所以比较出发点和边的权值 
			if(f[y]>dist)
			{
				f[y]=dist;
				if(!pd[y])         //在队列中的点千万不要入队，不然复杂度爆炸 
				{
					team[++ta]=y;
					pd[y]=1;
				}
			}
		}
	}while(he<ta);
	cout<<f[t];      //输出终点的最短路就好了呀 
	AC;              //AC优化（逃 
}
```
## 祝大家CSP   rp++！！！望管理员大大给过！！QWQ


---

## 作者：Dilute (赞：30)

## 令人智熄的二分操作

[AC记录](https://www.luogu.org/record/show?rid=6347426)

_要看正常的解法请看其他题解_

而且还蛮快的。。。

其实，这是非常奇葩的一个想法

总体思路就是：二分答案

你没听错，二分答案

我们从题面中可以看到，其实这道题的拥挤度也就$10000$而已，所以我们就会发现二分似乎可以？？？

存图存完之后直接二分，二分的$Check()$里面打一个$BFS$，来求能否通往终点，就好了

具体的东西就上代码来看吧

****

```cpp
#include<bits/stdc++.h> // 万能头文件 

using namespace std;
 
// 邻接表存图 
// 由于是无向图，所以这些数组要开大一倍，我就是这么被坑掉了10分 
int End[50100]; // End[i]表示第i条边的终点 
int Value[50100]; // Value[i]表示第i条边的边权 
int Next[50100]; // Next[i]表示第i条边的下一条边 
int Head[10100]; // Head[i]表示第i个点的第一条便
 
int q[50100]; // BFS的队列 
int n, m, s, t; // 如题意 
int qf, qe; // BFS队列的队首、队尾 
bool Used[10100]; // BFS，表示是否到过这个点 

bool Check(int x){
	memset(Used, false, sizeof(Used)); // 朴实无华的BFS 
	qf = qe = 1;
	q[1] = s;
	Used[s] = true;
	while(qf <= qe){
		int xx = Head[q[qf]];
		while(xx != -1){
			if(!Used[End[xx]] && Value[xx] <= x){ // 拓展 
				q[++qe] = End[xx];
				Used[End[xx]] = true;
			}
			xx = Next[xx]; 
		}
		qf++; // 出队 
	}
	return Used[t]; // 返回终点有没有到过 
}

int main(){
	memset(Next, -1, sizeof(Next));
	memset(Head, -1, sizeof(Head));
	scanf("%d %d %d %d", &n, &m, &s, &t);
	int r = 0;
	for(int i = 1; i <= m; i++){ // 读入、存图 
		int a, b, c;
		scanf("%d %d %d", &a, &b, &c);
		Value[i*2] = c;
		End[i*2] = b;
		Next[i*2] = Head[a];
		Head[a] = i*2;
		Value[i*2+1] = c; // 由于是无向图，所以要存两次 
		End[i*2+1] = a;
		Next[i*2+1] = Head[b];
		Head[b] = i*2+1;
		if(c > r)
			r = c; // 生成一个值等于所有最高拥挤度的r，方便二分 
	}
	// ------------读入完毕---------------
	// ------------二分开始--------------- 
	r++;
	int l = 1;
	while(l < r){ // 同样朴素的二分~~~ 
		int Mid = ((l+r) >> 1);
		if(Check(Mid))
			r = Mid;
		else l = Mid+1;
	}
	printf("%d", l);
}
```
****
_感谢 `学委` 对我的启发_

---

## 作者：「QQ红包」 (赞：28)

最开始以为是最短路径，但是发现拥挤度跟最短路并无卵关系。

这道题是最小生成树， prim和克鲁斯卡尔任意。

我用的是克鲁斯卡尔。

克鲁斯卡尔的话只要起点和终点在一个集合了，就输出最后进入集合的那条边的边权值。毕竟之前从小到大排序过了来着。

```cpp

/*
第一行四个数字n，m，s，t。
接下来m行，每行三个数字，分别表示两个区和拥挤度。
（有可能两个区之间有多条大道相连。)
输出格式：
输出题目要求的拥挤度。
*/
#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<string>
#include<math.h>
#include<time.h>
#include<vector>
#include<bitset>
#include<memory>
#include<utility>
#include<stdio.h>
#include<sstream>
#include<iostream>
#include<stdlib.h>
#include<string.h>
#include<algorithm> //一堆没用的头文件 
#define LL unsigned long long 
using namespace std; 
int n,m,s,t,i;
struct hhh
{
    int u,v,c;
}a[100000];
int f[20000];
int cmp(const hhh &a,const hhh &b)
{
    if(a.c<b.c) return 1;
        else return 0;
}
int gf(int x)//并查集找爸爸 
{
    if (f[x]==x) return x; else//如果爸爸是本身就返回自己 
    {
        return f[x]=gf(f[x]);//返回祖宗 
    }
}
void un(int x,int y)//合并 
{
    int xx=gf(x);//找x的祖宗 
    int yy=gf(y);//找y的祖宗 
    if (xx!=yy)//如果祖宗不同 
    {
        f[xx]=yy;//合并祖宗 
    }
    return;
}  
int main()
{
    scanf("%d %d %d %d",&n,&m,&s,&t);//n为城市数，m为边数，s为起点，t为终点
    for (i=1;i<=m;i++)
        scanf("%d %d %d",&a[i].u,&a[i].v,&a[i].c);
    sort(a+1,a+m+1,cmp);//边权值从小到大排序 
    int haha=0;int sum=0;
    for (i=1;i<=n;i++)//f数组初始化
    {
        f[i]=i;
    }
    for (i=1;i<=m&&haha<=n-1;i++)
    {
        if (gf(a[i].u)!=gf(a[i].v))//判断是否在集合内 
        {
            un(a[i].u,a[i].v);//合并 
            haha++;//每次将两个不同集合中的点合并，都将使haha值减1 
        }
        if (gf(s)==gf(t))//起点和终点在同一个集合。
        {
            cout<<a[i].c;
            return 0;
        }
    }
    return 0;
}

```

---

## 作者：曦行夜落 (赞：17)

由于我刚刚了解邻接链表（不信自己看学术版），所以这里发一发题解，顺便重新理一遍                                                
SPFA都应该了解，下面挂出框架                       
```
while 队列不为空
{
	取队首，队首出队
    枚举每一条边，如果起点为队首                                         
        对这条边进行一次松弛
        （也就是三角形不等式dist[s]=min(dist[t]+map[s][t],dist[s])）
        如果成功，入队
}
```
上面的是没有任何优化的朴素SPFA，显然，这种算法将有可能退化为BellmanFord                                      
这时，我们使用一个全新的图存储方式~~，其实也不新~~                 
可以发现，这个算法最危险的地方就是枚举每一条边，如果能够直接知道要松弛哪些边，该多好啊！                 
这时就轮到邻接链表出场了。接下来介绍几个重要数组。                    
head[i]：起点是i的第一条边（其实大部分时候是最后一条，但是一般从这个head[i]开始搜索）               
next[i]：表示第i条边同一起点的下一条边                             
to[i]：表示第i条边的终点
w[i]：表示第i条边的边权                     
研究完这些，离成功就不远了。首先看最重要的addedge函数                  
（注意是P，看得懂吧？）                            
```pascal
procedure addedge(u,v,w:longint);
begin
  inc(tot); //边数增加
  e[tot].too:=v; //设置终点为v
  e[tot].l:=w; //边权
  e[tot].nxt:=first[u]; //注意！将老的第一条边设置为新的的后继
  first[u]:=tot; //新的第一条边
end;
```                        
以上就是这个算法的精华，设队首为u，接下来——    
我们将SPFA中的枚举每一条边改为从head[u]开始，每次松弛，然后将u替换为next[u]，就可以啦！具体看代码吧                            
```pascal
var
  e:array[0..500050] of record //结构体e，存to，w和next
              too,l,nxt:longint;
            end;
  first,dist,q:array[0..500050] of longint; //head、dist、队列
  flag:array[0..500050] of boolean; //队列标记
  n,m,i,j,head,tail,s,t,f,g,w,p,tot:longint; //各种变量
  
function max(x,y:longint):longint; //max，用完cpp偶尔一次P觉得好麻烦
begin
  if (x>y) then exit(x); exit(y);
end;

procedure addedge(u,v,w:longint); //边的构造
begin
  inc(tot);
  e[tot].too:=v;
  e[tot].l:=w;
  e[tot].nxt:=first[u];
  first[u]:=tot;  
end;

begin
  readln(n,m,s,t);
  for i:=1 to m do first[i]:=-1; //没有下一条边
  
  tot:=0;
  for i:=1 to m do
    begin
      readln(f,g,w);
      addedge(f,g,w);
      addedge(g,f,w); //双向！
    end;

  for i:=1 to n do dist[i]:=maxlongint; //将dist设置为极大值
  dist[s]:=0; flag[s]:=true; q[1]:=s; //s入队列
  head:=1; tail:=1;

  while head<=tail do //while队列不为空
    begin
      p:=q[head]; inc(head); //出队
      flag[p]:=false;
      i:=first[p]; //找队首连出的边，首先是head[p]
      while i>-1 do //找所有的边直到没有下一条边
        begin
          if dist[e[i].too]>max(dist[p],e[i].l) then //如果可以松弛
            begin
              dist[e[i].too]:=max(dist[p],e[i].l); //松弛
              if not flag[e[i].too] then //入队列
                begin
                  inc(tail);
                  q[tail]:=e[i].too;
                  flag[e[i].too]:=true;
                end;
            end;
          i:=e[i].nxt; //下一条
        end;
    end;
  writeln(dist[t]);
end.
```                                          
有什么不足，欢迎拍砖

---

## 作者：Zijun_Xu (赞：15)


# 本题思路：
先把每条道路用拥挤度为第一关键字排序，从拥挤度最小的开始连，然后查S与T是否连通。如果不连通则继续连下一边。当恰好连通时，就是你连的最晚的一条边（显然最拥挤）最小。现在立刻输出答案，结束程序。 \

------------

 贴上 **Accepted** 代码：

```
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int x;
	int y;
	int t;
}a[222222];//x到y的边拥挤度t
int father[222222],n,m,s,t;
inline int find(int xx)//并查集
{
	while(xx!=father[xx])
	{
		xx=father[xx];//找祖先
	}
	return xx;
}
inline void unionn(int xx,int yy)//连接
{
	father[yy]=xx;
}
inline bool cmp(node p,node q)
{
	return p.t<q.t;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=0;i<=222221;i++)
	{
		father[i]=i;//假定祖先是自己
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].t);
	}
	sort(a+1,a+m+1,cmp);//拥挤度从小到大排序
	int tot=0,num=0;
	for(int i=1;i<=m;i++)
	{
		int cc=find(a[i].x),dd=find(a[i].y);
		unionn(cc,dd);
		if(find(s)==find(t))
		{
			printf("%d",a[i].t);
			return 0;
		}
	}
}
```
### 谢谢大家，祝大家好运

---

## 作者：Drinkkk (赞：13)

/\*
P1396 题解

最短路算法的应用


思路：

其实这道题就是最短路问题，用$SPFA$跑最短路即可。

但是注意了，这道题是求从$s$点到$e$点的路径所经过的所有可能的路径所经过的边权的最大值的最小值。

那么如何做最短路呢？

很显然，我们是将当前该边左边的最优解(即$a[x].q$)与边权作比较(即$b[i].c$)，取二者的最小值，再将其结果与该边右边的最优(即$a[y].q$)作比较，取最小值，那么在跑完一次最短路之后，答案就是$a[e].q$。

所以：$a[y].q=min(max(a[x].q,b[i].c),a[y].q);$

所以，代码与模板不同的地方如下：

```cpp
int now=max(a[x].q,b[i].c);
int y=b[i].y;
if(now<a[y].q)
{
    a[y].q=now;
}
```
下面上AC代码：
\*/
```cpp
#include <cstdio>
struct nodea{ int h,v,q; } a[1000001];
struct nodeb{ int x,y,c,g; } b[1000001];
int f[1000001],len=0,n=0,m=0,s=0,e=0;
int ans=999999999;
int max(int x,int y)
{
    return x>y?x:y;
}
void br(int x,int y,int c)
{
    len++;
    b[len].x=x;
    b[len].y=y;
    b[len].c=c;
    b[len].g=a[x].h;
    a[x].h=len;
}
void bfs()
{
    int tou=1,wei=2;
    f[1]=s;
    a[s].v=1;
    a[s].q=0;
    while(tou!=wei)
    {
        int x=f[tou];
        for(int i=a[x].h;i>0;i=b[i].g)
        {
            int now=max(a[x].q,b[i].c);
            int y=b[i].y;
            if(now<a[y].q)
            {
                a[y].q=now;
                if(a[y].v==0)
                {
                    a[y].v=1;
                    f[wei]=y;
                    wei++;
                    if(wei>n)
                    {
                        wei=1;
                    }
                }
            }
        }
        a[x].v=0;
        tou++;
        if(tou>n)
        {
            tou=1;
        }
    }
}
int main()
{
    scanf("%d %d %d %d",&n,&m,&s,&e);
    for(int i=1;i<=n;i++)
    {
        a[i].h=0;
        a[i].v=0;
        a[i].q=999999999;
    }
    for(int i=1;i<=m;i++)
    {
        int x=0,y=0,c=0;
        scanf("%d %d %d",&x,&y,&c);
        br(x,y,c),br(y,x,c);
    }
    bfs();
    printf("%d",a[e].q);
    return 0;
}
```

---

## 作者：星之海 (赞：8)

我来写一个题解  
本来做这道题目是想练一练最短路的  
可是我在做最短路的过程中发现这是一道  
**最小生成树  **  

普及一下最小生成树的算法：  
分为两种，一种是Prim，还有一种是Kruskal  
这里使用Kruskal算法（比较方便）  
下面是分析：  

因为本题是求最短路中的最大值的最小值是多少  
那么我们就可以求s到t的最短路中最小值中最大值是多少就可以了（有点绕人）  
所以我就想到了完美的Kruskal算法  
我们可以把求最小值的过程转化为跑一遍最小生成树的过程  
那么也就把问题转化为：在一个无向图中，求其最小生成树中权值最大的一条边是多少。  
也就是求一个图的最小瓶颈树  
好了，问题转化完毕。
______________________________________
接下来是怎么实现  
怎么求最小生成树的最大权（见洛谷OJ的P1547:Out of Hay）  
那么怎么求最小生成树的最大权呢  
很简单，我们只要在算最小生成树的时候保存一下当前的权与最大值的较大值就可以了
______________________________________
还有一件事  
怎样求s到t的最小生成树呢（怎样判定s与t已经连接取最大值了呢？）  

这个想一下就好了，因为Kruskal求生成树的过程是一点一点用并查集连接（并）的    
所以在第一次s与t这两个点连接时所得到的最大权值即为所求  
_______________________________________
~~解释完美结束~~

下面是美丽的代码：
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=20001;
struct save {
	int x,y,v;
} a[N];
int father[N];
int n,m,s,t,maxn=-0x7fffffff;
bool cmp(save m,save n) {
	return m.v<n.v;
}
int find(int x) {
	if(father[x]!=x)
		father[x]=find(father[x]);//路径压缩
	return father[x];
}
int main() {
	int i;
	cin>>n>>m>>s>>t;
	for(i=1; i<=n; i++)
		father[i]=i;
	for(i=1; i<=m; i++)
		cin>>a[i].x>>a[i].y>>a[i].v;
	sort(a+1,a+m+1,cmp);//按照权值排下序
	for(i=1; i<=m; i++) {
		int t1,t2;
		t1=find(a[i].x);
		t2=find(a[i].y);
		if(t1!=t2) {//如果不是一个祖先（需要连接）
			father[t1]=t2;
			if(find(s)==find(t)) {//如果s与t连接了
				maxn=max(maxn,a[i].v);//保存最大值
				break;//此时因为已经是答案了，所以直接跳出
			}
			else
			maxn=max(maxn,a[i].v);//保存最大值
		}
	}
	cout<<maxn<<endl;//输出最大值
	return 0;
}
```

---

## 作者：Armand (赞：5)

----
2018.9.24更新

## 关于spfa，他已经死了，所以童鞋们还是写dijkstr吧……

-------------------------------------------


# P1396 营救


	啊，这是一道明显的二分题目，因为他说“使得经过道路的拥挤度最大值最小”。
	（啊一定是因为我太弱了，所以觉得这种语句肯定是二分大法！）

	然而我还是丧心病狂的用最短路来写了.......（才不告诉你我不会二分呢）

	题目中的“所以请你帮她规划一条从s至t的路线，使得经过道路的拥挤度最大值最小”不就是明显的最短路吗？

	所以这是最短路模板题！（是我太自信了？）

	那么这题目与普通最短路，那些模板题有什么区别呢？

	其实就是更新路径长度的细小差别啦，只要稍微改下更新路径方式就可以AC啦（尽管我还是debug了好久......)

~~这里我就用一下spfa来跑吧,个人感觉是比较好用的一种跑法最短路跑法.~~

####	其实和spfa模板的不同只有一处

#####	这是现在的更新最短路：
   ``` c++
int tmp=max(dis[t],Len[t][i]);
if(dis[plat[t][i]]>tmp) {
	dis[plat[t][i]]=tmp;
	if(!flag[plat[t][i]]) {
		Q.push(plat[t][i]);
		flag[plat[t][i]]=1;
	}
}
    ```
#####	而原来的模板：
    
   ```c++
int tmp=dis[t]+Len[t][i];
if(dis[plat[t][i]]>tmp) {
	dis[plat[t][i]]=tmp;
	if(!flag[plat[t][i]]) {
		Q.push(plat[t][i]);
		flag[plat[t][i]]=1;
	}
}
    ```

### 可见更新路径长，从把路接上去变成了取最大值。

### 那么只需要把spfa敲一遍就好啦。
```c++
#include<bits/stdc++.h>//懒懒的万能头
#define Maxn 100005
using namespace std;
int ax,axx,n,m,beg,fin,len;
vector<int>plat[Maxn],Len[Maxn];//在这里我使用了vector，只要还是因为懒....
int flag[Maxn],dis[Maxn];//储存是否入队列以及最短路
void add(int a,int b,int c) {//加边（一定要注意是双向的！）
	plat[a].push_back(b);
	Len[a].push_back(c);
	plat[b].push_back(a);
	Len[b].push_back(c);
}
queue<int>Q;//(又是懒懒的系统队列）（貌似会比手写得慢一点吧）
void spfa() {
	for(int i=1; i<=n; i++)dis[i]=1e9+7,flag[i]=0;//初始化距离无穷大
	flag[ax]=1;//起点入队
	dis[ax]=0;//起点到起点距离相等
	Q.push(ax);//入系统队列（与上面不同）
	while(!Q.empty()) {
		int t=Q.front();//取队首元素
		Q.pop();//弹出队首元素
		flag[t]=0;//队首元素出队（flag的队！）（不要看混了）
		for(int i=0; i<plat[t].size(); i++) {
			int tmp=max(dis[t],Len[t][i]);//唯一和模板不一样的地方
			if(dis[plat[t][i]]>tmp) {
				dis[plat[t][i]]=tmp;
				if(!flag[plat[t][i]]) {
					Q.push(plat[t][i]);
					flag[plat[t][i]]=1;
				}
			}
		}
	}
	if(dis[axx]==1e9+7)dis[axx]=-1;//一定要注意题中的-1，不然就wa了
	printf("%d\n",dis[axx]);
	return ;
}

int main() {
	scanf("%d%d%d%d",&n,&m,&ax,&axx);//读入
	for(int i=1; i<=m; i++) {
		scanf("%d%d%d",&beg,&fin,&len);
		add(beg,fin,len);
	}
	spfa();
}
```

	然而后来发现.....
###	貌似最小生成树更好写啊.....
	这里采取克鲁斯卡尔算法，（名字有点长……）
	采取并查集辅助（为什么感觉还是个模板题）
	这里解释下为什么想到最小生成树，因为，这题采取更新最大值，而最大值是单调递增的。
    那么在答案出现前肯定目前值会比答案小啊，对答案并没有影响.
```c++
#include<bits/stdc++.h>
using namespace std;
int fa[50005],n,m,ans,tmpf,tmps,cnt,num,s,t;
struct node {
	int fr,to,cost;
	bool operator <(const node &A)const {//重载比较有人体美学~
		return A.cost>cost;
	}
} A[50005];
int getfa(int v) {//路径压缩，一定要，不然并查集就没什么用处了
	while(v!=fa[v])v=fa[v]=fa[fa[v]];//尽管长了点，但这个并查集效率肯定是最高的（真诚推荐使用）
    //也就是手动加常数优化233333(不要加多了……并查集压缩后基本路径长度在四左右……)
	return v;
}
void solve() {
	sort(A+1,A+m+1);//排序
	for(int i=1; i<=m; i++) {
		tmpf=getfa(A[i].fr),tmps=getfa(A[i].to);//寻找这条边的两个端点是否已经被放在一起
		if(tmpf==tmps)continue; //若果是那就继续
		if(getfa(s)==getfa(t))break;//如果起点和终点在一起了就退出程序吧
		num++;
		ans=max(ans,A[i].cost);//从小到大记录max值，（因为从最小的开始，所以答案肯定不会比当前的小）
		fa[tmps]=tmpf;//合并父亲
		cnt++;
		if(cnt==n-1) break;
	}
}
int main() {
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1; i<=m; i++)scanf("%d%d%d",&A[i].fr,&A[i].to,&A[i].cost),fa[i]=i;//fa[]的初始化一定要记得
	solve();
	printf("%d\n",ans);
}
```

---

## 作者：Coco_T (赞：5)

其实就是一道最小生成树的模板题，我在这里用的是kruskal算法，唯一需要注意的是每加入一条边都要判断s，t是不是在一个集合里面，这样就可以顺利AC了。。。









```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int fa[10005];
struct node{
    int x,y,z;
}; 
node way[20010];
int n,m,s,t,tot=0;
int com(const node &c,const node &d)
{
    return c.z<d.z;
}
int find(int g)  //找到该元素所在集合的代表元素
{
    if (fa[g]!=g)
       fa[g]=find(fa[g]);
    return fa[g];
}
int unionn(int s1,int s2)  //合并集合的过程
{
    int r1=find(s1);
    int r2=find(s2);
    if (r1!=r2)
       fa[r1]=r2;
}
int js()
{
    int i,j,k;
    k=1;
    i=1;
    while (k<n)
    {
        while (find(way[i].x)==find(way[i].y))
            i++;
        tot=max(way[i].z,tot);   //因为求的是最大值，所以用了一个max，其实没必要这么麻烦，因为边一定是从大到小的，后加入的边一定较大，可以直接写tot=way[i].z;
        unionn(way[i].x,way[i].y);  //这里就是一个并查集处理
        k++;
        if (find(s)==find(t))  //判断，自认为是这道题最重要的细节
           break;
    }
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    int i;
    for (i=1;i<=m;i++)
    {
       scanf("%d%d%d",&way[i].x,&way[i].y,&way[i].z);
    }
    for (i=1;i<=n;i++)
      fa[i]=i;
    sort(way+1,way+1+m,com);  //把边从小到大排序
    js();
    printf("%d",tot);
    return 0;
}
```

---

## 作者：__AFOier__ (赞：4)


方法 ： vector + SPFA


----------------------------------------------------xcy-AK-IOI----------------------------------------------------

似乎许多人都是使用前向星 / 邻接表 / 邻接矩阵(可能会炸)

然而, C++党可以用

## VECTOR 建图

----------------------------------------------------xcy-AK-IOI----------------------------------------------------

接下来, 是算法的问题:

似乎 很多大佬 都是 用 K算法/ 二分做的?

然鹅 : 这题用SPFA 更简单.

做法: 将访问到的节点(v)的上一个节点(u)的最优解(d[u]) 和 u点到v点的距离(g[u][v] )的 最大值  与  被访问到的节点(v)的最优解(d[v]) 比较, 如果前者小, 就松弛后者.

### 即 :

#### ——我们是将当前该边左边的最优解(即a[x].qa[x].q)与边权作比较(即b[i].cb[i].c)，取二者的最小值，再将其结果与该边右边的最优(即a[y].qa[y].q)作比较，取最小值，那么在跑完一次最短路之后，答案就是a[e].qa[e].q。(by 钟梓俊)

```
so ：
关系式: d[v] = min (d[v], max(d[v的上一个节点, 设为u] , u 与 v 的距离))
```
-

----------------------------------------------------xcy-AK-IOI----------------------------------------------------

具体操作见代码:

```
#include    <queue>
#include   <cstdio>
#include   <vector>  //vector 头文件
#include  <cstring>
#include <iostream>
#define    _      0 //卖萌
using namespace std;

int n, m, s, t;
int x, y, z;

struct edge {
	int v, w;
};
vector <edge> g[100010];// 用来建图

int d[100010];
bool vis[100010];
queue <int> q;// 准备用队列实现SPFA

int main() {
	scanf("%d%d%d%d", &n, &m, &s, &t);
	while (m--) {
		scanf("%d%d%d", &x, &y, &z);
		g[x].push_back((edge){y, z});
        // 将y 节点存到x 节点后, 且使x 节点距 y 节点z 个单位
		g[y].push_back((edge){x, z});
        // 将x 节点存到y 节点后, 且使y 节点距 x 节点z 个单位(无向图)
	}
	memset(d, 127, sizeof(d));// 初始化
	d[s] = 0, vis[s] = 1, q.push(s);// 初始化
    // spfa :
	while (!q.empty()) {
		int x = q.front();
		q.pop(), vis[x] = 0;
                // 遍历: 从第一个与x 相连的节点到最后一个与x 相连的节点
                // 注意: vector 数组 是从 0 开始 存储 的!!!!!!
                // 因此: 我们的循环应从0 开始
		for (int i = 0; i < g[x].size(); i++) {
			int y = g[x][i].v, w = g[x][i].w;
			if (max(d[x], w) < d[y]) {
				d[y] = max(d[x], w);//松弛操作
				if (!vis[y]) q.push(y), vis[y] = 1;//入队操作
			}
		}
                // 遍历完
	}
    // spfa 完
	printf("%d", d[t]);
	return ~~(0 ^ _ ^ 0);// 卖萌
}
```


---

## 作者：Minakami_Yuki (赞：4)

## 题意简述
给你一张图，有边权，求使得源点汇点联通的路径中边最大值的最小值。（貌似还是不很清楚）
## 思想
看到最大的最小很多人想到二分，但是可以有更好的解法。
我们不妨用**并查集**维护这个图，将边从小到大排序，每次取出边权最小的边，若该边的起点与终点未在一个集合内，就将其合并。当源点与汇点在一个集合内时，当前边的权值就是答案。
## 并查集基本操作
这里有一个~~比较优美的~~路径压缩的实现：
```cpp
int find(int x) {return fa[x] = fa[x] == x ? x : find(fa[x]);}
```
一行代码。
**合并**的话在主函数内直接写就行了，没有一些附加消息没必要单独写函数。

## Code
40行代码（有快读）
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>

inline int read() {
	char ch = getchar(); int r = 0;
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) r = r * 10 + ch - '0', ch = getchar();
	return r;
}

const int N = 20020;

struct edge {
	int x, y, z;
} e[N];

int fa[N];

inline bool cmp(edge a, edge b) {return a.z < b.z;}

int find(int x) {return fa[x] = fa[x] == x ? x : find(fa[x]);}

int main() {
	int n = read(), m = read(), s = read(), t = read();
	for(register int i = 1; i <= n; i++) fa[i] = i;
	for(register int i = 1; i <= m; i++) {
		int x = read(), y = read(), z = read();
		e[i] = (edge) {x, y, z};
	}
	std::sort(e + 1, e + m + 1, cmp);
	for(register int i = 1; i <= m; i++) {
		int x = find(e[i].x), y = find(e[i].y);
		if(x != y) fa[x] = y;
		if(find(s) == find(t)) {
			printf("%d", e[i].z);
			return 0;
		}
	}
}
```

---

## 作者：Dirt、 (赞：4)

本题可以通过求最短路求解

我用了dijkstra，可以定义$dis[x]$为$x$与出发点$s$之间最长边的边权

设当前扩展的点为$u$,$u$与$x$间边权为$w$

可以得到$dis[x]=min(dis[x],max(dis[u],w))$

贴一波代码~
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
struct Edge
{
	int next,to,w;
}edge[40003];//链式前向星存边
int n,m,s,t,cnt;
int dis[10003],head[10003];
bool v[10003];
int read()
{
	int x=0;bool f=true;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=false;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return f?x:-x;
}
void print(int x)
{
	if(x<0){x=-x;putchar('-');}
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
void addedge(int u,int v,int w)
{
	edge[++cnt].next=head[u];
	edge[cnt].to=v;
	edge[cnt].w=w;
	head[u]=cnt;
}
void dijkstra()
{
	memset(dis,0x3f3f3f3f,sizeof(dis));
	dis[s]=0;
	int x,minn;
	while(1)
	{
		x=0,minn=0x3f3f3f3f;
		for(int i=1;i<=n;i++)
			if(!v[i]&&dis[i]<minn)
			{
				minn=dis[i];
				x=i;
			}
		if(!x) break;
		v[x]=true;
		for(int i=head[x];i;i=edge[i].next)
			dis[edge[i].to]=min(dis[edge[i].to],max(dis[x],edge[i].w));
            //与普通dijkstra的唯一不同之处，dis数组表示路径上的最长边的边权
	}
	return;
}
int main()
{
	n=read(),m=read(),s=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		addedge(u,v,w);
		addedge(v,u,w);//无向图需要存两遍
	}
	dijkstra();
	print(dis[t]);
	return 0;
}
```

---

## 作者：chendayy99 (赞：4)

使用并查集的解法，由P1111得到的灵感，这题实际上比P1111更简单。

首先对所有边的拥挤度进行排序，然后从拥挤度最小的边开始，将边左右连接的点放入并查集中，这样同一并查集中的点就都是相互连通的。

当s和t出现在同一并查集中时，意味着s和t已经连通了，此时的道路拥挤度就是我们要的拥挤度最大值的最小值。

```delphi

program save;
type roads=record
time:integer;
aside:integer;
bside:integer;
end;
var n,m,s,t,i,p1,p2:integer;
road:array[1..20000] of roads;
a:array[1..10000] of integer;
function root(x:integer):integer;
begin
if a[x]=x then
root:=a[x]
else
begin
a[x]:=root(a[x]);
root:=a[x];
end;
        end;
procedure sort(l,r: integer);
      var
         i,j,x: integer;
y:roads;
      begin
         i:=l;
         j:=r;
         x:=road[(l+r) div 2].time;
         repeat
           while road[i].time<x do
            inc(i);
           while x<road[j].time do
            dec(j);
           if not(i>j) then
             begin
                y:=road[i];
                road[i]:=road[j];
                road[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
readln(n,m,s,t);
for i:=1 to m do
readln(road[i].aside,road[i].bside,road[i].time);
sort(1,m);
for i:=1 to n do
a[i]:=i;
for i:=1 to m do
begin
p1:=road[i].aside;
p2:=road[i].bside;
if root(p1)<>root(p2) then
a[root(p1)]:=root(p2);
if root(s)=root(t) then
begin
writeln(road[i].time);
halt;
end;
end;
end.

```(pascal)


---

## 作者：James0602 (赞：3)

可以用最短路**Ford**来做，只不过要变变形，把求和变成求最大值，话不多说，直接上代码~~~

uses math;

var

        n,m,s,t,i,j,check:longint;
        u,v,w,dis:array[1..100005] of longint;
begin

        readln(n,m,s,t);
        for i:=1 to m do
                readln(u[i],v[i],w[i]);//这代表u[i]到v[i]的距离是w[i]
        for i:=1 to n do
                dis[i]:=100000000;//初始化
        dis[s]:=0;//起始点为零
        for j:=1 to n-1 do
        begin
                check:=0;
                for i:=1 to m do
                begin
                        if dis[v[i]]>max(dis[u[i]],w[i]) then
                        begin
                                					    
                                dis[v[i]]:=max(dis[u[i]],w[i]);
                                check:=1;
                        end;
                        if dis[u[i]]>max(dis[v[i]],w[i]) then
                        begin
                                dis[u[i]]:=max(dis[v[i]],w[i]);
                                check:=1;
                        end;//要做两次因为是双向
                end;
                if check=0 then break；//当它没改变时，直接退出
        end;
        writeln(dis[t]);//输出
end.//再见~~~



---

## 作者：ShineEternal (赞：3)

# 题目：https://www.luogu.org/problemnew/show/P1396

# 分析：
这其实一看就是一个最短路的近似模板的题目，但我们要注意到两个区之间可能会有多条道路，所以说我们只需要在最短路模板的基础上把加和改为最大值即可，

因为题目还说了要求出最后的结果是最大值的最小，所以我们可能会自然而然的想到二分，然而此题跑个dijkstra或spfa甚至是克鲁斯卡尔最小生成树都行。

然而据某大佬说二分+bfs也能跑出来。

下面提供dijkstra算法。

# [代码在这](https://blog.csdn.net/kkkksc03/article/details/83625866)

---

## 作者：mmqqdd (赞：3)

```cpp

我用的是prime算法加邻接表，因为数据范围很大，所以邻接矩阵会爆内存，
另外我还用了一个数组f1存父节点，方便找最短路。
type arr=record  
x,y,z,s:longint;  
end;  
var  n,m,qd,zd,x,y,z,i:longint;  
a:array[0..50000]of arr;c,f1,min:array[0..20000]of longint;  
f:array[0..20000]of boolean;  
function ans(x:longint):longint;  
var minx:longint;  
begin  
if x=qd then exit(0);  
if min[x]>ans(f1[x])then exit(min[x])else exit(ans(f1[x]));  
end;  
procedure sb(qdb:longint);  
var i,min2,k:longint;  
begin  
  if a[qdb].x=zd then exit;  
  f[a[qdb].x]:=true;  
  repeat  
    if (min[a[qdb].y]>a[qdb].z)and(not f[a[qdb].y])then  
        begin  
              min[a[qdb].y]:=a[qdb].z;  
              f1[a[qdb].y]:=a[qdb].x;  
        end;  
    qdb:=a[qdb].s;  
  
  until qdb=0;  
  min2:=maxlongint;  
  for i:=1 to n do  
  if (not f[i])and(min[i]<min2)then  
     begin  
       min2:=min[i];  
       k:=i;  
  
     end;  
  sb(c[k]);  
end;  
begin  
read(n,m,qd,zd);  
for i:=1 to m do min[i]:=maxlongint;  
for i:=1 to m do  
  begin  
    read(x,y,z);  
    a[i*2-1].x:=x;a[i*2-1].y:=y;a[i*2-1].z:=z;  
    a[i*2-1].s:=c[x];c[x]:=i*2-1;  
    a[i*2].x:=y;a[i*2].y:=x;a[i*2].z:=z;  
    a[i*2].s:=c[y];c[y]:=i*2;  
  
  end;  
sb(c[qd]);  
write(ans(zd));  
end.  

```

---

## 作者：sshwy (赞：3)

不得不来一发题解

本来看到二分和并查集和图论的标签的时候多害怕的

后来我深思熟虑

#其实用最小生成树就行了

##首先对边的权值排序

从小到大构建最小生成树

每加一条边就判断s，t的联通

联通了就输出当前联通块的最大权值

##因为一旦联通，就说明一定要经过当前的边，即当前的最大权值

类似贪心

#其次，构建最小生成树时加入并查集优化

##压缩路径

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

int n,m,s,t;
int f[10001];//father（并查集的内容）
long long total;

struct cs
{
    int x,y,z;
}a[20001];

bool comp(cs a1,cs a2)
{
    return a1.z<a2.z;
}

int gf(int k)//getfather（并查集的内容）
{
    if(f[k]==k)return k;
    f[k]=gf(f[k]);//压缩路径
    return f[k];
}

void un(int b1,int b2)//union（并查集的内容）（联通b1，b2所在的联通块）
{
    int fb1=gf(b1);
    int fb2=gf(b2);
    f[fb1]=fb2;
}

int main()
{
    cin>>n>>m>>s>>t;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i].x>>a[i].y>>a[i].z;
    }
    sort(a+1,a+m+1,comp);//从小到大

    for(int i=1;i<=n;i++)f[i]=i;//并查集初始化，每个区自成一联通块
    
    for(int i=1;i<=m;i++)
    {
        if(gf(a[i].x)!=gf(a[i].y))//如果不在同集
        {
            un(a[i].x,a[i].y);
            total=total>a[i].z? total:a[i].z;
        }
        if(gf(s)==gf(t))
        {
            break;
        }
    }
    cout<<total;
    return 0;
}
```

---

## 作者：Ckger (赞：2)

本蒟蒻还没学图论，稍微看了一下书就水过了（二分太难），用dijkstra稍微变一下就可以了，在做些优化。请参见代码，代码上面注释很清晰（自认为）。
# code：
```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<stack>//头文件
using namespace std;
bool pc[10010];//dijkstra使用所需要的判重数组 
int n/*点的个数*/,m/*边的个数*/,start/*起始点*/,end/*终点*/,num[10010]/*每个点连的边*/,max_best[10010]/*每个点走到的最大的拥挤度的最小值*/,INF=0x7fffffff/*足够大的值*/;
long long ans=INF/*最终答案起始赋值*/;
struct edge
{
    int last,next,yj;
    
}a[50001];//点和边的结构体 
int cmp(edge c,edge d)//sort使用cmp函数排序 
{
    if (c.last==d.last)
        return c.next<d.next;
    return c.last<d.last;
}
void createroad()//建图 
{
    for (int i=1;i<=m;i++)
    {
        cin>>a[i].last>>a[i].next>>a[i].yj;//先将数据储存起来 
        a[i+m].last=a[i].next;
        a[i+m].next=a[i].last;
        a[i+m].yj=a[i].yj;//因为图无向，所以反过来存一遍，以便于快速找到每个点所连的边 
    }
    sort(a+1,a+1+m*2,cmp);//排序->出发点编号排序 
    int nn=1;//nn初始值为 1 
    for (int i=1;i<=2*m;i++)
    {
        if (a[i].last!=nn)//假如当前位置的出发点不为nn，则出发点变动 
        {
            num[nn]=i-1;//储存出发点最后到达的位置 
            nn=a[i].last;//更新nn
        }
    }
    num[0]=0;//开头结尾特殊处理 
    num[n]=2*m;
	//将每个点连接的点在a数组里的位置用num数组存起来，以便于查找 
}

int find(int aa,int b)//查找两个点之间边的权值（拥挤度） 
{
	int anss=INF;//因为两个点之间可能有多条边，所以挑选权值最小的 
	for (int ss=num[aa-1]+1;ss<=num[aa];ss++)
		if (a[ss].last==aa&&a[ss].next==b)
			anss=min(anss,a[ss].yj);//更新最小权值 
	if (anss!=INF) return anss;
}
void dijkstra(int s)
{
	fill(max_best+1,max_best+1+n,INF);//将数组初始化为最大值 
	max_best[s]=0;//起点到起点距离为 0 
	while (1)//开始搜 
	{
		int v=-1;
		for (int i=1;i<=n;i++)
			if (!pc[i]&&(v==-1||max_best[i]<max_best[v])) v=i;//找到与自己相连且边的权值最小的点 
		if (v==-1)//如果没找到则所有点遍历 
			break;//跳出循环 
		pc[v]=true;//标记走过 
		for (int i=num[v-1]+1;i<=num[v];i++)//从自己相连的点开搜 
		{
			int k=find(v,a[i].next);//找到边的权值 
			max_best[a[i].next]=min(max(max_best[v],k),max_best[a[i].next]);//更新与自己相连的点的权值的最大值	
		}
	}
	//结束搜索 
	ans=max_best[end];//ans赋值 
}
int main()
{
	memset(pc,false,sizeof(pc));//memset初始化 
    memset(a,-1,sizeof(a));
    cin>>n>>m>>start>>end;//输入 
    createroad();//建图 
    dijkstra(start);//找出最小值 
    cout<<ans;//输出 
    return 0;
}
```
写了这么多，我还是太菜了，求一遍过，谢谢。
### 本题解受机房CLF，FXW，LYH，HC  ~~大佬~~神佬启发而得

---

## 作者：infinityedge (赞：2)

这真是一道倍增LCA的好题

···
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
struct wn{
    int x,y,w;
}e[50005],shu[20005];
int fa[10005],he[10005],vis[10005],dep[10005],f[10005][20],weight[10005][20],n,m,s,t,q,po=0;
int cmp(wn x,wn y){
    return x.w<y.w;
}
int find(int x){
    if(fa[x]==x)return x;
    fa[x]=find(fa[x]);
    return fa[x];
}
void addedge(int x,int y,int w){
    po++;
    shu[po].x=y;
    shu[po].y=w;
    shu[po].w=he[x];
    he[x]=po;
    po++;
    shu[po].x=x;
    shu[po].y=w;
    shu[po].w=he[y];
    he[y]=po;
}
void dfs(int x,int faq,int w){
    dep[x]=dep[faq]+1;
    f[x][0]=faq;
    weight[x][0]=w;
    vis[x]=1;    
    for(int i=he[x];i!=0;i=shu[i].w){
        if(!vis[shu[i].x]){
            dfs(shu[i].x,x,shu[i].y);
        }
    }
}
void csh(){
    for(int i=1;i<=18;i++){
        for(int j=1;j<=n;j++){
            f[j][i]=f[f[j][i-1]][i-1];
            weight[j][i]=max(weight[j][i-1],weight[f[j][i-1]][i-1]);
        }
    }
}
void hb(int x,int y,int w){
    int xx=find(x),yy=find(y);
    if(xx!=yy){
        fa[xx]=yy;
        addedge(x,y,w);
    }
}
int lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    int minn=0;
    for(int i=18;i>=0;i--){
        if(dep[f[x][i]]>=dep[y]){
            minn=max(weight[x][i],minn);
            x=f[x][i];    
        }
    }
    if(x==y)return minn;
    for(int i=18;i>=0;i--){
        if(f[x][i]!=f[y][i]){
            minn=max(minn,weight[x][i]);
            minn=max(minn,weight[y][i]);
            x=f[x][i];
            y=f[y][i];            
        }
    }
    minn=max(minn,weight[x][0]);
    minn=max(minn,weight[y][0]);
    return minn;
}
int main(){
    scanf("%d%d%d%d",&n,&m,&s,&t);
    memset(he,0,sizeof(he));
    for(int i=1;i<=n;i++){
        fa[i]=i;
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
    }
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++){
        hb(e[i].x,e[i].y,e[i].w);
    }
    dep[0]=0;
    for(int i=1;i<=n;i++){
        if(!vis[i]){            
            dfs(i,0,0);
        }            
    }
//    for(int i=1;i<=n;i++)printf("%d ",shu[i].x);
    csh();
        if(find(s)!=find(t)){
            printf("-1\n");
        }
        printf("%d\n",lca(s,t));
    return 0;
}
···
```

---

## 作者：cx51y (赞：2)

二分+并查集判断联通块

我们可以二分一下最大的边，则小于这个最大边的

边都可以走，这样我们只需判断在这种情况下起点

和终点是否在同一个联通块里就行了；使用并查集

来判断；


```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
int n,m,s,t,nl,ans;
int fa[N],hd[N];
struct node
{
    int u,v,d,next;
}edge[N];
void add_edge(int u,int v,int d)
{
    edge[++nl].next=hd[u];
    edge[nl].u=u;edge[nl].v=v;edge[nl].d=d;
    hd[u]=nl;
}
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
int check(int m)
{
    for(int i=1;i<=n;i++)fa[i]=i;     //每次重置并查集数组
    for(int i=1;i<=nl;i++)
    {
        if(edge[i].d>m)continue;       //大于当前最大边则不能走
        int u=edge[i].u,v=edge[i].v;
        int x=find(u),y=find(v);
        if(x!=y)
        {
            fa[x]=y;
        }
    }
    fa[s]=find(s),fa[t]=find(t);
    return fa[s]==fa[t];                //s,t是否在同一个联通块里
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++)
    {
        int u,v,d;
        scanf("%d%d%d",&u,&v,&d);
        add_edge(u,v,d);
    }
    int l=0,r=1e5+10,mid;
    while(r-l>=1)
    {
        mid=(l+r)/2;
        if(check(mid))
        {
            ans=mid;
            r=mid;
        }
        else l=mid+1;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：神的泪 (赞：2)

来一发题解，其实本题可以理解成一道最短路问题的变形。

本题我是用dijkstra+heap优化算法过的，当然spfa的思想也是一样的。

对于最短路问题，dijkstra的思想是：

1.初始化v0的路径长度为d0 = 0，其余各点di长度为无穷大

2.每次从尚未得出结论的点中，取出离起始点v0最近的那个点vi，然后得出结论，v0到现在取出的点vi的最短路的长度就是目前计算出的di

3.通过di + wik和dk作松弛操作，更新所有i相邻的点的d值。

4.执行2，3直到所有点的距离都被确定。


对于本题来说，其他思想完全一样的，只是松弛操作的时候比较的不是dk和di+wik，而是dk 和max(di, wik)就可以了。

然后由于题目数据n <= 10000, m <= 2n，所以是稀疏图，用heap优化比纯dijkstra更快。


最后附上代码。





    


```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
#define MAX_DIS 10000;
struct Edge {
    int from;
    int to;
    int dis;
};
struct HeapNode {
    int u;
    int d;
    HeapNode() {}
    HeapNode(int num, int dis) :u(num), d(dis) {}
    bool operator<(const HeapNode & n) const {
        return this->d > n.d; 
    }
};
int main {
    int n, m, s, t, u, dis;
    cin >> n >> m >> s >> t;
    vector<vector<Edge> > edges;
    Edge e;
    HeapNode node;
    int *d = new int[n + 1];
    int *p = new int[n + 1];
    for (int i = 0; i <= n; i++) {
        d[i] = MAX_DIS;
    }
    d[s] = 0;
    memset(p, 0, sizeof(int) * (n + 1));
    priority_queue<HeapNode> que;
    edges.resize(n + 1);
    for (int i = 0; i < m; i++) {
        cin >> e.from >> e.to >> e.dis;
        edges[e.from].push_back(e);
        u = e.from;
        e.from = e.to;
        e.to = u;
        edges[e.from].push_back(e);
    }
    que.push(HeapNode(s, 0));
    while (!que.empty()) {
        node = que.top();
        que.pop();
        u = node.u;
        dis = node.d;
        if (!p[u]) {
            p[u] = 1;
            d[u] = dis;
            for (int i = 0; i < edges[u].size(); i++) {
                               // 只有这段和dijkstra算法的思想不一样，利用当前点的拥挤度和路径拥挤度的最大值对相邻点做松弛操作
                int testDis = max(dis, edges[u][i].dis);  
                if (d[edges[u][i].to] > testDis) {
                    d[edges[u][i].to] = testDis;
                    que.push(HeapNode(edges[u][i].to, testDis));
                }
            }
        }
    }
    cout << d[t];
    return 0;
}

```

---

## 作者：枉却东风 (赞：1)

####  当年做这道题的时候还是一个超级超级超级蒟蒻

#### 不会spfa和kruskal
## 于是用了一个伪Bellman—ford加一个小优化就A了qwq
#### 代码短得不可思议噗哈哈
```
#include <iostream>
#include <string.h>
#include <cmath>
#define MAXN 0x3f3f3f
using namespace std;
int n,m,s,t;
int u[20005],v[20005],w[20005];
int dis[10005],flag;
int main()
{
	memset(u,0,sizeof(u));
	memset(v,0,sizeof(v));
	memset(w,0,sizeof(w));
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++)
	{
		cin>>u[i]>>v[i]>>w[i];
	}
	for(int i=1;i<=n;i++)
	{
		dis[i]=MAXN;
	}
	dis[s]=0;
	for(int i=1;i<n;i++)
	 {
	 	flag=0;
	 	for(int j=1;j<=m;j++)
	 	{
	 		if(dis[u[j]]>max(dis[v[j]],w[j]))
	 		{
	 			dis[u[j]]=max(dis[v[j]],w[j]);
	 			flag=1;
			 }
	 		if(dis[v[j]]>max(dis[u[j]],w[j]))
	 		{
	 			dis[v[j]]=max(dis[u[j]],w[j]);
	 			flag=1;
	 		}
		 }
		 if(flag==0) break;
	 }
	 cout<<dis[t];
	 return 0;
}
```

---

## 作者：以梦为马 (赞：1)

这道题所要求的是“经过道路的拥挤度最大值的最小值”，换句话说，也就是让从s到达t的所有路径中的最大权值最小，并求出这个最小值。听起来很拗口_(°:з」∠)_
由这个题干，不难想到：Kruskal算法求MST的贪心策略可以一用。为了得到题干中要求的“最小值”，我们总是选择剩下的边中权值最小的边相连两个节点（用并查集判断以避免成环）。题干中要求研究的是从s到t的路径，虽然一些加入的边并不属于所要求的路径，但是恰好使得s和t连通的那条边，一定是s到t的路径中的最大值。而在Kruskal算法的贪心策略前提下，这个最大值一定是题干所要求的“最小值”。
总而言之，这一解法是基于稍加改动的Kruskal算法。
Kruskal算法求MST的核心有两个：一是边的排序，二是并查集的判是否成环。边的排序我选择用结构体储存起点，终点，权值，并用stl的qsort()函数排序。
下面贴上AC代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define maxn 10005
#define maxm 20005
using namespace std;
struct node
{
  int s,t,w;     
};
struct node g[maxm];
int n,m,s,t,fa[maxn];
int cmp(const void *a,const void *b)
{
  struct node *p=(struct node *)a,*q=(struct node *)b;
  return p->w-q->w;  
} 
void init()
{
  int u,v,w;
  scanf("%d%d%d%d",&n,&m,&s,&t);
  for(int i=1;i<=n;i++)fa[i]=i;
  for(int i=0;i<m;i++)
  {
    scanf("%d%d%d",&u,&v,&w);
    g[i].s=u;g[i].t=v;g[i].w=w;        
  }     
  qsort(g,m,sizeof(g[0]),cmp);
}
int find(int x)
{
  return fa[x]==x?x:fa[x]=find(fa[x]);  
}
void merge(int s,int t)
{
  fa[find(s)]=find(t);     
}
int main()
{
  int s1,t1;
  init();
  for(int i=0;i<m;i++)
  {
    s1=g[i].s;t1=g[i].t;
    if(find(s1)!=find(t1))
      merge(s1,t1);        
    if(find(s)==find(t)) 
    { 
      printf("%d\n",g[i].w);
      break; 
    }
  }
  return 0;  
}

```

---

## 作者：plane (赞：1)

嘛。其实这道题没那么复杂，先无视背景的说……


很简单的一道单源最短路的改板……好像大部分人用的SPFA


只需要把求费用和的那段改为求最小就好了啦~


下面。。一部分程序。


```delphi

procedure spfa(s:longint);
var i,j,now,sum,point:longint;
begin
  for j := 1 to p do dist[j]:=maxlongint;
  dist[s]:=0;
  v[s]:=true;
  now:=s;
  head:=0;
  tail:=1;
  h1:=0;
  t1:=1;
  d[head]:=s;

```
```delphi

  while h1<t1 do
    begin
      now:=d[head];
      point:=front[now];
      while point<>-1 do
        begin
          if dist[to1[point]]>max(dist[now],vul[point])
          then
            begin
              dist[to1[point]]:=max(dist[now],vul[point]);
              if not v[to1[point]]
              then
                begin
                  d[tail]:=to1[point];
                  v[to1[point]]:=true;
                  tail:=(tail+1) mod 10001; t1:=t1+1;
                end;
            end;
          point:=next[point];
        end;
      v[now] := false;
      head:=(head+1) mod 10001;
      inc(h1);
    end;
end;

```




```delphi


var p,c,s,t,i,x,y,z:longint;
    a,b:array[1..50001,0..50001] of longint;
    d:array[0..20001] of longint;
    v:array[1..10001] of boolean;
    dist:array[1..10001] of longint;
    front:array [0..10001] of longint;
    to1,vul:array [0..40001] of longint;
    next:array [0..400001] of longint;
    head,tail,h1,t1:longint;
function min(a,b:longint):longint;
begin
  if a<b then exit(a) else exit(b);
end;
function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;
procedure spfa(s:longint);
var i,j,now,sum,point:longint;
begin
  for j := 1 to p do dist[j]:=maxlongint;
  dist[s]:=0;
  v[s]:=true;
  now:=s;
  head:=0;
  tail:=1;
  h1:=0;
  t1:=1;
  d[head]:=s;
  while h1<t1 do
    begin
      now:=d[head];
      point:=front[now];
      while point<>-1 do
        begin
          if dist[to1[point]]>max(dist[now],vul[point])
          then
            begin
              dist[to1[point]]:=max(dist[now],vul[point]);
              if not v[to1[point]]
              then
                begin
                  d[tail]:=to1[point];
                  v[to1[point]]:=true;
                  tail:=(tail+1) mod 10001; t1:=t1+1;
                end;
            end;
          point:=next[point];
        end;
      v[now] := false;
      head:=(head+1) mod 10001;
      inc(h1);
    end;
end;
begin
  fillchar(v,sizeof(v),false);
  readln(p,c,s,t);
  for i:=0 to 10001 do front[i]:=-1;
  for i:=1 to c do
    begin
      readln(x,y,z);
      next[i*2-1]:=front[y];
      vul[i*2-1]:=z;
      front[y]:=i*2-1;
      to1[i*2-1]:=x;
      next[i*2]:=front[x];
      vul[i*2]:=z;
      front[x]:=i*2;
      to1[i*2]:=y;
    end;
  spfa(s);
  writeln(dist[t]);
end.



<hr>
```

---

## 作者：薛裕龙 (赞：1)

这道题我一开始以为要用最短路。但仔细一看，如果用最短路疏松操作的话，最小的拥挤度很好求，但这是最大的拥挤度的最小值啊。如果你求出了每一个点的最小值，你怎么知道他是经过了哪些点到达的那个点呢，这就很是糊涂。于是我受到了最小生成树的启发，这其实也可以让权值从小到大依次连接各个点。每连接一次，就看看他的权值是否超过当前最大值，若超过就将值赋给它。

可能我的前面描述的不太清晰，上代码：

    
    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,s,t,maxx=-1;      maxx是代表最大的值
const int maxn=15000,maxm=35000;
struct zhu{              一直不知道我在干什么的人请kruskal算法练熟了
    int u,v,w;
}e[maxm];
int fa[maxn];     不知道这是干什么的好好学习并查集
int cmp(const zhu &a,const zhu &b)   
{
    return a.w<b.w;                                     
}
int find(int k)
{
    if(fa[k]==k)return k;
    else return fa[k]=find(fa[k]);         
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    }
    sort(e,e+m+1,cmp);
    for(int i=1;i<=n;i++)
    fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x==y)continue;
        else{
            fa[x]=y;
            if(e[i].w>maxx)maxx=e[i].w;
            }    
        find(s);       注意这里必须查找两次，因为上面刚刚更新了 fa ，如果这里不刷新一次，s与t的fa可能有误
        find(t);
        if(fa[s]==t||fa[s]==fa[t]||s==fa[t])
        break;                                     之所以有着三个，是因为路是双向的，不一定fa刚好在t身上，所以有三种情况来退出
    }
    printf("%d",maxx);
    return 0;
}
```

---

## 作者：Excim (赞：1)

提供三种做法：

1.倍增lca+最小生成树：

基本上同货车运输：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
void read(int &y)
{
    y=0;char x=getchar();
    while(x<'0'||x>'9') x=getchar();
    while(x>='0'&&x<='9')
    {
        y=y*10+x-'0';
        x=getchar();
    }
}
struct edge
{
    int u,v,w;
}e[50005];
bool cmp(edge x,edge y)
{
    return x.w<y.w;
}
int fa[10005][25],maxw[10005][25];
int f[10005],head[20005],nxt[20005],to[20005],d[20005],dep[10005];
int n,m,s,t,cnt;
int find(int x)
{
    if(x==f[x]) return x;
    return f[x]=find(f[x]);
}
void add(int u,int v,int w)
{
    to[cnt]=v;
    d[cnt]=w;
    nxt[cnt]=head[u];
    head[u]=cnt++;
}
void dfs(int x,int y)
{
    for(int i=head[x];i!=-1;i=nxt[i])
    {
        if(i!=y)
        {
            dep[to[i]]=dep[x]+1;
            fa[to[i]][0]=x;
            maxw[to[i]][0]=d[i];
            dfs(to[i],i^1);
        }
    }
}
int lca(int x,int y)
{
    if(dep[x]>dep[y])
    {
        int tmp=x;
        x=y;
        y=tmp;
    }
    int ans=-1;
    for(int i=15;i>=0;i--)
    {
        if(dep[fa[y][i]]>=dep[x])
        {
            ans=max(ans,maxw[y][i]);
            y=fa[y][i];
        }
    }
    if(x==y) return ans;
    for(int i=15;i>=0;i--)
    {
        if(fa[x][i]!=fa[y][i])
        {  
            ans=max(ans,max(maxw[x][i],maxw[y][i]));  
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return ans;
}
int main()
{
    read(n);read(m);read(s);read(t);
    for(int i=0;i<m;i++)
    {
        read(e[i].u);read(e[i].v);read(e[i].w);
    }
    sort(e,e+m,cmp);
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=0;i<m;i++)
    {
        if(find(e[i].u)!=find(e[i].v))
        {
            add(e[i].u,e[i].v,e[i].w);
            add(e[i].v,e[i].u,e[i].w);
            f[find(e[i].u)]=find(e[i].v);
        }
    }
    dep[1]=1,dfs(1,-1);
    for(int j=1;j<=15;j++)
    {
        for(int i=1;i<=n;i++)
        {
            fa[i][j]=fa[fa[i][j-1]][j-1];
            maxw[i][j]=max(maxw[i][j-1],maxw[fa[i][j-1]][j-1]);
        }
    }
    printf("%d",lca(s,t));
    return 0;
```
}2.最小生成树+暴力公共祖先：

此题只有一组数据，所以我们可以使用离线算法，首先求出图的最小生成树，然后由s节点暴力向上找父亲节点，一路标记，到达根节点后停止。在由t节点向上暴力找父亲节点，到达有标记的点之后停止。


然后两点分别再向上到公共祖先，更新最大值，输出即可。


3.最小生成树+巧妙利用并查集性质：


继续使用离线算法，然后使用克鲁斯卡尔算法求最小生成树，当s与t在一个集合中时，s到t的路径就确定了，最长的边就是当前要处理的边，输出即可。


---

## 作者：Hank (赞：1)

最小生成树，排序后从小到大枚举边 再从边中找最大值

代码如下：






    

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,s,t;
struct heheda
{
    int x,y,z;
}a[20005];
int fa[10005]; //并查集 
int getint()//读入优化 
{
    int str=0;
    char ch;
    for(ch=getchar();ch<'0' || ch>'9' ; ch=getchar());
    for(;ch>='0' && ch<='9';ch=getchar())str=10*str+ch-'0';
    return str;
}
bool comp(const heheda &a,const heheda &b)
{
    return a.z<b.z;
}
int find(int x)
{
    int pre=x;
    while(fa[x]!=x)x=fa[x];//找爸爸 
    while(fa[pre]!=pre)//路径压缩 
    {
        fa[pre]=x;
        pre=fa[pre];
    }
    return x;
}
int main()
{
    int x,y,z;
    n=getint();
    m=getint();
    s=getint();
    t=getint();
    for(int i=1;i<=m;i++)
    {
        a[i].x=getint();
        a[i].y=getint();
        a[i].z=getint();
    }
    for(int i=1;i<=n;i++)fa[i]=i;//初始化 
    sort(a+1,a+m+1,comp);//排序 
    int k=0;
    int ans=0;
    for(int i=1;i<=m;i++)
    {
        int x1=find(a[i].x);int x2=find(a[i].y);
        ans=max(ans,a[i].z);
        if(x1==x2)continue;//若已经连起来了 就继续 
        fa[x2]=x1;//连接 
        k++;
        if(k==n-1)
        break;
        if(find(s)==find(t))break;//s、t相连 退出 
    }
    printf("%d",ans);
}
```

---

## 作者：xun薰 (赞：1)

这个题的做法有

克鲁斯卡尔 倍增LCA dijikstra  二分答案 等

我来一个spfa的....

dis[i]表示i到s的最大边的最小值。其实就是变形spfa.

核心
if(dis[v]>max(dis[now],edge[i].z))

dis[v]=max(dis[now],edge[i].z)

代码





```cpp
#include<iostream>
#include<queue>
#include<cstring> 
#include<cstdio>
#define maxn 10003
using namespace std;
int n,m,s,t,x,y,z,a,sumedge;
int inq[maxn],dis[maxn],head[maxn];
queue<int>q;
struct Edge{
    int x,y,z,nxt;
    Edge(int x=0,int y=0,int z=0,int nxt=0):
        x(x),y(y),z(z),nxt(nxt){}
}edge[maxn<<2];
void add(int x,int y,int z){
    edge[++sumedge]=Edge(x,y,z,head[x]);
    head[x]=sumedge;
}
void spfa(){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    q.push(s);inq[s]=1;
    while(!q.empty()){
        int now=q.front();q.pop();inq[now]=0;
        for(int i=head[now];i;i=edge[i].nxt){
            int v=edge[i].y;
            if(dis[v]>max(dis[now],edge[i].z)){
                dis[v]=max(dis[now],edge[i].z);
                if(!inq[v]){
                    inq[v]=1;
                    q.push(v); 
                }
            }
        }
    } 
}
int main(){
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);add(y,x,z);
    }
    spfa();
    printf("%d\n",dis[t]);
    return 0;
}
```

---

## 作者：兴安黑熊 (赞：0)

本题的意思是说：当s到t点联通的时候，最大的边长（权值）是多少？ 当然这里的联通要求路径最短，也就是最小生成树，考虑并查集+克鲁斯卡尔，代码非常好写，好写到超乎你的想象，另外没加ios::sync_with_stdio(false)也没TLE，这不应该，可以看出数据是不卡时间的，代码如下：
```cpp
#include <iostream>
#include <string.h>
#include <algorithm>
using namespace std;
int vis[20001];
struct sa
{
    int a;
    int b;
    int val;
}dp[20001];
int find(int x)
{
    if (x!=vis[x])
    vis[x]=find(vis[x]);
    return vis[x];
}
int join(int x,int y)
{
    int x1=find(x);
    int y1=find(y);
    if (x1!=y1)
      {vis[y1]=x1; return 1;}
   return 0;
}
int cmp(const sa &a,const sa &b)
{
    return a.val<b.val;
}
int main()
{
  int n,m,s,t,num,ans=0;
  cin>>n>>m>>s>>t;
  for(int i=1;i<=n;i++) vis[i]=i;
  for(int i=1;i<=m;i++)
   cin>>dp[i].a>>dp[i].b>>dp[i].val;
   sort(dp+1,dp+m+1,cmp);
   num=0;
   for(int i=1;i<=m;i++)
   {
       if (join(dp[i].a,dp[i].b)==1)
       {ans=max(ans,dp[i].val);
        num++;
       }
       if (num==n-1) break;

       if (find(s)==find(t)) break;
   }
   cout<<ans<<endl;
    return 0;
}

```

---

## 作者：pupuvovovovovo (赞：0)

楼上好多高级算法……。。

二分一个最大拥挤度

然后判断s到t的连通性（我用的是广搜遍历，深搜也可以）

再注意一下数组上界，无向图邻接表要2m

完了。

pascal：如下。


```cpp
var first,last:array [1..10000] of longint;
yo,en,next:array [1..40000] of longint;
n,bs,s,endd,i,x,y,z,top,l,r,m,ans,max,min:longint;
procedure add(x,y,z:longint);
begin
  inc(top);
  if first[x]=0 then first[x]:=top
  else next[last[x]]:=top;
  last[x]:=top;
  en[top]:=y;
  yo[top]:=z;
end;//邻接表
function judge(x:longint):boolean;//二分答案的主体
var dl:array [1..10000] of longint;
b:array [1..10000] of boolean;
i,h,t:longint;
 procedure push(x:longint);
 begin
   if b[x] then exit;
   b[x]:=true;
   inc(t);
   dl[t]:=x;
 end;
begin
  fillchar(dl,sizeof(dl),0);
  fillchar(b,sizeof(b),false);
  h:=0;
  t:=1;
  dl[1]:=s;
  repeat
    inc(h);
    if dl[h]=endd then exit(true);
    i:=first[dl[h]];
    while i>0 do
    begin
      if yo[i]<=x then push(en[i]);
      i:=next[i];
    end;
  until h=t;
  exit(false);
end;
begin
  read(n,bs,s,endd);
  min:=maxlongint;
  for i:=1 to bs do
  begin
    read(x,y,z);
    add(x,y,z);
    add(y,x,z);
    if z>max then max:=z;
    if z<min then min:=z;
  end;
  l:=min;
  r:=max;
  while l<=r do
  begin
    m:=(l+r) div 2;
    if judge(m) then
    begin
      ans:=m;
      r:=m-1;
    end
    else l:=m+1;
  end;
  //主程序中的二分
  write(ans);
end.
```

---

## 作者：伽马天行 (赞：0)

二分答案，通过spfa选边，凡是大于二分值的一律不选，最后判断从s出发，是否能够到达t。就这样不断二分下去。

--by uoi 大佬 pjx(注：此处的u指universal)

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
struct df{
    int loc,num;
};
vector<df>ylx[10005];
queue<int>q;
bool y[10005];
int n,m,s,t,le,ri,z[10005];
bool spfa(int v)
{
    memset(y,false,sizeof(y));
    for(int i=1;i<=n;i++)    z[i]=99999999;
    z[s]=0;
    y[s]=true;
    q.push(s);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        y[x]=false;
        for(int i=ylx[x].size()-1;i>=0;i--)
        {
            if(ylx[x][i].num<=v&&z[ylx[x][i].loc]>z[x]+ylx[x][i].num)
            {
                z[ylx[x][i].loc]=z[x]+ylx[x][i].num;
                if(!y[ylx[x][i].loc])
                {
                    y[ylx[x][i].loc]=true;
                    q.push(ylx[x][i].loc);
                }
            }
        }
    }
    if(z[t]<99999999)    return true;
    else    return false;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int t1,t2,t3,i=1;i<=m;i++)
    {
        scanf("%d%d%d",&t1,&t2,&t3);
        df tt;
        tt.loc=t2;tt.num=t3;ylx[t1].push_back(tt);
        tt.loc=t1;ylx[t2].push_back(tt);
    }
    le=1;ri=10000;
    while(le<ri)
    {
        int mid=(le+ri)/2;
        if(spfa(mid))    ri=mid;
        else    le=mid+1;
    }
    printf("%d",ri);
}
```

---


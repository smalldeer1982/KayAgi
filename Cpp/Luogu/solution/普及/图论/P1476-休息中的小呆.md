# 休息中的小呆

## 题目描述

当大家在考场中接受考验（折磨？）的时候，小呆正在悠闲（欠扁）地玩一个叫“最初梦想”的游戏。游戏描述的是一个叫 pass 的有志少年在不同的时空穿越对抗传说中的大魔王 chinesesonic 的故事。小呆发现这个游戏的故事流程设计得很复杂，它有着很多的分支剧情，但不同的分支剧情是可以同时进行的，因此游戏可以由剧情和剧情的结束点组成，某些剧情必须要在一些特定的剧情结束后才能继续发展。为了体验游戏的完整性，小呆决定要看到所有的分支剧情——完成所有的任务。但这样做会不会耽误小呆宝贵的睡觉时间呢？所以就请你来解决这个问题了。


## 说明/提示

### 数据范围及约定

对于全部数据，$0<n<100$，$0<m\le 120$，$0<i\le 100$，$0<j\le 100$，$0<k\le 1000$。

## 样例 #1

### 输入

```
4
5
1 2 2
2 3 2
3 5 3
1 4 3
4 5 3
```

### 输出

```
7
1 2 3 5
```

# 题解

## 作者：songxiao (赞：8)

很多的题解都说“剧情结束点不是所有节点，节点数还要多一个”但是并没有解释。我来说一下，其实剧情结束点确实是从 $1$ 到 $n$，但是还有一个总的剧情开始的节点，所以实际是 $0$ 到 $n$。如果下标从 $1$ 开始，就可以理解为 $1$ 到 $n+1$。

然后就是最长路板子，可以参考 [P1807 最长路](https://www.luogu.com.cn/problem/P1807)。

AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dis[1005][1005];
int main()
{
	cin>>n>>m;
    for(int i=1;i<=n+1;i++)//初始化
        for(int j=1;j<=n+1;j++)
        {
            if(i==j)
                dis[i][j]=0;
            else
                dis[i][j]=1e9;
        }
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		dis[u][v]=min(dis[u][v],-w);//谨防重边（不一定有）
	}
	for(int k=1;k<=n+1;k++)
	{
		for(int i=1;i<=n+1;i++)
		{
			for(int j=1;j<=n+1;j++)
			{
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
    cout<<-dis[1][n+1]<<' '<<endl;
    for(int i=1;i<=n+1;i++)
    	if(dis[1][i]+dis[i][n+1]==dis[1][n+1])
    		cout<<i<<' '; 
	return 0;
}

```

---

## 作者：冷眸丶 (赞：8)

# 题意
这道题要输出小呆完成整个游戏至少需要多少时间以及要经过的所有可能的剧情结束点（按升序输出）.

注意！！！

这道题有几个地方没有说清楚

- ~~完成整个游戏至少需要多少时间~~指从剧情开始到结局所需要的最长时间,即求最长路
- 所有剧情结束点不是所有结点,所以所有结点个数为n+1
- 根据i(0<i<=100),j(0<j<=100)可知剧情开始的结点为1,剧情结局的结点为n
- 经过的所有可能的剧情结束点是指这个最长路的路径,但是最长路有时候并不是只有一个,所以还要输出其他最长路,最后注意升序输出
# 思路
经过分析可得这道题是求最长路问题,但是这道题给出的图是非常特别的,是[有向无环图](https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE/10972513?fr=aladdin)(DAG图),所以我想到了用[拓扑排序](https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807?fr=aladdin).

根据结点的拓扑排序次序来对带权重的DAG图 G=( V , E )进行边的松弛操作,我们便可以在 θ ( V + E )时间内计算出从单个源结点到所有结点的~~最短路径~~最长路径.

在DAG图中即使存在权重为负值的边,但因为没有权重为负值的环路,~~最短路径~~最长路径都是存在的,但因为本题数据权重都是正的,这个性质可有可无

# 代码

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<vector>
#define maxm 1020
#define maxn 1210
#define inf -0x3f3f3f3f
using namespace std;
struct EDGE
{
	int next;
	int to;
	int w;
} edge[maxm];
struct REDGE
{
	int next;
	int to;
} redge[maxm];
int node[maxn];
int head[maxn],rhead[maxn],in[maxn];
//优先级队列:从小到大 
priority_queue<int,vector<int>,greater<int> > q;
queue<int> q1;
vector<int> v;
int n,m,cnt;
int ans;
void add(int u,int v,int w)
{
	edge[++cnt].next=head[u];
	edge[cnt].to=v;
	edge[cnt].w=w;
	redge[cnt].next=rhead[v];
	redge[cnt].to=u;
	head[u]=cnt;
	rhead[v]=cnt;
}
//拓扑排序 
void topsort()
{
	for(int i=1; i<=n; i++)
		if(in[i]==0)
			q.push(i);
	while(!q.empty())
	{
		int p=q.top();
		q.pop();
		v.push_back(p);
		for(int i=head[p]; i!=0; i=edge[i].next)
		{
			int u=edge[i].to;
			in[u]--;
			if(in[u]==0)
				q1.push(u);
		}
		if(q.empty())
		{
			while(!q1.empty())
			{
				int p=q1.front();
				q1.pop();
				q.push(p);
			}
		}

	}
}
void init()
{
	for(int i=1; i<=n; i++)
		node[i]=inf;
	node[1]=0;
}
//松弛操作 
void relax(int u,int v,int w)
{
	if(node[u]+w>node[v])
		node[v]=node[u]+w;
}
int main()
{
	int p;
	int o1,o2,o3,p1;
	cin>>n>>m;
	//因为n是所有剧情结束点,所以所有剧情点为n+1 
	n++;
	for(int i=1; i<=m; i++)
	{
		cin>>o1>>o2>>o3;
		add(o1,o2,o3);
		in[o2]++;
	}
	topsort();
	init();
	//对每个结点发出的所有边进行松弛操作 
	for(int i=0; i<n; i++)
		for(int j=head[v[i]]; j!=0; j=edge[j].next)
			relax(v[i],edge[j].to,edge[j].w);
//	for(int i=0;i<v.size();i++)
//		cout<<v[i]<<" ";
//	cout<<endl;
	//输出最长路径 
	cout<<node[n]<<endl;
	/*
	因为本题要输出所有最长路径
	所以我就建了一个逆向链式前向星方便遍历
	优先级队列q存放所有最长路径(含相同元素) 
	*/ 
	q.push(n);
	while(1)
	{
		p=q.top();
		if(p==1)
			break;
		for(int i=rhead[p]; i!=0; i=redge[i].next)
		{
			for(int j=head[redge[i].to]; j!=0; j=edge[j].next)
			{
				if(edge[j].to==p)
				{
					//判断这条路是否为最长路的一条边 
					if(node[redge[i].to]+edge[j].w==node[p])
					{
						q.push(redge[i].to);
						break;
					}
				}
			}
		}
	}
	//输出(相同元素只输出一次) 
	p=inf;
	while(!q.empty())
	{
		if(q.top()!=p)
		{
			cout<<q.top()<<" ";
			p=q.top();
		}
		q.pop();
	}
	return 0;
}



---

## 作者：天才颓废学家 (赞：5)

# P1476题解
## 1. 前言
双语题解（ C++ / Pascal ）

对于 Floyd 算法有较为详细的教学，适合新手
## 2. 题意
“为了体验游戏的完整性，小呆决定要看到所有的分支剧情——完成所有的任务。”——题面。

因为**不同的支线可以同时进行**，所以这是让我们求**最长路**。

最长路怎么求呢？蒟蒻只会 **Floyd** 。一看数据范围：$0<n<100,\;\;0<m\leq120\;$。稳了！就是你！
## 3. Floyd 算法简介
### 定义及特点
“ Floyd 算法又称为**插点法**，是一种用于寻找给定的加权图中**多源点之间最短（长）路径**的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。”——360百科

 Floyd 算法是基于 dp 思想（三维 dp 实在不怎么高效）的解决**多源多汇**最短（长）路问题的算法。可以正确处理**无向图**或**有向图**或**带负权的图** 的最短路径问题，同时也被用于计算有向图的传递闭包。

简单来说就是**码量最少、查错最容易、最简单**的最短（长）路算法。 但是它的算法复杂度为 $O(n^3)$ **极易爆炸**，主要是因为它求出了**每两个点之间的最短（长）路径**。当然也有很多题目需要求出每两个点之间的最短（长）路径，即多源多汇问题。
## 4. 代码实现
 Floyd 算法需要枚举三个点，及**起点**、**终点**和**中间点**，如果从起点出发经过另一个点再到终点比原先更短，则替换。

如图 1

![图 1](https://cdn.luogu.com.cn/upload/image_hosting/7jvgo6cp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
###### 图 1

一开始 $f_{1,2} = 5$，但$f_{1,3} + f_{3,2} = 3 < f_{1,2}$ ，所以 $f_{1,2}$ 更新为3。

当循环结束时，f数组中将存有**任意两个可到达的点之间的最短（长）路径**。

因此，我们可以得到 **Floyd 算法伪代码**
```
for k = 1 ~ n 注意：一定要先枚举中间点 k !（划重点）
   for i = 1 ~ n
       for j = 1 ~ n
           if (三点不重复)
               f[i][j] = max{f[i][j], f[i][k] + f[k][j]}
```
## 5. 本题的具体做法
如果你已经知道并熟练掌握了以上内容，那么这题对你来说也就不是问题了。因为这就是个 Floyd **求最长路**的~~板子~~题！

这里主要说说几个坑点

+ 这道题输入的是**有向边**，**有向边**！所以什么$f_{j,i},f_{k,i}\;$不能乱写！

+ 这道题输入的 n 是有 n 个**剧情结束点而非总结点数**！所以 **n 要加1**

+ 再就是所有可能的剧情结束点要**按升序输出**（不会真有人~~傻到~~降序输出吧？）。

给张图吧。

本题的样例如图 2

![](https://cdn.luogu.com.cn/upload/image_hosting/v0v5q9bi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
###### 图 2

避过了这几个坑，做题应该是十分顺畅的，推荐先去**自行实现**。实在调不出来再看本蒟蒻的代码。

### C++版本

```cpp
#include<bits/stdc++.h>
using namespace std;
//快读
inline int read(){
    int x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)){
        if (ch == '-')
            f = -1;
            ch = getchar();
    }
    while (isdigit(ch)){
        x = x * 10 + ch -48;
        ch = getchar();
    }
    return x * f;
}
//快输
inline void write(int x){
    if (x < 0){
        putchar('-');
        write(-x);
        return;
    }
    if (x >= 10)
        write(x / 10);
    putchar(x % 10 + 48);
    return;
}
inline void writeln(int x){
    write(x);
    puts("");
    return;
}
inline void writesp(int x){
    write(x);
    putchar(' ');
    return;
}
//相信我，它们真的有用！（人丑常数大真实现状）
int f[199][199];
signed main(){
    int n = read(), m = read();
    n ++; //划重点
    memset(f, 0, sizeof(f));
    for (int i = 1; i <= m; ++ i)
    f[read()][read()] = read();
    //Floyd具体解释见上，这里不再赘述
    for (int k = 1; k <= n; ++ k) //划重点
        for (int i = 1; i <= n; ++ i)
            if (i != k)
                for (int j = 1; j <= n; ++ j)
                    if (i != j && k != j && f[i][k] && f[k][j])
                        f[i][j] = max(f[i][j], f[i][k] + f[k][j]);
    writeln(f[1][n]); //输出最长路径
    for (int i = 1; i <= n; ++ i)
        if (f[1][i] + f[i][n] == f[1][n])
            writesp(i); //输出所有可能的答案
    return 0;
} //码风略丑，见谅
```
### Pascal版本
注释见上
```pascal
uses math;
var
 n,m,i,j,x,y,z,k:longint;
 f:array[0..199,0..199] of longint;
begin
 read(n,m);
 for i:=1 to m do
  begin
   read(x,y,z);
   f[x,y]:=z;
  end;
 inc(n);
 for k:=1 to n do
  for i:=1 to n do
   if k<>i then
    for j:=1 to n do
     if (i<>j) and (k<>j) and (f[i,k]<>0) and (f[k,j]<>0) then
      f[i,j]:=max(f[i,j],f[i,k]+f[k,j]);
 writeln(f[1,n]);
 for i:=1 to n do
  if f[1,i]+f[i,n]=f[1,n] then
   write(i,' ');
end.
```

~~似乎跑 n 边堆优化 dij 更快吧（小声说话）~~
## 6. 随便扔几道题吧
[P2491 [USACO08JAN]Cow Contest S](https://www.luogu.com.cn/problem/P2419)

[P6175 无向图的最小环问题](https://www.luogu.com.cn/problem/P6175)

[P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)

---

## 作者：syf2008 (赞：3)

这题其实数据比较水

如果数据不水
floyd复杂度是O(1000000)，明显是过不了的
~~(吸氧+快读+优化就能过)~~

所以要用拓扑排序

先上floyd
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[105][105],u,v,b;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{cin>>u>>v>>b;
	a[u][v]=b;}
	for(int k=1;k<=n+1;k++)
	for(int i=1;i<=n+1;i++)
   	for(int j=1;j<=n+1;j++)
   	if(i!=j&&j!=k&&a[i][k]&&a[k][j])
   	a[i][j]=max(a[i][j],a[i][k]+a[k][j]);
   	cout<<a[1][n+1]<<endl;
	for(int i=1;i<=n+1;i++)
	if(a[1][i]+a[i][n+1]==a[1][n+1])
  	cout<<i<<" ";
	return 0;
}
```
拓扑排序
```cpp
#include<bits/stdc++.h>
#define inf -0x3f3f3f3f
using namespace std;
struct ss
{
	int next,to,w;
}a[1005];
struct ss1
{
	int next,to;
}a1[1005];
int node[1205],h[1205],h1[1205],in[1205],n,m,cnt,ans;
priority_queue<int,vector<int>,greater<int> >q;//优先队列
queue<int>q1;
vector<int>v;
void add(int u,int v,int w)
{
	a[++cnt].next=h[u];
	a[cnt].to=v;
	a[cnt].w=w;
	a1[cnt].next=h1[v];
	a1[cnt].to=u;
	h[u]=cnt;
	h1[v]=cnt;
}
void tsort()//拓扑排序 
{
	for(int i=1;i<=n;i++)
	if(in[i]==0)
	q.push(i);
	while(!q.empty())
	{
	int p=q.top();
	q.pop();
	v.push_back(p);
	for(int i=h[p];i!=0;i=a[i].next)
	{
	int u=a[i].to;
	in[u]--;
	if(in[u]==0)
	q1.push(u);
	}
	if(q.empty())
	while(!q1.empty())
	{
	int p=q1.front();
	q1.pop();
	q.push(p);
	}
	}
}
void song()//松弛操作
{
	for(int i=1;i<=n;i++)
	node[i]=inf;
	node[1]=0;
}
void relax(int u,int v,int w)
{
	if(node[u]+w>node[v])
	node[v]=node[u]+w;
}
int main()
{
	int p,o1,o2,o3,p1;
	cin>>n>>m;
	n++;//因为n是所有剧情结束点,所以所有剧情点为n+1
	for(int i=1;i<=m;i++)
	{
	cin>>o1>>o2>>o3;
	add(o1,o2,o3);
	in[o2]++;
	}
	tsort();
	song();//对每个结点发出的所有边进行松弛操作 
	for(int i=0;i<n;i++)
	for(int j=h[v[i]];j!=0;j=a[j].next)
	relax(v[i],a[j].to,a[j].w);
	cout<<node[n]<<endl;//输出最长路径
	q.push(n);
	while(1)
	{
	p=q.top();
	if(p==1)
	break;
	for(int i=h1[p];i!=0;i=a1[i].next)
	for(int j=h[a1[i].to];j!=0;j=a[j].next)
	if(a[j].to==p)//判断这条路是否为最长路的一条边
	if(node[a1[i].to]+a[j].w==node[p])
	{q.push(a1[i].to);
	break;}
	}
	p=inf;
	while(!q.empty())
	{if(q.top()!=p)//去重 
	{cout<<q.top()<<" ";
	p=q.top();}
	q.pop();}
	return 0;
}

```

---

## 作者：万弘 (赞：2)

这题数据<=100确实可能令人想到Floyd,不过我认为此题可以用拓扑计数

首先,用拓扑需要保证图中没有环,根据题意,若有环则无法到达每一个点,与要到达每一个点矛盾,所以图中无环

设`f[v]为到达v点所需用时,u->v为一条由u到v的边,则有`
$$f[v]=\max_{u->v}f[u]+w(u->v)$$

然后求一下f[1~n+1]的最大值(我也不知道为什么到n+1),就是第一问.

第二问只要在记录f时记录前驱pre[v],然后从最大的点往前找并将这个序列按升序排列即可

时间复杂度$O(n+m)$


---

## 作者：Elma_ (赞：1)

## Description
[题目描述](https://www.luogu.com.cn/problem/P1476)

## Solution
第一问就是求最长路的问题，做法显然。

至于为什么是最长路？注意到题目描述中“**至少**”而不是“**最少**”。

做题前养成先看数据范围的好习惯，~~可以骗到很多分~~，这题$0<n<100$的数据范围，用$Floyed$完全没有问题。

还要注意一点：是$n$个结束点，不是$n$个点，共有$n+1$个点，所以我们要求的是$dis(1, n+1)$

对于第二问，枚举每个点，判断$dis(1,i)+dis(i,n+1)$是否等于$dis(1,n+1)$，如果相等就证明点$i$在$dis(1, n+1)$的路线上。

这题数据很小，所以可以用邻接矩阵存图。

## Code

```
#include <iostream>
#include <algorithm>
#define maxn 105
using namespace std;

int dis[maxn][maxn];
int n, m;

void work()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u, v, w;
		cin>>u>>v>>w;
		dis[u][v] = w;
        	//注意是单向边，只存一次
	}
	
	for(int k=1;k<=n+1;k++)
		for(int i=1;i<=n+1;i++)
			for(int j=1;j<=n+1;j++)
				if(i != k && j != k && dis[i][k] != 0 && dis[k][j] != 0)
					dis[i][j] = max(dis[i][j], dis[i][k]+dis[k][j]);//求最长路
	
	cout<<dis[1][n+1]<<endl;
	
	for(int i=1;i<=n+1;i++)
		if(dis[1][i]+dis[i][n+1] == dis[1][n+1])
        //判断是否在最长路上
			cout<<i<<" ";
			
	cout<<endl;
	return;
}

int main(void)
{
	work();
	return 0;//AC~
}
```


---

## 作者：SUNCHAOYI (赞：1)

**仔细看题不难发现这是一道计算最短路的题目。题目数据范围很小，所以用最简单的Floyed即可**

**首先输入（单向边），然后flyed求最短路，输出，最后是完成题目附加的要求**

**只要循环设置断点，然后把分成的两段相加看看是否相等，若相等就输出**

------------

```
#include <iostream>
using namespace std;
const int MAX = 100;
int dis[MAX][MAX];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i = 1;i <= m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		dis[x][y] = z;//存边 
	}
	for(int i = 1;i <= n + 1;i++)//找最短路 
		for(int j = 1;j <= n + 1;j++)
			for(int k = 1;k <= n + 1;k++)
				if(i != k && j != k && dis[j][i] != 0 && dis[i][k] != 0)
					dis[j][k] = max(dis[j][k],dis[j][i] + dis[i][k]);
	int k = dis[1][n + 1];
	cout<<k<<endl;
	for(int i = 1;i <= n + 1;i++)//枚举可能情况 
		if(dis[1][i] + dis[i][n + 1] == k)cout<<i<<" ";
	cout<<endl; 
	return 0;
}
```


---

## 作者：watermonster (赞：1)

## 题意:
1.输出1到n+1的最长路大小

2.升序输出所有可能在最长路上的点

#### 何以见得？

“完成整个游戏至少需要多少时间”即最长路

“要经过的所有可能的剧情结束点”即所有可能在最长路上的点

## 解法：
第一问的算法很明显。对于第二问，如果起点到i号点最长路加上终点到i号最长路等于起点到终点的最长路，那么i号点则可能是最长路上的点。

如果用$dis[0][i]$表示起点到i号点的最长路，用$dis[1][i]$表示终点到i号点的最长路，判断条件则为：$dis[0][i]+dis[1][i]==dis[0][n+1]$

## 注意：
原图为有向图，如果要求终点到各点的最长路则要建反向图。如果用链式前向星建双向边，那么边编号为奇数(i&1==1)则是正向边，偶数(i&1==0)则为反向边。
## 蒟蒻代码：
```cpp
#include <queue>
#include <cstdio>
using namespace std;
#define il inline
#define re register
#define isdigit(ch) (ch>='0'&&ch<='9')
const int N=110;
const int M=220;

il void read(int &x)
{
	x=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+ch-48,ch=getchar();
}
il void write(int x)
{
	if(x/10) write(x/10);
	putchar(x%10+48);
}

int n,m,u,v,w;

int cnt,h[N];
struct edge{int v,w,nxt;}e[M<<1];
il void add(int u,int v,int w){e[++cnt]=(edge){v,w,h[u]};h[u]=cnt;}
//链式前向星存图

int dis[2][N];
bool inque[N];
il void spfa(int s,int p)
{
	queue<int>q;q.push(s);
	while(!q.empty())
	{
		u=q.front();q.pop();inque[u]=false;
		for(re int i=h[u];i;i=e[i].nxt)
		{
			if((p^(i&1))&&dis[p][v=e[i].v]<dis[p][u]+e[i].w)
            //第一个条件：正向图只能走正向边，反向图只能走反向边
			{
				dis[p][v]=dis[p][u]+e[i].w;
				if(!inque[v]) q.push(v),inque[v]=true;
			}
		}
	}
}

int main()
{
	read(n),read(m);
	for(re int i=1;i<=m;++i)
	{
		read(u),read(v),read(w);
		add(u,v,w);add(v,u,w);//同时将反向图建好
	}
	spfa(1,0);spfa(n+1,1);//两次最长路
	write(dis[0][n+1]);puts("");//第一问答案
	for(re int i=1;i<=n+1;++i)
		if(dis[0][i]+dis[1][i]==dis[0][n+1])//i为最长路上的点
			write(i),putchar(' ');
	return 0;
}
```

---

## 作者：何炳儒 (赞：1)

这里是求最长路并且结点个数+1

1、存储图：看数据量，这里是100，邻接矩阵

2、floyed优化：I,j,k不等并且用来dp的值有值

3、输出优化点：更新过别人的点

下面上蒟蒻的代码：

```cpp
#include <bits/stdc++.h>//万能库
const int N=1e2+10;
using namespace std;
int dp[N][N],n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        dp[u][v]=w;
    }
    for(int k=1;k<=n+1;k++){
        for(int i=1;i<=n+1;i++){
            for(int j=1;j<=n+1;j++){
                if(i!=j&&j!=k&&dp[i][k]&&dp[k][j]){
                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]);
                }
            }
        }
    }
    cout<<dp[1][n+1]<<endl;
    for(int k=1;k<=n+1;k++){
        if(dp[1][n+1]==dp[1][k]+dp[k][n+1])
            cout<<k<<" ";
    }
    cout<<endl;    
    return 0;
}
```

---

## 作者：青丝、暮成雪 (赞：1)

这是一道用弗洛伊德来求最长路的题（一开始没搞懂题意的我被题目直接弄晕.....）

直接求1到n+1的最长路即可（注意：是n+1！是n+1！是n+1！重要事情说三遍）

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int dp[110][110],n,m;
int main()
{
        scanf("%d%d",&n,&m);
            for(int i=1;i<=m;i++)
            {
                        int x,y,z;
                        scanf("%d%d%d",&x,&y,&z);
                        dp[x][y]=z;
            }
            for(int k=1;k<=n+1;k++)
            for(int i=1;i<=n+1;i++)
            for(int j=1;j<=n+1;j++)
            {
                        if(i!=j&&j!=k&&dp[i][k]&&dp[k][j])
                        if(dp[i][j]<dp[i][k]+dp[k][j])
                        dp[i][j]=dp[i][k]+dp[k][j];
            }
            printf("%d\n1 ",dp[1][n+1]);
            for(int i=2;i<=n+1;i++)
            if(dp[1][i]+dp[i][n+1]==dp[1][n+1])
            printf("%d ",i);
            return 0;
}
```

---

## 作者：Marginal_world (赞：0)

题意分析：要输出小呆完成整个游戏至少需要多少时间以及要经过的所有可能的剧情结束点。

注意点：所有剧情结束点不是所有结点，所以所有结点个数要加一。

由于良心数据，本题可以用弗洛伊德求解。

算出最长路，输出即可。

代码：
```cpp
#include <iostream>
using namespace std;

int map[101][101],n,m,a,b,c;

int main()
{
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        cin >> a >> b >> c;
        map[a][b] = c;
    }
    for(int k=1;k<=n+1;k++) //弗洛伊德模板
        for(int i=1;i<=n+1;i++)
            for (int j = 1; j <= n + 1; j++)
            {
                if (i != j && j != k && map[i][k] && map[k][j])
                    if (map[i][j] < map[i][k] + map[k][j])
                        map[i][j] = map[i][k] + map[k][j];
            }
    cout << map[1][n + 1]<<endl;
    for (int i = 1; i <= n + 1; i++)
        if (map[1][i] + map[i][n + 1] == map[1][n + 1])
            cout << i <<" ";
    return 0;
}

```
希望能帮助到大家。

---

## 作者：一只小H (赞：0)

## 题意简述

一张有向无环图，求从开始点到结束点至少需要的时间，并输出所有经过的点。

输入：

* $n$ 表示**结束点个数**，$m$ 表示边数。
* $m$ 条边以及权值。
* $0<n<100$,$0<m<=120$。

输出：

* 需要的时间。
* 经过的点。（按升序输出）

## 题目分析

![样例](https://cdn.luogu.com.cn/upload/image_hosting/tj94sqv8.png)

由于要求的是“完成整个游戏**至少**需要多少时间”，所以需要求最长路。

因为数据范围较小，所以直接使用 Floyd 即可。

注意 $n$ 是指**结束点的个数**不是**结点的个数**，结点的个数要加上开始的点，所以要**加一**。

关键在于如何求经过的点。首先开始的点和结束的点是肯定会经过的，所以直接输出即可。然后枚举中间的每一个点，如果它到开始的点的距离加上它到结束的点的距离等于从开始的点到结束的点的距离，那么它就在最长路上，需要进行输出。

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;          //n表示结点个数，m表示边个数
int G[2333][2333]; //邻接矩阵存图
int main()
{
    int a, b, c; //用于输入
    cin >> n >> m;
    n++; //注意输入的是剧情结束点，不包括开始的点，所以要加1

    /*初始化*/
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            G[i][j] = -2333333;
        }
    }

    /*连边*/
    for (int i = 1; i <= m; ++i)
    {
        cin >> a >> b >> c;
        G[a][b] = max(G[a][b], c);
    }

    /*Floyd求最长路*/
    for (int k = 1; k <= n; ++k)
    {
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                G[i][j] = max(G[i][j], G[i][k] + G[k][j]);
            }
        }
    }

    cout << G[1][n] << endl; //输出长度

    cout << 1 << " "; //出发点肯定经过

    for (int i = 2; i < n; ++i) //枚举中间的每一个点
    {
        if (G[1][i] + G[i][n] == G[1][n]) //如果是最长路上的点那么就输出
        {
            cout << i << " ";
        }
    }

    cout << n; //结束点也同样肯定经过
    return 0;
}
```


---


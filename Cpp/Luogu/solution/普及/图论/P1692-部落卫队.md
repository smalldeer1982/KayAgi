# 部落卫队

## 题目描述

原始部落 byteland 中的居民们为了争夺有限的资源，经常发生冲突。几乎每个居民都有他的仇敌。部落酋长为了组织一支保卫部落的队伍，希望从部落的居民中选出最多的居民入伍，并保证队伍中任何 $2$ 个人都不是仇敌。

给定 byteland 部落中居民间的仇敌关系，编程计算组成部落卫队的最佳方案。若有多种方案可行，输出字典序最大的方案。

## 说明/提示

对于 $60\%$ 数据：$n \le 20$，$m \le 100$。

对于所有数据：$n \le 100,m \le 3000$。数据从所有合法数据从随机均匀取样。

## 样例 #1

### 输入

```
7  10
1  2
1  4
2  4
2  3
2  5
2  6
3  5
3  6
4  5
5  6```

### 输出

```
3
1 0 1 0 0 0 1
```

# 题解

## 作者：jojoxie (赞：42)

这道题我用了最普通的深搜来做

每个人挨个尝试，如果这个人与队中的任何人为仇敌则只能不选，否则尝试选与不选两种情况

听说不剪枝会TLE，但似乎没怎么剪枝还是AC了
```
#include <stdio.h>

int m, n, a[105];

int ch[105][105];//标记两个人是否是仇敌关系 

int x[105], tot = 0, s = 0;

void dfs(int k) {
	if(k > n) {
		if(s <= tot) {
			return;
		}
		tot = s;
		for(int j = 1; j <= n; j++) {
			a[j] = x[j];
		}
		return;
	}
	
	int check = 1;
	
	for(int t = 1; t < k; t++) {
		if(ch[t][k] && x[t]) {
        //如果现在已经选择的人中有人与第k个人为仇敌关系，则第k个人
        不能选 
			check = 0;
			break;
		}
	}
	
	if(check) {//如果第k个人可以选 
		x[k] = 1;
		s++;
		dfs(k + 1);//尝试选第k个人的情况 
		s--;
		x[k] = 0;
	}
	
	dfs(k + 1);//尝试不选第k个人的情况 
    
    return;
}

int main() {
	scanf("%d%d", &n, &m);
	
	int u, v;
	
	for(int i = 1; i <= m; i++) {
		scanf("%d%d", &u, &v);
		ch[u][v] = 1;//标记u和v的仇敌关系 
		ch[v][u] = 1;
	}
	
	dfs(1);//从第一个人开始搜索 
	
	printf("%d\n", tot);
	
	for(int i = 1; i <= n; i++) {
		printf("%d ", a[i]);
	}
	
	return 0;
}
```

---

## 作者：litble (赞：30)

这道题是很简单的搜索。

可以加一个小小的最优性剪枝，就是假如把后面所有能选的人都选上，还是比ans小的话，剪枝。

这样就可以AC了。

其实我本来还想用位运算优化的，奈何100的数据范围存不下。

AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int read(){//读入优化
    int q=0;char ch=' ';
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return q;
}
bool lu[105][105];
int b[105],c[105];int ans,n,m;
void dfs(int x,int num){//x:当前搜索的位置，num:已经选了几个人
    if(x==n+1){
        if(num>ans){//更新答案
            ans=num;
            for(int i=1;i<=n;i++)c[i]=b[i];
        }
        return;
    }
    if(num+n-x+1<ans)return;//小小的剪枝
    int bj=0;
    for(int i=1;i<=x-1;i++)//判断可不可以选
        if(b[i]&&lu[x][i]){bj=1;break;}
    if(!bj){b[x]=1;dfs(x+1,num+1);b[x]=0;}
    dfs(x+1,num);
}
int main()
{
    int i,j,x,y;
    n=read();m=read();
    for(i=1;i<=m;i++){x=read();y=read();lu[x][y]=lu[y][x]=1;}
    dfs(1,0);
    printf("%d\n",ans);
    for(i=1;i<=n;i++)printf("%d ",c[i]);
    return 0;
}
```
位运算优化（如果你拿去交会WA一个点因为存不下！！！）

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define ull unsigned long long
int read(){
    int q=0;char ch=' ';
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return q;
}
ull ma[105],s[105];
int b[105],c[105];int ans,n,m;
void dfs(int x,int num,ull zt){//当前枚举位置，选择人数，当前选择的状态
    if(x==n+1){
        if(num>ans){//更新状态
            ans=num;
            for(int i=1;i<=n;i++)c[i]=b[i];
        }
        return;
    }
    if(num+n-x+1<ans)return;//剪枝
    ull kl=zt&ma[x];//位运算判断
    if(!kl){b[x]=1;dfs(x+1,num+1,zt|s[x]);b[x]=0;}
    dfs(x+1,num,zt);
}
int main()
{
    int i,j,x,y;
    n=read();m=read();
    s[1]=1;for(i=2;i<=n;i++)s[i]=s[i-1]*2;
    for(i=1;i<=m;i++){
        x=read();y=read();
        ma[x]|=s[y];ma[y]|=s[x];//用位运算保存关系
    }
    dfs(1,0,0);
    printf("%d\n",ans);
    for(i=1;i<=n;i++)printf("%d ",c[i]);
    return 0;
}
```

---

## 作者：逆时针的记忆 (赞：19)

## 你还在为你的AC而高兴吗?或者你还是在为你的TLE烦恼?

在此宣传[我的博客](https://www.luogu.org/blog/ha-ha/#)

>看到大家说其他oj过不了，我将为大家提供三种题解，一种入门搜索，一种好理解，一种能过~~大数据~~（小数据）

>入门版,是不是很简单

```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int ans[155],res,use[155],n,m;
bool map[155][155];

bool js(int x)//有仇敌在里面你就不能进，返回假，否则返回真
{
	for (int i=1; i<=n; i++)
		if (use[i]&&map[x][i]) return false;
	return true;
}

void dfs(int p,int rs)
{
	int i;
	if (p>n)//搜完为止
	{
		if (rs>res)//人更多?那咱交换
		{
			res=rs;
			for (i=1; i<=n; i++) ans[i]=use[i];
		}
		return;
	}
	for (i=1; i<=n; i++)//一个一个判断慢不满足条件
	{
		if (!use[i]&&js(i))
		{
			use[i]=1;//use判断有没有进队,用int比bool方便一些
			dfs(i+1,rs+1);
			use[i]=0;
		}
	}
    dfs(p+1,rs);
}

int main()
{
	int i,j,x,y;
	scanf ("%d%d",&n,&m);
	for (i=1; i<=m; i++)
	{
		scanf ("%d%d",&x,&y);
		map[x][y]=map[y][x]=1;//双向边，map可能重名，但不要紧，没开<map>
	}
	dfs(1,0);//第一个人开始搜，队里没人
	printf ("%d\n",res);
	for (i=1; i<=n; i++) printf ("%d ",ans[i]);
	printf ("\n");
	return 0;
}
```

>先别复制，你会T3组，让我们优化优化,我们在搜过一个人后可以不用从头再搜，所以上面的循环可以改一下，见下。


>简单版，来自我自己，看了榜首大佬的，差不多，没减枝，但我还是大胆（不知羞耻）地发上题解，解释还是要吧，不然过不了管理员的慧眼，想必大家看了其他题解，都很清楚,快读我删了，不然就和其他题解没什么差别了


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int ans[155],res,use[155],n,m;
bool map[155][155];

bool js(int x)//有仇敌在里面你就不能进，返回假，否则返回真
{
	for (int i=1; i<=n; i++)
		if (use[i]&&map[x][i]) return false;
	return true;
}

void dfs(int p,int rs)//p候选人，rs人数
{
	int i;
	if (p>n)//搜索完n个人
	{
		if (rs>res)//更新答案
		{
			res=rs;
			for (i=1; i<=n; i++) ans[i]=use[i];
		}
		return;
	}
	if (js(p)) {use[p]=1; dfs(p+1,rs+1); use[p]=0;}//use判断有没有进队
	dfs (p+1,rs);//至于这里为什么不加else，因为所有情况都要考虑
}

int main()
{
//	freopen ("inde.in","r",stdin);
//	freopen ("inde.out","w",stdout);
	int i,j,x,y;
	scanf ("%d%d",&n,&m);
	for (i=1; i<=m; i++)
	{
		scanf ("%d%d",&x,&y);
		map[x][y]=map[y][x]=1;//双向边，map可能重名，但不要紧，没开<map>
	}
	dfs(1,0);//第一个人开始搜，队里没人
	printf ("%d\n",res);
	for (i=1; i<=n; i++) printf ("%d ",ans[i]);
	printf ("\n");
	fclose (stdin); fclose (stdout);
	return 0;
}
```
>可以在你谷上A，但其他数据大一点的ojA不了,这就需要下一篇——

>快速版本，我是光明正大(~~偷偷地~~)向大佬@Allen_D 请教的. 

>[大佬&&mz传送门](https://www.luogu.org/space/show?uid=141460)在这

>如果一个人他进了卫队，就让他的敌人全部不能进卫队谁让我们有仇,f1数组就是这个意思，快读已经省略。


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=155;
int n,m,ans,tmp[N],sum[N],tot,head[N],flag[N];//tmp同上use，sum同上ans
 struct ss
{
	int v,nx;
}f[12005];//边集数组结构体

 void dfs(int num,int res,int t,int flag[])
{
	if (num==n)
	{
		if (res>ans) //同上，不再赘述
		{
			for (int i=1; i<=n; i++) sum[i]=tmp[i]; 
			ans=res;
		}
		return;
	}
	int f1[N];
	for (int i=t; i<=n; i++)
		if (!flag[i]&&!tmp[i])//tmp可以不要，加了会变慢，但便于理解，防止和f1弄混
		{
			tmp[i]=1;
			int num1=num+1;//这是先进的这个人，
			for (int j=1; j<=n; j++) f1[j]=flag[j];//判断仇人是哪些
			for (int j=head[i]; j>0; j=f[j].nx)
				if (!flag[f[j].v]) f1[f[j].v]=1,num1++;//是仇人的全进不了，冤家路窄啊dfs(num1,res+1,i+1,f1);
			tmp[i]=0;
		}
}

 int main()
{
	scanf("%d%d",&n,&m);
	int a,b;
	for (int i=1; i<=m; i++)
	{
		scanf("%d%d",&a,&b);
		f[++tot].nx=head[a]; head[a]=tot; f[tot].v=b;
		f[++tot].nx=head[b]; head[b]=tot; f[tot].v=a;
	}//边集数组建边，这题要建双向边
	dfs(0,0,1,flag);//搜了0个人，队里有0个人，从第一个人开始搜，flag是个数组，睁大眼睛些
	printf("%d\n",ans);
	for (int i=1; i<=n; i++) printf("%d ",sum[i]); printf("\n");
	return 0;
}
```


---

## 作者：wlj_55 (赞：10)

~~众所周知，玄学是万能的~~
### 前言
此题正解为dfs，但我希望我的做法可以为您提供一种新的思路。
### 引入：random_shuffle函数
使用方法：
```cpp
random_shuffle(a+1,a+n+1);
```
得到一个元素种类与原数组相同，但顺序被打乱的新数组。

测试如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/4js216tz.png)

时间复杂度：$O(n)$
### 正题
让我们回到本题，题目要求是在$n$人中选出一些人，使得他们之间没有有仇的人。

看一下数据范围，发现$n\le 100$，但dfs+剪枝也是一个玄学的东西，不知道它能否过掉所有的数据点，那么我们就可以祭出我们的玄学随机大法——random_shuffle

### 做法
我们每次枚举一个选人的顺序，然后从头到尾选，如果能选，我们就选上这个人，并且将其仇敌全部标记，然后更新我们的答案。做一次的准确率太差，经过本人实测，重复次数开在$200000$次左右即可做到既不超时(900+ms)，又保证准确率。当然，如果脸白的话，重复次数$1e4-1e5$也是可能过的。
### 注意
由于本题存在多解但没有SPJ，所以用这种做法还需要判断一下字典序，最后取所有答案中字典序最大的输出。

下面献上我的代码
```
#include<bits/stdc++.h>
using namespace std;
int first[100005],nxt[100005],to[100005],tot=0;
void Add(int x,int y){
	nxt[++tot]=first[x];
	first[x]=tot;
	to[tot]=y;
}
int n,m,a[105],vis[105],maxn=-1,ans[105];
bool pd(){
	for(int i=1;i<=n;i++){
		if(vis[i]<ans[i])  return 0;
		if(vis[i]>ans[i])  return 1;
	}
}
int main(){
	srand(time(0));
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		a[i]=i;
	}
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		Add(x,y);
		Add(y,x);
	}
	for(int i=1;i<=200000;i++){
		memset(vis,-1,sizeof(vis));
		random_shuffle(a+1,a+n+1);
		int num=0;
		for(int i=1;i<=n;i++){
			if(vis[a[i]]==-1){
				num++,vis[a[i]]=1;
				for(int e=first[a[i]];e;e=nxt[e]){
					if(vis[to[e]]==-1)  vis[to[e]]=0;
				}
			}
		}
		if(num>maxn){
			maxn=num;
			for(int i=1;i<=n;i++){
				ans[i]=vis[i];
			}
		}
		if(num==maxn){
			if(pd()){
				for(int i=1;i<=n;i++){
					ans[i]=vis[i];
				}
			}
		}
	}
	cout<<maxn<<endl;
	for(int i=1;i<=n;i++){
		cout<<ans[i]<<" ";
	}
}
```
### 后记
此算法并非正解，也有一定可能被卡掉，建议大家在正式考试时除非万不得已，尽量不要使用这种做法。

---

## 作者：百里狂生 (赞：9)

题目链接：https://www.luogu.com.cn/problem/P1692

这道题涉及到了图和深度优先搜索的知识，最主要的问题在于如何储存和判断两个人之间是否存在仇敌关系，还有如何进行搜索等。



------------
**一、图的储存**

我们以5个居民为例，则可以把每一个居民当做一个结点，如果两个人之间没有仇敌关系就用线连接起来，这样就形成了一个图，于是这个问题就转化成了从图中寻找最多的结点，且这些结点之间均有连线，即不是仇敌关系。

那么我们如何储存这样一个图呢？答案是：邻接矩阵。

**邻接矩阵**

邻接矩阵（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中V={v1,v2,…,vn} 。G的邻接矩阵是一个具有下列性质的n阶方阵：

①对无向图而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，有向图则不一定如此。

②在无向图中，任一顶点i的度为第i列（或第i行）所有非零元素的个数，在有向图中顶点i的出度为第i行所有非零元素的个数，而入度为第i列所有非零元素的个数。

③用邻接矩阵法表示图共需要n^2个空间，由于无向图的邻接矩阵一定具有对称关系，所以扣除对角线为零外，仅需要存储上三角形或下三角形的数据即可，因此仅需要n（n-1）/2个空间。

因此在这里可以定义一个二维数组作为一个进阶矩阵：a[301][301]（请大家注意一下数据的范围），其中a[u][v]表示第u个居民和第v个居民之间的关系，用1表示他们两个之间有仇敌关系，0反之。

此时我们有了一个框架来储存这个图，那么怎样使两个结点在邻接矩阵上相连呢？很简单，因为u对v有仇敌关系，反过来，v对u也有仇敌关系，所以：

```cpp
for(int i=1;i<=m;i++)
{
	cin>>u>>v;
	a[u][v]=a[v][u]=1;
} 
```

这样就可以把这个图储存下来了。

那么如何在搜索中判断或寻找这个图呢？我们在下文中讲。

------------
**二、搜索**

整个搜索过程有点像任意的排列，在任意的排列中每一种数字只有选或不选两种状态，在此题种，每一个居民也有选或不选两种状态，因此可以开一个bool数组x[301]来储存每一个居民被选的状态。

我们规定：

```cpp
const int N=301; 
bool x[N];   ///是否将第i个节点加入团中 
bool bestx[N];   ///记录最优解 
int bestn;   ///记录最优值 
int cn;  ///当前已放入团中的节点数量 
int deep;  ///当前搜索的深度 
```
此时一五个居民为例，我们来模拟一次搜索。

（1）、deep=1

**开始搜索第一层**。扩展A结点，首先判断是否满足条件，因为之前还没有选中任何结点，所以满足条件。扩展左分支，让x[1]=1，cn++，cn=1，生成B结点。


那么这个限制条件是什么呢？

1. 这个数没有被选中过，即x[j]！=1.
2. 查看这个人和其他居民的仇敌关系（详见代码）。

```cpp
bool place(int t)  ///判断是否可以把节点t加入团中 
{
	bool ok=true;
	for(int j=1;j<t;j++)  ///节点t与t-1个节点中被选中的节点是否相连 
	{
		if(x[j] && a[t][j]==1)  ///x[j]表示j是被选中的节点，a[t][j]==1 表示t和j是有仇敌关系   
		{
			ok=false;
			break;
		} 
	} 
	return ok;
} 

```
（2）、deep=2

**扩展B结点**。判断t号结点是否符合约束条件，满足条件，扩展左分支，令x[2]=1，cn++，cn=2，生成C结点。


（3）、deep=3

**扩展C结点**。判断t号结点是否符合约束条件，满足条件，扩展左分支，令x[3]=1，cn++，cn=3，生成D结点。


（4）、deep=4

**扩展D结点**。首先判断t号结点是否和前面已选中的结点（1、2、3号）有相连边，（假设）4号和2号没有相连边，不满足约束条件，不能向左扩展分支。判断限界条件cn+fn>bestn，cn=3，fn=n-1=1，bestn=0，满足限界条件，令x[4]=0，生成E结点。


（5）、deep=5

**扩展E结点**。首先判断t号结点是否和前面已选中的结点（1、2、3号）有相连边，（假设）5号和2号没有相连边，不满足约束条件，不能向左扩展分支。判断限界条件cn+fn>bestn，cn=3，fn=n-1=0，bestn=0，满足限界条件，令x[5]=0，生成F结点。


（6）、deep=6

**扩展F结点**。t>n，找到了一个当前的最优解，用bestx[]保存当前最优解为{1,1,1,0,0}，保存当前最优值bestn=cn=3，F结点为死结点。

（8）、deep=5

**向上回溯到E结点**。E结点的左右子树都已经查看了，继续向上回溯到D结点，D结点的左右子树也均已查看，继续回溯到C结点，cn--，cn=2,。因为C结点在生成D结点时，已经执行过cn++，此时应该再减回去。


（9）、deep=3

**重新扩展C结点**。C结点的右子树还没有生成过，根据限界条件cn+fn>bestn，cn=2，fn=n-t=2，beatn=3，向右扩展子树。令x[3]=0，生成G结点。


……

以此类推，一直拓展回到A结点为死结点，不能继续再产生新的子树，搜索结束。

到此，我们成功的模拟了一次dfs的过程，那么这个程序该怎么写呢?

有上述过程不难看出：如果t>n表示已经搜索到了叶子结点，那么记录最优值和最优解，return。否则判断是否满足约束条件（要和限界条件有所区分），如果满足，则拓展左子树，此时左子树上的节点表示能够进入卫队，所以令x[deep]=1，cn++，表示此时的人数增加1,然后dfs(deep+1)继续搜索左子树。当回溯时，cn--。

判断如果满足限界条件，则拓展右子树，此时该子树上的结点不能进入卫队，所以令x[deep]=0，人数不变，dfs(deep+1)继续搜索右子树。



------------
**完整程序**

```cpp
#include<iostream>
#include<string.h>
using namespace std;
const int N=301;
int a[N][N];   ///图用邻接矩阵表示 
bool x[N];   ///是否将第i个节点加入团中 
bool bestx[N];   ///记录最优解 
int bestn;   ///记录最优值 
int cn;  ///当前已放入团中的节点数量 
int n,m;   ///n为图中节点数，m为图中边数 

bool place(int t)  ///判断是否可以把节点t加入团中 
{
	bool ok=true;
	for(int j=1;j<t;j++)  ///节点t与t-1个节点中被选中的节点是否相连 
	{
		if(x[j] && a[t][j]==1)  ///x[j]表示j是被选中的节点，a[t][j]==1 表示t和j是有仇敌关系   
		{
			ok=false;
			break;
		} 
	} 
	return ok;
} 

void dfs(int deep)
{
	if(deep>n)
	{///到达了叶子节点  
		for(int i=1;i<=n;i++)
			bestx[i]=x[i];
		bestn=cn;
		return;
	}
	if(place(deep))  ///满足条件则放入左子树，即把节点t放入团中  
	{
		x[deep]=1;
		cn++;
		dfs(deep+1);
		cn--;  ///回溯   
	} 
	if(cn+n-deep>bestn)  ///放入右子树 
	{
		x[deep]=0;
		dfs(deep+1);
	} 
}

int main()
{
	int u,v;  ///n就是节点数，m数边数  
	cin>>n>>m;
	memset(a,0,sizeof(a));///邻接矩阵里面的数据初始化为 0 
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v;
		a[u][v]=a[v][u]=1;
	} 
	bestn=0;
	cn=0;
	dfs(1);
	cout<<bestn<<endl;
	for(int i=1;i<=n;i++)
		cout<<bestx[i]<<" ";
	return 0;
}
```


------------
**结语**

遇到与图紧密结合的题目是，应当在草稿纸上推演搜索过程，体会深度搜索与回溯的原因及过程，才能写出AC程序。

祝好！

---

## 作者：那一条变阻器 (赞：6)

啊这道题其实暴力就行了，算是一道搜索入门题吧。


------------


搜索变量就应该是当前到哪一位了，然后进行枚举，当前的一位加或者不加，然后知道搜完为止。

判断当前一位可不可以加的时候本来想用vector的，但是没调出来qwq（菜），然后学的第一篇题解惹

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m , ans;
int anses[110] , now[110] , vis[110] , dis[110][110];
void dfs(int step , int sum){	//当前到哪个人了和人数总和 
	if(step == n + 1){
		if(sum > ans){
			ans = sum;
			for(int i = 1; i <= n; i++) anses[i] = now[i];
		}
		return;
	}
	if(n + sum - step + 1 < ans) return;	//剪枝，若剩下的还没有答案多，放弃
	int f = 0;
	for(int i = 1; i <= step - 1; i++)
        if(vis[i] && dis[step][i]){	 
			f = 1; 
			break;
		}
	if(!f){
		vis[step] = 1;
		now[step] = 1;
		dfs(step + 1 , sum + 1);
		now[step] = 0;
		vis[step] = 0;
	}
	dfs(step + 1 , sum);	//！！！！这里不能交换与上面加入这个人的位置，因为在答案一致的情况下字典序优先 
}
int main(){
	cin >> n >> m;
	for(int i = 1; i <= m; i++){
		int x , y;
		cin >> x >> y;
		dis[x][y] = dis[y][x] = 1;
	}
	dfs(1 , 0);
	cout << ans << endl;
	for(int i = 1; i <= n; i++) cout << anses[i] << " ";
	return 0;
}
```

吐槽：多刷点搜索暴力肯定有好处的，就像这次6.6欢乐赛一样，暴力可以拿很多分了

---

## 作者：XZYQvQ (赞：5)

此题搜索

加个最优性剪枝就能过了。

只不过有点悬。。。900+ms

$dfs(i,j)$表示选中了第$i$个人，当前已经选中了$j$个人（$j$个人中不包含第$i$个人）的答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans,ansf[105];
bool book[105][105],flag[105];
void dfs(int a,int b)
{
    if(++b+n-a<=ans)return;
    for(int i=1;i<a;i++)if(flag[i]&book[i][a])return;
    flag[a]=1;for(int i=a+1;i<=n;i++)dfs(i,b);
    if(b>ans){ans=b;for(int i=1;i<=n;i++)ansf[i]=flag[i];}
    flag[a]=0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,a,b;i<=m;i++)scanf("%d%d",&a,&b),book[a][b]=book[b][a]=1;
    for(int i=1;i<=n;i++)dfs(i,0);
    printf("%d\n",ans);
    for(int i=1;i<=n;i++)printf("%d ",ansf[i]);
    return 0;
}
```
优化（我没加）：

1. 用位运算

2. 保存上次搜索答案来最优性剪枝，比上面代码中的最优性剪枝精确


---

## 作者：yyyyyyy (赞：4)

这道题是一道典型的回溯，只要加一点小小的剪枝，保证不会超时

```cpp
var i,n,m,max,x,y,ans:longint;
    a,p:array[1..1000] of 0..1;//a是回溯数组，p是最后输出的最大值数组
        c:array[1..1000,0..1000] of boolean;//c是邻接矩阵
procedure search(y,x:longint);//回溯过程，y是当前判断的数，x是已入队的个数
var i:longint;
    flag:boolean;//flag用来判断当前这个数能不能入队
begin
if (y>N)and(x>max) then//如果当前已经已经判断完所有数且超出最大值，就更新最大值
   begin
   max:=x;
   p:=a;
   exit;//返回上一层
   end;
if (y>n)and(x+n-y<max) then exit;//剪枝，如果现在已有的数加上之后所有的数小于当前最大值，就返回上一层
flag:=true;
for i:=1 to y-1 do
    if (c[y,i]=false)and(a[i]=1) then//如果第y个数和第i个数为仇敌且第i个数已入队，则第y个数不能入队
       begin
       flag:=false;
       break;
       end;
if flag then//如果第y个数可以入队
   begin
   a[y]:=1;//入队
   search(y+1,x+1);//回溯下一个数
   a[y]:=0;//回溯一步
   end;
search(y+1,x);//不入队回溯
end;
begin
{assign(input,'inde.in');
assign(output,'inde.out');
reset(input);
rewrite(output);}
max:=0;
readln(n,m);
fillchar(c,sizeof(c),#1);//邻接矩阵赋初值
for i:=1 to m do//创矩阵
    begin
    readln(x,y);
    c[x,y]:=false;
    c[y,x]:=false;
    end;
search(1,0);//回溯
writeln(max);
for i:=1 to n do write(p[i],' ');
{close(input);
close(output);}
end.

```

---

## 作者：Zkxxxv_h (赞：3)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int ans=0;
int n,m;
int ra[1001][1001],c[1001],b[1001];
void search(int k,int t){//k:当前位置,t:选择的人数 
	if(k>n) {//达到总人数存储答案 
		if(t>ans)
		{
			ans=t;
			for(int i=1;i<=n;i++)
				c[i]=b[i];
		}
		return ;
	}
	if(t+n-k+1<ans) return ;//剪枝
	int bj=0; 
	for(int i=1;i<=n;i++)
		if(b[i]&&ra[k][i]){//判断此居民该不该选 
			bj=1;break;}
	if(bj==0){//选择此居民的情况 
		b[k]=1;search(k+1,t+1);b[k]=0;
	}
	search(k+1,t);//不选的情况 
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		ra[u][v]=1;
		ra[v][u]=1;
	}
	search(1,0);
	cout<<ans<<endl;
	for(int i=1;i<=n;i++)
	cout<<c[i]<<' ';
	return 0
}
```
[评测结果](https://www.luogu.org/recordnew/show/17989659)

---

## 作者：sukimo (赞：2)

看到$n\leq100$的数据，不用想，直接上dfs。由于要输出组成名单，所以用一个数组来储存最优解。题目没有说多种可能性怎么选，所以应该是默认选字典序最小，那么搜索的顺序就要讲究。再加点剪枝就可以过。

```
#include<bits/stdc++.h>
using namespace std;
int n,_max,array[105],rem[105];bool mark[105],hate[105][105];
void dfs(int now,int cnt){
	if(_max<cnt){
		_max=cnt;for(int i=1;i<=cnt;i++)rem[i]=array[i];
	}
	if(now>n||n-now+1+cnt<_max)return;
	for(int i=1;i<=cnt;i++)
		if(hate[array[i]][now]){dfs(now+1,cnt);return;}
	array[cnt+1]=now;dfs(now+1,cnt+1);dfs(now+1,cnt);
}
int main(){
	int m;scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int a,b;scanf("%d%d",&a,&b);hate[min(a,b)][max(a,b)]=1;
	}
	dfs(1,0);
	printf("%d\n",_max);
	for(int i=1;i<=_max;i++)mark[rem[i]]=1;
	for(int i=1;i<=n;i++)printf("%d ",mark[i]);
	return 0;
}
```


---

## 作者：LMSH7 (赞：1)

机房模拟赛题目

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
#include<cmath>
using namespace std;

int n,k,ad[305][305];
int temp[305],ans;//temp存搜索过程中的队列
int s[305],b[305];//s为当前最优队列的方案

void dfs(int x,int y){//x目前搜到第几个人，y目前已经“进队”几个人
    if(x>n){

      if(ans<y){

          ans=y;//如果以前进队的人小于本次进队的人数，则本次进队方案为暂时最佳
          for(int i=1;i<=n;i++){

          s[i]=temp[i];
//           temp[i]=0;
            }//回溯过，不用再赋为0 
        }
        return;
    }
     if((y+n-x+1)<ans){

     return;
     }//优化，如果后面的人都加上还不如之前的进队方案人数多，就直接pass
    if(b[x]==0){    
        for(int i=x+1;i<=n;i++){
       //for(int i=1;i<=n;i++)

            if(ad[x][i]==1)b[i]+=1;     //多个人可能会仇恨到同一个人
            //回溯时就会误改，重点        
        }  
            temp[x]=1;
            dfs(x+1,y+1);
            temp[x]=0;//回溯

        for(int i=x+1;i<=n;i++){

          if(ad[x][i]==1)b[i]-=1;           
        }              
 	}
      dfs(x+1,y);       
    return;
}

int main()
{
	freopen("inde.in","r",stdin);
	freopen("inde.out","w",stdout);
    cin>>n>>k;
    for(int i=1;i<=k;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        ad[a][b]=1;
        ad[b][a]=1;//仇恨关系用二维数组表示
    }
    dfs(1,0);
    cout<<ans<<endl;
    for(int i=1;i<=n;i++)
    {
        printf("%d ",s[i]);
    }
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

---

## 作者：千反田 (赞：1)

一道深搜题

看题解好多dalao都用了好多优化（~~本蒟蒻都不会~~）

抱着试一试的心态打了个爆搜 [~~居然~~过了（356ms）](https://www.luogu.org/recordnew/show/18056851)

我们用hostility数组标记两人之间是否有仇恨

用byteland数组标记当前状态，ansf数组表示答案

~~为啥都这么长啊~~

每次只要byteland里的人数大于ansf

更新答案

```cpp
bool hostility[Num][Num],byteland[N],ansf[N];
```
代码核心：

这个深搜判断比较特别

要把判断拉到前面

循环判断此人是否与他人有仇恨

如果有，标记

```cpp
    bool flag=false;//标记此人是否与他人有仇恨
    for(int i=1;i<=step-1;++i)
    {
        if(byteland[i]&&hostility[step][i])//此人不在卫队中且与他人无仇恨？
        {
            flag=true;
            break;
        }
    }
    if(!flag) //如果与他人没有仇恨
    {
        byteland[step]=true;
        DFS(step+1,people+1);//第一种状态：选
        byteland[step]=false;
    }
    DFS(step+1,people);//不选
```



# 祭上代码

```cpp
#include<bits/stdc++.h>
#define inf INT_MAX
#define N 105
#define Num 3005
using namespace std;
int n,m,ans=-inf;
bool hostility[Num][Num],byteland[N],ansf[N];
void DFS(int step,int people)
{
    if(step==n+1)
    {
        if(people>ans)
        {
            ans=people;
            for(int i=1;i<=n;++i)
             ansf[i]=byteland[i]; //更新答案
        }
        return;
    }
    bool flag=false;//标记此人是否与他人有仇恨
    for(int i=1;i<=step-1;++i)
    {
        if(byteland[i]&&hostility[step][i])//此人不在卫队中且与他人无仇恨？
        {
            flag=true;
            break;
        }
    }
    if(!flag) //如果与他人没有仇恨
    {
        byteland[step]=true;
        DFS(step+1,people+1);//第一种状态：选
        byteland[step]=false;
    }
    DFS(step+1,people);//不选
} 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i)
    {
        int temp_a,temp_b;
        scanf("%d%d",&temp_a,&temp_b);
        hostility[temp_a][temp_b]=true;
        hostility[temp_b][temp_a]=true;//众所周知，仇恨是相互的 所以要标记两个
    }
    DFS(1,0);//开始快乐地深搜
    printf("%d\n",ans);
    for(int i=1;i<=n;++i)
    {
        printf("%d ",ansf[i]);
    }
    return ~~(0-0);//卖萌求通过
}
```


---

## 作者：xukuan (赞：1)

深搜判断每个人是不是加入卫队








```cpp
var
 a:array[0..110,0..110] of boolean;
 //a[i,j]=true代表i和j是仇敌
 b,c,d:array[0..110] of longint;
 //b[i]代表第i个人在卫队中的仇敌数
 //c[i]代表第i个人在最大值中这个人取不取
 //d[i]代表第i个人在当前的取不取
 i,m,n,maxx:longint;
procedure cin;//输入
 var
  i,u,v:longint;
 begin
  readln(n,m);
  for i:=1 to m do
   begin
    readln(u,v);
    a[u,v]:=true;
    a[v,u]:=true;
   end;
end;
procedure dfs(k,ans:longint);
 var
  i:longint;
 begin
  if k=n+1 then//所有人都选完
   begin
    if ans>maxx then//大于最大值
     begin
      maxx:=ans;
      c:=d;
     end;
    exit;
   end;
  if b[k]=0 then//这个人在卫队中没有仇敌
   begin
    for i:=1 to n do
     if a[k,i] then inc(b[i]);//选入卫队
    d[k]:=1;
    dfs(k+1,ans+1);//选这个人进卫队
    d[k]:=0;
    for i:=1 to n do
     if a[k,i] then dec(b[i]);//回溯
   end;
  dfs(k+1,ans);//不选这个人进卫队
end;
begin
 cin;
 dfs(1,0);
 writeln(maxx);
 for i:=1 to n do
  write(c[i],' ');//输出
end.
```

---

## 作者：PigAunt (赞：0)

思路都差不多，用回溯法搜索每一个人
我放个C#的吧(逃
```cs
using System;

namespace OICSCode
{
    class Program
    {
        public static void Main(string[] args)
        {
            TribalSecurityTeam tribalSecurityTeam = new TribalSecurityTeam();
            int tmpPersonA, tmpPersonB;
            string input;
            string[] inputArray;
            input = Console.ReadLine();
            inputArray = input.Split(' ');
            tribalSecurityTeam.AmountPeople = int.Parse(inputArray[0]);
            tribalSecurityTeam.AmountRelationships = int.Parse(inputArray[1]);
            for (int i = 0; i < tribalSecurityTeam.AmountRelationships; i++) // 标记敌对关系。
            {
                input = Console.ReadLine();
                inputArray = input.Split(' ');
                tmpPersonA = int.Parse(inputArray[0]);
                tmpPersonB = int.Parse(inputArray[1]);
                tmpPersonA -= 1; // 处理编号。程序中为0开始，题目中为1开始。
                tmpPersonB -= 1;
                tribalSecurityTeam.IsEnemies[tmpPersonA, tmpPersonB] = true;
                tribalSecurityTeam.IsEnemies[tmpPersonB, tmpPersonA] = true;
            }

            tribalSecurityTeam.SearchBestTeam(0, 0); // 从第1个人开始搜索。

            Console.WriteLine(tribalSecurityTeam.MaxTeamMembersAmount);
            for (int i = 0; i < tribalSecurityTeam.AmountPeople; i++) // 按照题目要求输出成员关系。
            {
                if (tribalSecurityTeam.IsMaxTeamMember[i] == true)
                    Console.Write("1");
                else
                    Console.Write("0");
                Console.Write(" ");
            }
        }
    }

    /*
        Problem Infomation
        Name: 部落卫队
        Description: 
            原始部落byteland中的居民们为了争夺有限的资源，经常发生冲突。
            几乎每个居民都有他的仇敌。部落酋长为了组织一支保卫部落的队伍，
            希望从部落的居民中选出最多的居民入伍，并保证队伍中任何2个人都不是仇敌。
            给定byteland部落中居民间的仇敌关系，编程计算组成部落卫队的最佳方案。
        Input: 
            第 1 行有 2 个正整数 n 和 m，表示 Dyland 部落中有 n 个居民，居民间有 m 个仇敌关系。
            居民编号为1，2，…，n。接下来的 m 行中，每行有 2 个正整数 u 和 v，表示居民 u 与居民 v 是仇敌。
        Output:
            第 1 行是部落卫队的顶人数；
            文件的第 2 行是卫队组成 x i，1<=i<=n，xi =0 表示居民 i 不在卫队中，xi=1 表示居民 i 在卫队中。
    */

    /*
        Author's Thoughts
            本题实际上属于 最大团问题 。给一个无向图G=(V,E) ，V是顶点集合，E是边集合。
            然后在这顶点集合中选取几个顶点，这几个顶点任意两个之间都有边在E中。求最多可以选取的顶点个数。这几个顶点就构成一个最大团。
    */
    class TribalSecurityTeam
    {
        public TribalSecurityTeam()
        {
            IsTmpTeamMember = new bool[105];
            IsMaxTeamMember = new bool[105];
            IsEnemies = new bool[105, 105];
            for (int i = 0; i < 105; i++)
            {
                IsMaxTeamMember[i] = false;
                IsTmpTeamMember[i] = false;
                for (int j = 0; j < 105; j++)
                {
                    IsEnemies[i, j] = false;
                }
            }
        }

        public int AmountPeople { get; set; }
        public bool[,] IsEnemies { get; set; }
        public int MaxTeamMembersAmount { get; set; } = Int32.MinValue;
        public bool[] IsTmpTeamMember { get; set; }
        public int AmountRelationships { get; set; }
        public bool[] IsMaxTeamMember { get; set; }

        public bool isTeamEnemie(int personToTest) // 判断是否为当前卫队中的敌人。
        {
            for (int i = 0; i < personToTest; i++) // 因为搜索是从小到大的，故判断到被搜索者的前一个。
            {
                if (IsTmpTeamMember[i] && IsEnemies[i, personToTest])
                {
                    return true;
                }
            }
            return false;
        }

        public void SearchBestTeam(int personNow, int tmpTeamMembersAmount)
        {
            if (personNow > AmountPeople - 1) // 若已经搜索完最后一个人，进入判断。
            {
                if (tmpTeamMembersAmount > MaxTeamMembersAmount) // 若当前组合更优，进行替换。
                {
                    MaxTeamMembersAmount = tmpTeamMembersAmount;
                    for (int i = 0; i < AmountPeople; i++)
                    {
                        IsMaxTeamMember[i] = IsTmpTeamMember[i];
                    }
                }
                return;
            }

            // 如果当前卫队里的人数加上后面所有人都没有最大值大，那么这条路一定不对，故放弃。
            if (tmpTeamMembersAmount + AmountPeople - personNow + 1 < MaxTeamMembersAmount)
                return;

            if (!isTeamEnemie(personNow) && !IsTmpTeamMember[personNow]) // 若满足条件，加入搜索。
            {
                IsTmpTeamMember[personNow] = true;
                SearchBestTeam(personNow + 1, tmpTeamMembersAmount + 1);
                IsTmpTeamMember[personNow] = false;
            }
            SearchBestTeam(personNow + 1, tmpTeamMembersAmount);
            return;
        }
    }
}
```


---

## 作者：Jigsaw_Killer (赞：0)

看到数据范围N<=100，直接DFS暴力就A了，没什么技术含量的水题。直接上代码，各位dalao都看得懂。（不过这题dalao应该不屑于看题解吧）dalao勿喷缩进！！！

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
int num[105][105],N,M,ce,ce1,vis[105],ans1[105],ans=0;
using namespace std;
int DFS(int n,int sum)
{
if(n==N)//搜到头了
{
if(sum>ans)//记录最优解
{
ans=sum;
for(int a=0;a<N;a++)
ans1[a]=vis[a];
}
return 0;
}
int pan=0;
for(int a=0;a<N;a++)//一个一个试，纯粹暴力。
{
if(a==n)
continue;
if(vis[a]==1&&num[a][n]==1)
{
pan=1;
break;
}
}
if(pan==0)
{
vis[n]=1;
DFS(n+1,sum+1);
vis[n]=0;
}
DFS(n+1,sum);
}
int main ()
{
scanf("%d%d",&N,&M);
for(int a=0;a<M;a++)
{
scanf("%d%d",&ce,&ce1);
num[ce-1][ce1-1]=1;//只要我讨厌你，我俩都不能来。所以无向边存两次
num[ce1-1][ce-1]=1;
}
DFS(0,0);
printf("%d\n",ans);
for(int a=0;a<N;a++)
printf("%d ",ans1[a]);
return 0;
}
```

---

## 作者：Lynx (赞：0)

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
#include<cmath>
using namespace std;
int n,m,ans=0,c[101],tmp[101]={0},b[101]={0};//c为 
bool a[101][101]={0};
void search(int t,int s)//第t个人 卫队中有s个人
{
    if(t==n+1)//n个人都搜素了 
    {
        if(s>ans)//如果更优 
        {
            ans=s;
            for(int i=1;i<=n;i++)
                c[i]=tmp[i];//保存tmp[],s 
        }
        return ;
    }
    if(b[t]==0)//如果可以选 
        for(int i=1;i>=0;i--)
        {
            if(i==1)//1代表选 
            {
                tmp[t]=1;
                s++;
                b[t]++;//重点：仇恨不知1,所以要++ 
                for(int j=1;j<=n;j++)
                    if(a[t][j])
                        b[j]++;
                search(t+1,s);
                tmp[t]=0;//回溯 
                s--;
                b[t]--;
                for(int j=1;j<=n;j++)
                    if(a[t][j])
                        b[j]--;
            }
            else
                search(t+1,s);
        }
    else
        search(t+1,s);
}
int main()
{
    freopen("1.txt","r",stdin);
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        a[x][y]=1;//a[i][j] i与j为仇敌 
        a[y][x]=1;
    }
    search(1,0);
    printf("%d\n",ans);
    for(int i=1;i<=n-1;i++)
        printf("%d ",c[i]);
    printf("%d\n",c[n]);
    return 0;
}
```

---

## 作者：XiXi (赞：0)

```delphi
type sss=set of 0..100;
var a,f:array[1..100] of boolean;
s:array[1..100] of sss;
w:sss;
n,m,x,y,i,tot,max:longint;
procedure try(k,tot:longint;w:sss);
var i:longint;
begin
if (tot>max) then begin
max:=tot;
a:=f;
end;     //a数组记录人数最多时的每个人的存在情况
for i:=k+1 to n do     //选组合
if not(i in w) then     //w存放被选取人的仇敌，第i人不是仇敌才行
begin
f[i]:=true;     //第i人出现
try(i,tot+1,w+s[i]);     //第i个人、总人数、w集合
f[i]:=false;     //回溯
end;
end;
begin
readln(n,m);
max:=-maxlongint;
for i:=1 to m do
begin readln(x,y);s[x]:=s[x]+[y];end;
try(0,0,w);writeln(max);
for i:=1 to n do if a[i] then write('1 ') else write('0 ');
end.
```
时间：

第1个点  0ms

....2........  0ms

....3........  15ms

....4........  15ms

....5........  0ms

....6........ 46ms

总体上时间还是可以的，本题关键在于使用集合解决了仇敌关系。


---


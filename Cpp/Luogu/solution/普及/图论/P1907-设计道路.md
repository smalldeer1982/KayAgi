# 设计道路

## 题目描述

Caesar远征高卢回来后，对你大加赞赏，他亲自来到Genoa视察。

Genoa在你的建设下变得无比繁荣，由于财政收入的增加，你为城市修建了交通系统。古罗马的交通系统由两部分组成——Dirt Road和Rome Road。两个路口间只可能是其中一种道路。在Rome Road上可以驾驶马车，而在Dirt Road上则不行。由于修建道路是一项浩大的工程，使得你无法将整个城市用Rome Road连接起来。

现在Caesar已经到达码头，他要求去你家参观。Caesar由一个癖好，喜欢坐车而不喜欢走路。所以Caesar走Dirt Road时的不满值要比走Rome Road时大。

为了不让Caesar过于不满而罢免你的职位，请设计路线使得Caesar的不满值最小。


## 样例 #1

### 输入

```
100.0 2.0
2
1.0 0.0
2.0 1.0
1 2
0 0
0.0 0.0
2.0 2.0
```

### 输出

```
202.8284```

# 题解

## 作者：wwwidk1234 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P1907)

[也许更好的阅读体验？](https://wwwidk1234.github.io/)

## 前置芝士
- [链式前向星储存图。](https://oi.wiki/graph/save/)

- [Dijkstra 算法。](https://oi.wiki/graph/shortest-path/)

- 欧几里得距离。
## 题目分析
这是一道**最短路**题，可以把 $0$ 号点当做码头，把 $n+1$ 号点当做家，最后从 $0$ 号点跑一遍 **Dijkstra**，设 $distanc_i$ 表示从起点 $0$ 到点 $i$ 的最短距离，那么 $distanc_{n+1}$ 即为本题答案。

### 建图方式
考虑使用**链式前向星**储存图，每条边的权重为对应的距离乘对应的不满值。以下是欧几里得距离的计算公式：

$$d=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$

先建立 Rome Road，再建立 Dirt Road，详见代码：

```cpp
cin>>dirt>>rome;
cin>>n;
for(int i=1;i<=n;i++)
	cin>>posx[i]>>posy[i];
while(1)
{
	int x,y;
	cin>>x>>y;
	if(x==0&&y==0) break;
	vis1[x][y]=vis1[y][x]=true;
	double res=dis(posx[x],posx[y],posy[x],posy[y]);
	addEdge(x,y,rome*res);
	addEdge(y,x,rome*res);
}
cin>>posx[0]>>posy[0]>>posx[n+1]>>posy[n+1];
for(int i=0;i<=n+1;i++)
	for(int j=0;j<=i;j++)
	{
		if(!vis1[i][j])
		{
			double res=dis(posx[i],posx[j],posy[i],posy[j]);
			addEdge(i,j,dirt*res);
			addEdge(j,i,dirt*res);
		}
	}
```
之后就可以以 $0$ 号点为起点跑 Dijkstra 了，我使用的是有加了堆优化后的 Dijkstra，**记得初始化距离数组。**
```cpp
template<class T>
class cmp
{
	public:bool operator()(T A,T B){return A.dis>B.dis;}
};
priority_queue<node,vector<node>,cmp<node>> q; //创建小根堆
void dijkstra(int s)
{
	q.push({0,s});
	distanc[s]=0;
	while(!q.empty())
	{
		int u=q.top().p; q.pop();
		if(!vis[u])
		{
			vis[u]=1;
			for(int i=head[u];i;i=edge[i].nxt)
			{
				int v=edge[i].to;
				if(distanc[v]>distanc[u]+edge[i].w)
				{
					distanc[v]=distanc[u]+edge[i].w;
					q.push(node{distanc[v],v});
				}
			}
		}
	}
}
```
最后 $distanc_{n+1}$ 即为最终答案。
## 完整代码
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int N=1000;
const int M=499510;
const double inf=1145141919;
int n,m;
bool vis[N];
double distanc[N];
int head[N];
int cnt=0;
struct Edge
{
	int to,nxt;
	double w;
}edge[M<<1];
void addEdge(int u,int v,double w)  //加边
{
	++cnt;
	edge[cnt]={v,head[u],w};
	head[u]=cnt;
}
struct node
{
	double dis;
	int p;
};
template<class T>
class cmp
{
	public:bool operator()(T A,T B){return A.dis>B.dis;}
};
priority_queue<node,vector<node>,cmp<node>> q; //创建小根堆
void dijkstra(int s)
{
	q.push({0,s});
	distanc[s]=0;
	while(!q.empty())
	{
		int u=q.top().p; q.pop();
		if(!vis[u])
		{
			vis[u]=1;
			for(int i=head[u];i;i=edge[i].nxt)
			{
				int v=edge[i].to;
				if(distanc[v]>distanc[u]+edge[i].w)
				{
					distanc[v]=distanc[u]+edge[i].w;
					q.push(node{distanc[v],v});
				}
			}
		}
	}
}

double dis(double xa,double xb,double ya,double yb)
{
	return sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb));
}
bool vis1[N][N];
double dirt,rome;
double posx[N],posy[N];
signed main()
{
	cin>>dirt>>rome;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>posx[i]>>posy[i];
	while(1)
	{
		int x,y;
		cin>>x>>y;
		if(x==0&&y==0) break;
		vis1[x][y]=vis1[y][x]=true;
		double res=dis(posx[x],posx[y],posy[x],posy[y]);
		addEdge(x,y,rome*res);
		addEdge(y,x,rome*res);
	}
	cin>>posx[0]>>posy[0]>>posx[n+1]>>posy[n+1];
	for(int i=0;i<=n+1;i++)
		for(int j=0;j<=i;j++)
		{
			if(!vis1[i][j])
			{
				double res=dis(posx[i],posx[j],posy[i],posy[j]);
//				cout<<i<<","<<j<<":"<<res<<endl;
				addEdge(i,j,dirt*res);
				addEdge(j,i,dirt*res);
			}
		}
//	memset(distanc,0x3f,sizeof distanc);
	for(int i=0;i<=n+10;i++) distanc[i]=inf;
	dijkstra(0);
//	for(int i=0;i<=n+1;i++) cout<<distanc[i]<<" ";
	cout<<fixed<<setprecision(4)<<distanc[n+1];
	return 0;
}
```

---

## 作者：xhQYm (赞：6)

- 题目链接：[P1907 设计道路](https://www.luogu.com.cn/problem/P1907)


这题很明显是一个dijkstra的基础练手题，一看数据范围就知道，这题连堆优化都不用。


我们把 $0$ 号点作为码头，把 $n+1$ 号点设为最后要到达的地方（家），所以这题最终求的就是 $0$ 号点到 $n+1$ 号点的最短路。

那么怎么建图呢？

首先，写一个函数`dis`来求两个点之间的距离。

这样写：

`double dis(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}`

建图就是先建`Rome Road`，之后双重循环建`Dirt Road`即可，注意**不要建重边了**。

**注意建边的长度是距离乘以不满度！**

建`Dirt Road`的时候双重循环建边即可，第一场循环 $i$ 从 $0 \rightarrow n+1$ ，第二层循环 $j$ 从 $0 \rightarrow i-1$ ，之后边权就建成两点之间的距离乘以不满度即可。

之后跑一遍`dijkstra`就行了，不会`dijkstra`的看[这里](https://blog.csdn.net/user_qym/article/details/104086809)。

那么我们就上代码吧，不懂的看注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef double db;
const int N=1010,M=N*2;
int n,a,b;
db g[N][N],x[N],y[N],dist[N],A,B;
bool st[N],vis[N][N];
db dis(db x1,db y1,db x2,db y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}//距离函数
void dijkstra()//这个的详细解释看我上面的那个链接
{
    dist[0]=0;
    for(int i=1;i<=n+1;i++) dist[i]=0x3f3f3f3f;
    for(int i=0;i<=n+1;i++)
    {
        int t=-1;
        for(int j=0;j<=n+1;j++)
            if(!st[j] && (t==-1 || dist[t]>dist[j]))
                t=j;
        for(int j=0;j<=n+1;j++)
            dist[j]=min(dist[j],dist[t]+g[t][j]);
        st[t]=true;
    }
    cout<<fixed<<setprecision(4)<<dist[n+1];
    //保留四位小数
}

int main()
{
    cin>>A>>B;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i];
    while(cin>>a>>b,a!=0,b!=0)//输入到(0,0)为止
    {
        vis[a][b]=vis[b][a]=true;//标记有没有
        g[a][b]=g[b][a]=B*dis(x[a],y[a],x[b],y[b]);//建边
    }
    int sx,sy,fx,fy;
    cin>>sx>>sy>>fx>>fy;//输入起点终点
    x[0]=sx,y[0]=sy,x[n+1]=fx,y[n+1]=fy;
    //赋值到0号点和n+1号点
    for(int i=0;i<=n+1;i++)
        for(int j=0;j<=i;j++)
            if(!vis[i][j])
                g[i][j]=g[j][i]=A*dis(x[i],y[i],x[j],y[j]);//建边
    dijkstra();
    return 0;
}
```

如果还有不懂的或者文章错误欢迎再下面或者私信提出！


---

## 作者：加勒比·史努比 (赞：5)

### Solve

Dijkstra算法寻找最短路径

1.路口，码头，家都作为节点。节点0为码头，节点n+1为家（建图关键）。

2.跑一遍Dijkstra。

### Tips

1.本题数据范围较小，可以用邻接矩阵

2.最大距离最好开大些，开0x3fff就WA了两个点，开1e6就A了

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;  //标准开头
const int N=5000;
double m[N][N];  //邻接矩阵存边
int n;  //路口数
double e,r;  //e——Dirt Road，r——Rome Road
double x[N],y[N];  //节点信息
double d[N];  //离码头的最短距离
bool vis[N][N];  //vis[i][j]==true——i到j之间有Rome Road，false——没有
bool f[N];  //Dijkstra遍历时是否访问过，true——是，false——否
int dx,dy;  //dx到dy有Rome Road
int main()
{
	cin>>e>>r>>n;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
	while(cin>>dx>>dy&&dx!=0&&dy!=0){  //建立Rome Road
		vis[dx][dy]=vis[dy][dx]=true;
		m[dx][dy]=m[dy][dx]=r*sqrt((x[dx]-x[dy])*(x[dx]-x[dy])+(y[dx]-y[dy])*(y[dx]-y[dy]));
	}
	cin>>x[0]>>y[0]>>x[n+1]>>y[n+1];
	for(int i=0;i<=n+1;i++){  //建立Dirt Road
		for(int j=0;j<=i;j++){ 
			if(!vis[i][j]) m[i][j]=m[j][i]=e*sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
		}
	}
	d[0]=0;
	for(int i=1;i<=n+1;i++) d[i]=1e6;
	for(int i=0;i<=n+1;i++){  //核心Dijkstra
		int k;
		double maxn=1e6;
		for(int j=0;j<=n+1;j++){
			if(!f[j]&&d[j]<maxn){
				maxn=d[j];
				k=j;
			}
		}
		if(maxn==1e6) break;
		f[k]=true;
		for(int j=0;j<=n+1;j++){
			if(d[k]+m[k][j]<d[j]) d[j]=d[k]+m[k][j];
		}
	}
	printf("%.4lf",d[n+1]);  //完美输出
	return 0;
}
```

---

## 作者：2024sdhkdj (赞：3)

**[题目传送门](https://www.luogu.com.cn/problem/P1907)**
## 题意描述：
给定 $n$ 个中间点（路口）的坐标和起点（码头）、终点（你家）的坐标。对于每两个中间点间有且只有两种道路：Dirt Road 和 Rome Road，走 Dirt Road 和 Rome Road 一个单位长度时各有一个不满值，即走这两种道路的**总不满值**为 对应的不满值 $\times$ 两点间的距离。已知两个路口间的道路为Rome Road的坐标，要你设计路线使得从码头到家的不满值**最小**。
## 算法分析：
这里我们可以把**总不满值**设为边权，起点设为 $0$，终点设为 $n+1$，首先预处理出所有 Rome Road 和 Dirt Road 的边权，然后跑一遍最短路。

这里我用的是 dijkstra 求最短路，也推荐大家使用，原因有三：

第一：此算法的本质是贪心，更容易上手，而其他求最短路的算法的本质是 DP；

第二：在这题中，两点间的距离和不满值不可能为负数，因此不用担心出现负边权的情况；

第三：~~也不会像某死去的算法一样被卡~~。

有可能有读者还不了解 dijkstra，这里简单介绍一下（大佬可以跳过）：

dijkstra 需要把我们的点分成两部分，一部分是已更新节点（初始无节点），一部分是未更新节点（初始是所有节）。这部分我们用 $flag$ 数组来实现，$flag[i]=1$ 代表已更新 $flag[i]=0$ 代表未更新。假设起点为 $1$，我们现在要运行 Dijkstra 算出每个点的 $dis$ 值（$dis[i]$ 表示到 $i$ 点的最短路）。

重复一下两个操作：

1.从未更新节点集合中，选取一个 $dis$ 数组值最小的结点 $y$，移到已更新集合中。

2.对于 $y$，我们对于每条以 $y$ 为起点的边执行松弛操作。(松弛操作：如果有一条边起点 $y$ 终点 $z$ 权值 $v$，我们算出 $dis[y]+v$ 与 $dis[z]$ 比较，如果前者小则执行 $dis[z] = dis[y]+v$ )

基本原理是：每次新更新一个距离最短的点，更新与其相邻的点的距离数组  $dis$。当所有边权都为正时，由于不会存在一个最短路更短的且没更新过的点，所以这个点的距离永远不会再被改变，因而保证了算法的正确性。

（以上介绍摘自 CSSYZ 课件）

这题我用了优先队列优化，（如果你够巨）也可以手写堆，这样会比优先队列快一些，~~但代码复杂度很高~~。当然，如果是稠密图的话，优化跑得还没暴力快。

最后的最后，我怕还有人有这样的疑惑：如何求直角坐标系上两点间的距离呢？这里简单证明一下。如下图：![](https://cdn.luogu.com.cn/upload/image_hosting/s2jnkzbs.png)
做 $ao$ 和 $ob$ 相交于点 $o$，使得 $ao$ 垂直于 $ob$，连接 $a$ 和 $b$。易得 $ao=x1-y1$，$ob=y2-y1$，根据勾股定理，得：$ab^2=ao^2+ob^2$，即：$ab= \sqrt{ao^2+ob^2}$，代入得：
$$dis(a,b)= \sqrt{(x1-x2)^2 +(y1-y2)^2}$$
## 代码：
放代码了，不懂之处请看注释。
~~~
#include<bits/stdc++.h>
#define int long long//此题可以不开long long，习惯了
#define inf 0x7fffffff
using namespace std;
const int N=1e3+10;
int n,a,b;
int head[N];
double dval,rval,wx,wy,hx,hy;
double x[N],y[N],dis[N];
bool vis[N][N],flag[N];
struct node{
	int to,next;
	double w;
}a[N*N];
void add(int u,int v,double w){//链式前向星加边
	a[++cnt]=node{v,head[u],w};
	head[u]=cnt;
}
typedef pair<int,int> pii;//这里用pair存储两个值，
priority_queue<pii,vector<pii>,greater<pii> > que;//优先队列（小根堆）
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>dval>>rval>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		dis[i]=inf;//到达此边的初始值为一个极大值
	}
	dis[n+1]=inf;
	while(1){
		cin>>a>>b;
		if(!a&&!b)
			break;
		vis[a][b]=vis[b][a]=true;
		add(a,b,rval*sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])));
		add(b,a,rval*sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])));//注意，按照题目要求建无向边，下同
	}
	cin>>x[0]>>y[0]>>x[n+1]>>y[n+1];
	for(int i=0;i<=n;i++)
		for(int j=i+1;j<=n+1;j++)
			if(!vis[i][j]){
				add(i,j,dval*sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
				add(j,i,dval*sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
			}
	que,push(make_pair(dis[0],0));//压入起点
	while(!que.empty()){
		int u=que.top().second;//优先队列不能用front()，而是用top()
		que.pop();//接下来就是打板子了，没什么好讲的
		if(flag[u])
			continue;
		flag[u]=1;
		for(int i=head[u];i;i=a[i].next){
			int x=a[i].to;
			if(dis[u]+a[i].w<dis[x]){
				dis[x]=dis[u]+a[i].w;
				que.push(make_pair(dis[x],x));
			}
		}
	}
	cout<<fixed<<setprecicion(4)<<dis[n+1];//记得保留4位小数
	return 0;
}
~~~
[AC记录](https://www.luogu.com.cn/record/123157429)

[我的BLOG](https://www.luogu.com.cn/blog/hsb0507/)

---

## 作者：Kalium (赞：2)

# P1907 设计道路题解

## 前言：

本题解开了防抄袭(freopen)，文件名是歌名，有兴趣的听听。

## 题意：

有两种不同的道路，不同道路的花费不同，告诉你每个点的坐标，以及告诉你哪条路是哪个花费，求出从起点走到终点的最小花费。

## 思路：

看一下数据范围，额，裸的dijkstra。

貌似邻接矩阵都可以。

主要是卡精度，但是不要慌，全部设成double即可。

我们看看输入吧（主要是输入把本菜鸡坑了一手）。

先输入两种不同道路的加成，再输入点的坐标。

接下来处理花费，花费好处理，用距离公式算一下距离乘一下加成即可。

但我们要用一个 $f[x][y]$ 的数组标记，便于下次如果是不同道路的时候的花费。

这条道路的花费搞定，我们输入起点终点，并存入 0 和 n + 1 的位置上。

然后遍历看看f数组没遍历到的，算出花费。

dij跑一遍，输出，结束。

## 代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#define inf 0x3f3f3f3f

const int N = 1e3 + 7;

using namespace std;

int n;

double D, R;

double x[N], y[N];

double sx, sy, fx, fy;

double g[N][N], dis[N];

bool flag[N], f[N][N];

int xx, yy;

inline double distance(double x1, double x2, double y1, double y2) {
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

inline double mina(double a, double b) {
	if (a < b)
		return a;
	return b;
}

inline void dijkstra() {
	dis[0] = 0;
	for (int i = 1; i <= n + 1; i ++) dis[i] = inf; 
	
	for (int i = 0; i <= n + 1; i ++) {
		int k = -1;
		double tmp = inf;
		
		for (int j = 0; j <= n + 1; j ++) {
			if (! flag[j]) {
				if (tmp > dis[j]) {
					tmp = dis[j];
					k = j;
				}
			}
		}
		
		flag[k] = 1;
		
		for (int j = 0; j <= n + 1; j ++)
			dis[j] = mina(dis[j], dis[k] + g[k][j]);
	}
}

int main() {
	freopen("starsky.in", "r", stdin);
	freopen("starsky.out", "w", stdout);
	
	scanf("%lf %lf", &D, &R);
	scanf("%d", &n);
	
	for (int i = 1; i <= n; i ++)
		scanf("%lf %lf", &x[i], &y[i]);
	
	while (1) {
		scanf("%d %d", &xx, &yy);
		
		if (! xx && ! yy) break;
		
		f[xx][yy] = f[yy][xx] = 1;
		g[xx][yy] = g[yy][xx] = R * distance(x[xx], x[yy], y[xx], y[yy]);
	}
	
	scanf("%lf %lf", &x[0], &y[0]);
	scanf("%lf %lf", &x[n + 1], &y[n + 1]);
	
	for (int i = 0; i <= n + 1; i ++) {
		for (int j = 0; j <= i; j ++) {
			if (! f[i][j])
				g[i][j] = g[j][i] = D * distance(x[i], x[j], y[i], y[j]);
		}
	}
	
	dijkstra();
	
	printf("%0.4lf\n", dis[n + 1]);
	
	fclose(stdin);
	fclose(stdout);
	
	return 0;
}
```

$Atlantic.$

---

## 作者：dtrthg (赞：1)

## 前置知识

- 图的基本概念和建图；
- 优先队列的基本使用；
- dijkstra 算法；

## 题目大意

给定若干个点，其中一些点之间用特殊的边连接，剩下的点用普通边连接，经过不同的边有不同的花费，求给定两点的最小花费。

## 思路

典型的**单源最短路问题**。通俗地讲，单源最短路问题就是求从一个点到其他各点的最短距离。对于这类问题，可以使用 dijkstra 求解。令 $dis_{i}$ 表示从起点到 $i$ 的最短距离，dijkstra 的步骤如下：

1. 将 $dis$ 除起点外的所有初始化为正无穷，$dis_{start}$ 初始化为0。($start$ 表示起点）；
2. 找到未被标记且 $dis$ 值最小的点 $x$，标记 $x$；
3. 遍历 $x$ 的所有后继，如果有 $dis_x+val_x<dis_{next}$，则更新 $dis_{next}$；
4. 重复 2、3 步直到所有点被标记；

对于点 $A,	B$ 之间的距离，设 $A$ 的坐标为 $(x_1,y_1)$，点 $B$ 的坐标为 $(x_2,y_2)$，可以使用欧几里得距离公式：

$$dist(x,y)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$

关于 dijkstra 的证明，可以参考 [oi-wiki](https://oi-wiki.org/graph/shortest-path/#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E)。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define of(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
const int inf=0x3f3f3f3f;
const ll INF=9e18;
const int mod=-1;//ll?
const int N=1010;
double x[N],y[N];
struct Edge {int v; double val;};
vector <Edge> e[N];
priority_queue <Edge> q;
bool operator < (Edge x,Edge y) {return x.val>y.val;}
double dis[N]; bool vis[N];
double count_dist(double x1,double x2,double y1,double y2)
{
	return std::sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
//基于重载预算符实现小根堆
void dij()
{
	fo(i,0,1005) dis[i]=1000000000.0;
	dis[0]=0.0; q.push({0,0.0});
  	 //初始化
	while(!q.empty())
	{
		int now=q.top().v; q.pop();
		if(vis[now]) continue;
		vis[now]=1;
      		//判断是否访问
		for(int i=0;i<e[now].size();++i)
		{
			int nxt=e[now][i].v; double val=e[now][i].val;
			if(dis[now]+val<dis[nxt])//如果更优
			{
				dis[nxt]=dis[now]+val;
				q.push({nxt,dis[nxt]});
			}
		}
	}
}
int main()
{
	double d,r;scanf("%lf%lf",&d,&r);
	int n;scanf("%d",&n);
	fo(i,1,n) scanf("%lf%lf",&x[i],&y[i]);
	while(1)
	{
		int u,v;scanf("%d%d",&u,&v);
		if(u==0&&v==0) break;
		double val=r*count_dist(x[u],x[v],y[u],y[v]);
		e[u].push_back({v,val}); e[v].push_back({u,val});
     		 //对于特殊边的建立
	}
	scanf("%lf%lf%lf%lf",&x[0],&y[0],&x[n+1],&y[n+1]);
	fo(i,0,n+1)
		fo(j,0,i)
		{
			double val=d*count_dist(x[i],x[j],y[i],y[j]);
			e[i].push_back({j,val}); e[j].push_back({i,val});
		}
   		 //对于普通边的建立
	dij();
	printf("%.4lf\n",dis[n+1]);
	return 0;
}
```


---

## 作者：gesong (赞：1)

题目传送门：[P1907 设计道路](https://www.luogu.com.cn/problem/P1907)。
# 前置知识

**两点之间的距离公式：**

设两点分别为：$(x1,y1)(x2,y2)$，则两点的距离为：$\sqrt{(x2-x1)^2+(y2-y1)^2}$。

**最短路 [dijkstra](https://blog.csdn.net/qq_45776662/article/details/107177424?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167331261916800188551470%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167331261916800188551470&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-107177424-null-null.142^v70^control,201^v4^add_ask&utm_term=dijkstra%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187) 算法。**
# 思路

这道题主要是考虑怎么建图，我们可以用路口来编号，起点和终点特殊处理分别为 $0$ 和 $n+1$。

我们再考虑两种路，首先题目告诉了我们 Rome Road 的边，我们只要把每个路口连边即可，边权就为直线路径再乘上代价，然后考虑 Dirt Road，我们知道，如果没有 Rome Road 那一定就是 Dirt Road，那么我们直接枚举每个路口建边。

最后把 $s$ 连向所有的路口，把所有的路口都连向 $t$，即可。

最后的最后跑一遍 dijkstra 算法即可。

**注意：一定要注意 double 不要 int 不然精度丢失**。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1010;
vector<pair<int,double> >a[N];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
double hx[N],hy[N];
inline double dis(double x1,double y1,double x2,double y2){//求距离
	return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}
void add(int u,int v,double w){//加边函数
	a[u].push_back({v,w});
	a[v].push_back({u,w});
}
bool vis[N][N];
int b[N];
double d[N];
double dij(int s,int t){//求最短路算法
	q.push({0,s});
	for (int i=0;i<=t;i++) d[i]=1e9;
	d[s]=0;
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if (b[u]) continue;
		b[u]=1;
		for (auto i:a[u]){
			int v=i.first;
			double w=i.second;
			if (d[v]>d[u]+w){
				d[v]=d[u]+w;
				q.push({d[v],v});
			}
		}
	}
	return d[t];
}
main(){
	double a,b;
	cin>>a>>b;
	int n;
	cin>>n;
	for (int i=1;i<=n;i++) cin>>hx[i]>>hy[i];
	int x,y;
	while(cin>>x>>y&&x&&y) vis[x][y]=vis[y][x]=1,add(x,y,dis(hx[x],hy[x],hx[y],hy[y])*b);//建 Rome Road 的边 
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++)
			if (!vis[i][j]) add(i,j,dis(hx[i],hy[i],hx[j],hy[j])*a);//枚举建 Dirt Road 的边
	double sx,sy,tx,ty;
	cin>>sx>>sy>>tx>>ty;
	for (int i=1;i<=n;i++) add(0,i,dis(sx,sy,hx[i],hy[i])*a);//起点向各个点连边 
	for (int i=1;i<=n;i++) add(i,n+1,dis(hx[i],hy[i],tx,ty)*a);//每个点都连向终点
	printf("%.4lf",dij(0,n+1));
    return 0;
}

```



---

## 作者：Toorean (赞：1)

# 题意
设 $dis(p1, p2)$ 为平面直角坐标系上点 $p1$ 到点 $p2$ 的距离。
- $n+2$ 个点，每个点之间有一条边；

- 当两个点 $p1, p2$ 在输入中提到（即输入整数数对 $(i, j)$）时，那么这两条点的边权为 $rome\_road\times dis(p1, p2)$，如果没有被提到，两个点 $p1, p2$ 的距离为 $dis(p1, p2)\times dirt\_road$；

- 求点 $S$ 到点 $E$ 的最短路径。

# 思路
由题意可以得知，这是一个最短路问题。由于 $n\leq 1000$，所以我们就可以使用**邻接矩阵**来存图，又由于**不会拥有负权边**，因此我们可以使用**未经优化**的 $Dijkstra$ 来解这道题。而本题唯一的难点就是存边，存边可以考虑双重循环来枚举每两个点之间的距离来解。

# AC Code
```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>

using namespace std;

#define MAXN 1010
#define INF 1919810114.514
#define abs(x) (x < 0 ? -x : x)
#define power(x) ((x) * (x))

struct point {
    double x, y;
};

int n, m, i, tmpx, tmpy;
double mud, stone, sx, sy, ex, ey; 
double g[MAXN][MAXN], dis[MAXN];
bool found[MAXN];
point arr[MAXN];

double Distance (point x, point y) {
    return abs (sqrt (abs (power ((x.x - y.x))) + abs (power ((x.y - y.y)))));
} // 距离公式。

void dij (int st) {
    for (int i = 0; i <= n + 1; i++) {
        dis[i] = INF;
    }
    memset (found, false, sizeof (found));
    dis[st] = 0.0;

    while (true) {
        int u = -1;
        for (int i = 0; i <= n + 1; i++) {
            if (!found[i] && (u == -1 || dis[i] < dis[u])) {
                u = i;
            }
        }
        
        if (u == -1) { break ; }
        found[u] = true;

        for (int i = 0; i <= n + 1; i++) {
            dis[i] = min (dis[i], dis[u] + g[u][i]);
        }
    }
} // 模板。

int main (void) {

    for (int i = 0; i < MAXN; i++) {
        for (int j = 0; j < MAXN; j++) {
            g[i][j] = INF;
        }
    } // 初始化。

    scanf ("%lf %lf\n%d", &mud, &stone, &n);
    for (int i = 1; i <= n; i++) {
        double u, v;
        scanf ("%lf %lf", &u, &v);
        arr[i] = {u, v};
    }
    while (~scanf ("%d %d", &tmpx, &tmpy) && tmpx && tmpy) {
        double tmp = Distance (arr[tmpx], arr[tmpy]) * stone;
        g[tmpx][tmpy] = g[tmpy][tmpx] = tmp;
    }
    scanf ("%lf %lf\n%lf %lf", &sx, &sy, &ex, &ey);
    
    for (int i = 1; i <= n; i++) {
        g[0][i] = g[i][0] = Distance ({sx, sy}, arr[i]) * mud;
        g[i][n + 1] = g[n + 1][i] = Distance ({ex, ey}, arr[i]) * mud;
        for (int j = 1; j < i; j++) {
            g[i][j] = g[j][i] = min (g[i][j], Distance (arr[i], arr[j]) * mud);
        }
    } 
    g[0][n + 1] = g[n + 1][0] = Distance ({sx, sy}, {ex, ey}) * mud;
    // 存边
    dij (0);

    printf ("%.4f\n", dis[n + 1]);

    return 0;
}
```

---

## 作者：Hexarhy (赞：1)

一个月没上洛谷，直接红掉蓝，并发篇题解熟悉下~~补rating~~。

--------------

## 题意简述

在平面直角坐标系中，有$n$个点，构成一个强连通图。即每两个点连边，边的类型不是$\texttt{Rome}$就是$\texttt{Dirt}$。

**边长**即为两点直线距离（欧几里得距离）。**边权**为边长$\times$相应不满值。

求最短距离。

## 解题思路

显然跑最短路，这里选取$\texttt{Dijkstra}$。

麻烦一点的可能是建图。

输入时把$\texttt{Rome}$的边建好，用矩阵标记已建边。那么剩下的就是$\texttt{Dirt}$。细节自己实践就能注意到，思维难度不大。

## 注意事项

- 无向图。

- 跑$\texttt{Dijkstra}$时，入队的不是`(next,val)`而是`(next,dis[next])`。相信你知道什么意思（我被这个坑了几次）。

- 注意精度建议`double`。

- 注意起点和终点。


## 奇异码风

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <climits>
#include <queue>
using namespace std;

const int MAXN=5005;
int n;
double dirt,rome;
struct point
{
	double x,y;
	friend istream& operator >>(istream& is,point& a)
	{
		is>>a.x>>a.y;
		return is;
	}//方便输入
}a[MAXN];
struct node
{
	int to;
	double v;
	bool operator<(const node& a)const
	{
		return v>=a.v;//堆优化符号别反
	}
};
vector <node> edge[MAXN];
double dis[MAXN];
bool visit[MAXN];
bool f[MAXN][MAXN];

double calc(const point u,const point v,const double cost)
{
	return sqrt((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y))*cost;//注意边长与边权
}

void input(void)
{
	cin>>dirt>>rome>>n;
	for(int i=1;i<=n;i++)
	 cin>>a[i];
	int u=0,v=0;
	do//建Rome边
	{
		cin>>u>>v;
		edge[u].push_back(node{v,calc(a[u],a[v],rome)});
		edge[v].push_back(node{u,calc(a[v],a[u],rome)});
		f[u][v]=f[v][u]=true;//标记
	}while(u && v);
	cin>>a[0]>>a[n+1];
}

void build(void)
{
	for(int i=0;i<=n+1;i++)
	 for(int j=i+1;j<=n+1;j++)
	  if(!f[i][j])//剩下的就是Dirt
	  {
		  edge[i].push_back(node{j,calc(a[i],a[j],dirt)});
		  edge[j].push_back(node{i,calc(a[j],a[i],dirt)});
	  }
}

void dijkstra(void)//模板了
{
	priority_queue <node> q;
	for(int i=0;i<=n+1;i++)
	 dis[i]=1.00*INT_MAX;
	dis[0]=0.0;//注意起点
	q.push(node{0,0.0});
	while(!q.empty())
	{
		const int tmp=q.top().to;
		q.pop();
		if(visit[tmp])
		 continue;
		visit[tmp]=true;
		for(auto it:edge[tmp])
			if(dis[it.to]>dis[tmp]+it.v)
			{
				dis[it.to]=dis[tmp]+it.v;
				if(!visit[it.to])
				 q.push(node{it.to,dis[it.to]});//坑
			}
	}
}

int main()
{
	input();
	build();
	dijkstra();
	printf("%.4lf\n",dis[n+1]);//注意终点
	return 0;
}
```

---

## 作者：Komorebi_shine (赞：1)

这题的最短路题解和讨论里说的很清楚了，只要把每个结点（包括起点和终点）之间都连起来，跑一遍有实数的最短路就行了。注意下哪些地方要用实数，边权是如何算出来的（根号距离乘单位长度的花费）。

这题的输入特别多，还很烦，用scanf的要注意`%d`和`%lf`的区分。还有，这题的边是双向边，建边的时候要双向建边（不过应该不用建终点到起点的边吧）。

正如某片题解所说，这题输出调试特别麻烦，注意把调试删干净（我也因为没删完wa了一次）

然后就是一通最短路。**最短路，我选dijstra。dijstra，我选堆优化**，看到题解里连堆优化dij都没有，我补一篇
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge
{
	int v,next;
	double w;
} p[4000001];//邻接表的边
int front[1010],n,i,j,M,_x,_y;
bool v[1010];
double dis[1010],x[1010],y[1010],x_1,x_2;
void add(int u,int v,double w)
{
	p[++M].v=v;
	p[M].w=w;
	p[M].next=front[u];
	front[u]=M;
}//加边
struct point
{
	int a,b;
} q;
bool operator <(const point &x,const point &y)
{
	return x.a>y.a;
}
priority_queue<point> dui;//堆优化
double dijstra(int st,int ed)
{
	q.a=0;
	q.b=st;
	dui.push(q);
	int ii;
	for (ii=1;ii<=n+2;ii++) dis[ii]=1999999999;
	dis[st]=0;
	while (!dui.empty())
	{
		int x=dui.top().b;
		dui.pop();
		if (v[x]) continue;
		v[x]=true;
		for (ii=front[x];ii;ii=p[ii].next)
		{
			if (dis[x]+p[ii].w<dis[p[ii].v])
			{
				dis[p[ii].v]=dis[x]+p[ii].w;
				if (!v[p[ii].v])
				{
					q.a=dis[p[ii].v];
					q.b=p[ii].v;
					dui.push(q);
				}
			}
		}
	}
	return dis[ed];
}//最短路
double juli(double i1,double j1,double i2,double j2)
{
	return sqrt((i1-i2)*(i1-i2)+(j1-j2)*(j1-j2));
}//距离计算公式
int main()
{
	scanf("%lf%lf",&x_1,&x_2);
	scanf("%d",&n);
	for (i=1;i<=n;i++)
	 scanf("%lf%lf",&x[i],&y[i]);
	for (i=1;i<=n;i++)
	 for (j=i+1;j<=n;j++)
	 {
	 	add(i,j,x_1*juli(x[i],y[i],x[j],y[j]));
	 	add(j,i,x_1*juli(x[i],y[i],x[j],y[j]));
	 }//这里用到一个小技巧，对于romeroad，我们这里也按照dirtroad边权建边。因为romeroad边权一定更小，后面romeroad建边后，最短路最终会用短边造成影响，所以并没有什么事，就是时间费了点（反正有，大把时光？）
	scanf("%d%d",&_x,&_y);
	while (_x!=0 && _y!=0)
	{
		add(_x,_y,x_2*juli(x[_x],y[_x],x[_y],y[_y]));
		add(_y,_x,x_2*juli(x[_x],y[_x],x[_y],y[_y]));
		scanf("%d%d",&_x,&_y);
	}
	scanf("%lf%lf%lf%lf",&x[n+1],&y[n+1],&x[n+2],&y[n+2]);
	for (i=1;i<=n;i++)
	{
		add(n+1,i,x_1*juli(x[i],y[i],x[n+1],y[n+1]));
		add(i,n+1,x_1*juli(x[i],y[i],x[n+1],y[n+1]));
		add(i,n+2,x_1*juli(x[i],y[i],x[n+2],y[n+2]));
		add(n+2,i,x_1*juli(x[i],y[i],x[n+2],y[n+2]));
	}
	add(n+1,n+2,x_1*juli(x[n+1],y[n+1],x[n+2],y[n+2]));//以上全是读入建边
	printf("%.4lf\n",dijstra(n+1,n+2));
	n+=2;//追求完美
	return 0;
}
```

---

## 作者：Checkmate (赞：1)

很容易发现这是一个最短路，不满意值及为两点间的距离，题目要我们求最少的不满意值即求起点与终点间的最短路；

用结构体存路口的坐标，a[0]存起点，a[n+1]存终点；（没有C++的题解来水一波）；

（代码比较长，耐心看是会有收获的）；







```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
const int maxn=1005;
using namespace std;
double dirty,roma;
int beg[maxn*100],nex[maxn*100],vis[maxn*100],to[maxn*100],q[maxn*100],e;
double dis[maxn*100],w[maxn*100];//数组开大点TAT（惨痛的教训）
bool flag[maxn][maxn];
void add(int x,int y,double z)//链式前向星储存 ； 
{
    e++;
    nex[e]=beg[x];
    beg[x]=e;
    to[e]=y;
    w[e]=z;
}
struct Node{
    double x,y;
}a[maxn];
double path1(int aa,int bb)//计算Dirt Road的不满值 ； 
{
    return sqrt((a[aa].x-a[bb].x)*(a[aa].x-a[bb].x)+(a[aa].y-a[bb].y)*(a[aa].y-a[bb].y))*dirty;
}
double path2(int aa,int bb)//计算Rome Road的不满值； 
{
    return sqrt((a[aa].x-a[bb].x)*(a[aa].x-a[bb].x)+(a[aa].y-a[bb].y)*(a[aa].y-a[bb].y))*roma;
}
void SPFA(int x) 
{
    int head=0,tail=1;
    dis[x]=0;q[1]=x;vis[x]=1;
    while(head<tail)
    {
        head++;
        int u=q[head];
        vis[u]=0;//记得去标记； 
        for(int i=beg[u];i;i=nex[i])
        {
            int v=to[i];
            if(dis[v]>dis[u]+w[i])
            {
                dis[v]=dis[u]+w[i];
                if(!vis[v])
                {
                    vis[v]=1;
                    q[++tail]=v;
                }
            }
        }
    }
}
int main(){
    cin>>dirty>>roma; //Dirty road和Rome road的不满意值;
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].x>>a[i].y;
    }
    int x,y;
    memset(dis,127,sizeof(dis));//初始化最大值； 
    while(1)
    {
        cin>>x>>y;if(x*y==0)break;
        flag[x][y]=1;flag[y][x]=1;//记录两点间的道路类型方便添加 Dirt Road； 
        add(x,y,path2(x,y));//添加Rome Road 
        add(y,x,path2(x,y));
    }
    for(int i=1;i<n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            if(!flag[i][j])//不是Rome road;
            {
                add(i,j,path1(i,j));//往没做标记的两个路口间添加Dirt Road； 
                add(j,i,path1(i,j));
            }
        }
    }
    cin>>a[0].x>>a[0].y>>a[n+1].x>>a[n+1].y;//起点设为0，终点n+1； 
    for(int i=1;i<=n+1;i++)
    {
        add(0,i,path1(0,i));//往各个路口（和终点）与起点间添加 Dirt Road；
        add(i,0,path1(i,0));
    }
    for(int i=0;i<=n;i++)
    {
        add(n+1,i,path1(i,n+1));//同上，添终点的Dirt Road； 
        add(i,n+1,path1(i,n+1));
    }
    SPFA(0);//从起点搜起 
    printf("%.4lf\n",dis[n+1]);//输出终点距离 
    return 0;
}
```

---

## 作者：Po7ed (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/P1907)**

### 解法
#### 思路
求“最小不满值”，还给了一些点和边，明显是求最短路。
#### 算法流程
记走 Dirt Road 和 Rome Road 一个单位长度时的不满值为 $D$ 和 $R$。

前置知识：[欧几里得距离](https://zhuanlan.zhihu.com/p/520480277)、[Dijkstra](https://zhuanlan.zhihu.com/p/338414118)。

- 按照输入的建 Rome Road。边权为 $R\times\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。$x_1,y_1,x_2,y_2$ 分别为两点坐标。
- 输入起点（码头）和终点（家）。可以将它们记为 $0$ 号和 $n+1$ 号点。
- 遍历任意两点建 Dirt Road。边权为 $D\times\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。
- 进行 Dijkstra。

#### 代码
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <cmath>
using namespace std;

struct node//节点
{
	double x,y;
};
struct ndfp//给堆优化用的
{
	int id;
	double d;
	friend bool operator < (ndfp a,ndfp b)
	{
		return a.d<b.d;
	}
};

//计算两点间欧几里得距离
inline double dist(double x1,double y1,double x2,double y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

int main()
{
	double D,R;//不满值
	int n;
	scanf("%lf %lf\n%d",&D,&R,&n);
	node p[n+2];
	double e[n+2][n+2];//邻接矩阵
	fill(*e,*e+(n+2)*(n+2),0x3f3f3f3f);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf %lf",&p[i].x,&p[i].y);
	}
	int a,b;
	while(true)
	{
		scanf("%d %d",&a,&b);
		if(!(a||b))
			break;
		e[a][b]=R*dist(p[a].x,p[a].y,p[b].x,p[b].y);//建 Rome Road
		e[b][a]=R*dist(p[a].x,p[a].y,p[b].x,p[b].y);
	}
	double bx,by,ex,ey;
	scanf("%lf %lf %lf %lf",&bx,&by,&ex,&ey);
	p[0].x=bx;
	p[0].y=by;
	p[n+1].x=ex;
	p[n+1].y=ey;
	for(int i=0;i<=n+1;i++)
	{
		for(int j=0;j<=n+1;j++)
		{
			if(i!=j)//建 Dirt Road
				e[i][j]=min(e[i][j],D*dist(p[i].x,p[i].y,p[j].x,p[j].y));
		}
	}
	priority_queue<ndfp> q;//堆
	q.push({0,0});
	ndfp t;
	double dis[n+2];
	fill(dis,dis+(n+2),0x3f3f3f3f);
	dis[0]=0;
	while(!q.empty())//Dijkstra（我写堆优化因为好写）
	{
		t=q.top();
		q.pop();
		if(t.d!=dis[t.id])
		{
			continue;
		}
		for(int i=0;i<=n+1;i++)
		{
			if(dis[i]>dis[t.id]+e[t.id][i])
			{
				dis[i]=dis[t.id]+e[t.id][i];
				q.push({i,dis[i]});
			}
		}
	}
	printf("%.4lf",dis[n+1]);
	return 0;
}
```

---

## 作者：Weakest_Konjac (赞：0)

一看就是SPFA，本蒟蒻刚好在刷图论的水题，就把这道题AC了
温馨提示：这条道路是直的，求欧几里得距离再乘rome或dirt
```pascal
var a:array[1..1002,1..2]of extended;//坐标
    w:array[1..1002,1..1002]of extended;//是否是Rome
    dist:array[1..1002]of extended;//最小值
    f:array[1..1002]of boolean;//判断有没有入队
    h:array[1..1002]of longint;//队列
    i,j,n,x,y,t,ww:longint;
    x1,y1,x2,y2,dirt,rome:extended;
begin
  read(dirt,rome);
  read(n);
  for i:=1 to n do
   read(a[i,1],a[i,2]);
  read(x,y);
  while (x<>0)and(y<>0) do
  begin
   w[x,y]:=rome*sqrt(sqr(a[x,1]-a[y,1])+sqr(a[x,2]-a[y,2]));//如果是Rome就在w数组中存储这条路
   w[y,x]:=w[x,y];//双向路
   read(x,y);
  end;
  read(x2,y2);//码头坐标
  read(x1,y1);//家的坐标
  n:=n+2;//建新的点
  a[n-1,1]:=x2;//建码头点
  a[n-1,2]:=y2;
  a[n,1]:=x1;//建家点
  a[n,2]:=y1;
  h[1]:=n;
  t:=0;ww:=1;
  for i:=1 to n do dist[i]:=maxlongint;//初始最大
  dist[n]:=0;
  while ww<>t do
  begin
   t:=t mod n+1;
   x:=h[t];
   f[x]:=false;
   for i:=1 to n do
   begin
    if (dist[x]<maxlongint)and(w[x,i]<>0)and(dist[x]+w[x,i]<dist[i]) then//如果是Rome，走w数组的路
    begin
     dist[i]:=dist[x]+w[x,i];
     if f[i]=false then
     begin
      f[i]:=true;
      ww:=ww mod n+1;
      h[ww]:=i;
     end;
    end;
    if (dist[x]<maxlongint)and(w[x,i]=0)and(dist[x]+dirt*sqrt(sqr(a[x,1]-a[i,1])+sqr(a[x,2]-a[i,2]))<dist[i]) then//dirt路
    begin
     dist[i]:=dist[x]+dirt*sqrt(sqr(a[x,1]-a[i,1])+sqr(a[x,2]-a[i,2]));
     if f[i]=false then
     begin
      f[i]:=true;
      ww:=ww mod n+1;
      h[ww]:=i;
     end;
    end;
   end;
  end;
  writeln(dist[n-1]:0:4);//保留四位小数
end.
```

---

## 作者：wangxuye (赞：0)

已知所有路口、起点、终点的坐标以及所有有rome road连接的路口，求从起点到终点的最短路径

很明显，这是一个带权的最短路，rome road的权为rome，dirt road的权为dirt（见程序），再已知所有路口的坐标就知道了所有路口间的距离（两点间距离公式），那么这道题就可以用dijkstra或bellman-ford做了

下面贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int SIZE=1000;
typedef double db;

struct aa
{
	db x,y;
} crossing[SIZE+10];//所有路口的坐标 

db sqr(db x)  //平方 
{
	return x*x;
}

db dist(int i,int j)  //计算两点间的距离 
{
	return sqrt(sqr(crossing[i].x-crossing[j].x)+sqr(crossing[i].y-crossing[j].y));//两点间距离公式
}

struct aaa
{
	int start,end;
} romeroad[SIZE*10+10];//rome road连接的两个路口 

db dis[SIZE+10][SIZE+10];//邻接表存储任意两点间的距离 
db mincount[SIZE+10];//dijkstra的最短距离 
bool visit[SIZE+10];//是否已经访问过 

db dbmin(db x,db y)  //最小值 
{
	if(x>y) return y;
	else return x;
}

int main()
{
	db dirt,rome;
	scanf("%lf%lf",&dirt,&rome);
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&crossing[i].x,&crossing[i].y);//读入所有点的坐标 
	int m=0;
	for(int i=1;i<=n+2;i++)
	{
		for(int j=1;j<=n+2;j++) dis[i][j]=0x3f3f3f3f;
		mincount[i]=0x3f3f3f3f;
	}
	for(;;)  //读入有马路的两点 
	{
		m++;
		scanf("%d%d",&romeroad[m].start,&romeroad[m].end);
		if(romeroad[m].start==0&&romeroad[m].end==0)
		{
			m--;
			break;
		}
	}
	scanf("%lf%lf%lf%lf",&crossing[n+1].x,&crossing[n+1].y,&crossing[n+2].x,&crossing[n+2].y);//读入起点和终点的坐标 
	n+=2;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) dis[i][j]=dirt*dist(i,j);//计算dirt road的距离 
	for(int i=1;i<=m;i++)
	{
		db x=dis[romeroad[i].start][romeroad[i].end]*rome/dirt;//计算rome road的距离 
		dis[romeroad[i].start][romeroad[i].end]=x;
		dis[romeroad[i].end][romeroad[i].start]=x;
	}
	int k=n-1;
	db minn;
	db cnt=0;
	mincount[k]=0;
	for(int i=1;i<n;i++)   //dijkstra（这里是n^2算法，因为n<=1000，所以本人懒得（划）就不用优先队列优化了）
	{
		visit[k]=true;
		minn=0x3f3f3f3f;
		int b=-1;
		for(int j=1;j<=n;j++)
		{
			if(visit[j]) continue;
			mincount[j]=dbmin(mincount[j],mincount[k]+dis[k][j]);
			if(mincount[j]<minn)
			{
				minn=mincount[j];
				b=j;
			}
		}
		k=b;
		if(k==-1)
		{
			printf("fuck\n");//忽略这里 
			return 0;
		}
		if(k==n) break;//若没有比到终点更短的路径则推出 
	}
	printf("%.4lf\n",mincount[n]);//输出到终点的最短路径 
	return 0;
}
```

---

## 作者：tututu (赞：0)

题解：

这题是典型的最短路，通过对输入数据的处理，转化为1-n的最短路问题，就是需要用实数，用函数算出两点间距离，然后dijkstra跑一遍即可

pascal code:

```cpp
var
  x,y:real;
  n,i,j,t,k,min:longint;
  d,a,b:array[-1..1002] of real;
  c:array[-1..1002] of boolean;
  f:array[-1..1002,-1..1002] of boolean;
function ccc(p,q:longint):real;//计算p,q间的距离
begin
  if f[p,q] then exit(y*sqrt(sqr(a[p]-a[q])+sqr(b[p]-b[q])))
             else exit(x*sqrt(sqr(a[p]-a[q])+sqr(b[p]-b[q])));
end;
begin
  readln(x,y);
  readln(n);
  for i:=2 to n+1 do readln(a[i],b[i]);
  readln(t,k);
  while (t>0) or (k>0) do
    begin
      f[t+1,k+1]:=true;//双向，不知道单向对不对
      f[k+1,t+1]:=true;
      readln(t,k);
    end;
  readln(a[1],b[1]);
  readln(a[n+2],b[n+2]);//这里转化了一下把起点终点放到前后（所以前面t,k等都+1）
  n:=n+2;
  c[1]:=true;
  for i:=2 to n do d[i]:=ccc(1,i);//d保存当前最短路
  d[0]:=10000000;
  for i:=2 to n do
    begin
      min:=0;//最短的可拓展点
      for j:=2 to n do if not c[j] then if d[j]<d[min] then min:=j;
      c[min]:=true;
      for j:=2 to n do if not c[j] then if d[min]+ccc(min,j)<d[j] then d[j]:=d[min]+ccc(min,j);//重置点的最短路径
    end;
  write(d[n]:0:4);//输出不讲了
end.
```

---


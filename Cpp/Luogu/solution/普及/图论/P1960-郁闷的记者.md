# 郁闷的记者

## 题目描述

你是一个体育报社的记者，你接受到一个艰难的任务：有 $N$ 支足球队参加足球比赛，现在给你一些比赛的结果，需要你给出各支球队的排名，从 $1$ 到 $N$。

以下是给你的一些信息：

 1. 没有平局；
 2. 不同的球队排名不能相同；
 3. 对于所有满足 $1 \le a<b \le N$，第 $a$ 名的球队一定可以打败第 $b$ 名的球队。

给你部分比赛结果，要求给出排名，并且判断是否存在另一种排名方法满足给你的比赛结果。


## 说明/提示

【数据范围】

$30\%$ 的数据满足：$1 \le N \le7$，$1 \le M \le 15$

$60\%$的数据满足：$1 \le N \le 100$，$1 \le M \le 2000$

$100\%$ 的数据满足：$1 \le N \le 5000$，$1 \le M \le 100000$


本题已加入spj，如果输出的最后一行错误将会提示 `Your decide is wrong!`

如果存在多种排名情况，排名错误将会提示 `Wrong ranks!`

如果情况固定且您的答案错误将会提示 `In line X,Your ans is wrong:expected = X,found = Y`


## 样例 #1

### 输入

```
3
2
2 1
2 3```

### 输出

```
2
1
3
1
```

# 题解

## 作者：Strong_Jelly (赞：20)

## 我们用拓扑排序来做这道题

先讲解一下**拓扑排序**：

拓扑排序是用来解决**AOV网**的问题的一个算法

**AOV网**是一个**无环有向图**，形象的解释一下：一个农夫有n项农活要干，但农活是有先后顺序的（例如必须先给庄稼施肥，浇水，最后才能采摘，~~总不能拔苗助长啊~~）。我们可以用一个图来形象的描绘出来（必须先完成的农活A指向必须完成A这个农活才可以做的农活B，以此构成一个图），这就是AOV网。

给张图形象一下，就不口胡了

![](https://cdn.luogu.com.cn/upload/pic/60542.png)

无环是因为有环就会发生冲突，例：

![](https://cdn.luogu.com.cn/upload/pic/60544.png)

那么完成1需要完成4,完成4需要完成3，完成3需要完成2，完成2需要完成1…………诶，完成1需要完成1？这就不对了。

拓扑排序是把这种AOV网转换成一个序列（从先完成的到后完成的）的算法（相同级别谁在前谁在后~~随你大小便~~，**这道题这里是关键**）

## 再来分析一下题目

先看三个条件

```
1.没有平局

2.不同的球队排名不能相同

3.对于所有满足l ≤ a < b ≤ n，第a名的球队一定可以打败第b名的球队
```

既然a球队一定能打败b球队且a球队比b球队排名高，那么这道题就可以用拓扑，把排名高的球队指向排名低的球队，然后进行拓扑排序，就OK了。但题目还要求求出是否有多种排序方案，看上面写着**这道题这里是关键**的地方，如果出现了相同级别，就会出现多种排序方案，加一个判断就可以了

先看邻接矩阵的做法（这道题n ≤ 5000，不会爆空间）

```cpp
#include <bits/stdc++.h>
using namespace std;
stack < int > pru;//用来存没有入度的点(名义上的起点，但不是真正的起点)，会更新，改成队列也一样 
int n, m, x, y, in[100001], out[100001], t, f, ff[5001][5001];//in[i]表示i这个点的入度，out[i]表示i这个点的出度，t存是否出现了相同级别，f存最后题目要求输出的是否有多个方案，ff[i][j]表示i这个点的第j个出度  
int main()
{
	scanf("%d %d", &n, &m);
	for(register int i = 1; i <= m; ++i)
	{
		scanf("%d %d", &x, &y);
		++in[y];
		++out[x];
		ff[x][out[x]] = y;//存出度的节点编号 
	}
	for(register int i = 1; i <= n; ++i)
	{
		if(in[i] == 0)//起点没有入度 
		{
			pru.push(i);
			++t;//有多个起点就有多个排序方案(相同级别) 
		}
	}
	if(t > 1)//多个起点 
	{
		f = 1;//存起来 
	}
	t = 0;//置零 
	while(!pru.empty())
	{
		int u = pru.top();//取出 
		pru.pop();
		printf("%d\n", u);//输出 
		t = 0;//置零 
		for(register int i = 1; i <= out[u]; ++i)//循环这个点的所有出度
		{
			int k = ff[u][i];//连出来的这个点 
			--in[k];//消除 
			if(in[k] == 0)
			{
				pru.push(k);
				++t;//相同级别 + 1 
			}
		}
		if(t > 1)//同上 
		{
			f = 1;
		}
	}
	printf("%d", f);//别忘了输出这个 
	return 0;
}
```

链式向前星的做法（就不写注释了，和邻接矩阵的大同小异）：

```cpp
#include <bits/stdc++.h>
using namespace std;
queue < int > pru;
int n, m, head[100001], num, x, y, in[100001], t, f;
struct node
{
	int next, to;
}stu[100001];
inline void add(int x, int y)
{
	stu[++num].next = head[x];
	stu[num].to = y;
	head[x] = num;
	return;
}
int main()
{
	scanf("%d %d", &n, &m);
	for(register int i = 1; i <= m; ++i)
	{
		scanf("%d %d", &x, &y);
		add(x, y);
		++in[y];
	}
	for(register int i = 1; i <= n; ++i)
	{
		if(in[i] == 0)
		{
			pru.push(i);
			++t;
		}
	}
	if(t > 1)
	{
		f = 1;
	}
	t = 0;
	while(!pru.empty())
	{
		int u = pru.front();
		pru.pop();
		printf("%d\n", u);
		t = 0;
		for(register int i = head[u]; i; i = stu[i].next)
		{
			int k = stu[i].to;
			--in[k];
			if(in[k] == 0)
			{
				pru.push(k);
				++t;
			}
		}
		if(t > 1)
		{
			f = 1;
		}
	}
	printf("%d", f);
	return 0;
}
```


---

## 作者：睆熠 (赞：6)

##  竟然没有人用差分约束跑！？
这里上一个差分约束的题解，跑了55ms，还算可以吧。。\
思路就是当一个队打败另一个队的时候在两队间建立一条有向边，最后直接跑到每一个点的最长路来将他们排名（没有被打败过的就设最长路为0）。\
具体细节请看代码。
###### 注意：下面代码是不能AC的，与AC代码有几个字符的差异，请不要尝试复制粘贴！否则(https://www.luogu.org/record/25753419)
# Code

```c
#include <bits/stdc++.h>
#define IThinkIAmTooPowerful return 0;
using namespace std;
inline int read(){int ans=0,f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}return ans*f;}
//恶意压行的快读 反正你知道是快读就行了 
inline int max(int a, int b){return a > b ? a : b;}
inline int min(int a, int b){return a < b ? a : b;}
struct node{
	int u,v;
}e[100005];
struct node1{
	int x,id;
}dis[5005];
int n,m;
int ru[5005];
bool comp(node1 a,node1 b){return a.x<b.x;}
int main(){
	n=read();m=read();
	for(int i=1;i<=m;++i){
		e[i].u=read(),e[i].v=read();
		ru[e[i].v]++;//其实只是记录它是否被打败过 
	}
	memset(dis,-1,sizeof(dis));
	for(int i=1;i<=n;++i){
		if(ru[i]==0) dis[i].x=0;//如果没有队打败它，就设成优胜队，此时距离为0 
		dis[i].id=i;
	}
		for(int i=1;i<=m;++i)
			if(dis[e[i].u].x!=-1)
				dis[e[i].v].x=min(dis[e[i].u].x+1,dis[e[i].v].x);//暴力跑最长路就好了 
	sort(dis+1,dis+1+n,comp);//把距离按从小到大排序 
	int ans=0;
	for(int i=1;i<=n;++i){
		printf("%d\n",dis[i].id);
		if(dis[i].x==dis[i-1].x) ans=1;//如果有可以和此队并列的队伍，就是有更多方案的 
	}
	printf("%d",ans);
	IThinkIAmTooPowerful//A掉此题，真是太强了 
	
}
```


---

## 作者：LiftingTheElephant (赞：6)

闲话少说，直接上代码。
```
//蒟蒻使用的邻接表，数组是多么优美啊！
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
vector <int> l[5005];//邻接表，l[i]储存被他打败的所有队
int fail[5005],win[5005];
//fail[i]代表第i队被打败的次数，win[i]代表第i队赢的次数
stack <int> q;//答案存储
int x,sum,qtop,n,m,a,b;
int main()
{
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		cin>>a>>b;//a打败了b
		win[a]++;//a多赢一局
		fail[b]++;//b多输一局
		l[a].push_back(b);//存入邻接表中，a打败了b
	}
	for(int i=1;i<=n;i++)
		if(fail[i]==0)//若此队未被打败
		{
			q.push(i);
			sum++;
		}
	if(sum>1)//若多个队都未被打败则有多种可能
		x=1;
	while(!q.empty())//栈非空
	{
		sum=0;
		qtop=q.top();//当前未被打败的队
		cout<<qtop<<endl;//直接输出
		q.pop();//然后就不需要它了
		for(int i=0;i<l[qtop].size();i++)//循环删点
		{
			fail[l[qtop][i]]--;
            //这个被未被打败的队打败的队少被打败一次
			if(fail[l[qtop][i]]==0)//若此时它未被打败过
			{
				q.push(l[qtop][i]);//入栈
				sum++;//计数
			}
		}
		if(sum>1)//若多个队都未被打败则有多种可能
			x=1;
	}
	cout<<x<<endl;//输出是否有多种可能
    cout<<"Do not copy this code"<<endl;//防盗标识
	return 0;
}

```

---

## 作者：花落丶宸星 (赞：5)

## 拓扑裸题？！
#### 这是我们考试里做到的，所以我来水一波题解。。。（我们考试里面还要求输出最小字典序）      
题目很简单，就是裸拓扑，关键是多个解的判断，根据多次推测，我们发现，当某一次拓扑时，出现多个入度为0的，就有多个解。。。所以就可以写出代码了。。。         
~~我的码风清奇，看得懂就行了~~       
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,u,v,cs,mm;
bool a[5010][5010];//破坏队形的邻接矩阵
bool flag;
int rd[5010];
bool used[5010];
int main(){
	scanf("%d",&n);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		a[u][v]=true;
		rd[v]++;
	}
	int nn=n;
	while(nn>0){
		cs=0;mm=2147483647;
		for(int i=1;i<=n;i++){
			if(rd[i]==0&&used[i]==false){
				cs++;
				if(i<mm){
					mm=i;
				}
			}
			
		}
		if (cs>1){
			flag=true;
		}
		printf("%d\n",mm);
		used[mm]=true;
		nn--;
		for(int i=1;i<=n;i++){
			if(a[mm][i]){
				a[mm][i]=false;
				rd[i]--;
			}
		}
	}
	if (flag) printf("1\n");
	else printf("0\n");	
	return 0; 
}
```
别人都是写拓扑用队列什么的，我也不会那么写，我认为这样写还是比较舒服的。qwq

---

## 作者：Lonely_NewYear (赞：4)

# 洛谷 P1960 题解

## 题目大意

给出 $n$ 支球队，并要求某个球队一定在另外一个球队之前，求可行方案。

## 题目分析

首先要明确的是，有多种答案。

我们会发现如果对于某一个球队，如果要求在他前面的所有球队已经被确认在他前面了（也就是已经被输出了），那么就可以输出这个球队了。可以把一个球队当做点，要求条件当做边，在此情况下，就相当于要求某一个点入度为 $0$。

考虑具体实现方法。

建边时从被要求靠前的点建到靠后的点，先把所有入度为0的点加入一个队列中，然后每一次选择队列中的一个元素 $x$ 输出并弹出队列。然后删除 $x$ 和 $x$ 发出的所有边，同时将 $x$ 连接到的点入度减一。如果某个点入度减一后入度为 $0$，那就加入队列。

还有一问，求是否有多种方案。我们会发现只有在 $x$ 不唯一时才会导致多种方案，也就是任何时刻都要求队列中只有一个元素，可以在将一个数插入队列时判断一下队列是否是空的，如果不是空的就说明有多种方案。

为了方便做题，$x$ 一般取队头。

这就是拓扑排序了。

## 代码


```cpp
#include<cstdio>
#include<queue>
using namespace std;
struct edge
{
    int to,next;
}g[100001];
int head[5001],cnt,num[5001],n,m,ans[5001],tot;
//邻接表建图，num表示入度，ans记录答案，tot记录已经排好了多少个数。
bool flag;//表示是否有多种方案
queue<int> q;
void add(int u,int v)
{
    g[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
void toposort()
{
    for(int i=1;i<=n;i++)
    {
        if(num[i]==0)
        {
            if(!q.empty())
            {
                flag=1;
            }
            q.push(i);
        }
    }
    while(!q.empty())
    {
        int u=q.front();
        ans[++tot]=u;
        q.pop();
        for(int i=head[u];i;i=g[i].next)
        {
            int v=g[i].to;
            num[v]--;
            if(num[v]==0)
            {
                if(!q.empty())
                {
                    flag=1;
                }
                q.push(v);
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)//建图，更新入度
    {
        int u,v;
        scanf("%d%d",&u,&v);
        num[v]++;
        add(u,v);
    }
    toposort();
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",ans[i]);
    }
    printf("%d",flag);
    return 0;
}
```

因为会遍历所有点和边，所以时间复杂度为 $O(n+m)$，十分优秀。

需要注意的是，有环的情况无法完成拓扑排序，会产生矛盾。如果题目要求判断这种情况的话可以在函数结束时判断已经排好了多少个数，如果不为 $n$ 则说明有环。

谢谢观看。

---

## 作者：gyh20 (赞：3)

a>b,b>c,a>d……
一看到这类题就会想到拓扑，本题不难，具体见代码。
```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
priority_queue <int> q;//为了字典序
struct edge{
	int to,next;
}e[500002];//洛古数据较水，我们学校数据为N<=100000,M<=500000必须用前向星
int m,n,a,b,c,head[100002],rd[100002],ans[100002],p,cnt;bool k;
void bu(int x,int y){
	e[++cnt].next=head[x];
	e[cnt].to=y;
	head[x]=cnt;
	rd[y]++;
}//构建前向星

int main(){
k=0;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a>>b;
		bu(a,b);
	}p=0;
  //p为一标记，表示当前队列需要新进入几个元素
	for(int i=1;i<=n;i++){
		
		if(rd[i]==0)q.push(-i),p++;//负数比较大小
	}
	if(p>1)k=1;//如果一次性进入大于2个元素则说明有多种方案
	while(!q.empty()){
		c=-q.top();
		ans[++ans[0]]=c;//存储
		q.pop();
		p=0;
		for(int i=head[c];i;i=e[i].next){
			rd[e[i].to]--;
			if(rd[e[i].to]==0)q.push(-e[i].to),p++;
		}
		if(p>1)k=1;
	}//标准拓扑

		for(int i=1;i<=ans[0];i++)cout<<ans[i]<<"\n";cout<<k;
	

}
```


---

## 作者：syksykCCC (赞：2)

看到竟然没有用dfs写的题解，故来和大家分享一下我的dfs解法

~~个人认为这题不止黄题难度啊~~

这题主要可以分为两个部分，一个是找出一种合法排名，另一个是判断是否答案唯一。我们一个个来解决

**1.找出一种合法排名**

拓扑排序，其它题解也已经讲得很清楚了，这里不再赘述

一个可行的方法是从失败队向获胜队连边，根据拓扑序列的性质“所有该点能访问到的点都在该点的前面”，就可以得到一种排名顺序了

**2.判断是否答案唯一**

个人认为这是该题的难点所在

首先建一个从获胜队向失败队连边的图（即上面所提到的图的反向图），遍历每一个节点

我们考虑当遍历到一个点时，就将从它出发的所有边都删去（在代码中体现为可访问到的点的入度$inv-1$）

然后此时，每一个还存在的点的入度如果为0，就可以作为一个新的根节点，当作排名的下一位。那么如果这样的点的数量不止一个，就说明排名是不确定的

![](https://cdn.luogu.com.cn/upload/pic/54111.png)

例如此时，访问到了$1$这个点，我们将图变为

![](https://cdn.luogu.com.cn/upload/pic/54112.png)

那么$2$或$3$都入度为零，即可以作为排名的下一位，则方案不唯一

特殊的，考虑到原图中可能有多个根节点，则如果原图中的根节点数量大于$1$，方案也是不唯一的，例如

![](https://cdn.luogu.com.cn/upload/pic/54113.png)

注意在此次遍历中，要找新图里的根节点访问

具体实现看代码吧

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 5005;
int n,m,sorted[N],cnt,inv[N];
vector<int> g[N],r[N];
bool vis[N],oth;
bool check()//查找此时的根节点数量是否>1 
{
	int sum=0;
	for(int i=1;i<=n;i++)
		if(!vis[i] && !inv[i])
			sum++;
	return sum>1;
} 
void dfs_on_g(int u)//解决问题1
{
	vis[u]=true;
	int len=g[u].size();
	for(int i=0;i<len;i++)
	{
		int v=g[u][i];
		if(!vis[v]) dfs_on_g(v);
	} 
	sorted[++cnt]=u;//该数组用来储存一种可行序列 
}
void dfs_on_r(int u)//解决问题2 
{
	vis[u]=true;
	int len=r[u].size();
	for(int i=0;i<len;i++) inv[r[u][i]]--;//删边 
	oth=max(oth,check());
	for(int i=0;i<len;i++)
	{
		int v=r[u][i];
		if(!vis[v] && !inv[v])//找根节点遍历 
			dfs_on_r(v);
	}
}
void topsort_on_g()//解决问题1
{
	for(int i=1;i<=n;i++)
		if(!vis[i]) dfs_on_g(i);
}
void topsort_on_r()//解决问题2 
{
	oth=max(oth,check());//更新答案 
	for(int i=1;i<=n;i++)
		if(!vis[i] && !inv[i]) dfs_on_r(i);//找根节点遍历 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		g[y].push_back(x);//g用来解决问题1 
		r[x].push_back(y);//r用来解决问题2 
	}
	topsort_on_g();//解决问题1
	for(int i=1;i<=n;i++)
		printf("%d\n",sorted[i]);
	memset(vis,false,sizeof(vis));
	for(int i=1;i<=n;i++)
		inv[i]=g[i].size();//初始入度=被多少节点打败 
	oth=0;//oth用来标记是否存在其它方案 
	topsort_on_r();//解决问题2 
	printf("%d\n",oth);
	return 0;
}
```
代码效率可能不是很高，希望各位路过的大佬可以提出改进意见哦

---

## 作者：BFSBFSBFSBFS (赞：2)

~~填坑.~~

题意.有n个队伍.m对输赢关系.找出1种符合输赢关系的队伍名次排列.并判断是否有其它可能.

输赢关系:1种关系$x_i, y_i$表示$x_i$能打败$y_i$.即$x_i$的名次靠前.

首先.没有被打败过的队伍有可能是第1名.

第2名可能是没有被打败的,或者只被第1名打败的.

明显是拓扑了..

找到入度为0的队伍.给予剩下最靠前的名次.删掉它所有的出边.

任意时刻存在有多个入度为0的队伍,就有多种可能.

 ![](https://cdn.luogu.com.cn/upload/pic/12606.png) .

 ![](https://cdn.luogu.com.cn/upload/pic/12608.png) .

结果为ABCD,或ACBD,ACDB.

用的邻接表...时间与空间效率$O(n^2)$.

Diu代码..

```cpp
program P1960;
 var
  b:array[0..5001,0..5001] of longint; //当时用的邻接表..
  a,d,f:array[0..5001] of longint;
  i,j,m,n,o,p,p1:longint;
 begin
  readln(n);
  readln(m);
  fillchar(a,sizeof(a),0);
  fillchar(d,sizeof(d),0);
  fillchar(f,sizeof(f),0);
  for i:=1 to m do
   begin
    readln(o,p);
    inc(a[o]);         //统计出度.
    inc(d[p]);         //统计入度.
    b[o,a[o]]:=p;      //记录出边.
   end;
  i:=1;
  p1:=0;
  while i<=n do
   begin
    inc(i);    //表示当前名次+1.
    p:=0;
    for j:=1 to n do
     if (d[j]=0) and (f[j]=0) then     //入度为0.且未被加入名次中.
      begin
       if p<>0 then p1:=1;             //多种情况出现.
       if p=0 then p:=j;
      end;
    f[p]:=1;              //标记已加入.
    for j:=1 to a[p] do   //删掉所有出边.
     dec(d[b[p,j]]);
    writeln(p);
   end;
  writeln(p1);
 end.
```

---

## 作者：Trinity (赞：1)

# P1960 郁闷的记者_NOI导刊 
## 题目描述
有一些编号，再给出一些名次先后的关系，让你列出排名以及判断是否有多种排名方法。  
## 分析
即使题目没有明确提出图的概念，但是无论是先后次序，还是列出排名方法，很明显就是拓扑排序。上下的题解要么是就着题意分析，要么就是自己开创的方法，但是就是板子。
## 解答
根据提供的次序关系，我们显然可以摆出每个点的**等级**（即$level$），再根据等级进行带权排序，等级越高的点排名越靠前，而如果有两个点的等级相同，那么它们就可以随意交换排名，所以就有多种排序方法。程序很好打，就是套板子。  
下面上代码。
```cpp
queue<int>q;
int n,m,head[N*2],cnt,ind[N],lev[N];
struct graph{int to,next;}e[N*2];
inline void addedge(int u,int v)
{
    e[++cnt].next=head[u],head[u]=cnt;
    e[cnt].to=v;
}
inline void topo_bfs()
{
    for(int i=1;i<=n;i++)if(!ind[i])lev[i]=0,q.push(i);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=e[i].next)
        {
            int v=e[i].to;
            ind[v]--,lev[v]=lev[u]+1;
            if(!ind[v])q.push(v);
        }
    }
}
struct answer{int u,lev;}ans[N];
inline bool cmp(answer a,answer b){return a.lev<b.lev;}
int main()
{
    n=read(),m=read();
    for(int i=1,u,v;i<=m;i++)
        u=read(),v=read(),addedge(u,v),ind[v]++;
    topo_bfs();
    for(int i=1;i<=n;i++)ans[i].u=i,ans[i].lev=lev[i];
    sort(ans+1,ans+n+1,cmp);
    bool f=0;
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",ans[i].u);
        if(i!=1)if(ans[i].lev==ans[i-1].lev)f=1;
    }
    printf("%d",f);
    return 0;
}
```
## 总结
模板思想十分重要。。。

---

## 作者：Infinity_shl (赞：1)

鉴于还没有Cpp的题解，本人蒟蒻就来发表一下

dalao勿喷！

本人采用最基本的拓扑排序算法，首先统计每个点的入度（好像没有什么卵用）、出度，以及每个球队可以战胜的队伍，对于出度为0的入栈，统计当前入栈的个数，如果大于1，则有多种情况————————，具体见代码

----------

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<stack>
#include<cstdlib>     头文件
using namespace std;
int n,m;
vector<int> a[5011];     每个队伍战胜的队伍
int in[5011],out[5011];  入度、出度
stack<int> q;            栈
bool x=0;                判断是否存在多种情况
int sum;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		in[x]++;              统计
		out[y]++;
		a[x].push_back(y); 
	}                         读入
	for(int i=1;i<=n;i++)
		if(!out[i]) q.push(i),sum++; 入栈
	if(sum>1) x=1;               多种情况判断
	sum=0;
	while(!q.empty())            
	{
		sum=0;
		int now=q.top();  
		cout<<now<<endl;        输出答案
		q.pop(); 
		for(int i=0;i<a[now].size();i++)
		{                           删边
			out[a[now][i]]--;
			if(!out[a[now][i]]) sum++,q.push(a[now][i]);       入栈
		}
		if(sum>1) x=1;        判断
	}
	if(x) cout<<1;         多种情况的输出
	else cout<<0;
    cout<<"请 勿 作 弊 ！";   重点！！
	return 0;
}
```

结束了---

---

## 作者：Jith_2004 (赞：0)

[P1960](https://www.luogu.org/problemnew/show/P1960)

楼上是用栈实现的dfs来做Topological Sort，而本人不才，是用递归实现的。

其实我们做这题只需要每个节点的入度，因为拓扑排序的起点是入度为零的节点，记录出度其实没有必要。

**特别要注意的是，由于dfs是逆向确定各顶点的拓扑顺序，**所以在输出之前，要对记录的顶点顺序进行反序操作（或者直接反序输出也行），如果是用vector的话可以这么写：

```cpp
reverse(topo.begin(),topo.end());
```

虽然宽搜和深搜做拓扑排序的复杂度都是O(|V|+|E|),但是数据一大或者大规模图会引起栈溢出，所以大家还是用宽搜或用栈实现dfs比较妥当。

详细代码和测评结果[请点这里](https://www.luogu.org/record/show?rid=9858248)

---


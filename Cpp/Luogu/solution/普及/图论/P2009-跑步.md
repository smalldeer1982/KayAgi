# 跑步

## 题目背景

跑步是一项有意思的运动，尤其是可以开发人的脑筋。常神牛很喜欢跑步。


## 题目描述


常神牛跑步的场地是一个多边形（边数 $\leq 20$，每个顶点用英文大写字母表示），并且在这个多边形内部，还会有一些小道，连接两个不相邻的顶点。所有的边长和小道都是双向通行的举例来说，下面一个图：

 ![](https://cdn.luogu.com.cn/upload/pic/1049.png)

假设常神牛从 $A$ 点跑到 $D$ 点，最短的路径是 $A-E-D$（长度为 $6$）。

现在告诉你多边形的边数 $n$，多边形每条边的长度，多边形内的连线数 $k$，每条连线的两个端点及长度，以及起始点和结束点，请你输出最短路径的长度。但是常神牛有点强迫症，如果两点之间有多条道路直接连接，他会选择最长的那条。

注意：输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为 $0$。


## 说明/提示

对于 $20\%$ 的数据，$k=0$；

对于 $50\%$ 的数据，$k \leq 10$；

对于 $100\%$ 的数据，$1 \leq n \leq 20$，$0 \leq m \leq 50$，$k \leq 100$，所有路径长度均不大于 $1000$。

## 样例 #1

### 输入

```
5 2
6 4 5 4 2
A D 7
E B 8
A D```

### 输出

```
6```

# 题解

## 作者：kkksc03 (赞：57)

最后一题用到了一种令普及组的同志们抓狂的算法：图论。这就是一道图论练习题，没什么好说的，预处理按题目走，然后floyd秒过。


---

## 作者：Exber (赞：9)

这道题直接用 Floyd 就能过(~~其实是因为我把 dijkstra 忘得差不多了~~)。

这么简单的一道题，为什么只有七百多人通过呢？

因为他太~~毒瘤~~水了，大佬们都不做……

**Floyd 算法是啥**

Floyd 算法是一款时间复杂度为 $O(n^3)$ 的算法(n 为点数)，它主要是用来求多源最短路(就是每个点到其他点的最短路)。

这种算法类似于 DP，我们用一个二维数组 d 来存最短路的长度，$d_{i,j}$ 表示点 i 到点 j 的最短路长度。那么我们只要再枚举一个中间点 k，判断 i 到 k 再到 j 的路径长度是不是比 i 直接到 j 短。如果是那就更新 $d_{i,j}$。写成大佬们口中的 "状态转移方程" 就是 $d_{i,j}=\max(d_{i,j},d_{i,k}+d_{k,j})$。

**本题一大坑点**

题目里说了:
```
输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。
在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。
所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为0。
```
所以每条边都要取最大值，不然就错了（~~我在这里卡很久~~）。

**AC代码**
```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 

using namespace std;

int n,k,d[105][105]; //d[i][j]表示i到j的最短路距离

int main()
{
	scanf("%d%d",&n,&k);
	memset(d,0x3f,sizeof(d));
	for(int i=1;i<=n;i++)
	{
		int t;
		scanf("%d",&t);
		if(d[i][i%n+1]!=d[104][104])//本题一大坑点 
		{
			t=max(t,d[i][i%n+1]);
		}
		d[i][i%n+1]=t;
		d[i%n+1][i]=t;
	}
	for(int i=1;i<=k;i++)
	{
		char s,e;
		int t;
		cin>>s>>e;
		scanf("%d",&t);
		s=s-'A'+1;//字符->数字转换
		e=e-'A'+1;//字符->数字转换
		if(d[s][e]!=d[104][104])//本题一大坑点 
		{
			t=max(t,d[s][e]);
		}
		d[s][e]=t;
		d[e][s]=t;
	}
	for(int k=1;k<=n;k++)//枚举中间点
	{
		for(int i=1;i<=n;i++)//枚举起点
		{
			for(int j=1;j<=n;j++)//枚举终点
			{
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);//更新
			}
		}
	}
	char s,e;
	cin>>s>>e;
	s=s-'A'+1;//字符->数字转换
	e=e-'A'+1;//字符->数字转换
	printf("%d\n",d[s][e]);
	return 0;
}
```


---

## 作者：伟大的王夫子 (赞：5)

如果想要更好的体验，可以到[我的博客](https://www.luogu.org/blog/I-AK-IOI/)去看

这题一看，就是一个最短路，要求输出从一个点到另一个点的最短路

由于$n$比较小，适合用$O(n^3)$的$Floyd$偷懒

所以，我们建造一个二维数组$d$， 将其赋值为0x3f,先读入每条边的长度，然后取max

可是，不能每次取max，因为一开始$d$数组的值都很大。所以，我们要进行一个特判。

另外，将字母转化为数字

即$A \to1, B \to 2, C \to 3 \cdots Z \to 26$

即把字母的值减去'A',再+1

最后在运行转移方程$d[i][j] = \min(d[i][j], d[i][k]+d[k][j])$,循环顺序依次是$k, i, j$

最后详见代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, d[25][25];
int main() {
	cin >> n >> m;
	memset(d, 0x3f, sizeof d);
	for (register int i = 1; i < n; ++i) {
		int x;
		cin >> x;
		d[i + 1][i] = d[i][i + 1] = x;
	}
	int x;
	cin >> x;
	d[n][1] = d[1][n] = x;
	for (register int i = 1; i <= m; ++i) {
		char a, b;
		int x, y, z;
		cin >> a >> b >> z;
		x = a - 'A' + 1, y = b - 'A' + 1;//字母转化数字 
		if (d[x][y] == 0x3f3f3f3f) d[y][x] = d[x][y] = z;
		else d[y][x] = d[x][y] = max(d[x][y], z);//这里我们特判一下，不能每个边都取max 
	}
	for (register int k = 1; k <= n; ++k)	
		for (register int i = 1; i <= n; ++i)
			for (register int j = 1; j <= n; ++j)
				d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
	char a, b;
	cin >> a >> b;
	//cout << d[1][4];
	cout << d[(int)a - 'A' + 1][(int)b - 'A' + 1];
}
```

---

## 作者：落寞孤云 (赞：3)

没人写dijstra？那就让我来捡个漏吧=w=
数据略水，我忘用小根堆都过了六个点。
第一次发题解，dalao勿喷。
```cpp
#include<bits/stdc++.h>
#define MAXN 2500
#define INF 20000
#define N(x) x-'A'+1
using namespace std;
typedef pair<int,int> pii;
int g[MAXN][MAXN],n,k,begin,end,a[MAXN],vis[MAXN]; //a为源点到目标的距离，vis为访问标记 
priority_queue<pii,vector<pii>,greater<pii> > q; //小根堆优化，记住pair的排序方式是按第一个元素来，所以距源点距离要放在前面 
void read()
{
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		if(i < n)
		    {
		        g[i][i+1]=max(g[i][i+1],x);
		        g[i+1][i]=max(g[i][i+1],x);
		    }
		else
		    {
		        g[i][1]=max(g[i][i+1],x);
		        g[1][i]=max(g[i][i+1],x);
		    }
	}
	for(int i=1;i<=k;i++)
	{
		char a,b;
		int x,a1,b1;
		cin>>a>>b>>x;
		a1=N(a); b1=N(b);
		g[b1][a1]=g[a1][b1]=max(g[a1][b1],x);
	}
	char a,b;
	cin>>a>>b;
	begin=N(a); end=N(b);
}

void dijstra(int s)
{
	a[s]=0;
	q.push(pii(0,s));
	while(!q.empty())
	{
		pii now=q.top(); q.pop();
		int x=now.second,y=now.first;
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=1;i<=n;i++)
		{
			if(g[x][i] == -1 ) continue;
			if(g[x][i] + a[x] < a[i])
			{
				a[i]=a[x]+g[x][i];
				q.push(pii(a[i],i));
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		a[i]=INF;
		for(int j=1;j<=n;j++)
		{
			g[i][j]=-1;
		}
	}
	read();
	dijstra(begin);
	if(begin == end)
	{
		printf("%d",g[begin][end] == -1 ? 0:g[end][end]); //特判，end比begin的字少一些诶 
		return 0; 
	}
	printf("%d",a[end]);
}
```

---

## 作者：No_wonder (赞：2)

其实就是一道图论的基础题而已。

题意是：给你一个有重边的图，如果两点间有重边，那么这两点距离取重边中最大值，求最短路。

因为$n$小到离谱，用Flyod可以愉快的通过这道题。

## Floyd
这里引用了这篇[blog](https://blog.csdn.net/chensheep/article/details/108217938)


首先我们介绍一下松弛概念：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nL2UydGtnYTVoLnBuZw?x-oss-process=image/format,png#pic_center)

这张图片中灰与红点间直接相连的边权是7，这是我们通过绿点松弛，发现从灰到绿再到红更短，我们就选择这条路径。

对于更多点的情况，我们枚举每一个点为松弛点，对其他所有点对进行松弛，同时贪心的选取最小值，这就是Floyd。

代码简洁又经典

```cpp
	for(ri t=1;t<=n;t++)//松弛点的枚举一定要放最外层
	for(ri i=1;i<=n;i++)
	for(ri j=1;j<=n;j++)
	dis[i][j]=dis[j][i]=min(dis[i][j],dis[i][t]+dis[t][j]);

```

现在回头看看，总算理解了Flyod这个算法的本质是动态规划。$dis[i][j]$里面存储的是目前的最优解，倘若有松弛点且符合转移条件，就进行一次状态转移。这样想也理解了为什么要把松弛点的枚举放在最外面。因为松弛点的变动实质上就是状态的转移，如果这时的状态中的每一个点对$(i,j)$还没有处理完，就会漏掉一些状态导致最终的解错误。

如果您是初学者读不懂上面一段话，请不要沮丧。再经过一些时间你再偶尔翻到这篇题解时，说不定还会嘲笑我的认识肤浅呢。如果有认识更高深的dalao，欢迎指出这篇题解中的不足，


学会了Floyd，然后根据题意模拟就好，具体细节请见我这篇代码。

```cpp
#include<bits/stdc++.h>
#define ri register int
#define inf INT_MAX/2
using namespace std;
int n,k;
int dis[150][150];
int main()
{
	cin>>n>>k;
	for(ri i=1;i<=n;i++)							//初始化为极大值，防止Floyd中误选。 
	for(ri j=1;j<=n;j++)
	dis[i][j]=inf;									
	for(ri i=1;i<=n;i++)
	{
		int u=i;
		int v=i%n+1;								//转数字 
		int tmp;
		cin>>tmp;
		if(dis[u][v]==inf)	dis[v][u]=dis[u][v]=tmp;				//如果这条边没有值，就直接赋值 
		else				dis[v][u]=dis[u][v]=max(dis[u][v],tmp); //如果这条边被赋值过，选择最大值 
	}
	for(ri i=1;i<=k;i++)
	{
		char a,b;
		int tmp=0;
		cin>>a>>b>>tmp;												//转数字 
		if(dis[a-'A'+1][b-'A'+1]==inf)	dis[b-'A'+1][a-'A'+1]=dis[a-'A'+1][b-'A'+1]=tmp;	//意义与上面的相同 
		else  dis[b-'A'+1][a-'A'+1]=dis[a-'A'+1][b-'A'+1]=max(dis[a-'A'+1][b-'A'+1],tmp);
	}
	for(ri t=1;t<=n;t++) 																	//Floyd
	for(ri i=1;i<=n;i++)
	for(ri j=1;j<=n;j++)
	dis[i][j]=dis[j][i]=min(dis[i][j],dis[i][t]+dis[t][j]);
	char a,b;
	cin>>a>>b;
	cout<<dis[a-'A'+1][b-'A'+1];
}
```


---

## 作者：ShineEternal (赞：2)

[$My\ blog$](https://blog.csdn.net/kkkksc03/article/details/102733586)

看到题解少，来补充一篇。。。


## description（notes）：

变相给出一个图求最短路，对特殊情况有特殊要求


## solution：

这道题观察到数据范围小的可怜，便可以使用Floyd算法解决。

在刚刚处理的时候，要注意一句话

> 如果两点之间有多条道路直接连接，他会选择最长的那条。

所以如果这一条边中已经记录了数据，就取个max就行了。

对于多边形的边上和里面的连线都做这样的操作。

然后跑Floyd

**注意：**

- scanf和cin最好不要一块用。

- 最短路别忘了赋初值

- 字符转为数字下标考虑清楚是从0还是1开始

## code:
```cpp
#include<cstdio>
#include<iostream>
#define inf 0x3f3f3f3f
using namespace std;
int a[105][105];
int main()
{
	int n,k,x;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j]=inf;
		}
	}
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(a[i][i%n+1]!=inf)
		{
			a[i][i%n+1]=a[i%n+1][i]=max(x,a[i%n+1][i]);
		}
		else
		{
			a[i][i%n+1]=a[i%n+1][i]=x;
		}
	}
	char s,e;
	for(int i=1;i<=k;i++)
	{
		int val;
		cin>>s>>e>>val;
		
		int x=s-'A'+1;
		int y=e-'A'+1;
		if(a[x][y]!=inf)
		{
			a[x][y]=a[y][x]=max(val,a[x][y]);
		}
		else
		{
			a[x][y]=a[y][x]=val;
		}
	}
	char n1,n2;
	cin>>n1>>n2;
	int ans1=n1-'A'+1;
	int ans2=n2-'A'+1;
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
			}
		}
	} 
	cout<<a[ans1][ans2]<<endl;
	return 0;
} 
```

---

## 作者：ljc20020730 (赞：2)

这道题给我们的教训是仔细审题……

原来题目中有这么一段话，我竟然没看……

```cpp
注意：输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为0。
```
所以一开始就依靠这点代码拿了60分。。。

```cpp
uses math;
var n,i,j,k,s,t:longint;
    g:array[1..20,1..20]of longint;
    ch1,ch2,kong:char;
    st:string;
begin
 readln(n,k);
 for i:=1 to n do
  for j:=1 to n do
   g[i,j]:=maxlongint div 3;
 for i:=1 to n do begin
  read(t);
  if i=n then begin g[n,1]:=t; g[1,n]:=t; continue; end;
  g[i,i+1]:=t;
  g[i+1,i]:=t;
 end;
 readln;
 for i:=1 to k do begin
  read(ch1);read(kong);read(ch2);readln(st);
  val(st,t);
  t:=min(g[ord(ch1)-ord('A')+1,ord(ch2)-ord('A')+1],t);//注意！！！
  g[ord(ch1)-ord('A')+1,ord(ch2)-ord('A')+1]:=t;//注意！！！
  g[ord(ch2)-ord('A')+1,ord(ch1)-ord('A')+1]:=t;//注意！！！
 end;
 for k:=1 to n do
  for i:=1 to n do
   for j:=1 to n do
    if (k<>i)and(i<>j)and(j<>k)and(g[i,j]>g[i,k]+g[k,j])
    then g[i,j]:=g[i,k]+g[k,j];
 readln(ch1,kong,ch2);
 s:=ord(ch1)-ord('A')+1;
 t:=ord(ch2)-ord('A')+1;
 writeln(g[s,t]);
end.
```
后来才发现原来要特判。。。
再来回味一下：

```cpp
注意：输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为0。
```
所以在1分多钟后就诞生了P党的AC代码：

```cpp
uses math;
var n,i,j,k,s,t:longint;
    g:array[1..20,1..20]of longint;
    ch1,ch2,kong:char;
    st:string;
begin
 readln(n,k);
 for i:=1 to n do
  for j:=1 to n do
   g[i,j]:=maxlongint div 3;
 for i:=1 to n do begin
  read(t);
  if i=n then begin g[n,1]:=t; g[1,n]:=t; continue; end;
  g[i,i+1]:=t;
  g[i+1,i]:=t;
 end;
 readln;
 for i:=1 to k do begin
  read(ch1);read(kong);read(ch2);readln(st);
  val(st,t);
  if g[ord(ch1)-ord('A')+1,ord(ch2)-ord('A')+1]<>maxlongint div 3 then//注意！！！
  t:=max(g[ord(ch1)-ord('A')+1,ord(ch2)-ord('A')+1],t);//注意！！！
  g[ord(ch1)-ord('A')+1,ord(ch2)-ord('A')+1]:=t;//注意！！！
  g[ord(ch2)-ord('A')+1,ord(ch1)-ord('A')+1]:=t;//注意！！！
 end;
 for k:=1 to n do
  for i:=1 to n do
   for j:=1 to n do
    if (k<>i)and(i<>j)and(j<>k)and(g[i,j]>g[i,k]+g[k,j])
    then g[i,j]:=g[i,k]+g[k,j];
 readln(ch1,kong,ch2);
 s:=ord(ch1)-ord('A')+1;
 t:=ord(ch2)-ord('A')+1;
 writeln(g[s,t]);
end.
所以大家要仔细审题啊！！1
```

---

## 作者：Isshiki·Iroha (赞：1)

这题说白了就是求最短路，而且题目数据也~~很水~~，我写了最朴素的  Dij（~~Floyd 不会~~）。

这题我一开始觉得没什么，但 debug 的时候发现坑太多了，这里我总结一下。

1. “第二行，$n$ 个数，分别表示多边形每条边的长度（按顺时针次序依次给出，即分别为 $AB$，$BC$，$CD$，$DE$ 等等的长度）。” 这里要注意不能直接打 for，因为最后一个应该是从 $n$ 到 $1$。

2. 两点之间有多条路选最长（为什么我用矩阵存）。

3. 如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为 $0$。

4. 双向边。

其余的在代码里注释。

下面是代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
using namespace std;
const int maxn=27;
const int INF=0x3f3f3f3f;
int n,m,s,e;
char a,b;
struct MAPS {
	int maps[maxn][maxn],vis[maxn];
	int dis[maxn];
	void dij(int s,int e) {
		vis[s]=1;
		for(reg int i(1);i<=n;++i)dis[i]=maps[s][i];
		int minx,addr=s,marks=s;
		for(reg int i(1); i<=n; ++i) {
			minx=INF;
			for(reg int j(1); j<=n; ++j) {
				if(!vis[j]&&maps[addr][j]) {//是否与addr连接
					if(minx>dis[j]){
						minx=dis[j];
						marks=j;//找最短路径的点relax
					}
				}
			}
			//cout<<marks<<endl;
			vis[marks]=1;//标记
			for(reg int j=1;j<=n;++j){
				if(dis[addr]+maps[addr][j]<dis[j]){
					dis[j]=dis[addr]+maps[addr][j];//松弛relax
				}
			}
			addr=marks;//改变起点继续松弛
		}
		cout<<dis[e];
	}
} Chtholly;
struct L {
	void input() {
		cin>>n>>m;
		for(reg int i(1); i<=n; ++i) {
			for(reg int j(1); j<=n; ++j) {
				Chtholly.maps[i][j]=-1;
			}
			Chtholly.maps[i][i]=0;
		}
		for(reg int i(1),w; i<n; ++i) {
			cin>>w;
			Chtholly.maps[i+1][i]=Chtholly.maps[i][i+1]=w;//取最大
		}
		int w;
		cin>>w;
		Chtholly.maps[n][1]=Chtholly.maps[1][n]=max(Chtholly.maps[1][n],w);//特殊处理
		for(reg int i(1),j,k; i<=m; ++i) {
			cin>>a>>b>>w;
			j=a-'A'+1;
			k=b-'A'+1;
			Chtholly.maps[j][k]=Chtholly.maps[k][j]=max(Chtholly.maps[j][k],w);
		}
		cin>>a>>b;
		s=a-'A'+1;
		e=b-'A'+1;
		for(reg int i(1); i<=n; ++i) {
			for(reg int j(1); j<=n; ++j) {
				if(Chtholly.maps[i][j]!=-1)continue;
				Chtholly.maps[i][j]=INF;
			}
        //Chtholly.maps[i][j]=0;
        //这里不能加，因为自己到自己可能不是0。
		}
	}
} Misaka;
int main() {
	ios::sync_with_stdio(false);
	Misaka.input();
	Chtholly.dij(s,e);
	return 0;
}
```

---

## 作者：Toxic_Obsidian (赞：1)

我真的是无语了，提交了7遍才过（所以注意读题啊）

这是一道很裸的FLOYD-WARSHALL的练习题

C++党的蒻鸡见楼下用SPFA表示太长，就写了个FLOYD

附上代码，注意预处理和FLOYD的三层递归别写错了

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn=20+5;
const int INF=0x7ffffff;

int g[maxn][maxn];
int n,k;

int main()
{
    ios::sync_with_stdio(false);
    ///INITIALIZE
    for(int i=0;i<maxn;i++){
        for(int j=0;j<maxn;j++){
            g[i][j]=INF;
        }
        g[i][i]=0;
    }
    ///INPUT STAGE
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        int t;
        cin>>t;
        if(i!=n) g[i][i+1]=g[i+1][i]=t;
        else g[i][1]=g[1][i]=t;
    }
    for(int i=1;i<=k;i++){
        char x,y;
        int t;
        cin>>x>>y>>t;
        int a=x-'A'+1;
        int b=y-'A'+1;
        if(g[a][b]!=INF) g[a][b]=g[b][a]=max(g[a][b],t);
        else g[a][b]=g[b][a]=t;
    }
    ///FLOYD STAGE
    for(int k=1;k<=n;k++){                                   ///中间节点必须写在这里！！！要不然#7会WA（别问我怎么知道的）
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                g[i][j]=g[j][i]=min(g[i][j],g[i][k]+g[k][j]);
            }
        }
    }

    char st,ed;
    cin>>st>>ed;
    cout<<g[st-'A'+1][ed-'A'+1];

    return 0;
}
```

---

## 作者：理想气体 (赞：1)

看到没有c++的题解，我来补一发；

非常简单的图论题，按照题目说的处理，最后跑一边单源最短路算法就行。

我这里就用SPFA写了，由于数据规模小，代码稍微有点水= =





```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
bool isin1[50][50] , isin2[50];
int map[50][50];
int d[50];
vector<int> w[50];
queue<int> q;
int B , E;
void spfa()
{
    d[B] = 0;
    q.push(B);isin2[B] = true;
    while(!q.empty())
    {
        int li = q.front(); q.pop(); isin2[li] = false;
        for(vector<int>::iterator ite = w[li].begin() ; ite != w[li].end() ; ite++)
        {
            if(d[*ite] > d[li] + map[li][*ite])
            {
                d[*ite] = d[li] + map[li][*ite];
                if(!isin2[*ite])
                {
                    q.push(*ite);isin2[*ite] = true;
                }
            }
        }
    }
}
int main()
{
    int n , k;
    cin>>n>>k;
    for(int i = 0 ; i <= n ; i++)
    {
        d[i] = 10000000;
    }
    for(int i = 1 ; i < n ; i++)
    {
        int x ; cin>>x;
        map[i][i+1] = map[i+1][i] = x;
        w[i].push_back(i+1);
        w[i+1].push_back(i);
    }
    int x; cin>>x; map[n][1] = map[1][n] = x;
    w[n].push_back(1);w[1].push_back(n);
    for(int i = 1 ; i <= k ; i++)
    {
        char x ,y; cin>>x>>y;
        int a = x-'A'+1 , b = y-'A'+1;
        int l;cin>>l;
        if(!isin1[a][b])
        {
            w[a].push_back(b);
            w[b].push_back(a);
            isin1[a][b] = isin1[b][a] = true;
        }
        if(map[a][b] < l)
            map[a][b] = map[b][a] = l;
    }
    char c1 , c2;
    cin>>c1>>c2;
    B = c1-'A'+1;E = c2-'A'+1;
    if(B == E)
    {
        cout<<map[B][E];
        return 0;
    }
    spfa();
    cout<<d[E];
    return 0;
}
```

---

## 作者：夏色祭 (赞：1)

这显然是一题最短路，但数据实在有些弱，于是我就用了搜索。。。

AC代码：

```cpp
var
  a:array['A'..'Z','A'..'Z']of longint;
  b:array['A'..'Z']of boolean;
  n,m,i,j,x,min:longint;
  x1,y1:char;
  s:ansistring;
procedure try(k:char;sum:longint);
var
  i:char;
  begin
    if (k=y1)and(sum<>0) then //到达终点
      begin
        if sum<min then min:=sum;
        exit;  
      end;
    if sum>=min then exit;//剪枝
    for i:='A' to 'Z' do 
      if not b[i] and (sum+a[k,i]<min) and (a[k,i]<>0) then 
        begin
          b[i]:=true;
          try(i,sum+a[k,i]);
          b[i]:=false;//回溯
        end;
  end;
begin
  readln(n,m);
  for i:=1 to n do 
    begin
      read(x);
      if i<n then 
        begin 
          a[chr(ord('A')+i-1),chr(ord('A')+i)]:=x;
          a[chr(ord('A')+i),chr(ord('A')+i-1)]:=x;
        end
        else 
          begin
            a[chr(ord('A')+i-1),'A']:=x;
            a['A',chr(ord('A')+i-1)]:=x;
          end;
    end;
  readln;
  for i:=1 to m do 
    begin
      readln(s);
      x1:=s[1];
      delete(s,1,pos(' ',s));
      y1:=s[1];
      delete(s,1,pos(' ',s));
      val(s,x);
      if a[x1,y1]<x then 
        begin
          a[x1,y1]:=x;
          a[y1,x1]:=x;
        end;
    end;
  readln(s);
  x1:=s[1];
  delete(s,1,pos(' ',s));
  y1:=s[1];
  min:=maxlongint;
  if x1<>y1 then b[x1]:=true;//注意起点就是终点的情况
  try(x1,0);
  write(min);
end.
```

---


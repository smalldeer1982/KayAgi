# 拆地毯

## 题目背景

还记得 NOIP 2011 提高组 Day1 中的铺地毯吗？时光飞逝，光阴荏苒，三年过去了。组织者精心准备的颁奖典礼早已结束，留下的则是被人们踩过的地毯。请你来解决类似于铺地毯的另一个问题。


## 题目描述

会场上有 $n$ 个关键区域，不同的关键区域由 $m$ 条无向地毯彼此连接。每条地毯可由三个整数 $u$、$v$、$w$ 表示，其中 $u$ 和 $v$ 为地毯连接的两个关键区域编号，$w$ 为这条地毯的美丽度。

由于颁奖典礼已经结束，铺过的地毯不得不拆除。为了贯彻勤俭节约的原则，组织者被要求只能保留至多 $K$ 条地毯，且保留的地毯构成的图中，任意可互相到达的两点间只能有一种方式互相到达。换言之，组织者要求新图中不能有环。现在组织者求助你，想请你帮忙算出这至多 $K$ 条地毯的美丽度之和最大为多少。


## 说明/提示

选择第 $1$、$2$、$4$ 条地毯，美丽度之和为 $10 + 9 + 3 = 22$。

若选择第 $1$、$2$、$3$ 条地毯，虽然美丽度之和可以达到 $10 + 9 + 7 = 26$，但这将导致关键区域 $1$、$2$、$3$ 构成一个环，这是题目中不允许的。


$1\le n,m,k \le 10^5$。


## 样例 #1

### 输入

```
5 4 3
1 2 10
1 3 9
2 3 7
4 5 3```

### 输出

```
22```

# 题解

## 作者：星爵 (赞：33)

模拟赛上做的题

就排个序

然后做   k   条边的最大生成树

然后就莫名奇妙的AC了

然后...

就没有然后了

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,k,f[100100],ans;
struct no
{
    int x,y,z;
}a[100100];
bool comp (const no & a,const no &b)
{
    return a.z>b.z;
}
int find(int x)
{
    if(f[x]!=x)
        f[x]=find(f[x]);
    return f[x];
}
void un(int x,int y)
{
    f[x]=y;
}
int main()
{
    freopen("carpet.in","r",stdin);
    freopen("carpet.out","w",stdout);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
    sort(a+1,a+m+1,comp);
    for(int i=1;i<=n;i++)//并查集，初始时每个祖先都是自己
        f[i]=i;
    for(int i=1,kk=0;i<=m&&kk<k;i++)
    {
        int l=find(a[i].x),r=find(a[i].y);
        if(l!=r)//不在同一集合就合并
        {
            un(l,r);
            kk++;//计数
            ans+=a[i].z;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：顾z (赞：13)

# [顾z](https://www.cnblogs.com/-guz/) 

题目描述--->[p2121 拆地毯](https://www.luogu.org/problemnew/show/P2121)

## 分析

这题**为什么是最大生成树**.

~~先来bb两句~~

题目为拆地毯,让我们剩下k个地毯.

题目想要我们**求得最大的美丽度**.

且要求我们

``保留的地毯构成的图中，任意可互相到达的两点间只能有一种方式互相到达``

很明显,这一要求提示了我们最后结构会是一棵树

(因为树上路径唯一啊,qwq.

然后根据**正难则反**的思想.

我们考虑**拼地毯**.

所以我们就想到了**kruskal算法**.(｀・ω・´)

与普通kruskal不同的是,这里是一个**最大生成树**

我们**拼到k个得到的最大美丽度就是答案**

**为什么是拼到k个**?

给大家一个图.

![](https://i.loli.net/2018/09/14/5b9b21927734f.png)

如果此时题目要求我们剩下6个地毯,很明显我们将6个地毯放入同一个并查集中就可满足条件.

(已经预处理出较大美丽度的情况下)

**拆地毯,让我们剩下k个,因此我们合并出k个即可**

~~所以就裸了~~

## 做法

我们只需要对最小生成树略微修改,把**边权从大到小排序**即可.

**注意判断已经加入到同一个并查集中的数量为k.**

------------------代码------------------

```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
using namespace std;
IL void in(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int fa[100008],n,m,ans,cnt,k;
struct E{int pre,to,w;}edge[400008];
IL bool cmp(const E&a,const E&b)
{
	return a.w>b.w;
}//边权从大到小排序.
IL int find(int x)
{
	return fa[x]==x?x:fa[x]=find(fa[x]);
}//路径压缩并查集
IL void kruskal()
{
    sort(edge+1,edge+m+1,cmp);//排序
    for(RI i=1;i<=m;i++)
    {
        RI u=edge[i].pre,v=edge[i].to,w=edge[i].w;
        int fu=find(u),fv=find(v);
        if(fu==fv) continue;
        ans+=w;fa[fv]=fu;
        cnt++;
        if(cnt==k) break;//判断已经拼了k个地毯.
    }
}
int main(){
    in(n),in(m);in(k);
    for(RI i=1;i<=n;i++) fa[i]=i;//并查集初始化.
    for(RI i=1;i<=m;i++) 
    in(edge[i].pre),in(edge[i].to),in(edge[i].w);
    kruskal();//kruskal操作
    printf("%d",ans);
}
```

---

## 作者：孑彧 (赞：6)

# P2121 拆地毯 解题报告

### 题意

有一个无向图，每条边有边权，求保留k条边，且不构成环的最大总权值是多少

### 思路

这个题是最大生成树~~（这不是废话么~~

所以我们只需要将边排序，然后跑一边kruskal就好了,每当取一条边的时候，cnt++，直到cnt==k

### 代码

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 110000
using namespace std;
struct Edge{
	int x,y;
	double v;
	bool operator < (const Edge &a)const{
		return v>a.v;
	}
}e[maxn];
int ecnt;
void adde(int x,int y,int v){
	e[++ecnt].x=x;
	e[ecnt].y=y;
	e[ecnt].v=v;
}
int p,s;
int f[maxn];
int find(int x){
	if(x==f[x]){
		return x;
	}
	else{
		return f[x]=find(f[x]);
	}
}
bool merge(int x,int y){
	int fx=find(x);
	int fy=find(y);
	if(fx==fy){
		return false;
	}
	else{
		f[fx]=fy;
	}
	return true;
}
int n,m,k;
int main(){
	scanf("%d %d %d",&n,&m,&k);
	int x,y,z;
	for(int i=1;i<=m;i++){
		scanf("%d %d %d",&x,&y,&z);
		adde(x,y,z);
	}
	for(int i=1;i<=n;i++){
		f[i]=i;
	}
	int tot=0;
	int ans=0;
	sort(e+1,e+1+m);
	for(int i=1;i<=n-1;i++){
		x=e[i].x;
		y=e[i].y;
		if(merge(x,y)){
			tot++;
			ans+=e[i].v;
		}
		if(tot==k){
			break;
		}
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：TheAutumnGlory (赞：5)

## 这道题很明显是让我们从图（不保证联通）里找出k条边，使得两点之间最多只有1条边，那直接上kruskal，求最大生成树就可以了。

不知道kruskal可以看一下这篇文章：
[传送门](https://www.luogu.org/blog/YangZiWen/xue-xi-bi-ji-1-post)

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
struct node{用结构体储存边的信息，方便排序
	int x,y,len;     x表示起点，y表示终点，len表示此条边的长度
}a[N];
int n,m,k,fa[N];    fa[x]:表示x属于哪集合（学过并查集的应该都知道吧qwq）
bool cmp(node a,node b){  将每条边的长度排序，因为是求最大生成树，所以需从大到小排序
	return a.len>b.len;
}
int _find(int x){  找爸爸（找x的所属集合）
	if(x!=fa[x])
		fa[x]=_find(fa[x]);
	return fa[x];
}
kruskal其实是贪心和并查集的结合，代码也很好写：
void kruskal(){
	int i=1,cnt=0,tot=0;    i表示当前边，cnt表示已选出的边的个数，tot表示最大美丽值
	while(i<=m){找出x与y的所属集合
		int x=_find(a[i].x);
		int y=_find(a[i].y);
		if(x!=y){若不在同一集合（则两点未联通）因为从大到小排了序，所以得到的肯定是最优解
			fa[x]=y;   将x的所属集合设为y
			tot+=a[i].len;  加上当前边的美丽值
			cnt++; 选出边数++
		}
		if(cnt==k)  选完了就不用了在继续选下去了
			break;
		i++;
	}
	printf("%d",tot);
}
int main(){
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=m;i++)
		scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].len);
	for(int i=1;i<=n;i++)并查集的初始化，将每个点的所属集合设为自己
		fa[i]=i;
	sort(a+1,a+1+m,cmp);
	kruskal();
	return 0;
}
```

---

## 作者：一滴小水滴 (赞：4)

## 这道题与最小生成树很相似，有兴趣的童鞋们[戳戳这里](https://www.luogu.org/blog/Zhouqixuan0211/solution-p3366)看看最小生成树。


------------
## 这道题一共有两种办法kruskal和prim，这里给大家讲一讲较简单一点的kruskal算法。


------------
### 步骤：
### 1.用结构体变量edge存储这条边的起点、终点及美丽度；
### 2.用father[]一维数组存储这条边起点和终点的关系，将所有点的 father[]初始化为自己；
### 3.输入后将所有地毯的美丽度用sort快排从大到小排序；
### 4.用kruskal函数来计算答案ans，最后输出答案ans。


------------
### 然后给大家讲一讲比较重要的两个函数：
### 1.find函数，用来查找此结点的根结点。
```cpp
int find(int t)
{
	if(t==father[t])return t;        //如果这个结点的父亲结点就是
                                            他自己，说明他自己就是这棵树的根结点，则返回自己。
	father[t]=find(father[t]);       //递归不断查找根结点。
	return father[t];
}
```

### 2.最重要的kruskal函数，没有返回值，只是改变答案ans的值。
```cpp
inline void kruskal()
{
	int x,y;                  //x、y来临时存储起点关键点和终点关键点的根结点。
	for(int i=1;i<=m;i++)
	{
		x=find(edge[i].u);
		y=find(edge[i].v);
		if(x==y)continue;          //如果他们的根结点相同，说明会构成一个环，
                                               则跳过此次循环。
		ans+=edge[i].w;              //ans不断加上这条地毯的美丽度。
		father[x]=y;                //更改起点关键点的根结点的父亲结点为y。
		tot++;                       //地毯数tot自增。
		if(tot==k)break;              //如果已经有足够的地毯了，则退出循环，
                                                      结束kruskal函数。
	}
}
```


------------
### 这篇题解的重点部分都讲解完毕了，那我们直接上完整AC代码！
```cpp
#include<bits/stdc++.h>
#define MAXN 200005
using namespace std;
struct node
{
	int u,v,w;
}edge[MAXN];                       //edge结构体来存储起点、终点及美丽度。
int n,m,father[MAXN],tot=0,k;
long long ans=0;
int find(int t)                       //find函数，查找根结点。
{
	if(t==father[t])return t;
	father[t]=find(father[t]);
	return father[t];
}
bool cmp(node a,node b)             //sort的cmp函数，将美丽度从大到小排序。
{
	return a.w>b.w;
}
inline void kruskal()              //kruskal函数，将答案ans不断改变。
{
	int x,y;
	for(int i=1;i<=m;i++)
	{
		x=find(edge[i].u);
		y=find(edge[i].v);
		if(x==y)continue;
		ans+=edge[i].w;
		father[x]=y;
		tot++;
		if(tot==k)break;
	}
}
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		father[i]=i;            //将1~n的所有结点的父亲结点都初始化为他自己。
	for(int i=1;i<=m;i++)
	{
		cin>>edge[i].u>>edge[i].v>>edge[i].w;
	}
	sort(edge+1,edge+m+1,cmp);           //用sort将美丽度排序
                                                （此处再一次证明了c++STL的强大）。
	kruskal();                   //开始kruskal函数。
	cout<<ans<<endl;               //输出答案。
	return 0;                   //程序再见！
}
```


------------
## 以上就是这篇题解的内容了，祝大家天天开心、天天快乐、天天AC！！！

---

## 作者：小周猪猪 (赞：3)

根据克鲁斯卡尔的最小生成树的思想：贪心+并查集维护

即，要求美丽值最大，那么需要按照边权进行从大到小排序.

然后，根据排序顺序依次将当前最大的边权加入图中（该贪心策略的证明可以参考克鲁斯卡尔算法的证明，这里不详细论述）

然后，我们需要处理环的问题，需要用并查集来维护：即，当枚举的边的起始点处于同一个集合时说明已经有边相连，不能取这条边.否则将这两个点合并.

说白了就是有边数限制的最大生成树..........

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans=0;
int Edge_cnt=0,tot=0;
int father[10000000];
struct node
{
	int u,v,w;
}edge[10000000];
inline bool cmp(node x,node y)
{
	return x.w>y.w;
}//按边权排序
int getfather(int x)
{
	if (father[x]==x) return x;
	else return father[x]=getfather(father[x]);
}//查找祖先+路径压缩
int main()
{
	int n,m,K;
	cin>>n>>m>>K;
	for (int i=1;i<=m;i++)
	{
		int U,V,W;
		cin>>U>>V>>W;
		edge[++tot]=(node){U,V,W};
	}//这是一种直接对结构体赋值的方法
	sort(edge+1,edge+tot+1,cmp);
	for (int i=1;i<=n;i++) father[i]=i;
	for (int i=1;i<=tot;i++)
	{
		int point1=getfather(edge[i].u);
		int point2=getfather(edge[i].v);
		if (point1!=point2)//若不在同一个集合中时
		{
			father[point1]=point2;
			ans+=edge[i].w;//合并+累加答案
			Edge_cnt++;
			if (Edge_cnt>=K) break;//若超过次数限制则退出
		}
	}
	cout<<ans<<endl;
	return 0;
}

```



---

## 作者：NeilKleist (赞：3)

首先题目要求不能有环，那就一定是树！

然而只能保留k条地毯……那就把多余的删掉就可以了

由于要美丽值最大，所以就是最大生成树，但是只保留前k大的边


代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>

struct Edge//边数据
{
    int from;
    int to;
    int weight;
};

struct Cmp//优先队列比较结构体，按降序排列
{
    bool operator() (const Edge& e1, const Edge& e2)
    {
        return e1.weight < e2.weight;
    }
};

int parent[100010];//父节点
std::priority_queue<Edge, std::vector<Edge>, Cmp> queue;//优先队列

int find(int);//并查集

int main()
{
    int n_count = 0;
    int e_count = 0;
    int m_count = 0;
    std::cin >> n_count >> e_count >> m_count;

    for (int i = 0; i < e_count; i++)//读数据
    {
        int f = 0;
        int t = 0;
        int w = 0;
        std::cin >> f >> t >> w;

        Edge e;
        e.from = f;
        e.to = t;
        e.weight = w;
        queue.push(e);
    }

    for (int i = 0; i <= n_count; i++)//初始化，自己的父节点是自己
    {
        parent[i] = i;
    }

    int max = 0;

    while (m_count > 0)//如果还没有留够
    {
        Edge e = queue.top();
        queue.pop();

        int pf = find(e.from);
        int pt = find(e.to);

        if (pf != pt)//两个不在同一个集合里的话
        {
            parent[pf] = pt;//暴力合并
            max += e.weight;

            m_count--;//留下一条地毯
        }
    }

    std::cout << max << std::endl;

    //system("pause");
    return 0;
}

int find(int x)//并查集合并函数
{
    int px = parent[x];
    while (px != parent[px])//一直找到父节点是自己的节点为止
    {
        px = parent[px];
    }

    int i = x;
    int j = 0;
    while (i != px)//路径压缩
    {
        j = parent[i];
        parent[i] = px;
        i = j;
    }

    return px;
}
```

---

## 作者：Elma_ (赞：1)

## kruskal
实际上这题近似于一道板子题，我太菜只会kruskal。

只不过这里连接两点之间的边用地毯来代替，边权就是地毯的美丽度。

题目还要求拆完后的地毯联通，但不能有环，这一看就是生成树了。所以题目就可以转化为这样的问题：给定一个$n$个点$m$条边的无向图，求出有$k$条边的最大生成树。

最大生成树用kruskal实现也很简单，只需要让边按边权从大到小排序即可。

最后注意是要连$k$条边，而不是$k-1$条边。

## CODE
```
#include <iostream>
#include <algorithm>
using namespace std;

struct node
{
	int x, y, w;
}edge[200002];

int dad[200002];
int n, m, ans, k;

bool cmp(node xx, node yy)
{
	return xx.w>yy.w;//从大到小排序
}

int anc(int x)
{
	if(dad[x] == x)
		return x;
	return dad[x] = anc(dad[x]);//查询祖先
}

void uni(int x, int y)
{
	x = anc(x);
	y = anc(y);
	
	if(x != y)
		dad[x] = y;//合并
}

bool ask(int x, int y)
{
	return anc(x) == anc(y);
}//询问

void work()
{
	cin>>n>>m>>k;
	
	for(int i=1;i<=n;i++)
		dad[i] = i;//dad初始化为自己

	for(int i=1;i<=m;i++)
		cin>>edge[i].x>>edge[i].y>>edge[i].w;
	
	sort(edge+1, edge+m+1, cmp);//从大到小排序
	
	for(int i=1;i<=m;i++)
	{
		if(anc(edge[i].x) != anc(edge[i].y))
        //如果不在一个集合
		{
			k--;//需要连的边数-1
			ans += edge[i].w;
			dad[anc(edge[i].x)] = edge[i].y;//合并	
		} 
		
		if(k == 0)//连了k条边，都连完了
			break;//结束连边
	}
	
	cout<<ans<<endl;
}

int main(void)
{
	work();
	return 0;//完美AC~
}
```


---

## 作者：ModestCoder_ (赞：1)

一道图论简单题，不清楚这么点儿人过

思路很简单，用并查集

先按照美丽度排个序

从大到小

一个一个来（嗯就是这样）

你当前的边加入的话

只能构成你连接的两个点的唯一路径！！

好吧其实就是k条边的最大生成树==







```cpp
var
    a,b,c,f:array[0..100000] of longint;
    n,m,k,i,x,y,ans,t:longint;
procedure sort(l,r: longint);
var
    i,j,x,y: longint;
begin
    i:=l;
    j:=r;
    x:=a[(l+r) div 2];
    repeat
        while a[i]>x do
            inc(i);
        while x>a[j] do
            dec(j);
        if not(i>j) then
            begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                y:=c[i];
                c[i]:=c[j];
                c[j]:=y;
                inc(i);
                j:=j-1;
            end;
    until i>j;
    if l<j then
        sort(l,j);
    if i<r then
        sort(i,r);
end;
function find(p:longint):longint;
begin
    if f[p]=p then
        find:=p else
        find:=find(f[p]);
    f[p]:=find;
end;
begin
    readln(n,m,k);
    for i:=1 to m do
        begin
            readln(b[i],c[i],a[i]);
        end;
    sort(1,m);
    for i:=1 to n do
        f[i]:=i;
    for i:=1 to n do
        begin
            x:=find(b[i]);
            y:=find(c[i]);
            if x<>y then
                begin
                    f[x]:=y;
                    inc(ans,a[i]);
                    inc(t);
                    if t=k then
                        break;
                end;
        end;
    writeln(ans);
end.

```

---

## 作者：此祥非彼翔 (赞：1)

其实此题可以用并查集的思想来写

但前几个点暴力的话也可以的七十来分，这是我们考试的题目；

下面发一下我的代码；

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int asd = 100001;
struct edge{
    int u;
    int v;
    int  w;
}e[asd*2];//使用结构体来写，双向边*2；
int n,m,k;
int head[asd],f[asd];
long long ans;
bool cmp(edge a,edge b)
{
    return a.w > b.w;
    }
int find(int x)
    {
        if(f[x]!=x)
            f[x]=find(f[x]);
        return f[x];
        }
int main(){
 //freopen("carpet.in","r",stdin);
 //freopen("carpet.out","w",stdout);    
    int fa,fb;
    cin>>n>>m>>k;
  for(int i=1;i<=m;i++)
    {
 scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    }
    sort(e+1,e+1+m,cmp);//快排；
   for(int i=1;i<=n;i++)
    f[i] = i;
   for(int i=1;i<=m;i++)
    {
        fa = find(e[i].u);
        fb=find(e[i].v);
        if(fa != fb)
            {
            f[fa]=fb;
                ans+=e[i].w;
            k--;
        }
        if(!k) break;
    }
    cout<<ans;
    return 0;
}
```

---


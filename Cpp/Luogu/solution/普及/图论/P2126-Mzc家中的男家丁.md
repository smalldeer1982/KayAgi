# Mzc家中的男家丁

## 题目背景

mzc 与 djn 的…还没有众人皆知，所以我们要来宣传一下。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁，现在 mzc 要将她们全都聚集起来（干什么就不知道了）。现在知道 mzc 与男家丁们互相之间通信的时间，请算出把他们每个人叫到需要的总时间（要重复的哦）。保证能把他们每个人叫到。

## 说明/提示

$n\leq2300,m\leq4\times10^5$


## 样例 #1

### 输入

```
5
12
0 2 15
2 3 20
3 5 13
1 3 29
0 1 30
2 4 21
0 3 23
5 1 48
0 4 17
0 5 27
1 2 43
2 5 41
```

### 输出

```
94
```

# 题解

## 作者：Hydrogen_Helium (赞：18)

从题目不难看出这是一道最小生成树的裸题，然后再看数据范围:

$n <= 2300 $      
      $m <= 400000$

首先想到Kruskal或者Prim都可以满足需要，但考虑到这两种算法中Kruskal应用更广，所以今天我们重点讲一下**Kruskal算法**。

首先回归最小生成树的定义：给定一张边带权的无向图$G = (V, E)$,$n=|V|$,由$V$中$n$个节点和$E$中$n-1$条边构成的无向连通图称为$G$的一棵生成树。边的权值之和最小的生成树被称为最小生成树。

进入今天的正题:**Kruskal算法**

Kruskal算法是基于一种贪心的思想，他总是维护无向图的最小生成森林。最初，生成森林是由零条边构成，每个节点构成一棵仅包含一个节点的树。

Kruskal算法的主体步骤，就是不断从剩余的边中选出一条权值最小，且他的两个端点在生成森林中分属于两棵不同的树，将这条边加入生成森林中。

那么，我们自然就会想到图的连通性应该如何维护呢？ 为了代码效率和简便，我们一般都采用并查集来维护。（事实上，Kruskal算法的巨大优越性也是在加入并查集优化后才得以体现的，而我们平时所说的Kruskal一般都是带并查集优化的。）

算法流程：

1.建立并查集，每个点构成一个集合。

2.将各边按权值从小到大排序，依次扫描每条边。

3.若一条边两端点在同一集合中，则忽略这条边直接跳过。

4.否则，合并他们所在的集合，将权值之和累加到答案中。

5.第四步中选中的边就构成了这张图的最小生成树。

一图胜千言：

这是一幅无向图：![](https://cdn.luogu.com.cn/upload/pic/62024.png)

将各边按权值从小到大排完序后应为：

	x      y       val
    1      2        2
    1      3        2
    1      4        3
    3      4        3
    2      3        4
然后我们开始执行Kruskal的主体流程：

枚举第一条边（1, 2, 2），将其加入生成森林中，生成森林变为：![](https://cdn.luogu.com.cn/upload/pic/62028.png)

枚举第二条边（1, 3, 2），将其加入生成森林中，生成森林变为：![](https://cdn.luogu.com.cn/upload/pic/62029.png)

枚举第三条边（3，4，3），将其加入生成森林中，生成森林变为：![](https://cdn.luogu.com.cn/upload/pic/62030.png)

你会发现，此时我们已经选出$n - 1$条边，那么这就是这张图的最小生成树，将权值累加起来即为答案，Kruskal算法结束。

Ps：这幅图比较简单，但是重在理解Kruskal的流程。

原理理解之后，代码就会变得异常简单了，注意，重点在于**一定要理解**，废话不多说，直接上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 400005

using namespace std;

int n, m, fa[maxn], tot, head[maxn], sum;

struct Edge{
	int x, y, w;
}edge[maxn];

bool cmp(Edge x,Edge y){return x.w < y.w;} //自定义比较函数

int find(int x){reutnr x == fa[x] ? x : fa[x] = find(fa[x]);}

bool judge(int x,int y){return find(x) == find(y);}

void merge(int x,int y){fa[find(x)]=find(y);}
//优雅的三行并查集
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++){
		cin >> edge[i].x >> edge[i].y >> edge[i].w;
		edge[i].x++, edge[i].y++;
	}
	sort(edge+1, edge+m+1, cmp); //权值从大到小排序
	for(int i = 1; i <= n; i++) fa[i] = i;
	for(int i = 1; i <= m; i++){
		int x = edge[i].x, y = edge[i].y;
		if (!judge(x,y)){
            sum += edge[i].w;
			merge(x,y);
		}
	}                           //当然，这部分也可以封装到函数中，看个人喜好
	cout << sum << '\n';
	return 0;
}
```


最后，本篇题解旨在帮助那些刚刚接触到最小生成树的OIer们更好的理解，若有任何问题，请私信本人。

---

## 作者：chdy (赞：4)

数据范围并不是很大 考虑克鲁斯卡尔不用prim堆优化
注意下标从0开始。
```
#include<iostream>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<cstdio>
#include<iomanip>
#include<map>
#include<queue>
#include<stack>
#include<cstring>
#include<string>
#include<vector>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m;
struct bwy
{
	int next;
	int prev;
	int v;
}s[400007];
int f[2309];
int getfather(int x)
{
	if(f[x]==x)
		return f[x];
	return f[x]=getfather(f[x]);
}
int my(bwy x,bwy y)//当然也是可以重载运算符的
{
	return x.v<y.v;
}
void merge(int x,int y)
{
	x=getfather(x);
	y=getfather(y);
	f[x]=y;
}
int num=0;
int ans=0;
int main()
{
	//freopen("1.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		x=read();y=read();z=read();
		s[i].next=x;
		s[i].prev=y;
		s[i].v=z;
	}
	sort(s+1,s+1+m,my);
	for(int i=0;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++)
	{
		int u=getfather(s[i].next);
		int p=getfather(s[i].prev);
		if(u!=p)
		{
			merge(u,p);
			ans+=s[i].v;
		}
	}
	printf("%d",ans);
	return 0;
}
```
考到的其实就是裸的最小生成树了

---

## 作者：fls233666 (赞：2)

**2020年2月16日更新：修正题解排版问题**

----------

不难看出，男家丁与 mzc 的通讯网络是一个图的结构。再根据通讯路线是双向的，我们就能得到第一个重要信息：**题目给出了一个无向图**。

接着，根据题目中要求把所有男家丁都叫到的最小总时间，可以得到第二个重要信息：**题目要求一个图的最小生成树**。

要求最小生成树，最重要的就是图一定要连通。对于图的连通性，题目中也给出了解释。**题目保证能把每个人都叫到，就保证了图的连通性。**

总结一下题意：

**给出一张连通的无向图，求出这张图的最小生成树。**

下面开始求解：

------------

求解最小生成树，有两种办法(以下用 $n$ 表示点数，用 $m$ 表示边数)：

| 方法名称 |  时间复杂度 | 
| :----------: | :----------: |
| Kruskal | $O(m \log(m))$ |
| Prim | $O(n^2)$ |

其中，Prim 还可以通过堆优化将时间复杂度优化到$O(m \log(n))$

分析此题的数据范围：$n \le 2300,m \le 400000$

显然，用无堆优化的 Prim 算法可以稳过。

Prim 的实现过程如下：

1. 初始化 $dis$ 数组，将全部点赋值为无穷大，然后选择一个点把其 $dis$ 值赋值为 $0$；
2. 选择一个没有处理过的，$dis$ 值最小的点；
3. 把这个点标记为处理过，并用这个点连出去的边更新其它未处理的点的 $dis$ 值；
4. 重复上述过程 $n$ 次后，每个点都被处理过。这时把 $dis$ 中的每个值加起来，就能得到最小生成树的边权和。

以下是代码：

```cpp
#include<iostream>
#include<cstring>
#include<vector>
#define INF 2147000000   //无穷大
using namespace std;
int main(){
    int n,m,ans=0;
    cin>>n>>m;
    vector < pair<int,int> > vb[n+1];   //边链表存边
    for(int a,b,w,i=1;i<=m;i++){
        cin>>a>>b>>w;
        vb[a].push_back(make_pair(b,w));
        vb[b].push_back(make_pair(a,w));
  		//无向边存两次
    }
  //数据读入与存储
  
    int dis[n+1];
    bool fw[n+1];   //标记每个点是否有被访问过
    for(int i=0;i<=n;i++)
    	dis[i]=INF; 
    dis[0]=0;   //dis数组初始化赋值
    memset(fw,0,sizeof(fw));    //重置标记
    for(int mn=INF,u,tg=0;tg<n;tg++,mn=INF){
        for(int j=0;j<=n;j++){
        	if(!fw[j]){
               	if(mn>dis[j]){
               		mn=dis[j];
					u=j;	 
				} 
            }
		}
  		//一个循环找到dis最小的未处理的点
  
        fw[u]=true;  //标记
        for(int lb=vb[u].size(),i=0;i<lb;i++)
            if(!fw[vb[u][i].first])    //更新未处理的点的dis值
                if(vb[u][i].second<dis[vb[u][i].first])
                    dis[vb[u][i].first]=vb[u][i].second;
    }
  //Prim运行过程
  
    for(int i=0;i<=n;i++)
    	ans+=dis[i];    //累加求和并输出
    cout<<ans; 
    return 0;
}
```


---

## 作者：TheAutumnGlory (赞：1)

## 此题一眼最小生成树裸题，跟P2121，P1547，P2820极其相似~~一模一样~~
所以不知道最小生成树的巨佬们请进：
[传送门](https://www.luogu.org/blog/YangZiWen/xue-xi-bi-ji-1-post)

$code:$
```
#include<bits/stdc++.h>裸的板子，锻炼背代码能力。。。。
using namespace std;
const int N=2305;
const int H=400005;
struct node{
	int x,y,len;重载运算符，相当于bool cmp(node a,node b){return a.len<b.len;}
	bool operator < (const node &a) const {
		return len<a.len;
	}
}a[H];
int n,m,fa[N];
并查集的getfather
int _find(int x){
	if(x!=fa[x])
		fa[x]=_find(fa[x]);
	return fa[x];
}
kruskal：贪心+并查集
void kruskal(){
	int cnt=0,tot=0,i=0;
	while(i<=m && cnt<n){
		i++;
		int x=_find(a[i].x);
		int y=_find(a[i].y);
		if(x!=y){
			fa[x]=y;
			cnt++;
			tot+=a[i].len;
		}
	}
	printf("%d",tot);
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].len);
	for(int i=1;i<=n;i++)初始化
		fa[i]=i;
	sort(a+1,a+1+m);
	kruskal();
	return 0;
}
```

---

## 作者：离人怎挽 (赞：1)

裸的一道最小生成树板子题，适合初学者练习用，因为要求重复，只需将
板子中的if(cnt==n-1) break; 去掉就行，下面是克鲁斯卡尔加并查集优化
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdio>
using namespace std;
char a[2010][2010];
int n,m,ans;
bool b[2010][2010];
int dir[][2]= {{1,0},{0,1},{-1,0},{0,-1}};
int f[400010];
int find(int x) {
	return f[x]==x?x:f[x]=find(f[x]);//并查集查询
}
struct node {
	int l,r,v;//存边
} bian[400010];
bool cmp(const node x,const node y) {
	return x.v<y.v;//重载排序，从小到大排，有些贪心思想，每次选代价最小的边加
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=m; i++)
		cin>>bian[i].l>>bian[i].r>>bian[i].v;
	for(int i=1; i<=n; i++) f[i]=i;
	sort(bian+1,bian+m+1,cmp);
	for(int i=1; i<=m; i++) {
		if(find(bian[i].l)!=find(bian[i].r))
			f[find(bian[i].l)]=find(bian[i].r),//合并加边
			                   ans+=bian[i].v;
	}
	cout<<ans;
}
```

---

## 作者：wzf2000 (赞：1)

此题为非常简单的最小生成树，附上prim标程：

```cpp
var
  n,m,i,j,k,c,d,e:longint;
  a,b:array [0..10000] of longint;
  f:array [0..2300,0..2300] of longint;
  dis:array [0..10000] of longint;
  min,sum:longint;
  used:array [0..10000] of boolean;
begin
  assign(input,'mzcanddjn.in');
  reset(input);
  assign(output,'mzcanddjn.out');
  rewrite(output);
  readln(n);
  readln(m);
  fillchar(f,sizeof(f),$7f);
  for i:=1 to m do
    begin
      readln(c,d,e);
      f[c,d]:=e;
      f[d,c]:=e;
    end;
  fillchar(dis,sizeof(dis),$7f);
  dis[0]:=0;
  sum:=0;
  for i:=0 to n do
    begin
      min:=maxlongint;
      for j:=0 to n do
        if not used[j] and (dis[j]<min) then
          begin
            k:=j;
            min:=dis[j];
          end;
      used[k]:=true;
      sum:=sum+dis[k];
      for j:=1 to n do
        if not used[j] and (f[k,j]<dis[j]) then
          dis[j]:=f[k,j];
    end;
  writeln(sum);
  close(input);
  close(output);
end.

```

---


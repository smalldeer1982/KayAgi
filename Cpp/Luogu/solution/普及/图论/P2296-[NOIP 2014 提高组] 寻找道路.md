# [NOIP 2014 提高组] 寻找道路

## 题目背景

NOIP2014 提高组 D2T2

## 题目描述

在有向图 $G$ 中，每条边的长度均为 $1$，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：

1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。
2. 在满足条件 $1$ 的情况下使路径最短。

注意：图 $G$ 中可能存在重边和自环，题目保证终点没有出边。

请你输出符合条件的路径的长度。

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/2p3mke49.png) 

如上图所示，箭头表示有向道路，圆点表示城市。起点 $1$ 与终点 $3$ 不连通，所以满足题目描述的路径不存在，故输出 $-1$。

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/tm2e1lqq.png)
如上图所示，满足条件的路径为 $1\to 3\to 4\to 5$。注意点 $2$ 不能在答案路径中，因为点 $2$ 连了一条边到点 $6$，而点 $6$ 不与终点 $5$ 连通。

**数据范围及约定**

- 对于 $30\%$ 的数据，$0<n\le10$，$0<m\le 20$。
- 对于 $60\%$ 的数据，$0<n\le100$，$0<m\le 2000$。
- 对于 $100\%$ 的数据，$0<n\le 10^4$，$0<m\le 2\times 10^5$，$0<x,y,s,t\le n,x,s\ne t$。

## 样例 #1

### 输入

```
3 2
1 2
2 1
1 3```

### 输出

```
-1```

## 样例 #2

### 输入

```
6 6
1 2
1 3
2 6
2 5  
4 5
3 4
1 5```

### 输出

```
3```

# 题解

## 作者：WsW_ (赞：3)

### 更新
- $2024.12.31$ 删除部分粗体。

---
### 思路
如果我们知道哪些点满足**出边所指向的点都直接或间接与终点连通**，那么这道题就变成了最简单的 bfs 单源最短路。  
所以我们先预处理出哪些点满足出边所指向的点都直接或间接与终点连通，再进行 bfs 单源最短路。  
想要求出哪些点满足出边所指向的点都直接或间接与终点连通，就得先求出哪些点直接或间接与终点连通。可以建反图，然后从终点开始 dfs 遍历所有和他连通的点。  
在遍历反图的过程中，遍历到一个点就删掉一个点，如果某个点的入度从因为删点变成了 $0$，就说明他满足出边所指向的点都直接或间接与终点连通。  

一共进行了 dfs 和 bfs 两次遍历，时间复杂度为 $O(n+m)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int s,t;
vector<int>edg[10003],fedg[10003];
int out[10003];
bool vis[10003],f[10003];
int dis[10003];
queue<int>q;

void col(int p){
	if(vis[p])return;
	vis[p]=1;
	for(int i=0;i<fedg[p].size();i++){
		int to=fedg[p][i];
		out[to]--;
		if(!out[to])f[to]=1;
		col(to);
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v; scanf("%d%d",&u,&v);
		edg[u].push_back(v);
		fedg[v].push_back(u);
		out[u]++;
	}
	scanf("%d%d",&s,&t);
	col(t);
	f[t]=1;
	memset(dis,0x3f,sizeof(dis));
	q.push(s);
	dis[s]=0;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=0;i<edg[x].size();i++){
			int to=edg[x][i];
			if(!f[to])continue;
			if(dis[to]>dis[x]+1){
				q.push(to);
				dis[to]=dis[x]+1;
			}
		}
	}
	if(dis[t]<=1e4)cout<<dis[t];
	else cout<<"-1";
	return 0;
}
```

---

## 作者：ethanhyz (赞：2)

# P2296 [NOIP2014 提高组] 寻找道路 题解

## 思路分析

本题的思路其实很简单。

阅读条件一，可以发现所有 **出边所指向的点不全都直接或间接与终点相连** 的点都不可能存在于路径中，即对于本题来说，这些点相当于不存在。

因此，我们只需要找到这些点，去除后 `BFS` 即可。

那如何找到这些点呢？

注意到一个关键点：**“直接或间接与终点相连”**，这可以通过以终点为起点、所有边都反向的 `BFS` 求得，能 `BFS` 到的即为**直接或间接与终点相连**，打上标记 `f`。

随后，遍历每个点，判断其**每条出边所指向的点**是否**直接或间接与终点相连**，即有没有被打上标记 `f`，如果有任意一个**出边所指向的点**没有被打上标记 `f`，则打上标记 `F`，说明该点不能被选进路径。

最后以起点为起点，正向边，再进行一次 `BFS`，注意判断标记 `F`。

总时间复杂度为 $O(n+m+n)=O(2n+m)$，对于本题数据范围完全够用。

题目比较简单，直接上代码。

## Code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,x,y,s,t,node,step[10005];
bool f[10005],F[10005];
//标记f与F含义见上，f=0表示不与终点相连，F=0表示不能被选进路径，反之亦然
vector <ll> e[10005],E[10005];
//临界表存图，e是正向边，E是反向边
queue <ll> q; //BFS队列
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&x,&y);
		e[x].push_back(y); //建正向边
		E[y].push_back(x); //建反向边
	}
	scanf("%lld%lld",&s,&t);
	//以终点为起点，反向边，BFS
	q.push(t);
	f[t]=1;
	while(!q.empty())
	{
		node=q.front();
		q.pop();
		for(int i=0;i<E[node].size();i++)
			if(!f[E[node][i]]) //E[node][i]即为边的终点
			{
				q.push(E[node][i]);
				f[E[node][i]]=1;
			}
	}
	//遍历每个点
	for(int i=1;i<=n;i++)
		if(f[i]) //如果点本身不与终点相连就没必要考虑了
		{
			F[i]=1;
			for(int j=0;j<e[i].size();j++)
				if(!f[e[i][j]]) //如果出边的终点不与终点相连
				{
					F[i]=0;
					break;
				} 
		}
	while(!q.empty()) q.pop(); //清空BFS队列，以便下一次BFS
	if(F[s]) q.push(s); //如果终点本身就不能被选进路径就不必bfs了，不会进入while，直接到最后
	//以起点为起点，正向边，BFS
	while(!q.empty()) 
	{
		node=q.front();
		q.pop();
		if(node==t) //如果bfs到了终点
		{
			printf("%lld\n",step[node]); //输出路径长度，结束
			return 0;
		}
		for(int i=0;i<e[node].size();i++)
			if(!step[e[node][i]]&&F[e[node][i]]) //该边终点没有被访问过（step默认为0，无需再开标记数组
			{
				q.push(e[node][i]);
				step[e[node][i]]=step[node]+1;
			}
	}
	puts("-1"); //无解
	return 0;
}
```

## 完结撒花～

---

## 作者：CaiZi (赞：2)

首先考虑求出可以到达终点的点，直接建反图出来，然后使用记忆化 DFS 或 BFS 求出 $t$ 点能到达的所有点，这些点即为原图可以到达 $t$ 点的点。

然后接下来我们对于每个节点，判断其能到达的点是否都可以到达终点，如果该点满足这个条件，就把这个点标记一下。然后考虑建一张新的图，对于原来一条 $u\to v$ 的边，如果 $u,v$ 均被标记，则正常加入这条边，否则无视这条边。

给新图跑 BFS 求 $s$ 点到 $t$ 点的最短路即可。

时间复杂度 $O(n+m)$。

代码展示：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s,t,w[10001],a;
vector<int>f[10001],g[10001],h[10001];
bool x[10001],y[10001];
queue<int>q;
inline void dfs(int i){
	for(int j:g[i]){
		if(!x[j]){
			x[j]=true;
			dfs(j);
		}
	}
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>s>>t;
		f[s].push_back(t);
		g[t].push_back(s);
	}
	cin>>s>>t;
	dfs(t);
	x[t]=true;
	for(int i=1;i<=n;i++){
		y[i]=true;
		for(int j:f[i]){
			if(!x[j]){
				y[i]=false;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(y[i]){
			for(int j:g[i]){
				if(y[j]){
					h[j].push_back(i);
				}
			}
		}
	}
	fill(w+1,w+n+1,-1);
	w[s]=0;
	q.push(s);
	while(!q.empty()){
		int i=q.front();
		q.pop();
		for(int j:h[i]){
			if(w[j]==-1){
				w[j]=w[i]+1;
				q.push(j);
			}
		}
	}
	cout<<w[t];
	return 0;
}
```

---

## 作者：xiaohuang (赞：2)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/22/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8F%E6%B4%9B%E8%B0%B7P2296%20%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF/)

### Solution

我们先看一个例子：

不妨令起点为$1$，终点为$3$。

![](https://s2.ax1x.com/2019/08/22/mdORPg.png)

这个例子的答案是$3$，路径是$1 \to 4 \to 5 \to 3$。

我们可以先检验出每一个点是否能到终点。可以从终点出发，按照反向边走一遍，然后把走不到的点以及它的入边连的点都删除，像这样：

![](https://s2.ax1x.com/2019/08/22/mdzHC8.png)

最后在跑一边$bfs$序，求出最短路就可以了。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>

using namespace std;

const int MAXN = 200005;
struct EDGE {
    int to, nxt;
} edge1[MAXN], edge2[MAXN];
int n, m, u, v, S, T, cnt1, cnt2, dis[MAXN], head1[MAXN], head2[MAXN];
bool vis[MAXN];
inline void addedge(int u, int v) {//邻接表存图
    edge1[++cnt1].to = v; edge1[cnt1].nxt = head1[u]; head1[u] = cnt1;
    edge2[++cnt2].to = u; edge2[cnt2].nxt = head2[v]; head2[v] = cnt2;//反向边
}
inline void bfs1(int cur) {
    queue<int> Q;
    Q.push(cur);
    vis[cur] = 1;
    while (!Q.empty()) {
        int u = Q.front();
        Q.pop();
        for (int i = head2[u]; ~i; i = edge2[i].nxt) {//遍历每一个点
            int v = edge2[i].to;
            if (!vis[v]) {
                vis[v] = 1;
                Q.push(v);
            }
        }
    }
}
inline bool check(int u) {//判断是否能到达终点
    for (int i = head1[u]; ~i; i = edge1[i].nxt)
        if (!vis[edge1[i].to]) return 0;
    return 1;
}
inline bool bfs2(int cur) {
    queue<int> Q;
    Q.push(cur);
    while (!Q.empty()) {
        int u = Q.front();
        Q.pop();
        if (!check(u)) continue;
        for (int i = head1[u]; ~i; i = edge1[i].nxt) {//遍历每一个点
            int v = edge1[i].to;
            if (dis[v] == -1) {
                dis[v] = dis[u] + 1;
                Q.push(v);
                if (v == T) {
                    printf("%d\n", dis[T] + 1);
                    return 1;
                }
            }
        }
    }
    return 0;
}
int main() {
    scanf("%d%d", &n, &m);
    memset(head1, -1, sizeof(head1));
    memset(head2, -1, sizeof(head2));
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        addedge(u, v);//加边
    }
    scanf("%d%d", &S, &T);
    bfs1(T);//求出终点能到的点
    memset(dis, -1, sizeof(dis));
    if (!bfs2(S)) printf("-1\n");
    return 0;
}
```

---

## 作者：1124828077ccj (赞：2)

首先把路线全倒过来，从终点往起点走一遍，把不行的点标起来，然后再从起点往终点做一个 bfs，求最短的路线，就行了

```cpp

#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<vector>
using namespace std;
int x,y,s,t,n,m,h[10002],f[10002],tr;
vector<int>a[10002],b[10002];
void dfs(int u){
    if (h[u])return;
    f[u]=1;h[u]=1;
    for (int i=0;i<b[u].size();i++)
    dfs(b[u][i]);
}
void bfs(int u){
    int g[10002],ans[10002],l=0,fl[10002],xx;
    memset(fl,0,sizeof(fl));memset(ans,0,sizeof(ans));
    for (int i=0;i<a[u].size();i++)
    if (!fl[a[u][i]] && f[a[u][i]])
    {ans[l]=1;g[l++]=a[u][i];fl[a[u][i]]=1;}
    for (int i=0;i<l;i++)
    {
        if (g[i]==t){tr=1;printf("%d",ans[i]);break;}
        xx=g[i];
        for (int j=0;j<a[xx].size();j++)
        if (!fl[a[xx][j]] && f[a[xx][j]])
        {ans[l]=ans[i]+1;g[l++]=a[xx][j];fl[a[xx][j]]=1;}
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=0;i<m;i++)
    {
        scanf("%d%d",&x,&y);
        a[x].push_back(y);b[y].push_back(x);
    }
    scanf("%d%d",&s,&t);
    dfs(t);
    memset(h,0,sizeof(h));
    for (int i=1;i<=n;i++)
    {
        if (!f[i])continue;
        for (int j=0;j<a[i].size();j++)
        if (!f[a[i][j]]){h[i]=1;break;}
    }
    for (int i=1;i<=n;i++)
    if (h[i])f[i]=0;
    if (f[s])bfs(s);
    if (!tr)printf("-1");
    return 0;
}

```

---

## 作者：HHC883 (赞：1)

# 题目分析
如果没有“路径上的所有点的出边所指向的点都直接或间接与终点连通”这个条件，直接 BFS 即可。而加上了这个条件，其实也不难。我们只要把所有存在一条出边所指向的点**不**直接或间接与终点连通的点删掉，在剩下的图上跑 BFS 即可。如何判断一个点是否存在一条出边所指向的点不直接或间接与终点连通呢？要判断连通性，让我们想到了 DFS。但是如果从每个点出发都跑一遍 DFS，必然超时。而我们需要从每个点出发都跑一遍 DFS，是因为 DFS 的起点不同。可是终点是相同的啊！于是，我们可以建反图，并以原图终点作为 DFS 的起点，找出所有与终点连通的点，从而判断哪些点要被删掉。最后在原图上跑 BFS 即可。

注意判断起点是否被删去，否则可能会被 hack。

时间复杂度为 $O(n+m)$。
# 参考代码
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int n,m,s,t,es1[(int)2e5+5],nxt1[(int)2e5+5],head1[(int)1e4+5],cnt1,es2[(int)2e5+5],nxt2[(int)2e5+5],head2[(int)1e4+5],cnt2,dis[(int)1e4+5];
bool arr[(int)1e4+5],vis[(int)1e4+5];
queue<int> q;
void link1(int u,int v){
	es1[++cnt1]=v;
	nxt1[cnt1]=head1[u];
	head1[u]=cnt1;
}
void link2(int u,int v){
	es2[++cnt2]=v;
	nxt2[cnt2]=head2[u];
	head2[u]=cnt2;
}
void dfs(int now){
	arr[now]=true;
	for(int i=head2[now];i;i=nxt2[i]) if(!arr[es2[i]]) dfs(es2[i]);
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	int x,y;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		link1(x,y),link2(y,x);
	}
	cin>>s>>t;
	dfs(t);
	for(int i=1;i<=n;i++){
		for(int j=head1[i];j;j=nxt1[j]){
			if(!arr[es1[j]]) vis[i]=true;
		}
	}
	memset(dis,0x3f,sizeof dis);
	q.push(s);
	dis[s]=0;
	if(vis[s]){
		cout<<-1;
		return 0;
	}
	vis[s]=true;
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=head1[now];i;i=nxt1[i]){
			if(!vis[es1[i]]){
				vis[es1[i]]=true;
				dis[es1[i]]=dis[now]+1;
				q.push(es1[i]);
			}
		}
	}
	if(dis[t]>1e9) cout<<-1;
	else cout<<dis[t];
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

建反图和最短路。

核心思想，删去不满足题意的边，跑最短路。

建反图，搜一遍 $t$ 所在联通块，记录哪些点可行。

在正图上遍历每个点，若某个点的所有临点都在 $t$ 所在联通块，说明这个点满足题目中的条件一，即可以出现在最终路径上。

在原图上遍历每条边，若一个边的两个点都符合条件一，则加入新图。

建完新图跑一遍最短路即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, s, t, dis[10005];
bool vis[10005], can[10005]={0, 1};
vector<int> g[10005], e[10005], h[10005];
void dfs (int u) {
	vis[u]=1;
	for (int i:g[u])
		if (!vis[i])
			dfs(i);
}
queue<int> q;
int main () {
	cin >> n >> m;
	for (int u, v; m--; )
		cin >> u >> v,
		e[u].push_back(v),
		g[v].push_back(u);
	cin >> s >> t;
	dfs(t);
	for (int i=1; i<=n; can[++i]=1) 
		for (int j:e[i])
			can[i]=min(can[i], vis[j]);
	for (int i=1; i<=n; ++i)
		for (int j:e[i]) 
			if(can[i]&&can[j]) 
				h[i].push_back(j);
	memset(dis, -1, sizeof dis);
	q.push(s);
	dis[s]=0;
	for (int u=q.front(); q.size(); q.pop(), u=q.front())
		for (int i:h[u])
			if (dis[i]==-1)
				dis[i]=dis[u]+1,
				q.push(i);
	cout << dis[t];
	return 0;
} 
```

---

## 作者：zhangzirui66 (赞：1)

条件第一步，要能到达 $t$ 点，建反图跑一遍。记录哪些点可行。

第二步，扫描每个点，若其旁边均为标记过的，说明点的出边所指向的点都直接或间接与终点连通。记录这个点第二次

第三步，在原边枚举每条边，若两个节点均被记录了第二次，加入一个新图，否则扔掉。

对新图进行 BFS 即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, s, t, vis[10005], can[10005], dis[10005];
vector<int> g[10005], f[10005], h[10005];
void dfs(int u){
    vis[u] = 1;
    for(int i = 0; i < g[u].size(); i ++){
        if(!vis[g[u][i]]){
            dfs(g[u][i]);
        }
    }
}
queue<int> q;
int main(){
    cin >> n >> m;
    for(int i = 1; i <= m; i ++){
        int u, v; cin >> u >> v;
        f[u].push_back(v); g[v].push_back(u);
    }
    cin >> s >> t;
    dfs(t);
    for(int i = 1; i <= n; i ++){
        can[i] = 1;
        for(int j = 0; j < f[i].size(); j ++){
            can[i] = min(can[i], vis[f[i][j]]);
        }
    }
    for(int i = 1; i <= n; i ++){
        for(int j = 0; j < g[i].size(); j ++){
            if(can[i] && can[g[i][j]]) h[g[i][j]].push_back(i);
        }
    }
    for(int i = 1; i <= n; i ++) dis[i] = -1;
    q.push(s); dis[s] = 0;
    while(q.size()){
        int now = q.front(); q.pop();
        for(int i = 0; i < h[now].size(); i ++){
            if(dis[h[now][i]] == -1){
                dis[h[now][i]] = dis[now] + 1;
                q.push(h[now][i]);
            }
        }
    }
    cout << dis[t];
    return 0;
}
```

---

## 作者：glass_goldfish (赞：1)

直接爆搜一遍点 $s$ 所在的连通块，如果点 $t$ 不在连通块中，说明无解。如果有解，那么寻找在这个连通块中的点并标记。然后扫一遍边，如果两个端点都在连通块中，那么这条边可以使用。最后把所有可以使用的边放在一起，求最短路即可。代码实现比较容易，不放了。

---

## 作者：sherry_lover (赞：1)

# P2296 [NOIP2014 提高组] 寻找道路 题解

[题目传送门](https://www.luogu.com.cn/problem/P2296)

## 思路

考虑先找到所有满足“出边所指向的点都直接或间接与终点连通”这个条件的点。然后求 $s$ 到 $t$ 只经过这些点的最短路即可。

那怎么找到这些点呢？从 $k$ 开始 bfs，每遍历到一个点打上标记，最后遍历每个点的出边判断是否可行即可。

时间复杂度 $O(n+m)$。


Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,s,t;
vector<int> a[10005],b[10005];
bool flag[10005],vis[10005];
void bfs(int k);
void init(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++)
	{
		cin >> x >> y;
		a[x].push_back(y);
		b[y].push_back(x);
	}
	cin >> s >> t;
	bfs(t);
	return;
}
void bfs(int k){
	queue<int> q;
	flag[k] = 1;
	q.push(k);
	while(!q.empty()){
		int u = q.front();
		q.pop();
		for(int i = 0;i < b[u].size();i++){
			if(flag[b[u][i]] == 0)
			{
				q.push(b[u][i]);
				flag[b[u][i]] = 1;
			}
		} 
	}
}
bool pd(int s)
{
	if(flag[s])
	{
		for(int i = 0;i < a[s].size();i++)
		{
			if(!flag[a[s][i]]) return false;
		}
		return true;
	}
	return false;
}
int search(int s,int t)
{
	queue<int> q;
	bool vis[10005];
	int step[10005];
	memset(vis,0,sizeof(vis));
	memset(step,-1,sizeof(step));
	vis[s] = 1;
	step[s] = 0;
	q.push(s);
	if(!pd(s)) return -1;
	while(!q.empty()){
		int u = q.front();
		q.pop();
		for(int i = 0;i < a[u].size();i++){
			if(vis[a[u][i]] == 0 && pd(a[u][i]))
			{
				q.push(a[u][i]);
				vis[a[u][i]] = 1;
				step[a[u][i]] = step[u]+1;
			}
		} 
	}
	return step[t];
}
int main(){
	init();
	cout << search(s,t);
	return 0;
}
```

---

## 作者：zzwdsj (赞：1)

### 思路
既然要求路径最短，就求最短路，权为 $1$ 的最短路可以使用 BFS 求解。现在还要求路径上所有点的出边连到的点都能到达终点。我们可以在反图上从终点开始跑 BFS，搜索到的节点都能到达终点。最后在求解时只让可以到达终点的节点扩展即可。 
### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s,t,x,y;
vector<int> mp[2][200001];
bool flag[3][200001];
struct node{int x,d;};
int dfs(int st,int nd,int v)
{
	queue<node>q;
	flag[v][st]=1;
	q.push({st,0});
	while(!q.empty())
	{
		auto h=q.front();
		q.pop();
		for(int i:mp[v][h.x])if(!flag[v+1][i])goto exit;
		for(int i:mp[v][h.x])
			if(!flag[v][i]&&flag[v+1][i])
			{
				flag[v][i]=1;
				if(i==nd)return h.d+1;
				q.push({i,h.d+1});
			}
		exit:;
	}
	return -1;
} 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(flag[2],1,sizeof flag[2]);
	cin>>n>>m;
	for(int i=1;i<=m;i++)cin>>x>>y,mp[0][x].push_back(y),mp[1][y].push_back(x);
	cin>>s>>t;
	dfs(t,0,1);
	cout<<dfs(s,t,0);
	return 0;
}
```

---


# 小岛

## 题目背景

西伯利亚北部的寒地，坐落着由 $N$ 个小岛组成的岛屿群，我们把这些小岛依次编号为 $1$ 到 $N$。


## 题目描述

起初，岛屿之间没有任何的航线。后来随着交通的发展，逐渐出现了一些连通两座小岛的航线。例如增加一条在 $u$ 号小岛与 $v$ 号小岛之间的航线，这条航线的用时为 $e$。那么沿着这条航线，$u$ 号小岛上的人可以前往 $v$ 号小岛，同样的 $v$ 号小岛上的人也可以前往 $u$ 号小岛，其中沿着这一条航线花费的时间为 $e$。

同时，随着旅游业的发展，越来越多的人前来游玩。那么两个小岛之间的最短路径是多少便成为了饱受关注的话题。


## 说明/提示

对于 $20\%$ 的数据，$N\le 5$ 且 $M\le 30$。

对于 $40\%$ 的数据，$N\le 20$ 且 $M\le 200$。

对于 $60\%$ 的数据，$N\le 80$ 且 $M\le 500$。

对于 $80\%$ 的数据，$N\le 100$ 且 $M\le 2500$。

对于 $100\%$ 的数据，$N\le 100$ 且 $M\le 5000$。


## 样例 #1

### 输入

```
3 8 
1 3 1 10 
0 2 3 
1 2 3 20 
1 1 2 5 
0 3 2 
1 1 3 7 
1 2 1 9 
0 2 3```

### 输出

```
-1
15
12```

## 样例 #2

### 输入

```
5 16
1 1 2 343750
1 1 3 3343
1 1 4 347392
1 1 5 5497
1 2 3 123394
1 2 4 545492
1 2 5 458
1 3 4 343983
1 3 5 843468
1 4 5 15934
0 2 1
0 4 1
0 3 2
0 4 2
0 4 3
0 5 3```

### 输出

```
5955
21431
9298
16392
24774
8840```

# 题解

## 作者：公主殿下MIKU (赞：15)

裸的最短路模板，数据范围小，完全可以直接在每次询问的时候跑一遍最短路就行，如果担心时间的话，可以用堆优化的dijkstra,完全可以过，堆可以手打，但作为stl党，
我们可是有黑科技的。优先队列相当于一个大根堆，你可以使用stl的pair使他成为小根堆，也可以通过运算符装载将其重载为小根堆。
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
struct node{//小根堆重载
    int now,x;//now代表点的位置，x代表距离
    bool operator <(const node &tmp) const
    {
        return x>=tmp.x;
    }
}cur;
int head[110],to[10010],nxt[10010],v[10010],num,dis[10010],e,n,m,x,y,k;
bool vis[110];
const int inf=2147483647; 
void add(int x,int y,int z)//前向星建图，因为是双向边，所以存两条边
{
    to[++num]=y;
    v[num]=z;
    nxt[num]=head[x];
    head[x]=num;
    to[++num]=x;
    v[num]=z;
    nxt[num]=head[y];
    head[y]=num;
}
void dij(int s)
{
    priority_queue<node>q;
    fill(dis+1,dis+n+1,inf);//初始化，一定要初始化，不然它会与上次查询有冲突。
    fill(vis+1,vis+n+1,0);
    dis[s]=0;
    q.push((node){
        s,dis[s]
    });
    while(!q.empty())
    {
        cur=q.top();
        q.pop();
        if(vis[cur.now]) continue;
        vis[cur.now]=1;
        for(int i=head[cur.now];i;i=nxt[i])
        {
            if(dis[to[i]]>dis[cur.now]+v[i])//路径压缩
            {
                dis[to[i]]=dis[cur.now]+v[i];
                q.push((node){
                    to[i],dis[to[i]]
                });
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&k);
        if(k==0)
        {
            scanf("%d%d",&x,&y);
            dij(x);//遍历最短路
            printf("%d\n",dis[y]==inf?-1:dis[y]);
        }
        else 
        {
            scanf("%d%d%d",&x,&y,&e);
            add(x,y,e);//加边
        }
    }
    return 0;
}	
```
管理大大求过。

---

## 作者：追风少年σχ (赞：9)

# GR 苹果叶（AHOI初中组命题者&&钻石教练）正版授权
### 本题正解Floyed（但是和前几位写的Floyed思路不同）

考虑一次修改边的操作，将受到这条边影响的点枚举出来。（这条边相当于枚举中的K）。
有以下修改最短路的方式：

### f[i][j]=f[i][s]+f[s][d]+f[d][j];
###### （其中f[s][d]表示刚刚读入的进行修改的边）


对每次读入最新修改的边枚举i,j更新最短路这样做m次就完了。（简不简单？）





贴上正解标程：



```cpp
#include<cstdio>
const int inf=199999990;
int n,m,f[101][101];
int main(){
	int a,s,d,e;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i!=j)f[i][j]=inf;
		}
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&a,&s,&d);
		if(a==0){
			if(f[s][d]!=inf)printf("%d\n",f[s][d]);
			else printf("-1\n");
		}
		else{
			scanf("%d",&e);
			if(e<f[d][s]){
			    f[d][s]=f[s][d]=e;
			    for(int k=1;k<=n;k++){
			    	for(int l=1;l<=n;l++){
			    		if(f[k][s]+f[s][d]+f[d][l]<f[k][l])
						    f[k][l]=f[l][k]=f[k][s]+f[s][d]+f[d][l];//核心语句更新f[k][l]的最短路 
					}
				}
		    }
		}
	}
	return 0;
}
//复杂度O((n^2)*m) 
```
最慢的52ms就过了，还是比较高效简便的

---

## 作者：sukimo (赞：4)

这道题也算是floyd算法的一个经典变形：增边多源最短路。除了传统的两点间距离外，还会动态地加边。如果每加一条边都要跑一整遍floyd的话，时间复杂度明显难以接受。所以考虑优化。回忆floyd算法的原理，每次都以一个点作为中转点来更新，那么对于每一次增边，只会涉及到两个点，可以先判断是否需要floyd修改（比如没加此边前的两点最短路已经小于边的长度，那么明显加了也没什么用，可忽略），如果需要，就只以它俩为中转点进行更新，这样就优多了。floyd算法的衍生功能实际上是很多的，建议把它的精髓搞懂。

上代码：

```
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;int n,dis[105][105];
void floyd(int x,int y){
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)dis[i][j]=min(dis[i][j],dis[i][x]+dis[x][j]);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)dis[i][j]=min(dis[i][j],dis[i][y]+dis[y][j]);    
}
int main(){
	int m;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)if(i-j)dis[i][j]=INF;
	for(int i=1;i<=m;i++){
		int type,a,b;scanf("%d%d%d",&type,&a,&b);
		if(!type)printf("%d\n",dis[a][b]==INF?-1:dis[a][b]);
		else{
			int q_edge;scanf("%d",&q_edge);
			if(dis[a][b]>q_edge){dis[a][b]=dis[b][a]=q_edge;floyd(a,b);}
		}
	}
	return 0;
}
```


---

## 作者：Chen_Py (赞：4)

~~写一个效率差一点但运行起来效果不错的方法吧~~

还记得[P1119 灾后重建](https://www.luogu.org/problemnew/show/P1119)中，每次增加中间点，然后询问全源最短路。那道题应该用$Floyd$算法的来搞。

$Floyd$算法中，$dist[k][i][j]$ 的含义是以 $i,j$ 为起点和终点，路径上的中间点编号**不超过** $k$ 的最短距离。

这道题的思想**类似 $Floyd$ 算法**，只不过 $Floyd$ 每次枚举中间点松弛路径，我们枚举中间边来松弛路径

对于每一次增加的边 $(a->b,c)$ ，枚举任意两个点 $i,j$ ，考虑到新增边后，路径方案必须满足：

$dist[i][j]<=min(dist[i][a]+dist[b][j]+c,dist[i][b]+dist[a][j]+c)$

就可以用这个松弛来搞啦~

注意这里新增的边是双向边，所以必须按两个方向进行松弛

效率 $O(n^2m)$ 看起来好像没有$Dijkstra$~~暴力~~算法的 $O(mnlogn+m^2)$ 好，但是这种算法的常数比较小，写起来也好写，而且对于这道题的数据 $(n<=100,m<=5000)$ ，这种方法跑起来还是比较快的。

但是吧，这种算法的正确性我还没找到好的证明方法，如果各位大佬有证明或者有反例请联系笔者

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int myp[107][107];//就是map...
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i==j)myp[i][j]=0;
            else myp[i][j]=1e9;
        }
    }
    int op,a,b,c;
    while(m--)
    {
        cin>>op;
        if(op==0)
        {
            cin>>a>>b;
            if(myp[a][b]>=1e9)cout<<-1<<endl;
            else cout<<myp[a][b]<<endl;
        }
        else
        {
            cin>>a>>b>>c;
            myp[a][b]=min(c,myp[a][b]);
            myp[b][a]=min(c,myp[b][a]);
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<=n;j++)
                {
                    myp[i][j]=min(myp[i][j],myp[i][a]+myp[a][b]+myp[b][j]);
                    myp[i][j]=min(myp[i][j],myp[i][b]+myp[b][a]+myp[a][j]);
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：2)

这里提供Dijkstra+Heap

裸最短路

每次询问的时候跑一遍

```cpp
#include<queue>
#include<cstdio>
#define reg register
using namespace std;
const int N=101,M=5001,INF=2147483647;
inline void read(reg int &x)
{
    reg int out=0;reg char ch=getchar();
    while (ch<48||ch>57)ch=getchar();
    while (ch>47&&ch<58)
        out=out*10+ch-48,ch=getchar();
    x=out;
}
int num,n,m,head[N];
struct edge{int to,w,next;}e[2*M];  //定义邻接表
inline void add(reg int a,reg int b,reg int c)  //建边
{
    e[++num].next=head[a];
    head[a]=num;
    e[num].to=b;
    e[num].w=c;
}
struct heap    //堆优化
{
    int id,dis;
    bool operator<(const heap &hh)const
    {
        return dis>hh.dis;
    }
};
inline int dijkstra(int a,int b)
{
    reg int d[N],f[N];
    for (reg int i=1;i<=n;i++)d[i]=INF,f[i]=0;d[a]=0;  //初始化
    priority_queue<heap>q;q.push((heap){a,0});
    while (q.size())
    {
        reg int p=q.top().id;q.pop();
        if (f[p])continue;f[p]=1;
        for (reg int i=head[p];i;i=e[i].next)
        {
            reg int v=e[i].to;
            if (d[p]+e[i].w<d[v])
                d[v]=d[p]+e[i].w,
                q.push((heap){v,d[v]});
        }
    }
    return d[b]==INF?-1:d[b];  //如果最短路不存在就是-1
}
int main()
{
    read(n);read(m);
    while (m--)
    {
        reg bool flag;scanf("%d",&flag);
        reg int a,b;read(a);read(b);
        if (flag) //建边操作
        {
            reg int c;read(c);
            add(a,b,c),add(b,a,c);
        }
        else  //询问操作
            printf("%d\n",dijkstra(a,b));
    }
    return 0;
}
```

---

## 作者：向金牌冲刺 (赞：2)

用spfa暴力求最短路，不要忘记更新两点之间的最短边

```cpp
#include<iostream>//long long不能做数组下标 
#include<cstdio>
#include<cstring>
using namespace std;
int n,m;
int u,v,d;
int s,e;//起点 终点 
int pd;
int exist[1000];//记录是否入队 
int team[10000001];//队列 
int dis[1001];//最短路 
int g[101][101];//邻接矩阵存图 
int head,tail;
int spfa()
{
    memset(dis,0x7f,sizeof(dis));
    dis[s]=0;
    memset(exist,false,sizeof(exist));
    team[1]=s;
    head=0;
    tail=1;
    exist[s]=true;//以上为spfa初始化 
    do
    {
        ++head;
        u=team[head];
        exist[u]=false;//取出一个点 
        for(v=1;v<=n;++v)
        {
            if(dis[v]>dis[u]+g[u][v])
            {
                dis[v]=dis[u]+g[u][v];//松弛操作，更新 
                if(!exist[v])
                {
                    ++tail;
                    team[tail]=v;
                    exist[v]=true;//如果被更新的点没在队列里就入队 
                } 
            }
        }
    }while(head<tail);
}
int main()
{
    cin>>n>>m;
    memset(g,0x7f,sizeof(g));//邻接矩阵初始化 
    for(int i=1;i<=m;++i)
    {
        cin>>pd;
        if(pd==1)
        {
            cin>>u>>v>>d;
            if(d<g[u][v])
            {
                g[u][v]=g[v][u]=d;//更新边的信息 
            }
        }
        else
        {
            cin>>s>>e;
            spfa();//求s到e的最短路 
            if(dis[e]>10000000) cout<<-1<<endl;//如果s到e的距离太大则不存在路 
            else cout<<dis[e]<<endl;
        }
    }
    return 0;
}
```

---

## 作者：迷残云 (赞：1)

首先，我不知道这题目为何会被放到主题库里毕竟最短路的题在题库里已经不少了，第二，这道题的题面非常裸，一眼就看出来是道最短路，不像去年的$ pj $最后一题[加工零件](https://www.luogu.com.cn/problem/P5663)，反正我是没看出来是最短路径。

好，进入正题：

这道题其实四大金刚：

$floyd $ $dijkstra$ $bellman-ford $ 和 $spfa$都能过。

由于笔者**最近**不怎么打堆优化的$ dij $，只打~~已经死了的~~$ spfa $，于是这篇题解以 $spfa $为主线。

如果大家不了解 $ spfa $的就可以看这篇日报，特别的详细，作者也是非常精心：[最短路径](https://www.luogu.com.cn/blog/wym483739/xue-tu-lun-ni-zhen-di-liao-xie-zui-duan-lu-ma-post)

还是简单的介绍一下 $ spfa $吧：

$ spfa $，最短路径算法，是$bellman-ford $ 的队列实现，时间复杂度 $ O(VE)$,$ V $为点数,$ E $为边数（感谢管理员提醒）（有时会被卡，具体参照$ noi 2018$T1）

主要思想：

初始把起点加入队列，每次从队列中取出一个元素，并对所有与它相邻的点进行修改，若某个点修改成功，则将其入队，直到队列为空时算法结束。

具体还是看上面那篇博客吧，至于负环什么的应该都有。

这道题就是对每一个询问跑一次 $ spfa $,肯定不会被卡（~~floyd都过了~~） ，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2010;
const int M=6010;
const int INF = 0x3f3f3f3f;
struct ed{
	int next,to,dis;
}
edge[M];
int dist[M];
bool visit[M];
int in[M];
int n, m;
int cnt;
int head[M];
void addedge(int u,int v,int w)
{
	edge[++cnt].next=head[u];
	edge[cnt].to=v;
	edge[cnt].dis=w;
	head[u]=cnt;
}
void spfa(int start)
{
	queue<int> Q;
	int i, now;
	memset(visit, false, sizeof(visit));
	for (i = 1; i <= n; i++)
		dist[i] = INF;
	dist[start] = 0;
	Q.push(start);
	visit[start]= true;
	while (!Q.empty())
	{
		now = Q.front();
		Q.pop();
		visit[now] = false;

		for (i = head[now]; i; i=edge[i].next)
		{
			if (dist[edge[i].to] > dist[now] + edge[i].dis)
			{
				dist[edge[i].to] = dist[now] + edge[i].dis;
				if (visit[edge[i].to] == 0)
				{
					Q.push(edge[i].to);
	                visit[edge[i].to] = true;
				}
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
			for(int i=1;i<=m;i++)
			{
				int a,b,c,v;
			scanf("%d%d%d",&a,&b,&c);
			if(a==0){
			spfa(b);
			if(dist[c]!=INF)printf("%d\n",dist[c]);
			else printf("-1\n");
		}
			else if(a==1)
			{
				scanf("%d",&v);
			addedge(b,c,v);
			addedge(c,b,v);
		}
	}
	return 0;
}
```


---

## 作者：zhangyuhan (赞：1)

还没有裸的$dijkstra$?我来写一篇吧。

其实由于数据太水，连裸$dijkstra$的$O(n^2m)$，我也是醉了。。

稍微讲一下思路吧（~~有啥好讲的~~)

对于$0$的操作，直接跑$dijkstra$，如果$d[t]=INF$的话，要输出$-1$。

对于$1$的操作，直接建边，但有重边的可能，记得判断哪个更小。

$AC$ $Code$

```cpp
#include <iostream>
#define INF 1e8
using namespace std;

int n,m;

long long d[1010],G[1010][1010];

bool used[1010];

void init(){
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			G[i][j]=INF;
}//初始化要记得

void dijkstra(int s){
	fill(d,d+1+n,INF);//记得初始化
	fill(used,used+1+n,false);//记得初始化
	d[s]=0;
	while(true){
		int v=-1;
		for(int u=1;u<=n;u++)
			if(!used[u]&&(v==-1||d[u]<d[v]))
				v=u;
		if(v==-1)
			break;
		used[v]=true;
		for(int u=1;u<=n;u++)
			if(d[v]+G[v][u]<d[u]&&G[v][u]!=INF)
				d[u]=d[v]+G[v][u];
	}
}//dijkstra

int main(){
	cin>>n>>m;
	init();//别忘调用
	for(int i=1;i<=m;i++){
		int u,v,c;
		int k;
		cin>>k;
		if(k==0){
			cin>>u>>v;
			dijkstra(u);
			if(d[v]==INF)
				cout<<-1<<endl;//记得特判
			else
				cout<<d[v]<<endl;
		}//对于0的操作
		else{
			cin>>u>>v>>c;
			if(c<G[u][v]){
				G[u][v]=G[v][u]=c;
			}//记得判断重边
		}//对于1的操作
	}
	return 0;
}
```


---

## 作者：agicy (赞：1)

享受最佳阅读体验请进入[传送门](https://lu-anlai.github.io/2019/02/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P2683%E3%80%91-%E5%B0%8F%E5%B2%9B/)。

## 原题

题面请查看[洛谷 P2683 小岛](https://www.luogu.org/problemnew/show/P2683)。

## 题解

$\text{Dijkstra}$

### 思路

每一次查询都进行一遍$\text{Dijkstra}$求单源最短路径。

#### 算法的优化

1. `fread();`读入优化，大约可节省$100\text{ms}$的时间；
2. 存图应使用**链式前向星**；
3. 使用堆（或者`std::priority_queue`）优化；

经过优化后，算法的时间复杂度为$\text{O}(mnlog_{2}n+m^{2})$。

### 代码

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using std::less;
using std::priority_queue;
using std::vector;     //头文件和引用
#define INF 0X3F3F3F3F //定义正无穷
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)
static char buf[100000], *p1 = buf, *p2 = buf; //fread();读入优化

inline int read(void)
{
    register char ch = getchar();
    register int sum = 0;
    while (!(ch >= '0' && ch <= '9'))
        ch = getchar();
    while (ch >= '0' && ch <= '9')
        sum = sum * 10 + ch - 48, ch = getchar();
    return sum;
}

struct Node
{
    int ID, dis;
    bool operator<(const Node &a) const
    {
        return dis > a.dis;
    }
};

bool vis[101];
int cnt, head[101], to[10001], w[10001], Next[10001];
int dis[101];
priority_queue<Node, vector<Node>, less<Node>> Q; //优先队列

void Add_Edge(int, int, int);
void Dijkstra(int);

int main(void)
{
    register int m, op, s, t, u, v, e; //register变量更快些
    read();                            //n在本题中没有用，也无超过n的毒瘤数据，无需读入
    m = read();                        //读入m
    while (m--)
    {
        op = read();
        if (op == 0)
        {
            s = read(), t = read();
            Dijkstra(s);
            printf("%d\n", (dis[t] == INF) ? (-1) : (dis[t]));
        }
        if (op == 1)
        {
            u = read(), v = read(), e = read();
            Add_Edge(u, v, e);
            Add_Edge(v, u, e); //双向边
        }
    }
    return 0;
}

void Add_Edge(int f, int t, int val) //链式前向星存图
{
    Next[++cnt] = head[f];
    to[cnt] = t;
    w[cnt] = val;
    head[f] = cnt;
    return;
}

void Dijkstra(int s)
{
    register int i, ID, To;
    Node temp;
    memset(vis, false, sizeof(vis));
    memset(dis, 0X3F, sizeof(dis));
    dis[s] = 0; //每次运行前要记得初始化
    temp.ID = s, temp.dis = 0;
    Q.push(temp);
    while (!Q.empty())
    {
        temp = Q.top();
        Q.pop();
        ID = temp.ID;
        if (vis[ID])
            continue;
        vis[ID] = true;
        for (i = head[ID]; i; i = Next[i])
        {
            To = to[i];
            if (dis[To] > dis[ID] + w[i])
            {
                dis[To] = dis[ID] + w[i]; //松弛操作
                temp.ID = To, temp.dis = dis[To];
                Q.push(temp);
            }
        }
    }
    return; //返回
}
```

### 我的评测记录

- [洛谷 R16112574](https://www.luogu.org/recordnew/show/16112574)。


---

## 作者：TechZ (赞：0)

动态的去更新当前的得距离即可，因为每次加边后只会对跟这条边有关系得路径发生改变，而不是去每一次跑一边dij这样可以过是因为数据太水，而且内存占用要多于正解  
那么我们怎样去更新floyd呢，原本的Floyd是三重循环分别枚举中间节点，起点，终点，那么已知只改变某一条路得长度，则去掉第一重循环也就是将k确定下来只需要枚举所有起点与终点以这条边为中间边得情况即可.
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;
const int N=105;
const int M=5005;
struct node
{
    int s;
    int to;
    int e;
};
node G[N][N];//声明
int n,m;
int main()
{   
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        G[i][j].e=0xf3f3f3f;//初始化
        if(i==j)
        G[i][j].e=0;
    }
    for(int i=1;i<=m;i++)
    {    int u,v;
        int p;
        scanf("%d%d%d",&p,&u,&v);
        if(p==1)
        {
           
            int w;
            scanf("%d",&w);
            if(G[u][v].e>w)//如果比原来得小才值得去改变
            {   
        
            G[u][v].e=w;
            G[v][u].e=w;
        for(int k=1;k<=n;k++)
        for(int l=1;l<=n;l++)
        {
            if(G[k][l].e>=G[k][u].e+G[u][v].e+G[v][l].e)
            {
                G[k][l].e=G[l][k].e=G[k][u].e+G[u][v].e+G[v][l].e;//更新
            }
        }
    }
            
        }
        if(p==0)
        {   
            
            printf("%d\n",G[u][v].e>=0xf3f3f3f?-1:G[u][v].e);//输出
        }
    }
    return 0;
}
```


---

## 作者：Elma_ (赞：0)

## Description
[题目](https://www.luogu.com.cn/problem/P2683)

## Solution
一眼题啊，很裸的最短路板子题。

- 对于操作0，从$s$点跑一遍单源最短路，如果$t$的$dis$不为$inf$（$inf$为$dis$初始值）就输出
- 对于操作1，注意题目说的是双向航线，即**无向边**，存两次即可。

最短路照道理是写$dij$比较稳定，~~因为SPFA已经死了~~，但是本蒻写了$SPFA$居然也能过。

据说还有巨佬用$Floyed$过去，~~可能数据水~~，本蒻先膜拜为敬Orz

## Code
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#define maxm 5005
#define inf 233333333
using namespace std;

struct node
{
	int next, to, dis;
}edge[maxm];

int n, m, cnt;
int dis[maxm], head[maxm];
bool vis[maxm];

void addedge(int u, int v, int w)
{
	edge[++cnt].next = head[u];
	edge[cnt].to = v;
	edge[cnt].dis = w;
	head[u] = cnt;
}//标准前向星存边

void spfa(int s)
{
	queue<int> q;
    memset(vis, false, sizeof(vis));
    for(int i=1;i<=n;i++)
    	dis[i] = inf;
    
    dis[s] = 0;
    vis[s] = true;
    q.push(s);
    
    while (!q.empty())
    {
        int u = q.front();
        vis[u] = false;
        q.pop();

        for(int i=head[u];i;i=edge[i].next)
        {
            if(dis[edge[i].to]>dis[u]+edge[i].dis)
            {
                dis[edge[i].to]=dis[u]+edge[i].dis;
                if(!vis[edge[i].to])
                {
                    q.push(edge[i].to);
                    vis[edge[i].to] = true;
                }
            }
        }
    }
}//标准SPFA

void work()
{
	scanf("%d%d", &n, &m);
	
	for(int i=1;i<=m;i++)
	{
		int f;
		scanf("%d", &f);
		
		if(f == 0)
		{
			int s, t;
			scanf("%d%d", &s, &t);
			spfa(s);//跑最短路
			
			if(dis[t] != inf)
				printf("%d\n", dis[t]);
			else
				printf("-1\n");
		}
		else 
		{
			int u, v, w;
			scanf("%d%d%d", &u, &v, &w);
			addedge(u, v, w);
			addedge(v, u, w);//双向存边
		}
	}
}

int main(void)
{
	work();
	return 0;
}
```


---

## 作者：TheAutumnGlory (赞：0)

最短路模板题，如果对最短路不是很熟悉的同学请移步：
[传送门](https://www.luogu.org/blog/156001/zui-duan-lu)

## 进入正题

此题与其他题不同的是，每新增条边，就必须存储，然后等1操作到达时跑最短路，于是我们有dijkstra和SPFA两种跑最短路的方法：

其次，如何处理无法到达呢。只需要if(dis[]==inf)就行了。

因为我们dis一开始初始化为inf，如果在接下来的跑最短路中没有被更新（也就是dis==inf），说明由当前起点是到不了这个点的。

### dinjkstra:

dijkstra的核心就在于它的算法步骤：
```
算法步骤:
1. 找离起点x最近的未讨论过的点k。
2. 判断经过k点，起点x到其他点的距离是否缩短，如缩短
则更新。将k点标记为已讨论。
3. 重复进行第1步，直到所有点都被讨论过为止。

```
所以dijkstra的实质是贪心，但是在上述步骤1中，我们可以使用强大的stl中的优先队列来快速查找。

所以dijkstra的时间复杂度为$O(nlog_n)$

$code$:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10005;
const ll inf=1e15;
struct node{    重载运算符，将dis关键字从小到大排序
	int num;
	ll dis;
	bool operator < (const node &a) const{
		return dis>a.dis;
	}
};
int n,m;
ll dis[N];
bool mark[N];
int Last[N],End[N],len[N],Next[N],tot;
void cb(int x,int y,int z){
	End[++tot]=y;
	len[tot]=z;
	Next[tot]=Last[x];
	Last[x]=tot;
}
void dijkstra(int s){
	for(int i=1;i<=n;i++){
		dis[i]=inf;
		mark[i]=false;
	}
	dis[s]=0;
	//mark[s]=true;
	priority_queue<node> q;	   以dis作为关键字的小根堆
	q.push((node){s,0});
	while(q.size()){
		int u=q.top().num;     取出距离起点最近的点
		q.pop();
		if(mark[u])
			continue;
		mark[u]=true;
		for(int i=Last[u];i;i=Next[i]){   链式前向星
			int v=End[i];
			if(!mark[v] && dis[v]>dis[u]+len[i]){  更新最短距离
				dis[v]=dis[u]+len[i];
				q.push((node){v,dis[v]});
			}
		}
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		int opt,x,y,z;
		scanf("%d",&opt);
		if(opt){   opt==1 记录边
			scanf("%d %d %d",&x,&y,&z);
			cb(x,y,z);
			cb(y,x,z);
		}
		else{
			scanf("%d %d",&x,&y);
			dijkstra(x);     跑最短路
			if(dis[y]!=inf)   判断是否可以到达
				printf("%lld\n",dis[y]);
			else
				puts("-1");
		}
	}
	return 0;
}
```

### SPFA(bellman-ford)


算法流程:

用一个队列来进行维护。初始时将起点加入队列。

每次从队列中取出一个元素，并对他所连接的点进行松弛，若某个点松弛成功（则通过那个点到起点距离缩短），则将其入队。直到队列为空

简单的说就是队列优化的bellman-ford，利用了每个点不会更新次数太多的特点

SPFA的时间复杂度是O(kE)，k一般取2左右（k是增长很快的 函数ackermann的反函数,2^65536次方也就5以下 ），可以处理负边。

$code$:(其实跟dijkstra差不多）
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10005;
const ll inf=1e15;
int n,m;
ll dis[N];
bool mark[N];
int Last[N],End[N],len[N],Next[N],tot;
void cb(int x,int y,int z){
	End[++tot]=y;
	len[tot]=z;
	Next[tot]=Last[x];
	Last[x]=tot;
}
void spfa(int s){
	for(int i=1;i<=n;i++){
		dis[i]=inf;
		mark[i]=false;
	}
	dis[s]=0;
	mark[s]=true;
	queue<int> q;
	q.push(s);
	while(q.size()){
		int u=q.front();
		q.pop();
		mark[u]=false;
		for(int i=Last[u];i;i=Next[i]){
			int v=End[i];
			if(dis[v]>dis[u]+len[i]){
				dis[v]=dis[u]+len[i];
				if(!mark[v]){
					q.push(v);
					mark[v]=true;
				}
			}
		}
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		int opt,x,y,z;
		scanf("%d",&opt);
		if(opt){
			scanf("%d %d %d",&x,&y,&z);
			cb(x,y,z);
			cb(y,x,z);
		}
		else{
			scanf("%d %d",&x,&y);
			spfa(x);
			if(dis[y]!=inf)
				printf("%lld\n",dis[y]);
			else
				puts("-1");
		}
	}
	return 0;
}
```

### SPFA判断负环可以看文章上方传送门

#### 其实这道题还能用floyd

是不是很惊讶，floyd的时间复杂度$O(N^3M)$怎么可能过的了！！？


但是我们可以边记录边进行更新，这样这道题的时间复杂度就是$O(N^2M)$了！！！

题解区里有大佬讲的很清楚了，这里我就不细讲了。。。


### 总结：
这道题其实还是一道很不错的题，可以为巩固最短路来用！

---

## 作者：Swing_YL (赞：0)

n<=100 Floyed即可
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
#define LL long long
#define dou 0
#define mod 10000
inline void read(LL &x){
    LL f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x=x*f;
}
inline void write(LL x){
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
LL n,m;
bool flag;
LL dis[1020][1020];
int main(){
    // #ifndef hammer
    // freopen("a.in","r",stdin);
    // freopen("a.out","w",stdout);
    // #endif
    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//cin cout优化
    scanf("%lld%lld",&n,&m);
    for(LL i=1;i<=n;i++)
        for(LL j=1;j<=n;j++)
            dis[i][j]=2147483647;
    for(LL i=1;i<=m;i++){
        LL x,y,z,opr;
        scanf("%lld",&opr);
        if(opr==0){
            scanf("%lld%lld",&x,&y);
            if(flag==1){
            //判断之前是否建过边，在查询时判断比在加边后更新减少很多复杂度
                if(dis[x][y]!=2147483647)
                    printf("%lld\n",dis[x][y]);
                else printf("-1\n");
            }
            else{
                for(LL k=1;k<=n;k++)
                    for(LL i=1;i<=n;i++)
                        for(LL j=1;j<=n;j++)
                            if(dis[i][j]>dis[i][k]+dis[k][j])
                                dis[i][j]=dis[i][k]+dis[k][j];
                if(dis[x][y]!=2147483647)
                    printf("%lld\n",dis[x][y]);
                else printf("-1\n");
                flag=1;
                //标记为已经更新过，如果之后不再加边而只是查询，直接输出即可
            }
        }
        else if(opr==1){
            flag=0;
            scanf("%lld%lld%lld",&x,&y,&z);
            dis[y][x]=min(dis[y][x],z);//会有重边，不加这个只有25分
            dis[x][y]=min(dis[x][y],z);
        }
    }
    fclose(stdin);
    fclose(stdout);
    return dou;
}
```
 
~~我知道O(n*n*n)不如O(nlogn)   
蒟蒻的题解 轻点喷~~

---

## 作者：我没有小白 (赞：0)

裸的最短路，最短路只会spfa输入根据题目要求模拟一边，最后查询的时候在跑一边最短路，输出就可以了

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int>q;
struct edge
{
	int next,to,dist;
} e[500007];
int head[500007],tot;
inline void add(int x,int y,int z)
{
	e[++tot].next=head[x];
	e[tot].to=y;
	e[tot].dist=z;
	head[x]=tot;
}
int n,m;
int f,g,w;
int vis[500007],dis[500010];
void spfa(int s)
{
	while(!q.empty())q.pop();
	for(int i=1; i<=n; i++)dis[i]=2147483647;
	dis[s]=0;
	q.push(s);
	vis[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u],v; v=e[i].to,i; i=e[i].next)
			if(e[i].dist+dis[u]<dis[v])
			{
				dis[v]=dis[u]+e[i].dist;
				if(!vis[v])
					vis[v]=1,q.push(v);
			}
	}
}//从这往上是裸的spfa板子，每次打spfa都要打以上步骤，就不多讲了 
int main()
{
	cin>>n>>m;
	for(int i=1; i<=m; i++)
	{
		int o;//这个o是用来判断输入或者查询的 
		cin>>o;
		if(o)
		{
			cin>>f>>g>>w;
			add(f,g,w);
			add(g,f,w);
		}//因为说这无向边，所以双边 
		if(!o)
		{
			cin>>f>>g;
			spfa(f);
			if(dis[g]==2147483647)
				cout<<-1<<endl;
			else cout<<dis[g]<<endl;//对于每个询问，输出一个值 
		}
	}
}
```
管理大大求过，小妹谢谢咯

---

## 作者：WanderingTrader (赞：0)

这道题的数据其实并不强，大概是想让大家试试Floyd吧。不过虽然是多源多汇，我们也可以将其转换为SSSP问题，由于没有负权边，使用Dijkstra解决较为简单。  
如果没有学过Dijkstra,可以看看本人的这篇博客  [传送门](https://www.luogu.com.cn/blog/Steven371/xue-xi-bi-ji-dijkstra)。  
#### 题意简述
题目已经说得很明白了，求最短路。  
#### 题目分析
按照正常方法存储边，然后每次询问以$s$为起点做一次Dijkstra即可。
#### 代码
先把框架写好：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define INF 1e12
#define ll long long
ll d[N];
int num;
bool done[N];
struct edge { int u,v,w; } x;
vector <edge> edges;
vector <ll> G[N];
struct node
{
	ll d;
	int u;
	bool operator < (const node& x) const
	{ 
		return d > x.d;
	} 
} t;
void insert(int x,int y,int e);
void Dijkstra(int n,int s);
int main(){
	int n,m,u,v,w,k;
	scanf("%d%d",&n,&m);
	for(ll i = 0;i < m;i ++){
		scanf("%d%d%d",&k,&u,&v);
		if(!k)
		{
			Dijkstra(n,u);
			printf("%lld\n",d[v] == INF ? -1 : d[v]);
		}
		else
		{
			scanf("%d",&w);
			insert(u,v,w);
		}
	}
	return 0;
}
```
现在我们开始写$insert$函数  
其实并不难，只是要注意题中给的是双向边：
```cpp
void insert(int x,int y,int e)
{
	edges.push_back({x,y,e});
	edges.push_back({y,x,e});
	G[x].push_back(num); 
	++ num;
	G[y].push_back(num);
	++ num;	
}
```
本人这里采用的是 **边编号+点对边** 存储方法，可能不那么容易理解，不过仔细分析每条语句的目的就能明白它的用意。  

$Dijkstra$函数就很好写了，直接上模板：
```cpp
void Dijkstra(int n,int s)
{
	int size;
	priority_queue <node> pq;
	fill(d + 1,d + n + 1,INF);
	fill(done,done + n + 1,0);
	d[s] = 0;
	pq.push({0,s});
	while(!pq.empty())
	{
		t = pq.top();
		pq.pop();
		if(done[t.u]) continue;
		done[t.u] = 1;
		size = G[t.u].size();
		for(int i = 0;i < size;i ++)
		{
			x = edges[G[t.u][i]];
			if(d[x.v] > d[t.u] + x.w)
			{
				d[x.v] = d[t.u] + x.w;
				pq.push({d[x.v],x.v});
			}
		}
	}
}
```
这里需要注意的就是由于查找有多次，每次查找都要对数组初始化，而且尽量将边数、起点作为一个参数传入，使其封装成一个独立的函数，使用起来更方便。

全部代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define INF 1e12
#define ll long long
ll d[N];
int num;
bool done[N];
struct edge { int u,v,w; } x;
vector <edge> edges;
vector <ll> G[N];
struct node
{
	ll d;
	int u;
	bool operator < (const node& x) const
	{ 
		return d > x.d;
	} 
} t;
void insert(int x,int y,int e)
{
	edges.push_back({x,y,e});
	edges.push_back({y,x,e});
	G[x].push_back(num); 
	++ num;
	G[y].push_back(num);
	++ num;	
}
void Dijkstra(int n,int s)
{
	int size;
	priority_queue <node> pq;
	fill(d + 1,d + n + 1,INF);
	fill(done,done + n + 1,0);
	d[s] = 0;
	pq.push({0,s});
	while(!pq.empty())
	{
		t = pq.top();
		pq.pop();
		if(done[t.u]) continue;
		done[t.u] = 1;
		size = G[t.u].size();
		for(int i = 0;i < size;i ++)
		{
			x = edges[G[t.u][i]];
			if(d[x.v] > d[t.u] + x.w)
			{
				d[x.v] = d[t.u] + x.w;
				pq.push({d[x.v],x.v});
			}
		}
	}
}
int main(){
	int n,m,u,v,w,k;
	scanf("%d%d",&n,&m);
	for(ll i = 0;i < m;i ++){
		scanf("%d%d%d",&k,&u,&v);
		if(!k)
		{
			Dijkstra(n,u);
			printf("%lld\n",d[v] == INF ? -1 : d[v]);
		}
		else
		{
			scanf("%d",&w);
			insert(u,v,w);
		}
	}
	return 0;
}
```

最后分析一下复杂度，循环$O(m)$，Dijkstra+堆优化$O(n\ log\ n)$，总共$O(m\times n\ log\ n)$，最大约为$3.5\times10^6$，远小于时间限制。(实测结果：所有数据点用时之和为$2.52s$）。  
$\mathrm{The\ end.}$

---

## 作者：Aehnuwx (赞：0)

看完题解后，发现：

为啥都是 $ \rm Dijkstra, SPFA $ 啥的，而我却写了个 $ \text  {O(理论上过不去)} $ 的 $ \rm Floyd $ 啊...

卡了一波常才 A 掉...

首先，我的思路和[这篇题解](https://www.luogu.org/blog/wyl020527/solution-p2683)是一样的。

但是，这位大佬的代码总用时是 $ 5.63s $，但是我的代码的总用时却~~只有~~ $ 4.31s $。原因就是我对于几个小地方进行了优化。

优化0: $ \rm O2,O3,Ofast! $

结果：Fail.

优化1: $ \rm IO $ 优化来一波!

结果：Fail.

优化2: 修改输出优化对于输出 $ -1 $ 时的做法！

结果：Fail.

优化3: $ \rm register $ 大法好！

结果：Fail.

优化4: 将`while(m--)`变成`for(;m;--m)`，强行优化常数!

结果：Fail.

优化5: 在跑 $ \rm Floyd $ 时，如果 $ \rm dis[k][i]=INF $，直接 $ \rm continue! $

结果：Fail.

> 说句实话，我卡到这里的时候真的很想弃疗了

但是，所谓最狠的优化在最后，

优化6: 增加一个标记，避免重复跑 $ \rm Floyd! $

解释：定义一个我命名为 $ \rm flag $ 的 $ \rm bool $ 变量，初始值为 $ \rm true $。如果读入的 $ \rm opt=0 $，直接判断 $ \rm flag $ 是否为真。若为真，直接输出题目中 $ s $ 到 $ t $ 的距离。否则才跑 $ \rm Floyd $。若 $ \rm opt=1 $，则输出距离，然后 $ \rm flag=false $。

结果：卡过去啦！最慢的一个点也~~只~~有 $ 786ms $，还是不错啊。

> 其实这个优化在上文中讲到的那篇题解中也是有的

讲完了。

$ \rm code $

```cpp
# pragma GCC optimize(2)
# pragma GCC optimize(3)
# pragma GCC optimize("Ofast")
// 优化0
# include <bits/stdc++.h>
const int maxN = 105;
const int INF = 0x3f3f3f3f;
# define min(a, b) (a) < (b) ? (a) : (b)
int n, m, dis[maxN][maxN];
int read();
void write(int);
int main() {
	n = read(), m = read();
	memset(dis, INF, sizeof dis);
	bool flag = true;
	for(; m; --m) { // 优化4
		int opt = read(), u = read(), v = read();
		if(opt == 0) {
			if(flag) write(dis[u][v] == INF ? -1 : dis[u][v]), puts(""); // 优化6
			else {
				for(register int k = 1; k <= n; ++k)
					for(register int i = 1; i <= n; ++i) {
						if(dis[k][i] == INF) continue; // 优化5
						for(register int j = 1; j <= n; ++j) // 优化3
							dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
				}
				flag = true, write(dis[u][v] == INF ? -1 : dis[u][v]), puts(""); 
			}
		} else {
			int e = read();
			dis[u][v] = dis[v][u] = min(e, dis[u][v]), flag = false;
		}
	} 
	return 0;
}
int read() {
	int x = 0;
	char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x;
}
void write(int x) {
	if(x < 0) { std::cout << -1; return; } // 优化2
	if(x > 9) write(x / 10);
	putchar(x % 10 + 48);
}
// 优化1
```

大概除了代码打了一千多字的样子，~~管理员大佬求过啊~~。

---


# 【模板】负环

## 题目描述

给定一个 $n$ 个点的有向图，请求出图中是否存在**从顶点 $1$ 出发能到达**的负环。

负环的定义是：一条边权之和为负数的回路。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 2 \times 10^3$，$1 \leq m \leq 3 \times 10^3$。
- $1 \leq u, v \leq n$，$-10^4 \leq w \leq 10^4$。
- $1 \leq T \leq 10$。

#### 提示

请注意，$m$ **不是**图的边数。

## 样例 #1

### 输入

```
2
3 4
1 2 2
1 3 4
2 3 1
3 1 -3
3 3
1 2 3
2 3 4
3 1 -8
```

### 输出

```
NO
YES
```

# 题解

## 作者：Singercoder (赞：142)

不详细解释了，需要的可以看看别的题解。

主要思路就是用spfa判断入队次数是否>=n，如果是则说明有负环，这一点可以由spfa的松弛算法原理推导来。

注意一定要判**入队次数**而不是松弛次数，我看几乎现有每一篇题解判的都是松弛次数，可以试试这个[hack](https://www.luogu.com.cn/discuss/show/202226)。

hack原理很简单：如果存在重边导致了多次松弛，那么对松弛次数的判断就会产生影响。解决方式就是判**入队次数**，虽然略慢，但是更稳。

---

update[2020.7.26]：在写差分约束的时候想用spfa判无解，然后经过一系列的思考就有了下面这组新的hack数据：

```
input:
1
4 6
1 2 -3
1 3 -2
1 4 -1
2 3 -6
2 4 -5
3 4 -4
output:
NO
```

![](https://cdn.luogu.com.cn/upload/image_hosting/b9ryg21s.png)


注意这组hack只对用**链式前向星**（而非vector）存边且判的是**松弛次数**（而非入队次数）的有效，而且该数据无重边无自环，比discuss里面的那个数据更有说服力。

首先hack原理就是对n号节点进行n-1轮松弛，每轮都有x($x \in [1,n-1]$）次松弛，这样就能产生n^2级别的松弛次数。

但是判入队次数就hack不掉了，每轮的第一次松弛会让n节点入队，但n节点只有在下一轮才会出队；因此本轮的其余所有松弛全部无法导致入队。

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 0x3f3f3f3f
using namespace std;
const int MAXN=2010;
const int MAXM=3010;
int n,m;

int en=-1,eh[MAXN];
struct edge
{
	int u,v,w,next;
	edge(int U=0,int V=0,int W=0,int N=0):u(U),v(V),w(W),next(N){}
};edge e[MAXM<<1];
inline void add_edge(int u,int v,int w)
{
	e[++en]=edge(u,v,w,eh[u]);eh[u]=en;
}
void input()
{
	scanf("%d %d",&n,&m);
	en=-1;
	memset(eh,-1,sizeof(eh));
	int u,v,w;
	for(int i=1;i<=m;++i)
	{
		scanf("%d %d %d",&u,&v,&w);
		add_edge(u,v,w);
		if(w>=0)add_edge(v,u,w);
	}
}

int dis[MAXN],cnt[MAXN];
bool vis[MAXN];
queue<int> q;
void spfa()
{
	fill(dis+1,dis+n+1,inf);
	memset(cnt,0,sizeof(cnt));
	memset(vis,0,sizeof(vis));
	
	while(!q.empty())q.pop();
	dis[1]=0;vis[1]=1;q.push(1);
	
	int u,v,w;
	while(!q.empty())
	{
		u=q.front();vis[u]=0;q.pop();
		for(int i=eh[u];i!=-1;i=e[i].next)
		{
			v=e[i].v;w=e[i].w;
			if(dis[u]+w<dis[v])
			{
				dis[v]=dis[u]+w;
				if(!vis[v])
				{
					if(++cnt[v]>=n)//注意就是这个位置的判断。一定要保证在判vis之后，即判入队次数；而不是在判vis之前，即判松弛次数！！！
					{
						printf("YES\n");return;
					}
					vis[v]=1;q.push(v);
				}
			}
		}
	}
	printf("NO\n");
}

int main()
{
//	freopen("in.txt","r",stdin);
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;++i)
	{
		input();
		spfa();
	}
	return 0;
}
```

---

update[2020.7.28]：感谢AK新手村dalao提供的判最短路径边数的思路

在[fyy2603提供的hack](https://www.luogu.com.cn/discuss/show/168472)中，提到了极限数据可能爆int的问题，其原因在于要让入队次数达到上界n，则遍历边的总个数最大可达$n^2$。

考虑换一种思路，我们知道如果没有负环，从1号点到每个点的最短路径应当是不存在环的；而如果存在环那它只可能是负环，且最短路径长度会在算法过程中无限增大。

因此我们可以判断1号点到i号点的最短路径长度是否<n（即经过的点数<=n，没有任何一个点被重复经过），来更高效地判断是否存在负环。

而这也就完美避免了极限数据爆int的问题。（~~直接开ll不香吗~~）

```cpp
//其他部分没有区别
void spfa()
{
	fill(dis+1,dis+n+1,inf);
	memset(cnt,0,sizeof(cnt));
	memset(vis,0,sizeof(vis));
	
	while(!q.empty())q.pop();
	dis[1]=0;vis[1]=1;q.push(1);
	
	int u,v,w;
	while(!q.empty())
	{
		u=q.front();vis[u]=0;q.pop();
		for(int i=eh[u];i!=-1;i=e[i].next)
		{
			v=e[i].v;w=e[i].w;
			if(dis[u]+w<dis[v])
			{
				dis[v]=dis[u]+w;
				cnt[v]=cnt[u]+1;//记录最短路径的边数 
				if(cnt[v]>=n)//最短路径边数>=n，即存在被重复遍历的点，也就是存在负环
				{
					printf("YES\n");
					return;
				}
				if(!vis[v])
				{
					vis[v]=1;q.push(v);
				}
			}
		}
	}
	printf("NO\n");
}
```



---

## 作者：iMya_nlgau (赞：67)

### 判断负环

若图中存在一个环，环上各边的边权和为负数，则称该环为**负环**。

含有负环的图显然是没有最短路的，因为每走一次这个负环，总权值就会更小，导致陷在环里出不来。

我们可以用 Bellman-Ford 或 SPFA 来判断负环。

#### Bellman-Ford 判断负环

Bellman-Ford 算法通过不断迭代计算最短路，每轮迭代至少有一个结点得到了最短路。所以，若图中没有负环，则最多经过 $n-1$ 轮迭代后算法结束。**若第 $n$ 轮迭代仍有结点的最短路能被更新，则图中有负环**。复杂度为   $O(nm)$。

#### SPFA 判断负环

SPFA 是队列优化的 Bellman-Ford，所以我们可以类比 Bellman-Ford 判断负环。然而 SPFA 使用队列，无法直接得知在进行第几轮迭代。再观察 Bellman-Ford，我们发现第 $i$ 轮迭代实际是在计算最短路包含 $i$ 条边的结点。所以我们**用 $cnt[x]$ 表示 $1$ 到 $x$ 的最短路包含的边数**，$cnt[1]=0$。每次用 $dis[x]+w(x,y)$ 更新 $dis[y]$ 时，也用 $cnt[x]+1$ 更新 $cnt[y]$。此过程中**若出现 $cnt[y]\ge n$，则图中有负环**。最坏情况复杂度也是 $O(nm)$。

也可以用另一种方式理解：$1$ 到 $x$ 的最短路上的边数一定不多于 $n-1$。否则至少有一个结点被重复经过，这说明存在环，且经过该环能更新该结点的 $dis$ 值，即存在负环。

SPFA 也可以通过记录每个点的入队次数判断负环，若有节点入队次数 $\ge n$，则有负环。这种方式效率会略低。可以参考其他题解。

下面的代码中，利用了 SPFA 记录最短路经过边数的方法判负环。

```cpp
#include<cstdio>
#include<cstring>
const int maxn=2e3+10;
const int maxm=6e3+10;
int n,m;
struct Edge{
	int to,w,next;
}edge[maxm];        //链式前向星存图
int head[maxn],tot;
inline void Init(){     //有多组测试数据，每次初始化
	for(int i=0;i<maxm;i++) edge[i].next=0;
	for(int i=0;i<maxn;i++) head[i]=0;
	tot=0;
}
inline void addedge(int u,int v,int w){
	edge[++tot].to=v;
	edge[tot].w=w;
	edge[tot].next=head[u];
	head[u]=tot;
}
#include<queue>
using std::queue;
queue<int> Q;
int dis[maxn],vis[maxn],cnt[maxn];
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(cnt,0,sizeof(cnt));
	dis[1]=0; vis[1]=true;
	Q.push(1);
	while(!Q.empty()){
		int x=Q.front();
		Q.pop();
		vis[x]=false;
		for(int i=head[x];i;i=edge[i].next){
			int y=edge[i].to,z=edge[i].w;
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;  //更新最短路
				cnt[y]=cnt[x]+1;  //更新包含边数
				if(cnt[y]>=n) return true;  //判定存在负环
				if(!vis[y]){
					Q.push(y);
					vis[y]=true;
				}
			}
		}
	}
	return false;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		Init();
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++){
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			addedge(u,v,w);
			if(w>=0) addedge(v,u,w);
		}
		puts(spfa()?"YES":"NO");
	}
	return 0;
}
```

---

## 作者：fzj2007 (赞：58)

这模板题怎么没人发题解啊。。

## 第一步 读题

#### 题干：

>给定一个 $n$ 个点的有向图，请求出图中是否存在**从顶点 $1$ 出发能到达**的负环。

>负环的定义是：一条边权之和为负数的回路。

这个没什么可说的吧。。重要的地方题目也加粗了，这是从顶点 $1$ 出发能到达的负环。那么**从顶点 $1$ 出发不能到达的负环就不算负环。**

------------

#### 输入输出：

>输入的第一行是一个整数 $T$，表示测试数据的组数。对于每组数据的格式如下：

>第一行有两个整数，分别表示图的点数 $n$ 和接下来给出边信息的条数 $m$。

>接下来 $m$ 行，每行三个整数 $u$,$v$,$w$。

> - 若 $w \geq 0$，则表示存在一条从 $u$ 至 $v$ 边权为 $w$ 的边，还存在一条从 $v$ 至 $u$ 边权为 $w$ 的边。
> - 若 $w\lt0$，则只表示存在一条从 $u$ 至 $v$ 边权为 $w$ 的边。

也没有什么特别的，和我们打的模板差不多。下面我来扯句题外话：（仅属于猜测，不要就这个问答做文章。）

>$Q:$为什么建 $1$ 条边还是 $2$ 条边与 $w$ 有关？

>$A:$因为当 $w \lt 0$ 时建 $2$ 条边会直接出现负环。

## 第二步 思路

很明显，这个题是最短路的模板题（变形的）。由于出现了负环，所以 $Floyed$ （废话，时间复杂度都不行）与 $Dijkstra$ 都是无法处理的负环的。那么我们这里推出两个算法： $Bellman-Ford$ 以及它的升级版 $SPFA$。接下来我们以 $SPFA$ 作为重点讲解。

### Bellman-ford

由于篇幅限制，这个算法如果想详细了解可以来[这里](https://baike.baidu.com/item/Bellman-Ford%E7%AE%97%E6%B3%95/1089090?fromtitle=bellman-ford&fromid=6039406&fr=aladdin)学习。（当然看完 $SPFA$ 的讲解也就基本能理解了）

### SPFA

先推荐一个讲的比较好的[博文](https://blog.csdn.net/qq_41593380/article/details/81025079)。

这个算法作为我们的重点来讲解。$SPFA$，全称叫做 Shortest Path Faster Algorithm（就是取了首字母防止太长）。这个算法可以处理负边权、负环的情况。

我们先口胡一下这个算法的基础思路：

我们我们使用一个数组 $dis$ 来记录每个节点的最短路径的值（当然过程中为当前最优解，并非最终最优解，也就是 $dis$ 数组是在不断更新优化的），然后我们用邻接表来存储图。我们采取动态逼近法：设立一个先进先出的队列用来保存没有优化的结点，优化方式为每次取出队首结点 $u$，然后用 $u$ 的当前最优值对离开 $u$ 点所指向的结点 $v$ 进行松弛操作，如果 $v$ 点的目前最优值有调整，且 $v$ 不在当前的队列中，就将 $v$ 点放入队尾。这样不断进行松弛操作，直到队列为空为止。最后 $dis$ 数组存储的就是答案。

当然这个思路是需要求最终的答案的，我们本题不需要求出最终的答案，但是我们也需要一次一次更新最优解同时获取结点松弛的次数。

我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，一般的方法就是求一个点的进队次数。如果一个点的进队次数超过 $n$ 即出现负环。

## 第三步 代码

上面口胡了那么多，终于到代码部分了。。（**警告：快读较长，建议跳过**）

```
#include<bits/stdc++.h>//万能头233
using namespace std; 
using std::cin;
using std::cout;
using std::endl;
namespace IN{//快读
    const int MAX_INPUT = 1000000;
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,MAX_INPUT),p1==p2)?EOF:*p1++)
    char buf[MAX_INPUT],*p1,*p2;
    template<typename T>inline bool read(T &x) {
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
        	ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {
       return read(a)&&read(args...);
    }
    #undef getc
}

namespace OUT{//快写
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
    	for(register int i=0;i<s.length();i++) putc(s[i]);
	}
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);put(ch,args...);
    }
}
using IN::read;
using OUT::put;
using OUT::putc;
using OUT::putstr;
//定义一串
#define maxn 3005
#define inf 0xffffff
struct edge{//存储图，邻接表
	int v,w,nxt;
}e[maxn<<1];
int head[maxn],n,m,T,qnum[maxn],dis[maxn],cnt; 
bool vis[maxn];
queue<int> q;
inline void add(int u,int v,int w){//建图，不会可以bfs一下
	e[++cnt]=(edge){v,w,head[u]},head[u]=cnt;
}
inline void buildedge(){//读入的第二部分，读入这个图
	for(int i=1,x,y,z;i<=m;i++){
		read(x,y,z);//读入
		if(z>=0) add(x,y,z),add(y,x,z);//别忘了建双向图
		else add(x,y,z);//否则单向图
	} 
}
inline bool spfa(int s){//spfa定义为bool类型，如果负环返回0
	while(!q.empty()) q.pop();//清空队列（其实没必要）
	q.push(s);//先加入结点，然后记录
	vis[s]=1,qnum[s]++,dis[s]=0;
	while(!q.empty()){//如果队列非空
		int u=q.front();//取出队首元素
		q.pop(),vis[u]=0;//操作一下
		for(int i=head[u];i;i=e[i].nxt){//一个一个地进行访问
			int v=e[i].v;//求出指向
			if(dis[v]>dis[u]+e[i].w){//如果不是最优
				dis[v]=dis[u]+e[i].w;//更新
				if(!vis[v]){//如果不在队列里
					vis[v]=1;//入队操作
					q.push(v);
					qnum[v]++;
					if(qnum[v]>n) return 0;//返回0
				}
			}
		}
	}
	return 1;//别忘了返回1啊
}
int main(int argc, char const *argv[]){
    std::ios::sync_with_stdio(false);//关闭同步流
    cin.tie(NULL);
    cout.tie(NULL);
    read(T);//读入
    while(T--){//T次
    	read(n,m);//读入n,m
    	cnt=0;//初始化一波
    	memset(head,0,sizeof(head));
    	memset(qnum,0,sizeof(qnum));
    	for(int i=1;i<=n;i++) dis[i]=inf;//先弄成inf
    	memset(vis,0,sizeof(vis));
    	buildedge();//建图
    	if(!spfa(1)) putstr("YES\n");//如果有负环输出YES
    	else putstr("NO\n");//否则输出NO
	}
    return 0;//下次见233
}
```

### 第四步 其他

- 撰文不易，大佬勿喷！
- 文章若有`bug`请私信作者，感激不尽！
- 如果有帮助，请帮忙点下赞，感谢！


---

## 作者：AzzyZhe (赞：35)

## 题解 P3385 负环
$\rightarrow$[题目传送门](https://www.luogu.com.cn/problem/P3385)

我来写篇总结附带求出具体负环的吧。

### 题解：判断负环
----
既然判断负环的几种方法其他题解都已经提到过，那我就姑且只大概做个总结吧。

1. Floyd 算法求负环，时间复杂度 $\mathcal O (n^3)$：

可以考虑建立原图的反向图记录 $1$ 向每个点的最短路径的更新来源再从点 $1$ 开始 dfs 看是否能进入环中。

此外因为 Floyd 的结果中负环上的点到自身距离小于 $0$，所以可以同时传下闭包（Floyd 一遍以后再从 $1$ 开始 dfs 一遍判断可达点到自身的距离是否有小于 $0$ 的也可）。

本题中由于时间复杂度太高而不能通过。

代码（自身距离+闭包）：
```cpp
int dis[MAXN][MAXN];
bool vis[MAXN][MAXN];
bool Floyd(int s)
{
	vis[s][s]=1;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				vis[i][j]|=vis[i][k]&&vis[k][j];
				if(dis[i][j]>dis[i][k]+dis[k][j])
					dis[i][j]=dis[i][k]+dis[k][j];
			}
	for(int i=1;i<=n;i++)
		if(vis[s][i]&&dis[i][i]<0)
			return 1;//存在负环
	return 0;
}
```
```cpp
//读入&初始化
memset(dis,0x3f,sizeof(dis));//不能0x7f
memset(vis,0,sizeof(vis));
cin>>n>>m;
for(int i=1;i<=n;i++)
	dis[i][i]=0,
	vis[i][i]=0;
for(int i=0,u,v,w;i<m;i++)
{
	cin>>u>>v>>w;
	dis[u][v]=min(dis[u][v],w);
	vis[u][v]=1;
	if(w>=0)
		vis[v][u]=1,
		dis[v][u]=min(dis[v][u],w);
}
```

2. SPFA 算法求负环，时间复杂度 $\mathcal O (kn)$：

没有负环的图中一个最多被其他 $n-1$ 个点松弛 $n-1$ 次，如果一个点被从 $1$ 出发的 SPFA 松弛了 $n$ 次及以上，则存在由 $1$ 可达的负环。

需要注意的一点是（如果有人之前学的 SPFA 像我学的一样），不同于求最短路时，这里如果在松弛完点 $u$ 的可松弛边后才标记 $u$ 出队，就会忽略掉由自环形成的负环。 

代码：
```cpp
int cnt[MAXN],dis[MAXN];
queue<int>q;
bool vis[MAXN];
int spfa(int s)
{
	memset(vis,0,sizeof(vis));
	memset(dis,0x7f,sizeof(dis));
	memset(cnt,0,sizeof(cnt));
	while(!q.empty())
		q.pop();
	vis[s]=1;
	dis[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		vis[u]=0;
		q.pop();
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w)
			{
				dis[v]=dis[u]+e[i].w;
				if(!vis[v])
				{
					if(++cnt[v]>n)
						return 1;
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
	return 0;
}
```
3. DFS-SPFA 求负环，时间复杂度 $\mathcal O (n^2)$：

据说只是判断负环的话很快，但要求解的话很慢。

可以搜索实现，松弛到还未退出的点即存在负环。

也可以像这样把普通 SPFA 里的队列改为栈，模拟深搜，但要注意这时 `vis[]` 表示的是否正在搜索经过而非是否在栈内。

作为“SPFA”一如既往地容易被卡（此题中被 #9 卡）。

代码（其实这个模拟但没完全模拟，反而显得麻烦了）：
```cpp
int dis[MAXN];
int stk[MAXN],sp;
int pre[MAXN],cnt[MAXN];//从哪个点搜过来的 / 从一个点出发的搜索分支数
bool vis[MAXN],instk[MAXN];
int dfs_spfa(int s)
{
	memset(vis,0,sizeof(vis));
	memset(dis,0x7f,sizeof(dis));
	memset(cnt,0,sizeof(cnt));
	memset(instk,0,sizeof(instk));
	sp=0;
	stk[++sp]=s;
	dis[s]=0;
	instk[s]=1;
	while(sp)
	{
		int u=stk[sp--];instk[u]=0;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w)
			{
				dis[v]=dis[u]+e[i].w;
				if(vis[v])
					return 1;
				if(!instk[v])
					stk[++sp]=v,
					cnt[u]++,
					pre[v]=u,
					instk[v]=1;
			}
		}
		while(u&&cnt[u]==0)
		{
			vis[u]=0;
			u=pre[u];
			cnt[u]--;
		}
	}
	return 0;
}
```

4. Bellman-Ford 算法求负环，时间复杂度 $\mathcal O (mn)$：

即 SPFA 算法的本质。

Bellman-Ford 算法在没有负环时，最坏情况（一条链）下也只需 $n-1$ 次即可完成所有松弛操作找到最短路，如果第 $n$ 次仍有可松弛的边，则图中有负环。

但是它并不能直接判断是否由 $1$ 可达，可以考虑第 $n$ 次循环来一次万能的 dfs 或者在松弛时顺带传下闭包。

代码：
```cpp
int dis[MAXN],vis[MAXN];
int bellman_ford(int s)
{
	memset(dis,0x7f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	vis[s]=1;
	for(int i=1;i<n;i++)
	{
		bool flag=1;
		for(int j=1;j<=tot;j++)//tot:边数
			if(dis[e[j].v]>dis[e[j].u]+e[j].w)
			{
				dis[e[j].v]=dis[e[j].u]+e[j].w;
				vis[e[j].v]|=vis[e[j].u];
				flag=0;
			}
		if(flag)
			return 0;
	}
	for(int j=1;j<=tot;j++)
		if(dis[e[j].v]>dis[e[j].u]+e[j].w)
		{
			dis[e[j].v]=dis[e[j].u]+e[j].w;
			if(vis[e[j].u])
				return 1;
		}
	return 0;
}
```

此外，本题中还有一点值得注意的就是，本题是一道个测试点有多组数据点的图论题，因此要重置链式向前星的 `head[]` 数组和加边计数（之前自己居然犯了这种错误……）。

说起来缩点暴力把边权变点权求负环似乎可能因正环加负环构成的 $8$ 形图而不通用？类似下图：（有其他方法欢迎评论指出）

![](https://cdn.luogu.com.cn/upload/image_hosting/k81i8v3u.png)

### 扩展：求出负环
----
~~虽然好像使用价值不是很大（总不能用负环缩点吧）。~~

1. Floyd 算法：

上面求负环的前一种方案显然可以直接求出。

或者由上面提到的结论，哪些点在负环上一目了然。如果要分出每个点所在的负环，考虑 dfs。

2. SPFA（Bellman-Ford）算法：

这里不再分开介绍。

在松弛时记录最短路径来源（SPFA 的话也可 DFS-SPFA 实现），回溯到环上 dfs。

值得注意的是 SPFA 中 `cnt[v]>n` 的点 $v$ 和 Bellman-Ford 算法中第 $n$ 次可松弛的边 $i$ 不一定在负环上（如下图），因此需向前回溯 $n$ 次。

![](https://cdn.luogu.com.cn/upload/image_hosting/rqmavufl.png)

不过上面提到的几种方法，多半可能在两个负环构成的 $8$ 形图中漏解，这个问题个人暂时无解 emmmm。

此外还在网上看到另一种建立“最短路径树”判环的方法，想了解的可以参考[链接](https://www.zhihu.com/question/264951302)。

### 其他
----
关于上文提到的“Floyd 算法结果中负环上的点到自身距离小于 $0$”这个结论，个人的理解是：Floyd 最外层经过 $k$ 次插点循环的结果是，最多经过 $1 \cdots k$ 的点下的最短路径，如果存在负环，即便以及不满足动态规划的最优化原理，但自己到自己的距离会被一条经过负环至少一圈（一部分）的路径取代，因此负环上的点到自身距离小于 $0$。

如有不对或有其他更严谨/更好理解的想法欢迎指出，其他地方也是。


---

## 作者：Suuon_Kanderu (赞：34)

模板题为啥没人来发题解啊……

反正 SPFA 也已经是 $O(VE)$ 了，所以我们直接写 BellmanFord 也只是差个常数而已。

BellmanFord 的算法流程是这样的：

1. 初始化，设 $d_i$ 为 1 到 n 的最短路距离，肯定是 $d_1 = 0, d_{2 \cdots n} = \operatorname{inf}$。

2. 进行 $n-1$ 次松弛操作。我们每次就更新一层数的最短路。什么意思呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/qhc5gpzq.png)

比如这个垃圾图，第一次，我们就会把 $d_B$ 更新为 $f$ ，第二次操作时就会把 $d_C$ 更新为 $f+g$。

具体实现就可以用 for 循环扫一遍所有的边。当然你用什么 SPFA 的就是用队首更新点。

3. 到了我们判断负环的时间了。

我们把所有边扫一遍，由于题目说 **从顶点 1 出发能到达的负环**，所以我们直接掠过顶点 1 无法到达的点，（$d_i = \operatorname{inf}$）。按理说，$n-1$ 次松弛之后我们一定无法获得更短的路了(都被松弛过了)。然而，如果存在负环，就没有最短路了，因为在负环上能够越走越短，**所以此时如果能够松弛，一定存在负环**

代码：

```
#include <cstdio>
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e6 + 1000;
int cnt = 0;
struct node{
	int x , y , v;
}e[N];
void add(int x ,int y , int v) {e[++cnt] = {x , y , v};}
void addd(int x, int y , int v) {
	if(v < 0)add(x , y , v);
	if(v >= 0) add(x , y , v) , add(y , x , v);
}
int n;
bool bellman() {
	static int d[N];
	d[1] = 0;
	for(int i = 2; i <= n; i++)
		d[i] = 0x7fffffff;
	for(int i = 1 ; i <= n - 1; i++)
		for(int j = 1; j <= cnt; j++) {
			if(d[e[j].x] != 0x7fffffff && 
			d[e[j].x] + e[j].v < d[e[j].y])
				d[e[j].y] = d[e[j].x] + e[j].v;
		}
	for(int i = 1; i <= cnt; i++) {
		if(d[e[i].x] == 0x7fffffff || d[e[i].y] == 0x7fffffff)continue;
		if(d[e[i].x] + e[i].v < d[e[i].y])return true;// 负权回路
	}
	return false;
}
signed main() {
	int t;scanf("%d" , &t);
	while(t--) {
		memset(e , 0 , sizeof(e));
		cnt = 0;
		int m;scanf("%d%d" , &n, &m);
		for(int i = 1; i <= m; i++) {
			int x , y , v;scanf("%d%d%d" , &x , &y , &v);
			addd(x , y , v);
		}
		if(bellman())printf("YES\n");
		else printf("NO\n");		
	}
	return 0;
}
```


---

## 作者：Daniel_7216 (赞：16)

负环的定义是：一条边权之和为负数的回路。所以在负环的图上是不存在最短路的。

所以，我们考虑这样的思路：先试着求出 $1$ 到其他点的最短路，如果发现不存在合法路径，就说明有负环存在。

- 方法一：弗洛伊德

求出任意两点之间的最短路，如果有一个点到自己的距离为负数，就说明存在负环，时间复杂度 $O(TN^3)$，（~~关于弗洛伊德：它死了~~）

- 方法二：SPFA

![](https://cdn.luogu.com.cn/upload/pic/25108.png)

开玩笑，开玩笑。其实正解就是 SPFA。

SPFA 本质上可以看作一个变形的 BFS，我们想想它的算法流程（参考了蓝书）：

1. 用 $dis_i$ 表示点 $i$ 到起点的距离，初始值设为无穷大，起点设为 $0$，并把它放入一个队列中。

2. 每次从队头取出点 $x$，扫描它所有的领居点 $y$，两点的距离为 $z$，如果 $dis_x+z<dis_y$，则更新 $dis_y$，同时如果 $y$ 不在队列中则让 $y$ 入队。

3. 重复执行直到队空。

如果存在负环，那么就会有负边，这样的话有些点就会被一直更新。所以如果一个点被超 $N$ 个点更新过，那就说明有负环。

或者，可以记录最短路的边数。如果不存在负环，图的最短路是不会反复经过一条边的。

更新次数判负环：
```cpp
#include <cstdio>
#include <iostream>
#include <queue>
#include <vector>
#include <cstring> 
using namespace std;
int T, n, m, u, v, w;
vector <pair<int, int> > G[2001];
int dis[2001], cnt[2001];
bool in[2001];
void spfa(){
	memset(dis, 0x3f3f, sizeof(dis));
	memset(in, 0, sizeof(in));
	memset(cnt, 0, sizeof(cnt));
	queue <int> q;
	q.push(1);
	dis[1] = 0;
	in[1] = true;
	cnt[1] = 1;
	while (!q.empty()){
		u = q.front();
		q.pop();
		in[u] = false;
		for (int i = 0; i < G[u].size(); i++){
			v = G[u][i].first;
			w = G[u][i].second;
			if (dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				if (!in[v]){
					cnt[v]++;
					q.push(v);
					in[v] = true;
					if (cnt[v] >= n){
						printf("YES\n");
						return;
					} 
				}
			}
		}
	}
	printf("NO\n");
}
int main(){
	scanf("%d", &T);
	for (int  t = 0; t < T; t++){
		scanf("%d%d", &n, &m);
		for (int i = 1; i <= n; i++){
			G[i].clear();
		}
		for (int i = 0; i < m; i++){
			scanf("%d%d%d", &u, &v, &w);
			G[u].push_back(make_pair(v, w));
			if (w >= 0){
				G[v].push_back(make_pair(u, w)); 
			} 
		}
		spfa();
	}
	return 0;
}
```
最短路路径数判负环：
```cpp
#include <cstdio>
#include <iostream>
#include <queue>
#include <vector>
#include <cstring> 
using namespace std;
int T, n, m, u, v, w;
vector <pair<int, int> > G[2001];
int dis[2001], cnt[2001], sum;
bool in[2001];
void spfa(){
	memset(dis, 0x3f3f, sizeof(dis));
	memset(in, 0, sizeof(in));
	memset(cnt, 0, sizeof(cnt));
	queue <int> q;
	q.push(1);
	dis[1] = 0;
	in[1] = true;
	cnt[1] = 0;
	while (!q.empty()){
		u = q.front();
		q.pop();
		in[u] = false;
		for (int i = 0; i < G[u].size(); i++){
			v = G[u][i].first;
			w = G[u][i].second;
			if (dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				cnt[v] = cnt[u] + 1;
				if (cnt[v] >= sum){
					printf("YES\n");
					return;
				}
				if (!in[v]){
					q.push(v);
					in[v] = true; 
				}
			}
		}
	}
	printf("NO\n");
}
int main(){
	scanf("%d", &T);
	for (int  t = 0; t < T; t++){
		scanf("%d%d", &n, &m);
		sum = 0;
		for (int i = 1; i <= n; i++){
			G[i].clear();
		}
		for (int i = 0; i < m; i++){
			scanf("%d%d%d", &u, &v, &w);
			G[u].push_back(make_pair(v, w));
			sum++;
			if (w >= 0){
				sum++;
				G[v].push_back(make_pair(u, w)); 
			} 
		}
		spfa();
	}
	return 0;
}
```

---

## 作者：Nt_Tsumiki (赞：8)

### 题意
传送门：[link](https://www.luogu.com.cn/problem/P3385)

给你 $T$ 个图，每个图有 $n$ 个点和 $m$ 条由 $u$ 到 $v$ 边权为 $w$ 的边。

现给你这 $m$ 条边，求图中是否有负环。
### 做法
#### 算法分析
根据题的大意我们可以看出，这是一道单源最短路的题目。

单源最短路算法有 dij 和 SPFA，那这道题应该用哪道算法呢？

我们看一下数据范围：

- $1 \leq n \leq 2 \times 10^3$，$1 \leq m \leq 3 \times 10^3$。

- $1 \leq u, v \leq n$，$-10^4 \leq w \leq 10^4$。

- $1 \leq T \leq 10$。

很明显会有负环，这时 dij 就行不通了，我们就需要用 SPFA 了。
#### 算法讲解
SPFA 为能够有效判断**负环**的一种单源最短路算法，但其算法复杂度比不上 dij，在存在菊花图的情况下，很容易原地爆炸。

但由于能够判断负环的性质，才使得它在同类最短路算法中没有被淘汰（可应用于 Johnson 全源最短路算法中），其主要思想为**贪心**。

SPFA 的独特性质在于他的一个点能够不止一次进队，这个特点有利也有弊，

利在于它可以通过入队次数来判断负环；

弊在于它容易被卡（~~关于SPFA，他死了~~）。

但在此题中它能完美胜任 dij（他不能判负环）。

资料：[link](https://www.luogu.com.cn/blog/natieyes/zui-duan-lu-suan-fa-zhi-spfa)
#### 算法实现
答题思路很简单，先链式前向星存图，再用 SPFA 遍历即可，所以问题在于 SPFA 的整体框架。

收我们需要一个队列，先把 $1$ 号点存进去，再遍历到与 $1$ 号点所连接着的点，依次松弛、入队，如果一个点入队次数大于等于 $n$ 就直接输出 `YES` 接着 `return`；如果队列为空了，但依旧没有输出 `YES` 就输出 `NO`。
### Code
```cpp
//注释极少版
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>

using namespace std;
int t,cnt;
int dis[10001],v[10001];
int head[10001],tim[10001];

struct Node{
    int to,next,dis;
}edge[100001];

void add(int t1,int t2,int t3) {//存图
    cnt++;
    edge[cnt].to=t2;
    edge[cnt].dis=t3;
    edge[cnt].next=head[t1];
    head[t1]=cnt;
}

void SPFA_dui(int n) {
    queue<int> q;
    memset(dis,0x3f,sizeof(dis));
    memset(v,0,sizeof(v));
    memset(tim,0,sizeof(tim));
    //初始化
    dis[1]=0;
    v[1]=1;
    q.push(1);//加入 1
    while (!q.empty()) {
        int x=q.front();
        q.pop();
        v[x]=0;
        for (int i=head[x];i;i=edge[i].next) {//链式前向星遍历
            int y=edge[i].to;
            if (dis[y]>dis[x]+edge[i].dis) {//relax
                dis[y]=dis[x]+edge[i].dis;
                tim[y]=tim[x]+1;
                if (tim[y]>=n) {//有负环
                    cout<<"YES"<<endl;
                    return;
                }
                if (!v[y]) {//入队
                    v[y]=1;
                    q.push(y);
                }
            }
        }
    }
    cout<<"NO"<<endl;
    
}

int main() {
    scanf("%d",&t);
    for (int i=1;i<=t;i++) {
        memset(head,0,sizeof(head));//有多组数据，记得清空
        int n,m;
        scanf("%d%d",&n,&m);
        for (int j=1;j<=m;j++) {
            int t1,t2,t3;
            cin>>t1>>t2>>t3;
            add(t1,t2,t3);
            if (t3>=0) {
                add(t2,t1,t3);
            }
        }
        SPFA_dui(n);
        cnt=0;
    }
}
```

---

## 作者：Brian_WBY (赞：8)

因为LaTeX的使用不规范被拒了两次，认真改了一遍，应该没问题了。

update：感谢巨佬@Fee_cle6418  指出错误，现已改正。

------------

题解区的大佬都是用的链式前向星存图，蒟蒻不会啊$qwq$，还是用vector吧。

### 感谢@Fee_cle6418 指出这里vector常数不一定大。

题目要求判定负环，由于dijkstra算法无法处理负权，于是我只好无(kai)奈(xin)的使用spfa算法，即队列优化的Bellman-Ford算法。时间复杂度为$O(km)$，这里$k$是一个常数，但是容易被卡成$O(nm)$。但是在这里只能用spfa，出题人是不可能这么无良再去卡spfa的，可以放心使用。

因为spfa是队列优化的Bellman-Ford，所以我先简单说一下Bellman-Ford算法。

Bellman-Ford是对整张图进行$n-1$次松弛，每次枚举每条边进行松弛，最后一定能得出最优解。

而spfa就是在Bellman-Ford的基础上避免无意义的松弛操作，只有成功的松弛操作才会对那个点产生影响，所以使用队列维护等待松弛的点，每次取出一个点进行松弛，对于所有松弛成功的点加入队列，来达到加速的目的。具体实现细节见代码。

spfa算法求单源最短路径的代码（[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)）：

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
#define INF 2147483647//我并不推荐使用这样的最大值，太容易爆了，但是由于题目就是要求如果无法到达，直接输出这个数，所以我干脆把最大值定位这个数了
struct edge
{
	int v,w;//保存能够到达的点和边权
	edge(int _v=0,int _w=0)//初始化函数，方便加边
	{
		v=_v;
		w=_w;
	}
};
vector<edge>g[10001];//记录每个点能到达的点以及权值
int d[10001];//d[x]表示从s到x的最短路
bool inq[10001];//inq[x]为1表示x在队列中
queue<int>q;//因为每个点要入队多次，手写队列空间耗费巨大，又不想写循环队列，干脆用STL好了
int main()
{
	int n,m,s;
	scanf("%d%d%d",&n,&m,&s);
	int u,v,w;
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		g[u].push_back(edge(v,w));//单向边只需要加一次
	}
	q.push(s);//起始点加入队列
	inq[s]=1;//s在队列中，inq[s]=1
	for (int i=1;i<=n;i++)
		d[i]=INF;//先把d数组赋初值为INF，方便求最小值
	d[s]=0;//s->s当然是0
	while (!q.empty())//bfs
	{
		int now=q.front();
		q.pop();//取出队首
		inq[now]=0;//now现在已经不在队列，inq[now]=0
		for (vector<edge>::iterator it=g[now].begin();it!=g[now].end();it++)//这个时候用元素迭代器较方便
			if  (d[it->v]>d[now]+it->w)//如果可以对now能到达的点松弛
			{
				d[it->v]=d[now]+it->w;//松弛
				if  (!inq[it->v])//如果松弛成功的点不在队列中
				{
					q.push(it->v);//加入队列
					inq[it->v]=1;//这个点已入队，inq变为1
				}
			}
	}
	for (int i=1;i<=n;i++)
		printf("%d ",d[i]);//直接输出答案即可
	return 0;
}
```

PS：spfa算法中任意一个队列标记搞错都会导致死循环或跑的很慢。

有了上面的spfa的代码，我们如何利用他判定负环呢？

其实也比较简单，如果一个点被松弛了$n$次及以上，那么一定有负环，开一个$times$数组记录松弛次数即可。原因如下：

因为spfa的Bellman-Ford的优化，而Bellman-Ford算法完成后可以保证所有长度为$n-1$的路径全部被遍历，而如果需要对某个点进行第$n$次松弛，说明已经成环了，而这个环可以使最短路变小，说明他一定是负环，而且起始点能够到达。

在spfa的基础上记录松弛次数即可，但本题多组数据，需要稍作改动，代码如下（与spfa一样的部分不再解释）：

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
const int INF=0x3f3f3f3f;//我习惯定义INF为0x3f3f3f3f，理由是可以memset
using namespace std;
struct edge
{
	int v,w;
	edge(int _v=0,int _w=0)
	{
		v=_v;
		w=_w;
	}
};
int n;
vector<edge>g[2001];
int d[2001];
bool inq[2001];
queue<int>q;
int times[2001];//记录松弛次数
void spfa(int s)//多组数据，为了方便，我用了函数
{
	memset(inq,0,sizeof(inq));
	memset(d,INF,sizeof(d));
	memset(times,0,sizeof(times));
	while (!q.empty())	q.pop();//多组数据，处理前要全部清空
	q.push(s);
	inq[s]=1;
	d[s]=0;
	times[s]=1;
	while (!q.empty())
	{
		int now=q.front();
		q.pop();
		inq[now]=0;
		for (vector<edge>::iterator it=g[now].begin();it!=g[now].end();it++)
			if  (d[it->v]>d[now]+it->w)
			{
				d[it->v]=d[now]+it->w;
				times[it->v]++;//松弛次数加1
				if  (times[it->v]>n)//如果已经有点松弛次数大于n
				{
					puts("YES");//说明有负环，输出YES
					return;//返回，不需要继续遍历
				}
				if  (!inq[it->v])
				{
					q.push(it->v);
					inq[it->v]=1;
				}
			}
	}
	puts("NO");//永远没有点松弛次数大于n，说明无负环
}
int main()
{
	int t,m;
	scanf("%d",&t);
	for (int i=1;i<=t;i++)
	{
		scanf("%d%d",&n,&m);
		int u,v,w;
		for (int j=1;j<=m;j++)
		{
			scanf("%d%d%d",&u,&v,&w);
			g[u].push_back(edge(v,w));
			if  (w>=0)  g[v].push_back(edge(u,w));//大于等于0时双向边
		}
		spfa(1);//调用函数，起点为1
		for (int j=1;j<=n;j++)
			g[j].clear();//清空
	}
	return 0;
}
```

用vector的码量还是比链式前向星少，~~适合我这种懒人~~。

---

## 作者：信守天下 (赞：6)

## [洛谷传送门](https://www.luogu.com.cn/problem/P3385)
## 题意
有 $T$ 张有向图，问每张图中有没有负环。
## 思路
判定每一张图中有没有负环，可以使用 SPFA 算法进行求解。
## SPFA 算法
在任意图的**单源**最短路径问题中，边权**可以为负**。

此时状态不像正权图中一样，不再有可用的拓扑序，只能进行**搜索**。

但依然可以使用**最优性剪枝**。

### SPFA 算法：宽搜求每个点的最短路径长度
它是基于 Bellman-Ford 算法的一种优化。

优化了两点：

- 最优性剪枝：每个点只记录当前最短的路径长度。
- 入队优化：点的最短路径长度被更新时，如果该点还在队列中，则不重复入队。

### SPFA 算法实现思路
$1.$ 初始化所有点，起点入队。

$2.$ 按顺序处理队列中的每个点。

$2. 1.$ 标记当前点出队。

$2. 2.$ 枚举邻点，找到能够更新距离的点。

$2.2.1.$ 记录更新的距离。

$2.2.2.$ 如果邻点不在队中，则入队并标记。
### SPFA 算法示例

我们考虑这样的一张图，以 $1$ 为起点。

![](https://cdn.luogu.com.cn/upload/image_hosting/xlf6ysc7.png)

SPFA 算法流程如下：

1. 初始状态 $[1, 0]$ ，入队。
2. 处理状态 $[1, 0]$。 
3. 得到状态 $[2, 24]$，更新点 $2$，入队。
4. 得到状态 $[3, 8]$，更新点 $3$，入队。
5. 得到状态 $[4, 15]$，更新点 $4$，入队。
6. 处理状态 $[2, 24]$。
7. 得到状态 $[5, 30]$，更新点 $5$，入队。
8. 处理状态 $[3, 8]$。
9. 得到状态 $[5, 15]$，更新点 $5$，已在队中，不入队。
10. 得到状态 $[6, 11]$，更新点 $6$，入队。
11. 处理状态 $[4, 15]$。
12. 得到状态 $[7, 19]$，更新点 $7$，入队。
13. 处理状态 $[5, 15]$。
14. 得到状态 $[7, 24]$，没有更新点 $7$，舍弃。
15. 处理状态 $[6, 11]$。
16. 得到状态 $[4, 16]$，没有更新点 $4$，舍弃。
17. 得到状态 $[5, 13]$，更新点 $5$，入队。
18. 得到状态 $[7, 14]$，更新点 $7$，已在队中，不入队。
19. 处理状态 $[7, 14]$。
20. 得到状态 $[2, 17]$，更新点 $2$，入队。
21. 处理状态 $[5, 13]$。
22. 得到状态 $[7, 22]$，没有更新点 $7$，舍弃。
23. 处理状态 $[2, 17]$。
24. 得到状态 $[5, 23]$，没有更新点 $5$，舍弃。
25. 所有状态处理完毕，最终结果如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/v09hs8gl.png)

### 复杂度分析
令点数为 $n$，边数为 $m$。

每个点最多入队 $O(n)$ 次，对于**随机图**，**期望**入队次数 $O(1)$。
#### 时间复杂度
遍历图一次 $O(n + m)$。

总时间复杂度为 $O((n + m)n)$，**期望**时间复杂度 $O(n + m)$。
#### 空间复杂度
队列中点数 $O(n)$。

存储图 $O(n + m)$。

总空间复杂度为 $O(n + m)$。
### SPFA 算法判定负环
SPFA 算法可以判断是否存在负环。

令图中点数为 $n$，如果没有负环，任意点的最短路径边数最多为 $n - 1$。

点是**按顺序**处理的，一个点在两次入队之间，**至少**有一个新点求出了最短距离。

所以，如果有点入队次数达到 $n$，必然存在负环。
## code
~~~cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;
using PII = pair<int, int>;

const int kMaxN = 2e3 + 1, kInf = ~(1 << 31);

struct Edge {     // 点
  vector<PII> e;  // 边，记录指向节点和长度
  int d = kInf;   // 距离
  int vis;        // 入队次数
  bool b;         // 在队列中的标记
} edge[kMaxN];
queue<int> q;
int t, n, m;

bool Record(int x, int d) {  // 处理x点距离d的新状态
  if (d < edge[x].d) {       // 是更优状态
    edge[x].d = d;           // 记录
    if (!edge[x].b) {        // 点不在队中
      edge[x].b = 1;         // 标记入队
      edge[x].vis++;         // 入队次数增加
      q.push(x);             // 入队
    }
  }
  return edge[x].vis >= n;  // 判定负环
}

bool SPFA() {                                // SPFA求最短路&判定负环
  for (Record(1, 0); !q.empty(); q.pop()) {  // 记录起始状态，依次处理每个状态
    int x = q.front();
    edge[x].b = 0;                                  // 标记出队
    for (PII e : edge[x].e) {                       // 遍历邻边
      if (Record(e.first, edge[x].d + e.second)) {  // 处理新状态&判定负环
        return 1;                                   // 是负环，返回
      }
    }
  }
  return 0;  //求完所有点最短路后仍然没有出现负环
}

void Make() {  // 多测清空
  vector<PII> f;
  fill(&edge[0], &edge[kMaxN], (Edge){f, kInf, 0, 0});
  while (!q.empty()) {
    q.pop();
  }
}

int main() {
  cin >> t;
  while (t--) {
    Make();
    cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; i++) {  //建边
      cin >> u >> v >> w;
      edge[u].e.push_back({v, w});
      if (w >= 0) {
        edge[v].e.push_back({u, w});
      }
    }
    cout << (SPFA() ? "YES" : "NO") << endl;
  }
  return 0;
}
~~~
### 注意：部分代码为 C++ 17 的语法，使用 C++ 11 或 C++ 14 等评测可能会编译错误

---

## 作者：安子 (赞：6)


题目中给出的负环定义：

> 一条边权之和为负数的回路。

负环自然用 SPFA 来判（Dijstra 甚至不能处理有负权边的图，[为什么](https://blog.csdn.net/u012677715/article/details/79346113)）。
而未用队列优化的 [Bellman-ford](https://blog.csdn.net/anlian523/article/details/80953767) 复杂度为 $O(n\times e)$，不是我们能接受的。

**SPFA 能判断负权环得益于其的松弛操作。**
在 SPFA 中，我们跟新最短路的条件为 $dist[u]>dist[v]+len[v][u]$。即原点通过当前已知路径从一节点到达新的节点的距离小于原点直接从已知路径到达新的节点的距离。跟新完成后，由于新的节点可能更新出一条更优路径，就放入队中（没入队的话）。此称为一次松弛。

在正常的情况下，一个点入队最多次为 $n-1$，原因我们可以类比 Bellman-ford：在 Bellman-ford 的迭代过程中，每迭代一次就最少会求出一个点到源点的最短路。也就是说，每个点最多会被迭代 $n-1$ 次,换成了 SPFA，就是每个点最多会入队 $n-1$ 次。我们就可以运用这点来判断负环。

如果存在负环，意味着这个环将不断跟新，迭代的次数也将无穷无尽。那我们用一个 $intot$ 数组来记录每个点的入队次数（也就是迭代次数）。当某个点的入队次数大于等于 $n$ 时，即意味着存在负环了。

下面是代码。

```
#include <bits/stdc++.h>
#define ll long long
#define M 10200
#define N 10200
using namespace std;
inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=(re<<1)+(re<<3)+(ch-'0'); ch=getchar();}
    return re*f;
}//快读
struct node{
	int next;
	int to;
	int len;
}a[M];
int head[N],num=0;
void edge(int x,int y,int z)
{
	a[++num].len=z;
	a[num].to=y;
	a[num].next=head[x];
	head[x]=num;
}//链式前向星存图
queue<int >q;
int bj[N];//记录点是否在队列中
int intot[N];//记录入队次数
ll dist[N];//记录到源点1的最短路
int n,m;
int ans[100];//根据此输出答案

void spfa(int t)//标椎SPFA
{
	while(!q.empty())
	{
		int u=q.front();q.pop();bj[u]=0;
		for (int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if (dist[u]+a[i].len<dist[v])
			{
				dist[v]=dist[u]+a[i].len;
				if (bj[v]==0)
				{
				    intot[v]++;//记录入队次数
					q.push(v);bj[v]=1;
					if (intot[v]>=n) 
					{
						ans[t]=1;//入队太多了就记录当前数据存在负环
						return ;
					}
					
				}
			}
		}
	}
	ans[t]=0;return ;//完整做完最短路即不存在负环
}
void ng(int t)
{
	memset(a, 0, sizeof(a));
	memset(bj,0, sizeof(bj));
	memset(head, 0, sizeof(head));
	memset(intot, 0, sizeof(intot));
	memset(dist,0x3f3f3f3f, sizeof(dist));
	while(!q.empty())q.pop();num=0;//初始化
	n=read();m=read();
	for (int i=1;i<=m;++i)
	{
		int x,y,z;
		x=read();y=read();z=read();
		edge(x,y,z);
		if (z>=0)edge(y,x,z);//别忘了当有一边权值大于零时存两边
	}
	q.push(1);bj[1]=1;intot[1]++;
	dist[1]=0;spfa(t);//先把1入队
}
int main()
{
	int t;
	t=read();
	for (int i=1;i<=t;++i) ng(i);
	for (int i=1;i<=t;++i)
	{
		if (ans[i]==1)cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
	}//合起来输出
	return 0;
}

```


---

## 作者：Push_Y (赞：5)

 从[P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)题解区里的大佬指路到来，建议大家做完这题再用那题来当一个复习。

###  负环

一个所有边的边权和为负数的环叫做负环。如果一个图中出现了负环，会导致最短路永远走不出去。思考一下，如果有一个点已经被走过了 $n-1$ 次，这意味着什么。

###  如何判断负环？
 
 用 `spfa` 跑最短路的时候，每次判断队首点的入队次数是否已经达到 $n-1$ 。若有一次满足该条件，则有负环，直接输出 `YES` 。若没有一次满足该条件，则无负环，输出 `NO` 。
 
### 其他注意事项

- 对于每一组数据，清空掉有关的数组。
- 链接表要开两倍 $M$
- 更多精彩尽在代码注释中。

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gin(){//快读
	char c=getchar();
	int s=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=5e3+5;//本题数据范围不大，习惯开大一点。
int n,m,cnt[N],d[N],tot=0,head[N];
//cnt记录已经入队的次数。
bool h[N],t;
//小写字母t用来存是否存在负环，存在则为1，否则为0。
queue<int> q;

struct edge{//用结构体存链接表
	int dis,ne,to;
}e[N<<1];

inline void add(int u,int v,int w){//连边
	e[++tot].dis=w;
	e[tot].to=v;
	e[tot].ne=head[u];
	head[u]=tot;
}

inline void spfa(){//最短路模板
	memset(h,0,sizeof h);
	memset(cnt,0,sizeof cnt);
	memset(d,63,sizeof d);//记得每次初始化
	h[1]=1,t=0,d[1]=0;
	q.push(1);
	while(q.size()){
		int u=q.front();q.pop();h[u]=0;
		if(cnt[u]==n-1){t=1;return;}//如果在此之前已经有n-1次入队了则有负环。
		cnt[u]++;
		for(int i=head[u];i;i=e[i].ne){
			int v=e[i].to,w=e[i].dis;
			if(d[v]>d[u]+w){
				d[v]=d[u]+w;
				if(!h[v])h[v]=1,q.push(v);
			}
		}
	} 
}

int main(){
	int T=gin();
	while(T--){
		n=gin(),m=gin();
		tot=0;//在tot变为0的情况下，结构体e每次存的时候都会覆盖老的答案，所以不再需要初始化e了。
		memset(head,-1,sizeof head);//初始化head数组
		for(int i=1;i<=m;i++){
			int u=gin(),v=gin(),w=gin();
			add(u,v,w);
			if(w>=0)add(v,u,w);
		}
		spfa();
		if(t)printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

---

## 作者：珈乐唯毒 (赞：4)

本来一看负边，环条件反射的想floyd

写了一半看数据范围发现炸了QAQ

dijkstra不能处理负边

所以这道题只能用spfa

而当SPFA算法中一个点的d值被更新达到n次，说明图中存在负环

因此只需要从1开始广搜，每一次记录改点的到达次数就行了
```
#include<bits/stdc++.h>
using namespace std;
int t,n,m,u,v,w,nn,vis[2005],viss[2005],d[2005];
struct lmf{
	int v,w;
	lmf(int a,int b){
		v=a;
		w=b;
	}
};
vector<lmf> g[2005];
bool fid=0;
bool vi[2005];
queue<int> q;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		memset(d,0x7f,sizeof(d));
		memset(viss,0,sizeof(viss));
		fid=0;
		for(int i=1;i<=m;i++){
			scanf("%d%d%d",&u,&v,&w);
			g[u].push_back(lmf(v,w));
			if(w>=0)g[v].push_back(lmf(u,w));
		}
		d[1]=0;
		q.push(1);
		while(!q.empty()){
			u=q.front();
			q.pop();
			vi[u]=0;
			if(viss[u]>=n){
				cout<<"YES"<<endl;
				fid=1;
				break;
			}
			for(int i=0;i<g[u].size();i++)if(d[u]+g[u][i].w<d[g[u][i].v]){
				viss[g[u][i].v]++;
				d[g[u][i].v]=d[u]+g[u][i].w;
				if(!vi[g[u][i].v]){
					vi[g[u][i].v]=1;
					q.push(g[u][i].v);
				}
			}
		}
		for(int i=1;i<=n;i++)g[i].clear();
		if(!fid)cout<<"NO"<<endl;
	}
	return 0;
} 
```


---


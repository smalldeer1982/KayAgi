# 道路重建

## 题目描述

从前，在一个王国中，在 $n$ 个城市间有 $m$ 条道路连接，而且任意两个城市之间至多有一条道路直接相连。在经过一次严重的战争之后，有 $d$ 条道路被破坏了。国王想要修复国家的道路系统，现在有两个重要城市 $A$ 和 $B$ 之间的交通中断，国王希望尽快的恢复两个城市之间的连接。你的任务就是修复一些道路使 $A$ 与 $B$ 之间的连接恢复，并要求修复的道路长度最小。

## 样例 #1

### 输入

```
3
2
1 2 1
2 3 2
1
1 2
1 3```

### 输出

```
1```

# 题解

## 作者：xiaolou (赞：99)

2325131433448687~

这道题居然没有floyd的题解，蒟蒻表示愤愤不平，100的数据都没人写floyd，那我就来水一发2333。。。

神奇代码：
```cpp
#include <bits/stdc++.h>

using namespace std;
int h[105][105],d[105][105];
void floyd(int n)
{
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				h[i][j]=min(h[i][j],h[i][k]+h[k][j]);
}//floyd的板子，floyd的特点就是思路清晰，代码精简，所以很适合我这样听不懂dijkstra和spfa的蒟蒻使用。。。	

int main()
{
	memset(h,0x3f3f3f3f,sizeof(h));//一拜初始化
	int n,m,k;
	cin >> n >> m;
	for(int i=1;i<=m;i++)
	{
		int s,e;
		cin >> s >> e;
		cin >> d[s][e];
		d[e][s]=d[s][e];
		h[s][e]=h[e][s]=0;
	}//二拜建图（注意是双向边，建成单向边会瞬间爆炸。。。）
	cin >> k;
	for(int i=1;i<=k;i++)
	{
		int s,e;
		cin >> s >> e;
		h[s][e]=h[e][s]=d[s][e];//三拜删边(2333)
	}
	floyd(n);//套板子喽！真香。。。
	int st,en;
	cin >> st >> en;
	cout << h[st][en];//愉快地输出，最后祝大家NOIP进复赛！
	return 0;
    //2325131433448687
} 
```

---

## 作者：EarthGiao (赞：29)

## 【三种方法】

###  1.【最简单的弗洛伊德】
#### 【思路】
弗洛伊德的方法    
先将有路的点都连接起来   
由于只需要修改损坏的点    
所以完好的道路是可以走的而且不需要修复   
所以消耗为0     
可以把损坏的边标记一下   
把没被标记的也就是完好的边改为0    
因为不需要消耗    

最后再跑一遍弗洛伊德就好了     
#### 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int Max = 102;
int f[Max][Max];
bool use[Max][Max];
int main()
{
	int n,m,k;
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(register int i = 1;i <= n;++ i)
		for(register int j = 1;j <= n;++ j)
			f[i][j] = 999;
	for(register int i = 1;i <= m;++ i)
	{
		cin >> x >> y >> z;
		f[x][y] = f[y][x] = z;
	}
	scanf("%d",&k);
	for(register int i = 1;i <= k;++ i)
	{
		cin >> x >> y;
		use[x][y] = use[y][x] = true;
	}
	for(register int i = 1;i <= n;++ i)
		for(register int j = 1;j <= n;++ j)
			if(use[i][j] == false && f[i][j] != 999)
				f[i][j] = 0;
	for(register int k = 1;k <= n;++ k)
		for(register int i = 1;i <= n;++ i)
			for(register int j = 1;j <= n;++ j)
				f[j][i] = f[i][j] = min(f[i][j],f[i][k] + f[k][j]);
	int A,B;
	scanf("%d%d",&A,&B);
	cout << f[A][B] << endl;
	return 0;
}
```

### 2.【SPFA】
#### 【思路】
SPFA    
SPFA诈尸+1   
先输入有路的数据    
建立边但是先不赋值   
保持他默认为0的距离   
只把某条边对应的长度稍微记录一下     
然后输入坏掉的路    
这个时候才将坏掉的路的长度赋值上去   
因为完好无损的路可以通过而且不需要耗费去修复   
所以对需要修复的路径的总长度没有贡献   
就是0   
但是坏掉的不一样   
贡献它本身的长度   
  
然后跑SPFA求出A到B的最短路就好了     
#### 【完整代码】 
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int Max = 102;
struct node
{
	int y;
	int ne;
	int z;
}a[Max * Max];
int sum = 0;
int head[Max];
int acioi[Max * Max];
void add(int x,int y,int z)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	acioi[sum] = z;
	head[x] = sum;
}

int d[Max];
bool use[Max];
int A,B;
int n,m,k;
void SPFA()
{
	queue<int>q;
	q.push(A);
	for(register int i = 1;i <= n;++ i)
		d[i] = 999;
	d[A] = 0;
	while(!q.empty())
	{
		int qwq = q.front();
		q.pop();use[qwq] = false;
		for(register int i = head[qwq];i != 0;i = a[i].ne)
		{
			int awa = a[i].y;
			if(d[awa] > d[qwq] + a[i].z)
			{
				d[awa] = d[qwq] + a[i].z;
				if(use[awa] == false)
				{
					use[awa] = true;
					q.push(awa);
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y,z;
	for(register int i = 1;i <= m;++ i)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	scanf("%d",&k);
	for(register int i = 1;i <= k;++ i)
	{
		scanf("%d%d",&x,&y);
		for(register int j = head[x];j != 0;j = a[j].ne)
			if(a[j].y == y)
				a[j].z = acioi[j];
		for(register int j = head[y];j != 0;j = a[j].ne)
			if(a[j].y == x)
				a[j].z = acioi[j];
	}
	scanf("%d%d",&A,&B);
	SPFA();
	cout << d[B] << endl;
	return 0;
}
```

### 3.【dijstra】
#### 【思路】
地杰斯特拉+堆优化    
我知道的三个求最短路的方法里面貌似生存能力最强的一个    
输入数据    
处理方式和SPFA的方法一个样    
先只把边连接起来但是不赋值边权    
让边权保持为0    
然后将损坏掉的路赋值上边权    
（原因不多赘述了，前面两种方法都说过了）    
 
然后跑dijkstra就好了     
#### 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
struct point
{
	int w;//按照w从小到大排序 
	int x;
	bool operator < (const point & xx)const 
	{
		return xx.w < w;
	}
};
priority_queue<point>q;
const int Max = 102;
struct node
{
	int y,ne,z;
}a[Max * Max];
int sum = 0;
int head[Max];
int acioi[Max * Max];
int n,m;
int A,B;
int dis[Max];
bool use[Max];

void add(int x,int y,int z)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	acioi[sum] = z;
	head[x] = sum;
}

void dj()
{
	dis[A] = 0;
	q.push((point){0,A});
	while(!q.empty())
	{
		point qwq = q.top();
		q.pop();
		int x = qwq.x;
		if(use[x] == true)
			continue;
		else
			use[x] = true;
		for(register int i = head[x];i != 0;i = a[i].ne)
		{
			int awa = a[i].y;
			if(dis[awa] > dis[x] + a[i].z)
			{
				dis[awa] = dis[x] + a[i].z;
				if(use[awa] == false)
					q.push((point){dis[awa],awa});
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(register int i = 1;i <= n;++ i)
		dis[i] = 999;
	int x,y,z;
	for(register int i = 1;i <= m;++ i)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	int k;
	scanf("%d",&k);
	for(register int i = 1;i <= k;++ i)
	{
		scanf("%d%d",&x,&y);
		for(register int j = head[x];j != 0;j = a[j].ne)
			if(a[j].y == y)
				a[j].z = acioi[j];
		for(register int j = head[y];j != 0;j = a[j].ne)
			if(a[j].y == x)
				a[j].z = acioi[j];
	}
	scanf("%d%d",&A,&B);
	dj();
	cout << dis[B] << endl;
	return 0;
}
```

---

## 作者：BILL666 (赞：20)

与楼下思路较相似，但用的是迪杰斯特拉算法。 因为要求最短修建长度，所以把那些没有损坏的边权当做0处理。 最开始存的时候，边权均赋为0； 之后输入被损坏的边时，枚举与其相连的每一条边； 枚举到另一个点时，将其路径改为初始值。 因为是无向图，改路径值时一定要注意两边都要改变！！！！！！ 具体代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,first[5000],next[5000],to[5000],w[5000],tot,d,a[200][200],A,B,dis[5000];
int pd[5000];
priority_queue<pair<int,int> >q;
void ADD(int x,int y,int s)//领接表存储
{
    tot++;
    next[tot]=first[x];
    first[x]=tot;
    to[tot]=y;
    w[tot]=s;
    return;
}
void DIJ()
{
    for(int i=1;i<=n;i++)
        dis[i]=1000000000;//赋一个老大老大的值
    dis[A]=0;
    q.push(make_pair(0,A));
    while(!q.empty())
    {
        int u=q.top().second;
        q.pop();
        for(int e=first[u];e;e=next[e])//枚举每条边
        {
            int v=to[e];
            if(dis[v]>dis[u]+w[e])//只要路径更短就更新
            {
                dis[v]=dis[u]+w[e];
                q.push(make_pair(-dis[v],v));
                //一定是-dis[v]!这样才能使其变为小根堆 
                //速度老快了！
            }
        }
    }
    return;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int ii,jj,kk;
        cin>>ii>>jj>>kk;
        a[ii][jj]=kk;
        a[jj][ii]=kk;//一定两面存！
        ADD(ii,jj,0);
        ADD(jj,ii,0);
    }
    cin>>d;
    for(int i=1;i<=d;i++)
    {
        int ii,jj;
        cin>>ii>>jj;
        for(int j=first[ii];j;j=next[j])
        	if(to[j]==jj) w[j]=a[ii][jj];
        for(int j=first[jj];j;j=next[j])
        	if(to[j]==ii) w[j]=a[ii][jj];//两面赋值！
    }
    cin>>A>>B;
    DIJ();//迪杰斯特拉走你！
    cout<<dis[B];
    return 0;
}
```

---

## 作者：beretty (赞：12)

终于过了

刚刚练了spfa,

本蒟蒻太水，写这道题还想了好半天（估计吃枣药丸qwq），代码挺丑。。。

主要思路：

通过gg数组存路径长度，g数组存到某点所要修的路径长度。

g数组起点赋值0。

然后就跑一遍spfa,

每循环到一个点就更新一次g数组的值。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int dis[1001],gg[1001][1001],team[1005],f[1001][1001],num[1005],n,m,s,t,d;
int way[1006],x,y,z,g[1001][1001],head[2001];
bool exist[1003];
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    int i,j,k;
    memset(gg,127,sizeof(gg));
    for(i=1;i<=m;i++)
    {
        cin>>x>>y>>z;
        g[x][y]=g[y][x]=1;
        gg[x][y]=gg[y][x]=z;
        f[x][++num[x]]=y;
        f[y][++num[y]]=x;
    }
    int b1,b2;
    cin>>d;
    for(i=1;i<=d;i++)
    {
        cin>>b1>>b2;
        g[b1][b2]=g[b2][b1]=0;
    }
    cin>>s>>t;
    memset(dis,127,sizeof(dis));
    team[1]=s;
    dis[s]=0;
    memset(way,127,sizeof(way));
    way[s]=0;
    exist[s]=true;
    int head=0,tail=1;
    do
    {
        head++;
        int u=team[head];
        exist[u]=false;
        for(i=1;i<=num[u];i++)
            if(dis[f[u][i]]>dis[u]+gg[u][f[u][i]])
            {
                dis[f[u][i]]=dis[u]+gg[u][f[u][i]];
                if(!g[u][f[u][i]])
                  way[f[u][i]]=min(way[f[u][i]],way[u]+gg[u][f[u][i]]);
                else way[f[u][i]]=min(way[f[u][i]],way[u]);
                if(!exist[f[u][i]])
                {
                    tail++;
                    exist[f[u][i]]=true;
                    team[tail]=f[u][i];
                }
            }
    }while(head<=tail);
    cout<<way[t]<<endl;
    return 0;
}
```

---

## 作者：xfydemx (赞：9)

关于此题，其实与一般的最短路的区别是不是求最短距离和，而是损坏的距离和，因而好的路与我们无关，可以建成边权为0来处理。


```cpp
#include       <map>
#include       <set>
#include     <ctime>
#include     <cmath>
#include     <queue>
#include     <stack>
#include    <cstdio>
#include    <vector>
#include   <cstring>
#include   <cstdlib>
#include  <iostream>
#include <algorithm>
using namespace std;
bool exi[1000000];
struct Edge{
    int next,to,w;//链式前向星建图
    bool h;//记录是否被毁坏
}a[10000];
int n,m,q,e,r,k,b,inde,head[100000],dis[1000000];
void add(int x,int y,int w){
    inde++;
    a[inde].to=y;
    a[inde].next=head[x];
    a[inde].w=w;
    head[x]=inde;
}
queue<int> Q;
int main()
{
    cin>>n>>m;
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i<=m;i++){
        cin>>q>>e>>r;
        add(q,e,r);
        add(e,q,r);
    }
    cin>>r;
    for(int i=1;i<=r;i++){
        cin>>q>>e;
        for(int j=head[q];j;j=a[j].next){
            if(a[j].to==e) a[j].h=1;
        }
        for(int j=head[e];j;j=a[j].next){
            if(a[j].to==q) a[j].h=1; //注意，由于是双向图，前向星里要从两边删边
        }
    }
    for(int i=1;i<=2*m;i++){
        if(!a[i].h) a[i].w=0;
    }
    cin>>k>>b;
    Q.push(k);//跑SPFA咯
    exi[k]=1;
    dis[k]=0;
    while(!Q.empty()){
        int x=Q.front();
        exi[x]=0;
        Q.pop();
        for(int i=head[x];i;i=a[i].next){
            int s=a[i].w,t=a[i].to;
             if(dis[t]>s+dis[x]){
                dis[t]=s+dis[x];
                if(!exi[t])
                Q.push(t);
                exi[t]=1;
            }
        }
    }
    cout<<dis[b];
    return 0;
}

```

---

## 作者：吴文姿 (赞：4)

我做这个题的时候

没有想到什么厉害的题解（~~虽然我会好几个  但是呢我不会写~~
）

但是
我还是写出来了一个题解

名字就叫   SPFA 神器算法

先上代码（~~抄袭者会被屎名的~~）
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define ll long long 
#include<queue>
using namespace std;
int a,b,k,end,c,d;
int vis[5555],head[5555],dis[5555];
int tot=0,n,m,s;
bool duan[101][101];
int aa[5555],bb[5555],cc[5555];
struct E{        //链式前向星 
    int to,pre,w;
}edge[30010];
void add(int x,int y,int z){//加边 
    tot++;
    edge[tot].to=y;
    edge[tot].w=z;
    edge[tot].pre=head[x];
    head[x]=tot;
}
void spfa(){
    
	//针对该题，要输出各点到其他点距离最短和 
        queue<int> q;
    	for(int i=1;i<=n;i++){//初始化， 
        	dis[i]=0x7fffffff;
        	vis[i]=0;
        }
    	q.push(k);//放入起点 
    	dis[k]=0;//自己到自己为0； 
    	vis[k]=1;
    	while(!q.empty()){ 
        	int u=q.front();
        	q.pop();vis[u]=0;//弹出队首 
        	for(int i=head[u];i;i=edge[i].pre){
            	int v=edge[i].to;
            	if(dis[v]>dis[u]+edge[i].w){
                	dis[v]=dis[u]+edge[i].w;//更新最小值sta 
                	if(!vis[v]){
	                    vis[v]=1;
	                    q.push(v);//重新放入； 
	                }
	            }
	        }
		}
	
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>aa[i]>>bb[i]>>cc[i];
    }
    cin>>d;
    for(int i=1;i<=d;i++)
    {
    	cin>>a>>b;
    	duan[a][b]=1;
    	duan[b][a]=1;
    }
    for(int i=1;i<=m;i++)
    {
    	if(duan[aa[i]][bb[i]]==0)
    	{
    		# add(aa[i],bb[i],0);
    		# add(bb[i],aa[i],0);
    	}
    	else {
    		# add(aa[i],bb[i],cc[i]);
    		# add(bb[i],aa[i],cc[i]);
    	}
    }
    
    cin>>k>>end;
    spfa();
    cout<<dis[end]<<endl;
	return 0;    
}
```


但是我要提醒的是      这是无向图   应该加边两次
（我因为这个被砍掉70分）
血淋淋的教训

---

## 作者：OIer991215 (赞：3)

突然发现自己还是太naive了。。

一开始是这么想的：woc好水的新题，spfa跑出最短路记录最短路上的点，然后看看哪些点之间的道路被砍掉了，加上不就完了。

然后GG了，80分\*3。。。。后来突然想到，，万一最短路有两条呢，这两条中每条都有一个道路被砍，一个是长边一个是短边。那么程序就不一定能运行出正确答案来了。

送80分同学一组数据：

4 4
1 2 2
2 3 2
1 4 1
4 3 3
2
2 3
4 3
1 3
于是经过改进，额外开了一个叫rep的数组，表示从上一个点到本点需要修复的路径和，然后就非常的显然了。

本题的难点就是：最短路可能不止一条啊（我还是太年轻了）




```cpp
#include <iostream>
#include <cstdio> 
#include <queue>
using namespace std;
queue <int> q;
int n,m,a,b,c,S,t,p,ans;
int s[110][110];
int dis[110];
int rep[110];
bool flag[110][110];
bool vis[10101];
int head[10101];
struct Node
{
    int to;
    int val;
    int next;
}e[1010101];
void add_edge(int u,int v,int va)
{
    e[++head[0]].to=v;
    e[head[0]].next=head[u];
    e[head[0]].val=va;
    head[u]=head[0];
}
void SPFA()
{
    q.push(S);
    vis[S]=1;
    for(int i=1; i<=n; i++)
        rep[i]=dis[i]=1e9;
    dis[S]=rep[S]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=head[x]; i!=0; i=e[i].next)
            if(dis[x]+e[i].val<=dis[e[i].to])
            {
                dis[e[i].to]=dis[x]+e[i].val;
                if(flag[x][e[i].to]==1)
                    rep[e[i].to]=min(rep[e[i].to],rep[x]+e[i].val);
                else
                    rep[e[i].to]=min(rep[e[i].to],rep[x]);
                if(!vis[e[i].to])
                {
                    vis[e[i].to]=1;
                    q.push(e[i].to);
                }
            }
        vis[x]=0;    
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add_edge(a,b,c);
        add_edge(b,a,c);
    }
    scanf("%d",&p);
    for(int i=1; i<=p; i++)
    {
        scanf("%d%d",&a,&b);
        flag[a][b]=flag[b][a]=1;
    }
    scanf("%d%d",&S,&t);
    SPFA();
    printf("%d",rep[t]);
    return 0;
}
```

---

## 作者：Alanalan (赞：3)

~~~
/*
这道题整体不是太难。用SPFA算法写的。
难度还可以(个人认为难度在普及-的难度)
首发题解，有问题请大佬们指出。谢谢！ 
*/ 
#include<iostream>//本题无需使用其他头文件 
using namespace std;
int n,m,d;
int a[110][110];//记录每两个城市之间的距离 
bool broken[110][110];//记录两个城市之间是否被破坏 
int A,B;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			broken[i][j]=true;//将每两个道路之间记为未被破坏 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=0x3f3f3f3f;//让没有道路的两个城市之间的距离置为一个非常大的数字(0x3f3f3f3f)
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;//输入x,y,z;(x为题中i,y为题中j,z为题中k)
		a[x][y]=z;//将这两个城市(i和j)的距离置为 k
		a[y][x]=z;
	}
	cin>>d;
	for(int i=1;i<=d;i++)
	{
		int x,y;
		cin>>x>>y;
		broken[x][y]=false;//输入两城之间是否被破坏 
		broken[y][x]=false;
	}
	cin>>A>>B;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]!=0x3f3f3f3f&&broken[i][j]==true)
				a[i][j]=0;//如果此处未被破坏，则不需要维修
		}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				a[i][j]=min(a[i][k]+a[k][j],a[i][j]);//SPFA(记录两地之间最短距离) 
	cout<<a[A][B]<<endl;//输出AB两地之间的最短距离 
	return 0;
}
~~~

---

## 作者：AcerMo (赞：2)

楼下代码略长，而且貌似这边没有STL党，STL大法好233
思路相近，只不过是在SPFA过程中，判断一下两点之间路径是否完好
代码
```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=1500;
struct edge
{
    int to,cost;
}now;
vector<edge>v[M*2];
int n,m,d,st,ed;
int dis[M],jud[M][M],vis[M];
void SPFA()
{
    fill(dis,dis+n+1,M<<5);
    queue<int>q;
    q.push(st);dis[st]=0;
    while (q.size())
    {
        int u=q.front();
        q.pop();vis[u]=0;
        for (int i=0;i<v[u].size();i++)
        {
            int go=v[u][i].to;
            int pay=v[u][i].cost;
            if (!jud[u][go]||!jud[go][u]) pay=0;
            if (dis[go]>dis[u]+pay) 
            {
                dis[go]=dis[u]+pay;
                if (!vis[go])
                {
                    vis[go]=1;q.push(go);
                }
            }
        }
    }
    return ;
}
int main()
{
    scanf("%d%d",&n,&m);int a,b,c;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        now.to=b;now.cost=c;v[a].push_back(now);
        now.to=a;now.cost=c;v[b].push_back(now);
    }
    scanf("%d",&d);
    for (int i=1;i<=d;i++)
    {
        scanf("%d%d",&a,&b);jud[a][b]=jud[b][a]=1;
    }
    scanf("%d%d",&st,&ed);
    SPFA();cout<<dis[ed];
    return 0;
}
```

---

## 作者：_Blue_ (赞：2)

### 这是道模板题 ~~可我还是WA了好几次~~
这里用的是**SPFA**，因为数据很水。  
具体思路就是**SPFA+暴力**（雾  
观察题目可知，我们要求的是A到B**修复路径**的最短路，而不是A到B的最短路。  
也就是说，不要**修复的道路的长皆为0**  
  
------------
#### 贴代码（码风奇怪且丑 ： 
```cpp
#include <bits/stdc++.h>
using namespace std;
int v[1100],d[1100];
int last[1100];
struct bian{
	int x,y,c,next;
}a[110000];
int len,n,m,s;
int need[1100][1100];
queue<int >q;
void ins(int x,int y,int c){   //建边
	len++;
	a[len].x=x;a[len].y=y;a[len].c=c;
	a[len].next=last[x];last[x]=len;
}
void spfa(int u){
	d[u]=0;v[u]=1;q.push(u);
	while(!q.empty()){
		int x=q.front();
        q.pop();
        v[x]=0;
		for(int k=last[x];k;k=a[k].next){
			int y=a[k].y;
			if(d[y]>d[x]+a[k].c){
				d[y]=d[x]+a[k].c;
				if(!v[y]) q.push(y),v[y]=1;
			}
		}
	}
}
int read(){    //萌新式快读
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}
int main(){
	memset(d,9999999,sizeof(d));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){   //先读入边
		int x=read();
		int y=read();
		int c=read();
		ins(x,y,c);
		ins(y,x,c);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){    //need[]存储需要修建的边
		int x=read();
		int y=read();
		need[x][y]=1;
		need[y][x]=1;
	}
	for(int i=1;i<=len;i++){   //不要修复的边长为0
		int x=a[i].x;
		int y=a[i].y;
		if(!need[x][y]) a[i].c=0;
	}
	int x=read();
	int y=read();
	spfa(x);
	printf("%d",d[y]);  
   	return 0;
}
```    
**一个细节**  
这是双向边！记得要建两条边，否则30pt警告  
~~我就在这里卡了一下~~  
这个蒟蒻很弱，他没什么好说的。


---

## 作者：Celebrate (赞：1)

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int list[210];//现在的位置 
int head,tail;//头和尾 
int a[110][110],b[110][110],d[110];//a[x][y]，x到y的距离；b[x][y],x到y需要修建的路的长度；d[i]表示A到x最小需要修多少路 
bool v[110];//v[x]表示x这个点是否在list数组里面 
int n,m,A,B;
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		memset(list,0,sizeof(list));
		int i,j,x,y,c;
		memset(a,127,sizeof(a));
		memset(b,127,sizeof(b));//初始化 
		for(i=1;i<=m;i++)
		{
			scanf("%d%d%d",&x,&y,&c);
			if(c<a[x][y])
			{
				a[x][y]=c;//建立边 
				a[y][x]=c;//建立返向边 
				b[x][y]=0;//一开始能联通的为0 
				b[y][x]=0;
			}
		}
		int tt;scanf("%d",&tt);
		while(tt--)
		{
			scanf("%d%d",&x,&y);
			b[x][y]=a[x][y];//这条路已经被摧毁 
			b[y][x]=a[y][x];
		}
		scanf("%d%d",&A,&B);
		memset(d,127,sizeof(d));d[A]=0;//A到A修建0 
		memset(v,false,sizeof(v));v[A]=true; //存进list[1]之中 
		list[1]=A;head=1;tail=2;//初始化list[1] 
		while(head!=tail)
		{
			x=list[head];//记录 
			for(y=1;y<=n;y++)
			{
				if(d[y]>d[x]+b[x][y] && b[x][y]<=1000)//不断的搜寻 
				{
					d[y]=d[x]+b[x][y];//取最优值 
					if(v[y]==false)//如果没有存入list的话 
					{
						v[y]=true;
						list[tail]=y;
						tail++;if(tail==n+1) tail=1;//防止爆内存，宽搜时用这个很有效 
					}
				}
			}
			list[head]=0;//清0 
			head++;if(head==n+1) head=1;//同上 
			v[x]=false;
		}
		printf("%d\n",d[B]);//输出 
	}
	return 0;
}
```

---

## 作者：blackbeanman (赞：1)

看这么小的数据范围却没有Floyd的题解，发一个


            
    

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[110][110];
int t[110][110];
int i,j,k,n,m,s,tt,p1,p2,p3,d;
int main()
{
    cin>>n;    //n个城市 
    cin>>m;//m条道路 
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)//初始化 
        {
            t[i][j]=99999999;
            a[i][j]=99999999;        //t[i][j]储存可以调用的道路信息 
        }
    for(i=1;i<=m;i++)
    {
        cin>>p1>>p2>>p3;
        t[p1][p2]=p3;
        t[p2][p1]=p3;//双向边 
        a[p1][p2]=0;
        a[p2][p1]=0;//有路先默认是好的 
    }
    cin>>d;
    for(i=1;i<=d;i++)
    {
        cin>>p1>>p2;
        a[p1][p2]=t[p1][p2];//炸毁了的是长度，没有路的是inf，不用修的是0 
        a[p2][p1]=t[p2][p1]; 
    }
    cin>>s>>tt;
    for(k=1; k<=n; k++)
        for(i=1; i<=n; i++)
            for(j=1; j<=n; j++)
                if (a[i][k]+a[k][j]<a[i][j]) a[i][j]=a[i][k]+a[k][j];
    //floyd板子 
    cout<<a[s][tt];
    return 0;
}

```

---

## 作者：war1111 (赞：1)

P3905 道路重建

我一开始想错了，我的是类似kruskal，把毁坏的边从小到大加，并且判断联通性。但是这有一个问题，你可能会多加，就是这条边没用，但是它比较小，你也加上了。

居然还有10分，数据也是水水的。。。

正解是把未坏的边的权值设成0，坏的边的值不变，跑spfa即可。

http://www.cnblogs.com/war1111/p/7645929.html

标程在blog里。


---

## 作者：CrazyDance (赞：0)

## [~~传送门~~](https://www.luogu.org/problem/P3905)

### 这是一个最短路的应用题~~一眼下去以为是生成树~~

这题的解法就是把所有坏掉的路径边权保留，把完好的路径边权赋为0。

为何？

因为这题只让我们求 $A$ 到 $B$ 之间 **修复的道路长度**

所以我们就把边权改了，再跑一遍最短路就行了。

由于这题数据过小：$2<n≤100$ 跑 $Floyd$ 是可以的。如果某些同学认为 $SPFA$ 和 $Dijkstra$ 比较直观，也可以选择使用。

不废话了，上代码（代码里有注解）：

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#define inf 0x3f3f3f
#define N 110
using namespace std;
struct note
{
    int to,val,next;
}t[N*N];
queue<int> q;//经典队列
bool vis[N],v[N*N];
int head[N],cnt=0,dis[N],n,m,curr,w[N][N],s,e;
void add(int a,int b,int c)
{
    t[++cnt].to=b;
    t[cnt].next=head[a];
    t[cnt].val=c;
    head[a]=cnt;
    w[a][b]=cnt;//记录a和b之间的边的编号
}
int main()
{
    memset(dis,inf,sizeof dis);
    memset(vis,0,sizeof vis);
    memset(v,1,sizeof v);//开始定义所有路径都是完好无损的 
    scanf("%d\n%d",&n,&m);
    for (int i=1,a,b,c;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    int T;
    scanf("%d",&T);
    for (int x,y,z1,z2;T--;)
    {
    	scanf("%d%d",&x,&y);
		z1=w[x][y];//方便存储 
		z2=w[y][x];//同上 
		v[z1]=v[z2]=0;//两条边都损坏了
	}
	for (int i=1;i<=m*2;i++) if (v[i]) t[i].val=0;//最重要的一步：把标记完好的边边权赋为0
	//————————————————————以下是经典SPFA———————————————————————— 
	scanf("%d%d",&s,&e);
    q.push(s);//入队
    dis[s]=0;
    vis[s]=1;
    for (;!q.empty();)//如果队列里还有数
    {
    	curr=q.front();//取队首
    	q.pop();
        vis[curr]=0;
        for (int i=head[curr];i;i=t[i].next)//链式前向星搜边
        {
            if (dis[t[i].to]>dis[curr]+t[i].val)//更新
            {
            	dis[t[i].to]=dis[curr]+t[i].val;
            	if (!vis[t[i].to])//入队
				{
					q.push(t[i].to);
            		vis[t[i].to]=1;
            	}
            }
        }
    }
    printf("%d",dis[e]);
    return 0;
}
```

---

## 作者：飞雪连天 (赞：0)

看了一下，没有
# SPFA+堆
的题解，那我就来一篇；

关于SPFA+堆，他让SPFA又活了过来。

本题思想：跑两边SPFA，其中第二遍是把拆掉的路的权值设为0；

以下是AC代码：


------------

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#define M(x,y) make_pair(x,y)//作用等于重载运算符
const int maxn=108;
const int maxm=5008;
using namespace std;
int n,m,d,s,end,a,b,c,dis[maxn],vis[maxn],head[maxm],num_edge=0,x[maxm],y[maxm];
struct Edge{
	int next,to,dis;
}edge[maxm];
priority_queue < pair<int,int> > q;//小根堆，一定要设成pair！！！
void addedge(int from,int to,int dis)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].to=to;
	edge[num_edge].dis=dis;
	head[from]=num_edge;
}
void SPFA()
{
	for(int i=1;i<=n;++i)//初始化
	{
		dis[i]=1e10;
		vis[i]=0;
	}
	q.push(M(0,s));
	vis[s]=1;
	dis[s]=0;
	while(!q.empty())
	{
		int u=q.top().second;//直接求出目前dis的最小值
		q.pop();
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].dis)
			{
				dis[v]=dis[u]+edge[i].dis;
				if(vis[v]==0)
				{
					vis[v]=1;
					q.push(M(-dis[v],v)); //作用等于重载运算符，小根堆，加入-dis[v]
				}
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	scanf("%d",&m);
	for(int i=1;i<=m;++i)
	{
		scanf("%d %d %d",&a,&b,&c);
		addedge(a,b,c);
		addedge(b,a,c);//不要忘了是无向图
	}
	scanf("%d",&d);
	for(int i=1;i<=d;++i)
	{
		scanf("%d %d",&x[i],&y[i]);
	}
	scanf("%d %d",&s,&end);
	SPFA();
	int ans1=dis[end];//处理前的最短路
	for(int i=1;i<=d;++i)
	{
		addedge(x[i],y[i],0);
		addedge(y[i],x[i],0);//不要忘了是无向图++
	}
	SPFA();
	int ans2=dis[end];//处理后的最短路
	printf("%d",ans1-ans2);
	return 0;
}
```
时空：

![](https://cdn.luogu.com.cn/upload/pic/42342.png)

---

## 作者：七喜 (赞：0)

1.审题：这道题明显是最短路;

2.选择算法：由于数据比较小，~~而且看起来比较水(似乎暴露了我在水这件事)~~，所以SPFA，Dijkstra，Floyd都可以用;

下面给出三种方法的代码，以及一些注意事项;

### 1.SPFA（不建议在没有负边权的时候用）
```c
#include<bits/stdc++.h>
using namespace std;

int n,m;
int d;
int c[118][118],Min[118];
bool xc[118][118],vis[118];

void SPFA(int st){
	queue<int> q;
	q.push(st); Min[st]=0; vis[st]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		vis[x]=0;
		for(int i=1;i<=n;i++)
			if(Min[i]>Min[x]+c[i][x])
			{
				Min[i]=Min[x]+c[i][x];
				if(!vis[i]) {vis[i]=1;q.push(i);}
			}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	memset(c,0x7f7f7f,sizeof(c));
	memset(Min,0x7f7f7f,sizeof(Min));
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		xc[u][v]=xc[v][u]=1;
		c[u][v]=c[v][u]=w;
	}
	scanf("%d",&d);
	for(int i=1;i<=d;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		xc[u][v]=xc[v][u]=0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(xc[i][j]) c[i][j]=c[j][i]=0;
	int a,b;
	scanf("%d%d",&a,&b);
	SPFA(a);
	printf("%d\n",Min[b]);
	return 0;
}
```
SPFA注意要判断那条边有没有在队列里面;
### 2.Dijkstra
```c
#include<bits/stdc++.h>
using namespace std;

typedef pair<int,int> PI;
int n,m,a,b,d;
int Min[118],c[118][118];
bool vis[118],xc[118][118];

void dijkstra(int st){
	priority_queue<PI,vector<PI>,greater<PI> >q;//建小根堆,当然如果使用大根堆poirority_queue<PI>q存入时取负数也可以;
	q.push(PI(0,st)); Min[st]=0;
	while(!q.empty())
	{
		int x=q.top().second;q.pop();
		if(vis[x]) continue; vis[x]=1;
		for(int i=1;i<=n;i++)
			if(Min[i]>Min[x]+c[i][x])
			{
				Min[i]=Min[x]+c[i][x];
				q.push(PI(Min[i],i));
			}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	memset(c,0x7f7f7f,sizeof(c));
	memset(Min,0x7f7f7f,sizeof(Min));
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		xc[u][v]=xc[v][u]=1;
		c[u][v]=c[v][u]=w;
	}
	scanf("%d",&d);
	for(int i=1;i<=d;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		xc[u][v]=xc[v][u]=0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(xc[i][j]) c[i][j]=c[j][i]=0;
	scanf("%d%d",&a,&b);
	dijkstra(a);
	printf("%d\n",Min[b]);
	return 0;
}
```
1.Dijkstra注意要附初值，Min[st]=0;

2.要开pair，要开pair，要开pair，重要的事情说三遍！！！
### 3.Floyd
```c
#include<bits/stdc++.h>
using namespace std;

int n,m,a,b,d;
int c[118][118];
bool xc[118][118];

int main(){
	scanf("%d%d",&n,&m);
	memset(c,0x3f3f3f3f,sizeof(c));//这里注意不要溢出，开0x7f7f7f会溢出！！！
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		xc[u][v]=xc[v][u]=1;
		c[u][v]=c[v][u]=w;
	}
	scanf("%d",&d);
	for(int i=1;i<=d;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		xc[u][v]=xc[v][u]=0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(xc[i][j]) c[i][j]=c[j][i]=0;
	scanf("%d%d",&a,&b);
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(c[i][k]+c[k][j]<c[i][j]) c[i][j]=c[i][k]+c[k][j];
	printf("%d\n",c[a][b]);
	return 0;
}
```
1.所有的附初值都要注意不要溢出！

2.如果使用链式向前星要开两倍边！

3.貌似去边还有dalao的方法比我的更周到，所以本题解仅供参考！

---

## 作者：ShineEternal (赞：0)

# 题目：https://www.luogu.org/problemnew/show/P3905

# 分析：
此题是显然的最短路算法，只是看到一起删掉的一堆边感到~~十分~~棘手，而且还要求出的是最短添加边的总长度

但如果仔细观察就可以发现，我们其实并不用一个一个的全部枚举，只需要把添加的边做最短路就行了。

我们可以首先把数组初始化为一个较大的数，然后每读入一条边，就把此边的权值记录，但还要把它清零。

为什么呢？

因为我们清零相当于不考虑此边的权值，但又可以经过这条边，有效的能保留下删去的边，来仅仅考虑被删边的最短路。

然后读入删掉的边，这时候我们把那些删去的边赋上原来的权值，进行计算即可。

what？这不就是最短路模板吗？

## 还有呢？

注意到数据范围，

$n\leq100$?

不就是Floyd常见的数据范围吗？

于是floyd都往上套了。。。

于是此题经过转换，就成为了一个可用Floyd，dijkstra，spfa等多种最短路算法解决的板子题了。。。

# 下面给出[Floyd代码：](https://blog.csdn.net/kkkksc03/article/details/83588613)

关于其他的做法，请到https://blog.csdn.net/kkkksc03
，
以查看更多做法

---

## 作者：Jith_2004 (赞：0)

[P3905 道路重建](https://www.luogu.org/problemnew/show/P3905)

	看到题解里有好多很好的想法，如把未损坏的路的权赋为0等。

但我们也可以先开一个prev数组，再跑一遍Dijkstra，用prev数组记录每条单源最短路径的节点的前趋，这样就能在
****O(|E|)****的时间内进行****路径还原****。最后在路径还原的过程中统计损坏的道路的权的和，输出就行了。~~（但我本人感觉这个带一点贪心的算法不是正解）~~

代码如下：
```cpp
	#include <bits/stdc++.h>
	using namespace std;
	const int MAXN=1000;
	int cost[MAXN+2][MAXN+2],prev[MAXN+2];
	int n,m,t,a,b,d[MAXN+2];
	bool bl[MAXN+2],bre[MAXN+2][MAXN+2];
    
	void dijk(){ Dijkstra大法好
		d[a]=0;
		while(1){
			int v=-1;
			for(int u=1;u<=n;++u)
				if(!bl[u] && (v==-1 || d[v]>d[u])) v=u;
				if(v==-1) break;
        		bl[v]=1;
        		for(int u=1;u<=n;++u){
            		if(d[u]>d[v]+cost[v][u]){
                		prev[u]=v;  //**记录每个节点的前趋**
                		d[u]=d[v]+cost[v][u];
            		}
        		}
    	}
	}

	int main(){
    	memset(d,0x7f,sizeof(d));
    	memset(cost,0x7f,sizeof(cost));
    	memset(prev,-1,sizeof(prev)); //千万别忘了初始化
    	cin>>n>>m;
    	for(int i=1;i<=m;++i){
        	int x,y,z;
        	cin>>x>>y>>z;
        	cost[x][y]=cost[y][x]=z;
    	}
    	cin>>t;
    	for(int i=1;i<=t;++i){
        	int x,y;
        	cin>>x>>y;
        	bre[x][y]=bre[y][x]=1;
    	}
    	cin>>a>>b;
    	dijk();
    	int now=b,ans=0;
    	for(;prev[now]!=-1;now=prev[now]) //路径还原
        	if(bre[now][prev[now]]==1) ans+=cost[prev[now]][now];
    	cout<<ans<<endl;
    	return 0;
	}
```

---

## 作者：heaven燕过留痕 (赞：0)

楼下都是dalao啊，让本蒟蒻~~看都看不懂~~瑟瑟发抖

刚看到这道题思路也是与楼下相似，将未被破坏的道路边权赋为0。但在如何将未被破坏道路赋0的问题上，我用了**两个二维矩阵**：gragh0与gragh。gragh0初始为0，gragh初始为正无穷，输入所有道路时gragh0与gragh都被赋值，在输入被破坏道路时将对应gragh0赋为0，最后**用gragh的对应值减去gragh0的对应值**，就得到了我们想要的图，再加上SPFA大法就AC了

**Talk is cheap show me the code.**



------------


```
#include <iostream>
#include <queue>
#define MAX 105
#define INF 10005

using namespace std;
int v,e,v1,v2,w,a,b,dis[MAX],gragh0[MAX][MAX],gragh[MAX][MAX],d;
bool visit[MAX];
void init()
{
    for(int i=1;i<=v;i++)
    {
        for(int j=1;j<=v;j++)
            gragh[i][j]=INF;
        gragh[i][i]=0;
        dis[i]=INF;
    }

}
void create_gragh()
{
    for(int i=1;i<=e;i++)
    {
        cin>>v1>>v2>>w;
        gragh0[v1][v2]=gragh0[v2][v1]=w;
        gragh[v1][v2]=gragh[v2][v1]=w;
    }
    cin>>d;
    for(int i=1;i<=d;i++)
    {
        cin>>v1>>v2;
        gragh0[v1][v2]=gragh0[v2][v1]=0;
    }
    for(int i=1;i<=v;i++)
        for(int j=1;j<=v;j++)
            gragh[i][j]-=gragh0[i][j];
            /*两个数组相减，因为被破坏道路的gragh0被清零，
            所以gragh中的被破坏道路还是原样
            而gragh0中的未被破坏道路未被清零
            所以gragh与gragh0中的未被破坏道路相互抵消，边权变为0*/
}
void spfa(int s)
{
    queue<int> q;
    q.push(s);
    dis[s]=0;
    visit[s]=true;
    while(!q.empty())
    {
        int index=q.front();
        q.pop();
        visit[index]=false;
        for(int i=1;i<=v;i++)
        {
            if(dis[i]>dis[index]+gragh[index][i])
            {
                dis[i]=dis[index]+gragh[index][i];
                if(!visit[i])
                {
                    q.push(i);
                    visit[i]=true;
                }
            }
        }
    }
}
int main()
{
    cin>>v>>e;
    init();
    create_gragh();
    cin>>a>>b;
    spfa(a);
    cout<<dis[b]<<endl;
}

```

---

## 作者：AugustineYang (赞：0)

根据题意说明，从A城市到B城市，国王不在乎通过了多远的**未损坏**的道路，只在乎“通过”了多远的**损坏**的道路。因此**未损坏**的道路的长度对于最终的答案并没有影响，记为0，而**损坏**的道路保留原长，再跑最短路。这里同时放了堆优化Dijkstra的 和 SLF优化SPFA的代码。
```cpp
#include <cstdio>
#include <string>
#include <cstring>
#include <queue>
#define MAXN 105
#define MAXM 10005
using namespace std;
int n, m, d, num_edge, start, finish;
int head[MAXN]; //数组模拟邻接表的head数组 
int dis[MAXN]; //一个点到起点的距离 
bool in_queue[MAXN]; //SPFA时记录元素是否在队列中 
struct add
{
	int next, to, len_temp, len; //len_temp临时记录长度 
	bool broken; //损坏的道路记为1，未损坏的记为0 
}edge[MAXM];
struct node
{
	int num, d; //dijkstra中记录队列中一个元素的编号和它对应的dis 
	bool operator <(const node& temp)const
	{
		return d>temp.d; //优先队列优化dijkstra时的重载运算符 
	}
};
inline int read() //快读 
{
	int sum = 0;
	char c = getchar();
	while(!isdigit(c)) c = getchar();
	while(isdigit(c))
	{
		sum = (sum<<3)+(sum<<1)+(c&15);
		c = getchar();
	}
	return sum;
}
inline void add_edge(int from, int to, int len_temp) //数组模拟邻接表 加边 
{
	edge[++num_edge].to = to;
	edge[num_edge].next = head[from];
	edge[num_edge].len_temp = len_temp; 
	head[from] = num_edge;
}
inline void update_edge(int from, int to) //更改路径长度 
{
	for(int i=head[from]; i; i=edge[i].next) //遍历查找损坏道路所对应的编号 
		if(edge[i].to == to) 
		{
			edge[i].broken = 1;
			edge[i].len = edge[i].len_temp;
			return;
		}
}
inline void dijkstra(int s)
{
	memset(dis, 127, sizeof dis); //将dis数组赋予极大值 
	dis[s] = 0;
	priority_queue<node> q;
	q.push((node){s, 0});
	while(!q.empty())
	{
		node temp = q.top(); q.pop();
		int u = temp.num;
		if(dis[u] != temp.d) continue; 
		for(int i=head[u]; i; i=edge[i].next)
		{
			int v = edge[i].to;
			if(dis[v] > dis[u]+edge[i].len)
			{
				dis[v] = dis[u]+edge[i].len;
				q.push((node){v, dis[v]});
			}
		}	
 	}
}
inline void spfa(int s)
{
	memset(dis, 127, sizeof dis);
	dis[s] = 0;
	deque<int> q;
	q.push_back(s);
	in_queue[s] = 1;
	while(!q.empty())
	{
		int u = q.front(); q.pop_front();
		in_queue[u] = 0;
		for(int i=head[u]; i; i=edge[i].next)
		{
			int v = edge[i].to;
			if(dis[v] > dis[u]+edge[i].len)
			{
				dis[v] = dis[u]+edge[i].len;
				if(!in_queue[v])
				{
					if(!q.empty() && dis[v]<dis[q.front()])
						q.push_front(v);
					else q.push_back(v); //SLF优化SPFA 
					in_queue[v] = 1;
				}
			}
		}
	}	
}
int main()
{
	n = read(), m = read();
	for(int i=1; i<=m; ++i)
	{
		int x = read(), y = read(), z = read();
		add_edge(x, y, z); //道路是双向的 
		add_edge(y, x, z);
	}
	d = read();
	for(int i=1; i<=d; ++i)
	{
		int x = read(), y = read();
		update_edge(x, y); //将损坏的道路长度更新为原长 
		update_edge(y, x); //由于是双向边，因此两个方向均要更新 
	}
	for(int i=1; i<=n; ++i)
		for(int j=head[i]; j; j=edge[j].next)
			if(!edge[j].broken) edge[j].len = 0; //遍历，将未损坏的道路长度赋予为0 
	start = read(), finish = read();
	//dijkstra(start);
	spfa(start);
	printf("%d\n", dis[finish]);
	return 0;	
}

```

---

## 作者：yy1695651 (赞：0)

### 此题要把没有被破坏的道路的距离看做0，再用spfa算法计算重要城市两点间距离！ 
#### 利用前向心存储路径
代码如下
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define N 100 + 10
#define M 5000 + 10
using namespace std;
int n, m, p[N], e_num, bomb, start, _end, dist[N];
bool bad[N][N], fg[N];

//前向心储存路径
struct Edge
{
    int b, nt, w;
}e[M];

//前向心添加路径
void add(int x, int y, int z)
{
    e_num++;
    e[e_num].b = y;
    e[e_num].w = z;
    e[e_num].nt = p[x];
    p[x] = e_num;
}

void spfa(int x)
{
    queue<int> q;
    dist[x] = 0;
    fg[x] = true;
    q.push(x);
    while(!q.empty())
    {
        x = q.front();
        q.pop();
        fg[x] = false;
        int edge = p[x];
        while (edge > 0)
        {
            int t = e[edge].b;
            if (!bad[x][t]) e[edge].w = 0;
            if (dist[t] - dist[x] > e[edge].w)
            {
                dist[t] = dist[x] + e[edge].w;
                if (!fg[t])
                {
                    fg[t] = true;
                    q.push(t);
                }
            }
            edge = e[edge].nt;
        }
    }
}

int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        scanf("%d %d %d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }
    scanf("%d", &bomb);
    for (int i = 0; i < bomb; i++)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        bad[a][b] = true;
        bad[b][a] = true;
    }
    memset(dist, 127, sizeof(dist));
    //memset赋127是memset可赋的最大值
    scanf("%d %d", &start, &_end);
    spfa(start);
    printf("%d", dist[_end]);
    return 0;
}

```

---

## 作者：yjxyjx (赞：0)

~~这题的题面写得极其恶心，让我等蒟蒻明白：原来题面这么写不犯法，将来一定要把这垃圾题目用来恶心一下别人233~~

因为这几天脑子不怎么够用，所以看题解的次数很多，~~（因为做贼心虚还问了一下管理这个犯不犯法。。~~

好了说正文：

列一下坑点：

1. 这题的边是无向边，存图的时候记得[x][y]和[y][x]都要存；

2. 这题是让你确定哪些边需要修补，不是让你加哪些边（可能是我智商低dalao请忽略）

3. 这个点有些抽象也不容易想到：我们可以将边分为以下三种
       1. 炸毁了的是长度
       2. 没有路的是inf
       3. 不用修的是0 
   （这个东西不是我想出来的，是之前发题解的大佬想出来的）
   
最后，代码献上，但请自备草稿纸算一下：

```
#include<bits/stdc++.h>

const int MaxN = 100 + 10;
const int oo = 0x3f3f3f3f;

int n, m, Start, End;
int Dist[MaxN][MaxN], Weight[MaxN][MaxN];
/*这里变量名大写是因为：怕和某些关键字重名*/
void Init() {
    for (int i = 0; i <= n + 3; ++i) {
        for (int j = 0; j <= n + 3; ++j) {
            (i != j) ? Dist[i][j] = oo : Dist[i][j] = 0;
        }
    }
}

void Floyd() {
    for (int k = 1; k <= n; ++k) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                Dist[i][j] = std::min(Dist[i][j], Dist[i][k] + Dist[k][j]);
            }
        }
    }
}

void debug1() {
    for (int i = 0; i <= n + 3; ++i) {
        for (int j = 0; j <= n + 3; ++j) {
            std::cerr << Dist[i][j] << "   ";
        }
        std::cerr << "\n";
    }
    std::cerr << "\n\n";
}

int main() {
    std::cin >> n >> m;

    Init();

    for (int i = 1; i <= m; ++i) {
        int x, y, k;
        /* x：起点，y：终点，k：权值 */
        std::cin >> x >> y >> k;
        /*下面这里(Weight)反着也要来，因为不用的话，
          Weight数组只有斜着的一半（这个不好说请自己算一下）*/
        Weight[x][y] = Weight[y][x] = k;
        Dist[x][y] = Dist[y][x] = 0;
    }
    // debug1();

    
    int D;
    std::cin >> D;
    for (int i = 1; i <= D; ++i) {
        int x, y;
        std::cin >> x >> y;
        Dist[x][y] = Dist[y][x] = Weight[x][y];
    }
    // debug1();

    std::cin >> Start >> End;

    Floyd();

    std::cout << Dist[Start][End];
    return 0;
}

```

~~现在以一天一题的速度蹒跚前行，颓啊~~

---

## 作者：jiangzhiou (赞：0)

看到没人用优先队列，鄙人不才，就来一个吧。

大致思路是把所有的路径输入进去，把没炸掉的路的权值赋为0，炸掉的路权值不变，然后就按照解决最短路径的方法来就行咯~

具体代码如下（会有详细注释）：

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
struct sd{
    int num,d;//记录点和对应的距离
    bool operator < (const sd &x) const//重载预算符，作用大致为d越小结构体的值越大（优先队列要用）
    {
        return x.d<d;
    }
};
bool pan[200][200];//判断两个城市间有没有路被炸掉
int dist[10000];//点到初始点的位置
bool vis[10000];//点是否被走过
vector<sd>mp[10000];//mp[I][j]表示I到num的距离为d
priority_queue<sd>hhh;//结构体的值越大位置越靠近首位置
int main()
{
    memset(dist,127,sizeof(dist));//将初值赋为很大
    int m,n;//城市数与道路数
    scanf("%d%d",&m,&n);
    sd w;
    for(int a,b,c,i=1;i<=n;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        w.num=b;w.d=c;mp[a].push_back(w);//记录a到b的权值c，注意是无向图
        w.num=a;mp[b].push_back(w);
        pan[a][b]=true;//两个城市有路连接
        pan[b][a]=true;
    }
    int d;
    scanf("%d",&d);
    for(int a,b,i=1;i<=d;i++)
    {
        scanf("%d%d",&a,&b);
        pan[a][b]=false;//断掉
        pan[b][a]=false;
    }
    for(int i=1;i<m;i++)//找已连接的路
    {
        for(int j=i+1;j<=m;j++)
        {
            if(pan[i][j])//如果有连接
            {
                for(int k=mp[i].size()-1;k>=0;k--)
                {
                    if(mp[i][k].num==j)
                    {
                        mp[i][k].d=0;//权值变为0
                    }
                }
                for(int k=mp[j].size()-1;k>=0;k--)
                {
                    if(mp[j][k].num==i)
                    {
                        mp[j][k].d=0;//权值变为0
                    }
                }
            }
        }
    }
    int start,end;
    scanf("%d%d",&start,&end);//记录起始点与指定点
    vis[start]=true;//第一个点记录为走过
    int ans=0;
    for(int j=mp[start].size()-1;j>=0;j--)
    {
        if(dist[mp[start][j].num]>mp[start][j].d)
        {
            dist[mp[start][j].num]=mp[start][j].d;//调整最短路径
        }
        hhh.push(mp[start][j]);//装路径
    }
    while(true)
    {
        int k;
        while(true)
        {
            k=hhh.size();
            if(k==0) break;//如果队列中元素没了，弹出
            w=hhh.top();//访问队首元素，这时的路径是最短的
            hhh.pop();//弹出队首元素
            if(!vis[w.num]) break;//如果这个点没被走过，进行接下来的操作
        }
        if(k==0||vis[end]) break;//如果指定点已被走过或者队中没有元素，终止操作
        k=w.num;//记录当前点
        vis[k]=true;//记录成走过
        for(int j=mp[k].size()-1;j>=0;j--)
        {
            int t=mp[k][j].num;
            if(!vis[t]&&dist[t]>mp[k][j].d+dist[k])//三角定则不多说
            {
                dist[t]=mp[k][j].d+dist[k];
                w.num=t;
                w.d=dist[t];
                hhh.push(w);//把新的路径装进队列
            }
        }
    }
    printf("%d",dist[end]);//输出到指定点的最短路径
    return 0;
}
```

---

## 作者：wddwjlss (赞：0)

//这道题是一道比较简单的最短路问题，所以真正的蒟蒻来发题解了，由于本蒟蒻刚刚学会spfa

```cpp
//就用spfa写了这道题 
#include<bits/stdc++.h>
using namespace std;
const int maxn=500010;
struct Edge
{
    int next,to,dis;
}edge[maxn];
int head[maxn],num_edge,n,m;
int dis[maxn];
int x1[500000],yy[500000];
bool inqueue[maxn];
void add_edge(int from,int to,int dis)
{
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    edge[num_edge].dis=dis;
    head[from]=num_edge;
```
}//数组模拟邻接表存图
```cpp
void SPFA(int start)
{
    int i;
    queue<int> q;//这里使用了STL库中的队列 
    for(i=1;i<=n;i++)
    dis[i]=2147483647;
    dis[start]=0;
    q.push(start);//初始化 
    while(!q.empty())//队列不为空时循环 
    {
        int x=q.front();
        q.pop();
        inqueue[x]=false;//inqueue为标记数组，标记是否在队中 
        for(i=head[x];i!=0;i=edge[i].next) //遍历队首连出的所有边 
            if(dis[edge[i].to]>dis[x]+edge[i].dis)//松弛 
            {
                dis[edge[i].to]=dis[x]+edge[i].dis;           
                if(!inqueue[edge[i].to])
                {
                    inqueue[edge[i].to]=true;
                    q.push(edge[i].to);//新点入队 
                }
            }
    }
}
int main()
{
    int i;
    int x,y,z;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add_edge(x,y,z);    
        add_edge(y,x,z);    
```
}//读入，注意是无向图 ，本蒟蒻一开始没注意只得了20分
```cpp
    int d;
    cin>>d;
    for(i=1;i<=d;i++)
        scanf("%d%d",&x1[i],&yy[i]);
    int A,B;
    cin>>A>>B;
    SPFA(A);//我们一开始先在没有损坏的路上跑一遍spfa 
    int orz=dis[B];//记录A到B的最短路 
    for(i=1;i<=d;i++)
    {
        add_edge(x1[i],yy[i],0);
        add_edge(yy[i],x1[i],0);
    }//    这条路损坏了我们就把它的权值附成0 
    SPFA(A);//我们再在损坏的路上跑一遍spfa 
    int sro=dis[B];//记录损坏后A到B的最短路 
    orz=orz-sro;//两者的差值就是结果啦 
    printf("%d ",orz);
    return 0;
}
```

---

## 作者：Tramis (赞：0)

我们可以

先memset dis这个数组全部搞成正无穷

在录入边的时候顺手把dis搞成0并且开一个mapp记录边的权值

再在删边的时候顺手把dis更新成mapp记录的权值

最后floyed就可以了√

(dalao们都是0ms ac蒟蒻表示害怕...难道是floyed的原因？)


    
    
    
    
    
    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=120;
const int inf=0x7fffffff;
int mapp[N][N];
int dis[N][N];
int n,m,a,b,c;
int main(){
    memset(mapp,63,sizeof(mapp));
    memset(dis,63,sizeof(dis));
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)    mapp[i][j]=inf;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d %d %d",&a,&b,&c);
        mapp[a][b]=mapp[b][a]=min(mapp[b][a],c);
        dis[a][b]=dis[b][a]=0;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        scanf("%d %d",&a,&b);
        dis[a][b]=dis[b][a]=mapp[a][b];
    }
    scanf("%d %d",&a,&b);
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]);
    cout<<dis[a][b];
    return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：0)

看了，好像没有 Floyd 的题解，来一发。。。

思路的话，与楼上差不多。。。

重点是，我用邻接表存图，结果因为一个细节，20分\*3。。。

附代码（丑陋无比。。。）：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAX 999999999//最大值
#define MAXN 110
using namespace std;
int n,m,d,s,t,a[MAXN][MAXN];
bool b[MAXN][MAXN];//道路是否被摧毁
inline int read(){//读优
       int date=0,w=1;char c=0;
       while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
       while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
       return date*w;
}
void floyd(){//Floyd 跑最短路，应该都懂吧。。。
     for(int k=1;k<=n;k++)
     for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
     a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
     printf("%d\n",a[s][t]);
}
int main(){
    int u,v,w;
    n=read();m=read();
    for(int i=1;i<=n;i++)//赋初值
    for(int j=1;j<=n;j++)
    a[i][j]=(i==j)?0:MAX;
    for(int i=1;i<=m;i++){//读入边
            u=read();v=read();w=read();
            if(a[u][v]>w)a[u][v]=a[v][u]=w;//双向边
            }
    d=read();
    for(int i=1;i<=d;i++){//读入被摧毁的边
            u=read();v=read();
            b[u][v]=b[v][u]=true;//当初就是因为这里，没有考虑到边是双向的，WA 了3次。。。
            }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    if(!b[i][j]&&a[i][j]!=0&&a[i][j]!=MAX)a[i][j]=0;//未被摧毁的的边权值赋为0
    s=read();t=read();//读入起止点
    floyd();
    return 0;//结束，撒花~~~
}

```

---

## 作者：ars4me (赞：0)

核心思想和楼下差不多 其实我们可以理解成在每次寻找最短路的时候都去维护一个当前的最小花费

需要注意的是 当我们知道当前找的这条边不是被摧毁的边的时候 我们则需要在pay[edge[i].to]和pay[u]中找一个较小的而不用再考虑这条边的长度 大概就是这么个意思

和楼下不一样的是 我是采用的堆优化的dijkstra实现的 链式前向星存储 用了make\_pair(a,b)便于堆的优化 因为按a排 所以a放长度 b放编号 感觉STL确实很实用

另外 按理论说这个题在比较(edge[i].dis + dis[u])和dis[edge[i].to]的大小的时候是要取等号的 但其实都一样

代码如下




        






        
        
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<queue>
#include<cstring>
#include<string>
    using namespace std;
    #define in = read()
    typedef long long ll;
    const ll size = 500000 + 10000;
    const ll size2 = 1000 + 10;
        struct point{   ll next,to,dis;}edge[size];
        priority_queue <pair<ll , ll> , vector<pair<ll , ll> > , greater<pair<ll , ll> > > q;
            ll n,m,d,Beginn,Endd;
            ll site;
            ll head[size],dis[size],pay[size];
            bool exist[size],need[size2][size2];
inline ll read(){
        ll num = 0 , f = 1;   char ch = getchar();
        while(!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while(isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
inline void add(ll x, ll y, ll z){
        edge[++site].next = head[x];
        edge[site].to = y;
        edge[site].dis = z;
        head[x] = site;
}
int main(){
        n in;   m in;
        for(int i=1;i<=m;i++){
                ll x,y,z;   x in;   y in;   z in;
                add(x,y,z);   add(y,x,z);
        }
        d in;
        for(int i=1;i<=d;i++){
                ll x,y;   x in;   y in;
                need[x][y] = need[y][x] = true;
        }
        Beginn in;   Endd in;
        memset(dis,127/3,sizeof(dis));    dis[Beginn] = 0;
        memset(pay,127/3,sizeof(pay));    pay[Beginn] = 0;
        pair<ll , ll> x;
        q.push(make_pair(0,Beginn));
        while(!q.empty()){
                x = q.top();    q.pop();    ll u = x.second;
                if(exist[u])    continue;
                exist[u] = true;
                for(int i=head[u];i!=0;i=edge[i].next)
                        if(edge[i].dis + dis[u] <= dis[edge[i].to]){
                                dis[edge[i].to] = edge[i].dis + dis[u];
                                if(need[u][edge[i].to])
                                        pay[edge[i].to] = min(pay[edge[i].to],edge[i].dis + pay[u]);
                                else
                                        pay[edge[i].to] = min(pay[edge[i].to],pay[u]);
                                q.push(make_pair(dis[edge[i].to],edge[i].to));
                        }
                exist[u] = false;
        }
        printf("%d",pay[Endd]);
}
//coyg
```

---

## 作者：win_or_die (赞：0)

这题看似很难，怎么才能刷出最短的修建道路，其实看出来是非常水的。


下面讲下想法：如何才能输出要修建的最短路呢?大家仔细想下，如果要

刷损坏要修建是不是与没损坏的没有关系，那么我们只需要将没损坏的边

权设为0不就行了？因为加不加0都无所谓，在套下spfa模板刷趟最短路就

行了，听了之后，是不是感觉此题非常水呢~~~~~~~~~~~~~~^0^.


下面给出代码：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn=105,maxe=4955;
int n,m,x[maxe],y[maxe],z[maxe],X,Y,D,son[maxe],lnk[maxe],nxt[maxe],w[maxe],que[maxe],dis[maxe],tot,A,B;
bool vis[maxe],Vis[maxn][maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){f=ch=='-'?-f:f;ch=getchar();}
	while(isdigit(ch)) ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void add_e(int x,int y,int z) {son[++tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;}
void SPFA(){
	memset(dis,63,sizeof(dis));
	que[1]=A;vis[A]=1;dis[A]=0;
	int hed=0,til=1;
	while(hed!=til){
		hed=hed+1;vis[que[hed]]=0;
		for (int i=lnk[que[hed]];i;i=nxt[i]){
			if(dis[que[hed]]+w[i]<dis[son[i]]){
				dis[son[i]]=dis[que[hed]]+w[i];
				if(!vis[i]) {vis[i]=1;til=til+1;que[til]=son[i];}
			}
		}
	}
}
int main(){
	freopen("道路重建.in","r",stdin);
	freopen("道路重建.out","w",stdout);  //头文件，可以不管。
	n=read();m=read();
	for (int i=1;i<=m;i++){
		x[i]=read();y[i]=read();z[i]=read();
		add_e(x[i],y[i],z[i]);add_e(y[i],x[i],z[i]);
	}
	D=read();
	for (int i=1;i<=D;i++){
		X=read();Y=read();
		Vis[X][Y]=1;Vis[Y][X]=1;
	}
	for (int i=1;i<=m;i++){
		if(Vis[x[i]][y[i]]==1) {add_e(x[i],y[i],z[i]);add_e(y[i],x[i],z[i]);}
		else {add_e(x[i],y[i],0);add_e(y[i],x[i],0);}
	}
	A=read();B=read();
	SPFA();
	printf("%d",dis[B]);
	return 0;
} 
```


---


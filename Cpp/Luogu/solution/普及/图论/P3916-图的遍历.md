# 图的遍历

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。

## 说明/提示

- 对于 $60\%$ 的数据，$1 \leq N,M \leq 10^3$。
- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^5$。

## 样例 #1

### 输入

```
4 3
1 2
2 4
4 3```

### 输出

```
4 4 3 4```

# 题解

## 作者：hongzy (赞：629)

### 反向建边 + dfs

按题目来每次考虑每个点可以到达点编号最大的点，不如考虑较大的点可以反向到达哪些点

循环从N到1，则每个点i能访问到的结点的A值都是i

每个点访问一次，这个A值就是最优的，因为之后如果再访问到这个结点那么答案肯定没当前大了

---

思路已经很明晰了，代码实现不难

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

#define MAXL 100010

int N, M, A[MAXL];
vector<int> G[MAXL]; //vector存图 

void dfs(int x, int d) {
	if(A[x]) return; //访问过 
	A[x] = d;
	for(int i=0; i<G[x].size(); i++)
		dfs(G[x][i], d);
}

int main() {
	int u, v;
	scanf("%d%d", &N, &M);
	for(int i=1; i<=M; i++) {
		scanf("%d%d", &u, &v);
		G[v].push_back(u); //反向建边 
	}
	for(int i=N; i; i--) dfs(i, i); 
	for(int i=1; i<=N; i++) printf("%d ", A[i]);
	printf("\n");
	return 0;
}
```

---

## 作者：Stump (赞：124)

```cpp
//萌新不会tarjan和dp
//只会dfs
//有多个点到一个点可以转成一个点到多个点
//所以可以反向建边，然后编号从大到小dfs。
//复杂度O（n），每个点只遍历一次
#include<iostream>
#include<cstdio>
#define BIG 233333
using namespace std;
int n,m,x,y,tot;
int maxx[BIG],las[BIG],to[BIG],nxt[BIG];
inline void add(){
    scanf("%d%d",&y,&x);
    nxt[++tot]=las[x];
    las[x]=tot;
    to[tot]=y;
}
inline void dfs(int now,int st){
    if(maxx[now])
        return;
    maxx[now]=st;
    for(register int e=las[now];e;e=nxt[e])
        if(!maxx[to[e]])
            dfs(to[e],st);
    return;
}
int main(){
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=m;++i)
        add();
    for(register int i=n;i;--i)
        dfs(i,i);
    for(register int i=1;i<=n;++i)
        printf("%d ",maxx[i]);
    return 0;
}
```

---

## 作者：subarude (赞：117)



```
想到了两种解法
- 缩点 + dfs
- 反着建图 + dfs
```

## 1. 缩点 + $dfs$

#### 缩点之后
- 在同一个强联通分量中的点可以相互到达，那么我们可以在缩点时记录每个联通分量中编号最大的点

- 一个强联通分量中所有点能到达的最大编号的点即为这个联通分量能到达的最大的编号

~~那么我么可以快乐深搜了~~

Code_1:

```cpp
/*
缩点 
在缩完点的图上dfs 
*/
#include <cstdio>
#include <cstring>
#include <iostream>

#define maxn 100010

using namespace std;

inline int read() {
	int op = 1, a = 0;
	char c = getchar();
	for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
	for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
	return op * a;
}

int n, m;

int cnt;
int head[maxn];
struct Edge {int from, to, nxt;} e[maxn];

inline void add_edge(int u, int v) {
	cnt++;
	e[cnt].to = v;
	e[cnt].from = u;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

int r;//栈的右端点 
int s[maxn];//数组来模拟栈 
int num;//个数
int Time; 
bool vis[maxn];
int belong[maxn];//一个点属于哪个强连通分量 
int dfn[maxn], low[maxn];
int rep[maxn];//存储缩完点后每个点所代表的所有点中编号最大的 

void Tarjan(int u) {
	dfn[u] = low[u] = ++Time;
	vis[u] = 1;
	s[++r] = u;
	int R = r;
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (!dfn[v]) {
			Tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if (vis[v]) low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		num++;
		for (int i = R; i <= r; i++) {
			vis[s[i]] = 0;
			belong[s[i]] = num;
			rep[num] = max(rep[num], s[i]);
			//记录强连通分量中编号最大的点（的编号） 
		}
		r = R - 1;
	}
}

//重新建图 
void rebuild() {
	cnt = 0;
	memset(head, 0, sizeof head);
	for (int i = 1; i <= m; i++) {
		int x = e[i].from, y = e[i].to;
		if (belong[x] == belong[y]) continue;
		add_edge(belong[x], belong[y]);
	}
}

int ans[maxn];

void dfs(int u) {
	if (ans[u]) return;
	ans[u] = rep[u];
	//必定能到这个强连通分量中的点 
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		dfs(v);
		ans[u] = max(ans[u], ans[v]);
		//和上一句的位置不能颠倒 
	}
}

int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; i++) {
		int x = read(), y = read();
		add_edge(x, y);
	}
	for (int i = 1; i <= n; i++) if (!dfn[i]) Tarjan(i);
	rebuild();
	for (int i = 1; i <= num; i++) if (!ans[i]) dfs(i);
	for (int i = 1; i <= n; i++) cout << ans[belong[i]] << ' ';
	//一个点的答案都直接输出对应的强连通分量能到的编号最大的点 
	return 0;
}
```


~~然后这么写被机房的$dalao$们讽刺辽~~$QwQ$

$\text {什么？您不是来看这个写法的？\ } $

$\text {别走、别走qwq}$

~~我还能接着口胡$qwq$~~

## 2.反着建图的写法

### - **如果反着建图，那么一个点能到的点不就成了能到那个点的点吗$qwq$**



- 所以我们可以反着建边然后从 $n$ 开始倒着枚举每个点，以他为祖先进行搜索
- 如果搜到了一个已经被其它点遍历到过的点，那么显然有一个编号更大可以走到他（他可以遍历到一个比当前的祖先编号更大的点）
- 那就不管它了~~qwq反正人家估计也不会再理你~~


Code_2:

```cpp
#include <vector>
#include <cstdio>
#include <iostream>

#define maxn 100010

using namespace std;

inline int read() {
	int op = 1, a = 0;
	char c = getchar();
	for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
	for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
	return op * a;
}

int cnt;
int head[maxn];
struct Edge {int to, nxt;} e[maxn];

inline void add_edge(int u, int v) {
	cnt++;
	e[cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

int n, m;
int f[maxn];

void dfs(int u, int fa) {//fa是祖先 
	f[u] = fa;
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (f[v]) continue;
		//有编号更大的点可以遍历到他 
		dfs(v, fa);
	}
}

int main() {
	n = read(), m = read();
	for (; m; m--) {
		int x = read(), y = read();
		add_edge(y, x);
	}
	for (int i = n; i >= 1; i--) {
	//倒着枚举每一个点 
		if (f[i]) continue;
		//有编号更大的点可以遍历到他（倒着枚举的缘故） 
		dfs(i, i);
	}
	for (int i = 1; i <= n; i++) cout << f[i] << ' ';
	return 0;
}
```


如有错误 or 建议欢迎$dalao$们指出





$by$

$subarude$










---

## 作者：lzpclxf (赞：43)

想了很久觉得还是发一下比较好
我就是想把过程**讲的相对透彻一点**，因为我在理解的时候自己确实花费了好久
**补充**一些一笔带过对juruo不是很友好的一些地方
正文：
[题目传送门](https://www.luogu.org/problem/P3916)

一开始大家的思路应该就是单纯的dfs但是我们注意到$n$的范围到了$10^5$这时$n^2$的暴力是过不去的于是我们开始思考反向建边倒着遍历

```cpp
void add(int x, int y) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	head[x] = cnt;
}
```
邻接表存边
```cpp
	for(int i = n; i >= 1; i--) {
		if(ans[i]) continue;
		dfs(i, i);
	}
```
$continue$掉的这句话解释一下：
因为我们是倒着来的，这个点已经被遍历到过了，说明后边的点肯定能走到他，而我们遍历的顺序又是反着来的，所以后边的节点一定比他的大，则这个点所能到的最大值就不用再更新了。相应的如果之前没有点能走到他那么就需要遍历他之前的点，来寻找他的祖先。

```cpp
void dfs(int x, int fa) {
	ans[x] = fa;
	for(int i = head[x]; i; i = e[i].nxt)
		if(!ans[e[i].to]) dfs(e[i].to, fa);
}
```
$dfs$比较简洁，先给$ans$数组赋值，表示在目前的已知条件下，他所能走到的最远的距离是他的祖先$fa$注意这个祖先是比他要大的，就是他能到的最远的点

The Last:
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 100010;
int n, m, head[N], cnt, ans[N];
struct node{
	int nxt, to;
}e[N];
int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1;ch = getchar();}
	while(isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
	return s * w;
}
void add(int x, int y) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	head[x] = cnt;
}
void dfs(int x, int fa) {
	ans[x] = fa;
	for(int i = head[x]; i; i = e[i].nxt)
		if(!ans[e[i].to]) dfs(e[i].to, fa);
}
int main() {
	n = read(), m = read();
	for(int i = 1; i <= m; i++) {
		int x, y;
		x = read(), y = read();
		add(y, x);
	}
	for(int i = n; i >= 1; i--) {
//		memset(vis, 0, sizeof(vis));
//		maxn = i;
		if(ans[i]) continue;
		dfs(i, i);
//		printf("%d\n", maxn);
	}
	for(int i = 1; i <= n; i++) printf("%d ", ans[i]);
	return 0;
}
```
谢谢收看， 祝身体健康！

---

## 作者：shame_djj (赞：36)

	这题打眼一看，哇！水题。
    把边按照终点排序
    按照边直接迭代更新不就好了？
    于是我高高兴兴的交了一份代码
   ```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;
int f[100010];
int n, m;

struct road{
    int u, v;
} edge[100010];

bool cmp(road a, road b) {
    return a.v > b.v;
}

int main() {
    cin >> n >> m;
    for (register int i = 1; i <= m; i ++)
        scanf ("%d %d", &edge[i].u, &edge[i].v);
    sort (edge + 1, edge + m + 1, cmp);
    for (register int i = 1; i <= n; i ++)
        f[i] = i;
    for (register int i = 1; i <= m; i ++)
        f[edge[i].u] = max(f[edge[i].u], f[edge[i].v]);
    for (register int i = 1; i <= n; i ++)
        printf ("%d ", f[i]);
    printf ("\n");
    return 0;
}
```


	结果爆炸。。。。只得了10分。。。
    突然想到可能会有一遍更新更新不完的情况，
    （楼主脑残，构造不出来）
    比如说求最短路时不就是一条短边松弛好多次。
    所以我稍稍地改了我的代码，
    
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;
int f[100010];
int n, m;

struct road{
    int u, v;
} edge[100010];

bool cmp(road a, road b) {
    return a.v > b.v;
}

int main() {
    cin >> n >> m;
    for (register int i = 1; i <= m; i ++)
        scanf ("%d %d", &edge[i].u, &edge[i].v);
    sort (edge + 1, edge + m + 1, cmp);
    for (register int i = 1; i <= n; i ++)
        f[i] = i;
    for (register int k = 1; k <= 10; k ++)
        for (register int i = 1; i <= m; i ++)
            f[edge[i].u] = max(f[edge[i].u], f[edge[i].v]);
    for (register int i = 1; i <= n; i ++)
        printf ("%d ", f[i]);
    printf ("\n");
    return 0;
}
```
	
    其实就是套了一个让它多更新几次的循环，
    然后80分了qaq
    这题数据量1e5
    排序O(mlog(m)), 更新是O(km)(k是更新次数);
    如果这题的数据比较毒瘤，O(km)就会炸
    同时也会说明我们的算法是不可行的（滑稽）
    不过这题数据水，楼主将k改为100时直接AC
    最后通过10到100内的二分查找，发现
    这题最小的k是95（滑稽~滑稽~~）
    
    离noip还有5个月，祝大家rp++
    也希望这篇题解能通过
    （滑稽的是我没有粘AC代码，不过代码已经不重要了）

---

## 作者：Drifterming (赞：32)

/\*
非常神奇的dfs，我们上午考试考的这道题，考场上我是正着建的边，但是不会做环啊，只得了50分，

然后把用来判重的visited数组拿掉，多得了10分！

然后让每个点dfs100次，AC啦！！！

就是任性，不怂不超时！

\*/







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=100005;
int n,m;
int Max_to[N],Min_to[N];
int num_edge,head[N];
struct Edge
{
    int u,v,nxt;
}edge[N];
int read()
{
    char c=getchar();int num=0;
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        num=num*10+(c^'0');
    return num;
}
void add_edge(int u,int v)
{
    edge[++num_edge].u=u;
    edge[num_edge].v=v;
    edge[num_edge].nxt=head[u];
    head[u]=num_edge;
}
void dfs(int u)
{
    for(int i=head[u],v;i;i=edge[i].nxt)
    {
        v=edge[i].v;
        if(Max_to[v])
        {
            Min_to[u]=min(Min_to[u],Min_to[v]);
            Max_to[u]=max(Max_to[u],Max_to[v]);
            continue;
        }
        dfs(v);
        Max_to[u]=max(Max_to[u],Max_to[v]);
        Min_to[u]=min(Min_to[u],Min_to[v]);
    }
}
int main()
{
    //freopen("graph.in","r",stdin);
    //freopen("graph.out","w",stdout);
    n=read(),m=read();
    for(int i=1,u,v;i<=m;++i)
    {
        u=read(),v=read();
        add_edge(u,v);
    }
    for(int i=1;i<=n;++i)
        Max_to[i]=Min_to[i]=i;
    for(int i=1;i<=100;++i)        //代码AC的核心关键部分，每个点dfs一百次！咱不怂不超时 
    {
        for(int j=1;j<=n;++j)
            dfs(j);
    }
    for(int i=1;i<=n;++i)
    {
        if(Max_to[i]<Max_to[Min_to[i]])
            Max_to[i]=Max_to[Min_to[i]];
        if(Max_to[i]<Max_to[Max_to[i]])
            Max_to[i]=Max_to[Max_to[i]];
        printf("%d ",Max_to[i]);
    }
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

---

## 作者：曼恩薄荷 (赞：31)

	本蒟蒻今天刚刚学了缩点，深感此算法的奇妙，对tarjan他老人家的独特创造佩服不已，看了看似乎没有使用tarjan求强联通分量的题解，便想在此谈一下自己的学习心得。（PS：如果你还没有学习过tarjan求强联通分量的算法的话，推荐一篇博客 BY ByVoid大神 https://www.byvoid.com/zhs/blog/scc-tarjan/ 里面讲的十分详细）。
------------

	下面我们切入正题：求对于每个点所能扩展到的下标最大的点。很容易我们想到：对于任意一个集合，若该集合内的点都可以互相到达的话，那么对于这整个集合中所有点的答案便为其中下标最大的那个点。那么我们就可以把整个图中的强联通分量求出来，并把他们其中最大的点标记为这个强联通分量的内容。代码如下：
  ```cpp
void tarjan(int x)  				 //求有向图强联通分量的tarjan，在这里不过多叙述，想学习的可以点链接去博客qwq 
{
    vis[x] = 1;
    s[++top] = x;
    dfn[x] = low[x] = ++Time;
    for(int i = head[x];i;i=e[i].next)
    {
        int to = e[i].to;
        if(!dfn[to])
        {
            tarjan(to);
            low[x] = min(low[x],low[to]);
        }
        else if(vis[to])
            low[x] = min(low[x],dfn[to]);
    }
    if(dfn[x] == low[x])			//如果x及其子树能够构成一个强联通分量 
    {
        ++cnt;
        int j;
        while(j=s[top])   			//将其子树中的点都加入此分量中,并将此分量中的最大值保存在MAX数组中 
        {
            vis[j] = 0;
            belong[j] = cnt;
            MAX[cnt] = max(MAX[cnt],j);
            top--;
            if(j==x) break;
        }
    }
}

```
	这样我们便可以将本很难处理的环变成一个个点，然后要做的就是求出对于每个点的ans了，于是我想到了使用记忆化搜索（其实就是dp）。我们设f[i]表示从i出发所能追溯到的最大的点，所以f[i]=max(f[i],f[i的儿子]）就转化成为一种树形结构，可以轻松递归求解。代码如下：
```cpp
void dfs(int x)    					//记忆化搜索 
{
    if(f[x]) return;
    f[x] = MAX[x];					//当前强联通分量中的最大值 
    for(int i=head[x];i;i=e[i].next)
    {
        int to = e[i].to;
        if(!f[to]) dfs(to);
        f[x] = max(f[x],f[to]);		// 子树中的最大值 
    }
}
```

	这样我们便求出了对于每个强联通子图的答案，最后要做的只需要是找到每个点分别对应哪个强联通子图就好了，是不是喜欢上了这种奇妙的算法qwq？
    
	完整代码奉上（~~千万不要直接抄喔~~）：
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int maxn = 10e5 + 5;

struct Edge{
    int to,next;
}e[maxn];

int dfn[maxn],low[maxn],Time;
int s[maxn],top,vis[maxn];
int f[maxn],n,m;
int cnt,belong[maxn],MAX[maxn];
int k,x[maxn],y[maxn],head[maxn];

void add(int u,int v)
{
    e[++k].to = v;
    e[k].next = head[u];
    head[u] = k;
}

void tarjan(int x)  				 //求有向图强联通分量的tarjan，在这里不过多叙述，想学习的可以点链接去博客qwq 
{
    vis[x] = 1;
    s[++top] = x;
    dfn[x] = low[x] = ++Time;
    for(int i = head[x];i;i=e[i].next)
    {
        int to = e[i].to;
        if(!dfn[to])
        {
            tarjan(to);
            low[x] = min(low[x],low[to]);
        }
        else if(vis[to])
            low[x] = min(low[x],dfn[to]);
    }
    if(dfn[x] == low[x])			//如果x及其子树能够构成一个强联通分量 
    {
        ++cnt;
        int j;
        while(j=s[top])   			//将其子树中的点都加入此分量中,并将此分量中的最大值保存在MAX数组中 
        {
            vis[j] = 0;
            belong[j] = cnt;
            MAX[cnt] = max(MAX[cnt],j);
            top--;
            if(j==x) break;
        }
    }
}

void dfs(int x)    					//记忆化搜索 
{
    if(f[x]) return;
    f[x] = MAX[x];					//当前强联通分量中的最大值 
    for(int i=head[x];i;i=e[i].next)
    {
        int to = e[i].to;
        if(!f[to]) dfs(to);
        f[x] = max(f[x],f[to]);		// 子树中的最大值 
    }
}

int main()
{
    //freopen("data.in","r",stdin);
    //freopen("jkb.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x[i],&y[i]);			//保存边信息 
        add(x[i],y[i]);
    }
    for(int i=1;i<=n;i++)					//求出强联通分量 
        if(!dfn[i])
            tarjan(i);
    memset(e,0,sizeof(e));					//清空原图 
    memset(head,0,sizeof(head));	
    k = 0;
    for(int i=1;i<=m;i++)					//建立新图 
        if(belong[x[i]]!=belong[y[i]])
            add(belong[x[i]],belong[y[i]]);
    for(int i=1;i<=cnt;i++)
        if(!f[i]) dfs(i);
    for(int i=1;i<=n;i++)					//输出答案 
        printf("%d ",f[belong[i]]);
    return 0;
}
```

---

## 作者：iMya_nlgau (赞：23)

# P3916 【图的遍历】

从标签来看这道题应该用强连通分量，缩点做，但我还是更喜欢$DFS$的码量，所以这是一篇$DFS$题解.

一种显而易见的算法是从每个点搜索能到达的点，再找出最大的，然而这种暴搜的时间复杂度接近$O(n^2)$，$n^2$过十万似乎只能是奇迹，于是我们应该换一下思路：

**与其求从一个点出发，能到达的编号最大的点，不如等价地求有哪些点能到达这个最优的点**

于是就会很自然地想到应该反向建边.

### 反图：
反图是指将原图的所有边反向所建立的图，形式化地说，有向图$G=(V,E)$的反图是图$G^T=(V,E^T)$，这里$E^T=\{(v,u)\in V\times V:(u,v)\in E\}$.

### $DFS$实现：
容易想到，应该按编号从大到小$DFS$每个节点，这样能保证一个点$v$第一次被访问到一定是从最优的$A(v)$出发的$DFS$，这样每个点只需访问一次，总的时间复杂度为$O(n)$，本题$n\leqslant 10^5$，轻松跑过.


理解本题思路后，代码实现就非常简单了，还不到$40$行.

```cpp
#include<cstdio>
const int maxn=1e5+10;
int edge[maxn],next[maxn];
int head[maxn],cnt;		//采用链式前向星实现邻接表存图
inline void Init(){		//邻接表初始化
    for(int i=0;i<maxn;i++)
        head[i]=next[i]=-1;
    cnt=0;
}
inline void addedge(int u,int v){	//加入边(u,v)
    edge[cnt]=v;
    next[cnt]=head[u];
    head[u]=cnt++;
}
int n,m;			//n为点数，m为边数
int ans[maxn];			//ans数组存答案，ans[i]即A(i)
void dfs(int n,int a){		//dfs实现
    if(ans[n]) return;		//如果访问过直接返回
    ans[n]=a;			//记录答案
    for(int i=head[n];~i;i=next[i])	//~i也可以写作i!=-1
        dfs(edge[i],a);
}
int main(){
    Init();
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(v,u);		//反向建图
    }
    for(int i=n;i;i--)		//从大到小dfs
        if(!ans[i]) dfs(i,i);
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    return 0;
}
```
感谢阅读，欢迎各位$dalao$指出错误 (^_^;)

$by\ Sapphire6575737973$

---

## 作者：shadowice1984 (赞：23)

来一发bfs版本

对于这个图来讲我们可以反向建图

将到达的最大点转化为是否可以被当前的最大点到达

所以我们从n到1枚举起点

然后可以发现这样的性质

如果一个点被标记过，也就是说这个点有答案

和该点相连的所有点都被标记过，因此无需搜索这个点。

在遇到有答案的点是跳过即可

上代码~

```cpp
#include<stdio.h>
#include<queue>
using namespace std;
struct data
{
    int v;int next;
}edge[100010];
int alist[100010];
int cnt;
void add(int u,int v)
{
    edge[++cnt].v=v;
    edge[cnt].next=alist[u];
    alist[u]=cnt;
    return;
}
int n;int m;
int res[100010];//答案数组
queue <int> q;
int now;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++)
    {
        int u;int v;
        scanf("%d%d",&u,&v);
        add(v,u);//反向建图
    }
    for(int i=n;i>=1;i--)
    {
        if(res[i]!=0)continue;//如果这个点被搜过所有相连点均被搜过可以跳过
        q.push(i);
        while(!q.empty())//对点ibfs
        {
            now=q.front();q.pop();
            res[now]=i;
            int next=alist[now];
            while(next)
            {
                int v=edge[next].v;
                if(res[v]==0)
                {
                    q.push(v);
                }
                next=edge[next].next;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d ",res[i]);//输出答案
    }
    return 0;
}
```

---

## 作者：Jelly_Goat (赞：16)

~~看了看题解区，都是神仙啊QAQ又是广搜又是大法师的~~  
我发一篇正经一点的tarjan缩点+toposort+dp的版本。   
这个题用来练缩点还是蛮不错的qwq 

其实这个题好像有个正向版本，那就是：[【模板】缩点](https://www.luogu.org/problem/P3387)  
然而那个板子是用来正向累加权值求最大的dp，这个是反向求最大id的dp  
首先我们知道如果加反向边，环还是环，SCC大小等不变  
在同一个SCC里面的点能遍历到的首先是SCC中id最大的点  
然后缩点过后就变成了DAG，放心toposort  
然后才是不是同一个SCC中倒序能遍历到的最大的id  
因此我们说能遍历到的点的id的最大值  
那我们从最后边倒序向前toposort  
直接从当前点更新出发点的dp值就好了啊  
~~代码量可是巨大~~  

另外是几个细节  
1. 反向边遍历边的时候得到的边的出发点是终点，dp时候要注意  
2. 重新建图如果是多开空间富裕然后memset时间爆炸，那就多开一个图  

行了，上代码（有注释）
```cpp
#include <iostream>
#include <cstdio>
#include <queue>

using namespace std;
struct edge
{ // 边
	int from, to, next;
};
struct gragh
{
	edge Edge[100086];					   // 每个图的边
	int cnt, head[100086];				   // 每个图的前向星
	inline void add_edge(int from, int to) // 每个图的加边
	{									   // 对于每一个图的加边
		this->cnt++;					   // this可以理解为“当前图的”
		this->Edge[this->cnt].from = from;
		this->Edge[this->cnt].to = to;
		this->Edge[this->cnt].next = this->head[from];
		this->head[from] = cnt;
	}
};
gragh a, b; // a是缩点前的，b是缩点后的

int dfn[100086], low[100086], dfncnt, stack[100086], top;
int group[100086], gcnt, maxid[100086];
bool vst[100086];
//我们最后要统计每一个SCC的入度来toposort进行dp
int n, m, In[100086], dp[100086];
//缩点
void tarjan(int n)
{
	dfn[n] = low[n] = ++dfncnt;
	stack[++top] = n;
	vst[n] = true;
	for (int i = a.head[n]; i; i = a.Edge[i].next)
	{
		int to = a.Edge[i].to;
		if (dfn[to] == 0)
		{
			tarjan(to);
			low[n] = min(low[n], low[to]);
		}
		else if (vst[to]) //我写了dfn版本，据说low版本并不准确
		{
			low[n] = min(low[n], dfn[to]);
		}
	}
	if (low[n] == dfn[n])
	{
		int now;
		gcnt++;
		do //do-while会省下一次码量，n就直接不用最后再弹了
		{
			now = stack[top--];
			group[now] = gcnt;
			//更新一下当前SCC最大的id
			maxid[gcnt] = max(maxid[gcnt], now);
			vst[now] = false;
		} while (now != n);
	}
}
// 重新建图
void rebuild()
{
	for (int i = 1; i <= a.cnt; i++)
	{
		int from = a.Edge[i].from;
		int to = a.Edge[i].to;
		if (group[from] != group[to])
		{
			//统计入度，重新加边
			In[group[to]]++;
			b.add_edge(group[from], group[to]);
		}
	}
}

void toposort()
{
	queue<int> q;
	for (int i = 1; i <= gcnt; i++)
		if (In[i] == 0)
			q.push(i);
	while (!q.empty())
	{
		int from = q.front();
		q.pop();
		dp[from] = max(dp[from], maxid[from]); //对于当前节点的dp
		for (int i = b.head[from]; i; i = b.Edge[i].next)
		{
			int to = b.Edge[i].to;
			dp[to] = max(dp[from], dp[to]); //to是起点，更新起点dp值
			if (--In[to] == 0)
				q.push(to);
		}
	}
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++)
	{
		int f, t;
		scanf("%d%d", &f, &t);
		a.add_edge(t, f);
	}
	for (int i = 1; i <= n; i++)
	{
		if (dfn[i] == 0)
			tarjan(i);
	}
	rebuild();
	toposort();
	for (int i = 1; i <= n; i++)
	{
		printf("%d ", dp[group[i]]);
	}
	return 0;
}
```

---

## 作者：灵光一闪 (赞：7)

~~神**这是个绿题？你逗我玩呢啊~~

这个题同上次[题解](https://www.luogu.org/blog/luoguyisuei/solution-cf727a)一样

主要考察的是逆向思维的运用。

顺着DFS不优化就是作死，比如这个:

1->2->3->4->···->100000

这个你要顺着DFS就完了，O($n^{2}$)的复杂度不是你$10^{5}$想辗就能辗过去的……
  
所以我们要反向建边:

1<-2<-3<-4<-···<-100000

这样从100000开始跑，每一个点都是遍历一次,复杂度O(n)

我相信没有人能把常数写到10000去吧？【能写到1000的都是人才……】

然后说点细节:

1. 数组别开小了【第一次60】

2. **是从大开始DFS！**

3. 但凡学过DFS的就别写`for(int i=0;i<n;i++)`除非你建边时每个点都减了1

4. 认真码，仔细码，别码错了，最好一遍过【这种DFS水题学过遍历的都能阿希好吗qaq】

5. 核心是**反向建边**，请不要建反了。还有，这个是有向图

代码:
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<vector>
using namespace std;
vector<int> v[233333];//vector跑DFS
bool vis[233333];//是否访问过？
int ans[233333];//答案
/*无视233333好吧qaq*/
void dfs(int a,int cos){//a是现在 cos是最大的
	ans[a]=cos;//赋值
	vis[a]=true;//标记
	for(int i=0;i<v[a].size();i++){//跑到下一层
		if(!vis[v[a][i]]){
			dfs(v[a][i],cos);
		}
	}
	return;
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++){//输入
		int x,y;
		cin>>x>>y;
		v[y].push_back(x);//反向建边
	}
	for(int i=n;i>=1;i--){
		if(!vis[i]){//千万要把if写上，不然就是WA+TLE
			dfs(i,i);
		}
	}
	for(int i=1;i<=n;i++){//输出
		cout<<ans[i]<<" ";
	}
	return 0;
}
```

有问题及时私信窝，我会在48小时内回复滴【节假日24小时】

The End.


---

## 作者：Reko_Tang (赞：6)

好久没更博客了（ps：终于考完试了！！！！！！！！！！！）

P3916 图的遍历 ->[传送门](https://www.luogu.org/problem/P3916)

这题好像是之前一码某场比赛的D题，虽说是道绿题，但想明白就没问题。

可以通过反向建边然后从最大节点开始dfs，就可以把所有与该节点联通的节点标记，在dfs的过程中记得加个判断该节点是否被走过就行了。

上个代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 9;
vector<int> G[MAXN];
int n, m, a[MAXN];
void dfs(int now, int x){
	a[now] = x;
	for (int i = 0; i < G[now].size(); i++){
		if (!a[G[now][i]]) dfs(G[now][i], x);
	}
}
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++){
		int x, y;
		cin >> x >> y;
		G[y].push_back(x);
	}
	for (int i = n; i > 0; i--){
		if (!a[i]) dfs(i, i);
	}
	for (int i = 1; i <= n; i++) cout << a[i] << ' ';
	return 0;
}

```


---

## 作者：zhanghengrui (赞：6)

本题第一篇Python题解

---

看到题，很自然能想到反向建边，然后从最大的点开始枚举每一个点能到的所有点（当然不包括已经到过的）并作标记，直接输出就可以了

于是就有了这份代码

```python
s=input().split()
N,M=int(s[0]),int(s[1])
#预处理
e=[[]]
A=[None]
for i in range(1,N+1):
    e.append([])
    A.append(None)
#读入并建边
for i in range(M):
    s=input().split()
    U,V=int(s[0]),int(s[1])
    e[V].append(U)
#Dfs函数
def Dfs(x,s):
    if A[x]!=None:return
    A[x]=s
    for i in e[x]:
        if A[i]==None:Dfs(i,s)
for i in range(N,0,-1):
    if A[i]==None:Dfs(i,i)
#输出
for i in range(1,N+1):
    if i>1:print(' ',end='')
    print(A[i],end='')
```

But，如无意外，这份代码交上去会__RE__

下载数据本地测一测，发现那一堆错误信息最后会有一句

`RecursionError: maximum recursion depth exceeded`

也就是栈的深度过大（栈的最大深度默认是$1000$）

于是我们要在刚刚那份代码前面加上这样两行

```python
import sys#导入sys库
sys.setrecursionlimit(1000000)#设置栈的最大深度（不一定要1000000，够大就行）
```

然后就可以愉快地AC了

---

~~码风略丑，别吐槽~~

有不懂的可以私信或在博客中评论

---

## 作者：yu__xuan (赞：6)

Emm...本蒟蒻只会邻接矩阵，这种大数据的题还是很难的(总不能用矩阵存吧，会爆的诶！可能我太弱了)。但总不能一直用邻接矩阵吧。

邻接表我太弱了，就不讲了，各位可以去网上搜一下。

本题的思路就是，反向存边，dfs遍历。
反向存边就是字面意思，题目给你a-->b,你就存为b-->a。
然后dfs遍历。

对于样例：

正常的图是这样的
![](https://cdn.luogu.com.cn/upload/pic/59311.png)

反向就是这样的：
![](https://cdn.luogu.com.cn/upload/pic/59311.png)

我们由i:n-->1遍历它们能到达的点，将该点的最大值设为i即可。

**Code:**
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int cnt=0;
int ans[100001],head[100001];
struct edge{
	int to,next;
}Edge[100001];
void add_edge(int from,int to){//邻接表存边 
	Edge[++cnt].to=to;
	Edge[cnt].next=head[from];
	head[from]=cnt;
}
void dfs(int now,int st){//深搜 
	if(ans[now]) return;//如果已经更新过了，不是0就返回。 
	ans[now]=st;
	for(int i=head[now];i;i=Edge[i].next){//普普通通的遍历 
		dfs(Edge[i].to,st);
	}
}

int main(){
	int n,m;
	int a,b;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		scanf("%d%d",&a,&b);
		add_edge(b,a);//反向存边 
	}
	for(int i=n;i>=1;--i){//由n-->1，去更新最大值。 
		dfs(i,i);
	}
	for(int i=1;i<=n;++i){//输出 
		printf("%d ",ans[i]);
	}
	return 0;
}
```

---

## 作者：无妹的妹控 (赞：5)

看了这么多BFS，我还是选择用爬山。。。
# 本题爬山AK!
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
int n,m,biggest[100005];//biggest指该点能达到的最大点编号
struct list
{
	int a,b;
} a[100005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) biggest[i]=i;
	for(int i=1;i<=m;i++) scanf("%d%d",&a[i].a,&a[i].b),biggest[a[i].a]=max(biggest[a[i].a],biggest[a[i].b]);
	for(int l=1;l<94;l++)
		for(int i=1;i<=m;i++) biggest[a[i].a]=max(biggest[a[i].a],biggest[a[i].b]);
	for(int i=1;i<=n;i++) printf("%d ",biggest[i]);
 	return 0;
}

```
自己亲测，本题数据，最少爬93遍。

---

## 作者：cheater__ (赞：5)

前方高能！！！！
正向建边+bfs+400次爆搜ac
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define maxn 100010

struct edge
{
	int from,to,next;
}q[maxn];

int a[maxn],n,m,maxx[maxn];

void init()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&q[i].from,&q[i].to);
		q[i].next = a[q[i].from];a[q[i].from] = i;
	}
}

int main()
{
	init();
	for(int i=1;i<=n;i++)
		maxx[i] = i;
	for(int k=1;k<=400;k++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int p = a[i];p!=0;p = q[p].next)
			{	
				if(maxx[i] < maxx[q[p].to])
					maxx[i] = maxx[q[p].to];
			}	
		}
		for(int j=1;j<=n;j++)
		{
			int p = maxx[j];
			while(maxx[p] != p)
				p = maxx[p];
			maxx[j] = p;
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d ",maxx[i]);
	return 0;
}
```

---

## 作者：gzw2005 (赞：5)

在此要感谢巨佬 [LBY](https://www.luogu.org/space/show?uid=52881) 的思路。

首先定义 $f[i]$ 为从第 $i$ 个点出发能到达的编号最大的点。

所以一开始 `f[i]=i`。

接下来要用到一个常识：

已知 $x$ 和 $y$ 连了一条有向边（即 x=>y），那么第 $y$ 个点能到达的最大点（即 `f[y]`），第 $x$ 个点也能到达。

很容易想到松弛。

不过松弛一次还不够，因为有一些路径可能要经过很多个点。这里用了 `while` 了解决这个问题。

后来问了老师，大概松弛 100 次就可以了。所以时间复杂度大概 $O(100M)$。~~时间复杂度依然很玄学~~

[AC证明](https://www.luogu.org/record/show?rid=7867549)。204ms.

```
#include<bits/stdc++.h>
using namespace std;
struct Link{
	int x,y;
}link[100002];
int n,m,f[100002];
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		cin>>link[i].x>>link[i].y;
	for(int i=1;i<=n;i++)//初始化 
		f[i]=i;
	for(bool find=true;find;){
		find=false;
		for(int i=1;i<=m;i++)
			if(f[link[i].x]<f[link[i].y]){//松弛 
				find=true;
				f[link[i].x]=f[link[i].y];
			}
	}
	for(int i=1;i<=n;i++)
		cout<<f[i]<<" ";
	return 0;
}
```

最后再次感谢巨佬 [LBY](https://www.luogu.org/space/show?uid=52881)！

---

## 作者：oscar (赞：5)

这题有一个不用tarjan的做法，不知道是数据太弱还是我的做法本身就是对的

一开始写了一个把记录low数组改成记录能达到的最大编号

结果发现WA了，更新顺序不能保证是对的

然后我多更新了几次，直到任意节点的“最大编号”信息不再变化为止，然后就AC了


扔代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=100010;
struct edge
{
    int v;
    edge *next;
}*h[MAXN],pool[MAXN*2];
int top,changed;
inline void addedge(int u,int v)
{
    edge *tmp=&pool[top++];tmp->v=v;tmp->next=h[u];h[u]=tmp;
}
int vis[MAXN],hi[MAXN];
void search(int u)
{
    vis[u]=1;
    for(edge *tmp=h[u];tmp;tmp=tmp->next)
    {
        if(!vis[tmp->v])
        {
            search(tmp->v);
        }
        if(hi[tmp->v]>hi[u])
        {
            changed=1;//这里也是关键
            hi[u]=hi[tmp->v];
        }
    }
    vis[u]=2;
}
int main()
{
    int n,m,a,b;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)hi[i]=i;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        addedge(a,b);
    }
    //这里是关键
    do
    {
        memset(vis,0,sizeof(vis));changed=0;
        for(int i=1;i<=n;i++)
        {
            if(!vis[i])
                search(i);
        }
    }while(changed);
    //关键部分到此结束
    for(int i=1;i<=n;i++)
    {
        printf("%d ",hi[i]);
    }
    printf("\n");
    return 0;
}
```

---

## 作者：KesdiaelKen (赞：4)

来个非正解但是很好写且可以A掉的方法。

开一个数组$zd$记录从某点出发能够到达的编号最大的点。从每一个点$dfs$同时打$visit$记录保证不重复遍历同一个节点，保证时间复杂度。对于一个点$i$，遍历它连向的点$j$，如果$visit$过则让$zd[i]$取$max(zd[i],zd[j])$，否则先$dfs$节点$j$之后再取$max$。

发现这样会WA。考虑这样一张图：$1to3,3to2,2to1$。先$dfs$节点$1$，$1$继续到$3$，然后到$2$，此时$2$无处可去（$1$已经$visit$了），只能取$zd[2]=max(zd[1],zd[2])=2$。然而事实上因为$1$还未取$max$得$3$（$dfs$的延迟性），所以$zd[2]$跟着得到了错误的答案$2$，导致输出错误。

因此，我们考虑再次$dfs$，方法是$memset\space visit$且保留上一次的$zd$后再$dfs$一遍，这样多次$dfs$后可以让延迟的答案推回到它正确的位置，得到正确答案。这样的做法很玄学，不知道能不能卡掉，但是三次$dfs$后就能A了。代码中写了$5$次$dfs$，保证正确性（你不能要求程序总是完全正确的，字符串$hash$作为一种正确的算法还能被卡掉呢）。

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<queue>
using namespace std;
int zd[200000]={0};
int n,m;
struct Edge
{
    int t,nexty;
}edge[1000000];
int head[200000]={0},cnt=0;
void add(int a,int b)
{
    cnt++;
    edge[cnt].t=b;
    edge[cnt].nexty=head[a];
    head[a]=cnt;
}
bool dg[200000]={0};
void dfs(int node)
{
    dg[node]=true;
    for(int i=head[node];i;i=edge[i].nexty)
    {
        if(!dg[edge[i].t])dfs(edge[i].t);
        zd[node]=max(zd[node],zd[edge[i].t]);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)zd[i]=i;
    int a,b;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
    }
    for(int i=1;i<=n;i++)dfs(i);
    for(int i=1;i<=n;i++)dg[i]=false;
    for(int i=1;i<=n;i++)dfs(i);
    for(int i=1;i<=n;i++)dg[i]=false;
    for(int i=1;i<=n;i++)dfs(i);
    for(int i=1;i<=n;i++)dg[i]=false;
    for(int i=1;i<=n;i++)dfs(i);
    for(int i=1;i<=n;i++)dg[i]=false;
    for(int i=1;i<=n;i++)dfs(i);
    for(int i=1;i<=n;i++)printf("%d ",zd[i]);
    printf("\n");
    return 0;
}
```


---

## 作者：老咸鱼了 (赞：3)

萌新太菜了，只会写单源最短路，这题大佬们都是DFS，但是本孱弱并不会DFS，所以就用SPFA过了。
图的遍历，顾名思义让每个点都跑一次，既然一次SPFA不能跑过所有点，那么我们就多跑几次。
举个小点的样例

5 5

1 2

2 4

1 3

2 5

3 4

![样例图片](http://ae01.alicdn.com/kf/HTB1PsRBcRGw3KVjSZFD760WEpXaK.png)

~~手画的图有点丑~~

图中我们可以看出单单从5跑一次反向边是不能求出每个边最大的值的，例如3最大值应该是4，所以这时候我们就需要多跑几次SPFA了，从4这个点再开始跑一次，但是如果我们每个点都跑一次SPFA  1e5的数据肯定会超时，所以我们从最大的点开始跑，并且用一个数组来记录每个点有没有到过，如果到过就不用再跑一次了，因为是从大到小跑的，所以如果到过那个点，那么必定是那个点能到的最大值。

用的时间也并不是特别多
![](http://ae01.alicdn.com/kf/HTB1vjRAcRKw3KVjSZTE763uRpXak.png)

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct f{
	int x,y,next;
}a[500050];
int b[500050],head[500050],vis[500050];
bool p[500050];
bool cmp(f a,f b)
{
	return a.y>b.y;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		b[i]=i;
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a[i].y,&a[i].x);		//因为是从大到小跑，所以我们要存反向边。
		a[i].next=head[a[i].x];
		head[a[i].x]=i;
	}
	for(int i=n;i>=1;i--)
	{
		if(p[i]==false)		//记录这个点有没有跑到过。
		{
			queue<int>q;			//虽然SPFA已经死了，但是因为SPFA写起来比较简单，本孱弱还是比较喜欢写SPFA。。。
			q.push(i);
			while(!q.empty())
			{
				int u=q.front();
				p[u]=true;		//标记已经来过这个点了。
				q.pop();
				vis[u]=false;
				for(int i=head[u];i;i=a[i].next)
				{
					int t=a[i].y;
					if(b[a[i].y]<b[u])
					{
						b[a[i].y]=b[u];
						if(!vis[t])
						{
							q.push(t);
							vis[t]=1;
						}
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d ",b[i]);
	}
}
```
如果哪里还有问题希望大佬能指正一下。

---

## 作者：张亦弛 (赞：3)

首先来看看这道题的暴力解法，对每个点进行一个dfs，记录搜索路上的编号最大的点，就是最后的答案。看看数据范围：对于60% 的数据，1≤N、K≤1000。这60分应该没有问题。

然后再来思考正解，对于每一个点到达的编号最大的点，我们可以看作大编号的点可以覆盖哪些点，被覆盖的这些点能达到的最大的点，也就是这些编号大的点了。比如5覆盖了1、2，也就是说1、2可以到达5，然后4也覆盖了1、2，很容易看出，1和2的答案都是5。所以我们只需要从点编号最大的开始，就是for(int i=n;i>=1;i--)，这样就可以保证第一次计算被覆盖的点的A（能达到的最大编号的点）就是把这个点覆盖了的点，按照上面的例子就是，以5为起点的时候，1、2的A就已经更新了，且不会再被更新（因为i从大到小枚举的）。

注意一下：这样的话，就需要反向存边。

ac代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;//N个点,M条边的有向图
struct Edge
{
	int to;
	int next;
}edge[100005];//邻接表存图 
int cnt;
int head[100005];
void add(int from,int to)
{
	cnt++;
	edge[cnt].to=to;
	edge[cnt].next=head[from];
	head[from]=cnt;
}//邻接表存边 
queue <int> q;
int vis[100005];//记录最后的答案 
void bfs(int x)//bfs
{
	while(!q.empty())//当队列不为空 
	{
		int u=q.front();//取出队首 
		q.pop();//弹栈 
		vis[u]=x;//一遇到就更新（因为x从大到小） 
		for(int i=head[u];i;i=edge[i].next)//邻接表找边 
		{
			int v=edge[i].to;//到达的点 
			if(vis[v]==0)//如果没有被修改过 
				q.push(v);//入队，进行bfs 
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);//输入N个点、M条边
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);//a输入a、b相连 
		add(b,a);//加边 
	}
	for(int i=n;i>=1;i--)//从大到小倒着来枚举 
	{
		if(vis[i]!=0)//如果没有被更新过 
			continue;//跳过 
		q.push(i);//入队 
		bfs(i);//开始bfs 
	}
	for(int i=1;i<=n;i++)
		printf("%d ",vis[i]);//输出答案 
	return 0;
}
```

---

## 作者：ghj1222 (赞：2)

题目大意：给出 $N$ 个点， $M$ 条边的有向图，对于每个点 $v$ ，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。

我们逆向思考一下，我们根据贪心，从点编号最大的点逆着有向边向外扩展，能扩展到的所有的点的答案一定是n。

然后从点编号次大的点逆着有向边向外扩展，不去访问那些已经找到答案的点，能扩展到的所有点的答案是n-1

然后从点编号为n-2...

所以我们得出来了一个贪心+dfs算法

```
#include<cstdio>
#include<iostream>
using namespace std;
//建立反向边，然后进行n次dfs 
struct edge
{int v,ne;}a[100010];
int n,m,d[100010],h[100010],tmp;
void add(int x,int y)
{
	a[++tmp]=(edge){y,h[x]};
	h[x]=tmp;
}
void dfs(int x,int key)
{
	d[x]=key;
	for(int i=h[x];i!=0;i=a[i].ne)
	{
		if(d[a[i].v]==0)
		{
			dfs(a[i].v,key);
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int liu,chen,i=1;i<=m;i++)
	{
		scanf("%d%d",&liu,&chen);
		add(chen,liu);
	}
	for(int i=n;i>=1;i--)
		if(d[i]==0)
			dfs(i,i);
	for(int i=1;i<=n;i++)
		printf("%d%c",d[i],i==n?'\n':' ');
	return 0;
}
```

---

## 作者：Bring (赞：2)

~~怀疑难度打错了~~
# **dfs任性AC**
~~ruoju题解~~大佬勿喷
##  _步入正题->_ 
```cpp
#include<iostream>
#include<vector>
using namespace std;
#define B b[d][i]
int n, m, u, v, a[100001];
vector<int>b[100001];//邻接表存边防MLE
void dfs(int d,int z);//dfs原型：d表示点，z表示将遍历到的点改为z
int main() {
	cin >> n >> m;
	while (m--)cin >> u >> v, b[v].push_back(u);//有向边反着存
	for (int i(n); i >= 1; --i)dfs(i, i);//为什么反着做，往下看
	for (int i(1); i <= n; ++i)cout << a[i] << ' ';
	return 0;
}
void dfs(int d, int z) {
	if (a[d] >= z)return;//保证获得最大值
	a[d] = z;
	for (int i(0), s(b[d].size()); i < s; ++i)dfs(B, z);//这就是关键了
	/*
	有向边反着存：
	是为了将点寻找最大点的问题
	改为最大点寻找点的问题
	这样所有最大点遍历到的点
	都可以改为最大点的值
	因此从高往低dfs
	并保证遍历过的点不会被再次改变
	~神奇吧~
	*/
}
```

---

## 作者：Solomon_611 (赞：2)

本蒟蒻不会Tarjan缩点这种高端操作，所以就用了宽搜。

本来以为会TLE，但优化过度了，WA了，后来简单的优化一下就过了。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <queue>
#include <list>
#include <set>
#include <cstdio>
#include <stack>
#include <vector>
#include <map>
using namespace std;
int Max[100001];
vector<int> edge[100001];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        Max[i] = i;
    }
    for (int i = 1; i <= m; i++)
    {
        int a, b;
        cin >> a >> b;
        //Max[a] = max(Max[a], b);
        edge[a].push_back(b);
    }
    for (int i = 1; i <= n; i++)
    {
        bool b = true;
        for (int i = 1; i <= n; i++)
        {
            int size = edge[i].size();
            int t = Max[i];
            for (int j = 0; j < size; j++)
            {
                Max[i] = max(Max[i], Max[edge[i][j]]);
            }
            if (t != Max[i])
            {
                b = false;
            }
        }
        if (b)
        {
            break;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        cout << Max[i] << " ";
    }
    return 0;
}
```

---

## 作者：zjp_shadow (赞：2)

话说这题在很后面……好像没啥人做……

思路比较简单 一开始以为直接一个dfs+dp能直接过……可是忘记考虑了有向图中的环的情况结果爆炸了……

提供一个简单数据：

input:
4 4
1 2
2 3
3 1
2 4
output:

4 4 4 4

所以我们需要别的方法来解决

- 很显然 用Tarjan(or Kosaraju)先来缩点，把每个强联通分量

的中点编号最大的作为这个强联通分量的权值，然后在dfs中进行dp，

转移方程就是$dp[u]=\max(dp[u],dp[v])$其中$u$为$v$的儿子，

这个题至此迎刃而解。







    

```cpp
#include <bits/stdc++.h>
#define For(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)
#define Fordown(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)
#define Set(a, v) memset(a, v, sizeof(a))
#define Travel(i, u, G) for(int i = G.Head[u]; i; i = G.Next[i])
//对于多图的访问更加便捷 
using namespace std;
inline int read(){
  int x = 0, fh = 1; char ch;
  for(; !isdigit(ch); ch = getchar()) if (ch == '-') fh = -1;
  for(; isdigit(ch); ch = getchar()) x = (x<<1) + (x<<3) + (ch^'0');
  return x * fh;
}
bool chkmin (int &a, int b) {return b < a ? a = b, 1 : 0; }
bool chkmax (int &a, int b) {return b > a ? a = b, 1 : 0; }
const int N = 100100;
int dp[N];
bool vis[N];
struct graph {
    int to[N], Next[N], Head[N], e;
    void init() {
        Set(Head, 0);
        e = 0;
    }
    void add_edge (int u, int v) {
        to[++e] = v;
        Next[e] = Head[u];
        Head[u] = e;
    }
};
graph G1, G2;
//G1是之前的图，G2是后来重新建的图 
int val[N];
void dfs(int u) {
    if (vis[u]) return ;
    vis[u] = true;
    dp[u] = val[u]; //一开始初始化为它的权值 
    Travel(i, u, G2) {
        int v = G2.to[i];
        dfs(v);
        dp[u] = max(dp[u], dp[v]);
        //动态转移 
    }
}
int lowlink[N], dfn[N], dfs_clock = 0;
int sccno[N], scc_cnt = 0;
stack <int> S;
void Tarjan(int u) {
    dfn[u] = lowlink[u] = ++dfs_clock;
    S.push(u);
    Travel (i, u, G1) {
        int v = G1.to[i];
        if (!dfn[v] ) {
            Tarjan (v);
            chkmin (lowlink[u], lowlink[v]);
        } else if (!sccno[v]) 
            chkmin (lowlink[u], dfn[v]);
    }
    if (lowlink[u] == dfn[u]) {
        ++scc_cnt;
        for(;;) {
            int x = S.top(); S.pop();
            sccno[x] = scc_cnt;
            chkmax (val[scc_cnt], x);
            //把每个联通块的权值置为这个联通块中所有点的最大序号 
            if (x == u) break;
        }
    }
}
//很标准的Tarjan缩点 
void Rebuild (int n) {
    For (i, 1, n)
        Travel (j, i, G1) {
            int u = i, v = G1.to[j];
            if (sccno[u] == sccno[v]) continue;
            G2.add_edge(sccno[u], sccno[v]);
        }
```
}//重建图

    
        
        
        
```cpp
int main(){
    G1.init(); G2.init();
    int n = read(), m = read();
    For (i, 1, m) {
        int u = read(), v = read();
        G1.add_edge (u, v);
    }
    For (i, 1, n)
        if (!dfn[i] ) Tarjan(i);
    Rebuild(n);
    For (i, 1, scc_cnt)
        if (!vis[i] ) dfs(i);
    For (i, 1, n)
        printf ("%d ", dp[sccno[i]]);
        //注意 之后的每个数要去它的强连通分块中 寻找其最大值 
    return 0;
}
```

---

## 作者：EzioAuditoreFirenze (赞：2)

 ## **广搜福利**
 
面对这种题，第一个反应当然是dfs

**但是**

很显然，这道题是有环的

有环的话处理很麻烦，还需要tarjan

//据说STL的set非常快，用set判环也是一种思路，具体会不会TLE就不知道了，毕竟没试过。如果真能成功，这就是很骚的操作了，省时间又省脑子。

**然而**

众所周知，广搜处理有环的问题有得天独厚的优势

### 那么为什么不尝试广搜呢

直接上代码，内附注释


```cpp
#include<bits/stdc++.h>
using namespace std;


int n,m;
bool book[100010];


int q[100010];
//毕竟queue也就几行代码，stl的queue终究还是慢了一点点，我就自己写了


struct edge
{
    int to;
    int next;
}e[100010];
int total=0,head[100010];
void addedge(int x,int y)
{
    e[total].to=y;
    e[total].next=head[x];
    head[x]=total;
    total++;
}
//邻接表存图不多废话了


//广搜重头戏
void bfs(int n)
{
    memset(book,0,sizeof(book));//先把记录数组初始化
    int maximum=n;//任意一个点能到达的最大点不会比自己小
    int head0=0,tail=1;//手写队列
    q[0]=n;
	
    
    //基本广搜算法
    while(head0<tail)
    {
        for(int i=head[q[head0]];i!=-1;i=e[i].next)//邻接表遍历
        {
            if(!book[e[i].to])
            {
                book[e[i].to]=true;
                q[tail]=e[i].to;
                tail++;//入队后队长++
                maximum=max(maximum,e[i].to);
            }
        }
        head0++;//队头出队
    }
    cout<<maximum<<' ';//最后输出结果
}


int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        head[i]=-1;
    for(int i=0,a,b;i<m;i++)
    {
        cin>>a>>b;
        addedge(a,b);
    }
    for(int i=1;i<=n;i++)
        bfs(i);
    return 0;
}
```

---

## 作者：YZL11111 (赞：1)

题目链接：https://www.luogu.com.cn/problem/P3916

## 【题目描述】
给出N个点，M条边的有向图，对于每个点v，求A(v)表示从点v出发，能到达的编号最大的点。

## 【输入格式】
第1 行，2 个整数N,M。

接下来M行，每行2个整数U_i,V_i，表示边(U_i,V_i)。点用1, 2,,N编号。

## 【输出格式】
N 个整数A(1),A(2),⋯,A(N)。

## 【解题思路】
记忆化dfsWA了3发，怒了，索性直接反向建图，从后往前bfs，节点n能到的节点答案一定是n

## 【AC代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 100010;
struct Edge
{
	int to;
	int next;
}edge[maxn];
int head[maxn];
int ans[maxn];
int n, m;
inline void bfs(int s)
{
	queue<int> que;
	que.push(s);
	while (!que.empty())
	{
		int u = que.front();
		que.pop();
		for (int i = head[u]; i; i = edge[i].next)
		{
			int v = edge[i].to;
			if (ans[v]) continue;
			ans[v] = s;
			que.push(v);
		}
	}
	if (!ans[s]) ans[s] = s;
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		edge[i].to = u;
		edge[i].next = head[v];
		head[v] = i;
	}
	for (int i = n; i >= 1; --i) bfs(i);
	for (int i = 1; i <= n; ++i) printf("%d ", ans[i]);
	puts("");
	return 0;
}
```


---

## 作者：薛定谔的鱼 (赞：1)

第一次题解，求过。。。

蒟蒻不会tarjan dp.balabala。。。所以只能来一个dfs了。
**思路：倒着dfs，遍历到的点即为最大。**

为什么嘞？因为是倒着，所以从后往前遍历能遍历到的点，它的值就是当前的点。

其实还是想安利一下前向星存边（虽然这玩意在洛谷里满天飞了）
但是挡不住好用啊




```cpp
#include<bits/stdc++.h>//可爱的万能头
using namespace std;
const int maxn=100100;
int head[maxn],cnt;
void read(int &x)//第十个点太bt，所以用了读入优化
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
struct edge{int to;int next;}e[maxn];
int n,m,x,y;
int maxm[maxn];
void addedge(int from,int to)
{
	e[++cnt].next=head[from];
	e[cnt].to=to;
	head[from]=cnt;
}
void dfs(int now,int ans)//dfs
{
	if(maxx[now])//如果遍历到的点数值不为0，就是在之前遍历过了，那就pass
	return;
	maxm[now]=ans;
	for(int i=head[now];i;i=e[i].next)//前向星跑图
	if(!maxm[e[i].to])
	dfs(e[i].to,ans);
	return;
}
int main()
{
	read(m);read(n);//读入优化
	for(int i=1;i<=n;i++)
	{
		read(x),read(y);//读入优化
		addedge(y,x);//前向星倒存图
	}
	for(int i=m;i;i--)//从后往前dfs
	dfs(i,i);
	for(int i=1;i<=m;i++)
	printf("%d ",maxm[i]);//输出可爱的答案
	return 0;
}
	
```

前向星
```cpp
struct edge{int to;int next;//int dis;}e[maxn];//第i条边的终点,第i条边同起点的下一条边的存储位置
//head[]是i这条边的存储位置。
void addedge(int from,int to)
{
	e[++cnt].next=head[from];
	e[cnt].to=to;
    //e[cnt].dis=dis; 此为无权图，所以...如果是有权图，加上这行。
	head[from]=cnt;
}

for(int i=head[now];i;i=e[i].next)//遍历
```
萌新求过审 qwq

---

## 作者：Tiffany_Tendering (赞：1)

    有人说需要tarjan
    本人也尝试了一下
    好像确实可以 但是感觉不好实现

    但是还有一个方法
    tarjan的作用就是判断环
    所以我们用vis[]数组来记录是否被标记就好了
    
    如果正向的搞 就是那种规规矩矩的建图 跑dfs
    我也没做 估计可能会超时？？
    反正我也不知道
    
    于是我们就考虑反向的做
    从最大的点开始搜索 只要能够搜到的点 那么所搜到的点的最后答案就是这个点
    口述麻烦 
    看代码
    
    
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<cstring>
    using namespace std;
    const int maxn = 100005 ;
    int n,m,head[maxn],top,sum,ans[maxn];  //ans[]记录的是某个点的答案 
    struct edge{
	    int to,next;
    }e[maxn];

    void add_edge(int u,int v) {
	    e[++top].to = v;
	    e[top].next = head[u] ;
	    head[u] = top ;
    }

    void dfs(int u,int sum) {
	    if(ans[u]) return ;
	    ans[u] = sum ;
	    for(int i = head[u]; i ;i = e[i].next) {
		    if(!ans[e[i].to]) 
		      dfs(e[i].to,sum) ;
	    }
	    return ;
    }

    int main() {
	    scanf("%d%d",&n,&m) ;
	    for(int i = 1;i <= m ;++i) {
		    int x,y; scanf("%d%d",&x,&y) ;
		     add_edge(y , x) ;  //反向即可 
	    }
	    for(int i = n;i >= 1; --i) {
		    if(ans[i]) continue;   
		    dfs( i , i ) ;  //目前为止是哪个点 以及目前为止的答案 
    	}
	    for(int i = 1;i <= n ;++i) printf("%d ",ans[i]) ;
	    return 0;
    }

---

## 作者：wangxuye (赞：1)

## 题目大意

向图中所有点能够到达的节点的最大编号

一看到这个**最大编号**，就想到了tarjan算法中的low数组，于是就考虑用tarjan来缩点。

缩完点以后得到了一张有向无环图，所以我们只要以0为超级源点，向所有入度为0的节点，然后做一次树规就行了。

### 转移方程：f [ x ] = max ( f [ y ] , d [ x ] ) (y∈son [ x ] , d [ x ] 表示编号为x的强连通分量中的最大原节点编号

下面上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=1000010;

int head[N],ver[M],next[M],dfn[N],low[N],c[N];
int headc[N],verc[M],nextc[M],valuec[N];
int n,m,tot,totc,num;
int sta[N],top;
bool ins[N];
vector<int> scc[N];
int cnt;
int f[N],in[N];
bool visit[N];

void add(int x,int y) //原来的边
{
	ver[++tot]=y,next[tot]=head[x],head[x]=tot;
}

void add_c(int x,int y) //缩点后的边
{
	verc[++totc]=y,nextc[totc]=headc[x],headc[x]=totc,in[y]++;
}

void tarjan(int x) //tarjan缩点
{
	dfn[x]=low[x]=++num;
	sta[++top]=x,ins[x]=true;
	for(int i=head[x];i;i=next[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y]) low[x]=min(low[x],low[y]);
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		int y;
		for(;x!=y;)
		{
			y=sta[top--],ins[y]=false;
			c[y]=cnt,scc[cnt].push_back(y);
			valuec[cnt]=max(valuec[cnt],y);
		}
	}
}

void init() //初始化不要介意
{
	memset(head,0,sizeof(head));
	memset(ver,0,sizeof(ver));
	memset(next,0,sizeof(next));
	memset(headc,0,sizeof(headc));
	memset(verc,0,sizeof(verc));
	memset(nextc,0,sizeof(nextc));
	memset(sta,0,sizeof(sta));
	memset(ins,false,sizeof(ins));
	memset(c,0,sizeof(c));
	memset(f,0,sizeof(f));
	memset(visit,false,sizeof(visit));
	memset(in,0,sizeof(in));
	for(int i=1;i<=n;i++) scc[i].clear();
	tot=totc=top=num=cnt=0;
}

void dp(int x) //树规
{
	f[x]=valuec[x];
	visit[x]=true;
	for(int i=headc[x];i;i=nextc[i])
	{
		int y=verc[i];
		if(!visit[y]) dp(y);
		f[x]=max(f[x],f[y]);
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	init();
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	for(int x=1;x<=n;x++)
	{
		for(int i=head[x];i;i=next[i])
		{
			int y=ver[i];
			if(c[x]==c[y]) continue;
			add_c(c[x],c[y]);
		}
	}
	for(int i=1;i<=n;i++)
		if(!in[i]) add_c(0,i);
	dp(0);
	for(int i=1;i<=n;i++)
		printf("%d ",f[c[i]]);
	printf("\n");
	return 0;
}
```

---

## 作者：redegg (赞：1)

就我线段树吗？（嗯？？？这和线段树有啥关系？）

~~其实不用线段树的，用二分也可以~~

一开始我还真的傻傻地去跑强连通分量，然后太菜写炸了，于是换了一种思路，既然我们要求每个点能到多大的点，不如从当前最大的点遍历一遍，赋值，然后再从剩下的未被赋值的点中选出最大的，然后继续遍历，一直这样知道全部遍历，这样反向来不仅可以减小复杂度，而且对于在不在一张图上没有要求。

于是为了求出剩下点的最大编号，我选择了线段树。

剩下的反方向dfs一遍，直接赋值，完。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int t[500000];
vector<int> q[200000];
void build(int l,int r,int id)
{
    if(l==r)
    {
        t[id]=l;
        return ;
    }
    int mid=(l+r)/2;
    build(l,mid,id*2);
    build(mid+1,r,id*2+1);
    t[id]=max(t[id*2],t[id*2+1]);
}

void update(int l,int r,int x,int id)
{
    if(l==r&&l==x)
    {
        t[id]=-1e9;
        return ;
    }
    int mid=(l+r)/2;
    if(x<=mid) update(l,mid,x,id*2);
    else update(mid+1,r,x,id*2+1);
    t[id]=max(t[id*2],t[id*2+1]);
}

bool b[100005];
int ans[100005];

void dfs(int x,int f,int last)
{
    update(1,n,x,1);
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==last)continue;
        if(b[nx])continue;
        b[nx]=1;
        ans[nx]=f;
        dfs(nx,f,x);
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    build(1,n,1);
    for(int i =1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        q[y].push_back(x);
    }
    while(1)
    {
        int k=t[1];
        if(k<=0)break;
        b[k]=1;
        ans[k]=k;
        dfs(k,k,k);
    }
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    printf("\n");
    return 0;
}

```

---


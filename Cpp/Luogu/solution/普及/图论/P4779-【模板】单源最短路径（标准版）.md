# 【模板】单源最短路径（标准版）

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 说明/提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# 题解

## 作者：little_sun (赞：1078)

### 前言

*   $SPFA$算法由于它上限 $O(NM) = O(VE)$的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:$dijkstra$.

### 什么是$dijkstra$?

*   $dijkstra$是一种单源最短路径算法,时间复杂度上限为$O(n^2)$(朴素),在实际应用中较为稳定$;$加上堆优化之后更是具有$O((n+m)\log_{2}n)$的时间复杂度,在稠密图中有不俗的表现.

### $dijkstra$的原理/流程?

*   $dijkstra$本质上的思想是贪心,它只适用于不含负权边的图.
*   我们把点分成两类,一类是已经确定最短路径的点,称为"白点",另一类是未确定最短路径的点,称为"蓝点"
*   $dijkstra$的流程如下$:$
*   $1.$ 初始化$dis[start] = 0,$其余节点的$dis$值为无穷大.
*   $2.$ 找一个$dis$值最小的蓝点$x,$把节点$x$变成白点.
*   $3.$ 遍历$x$的所有出边$(x,y,z),$若$dis[y] > dis[x] + z,$则令$dis[y] = dis[x] + z$
*   $4.$ 重复$2,3$两步,直到所有点都成为白点$.$
*   时间复杂度为$O(n^2)$

### $dijkstra$为什么是正确的

*   当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第$2$步中找出的蓝点$x$必然满足$:dis[x]$已经是起点到$x$的最短路径$.$我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度

### 图解

*   (令$start = 1$)
*   开始时我们把$dis[start]$初始化为$0$,其余点初始化为$inf$
![初始化](https://i.loli.net/2018/07/25/5b583277e47e9.png)
*   第一轮循环找到$dis$值最小的点$1$,将$1$变成白点,对所有与$1$相连的蓝点的$dis$值进行修改,使得$dis[2]=2,dis[3]=4,dis[4]=7$
![1](https://i.loli.net/2018/07/25/5b58347b9a37b.png)
*   第二轮循环找到$dis$值最小的点$2$,将$2$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[3]=3,dis[5]=4$
![2](https://i.loli.net/2018/07/25/5b586fa8de335.png)
*   第三轮循环找到$dis$值最小的点$3$,将$3$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[4]=4$
![3](https://i.loli.net/2018/07/25/5b58703e8d0d6.png)
*   接下来两轮循环分别将$4,5$设为白点,算法结束,求出所有点的最短路径
*   时间复杂度$O(n^2)$

### 为什么$dijkstra$不能处理有负权边的情况?
*    我们来看下面这张图
![4](https://i.loli.net/2018/07/25/5b58724845b8d.png)
*   $2$到$3$的边权为$-4$,显然从$1$到$3$的最短路径为$-2$ $(1->2->3).$但在循环开始时程序会找到当前$dis$值最小的点$3$,并标记它为白点.
*   这时的$dis[3]=1,$然而$1$并不是起点到$3$的最短路径.因为$3$已经被标为白点,所以$dis[3]$不会再被修改了.我们在边权存在负数的情况下得到了错误的答案.

### $dijkstra$的堆优化?

*   观察$dijkstra$的流程,发现步骤$2$可以优化
*   怎么优化呢?
*   ~~我会zkw线段树!我会斐波那契堆!~~
*   我会堆!
*   我们可以用堆对$dis$数组进行维护,用$O(\log_{2}n)$的时间取出堆顶元素并删除,用$O(\log_{2}n)$遍历每条边,总复杂度$O((n+m)\log_{2}n)$

*  范例代码:

``` cpp
#include<bits/stdc++.h>

const int MaxN = 100010, MaxM = 500010;

struct edge
{
    int to, dis, next;
};

edge e[MaxM];
int head[MaxN], dis[MaxN], cnt;
bool vis[MaxN];
int n, m, s;

inline void add_edge( int u, int v, int d )
{
    cnt++;
    e[cnt].dis = d;
    e[cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

struct node
{
    int dis;
    int pos;
    bool operator <( const node &x )const
    {
        return x.dis < dis;
    }
};

std::priority_queue<node> q;


inline void dijkstra()
{
    dis[s] = 0;
    q.push( ( node ){0, s} );
    while( !q.empty() )
    {
        node tmp = q.top();
        q.pop();
        int x = tmp.pos, d = tmp.dis;
        if( vis[x] )
            continue;
        vis[x] = 1;
        for( int i = head[x]; i; i = e[i].next )
        {
            int y = e[i].to;
            if( dis[y] > dis[x] + e[i].dis )
            {
                dis[y] = dis[x] + e[i].dis;
                if( !vis[y] )
                {
                    q.push( ( node ){dis[y], y} );
                }
            }
        }
    }
}


int main()
{
    scanf( "%d%d%d", &n, &m, &s );
    for(int i = 1; i <= n; ++i)dis[i] = 0x7fffffff;
    for( register int i = 0; i < m; ++i )
    {
        register int u, v, d;
        scanf( "%d%d%d", &u, &v, &d );
        add_edge( u, v, d );
    }
    dijkstra();
    for( int i = 1; i <= n; i++ )
        printf( "%d ", dis[i] );
    return 0;
}

```
### 例题
*   入门模板:P3371
*   进阶模板:P4779
*   其余例题请右转洛谷题库,搜索"最短路"

### 后记
*   本文部分内容摘自李煜东《算法竞赛进阶指南》和《信息学竞赛一本通》
*   友情提示:正权图请使用$dijkstra$算法,负权图请使用$SPFA$算法
*   感谢洛谷各位管理员提供的平台
### [博客传送门](https://www.cnblogs.com/little-sun0331/p/9484730.html)
### [个人博客](https://www.cnblogs.com/little-sun0331/)

---

## 作者：2018一维 (赞：226)



# 单源最短路算法——Dijkstra


------------

## 实现方法：
**1.**定义ans[100000]，ans[i]代表到达i点的最小花费

**2.**定义bool数组visit，代表是否来过这里

**2.**ans[起点]=0,其余的赋值为inf

**3.**定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。

**4.**列举所有与curr相联通的的点，将这些点(i)的ans值更新：

$ ans[i]=min(ans[i],ans[curr]+ $到这些点需要的花费 $)$

**5.** 列举所有访问过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过）

**6** 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径


------------

## 伪代码
```cpp
bool vis[1000000];//是否访问过
int ans[1000000];
int curr=起点;
memset(ans,0x7fffffff,sizeof(ans))
while(vis[curr]==0)
{
	vis[curr]=1;
	for(int i;列举所有curr连通的点）
    {
    	ans[i]=min(ans[i],ans[curr]+k)//k代表从curr点到i点的最短路
    }
    int minn=2147483647;
    for(int i=1;i<=m;i++)//列举所有点
    {
    	if(vis[i]==1&&ans[i]<minn)//访问过且小
        {
        	minn=ans[i];//更新最小值
            curr=i;//更新下一个点
        }
    }
}

```


------------

## 存图方式
链式前向星
**以下是关于链式前向星的介绍 ，会的可以跳过：**
 


## 边的存储

这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。


在链式前向星存图中，我们需要定义一个结构体：
```cpp
struct EDGE 
{
    int next;
    int to;
}edge[1000000];
```
和一个数组：
```cpp
int head[1000000];
```
和一个变量：
```cpp
int cnt=0;//指针
```
你会发现竟然没存起点！！其实起点是用$head$存的
 ### 举例：
 ![](https://cdn.luogu.com.cn/upload/pic/43957.png   )


如图：这样的一个有向图，输入是：

```
1 2
1 3
1 4
2 3
```

### 逐步分析：

#### 1.输入1 2，代表1连向2。
```cpp
cnt++;//作为结构体下标，没有意义
head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面
edge[cnt].to=2;结点1的儿子是2
```
此时：
$cnt=1$

| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $0$| $ 0$| $0$ |
|  $next$|$ 0 $|$0 $ | $0$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $1 $|$ 0 $|$ 0 $|$ 0 $|



#### 2.输入1 3，代表1连向3。
```cpp
cnt++;
head[1]=cnt;
edge[cnt].to=3;结点1的儿子是3
//这时,3成为了结点1的儿子，不过2被挤了下去...
//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2
//所以代码要换成：
cnt++;
edge[cnt].to=3;//结点1连向3
edge[cnt].next=head[1];//3的兄弟是2
head[1]=cnt;//更新head
```

此时：
$cnt=2$

| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $3$| $ 0$| $0$ |
|  $next$|$ 0 $|$1 $ | $0$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $2 $|$ 0 $|$ 0 $|$ 0 $|



#### 3.输入1 4，代表1连向4。

此时：
$cnt=3$



| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $3$| $ 4$| $0$ |
|  $next$|$ 0 $|$1 $ | $2$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $3 $|$ 0 $|$ 0 $|$ 0 $|


#### 4.输入2 3，代表2连向3。

此时：
$cnt=4$

| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $3$| $ 4$| $3$ |
|  $next$|$ 0 $|$1 $ | $2$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $3 $|$ 4 $|$ 0 $|$ 0 $|



### 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$


#### 若需要记录权值，在结构体中加入一个元素即可

代码：(带权值）
```cpp
#include<iostream>
using namespace std;
struct edge 
{ 
    int next;
    int to;
    int wei;
}edge[MAXM];
int head[MAXN];//head[i]为i点的第一条边
int cnt=0;
void addedge(int u,int v,int w) //起点，终点，权值 
{
    edge[++cnt].next=head[u];//更新cnt
    edge[cnt].to=v;
    edge[cnt].w=w;
    head[u]=cnt;
}
int main()
{
	int n;
    for(int i=1;i<=n;i++)
    {
    	int a,b,wei;
        addedge(a,b,wei);
        //如果是无向图，还要addedge(b,a,wei);
    }
}
```
 
#### 注意：
 
 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。



------------

## 边的遍历

在遍历以x为起点的所有边时，只需要这样就行

		for(int i=head[x];i!=0;i=edge[i].next)

这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。




------------

## 优势与特点


既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。

 

------------

## 代码
```cpp
#include<iostream>
using namespace std;
int head[100000],cnt;
long long ans[1000000];
bool vis[1000000];
int m,n,s;
struct edge
{
	int to;
	int nextt;
	int wei;
}edge[1000000];
void addedge(int x,int y,int z)
{
	edge[++cnt].to=y;
	edge[cnt].wei=z;
	edge[cnt].nextt=head[x];
	head[x]=cnt;
}
int main()
{
	cin>>m>>n>>s;
	for(int i=1;i<=n;i++)
	{
		ans[i]=2147483647;
	}
	ans[s]=0;
	for(int i=1;i<=n;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		addedge(a,b,c);
	}
	int pos=s;
	while(vis[pos]==0)
	{
		long long minn=2147483647;
		vis[pos]=1;
		for(int i=head[pos];i!=0;i=edge[i].nextt)
		{
			if(!vis[edge[i].to]&&ans[edge[i].to]>ans[pos]+edge[i].wei)
			{
				ans[edge[i].to]=ans[pos]+edge[i].wei;
			}
		}
		for(int i=1;i<=m;i++)
		{
			if(ans[i]<minn&&vis[i]==0)
			{
				minn=ans[i];
				pos=i;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		cout<<ans[i]<<' ';
	}
}
```
以上是Dijkstra的基础介绍，上面的这份代码是不加优化的Dijkstra，能通过
[P3371单源最短路径（弱化版）](https://www.luogu.org/problemnew/show/P3371)
不过在这道题中会TLE。

### 优化


在上面第五步中：
`5. 列举所有访问过的的点，找到ans值最小的点`

这一步由于每次都要遍历一遍所有点，复杂度为$O(n)$

不过可以用堆（STL：优先队列）进行优化，复杂度为$O(logn)$

#### 简单介绍优先队列

一种数据结构，支持找出数列中最大值，弹出最大值

重载运算符后还可以维护最小值


- 代码：

头文件
```cpp
#include<queue>
```

定义
```cpp
priority_queue<int> q;
```

加入
```cpp
q.push(a);
```
弹出最大值
```cpp
q.pop()
```

查询最大值
```
q.top()
```

详细的可看[P3378 【模板】堆](https://www.luogu.org/problemnew/show/P3378)

### 代码

对以上代码加入堆优化：

由于每个点有两个值需要存储（$ans$值，点的编号）,所以要用结构体

由于要找最小的点，所以用优先队列时需要重载运算符：
```cpp
struct node
{
    int ans;//ans值
    int id;//点编号
    bool operator <(const node &x)const//重载运算符
    {
        return x.ans<ans;
    }
};
```

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int head[100000],cnt;
long long ans[1000000];
bool vis[1000000];
int m,n,s;
struct edge
{
	int to;
	int nextt;
	int wei;
}edge[1000000];
struct priority
{
    int ans;
    int id;
    bool operator <(const priority &x)const
    {
        return x.ans<ans;
    }
};
void addedge(int x,int y,int z)
{
	edge[++cnt].to=y;
	edge[cnt].wei=z;
	edge[cnt].nextt=head[x];
	head[x]=cnt;
}

priority_queue<priority> q;

int main()
{
	cin>>m>>n>>s;
	for(int i=1;i<=n;i++)
	{
		ans[i]=2147483647;
	}
	ans[s]=0;
	for(int i=1;i<=n;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		addedge(a,b,c);
	}
	int u;
	q.push((priority){0,s});
    while(!q.empty())
    {
        priority temp=q.top();
        q.pop();
        u=temp.id;
        if(!vis[u])
        {
        	vis[u]=1;
	        for(int i=head[u];i;i=edge[i].nextt)
	        {
	            int v=edge[i].to;
	            if(ans[v]>ans[u]+edge[i].wei)
	            {
	                ans[v]=ans[u]+edge[i].wei;
	                if(!vis[v])
	                {
	                    q.push((priority){ans[v],v});
	                }
	            }
	        }
		}
    }
	for(int i=1;i<=m;i++)
	{
		cout<<ans[i]<<' ';
	}
}
```


#### 感谢收看..


---

## 作者：违规用户名U56916 (赞：174)

**为什么洛谷要出两道模板题？？**

据说这道题数据有毒，卡SPFA，幸好我更喜欢dijstra，可看数据范围，很不友好的n和m，怎么办呢？

出现吧 堆优化 **priority_queue**（STL大法好）~~手打堆太麻烦~~

好吧，我主要想说的是第三个数据点，这个点真的有毒

数据范围约定 

0<wi<1*10^9

∑wi<1*10^9

完全木有必要开long long

那么我们可以用memset初始化最大值0x3f或0x7f

个人更喜欢0x3f因为不会加爆出int，可是第三个点WA了

为什么呢？

于是用0x7f

又WA（捂脸）~~这次应该是爆了~~

问题出在哪呢？

看讨论里说数据是不连通的，我觉得不是，更有可能是那个点的最短路很大，0x3f不够，而0x7f会爆，怎么办呢？

乖乖for循环吧！！

for循环赋值成1e10，绝对没问题了

事实证明，si这样di

AC代码贴上

```
#include<bits/stdc++.h>
#define M(x,y) make_pair(x,y)
using namespace std;
int fr[100010],to[200010],nex[200010],v[200010],tl,d[100010];
bool b[100010];
void add(int x,int y,int w){
    to[++tl]=y;
    v[tl]=w;
    nex[tl]=fr[x];
    fr[x]=tl;
}
priority_queue< pair<int,int> > q;
int main(){
    int n,m,x,y,z,s;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    for(int i=1;i<=n;i++) d[i]=1e10;
    d[s]=0;
    q.push(M(0,s));
    while(!q.empty()){
        int x=q.top().second;
        q.pop(); 
        if(b[x]) continue;
        b[x]=1;
        for(int i=fr[x];i;i=nex[i]){
            int y=to[i],l=v[i];
            if(d[y]>d[x]+l){
                d[y]=d[x]+l;
                q.push(M(-d[y],y));//懒得重载运算符
            }
        }
    }
    for(int i=1;i<=n;i++) printf("%d ",d[i]);
    return 0;
}
```

~~自认代码风格很好~~

---

## 作者：ACAね (赞：130)

# spfa的复活之路

## 警告，如果你没有学会用dijkstra堆优化不建议看此篇题解

### ~~一篇诡异的非正解~~

### 因为本人很弱，所以有一些自以为是的地方，希望大家指出，但是不要乱喷...,我会改的

在三页的提交后终于用spfa切掉了这道题。。。

首先我先尝试使用了~~玄学(LLL,SLF?)~~优化，均只有68~48分，无意中发现

# [这个](https://www.luogu.org/record/show?rid=8793733)

发现数据都特意卡掉了

那就只能自食其力了

我们发现所有卡掉spfa的数据，就是诱导算法进入一个持续更新的地方

于是我尝试新加入的点入队头（dfs版）.

同时如果dis[head]>dis[tail],则交换head与tail

[似乎多过了一个诶](https://www.luogu.org/recordnew/show/11854571)

之后我发现第一个数据非常毒瘤，死活卡不过去，因为数据太大，下不下来

但是我们可以下载输出啊!

经过一番观(xia)察(gao)

之所以卡掉前面的交换的程序，是因为这个头dis>尾dis的很多。

于是我以0.01%的概率排序整个队列，我们惊喜的发现，[点1过了!](https://www.luogu.org/record/show?rid=11854835)

但是点3T飞

后来发现这个时间复杂度是错误的，被dijkstra爆踩

于是我们以$1\div(tail-head+1)$的概率排序队列，这个的期望复杂度是log的

因为sort的速度快于堆排（误

所以好像速度比dijkstra 的配对堆优化要快80ms

[玄学spfa](https://www.luogu.org/recordnew/show/11855010)

[pairing_heap_dijkstra](https://www.luogu.org/record/show?rid=11846688)

运用了fread和不开long long后似乎可以抢rank?

210ms左右

dijkstra

```cpp
// luogu-judger-enable-o2
/*
@Date    : 2018-10-13 17:42:26
@Author  : Adscn (1349957827@qq.com)
@Link    : https://www.cnblogs.com/LLCSBlog
*/
#define FASTER
#ifdef FASTER
#pragma GCC diagnostic error "-std=c++11"
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#endif
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
#define IL inline
#define RG register
#define gi getint()
#define gc getchar()
#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
IL int getint()
{
    RG int xi=0;
    RG char ch=gc;
    bool f=0;
    while(ch<'0'|ch>'9')ch=='-'?f=1:f,ch=gc;
    while(ch>='0'&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
    return f?-xi:xi;
}
IL void pi(int k,char ch=0)
{
    if(k<0)k=-k,putchar('-');
    if(k>=10)pi(k/10,0);
    putchar(k%10+'0');
    if(ch)putchar(ch);
}
IL unsigned int LOG2(unsigned int x)
{
    unsigned int ret;
    __asm__ __volatile__ ("bsrl %1, %%eax":"=a"(ret):"m"(x));
    return ret;
}
typedef long long ll;
class graph{
private:
    struct edge{
        int v;
        edge *next;
        int w;
    }e[200007],*head[200007];
    int cnt;
public:
    graph(){cnt=0;}
    void add(int u,int v,int w=0)
    {
        e[cnt]=((edge){v,head[u],w});
        head[u]=&e[cnt++];
    }
    edge* begin(int u){return head[u];}
    edge* end(){return NULL;}
    class iterator{
    public:
        friend class graph;
        iterator(edge* p=NULL):__ptr(p){}
        iterator (const iterator &p):__ptr(p.__ptr){}
        iterator& operator ++()
        {
            __ptr=__ptr->next;
            return *this;
        }
        iterator operator ++(int)
        {
            iterator __tmp=(*this);
            ++(*this);
            return __tmp;
        }
        edge* operator ->(){return __ptr;}
        edge& operator * (){return *__ptr;}
        bool operator ==(const iterator &p){return __ptr==p.__ptr;}
        bool operator != (const iterator &p){return __ptr!=p.__ptr;}
    private:
        edge *__ptr;
    };
}g;
const int MAXN=100000+7;
typedef pair<ll,int> pii;
__gnu_pbds::priority_queue<pii,greater<pii> >q;
int n,m,s;
ll dis[MAXN];
bool vis[MAXN];
void dijkstra()
{
    memset(dis,0x7f7f7f,sizeof dis);
    q.push(make_pair(0,s));
    dis[s]=0;
    while(!q.empty())
    {
        int now=q.top().second;q.pop();
        if(vis[now])continue;
        vis[now]=1;
        for(graph::iterator i=g.begin(now);i!=g.end();++i)
        {
            int v=i->v;
            if(dis[v]>dis[now]+i->w)dis[v]=dis[now]+i->w,q.push(make_pair(dis[v],v));
        }
    }
}
int main(void)
{
	n=gi,m=gi,s=gi;
	for(int i=1;i<=m;i++)
	{
		int u=gi,v=gi,w=gi;
		g.add(u,v,w);
	}
    dijkstra();
	for(int i=1;i<=n;i++)pi(dis[i],' ');	
    return 0;
}
```

伪dfs版spfa
```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
#define IL inline
#define RG register
#define gi getint()
#define gc getchar()
#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
IL int getint()
{
    RG int xi=0;
    RG char ch=gc;
    bool f=0;
    while(ch<'0'|ch>'9')ch=='-'?f=1:f,ch=gc;
    while(ch>='0'&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
    return f?-xi:xi;
}
IL void pi(int k,char ch=0)
{
    if(k<0)k=-k,putchar('-');
    if(k>=10)pi(k/10,0);
    putchar(k%10+'0');
    if(ch)putchar(ch);
}
IL unsigned int LOG2(unsigned int x)
{
    unsigned int ret;
    __asm__ __volatile__ ("bsrl %1, %%eax":"=a"(ret):"m"(x));
    return ret;
}
typedef long long ll;
class graph{
private:
    struct edge{
        int v;
        edge *next;
        int w;
    }e[200007],*head[200007];
    int cnt;
public:
    graph(){cnt=0;}
    void add(int u,int v,int w=0)
    {
        e[cnt]=((edge){v,head[u],w});
        head[u]=&e[cnt++];
    }
    edge* begin(int u){return head[u];}
    edge* end(){return NULL;}
    class iterator{
    public:
        friend class graph;
        iterator(edge* p=NULL):__ptr(p){}
        iterator (const iterator &p):__ptr(p.__ptr){}
        iterator& operator ++()
        {
            __ptr=__ptr->next;
            return *this;
        }
        iterator operator ++(int)
        {
            iterator __tmp=(*this);
            ++(*this);
            return __tmp;
        }
        edge* operator ->(){return __ptr;}
        edge& operator * (){return *__ptr;}
        bool operator ==(const iterator &p){return __ptr==p.__ptr;}
        bool operator != (const iterator &p){return __ptr!=p.__ptr;}
    private:
        edge *__ptr;
    };
}g;
const int MAXN=100000+7;
int q[20000000];
int n,m,s;
ll dis[MAXN];
bool vis[MAXN];
void dijkspfa()
{
    memset(dis,0x7f7f7f,sizeof dis);
    int l=0,r=0;
    q[l]=s;
    dis[s]=0;
    while(l<=r)
    {
        if(dis[q[l]]>dis[q[r]])swap(q[l],q[r]);
        int now=q[l++];
        vis[now]=0;
        for(graph::iterator i=g.begin(now);i!=g.end();++i)
        {
            int v=i->v;
            if(dis[v]>dis[now]+i->w)
            {
                dis[v]=dis[now]+i->w;
                if(!vis[v])
                {
                    vis[v]=1;
                    if(l>1&&rand()%10)q[--l]=v;
                    else q[++r]=v;
                }
            }
        }
    }
}
int main(void)
{
       srand(time(0));
   	n=gi,m=gi,s=gi;
   	for(int i=1;i<=m;i++)
   	{
   		int u=gi,v=gi,w=gi;
   		g.add(u,v,w);
   	}
   	dijkspfa();
   	for(int i=1;i<=n;i++)pi(dis[i],' ');
       return 0;
}
```
#AC spfa
```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
#define IL inline
#define RG register
#define gi getint()
#define gc getchar()
#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
IL int getint()
{
    RG int xi=0;
    RG char ch=gc;
    bool f=0;
    while(ch<'0'|ch>'9')ch=='-'?f=1:f,ch=gc;
    while(ch>='0'&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
    return f?-xi:xi;
}
IL void pi(int k,char ch=0)
{
    if(k<0)k=-k,putchar('-');
    if(k>=10)pi(k/10,0);
    putchar(k%10+'0');
    if(ch)putchar(ch);
}
IL unsigned int LOG2(unsigned int x)
{
    unsigned int ret;
    __asm__ __volatile__ ("bsrl %1, %%eax":"=a"(ret):"m"(x));
    return ret;
}
typedef long long ll;
class graph{
private:
    struct edge{
        int v;
        edge *next;
        int w;
    }e[200007],*head[200007];
    int cnt;
public:
    graph(){cnt=0;}
    void add(int u,int v,int w=0)
    {
        e[cnt]=((edge){v,head[u],w});
        head[u]=&e[cnt++];
    }
    edge* begin(int u){return head[u];}
    edge* end(){return NULL;}
    class iterator{
    public:
        friend class graph;
        iterator(edge* p=NULL):__ptr(p){}
        iterator (const iterator &p):__ptr(p.__ptr){}
        iterator& operator ++()
        {
            __ptr=__ptr->next;
            return *this;
        }
        iterator operator ++(int)
        {
            iterator __tmp=(*this);
            ++(*this);
            return __tmp;
        }
        edge* operator ->(){return __ptr;}
        edge& operator * (){return *__ptr;}
        bool operator ==(const iterator &p){return __ptr==p.__ptr;}
        bool operator != (const iterator &p){return __ptr!=p.__ptr;}
    private:
        edge *__ptr;
    };
}g;
const int MAXN=100000+7;
int q[30000000];
int n,m,s;
ll dis[MAXN];
bool vis[MAXN];
bool cmp(int l,int r){return dis[l]<dis[r];}
void spfa()
{
    memset(dis,0x7f7f7f,sizeof dis);
    RG int l=0,r=0;
    q[l]=s;
    dis[s]=0;
    while(l<=r)
    {
        if(rand()%((r-l+1>>3)+1)==0)sort(q+l,q+r+1,cmp);
        int now=q[l++];
        vis[now]=0;
        for(RG graph::iterator i=g.begin(now);i!=g.end();++i)
        {
            int v=i->v;
            if(dis[v]>dis[now]+i->w)
            {
                dis[v]=dis[now]+i->w;
                if(!vis[v])
                {
                    vis[v]=1;
                    if(l>1)q[--l]=v;
                    else q[++r]=v;
                }
            }
        }
    }
}
int main(void)
{
    srand(19260817);
    n=gi,m=gi,s=gi;
    for(int i=1;i<=m;i++)
    {
        int u=gi,v=gi,w=gi;
        g.add(u,v,w);
    }
    spfa();
    for(int i=1;i<=n;i++)pi(dis[i],' ');
    return 0;
}
```

---

## 作者：GKxx (赞：93)

### 本题解已更新 2018.11.18

是时候来一篇**线段树**的题解了。

线段树的效率还是挺优秀的，至少我自己测下来比我原来写的优先队列快。

先考虑一下如果要优化dijkstra算法，优先队列需要哪些操作，让线段树来实现它们。

- 查询队列是否为空，即还有没有要用来松弛其它点的点。

- 取出dist值最小的元素，并删除

- 修改一个点的dist值

如果我们用线段树来维护dist数组，那么修改操作就是非常简单的单点修改。我们只要用线段树来维护区间dist最小元素是谁(minpos，简称mp)即可。

但是线段树是不支持删除元素的，我们可以把dist[0]设置为恒为inf，如果要删除一个元素只要让它对应的叶节点mp值=0即可。这样的话就会保证查询dist最小元素的时候一定不会查到它；如果查到它就说明“优先队列”已经空了。

这是普通线段树的版本

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define dwn(I, A, B) for (int I = (A); I >= (B); --I)
#define erp(I, X) for (int I = head[X]; I; I = next[I])

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> void writeln(T x) {
    write(x);
    puts("");
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

const int maxn = 1e5 + 207, maxm = 2e5 + 207, inf = INT_MAX;
int v[maxm], w[maxm], head[maxn], next[maxm], tot;
int dist[maxn], mp[maxn << 2];
int n, m, s;

inline void ae(int x, int y, int z) {
    v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot;
}
inline int cmp(int a, int b) { return dist[a] < dist[b] ? a : b; }
inline void upd(int x) { mp[x] = cmp(mp[x << 1], mp[x << 1 | 1]); }
void modify(int o, int l, int r, int pos, int val) {
    if (l == r) { mp[o] = val; return; }
    int mid = (l + r) >> 1;
    if (pos <= mid) modify(o << 1, l, mid, pos, val);
    else modify(o << 1 | 1, mid + 1, r, pos, val);
    upd(o);
}
inline void dijkstra(int s) {
    rep(i, 0, n) dist[i] = inf;
    dist[s] = 0; modify(1, 1, n, s, s);
    rep(t, 1, n - 1) {
        int x = mp[1]; modify(1, 1, n, x, 0);
        // 注意chkMin函数中已对dist[v[i]]赋值。
        erp(i, x) if (chkMin(dist[v[i]], dist[x] + w[i]))
            modify(1, 1, n, v[i], v[i]);
    }
}

int main() {
    read(n, m, s);
    rep(i, 1, m) {
        int x, y, z; read(x, y, z); ae(x, y, z);
    }
    dijkstra(s);
    rep(i, 1, n) write(dist[i]), putchar(' ');
    puts("");
    return 0;
}
```

下面是zkw线段树的版本，比普通线段树快。（长达30行的程序头已略去）

参考了@Kelin大佬的写法，在这里表示感谢和膜拜。

```cpp
const int maxn = 1e5 + 207, maxm = 2e5 + 207, inf = INT_MAX;
int v[maxm], w[maxm], head[maxn], next[maxm], tot;
int dist[maxn], mp[maxn << 2], M = 1;
int n, m, s;

inline void ae(int x, int y, int z) { v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot; }
inline int cmp(int a, int b) { return dist[a] < dist[b] ? a : b; }
inline void build(int n) {
	while (M < n + 2) M <<= 1;
    mp[0] = n + 1;
}
inline void modify(int x, int nv) {
	for (int i = x + M; dist[mp[i]] > nv; i >>= 1)
    	mp[i] = x;
    dist[x] = nv;
}
inline void del(int x) {
	for (mp[x += M] = 0, x >>= 1; x; x >>= 1)
    	mp[x] = cmp(mp[x << 1], mp[x << 1 | 1]);
}
inline void dijkstra(int s) {
    rep(i, 0, n) dist[i] = inf;
    build(n); modify(s, 0);
    rep(t, 1, n - 1) {
        int x = mp[1]; del(x);
        // 这里没有对dist[v[i]]赋值，赋值操作在modify函数里进行，与上一个代码有所区别
        erp(i, x) if (dist[v[i]] > dist[x] + w[i])
            modify(v[i], dist[x] + w[i]);
    }
}

int main() {
    read(n, m, s);
    rep(i, 1, m) {
        int x, y, z; read(x, y, z); ae(x, y, z);
    }
    dijkstra(s);
    rep(i, 1, n) write(dist[i]), putchar(' ');
    puts("");
    return 0;
}
```

另附强势压行版本。~~4行线段树你没有看错~~

```cpp
const int maxn = 1e5 + 207, maxm = 2e5 + 207, inf = INT_MAX;
int v[maxm], w[maxm], head[maxn], next[maxm], tot;
int dist[maxn], mp[maxn << 2], M = 1;
int n, m, s;

inline void ae(int x, int y, int z) { v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot; }
inline int cmp(int a, int b) { return dist[a] < dist[b] ? a : b; }
inline void build(int n) { while (M < n + 2) M <<= 1; mp[0] = n + 1; }
inline void modify(int x, int nv) { for (int i = x + M; dist[mp[i]] > nv; i >>= 1) mp[i] = x; dist[x] = nv; }
inline void del(int x) { for (mp[x += M] = 0, x >>= 1; x; mp[x] = cmp(mp[x << 1], mp[x << 1 | 1]), x >>= 1); }
inline void dijkstra(int s) {
    rep(i, 0, n) dist[i] = inf;
    build(n); modify(s, 0);
    rep(t, 1, n - 1) {
        int x = mp[1]; del(x);
        erp(i, x) if (dist[v[i]] > dist[x] + w[i])
            modify(v[i], dist[x] + w[i]);
    }
}

int main() {
    read(n, m, s);
    rep(i, 1, m) {
        int x, y, z; read(x, y, z); ae(x, y, z);
    }
    dijkstra(s);
    rep(i, 1, n) write(dist[i]), putchar(' ');
    puts("");
    return 0;
}
```

~~线段树大法好~~

---

## 作者：installb (赞：65)

**updated. 2019.11.3**  

Dijkstra是用于求解正权图上的单源最短路径(SSSP)问题的算法  

在这里我也想说一下关于SPFA和Dij Dij是一个求**没有负权边的图的单源最短路**的算法 SPFA是一个求**存在负权边的图的单源最短路**以及判负环的算法 看似一字之差 写起来也很像 但其实Dij和SPFA完全是不同的思想 Dij是贪心思想 利用了一个只有没有负权边的图才拥有的性质 而SPFA更像是一个"暴力"算法  

另外 SPFA没死  
下面是正文  

## 算法流程
Dijkstra算法其实是一个基于贪心的过程  
正确性会在后面提及  

设起点是$s$  
$dis_u$表示目前从$s$到$u$的最短路径  
$vis_u$表示$u$点的最短路是否已经被确定  

$1.$初始化起点的距离$dis_s$为0 其它节点都是正无穷  
$2.$找到所有未确定最短路的点中 与起点的距离$dis_u$最小的点$u$  
$3.dis_u$一定是起点到$u$最短路的长度了 $u$的最短路变为已确定  
$4.$扫描$u$的所有出边 如果$s\to u\to v$这条路径更优(即$dis_u+w(u,v)<dis_v$) 就把$dis_v$更新为$dis_u+w(u,v)$  
$5.$重复2~4直到所有点的最短路都被确定  

这里放张图理解  
代码在后面  
之前画的图太丑了 所以自己手画了一幅  
蓝点表示已经确定了最短路 打$\sqrt{}$的代表按距离的小根堆的堆顶  
![](https://s2.ax1x.com/2019/11/03/KORp1e.jpg)


~~最后放一张动图~~  
动图炸了 所以点[这里](https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html)吧/kk

## 正确性
Dijkstra是基于贪心思想实现的  

在每一轮更新后 还未访问到过的节点一定不优于已经访问到过的节点  
而在已经访问到过的节点中 找出未确定最短路且当前$dis_u$最小的$u$  
由于其它点的$dis$本来就已经比$dis_u$大 边权还是非负数 它们不可能更新$dis_u$ 所以$dis_u$已经被确定了 $u$的最短路就确定了 这样一步一步下来可以确定所有点的最短路  

## 优化
寻找全局最小值这一步是可以优化的  

加入元素、查找最小值、删除最小值  
用堆来实现这些操作非常合适  

所以就有了堆优化的Dijkstra  
堆中每个元素存两个值 结点编号$x$和入堆是该点被更新成的距离$dis$  
$dis$为第一关键字(即按dis的小根堆)
主要思想不变 每次找距离最小点是直接取出堆顶并删除堆顶  
更新最短路的时候 将更新后的节点入堆  

注意一个点可能会被更新多次而入堆多次 但是只有**最后一次入堆才是正确的dis** 同时**也一定是在所有入堆操作结束后才会出堆** 所以直接开个数组判断有没有出堆过就好了 当然也可以根据堆中元素的距离大小和点的最短路大小直接判断  

直接给出堆优化Dijkstra代码:  
```cpp
struct node{
	LL dis,x;
	bool operator < (const node &nd)const{ return nd.dis < dis; }
	// 重载运算符 注意pq的重载是反的
}h;

priority_queue <node> q; // 这叫堆

void add_edge(int f,int t,int C){
	++ ec; to[ec] = t; cst[ec] = C; nxt[ec] = hed[f]; hed[f] = ec;
}

void dijkstra(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s] = 0; h.x = s; h.dis = 0; q.push(h);
	while(!q.empty()){
		h = q.top(); q.pop();
		int u = h.x,v;
		if(vis[u]) continue; vis[u] = 1;
		for(int i = hed[u];i;i = nxt[i]){
			v = to[i];
			if(dis[v] > dis[u] + cst[i]){
				dis[v] = dis[u] + cst[i];
				if(!vis[v]){
					h.x = v; h.dis = dis[v];
					q.push(h);
				}
			}
		}
	}
	for(int i = 1;i <= n;i ++) printf("%d ",dis[i]);
}

int main(){
	scanf("%d %d %d",&n,&m,&s);
	while(m --){
		scanf("%d %d %d",&a,&b,&c);
		add_edge(a,b,c);
	}
	dijkstra();
	return 0;
}
```

### 时间复杂度证明:

由于每一个点只会出堆一次(严格来说是只扩展这个节点一次)  
所以每一个点和每一条边都只会访问一次  
堆优化Dijkstra的时间复杂度为$O((N+M)logM)$  

另外 如果图中存在负权边 即使没有负环 Dijkstra 也会有错误  
如果不用新数组判断而用距离$dis$来判断一个点是否入堆过 那么会被卡成指数级复杂度  

## 简单应用
在求最短路的过程中可以同时维护一些其他信息  
这些信息也应该能够传递  
**1.记录路径**  
每次更新最短路的时候记一个pre即可 代表这条路径是由哪个点过来的  
最后直接从最后一个点不断取pre 输出路径  
```cpp
void dijkstra(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s] = 0; t.x = s; t.dis = 0; q.push(t);
	while(!q.empty()){
		h = q.top(); q.pop();
		int u = h.x,v;
		if(vis[u]) continue; vis[u] = 1;
		for(int i = hed[u];i;i = nxt[i]){
			v = to[i];
			if(dis[v] > dis[u] + cst[i]){
				dis[v] = dis[u] + cst[i];
           pre[v] = u;
				t.x = v; t.dis = dis[v];
				q.push(t);
			}
		}
	}
}
while(now){
	printf("%d ",now);
   now = pre[now];
}
```
**2.最短路计数**  
记录一个$cnt_u$代表起点到u的最短路有多少条  
在$dis_v=dis_u+w(u,v)$时 加上来自$u$的方案数  
```cpp
void dijkstra(int s){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(cnt,0,sizeof(cnt));
	dis[s] = 0; cnt[s] = 1; t.x = s; t.dis = 0; q.push(t);
	while(!q.empty()){
		h = q.top(); q.pop();
		int u = h.x; if(vis[u]) continue; vis[u] = 1;
		for(int i = hed[u];i;i = nxt[i]){
			int v = to[i];
			if(dis[v] > dis[u] + w[i]){
				dis[v] = dis[u] + w[i]; cnt[v] = cnt[u];
				t.x = v; t.dis = dis[v];
				q.push(t);
			}
			else if(dis[v] == dis[u] + w[i]){
				cnt[v] += cnt[u];
				cnt[v] %= N;
			}
		}
	}
}
```
**3.次短路**  
记录到每个点的最短路和次短路  
这里由于边能够重复走 就不能够使用是否出过堆判断 一个点可能要更新其它点多次  
这里只要用路程判断 就是堆中元素$\{x,dis\}$的$dis$比次短路$dis2_x$还大 就抛弃这个元素 取下一个  

还有一种神奇的解法 把每一条边再加一条边 起点终点相同 边权为原来的**三倍** 代表$u\to v\to u\to v$  
```cpp
void dijkstra(int fr){
	memset(dis,0x3f,sizeof(dis)); dis[fr] = 0;
	memset(ds2,0x3f,sizeof(ds2));
	memset(vis,0,sizeof(vis));
	priority_queue <node> q;
	t.x = fr; t.dis = 0; q.push(t);
	while(!q.empty()){
		h = q.top(); q.pop();
		int u = h.x; if(vis[u]) continue; vis[u] = 1;
		for(int i = hed[u];i;i = nxt[i]){
			int v = to[i];
			if(dis[v] > dis[u] + w[i]){
				ds2[v] = dis[v];
				dis[v] = dis[u] + w[i];
				t.x = v; t.dis = dis[v];
				q.push(t);
			}
			else if(ds2[v] > dis[u] + w[i] && dis[v] != dis[u] + w[i]) ds2[v] = dis[u] + w[i];
			if(ds2[v] > ds2[u] + w[i]) ds2[v] = ds2[u] + w[i];
		}
	}
}
for(int i = 1;i <= m;i ++){
	scanf("%d %d %d",&a,&b,&c);
	add_edge(a,b,c);
	add_edge(b,a,c);
	add_edge(a,b,3 * c);
	add_edge(b,a,3 * c);
}
```

---

## 作者：yizimi远欣 (赞：32)

## 既然卡SPFA，那就用Dijkstra + 堆优化

#### ~~我太菜了就不会SPFA~~

就是要注意，可能有些同学会说：

“我们又不是不会Dijkstra + 堆优化”

于是自信满满的交上，一看就傻眼了，，，

60分？！  #2 #3 TLE？！

这里就是一个需要注意的地方了

过不去可能是因为没有加一个简单的优化：（下面截取一部分代码）

```cpp
while (q.size()){
        int u = q.top().v;
        int d = q.top().u;
        q.pop();
        if(d!=dis[u])//这里是优化哦
            continue;//QAQ
        rep(i,u){
            int v = e[i].v;
            int w = e[i].w;
            if (dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                node p;
                p.u = dis[v], p.v = v;
                q.push(p);
            }
        }
    }
```

这个优化把一些不可行的路径直接跳过去，会减少一些时间

没有这句是2500+ms

有这句只需208msQAQ

那么Dijkstra是不需要讲的（如果你做过弱化版）

堆优化似乎也不难，就是拿堆优化找最短dis就好

完整代码：

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 100010
#define inf 1 << 30
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
inline void write(int x){
    if (x < 0)putchar('-');x = -x;
    if (x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
//This is AC head above...
struct edge{
    int v, nxt, w;
} e[mn<<1];
int h[mn],p;
inline void add(int a,int b,int c){
    p++;
    e[p].nxt = h[a];
    h[a] = p;
    e[p].v = b;
    e[p].w = c;
}
struct node{
    int u,v;
    bool operator <(const node &b) const{
        return u > b.u;
    }
};
/*
bool operator <(const node &a,const node &b) {
        return a.u > b.u;
};
*/
int n,m,s;
int dis[mn];
priority_queue<node> q;
inline void Dij(int s){
    go(i, 0, n, 1)
        dis[i] = inf;
    dis[s] = 0;
    node o;
    o.u = 0;
    o.v = s;
    q.push(o);
    while (q.size()){
        int u = q.top().v;
        int d = q.top().u;
        q.pop();
        if(d!=dis[u])
            continue;
        rep(i,u){
            int v = e[i].v;
            int w = e[i].w;
            if (dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                node p;
                p.u = dis[v], p.v = v;
                q.push(p);
            }
        }
    }
}
int main(){
    n=read(),m=read(),s=read();
    go(i,1,m,1){
        int u = read(), v = read(), w = read();
        add(u, v, w);
    }
    Dij(s);
    go(i,1,n,1){
        cout << dis[i] << " ";
    }
    cout << "\n";
    return 0;
}
```

### 第五次发题解，希望可以帮助一直爆60的同学

---

## 作者：milk_candy (赞：19)

# 【模板】单源最短路径（堆优Dij） 题解

## 题意分析

给出n、m、s，和m条**有向边**，保证这个s点能够到达这张图的任何一个位置。

n代表这张图上点的数量，m代表这张图上边的数量，s代表源点（在这题里面，s永远等于1）

随后给出的**有向边**，有u、v、w，起点、终点、距离。

**求源点s到每个点的最短路径（自己到自己是0）**

$n\leq 100000,m\leq 200000,\sum{w[i]}\leq10^9$。

**spfa被卡。**

## 解题思路

SPFA不能通过，所以转向Dijkstra。但是Dijkstra的算法复杂度高达$O(n^2)$，必须想办法让它通过这个100000。这个时候，就有了“堆优Dijkstra”。

- Prob.1 堆优Dijkstra是什么？
  - 和普通的Dijkstra原理上相同，都是从原点开始宽度优先遍历。
  - 堆优Dijkstra的不同在于，每次Dijkstra在选择bfs下一个点的时候，能很快找出“距离最小”的那个点。

- Prob.2 **堆**优致力于实现什么？（弄堆来干嘛？）

  - 例子：![](https://cdn.luogu.com.cn/upload/image_hosting/sg7ejnln.png)
  - 例如现在A是源点。
  - 点A到B的连边距离为2，点A到C的连边距离为1。
  - 则从源点开始宽度优先遍历的有B和C点，这个时候记录有2种状态，“源点到该点”的距离分别是0+2和0+1，这里的0代表的是dis[A]，**以后从一个点宽度遍历到别的点的时候，也要先用dis[这个点]加到目标点的边的距离。例如从源点到X点的dis是10000，X到Y点的连边距离是10000，则(Y,10000+10000)这个状态被记录。**
  - 于是(B,2)和(C,1)被计入状态中，分别代表“源点到B点的一个距离方案是2”“源点到C点的一个距离方案是3”。
  - 按照贪心的想法，我们应该从最短的开始走，所以下一个bfs的状态会是(C,1)。
  - 而随着越来越多的状态被压入bfs状态数组，找到“源点到x点的最短距离”会变得很困难，**我们就可以用一个堆**来直接拿出每次**“源点到x点距离最短的”**。

- Prob.3 怎么实现堆优Dij呢？

  - 和一般的bfs几乎一样，先将源点放入状态数组，接下来假设A是源点，通过上面的例子，详细解析一下。

  - | 执行步骤                                                     | 状态数组   |
    | ------------------------------------------------------------ | ---------- |
    | 源点A被压入状态数组                                          | (A,0)      |
    | 源点A是堆头，被弹出；遍历到B、C点被压入状态数组(dist[B]=2,dist[C]=1) | (C,1)(B,2) |
    | (C,1)是堆头，被弹出；遍历到D点被压入状态数组(dist[D]=4)      | (B,2)(D,4) |
    | (B,2)是堆头，被弹出；遍历到D点被压入状态数组(dist[D]从4被更新到3)**（请注意此处的状态数组）** | (D,3)(D,4) |
    | (D,3)是堆头，被弹出；它没有连着任何点。                      | (D,4)      |
    | (D,4)是堆头，被弹出；它没有连着任何点。                      | --         |
    
- 这样的bfs是不难写，整理一番思路后很快就能得出程序核心部分。
  
- ```cpp
    q.push(源点，0);
    while(!q.empty())
    	{
        	拿出堆头，临时放在x;
        	int u=x.first;//源点编号找出来
        	堆头被弹出;
        	for(int i∈堆头那个点能去的所有点)
            	{
                	int v=e[i].EndPoint;//要去的点编号找出来
                	int w=e[i].Value;//源点 到 要去的点的边距离找出来
                	if(dis[u]+w<dis[v])
                    	{
                        	dis[v]=dis[u]+w;
                        	q.push(v,dis[u]+w);
    					}	
                        //松弛大家都会
    			}
    	}
    ```
  
- 现在请回头看上面那个地方加粗标记的状态数组。有没有发现什么地方不对？这里出现(D,3)(D,4)的原因，其实是我们在(D,3)(D,4)同时出现时没有把(D,4)这个状态删除掉，同样都是**源点到这个点**，我们当然希望距离是越小越好的，所以我们不需要这个(D,4)，理应将其删除，
  
- 但是我们如果要揪出这个点，把它删了，着实是费时间。
  
- 我们从程序的运行过程了解到——dis[D]在两个状态(D,3)(D,4)还没开始bfs的时候，已经是3。
  
- 那么只要每次bfs的时候，判断一下堆头这个点（也就是3,4）是否大于dis[D]，如果大于dis[D]，就不能让它继续dfs。
  
- 具体实现的过程如下：
  
- ```cpp
    if(x.d>dis[u])//x是我们取出来的堆头，u代表堆头x的点编号。
    	continue;
    //防止劣值替换优值
    ```
    
  - **如果你不这样做，并不会让你WA，但是很容易TLE。**因为如果我们不剪枝的话 下面那个根本无用的for循环仍在运行，它在压入无用的状态到堆里（因为这些状态根本再怎么bfs也更新不了答案，不是吗？）
  
- Prob.4 可有可无的东西：**链式前向星**替代vector实现链表

  - 当我们想快速建图找出一个点连着多少条边，懒的时候我都用的vector。

  - 如下随便一个图：

  - | G[A] | B    | C    |
    | ---- | ---- | ---- |
    | G[B] | D    | --   |
    | G[C] | D    | --   |
    | G[D] | E    | --   |
    | G[E] | --   | --   |

  - 像这样第一列代表每个点，然后右边的每个数代表它能连接到哪些边，直接弄vector G[点数];

  - 这是高手不屑于使用的，奆佬认为链式前向星可以做vector做不到的事情。

  - 其实链式前向星是不太困难的（但是我很讨厌），无非是对于上面的每一个点，就好像A能连接到B、C。我们就把C跟B连，B跟A连。如果我们要遍历一个点能到达的所有边，只需要开个front数组……

    - front数组是什么？

      - 假如我们要遍历跟A连着的所有边，前面说链式前向星已经将**C跟B连，B跟A连**，那么我们就只需要记住那个“C”的位置。

      - 所以front[点数]数组存储每个点连接的“最后一个点”是哪一个点。遍历这个点连接的所有边的时候，就直接从“最后一个点”开始往前跳转。

      - （小细节）跳转到最后，它终究会跳转完，不能再跳转。这个时候，程序一开始的

      - ```cpp
        memset(front,-1,sizeof(front));
        ```

      - 就显得非常重要。遍历的时候，只需要判断当前边是否是-1就可。

    - 链式前向星遍历和普通vector遍历的区别

      - 假如现在这个点是u点。

      - 链式前向星：

      - ```cpp
        for(int i=front[u];i>0;i=e[i].next)
            {
                int v=e[i].to;
                int w=e[i].value;
                //注意这里能这样做的原因是：不断更换着的i直接代表着边编号。
                if(dis[u]+w<dis[v])……
            }
        ```

      - 为了让不断更换着的i是边的编号，我们需要这样加边：

      - ```cpp
        void add(int u,int v,int w)
        {
        	edg_cnt++;
        	e[edg_cnt].to=v;
        	e[edg_cnt].value=w;
        	e[edg_cnt].next=front[u];
            //跟上一个边连边
        	front[u]=edg_cnt;
            //更换front，front变为“边编号”（为了让遍历时的i是“边编号”，front变为“边编号”很重要）
        }
        ```

      - vector：

      - ```cpp
        for(int i=0;i<G[u].size();i++)
        	{
            	int v=G[u][i].to;
            	int w=G[u][i].value;
            	if(dis[u]+w<dis[v])……
        	}
        ```

## 参考程序

```cpp
#include<bits/stdc++.h>
using namespace std;

struct OneEdge
{
	int to,value,next;
} e[500005];
int edg_cnt,front[110005];
int n,edg,source;

void add(int u,int v,int w)
{
	edg_cnt++;
	e[edg_cnt].to=v;
	e[edg_cnt].value=w;
	e[edg_cnt].next=front[u];
	front[u]=edg_cnt;
	//链式前向星式建边 
}

struct Heap
{
	int u,d;//号码、距离 
};

priority_queue<Heap> q;
bool operator < (const Heap& now,const Heap& rhs)
{
	return now.d>rhs.d;
}
//用pq弄小根堆需要重定义小于号。

int dis[100005];
void dij()
{
	for(int i=1;i<=n;i++)
		dis[i]=2147483647;
	dis[source]=0;
	//先把距离设为无穷大，然后把自己到自己的距离设为0
    
	q.push((Heap){source,dis[source]});
	while(!q.empty())
		{
			Heap x=q.top();
			q.pop();
			int u=x.u;
        	//先取出当前点
			
			if(x.d>dis[u])
				continue;
			//防止劣值替换优值 
			
			for(int i=front[u];i>0;i=e[i].next)
				{
					int v=e[i].to;
					int w=e[i].value;
                	  //确定下一个要去的点是哪个点，以及去这个点的距离
					if(dis[u]+w<dis[v])
                      	  //松弛
						{
							dis[v]=dis[u]+w;
							q.push((Heap){v,dis[v]});
						}
				}
		}
}
int main()
{
	memset(front,-1,sizeof(front));
    //为了遍历每个点的时候，让遍历在“无路可走”时停止，我们要让最后一个点连接给-1
    
	scanf("%d%d%d",&n,&edg,&source);
	int u,v,w;
	for(int i=1;i<=edg;i++)
		{
			scanf("%d%d%d",&u,&v,&w);
			add(u,v,w);
			//有向边	
    	}
	dij();
	for(int i=1;i<=n;i++)
		printf("%d ",dis[i]);
	return 0;
} 

```

---

## 作者：Delta_Rain (赞：19)

Update: 2018-10-20

更新一波题解。

Dijkstra是目前跑的最快的单源最短路算法。

Dijkstra的适用范围：没有负权边的图。

使用堆优化的Dijkstra时间复杂度~~大约的确是~~$O((m+n)\log{n})$。如有不同意见，欢迎在评论区留言。

Dijkstra算法的实质是贪心，通过当前已经求得最短路的节点去松弛其他节点，从而求得最短路。

下面是一个演示动画，帮助理解Dijkstra算法的原理。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Dijkstra_Animation.gif/220px-Dijkstra_Animation.gif)

(图片来自Wikipedia)

本篇题解使用了指针式链式前向星，看不懂的可以对照下面的"翻译"。

~~茴香豆~~**前向星**有四种写法

```cpp
// 版本1:
// 定义:
struct edge { edge* nxt = NULL; int to, w; }e[M << 1], *h[M];
// h[]是头指针，e[]存边
// 加边:
inline void add_edge(int u, int v, int w) {
	e[++tot].nxt = h[u];
    h[u] = e + tot;
    h[u] -> to = v, h[u] -> w = w;
}
// 遍历:
for(edge* i = h[x]; i != NULL; i = i -> nxt) {
	i -> to // 连接到的点
    i -> w // 边权
}
// 版本2:
// 数组版
int h[maxn], nxt[maxn], to[maxn], w[maxn], tot;
void add_edge(int u, int v, int wi) {
	nxt[++tot] = h[u];
   	to[tot] = v;
    w[tot] = wi;
    h[u] = tot;
}
for(int i = h[x]; i; i = nxt[i]) {
	to[i] // 连接到的点
    w[i] // 边权
}
// 版本3:
// 结构体
struct edge {int nxt, to, w;}e[maxn];
int h[maxn], tot;
void add_edge(int u, int v, int w) {
	e[++tot] = (edge) {h[u], v, w};
    h[u] = tot;
}
for(int i = h[x]; i; i = e[i].nxt) {
	e[i].to // 连接到的点
   	e[i].w // 边权
}

```

======以下为更新前内容=======

怎么全都用优先队列（~~欺负我STL学的差~~）

我来发一个 **手写堆 + 指针版链式前向星**的题解，来照顾STL没有学好的dalao们。

**关于堆优化Dijkstra，大家一定很熟悉，就不多做介绍了**

喜闻乐见的代码时间

```cpp
#include <bits/stdc++.h>
// 下面是跟别人学的快读快写
#define gr() (S == T && (T = (S = BB) + fread(BB, 1, 1<<15, stdin), S == T) ? EOF : *S++)
char BB[1 << 20], *S = BB, *T = BB;
// fread & fwrite 跑得快
inline int read() {
	char c;
	while(!isdigit(c = gr())); int x = c ^ 48;
	while(isdigit(c = gr())) x = (x << 3) + (x << 1) + (c ^ 48);
	return x;
}
char pbuf[10000000], *pp = pbuf;
inline void write(int x) {
	static int sta[35];
	register int top = 0;
	if(!x) sta[++top] = 0;
	while(x) sta[++top] = x % 10, x /= 10;
	while(top) *pp++ = sta[top--] ^ 48;
}
const int M = 1e5 + 5;
int n, m, s, tot, d[M], t;
// edge 前向星
struct edge { edge* nxt = NULL; int to, w; }e[M << 1], *h[M];
// node 往堆里放用 二元组 存边权和编号
struct node { int w, id; };
// 重载小于号
int operator <(node a, node b) { return a.w < b.w; }
// 手写堆
namespace heap {
	node hp[M << 1]; // 一个小根堆
	int sum;
    // 相当于优先队列的push
	inline void push(node x) {
		hp[++sum] = x;
		for(int i = sum, j = i >> 1; j; i = j, j = i >> 1)
			if(hp[i] < hp[j]) std::swap(hp[i], hp[j]);
	}
    // 相当于优先队列的pop
	inline void pop() {
		hp[1] = hp[sum--];
		for(int i = 1, j = i << 1; j <= sum; i = j, j = i << 1) {
			if(j + 1 <= sum && hp[j + 1] < hp[j]) ++j;
			if(hp[i] < hp[j]) break;
			else std::swap(hp[i], hp[j]);
		}
	}
    // 相当于优先队列的top和size
	inline node top() { return hp[1]; }
	inline int size() { return sum; }
}
// 加边 单向边
inline void add_edge(int u, int v, int w) {
	e[++tot].nxt = h[u], h[u] = e + tot, h[u] -> to = v, h[u] -> w = w;
}
// 堆优化dij （虽然函数名叫spfa）
inline void spfa() {
	heap::push((node) {0, s}); // 把源点扔进堆里
	memset(d, 0x7f, sizeof(d)); // 赋初值INF
	d[s] = 0; // 赋初值 s到s的距离为0
	while(heap::size()) { // 堆不空
		node now = heap::top(); // 取堆顶
		heap::pop(); // 弹堆
		int x = now.id;
		if(now.w ^ d[x]) continue; // ^ 和 != 一样
		for(edge* i = h[x]; i != NULL; i = i -> nxt)
			if(d[i -> to] > d[x] + i -> w) {
				d[i -> to] = d[x] + i -> w; // 松弛操作
				heap::push((node) {d[i -> to], i -> to});
			}
	}
}
int main() {
	n = read(), m = read(), s = read();
	for(register int i = 1, x, y, z; i <= m; ++i) {
		x = read(), y = read(), z = read();
		add_edge(x, y, z); // 加单向边
	}
	spfa(); // 最短路走起
	for(register int i = 1; i <= n; ++i)
		write(d[i]), *pp++ = ' ';
	fwrite(pbuf, 1, pp - pbuf, stdout); // fwrite跑的快
	return 0;
}
```
Accepted
用时152ms


**关于spfa 他死了**

~~（这年头费用流都能用Dijkstra跑）~~

---

## 作者：Silvermoon (赞：16)

直接进入正题吧

 _**PART 1**_  为什么要选择Dijkstra？~~(Dijkstra，你值得拥有)~~
```cpp
首先分析一下最常见的三种最短路算法的情况

算法名称   时间复杂度(最好)   时间复杂度(最坏)   空间复杂度   用途
Dijkstra       O(N^2)             O(N^2)            O(N)      单源
SPFA        O(KM)(k为常数)        O(NM)             O(N)      单源
Floyd          O(N^3)             O(N^3)           O(N^2)     多源

可以知道，SPFA是比较不稳定的(比如说在NOI的归程中)，所以我们需要Dijkstra
Dijkstra的时间复杂度稳定在O(N^2)，是一种非常理想的时间复杂度(主要是稳定)
```

 _**PART 2**_  Dijkstra的优化

这里就不再赘述普通的Dijkstra了，如有需要，出门左转至P3371了解情况

Dijkstra的优化主要就出在找最小值上，外层O(N)的循环是无法优化的，因为Dijkstra一定要以每一个点进行扩散才能保证答案的正确

维护最小值主要就是两种数据结构：线段树和小根堆

本篇题解只讲述线段树的维护~~(我才不会告诉你们这是因为我用堆敲了几遍都没过)~~

我们用线段树只用维护区间最小值与最小值的位置即可，如不会线段树，请找baidu.com或其他大佬

维护最小值相信大家都会了，而维护最小值的位置只需调整一下update即可

 _**PART**_  3 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=200010,M=500010;
struct stt//线段树要维护的min和min的位置w
{
	int m,w;
}t[N<<2];
struct node//链式前向星存边
{
	int to,la,v;
}e[M];
int n,m,tot=0,a,b,c,s;
int dis[N],st[N],bz[N];
int read()//快读
{
	int p=0;
	char c=getchar();
	while (c<'0' || c>'9') c=getchar();
	while (c>='0' && c<='9') p=p*10+(c-'0'),c=getchar();
	return p;
}
void write(int l)//快输
{
	if (l>=10) write(l/10);
	putchar(l%10+'0');
}
int ls(int x){return x<<1;}//位运算加速获得左儿子(等同于return x*2;)
int rs(int x){return x<<1|1;}//位运算加速获得右儿子(等同于return x*2+1;)
void add(int uu,int vv,int value)//链式前向星标准操作
{
	tot++;
	e[tot].to=vv;
	e[tot].v=value;
	e[tot].la=st[uu];
	st[uu]=tot;
}
void update(int x)//稍微修改过的update
{
	if (t[ls(x)].m<t[rs(x)].m)//比较左右儿子的最小值
	{
		t[x].m=t[ls(x)].m;//如果左子区间的最小值小
		t[x].w=t[ls(x)].w;//则当前区间最小值的位置是左子区间最小值的位置
	}
	else
	{
		t[x].m=t[rs(x)].m;//如果右子区间的最小值小
		t[x].w=t[rs(x)].w;//则当前区间最小值的位置是右子区间最小值的位置
	}
}
void add(int l,int r,int x,int y,int z,int now)//修改值
{
	if (l>=x && r<=y)
	{
		t[now].m=z;
		return;
	}
	if (r<x || l>y) return;
	int mid=(l+r)>>1;
	add(l,mid,x,y,z,ls(now));
	add(mid+1,r,x,y,z,rs(now));
	update(now);
}
void build(int l,int r,int now)//建树
{
	if (l==r)
	{
		t[now].m=dis[l];
		t[now].w=l;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls(now));
	build(mid+1,r,rs(now));
	update(now);
}
void dij()//Dijkstra
{
	int cnt=0;
	while (cnt<n-1)
	{
		int mn=t[1].m,mnl=t[1].w;
		add(1,n,mnl,mnl,2147483647,1);//扩散过的点不能进行再扩散
		bz[mnl]=1;
		for (int i=st[mnl];i!=-1;i=e[i].la)//标准Dijkstra打法
		{
			if (dis[e[i].to]>dis[mnl]+e[i].v)
			{
				dis[e[i].to]=dis[mnl]+e[i].v;
				if (bz[e[i].to]==0) add(1,n,e[i].to,e[i].to,dis[e[i].to],1);
				//我懒，所以把区间修改的懒标记删除后弄成了类似单点修改的东东
			}	
		}
		cnt++;
	}
}
int main()
{
	n=read(),m=read(),s=read();
	memset(st,-1,sizeof st);
	memset(dis,0x3f,sizeof dis);
	dis[s]=0;
	build(1,n,1);
	for (int i=1;i<=m;i++)
	{
		a=read(),b=read(),c=read();
		add(a,b,c);
	}
	dij();
	for (int i=1;i<=n;i++) write(dis[i]),putchar(' ');
	return 0;//结束了
}
```



---

## 作者：Sai0511 (赞：14)

看到各位大佬们都是用**前向星**存图，，我感到十分难以理解。对于像我这样的图论初学者来说，$vector$应该要比**前向星**要容易理解一些，~~我太菜了就不会前向星...~~,于是我就发一篇用$vector$存图的题解。       
首先我们先定义一个结构体$edge$,$edge$里存的是两个数$w,v$其中$w$表示这条边对应的下一个点，$v$代表从此点到下一个点的权值。                 
于是我们的$vector$就可以开$MAXN$个数组，其中$v[i]$表示与第$i$号节点相连的所有节点，其中权为$val$。                 
### 好的，知道了如何存图，我们开始讲算法：   
$0\sim30$分算法:$O(n^3)$的$Floyed$...$Floyed$的程序很短，很容易记，用的是一种类似$dp$的思想，其中：       
$$g[i][j]=g[i][k]+g[k][j]$$           
然后开$3$个循环$i,j,k$即可，$Floyed$程序比较简单，这里就不列举。                
$30\sim50$分算法：$spfa$,此题写一个$spfa$可以过两个点，亲测有效。$spfa$的算法建议去[这里](https://www.luogu.org/problemnew/solution/P3371)看看，这里就不再描述了。~~关于spfa---它死了~~    
$100$分算法，$Dijkstra$+堆优化，时间复杂度：$O(n log n),$其中，$Dijkstra$+堆优化的思想是：遍历第$i$号节点所有与它相连的节点，判断当前走的节点是否已经在堆（优先队列）中并且判断现在走过的路程是否比该节点当前走过的路程更短，如果更短，则更新最短路程，并将这个点扔进堆中然后继续执行，一直到队列为空为止。                   
### 话不多说，上代码：       
```cpp
#include<bits/stdc++.h>
#define MAXN 100010 //定义最大值
#define INF 2147483647
//这里使用了一个偷懒的写法，把最大值定义成不能到达的节点所要输出的数，在输出时就不需要特判了。
#define ll long long
using namespace std;
struct edge{ll w,v;};
ll n,i,j,beg,end,x,y,z,m;
vector<edge> g[MAXN];
edge E,E1;
ll dis[MAXN],vis[MAXN];
struct Node{
    ll w,v;
    bool operator < (const Node& x) const{
        return v>=x.v;
    }
};
priority_queue<Node> q;
Node node;
namespace Fastio{
    inline ll read(){//快速输入
        ll x=0;char c=getchar();
        while(!isdigit(c)) c=getchar();
        while(isdigit(c)) {x=x*10+c-48;c=getchar();}
        return x;
    }
    void write(ll x){//快速输出
        if(x/10>0) write(x/10);
        putchar(x%10+48);
        return;
    }
}
using namespace Fastio;
inline void Dijkstra(){//Dijkstra 
    while(!q.empty()){//当队列非空时
        ll ww=q.top().w;q.pop();
        //取出队列首元素，队列放出元素
        if(vis[ww]) continue;
        //如果访问过此节点，直接continue
        vis[ww]=1;//将该节点设置为走过
        for(i=0;i<g[ww].size();i++){
            ll w=g[ww][i].w; ll v=g[ww][i].v;
            //取出与该点所有相连的点      
            //取出与该点相连的点的边权值
            if(v+dis[ww]<dis[w]){//如果比当前节点所用过的最短路径要小
                dis[w]=dis[ww]+v;//更新最小值
                node.w=w;node.v=dis[w];
                q.push(node);//扔进堆里
            }
        }
    }
}
int main(){
    n=read();m=read();beg=read();//输入
    for(i=1;i<=m;i++){
        x=read();y=read();z=read();//输入
        E.w=y;E.v=z;
        g[x].push_back(E);
    // 将这点x的下一个点设成y,权值为z,放进vector中。注意是有向图...我不会告诉你我以为是无向图而WA了n次= =   
    }
    for(i=1;i<=n;i++) dis[i]=INF; 
    //注意，如果偷懒的话必须要写一个for循环，使用memset会出问题
    dis[beg]=0;
    node.w=beg;node.v=0;
    q.push(node);
    Dijkstra();
    for(i=1;i<=n;i++){write(dis[i]);putchar(' ');}
}
```



---

## 作者：CodyTheWolf (赞：12)

### [开头小广告：自己做的一个模板库OwO](https://www.luogu.org/blog/29354/Templet)

------------
>* ## 关于SPFA
>* ## 它并没有死

------------
看到了很多Dalao对SPFA上的堆优化。

一位直接把编号丢到STL的优先队列不算错但肯定不是最优，因为STL的优先队列不会随着编号所对应的权值的大小而改变，所以还是会有很多没有用的状态被取出。

其他的貌似都没有这个操作：
```cpp
		while (!Q.empty() && Q.top().first > dis[Q.top().second])
            Q.pop();
        if (Q.empty())
            break;
```
（这里我的优先队列是一个二元组，first是权值，second是点号，详见代码）

是不是有点眼熟？这个好像是Dijkstra里的？

对，其实堆优化的SPFA也可以像Dijkstra一样优化出队的元素。原理其实就是如果出队点的某次扩展的权值（就是出队时的first）如果大于现在已经拓展完的权值，那么说明这个点已经不需要被扩展了，因为在他之前已经用更小的扩展过了，所以可以直接pop掉。这个对照上面几行代码应该是很好理解的。

用了这个优化以后，最大点400ms，还特意拿了cin测试。

## 再说一次，这个是优化队列的SPFA，而不是披着Dijkstra外衣的SPFA。。。qwq

------------
## Code

```cpp
#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1e6 + 5, MAXM = 2e6 + 5;

typedef pair<int, int> pii;

int head[MAXM], nxt[MAXM], v[MAXM], w[MAXM], cnt;

int dis[MAXN];

int n, m, s;

inline void Addline(int x, int y, int z)
{
    v[cnt] = y, w[cnt] = z;
    nxt[cnt] = head[x], head[x] = cnt++;

    return;
}

inline void SPFA(int s)
{
    memset(dis, 0x3f, sizeof dis);

    priority_queue<pii, vector<pii>, greater<pii>> Q;
    Q.push(make_pair(0, s)), dis[s] = 0;

    while (!Q.empty())
    {
        while (!Q.empty() && Q.top().first > dis[Q.top().second])
            Q.pop();
        if (Q.empty())
            break;

        int x = Q.top().second;
        Q.pop();

        for (int i = head[x]; ~i; i = nxt[i])
            if (dis[v[i]] > dis[x] + w[i])
            {
                dis[v[i]] = dis[x] + w[i];
                Q.push(make_pair(dis[v[i]], v[i]));
            }
    }

    return;
}

signed main(void)
{
    memset(head, -1, sizeof head);

    cin >> n >> m >> s;
    for (int i = 1, x, y, z; i <= m; i++)
        cin >> x >> y >> z, Addline(x, y, z);

    SPFA(s);

    for (int i = 1; i <= n; i++)
        cout << dis[i] << " ";

    return 0;
}
```


---

## 作者：Gtr12180916 (赞：11)

逐行注释版堆优化Dj
适合初学者！！！

```
//4779 //堆优化的迪杰斯特拉 
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cstdio>
using namespace std;
int n,m,t,tot=0;                    //基本变量的定义 
int dis[200001],last[200001];       
//dis数组下标表示节点编号，数值表示到定点的距离
//last数组用于链式前向星，下标表示节点编号，数值表示此节点的最后一条出边 
bool mark[200001];    
//mark用于dj最短路算法，下标表示节点编号，数值true表示该节点的dis数组值为最短路 
struct edge{
	int to,prev,v;   //链式前向星存图法 
}e[200001];          //e数组下标表示边的序号，值分别为到达的点的编号，前一条边的编号和边权 
void add(int a,int b,int c){
	e[++tot]=(edge){b,last[a],c}; //先加后用，存边时依次保存的是到达的点的编号b，前一条边的编号last[a]和边权c  
	last[a]=tot;
}
struct node            //dj算法的结构体定义，存储的分别是点的编号和点距离定点的距离 
{
    int id;
    int dis;
    bool operator <( const node &x )const      //结构体优先队列比较函数（背下来吧） 
    {
        return x.dis < dis;
    }
};
priority_queue<node> q;      //结构体优先队列的定义 
int main()
{
	scanf("%d%d%d",&n,&m,&t);        //接收数据 
	int a,b,c;                       //定义临时变量用于链式前向星建图 
	for(int i=1;i<=m;i++){           //接收数据建图 
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	for(int i=1;i<=n;i++){           //数组初始化，dis数组要设为最大，以便更新最小距离 
		dis[i]=0x3f3f3f3f;
		mark[i]=0;
	}
	dis[t]=0;                        //起始点到自己的距离初始化为0（题目要求） 
	q.push((node){t,dis[t]});        //起始点的编号和到自己的距离分别放入队列 
	while(!q.empty()){               //dj 
		int x=q.top().id;            //取出队列中距离定点最小的一个点 
		int i=last[x];               //保存从此点发出的最后一条边，之后来遍历 
		q.pop();                     //可以出队了 
		if(mark[x]){                 //如果这个点已经出队（已经为最小值）则取下一个 
			continue;
		}
		mark[x]=1;                   //出队后mark数组打上标记，表示此下标点编号已经求出最小距离 
		while(i){                    //写成for循环也行，可参考spfa的写法 
			if(!mark[e[i].to]&&dis[e[i].to]>(dis[x]+e[i].v)){   
			//若编号为i的边到达的点未求出最小距离
			//并且存在经过此边的一条路径，比到达点上的到定点的距离短（后半部分和spfa相同） 
				dis[e[i].to]=dis[x]+e[i].v;     //更新 
				q.push((node){e[i].to,dis[e[i].to]});  //将更新完的点入队	
			}
			i=e[i].prev;      
		}
	}
	for(int i=1;i<=n;i++){
		printf("%d ",dis[i]);      //分别打印到定点的最小距离 
	}
	return 0;
}
```


---

## 作者：logeadd (赞：11)

如果你没有学习过堆优化的dij算法，不建议看此篇题解

真正的dij算法，也就是说最优化的dij算法的复杂度是O（m+nlogn），然而我们一般使用的dij算法的复杂度其实是O（(n+m)logm)

因为我们使用的STL中的二叉堆插入操作是log级别的，而且还不支持修改某个点的权值，这样会导致堆中有很多无用的元素，而且会有很多无用的pop操作，徒增了复杂度

现在我们需要的是一个支持修改权值的，快速插入的堆，配对堆是一个很好的选择
配对堆的插入复杂度是严格O(1),pop复杂度是均摊O(log),修改权值的操作比较玄学，学术界好像没有定论，大概比O（logn）要小一些。

配对堆的原理也比较简单，在这里不详细讲解，有兴趣的dalao可以去了解一下

c++中的pbds库封装了现成的配对堆，具体用法可以看代码

注意一下万能头文件并没有包含pbds库，还有pbds库在NOI系列赛事中的使用好像有点问题，因为有下划线开头的名称空间
```cpp
# include<iostream>
# include<cstdio>
# include<algorithm>
# include<queue>
# include<ext/pb_ds/priority_queue.hpp>//头文件 
inline int read()
{
	int x=0;
	char ch=getchar();
	while(ch>'9' || ch<'0') ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x;
}
using namespace std;
using namespace __gnu_pbds;
typedef __gnu_pbds::priority_queue< pair<int,int> ,greater< pair<int,int> >,pairing_heap_tag > heap; 
//pairing_heap_tag表示这是一个配对堆 
const int mn = 100005;
const int maxn = 200005 ;
const int inf = 2147483647;
heap q;
heap::point_iterator id[mn];//记录下每个点的迭代器 
struct edge{int to,next,dis;};
edge e[maxn * 2];
int head[mn],edge_max;
void add(int x,int y,int z)
{
	e[++edge_max].to=y;
	e[edge_max].dis=z;
	e[edge_max].next=head[x];
	head[x]=edge_max;
}
int n,m,s,dis[mn];
void dij(int x)
{
	for(int i=1;i<=n;i++) dis[i]=inf;
	dis[x]=0;
	id[x]=q.push(make_pair(0,x));//每次push会返回新加入点的迭代器 
	while(!q.empty())
	{
		int now=q.top().second;
		q.pop();
		for(int i=head[now];i;i=e[i].next)
		{
			if(e[i].dis+dis[now]<dis[e[i].to])
			{
				dis[e[i].to]=dis[now]+e[i].dis;
				if(id[e[i].to]!=0) //如果在堆中 
				    q.modify(id[e[i].to],make_pair(dis[e[i].to],e[i].to));//修改权值 
				else id[e[i].to]=q.push(make_pair(dis[e[i].to],e[i].to));//加入堆 
			}
		}
	}
}
int main()
{
	int x,y,z;
	n=read(),m=read(),s=read();
	for(int i=1;i<=m;i++)
	{
		x=read(),y=read(),z=read();
		add(x,y,z);
	}
	dij(s);
	for(int i=1;i<=n;i++)
	   printf("%d ",dis[i]);
	return 0; 
}
```

---

## 作者：preqzhor (赞：10)

卑微的蒟蒻思考了一天再请教校里的dalao后写出的带有很全注释的题解
```cpp
#include<bits/stdc++.h>
#define INF 2147483647
#define MAXN 500010
#define MAXM 10010
using namespace std;
int N,M,S;
int p;
int dis[MAXN],vis[MAXN];
int head[MAXN];//head数组表示以i为起点的第一条边的储存位置 
struct Edge//链式前向星，next表示与第i条边同起点的下一条边的存储位置 
{
	int next;//下一条边的编号指针 
	int to;
	int cost;
}edge[MAXN];
struct node
{
	int dis;
	int pos;
};
struct cmp{
  bool operator ()(node &x,node &y){
    return x.dis>y.dis;//小根堆重载 
  }
}; 
void addline(int a,int b,int c)
{	
	//a是起点 
	edge[++p].next=head[a];//++p表示p的编号，其上一条边的储存位置是head[a] 
	head[a]=p; //a为起点，此时以a为起点的上一条边是第p条 
	edge[p].to=b;
	edge[p].cost=c;
	/*
	edge[编号++].上一条边=head[起点]head代表了以n为起点的上一条边的编号 
	head[第？个起点]=编号//把这条边更新为上一条边 
	*/		 
}
priority_queue<node,vector<node>,cmp>q;
void Dijkstra(int s)
{
	dis[s]=0;
	q.push((node){0,s});
	while(!q.empty())
	{
		node tmp=q.top();//tmp是优先队列q中栈顶元素，由于q是小根堆所以是最小的元素 
		q.pop();
		int x=tmp.pos,d=tmp.dis;// x是栈顶元素的位置，d是栈顶元素离s的距离 
		//x就是距离最近的那条边的位置，d就是距离最近的边的花费 
		if(vis[x])continue;//如果vis中存了（访问过），跳过
		vis[x]=1;//记录
		for(int i=head[x];i;i=edge[i].next) //访问从i出发的所有边//遍历链式前向星 
		{
			//head[x]是x连到的第一条边
			//edge[i].next是下一条边 
			//i不等于0时继续进行 				
			//i是离目前集合最近边的第一条边的储存位置 
			//cout<<x; 
			int y=edge[i].to;
			if(dis[y]>dis[x]+edge[i].cost)
			{
				dis[y]=dis[x]+edge[i].cost;
				if(!vis[y])//如果到的点y没有被访问过 
				{
					q.push((node){dis[y],y});//就把y丢到堆里 
				}
			}
			//cout<<i<<" ";
		 } 
	}
	
}
int main()
{
	scanf("%d%d%d",&N,&M,&S);
	memset(dis,0x3f3f3f3f,sizeof(dis));
	for(int i=1;i<=M;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		addline(a,b,c);
	}
	Dijkstra(S);
	for(int i=1;i<=N;i++)
	{
		printf("%d ",dis[i]);
	}
	return 0;
}
```


---

## 作者：南城忆潇湘 (赞：9)

感觉大佬的题解都有点看不懂。。。我就来写一下核心代码为 **六行**的dij+堆优化qwq 可能会好懂一些.. 
```cpp
#include<bits/stdc++.h>
#define MAXN 2147483647//初始化最大值
using namespace std;
struct Node{
    int dis,head,num;
    friend bool operator < (Node s,Node t){ //重载运算符，为了用小根堆
        return s.dis>t.dis;//记住，小于在里面要变成大于，不然会卡住
    }
};
Node a[1000001];
int nxt[2000001],to[2000001],d[2000001],top,dist[1000001];
bool used[1000001];
priority_queue <Node> q;//优先队列（堆）
int main(){
    int n,m,s,x,y,k;
    scanf("%d%d%d",&n,&m,&s);
    for(register int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&k);
        nxt[++top]=a[x].head;	a[x].head=top;	  to[top]=y; 
        d[top]=k; a[i].num=i;	a[i].dis=MAXN;//初始化，也就是链式前向星
    }
    a[s].dis=0;	q.push(a[s]);//加入第一个点
    while(!q.empty()){//核心代码上场qwq
        Node v=q.top();q.pop();//取出这个点
        if(v.dis>dist[v.num])	continue;//如果这个数在他放入队列被更新后的话，那么在它之后肯定有一个比它权值更小的点，就直接返回。
        for(register int i=v.head;i;i=nxt[i])
            if(a[to[i]].dis>v.dis+d[i])      dist[to[i]]=a[to[i]].dis=v.dis+d[i],q.push(a[to[i]]);//松弛操作
    }
    for(register int i=1;i<=n;i++)
        printf("%d ",a[i].dis);//输出就ok了
    return 0;
}
.....
```

---

## 作者：wuyuema (赞：8)

开头提示：本做法不适用于所有单源最短路。由于过于玄学，请酌情使用。我现在已经忘记这个做法是我自己YY的还是嫖来的了，如果在其他地方见到，且时间比我这个早，请告知出处，谢谢。  

使用SPFA的皮，Dijkstra的灵魂。  

和正常SPFA的区别：  
- 使用双端队列，这里使用了性质一样的STL链表。  
- 对频繁出入队的点和较远的点做延后处理。一般的点从左边入队，这种点从右边入队。  

然后啪叽啪叽就过了OAO  

记一个点出入队次数为cnt，如果cnt小于R那么优先处理。如果dis比左端队首的dis小那么优先处理。具体细节见代码。因为其他地方是标准SPFA所以不上注释。使用快读。O2可优化55%的时间。代码附赠一段Dijkstra模板。

```cpp
#include <cstdio>
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#include <cstring>
#include <list>
using namespace std;

const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
int n, m, s;
struct Edge {
	int u, v, w;
	Edge(int uu, int vv, int ww) : u(uu), v(vv), w(ww){}
};
vector<Edge> E;
vector<int> G[maxn];
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

int dis[maxn];
bool vis[maxn];

struct node {
	int d, dis;
	node(int dd, int ddis) : d(dd), dis(ddis) {}
	friend bool operator < (const node &a, const node &b) {
		return a.dis > b.dis;
	}
};
void dijkstra(int s) {
	memset(dis, inf , sizeof(dis));
	memset(vis, 0, sizeof(vis));
	dis[s] = 0;
	priority_queue<node> q;
	q.push(node(s, dis[s]));
	while (!q.empty()) {
		int u = q.top().d;
		q.pop();
		if (vis[u]) continue;
		vis[u] = 1;
		for (int i = 0; i < G[u].size(); i++) {
			Edge e = E[G[u][i]];
			if (dis[e.v] > dis[u] + e.w) {
				dis[e.v] = dis[u] + e.w;
				if (!vis[e.v]) q.push(node(e.v, dis[e.v]));
			}
		}
	}
}

const int R = 200;
const int V = 40;
int cnt[maxn];
void spfa(int s) {
	memset(dis, inf, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	memset(cnt, 0, sizeof(cnt));
	dis[s] = 0;
	list<int> q;
	q.push_front(s);
	while (!q.empty()) {
		int u = *(q.begin()); q.pop_front();
		vis[u] = 0;
		for (int i = 0; i < G[u].size(); i++) {
			Edge e = E[G[u][i]];
			if (dis[e.v] > dis[u] + e.w) {
				dis[e.v] = dis[u] + e.w;
				if (!vis[e.v]) {
					vis[e.v] = 1;
					if (cnt[e.v] > 0 && cnt[e.v] < R || q.size() && dis[*(q.begin())] >= dis[e.v] - V) {
						q.push_front(e.v);
					}
					else {
						q.push_back(e.v);
					}
					cnt[e.v]++;
				}
			}
		}
	}
}

int main(){
//	freopen("testdata.in", "r", stdin);
//	freopen("t.out", "w", stdout);
	n = read(), m = read(), s = read();
	int tu, tv, tw;
	for (int i = 1; i <= m; i++) {
		tu = read(), tv = read(), tw = read();
		E.push_back(Edge(tu, tv, tw));
		G[tu].push_back(E.size() - 1);  
	}
//  dijkstra(s);
	spfa(s);
	for (int i = 1; i <= n; i++) printf("%d ", dis[i]);
	return 0;
}
```
  
以上。

---

## 作者：lzk5627 (赞：8)

这个题目难度~~蓝的有点过分了吧~~

只要堆优化的迪杰斯特拉算法就可以过了,说白了应该也就是道~~绿题~~

==================闲话分割线,忙的同学可直接跳过

NOI Day return前几天比赛时打了个暴力(迪杰斯特拉+并查集+LCA),本以为可以水至少50分的,结果文件输入名打错了,直接爆0,交到洛谷来好歹也有65分(woc我的65分啊)

好的,~~闲话扯完了~~,现在来回到正题~~是谁没事在哪扯闲话~~,这题只要用邻接链表存图,然后堆优化就可以了(~~不知道题面里的巨佬是怎么打的~~,也许他用的是SPFA,话说SPFA最慢可以卡到O(n^2)没人发现吗),~~这次出题人就直接在将题时直接说SPFA死了~~

================强行拉回正题

所以说比赛时如果求稳(时间复杂度允许)的话还是尽量使用迪杰斯特拉算法

下面是A掉的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<long long,int>P;
int n,m,s,head[100001],next[200001],v[200001],w[200001];//邻接链表存边
//v[i]为第i条边导向的点,w[i]为第i条边的权值
long long _min[100001];//每个点的最短路
priority_queue<P,vector<P>,greater<P> >que;//堆优化
int read()
{
    char ch=getchar();
    int x=0,f=1;
    while(ch>'9'||ch<'0')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
        {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
        }
    return x*f;
}
int main()
{
    n=read();
    m=read();
    s=read();
    for(int i=1;i<=m;i++)
    {
        int x=read(),y=read(),z=read();//输入存边
        next[i]=head[x];
        head[x]=i;
        v[i]=y;
        w[i]=z;
    }
    fill(_min+1,_min+n+1,100000000000);//初始化
    _min[s]=0;
    que.push(P(0,s));
    while(!que.empty())
    {
        P x=que.top();
        que.pop();
        if(x.first>_min[x.second])
            continue;//大于就直接跳过,因为这肯定不是最短路了
        for(int i=head[x.second];i!=0;i=next[i])
        {
            if(x.first+w[i]<_min[v[i]])
            {
                _min[v[i]]=x.first+w[i];
                que.push(P(_min[v[i]],v[i]));//更新
            }
        }
    }
    for(int i=1;i<=n;i++)
        printf("%lld ",_min[i]);输出
    return 0;//完美撒花
}
```
============
题外话: 本次NOI难度适中,代码长度中等,题目谨防AK与爆0,考虑人群广,为出题人点个赞.

---

## 作者：WorldBest丶牛顿 (赞：7)

## 本题解较适合堆优化重载括号运算符的同学看
众所周知， $Dijkstra$ 是一个常用来求没有负环的最短路的方法  
一种常见的优化，就是优先队列（堆）优化 $Dijkstra$  
优先队列的写法对每个人来说也是各不相同  
针对一种重载括号运算符的写法，我想谈一谈我的看法

代码：
```cpp
struct cmp{
    bool operator()(const int &x,const int &y)
    const
    {
        return dis[x]>dis[y];
    }
};
priority_queue<int,vector<int>,cmp>q;
void dijkstra(){
    int u,v,w;
    for(int i=1;i<=n;++i) d[i]=2147483647;
    dis[s]=0;q.push(s);
    while(!q.empty()){
        u=q.top();
        q.pop();
        if(vis[u]) continue;
        vis[u]=true;
        for(int i=head[u];i;i=p[i].nxt){
            v=p[i].to;w=p[i].w;
            if(dis[u]+w<dis[v])
            {
                dis[v]=dis[u]+w;
                q.push(v);
            }
        }					
    }	
}
```

这种写法保留了 $priority\_queue$ 中小根堆原来的写法，更容易理解  
并且这种写法在某本著名的书中也出现了  
但是这种方法真的没有问题吗？  

我们可以考虑，如果在更新其他节点的时候，某一个节点被多次更新，那么它每次的 $dis$ 值都是会减小的  
那么如果一个节点更新的次数足够多时，它总有一次会跟自己进行比较，那么它会因为自己与自己的 $dis$ 值相等而留在这个位置   
那么它就会在堆中形成一种类似于“路障”的东西将堆的某些部分“堵住”  
而这种写法在数据结构上也破坏了堆原有的性质，就会使算法出现错误  
如下图：  

$q.push$ 表示松弛时的入堆操作， $1(10)$ 表示将节点编号为 $1$ 的 $dis$ 值修改为 $10$
$cmp\quad$ 是重载括号运算符的写法  
$node\quad$ 是将节点编号和 $dis$ 值合并之后的写法（下面有代码）  
注： $pair$ 写法与 $node$ 写法大致类似，在此不再阐述  

![](https://cdn.luogu.com.cn/upload/pic/32719.png)

很明显，当编号为 $2$ 的节点多次入堆之后，堆内元素已经产生了问题  
所以，如果一张图中有大量的重边，就很容易会导致这样的问题发生  

附上 $node$ 写法代码
```cpp
struct node
{
    int u,d;
    bool operator<(const node& rhs)
    const
    {
        return d>rhs.d;
    }
};

void Dijkstra()
{
    priority_queue<node> q;
    for(int i=1;i<=n;++i) d[i]=2147483647;
    q.push((node){s,d[s]});
    d[s]=0;
    while(!q.empty())
    {
        node x=q.top();
        int u=x.u;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=head[u];i;i=e[i].next)
        {
            int v=e[i].v,w=e[i].w;
            if(d[u]+w<d[v])
            {
                d[v]=d[u]+w;
                q.push((node){v,d[v]});
            }
        }
    }
}
```
如果有什么更好（玄学）的重载括号运算符的写法可以私信我qwq

---

## 作者：zhangjiacheng (赞：6)

### 算法简析：主要是Dijkstra加上堆优化就AC了。
### 代码如下：
```c++
#include<stdio.h>
#include<string.h>
#include<iostream>
#define inf 2147483647
using namespace std;
int heap_size;
const int maxn = 100000+10;//点的最大数量 
const int maxm = (200000  + 10) * 2;//边的最大数量 
int cnt, head[maxn],  s[maxn];// cnt 边的数量。 head【点】连接的第一条边的编号。 s集合是代表确定最短的点 
struct node{
    int to, nxt, val;// to 这条边指向的点 nxt这条边的下一条边。val权值 
}edge[maxm];
int min(int a,int b){
    return a<= b ? a : b;
}
struct node1{
    int dist;//距离 
    int idx;//点的编号 
}dist[maxm],dist1[maxm];
void shiftdown(int rt){//下放 
    int l=rt<<1;
    int r=rt<<1|1;
    int minest;
    if(l<=heap_size&&dist1[l].dist<dist1[rt].dist)
        minest=l;
    else
        minest=rt;
    if(r<=heap_size&&dist1[r].dist<dist1[minest].dist)
        minest=r;
    if(minest!= rt){
        swap(dist1[rt],dist1[minest]);
        shiftdown(minest);
    }
}
void shiftup(int rt){
    while(dist1[rt].dist<dist1[rt>>1].dist&&rt!=1){
        swap(dist1[rt],dist1[rt>>1]);
        rt=rt>>1;
    }
}
void init(){//初始化 
    cnt = 0;
    heap_size = 0;
    memset(head, -1, sizeof head);
}
void add(int u, int v, int w){
    edge[cnt].to = v;//指向V点 
    edge[cnt].val = w;//权值 
    edge[cnt].nxt = head[u];//下一条边 
    head[u] = cnt++;//第一条边 
}
void Dijkstra(int n,int st){
    int mindis, u;
    memset(s, 0, sizeof s);
    for(int i =1;i <=n;i++) dist[i].dist = inf,dist[i].idx = i;// 初始化 
//	printf("%d\n", dist[2]);
    for(int i = head[st];~i;i = edge[i].nxt){//~i  i!=-1 
        int v = edge[i].to;
        dist[v].dist = min(dist[v].dist,edge[i].val);//初始dist数组 
    }
    s[st] = 1;  //起点加入 
    dist[st].dist = 0;  // 起点的距离是0
    heap_size=0; //初始堆   没有元素 
    for(int i = 1;i <= n;i++){
        if(i==st) continue;//跳过起始点 
        heap_size++;
        dist1[heap_size] = dist[i];
        shiftup(heap_size);
    }
    //堆中有n-1个点 
    for(int i = 1; i <= n-1; i++){  
        mindis = inf;
       	mindis = dist1[1].dist;// 小顶堆 
       	
       	u = dist1[1].idx;// idx代表这个点的编号 
       	while(s[u]==1){// 若选择的点已经再S数组中 ， 我们就重新再找一个 
            u = dist1[1].idx;
            swap(dist1[1],dist1[heap_size]);
       		heap_size--;
       		shiftdown(1);
        }

  		s[u]=1;// 放到S数组中 
  		for(int j = head[u];~j;j = edge[j].nxt){//遍历u点连接的所有的边 
  			int v = edge[j].to;//u点所指向的点  
  			if(s[v]==0 && dist[u].dist + edge[j].val < dist[v].dist && edge[j].val < inf){
  				dist[v].dist = dist[u].dist + edge[j].val;
  				heap_size++;
  				dist1[heap_size] = dist[v];
  				shiftup(heap_size);
  				//重新加入到堆中 
            }
        }
 	}
}
int main(){
    init();
    int N, M, S;//n个点 ， m条边 ， s代表起点 
    scanf("%d%d%d", &N ,&M, &S);
    while(M--){
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w);//  加入u到v的权值为w的边 
    }
    Dijkstra(N, S);//单源最短路 
    for(int i = 1;i <= N;i++){
        printf("%d ",dist[i]);//输出所有的最短距离 
    }
}
```

---

## 作者：御·Dragon (赞：5)

2019/11/15 更新日志

发现我的Dijstra优先队列模板有点问题，修改了，并在多处删繁就简，增添详细注释。

-----------

昨天： __[图论-概念与记录图的方法](https://www.luogu.org/blogAdmin/article/edit/137066)__

以上是昨天的Blog，有需要者请先阅读完以上再阅读今天的Blog。

可能今天的有点乱，好好理理，认真看完相信你会懂得

------------

分割线

------------

# 第二天

引子：昨天我们~~简单~~讲了讲图的概念与记录图的方法，那么大家有一定的底子了，我们就开始初步接触图论算法了！

我们只讲Dijkstra和Floyd，因为其实在比赛中会这两个算法就很好了。

__今天我们要讲的是：最短路径问题__

## Top1：最短路的概念

相信大家都知道有一款Made in China的导航软件——百度导航。那么他们是怎么为我们导航的？就是使用了今天我们要学的问题 __最短路径__ 。

~~说不定你学了之后就可以做一个导航的~~ __~~是不是有点小激动？~~__ 

__$\color{red}\text{ 重点：最短路问题就是一个点到另一个最短的路径！ }$__

------------

### 最短路~~专业~~术语：

__中转点：__ 一个点到另一个点不一定是有直接道路连接的，可能会经过一些别的点，我们就叫那些点叫做 __中转点__ 。

__松弛：__ 比如现在从 $I$ 点到 $J$ 点的边权为 $X$ ，而现在有一个点 $K$ ，$K$ 到 $I$ 的边权为 $Y$ ，$K$ 到 $J$ 的边权为 $Z$。如果 $Y$ + $Z$ < $X$ ，也就是 ($I$ 点到 $J$ 点的路径边权) 比 ($K$ 到 $J$ 的边权) 加上 ($K$ 到 $I$ 的边权) 还要大，那么显而易见， __$I$ 到 $J$ 的直接路径 $X$ 可以由中转点 $K$ 降到 $Y + Z$，使得 $I$ 到 $J$ 的最短路径更优。__

------------

## Top2:Floyd算法

现在大家都知道最短路是什么了，那么从简单到复杂，我们先来看看新手必懂的算法。

Floyd简单粗暴，就是枚举三个点，一个起点，一个终点，一个中转点。看 __起点到中转点的路径__ 加上 __中转点到终点的路径__ 是不是小于 __目前起点到终点的路径__ 即可（就是不断松弛）。

显而易见，Floyd算法很好懂，就是时间复杂度高了点—— $N^3$ 的复杂度。而且，Floyd是多源最短路，询问时只需调用dis就行了。

所以， __当 N 大于1000时，慎用！__

代码就很简答啦(蒟蒻用邻接矩阵写的)：

```
//如果为无向图,dis就会对称,Floyd的j就只要到i,且dis[i][j]dis[j][i] 要一起更新 
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1000 + 10;
int n,m;
int x,y,z;
int dis[MAXN][MAXN];
void Floyd(){
	for(int k = 1;k <= n; k++)
		for(int i = 1;i <= n; i++)
			for(int j = 1;j <= n/*i*/; j++)
				if(dis[i][k] + dis[k][j] < dis[i][j])dis[i][j] = dis[i][k] + dis[k][j];
	return;
}
int main(){
	cin>>n>>m;
	for(int i = 1;i <= n; i++)dis[i][i] = 0;
	for(int i = 1;i <= n; i++)
		for(int j = 1;j <= n; j++){
			if(i != j)dis[i][j] = 1e9;
		}
	for(int i = 1;i <= m; i++){
		cin>>x>>y>>z;
		dis[x][y] = z;
	}
	Floyd();
	for(int i = 1;i <= n; i++){
		for(int j = 1;j <= n; j++){
			cout<<dis[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```

## Top3：Dijkstra算法

Dijkstra与Floyd相反，是单元最短路，即只能求出一个点到其他所有点的最短路。

Dijkstra属于贪心的思想，正解：

首先定义两个种类——黑点和白点，黑点就是在目前算完最短路径的点，白点反之。

每次在白点中找一个离目前任意一个黑点最近的，加入黑点，更新白点到原点的最短路即可。

代码如下：注意：这里的dis不再是邻接矩阵，是单源最短路径。tot才是邻接矩阵！

邻接矩阵，蒟蒻是用洛谷[P1828 香甜的黄油 Sweet Butter](https://www.luogu.org/problemnew/show/P1828) 作为例题写的模板，体谅一下


```
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100 + 10;
struct Node{
	int x,y;
}f[MAXN];
int n,m,a,b,s,t;
bool black[MAXN];
double dis[MAXN];
double tot[MAXN][MAXN];
double calc(int i,int j){
	return sqrt((f[i].x - f[j].x) * (f[i].x - f[j].x) + (f[i].y - f[j].y) * (f[i].y - f[j].y));
}
double Dijkstra(int start,int end){
	for(int i = 1;i <= n; i++){
		dis[i] = tot[start][i];
	}
	dis[start] = 0;
	black[start] = true;
	for(int i = 1;i < n; i++){
		double M = 2e9;
		int u = start;
		for(int j = 1;j <= n; j++){
			if(dis[j] < M && !black[j]){
				M = dis[j];
				u = j;
			}
		}
		if(u == start)continue;
		//此处的判断与前面的u = start对应,若该图存在一个单独的点这里就要加上
		//否则可以u = 0,这个判断删掉 
		black[u] = true;
		for(int j = 1;j <= n; j++){
			if(black[j])continue;
			if(dis[u] + tot[u][j] < dis[j]){
				dis[j] = dis[u] + tot[u][j];
			}
		}
	}
	return dis[end];
} 
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n; i++)
		for(int j = 1;j <= n; j++){
			tot[i][j] = i == j ? 0 : 1e9;
		}
	for(int i = 1;i <= n; i++){
		scanf("%d%d",&f[i].x,&f[i].y);
	}
	scanf("%d",&m);
	for(int i = 1;i <= m; i++){
		scanf("%d%d",&a,&b);
		tot[a][b] = calc(a,b);
		tot[b][a] = tot[a][b];
	}
	scanf("%d%d",&s,&t);
	printf("%.2f",Dijkstra(s,t));
	return 0;
}

```

__所以，Dijkstra的时间复杂度是 $N^2$__

怎么优化呢？很简单——在寻找离黑点最近的白点时，使用优先队列即可。

但是这里要注意的是，我们朴素的使用单调队列维护，在洛谷 [P4779 【模板】单源最短路径](https://www.luogu.org/problem/P4779) 中会TLE。

> 为什么呢？

我们的优先队列不想 set 等 STL ，没有自动去重的功能。所以当队列中有多个相同的元素时，Dijkstra的效率会大大减少。

__所以__ ，我们需要一个bool型的数组，不难想到，该数组用来记录 __每个元素当前在队列中是否存在。__

__细节又来了。__ 我们bool型数组的定义是 __每个元素当前在队列中是否存在。__ 那么我们每次在优先队列弹出队首进行操作时，我们需要 __将队首的bool标记取消。__ 

一个元素可以多次单独出现在队列，但是不能一次多个出现在队列。

虽然多次拓展到队首，但是队首到源点的最短路径 可能 更新了。所以我们不妨再次从队首再次进行拓展，更新周围点的答案。 __这就是我们为什么要将队首的bool标记取消。__

__优先队列Dijkstra：__

```
#include<bits/stdc++.h>
#include<cctype>
#pragma GCC optimize(2)

#define in(a) a = read()
#define out(a) write(a),printf(" ")
#define outn(a) write(a),putchar('\n')

#define ll long long
#define rg register
#define New int

using namespace std;

namespace IO_Optimization{

	inline New read()
	{
	    New X = 0,w = 0;
		char ch = 0;

		while(!isdigit(ch))
		{
			w |= ch == '-';
			ch=getchar();
		}
	    while(isdigit(ch))
		{
			X = (X << 3) + (X << 1) + (ch ^ 48);
			ch = getchar();
		}
	    return w ? -X : X;
	}

	inline void write(New x)
	{
	     if(x < 0) putchar('-'),x = -x;
	     if(x > 9) write(x/10);
	     putchar(x % 10 + '0');
	}

	#undef New
}
using namespace IO_Optimization;

const int MAXN = 1000000 + 2;

int n,m,s,x,y,z,len,p;
int dis[MAXN],nxt,val;
struct Node
{
	int num,dist;
	inline bool operator <(const Node &nnxt)const{
		return dist > nnxt.dist;
	}
};
vector<Node> nei[MAXN];
bool vis[MAXN];

inline void Dijkstra(int start)
{
	memset(dis,0x3f3f3f3f,sizeof(dis));
	memset(vis,false,sizeof(vis));
	priority_queue<Node>q;
	Node cur = {start,0};

	q.push(cur);
	dis[start] = 0;
	vis[start] = true;

	while(!q.empty())
	{
		cur = q.top();
		q.pop();
		p = cur.num;
		vis[p] = false;
		len = nei[p].size();

		for(rg int i = 0;i < len; ++i)
		{
			nxt = nei[p][i].num;
			val = nei[p][i].dist;

			if(dis[nxt] > dis[p] + val)
			{
				dis[nxt] = dis[p] + val;
				if(!vis[nxt])
				{
					Node tmp = {nxt,dis[nxt]};
					q.push(tmp);
					vis[nxt] = true;
				}
			}
		}
	}
	return;
}

int main()
{
	in(n),in(m),in(s);
	for(rg int i = 1;i <= m; ++i)
	{
		in(x),in(y),in(z);
		nei[x].push_back((Node){y,z});
	}

	Dijkstra(s);
	
	for(rg int i = 1;i <= n; ++i)
		out(dis[i] == 0x3f3f3f3f ? 2147483647 : dis[i]);

	return 0;
}

```
## 顺便带一下SPFA的算法模板和用动态数组记录的Dijkstra(这里不做详解了，有需要的人可以复制看一下)

SPFA：

```
#include<iostream>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring> 
using namespace std;
int n, p, c, cow[801], a, b, d, cnt = 0, sum = 0, ans = 2147483647;
int dis[10000], w[10000], next[10000], to[10000], first[10000] = {0};
bool exist[10000] = {false};
queue<int> q;

void addEdge(int u, int v, int weight)
{
	cnt++; //边的编号 
	to[cnt] = v; //第cnt条边指向点v 
	w[cnt] = weight; //第cnt条边的权值 
	next[cnt] = first[u]; // 第cnt条边指向连接点u的第一条边 
	first[u] = cnt; //将连接点u的第一条边更新为第cnt条边
	return; 
} 

void spfa(int start)
{
	memset(exist, false, sizeof(exist)); //一开始所有点在队列外 
	memset(dis, 0x7f, sizeof(dis)); //将所有点到起始点的距离置为极大值 
	dis[start] = 0; 
	q.push(start); //起始点入队列 
	exist[start] = true; 
	while(!q.empty())
	{
		int head = q.front(); //取队列的第一个点 
		q.pop();
		exist[head] = false;
		for(int e = first[head]; e != 0; e = next[e]) //循环head连接的每一条边 
		{
			//松弛操作 
			if(dis[head] + w[e] < dis[to[e]])
			{
				dis[to[e]] = dis[head] + w[e];
				if(exist[to[e]] == false)
				{
					q.push(to[e]); //将被更新的点入队列 
					exist[to[e]] = true;
				}
			}
		}
	}
	return;
}

int main()
{
	cin >> n >> p >> c;
	for(int i=1; i <= n; i++) //输入每头牛所在的位置 
	{
		cin >> cow[i];
	}
	for(int e=1; e <= c; e++) //输入每一条边 
	{
		cin >> a >> b >> d;
		addEdge(a, b, d);
		addEdge(b, a, d);
	}
	for(int i=1; i <= p; i++) //注意是循环牧场
	{
		spfa(i);
		sum = 0;
		for(int j=1; j <= n; j++)
		{
			sum = sum + dis[cow[j]];
		}
		ans = min(ans, sum);
	}
	cout << ans;
	return 0;
}


```

动态数组Dijkstra：

```
#include<iostream>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;
int n, p, c;
const int INF = 1e9;
int cow[805], dis[805], vertex[805][805];
vector<int> neighbor[805]; 

struct Node
{
	int id, dist;
	bool operator < (const Node & second) const
	{
		return dist > second.dist;
	}
};

void dijkstra(int start)
{
	priority_queue<Node> pq;
	for(int i = 1; i <= p; i++)
    {
        dis[i] = INF;
    }
	dis[start] = 0;
	Node cur = {start, 0}; //起始点和其到dis[start] 
    pq.push(cur);
    while(!pq.empty())
    {
    	cur = pq.top();
    	pq.pop();
    	int u = cur.id;
    	for(int i=0; i <= neighbor[u].size() - 1; i++)
    	{
    		int v = neighbor[u][i]; //与u相邻的边v 
    		if(dis[u] + vertex[u][v] < dis[v])
    		{
    			dis[v] = dis[u] + vertex[u][v];
    			Node next;
    			next.id = v;
    			next.dist = dis[v];
    			pq.push(next);
			}
		}
	}
	return;
} 

int main()
{
	cin >> n >> p >> c;
	for(int i = 1; i <= n; i++) //输入每头牛所在的位置 
	{
		cin >> cow[i];
	}
	for(int i=1; i <= p; i++)
	{
		for(int j=1; j <= p; j++)
		{
			vertex[i][j] = (i == j) ? 0 : INF;
		}
	}
	for(int i=1; i <= c; i++) //输入每一条边 
	{
		int a, b, d;
		cin >> a >> b >> d;
		vertex[a][b] = d;
		vertex[b][a] = d;
		neighbor[a].push_back(b);
		neighbor[b].push_back(a); 
	}
	int ans = INF;
	for(int i=1; i <= p; i++) //注意是循环牧场
	{
		dijkstra(i); //假如把糖放在第i个牧场 
		int sum = 0;
		for(int j=1; j <= n; j++)
		{
			sum = sum + dis[cow[j]];
		}
		ans = min(ans, sum);
	}
	cout << ans;
	return 0;
}


```

# 好了，第二天就到这里，是不是都听懂了呢~~狗屁~~？欢迎在下方留言！

---

## 作者：炳源 (赞：4)

先贴代码（~~小小地加了个封装~~）
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
typedef long long int ll;
const int maxsize = 200100;
const int maxl = 500100;
int head[maxsize];
bool isdigit(char ch)
{
	if(ch >= '0' && ch <= '9')
		return 1;
	return 0;
}
inline int Read()
{
	int data = 0;
	char ch = getchar();
	while(!isdigit(ch))
		ch = getchar();
	while(isdigit(ch))
		data = (data << 3) + (data << 1) + ch - '0',ch = getchar();
	return data;
}
inline void Display(const int data)
{
	if(data / 10)
		Display(data / 10);
	putchar(data % 10 + '0');
}
struct E
{
	int next;
	int to;
	int val;
}edge[maxl];
int c_edge;
void addedge(int u,int v,int val)
{
	edge[++c_edge].next = head[u];
	edge[c_edge].to = v;
	edge[c_edge].val = val;
	head[u] = c_edge;
}
int n,m,s;
int dist[maxsize];
class Dijstra
{
	private :
		struct node
		{
			int u,dis;
			bool operator <(const node& __comp) const
			{
				return dis > __comp.dis;
			}
		};
		bool vis[maxsize];
		priority_queue<node> Q;
	public :
		void Query_min_dist(int pos)
		{
			dist[pos] = 0;
			Q.push((node){pos,0});
			while(!Q.empty())
			{
				node H = Q.top();
				Q.pop();
				int u = H.u,dis = H.dis;
				if(vis[u])
					continue;
				vis[u] = 1;
				for(int i = head[u];i;i = edge[i].next)
				{
					int To = edge[i].to;
					if(dist[To] > dist[u] + edge[i].val)
					{
						dist[To] = dist[u] + edge[i].val;
						if(!vis[To])
							Q.push((node){To,dist[To]});
					}
				}
			}
		}		
}Plan_of_Dijstra;
class Shortest_Path_Faster_Algorithm
{
	private :
		bool in[maxsize];
	public :
		void Query_min_dist(int x)
		{
			for(int i = 1;i <= n;i++)
				dist[i] = 2147483647;
			queue<int> Q;
			Q.push(x);
			dist[x] = 0;
			in[x] = 1;
			while(!Q.empty())
			{
				int H = Q.front();
				Q.pop();
				in[H] = 0;
				for(int i = head[H];i;i = edge[i].next)
				{
					int T = edge[i].to;
					if(dist[T] > dist[H] + edge[i].val)
					{
						dist[T] = dist[H] + edge[i].val;
						if(in[T] == 0)
						{
							Q.push(T);
							in[T] = 1;
						}
					}
				}
			}
		}
}Plan_of_SPFA;
class Floyd
{
	public :
		ll alldist[1010][1010];
		void Query_min_dist(int pos)
		{
			for(int k = 1;k <= n;k++)
				for(int i = 1;i <= n;i++)
					for(int j = 1;j <= n;j++)
						if(i != j)
							alldist[i][j] = min(alldist[i][j],alldist[i][k] + alldist[k][j]);
			for(int i = 1;i <= n;i++)
				dist[i] = alldist[pos][i];
		}
}Plan_of_Floyd;
int main()
{
	n = Read();m = Read();s = Read();
	for(int i = 0;i <= n;i++)
		dist[i] = 2147483647;
	if(n <= 1000)
		for(int i = 1;i <= n;i++)
			for(int j = 1;j <= n;j++)
				if(i != j)
					Plan_of_Floyd.alldist[i][j] = 2147483647;
	for(register int i = 1;i <= m;i++)
	{
		int u = Read(),v = Read(),val = Read();
		addedge(u,v,val);
		if(n <= 1000)
			Plan_of_Floyd.alldist[u][v] = val;
	}
	Plan_of_Dijstra.Query_min_dist(s);
	Plan_of_SPFA.Query_min_dist(s);
	Plan_of_Floyd.Query_min_dist(s);
	for(register int i = 1;i <= n;i++)
		Display(dist[i]),putchar(' ');
}
```  
![](https://cdn.luogu.com.cn/upload/image_hosting/ddan5f5q.png)
距离CSP-S还有54天  
蒟蒻~~怀着敬畏的心情~~来复习最短路  
对于最短路  它的定义通过百度我们可知
```
两节点（通常是源节点和阱节点）之间总权和最小的路径就是最短路
```
# 1.Dijkstra算法  
该算法以稳定著称，还有它的优化版海斯算法  
纯Dij算法时间复杂度有点小高，所以我们要考虑对它的优化  
（看到其它题解的各种优化算法，不觉感叹真的都太强了）  
然而我只会堆优化
## 原理：  
我们可以发现对于初始的dij算法，时间主要是消耗在对于dist数组的更新  
所以我们可以考虑把这个数组压进一个堆当中，这样就可以做到O(logn)的时间来查询这个dist数组  
其实题解榜一已经讲的很明白了  
## 缺点：
不能跑负权图，因为它不能够事先“预测”到下一个点再跑下一个边是否是一条负权路，只能够贪心贪到当前走到的最优值
# 2.SPFA
该算法以写得快，好理解著称，是西南交大的段凡丁教授在1994提出的名字，但是国际上在1957年已经有提出用队列优化SPFA的前身Bellman-Ford算法  
## 原理：
自己认为是可以用一点点DP的思想来理解，对于每一个点，放入队列中，就可以再次进行松弛操作，对于SPFA的各种优化，其实核心思想也就是把dist放到堆等各种数据结构里，这样SPFA就是一个可重复入队的dij算法  
## 缺点：
容易被“菊花图”卡掉，菊花图可以认为就是像菊花一样的一张图，就是一点多边，这样该算法的时间都会被消耗在对于松弛操作的查询  
# 3.Floyd
该算法以写得最快，最好理解闻名，是罗伯特·弗洛伊德这位巨佬提出的  
代码只有短短五行，不仅仅可以用来求单源最短路，对于图内各个点之间的距离都可以求出来
## 原理：
真正的DP思想，松弛操作，就是考虑对于一个点，走到另外一个点，是怎样走最短的操作那么反过来看，我们可以想到对于一个点，它到底可以松弛多少个点对，于是Floyd算法就这样出来了
## 缺点：
空间最大，时间最大，虽然披着动态规划的外衣，但确确实实是最暴力的写法  
但是对于小数据常常有奇效  
# 总结：
对于三种常用的算法我们Oier都要掌握得熟练，题目中都要认真的加以辨别，个人推荐刷15年以前的题目大多都可以用SPFA算法，然而之后“SPFA已死”，最好还是用dij算法啦  
# 最后
```
while (1)
CSP2019.rp++,CSP2019.score++;
```


---

## 作者：JK_LOVER (赞：4)

主要是来看看链式前向星
```cpp
struct Edge//链式前向星 
{
	int to;//目标点 
	int w;//权值 
	int next;//	上一条同起点的边的编号 
}edge[1500000];

int head[1500000];//最后输入的起点的边的编号 
int cnt=0;
void add(int u,int v,int d)//添加函数 
{
	cnt++;//当前编号 
	edge[cnt].w = d;
    edge[cnt].to = v;
    edge[cnt].next = head[u];//同起点的上一个边的编号 
    head[u] = cnt;
}            
```[](https://cdn.luogu.com.cn/upload/image_hosting/jzblpeuc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
链式前向星见上，现在直接上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf=2147483647;
struct Edge//链式前向星 
{
	int to;//目标点 
	int w;//权值 
	int next;//	上一条同起点的边的编号 
}edge[1500000];
int head[1500000];//最后输入的起点的边的编号 
int dis[6000000];//每个点的距离 
bool pd[6000000];//判断扩展过没 
int cnt=0,N,M,S;
struct node{
	int p;//目标点 
	int dist;//现距离 
	bool operator < (const node& x) const//重载运算符 
	{
		return x.dist < dist;
	}
};
priority_queue<node> q;
void add(int u,int v,int d)//添加函数 
{
	cnt++;//当前编号 
	edge[cnt].w = d;
    edge[cnt].to = v;
    edge[cnt].next = head[u];//同起点的上一个边的编号 
    head[u] = cnt;
}                  
void dj(int s)     
{
	node aa;
	dis[s]=0;
	aa.dist=0;
	aa.p=s;
	q.push(aa);//初始化 
	while(!q.empty())//函数主体 
	{
		node now,next;
		now=q.top();q.pop();//dist最小的边 
		int x=now.p;
		if(pd[now.p]) continue;
		pd[now.p]=true;//已拓展 
		for(int i=head[x];~i;i=edge[i].next)//同起点的边枚举直到到最后一条边退出 
		{
			int y=edge[i].to;
			if(dis[y]>dis[x]+edge[i].w)//是否更小 
			{
				dis[y]=dis[x]+edge[i].w;
				if(!pd[y])//未被拓展 
				{
					next.dist=dis[y];
					next.p=y;
					q.push(next);
				}
			}
		}
	}
}
int main()
{
	memset(pd,false,sizeof(pd));
	memset(head,-1,sizeof(head));//初始化 
	cin>>N>>M>>S;
	for(int i=1;i<=N;i++)
	{
		dis[i]=inf;//初始化
	}
	for(int i=1;i<=M;i++)//输入边 
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x,y,z);
	}
	dj(S);
	for(int i=1;i<=N;i++)
	cout<<dis[i]<<' ';//输出结果 
	return 0;
}
```




---

## 作者：Martin_MHT (赞：4)

### 前言
~~关于spfa，它死了~~  
所以，我们需要一个更稳定的算法——dijkstra.  

稳定的$O(n^2)$算法，你值得拥有！~~TLE~~

---
### 正解
好了不胡扯了，其实裸dijkstra($O(n^2)$)是会超时的，所以我们要优化它

想一想，dij最耗时间的$O(n)$在哪里呢？  
扩展节点、标记白点！

扩展节点以我们这种水平是难以优化的了，但标记白点呢？  
因为我们每一次只用选最小的节点来标记，所以完全可以优化成$O(logn)$

所以，优化后的复杂度……~~（我也不知道反正我过了）~~有大佬告诉我吗？

还有，本来我是手打堆的，炸了。。

于是用了STL优先队列（大部分都不会，我没学过STL，重载运算符[@Gaussian](https://www.luogu.org/space/show?uid=139340)大佬帮忙的）

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#define ARRLEN 100005
#define INF 2147483647
using namespace std;
struct Node
{
	int start;
	int value;
	bool operator <(const Node&R) const
	{
		return R.value<value;
	}
};
priority_queue<Node> h;
struct Edge
{
	int next;
	int to;
	int val;
}edge[ARRLEN*2];
int head[ARRLEN],len,n,m,s,dis[ARRLEN];
bool white[ARRLEN];
void add_edge(int start,int end,int v)
{
	len++;
	edge[len].next=head[start];
	edge[len].to=end;
	edge[len].val=v;
	head[start]=len;
}
void dij(int start)
{
	int u,v;
	for(int i=1;i<=n;i++)
		dis[i]=INF;
	dis[start]=0;
	// white[start]=true;
	h.push((Node){start,0});
	while(!h.empty())
	{
		Node tmp=h.top();
		u=tmp.start;
		h.pop();
		if(white[u])
			continue;
		white[u]=true;
		for(int i=head[u];i!=0;i=edge[i].next)
		{
			v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].val)
			{
				dis[v]=dis[u]+edge[i].val;
				if(!white[v])
				{
					h.push((Node){v,dis[v]});
				}
			}
		}
	}
}
int main()
{
	int u,v,f;
	scanf("%d %d %d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d %d",&u,&v,&f);
		add_edge(u,v,f);
	}
	dij(s);
	for(int i=1;i<=n;i++)
		printf("%d ",dis[i]);
	return 0;
}
```

当时我就懵了，这是什么操作？？不行，我这个狼火怎么能这样靠内置函数！  
上吧，我的手打堆！

注：
- 白点：已经不能松弛的点
- 蓝点：可以进行松弛的点

```cpp
#include <cstdio>
#define ARRLEN 100005//数组长度，边数要开2倍
#define INF 2147483647//无限大 2^31-1
using namespace std;
struct Node
{
	int start;//顶点(其实是终点)
	int value;//边权
}h[ARRLEN];//在堆中的结构体
void swap(Node &a,Node &b)	{Node t=a;a=b;b=t;}//交换不解释
struct Edge
{
	int next;
	int to;
	int val;
}edge[ARRLEN*2];//链式前向星存边
int head[ARRLEN],len,n,m,s,dis[ARRLEN],hl;
bool white[ARRLEN];//白点
void Up(int wz)//向上操作
{
	while(h[wz].value<h[wz/2].value&&wz>1)
	{
		swap(h[wz],h[wz/2]);
		wz/=2;
	}
}
void Down(int wz)//向下操作
{
	while((h[wz].value>h[wz*2].value&&wz*2<=hl)
    ||
    (h[wz].value>h[wz*2+1].value&&wz*2+1<=hl))
	{
		int t=wz*2;
		if(h[t+1].value<h[t].value&&t+1<=hl)
			t++;
		swap(h[wz],h[t]);
		wz=t;
	}
}
void Ins(Node in)//插入操作
{
	hl++;
	h[hl]=in;
	Up(hl);
}
void Del(int wz)//删除操作
{
	if (h[wz].value>h[hl].value)
	{
		h[wz]=h[hl];
		hl--;
		Up(wz);
	}
	else if(h[wz].value<h[hl].value)
	{
		h[wz]=h[hl];
		hl--;
		Down(wz);
	}
	else
	{
		h[wz]=h[hl];
		hl--;
	}
}

void add_edge(int start,int end,int v)
{
	len++;
	edge[len].next=head[start];
	edge[len].to=end;
	edge[len].val=v;
	head[start]=len;
}
void dij(int start)
{
	int u,v;
	for(int i=1;i<=n;i++)
		dis[i]=INF;
	dis[start]=0;
	Ins((Node){start,0});//在这里先把起点放进堆里
	while(hl)//相当于h.size()
	{
		Node tmp=h[1];//取出堆顶
		u=tmp.start;
		Del(1);//删除堆顶
		if(white[u])//如果不能松弛
			continue;
		white[u]=true;//将上一次更新边权最小的边的点更新为白点
		for(int i=head[u];i!=0;i=edge[i].next)//枚举每一条边
		{
			v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].val)
			{
				dis[v]=dis[u]+edge[i].val;
				if(!white[v])//如果不是白点
				{
					Ins((Node){v,dis[v]});//插入新边
				}
			}
		}
	}
}
int main()
{
	int u,v,f;
	scanf("%d %d %d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d %d",&u,&v,&f);
		add_edge(u,v,f);//加新边
	}
	dij(s);
	for(int i=1;i<=n;i++)
		printf("%d ",dis[i]);
	return 0;
}

```

关于堆，不懂的朋友可以看[这里](https://www.luogu.org/blog/BlueHedgehog/solution-p2676)超详细保证会！；  
关于dijkstra，不懂的朋友请移步[弱化版](https://www.luogu.org/problemnew/show/P3371)；  
#### END.

---

## 作者：doctorZ_ (赞：4)

做这到题前，我们先来回顾一下dijkstra算法思路和代码
![](https://img-blog.csdn.net/20170519112913377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFqb3Jfemhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

如上图，从点A->点F，最短路径为A->C->D->F，Min=3+3+3=9

dfs在图论中一直占据着重要的角色。可扩展到图论中割顶，桥，拓扑，双连通分量，强连通分量问题的解决上。在做一些算法题目的过程中，深搜感觉可以解决大部分搜索类题目了，但是深搜难在剪枝，剪枝可以减少大量不必要的搜索过程。

## 用链式前向星的Dijkstra算法的代码：
[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.org/problemnew/show/P3371)
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int n,m,s;
int st[11000],tot=0;
struct node
{
    int to,last,val;
}e[510000];
queue<int> q;
int dis[11000];
bool judge[11000];
void dij()
{
    memset(dis,0x7f,sizeof(dis));
    dis[s]=0;
    int u=s;
    while(!judge[u])
    {
    	judge[u]=true;
    	for(int i=st[u];i!=0;i=e[i].last)
    	{
    		int v=e[i].to;
    		if(dis[v]>dis[u]+e[i].val)
    			dis[v]=dis[u]+e[i].val;
        }
        int minn=2147483647;
        for(int i=1;i<=n;i++)
            if(!judge[i]&&dis[i]<minn)
            {
                u=i;
                minn=dis[i];
            }
    }
}
void add(int a,int b,int c)
{
    e[++tot].to=b;
    e[tot].val=c;
    e[tot].last=st[a];
    st[a]=tot;
}
int main()
{
    scanf("%d %d %d",&n,&m,&s);
    for(int i=1;i<=m;i++)
    {
        int a,b,w;
        scanf("%d %d %d",&a,&b,&w);
        add(a,b,w);
    }
    dij();
    for(int i=1;i<=n;i++)
        if(dis[i]==2139062143)
            printf("2147483647 ");
        else
            printf("%d ",dis[i]); 
    return 0;
}
```
Dij算法是基于广搜，松弛的时候有点贪心和动态规划的思想。

使用邻接矩阵实现的dijkstra算法的复杂度是O(V²)。使用邻接表的话，更新最短距离只需要访问每条边一次即可，因此这部分的复杂度是O(E).但是每次要枚举所有的顶点来查找下一个使用的顶点，因此最终复杂度还是O(V²)。在|E|比较小时，大部分的时间都花在了查找下一个使用的顶点上，因此需要使用合适的数据结构进行优化。

堆优化+dijkstra算法

堆的实现原理这里就不说了，在很多书里面都有详细介绍。

下面是手打堆实现。在每次更新时往堆里插入当前最短距离和顶点的值对。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 110000
#define M 1000000
using namespace std;
int n,m,s;
int st[N+1],tot;
struct edge
{
    int to,last,val;
}e[M+1];
void add(int a,int b,int c)
{
    e[++tot].to=b;
    e[tot].val=c;
    e[tot].last=st[a];
    st[a]=tot;
}
int num;
struct node
{
    int pos,dis;
}heap[5*N+1];
void up(int x)
{
    while(x!=1&&heap[x].dis<heap[x/2].dis)
    {
        swap(heap[x],heap[x/2]);
        x/=2;
    }
}
void down(int x)
{
    while(heap[x].dis>heap[2*x].dis&&2*x<=num||heap[x].dis>heap[2*x+1].dis&&2*x+1<=num)
    {
        int y=2*x;
        if(heap[y+1].dis<heap[y].dis&&y+1<=num)
            y++;
        swap(heap[x],heap[y]);
        x=y;
    }
}
void insert(int x,int b)
{
    heap[++num].dis=x;
    heap[num].pos=b;
    up(num);
}
int dis[N+1];
bool judge[N+1];
void dij()
{
    for(int i=1;i<=n;i++)
        dis[i]=2147483647;
    dis[s]=0;
    insert(0,s);
    while(num!=0)
    {
        node p=heap[1];
        heap[1]=heap[num--];
        down(1);
        int u=p.pos;
        if(judge[u]||dis[u]!=p.dis)
            continue;
        judge[u]=true;
        for(int i=st[u];i!=0;i=e[i].last)
        {
            int v=e[i].to;
            if(dis[v]>dis[u]+e[i].val)
            {
                dis[v]=dis[u]+e[i].val;
                if(!judge[v])
	                insert(dis[v],v);
            }
        }
    }
}
int main()
{
    scanf("%d %d %d",&n,&m,&s);
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        scanf("%d %d %d",&a,&b,&c);
        add(a,b,c);
    }
    dij();
    for(int i=1;i<=n;i++)
        printf("%d ",dis[i]);
    return 0;
}
```
后记

本文部分内容摘自[https://blog.csdn.net/major_zhang/article/details/72519233](https://blog.csdn.net/major_zhang/article/details/72519233)

---

## 作者：封禁用户 (赞：4)

# SPFA的题解在哪里？？？

## SPFA还没有死！！！

既然dijkstra可以使用堆优化，spfa一样可以！

spfa的堆优化：每次从堆中只需要取出最小的元素进行松弛，这样便可以大大缩小松弛的次数，效率从而得到提高。

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2147483647;
const int N=100005;
int d[N];
vector<pair<int,int>>edge[N];
priority_queue<pair<int,int> >q;
int main()
{
	int n,m,s,f,g,w;
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&f,&g,&w);
		edge[f].push_back(make_pair(g,w));
	}
	for(int i=1;i<=n;i++)
		d[i]=INF;
	d[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		int k=q.top().second;
		if(d[k]!=-q.top().first)
		{
			q.pop();
			continue;
		}
		q.pop();
		for(int i=0;i<(int)edge[k].size();i++)
		{
			int v=edge[k][i].first,u=edge[k][i].second;
			if(d[v]>d[k]+u)
			{
				d[v]=d[k]+u;
				q.push(make_pair(-d[v],v));
			}
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d ",d[i]);
	return 0;
}

```

---

## 作者：Mine_King (赞：3)

温馨提示：$SPFA$的时间复杂度是**声称**O(m)，最坏情况O(nm)，**容易被卡到最坏**。所以……想学$SPFA$的请移步[这里](https://www.luogu.org/blog/yhdhg1395754790/)的[这里](https://www.luogu.org/blog/yhdhg1395754790/solution-p3371)  
所以这题的正解应该是$dijkstra!$  
那么我们讲讲$dijkstra$怎么写：首先，是和$SPFA$一样的初始化。然后，把起点标记为访问。然后更新与其相连的点的最短路的值（就是松弛）。再找到未访问的点中最短路的值最小的点，重复以上操作。  
具体实现起来就是这个亚子：  
![](https://cdn.luogu.com.cn/upload/pic/71301.png)  
讲完基础的，再来讲一下细节问题：这个细节决定了**时间复杂度**！  
这个细节就是“找到未访问的点中最短路的值最小的点”。  
两种方法：  
第一种：高端霸气上档次，非常实用……（此处省略10000字）的**爆扫**！[滑稽]。爆扫的时间复杂度是O($n^2$)，个人感觉和$SPFA$没有什么区别，不建议使用。  
第二种：~~高端霸气上档次的~~优先队列！该方法是当一个点的最短路的值被更新后，就将其加入小根堆。这时小根堆里会出现多个相同的点。但是我们用过一个点之后就会将其标记，所以不会有问题。时间复杂度是O(mlogn)  
什么？你不知道小根堆是什么？戳[这里](https://www.luogu.org/blog/yhdhg1395754790/solution-p3378)  
但我们是不会手打小根堆的，太麻烦了。于是，我们就要用到`priority_queue`。他是系统自带优先队列，但是是大根堆。所以我们要这样做：
```cpp
priority_queue<int, vector<int>, greater<int> >//注意，这里要有空格，不然系统会判为位运算符
```
现在是最后一个问题：我们是要按照每个点的值来排序的。但我们同时也要记录他的编号。这时，我们就需要`pair`。不知到的就自行百度吧…所以，我们可以这么定义：
```cpp
priority_queue<pair<int,int>, vector<pair<int,int> >, greater<pair<int,int> > >
```
所有问题都解决了，那么上代码吧。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
vector<int>g[200005];
vector<int>d[200005];
int v[100005];
bool f[100005];
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
int main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++)
	{
		int ff,tt,dd;
		cin>>ff>>tt>>dd;
		g[ff].push_back(tt);
		d[ff].push_back(dd);//建图
	}
	for(int i=1;i<=n;i++) v[i]=1e10;//初始化
	q.push(make_pair(0,s));//压入起点，make_pair是返回一个pair值。
	v[s]=0;
	while(!q.empty())
	{
		int xx=q.top().second;//psir有两个值，返回第一个是.first，第二个是.second。小根堆以第一个值排序，所以第一个放值，第二个放编号
		q.pop();//记得谈出！！！
		if(!f[xx])//判断是否被访问过
		{
			f[xx]=true;//记得标记！！！
			for(int i=0;i<g[xx].size();i++)
			 if(v[g[xx][i]]>v[xx]+d[xx][i])//松弛
		 	 {
			 	v[g[xx][i]]=v[xx]+d[xx][i];
			 	q.push(make_pair(v[g[xx][i]],g[xx][i]));//加入小根堆
			 }
		}
	}
	for(int i=1;i<=n;i++) cout<<v[i]<<' ';
	return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：3)

# SPFA死了？不存在的！

我不喜欢带log的复杂度。我爱SPFA。

但SPFA被卡已成事实，怎么办？

看看大家都怎么做的——priority_queue来减少入队次数

我们可以使用一些玄学的东西，**使SPFA中的队列更接近优先队列**

他来了——

## deque优化SPFA

我们开一个双端队列，实时维护首尾，保证首 < 尾，这样可以有效

打乱精心设计的hack数据，使各点入队次数减少，并使图更随机。

见代码：

```cpp
//deque优化的SPFA
#include<bits/stdc++.h>
using namespace std;
const int M=500005;
const int N=100005;
inline int read(){
	char ch=getchar();int x=0;
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}
int n,m,s;
int u[M],v[M],w[M];
int next[M],first[N];
bool vis[N];
int dis[N];
deque<int> q;//双端队列 
inline void init(){//初始化 
	for(int i=1;i<=n;i++)dis[i]=2147483647;
	dis[s]=0;q.push_back(s);
	vis[s]=1;
}
inline void spfa(){
	while(q.size()){
		int x=*q.begin();q.pop_front();
		vis[x]=0;
		//取出队列头尾两点中距离较小的进行松弛 
		//注意加q.size()一句，否则在取出x后队列为空时会RE 
		if(q.size() && dis[*q.begin()]>dis[*(q.end()-1)])
			swap(*q.begin(),*(q.end()-1));
		for(int i=first[x];i;i=next[i]){
			int y=v[i];
			if(dis[x]+w[i]<dis[y]){
				dis[y]=dis[x]+w[i];
				if(!vis[y]){
					vis[y]=1;
					//维护首<尾 
					if(q.size() && dis[y]>dis[*q.begin()])q.push_back(y);
					else q.push_front(y);
				}	
			}
		}
	}
}
int main(){
	n=read(),m=read(),s=read();
	for(int i=1;i<=m;i++){
		u[i]=read(),v[i]=read(),w[i]=read();
		//邻接表 
		next[i]=first[u[i]];
		first[u[i]]=i;
	}
	init();
	spfa();
	for(int i=1;i<=n;i++)
		printf("%d ",dis[i]);
	puts("");
    return 0;
}
```
跑得贼快, 5个点161ms。

#### **Update** 
现在出了第六个大数据，hack得真好，跑了900+ms

但对SPFA的优化是不会停的！SPFA是不会死的！



---

## 作者：yeaDonaby (赞：3)

## 求单源最短路径！
求最短路核心步骤：relax松弛操作


![](https://i.loli.net/2019/06/27/5d145b659fbf762565.png)

```
if(map[A][B]+map[B][C]<map[A][C])
{
	map[A][C]=map[A][B]+map[B][C];
}
```
这里介绍3种算法：


------------

### 1.dijkstra:
算法步骤：
1.找到离起点x**最近**的**未讨论**的点k

**2.判断经过k点， 起点x到其他点的距离是否
缩短， 如缩短则更新。 将k点标记为已讨论。(relax)**

3.返回第1步， 直到所有点都被讨论过。

##### 不能处理负权！！！
#### 不能处理负权！！！
### 不能处理负权！！！
#### 朴素版：

### O（n*n）
```
#include<iostream>
using namespace std;
const int inf=100000001;int mini,k;
int map[101][101],dis[101],mark[101];
void dijkstra(int x)//求从x点出发到其他点的最短距离
{
	////////初始化////////
	for(i=1; i<=n; i++)//初始化数据 
	{
		dis[i]=map[x][i];//mark记录第i号节点是否讨论过 
		mark[i]=false;//初始化dis数组，dis【i】记录起点x到点i的距离 
	}
	mark[x]=1;//讨论起点
	////////算法执行过程////////
	while(1)
	{
		mini=inf;//inf为自定义常量表示无穷大，例如const int inf=999999999 
		k=0;//k记录离x最近的编号 
		for(i=1; i<=n; i++)//寻找当前离x最近且未讨论的点 
		{
			if(mark[i]==0&&dis[i]<mini)
			{
				mini=dis[i]; 
				k=i;
			}
		}
		//讨论k为中转点，有没有其他点到x的距离缩短
		if(k>0)
		{
		mark[k]=1;//点k已讨论过 
			for(i=1; i<=n; i++)//讨论每个点，若距离缩短更新dis【i】
			{
				if(dis[k]+map[k][i]<dis[i])
				{
					dis[i]=dis[k]+map[k][i];
				}
			}
		}
		else break;//k==0表是全部讨论过了 
	}
}
int main()
{
	int i,j,n,m,x,y,a,b,c;
	cin>>n>>m;
	for(i=1; i<=n; i++)
	{
		for(j=1; j<=n; j++)
		{
			if(i==j)
			{
				map[i][j]=0;
			}
			else
			{
				map[i][j]=inf;
			}
		}
	}
	for(i=1; i<=m; i++)
	{
		cin>>a>>b>>c;
		map[a][b]=c;
	}
	cin>>x>>y;
	dis[x]=0;
	dijkstra(x);
	cout<<dis[y];
	return 0;
}
```
#### 优化版：

堆优化+vector

vector，实际上就是个动态数组。随机存取任何元素都能在常数时间完成。
在尾端增删元素具有较佳的性能,但在中间插入慢。它里面存储的元素可以是任意类型。

#include<vector>
常用函数：
push_back()－在数组尾部添加一个元素e,数组长度自动+1

pop_back()－删除数组最后一个元素,但无返回值,数组长度自动-1
  
front()－得到数组第一个元素
  
back()-得到数组最后一个元素
  
size()-数组中元素的个数
  
empty()-判断数组是否为空
  
clear()-清空整个数组

可用下标来修改**已存在**的元素

### O（n*logn）
**常数略大**
```
#include<stdio.h>
#include<vector>
#include<queue>
#define maxn 101
#define I inline
#define R register
#define inf 0x7ffff
using namespace std;
int n,m,x,y,z,dis[maxn];
bool mark[maxn];
struct node
{
	int num,dis;
	bool operator<(const node &a) const
	{
		return a.dis<dis;
	}
};
struct map
{
	int end;
	int len;
} edge;
vector<map> g[maxn];
I void dijkstra(int s)
{
	int t;
	priority_queue<node> q;
	node tmp;
	tmp.num=s;
	tmp.dis=0;
	q.push(tmp);
	while(!q.empty())
	{
		int u=q.top().num;
		q.pop();
		if(mark[u])
		{
			continue;
		}
		mark[u]=true;
		for(int i=0; i<g[u].size(); i++)
		{
			int v=g[u][i].end;
			int l=g[u][i].len;
			if(dis[v]>dis[u]+l)
			{
				dis[v]=dis[u]+l;
				tmp.num=v;
				tmp.dis=dis[v];
				q.push(tmp);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(R int i=1; i<=n; i++)
	{
		dis[i]=inf;
	}
	for(int i=1; i<=m; i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		edge.end=y;
		edge.len=z;
		g[x].push_back(edge);
	}
	scanf("%d%d",&x,&y);
	dis[x]=0;
	dijkstra(x);
	printf("%d",dis[y]);
	return 0;
}
```

堆优化+链式前向星

### O（n*logn）

代码类似，讲一下链式前向星。
```
#define maxm 1000000
#define maxn 10000
int Next[maxm],end[maxm],len[maxm],last[maxn];
//Next[i]表示跟第i条边有相同起点的上一条边的编号
//last[x]表示以x为起点的边最新一条的边的编号
cin>>n>>m;
for(int i=1; i<=m; i++)
{
	scanf("%d%d%d",&x,&y,&z);
	end[i]=y;
	len[i]=z;
	Next[i]=last[x];
	Last[x]=i;
}
```


------------
                      
### 2.SPFA
                  
spfa可以处理负权。
                      
SPFA是Bellman-Ford算法的一种队列实现，减少了不必要的冗
余计算。
                  
算法流程:
                  
用一个队列来进行维护。初始时将起点加入队列。每次从队
列中取出一个元素，并对所有与他相邻的点进行松弛，若某个相
邻的点松弛成功（到起点距离缩短），则将其入队。直到队列为
空时算法结束。
                  
简单的说就是队列优化的bellman-ford,利用了每个点不会更新次数太多的特点。
                  
SPFA的时间复杂度是O(kE) k一般取2左右（k是增长很快的函数ackermann的反函数,2^65536次方也就5以下 ）,可以处理负边。
                  
SPFA的实现甚至比Dijkstra或者 Bellman_Ford还要简单。
                      
```
#include<stdio.h>
#include<queue>
#define maxn 101
#define R register
#define inf 0x7ffffff
using namespace std;
int n,m,x,y,z;
queue<int> q;
int dis[maxn],map[maxn][maxn];
bool f[maxn];
void spfa(int s)
{
	for(R int i=1; i<=n; i++)
	{
		dis[i]=inf;
	}
	q.push(s);
	f[s]=true;
	dis[s]=0;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		f[x]=false;
		for(R int i=1; i<=n; i++)
		{
			if(dis[x]+map[x][i]<dis[i])
			{
				dis[i]=dis[x]+map[x][i];
				if(!f[i])
				{
					q.push(i);
					f[i]=true;
				}
			}
		}
	}
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(R int i=1; i<=n; i++)
	{
		for(R int j=1; j<=n; j++)
		{
			map[i][j]=inf;
		}
	}
	for(R int i=1; i<=m; i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		map[x][y]=z;
	}
	scanf("%d%d",&x,&y);
	spfa(x);
	printf("%d",dis[y]);
	return 0;
}
```
map可以优化，与dijkstra类似。
###### (~~我就不贴了~~)
  
**用spfa判负权回路：如果任意一条边被修改大于n-1次，就代表这个图内一定存在至少一个负权回路。**
  
spfa容易被卡，卡spfa的图叫菊花图。
  
例如：
  
![](https://i.loli.net/2019/06/27/5d14656e5d50368069.png)
  
floyd:
  
floyd背后是矩阵乘法，这里不讲了。
  
floyd是求多源最短路径。
  
可以处理负权。
  
### O(n* n *n);
```
for(k=1; k<=n; k++)
	{
		for(i=1; i<=n; i++)
		{
			for(j=1; j<=n; j++)
			{
				if(m[i][j]>m[i][k]+m[k][j])
				{
					m[i][j]=m[i][k]+m[k][j];
				}
			}
		}
	}
```
是否可以调换k的位置？写成下列形式：
```
for(i=1; i<=n; i++)
	{
		for(j=1; j<=n; j++)
		{
			for(k=1; k<=n; k++)
			{
				if(m[i][j]>m[i][k]+m[k][j])
				{
					m[i][j]=m[i][k]+m[k][j];
				}
			}
		}
	}  
```
问题出在我们太早的把i—k—j的距离确定下来了，假设一旦k=p时，找到了i—p—j为最短的距离后，i到j就相当处理完了，以后不会再改变了，一旦以后有使i到j的更短的距离时也不能再去更新了，所以结果一定是不对的。

floyd太慢,此题不用。

---

## 作者：G我就是菜G (赞：3)

## 【pascal题解】
上次那个弱化版的堆优化加了似乎跟没加一样[弱化版](https://www.luogu.org/problemnew/show/P3371)（原谅我一个蒟蒻挑了几个晚上才调出来……）其实就是把数组开大，在弱化版的基础上维护小根堆时判断点是否已经在堆中即可，如果在堆中，则更改heap值，否则加入队列【详见代码】。

代码：
```
  var n,m,k,ledge,i,b,x,y,z:longint;
      ff,head,num:array[0..200001]of longint;
      //比上次多了个ff记录是否在堆中
      heap,dis:array[0..200001]of int64;
      edge:array[0..200001]of record
        y,nxt,z:longint;
      end;
  procedure swap(var a,b:longint);
  var t:longint;
  begin
        t:=a;a:=b;b:=t;
  end;


  procedure swap1(var a,b:int64);
  var t:int64;
  begin
        t:=a;a:=b;b:=t;
  end;


  procedure add(x,y,z:longint);
  begin
        inc(ledge);
        edge[ledge].y:=y;
        edge[ledge].z:=z;
        edge[ledge].nxt:=head[x];
        head[x]:=ledge;
  end;  //链式前向星储存


  procedure insert(a,x:longint);
  var i:longint;
  begin
        if ff[x]<>0 then  //如果已经在堆中，返回堆中位置
        begin
                heap[ff[x]]:=a;
                i:=ff[x];
        end
        else
        begin
                inc(heap[0]);
                heap[heap[0]]:=a;
                num[heap[0]]:=x;
                i:=heap[0];
                ff[x]:=heap[0];
        end;
        while (i div 2>0)and(heap[i]<heap[i div 2]) do
        begin
                swap(ff[num[i]],ff[num[i div 2]]);
                swap1(heap[i],heap[i div 2]);
                swap(num[i],num[i div 2]);
                i:=i div 2;
        end;
  end;


  procedure del;
  var mid,i:longint;
  begin
        ff[num[1]]:=0;  //弹出堆顶元素
        heap[1]:=heap[heap[0]];
        num[1]:=num[heap[0]];
        dec(heap[0]);
        i:=1;
        if (heap[i*2]<heap[i*2+1])or(i*2=heap[0]) then mid:=i*2
        else mid:=i*2+1;
        while (mid<=heap[0])and(heap[mid]<heap[i]) do
        begin
                swap(ff[num[i]],ff[num[mid]]);
                swap1(heap[i],heap[mid]);
                swap(num[i],num[mid]);
                i:=mid;
                if (heap[i*2]<heap[i*2+1])or(i*2=heap[0]) then mid:=i*2
                else mid:=i*2+1;
        end;
  end;


  begin
        readln(n,m,k);
        for i:=1 to m do
        begin
                readln(x,y,z);
                add(x,y,z);
        end;
        fillchar(dis,sizeof(dis),$7f);
        dis[k]:=0;
        b:=k;
        heap[0]:=1;heap[1]:=0;num[1]:=k;
        while heap[0]<>0 do
        begin
                i:=head[b];
                while i<>0 do
                begin
                        if dis[b]+edge[i].z<dis[edge[i].y] then
                        begin
                                dis[edge[i].y]:=dis[b]+edge[i].z;
                                insert(dis[edge[i].y],edge[i].y);
                        end;
                        i:=edge[i].nxt;
                end;
                del;
                b:=num[1];
        end;
        for i:=1 to n do
                write(dis[i],' ');
        writeln;
  end.
```


推广：[【蒟蒻的博客 欢迎来踩】](https://www.luogu.org/blog/czxshenshen/)

---

## 作者：Leaved_ (赞：3)

[二倍经验](https://www.luogu.org/problem/P3371) P3371


~~话说这题好像和P3371没啥区别~~

好吧，这道题较P3371来说数据比较~~毒瘤~~，稍不注意就会TLE...

标准的堆优化Dij就可以把这种~~毒瘤题~~卡过去啦！！！

代码：（堆优化dij）

```
#include <bits/stdc++.h>

using namespace std;

int n,m,s,tot;
long long dis[1000010<<1],h[2000010<<1];
bool used[2000010<<1];

priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;//堆优化
//别忘了加空格，要不然在编译器眼里和右移没什么两样
//So，你可以收获一片黄色...
//希望你别“涉黄”

struct Node {
	long long to,w,next;
}e[2000010<<1];

void add_edge(long long x,long long y,long long z) {
	++tot;
	e[tot].to=y;
	e[tot].next=h[x];
	e[tot].w=z;
	h[x]=tot;
}

void input() {
	long long u,v,w;
	cin>>n>>m>>s;
	for(long long i=1;i<=m;i++) {
		cin>>u>>v>>w;
		add_edge(u,v,w);
	}
}

void Dijkstra() {
	while(q.size()) {
		long long u=q.top().second;
		q.pop();
		if(used[u]) continue;
		used[u]=1;
		for(int i=h[u];i;i=e[i].next) {
			long long v=e[i].to;
			if(dis[v]>dis[u]+e[i].w) {
				dis[v]=dis[u]+e[i].w;
				q.push(make_pair(dis[v],v));
			}
		}
	}
}

void output() {
	for(int i=1;i<=n;i++) {
		cout<<dis[i]<<" ";
	}
}

int main() {
	input();
	for(int i=1;i<=n;i++) {
		dis[i]=2147483647;//初始化
	}
	dis[s]=0;//起点
	q.push(make_pair(0,s));
	Dijkstra();
	output();
}
```

---

## 作者：ez_lcw (赞：3)

# dijkstra+小根堆优化
不会dijkstra的请先看一下[这位大佬博客的讲的dijkstra的基本思想（看不懂代码没关系，我也看不懂，这篇题解有具体的代码）](https://blog.csdn.net/qq_35644234/article/details/60870719)

一看到着这题的n_max值：100000，又想到SPFA的时间复杂度：复杂度$O(kE)$（最坏好像是$O(VE)$）（k为常数，一般<=2）自然要想到用[dijkstra](https://baike.baidu.com/item/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95?fromtitle=Dijkstra%E7%AE%97%E6%B3%95&fromid=215612)了。

但是，如果直接用dijkstra会TLE，所以我们要用到堆优化，简单的实现方法是用[优先队列](https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/9354754?fr=aladdin)（priority_queue），优，那么还是要学一学用[二叉堆](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E5%A0%86/10978086?fr=aladdin)（[小根堆](https://www.luogu.org/blog/lc-2018-Canton/shou-xie-er-cha-dui-xiao-gen-dui-post)），也就是优先队列的一种实现方法来做。

那么什么是二叉堆呢？二叉堆就是一颗完全二叉树或者是近似完全二叉树，小根堆是一种二叉堆。

## 关于小根堆的一些规则：

**1、这是是一颗完全二叉树或者是近似完全二叉树。**

**2、这棵树里的每一棵树的根的儿子（左儿子、右儿子）都小于这棵树的根。**

**3、这棵树的每一个节点（除根节点外）的父亲都是编号$floor(num/2)$（向下取整），同理每个节点的儿子（除叶节点外）的编号都是$2*num$、$2*num+1$。**

### 插入的规则：

**直接将元素塞入堆尾，然后不断与其父节点（不是堆里的前一个节点）比较，如果这个元素小于其父节点，则交换两个元素，直到为根或符合条件为止。**

### 删除堆顶的规则：

**现将堆顶元素删除，再将堆底的元素a加入堆顶，先找其儿子节点，比较它们的大小，如果a比小的那个元素大，则交换这两个元素的位置，再继续比较a现在的儿子，直到a成为叶节点或符合条件为止。**

这样，小根堆的第一个元素绝对是最小的（后面的元素不一定按从小到大顺序排序，但一定满足每一个节点（除根节点外）都小于其父节点）。

那么我们就可以用二叉堆来代替优先队列了。

具体代码和详解如下：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>

#define N 100001
#define M 200001
#define INF 0x7fffffff

using namespace std;

int n,m,s,head[N],to[M],w[M],nxt[M],dis[N],cnt;
bool vis[N];

struct data{//u表示当前的点的编号，s表示当前的耗费（路程）
    int u,s;
}now;

class Heap_little {//小根堆
    public://公开的变量/函数
        int size(){//返回长度
            return len;
        }
        data top(){//返回堆顶元素
            return heap[1];
        }
        void push(data x) {//插入元素
            heap[++len]=x;
            int now=len;
            while(now!=1&&heap[now/2].s>heap[now].s) {//如果当前元素比它的父亲节点小，则交换这两个节点
                swap(heap[now/2],heap[now]);
                now/=2;//更新当前节点
            }
        }
        void pop(){
            heap[1]=heap[len--];//弹出堆顶元素，将堆尾元素放入堆顶
            int pa=1,s;
            while(1){
                s=pa*2;//这个点的左儿子
                if(s<=len&&heap[s+1].s<heap[s].s){
                    s++;//如果右儿子更小，则把s改为右儿子
                }
                if(s>len||heap[pa].s<=heap[s].s){
                    break;//如果已经到堆尾或符合条件了，则退出
                }
                swap(heap[pa],heap[s]);//交换这两个元素
                pa=s;
            }
        }
        bool empty(){//判断堆是否为空
            if(!len){
                return true;
            }else{
                return false;
            }
        }
    private://不公开的变量/函数
        int len;
		data heap[N];
}q;

void adde(int u,int v,int wi){//链式前向星存图
    cnt++;
    to[cnt]=v;//记录这条边的终点
    w[cnt]=wi;//记录这条边的权值
    nxt[cnt]=head[u];//记录nxt
    head[u]=cnt;//更新head
}

void dijkstra(){
    memset(dis,127,sizeof(dis));//现将dis数组设为最大
    q.push((data){s,0});//将起点扔进堆里
    while(!q.empty()){//如果堆没有空
        now=q.top();
        q.pop();
        if(vis[now.u]){//如果已经有人来过了，则continue
            continue;
        }
        vis[now.u]=true;//标记
        dis[now.u]=now.s;//更新dis
        for(int i=head[now.u];i;i=nxt[i]){
            if(!vis[to[i]]&&now.s+w[i]<dis[to[i]]){//如果没有去过并且是更优方案，就扔进堆里
                q.push((data){to[i],now.s+w[i]});
            }
        }
    }
}

int main(){
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        adde(u,v,w);//建边
    }
    dijkstra();
    for(int i=1;i<=n;i++){
        printf("%d ",dis[i]);//输出
    }
    puts("");//输出后换行，养成好习惯
    return 0;
}
```

在补充一篇用**优先队列**实现的代码：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>

#define N 100001
#define M 200001
#define INF 0x7fffffff

using namespace std;

int n,m,s,head[N],to[M],w[M],nxt[M],dis[N],cnt;
bool vis[N];

struct data{
    int u,s;
    bool operator < (const data &a) const {//重载运算符
        return s>a.s;
    }
}now;

priority_queue<data>q;//优先队列

void adde(int u,int v,int wi){//链式前向星存图
    cnt++;
    to[cnt]=v;//记录这条边的终点
    w[cnt]=wi;//记录这条边的权值
    nxt[cnt]=head[u];//记录nxt
    head[u]=cnt;//更新head
}

void dijkstra(){
    memset(dis,127,sizeof(dis));//现将dis数组设为最大
    q.push((data){s,0});//将起点扔进队列里
    while(!q.empty()){//如果队列没有空
        now=q.top();
        q.pop();
        if(vis[now.u]){//如果已经有人来过了，则continue
            continue;
        }
        vis[now.u]=true;//标记
        dis[now.u]=now.s;//更新dis
        for(int i=head[now.u];i;i=nxt[i]){
            if(!vis[to[i]]&&now.s+w[i]<dis[to[i]]){//如果没有去过并且是更优方案，就扔进队列里
                q.push((data){to[i],now.s+w[i]});
            }
        }
    }
}

int main(){
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        adde(u,v,w);//建边
    }
    dijkstra();
    for(int i=1;i<=n;i++){
        printf("%d ",dis[i]);//输出
    }
    puts("");
    return 0;
}
```

顺便补充一点：有负权千万别有dijkstra，乖乖用~~死了的~~SPFA吧~~（Floyd就不想说了，用那个东西还不如打暴力）~~。

---

## 作者：fyfy (赞：3)

没什么好说的.

坑定是卡SPFA，所以这里给一个迪杰斯特达(堆优化)的板子.

普通迪杰斯特拉坑定过不了(n^2),加了堆优化就跑的飞快(nlogn).


```cpp
//dijkstra-dyh
#include <cstdio>
#include <cstring>
#include <queue>
#define MAXN 10010
using namespace std;
typedef pair<int,int>Pair;

struct node {
  int u,w,v,next;
}e[500010];

int dis[MAXN],st[MAXN];
bool flag[MAXN];
int tot,start,n,m,x,y,z;

void add(int x,int y,int z)
{
  e[++tot].u=x;e[tot].v=y;
  e[tot].w=z;
  e[tot].next=st[x];st[x]=tot;
}

int dijsktra(int start)
{
  memset(dis,127,sizeof dis);
  memset(flag,0,sizeof flag);
  dis[start]=0;priority_queue< Pair,vector<Pair>,greater<Pair> >que;
  que.push(make_pair(dis[start],start));
  while (!que.empty()) {
    Pair now=que.top();que.pop();
    if (flag[now.second]) continue;
    flag[now.second]=1;
    for (int i=st[now.second];i;i=e[i].next)
    if (dis[now.second]+e[i].w<dis[e[i].v]) {
      dis[e[i].v]=dis[now.second]+e[i].w;
      if (!flag[e[i].v]) que.push(make_pair(dis[e[i].v],e[i].v));
    }
  }
  for (int i=1;i<=n;i++) {
    if (dis[i]==2139062143) dis[i]=2147483647;
    printf("%d ",dis[i]);
  }
}
int main()
{
  scanf("%d%d%d",&n,&m,&start);
  for (int i=1;i<=m;i++) {
    scanf("%d%d%d",&x,&y,&z);
    add(x,y,z);
  }
  dijsktra(start);
}
```

---

## 作者：brnhbrnh (赞：2)

dijkstra的题解挺多的我就不提交解释了，这里给一个使用template来重定义stl的想法。

首先我们知道priority_queue默认大根堆，但是也给了一种定义小根堆的方法
```cpp
priority_queue<int,vector<int>,greater<int> > q;
```
那我就可以通过重新定义greater的方式来完成对struct的排序（其他题解都在struct里重定义小于号）

先找到stl里的greater
```cpp
 template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
```
仿照他的写法写一份
```cpp
template <typename _t> struct QAQ
{
	bool operator ()(const _t &x,const _t &y)
	const {return x.dis>y.dis;}
};
```
然后像刚才那样开优先队列
```cpp
priority_queue<node,vector<node>,QAQ<node> > q;
```
如丝般顺滑的完成了这个操作，这样操作好处就是可以根据不同的要求更换不同的排列方式（虽然想不到什么时候要更换23333）

下面附上AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
const int maxm=2e5+5;
const int INF=1<<30;
struct edge
{
	int n,v,d;
} e[maxm];
int h[maxn],p=0;
void ac(int u,int v,int d)
{
	e[++p].n=h[u];
	e[p].v=v;
	e[p].d=d;
	h[u]=p;
}
int N=0,M=0,S=0;bool vis[maxn];
struct node
{
	int dis,id;
} tt[maxn];
template <typename _t> struct QAQ
{
	bool operator ()(const _t &x,const _t &y)
	const {return x.dis>y.dis;}
};
priority_queue<node,vector<node>,QAQ<node> > q;
void dijkstra()
{
	while(!q.empty())
	{
		node xx=q.top();q.pop();
		if(vis[xx.id]) continue;
		int u=xx.id;
		vis[u]=1;
		for(int i=h[u];i!=-1;i=e[i].n)
		{
			if(tt[u].dis+e[i].d<tt[e[i].v].dis)
			{
				tt[e[i].v].dis=tt[u].dis+e[i].d;
				q.push(tt[e[i].v]);
			}
		}
	}
}
int main()
{
	memset(h,-1,sizeof(h));
	scanf("%d%d%d",&N,&M,&S);
	int u=0,v=0,d=0;
	for(int i=1;i<=M;i++)
	{
		scanf("%d%d%d",&u,&v,&d);
		ac(u,v,d);
	}
	for(int i=1;i<=N;i++) tt[i].dis=INF,tt[i].id=i;
	tt[S].dis=0;
	q.push(tt[S]);
	dijkstra();
	for(int i=1;i<=N;i++)
	{
		printf("%d ",tt[i].dis);
	}
	return 0;
}
```


---

## 作者：渡_川 (赞：2)

...好尴尬啊

最近才知道优先队列这东西

上次在P3371 【模板】单源最短路径（弱化版）上被卡了之后才知道自己的dijkstra一直都没有优化。

优化似乎也不难，就是拿优先队列优化找最短的就好

### 神犇勿喷,这是初级的蒟蒻AC算法：

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.ArrayList;
import java.util.PriorityQueue;

public class Main {

	private static StreamTokenizer stk;
	private static int n;// 点数

	@SuppressWarnings("unchecked")
	public static void main(String[] args) {
		stk = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));// 优化输入
		n = getInt();
		int m = getInt();// 边数
		int start = getInt();// 起点
		ArrayList<Edge_4779>[] a = new ArrayList[n + 1];
		int[] results = new int[n + 1];
		for (int i = 1; i <= n; i++) {
			a[i] = new ArrayList<Edge_4779>();
			results[i] = 0x7fffffff;// 这里最开始全都是无穷大
		}
		while (m-- > 0) {
			int f = getInt();
			int g = getInt();
			int w = getInt();
			a[f].add(new Edge_4779(g, w));// 存图
		}

		Dijkstra(a, results, start);

		StringBuilder s = new StringBuilder();
		for (int i = 1; i <= n; i++) {
			s.append(results[i]);
			s.append(" ");
		}
		// 优化输出
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		out.println(s);
		out.flush();

	}

	// 使用优先队列进行优化的Dijkstra
	private static void Dijkstra(ArrayList<Edge_4779>[] a, int[] results, int start) {
		int count = 0;
		boolean[] bool = new boolean[n + 1];

		PriorityQueue<Edge_4779> pq = new PriorityQueue<Edge_4779>();// 优先队列
		pq.add(new Edge_4779(start, 0));

		while (pq.size() > 0 && count < n) {// 没有边了或者全部点都计算过了就结束
			Edge_4779 t = pq.poll();// 取出最小的
			int g = t.G;
			int w = t.W;
			if (!bool[g]) {// 判断是否遍历过
				bool[g] = true;
				count++;
				results[g] = w;
				for (Edge_4779 temp : a[g]) {// 遍历每条出边
					int tg = temp.G;
					int tw = temp.W;
					pq.add(new Edge_4779(tg, w + tw));// 入队
				}
			}
		}
	}

	private static int getInt() {
		try {
			stk.nextToken();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return (int) stk.nval;

	}
}

class Edge_4779 implements Comparable<Edge_4779> {
	int G, W;

	public Edge_4779(int g, int w) {
		G = g;// 目标点
		W = w;// 长度
	}

	@Override
	public int compareTo(Edge_4779 o) {
		return this.W - o.W;
	}

}
```


---

## 作者：Zechariah (赞：2)

听说单源最短路径数据加强，兴致勃勃的跑来写了一发dijkstra+优先队列优化，一开始重载括号运算符WA了一个点，后来听了神犇的话老老实实写结构体，于是AC了OwO

蒟蒻对dijkstra不是非常熟练，有错误可以立刻踢出！

------------------
话说今天数据又加强了，之前的代码dist初始化2147483647就AC了...

```cpp
#include <bits/stdc++.h>
#define N 200000+100
using namespace std;
int n, m, num, nt[N], p[N], q[N], b[N];
bool flag[N];
long long dist[N], w[N];
void add(int x, int y, long long z)
{
	b[++num] = y;
	w[num] = z;
	nt[num] = p[x];
	p[x] = num;
}
struct Node {
	int bh;
	long long dist;
	Node(int x, long long y)
	{
		bh = x;
		dist = y;
	}
	bool operator <(const Node &s)const
	{
		return s.dist<dist;
	}
};
void dijkstra(int st)
{
	for (int i = 1; i <= n; ++i)dist[i] = 2147483647;
	dist[st] = 0;
	priority_queue<Node>q;
	q.push(Node(st, 0));
	while (!q.empty())
	{
		Node k = q.top(); q.pop();
		if (!flag[k.bh])
		{
			flag[k.bh] = true;
			int e = p[k.bh];
			while (e)
			{
				int kk = b[e];
				if (dist[kk] - dist[k.bh]>w[e])
					dist[kk] = dist[k.bh] + w[e];
				q.push(Node(kk, dist[kk]));
				e = nt[e];
			}
		}
	}
}

int main()
{
	int st;
	scanf("%d%d%d", &n, &m, &st);
	for (int i = 1; i <= m; ++i)
	{
		int x, y;
		long long z;
		scanf("%d%d%lld", &x, &y, &z);
		add(x, y, z);
	}
	dijkstra(st);
	for (int i = 1; i <= n; ++i)
		printf("%lld ", dist[i]);
	return 0;
}
```

---

## 作者：psk011102 (赞：2)

这显然要用$Dijkstra$算法

$Dijkstra$算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：$T$，初始时，原点$s$的路径权重被赋为$0$ ,$(dis[s]=0)$。若对于顶点 $s $存在能直接到达的边$（s,m）$，则把$dis[m]$设为$w(s,m)$,同时把所有其他（$s$不能直接到达的）顶点的路径长度设为无穷大。初始时，集合$T$只有顶点$s$。

然后，从$dis$数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到$T$中，$OK$，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在$dis$中的值。

然后，又从$dis$中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

代码如下

```
#include <bits/stdc++.h>
#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)
#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)
#define Set(a, v) memset(a, v, sizeof(a))
#define file(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
using namespace std;

bool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}
bool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}

inline int read() {
 int x = 0, fh = 1; char ch = getchar();
    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;
    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');
    return x * fh;
}
int n,m,s;
int he[100005],to[200005],ne[200005],cost[200005],e;
int dis[100005];
void add(int x,int y,int z){
     to[++e]=y;
	 ne[e]=he[x];
	 he[x]=e;
	 cost[e]=z;
}
#define PII pair<int,int>
int flag[100005];
priority_queue<PII,vector<PII> ,greater<PII> >Q;
void spfa(){
    F(i,1,n)dis[i]=2107483647;
   dis[s]=0;
   Q.push(make_pair(dis[s],s));
   while(!Q.empty()){
    PII now=Q.top();
    Q.pop();
	 if(flag[now.second])continue;
    flag[now.second]=1;
    for(int i=he[now.second];i;i=ne[i]){
         int v=to[i];
        if(dis[now.second]+cost[i]<dis[v]){
            dis[v]=dis[now.second]+cost[i];
            if(!flag[v])
              Q.push(make_pair(dis[v],v));
        }
    }
   }
}
int main () {
#ifndef ONLINE_JUDGE
file("4779");
#endif
    n=read();
	m=read();
	s=read();
	F(i,1,m){
	   int x=read(),y=read(),z=read();
	   add(x,y,z);
	}
    spfa();
	F(i,1,n)printf("%d ",dis[i]);
    return 0;
}
```

最后再说一件事

~~关于~~$spfa$~~,它已经死了~~

---

## 作者：1010_ (赞：2)

dijk其实可以被很多优化，但好像在合理时限内，最快的是zkw线段树(本题可能不是,参考[此题](https://www.lydsy.com/JudgeOnline/problem.php?id=3040)数据范围)，所以特来此发表题解，分享一下
不会线段树的可以看楼下题解，想学zkw的可以参考本人博客[浅谈zkw之lazy标记](https://www.cnblogs.com/czx-1010/articles/9679412.html)和论文[《统计的力量》](https://wenku.baidu.com/view/0c1bbba40029bd64783e2cca.html)
```C++
#pragma GCC optimize(2)
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') ch=='-'&&(f=-1),ch=getchar();
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}//快速读入
const int N=1e6+10,M=1e7+10,inf=0x3f3f3f3f;
int n,m,tot;
int last[N],dis[N];
struct AC{int v,w,to;}e[M];
void add(int x,int y,int z){e[++tot]=(AC){y,z,last[x]};last[x]=tot;}//加边操作

int t[N<<2],num[N<<2],tn;
void first(){memset(t,0x3f,sizeof t);}
void build(){tn=1;while(tn<n)tn<<=1;--tn;for (int i=1;i<=n;++i)num[i+tn]=i;}
void change(int p,ll k)
{
	p+=tn;t[p]=k,p>>=1;
	while (p){
	if (t[p<<1]<t[p<<1|1]) t[p]=t[p<<1],num[p]=num[p<<1];
	else t[p]=t[p<<1|1],num[p]=num[p<<1|1];p>>=1;
	}
}
//上面为zkw线段树
int main()
{
	n=read(),m=read();int s=read();first();build();//first和build是给线段树赋初值
	for (int i=tot,x,y,z;i<m;++i)x=read(),y=read(),z=read(),add(x,y,z);
	{
		int x;
		memset(dis,0x3f,(n+1)<<2);dis[s]=0;change(s,0);
		while (t[1]!=inf)
		{
			x=num[1];change(x,inf);
			for (int i=last[x],v=e[i].v;i;i=e[i].to,v=e[i].v)
			if (dis[v]>dis[x]+e[i].w)
				dis[v]=dis[x]+e[i].w,change(v,dis[v]);
		}
	}//括号内为dijkstra
	for (int i=1;i<=n;++i)printf("%d ",dis[i]);
	return 0;
}
```

---

## 作者：autoint (赞：2)

不明原因TLE的看这里。
# 前言
之所以想给这题写题解呢，是因为之前发题解的说的都泛泛，其中$Dijkstra$的优化（我下面会讲）只有一个人提了一下，也没具体分析。然而10次实践经验不如1次理论总结。我分析了一下那优化，然后打出了我自认为等意义的代码，发现是对的，所以我想和大家分享一下那样优化的意义。

# 初始版本
```cpp
void Dijkstra()
{
    fill(d+1,d+n+1,1e9+7);
    d[s]=0;
    Q.push(P(-d[s],s));
    while(!Q.empty())
    {
        int x=Q.top().second; // 注意这里和下面的有什么不同
        Q.pop();
        for(int i=head[x];i;i=E[i].nx)
        {
            int y=E[i].to;
            if(d[x]+E[i].w<d[y])
            {
                d[y]=d[x]+E[i].w;
                Q.push(P(-d[y],y));// 解释一下为什么push(-d[y])，是因为我用的是STL的优先队列，而我想取每次最小的。
            }
        }
    }
}
```
这样我自信满满的交上去，RE了。我下载数据来看跑了6秒，是TLE了（落谷会判那些跑得过久的程序RE）。为什么呢?

# 优化版本
```cpp
int d[MAXN];
priority_queue<P>Q;
inline void Dijkstra()
{
    fill(d+1,d+n+1,1e9+7);
    d[s]=0;
    Q.push(P(-d[s],s));
    while(!Q.empty())
    {
        int x=Q.top().second,dis=-Q.top().first;
        Q.pop();
        if(dis>d[x]) continue; // 注意这里的变化
        for(rg int i=head[x];i;i=E[i].nx)
        {
            int y=E[i].to;
            if(d[x]+E[i].w<d[y])
            {
                d[y]=d[x]+E[i].w;
                Q.push(P(-d[y],y));
            }
        }
    }
}
```
加这个剪枝是不TLE的关键。
### 理论证明
1. 在访问一个点之前，他可能被多次拓展到，我们只希望拓展一次，即最小距离的那一次。

2. 而最小距离入的队应该是最先拓展的，所以非最小距离的拓展是在最小距离的拓展之后，且毫无意义的，白白多扫了一遍边，增加时间开销。尽管时间复杂度上界不变，但是会TLE。 

3. 怎么办？把那些非最小距离的剪掉就行了，这样才能保证O(nlogn)。

这样就从开O3都会TLE-> 普通就AC 

# 用实践证明
按我说的不难打出如下的等价代码
```cpp
inline void Dijkstra()
{
    fill(d+1,d+n+1,1e9+7);
    d[s]=0;
    Q.push(P(-d[s],s));
    while(!Q.empty())
    {
        int x=Q.top().second;
        Q.pop();
        if(vis[x]) continue; // 用dis判断->用vis判断
        vis[x]=1;
        for(rg int i=head[x];i;i=E[i].nx)
        {
            int y=E[i].to;
            if(d[x]+E[i].w<d[y])
            {
                d[y]=d[x]+E[i].w;
                Q.push(P(-d[y],y));
            }
        }
    }
}
```
这个也是AC了的代码，不会TLE。不过相比上面的写法而言要慢200ms，还多了$O(n)$空间，所以不推荐使用。

---

## 作者：Great_Influence (赞：2)

本文使用$dijkstra$算法。

该算法无法解决带负权边问题，所以如果遇到带有负权边的问题，请使用$BellmanFord$($SPFA$为其一个常见优化)以及其它算法。

首先，考虑以下贪心:

1.先将原点相连的点全部入队并更新距离。

2.将队内离原点距离最小的点取出并更新与其相连的所有点的距离。然后该点再也不会被访问。

因为图中没有负权边，所以该算法正确性显然。但是直接做是$O(n^2)$的。于是考虑优化第二步。那么，我们可以选择将点丢到以距离为权值的小根堆中维护。这样的复杂度为$O(n\log n)$。

这个算法的好处就是时间复杂度稳定，不会被卡。而$SPFA$可以通过构建三角网络图卡到$O(n^2)$。因此遇到不带负权的图最好改用$dijkstra$来计算距离(防止毒瘤出题人)。

因为堆中元素会改变，因此可以直接使用$pbds$内的待修改堆。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmax(a,b) a=a>b?a:b
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}

inline void write(int x)
{
    if(!x){putchar(48);putchar('\n');return;}
    static int sta[45],tp;
    for(tp=0;x;x/=10)sta[++tp]=x%10;
    for(;tp;putchar(sta[tp--]^48));
    putchar('\n');
}

using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
#endif
}

const int MAXN=1e5+7,MAXM=4e5+7;

static int n,m;

static struct edg
{
    int u,v,w,h;
    friend bool operator<(edg a,edg b){return a.h>b.h;}
}EDG[MAXM];

static struct edge
{
    int v,w,nxt;
}P[MAXM<<1];

static int head[MAXN],e;

inline void add(int u,int v,int w)
{P[++e]=(edge){v,w,head[u]};head[u]=e;}

__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> > >G;

__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> > >::point_iterator its[MAXN];

static int dis[MAXN];

const int INF=2e9+7;

inline void dijkst(int s)
{
    G.clear();
    its[s]=G.push(make_pair(0,s));dis[s]=0;
    Rep(i,2,n)dis[i]=INF,its[i]=G.push(make_pair(INF,i));
    static int u;
    while(!G.empty())
    {
        u=G.top().second;G.pop();
        for(register int v=head[u];v;v=P[v].nxt)
            if(dis[P[v].v]>dis[u]+P[v].w)
            {
                dis[P[v].v]=dis[u]+P[v].w;
                G.modify(its[P[v].v],make_pair(dis[u]+P[v].w,P[v].v));
            }
    }
}

static int s;

inline void init()
{
    read(n);read(m);read(s);
	static int u,v,w;
    Rep(i,1,m)read(u),read(v),read(w),add(u,v,w);
}

inline void solve()
{
    dijkst(s);
	Rep(i,1,n)printf("%d ",dis[i]);
	puts("");

}

int main()
{
    file();
    init();
    solve();
	cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}
```

---

## 作者：xukuan (赞：2)

lyd的《算法竞赛进阶指南》还是一本不错的书

在此仅做代码搬运

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<map>
#include<queue>
#define ll long long
using namespace std;

ll head[10010],ver[500010],edge[500010],Next[500010],d[500010];
bool v[10010];
ll n,m,tot,s;
priority_queue<pair<ll,ll> >q;

inline ll read(){
    ll tmp=1,x=0;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
   
    while(isdigit(ch)){
        x=x*10+ch-48;
        ch=getchar();
    }
    return tmp*x;
}

inline void addEdge(ll x,ll y,ll z){
    ver[++tot]=y;
    edge[tot]=z;
    Next[tot]=head[x];
    head[x]=tot;
}

void dijkstra(){
    for(ll i=1; i<=500005; i++)d[i]=2147483647;
    //memset(d,0x3f3f3f3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[s]=0;
    q.push(make_pair(0,s));
    while(q.size()){
        ll x=q.top().second; q.pop();
        if(v[x]) continue;
        v[x]=1;
        for(ll i=head[x]; i; i=Next[i]){
            ll y=ver[i],z=edge[i];
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                q.push(make_pair(-d[y],y));
            }
        }
    }
}

int main(){
    n=read(); m=read(); s=read();
    for(ll i=1; i<=m; i++){
        ll x=read(),y=read(),z=read();
        addEdge(x,y,z);
    }
    dijkstra();
    for(ll i=1; i<=n; i++){
        printf("%lld ",d[i]);
    }
}
```

---

## 作者：蒟蒻初音ミク (赞：1)

其实我不喜欢跑dijkstra的。。。但是本题要卡SPFA，所以。。。


身为一个蒟蒻的我自然不想在各位大佬面前作死，但是我想纪念一下，因为这是我第一次使用——

# 指针邻接表！！！

下面就是代码了

~~（码风大家不喜欢的话，私信本蒟蒻，本蒟蒻一定会改哦！）~~

## code
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define N 100000
using namespace std;
struct ed{
	int to,w;
	ed *next;
}*edge,*head[N+10];
int n,m,dis[N+10],s;
inline void add(int u,int v,int w)
{
	edge=new ed;//申请动态内存
	edge->next=head[u];
	edge->to=v;
	edge->w=w;
	head[u]=edge;
}
struct node{
	int w,id;
	bool friend operator < (node a,node b)
	{
		return a.w>b.w;//小跟堆
	}
};
priority_queue<node>q;
bool vis[N+10];
void dijkstra()
{
	for(register int i=1;i<=n;++i)dis[i]=0x7f7f7f7f;
	memset(vis,0,sizeof(vis));
	while(!q.empty())q.pop();
	node n1;
	n1.id=s;n1.w=0;dis[s]=0;q.push(n1);
	while(!q.empty())
	{
		n1=q.top();q.pop();
		int u=n1.id;
		if(vis[u])continue;
		vis[u]=1;
		for(register ed *i=head[u];i;i=i->next)
		{
			int v=i->to;
			if(dis[v]>dis[u]+i->w)
			{
				dis[v]=dis[u]+i->w;
				n1.id=v;n1.w=dis[v];q.push(n1);
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&s);
	int a,b,c;
	for(int i=1;i<=m;++i)
	{
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	dijkstra();
	for(register int i=1;i<=n;++i)printf("%d ",dis[i]);
	return 0;
}
```

---

## 作者：二哥啃菜包 (赞：1)

莫名感觉我被坑了。。。。。嘤嘤嘤！

这题在p3371用spfa死得好惨，T掉了三个点。

绝望之下来次此作死。

**结果居然过了！！！**

看来稠密图是不一样。但不建议在不同比赛中写这个。

关于spfa，

他死了。。。
于是可爱的Dij开始以独立的姿态登上政治舞台。

然而今天spfa翻身了！

通过一样的优化spfa再次推翻Dij伪政权。

具体实现很好理解，现将小根堆重载为大根堆在专门写一个结构体。

最后STL优先队列的取顶操作要用q.top();

然后就可以愉快的spfa了！我用了前向星存图，vecter不会用各位大佬见谅；
好吧好吧！上代码！
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
long long n,m,s;
#define N 100005
#define M 200005
#define ll long long
ll head[N],vis[N],dis[N];
ll En=0;
struct edge{
	ll next,to,dis;
}E[M];
void E_add(ll from,ll to,ll dis){
	En++;
	E[En].next=head[from];
	E[En].to=to;
	E[En].dis=dis;
	head[from]=En;
}//前向星就不用详说了；
struct node{
	ll u,v;
	bool operator < (const node &nt) const {
		return v>nt.v;
	}
};//防止可爱的堆出错
void clear(){
	for(int i=1;i<=n;++i)dis[i]=2147483647,vis[i]=0;
}
void spfa(ll s){
	clear();
	priority_queue<node> q;
	dis[s]=0;vis[s]=1;q.push((node){s,dis[s]});
	while(!q.empty()){
		node tmp=q.top();q.pop();vis[tmp.u]=0;//太可怕了，我pop没写查了三十分钟。。。
		for(int i=head[tmp.u];i;i=E[i].next){
			ll v=E[i].to;
			if(dis[v]>dis[tmp.u]+E[i].dis){
				dis[v]=dis[tmp.u]+E[i].dis;
				if(vis[v]==0){
					q.push((node){v,dis[v]});
					vis[v]=1;
				}
			}
		}
	}
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&s);
	for(int i=1;i<=m;++i){
		ll u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		E_add(u,v,w);
	}
	spfa(s);
	for(int i=1;i<=n;++i)printf("%lld ",dis[i]);
}
```
要说的大概就这些了，祝大家while(1)rp++;

---

## 作者：zhylj (赞：1)

如果你需要完整代码和更好的阅读体验，可以前往我的博客：[https://www.cnblogs.com/zhylj/p/9492055.html](https://www.cnblogs.com/zhylj/p/9492055.html)

线段树优化$\rm dijkstra$

线段树每个节点维护$[l,r]$中$dist$最小的点，删除则把该点$dist$赋值为$+\infty$，然后更新该点影响到的线段树上的其他节点即可。

可以得到“更新该节点影响到的线段树上的其他节点”部分的代码：
（线段树数组$\rm st[]$）

```
void pushup(int x) {
    st[x] = dist[st[x << 1]] < dist[st[x << 1 | 1]] ? st[x << 1] : st[x << 1 | 1];
}

void updata(int x, int l, int r, int q) {  //更新信息
    if(l != r) {
        int mid = (l + r) >> 1;
        if(q <= mid) updata(x << 1, l, mid, q);
        else updata(x << 1 | 1, mid + 1, r, q);
        pushup(x);
    }
}
```

然后$\rm dijkstra$代码如下：

```
//此处ans为最终数组
void dijkstra(int s) {
    ans[s] = dist[s] = 0;
    build(1, 1, n);  //建树
    while(dist[st[1]] < inf) {
        int v = st[1]; vis[v] = 1; //取出最小的
        for(int i = head[v]; i != -1; i = edges[i].nxt) if(!vis[edges[i].to]) { //更新相邻节点
            dist[edges[i].to] = min(dist[edges[i].to], dist[v] + edges[i].val);//修改dist
            updata(1, 1, n, edges[i].to);//更新所影响的节点
        }
        ans[v] = dist[v]; dist[v] = inf;//记录答案，删除节点
        updata(1, 1, n, v);  //更新所影响的节点
    }
}
```

---

## 作者：zhy12138 (赞：1)

看到这道题时，蒟蒻的我开心极了。
因为我不会SPFA只会dikjstra
（~~但我的同学用STL堆优化貌似T了~~）没事，我用的是手打。
堆优化没什么好说的，直接贴代码吧，由于是手打，码量较为适中~~NOI2018的梗~~
tree就是堆，num是记每一个点在堆中的位置，用于维护堆。
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<ctime>
using namespace std;
int n,m,t,head[100001],dis[100001],maxn=2147483647,tree[100001],tot=0,num[100001];
bool pd[100001];
struct sb
{
    int next;
    int to;
    int l;
}a[200001];
int put(int k)
{
    tot++;
    tree[tot]=k;
    num[k]=tot;
    int bj=tot,xia;
    while(bj!=1)
    {
        xia=bj/2;
        if(dis[tree[xia]]<=dis[tree[bj]])
            return 0;
        num[tree[xia]]=bj;
        num[tree[bj]]=xia;
        int change=tree[xia];
        tree[xia]=tree[bj];
        tree[bj]=change;
        bj=xia;
    }
}
int bian(int zone)
{
    int bj=zone,xia;
    while(bj!=1)
    {
        xia=bj/2;
        if(dis[tree[xia]]<=dis[tree[bj]])
            return 0;
        num[tree[xia]]=bj;
        num[tree[bj]]=xia;
        int change=tree[xia];
        tree[xia]=tree[bj];
        tree[bj]=change;
        bj=xia;
    }
}
int get()
{
    tree[1]=tree[tot];
    num[tree[tot]]=1;
    tot--;
    int bj=1,xia;
    while(bj*2<=tot)
    {
        xia=bj*2;
        if(dis[tree[xia+1]]<dis[tree[xia]] && xia+1<=tot)
            xia++;
        if(dis[tree[xia]]>=dis[tree[bj]])
            return 0;
        num[tree[xia]]=bj;
        num[tree[bj]]=xia;
        int change=tree[xia];
        tree[xia]=tree[bj];
        tree[bj]=change;
        bj=xia;
    }
}
int main()
{
    cin>>n>>m>>t;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        a[i].to=y;
        a[i].l=z;
        a[i].next=head[x];
        head[x]=i;
    }
    for(int i=1;i<=n;i++)
    	dis[i]=maxn;
    dis[t]=0;
    put(t);
    for(int i=1;i<=n;i++)
    {
        int bj=tree[1];
        num[bj]=0;
        pd[bj]=1;
        get();
        for(int j=head[bj];j!=0;j=a[j].next)
            if(pd[a[j].to]==0 && dis[a[j].to]>dis[bj]+a[j].l)
            {
                dis[a[j].to]=dis[bj]+a[j].l;
                if(num[a[j].to]==0)
                    put(a[j].to);
                else
                    bian(num[a[j].to]);
            }
    }
    for(int i=1;i<=n;i++)
        cout<<dis[i]<<" ";
    cout<<endl;
    return 0;
}
```

---

## 作者：King_Han (赞：1)

嗯 邪恶的出题人似乎是对spfa有什么偏见。作为一个偏爱spfa的蒟蒻，我还是选择spfa先a掉P3371。

不多说，用spfa只能过后面两个点40分。~~别问我怎么知道的~~，
这种邪恶的数据要用优先队列+pair优化的dijkstra（~~题解里的dalao这题居然还能用平板电视库，蒟蒻一点也不会~~），dis数组不开longlong最后一点也会爆，~~这个也别问我怎么知道的~~，小细节改完之后就是完美的O（nlogn）的dij。

不过还是有dalao用平衡树上跑spfa+*……&&%￥#%……*（我也不知道是什么鬼优化）过了，蒟蒻还是一点也不会。。。

```
#include<bits/stdc++.h>
#define inf 999999999//我就是喜欢999999999
using namespace std;
int vis[100005],head[100005],n,m,s,tot;
long long dis[100005];
typedef pair<long long,int> pa;
priority_queue<pa,vector<pa>,greater<pa> >q;
struct Edge{
	int nxt;
	int to;
	long long dis;
}edge[200005];
void dij()
{
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++)
		dis[i]=inf; 
	dis[s]=0;
	q.push(make_pair(0,s));
	while (!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if (vis[u]) 
			continue;
		vis[u]=1;   	
		for (int p=head[u];p;p=edge[p].nxt)
		{
			int v=edge[p].to;
			if (dis[v]>dis[u]+edge[p].dis)
			{
				dis[v]=dis[u]+edge[p].dis; 
	  			q.push(make_pair(dis[v],v)); 
		  	}
		}
	} 
}
void add_(int from,int to,long long dis)
{
	edge[++tot].nxt=head[from];
	edge[tot].to=to;
	edge[tot].dis=dis;
	head[from]=tot;
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		int f,t,d;
		scanf("%d%d%d",&f,&t,&d);
		add_(f,t,d);
	}
	dij();
	for(int i=1;i<=n;i++)
	{
		printf("%d ",dis[i]);//完美
	}
	return 0;//再见dij :)
}
```

---

## 作者：Drinkkk (赞：1)

## $\text{Description}$

给定一个 $N$ 个点，$M$ 条有向边的带非负权图，请你计算从 $S$ 出发，到每个点的距离。

数据保证你能从 $S$ 出发到任意点。


$u_i,v_i$ 表示第 $i$ 条有向边的起点和终点，$w_i$ 表示第 $i$ 条边的边权。

$1 \leq u_i, v_i \leq N \leq 100000,$

$1 \leq M \leq 200000,S = 1,$

$0 \leq w_i,\sum w_i \leq 10 ^ 9$ 。

## $\text{Solution}$

这道题目会把最坏复杂度为 $O(nm)$ 的 SPFA 卡掉，这时候我们就需要用到 Dijkstra 了。

Dijkstra 的流程就是每次在未确定最短路的点中找一个 $dis$ 值最小的点，然后用它来更新别的点，然后把这个点标为已确定最短路。直到所有点都确定了最短路为止。

$$dis_i\;\text{表示的是从}\;S\;\text{到}\;i\;\text{的最短路的长度}$$

如果在每次做完后我们暴力找 $dis$ 值最小的点，这个的复杂度是 $O(n^2)$ 的。那么我们怎么优化它呢？我们可以用堆来维护它，这样我们就可以把这一部分的时间复杂度给降到 $O(n\;\log\;n)$ 了。

这里的堆我是手写的，码量较大。

我的 Dijkstra 可能思路有些奇怪，但还是 Dijkstra 。

其实这道题目不单止可以用堆维护，还可以用线段树等维护的，有兴趣的可以自己尝试一下。

## $\text{Code}$

```
#include <cstdio>
#define inf 2147483647/2
struct node{ int x,y,c,g; } a[1000001];
int heap[1000001][2],bj[1000001],h[1000001];
int ans[1000001];
int len=0,n=0,m=0,st=0;
void ins(int x,int y,int c)
{
    len++;
    a[len].x=x;
    a[len].y=y;
    a[len].c=c;
    a[len].g=h[x];
    h[x]=len;
}
void pushup(int x)
{
    int fa=x/2;
    if(fa==0)
    {
        return ;
    }
    if(heap[x][0]<heap[fa][0])
    {
    	int t=bj[heap[x][1]];
    	bj[heap[x][1]]=bj[heap[fa][1]];
    	bj[heap[fa][1]]=t;
    	
	    t=heap[fa][0];
        heap[fa][0]=heap[x][0];
        heap[x][0]=t;
        
        t=heap[fa][1];
        heap[fa][1]=heap[x][1];
        heap[x][1]=t;
        
        pushup(fa);
    }
}
void pushdown(int x)
{
    if(x*2>n)
    {
        return ;
    }
    int lson=x*2;
    int rson=x*2+1;
    int disl=heap[lson][0];
    int disr=heap[rson][0];
    int disx=heap[x][0];
    if(lson>n)
    {
        disl=inf+1;
    }
    if(rson>n)
    {
        disr=inf+1;
    }
    if(disx>disl && disx>disr)
    {
        if(disl<disr)
        {
            int t=bj[heap[x][1]];
            bj[heap[x][1]]=bj[heap[lson][1]];
            bj[heap[lson][1]]=t;
            
			t=heap[x][0];
            heap[x][0]=heap[lson][0];
            heap[lson][0]=t;
            
            t=heap[x][1];
            heap[x][1]=heap[lson][1];
            heap[lson][1]=t;
            
            pushdown(lson);
        }
        else
        {
        	int t=bj[heap[x][1]];
            bj[heap[x][1]]=bj[heap[rson][1]];
            bj[heap[rson][1]]=t;
            
            t=heap[x][0];
            heap[x][0]=heap[rson][0];
            heap[rson][0]=t;
            
            t=heap[x][1];
            heap[x][1]=heap[rson][1];
            heap[rson][1]=t;            
            
            pushdown(rson);
        }
    }
    else if(disx>disl)
    {
    	int t=bj[heap[x][1]];
        bj[heap[x][1]]=bj[heap[lson][1]];
        bj[heap[lson][1]]=t;
        
        t=heap[x][0];
        heap[x][0]=heap[lson][0];
        heap[lson][0]=t;
        
        t=heap[x][1];
        heap[x][1]=heap[lson][1];
        heap[lson][1]=t;
        
        pushdown(lson);
    }
    else if(disx>disr)
    {
    	int t=bj[heap[x][1]];
        bj[heap[x][1]]=bj[heap[rson][1]];
        bj[heap[rson][1]]=t;
        
        t=heap[x][0];
        heap[x][0]=heap[rson][0];
        heap[rson][0]=t;
        
        t=heap[x][1];
        heap[x][1]=heap[rson][1];
        heap[rson][1]=t;
        
        pushdown(rson);	
    }
}
void Dijkstra()
{
    int len=n;
    heap[st][0]=0;
    pushup(st);
    while(len!=0)
    {
        int x=heap[1][1];
        ans[x]=heap[1][0];
//  		printf("x=%d\n",x);
//  		for(int i=1;i<=n;i++)
//  		{
//  			printf("%d ",bj[i]);
//  		}
//  		printf("\n");
//  		printf("Ans:");
//  		for(int i=1;i<=n;i++)
//  		{
//  			printf("%d ",ans[i]);
// 		}
// 		printf("\n"); 
// 		printf("--------------sta------------\n");
//  		for(int i=1;i<=n;i++)
//  		{
//  			printf("%d %d\n",heap[i][0],heap[i][1]);
//  		}
        for(int i=h[x];i>0;i=a[i].g)
        {
            int y=a[i].y;
            if(heap[bj[y]][0]>inf)
            {
                continue;
            }
 			// printf("x=%d,y=%d\n",x,y);
 			// printf("%d,%d,%d,%d\n",ans[x],a[i].c,heap[bj[y]][0],bj[y]);
            if(ans[x]+a[i].c<heap[bj[y]][0])
            {
                heap[bj[y]][0]=ans[x]+a[i].c;
                pushup(bj[y]);
            }
        }
//  		printf("--------------bef------------\n");
//  		for(int i=1;i<=n;i++)
//  		{
//  			printf("%d %d\n",heap[i][0],heap[i][1]);
//  		}
        len--;
        heap[1][0]=inf+1;
        pushdown(1);
//  		printf("-------------aft-------------\n");
//  		for(int i=1;i<=n;i++)
//  		{
//  			printf("%d %d\n",heap[i][0],heap[i][1]);
//  		}
    }
}
int main()
{
    scanf("%d %d %d",&n,&m,&st);
    for(int i=1;i<=n;i++)
    {
        bj[i]=i;
        heap[i][0]=inf-1;
        heap[i][1]=i;
    }
    for(int i=1;i<=m;i++)
    {
        int x=0,y=0,c=0;
        scanf("%d %d %d",&x,&y,&c);
        ins(x,y,c);
    }
    Dijkstra();
    for(int i=1;i<=n;i++)
    {
        printf("%d ",ans[i]);
    }
    return 0;
}
```

---

## 作者：wxy2005 (赞：1)

# 本蒟蒻又来发布题解了
### 众所周知，这是一道用迪杰斯特拉算法做的题，至于迪杰斯特拉是啥，前面已经有巨佬解释过了。
### 大家都知道，一般的迪杰斯特拉算法是O(n^2)的，但是对于这道题的数据来说，这未免有些高，观察一下数据范围，只有nlogn及一下级别算法才能通过此题。
### 反过来再想一下迪杰斯特拉，每次都是取出来最小的那一条边。
# 等等！最小的！
### 这可以立刻联想带堆，确切的说是小根堆。
## 既然思路有了，就看代码实现了。
#### 首先是读入，这很简单，利用边链表读入。
### 边链表是一个很常用的东西，大家要理解边链表的含义，实在理解不了的就硬背。
```cpp
void add(int x,int y,int z)
{
	ne[++cnt]=no[x];
	no[x]=cnt;
	la[cnt]=y;
	val[cnt]=z;
	return ;
}
```
#### 边链表创建程序完成，接着是整个读入过程
```cpp
for(int i=1;i<=m;i++)
{
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	add(x,y,z);
}
```
## 然后是堆，堆是什么我就不再这里介绍了，详情请看第[P3378](https://www.luogu.org/problemnew/show/P3378)
```cpp
	for(N=1;N<=m;N<<=1);
	for(int i=1;i<=N*2;i++)
		a[i]=MAX;
```
### 这是堆的初始化，接下来是见到一个点就把他的插进堆里，插进堆里的函数如下（也是堆的插入，看第p3378题）
```cpp
void ins(int i,int x)
{
	a[N+i]=x;
	num[N+i]=i;
	for(int j=(N+i)>>1;j>=1;j>>=1)
	{
		a[j]=min(a[j<<1],a[j<<1|1]);
		num[j]=(a[j<<1]<a[j<<1|1])?num[j<<1]:num[j<<1|1];
	}
	return;
}
```
### 其中i和x代表将x插入堆的第i个位置，num是每一个节点的那棵树中的最小值。
### 这仅仅是插入过程，要想寻找到该插那个点还需要一个for循环
```cpp
void update(int x)
{
	for(int i=no[x];i!=0;i=ne[i])
	{
		if(check[la[i]]!=0)
		continue;
		dis[la[i]]=min(val[i]+dis[x],dis[la[i]]);
		ins(la[i],dis[la[i]]);
	}
	ins(x,MAX);
	check[x]=1;
	return;
}
```
# check是看这个点有没有来过，不然可能会陷入死循环！
## 这里有一个比较偷懒的写法，那就是将出发点的距离赋成0，这样第一个找到的就是出发点了。
```cpp
	dis[s]=0;
	ins(s,0);
```
### 最后是不断更新（只需要n次）
```cpp
	for(int i=1;i<=n;i++)
	{
		update(num[1]);	
	}
```
## 全部代码：
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<stdlib.h>
#include<algorithm>
#include<cstring>
#include<vector> //一坨头文件，不用细看
#define MAXN 800005
#define MAX 2147483647//int 的边界值
using namespace std;
int ne[MAXN],la[MAXN],no[MAXN],cnt=0,val[MAXN],dis[MAXN],N=1,check[MAXN];
int a[2*MAXN],num[2*MAXN];
void add(int x,int y,int z)//边链表
{
	ne[++cnt]=no[x];
	no[x]=cnt;
	la[cnt]=y;
	val[cnt]=z;
	return ;
}
void ins(int i,int x)//插入
{
	a[N+i]=x;
	num[N+i]=i;
	for(int j=(N+i)>>1;j>=1;j>>=1)
	{
		a[j]=min(a[j<<1],a[j<<1|1]);
		num[j]=(a[j<<1]<a[j<<1|1])?num[j<<1]:num[j<<1|1];
	}
	return;
}
void update(int x)//更新
{
	for(int i=no[x];i!=0;i=ne[i])
	{
		if(check[la[i]]!=0)
		continue;
		dis[la[i]]=min(val[i]+dis[x],dis[la[i]]);
		ins(la[i],dis[la[i]]);
	}
	ins(x,MAX);
	check[x]=1;
	return;
}
int m,n,s;
int main()
{
	//freopen("dijiesitela.in","r",stdin);
	//freopen(".out","w",stdout);
	for(int i=0;i<MAXN;i++)
		dis[i]=MAX;
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	for(N=1;N<=m;N<<=1);
	for(int i=1;i<=N*2;i++)
		a[i]=MAX;
	dis[s]=0;
	ins(s,0);
	for(int i=1;i<=n;i++)
	{
		update(num[1]);	
	}
	for(int i=1;i<=n;i++)
		printf("%d ",dis[i]);
    return 0;
}
```
# 结束！
## 希望管理员大大放过 

---

## 作者：Sakura_Peng (赞：0)

虽然好多人发了，但是我还是想发一下，我是蒟蒻=-=

一道模板最短路题蓝色难度着实令人害怕，因为这道题要用邻接表+堆优化的dijsktra才能过

我也专门学习了一下堆优化的dijsktra。

在dijsktra的朴素算法中，我们要先循环每个点先找出最小的点再把与找出的这个点相连的点的最短路更新一下，这样的话我们加入了太多的冗余判断了，而堆优化就省去了**循环每个点先找出最小的点** 这个过程。

我们可以设置一个小根堆，堆中每个节点放置当前dis[i]和i，使得每次的根节点就是最小值，我们就可以直接把这个根节点直接取出，直接更新与这个点i相连的点最短路了。

~~（但是我懒~~ 

所以我选择使用优先队列这个算法，但优先队列我们在使用时，需要注意我们优先队列里每个队列空间里需要放两个值：dis[i]和i，所以这里要学习一种新的设置优先队列一个队列空间可以存放多个值的语法

我们可以把它想象成还是一个结构体类型

这里要首先要学习：**重载运算符**

对于网站博客上的重载运算符的定义实在是太深奥看不懂，我也是通过yj大佬的耐心回答下理解了这个玩意是干啥的，也就是字面的意思

我们可以重新定义一个原本存在的运算符新的运算形式

例如加号“+”

本来+号两边只能加两个相同类型的，但是我们可以自己重新定义
比如 定义成 long long + double

这样就定义了一个新的形式 

一开始我有个问题，就是觉得这个运算符你定义新的运算形式之后，那计算机会怎么样去执行你的运算符到底是他原本编译器所定义的运算符运算形式还是你自己新定义的呢？

**嗯，计算机会自己帮你判断的~**

看一下这里使用优先队列的定义
````cpp
    struct node
    {
    	int dis;
    	int pos;  //dis存储这个点的最短路，pos存的是这个点的下标
    	bool operator <(const node &x)const
    	{
    		return x.dis < dis;  //利用重载运算符
    		}
    };
    priority_queue <node> q;
````
那么这里的重载运算符是什么意思呢？

我们可以这样理解，在原本的优先队列内部操作里，就是使用"<"来定义大根堆小根堆，但是在原本优先队列中仅仅指的在每个队列空间只有一个元素时一个元素和另外一个元素的比较。那么这里我们使用了重载运算符，就是将这个优先队列内部操作里面的原本那样的操作变成现在每个队列空间里面有两个元素的时候根据其中一个元素的大小决定优先队列里顺序判断。

这里的操作有点类似于sort函数的写cmp函数为结构体排序的思想吧！

这里就是优先队列的定义问题，那么还有在每次的存储问题，这时候我们已经有了不止一个元素需要存储在一个空间里，所以存储时也需要有新的语法格式：（设当前这个点为s，dis[s]=0）
````cpp
q.push(( node ) {dis[s],s});
````
注意！我们这里利用大括号中间的数必须按照定义时的顺序存储，如果反过来{s,dis[s]}那么这个时候计算机就会认为s是这个点的最短路长度，dis[s]是这个点的下标了。

在进行堆优化的dijsktra中，我们也需要进行改变，在一开始我们直接取出队头元素，判断这个元素是否已经在之前找到过标记过，如果没有则根据邻接表直接更新与其相连的点的最短路的值，并且把与其相连的点全部都放入队列中，这样就可以直接做到朴素算法中原本循环每个点进行找当前最小dis值的过程了。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <queue>
using namespace std;
int b[200001],n,m,s,top,dis[200001],h[200001];
struct CZP
{
	int next,to,di;
}a[200001]; 
struct node
{
	int dis;
	int pos;
	bool operator <(const node &x)const
	{
		return x.dis < dis;
		}
}; //定义新的优先队列
void cun(int from,int to,int dis)
{
	a[++top].next=h[from];
	a[top].to=to;
	a[top].di=dis;
	h[from]=top;
}  //邻接表
priority_queue <node> q;
int main()
{
	scanf("%d%d%d",&n,&m,&s);
	for (int i=1;i<=n;i++)
	h[i]=-1;
	for (int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		cun(x,y,z);
	}
	for (int i=1;i<=n;i++)
	dis[i]=1e9;  //这里不需要把dis[i]的值定义成起点到i点的路径长度，直接最大值即可（但是应该定义成路径长度没啥太大问题）
	dis[s]=0;
	q.push(( node ) {0,s});  //先把起点放入队列中
	while (!q.empty())
	{
		node x=q.top();
		q.pop();
		int k=x.pos;
		if (b[k]==1)
		continue;  //巧妙过程，省去了while语句，如果这个点已经被标记过了，那么就不会执行下面的语句继续执行上方三行语句直到找到没有标记过的
		b[k]=1;
int v=h[k];
		while (v!=-1)
		{
			if (dis[a[v].to]>dis[k]+a[v].di)
			{
				dis[a[v].to]=dis[k]+a[v].di;  //更新与这个点相连的点的dis最短路
				if (!b[a[v].to])
				q.push( ( node ) { dis[a[v].to],a[v].to} );  //并且加入队列，必须每次更新完都加一次，因为dis值在改变，可能在更新之前在优先队列中排名不在前面，但是更新之后优先队列排在第一位了
			}
			v=a[v].next;
		}
	}
	for (int i=1;i<=n;i++)
	printf("%d ",dis[i]);
	return 0;
}
```

还是有很多细节需要注意的，我在复习这道题目的时候，打的几乎完全一样，但是就是满不了分，百思不得其解的时候，发现打入队列那几行语句跟第一次打的空格少了几个，我就把小括号中括号任何间隙都加了空格=-=然后就过了awa

可能有很多是我自己理所当然了解的想法不太对，但是我觉得在当下，这种想法也还是可以支撑我能够知道堆优化的dijsktra每行啥意思吧=-

---

## 作者：SunRichard (赞：0)

思路 前向星存图

堆优化的djk

代码有注释哩~~



```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>

const int MaxN = 100010, MaxM = 500010;

struct Edge
{
    int to, val, next;
}Edge[MaxM]; // 链式前向星 
int head[MaxN], dis[MaxN], num=0;
bool vis[MaxN];
int n, m, s;

inline void add_Edge( int u, int v, int d ) //加边操作 
{
    ++num;
    Edge[num].val = d; //赋权 
    Edge[num].to = v; // 这条边终点 
    Edge[num].next = head[u]; //下一条边的下标 
    head[u] = num;//设置第一条边为当前边 
}

struct node 
{
	int val; //距离 
	int pos; //点的位置
	node(){}
	node(int p , int v)
	{
		pos=p;
		val=v;
	}
	
	bool operator < (const node &a)const
	{
		return val > a.val;
	} 
	//重载"<" 
	
} ;//结构体 结点

inline void dijkstra(int start)
{
	std::priority_queue<node>que;
/*for(int i = 1 ; i<=n ; ++i)
	{
		dis[i]=0x3f;
		vis[i]=false;
	}*/
	dis[start]=0;
	que.push( node(start,0) );
	
	while(!que.empty())
	{
		node temp=que.top(); //优先队列首元素就是dist数组最小值
		que.pop();
		int mini=temp.pos; //最小值为首元素节点
		if(vis[mini])
			continue;
		 
		 
		 
		 	vis[mini]=true;
	
		 //判断最小值是否被找过，如果找过则跳过继续。 
		 
		 for(int i=head[mini] ; i ; i=Edge[i].next)//首尾相连更新距离 
		 {
		 	int to=Edge[i].to;
		 	if(dis[to]>dis[mini]+Edge[i].val)
		 	{
		 		dis[to]=dis[mini]+Edge[i].val;
		 		if(!vis[to])
		 		{
		 			que.push(node(to,dis[to]));
				 }
			
				 
			 }
		 }
	 } 
} 
int main()
{
	
	 scanf( "%d%d%d", &n, &m, &s );
    for(int i = 1; i <= n; ++i)dis[i] = 0x7fffffff;
    for( register int i = 0; i < m; ++i )
    {
        register int u, v, d;
        scanf( "%d%d%d", &u, &v, &d );
        add_Edge( u, v, d );
    }
    dijkstra(1);
    for( int i = 1; i <= n; i++ )
        printf( "%d ", dis[i] );
    return 0;
}

 

```



---

## 作者：菜鸟至尊 (赞：0)

邻接链表存图的似乎不多了                            
所以就写了动态分配内存的邻接链表                                      
也比较容易打  

每次找到最近的点的时候

把这个点的连边的点加进小根堆里面

邻接链表的话就指针l=l->Next迭代就行了

注意结构体的.next和->next的区别哦                
前一个是实在的变量的成员               
后一个是指针指向的变量的成员

这个堆不只要放入dis值            
下标也要放进去
毕竟你要知道你想更新的dis是哪一个                        
所以堆用结构体很好操作 并且在结构体交换的时候swap就是神器了

最后记得加上优化if(sign[disd[1].s]){pop();}
走过的点要弹掉

so        
堆加速的dijkstra跑的挺快的

测得跑了264ms  代码应该还是简单易懂的
```cpp
#include<bits/stdc++.h>
using namespace std;
struct note{int end,w;
	struct note *next;
};struct note edge[100001];//下标代表起点
long long dis[100001];bool sign[100001];int n,m,s,a,b,c;
struct opp{
	int dis;int s;
};struct opp disd[100001];int end=0;
void pushin(int data,int sp){register int s=++end;//小根堆插入
disd[s].dis=data;disd[s].s=sp;
        while(s>0){
        if(disd[s].dis<disd[s>>1].dis){swap(disd[s],disd[s/2]); s=s>>1;}
        else{break;}}
}
void pop(){swap(disd[end],disd[1]);end--;//小根堆弹出
    for(int i=1,j=2;j<=end;i=j,j=i<<1){
    if(j+1<=end&&disd[j].dis>disd[j+1].dis){j++;}
    if(disd[i].dis>disd[j].dis){swap(disd[i],disd[j]);}
    else{break;}
	}
}
inline int read(){int s=0,w=1;char ch=getchar();//快读
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();return s*w;
}
void dj(int x){if(x==-1){return;}sign[x]=1;
	for(struct note *l=edge[x].next;l!=NULL;l=l->next){
	if(dis[x]+l->w<dis[l->end]){dis[l->end]=dis[x]+l->w;pushin(dis[l->end],l->end);};}
	int sp=-1,mind=2147483647;
	while(end>0){
	if(sign[disd[1].s]){pop();}
	if(!sign[disd[1].s]){sp=disd[1].s;dj(sp);break;}
	}
}
int main(){cin>>n>>m>>s;//预处理我放在了主函数里
    for(register int i=1;i<=n;i++)
    edge[i].next=NULL;
	for(register int i=1;i<=m;i++){a=read();b=read();c=read();
	struct note *l=(note *)malloc(sizeof(note));l->end=b;l->w=c;
	l->next=edge[a].next;edge[a].next=l;}
	for(register int i=1;i<=n;i++){dis[i]=2147483647;}dis[s]=0;
	dj(s);
	for(register int i=1;i<=n;i++){cout<<dis[i]<<" ";}
	return 0;
}
```
end~~~~

---

## 作者：FifthAxiom (赞：0)

首先，我们应该为小F同学的行为而感动，他用自己的亲身经历告诉我们$SPFA$已死，$dijkstra$才是正统（逃

但是很明显，在这题中不管是某已死算法还是无优化的$dijkstra$都会被数据卡成蛇的，所以我们需要对普通的$dijkstra$增加一些优化。

观察无优化的模板，我们发现时间复杂度提不上去的根本原因是找全局最小值的时间花费太长了，所以我们可以用堆来维护这个最小值，使得时间复杂度优化为$\mathcal{O}(n\log n)$。

我们可以用priority_queue来实现堆，但是algorithm中也有三个函数可以将序列维护成堆的形式。

对于一个序列$a[i]$：

$make\_heap(a + 1, a + n + 1, cmp)$表示将序列中的1~n的部分建立成一个堆，用的是数组存完全二叉树的方式（cmp为比较函数，大根堆return a < b，小根堆反之）。

$push\_heap(a + 1, a + n + 1,cmp)$表示将第n个元素放入堆中。

$pop\_heap(a + 1, a + n + 1, cmp)$弹出堆顶。

取出堆顶即为a[1]。

于是我们的优化就可以这么写：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

struct Edge {
	int d, to, next;
} e[200010 << 1];

std::pair<int, int> heap[200010 << 1];
int size, n, m, dist[100010], head[100010], tot;
bool v[200010];

inline cmp(std::pair<int, int> a, std::pair<int, int> b) {//比较函数
	return a.first > b.first;
}

inline void add(int u, int v, int w) {
	e[++tot].to = v;
	e[tot].d = w;
	e[tot].next = head[u];
	head[u] = tot;
	
}

void dijkstra() {
	memset(dist, 0x3f, sizeof(dist));
	memset(v,0, sizeof(v));
	dist[1] = 0;
	heap[++size] = std::make_pair(0, 1);
	while (size) {
		int x = heap[1].second;
		std::pop_heap(heap + 1, heap + size + 1, cmp);//弹出堆顶
		size--;
		if (v[x]) continue;
		v[x] = 1;
		for (int i = head[x]; i; i = e[i].next) {
			int y = e[i].to, z = e[i].d;
			if (dist[y] > dist[x] + z) {
				dist[y] = dist[x] + z;
				heap[++size] = std::make_pair(dist[y], y);
				std::push_heap(heap + 1, heap + size + 1, cmp);//把二元组插入堆中
			} 
		}
	}
}
 
int main() {
	int s;
	scanf("%d %d %d", &n, &m, &s);
	for (int i = 1; i <= m; i++) {
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);
		add(u, v, w);
	}
	dijkstra();
	for (int i = 1; i <= n; i++) {
		printf("%d ", dist[i]);
	}
	return 0;
}
```

代码已增加防抄袭，请大家在不关键的地方找问题

本题解提供了一个实现堆的不同思路，希望大家能够从中获益。


---

## 作者：n0000000000o (赞：0)

我一只蒟蒻就不多说了，  
在此补充 @HNFMS郎才尽江淹 的题解，用结构体半封装一下，加了很多注释的代码。~~快读都没有写~~  
  思路：用 **优先队列** 和 **$pair$** 优化的 **迪杰斯特拉** 算法  
    代码见下 
  ```cpp
#include <bits/stdc++.h>
#include <queue> 
using namespace std;
int n, m, s;
struct NodePath{
	int net;//边 -> 边   这条边的出发点上出发的上一条边的编号 
	int v;//边 -> 点  这条边的终点编号 
	int w;//边 -> 值  这条边的权值 
} ph[500000 + 9];
struct NodePoint{
	int head;//点 -> 边   从这个点出来的最新的一条边的编号 
	long long dis;//到每个点的最短距离 
//	NodePoint():head(0), dis(0x3f3f3f3f){}
	NodePoint(int a = 0, long long b = 0x3f3f3f3f)//初始无穷大 
	{
		head = a;
		dis = b;
	}
} pt[100000 + 9];
typedef pair <long long, int> point;//第一项是到点的最短路，第二项是该点的编号 
void node(int x, int y, int ww, int e);//邻接表初始化 
priority_queue <point, vector<point>, greater<point> > q;
//优先队列，优先返回较小值 （默认先排 pair 的第一位） 
int main()
{
	cin >> n >> m >> s;
	for (int i = 1; i <= m; i++)
	{
		int x, y, ww;
		cin >> x >> y >> ww;
		node (x, y, ww, i);//邻接表 
	}
//	int inf = 0x3f3f3f3f;
//	fill(pt+1, pt+1+n, NodePoint(0,inf));
	pt[s].dis = 0;//到自己的距离为0 
	q.push(point(0,s));//源点入队 
	while (!q.empty())
	{
		point x = q.top();
		q.pop();
		if (x.first > pt[x.second].dis)//剪枝：没有继续找下去的必要 
			continue;
		for (int i = pt[x.second].head; i != 0; i = ph[i].net)//把这个点的每条出边跑一次 
		{
			int z = ph[i].v; //把终点记录 
			if (x.first + ph[i].w < pt[z].dis)//到 x 点的最短距离 + 该边权值 < 到 z 点的最短距离
			{
				pt[z].dis = x.first + ph[i].w;//收缩
				q.push(point(pt[z].dis, z));//将该点更新 
			} 
		} 
	}
	for (int i = 1; i <= n; i++)
		cout << pt[i].dis <<" ";
	cout << endl;
	return 0;  
}
void node(int x, int y, int ww, int e)//邻接表初始化 
{
	ph[e].net = pt[x].head;//指向该顶点的上一条边 
	pt[x].head = e;
	ph[e].v = y;
	ph[e].w = ww;
}

  ```

---

## 作者：panhuachao (赞：0)

Dijskra算法+堆优化，但是数据有点大，不能用邻接矩阵储存，用邻接表。
好了，其他也没什么可说的了。这篇题解呢，是大量利用STL的，要是看不懂STL的请见楼下题解。。。
```cpp
//根据数据范围(以P4779为准，这个代码两题通用)，我决定采用Dijskra的堆优化 
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#include<cstring>
#include<list>
using namespace std;
struct Edge{
    int to,len;
};
int n,m,s , u,v,w;
vector<list<Edge> > dis;		//一看数据，邻接矩阵肯定Pass了，上邻接表（高级写法） 

struct Dot{
    int dist,t;
    bool operator < (Dot a)const{
        return dist>a.dist;
    }
};
priority_queue<Dot> q;
vector<int>f;					//离起点的最小距离 
int tot;

int main(){
//	freopen("testdata.in","r",stdin);
//	freopen("testdata.out","w",stdout); 
    scanf("%d%d%d",&n,&m,&s);
    dis.reserve(n+1);
    f.reserve(n+1);
    for(int i=0;i<=n;i++)
        dis.push_back(list<Edge>());
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&w);
        if(u!=v) dis[u].push_back( {v,w} );		//数据有毒，有从a到a距离为??(>0)的这种东西造成死循环。。。 
    }							//读入 
    
    for(int i=0;i<=n;i++)
        f.push_back(2147483647);
    q.push( Dot{0,s} );
    tot=n;					//初始化 
    for(;tot>0&&!q.empty();){		//必须要加!q.empty()，否则就会因为达不到的点卡死，tot是节省时间 
        Dot now=q.top(); q.pop();
        if(f[now.t]<=now.dist) continue;
        f[now.t]=now.dist; tot--;
        for(list<Edge>::const_iterator i=dis[now.t].begin();i!=dis[now.t].end();i++)
             q.push( Dot{now.dist+i->len,i->to} );
    }
    for(int i=1;i<n;i++) printf("%d ",f[i]); printf("%d\n",f[n]);
//	fclose(stdin);
//	fclose(stdout);
    return 0;
} 
```


---

## 作者：wangxuye (赞：0)

一道标准的dijkstra的堆优化

二叉堆就不讲了~~（反正也没人用）~~，用STL里的优先队列priority_queue代替就行了，记得重载小于运算符就行了

细节见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100010,M=200010;

int head[N],ver[M],edge[M],next[M],d[N];
int n,m,tot=0,s;
bool visit[N];

void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,next[tot]=head[x],head[x]=tot;
}

struct aa
{
	int v,pos;
} ;
bool operator<(const aa &a,const aa &b) //重载小于运算符
{
	return a.v>b.v;
}
priority_queue<aa> q;

void push(int v,int pos) //代替q.push()
{
	aa a;
	a.pos=pos,a.v=v;
	q.push(a);
}

void dijkstra()
{
	memset(d,0x3f,sizeof(d));
	d[s]=0;
	memset(visit,false,sizeof(visit));
	for(;q.size();q.pop());
	push(0,s);
	for(;q.size();)
	{
		aa x=q.top();
		q.pop();
		int pos=x.pos,v=x.v;
		if(visit[pos]) continue; //重点注意（我不会告诉你我在这儿TLE了好几次）
		visit[pos]=true;
		for(int i=head[pos];i;i=next[i])
		{
			int y=ver[i];
			if(visit[y]) continue;
			if(d[y]>v+edge[i])
			{
				d[y]=v+edge[i];
				push(d[y],y);
			}
		}
	}
}

int read()
{
	int a=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		a=(a<<3)+(a<<1)+ch-'0',ch=getchar();
	return a*w;
}

void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}

int main()
{
	n=read(),m=read(),s=read();
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		a=read(),b=read(),c=read(); //怕被卡所以送了快读
        add(a,b,c);
	}
	dijkstra(); //dijkstra
	for(int i=1;i<=n;i++) write(d[i]),putchar(' ');
	printf("\n");
	return 0;
} 
```

---


# [COCI 2014/2015 #3] DOM

## 题目描述

在一个养老院里，$n$ 位老人正在看电视。这个电视节目由 $m$ 个频道组成，数字从 $1$ 到 $m$ 不等。每个老人都有自己喜欢和讨厌的电视频道。

如果电视正在播放某个老人讨厌的频道，他会站起来，慢慢走向电视机，把频道换成他最喜欢的，然后回到舒适的椅子上。如果有多个老人讨厌现在的频道，他们中最年轻的会站起来，把频道换成他最喜欢的，其余的人都会坐着。

当然，在一次更换频道后，另一位老人可能会觉得新频道无法忍受，所以他会更换该频道。鉴于老人们很顽固，这种情况可能会无限期地持续下去。

对于老人们最喜欢和讨厌的频道以及电视上的初始频道，确定老人们保持快乐所需的频道更改次数。

## 说明/提示

#### 样例输入输出 1 解释
最初，电视上是 $2$ 频道。这个频道惹恼了最年轻和最年长的老人，所以最年轻的人站起来，把频道他最喜欢的改成 $1$ 频道，这样每个人都可以一起看 $1$ 频道。
#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $1\le n,m\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n,m\le 10^5$，$1\le p\le m$，$1\le a_i, b_i\le m$，$a_i \neq b_i$。

## 样例 #1

### 输入

```
3 4 2
1 2
2 3
3 2```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3 1
1 2
2 3
3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 5 2
1 3
2 3
3 2
5 1```

### 输出

```
3```

# 题解

## 作者：Graphcity (赞：14)

对于这道题，我们可以建图解决问题。

在这题所构造的图中，如果点 $a$ 连向了点 $b$ , 则表示现在正在观看频道 $a$ 时会有一个人把频道调到 $b$ 。

样例 3 建的图差不多是这样子的：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ocedhiu.png)

我们可以试着再把图化简一下：

每次要调整频道时，只会让最年轻的人来调整，所以对于每个点，只要保留它第一次连的边就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/ice7q8ew.png)

可以发现，当走到入度为 0 的结点时，就没有人会调频道了，可以输出答案。而且，当两次都经过同一个点时，就表示老人们会一直循环调整频道，输出 -1 结束程序即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Maxn int(1e5)
using namespace std;

int n,m,now,ans;//now:目前所在的结点 
int nxt[Maxn+5];//nxt[x]表示x连接的那一条边 
int vis[Maxn+5];//vis[x]记录x结点经过了几次 

int main()
{
	scanf("%d%d%d",&n,&m,&now);
	for(register int i=1;i<=n;++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		if(!nxt[b]) nxt[b]=a;//连边 
	}
	while(nxt[now])
	{
		if(++vis[now]>1)//特判无解 
		{
			printf("-1");
			return 0;
		}
		now=nxt[now];
		++ans;
	}
	printf("%d",ans);
    return 0;
}
```

---

## 作者：peppaking8 (赞：9)

## 思路
$$\texttt{Solution 1}$$
$$\text{60 pts}$$
很容易想到，按照题目模拟即可。从 $p$ 开始，记录一下当前的步骤，然后对于每一轮，从前往后搜，如果有人讨厌这个频道就直接变换，并进入下一个步骤。

时间复杂度 $O(n^2)$，肯定过不了 $n\le 10^5$ 的数据。而且，如果操作可以无限进行，那么程序就会持续不断地进行，肯定超时了。

我们先考虑一下如何处理死循环的情况。如果整个操作的步骤中出现了两个相同的频道，并在不同时间中出现，那么可以说就构成了**循环**，操作就会无限进行。如果没有这样的情况呢？很简单，操作会在 $m$ 轮之内截止。

所以我们可以想到用 ```vis[]``` 数组来判断这个频道是否在之前出现过，初始化 $\text{vis}_p$ 为 $1$。如果出现相同，直接退出并输出 ```-1```。

还有一种判断方法，就是**仅枚举前 $m$ 轮**，如果仍然没有结束，那么根据抽屉原理，必定存在两个数相同。进而会死循环。

$$\texttt{Solution 2}$$
$$\text{100 pts}$$

我们再看一眼样例。

```
3 4 2
1 2
2 3
3 2
```

对于样例 $1$，注意到第三个人是**不可能换频道的**。因为即使现在是频道 $2$，比他年龄小的人也会率先调转频道。

所以，可以调换频道的人最多只有 $m$ 个。那么我们自然想到记录一个 ```to[i]``` 数组，表示在电视上播放 $i$ 频道时，会调换到哪个频道。

这样，每次操作就变成了 $O(1)$ 的效率，总体复杂度变为 $O(n)$。优秀！

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,m,p;
int to[N];
int main(){
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		if(!to[y]) to[y]=x;//更新to数组
	} 
	if(!to[p]){//如果没人讨厌p频道，那么就不会调换。
    	printf("0\n");
		exit(0);
	}
	for(int i=1;i<=m;i++){//枚举前m轮
		p=to[p];//变换频道
		if(!to[p]){//如果下一步没人换频道，输出当前步数。
			printf("%d\n",i);
			exit(0);
		}
	}
	printf("-1\n");//如果仍没有结束，根据Solution1的介绍，应该输出-1。
	exit(0);
} 
```

记得点个赞再走哦~

---

## 作者：Ptilopsis_w (赞：6)

# 1.题意
有 $m$ 个频道, $n$ 个老人，每个老人有最喜欢的频道和最讨厌的频道，若当前频道是某个老人最讨厌的，他就会把频道换成最喜欢的，如果多个老人讨厌同一个频道，最年轻的老人会切换频道，给定初始频道 $p$ ，输出切换几次频道才能停止，若无法停止，输出 $-1$ 
# 2.思路
若有一个老人喜欢 $a$ 频道，讨厌 $b$ 频道，那么当前频道是 $b$ 的话，就会被这个老人换成 $a$

根据上面的分析，我们可以将 $m$ 个频道抽象成 $m$ 个点，每一个老人抽象成从 $b$ 到 $a$ 的有向边，从 $p$ 开始搜索，若找到一个点没有边连向其他点，说明这个点所有老人都不讨厌，输出路径长度即可，若找到环，说明这几个老人会不停切换频道，输出 $-1$ 即可

但是题目中给了这么两句话
```
如果有多个老人讨厌现在的频道，他们中最年轻的会站起来，把频道换成他最喜欢的，其余的人都会坐着。
老人的输入顺序是按年龄从小到大排列的。
```
说明如果有一个点连出去多条边，只会走输入时最早的那条边，也就是**每个点只有一条边或没有边**，这样我们直接用一个数组 $to$ 来表示这个点连向哪个点就可以了，然后从 $p$ 开始遍历，遍历到哪个点就打上标记，若遍历到一个已经打了标记的点，说明有环，输出 $-1$没有边连出去，输出路径长度即可

# 3.代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, p;
bool vis[100005];
int to[100005];

int work(int x, int tot)
{
	if(vis[x] == true)//遍历到之前访问过的点了，说明有环
		return -1;
	if(to[x] == 0)//这个点没有边连出去，说明找到了解，返回路径长度
		return tot;
	
	vis[x] = true;//上面两个情况都不符合就打上标记继续递归
	return work(to[x], tot+1);//这样写可以在找到解时直接一路返回到main()
}

int main()
{
	scanf("%d%d%d", &n, &m, &p);
	for(int i = 1; i <= n; i++)
	{
		int v, u;
		scanf("%d%d", &v, &u);//注意题目输入顺序
		
		if(to[u] == 0)//如果u之前没有边，即当前为时间最早的边
			to[u] = v;
	}
	printf("%d", work(p, 0));//用work函数递归解题
	return 0;
}
~~~

---

## 作者：快斗游鹿 (赞：5)

本题是一道很基础的图论练习题。

但大家的思路也不要被题目标签所局限。

因为本题还可以用模拟解决。

## 思路

首先，我设置了一个桶 $flag$。

这个桶的作用就是统计某个频道有没有人讨厌。

如果这 $m$ 个频道都有人讨厌，那老人们一定会不断地循环切换频道，就要输出 $-1$。

反之，我们就将桶二次循环利用（节省空间）。

因为题目中的老人是按年龄输入的，所以我们也不用进行排序。

那桶要如何二次使用呢？

第一，我在判断每个桶是否为空时，将每个桶都置回初始值。

第二，我们在往桶里扔值时，判断条件就是该桶是否为空。

当桶 $b[i]$ 为空时，就将配套的 $a[i]$ 装进桶中，这样就保证一定会是最年轻的老人去调频道。

接下来我们思考：既然已经判断过一遍是否会产生循环了，那接下来的模拟岂不是用单重循环就行了？

事实就是如此，我们只需要执行一个循环次数不超过 $m$ 的循环，就可以得到答案。

第一，当 $p$ 频道本身就没人讨厌时，直接输出 $0$。

第二，如何模拟？

```
for(int i=1;i<=m;i++){
		if(flag[p]==0){//如果没人讨厌，就直接输出
			cout<<s;
			return 0;
		}
		else{
			p=flag[p];//将此时的频道置为讨厌本频道的人喜欢的频道
			s++;//计数器累加
		}
	}
	cout<<-1;//如果跑完m个频道又回到了原位，就说明形成了循环
```

了解模拟过程后，我们直接贴代码：

## Code
```
#include<bits/stdc++.h>
using namespace std;
int a[100011],b[100011],flag[100011],biaozhi[100011];
int main(){
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);
		flag[b[i]]=1;//进行第一轮桶处理
	}
	int ll=0;
	for(int i=m;i>=1;i--){
		if(flag[i]==0){//判断桶是否都有值
			ll=1;
		}
		flag[i]=0;//将桶置为初始值
	}
	for(int i=1;i<=n;i++){
		if(flag[b[i]]==0){
			flag[b[i]]=a[i];//标志每个频道会被切换到的下一个频道
		}
	}
	if(ll==0){//会产生循环，直接输出
		cout<<-1;
		return 0;
	}
	int i=1,s=0;
   //上面讲过模拟过程了，这里不再赘述
	for(int i=1;i<=m;i++){
		if(flag[p]==0){
			cout<<s;
			return 0;
		}
		else{
			p=flag[p];
			s++;
		}
	}
	cout<<-1;
	return 0;
}
```


---

## 作者：sukimo (赞：3)

这道题是一个基础的模拟题。一旦理解题目，代码就呼之欲出了。

首先，让我们仔细品味这句话：“如果有多个老人讨厌现在的频道，他们中最年轻的会站起来，把频道换成他最喜欢的，其余的人都会坐着。”这句话揭示了一个十分重要的性质：如果在所有讨厌老人$i$讨厌的频道的老人中，老人$i$不是最年轻的，那么就可以忽略老人$i$不管(听起来好没责任感的样子)。因为就算出现他不喜欢的频道，也轮不到他来换台，而是由更年轻的老人来做。

那么，我们定义两个数组$hate$和$like$(它们的意义可不相同)。$hate[i]$表示讨厌$i$频道的最年轻老人编号，而$like[i]$表示老人$i$喜欢的频道。这样就好像构成了一条链，我们由当前的频道$fir$，如何判断切换的下一个频道呢(如果要换)？那么就是$like[hate[fir]]$。这应该比较好理解。如果没有人讨厌当前这个频道，那么$hate[i]$就是$0$。如果要判断会不会一直换台，只用一个标记数组记录一下换过的频道就好了。一旦重复就说明会一直换下去。接下来的代码应该是十分清晰好懂的：

```
#include<bits/stdc++.h>
using namespace std;
const int MX=100005;int vis[MX],hate[MX],like[MX];
int main(){
	int n,m,fir,cnt=0;scanf("%d%d%d",&n,&m,&fir);
	for(int i=1;i<=n;i++){int q;scanf("%d%d",&like[i],&q);if(!hate[q])hate[q]=i;}
	while(hate[fir]){
		if(vis[hate[fir]]){cnt=-1;break;}cnt++;vis[hate[fir]]=1;fir=like[hate[fir]];
	}
	printf("%d",cnt);
	return 0;
}
```

那么这篇题解就到这里，谢谢观赏！！

---

## 作者：y0y68 (赞：3)

这题是一个简单的**模拟**，按照题目做就可以了。

首先，我们会想到怎么判`-1`，显然我们把访问过的频道标记一下，遇到标记过了的输出`-1`就好了，因为如果遇到一个访问过的频道，就会访问到上次访问这个频道之后访问的下一个频道，从而形成循环。

然后思考，目前访问的这个频道没有被访问过怎么办？题目说由讨厌这个频道的最年轻的人来跳转到他喜欢的频道，于是我们需要建三个数组，分别是：$hate[i]$（表示第 $i$ 个频道有没有人讨厌，有为`true`，没有为`false`）、$chan[i]$（表示第 $i$ 个人喜欢的频道）、$young[i]$（表示喜欢第 $i$ 个频道的最年轻的人是哪位）。

读入时可这样预处理：
```cpp
scanf("%d%d",&chan[i],&x);
hate[x]=true;
if(!young[x])young[x]=i;
/*
如果目前没有讨厌这个频道的人就记下来，否则跳过，
因为题目说给出的老人是按年龄从小到大排序的。
*/
```
进行模拟时可这样写：
```cpp
while(!vis[p]){
	vis[p]=1;//做标记
	if(hate[p])p=chan[young[p]],cnt++;
	else{cout<<cnt<<endl;return 0;}
	/*
	如果第p个频道有人讨厌，就跳到讨厌
	第p个频道的最年轻的人最喜欢的频道，
	并且次数加1，否则输出答案，程序结束。
	*/
}
```
附加完整代码，时间复杂度为 $O(n)$ ：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
bool vis[100005],hate[100005];
int n,m,p,cnt,young[100005],chan[100005];
int main(){
	cin>>n>>m>>p;
	for(int i=1,x;i<=n;i++){
		scanf("%d%d",&chan[i],&x);
		hate[x]=true;
		if(!young[x])young[x]=i;
	}
	while(!vis[p]){
		vis[p]=1;
		if(hate[p])p=chan[young[p]],cnt++;
		else{cout<<cnt<<endl;return 0;}
	}
	puts("-1");return 0;
}
```
拜拜

---

## 作者：do_while_true (赞：2)

统计一下每个频道如果要换的时候应该换哪一个频道。

也就是每个频道第一次作为最讨厌的频道时的最喜欢的频道。

每一次频道变成自己指向的频道，如果再次回到这个频道说明出现环的情况，也就是无解输出 $-1$。

当这个频道没有指向的频道时，也就是这个频道所有人都不讨厌，则输出我们换频道的次数。

### Code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,p,a,b,vis1[100001],cnt;
bool vis2[100001];
int main()
{
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a,&b);
		if(!vis1[b]) vis1[b]=a;
	}
	while(vis1[p])
	{
		if(vis2[p]){
			printf("-1");
			return 0;
		}
		vis2[p]=1;
		p=vis1[p];
		++cnt;
	}
	printf("%d",cnt);
	return 0;
}
```


---

## 作者：Terraria (赞：1)

~~（我才不会告诉你我一开始暴力还能水 $70$ 分呢）~~

既然都说到暴力了，那就讲讲暴力的思路（居然还有 $70pts$）：

首先用一个队列存下当前正在播放的电视频道，然后再从第 $1$ 个人搜到第 $n$ 个人，如果有哪一个人的不喜欢的电视频道正好是当前的频道，就先弹出队头，拉入这个人喜欢的电视频道。

由于此非整解，就不过多赘述，具体看代码及注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,sum=0;
int a[100009];//最喜欢
int b[100009];//最讨厌
bool c=true;
queue<int> q;
int vis[100009];//是否看过这个电视频道
inline int read(){//快读
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
    	if(ch=='-')f=-1;
    	ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}
inline void write(int x){//快写
    if(x<0) x=~x+1,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main(){
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i]=read();
	}
	q.push(p);
	while(!q.empty()){
		int qian=q.front();
		vis[qian]=true;//已经看过这个电视
		q.pop();//直接先弹出
		for(int i=1;i<=n;i++){
			if(b[i]==qian){//如果搜到有人不喜欢这个电视频道
				if(!vis[a[i]]){//还没看过这个电视说明当前还没有产生环，也就是还不能确定是否是无限次调整
					q.push(a[i]);//拉入队，表示接下来要看的电视频道
					break;//由于只有最年轻的人去调整，因此需要跳出循环
				}
				else{//在有环的情况下说明要无限次调整，因此c标记为false
					c=false;
					break;
				}
			}
		}
		sum++;
	}
	if(c) write(sum-1);//即使最后满足了条件也会因为while里面的最后一条语句而多加1，因此输出减1
	else write(-1);
	return 0;
}
```
# 正解：

再分析刚才的思路：

在判断是否要拉入队时我们采用的是 $for$ 爆搜；

## 那如果我们记录一下呢——

```cpp
for(int i=1;i<=n;i++){
	cin>>a[i]>>b[i];
	if(!first_hate[b[i]]) first_hate[b[i]]=a[i];//作用是记录当前第b[i]个频道一定且唯一被电视频道为a[i]的所替代
}
```
## 当然光有记录还不够，还需要一个记录电视频道是否多次出现数组，以防出现环。

对于以上这条，只需要打一个数组记录是否出现次数大于 $1$，如果大于则说明已经出现了环，故直接输出 $-1$ 并 $return$ $0$。

于是代码就出来啦！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,ans=0;
int first_hate[100009];
int a[100009],b[100009];
int times[100009];//记录每个频道的出现次数
int main(){
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];//其实根本不需要这两个数组，懒得改了
		if(!first_hate[b[i]]) first_hate[b[i]]=a[i];//已有说明
	}
	while(first_hate[p]){//在当前频道是否有被厌恶，若有则需要执行以下操作
		times[p]++;//记录出现次数
		if(times[p]>1){//出现次数大于1则说明出现了环
			cout<<-1;
			return 0;//记得return 0！！！
		}
		p=first_hate[p];
        /*
        这句语句估计是核心，这里的p相当于前面的a[i]
        p代表当前的电视频道
        first_hate[p]代表讨厌这个电视频道对应的应该被替换的频道
        替换之后继续对当前的电视频道进行循环
        */
		ans++;//增加一次操作
	}
	cout<<ans<<endl;
	return 0;
}
```
码字不易，谢谢观看！

---

## 作者：小恐 (赞：1)

这道题中每个频道有唯一的它下一个要跳转的频道，或者就没有下一个，如果没有下一个那就不会有老人再去调频道了。如果有，那么它的下一个一定是第一个讨厌它的老人喜欢的频道。

记录完了后就从初始频道开始走，循环也好，dfs也行，我习惯用dfs。我们需要把看过的频道打上标记，如果这个点之前走过又回来了，那永远也停不下来，输出$-1$，因为每个频道最多看一次，所以时间复杂度$O(m)$，不会超时。

上代码：
```cpp
#include<stdio.h>
#include<string.h>
using namespace std;
const int NR=1e5+5;
const int MR=1e5+5;
const int INF=0x3f3f3f3f;
typedef long long LL;
int read()//快读
{
	int x=0;
	int bei=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			bei=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*=bei;
}
int nxt[MR];//每个频道的下一个
bool book[MR];//记录看没看过
int cnt;//调了几次频道
void dfs(int x)
{
	if(book[x])//之前走过
	{
		cnt=-1;//答案为-1
		return;
	}
	if(nxt[x]==-1)//后面没有了
		return;//停！
	++cnt;//次数+1
	book[x]=1;//标记看过
	dfs(nxt[x]);//继续调
}
int main()
{
	memset(nxt,-1,sizeof(nxt));//全默认-1
	int n=read(),m=read(),p=read();
	for(int i=1;i<=n;++i)
	{
		int u=read(),v=read();
		if(nxt[v]==-1)//是第一个讨厌这个频道的
			nxt[v]=u;//记录下一个
	}
	dfs(p);//从初始频道开始
	printf("%d",cnt);//输出答案
	return 0;
}

```
感谢阅读！~~点个赞再走呗~~

---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6264)

提供一种 $O(n)$ 模拟思路

一个一个频道访问即可

对于当前访问的频道，可能有两种情况：

**一、当前频道已经被访问过**

这个时候直接输出 `-1`即可

因为访问完这个频道后肯定会访问上次访问这个频道后访问的一个频道，就会出现死循环

拿样例二举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ohlg1qab.png)

如图，最初电视上的是频道 $1$

频道的变化顺序：$1\rightarrow 2\rightarrow 3\rightarrow 1\rightarrow 2\rightarrow ......$

可以看出是个死循环，故输出 `-1`

**二、当前频道仍未被访问过**

先将这个频道标记一下，然后根据这个频道的信息找到最讨厌这个频道的人中最年轻的一个，然后跳转到那个人最喜欢的频道即可

那么，问题来了：

**怎么找到「最讨厌这个频道的人中最年轻的一个」呢？**

发现题目中有一个条件：

> 老人的输入顺序是按年龄从小到大排列的。

因此存储最先输入的讨厌这个频道的人编号即可

看代码吧：

```
#include<bits/stdc++.h>
const int maxn=100005;
using namespace std;
bool vis[maxn],h[maxn];
//vis记录此频道访问过了没有，h记录有没有人讨厌这个频道
int n,m,p1,cnt;
//cnt记录换了多少次频道
int p[maxn],l[maxn];
//p记录讨厌这个频道的最年轻的人是哪个人，l记录这个人最喜欢的频道
int main(){
	cin>>n>>m>>p1;
	for(int i=1;i<=n;i++){
		int x;
		cin>>l[i]>>x;
		h[x]=1;
		if(!p[x]){
			p[x]=i;//记录讨厌这个频道的最年轻的人
		}
	}
	while(!vis[p1]){//遇到标记过的频道直接跳出
		vis[p1]=1;//标记
		if(h[p1]){//有人讨厌就换频道
			p1=l[p[p1]];
			cnt++;
		}else{//没人讨厌直接输出
			cout<<cnt<<"\n";
			return 0;
		}
	}
	cout<<"-1"<<"\n";//跳出循环输出-1
	return 0;
}
```

---

## 作者：_edge_ (赞：0)

据说有神仙会 $O(n)$ ？~~反正本蒟蒻只会图论。~~

首先对于 $50\%$ 的数据保证 $n,m\le10^3$。

显然用暴力的 $O(n^2)$ 做法模拟一遍 $50$ 分就拿到了。

换一个角度思考一下，`-1` 的情况有哪些？

可能是有**环**的情况？

所以？**环**用什么来判？**SPFA**！

其实如果想到**SPFA**那么这道题目的模型也就出来了。

将这个转化成一张图就是 $b_i → a_i$ 连一条 $-1$ 的边，然后通过 SPFA 来判一下负环。$b_i → a_i$ 连一条 $1$ 同理跑一遍最长路就可以了。

那 …… 答案怎么统计呢？

首先可以发现，答案肯定是 `-1` 多的那个频道。

于是用一个最小值来求 `-1` 多的那个频道，然后取一个相反数就可以了。

这里我用的是 DFS 找环，队列的话可能比较慢。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int INF=1e5+5;
int n,m,p,a[INF],b[INF],dis_[INF],vis[INF];
struct _node_edge {
        int to_,next_;
} edge[INF];
int head[INF],tot;
void add_edge(int x,int y) {
        edge[++tot]=(_node_edge){y,head[x]};
        head[x]=tot;
        return;
}
bool DFS_(int x) {
        vis[x]=true;
        int i=head[x]; if (!i) return false;
        if (dis_[edge[i].to_]>dis_[x]-1) {
                dis_[edge[i].to_]=dis_[x]-1;
                if (vis[edge[i].to_]) return true;
                if (DFS_(edge[i].to_)) return true;
        }
        return false;
}
signed main()
{
        scanf("%d %d %d",&n,&m,&p);
        for (int i=1; i<=n; i++) scanf("%d %d",&a[i],&b[i]);
        for (int i=n; i>=1; i--) add_edge(b[i],a[i]);//注意这里要倒着连边，但这个链式前向星其实可以省去不写。
        memset(dis_,63,sizeof dis_);
        memset(vis,false,sizeof vis);
        dis_[p]=0;
        if (DFS_(p)) {cout<<"-1\n"; return 0;}
        int Minv=0;
        for (int i=1; i<=m; i++) if (dis_[Minv]>dis_[i]) Minv=i;
        cout<<(-dis_[Minv])<<"\n";
        return 0;
}

```


---

## 作者：Mr_WA的大号 (赞：0)

我还是从前那个蒟蒻，没有一丝丝改变。小学生又来发题解了！

题号：P6264

难度：★★★

算法：（~~啥也没有就智力~~）

## 开课了！

这道题真的并不难，重点在于两个东西：

1.如何调频道

2.是否会无期限地继续

这次就给大家讲一下如何解决这两个问题。

对于调频道这个问题如果当前频道有人不喜欢，就调为他喜欢的频道，否则输出次数就行了。

是否会无期限继续我们就来看一下在调频道的过程中出现了几次。如果出现了两次，就代表已经有一个环了，如：1-2-5-4-3-2-5-4-3-2-5......

课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<stack>
#include<queue>
#include<set>
using namespace std;
int n,m,now,ans;
int a,b;
int fav[100010],vis[100010];
double dis[100010];
int main()
{
	cin>>n>>m>>now;
	for(int i=1; i<=n; i++)
	{
		cin>>a>>b;//输入没必要用数组
		if(fav[b]==0)fav[b]=a;//如果他是第一个不喜欢这个频道的人，那么他会将频道b调为频道a
		dis[b]=true;//将这个频道设为有人不喜欢
	}
	while(dis[now]==true)//如果有人不喜欢这个频道
	{
		vis[now]++;//这个频道出现的次数++
		if(vis[now]>1)//如果他出现的次数不止1次
		{
			cout<<-1;//则会无期限继续
			return 0;//结束
		}
		now=fav[now];//调频道
		ans++;//次数++
	}
	cout<<ans;//输出调频道的次数
	return 0;
}
```
祝大家能AC！

---


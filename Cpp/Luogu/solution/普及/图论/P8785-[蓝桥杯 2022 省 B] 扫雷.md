# [蓝桥杯 2022 省 B] 扫雷

## 题目描述

小明最近迷上了一款名为《扫雷》的游戏。其中有一个关卡的任务如下，在一个二维平面上放置着 $n$ 个炸雷，第 $i$ 个炸雷 $\left(x_{i}, y_{i}, r_{i}\right)$ 表示在坐标 $\left(x_{i}, y_{i}\right)$ 处存在一个炸雷，它的爆炸范围是以半径为 $r_{i}$ 的一个圆。

为了顺利通过这片土地，需要玩家进行排雷。玩家可以发射 $m$ 个排雷火箭，小明已经规划好了每个排雷火箭的发射方向，第 $j$ 个排雷火箭 $\left(x_{j}, y_{j}, r_{j}\right)$ 表示这个排雷火箭将会在 $\left(x_{j}, y_{j}\right)$ 处爆炸，它的爆炸范围是以半径为 $r_{j}$ 的一个圆，在其爆炸范围内的炸雷会被引爆。同时，当炸雷被引爆时，在其爆炸范围内的炸雷也会被引爆。现在小明想知道他这次共引爆了几颗炸雷?

你可以把炸雷和排雷火箭都视为平面上的一个点。一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。

## 说明/提示

**【样例说明】**

示例图如下, 排雷火箭 1 覆盖了炸雷 1 , 所以炸雷 1 被排除; 炸雷 1 又覆 盖了炸雷 2 , 所以炸雷 2 也被排除。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-13.jpg)

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例: $0 \leq x, y \leq 10^{9}, 0 \leq n, m \leq 10^{3}, 1 \leq r \leq 10$.

对于 $100 \%$ 的评测用例: $0 \leq x, y \leq 10^{9}, 0 \leq n, m \leq 5 \times 10^{4}, 1 \leq r \leq 10$. 


蓝桥杯 2022 省赛 B 组 H 题。

## 样例 #1

### 输入

```
2 1
2 2 4
4 4 2
0 0 5```

### 输出

```
2```

# 题解

## 作者：zzy0618 (赞：23)

改掉了之前的错误解法，这下应该没问题了。

## 思路

有一个性质是 $r\le 10$，也就是一个雷至多引爆 $10^2$ 级别个的**位置**（不是个数）的雷，而雷的数量级足够我们去暴力寻找这些位置。

将所有炸雷存到一个桶里面，具体的，使用 `map` 编号，然后存一下在这个位置雷的个数以及这个位置最大的 $r$。对于每个一个排雷火箭使用 dfs 暴力搜，已经被搜过的地方打个标记就行。

这样复杂度是 $O(r^2(n+m)\log n)$ 的，可以通过此题。

## 代码

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define mk make_pair
using namespace std;
const int N=1e5+5,M=290023;
int n,m,ans,tot;
int cnt[N],tmp[N],vis[N];
map<pii,int> mp;
void dfs(int x,int y,int r){
	for(int i=x-r;i<=x+r;++i){
		for(int j=y-r;j<=y+r;++j){
			if((i-x)*(i-x)+(j-y)*(j-y)>r*r)continue;
			if(mp.count(mk(i,j))){
				int z=mp[mk(i,j)];
				if(vis[z])continue;
				vis[z]=1;ans+=cnt[z];
				dfs(i,j,tmp[z]);
			}
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,x,y,z,r;i<=n;++i){
		cin>>x>>y>>r;
		if(mp.count(mk(x,y))){
			int z=mp[mk(x,y)];
			++cnt[z],tmp[z]=max(tmp[z],r);
		}else
			mp[mk(x,y)]=++tot,
			cnt[tot]=1,tmp[tot]=r;
	}for(int i=1,x,y,r,z;i<=m;++i)
		cin>>x>>y>>r,dfs(x,y,r);
	cout<<ans<<'\n';
	return 0;
}
```

---


# [KOI 2023 Round 2] 湖边的蚁穴

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 湖畔有一个蚂蚁们聚居的蚁穴。这个蚁穴沿着圆形湖泊的边缘，环形地依次排列着从 $1$ 到 $N$ 编号的 $N$ 个房间。对于所有满足 $1 \leq i \leq N - 1$ 的 $i$，第 $i$ 个房间与第 $i + 1$ 个房间之间，以及第 $N$ 个房间与第 $1$ 个房间之间都通过通道直接连接。

但由于各种原因，从某些房间开始分出了若干个小房间。现在，对于所有满足 $1 \leq i \leq N$ 的 $i$，蚁穴中的第 $i$ 个房间通过通道直接连接着 $C_i$ 个小房间。与第 $i$ 个房间连接的小房间不会与其他任何房间相连。

例如，若 $N = 7$ 且 $C = [3, 0, 0, 1, 0, 2, 0]$，蚁穴的结构如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/57hzt6bh.png)

蚁穴中的每个房间与小房间最多只能住一只蚂蚁。如果通道直接连接的两个位置（房间或小房间）中都住着蚂蚁，那么这两只蚂蚁会感到不舒服。为了避免这种不适，当前蚁穴的每条通道最多只能连接一只住着蚂蚁的位置。

蚂蚁们非常聪明，因此在上述条件允许的情况下，它们总是设法使蚁穴中居住的蚂蚁数量最大。现在给出蚁穴的结构，请编写一个程序，计算最多有多少只蚂蚁可以住在蚁穴中。

## 说明/提示

**限制条件**

- 所有给定的数均为整数。
- $2 \leq N \leq 250\,000$
- $0 \leq C_i \leq 10^{12} \quad (1 \leq i \leq N)$

**子任务**

1. （4 分）$N = 2$  
2. （8 分）$N \leq 1\,000$ 且 $C_i = 0 \quad (1 \leq i \leq N)$  
3. （14 分）$N \leq 1\,000$ 且 $C_i \leq 1 \quad (1 \leq i \leq N)$  
4. （15 分）$N \leq 1\,000$  
5. （20 分）$C_i \leq 1 \quad (1 \leq i \leq N)$  
6. （13 分）$C_i \leq 1\,000 \quad (1 \leq i \leq N)$  
7. （9 分）$C_i \geq 1 \quad (1 \leq i \leq N)$  
8. （17 分）无附加限制

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
4
1 0 1 0```

### 输出

```
4```

## 样例 #2

### 输入

```
4
1 1 1 1```

### 输出

```
4```

## 样例 #3

### 输入

```
2
0 0```

### 输出

```
1```

## 样例 #4

### 输入

```
7
3 0 0 1 0 2 0```

### 输出

```
9```

# 题解

## 作者：chen_kun (赞：4)

# 题解：P12663 [KOI 2023 Round 2] 湖边的蚁穴

## 思路简述

这题还是比较简单的。

用数组 $a$ 代表第 $i$ 个大房间有 $a_i$ 个小房间，用变量 $cnt$ 代表能住几只蚂蚁。

首先遍历整个 $a$ 数组。

因为有通道直接连接的两个房间不能同时住蚂蚁，而小房间与其他的大房间没有通道直接连接，因此有小房间就让它直接住满蚂蚁即可。即若房间 $a_i$ 不为 0，则 `cnt+=a[i];`。

那么如果当前的大房间没有小房间，则找出一整段连续的没有小房间的大房间，用变量 $t$ 记录它们的个数，直到找到一个有小房间的大房间再统一结算。因为相邻的两个大房间不能同时住蚂蚁，所以这一连串的 $t$ 的大房间仅有一般的房间可以住蚂蚁，如果 $t$ 为奇数则可以在 $t$ 的一半的基础上再多住一只，即 `cnt=cnt+t/2+t%2;`。

另外由于数组是环状的，所以如果数组首尾都是 0 的话有点难处理，所以我们可以把开头所有的 0 都丢到数组的末尾将它们强制首尾相接，就简单很多了。

## 代码呈现

### C++


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=255555;
int cnt,n,a[2*N],mmax,t,st,f=1;//由于要首尾相接所以数组的大小要开到2*N 
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]!=0&&!st) st=i;//st用于记录第一个非0的数的位置 
		if(!st) a[i+n]=a[i];//如果开头是0就丢到数组末尾 
	}
	if(!st){//如果全是0直接输出即可 
		cout<<n/2;
		return 0;
	}
	for(int i=st,k=1;k<=n;k++,i++){
		if(a[i]!=0) cnt+=a[i]+t%2+t/2,t=0;//有小房间就全加起来，再结算前面连续的大房间，最后将大房间的个数清零 
		else t++;//没有小房间的话就累加个数 
	}
	cout<<cnt+t%2+t/2;//输出的时候再算一次防止数组末尾是0导致没算进去 
	return 0;
}
/*
6
3 0 2 0 0 0
*/
```
## The end.

---

## 作者：LateSight (赞：2)

首先，读一下题，能够有一个结论：如果有小房间时让蚂蚁进小房间为最好的情况。

### 证明：
因为题目中提到：“当前蚁穴的每条通道最多只能连接一只住着蚂蚁的位置”，所以进小房间我们就能保证目前的大房间一定没有蚂蚁住，从而使附近的两个房间均可居住。

接下来，可以枚举两种情况：
1. 从一号房间开始居住；
2. 从二号房间开始居住。

循环体内进行以下几个操作：

1. 判断当前房间 $i$ 是否有小房间，如果有，答案加上小房间数；
2. 若前一个或后一个房间有小房间并且前一个房间没有蚂蚁居住，答案加 $1$，并标记当前房间有蚂蚁；
3. 若前一个房间没有蚂蚁居住，答案加 $1$ ，并标记当前房间有蚂蚁。

需要注意的是，从一号房间开始住的话需要判断 $1$ 号和 $n$ 号房间是否同时有蚂蚁居住，如果有，答案减 $1$。

具体代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,cnt;
struct node{
	int pd,so,c;//pd表示是否有小房间，so表示小房间数，c表示是否选择过
}e[250010],e1[250010];//e表示情况1，e1表示情况2 
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>e[i].so,e[i].pd=((e[i].so)?1:0),e1[i]=e[i];//预处理，判断是否有小房间 
	for(int i=1;i<=n;i++)//情况1
		if(e[i].pd) cnt+=e[i].so;
		else if((e[i+1].pd||e[i-1].pd)&&!e[i-1].c) cnt++,e[i].c=1;
		else if(!e[i-1].c) cnt++,e[i].c=1;
	if(e[1].c&&e[n].c) cnt--;//特判 
	ans=max(ans,cnt);//记录答案 
	cnt=0;
	for(int i=2;i<=n;i++)//情况2 
		if(e1[i].pd) cnt+=e1[i].so;
		else if((e1[i+1].pd||e1[i-1].pd)&&!e1[i-1].c) cnt++,e1[i].c=1;
		else if(!e1[i-1].c) cnt++,e1[i].c=1;
	ans=max(ans,cnt);
	cout<<ans;//输出答案
	return 0; 
}
```

---

## 作者：2024Lsx (赞：1)

### [湖边的蚁穴原题](https://www.luogu.com.cn/problem/P12663)  
## 思路
考虑让蚂蚁全部住进小洞里面，这样明显更优。  
其余的大洞呢？有小洞的连接的大洞显然不行，两个大洞相连的显然不行。  
可以看连续的几个没有小洞连接的大洞里取上一半居住。  
考虑到这是一个环，可以从第一个有小洞的大洞开始，若没有，输出大洞个数的一半，详细见代码。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[2500001],sum;
signed main() {
	int n;
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		sum+=a[i];       //小洞个数
	}
	if(sum==0) {
		cout<<n/2;     //没有小洞
		return 0;
	}
	for(int i=n+1; i<=n*2; i++) {
		a[i]=a[i-n];      //破环成链
	}
	int t=-1;
	for(int i=1; i<=n; i++) {
		if(a[i]!=0) {
			t=i; //第一个有小洞的大洞
			break;
		}
	}
	int e=0;
	for(int i=t+1;i<=n+t;i++){
		if(a[i]!=0) {
			sum=sum+(e+1)/2;   //一半大洞
			e=0;
		}
		else{
			e++;             //寻找
		}
	}
	cout<<sum<<endl;
}
```

---

## 作者：XuZile (赞：1)

# P12663 题解
## 前言 ~~（废话）~~
这道题看上去很简单，但是~~做起来也很简单~~。就是~~有数不清的坑等着你去跳~~。我也是很荣幸的卡了~~足足半小时~~。
## 解题思路
我们可以通过分析得出，在有小房间的情况下优先住满小房间必定是最优解，统计答案为 $cnt=cnt+c_i$。那么在没有小房间的情况下，我们需要跳过一个房间去住。这个在程序中也比较好实现，只要得出上一个有小房间的地方到下一个有小房间的地方，得出中间隔了几个房间。统计答案为 $cnt=cnt+\left \lceil \frac{c}{2} \right \rceil$。但是这时候开头说的问题出现了，大家请看下面这种情况。![](https://cdn.luogu.com.cn/upload/image_hosting/rt5xmi4c.png)

我们发现在只有 5 个大房间的情况下，只能住 2 个房间。从而得出结论，因为在所有都没有小房间是我们统计的答案只能是 $cnt=\left \lfloor \frac{c}{2} \right \rfloor$。
## 代码实现
我这边做的时候处理环形的方法是将前面小房间数为 0 的房间全部挪到最后。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,cnt;
int a[500010];
signed main(){
	cin >> n;
	for(int i=1;i<=n;i++) cin >> a[i];
	for(int i=1;i<=n;){
		if(a[i]!=0){
			cnt+=a[i];
			i++;
		}else{
			bool ff=0;
			if(i==1)  ff=1;
			int c=0;
			while(i<=n&&a[i]==0) c++,i++;
			if(ff){
				if(c==n){
					cout << c/2;
					return 0;
				}
				n+=c;
				continue;
			}
			cnt+=(int)(ceil(c*1.0/2));
		}
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：枫原万叶 (赞：1)

# P12663 题解

## 分析

题目的大致意思是有一个无向环，环上的每个节点都可以再分支出去几个节点，但是分支出去的节点不能再分支。现在题目要求在每个节点上染上一种色（不染色也算），相邻的两个节点不能同色，问最多可以染多少个节点。

首先可以确定的是所有分支出去的节点都必须染色，哪怕只分支出去一个，这个分支节点影响到的也只是它的环节点，相反如果染色的是环节点，那么它会影响到其两边的节点以及其分支节点。

接着拥有分支节点（也就是分支节点被染色的环节点）就不能再染色，所以我们可以把整个环空格开来，在相邻两个不能被染色的节点之间尽量染最多的节点，那么就是 $\lceil \frac{n}{2} \rceil$（奇数要多加一个）。

最后答案就是两者相加之和。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main() {
	ios::sync_with_stdio(false);cin.tie(0);
	int n;
	cin >> n;
	vector<ll> c(n);
	ll s = 0;
	for (int i = 0; i < n; i++) {
		cin >> c[i];
		s += c[i];
	}
	vector<bool> z(n);
	for (int i = 0; i < n; i++)
		z[i] = c[i] == 0;
	bool f = true;
	for (int i = 0; i < n; i++)
		if (!z[i]) {
			f = false;
			break;
		}
	if (f) {
		cout << s + n / 2 << endl;
		return 0;
	}
	int st = 0;
	while (z[st]) st++;
	vector<int> a;
	int cnt = 0;
	for (int i = 0, idx; i < n; i++) {
		idx = (st + i) % n;
		if (z[idx])
			cnt++;
		else if (cnt > 0) {
			a.push_back(cnt);
			cnt = 0;
		}
	}
	if (cnt > 0) a.push_back(cnt);
	for (int x : a)
		s += (x + 1) / 2;
	cout << s << endl;
	return 0;
}
```

---

## 作者：wbqhasvcf (赞：0)

此题是个典型的贪心。

第一步，首先让所有蚂蚁住满小房间，可以证明这是最优的：即使一个大房间只有一个小房间，住在小房间和住在大房间二者只能选其一，但从目的上来说两种方法是等价的，都会多提供给一只小蚂蚁安居乐业的住所（为什么还要用上那么怪异的语言修饰，恼），况且住在小房间不会影响大房间周围的两个房间，而住在大房间会使周围的两个房间废掉，所以必须要让蚁子们住满小房间！

第二步，安排剩余没分出小房间的大房间。我们将这些大房间分成若干组，使每组的所有大房间的序号是连续的。由于每组的大房间的分配不会影响其他组的分配，接下来只用将每组大房间的数量加 $1$ 再除以 $2$，即为每组最贪心的分配方法，把每组的分配数累加起来与小房间总数相加，就完事了。

吗？注意注意！蚁穴是建在湖边，而不是你家门口的河边！如果对于任意的 $1\le i\le N$，$c_{i}=0$，那就不对了。此时组数为 $1$，这一整组的大房间是一个环而非一个连续的段，最优分配应该为大房间总数直接除以 $2$，这里不能先加 $1$。所以基于这一点！需要特判一下，否则起码第二组捆绑数据点你就全WA了。

参考代码（明显的 $O(n)$ 时间复杂度）：
```cpp
#include<iostream>
#define ll long long
using namespace std;
const int N=2.5e5+5;

int n,h0[N];
ll c[N],ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i];
		ans+=c[i];//第一步：累加每个大房间分出的小房间数
	}
	int cnt=1;
	//第二步：将剩余没有分出小房间的大房间分组 
	for(int i=1;i<=n;i++)
		if(!c[i]) h0[cnt]++; 
		else
		{
			while(c[i]) i++;//while循环一次性跳过所有c[i]不为0的大房间 
			cnt++;
			i--;//别忘i--，外层循环在执行完此步后又会i++ 
		}
	if(cnt==1) ans+=h0[1]/2;//特判丝毫没有小房间的情况 
	else
	{
	    h0[1]+=h0[cnt];//此步非常关键，将首尾合并
		/*若c[n]为0，cnt为组数，需要将h0[cnt]归为h0[1]，并且下面的循环不会遍历到h0[cnt] 
		若c[n]不为0，cnt会比组数多1，此时h0[cnt]为默认数值0，对h0[1]没有影响，
		所以此处可以不写分支结构判断c[n]，直接浓缩成上面1行的语句*/
	    for(int i=1;i<cnt;i++)
		    ans+=(h0[i]+1)/2;
    }
	cout<<ans;
	return 0;
}
```

---


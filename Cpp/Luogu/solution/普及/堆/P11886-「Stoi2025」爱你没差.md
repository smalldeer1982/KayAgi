# 「Stoi2025」爱你没差

## 题目背景

![](bilibili:BV1fx411N7bU?page=147)

## 题目描述

给定正整数 $n,m$ 和一个非负整数序列 $a_1,a_2,\dots,a_n$，每次可以选取其中两个数 $x,y$，去掉它们并往序列中加入 $x+y$，若有 $m \cdot x \ge y$ 且 $m \cdot y \ge x$，则得一分。求将全部数合并成一个数得分的最大可能值。

## 说明/提示

#### 样例解释

先选择 $1,2$，序列变为 $3,3$，再选择 $3,3$，序列变为 $6$，此时得分为 $2$。

若先选择 $2,3$，则得分为 $1$。

#### 数据范围与限制

对于 $20\%$ 的数据，满足 $n\le10$。

对于 $60\%$ 的数据，满足 $n\le10^3$。

对于所有数据，满足 $1\le n\le10^6$，$2\le m\le10$，$0\le a_i<2^{64}$，$\sum a_i<2^{64}$。

## 样例 #1

### 输入

```
3 2
1 2 3
```

### 输出

```
2
```

# 题解

## 作者：VinstaG173 (赞：13)

简单贪心，预估难度普及。

根据样例中的情形，猜测可以优先合并较小数。事实上容易发现若每次操作合并当前最小的两个数，当且仅当最小的 $k$ 个数之和 $S_k$ 与第 $k+1$ 小的数 $a_{k+1}$ 间满足 $mS_k<a_{k+1}$ 时不得分，且容易证明这是不得分的最少可能次数。

用小根堆维护即可做到 $O(n\log n)$。

---

upd 2025.3.16

看大家讨论度这么高，交的题解还几乎没有正确的证明，看来这篇题解还是写得太不够详细了。简单地把证明写好一点。

不妨假设原序列从小到大排序，$S_k=a_1+\dots+a_k$。若 $m\cdot S_k<a_{k+1}$，则一定存在一次合并，较小的数 $x\le S_k$，较大的数 $y\ge a_{k+1}$，这时必然不得分。显然对于不同的满足以上条件的 $k$，对应的合并是不同的。

然后在上述贪心过程中，当出现不得分的情况时，由 $m\cdot x<y$ 且 $m\ge2$，显然 $y$ 不可能由合并得来，否则合并成 $y$ 的两个数中至少有一个大于 $x$，不可能在 $x$ 合并之前被合并。因此 $y$ 必然是原先的某个 $a_{k+1}$，从而 $a_{k+2},\dots,a_n$ 都没有被合并。更强地，由以上的讨论，此时所有 $>m\cdot x$ 的数都不可能是合并得来的结果。则此时的 $x$ 只可能是 $a_1,\dots,a_k$ 中所有数合并的结果，即 $S_k$。

由以上证明其实我们发现可以直接排序后求出使得 $S_k<a_{k+1}$ 的 $k$ 的数量。但是时间复杂度瓶颈同样为 $O(n\log n)$，给出的序列已经排好序显得过于别有用心（误）。而且贪心更加容易猜测，作为 IOI 赛制题目难度会降低很多。

另外关于 `__int128`，你说的对，但是如果古老的机子除了 64 位整数就得写高精怎么办呢？std 的实现本身就没有使用 `__int128`，但是不可能卡。以下给出 std 的实现方法：

```cpp
		x=q.top();q.pop();
		y=q.top();q.pop();
		if(y==0||x>(y-1)/m)++sum;
		q.push(x+y);
```

---

## 作者：liuhaoyan0323 (赞：3)

思维题？

## 思路

首先我们将给的 $2$ 个式子变形，得到 $m \ge \frac{x}{y}$ 且 $m \ge \frac{y}{x}$ 时才能计分。显然若想成功得分，应保证 $x$ 和 $y$ 尽量接近。

现在，有 $2$ 种情况，取两个最小数或两个最大数进行合并（两数最接近的两种极端情况）。我们分类讨论：

- 取最大数，显然最后剩的两个数是原数列中的最小数和其余数之和，明显不是最优。
- 取最小数，显然最后剩的两个数是原数列中的最大数和其余数之和，优于其他情况。

所以我们每次取数列中最小的两个数合并，可以证明这是最优方案。\
考虑用堆维护取数这一过程。

注意本题毒瘤的数据范围：

- 对于所有数据，满足 $1\le n\le10^6$，$2\le m\le10$，$0\le a_i<2^{64}$，$\sum a_i<2^{64}$。

我们分析数据范围：

- 合并的数不会越界（$\sum a_i<2^{64}$）；

- 判断计分方式 $m \cdot x \ge y$（这里注意，若设每次取得最小两数中 $x < y$，则 $y \cdot m \ge x$ 必然满足），很明显炸 `unsigned long long` 了，此时一个越界数显然满足条件。

**溢出处理**：在判断条件 $m \cdot x \ge y$ 时，先检查 $x$ 是否会导致乘法溢出。如果溢出，则直接认为条件成立，否则进行正常计算。

综上所述，代码就很好写了。

## 代码

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
priority_queue<int,vector<int>,greater<int> > que;
int n,m,x;
inline void read(int &num){
    num=0;
    char ch=getchar();
    while (ch<'0'||ch>'9')ch=getchar();
    while (ch>='0'&&ch<='9'){
        num=num*10+(ch-'0');
        ch=getchar();
    }
}
signed main() {
    read(n);
    read(m);
    for(int i=1;i<=n;++i) {
        read(x);
        que.push(x);
    }
    int ans=0;
    while(que.size()>1){
        int x=que.top();
		que.pop();
        int y=que.top();
		que.pop();
        // 判断 m*x >= y，处理溢出
        if(x>ULLONG_MAX/m||x*m>=y){
            ++ans;
        }
        que.push(x + y);
    }
    printf("%llu", ans);
    return 0;
}
```

---

## 作者：xiaoqimingbozai (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11886)

看到题目不难想到对于每一个 $x$，$y$ 分 $3$ 种可能：

 1. $x=y$ 此时显然满足 $x⋅m\ge y$ 且 $y⋅m\ge x$
 2. $x<y$ 只要满足 $x⋅m\ge y$ 即可
 3. $y>x$ 同理

不妨设 $x<y$ 要使得最后 $x⋅m>=y$ 的数最多，可以使用贪心算法实现。

设 $x$ 为当前队列的最小值 $y$ 为次小值，若 $x⋅m<y$ 则 $x$ 永远不可能产生贡献。

但是，我们可以让 $x$ 去造福 $y$，使得 $y=y+x$ 然后 $y$ 产生贡献的可能就更大了。

感觉证明很扯？来看几个图，

![](https://cdn.luogu.com.cn/upload/image_hosting/kgu1ew8j.png)

其中z指的就是把 $x+y$ 压入队中后再取出的最小值，这里的 $x+y$ 去产生贡献就更有可能了。

![](https://cdn.luogu.com.cn/upload/image_hosting/54kn6k4q.png)

这里的 $x+y$ 就无所谓了，毕竟 $m\ge 2$，所以 $x+y<y⋅m$。况且 $z$ 还小于 $y⋅m$，因为 $(x+y)⋅m>y⋅m $，所以 $(x+y)⋅m>z$。

![](https://cdn.luogu.com.cn/upload/image_hosting/713p0b17.png)

因为 $z>y$ 所以 $z⋅m>y⋅m$ 又因为 $x+y<y⋅m$ 所以 $z⋅m>x+y$。

以上情况，把 $x+y$ 压入队都使得 $x+y$ 产生贡献的可能性更大。

对于$x⋅m\ge y$ 的，可以直接产生贡献，直接累加答案即可。

综上，这是一个正确的贪心策略。

以上过程可以用小根堆实现，然后你就开心的打了代码。

然后发现只得了 $20$ 分，于是你去看了数据规模。发现 $a_i<2^{64}$ 要使用 `unsigned long long`，并且 $m\le 10$，乘 $m$ 时有可能爆。

于是你把 $x⋅m\ge y$ 改成了 $x\ge \frac{y}{m}$， 就过掉了此题。

写的时候注意 $\frac{y}{m}$ 的类型！

[AC代码](https://www.luogu.com.cn/article/9tf8dvne)

蒟蒻第一次写题解，各位大佬多多指教。

---

## 作者：yihang2011 (赞：2)

## [P11886 「Stoi2025」爱你没差](https://www.luogu.com.cn/problem/P11886)

这题能评上黄主要是因为它坑，而坑点主要集中在数据范围身上。

**省流：开 `__int128_t`**

思路官方题解写的很清楚就不再多说了。

首先可以看到 $0 \le a_{i} < 2^{64}$，然后我就开 `long long`，卒；

发现 `long long` 最大为 $2^{63} - 1$，$2^{64} - 1$ 显然装不下，于是我就开了 `unsigned long long`，卒；

又发现 $2 \le m \le 10$，由于 `unsigned long long` 最大为 $2^{64} - 1$，$m \cdot x$ 与 $m \cdot y$ 的最大值为 $10(2^{64} - 1) \approx 1.845 \times 10^{20}$，`unsigned long long` 同样装不下，于是就有了 `__int128_t`，不过由于 `__int128_t` 无法直接输入输出，运算时强制转换一下就行了。

小根堆定义为 `priority_queue<unsigned long long, vector<unsigned long long>, greater<unsigned long long>> q;`。

代码如下：

```cpp
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;

priority_queue<unsigned long long, vector<unsigned long long>, greater<unsigned long long>> q;
int n, m;

int main() {
    cin >> n >> m;
    for (unsigned long long i = 1, x; i <= n; i++) {
        cin >> x;
        q.push(x);
    }
    int ans = 0;
    while (q.size() > 1) {
        unsigned long long x = q.top(); q.pop();
        unsigned long long y = q.top(); q.pop();
        if (m * (__int128_t)x >= y && m * (__int128_t)y >= x) {
            ans++;
        }
        q.push(x + y);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：yaoshuen (赞：1)

直入主题，注意条件 $m \times x \geq y$ 和 $m \times y \geq x$ （以下简称条件一和条件二），不妨设 $x \leq y$ 。条件二是必定满足的，考虑条件一。

如果 $x$ 不能满足条件一，那么说明 $x$ “小了”，我们希望 $x$ 大“一点点”再来合并，也就是将 $x$ 加上大于等于 $x$ 的最小数。

于是就有了贪心思路。

**维护一个小根堆，每次取出顶部的两个数合并，判断能否得分即可。**

能否先合并大的数？

**不能**

如果先合并大的，那么大的数将变得更大，对于其他较小数也就更难得分，因此相较先合并小数更劣。

又有人可能会问：主播主播，如果 $x$ “小了”，能否不增大 $x$ ，而增大一个比 $x$ 更小的数，然后让那个增大的数和 $x$ 合并？ 

**不能**

因为我们使用小根堆维护，最先取出的两个数必定是最小的，因此不存在上述问题。


---


### 注意事项

由于数据范围过大，直接判断 $m \times x \geq y$ 可能会在 $m \times x$ 处超过 ```unsigned long long``` 的范围，因此建议强制转换浮点型并判断等价条件 $x \geq \frac{y}{m}$ 

### 参考代码


```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
inline int read(){
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}
int n,m,x,y,s=0;
priority_queue<int,vector<int>,greater<int> >q;
signed main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		q.push(read());
	}
	while(q.size()>1){
		x=q.top();
		q.pop();
		y=q.top();
		q.pop();
		if(x>=y*1.0/m&&y>=x*1.0/m){
			s++;
		}
		q.push(x+y);
	}
	printf("%llu\n",s);
	return 0;
}

```

---

## 作者：_MiyazonoKaori_ (赞：1)

### 一些闲话：
赛时调了好久都没想出来是 `long long` 爆了，然后 @[yuruilin2026](https://www.luogu.com.cn/user/1294410) 和 @[Hootime](https://www.luogu.com.cn/user/1275540) 两个神犇一眼秒了。  
还有就是这个贪心结论在赛时是猜的。
### 正文：
#### 思路：
一个比较简单的贪心，思路大概就是每次选取这个序列中最小值合并，但是用数组排序肯定会爆，所以使用小根堆或单调队列维护。  
关于贪心的正确性证明，如果先把一个数组排好序的话，会有很多种情况，如：
$$\left \{ a_1,a_2 \right \}\left \{ a_3,a_4 \right \}\left \{ a_5,a_6 \right \} $$
$$a_1,\left \{ a_2,a_3 \right \}\left \{ a_4,a_5 \right \},a_6 (a_1,a_6合并)$$
$$\left \{ a_1,a_2 \right \}a_3\left \{ a_4,a_5 \right \}a_6 (a_3,a_6合并)$$
$$\dots$$

那么总结下来所有情况可分为两种，一种是前面全部连起来合并，一种是拆两个单独的数来合并，下面是总结的两种情况：  
$$\left \{ a_1,a_2 \right \}\left \{ a_3,a_4 \right \}\left \{ a_5,a_6 \right \} $$
$$a_1,\left \{ a_2,a_3 \right \}\left \{ a_4,a_5 \right \},a_6 (a_1,a_6合并)$$
我们假设有一个 $m$ 使得 $a_1,a_2$ 合并不能得分，$a_2,a_3$ 合并能得分，那么 $a_1+a_2$ 肯定可以和后面的 $a_3$ 到 $a_6$ 或后面合并后的数合并，那么就可以得到这两种方式的得分其实是相同的。  
同理，其他拆散再合并的情况也是一样的，与连起来合并的价值一样，所以就可以按每次选取这个序列中最小值合并。
#### 代码：
因为 $0\le a_i<2^{64}$ 这刚好是 `long long` 的范围，所以判断的时候不能直接用 `m*x>=y&&m*y>=x` 的格式，而是需要改用除法或使用 `__int128` 存储，下面是 $\mathfrak{AC}$ 代码：

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define fast_gets ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define open_f_same freopen("data.in", "r", stdin);freopen("data.out", "w", stdout);
#define close_f fclose(stdin);fclose(stdout);
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)){
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (isdigit(ch)){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
inline void write(int x){
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
int main() {
    int n, m;
    cin >> n >> m;
    
    priority_queue<long double, vector<long double>, greater<long double>> pq;
    vector<long double> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        pq.push(a[i]);
    }
    if(n==0){
        cout<<0;
        return 0;
    }
    if(m==0){
        cout<<n-1;
        return 0;
    }
    int score = 0;
    while (pq.size() > 1) {
        long double x = pq.top();
        pq.pop();
        long double y = pq.top();
        pq.pop();
        if (x >= y/m && y >= x/m) {
            score++;
        }
        pq.push(x + y);
    }
    cout << score << endl;
    
    return 0;
}
```
马蜂可能有些神经，但还是能看吧。

---

## 作者：FZY_CZY (赞：1)

# 题意
[题目](https://www.luogu.com.cn/problem/P11886) 是这个←。

意思很简单，就是不断在一个序列里面挑选两个数，然后尽量使得这两个数 $x,y$ 满足 $m\cdot x\ge y$ 且 $m\cdot y\ge x$，然后将这两个数删除，将他们的和加到序列里面。

求在整个“删”和“加”的过程中，满足条件的 $x,y$ 的个数。
# 思路
其实这道题的思路很好想，甚至可以直接就猜出来。

我们维护一个升序的序列，每次取出最小的两个数，如果他们满足条件，则答案加一，然后将他们的和添加到序列里面。

我们来看一下为什么是对的，也就是为什么我们每次取最小的两个数一定是最优的。

假设这个序列是 $a$，每次我们取出 $a_1,a_2$，那我们为什么不能取出 $a_2,a_3$ 或者其他两个数呢？因为我们发现，如果 $a_1,a_2$ 不满足条件，就意味着 $a_1$ 与任何数在一起都无法满足条件了，为了使我们的得分尽可能的大，所以我们无脑选择 $a_1,a_2$ 合并一定是不劣的。
# 代码
维护一个升序的序列我们很自然的想到用优先队列（堆），没学过的看 [堆（模板题）](https://www.luogu.com.cn/problem/P3378)
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
priority_queue<ULL,vector<ULL>,greater<ULL>> q;
int n,m;
int ans;
ULL x;
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++)
    {
        ULL x;
        scanf("%llu",&x);
        q.push(x);
    }
    while (q.size()>1)
    {
        ULL x=q.top();
        q.pop();
        ULL y=q.top();
        q.pop();
        //取两个最小的数
        if ((__int128_t)m*(__int128_t)x>=(__int128_t)y&&(__int128_t)m*(__int128_t)y>=(__int128_t)x)
            ans++;
        q.push(x+y);
    }
    cout<<ans;
    return 0;
}
``````
在我的代码中，你们是不是还发现了一个细节，就是`unsigned long long`和`__int 128_t`，我们可以仔细看一下数据范围，就可以发现如果只有`long long`或者只有`unsigned long long`是不够的，因为 $m\le10,a_i<2^{64}$，所以这也是一个细节。

---

## 作者：__CJY__ (赞：1)

## 思路
当合并两个数 $x$ 和 $y$ 时，若满足 $m \times x\ge y$ 且 $m \times y \ge x$ 则得分，这表明 $x$ 和 $y$ 的比值需在 $\frac{1}{m} \sim m$ 范围内。所以可以得出一个结论：较小的数更容易满足该条件，因为它们的比值更接近 $1$。

我们‌每次合并当前最小的两个数‌，这样做的优点是：
* 较小的数之间比值更接近，更容易满足条件。
* 合并后的数可能仍较小，为后续合并保留满足条件的可能。

我们可以用优先队列（`priority_queue`）实现，因为它的队首元素始终是最小的。

结果可能会溢出 `unsigned long long` 的范围，所以要用 `__int128`。
## Code
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
priority_queue<ull,vector<ull>,greater<ull>>q;
ull n,m,ans;
int main(){
	cin>>n>>m;
	for(ull i=1,x;i<=n;i++) cin>>x,q.push(x);
	while(q.size()>1){
		ull x=q.top();q.pop();
		ull y=q.top();q.pop();
		if(m*(__int128)x>=y&&m*(__int128)y>=x) ans++;
		q.push(x+y);
	}
	cout<<ans;
}
```

---

## 作者：wrh316 (赞：1)

### 思路
根据样例提示，我们发现：贪心策略为每次合并当前最小的两个数，以确保后续的数尽可能大，从而在后续合并中更容易满足得分条件。

用小根堆维护，每次堆操作的时间复杂度为 $O(\operatorname{log} n)$，总共有 $n - 1$ 次合并操作，总时间复杂度为 $O(n \operatorname{log} n)$。

注意：不开 `__int128` 见祖宗。

### 代码
```c++
#include <bits/stdc++.h>
#define int __int128
using namespace std;

int n, m, ans;
priority_queue<int, vector<int>, greater<>> q;
int read() {
	char array[105];
	cin >> array;
	int ans = 0;
	int cnt = 1;
	if (array[0] == '-') {
		cnt = -1;
		for (int i = 1; i < strlen(array); i++) ans = ans * 10 + (array[i] - '0');
	} else {
		for (int i = 0; i < strlen(array); i++) ans = ans * 10 + (array[i] - '0');
	}
	return ans * cnt;
}
void print(int num) {
	if (num < 0) {
		putchar('-');
		print(-num);
	} else if (num > 9) {
		print(num / 10);
		putchar(num % 10 + '0');
	} else putchar(num + '0');
	return ;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	n = read();
    m = read();
	for (int i = 0, x; i < n; i++) {
		x = read();
		q.push(x);
	}
	while (q.size() > 1) {
		int x = q.top(); q.pop();
		int y = q.top(); q.pop();
		if (m * x >= y && m * y >= x) ans++;
		q.push(x + y);
	}
	print(ans);
	return 0;
}
```

[AC 记录~~不放了~~](https://www.luogu.com.cn/record/207950515)

---

## 作者：wangliu (赞：1)

# P11886 爱你没差
[题目传送门](https://www.luogu.com.cn/problem/P11886)

## 题目大意

给定有 $n$ 个正整数的序列，每次从中选出两个 $x,y$ 正整数，若有 $m \cdot x \ge y$ 且 $m \cdot y \ge x$，则得一分，然后把 $a+b$ 加回到序列中，求出分数的最大值。

## 题目思路

容易想到贪心，每次选取最小的两个数，经过 $n-1$ 次操作后所得分数即为答案。

简单证明一下：首先我们可以把序列划分为3个子序列，每个子序列中继续三分，这道题的情况可以被简化为仅有两个或三个数，两个数只能进行合并，然后对三个数进行讨论，设三个正整数 $x,y,z$，满足 $x \le y \le z$。

- 如果满足 $m \cdot x \ge y$ 且 $ m \cdot x + m \cdot y \ge z$，此时最优解为 $2$。如果选择 $x,z$ 就不一定得到两分。
- 如果满足 $m \cdot x \ge y$ 且 $ m \cdot x + m \cdot y < z$，此时最优解为 $1$。如果选择 $x,z$ 只能得 $0$ 分。
- 如果满足 $m \cdot x < y$ 且 $ m \cdot x + m \cdot y \ge z$，此时最优解为 $1$。如果选择 $x,z$ 可能得 $0$ 分。
- 其他情况无论如何操作均无法得分。

综上，每次贪心选取最小的两个数合并就能得到最优解，用优先队列维护序列，经过 $n-1$ 次操作能得到答案。

```cpp
//洛谷非常重视学术诚信。抄袭、复制题解，以达到刷 AC 率/AC 数量或其他目的的行为，在洛谷是严格禁止的，这将会导致您成为作弊者。
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> > shu;//用优先队列维护序列，快速查询最小值
int n,m,ans;
int main(){
	n=read();m=read();//快读
	for(int i=1;i<=n;i++) shu.push(read());
	while(shu.size()>1){
		int a=shu.top();shu.pop();
		int b=shu.top();shu.pop();
		if(a*m>=b) ans++;//a一定小于b，b*m>=a恒成立
		shu.push(a+b);
	}
	print(ans);//快写
	return 0;
}
```

时间复杂度 $O(n \log n)$，足以通过本题。

~~然后你就拿了 $20$ 分，开始自我怀疑。~~

其实贪心思路没有问题，但是数据有点巧妙，$0\le a_i<2^{64}$。

乍一看以为要开 ```unsigned long long``` 防止溢出，实际上在做判断时 $m \cdot a_i$ 就已经溢出了，然后喜提 $20$ 分。[link](https://www.luogu.com.cn/record/207937942)

可以选择 ```__int128``` 防止溢出，然后写个快读快写函数就过了，其实也可以取模判断 ~~但是懒得写~~。

---

## 作者：tuntunQwQ (赞：1)

目标是使得分最大，每次可以先考虑当前序列中最小的数，显然令它和第二小的数合并最优。用优先队列维护当前序列，每次将最小和次小的数合并。注意判断 $m⋅x$ 是否 $≥y$ 时，$m⋅x$ 会超过 $2^{64}-1$，需要在计算时转换为 `__int128` 类型。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,m,a,cnt;priority_queue<unsigned long long,vector<unsigned long long>,greater<unsigned long long> > q;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a,q.push(a);
	for(int i=1;i<n;i++){
		unsigned long long x=q.top();
		q.pop();
		unsigned long long y=q.top();
		q.pop();
		if(m*(__int128)x>=y)cnt++;
		q.push(x+y);
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

# P11886 「Stoi2025」爱你没差 题解  
一道并不怎么难但赛时坑人的题。  
为表示方便，本文下面形如 $ab$ 皆意为 $a \times b$。
### 解题思路  
首先先说结论，每次贪心合并最小的两个数，并进行判断和累加，用小根堆即 `priority_queue` 维护就可以。既然出题人说比赛不卡常，那 $\mathcal O(n \log n)$ 完全可以接受。  
### 正确性证明  
可以发现，题目中“加分”所要满足的条件是对称性的，所以当两个数 $x \le y$ 且 $mx \ge y$ 时，就一定可以，这个显然，不做证明。  
接下来，题目中合并后会变成 $x+y$。那么我们考虑一种情况 $x \le y \le z$，如样例，感性理解，如果先对 $y$ 和 $z$ 操作，合并后的 $y+z$ 会远离 $x$ 从而更难实现“加分”。考虑先 $x+y$ 和 $x+z$ 比较的再严谨一些的方法，分类讨论先 $x+y$ 的情况：  
1.    先合并 $x$ 和 $y$ 时两次合并没分，即 $mx < y$，且 $(x+y)m < z$。因为 $m \ge 2$，所以显然不可能 $zm < x+y$。  
不妨设 $y=mx+1$，$z=m(x+y)+1=m^2x+mx+m+1$。这时候 $x+z=m^2x+mx+m+x+1$，$my=m^2x+m$，相减可得 $mx+x+1$。$\because m \ge 2,x \ge 1$，$\therefore x+z>my$，故两次合并也均不得分，先合并 $x$ 和 $y$ 不劣。  
2.    合并 $x$ 和 $y$ 有分，合并 $x+y$ 和 $z$ 时没分。  
不妨设 $y=x$，$z=m(x+y)+1=2mx+1$。先合并 $x$ 和 $z$ 时 $mx<z=2mx+1$，$my=mx<x+z=2mx+x+1$，故两次合并也均不得分。  
严谨一些，再设 $y=mx-1$，$z=m(x+y)+1=m^2x+mx-m+1$。先合并 $x$ 和 $z$ 时 $mx$ 和 $z$、$my$ 和 $x+y$ 当且仅当 $x=0$、$y \ne 0$ 且 $m$ 足够大时，$mx \ge z$ 或 $my \ge x+z$，但 $mx>0$，所以上述情况不可能，故两次合并也均不得分，所以先合并 $x$ 和 $y$ 不劣。  
3.    合并 $x$ 和 $y$ 没分，合并合并 $x+y$ 和 $z$ 时有分。
不妨设 $y=mx+1$，$z=m(x+y)-1=m^2x+mx+m-1$。先合并 $x$ 和 $z$ 时 $mx<z=m^2x+mx+m-1$，$my$ 和 $x+z$ 不确定，最多一分。
同样在严谨一些，设 $y=mx+1$，$z=x+y=mx+x+1$。先合并 $x$ 和 $z$ 时 $mx<z=mx+x+1$，$my=mx+1<x+z=mx+2x+1$，所以两次都不得分，故先合并 $x$ 和 $y$ 不劣。
4.    先合并 $x$ 和 $y$ 时两次合并都有分，你不可能更多分了，所以不劣。

对于“不妨设”的解释，可以简单知道 $\ge$ 的判定是单向的，所以我们大部分的取值都取一个极限，要么最大，要么最小。对于 $z$，我们要得分就尽量要在满足条件下尽量的小。$y$ 一些情况下不确定，所以两端极值都取。准确一点，在两端情况下通过上述的分析，也能看出，取值的效果对计分的影响是单调的。

把上述结论推广，综上，该策略应该正确。  

关于推广的证明：合并出来的数是固定的，当推广时想象成对于几个区间的上述贪心，而各区间的贪心的后效唯一，可以证明在使用该贪心策略下合并的后效性一定不劣。

### 注意事项  
$0 \le a_i \le 2^{64}$，要开 `__int128`。

### AC 代码  

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
typedef __int128 ll;
__int128 read(){
	__int128 res=0;
	char scan[1005];
	scanf("%s",scan);
	int idx=(scan[0]=='-'?1:0);
	for(int i=idx;i<strlen(scan);i++){
		res*=10;
		if(idx==1)res-=scan[i]-'0';
		else res+=scan[i]-'0';
	}
	return res;
}
priority_queue<ll,vector<ll>,greater<ll>> q;
ll n,m,k;
int ans;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		k=read();
		q.push(k);
	}
	for(int i=1;i<n;i++){
		ll x=q.top();
		q.pop();
		ll y=q.top();
		q.pop();
		if(x*m>=y) ans++;
		q.push(x+y);
		//cout<<x<<" "<<y<<endl;
	}
	cout<<ans;
}
```

欢迎指出文中问题。

---

## 作者：fish_love_cat (赞：0)

Upd：证明有锅，来改了来改了。另外的怎么和官方的证明不太一样（？）

---

首先想到贪心。

我们猜测可以让最小的两个数优先合并。怎么证明呢？

显然此时产生贡献直接合是不劣的。那么如果合并无贡献时还有合的必要吗？

注意到此时合成的两个数必然满足 $a<\frac{b}{m}$，所以合进去不会对 $b$ 下一步的合成造成负面影响。相反 $b$ 由于增大，而此时它又是最小值，合进去甚至可能有帮助。如果合进去后 $b$ 排位有了改变那么事实上序列差距很小所以也是不会影响答案的。

所以这是对的。

那么直接优先队列糊上去就行了。

`long long` 甚至 `unsigned long long` 都是过不了的，必须 `__int128`，场上硬控某人 0.5h 不说是谁。

```cpp
#include<bits/stdc++.h>
#define int unsigned __int128
using namespace std;
long long ans;
priority_queue<int,vector<int>,greater<int> >q;
signed main(){
    long long n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        long long x;
        cin>>x;
        q.push(x);
    }
    for(int i=1;i<n;i++){
        int a,b;
        a=q.top();
        q.pop();
        b=q.top();
        q.pop();
        if(m*a>=b)ans++;
        q.push(a+b);
    }
    cout<<ans;
    return 0;
}
```

建议橙或黄。

---


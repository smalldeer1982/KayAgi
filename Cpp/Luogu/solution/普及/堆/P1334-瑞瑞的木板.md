# 瑞瑞的木板

## 题目背景

瑞瑞想要亲自修复在他的一个小牧场周围的围栏。

## 题目描述

他测量栅栏并发现他需要 $n$ 根木板，每根的长度为整数 $l_i$。于是，他买了一根足够长的木板，长度为所需的 $n$ 根木板的长度的总和，他决定将这根木板切成所需的 $n$ 根木板（瑞瑞在切割木板时不会产生木屑，不需考虑切割时损耗的长度)。

瑞瑞切割木板时使用的是一种特殊的方式，这种方式在将一根长度为 $x$ 的木板切为两根时，需要消耗 $x$ 个单位的能量。瑞瑞拥有无尽的能量，但现在提倡节约能量，所以作为榜样，他决定尽可能节约能量。显然，总共需要切割 $(n-1)$ 次，问题是，每次应该怎么切呢？请编程计算最少需要消耗的能量总和。

## 说明/提示

#### 输入输出样例 1 解释

将长度为 $21$ 的木板，第一次切割为长度为 $8$ 和长度为 $13$ 的，消耗 $21$ 个单位的能量，第二次将长度为 $13$ 的木板切割为长度为 $5$ 和 $8$ 的，消耗 $13$ 个单位的能量，共消耗 $34$ 个单位的能量，是消耗能量最小的方案。

----

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\le n \le 2 \times 10^4$，$1 \leq l_i \leq 5 \times 10^4$。

## 样例 #1

### 输入

```
3
8
5
8
```

### 输出

```
34
```

# 题解

## 作者：Jyf624761709 (赞：55)

相信许多人都已经知道了这道题就是合并果子，但是还不知道它是怎样转化成合并果子的，我觉得楼下的dalao们都讲的不太清楚，这里我给大家举个例子：

比如说9 7 6 5 3,有些同学可能会想：每次我砍最大的，然后剩下的不就少了。其实不然，因为不一定一次只能砍一个，可以砍两个或两个以上。不多说，我把上面例子的最优策略讲出来大概就知道了。

step1：把9+7+6+5+3切成7+6和5+3+9两部分；  
step2：把7+6切成7和6；  
step3：把5+3+9切成5+3和9两部分：  
step4：把5+3切成5和3。

这时我们再回过头来看，是不是就是合并果子的步骤？

代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
typedef long long ll;
priority_queue<ll,vector<ll>,greater<ll> > a;//这里直接调用优先队列
#define in(t) freopen("t.in","r",stdin)
#define out(t) freopen("t.out","w",stdout)
#define m(a) memset(a,0,sizeof(a))
int main(){
    long long ans=0,n,t;//ans注意要开long long,不然会爆
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&t);
        a.push(t);
    }
    for(int i=1;i<=n-1;i++){
        int c,d;
        c=a.top();
        a.pop();
        d=a.top();
        a.pop();//每次取最小的两个数
        ans+=c+d;//加上能量
        a.push(c+d);
}//和合并果子一样，具体可以参考合并果子题解
    printf("%lld",ans);

    return 0;

}
```


---

## 作者：TESJackeyLove (赞：30)

**从题目中我们可以知道，每次是把一块木板无损锯成两块，花费的代价就是这个木板的长度，那么需要N块木板的话就需要锯N-1次，所以我们的目的就是去求这N-1步代价的最小值了。**
- 我们可以通过画图的方式更加清晰明了的去了解这个步骤，如下图：假设我们最终需要的是c，e，f，g这四块木板，那么我们通过N-1次（3次）切割：  
第一步：a->b+c，代价是a  
第二步：b->d+e，代价是b   
第三步：d->f+g，代价是d   
那么我们的总代价就是a+b+d了。  
但是题目好像并没有给我们a，b，d的值，只给了我们c，e，f，g的值。ok，那我们把它转化一下：  
a+b+d  
=(b+c)+b+d  
=2b+c+d  
=2(d+e)+c+d  
=3d+2e+c  
=3(f+g)+2e+c  
![](https://cdn.luogu.com.cn/upload/image_hosting/ws6kug3d.png)
- 现在总代价就由f，g，e，c这些最终的木板长度表示了，我们可以发现，有的木板只加了一次，有的加了两次，有的加了三次，因为这里N=4，N-1次也就是3次就可以完成了，那么当N增大的时候，会有些木板被加4次，5次甚至更多，最多的会被加N-1次，那么我们想要总代价最小，肯定要使小的数加的次数多，大的数加的次数小了。这里一块模板锯成两块，我们可以反过来看，两块木板合成一块木板，代价也是这个木板的长度，那么我们每次就可以选择最小的两块去合并就可以了（似乎好像现在和合并果子那题一样了）。
![](https://cdn.luogu.com.cn/upload/image_hosting/u3ot84ie.png)
- 既然涉及到大小，那么肯定和排序有关，当然你可以写一个数字，每次操作都排序一下，可以但是没必要。我们可以用优先队列来做，优先队列priority_queue <type> q的写法（这里的type是数据类型，自己代入类型即可）是默认从大到小的，其实它的完整写法是这样的：priority_queue<type,vector<type>,less<type> > q，那么要怎么改呢?把后面的less（意思为更小的，降序）改为greater（意思为更大的，升序）即可，priority_queue<type,vector<type>,greater<type> > q就是从大到小优先级的优先队列。
- 至此，思路就很明确了，我们每次从队头拿出两个元素进行合并，用一个变量tmp记录下当前这一次合并的代价，再用一个变量ans把每次的代价都加起来，然后我们把合并后的元素再加到队列里去，优先队列会自动排好序，那么我们一直重复操作直到队列大小为1，就合并完了。还是一样，开long long！以下是蒟蒻的代码：
  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<algorithm>
  #include<cstring>
  #include<cstdlib>
  #include<queue>
  #include<stack>
  #define fore(i,a,b) for(int i=a;i<=b;i++)
  #define ford(i,a,b) for(int i=a;i>=b;i--)
  #define IGNB std::ios::sync_with_stdio(false);
  #define ll long long
  using namespace std;
  int main(){
      IGNB;
      priority_queue<ll,vector<ll>,greater<ll> > q;
      int n;
      cin>>n;
      ll t;
      fore(i,1,n){
          cin>>t;
          q.push(t);
      }
      ll ans=0,tmp=0,a=0,b=0;	
      while(q.size()>1){
          a=q.top();
          q.pop();
          b=q.top();
          q.pop();
          tmp=a+b;
          ans+=tmp;
          q.push(tmp);
      }
      cout<<ans<<endl;
      return 0;
  }

```


---

## 作者：zhangyuhan (赞：16)

# 瑞瑞的木板(拆分果子)

大家先去看看[这道题](https://www.luogu.org/problemnew/show/P1090)。

# 发现了什么？

~~什么都没有~~

观察发现，合并果子就是将一堆果子从小到大合并，运用了哈夫曼树的思想。

# 这题呢？

它是问你将一块木板不断拆分，既能拆成所有需要的长度，消耗能量也最少。

# 有什么关联？

首先，拆分的时候是先将所需要的最大的长度拆分出来，再继续拆剩下的，直到都拆分完毕，这样就是消耗能量最小的方案。

**是不是有点像了？**

再继续。

我们可以运用逆向思维，从最小的长度开始，不断合并第一个比它大的长度，将拆分的过程反过来推，消耗的能量跟正推也是一样的。

**SO？**

不就是合并果子裸题啰。

# 怎么实现？

如果你一个一个合并，再把合并后的长度放入原数组，再重新排序，不仅实现难度大，而且时间爆炸。

**怎么做？**

观察数据范围，$n≤10000$,$O(n^2)$都是玄学。

当然$O(n\log{n})$最有可能啰。

再观察解题思路，你会发现需要**不停地动态取最小值**。

加粗字让你想到了什么？

那不就是**堆**吗。

用小根堆来存储每次合并后的所需木板长度，每次直接从堆顶取出两个最小值，合并后再放入堆中，直到堆里只有一个元素。

时间复杂度完完美美$O(n\log{n})$。

$AC$ $Code$

```cpp
#include <iostream>
#include <queue>//STL是个好东西
using namespace std;

priority_queue<int, vector<int>, greater<int> > pq;//小根堆标准定义
int a[1000010],n;
long long ans;//注意最终答案会爆int!要用long long存！

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		pq.push(a[i]);
	}//输入+预处理
	for(int i=1;i<=n-1;i++){
		int a=pq.top();//取出最小元素
		pq.pop();
		int b=pq.top();//取出第二小元素
		pq.pop();
		ans+=a+b;//合并消耗的能量值累加
		pq.push(a+b);//合并后再放入堆中
	}
	cout<<ans<<endl;//输出
	return 0;//完结撒花！
}
```

---

## 作者：___new2zy___ (赞：7)

# 题解 P1334 【瑞瑞的木板】

题目传送门：：

https://www.luogu.org/problemnew/show/P1334

===========================================================**这题好水**================

就是合并果子吧= =一点没变= =

合并果子：：（类似题目）

https://www.luogu.org/problemnew/show/P1090

不多说废话，直接上解释：：

每次取两块长度最小的木板合并，所以让小的木板尽量多的合并，大的木板尽量少的合并，这样能做到小的木板对答案贡献多，大的木板贡献少的最优解

本题数据稍微大了一些，记得用**longlong或者I64d**

====================================================以下献上我丑陋的代码============


    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<queue>
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;
    inline int read()//拙劣的快读
    {
        int p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
        while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return f*p;}
    ll n,heap_size,Small_Heap[20005],ans;
    //Small_Heap小根堆
    void put_in(int k)//向堆中插入元素并调整
    {
        Small_Heap[++heap_size]=k;
        ll now=heap_size,next;
        while(now>1)
             {
                next=now/2;
                if(Small_Heap[next]<=Small_Heap[now])return ;
                swap(Small_Heap[next],Small_Heap[now]);
                now=next;   	
             }
    }
    ll insert_top()//取出堆顶并维护
    {
        ll now=1,next,rest=Small_Heap[1];
        Small_Heap[1]=Small_Heap[heap_size--];
        while(now*2<=heap_size)
              {
          	   next=now*2;
          	   if(next<heap_size&&Small_Heap[next]>Small_Heap[next+1])next++;
          	   if(Small_Heap[now]<=Small_Heap[next])break ;
          	   swap(Small_Heap[next],Small_Heap[now]);
          	   now=next;
              }
        return rest;
    }
    int main()
    {
	    //本题类似于合并果子，推荐两题一起做
	    n=read();
	    for(int i=1;i<=n;i++)
	        put_in(read());
	    for(int i=1;i<=n-1;i++)
	        {
	    	    ll x=insert_top();
	    	    ll y=insert_top();
	    	    put_in(x+y);
	    	    ans+=x+y;
		    }
        //每次取出两个最小的合并后放回
        //注意一共n-1次合并
	    printf("%lld",ans);
	    return 0;
    }


以上就是全部啦，没什么了= =

最后推广一下我的博客:
https://www.luogu.org/blog/new2zy/

拜拜~~~= =

---

## 作者：PrefixAMS (赞：5)

 相信大多数OIer都做过一道名为
 ## [合并果子](https://www.luogu.org/problem/P1090)
 的题
 
 就是拿到PQ入门题
 
 你可能会问  这两道题有什么关系
 
解释一下

```
合并果子

每次找最小的两堆合并在一起
PQ实现

本题

可以将锯成两半转化为合并

所以 

本质一样
```

n年前代码


```cpp
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
int main()
{
	priority_queue <int> a;
	int n,cmp,r=0;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		int x;
		cin>>x;
		a.push(-x);
	}
	for(int i=1;i<n;i++)
	{
		r-=a.top();
		cmp=a.top();
		a.pop();
		cmp+=a.top();
		r-=a.top();
		a.pop();
		a.push(cmp);
	}
	cout<<r;
	return 0;
    
    //防作弊
}
```

其实可以直接开小根堆的


# 开LL 开LL 开LL

~~十年OI一场空，不开LL见祖宗~~

---

## 作者：发源于 (赞：4)

[color=red]洋溢着笑容拍手称快[/color]

其实我的第一想法是维护一个最小值，还有一个除最小值外的小堆（根）

每次将最小和第二小取出相加放入小根堆，重新求最小放入最小值（删掉），再刷新小根堆

就是每次求最小和第二小，相加，存入累加器s

结果发现太烦了（懒得）

所以我干了件很没道德的事

直接把合并果子抄过来

把s改为int64，过了

这数据也太弱了吧

我的方法：维护一个数组，将前两个相加，然后向后进行插入排序

n^2左右

#[color=red]申明：我无法确定我第一个算法是不是正确的，因为我没写过[/color]

代码如下

```delphi

var
  a:array[1..100000] of longint;
  i,j,s,n,c:longint;
procedure qsort(l,r:longint);
var
begin
{快排略去}
end;
begin
  readln(n);
  for i:=1 to n do
    read(a[i]);
  qsort(1,n);
  s:=0;
 for i:=1 to n-1 do
    begin
      s:=a[i]+a[i+1]+s;
      a[i+1]:=a[i+1]+a[i];
      j:=i+1;
      while (a[j]>a[j+1]) and (a[j+1]<>0) do
        begin
          c:=a[j];
          a[j]:=a[j+1];
          a[j+1]:=c;
          inc(j);
        end;
    end;
  writeln(s);
end.

```
这是堆吗

<hr>
<hr>
经历了一个凶残的晚上，我终于把堆写出来了

算法就是上面的那个，但是细节伤不起啊

```delphi

var
  a,f:array[0..50001] of longint;//f是堆
  i,last,n,l,l1:longint;//last是堆尾
  sum:int64;//注意int64
function min(a,b:longint):longint;
begin
  if a<b then exit(a) else exit(b);
end;
procedure insert(num:longint);//插入
var
  i,t:longint;
begin
  inc(last);
  i:=last;
  f[i]:=num;
  while f[i]<f[i div 2] do
    begin
      t:=f[i]; f[i]:=f[i div 2]; f[i div 2]:=t;
      i:=i div 2;
    end;
end;
procedure del;//就是这个删除弄了我一个晚上
var
  i,t,q:longint;
begin
  f[1]:=f[last];
  f[last]:=0;
  dec(last);
  i:=1;
  while (min(f[i*2],f[i*2+1])<f[i])  do
    begin
      if f[i*2]<f[i*2+1] then q:=i*2 else q:=i*2+1;
      if f[q]=0 then if f[i*2]=0 then q:=i*2+1 else q:=i*2;//防越界
      {其实我本来是用i<last div 2的，后来发现不行，重新改成这个}
      if f[q]=0 then break;
      t:=f[i]; f[i]:=f[q]; f[q]:=t;
      i:=q;
    end;
end;
begin
  readln(n);
  last:=0;
  for i:=1 to n do
    begin
      readln(a[i]);
      insert(a[i]);
    end;
  l:=f[1];
  sum:=0;
  while last>1 do
    begin
      del;
      sum:=sum+l+f[1];
      l1:=l+f[1];
      del;
      insert(l1);
      l:=f[1];
    end;
  writeln(sum);
end.

```
不要问我为什么写堆，老师要求伤不起啊

[删除]管理员给个过吧，分数随便给，就算不加也行[/删除]


---

## 作者：Peter_Z (赞：3)

看到没有人用STL的push\_heap和pop\_heap，[delete]赶紧水一发[delete]

push\_heap在堆中插入一个节点并上浮。

pop\_heap将最顶端的节点弹出并将其他节点上浮。

对最小堆操作时要加greater<int>()。

Ps.tree[0]表示堆的大小，不必用新的变量来存。

代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long n,tree[20002],d,ans;    //基本的变量，记住要用longlong(或int64)
inline void insert(int d) {        //向堆中插入d 
    tree[0]++;
    tree[tree[0]]=d;
    push_heap(tree+1,tree+tree[0]+1,greater<int>());//小根堆 
}
inline void pop() {                //跳出一个数 
    pop_heap(tree+1,tree+tree[0]+1,greater<int>());
    tree[0]--;
}
int main() {
    std::ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0; i<n; i++) {
        cin>>d;            //输入并插入d 
        insert(d);
    }
    for(int i=0; i<n-1; i++) {    //两次跳出最小值后求出和再插入堆 
        int c1=tree[1];
        pop();
        int c2=tree[1];        //小根堆tree[1]表示最小数 
        pop();
        insert(c1+c2);
        ans+=c1+c2;            //将c1+c2累加到ans 
    }
    cout<<ans;        //输出ans 
    return 0;
}
```

---

## 作者：PTC06 (赞：3)

这题和1090类似，明白思路就很容易实现。

思路：

经典做法是用堆，但其实这题用multiset在操作和效果上都和堆差不多。

堆的pop,push这两个操作和set的erase,insert这两个操作基本是一样的效果。

那么如果会做堆的做法，就应该也会用multiset。

就是每次找出最小的两个，将他们的和存起来后将他们本身删掉，然后把他们的和加入multiset里面（相当于合并），再用ans加上他们的和。

最后输出ans。

程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,t,sumof12;
long long ans;
int main()
{
    cin>>n;
    multiset<int> s;
    for (i=1;i<=n;i++)
    {
        cin>>t;
        s.insert(t);
    }
    while (s.size()>1)
    {
        sumof12=*s.begin();
        s.erase(s.begin());
        sumof12+=*s.begin();
        s.erase(s.begin());
        s.insert(sumof12);
        ans+=sumof12;
    }
    cout<<ans;
}
```

---

## 作者：中2少年雷耶斯 (赞：3)

此题跟P1090差不多。P1090是合并，此题是分解，但是代码却一模一样。代码前面已经有很多dalao写了，我就来分析一下为什么这两个题的代码一模一样吧


假如你在P1090中用了一个数组P，在P1334中用了一个数组Q，设木板长（果子重量）的和是R，那么**Q数组储存着你的目标木板，当这里面只有一个数的时候，这就意味着你的目标只有一个——拥有一块长为R的木板，而题目中表示你一开始就有一块肠长为R的木板了，所以那个时候你就完成任务了。合并两块目标木板则意味着你的目标是拥有一块长度为这两块木板长之和的木板（因为你可以分解这块木板以获得这两块目标木板）。因为两题中能量的消耗都是消耗两块木板（两堆果子）的和，所以答案就一样了**


所以，虽然这两题代码一样，但是数组的意义是完全不一样的，各位dalao在Co那题代码的时候请思考思考@V@


顺便附上一个自己手打的小根堆结构体（大根堆就把大于小于换一下就行了）


```cpp
struct heap
{
    int num,yes[20001];  //堆的大小和朴素的堆
    heap(){num=0;for(int i=0;i<=20000;i++)yes[i]=0;} //初始化
    void in(int p) //入堆
    {
        num++;yes[num]=p;
        int now=num;
        while((now!=1)&&(yes[now]<yes[now/2]))
            {int swap=yes[now];yes[now]=yes[now/2];yes[now/2]=swap;now/=2;}
    }
    int out()  //出堆
    {
        int now=1,next=0,turn=yes[1];
        yes[1]=yes[num];num--;
        while(now*2<=num)
        {
            next=2*now;if(yes[next+1]<yes[next])next++;
            if(yes[now]<=yes[next])return turn;
            int swap=yes[now];yes[now]=yes[next];yes[next]=swap;
            now=next;
        }
        return turn;
    }
};
```
有了以上的结论和预备，这题的main函数就显得很精简了：
```cpp
iint main()
{
    heap t;  //一个漂亮的小根堆
    long long n,ans=0,x;cin>>n;  //用longlong保险一些（不知道int会不会炸）
    for(int i=1;i<=n;i++){cin>>x;t.in(x);}  //输入，入堆
    for(int i=1;i<=n-1;i++) //因为每一次分割都会让目标数组减少一个数，所以总共进行n-1次循环就好了
    {
        int p=t.out()+t.out(); //两个出堆
        t.in(p);ans+=p;  //和入堆，然后答案增加
    }
    cout<<ans; //输出
        return 0;
}
```

---

## 作者：backkom (赞：2)

一个O(n)的题解

合并过程中，不需要通过堆维护。

在初始序列按照从小到大排列的情况下，每一次合并产生的新“点”，把他们单独放进另一个队列，则显然这一个队列也是单调递增的。

这样对于每一次的合并，只需要判断两个队列的队首元素的大小，即可。

显然这样做，合并复杂度是O(n)，但是由于初始序列不一定有序，所以采用基数排序，就满足整体复杂度O(n)啦。

代码如下：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e4+2;
ll a[N],b[N],n,ans,la=1,lb=1,ra=1,rb=0;
ll gp[11][N],s[11];
ll choose()
{
	if(la>ra) return b[lb++];
	if(lb>rb) return a[la++];
	int m1 = a[la], m2 = b[lb];
	if(m1 <= m2)return a[la++];
	else return b[lb++];	
} 
ll get()
{
	ll ret = 0;
	ret = choose() + choose();	
	b[++rb] =ret;
	return ret;
}
void radix_sort()
{
	int ma = *max_element(a+1,a+n+1);
	int t = 0,k=1; while (ma){ma/=10,t++;}
	for(int i=1;i<=t;i++)
	{
		for(int j=1,idx;j<=n;j++)
		{
			idx = a[j]/k%10;
			gp[idx][s[idx]] = a[j];				
			s[idx]++;
		}
		k*=10;
		for(int j=0,num = 1;j<=9;j++)
			for(int k=0;k<s[j];k++)
				a[num++] = gp[j][k];
		memset(s,0,sizeof(s)); 
	}
} 


int main()
{
	cin >> n;
	for(int i=1;i<=n;i++) cin >> a[i];
	radix_sort(); ra = n;
	for(int i=1;i<=n-1;i++)
	{
		ans += get();
	}
	cout << ans;	
} 

```




---

## 作者：Kwork (赞：1)

这道题和切割木板完全一样，每次取最小的合并，具体证明可以用一棵树来理解。

可惜~~我不是太会~~这里太小写不下。。。。

个人YY：每两块木板合并后还需要再次合并，所以我们要让小的木板尽量多的合并，打的木板尽量少的合并~~好像很有道理~~。。。。//勿喷。

用堆实现可以非常~~搞笑~~高效。

----------------------------------------------------------------------------------------------

~~**堆的模板**~~非常良心的手写堆。







```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>//我定义了queue就是不用
using namespace std;
const int maxn=50005;
long long ans=0;
int heap[maxn],sz=0,n;
int pop(){
    int ans=heap[0];
    int x=heap[--sz];
    int i=0;
    while((i*2+1)<sz){
        int a=i*2+1,b=i*2+2;
        if(b<sz && heap[b]<heap[a]) a=b;
        if(heap[a]>=x) break;
        heap[i]=heap[a];
        i=a;
    }
    heap[i]=x;
    return ans;
}
void push(int x){
    int i=sz++;
    while(i>0){
        int p=(i-1)/2;
        if(heap[p]<=x) break;
        heap[i]=heap[p];
        i=p;
    }
    heap[i]=x;
    return;
}
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++){
        int t;
        cin>>t;
        push(t);
    }
    for(int i=1;i<n;i++){
        int x=pop();
        int y=pop();
        x+=y;
        ans+=x;
        push(x);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：sfd158 (赞：1)

用stl的优先队列来模拟堆的操作

类似于合并果子

```cpp

#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
priority_queue<unsigned,vector<unsigned>,greater<unsigned> >q;
int main()
{
    unsigned i,n,u,t,sum=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        scanf("%d",&t);
        q.push(t);
    }
    for(i=1;i<n;i++)
    {
        u=q.top();
        q.pop();
        t=q.top();
        q.pop();
        sum+=u+t;
        q.push(u+t);
    }
    printf("%u",sum);
    return 0;
}

```
注意：int存不下，必须要用unsinged


---

## 作者：AC_Evil (赞：1)

这道题就是noip2004合并果子，思路大家应该已经不陌生。楼下用的都是O(n log n)的写法，我提供一个复杂度为O(n)的写法


对于这道题，不少大佬用的是堆或线段树来维护每次合并的最小值，我来给个新思路：队列。


这道题如果一开始将序列排成有序的，如何让n-1次操作，总是能取最小值？


想下：序列从小到大有序，第一次取的肯定是第1、2项（因为这两项的和最小），关键在合并后的新数应该在新序列的哪个位置。


因为每次合并的数都是由序列中两个最小的数相加而成，所以合并后的数会严格增大。根据这个规律，将这些合并后的数放在另一个序列中，可以保证这个新序列有序，同时原序列也仍然严格有序。


那么取数就方便了。类似于归并排序，只要从两列中从头取两个最小的数，合并后ans累加上它，再放入第二个序列的末尾（进队），操作n-1次，ans即为所求。


如何取数？


############

a1 a2 a3 ...（序列a）

b1 b2 b3 ...（序列b）

############


因为只要取两个数，且序列a、b从小到大有序，所以只要考虑每个序列的前两个数。所有要判断的情况为：a1+a2，b1+b2，a1+b1，a2+b2。


但因为a1<=a2，b1<=b2，所以a1+b1<=a2+b2，可以将a2+b2这种可能性舍去。


对于刚开始要排序，因为 1<=Li<=50,000，所以可以用桶排序（也叫基数排序）提高效率，时间复杂度为O（50000），可忽略不计。


代码：









    




```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int maxL = 5e+4 + 5, maxn = 2e+4 + 5;
const long long oo = 1e+14; // 无限大定义
struct queue {
    long long data[maxn]; // 数据
    int head, tail; // 队列的开头结尾
    void create() { head = 1; tail = 0; } // 队列初始化
    long long first() { return head <= tail ? data[head] : oo; } // 获得队列的第一个数（oo：假如队列为空，则获取的数为无穷大。作用后面再说）
    long long second() { return head + 1 <= tail ? data[head + 1] : oo; } // 获得队列的第二个数
    long long back() { return data[tail]; } // 获得队列的最后一个数
    void push_back(int value) { data[++tail] = value; } // 进队
    void pop() { head++; } // 出队
} Old, New; // 两个序列（队列）。Old为上文记录原来数的队列，New为上文记录合并后数的队列
int num[maxL], n; // num:桶（排序专用）。不懂？去问度娘（桶排或基数排序）。n不解释了
long long ans = 0; // 结果
inline int read() { // 快速读入（这个自己理解，不在本题讨论范围）
    int Result = 0, mark = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-') mark = -1;
        ch = getchar();
    }
    while (isdigit(ch)) {
        Result = Result * 10 + ch - '0';
        ch = getchar();
    }
    return Result * mark;
}
void init() { // 初始化
    memset(num, 0, sizeof(num));
    Old.create();
    New.create(); // 新老队列初始化
    n = read();
    for (int i = 1; i <= n; i++)
        num[read()]++; // 读一个数，放入桶中。
    for (int i = 1; i < maxL; i++)
        for (int j = 1; j <= num[i]; j++)
            Old.push_back(i); // 将桶排后的结果放入老队列中。此时队列从小到大有序。
}
void solve() {
    for (int i = 1; i < n; i++) {
        long long a = Old.first() + Old.second(), b = New.first() + New.second(), c = Old.first() + New.first();
        // 上文讨论的4-1=3种情况。
        if (a <= b && a <= c) {
            Old.pop(); Old.pop();
            New.push_back(a);
        }
        else if (b <= a && b <= c) {
            New.pop(); New.pop();
            New.push_back(b);
        }
        else {
            New.pop(); Old.pop();
            New.push_back(c);
        } //三种操作
        ans += New.back(); //累加
    }
}
void print() {
    cout << ans; // 打印结果
}
int main() { // 主框架
    init();
    solve();
    print();
    return 0;
}
**最后：不要抄袭！**
```

---

## 作者：任梦华 (赞：0)

```cpp
/*
本题是一个比较简单的堆排序的题目，
思想和之前的合并果子非常像（简直一模一样）
我每次找到数列中最小的俩个进行合并，
再将合并后的数存入数列中
（可以用堆实现，大佬可以无视直接用优先队列，原理是一样的，
我们建立一个二叉树，让每个子节点都大于它的父亲节点
二叉树的根节点就成了最小值）
再找新的数列中最小的俩个；
（以此类推，并将过程中找到的合并后的值加起来就是答案）
*/
#include<bits/stdc++.h>
using namespace std;
int n;
long long l,s[50000],da;//题目数字给的太大了，不开long long过不了。
void sf(int wz)//上浮，将一个新值按规矩上移（每个子节点都大于它的父亲节点）
{
    while(wz!=1)//到顶结束
    {
        int cnm=wz>>1;//位运算，相当于除以2（向下取）；
        if(s[wz]<s[cnm])
            swap(s[wz],s[cnm]);
        else//找到自己位置也可以结束
            break;
        wz=cnm;
    }
}
void xc()//下沉，将一个较大值按规矩下移（顺便找到新的最小）
{
    int wz=1;
    while((wz<<1)<=n)
    {
        int cnm=wz<<1;//相当于乘2
        int t=wz;//t表示我当前的值和t的值交换
        if(cnm<=n&&s[wz]>s[cnm])
            t=cnm;//有左边并且可换
        if(s[wz]>s[cnm+1]&&s[cnm]>s[cnm+1]&&cnm+1<=n)
                t=cnm+1;//有右边并且比左边好
        if(t!=wz)//不等交换
            swap(s[wz],s[t]);
        else//找到位置，不动了
            break;
        wz=t;
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>l;
        s[i]=l;//表示我新进来一个数，我先暂时把它放在完全二叉树末尾（也就是第i个）
        sf(i);//我要把树中第i个点的数按要求上浮（上小下大）
    }
    for(int i=1;n!=1;i++)//当我节点个数为1时就做完了
    {
        int k=s[1];//取一个最小
        s[1]=s[n--];//将这个最小变为一个较大值
        xc();//把这个较大值下沉（相当于去掉最小，重新找最小）
        k=k+s[1];//再取
        s[1]=s[n--];//再删
        xc();
        s[++n]=k;//将新值存入完全二叉树末尾
        sf(n);//再次上浮
        da=da+k;//累计答案
    }
    cout<<da;
}
```

---

## 作者：water_mi (赞：0)

/\*
分析：

这是一道典型的二叉堆，方法如下：

（1）从一个森林中取出权和最小的两棵树

（2）将他们变成一棵新子树，删除原来的两颗子树，将新的数插入到森林中

重复上述过程，直到森林中有且仅有一棵树。

依照这个题来理解，就是这样的：

（1）通过N次put操作建立一个小根堆。

（2）两次get操作取出两个最小数，累加起来，再插入到堆中，

（3）反复（2），直到只有一个堆为止

深入分析，其实并不需要两次get操作，只需要将第一次get到的数，累加到heap[1]然后直接调整（无需担心会破坏堆的结构）

上面分析比较难得理解，但是，仅用n次put操作，不是很快吗？

如果实在看不懂，下面有个大佬已经写过简易版本（分析之前的版本），可以结合食用。

时间复杂度：

get和put两个操作的时间复杂度均为$log_2n$。所有建堆复杂度为$nlong_2n$。切木板时，

每次需要只需要从堆中取出一个数，再放入根结点中，在维护一遍堆，因此一遍合并的复杂度有分析之前的$3log_2n$

（取出两个数，再加入一个数）变为了$2log_2n$，共n - 1次合并操作，所以整道题目的复杂度为$nlog_2n$

\*/
```cpp
#include<cstdio>
void swap(long long &a,long long &b){long long tmp = a;a = b;b = tmp;}
long long n,heap[50010],heap_size,ans,tmp,add;
void put(long long value){
    long long now = heap_size,next;
    heap[++heap_size] = value;
    while(now > 1){
        next = now >> 1;
        if(heap[now] >= heap[next]) return;
        swap(heap[next],heap[now]);
        now = next;
    }
}
void get(){
    long long value = heap[1],now = 1,next;
    heap[1] = heap[heap_size--];
    while(now * 2 <= heap_size){
        next = now << 1;
        if(next < heap_size && heap[next + 1] < heap[next]) next++;
        if(heap[now] <= heap[next]) break;
        swap(heap[next],heap[now]);
        now = next;
    }
    //以上是堆的基本操作 
    heap[1] += value,now = 1,ans += heap[1];//将已经get到的值放入根结点中，答案加上切割所需要的能量耗费值 
    while(now * 2 <= heap_size){
        next = now << 1;
        if(next < heap_size && heap[next + 1] < heap[next]) next++;
        if(heap[now] <= heap[next]) break;
        swap(heap[next],heap[now]);
        now = next;
    }
    //维护这个堆，省去再一次put操作 
}
int main(){
    scanf("%lld",&n);
    for(long long i = 1;i <= n;i++){
        scanf("%lld",&tmp);
        put(tmp);
    }
    //通过N次put操作建立一个小根堆
    for(long long i = 1;i < n;i++) get();
    //进行n - 1次切割操作 
    printf("%lld",ans);//输出答案 
    return 0;
}
```

---

## 作者：hibiki (赞：0)

既然楼下说P的题解越来越少那么就上一个P的堆版。实际上和合并果子一样的思路。逆向处理，既然题目里是切割，那么反过来考虑合成木板。两块小木板合成以后可以得到一块大木板，这块大木板又是由更大的木板合成出来的。因此可以维护一个小根堆，每次取出堆顶的两个元素，将他们的和加入堆中，并更新答案。(其实楼下和楼下的楼下都是lz同一个机房的)

```pascal
Var
    heap:array[0..1000000] of int64;
    cnt,n,t,ans:int64;
    i:longint;
Procedure add(v:longint);
    var
        now,t:longint;
    begin
        inc(cnt);
        heap[cnt]:=v;
        now:=cnt;
        while (now<>1) and (heap[now]<heap[now div 2]) do begin
            t:=heap[now];
            heap[now]:=heap[now div 2];
            heap[now div 2]:=t;
            now:=now div 2;
        end;
    end;
Function delete:longint;
    var
        now,t:longint;
    begin
        delete:=heap[1];
        heap[1]:=heap[cnt];
        dec(cnt);
        now:=1;
        while (now*2<=cnt) and ((heap[now]>heap[now*2]) or ((now*2+1<=cnt) and (heap[now]>heap[now*2+1]))) do begin
            if (now*2+1>cnt) or (heap[now*2]<heap[now*2+1]) then begin
                t:=heap[now];
                heap[now]:=heap[now*2];
                heap[now*2]:=t;
                now:=now*2;
            end else begin
                t:=heap[now];
                heap[now]:=heap[now*2+1];
                heap[now*2+1]:=t;
                now:=now*2+1;
            end;
        end;
    end;
Begin
    readln(n);
    for i:=1 to n do begin
        readln(t);
        add(t);
    end;
    for i:=1 to n-1 do begin
        t:=delete+delete;
        ans:=ans+t;
        add(t);
    end;
    writeln(ans);
End. 【code】
```

---

## 作者：ZYR_ (赞：0)

[h1]AC以后表示醉了……（就是范围大点的合并果子代码！！！）[/h1]

之前没看出来，WA了好久，后来才想通的……

请大家仔细想想，合并果子是把一些果子合在一起，而此题是把一块木板分成一些小段。就是倒过来嘛！

再经过一些实验可得出，正反无所谓……

还要再提醒一下，试图快排的同学们不要白费努力了，快排会超时，要用堆排序。

不多啰嗦了，直接上代码：




```cpp
[codep]var
    heap:array[1..30001]of int64;
    n,t,f1,f2,sum,sz:int64;
    i:longint;      //切记，虽然代码和合并果子相同，但数据范围要比合并果子大一些，所以要用int64！
procedure push(x:longint);    //以下是堆操作，放入（push）和取出（pop），不懂的童鞋自己去[delete]百度[/delete]学。
var    
    i,f:longint;
begin
    inc(sz);
    i:=sz;
    while i>1 do
    begin
        f:=i div 2;
        if heap[f]<=x then break;
        heap[i]:=heap[f];
        i:=f;
    end;
    heap[i]:=x;
end;
function pop():longint;     //取出
var
    ret,x,i,lchild,rchild:longint;
begin
    ret:=heap[1];
    x:=heap[sz];
    sz:=sz-1;
    i:=1;
    while i*2<=sz do　　　　
    begin
        lchild:=i*2;
        rchild:=i*2+1;
        if (i*2+1<=sz) and (heap[rchild]<heap[lchild]) then lchild:=rchild;
        if x<=heap[lchild] then break;
        heap[i]:=heap[lchild];
        i:=lchild;
    end;    
    heap[i]:=x;
    exit(ret);
end;
begin
    readln(n);
    sum:=0;
    sz:=0;
    for i:=1 to n do　　　　//读入堆
    begin
        read(t);
        push(t);
    end;
    for i:=1 to n-1 do　　　　//堆排序并记录
    begin
        f1:=pop();
        f2:=pop();
        push(f1+f2);
        sum:=sum+f1+f2;
    end;
    writeln(sum);
end.[/codep]
总体来说，只要会堆排序，这道题不算难。希望大家能看懂！
```

---

## 作者：Deny_小田 (赞：0)

## 我的楼下的评价是：


# 致以敬意但并不欣赏。

诚然，楼下手打堆确实挺不容易的，值得鼓励，但这种方法不是很值得推崇。

我（们）的信仰是现实主义。


废话扯了这么多，怎么办呢？？

我想，楼下的main函数值得借鉴。跟我想的差不多。

太简单了，不再赘述。


必须用long long（long没有尝试过），第9个点会炸int。

附代码：








```cpp
#include <cstdio>
#include <queue>
#include <iostream>
using namespace std;
typedef long long LL;
LL n,t,ans = 0;
priority_queue<LL, vector<LL>, greater<LL> > q;
int main(int argc, char const *argv[]){
    ios::sync_with_stdio(false);
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> t;
        q.push(t);
    }
    for(int i = 1; i < n; i++){
        int x = q.top(); q.pop();
        int y = q.top(); q.pop();
        x += y;
        ans += x;
        q.push(x);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：小丑 (赞：0)

[h1]既然这里没有P党的题解，而且现在P党的题解也越来越少，所以在此写下p的题解。

这里的板长切割方案其实可以组合成一棵二叉树，并且最佳的切割方案应该满足最短的板与次短的板的节点应当是兄弟节点，因此对于最优解来讲，最短的板应当是深度最大的叶子节点之一，很容易想到其兄弟节点是次短节点，这样它们合起来的代价才会最优。在每次切割前都有：（L1+L2），L3，L4。。。，LN。复杂度比较高，是O（N方），有更优的解法可以自己去上网查找。实现方式是递归。[/h1]

[codec]var n,answ,min1,min2,k,t:int64;//min1存最短的板的编号，min2存次短的板的编号，t存当前两块木板合成的代价。

```cpp
    long:array[1..20000]of int64;
    i:longint;
begin
 readln(n);
 for i:=1 to n do
  readln(long[i]);//读入
 while n>1 do//直到计算到木板数为一块时
  begin//每次都求出最短的板和次短的板，再进行合并
   min1:=1;
   min2:=2;
   if long[min1]>long[min2] then
    begin
     k:=min2;
     min2:=min1;
     min1:=k;
    end;
   for i:=3 to n do
    if long[i]<long[min1]
     then
      begin
       min2:=min1;
       min1:=i;
      end
     else if long[i]<long[min2] 
      then
       min2:=i;
   t:=long[min1]+long[min2];//两块板合并的过程
   answ:=t+answ;
   if min1=n then
    begin
     k:=min2;
     min2:=min1;
     min1:=k;
    end;
  long[min1]:=t;//这里要处理一下原先的长度，更新一下，防止之后的计算出现问题，也避免了重复的合并
  long[min2]:=long[n];
  n:=n-1;
 end;
 writeln(answ);
end.[/codec]
```
[h1]本人水平较差，如有错误请指出，并非常抱歉。[/h1]

---


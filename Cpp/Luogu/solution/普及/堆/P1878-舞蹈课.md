# 舞蹈课

## 题目描述

有 $n$ 个人参加一个舞蹈课。每个人的舞蹈技术由整数来决定。在舞蹈课的开始，他们从左到右站成一排。当这一排中至少有一对相邻的异性时，舞蹈技术相差最小的那一对会出列并开始跳舞。如果不止一对，那么最左边的那一对出列。一对异性出列之后，队伍中的空白按原顺序补上（即：若队伍为 `ABCD`，那么 `BC` 出列之后队伍变为 `AD`）。舞蹈技术相差最小即是 $a_i$ 的绝对值最小。

任务是模拟以上过程，确定跳舞的配对及顺序。


## 说明/提示

对于 $50\%$ 的数据，$1\leq n\leq 200$。

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5$，$1\le a_i\le 10^7$。

## 样例 #1

### 输入

```
4
BGBG
4 2 4 3
```

### 输出

```
2
3 4
1 2
```

# 题解

## 作者：NIMNIM (赞：118)

### [这道题](https://www.luogu.org/problem/P1878)
是暑假的时候教练给我们测试的一道题，说实话，当时没打完，究其原因，竟是我~~代码能力太差了~~思路太复杂了qwq

但是，尽管思路比较清奇，我也觉得可能会有和我想的一样但是代码打不出来的人，所以我要发一发题解来帮帮大伙

~~题解里面有打上标记的，而可以说用的不是 $bool$ 类型的标记而是 $int$  类型的标记~~

我们大部分人自然都知道优先队列（大根/小根堆），这里不再赘述，就给个[链接](https://www.cnblogs.com/xzxl/p/7266404.html)

------------

#### 下面进入问答环节：

$ASK:$ 这道题怎么用优先队列？？？

$ANSWER:$ 其实想想也不难，只要用优先队列来维护相邻舞者之间的技术值的差，每次取最小的就OK了

$ASK:$ 有一对跳了之后，TA们两边的怎么办？

$ANSWER:$ 这个问题其实也不算难，我们只要用链表结构，断链重连，放入队列就好了

~~问答环节结束~~

------------
看到这儿，可能你就跑去打代码了对吧，但是，停下！！！ ~~（当然你真的会了你自然可以走了我不留你~~

但是还有一个比较重要的问题：

对于一排舞者，B1  G1  B2  G2  ，我们一开始存储并放入队列的是什么，是每两个相邻的舞者的差，那假设 G1  B2 先出来，然后断链重连，那么B1  G1  的联系以及 B2  G2  的联系该怎么办？？？

这时候，我们就要学会打标记了。

------------

### 我们有两种可选的思路：

**第一种**比较简单，即在每一对舞者出列之后对这两个舞者都打上标记，以后在优先队列中取出TA们的时候不执行操作就是了

**第二种**则有点~~蠢~~难，就是在每次更新差值的时候，用int数组存放更新了的差值，如果在后面从优先队列中取出的差值与之前存放的差值不相等的话，则说明这个差值未被更新的，那也不执行操作即可

~~（第二种是我这种菜鸡用的方法，看不太懂就学第一个吧）~~

------------

#### 代码来了：

1.第一种的之前题解似乎有

2.第二种：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
using namespace std;
#define inf 2000000000
int ans[200005][2],sum=0;
struct node//链表 
{
	int l,r,cha,xu;
	bool judge;
}a[200005];

bool operator<(node rr,node ll)//优先队列有限法则 
{
	int lll=abs(ll.cha),rrr=abs(rr.cha);
	if(rrr!=lll)
		return lll<rrr;
	else
		return ll.xu<rr.xu;
}

priority_queue <node> que;

int main ( )
{
	//freopen("dance.in","r",stdin);
	//freopen("dance.out","w",stdout);
	int n,now,next,t=0;
	char x;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(x=='B') a[i].judge=0;
		else a[i].judge=1;
	} //以上性别判断 
	scanf("%d",&now);
	for(int i=1;i<n;i++)
	{
		scanf("%d",&next);
		a[i].xu=i;	 		//自身是第几个 
		a[i].cha=next-now;//预处理技术值差 
		a[i].l=i-1;a[i].r=i+1;//预处理左右 
		que.push(a[i]);
		now=next;
	}
	a[n].r=n+1;a[n].xu=n;a[n].cha=inf;
	while(!que.empty())//开始模拟过程 
	{
		int xx=que.top().xu,cmp=que.top().cha;
		que.pop();
		int yy=a[xx].r;
		if(a[xx].cha==cmp/*判断是否是更新过的*/&&a[xx].judge!=a[yy].judge/*一男一女*/
		&&xx!=0&&yy!=n+1/*特判链表首尾 */)
		{
			ans[++t][0]=xx;ans[t][1]=yy;
			a[a[xx].l].cha+=a[xx].cha+a[yy].cha;//更新差值 
			a[a[yy].r].l=a[xx].l;a[a[xx].l].r=a[yy].r;//断链重连 
			if(a[xx].l>0&&a[yy].r<=n)//特判链表首尾 
				que.push(a[a[xx].l]);//入队列 
			a[xx].l=a[xx].r=0;a[yy].l=a[yy].r=n+1;
		}
	}
	printf("%d\n",t);
	for(int i=1;i<=t;i++)
		printf("%d %d\n",ans[i][0],ans[i][1]);
	return 0;
}
```

写了好久。。。求管理大大通过；求读者赞赞。

---

## 作者：汪鸣谦 (赞：77)

这一题大概是二叉堆也就是优先队列的题。

首先新建一个小根堆

按照题意模拟一下过程：第一遍，我们从左到右扫整个数组，如果有相邻的异性就入队。

这里在优先队列里我们存储三个信息：当前一对的编号 $(x,y)$ 以及它们的差的绝对值，每次先是按照绝对值从小到大排序，然后如果绝对值一样就按照左端点从小到大排序即可。

每一次首先从优先队列里去处队首元素，将他们标记为已取过，出队，用 $ans$ 数组进行记录。

看到这里，此题似乎与优先队列裸题没区别。

但是题目里说了这么一句：“一对异性出列之后，队伍中的空白按原顺序补上（即：若队伍为 $ABCD$，那么 $BC$ 出列之后队伍变为 $AD$ ）”。

这意味着什么呢？$AD$ 仍然有可能组成一对新的合法的舞伴，但是我们在第一遍扫描的时候无法考虑这种情况。

怎么办？链表

设 $f[i]$ 表示右边和i相邻的数，$g[i]$ 表示左边和i相邻的数。这样的话呢，就形成了指向关系。

首先将 $f[i]$ 初始化成 $i$+1 ，$g[i]$ 初始化成 $i-1$（这里比较好理解）。

然后每次进行合法的出队的操作的时候，我们把当前点对的左边的数叫 $x$，右边的数叫 $y$ 那么 $x$ 的左边相邻点的右边相邻点自然就要指向 $y$ 的右边相邻点，$y$ 的右边相邻点的左边相邻点自然要指向 $x$ 的左边相邻点。

这里有点绕，简而言之就是（可以画个图试试）。

```
f[g[x]] = f[y];

g[f[y]] = g[x];
```


然后这里多出来了一对新的相邻点 $g[x]$ 和 $f[y]$。

判断他们是否合法，如果合法就入队即可。

代码：

```
#include<bits/stdc++.h>

using namespace std;
struct node{
	int w,c,d;
};
priority_queue<node>q;
int n,a[200011]={0},is[200011]={0},cnt=0,ans1[200011]={0},ans2[200011]={0},f[200011]={0},g[200011]={0},flag=1;
bool operator<(node a,node b){
	if(a.w==b.w)return a.c>b.c;
	else return a.w>b.w;
}
string s;
int main(){
	cin>>n;
	cin>>s;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	s+='H';
	for(int i=1;i<n;i++){
		if(s[i-1]!=s[i])q.push((node){abs(a[i]-a[i+1]),i,i+1});
	}
	for(int i=1;i<=n;i++){
		f[i]=i+1;
		g[i]=i-1;
	}
	while(q.empty()==0){
		node t=q.top();
        q.pop();
		int x=t.c,y=t.d;
		if(is[x]==0&&is[y]==0){
			f[g[x]]=f[y];
			g[f[y]]=g[x];
			cnt+=1;
			ans1[cnt]=x,ans2[cnt]=y;
			is[x]=1,is[y]=1;
			if(is[g[x]]==0&&is[f[y]]==0){
				if((s[g[x]-1]+s[f[y]-1])==('G'+'B')){
                    q.push((node){abs(a[g[x]]-a[f[y]]),g[x],f[y]});
                }
			}
		}
	}
	cout<<cnt<<endl;
	for(int i=1;i<=cnt;i++){
		cout<<ans1[i]<<" "<<ans2[i]<<endl;
	}
	return 0;
}
```

最后提示一点，一定一定要先出队（具体就是用 $t$ 记录队首信息以后就立刻 POP）。

否则会WA（因为已经有新的数进来了队首可能就变了~~我就是在这卡住的~~）

~~都到这了，点个赞好吗qwq~~

---

## 作者：反手一只MJJ (赞：31)

## 不会链式也没事
#### **[题目专属入口，欢迎光临](https://www.luogu.org/problemnew/show/P1878)**
### 题目怎么说，我们怎么做！
---
## 变量声明:
```
/*
    note 一组男女包含l(左边的人),r(右边的人),cha(差的绝对值),需排序搭配优先队列排序
    priority_queue<note>que 优先队列
    queue<note>ANS 存入答案
    n 队伍中的人数
    ans 输出的第一行答案
    a[] 每个人的技术含量
    sex[] 性别, bool类型
    danced[i] 表示第i个人是否已出列
    L[i] 此时此刻，第i个人的左边是第L[i]个人
    R[i] 此时此刻，第i个人的左边是第R[i]个人
    (L[]和R[]搭配使用,仿链表)
*/
```
# 题目怎么说，我们怎么做：
- ~~纯模拟题，最喜欢awa。~~
## 分析题目,有主要几种操作:
- 操作一：输入。
- 操作二：查找 技术含量差绝对值 最小的一对相邻男女。
- 操作三：弹出这对男女，更新队伍。
- 操作四：输出。
## 操作一：
- 纯输入。
## 操作二：
- 因为每次都查找最小值，线性扫描耗时间，我们需要一个优先队列que来维护。
## 操作三：
- 倘若我们每次弹出一对男女后，把剩下的人合并，会很耗时。
- 这时，大佬们自然而然地想到了链表链接。
- 但我不喜欢awa！
- 如下，假设现在有10个人：
- INF(0x3f3f3f3f)表示没有人。

![image](https://cdn.luogu.com.cn/upload/pic/70724.png)

- 我们用L[i]和R[i]来维护弹出一组人后———此时此刻第i个人的左边和右边是队列中第L[i]个人和第R[i]个人，取代暴力调整队伍的做法。
 - 假如我们弹出5和6：
 - 则弹出后应该调整L[7]和R[4]的值。

![image](https://cdn.luogu.com.cn/upload/pic/70765.png)

- 我们可以通过：进行调整。

```cpp
	if(R[x.r]!=INF)L[R[x.r]]=L[x.l];
	if(L[x.l]!=INF)R[L[x.l]]=R[x.r];
```
- 如图：

![image](https://cdn.luogu.com.cn/upload/pic/70771.png)
![image](https://cdn.luogu.com.cn/upload/pic/70773.png)
- 注意每次执行操作三后，需要判断是否形成了新的一组相邻男女。
## 操作四：
- 纯输出。
---
# 接下来是代码：

```cpp

#include<cctype>
#include<cstdio>
#include<queue>
#define rd read()
using namespace std;
const int INF=0x3f3f3f3f;
const int MAXN=200005;
inline int read()
{
    int x=0;
	bool f=false;
	char g=getchar();
    for(;!isdigit(g);g=getchar())if(g=='-')f=true;
    for(;isdigit(g);g=getchar())x=(x<<3)+(x<<1)+(g^48);
    if(f)return -x;
    return x;
}//快读
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar((x%10)|48);
	return;
}//快写
inline int abs(int x){if(x>0)return x;return-x;}
struct note{
	int l,r,cha;
	friend bool operator < (note a,note A){
		if(a.cha==A.cha)
		return a.l > A.l;
		return a.cha > A.cha;
	}
};
priority_queue < note > que;
queue < note > ANS;
int n,ans=0;
int a[MAXN];
bool sex[MAXN];
bool danced[MAXN];
int L[MAXN],R[MAXN];
int main()
{
	n=rd;
	if(n==1){printf("0\n");return 0;}
	for(int i=1;i<=n;i++)
	{
		L[i]=i-1;R[i]=i+1;
		char g;
		while(!isalpha(g=getchar()));
		if(g=='G')sex[i]=true;
	}
	L[1]=INF;R[n]=INF;
	for(int i=1;i<=n;i++){
		a[i]=rd;
		if(i==1)continue;
		if(sex[i]^sex[i-1])//一男一女
		que.push((note){i-1,i,abs(a[i-1]-a[i])});
	}
	while(que.size()){
		note x=que.top();
		que.pop();
		if(danced[x.l]||danced[x.r])continue;
		danced[x.l]=true;danced[x.r]=true;
		ans++;
		ANS.push((note){x.l,x.r,0});
		if(R[x.r]!=INF)L[R[x.r]]=L[x.l];
		if(L[x.l]!=INF)R[L[x.l]]=R[x.r];
		if(R[x.r]!=INF&&L[x.l]!=INF)
		if(sex[R[x.r]]^sex[L[x.l]])//形成了一对新的相邻男女
		que.push((note){L[x.l],R[x.r],abs(a[L[x.l]]-a[R[x.r]])});
	}
	write(ans);
	putchar('\n');
	while(ANS.size()){
		printf("%d %d\n",ANS.front().l,ANS.front().r);
		ANS.pop();
	}
    return 0;
}
```

--- 
#### 蒟蒻恳求各位大佬指点qwq
#### ~~(广告,本蒟蒻开始建设Blog了awa:[点我](https://www.luogu.org/blog/134593/))~~

---

## 作者：An_Aholic (赞：20)

# P1878 舞蹈课

---

### Part 0. 前言  
其实这道题蛮简单的，就是在前置知识（详见 Part 1）上对我这个蒟蒻造成了亿点点打击（？

---

### Part 1. 前置知识讲解

---
#### 1.1 堆/优先队列

堆，即优先队列，不断维护堆中第一个元素为整个堆中最小（小根堆）/ 大（大根堆）的元素。

首先，我们要知道维护一个**小根堆**的基本操作步骤：

1. 在堆尾加入一个元素，并把这个结点设为当前结点，以下简称为 $x$；

2. 如果 $x$ 小于父亲结点，则交换它们的值，并把父结点置为 $x$，继续将当前结点与它父结点比较，重复操作 2；

3. 如果 $x$ 不小于父结点，则结束。

如果是大根堆，那么只需要把操作 2 改成大于，操作 3 改成不大于。

我们来试一下手写：

```cpp
void push(int x) {
	tot++;
	h[tot] = x;
	int i = tot;
	int j = i / 2;
	while (j > 0 && h[i] < h[j]) {
		swap(h[i], h[j]);
		i = j;
		j = i / 2;
	}
}

void pop() {
	h[1] = h[tot];
	tot--;
	int i = 1;
	int j = 2 * i; //左儿子
	if (j + 1 <= tot && h[j + 1] < h[j])
		j++;
	while (j <= tot && h[j] < h[i]) {
		swap(h[j], h[i]);
		i = j;
		j = 2 * i;
		if (j + 1 <= tot && h[j + 1] < h[j])
			j++;
	}
}

```


由于作者太懒了，不想写手写，宁愿写一个超长的 STL 也不写！！1

` priority_queue<int, vector<int>, greater<int>> h; `

---
#### 1.2 重载运算符

如果我们想要自己定义的两种类型（通常是结构体）能够运算，需要重新定义这个运算符号在这两个类型之间运算是怎么运算的。说的直接一点，就是**告诉编译器，以后看见我用这两种类型进行运算，就按我定义的方法运算！**

1. 不能重装 C++ 基本的数据类型运算规则，重载运算符至少需要包含一个用户自定义的数据类型。
2. 禁止额外虚构超出 C++ 提供的运算符。
3. 运算符重载遵循优先级约束。
4. 重载运算符不限定运算数据类型，可以通过多次重载完成更多的数据类型运算。
5. 重载运算符后，左侧的操作数据是调用对象，前后位置不能颠倒。
6. 注意运算符重载的参数个数，所有运算符一般只会和一个数据进行运算，所以除了全局运算符重载外，成员的运算符重载参数应该只有一个。

定义有四种，这里介绍三种：

- 直接在结构体外写一个重载。
```cpp
bool operator定义的符号(const 类型1 &比较的第一个数, const 类型2 &比较的第二个数) {
		return 比较方法;
}
```

举个例子：
```cpp
bool operator>(const int &x, const int &y) {
	if (x.a != y.a) {
		return x.a > y.a;
	}
	// else
	return x.b > y.b;
}
```
- 在结构体内写一个成员函数。

```cpp
struct info {
	int a, b;
	bool operator>(const info &x) const {
		if (a != x.a) {
			return a > x.a;
		}
		// else
		return b > x.b;
	}
};
```

- 在结构体内写一个友元函数。
```
struct info {
	int a, b;
	friend bool operator>(const int &x, const int &y) {
		if (x.a != y.a) {
			return x,a > y.a;
		}
		// else
		return x.b > y.b;
	}
};
```
---

### 1.3 链表
每一个元素，记录它的前面的，后面的，类似一个链条。



---
----

### Part 2. 思路
这道题，我们要去想，哪里用到小根堆？

原题中：“舞蹈技术相差最小的那一对会出列并开始跳舞”。

那么，我们用小根堆存储的就是，我们每一对的信息！

那么再考虑存储：

一个结构体 $per$ 来记录这个人的信息，这是必须的。

可是我们怎么来存储这个差？

我们再设一个结构体 $dui$，这个结构体里面记录的是这一对人的索引（下标），和这两个人的差。

**要注意的是，我们在定义小根堆时要把类型改成 $dui$！**

我们先将这存储部分的代码给出：

``` cpp

struct dui {
	int l, r;
	int diff_val;

};
dui ans[1000010];



struct per {
	char b_g; //性别
	int val;
	int prev, next;

} p[2000005];

priority_queue<dui, vector<dui>, greater<dui>> h;
bool vis[2000005];
int cnt;
int n;
 ```
  
 然后，我们将会把每两个相邻的异性先入堆吧？
 
 然后呢？
 
 我们到堆为空之前一直循环，取堆顶，就得到了当前差最小的那一对。如果那一对中已经有一个和别人组合过了，就不可以再组了，把他俩给弹出去。没有任意一个和别人组过，就说明可以再组，把他俩前后连上（链表），压进去，再把他俩弹出去。每一次判断可以组合时记录下来，最后输出即可。



---


### Part 3. 代码
```cpp

#include <bits/stdc++.h>
using namespace std;

struct dui {
	int l, r;  // 两个人
	int diff_val; //差
	bool operator>(const dui &x) const {
		if (diff_val != x.diff_val) {
			return diff_val > x.diff_val;
			/*
			if (diff_val > x.diff_val)
				return 1; (true)
			*/
		}
		// else
		return l > x.l;
	}
};
dui ans[1000010];



struct per {
	char b_g;
	int val;
	int prev, next;

} p[2000005];

priority_queue<dui, vector<dui>, greater<dui>> h;
bool vis[2000005];
int cnt;
int n;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> p[i].b_g;
	for (int i = 1; i <= n; i++)
		cin >> p[i].val;
	for (int i = 1; i <= n; i++)
		p[i].prev = i - 1, p[i].next = i + 1;
	p[1].prev = 1;
	p[n].next = n;
	for (int i = 1; i < n; i++) {
		if (p[i].b_g != p[i + 1].b_g) {
			dui v;
			v.diff_val = abs(p[i].val - p[i + 1].val);
			v.l = i;
			v.r = i + 1;
			h.push(v);
		}
	}
	while (!h.empty()) {
		dui x = h.top(); 
		if (vis[x.l] || vis[x.r]) {
			h.pop();
			continue;
		}
		ans[++cnt] = x;
		vis[x.l] = vis[x.r] = 1; // 标记
		h.pop();
		int q = p[x.l].prev;
		int b = p[x.r].next;
		p[q].next = b;
		p[b].prev = q;
		if (p[q].b_g != p[b].b_g) {
			dui t;
			t.l = q;
			t.r = b;
			t.diff_val = abs(p[q].val - p[b].val);
			h.push(t);
		}
	} 
	cout << cnt << endl;
	for (int i = 1; i <= cnt; i++)
		cout << ans[i].l << " " << ans[i].r << endl;
}
```
---
完结撒花！

---

## 作者：ListenSnow (赞：13)

## 题意
给定$n$个人，每个人有一个舞蹈技术值，**相邻**且舞蹈技术值相差最小的一对异性会出队，求出队的总次数以及出队的顺序。
## 思路
首先看到最小值，可以想到用**小根堆**来实现。

先将每一种可能的出队方案储存到小根堆中。

可以定义一个数组来表示是否出队。如果相邻的舞者有人已经出队，便跳过。

每一次出队以后，就会产生一对新的相邻舞者，可以用数组模拟**链表**来储存每一位舞者边上的人。出队后便将这一对舞者从链表中**删去**，同时在答案数组中记录。再判断新产生的一对相邻舞者是否满足出队要求（注意特判边界情况）。

最终得到的便是本题的答案。


## 代码

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int N=2e5+10;
int n,a[N],nex[N],sex[N],pre[N],ans[N][2],cnt;
bool st[N];
char s[N];
int abs(int a){return a>0?a:-a;}
struct node{
	int l,r,dis;
	bool operator <(const node &t)const{ 
	    if(dis==t.dis) return l>t.l; //若有多队舞者差值相同，则最左边的一对优先出队 
	    return dis>t.dis;
	}
};
priority_queue<node>q;
int main()
{
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(s[i]=='B') sex[i]=1;
		pre[i]=i-1,nex[i]=i+1; //链表初始化 
	}
	for(int i=1;i<n;i++)
	    if((sex[i]^sex[i+1])==1) q.push(node{i,i+1,abs(a[i]-a[i+1])});// 若相邻两人异性，则异或值为1，反之则为0 
	while(q.size())
	{
		node now=q.top();
		q.pop();
		if(!st[now.l]&&!st[now.r]) //都仍未出队 
		{
			st[now.l]=true;//标记出队 
			st[now.r]=true;	
			ans[++cnt][0]=now.l;//记录答案 
			ans[cnt][1]=now.r;
			nex[pre[now.l]]=nex[now.r];//删去出队的舞者 
			pre[nex[now.r]]=pre[now.l];
			if(nex[now.r]>n||pre[now.l]<1) continue; //特判边界 
			if((sex[pre[now.l]]^sex[nex[now.r]])==1) q.push(node{pre[now.l],nex[now.r],abs(a[pre[now.l]]-a[nex[now.r]])});
		    //判断新产生的相邻舞者是否满足出队要求 
		}
	}
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;i++) printf("%d %d\n",ans[i][0],ans[i][1]);
	return 0;
}
```


---

## 作者：Natsume_Rin (赞：7)

这一题，可以使用优先队列。

相关定义：

```cpp
priority_queue<pair<pair<int,int>, int> >q;
```

还要应用链表的相关操作。

$ne_i$ 表示第 $i$ 个学生的下一个学生。

$la_i$ 表示第 $i$ 个学生的上一个学生。

**每次从优先队列中取出一对男女，再修改相关的链的信息。放入新的男女在优先队列中（如果有的话）。**

代码：

```cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;
const int MAXN = 2e5+5;
int n;
int a[MAXN];
char x[MAXN];
int ne[MAXN];
int la[MAXN];
priority_queue<pair<pair<int,int>, int> >q;
int anc[MAXN][2];
int ans;
int cid;
bool pd[MAXN];
inline int read(){
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x){
	if(x>9){
		write(x/10);putchar(x%10+'0');
	}
	else putchar(x+'0');
}
int main(){
	n=read();
	for(RI i=1;i<=n;++i) cin>>x[i], ne[i]=i+1;
	ne[n]=0;
	for(RI i=2;i<=n;++i) la[i]=i-1;
	for(RI i=1;i<=n;++i) a[i]=read();
	for(RI i=1;i<n;++i) if(x[i]!=x[ne[i]]) q.push(make_pair(make_pair(-abs(a[i]-a[ne[i]]),-i),-(i+1)));
	while(!q.empty()){
		if(pd[-q.top().first.second]||pd[-q.top().second]) {
			q.pop();
			continue;
		}
		++ans;
		anc[ans][0]=-q.top().first.second;
		anc[ans][1]=-q.top().second;
		pd[anc[ans][0]]=1;
		pd[anc[ans][1]]=1;
		cid=anc[ans][0];
		q.pop();
		if(!la[cid]||(!ne[ne[cid]])) continue;
		if(x[la[cid]]!=x[ne[ne[anc[ans][0]]]]) q.push(make_pair(make_pair(-abs(a[la[cid]]-a[ne[ne[anc[ans][0]]]]),-la[cid]),-(ne[ne[anc[ans][0]]])));
		ne[la[cid]]=ne[anc[ans][1]];
		la[ne[anc[ans][1]]]=la[cid];
	}
	write(ans), putchar('\n');
	for(RI i=1;i<=ans;++i) write(anc[i][0]), putchar(' '), write(anc[i][1]), putchar('\n');
	return 0;
}
```

码风略丑，见谅，望轻喷。

---

## 作者：Dragonbell_exp (赞：6)

# 内容：
# 题目要求：
-
输入n个人的性别与舞蹈技术，

舞蹈技术差从小到大输出所有相邻的异性，

如果技术差相等按照从左到右来输出（在这道题中意义不大），

且当异性出队后队伍不为空时，

队伍会填补上空缺。

看到这我们就不难想到这道题应该用链表（^_^)。


------------

# 思路：
使用链表与堆来做这道题。

定义一个结构体（person）存储：
一个人的性别，舞蹈技术以及前后的人。

定义又一个结构体（dui）来存储：
相邻两个人之间的技术差。

定义一个小根堆来不断提供相差最小的组合。

先读入每个人的性别与实力，

再把每个人与前后的人相链，

然后将所有异性相邻的舞者入堆，

循环不断提取出实力相差最少的异性相邻人出队跳舞。

#### 循环中有几点需要注意：

1. 当一对人已经出队了，

   就不需要继续管他们了。

   所以需要定义bool数组来标记一个人是否出队并判断；

2. 为了维护人与人之间的相链关系，

   需要在每次有人出队后把出队的人的左右相链，

   并继续把异性入堆。


------------
#    代码：
```c
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<queue>
using namespace std;
struct human{//每个人的信息 
	char xb;//性别  
	int from,to;//前后的人的编号，以此建立链表 
	int w;//实力 
} people[200010]; 
struct dui{//堆的类型是dui 
	int i,j;//相邻的两个人 
	int mix;//他们的实力差 
	friend bool operator<(dui a,dui b){//重载运算符，大根堆变为小根堆（STL库只能定义大根堆，要把它重载为小根堆） 
	    if(a.mix!=b.mix) return a.mix>b.mix;
	    else return a.i>b.i;
	} 
}ans[200010];//存放符合的对
bool vis[200010];//用来标记是否已经出队，0否1是 
priority_queue<dui> h;//dui类型的大根堆会被重载为小根堆 

int main(){
	int n;//共有n个人 
	scanf("%d\n",&n);//读入人数 
	for(int i=1;i<=n;i++){//
		people[i].xb=getchar();
	}
	getchar();
	
	for(int i=1;i<=n;i++){//读入他们的实力 
		scanf("%d",&people[i].w);
		people[i].from=i-1;//与前后建立联系 
		people[i].to=i+1;
	}
	
	for(int i=1;i<n;i++){//将相邻的异性存入堆 
		if(people[i].xb!=people[i+1].xb){//如果是异性，就把所有信息存入堆 
			dui t;
			t.mix=abs(people[i].w-people[i+1].w);
			t.i=i;
			t.j=i+1;
			h.push(t);
		}
	}
	int cnt=0;//cnt是符合的对的数量数 
	while(!h.empty()){//如果堆不为空，即还有相链的异性 
		dui t=h.top();//取实力最小的（top）左右相链的人的编号（x，y） 
		int x=t.i,y=t.j;
		
		if(vis[x]==1||vis[y]==1) {//如果其中有任何人已经出队就跳过并将他出堆 
			h.pop();
			continue; 
		}
		ans[++cnt]=t;//否则输出增加 
		h.pop();//出堆 
		vis[x]=vis[y]=1;//把此时的相链的两个标记为已经出队 
		int xx=people[x].from,yy=people[y].to;//维护链表，将出队者的前后相链 
		people[xx].to=people[y].to; 
		people[yy].from=people[x].from; 
		if(people[xx].xb!=people[yy].xb&&xx>=1&&yy<=n){//如果相链后是异性那么继续入堆 
			t.mix=abs(people[xx].w-people[yy].w);
			t.i=xx;
			t.j=yy;
			h.push(t);
		}
	}
	cout<<cnt<<endl;//输出符合的人数以及他们对应的位置 
	for(int i=1;i<=cnt;i++){
		cout<<ans[i].i<<" "<<ans[i].j<<endl;
	}
	
	return 0;
}
```



---

## 作者：sukimo (赞：5)

首先，两两配出的对子是有明显的优先级的，而且会出现跳完了这对删除和删除后队列拼接加入新配对这两种操作，于是想到使用堆来维护。跳完了删除，还需要灵活的维护接下来新队伍拼接后是哪两个挨在一起，于是使用链表。读入时先将所有配对入堆，选出跳舞的一对，出堆并打标记，站位拼接处理新对。重复以上即可。

```
#include<bits/stdc++.h>
using namespace std;
const int MX=200005;
struct STR1{int q1,q2,_abs;};struct STR2{char sex;int le,ri,val;}dance[MX];
bool operator <(STR1 a,STR1 b){return a._abs==b._abs?a.q1>b.q1:a._abs>b._abs;}
STR1 pack(int q1,int q2,int _abs){STR1 a;a.q1=q1;a.q2=q2;a._abs=_abs;return a;}
int vis[MX];priority_queue<STR1>heap;
void solve(int x,int y){
	vis[x]=vis[y]=1;heap.pop();
	if(dance[x].le!=-1)dance[dance[x].le].ri=dance[y].ri;
	if(dance[y].ri!=-1)dance[dance[y].ri].le=dance[x].le;
	if(dance[x].le!=-1&&dance[y].ri!=-1&&dance[dance[x].le].sex!=dance[dance[y].ri].sex)heap.push(pack(dance[x].le,dance[y].ri,abs(dance[dance[x].le].val-dance[dance[y].ri].val)));
}
int main(){
	int n,k,girl_cnt=0,boy_cnt=0;scanf("%d",&n);
	for(int i=1;i<=n;i++){dance[i].le=(i-1?i-1:-1);dance[i].ri=(n-i?i+1:-1);}
	for(int i=1;i<=n;i++){cin>>dance[i].sex;dance[i].sex=='B'?boy_cnt++:girl_cnt++;}
	for(int i=1;i<=n;i++){scanf("%d",&dance[i].val);if(i-1&&dance[i].sex!=dance[i-1].sex)heap.push(pack(i-1,i,abs(dance[i].val-dance[i-1].val)));}
	k=min(girl_cnt,boy_cnt);printf("%d\n",k);
	for(int i=1;i<=k;i++){
		while(vis[heap.top().q1]||vis[heap.top().q2])heap.pop();
		printf("%d %d\n",heap.top().q1,heap.top().q2);
		solve(heap.top().q1,heap.top().q2);
	}
	return 0;
}
```


---

## 作者：cancan123456 (赞：4)

算法框架：
1. 读入数据
2. 建立链表
3. 将所有可能的配对入队
4. 如果没有可能的配对，结束并输出，否则，继续
5. 找到一个舞蹈技术差最小的配对
6. 如果是不合法配对，弹出并跳到5，否则，继续
7. 存储下来，出队，更改组成配对的两个人的信息，将新产生的配对入队
8. 如果没有可能的配对，结束并输出，否则，跳回4

上代码！
```cpp
#include <cstdio>
#include <queue>
using namespace std;
#define maxn 200005
#define maxk 100005 
int n;
struct Person {
	int a;
	char xb;
	int pre, next;
	void print();
} people[maxn];
int abs(int x) {
	return x < 0 ? -x : x;
}
struct Pair {
	int first, second;
	int diff;
	Pair() {
		diff = abs(people[first].a - people[second].a);
	}
	Pair(int first, int second): first(first), second(second) {
		diff = abs(people[first].a - people[second].a);
	}
	bool right() {
		return (0 <= first && first < n) && (0 <= second && second < n) && (people[first].xb != people[second].xb) && (people[first].next == second) && (people[second].pre == first);
	}
	void print();
};
bool operator < (const Pair & a, const Pair & b) {
	return (a.diff > b.diff) || ((a.diff == b.diff) && (a.first > b.first));
}
void Person::print() {
	printf("xb: %c, a: %d\n", xb, a);
}
void Pair::print() {
	people[first].print();
	people[second].print();
	printf("diff: %d, ", diff);
	if (right()) {
		printf("合法\n");
	} else {
		printf("不合法\n");
	}
}
int k;
Pair ans[maxk];
int main() {
	scanf("%d\n", &n);
	for (int i = 0; i < n; i++) {
		scanf("%c", &people[i].xb);
	}
	for (int i = 0; i < n; i++) {
		scanf("%d", &people[i].a);
	}
	for (int i = 0; i < n; i++) {
		people[i].pre = i - 1;
		people[i].next = i + 1; 
	}
	priority_queue < Pair > pairs;
	for (int i = 0; i < n - 1; i++) {
		pairs.push(Pair(i, i + 1));
	}
	while (!pairs.empty()) {
		while (!Pair(pairs.top()).right() && !pairs.empty()) {
			pairs.pop();
		}
		if (pairs.empty()) {
			break;
		}
		Pair t = pairs.top();
		pairs.pop();
		ans[k++] = t;
		pairs.push(Pair(people[t.first].pre, people[t.second].next));
		people[people[t.first].pre].next = people[t.second].next;
		people[people[t.second].next].pre = people[t.first].pre;
	}
	printf("%d\n", k);
	for (int i = 0; i < k; i++) {
		if (ans[i].first < ans[i].second) {
			printf("%d %d\n", ans[i].first + 1, ans[i].second + 1);
		} else {
			printf("%d %d\n", ans[i].second + 1, ans[i].first + 1);
		}
	}
	return 0;
}
```

---

## 作者：_121017_ (赞：3)

一道堆 + 链式的~~水~~题，这里给出不用 $pair$ 的做法。

思路：$pre[i]$ 表示当前学生的前一个， $next[i]$ 表示当前学生的下一个，用 $priority\_queue$ 存储每一组学生，每次取出堆顶元素并存储，在判断这一组学生前面一个学生和后面一个能否组成一组，如果能就入堆。

坑点：一点要用 **双向链表** 来存储前后学生的下标，要用 $flag$ 数组判断学生是否跳过舞，学生出队后右边的学生的后一个学生的前一个学生的指针指向出队的左边的学生的前一个，左边的学生的前一个的指针指向右边的学生的后一个。

具体看代码。

# code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
using namespace std;
int n;
int ans;
int a[1000001],pre[10001],next[10001];
//分别存储学生的舞蹈技巧、学生的前一个和后一个
struct Node{
	int l;//出队跳舞的左边的学生
	int r;//出队跳舞的右边的学生
}ou[1000001];//存储出队跳舞的学生
bool m[1000001];//存储学生是男是女
bool flag[1000001];//标记学生是否出过队
struct node{
	int pre;//每对学生左边的一个
	int cur;//每对学生右边的一个
	int num;//每对学生舞技之差
}f[1000001];
bool operator <(node a,node b){
	if(a.num==b.num){
		return a.cur>b.cur;
	}
	return a.num>b.num;
}
//重载运算符
priority_queue <node,vector<node> > q;//优先队列
signed main(){
	cin>>n;
	for(ri i=1;i<=n;i++){
		char c;
		cin>>c;
		if(c=='B') m[i]=0;//如果是男生，m标记为0
		else m[i]=1;//否则标记为1
	}
	for(ri i=1;i<=n;i++){
		cin>>a[i];
		pre[i]=i-1;
		next[i]=i+1;
		f[i].pre=i-1;
		f[i].cur=i;
		f[i].num=abs(a[i]-a[i-1]);
		if(m[i]!=m[i-1]&&i>1){//如果越界或性别相同就不入队
			q.push(f[i]);
		}
	}
	while(!q.empty()&&ans<=n/2){//一直到没有可以出队的学生
		node hd=q.top();//取除堆顶元素
		q.pop();
		if(hd.cur<=n&&hd.pre>=1&&flag[hd.cur]!=1&&flag[hd.pre]!=1){//如果不越界且没有出队跳过舞
			flag[hd.cur]=1,flag[hd.pre]=1;//标记学生已经出过队
			pre[next[hd.cur]]=pre[hd.pre];
			next[pre[hd.pre]]=next[hd.cur];
                        //改变指针方向
			ans++;//出对数加1
			ou[ans].l=hd.pre,ou[ans].r=hd.cur;//存储出队学生
			int x=pre[hd.pre],y=next[hd.cur];
			if(x>=1&&y<=n&&m[x]!=m[y]&&(!flag[x])&&(!flag[y])){//如果出队后又有新的学生组成一对
				node tl;
				tl.cur=y;
				tl.pre=x;
				tl.num=abs(a[y]-a[x]);
				q.push(tl);
                                //入堆
			}
		}
	}
	cout<<ans<<endl;
	for(ri i=1;i<=ans;i++){
		cout<<ou[i].l<<" "<<ou[i].r<<endl;
	}
        //输出
	return 0;//结束
} 
```


---


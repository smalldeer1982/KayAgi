# 【模板】堆

## 题目描述

给定一个数列，初始为空，请支持下面三种操作：

1. 给定一个整数 $x$，请将 $x$ 加入到数列中。
2. 输出数列中最小的数。
3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。




## 说明/提示

**【数据规模与约定】**
- 对于 $30\%$ 的数据，保证 $n \leq 15$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq x \lt 2^{31}$，$op \in \{1, 2, 3\}$。

## 样例 #1

### 输入

```
5
1 2
1 5
2
3
2
```

### 输出

```
2
5```

# 题解

## 作者：henry_y (赞：854)

[该篇文章同步于我的个人博客](https://www.cnblogs.com/henry-1202/p/9307927.html)

二叉堆是一种基础数据结构，主要应用于求出一组数据中的最大最小值。C++ 的STL中的优先队列就是使用二叉堆。不过初赛经常考二叉堆的原理。

事实上支持的操作也是挺有限的（相对于其他数据结构而言），也就插入，查询，删除这一类

**对了这篇文章中讲到的堆都是二叉堆，而不是斜堆，左偏树，斐波那契堆什么的~~我都不会啊~~**


------------
更新概要：

~~无良博主终于想起来要更新辣~~

**upd1:更新5.2.2-对于该子目所阐述的操作“用两个堆来维护一些查询第k小/大的操作”更新了一道例题-该操作对于中位数题目的求解**

**upd2：更新5.3-利用堆来维护可以“反悔的贪心”**

continue...

------------


# 一.堆的性质

**1.堆是一颗完全二叉树**

**2.堆的顶端一定是“最大”，最小”的，但是要注意一个点，这里的大和小并不是传统意义下的大和小，它是相对于优先级而言的，当然你也可以把优先级定为传统意义下的大小，但一定要牢记这一点，初学者容易把堆的“大小”直接定义为传统意义下的大小，某些题就不是按数字的大小为优先级来进行堆的操作的**

（但是为了讲解方便，下文直接把堆的优先级定为传统意义下的大小，~~所以上面跟没讲有什么区别？~~）

**3.堆一般有两种样子，小根堆和大根堆，分别对应第二个性质中的“堆顶最大”“堆顶最小”，对于大根堆而言，任何一个非根节点，它的优先级都小于堆顶，对于小根堆而言，任何一个非根节点，它的优先级都大于堆顶（这里的根就是堆顶啦qwq）**

来一张图了解一下堆（这里是小根堆）（原谅我丑陋无比的图）

![](https://i.loli.net/2018/07/13/5b48bcc426d83.png)

不难看出，**对于堆的每个子树，它同样也是一个堆**（因为是完全二叉树嘛）

# 二.堆的操作

## 1.插入

假设你已经有一个堆了，就是上面那个

这个时候你如果想要给它加入一个节点怎么办，比如说0？

先插到堆底（严格意义上来说其实0是在5的左儿子的，图没画好放不下去，不过也不影响）

然后你会发现它比它的父亲小啊，那怎么办？不符合小根堆的性质了啊，那就交换一下他们的位置

![](https://i.loli.net/2018/07/13/5b48bd1106211.png)

交换之后还是发现不符合小根堆的性质，那么再换

![上浮2.png](https://i.loli.net/2018/07/13/5b48bd7c385b4.png)

还是不行，再换

![上浮3.png](https://i.loli.net/2018/07/13/5b48bd5579ff1.png)

好了，这下就符合小根堆的性质了，是不是顺眼很多了？~~（假的，图越来越丑，原谅我不想再画）~~

![上浮4.png](https://i.loli.net/2018/07/13/5b48bdc07f3bc.png)

事实上堆的插入就是把新的元素放到堆底，然后检查它是否符合堆的性质，如果符合就丢在那里了，如果不符合，那就和它的父亲交换一下，一直交换交换交换，直到符合堆的性质，那么就插入完成了

Code：
```cpp
void swap(int &x,int &y){int t=x;x=y;y=t;}//交换函数 
int heap[N];//定义一个数组来存堆
int siz;//堆的大小 
void push(int x){//要插入的数 
	heap[++siz]=x;
	now=siz;
	//插入到堆底 
	while(now){//还没到根节点，还能交换 
		ll nxt=now>>1;//找到它的父亲 
		if(heap[nxt]>heap[now])swap(heap[nxt],heap[now]);//父亲比它大，那就交换 
		else break;//如果比它父亲小，那就代表着插入完成了 
		now=nxt;//交换 
	}
	return; 
}
```
## 2.删除

把0插入完以后，忽然你看这个0不爽了，本来都是正整数，怎么就混进来你这个0？

于是这时候你就想把它删除掉

怎么删除？在删除的过程中还是要维护小根堆的性质

如果你直接删掉了，那就没有堆顶了，这个堆就直接乱了，所以我们要保证删除后这一整个堆还是个完好的小根堆

![上浮4.png](https://i.loli.net/2018/07/13/5b48bdc07f3bc.png)

首先在它的两个儿子里面，找一个比较小的，和它交换一下，但是还是没法删除，因为下方还有节点，那就继续交换

![上浮3.png](https://i.loli.net/2018/07/13/5b48bd5579ff1.png)

还是不行，再换

![上浮2.png](https://i.loli.net/2018/07/13/5b48bd7c385b4.png)

再换

![](https://i.loli.net/2018/07/13/5b48bd1106211.png)

好了，这个碍眼的东西终于的下面终于没有节点了，这时候直接把它扔掉就好了

![](https://i.loli.net/2018/07/13/5b48bcc426d83.png)

这样我们就完成了删除操作，但是在实际的代码操作中，并不是这样进行删除操作的，有一定的微调，代码中是直接把堆顶和堆底交换一下，然后把交换后的堆顶不断与它的子节点交换，直到这个堆重新符合堆性质~~（但是上面的方式好理解啊）~~

手写堆的删除支持任意一个节点的删除，不过STL只支持堆顶删除，STL的我们后面再讲

Code：
```cpp
void pop(){
	swap(heap[siz],heap[1]);siz--;//交换堆顶和堆底，然后直接弹掉堆底 
	int now=1;
	while((now<<1)<=siz){//对该节点进行向下交换的操作 
    	int nxt=now<<1;//找出当前节点的左儿子 
        if(nxt+1<=siz&&heap[nxt+1]<heap[nxt])nxt++;//看看是要左儿子还是右儿子跟它换 
        if(heap[nxt]<heap[now])swap(heap[now],heap[nxt]);//如果不符合堆性质就换 
        else break;//否则就完成了 
        now=nxt;//往下一层继续向下交换 
	}
}
```
## 3.查询

因为我们一直维护着这个堆使它满足堆性质，而堆最简单的查询就是查询优先级最低/最高的元素，对于我们维护的这个堆heap，它的优先级最低/最高的元素就是堆顶，所以查询之后输出heap[1]就好了

一般的题目里面查询操作是和删除操作捆绑的，查询完后顺便就删掉了，这个主要因题而异

# 三.堆的STL实现

这年头真的没几个人写手写堆~~（可能有情怀党？）~~

一是手写堆容易写错代码又多，二是STL	直接给我们提供了一个实现堆的简单方式：优先队列

手写堆和STL的优先队列有什么	区别？~~没有区别~~

速度方面，手写堆会偏快一点，但是如果开了O2优化优先队列可能会更快；

代码实现难度方面：优先队列完爆手写堆

这两方面综合起来，一般都是用STL的优先队列来实现堆，~~省选开O2啊~~

至于为什么前面讲堆的操作时用手写堆，好理解嘛，最好先根据上面的代码和图理解一下堆是怎么实现那些操作的，再来看一下下面的STL的操作

定义一个优先队列：
```cpp
首先你需要一个头文件：#include<queue>
priority_queue<int> q;//这是一个大根堆q
priority_queue<int,vector<int>,greater<int> >q;//这是一个小根堆q
//注意某些编译器在定义一个小根堆的时候greater<int>和后面的>要隔一个空格，不然会被编译器识别成位运算符号>>
```
优先队列的操作：
```
q.top()//取得堆顶元素，并不会弹出
q.pop()//弹出堆顶元素
q.push()//往堆里面插入一个元素
q.empty()//查询堆是否为空，为空则返回1否则返回0
q.size()//查询堆内元素数量
```
常用也就这些，貌似还有其他，不过基本也用不到，知道上面那几个也就可以了

不过有个小问题就是STL只支持删除堆顶，而不支持删除其他元素

但是问题不大，开一个数组del，在要删除其他元素的时候直接就标记一下del[i]=1，这里的下标是元素的值，然后在查询的时候碰到这个元素被标记了直接弹出然后继续查询就可以了
（前两天刚从学长处get这个姿势）

另外因为STL好写，下面堆的应用全部都会采用STL的代码实现~~（懒啊，如果有放代码的话）~~

这里补一下重载运算符在STL的优先队列中应用到的知识

**重载运算符是什么？**

**把一种运算符变成另外一种运算符（注意，都必须是原有的运算符）**，比如把<号重载成>号，这个东西学过STL中的sort的同学应该会比较熟悉

这个在优先队列中有什么用处呢？

之前我们就讲到了，大根堆，小根堆的“大”和“小”都不是传统意义下的“大”和“小”，重载运算符在STL的优先队列中就是用来解决这种“非传统意义的‘大’和‘小’”的

现在你有一个数列，它有权值和优先级两种属性，权值即该数的大小，优先级是给定的，现在要你按照优先级的大小从小到大输出这个数列

~~这不是Treap吗？这不是sort吗？~~

以上两个东西都可以用来实现这道题（逃，而且就实用性而言，sort用来解决这道题是最方便的，但是我们现在要讲的做法是使用**堆排序**的方式来解决这道题（堆排序是什么？下文堆的应用中有提到）

首先应该想得到结构体，我们定义一个结构体
```cpp
struct node{
	int val,rnd;
}a[100];
```
但是使用传统做法是行不通的，在小根堆中是通过比较数的大小来确定各个元素在堆中的位置的，但是对于这个a数组，你是要对比权值val的值，还是要对比优先级rnd的值？

这时候**重载运算符**就派上用场了

我们在结构体里面再加3行东西

```
struct node{
	int val,rnd;
    bool operator < (const node&x) const {
		return rnd<x.rnd;
	}
}a[100];
```

这个玩意为什么要这么写呢？

首先这个玩意是bool类型的，因为你只需要判断这两个是大，还是小；然后，要重载运算符就必须加一个operator这个玩意，不然计算机怎么知道你要干嘛？后面接一个你要重载的运算符，这里是“<”，再后面的括号里面的东西则是你要比较的数据类型，这里是数据类型为node，并且加了一个指针&，将对这个x的修改同步到你实际上要修改的数据那里。然后就是记得加那两个const

然后两个大括号里面就是你重载的内容了，这里是把比较数的大小的小于号，重载成比较node这个数据类型里面的优先级的大小

这个玩意讲的比较多，主要是因为是一个很难懂的东西~~（对我来说？反正当时学的时候就是感觉很晦涩难懂，这里就尽量写详细一点，给和当初的我一样的萌新看一下）~~

而且在实际中，这个东西的用处也很大，就说在堆里面的应用，在NOIP提高，省选的那个级别，就绝对不可能考裸的堆的，往往你要比较的东西就不是数的大小了，而是按照题目要求灵活更改，这时候重载运算符就帮得上很大忙了

**这也就是为什么我在前面反复强调，堆里面的大小，并非传统意义下的大小**

# 四.堆的复杂度

因为堆是一棵完全二叉树，所以对于一个节点数为n的堆，它的高度不会超过log2n

所以对于插入，删除操作复杂度为O(log2n)

查询堆顶操作的复杂度为O(1)

# 五.堆的应用

## 1.堆排序

其实就是用要排序的元素建一个堆（视情况而定是大根堆还是小根堆），然后依次弹出堆顶元素，最后得到的就是排序后的结果了

但是裸的并没有什么用，我们有sort而且sort还比堆排快，所以堆排一般都没有这种模板题，一般是利用堆排的思想，然后来搞一些奇奇怪怪的操作，第2个应用就有涉及到一点堆排的思想

## 2.用两个堆来维护一些查询第k小/大的操作

- [洛谷P1801 黑匣子](https://www.luogu.org/problemnew/show/P1801)  

利用一个大根堆一个小根堆来维护第k小，并没有强制在线  
不强制在线，所以我们直接读入所有元素，枚举询问，因为要询问第k小，所以把前面的第k个元素都放进大根堆里面，然后如果元素数量大于k，就把堆顶弹掉放到小根堆里面，使大根堆的元素严格等于k，这样这次询问的结果就是小根堆的堆顶了（前面k-1小的元素都在大根堆里面了）。记得在完成这次询问后重新把小根堆的堆顶放到大根堆里面就好。
- [洛谷P1090 合并果子](https://www.luogu.org/problemnew/show/P1090)  

直接从所有果子中找到最小堆最小的果子，合并之后再放入堆中。
- [洛谷P1168 中位数](https://www.luogu.org/problemnew/show/P1168)

中位数也是这种操作可以解决的一种经典问题，但是实际应用不大（这种操作的复杂度为$O(nlogn)$，然而求解中位数有$O(n)$做法）

Luogu中也有此类例题，题解内也讲的比较清楚了，此处不再赘述，读者可当做拓展练习进行食用

提示：设序列长度为$N$，则中位数其实等价于序列中$N/2$大的元素

```
#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#define ll long long
#define inf 1<<30
#define il inline 
#define in1(a) read(a)
#define in2(a,b) in1(a),in1(b)
#define in3(a,b,c) in2(a,b),in1(c)
#define in4(a,b,c,d) in2(a,b),in2(c,d)
il int max(int x,int y){return x>y?x:y;}
il int min(int x,int y){return x<y?x:y;}
il int abs(int x){return x>0?x:-x;}
il void swap(int &x,int &y){int t=x;x=y;y=t;}
il void readl(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
il void read(int &x){
    x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
using namespace std;
/*===================Header Template=====================*/
#define N 200010
priority_queue<int,vector<int>,greater<int> > q;
priority_queue<int> q1;
int n,m,a[N],b[N];
int main(){
    in2(n,m);
    for(int i=1;i<=n;i++)in1(a[i]);
    for(int i=1;i<=m;i++)in1(b[i]);
    int i=1;
    for(int j=1;j<=m;j++){
        for(;i<=b[j];i++){
            q1.push(a[i]);
            if(q1.size()==j)q.push(q1.top()),q1.pop();
        }
        printf("%d\n",q.top());
        q1.push(q.top());q.pop();
    }
    return 0;
}
```

**事实上堆在难度较高的题目方面更多的用于维护一些贪心操作，以降低复杂度，很少会有题目是以堆为正解来出的了，更多的，堆在这些题目中处于“工具”的位置**

## 3.利用堆来维护可以“反悔的贪心”

题目：[Luogu P2949 [USACO09OPEN]工作调度Work Scheduling](https://www.luogu.org/problemnew/show/P2949)

这道题的话算是这种类型应用的经典题了

首先只要有贪心基础就不难想出一个解题思路：因为所有工作的花费时间都一样，我们只要尽量的选获得利润高的工作，以及对于每个所选的工作，我们尽量让它在更靠近它的结束时间的地方再来工作

但是两种条件我们并不好维护，这种两个限制条件的题目也是有一种挺经典的做法的：对一个限制条件进行排序，对于另一个限制条件使用某些数据结构来维护（如treap，线段树，树状数组之类），但是这并不在我们今天的讨论范畴QAQ

考虑怎么将这两个条件“有机统一”。

排序的思路是没有问题的，我们可以对每个工作按照它的结束时间进行排序，从而来维护我们的第二个贪心的想法。

那么对于这样做所带来的一个冲突：对于一个截止时间在d的工作，我们有可能把0~d秒全都安排满了（可能会有多个任务的截止时间相同）

怎么解决这种冲突并保证答案的最有性呢？

一个直观的想法就是把我们目前已选的工作全部都比较一下，然后选出一个创造的利润最低的工作（假设当前正在决策的这个工作价值很高），然后舍弃掉利润最低的工作，把这个工作放进去原来的那个位置。（因为我们已经按照结束时间排序了，所以舍弃的那个任务的截止完成时间一定在当前决策的工作的之前）

但是对于大小高达$10^6$的n，$O(n^2)$的复杂度显然是无法接受的，结合上面的内容，读者们应该也不难想出，可以使用堆来优化这个操作

我们可以在选用了这个工作之后，将当前工作放入小根堆中，如果堆内元素大于等于当前工作的截止时间了（因为这道题中，一个工作的执行时间是一个单位时间），我们就可以把当前工作跟堆顶工作的价值比较，如果当前工作的价值较大，就可以将堆顶弹出，然后将新的工作放入堆中，给答案加上当前工作减去堆顶元素的价值（因为堆顶元素在放入堆中的时候价值已经累加进入答案了）。如果堆内元素小于截止时间那么直接放入堆中就好

至此，我们已经可以以$O(nlogn)$的效率通过本题

而通过这道题我们也可以发现，只有在优化我们思考出来的贪心操作的时间复杂度时，我们才用到了堆。正如我们先前所说到的，在大部分有一定难度的题目里，堆都是以一个“工具”的身份出现，用于优化算法（大多时候是贪心）的时间复杂度等

```
#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
#include <map>
#include <set>

using namespace std ;

#define N 100010
#define int long long

int n , m ;
struct node {
	int d,p ;
	bool operator < ( const node &x ) const { return p>x.p; }
} a[ N ] ;

bool cmp( node a , node b ) {
	return a.d==b.d?a.p>b.p:a.d<b.d;
}

priority_queue< node > q ;

signed main() {
	scanf( "%lld" , &n ) ;
	for( int i = 1 ; i <= n ; i ++ ) {
		scanf( "%lld%lld" , &a[i].d , &a[i].p ) ;
	}
	sort(a+1,a+n+1,cmp);
	int ans = 0 ;
	for( int i = 1 ; i <= n ; i ++ ) {
		if( a[i].d<=(int)q.size() ) {
			if( q.top().p<a[i].p ) {
				ans += a[i].p-q.top().p ; 
				q.pop() ; 
				q.push(a[i]) ;
			}
		} else q.push(a[i]) , ans += a[ i ].p ;
	}
	printf( "%lld\n" , ans ) ;
}
```

continue...持续更新中

---

## 作者：封禁用户 (赞：39)

> 你自信满满的打开这题，开始写题解。
> 
> 你自信的介绍完 `priority_queue` 后题解。
> 
> 你发现管理员需要介绍普通的操作，你直接退出不写了（确信。

~~以上都是闲话，现在开始讲正文。~~

# 题目大意

给定一个数列一共三个操作：

 + 给定一个 $x$，将 $x$ 加入数列中。
 + 输出这个数组里面的最小值。
 + 删除这个数组的最小值。
 
# 思路

首先，如果我们就考虑普通的做法，每一次操作都是暴力的话，我们来分析一下复杂度：

 + 给定一个 $x$，将 $x$ 加入数列中。
 
 	每一次加入一个数就是放到末尾，时间复杂度 $O(1)$。
    
 + 输出这个数组里面的最小值。
 	
   每一次扫一遍这个数组，时间复杂度 $O(n)$。
    
 + 删除这个数组的最小值。
 	
   先扫一遍整个数组找到最小值所在的位置 $pos_{min}$，然后将 $pos_{min}$ 之后的所有数字向前移动一位。时间复杂度也是 $O(n)$。

综上，我们得到最后的复杂度应该是 $O(n^2)$，但是 $n \le 10^6$，效率明显不够，就假掉力。

所以现在我们要一个数据结构，使得输找到最小值和删除最小值的速度要快。这个数据结构就是 **堆**。

## 堆的知识

堆有两种，一种是大根堆，一种是小根堆。而这一题要求的是最小是，所以我们应该要用小根堆

### 1. 堆的性质

小根堆有两个特点：

 + 是一个完全二叉树。
 + 儿子值 $\ge$ 父亲值。

> 注意：完全二叉树是满二叉堆的最后一层删除了右边的几个节点后得到的树。

![tree1](https://cdn.luogu.com.cn/upload/image_hosting/nvrztsgl.png) ![tree2](https://cdn.luogu.com.cn/upload/image_hosting/oxlzbgxk.png) ![tree3](https://cdn.luogu.com.cn/upload/image_hosting/34b350eb.png)

上面的三幅图中，第一和第二棵树全都不是完全二叉树，第三课才是正确的完全二叉树。

### 2.堆的操作

#### 1.插入一个数 $x$
假设我们已经建立了一个堆如下（为了方便描述，我已经在图中编了个号）：
![](https://cdn.luogu.com.cn/upload/image_hosting/hlexmqh5.png)

我们可以发现，每一个父节点 $id$ 的左儿子恰好是 $2 \times id$，右儿子既是 $2 \times id + 1$，具体的证明过程可以看 [这篇文章](https://www.cnblogs.com/sybil-hxl/p/15088324.html)。

然后我们假设要插入一个数字 $11$，那么我们可以直接将 $11$ 当作一个节点放到“最后”（这里的“最后”指的是最后一个节点的下一个新节点）：	
![](https://cdn.luogu.com.cn/upload/image_hosting/6w80kmai.png)

接下来，整个数的结构已经被破坏，因为 $11$ 这一个数并不大于他的父亲节点 $47$，我们需要将 $11$ 这个节点往上调：

![](https://cdn.luogu.com.cn/upload/image_hosting/oa435msv.png)

调了一次后发现 $11$ 还是没有大于他的父亲节点 $17$，于是我们再调：

![](https://cdn.luogu.com.cn/upload/image_hosting/ogu0fz4e.png)

我们发现现在已经满足小根堆的条件了，我们就可以~~跑路~~完成了插入这个操作。时间复杂度应该是这个树的高度既 $O(\log\ n)$。

我们可以总结一下插入的操作：
 + 先把这个数插入到最后。
 + 然后不断地向上调整，直到满足小根堆的条件。

向上调整的代码：

```cpp
void push_up(int &i,int val){//找到val插入的位置
	//i为这个数的高度，val为插入的树
	while(i > 1 && val < heap[i / 2]){//如果不满足小根堆的条件
		heap[i] = heap[i / 2];//这个点就变成他的父节点，就是把这个数向上找到他插入的位置
		i /= 2;//变为父节点的编号
	}
}
```

插入一个数的代码：

```cpp
void insert(int val){//加入val
	int i = ++size;//高度
	push_up(i, val);//找到val插入的位置
	heap[i] = val;//插入val
}
```

#### 2.删除最小值

因为我们这个堆是小根堆，那么我们直接将第一个节点删除：

![](https://cdn.luogu.com.cn/upload/image_hosting/l6eo3g82.png)

这时，剩下的节点没有父节点了，那怎么办呢，其实我们可以用“世袭制”的方法来去“变”出一个父节点，“世袭制”是什么意思呢？就是皇帝领盒饭后的下一位皇帝是他的儿子，如果有多个就按年龄大的来算。回到我们这个堆，每一个节点的编号就像是他的年龄，现在皇帝 $9$ 领盒饭了，那么他的下一位继承人就是年龄（编号）最大的儿子： $31$，我们将 $31$ 放到皇帝的位置上，这个堆就变成了下面这个模样：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1vyr5ej.png)

但是我们发现，这个小根堆又一次被破坏了，$17$ 这个节点小于他的父节点，我们就将 $37$ 向下调：

![](https://cdn.luogu.com.cn/upload/image_hosting/i39tjz36.png)

我们又发现 $23$ 这个节点小于 $37$，我们就继续将 $37$ 向下调：
![](https://cdn.luogu.com.cn/upload/image_hosting/bd9uw2dl.png)

现在就满足了小根堆的条件。

时间复杂度也应该和插入操作一样，是这个树的高度：$O(\log\ n)$。

我们又可以总结一下删除的操作：
 + 把最后一个节点放到第一个。
 + 不断地向下调整，直到满足小根堆的条件。

向下调整的代码：
```cpp
void push_down(int &i,int val){//找到删除
	int ch = i * 2;
	while(ch <= size){
		if(ch < size && heap[ch + 1] < heap[ch])ch++;
		if(val <= heap[ch])break;
		heap[i] = heap[ch];
		i = ch;
		ch += ch;
	}
}
```

删除最小值的代码：
```cpp
void delete_min(){
	int i = 1, val = heap[size--];
	push_down(i, val);//找到最后一个树应该向下调整到哪个位置
	heap[i] = val;
}
```

#### 3.输出最小值

最小值就是堆的第一个元素，每一次输出这个值就可以了。

时间复杂度：$O(1)$。

最后的复杂度应该是 $O(n\ \log\ n)$ 能过这道题，堆的知识点我们也讲的差不多了。

### 手写堆实现 AC 代码

```cpp
/*****************************************
备注：
******************************************/
#include<queue>
#include<math.h>
#include<stack>
#include<stdio.h>
#include<iostream>
#include<vector>
#include<iomanip>
#include<map>
#include<string.h>
#include<algorithm>
using namespace std;
typedef long long LL;
const int MAXN = 1e6 + 10;
const int MR = 10 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 998244353;
int size, heap[MAXN];
void push_up(int &i,int val){
	while(i > 1 && val < heap[i / 2]){
		heap[i] = heap[i / 2];
		i /= 2;
	}
}
void push_down(int &i,int val){
	int ch = i * 2;
	while(ch <= size){
		if(ch < size && heap[ch + 1] < heap[ch])ch++;
		if(val <= heap[ch])break;
		heap[i] = heap[ch];
		i = ch;
		ch += ch;
	}
}
void insert(int val){
	int i = ++size;
	push_up(i, val);
	heap[i] = val;
}
void delete_min(){
	int i = 1, val = heap[size--];
	push_down(i, val);
	heap[i] = val;
}
signed main()
{
	int n;
	cin >> n;
	for(int i = 1;i <= n; i++){
		int opt, x;
		cin >> opt;
		if(opt == 1){
			cin >> x;
			insert(x);
		}
		if(opt == 2){
			cout << heap[1] << endl;
		}
		if(opt == 3){
			delete_min();
		}
	}
	return 0;
}
```

接下来我们来介绍一个 c++ 自带的堆实现：`priority_queue` 优先队列。

## `priority_queue` 的使用方法

首先，我们要先定义头文件 `#include<queue>`。

然后我们可以以 `priority_queue<type> name;` 的方式来定义。其中 `type` 可以是 `struct` 类型，例如：

```cpp
struct student
{
	string name;
	int score;
};//记录一个学生成绩
priority_queue<student> que;//定义一个优先队列
```
---
优先队列还支持自定义排序方法，一共有两种：

 + 1.重载运算符

```cpp
struct student 
{
	string name;
	int score;
	bool operator < (const struct Status &x) const {
		if(score == x.score)return name < x.name;
		return score > x.score;
	}//按照分数排序
};
priority_queue<student> que;//现在已经是按照我们自己定义的方法来排序
```

 + 2.自定义排序
 
```cpp
bool cmp(const pair<int,int> &a, const pair<int,int> &b)
{
	return a.second>b.second;
}//pair按照第二关键字排序
priority_queue<pair<int,int>, vector<pair<int,int> >, decltype(&cmp)> q(cmp);//定义比较麻烦，建议不要用这一种
```

---

小根堆和大根堆我们可以这样定义：

```cpp
priority_queue<int> que;//默认为小根堆

priority_queue<int, vector<int>, less<int> > que;//这个也是小根堆

priority_queue<int, vector<int>, greater<int> > que;//这个是大根堆

bool cmp(const int &a, const int &b)
{
	return a > b;
}
priority_queue<int, vector<int >, decltype(&cmp)> q(cmp);//这个还是大根堆
```
---

`priority_queue` 的操作和 `queue` 差不多，一共有以下 $5$ 种：

```cpp
priority_queue<int> que;
que.push(x);//加入一个数x
cout << que.top();//输出第一个数
cout << que.size();//输出这个堆有几个元素
que.pop();//弹出第一个元素
cout << que.empty();//判断这个堆是不是空的
```

`priority` 的知识点也讲的差不多了，接下来回到这道题，就是使用上面的 `push, top, pop` 就可以了。

## 其他例题

### 1.[合并果子](https://www.luogu.com.cn/problem/P1090)

每一次将这个数列的最小值和次小值取出，然后相加再放回去堆里就做完了。

#### 手写堆代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int heap[100001], heap_length, n, x, y, i, tot = 0;
void put(int t)
{
	int now, next;
	heap[++heap_length] = t;
	now = heap_length;
	while(now > 1)
	{
		next = now / 2;
		if(heap[now] >= heap[next]) return;
		swap(heap[now], heap[next]);
		now = next;
	}
}
int get()
{
	int next, tot, now;
	tot = heap[1];
	heap[1] = heap[heap_length--];
	now = 1;
	while(2 * now <= heap_length)
	{
		next = 2 * now;
		if(next < heap_length && heap[next + 1] < heap[next])
			next++;
		if(heap[now] <= heap[next]) return tot;
		swap(heap[now], heap[next]);
		now = next;
	}
	return tot;
}
int main(){
	cin >> n;
	for(i = 1;i <= n; i++)
	{
		cin >> x;
		put(x);
	}
	for(i = 1;i < n; i++)
	{
		x = get();
		y = get();
		tot += x + y;
		put(x + y);
	}
	cout << tot << endl;
}
```

#### `priority_queue` 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int tot = 0, n;
priority_queue<int, vector<int>, greater<int> > q;
int main(){
	cin >> n;
	for(int i = 1;i <= n; i++)
	{
	    int x;
		cin >> x;
		q.push(x);
	}
	for(int i = 1;i < n; i++)
	{
		int x = q.top();q.pop();
		int y = q.top();q.pop();
		tot += x + y;
		q.push(x + y);
	}
	cout << tot << endl;
}
```



# 持续更新中……

~~写了 3h 麻烦管理员大大通过吧。~~

---

## 作者：yzm0325 (赞：23)

刚学了二叉堆这题就清题解了，那我就来一发吧！

二叉堆是一棵**完全二叉树**，所以我们用一个数组存储，存储时依据这两条性质：

- 第 $x$ 个节点的父节点是 $\lfloor x \div 2 \rfloor$。
- 第 $x$ 个节点（如果存在左右儿子，那么它）的左儿子编号是 $2 \times x$，右儿子编号是 $2 \times x + 1$。

存储之后如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/pz47v5ja.png)

对于这道题，我们需要用一种特殊的堆结构：**小根堆**。小根堆父节点的值一定小于子节点的值。如下图就是一个小根堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/cg2f4frr.png)

接着，来看怎么用小根堆完成题目中的三种处理。

### 1.查询最小值

很简单，小根堆的根节点就是。

代码：

```cpp
int top() {
	return w[1]; // 返回根节点
}
```

### 2.加入新元素

很容易想到，无论如何先把新的元素放在堆的尾部，才能保证不违反堆最基本的性质，像这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/t9s1mgfx.png)

然而这又违反了小根堆的性质：父节点的值小于子节点的值。我们考虑对小根堆进行**修复**：

1. 若自己是根或自己的值大于父节点（即小根堆性质满足）了，停止修复。
1. 否则自己的值更小，将自己与父节点交换，继续修复。

修复过程如下：

首先用 $3$ 和根节点 $5$ 比较，发现 $3<5$，不符合小根堆性质，将两个节点交换。

![](https://cdn.luogu.com.cn/upload/image_hosting/5kdrf5tl.png)

再用 $3$ 和现在它的根节点 $2$ 比较，发现 $3>2$，符合小根堆性质，于是修复成功。

至此，我们成功的将元素 $2$ 插入了这个小根堆。时间复杂度为 $O(\log n)$。

代码如下：

```cpp
void modify(int x) { // 插入时自底向上修复 x 号节点
    if(x == 1 || w[x] > w[x / 2]) return; // x 已经是根或符合小根堆性质
    swap(w[x], w[x / 2]);
    modify(x / 2); // 递归继续修复
}
void push(int x) { // 插入元素 x
    w[++tot] = x; // 直接插到尾部
    modify(tot); // 修复
}
```

### 3.删除最小值

如果直接擦掉最小值，堆将会分裂成两个堆，会遇到大麻烦。所以先把根节点和尾部节点交换，再直接把尾节点删掉。

![](https://cdn.luogu.com.cn/upload/image_hosting/xgte705d.png)

明显不符合性质了，还要自上而下修复，规则和上面一样。不放图了。

根据这个思路写出代码：

```cpp
void repair(int x) { // 删除时自上而下修复 x 号节点
    if(x * 2 > tot) return; // 已经是叶子节点
    int tar = x * 2; // 右节点一定存在
    if(x * 2 + 1 <= tot) tar = w[x * 2] < w[x * 2 + 1] ? x * 2 : x * 2 + 1;
    // 如果有左节点，tar 取两节点的最小值
    if(w[x] < w[tar]) return; // 不违反小根堆性质说明修复成功，返回
    swap(w[x], w[tar]); // 否则和小的交换
    repair(tar); // 继续修复
}
void pop() { // 弹掉最小值
    swap(w[1], w[tot--]); // 压行技巧，交换尾部节点并将尾节点设为无效
    repair(1); // 从根节点修复
}
```

时间复杂度也为 $O(\log n)$。这样，就在优秀的时间复杂度内完成了这道题。

但是！上面的实现过程是不是……复杂了点？很幸运，STL 提供了**优先队列**这种数据结构，即 `priority_queue`，底层就是用堆实现的，头文件还是队列的 `queue`。优先队列有以下几种常用操作：

- `priority_queue <int> q;` 建立一个 `int` 类型的优先队列（大根堆） $q$。

- `priority_queue <int, vector<int>, greater<int> > q;` 建立一个小根堆 $q$。

- `q.top();` 查询最大（小）值。

- `q.pop();` 弹出最大（小）值。

- `q.push(x);` 将 $x$ 加入队列。

借助 STL，这道题瞬间变得很简单了。STL 代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, op, x;
priority_queue <int, vector <int>, greater <int> > q; // 注意定义小根堆的格式
int main() {
    cin >> n;
    while(n--) {
        cin >> op; // 哪种操作
        if(op == 1) {
            cin >> x;
            q.push(x); // 插入，使用 push()
        } else if(op == 2)
            cout << q.top() << endl; // 查询最小值，使用 top()
        else q.pop(); // 弹出最小值，使用 pop()
    }
    return 0;
}
```


完结撒花！

---

## 作者：郑朝曦zzx (赞：8)

## 二叉堆的简介
二叉堆是一种基于二叉树的数据结构，支持插入元素，删除、询问极值的操作，单次时间复杂度为 $O(\log n)$。

本题需要维护一个小根堆，对于任意父子节点关系，满足**父亲结点的权值小于等于其儿子节点的权值**。

比如这个就是一个合法的小根堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/1cd6943m.png)

## 二叉堆的操作

- 父子关系的表示
```cpp
#define fa (pos >> 1)
#define ls (pos << 1)
#define rs (ls | 1)
```
像线段树一样存节点，直接查询父子关系。

- 向上调整 `void up(int pos)`

从 $pos$ 号节点，往根找，如果不符合小根堆的性质，交换父子节点。
```cpp
void up(int pos)
	{
		
		while (fa && num[fa] > num[pos])
		{
			swap(num[fa], num[pos]);
			pos = fa;
		}
	}
```
只要存在父亲，而且不满足堆的性质，交换父子。
- 插入（图中权值为 1 的节点为根）

**在最后插入，然后一路上调即可，举个例子。**

比如我们要在这个结构下插入一个 $3$。


1. 第一步，把他连到任意一个叶子节点下，比如连到 $6$ 下面，如图。



容易发现，现在的树违反了小根堆的性质，所以我们需要调整。

2. 交换 $3$ 和 $6$，如图。

3. 接着，交换 $3$ 和 $4$，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/zdsbcvc8.png)

请同学们对照着图和代码理解一下。

```cpp
void insert(int x)
	{
		num[++cnt] = x;
		up(cnt);
	}
```


- 向下调整 `void down(int pos)`

和向上调整类似，从某个节点向下处理父子关系，建议读者自行对照代码进行理解。

```cpp
void down(int pos)
	{
	// 从上往下递归，如果某个儿子的值比父亲小
	// 就把值最小的儿子与父亲交换 
		while (1)
		{
			int tmp = pos;
			if (ls <= cnt && num[ls] < num[tmp])
			tmp = ls;
			if (rs <= cnt && num[rs] < num[tmp])
			tmp = rs;
			if (tmp == pos) break;
			swap(num[tmp], num[pos]);
			pos = tmp;
		}
	}
```

- 删除最小值 `void erase()`

直接把根的权值改成编号最大点节点的权值，向下调整一次，并且扔掉标号最大点节点。
```cpp
void erase()
	{
		num[1] = num[cnt];
		--cnt;
		down(1);
	}
```

比如在这个堆中，我要删除最小值 1。

经过调整，新的堆长这个样子。

![](https://cdn.luogu.com.cn/upload/image_hosting/bqnmg6z3.png)

- 询问最小值 `int top()`

根据性质直接返回根节点权值即可。

- 时间复杂度说明：由于节点是一个一个开点，所以二叉树是“矮胖”的，层数为 $\log \ n$ 级别的，所以单次插入删除询问操作就是 $O(\log n)$。

## 完整代码

手写二叉堆：

```cpp
/* 【模板】堆 Luogu P3378
小根堆得结构：父亲节点的值 < 儿子节点的值
时间复杂度：
插入：O(log n)
删除：O(log n)
查询最大、最小值：O(1) 
*/
#include <cstdio>
#include <algorithm>
#define fa (pos >> 1)
#define ls (pos << 1)
#define rs (ls | 1)
using namespace std;
const int mxn = 1000010;
struct heap
{ // 小根堆 
	int num[mxn], cnt;
	void up(int pos)
	{
		// 从下往上找，如果父亲的值大于儿子，交换父亲与儿子 
		while (fa && num[fa] > num[pos])
		{
			swap(num[fa], num[pos]);
			pos = fa;
		}
	}
	void down(int pos)
	{
	// 从上往下递归，如果某个儿子的值比父亲小
	// 就把值最小的儿子与父亲交换 
		while (1)
		{
			int tmp = pos;
			if (ls <= cnt && num[ls] < num[tmp])
			tmp = ls;
			if (rs <= cnt && num[rs] < num[tmp])
			tmp = rs;
			if (tmp == pos) break;
			swap(num[tmp], num[pos]);
			pos = tmp;
		}
	}
	void insert(int x)
	{
		num[++cnt] = x;
		up(cnt);
	}
	void erase()
	{
		num[1] = num[cnt];
		--cnt;
		down(1);
	}
	int top()
	{ return num[1]; }
}data;
int n;
int main()
{
	scanf("%d", &n);
	for (int i = 1, opt, x; i <= n; ++i)
	{
		scanf("%d", &opt);
		if (opt == 1)
		{
			scanf("%d", &x);
			data.insert(x);
		}
		else if (opt == 2) printf("%d\n", data.top());
		else data.erase();
	}
	return 0;
}
```

手写二叉堆（template 模板+代码精简版）
```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T, size_t mxn>
struct Heap
{
	int cnt;
	T val[mxn + 5];
	Heap() { cnt = 0; }
	#define fa (pos >> 1)
	#define ls (pos << 1)
	#define rs (ls | 1)
	void insert(T x)
	{
		val[++cnt] = x;
		int pos = cnt;
		while (fa && val[fa] > val[pos])
		{
			swap(val[fa], val[pos]);
			pos = fa;
		}
	}
	void erase()
	{
		val[1] = val[cnt--];
		int pos = 1;
		while (1)
		{
			int tmp = pos;
			if (ls <= cnt && val[ls] < val[tmp]) tmp = ls;
			if (rs <= cnt && val[rs] < val[tmp]) tmp = rs;
			if (tmp == pos) break;
			swap(val[pos], val[tmp]);
			pos = tmp;	
		}
	}
	T top() { return val[1]; }
	#undef fa
	#undef ls
	#undef rs
};
Heap <int, 1000000> data;
int n;
int main()
{
	scanf("%d", &n);
	for (int i = 1, opt, x; i <= n; ++i)
	{
		scanf("%d", &opt);
		if (opt == 1)
		{
			scanf("%d", &x);
			data.insert(x);
		}
		else if (opt == 2) printf("%d\n", data.top());
		else data.erase();
	}
	return 0;
}
```


STL 实现：
```cpp
//【模板】堆 Luogu P3378 STL 实现 
#include <bits/stdc++.h>
using namespace std;
priority_queue <int, vector <int>, greater <int> > q;
int n;
int main()
{
	scanf("%d", &n);
	for (int i = 1, opt, x; i <= n; ++i)
	{
		scanf("%d", &opt);
		if (opt == 1) scanf("%d", &x), q.push(x);
		else if (opt == 2) printf("%d\n", q.top());
		else q.pop();
	}
	return 0;
}
```


---

## 作者：return_second (赞：4)

`upd on 2025.04.20：说明了对建树方法的限制条件。`

# 算法介绍

堆一般来说是一个二叉堆，即一棵二叉树，分为大根堆和小根堆。大根堆就是父节点的权值大于子节点，小根堆就是父节点的权值小于子节点。

显然，题目要求最小数，即小根堆，所以下文的操作就是小根堆。

本题解仅讲述手写堆的方法，`priority_queue` 的方法请移步至其他题解。

## 储存方法

有一种常用的用数组存储树的方法。假设父节点的编号是 $i$，那子节点的编号就是 $2i$ 和 $2i+1$。如下图所示：

![](https://oi-wiki.org/ds/images/binary-heap-array.svg)

但是这种建树方法是有限制的。只有当前的树是完全二叉树时才可以使用该方法。因为下文中新节点默认会插到左边，所以堆是一种完全二叉树。

## 插入操作

插入操作就是把一个节点插入树中，且满足本来的性质。最简单的方法就是先把它变成一个叶子结点，然后不断与父节点比较，如果满足要求就交换。如图所示：

![](https://oi-wiki.org/ds/images/binary_heap_insert.svg)

（请原谅我放了大根堆的图）

给出代码：

```cpp
void push(int x)
{
	a[++len]=x;//变成叶子节点
	int now=len;
	while(now!=1&&a[now]<=a[now>>1])//如果满足要求就交换
	{
		swap(a[now],a[now>>1]);
		now>>=1;//除以二，变成父节点
	}
}
```

## 删除操作

如果直接删除根节点，就会变成两个堆，显然不好处理。一种常用的方法是把根节点和最后一个节点交换后，直接删除。

那怎么使堆仍然满足性质呢？其实只要把新的根节点不断往下拉，与比自己更优的子节点交换。但与刚刚不同的是，要在两个子节点中取最优的一个交换。

给出代码：

```cpp
void pop()
{
	swap(a[1],a[len--]);//交换并删除
	int now=1;
	while((now<<1)<=len)
	{
		int	nxt=now<<1;//寻找子节点
		if(nxt+1<=len&&a[nxt]>a[nxt+1])//两个子节点取最优
			nxt++;
		if(a[now]>a[nxt])//如果更优就交换
		{
			swap(a[now],a[nxt]);
			now=nxt;
		}
		else
		{
			break;
		}
	}
}
```

## 查询操作

这个没什么好说的，直接输出最优的根节点即可。

# 正确性证明

因为我们在每次操作时都保证满足堆的性质，所以是正确的。时间复杂度方面，最坏情况是从叶子结点一直到根节点或者从根节点到叶子结点，是树的高度，也就是 $\log n$，单次操作的时间复杂度就是 $O(\log n)$。

# 代码实现

给出代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e6+5;
int n;
int len,a[N];
void push(int x)
{
	a[++len]=x;
	int now=len;
	while(now!=1&&a[now]<=a[now>>1])
	{
		swap(a[now],a[now>>1]);
		now>>=1;
	}
}
void pop()
{
	swap(a[1],a[len--]);
	int now=1;
	while((now<<1)<=len)
	{
		int	nxt=now<<1;
		if(nxt+1<=len&&a[nxt]>a[nxt+1])
			nxt++;
		if(a[now]>a[nxt])
		{
			swap(a[now],a[nxt]);
			now=nxt;
		}
		else
		{
			break;
		}
	}
}
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		int op,x;
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d",&x);
			push(x);
		}
		else if(op==2)
			printf("%d\n",a[1]);
		else
			pop();
	}
    return 0;
}
```

# 参考文献

[二叉堆 - OI Wiki](https://oi-wiki.org/ds/binary-heap/)，本文所有配图也来自于此。

---

## 作者：zsq9 (赞：3)

[AC 记录 1](https://www.luogu.com.cn/record/213831526)

[AC 记录 2](https://www.luogu.com.cn/record/213836759)

## 题目~~大意~~

给定一个数列，初始为空，三种操作：

1. 给定一个整数 $x$，请将 $x$ 加入到数列中。
2. 输出数列中最小的数。
3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。

## 算法介绍

题目中有~~模板两个字所以想到堆~~。堆是一个完全二叉树，堆分为小根堆和大根堆，小根堆是子节点大于根节点，所以堆头最是小的；大根堆是子节点小于根节点，所以堆头是最大的。

## 正确性证明

如图，这是一个严格的小根堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/u3zmiit8.png)

如果我们要向小根堆里插入 1。

![](https://cdn.luogu.com.cn/upload/image_hosting/q5u8zv4f.png)

成了这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/b2235obm.png)

我们发现这样就不符合小根堆子节点大于根节点了，我们就要交换，来维护小根堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/9n8zepnp.png)

我们发现还是不符合小根堆性质还要交换。

![](https://cdn.luogu.com.cn/upload/image_hosting/zsjx2eah.png)

~~cao 还是不符合~~，我们还要继续维护。

![](https://cdn.luogu.com.cn/upload/image_hosting/p0bq5fmq.png)

现在符合了，我们就完成了插入，容易发现只要交换 $\log{n}$ 次，因为堆是一个完全二叉树，最多只有 $\log{n+1}$ 层，所以插入是 $\log{n}$ 的复杂度，而修复也是一层一层的修复，所以也是 $\log{n}$ 的，求最小值直接输出堆顶 $O(1)$ 的。

我们发现，直接删除堆顶会直接破坏堆，那么我们就先把堆顶和底下的数交换再删除，再修复就好了，时间复杂度是 $\log{n}$ 。

## STL 方法

如果我们在比赛时肯定不想写这么长的代码，那该怎么办呢？我们可以用 STL 中的 `priority_queue`，它是这样定义的。

> ```cpp
> priority_queue<int> q;//默认大根堆
> priority_queue<int,vector<int>,greater<int> > q;//小根堆
> ```

这样就不用手写堆了。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,top,head[1000005];
void push_up(ll x){
	if(x==1||head[x]>head[x/2])return ;
	swap(head[x],head[x/2]);
	push_up(x/2);
}
void push(ll x){
	head[++top]=x;
	push_up(top);
}
ll head_top(){
	return head[1];
}
void pop_repair(ll x){
	ll top2=x*2;
	if(top2+1<=top)
		if(head[x*2]>head[x*2+1])++top2;
	if(head[x]<head[top2]||x*2>top)return;
	swap(head[x],head[top2]);
	pop_repair(top2);
}
void pop(){
	swap(head[1],head[top--]);
	pop_repair(1);
}
int main(){
	cin>>n;
	while(n--){
		ll op;
		cin>>op;
		if(op==1){
			ll x;
			cin>>x;
			push(x);
		}else if(op==2){
			cout<<head_top()<<"\n";
		}else{
			pop();
		}
	}
	
	
	
	return 0;
}
```

STL

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
priority_queue<ll,vector<ll>,greater<ll> > q;
ll n;
int main(){
	cin>>n;
	while(n--){
		ll op;
		cin>>op;
		if(op==1){
			ll x;
			cin>>x;
			q.push(x);
		}else if(op==2){
			cout<<q.top()<<"\n";
		}else{
			q.pop();
		}
	}
	
	
	
	return 0;
}
```

---

## 作者：cute_zczc_qwq (赞：1)

# [P3378](https://www.luogu.com.cn/problem/P3378) 【模版】 堆

## 算法介绍：
我们可以简单的把堆理解为一棵完全二叉树。

### 堆的作用：
我们可以使用堆来解决一组数据中既有插入，删除，又有查询最大值，最小值的问题。

### 堆的性质：
小根堆中，左孩子和右孩子的值总是大于其祖先的值，树的根节点最小。

大根堆于小根堆相反，左孩子和右孩子的值总是小于其祖先的值，树的根节点最大。

上述的堆中的任意一棵子树具有相同的性质。

### 具体操作：
以小根堆为例：

这就是一个小根堆：

我们可以用一维数组来储存堆。
```cpp
int a[1000005];
```

![](https://cdn.luogu.com.cn/upload/image_hosting/23tj7jtt.png)


插入节点时，我们先将它放在堆的最后。

![](https://cdn.luogu.com.cn/upload/image_hosting/i19rsh7u.png)


我们如果发现其值小于其祖先的值，就将他们交换，直到其值大于其祖先的值或它已经为根节点。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tengodq.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/kj6mi3ls.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/49hx3ss8.png)

代码实现：
```cpp
void swap(int &a,int &b){
    a += b;
    b = a-b;
    a -= b;
}
void update1(int f){
	a[r] = f;
	int r1 = r;
    while(r1/2 >= 1 && a[r1/2] > a[r1]){
        swap(a[r1],a[r1/2]);
        r1 /= 2;
    }
}
```

删除最小节点时，我们先让堆顶和堆尾交换，堆的大小 $ -1 $。

![](https://cdn.luogu.com.cn/upload/image_hosting/1nn8frme.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ghtsidka.png)

从它的两个孩子中选一个小的，交换，直到其孩子大于它或其已经为叶节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/307efg8y.png)

### 代码实现：

```cpp
void update2(){
	int f = 1,b;
	a[1] = 0;
	swap(a[1],a[r]);    //交换堆顶和堆尾。
	r--;    //堆的大小 -1 。
	while(2*f <= r){    //当 a[f] 有至少一个孩子时。
		b = 2*f;
		if(2*f+1 <= r && a[b+1] < a[b]){
			b++;
		}    //求出 a[2*f] 和 a[2*f+1] 中的最小值。
		if(a[b] < a[f]){
			swap(a[f],a[b]);    //如果 a[f] 小于 a[2*f] 和 a[2*f+1] 中的最小值，就交换。
		}
		else{    //如果不小于的话结束更新，因为 a[f] 已经小于 a[f] 为根节点的子树的所有其它元素了。
			return;
		}
		f = b;
	}
}
```
### 正确性证明：
显然，我们只要知道堆顶的值，孩子之间的顺序无所谓，而每次插入节点时都会更新一遍，所以最小值就是堆顶的值。

因为树高为 $ \log_{}{n} $，所以此算法单次更新时间复杂度为 $ O(\log_{}{n} )$，单次查询时间复杂度为 $ O(1) $，总时间复杂度为 $ O(n\log_{}{n} ) $，足以通过此题。

### 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],r = 0,op,s;    //r 为目前堆的大小。
void swap(int &a,int &b){    //交换。
    a += b;
    b = a-b;
    a -= b;
}
void update1(int f){    //插入节点，f 为要插入的数。
	a[r] = f;
	int r1 = r;
    while(r1/2 >= 1 && a[r1/2] > a[r1]){
        swap(a[r1],a[r1/2]);
        r1 /= 2;
    }
}
void update2(){    //删除根节点。
	int f = 1,b;
	a[1] = 0;
	swap(a[1],a[r]);
	r--;
	while(2*f <= r){
		b = 2*f;
		if(2*f+1 <= r && a[b+1] < a[b]){
			b++;
		}
		if(a[b] < a[f]){
			swap(a[f],a[b]);
		}
		else{
			return;
		}
		f = b;
	}
}
int main(){
    cin>>n;
	for(int i = 1;i <= n;i++){
		cin>>op;
		if(op == 1){
			r++;
			cin>>s;
			update1(s);
		}
		else if(op == 2){    //查询最小值，也就是小根堆堆顶。
			cout<<a[1]<<endl;
		}
		else{
			update2();
		}
	}
    return 0;
}
```


## ~~偷懒~~ STL 做法：
使用 STL 中的优先队列 priority_queue，它能自动排序。

### 头文件：
```cpp
#include<queue>
```
### 格式：
```cpp
priority_queue< 数据类型 > 名称 ;    //默认大根堆。

//大根堆：
priority_queue< 数据类型, vector< 数据类型 >,less< 数据类型 > > 名称 ;

//小根堆：
priority_queue< 数据类型, vector< 数据类型 >,greater< 数据类型 > > 名称 ;

//最后的两个 '>' 不能写在一起，">>" 是右移运算符。
```
### 语法：

```cpp
q.size();    //返回值为 q 里元素个数。
q.empty();    //检测 q 是否为空，空则返回 1，否则返回 0。
q.push(k);    //在 q 中插入 k。
q.pop();    //q 的第1个元素出队。
q.top();    //返回值为 q 的第 1 个元素。
```

### STL 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    priority_queue< long long,vector<long long>,greater<long long> > Q;
    int n,a,f;
    cin>>n;
    for(int i = 1;i <= n;i++){
        cin>>f;
        if(f == 1){
            cin>>a;
            Q.push(a);    //a 入队。
        }
        else if(f == 2){
            cout<<Q.top()<<endl;    //输出 Q 中最小的元素。
        }
        else{
            Q.pop();    //Q 中最小的元素出队。
        }
    }
    return 0;
}
//还是爱用优先队列，简单又不容易错。
```

---

## 作者：huyinuo (赞：1)

# P3378 【模板】堆 题解
## 前置知识
### 什么是堆？
堆是一种树形结构，树的根在堆中就是堆顶，堆顶总是以你定义类型的最优值。堆有两种，一种是小根堆，堆顶是最小值。一种是大根堆，堆顶是最大值。
### 堆的操作
堆的操作有两种，上浮和下沉。顾名思义，上浮即为添加一个值后使其慢慢往上进行比较确认位置。下沉就是某个节点按优先级下降，或是替换堆顶的值。
## 题目分析
就是实现一个堆，有上浮，下沉，输出根三种操作。
## Code
我这里提供两种写法，手写堆和 STL 中的优先队列。
### 手写堆
手写堆理解起来有些困难，竞赛中经常不用。~~大佬轻喷~~。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 10;
int n;
int q[maxn],len;           //len记录当前长度
int op,x;
void push(int x)           //插入新元素
{
    q[++ len] =x;
    int i = len;
    //上浮操作
    while(i > 1 && q[i] < q[i / 2]) 
    {
        swap(q[i],q[i / 2]);
        i /= 2;
    }
}
void pop() //下沉 删除堆顶
{
    q[1] = q[len --];
    int i = 1;
    while(2 * i <= len)
    {
        int ls = 2 * i; //左儿子 
        if(ls < len && q[ls + 1] < q[ls]) ls ++;
        if(q[ls] < q[i])
        {
            swap(q[ls],q[i]);
            i = ls;
        }
        else break;
    }
}
int main()
{
    scanf("%d",&n);
    while(n --)
    {
        scanf("%d",&op);
        if(op == 1) scanf("%d",&x),push(x);
        if(op == 2) printf("%d\n",q[1]);
        if(op == 3) pop();
    }
    return 0;
}
```
### 优先队列
优先队列底层基于堆，可以方便的插入和弹出。在竞赛中可用于优化代码。

### 关于优先队列
优先队列定义
```cpp
priority_queue<int,vector<int> > q; //小根堆
priority_queue<int,vector<int>, greater<int> > q; //大根堆
```
优先队列的内置函数
```cpp
q.push(x); //插入     O(log n)
q.pop();   //弹出根   O(log n)
q.top();   //返回对顶元素 O(1)
q.size();  //返回长度     O(1)
```
那么这道题就很简单了，插入 $\operatorname{push}$，弹出 $\operatorname{pop}$，返回栈顶 $\operatorname{top}$。
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>, greater<int> > q;
//priority_queue<int,vector<int> > q;
int n;
long long ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int op;
		scanf("%d",&op);
		if(op==1)
		{
			int x;
			scanf("%d",&x);
			q.push(x); //插入
			continue;
		}
		else if(op==2)
		{
			printf("%d\n",q.top()); //输出
			continue;
		}
		else if(op==3)
		{
			q.pop(); //弹出
			continue;
		}
	}
	return 0;
}
```
不管是插入还是弹出的时间复杂度都是 $\log n$，总时间复杂度 $O(n\log n)$。
## 其他
刚刚提到了，优先队列可用于优化其他算法，例如 $\operatorname{Dijstra}$。可用优先队列找到当前点已有最短路最短的开始走。

---

## 作者：pengyirui (赞：1)

# 前置芝士-二叉树
**编者注：关于树，请到[此处](https://baike.baidu.com/item/%E6%A0%91/2699484?fromModule=lemma_sense-layer#viewPageContent)查看。**        

二叉树，是一种基本的数据结构，属于一棵树，但是对于每一个父亲节点只可能有 $0$、$1$ 或者 $2$ 个孩子节点。
## 满二叉树
对于每一层，节点都是满的二叉树。         

关于满二叉树：
- 满二叉树的节点数量（$n$ 表示深度）：$2^{n+1}-1$ 个。
- 满二叉树的叶子节点数量（$n$ 表示深度）：$2^n$ 个。
## 完全二叉树
一棵深度为 $k$ 的有 $n$ 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 $1\le i\le n$ 的结点与满二叉树中编号为 $i$ 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
### 完全二叉树的性质
1. 对于一棵节点数为 $n$ 的完全二叉树，深度为：$$\left\lfloor \log_{2} n + 1\right\rfloor$$；
2. 如果对一棵有 $n$ 个结点的完全二叉树的结点按层序编号，则对任一结点 $i (1\le i\le n) $ 有：
    - 如果 $i=1$，则结点 $i$ 是二叉树的根，无双亲；如果 $$i>1$$，则其父亲是结点 $\dfrac{i}{2}$；
    - 如果 $$2\times i>n$$，则结点 $i$ 无左孩子，否则其左孩子是结点 $2\times i$；
    - 如果 $2\times i+1>n$，则结点 $i$ 无右孩子，否则其右孩子是结点 $2\times i+1$。
# 堆的介绍
## 堆的定义
堆是一棵完全二叉树（知道前置芝士的用途了吧）。    
对于小根堆：每一个儿子节点都大于父亲节点；   
对于大根堆：每一个儿子节点都小于父亲节点。
## 堆的操作（画风不好，不喜勿喷）
### 建立堆
#### 代码
```cpp
int dui[999999];
int shuliang=0;
```
### 查询
输出根即可。
#### 代码
```cpp
int chaxun()
{
	return dui[1];
}
```

### 插入
假设有下面这颗小根堆：
![](https://cdn.luogu.com.cn/upload/image_hosting/vlmejujm.png)        
我们现在要插入数字 $2$。    

1. 插入堆尾。![](https://cdn.luogu.com.cn/upload/image_hosting/rju4mb04.png)
2. 检查父节点，如果小于就交换。![](https://cdn.luogu.com.cn/upload/image_hosting/jvedlg8i.png)
3. 重复第二步，直到大于父亲节点。![](https://cdn.luogu.com.cn/upload/image_hosting/jvedlg8i.png)
4. 结束。![](https://cdn.luogu.com.cn/upload/image_hosting/jvedlg8i.png)
#### 代码
```cpp
void tiaozheng(int jiedian)//字面意思
{
	if(jiedian==1||dui[jiedian]>dui[jiedian/2])return;//完工！！！ 
	swap(dui[jiedian],dui[jiedian/2]);
	tiaozheng(jiedian/2);
} 
void in(int yuansu)
{
	dui[++shuliang]=yuansu;
	tiaozheng(shuliang);
}
```
### 删除
还是那一个小根堆。
![](https://cdn.luogu.com.cn/upload/image_hosting/vlmejujm.png)
1.  根与堆尾部交换。![](https://cdn.luogu.com.cn/upload/image_hosting/v2u0z5nn.png)
2.  删除堆尾。![](https://cdn.luogu.com.cn/upload/image_hosting/63wnj5dh.png)
3.  将堆顶与左右儿子比较，选取小的交换。![](https://cdn.luogu.com.cn/upload/image_hosting/81k40pze.png)
4.  重复第3步，直到满足堆的性质。![](https://cdn.luogu.com.cn/upload/image_hosting/81k40pze.png)
5.  结束。![](https://cdn.luogu.com.cn/upload/image_hosting/81k40pze.png)
#### 代码

```cpp
void tiaozheng2(int jiedian)//字面意思
{
	if(jiedian*2>shuliang)return; 
	int anss=jiedian*2;
	if(dui[anss]>dui[anss+1]&&(anss+1)<=shuliang)anss++;
    if(dui[jiedian]<dui[anss])return;
    swap(dui[jiedian],dui[anss]);
	tiaozheng2(anss);
} 
void pop()
{
	swap(dui[1],dui[shuliang--]);
	tiaozheng2(1);
}
```
# 手写堆代码
~~代码一点都不长，只花了我半个小时。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int dui[999999];
int shuliang=0;
int top()
{
	return dui[1];
}
void tiaozheng(int jiedian)//字面意思
{
	if(jiedian==1||dui[jiedian]>dui[jiedian/2])return;//完工！！！ 
	swap(dui[jiedian],dui[jiedian/2]);
	tiaozheng(jiedian/2);
} 
void push(int yuansu)
{
	dui[++shuliang]=yuansu;
	tiaozheng(shuliang);
}
void tiaozheng2(int jiedian)//字面意思
{
	if(jiedian*2>shuliang)return; 
	int anss=jiedian*2;
	if(dui[anss]>dui[anss+1]&&(anss+1)<=shuliang)anss++;
    if(dui[jiedian]<dui[anss])return;
    swap(dui[jiedian],dui[anss]);
	tiaozheng2(anss);
} 
void pop()
{
	swap(dui[1],dui[shuliang--]);
	tiaozheng2(1);
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
    for(int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a;
		switch(a)
		{
			case 1:
				cin>>b;
				push(b);
				break;
			case 2:
				cout<<top()<<endl;
				break;
			case 3:
				pop();
		}
	 } 
	return 0;
}
```

# 关于堆
大家可以发现，太难写了……（说实话，我也不想写）    
推荐一个好东西：STL。

```cpp
#include <queue>
priority_queue<int,vector<int>,greater<int> > c;      //定义从小到大的int类型的优先队列
priority_queue<int> c;                                //定义从大到小的int类型的优先队列 
c.push();        //压入 
c.pop();         //弹出队首元素 
c.top();         //访问队首元素 
c.empty();       //判断队列是否为空
//如是结构体必须重载'<' 
```
# STL代码

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> >q;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		if(a==2)cout<<q.top()<<endl;
		if(a==3)q.pop();
		if(a==1)
		{
			int b;
			cin>>b;
			q.push(b);
		}
	}
	return 0;
}
```
完结撒花！！！

---

## 作者：hhy0911 (赞：0)

# 一、题目大意
维护一个数据结构，可以支持插入、删除、查询最小值。

首先可以想到维护数组，查询是 $O(n)$ 的，插入、删除是 $O(1)$ 的。但是对于 $n \le 10^{6} $ 的范围， $O(n)$ 的复杂度很明显不行了。所以我们需要一个更好的数据结构来维护。此时**堆**就登场了！！

堆是一个重要的数据结构，可以用来维护最小值（或者最大），并且时间复杂度大大的优化了。下面我来介绍一下。下图是堆的一个示例：

![](https://cdn.luogu.com.cn/upload/image_hosting/2ospy7sc.png)
------------
# 二、介绍
1. 从上图可见堆是一个完全二叉树，即只有最后一层不是满的的一种二叉树。
1. 堆可以分为大根堆和小根堆，顾名思义，就是每个节点都比儿子大（或者小）的。不过这个“大”“小”也可以由你自己定义。不过后面的内容都默认是小根堆，跟题目一致。大根堆只要修改判断条件即可。

它可以支持三种操作，分别为插入，删除和查询最小值。那么现在我来分别介绍这几种操作怎么实现。

# 三、代码实现

## 一、存储方式

因为堆是一个完全二叉树，所以存储堆完全可以用数组来模拟二叉树，即对于每个节点 $i$，他的右儿子编号为 $2i$，左儿子编号为 $2i+1$。并且根节点的编号为 $1$。存储代码：


```cpp
const int N = 1e6 + 7;
typedef long long ll;
ll heap[N];//堆
int n, sum = 0;//sum是堆内元素的数量

```



---



## 二、查询
查询的代码很简单，因为堆的性质保证了堆的根是最小的，所以再查询时，只需要取堆顶就可以了。代码如下：
```cpp
ll top() {
	//返回堆顶
	return heap[1];
}
```


------------

## 三、插入
为了保证堆的性质（即堆是一颗完全二叉树），我们再插入元素时，必须将其加入在这个树的尾部。如下

![](https://cdn.luogu.com.cn/upload/image_hosting/85qmng9u.png)

但是加入这个节点后，小根堆的性质却丧失了。因此我们必须要进行**修复**，来保证这个性质。可是如何修复呢？其实很简单。我们只要保证儿子比父亲大即可。所以插入后，如果这个节点比父亲小，就把他们交换。

![](https://cdn.luogu.com.cn/upload/image_hosting/81jcnyfb.png)

此时这个节点交换后满足了这个性质，就不需要交换了，但是如果不满足，则继续进行修复即可。不过要注意如果这个节点到达堆顶，也不需要修复了。代码如下：
```cpp
void push(int u) {
	//将u加入堆
	heap[++sum] = u;
	int p = sum;//u所在的位置
	while (1) {
		if (p == 1)break;//到达根节点
		if (heap[p / 2] > heap[p]) {
			//不满足小根堆的性质
			swap(heap[p / 2], heap[p]);
			p = p / 2;//交换
		}
		else {
			break;//满足性质则退出
		}
	}
}
```


------------
## 四、删除
我们初学时可能会认为要把堆顶删掉，但是这样导致堆被一分为二。所以要用另一种方法来删除。就是**先把堆顶和最后一个元素交换**，再删除最后一个元素（即原来的堆顶）。

![](https://cdn.luogu.com.cn/upload/image_hosting/p7j2g92y.png)

但是现在小根堆的性质可能又保不住了，因此我们要再次进行**修复**。这次修复和插入类似，不过方向不同，是由顶到底部。每次修复时，选取儿子中**最大**的一个，如果它比父亲小，那么就交换，接下来如果仍然不满足小根堆的性质，则继续修复。否则就可以退出了。

![](https://cdn.luogu.com.cn/upload/image_hosting/t60cehmz.png)

代码如下：
```cpp
void pop() {
	swap(heap[1], heap[sum--]);//将堆顶和堆尾互换，并删除堆尾
	int p = 1;
	while (1) {
		if (p * 2 > sum)break;//到达底部
		int tar = p * 2;
		if (p * 2 + 1 <= sum) {
			tar = heap[p * 2] < heap[p * 2 + 1] ? p * 2 : p * 2 + 1;
			//选择子节点中最小的一个
		}
		if (heap[p] > heap[tar]) {
			//不满足性质则继续修复
			swap(heap[p], heap[tar]);
			p = tar;
		}
		else {
			//满足性质则退出
			break;
		}
	}
}
```
## 五、时间复杂度

可以看出，查询的时间复杂度明显是常数的，即 $O(1)$。但是插入和删除呢？因为堆是一个完全二叉树，所以树高是 $\log n$ 的。而每次插入、删除都会在树上移动一层，所以一共是 $\log n$ 次。时间复杂度为 $O(\log n)$ 。


------------

# 四、AC代码
```cpp
#include<iostream>
using namespace std;
const int N = 1e6 + 7;
typedef long long ll;
ll heap[N];//堆
int n, sum = 0;//sum是堆内元素的数量
void push(int u) {
	//将u加入堆
	heap[++sum] = u;
	int p = sum;//u所在的位置
	while (1) {
		if (p == 1)break;//到达根节点
		if (heap[p / 2] > heap[p]) {
			//不满足小根堆的性质
			swap(heap[p / 2], heap[p]);
			p = p / 2;//交换
		}
		else {
			break;//满足性质则退出
		}
	}
}
void pop() {
	swap(heap[1], heap[sum--]);//将堆顶和堆尾互换，并删除堆尾
	int p = 1;
	while (1) {
		if (p * 2 > sum)break;//到达底部
		int tar = p * 2;
		if (p * 2 + 1 <= sum) {
			tar = heap[p * 2] < heap[p * 2 + 1] ? p * 2 : p * 2 + 1;
			//选择子节点中最小的一个
		}
		if (heap[p] > heap[tar]) {
			//不满足性质则继续修复
			swap(heap[p], heap[tar]);
			p = tar;
		}
		else {
			//满足性质则退出
			break;
		}
	}
}
ll top() {
	//返回堆顶
	return heap[1];
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int op, x;
		cin >> op;
		if (op == 1) {
			cin >> x;
			push(x);
			//将x加入堆
		}
		else if (op == 2) {
			cout << top() << '\n';
			//输出最小值
		}
		else {
			pop();
			//删除最小值
		}
	}
	return 0;
}
```


------------

# 五、介绍STL优先队列
在C++中，有一个 STL 叫优先队列**即 priority_queue**，它的底层就是堆，它在 <queue> 头文件中。我们在平时用到堆的时候，可以用它代替（用处完全一样！）。介绍一下优先队列的使用方式。

## 一、创建
和 queue 类似，直接用
```cpp
priority_queue<int> q;
```
即可。默认是大根堆。小根堆可以用
```cpp
priority_queue<int, vector<int>, greater<int> > q;
```

## 二、使用
其实优先队列的操作的函数名和我的代码中的函数名相同。分别为：
  ```cpp
q.top()//查询
q.pop()//删除
q.push()//插入
q.empty()//是否为空
q.size()//大小
```
# 六、结语

谢谢大家！！！

---

## 作者：b__b (赞：0)

# 堆
## 什么是堆？
摘自百度百科：
> 堆（heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：
> - 堆中某个结点的值总是不大于或不小于其父结点的值；
> - 堆总是一棵完全二叉树。
> 
> 将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。
## 如何实现？
下列有两种方法：手写堆与 STL 大法，以下主要讲解手写堆。

手写堆有两种操作：上浮或下沉，这里用大根堆举例，小根堆原理相近。

（下文图片来自 <https://blog.csdn.net/xiaomucgwlmx/article/details/103522410>）
### 上浮
某个节点的优先级上升，或者在堆底部加入新元素时，要从下至上恢复堆的顺序。

例如，对于下图的堆：

![](https://cdn.luogu.com.cn/upload/image_hosting/00gg41to.png)

如果我们插入一个 $16$，那么会先变成这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/v2ekktl6.png)

然后 $16$ 往上一瞅：欸，上面的 $2$ 怎么比我小？让他滚下来！

于是我们交换 $16$ 与 $2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/39dg6inm.png)

但是这样还是不够的，因为 $16$ 发现上面的 $10$ 还是比他小，所以还是需要让 $16$ 与 $10$ 交换。

于是我们得到：

![](https://cdn.luogu.com.cn/upload/image_hosting/2weg4acx.png)

这时满足了堆的性质，于是插入完成。
### 下沉
某个节点的优先级下降，或者弹出堆顶时，要从上到下恢复堆的顺序。

还是这个堆：

![](https://cdn.luogu.com.cn/upload/image_hosting/00gg41to.png)

现在我们删除 $10$，这时我们发现这个二叉树没有头了！

![](https://cdn.luogu.com.cn/upload/image_hosting/xcak78by.png)

怎么办？那我们先把 $1$ 放上去吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/chwn1wez.png)

放上去之后 $1$ 发现：不对！$7$ 比我大！

于是 $1$ 与 $7$ 交换：

![](https://cdn.luogu.com.cn/upload/image_hosting/nlkm290o.png)

但是交换完后 $5$ 又大于 $1$ 了，因此继续交换：

![](https://cdn.luogu.com.cn/upload/image_hosting/mfztrwro.png)

于是下沉完成。
## 复杂度
因为堆是一个完全二叉树，因此只有 $\log_2n$ 层，上浮和下沉最多只会进行 $\log_2n$ 次，因此上浮和下沉的复杂度都为 $\mathcal{O}(\log_2n)$，如果有 $m$ 次插入或删除操作，复杂度为 $\mathcal{O}(m\log_2n)$。输出最大或最小值可直接输出堆顶，复杂度为 $\mathcal{O}(1)$。

STL 的优先队列也是使用了堆，复杂度同理。
## 代码
下列给出手写堆和 STL。
#### 手写堆
```cpp
#include <iostream>
#include <cctype>
int heap[1000005], len; //满二叉树
//这种表示方法中，满二叉树中第i个节点的左儿子和右儿子分别为i*2和i*2+1
int main() {
    int n, now;
    char ch;
    for (scanf("%d", &n); n--;) {
        for (; !isdigit(ch = getchar()););
        switch (ch) {
            case '1':
                scanf("%d", heap + (now = ++len));
                while (now) { //上浮
                    int up = now >> 1;
                    if (heap[up] > heap[now]) std::swap(heap[up], heap[now]);
                    else break;
                    now = up;
                }
                break;
            case '2':
                printf("%d\n", heap[1]);
                break;
            case '3':
                std::swap(heap[len--], heap[now = 1]);
                while ((now << 1) <= len) { //下沉
                    int low = now << 1;
                    if (low + 1 <= len && heap[low] > heap[low + 1]) ++low;
                    if (heap[low] < heap[now]) std::swap(heap[now], heap[low]);
                    else break;
                    now = low;
                }
        }
    }
}
```
#### STL
下文不介绍 priority_queue，若有了解兴趣可看 https://cppreference.cn/w/cpp/container/priority_queue
```cpp
#include <cstdio>
#include <cctype>
#include <vector>
#include <queue>
int main() {
    std::priority_queue<int, std::vector<int>, std::greater<int>> q; //小根堆
    int n, x;
    char ch;
    for (scanf("%d", &n); n--;) {
        for (; !isdigit(ch = getchar()););
        switch (ch) {
            case '1':
                scanf("%d", &x);
                q.push(x);
                break;
            case '2':
                printf("%d\n", q.top());
                break;
            case '3':
                q.pop();
        }
    }
}
```

---

## 作者：gdz0214_and_zxb0214 (赞：0)

## 二叉堆的引入
何为二叉堆？二叉堆就是一种基于树的数据结构，其中又有大根堆与小根堆，用于快速求出最值。

大根堆的性质如下：对于每一个非叶节点，他的权重比他的所有儿子权重都要大，同时他的左儿子权重比右儿子权重大，小根堆则同理。

本题有入队，求最值，出队三种操作，朴素算法明显会炸，此时需要一个更快的算法，这时二叉堆就派上了用场，由于是求最小值，故使用小根堆。
## 小根堆的操作
## 入堆
为了维护小根堆，可以先将输入节点放在末尾，然后不断向上调整，具体如下：

1. 若自己比父亲小，交换自己权重和父亲权重，从父亲处继续调整。
2. 不用调整直接返回。
## 求最值
直接输出栈顶。
## 出堆
可以交换栈顶与末尾节点，随后末尾节点出堆（前栈顶），再将交换后的栈顶向下调整，具体如下：

1. 若当前节点为叶子节点，返回。
2. 判定**当前节点左儿子权重是否小于当前节点权重**，若是，记录下左儿子编号，否则记录当前节点编号。
3. 如果当前节点还有右儿子，则判定**右儿子权重是否既小于当前节点权重又小于左儿子权重（可简化为右儿子权重是否小于先前记录过的节点的权重）**，若是，记录下右儿子编号。
4. 若记录过后的节点为当前节点，返回。
5. 否则交换记录过后的节点权重与当前节点权重，从记录过后的节点继续向下调整。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int m,h[1000010],n,op,x;
void Swap(int x,int y){
	swap(h[x],h[y]);
}
void down(int i){
	int t;
	while(i*2<=n){
		if(h[i*2]<h[i]){
			t=i*2;
		}else{
			t=i;
		}
		if(i*2+1<=n){
			if(h[i*2+1]<h[t]){
				t=i*2+1;
			}
		}
		if(t!=i){
			Swap(t,i);
			i=t;
		}else{
			return;
		}
	}
	return; 
}
void up(int i){
	while(i/2){
		if(h[i/2]>h[i]){
			Swap(i/2,i);
			i/=2;
		}else{
			return;
		}
	}
	return;
}
signed main(){
	scanf("%lld",&m);
	while(m--){
		scanf("%lld",&op);
		if(op==1){
			scanf("%lld",&x);
			h[++n]=x;
			up(n);
		}else if(op==2){
			printf("%lld\n",h[1]);
		}else{
			Swap(1,n);
			--n;
			down(1);
		}
	} 
	return 0;
}
```

---

## 作者：LionBlaze (赞：0)

# 什么是优先队列

优先队列是一种抽象数据结构（指没有规定操作具体实现，只规定了操作），支持三种操作：

- INSERT：往优先队列中插入一个元素 $x$。
- MINIMUM/MAXIMUM：求优先队列中的最小值/最大值。
- EXTRACT-MIN/EXTRACT-MAX：删除优先队列中的最小值/最大值。这里，最小值/最大值要和 MINIMUM/MAXIMUM 中相同。下同。
- DECREASE-KEY/INCREASE-KEY：把一个元素 $x$ 的值增加/减少。给定 $x$ 的位置。

最大优先队列指操作为 INSERT/MAXIMIM/EXTRACT-MAX/INCREASE-KEY 的优先队列，最小优先队列同理。

优先队列在 C++ STL 中被封装为 `priority_queue`（**不支持 DECREASE/INCREASE-KEY**，并且**默认为最大优先队列**），可以直接使用。但是，我们并不满足于此。不知道一个数据结构的原理，我们怎么可以安心使用呢？？

> 这也是这题被我提议升黄的原因。

优先队列的一种优秀实现是使用**二叉堆**，

# 数据结构介绍

二叉堆（以下简称堆，本文并没有介绍其它种类的堆）是一棵完全二叉树。我们定义堆的“末尾元素”和“超尾元素”为，如果根节点编号为 $1$，一个节点 $i$ 的左子结点和右子节点（如果存在）编号为 $2i$ 和 $2i+1$，则“末尾元素”是编号为堆的大小的节点，“超尾元素”为，如果堆中再多一个节点时的末尾元素的位置。

几种操作的实现，以最小堆为例：

- INSERT：把节点插入到堆的超尾元素处，然后不停和父节点交换直到自身成为根节点或者自身节点的值不小于父节点的值（即，每次如果可以交换则交换，并且下一次要判断的节点变为这次交换完毕的节点，即交换之前的父节点）。
- MINIMUM：根结点的值。
- EXTRACT-MIN：把根节点和末尾元素交换，然后直接删除交换之后的末尾元素。不停将自身节点和子节点中更小的交换，直到自身没有子节点或者自身比一个或两个子节点的值都小。
- DECREASE-KEY：不停和父节点交换直到自身成为根节点或者自身节点的值不小于父节点的值。

# 数据结构本质/正确性证明/时间复杂度分析

同样以最小优先队列（具体实现为最小堆）为例。

首先说明时间复杂度为什么优。$n$ 为二叉堆中当前元素个数。

- INSERT 时间复杂度为 $\mathcal O(\log n)$。
- MINIMUM 时间复杂度为 $\Theta(1)$。
- EXTRACT-MIN 时间复杂度为 $\mathcal O(\log n)$。
- DECREASE-KEY 时间复杂度为 $\mathcal O(\log n)$。

这些都是显然的。

对于最小堆，关键在于一个重要性质：自身的节点的值都不大于自身的若干个子节点的值。一个重要的推论就是，自身节点的值是以自身为根的整棵子树的值的最小值（可能不唯一）。

我们假设堆在每次操作开始前和结束后都满足最小堆性质。则 MINIMUM 正确性显然。

对于 INSERT 操作正确性显然，并且之后显然满足堆性质。顺带一提，INSERT 操作也可以解释为，堆大小为无穷大（但是虚拟元素的大小不计入堆真正大小），则此时超尾元素显然存在，我们让虚拟节点的值都为正无穷大，则此时只是把超尾节点的值减小到了想要的值而已。

> ~~不是吧不会还有人不会证吧~~为了严谨我们来证明一下。
>
> 我们设当前节点（在开始的时候是超尾节点，后面不断提升）为 $x$。假设 $x$ 的子树满足堆性质，且 $x$ 的任何祖先节点的值都不大于 $x$ 的任何子节点的 $v$（$v(k)$ 代表节点 $k$ 的值），而整个堆中唯一可能违反堆性质的只能是 $x$ 和 $x$ 的父节点 $p(x)$。开始的时候显然满足。
>
> 那么如果 $v(x)\ge v(p(x))$，则无需调整。整个堆中唯一可能违反堆性质的地方也没有违反，直接退出即可。
>
> 否则，$v(x)<v(p(x))$，而交换之后，$v(x)$ 增加了而 $v(p(x))$ 减少了，$v(x)$ 和 $v(p(x))$ 满足了堆性质，而显然这只会影响到 $v(x)$ 和 $v(p(x))$ 周围的元素的堆性质。
>
> $x$ 的子节点：根据归纳假设显然。
>
> $v(p(x))$ 的父节点：可能矛盾，需要进一步维护。
>
> 把 $x$ 变为 $p(x)$ 之后归纳假设是否仍然成立：画个图可能会理解得更好一些，唯一可能出毛病的地方就是交换前的 $x$ 是否满足。而因为 $v(p(x))$ 和其祖先节点满足堆性质（此时 $x$ 是交换之前的），所以不会出问题，归纳假设仍然成立。

DECREASE-KEY 操作正确性根据上面也是显然成立的。

EXTRACT-MIN 为什么正确？考虑一次调整。画图可知显然成立，具体证明留作习题。

另一个习题：最小堆是否能够高效支持 INCREREASE-KEY？如果能，设计出算法。

# 代码实现

此题 C++ 代码实现。本题不需要支持 DECREASE-KEY 操作。

这是无封装的二叉堆写法。

```cpp
#include <stack>
#include <cstdio>

using namespace std;

int arr[2000005];

int main()
{
	int n;
	scanf("%d", &n);
	int num = 0;
	while (n--)
	{
		int op;
		scanf("%d", &op);
		if (op == 1)
		{
			scanf("%d", arr + ++num);
			int i = num;
			while (i != 1 && arr[i / 2] > arr[i])
			{
				int t = arr[i];
				arr[i] = arr[i / 2];
				arr[i /= 2] = t;
			}
		}
		if (op == 2) printf("%d\n", arr[1]);
		if (op == 3)
		{
			arr[1] = arr[num--];
			int i = 1;
			while (i * 2 <= num && arr[i * 2] < arr[i] || i * 2 + 1 <= num && arr[i * 2 + 1] < arr[i])
			{
				if (i * 2 + 1 > num || arr[i * 2] < arr[i * 2 + 1])
				{
					int t = arr[i];
					arr[i] = arr[i * 2];
					arr[i = i * 2] = t;
				}
				else
				{
					int t = arr[i];
					arr[i] = arr[i * 2 + 1];
					arr[i = i * 2 + 1] = t;
				}
			}
		}
	}
	return 0;
}
```

这是带封装的二叉堆写法。

注意最后的节点只有左子结点的时候的特殊情况。

```cpp
#include <functional>
#include <cstdio>
#include <queue>

using namespace std;

template<typename T, typename C = vector<T>, typename P = less<T>>
class my_priority_queue
{
	C c{};
	P p{};
public:
	my_priority_queue() {}
	void insert(const T& x)
	{
		c.push_back(x);
		int id = c.size() - 1;
		while (id && p(c[id], c[(id - 1) / 2]))
		{
			swap(c[id], c[(id - 1) / 2]);
			id = (id - 1) / 2;
		}
	}
	T top() { return c[0]; }
	void pop()
	{
		swap(c[0], c[c.size() - 1]);
		c.pop_back();
		int id = 0;
		while (id * 2 + 1 < c.size() && p(c[id * 2 + 1], c[id]) || id * 2 + 2 < c.size() && p(c[id * 2 + 2], c[id]))
		{
			int mx = id * 2 + 2 >= c.size() || p(c[id * 2 + 1], c[id * 2 + 2]) ? id * 2 + 1 : id * 2 + 2;
			swap(c[id], c[mx]);
			id = mx;
		}
	}
};

int main()
{
	my_priority_queue<int> q;
	int n;
	scanf("%d", &n);
	while (n--)
	{
		int op;
		scanf("%d", &op);
		if (op == 1)
		{
			int x;
			scanf("%d", &x);
			q.insert(x);
		}
		if (op == 2) printf("%d\n", q.top());
		if (op == 3) q.pop();
	}
	return 0;
}
```

这是两种 `priority_queue` 写法。

第一种是因为 `priority_queue` 是最大堆，所以把所有元素取相反数然后存入。

```cpp
#include <cstdio>
#include <queue>

using namespace std;

int main()
{
	priority_queue<int> q;
	int n;
	scanf("%d", &n);
	while (n--)
	{
		int op;
		scanf("%d", &op);
		if (op == 1)
		{
			int x;
			scanf("%d", &x);
			q.push(-x);
		}
		if (op == 2) printf("%d\n", -q.top());
		if (op == 3) q.pop();
	}
	return 0;
}
```

第二种是自定义比较器[^1]。

```cpp
#include <functional>
#include <cstdio>
#include <queue>

using namespace std;

int main()
{
	priority_queue<int, vector<int>, greater<int>> q;
	int n;
	scanf("%d", &n);
	while (n--)
	{
		int op;
		scanf("%d", &op);
		if (op == 1)
		{
			int x;
			scanf("%d", &x);
			q.push(x);
		}
		if (op == 2) printf("%d\n", q.top());
		if (op == 3) q.pop();
	}
	return 0;
}
```

# 注解

[^1]: 为什么要写成 `priority_queue<int, vector<int>, greater<int>>` 呢？实际上 `priority_queue` 的原型通常形如 `template <class _Ty, class _Container = vector<_Ty>, class _Pr = less<typename _Container::value_type>> class priority_queue`，第一个参数代表元素类型，第二个代表内部容器（即如何存储二叉树，默认使用变长数组 `vector`），第三个参数代表比较器。比较器实际上是反的，如果你传入 `less` 则实际上是最大堆，`greater` 是最小堆，这个很难受。我手写的带封装 `my_priority_queue` 也使用了类似设计。

---


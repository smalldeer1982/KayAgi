# [蓝桥杯 2021 省 AB2] 负载均衡

## 题目描述

有 $n$ 台计算机，第 $i$ 台计算机的运算能力为 $v_{i}$ 。

有一系列的任务被指派到各个计算机上，第 $i$ 个任务在 $a_{i}$ 时刻分配，指定计算机编号为 $b_{i}$, 耗时为 $c_{i}$ 且算力消耗为 $d_{i}$。如果此任务成功分配，将立刻开始运行, 期间持续占用 $b_{i}$ 号计算机 $d_{i}$ 的算力, 持续 $c_{i}$ 秒。

对于每次任务分配，如果计算机剩余的运算能力不足则输出 $-1$，并取消这次分配，否则输出分配完这个任务后这台计算机的剩余运算能力。

## 说明/提示

**【样例说明】**

时刻 $1$，第 $1$ 个任务被分配到第 $1$ 台计算机，耗时为 $5$，这个任务时刻 $6$ 会结束, 占用计算机 $1$ 的算力 $3$。

时刻 $2$，第 $2$ 个任务需要的算力不足，所以分配失败了。

时刻 $3$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，剩余算力不足 $3$，所以失败。

时刻 $4$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，但剩余算力足够，分配后剩余算力 $1$。

时刻 $5$，第 $1$ 个计算机仍然正在计算第 $1$，$4$ 个任务，剩余算力不足 $4$，失败。

时刻 $6$，第 $1$ 个计算机仍然正在计算第 $4$ 个任务，剩余算力足够，且恰好用完。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $n, m \leq 200$。

对于 $40 \%$ 的评测用例, $n, m \leq 2000$。

对于所有评测用例, $1 \leq n, m \leq 2\times 10^5,1 \leq a_{i}, c_{i}, d_{i}, v_{i} \leq 10^{9}, 1 \leq b_{i} \leq n$。 

蓝桥杯 2021 第二轮省赛 A 组 H 题（B 组 I 题）。

## 样例 #1

### 输入

```
2 6
5 5
1 1 5 3
2 2 2 6
3 1 2 3
4 1 6 1
5 1 3 3
6 1 3 4```

### 输出

```
2
-1
-1
1
-1
0```

# 题解

## 作者：xwh_hh (赞：15)

一道经典好题。  

我们可以考虑用 $n$ 个堆去维护在各个计算机中运行的程序，每当有一个任务 $(a_i,b_i,c_i,d_i)$ 被指派时，我们就可以先将已完成的任务删除，再判断算力是否能够承受，这样每个任务入堆后平均只会被访问 $2$ 次，节省了很多时间。  

由于同一台计算机中，早完成的任务一定比晚完成的任务先删除，这让我们想到了小根堆。我们希望在弹出时能够立即知道算力，所以我们可以用 `pair` 类型的小根堆来维护，`first` 维护结束时间，`second` 维护占用算力，时间复杂度 $O(m\log n)$。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> P;//结束时间first 占用算力second
int n,m,h[200005];
priority_queue<P,vector<P>,greater<P> > pq[200005];//堆 
int main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>h[i];
    while(m--){
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        while(!pq[b].empty() && pq[b].top().first<=a){//将已完成的任务删除 
            h[b]+=pq[b].top().second;
            pq[b].pop();
        }
        if(h[b]<d) cout<<-1<<endl;
        else{//分配 
            h[b]-=d;
            pq[b].push(P(a+c,d));//注意是结束时间 
            cout<<h[b]<<endl;
        }
	} 
    return 0;
}

```


---

## 作者：lupengheyyds (赞：13)

# 一、题目描述：
[原题链接](https://www.luogu.com.cn/problem/P8755)
请大家在原题查看，这里不再赘述。
# 二、思路：
## 1.纯模拟：
这是很容易想到的，我们可以建立一个二维数组，第一维表示机器，第二维表示当前时间，里面存储当前算力，当接到任务时，与所需算力进行比较，若可以处理，将 $b$ 机器 $a \sim a+c-1$ 时间的算力减去 $d$ ，由于是区间处理，我们可以用[差分](https://baike.baidu.com/item/%E5%B7%AE%E5%88%86/10349967?fromModule=lemma-qiyi_sense-lemma)（对差分不再解释，可以在连接里看）。

这个算法 $\color{red}40$ 分。

## 2.堆：
上面的算法有空间与时间上的双重不足，在优化时，我们应先想到什么是“不重要的”。

1. 题目只要求输出每一次的 $b$ 机器的情况，所以我们可以只去处理当前的 $b$ 机器。

2. 需要输出每一次派发人物后的信息，而不是每时每刻，所以我们以每一个任务为单位，进行处理。

基于任务，显而易见应该以任务结束时间先后弹出，题目并没有保证结束时间的先后与输入先后的关系，我们就应该动态维护最小值，自然就有了堆。

### 具体实现：
建立一个优先队列存放结束时间与此任务所耗算力，以结束时间从早到晚排列：
```
struct Computer{
	long long EndTime,F;//EndTime表示当前任务结束时间，F表示所需算力 
	bool operator<(const Computer &tmp)const{
		return EndTime>tmp.EndTime;//从早到晚记录结束时间 
	}
};
priority_queue<Computer> que[szl];
```
对于每一次派发任务，更新算力，如果此任务已经结束，添加回算力，并弹出任务：
```
if(v[b]<d){//若还是不能接任务 
	cout<<-1<<endl;
	continue;
}
que[b].push({a+c,d});//接任务
v[b]-=d;//消耗算力
cout<<v[b]<<endl;
```

# END

这是我第一篇题解，创作不易，希望管理员能通过，管理员幸苦了。

---

## 作者：gengchenghao (赞：5)

## 思路
用堆来维护，在 $a_i$ 时刻如果堆顶有计算机完成了，就把算力退回来，即先将已完成的任务删除，再将算力弹出，再判断算力是否能够承受。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
struct node{
	int ti,v;
	bool operator<(const node& a) const {
		return ti>a.ti;
	}
};
priority_queue<node>q[N];
int v[N];
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	while(m--){
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		while(q[b].size()&&q[b].top().ti<=a){
			v[b]+=q[b].top().v;
			q[b].pop();
		}
		if(v[b]<d)puts("-1");
		else{
			v[b]-=d;
			q[b].push({a+c,d});
			cout<<v[b]<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：5)

# 题目描述

[[蓝桥杯 2021 省 AB2] 负载均衡](https://www.luogu.com.cn/problem/P8755)

# 算法思路

看到题目，一下子就想到了**堆**，维护一个时间的小根堆，在时刻 $a_{i}$，如果堆顶有计算机完成了，就把算力退回来，然后判断计算机 $b_{i}$ 能否分配任务，不能则输出 $-1$，能就把计算机 $b_{i}$ 的算力减去占用的算力，然后输出剩余算力就行了。

### 时间复杂度：$O(m \log n)$。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200010;
struct computer
{
	ll times,capacity,idx;//时间，要用算力，计算机编号
	bool operator<(const computer &x)const//时间从小到大
	{
		return times>x.times;
	}
};
ll n,m,v[N],a[N],b[N],c[N],d[N];
priority_queue<computer> heap;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>v[i];//输入算力
	}
	for(int i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i]>>c[i]>>d[i];
		while(heap.size()&&a[i]>=heap.top().times)//如果有计算机完成了任务
		{
			v[heap.top().idx]+=heap.top().capacity;//退回算力
			heap.pop();
		}
		if(v[b[i]]<d[i])//如果剩余算力不够
		{
			cout<<"-1\n";
			continue;
		}
		heap.push({a[i]+c[i],d[i],b[i]});
		v[b[i]]-=d[i];//去掉要用算力
		cout<<v[b[i]]<<"\n";//输出剩余算力
	}
	return 0;
}
```


---

## 作者：封禁用户 (赞：4)

# P8755 题解

## 方法 1：暴力

首先注意到，不同编号的计算机不会互相影响，所以下面我们单独考虑每一个计算机的任务。一个简单的想法就是直接模拟：

每次接受一个任务我们就记录它在未来时间的算力消耗；每次来一个任务我们就检查当前算力消耗是否能够满足。但由于消耗算力数据范围比较大，这个模拟会超时。

## 方法 2：堆
我们考虑用一个堆记录**最早完成的任务**，也就是：

每次接受一个任务，我们就把 $(A _ {i}+C _ {i},D _ {i})$ 加入到堆列表，并且记录当前的算力剩余 $u = u - D _ {i}$，每次来一个任务，我们就不断从**堆顶弹出 $A _ {j} + C _ {j} \le A _ {i}$ 的任务 $j$**，每次弹出时恢复算力 $u = u + D _ {j}$，则如果更新后，此时 $D _ {i} \le u$，我们就选择接受这个任务。


## AC 代码

```c
#include <bits/stdc++.h>
using namespace std;
const int maxn = 200010;
using E = pair<int, int>; // 定义数据结构存储该任务信息：first 记录离开时间，second 记录算力
struct S {
	int v; // 记录剩余计算量
	priority_queue<E, vector<E>, greater<E>> minq; // 记录当前已经分配的任务
};
S s[maxn];
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> s[i].v;
	for (int i = 0; i < m; ++i) {
		int a, b, c, d;
		cin >> a >> b >> c >> d;
		while (!s[b].minq.empty()) {
			if (s[b].minq.top().first > a) break; // 在 a 以后才能离开！
			// 否则，堆顶的任务已经可以离开了
			s[b].v += s[b].minq.top().second;
			s[b].minq.pop();
		}
		if (s[b].v >= d) { // 余量仍足，接受任务
			s[b].v -= d;
			s[b].minq.push(E{a+c, d}); // 把任务插入堆中：我们希望按离开时间弹出，故把 'a+c' 作为第一维入队
			cout << s[b].v << endl;
		} else cout << -1 << endl;
	}
  	return 0;//完结撒花
}

```

---

## 作者：a_girl (赞：2)

[P8755 [蓝桥杯 2021 省 AB2] 负载均衡](https://www.luogu.com.cn/problem/P8755)

## 题意
有 $n$ 个任务，每个任务从 $a_i$ 时间开始，用编号为 $b_i$ 的计算机 $d_i$ 的算力，需要时间 $c_i$，如果时间不足，输出 $-1$，否则输出剩下的算力。

## 思路
### 1.暴力
这是非常容易就能想到，我们拿一个数组保存每台机器用的时间，但这样显而易见，肯定不是正解，因为数字太大，会超时。

### 2.堆
我们拿一个维护时间的小根堆，因为编译器里面带的是大根堆，所以我们要搞一个运算符重载。

如果时间小于现在的时间，我们就把算力给拿回去，如果计算机剩下的算力要比所需的算力少，就表示不行，否则就用计算机剩下的算力减去所需的算力，求出还剩下的算力，输出并扔进优先队列。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
struct node
{
	int x,y;
	bool operator<(const node& a)const{return x>a.x;}//运算符重载
};
int n,m,v[200005];
priority_queue<node> q[200005];//堆 
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>v[i];
	for(int i=1;i<=m;i++)
	{
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		while(!q[b].empty()&&q[b].top().x<=a)
		{
			v[b]+=q[b].top().y;//返回计算机的算力 
			q[b].pop();
		}
		if(v[b]<d) cout<<"-1\n";//如果不行输出-1 
		else
		{
			v[b]-=d;//行的话就减去需要的时间 
			cout<<v[b]<<endl;
			q[b].push(node{a+c,d});
		}
	}
	return 0;谢谢观看 
}
```

---

## 作者：Charles_with_wkc (赞：1)

# 思路：
输出每一次的 $b$ 机器剩余的算力的情况，可以只去处理当前的 $b$ 机器。输出每一次派人后的信息，而不是每个时刻，以每一个任务为单位，进行处理。

以任务结束时间先后弹出，题目没有保证结束时间的先后与输入先后的关系，就应该动态维护最小值，显然要用优先队列。
# 核心代码：
```cpp
while(!q[b].empty()&&q[b].top().first<a){
	v[b]+=q[b].top().second;
	q[b].pop();
}//如果时间已经过了
if(v[b]<=d){
	cout<<-1<<'\n';
	continue;
}//判断-1
v[b]-=d;
q[b].push(pair<int,int>(a+c,d));//存储
```
[完整代码](https://www.luogu.com.cn/paste/1haz2136)

---

## 作者：IkeveLand (赞：1)

**思路：堆**

对于每个计算机维护一个堆，含有两个权值：结束时刻和其消耗的算力。

可以维护每个计算机的算力变化，第一步要把当前计算机的堆中的**结束时刻**小于当前计算机开始时刻的全部弹出队列，并恢复这些算力。

第二步，如果能分配资源就把当前计算机结束时刻和其消耗算力放入到堆中，否则输出 -1 。

## Code:

```cpp
#include <bits/stdc++.h>
#define int long long 
#define pii pair<int,int>
using namespace std;
const int N=1e6+114;

int n,m;
priority_queue<pii,vector<pii>,greater<pii> >q[N];
int v[N];
signed main ()
{
	scanf ("%lld %lld",&n,&m);
	for (int i=1;i<=n;i++) scanf ("%lld",&v[i]);
	
	for (int i=1;i<=m;i++){
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		while (!q[b].empty()&&q[b].top().first<a){
			v[b]+=q[b].top().second;
			q[b].pop();
		}
		if (v[b]<d) puts("-1");
		else {
			q[b].push({a+c-1,d});
			v[b]-=d;
			printf ("%lld\n",v[b]);
		}
	}
	return 0;
}
```

---

## 作者：QAQ_liu (赞：1)

### 思路：
给每个计算机都分配一个优先队列。

比如我们现在要处理 $i$ 号计算机的任务，我们拿出    $q_i$ 的堆首，里面会有某个任务的结束时间，占用算力。

我们假设堆顶的结束时间是 $t1$，任务时间为 $t2$。

如果 $t1<t2$ 出堆。否则，如果算力够用，扣掉算力，进堆，否则输出 $-1$。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,v[200005];
struct node{
	long long en,cal;
}t;
bool operator<(node a,node b){
	return a.en>b.en;
}
priority_queue<node> q[200005];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	for(int i=1;i<=m;i++){
		long long a,b,c,d;
		cin>>a>>b>>c>>d;
		while(q[b].size()>0&&q[b].top().en<=a){
			v[b]+=q[b].top().cal;
			q[b].pop();
		}if(v[b]<d) cout<<-1<<endl;
		else{
			v[b]-=d;
			q[b].push(node{a+c,d});
			cout<<v[b]<<endl;
		}
	}
    return 0;
}
```

---

## 作者：linch (赞：0)

## 题意
有 $n$ 个任务，每个任务从 $a_i$ 时刻开始，占用编号为 $b_i$ 的计算机 $d_i$ 的算力 $c_i$ 秒，输出每个任务分配后对应计算机剩余算力，如果不足，输出 `-1`。

## 解决
模拟。根据题意进行任务分配。但是每次分配前需要先释放算力。如果把进行中任务全部搜一遍，肯定超时，所以我们可以按结束时间排序。

排序后，可以按照顺序释放算力，如果结束时间晚于当前时间，则立即退出。

为了保证时间复杂度，需要使用 $O(n \log n)$ 的排序算法，这里使用堆排序。

#### 什么是堆排序？
建立一个完全二叉堆（树），维护这个小根堆使其**每个子节点都比父节点大**。

由此性质，可得**该堆的根节点一定是最小的**，重复弹出即可。

具体实现方案可以自己了解，也可以使用模板库，这里提供手写的代码。

## 代码
```cpp
#include<iostream>
using namespace std;
const int maxn=2e5+10;
long long n,m,heap_size,a,b,c,d;//n,m,a,b,c,d 与题意同，heap_size 表示当前堆大小（即进行中任务数量）。
int v[maxn];
struct node{
	int t=0,val=0,num=0;//分别表示结束时间，占用算力，计算机编号。
}heap[maxn];
void _swap(int rt1,int rt2){
	swap(heap[rt1].t,heap[rt2].t);
	swap(heap[rt1].val,heap[rt2].val);
	swap(heap[rt1].num,heap[rt2].num);
	return;
}//定义交换函数，交换整个结构体。
void rise(int rt){
	while(rt!=1 && heap[rt].t<heap[rt/2].t){
		_swap(rt,rt/2);
		rt/=2;
	}
}//节点上升。
int son(int rt){
	if(rt*2+1<=heap_size && heap[rt*2+1].t<heap[rt*2].t){
		return rt*2+1;
	}
	else return rt*2;
}//获取更小的子节点编号。
void fall(int rt){
	int t1=son(rt);
	while(t1<=heap_size && heap[t1].t<=heap[rt].t){
		_swap(t1,rt);
		rt=t1;
		t1=son(rt);
	}
}//下降。
void del(){
	_swap(1,heap_size);
	heap_size--;
	fall(1);
}//弹出根节点元素。
void add_data(int temp1,int temp2,int temp3){//分别表示加入数据的结束时间，占用算力，计算机编号，与结构体同。
	heap_size++;//数量增加。
	heap[heap_size].t=temp1;
	heap[heap_size].val=temp2;
	heap[heap_size].num=temp3;
	rise(heap_size);
	return;
}//加入数据。
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}//输入。
	for(int i=1;i<=m;i++){
		cin>>a>>b>>c>>d;//输入。
		while(heap[1].t<=a && heap_size>=1){//如果堆的根节点的结束时间旧早于当前时间，且堆不为空。
			v[heap[1].num]+=heap[1].val;//释放算力。
			del();//弹出根节点。
		}
		if(v[b]<d){
			cout<<-1<<endl;
		}//算力不足。
		else{
			add_data(a+c,d,b);//存入数据。
			v[b]-=d;//花费算力。
			cout<<v[b]<<endl;//输出剩余算力。
		}
	}
	return 0;
}
```

[AC 代码](https://www.luogu.com.cn/record/155776523)

---

## 作者：Speech_less (赞：0)

# P8755 [蓝桥杯 2021 省 AB2] 负载均衡 题解
## 主要思路
本题数据 $2 \times 10^5$ 一看暴力模拟就不能过，要想一下怎么优化。

本蒟蒻用的是伟大的优先队列 priority_queue。

首先，不能以时间模拟，会爆。但是读一下题，发现可以根据每一个任务进行模拟，只需要 $O(m \log n)$ 的时间复杂度。用 $n$ 个优先队列存每一个任务的结束时间，当任务需要用到这一台电脑时，再对他们进行操作。

核心代码：

```
for(int i=1;i<=m;i++){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		while(!q[b].empty()){//让到时间的任务出队列 
			if(q[b].top().time<=a){
				powe[b]+=q[b].top().poww;//算力回归 
				q[b].pop();
			}
			else break;
		}
		if(powe[b]<d){//判断能否接受任务 
			cout<<"-1\n";
		}
		else{
			powe[b]-=d;
			q[b].push(node{a+c,d});//能就入队 
			cout<<powe[b]<<'\n';
		}
	}
```

其他部分都很简单，你应该能想到吧。

~~你都能做黄题了，怎么可能想不到。~~

------------

## AC 代码上交

```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int powe[N];
struct node{
	int time,poww;
	friend bool operator <(node x,node y){
		return x.time>y.time;
	}
};
priority_queue <node> q[N];
int main(){
	int m,n;
	cin>>n>>m;
	for(int i=1;i<=n;i++) scanf("%d",&powe[i]);
	for(int i=1;i<=m;i++){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		while(!q[b].empty()){//让到时间的任务出队列 
			if(q[b].top().time<=a){
				powe[b]+=q[b].top().poww;//算力回归 
				q[b].pop();
			}
			else break;
		}
		if(powe[b]<d){//判断能否接受任务 
			cout<<"-1\n";
		}
		else{
			powe[b]-=d;
			q[b].push(node{a+c,d});//能就入队 
			cout<<powe[b]<<'\n';
		}
	}
	return 0;
} 
```

我知道你是不会抄袭的吧？

\* 注：切记无抄袭，抄袭变宗名。

---

## 作者：qzmoot (赞：0)

# P8755 题解
[题目传送门](https://www.luogu.com.cn/problem/P8755)
# 题目解读
说人话，这道题目就是在每个时刻进行算力的判断，是否能分配任务，如果能就输出剩余算力，不能就输出 $-1$。
# 第一种解法-暴力
于是我们很快就能想到暴力模拟的写法。

但是明显，这题暴力不是**正解**，所以我就不多说了。
# 第二种方法-堆
因为这个早来的任务肯定是先删除的，所以我们直接用一个小根堆来维护时间，注意，C++ 自带的**优先队列**是默认的**大根堆**，所以我们要进行一个运算符的**重载**。

对于 $A_i$，弹出比 $A_i$ 小的时间，把算力退回去，然后判断 $B_i$ 能否接受，不能的话就输出 $-1$，否则输出剩余的算力就行了，并且还要扔进堆里。

时间复杂度：$O(m \log n)$。
# 代码时间
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200005;
struct node{
	int t,val,id;
	bool operator<(const node& x)const//重载运算符 
	{
		return t>x.t;
	}
};
int n,m,v[N];
priority_queue<node> q;//堆 
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>v[i];
	for(int i=1,a,b,c,d;i<=m;i++)
	{
		cin>>a>>b>>c>>d;
		while(!q.empty() && a>=q.top().t)//弹出比a小的计算机 
		{
			v[q.top().id]+=q.top().val;//退还算力 
			q.pop();
		}
		if(v[b]<d)//如果算力不足 
		{
			cout<<"-1"<<endl;
			continue;
		}
		q.push({a+c,d,b});//足够的话直接插入 
		v[b]-=d;//计算剩余算力 
		cout<<v[b]<<endl;
	}
	return 0;
}
```

---

## 作者：tZEROちゃん (赞：0)

朴素的想法是直接模拟这个过程，给每个计算机开一个处理列表，一项任务时间一到就把它扔出去，但这样必定会超时。

我们想，如果一个任务完成了，但他后面又用不到这个计算机，我们还每次去处理它一下，肯定很浪费时间，因此，我们可以在用到这个计算机时，再一次性把所有完成了任务的计算机扔出去。

具体来说，我们用堆来维护每一个计算机，对于每一次操作，我们弹出在这个计算机中所有结束时间（即，开始时间 + 持续时间）比插入的任务的开始时间小的计算机，在弹出的过程中计算新的「算力」，判断算力是否够用，若够用就插入，并更新算力，否则输出 $-1$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, l, r) for(auto i = (l); i <= (r); ++i)
#define pb push_back

const int N = 2e5 + 10;
int a[N];
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q[N];
// .first => end time, .end => compute ability

void solve() {
  int t, id, ut, comp;
  cin >> t >> id >> ut >> comp;
  while (!q[id].empty() && q[id].top().first <= t) {
    a[id] += q[id].top().second;
    q[id].pop();
  }
  if (a[id] < comp) return puts("-1"), void(); else {
    int et = t + ut;
    q[id].push({et, comp}); a[id] -= comp; 
    cout << a[id] << '\n';
  }
}

int main() {
  int n, m;
  cin >> n >> m; 
  rep (i, 1, n) cin >> a[i];
  while (m--) {
    solve();
  }
}
```

---


# 前缀统计

## 题目描述

给定 $N$ 个字符串 $S_1,S_2\cdots S_N$，接下来进行 $M$ 次询问，每次询问给定一个字符串 $T$，求 $S_1 \sim S_N$ 中有多少个字符串是 $T$ 的前缀。

输入字符串的总长度不超过 $10^6$，仅包含小写字母。

## 说明/提示

数据范围满足 $1 \le N,M \le 10^5$

## 样例 #1

### 输入

```
3 2
ab
bc
abc
abc
efg```

### 输出

```
2
0```

# 题解

## 作者：Atserckcn (赞：18)

# [P10470 前缀统计](https://www.luogu.com.cn/problem/P10470)题解

## 题目简述：

一共有 $N$ 个字符串 $S_1,S_2,\cdots,S_N$，有 $M$ 次询问，每次给定字符串 $T$，需要求出 $N$ 个字符串中一共有多少个字符是 $T$ 的**前缀**。

数据范围：

> 总长度不超过 $10^6$。

思路1：

运用 STL 函数中的 `find()` 函数，每次查找 $N$ 个字符串，并计算其 `find()` 函数返回值为 $0$，即是 $T$ 的前缀的情况数。

但是分析一下时间复杂度，我们会发现，$N$ 和 $M$ 最大都为 $10^5$，则每次匹配的最坏结果就是 $10^5 \times 10^5 =10^{10}$，很显然会时间超限。

那么我们需要认识一种新的数据结构——字典树！

## trie 树

字典树（trie 树）是一种用于实现**字符串快速检索**的多叉树结构。

trie 树的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符 c，就沿着当前节点的 c 字符指针，走向该指针指向的节点。

下图即为一个简易版字典树，存储了单词：ab、ac、ba。

![](https://cdn.luogu.com.cn/upload/image_hosting/2fi7b7qu.png)

那么该如何用代码实现字典树呢？

像以往的树形结构一样，我们可以用结构体存树：

```cpp
struct EDGE{
	int son[26];//因为保证只有小写字母，所以分支最多有26个
	int cnt;//统计到这个节点为止，一共有几个前缀
}edge[MAXN];
```

当然，因为输入的是小写字母，但是结构体里边是数字的一维数组，所以我们还要手打一个字符串转数字的函数——

```cpp
int getnumber(char ch)//蒟蒻不会用map，勿喷
{
	return ch-'a';//ASCII码值
}
```

接下来，我们需要解决两大问题：

1、如何将一个字符串插入字典树？

思路：由于字典树是用来存字符的，所以我们可以将整个字符串转为一个个字符，再将其插入字典树，具体操作注释在代码中。

```cpp
void insert(string s)//插入字符串s
{
	now=1;//相当于一个起点
	for(int i=0;i<s.size();i++)//分解每个字符
	{
		num=getnumber(s[i]);//转化
		if(!edge[now].son[num])//如果当前字典树不存在此单词
			edge[now].son[num]=++cnt;//加边
		now=edge[now].son[num];//沿着现在的这条边走
		if(i==s.size()-1) edge[now].cnt++;//特判情况，若已经是字符串的最后一个字符，则代表字典树的这个节点是一个单词的末尾，统计的cnt需要+1
	}
	return;
}
```

2、如何统计一个字符串前缀的个数？

思路：顺着查找字符串的每个字符，一路顺着字典树，直到查完，一路上统计 cnt 个数。

Code:

```cpp
void find(string s)//统计字符串s的前缀数量
{
	ans=0;//统计的变量
	now=1;//起点
	for(int i=0;i<s.size();i++)
	{
		num=getnumber(s[i]);
		if(!edge[now].son[num])//如果到头了
		{
			printf("%d\n",ans);
			return;
		}
		now=edge[now].son[num];//转移
		ans+=edge[now].cnt;//统计
	}
	printf("%d\n",ans);
	return;
}
```

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int now,cnt=1,num,ans;
int getnumber(char ch)
{
	return ch-'a';
}
struct EDGE{
	int son[26];
	int cnt;
}edge[MAXN];
int n,m;
string s;
void insert(string s)
{
	now=1;
	for(int i=0;i<s.size();i++)
	{
		num=getnumber(s[i]);
		if(!edge[now].son[num])
			edge[now].son[num]=++cnt;
		now=edge[now].son[num];
		if(i==s.size()-1) edge[now].cnt++;
	}
	return;
}
void find(string s)
{
	ans=0;
	now=1;
	for(int i=0;i<s.size();i++)
	{
		num=getnumber(s[i]);
		if(!edge[now].son[num])
		{
			printf("%d\n",ans);
			return;
		}
		now=edge[now].son[num];
		ans+=edge[now].cnt;
	}
	printf("%d\n",ans);
	return;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		cin >> s;
		insert(s);
	}
	for(int i=1;i<=m;i++)
	{
		cin>>s;
		find(s);
	}
	return 0;
}
```

**[AC 记录](https://www.luogu.com.cn/record/160389788)**

**推荐关联题目：[P8306 【模板】字典树](https://www.luogu.com.cn/problem/P8306)，以及[我写的个人记录题解](https://www.luogu.com.cn/article/gjzmyy9j)。**

---

## 作者：Cypher_404 (赞：7)

# 题解：P10470 前缀统计

## 题意分析：

给定 $ N $ 个字符串 $ S_1 , S_2 \cdots S_N  $  ，接下来进行 $ M $  次询问，每次询问给定一个字符串 $ T $ ，求 $ S_1 \sim S_N $  中有多少个字符串是 $ T $ 的前缀。

## 方法分析：

因为 $ 1 \le N , M \le 10^5 $

所以暴力模拟是 $ N ^ 2 $ 的，达到了 $ 10 ^ { 10 } $ 肯定不能通过。

考虑字典树。

## 简介字典树：

字典树是一种树形数据结构。

它的每个节点代表一个字符，从根节点到每个单词的路径形成了一个单词。

字典树的一个重要特点是共享相同前缀的单词会共享相同的前缀路径。

这样就可以快速找到具有相同前缀的单词了。

所以我们只需要在建立字典树时将每个单词的结尾的节点加上 $ 1 $ 在统计答案时累加即可。

## 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
string s;
struct Tree
{
     int fail;
     int vis[30];
     int end;
}tree[1500000];
int cnt=1;
void build(string s)//将字符串s加入字典树
{
	int l=s.size();//获取s的长度
	int now=1;//now指针设为1
	for(int i=0;i<l;++i)
	{
		if(tree[now].vis[s[i]-'a']==0)//没有建边
			tree[now].vis[s[i]-'a']=++cnt;
		now=tree[now].vis[s[i]-'a'];//跳转
	}
	tree[now].end+=1;//结尾处加上1
}
int getans(string s)//获取结果
{
	int l=s.size();
	int now=1,ans=0;//同build
	for(int i=0;i<l;++i)
	{
		now=tree[now].vis[s[i]-'a'];//跳转
		for(int t=now;t&&tree[t].end!=-1;t=tree[t].fail)//每次都跳fail指针
		{
			ans+=tree[t].end;//加上结尾的，即统计答案
		} 
	}
	return ans;
}
int main()//主函数没什么能讲的了OVO
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		build(s);
	}
	while(m--)
	{
		cin>>s;
		cout<<getans(s)<<'\n';
	}
	return 0;//华丽丽的结束
}
/*
3 2
ab
bc
abc
abc
efg
*///平平无奇的样例
```

请点个赞吧，谢谢。

---

## 作者：StarsIntoSea_SY (赞：5)

~~没有学过[字典树](https://www.luogu.com.cn/problem/P8306)的请退。~~

# Solution

不难发现，与字典树板子题唯一不同的地方在于插入和查询是反着来的。

考虑在插入过程中开一个与字典树数组一样的数组，用来标记每一个插入的字符串的最后一个字母，这样在查询过程中每扫到标记，就说明用字符串是满足的。

注意，插入的字符串可能完全相同，因此标记和答案的统计一定是要累加而不是只 +1 这么简单。

# Code

```cpp
#include <stdio.h>
#include <string.h>
const int N=1e6+3;
char s[N];
int t[N][130],d[N][130],cnt[N];  //d数组用来打标记
int idx,n,m;
void insert(char str[]){
	int p=0,len=strlen(str);
	for(int i=0;i<len;++i){
		if(t[p][str[i]]==0){
			idx++;
			t[p][str[i]]=idx;
		}
		if(i==len-1) d[p][str[i]]++;  //标记操作（与模版唯一不同的一行）
		p=t[p][str[i]];
	}
}
int find(char str[]){
	int p=0,len=strlen(str);
	int ans=0;
	for(int i=0;i<len;++i){
		if(t[p][str[i]]==0) return ans; //注意返回ans而非0，因为在前面还是会有单词满足前缀的
		ans+=d[p][str[i]];  //每扫到一个表示说明有单词满足前缀，注意不能只+1，因为可能会有相同的单词
		p=t[p][str[i]];
	}
	return ans;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%s",s);
		insert(s);
	}
	for(int i=1;i<=m;++i){
		scanf("%s",s);
		printf("%d\n",find(s));
	}
}
```

---

## 作者：JYX0924 (赞：4)

给一个不用字典树的方法。

首先，存储一下每个字符串出现的次数，然后将它们的长度存储起来排序。

对于每一次输入，枚举每一个长度，长度大于字符串时就直接退出循环。这样的话，对于每一次查询，最坏情况也不超过 1000，而且大多数情况都枚举不到 1000。

下面是 AC 代码。
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,len,ans,vis[1000005];
string str;
map<string,int> sum;
vector<int> q;
int main()
{
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) {cin>>str,sum[str]++; if(vis[str.length()]==0) q.push_back(str.length()),vis[str.length()]=1;}
	sort(q.begin(),q.end()); len=q.size();
	while(m--)
	{
		cin>>str; int len2=str.length(); ans=0;
		for(int i=0;i<len&&q[i]<=len2;i++)
		{
			string x=str.substr(0,q[i]);
			if(sum[x]!=0) ans+=sum[x];
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：shentianxing (赞：4)

## P10470 前缀统计 题解
模板 trie 字典树题。
### 为什么不能暴力
$M$ 次匹配，每次匹配时 $N$ 次循环，而每个字符串最长 
$10^6$ 个字符，最差情况下 1s 是跑不完的。
### trie 字典树的建树和查询
就是把每个字符串存入字典树中。   
**1.建树**  
每一个节点储存一个字母，可以把前缀一样的储存在一起：  

（储存 `ab`，`ac`，`bc` 三个字符串的字典树）   
![样例树](https://cdn.luogu.com.cn/upload/image_hosting/6puhwnal.png)  
具体建树过程详见代码：
```cpp
int all=0,trie[1000000][26],endd[1000000];
//all:现在树的节点数量
//trie字典树[节点编号][子节点字符]由于本题仅会出现小写字符所以子节点字符可能性只有26种
//endd记录每个节点是否有字符串结束
void build(string a){
	int p=1;
   //定义变量用来爬树
	for(int i=0;a[i];i++){
		if(!trie[p][a[i]-'a']){
			all++;
			trie[p][a[i]-'a']=all;
        //如果还没有此节点，创建一个新节点
		}
		p=trie[p][a[i]-'a'];
     //往上爬一格
	}
	endd[p]++; 
   //字符串结束后标记
}
```
**2.查询**   
可以通过 trie 的特性，查询时爬树，若爬过有字符串结束的节点答案加一。
```cpp
//记得返回答案
int find(string a){
	int p=1;//爬树变量
	int sum=0;//答案
	for(int i=0;a[i];i++){
		if(!trie[p][a[i]-'a']){
			break;//如果找不到其它字符串结束循环
		}
		sum+=endd[trie[p][a[i]-'a']];
      //若有字符串结束，答案加一
		p=trie[p][a[i]-'a'];
		//爬树
	}
	return sum;
}
```   
**完整 AC 代码**   
```cpp
#include <bits/stdc++.h>
using namespace std;

int trie[1000000][26],all=1,endd[1000000];
void build(string a){
	int p=1;
	for(int i=0;a[i];i++){
		if(!trie[p][a[i]-'a']){
			all++;
			trie[p][a[i]-'a']=all;
		}
		p=trie[p][a[i]-'a'];
	}
	endd[p]++; 
}

int find(string a){
	int p=1;
	int sum=0;
	for(int i=0;a[i];i++){
		if(!trie[p][a[i]-'a']){
			break;
		}
		sum+=endd[trie[p][a[i]-'a']];
		p=trie[p][a[i]-'a'];
	}
	return sum;
}

int main(){
	int m,n;
	cin>>m>>n;
	while(m--){
		string x;cin>>x;
		build(x);
	}
	while(n--){
		string x;cin>>x;
		cout<<find(x)<<endl;
	}
	return 0;
}
```

---

## 作者：Mystic_dragon (赞：4)

双倍经验:

[P8306 字典树](https://www.luogu.com.cn/problem/P8306)


------------
所以这题及其类似模版题嘛。~~甚至还不需要考虑大小写字母~~

简单地维护字典树，单词插入结束后单词对应的结尾字母加一，即下文中的 $cnt$ 数组。查询和插入思路就相似了，维护好当前查询字符串在树中可以走到的位置，统计这个位置单词结束的数量。

单次插入时间复杂度：$O(l)$ ，单次插入时间复杂度：$O(l)$ ，总空间复杂度：$O(n \sum l)$。其中 $l$ 为字符串长度。


------------
```cpp
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;
typedef long long i64;
i64 n,m;
i64 Trie[1000010][26];
char s[1000010];
i64 cnt[1000010];
i64 tot;
void build(char *s){
	i64 node=0;
	i64 len=strlen(s);
	for(int i=0;i<len;++i){
		i64 k=s[i]-'a';
		if(!Trie[node][k]) Trie[node][k] = ++tot;
		node=Trie[node][k];
	}
    cnt[node]++;
}
i64 query(char *s){
    i64 ans=0;
	i64 node=0;
	i64 len=strlen(s);
    for(int i=0;i<len;++i){
        i64 k=s[i]-'a';
        if(!Trie[node][k]) return ans;
        node=Trie[node][k];
        ans+=cnt[node];
    }
    return ans;
}
int main(){
    cin>>n>>m;
	for(int i=1;i<=n;++i){
        cin>>s;
        build(s);
	}
	for(int i=1;i<=m;++i){
        cin>>s;
        cout<<query(s)<<endl;
	}
	return 0;
}

```

---

## 作者：jiangjiangQwQ (赞：2)

### 思路
字典树的基础操作，将输入的 $n$ 个字符串插入到字典树中，对于每次询问，查询字典树中是它的前缀字符串的总数量。具体细节如下，把插入到字典树的**终点结点经过次数加 $1$**，查询时用变量将走过的结点值累加，就是答案。注意这里**经过次数不是要置为 $1$**，否则你会喜提全错。
### 代码
```cpp
#include<iostream>
#include<vector>
#include<string>
#include<cstring>
#include<algorithm>
#include<cmath> 
using namespace std;
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Rep(i,j,k) for(int i=j;i>=k;i--)
#define ls(c) c<<1
#define rs(c) c<<1|1
#define int long long
#define lowbit(x) ((x)&(-x))
template<typename type>
inline void read(type &x){
    x=0;bool flag(0);char ch=getchar();
    while(!isdigit(ch)) flag^=ch=='-',ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    flag?x=-x:0;
}
template<typename type>
inline void write(type x){
    x<0?x=-x,putchar('-'):0;
    static short Stack[50],top(0);
    do Stack[++top]=x%10,x/=10;while(x);
    while(top) putchar(Stack[top--]|48);
}
inline char read(char &ch){return ch=getchar();}
inline char write(const char &ch){return putchar(ch);}
template<typename type,typename ...T>
inline void read(type &x,T&...y){read(x),read(y...);}
template<typename type,typename ...T>
inline void write(type x,T...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\n');}
const int N=2e6+5,Mod=1e9+7;
int n,m,tr[N<<2][28],idx,End[N<<2];
string s[N];
void insert(string s){
	int p=0;
	for(int i=0;i<s.size();i++){
		int c=s[i]-'a'+1;
		if(!tr[p][c]) tr[p][c]=++idx;
		p=tr[p][c];
	}End[p]++;return;
}
int query(string s){
	int p=0,res=0;
	for(int i=0;i<s.size();i++){
		int c=s[i]-'a'+1;
		if(!tr[p][c]) break;
		p=tr[p][c];res+=End[p];
	}return res;
}
signed main(){
	cin>>n>>m;
	For(i,1,n) cin>>s[i],insert(s[i]);
	int ans=0;
	For(i,1,m){
		string t;
		cin>>t;
		cout<<query(t)<<'\n';
	}
//	write(ans);
	return 0;
}
```

---

## 作者：yueyan_WZF (赞：2)

这道题显然是字典树，不会字典树的建议先去做一下 [例题](https://www.luogu.com.cn/problem/P8306)

------------
## 正文开始
字典树的基本过程就不说了（比如插入字符串，判断字符串......）
### 思路

```
每次询问给定一个字符串 T ，求在后输入的字符串中有多少个字
符串是 T 的前缀。
```
前缀大家应该都知道吧，而我们通过建字典树，成功的将前缀相同的字符串们连到了一起。

所以我们通过一些思考就会发现，这题不就是在问我们，**这个 $T$ 字符串在字典树上包含了几个输入过的字符串吗**？

### 代码实现

我们为了知道以某一个节点结尾的字符串有多少个，我们可以在插入字符串时做些手脚。

我们定义一个二维数组（~~思考一下为什么是二维的~~），当插入的字符串插入完时，我们就：

```
cnt[i][j]++;
```
其中 $i$ 表示字符串倒数第二个字符，$j$ 表示倒数第一个字符，这样就可以说明，以 $j$ 为结尾的字符串又多了一个。

### AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int h[320005][50];
int cnt[502200][502];//开大一点！ 
int o;
int n,m;
char a[300050];
void insert(char st[]){
	int len=strlen(st);
	int p=0;
	for(int i=0;i<len;i++){
		int u=st[i];
		if(!h[p][u]){
			h[p][u]=++o;
		}
		if(i==len-1){
			cnt[p][u]++;//重点 
		}
		p=h[p][u];
		
	}
}
int find(char st[]){
	int len=strlen(st);
	int p=0;
	int res=0;
	for(int i=0;i<len;i++){
		int u=st[i];
		if(!h[p][u]){
			return res;
		}
		res+=cnt[p][u];
		p=h[p][u];
	}
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",&a);
		insert(a);
	}
	for(int i=1;i<=m;i++){
		scanf("%s",&a);
		printf("%d\n",find(a));
	}
  return 0;//美好习惯
} 
```

---

## 作者：Melo_qwq (赞：1)

如果你写炸了，看看数组有没有开小，因为字母 z 的 ASCII 值是 $122$。

# 题目大意

给定一些字符串 $S$ 和一些字符串 $T$，求对于每个 $T$，有多少个 $S$ 是它的前缀。

# 题目实现

半个字典树典题，跟板子差异不大。

咱们先看板子的各个变量：

1. $tot$ 记录编号。

1. $son_{x,ch}$ 表示编号 $x$ 的结点通过字符 $ch$ 指向的结点的编号。

1. $cnt_x$ 表示经过 $x$ 的结点的次数。

我们发现建树没有区别。

问题就在于板子是问的这个字符串是多少个字符串的前缀，但是本题问的是有多少个字符串是这个字符串的前缀。

所以 $cnt$ 数组的意义要变一下。

我们把 $cnt_x$ 改为以编号 $x$ 的结点**结尾**的字符串的个数。

所以我们在查询的时候每遇到一个点就加上这个点的 $cnt$ 值就能涵盖当前 $T$ 所有的前缀了。

当我们的 $T$ 的字符 $T_i$ 不在树上时结束运算，因为后面的一定也不在树上。

画个图形式化地理解一下（以样例为例）：
![](https://cdn.luogu.com.cn/upload/image_hosting/llxjgjzi.png?x-oss-process=image/resize,m_lfit,h_700,w_900)

上图是建好的树。

红色的是 $cnt$ 值，那么我们查询 `abc` 时会沿编号 $0-1-2-5$，计算答案后是 $2$。

`efg` 没有符合的，直接跳出。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 1e5 + 7 ;
int n ,m ,son[N][123] ,tot ,cnt[N][123] ;
char s[N] ,t[N] ;
namespace shin {
	inline int read (char x) {
		if (x >= 'A' and x <= 'Z') {
			return x - 'A' ; 
		}
		if (x >= 'a' and x <= 'z') {
			return x - 'a' + 26 ; 
		}
		return x - '0' + 52 ;
	}
	inline void insert (char s[]) {
		int x = 0 ;
		int len = strlen (s) ;
		rep (i ,0 ,len - 1 ,1) {
			int ch = shin :: read (s[i]) ;
			if (! son[x][ch]) son[x][ch] = ++ tot ;
			if (i == len - 1) cnt[x][ch] ++ ;
			x = son[x][ch] ; 
		}
	}
	inline int find (char s[]) {
		int x = 0 ,ans = 0 ;
		int len = strlen (s) ;
		rep (i ,0 ,len - 1 ,1) {
			int ch = shin :: read (s[i]) ;
			if (! son[x][ch]) return ans ;
			ans += cnt[x][ch] ;
			x = son[x][ch] ; 
		}
		return ans ;
	}
}
int main () {
	ios :: sync_with_stdio (false) ;
	cin >> n >> m ; 
	rep (i ,1 ,n ,1) {
		cin >> s ;
		shin :: insert (s) ;
	}
	rep (i ,1 ,m ,1) {
		cin >> t ;
		cout << shin :: find (t) << '\n' ;
	} 
	return 0 ;
}
//kafka & かみや & やえみこ
```

---

## 作者：Breath_of_the_Wild (赞：1)

考察知识点：字典树。

我们用样例来建立如下的一个树：
![](https://sy.hhwdd.com/RequireFile.do?fid=2n5zGl27)
从 root 开始到某个星号的路径所经过的字母组在一起，就是某一个字符串的路径。

这就是字典树。

所以，插入就是：如果这条路径从未被走过，就自己建这条路径。然后再走到对应的儿子节点。到了终点，做一个标记，表示某个字符串结束了。

那么查询自然也很简单了：遍历这个字符串的这条路径，把路上的所有标记加起来，输出即可。

下面是插入和查询的函数。
```cpp
int n,m,x,tot,Stop[N],tr[N][28];
void Ins(){
	int p=1;
	for(char c:x){
		if(!tr[p][c-'a']) tr[p][c-'a']=++tot;
		p=tr[p][ch-'a'];
	}
	Stop[p]++;
}
int Find(){
	int p=1,ans=0;
	for(char c:x){
		p=tr[p][ch-'a'];
		ans+=Stop[p];
	}
	return ans;
}
```

---

## 作者：leiaxiwo (赞：0)

# 题解：P10470 前缀统计
[传送门](https://www.luogu.com.cn/problem/P10470)
### 题意分析
字典树模版题，无非把模版的输入输出反了过来，没学过的建议移步 [P8306 【模板】字典树](https://www.luogu.com.cn/problem/P8306)。

这篇题解采用了相对少见的 `string` 完成，各位读者可以参考。
### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
string s;
int cnt=1;

struct __Trie{
	struct tr{
		int pointer;
		int son[35];
		int end;
	}trie[500005];
	void build(string s){
	    int l=s.size();
	    int now=1;
	    for(int i=0;i<l;++i){
		    if(trie[now].son[s[i]-'a']==0){
		    	trie[now].son[s[i]-'a']=++cnt;
			}
	    	now=trie[now].son[s[i]-'a'];
	    }
	    trie[now].end+=1;
	    return ;
    }
	int query(string s){
		int l=s.size();
		int now=1;
		int ans=0;
		for(int i=0;i<l;i++){
			now=trie[now].son[s[i]-'a'];
		    for(int j=now;j&&trie[j].end!=-1;j=trie[j].pointer){
			    ans+=trie[j].end;
		    }
		}
		return ans;
	}
}liver_trie;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		cin>>s;
		liver_trie.build(s);
	}
	for(int i=1;i<=m;i++){
		cin>>s;
		printf("%d\n",liver_trie.query(s));
	}
	return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

一眼看题目，绝对是字典树。

前置知识：[【模板】字典树](/problem/P8306)，还没学？[看这里！](https://oi-wiki.org/string/trie/)

但是与模板不同的是这道题需要的是 $S$ 中有多少是 $T$ 的前缀，而非 $T$ 是多少 $S$ 的前缀。

考虑将所有 $S$ 建字典树，同时将每个字符串结尾记录下。

查询时每次加上以当前点为结尾的单词数（以这个节点为结尾就一定是从“头”到这个位置都符合的字符串，也就是要找的前缀）。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,q,son[100001][123],cnt[100001][123],tot,mp[123];
string s;
void insert(string s){
    int x=0;
    for(int i=0;i<s.size();i++){
    	int c=mp[s[i]];
        if(!son[x][c])//如果没出现过就开点
            son[x][c]=++tot;
        if(i==s.size()-1)//是结尾要记录
            cnt[x][c]++;
        x=son[x][c];
    }
    return;
}
int find(string s){
    int x=0,ans=0;
    for(int i=0;i<s.size();i++){
        int c=mp[s[i]];
        if(!son[x][c])//没有儿子就停止
            break;
        ans+=cnt[x][c],x=son[x][c];//累加答案
    }
    return ans;
}
void Main(){
    for(int i=0;i<=tot;i++){
        for(int j=1;j<=62;j++)
            son[i][j]=0;
    }//初始化
    tot=0;
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>s;
        insert(s);//插入
    }
    while(q--){
        cin>>s;
        cout<<find(s)<<'\n';//查询
    }
    return;
}
int main(){
    for(int i='a';i<='z';i++)
        mp[i]=i-'a'+1;
    for(int i='A';i<='Z';i++)
        mp[i]=i-'A'+27;
    for(int i='0';i<='9';i++)
        mp[i]=i-'0'+53;//初始化
    Main();
    return 0;
}
```

---

## 作者：FallingFYC_ (赞：0)

[原题](https://www.luogu.com.cn/problem/P10470)

---
### 思路

就是把[【模板】字典树](https://www.luogu.com.cn/problem/P8306)的询问反了过来。

分两步：

1. 在添加时在字典树上标记一下每个模式串的结尾。
2. 在查询递归时加上路径上所有的结尾标记的数量。

还有一些易错点写在代码里了。

---
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 1e6 + 5;
int t , q , n , trie[MAX][26] , inx = 1 , e[MAX][26];
string mod , ask;

void insert(string s)
{
    int p = 1; //注意，这里从0开始会WA
    for (int i = 0 ; i < s.length() ; i++)
	{
        int x = s[i] - 'a';
        if (!trie[p][x]) trie[p][x] = ++inx;
        if (i == s.length() - 1) e[p][x]++;//不能加在最后
        p = trie[p][x];
    }
    return;
}

int find(string s)
{
    int p = 1 , ans = 0;
    for (int i = 0 ; i < s.length() ; i++)
	{
        int x = s[i] - 'a';
        if (!trie[p][x]) return ans; //这里不要像模板一样返回0
        if (e[p][x]) ans += e[p][x];
        p = trie[p][x];
    }
    return ans;
}

int main()
{
    cin >> n >> q;
    for (int i = 1 ; i <= n ; i++)
    {
        cin >> mod;
        insert(mod);
    }
    for (int i = 1 ; i <= q ; i++)
    {
        cin >> ask;
        cout << find(ask) << endl;
    }
    return 0;
}
```

---


# 【模板】字典树

## 题目描述

给定 $n$ 个模式串 $s_1, s_2, \dots, s_n$ 和 $q$ 次询问，每次询问给定一个文本串 $t_i$，请回答 $s_1 \sim s_n$ 中有多少个字符串 $s_j$ 满足 $t_i$ 是 $s_j$ 的**前缀**。

一个字符串 $t$ 是 $s$ 的前缀当且仅当从 $s$ 的末尾删去若干个（可以为 0 个）连续的字符后与 $t$ 相同。

输入的字符串大小敏感。例如，字符串 `Fusu` 和字符串 `fusu` 不同。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T, n, q\leq 10^5$，且输入字符串的总长度不超过 $3 \times 10^6$。输入的字符串只含大小写字母和数字，且不含空串。

### 说明
std 的 IO 使用的是关闭同步后的 cin/cout，本题不卡常。

## 样例 #1

### 输入

```
3
3 3
fusufusu
fusu
anguei
fusu
anguei
kkksc
5 2
fusu
Fusu
AFakeFusu
afakefusu
fusuisnotfake
Fusu
fusu
1 1
998244353
9```

### 输出

```
2
1
0
1
2
1```

# 题解

## 作者：qip101 (赞：249)

### 一.什么是字典树

Trie 树，即字典树，是一种树形结构。典型应用是用于统计和排序大量的字符串前缀来减少查询时间，最大限度地减少无谓的字符串比较。

Trie 树的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 

### 二.字典树的性质

1.根节点不包含字符，除根节点外每一个节点都只包含一个字符。

2.从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。

3.每个节点的所有子节点包含的字符都不相同。

下图就是一个字典树：

![](https://pic1.zhimg.com/v2-c6c00f279fb8a978ba6a7b08820e92e8_r.jpg)

### 三.字典树的操作

**1.映射字符**

```cpp
int getnum(char x){
    if(x>='A'&&x<='Z')
        return x-'A';
    else if(x>='a'&&x<='z')
        return x-'a'+26;
    else
        return x-'0'+52;
} 
```

**2.插入字符串**

```
void insert(char str[])
{
    int p=0,len=strlen(str);
    for(int i=0;i<len;i++)
    {
        int c=getnum(str[i]);
        if(!t[p][c])
            t[p][c]=++idx;
        p=t[p][c];
        cnt[p]++;
    }
}
```

**3.查询操作**

```cpp
int find(char str[])
{
    int p=0,len=strlen(str);
    for(int i=0;i<len;i++)
    {
        int c=getnum(str[i]);
        if(!t[p][c])
            return 0;
        p=t[p][c];
    }
    return cnt[p];
}
```

**4.main 函数部分**

```cpp
int main(){
    scanf("%d",&T);
    while(T--)
    {
        for(int i=0;i<=idx;i++)
            for(int j=0;j<=122;j++)
                t[i][j]=0;
        for(int i=0;i<=idx;i++)
            cnt[i]=0;
        idx=0;
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++)
        {
            scanf("%s",s);
            insert(s);
        }
        for(int i=1;i<=q;i++)
        {
            scanf("%s",s);
            printf("%d\n",find(s));
        }
    }
    return 0;
}
```

### 四.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,q,n,t[3000005][65],cnt[3000005],idx;
char s[3000005];
int getnum(char x){
    if(x>='A'&&x<='Z')
        return x-'A';
    else if(x>='a'&&x<='z')
        return x-'a'+26;
    else
        return x-'0'+52;
} 
void insert(char str[]){
    int p=0,len=strlen(str);
    for(int i=0;i<len;i++){
        int c=getnum(str[i]);
        if(!t[p][c])
            t[p][c]=++idx;
        p=t[p][c];
        cnt[p]++;
    }
}
int find(char str[]){
    int p=0,len=strlen(str);
    for(int i=0;i<len;i++){
        int c=getnum(str[i]);
        if(!t[p][c])
            return 0;
        p=t[p][c];
    }
    return cnt[p];
}
int main(){
    scanf("%d",&T);
    while(T--){
        for(int i=0;i<=idx;i++)
            for(int j=0;j<=122;j++)
                t[i][j]=0;
        for(int i=0;i<=idx;i++)
            cnt[i]=0;
        idx=0;
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++){
            scanf("%s",s);
            insert(s);
        }
        for(int i=1;i<=q;i++){
            scanf("%s",s);
            printf("%d\n",find(s));
        }
    }
    return 0;
}
```




---

## 作者：一扶苏一 (赞：81)

## 【trie】【B3627】【模板】字典树

## Analysis

考虑对模式串建立 trie 树，每个节点维护一个值 cnt，在每个模式串插入结束以后，从字典树上对应的结点令 cnt 加一。则每次查询相当于在 trie 树上匹配到的结点的子树中 cnt 的和。

于是在建立好 trie 树以后做一次 dfs，求出子树 cnt 和，就可以 $O(1)$ 回答查询了。

## Code

```cpp
#include <iostream>
#include <unordered_map>


struct Node {
  int cnt;
  std::unordered_map<char, Node*> ch;

  Node() : cnt(0) {};

  void dfs() {
    for (auto [x, y] : ch) {
      y->dfs();
      cnt += y->cnt;
    }
  }
};
Node *rot;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  int T, n, q;
  std::string s;
  for (std::cin >> T; T; --T) {
    std::cin >> n >> q;
    rot = new Node();
    for (int i = 1; i <= n; ++i) {
      std::cin >> s;
      auto u = rot;
      for (auto c : s) u = (u->ch[c] ? u->ch[c] : u->ch[c] = new Node);
      ++u->cnt;
    }
    rot->dfs();
    for (int i = 1; i <= q; ++i) {
      std::cin >> s;
      bool flag = true;
      auto u = rot;
      for (auto c : s) if (u->ch[c]) {
         u = u->ch[c];
      } else {
        flag = false; break;
      }
      std::cout << ((flag) ? u->cnt : 0) << '\n';
    }
  }
  return 0;
}
```

## gen

```py
from random import randint
import os

arr = [0, 1, 10, 100, 1000, 100000, 1]
temp = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

for id in range(1, 7):
  inname = "trie" + str(id) + '.in'
  ansname = 'trie' + str(id) + '.ans'
  f = open(inname, 'w', newline='\n')
  t = arr[id]
  f.write(str(t) + '\n')
  if id != 6:
    for tt in range(t):
      n = 100000 // t
      m = n
      last = 500000 // t
      text = []
      f.write(str(n) + " " + str(m) + '\n')
      for i in range(m - 1):
        s = str()
        lst = randint(1, (last // (m - i + 1)))
        for j in range(lst):
          s += temp[randint(0, len(temp) - 1)]
        text.append(s)
        last -= lst
      s = str()
      for i in range(last):
        s += temp[randint(0, len(temp) - 1)]
      text.append(s)
      last = 1500000 // t
      for i in range(n - 1):
        j = randint(0, len(text) - 1)
        lst = randint(1, (last // (m - i + 1)))
        s = text[j]
        for k in range(lst):
           s += temp[randint(0, len(temp) - 1)]
        f.write(s + '\n')
        last -= lst
      s = str()
      for i in range(last):
        s += temp[randint(0, len(temp) - 1)]
      f.write(s + '\n')
      for i in range(m):
        f.write(text[i] + '\n')
  else:
    f.write("100000 100000\n")
    lst = 1900000
    for i in range (100000):
      last = randint(0, lst // (100000 - i) - 1)
      s = 'a'
      for j in range(last):
        s += temp[randint(0, len(temp) - 1)]
      f.write(s + '\n')
      lst -= last
    for i in range(100000):
      f.write('a\n')
  f.flush()
  os.system('std.exe < ' + inname + ' > ' + ansname)
```



---

## 作者：npqenqpve (赞：25)

### 思路：

字典树模板题。

字典树是一种字符串前缀结构，每个结点表示的是某个字符串的前缀信息，自然可以维护 $s$ 是字典中多少字典串的前缀。

具体而言，每次添加操作只对路径上的点有贡献，可以考虑给路径上每个点的计数器加 $1$，那么答案就是文本串的结尾对应点的计数器大小，因为所有对这个点有贡献的点都存在于其子树之内，等价于文本串作为前缀。

当然，只在每个字典串的结尾打标记，答案为文本串的结尾的子树中标记的个数也是一个道理。

由于本题中字符集在字典序上并不连续，重新编号一下即可。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,tot,tag[(int)(3e6+10)];
map<char,int>mp;
int trie[(int)(3e6+10)][63];
void insert(char *s)
{
	int len=strlen(s+1),p=0;
	for(int i=1;i<=len;i++)
	{
		if(!trie[p][mp[s[i]]]) trie[p][mp[s[i]]]=++tot;
		p=trie[p][mp[s[i]]]; 
		tag[p]++;
	}
}
int query(char *s)
{
	int len=strlen(s+1),p=0;
	for(int i=1;i<=len;i++)
	{
		if(!trie[p][mp[s[i]]]) return 0;
		p=trie[p][mp[s[i]]]; 
	}
	return tag[p];
}
char s[(int)(3e6+10)];
signed main()
{
	int t,id=0;cin>>t;
	for(char i='a';i<='z';i++) mp[i]=++id;
	for(char i='A';i<='Z';i++) mp[i]=++id;
	for(char i='0';i<='9';i++) mp[i]=++id;
	while(t--)
	{
		cin>>n>>m;
		for(int i=0;i<=tot;i++)
		{
			tag[i]=0;
			for(int j=0;j<=62;j++)
			{
				trie[i][j]=0;
			}
		}
		tot=0;
		for(int i=1;i<=n;i++)
		{
			cin>>(s+1);
			insert(s);
		}
		for(int i=1;i<=m;i++)
		{
			cin>>(s+1);
			cout<<query(s)<<"\n";
		}
	}
	system("pause > null");
}
```



---


# [蓝桥杯 2020 国 B] 游园安排

## 题目描述

$\mathrm{L}$ 星球游乐园非常有趣，吸引着各个星球的游客前来游玩。小蓝是 $\mathrm{L}$ 星球 游乐园的管理员。

为了更好的管理游乐园，游乐园要求所有的游客提前预约，小蓝能看到系统上所有预约游客的名字。每个游客的名字由一个大写英文字母开始，后面跟 $0$ 个或多个小写英文字母。游客可能重名。

小蓝特别喜欢递增的事物。今天，他决定在所有预约的游客中，选择一部分游客在上午游玩，其他的游客都在下午游玩，在上午游玩的游客要求按照预约的顺序排列后，名字是单调递增的，即排在前面的名字严格小于排在后面的名字。

一个名字 $A$ 小于另一个名字 $B$ 是指：存在一个整数 $i$，使得 $A$ 的前 $i$ 个字母与 $B$ 的前 $i$ 个字母相同，且 $A$ 的第 $i+1$ 个字母小于 $B$ 的第 $i+1$ 个字母。(如果 $A$ 不存在第 $i+1$ 个字母且 $B$ 存在第 $i+1$ 个字母, 也视为 $A$ 的第 $i+1$ 个字母小于 $B$ 的第 $i+1$ 个字母)

作为小蓝的助手，你要按照小蓝的想法安排游客，同时你又希望上午有尽量多的游客游玩，请告诉小蓝让哪些游客上午游玩。如果方案有多种，请输出上午游玩的第一个游客名字最小的方案。如果此时还有多种方案，请输出第一个游客名字最小的前提下第二个游客名字最小的方案。如果仍然有多种，依此类推选择第三个、第四个……游客名字最小的方案。


## 说明/提示

对于 $20 \%$ 的评测数据, 输入的总长度不超过 $20$ 个字母。

对于 $50 \%$ 的评测数据, 输入的总长度不超过 $300$ 个字母。

对于 $70 \%$ 的评测数据, 输入的总长度不超过 $10000$ 个字母。

对于所有评测数据, 每个名字的长度不超过 $10$ 个字母, 输入的总长度不超过 $10^6$ 个字母。 

蓝桥杯 2020 年国赛 B 组 G 题。

## 样例 #1

### 输入

```
WoAiLanQiaobei```

### 输出

```
AiLanQiaobei```

# 题解

## 作者：qzmoot (赞：32)

# 题目解读
输入一个字符串，大写开头的是人名，要求输出这个字符串的最长上升子序列。
# 开始解题
对于如此大的数据：$10^6$ 用 $O(n^2)$ 的做法肯定会 TLE 所以我们考虑用二分优化。

对于二分，我们可以使用 `lower_bound` 函数，就是下界判断 `lower_bound(a.begin(),a.end(),value)` 就是当查找到的值: $mid<value$ 时就会继续，$mid\geq value$ 时返回。

由次我们就可以查找到数组中最小的数进行替换。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string a,dp[1000005],s[1000005],ans[1000005];
int h=0,t=0,cnt=1,idx=1,len=0;
int main()
{
	cin>>a;
	for(int i=0;i<a.size();i++)
	{
		if(isupper(a[i]))
			s[++cnt]=a[i];
		else
			s[cnt]+=a[i];
	}
	for(int i=1;i<=cnt;i++)
	{
		int pos=int(lower_bound(dp+1,dp+len+1,s[i])-dp);
		len=max(len,pos);
		dp[pos]=s[i];
		ans[pos]=ans[pos-1]+s[i];
	}
	cout<<ans[len];
    return 0;
}
```
### 第一篇题解给个赞吧！！

---

## 作者：Sirkey (赞：12)

~~这个题这么久了还没有题解？那我就不客气了！~~

首先我们处理字符串：当出入一个大写子母的时候就，便用一个来储存。 

这样：
```cpp
	while(cin>>a){
	    if('A'<=a && a<='Z') 
	       s[++top]=a;
	    else s[top]+=a;
	}
```
读懂题目，就可以知道求的是一个用字典序拍的最长上升子序列。

我们可以采用贪心的思想：

每一次都去加入一个 ` s[i] ` 如果 ` s[i] ` 可以加入当中最长上升子序列中。那么就直接加入，再记一下当前长度，每一个长度都需要记录，因为后面要用到长度去更新答案。

但是显而易见，有的时候是不满足的，所以便可以吧找的在当前状态中第一个比他大的数。如果跑一遍就会超时，但是因为当前状态的确拥有单调性，所以不难想到二分：

```cpp
first=lower_bound(k.begin(),k.end(),s[i])-k.begin()
```
那么思路就很清晰了，注意一下大小足足有 $ 10^6 $ 这么大，所以用一下
 ` vector  ` 便是最好的选择 。

最后以此枚举长度，获取答案。

听我说了这么多，代码来了 ：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MX=1e6+10;
char a;
int top=0;
string s[MX],ans[MX];
vector< string > k;
vector< int > len;
int main(){
	while(cin>>a){
	    if('A'<=a && a<='Z') 
	       s[++top]=a;
	    else s[top]+=a;
	}
	k.push_back(s[0]),len.push_back(1);
	for(int i=1;i<=top;i++){
	    if(s[i] > k.back()){
			k.push_back(s[i]);
			len.push_back(k.size());
		}
		else {
	            int first=lower_bound(k.begin(),k.end(),s[i])-k.begin();
		    k[first]=s[i];
		    len.push_back(first+1);
		}
	}
	int m=k.size(),cnt=0; 
	for(int i=top;m>0;i--)
		if(len[i]==m) {
			ans[++cnt]=s[i];
			m--;
		}
	for(int i=cnt;i>=1;i--)
		cout<<ans[i];
	return 0;
}
```
 $ k $ 是当前状态， $ len $ 是长度 。
 
 ——end——

---

## 作者：Lian_zy (赞：7)

# 题目传送门
[**P8736 \[蓝桥杯 2020 国 B\] 游园安排**](https://www.luogu.com.cn/problem/P8736)

# 题目分析
此题为字符串版的最长上升子序列。

由于最坏情况下，最多有 $10^6$ 个元素，而朴素的最长上升子序列的时间复杂度为 $O(n^2)$，肯定会炸。

此时我们就需要优化我们的程序，优化后的程序时间复杂度仅 $O(n \log n)$，可以通过 $10^6$ 级别的数据。

一上来就考虑字符串太难了，如果题目是数字呢？

我们可以开一个数组模拟一个栈，当元素 $x$ 大于它的栈顶元素，则使 $x$ 入栈，这样可以保证数组的单调性。

如果 $x$ 小于栈顶元素，则二分第一个比 $x$ 大的数，并替换它。最长序列长度即为最后模拟的大小。

这也是很好理解的，对于两个数 $i$ 和 $j$ 满足 $1 \le i,j \le n$，如果 $i < j$ 且 $a_i < a_j$，用 $a_i$ 替换 $a_j$，长度虽然没有改变但 $a$ 可能会变得更长。

数字版 $n \log n$ 的最长上升子序列的代码如下：

``` cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 1e6 + 10;
int i, j, n, s, t, l, r, m, a[maxn];
int main() {
	scanf("%d", &n);
	a[0] = -0x3f3f3f3f;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &t);
		if (t > a[s]) a[++s] = t;
		else {
			l = 1, r = s;
			while (l <= r) {
				m = l + r >> 1;
				if (t > a[m]) l = m + 1;
				else r = m - 1;
			}
			a[l] = t;
		}
	}
	printf("%d\n", s);
	return 0;
}
```

好了，现在数字版的最长上升子序列已经被解决了，但是字符串版的怎么办呢？

我们可以写一个比较函数，剩下的基本上就与数字版的 LIS 没区别了。

函数：

``` cpp
bool big(string a, string b) {
	if (a.size() == b.size()) {
		for (int i = 0; i < a.size(); i++) {
			if (a[i] == b[i]) continue;
			return a[i] > b[i];
		}
		return false;
	}
	return a.size() > b.size();
}
```

现在问题变得简单了，你可以把题解关掉去写代码了。

---

## 作者：fengqiao17 (赞：5)

## 题目大意

给你 $n$ 个名字，要求从中选出下标单调递增，字符串的字典序也单调递增的最长子序列。

## 解题思路

1. 输入比较简单，每次如果遇到大写字母就保存字符串，否则就继续累加，注意最后还要更新一次；
2. 维护一个数组 $b_i$，表示每一个最长上升子序列的最后一个字符串；以及一个 $ans_i$ 数组，表示以 $b_i$ 结尾的最长上升子序列答案。二分第 $i$ 个字符串在这个 $b_k$ 中的位置 $k$，由于是按顺序进行，所以下标单调。
3. 找到 $k$ 之后，我们就可以更新末尾，并且将 $ans_k$ 接上 $a_k$。这里注意要维护一个 $maxi$ 表示最长的最长上升子序列，这句话可能比较难懂，但是看代码应该可以理解。
4. 最后输出 $ans_{maxi}$ 即可。

## 代码编写

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
string a[N];
string b[N], ans[N];
int cnt = 0, maxi = 0;
int erfen(string s) {
  int lt = 0, rt = maxi + 1;
  while (lt + 1 < rt) {
    int mid = (lt + rt) >> 1;
    if (b[mid] >= s) {
      rt = mid;
    } else {
      lt = mid;
    }
  }
  return rt;  // 查找可以接上的最长上升子序列
}
int main() {
  string s;
  cin >> s;
  for (int i = 0; i < s.size(); i++) {
    if (s[i] >= 'a' && s[i] <= 'z') {  // 如果是小写字母就累计
      a[cnt] = a[cnt] + s[i];
    } else {  // 大写字母更新
      a[++cnt] = s[i];
    }
  }
  for (int i = 1; i <= cnt; i++) {
    int k = erfen(a[i]);  // 二分，这里的b[i]始终是有序的
    maxi = max(maxi, k);  // 更新最大值
    b[k] = a[i], ans[k] = ans[k - 1] + a[i];
  }
  cout << ans[maxi];
  return 0;
}
```

---

## 作者：PartiallyCorrect (赞：4)

这道题目是最长上升子序列的变形题。先用字符串读入。由于数据比较大，所以需要用二分优化，加一个数组做二分优化。还需要还原这个子序列，加一个数组来存储。具体代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int cnt=0,len=0;
string s,a[N],d[N],f[N]; 
int main(){
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]<'a') 
			a[++cnt]=s[i];
		else 
			a[cnt]+=s[i];
	}
	for(int i=1;i<=cnt;i++){
		int k=lower_bound(d+1,d+len+1,a[i])-d;
		len=max(len,k);
		d[k]=a[i];
		f[k]=f[k-1]+a[i];
	}
	cout<<f[len];
}
```


---

## 作者：快斗游鹿 (赞：3)

本题实际上就是要求字典序最小的最长上升子序列。考虑贪心加二分。每次都二分找出当前最长上升子序列中大于当前数的最小的数并替换，容易证明这样最后的最长上升子序列一定是字典序最小的。总时间复杂度 $O(n\log n)$。

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int cnt,id[N],c[N],a[N],len;
string S,s[N],t[N],f[N];
unordered_map<string,int>mp;
int find(int x){
	int l=1,r=len;
	while(l<=r){
		int mid=(l+r)>>1;
		if(x>c[mid])l=mid+1;
		else r=mid-1;
	}
	return l;
}
int main(){
	cin>>S;
	for(int i=0;i<S.length();i++){
		if(S[i]<'a')s[++cnt]+=S[i];
		else s[cnt]+=S[i];
	}
	for(int i=1;i<=cnt;i++)t[i]=s[i];
	sort(t+1,t+1+cnt);
	for(int i=1;i<=cnt;i++)mp[t[i]]=i;
	for(int i=1;i<=cnt;i++)id[i]=mp[s[i]];
	for(int i=1;i<=cnt;i++){
		int k=find(id[i]);
		c[k]=id[i];a[i]=k;
		len=max(len,k);
		f[k]=f[k-1];
		f[k]+=t[id[i]];
		
	}
	cout<<f[len];
}
```


---

## 作者：never_check (赞：2)

[返回题目](https://www.luogu.com.cn/problem/P8736) 
 
### 分析 

先按题目给出的，大写字母开头的子串是人名，把字符串分割成若干个子串，每串是由大写字母开头的，中间没有其他大写字母。然后用 DP 大法算出 LIS 长度。由于数据大，要有二分优化（不然等着 TLE 吧）。用 lower_bound 函数优化每一次更新，这就完美的 AC 了。

虽然题目说用字典树，但完全不需要。

首先先将子串进行拆分。

```cpp
for(int i=0;i<p;i++)        //拆解成若干个子串 {
       if(s[i]<'a') {
            a[++n]=s[i];
        }
        else {
            a[n]+=s[i];
        }
    }
```

然后进行 dp 操作即可完成。
```cpp
for(int i=1;i<=n;i++){
        t=lower_bound(dp+1,dp+maxl+1,a[i])-dp;
        maxl=max(maxl,t);
        dp[t]=a[i];
        f[t]=f[t-1]+a[i];
    }
```



---

## 作者：封禁用户 (赞：1)

# P8736 [蓝桥杯 2020 国 B] 游园安排

## 分析

看看题目，发现**每个人的名字开头都是大写**，可以用一个数组存下来。

容易发现本题是最长上升子序列板子，只不过数变成了字符串。

可是我看了数据……好吧，$O(n^2)$ 会爆啊！所以只能用**优化版**的最长上升子序列板子了。

时间复杂度 $O(n \log n)$ 可以允许。

## 最长上升子序列写法

理一下思路。

1. 提前排序字符串
2. 用 ```int pos=lower_bound(st+1,st+1+len,name[i])-st;``` 记录当前位置，用一个数组记录当前排序结果
3. 状态转移方程 ```dp[pos]=dp[pos-1]+name[i];```
4. 答案为 ```dp[len]```，其中 ```len=max(len,pos);``` 

## 代码

最后，来欣赏一下[精简的AC代码](https://www.luogu.com.cn/record/161463695)：

```cpp
#include<bits/stdc++.h>
using namespace std;
string name[1000005],dp[1000005],st[1000005];
int main(){
    string s;
    cin>>s;
    int cnt=0;
    for(int i=0;s[i];i++){
        if(isupper(s[i])) name[++cnt]=s[i];
        else name[cnt]+=s[i];
    }
    int len=0;
    for(int i=1;i<=cnt;i++){
        int pos=lower_bound(st+1,st+1+len,name[i])-st;
        len=max(len,pos);
        st[pos]=name[i];
        dp[pos]=dp[pos-1]+name[i];
    }
    cout<<dp[len];
    return 0;
}
```

---

## 作者：Mier_Samuelle (赞：1)

首先按照题目中的描述将字符串拆成若干个人名来存储，然后直接动态规划求最长上升子序列即可。

注意本题中人名数量可能达到 $10^6$，因此在更新状态的时候要用二分。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 1e6 + 10;
string dic[MAXN], dp[MAXN], ans[MAXN];
int main(){
     string str;
     cin >> str;
     int cnt = 0;
     //将字符串拆成人名
     for (int i = 0;i < str.length();i++){
          if (str[i] >= 'A' && str[i] <= 'Z') cnt++;
          dic[cnt] += str[i];
     }
     //直接dp求LIS
     int arr = 0;
     for (int i = 1;i <= cnt;i++){
          int pos = lower_bound(dp + 1, dp + arr + 1, dic[i]) - dp;
          arr = max(pos, arr);
          dp[pos] = dic[i];
          ans[pos] = ans[pos - 1] + dic[i];
     }
     cout << ans[arr] << endl;
     return 0;
}
```

---

## 作者：FallingFYC_ (赞：1)

# [原题](https://www.luogu.com.cn/problem/P8736)

少有的我都会的 DP。

---
### 分析&思路

我原本想的是用优先队列做，但这连样例都过不去，直到我看见了 `动态规划,dp` 的标签才恍然大悟。

这道题就是一道最长上升子序列（LIS）的变形。

[模板题](https://www.luogu.com.cn/problem/B3637) [讲解](https://blog.csdn.net/lxt_Lucia/article/details/81206439)

我们要求的，就是人名的最长上升子序列。但本题让我们输出最长上升子序列而不是最长上升子序列的长度，我们可以在转移的过程中记录即可。

---
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXS = 1e6;
int n , ansl;
string names , s[MAXS + 5] , f[MAXS + 5] , d[MAXS + 5];
int main()
{
    cin >> names;
    string ts = ""; names += 'F';
    for (int i = 0 ; i < names.length() ; i++)
    {
        if (!i) ts += names[i];
        else if (names[i] >= 'A' && names[i] <= 'Z') {s[++n] = ts; ts = names[i];}
        else ts += names[i];
    }

    //将d数组初始化极大值（这里是可能的最大的名字）
    for (int i = 1 ; i <= n ; i++) d[i] = "Zzzzzzzzzz";
    for (int i = 1 ; i <= n ; i++)
    {
        int now = lower_bound(d + 1 , d + n + 1 , s[i]) - d;
        f[now] = f[now - 1] + s[i];
        d[now] = s[i];
        ansl = max(ansl , now);
    }
    cout << f[ansl];
    return 0;
}
```

---

## 作者：CarroT5656 (赞：1)

**题目大意**

给定若干个字符串，要你输出它的 LIS。

**解法分析**

LIS 模板的简单变形。

考虑先划分原字符串，得到 $n$ 个字符串。

求这 $n$ 个字符串的 LIS 即可。

考虑记录 $f_i$ 表示长度为 $i$ 的上升子序列。

在转移过程中记录 $f_i=f_{i-1}+s$ 即可，$s$ 为当前字符串。

比较字符串的时间加上求 LIS 的时间，总时间复杂度为 $O(nk\log n)$，可以通过。

**Code**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1000005
using namespace std;
ll n,len;
string s,c[N],d[N],f[N]; 
int main(){
	cin>>s;
	for(ll i=0;i<s.size();i++){
		if(s[i]<'a') c[++n]=s[i];
		else c[n]+=s[i];
	}
	for(ll i=1;i<=n;i++){
		ll p=lower_bound(d+1,d+len+1,c[i])-d;
		len=max(len,p),d[p]=c[i];
		f[p]=f[p-1]+c[i];
	}
	cout<<f[len];
	return 0;
}
```

---

## 作者：Sun_Email (赞：1)

[题目 link](https://www.luogu.com.cn/problem/P8736)

地区的问题就不多说了（可直接见代码）。

介于字符串不好操作，可以考虑用 `map` 做“离散化”，注意保持“双向联通”（即通过字符串可以访问序号，通过序号也可以访问字符串）。

然后介于 $|S| \le 10^6$，`LIS` 需要用 $n \log n$ 的算法实现。

这个算法的具体思路：

对于每一个 $a_i$（这个指 $s_i$ 被离散化后的编号），用二分（当然  `upper_bound` 也行）找出它在目前的最长子序列的第一个 $\ge a_i$ 的位置（不妨设为 $l$），然后把 $dp_l$ 更新即可。


[`AC` 纪录](https://www.luogu.com.cn/record/111717620)，可放心食用。

`AC` 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string zong,t,s[1000001],x[1000001],f[1000001];
map<string,int> mp;
map<string,int>::iterator mit;
int len,a[1000001],tot=0,d[1000001];
int lis(){
	int l,r,mid,c=1;
	d[1]=mp[s[1]];f[1]=s[1];
	for(int i=2;i<=tot;++i){
		l=1;r=c;
		while(l<=r){
			mid=(l+r)>>1;
			if(d[mid]<a[i]){
				l=mid+1;
			}
			else{
				r=mid-1;
			}
		}
		c=max(l,c);d[l]=a[i];
		f[l]=f[l-1];f[l]+=x[d[l]];
	}
	return c;
}
int main(){
	cin>>zong;len=zong.length();
	//读入 
	for(int i=0;i<len;++i){
		if('A'<=(char)(zong[i])&&(char)(zong[i])<='Z'){
			mp[t]=1;s[++tot]=t;t.clear();
		}
		t+=zong[i];
	}
	mp[t]=1;s[++tot]=t;
	//离散化 
	int id=0;
	for(mit=mp.begin();mit!=mp.end();++mit){
		mit->second=++id;
	}
	for(int i=1;i<=tot;++i){
		a[i]=mp[s[i]];x[a[i]]=s[i];
	}
	len=lis();
	cout<<f[len];
	return 0;
}
```


---

## 作者：leiaxiwo (赞：0)

# 题解：P8736 [蓝桥杯 2020 国 B] 游园安排
[传送门](https://www.luogu.com.cn/problem/P8736)
### 题意分析
输入一个字符串，要求输出这个字符串的最长上升子序列。

朴素做法是 $O(n^2)$，这个时间复杂度会炸，我们遂采用二分优化解决此题。

对于二分我们可以用 `<algorithm>` 头文件的 `lower_bound` 二分函数解决，具体来说就是 `lower_bound(a.begin(),a.end(),value)` 就是当查找到的值：$mid < value$ 时就会继续，$mid \ge value$ 时返回。这个函数基于二分查找，只有 $O(\log n)$ 的时间复杂度，可以完成本题。

那么本题就结束战斗了。
### 代码参考
```cpp
//-std=c++14 
#include<bits/stdc++.h>
/*
#include<ext/rope>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
*/
using namespace std;
//using namespace __gnu_cxx;
string A,dp[1000005],B[1000005],lis[1000005];
int h=0,t=0;
int cnt=1,idx=1,len=0;
int main(){
	cin>>A;
	int l=A.size();
	for(int i=0;i<l;i++){
		if(isupper(A[i])){
			B[++cnt]=A[i];
		}
		else{
			B[cnt]+=A[i];
		}
	}
	for(int i=1;i<=cnt;i++){
		int pos=lower_bound(dp+1,dp+len+1,B[i])-dp;
		len=max(len,pos);
		dp[pos]=B[i];
		lis[pos]=lis[pos-1]+B[i];
	}
	cout<<lis[len];
    return 0;
}
```

---

## 作者：_smart_stupid_ (赞：0)

## [题目](https://www.luogu.com.cn/problem/P8736)

此题想让你求一个字符串数组里面的最长上升子序列。

## 做法

首先，预处理输入的字符串，如果当前字母是大写，就将之前的字串放进数组里，然后继续统计字串，否则，就把当前字母放进字串。

统计好字串后，就是最长上升子序列的板子，放入代码里即可。

时间复杂度：设字串长 $n$：$O((n)\log_2(n))$。

## AC Code：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <stack>
#include <cmath>
#include <list>
#include <set>
#include <map>
using namespace std;
string s;
string a[1000100];
int n;
string dp[1000100];
string ans[1000100];

int len = 1;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> s;
	int len = s.size();
	string tmp = "";
	for (int i = 0; i < len; i ++) {
		if (s[i] >= 'A' && s[i] <= 'Z') {
			n++;
			a[n] = tmp;
			tmp = "";
		}
		tmp += s[i];
	}
	n++;
	a[n] = tmp;
	len = 0;
	for (int i = 1; i <= n; i ++) {
		int p = lower_bound(dp + 1, dp + len + 1, a[i]) - dp;
		len = max(len, p);
		dp[p] = a[i];
		ans[p] = ans[p - 1] + a[i];
	}
	cout << ans[len];
	return 0;
}
```

---


# [常州市赛 2022] 文本找数

## 题目背景

搬运自 <http://czoj.com.cn/p/460>。数据为民间数据。



## 题目描述

正当小 $\text{X}$ 带着大家玩三角形游戏的时候，小 $\text{Y}$ 在编程中遇到了一个难题，来请教小 $\text{X}$。

小 $\text{Y}$ 遇到的难题是需要在一行文本中找最大的数，这一行文本中有整数和实数，也有字母、空格等其它各种字符。这一行文本最多包括 $10000$ 个字符，其中每个数的长度不超过 $100$（包括小数点），所有的数都没有正负符号，并且没有前导 $0$，所谓前导 $0$ 是指一个数中开头可 以省略的 $0$，如 $007$ 中的两个 $0$ 就是前导 $0$，$0.618$ 中小数点前的 $0$ 不是前导 $0$。也就是说文本中出现的整数必定是一串连续的阿拉伯数字，除了 $0$ 以外所有整数的首位一定不是 $0$。文本中出现的实数必定是一串连续的阿拉伯数字并且中间夹杂着一个唯一的小数点，该小数点两侧必须是数字，并且小数点左侧一定是上文所述的整数。

## 说明/提示

### 样例解释
对于样例 $1$，有 $120,315,513,512,153,0$ 六个数，最大的数为 $513$。

对于样例 $2$，有 $5,2.1,4,3.77442,5.0$ 五个数，最大的数有两个，$5.0$ 的长度更长。

### 数据规模与约定
对于 $10\%$ 的数据，文本为用空格隔开的若干个非负整数（范围在 int 以内），且最后一个数为 $0$，其余的数都不为 $0$； 

对于另外 $40\%$ 的数据，文本中不包含小数点；

对于 $100\%$ 的数据，文本长度 $≤10^4$，单个数的长度 $≤100$。

## 样例 #1

### 输入

```
120 315 513 512 153 0```

### 输出

```
513```

## 样例 #2

### 输入

```
5r2.1q 4p 3.77442qw cock5.0$```

### 输出

```
5.0```

# 题解

## 作者：__Kyw666__ (赞：1)

## 题意解释

给你一串字符串，要求提取出其中的数字，并比较大小。

## 思路分析

这里介绍一个纯用字符串的方法，很好理解。\
这道题的关键是怎么比较两个字符串数字的大小，这里分 $2$ 种情况讨论。

### 整数之间的比较

1. 比较位数，位数大的数值就大。
2. 位数相同，直接按字符串的字典序比较，字典序大的数值就大。

### 小数之间的比较

小学时候就学过，比较小数可以把它们的小数点同时右移，化成整数后再比较。

1. 判断两个数小数点的位置，没有小数点就记作 $0$。同时记下它们小数点后分别有几位数字。
2. 如果是小数，就去除小数点。小数点后位数较少的数要往后添 $0$。
3. 两个数都化成了整数，就按上面**整数之间的比较方法**比较。  

**特别注意**！如果两数相同还要比较小数点后的数字位数。
## 代码实现

```
#include<bits/stdc++.h>
using namespace std;

int cnt;
string a,t;
string num[10005];
bool cmp(string x,string y)
{
	int s1=0,s2=0;
	for(int i=0;i<x.size();i++)
		if(x[i]=='.')
		{
			s1=x.size()-i-1;
			break;
		}
	for(int i=0;i<y.size();i++)
		if(y[i]=='.')
		{
			s2=y.size()-i-1;
			break;
		}
	if(s1!=0) x.erase(x.size()-s1-1,1);
	if(s2!=0) y.erase(y.size()-s2-1,1);
	if(s1>s2)
	{
		for(int i=1;i<=s1-s2;i++) y+="0";	
	}
	else if(s2>s1)
	{
		for(int i=1;i<=s2-s1;i++) x+="0";
	}
	if(x!=y) 
	{
		if(x.size()!=y.size()) return x.size()>y.size();
		return x>y;
	}
	return s1>s2;
}
int main()
{
	getline(cin,a);
	for(int i=0;i<a.size();i++) 
	{
		if(a[i]>='0'&&a[i]<='9') continue;
		else if(a[i]!='.'&&a[i]!=' ') a[i]=' ';
	}
	for(int i=0;i<a.size();i++)
	{
		if(a[i]==' '&&a[i+1]==' ') continue;
		else t+=a[i];
	}
	int head=0;
	t+=' ';
	for(int i=0;i<t.size();i++)
	{
		if(t[i]==' ')
		{
			cnt++;
			num[cnt]=t.substr(head,i-head);
			head=i+1;
		}
	}
	sort(num+1,num+cnt+1,cmp);
	cout<<num[1];
	return 0;
 } 
```

结束！

---

## 作者：Yi_chen123 (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/B4212)

## 前置知识

`istringstream` 是一种特殊的输入流对象，即字符串输入流，它的使用与正常的输入流相差不大，只是把输入数据的地方改为了一个字符串内部。\
下面是一个例子（不完整代码）：

```cpp
string s = "114514 hello";
istringstream iss(s); //一个关联字符串 s 的字符串输入流
int n; string s1;
iss >> n >> s1; //使用字符串输入流进行字符串内的输入
cout << n << endl << s1;
```

输出结果如下：

```
114514
hello
```

出处：[另一篇我的题解。](https://www.luogu.me/article/u3f6wu8g)

## 思路

众所周知，`cin` 在读入整数与浮点数时，一般以空格（或者换行）作为分界线，`istringstream` 也不例外。\
那么，我们可以利用这个特性，将不是数字和小数点（`.`）的字符全部过滤为空格，再用 `istringstream` 逐个读入最终“存活”下来的浮点数或整数，比较它们的大小即可。\
但是…… 我们遇到了两个问题欸！

- 题目中明文规定，如若遇到若干个相等的数，需要输出长度更长的，但我们仅通过现有的思路，无法比较两个值相等的数在原串内的长度。
- 与此同时，输出也需要将所有数字“打回原形”，即要原封不动地输出数在原串内的形态，比如在原串内是 `5.000` 就不能输出 `5`，只读入浮点数仍然很难办到……

其实，我们解决刚才的问题并不难，我们首先以字符串的形式读入每个数，再使用 C++11 以上支持的 `stod()` 函数，将一个 `std::string` 转换为一个双精度浮点数（`double`），即能比较数在原串内的长度，又能输出数在原串内的形态，这样不就能秒杀了吗？

## 正解

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    getline(cin, s);
    
    for(int i = 0; i < s.size(); ++i){
    	if(!isdigit(s[i]) && s[i] != '.'){
    		s[i] = ' '; //过滤无关字符为空格
		}
	}
	istringstream iss(s);
    string now, real; //now 为当前读入字符串，real 为最大数在原串中的真实形态
    double ans = -1;
    while(iss >> now){
        double k = stod(now); //转浮点数
        if(k > ans) //数值本就不同
        	real = now, ans = k;
        else if(k == ans && now.size() > real.size()) //数值相等，长度不同
            real = now;
	}
    cout << real;
    return 0;
}
```

---

## 作者：ZeroOf149 (赞：0)

# [B4212 [常州市程序设计小能手 2022] 文本找数](https://www.luogu.com.cn/problem/B4212)

## 题目描述

给一些实数，原样输出最大的实数。如果有多个，输出最长的。**忽略所有其它字符**。

## 解法说明

首先需要明确：所谓“其它字符”，指既不是数字、又不是小数点的字符。

考虑没有“其它字符”时怎么做。  
我们可以记录当前的答案与其对应的最大实数，新输入一个字符串时，先将其转换为浮点数，再与最大值比较。如果它比当前最大值还要大，那么就更新答案与最大值；如果它恰为当前最大值，那么根据字符串长度更新答案。  
代码看起来是这样的：
```cpp
while (cin >> now) {
  double v = 0;
  std::from_chars(now.c_str(), now.c_str() + now.length(), v);  // 转换到浮点数
  if (v > mx) {
    ans = now;
    mx = v;
  } else if (v == mx && now.length() > ans.length())
    ans = now;
}
```

现在，我们需要处理“其它字符”。  
我们希望 `std::cin` 能忽略“其它字符”。换言之，我们希望 `std::cin` **将“其它字符”识别为空格**！

现在的问题是：识别的源头在哪？

我们能够发现，`std::cin` 可以通过 `imbue(const std::locale&)` 这一个成员函数更改本地化方式，而它的字符分类功能是与 `std::ctype` 关联的。  
此时解法很清晰了：考虑从 `std::ctype<char>` 继承一个类，然后修改底层的字符分类表，最后将其传进 `std::cin` 并使用上文的正常解法。  
实现细节见代码实现。

## 代码实现
```cpp
#include <charconv>
#include <iostream>
#include <string>
#include <vector>

using std::cin;
using std::cout;
using std::string;

struct csv_number : std::ctype<char> {
  csv_number(std::size_t refs = 0) : ctype(make_table(), false, refs) {}  // 构造时使用新表
  
  static const mask* make_table() {
    static std::vector<mask> v(classic_table(), classic_table() + table_size);  // 获取原表
    for (int ch = 0; ch < 128; ++ch)
      if ((ch < '0' || ch > '9') && ch != '.') v[ch] |= space;  // 如果是“其它字符”就分类为空格
    return &v[0];
  }
};

double mx;
string now, ans;

int main() {
  cin.tie(nullptr);
  cout.tie(nullptr);
  std::ios::sync_with_stdio(false);
  cin.imbue(std::locale(cin.getloc(), new csv_number));  // 将改好的分类使用指针传递。
  while (cin >> now) {
    double v = 0;
    std::from_chars(now.c_str(), now.c_str() + now.length(), v);
    if (v > mx) {
      ans = now;
      mx = v;
    } else if (v == mx && now.length() > ans.length())
      ans = now;
  }
  cout << ans;
  // 这里不用 delete 的原因是 std::locale 会自动析构指针指向的资源。
}
```

---


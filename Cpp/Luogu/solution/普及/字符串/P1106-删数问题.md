# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# 题解

## 作者：expin (赞：258)

我们的思路是这样的：要删m个数，一开始m=k，在左边m+1个数中，找到其中最小的数（如果有多个则选最左边的），记它的位置为t，显然，t左边的l个数都可以删掉，此时还需要删m-l个数，m重新赋值为m-l，而t右边的数是一个新的数列，进行同样的操作，直到选出了n-k个数为止。

证明？我们希望从左开始在尽量大的范围内找到一个最小的数作为结果的第一位，但范围不能超过m+1，否则可能把左边全部m个数删了也无法把找到的数作为第一位，第一位找到后是第二位，同理。。可以，这很贪心

这样做可以每找出一个数就**直接输出**，但还要考虑前导0的问题。以及，若循环结束什么都没输出（意味着答案是0）就在程序结束前输出0。

以下是代码，思路如上：

```cpp
#include<iostream>
#include<string>
using namespace std;
int n,k,a[257],rest,t=1,minp,cnt=0;
bool flag=0;
string num;
int main(){
    cin>>num>>k;
    n=num.length();
    for(int i=1;i<=n;++i)a[i]=num[i-1]-'0';
    rest=n-k;
    while(cnt<rest){
        minp=t;
        for(int i=t;i<=k+t;++i)if(a[minp]>a[i])minp=i;
        if(a[minp])flag=1;
        if(flag)cout<<a[minp];
        k-=minp-t;
        t=minp+1;
        cnt++;
    }
    if(!flag)cout<<0;
    return 0;
}
```

---

## 作者：修罗海神王 (赞：194)

# 大家好，
###### 本蒟蒻又回来了（逃……………………………
好了！话不多说，让我们来看一下这道题目

首先，我们先举一个例子：

   1 7 5 4 3 8
   
   删的个数：4
   
   不难看出：
   
   第一次删的应该是  7
   
   第二次删的应该是  5
   
   第三次删的应该是  4
   
   第四次删的应该是  8
   
那么，剩下的数就是“13”（经过比较发现确实正确）

是如何得出规律的呢？？
   我们仔细观察一下这个例子：
   
   第一次删的数为7，和5比较，发现7跟大（简单表述）
   
   第二次删的数为5，和4比较，发现5跟大
   
   第三次删的数为4，和3比较，发现4跟大
   
   第四次删的数为8，和最后一个数（应该是a[7]（假设有，并为0））比较，发现5跟大

   大家有木有发现规律？？
   很明显，就是删去下坡数，也就是这个例子中的7（比5大）、5（比4大）、4（比3大）、8（比最后一个大（假设有，并为0））。如果您已经掌握，能么，希望您可以看懂下面的代码，本蒟蒻就不多做解释了（感谢大佬们给我的启发）：：
  ```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
int n,a[251],l,k;
int main()
{
    cin>>st;cin>>n;l=st.size();
    for(int i=0;i<l;i++) a[i]=st[i]-'0';
    for(int i=1;i<=n;i++)
      for(int j=0;j<l;j++)
        if(a[j]>a[j+1]) 
		{
            for(int k=j;k<l;k++) a[k]=a[k+1];
            l--; break;
        }
    int i=0; 
    while(a[i]==0&&k<l-1) {k++;i++;}
    for(int i=k;i<l;i++) cout<<a[i];
    return 0;
}
```

防抄袭万岁！！！！！！！！！！   

---

## 作者：xh39 (赞：141)

# 这一题主要是找到高峰就删，代码不难。
## 还要注意前导零。（如果最后一个点wa的，肯定是没注意答案是0的情况）
#### 思路都已经说到这里了，代码就不用看了吧。~~（除非你实在是做不出来）~~






```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string n;
    int s,i;
    cin>>n>>s;
    while(s){
        for(i=0;n[i]<=n[i+1];){//找高峰期
            i++;
        }
        n.erase(i,1);//删除函数,就是从第i个位置连续删1个。如果不清楚删除函数，可以百度。
        s--;
    }
    while(n[0]=='0'&&n.size()>1){//处理前导零，注意如果长度是1就不能再删了。
    	n.erase(0,1);
	}
    cout<<n;
    return 0;
}
```

---

## 作者：KesdiaelKen (赞：128)

我的思路与下面的各位大佬有点不一样。因为题目最终求的是删数后最小的一个数，其实我们可以将问题直接转换为保留几位数字，使最后的数最小。于是，就有贪心的算法了：

首先，考虑第一位。将第一位所有可能的位置枚举一下，取最小且最前的一个。因为同样长度的数字比较看开头，于是这样便保证了第一位的最优性。要注意，要取最前的一个，尽量保留更多的可选数。而第二位就在第一个数之后的所有允许范围内枚举，方法同第一位。这样，取完了所有要取的数，然后输出就可以了。

这里注意一下，题目并没有很明确的说要去掉前导零，但是事实上数据是要去的。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
#include<iostream>
using namespace std;
int main()
{
    char num[500];
    int gs,bl;
    scanf("%s%d",num,&gs);//读入
    int len=strlen(num);//取总长
    bl=len-gs;//得到需要保留的数的个数
    int shu[500];
    for(int i=0;i<len;i++)shu[i]=num[i]-'0';//转化为整数类型，并存储
    int bln[500],js=0,sgw=-1;//注意初始化，上一个开头要取-1，因为第一位有可能取第0个
    int lim,minn;
    while(bl-js)//即枚举bl次
    {
        minn=2e9;//初始化，minn=inf
        for(int i=sgw+1;i<=len-bl+js;i++)if(shu[i]<minn)minn=shu[sgw=i];//取最小且最前的数
        bln[js++]=shu[sgw];//加入到数中
    }
    int start=0;
    while(bln[start]==0&&bl-start-1)start++;//去前导零
    for(int i=start;i<bl;i++)printf("%d",bln[i]);//输出
    return 0;
}
```

---

## 作者：Atmizz (赞：63)

# 题解：
敲完代码，来看这个题，很简单的一个贪心普及-的题目（其实我提交了三遍）。

大家可以模拟这个过程，听别人说，这个数据并不是很强大，所以我还是一开始WA了最后一个点。。

## 我提供一个简单思路：
首先来看一个例子->
输入n和4
- n=175438         //删掉7
-   15438          //删掉5
-   1438           //删掉4
-   138            //删掉8
-   13            //解为13

先将字符串的数字转化为整数的数组（~~其实也可以不用转化，但是我习惯了~~），然后寻找高位上的减区间，再将将减区间的第一个数删去，最后输出。但是注意一点，就是删去前导0，不然的话，输入10和1 ，就会啥也不输出（~~我才不告诉你我咋知道的~~）。

#### 去除前导0的code：
```cpp
while(a[i]==0 && l<len-1) {// 删去前导 0 ，l<len-1防止10 1 的数据啥也不输出，减去一个‘1 ’输出 0 
	l++;//开头的下标加 
	i++;//找下一个 
}
```
## emmm~~ 给出全部code:
```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
using namespace std;
string s;
int n,a[251];
int main()
{
	cin>>s;//输入数字 
	scanf("%d",&n);//减少的位数 
	int len=s.length();//看一下有多少位 
	for(int i=0;i<len;i++)
		a[i]=s[i]-'0';//将字符串转化为整数数组 
	int l=0;//输出的开头下标 
	for(int i=1;i<=n;i++) {//要删掉的数字个数 
		for(int i=0;i<len;i++) {//从头到尾扫一遍 
			if(a[i]>a[i+1]) {//找到了高位大于低位的数 
				for(int j=i;j<len;j++)//后面的数前移一个下标 
					a[j]=a[j+1];
				len--;//长度减小 
				break;//继续找下一个，或许可以减少时间 
			}
		}
	}
	int i=0; 
	while(a[i]==0 && l<len-1) {// 删去前导 0 ，l<len-1防止10 1 的数据啥也不输出，减去一个‘1 ’输出 0 
		l++;//开头的下标加 
		i++;//找下一个 
	}
	for(int i=l;i<len;i++)//输出 
		printf("%d",a[i]);
	return 0;//最后结束 
}
```


---

## 作者：saxiy (赞：46)

## $O(nlogn)$ 算法

### 前置芝士

- ST算法: [P3865 【模板】ST表](https://www.luogu.org/problem/P3865)

### $O(nlogn)$ 切了这道题需要用到的思想&&算法

1. RMQ（这里以ST算法为例）

2. DP（最简单的状态转移）

3. 贪心（局部最优 => 全局最优）

### 思路:

- 题目给到 $n$ 和 $k$

1. 怎么保证删完 $k$ 位数后剩下的数最小呢？

- 同大多数想法相同，改删数为取数，由于k的限制，我们每次只能枚举 $i$ ~ $i+k$ 这个区间（即 $k+1$ 位数）这样就算我们取到最后第 $i+k$ 位数，我们也有能力删掉前 $i$ ~ $i+k-1$ 这 $k$ 位数，贪心地想，因为最后 $n$ 删完的数字位数是一定的，那么就需要保证在高位的数越小越好，即在当前我们考虑的区间 $i$ ~ $i+k$ 中，我们要选取最小的那个数，一遍暴力扫是肯定不能保证 $O(nlogn)$ 的复杂度的，对于这种 **RMQ** 问题，我们选择 **ST** 算法，保证每次查询是 $O(1)$ 的复杂度。

2. 现在我们选到了 $i$ ~ $i+k$ 这个区间的最小值，怎么才能定位这个数呢？

- 确定一个二维数组 $last$ ，让 $last_{i,j}$ 表示第 $i$ 位时下一个最近的 $j$ 的位置，显然我们可以得到 $last_{i,j}= last_{i+1,j} (a_{i}\not=j)$ , $last_{i,j}= i (a_{i}=j)$ ，注意到这个状态是由后一个状态转移而来，我们一遍逆序就可以得到整个数组，即我们想要调用的信息，这就是最简单的状态转移。

### 代码实现

代码里有很多小的细节，比如各种边界问题，我也debug了很久 ~~（10分钟？）~~

这里是 [U83355 删数问题【升级版】](https://www.luogu.org/problem/U83355)，卡掉了所有 $O(n^{2})$ 算法，可以试一试。

```cpp
#pragma GCC optimize("Ofast,fast-math,unroll-loops")
#include <bits/stdc++.h>
#define N 500005//我开的很大，其实没必要
#define LOG_N 20
using namespace std;

char str[N];
int n, k, a[N], last[N][10];
int f[N][LOG_N], lg[N];

void init() {
	scanf("%s%d", str, &k);
	n = strlen(str);
	lg[1] = 0;//预推一遍log数组，节约调用cmath库log函数的时间
	for(int i = 2;i <= n;i++)
		lg[i] = lg[i >> 1] + 1;
	*last[n] = n;//边界条件，细节x1（可以注释掉这行试一试）
	for(int i = n - 1;~i;i--) {
		a[i] = *f[i] = str[i] - '0';
		memcpy(last[i], last[i + 1], sizeof(int) * 10);//（暴力复制）
		last[i][a[i]] = i;
	}
	for(int i = 1;i <= lg[n];i++)
		for(int j = 0;j + (1 << i) <= n;j++)//ST算法
			f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);
}

int minx(int l, int r) {
	int k = lg[r - l + 1];//写成函数方便调用和debug，是个好习惯。
	return min(f[l][k], f[r - (1 << k) + 1][k]);
}

void work() {
	bool flag = 0;
	for(int i = 0;i < n;i++) {
		int minn = minx(i, i + k);
		k -= last[i][minn] - i;
		i = last[i][minn];
		if(i >= n) break;//细节x2，先判边界，因为之前没有考虑i+k的溢出
		if(minn || flag) putchar(minn + '0'), flag = 1;//判前导0（选数时前几位可能选0）
	}
	if(!flag) putchar('0');//如果什么都没有输出，即答案为0
} 

int main() {
	init();
	work();
	return 0;
}
```

### 抄题解是不对的QAQ~

---

## 作者：KillerXu (赞：31)

说实话，这道题真的做到我绝望

思想主要是，既然是删数，那不如简化一下问题，变删数为选数。

且读入字符串时，给它转换为数字

这是一个贪心思想，高位尽量选小的，但是顺序又不能改变

##所以循环时边界条件不是数的长度，而是长度-还剩的要选的个数

但是打起来，我连续犯了很多错误：

首先，最后一个数据是有误的，与题意不符，会输出0，这个输出是需要特判一下。

下面是我犯的所有错误，希望大家引以为戒

1、在暴力模拟每个数时，一失误把条件在循环内改变了，于是整个输出简直都要爆炸。

2、题意没彻底理解透，对于前导0的问题，我以为是有前导就不能选，然而不是那样，是选完再删去前导0（重点），也就是说读入10位数要求删去5位，如果里面有0，输出不一定是5位！

3、最后的输出，还是删前导0的问题，一开始我是判断只要出现前导0，i自加，然而那样输出会少一位（低级错误），所以应该是跳过：continue。

4、导致我做了将近半小时的原因是：代码乱。这个应该是所有比赛最忌讳的，因为这样及其难差错，所以，以后还是发挥一下强迫症吧= =


于是，混乱的代码：

    
    
    
    
    
     
```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    char n[255];//字符串读入
    int k;
    int i,j,t=0,f=1,t2=1//t2，解决循环变量问题
    char min;
    int a[255],b[255],p;//a用来转换，b用来输出
    scanf("%s",n);
    scanf("%d",&k);
    for(i=0;i<strlen(n);i++) a[i+1]=n[i]-'0';//转换为数字好算
    p=strlen(n); int s=p-k;//s为还需选数的个数
    for(i=1;i<=p-k;i++)
    {
        min=10;
              for(j=1;j<=p-s+1;j++)//p-s+1，p-(s-1)的化简，求出可以循环的边界，避免到最后无数可选
        {
            if(a[j]<min){min=a[j]; t=j;}//求最小。可以看出t在改变，所以后面要赋值给t2
        }
        s--;
        b[i]=a[t];
        t2=t+1;
        f++;
    }
    i=1;
    int flag=0;
    for(i=1;i<=f-1;i++) 
    {
        if(f-1>1&&flag==0&&b[i]==0) continue;//去前导0，只要flag为假，就说明此时的0是前导0，不输出。f-1>1为了过最后的数据
       else
       {
           flag=1;
          printf("%d",b[i]);
         }
      }
    return 0;//泪奔，一道如此之难的贪心，模拟题
}
```

---

## 作者：TLE_ooo (赞：20)

因为本蒟蒻水平过于真实，这道题目只会用模拟来做。。。
首先这题是一道小学的奥数题，采取贪心的思想（要不是我们老师在上贪心时出了这道题）。从高位起，一旦出现大数位于小数前，删除大数即可（不知道的童鞋可以自己推一下）。
下面直接上AC代码（带注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
string n;//开全局变量，因为下面的自定义函数中要用到 
int k;
string del(int x)//删除n字符串中第x位的字符 
{
	string s;
	for(int i=0;i<n.size();i++)
	{
		if(i==x)
			continue;
		else
			s+=n[i];//字符串可以直接相加 
	}
	return s;
}
void check(string &x)//去除前导0 
{
	while(x[0]=='0')
		x=del(0);
}
int main()
{
	cin>>n;
	cin>>k;
	int tot=0;//计数器清零 
	int i=0;//字符串下标指针归零 
	while(1)
	{
		if(n[i]>n[i+1])//若出现逆序（大的在小的前面），删除大数 
		{
			n=del(i);//删数 
			check(n);//去0 
			i=0;//每次删完都要再次从头开始扫 
			tot++;
			if(tot==k)
				break;
		}
		else
			i++;//符合顺序，指针指向下一位下标 
	}
	for(int i=0;i<n.size();i++)
		cout<<n[i];
	if(n.size()==0)//特殊条件判断 
		cout<<0;
	return 0;
}
```


---

## 作者：williamllk (赞：19)

## 本蒟蒻又来发题解了!

最近刚自学了贪心算法，就碰到了这道题目，那么下面开始讲解题目

[题目](https://www.luogu.org/problem/P1106)

------------
如何决定哪位被删除呢？是不是最大的那个数字呢？显然不是，很容易举出一些反例。

为了尽可能逼近目标，选取的贪心策略为：

## 每一步总是选择一个使剩下的数最小的数字删去

即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字，否则删除第一个递减区间的首字符，这样删一位便形成了一个新数字串。然后回到数字串首，按上述规则再删下一个数字。重复以上过程s次为之，剩下的数字串便是问题的解

接下来给出AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string n;
int s,len,k;
int main(){
	cin>>n>>s;
	len=n.length();
	while(s>0){
		s--;
		k=len-1;
		for(int i=0;i<len-1;i++){
			if(n[i]>n[i+1]){
				k=i;
				break;
			}
		}
		n.erase(k,1);
		len--; 
	}
	while(n[0]=='0') n.erase(0,1);
	if(n!="") cout<<n<<endl;
	else cout<<"0"<<endl;
	return 0;
}
```

最后附上[AC链接](https://www.luogu.org/record/27684809)

---

## 作者：Sol1 (赞：19)

设 $n=\lceil\lg N\rceil$，通俗来说就是 $N$ 的位数。

貌似目前所有题解给出的都是复杂度高于 $O(n \log n)$ 的算法，这里给出此题最快的 $O(n)$ 算法。

思想还是一样的，即如果一个数比后面的数大就删掉。

关键在于要反向考虑这个问题，即考虑一个数可以删掉哪些数。

如果第 $i$ 个数比第 $i-1$ 个数大，那么我们称第 $i$ 个数可以删掉第 $i-1$ 个数。这样，我们就可以采用对于一个数暴力往前跳然后删除的算法。

于是我们发现现在关键就在于维护这个序列，支持快速单点删除和快速求前驱后继。显然可以使用双向链表。

这样做为什么是 $O(n)$ 的呢？因为这样遍历一个数就会删掉它，每一个数最多被删除一次，而只有 $n$ 个数，删除为 $O(1)$，所以复杂度均摊一下就是 $O(n)$。

为啥是最优复杂度呢？

显然，读入是 $O(n)$。~~除非你有不读入的算法~~

至此，问题解决。

实现上的细节其他题解已经说的很清楚了，这里不再赘述。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

string s;
int n, k, nxt[1000005], prv[1000005];

void Solve() {
    int start = 0;
    for (int i = 0;i < n - 1;i++) {
        nxt[i] = i + 1;
        prv[i + 1] = i;//双向链表
    }
    prv[0] = -1;
    nxt[n - 1] = -1;
    for (int i = 1;i != -1;i = nxt[i]) {
        int cur = prv[i];
        //往前跳并删除
        while (cur >= 0 && s[i] < s[cur]) {
            //printf("delete %d\n", cur);
            cur = prv[cur];
            k--;
            if (k == 0) break;
        }
        if (cur >= 0) {
            nxt[cur] = i;
            prv[i] = cur;
        } else {
            start = i;
            prv[i] = -1;
        }
        if (k == 0) break;
        //printf("%d\n", i);
    }
    int siz = 0;
    for (int i = start;i != -1;i = nxt[i]) {
        siz++;
    }
    bool flag = 0;
    siz -= k;
    for (int i = start;i != -1 && siz;i = nxt[i], siz--) {
        if (s[i] != '0') flag = 1;
        if (flag) putchar(s[i]);
    }
    if (!flag) putchar('0');
}

int main() {
    cin >> s >> k; n = s.length();
    Solve();
    return 0;
}
```

---

## 作者：邪恶力量 (赞：6)

# 思路很重要
~~这道题数据虽然很水~~，但有坑。本蒟蒻提交4遍才AC。

我一开始的思路是删掉最大的数，但是想想有不对，例如
235493，删一个数，如果删最大数9，变成23543
，但显然应该删5，变成23493<23543。所以这个思路不对。

仔细观察，才发现如果前面的数比后面大，就应删去，
如36593，因为6比5大所以先删，如果删2个，则删6和9。

这样可以完美避开0的问题，在0前的所有数比0大，我删数的思路是，将后面的数整体向前移1格，将数覆盖就行了。

**重点来了，如果数为10101，删2个，正常答案为1，但用上面的方法会输出001，所以要在输出时判断。**

来看代码，首先初始化数组：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
int main()
{
    char a[300];
    for(int i=0;i<=299;i++)     //用a充当空
    a[i]='a';
    int n,num=0,s=0,jud=1;
    cin>>a>>n;
    int len=strlen(a)-1;        //由于从0开始，长度减1
    for(int j=1;j<=n;j++)       //删n次
    for(int i=0;i<=len-(j-1);i++)//每删一次，长度-1
        { 
            if(i==len-(j-1))  //如果循环到最后一个数时
            {       //说明数字递减，必须删最后一个数
                a[i]='a';//a当空表示
                s=1;     //s为判断符，为1时结束循环
            }
            else
            if(a[i]!='0'&&a[i]>a[i+1])如果前面的数比后面大，就应删去
                {
                    for(int k=i;k<=len;k++)//覆盖掉被删的数字
                    a[k]=a[k+1];
                    s=1;
                }
            if(s==1)//s为1说明删了数，结束i的循环
            {
                s=0;
                break;
            }
        } 
    for(int j=0;j<=strlen(a)-1;j++)
    {
        if(a[j]!='a')//只有数字能输出，a不输出
        if(a[j]!='0' ||jud==0)//前导0不输出，后面的0要输出
        {
            cout<<a[j];//当输出非0数后jud=0，后面的0可输出
            jud=0;
        }
    }
    if(jud)//当jud=1，值未改变时，说明没有输出，此时输出0
    cout<<0;
    return 0;
}
```
这道贪心有难度，我这个蒟蒻的代码还是有小问题，还请大佬指教。各位大佬，多提建议！本蒟蒻感激不尽。。。。。。


---

## 作者：yfct (赞：6)

[书海扬帆的博客](www.ljhedp.cn)

这道题目是一道非常经典的贪心问题。由于n的位数非常多，而且删除操作改变的是每个数位，所以我们非常自然地能想到用字符串来存储n。

接下来我们来思考贪心策略， 首先我思考的是，将字符串中最大的s个数字都删去，但是我发现我是错的。比如36251314这个字符串，要删去2位的话，就不应该删6和4，而应该删6和2。综上所述，我们可以得出本题目的贪心策略：从高位到低位搜索，如果各位数字均递增，则删去最后一个数字，否则删除第一个递减区间的首字符。举个栗子，如果1234567要删除2位的话，我们必定是删除6和7，而3654321如果要删除2位的话，我们则要选择删去6和5.

重复以上过程s次，剩下的数字串便是问题的解了。

这里再谈一下0的问题，由于前导0不能输出~~（你见过有人把123写成0123或是000123嘛）~~所以我们再来一个布尔变量flag来记录每一位是否为0.但是这个时候还出现了一个问题，就是这个字符串被删除完了，只剩下一个0怎么办？比如说样例7，10删除1位之后，我们还是必须要输出0的。因此我们再建立一个cnt变量来存储输出的数字的个数。如果个数为0，那么说明整个字符串均为0，此时我们还需要输出一个0.

话说了这么多，你应该能看懂了吧，下面分享下代码。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
char n[500];
int s,len;
bool flag;
int main(){
    scanf("%s",&n);//读入数据
    for(int i=0;i<500;i++) if(n[i]!='\0') len++;//计算字符串长度
    cin>>s;//读入数据，我们一共要删除s个字符
    for(int i=1;i<=s;i++){
        for(int j=0;j<len-1;j++)//从字符串的第一个字符开始查找，len是字符串的长度
            if(n[j]>n[j+1]){//如果找到了递减区间
                for(int k=j;k<len-1;k++) n[k]=n[k+1];
                //那么就删除字符串n的第j个字符，后面字符往前调整。
                break;
            }    
            len--;//由于已经删除了一个元素，所以长度-1
        }
        int cnt;//记录被输出字符的个数
        for(int i=0;i<len;i++){
            if(n[i]!='0') flag=true;//如果不是0，则说明可以输出，flag=1
            if(flag) cout<<n[i],cnt++;//如果可以输出那就输出，同时个数增加1
    }
    if(cnt==0) cout<<0;//如果啥都没输出，就说明整个字符串都是0，此事我们还要输出一个0
    return 0;//愉快地结束了
    }
```
谢谢大家，再次说下我的博客，[书海扬帆的博客](www.ljhedp.cn)，网址是www.ljhedp.cn, 欢迎访问！


---

## 作者：pkh449183860 (赞：5)

题目链接：[P1106 删数问题](https://www.luogu.org/problemnew/show/P1106)

此题先看看思路：   
如果是直接删掉最大的数字，很容易便可举出反例：   
1529 1   
如果直接删最大的9，结果为152，如果删掉5，结果为129，显然删掉5才是最佳答案。   
再看一组数据：   
141519 2   
如果删最大的9，5，结果为1411，如果删掉4，5，结果为1119，显然删掉4，5才是最佳答案。   
思考~~良久~~后找到了规律：找到第一个比上一个数大的数,
并删去   

------------

在这里我用的是string做的，因为string中有一个erase()函数。   
erase顾名思义就是删除。  
它可以删除从第一个数开始，删除长度为第二个数（包括自身）。  
例如erase(i,1）就是从i出发，删除1个数。

------------

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
string n;
int k; //由题意定义变量 
int i,j,l;
int main()
{
	cin>>n;
	cin>>k;
	l=n.length();//取出循环长度 
	for(i=1;i<=k;i++)
	{
		for(j=0;j<=l;j++)
		{
			while(n[0]=='0')
			{
				n.erase(0,1); //删除前导0 
			}
			if(n[j]>n[j+1])
			{
				n.erase(j,1); //如果这个是比前一个大,就删掉 
				l--;
				break;
			}
			//Q:如果把最后一个0给删了，就会错误，但并未错，为什么？
			//A:程序是先删前导0在删数，如果只剩下0了,就说明已经删完了。 
		}
	}
	for(i=0;i<=l;i++)
	{
		cout<<n[i]; //输出删后数字 
	}
	return 0;
}
```


---

## 作者：bunH2O (赞：5)

## 简单的字符串+贪心
~~我不会告诉你我WA了两次的~~
### 其实这道题是完全可以选数来做的
### n个数,删k个，不就是留下来n-k个嘛！
### 所以在能选的范围之内只需选择最小的即可
## 于是，72分代码蛋生了：
```cpp
#include<bits/stdc++.h>
#include<string>
using namespace std;
int main()
{
	string n;
	int s;
	cin>>n>>s;
	int l=n.length()-s;
	int place=-1,t=l;//place保证顺序为从左往右
	while(l>0)
	{
		int mini=11;
		for(int i=place+1;i<=s+t-l;i++)//确保不会出现位数不够的情况
		{//能选的范围为place+1至s+t-1。
				mini=n[i]-'0';
				place=i;
			}
		}
		cout<<mini;
		l--;
	}
	return 0;
}
```
## 坑点一：前导0
## 于是，84分代码蛋生了：
```cpp
#include<bits/stdc++.h>
#include<string>
using namespace std;
int main()
{
	string n;
	int s;
	cin>>n>>s;
	int l=n.length()-s;
	int place=-1,t=l;//前面的不解释了
	while(l>0)
	{
		int mini=11;
		for(int i=place+1;i<=s+t-l;i++)
		{
			if(n[i]-'0'<mini) 
			{
				mini=n[i]-'0';
				place=i;
			}
		}
		l--;
		if(mini==0)
		{
			continue;//防止前导零；
		}
		cout<<mini;
	}
	return 0;
}
```
## 坑点2：它就是0
## 满分代码它终于来了QaQ
```cpp
#include<bits/stdc++.h>
#include<string>
using namespace std;
int main()
{
	string n;
	int s;
	cin>>n>>s;
	int l=n.length()-s;
	int place=-1,t=l;
	bool k=1;
	while(l>0)
	{
		int mini=11;
		for(int i=place+1;i<=s+t-l;i++)
		{
			if(n[i]-'0'<mini) 
			{
				mini=n[i]-'0';
				place=i;
			}
		}
		l--;
		if(k&&mini==0&&l==0) 
		{
			cout<<0;
			return 0;
		}
		if(k&&(mini==0))
		{
			continue;
		}
		cout<<mini;
		k=0;
	}
	return 0;
}
```


---

## 作者：我惠美如画 (赞：5)

## 这个题乍一看就知道是贪心，然而坑点却很多 
### 1.首先要注意的一点就是要用数组存储数(相信这个点大家也都注意到了)
### 2.其次呢，就是前导0的问题（什么是前导0呢？）
#### 举个栗子，比如说有两个数。一个是0100，一个是100.
#### 我们就说第一个数含有前导0，简单地说就是数的前n位是0(n >= 1) 
#### 这道题我们可以通过单调栈贪心实现。 
#### 我们维护一个 单调增的单调栈 这样可以保证结果的正确性 
#### (因为大佬们的贪心策略都是删除递增序列的最后一位，这样的话显然可以使我们的结果正确性有保障)
#### 然而，这样还是可能会出现一些奇怪的- 问题
#### 举个例子 比如我输入的序列是12345678。经过单调栈的筛选之后，仍然是12345678，这个时候n任然是n，没有变化。
#### 这个时候我们就要考虑 12345678倒着删去n位，这样才是正确的。
# 废话不多说上代码
```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<stack>
const int N = 260;
int f(char x){return x-'0';}//字符型转换整型
char a[N];
int n,cnt,b[N];
int stack[N];
std::stack<int>q;
int main() {
    scanf("%s %d",a,&n);
    int len = strlen(a);
    for(int i = 0;i < len;i ++) {
        while(n && q.size() && q.top() > f(a[i]) && q.top() > 0) {
            q.pop();
            n--;
        }
        q.push(f(a[i]));
    }
    while(n-- && q.size()) q.pop();//12345678的情况
    while(!q.empty()){
        b[++cnt] = q.top();
        q.pop();
    }
    while(b[cnt] == 0 && cnt) cnt --;//这两句话是专门为了前导0写的
    if(cnt == 0) printf("0");
    else for(int i = cnt;i >= 1;i --) printf("%d",b[i]); //倒序输出因为栈是倒着存的（输入时造成的呀）
    return 0;
}
```


---

## 作者：封禁用户 (赞：5)

分析：

由于正整数n的有效位数最大可达240位，所以可以采用字符串类型来存储n。那么，应如何来确定该删除哪s位呢？是不是只要删掉最大的s个数字就可以了呢？

为了尽可能地逼近目标，我们选取的贪心策略为：每一步总是选择一个使剩下的数最小的数字删去，即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字，否则删除第一个递减区间的首字符。然后回到串首，按上述规则再删除下一个数字。重复以上过程s次，剩下的数字串便是问题的解了。

直接上100分AC源码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[250];
int main()
{
    int s,len,i,j,k;
    bool flag=0;
    scanf("%s%d",a,&s);
    len=strlen(a);
    for(i=1;i<=s;i++)
    {
        for(j=0;j<=len-1;j++)
        {
            if(a[j]>a[j+1])
            {
                for(k=j;k<=len-1;k++)
                a[k]=a[k+1];
                break;
            }
        }
        len--;
    }
    for(i=0;i<=len-1;i++)
    {
        if(a[i]!='0'||i==len-1)flag=1;
        if(flag)printf("%c",a[i]);
    }
    printf("\n");
    return 0;
}
```

---

## 作者：智子·起源 (赞：4)

## 这道题与其花那么大力气想贪心，还不如直接暴枚？

### 在每次删掉数字中的任意一个数的所有方案中，取最小的进行下一次删数就可以啦！

不多说，还听不懂的话看看代码吧。
```cpp
#include<iostream>
#include<string>
using namespace std;
string str,s,t;int n;
string min(string a,string b)//自定义判断最小值函数。
{
  while(a[0]=='0')a.erase(0,1);
  while(b[0]=='0')b.erase(0,1);//清除前导0。
  if(a.size()>b.size())return b;
  if(a.size()<b.size())return a;//先初步从数字位数进行判断。
  for(int i=0;i<a.size();i++)
  {
    if(a[i]>b[i])return b;
    if(a[i]<b[i])return a;//逐位比较
  }
  return a;//如果每一位都相同，就输出任意一个数字。（人家相等）
}
int main()
{
  cin>>str>>n;
  for(int i=0;i<n;i++)
  {
    s="{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{";
  //是不是觉得我这人有些问题？
    for(int j=0;j<str.size();j++)//枚举要删的数
	{
	  t="";
	  for(int k=0;k<str.size();k++)if(k!=j)t+=str[k];//如果当前数字不是要删除的数字，那就把它放进新数字里。
	  s=min(s,t);//找出删掉任意数中最小的数字。
	}
	str=s;//将str更新为当前操作中的最小数字，准备进行下一步操作。
  }
  if(str=="")cout<<0;//要判断一下，如果字符串里面什么都没有，那么就证明它所表示的数字是0。
  else cout<<str;
  return 0;
}

```

如果贪心的话……可以参考一下其他几十篇题解……
~~[汗]~~

---

## 作者：仗剑_天涯 (赞：3)

这道题蒟蒻选择了贪心，但是，怎么贪呢？

1.找规律，得出方法

这个的话，自己出几组数据。
```
1234
第一步
123 
124
134
234
经比较 123最小。
第二步
12
13
23
经比较 12最小。
第三步
1
2
经比较 1最小。
1234321——>123321——>12321——>1221——>121——>11——>1
```
发现规律是删除第一个上坡数（上坡数：比后一个数大的数）

2.证明
```
假如有一个四位数abcd,b、c为上坡数
则有：
abc
abd
acd
bcd
```
可以看到，假如删一个上坡数，它以后(包括它)的上坡数，会被比它小的数取代。

由于如果删第n个上坡数，那么前面的n-1个位置本身是可以被比它小的数取代的，所以删第一个上坡数最划算。

3.打代码

上面的思路，大致实现如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
int n;
int main()
{
	cin>>st>>n;
	while(n)
	{
		for(int i=0;i<st.size();i++)
		{
			if(st[i]>st[i+1])//判断上坡数
			{
				st=st.erase(i,1);//删上坡数
				break; //找到上坡数，中断循环
			}
		}
		n--;
	}
	for(int i=0;i<st.size();i++)
	{
		cout<<st[i];
	}
   return 0;
}
```
但是只有72分，为什么呢？

因为我忘了一步：删前导零！

加上这段：
```cpp
len=0;
while(st[len]=='0') len++;
```
但是只有84分，为什么呢？
我忘了判断数字是0的情况了。
再在输出前面加上这段：
```cpp
if(st.size()==1)
{
	cout<<st[0];
	return 0;
}
```
AC代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
int n,len;
int main()
{
	cin>>st>>n;
	while(n)
	{
		for(int i=0;i<st.size();i++)
		{
			if(st[i]>st[i+1])//判断上坡数
			{
				st=st.erase(i,1);//删上坡数
				break; //找到上坡数，中断循环
			}
		}
		n--;
	}
	if(st.size()==1)//特判数只有一位(0)
	{
		cout<<st[0];
		return 0;//结束程序，不执行下面的输出
	}
	len=0;
	while(st[len]=='0') len++;//删前导0
	for(int i=len;i<st.size();i++)
	{
		cout<<st[i];//输出
	}
	return 0；
}
```


---

## 作者：野生小卒 (赞：3)

思路：每次删掉发现的第一个比下一个数大的数字

```cpp
#include<cstring>
#include<iostream>
using namespace std;
inline void del(int i);
char N[300];
int k;
int main()
{
    cin>>N>>k;
    while(N[0]=='0')//以防万一把输入的前导0也删了
        del(0);
    for(int i=1;i<=k;i++)
    {
        for(int j=0;j<strlen(N);j++)
        {
            if(N[j]>N[j+1])
            {
                del(j);
                break;
            }
        }
    }
    //67分的人主要看这里
    while(N[0]=='0')
        del(0);
    //删掉前导0是关键点
    cout<<N<<endl;
    return 0;
}

void del(int i)//这个函数应该可以优化一下
{
    for(int j=i;j<strlen(N);j++)
        N[j]=N[j+1];
}
```

---

## 作者：Cinderella (赞：3)

本蒟蒻又来发题解啦！

这一题需要运用到$\color {blue} {\text{贪心策略}}$来做，其最主要的方法就是$\color {red} {\text{找峰值}}$，接下来是我滴思路：

1.输入字符串与要删的个数

2.找递减序列的第一个，如果找到了，
则将这个位置标记，并且将位置w赋值为j，退出循环

3.将位置w以后的数组元素全部向前移动一位

4.输出，并特判前导0

接下来献上我的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>

using namespace std;
string st;
long long s,p,w,len;
int main()
{
 cin>>st>>s;
 len=st.size();
 for(int i=1;i<=s;i++)
 {
  for(int j=0;j<=len-i+1;j++)
  { 
   if(st[j]>st[j+1]||j==len-i+1)
   {
   	w=j;
        st[j]='*';
        break;
   }
  } 
  for(int j=w+1;j<len;j++) st[j-1]=st[j],st[j]='*';
 }
 for(int i=0;i<len-s;i++)
 {
   if(st[i]!='0') p=1,cout<<st[i];
   if(st[i]=='0'&&p==1) cout<<st[i];
 }
 return 0;
}
```



------------

如果你将这个程序提交上去，那么恭喜你，成功 $\color {red} {\text{WA}}$，并得到84分的$\color {green} {\text{‘好成绩’}}$。你会看到你WA了最后一个点，这个点的数据是：10  1，如果你用这个样例测一下你的程序，你会发现——不输出东西！

所以，我们就要特判一下了，修改后的代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>

using namespace std;
string st;
long long s,p,w,len;
int main()
{
 cin>>st>>s;
 len=st.size();
 if(st[0]=='1'&&st[1]=='0'&&s==1) 
 {
   cout<<'0';
   return 0;
 }//特判
 for(int i=1;i<=s;i++)
 {
  for(int j=0;j<=len-i+1;j++)
  { 
   if(st[j]>st[j+1]||j==len-i+1)
   {
   	w=j;
    st[j]='*';
    break;
   }
  } //找递减序列的第一个
  for(int j=w+1;j<len;j++) st[j-1]=st[j],st[j]='*';//将w以后的元素全部向前移动一位
 }
 for(int i=0;i<len-s;i++)
 {
   if(st[i]!='0') p=1,cout<<st[i];//特判前导0
   if(st[i]=='0'&&p==1) cout<<st[i];
 }//输出
 return 0;
}
```

好啦，以上就是P1106 【删数问题】的题解，如有不足，请各位dalao在右边→评论区指出！

---

## 作者：XYFS (赞：2)

## ****前两天算法课提到了这个问题。。课上有灵感了，下课回去码了测试基本正确。****
### 我的思路是：枚举


------------
因为是一个大整数，我们几乎都会想到用string或者char数组存储，这也为我们下一步打下了基础：我们只关注字符串本身就好了啊！排序一个个找就完事了（滑稽

#### 代码如下：
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using std::cin;	//原谅我不想用namespace std..orz
using std::cout;
using std::endl;
using std::sort;
using std::vector;
using std::string;

int main(void) {

	string s;
	int n;
	vector<string> v;	//STL容器，动态数组

	cin >> s >> n; //读入s和n

	for(int i = 0; i < n; i++) //删除n个数字
	{
		for(int j = 0; j < static_cast<int>(s.length()); j++) //一次次遍历字符串，每次只删除一个字符
		{
			string ss = s;
			ss.erase(ss.begin()+j);	//删数字（字符）
			v.push_back(ss);  //每一次删的结果
		}
		sort(v.begin(), v.end());  //排序找当前删除一位数后的最小数字，string特性--按字典序排序
		s = v[0];	//为下一次循环做准备
		v.clear();	//清空容器（可写可不写，因为找的是最小数~）
	}

	while(s.length() > 1 && s[0] == '0')
		s.erase(s.begin());	//去掉讨厌的前导0~

	cout << s << endl;

	return 0;	//over~
}

```


---

## 作者：sycqwq (赞：2)

这一道题目我做了两遍，第一遍我**是把最大的数删了**，wa了几个点。
第二遍，我发现了一个规律，我就跟大家举一下例子：
一组数据：

50074897

2

这里要删两个数，按照我第一遍的想法肯定是不行的，删除最大数的后是500747，但结果是4897，我发现：**不要删最大的数，要删比下一个数大的数，并且越靠前越先删注意要删除前导0！**

重点代码：
```cpp
for(int kk=j;kk<l;kk++)
	a[kk]=a[kk+1];
```
这串代码是找到要删的数以后，删除的代码，把所有的数往左移一位a[i]=a[i+1].

下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int k;
	string a;
	cin>>a>>k;
	int l=a.size();
	for(int i=0;i<k;i++)//删除k个数，循环k次
	{
		for(int j=0;j<l;j++)//寻找要删除的数
		{
			if(a[j]=='0')//如果是‘0’，需要删掉，不过并不需要占删除的数
			{
				for(int kk=j;kk<l;kk++)//删除
					a[kk]=a[kk+1];
           --j;
			}
			else if(a[j]>a[j+1])//如果比前面的数大，删除
			{
				for(int kk=j;kk<l;kk++)
					a[kk]=a[kk+1];
				
				break;//这一轮删了一个数，退出进行下一轮
			}
		}
		
		
	}
	cout<<a;										 
	return 0;
}
```

---

## 作者：zhaowangji (赞：2)

貌似比前面的题解简单一些

不知道有没有参加过南通2018国庆冲刺营的朋友？

当时应该是讲过这一题的（将那一课的貌似就是我们老师）

其实跟高精没有任何关系，可以自己举几个例子

可以发现**每一次删掉的数，刚好是非下降序列的最后一个**，并且是顺序的（就是直接从前往后判断）

比如193756，先删9

然后13756，删7

然后1356，删6

......

外面是1~k的循环，里面枚举字符串的每一个数，判断是不是非下降序列的最后一个，如果是就删掉，记住要立即退出循环

输出很坑

判断前导0，并且要特判最后是一位数的情况

```cpp
#include<iostream>
#include<string>
using namespace std;
string n;
int k;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	for(int j=0;j<n.size();j++)
	if(n[j]>n[j+1]){n.erase(j,1);break;}
	//判断，前面一个数比后一个数大。
   	//记得break写在if语句后面，而非整个j循环里面 
	int m=0;
	while(n[m]=='0')m++;
	//跳过前导0
	//如果只有最后一位数，注意特判
	if(m==n.size())cout<<0;
	else
	{
		for(int i=m;i<n.size();i++)
		cout<<n[i];//从非前导0的位开始输出
	}
	
	
	cout<<endl;//好习惯
	return 0;
}

```


---

## 作者：蒟蒻365 (赞：2)

思路上大体是一样的，只不过我的写法有点神奇...

思路：从前往后删，保证到这个地方为止是单调递增的，删到次数用完或数列被删完为止

比如样例：175438 4

最开始：1

然后7进来，满足单调递增，继续。

5进来，不满足了，将7删掉，此时我们还能删3次，序列为15

4进来，将5删掉，还能删2次，序列为14

3进来，4删掉，还能删一次

8进来，此时虽然满足单调递增，但是我们还能删除一次，所以不输出它

最终答案为13

详见代码

```
#include<bits/stdc++.h>
using namespace std;
char c[251];//定义一个字符数组
int main(){
	int n,len,t;
	cin>>c;
	cin>>n;//输入删除次数
	t=len=strlen(c);//得到字符串长度，因为len的值会改变，所以再多定义一个t
	for(int i=0;i<len;i++){
		if(c[i]>c[i+1]){//如果不满足单调递增
			if(len>t-n){//如果还能够进行删除，即还没有删到n次 
				for(int j=i;j<len;j++)
					c[j]=c[j+1];//全部前移，删除当前数
				--len,i-=2;//len--表示长度减少，然后i-=2就是真正神奇的地方了
			}/*首先i原本是指向被删除的那个数的，现在它被删了，你的这一次i就不能++，这是减去的其中一个1，其次有可能原本被删数前面的那个数不会被删，但是前移后，它需要被删去了。如数据：133420 3。在下面详细解释*/
			else break;//如果没有删除的机会了，结束循环
		}
	}
	int i=0;
    while(i<=len-1&&c[i]=='0') i++;//删除前导零
    if(i==len) printf("0");//针对这种数据：100 1
	for(i;i<t-n;i++) cout<<c[i];/*输出。不管len为多长，反正我们只输出前t-n位。这样就解决了到了最后虽然是单调递增但是还有删除机会的情况*/
	return 0;	
}
```

数据：133420 3

前四位1334都满足单调递增

2进来，删除4

此时因为i减了2，所以程序能够发现又不满足单调递增了，所以删掉两个3

最终答案为120。所以是需要减2的。

---

## 作者：Checkmate (赞：2)

思路跟各位大神都是一样的，若整体为升序，删去升序的最后一个，其余删去开始降序的第一个，但我用了一个erase函数，使程序更加简明易懂；

    
```cpp
#include<iostream>
#include<string>
using namespace std;
int main(){
    int l,m=0,i,j,t,h,cut=0;//cut计数，m统计先导零。
    string s;
    cin>>s>>t;
    l=s.size();
    while(cut<t){
      for(i=0;i<l-1;i++)
        if(s[i]>s[i+1]){//发现降序。
        cut++;s.erase(i,1);break; //删去的数目加一，删去s[i]（erase（i,1）函数：从i开始删去包括i的后一个数——就是删去i）。
        }
        if(i==l-1){ //到达最后，没有发现降序。
            cut++;s.erase(i,1); //删去最后一个，数目加一。
        }
    }
    while(s[m]=='0'&&m<s.size()-1)//看有几个先导零，不能等于size-1，因为要从第m位开始输出。
    {
        m++;//发现零，开始输出的位数加一。
    }
        for(i=m;i<s.size();i++)//从m位开始输出；
        cout<<s[i];
    return 0;
}
```

---

## 作者：antiquality (赞：2)

本来看到是打算改成f里面选数的，和最长xx子序列一样。

但是后来想到实现稍微快一点的删数，因为就懒得去dp了

最初是用数组，其实用链表或者字符串操作更好，也更容易

嗨呀然后就发现会最后一个数保留下来，去题解区转了一圈才想起来要在末尾加个空，拿来比较

循环么，就是按删的次数来循环，要比length（因为会改变）好

第一次提交f[i]**>=**f[i+1]然后就炸了

好像是删掉了一些最优解……


顺便发现了一些题解存在的问题，

它们在删数的时候，因为大多是是while，所以在本地编译上当length=1时候会报错

于此反馈给题解管理员


Pascal源码

```pascal
 var
  f:ANSIstring;
  k:longint;
  i,j,n,s:longint;
 procedure ouf;
  begin
   delete(f,length(f),1);
   while (f[1]='0')and(length(f)<>1) do
    delete(f,1,1);
   if f='' then f:='0';
   writeln(f);
   halt;
  end;
 begin
  n:=0;s:=0;i:=0;
  readln(f);
  readln(k);
  f:=f+' ';
  repeat
   inc(s);
   for i:=1 to length(f)-1 do
    if f[i]>f[i+1] then
     begin
      delete(f,i,1);
      break;
     end;
  until s=k;
  ouf;
 end.

```

---

## 作者：Conical (赞：2)


典型的贪心，看数据范围，可以暴力。复杂度O(l\*l\*k)

然而加上链表，复杂度O(l\*k)

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a[260];
int next[260],be[260];
int main()
{
    int l,k,i,top=0;//top指向表头 
    scanf("%s",a);
    scanf("%d",&k);
    l=strlen(a);
    if(k==0)
    {
        for(i=0;i<l;i++)
        printf("%c",a[i]);
        return 0;
    }
    next[0]=1;
    be[0]=0;
    for(i=1;i<l;i++)
    {
        be[i]=i-1;
        next[i]=i+1;
```
}//建链表
```cpp
    while(k--)//分k次处理 
        for(i=top;i<l;i=next[i])
            if(a[i]>a[next[i]])
            {
                be[next[i]]=be[i];
                next[be[i]]=next[i];
                if(i==top)
                    top=next[i];
                break;
            }
    i=top;
    while(a[i]=='0'&&i<l-1)
        i=next[i];//去除前导零 
    for(;i<l;i=next[i])
        printf("%c",a[i]);
    return 0;
}
```
/\*
a0,a1,a2,a3...

当ai之前的数均小于ai且ai+1小于ai时，

保证删掉ai可以得到最优解

\*/

---

## 作者：ceba_robot (赞：2)

呃，好像我是第一个用cpp的。

好，这是一道贪心，贪心思路是删除第一个递减数列的第一个（或者是第一个递增数列的最后一个）。

为什么呢？

首先，我们可以看出，第一个递减数列的第一个就是第一个递增数列的最后一个，而且这个数是这两个数列中最大的一个，这样无论删去这一个局部的哪一个数，都不可能比删去这个数小，**第一步贪心保留最优解**。同时，我们知道，高位对数的大小的影响比低位要大，所以**全局的最优解包含局部的最优解**。根据这两个结论，这个贪心方法是正确的。

贪心思路不难，但是实现起来并不容易，由于害怕数组的大规模移动，我最终选择用数组模拟链表来完成贪心过程。但是似乎数据不是太强，我一个同学完全用暴力就ac了。

下面是代码：

[codec ]




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char arr[260];
int next[260],last[260];
int k,len;
int ans=0;
int main()
{
    scanf("%s %d",arr+1,&k);
    len=strlen(arr+1)+1;
    for(int i=0;i<=len;i++)
        last[i]=i-1,next[i]=i+1;
    int i=next[0];
    while(ans!=k && i!=len)
    {
        if(arr[i]>arr[next[i]])
        {
            next[last[i]]=next[i];
            last[next[i]]=last[i];
            i=next[0];
            ans++;
        }
        else
            i=next[i];
    }
    bool flag=true,flag1=false;
    i=next[0];
    while(i!=len)
    {
        if(flag && arr[i]=='0')
            i=next[i];
        else
        {
            printf("%c",arr[i]);
            flag1=true;
            flag=false;
            i=next[i];
        }
    }
    if(!flag1)
        printf("0");
    printf("\n");
    return 0;
}
[/cpdec ]
```

---

## 作者：PTC06 (赞：2)

此题最能体现出贪心思想：以局部最优推导出整体最优。

比如说如果输入175438和1，就应该删局部最优的7，变成15438，而不是删整体最优的8，就会变成17543。

还有就是要删除前导0，因为比如输入100和1，就应该删1，变成00，也就是0，如果直接把字符串转成数值来删除前导0是不行的，应为删完后的有可能是高精度数，用dword或int64等均装不下

```cpp
var s,s1:string;
    i,l,k,p,o,q:longint;
procedure shan(s1:string);       //这里定义一个过程来删数
begin
  s:=s1;                                     //输入的s1赋值给s
  while (s[p+1]>=s[p]) and (p<>length(s)) do inc(p);      //这里十分重要，体现出贪心的中心思想，把这一位和下一位比较
  delete(s,p,1);        //然后删除
  while s[1]='0' do delete(s,1,1);      //这里删除前导0
end;
begin
  readln(s);      //输入高精度数
  readln(k);      //输入删除的位数
  for i:=1 to k do      //循环k次，也就是循环到需要删的次数
    begin
      p:=1;        //刚开始比较时要变成第一位
      shan(s);    //删除
    end; 
  if s='' then writeln('0') else writeln(s);    //如果全删光了要输出0
end.
```

---

## 作者：king_xbz (赞：2)

这道黄色水题做了我好久，每次都wa部分点，下了两次数据才ac
其实题目本身难度并不大，只是需要注意特判升序和删除前导零
code：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int n;
int flag,endll;
signed main()
{
	getline(cin,a);
 int len=a.size();
	cin>>n;
 //输入字符串	
	for(int i=0;i<len-1;i++)
    if(a[i]>a[i+1])
    {
    flag=1;
    break;
}
if(flag==0)
{
for(int i=0;i<len-n;i++)
cout<<a[i];
return 0;
}
//特判：如果是升序，就输出前len-n个 
if(n==len-1)
	{
	for(int i=0;i<=len;i++)
	if(a[i]=='0')
	{
	cout<<"0";
	return 0;
}
	}
	//特判：如果删去的数=len-1且在len中有数为0，就输出0（否则在后面会当作前导0给判掉） 
	flag=0;//记得把flag归零，后面还要用 
	int t=0;
	for(int j=1;j<=n;j++)
	{//总共删n个数 
		for(int i=0;i<len-1;i++)
		{
			if(a[i+1]<a[i])
			{
			//cout<<a[i+1]<<" ";
			a.erase(i,1);
			t++;
			break;
			}
			//贪心法求解：如果这个大于后一个就把这个删掉，同时t++ 
		}
	}
	for(int i=0;i<len-t;i++)//只输出前t位
	{
		if(a[i]!='0')
		flag=1;
		if(a[i]=='0'&&flag==0)
		continue;//跳过前导零 
		cout<<a[i];
	}
	return 0;//ac撒花 
}
```cpp
祝大家ac

---

## 作者：Flows_yu (赞：2)

## STL 傻逼题解来一发，逃~~~

闲来无事找个水题压压惊，我记得这个题是很多教材上都会有的例题
贪心思想是每找到一个数如果比它的后一个数大，则将这个数删除，循环k次即可（若找不到则删除当前序列最后一个数）纯属暴力解题，但看看这数据范围，who care ~

PS：注意前导零问题（因为这个wa了两发。。。）
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(int argc, char const *argv[]) {
    string s;
    int k;
    cin >> s >> k;
    for (int i = 0; i < k; ++i) {
        bool flag = 0;
        for (int j = 0; j < s.length() - 1; ++j) {
            if (s[j] > s[j + 1]) {
                s.erase(j, 1);
                flag = 1;
                break;
            }
        }
        if (!flag) s.erase(s.length() - 1);
    }
    while (s[0] == '0') s.erase(0, 1);
    if (s.length())
        cout << s << endl;
    else
        cout << "0" << endl;
    return 0;
}

```


---

## 作者：Lydia_Moon (赞：2)

萌新放弃一次，总提交8次悟出来的贪心题解，大佬轻喷……

考完某次考试，删数题目满分，突然想起洛谷有这么一道题，喜滋滋地来刷双倍经验，结果提交四次才过……



------------


话不多说，先从样例分析：
175438，删4个数，得13

### **1.一个数要最小，高位得尽量小对吧，那么如果某位数比后一位数大，果断删去！维护一个最长不下降子序列（且字典序最小），可以保证前面的数尽量小。**

所以，分析175438：

1比7小，过。

7比5大，删7，得15438，k=3。

5比4大，删5，得1438，k=2。

4比3大，删4，得138，k=1。

3比8小，过。

8后没数了，过。

此时175438 -> 138，k -> 1。

是个最长不下降子序列，但不是我们要的。


------------


于是……

### **2.当删完数后，若k!=0，则只输出前(n-k)个数，删去后k个数**

所以，分析138：

n=3，k=1。

n-k=2。

输出13，拦截下8。

这样程序就可以过样例了，但……

提交，72分，WA两个点。

萌新WA的一声哭了出来！

现在肿么办啊QAQ……

表急，擦擦眼泪，看看测试信息

…………

…………

…………



----------------


输出的数最高位是0啊啊啊！！！

### **2.5那我保留0前面的1个数？**

改一改，72 -> 50

emmmm…………………………

重新看看测试点内容（之前没找到在哪下载测试点）……

500074897 2 -> 4897

…………

坑爹呢这是！

不是删2个数吗？

怎么删了5个？！

冷静了一下，我发现……

500074897 （删2个数5，7） -> 0004897 （忽略前导0） -> 4897！

--------------------

So……

### **3.在输出时，如果还未输出一个大于0的数而当前需输出0,则跳过0。（忽略前导0）**

再改，50 -> 84

依然不是满分……~~元芳，你怎么看？~~

最后一个测试点说我的输出太短？

下载测试点，仔细一看，10 1 -> 0。

------------

因为跳过前导0,所以我根本没有输出任何东西！

那么……

### **4.当发现什么都没有输出而程序即将return 0时，最后的抢救——输出0！**

提交，满分！

贪心思路的推导——完结撒花～

附上AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[510000],n,k;
void input(),work(),output();
int main()
{
	input();
	work();
	output();
	return 0;
}
void input()
{
	char c[510000];
	scanf("%s",c);
    scanf("%d",&k);
    n=strlen(c);
	for(register int i=0;i<n;++i)
		a[i+1]=c[i]-'0';
}
萌新的贪心开始辣！QAQ
void work()
{
	for(register int i=1;i<n;++i)
	{
		if(k==0) break;
		if(a[i+1]<a[i])
		{
			for(register int j=i;j>=1;--j)
			{
				if(k==0) break;
				if(a[j]==-1) continue;
				if(a[j]>a[i+1])
					a[j]=-1,k-=1;
				else
				
					break;
			}
		}
	}
	for(register int i=n;i>=1;--i)
		if(a[i]!=-1) 
			if(k==0)
				break;
			else
				a[i]=-1,k-=1;
}
萌新的贪心完成辣！QVQ
void output()
{
    int f=1,p=1;
	for(register int i=1;i<=n;++i)
    {
        if(a[i]==0&&f==1) continue;
        if(a[i]!=0&&a[i]!=-1) f=0;
        if(a[i]!=-1)
			printf("%d",a[i]),p=0;
    }
    if(p==1) printf("0");
	printf("\n");
}
```


---

## 作者：liuzitong (赞：2)

# 4.24一个重要的日子.
我人生中第一道7个测试点下载了5个的题目被我发现了,第一次用光下载数据点机会,真心坑点重重.

这题是一道很经典的贪心题目,可能是因为我太蒻了,导致我一直以为最少普及难度.

我用了几乎从未用过的"指针"(加这->  ""  <-个的原因是这个“指针”是模拟指针)；

### 这个题的贪心策略应该都明白：找第一个开始下降的那个数删，如果一直上升删最后一个。原理就不解释了；

### 这个题每个字符设一个指针，指向他的下一个（不是下一个字符而是下一个非空字符），这样形成了一个伪链表；

不说了，上带注释(注释很全)代码(有一点点瑕疵)
```cpp
#include<bits/stdc++.h>
using namespace std;
struct po {//结构体(别问我po什么意思)
    char sh;//字符(该序号)
    int z;//指针(后继)
};
po a[1001];
int u;//记录字符串长度
int main() {
    int s;
    while(1) {
        ++u;
        a[u-1].z=u;//初始化后继
        a[u].sh  = getchar();//读入
        if(a[u].sh  == '0') {//这里也可以不处理
            a[u].sh  = '!';
        }

        if(a[u].sh  == '\n')//换行的时候结束
            break;
    }
    u--;//减去'\n'的长度
    scanf("%d",&s);//输入要减去的个数
    if(a[1].sh =='1'&&a[2].sh =='!'&&s==1){//最后一个数据点我自己本地测过了,但提交就WA
        cout<<0;//于是就打表了....大家可以屏蔽这几行把下面某几行的注释去掉,本地可以过
        return 0;
    }
    int uu=0;//记录是否一直上升趋势
    for(int i=1; i<=s; i++) {//循环s次
        for(int j=1; j<u;) {//循环u-i个,至于为什这样写留给大家思考
            if(a[j].sh  > a[a[j].z].sh  &&a[j].sh!='-'&&a[a[j].z].sh!='-') {//标记过的不要管,如果某突然个下降了
                a[j].sh  = '-';//标记
                int pp=j-1;
                while(a[pp].sh  == '-')//拆开链表,重新接上
                    pp--;
                a[pp].z = a[j].z ;
                uu++;//标记
                break;//每次只能去掉一个
            }
            j = a[j].z ;//找下一个非空字符
        }
        if(uu==0) {//若一直上升,去掉最后一个
            a[u].sh  = '-';
        }
        uu=0;
//        for(int k=1; k<=u; k++) {//如果不理解过程可以"解封"这些然后体会一下
//            cout<<k<<"->"<<a[k].z <<"   ";
//        }
//        for(int k=1; k<=u; k++) {
//            cout<<a[k].sh ;
//        }
//        cout<<endl;
    }
    int oo=0;//输出每个非空字符
    int uuu=0;//去除前导0
    for(int i=1; i<=u-s; i++) {//循环u-s次
        oo = a[oo].z ;//每次找他的后继
        if(uuu!=0||a[oo].sh !='!'){//之前写过'!'代表0
            uuu++;
            if(a[oo].sh !='!')
                cout<<a[oo].sh ;
            else //如果是'!'就输出0
                cout<<0;
        }
    }
//    if(uuu==0)//如果什么也没输出
//        cout<<"0";//补0
    return 0;
}
```


---

## 作者：kittener (赞：2)

这道题虽然是道典型贪心但是我选择用深搜做，限制好次数然后每次查找最小的数，同时限制每次查找范围，就可以Ａ掉了###

代码如下：


                
                 
                
```cpp
#include<iostream>
#include<cstring>
#define MAX 241
using namespace std;
string s;        
int i,j,n;        
int a[MAX],c[MAX];
char b[MAX];    
int times=0;
int t;
int f;        
void sou(int x){
    int tmp=MAX;
    if (times==s.size()-n)return;    
    for (i=x;i<=s.size()-f;i++){
        if (a[i]<tmp){
        tmp=a[i]; 
        t=i; 
        }         
        if(a[i]>=tmp)continue; 
    }
    t++;         
    c[times]=tmp;
    times++;      
    f--;         
    sou(t);        
}                 
int main(){     
    cin>>s;        
    cin>>n;
    int y=0;
    f=s.size()-n;        
    for (i=0;i<s.size();i++){
        b[i]=s[i];
    }            
    for (i=0;i<s.size();i++){ 
        a[i]=b[i]-48; 
    }             
    sou(0);        
    for (i=0;i<times-1;i++){
        if (c[i]==0){
            y++;
            continue;
        }
        if (c[i]!=0)break;
```
}//删前导0；
    for (i=y;i<times;i++)cout<<c[i];

    return 0;        

}

---

## 作者：Vocalise (赞：1)

这题无脑string可做（但是也用了一点贪心的思想）。

虽然大家天天都在喷$string$慢的要死，但是对于这题是绰绰有余的，**而且没有比其他同学的更慢！**

我的思路是：每一次找出使剩下数更小的位置删除。

这可以看出是对的，因为：长度相同的数，如果本身就更小，那么通过最优的操作可以使得删除的结果也更小（至少不会更大）。

```cpp
std::string(int n,char ch)//把string类赋值为n个字符
std::string(int i,int len)//把string类i起始的len个字符删去，后面自动补齐
str::string.operator<(...)//按照字典序比大小，此题中和比数字并无区别
```

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>

std::string n;
int k;

std::string tmp,t;
int main(){
	std::cin>>n>>k;
	for(int i=1,l=n.size();i<=k;i++,l--){
		tmp=std::string(250,'9');
		int j=0;
		for(register int i=0;i<l;i++){
			t=n;t.erase(i,1);
			if(t<tmp){
				tmp=t;
				j=i;
			}
		}
		n.erase(j,1);
	}
	std::cout<<n<<std::endl;
	return 0;
}
```
但是这样是会WA两个点的，碰到高精就要想到：

## 是不是有前导零？

没错，于是在输出一处前加上了：
```cpp
while(n[0]=='0')n.erase(0,1);
```
但是仍然WA一个点...你应该想到，

> 做人不能做太绝。。。

要是删完就0了，你一while不就

$$\texttt{too short on line one column one}$$

了吗？

---

## 作者：Posser (赞：1)

ac后去看题解才发现是**贪心**，但我却想到了记忆化。本来是想回溯法暴搜的，但是有一个数据不给过，果断来一发记忆搜索，**ac**!!!不得不说，记忆化大法就是好用。

------------

思路如下:

------------

1.求出要留下的数的个数

------------

2.深搜每一个结果并记录在数组当中

------------

3.去除前导0

------------
不多说，上我**别具一格**的代码，哈哈哈哈哈哈
```cpp
#include <iostream>
#include <string>

using namespace std;
const int _size = 255;
bool vis[_size];
string dp[_size][_size][2];
string s;
int n, len;

bool compare(const string& a, const string& b) //自定义比较函数, 相当于 a < b ? true : false
{
	if (a.length() != b.length())
		return a.length() < b.length();
	return a < b;
}

string dfs(int ind, int cnt, int state)
{
	if (dp[ind][cnt][state] != "")
		return dp[ind][cnt][state];  //记忆化
	if (ind >= len)  // 出口
	{
		if (cnt == n) return  "";
		else return s;
	}
	string ans1, ans2;
	ans1 = ans1 + s[ind] + dfs(ind + 1, cnt + 1, true); // 选择这个数
	ans2 = ans2 + dfs(ind + 1, cnt, false); // 不选这个数
	return dp[ind][cnt][state] = compare(ans1, ans2) ? ans1: ans2;
}

int main()
{
	cin >> s >> n;
	len = s.size();
	n = len - n;  // 求出要保留的数的个数
	string ans = dfs(0, 0, false);
	while (ans.at(0) == '0' && ans.size() > 1) //除前导0
		ans.erase(ans.begin());
	cout << ans << endl;
	return 0;
}
```


---

## 作者：一滴小水滴 (赞：1)

### 经过四次删数后的确能够得到最终答案13。但是我来给出另一个例子：将1314这个数删一次，如果直接删除最大的数得到的数是131，但是114却比它更小。

### 所以，删除最大的数并不是最终解决问题的办法。众所周知，一个数的位数是很重要的，假设a等于100，而b等于1000，b的位数大于a，所以b就一定大于a。
### 再假设，a等于123，b等于124，他们的位数相同，那我们就从它们的最高位比起，一直比到最低位，得出b大于a。
### 那对于这道题，我们也可以从最高位一直到最低位不断地循环k次删数，如果当前数大于后一个数，说明这是较高位的最大数，就将它删除，否则继续往下循环。当只有已经搜索到倒数第二个数的时候，说明前面的数都比最后一个数小，我们就直接删除最后的数了。具体操作如下：
```cpp
for(int i=1;i<=s;i++)       //s表示删数的个数，从1开始删s次
		for(int j=0;j<n.size()-1;j++)   //从第一个数
                                         一直到倒数第二个数循环删数
		{
			if(n[j]>n[j+1])
			{
				n.erase(j,1);
				break;
			}                  //如果有下降的序列，
                                          就删除当前数，并跳出循环
			else if(j==n.size()-2)
			{
				n.erase(j+1);          
				break; 
			}    //如果一直搜到倒数第二个数还没有结束，
                                   说明前几个数一直在上升，
                                     那么最后一个数一定是最大的，
                                              直接删除最后一个数。
		}
```



------------
### 这一道题，还有一个很重要的地方，那就是去除前导零。我们可以从第一个数一直往后搜，如果是零，就继续循环，否则跳出循环。结束后再从删除零后的位置将数输出，还要判断一下，搜零的位置结束后是不是等于数的长度，如果是，就直接输出一个零。代码如下：
```cpp
int i=0;
	while(i<n.size()&&n[i]=='0')
		i++;          //如果不是零就一直往下循环。
	if(i==n.size())cout<<0<<endl;   //如果结束位置和数的
                                     长度相等，就直接输出一个零。
	else for(int j=i;j<n.size();j++)
			cout<<n[j];     //输出每一个数字。
```


------------
### 这道题的重点就是这些，接下来给大家看一看AC代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int s;
	string n;
	cin>>n>>s;      //输入高精度数和要删的个数。
	for(int i=1;i<=s;i++)
		for(int j=0;j<n.size()-1;j++)
		{
			if(n[j]>n[j+1])
			{
				n.erase(j,1);
				break;
			}
			else if(j==n.size()-2)
			{
				n.erase(j+1);
				break; 
			}
		}       //循环删数。
	int i=0;
	while(i<n.size()&&n[i]=='0')
		i++;
	if(i==n.size())cout<<0<<endl;     //去除前导零。
	else for(int j=i;j<n.size();j++)
			cout<<n[j];       //输出结果。
	return 0;
}
```


------------
## 这篇题解就是这样，祝大家天天AC！


---

## 作者：HeartBlock_Love (赞：1)

【算法分析】

由于正整数n的有效数位为240位，所以很自然地采用字符串类型存贮n。那么如何决定哪s位被删除呢？是不是最大的s个数字呢？显然不是，大家很容易举出一些反例。为了尽可能逼近目标，我们选取的贪心策略为：每一步总是选择一个使剩下的数最小的数字删去，即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字；否则删除第一个递减区间的首字符，这样删一位便形成了一个新数字串。然后回到串首，按上述规则再删下一个数字。重复以上过程s次为止，剩下的数字串便是问题的解了。


例如：n=175438

           s=4
           
          删数的过程如下：
          
               n=175438   //删掉7
               
                   15438  //删掉5
                   
                   1438   //删掉4
                   
                   138    //删掉8
                   
                   13     //解为13
                   
这样，删数问题就与如何寻找递减区间首字符这样一个简单的问题对应起来。不过还要注意一个细节性的问题，就是可能会出现字符串串首有若干0的情况，甚至整个字符串都是0的情况。按以上贪心策略编制的程序框架如下

```
输入n，s；
   for (i=1;i<=s;++i) {                  //一共要删除s个字符   
     for ( j=0;j<len-1;++j )            //从串首开始找，len是n的长度
      if ( n[j]>n[j+1] ) {                  //找到第一个符合条件的  
        for ( k=j;k<len-1;++k )       //删除字符串n的第j个字符 ，后面字符往前整 
          n[k]=n[k+1];
       break;
      }
     --len;                                    //长度减1 
    }
   输出n；                                 //删去串首可能产生的无用零
```


---

## 作者：flyfree (赞：1)

我~~震惊地~~发现整整六页题解竟然没人用指针？

思路其实和几位dalao差不多，就是从最高位向低位找，找到第一个后一位比自己小的数就删掉它，然后重新回到最高位，再次向后找，直至删完。

如果出现了整个数列单调递增，但数还没删完的情况，就从最低位开始向前删，直至删完。

很显然，删掉一个数后，这个数的位置会被它的后一位代替。（因为删掉的位数是一定的，也就是最终位数是一定的，所以每删掉一位缩小的十分之一可以忽略不计，看做是后一位补上了删掉的位更好理解）

注意，后文都是在忽略减少位数的情况下论述的。

这样的话，如果一个数的后一位比它小，那么删掉这个数后整个数一定会变小。

那么，为什么一定要从最高位开始找呢？

容易理解的是，如果要选择：1、把一个较高位减小 2、把一个较低位减小  显然是要选择把较高位减小的，无论减小多少，高位减小所带来的变化一定大于低位减小带来的变化。因此，要优先减小高位，也就是要从高位开始找。

补一发~~

```cpp
#include <cstdio>
using namespace std;
int k,cnt,n;
bool flag;
char x;
struct node
{
    node *last,*next;//记录每一个数的上一位和下一位
    short vi;//本位数值
};
int main()
{
    node *head,*tail,*p;//head指向整列数的开头，tail是结尾
    n=1;//记录共有几位数，由于第一位是在循环外读入的，所以初始化为1
    x=getchar();
    head=new(node);
    head->vi=x-'0';
    head->last=NULL;
    tail=head;
    for(;;)//读入整列数并用链表连接
    {
        x=getchar();
        if(x<'0'||x>'9')
        break;
        p=new(node);
        p->vi=x-'0';
        tail->next=p;
        p->last=tail;
        tail=p;//更新尾指针
        n++;
    }
    tail->next=NULL;
    scanf("%d",&k);
    if(k==n)//特判，否则最后可能会没有输出
    {
        printf("0");
        return 0;
    }
    for(int i=1;i<=k;i++)
    {
        p=head;//每次从头开始找
        for(;;)
        {
            if(p==tail)//如果找到末尾，说明整个序列严格递增，剩余的位数要从末尾删，在此处做个标记
            {
                flag=true;
                break;
            }
            if((p->vi)>(p->next->vi))//贪心删数
            {
                if(p!=head)//一定要特判删的是不是第一个数（毕竟我也是在这卡过一回的），因为head->last是NULL
                p->last->next=p->next;
                p->next->last=p->last;
                if(p==head)//防止head指针成为野指针
                head=p->next;
                delete(p);//释放空间
                break;
            }
            else
            p=p->next;//没找到就继续找
        }
        if(flag)
        break;
    }
    p=head;
    for(;;)//删掉前面的0
    {
        if(p==tail)//如果最后一位前面全是0，无论最后一位是不是0，都直接输出就好了
        {
            printf("%d",p->vi);
            return 0;
        }
        if(p->vi!=0)
        break;
        p=p->next;
    }
    for(cnt=n-k;cnt>=1;cnt--)//控制数字个数，防止刚才标记了flag然后break的情况输出末尾本应删除的剩余位数
    {
        printf("%d",p->vi);
        if(p==tail)//删除前面的0之后位数可能会减少
        break;
        p=p->next;
    }
    return 0;
}
```

~~说实话指针是真心麻烦，一言不合就RE~~

---

## 作者：Qiao712 (赞：1)

## 运用c++ string让代码更简洁
### 不用将字符串转化为数字数字
#### 本题使用贪心思想
一个让这串数字越小，它的高位数就得越小。我们每次删除要使得删除后的数高位尽量的小。  
每一次删除时，从**最高位**开始向低位数遍历，当遇到的一位数比它的更高位更小时，我们就删除它的更高一位，让这个更小的数“篡位”，就可以保证这串数更小。下一次删除时，要也从新从**最高位开始**。

#### 需要注意的地方
1. 删除了最高位之后，需要删去后面的‘0’
2. 输出的时候要注意有没有全删删没，全删没后要输出0。

```
/*使用c++ 的 string*/
#include<iostream>
#include<string>

using namespace std;

int main() {
	string a;
    a.reserve(251);//预先开辟空间
	cin>>a;
	int k;
	cin>>k;
	
	for(int i = 1; i<a.length() && k!=0; i++){
		if(a[i-1] > a[i]){
			a.erase(i-1,1);
			k--;//次数减一
			
			//消除0 
			if(i-1 == 0){
				int j;
				for(j = 0; j<a.length() && a[j] == '0'; j++);
				a.erase(0,j);
			}
			
			i = 0;//想让下一次循环i=1，可惜忘了每次循环还要加1，写成了 i=1；o(╥﹏╥)o 
		}
	}
	
	//k没用完？说明所以数都升序。这时只需去除末尾的k位 
	for(; k>0; k--){
		a.pop_back();
	}
	
	if(a.empty()){//为空时
		cout<<0;
	}else{
		cout<<a;
	}
	
}
```
时空复杂度会略高

---

## 作者：赤瞳之鸦 (赞：1)

#思路:

题目很简单，说实话就是找降序的第一个

嗯，是道模拟题(笑)

题目卡了好几次，

第一次卡是因为第二个点的零的问题

很尴尬，只好再令一个循环把前面的零全部消掉

第二次是长度问题

因为这样(见下)的清零方式只是删去了0

但是长度还是没有变，所以后面留了好多空格

尴尬的不符合了题目要求= =

所以重新定义一下长度就好了

```cpp
#include<iostream>
#include<cstring>    //字符串必备神器 
using namespace std;
string number;
int k,lenth,times,place;

int main()
{
    cin>>number;
    cin>>k;
    lenth=number.size();
    if(k==0)        //特判，虽然题目没有但是天真的我还是打上了 
    {
        cout<<number;
        return 0;    
    }
    while(times<k)    //重点~ 
    {
        int i;
        for(i=0;i<lenth;i++)    //擦掉降序的第一个 
        {
            if(number[i]>number[i+1])
            {    
                times++;
                number.erase(i,1);    //erase函数~偷懒不自己写 
                break;
            }
            if(i==lenth-1)        //还是特殊情况，当前面都是升序到了最后一个，只能擦最后一个 
            {
                times++;
                number.erase(i,1);    
            }
        }    
    }
    
    lenth=number.size();    //没错这个点卡了我好久= =后来看题解才明白自己咋回事= = 
    while(number[place]=='0'&&place<lenth-1)
        place++;            //删掉前面的零(其实没有删掉只是从零的最后一项开始输出而已，place是个简单的标记) 
    for(int i=place;i<lenth;i++)    //耿直的输出 
        cout<<number[i];

    return 0;        
}
```
#科普几个小姿势:

判断字符串长度(不是判断字节大小= =)函数名.size()~

判断字节大小用sizeof(函数名)~

字符串数组默认是从零开始填的，小伙伴们要注意哟~

erase函数式删除字符串中第几个后的第几个~类似于链表~但是时间复杂度是O(n)

如果不清零一开始定义的数组的话删除了多少个就会空下多少个~

```cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string number;
    cin>>number;    //以输入12456为例 
    int lenth=number.size();
    for(int i=0;i<lenth;i++)
    {
        cout<<i<<"<<"<<number[i]<<" "; //结果是0<<1 1<<2 2<<3 3<<4 4<<5 5<<6
    }  
    number.erase(2,1);    //删除第二项后的第一个(相当于删除了第三个)
                        //注意第二个数字代表的是删除的个数~ 
    for(int i=0;i<lenth;i++)
    {
        cout<<i<<"<<"<<number[i]<<" ";    //结果是0<<1 1<<2 2<<3 3<<4 4<<5 5<<6 
    } 
    return 0;
}
```

---

## 作者：winmt (赞：1)

这题首先要说的是：大坑！！！得67分的基本都是因为没有注意最后去除前导零，比如：输入5000 1，是将5删除，所以答案按道理是000，但是这不是个数，所以要将前面的0去掉，正确答案应该就输出：0。我也想了好久才找出错误。如果你得67分且是上述情况，我建议自己自行修改下！不要往下看题解，实在不会的话再看吧。

思路：这是贪心的经典水题啊～但是我和你们的不太一样，你们是删除数字，而我是找数字，具体是：每次找当前没用过且与之前使用的数字不矛盾的最小的数字作为当前的高位。毕竟你想一想，高位的数大，即使低位的数字小，整体也大啊，这就是本题贪心的关键点。我用的是priority\_queue小根堆，你用set也可以，手写当然更好。

【cpp code】



```cpp
//头文件太多，看着恶心于是就删了2333
string s,ans;
int k,len;
bool vis[255];
int delete0(string x)
{
    int p=0;
    for(int i=0;i<x.size();i++)
    {
        if(x[i]=='0' && i<x.size()-1)p++; else break;
    }
    return p;
}
int main()
{
    cin>>s>>k;
    ans="";
    len=s.size()-k;
    priority_queue<pair<char,int>,vector<pair<char,int> >,greater<pair<char,int> > >q;
    queue<pair<char,int> >qq;
    for(int i=0;i<s.size();i++)q.push(make_pair(s[i],i));
    for(int j=1;j<=len;j++)
    {
        while(q.top().second+len-j>=s.size() || vis[q.top().second]==1)
        {
            if(vis[q.top().second]==0)qq.push(q.top());
            q.pop();
        }
        ans+=q.top().first;
        for(int i=0;i<=q.top().second;i++)vis[i]=1;
        q.pop();
        while(!qq.empty())
        {
            q.push(qq.front());
            qq.pop();
        }
    }
    int kkk=delete0(ans); //别忘了，删除前导0
    for(int i=kkk;i<ans.size();i++)cout<<ans[i];
    return 0;
}
```

---

## 作者：蒋钦杰jqj (赞：1)

删除数字之后的效果就是后面数字提前

升序的序列肯定选择最后一位

降序的序列肯定选第一位

有升有降选第一个出现降序的第一位

```cpp
var s:ansistring;
t,n,i:longint;
begin
readln(s);
readln(n);
t:=0;
s:=s+' ';
while t<>n do
  begin
  inc(t);
  for i:=1 to length(s)-1 do
  if ord(s[i])>ord(s[i+1]) then//寻找第一个降序的数字
    begin
    delete(s,i,1);
    break;
    end;
  end;
delete(s,length(s),1);
while s[1]='0' do
delete(s,1,1);
writeln(s);
end.
```

---

## 作者：野菜汤 (赞：1)

题解：

此题也算是较难了，那么解题的办法也是有很多，这里呢提供比较快的，也是最为精简的最优解标程。仅供参考。

```delphi
var 
  i,j,n:longint;
  s:string;
begin
  readln(s);
  readln(n);
  for i:= 1 to n do{要删多少个数便循环多少次}
   begin 
     j:=1;
     while (s[j+1]>=s[j]) and (j<length(s)) do{记住是‘>=’，而不是‘>’}
       inc(j);{巧妙地搜索运用，找到最大数然后删之} 
     delete(s,j,1);
     while s[1]='0' do {除‘0’}
     delete(s,j,1);
  end;
  if s='' then write('0') {如果删光了，那么也要输出‘0’}
           else write(s);
end.
```
本题的思路还是贪心吧，每一次只要找到s[i]>s[i+1]且s[i+1]<=s[i+1]时，就直接把s[i]删之，就能轻松解决。而最后还要去‘0’，以免被阴。

其实这道题的解法不止一个，但以上题解必定是最优解，请同学们好好思考理解，参透其中真谛，这一类的题有很多，但只要能理解以上题解，必能触类旁通。


---

## 作者：huaxia78dragon (赞：1)

先从删数个数入手\
每轮找出要删的数\
思路大体如此\
删的方法：\
1.找到山峰： 如：1 3 2中山峰是3\
他比周围两个数都大\
特殊情况 ：987654321 及 123456789\
降序中9无法与右边比较会报错不过如果用数组储存，可以把a[0]设为2e9即无穷大\
但我更倾向与在两两比较中前数小则继续，前数大则删除前数（可以用string）\
升序中同样可以设a[n+1]为-1\
但string中就需要特判即当str[str.length() -1] 仍然小于等于前一个时，删除它\
意为了让数字小的权最大\
注：在过程中所有数都会比较一次\
2.删除：\
string str;
str = str.substr(0,i-1) + str.substr(i + 1,len - i)\
所以只用O(k * len)的时间复杂度与十八行的代码就complete了（都靠string)思路与“我是sb”作者发的无二致
```
#include<bits/stdc++.h>
using namespace std;
string str;
int main(){
	int k;
	cin >> str;
	scanf("%d", &k);
	for(int i = 0; i < k;i ++)
		for(int j = 0; j < str.length(); j ++)
			 if(str[j] > str[j + 1] || j == str.length() - 1 && str[j] <= str[j + 1]){
			 	 str = str.substr(0, j) + str.substr(j + 1,str.length() - j);
				 break;
			 }
	bool flag = 0;
	for(int i = 0; i < str.length(); ++ i) if(str[i] != 48 || flag) cout << str[i],flag = 1;//去前导零并输出
	if(!flag) printf("0");//无输出特判，就输出零
	return 0;
}

```


---


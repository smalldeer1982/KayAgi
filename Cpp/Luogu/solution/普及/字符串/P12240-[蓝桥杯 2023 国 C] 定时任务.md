# [蓝桥杯 2023 国 C] 定时任务

## 题目描述

Cron 表达式在定时任务中经常被使用，在这里我们用了一种简化后的版本 SimpleCron 表达式：SimpleCron 表达式是一个具有时间含义的字符串，字符串以 $4$ 个空格隔开，分为 $5$ 个域，格式为 $X \ X \ X \ X \ X$，其中 $X$ 是一个域的占位符。$5$ 个域从左至右依次为秒 $(0 - 59)$、分钟 $(0 - 59)$、小时 $(0 - 23)$、日期 $(1 - 31)$、月份 $(1 - 12)$，其中括号内为他们各自的取值范围。同时域内取值也可以使用一些特殊字符（每个域内只能使用一种特殊字符）：

1. 特殊字符 $\tt{*}$（ASCII 码为 $42$）表示所有可能的值。例如：在分钟域内表示每一分钟；在日期域内表示月内的每一天。
2. 特殊字符 $\tt{,}$（ASCII 码为 $44$）表示列出枚举值。例如：在秒域内，$3,20$ 表示分别在 3 秒和 20 秒执行一次任务。
3. 特殊字符 $\tt{-}$（ASCII 码为 $45$）表示范围，可以视为连续的若干个枚举值。例如：$1 - 5$ 等价于 $1,2,3,4,5$。

例如，

$$ 421,3,151 - 31 * $$

表示的含义是每个月份中的每一天中的 $01:02:04$、$03:02:04$、$15:02:04$ 这三个时刻各执行一次，在 $2023$ 年一共会执行 $1095$ 次。

现在给出你一个合法的 SimpleCron 表达式，其中用到的所有数字均没有前导零。请问在 $2023$ 一整年当中，使用了这个表达式的定时任务总计会执行多少次？

## 说明/提示

### 评测用例规模与约定

对于所有评测用例，$0 \leq$ 秒域的取值 $\leq 59$，$0 \leq$ 分钟域的取值 $\leq$ $59$，$0 \leq$ 小时域的取值 $\leq 23$，$1 \leq$ 日期域的取值 $\leq 31$，$1 \leq$ 月份域的取值 $\leq 12$。

## 样例 #1

### 输入

```
4 2 1,3,15 1-31 *```

### 输出

```
1095```

# 题解

## 作者：chenhouye (赞：3)

## 思路  
由于每天的小时数、分钟数、秒数固定，所以可以单独分析，使用一个变量 $day$ 来记录每天执行多少次操作。  
对于每一个月，天数不固定，所以可以将需要执行操作的日期标记在一个数组内，再检索需要执行操作的月的每一天，看是否需要，若是，则答案加上 $day$ 。  
### 如何处理各个表达式？  
* $*$ 格式：最简单，就是全部阈值。
  * 对于时、分、秒， $day$ 直接乘上范围。
  * 对于其他的，将数组内阈值内每一个数标记。
* $,$ 格式（这里把单独一个数字算进去）：
  * 对于时、分、秒，可以偷懒，数一下“ $,$ ”的数量 $sum$ ，变量 $day$ 乘上 $(sum+1)$ 。
  * 对于其他的，则需要以“ $,$ ”为分隔获取所有数字，再在数组内标记。
* $-$ 格式：先获取“ $-$ ”前和后两个数字，分别为 $left$ 和 $right$ 。
  * 对于时、分、秒， $day$ 乘上 $(right-left+1)$ 。
  * 对于其他的，在数组中将 $left$ 到 $right$ 区间内的数标记。  
## 代码  
```
#include<bits/stdc++.h>
using namespace std;
int day=1,l,sum;//l用来存储字符串长度，随时备用
bool dm[40][2];//dm[i][0]用来标记日期i，dm[i][1]用来标记月份i
string s[10];//分别存储5个小段字符串
void f1(int p,int h){//f1函数针对时、分、秒
	//p表示哪一段字符串，h表示范围
	if(s[p][0]=='*') day*=h;
	else{
		bool flag=0;
		l=s[p].size();
		sum=0;
		for(int i=0;i<l;i++){
			if(s[p][i]==',') sum++;
			if(s[p][i]=='-') flag=1;
		}
		if(!flag){//是“,”情况
			day=day*(sum+1);
			return ;
		}
		flag=0;
		int left=0,right=0;
		for(int i=0;i<l;i++){
			if(s[p][i]=='-') flag=1;
			else if(!flag) left=left*10+(s[p][i]-'0');
			else right=right*10+(s[p][i]-'0');
		}
		day=day*(right-left+1);
	}	
}
void f2(int p,int h){//f2函数针对月、日
	//p、h意义同f1函数
	if(s[p][0]=='*'){
		for(int i=1;i<=h;i++){
			dm[i][p-3]=1;
		}
	}
	else{
		bool flag=0;
		int n=0;
		l=s[p].size();
		for(int i=0;i<l;i++){
			if(s[p][i]=='-') flag=1;
			else if(s[p][i]!=',') n=n*10+(s[p][i]-'0');
			else{
				dm[n][p-3]=1;
				n=0;
			}
		}
		if(!flag){//是“,”情况
			dm[n][p-3]=1;//扫尾，别忘了
			return ;
		}
		int left=0,right=0;
		flag=0;
		for(int i=0;i<l;i++){
			if(s[p][i]=='-') flag=1;
			else if(!flag) left=left*10+(s[p][i]-'0');
			else right=right*10+(s[p][i]-'0');
		}
		for(int i=left;i<=right;i++){
			dm[i][p-3]=1;
		}
	}	
}
int main(){
	for(int i=0;i<5;i++){
		cin>>s[i];
	}//输入
	f1(0,60);
	f1(1,60);
	f1(2,24);
	for(int i=1;i<=31;i++){
		dm[i][0]=0;
		dm[i][1]=0;
	}//初始化
	f2(3,31);
	f2(4,12);
	//检索哪些月和日
	int k[40]={0,31,28,31,30,31,30,31,31,30,31,30,31},ans=0;
	for(int i=1;i<=12;i++){
		if(dm[i][1]){
			for(int j=1;j<=k[i];j++){
				if(dm[j][0]) ans+=day;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```
## 后记  
本人第一次发题解，讲得不好或码风不正敬请谅解。

---

## 作者：W_C_B_H (赞：2)

Update 2025.04.20 14:55：题解被认为是 AI 生成的，后根据 LA 群群友的建议做了一些修改。

[题目传送门](/problem/P12240)。

题目大意：给定一个 SimpleCron 表达式，求使用了它的定时任务在 2023 年内被执行的次数。

由于枚举 $365\times24\times60\times60$ 秒显然不现实，故我们可以先算出在有效的日期和月份内，每天该定时任务被执行的次数，记为 `oneDay`，再对于每个有效的日期和月份累加答案。

具体地，对于秒、分钟和小时：如果该字符串是 `*`，则返回值域大小（秒、分钟各 $60$，小时是 $24$）；如果该字符串包含 `,`，则将其根据 `,` 分隔成若干段，并返回段数；如果该字符串包含 `-`，则返回其表示的区间的长度；否则，返回 $1$（即仅有一种取值）。
 
根据乘法原理，将秒、分钟和小时按上述流程处理后的返回值相乘，便得到了在有效的日期和月份内，每天被执行的次数。

接着计算有哪些日期和月份有效，用两个 `boolean` 数组 `validDay[1..31]` 和 `validMonth[1..12]` 分别标记对应日期和月份是否有效，具体过程与对秒、分钟和小时的处理类似，若是 `*` 则全部标记为 `true`，其余的标记对应的下标即可。

最后用两重循环枚举一年的每一天（先枚举月份，若该月有效再枚举该月的每一天），若其有效则将答案加上每天被执行的次数。

Code：

```java
import java.util.Scanner;
public class Main {
    static final int DAY = 31, MONTH = 12; // 最大日期和月份
    static String sec, min, hour, day, month;
    static int oneDay = 1, ans = 0; // oneDay 表示在有效的日期内一天会被执行几次, ans 表示一年总执行次数
    static int[] daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 2023 年每月天数
    static boolean[] validDay = new boolean[35]; // validDay[i] 表示日期为 i 时是否会被执行
    static boolean[] validMonth = new boolean[15]; // validMonth[i] 表示月份为 i 时是否会被执行
    static int calc(String str, int range) {  // 计算一个表达式的某个域的取值情况数
        if(str.equals("*")) {    // 所有可能的值
            return range;
        }
        if(str.contains(",")) { // 枚举值
            String[] arr = str.split(",");
            return arr.length;
        }
        if(str.contains("-")) { //范围
            String[] arr = str.split("-");
            int start = Integer.parseInt(arr[0]);
            int end = Integer.parseInt(arr[1]);
            return end - start + 1;
        }
        return 1;
    }
    static void initValidDay() { // 初始化 validDay 数组
        if(day.equals("*")) {   // 每个日期均有效
            for(int i = 1; i <= DAY; i++) {
                validDay[i] = true;
            }
        } else if(day.contains(",")) { // 枚举值
            String[] arr = day.split(",");
            for(String s : arr) {
                int d = Integer.parseInt(s);
                validDay[d] = true;
            }
        } else if(day.contains("-")) { // 范围
            String[] arr = day.split("-");
            int start = Integer.parseInt(arr[0]);
            int end = Integer.parseInt(arr[1]);
            for(int i = start; i <= end; i++) {
                validDay[i] = true;
            }
        } else {    // 单个值
            int d = Integer.parseInt(day);
            validDay[d] = true;
        }
    }
    static void initValidMonth() {  // 初始化 validMonth 数组
        if(month.equals("*")) {   // 每个月份均有效
            for(int i = 1; i <= MONTH; i++) {
                validMonth[i] = true;
            }
        } else if(month.contains(",")) { // 枚举值
            String[] arr = month.split(",");
            for(String s : arr) {
                int m = Integer.parseInt(s);
                validMonth[m] = true;
            }
        } else if(month.contains("-")) { // 范围
            String[] arr = month.split("-");
            int start = Integer.parseInt(arr[0]);
            int end = Integer.parseInt(arr[1]);
            for(int i = start; i <= end; i++) {
                validMonth[i] = true;
            }
        } else {    // 单个值
            int m = Integer.parseInt(month);
            validMonth[m] = true;
        }
    }
    public static void main(String[] args) {
        // 初始化
        for(int i = 1; i <= DAY; i++) {
            validDay[i] = false;
        }
        for(int i = 1; i <= MONTH; i++) {
            validMonth[i] = false;
        }
        // 输入
        Scanner sc = new Scanner(System.in);
        sec = sc.next();
        min = sc.next();
        hour = sc.next();
        day = sc.next();
        month = sc.next();
        // 计算
        oneDay *= calc(sec, 60);
        oneDay *= calc(min, 60);
        oneDay *= calc(hour, 24);   // 此时 oneDay 表示在有效的日期内一天会被执行多少次
        initValidDay();
        initValidMonth();
        for(int i = 1; i <= 12; i++) {  //枚举月份
            if(validMonth[i]) { //若该月有效
                for(int j = 1; j <= daysOfMonth[i-1]; j++) {    //枚举该月的每一天
                    if(validDay[j]) {   //若日期有效
                        ans += oneDay;  //累加答案
                    }
                }
            }
        }
        // 输出
        System.out.println(ans);
        sc.close();
    }
}
```

---

## 作者：bayiran (赞：1)

~~其实非常简单，就是把五个数（范围）相乘就好了。~~

---

### 分析

根据题目，输入的是五个字符串，把这五个字符串分别遍历，最终可能值相乘即可。

对于特殊字符的判断：

- `*`：遇到直接取最大数值，然后退出遍历。
- `-`：将它前面和后面的数值相减。
- `,`：相当于分隔符，数出有多少个，若有 `n` 个 `,`，则可能值是 $n+1$。

由于题目中说明同一个域内只有一个特殊字符，因此不考虑其他情况。

注意：**每一个月的天数不固定，因此需要建立一个数组来表示每个月份的天数**，再进行相乘。

其实把每个月的天数相加也可以。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> ac(const string s,int mi,int ma){
    vector<int> ans;
    if(s == "*"){
        ans.reserve(ma - mi + 1);
        for(int i=mi;i<=ma;i++){
            ans.push_back(i);
        }  
    }
    else if(s.find(',') != string::npos){
        istringstream iss(s);
        string t;
        while(getline(iss, t, ',')){
            ans.push_back(stoi(t));
        }    
        sort(ans.begin(),ans.end());
        ans.erase(unique(ans.begin(),ans.end()),ans.end());
    }
    else if(s.find('-') != string::npos) {
        size_t p = s.find('-');
        int start = stoi(s.substr(0,p));
        int end = stoi(s.substr(p+1));
        ans.reserve(end - start + 1);
        for(int i=start;i<=end;i++){
            ans.push_back(i);
        }
            
    }
    else{
        ans.push_back(stoi(s));
    }
    return ans;
}
int main() {
    string s,mi,h,d,mo;
    cin>>s>>mi>>h>>d>>mo;
    vector<int> sv = ac(s, 0, 59);
    vector<int> miv = ac(mi, 0, 59);
    vector<int> hv = ac(h, 0, 23);
    vector<int> dv = ac(d, 1, 31);
    vector<int> mov = ac(mo, 1, 12);
    const int fixed = sv.size() * miv.size() * hv.size();
    int ans = 0;
    const int md[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    for (int m : mov) {
        int maxday = md[m];
        auto it = upper_bound(dv.begin(), dv.end(), maxday);
        ans += fixed * (it - dv.begin());
    }
    
    cout<<ans<<endl;
    return 0;
}
```

---


# [蓝桥杯 2025 国 B] 子串去重

## 题目描述

给定一个字符串 $S$ 以及若干组询问，每个询问包含两个区间 $(L_a, R_a)$, $(L_b, R_b)$，你需要判定 $S_{L_a}, S_{L_a+1}, \ldots, S_{R_a}$ 与 $S_{L_b}, S_{L_b+1}, \ldots, S_{R_b}$ 去重后有多少个位置上的字符是不同的。

这里的去重指的是每个子串对于每种字符，只保留第一个出现的那个，后续出现的直接丢弃。

例如 $\tt{aabcbac}$ 在选中区间 $[1,5]$ 时，得到子串 $\tt{aabcb}$，去重后为 $\tt{abc}$，选中区间 $[3,6]$ 时得到 $\tt{bcba}$，去重后为 $\tt{bca}$。

特别地，两个长度不同的子串中，较长串的多出的部分每个位置都视为不同。

## 说明/提示

**【评测用例规模与约定】**

对于 40% 的评测用例，$|S| \leq 10$, $m = 1$。

对于 60% 的评测用例，$|S|, m \leq 5000$。

对于 100% 的评测用例，$1 \leq |S|, m \leq 10^5$, $1 \leq L_a \leq R_a \leq |S|$, $1 \leq L_b \leq R_b \leq |S|$。

## 样例 #1

### 输入

```
aabcbabacdab
3
1 1 2 2
1 10 6 9
4 7 9 12```

### 输出

```
0
1
2```

# 题解

## 作者：vegetableYe (赞：3)

### 第十六届蓝桥杯CB国赛 I-子串去重

本题不难，这里我们直接说说正解。

非常容易注意到的事情是，字符串去重后的长度是不超过 $26$ 的，因此如果我们能得到两个区间的子串去重后的字符串，那么对于题目求的东西，我们是可以直接暴力匹配算出的，复杂度不超过 $O(\Sigma)$。

那么问题就来到了，如何获得去重后的两个串呢？

题目中提到了，去重是保留第一个出现的字母，这个东西长得就很像 "子序列自动机"，因此我们往这方面考虑。

子序列自动机即：$nxt_{i,j}$ 表示，从 $i$ 位置开始往后找，字母 $j$ 第一次出现的位置。

那么借助自动机 $nxt$，对于区间 $[L,R]$ 我们只需要枚举一遍 $26$ 个字母，看是否满足 $nxt_{L, j} \leq R$，只要满足就说明："下标 $L$ 右边第一个出现的字母 $j$ 在 $R$ 左侧"，也就是 $j$ 在区间以内，因此就可以 $O(26)$ 获得任意区间 $[L,R]$ 去重后的字符串。

我们对 $[l_1, r_1]$ 和 $[l_2, r_2]$ 分别取出串暴力对比即可。

那么我们只需要考虑如何求出 $nxt$，这一步实际上是非常经典、同时也是固定套路的递推求解，我们倒序枚举 $i$，直接 $nxt_i=nxt_{i+1}$，再 $nxt_{i, s_i-'a'}=i$ 即可。

```cpp
void solve() {
	string s;
	cin >> s;
	int n = s.size();
	s = " " + s;
	vector<vector<int>> nxt(n + 2, vector<int>(26, n + 1));
	for(int i = n; i > 0; i--) {
		nxt[i] = nxt[i + 1];
		nxt[i][s[i] - 'a'] = i;
	}
	
	int q;
	cin >> q;
	while(q--) {
		int l1, r1, l2, r2;
		cin >> l1 >> r1 >> l2 >> r2;
		vector<P> v1, v2;
		for(int j = 0; j < 26; j++) {
			if(nxt[l1][j] <= r1) {
				v1.emplace_back(nxt[l1][j], j + 'a');
			}
			if(nxt[l2][j] <= r2) {
				v2.emplace_back(nxt[l2][j], j + 'a');
			}
		}
		sort(v1.begin(), v1.end());
		sort(v2.begin(), v2.end());
		int sz1 = v1.size(), sz2 = v2.size();
		int ans = abs(sz1 - sz2);
		int mn = min(v1.size(), v2.size());
		for(int i = 0; i < mn; i++) {
			ans += (v1[i].y != v2[i].y);
		}
		
		cout << ans << endl;
	}
}
```

时间复杂度：$O(|S|+q \times |\Sigma| \times \log(|\Sigma|))$。（$\log(\Sigma)$ 是因为我们要对去重后的字符串按下标排序，这样才是字符串真实的顺序。）（其中 $\Sigma=26$，指的是字符集大小。）

---

## 作者：I_AM_TLEer (赞：1)

# P12838 [蓝桥杯 2025 国 B] 子串去重

## 题目大意：

给定一个字符串 $S$，提出 $m$ 个询问，每问包含两个区间。若每个区间只保留每种字符第一个出现的那个。问重组之后两字符串有多少个位置上的字符是不同的。

## 思考过程：

依旧是 `第一个出现的那个`，这就很二分。具体地：从前到后预处理，累计每个字符的数量，构成单调不降序列。查找时二分第一个出现的。

但思考过后，二分的目的也可以预处理出来。

之后的操作可以轻松得到：放入结构体中，排序得出重组结果，比较输出答案。

## AC code:


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int b[35][100005];
char a[100005], ans[2][35];
int m, len, l1, r1, l2, r2;

struct num {
	char fc;
	int fi;
} nit[35];

bool cmp (num a1, num b1) {
	return a1.fi < b1.fi;
}

int igh (int l, int r, int cv) {
	l --, r --; int len0 = 0;
	for (int i = 0; i < 26; i ++) {
		nit[i].fc = 'a' +i;
		nit[i].fi = b[i][l];
	}
	sort(nit, nit +26, cmp);
	for (int i = 0; i < 26; i ++) {
		if (nit[i].fi > r) ans[cv][i] = '\0';
		else ans[cv][i] = nit[i].fc, len0 ++;
	}
	return len0;
}

int wes (int len1, int len2) {
	int mlen = max(len1, len2), end = 0;
	for (int i = 0; i < mlen; i ++)
		end += (ans[0][i] != ans[1][i]);
	return end;
}

signed main () {
	scanf("%s", a);
	len = strlen(a);
	for (int i = 0; i < 26; i ++) b[i][len] = len;
	for (int i = len -1; i >= 0; i --) {
		for (int i1 = 0; i1 < 26; i1 ++)
			b[i1][i] = b[i1][i +1];
		b[a[i] -'a'][i] = i;
	}
	scanf("%lld", &m);
	for (int i = 0; i < m; i ++) {
		scanf("%lld %lld %lld %lld", &l1, &r1, &l2, &r2);
		printf("%lld\n", wes(igh(l1, r1, 0), igh(l2, r2, 1)));
	}
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/222115485)

---

## 作者：3_14 (赞：1)

[**题目传送门**](https://www.luogu.com.cn/problem/P12838)

# 思路

## 分析

子串去重后由每个字符首次出现的位置组成。例如，子串 aabcb 去重后为 abc，因为后续的 a 和 b 被丢弃。

计算差异：长度，去重后的子串长度分别为 $k_1$ 和 $k_2$，则差异数至少为 $\left|k_1 - k_2\right|$。

优化：预先记录每个字符在字符串中的所有出现位置，就可以快速判断字符是否在区间内首次出现。

## 具体做法

对每个区间 $\left[ L,R \right]$，遍历每个字符 $c$，检查其是否在区间内首次出现。若是，则记录该位置，并将 $c$ 加入去重子串。排序所有记录的位置，生成去重后的子串。比较两个去重子串，计算差异。最后输出。

# 代码

```cpp
#include<bits/stdc++.h>
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=3e4+5,mod=1e9+7,MOD=998244353;
vector<int>pos[26];//存储每个字符的1-based位置列表
//计算区间[L,R]去重后的长度及首次出现位置
pair<int,vector<int>>pcs(int L,int R,string s){
    vector<int>lst;
    int k=0;
    for(int c=0;c<26;c++){//遍历26个小写字母
        auto&p=pos[c];
        if(p.empty())continue;
        //二分查找第一个>=L的位置
        auto it=lower_bound(p.begin(),p.end(),L);
        if(it==p.end())continue;
        int pi=*it;
        if(pi>R)continue;
        int idx=it-p.begin();
        //检查是否为区间内首次出现
        if((idx==0)||(p[idx-1]<L)){
            k++;
            lst.push_back(pi);
        }
    }
    sort(lst.begin(),lst.end());//按位置排序得到去重子串顺序
    return {k,lst};
}
string s;
int m,La,Ra,Lb,Rb;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>s>>m;
    int n=s.size();
    //预处理每个字符的出现位置（1-based）
    for(int i=0;i<n;i++)pos[s[i]-'a'].push_back(i+1);
    while(m--){
        cin>>La>>Ra>>Lb>>Rb;
        auto[k1,lst1]=pcs(La,Ra,s);
        auto[k2,lst2]=pcs(Lb,Rb,s);
        int t=min(k1,k2),df=0;
        for(int i=0;i<t;i++){//比较前t个位置的字符
            char ch1=s[lst1[i]-1],ch2=s[lst2[i]-1];//1-based转0-based
            if(ch1!=ch2)df++;
        }
        cout<<df+abs(k1-k2)<<'\n';
    }
    return 0;
}
```

### 时间复杂度

大概是 $O\left(n + m \times 26 \log n\right)$。

卡着 $999$ms 过，勿喷。

[**AC 记录**](https://www.luogu.com.cn/record/221287649)

---

## 作者：itzxianfish (赞：0)

现场怪来力~~。

# 题目大意

给定一个字符串 $S$ 和操作次数 $t$，每次操作给出两个区间，分别是 $[L_a, R_a]$ 和 $[L_b, R_b]$，我们需要对区间内的字符去重后比较不同字符的数量，如果长度不一样，多出来的部分视为不同。

在题目中，去重定义为“每个子串对于每种字符，只保留第一个出现的那个，后续出现的直接丢弃”。

# 分析

一开始看到带区间询问题目，我还很兴奋的以为是线段树，但是发现事情没这么单纯 QAQ。

显然，根据题意，去重不仅与区间的字符有关，还与其各自出现的顺序相关。

单独考虑一次区间去重操作，那我们其实可以把问题转化成：**对于每一个字符，如果其在区间内存在，寻找其在区间内第一次出现的位置，按照下标排序输出**。

如果你是个铁头娃，那自然可以直接线性扫描一遍，但是我们可以仔细看看这个转化之后的问题，用测试样例的字符串来说，设 $S = \texttt{aabcbabacdab}$，对于**每一个小写字母**进行寻找，那么我们可以直接对其中某一个字母进行讨论。比如 $\texttt{a}$，那么，我们可以获得字符 $\texttt{a}$ 的下标序列：$[1, 2, 6, 8, 11]$，对于其他字符同理。

我们可以使用哈希表在线性扫描字符串的同时获得所有字符的下标数组，而且在线性扫描的时候获取还有个十分重要的特性，就是下标是**严格递增的**，这意味着我们寻找字符第一次在区间出现的下标是不必要线性扫描的，我们可以使用**二分查找**来寻找。

# 代码实现

输入字符串后直接线性扫描，存储下标。

实现一个函数，用于获取区间去重结果，然后直接遍历获得的去重结果来计算本次查询的 $ans$ 即可。

我下面贴出 C++ 比较新的语法实现，为了尽可能的适配比赛常用的语法，我会在注释里写一些大致的实现。


```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <ranges>
#include <utility>
using namespace std;
using Pair = pair< int, char >;

int t;
int L1, R1, L2, R2;
string s;
// int mp[26][MAXN], cnt[26];
map< int, vector<int> > charToIndex;

inline vector<Pair> getRange(int l, int r) {
	// Pair seg[30]; int tot;
	vector<Pair> seg;

	for (int i = 0; i < 26; i++) {
		// int p = lower_bound(mp[i] + 1, mp[i] + cnt[i] + 1, l) - mp[i];
		// lower_bound 可以选择手写
		auto it = ranges::lower_bound(charToIndex[i], l);

		// *it > r 等价于 mp[i][p] > r
		// 关于 end 迭代器，可以设置标记来替换
		if (it == charToIndex[i].end() || *it > r)
			continue;

		seg.push_back({ *it, static_cast<char>(i + 'a') });
	}

	// sort(seg + 1, seg + tot + 1)
	ranges::sort(seg);

	// 可以改用全局变量
	return seg;
}

int main() {
	cin >> s >> t;
	
	// mp[s[i] - 'a'][++cnt[s[i] - 'a']] = i + 1;
	for (int i = 0; i < s.size(); i++)
		charToIndex[static_cast<int>(s[i] - 'a')].push_back(i + 1);

	while (t--) {
		cin >> L1 >> R1 >> L2 >> R2;
		auto aVec = getRange(L1, R1);
		auto bVec = getRange(L2, R2);

		// 先计算长度不同的情况
		int ans = abs(static_cast<int>(aVec.size() - bVec.size()));
		
		// 遍历返回序列，寻找不同字符
		for (int i = 0; i < min(aVec.size(), bVec.size()); i++)
			ans += aVec[i].second != bVec[i].second;

		cout << ans << endl;
	}

	return 0;
}
```

这份没有任何优化手段的代码，跑了 $800ms$ 左右，所以使用常数表现更好的写法是保证不会超时的。

# 时间复杂度

我觉得这一部分是蛮有意思的，直到我在洛谷提交这一份代码（不同于赛场的 C++11 实现）之前，我都认为这个思路会因为常数太大而时间爆炸。

第一部分：读取和哈希表，这一部分时间是 $O(n)$ 或者 $O(n\log n)$，取决于使用 map 还是数组。

第二部分：查询，查询的输入和扫描计算去重序列算在一起是自带 $26$ 的常数。

第三部分：查询函数，首先一开始对每一个字符二分查找，算作 $O(26\log n)$，而后还有排序，所以整个函数算是 $O(26\log n + 26\log 26)$。

总共算在一起算是：$O(n\log n+q\log n)$，但是撇去了大的可怕的常数，赛后同学锐评道：常数大过线段树。

# 总结

其实赛时看到这道题，我想起来曾经做过的一道 CodeForce 的贪心（[感兴趣的可以看看](https://www.luogu.com.cn/problem/CF2111E)），也涉及到这样的哈希表存下标，于是就往这个方向想，得到了题解中的解法，也算是幸运力~~。

一改：修正字符串字体问题。

---


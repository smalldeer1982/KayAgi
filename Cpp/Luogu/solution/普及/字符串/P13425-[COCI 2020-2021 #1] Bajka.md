# [COCI 2020/2021 #1] Bajka

## 题目描述

小 Fabijan 看腻了图画书，于是他决定读他的第一本童话故事。不幸的是，Fabijan 经常遇到一个让他害怕的单词。为了克服恐惧，他发明了一个小游戏。

这个可怕的单词可以表示为一个长度为 $n$ 的小写字母数组。游戏开始时，Fabijan 将手指放在数组的某个位置，并把该位置的字母写在纸上。随后，他可以任意次数地执行以下两种操作中的一种：

- 他可以将手指移动到当前左边或右边相邻的位置（如果该位置存在），并把新位置上的字母写在纸上，写在最后一个字母之后。
- 他可以将手指移动到任意一个与当前位置字母相同的位置。在这种情况下，Fabijan 不会在纸上写任何字母。

从位置 $x$ 移动到位置 $y$ 需要 $|x-y|$ 秒。

如果游戏结束时，纸上写下了他最喜欢的单词，那么 Fabijan 就能克服对这个单词的恐惧。他希望尽快完成童话故事，因此请你告诉他，最少需要多少秒才能在纸上写下他最喜欢的单词。


## 说明/提示

第三个样例说明：

Fabijan 首先将手指放在第 $7$ 个位置，并写下字母 'b'。接着，他向左移动两次，每次都写下字母 'o'。下一步，他用第二种操作将手指移动到第 $6$ 个位置。最后，他再向左移动两次，分别写下字母 'o' 和 'k'。总共用了 $5$ 秒，每次移动耗时 $1$ 秒。

### 评分

在价值 $20$ 分的测试数据中，让 Fabijan 害怕的单词中的字母两两不同。

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
2 2
wa
ac```

### 输出

```
-1```

## 样例 #2

### 输入

```
7 7
monolog
nogolom```

### 输出

```
10```

## 样例 #3

### 输入

```
14 5
niskoobrazovan
boook```

### 输出

```
5```

# 题解

## 作者：b__b (赞：2)

我们考虑动态规划。设 Fabijan 害怕的单词为 $s$，喜欢的单词为 $p$，我们定义状态 $f(i,j)$ 表示现在手指在 $s$ 的第 $i$ 个字母上，写 $p$ 的第 $j$ 个字母所需的最小时间。那么我们有（字符串索引从 $1$ 开始）：
$$
f(i,j)=\begin{cases}
0 & j = m, \\
\infty & i \leq 1\quad\text{or}\quad i>n \quad\text{or}\quad s_i \neq p_{j-1},\\
\min\limits_{1 \leq k \leq n,s_k=s_a} \{f(k-1,j+1),f(k+1,j+1)\}+\lvert i - k \rvert + 1 & \text{otherwise.}
\end{cases}
$$
~~好长一公式。~~

于是我们可以使用记忆化搜索或者递推的方式编写。
```cpp
#include <iostream>
#include <cmath>
const int INF = 0x1BF52, N = 305; //你是一个一个一个常量
char s[N], p[N];
int jy[N][N], n, m;
int dfs(int a, int b) {
    if (b == m) return 0;
    if (jy[a][b]) return jy[a][b];
    int ret = INF;
    for (int i = 0; i < n; ++i) if (s[i] == s[a]) for (int j = -1; j <= 1; ++j)
        if (j && i + j >= 0 && i + j < n && s[i + j] == p[b])
            ret = std::min(ret, dfs(i + j, b + 1) + abs(i - a) + 1);
    return jy[a][b] = ret;
}
int main() {
    scanf("%d%d%*c%s%s", &n, &m, s, p);
    int ans = INF;
    for (int i = 0; i < n; ++i) if (s[i] == p[0]) ans = std::min(ans, dfs(i, 1));
    if (ans == INF) puts("-1");
    else printf("%d", ans);
}
```
递推的方式：
```cpp
#include <iostream>
#include <cstring>
#include <cmath>
const int N = 305;
char s[N], p[N];
int dp[N][N], n, m;
int main() {
    scanf("%d%d%*c%s%s", &n, &m, s, p), memset(dp, 0x3f, sizeof dp);
    for (int i = 0; i < n; ++i) dp[i][m] = 0;
    for (int i = m - 1; i; --i) for (int j = 0; j < n; ++j) for (int k = 0; k < n; ++k) if (s[j] == s[k])
        for (int u = -1; u <= 1; u += 2)
            if (u && k + u >= 0 && k + u < n && s[k + u] == p[i])
                dp[j][i] = std::min(dp[j][i], dp[k + u][i + 1] + abs(j - k) + 1);
    int ans = 0x3f3f3f3f;
    for (int i = 0; i < n; ++i) if (s[i] == p[0]) ans = std::min(ans, dp[i][1]);
    if (ans == 0x3f3f3f3f) puts("-1");
    else printf("%d", ans);
}
```
时间复杂度：外层循环为 $O(n)$，dfs 函数内部一次需要 $O(n)$，总共递归 $m$ 层，时间复杂度为 $O(n^2m)$。

空间复杂度：显然为 $O(nm)$。

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13425)

# 题目分析

使用动态规划。设害怕的单词为 $a$，喜欢的单词为 $b$。

### 定义状态

定义 $f_{i,j}$ 表示在 $a$ 中找出 $b$ 的**前** $i$ 个字母，$b$ 中**第** $i$ 个字母在 $a$ 中的位置为 $j$ 时所需最短时间。

### 状态转移方程
显然，$a_{j-1}$ 和 $a_{j+1}$ 需要至少有一个是 $b_{i-1}$。对于满足条件的 $i$ 和 $j$，我们需要找到另外一个位置 $k$ 使得 $a_k=b_{i-1}$，然后从该位置移动到 $a_{j-1}$ 或 $a_{j+1}$，需要保证移动后的位置对应的字母等于 $b_{i-1}$，这就是为什么 $a_{j-1}$ 和 $a_{j+1}$ 需要至少有一个是 $b_{i-1}$。那么我们可以求出到 $k$ 的最短时间，然后时间需要再加上 $\left| k-(j-1) \right|$ 或 $\left| k-(j+1) \right|$。最后再加 $1$ 移动到 $j$。这样我们就可以列出状态转移方程：

$$f_{i,j}=\begin{cases} \infin & a_{j-1}\ne b_{i-1} \text{ and } (j+1\ge n \text{ or } a_{j+1}\ne b_{i-1})\\ \mathop{\min}\limits_{a_k=b_{i-1}}f_{i-1,k}+\left| k-(j-1) \right| +1 & a_{j-1}=b_{i-1} \text{ and } (j+1\ge n \text{ or } a_{j+1}\ne b_{i-1})\\ \mathop{\min}\limits_{a_k=b_{i-1}}f_{i-1,k}+\left| k-(j+1) \right| +1 & a_{j+1}=b_{i-1} \text{ and } a_{j-1} \ne b_{i-1}\\ \min(\mathop{\min}\limits_{a_k=b_{i-1}}f_{i-1,k}+\left| k-(j-1) \right| +1,\mathop{\min}\limits_{a_k=b_{i-1}}f_{i-1,k}+\left| k-(j+1) \right| +1 & a_{j-1}=b_{i-1} \text{ and } a_{j+1}=b_{i-1} \end{cases}$$

### 初始状态

$$f_{0,i}=\begin{cases} 0 &a_i=b_0 \\ \infin & a_i\ne b_i \end{cases}$$

# 代码

```cpp
#include<bits/stdc++.h>
#define N 305
using namespace std;
int mem[30][N],h[30];
long long f[N][N];
int main(){
    int n,m;
    char a[N],b[N];
    cin>>n>>m>>a>>b;
    for(int i=0;i<n;i++){
        mem[a[i]-'a'][++h[a[i]-'a']]=i;
    }
    if(h[b[0]-'a']>0){
        for(int i=1;i<=h[b[0]-'a'];i++){
            f[0][mem[b[0]-'a'][i]]=0;
        }
    }
    else{
        cout<<-1;
        return 0;
    }
    for(int i=1;i<m;i++){
        char c=b[i];
        int yes=0;
        if(h[c-'a']==0){
            cout<<-1;
            return 0;
        }
        for(int j=1;j<=h[c-'a'];j++){
            f[i][mem[c-'a'][j]]=100000000001;
            if(a[mem[c-'a'][j]-1]!=b[i-1]&&(a[mem[c-'a'][j]+1]!=b[i-1]||mem[c-'a'][j]>=n)){
                continue;
            }
            if(a[mem[c-'a'][j]-1]==b[i-1]){
                for(int k=1;k<=h[b[i-1]-'a'];k++){
                    if(mem[c-'a'][j]==mem[b[i-1]-'a'][k]){
                        continue;
                    }
                    f[i][mem[c-'a'][j]]=min(f[i][mem[c-'a'][j]],f[i-1][mem[b[i-1]-'a'][k]]+abs(mem[c-'a'][j]-1-mem[b[i-1]-'a'][k])+1);
                    yes=1;
                }
            }
            if(mem[c-'a'][j]<n-1&&a[mem[c-'a'][j]+1]==b[i-1]){
                 for(int k=1;k<=h[b[i-1]-'a'];k++){
                    if(mem[c-'a'][j]==mem[b[i-1]-'a'][k]){
                        continue;
                    }
                    f[i][mem[c-'a'][j]]=min(f[i][mem[c-'a'][j]],f[i-1][mem[b[i-1]-'a'][k]]+abs(mem[c-'a'][j]+1-mem[b[i-1]-'a'][k])+1);
                    yes=1;
                }
            }
        }
        if(!yes){
            cout<<-1;
            return 0;
        }
    }
    long long minx=10000000001;
    for(int i=1;i<=h[b[m-1]-'a'];i++){
        minx=min(minx,f[m-1][mem[b[m-1]-'a'][i]]);                                 
    }
    cout<<minx;                                                              
    return 0;
}
```

---


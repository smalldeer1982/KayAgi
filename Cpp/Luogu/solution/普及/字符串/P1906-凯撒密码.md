# 凯撒密码

## 题目描述

在元老院的支持下，Caesar率领罗马军团进攻高卢地区。但是他的军事行动并不顺利，他急需你的支持。

一天，你突然受到Caesar从前线写来的信。为了防止敌军偷窃情报，Caesar决定用自创的密码来写这封信。但是面对满纸的乱码，你也无从下手。于是你前往元老院询问这种密码的玄机。

元老们告诉你，这是凯撒移位密码（世界上最早的加密术——编者注），解读它非常的简单：

对于明文中的每个字母，Caesar会用它后面的第t个字母代替。例如，当t=3时，字母A将变成C，字母B将变成D，……，字母Y将变成A，字母Z将变成B（假设字母表是循环的）。

这样一来，字母表：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

将变成： C D E F G H I J K L M N O P Q R S T U V W X Y Z A B

明文：  I Need Soldiers  将加密为

密文：  K Pggf Uqnfkgtu

如此一来，需要传达的信息在外人看来就如同天书了。加上Caesar会不时更换t的值，使得密码变得更加难以捉摸。

你的任务是将Caesar的密码翻译为明文。


## 说明/提示

1.如果你有看过《福尔摩斯探案集》的话，请回忆“跳舞娃娃”密码破译第一步；

2.我想这些可能会对你有帮助：

e 0.1268

t 0.0978

a 0.0788

o 0.0766

i 0.0707

n 0.0706

s 0.0634

r 0.0594


## 样例 #1

### 输入

```
START
NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX
END
START
N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ
END
START
IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ
END
ENDOFINPUT
```

### 输出

```
IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES
I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME
DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE
```

# 题解

## 作者：kkksc03 (赞：68)

这题其实想起来很简单，就是将原文通过某种偏移得到密文。

原文密文是一一对应的。（还记得noip2012的v什么密码吗？不太一样）

所以t是多少？没说。所以自己算。

其实下面的提示，就是各个字母出现的概率。由于数据量不小，频率约等于概率。所以找到最多的字母，确定他是‘e’，然后解码即可。


---

## 作者：octal (赞：28)

开始看到这道题，好迷茫

### 偏移量是什么呢？

题目说明更是让我疑惑不已

问了度娘才知道

第二条说明是英语构词中，字母出现频率的一个排行榜

("e"在英语单词中出现频率最高)

## 那么题目的意思就是：

## 把第一句暗文中出现最多的字母翻译为"e(E)"，求出偏移量t

## 这样一来题目就简单了

## 我的代码思路呢，就是将问题分解，用自定义函数解决小问题

那么这道题就需要

①输入

②求t

③翻译

④储存

⑤输出

但还需要注意的是

![](https://cdn.luogu.com.cn/upload/pic/48911.png)


## 所以可以先写下这段代码
```
void change(string &s)//将小写转为大写 
{
    int i;
    int len=s.size();
    for(i=0;i<len;i++)
    {
        if(s[i]>='a'&&s[i]<='z')
        s[i]-=32;
    }
}
```
## 这段代码也不难写
```
void translate(string &s,int t)//假设已知t，传址翻译暗文
{
    int len=s.size();
    for(int i=0;i<len;i++)
    {
        if(s[i]>='A'&&s[i]<='Z')
        {
            s[i]+=t;//有左移和右移两种移法，那t就有正负两种情况 
            if(s[i]>'Z') s[i]-=26; 
            if(s[i]<'A') s[i]+=26;//所以这里要有两个边界判断 
        }
    }
}
```
## 然后就是

## 求出t
```
int f(string s)
{
    int i,len=s.size();
    for(i=0;i<len;i++)
    v[(int)s[i]]++;
    int maxn=0,j;
    for(i='A';i<='Z';i++)
    {
        if(v[i]>maxn)
        {
            maxn=v[i];
            j=i;
        }
    }
    int ans='E'-j;//"E"是翻译成的明文，求偏移量用"E"-某出现最多字母 
    return ans;
}
```
## 最后呢，就是这道题的输入要稍微注意一下（嗯、当然是用"while(cin>>...)"）

~~表示苯蒟蒻在这里卡了很久~~

可能你们都知道cin后用getline会把空格和回车读入

## 如果直接打回车，这个getline就结束了~~（做了这道题后我才知道）~~

## 所以要打两个getline

## 那代码就是这样
```
#include<bits/stdc++.h>
using namespace std;
string a,s,e,ans[50];
int num,v[150],t;
void change(string &s)//将小写转为大写 
{
    int i;
    int len=s.size();
    for(i=0;i<len;i++)
    {
        if(s[i]>='a'&&s[i]<='z')
        s[i]-=32;
    }
}
void translate(string &s,int t)
{
    int len=s.size();
    for(int i=0;i<len;i++)
    {
        if(s[i]>='A'&&s[i]<='Z')
        {
            s[i]+=t;//有左移和右移两种移法，那t就有正负两种情况 
            if(s[i]>'Z') s[i]-=26; 
            if(s[i]<'A') s[i]+=26;//所以这里要有两个边界判断 
        }
    }
}
int f(string s)
{
    int i,len=s.size();
    for(i=0;i<len;i++)
    v[(int)s[i]]++;
    int maxn=0,j;
    for(i='A';i<='Z';i++)
    {
        if(v[i]>maxn)
        {
            maxn=v[i];
            j=i;
        }
    }
    int ans='E'-j;//"E"是翻译成的明文，求偏移量用"E"-某出现最多字母 
    return ans;
}
int main()
{
    while(cin>>s,getline(cin,a),getline(cin,a),cin>>e)
    {
        change(a);
        num++;
        if(num==1)//t根据第一句话来求
        t=f(a);
        translate(a,t);
        ans[num]=a;
    }
    for(int i=1;i<=num;i++)
    cout<<ans[i]<<endl;
    return 0;
}
```


---

## 作者：KingHui (赞：6)

我在上小学时候的睡前读物就是《福尔摩斯探案集》，对“跳舞小人”那一章记忆犹新（当时看标题觉得可能是什么恐怖故事，硬是留到了最后才看）。

福尔摩斯解密“跳舞小人”密码的时候，提到了英文中最受欢迎的字母就是‘e’，后来看 **《怪诞小镇》** 的时候经常用这种方法去尝试破译（虽然没有成功过）。

好了，看这道题。

既然是凯撒加密法，那么我们只要找到密文中对应‘E’的字母，我们就可以找到全部的密码表。

观察这道题的输入，个人认为START和END有些不太必要，可能是为了进一步降低难度。我们使用gets()函数进行读取时，完全可以忽略这两个关键词的影响，跳过就好了，对我们来说真正有用的只有**安全词**——ENDOFINPUT。

经过测试发现，输入结尾可能是'\r\n'和'\n'。如果结尾是'\r'，gets()是会读入的，当然可以用scanf的[ ]去解决。但其实我们只需要在比较判断时，使用 **strncmp()** 解决就可以了。

还有，当密文出现多个相等最大值时，取后者！

```c
#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int e[30] = { 0 };
int upper(char s[])//字母替换为大写
{
	for (int i = 0; s[i] != '\0'; i++)
		if (s[i] >= 'a' && s[i] <= 'z')
			s[i] = s[i] - 'a' + 'A';
	return 0;
}
int finde(char s[])//找到密文‘E’
{
	int key = 0, max = 0;
	for (int i = 0; s[i] != '\0'; i++)
		if (s[i] >= 'A' && s[i] <= 'Z')
		{
			e[s[i] - 'A']++;
			if (e[s[i] - 'A'] >= max)
			{
				max = e[s[i] - 'A'];
				key = s[i];
			}
		}
	key -= 'E';
	return key;
}
int main()
{
	char s[10010] = "\0";
	int key;
	while (gets(s))
	{
		if (strncmp(s, "ENDOFINPUT", 10) == 0)
			break;
		else if (strncmp(s, "START", 5) == 0 || strncmp(s, "END", 3) == 0)
			continue;
		else
		{
			upper(s);
			key = finde(s);
		}
		for (int i = 0; s[i] != '\0'; i++)
		{
			if (s[i] >= 'A' && s[i] <= 'Z')//简单的处理+输出
			{
				if (s[i] - key > 'Z')
					printf("%c", s[i] - key - 26);
				else if (s[i] - key < 'A')
					printf("%c", s[i] - key + 26);
				else
					printf("%c", s[i] - key);
			}
			else
				printf("%c", s[i]);
		}
		printf("\n");
	}
	return 0;
}
```


---

## 作者：HanPi (赞：6)

[P1906 凯撒密码](https://www.luogu.com.cn/problem/P1906)

这道题的提示是想告诉你,在一个英语中,字母 `E` 出现的频率最高,也就是说我们找到当前句子中出现最多的字母,它就代表了字母 `E` .知道这个对应关系后,我们把它相减,就得到每一个字母需要偏移的量.

设 $\tt 'A'+ans$ 为找到的代表 'E' 的字符.

则 任意字符所对应的明文应为该字符加上 $\tt 'E'-'A'-ans$

题目提示既然这样说了,样例就~~应该~~会保证满足~~吧~~.

坑点:

- 出现次数不需要清空(见第2个句子 `N` 和 `J` 都是在该句出现6次)
- 如果使用gets读入,前4个测试点是 `ENDOFINPUT\r` ,最后一个测试点是 `ENDOFINPUT`.不特判你将会喜提TLE.
- 偏移后如果超出了范围,需要调整.
- 要转成大写字母

$\tt\large{Code:}$

```c
#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
#include <string.h>
#include <malloc.h>
unsigned int dic[30] = {0};
int FindOffset(char* destStr)
{
    unsigned int i = 0, ans = 0;
    while (destStr[i++])
    {
        if ('a' <= destStr[i] && destStr[i] <= 'z')
        {
            destStr[i] = destStr[i] - 'a' + 'A';
            dic[destStr[i] - 'A']++;
        }
        else if ('A' <= destStr[i] && destStr[i] <= 'Z') dic[destStr[i] - 'A']++;
    }
    for (i = 0; i <= 26; i++)
    {
        //printf("%c %d\n", 'A' + i, dic[i]);
        if (dic[i] > dic[ans])
        {
            ans = i;
        }
    }
    return 'E'-'A'-ans;
}
char buf[500007],s;
int main()
{
    
    char* p,tmp;
    while (gets(buf))
    {
        p = buf;

        if (strcmp(buf, "ENDOFINPUT\r") == 0)break;
        if (strcmp(buf, "ENDOFINPUT") == 0)break;
        
        if (strcmp(buf, "END\r") == 0 || strcmp(buf, "START\r") == 0)continue;
        s = FindOffset(buf);
        while (*p)
        {
            tmp = *p;
            if ('A' <= *p && *p <= 'Z')
            {
                tmp+= s;
                if (tmp < 'A')tmp += 26;
                if (tmp > 'Z')tmp -= 26;
            }
            
            putchar(tmp);
            p++;
        }
        puts("");
    }
    return 0;
}
```


---

## 作者：happybob (赞：5)

这题目有点意思！一开始一定要读清楚题意，第一天看到题，第二天才想到其实吧，这个t，也就是移动的位数一定是要使结果的E最多的，所以其实我们可以在原串中找到出现次数最多的字母，然后往回减（因为是密文转明文）需要用到mapAC此题，12ms：

```cpp
#include <iostream>
#include <map>
#include <cstring>
#include <algorithm>
#include <cstdio>
using namespace std;

map <char, int> mp;

string v, b, s;

int main()
{
    while(true)
    {
        cin >> v;
        if(v == "ENDOFINPUT")
        {
            break;
        }
        scanf("\n");
        getline(cin, s);
        transform(s.begin(), s.end(), s.begin(), ::toupper);
        int len = s.length() - 1, max = 0, a;
        char xb;
        for(int i = 0; i <= len; i++)
        {
            if(isalpha(s[i]))
            {
                mp[s[i]]++;
                if(mp[s[i]] >= max)
                {
                    max = mp[s[i]];
                    xb = s[i];
                }
            }
        }
        if(xb == 'E')
        {
            cout << s << endl;
        }
        else
        {
            if(xb > 'E')
            {
                a = (int)xb - (int)'E';
            }
            else
            {
                a = (int)'E' - (int)xb;
            }
for(int i = 0; i <= len; i++)
                {
                    if(isalpha(s[i]))
                    {
                        if(s[i] - a > 'Z' || s[i] - a < 'A')
                        {
                            for(int j = 1; j <= a; j++)
                            {
                                if(s[i] == 'A')
                                {
                                    s[i] = 'Z';
                                    j++;
                                }
                                if(j <= a)
                                {
                                    s[i]--;
                                }
                            }
                        }
                        else
                        {
                            s[i] -= a;
                        }
                    }
                }
            cout << s << endl;
        }
        cin >> b;
    }
    return 0;
}
```
当然，xb - 'E'其实根本不用转int，map也可以变成hash的unordered_map，10ms：

```cpp
#include <iostream>
#include <unordered_map>
#include <cstring>
#include <algorithm>
#include <cstdio>
using namespace std;

unordered_map <char, int> mp;

string v, b, s;

int main()
{
    while(true)
    {
        cin >> v;
        if(v == "ENDOFINPUT")
        {
            break;
        }
        scanf("\n");
        getline(cin, s);
        transform(s.begin(), s.end(), s.begin(), ::toupper);
        int len = s.length() - 1, max = 0, a;
        char xb;
        for(int i = 0; i <= len; i++)
        {
            if(isalpha(s[i]))
            {
                mp[s[i]]++;
                if(mp[s[i]] >= max)
                {
                    max = mp[s[i]];
                    xb = s[i];
                }
            }
        }
        if(xb == 'E')
        {
            cout << s << endl;
        }
        else
        {
            if(xb > 'E')
            {
                a = xb - 'E';
            }
            else
            {
                a = 'E' - xb;
            }
for(int i = 0; i <= len; i++)
                {
                    if(isalpha(s[i]))
                    {
                        if(s[i] - a > 'Z' || s[i] - a < 'A')
                        {
                            for(int j = 1; j <= a; j++)
                            {
                                if(s[i] == 'A')
                                {
                                    s[i] = 'Z';
                                    j++;
                                }
                                if(j <= a)
                                {
                                    s[i]--;
                                }
                            }
                        }
                        else
                        {
                            s[i] -= a;
                        }
                    }
                }
            cout << s << endl;
        }
        cin >> b;
    }
    return 0;
}
```

那么说一下transform，其实transform功能很强大，不光引用于全部转换为大写或小写，string类型全部转成大写如下：

```cpp
string s = "kkksc03!!!";//作死
transform(s.begin(), s.end(), s.begin(), ::toupper);

现在, s = "KKKSC03";
```
由此看来，transform + toupper会将小写转大写，不是字母不转

转小写如下：

```cpp
string s = "KKK???";
transform(s.begin(), s.end(), s.begin(), ::tolower);

现在, s = "kkk???";
```

求赞和过

---

## 作者：SadLava (赞：4)

## 前言
这题好坑！（我好菜）
## 分析
本题考查凯撒密码。首先我们了解几个基本名词：**密文、明文、密钥**。
密文顾名思义就是**被加密过的文字**，明文指的是**原始信息**，密钥指的是**用来加密或是解密的信息**（现代复杂密码中，**一个密钥可能只能加密不能解密**，详见百度）。

了解了这个，我们看题中的示范：
```python
明文：I Need Soldiers
密文：K Pggf Uqnfkgtu
密钥：
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
```
我们可以看到，**第二行密钥中的K对应第一行中的I，P对应N，g对应e......u对应s**，按这个思路，密文就被解密成了**I Need Soldiers**。

“可我们没有密钥啊！”

看官们稍安勿躁，凯撒密码的致命缺陷就来自英语本身，众所周知，26个字母，在一句**长文章中**每个字母都将**出现很多次**。出于玄学原因，西方人酷爱**字母E**，大量含有e的词汇、短语被造出来，使得**E在一篇长文字中出现的次数是最多的**（**说明/提示**里的表其实就是在告诉我们e出现的几率高达12.68%位列第一）。

因此，我们求出所给句子中**出现最多的字母**，这个字母就有**大概率对应明文中的E**！

“只知道E对应啥有啥用？？？”

我们在这里**把字母表想象为一个环**，把凯撒密码的密钥想象成两个同心环（均按照相同的方向排列，遵循字母表顺序，约定内环为明文表外环为密文表），假设我们知道**E在密文中是J**，那么我们转动外环，**使外环上的J和内环上的E对齐**，这时整个密钥表也就出来了，

**为了方便表示**，我们将**密文最多字母**与**E**的差**约定为t**，这个值代表我们的**外环转动的格数**（内外环事先按A对A的方式对齐）

## 程序流程
PS：本题有一点特坑（本人有一点特菜），我看见了“**Caesar会不时更换t的值**”就误以为每个begin和end之间的t是不一样的t......其他坑点见代码注释。

程序流程总结之后如下：
$$ \text{读入全部数据}$$
$$ ↓$$
$$ \text{统计各字母出现的次数}$$
$$ ↓$$
$$ \text{找出出现最多的}$$
$$ ↓$$
$$ \text{算出t}$$
$$ ↓$$
$$ \text{根据t完成解密}$$

## AC代码

```cpp
#include<bits/stdc++.h>

using namespace std;
int t;
map<char,int> ma;
//计算t（偏移值）
int calcT(string s)
{
	long long maxv=-1,maxk=0;
    //下面的玄乎操作不用太纠结，用一个大小为26+的数组效果一样
	for(map<char, int>::iterator iter=ma.begin(); iter!=ma.end(); iter++) {
    	//标准的找最大元素操作
		if(iter->second>maxv) {
			maxv=iter->second;
			maxk=iter->first;
		}
	}
	return maxk-'E';//t，t是怎么算的关系到解密
}
//解密
string enc(string s,int t)
{
	for(int i=0; i<s.length(); i++) {
		if(s[i]>='A'&&s[i]<='Z') {//注意，别把标点解密了
			s[i]-=t;//如果上一个函数里是'E'-maxk，这里就得+=了
        	//模拟环状结构，注意不要+='Z'之类的，这么做会把字母变成......
			if(s[i]>'Z') s[i]-=26;
			if(s[i]<'A') s[i]+=26;
		}
	}
	return s;
}

int main()
{
	string text,be,en;
	vector<string> vs;
	while(1) {
		cin>>be;//读START
		cin.clear();//没啥用，吧
		if(be=="ENDOFINPUT") break;
     /*
     	下两行是创世巨坑
     	我们前面cin>>be后，be里是不会有'\n'的，因此缓冲区还存着1个换行！！！
     	getline只会读到换行！！！
     	我们第一个getline只能读到空串！！！
     	我们必须getline两次！！！
     */
		getline(cin,text);
		getline(cin,text);
      
		for(int i=0; i<text.length(); i++) {
			if(text[i]>='a'&&text[i]<='z') text[i]=toupper(text[i]);//范例输出是全大写，而且全大写方便统计，于是我就一脸懵逼地一遍过了
		}
		//统计字母
		for(int i=0; i<text.length(); i++) {
			if(text[i]>='A'&&text[i]<='Z') ma[text[i]]++;//注意到了吗？句中有标点！别把标点给统计了
		}
		vs.push_back(text);//坑点之前说过了，输入的全部数据的t是统一的，所以得先存起来，统计完再解密
		cin>>en;//读END
	}
	t=calcT(text);//找出出现最多的字母
	for(int i=0;i<vs.size();i++)
		cout<<enc(vs[i],t)<<'\n';//解密
	return 0;

}
```



---

## 作者：dinghongyu (赞：3)

### 这题的坑点在于：你并不知道$t$的值为多少   
### 所以我们需要先求出$t$的值，再来破译   
### 根据提示可知，一句话中字母“$e$”出现的次数是最多的，所以只需再头一句中求出出现次数最多的字母，便可求出“$t$”的值   
#### 代码如下：   
```cpp
#include <bits/stdc++.h>
using namespace std;
string s,e,w;
map < char , int > _;
int m,t;
char p = 'A';
int main()
{
    cin >> s;
    getline(cin,w);
    getline(cin,w);
    cin >> e;
    for (int i = 0;i < w.size();i++)
    {
        if (w[i] >= 'a' && w[i] <= 'z')
            w[i] -= 32;
        if (w[i] >= 'A' && w[i] <= 'Z')
            _[w[i]]++;
    }                    //求出现次数，这里开了个map数组
    for (char i = 'A';i <= 'Z';i++)
        if (_[i] > _[p])
            p = i;       //判断出现次数最多的
    t = 'E' - p;         //求t
    for (int i = 0;i < w.size();i++)
    {
        if (w[i] >= 'A' && w[i] <= 'Z')
        {
            if (w[i] + t > 'Z')
                cout << (char)(w[i] + t - 26);
            else if (w[i] + t < 'A')
                cout << (char)(w[i] + t + 26);
            else
                cout << (char)(w[i] + t);
        }
        else
            cout << w[i];
    }
    cout << "\n";
    while (cin >> s,getline(cin,w),getline(cin,w),cin >> e)
    {
        for (int i = 0;i < w.size();i++)
        {
        	if (w[i] >= 'a' && w[i] <= 'z')
        	    w[i] -= 32;
            if (w[i] >= 'A' && w[i] <= 'Z')
            {
                if (w[i] + t > 'Z')
                    cout << (char)(w[i] + t - 26);
                else if (w[i] + t < 'A')
                    cout << (char)(w[i] + t + 26);
                else
                    cout << (char)(w[i] + t);
            }
            else
                cout << w[i];
        }
        cout << "\n";
    }                           //边读边输
    return 0;
}
```

---

## 作者：lz2018 (赞：3)

这道题必须发一下题解，虽然效率不是很高~

#整体思路

1.

读入字符串，因为题目下方有提示，e的频率最高（当然出题人不会用不合此规则的数据），那么，我们把从正文第一句中找出频率最高的字母，把它认定为e加密而成的，求出加密的移动方向，大小。

2.

按照找出来的规律扩展至全文，输出。

注意：

在正文 第一句 中找出频率最高的字母

注意输入中的空格

以下是代码（很凌乱）
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int ss[50],ppp,k,f;
char m;
string s,c,sss;
int main(){
    while(getline(cin,s)){
    	sss=" ";
    	for(int i=0;i<s.size();i++){
    		if(s[i]>='a'&&s[i]<='z')s[i]-=32;
    		if(s[i]>='A'&&s[i]<='Z')sss+=s[i];
        }
    	if(sss==" ENDOFINPUT")return 0;
    	if(sss==" START")break;
    }
    while(1){
        getline(cin,c);
        sss=" ";
        for(int j=0;j<c.size();j++){
        	if(c[j]>='a'&&c[j]<='z')c[j]-=32;
        	if(c[j]>='A'&&c[j]<='Z')sss+=c[j];
        }
        while(sss!=" END"){
            if(ppp==0){
                f=0;
                for(int j=0;j<c.size();j++)if(c[j]>='A'&&c[j]<='Z')ss[c[j]-'0']++;//求频率最高 
                    for(int j=17;j<=42;j++)if(ss[j]>f){
                    f=ss[j];m=j+'0';
                    }
                    k=m-0-'E';
                    f=0;//求移动幅度 
                ppp=1;
            
            }
            if(k==0);//不变 
            else{//变
                if(k>0)f=1;
                if(f==0){//向右 
                    k=-k;
                    for(int j=0;j<c.size();j++){
                        if(c[j]>'Z'||c[j]<'A')continue;
                        int t='Z'-c[j];
                        if(t<k){
                            t=k-t;
                            c[j]='A'+t-1;
                        }
                        else c[j]+=k;
                    } 
                }
                
                else{//向左 
                    for(int j=0;j<c.size();j++){
                        if(c[j]>'Z'||c[j]<'A')continue;
                        int t=c[j]-'A';
                        if(k>t){
                            t=k-t;
                            c[j]='Z'-t+1;
                        }
                        else c[j]-=k;
                    } 
                } 
            }
            cout<<c<<endl;
            getline(cin,c);
            sss=" ";
            for(int j=0;j<c.size();j++){
            	if(c[j]>='a'&&c[j]<='z')c[j]-=32;
            	if(c[j]>='A'&&c[j]<='Z')sss+=c[j];
            }
        } 
        while(getline(cin,s)){
    		sss=" ";
        	for(int i=0;i<s.size();i++){
        		if(s[i]>='a'&&s[i]<='z')s[i]-=32;
        		if(s[i]>='A'&&s[i]<='Z')sss+=s[i];
            }
        	if(sss==" ENDOFINPUT")return 0;
        	if(sss==" START")break;
        }
    }
    return 0;
}
```
过呀

---

## 作者：反比例函数 (赞：2)

这是一道非常玄学的题，有一定思维难度，同时坑点极多，本蒟蒻提交了21次~~几乎心态爆炸~~。

看到题面，先感觉一头雾水，心想不知道密码这题咋做？往下看看，发现说明/提示的第二条提供了一大突破口。

说明的第二条是指英语中每个字母出现的频率，e最多，因此我们可以考虑将第一句话每个字母的出现次数统计一下，将最多的翻成e，求出密码即可破译。

注意：
1. 大小写转换
2. 密码按照第一句话算出，以后沿用下去，不是每句话换一个密码
3. getline读入一行时要先吃掉前面的回车，否则会出玄学错。

Code:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>//使用string类型添加<string>头文件
#include<algorithm>//使用sort添加<algorithm>头文件
#include<cctype>//使用islower添加<cctype>头文件
using namespace std;
class rk
{   public:
    int num;
    char data;}t[128];//对字母数量排序用
int main()
{
    string s,b,e;
    int i,f,cnt=0;
    while(cin>>b,getline(cin,s),getline(cin,s),cin>>e)
    //两个getline，第一个吃掉换行，第二个读入真正的s
    //b和e是用来存START和END的
    {   cnt++;//计数器加一
        memset(t,0,sizeof t);//每次计算前要把统计字母数量的t清空
        int len=s.size();
        for(i=0;i<len;i++)
          if(isalpha(s[i])) 
          { if(islower(s[i])) s[i]=toupper(s[i]);
            t[(int)s[i]].num++;t[(int)s[i]].data=s[i];}
        sort(t,t+128,[](const rk &a,const rk &b)
        {   if(a.num==b.num) return a.data<b.data;
            return a.num>b.num;});
        //排序（此处用了一个lambda表达式，但这属于C++11语法，建议乖乖写cmp函数）
        if(cnt==1) f=t[0].data-'E';//只有第一次算密码，以后用下去，不要再算
        for(i=0;i<len;i++)
        {   if(isalpha(s[i]))
            {   s[i]-=f;//把密码减去
                if(s[i]>'Z') s[i]-=26;
                if(s[i]<'A') s[i]+=26;}}
        //两种特殊情况，一是减去之后比A小了，加回来；二是减去之后反而比Z还大，减回去
        cout<<s<<endl;}}//输出，完事
```

---

## 作者：taophee (赞：2)

想法：

这道题看似很变态，其实做上去并不困难，充分分析一下题目，就可以发现可以查找出现频率最高的那个字母，这个字母为e，具体证明可以去Matrix67网站上看....然后就可以推导出t，接着整个文章的原文也就都出来了，接着就是输出就ok了

[ color=red]注：所有的字母最后均转成大写，我就是在这里被坑了好多次....[/color ]

程序：

```delphi

var
a:array [1..55000000] of char;
b:array [1..26] of longint;
i,j,l,k,sum,max,max1,t:longint;
s:ansistring;

begin
  sum:=0;
  while not eof do
   begin
    readln(s);
    if s='START' then continue;
    if s='END' then continue;
    if s='ENDOFINPUT' then break;
    l:=length(s);
    for i:=1 to l do
     begin
      inc(sum);
      a[sum]:=s[i];
      if(a[sum] in ['a'..'z'])or(a[sum] in ['A'..'Z']) then
      inc(b[ord(upcase(a[sum]))-64]);
    end;
    sum:=sum+1;
    a[sum]:='|';
  end;
  max:=0;
  for i:=1 to 26 do if(b[i]>max) then
   begin
    max:=b[i];
    max1:=i;
  end;
  t:=max1+96-ord('e');
  for i:=1 to sum do
   begin
    if a[i]='|' then begin writeln;continue;end;
    if(a[i] in ['a'..'z']) then
      write(chr((ord(a[i])-97-t+26) mod 26+ord('A')))
    else
     begin
      if(a[i] in ['A'..'Z']) then
        write(chr((ord(a[i])-65-t+26) mod 26+ord('A')))
      else write(a[i]);
    end;
  end;
end.

```

---

## 作者：Catch_22 (赞：1)

由常识，一堆单词中e出现的概率最大、

话说注释里也提示了、、

原来Matrix67神出过一道“Matrix67的情书”，

只不过Matrix67比较文艺，样例用的“I Love You”

数据也更加爽(10KB~50KB)，不会出现某些问题频率不符合概率的问题

```delphi
Var
  st:AnsiSTring;
  Iris:longint;
  xx,i:longint;
  Num:Array['A'..'Z'] of longint;
PRocedure Find();//找出现频率最大的，那个就是e移过来的
  Var
    Tt,i:longint;
    xx:Char;
  Begin
    Tt:=0;
    For i:=1 to Length(st) do
      Begin
        if st[i] in ['A'..'Z'] Then
          Begin
            Inc(Num[st[i]]);
            if (Num[st[i]]>Tt) Or ((Num[st[i]]=Tt) And (st[i]<xx)) Then
              Begin
                xx:=st[i];
                Tt:=Num[xx];
             End;
//这里这个or非常奇怪，可能是我程序的问题，题目中没有给出如果两个字母出现频率相同的话，取哪一个作为e，这就非常的有问题了、、由数据改成ASCII小的字母优先就对了
          End;
      End;
    Iris:=Ord(xx);
  End;
Begin
  st:='Iris';
  Fillchar(Num,Sizeof(Num),0);
  While st<>'ENDOFINPUT' do
    Begin
      Readln(st);
      st:=Upcase(st);
      if st='START' Then Readln(st); st:=Upcase(st);
      if st='END' Then Continue;
      if st='ENDOFINPUT' Then Halt;
      Find();
      Iris:=Ord('E')-Iris;//下面处理就跟去年那个那什么密码一样了、
      For i:=1 to Length(st) do
        Begin
          if st[i] in ['A'..'Z'] Then
            Begin
              xx:=Ord(st[i])+Iris;
              if xx>90 Then xx:=xx-26
              Else if xx<65 Then xx:=xx+26;
              Write(Chr(xx));
            End
          Else Write(st[i]);
        End;
      Writeln;
      While st<>'END' do
        Begin
          Readln(st);
          if st='END' Then Break;
          Begin
            For i:=1 to Length(st) do
              if st[i] in ['A'..'Z'] Then
                Begin
                  xx:=Ord(st[i])+Iris;
                  if xx>90 Then xx:=xx-26
                  Else if xx<65 Then xx:=xx+26;
                  Write(Chr(xx));
                End
              Else Write(st[i]);
            End;
          Writeln;
        End;
    End;
End.

```

---


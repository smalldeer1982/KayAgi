# 电话号码

## 题目描述

一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用 `Three Tens` 来记忆电话 `3-10-10-10`。

电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：`888-1200`）。电话号码可以用字母来表示。以下是字母与数字的对应：

 - `A`，`B` 和 `C` 对应 `2`；
 - `D`，`E` 和 `F` 对应 `3`；
 - `G`，`H` 和 `I` 对应 `4`；
 - `J`，`K` 和 `L` 对应 `5`；
 - `M`，`N` 和 `O` 对应 `6`；
 - `P`，`R` 和 `S` 对应 `7`；
 - `T`，`U` 和 `V` 对应 `8`；
 - `W`，`X` 和 `Y` 对应 `9`。

你会发现其中没有字母 `Q` 和 `Z`。电话中的连字号是可以忽略。例如 `TUT-GLOP` 的标准形式是 `888-4567`，`310-GINO` 的标准形式是 `310-4466`，`3-10-10-10` 的标准形式是 `310-1010`。

如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。

现在有一本电话簿，请从中找出哪些电话号码是重复的。


## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$N\le20$。

对于 $50\%$ 的数据，$N\le10000$。

对于 $100\%$ 的数据，$N\le10^5$。


## 样例 #1

### 输入

```
3
TUT-GLOP
3-10-10-10
310-1010
```

### 输出

```
310-1010 2```

# 题解

## 作者：tututu (赞：20)

关于此题我做时的难度，我无话可说.... 提高+/省选-

还有楼下的题解，我认为此题通过率如此低主要原因是楼下的题解。

同楼下，用了cin，用了string，不过还是卡的过去。

读入字符串，将每个'-'删去，字母替换为数字，保存到一个字符串数组。每个字符串理论上长度都为7.

最关键的。排序sort，然后用O(7n)枚举一遍找重复的就行了。

根本不存在细节处理困难。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int f[25]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9};
int n,t;
string s[100002],cnt;
bool fa;
int main(){
  cin>>n;
  for(int i=1;i<=n;i++){
    cin>>cnt;
    for(int j=0;j<cnt.length();j++)
      if(cnt[j]<='9'&&cnt[j]>='0') s[i]+=cnt[j];
      else if(cnt[j]>='A'&&cnt[j]<='Z') s[i]+='0'+f[cnt[j]-'A'];
  }
  sort(s+1,s+n+1);
  for(int i=1;i<=n+1;i++)
    if(s[i]!=s[i-1]){
      if(t>1) cout<<s[i-1].substr(0,3)<<'-'<<s[i-1].substr(3,4)<<' '<<t<<endl,fa=true;
      t=1;
    } else t++;
  if(!fa) cout<<"No duplicates.";
  return 0;
}
```

---

## 作者：Drifterming (赞：5)

/\*用一个char类数组把所有的字母表示的数字存起来，0和1题目中没说，但也要表示。

一个<string,int>类型的map表示a这个字符串出现的次数。

把每个读入的字符串转化为标准形式存起来，如果有出现次数超过两次的，存起来，答案数++。

最后将答案按字典序排序输出。\*/






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
int n,cnt,now,pos,sum[100005];
string s,temp,tot[100005];
char excel[100];
map<string,int> a;
struct Ans
{
    int cs;
    string chuan;
}ans[100005];
void init()        //初始化函数 
{
    excel['0']='0';excel['1']='1';
    excel['A']=excel['B']=excel['C']=excel['2']='2';
    excel['D']=excel['E']=excel['F']=excel['3']='3';
    excel['G']=excel['H']=excel['I']=excel['4']='4';
    excel['J']=excel['K']=excel['L']=excel['5']='5';
    excel['M']=excel['N']=excel['O']=excel['6']='6';
    excel['P']=excel['R']=excel['S']=excel['7']='7';
    excel['T']=excel['U']=excel['V']=excel['8']='8';
    excel['W']=excel['X']=excel['Y']=excel['9']='9';
}
bool cmp(Ans a,Ans b)
{
    return a.chuan+b.chuan<b.chuan+a.chuan;
}
int main()
{
    init();        //千万千万别忘记调用 
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        temp.clear();pos=0;        //将temp清空，pos归零 
        for(int j=0;j<s.length();j++)
        {
            if(s[j]!='-')    //转化为数字 
            {
                temp+=excel[s[j]];
                pos++;
            }
            if(pos==3) temp+='-',pos=-999999999;    //到了该加'-'的地方，加上'-',同时将pos设为负值，防止重复添加 
        }
        if(!a[temp]) tot[++cnt]=temp;    //如果这个字符串没出现过，将这个字符串加入到已有的字符串中 
        a[temp]++;    //该字符串出现的次数++ 
    }
    for(int i=1;i<=cnt;i++)        //找哪个字符串是重复的 
    {
        if(a[tot[i]]>1)
        {
            ans[++now].chuan=tot[i];    //存答案 
            ans[now].cs=a[tot[i]];
        }
    }
    if(!now)    //没有重复的 
    {
        printf("No duplicates.");
        return 0;
    }
    sort(ans+1,ans+now+1,cmp);        //按字典序排列 
    for(int i=1;i<=now;i++)
    {
        cout<<ans[i].chuan<<' ';
        printf("%d\n",ans[i].cs);
    }
    return 0;
}
```

---

## 作者：飞了的心 (赞：4)

一个蒟蒻的题解


先看题划重点

每个电话号码可以转化为7位数字

7位果断用7维数组~~其实是字典树懒得打~~

字母处理的话,果断静态数组但注意**Q和Z不需要处理**

~~第一眼看上去是Y和Z的我~~

数据范围挺大,所以抛弃cin,转向scanf和读入优化


一个字符一个字符地读入处理,处理出来的7位电话号码保存在r数组中

再累加

输出时暴力枚举7位输出,注意用flag标记没有重复的情况


测试基本保持250ms以下时间过

以下代码

```cpp
#include <bits/stdc++.h>
int a[10][10][10][10][10][10][10];
int size=0,n;
const int p[27]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,0,7,7,8,8,8,9,9,9,0}; //字母转数字的静态数组
int main(){
    scanf("%d",&n);char l;
    for (int g=1;g<=n;g++){
        int r[7];
        for (int pose=0;pose<7;){//读入处理 r存放当前号码    读入n以及一行电话号码后的回车符没有影响
            l=getchar();
            if ('0'<=l&&'9'>=l)
                r[pose++]=l-'0';
            if ('A'<=l&&'Y'>=l)
                r[pose++]=p[l-'A'];
        }
        ++a[r[0]][r[1]][r[2]][r[3]][r[4]][r[5]][r[6]];  //给a累加
    }
    bool flag=1;                                               //没有重复的标志
    for (int a1=0;a1<=9;a1++)
    for (int a2=0;a2<=9;a2++)
    for (int a3=0;a3<=9;a3++)
    for (int a4=0;a4<=9;a4++)
    for (int a5=0;a5<=9;a5++)
    for (int a6=0;a6<=9;a6++)
    for (int a7=0;a7<=9;a7++)
    if (a[a1][a2][a3][a4][a5][a6][a7]>=2){ //暴力枚举输出
        printf("%d%d%d-%d%d%d%d %d\n",a1,a2,a3,a4,a5,a6,a7,a[a1][a2][a3][a4][a5][a6][a7]);
        flag=0;
    }
    if (flag)//没有重复
        printf("No duplicates.");
}
```

---

## 作者：Hamer_sans (赞：2)

# P2037的题解

## 题目大意

给出 $n$ 个字符串，然后再给出一个类似于 Hash 表的对应关系，再将这些字符串转化成标准形式，如 $\texttt{xxx-xxxx}$，再统计出现了超过 $1$ 次的字符串标准形式，并按字典序排序输出字符串本身和字符串出现的次数。

## 分析与思路

先观察数据范围，$n\le10^{5}$，所以大概要用 $O(n)$ 的复杂度，所以提供两种思路:

1.用 `STL` 中自带的容器 `map` 来实现，每输入一个字符串，就用一个 `work` 函数进行处理成标准模式，再用 `map` 进行统计次数，因为 `map` 自带排序就不用再考虑字典序了，最后用迭代器进行遍历，次数超过一的就输出。再加一个标记，如果没有输出，输出 No duplicates.。

2.用模拟的思想，将这个字符串转换成数，因为最大就只有七位，就可以用类似于桶的方式存，再排一次序，最后输出就行了，但是有一点需要考虑的，就是前置零和标准形式的转换，我们到最后时可以统计这有多少位，少了多少位，就补多少个零，再在第三位的地方加一个连字符。同样加一个标记进行判断是否输出 No duplicates.。

## 代码

### 思路一：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n;
map<string,int> mp;
char Hash(char x){
	if(x=='A' or x=='B' or x=='C') return '2';
	if(x=='D' or x=='E' or x=='F') return '3';
	if(x=='G' or x=='H' or x=='I') return '4';
	if(x=='J' or x=='K' or x=='L') return '5';
	if(x=='M' or x=='N' or x=='O') return '6';
	if(x=='P' or x=='R' or x=='S') return '7';
	if(x=='T' or x=='U' or x=='V') return '8';
	if(x=='W' or x=='X' or x=='Y') return '9';
}
string work(string x){
	int len=0;
	string a="";
	bool flag=0;
	for(register int j=0;j<x.size();++j){
		if(len==8) break;
		if(flag==0 and len==3){
			a+='-';
			++len;
		}
		if(!isdigit(x[j]) and x[j]!='-'){
			a+=Hash(x[j]);
			++len;
		}
		if(isdigit(x[j])){
			a+=x[j];
			++len;
		}
	}
	return a;
}
int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;++i){
		string x;
		cin>>x;
		string a=work(x);
		mp[a]++;
	}
	map<string,int>::iterator it;
	bool flag=0;
	for(it=mp.begin();it!=mp.end();++it){
		if(it->second>1){
			cout<<it->first<<' '<<it->second<<endl;
			flag=1;
		}
	} 
	if(flag==0) puts("No duplicates.");
	return 0;
}
```

### 思路二：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5;
int n;
bool flagg;
bool vis[N],ok[N];
int ans[N];
vector<int> v;
char Hash(char x){
	if(x=='A' or x=='B' or x=='C') return '2';
	if(x=='D' or x=='E' or x=='F') return '3';
	if(x=='G' or x=='H' or x=='I') return '4';
	if(x=='J' or x=='K' or x=='L') return '5';
	if(x=='M' or x=='N' or x=='O') return '6';
	if(x=='P' or x=='R' or x=='S') return '7';
	if(x=='T' or x=='U' or x=='V') return '8';
	if(x=='W' or x=='X' or x=='Y') return '9';
}
int zhuan(string x){
	int sum=0;
	for(register int i=0;i<x.size();++i){
		if(x[i]=='-') continue;
		sum=sum*10+x[i]-'0';
	}
	return sum;
}
int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;++i){
		string x;
		cin>>x;
		string a="";
		int len=0;
		bool flag=0;
		for(register int j=0;j<x.size();++j){
			if(len==8) break;
			if(flag==0 and len==3){
				a+='-';
				++len;
			}
			if(!isdigit(x[j]) and x[j]!='-'){
				a+=Hash(x[j]);
				++len;
			}
			if(isdigit(x[j])){
				a+=x[j];
				++len;
			}
		}
		int p=zhuan(a);
		if(vis[p]){
			flagg=1;
			ans[p]++;
			if(ok[p]) continue;
			ok[p]=1;
			v.push_back(p);
			continue;
		}
		vis[p]=1;
		ans[p]++;
	}
	if(!flagg) puts("No duplicates.");
	else{
		sort(v.begin(),v.end());
		for(register int i=0;i<v.size();++i){
			int x=v[i];
			int cnt=0;
			string p="";
			while(x){
				p+=(x%10)+'0';
				x/=10;
				++cnt;
			}
			int u=7-cnt;
			for(register int j=1;j<=u;++j) p=p+'0';
			for(register int j=p.size()-1;j>=0;--j){
				putchar(p[j]);
				if(j==4) putchar('-');
			}
			putchar(' ');
			printf("%d",ans[v[i]]);
			puts("");
		}
	} 
	return 0;
}
```


---

## 作者：Loser_King (赞：2)

### Part 0 前言

一道完全的模拟题。

具有典型模拟题显然的特点：不需要用到什么算法，但是细节超级多。

## Part 1 题意

> 给定 $n$ 个电话号码，由`_,A~P,R~Y,0~9`组成。字母和数字之间存在映射关系。忽略下划线并把字母映射成数字后相等的两个电话号码被看成是等价的。求所有重复的电话号码及重复次数。

## Part 2 代码

（由于这是道模拟题，所以先放代码，然后再一一讲述细节）

Time : 668 ms Memory : 1.00 MB

应该是代码最短的几份代码之一了，而且也在最优解第四页。

```c++
#include<bits/stdc++.h>
using namespace std;
int n,cnt=1,flg,a[233333];
//cnt:存储当前号码出现次数
//flg:判断是否有解
//a[]:存储转换成七位数字的号码
map<int,int>m;
int main(){
	m[48]=0;m[49]=1;//1
	m[65]=m[66]=m[67]=m[50]=2;
	m[68]=m[69]=m[70]=m[51]=3;
	m[71]=m[72]=m[73]=m[52]=4;
	m[74]=m[75]=m[76]=m[53]=5;
	m[77]=m[78]=m[79]=m[54]=6;
	m[80]=m[82]=m[83]=m[55]=7;
	m[84]=m[85]=m[86]=m[56]=8;
	m[87]=m[88]=m[89]=m[57]=9;//2
    //以上为预处理映射
	cin>>n;
	for(int i=0;i<n;i++){
		string s;cin>>s;
		for(int j=0;j<s.length();j++)
		    if(s[j]!='-')a[i]=a[i]*10+m[s[j]];
            //把字符串转换成七位数字
	}
	sort(a,a+n);
	for(int i=1;i<=n;i++)
		if(a[i]!=a[i-1]){
			if(cnt>1)printf("%03d-%04d %d\n",a[i-1]/10000,a[i-1]%10000,cnt),cnt=1,flg=1;//3
		}else cnt++;//统计重复并输出
	if(!flg)puts("No duplicates.");//4
    //判断无解
}
```

## Part 3 做法

主要做法是使用 `std::map` 来存储映射信息，然后就使用 `int` 来存储转换后八位的数字，最后排序，判重，判断是否无解。

但是我写代码时遇到了 4 个小细节，卡了我好久。

1. 未判0,1

   虽然题面里没有给出数字0和1的映射关系，但是还是要把`'0'`和`'1'`给判进去。

2. ASCII码和数字搞混

   虽然开的是 `std::map<int,int>` 但是带进去的`s[j]`是ASCII码！

3. 输出

   可以使用 `printf` 的骚操作：`%03d`表示输出限长为3位，不足用`0`补足。

   注意如果这样写的话输出的是 `a[i-1]`。

4. 特判

   测试点`#9`是无解的情况，注意要特判。而且，那个句号是要输出的！



---

## 作者：Steven__Chen (赞：2)

# 蒟蒻的题解
好吧，废话不多说，直接进入正题。
------------
#### 我的思路大概是这样的:

1. 对这些原始电话号码中的每个字母所对应的数进行一波预处理

   代码如下：
```
int b[] = { 2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,-1,7,7,8,8,8,9,9,9 };
```
2. 读入n后继续读入字符串，并对其进行处理。

	代码如下：
```
cin >> n;//读入n
for (int i = 0; i <= n - 1; i++)
{
	cin >> c;//读入字符串
	int len = c.length();//获取字符串长度
	for (int j = 0; j <= len - 1; j++)//遍历字符串
	{
		if (c[j] <= 'Z' && c[j] >= 'A')//判断是不是英文字母
		{
			a[i] += b[c[j] - 'A'] + '0';//如果是，根据之前预处理好的数组对英文字母进行转换，并将其添加到新的字符串中
			if (cnt == 2)//如果是第三个被添加到字符串中的数组，还要添加一个连字符到新的字符串中
				a[i] += '-';
			cnt++;//统计个数
		}
		if (c[j] >= '0' && c[j] <= '9')//判断是否是数字
		{
			a[i] += c[j];//直接添加到新的字符串中
			if (cnt == 2)//同上
				a[i] += '-';
			cnt++;//同上
		}
	}
	cnt = 0;//重置计数器
}
```
3. 对处理好的字符串数组进行排序
	
   代码如下：
```
sort(a, a + n);//sort排序
```	
4. 进行最终处理，统计重复个数
	
   代码如下：
```
d = a[0];//初始化
cnt = 1;//初始化
for (int i = 1; i <= n; i++)//遍历排序后的字符串组，这里循环到n的原因是：如果只循环到n-1，那么第n-1个电话号码就不会被处理，最终输出的结果也就不对了。再多嘴一句，下面的代码利用了字符串组的有序性。
{
	if (a[i] == d)//如果这一个电话号码和上一个电话号码相同，计数器加一（这里的计数器代表重复个数）
		cnt++;
	else//如果这一个电话号码与上一个电话号码不同
	{
		if (cnt >= 2)//如果上一个电话号码的计数器大于等于2，也就是代表有重复
		{
			cout << d << " " << cnt << endl;//直接输出上一个电话号码和它的计数器
			flag = 1;//标志着有重复的电话号码
		}
		d = a[i];//将自己作为上一个电话号码，进入下一次循环
		cnt = 1;//计数器置为1（目前这个电话号码还没有重复）
	}
}
```
5. 判断n个电话号码中有没有重复，如果没有，输出  “ No duplicates.”

	代码如下：
  ```
if (!flag)//判断flag是否为0，如果是输出"No duplicates."
		cout << "No duplicates.";
```
# 到这里，我们的程序就结束了

## 说实话，我自认为我代码的效率还是可以的。
------------
## 最后，把完整的代码放在这里
```
#include<bits/stdc++.h>
using namespace std;
int n, cnt, flag;
string a[100001], c, d;
int b[] = { 2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,-1,7,7,8,8,8,9,9,9 };
int main()
{
	cin >> n;
	for (int i = 0; i <= n - 1; i++)
	{
		cin >> c;
		int len = c.length();
		for (int j = 0; j <= len - 1; j++)
		{
			if (c[j] <= 'Z' && c[j] >= 'A')
			{
				a[i] += b[c[j] - 'A'] + '0';
				if (cnt == 2)
					a[i] += '-';
				cnt++;
			}
			if (c[j] >= '0' && c[j] <= '9')
			{
				a[i] += c[j];
				if (cnt == 2)
					a[i] += '-';
				cnt++;
			}
		}
		cnt = 0;
	}
	sort(a, a + n);
	d = a[0];
	cnt = 1;
	for (int i = 1; i <= n; i++)
	{
		if (a[i] == d)
			cnt++;
		else
		{
			if (cnt >= 2)
			{
				cout << d << " " << cnt << endl;
				flag = 1;
			}
			d = a[i];
			cnt = 1;
		}
	}
	if (!flag)
		cout << "No duplicates.";
	return 0;
}
```



---

## 作者：_Ayanami_ (赞：2)

直接开了一个10000000的数组直接对应每一个电话号码

然而碰上前导零的时候貌似出了点问题

不过没有关系

emmmm（思考ing）

![](https://cdn.luogu.com.cn/upload/image_hosting/b8gndf46.png?x-oss-process=image/resize,m_lfit,h_170,w_225)（恍然大悟.jpg）

只要给它最高位放个一那不就没有前导零了吗（滑稽）

于是就把数组开到了20000000
AC

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
//对应数字 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
int z[26]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,0,7,7,8,8,8,9,9,9,0};
int n,l,m=0,c[20000000]={0},ss;
string s;
bool QWQ;
void write(int v)
{
	int g[10];
	for(int i=0;i<7;i++)
	{
		g[i]=v%10;//一位一位截下来
		v/=10;
	}
	for(int i=6;i>=0;i--)
	{
		cout<<g[i];//从高位开始输出
		if(i==4)
		{
			cout<<"-";//标准形式
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		ss=0;
		cin>>s;
		l=s.length();
		for(int j=0;j<l;j++)
		{
			if(s[j]=='-')
			{
				j++;
			}
			if(s[j]>='0'&&s[j]<='9')
			{
				ss=ss*10+s[j]-'0';//存下号码
			}
			else if(s[j]>='A'&&s[j]<='Z')
			{
				ss=ss*10+z[s[j]-'A'];//同上
			}
		}
		c[ss+10000000]++;//最前面放个一
	}
	for(int i=10000000;i<=19999999;i++)//循环每一个号码
	{
		if(c[i]>1)
		{
			QWQ=1;
			write(i);//输出号码
			cout<<" "<<c[i]<<endl;//输出重复次数
		}
	}
	if(!QWQ)//没有重复
	{
		cout<<"No duplicates.";
	}
}
```


---

## 作者：EuphoricStar (赞：1)

此题可以用 STL map 来做。

我的思路：

首先将每个字母对应的数字存入数组 $cmap$ 中。

接下来建立一个 map，存放每个电话号码出现的次数。

之后读入 $n$ 个电话号码，将每个电话号码转化为标准形式，并将该电话号码出现次数 $+1$。

之后遍历 map，如果 `it->second` 大于 $1$ 说明该电话号码出现过不止一次，打印，并将 $flag$ 标记设为 $1$。

最后 check 一下 $flag$，$flag$ 为 $0$ 就代表没有出现过重复的电话号码。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
char cmap[128];
map<string, int> phone;
bool flag;

void print(string s)
{
    for (int i = 0; i < s.size(); ++i)
    {
        if (i == 3) cout << '-';
        cout << s[i];
    }
}

int main()
{
    ios::sync_with_stdio(0);
    for (char c = '0'; c <= '9'; ++c) cmap[c] = c;
    cmap['A'] = cmap['B'] = cmap['C'] = '2';
    cmap['D'] = cmap['E'] = cmap['F'] = '3';
    cmap['G'] = cmap['H'] = cmap['I'] = '4';
    cmap['J'] = cmap['K'] = cmap['L'] = '5';
    cmap['M'] = cmap['N'] = cmap['O'] = '6';
    cmap['P'] = cmap['R'] = cmap['S'] = '7';
    cmap['T'] = cmap['U'] = cmap['V'] = '8';
    cmap['W'] = cmap['X'] = cmap['Y'] = '9';
    cin >> n;
    for (int i = 0; i < n; ++i)
    {
        string num, newnum = "";
        cin >> num;
        for (int i = 0; i < num.size(); ++i)
            if (num[i] != '-') newnum += cmap[num[i]];
        ++phone[newnum];
    }
    for (map<string, int>::iterator it = phone.begin(); it != phone.end(); ++it)
    {
        if (it->second > 1)
        {
            print(it->first);
            cout << ' ' << it->second << '\n';
            flag = 1;
        }
    }
    if (!flag) cout << "No duplicates.\n";
    return 0;
}
```


---

## 作者：MC_Launcher (赞：1)

### 本蒟蒻发一弹题解

本蒟蒻~~在WA和RE了10次后~~终于通过了这道题


------------

### 正文

这题的精髓在于如何转换，其他dalao的转换方法太高级，在此我就奉上本蒟蒻的代码，贡萌新查看，在此的代码就不坑大家了，希望各位自觉

```cpp
#include<bits/stdc++.h>
using namespace std;
int d[10000001];
int main()
{
	int n,b,flag=0,dd;
	cin>>n;
	string a;
	for(int j=1;j<=n;j++)
	{
		cin>>a;
		b=0;
		for(int i=0;i<a.length();i++)//转换
		{
			if(a[i]=='-')continue;
			else
			{
				if(a[i]>='A'&&a[i]<='Z')//字符串转换
				{
					if(a[i]=='A'||a[i]=='B'||a[i]=='C')
					{
						b*=10;
						b+=2;
					}
					if(a[i]=='D'||a[i]=='E'||a[i]=='F')
					{
						b*=10;
						b+=3;
					}
					if(a[i]=='G'||a[i]=='H'||a[i]=='I')
					{
						b*=10;
						b+=4;
					}
					if(a[i]=='J'||a[i]=='K'||a[i]=='L')
					{
						b*=10;
						b+=5;
					}
					if(a[i]=='M'||a[i]=='N'||a[i]=='O')
					{
						b*=10;
						b+=6;
					}
					if(a[i]=='P'||a[i]=='S'||a[i]=='R')
					{
						b*=10;
						b+=7;
					}
					if(a[i]=='V'||a[i]=='T'||a[i]=='U')
					{
						b*=10;
						b+=8;
					}
					if(a[i]=='X'||a[i]=='W'||a[i]=='Y')
					{
						b*=10;
						b+=9;
					}
				}
				else//数字转换
				{
					b*=10;
					b+=(a[i]-'0');
				}
			}
		}
		d[b]++;//将此电话号码标记
	}
	for(int i=0;i<=10000000;i++)
	{
		if(d[i]>1)//标记多遍就flag倒下并输出
		{
			printf("%03d",i/10000);//补0必须滴，因为我是用int储存的
			cout<<"-";
			printf("%04d",i%10000);
			cout<<" "<<d[i]<<endl;
			flag=1;
		}
	}
	if(flag==0)cout<<"No duplicates.";//否则输出未重复
}
```

拒绝抄袭，从你我做起


---

## 作者：Windowsredstone (赞：1)

好像大佬们都要么是7维数组或者超大string，~~我没用，赶紧水一发~~

~~但是也开了一个30几MB的数组~~

另外对于输出，大佬们都是

```c
printf("%d%d%d-%d%d%d%d %d\n",a1,a2,a3,a4,a5,a6,a7,a[a1][a2][a3][a4][a5][a6][a7]);
```
或者
```cpp
cout<<s[i-1].substr(0,3)<<'-'<<s[i-1].substr(3,4)<<' '<<t<<endl;
```
~~摘自各位大佬的题解~~

我实在太懒，就直接用了`printf`自带的`%03`

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
int z[26]= {2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
//		    a b c d e f g h i j k l m n o p q r s t u v w x y z
int tql[10000010]= {};
int main()
{
	int n,i,j,len,top,ioi;
	cin>>n;
	for(i=0; i<n; i++)
	{
		char tmp[9999];
		cin>>tmp;
		ioi=0;
		for(len=strlen(tmp),j=top=0; j<len; j++)
		{
			if(tmp[j]=='-')continue;
			ioi*=10;
			if(isalpha(tmp[j]))ioi+=z[tmp[j]-'A'];
			else ioi+=tmp[j]-'0';
		}
		tql[ioi]++;
//		cout<<tmp<<endl;
	}
	bool ak=0;
	for(i=0;i<10000000;i++)
		if(tql[i]>1)
		{
			printf("%03d-%04d %d\n",i/10000,i%10000,tql[i]);
			ak=1;
		}
	if(!ak)
		printf("No duplicates.\n");
	return 0;
}

```


---

## 作者：Deny_小田 (赞：1)

小田来说说做这道题的心路历程吧（惯用前缀舍弃）

POJ1002 原题。。。

我已无语。

当时我就是花了一周的时间AC的。

放在洛谷上\*bong沙卡拉卡\*40分，其它点全炸。

额。。又得从头开始了。


结果看了不到半分钟，立马想出第一个剪枝。。。

bong 80分 bong 90分。最终勉勉强强AC，我对这题并不是很满意。



<hr>
好了，立马切入正题。


简单（你都被折磨成这个样还叫简单？？？）的模拟题，需要<b>特别</b>注意细节（保证这句话很中肯。。。）因此被困了60，20,10……分。

我的思路是，先把所有的号码转化成规则的，且不加“-”的字符数字串，然后比较，如果有2个（及以上）的相同，存入结构体数组，下标+1，比较完之后，存入完毕之后，把字符串加上“-”，然后输出。


按理说这个思路说起来挺简单的，但实现起来很困难。

首先是读入问题。。。当发现自己写错了东西时恨不得扇自己两巴掌。。

后来是如果转化成规则字符数字串？请注意：Q和Z 没有，因此浪费了大量的时间！！！发现时同上。

恩，我刚开始的思路确实容易超时，string本来就慢，加上cin的读入问题，再加上循环写的冗长，不超时天理难容。。。T\_T

然后就是没有技术含量的输出。。



由于小田因为此题劳累过度营养不良，去治病去了，代码部分略去╮(╯▽╰)╭


---

## 作者：Nemonade (赞：0)

~~一道练习使用`STL`的好题~~

题目大意：要求把字符串转换成标准格式并且计算重复。
。

“转换”部分很明显，我们可以用一个数组 $as$ 记录字母与数字对应关系：

```cpp
inline void __init__(){
	as['A']=as['B']=as['C']=2;
	as['D']=as['E']=as['F']=3;
	as['G']=as['H']=as['I']=4;
	as['J']=as['K']=as['L']=5;
	as['M']=as['N']=as['O']=6;
	as['P']=as['R']=as['S']=7;
	as['T']=as['U']=as['V']=8;
	as['W']=as['X']=as['Y']=9;
	return;
}
```

然后按照题意模拟就可以：

```cpp
string t="";
int sum=0;
for(register int i=0;i<s.size();++i){
	if(s[i]>='0'&&s[i]<='9') t=t+s[i],++sum;
	else if(s[i]=='-') continue;
	else t=t+char(as[s[i]]+'0'),++sum;
	if(sum==3) t=t+'-';
}
```

（这里用一个 $sum$ 来记录横线的位置，当然你忽略横线最后输出时再加回去也行）

想到要记录每个字符串的数量，我们可以使用字符串哈希；但是这里我用了 `std::map<string,int> mp`。

于是每次算出一个串 $t$ 就 `++mp[t]` 就可以了，也不用考虑越界。因为 `map` 自带排序，所以最后迭代器遍历 `map` 就可以了。

（最后不要忘记加特判，否则会暴毙）

（特判要加 $\texttt{“.”}$，第一次在这里卡了很久\kk）

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int x=0;bool flag=false;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') flag=true;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return flag?-x:x;
}
const int N=200;
int as[N];
map<string,int> mp;
inline void __init__(){
	as['A']=as['B']=as['C']=2;
	as['D']=as['E']=as['F']=3;
	as['G']=as['H']=as['I']=4;
	as['J']=as['K']=as['L']=5;
	as['M']=as['N']=as['O']=6;
	as['P']=as['R']=as['S']=7;
	as['T']=as['U']=as['V']=8;
	as['W']=as['X']=as['Y']=9;
	return;
}
inline void work(string s){
	string t="";
	int sum=0;
	for(register int i=0;i<s.size();++i){
		if(s[i]>='0'&&s[i]<='9') t=t+s[i],++sum;
		else if(s[i]=='-') continue;
		else t=t+char(as[s[i]]+'0'),++sum;
		if(sum==3) t=t+'-';
	}
	++mp[t];
	return;
}
int main(){
	__init__();
	int kkk=read();
	while(kkk--){
		string s;cin>>s;
		work(s);
	}
	bool flag=true;
	//用auto也可以 
	for(register map<string,int>::iterator it=mp.begin();it!=mp.end();++it){
		if(it->second>=2) cout<<it->first<<" "<<it->second<<endl,flag=false;
	}
	if(flag) puts("No duplicates.");
	return 0;
}
```

---

## 作者：novax (赞：0)

#### 题意

给你若干个不规范的电话号码，让你找出所有出现过不止一次的电话号码并输出这些电话号码的数量。

#### 做法

题解区主要都是各种模拟/STL的做法，但我认为 $\textrm{\color{black}Trie}$ 是本题的正解也是最好的解法。

对于读入的带有字母的电话号码，我们可以写一个函数，将读入的带有字母的号码通过一个小模拟转成纯数字的电话号码。然后根据这些电话号码建立一颗七层的字典树，每个节点的子节点是字符 $0$ 到字符 $9$，同时在第七层的每个节点记录一下以该节点结尾的号码个数，最后dfs一下整棵字典树，遇到以某一个节点结尾的字符串数量大于一个就输出这个字符串。

#### 代码

```
#include <cstdio>
int nex[700010][11];
int tot;
int siz[700010];
char s[1010];
char s2[20];
int s3[20];
int N;
int IP;
char cc(char a)
{
	if(a>='0'&&a<='9')
		return a;
	if(a>='A'&&a<='C')
		return '2';
	if(a>='D'&&a<='F')
		return '3';
	if(a>='G'&&a<='I')
		return '4';
	if(a>='J'&&a<='L')
		return '5';
	if(a>='M'&&a<='O')
		return '6';
	if(a=='P'||a=='R'||a=='S')
		return '7';
	if(a>='T'&&a<='V')
		return '8';
	if(a>='W'&&a<='Y')
		return '9';
	return 0;
}
void print(int val)
{
	printf("%d%d%d-%d%d%d%d %d\n",s3[1],s3[2],s3[3],s3[4],s3[5],s3[6],s3[7],val);
}
void dfs(int p,int dep,int val) 
{
	s3[dep]=val;
	if(dep==7)
	{
		if(siz[p]>=2)
		{
			print(siz[p]);
			IP=1;
			return;
		}
	}
	int i;
	for(i=0;i<10;i++)
	{
		if(nex[p][i])
		{
			dfs(nex[p][i],dep+1,i);
		}
	}
}
int main()
{
	scanf("%d",&N);
	int i,j,k,p,idx;
	for(i=1;i<=N;i++)
	{
		scanf("%s",s);
		k=0;
		for(j=0;s[j];j++)
		{
			if(s[j]!='-')
			{
				s2[k]=cc(s[j]);
				k++;
				if(s2[k-1]==0)
					break;
			}	
		}
		if(k!=7)
			continue;
		p=0;
		for(j=0;j<7;j++)
		{
			idx=s2[j]-'0';
			if(nex[p][idx]==0)
			{
				nex[p][idx]=++tot;
			}
			p=nex[p][idx];
		}
		siz[p]++;
	}
	dfs(0,0,0);
	if(IP==0)
	{
		printf("No duplicates.\n");
	}
}
```

[评测记录](https://www.luogu.com.cn/record/42875582)，本题目前最优解。

---

## 作者：max0810 (赞：0)

这道题看见许多大佬都用的数组，本蒟蒻用的map，希望大家能懂。

思路很简单：每个字符串都化成标准形式（标准形式是string，可以避免前导零，然后放到map里面，最后输出就行。

关于map，本蒟蒻简单介绍一下（具体问度娘）。map和数组差不多，只是map下标可以是任何类型，而且，map可以自动按坐标的字典序排序。

代码如下（注意，我把有些括号换成中文了，你要抄就会0分）：
```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <map>
using namespace std;
const int f[26] = {2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,0,7,7,8,8,8,9,9,9,0};                         //26个字母对应的数字
map<string,int> m;                 //定义map
int main()
{
    int n;
    cin >> n;
    for(int i = 0;i < n;i++)
    {
        string x,s;
        cin >> x;
        for(int i = 0;i < x.size();i++）
        {
            if(x[i]>='0'&&x[i]<='9')s+=x[i]; //如果是数字就直接加
            else if(x[i]>='A'&&x[i]<='Z')s+=(f[x[i]-'A']+'0');//字母就处理一下
            if(s.size() == 7）break;         //如果已经有7个数字，就不用管后面了
        }                           //连接符不用考虑
        m[s]++;                   //统计
    }
    bool b = 1;                   //看有没有重复的，1是没有，0是有
    for(map<string,int>::iterator ite = m.begin();ite!=m.end();ite++)//枚举map，ite和枚举数组中的i差不多
        if(ite->second>1)//ite->first就是下标，ite->second就是下标对应的数
            cout << ite->first.substr(0,3) << '-' << ite->first.substr(3) << ' ' << ite->second << endl,b = 0;
    if(b)cout << "No duplicates.";
    return 0;
}

```


---

## 作者：雨季 (赞：0)

# 题解
**STL大法吼啊！！！**  

开一个 $set$ 存转换成标准形式的电话号码，注意把 $3-4$ 之间的连字符加上，方便输出。  
再开一个 $map$ 记录每个标准号码出现的次数。  
从 $begin()$ 到 $end()$ 遍历 $set$ ，将出现次数多于$1$的输出即可。

# 代码 
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<set>
#include<map> 
using namespace std;
#define N 1005

int n;

int len;
char s[N];
string ss;
set<string>se;
map<string,int>cnt;
char id[]={'2','2','2','3','3','3','4','4','4','5','5','5','6','6','6','7','0','7','7','8','8','8','9','9','9','0'};
void work() {
	scanf("%s",s);
	len=strlen(s);
	ss="";
	int nu=0;
	for(int i=0;i<len;++i) {
		if(s[i]=='-') continue;
		if(s[i]>='A'&&s[i]<='Z') ss=ss+id[s[i]-'A'];
		else ss=ss+s[i];
		nu++;
		if(nu==3) ss=ss+'-';
	}
	se.insert(ss);
	cnt[ss]++;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) work();
	bool f=0;
	for(set<string>::iterator i=se.begin();i!=se.end();++i) if(cnt[*i]>1) cout<<*i<<" "<<cnt[*i]<<endl,f=1;
	if(!f) printf("No duplicates.\n");
	return 0; 
}
```

---

## 作者：lipee (赞：0)

用七维数组储存不带‘-‘的标准形式，超过两个的输出。

特别注意‘No duplicates.’有‘.’~~



```cpp
var
  ans:array['0'..'9','0'..'9','0'..'9','0'..'9','0'..'9','0'..'9','0'..'9']of longint;//该标准形式个数
  n,i,j:longint;
  s,x,d:ansistring;
  i1,i2,i3,i4,i5,i6,i7:char;
  q:boolean;
begin
  d:='22233344455566670778889990';
  readln(n);
  for i:=1 to n do
    begin
      readln(x);
      s:='';
      for j:=1 to length(x) do
        if x[j]<>'-' then
          begin
            if x[j] in ['A'..'Z'] then s:=s+d[ord(x[j])-ord('A')+1];//通过字符串模拟形式转换
            if x[j] in ['0'..'9'] then s:=s+x[j];
          end;
      inc(ans[s[1],s[2],s[3],s[4],s[5],s[6],s[7]]);
    end;
  q:=false;
  for i1:='0' to '9' do
    for i2:='0' to '9' do
      for i3:='0' to '9' do
        for i4:='0' to '9' do
          for i5:='0' to '9' do
            for i6:='0' to '9' do
              for i7:='0' to '9' do
                if ans[i1,i2,i3,i4,i5,i6,i7]>1 then//超过两个输出
                  begin
                    q:=true;
                    writeln(i1+i2+i3+'-'+i4+i5+i6+i7+' ',ans[i1,i2,i3,i4,i5,i6,i7]);
                  end;
  if q=false then write('No duplicates.');//没重复就输出‘No duplicates.’
end.

```

---


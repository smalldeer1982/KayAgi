# 一中校运会之百米跑

## 题目背景

在一大堆秀恩爱的 \*\* 之中，来不及秀恩爱的苏大学神踏着坚定（？）的步伐走向了 $100$ 米跑的起点。这时苏大学神发现，百米赛跑的参赛同学实在是太多了，连体育老师也忙不过来。这时体育老师发现了身为体育委员的苏大学神，便来找他帮忙。

可是苏大学神需要热身，不然跑到一半就会抽（筋）、于是他就找到了你。。。如果你帮助体育老师解决了问题，老师就会给你 $5$ 个积分。

## 题目描述

假设一共有 $N$（$2\leq N\leq 2\times 10^4$）个参赛选手。（尼玛全校学生都没这么多吧）

老师会告诉你这 $N$ 个选手的名字。

接着会告诉你 $M$（$1\leq M\leq 10^6$）句话，即告诉你学生 A 与学生 B 在同一个组里。

如果学生 A 与学生 B 在同一组里，学生 B 与学生 C 也在同一组里，就说明学生 A 与学生 C 在同一组。

然后老师会问你 $K$（$1\leq K\leq 10^6$）句话，即学生 X 和学生 Y 是否在同一组里。

若是则输出 `Yes.`，否则输出 `No.`。

## 样例 #1

### 输入

```
10 6
Jack
Mike
ASDA
Michel
brabrabra
HeHe
HeHE
papapa
HeY
Obama
Jack Obama
HeHe HeHE
brabrabra HeHe
Obama ASDA
papapa Obama
Obama HeHE
3
Mike Obama
HeHE Jack
papapa brabrabra
```

### 输出

```
No.
Yes.
Yes.
```

# 题解

## 作者：vectorwyx (赞：194)

## 裸的并查集+map
## （STL大法好！）


------------
题目背景和题目描述~~非常直接地~~告诉我们：

这就是个并查集模板，只不过改成了字符串


------------
因此我们的问题就成了如何处理字符串

当然，可以用结构体，结构体的成员包含编号和名字

但是，还有一个更好用的东西:STL中的**map**

直接**建立一个由字符串到字符串的映射**代替数组

然后把并查集的模板粘上去改一改就成了

（没错，就是这么水）

------------
代码来了~
```cpp
#include<iostream>
#include<cstdio>
#include<map>//map库
using namespace std;
map<string,string> a;//建立映射
string fin(string x){//查找字符串x的祖先
	if(a[x]==x) return x;
	else return a[x]=fin(a[x]);//路径压缩
}
int main(){
	int n,m,k;
	string s1,s2;//s1,s2可重复使用
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>s1;//选手名字
		a[s1]=s1;//每个人的祖先初始化为自己
	}
	for(int i=1;i<=m;++i){
		cin>>s1>>s2;//两位选手
		string x1=fin(s1),x2=fin(s2);//合并
		if(x1!=x2) a[x1]=x2;
	}
	cin>>k;
	for(int i=1;i<=k;++i){
		cin>>s1>>s2;
		string x1=fin(s1),x2=fin(s2);//查询
		if(x1!=x2) printf("No.\n");
		else printf("Yes.\n");
	}
	return 0;//后话：STL大法好！
}
```


------------
你AC了吗？AC了就点个赞呗

---

## 作者：翼德天尊 (赞：48)

[题目传送门](https://www.luogu.com.cn/problem/P2256)

[并查集模板传送门](https://www.luogu.com.cn/problem/P3367)

**这道题的第一眼就是：字符串+板子并查集！！！**

遵循政治老师的教导，本题解将从是什么，为什么，怎么做三个方面来为大家阐述并查集的相关知识以及本题做法。

**好了，闲话不多说，不会这道题的童鞋们跟我来！**



------------


### STEP 1 什么是并查集
```
并查集，是用来求两者是否同属一个单位的一种思路。
仅由一个内容仅仅两行左右的函数以及一个数组就可以实现。
优点：方便快捷，使用有效。
缺点：emmm……没有什么大的缺点，非要有的话可能就是时间复杂度有些高，
     但是这个是可以通过一个小优化解决哒！
```


------------
### STEP 2 为什么要用并查集
并查集是用来判断两者是否为一个单位的方法。

如果同属于一个单位的人为一个战队，那么通过标记和函数查找，我们可以清楚地知道这一个战队的队长是谁，并且以这个队长为这个战队的标志，以后战队的每一个人与其他人碰面，只要标志不同，那就把另一个拉近自己的战队。在访问的时候，只要两个人的标志不同，就是不在一个战队，否则他们就是一个战队的好哥们啦。


------------
### STEP 3 并查集怎么做

#### 1.并查集标准判断标志是否相同函数
```
//只是个例子
int f[100];//定义一个数组，当然这个数组初始化的时候每个人的队长都是他自己
int find(int x){
	if (f[x]==x) return x;//如果队长是他自己，那么他就是队长
	return find(x); //否则一直搜，直到搜到队长为止
}
```
但是，你会发现，如果每一次碰到一个人就一直搜队长，是不是太慢了，于是我们可以优化一下，只要沿路碰到的全将他的队长设为最高队长。
```
//依然是个例子
int f[100];
int find(int x){
	if (f[x]==x) return f[x];
	return f[x]=find(f[x]);//沿路的都顺便将他标记
}
```
#### 2.针对这道题的转化函数
怎么在不用map的情况下定位跟踪到某一个名字的位置呢？这时候就需要新建一个函数来定位。
```
string mz[100];//大小随便开的，用来直接储存输入的名字
int fname(string name){//输入一个字符串也就是名字
	for (int i=1;i<=n;i++){
		if (name==mz[i]) return i;//不断搜索，返回他的位置
	}
}
```


------------

### STEP 4 总AC代码带注释
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k;//储存的相应东西如题所示
string f[20001],mz[20001];//分别储存每个人的队长标志以及序号对应的人名
int fname(string name){//转换函数
	for (int i=1;i<=n;i++){
		if (name==mz[i]) return i;
	}
}
string find(string name){//并查集函数
	if (f[fname(name)]==name) return name;
	return f[fname(name)]=find(f[fname(name)]);//将名字转换成数字储存
} 
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
    	cin>>f[i];
    	mz[i]=f[i];
	} //正常输入
	for (int i=1;i<=m;i++){
		string a,b;
		cin>>a>>b;
		f[fname(find(a))]=find(b);//并查集找队长操作
	}
	scanf("%d",&k);
	for (int i=1;i<=k;i++){
		string a,b;
		cin>>a>>b;
		if (find(a)==find(b)) printf("Yes.\n");
		else printf("No.\n");//寻找队长是否相同并输出
	}
    return 0;//好习惯要养成哦！
}
```

------------

### STEP 5 完结撒花
终于完美的结束了！还不懂的童鞋们可以在评论区留言，我会第一时间回复哒！如果没有问题了，就点个赞记录留念一下你的成长吧！


---

## 作者：zybnxy (赞：15)

* ##  ~~并查集水题~~
只是本题合并的是字符串，别的题合并的是数字而已。

其他的真的只时模板啊$QWQ$

本题的注意事项（打星号）

1：字符串的查找：

如果是数字，我们不需要查找，只需要对此合并就可以，但是如果是字符串，就必须要查找，观察范围发现$(2<=N<=20000)$于是。。。我们真的可以从$1$一直找到$20001$，如果找到了，就返回他的下标。

查找字符串的代码如下
```cpp
int findname(string s)
{
    int ans=0;
    for(ri i=1;i<=20001;i++)
        if(s==fa[i].name)return i;
}
```

2：对于字符串和其对应数字的存储

这个也很简单，我们只需要开一个结构体就可以了

平时我们这样开
```cpp
int fa[200001];
```

现在我们只需要一个结构体，来存贮每个字符串和下标就可以了
```cpp
struct node
{
    string name;
    int num;
}fa[2000001];
```

所以，现在我们查并查集的时候就需要这样写
```cpp
}fa[2000001];
inline int sfind(int x)
{
    if(fa[x].num==x)return x;
    else
    {
        fa[x].num=sfind(fa[x].num);
        return fa[x].num;
    }
}
```

3：对于细节的处理：

本题因为是字符串，所以在查找的时候难免会出现错误~~LZ就是因为这样调了近半个小时~~

最后附上AC代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream> 
#define ri register int
#define INF 2139063143
using namespace std;
struct node
{
    string name;
    int num;
}fa[2000001];
inline int sfind(int x)
{
    if(fa[x].num==x)return x;
    else
    {
        fa[x].num=sfind(fa[x].num);
        return fa[x].num;
    }
}
int findname(string s)
{
    int ans=0;
    for(ri i=1;i<=20001;i++)
        if(s==fa[i].name)return i;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(ri i=1;i<=n;i++)
    {
        fa[i].num=i;
        cin>>fa[i].name;
    } 
    for(ri i=1;i<=m;i++)
    {
        string name1,name2;
        cin>>name1>>name2;
        int u=findname(name1);
        int v=findname(name2);
        int uu=sfind(fa[u].num);
        int vv=sfind(fa[v].num);
        if(uu!=vv)
        	fa[uu].num=vv;
    }
    int k;
    scanf("%d",&k);
    for(ri i=1;i<=k;i++)
    {
        string name1,name2;
        cin>>name1>>name2;
        int u=findname(name1);
        int v=findname(name2);
        int uu=sfind(fa[u].num);
        int vv=sfind(fa[v].num);
        if(uu!=vv)printf("No.\n");
         else printf("Yes.\n");
    }
    return 0;
}
```

---

## 作者：Magallan_forever (赞：9)

# 裸的并查集+hash
首先我们来介绍一下什么是并查集：
>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。

>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。
—百度百科

简单地说，并查集可以快速的处理一些元素的合并和查询，但要求元素具有唯一性。
首先是原理：

我们把每一个集合当成一棵树，当一个元素与另一个元素的father相同时，我们就认为他们在同一个集合内。（这就是查询）

至于合并，我们可以考虑将一个集合的root合并到另一个集合的root下

初始化：一开始所有人都是自己的father~~我 是 我 爸 爸~~

好了上代码

__初始化__
```cpp
void init(int maxn){
    f.clear();
    for(int i=0;i<maxn;i++){
        f.push_back(i);
    }
}
```
__找root函数__
```cpp
int getf(int v){//或者叫getroot?（大雾）
    if(v==f[v])return v;
    return f[v]=getf(f[v]);//这是路径压缩
    //如果整棵树被卡成一条链，那么getf就是O(n)
    //这个可以让getf复杂度均摊成为O(log2n)
}
```
__查询__
```cpp
bool in(int x,int y){
    return f[getf(x)]==f[getf(y)];
}
```
__合并__
```cpp
void merge(int a,int b){
    int fa=getf(a),fb=getf(b);
    f[fb]=f[fa];//本来有一个叫按秩合并的东西，但是用的不多，
    //打路径压缩就够了
}
```
然后是hash
>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
>—百度

>这东西可以用来离散化和~~乱搞~~存储字符串
>—我

hash千千万，主要分为字符串/整数hash这里介绍字符串hash的一种-BKDRhash
```cpp
typedef unsigned long long ull;
const int seed=233;
int hash(string s){
	ull hash_=0;
	for(int i=0;i<s.length();i++) hash_=hash_*seed+s[i];
	return hash_%200000;
}
//这东西有可能有两个字符串hash值一样，谨慎使用
```
然后我们看一下，这道题需要判断多个不相交集合=>并查集

有字符串存储=>hash

所以这道题就是~~乱搞~~并查集+hash

code:
```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<iostream>
using namespace std;
typedef unsigned long long ull;
struct union_find_set{
    vector<int> f;
    void init(int maxn){
    	f.clear();
        int i;
        for(int i=0;i<maxn;i++){
            f.push_back(i);
        }
    }
    int getf(int v){
        if(v==f[v])return v;
        return f[v]=getf(f[v]);
    }
    void merge(int a,int b){
        int fa=getf(a),fb=getf(b);
        f[fb]=f[fa];
    }
    bool in(int x,int y){
        return f[getf(x)]==f[getf(y)];
    }
};
union_find_set set_;
string a,b;
const int seed=233;
int hash(string s){
	ull hash_=0;
	for(int i=0;i<s.length();i++) hash_=hash_*seed+s[i];
	return hash_%200000;
}
int main(){
	set_.init(200000);
	int n,m,k;
	scanf("%d%d",&n,&m);
	while(n--) cin>>a;
	while(m--) cin>>a>>b,set_.merge(hash(a),hash(b));
	scanf("%d",&k);
	while(k--) cin>>a>>b,puts(set_.in(hash(a),hash(b))?"Yes.":"No.");
	return 0;
}
```
[评测记录](https://www.luogu.org/record/22952266)

---

## 作者：Jayun (赞：6)

（^_^)


## 思路：

这是一道并查集水题,适合初学者做！！！

若不会**并查集**的点[我](https://www.luogu.org/blog/142373/bing-zha-ji),那是dalao的博客！

本题难点：名字是字符串，要字符串处理

给每个名字一个编号，如$1,2,3,4,5,6,...$,用[**$\texttt{STL的map}$**](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=monline_4_dg&wd=c%2B%2B%20map&oq=%25E5%25B9%25B6%25E6%259F%25A5%25E9%259B%2586&rsv_pq=de1f539f0014f2de&rsv_t=d77eu9QPciueH67DnsfE7xASWyMBuBvGjk0V3caYcLfsj4hT9eUyPAVbBbw5RUL5pjmj&rqlang=cn&rsv_enter=1&rsv_sug3=9&rsv_sug1=8&rsv_sug7=100&bs=%E5%B9%B6%E6%9F%A5%E9%9B%86)存下来，然后普通并查集

这题是C++福利啦~


Pascal不知道数组下标能不能用字符串，可以的话一个数组搞定

## 代码：

拒绝![ctrl](https://s2.ax1x.com/2019/06/22/Z9hS8H.png)+C

c++代码

```cpp
#include <iostream>

using namespace std;

map <string,int> ma;
int f[20010],tot,n,m;

int find(int k){     //并查集find()
    if(f[k]==k)return k;
    return f[k]=find(f[k]);
} 

int main()
{
	//*****初始化***** 
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)f[i]=i;
	//*****存名字***** 
	for(int i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		tot++;
		ma[s]=tot;
	}
	//*****并***** 
	for(int i=1;i<=m;i++)
	{
		string s,st;
		cin>>s>>st;
		int a=ma[s],b=ma[st];
		f[find(a)]=find(b);
	} 
	//*****查*****
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		string s,st;
		cin>>s>>st;
		int a=ma[s],b=ma[st];
		if(find(a)==find(b))cout<<"Yes.\n";
		else cout<<"No.\n";
	} 
	return 0;
}

```

---

## 作者：Forest_Prince (赞：4)

~~算是一道并查集板子题吧~~

既然检查两个选手是否在一个组里，自然而然的就想起了**并查集**

但是这个并查集和普通的并查集有些许的不同，里面多了个字符串，所以我们在查找根节点的时候，需要做一些改动，访问数组里面的编号项（详情见代码）

```cpp
int find(int n){
	if(uset[n].num!=n) uset[n].num=find(uset[n].num);
	return uset[n].num;
}
```


我们还需要一个函数来查找这个字符串在数组里是第几位
```cpp
int sfind(string a){
	for(int i=1;i<=n;i++){
		if(a==uset[i].s) return i;
	}
}
```

如果他们在同一个组里，他们的根节点是肯定相同的，所以我们在输入时判断这两个人在没在同一个组里，如果在同一个组里，不用管，如果不在，那么合并

对于k次询问，只需要判断这两个人有没有在同一个根节点，如果在就是Yes.
不在就是No.

题意了解清楚之后完整代码如下



```
#include<bits/stdc++.h>
#define _ 0 
using namespace std;
int n,m,k;
struct node{		//用来储存名字和编号 
	string s;
	int num;
};
node uset[20000+50]; 
int find(int n){	//上文提到的查找 
	if(uset[n].num!=n) uset[n].num=find(uset[n].num);
	return uset[n].num;
}
void merge(int a,int b){	//合并并查集 
	a=find(a);
	b=find(b);		
	if(a==b) return ;
	else uset[a].num=uset[b].num;
}
int sfind(string a){	//查找这个名字 
	for(int i=1;i<=n;i++){
		if(a==uset[i].s) return i;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>uset[i].s;		//对于每次输入，存编号 
		uset[i].num=i;
	}	
	for(int i=1;i<=m;i++){	//m次输入 
		string sa,sb;	//管理大大，我莫得骂人，我只是不知道叫什么了 
		cin>>sa>>sb;
		if(find(sfind(sa))!=find(sfind(sb))){	//查找两个名字
			merge(sfind(sa),sfind(sb));		//合并 
		}
	} 
	cin>>k;	 
	for(int i=1;i<=k;i++){		//k次询问 
		string sx,bs;
		cin>>sx>>bs;
		if(find(sfind(sx))==find(sfind(bs))){	//也是查找两个名字
			cout<<"Yes."<<endl;			//在一个组里 
		}else {
			cout<<"No."<<endl;			//不在一个组 
		}
	}
	return ~~(0^_^0);	//皮一下 
}
```


还望大佬多多指点

---

## 作者：Scherzo (赞：4)

本题是并查集稍微改了一点点，按理说应该是道橙题的。

首先我们先来认识一下并查集：

## 并查集

>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 ——百度百科

简单来说，并查集就是从一个图中，找出一个点的**最终祖先**，需要实现该操作的话，我们首先要有数组 $father$：

```cpp
int father[N];//N为最大节点数
```

------------

### 初始化

首先，由于最开始的时候每个节点都是独立的，所以我们将每个节点的祖先都设置为其本身：

```cpp
for (int i=1;i<=n;i++)
{
	father[i]=i;
}
```

------------


### 查询操作

题目中有一句话很好地体现了查询操作的基础。

>如果学生A与学生B在同一组里，学生B与学生C也在同一组里，就说明学生A与学生C在同一组。

也就是说，$A$ 的父节点的父节点，就是他的祖先节点。

那么，既然我们要找的只是每个节点的**最终祖先**，为什么不把 $A$ 的父节点，$A$ 的父节点的父节点的，他们的父节点都变为 $A$ 的**最终祖先**呢？

所以，进行查询操作的函数将会是一个**递归函数**。既然是递归函数，那么就必然有边界条件：

Q：函数什么时候结束？

A：找到**最终祖先节点**的时候结束。

Q：**最终祖先节点**有什么特点？

A：**最终祖先节点的父节点为自身**。

由于我们最开始初始化的时候每个节点的父节点都为自身，而在输入过程中没有获得父节点的节点便是祖先节点，所以**最终祖先节点的父节点为自身**

那么我们的递归函数具有了边界条件：

```cpp
inline void find_ancestor(int x)
{
	if (x==father[x])
	{
		return father[x];
	}
}
```

那么如何查询呢？

很简单，只需要让函数递归查询当前节点的父亲节点就可以了，同时还要将当前节点的父亲节点的**最终祖先节点**设为当前节点的父亲节点，接着我们的 $find$_$ancesoter$ 函数就完成了。

```cpp
inline int find_ancestor(int x)
{
	if (x==father[x])
	{
		return father[x];
	}
   return father[x]=find_ancestor(father[x]);
}
```

------------

### 合并操作

如果你想让两个节点合并，那么做法就是将一个节点设为另一个节点的祖先。

如果理解了上面的 $find$_$ancestor$ 函数，那么这个函数就好理解多了，直接上代码吧

```cpp
inline void emerge_nodes(int x,int y)
{
	int a=find_ancestor(a);
	int b=find_ancestor(b);
	if (a!=b)
	{
		father[a]=b;
	}
}
```

------------

掌握了这些，就可以AC [P3367 [模板] 并查集](https://www.luogu.com.cn/problem/P3367) 了，建议先AC模板后再来，阅读效果更佳

------------

## 解决本题

本题与模板题的差异就在于本题多了一个学生姓名，也就是说，不能再用 $father$ 数组了，而要用一个结构体。

对，就差这么多。

------------

### 变量声明

首先我们需要两个变量 $n$,$m$，含义分别为点数和边数。

```cpp
int n,m;
```

接下来，由于本题中有“名字”这个概念，所以我们可以创建结构体来存储每个节点的名字和父节点。

```cpp
struct node
{
	string name;
	int father;
}stu[N];
```

这样，``stu[i].name`` 就表示了第 $i$ 个同学的名字，``stu[i].father``就表示了第 $i$ 个同学的父节点。

### 函数

其中要有一个函数，传入一个姓名，返回该学生的编号，比较简单就不讲了。

```cpp
//其中n为学生人数
inline int name_to_num(string a)
{
	for (int i=1;i<=n;i++)
	{
		if (match(a,stu[i].name))
		{
			return i;
		}
	}
}
```
细心的你一定注意到了，这里还用到了一个 $match$ 函数，这是我写来判断两个字符串是否完全相同的，因为我总是感觉两个字符串之间用 ``==`` 很奇怪。

```cpp
inline bool match(string a,string b)
{
	if (a.size()!=b.size())
	{
		return 0;
	}
	for (int i=0;i<=a.size()-1;i++)
	{
		if (a[i]!=b[i])
		{
			return 0;
		}
	}
	return 1;
}
```

很简单吧，也不讲了。

------------


### ~~int mian~~ 主函数

和模板题几乎一模一样，不讲了

```cpp
int main()
{
	//Part I
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>stu[i].name;
		stu[i].father=i;
	}
	for (int i=1;i<=m;i++)
	{
		string a,b;
		cin>>a>>b;
		int x=name_to_num(a);
		int y=name_to_num(b);
		merge_nodes(x,y);
	}
	//Part II
	int k;
	cin>>k;
	for (int i=1;i<=k;i++)
	{
		string a,b;
		cin>>a>>b;
		int x=name_to_num(a);
		int y=name_to_num(b);
		if (find_ancestor(x)==find_ancestor(y))
		{
			cout<<"Yes."<<endl;
		}
		else
		{
			cout<<"No."<<endl;
		}
	}
}
```

------------


## CODE

完整代码~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=20010;

int n,m;

struct node
{
	string name;
	int father;
}stu[N];

inline bool match(string a,string b)
{
	if (a.size()!=b.size())
	{
		return 0;
	}
	for (int i=0;i<=a.size()-1;i++)
	{
		if (a[i]!=b[i])
		{
			return 0;
		}
	}
	return 1;
}

inline int name_to_num(string a)
{
	for (int i=1;i<=n;i++)
	{
		if (match(a,stu[i].name))
		{
			return i;
		}
	}
}

inline int find_ancestor(int x)
{
	if (stu[x].father==x)
	{
		return x;
	}
	return stu[x].father=find_ancestor(stu[x].father);
}

inline void merge_nodes(int x,int y)
{
	int a=find_ancestor(x);
	int b=find_ancestor(y);
	if (a!=b)
	{
		stu[a].father=b;
	}
}

int main()
{
	//Part I
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>stu[i].name;
		stu[i].father=i;
	}
	for (int i=1;i<=m;i++)
	{
		string a,b;
		cin>>a>>b;
		int x=name_to_num(a);
		int y=name_to_num(b);
		merge_nodes(x,y);
	}
	//Part II
	int k;
	cin>>k;
	for (int i=1;i<=k;i++)
	{
		string a,b;
		cin>>a>>b;
		int x=name_to_num(a);
		int y=name_to_num(b);
		if (find_ancestor(x)==find_ancestor(y))
		{
			cout<<"Yes."<<endl;
		}
		else
		{
			cout<<"No."<<endl;
		}
	}
}
```

	码字不易求点赞~拜拜了喵~

---

## 作者：PTC06 (赞：3)

较简单的并查集。唯一和其他题目的不同之处是输入的是人的名字（Stirng），而不是较多见的Int。

思路：

1.定义各种变量，其中包括一个结构体People，里面存了一个人的名字和编号，编号为数字（由于用到并查集，必须至少有一个是数字）

2.读入信息，需要注意的有两点：

读入n个名字的时候，需要读入People里面的name。

读入m的时候，要先找出每个名字对应的编号，再合并。

3.读入t和t对需要查询的人名，并且判断祖先是否相同。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,t1,t2,pre[20000],tem,tem1,t,j;
string st1,st2;
struct pers              //定义结构体。
{
    int num;
    string name;
} person[20000]; 
int sch(int x)           //找祖先。
{
    if (pre[x]==x) return pre[x];
    pre[x]=sch(pre[x]);
    return pre[x];
}
void join(int x,int y) 
{
    if (sch(x)!=sch(y))      //祖先不同则合并。
    {
        pre[sch(x)]=sch(y);
    }
}
int findnum(string s)        //找到名字对应的编号。
{
    for (j=1;j<=n;j++)
    {
        if (person[j].name==s) return person[j].num;
    }
}
bool samef(string x,string y)   //判断祖先是否相同。
{
    tem=findnum(x);
    tem1=findnum(y);
    if (sch(tem)==sch(tem1)) return 1;
    return 0;
}
int main()
{
    cin>>n>>m;
    for (i=1;i<=n;i++) pre[i]=i;
    for (i=1;i<=n;i++)
    {
        cin>>person[i].name;
        person[i].num=i;
    }
    for (i=1;i<=m;i++)
    {
        cin>>st1>>st2;
        t1=findnum(st1);
        t2=findnum(st2);
        join(t1,t2);
    }
    cin>>t;
    for (i=1;i<=t;i++)
    {
        cin>>st1>>st2;
        if (samef(st1,st2)) cout<<"Yes."<<endl; else cout<<"No."<<endl;
    }
}
```

---

## 作者：Mignon (赞：2)

Emmm，这题~~。

其实很容易发现这是一个并查集，只不过在字符串的处理上需要一点技巧，我采用二分查找。P.S.c++自带sort可以直接字典序排序字符串（string）。

并查集：

 用集合的思路，对于每个人建立一个集合，开始的时候集合元素是这个人本身，表示开始时不知道任何人和他一组。以后每次给出两个人的关系时，就将两个集合合并。这样实时地得到了在当前状态下的集合关系。如果有提问，即在当前得到的结果中看两元素是否属于同一集合。例如下图：
 
| 输入关系 | 分离集合 |
| :-----------: |: -----------: |
| 初始状态  | {1}{2}{3}{4}{5}{6}{7}{8}{9}{10} |
| (2,4) | {1}{2,4}{3}{5}{6}{7}{8}{9}{10} |
| (5,7) | {1}{2,4}{3}{5,7}{6}{8}{9}{10} |
| (1,3) | {1,3}{2,4}{5,7}{6}{8}{9}{10} |
| (8,9) | {1,3}{2,4}{5,7}{6}{8,9}{10} |
| (1,2) | {1,2,3,4}{5,7}{6}{8,9}{10} |
| (5,6) | {1,2,3,4}{5,6,7}{8,9}{10} |
| (2,3) | {1,2,3,4}{5,6,7}{8,9}{10} ||

代码：
```cpp
#include<bits/stdc++.h>
using namespace std ;
int n , m , k ;
string a[20001] ;
int f[20001] ;
int two( string x , int head , int last ) ;
void un( int x , int y ) ;
int find( int x ) ;

int main()
{
	cin >> n >> m ;
	for( int i = 1 ; i <= n ; i ++ )
	{
		cin >> a[i] ;
	}
	sort(a+1,a+n+1) ; // 字典序排序
	for( int i = 1 ; i <= n ; i ++ ) f[i] = i ;
    // 把开始每一个人的父亲都设成他自己
	string x , y ;
	for( int i = 1 ; i <= m ; i ++ )
	{
		cin >> x >> y ;
		int c = two(x,1,n) , d = two(y,1,n) ;
		if( c == -1 || d == -1 ) continue ;
		int r1 = find(c) ;
		int r2 = find(d) ;
        // 对输入的数据进行判断：是否在同一集合。
		if( r1 != r2 ) un(r1,r2) ;
	} 
	cin >> k ;
	for( int i = 1 ; i <= k ; i ++ )
	{
		cin >> x >> y ;
		int c = two(x,1,n) , d = two(y,1,n) ;
		if( c == -1 || d == -1 )
		{
			cout << "No." ;
			continue ;
		}
		if( find(c) == find(d) ) cout << "Yes." ;
		else cout << "No." ;
		cout << endl ;
	}
	return 0 ;
} 

int two( string x , int head , int last )
{
	if( head > last ) return -1 ;
	int g = ( last + head ) / 2 ;
	if( a[g] == x ) return g ;
	if( a[g] > x ) return two(x,head,g-1) ;
	else return two(x,g+1,last) ;
} // 二分查找

void un( int x , int y )
{
	f[x] = y ;
    // 用f[i]表示元素i的父亲结点，进行不断并到不同的集合中
	return ;
} // 合并

int find( int x )
{
	if( f[x] != x ) f[x] = find(f[x]) ; // 寻找根结点编号并压缩路径
	return f[x] ;
} // 查找
```

Finnish (ヾ(◍°∇°◍)ﾉﾞ)

---

## 作者：ENOR4 (赞：2)



### 好像所有大佬都是用并查集耶
### 那我发一个Hash的做法吧



~~本蒟蒻第一次发题解来玩玩~~


------------


###### 贴上AC代码
```cpp
#include<bits/stdc++.h>
#define MAX 10000
using namespace std;

int groups[MAX];						//储存每个人所属的组
int keys[20000];						//储存每个名字的值（key）
int c = 0;								//储存有多少个名字 

int eHash (string s) {					//Hash函数,将名字转为一个唯一的int值 
	int res = 0, len  = s.length();
	for (int i = 0; i < len; i++) {
		res += (int)s[i];				//将每个字母转换成int相加（ASCII） 
	}
	
	keys[c] = res;						 
	c++;
	
	return res;
}

int main () {
	memset(groups,0,sizeof(groups));			//将groups所有元素初始化为0,0即无组 
	
	string temp;						//这段用来跳过刚开始的姓名输入（用不着） 
	int n, m;
	cin>>n>>m;
	for (int i = 0; i < n; i++) {
		cin>>temp;
	}
	
	//处理关系 
	int t = 1;							//记录开了多少个小组 
	string t1, t2;
	int b1, b2;
	for (int j = 0; j < m; j++) {
		cin>>t1>>t2;
		b1 = eHash(t1);
		b2 = eHash(t2);
		
		if (groups[b1] == 0 && groups[b2] == 0) {				//如果两个名字都不属于任何一个组,则划为新组 
			groups[b1] = t;
			groups[b2] = t;
			t++;
		} else if (groups[b1] == groups[b2]) {					//同组跳过 
			continue;
		} else if (groups[b1] == 0 && groups[b2] != 0) {		//如果两个名字中有一个有组,则将另一个名字划为另一个名字的组 
			groups[b1] = groups[b2];
		} else if (groups[b2] == 0 && groups[b1] != 0) {
			groups[b2] = groups[b1];
		} else if (groups[b1] != 0 && groups[b2] != 0) {		//如果两个人的名字都有组，则将一个组全部划为另一个组 
			int t = groups[b2];
			for (int i = 0; i < c; i++) {
				if (groups[keys[i]] == t) {
					groups[keys[i]] = groups[b1];
				}
			}
		}
		
	}
	
	//输出答案 
	int k;
	cin>>k;
	string a1, a2;
	for (int l = 0; l < k; l++) {
		cin>>a1>>a2;
		if (groups[eHash(a1)] == 0 && groups[eHash(a2)] == 0) { //直接判断两人是否为同组,但有特殊情况,即两人都无组（都为0）,这种情况输出No 
			cout<<"No."<<endl;
		} else if (groups[eHash(a1)] == groups[eHash(a2)]) {
			cout<<"Yes."<<endl;
		} else {
			cout<<"No."<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Tools (赞：2)

# 这题其实水的一批

## 和亲戚一样的题目，是不过是字胡串而已

## 所以我们只要解决字胡串的问题就可以啦

## 蒟蒻用结构体就写出来了qwq

## 代码超级短，简单易懂

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<map>
using namespace std;
struct node{
	string a;//a是姓名
	int b;//用int类型来替代姓名,其实就是解决问题的关键
}ar[1000];
int n,m,k,fa[1000];
int find(int x)//并查集代码
{
	while(x!=fa[x]) x = fa[x] = fa[fa[x]];
	return x;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<1000;i++)fa[i]=i;//初始化冰茶几
	for(int i=0;i<n;i++)
	{
		scanf("%d",&ar[i].a);
		int len = ar[i].a.length();
		int ans = 0;
		for(int j=0;j<len;j++)ans+=ar[i].a[j];//用数字来代替字胡串就完美解决了
		ar[i].b = ans;
	}
	for(int i=0;i<m;i++)
	{
		string x,y;
		cin>>x>>y;
		int a,b;
		for(int j=0;j<n;j++)
		{
			if(ar[j].a==x)a = j;//找到两个人的下标
			if(ar[j].a==y)b = j;
		}
		fa[find(ar[a].b)] = find(ar[b].b);//合并
	}
	scanf("%d",&k);
	for(int i=0;i<k;i++)
	{
		string x,y;
		cin>>x>>y;
		int a,b;
		for(int j=0;j<n;j++)
		{
			if(ar[j].a==x)a = j;//依然找下标
			if(ar[j].a==y)b = j;
		}
		if(find(ar[a].b)==find(ar[b].b))printf("Yes.\n");//判断是否在一个集合内
		else printf("No.\n");
	}
    return 0;
}	
```
~~qwq希望能过，要不然最后一年noip一篇题解都没过~~

---

## 作者：没有输入 (赞：2)

# 并查集 & 字符串

本题主要考查对并查集的理解与运用，以及对字符串的处理。就并查集方面来说，如果抛开姓名，完全就是并查集模板题。主要难度在字符串的处理上。

### String

这里就不得不提一下C++比C的优势之一了：新增了string类型，使我们不用再苦逼地去开字符数组了。

先定义一个结构体用以储存每个人的数据
```cpp
struct Node
{
	string name;//名字
	int fa,num;//父亲的编号、自己的编号
} p[20005];
```
### 并查集

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。

并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。
```cpp
int merge(int x)
{
	if(p[x].fa==p[x].num) return p[x].num;
	return p[x].fa=merge(p[x].fa);
}
```
注意到**第四行**
```cpp
return p[x].fa=merge(p[x].fa);
```
我们另加了一个赋值语句。这样就可以将所有人的父亲指向同一个人，避免出现线性结构，以减低复杂度。

### 如何寻找一个名字？

因为数据才2W，所以直接枚举所有名字知道找到目标名字并返回其所在编号
```cpp
int Find(string s)
{
	int i;
	for(i=1; i<=n; i++)
		if(p[i].name==s) break;
	return i;
}
```
### 读入数据后进行合并

```cpp
for(int i=1; i<=m; i++)
	{
		cin>>x>>y;
		p[merge(Find(x))].fa=merge(Find(y));
	}
```

### 询问并给出答案

```cpp
while(k--)
{
	cin>>x>>y;
	printf("%s\n",merge(p[Find(x)].num)==merge(p[Find(y)].num)?"Yes.":"No.");
}
```
## 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
string x,y;
struct Node
{
	string name;
	int fa,num;
} p[20005];
int Find(string s)
{
	int i;
	for(i=1; i<=n; i++)
		if(p[i].name==s) break;
	return i;
}
int merge(int x)
{
	if(p[x].fa==p[x].num) return p[x].num;
	return p[x].fa=merge(p[x].fa);
}
int main()
{
	for(int i=0;i<20005;i++) p[i].num=p[i].fa=i;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) cin>>p[i].name;
	for(int i=1; i<=m; i++)
	{
		cin>>x>>y;
		p[merge(Find(x))].fa=merge(Find(y));
	}
	scanf("%d",&k);
	while(k--)
	{
		cin>>x>>y;
		printf("%s\n",merge(p[Find(x)].num)==merge(p[Find(y)].num)?"Yes.":"No.");
	}
	return 0;
}
```
我是[没有输入](https://www.luogu.org/space/show?uid=154344)，我们下次再见！

---

## 作者：thekeyto (赞：2)

```cpp
//map 和并查集
#include<iostream>
#include<map>
using namespace std;
int f[20005];
map <string,int> a;//定义map 
int find(int x)
{
    return f[x]==x?x:f[x]=find(f[x]);//一行带过查找和压缩路径 
}
int main()
{
    int n,i,m,k;
    string s,t;
    cin>>n>>m;
    for(i=1;i<=n;i++)
    {
        cin>>s;
        a[s]=i;
        f[i]=i;
    }
    for(i=1;i<=m;i++)
    {
        cin>>s>>t;
        int z=find(a[s]),x=find(a[t]);
        if (z!=x)
        f[z]=x;//把s的祖先指向z 
    }
    cin>>k;
    for(i=1;i<=k;i++)
    {
        cin>>s>>t;
        int z=find(a[s]),x=find(a[t]);
        if (z!=x)
        cout<<"No.\n";else cout<<"Yes.\n"; 
    }
    return 0;
}
```

---

## 作者：skylee (赞：1)

本题基本思想是并查集，在这里补充一个Pascal题解。

首先我们用name数组记录选手的名字，在读入选手名字的同时构建并查集初始状态（用ufs数组储存每个元素的祖先都指向其本身）。

然后读入分组状态，每组学生都是一个合并集合的过程。注意在这里两个选手的名字用空格分隔，因此不能简单地使用readln函数，而要进行字符串处理。在这里我使用了getstr函数，具体操作见代码。

同时我们要注意不能直接用选手的名字做ufs数组的下标，所以在这里我们的name数组就发挥了作用，name数组的下标可以看做每位选手的“编号”，我们在合并时只要处理编号就行了。

对于最后的k个询问，我们只要判断选手的“祖先”是否相同，若相同，则两位选手在同一个组里。

详细过程见代码注释。

'''pascal

```cpp
var
    n,m,k,i:longint;
    name:array[1..20000]of string;//存储选手姓名
    ufs:array[1..20000]of longint;//存储选手祖先
function getstr:string;//字符串读入处理
    var
        ch:char;
    begin
        getstr:='';
        read(ch);
        repeat
            getstr:=getstr+ch;
            if eoln then begin//如果为行末就跳出
                readln;
                exit()
            end;
            read(ch)
        until ch=' '//如果是空格就过滤并跳出
    end;
function find(s:longint):longint;//查询祖先
    var
        t:longint;
    begin
        while ufs[s]<>s do begin//一个优化：将所有相关联的元素直接连接到祖先
            t:=ufs[s];
            ufs[s]:=find(t);//递归调用，自上而下处理
            s:=t
        end;
        exit(s)
    end;
procedure union(const s1,s2:longint);//合并操作
    begin
        ufs[find(s1)]:=find(s2)//将两者祖先合并
    end;
function num(const s:string):longint;//利用name数组获取选手的“编号”
    var
        i:longint;
    begin
        for i:=1 to n do begin
            if name[i]=s then begin
                exit(i)
            end
        end
    end;
procedure union(const s1,s2:string);
    begin
        union(num(s1),num(s2))
    end;
begin
    readln(n,m);
    for i:=1 to n do begin
        readln(name[i]);
        ufs[i]:=i
    end;
    for i:=1 to m do begin
        union(getstr(),getstr())
    end;
    readln(k);
    for i:=1 to k do begin
        if find(num(getstr()))=find(num(getstr())) then begin
            writeln('Yes.')
        end
        else begin
            writeln('No.')
        end
    end
end.
'''
```

---

## 作者：wcfsdcard (赞：1)

用map，然后裸并查集就行了

```cpp

#include <iostream>
#include <string>
#include <map>
using namespace std;
map<string,string> father;
string getf(string v){
    if(father[v]==v) return v;
    else return father[v]=getf(father[v]);
}
void Union(string u,string v){
    string x=getf(u),y=getf(v);
    if(x!=y)
        father[y]=x;
}
int main(){
    int n,m,k;
    scanf("%d %d",&n,&m);
    string s;
    for(int i=1;i<=n;i++){
        cin>>s;
        father[s]=s;
    }
    for(int i=0;i<m;i++){
        string u,v;
        cin>>u>>v;
        Union(u,v);
    }
    scanf("%d",&k);
    string x,y;
    for(int i=0;i<k;i++){
        cin>>x>>y;
        if(getf(x)==getf(y))
            printf("Yes.\n");
        else printf("No.\n");
    }
    return 0;
}

```

---

## 作者：Conical (赞：1)

map容器+string类

**STL大法好！！！**

附代码

>#include<stdio.h>
>#include<iostream>
>using namespace std;
>const int MaxN(20002);
>map < string , int > Name;
>string s,t;
>int Fa[MaxN];
>int gfather(int x)
>{
>if(Fa[x]!=x)
>return Fa[x]=gfather(Fa[x]);
>return x;
>}
>void Union(int x,int y)
>{
>int f1(gfather(x)),f2(gfather(y));
>Fa[f1]=f2;
>}
>int main()
>{
>int N,M,K,i;
>scanf("%d%d",&N,&M);
>for(i=1;i<=N;i++)
>{
>cin>>s;
>Name[s]=i;
>Fa[i]=i;
>}
>for(i=1;i<=M;i++)
>{
>cin>>s>>t;
>Union(Name[s],Name[t]);
>}
>scanf("%d",&K);
>for(i=1;i<=K;i++)
>{
>cin>>s>>t;
>if(gfather(Name[s])==gfather(Name[t]))
>printf("Yes.\n");
>else
>printf("No.\n");
>}
>return 0;
>}

---

## 作者：sycqwq (赞：0)

啊！这不是道模板题吗？——刚看题的我

只要回了并查集，这题分分中切掉，唯一的难点就是字符串处理。

关于字符串处理，c++里有个库函数叫map，，，

```
map<string,string>a;
```

就等同于定义一个类型为字符串，下标为字符串的数组a，本题用这个储存即可。

因为同伴的名字肯定是个字符串，所以数组类型也是字符串。

关于并查集：

先定义队中一个人是队长，然后定义f数组，f[队员的名字]=队长的名字。

于是，这个队所有人的祖先都等于队长的名字。

给出寻找代码
```cpp

string fd(string x)//返回的是一个字符串名字
{
	if(f[x]==x)//如果这个人队的队长是自己，那么他就是队长
		return x;
	else
		return f[x]=fd(f[x]);//如果不是，就继续找下去，顺便把途中的都标记一下。
}
```

给出合并代码：

```cpp

string x,y;//x,y为两个人的名字，这里把输入加上去了
cin>>x>>y;
f[fd(x)]=fd(y);//默认左边的人属于右边的队，fd（x）就直接把他的同伴都合并到那个队去了。fd（y）代表右边的队长。
```

完整代码（无注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string> f;
string fd(string x)
{
	if(f[x]==x)
		return x;
	else
		return f[x]=fd(f[x]);
}
int main(){
	int n,m,k;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		string x;
		cin>>x;
		f[x]=x;
	}
	for(int i=1;i<=m;i++)
	{
		string x,y;
		cin>>x>>y;
		f[fd(x)]=fd(y);
	}
	cin>>k;
	for(int i=1;i<=k;i++)
	{
		string x,y;
		cin>>x>>y;
		if(fd(x)==fd(y))
			cout<<"Yes.";
		else
			cout<<"No.";
		cout<<endl;
	}
	
	return 0;
}

```

---

## 作者：唐一文 (赞：0)

##### 其实这道题很简单的啦
### STL真好用

------------

## 思路
一般的并查集是这样写的：  
$int \ fa[20005];$  
不难发现，它可以转化成这样：  
$map<int,int>fa;$  
那么，对于这题，可以把并查集写成这样：  
$map<string,string>fa;$  
然后再套模板就行了


------------

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
//以下为并查集模板
map<string,string>fa;//STL真好用
string find(string k){//注意类型为string
	if(fa[k]!=k){
		fa[k]=find(fa[k]);
	}
	return fa[k];
}
void unionn(string x,string y){//注意类型为string
	x=find(x);
	y=find(y);
	if(x!=y){
		fa[y]=x;
	}
}
string x,y;
int n,m,p;
int main(){
	cin>>n>>m;
	while(n--){
		cin>>x;
		fa[x]=x;//我 是 我 爸 爸
	}
	while(m--){
		cin>>x>>y;
		unionn(x,y);//合并
	}
	cin>>p;
	while(p--){
		cin>>x>>y;
		if(find(x)==find(y)){//判断他们的祖先是不是同一个
			cout<<"Yes."<<endl;
		}
		else{
			cout<<"No."<<endl;
		}
	}
	return 0;
}
```
#### 跑得还挺快，只用了$12ms$

---

## 作者：孑彧 (赞：0)

# P2256 一中校运会之百米跑 解题报告

### 题目描述

假设一共有N（2<=N<=20000）个参赛选手。（尼玛全校学生都没这么多吧）

老师会告诉你这N个选手的名字。

接着会告诉你M（1<=M<=1000000）句话，即告诉你学生A与学生B在同一个组里。

如果学生A与学生B在同一组里，学生B与学生C也在同一组里，就说明学生A与学生C在同一组。

然后老师会问你K（1<=K<=1000000）句话，即学生X和学生Y是否在同一组里。

若是则输出"Yes."，否则输出"No."

### 思路

这是一道明显的并查集裸题，和亲戚那道题差不多，只不过是将数字编号变为了一个字符串，但是$\mathcal{NO} $ $\mathcal{ PROBLEM}$，我们有一个非常好用的东西叫做$\mathbb{STL}$~~（C++大法好~~

然后其中有一个叫做string的，还有一个叫做map的，于是我们可以开一个map来代替f数组，find的时候直接返回string类型，那这道题就是非常简单的了

### 代码

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<map>
#include<string>
#define maxn 22000
using namespace std;
map<string,string>f;
string find(string x){
	return f[x]==x?f[x]:f[x]=find(f[x]);
}
void merge(string a,string b){
	a=find(a);
	b=find(b);
	if(a==b){
		return;
	}
	f[a]=b;
}
int n,m,k;
int main(){
	cin>>n>>m;
	string s;
	for(int i=1;i<=n;i++){
		cin>>s;
		f[s]=s;
	}
	string z;
	for(int i=1;i<=m;i++){
		cin>>s>>z;
		merge(s,z);
	}
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>s>>z;
		if(find(s)==find(z)){
			cout<<"Yes."<<endl;
		}
		else{
			cout<<"No."<<endl;
		}
	}
	return 0;
}
```



---

## 作者：F_S_R_M (赞：0)

##### 这个题还可以吧
# 思路：
1、定义map，库文件：<map> （万能头也行）
  
格式就是代码上那样（我也是最近刚学会），就是定义的数组中都是字符串的时候用。

2、输入每个人的名字，让每个人集合里的“老大（根节点）”都等于自己

3、输入两个人名字，如果两个人的“老大（根节点）”不相等，就说明不在同一个集合里面，就将他们加入同一个集合。

4、最后输入两个人，如果两个人在集合中“老大（根节点）”相同，就说明在同一集合中，输出Yes.

#### 特别提醒：

输出的后面有个点“Yes.”“No.”
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string> a;
string find(string x)
{
	if(x!=a[x])
	a[x]=find(a[x]);
	return a[x];	//find函数寻找“老大”（根节点） 
}
void lian(string x,string y)
{
	a[y]=x;		//lain函数就是将两个名字放到同一集合中 
}
int main()
{
	int n,m;
	string x,y;
	scanf("%d%d",&n,&m);	//输入 
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		a[x]=x;			//将他们的"老大"都设成自己 
	}
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		string r1=find(x);
		string r2=find(y);
		if(r1!=r2)
			lian(r1,r2);//注意这里放到统一集合中的是r1和r2 
	}
	int k;
	cin>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>x>>y;
		if(find(x)==find(y))	//如果是同一“老大”输出：Yes. 
		cout<<"Yes."<<'\n';		//有个点！！！！ 
		else
		cout<<"No."<<'\n';		//有个点！！！ 
	}
	return 0;
}

```


---

## 作者：kindle (赞：0)

把字符串的存储方式变成数字，其他的就可以继续套模版啦！

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;
int n, m, k, pre[20005];

void Initialize () {
    for (int i = 1; i <= n; i++)
        pre[i] = i;
}

int Find (int x) {
    if (x == pre[x])
        return x;
    return pre[x] = Find(pre[x]);
}

void Join (int x, int y) {
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy)
        pre[fy] = fx;
}

int main() {
    cin >> n >> m;
    string s;
    unordered_map<string, int> hash;
    for (int i = 1; i <= n; i++) {
        cin >> s;
        hash[s] = i;
    }
    Initialize();
    for (int i = 1; i <= m; i++) {
        string str1, str2;
        cin >> str1 >> str2;
        Join(hash[str1], hash[str2]);
    }
    cin >> k;
    for (int i = 1; i <= k; i++) {
        string a, b;
        cin >> a >> b;
        if (Find(hash[a]) == Find(hash[b]))
            cout << "Yes." << endl;
        else
            cout << "No." << endl;
    }
    
    return 0;
}
```


---

## 作者：zhangyuhan (赞：0)

**~~并查集+暴力吼啊~~**

这题其实也就是并查集无脑板子题，不过需要合并的是字符串。

其实也很简单。只需要把每个字符串按照输入顺序对应的下标来进行合并就可以了。

在询问的时候，对于每个询问的字符串，暴力找下标再判是否在同一集合就可以了（~~怎么没有被卡死~~）

并查集还没学？先学一学，掌握基本操作，再把[这道题](https://www.luogu.org/problemnew/show/P3367)A了

$AC$ $Code$

```cpp
#include <iostream>
using namespace std;

int fa[1000010];

string str[1000010];//用字符串数组存便于查找字符串下标

int n,m,k;

int init(){
	for(int i=1;i<=n;i++)
		fa[i]=i;
}//并查集初始化（注意一定要初始化！否则等于白打）

int findname(string s){
	for(int i=1;i<=n;i++)
		if(s==str[i])
			return i;
}//查找字符串下标

int find(int x){
	if(fa[x]!=x)
		fa[x]=find(fa[x]);
	return fa[x];
}//带路径压缩的“查”

void unite(int x,int y){
	x=find(x),y=find(y);
	if(x==y)
		return ;
	fa[x]=y;
}//基于“查”上面的“并”

bool same(int x,int y){
	return find(x)==find(y);
}//判断两个字符串的下标（及两个字符串）是否在同一集合内

int main(){
	cin>>n>>m;
	init();//初始化
	for(int i=1;i<=n;i++)
		cin>>str[i];
	for(int i=1;i<=m;i++){
		string s1,s2;
		cin>>s1>>s2;
		int x=findname(s1),y=findname(s2);
		unite(x,y);
	}//读入+合并
	cin>>k;
	while(k--){
		string s1,s2;
		cin>>s1>>s2;
		int x=findname(s1),y=findname(s2);
		if(same(x,y))
			cout<<"Yes.\n";
		else
			cout<<"No.\n";
	}//询问在线搞
	return 0;//完结撒花！
}
```

不过耗时有点慢，132ms。。。

---

## 作者：ZhangFuqun (赞：0)

## Map

STL大法好用！ 实现的思路就是，把每个名字对应一个编号,用map存，然后就 **完完全全** 是并查基的模板了。 

看上去很清晰很明白啊~~

下面是完整代码    

    头函数#include<map>
```cpp

map<string,int>mp;
int n,m,q,f[10005];

int getf(int v)
{
	return v==f[v]? v:f[v]=getf(f[v]);
}

void merge(int a,int b)
{
	a=getf(a);
	b=getf(b);
	if(a!=b)
	{
		f[b]=a;
	}
}

int main()
{
	for(int i=1;i<=10003;i++)
		f[i]=i;
		
	cin>>n>>m;
	string s,s1,s2;
	
	for(int i=1;i<=n;i++)	{
		cin>>s;
		mp[s]=i;
	}
	for(int i=1;i<=m;i++)
	{
		cin>>s1>>s2;
		if(mp[s1]<mp[s2])  //必须严格按照 a<b, merge(a,b) 
			merge(mp[s1],mp[s2]);
		else
			merge(mp[s2],mp[s1]);
	}
	cin>>q;
	while(q--)
	{
		cin>>s1>>s2;
		if( getf(mp[s1])==getf(mp[s2]))
			cout<<"Yes."<<endl;
		else
			cout<<"No."<<endl;
	}
}
```

---

## 作者：我没有小白 (赞：0)

这数据真的是太水了点。。。。。。

毕竟我还没有合并过字符串，所以我就合并这两个字符串的ascll码，我感觉相同的几率会很大，不过数据是真的良心，显示AC界面的时候还有些不可思议

我们假设每个字符串的ascll码的和是不同的，所以我们就可以用ascll码当他们的编号，然后用朴素的并查集操作就一边过了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n , m , k;
int f[30000];
int find(int x)
{
	if(f[x] == x)return x;
	else return f[x] = find(f[x]);
}
//find函数不会去做模板题 
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i ++)
	{
		int sum = 0;
		char s[50000];
		scanf("%s",s);
		for(int j = 0; j < strlen(s); j ++)
			sum += int(s[j]);
		f[sum] = sum;//这个是给f数组赋值，每个人都是自己的爸爸 
	}
	for(int i = 1; i <= m; i ++)
	{
		int sum1= 0 , sum2 = 0;
		char s1[5000] , s2[5000];
		scanf("%s%s",s1,s2);
		for(int j = 0; j < strlen(s1); j ++)
			sum1 += int(s1[j]);//这个是加和ascll值，下面也是一样 
 		for(int j = 0; j < strlen(s2); j ++)
			sum2 += int(s2[j]);
		int k = find(sum1) , j = find(sum2);
		if(k!=j)
			f[k]=j;//这个是合并集合 
	}
	cin >> k;
	for(int i = 1; i <= k; i ++)
	{
		int sum1 = 0,sum2 = 0;
		char s1[5000] , s2[5000];
		scanf("%s%s",s1,s2);
		for(int j = 0; j < strlen(s1); j ++)
			sum1 += int(s1[j]);
		for(int j = 0; j < strlen(s2); j ++)
			sum2 += int(s2[j]);
		if(find(sum1) == find(sum2))cout << "Yes."<<endl;
		else cout << "No."<<endl;
	}//输出操作 
}
//完结撒花 
```
					管理大大求过小妹谢谢啦

---


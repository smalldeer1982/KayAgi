# 情书

## 题目背景

一封好的情书需要撰写人全身心的投入。CYY同学看上了可爱的c**想对她表白，但却不知道自己写的情书是否能感动她，现在他带着情书请你来帮助他。



## 题目描述

为了帮助CYY，我们定义一个量化情书好坏的标准感动值。判断感动值的方法如下:

1. 在情书的一句话中若含有给定词汇列表中的特定单词，则感动值加1，但每一单词在同一句话中出现多次感动值不叠加，不同单词不受影响。保证输入的单词不重复。
2. 每句话以英文句号定界。
3. 全文不区分大小写。


## 说明/提示

对于所有的数据，保证1 ≤ n ≤ 100，每个单词不超过50字符，全文不超过1000字符。


## 样例 #1

### 输入

```
3
love
so
much
I love you so much.
```

### 输出

```
3```

# 题解

## 作者：起名真的很难 (赞：89)

这道题涉及了许多繁琐的步骤：

1.关键词判重

2.判断句子是否结束

3.大小写的统一

~~4.情书写得好不好~~

关于第①点用一个use数组判断，若use[i]!=0那么word[i]就是出现过

第②点就是使用找那个句点，~~很easy的~~

第③点，这里推荐一个STL transform，还是比较好用的（tolower是变小写，toupper是变大写）

PS:本来找句点我还用了个好东西：
```cpp
.find_first_of(".");
.find_last_of(".");
就是找第一个（最后一个）句点，如果有就返回位置，没有就返回-1
```

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tot,use[2010];
string word[2010],sen,sent="";

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)//++i比i++快
	{
		cin>>word[i];
		transform(word[i].begin(),word[i].end(),word[i].begin(),::tolower);
        //关键词变小写
	}
	getchar();//不能少啊，坑我好久
	getline(cin,sen);
	transform(sen.begin(),sen.end(),sen.begin(),::tolower);//整句变小写
	for(int i=0;i<sen.size();++i)
	{
		if(sen[i]=='.')//如果是  .
		{
			for(int j=1;j<=n;++j)
			{
				if(sent==word[j]&&!use[j])
				{
					use[j]=1,++tot;
					break;//其实这里还可以优化，但我懒
				}
			}
			sent="";
			memset(use,0,sizeof(use));//进入下一句,所有关键词又都可以增加好感
			continue;
		}
		if(sen[i]==',')
		{
			for(int j=1;j<=n;++j)
			{
				if(sent==word[j]&&!use[j])//与句号类似，没有清空use数组
				{
					use[j]=1,++tot;
					break;
				}
			}
			sent="";
			continue;
		}
		if(sen[i]==' ')
		{
			for(int j=1;j<=n;++j)
			{
				if(sent==word[j]&&!use[j])//如果是空格说明一个单词结束了
				{
					use[j]=1,++tot;
					break;
				}
			}
			sent="";
			continue;
		}
		sent+=sen[i];//不是句点不是逗号不是空格，那肯定是字母了
	}
	printf("%d",tot);//水完了
	return 0;
}
```

我可不可以求一波赞٩(๑❛ᴗ❛๑)۶

---

## 作者：一把丶抱住鑫 (赞：35)


**亲测测试点**

```
At there waiting for you.
Be with you.
Call you just to say hi. 
Dont mind you shout at me. 
Envision the whole of you.
Forever stand by you.
Give you what you need.
Have you enjoy your life.
I love you. 
Just want to stay with you.
Keep you close at heart.
Learn to know you.
Make a difference in your life.
Never make you cry. Offer support.
Put you in my heart.
Quiet your fear. Run with you. 
Sing a song for you.
Taciturn knight. Understand you.
Value you.
Work beside you.
XL love. 
You are all the time so addictive.
Zeal for you.



翻译
在那里等你。
和你在一起。
打电话给你只是想打个招呼。
不介意你对我大喊大叫。
想象你们所有人。
永远支持你。
给你你需要的。
你过得愉快吗？
我爱你。
只想和你在一起。
把你放在心里。
学会了解你。
改变你的生活。
永远不要让你哭。
提供支持。
把你放在我心里。
平息你的恐惧。
跟你一起跑。
为你唱首歌。
沉默的骑士。
明白你的意思。
珍惜你。
在你身边工作。
XL爱情。
你总是那么容易上瘾。
对你的热情。

```


**步入正题**
------------

这个题注意大小写。

注意you 和your

注意发现句号后标记数组要清零

下面有一坨你们看不懂的其实我也看不懂，机房大佬写的。

具体意思就是判断you和your这个包含关系，如果没有那坨的话your 就算一个了。
```c
#include<bits/stdc++.h>
using namespace std;
string s,u;

map<string,bool>can;

int n,ans;
string v[106];
int main()
{
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	getline(cin,u);
	getline(cin,s);
	for(int i=1;i<=n;i++){
		for(int j=0;j<v[i].size();j++){
			if(v[i][j]>='A'&&v[i][j]<='Z')v[i][j]+=32;
		}
	}
	for(int i=0;i<s.size();i++){
		if(s[i]>='A'&&s[i]<='Z')s[i]+=32;
	}
	for(int j=1;j<=n;j++){
		for(int i=0;i<s.size();i++){
			if(s[i]=='.')can.clear();
			if(s.substr(i,v[j].size())==v[j]&&(s[i+v[j].size()]=='.'||s[i+v[j].size()]==','||s[i+v[j].size()]==' ')){
				
				if(can[v[j]])continue;
				can[v[j]]=1;
				ans++;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```
表白成功！

---

## 作者：juruo_zjc (赞：18)

这题很简单，基本上就是根据题目听话就可以，我用了STL中的set操（xia）作（gao)

具体见代码吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
set<string>se,se2;
int ans,n;
int main()
{
    scanf("%d",&n);
    string a;
    for(int i=1;i<=n;i++){
        cin>>a;
        for(int i=0;i<a.length();i++)
			if(a[i]>='a'&&a[i]<='z') a[i]-=32;
        se.insert(a); 
    }
    char ch=getchar();
    string b;
    while(scanf("%c",&ch)==1){
        if(ch=='\n')break;
        if((ch>='A'&&ch<='Z')||(ch>='a'&&ch<='z')){
            if(ch>='a'&&ch<='z')ch=ch-32;
            b+=ch;
        }
        else{
            if(!b.empty()){
                if(se.count(b))se2.insert(b);
                b.clear();
            }
            if(ch=='.')ans+=se2.size(),se2.clear();
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Obito (赞：13)

这题很多人的代码都比较长，菜鸡在这里介绍一种较简单，又好理解的方法。

1.我们可以把感动值放到一个map映射上去，每次在正文中取出单词进行比较，具体看代码。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000;
int n;
string str[maxn];
map<string,bool>mp;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		transform(s.begin(),s.end(),s.begin(),::tolower);//统一大小写
		mp[s]=1;
	}
	char c;
	int ans=0,cnt=0;//ans是记录当前的答案，cnt是记录一句话中出现了多少感动词
	string s="";//记录词汇
	while(~scanf("%c",&c)){//持续读入，一定要用scanf，cin读不了空格
		if(c>='a'&&c<='z')s+=c;
		else if(c>='A'&&c<='Z')s+=c;//一个一个取出完整词汇
		else {
			transform(s.begin(),s.end(),s.begin(),::tolower);//统一大小写
		//	cout<<s<<endl;
			if(mp[s]==1)//如果这是一个感动词的话，词数++，答案++，记录单词
				ans++,cnt++,str[cnt]=s;
			mp[s]=0;//避免重复，先将映射变成0
			s="";
		}
		if(c=='.'){
			for(int i=1;i<=cnt;i++){//一句完结，将原来词汇放回映射
				mp[str[i]]=1;str[i]="";
			}
			cnt=0;
		}
	}
	cout<<ans<<endl;//完结散花
	return 0;
}

```
如有不懂，可以私聊问我QWQ

---

## 作者：黃粱一夢 (赞：10)

发现题解里面都是dalao用STL做的（~~蒟蒻瑟瑟发抖~~），这里我发一个不用STL的A（bao）C（li）打法。

这道题目坑点还是比较多的（不过仔细审题问题就不大）：

1.全文不区分大小写，不知道为什么，评测机不支持strlwr和strupr函数，所以转换大小写时要手打；

2.同一个能加感动值的单词在一句话中出现多次不会重复加（没看到这一点被坑了好几次）；

3.每个单词间以空格或逗号或句号作为分隔。

这题数据范围很小，所以不用担心T，下面附上代码：

```cpp
#include<cstdio>
#include<cstring>
char s[1005],a[105][55];
//s是情书正文，a是能加感动值的词汇 
int n,ans,i,j,k,f;
bool r[105];//r判断这个单词在本句是否出现过 
int main(){
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        scanf("%s",a[i]);
        for(j=0;j<strlen(a[i]);j++)
            if(a[i][j]>='A'&&a[i][j]<='Z')
                a[i][j]+=32;//统一转换成小写 
    }
    getchar();gets(s);
    for(i=0;i<strlen(s);i++)
        if(s[i]>='A'&&s[i]<='Z')
            s[i]+=32;
    i=0;memset(r,false,sizeof(r));
    while(i<strlen(s))
        if(s[i]>'z'||s[i]<'a'){
            if(s[i]=='.')//如果是句号那就是一句话结束，所以清空r 
                memset(r,false,sizeof(r));
            i++;continue;
            //因为从每个单词的第一个字母开始一个一个比较过去，
            //所以对于不是字母的都直接跳过
        }
        else{
            for(j=1;j<=n;j++)
                if(s[i]==a[j][0]&&(!r[j])){//如果第j个能加感动值的单词在本句出现过就跳过该单词 
                    f=1;int now=i+1;
                    for(k=1;k<strlen(a[j]);k++,now++)
                        if(s[now]!=a[j][k]){
                            f=0;break;
```
}//判断是不是能加感动值的单词
```cpp
                    if(f)
                        if(s[now]==' '||s[now]==','||s[now]=='.'){
                            ans++;r[j]=true;break;        
                            //判断这个单词是否结束，如果s[now]不是空格或逗号或句号，
                            //那么表明a[j]是这个单词的子串，不能算进去
                        }
                }
            while(s[i]>='a'&&s[i]<='z')i++;
            //每个单词要从首字母开始判，所以非首字母的要跳过 
        }
    return printf("%d\n",ans),0; 
}
```

---

## 作者：Tgotp (赞：8)

算法： trie


过程：来个比较好理解的，直接套上trie


然后对于前n个建trie，然后对于文本直接在trie上跑跑。


对于 . 看成一句话的理解，可以是如果你在当前的话里面有使用  . ，就把此时的val初始为cnt，如果val[x]  != cnt，才进行更新。


ps:一开始没有取消重定向竟然能用10分？


[代码](http://tgotp.science/p2264-%E6%83%85%E4%B9%A6/)


---

## 作者：ywjzxx (赞：5)

我仍然在无人问津的阴雨霉湿之地

和着雨音唱着没有听众的歌曲

人潮仍是漫无目的地向目的地散去

忙碌着无为着继续
等待着谁能够将我的心房轻轻叩击

即使是你也仅仅驻足了片刻便离去

想着或许下个路口会有谁与我相遇

哪怕只一瞬的奇迹

首先希望CYY表白成功

咳咳

扯回正题来

这道题目的大致意思就是在情书的一句话中若含有给定词汇列表中的特定单词
有几个要点

1.首先应该把全文转换为小写或者大写

2.我们可以用map进行标记

3.碰见句号需要还原标记，同时判断是否满足题意

4.碰见空格或者，则表明是一个单词，需要进行判断

满足以上四点要求，再加上一些细微的操作，或许这题也不是很难

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>vis;//map大法用来标记 
int ans,n;
string s[2001];//存放给定词汇列表，方便还原现场 
string t;//存放一句话中的单词 
string sb;//用来存放文章 
int main(){
	cin>>n;//读入 
	for(int j=1;j<=n;j++){
	    string now;
		cin>>now;
		for(int i=0;i<now.size();i++){
			if(now[i]>='A'&&now[i]<='Z') now[i]+=32;
		}
		vis[now]=1;//标记为1 
		s[j]=now;//记录 
	}
	string dd;
	getline(cin,dd);//!!!因为getline会读入回车，所以我们先把回车读掉，注意！！一定要用geiline读入回车，千万不能用char读，被坑惨了 
	getline(cin,sb);
	for(int i=0;i<sb.size();i++)
	    if(sb[i]>='A'&&sb[i]<='Z') sb[i]=sb[i]+32;//全文转换为小写 
	t="";
	for(int i=0;i<sb.size();i++){
		if(sb[i]=='.'){//判断为句号 
			if(vis[t]==1){//如果没被访问过，答案++ 
				ans++;
				vis[t]=0;
			}
			t="";
			for(int j=1;j<=n;j++)//句子结束了，还原现场 
			   vis[s[j]]=1;
		}
		else if(sb[i]==' '||sb[i]==',') {//否则只能是一个单词，不要还原现场 
			if(vis[t]==1){
				vis[t]=0;
				ans++;
			}
			t="";
	    }
	    else t+=sb[i];//存放单词 
	}
	cout<<ans<<endl;//祝你表白早日成功++ 
	return 0;
}

```


---

## 作者：peterwuyihong (赞：5)

# 怎么没有Python的题解鸭
## 那我来水一发
#### 前置芝士
import re->re库

re.findall(a,b)->返回b中a的串(list)

STR.replace(a,b)->返回把a换成b的字符串

STR.lower()->返回小写

STR.split(a)->以a为分隔符，返回list
### 贴上Python水代码一枚
```python
import re
n=int(input())
s=[]
for i in range(0,n):
     s.append(input().lower())#加入小写
#print(s)
p=input().lower()#源字符串小写
p=p.split('.')#分割每句话
ans=0
for each in s:#遍历每个爱♂的字符串
     each=' '+each+' '#为了判断整个词
    # print(each+':')
     for one in p:#遍历每个句子
          one=' '+one+' '#避免首尾无空格
          one=one.replace(',',' , ')#替换该死的','
         # print(one)
          if len(re.findall(each,one))!=0:#若找到
               ans+=1
print(ans)#输出！！！

```
###### 望管理员大大鼓励一下~~毕竟是唯一一篇Python~~

---

## 作者：shuiyuhan (赞：5)

怎么又没有p的题解啊？那我来水一发

题目描述：求~~taoyc~~给~~hyw~~的情书中能让~~hyw~~感动的单词的数量(求放过)

显然，因为1 ≤ n,m,k ≤ 100，故可以直接~~暴力~~，只不过有点坑，要注意特判一下

代码：~~不吸氧貌似也能过~~
```pascal
// luogu-judger-enable-o2
var
  s:array[0..100005] of ansistring;
  i,j,n,k,m,t,l,p,t1,ans,t2,t3,t4:longint;
  s1,s2,s3:ansistring;
  f:boolean;
begin
  readln(n);
  for i:=1 to n do begin readln(s[i]); s[i]:=lowercase(s[i]); end;//lowercase表示把s[i]统一转小写
  readln(s1);
  for i:=1 to length(s1) do
  if s1[i]=',' then s1[i]:=' ';//因为，与' '有相同的作用，故把，转为' '，
  s1:=lowercase(s1);//作用同上
  l:=1;
  while true do
  begin
    t:=pos('.',s1);//寻找'.'在s1中的位置
    if t=0 then break;
    s2:=copy(s1,l,t-l+1);//把这一段copy出来下面直接查找s2
    delete(s1,l,t-l+1);//把'.'给删掉避免误判
    p:=1;
    while true do//这段是来感动hyw的单词的(求放过)
    begin
      t1:=pos(' ',s2);
      if t1=0 then break;
      s3:=copy(s2,p,t1-p);//s3是一个单词
      f:=true;
      for i:=1 to n do if s3=s[i] then begin inc(ans); f:=false; break; end;//查找这个单词是否在s中出现过
      delete(s2,p,t1-p+1);
      while true do//如果出现过，那么删去重复的单词
      begin
        if f then break; 
        t4:=pos(s3,s2);
        if (t4=0) then break;
        delete(s2,t4,length(s3));
      end;
    end;
    s3:=copy(s2,p,length(s2)-p);//因为这种方法会漏下最后一个单词，所以特殊处理一下
    for i:=1 to n do if s3=s[i] then begin inc(ans); break; end;
    delete(s2,p,t1-p+1);
  end;
   s3:=copy(s1,p,length(s1)-p);
   for i:=1 to n do if s3=s[i] then begin inc(ans); break; end;
  writeln(ans);
end.


```
~~ps:I love hyw ——taoyc~~ (求放过)

C++党的放个我同学的代码QWQ：
```cpp
#include<iostream>
#include<string>
#include<map>
#include<cstring>
#include<cstdio>
using namespace std;
map<string,bool> t;
int n;
long long ans;
string a[105];
int main(){
    cin >> n;
    for (int i=1;i<=n;i++){
        cin >> a[i];
        for (int j=0;j<a[i].size();j++)
            if ('A'<=a[i][j]&&a[i][j]<='Z') a[i][j]+=32;
    }
    getchar();
    char s[1005];
    gets(s);
    for (int i=0;i<strlen(s);i++)
        if ('A'<=s[i]&&s[i]<='Z') s[i]+=32;
    for (int i=1;i<=n;i++){
        string now="";
        for (int j=0;j<strlen(s);j++)
            if (s[j]==' '||s[j]==','||s[j]=='.'){
                if (!t[a[i]]&&a[i]==now){
                    ans++;
                    t[now]=1;
                }
                if (s[j]=='.') t[a[i]]=0;
                now="";
            }else now+=s[j];
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：时律 (赞：3)

~~这种题一眼望去就是要用STL的~~

~~总感觉这是道假蓝题啊~~

本题中几个点：

1.其实逗号和空格是一种东西

2.大小写统一

~~然后就没了？这是道很简单的题啊，5分钟就切掉了~~

~~强烈要求加强数据范围！~~

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,bool> x;//每次的重复判断
map<string,bool> h;//给出的单词表
string xx(string a)//转成小写(XiaoXie)
{
	for(int i=0;i<a.size();i++)
		if(a[i]>='A' and a[i]<='Z')
			a[i]+=32;
	return a;
}
int main()
{
	int a,ans=0;
	string u,w="";
	cin>>a;
	for(int i=1;i<=a;i++)
	{
		cin>>u;
		h[xx(u)]=1;//处理掉，如果在后面处理单词的时候还要一个个找会T（虽然没试过）
	}
	getchar();
	getline(cin,u);
	for(int i=0;i<u.size();i++)
	{
		if(u[i]=='.' or u[i]==',' or u[i]==' ')
		{
			string v=xx(w);
			if(h[v]==1)
				if(x[v]==0)
					x[v]=1,ans++;//如果是单词表里的并且没出现过，那就标记成出现过并把答案++
			if(u[i]=='.')
				x.clear();//如果是句号重新开始
			w="";
		}
		else
			w+=u[i];
	}
	cout<<ans;//完结撒花！
}
```

---

## 作者：weak_ddb (赞：3)

看到题目感觉怎么这么水，愧对为提高＋省选-。但有几个点还是很坑的。


-----------------------------------正文分割线-------------------------------------------

看算法标签（字符串）~~这不很明显吗~~

本蒟蒻的思路很特别~~（大佬别吊打）~~：总体我们将单词作为外循环，将句子作为内循环，可以大大降低程序长度，因为句子只要循环一遍（也就是O(n)），单词也只循环一边，整体复杂度O(nm)

看条件3：全文大小写不区分。所以我们要统一大小写，可以用tolower()或toupper()来转换。

看条件1：**每句话**中感情词出现多次只算一次。我们以句号做分割点，立一个flag代表单词有没有在此句子中出现过。

~~看条件2：看什么看~~

附：利用C++里string可直接加和比较，我们用string k来记录当前单词,并判断是否对应。



------------


```
#include<bits/stdc++.h>
using namespace std;
string a[105];//各种单词
char s[1005];//句子
int n,love;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        for(int j=0;j<a[i].length();j++)
        a[i][j]=tolower(a[i][j]);//降为小写
    }
    getchar();//gets()会将回车读掉，字符串就读不到
    gets(s);
    for(int i=0;i<strlen(s);i++)
    s[i]=tolower(s[i]);
    for(int i=1;i<=n;i++)
    {
        string k="";//当前单词载体
        bool flag=true;//是否有当前单词，没有为true，有为false
        for(int j=0;j<strlen(s);j++)
        {
            if(s[j]==' '||s[j]=='.'||s[j]==',')//断开单词
            {
                if(a[i]==k&&flag){//符合条件且在此句子中没有出现
                    love++;
                    flag=false;//标为出现
                }
                if(s[j]=='.')flag=true;//又一个句子，重新起头
                k="";//单词清空
            }
            else k+=s[j];//加上字母
        }
    }
    cout<<love
}
```



------------


---

## 作者：想念就像犯罪 (赞：3)

第一次写题解，主要是有个大佬对我帮助贼大，这题我提交一直错，然后看了有位大佬的题解指出原来逗号也算单词的分隔符，才做出来的。其实这题思路很简单，因为给的数据不大，基本就是每个单词每个单词的比较就可以。我简单的把我的思路描述一下。


            
```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    FILE *op;
    int n,ka=0,sum=0,a;
    char s[200][200],sa[2000],kb[200],kc[200];
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    scanf("%s\n",&s[i]);
    gets(sa）;/*前面是输入就不说了*/
    for(int j=0;j<n;j++)
       kc[j]=0;/*初始化所有的单词都还没加过分*/
    for(int i=0;i<strlen(sa);i++)/*查找到所给文本的最后*/
    {
        a=0;
    if(sa[i]==' '||sa[i]=='.'||sa[i]==',')/*每找到一个独立的单词就开始比较*/
        {
            for(;ka<i;ka++)
            {
            kb[a++]=sa[ka];    /*将找到的单词分离出来*/
            }
            for(int j=0;j<n;j++)/*比较每个能加分的单词*/
            {
                if(strcasecmp(kb,s[j])==0&&kc[j]==0)/*利用函数判断分离出来的单词能不能加分，且该句子中只出现一次*/
                {
                    ++sum,kc[j]=1;/*出现了就加分，且标记该句子中已经出现了该加分单词*/
                }
            }
            ka=ka+1;
        }
        memset(kb, 0, sizeof(kb));/*对储存分离出单词的数组初始化*/
        if(sa[i]=='.')/*判断是不是已经结束了一句话了*/
        {
            for(int j=0;j<n;j++)
            kc[j]=0;/*一句话结束了就把标记是否已经加分的单词清零*/
        }
    }
    printf("%d",sum);
    return 0;
} 
/*第一次写，有什么错误，实在是不好意思了*/
```

---

## 作者：vеctorwyx (赞：2)

#### 读完题：~~好像不难（其实我没读题）~~

看完样例：“哇，出题人好良心！标点后面还有空格，用cin好了。”

然鹅。。。~~[点3 点7并不这么想](https://www.luogu.com.cn/record/29005668)~~

### 所以要用gets 输入情书正文

用一个字符数组（字符串）c存 ~~情书~~ 正文，然后用函数（好像不用函数也行）区分单词存入另一个数组b，同事用一个bool数组q记录使用特殊单词的情况

### 但请注意句末重置q的时间！

遇到"."时，记录一下，判断完特殊单词后再重置，也可以下次区分单词时重置

当输入n==0，需要特判输出0（~~那必然是0~~），[不然会RE](https://www.luogu.com.cn/record/29008095)（~~可能是Linux的特性~~，反正Windows系统不会RE）

~~其他好像没什么了~~

跑的还行一共[用了39ms](https://www.luogu.com.cn/record/29008106)（没开O2 O3缓存也没删）~~（虽然我以为会TLE）~~

上代码:
```
#include<bits/stdc++.h>
using namespace std;
int n,ji,jii,j;
char a[110][55];//记录特殊单词
char b[55],c[1010];
int ans;
bool q[110],flag;
void strlwr1(char a[110])//大写转小写
{
	for(int j=0;j<55;j++)
	if(a[j]<'a'&&a[j]>='A')
	a[j]+='a'-'A';
}
void  qfdc()//区分单词
{
	while(c[jii]!=' '&&c[jii]!='.'&&c[jii]!=',')
	{
		b[j]=c[jii];
		jii++;//jii记录查到情书正文的什么位置了
		j++;//ji记录单词的位置
	}
	if(c[jii]=='.')//记录重置
	flag=1;//要重置
	jii++;
	j=0;//单词用完要被覆盖掉，别忘了归零
}
int main()
{
	cin>>n;
	if(n==0)//特判
	{
		cout<<0;
		return 0;
	}
	for(int i=0;i<=n;i++)//多输入一次是因为输入n后直接进入输入a,会空一个数组（我是这么理解的）
	{
		gets(a[i]);
		strlwr1(a[i]);
	}
	gets(c);
	while(jii<strlen(c))//c没被遍历完
	{
		qfdc();
                strlwr1(b);
                for(int i=1;i<=n;i++)//枚举每一个特殊单词
                {
                  if(strcmp(a[i],b)==0&&q[i]==0)//是特殊单词
                  {
                    ans++;//答案加一
                    q[i]=1;//记录为使用过
                  }
                }
                if(flag)//一句话结束了
                {
                  memset(q,0,sizeof(q));//重置特殊单词使用情况
                  flag=0;//重置flag
                }
                memset(b,0,sizeof(b));//要有以防下次输入的单词比这次短然后下次的单词后接着这次的部分单词（小心!会WA!）
	}
 	cout<<ans;
	return 0;
}
```

---

## 作者：mysssss (赞：2)

# map映射大法好！！

看到这题，别被蓝标吓到了

其实感觉思路还是比较简单的

窝因为昨天写了道稳定婚姻，所以首先想到的是map映射

输入每一个单词然后在lvlet里面标记

用getline输入情书之后

整一段跑一次

看到数字句号逗号空格这些跳过

判每个单词

若这个单词在lvlet中是被标记上的

则好感ans++

之后再处理下细节就ok了



------------


## 细节提醒

1.在getline前要写getchar（）否则要完

2.看题，注意单词不区分大小写，我个人的写法是：全部变为小写

3.还是看题，注意同一个好感up单词在一个句子里出现2次，好感度只++一次，所以开一个flag标记，遇到句号再clear（）就好了

4.for里面每次判断句段中的一个单词后，记得要给动态字符串初始化



------------
具体请看代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
string word[200],s,box;
map<string ,int> lvlet,flag;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	cin>>word[i];
	for(int j=0;j<word[i].size();j++)
	if(word[i][j]>='A'&&word[i][j]<='Z')
	word[i][j]+=32;//全部变成小写
	lvlet[word[i]]=1;//标记
    }
        getchar();//缓冲
	getline(cin,s);
	for(int i=0;i<s.size();i++)
	{
	    if(s[i]==' '||(s[i]>='0'&&s[i]<='9')||s[i]==','||s[i]=='.')
	    {
	    	if(lvlet[box]==1&&flag[box]==0)
	    	{
	    	ans++;
	    	flag[box]=1;//标记，表示已在这个句子里出现过
	        }
	        box="";//初始化
	        if(s[i]=='.')//一个句子的结束
	        flag.clear();//标记初始化
	    }
	    else
	    {
	    if(s[i]>='A'&&s[i]<='Z')
	    box+=s[i]+32;//放进box里面也要变成小写
	    else
	    box+=s[i];
	    }
	}
	printf("%d",ans);//输出
    return 0;	
} 
```
差不多就是这样

个人感觉理解执行起来还算OK

还请巨佬们多多指教

祝各位csp S/J rp++;！！！

---

## 作者：thoq (赞：2)

说说自己的**原创思路**。

考虑用两个map，一个(m)用来标记导致感动值提升的单词，另一个（vis）标记当前句中的单词（以句号为准）:

```
map<string,int>m;
map<string,int>vis;
int n,ans;
```

全文不区分大小写，考虑将**全文转小写**

我们准备写一个函数solve(string s),统计提升的感动值，于是我们得到了清晰明了的**主程序**：

```
int main()
{
	string s;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		int len=s.size();
		for(int i=0;i<len;i++)
			s[i]=tolower(s[i]);//转小写 
		m[s]=1;//标记导致感动值提升的单词 
	}
	while(cin>>s)solve(s);//统计 
	printf("%d\n",ans);
	return 0;
}
```

接下来只剩solve了：

每句话以英文句号定界，遇到句号**清空vis**

但没空格的一句话会有几个句号呢？考虑将遇到句号的句子**截开**，然后……

**递归！！！**（奇葩思路）

完整代码：（应该算比较短的了）

```cpp
#include<bits/stdc++.h> 
using namespace std;
map<string,int>m;
map<string,int>vis;
int n,ans;
void solve(string s)
{
	int len=s.size();
	for(int i=0;i<len;i++)
	{
		if(isalpha(s[i])) //是否为英文字母 
			s[i]=tolower(s[i]);
		else if(s[i]==',')s[i]=' ';
		else if(s[i]=='.')
		{
			solve(s.substr(0,i));//解决'.'前的部分 
			vis.clear();//一句结束 
			solve(s.substr(i+1,len-i-1));//解决'.'后的部分 
			return;//此时就不要继续了 
		}
	}
	stringstream ss(s);
	while(ss>>s)
	{
		if(!vis[s]&&m[s])ans++;
		vis[s]=1;//当前句中出现此单词 
	}
}
int main()
{
	string s;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		int len=s.size();
		for(int i=0;i<len;i++)
			s[i]=tolower(s[i]);//转小写 
		m[s]=1;//标记导致感动值提升的单词 
	}
	while(cin>>s)solve(s);//统计 
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：离子键Ionic_Bond (赞：1)

## 根据题意模拟就是了，
## STL大法好就是了。
# 用到的sao操作：

## A.让cin读空标识符（空格、回车）
cin是c++中istream库的一个类，然而为了方便数和字符的分割，cin在定义时会自动不读空标识符，但是某些时候，比如说这个题，就必须读空格。

但是c++语言的开发者们不会把输入输出流这样一个颇具c++特色的东西扼杀在摇篮里，他们在**输入流类**中加入了一个参数：**skipws**

这个参数掌管cin是否读入空字符，具体操作：

```cpp
std::cin>>std::noskipws;//关闭空符阈，接下来cin可以读入空标识符
std::cin>>std::skipws;//开启空符阈，接下来cin不可以读入空标识符
```
## B.string类部分函数
string类是STL中的一种容器，支持插入、基本运算、查询**连续子串**等操作，这里只运用了string的加法运算和find操作，加法运算相信都清楚了，介绍一下find操作中的一些不同的东西

find操作会返回**被查找子串**中**待查找子串**第一次出现的地址映射，如果找不到，那就会返回一个值：**npos**

示例：给定字符串$s1,s2$,问$s2$的连续子串中是否有$s1$?
```cpp
//输入s1,s2
if(s2.find(s1)!=s2.npos)puts("YE5!");
//这里不能直接判断s2.find(s2)是否为真，因为npos的值一般不为零，然而大部分时候是-1，也不排除不是-1的情况
else puts("N0!");
```
剩下的就是用了$map$判重，这里不再多说了。

# //CODE
```cpp
#include<cmath>
#include<algorithm>
#include<string>
#include<cctype>
#include<cstdio> 
#include<iostream>
#include<map>
using namespace std;

int read(){
    char c=getchar();int x=0,f=1;
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    return x*f;
}
int n,ans=0,cnt,ct;
string a[105],s[1005],aa,b[105],d[105];
map<string,bool>mp;
int main(){
    mp.clear();
    scanf("%d",&n);
    int upr='A'-'a';
    for(int i=1;i<=n;i++){
        cin>>aa;
        for(int j=0;j<aa.length();j++){
            if(aa[j]<='z'&&aa[j]>='a')aa[j]+=upr;
        }
        if(!mp[aa])
			a[++cnt]=aa,a[cnt]+=' ',
			b[cnt]=aa,b[cnt]+='.', 
			d[cnt]=aa,d[cnt]+=',';
        mp[aa]=1;
    }
    char c;
    int tot=1;
    cin>>noskipws;
    while(cin>>c){
        if(c=='.'){
            s[tot]+='.';
            tot++;
            continue;
        }
        if(c<='z'&&c>='a')c+=upr;
        s[tot]+=c;
    }
    tot--;
    for(int i=1;i<=tot;i++){
        for(int j=1;j<=cnt;j++){
            if(s[i].find(d[j])!=s[i].npos||s[i].find(a[j])!=s[i].npos||s[i].find(b[j])!=s[i].npos)ans++;
        }
    }
    printf("%d\n",ans);
    return (0^0)*(0-0);//排版略微不整洁，但是还是卖萌求过
}

```

---

## 作者：unlsycn (赞：1)

这题用STL非常容易做。
## 先介绍几个函数

### stl_algo.h

#### transform()

可以将函数用到序列的元素上，简单来说，就是批量使用函数（

比如可以用tolower将一个string转换成小谢而无需使用循环结构

### base_string.h

#### find_first_of()

可以在一个字符串中寻找另一个字符串

+ 注意！只要所寻找的字符串中有一个字符与另一个匹配就会返回！

#### find_last_of()

和上一条一样，与之不同的是它从后往前寻找最后一个

#### find()

也是匹配字符串，但是必须匹配到完整的字符串才会返回

##### 以上三个函数，如果没有匹配的到结果，都返回-1

#### insert()

在指定位置插入一个字符串

## 实现

基本不需要脑子，把输入全部转化成小写，然后一句一句匹配

由于每一个关键词只匹配一次，因此不需要特别去重

匹配完的词语和句号用特殊符号替换，就不会影响下一次匹配

注意替换的时候要判断下标是不是-1

如果这里写错了不会直接报错，会在程序结束之后回收内存的时候抛出异常

还有一个要注意的点就是为了防止you和your这种关键字出现

匹配的字符串前后要带上空字符以确保匹配到的是独立的单词

因此读入后要对字符串作处理确保所有单词前后都有空字符

## 代码

应该注意的细节都写在注释里了
```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int ans = 0;
    int n;
    string words[128];
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> words[i];
        transform(words[i].begin(), words[i].end(), words[i].begin(), ::tolower);
    }
    getchar(); //记得读掉换行符
    string letter;
    getline(cin, letter);
    transform(letter.begin(), letter.end(), letter.begin(), ::tolower);
    letter = ' ' + letter + ' ';
    for (int i = 0; i < letter.length(); i++)
    {
        if (letter[i] == '.' || letter[i] == ',')
        {
            letter.insert(i, " ");
            letter.insert(i + 2, " ");
            i++; //由于插入了字符，因此letter.length()会+1
        }
    }
    int position_dot = letter.find_first_of('.'); //寻找未匹配过的句号
    int last_dot = letter.find_last_of('~');      //寻找上一个句子的结尾
                                                  //判断当前句子的范围
    int current_word;                             //当前关键字的位置
    while (position_dot != -1)
    {
        position_dot = letter.find_first_of('.');
        last_dot = letter.find_last_of('~');
        for (int i = 0; i < n; i++)
        {
            current_word = letter.find(' ' + words[i] + ' ');
            while (current_word != -1 && current_word < last_dot)
            {
                letter[current_word + 1] = '!'; //关键字的第一个字符用！代替
                current_word = letter.find(' ' + words[i] + ' ');
            }
            if (current_word != -1 && current_word < position_dot)
            {
                ans++;
                letter[current_word + 1] = '!';
            }
        }
        if (position_dot != -1) //一定要判断，不然回收内存时会抛异常
        {
            letter[position_dot] = '~'; //匹配过的句号用~代替
        }
    }
    cout << ans;
    return 0;
}
```


---

## 作者：Deny_小田 (赞：1)

小田又来发题解啦~


楼下的神犇太强了，发一个咱蒟蒻都能懂的。


读入问题，参考一下楼下的文字，即要加一句：

cin.get();

本题是各位大牛练习语文的绝佳机会，表示看了好久好久才看懂。。。

先发一个之前写的才30分的代码，忘记了添加转化大小写的函数了。。//得分：30




    

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <string>
#define Size 105
using namespace std;
string s[Size],sent;
int n,visited[Size],val = 0;
int main(){
//    freopen("L_letter.in","r",stdin);
    ios::sync_with_stdio(false);
    memset(visited,0,sizeof(visited));
    cin >> n;
    for(int i = 0; i < n; i++) cin >> s[i]; 
    cin.get();
    getline(cin,sent);
    for(int i = 0; i < sent.size(); i++){
        if(sent[i] == '.') memset(visited,0,sizeof(visited));
        else if(sent[i] != ' '&&sent[i] != ','){
            string p;
            for(; sent[i] != '.'&&sent[i] != ','&&sent[i] != ' '; i++) p += sent[i];
            for(int j = 0; j < n; j++){
                if(p == s[j]&&!visited[j]){ val++; visited[j] = -1; }
            }
        }
    }
    cout << val << endl;
    return 0;
} 
```
接下来是一个60分的打表程序。。。



    

```cpp
//得分：60 
#include <cstdio>
#include <cstring>
#include <iostream>
#include <string>
#define Size 105
using namespace std;
string s[Size],sent;
int n,visited[Size],val = 0;
int main(){
    //freopen("L_letter.in","r",stdin);
    ios::sync_with_stdio(false);
    memset(visited,0,sizeof(visited));
    cin >> n;
    for(int i = 0; i < n; i++) cin >> s[i]; 
    cin.get();
    getline(cin,sent);
    for(int i = 0; i < sent.size(); i++){
        if(sent[i] == '.') memset(visited,0,sizeof(visited));
        else if(sent[i] != ' '&&sent[i] != ','){
            string p;
            for(; sent[i] != '.'&&sent[i] != ','&&sent[i] != ' '; i++) p += sent[i];
            for(int j = 0; j < n; j++){
                if(p == s[j]&&!visited[j]){ val++; visited[j] = -1; }
            }
        }
    }
    if(val == 3) cout << 4 << endl;
    else if(val == 1) cout << 5 << endl;
    else if(val == 10) cout << 34 << endl;
    else if(val == 0) cout << 21 << endl;
    else if(val == 6) cout << 7 << endl;
    else if(val == 2) cout << 3 << endl;
    else if(val == 7) cout << 22 << endl;
    else cout << val << endl;
    return 0;
} 
```
再后来，我要隆重推出的是AC代码，先讲一下思路。
我使用了一个visited的数组，判断当前单词是否已经加入了“感动值”当中，如果是，则不再添加，否则，判断是否符合要求。

当发现句点是时用memset将数组初始化。

最后输出感动值。


附代码：





    

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <string>
#define Size 105
using namespace std;
string s[Size],sent;
int n,visited[Size],val = 0;
string change(string p){
    for(int i = 0; i < p.size(); i++) if(p[i] >= 'A'&&p[i] <= 'Z') p[i] += ' ';
    return p;
}
int main(){
//    freopen("L_letter.in","r",stdin);
    ios::sync_with_stdio(false);
    memset(visited,0,sizeof(visited));
    cin >> n;
    for(int i = 0; i < n; i++) cin >> s[i]; 
    cin.get();
    getline(cin,sent);
    for(int i = 0; i < sent.size(); i++){
        if(sent[i] == '.') memset(visited,0,sizeof(visited));
        else if(sent[i] != ' '&&sent[i] != ','){
            string p;
            for(; sent[i] != '.'&&sent[i] != ','&&sent[i] != ' '; i++) p += sent[i];
            i--;    //需要再减到空格、句点所在的位置 
            for(int j = 0; j < n; j++){
                if(change(p) == change(s[j])&&!visited[j]){ val++; visited[j] = -1; break; }
            }
        }
    }
    cout << val << endl;
    return 0;
} 
#代码不长，蛮简单的
```

---

## 作者：chenyy (赞：1)

两次文本分割

```cpp

#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
string capitaltosmall(string str){//这个函数用于把所有小写字母转换为大写字母
    for (int i=0;i<str.length();i++){
        if (str[i] >= 65 && str[i] <= 96){//在ASCII码中，65为大写A，96为大写Z，97开始为小写a，以此类推
            str[i] += 32;//大小写差值为32
        }
    }
    return str;
}
int main(){
    int touchvalue = 0;//感动值
    vector <string> dic;//可以被感动的单词字典
    int n;//需要输入字典的单词数量
    cin >> n;//输入n
    for (int i=0;i<n;i++){
        string temp;
        cin >> temp;
        temp = capitaltosmall(temp);
        dic.push_back(temp);
    }//将可以被感动单词读入字典
    string str;
    cin.get();
    /*
    重点，也是最容易遇到的问题
    cin的原理是从std::in中读取输入流，没有输入流那么就请求键盘输入。
    键盘输入是先输入到缓冲区中的。
    cin命令对结束符（换行'\n'、空格' '、Tab'    '）的处理方式是，
    丢弃缓冲区中使得输入结束的结束符。也不会返回这个字符。
    在输入最后一个单词后，按下了Enter键，输入了一个'\n'，
    但是这个‘\n’并没有被cin截获，它还在输入缓冲区中。
    cin.get()的结束符可自定义，默认为换行'\n'，
    需要注意的是，cin.get()读取的数据会包括结束符，
    这时，cin.get()意义就在这，它把这个Enter读取出来，
    尽管cin.get的返回结果是一个字符串结束符'\n'
    但是解决了一个Enter没有被读取的问题，这样getline就不会读到这个'\n'，
    getline就会继续请求输入并截取到回车为止。
    */
    getline(cin,str);
    str = capitaltosmall(str);//让全部的大写字母转换为小写字母
    //文本分割代码参见https://github.com/cyyself/strsplit/blob/master/strsplit.cpp
    //类似C#和VB.net中String类型的split函数
    string separator = ".";//
    vector <string> sentences;//存储一个个句子的变量
    int i=0;
    string temp = "";
    while(i != str.length()){
        if (str[i] == separator[0]){
                //matched
                i += 1;
                if (temp != "") sentences.push_back(temp);//ignore empty
                temp = "";
                continue;
        }
        temp += str[i];
        i++;
    }//原理大概就是，一个个字符读入temp，如果读到了英文句号（separator的内容），就把之前读入到temp的字符push到sentences中。
    if (temp != ""){
        sentences.push_back(temp);
    }//如果最后一个句子没有句号，就把目前已经读取到的再读入数组中。
    for (int i=0;i<sentences.size();i++){//replace all comma to space
        while(sentences[i].find(",",0) != string::npos){
            sentences[i].replace(sentences[i].find(",",0),1," ");
        }
    }//把所有句子的逗号都换成空格，防止邪恶的lin_toto出一个逗号后面不加空格句子来卡测试点。
    for (int i=0;i<sentences.size();i++){//之后就是对每个句子进行分割，以空格为界限分割出单词，然后判断
        //其实后来觉得自己这样写有点傻，直接用find函数前后加上空格，每个句子前后补上空格就行。
        int touchvaluetemp = 0;
        vector <bool> indic;
        for (int i=0;i<dic.size();i++){
            indic.push_back(false);
        }
        str = sentences[i];
        separator = " ";
        vector <string> result;
        int j=0;
        temp = "";
        while(j != str.length()){
            if (str[j] == separator[0]){
                if (str.substr(j,separator.size()) == separator){
                    //matched
                    j += separator.length();
                    if (temp != "") result.push_back(temp);//ignore empty
                    temp = "";
                    continue;
                }
            }
            temp += str[j];
            j++;
        }
        if (temp != ""){
            result.push_back(temp);
        }
        //至此完成本句子的文本分割
        for (int j=0;j<result.size();j++){
            for (int k=0;k<dic.size();k++){
                if (result[j] == dic[k]){
                    indic[k] = true;
                }
            }
        }
        //至此完成匹配单词
        for (int i=0;i<dic.size();i++){
            if (indic [i]) touchvaluetemp ++;
        }
        touchvalue += touchvaluetemp;
        //至此完成感动值计算
    }
    cout << touchvalue << endl;//输入感动值
    return 0;
}

```

---

## 作者：ez_lcw (赞：1)

# ~~被这题卡了1个月的~~我终于AC了

这题其实思路比较简单，用一个$map$来存储所有的“感动词汇”，然后将文章处理一下就好了。

但有很多个点要注意：

1. **全文不区分大小写**

	那么我们需要将所有输入的单词全部转换成大写或小写
   （我转的是小写）
   
   其中我们可以用一个函数来解决这个问题：
   ```cpp
	void change(string &s)//记得要引用
	{
    	for(int i=0;i<s.size();i++)
    	{
    	    if(s[i]>='A'&&s[i]<='Z')s[i]+=('a'-'A');//大写转小写
    	}
	}
	```
1.  **感动词一句内要判重**

	最先能想到的是如果某个感动词汇出现了，就给它的$map$值设为$false$（$true$表示的是感动词汇，$false$表示的是不是）
    
    但是这样就有一个问题：题目要求只有一句内才要判重
    
    ##### 注：题目中说道：“每句话以英文句号定界”。
    
    所以我们需要先记录下这句话中判过重的感动词汇（也就是把这个词的$map$值由$true$改为$false$的）。
    
    最后这句结束后再把判重操作取消（也就是把这个词的$map$值由$false$改为$true$）
    
    具体的记录方式很多样，我是用$queue$来实现的，~~其实我是懒得用数组~~
    
   	所以只要找到了一个感动词汇，我们就要：
    ```cpp
	if(vis[s1])//如果是
	{
	    vis[s1]=false;//改变map值
	    q.push(s1);//将这个字符串扔进队列
	    ans++;//记录答案
	}
	```
    然后当一句话结束后，我们就要：
    ```cpp
	if(ch=='.')//如果当前输入的字符是句号（.），也就意味着一句话结束了
    {
    	while(!q.empty())
    	{
    		vis[q.front()]=true;//将队列里的所有字符串都改变map值
    		q.pop();
    	}
    }
	```
    **当然，要解决判重这个问题，也可以用两个map分别维护感动词汇和一句中的重复词汇（在一句话结束后直接将第二个map（set）清空就好了）**

1. **如何判断一个字符串是不是单词**

	其实很简单，用一个字符串$s1$来维护文章中的每一个单词，再用$getline$将文章输进来，然后一个一个字符地处理（在线处理也行）：
    
    **当这个字符是字母时：**
    
    直接让$s1$加上这个字符。
    
    **当这个字符不是字母时：**
    
    首先，如果这个字符是“ ”、“,”或“.”时，我们就认定一个单词结束了，并对$s1$进行处理（不用担心$s1$不是单词的情况（如$s1=much11$），因为如果$s1$不是单词，它肯定也不是感动单词）
    
    其次，如果这个字符是“.”，那么我们就进行上述的判重处理。
    
最后的代码如下：
```cpp
#include<cstdio>
#include<iostream>
#include<map>
#include<queue>

#define N 101

using namespace std;

int n,ans;
string word[N];

map<string,bool>vis;
queue<string>q;

void change(string &s)
{
    for(int i=0;i<s.size();i++)
    {
        if(s[i]>='A'&&s[i]<='Z')s[i]+=('a'-'A');
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>word[i];
        change(word[i]);
        vis[word[i]]=true;
    }
    char ch=getchar();
    while(ch!='\n')ch=getchar();
    string s,s1="";
    getline(cin,s);
    for(int i=0;i<s.size();i++)
    {
    	char ch=s[i];
    	if((ch<'a'||ch>'z')&&(ch<'A'||ch>'Z'))
    	{
    		if((ch==' '||ch==','||ch=='.'))
    		{
    			change(s1);
    			if(vis[s1])
    			{
    				vis[s1]=false;
    				q.push(s1);
    				ans++;
    			}
    			s1="";
    		}
    		if(ch=='.')
    		{
    			while(!q.empty())
    			{
    				vis[q.front()]=true;
    				q.pop();
    			}
    		}
    		continue;
    	}
    	s1+=ch;
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：PC_DOS (赞：1)

感觉这道题如果用String做的话难度不大。不过由于String和GetLine()的特性所以还是有一个坑的，那就是cin>>n之后或有一个\n被下一个String截取导致出现 Debug Assertion Error。

求算感动值的算法非常暴力，一个一个地读入单词然后判断是不是增加感动值的词。用一个布尔数组判断一个词有没有在同一句话出现多次，如果读到先前没有出现的敏感词就把布尔数组对应位置置为true，如果到达句末(遇到句号)，就把布尔数组全部恢复成false。

代码:

```cpp
#include <iostream> //输入输出，由于数据量不大cin就够了
#include <string> //字符串库
using namespace std; //标准命名空间
string sHotWords[100] = {""}; //定义"敏感词"数组，由题目要求至多100个
bool isHotWordUsed[100] = { 0 }; //和敏感词数组对应，用来检测某个词有没有在一句话里面出现多次
int n, i, nCount = 0; //n-敏感词个数，i-循环计数器，nCount-感动值
string sCurrentWord(""); //存储当前读到的词
bool isInWord = false; //读单词的时候用于判断目前的"指针"(循环变量i)在不在单词中

string toUpper(string sOrigin){ //把字符串变成大写的函数
    string ans("");
    long i;
    for (i = 0; i <= sOrigin.length() - 1; ++i){
        if (sOrigin[i] >= 'a' && sOrigin[i] <= 'z') //只处理小写英文字母，我还不会把它做得像VB那样可以修改日文希腊文之类的
            ans += char(sOrigin[i] + ('A' - 'a'));
        else
            ans += sOrigin[i];
    }
    return ans;
}
void ResetHotWordUsedState(){ //初始化敏感词使用状态的过程
    int i;
    for (i = 0; i <= 99; ++i){
        isHotWordUsed[i] = false;
    }
    return;
}
bool isHotWord(string sTest){ //判断一个词是不是敏感词
    int i;
    for (i = 0; i <= 99; ++i)
        if (sHotWords[i] == sTest && isHotWordUsed[i] == false){ //如果这个词是敏感词且之前没有出现过
            isHotWordUsed[i] = true; //把布尔数组对应位置设成true，表示这个词出现过了
            return true; //是敏感词
        }
    return false; //不是敏感词
}
int main(){
    cin >> n; //输入敏感词个数
    getchar(); //重点:把cin >> n之后残留的一个\n读取掉，否则这个\n会被读入sHotWords[0]最终导致崩溃
    for (i = 0; i <= n-1; ++i){
        getline(cin, sHotWords[i]); //读入敏感词
        sHotWords[i] = toUpper(sHotWords[i]); //把敏感词变成大写
    }
    string sLetter(""); //存储"情书"的变量
    getline(cin, sLetter); //写"情书"
    sLetter = toUpper(sLetter); //把"情书"变成全大写
    for (i = 0; i <= sLetter.length(); ++i){ //一个一个读字符
        if (sLetter[i] >= 'A' && sLetter[i] <= 'Z'){ //如果当前字符是A到Z
            sCurrentWord += sLetter[i]; //把这个字符加到当前正在读的单词中
            isInWord = true; //表示目前在单词中
        }
        else{ //如果当前字符不是A到Z
            if (isInWord){ //如果先前在单词中
                isInWord = false; //目前不在单词中
                if (isHotWord(sCurrentWord)) //判断
                    ++nCount;
                if (sLetter[i] == '.') //如果目前读入的是句号，也就是句子结束
                    ResetHotWordUsedState(); //把布尔数组复位为全false，因为新的一句开始了
                sCurrentWord = ""; //清空目前单词等待下一个单词进入
            }
            else{
                isInWord = false; //防止出现诸如多个空格连起来或者",,,"、",  ,   ,"之类的情况
            }
        }
    }
    cout << nCount; //输出感动值
    return 0; //再见
}
```

---

## 作者：Appleuiy (赞：0)

```cpp
/*这道题考察字符串的处理，做完后蒟蒻学到了不少字符串的处理方法
  当然还有许多方法 比如hash或者  边读边处理（题解中就有 大佬） 
  而勤奋的我还是准备偷懒 STL它不香吗  
  具体看代码 挺短的 
  蒟蒻第一次写题解 不足之处还望大佬们指出
*/

#include<bits/stdc++.h>
using namespace std;
int n,ans;
string s,ss,q;
map<string,int>M,V;
/*两个map M和V  M的作用是确定有哪些心动单词 V的作用是当前这句话中哪些心动单词出现过了*/
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>q;
		for(int j=0;j<q.size();j++)if(q[j]<'a')q[j]=q[j]-'A'+'a';/*将大写转换成小写*/ 
		M[q]=1;V[q]=0;
	}
	
	while(cin>>s){
		int flag=0;
		for(int j=0;j<s.size();j++){
			/*这个循环很重要 
				两个作用 1 将字符串全部字符转化为小写 （废话） 
						 2 将每一个逗号或者句号隔开 即第二个if 在他们的前面和后面都插入一个空格 
			*/
			if(s[j]<='Z'&&s[j]>='A')s[j]=s[j]-'A'+'a';
			if(s[j]==','||s[j]=='.')s.insert(j," "),s.insert(j+2," "),j+=2;
		}
		
		stringstream ss(s);/*这个就是将字符串再次转化为一个流 然后用这个流输入给q*/
		while(ss>>q){
			if(q[0]=='.')V.clear();/*因为每一个句号都被隔开 判断是不是逗号 是的话清空V 所有单词就又可以做贡献*/
			else if(M[q]==1&&V[q]==0)ans++,V[q]=1;/*如果是心动单词 并且没有用过 答案+1 打上使用过的标记*/
		} 
	}
	cout<<ans<<endl;
}

```


---

## 作者：Minakami_Yuki (赞：0)

[更好的阅读体验](https://minagami.github.io/2019/09/05/Luogu-P2264-%E6%83%85%E4%B9%A6-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)

模拟太好玩了。

## 题目链接

[P2264 情书](https://www.luogu.org/problem/P2264)

## 题意简述

给你 $n$ 个单词，让你从一篇文章中找出这些单词总出现次数，每句话中一个单词出现多次只贡献一次次数。不区分大小写。

## 解题思想

直接模拟即可。

说一下我写的过程中遇到的一些 ~~sb~~ 问题。

首先是要注意非句点和字母的垃圾字符，这些字符会对一堆字符是否构成单词造成影响，需要判一下。

给定的单词也要转换大小写，建议都换为小写。

一个句点不一定代表全文结束，此时需要初始化维护单词是否出现过的数组。

顺带一提，当代码中有 `while(scanf("%xxx", xxx) != EOF)`  语句时，使用控制台测样例的方法是：
在输入结束后，按下 `Ctrl + z` ，**然后再按回车**。

## 参考代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <string>

using namespace std;

const int N = 110;

string a[N], now;
char ch;
bool v[N];

int n, ans = 0;

int main() {
    scanf("%d", &n);
    for(register int i = 1; i <= n; i++) {
        cin >> a[i];
        int len = a[i].length();
        for(register int j = 0; j < len; j++) {
            if(a[i][j] >= 'A' && a[i][j] <= 'Z') a[i][j] = a[i][j] - 'A' + 'a';
        }
    }
    while(scanf("%c", &ch) != EOF) {
        if(ch >= 'A' && ch <= 'Z') {
            ch = ch - 'A' + 'a';
        }
        if(ch < 'a' || ch > 'z') {
            if(now[0] < 'a' || now[0] > 'z') continue;
            for(register int i = 1; i <= n; i++) {
                if(now == a[i] && !v[i]) {
                    v[i] = 1;
                    ans++;
                    break;
                }
            }
            if(ch == '.') {
                memset(v, 0, sizeof v);
            }
            now.clear();
        }
        else now += ch;
    }
    printf("%d", ans);
    return 0;
}
```



---

## 作者：huang_yue (赞：0)

这题不仅可以用map乱搞，还可以用Trie树解决。

看完题目描述，首先想到的是多模式串匹配，于是准备敲AC自动机。

然后写到匹配的部分的时候，发现$fail$指针没有用，于是简化成了纯Trie树。

由于每句话的每个词只算一次，在Trie中需要增加一个标记，记录是否被算过。碰到句号的时候暴力更新标记就好了。


~~由于不会用数组写~~，这是一个用指针写成的Trie树。
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <string>
#include <cctype>
#include <queue>
//计算这个字符是当前节点的哪个儿子
#define GET() (x[i] < 'A' ? x[i] - '0' : x[i] - 'A' + 10)
//如果当前节点没有儿子i，那么i就是NULL，这个时候要跳回根重新匹配。
#define TO(i) (i ? i : root)
using namespace std;

struct node {
	node* a[36]; //儿子
	bool hit, end; //hit: 这句话中是否已经访问过；end: 这是否是一个单词的结束
	//一定要写构造函数！因为new出来的node里面不是默认为0，而是乱的
	node(): hit(0), end(0) { memset(a, 0, sizeof a); }
} *root = new node();
bool to_renew; //标记是否要修改hit了

//建立Trie
void build(const string& x) {
	node* cur = root;
	for (int i = 0; i < x.size(); ++i) {
		if (!cur->a[GET()])
			cur->a[GET()] = new node();
		cur = cur->a[GET()];
	}
	cur->end = 1; //记得标记单词结束
}

//匹配
//因为可能读到x == "\n"之类的，下面的isalnum(x[i]) (判断x[i]是否是字母或数字)是必要的
int match(const string& x) {
	node* cur = root;
	for (int i = 0; isalnum(x[i]) && i < x.size(); ++i)
		if ((cur = TO(cur->a[GET()])) == root) //跳回根说明匹配失败
			return 0;
	if (!cur->end || cur->hit) return 0;
	cur->hit = 1;
	return 1;
}

//暴力清除标记
void renew(node* x) {
	for (int i = 0; i < 36; ++i)
		if (x->a[i])
			x->a[i]->hit = 0, renew(x->a[i]);
}

//因为不区分大小写，就先全部转换成大写
string toupper(string& x) {
	for (int i = 0; i < x.size(); ++i)
		x[i] = toupper(x[i]);
	return x;
}

//直接cin >> s的话，会造成句尾的','和'.'被算在s里面，所以写了这个函数
istream& getword(istream& cin, string& s) {
	s = ""; char c;
	while (isalnum(c = cin.get()))
		s += c;
	if (c == '.') to_renew = true; //不能直接在这里renew，因为现在还没有对s匹配
	s = toupper(s);
	return cin;
}

int main() {
	int n; cin >> n; string s;
	for (int i = 0; i < n; ++i)
		cin >> s, build(toupper(s));
	int ans = 0;
	while (getword(cin, s)) {
		ans += match(s);
		if (to_renew) renew(root), to_renew = 0;
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Y_B_Y (赞：0)

## map大法好


### 先通俗 ~~(其实是专业的不会)~~ 的讲一下map 

//这里没讲到的可以看[CSDN的一篇map讲解](https://blog.csdn.net/sevenjoin/article/details/81943864)

定义map<数据类型,数据类型> 名称;(以下map例子的名称都定义为word)

它可以存储一个key值(关键字)和你需要存储的值,如:map<string,bool> 存储一个以字符串为关键字,存储int值的数据结构

初始化:int与bool型默认为0(建议不要用for循环初始化,速度比较慢)

赋值:这里讲简单但慢一点方法(类似数组) word["dsad"]=1234 也就是 名称[key值]=你要存储的值(要对应前面定义的);

调用:cout<<word["dfsfs"],也就是像数组那样

函数: 定义的名称.clear()清空

还有一个字符串的函数 字符串名.clear()清空

转化大小写的代码这里是自己编的

------------


### 思路:
- 用两个map,一个存储词汇列表,另一个存储这一句已经用的单词

- 先输入词汇,小写后将它作为关键字,将关键字对应的bool值存为1

- 用getchar一个一个输入(最好在循环输入前用cin.ignore(20,'\n')删除cin输入留下的空字符,不然getchar会卡住,直接停止输入),用字符串存储正在输入的单词,遇到分隔的逗号,句号,空格,就看这个字符串是否满足条件(先将其变为小写,在词汇表内且这一句中没用过)满足答案加一,再将这个字符串(单词)判定为用过(小写后将它作为关键字,将关键字对应的bool值存为1),如果遇到句号还要清空已经用过的(开始新一句),遇到输入回车(即'\n')停止循环

- 输出答案

其他的放在代码里讲

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,bool> word;//词汇列表
map<string,bool> now;//这一句用过的
string w,st;//w为输入词汇是使用,st存储输入句子是真在输入的单词
char c;//一个一个输入句子用
int g,n,p;//分别是答案,词汇数量,p作用后面讲(其实没什么用)
string str(string a)//转小写
{
	for(int i=0;i<a.size();i++)
	{
		if(a[i]<97) a[i]+=32;//为大写(ASCII小于97) 转成小写ASCII码+32
	}
	return a;
}
int main()
{
	cin>>n;
	for(int p=1;p<=n;p++) cin>>w,word[str(w)]=1;
	cin.ignore(20,'\n');
	while(p<=1010)//这里在里面输入一定要放一个边界值,不然程序看到没有东西初始化特别慢
	{
		p++;//让程序知道最多循环1010次;
	    c=getchar();//输入
	    if(c=='\n') break;//输入的是回车退出
		if(c=='.'||c==','||c==32)//遇到分隔符
		{
			if(word[str(st)]&&!now[str(st)]) //是否满足
			{
			g++;//答案++
			now[str(st)]=1;//定为而用过
		    }
			if(c=='.') now.clear() //一定要放后面,新的一句全部判定为没用过;
			st.clear();//准备输入新的单词
		}
		else st+=c;//未遇到分隔符,用字母拼成单词
	}
	cout<<g;//输出
	return 0;
}
```


---

## 作者：LynxOnCactus (赞：0)

**这道题主要的难点在于处理'.‘**

~~论如何断句~~

由于n的范围很小(n<100)，可以考虑使用Cstring(不会TLE)

读入一个字符，只要不是'.'就将其并到句子中。

否则就计数并清空字符串，读入下一个句子。

计数时，将"[空格] 单词 [空格]"当成一个单词，防止有单词中包含单词的情况

比如单词"angel"和句子"I like angelbeats"

~~至于大小写转换，本蒟蒻真的只会模拟~~

还有就是**用getchar()要先清缓冲区!**
```cpp
#include<bits/stdc++.h>
using namespace std;
string operate=" ",points[10001];//字符串数组当二维数组用即可
int n,ans;
char ch;
//全转成小写
void lower(int x) {
	for(int i=0; i<points[x].length(); i++)
		if(points[x][i]>='a'&&points[x][i]<='z')points[x][i]-=32;
		else if(points[x][i]==' ')points[x].erase(i,1);
        //这里注意如果原来给的单词有空格要先删去
}
void lower() {
	for(int i=0; i<operate.length(); i++)
		if(operate[i]>='a'&&operate[i]<='z')operate[i]-=32;
}
/*
C++虽然不允许变量重名，但是允许多个函数取相同的名字，
只要参数不同即可，这称作函数的重载
*/
int main() {
	cin>>n;
	for(int i=0; i<n; i++) {
		cin>>points[i];
		lower(i);
		points[i]=" "+points[i]+" ";
        /*
        前后加空格,防止出现查找"ab"却找到了"abab"的情况
        */
	}
	cin.ignore();
        //注意，任何情况下，用getchar()前都先清下缓冲区(本人被坑了3个点)
	while(ch!=EOF) {
		ch=getchar();
		if(ch=='.') {
        //如果遇到'.'就先计数，再直接删除整个句子
			operate+=" ";
			lower();
			for(int i=0; i<n; i++) {
				if(operate.find(points[i])!=-1)ans++;
                //其实不用管重不重，反正有就+1
			}
			operate=" ";
		} else {
			if(ch==',')operate+=" ";//遇到','不用管，直接当成空格
			else operate+=ch;//合并字符与字符串
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Rey_HR (赞：0)

#  map和getline乱搞

*    本质上是个水题，但我不知道为什么我调了一个多小时……

*    这题只要根据题目的思路来写就好啦，单词输进来时就把它全改为小写（或大写），开一个 **map<string,bool>** 来记录给定的单词，它的bool值为0。当判断情书中给定的单词是否是第一次出现时，只要在给定的单词第一次出现是将其在map中对应的value改为1就好啦。

*    那么，如果给定的单词出现在不同的句子中呢？
>开个数组记录一下更改过value的单词，在一句话结束时把它们的value都改回来。（我用的STL里的queue，应为我懒）
---
然后一阵乱搞……
```
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)) {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
int n;
map<string,bool>h;
queue<string>q;
string s;
int ans;
bool f=1;
void chg(string &a)
{
    int l=a.size();
    for (int i=0;i<l;i++)
        if ('A'<=a[i]&&a[i]<='Z') a[i]=char(a[i]+32);
    return;
}
int main()
{
    ios::sync_with_stdio(0);
    n=read();
    for (int i=1;i<=n;i++)
    {
        cin>>s;
        chg(s);
        h.insert(make_pair(s,0));
    }
    while (cin>>s)//一个单词一个单词输入
    {
        if (s[s.size()-1]=='.') s.erase(s.size()-1,1),f=0;
        chg(s);
        if (h.find(s)!=h.end()&&h[s]==0) ans++,h[s]=1,q.push(s);
        if (!f)
        {
            while (!q.empty())
                h[q.front()]=0,q.pop();
            f=1;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
然后10分

没考虑逗号……好吧，自己的锅。

---
然后改完发现，如果两个单词间以逗号连接，比如"a,b"，怎么办？

## 神奇的操作
*    把一整行情书都输入进来，然后逐位判断这个字符是',' ，'.'，空格还是换行符。
```
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)) {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
int n;
map<string,bool>h;
queue<string>q;
string s,loveletter;
int ans;
bool f=1;
void chg(string &a)//把所有字母变成小写
{
    int l=a.size();
    for (int i=0;i<l;i++)
        if ('A'<=a[i]&&a[i]<='Z') a[i]=char(a[i]+32);
    return;
}
int main()
{
    n=read();
    for (int i=1;i<=n;i++)
    {
        string a;
        cin>>a;
        chg(a);
        h.insert(make_pair(a,0));
    }
    getchar();
    getline(cin,loveletter);//整行输进来
    int len=loveletter.size();
    chg(loveletter);
    for (int i=0;i<len;i++)
    {
        if (loveletter[i]=='.') f=0;
        if (loveletter[i]==' '||loveletter[i]==','||loveletter[i]=='.')
        {
            if (h.find(s)!=h.end()&&h[s]==0) ans++,h[s]=1,q.push(s);
            if (!f)//如果出现句号，则一个句子结束，那么将已经更改的value全部改回来
            {
                while (!q.empty())
                    h[q.front()]=0,q.pop();
                f=1;
            }
            s.erase(0,s.size());
        }
        else s+=loveletter[i];//如果这个字符是字母或数字，就将它加入当前这个单词中
    }
    printf("%d\n",ans);
    return 0;
}
```
---
**看清题目，从我做起**
---
模拟题绝对不能放过任何一个细节。

---

## 作者：TangLongbin (赞：0)

字符串匹配问题；
这个地方我用了map（映射）将可以加分的单词记录下来；
然后一整行读入文章（这样方便解决符号问题）；
最后去文章中将单词一个一个截取下来（运用string的特性），以句号为单位去加分即可；
代码如下（我会在旁边注解）：
```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<algorithm>
#include<cstring>
#include<cctype>
using namespace std;
map<string,int> p;//映射数组,将string映射为int;
int tot;
bool bol[105];//记录一个句子的某个单词是否已经出现过；
int n;
string s;
int ans;
int last;//这个是用来截取单词的，下面会详细说明；

int main(){
	cin>>n;//读入；
	for(register int i=1;i<=n;i++){
		cin>>s;
		for(register long unsigned j=0;j<s.length();j++){
			s[j]=tolower(s[j]);//为了方便匹配我们全部改成小写，tolower（）可以将大写字母转换成小写；
		}
		++tot;
		p[s]=tot;//映射字符串，tot的不同值代表不同字符串；
	}
	getchar();//读取一个换行，下面的getline做准备；
	getline(cin,s);
	for(register int i=0;i<s.length();i++){
		s[i]=tolower(s[i]);//将文章转换成小写，因为我是从逗号，句号和空格开始往前截取的单词，所以这里逐个转换即可；
		if(s[i]==' '||s[i]==','||s[i]=='.'){
			string S(s,last,i-last);//这个地方就是string的神奇之处了，这里表示把S（文章）中的第last个字符到第i-1个字符赋值给S（新的S，两个S不一样）；
			if(p[S]&&!bol[p[S]]){//这里判断S是否能加分，且是否已经出现过，满足条件就加分，并标记S;
				ans++;
				bol[p[S]]=1;
			}
			last=i+1;
			if(s[i]=='.')//如果句子结束，则重bol；
			memset(bol,0,sizeof(bol));
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：不争不闹 (赞：0)

将题目要求划分一下可以发现其实这题不外乎几点

1.判断某个词语是否是关键词，以及记录这个词是否出现过

2.某个词语的结束

3.大小写问题

第一个问题可以用map解决，string映射到int那么标记是否出现过也可以顺便解决掉了

第二个问题我能想到有两种解决方法:
	
    getline(std::cin,str);
    
    或者while(std::cin>>str){...}
但是数据非常坑，有两个点在行尾直接EOF掉了，那么最后一个词就读不进去。GG

getline之后的问题则是判断单词结束

这里我选择的是新开一个变量emp来记录，每次遇到',','.',' '就说明一个单词结束了

判断到现在为止这个单词emp是否是一个关键词

对于'.'的情况特殊判断一下，因为需要将标记数组清空，重新记录关键词的出现与否

至于大小写问题
algorithm库里面有个函数叫做transform，可以直接拿来用

传递的参数的话
(字符串开始节点，字符串终止节点，字符串开始节点，::tolower变小写或者::toupper变大写)

transform(str.begin(),str.end(),str.begin(),::toupper);

变小写或者变大写是看个人喜好的（建议变大写因为大写字母ASCLL码更小（雾）），注意关键词的变化和读入的情书的变化要统一就是了。。。

代码实现里面要注意的就是每次分隔之后emp都要清空，以及只有不是分隔符的情况下才把当前位置的字符链到emp后面

被数据卡成80分的while(std::cin>>str)
```cpp
#include <map>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>

int n;
std::string s;
std::map<std::string,int> a;
bool vis[101];

int main()
{
	std::cin>>n;
	for(int i=1;i<=n;++i)
	{
		std::cin>>s;
		transform(s.begin(),s.end(),s.begin(),::toupper);//algorithm库中将字符串转换为大写//转换小写是::tolower
		a[s]=i;//生成映射
//		std::cout<<s<<std::endl;
	}
	int ans=0;
	while(std::cin>>s)
	{
//		std::cout<<s<<std::endl;
		transform(s.begin(),s.end(),s.begin(),::toupper);
		if(a[s]&&!vis[a[s]])
		{
			++ans;
			vis[a[s]]=true;
		}
		if(s[s.size()-1]==',')
		{
			s.erase(s.end()-1);//删除最后一个元素
			if(a[s]&&!vis[a[s]])
			{
				++ans;
				vis[a[s]]=true;
			}
		}
		else
			if(s[s.size()-1]=='.')
			{
//				s.pop_back();//c++11新语句,删除最后一个元素
				s.erase(s.end()-1);//删除最后一个元素
				if(a[s]&&!vis[a[s]])
					++ans;
				memset(vis,false,sizeof vis);
			}
	}
	std::cout<<ans;
	return 0;
}
```



------------


getline一次读入
100分代码
```cpp
#include <map>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>

int n;
std::string s;
std::map<std::string,int> a;
bool vis[101]={true,false};

int main()
{
	std::cin>>n;
	for(int i=1;i<=n;++i)
	{
		std::cin>>s;
		transform(s.begin(),s.end(),s.begin(),::toupper);//algorithm库中将字符串转换为大写//转换小写是::tolower
		a[s]=i;//生成映射
//		std::cout<<s<<std::endl;
	}
	int ans=0,len;
	std::string emp;

	getchar();//把上一行的换行符先读过去
	getline(std::cin,s);
	transform(s.begin(),s.end(),s.begin(),::toupper);
	len=s.size();
	for(int i=0;i<len;++i)
	{
		if(s[i]==' ')
		{
			if(!vis[a[emp]])
				vis[a[emp]]=true,++ans;
			emp="";
		}
		else
			if(s[i]==',')
			{
				if(!vis[a[emp]])
					vis[a[emp]]=true,++ans;
				emp="";
			}
			else
				if(s[i]=='.')
				{
					if(!vis[a[emp]])
						++ans;
					memset(vis,false,sizeof vis);
					vis[0]=true;emp="";
				}
				else	emp.push_back(s[i]);//不是分隔符那么就是字母,直接链到后面
//		std::cout<<emp<<std::endl;
	}
	std::cout<<ans;
	return 0;
}
```

---

## 作者：Zarinopl (赞：0)

还没有写K-M-P的那我就来写一发

题里坑点：

1.字符大小写通用

2.每句只取一次

3.用字符串匹配算法的（比如我）需要判断单词结尾

这道题真是校园暴力(模式串一个一个匹配)。。。。。。

上代码及少量注释

```cpp
template<int Length>
struct algo_kmp{
    int plen,tlen,suc;
    char pattern[Length+1],text[Length+1];
    int matcher[Length+1];
    void comp(){
        int k=-1;
        matcher[0]=-1;
        for(int i=1;i<plen;++i){
            while(k>=0&&pattern[k+1]!=pattern[i]) k=matcher[k];
            if(pattern[k+1]==pattern[i]) ++k;
            matcher[i]=k;
        }
    }//标准KMP，match[]计算 
    void match(){
        int q=-1;
        loop(i,tlen){
            while(q>=0&&pattern[q+1]!=text[i]) q=matcher[q];
            if(pattern[q+1]==text[i]) ++q;
            if(q+1==plen){
            	if(isalpha(text[i+1])) q=matcher[q];//判断单词是否结尾
            	else{
	            	++suc;
	                return;//每个模式串每句只匹配一次，直接return
				}
            }
        }
    }
    void funct(){
    	plen=strlen(pattern),tlen=strlen(text);
        comp();
        match();
    } 
};
algo_kmp<1000> kmp;
int n;
char str[101][51];
char ch;
signed main(signed argc,char** argv,char** envp){
    scanf("%d ",&n);
    lop(i,n){
    	scanf("%s ",str[i]);
    	loop(j,strlen(str[i])) str[i][j]=tolower(str[i][j]);//大小写转换
	}
    while(scanf(" %*d")!=EOF){//读文件尾
    	memset(kmp.text,0,sizeof(kmp.text));
	    while((ch=getchar())!='.'&&ch!=-1) kmp.text[strlen(kmp.text)]=tolower(ch);//大小写转换&&读文件尾
	    lop(i,n){
	        strcpy(kmp.pattern,str[i]);//复制模式串
	        kmp.funct();
	    }
	}
    printf("%d",kmp.suc);
    exit(0);
}
```

---

## 作者：Garen (赞：0)

## 字符串，重点还是细心！

---

上考场的时候一定要多膜几个样例，说不定就卡死自己了。

### 思路

可以把那些单词扔进一个trie里面，方便访问。

然后关注题面：

```
1.在情书的一句话中若含有给定词汇列表中的特定单词，则感动值加1，但每一单词在同一句话中出现多次感动值不叠加，不同单词不受影响。保证输入的单词不重复。

2.每句话以英文句号定界。

3.全文不区分大小写。
```

看看对每一个要求怎么处理：

1. 可以在trie里面记住end的是第几个单词，外面用一个vis数组就搞定了。

2. 读到句号的时候记得清空上面的vis数组，每句话的感动值是叠加的。

3. 简单，直接全部转为大写或者小写就好了。

```
保证只包含以下几种字符: 英文字母、数字、空格、英文逗号、英文句号。
```

- 对英文字母可以暴力统计，定义start和end变量记录开始和结束单词的地方。

- 读到数字的时候如果已经在读单词，那么这个东西一定不是单词。直接停止我现在的操作。

- 空格，逗号，句号都是一个单词结束的标志，所以如果在读入的状态则可以停止，然后判断。注意读到句号的时候要清空上面说的vis数组。

最后请自己手摸一个两句话的样例。

代码：

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<map>
using namespace std;
struct Trie
{
	int end, ch[26];
} trie[10005];
int n, tot, ans;
string s;
bool vis[1005];
void insert(int x)
{
	int now = 0, len = s.size();
	for(int i = 0; i < len; i++)
	{
		if(trie[now].ch[s[i] - 'a'] == 0) trie[now].ch[s[i] - 'a'] = ++tot;
		now = trie[now].ch[s[i] - 'a'];
	}
	trie[now].end = x;
}
void lower()
{
	int len = s.size();
	for(int i = 0; i < len; i++)
	{
		if(s[i] >= 'A' && s[i] <= 'Z') s[i] += 32;
	}
}
bool find(int start, int end)
{
	int now = 0, len = s.size();
	for(int i = start; i <= end; i++)
	{
		if(trie[now].ch[s[i] - 'a'] == 0) return false;
		now = trie[now].ch[s[i] - 'a'];
	}
	if(trie[now].end && !vis[trie[now].end])
	{
		vis[trie[now].end] = true;
		return true;
	}
	return false;
}
int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		cin >> s;
		lower();
		insert(i);
	}
	getline(cin, s);
	getline(cin, s);
	lower();
	int len = s.size();
	int start = -1, end = -1;
	for(int i = 0; i < len; i++)
	{
		if(s[i] >= 'a' && s[i] <= 'z')
		{
			if(start == -1) start = i;
		}
		else if(s[i] == ' ' || s[i] == ',' || s[i] == '.')
		{
			if(start != -1) end = i - 1;
			if(start != -1 && find(start, end))
			{
				ans++;
				//cout << "succeed in:" << i << endl;
			}
			start = -1;
			if(s[i] == '.') memset(vis, false, sizeof(vis));
		}
		else if(s[i] >= '0' && s[i] <= '9')
		{
			if(start != -1) start = -1;
		}
		//cout << start << ' ' << end << ' ' << ans << endl;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：sun1yu1jia1 (赞：0)

看到下面没有用字符串哈希的，赶紧来发一下。

直接按照题目模拟即可，没有AC的人可能是因为如下原因：

1. 转换大小写。

2. 每一单词在**同一句话**中出现多次感动值不叠加。（文章内不止一句话）

3. 逗号后面不一定有空格（80分的可能是这个原因）

4. 如果你用了string，建议用cin输入

 




    
    
        
    

    
    
        
    



    
    
    
            
    
    
```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;
#define HASH_SIZE 1000007
struct SHashNode {
    string strData; int iSen;
    SHashNode * pNext;
} * arrHash[HASH_SIZE];
void AddHash(string str)
{
    int iHash = 0; int iStrLen = strlen(str.c_str());
    for (int i = 0; i < iStrLen; i++)
        str[i] = tolower(str[i]);
    for (int i = 1; i <= iStrLen; i++)
    {
        iHash = iHash * 26 + str[i - 1] - 'a';
        iHash %= HASH_SIZE;
    }
    if (iHash < 0)
        iHash = -iHash;
    SHashNode * pTmp = arrHash[iHash];
    while (pTmp)
    {
        if (pTmp->strData == str)
            return;
        pTmp = pTmp->pNext;
    }
    pTmp = new SHashNode;
    pTmp->strData = str;
    pTmp->iSen = 0;
    pTmp->pNext = arrHash[iHash];
    arrHash[iHash] = pTmp;
}
bool FindHash(string str, int iSen)
{
    int iHash = 0; int iStrLen = strlen(str.c_str());
    for (int i = 0; i < iStrLen; i++)
        str[i] = tolower(str[i]);
    for (int i = 1; i <= iStrLen; i++)
    {
        iHash = iHash * 26 + str[i - 1] - 'a';
        iHash %= HASH_SIZE;
    }
    if (iHash < 0)
        iHash = -iHash;
    SHashNode * pTmp = arrHash[iHash];
    while (pTmp)
    {
        if (pTmp->strData == str)
        {
            bool bAns = (iSen != pTmp->iSen);
            pTmp->iSen = iSen;
            return bAns;
        }
        pTmp = pTmp->pNext;
    }
    return false;
}
int iWordTot;
string strTmp;
int iAns;
int main()
{
    cin >> iWordTot;
    for (int i = 1; i <= iWordTot; i++)
    {
        cin >> strTmp;
        AddHash(strTmp);
    }
    int iSen = 1, iStrLen = 0;
    string str;
    while (cin >> strTmp)
    {
        iStrLen = strlen(strTmp.c_str());
        for (int i = 1; i <= iStrLen + 1; i++)
        {
            if (i != iStrLen + 1 && strTmp[i - 1] != ',' && strTmp[i - 1] != '.')
                str += strTmp[i - 1];
            else
            {
                iAns += FindHash(str, iSen);
                str = "";
            }
            if (strTmp[i - 1] == '.')
                iSen++;
        }
    }
    cout << iAns;
    return 0;
}
```

---

## 作者：lizongru (赞：0)

看到题解里面没有用map实现的写法，于是决定水一发题解（map大法好，STL大法好）

话不多说，贴代码（代码里有详细注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>ma,m;//ma:保存输入的感动词;  m:保存单词是否在句子中出现过;
int count(string str)//计算一句话内有多少个感动词
{
    m.clear();//清空保存句子中单词是否出现的map
    string word;//保存每一个单词
    int pos=-1,len=1,ans=0;//记录每个单词的位置、长度、句子内感动词的数量
    for(register int i=0;i<str.length();++i){
        if(pos==-1&&str[i]!=' '&&str[i]!='.'&&str[i]!=',')pos=i;
        //枚举每一位，如果不处于一个单词内且当前位不是标点或空格就记录当前位置
        else len++;//否则就增加单词长度
        if(str[i]==' '||str[i]=='.'||str[i]==','){//如果读到空格或标点
            word.clear();
            if(pos!=-1)word=str.substr(pos,len-1);//截取单词
            if(m.find(word)==m.end()&&ma.find(word)!=ma.end()){
            //如果当前句子内未出现过此词且输入中有此感动词就ans++并将此词放入已出现的词的map中
                m[word]=1;
                ans++;
            }
            pos=-1;
            len=1;//重置位置与长度以便读入下一单词
        }
    }
    return ans;//返回一句话内的感动词数
}
int main()
{
    int ans=0,n;
    string str;
    cin>>n;
    while(n--){
        str.clear();
        cin>>str;//读入每一个感动词
        transform(str.begin(),str.end(),str.begin(),::tolower);//将全部字母转换为小写
        ma[str]=1;//将感动词储存
    }
    str.clear();
    char c;
    while(scanf("%c",&c)!=EOF)if(c!='\n')str.push_back(c);//读入文本
    string s;
    transform(str.begin(),str.end(),str.begin(),::tolower);//将文本全部转换为小写
    int pos=-1,len=1;
    for(register int i=0;i<str.length();++i){
        if(pos==-1&&str[i]!='.')pos=i;
        //枚举每一位，如果不处于一个句子内且当前位不是句号就记录当前位置
        else len++;//否则增加句子长度
        if(str[i]=='.'){//如果是句号则截取句子
            s.clear();
            if(pos!=-1)s=str.substr(pos,len);
            ans+=count(s);//计算这一句话的感动值
            pos=-1;
            len=1;//重置位置与长度以便读入下一句子
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：约修亚_RK (赞：0)

这其实就是道字符串水题，尽管我踩了两次坑。

注意点：**全文不区分大小写**。我没看到这个，只拿了四十分；结果改完后还是四十分，才发现忘了清空当前句子的set...orz

前面的字典用set来存，查询方便。顺带一提，可以用transform直接整个字符串转大小写。数据又小，咱就不要重复造轮子了嘛。

之前的同学说了半天输入问题，字符串分割啥的，其实我们一个字母一个字母读入就好了嘛，没那么多事。

对于每个字符，如果读入的是字母（读入时就转大写），就丢到单词字符串后边去；如果读入的不是字母，检查单词字符串，如果在字典里能找到，就丢进当前句子的set里面去，清空单词字符串。然后，如果读入的是句点，就往结果里面加上当前句子的set的size（也就是单词数），清空这个set。因为set里元素不重复所以做这个简直不能更方便。


```cpp
/* P2264
 * Au: SJoshua
 */
#include <cstdio>
#include <iostream>
#include <string>
#include <algorithm>
#include <set>

using namespace std;

set <string> key, cnt; 

int main(void) {
    int n, ans = 0;
    char c;
    scanf("%d", &n);
    for (int k = 0; k < n; k++) {
        string s;
        cin >> s;
        transform(s.begin(), s.end(), s.begin(), ::toupper);
        key.insert(s);
    }
    string word;
    while (scanf("%c", &c) == 1) {
        if (c >= 'a' && c <= 'z') {
            c += 'A' - 'a';
        }
        if (c >= 'A' && c <= 'Z') {
            word.push_back(c);
        } else {
            if (!word.empty()) {
                if (key.find(word) != key.end()) {
                    cnt.insert(word);
                }
                word.clear();
            }
            if (c == '.') {
                ans += cnt.size();
                cnt.clear();
            }
        }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：ouo·lala·ouo (赞：0)

几个注意点：

1句1次机会，所以应该要分句处理，另外可以在词语前后加空格来减免处理难度，逗号前后别忘了加空格。差不多就这么几点，AC代码附上

```delphi
var
  word,sen:array[1..1000]of ansistring;
  qs:ansistring;
  n,i,j,k,w,ans:longint;
  b:array[1..1000]of boolean;
procedure cl;
var l,i:longint;
begin
  l:=1;
  w:=1;
  for i:=1 to length(qs) do
  if qs[i]='.' then
  begin
    sen[w]:=' '+copy(qs,l,i-l)+' ';
    inc(w);
    l:=i+1;
  end;
end;

procedure clcl;
begin
  for i:=1 to w do
  begin
    j:=1;
    while j<=length(sen[i]) do
    begin
      if sen[i,j]=',' then
      begin
        insert(' ',sen[i],j+1);
        insert(' ',sen[i],j);
        inc(j);
      end;
      inc(j);
    end;
  end;
end;

begin
  readln(n);
  for i:=1 to n do
  begin
    readln(word[i]);
    word[i]:=' '+lowercase(word[i])+' ';
  end;
  readln(qs);
  qs:=lowercase(qs);
  cl;
  clcl;
  for i:=1 to w do
  begin
    fillchar(b,sizeof(b),true);
    for j:=1 to n do
     for k:=1 to length(sen[i])-length(word[j])+1 do
      if (copy(sen[i],k,length(word[j]))=word[j])and b[j] then begin inc(ans); b[j]:=false; end;
  end;
  writeln(ans);
end.
```

---

## 作者：TNoName (赞：0)

好像没有Python的题解，那我就来水一发

~~虽然用Python这题简直是普及-但是比赛不能用啊~~

先审题，嗯，字符串，拆分，去重

~~掌声~~有请.split()和set()登场

#### .split()：

将字符串拆分为包含数个字符串的列表。用法一般是str1.split(str="",num=str1.count(str)),其中str即为分隔符，默认为所有的空白字符（？），如" ""\n""\t"等；num表示拆分几次，默认为全部(str1.count(str)返回str在srt1中出现的次数)



#### set(iterable)：

把一个可迭代的对象转换为一个集合,集合内的元素是两两不同的。如果你试图将两个一样的元素塞进同一个集合，Python会很友善地帮你去重。集合是无序的，并且访问速度很快，可以在常数时间内查询是否包含某个元素（使用"in"操作符）。

补充：str.lower():将str里的所有大写字母变成小写的。
因为这道题不区分大小写所以就用它来统一变成小写（类似功能的.upper()当然也可以）

那么现在上代码：

```python3
n=int(input())#读入n
l=[input().lower() for i in range(n)]
s=input().lower().split('.')

st=[set((' '.join(i.split(','))).split(' ')) for i in s]

ans=0

for i in l:
    for j in st:
        if i in j:
            ans+=1

print(ans)
```

众：nmd这些中括号是什么玩意？？？

那些l=[...]是Python的列表推导

~~虽然看起来秀但是其实效率不是特别高不推荐用~~

列表推导基本语法：l=[fun(i) for i in iterable]

等价于:
```python3
for i in iterable:
    l.append(fun(i))
```
那么现在可以去一行一行地看代码啦！

>l=[input().lower() for i in range(n)]

读入词汇列表并转化为小写

>s=input().lower().split('.')

读入“情书”，转化为小写，并拆分为句子~~你家情书骂人**？？？~~

>st=[set((' '.join(i.split(','))).split(' ')) for i in s]

将句子拆为单词，并去重。其中：
>' '.join(i.split(','))

把i中的','替换为' '（其实完全没必要用split和join……）

之后两层循环遍历l和st并计数，最后输出答案。


友情提醒：Luogu在线IDE跑Python有时候会在行末加上谜之空白字符导致匹配失败……orz（甚至有时候评测机也会这样，大概是不同系统的锅？）

[评测记录](https://www.luogu.org/record/22910743)





---

## 作者：缘起□缘灭 (赞：0)

### 其实这个题目很简单啦~~但是我还是交了无数次~~
###### ~~有没有谁同我一样，没有看到不区分大小写的~~


------------
其实不必要去一个个单词，一个个句子去判断，~~因为我们有substr函数~~，可以取字符串的子串；~~和find函数~~，可以在某个字符串中找另一个字符串并返回位置。
有一点要注意，要在每个词汇列表的单词前后加一个空格，因为可能某个单词包含了另一个单词，比如：this中就包含is所以应当在单词前后加空格表示是一个单词。
```
for(int i=1;i<=n;++i)
	cin>>a[i],
    transform(a[i].begin(),a[i].end(),a[i].begin(),::tolower),a[i]=' '+a[i]+' ';//转成小写的函数
```

关于‘，’的问题，我们可以在读入字符串的时候就直接将‘，’转换成空格就是了
```
while(b.find(',',d)!=-1)d=b.find(',',d),b[d]=' ',d++;
```
记得将d归零或者是再设置一个变量。

核心代码：
```
d=0;
	while(b.find('.',d)!=-1){
		e=b.find('.',d);
		c=b.substr(d,e-d);
		c=' '+c+' ';
		for(int i=1;i<=n;i++)
			if(c.find(a[i])!=-1)
				ans++;
		d=e+1;
	}
```

---


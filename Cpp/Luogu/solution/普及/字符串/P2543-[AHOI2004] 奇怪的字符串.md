# [AHOI2004] 奇怪的字符串

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1654.png)


## 样例 #1

### 输入

```
01010101010 00000011111```

### 输出

```
6```

## 样例 #2

### 输入

```
01011 010010101111111111```

### 输出

```
5```

# 题解

## 作者：An_Account (赞：26)

这道题就是LCS的模板，状态转移方程就是**dp[i][j]=(a[i-1]==b[j-1])?dp[i-1][j-1]:max(dp[i-1][j],dp[i][j-1])**

其中，i代表串a已经计算到了第i个字符，j代表串b已经计算到了第j个字符，dp[i][j]代表a的前i个字符与b的前j个字符的LCS。

所以，如果这两个字符相等，那么直接继承dp[i-1][j-1]；

反之，则在dp[i-1][j]，dp[i][j-1]中选取最大的数。

为了优化一下（毕竟ab两串最大有10000个字符），所以我们可以想到滚动数组。

dp[i][j]只与上一行有关联，所以上面的那个方程可以写成if (a[i-1]==b[j-1]) dp[i%2][j]=dp[(i-1)%2][j-1]+1 else dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1])。

现在上代码。

```cpp
#include <iostream>
using namespace std;
int dp[2][10001];
int main()
{
    string a,b;
    cin>>a>>b;
    for (int i=1;i<=a.size();i++)
    for (int j=1;j<=b.size();j++)
    if (a[i-1]==b[j-1]) dp[i%2][j]=dp[(i-1)%2][j-1]+1;
    else dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
    cout<<dp[a.size()%2][b.size()];
}
```

---

## 作者：Drifterming (赞：14)

/\*DP
我们可以知道，在每一个位置有两种状态，i表示a串下标，j表示b串下标。

1、a[i]==b[i] --> dp[i][j]=dp[i-1][j-1]+1

2、a[i]!=b[j]--> dp[i][j]=max(dp[i][j-1],dp[i-1][j]

所以判断每个位置的状态，DP求解就可以了。

\*/


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
string a,b;
int dp[10001][10001];
int main()
{
    cin>>a>>b;
    int la=a.length(),lb=b.length();
    for(int i=1;i<=la;i++)    //从1开始，避免数组下标变负 
    {
        for(int j=1;j<=lb;j++)
        {
            if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1;
            else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
        }
    }
    printf("%d",dp[la][lb]);
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：7)

本题为 LCS 模板，且数据范围允许 $O(n^2)$ 算法。本文后面会介绍进阶版本。

## 题目大意
![](https://cdn.luogu.com.cn/upload/pic/1654.png)

求 $\operatorname{Longest\ Common\ Subsequence}(A,B)$。

## 大体思路
首先介绍 $O(n^2)$ 算法。

用 $f(i,j)$ 表示 $\operatorname{Lcs}A[1\sim i],B[1\sim j]$。分三种情况：

1. 若选择 $A_i$ 但不选 $B_j$，则 $f(i,j)=\max\left\{f_{(i,j)},f_{(i,j-1)}\right\}$；

1. 若选择 $B_j$ 但不选 $A_i$，则 $f(i,j)=\max\left\{f_{(i,j)},f_{(i-1,j)}\right\}$；

3. 当 $A_i=B_j$ 时，两个元素均选择，此时 $f(i,j)=\max\left\{f_{(i,j)},f_{(i-1,j-1)}+1\right\}$。

由于每一次状态转移均只需用到 $i-1$，因此用滚动数组优化空间。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int Max(int x,int y) {return x>y?x:y;}//手写会快一点
const int maxn=10005;
int f[2][maxn],n,m;
char a[maxn],b[maxn];
int main(){
	scanf("%s",a+1);n=strlen(a+1);
	scanf("%s",b+1);m=strlen(b+1);//输入
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i&1][j]=Max(f[i&1][j-1],f[(i-1)&1][j]);//滚动数组优化
			if(a[i]==b[j]) f[i&1][j]=Max(f[i&1][j],f[(i-1)&1][j-1]+1);
		}//ab 均选
	}
	printf("%d",f[n&1][m]);//输出
	return 0;
}
```
~~（抄代码的可以走了）~~

## 优化
要想压缩时间效率，关键就在 $for$ 循环上，做到尽可能少的遍历即可

1. 首先我们给第一个序列的值进行按顺序的编号，即将 $a$ 数组 $\{11\ 77\ 55\ 44\ 88\ 33\ 99\}$ 变为 $\{11\ 22\ 33\ 44\ 55\ 66\ 77\}$，并开一个数组将修改的值标记。

2. 对另一个序列，进行同样的编号，即根据开的标记数组赋值（同一个编号对应的值相同，若 $b$ 数组中含有 $a$ 中没有的值，就编号为 $0$ ,因为后续操作无须考虑）。

3. 这时，公共子序列就是 $b$ 中编号上升的序列，为什么？因为你进行编号就是为了便于判断顺序，肯定是要编号小的在前才能形成公共子序列，即顺序和 $a$ 中一致。

4. 最后一步，二分查找 $b$ 中最大上升子序列，用 $\text{lower\_bound}$，效率更高。

于是，复杂度降为 $O(n\log n)$。

例题：https://www.luogu.com.cn/problem/UVA10635 。

## 求次数
那究竟如何求 LCS 出现的次数呢？其实还是用动态规划的思想，加上简单的容斥。

考虑 $f[i][j]=k$,那么就加上 $f[i-1][j]$ 和 $f[i][j-1]$ 中 $=k$ 的方案数。

如果 $a[i]=b[j]$ ,那么还要算上 $f[i-1][j-1]$ 的方案数；但是如果 $a[i]\neq b[j]$ 且 $f[i-1][j-1]=k$，就要减去它的方案数了（容斥）。

另外，一定要开滚动数组（一次只存两状态即可），否则 MLE 等着你。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=5005;
const int mod=1e8;
int f[2][maxn],g[2][maxn],n,m;
char a[maxn],b[maxn];
signed main(){
	scanf("%s",a+1);scanf("%s",b+1);
	n=strlen(a+1)-1;m=strlen(b+1)-1;
	for(int i=0;i<=m;i++) g[0][i]=1;
	g[1][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i&1][j] = max(f[(i-1)&1][j],f[i&1][j-1]);
			g[i&1][j] = 0;
			if(a[i] == b[j]) f[i&1][j] = max(f[i&1][j],f[(i-1)&1][j-1]+1);
			if(a[i] == b[j] && f[i&1][j] == f[(i-1)&1][j-1]+1) 
				g[i&1][j] += g[(i-1)&1][j-1];
			if(f[(i-1)&1][j] == f[i&1][j]) 
				g[i&1][j] += g[(i-1)&1][j];
			if(f[i&1][j-1] == f[i&1][j]) 
				g[i&1][j] += g[i&1][j-1];
			if(f[i&1][j] == f[(i-1)&1][j-1])
				g[i&1][j] -= g[(i-1)&1][j-1];
			(g[i&1][j]+=mod) %= mod;
		}
	}
	printf("%lld\n%lld",f[n&1][m],g[n&1][m]);
	return 0;
}
```
例题：https://www.luogu.com.cn/problem/P2516 。

---

## 作者：cyborg (赞：7)

不同的动态规划，时间更少

total代表当前只考虑字符串b前i个字符时最长公共子序列的长度，ans[j]表示公共子序列长度为j时且只考虑字符串b前i个字符时至少需要字符串a的前多少个字符。

也就是说，每多考虑b的一个字符b[i]，就在字符串a中从ans[j]到ans[j+1](0<=j<total)指向的位置进行一次循环，当发现字符a[add]与字符b[i]相同时，就把ans[j+1]的值缩小为add，再从ans[total]指向的位置开始直到字符串a的末尾，当发现有字符与b[i]相同时，就把total的值加一。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int main()
{
    //freopen("test.cpp","r",stdin);
    int ans[10001]={0},total=0,la,lb;ans[0]=-1;
    char a[10000],b[10000];
    cin>>a>>b;
    la=strlen(a);
    lb=strlen(b);
    for(int i=0;i<lb;i++)
    {
        int end=ans[total]+1;//这时候最长公共子序列至少需要字符串a的前end-1个字符
        for(int t=total;t>=1;t--)
        for(int add=ans[t-1]+1;add<ans[t];add++)if(a[add]==b[i])//当发现有字符相同时，就缩小ans[t]的值
        {ans[t]=add;break;}
        for(int add=end;add<la;add++)//从a的第end个字符开始考虑，看能不能找到字符与b[i]相同
        if(a[add]==b[i]){ans[++total]=add;break;}
    }
    cout<<total;//输出这时找到的最长公共子序列的长度
}
```

---

## 作者：syksykCCC (赞：5)

## 模板：最长公共子序列

#### **其它题解都没有解释很清楚最长公共子序列怎么求（或许是我太蒟了），故我来发一篇补充解释一下**

这篇题解是写给像我这样原本连最长公共子序列都不会求的人看的。。。

~~**我是安徽人，我深深地爱着我省的省选题**~~

于是先来解释一下如何用dp求最长公共子序列

我们用$s$和$t$来表示题目中所给出的两个字符串，用$f[i][j]$来表示$s[0] \sim s[i-1]$这个子串和$t[0] \sim t[j-1]$这个子串的最长公共子序列的长度，然后分类讨论：

$1.$若$s[i-1]$不在此时的最长公共子序列中，则我们完全可以忽略$s[i-1]$这个字符，因为它并不影响此时的最长公共子序列的长度，那么此时$f[i][j]=f[i-1][j]$（忽略字符$s[i]$直接转移）  
$2.$若$t[j-1]$不在此时的最长公共子序列中，$f[i][j]=f[i][j-1]$，分析同上  
$3.$若$s[i-1]==t[j-1]$，那么他们两个可以组成最长公共子序列中新的一个元素，此时$f[i][j]=f[i-1][j-1]+1$，即为去掉它们两个时最长公共子序列的长度加上它们两个所组成的长度（也就是$1$啦）

综上所述，$f[i][j]$为以上三种情况中的最大值，其中第三种情况有先决要求

答案为$f[s.size()][t.size()]$（也就是两个整串的最长公共子序列的长度）

特别的，无论如何，我们都可以采取前两种情况，因为它与当前的$i,j$没有任何关系

code:
```
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int f[10002][10002];
int main()
{
    ios::sync_with_stdio(false);//关闭同步加速
    string s,t;
    cin>>s>>t;
    int len1=s.size(),len2=t.size();
    for(int i=1;i<=len1;i++)
    {
        for(int j=1;j<=len2;j++)//循环枚举每一个f
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);//设为(1)和(2)中的大值
            if(s[i-1]==t[j-1])//满足(3)的条件
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);//加入考虑(3)
        }
    }
    cout<<f[len1][len2]<<endl;//输出长度
    return 0;
}
```

求过，~~毕竟其它题解都没解释的清楚嘛~~

## ~~劳烦各位管理员造福蒟蒻~~，也希望各位大佬来指正哦！

---

## 作者：拂清歌 (赞：3)

# Hello everyone,running来发题解了
### 首先瞅瞅题目，这是一道“DP（动态规划）”，LCS模板
###### 滚动数组直接搞定，DP[i][j]表示a数列的前i个和b的前j个做LCS（在a的第i个和b的第j个相同的情况下）否则，继承财产，把之前的DP[i-1][j]和DP[j-1][1]中找最优的那个
###### 贴代码
```cpp
#include <bits/stdc++.h>
#define INF 2147483647//我习惯的代码模板 
#define _MATH_DEFINES_DEFINED
#pragma GCC optimize("O2")//手动开 O2 
using namespace std;
signed main(void){
    string a,b;
    cin>>a>>b;
    int DP[2][max(a.size(),b.size())+5];//DP数组，存每一步的状态 
    memset(DP,0,sizeof(DP));//DP数组清零 
    for (int i=0;i<a.size();i++){//枚举a数组的每一个元素 
        for (int j=0;j<b.size();j++){//枚举b数组的每一个元素 
            if(a[i]==b[j]) DP[(i+1)%2][j+1]=DP[i%2][j]+1;//如果这两个元素相等，一顿操作猛如虎 
            else DP[(i+1)%2][(j+1)]=max(DP[i%2][j+1],DP[(i+1)%2][j]);//否则，找之前的最优策略 
        }
    }
    cout<<DP[a.size()%2][b.size()];//输出最后的答案 
    return 0; 
}
```
好啦，个人原创，如有雷同，私信作者

---

## 作者：Drifterming (赞：2)

/\*DP
我们可以知道，在每一个位置有两种状态，i表示a串下标，j表示b串下标。

1、a[i]==b[i] --> dp[i][j]=dp[i-1][j-1]+1

2、a[i]!=b[j]--> dp[i][j]=max(dp[i][j-1],dp[i-1][j]

所以判断每个位置的状态，DP求解就可以了。

\*/


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
string a,b;
int dp[10001][10001];
int main()
{
    cin>>a>>b;
    int la=a.length(),lb=b.length();
    for(int i=1;i<=la;i++)    //从1开始，避免数组下标变负 
    {
        for(int j=1;j<=lb;j++)
        {
            if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1;
            else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
        }
    }
    printf("%d",dp[la][lb]);
    return 0;
}
```

---

## 作者：fighter_OI (赞：1)

最长公共子序列 dp

以 f[i,j]表示第一个串前i个字母与第二个串前j个字母的最长公共子序列

则有：

1. s1[i]=s2[j] f[i,j]=f[i-1,j-1]+1

2. s1[i]<>s2[j] f[i,j]=max(f[i-1,j],f[i,j-1])

注意压缩空间，我用了滚动数组

（P.S.我一同学开了[0..5000,0..5000] 洛谷神机竟然没爆）

标程：

```cpp
uses math;
var a,b:array[0..100000] of longint;
    s,s1,s2:ansistring;
    x,n1,n2,i,j:longint;
begin
 readln(s);
 x:=pos(' ',s);
 s1:=copy(s,1,x-1);
 s2:=copy(s,x+1,length(s)-x);
 n1:=x-1;
 n2:=length(s2);
 for i:=0 to n2 do
  a[i]:=0;
 for i:=1 to n1 do
  begin
   for j:=1 to n2 do
     if s1[i]=s2[j] then b[j]:=a[j-1]+1
                    else b[j]:=max(a[j],b[j-1]);
   a:=b;
  end;
 write(b[n2]);
end.
```

---

## 作者：HPXXZYY (赞：1)

[博客](https://www.luogu.org/blog/hpwwzyy2012/solution-p2543)“食用”效果更佳

这题是一道比较经典的动态规划的题目，是好几本c++或其它语言动态规划入门例题

方法：设dp[i][j]表示a[1..i]到b[1..j]的最长公共子序列长度
当a[i]==b[j]时，dp[i][j]=dp[i-1][j-1]+1
当a[i]!=b[j]时，dp[i][j]=max(dp[i-1][j],dp[i][j-1])

注意事项：本题时间复杂度可以接受，但空间复杂度令人无法接受（开10000*10000的int数组大概需要380MB空间，会MLE）

解决方法：我们发现dp[i][j]的值只和dp[i-1][j]（或dp[i][j-1],dp[i-1][j-1]）的值有关，与dp[i-2][j]（或dp[i][j-2],dp[i-2][j-2]）的值无直接关系，所以可以使用滚动数组优化~~，具体见代码~~

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=10010;
//把数组的长度用常数表示是个好习惯
//当所有数组长度相同时，既可以缩短代码长度，
//又可以降低出错率，还可以实现在修改数组长度时统一修改（这既是优点，也是缺点）
int la,lb,i,j;
int dp[2][N];
char a[N],b[N];
int main(){
    scanf("%s%s",a+1,b+1);
    la=strlen(a+1);
    lb=strlen(b+1);
    for(i=1;i<=la;i++)
    for(j=1;j<=lb;j++)
    if (a[i]==b[j]) dp[i%2][j]=dp[(i-1)%2][j-1]+1;
    else dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
    printf("%d",dp[la%2][lb]);
    return 0;
}
```

---

## 作者：dph754132771 (赞：1)

可以自行百度，最长公共子序列，还有，题目的数据比较水。。。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
short f[5001][5001];//f[i][j]表示串1到第i位，串2到第j位时可能的的最长公共子序列长度 
string s1,s2;
int main(){
    cin>>s1>>s2;
    memset(f,0,sizeof(f));
    for (int i=1;i<=s1.length();i++)
        for (int j=1;j<=s2.length();j++){
            if (s1[i-1]==s2[j-1]) f[i][j]=f[i-1][j-1]+1;//当前字符相同长度加一 
            else f[i][j]=max(f[i-1][j],f[i][j-1]);//否则选择前者最大的序列长度 
        }
    printf("%d",f[s1.length()][s2.length()]);
    return 0;
}
```

---

## 作者：TLMPEX (赞：0)

这是道LCS模板题，状态转移方程就是：

**if(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1;**

**else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);**

代码：
```c
#include<bits/stdc++.h>
using namespace std;
string a,b;
int dp[10000][10000];
int main(){
	int la,lb,i,j;
	cin>>a>>b;//输入
	la=a.size();//取a串长度
	lb=b.size();//取b串长度
	a=' '+a;
	b=' '+b;
	for(i=1;i<=la;i++)
		for(j=1;j<=lb;j++){
			if(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1;//如果匹配，哪么dp[i][j]就等于dp[i-1][j-1]+1
			else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);//如果不能匹配，就在dp[i-1][j]与dp[i][j-1]中取最大值
		}
	cout<<dp[la][lb];//输出
}
```


---

## 作者：Nozebry (赞：0)

# 题目分析：
这道题我们一开始不难想到最简单的方法——暴力枚举，它的时间复杂度为 **$O(length(X)×length(Y))$** 虽说好像也可以过（虽然字符串 $X$ 和字符串 $Y$ 的最大长度为 $9999$ ），但其实这道题是一道 $DP$ 题。

经过模拟样例我们不难找出递推公式：

**在每一个位置只可能有两种状态，在计算机内即为开( $1$ )关( $0$ )可以用 $i$ 表示 $x$ 串下标，用 $j$ 表示 $y$ 串下标。**

1、当 $a[i]=b[j]$ 时，$f[i,j]=f[i-1,j-1]+1$

2、当 $a[i]<>b[j]$ 时，$f[i,j]=max(f[i,j-1],f[i-1,j])$

## AC Code：

```pascal
uses math;
var
	i,j:longint;
	s,a,b:ansistring;
	f:array of array of longint;//在这里调用了pascal神奇的动态数组，数组大小可以在主程序里自行调用
begin
	readln(s);
	a:=copy(s,1,pos(' ',s)-1);
	delete(s,1,pos(' ',s));b:=s;//由于输入的两个数肯能很大，所以输入时要用字符串，再分成两个数
	setlength(f,length(a)+1,length(b)+1);//setlength：动态数组大小调用函数
	for i:=1 to length(a) do
		for j:=1 to length(b) do
			if a[i]=b[j] then f[i,j]:=f[i-1,j-1]+1
				else f[i,j]:=max(f[i-1,j],f[i,j-1]);//这里其实就是上方推出的递推公式
	writeln(f[length(a),length(b)]);//注意，最终结果在f[length(a),length(b)]，而不是f[1,1]
end.
```
（注： $pascal$ 的[math库](https://blog.csdn.net/white_elephant/article/details/51755412)，可以了解一下。。。）

---

## 作者：血色黄昏 (赞：0)

PY党的福利来了

怎么谷py题解这么少QwQ

LCS模板题 转移方程为dp[i][j]=(a[i-1]==b[j-1])?dp[i-1][j-1]:max(dp[i-1][j],dp[i][j-1])

有了转移方程代码就好懂了，其他请自行百度~

```python
l = [[0 for i in range(10001)], [0 for i in range(10001)]]
s = input().split()
n, m = s[0], s[1]
for i in range(len(n) + 1):
    for j in range(len(m) + 1):
        if n[i - 1] == m[j - 1]:
            l[i % 2][j] = l[(i - 1) % 2][j - 1] + 1;
            continue
        l[i % 2][j] = max(l[(i - 1) % 2][j], l[i % 2][j - 1])
print(l[len(n)][len(m)])
```

谢谢！

---

## 作者：巴塞罗那竞技 (赞：0)

这题不难，lcs模板即可(不知道为什么标签里有Hash。。)(用Hash怎么做。。)
## 注意注意注意：得用滚动数组(虽然不用也能满分。。)(请管理员加强数据)。
上代码。
```cpp
()```
#include<bits/stdc++.h>
using namespace std;
string a,b;```

int dp[2][10001];
int main()
{
     cin>>a>>b;
     for(int i=1;i<=a.length();i++)
         for(int j=1;j<=b.length();j++)
             if(a[i-1]==b[j-1])dp[i%2][j]=dp[(i-1)%2][j-1]+1;
                 else dp[i%2][j]=max(dp[i%2][j-1],dp[(i-1)%2][j]);
     cout<<dp[a.length()%2][b.length()];
     return 0;
}
```
```
我是AH人，我为我们的好（水）题感到骄傲自豪！

---

## 作者：L_Bennett (赞：0)

这道题得用动态数组（滚动数组），最好不要开很大作死。

这题就是最长公共子序列。

附上代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N(10000);
char s1[N],s2[N];
int f[N>>1][N>>1];
int main()
{
    cin>>s1>>s2;
    int n1=strlen(s1),n2=strlen(s2);
    for(int i=1;i<=n1;i++)
      for(int j=1;j<=n2;j++)
        if(s1[i-1]==s2[j-1]) f[i][j]=f[i-1][j-1]+1;
        else f[i][j]=max(f[i-1][j],f[i][j-1]);
    cout<<f[n1][n2];
    return 0;
}
```

---

## 作者：lizehan888 (赞：0)

(本题是2543的弱化版)pascal党，发福利了

```cpp
var
  f:array of array of longint;//动态数组真心好用
  s,s1,s2:ansistring;
  p,i,j:longint;
function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;
begin
  readln(s);
  p:=pos(' ',s);
  s1:=copy(s,1,p-1);
  s2:=copy(s,p+1,length(s));
  setlength(f,length(s1)+1,length(s2)+1);//开启动态数组，巨省空间
  for i:=1 to length(s1)do
    for j:=1 to length(s2)do
//正常的dp，自己想
  write(f[length(s1),length(s2)]);   
end.
```

---

## 作者：Little_Ming (赞：0)

正常DP，但要注意空间，把二维压缩成一维

```cpp
|var r,s1,s2:ansistring;p,i,j:longint;
|    dp,dpn:array[0..10000]of longint;
|procedure mt(var a:longint;b:longint);
|begin
|  if b>a then a:=b;
|end;
|begin
|  readln(r);
|  p:=pos(' ',r);
|  s1:=copy(r,1,p-1);
|  s2:=copy(r,p+1,length(r));
|  for i:=1 to length(s1) do
|  begin
|    for j:=1 to length(s2)do
|    begin
|      if s1[i]=s2[j] then dp[j]:=dpn[j-1]+1;
|      mt(dp[j],dp[j-1]);
|      mt(dp[j],dpn[j]);
|    end;
|    dpn:=dp;
|  end;
|  writeln(dpn[length(s2)]);
|end.

```

---

## 作者：co_step (赞：0)

#发现没有Pascal的题解，我就来写一个#

###经典的LCS###

```cpp
var
  f:array[0..5000,0..5000] of longint; //存储两个字符串分别为i,j时最长公共子序列的长度(原来开了10000*10000，结果MLE了)
  st1,st2:ansistring;
  i,j:longint;
begin
  readln(st2);
  st1:=copy(st2,1,pos(' ',st2)-1);
  st2:=copy(st2,pos(' ',st2)+1,length(st2)); //读入两个以空格分隔的字符串
  for i:=1 to length(st1) do
    for j:=1 to length(st2) do
      if st1[i]=st2[j] then
        f[i,j]:=f[i-1,j-1]+1 //如果两个字符相等的话就+1
                       else
        if f[i-1,j]>=f[i,j-1] then
          f[i,j]:=f[i-1,j]
                                else
          f[i,j]:=f[i,j-1]; //不是的话就取i-1,j-1中大的一个
  writeln(f[length(st1),length(st2)]); //输出最长公共子序列的长度
end.
```

---

## 作者：doby (赞：0)

经典的dp题目……

状态转移方程在循环里……

其实也没什么需要解释的……

```cpp
#include<iostream>
#include<cstring>
using namespace std;
string x,y;
int n,f[5009][5009]={0},l1,l2;//5000*5000竟然没爆……
int maxn(int a,int b){if(a>b){return a;}else{return b;}}//比max函数略快……
int main()
{
    cin>>x>>y;
    l1=x.size(),l2=y.size();
    for(int i=1;i<=l1;i++)
    {
        for(int j=1;j<=l2;j++)
        {
            if(x[i-1]==y[j-1]){f[i][j]=f[i-1][j-1]+1;}//状态转移
            else{f[i][j]=maxn(f[i-1][j],f[i][j-1]);}
        }
    }
    cout<<f[l1][l2];
    return 0;
}
```

---

## 作者：x_faraway_x (赞：0)

没有c++的题解，我就来写一个吧……

这道题是裸的最长公共子序列，但是要注意空间，所以要用滚动数组。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 10005;
char x[N], y[N];
int xl, yl, f[2][N];
void init() {
    cin >> x+1 >> y+1;
    xl = strlen(x+1);
    yl = strlen(y+1);
}
void work() {
    for(int i = 1; i <= xl; i++) 
        for(int j = 1; j <= yl; j++)
            if(x[i] == y[j]) 
                f[i%2][j] = f[(i-1)%2][j-1]+1;
            else
                f[i%2][j]=max(f[(i-1)%2][j],f[i%2][j-1]);
    cout << f[xl%2][yl];
}
int main() {
    init();
    work();
}
```

---


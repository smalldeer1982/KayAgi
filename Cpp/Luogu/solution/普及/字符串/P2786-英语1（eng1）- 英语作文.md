# 英语1（eng1）- 英语作文

## 题目背景

蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻HansBug知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$ ，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！

## 说明/提示

样例 $1$ 中，共计出现了 $2$ 次`hansbug`、 $2$ 次`absi2011` 、 $1$ 次 `yyy` 、 $1$ 次`kkksc03`、 $1$ 次  `lzn` ，所以总含金量为 $1\times2+2\times4+3\times1+4\times1+100\times1=115$，对 $99$ 取模就是 $16$ 。

样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。

此题目中大小写敏感。

数据范围（设所有单词的最大长度为 $Lmax$ ）：

![](https://cdn.luogu.com.cn/upload/pic/2228.png)


## 样例 #1

### 输入

```
5 99
hansbug 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
hansbug is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and hansbug.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

## 样例 #2

### 输入

```
5 99
yyyy 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
yyyy is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and yyyy.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

# 题解

## 作者：Diamiko (赞：19)

本题解使用std::map。

其实非常简单，我们只要把所有高级词汇和它的含金量存在map里，输入文章的时候计算，直接输出结果就OK了。需要注意的就是输入的处理。

正解应该是平衡树吧，我也不清楚，看tag知道的。但map内置红黑树，所以效率不会低很多。

具体见代码。

```cpp
#include<iostream>
#include<map>
#include<string>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long ll;
ll n,p;
map<string,ll>a;
ll ans;
int main()
{
    scanf("%lld%lld",&n,&p);
    for(int i=1;i<=n;i++)
    {
        string word;
        ll value;
        cin>>word>>value;
        a[word]=value;
        //word即高级词汇，value即其含金量
    }
    string t="";
    char c;
    //t存储词汇
    //c是用于输入的临时变量
    while(scanf("%c",&c)!=EOF)
    {
        if(!(isdigit(c)||isalpha(c)))
        {
            //不是数字，也不是字母，那就是分隔符或者空格回车之类的
            ans=((ans%p)+(a[t]%p))%p;
            //那么就更新答案，把上一个词的含金量加上
            //如果上一个词不是高级词汇，那么在map里对应的含金量就是0
            //相当于没有变化
            //为了答案不溢出，随时取模
            t="";
            //还原，以便记录下一个词
        }
        else t+=c;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：BackSlashDelta (赞：10)

解法：**哈希（hash）** + **二分查找（binary search）**

本来的做法是 哈希 + 暴力查找，然后我光荣地 TLE 了五个点。~~废话，暴力不 TLE 谁 TLE。~~

对于每个“高级词汇”，获取它们的**哈希值**，然后将哈希值**排序**（用**结构体**完成“含金量”与“高级词汇”的哈希值的对应）。 

对于文本中的每一个单词，取它的哈希值，并在结构体内进行**二分查找**，并在**查找时完成答案的更新**。

但是哈希有个令人头疼有不得不面对的问题——**哈希冲突**。   
所以为了**解决冲突**，~~只会写简单哈希的~~我使用了**两次异或运算**。   
因此我的哈希长这样：

```cpp
// typedef unsigned long long ulint ; 
ulint base = 8394824858985499411; 
ulint seed_1 = 5005454853518058551; 
ulint seed_2 = 3602030550927995261;
inline ulint hashit(string s)
{
	int l = s.size();
	ulint val = 0;
	for (int i = 0; i < l; i++)
	{
		val = s[i] * base + (val ^ seed_1);
		val ^= seed_2;
	}
	return val;
}
```

AC 代码：   
（该代码**大括号换行**）


```cpp
/**
 * codeby: \Delta
 * stamp: 20200424
 * note: hash with binary search
**/

#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long lint;
typedef long double ntrl;
typedef unsigned long long ulint;

// global
#define MAXN 100010
ulint MOD;
int n, m;
struct great
{
	ulint hsh, val; // 'hsh' is the hash value, and 'val' is the gold content
} word[MAXN]; // The words
lint ans; // The answer of this problem

// funtion
inline bool isltr(char x) { return (('a' <= x && x <= 'z') || ('A' <= x && x <= 'Z')); }
// (up) Tell me the 'x' is a letter or not.
inline bool cmp(great x, great y)
{
	return x.hsh < y.hsh;
}

// fastread
inline bool isnum(char x) { return ('0' <= x && x <= '9'); }
inline lint readlint()
{
	int sign = 1, val = 0;
	char tmp = getchar();
	while (!isnum(tmp))
	{
		if (tmp == '-')
		{
			sign = -sign;
		}
		tmp = getchar();
	}
	while (isnum(tmp))
	{
		val = val * 10 + tmp - 48;
		tmp = getchar();
	}
	return val * sign;
}

// hash
ulint base = 8394824858985499411, seed_1 = 5005454853518058551, seed_2 = 3602030550927995261;
inline ulint hashit(string s)
{
	int l = s.size();
	ulint val = 0;
	for (int i = 0; i < l; i++)
	{
		val = s[i] * base + (val ^ seed_1);
		val ^= seed_2;
	}
	return val;
}

// binary search
inline int bnrysrch(int l, int r, ulint key)
{
	int ret = -1;
	int mid;
	while (l <= r)
	{
		mid = l + ((r - l) >> 1);
		if (word[mid].hsh < key)
		{
			l = mid + 1;
		}
		else if (word[mid].hsh > key)
		{
			r = mid - 1;
		}
		else
		{
			ret = mid;
			ans += word[ret].val;
			ans %= MOD;
			break;
		}
	}
	return ret;
}

int main()
{
	n = readlint();
	MOD = readlint();

	string s;
	for (int i = 0; i < n; i++)
	{
		cin >> s;
		word[i].hsh = hashit(s);
		word[i].val = readlint();
	}

	sort(word, word + n, cmp);

	ulint hashval = 0;
	char tmpc;
	bool endword = false;
	s.clear();
	while (scanf("%c", &tmpc) != EOF) // Get the letter
	{
		if (!isltr(tmpc) && !isnum(tmpc) && !s.empty())
		{
			endword = true; // I have found a word
		}
		if (endword)
		{
			hashval = hashit(s);
			bnrysrch(0, n - 1, hashval);
			// debug
			cout << endl << s;
			printf(" , ans=%lld", ans);
			// end of debug
			s.clear();
			endword = false;
		}
		else if (isltr(tmpc) || isnum(tmpc))
		{
			s.append(1, tmpc); // Make the word
		}
	}

	printf("%lld\n", ans);

	return 0;
}

```

---

## 作者：1124828077ccj (赞：8)

//map真是个好东西，用它存储可以把代码变得很简单

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<map>
using namespace std;
int n,p,ans;
string a;
char t;
map<string,int>s;
int main()
{
    scanf("%d%d",&n,&p);
    for (int i=0;i<n;i++)
    {cin>>a;scanf("%d",&s[a]);}getchar();a="";
    while(scanf("%c",&t)==1)
    {
        if (!(t>='a' && t<='z' || t>='A' && t<='Z' || t>='0' && t<='9'))
        {ans=(ans+s[a])%p;a="";}
        else a+=t;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：户山香澄 (赞：6)

正如[little_gift大佬的题解](https://stars.blog.luogu.org/solution-p2786)中所说，

 _“本题从理论上来说应该是一道trie或类似数据结构的题,当然,大部分人都使用了map/hash.虽然相对无脑,不过也是解法.”_ 
 
 我一直感到很奇怪，这道题看起来就像一道trie的题，为什么题解中使用的全是hash/map/二分呢？
 
 直到我用trie做了这道题，然后……光荣的MLE 5个点。
 
 果然Trie是 _“用空间换时间”_ 的算法……
 
 于是我对基础的Trie进行了优化。
 
 介绍一种储存的方法——左儿子右兄弟。
 
 虽然优化以后还是有一个点MLE只有90分，但是比50分的已经好很多了。
 
 一般的Trie是对于每个节点存储其所有存在的字符的节点的位置，然而左儿子右兄弟的Trie中每个节点只有两个存储节点：nex和right.
 
 nex代表它的儿子，right代表它的兄弟。
 
有没有联想到一种存图方式——前向星？

反正具体看代码注释吧…….

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>

struct Node
{
    Node* nex;//存储最后一个儿子
    Node* right;//存储兄弟
    char ch;//存储该节点表示的字符
    int b;//含金量
    Node()
    {
        b = ch = 0;
        nex = right = NULL;
    }
}*r, *h, *v;
char s[51], st[51];

bool get_word()//这是专门为第二部分所写的读入单词用的函数
{
    char ch;
    int l = 0;
    memset(st, 0, sizeof st);
    for (ch = getchar(); !isalpha(ch) && !isdigit(ch) && ch != EOF; ch = getchar()) ;
    if (ch == EOF) return 0;
    for ( ; isalpha(ch) || isdigit(ch); st[l++] = ch, ch = getchar()) ;
    st[l] = '\0';
    return 1;
}

int main()
{   
    int n, p;
    scanf("%d%d", &n, &p);
    h = new Node;
    for (register int i = 1; i <= n; i++)
    {
        r = h;
        scanf("%s", s);
        int x;
        scanf("%d", &x);
        for (register int j = 0; s[j]; j++)
        {
            bool f = 0;
            for (v = r -> nex; v; v = v -> right)//遍历r的所有子节点，如果没有与当前字符相等的就新建一个
                if (v -> ch == s[j])
                {
                    f = 1;
                    break;
                }
            if (!f)//新建一个节点
            {
                v = new Node;
                v -> right = r -> nex;
                v -> ch = s[j];
                v -> nex = NULL;
                v -> b = 0;
                r -> nex = v;
            }
            r = v;
        }
        r -> b = x;
    }
    long long ans = 0;
    while (get_word())
    {
        r = h;
        bool flag = 1;
        for (register int j = 0; st[j]; j++)
        {
            bool f = 0;
            for (v = r -> nex; v; v = v -> right)//遍历r的所有子节点
                if (v -> ch == st[j]) 
                {
                    r = v;
                    f = 1;
                    break;
                }
            if (!f) //没找到
            {
                flag = 0;
                break;
            }
        }
        if (flag)
        {
            ans = (ans + r -> b) % p;
        }
    }
    printf("%lld\n", ans % p);

    return 0;
}
```
虽然只有90分，但是作为该题的另一种解法，不妨一试。

---

## 作者：Histone (赞：4)

字符串一直是蒟蒻的弱项啊

一直不会用map……

恰巧最近刚刚学会替罪羊树这种 **“暴力即优美”** 的数据结构

于是就想来试一试，~~结果一遍过，蒟蒻自己都不敢相信~~

现在为大家献上一个新的方法~

```cpp
struct node{
	int l,r,size,fact,val2;
	string val;
	bool exist;
}tzy[100005];

//l和r分别表示左右节点
//size和fact是替罪羊树的子树大小和子树真实大小
//val2就是含金量
//val来存单词
//exist表示该节点是否存在
```
有了结构后，我们就可以来实现替罪羊树了。

和标准替罪羊树没有什么区别

多写一个`findval2()`函数就好

```cpp
int findval2(string val){
	int now = root;
	while(now){
		if(tzy[now].val==val)break;
		if(val>tzy[now].val)//直接利用string的比较
			now = tzy[now].r;
		else
			now = tzy[now].l;
	}
	return tzy[now].val2;
}
```

完整代码太长，太占版面了

附上链接 [完整代码](https://www.cnblogs.com/Histone/p/12599958.html)

感谢观看，完结撒花~

---

## 作者：happybob (赞：3)

这个题目主要是怕TLE，不用hash之类的东西，map就轻松搞定，但细节值得留意

首先先分析一下算法，每次读入一个字符，如果是间隔符就把ans加到前面这个单词上，否则我们创造一个字符串去累加这个单词

（很多细节导致WA）

底下AC代码：

```cpp
#include <iostream>
#include <map>
#include <cstring>
#include <cstdio>
using namespace std;

map <string, int> mp;

char v;

string f = "", name;

int main()
{
    long long n, p, ans = 0, x;
    cin >> n >> p;
    for(int i = 1; i <= n; i++)
    {
        cin >> name >> x;
        mp[name] = x;
    }
    scanf("\n");//注意，这句话的用处在于高级词汇和文章之间的换行读入，因为读完高级词汇就直接进入while了。不加不会WA，但样例过不去（这……）
    while(scanf("%c", &v) != EOF)
    {
        if(v == ' ' || v == ',' || v == '.' || v == '!' || v == '?')
        {
            ans = (mp[f] + ans) % p;//每次直接取模，以防溢出
            f = "";//注意归0
        }
        else
        {
            f += v;
        }
    }
    cout << ans << endl;
    return 0;
}
```

当然，如果你喜欢30分，你也可以看这个暴力：

```
#include <cstdio>
#include <iostream>
#include <cstdio>
#include <unordered_map>
using namespace std;

unordered_map <string, int> mp;

char name[55];

string v;

int x;

int main()
{
    int n, p, ans = 0;
    scanf("%d %d", &n, &p);
    for(int i = 1; i <= n; i++)
    {
        scanf("%s %d", name , &x);
        mp[name] = x;
    }
    while(cin >> v)
    {
        for(unordered_map <string, int>::iterator it = mp.begin(); it != mp.end(); ++it)
        {
            if(v.find(it -> first) != string::npos)
            {
                ans += it -> second;
            }
        }
    }
    printf("%d\n", ans % p);
    return 0;
}

```
我的暴力法子之前写的，有很多没考虑到，请大家包容

连stl的hash容器unordered都过不去，看来大赛以及日常刷题一定要注意时限、数据以及时间复杂度

求个赞


---

## 作者：little_gift (赞：3)

**本题从理论上来说应该是一道trie或类似数据结构的题,当然,大部分人都使用了map/hash.虽然相对无脑,不过也是解法.这里就献上一份用fread+pbds写的目前最优解**

思路是用**map(__gnu_pbds::tree)**将所有的**"高级词汇"**映射到它的**"含金量"**,然后依次读取单词并判断是否是**"高级词汇"**,若是则累加**"含金量"**

**具体详见代码注释**
```cpp
#include <string>
#include <cstdio>
#include <cctype>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
const int ri_top = 1e7; //fread缓存区,若题目数据较大则需按需增大
char ri[ri_top], *rich = ri;
void read_int(int &x)
{
	while (!isdigit(*rich)) ++rich;
	for (x = *rich - '0'; isdigit(*++rich); x = x * 10 + *rich - '0');
} //在已读入的缓存区中读取一个整数,相当于sscanf(rich, "%d", &x); + 更新rich
//emm...我似乎没有想到fread可以配合sscanf使用.不过sscanf后要更新rich.
void read_st(char st[])
{
	while (isspace(*rich)) ++rich;
	for (*st = *rich; !isspace(*++rich); *(++st) = *rich);
	*(++st) = '\0';
} //原本使用的是string类型,使用了+=,但是结果比不用fread还慢.所以改成了奇怪的char[],具体思路就是把st当成指针(事实上传入的变量也是指针,这里的参数可能改为char *st更好一些)
int n, p, m, x, s;
char ch;
char st[51], *st1; //因为st不能随意更改,所以使用了st1并使其指向st[0].
//其实这里的思路和上面的ri,rich是差不多的.
__gnu_pbds::tree < string, int > mm; //pbds的map
__gnu_pbds::tree < string, int > :: iterator it; //pbds的迭代器
int main()
{
	fread(ri, 1, ri_top, stdin); //fread调用,把输入读取到ri中.
	read_int(n);
	read_int(p);
	for (register int i = n + 1; --i; )
	{
		read_st(st);
		read_int(x);
		mm[st] = x; //用__gnu_pbds::tree将"高级词汇"映射到"含金量"
	}
	while (*rich)
	{
		while (*rich && (ch = *(rich++), !isalpha(ch) && !isdigit(ch)));
		if (!*rich) break;
		st1 = st;
		for (*st1 = ch; ch = *(rich++), isalpha(ch) || isdigit(ch); *(++st1) += ch);
		*(++st1) = '\0'; //此处非常接近于上面的read_st(),只是更改了判断不符合条件的char的依据,并增加了若已经读完则退出的代码
		it = mm.find(st); //用find不用operator[](),就不会出现空项(因为operator[]()会在map中插入,以致增加时间复杂度)(至少我是这么认为的)
		if (it != mm.end()) //若是"高级词汇"
			s = (s + it -> second % p) % p; //增加"含金量"
	}
	printf("%d\n", s);
}
```

---

## 作者：zqy1018 (赞：2)

哈希+map...

被卡的飞起来

如果是字符串映射到数字的话，可能会很慢吧。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <map>
using namespace std;
typedef unsigned long long ll;
ll p,ans=0,base=10007;//取太小会被卡？？ 
char tmp[80];
map<ll,ll> mp;
int get(){
    memset(tmp,0,sizeof(tmp));
    char c;int l=0;
    for(c=getchar();isalpha(c)==0&&isdigit(c)==0&&c!=EOF;c=getchar());
    if(c==EOF)return -1;
    for(;isalpha(c)||isdigit(c);c=getchar())
        tmp[l++]=c;
    return l;
```
}//读取一个字符串
```cpp
int main(){
    int i,j,l,n;ll h,b;
    scanf("%d%llu",&n,&p);
    for(i=0;i<n;i++){
        scanf("%s%llu",tmp,&b);
        l=strlen(tmp);
        for(h=0,j=0;j<l;j++)
            h=h*base+tmp[j];
        mp[h]=b;
    }
    while((l=get())!=-1){
        for(h=0,j=0;j<l;j++)
            h=h*base+tmp[j];
        if(mp.count(h))ans+=mp[h];
    }
    printf("%llu\n",ans%p);
    return 0;
}
```

---

## 作者：Graphcity (赞：1)

这道题我们可以用 Hash 的办法做...

至于解决哈希冲突的方式，vector 其实够用了。

我们可以将每个高级词汇和含金量用一个 pair 一并存储在哈希表里面。接下来，对于那篇作文里面的单词，我们在哈希表里面挨个查找，看看有没有相同的就行了。

不过，这道题由于有分隔符的存在，作文的输入方式可能有点恶心，需要手动特判。

```cpp
#include<bits/stdc++.h>
#include<vector>
#include<string>
#define Maxn int(1e5)
using namespace std;
typedef pair<string,int> Pair;

vector<Pair> v[23334];

inline int Hash(string s)//获取哈希值 
{
	long long h=0;
	for(register int i=0;i<(int)s.size();++i)
	{
		h*=233;
		h+=(s[i]-'0');
		h%=23333;
	}
	return int(h);
}

int n,m,ans;

inline void Run(string s)//对于一个单词在哈希表里查找 
{
	int nowhash=Hash(s);
	for(register int i=0;i<(int)v[nowhash].size();++i)
		if(v[nowhash][i].first==s)
		{
			ans=(ans+v[nowhash][i].second)%m;
			break;
		}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i)
	{
		string a;
		int b;
		cin>>a;
		scanf("%d",&b);
		v[Hash(a)].push_back(make_pair(a,b%m));
	}
	
	string now;
	while(getline(cin,now))//单独输入一行 
	{
		string s;
		for(register int l=0;l<(int)now.size();++l)//判断单词 
		{
			char ch=now[l];
			if(ch==' ' || ch=='!' || ch=='?' || ch==',' || ch=='.')
			{
				Run(s);
				s.clear();
			}
			else s=s+ch;
		}
	}
	printf("%d",ans);
    return 0;
}

```


---

## 作者：Edgaru089 (赞：1)

题解有用pbds红黑树的呢

但还是比不过我C++11[unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map)黑科技！自带哈希的映射表！跑得比红黑树还快！是目前最快了。（开了O2，没用fread）
```cpp
/*
DOCUMENT NAME "20180720-luogu2786.cpp"
CREATION DATE 2018-07-20
SIGNATURE CODE_20180720_LUOGU2786
COMMENT 英语1（eng1）- 英语作文
*/

#include <cstdlib>
#include <iostream>
#include <unordered_map>
using namespace std;

int n, p;

int read() {
    int ans = 0;
    char c;
    while (!isdigit(c = getchar()));
    do {
        ans = (ans << 1) + (ans << 3) + c - '0';
    } while (isdigit(c = getchar()));
    return ans;
}

void read(int& val) { val = read(); }

bool isstr(int c) {
    return c != ' '&&c != ','&&c != '.'&&c != '!'&&c != '?'&&c != '\n'&&c != '\r';
}

char buf[30001];
void readstr(string& str) {
    str.clear();
    int c = 0;
    while (!isstr(c = getchar()) && c != EOF);
    if (c == EOF)
        return;
    do {
        str.push_back((char)c);
    } while (isstr(c = getchar()) && c != EOF);
}

string str;
unordered_map<string, int> m;

int main(int argc, char* argv[]) {

    m.rehash(200000);
    read(n); read(p);
    for (int i = 1; i <= n; i++) {
        readstr(str);
        m[str] = read();
    }


    readstr(str);
    int sum = 0;
    do {
        unordered_map<string, int>::iterator i = m.find(str);
        if (i != m.end())
            sum = (sum + i->second) % p;
        readstr(str);
    } while (str != "");

    printf("%d\n", sum);

    return 0;
}
```

---

## 作者：CalvinJin (赞：1)

字符串的排序+二分查找


一定要注意数组和变量范围

一个ansistring引发的血案


pascal代码见下

```pascal
var a:array[1..100000] of string; b:array[1..100000] of longint;
    n,i,j,t,l,r,m,x,p,ans:longint; s,s1:ansistring; biaodian:set of char;
procedure qsort(l,r:longint);
var i,j,z:longint; x,y:string;
begin
  i:=l; j:=r; x:=a[(l+r) div 2];
  repeat
    while a[i]<x do inc(i);
    while x<a[j] do dec(j);
    if not(i>j) then
    begin
      y:=a[i]; a[i]:=a[j]; a[j]:=y;
      z:=b[i]; b[i]:=b[j]; b[j]:=z;
      inc(i); dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
begin
  biaodian:=[' ',',','.','!','?'];
  read(n,p); readln;
  for i:=1 to n do
  begin
    readln(a[i]);
    x:=pos(' ',a[i]);
    val(copy(a[i],x,100),b[i]);
    delete(a[i],x,100);
  end;
  qsort(1,n);

  while not eof do
  begin
    readln(s);
    for i:=1 to length(s) do
      if s[i] in biaodian then s[i]:=' ';  //处理标点符号，后面找单词比较方便
    while (length(s)>0) and (s[1]=' ') do delete(s,1,1);//可能之前有多余空格，去掉
    while length(s)>0 do
    begin
      j:=1; s1:='';
      while s[j]<>' ' do begin s1:=s1+s[j]; inc(j); end;//找单词
      l:=1; r:=n;
      while l<r do                                  //二分查找
      begin
        m:=(l+r) div 2;
        if a[m]>s1 then r:=m;
        if a[m]<s1 then l:=m+1;
        if a[m]=s1 then begin l:=m; break; end;
      end;
      if a[l]=s1 then ans:=(ans+b[l] mod p) mod p;
      delete(s,1,j);                                                                 //删除已用单词
      while (length(s)>0) and (s[1]=' ') do delete(s,1,1);      //删除多余空格
    end;
  end;

  writeln(ans);
end.
```

---

## 作者：fallingdust (赞：0)

这道题目，我第一眼看上去，觉得：string读入，枚举暴力

写了大概10分钟后，发现：比较无比的麻烦，于是我果断放弃了枚举暴力

开始用一个很简单的数据结构写：map

map简直就是写这道题的神器！！！

好了，言归正传

到底要怎么去写这道题呢？？

很简单，

开一个map，把要比较的重点词汇压进去，然后一行一行读入作文，一个个比较，就OK了。

代码如下（重点在代码区）
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <map>
#include <cstdlib>
#include <cmath>
#include <iostream>
using namespace std;

#define ll long long
#define mx(x,y) x>y?x:y
#define mn(x,y) x<y?x:y
#define _e putchar(' ')
#define _v putchar('\n')
#define BF_N 1<<17

char buf[BF_N],sl,sr;
FILE *fin;

char gc() {
	return sl==sr&&(sr=(sl=0)+fread(buf,1,BF_N,stdin),sl==sr)?EOF:buf[sl++];
}

int Read() {
	int ans=0,k=1;
	char c=gc();
	while(!isdigit(c)) {
		if(c=='-')k=-1;
		c=gc();
	}
	while(isdigit(c)) {
		ans=ans*10+c-'0';
		c=gc();
	}
	return k*ans;
}
//上边是快速读入，非常快，支持int（其他的类型你自己改）
map<string,int> find_importance;//map使用
string b;						
//一行一行的作文，
string sentence,a,sd;			
int m,n,mod,ans=0,k=0;
//a---重点词汇，n---分数

void init() {		//读入
	cin>>m>>mod;		//重点词汇数目和
	for(int i=1; i<=m; ++i) {
		cin>>a>>n;
		find_importance[a]=n;
	}
	getline(cin,sd);
}

void work() {	//开始主要程序
	while(getline(cin,b)) {//一行一行读入
		for(int i=0; i<b.length(); ++i) {
        //判断是否为单词分隔
			if(b[i]==' '||b[i]==','||b[i]=='.'||b[i]=='!'||b[i]=='?') {
				if(find_importance[sentence]>=1) {
					ans+=find_importance[sentence];
					ans=ans%mod;
                    
//如果匹配成功，ans+=重点单词得分，%一次，防止溢出。
				}
				sentence="";//清空
			} else {
				sentence.push_back(b[i]);
			}
		}
	}
	cout<<ans%mod;  			
    //防止溢出，再%一次
}

int main() {
	init();
	work();
	return 0;
}
```

很简单，不过，能不能想到用map，就是个问题了。

---


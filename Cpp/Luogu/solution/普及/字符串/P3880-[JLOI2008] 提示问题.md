# [JLOI2008] 提示问题

## 题目描述

最近在 JLOI 网上的一个流行游戏中，选手要回答很难的问题。假如在规定时间内不能回答，系统将给出 $1$ 个提示，之后再依次给出第 $2,3$ 个提示。出现在答案中的是字母和下列字符：

$\verb|. , : ; ! ? - |$ 和空格（空格不会在开头和结尾出现）。

字母是指：小写字母 $\verb!a! \cdots \verb!z!$ 大写字母 $\verb!A! \cdots \verb!Z!$，其中 a e i o u A E I O U 是元音字母。

生成提示的规则：

- 第 $1$ 个提示：简单的将所有字母换成 $\verb!.!$ 即可；
- 第 $2$ 个提示：从第 $1$ 个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数 $N$，将第 $1$ 个提示中的前 $N$ 个字母显示；
- 第 $3$ 个提示：从第 $2$ 个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第 $1$ 个提示而来，即我们将前 $2/3$ 的字母显示（同样如不能被 $3$ 整除则取最接近的整数）。

## 样例 #1

### 输入

```
Upomoc! Lpv s nm pkrl sv smglsnk.```

### 输出

```
......! ... . .. .... .. ........ 
Upomoc! Lp. . .. .... .. ........ 
Upomoc! Lpv s nm pkrl s. ........
```

# 题解

## 作者：_StarBird_ (赞：11)

**题解 P3880 【[JLOI2008]提示问题】**

[题目传送门](https://www.luogu.com.cn/problem/P3880)

[在博客中食用更佳](https://www.luogu.com.cn/blog/jch2008/solution-p3880)

### 大 膜 你！

这题，没什么好说的，就是模拟。

我们考虑，把每一个提示都单独放在一个模块，一个一个处理就好了。

------------
###  提示1

 _简单的将所有字母换成'.'即可_ 
 
 题目说简单，貌似也挺简单的，扫一遍字符串，把字母换成'.'就好惹。
 
 另外，这个模块反正要扫一遍字符串，可以做个辅助，统计一下字母的个数。
 
**code:**
 ```cpp
void hint1()
{
    sum=0;
    for(int i=0;i<len;++i)//遍历字符串
        if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z') ++sum,printf(".");//如果找到字母，统计字母数并把字母换成.输出
        else printf("%c",str[i]);//如果是普通的符号，就直接输出
    puts("");//别忘了末尾换行
    return;
}
```

------------
###  提示2

 _从第1个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数$N$，将第1个提示中的前$N$个字母显示_ 
 
 这里需要把总字母个数除以三再四舍五入，比较麻烦。
 
 我们已经统计了字母的个数，所以可以手写一个四舍五入 ~~（lz太菜，不会一些奇怪的函数，有会的评论下叭）~~。
 
 这里可以用```(int)number```强制转换成$int$，会舍弃小数部分，保留整数部分，类似于 $\left[number\right]$，也就是向上取整，则```（int）number+1```为向下取整。
 
 
 四舍五入代码如下：
 ```cpp
int calc(double number)
{
    if (number==(int)number) return (int)number;//如果两数相等，说明除出来是个整数
    if (number-(int)number<(int)number+1-number) return (int)number;//如果这个数与向下取整的差小于向上取整的差，则应该向下取整
    else return (int)number+1;//否则（这个数与向上取整的差小于向下取整的差），则应该向上取整
    //怎样，是不是很玄学？（huaji
}
```

好了，废了那么多笔墨，我们完成了四舍五入。

接下来，就简单了：把字符串扫一遍，取前  $\frac{1}{3}$ 的字母改成'.'就好了。也是像 $hint1$ 一样做一些准备工作，我们可以记录 $\frac{1}{3}$ 的字母在哪个位置。

**code:**
```cpp
void hint2()
{
    int mark=calc(1.0*sum/3);//去除四舍五入后的三分之一，注意要*1.0转double
    int total=0;//字母数量
    for(int i=0;i<len;++i)
        if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')
        {
            ++total;
            if (total==mark) pos=i;//记录三分之一中最后一个字母的位置
            if (total<=mark) printf("%c",str[i]);//还没到三分之一且是字母，把原字符输出
            else printf(".");//在三分之一线以后的字母，化为'.'输出
        }
        else printf("%c",str[i]);//是普通字符，则直接输出
    puts("");
    return;
}
```

------------
###  提示3
_从第2个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第1个提示而来，即我们将前2/3的字母显示（同样如不能被3整除则取最接近的整数）_

这个提示分两步：首先要判断有没有可显示的元音字母，如果没有，就要扫一遍整个字符串，取前$\frac{2}{3}$的字母输出。

由于$hint2$calc函数的帮助，实现起来应该也比较容易，就是判断元音字母的if有点长，菜鸡lz甚至单独写了函数……

判断元音字母的函数，应该比较好写(唱跳rap篮球+C+V就好惹）：
```cpp
bool check(char ch)
{
    if (ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u' || ch=='A' || ch=='E' || ch=='I' || ch=='O' || ch=='U') return 1;//没啥好说的，判断就完事了
    return 0;
}
```
扫一遍，也没什么难度，写完，这题就差不多了。
```cpp
void hint3()
{
    bool flag=0;//是否有元音字母
    for(int i=pos+1;i<len;++i)//从上次的三分之一线后开始扫
        if (check(str[i])) {flag=1;break;}//扫到了元音字母就记录
    if (flag)//元音字母
    {
        for(int i=0;i<=pos;++i) printf("%c",str[i]);//先把三分之一线以前的字符输出
        for(int i=pos+1;i<len;++i)//找三分之一线之后的元音字母
            if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')//字母
            {
                if (check(str[i])) printf("%c",str[i]);//元音字母正常输出
                else printf(".");//辅音字母换成.输出
            }
            else printf("%c",str[i]);//普通字符直接输出
    }
    else//没有可输出的元音字母
    {
        int mx=calc(2.0*sum/3);//找到三分之二线
        int total=0;
        for(int i=0;i<len;++i)
        for(int i=0;i<len;++i)
	        if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')
	        {
	            ++total;//统计字母的个数
	            if (total<=mx) printf("%c",str[i]);//小于三分之二线直接输出
	            else printf(".");
	        }
	        else printf("%c",str[i]);//超过了三分之二线则化成'.'输出
    }
    puts("");
    return;
}
```

**完成！**



------------

完整程序：
```cpp
#include<bits/stdc++.h>
#define MAXN 60
using namespace std;
char str[MAXN];//字符串
int len,sum,pos;
int calc(double number)
{
    if (number==(int)number) return (int)number;
    if (number-(int)number<(int)number+1-number) return (int)number;
    else return (int)number+1;
}
bool check(char ch)
{
    if (ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u' || ch=='A' || ch=='E' || ch=='I' || ch=='O' || ch=='U') return 1;
    return 0;
}
void hint1()
{
    sum=0;
    for(int i=0;i<len;++i)
        if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z') ++sum,printf(".");
        else printf("%c",str[i]);
    puts("");
    return;
}
void hint2()
{
    int mark=calc(1.0*sum/3);
    int total=0;
    for(int i=0;i<len;++i)
        if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')
        {
            ++total;
            if (total==mark) pos=i;
            if (total<=mark) printf("%c",str[i]);
            else printf(".");
        }
        else printf("%c",str[i]);
    puts("");
    return;
}
void hint3()
{
    bool flag=0;
    for(int i=pos+1;i<len;++i)
        if (check(str[i])) {flag=1;break;}
    if (flag)
    {
        for(int i=0;i<=pos;++i) printf("%c",str[i]);
        for(int i=pos+1;i<len;++i)
            if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')
            {
                if (check(str[i])) printf("%c",str[i]);
                else printf(".");
            }
            else printf("%c",str[i]);
    }
    else
    {
        int mx=calc(2.0*sum/3);
        int total=0;
        for(int i=0;i<len;++i)
	        if (str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')
	        {
	            ++total;
	            if (total<=mx) printf("%c",str[i]);
	            else printf(".");
	        }
	        else printf("%c",str[i]);
    }
    puts("");
    return;
}
int main()
{
    cin.getline(str,MAXN);//有空格不能用cin或scanf，要用getline或gets
    len=strlen(str);//字符串长度
    hint1();
    hint2();
    hint3();
    return 0;
}
```
总结一下本题坑点：

1.输入有空格，cin和scanf很难用，最好用能读一行的来输入

2.四舍五入很麻烦

3.有元音字母不需要输出$\frac{2}{3}$的字母

4.元音字母的判断

**完**

---

## 作者：_MRCMRC_ (赞：6)

## 这道题太有意思了！

#### 需要注意的是，题目中操作2和操作3输出的，是所有**字母**数量的1/3或2/3，而不是字符串长度的1/3或2/3（这一点其实题解dalao们都说了）

# 那么我们就开始模拟吧！

##### 在这里给大家普及一个字符串的小处理方法：

```cpp
//头文件：
#include<iostream> 
#include<cstring>
```
```cpp
string s1(s.substr(0,k));
//定义一个字符串s1，截取字符串s的第0-第k位复制给s1
（说白了就是剪切-粘贴）
```

那么要是有两步操作：前半段需要截取s中的，后半段需要s1中的字符串，那该怎么操作呢？？

##### 那就这样：


```cpp
string tmp(s.substr(0,k));

/*
定义一个tmp，截取s的第0-第k位，复制给tmp
*/

string temp(s1.substr(k,s1.length() ));

/*
重新定义一个temp，截取s1的第k-最后一位，复制给temp
*/

s1=tmp+temp;//复合tmp和temp得到s1
```


## 所以我们可以用这个处理方法来分步操作题目的要求啦！


#### 咱们一步一步来：

### 且慢！我们注意到题目还提到了这样一点：

###### 将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数N

所以我们需要这样一步操作（其实前面题解dalao写过了）：
```cpp
inline int approximate(register int x) 
{
	if(x%3==0||x%3==1)
	{
		return x/3;
	}
	return x/3+1;
}
```

## 开始模拟吧！

定义变量：

```cpp
string s,s1,s2,s3,s4;
int len//字符串长度 
,total//操作2字母数量 
,fin//元音字母数 
,tot//操作3字母数量 
,tota//操作2动态长度 
,to//操作3动态长度
;

```
输入：
```cpp
	getline(cin,s);
    len = s.length();
    s1=s,s3=s;
    
```


操作一：将所有字母换成'.'

代码实现：
```
 	//操作1 
    for(register int i=0;i<=len;++i)								 
    {
        if((s[i]<='Z'&&s[i]>='A')||(s[i]<='z'&&s[i]>='a'))//如果是字母 
        {
            s1[i] = '.';//全改成点 
            ++total;//统计字母数量 
        }	
    } 	
    cout << s1 << endl;//输出，操作1完成 
```


操作二：从第1个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数N，将第1个提示中的前N个字母显示

代码实现：

```cpp
	//操作2 
    tot=approximate(total);//前1/3，动态变量不修改原字母数量的情况下循环 
    for(register int i=0;i<=len;++i)//从头到尾
    {
        if((s[i]<='Z'&&s[i]>='A')||(s[i]<='z'&&s[i]>='a'))//如果是字母 
        {
            tot--;	//字母数量-1 
        }
        if(tot == 0)
        {
        	tota=i+1;//标记 
        	break;
		}
    }
    string tmp(s.substr(0,tota));//定义一个tmp存储前半段（非空格元素） 
    string temp(s1.substr(tota,len));//定义temp存储后半段由s1修改来的数据（即那些点） 
    s2=tmp+temp;//复合 
    cout << s2 << endl; //输出操作2 
    s4=s2;//将s2复制到s4中为操作3做铺垫 
   
```

操作三：第3个提示：从第2个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第1个提示而来，即我们将前2/3的字母显示（同样如不能被3整除则取最接近的整数）

代码实现：

```cpp
	//操作3
    for(register int i=tota;i<=len;++i)//在操作2的基础上找元音字母 
    {
        if(s[i]=='A'||s[i]=='E'||s[i]=='I'||s[i]=='O'||s[i]=='U'||s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u')
        //找元音字母 
		{
            ++fin;//找到就+1 
        }
    }
    if(fin==0)//如果没有元音 
    {
    	tot=approximate(total*2);//前2/3,动态长度 
        for(register int i=0;i<=len;++i)//从头开始找非字母元素啊 
        {
            if((s[i]<='Z'&&s[i]>='A')||(s[i]<='z'&&s[i]>='a'))//如果是字母则-1 
            {
                tot--;	
            }    
			if(tot==0)
			{
				to=i+1;//标记 
				break;
			}     
        }
        string tmp(s.substr(0,to));//定义fuc存储前半段的元素（即到2/3的字母） 
        string temp(s1.substr(to,len));//定义func存储后半段（还是点） 
        s3=tmp+temp;//复合 
        cout << s3 << endl;
        return 0;
    }
    else//如果有元音 
    {
        for(register int i=tota;i<=len;++i)//从s2字母元素末尾开始查找 
        {
            if(s[i]=='A'||s[i]=='E'||s[i]=='I'||s[i]=='O'||s[i]=='U'||s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u')
            //如果是元音，那么存入s4 
            {
                s4[i]=s[i];
            }
            else if(s4[i]!=' ')//如果不是空格 
            {
            	s4[i]=s4[i];
			}
        }
        cout << s4;
        return 0;
    }
    return 0;
}

```

## 好啦，我们的操作完成了~

#### 给大家提供几组数据来测试下~~
```cpp
样例： 
Upomoc! Lpv s nm pkrl sv smglsnk.

......! ... . .. .... .. ........ 
Upomoc! Lp. . .. .... .. ........ 
Upomoc! Lpv s nm pkrl s. ........

样例1： 
aeio! aeiou AEIOU AEIOU znaak
输出：
....! ..... ..... ..... ..... 
aeio! aeio. ..... ..... .....
aeio! aeiou AEIOU AEIOU ..aa.

样例2：
qwrty !-;?u aeiot tcout aaazd
输出：
..... !-;?. ..... ..... .....
qwrty !-;?u a.... ..... .....
qwrty !-;.u aeio. ..ou. aaa..

样例3：
tyeur JjskD ,s;!? s.tkj sjdw!
输出：
..... ..... ,.;!? ..... ....!
tyeur J.... ,.;!? ..... ....!
tyeur JjskD ,s;!? s.t.. ....!

样例4 
aus,?  .?;- -,;:? !;,;? wps,s
输出：
...,?  .?;- -,;:? !;,;? ...,. 
au.,?  .?;- -,;:? !;,;? ...,.
aus,?  .?;- -,;:? !;,;? wp.,.

```

## 下面贴上本蒟蒻的AC代码~~

```
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <list>
#include <map>
#include <set>
#include <cstdlib>
#include <algorithm>
using namespace std;

string s,s1,s2,s3,s4;
int len,total,fin,tot,tota,to;

inline int approximate(register int x) 
{
	if(x%3==0||x%3==1)
	{
		return x/3;
	}
	return x/3+1;
}

int main()
{
    getline(cin,s);
    len = s.length();
    s1=s,s3=s;
    for(register int i=0;i<=len;++i)								 
    {
        if((s[i]<='Z'&&s[i]>='A')||(s[i]<='z'&&s[i]>='a'))
        {
            s1[i] = '.'; 
            ++total;
        }	
    } 	
    cout << s1 << endl;
    tot=approximate(total);
    for(register int i=0;i<=len;++i)
    {
        if((s[i]<='Z'&&s[i]>='A')||(s[i]<='z'&&s[i]>='a'))
        {
            tot--;
        }
        if(tot == 0)
        {
        	tota=i+1;
        	break;
		}
    }
    string tmp(s.substr(0,tota));
    string temp(s1.substr(tota,len));
    s2=tmp+temp;
    cout << s2 << endl;
    s4=s2;
    for(register int i=tota;i<=len;++i)
    {
        if(s[i]=='A'||s[i]=='E'||s[i]=='I'||s[i]=='O'||s[i]=='U'||s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u')
		{
            ++fin;
        }
    }
    if(fin==0)
    {
    	tot=approximate(total*2);
        for(register int i=0;i<=len;++i)
        {
            if((s[i]<='Z'&&s[i]>='A')||(s[i]<='z'&&s[i]>='a'))
            {
                tot--;	
            }    
			if(tot==0)
			{
				to=i+1;
				break;
			}     
        }
        string tmp(s.substr(0,to));
        string temp(s1.substr(to,len));
        s3=tmp+temp;
        cout << s3 << endl;
        return 0;
    }
    else
    {
        for(register int i=tota;i<=len;++i)
        {
            if(s[i]=='A'||s[i]=='E'||s[i]=='I'||s[i]=='O'||s[i]=='U'||s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u')
            {
                s4[i]=s[i];
            }
            else if(s4[i]!=' ')
            {
            	s4[i]=s4[i];
			}
        }
        cout << s4;
        return 0;
    }
    return 0;
}
```
[可以观看下本蒟蒻的评测记录~~跑的还行吧……](https://www.luogu.org/record/show?rid=12833291)

# 谢谢大家，有错误可以私信我哦！~~~


---

## 作者：lenaalyth (赞：2)

emmmm，一道简单的单纯的模拟题（~~然而我错了一下午。。。~~），本题只要跟着题目所给的提示写模拟就可以了。。。不过有两个个地方要注意：一个是字母数的三分之一。。。。是字母数。。是字母数。。是字母数（重要的地方说三遍），二是最接近，注意要四舍五入。。其他的就没什么了。。。放一下代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <string>
#include<cmath>
using namespace std;
int a,b,d,e,f,g,h,j,c[100000],q,t,tt;
string m,n,k,v;
int main()
{
	getline(cin,m);
	a=m.size();
	c[0]=-1;
	for(int x=0; x<a; x++)
	{
		if((m[x]>='A'&&m[x]<='Z')||(m[x]>='a'&&m[x]<='z'))
		{
			n+='.';
			q++;
		}
		else
		{
			n+=m[x];
		}
	}
	cout<<n<<endl;
	b=round(q/3.0);
	f=round((q*2)/3.0);
	for(int x=0; x<a; x++)
	{
		if((m[x]>='A'&&m[x]<='Z')||(m[x]>='a'&&m[x]<='z'))
		{
			if(t<b) 
			{k+=m[x];
			t++;
			}
			else
			{
			if(m[x]=='a'||m[x]=='e'||m[x]=='i'||m[x]=='o'||m[x]=='u'||m[x]=='A'||m[x]=='E'||m[x]=='I'||m[x]=='O'||m[x]=='U')
			{
					c[j++]=x;
			}
			k+='.';
			}
		}
		else
		k+=m[x];
		
		if((m[x]>='A'&&m[x]<='Z')||(m[x]>='a'&&m[x]<='z'))
		{
			if(tt<f) 
			{v+=m[x];
			tt++;
			}
			else
			{
			v+='.';
			}
		}
		else
		v+=m[x];
	}
	t=0;
	cout<<k<<endl;
	if(c[0]==-1)
		cout<<v<<endl;
	else
		for(int x=0; x<a; x++)
		{
			if((m[x]>='A'&&m[x]<='Z')||(m[x]>='a'&&m[x]<='z'))
		{
			if(t<b) 
			{
				cout<<m[x];
				t++;
			}
			else
			{
			if(x==c[g])
			{
				cout<<m[x];
				g++;
			}
			else
			cout<<'.';
			}
		}
		else
		cout<<m[x];
		}
	cout<<endl;

}
```

---

## 作者：战神yfy (赞：1)

## 题解 P3880 【[JLOI2008]提示问题】
这道题其实把三个提示分开来看，分别进行处理就很简单了，第一个输出加统计，第二个统计三分之一输出，第三个分类讨论，处理的过程都在代码里边了：
```cpp
#include<bits/stdc++.h>
using namespace std;
char yyt[]= {'a','e','i','o','u','A','E','I','O','U'};//元音跳转表
bool ok=false;//判断是否是元音
int main() {
	int temp=0;//字母的三分之一在整个字符串中的位置
	int t=0;//字母个数
	string a;//定义输入的字符串
	getline(cin,a);//输入一整行
	for(int i=0; i<a.size(); i++) {
		if((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z')) {//在这里，如果是字母就输出点，顺带统计个数
			cout<<'.';
			t++;
		} else cout<<a[i];//不是字母就照常输出
	}
	cout<<endl;//跳转下一行
	int l=round(1.0*t/3);//round是四舍五入取整函数，根据题意取整，l是n除以3的结果
	for(int i=0; i<a.size(); i++) {
		if((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z')) {
			if(l) {//这里如果还在前l个的范围内就输出
				if(l==1)temp=i;//截取字母的三分之一在整个字符串中的位置
				cout<<a[i];
				l--;//每次l要减少1
			} else	cout<<'.';//如果不在l内，就覆盖成点
		} else cout<<a[i];//其他照常输出
	}
	for(int i=temp+1; i<a.size(); i++) {//从temp开始扫描
		if((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z')) {//如果他是字母，就用元音跳转表进行对比
			if(a[i]==yyt[0]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[1]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[2]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[3]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[4]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[5]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[6]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[7]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[8]) {
				ok=true;
				break;
			}
			if(a[i]==yyt[9]) {
				ok=true;
				break;
			}
		}
	}
	if(ok==false) {//不是元音的情况
		cout<<endl;//换行
		int p=round(2.0*t/3);//四舍五入截取三分之二
		for(int i=0; i<a.size(); i++) {
			if((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z')) {
				if(p) {//在范围内就输出
					cout<<a[i];
					p--;
				} else	cout<<'.';//否则就覆盖成点
			} else cout<<a[i];
			//其他照常
		}
	} else {
		cout<<endl;//换行
		int s=round(1.0*t/3);//四舍五入截取三分之一
		for(int i=0; i<a.size(); i++) {
			if((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z')) {
				if(s) {//在三分之一以内照常输出
					cout<<a[i];
					s--;
				}//三分之一以外如果是元音就输出，否则就覆盖
				else if(s<1&&(a[i]==yyt[0]||a[i]==yyt[1]||a[i]==yyt[2]||a[i]==yyt[3]||a[i]==yyt[4]||a[i]==yyt[5]||a[i]==yyt[6]||a[i]==yyt[7]||a[i]==yyt[8]||a[i]==yyt[9]))	cout<<a[i];
				else cout<<'.';
			} else cout<<a[i];//其他照常
		}
	}
	return 0;//结束
}
```




---

## 作者：UnyieldingTrilobite (赞：1)

上手鉴定大膜你······最近太颓了切了好几道了。

用C++11来提供一种码量比较小的写法（给懒得在这题上耗太多时间的dalao发福利）。

好像没什么思路好说的······就按照题目做吧。

细节几乎没有。

科普几个玩意：
```
count_if(first,last,judge);
返回[first,last)区间中使得judge(i)==1的元素i的个数。
```
```
for_each(first,last,work);
对于[first,last)中每个元素i执行work(i).
```
```
lambda表达式：
[]()->{}生成匿名函数。
自行百度。
这里只用到一种:
[](char c){dosomething;}
就生成了一个匿名函数。
由于下面代码的每一个lambda表达式只有至多一个return所以可以省略->.
```
好了，就珂以愉快地切掉这题了······

感觉那年考生好幸福。

代码含注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline bool isyuanyin(char c){return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='A'||c=='E'||c=='I'||c=='O'||c=='U';}//是元音
char s[100];//字符数组
int main(){
	scanf("%[^\n]s",s);//读入一行（黑科技）
	int n=strlen(s);//长度
    int tot=count_if(s,s+n,[](char c){return isalpha(c);});//一行数字母
	for_each(s,s+n,[](char c){putchar(isalpha(c)?'.':c);});putchar('\n');//第一行提示，字母->'.'
	int hint=round(tot/3.),lstpos;//第二行提示显示字母数，最后一个字母的位置
	for(int i=0;i<n;++i){
		if(isalpha(s[i])){
			if(hint){
				--hint;
				putchar(s[i]);
				lstpos=i;
			}else putchar('.');
		}else putchar(s[i]);
	}putchar('\n');//第二行输出1/3的字符
	if(!count_if(s+lstpos+1,s+n,isyuanyin)){//如果剩下部分没有元音了
		hint=round(tot*2/3.);
		for(int i=0;i<n;++i){
			if(isalpha(s[i])){
				if(hint){
					--hint;
					putchar(s[i]);
				}else putchar('.');
			}else putchar(s[i]);
		}putchar('\n');	//同上，输出2/3的字符
	}else{//否则
		hint=round(tot/3.);
		for(int i=0;i<=lstpos;++i){
			if(isalpha(s[i])){
				if(hint){
					--hint;
					putchar(s[i]);
				}else putchar('.');
			}else putchar(s[i]);
		}//先把第二行输出的字母部分copy一遍
		for_each(s+lstpos+1,s+n,[](char c){putchar((isalpha(c)&&!isyuanyin(c))?'.':c);});//剩下部分显示元音
	}
	return 0;
}
```
Over.

最后~~不要脸的~~宣传[blog](https://www.luogu.com.cn/blog/2007100723874wxz/)和[~~英文~~编程语言](https://www.luogu.com.cn/blog/2007100723874wxz/define)。

祝大家切题愉快！

---

## 作者：Angel_s_Shadow (赞：1)

这题又是一道“大水题”

题目上标着高性能那我就细心做了……结果还是很水啊

其实就是模拟咯~

我不像大佬们那么强，只用了一个字符串

我用了4个字符串来处理这个东西

也就是原题目的字符串加上剩下的字符串

下面附上满分答案~

请不要复制题解哦
```cpp
#include <iostream>
using namespace std;
string str,str1,str2,str3;
int letter=0,nowIndex=0;//字母的数量，每个字母的下标
int yuan[55],yuanIndex=0;//初始化
bool isLetter(char a){//是否是字母
    return (a>='a'&&a<='z')||(a>='A'&&a<='Z');
}
bool isyuan(char a){//元音字母
    return (a=='a'||a=='A'||a=='e'||a=='E'||a=='i'||a=='I'||a=='o'||a=='O'||a=='u'||a=='U');
}
int round(float a){//四舍五入
    if(a-(int)a>=0.5){
        return (int)a+1;
    }else{
        return (int)a;
    }
}
void getStr(){
    yuan[0]=-1;//判断是否有元音存入的初始值，后面会用到
    char a;
    while((a=cin.get())!='\0'&&a!='\n'){
        str+=a;
        if(isLetter(a)){
            str1+='.';//初始化字符串
            str2+='.';
            str3+='.';
            letter++;
            if(isyuan(a)){
                yuan[yuanIndex++]=nowIndex;//如果是元音字母就把下标记录上
            }
        }else{
            str1+=a;//记录上其他符号
            str2+=a;
            str3+=a;
        }
        nowIndex++;
    }
    int len = nowIndex;//字符串长度  不要用.length()！！！会费时间了
    int letter_ = round(((float)letter)/3);//处理第二个提示
    for(int i=0;i<len;++i){
        if(!letter_){
            break;
        }
        if(isLetter(str[i])){
            letter_--;
            str2[i] = str[i];
        }
    }
    bool changes = false;//默认没有发生改变
    if(yuan[0]!=-1){
        str3=str2;
        for(int i=0;i<yuanIndex;++i){
            if(str3[yuan[i]]!=str[yuan[i]]){
                str3[yuan[i]]=str[yuan[i]];
                changes=true;//发生了改变
            }
        }
    }
    if(!changes){//没发生改变显示2/3字母
        int letter_ = round(((float)letter)/3*2);
        for(int i=0;i<len;++i){
            if(!letter_){
                break;
            }
            if(isLetter(str[i])){
                letter_--;
                str3[i] = str[i];
            }
        }
    }
}
void test(){//输出
cout <<str1<<endl<<str2<<endl<<str3;
}
int main()
{
    getStr();
    test();
    return 0;
}

```
以后也要加油呢


---

## 作者：happybob (赞：0)

这个题目的难度似乎有点难啊！！！

提示1很简单，只需要把字母转为.，空格以及其他字符还是其他字符

提示2的难度稍稍增加，但也难不过我们！我们先找到三分之一，四舍五入用round

提示3是最坑人的，难啊！先要在提示2记录下来三分之一的最后一个字符所在的下标，提示3从下表这里开始往后找元音，找得到那就先把三分之一以内输出，再把后面的元音输出，不然就是三分之二以内输出！

代码，20ms，跑的飞快：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

string s;

double cnt = 0;
int pos, xpos;

void one(string s)
{
    for(string::iterator it = s.begin(); it != s.end(); ++it)
    {
        if(*it == ' ')
        {
            printf(" ");
        }
        else if(isalpha(*it))
        {
            printf(".");
            cnt++;
        }
        else
        {
            printf("%c", *it);
        }
    }
    puts("");
}

void two(string s)
{
    pos = round(cnt / 3);
    int len = s.length() - 1;
    int count = 0;
    for(int i = 0; i <= len; i++)
    {
        if(isalpha(s[i]))
        {
            count++;
            if(count == pos + 1)
            {
                xpos = i;
            }
            if(count <= pos)
            {
                printf("%c", s[i]);
            }
            else
            {
                printf(".");
            }
        }
        else
        {
            printf("%c", s[i]);
        }
    }
    puts("");
}

void three(string x)
{
    int len = x.length() - 1, count = 0;
    string s = x;
    transform(s.begin(), s.end(), s.begin(), ::toupper);//全部转为大写
    bool flag = false;
    for(int i = xpos + 1; i <= len; i++)
    {
        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
        {
            flag = true;
            break;
        }
    }
    if(flag)
    {
        int f = 0;
        for(int i = 0; i <= len; i++)
        {
            if(count == pos && isalpha(x[i]))
            {
                f = i;
                break;
            }
            else if(isalpha(x[i]))
            {
                count++;
                if(count <= pos)
                {
                    printf("%c", x[i]);
                }
                else
                {
                    printf(".");
                }
            }
            else
            {
                printf("%c", x[i]);
            }
        }
        for(int i = f; i <= len; i++)
        {
            if(x[i] == 'a' || x[i] == 'e' || x[i] == 'i' || x[i] == 'o' || x[i] == 'u' || x[i] == 'A' || x[i] == 'E' || x[i] == 'I' || x[i] == 'O' || x[i] == 'U')
            {
                printf("%c", x[i]);
            }
            else
            {
                if(isalpha(x[i]))
                {
                    printf(".");
                }
                else
                {
                    printf("%c", x[i]);
                }
            }
        }
    }
    else
    {
        int spos = round(cnt / 1.5), cnts = 0;//除以1.5就是三分之二
        for(int i = 0; i <= len; i++)
        {
            if(isalpha(x[i]))
            {
                cnts++;
                if(cnts <= spos)
                {
                    printf("%c", x[i]);
                }
                else
                {
                    printf(".");
                }
            }
            else
            {
                printf("%c", x[i]);
            }
        }
    }
}

int main()
{
	getline(cin, s);
	one(s);
	two(s);
        three(s);
	return 0;
}
```

加上内存排名第一哦！

---

## 作者：Eason_AC (赞：0)

## Content
由于题目要求是在太过复杂，请见原[题面](https://www.luogu.com.cn/problem/P3880)查看。
## Solution
这题明显是一个大模拟，那么废话少说，我们开始吧。

首先就是要找到所有的字母，比如说样例，其中底下加了``^`` 号的就是所有字母的位置：

```
Upomoc! Lpv s nm pkrl sv smglsnk.
^^^^^^  ^^^ ^ ^^ ^^^^ ^^ ^^^^^^^
```

把它们的位置存下来，然后就可以输出第一个提示了——直接将所有字母替换成 ``.`` 即可。

自然而然地，字母出现的次数 $cnt$ 也可以模拟得出来了。然后，我们就可以求出来前 $\dfrac{1}{3}$ 和前 $\dfrac{2}{3}$ 的字母的位置了。

然后，我们先从 $\dfrac{1}{3}$ 的字母出现的位置开始找起，一直到字符串末尾，如果有元音，那么第三个提示就只输出 $\dfrac{1}{3}$ 的字母的位置之前的所有字符以及之后的所有元音字母，否则输出 $\dfrac{2}{3}$ 的字母的位置之前所有的字符。

至于第二个提示就不用再说了吧，直接输出 $\dfrac{1}{3}$ 的字母的位置之前所有的字符即可。

那么这道题目就算做完了，作为省选题算是很水的（毕竟这是 10 多年以前了）。
## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

string s;
int pk[57];
map<int, int> pk2;

int main() {
	getline(cin, s);
	int len = s.size();
	for(int i = 0; i < len; ++i)
		if((s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= 'a' && s[i] <= 'z')) {
			pk[++pk[0]] = i;	//将字母出现的位置记录下来
			pk2[i] = pk[0];
			printf(".");
		} else	printf("%c", s[i]);
	puts("");
	int key1 = floor(pk[0] / 3.0 + 0.5), key2 = floor((pk[0] * 2) / 3.0 + 0.5), vowel = 0;
//	printf("%d %d\n", key1, key2);
	for(int i = 0; i < len; ++i)
		if(pk2[i] >= 1 && pk2[i] <= key1)	printf("%c", s[i]);
		else if(pk2[i])	printf(".");
		else printf("%c", s[i]);
	puts("");
	for(int i = pk[key1] + 1; i < len; ++i)
		if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
			vowel = 1;
			break;
		}
	if(vowel) {
		for(int i = 0; i < len; ++i)
			if(pk2[i] >= 1 && pk2[i] <= key1)	printf("%c", s[i]);
			else if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')	printf("%c", s[i]);
			else if(pk2[i])	printf(".");
			else	printf("%c", s[i]);
	} else {
		for(int i = 0; i < len; ++i)
			if(pk2[i] >= 1 && pk2[i] <= key2)	printf("%c", s[i]);
			else if(pk2[i])	printf(".");
			else	printf("%c", s[i]);
	}
}
```

---

## 作者：蒟蒻lxy (赞：0)

## 被难题虐飞了，来刷一道“水”题
### 结果打了50分钟。。。


------------


### 思路：```按题意模拟```
	其实思路都在注释上
    

------------


坑点：

	1.第2、3的提示指的是字母数的1/3(2/3)而不是字符串长度的1/3(2/3);
    
	2.1/3和2/3要四舍五入;
    

------------
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a//字符串
int la,ans//a的长度、字母数
int main()
{
	getline(cin,a);//整行读入string
	la=a.size();//算出长度
	for(int i=0;i<la;i++)
		if(a[i]>='a' && a[i]<='z' || a[i]>='A' && a[i]<='Z')//如果是字母
			cout <<'.',ans++;//输出'.'、字母数++
		else
			cout << a[i]://输出符号
	cout << endl;
	//第一部分结束
	int n=(ans*1.0/3)+0.5,n2=(ans*2.0/3)+0.5,nnn=0,minn=0x3f3f3f3f;
	//分别是：n:第一次提示输出的字母数,n2:第二次提示输出的字母数
    //       nnn:记录输出字母数,minn:记录第一个不提示的字母位置
    //       +0.5即为四舍五入
    //
    //这个for循环输出1/3的字母，剩下为'.'
	for(int i=0;i<la;i++)
		if(a[i]>='a' && a[i]<='z' || a[i]>='A' && a[i]<='Z')//如果是字母
		{
			if(nnn>=n)//如果不能再提示了
				cout <<'.',minn=min(minn,i);//输出不提示的字母、记录第一个不提示的字母位置
			else
				cout << a[i],nnn++;//又输出了一个字母
		}
		else
			cout << a[i];//输出符号
	cout << endl;
	//第二部分结束
	nnn=0;//记录是否有元音字母
	for(int i=minn;i<la;i++)//从第一个不提示的字母开始遍历
		if(a[i]=='A' || a[i]=='E' || a[i]=='I' || a[i]=='O' || a[i]=='U' || a[i]=='a' || a[i]=='e' || a[i]=='i' || a[i]=='o' || a[i]=='u')//寻找元音字母
			nnn=1;
	if(!nnn)//如果没有元音字母就输出2/3的字母
	{
		for(int i=0;i<la;i++)
			if(a[i]>='a' && a[i]<='z' || a[i]>='A' && a[i]<='Z')//如果是字母
			{
				if(nnn>=n2)//如果不能再提示了
					cout <<'.';//输出不提示的字母
				else
					cout << a[i],nnn++;//又输出了一个字母
			}
			else
				cout << a[i];//输出符号
	}
	else//这里要提示元音字母
	{
		nnn=0;//同上
		for(int i=0;i<la;i++)
			if(a[i]>='a' && a[i]<='z' || a[i]>='A' && a[i]<='Z')//如果是字母
			{
				if(nnn>=n)//如果第一个提示输出完了
				{
					if(a[i]=='A' || a[i]=='E' || a[i]=='I' || a[i]=='O' || a[i]=='U' || a[i]=='a' || a[i]=='e' || a[i]=='i' || a[i]=='o' || a[i]=='u')//判断是否是元音字母
						cout << a[i];//输出元音字母
					else
						cout << '.';//不提示
				}
				else
					cout << a[i],nnn++;//又输出了一个字母
			}
			else
				cout << a[i];//输出符号
	}
	cout << endl;
	return 0;
}
```
------------
~~大模拟题~~

---

## 作者：Cantredo (赞：0)

题意很好理解，但这道题实在太考细节了...  
随便乱打的一个测试样例竟然帮我找到第八组测试样例过不去的原因？？hhhh...  
有个小地方忘写了导致第十组样例一直WA...   
为各位dalao献上蒟蒻的代码，详情请看注释。  
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <map>
#include <cmath>
#include <queue>
#include <cmath>
#include <ctype.h>
#define ll long long

using namespace std ;

string str1 ;   //输入的原始串
string str2 ;   //根据第1个提示之后的串
string str3 ;   //将第2个提示之后的串复制到str3中
//string str4 ; str4 ？ 并没有 str4，由str3或str2与str1可直接得出最后一个提示的串
int tot_alpha ;     //统计总共的字母数字
bool check = false ;        //检查第3个提示中是否有可显示的元音字母
int indexx ;        //找到第2个提示第N个字母的位置

int closest(double a , double b , double c){    //在第二个提示中比较谁更接近，也可如上面几位dalao的round函数
    if ( fabs(c - a) > fabs(c - b) ){       //比较浮点数绝对值，谁小谁更接近
        return b ;
    }
    return a ;
}

void display_one(){         //提示1，直接处理字符串
    str2 = str1 ;
    for ( int i = 0 ; i < str1.size() ; i ++ ){
        if ( isalpha(str2[i]) ){
            str2[i] = '.' ;
            tot_alpha ++ ;
        }
    }
    cout << str2 << endl ;
    return ;
}

void display_two(){         //提示2，由str1和str2组合而成
    double number = tot_alpha / 3.0 ;
    /*天花板ceil(element) 和 地板函数floor(element) (雾
    ceil()向上取整，返回不小于element的最大的整数，
    floor()向下取整，返回不大于element的最小的整数
    */
    int num = closest(ceil(number) , floor(number) , number) ;      //找到离商最接近的自然数N
    int count_ = 0 ;        //记录到目前出现的字母个数
    for ( int i = 0 ; i < str1.size() ; i ++ ){
        str3[i] = str1[i] ;         //将串复制到str3，便于第三个提示的处理 *ps：之前觉得这个str3会用到，但写到后面发现没什么用...于是一直WA第十组样例的噩梦开始了...
        /*纪念找到这个BUG的此组胡乱敲打的样例....
            input:  asd132asd123zxc
            output: ...132...123...
            output: asd132...123...
            output: as.132a..123...    正确输出->  output: asd132a..123...
          所以有了之后的 “用不着str3” 的疯狂打脸...
        */
        if ( isalpha(str1[i]) ){        //ctype.h 头文件判断字符是否是字母函数
            cout << str1[i] ;           //输出原串str1中的对应字符
            count_ ++ ;                 //若真字母个数+1 
        }else {
            cout << str1[i] ;           //输出原串str1中的对应字符
        }
        if ( count_ == num ) {      //当字母个数等于N时，记录下标，并跳出
            indexx = i ;            //记录第N个字母的位置
            break ;
        }
    }
    for ( int i = indexx + 1 ; i < str1.size() ; i ++ ){        //输出str2之后的串
        str3[i] = str2[i] ;
        cout << str2[i] ;
    }
    cout << endl ;
    return ;
}

void display_thr(){
    /*str3 = str1 ;   
    此处若加上这语句会出现一个未知的错误..
    如果有dalao知道为什么请告诉我，感激不尽！
    */
    for ( int i = indexx + 1 ; i < str1.size() ; i ++ ){
        /*
        cytpe.h头文件 tolower() 函数将一个字母转换成小写字母，与之对应的是 toupper() 
        此处统一转成小写字母，便于处理大写元音字母与小写元音字母
        */
        if ( tolower(str1[i]) == 'a' || tolower(str1[i]) == 'e' || tolower(str1[i]) == 'i' || tolower(str1[i]) == 'o' || tolower(str1[i]) == 'u' ){
            check = true ;      //说明有可显示的元音字母
        }
    }
    if ( check ){   //若真，则由原串str1和str3组合生成答案
        for ( int i = 0 ; i < indexx ; i ++ ){      //输出到第N个字母的位置
            cout << str1[i] ;
        }
        for ( int i = indexx ; i < str1.size() ; i ++ ){    
            /*输出第N个字母之后的字符，并判断是否有元音字母，
            若有则输出str1中的字母，若无则输出str3中的字符
            */
            if ( tolower(str1[i]) == 'a' || tolower(str1[i]) == 'e' || tolower(str1[i]) == 'i' || tolower(str1[i]) == 'o' || tolower(str1[i]) == 'u' ){
                cout << str1[i] ;
            }else{
                cout << str3[i] ;
            }
        }
    }else{  //若非真，则由原串str1与str2组合生成答案
        double number = tot_alpha / 3.0 * 2.0 ;
        int count_ = 0 ;
        int num = closest(ceil(number) , floor(number) , number) ;
        for ( int i = 0 ; i < str1.size() ; i ++ ){
            if ( count_ < num ){            //显示前2/3个字母
                if ( isalpha(str1[i]) ){
                    cout << str1[i] ;
                    count_ ++ ;
                }else{
                    cout << str1[i] ;
                }
            }
            else{       //若字母个数等于num则输出str2之后的串
                cout << str2[i] ;
            }
        }
    }
    return ;
}

int main(){
    getline(cin , str1) ;
    str3 = str1 ;           //若不加上此句在 codeblocks 下会返回非零...如果有dalao知道是什么原因请告诉我，感激不尽！
    display_one() ;
    display_two() ;
    display_thr() ;
    return 0 ;
}

```

---

## 作者：良月澪二 (赞：0)

模拟挺简单的吧~（虽然坑了我断断续续一下午）

在此之前，要先了解一下 $round$ 这个函数，都知道 $ceil$ 和 $floor$，就是类似于前面俩，可以四舍五入，在这个题中要除到$3.0$

字符串的题就不要用$scanf$ $printf$了，有$string$的话输入输出会比较难受，$cin$ $cout$多好阿，

会各种字符串的输入输出和函数就很好做了

简单易懂

```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<complex>
#define R register
#define A 51
#pragma GCC optimize(2)

using namespace std;
string s,s1;
int cnt;
bool ok,mark[A];

int main()
{
	getline(cin,s); //读空格
	int len=s.length();
	for(R int i=0;i<len;i++)
	  if(isalpha(s[i])) //isalpha()判断是否是字母
	    cout<<".",cnt++;
	  else cout<<s[i];
	puts(""); //用来输回车
	int n=round(cnt/3.0);
	for(R int i=0;i<len;i++)
	  if(isalpha(s[i]) and n!=0)
	    n--,cout<<s[i],s1+=s[i]; //作为string直接加
	  else if(isalpha(s[i]))
	    cout<<".",s1+='.',mark[i]=1;
	  else cout<<s[i],s1+=s[i],mark[i]=1;
	puts("");
	for(R int i=0;i<len;i++)
	  if((s[i]=='a' or s[i]=='A' or s[i]=='e' or s[i]=='E' or s[i]=='i' or s[i]=='I' or s[i]=='o' or s[i]=='O' or s[i]=='u' or s[i]=='U') and mark[i])
	    ok=1;
	if(ok==0)
	{
		int m=cnt-round(cnt/3.0);
		for(R int i=0;i<len;i++)
		{
			if(m and isalpha(s[i]))
			  cout<<s[i],m--;
			else cout<<s1[i];
		}
	}
	else
	{
		for(R int i=0;i<len;i++)
		  if((s[i]=='a' or s[i]=='A' or s[i]=='e' or s[i]=='E' or s[i]=='i' or s[i]=='I' or s[i]=='o' or s[i]=='O' or s[i]=='u' or s[i]=='U') and mark[i])
			cout<<s[i];
		  else cout<<s1[i];
	}
}
```

---


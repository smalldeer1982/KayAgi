# [RC-02] 求和

## 题目描述

小 Q 给你了几行字符串，字符串中间包含有一些整数，整数之间可能会有其他字符。你需要输出每行中所有整数的和。如果一个行里面一个数都没有则不要输出。**每两个整数之间一定有间隔字符（见样例 $3$）。**

请注意，题目中的整数都是简单的整数，即：整数前面没有多余的符号。假如数据中有 `.`，视作分隔符。

## 说明/提示

【样例解释】

- 第一个样例中，第一行有 $57,54,-321,8$ 几个数，和为 $-202$；第二、三行没有数字；第四行只有一个 $4$，输出 $4$。
- 第二个样例中只有一行，有两个数，和为 $4532893$。
- 第三个样例的第一行，由于每两个整数之间一定有间隔字符，所以把 `-` 视为间隔字符，输出 $2$。第五行，第一个数为 $-1$，因此把第二个 `-` 视为间隔字符，和为 $-1+1=0$。第七行，将 `.` 视为间隔字符，和为 $-2+3=1$。

【数据范围】

说明：「条件 A」指数据中不存在除数字、空格、换行、水平制表符之外的其他字符；「条件 B」指每两个数之间一定用且只用一个空格隔开。

**由于数据在 Windows 下制造，行末可能有多余的 `\r` 字符。请注意。**

对于 $10\%$ 的数据，满足条件 A 和 B，每行一定有且仅有 $10$ 个数；

对于 $40\%$ 的数据，满足条件 A 和 B，且不存在空行；

对于 $50\%$ 的数据，满足条件 A 和 B；

对于 $70\%$ 的数据，满足条件 A；

对于 $100\%$ 的数据，不存在除水平制表符、空格、换行外的不可见字符，每行不超过 $1000$ 个字符，每行最多包含 $200$ 个整数，不超过 $100$ 行，每个整数均 $\in[-10^7,10^7]$。

## 样例 #1

### 输入

```
su57jdkjth54hjsns-321d 8 ejre
erg(&-^%

weruy4uhnd-```

### 输出

```
-202
4```

## 样例 #2

### 输入

```
          4532984       d    -1```

### 输出

```
4532983```

## 样例 #3

### 输入

```
1-1
1 -1
1--5
1-----------1
-1-1
--1
-2.3```

### 输出

```
2
0
-4
0
0
-1
1```

# 题解

## 作者：Pethly_Cat (赞：54)

一道基本的字符串练习题。

我们把整个字符串遍历一遍，看到数字就保存到变量$sum$中。如果前面的位置是数字，而本位不是，那就跳过，再把前面得到的数加起来，$sum$清零。

另外，再用一个$bool$变量来判断字符串里有没有数字，如果有则不输出。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,sum;
bool flag,f;
int main()
{
    while(getline(cin,s)){
    	n=sum=0;
    	flag=false;
    	f=false;
    	for(int i=0;i<s.size();i++){
    		if(s[i]>='0'&&s[i]<='9') f=true;//判断字符串有没有数字
    		if(s[i-1]>='0'&&s[i-1]<='9'&&(s[i]<'0'||s[i]>'9')) continue;//数字在前面且该字符不是数字，跳过字符
    		if(s[i]=='-'&&s[i+1]>='0'&&s[i+1]<='9') flag=true;//判断是否为负数
    		if(s[i]>='0'&&s[i]<='9'){//如果为数字，保存到计数器里
    			n=n*10+(s[i]-'0');
    			if(s[i+1]<'0'||s[i+1]>'9'){
    				if(flag==true) n=-n,flag=false;
    				sum+=n,n=0;
				}
			}
		}
		if(f==true) cout<<sum<<endl;
	}
    return 0;
}
```

只求二字：

### 过和赞

---

## 作者：是非交融 (赞：5)

### **本题大意**
##### 在每一行字符串中寻找数字。
------------
------------
### **具体思路**

##### 一个一个字符地寻找，如果是数字就计算到总和里。
------------
#### **要点 ~~（本蒟蒻靠WA摸索出来的）~~**
##### 1.如果该行没有数字就不输出
##### 2.这里面有负数
##### 3.如果负数两边都是数字，那么该符号将视为无法影响数字的符号
------------
#### **主要代码如下**
```cpp
for(int i=0;i<n;i++)
{
	if(c[i]>='0'&&c[i]<='9') //要点一
	 l=1;//标记该行有数字
	int k=0,j=i;
	while(c[i]>='0'&&c[i]<='9') //累加
	 k=k*10+c[i++]-'0';
	if(j>1&&c[j-2]>='0'&&c[j-2]<='9') //要点三。
	 ans+=k;
	else			
	 if(j>0&&c[j-1]=='-') //要点二
	  ans-=k;
	 else
	  ans+=k;
}
```
------------
------------
### **奉上AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[10000];
int main()
{
	ios::sync_with_stdio(false);
	string s;
	while(gets(c))
	{
		bool l=0;
		long long n=strlen(c),ans=0;
		for(int i=0;i<n;i++)
		{
			if(c[i]>='0'&&c[i]<='9')
			 l=1;
			int k=0,j=i;
			while(c[i]>='0'&&c[i]<='9')
			 k=k*10+c[i++]-'0';
			if(j>1&&c[j-2]>='0'&&c[j-2]<='9')
			 ans+=k;
			else			
			 if(j>0&&c[j-1]=='-')
			  ans-=k;
			 else
			  ans+=k;
		}
		if(l!=0)
		 cout<<ans<<endl;
	}
}


```



---

## 作者：封禁用户 (赞：4)

其实这题不是很难（考细节），我想不明白为什么是黄题。

**进入正题**

#### 我来盘点一下该题的坑：

1. 有负数。
2. 如果没有数就不输出。
3. 如果两个整数之间隔着的是负号，则把负号是为分隔符。

#### 做法（对应着上面）：

1. 找到整数后判断前一个字符是否是负号。
2. 定义一个变量，找到数后就标记，输出时判断。
3. 判断整数前一个字符是否是负号，如果成立，再判断负号前一个字符是否为整数。




**$ Code:$**

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main()
{
	while(getline(cin,s))//不停输入
	{
		int ans=0;//用来加字符串中的整数。
		bool m=false;//用来看该字符串中有没有整数，true为有，false为没有。
		for(int i=0;i<s.size();i++)//从头开始找数字
		{
			if(s[i]>='0' && s[i]<='9')//找到了
			{
				int j=i,sum=0;//j计算该整数的和
				while(s[j]>='0' && s[j]<='9')//一直找下去，直至不是整数为止
					sum=sum*10+(s[j]-'0'),j++;//求值
				if(s[i-1]=='-' && (s[i-2]<'0' || s[i-2]>'9'))ans-=sum;//假如该数是负数，且负号前一个不是整数，就减掉sum，如果是数字，就会把负号视为分隔符，ans就得加sum。
				else ans+=sum;//否则，就加上sum。
				i=j,m=true;//i变成j，说明已经找过该整数了；m标记为true，说明该字符串中有整数。
			}
		}
		if(m==true)cout<<ans<<endl;//输出。
	}
    return 0;
}
```

**无注释版：**

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main()
{
	while(getline(cin,s))
	{
		int ans=0;
		bool m=false;
		for(int i=0;i<s.size();i++) 
		{
			if(s[i]>='0' && s[i]<='9')
			{
				int j=i,sum=0;
				while(s[j]>='0' && s[j]<='9')
					sum=sum*10+(s[j]-'0'),j++;
				if(s[i-1]=='-' && (s[i-2]<'0' || s[i-2]>'9'))ans-=sum;
				else ans+=sum;
				i=j,m=true;
			}
		}
		if(m==true)cout<<ans<<endl;
	}
    return 0;
}
```


---

## 作者：infinities (赞：3)

一道字符串模拟的题，其实不难，主要是有一些细节一定要注意：

首先，题目说是整数加和，那么小数点可以当作普通字符来看待。

其次，题目说整数间肯定有间隔，那么当我们判断一个数的正负时就要考虑负号以及上一个数字的位置，如果上一个数字的末尾与这个数字的开头不仅隔了“-”，那么就可以判断是负数。

最后，记得要整行读入，变量如果是全局变量记得输入每一行后重新赋值。

code:

```cpp
#include<bits/stdc++.h>

using namespace std;

string s;

int ans,num,flag,fl,op;

signed main(){
    while(getline(cin,s)){//这里因为luogu不支持gets，所以用了getline，不会的可以去百度一下
        ans=0,num=0,flag=-10,fl=1,op=0;
        for(int i=0;i<s.length();i++){
            if(s[i]<='9'&&s[i]>='0')op=1;//因为没有数字不必输出，所以这里进行是否输出的判断
            
            if(s[i]<='9'&&s[i]>='0'&&i>0){
                if(s[i-1]=='-'&&flag<i-2){
                    fl=-1;//关于数的正负性的判断
                }
            }
            
            while(s[i]<='9'&&s[i]>='0'&&i<s.length()){num=num*10+s[i]-'0',i++,flag=i-1;}//计算数字，不多说
            
            ans+=num*fl;//将正负号带上

            num=0,fl=1;//防止对下一个数产生影响
        }
        
        if(op)cout<<ans+num*fl<<"\n";//如果可以输出，那么就输出
    }
}
```


---

## 作者：200610311a (赞：2)

其实这一题并不算难，只是细节太多。想得部分分比较容易

但是本蒟蒻是不会满足于部分分的！（强我所难

经过不懈的努力，本蒟蒻终于AC了！（后来发现刻意得部分分还真不容易（即使我不容易地得了部分分

### 进入正题

仔细地看，出题人其实比较仁慈，没有小数、分数。难点在于如何判断‘—’是负号还是间隔符。再读题，发现“每两个整数之间一定有间隔字符”这句话。也就是说，如果‘—'两边都是数字，它就是分隔符。剩下的就没有什么难点了（如果还想练手，推荐[P1619 解一元二次方程的烦恼](https://www.luogu.com.cn/problem/P1619)

以下是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	char z[10000];
	while(gets(z)){
		int a[10000]={0},s=0,ans=0,p=0,l=0;//利用数组存数字
		bool x=0;//判断是否有数字
		for(int i=0;i<strlen(z);i++){
			if(z[i]>='0'&&z[i]<='9'){
				p=1;x=1;
				if(z[i-1]=='-')l=1;
				a[s]*=10;a[s]+=z[i]-'0';
			}
			else {
				if(p){
					if(z[i]=='-'&&z[i+1]<='9'&&z[i+1]>=0)z[i]='o';
                    //如果前后都是数字，‘—’为分隔符
					if(l)
                    //判断是否为负数
                    a[s]-=2*a[s];
				s++;p=0;l=0;
				}
			}
		}
		if(p){s++;if(l)a[s-1]-=2*a[s-1];
        //循环结束后再判断一次，以免遗漏
		}
		for(int i=0;i<s;i++)ans+=a[i];
		if(x!=0)//有数字就输出
		printf("%d\n",ans);
	}
	return 0;
} 
```


---

## 作者：Eason_AC (赞：1)

## Update
不好意思！上一版本贴错了代码，已自行订正！

## Content
输入一行字符串$s$，提取出$s$中的所有数字（如果负号前后都有数字的话不算做负号而是间隔符）并输出它们的和。

数据范围：设第$i$行字符串中数字个数为$cnt_i$，每个数字为$num_{i,j}(j\in[1,cnt_i])$。则$|s|\leqslant1000,cnt_i\leqslant200,|num_{i,j}|\leqslant10^7,1\leqslant i\leqslant100$。

## Solution
字符串模拟题。

废话不说，我们来理一下思路：

首先，读入一行字符串。这里建议用$\texttt{gets}$读入一个字符数组（$\texttt{char}$类型）。  
然后从第一个字符的下标开始，在线寻找是否有数字和负号。这时坑点就来了。

**坑点1：如果负号前后都有数字，不算做后面数字的负号而是一个没用的间隔符。**

判断完之后就开始记录数字了。这里和快读有些类似，设$x=0,f=1$，其中$x$就是记录数字的，$f$就是判断正负的，这个大家应该都清楚。如果数字前面是负号（前提是判断完后是非间隔符），那么一开始$f$就是$-1$。然后往后推数字，并计入$x$中。最后总和直接加上$x\times y$就可以了。

这时又有坑点出现了：

**坑点2：如果没有数字，什么都不要输出。**

以下的代码中用的是一个$\texttt{num}$数组存储数字，并用$\texttt{cnt}$这个变量来记录数字个数。所以，如果是这样的话，那么字符串里没有数字，自然就意味着$\texttt{cnt}$这个变量等于0，就不用输出了，否则输出总和。

细节有点多，细细琢磨。

## Code
```cpp
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <iostream>
using namespace std;

char a[1007];

int main() {
	while(gets(a)) {
		int num[207] = {0}, sum = 0, n = strlen(a), cur = 0, cnt = 0;
		while(cur < n) {
//			printf("%c ", a[cur]);
			if((a[cur] >= '0' && a[cur] <= '9') || (a[cur] == '-' && (a[cur + 1] >= '0' && a[cur + 1] <= '9') && (a[cur - 1] < '0' || a[cur - 1] > '9'))) {
				int x = 0, f = 1;
				if(a[cur] == '-') {f = -1; cur++;}
				while(a[cur] >= '0' && a[cur] <= '9') {
					x = x * 10 + (a[cur] - '0');
					cur++;
//					printf("%d\n", x);
				}
				num[++cnt] = x * f;
//				printf("%d %d\n\n", num[cnt], cnt); 
			}
			else	cur++;
		}
		if(!cnt)	continue;
		for(int i = 1; i <= cnt; ++i)
			sum += num[i];
		printf("%d\n", sum);
	}
	return 0;
}
```

---

## 作者：__hacker__ (赞：1)

#### 这道题WA最可能原因是负号的处理，-1-1，1-1这类测试是必要的。
```
#include <bits/stdc++.h>
using namespace std;
char ch[100000];
int main(){
    int k,tot,ret,temp;//用ret来控制正负，tot来累加。
    bool flag;//判断有没有出现数字，没有数字则不输出。
    while(cin.getline(ch,100000)){//不需要getchar()
        flag=false;k=tot=0;ret=1;
        for(int i=0;ch[i]!='\0';i++){
            if(isdigit(ch[i])){
                k*=10;
                k+=ch[i]-'0';//每一个数字用k暂时存储。
                flag=true;
            }
            else if(ch[i]=='-'&&isdigit(ch[i+1])) {
                if(i!=0&&isdigit(ch[i-1])){
                tot+=k*ret;
                k=0;
                ret=1;
                }
                else ret=-1;
            }
            else{
                tot+=k*ret;
                k=0;
                ret=1;
            }
            temp=i;
        }//最后一位如果是数字会遗失。
        if(isdigit(ch[temp])) tot+=k*ret;
        if(flag)
        cout<<tot<<endl;
    }
    //system("pause");
    return 0;
}
```


---


# [COCI 2009/2010 #2] RIMSKI

## 题目背景

本题为[$\texttt{COCI 2009-2010}\ 2^\texttt{nd}\ \texttt{round}\ \text{T2 RIMSKI}$](https://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)。

分值按原题设置，满分 $50$。

## 题目描述

给定一个罗马数字 $B$，把 $B$ 的字符重新排列，要求让排列后的数字最小。

## 说明/提示

$1\leq B< 100$。

注意，在本题中`I`如果在大数字之前，它只能在`V` 、`X`之前。输入遵循同样的规则。（这就是样例 $4$ 的输出为什么是 `LI` 而不是 `IL`。）

## 样例 #1

### 输入

```
VIII```

### 输出

```
VIII```

## 样例 #2

### 输入

```
VI```

### 输出

```
IV```

## 样例 #3

### 输入

```
III```

### 输出

```
III```

## 样例 #4

### 输入

```
LI```

### 输出

```
LI```

# 题解

## 作者：aaaaaawsl (赞：7)

## **无智商解法**
没有高级的算法，没有奇异的思路，枚举才是王道。  
本题需要将每一种罗马数字的字符重新排列，输出排列后最小的数字。  
注意数据范围 $1≤B<100$ 。  
~~枚举 100 个数还在我的承受范围内。~~

然而把 1 至 100 的数全部枚举一遍显然不是我的风格。  
观察罗马数字，可以发现除了 40 至 49 ，其他数字中的‘ L ’字符一定在开头。  
那么可以将开头的‘ L ’提取出来，剩下的字符按照正常方式判断，在最后将‘ L ’补进去。  
以上操作可以使用 string 自带的 substr 操作来执行。

但是以‘ L ’字符开头的罗马数字中还有一部分需要特殊判断。  
例如：罗马数字 _LXI_ 就可以将‘ X ’字符放在前面，排列成 _XLI_ 。  
因此需要对这部分内容特殊判断。

枚举最重要的部分就是代码，上代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
string opt(string s){
	string ss;
	if(s[0]=='L'){
		if(s=="LXI"||s=="LIX") return "XLI";
		if(s=="LXII"||s=="LIXI") return "XLII";
		if(s=="LXIII") return "XLIII";
		if(s=="LXIV"||s=="LXVI") return "XLIV";
		if(s=="LXV") return "XLV";
		if(s=="LXVII") return "XLVII"; 
		if(s=="LXVIII") return "XLVIII";
		if(s=="LXIX"||s=="LXXI") return "XLIX"; //对"LX"的特殊判断 
		ss="L"; //在返回的时候和'L'字符一起返回（若s的开头不为'L'，ss为空，不干扰结果） 
		s=s.substr(1,s.length()-1); //若s不在特殊判断范围内，使用substr函数去掉'L'字符，其余部分按照正常方法判断 
	}
	//1至9 
	if(s=="I"||s=="II"||s=="III"||s=="IV"||s=="V"||s=="VII"||s=="VIII"||s=="IX") return ss+s;
	if(s=="VI") return ss+"IV";
	//10至19 
	if(s=="X"||s=="XII"||s=="XIII"||s=="XIV"||s=="XV"||s=="XVII"||s=="XVIII"||s=="XIX") return ss+s;
	if(s=="XI") return ss+"IX";
	if(s=="XVI") return ss+"XIV";
	//20至29
	if(s=="XX"||s=="XXII"||s=="XXIII"||s=="XXIV"||s=="XXV"||s=="XXVII"||s=="XXVIII"||s=="XXIX") return s;
	if(s=="XXI") return ss+"XIX"; 
	if(s=="XXVI") return ss+"XXIV";
	//30至39
	if(s=="XXX"||s=="XXXII"||s=="XXXIII"||s=="XXXIV"||s=="XXXV"||s=="XXXVII"||s=="XXXVIII"||s=="XXXIX") return ss+s;
	if(s=="XXXI") return ss+"XXIX"; 
	if(s=="XXXVI") return ss+"XXXIV";
	//40至49
	if(s=="XLI"||s=="XLII"||s=="XLIII"||s=="XLIV"||s=="XLV"||s=="XLVII"||s=="XLVIII"||s=="XLIX") return ss+s;
	if(s=="XLVI") return ss+"XLIV";
	//90至100 
	if(s=="XC"||s=="XCI"||s=="XCII"||s=="XCIII"||s=="XCIV"||s=="XCV"||s=="XCVII"||s=="XCVIII"||s=="XCIX"||s=="C") return ss+s;
	if(s=="XCVI") return ss+"XCIV";
} //得到排列前得罗马数字，返回排列后的罗马数字 
int main(){
	string s;
	cin>>s;
	cout<<opt(s)<<endl;
	return 0;
}
```

---

## 作者：Argon_Cube (赞：7)

* **【题目链接】**

[Link:P7773](https://www.luogu.com.cn/problem/P7773)

* **【解题思路】**

看了一看提交区，真的有人打了一个 $100$ 个`if`的程序交上来……

好的，现在说一说这题如何做。

其实这题正解就是打表（$B$ 只有 $99$ 个可能值）。

但是显然我们是不会~~懒得~~打一个有 $100$ 个`if`的程序的。

这里说一下我的打表方式：

首先打出 $1\sim100$ 的罗马数字。

然后从小往大一个个与输入的罗马数字比对，如果某一个罗马数字可以由输入的罗马数字排列得到，那么就直接输出。由于是从前往后找的，那么我们就可以保证第一次找的是最小的。

* **【代码实现】**

```cpp
#include <iostream>
#include <string>
#include <array>

using namespace std;

array<string,101> romans={"","I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","XV","XVI","XVII","XVIII","XIX","XX","XXI","XXII","XXIII","XXIV","XXV","XXVI","XXVII","XXVIII","XXIX","XXX","XXXI","XXXII","XXXIII","XXXIV","XXXV","XXXVI","XXXVII","XXXVIII","XXXIX","XL","XLI","XLII","XLIII","XLIV","XLV","XLVI","XLVII","XLVIII","XLIX","L","LI","LII","LIII","LIV","LV","LVI","LVII","LVIII","LIX","LX","LXI","LXII","LXIII","LXIV","LXV","LXVI","LXVII","LXVIII","LXIX","LXX","LXXI","LXXII","LXXIII","LXXIV","LXXV","LXXVI","LXXVII","LXXVIII","LXXIX","LXXX","LXXXI","LXXXII","LXXXIII","LXXXIV","LXXXV","LXXXVI","LXXXVII","LXXXVIII","LXXXIX","XC","XCI","XCII","XCIII","XCIV","XCV","XCVI","XCVII","XCVIII","XCIX","C"};

string cnt_roman(const string& roman)
{
	string counter(5,'0');
	for(const char& tmp:roman)
		switch(tmp)
		{
			case 'I':
				counter[0]++;
				break;
			case 'V':
				counter[1]++;
				break;
			case 'X':
				counter[2]++;
				break;
			case 'L':
				counter[3]++;
				break;
			case 'C':
				counter[4]++;
				break;
		}
	return counter;
}

int main(int argc,char* argv[],char* envp[])
{
	string roman;
	cin>>roman;
	for(int i=1;i<100;i++)
		if(cnt_roman(roman)==cnt_roman(romans[i]))
			return cout<<romans[i],0;
	return 0;
}

```

---

## 作者：Flanksy (赞：4)

### 字符串

题解区都是来教人 $1 \sim 99$ 的罗马数字怎么写的？这也太搞笑了哥们。

----------

从 $1$ 枚举到 $99$ 并尝试生成每个数字对应的罗马数字，实际上只需要把每个数字的个位和十位拼起来。

所以只需要 $1 \sim 10,20,30,40,50,60,70,80,90$ 这些数对应的罗马数字就可以生成所有罗马数字。

首先生成每个数字，生成之后把数字的每一位排序再查询 `unordered_map`，如果这个数字可以重排得到更小的数，那么这个更小的数在此前已经出现过了，否则这个数字就是组成它的字母重排后能得到的最小的数。

时间复杂度 $O(1)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<string,string> ans;
unordered_map<int,string> ex;
string s;
int main(){
    ex[1]="I",ex[2]="II",ex[3]="III",ex[4]="IV",ex[5]="V";
    ex[6]="VI",ex[7]="VII",ex[8]="VIII",ex[9]="IX";
    ex[10]="X",ex[20]="XX",ex[30]="XXX",ex[40]="XL",ex[50]="L";
    ex[60]="LX",ex[70]="LXX",ex[80]="LXXX",ex[90]="XC";
    for(int i=1;i<=99;i++){
        if(!ex.count(i)) ex[i]=ex[i-i%10]+ex[i%10];
        s=ex[i],sort(s.begin(),s.end());
        if(!ans.count(s)) ans[s]=ex[i];
    }
    cin>>s;
    sort(s.begin(),s.end());
    cout<<ans[s]<<'\n';
    return 0;
}
```

---

## 作者：永动姬 (赞：4)

#### 先开一个[传送门](https://www.luogu.com.cn/problem/P7773)


### 分析时间

- 由于我没有像其他几位神犇，想到了一些规律，所以只好暴力判断（也就是打表）来做这道题.毕竟  $ B\leqslant 100 $  

- 窝的代码本质上是枚举 $ B =1 \rightarrow B =100$ 的所有情况。先输入B，再去判断是哪一个罗马数字，接着把相对应的答案输出来即可

- 废话不多说，上代码！说实话这个做法是挺耗时间的...qwq

### 代码时间(放心，可以过）

-  如何输入：

1. 用 cin 输入
```cpp
	string s;//字符串变量
	cin>>s;
```

2. 用 getline 输入
```cpp
	string s;
	getline(cin,s);
```

- 如何判断：
```cpp
	string s;
	if(s==" ") cout<<" ";    
```

- 完整代码时刻
-> [完整代码传送门](https://www.luogu.com.cn/paste/gquu1ed3)


---

## 作者：DF_Factory (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7773)

思路：

把 1 至 100 的罗马数字打出来。

循环判断哪一个罗马数字和输入的罗马数字相等，输出这个罗马数字即可。

此处“两个罗马数字相等”的定义是：两个罗马数字可以通过重新排列其中一个数字的字母使得这两个罗马数字相等。

代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;
string R[120]={
"","I","II","III","IV","V","VI","VII","VIII","IX","X",
"XI","XII","XIII","XIV","XV","XVI","XVII","XVIII","XIX","XX",
"XXI","XXII","XXIII","XXIV","XXV","XXVI","XXVII","XXVIII","XXIX","XXX",
"XXXI","XXXII","XXXIII","XXXIV","XXXV","XXXVI","XXXVII","XXXVIII","XXXIX","XL",
"XLI","XLII","XLIII","XLIV","XLV","XLVI","XLVII","XLVIII","XLIX","L",
"LI","LII","LIII","LIV","LV","LVI","LVII","LVIII","LIX","LX",
"LXI","LXII","LXIII","LXIV","LXV","LXVI","LXVII","LXVIII","LXIX","LXX",
"LXXI","LXXII","LXXIII","LXXIV","LXXV","LXXVI","LXXVII","LXXVIII","LXXIX","LXXX",
"LXXXI","LXXXII","LXXXIII","LXXXIV","LXXXV","LXXXVI","LXXXVII","LXXXVIII","LXXXIX",
"XC","XCI","XCII","XCIII","XCIV","XCV","XCVI","XCVII","XCVIII","XCIX","C"
};
int same(string a,string b){
	if(a.size()!=b.size()) return 0;
	int ret=1,ra[200],rb[200];
	memset(ra,0,sizeof(ra));
	memset(rb,0,sizeof(rb));//不memset全WA
	for(int i=0;i<a.size();i++) ra[a[i]]++,rb[b[i]]++;
	for(int i=0;i<200;i++) ret&=(ra[i]==rb[i]);
	return ret;
}
int main(){
	string s;
	cin >> s;
	for(int i=1;i<=100;i++){
		if(same(s,R[i])){
			cout << R[i];
			return 0;
		}
	}
	return 0;
}

```


---

## 作者：Leo2020 (赞：3)

## 思路
假设两个罗马数字字符相同，排列组合不同，可以把两个数看做同一项，因为最后的结果都是相同的。例如 $4$ 和 $6$ 分别为 "IV" 和 "VI" ,字符相同，排列组合不同，用同一个 map 数组 $a$ 来存储所对应的最小值。

提前预处理前 $100$ 个罗马数字的最小值，为了统一 $4$ 和 $6$ 可以把罗马数字按照字典顺序排序统一为 "IV" ,当循环到4时 $a_4 = 4$
 ,当循环到 $6$ 时 $a_4 = 4$。

最后输出罗马数字所对应的最小值。
 
上代码（~~代码太丑了，大佬轻喷~~）。

```
#include<bits/stdc++.h>
using namespace std;
map<string,int>a;//存贮最小值的变量
char* d[10]=
{"","I","II","III","IV","V","VI","VII","VIII","IX"};
char* tt[10]={"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
char* h[10]={"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
int f(char n){//罗马数字转阿拉伯数字
	int t=0;
	switch(n){//判断
		case 'I':t=1;break;
		case 'V':t=5;break;
		case 'X':t=10;break;
		case 'L':t=50;break;
		case 'C':t=100;break;
		case 'D':t=500;break;
		case 'M':t=1000;break;
	}
	return t;
}
int v(string n){//罗马数字转阿拉伯数字
	int l=n.size();
	int sum=0;
	for(int i=0;i<l;i++){
		if(f(n[i])>=f(n[i+1])) sum+=f(n[i]);//生成阿拉伯数字
		else sum-=f(n[i]);
	}
	return sum;//返回阿拉伯数字
}
int t[1000015];
int main(){
    for(int i=1;i<100;i++){//1到100预处理
       	string n;
        n=h[i%1000/100];//阿拉伯数字转罗马数字
	n+=tt[i%100/10];
	n+=d[i%10];
        for(int j=0;j<n.size();j++)t[j]=n[j];//罗马数字变字典序
        int tem=v(n);
        sort(t,t+n.size());
        for(int j=0;j<n.size();j++)n[j]=t[j];
        if(a[n]==0)a[n]=tem;//存储结果
        else a[n]=min(a[n],tem);
        memset(t,0,sizeof(t));//清空数字
    }
    string n;
    cin >> n;//输入字符串
    for(int j=0;j<n.size();j++)t[j]=n[j];//罗马数字变字典序
    int tem=v(n);
    sort(t,t+n.size());
    for(int j=0;j<n.size();j++)n[j]=t[j];
   	 //这个时候，a[n]就是最后的结果，需要转换成罗马数字
    	cout << h[a[n]%1000/100] << tt[a[n]%100/10] << d[a[n]%10] <<endl;//输出
	return 0;//结束
}
```

---


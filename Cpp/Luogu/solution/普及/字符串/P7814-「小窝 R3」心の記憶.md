# 「小窝 R3」心の記憶

## 题目背景

> 淡い夕暮れ飲み込まれて  
「君」の消えかけて姿を  
忘れさせるように走ってた   
新しい平和の世界に  
——[《心の記憶》](https://music.163.com/song?id=1847928316)

## 题目描述

- 本题中「**子串**」的定义如下：

字符串 $S$ 的子串是 $S$ 中**连续**的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \leq l \leq r \leq |S |,|S|$ 表示 $S$ 的长度）。

- 本题中「**子序列**」的定义如下：

对于字符串 $S$ 和一个长度为 $n$ 的严格单调递增数列 $k_1,k_2,\cdots,k_n(\forall 1\le i\le n,1\le k_i\le |S|)$，$S_{k_1},S_{k_2},\cdots,S_{k_n}$ 所组成的字符串即为 $S$ 的子序列。

---------------

现有 $T$ 次询问。
每次询问给定一个长度为 $n$ 的 01 串，记为 $A$。回答应是一个字符串 $B$，满足：

- $B$ 是长度为 $m$ 的 01 串。
- $B$ 中不存在任意一个**子串**与 $A$ 相同。
- $B$ 中存在**至少**一个**子序列**与 $A$ 相同。

输出任意一个满足要求的字符串 $B$ 即可。

## 说明/提示

### 样例解释

在第二次询问中，`01101` 和 `10110` 是另外合法的方案。

### 数据范围

| Subtask | 分值 | $\sum m\le$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$  | $10$ | $2\times10^6$ | $A$ 只由 `0` 组成 |
| $2$ | $10$ | $15$ | 无 |
| $3$ | $20$ | $2000$ | 无 |
| $4$  | $30$ | $10^6$ | $A$ 随机生成 |
| $5$ | $30$ | $2\times 10^6$ | 无 |

对于 $100\%$ 的数据，$1\le n\le m$，$1\le \sum m\le 2\times 10^6$。保证 $A$ 只由 `0` 和 `1` 组成。

## 样例 #1

### 输入

```
4
1 1
1
3 5
010
4 8
1101
5 6
11111```

### 输出

```
-1
01110
10100101
111101```

# 题解

## 作者：Hexarhy (赞：16)

这里是出题人官方题解。

为了保证子序列相同，我们可以直接在 01 串 $A$ 的基础上插入 $m-n$ 个字符。下文的所有分析都是基于此的。

下文所有做法都要求先特判无解。

显然 $n=m$ 或 $n=1$ 时无解，因为不可能做到子串不同。除此之外，还有容易忽略的情况是 $A$ 为 `01` 或 `10`。

当然，如果不想动脑，随机生成字符串并暴力验证也可以发现只有上述可能。

### Subtask 1

由于 $A$ 全是 `0`，因此在非首尾位置直接插入 $n-m$ 个 `1` 即可。

期望得分 $10$ 分。

### Subtask 2

暴力枚举每一位填 `0` 还是 `1`，然后跑一次 KMP 检验是否有子串相同，再用两个指针扫一遍 $A,B$ 看是否有子序列相同。

时间复杂度 $O(m\cdot2^m)$。期望得分 $20$ 分。

### Subtask 3

显然直接插入 $m-n$ 个连续的 `0` 或 `1` 可以很大机会做到子串不相同。

此时枚举插入位置，再跑 KMP 判断有没有子串相同即可。

时间复杂度 $O(m^2)$。期望得分 $40$ 分。

### Subtask 4

送给随机化的选手。乱搞应该都可以过。

期望得分 $70$ 分。

### Subtask 5

先放结论：**插少插首异**。

「**插少**」，即插入的字符为 `0` `1` 在 $A$ 中出现次数少的那个。  
「**插首异**」，即插入位置为另一个字符第一次出现的位置后。

下面证明这种做法的正确性。

要保证插入一段字符后不会有子串相同，分类讨论一下：

- 插入串与前面拼接成的串的子串不会是 $A$。
- 插入串与后面拼接成的串的子串不会是 $A$。
- 插入串的子串 或者 与前后拼接成的串的子串不会是 $A$。

不失一般性地，假设 `1` 的数量比 `0` 少，则插入串为 $m-n$ 个连续的 `1`。然后我们逐个考虑：

- **插入串与前面拼接成的串的子串不会是 $A$。**

显然成立，因为 `0` 的数量不一致。插首保证了插入串之后还有 `0`。

- **插入串与后面拼接成的串的子串不会是 $A$。**

显然成立，因为 `0` 的数量不一致。

- **插入串的子串 或者 与前后拼接成的串的子串不会是 $A$。**

对于前者，因为 $A$ 中肯定有 `0`，而插入串没有 `0`，不会有子串是 $A$。

对于后者，我们要找的子串为了达到这么多 `0` 的数量，而插入串并没有新增 `0` 的数量，因此这个子串必须包含插入串。此时第一个和第二个 `0` 的距离由于插入串发生了改变，因此必定不会有子串同时满足：

- `0` 的数量与 $A$ 相同。
- 第一个与第二个 `0` 的距离与 $A$ 对应相同。

综上，「插少插首异」的策略是正确的。代码实现的时候分类讨论 `0` `1` 数量多少即可。

时间复杂度 $O(m)$。期望得分 $100$ 分。

当然，应该存在不少正确的构造方法，思考难度应该都不大~~毕竟本来设计出来是打算作 A 题的~~。

### 参考代码

```cpp
int main()
{
    int T;scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        vector<bool> a(m+10);
        for(int i=1;i<=n;i++)
        {
        	int x;scanf("%1d",&x);
        	a[i]=x;
		}
        if(n==m || n==1 || (n==2 && (a[1]^a[2])))
        {
            puts("-1");
            continue;
        }
        int cnt0=0,cnt1=0;
        for(int i=1;i<=n;i++)   a[i]?cnt1++:cnt0++;
        bool f=false;
        for(int i=1;i<=n;i++)
        {
            printf("%d",int(a[i]));
            if(!f && (cnt1<cnt0?!a[i]:a[i]))
            {
                for(int j=1;j<=m-n;j++)
                	printf("%d",int(cnt1<cnt0));
                f=true;
            }
        }
        putchar('\n');
    }
    return 0;
}
```

### 结语

本题定位为签到题，题意简洁，代码简短，没有涉及任何高深算法，考察了选手的构造能力和细心程度~~是不可多得的好题~~。

---

## 作者：Eason_AC (赞：15)

## Content
现有 $T$ 次询问。 每次询问给定一个长度为 $n$ 的 01 串，记为 $A$。回答应是一个字符串 $B$，满足：

- $B$ 是长度为 $m$ 的 01 串。
- $B$ 中不存在任意一个子串与 $A$ 相同。
- $B$ 中存在至少一个子序列与 $A$ 相同。

若有多解输出任意一个解。

**数据范围：$1\leqslant n\leqslant m$，$1\leqslant\sum m\leqslant 2\times 10^6$，$A_i\in\{0,1\}$。** 
## Solution
这里直接讲正解。 

首先，下列情况不能够造出符合要求的 B：
- $n=1$。
- $n=m$。
- $n=2$ 且字符串是 `01` 或 `10`。

否则可以构造出一种方案。构造方案如下： 

1. 如果字符串形如 `000...1` 或者 `111...0` 的话，则先在第一个字符后面插入一个与第一个字符不同的字符（如果第一个字符是 `1` 则在后面插入 `0`，反过来则插入 `1`），然后如果长度不够的话就在后面不停地插入最后一个字符相同的字符直到长度达到 $m$ 为止。
2. 否则在原字符串最后一个字符之前插入 $m-n$ 个与最后一个字符不同的字符即可。

是不是很简单呢？
## Code
```cpp
namespace Solution {
	iv Main() {
		MT {
			int n, m;
			read(n, m);
			string s; cin >> s;
			if(n == 1 || n == m) puts("-1");
			else {
				string ans = s.substr(0, n - 1);
				int fl0 = 1, fl1 = 1;
				F(int, i, 0, (int)ans.size() - 1) if(ans[i] != '0') fl0 = 0; else if(ans[i] != '1') fl1 = 0;
				if((fl0 && s[n - 1] == '1') || (fl1 && s[n - 1] == '0')) {
					if(n == 2) puts("-1");
					else {
						string ans2 = ""; ans2 += ans[0];
						if(ans[0] == '0') ans2 += "1";
						else ans2 += "0";
						ans2 += s.substr(1, n - 1);
						F(int, i, n + 1, m - 1) ans2 += s[n - 1];
						cout << ans2 << endl;
					}
					continue;
				}
				if(s[n - 1] == '0') {
					F(int, i, n, m - 1) ans += "1";
					ans += s.substr(n - 1, 1);
				} else {
					F(int, i, n, m - 1) ans += "0";
					ans += s.substr(n - 1, 1);
				}
				cout << ans << endl;
			}
		}
		return;
	}
}
``` 

---

## 作者：Prean (赞：11)

lmpp 教你对着样例得到做法.jpg

题意：给定一个长度为 $ n $ 的字符串 A，要求你构造一个字符串 B，使得 A 是 B 的子序列且 A 不是 B 的子串。

首先给出无解的判断方法：
```cpp
if(n==1||n==m||(n==2&&A[1]!=A[2])){
	printf("-1\n");continue;
}
```
无解的判断方法很好理解吧 qwq。

然后观察样例：

样例：
```
010->01110
1101->10100101
11111->111101
```
除了第二个，第一个和第三个是不是都是在 **原串中插入一段 0 或 1** 啊？

思考这样做的正确性。B一定是 A 的子串，但 A 真的不是 B 的子序列吗？

好像如果能够把控中间插入的是 0 还是 1，那么 A 就不是 B 的子串！

至于这个位置，分两种情况讨论：

1. A 串存在一个位置 $ i $ 使 $ A_i=A_{i+1} $。

肯定在 $ i $ 的后面插入一串和 $ A_i $ 相反颜色的字符串啊！

2. 不存在这个位置

那么整个串就是 $ 0101010101... $ 或者 $ 10101010101... $，在中间随便一个位置插入就行，0 和 1 都可以。

不过要注意一下判断当 $ n=3 $ 的时候有可能出锅。
```cpp
#include<cstdio>
const unsigned M=2e6+5;
char A[M];unsigned T,n,m;
signed main(){
	register unsigned i,j;bool f;
	scanf("%u",&T);
	while(T--){
		scanf("%u%u%s",&n,&m,A+1);f=true;
		if(n==1||n==m||(n==2&&A[1]!=A[2])){
			printf("-1\n");continue;
		}
		for(i=1;i<n;++i){
			if(A[i]==A[i+1]){
				for(j=1;j<=i;++j)printf("%c",A[j]);
				for(j=1;j<=m-n;++j)putchar(A[i]=='0'?'1':'0');
				for(j=i+1;j<=n;++j)printf("%c",A[j]);printf("\n");f=false;break;
			}
		}
		if(f){
			if(n==3){
				printf("%c%c",A[1],A[2]);
				for(i=1;i<=m-n;++i)printf("%c",A[2]);printf("%c\n",A[3]);
			}
			else{
				for(i=1;i<=n-2;++i)printf("%c",A[i]);
				for(i=1;i<=m-n;++i)printf("%c",A[n-2]);printf("%c%c\n",A[n-1],A[n]);
			}
		}
	}
}
```

---

## 作者：闲人 (赞：4)

## P7814  
[题目传送门](https://www.luogu.com.cn/problem/P7814)  
## 题目简述  
- 有两个由0和1组成的字符串 $A$ 和 $B$ ，其中 $A$ 小于 $B$ 。  

- 其中 $A$ 不是 $B$ 的字串但是 $A$ 却是 $B$ 的子序列。
- 找出一个满足要求得 $B$ 串并输出。
- 一共 $T$ 组询问， $A$ 串长度为 $n$ ， $B$ 串长度为 $m$ , 其中 $1 \le n \le m , 1 \le \sum m \le 2 \times 10 ^ 6$ 

## 题目分析 
首先我把这道题分为了两个部分：  
1. 当 $A$ 长度为一和二时

1. 当 $A$ 的长度在三以上的时候。

我们来分别讨论以上两种情况：  
### 长度为 $1$ 或 $2$  

显然， 如果长度为 $1$ 时一定找不到一个满足条件的 $B$ 。  
再来讨论 $2$ 的情况，设想， 如果这两个数一个是 $0$ ， 一个是 $1$ ， 也不存在可行解， 事实上当 $A$ 的长度和 $B$ 的长度一样时也时无解的。 那么难道只要 $A$ 长度为 $1$ 或 $2$ 就都无解吗？其实不是， 如果 $A$ 形如 $00$ ，那 $B$ 只要像 $01...10$ 就可以了。 $11$ 时同理。  
### 长度在 $3$ 以上
1. 如果在原序列中 $1$ 和 $0$ 都有， 就有一种比较妙的容易想到的方法， 比如现在的序列是这样的： $01110101010$  我们不妨将第一个数 $(0)$ 和后面所有的数分开来看，如果我在第一个数 $(0)$ 的后面一直添加和它不同的数 $(1)$ ， 那么后面的所有数 $(1110101010)$ 和前面的那个新加的数 $(1)$ 一定组成不了原序列。所以成立！

1. 那么新的问题出现了如果我的序列是这样的： $011111111$ 会发现用上一个方法不行了，应为如果在第一个数 $(0)$ 后面加不同的数 $(1)$ 时第一个数会和后面的数组成原序列， 俗话说特殊情况特殊处理， 我们不难想到从第二个数开始插入与后面的数 $(1)$ 不同的数 $(0)$ ，就像这样： $010...011111111$ 。好啦，现在这个问题也愉快的解决啦！

## AC Code  
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

const int N = 1e6;

int n, m;
char a[N];

inline int check(int l, int r)              //判断序列的成分， 全是0则返回0， 全是1则返回1， 如果都有则返回-1；
{
    bool one = false, zero = false;
    for (register int i = l; i <= r; i++)
        if (one == true && zero == true) return -1;
        else if (a[i] == '1') one = true;
        else zero = true;
    if (one == true && zero == true) return -1;
    if (one == true && zero == false) return 1;
    else return 0;
}

using namespace std;

int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &n, &m);
        cin >> a;
        int len = strlen(a);
        if (n == m || n == 0 || n == 1)        //特殊的无解情况
        {
            printf("-1\n");
            continue;
        }
        if(n == 2)                             //A长度时2的情况
        {
            if(a[0] == a[1])
            {
                printf("%c", a[0]);
                for (int i = 1; i <= m - n; i++) printf("%c", ~a[0] + 98);
                printf("%c\n", a[len - 1]);
            }
            else printf("-1\n");
            continue;
        }
        int right = check(1, len - 1);
        if(right == 1 || right == 0)            //常规情况
        {
            printf("%c%c", a[0], a[1]);
            for (int i = 1; i <= m - n; i++) printf("%c", ~a[1] + 98);
            for (int i = 2; i <= len - 1; i++) printf("%c", a[i]);
            printf("\n");
            continue;
        }
        else
        {
            printf("%c", a[0]);
            for (int i = 1; i <= m - n; i++) printf("%c", ~a[0] + 98);
            for (int i = 1; i <= len - 1; i++) printf("%c", a[i]);
            printf("\n");
            continue;
        }
    }
    return 0;
}
```
## 后记
此题主要在于思维， 对于代码的要求极低， 但是思维一定要打开。



---

## 作者：EnofTaiPeople (赞：4)

首先给大家介绍一下我在考场上的提交结果：先是两个零分，接着三个三十分、三个七十分最后得到了满分。

我最开始的想法如下：
1. 如果 $n=1$，无解；
2. 如果 $m\le n$ 无解；
3. 否则有解，B 串的第一个字符是 A 串的第一个字符，接下来 B 串的 $m-n$ 个字符与第一个相反，随后 $n-1$ 个字符即 A 串的后 $n-1$ 个字符。

如若 A 串为 $1101$，且 $n=4,m=8$ 则答案是 $10000101$。

于是得出了如下的**十分**代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
	char c=getchar();int an=0,f=1;
	while((c<'0'||c>'9')&&c!='-')
		c=getchar();
	if(c=='-')f=-1,c=getchar();
	while(c>='0'&&c<='9')
		an=an*10+c-'0',c=getchar();
	return an*f;
}
inline void Slove(){
	int n=read(),m=read();
    char str1[2000005]={0};
	scanf("%s",str1);
	if(n==1||n>=m){
		printf("-1\n");return;
	}
	int an=m-n;register int i,tot=-1;
	putchar(str1[0]);
	char ch=(str1[0]=='0')?'1':'0';
	for(i=1;i<=an;i++)putchar(ch);
	for(i=1;i<n;i++)putchar(str1[i]);
	putchar('\n');
	return;
}
int main(){
	int T=read();while(T--)Slove();
	return 0;
}
```

问题出在哪？我试了一个样例：
```
1
2 10
10
```
输出如下：
```
100000000000
```
不难发现，当 A 串第 $2$~$n-1$ 个字符全部相同时，这个算法是有问题的。

不妨特判一下，如果是，B 串变为前两个字符是 A 串的前两个字符，接下来 $m-n$ 个字符与第二个字符相反，接下来 $n-2$ 个字符则是 A 串的后 $n-2$ 个字符。

注：当 $n=2$ 时，$10$ 和 $01$ 这两个作为 A 串时无解。

考场 AC 代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline void Slove(){
    int n,m;
	scanf("%d%d",&n,&m);
    char str[2000005];
	scanf("%s",str);
	if(n==1||n>=m){
		printf("-1\n");return;
	}
	int an=m-n;register int i;
	char ch=(str[0]=='0')?'1':'0';
    for(i=1;i<n;i++)
        if(str[i]==str[0])break;
    if(i==n){
        if(n<=2){
            printf("-1\n");return;
        }
	    putchar(str[0]);
        putchar(str[1]);
        for(i=1;i<=an;i++)
            putchar(str[0]);
        for(i=2;i<n;i++)
            putchar(str[i]);
        putchar('\n');
        return;
    }
	putchar(str[0]);
	for(i=1;i<=an;i++)putchar(ch);
	for(i=1;i<n;i++)putchar(str[i]);
	putchar('\n');
	return;
}
int main(){
	int T;scanf("%d",&T);while(T--)Slove();
	return 0;
}
```

---

## 作者：二gou子 (赞：2)

## Solution

首先很容易发现 $n=1$ 或者 $n=m$ 那么一定没有合法答案，然后考虑如何构造答案。根据第二个限制我们很容易想到从原字符串中插入一些字符来满足第一个和第三个限制，而第一个限制很容易满足，关键是如何满足第三个限制。

我的方法是这样的：找原序列中是否有两个相同的字符相邻。比如如果一个字符串是 $0101101$ ，中间有 $2$ 个 $1$ 相邻，那么这个时候我们就往这两个相同的字符中插入 $m-n$ 个与它们不同的字符，比如这个例子就可以往 $2$ 个 $1$ 当中插入 $m-n$ 个 $0$ ，这样的答案一定是合法的，下面可以简单证明一下：

首先前两个限制显然满足，考虑是否满足第三个限制。注意到我们将原序列中的一对相同且相邻的字符拆开了，而在我们构造出来的字符串中已经不可能再找出一段子串使得相邻的字符对数与原字符串相同了，也就是不可能存在与原字符串相同的子串，这样就可以满足第三个限制。

那么如果给出的序列是 $01010101$ 这样的字符串呢？这样就更简单了，我们直接在第一个字符后面插入 $n-m$ 个第二个字符就好了，这也可以证明：如果要想保证子串长度与原字符串相同，那么就必然要选出一对相邻且相同的字符，但原串并没有一对相邻且相等的字符，所以不可能与原串相等。

但是好像落了点什么，如果说给出的字符串是 $01$ 或 $10$ ，那么好像也没有合法答案。原因很简单，不管在这两个字符中间插入什么，都会得到一个子串与原字符串相等，这样一直推下去就可以证明没有合法答案。所以还要特判掉这种情况不合法。

然后就没了。时间复杂度 $O(n+m)$

## Code
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e6+5;
int T,n,m;
char s1[N];
int main()
{
	scanf("%d",&T);
	while(T--){
		bool flg=0;
		scanf("%d%d",&n,&m);
		scanf("%s",s1+1);
		if(n==1||n==m){
			printf("-1\n");
			continue;
		}
		for(int i=1;i<n;i++){
			if(s1[i]==s1[i+1]){
				for(int j=1;j<=i;j++){
					cout<<s1[j];
				}
				for(int j=1;j<=m-n;j++){
					if(s1[i]-'0'==1) cout<<"0";
					else cout<<"1";
				}
				for(int j=i+1;j<=n;j++){
					cout<<s1[j];
				}
				cout<<"\n";
				flg=1;
				break;
			}
		}
		if(!flg){
			if(n==2){
				printf("-1\n");
				continue;
			}
			cout<<s1[1];
			for(int i=1;i<=m-n;i++){
				cout<<s1[2];
			}
			for(int i=2;i<=n;i++){
				cout<<s1[i];
			}
			cout<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：maruize (赞：0)

考虑将串 B 分成两段，中间插入一些字符组成 A 使得不形成为 B 的子串
。

那么重点在分离方法。

最好想的是将 B 中第一个字符摘出来。但我越推越麻烦。

然后想了好长时间终于想到了以下拆分极长 1/0 段的方法。

---

设串 B 极长连续 1 的个数为 $k_b$ ，极长段个数为 $h_b$ ；

串 A 极长连续 1 的个数为 $k_a$ ，极长段个数为 $h_a$ 。

假设 $k_b>1$ ,只需 $k_a<k_b$ 或  $k_a=k_b,h_a<h_b$  即可使 B 一定不是 A 的子串。

所以去随便找一个极长 1 段，在中间插入若干个 0 即可。

---

如果不符合假设呢？

- 反转 01 （即考虑连续的 0 ）

- 但有可能 0 的极长连续段长也是 $1$ 啊？

---

然后发现这种情况其实是 01 交替。

- 串长为 $2$ ：无解。

- 串长 $> 2$：在串**中间**随便插入一段连续的 0 or 1 即可。

---

## 作者：luckydrawbox (赞：0)

### 提供一个最劣解

~~你们几十毫秒跑完的东西，我要几百毫秒。~~

显然，以下几种情况是无解的：

- $n=m$。

- $n=1$。

- $A=$``01``。

- $A=$``10``。

特判一下就好了。

注：下文提到的相反数字指的是：$0$ 的相反数字是 $1$，$1$ 的相反数字是 $0$。

为了保证子序列相同，我们先令答案 $B$ 为 $A$。

可是这样 $B$ 的前缀和 $A$ 就相等了，于是我们把 $B$ 的最后一个字符变成**相反的数字**。

然后在末尾插入剩下 $m-n$ 个字符。

插入第 $i$ 个字符 $(0\le i<m-n)$ 时我们采取如下贪心策略：

- 如果 $A_{0\sim n-2}=B_{i+1\sim n+i-1}$，则加入 $A_{n-1}$ 的相反数字。

- 否则，加入 $A_{n-1}$。

也就是说，如果加入 $A_{n-1}$ 不符合要求，就加入它的相反数字。

然而这样过不了以下两种情况：

- ``000000……1``

- ``111111……0``

怎么办呢？其实加入操作在前面和在后面是一样的，我们把这个 $A$ 翻转，打上标记，按前面的求一遍，对照标记反着输出就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(int x)
{
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}
int t,n,m;
string s,s1,s2;
bool fl;
char f(char c){//求c的相反数字 
	if(c=='0')
		return '1';
	else
		return '0';
}
int q0(){//0的个数 
	int ans=0;
	for(int i=0;i<s.size();i++)
		if(s[i]=='0')
			ans++;
	return ans;
}
int main()
{
    t=read();
    while(t--){
    	n=read();
    	m=read();
    	cin>>s;
    	if(n==m||n==1||s=="01"||s=="10"){//无解特判 
    		puts("-1");
    		continue;
		}
		fl=0;
		if((q0()==1&&s[n-1]=='0')||(q0()==n-1&&s[n-1]=='1'))
		{
			for(int i=0;i<n/2;i++)
				swap(s[i],s[n-1-i]);
			fl=1;//打上标记 
		}
		s1=s2=s.substr(0,n-1);
		for(int i=0;i<=m-n;i++){
			if(s1.substr(i,n-1)==s2)
				s1+=f(s[n-1]);
			else
				s1+=s[n-1];
		}
		if(fl){
			for(int i=s1.size()-1;i>=0;i--)
				putchar(s1[i]);
		}
		else
			for(int i=0;i<s1.size();i++)
				putchar(s1[i]);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：yukimianyan (赞：0)

分三类讨论。

一个小技巧：$\tt '0'\oplus 1='1','1'\oplus 1='0'$。

#### 无解
- 当 $n=m$ 时，无法插入字符，$B$ 串一定与 $A$ 串相同，无解；
- 当 $n=1$ 时，由于 $B$ 串是 $\tt 01$ 串，不可避免地出现 $\tt 0$ 和 $\tt 1$，无解；
- 当 $A=\tt "01"$ 时，在保证第三条要求的基础上，不可能找不到两个相邻且不相同的字符，无解；
- 当 $A=\tt "10"$ 时，与 $A=\tt "01"$ 类似，无解。

#### $A$ 中有两个相邻且相同的字符
那我们可以把 $A$ 串从这两个相邻的字符的中间断开，并用 $m-n$ 个与这两个字符不同的字符把它们再连起来。

举个例子，$A=\tt "0101110"$，这时我们把 $A$ 断开成 $\tt "0101$ 和 $\tt "110"$，并用 $m-n$ 个 $\tt '0'$ 把它们连起来，最终效果是 $\tt"0101000...000110"$。

#### $A$ 中没有两个相邻且相同的字符
那么 $A$ 应该是类似于 $\tt "01010101..."$ 这一种字符串，我们可以在首位后面插入 $m-n$ 个与首位不相同的字符。

举个例子，$A=\tt "0101010"$，这时我们在首位后面插入 $m-n$ 个 $\tt '1'$，最终效果是 $\tt "0111...1111010101"$。

代码：
```cpp
int n,m;
char a[100010];
int mian(){
    cin>>n>>m>>a;
    bool flag=0;//有没有两个相邻且相同的字符
    int pos=0;//如果有，那它们在哪里，如果没有，那就从 a[0] 后面插入
    for(int i=0;i<n-1;i++){//暴力扫一遍，可以确定复杂度是对的
        if(a[i]==a[i+1]){
            flag=1;
            pos=i;
            break;
        }
    }
    if(n==m||n==1||(n==2&&a[0]^a[1])){
        cout<<"-1"<<endl;
        return 0;
    }
    a[pos+1]='\0';
    cout<<a;//C 字符串特性，以 '\0' 结尾，那就把末尾改成 '\0' 输出
    a[pos+1]=a[pos]^flag^1;//记得还原
    for(int i=1;i<=m-n;i++) cout<<(char)(a[pos]^1);
    cout<<a+pos+1<<endl;
    return 0;
}
```

---

## 作者：Argon_Cube (赞：0)

* **【题目链接】**

[Link:P7814](https://www.luogu.com.cn/problem/P7814)

* **【解题思路】**

简单构造题。

显然无解情况有：

* $n=1$；

* $n=m$；

* $n=2\land A_1\neq A_2$

除此之外，必定有解。

我的构造方式是：

在两个相邻的、一样的字符中间插入 $n-m$ 个与两边不一样的字符。（例如样例第 $3$ 个数据，我的程序会把`1101`变成`10000101`）。

如果没有找到两个相邻的字符是相同的，则字符串必定形为`101010…`或`010101…`，这时只要在第一个字符与第二个字符中间插入 $n-m$ 个第二个字符即可（例如样例第 $2$ 个数据，我的程序会把`010`变成`01110`）。

* **【代码实现】**

```cpp
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main(int argc,char* argv[],char* envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int testcnt,targetlen;
	cin>>testcnt;
	string inital;
	while(testcnt--)
	{
		cin>>targetlen>>targetlen>>inital;
		if(!(inital.size()!=1&&targetlen!=inital.size()&&!(inital.size()==2&&inital[0]!=inital[1])))
			cout<<-1;
		else
		{
			int pos;
			for(pos=0;pos<inital.size()-1;pos++)
				if(inital[pos]==inital[pos+1])
					break;
			if(pos==inital.size()-1)
				pos=0;
			cout<<inital.substr(0,pos+1)<<string(targetlen-inital.size(),!(inital[pos]-'0')+'0')<<inital.substr(pos+1,inital.size()-pos-1); 
		}
		cout<<'\n';
	}
	return 0;
}

```

---

## 作者：Iam1789 (赞：0)

来氵个题解

首先特判出无解的情况：$n=1$ 或 $m<=n$ 或 $n=2$ 且 $s[1] \neq s[2]$ 时，显然是无解的。这三种情况很容易证明，在此不多赘述。~~然而考场上因为没看出第三种情况被卡了老长时间~~

在此先给出我的构造方法：在最前面插入 $m-n-1$ 个 $s[1] \oplus1$ 后，对 $s$ 从左到右搜索，在第一组满足 $s[i]=s[i-1]$ 之间插入 $s[i]\oplus1$，如果没有这样的情况，则在 $s[n]$ 前插入 $s[n-1]$。

接下来给出这种方法的证明：

因为前面的 $m-n-1$ 个 $s[1]\oplus1$ 与 $s[1]$ 相反，所以若存在子串，则不可能以前 $s[1]\oplus1$ 开头。在剩下 $n+1$ 个字符中，若出现子串只能以 $s[1]$ 或 $s[2]$ 开头。显然 $s[1]$ 是无法 $=s[2]$ 的。若原式中他们相等，则他们之间会被插入 $s[1]\oplus1$。因此只需要考虑 $s[1]$ 开头。若无字符插入过的话（即形如 $01010101...0101$ 一类的，只需在 $s[n]$ 前加入 $s[n-1]$。显而易见以 $s[1]$ 开头的子串结构就被破坏了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int n,m;
char c[2000007];
int main()
{
	scanf("%d",&t);
	for(register int ii=1;ii<=t;++ii)
	{
		scanf("%d%d",&n,&m);
		scanf("%s",c+1);
		if(m<=n||n==1||(n==2&&c[1]!=c[2]))
		{
			cout<<-1<<endl;
			continue;
		}
		c[0]=(c[1]-'0')^1+'0';
		while(m>n+1)
		{
			putchar(c[0]);
			--m;
		}
		putchar(c[1]);
		bool b=0;
		for(register int i=2;i<=n;++i)
		{
			if((c[i]==c[i-1]||i==n)&&b==0)
			{
				putchar((c[i]-'0')^1+'0');
				b=1;
			}
			putchar(c[i]);
		}
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：Jsxts_ (赞：0)

容易发现当 $n=m$ 或 $n=1$ 或 $n=2$ 且 $s_1 \ne s_2$ 时无解。

我们首先可以想到一种看似正确的构造方法：把原串最后一个字符 $s_n$ 反过来（1 变 0，0 变 1），然后把这个字符重复 $m-n$ 次，最后再填上 $s_n$。

但是，我们发现有一种情况会错，就是原串形如 $00....1$ 或 $11....0$ 时，按照上面的方法不符合题意。

于是我们针对这种类型再想一种办法，比如在原串第二位前插入 $m-n$ 个 $s_n$，举个例子： $n=3,m=6,s=001$ 时我们可以构造出字符串 $011101$ 使其满足条件。

思路理清了，代码就很简单：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 2e9;
int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
	return s*f;
}
char s[100010];
int main() {
	int T = read();
	while (T -- ) {
		int n = read(),m = read();
		scanf("%s",s+1);
		if (n == m || n == 1 || (n == 2 && s[1] != s[2])) {
			puts("-1");
			continue;
		}
		char t = s[1];
		int f = 0;
		for (int i = 1;i < n;i ++ ) if (s[i] != s[1]) f = 1;
		if (s[n] == s[1]) f = 1;
		if (!f) {
			putchar(s[1]);
			t = (s[1] == '1' ? '0' : '1');
			for (int i = 1;i <= m-n;i ++ ) putchar(t);
			for (int i = 2;i <= n;i ++ ) putchar(s[i]);
			putchar('\n');
			continue;
		}
		for (int i = 1;i < n;i ++ ) putchar(s[i]);
		if (s[n] == '0') t = '1';
		else t = '0';
		for (int i = 1;i <= m-n;i ++ ) putchar(t);
		putchar(s[n]), putchar('\n');
	}
	return 0;
}
// 010 -> 01110
// 001 -> 01101
```


---

## 作者：零殇 (赞：0)

#### 题意

给定一个长度为 $n$ 的序列 $A$，求构造长度为 $m$ 的序列 $B$，满足 $B$ 的**子串**不包含 $A$ 且 $B$ 的**子序列**包含 $A$。

#### 思路

由于 $B$ 的子序列包含 $A$ ，所以肯定要先构造一个 $A$ 串。

接下来我们要破坏 $A$ 的连续性。

我们才不管那么多东西，只要考虑最简单暴力的办法。

死命往一个地方插入一个相同的字符，直接把你断开。

那么问题来了，我要插什么？插哪里？

容易想到找到最早出现的两个相邻且相同的字符，往中间插入不同与它们的字符。

证明一下：

如果我们插入后，就分成了两段。

前面的部分是断开的，不可能匹配成功。

后面的部分由于取不到缺少的那个相同字符，也不可能匹配成功。

举个栗子：

$11011$

插入后（红色的 $0$ 是插入的）：

$1$ $\color{red}0$ $1011$

前面的 $1$ 和后面的串匹配不到，不可能匹配成功。

后面的 $1011$ 没有前面的 $1$ 做为前缀，也没法匹配成功。

那么如果没有两个相邻且相同的字符呢？

因为只有 $01$ 两个字符，所以 $A$ 只有 $101010...$ 或 $010101...$ 两种情况。

因此我们在第一个字符与第二个字符中间疯狂插入第二个字符就好了。

比如原串为：$10101$

插入后为：$1$ $\color{red}0$ $0101$

还是把原串分成两个部分，让它们都缺少所必须的字符。

最后考虑不可能的情况。

显然，如果 $n=m$ 或 $n=1$ 是没办法的，因为 $B$ 必定有子串等于 $A$。

还有一种情况是 $A$ 为 $10$ 或 $01$，因为如果想把 $A$ 分割开，中间无论插入什么都会匹配成功。

上代码：
```
#include<bits/stdc++.h>
const int N=2e6+7;
using namespace std;
int T,n,m;
int a[N];
int main() {
	scanf("%d",&T);
	while(T--) {
		int sum=0,chec=0;
		scanf("%d%d",&n,&m);
		string s;
		cin>>s;
		for(int i=0;i<n;i++) {
			a[i+1]=s[i]-'0';
			if(a[i+1]==a[i]&&i>0)
				sum++;
		}
		if(s=="01"||s=="10"||n==1||n==m) {
			puts("-1");
			continue;
		}
		if(!sum) {
			printf("%d",a[1]);
			for(int i=1;i<=m-n;i++)
				printf("%d",a[2]);
			for(int i=2;i<=n;i++)
				printf("%d",a[i]);
			printf("\n");
		}
		else {
			printf("%d",a[1]);
			for(int i=2;i<=n;i++) {
				if(a[i]==a[i-1]&&!chec) {
					chec=1;
					for(int j=1;j<=m-n;j++)
						printf("%d",a[i]^1);
				}
				printf("%d",a[i]);
			}
			printf("\n");
		}
	}
	return 0;
}
```
完结撒花~

---


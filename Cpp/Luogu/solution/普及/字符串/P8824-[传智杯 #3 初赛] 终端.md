# [传智杯 #3 初赛] 终端

## 题目描述

有一天您厌烦了电脑上又丑又没用的终端，打算自己实现一个 Terminal。

具体来说，它需要支持如下命令:

1. `touch filename`：如果名为 `filename` 的文件不存在，就创建一个这样的文件，如果已经存在同名文件的话则不进行任何操作。

2. `rm name`：删除名为 `name` 的文件。如果不存在这样的文件，就不进行任何操作。

3. `ls`：按**创建时间为顺序**，显示当前已经存在的未被删除的所有文件。
4. `rename xxx yyy`：将名为`xxx`的文件名字改为 `yyy` 。如果不存在这样的文件，或者已经存在文件名为 `yyy` 的文件，则不做任何操作。

这里所有涉及的文件名都仅由大写或者小写的英文字母构成，且文件名区分大小写。

## 说明/提示

对于 $20\%$ 的数据，只存在 $1,3$ 操作 

对于另外 $20\%$ 的数据，只存在 $1,2,3$ 操作

对于另外 $20\%$ 的数据，只存在 $1,3,4$ 操作

对于 $100\%$ 的数据，满足 $1 \leq n \leq 1000$

保证所有命令的长度不超过 $2000$ 个字符。

## 样例 #1

### 输入

```
6
touch yyh
touch yyhtql
rename yyh yyhnb
touch qwq
rename qwq qaq
ls```

### 输出

```
yyhnb
yyhtql
qaq```

# 题解

## 作者：liupan2010 (赞：6)

前言：

我是蒟蒻，看不懂 ```vector``` 和用 ```map``` 的高端写法，所以只能直接模拟字符串了。

[题目传送门](https://www.luogu.com.cn/problem/P8824)

------------

代码片段：

这里是一些定义：

```cpp
string newfile[1001];//新建的文件 
bool iscreate[1001];//记录这个文件是否存在 
int i,j,n,isok; 
string cmd,filename,anotherfilename;//分别为：输入的指令名，文件名与文件被改之后的名称 
```
------------

```touch``` 指令可以直接遍历，如果找到了同名文件，就不创建，否则就将其文件添加进去。

代码如下：

```cpp
isok=1;
cin>>filename;
for(j=1;j<=n;j++)
	if(newfile[j]==filename)//同名不能创造文件 
	{
		isok=0;
		break;
	}	
if(isok==1)//创建文件 
{
	iscreate[i]=true;
	newfile[i]=filename;
}
```

------------

```rm``` 指令也能直接遍历，如果找到了这个文件，就将这个文件设为不存在。

代码如下：

```cpp
cin>>filename;
for(j=1;j<=n;j++)
	if(newfile[j]==filename)//如果找到了同名文件 
	{
		iscreate[j]=false;//就将文件设为不存在 
		break;
	}	
```

------------

```rename``` 指令首先判断改后的文件名是否重名，如果没有就遍历文件。如果找到了被改名的文件就对其进行改名操作。

代码如下：

```cpp
cin>>filename>>anotherfilename;
isok=1;
for(j=1;j<=n;j++)
	if(newfile[j]==anotherfilename)//如果改后的名字重名了就进行标记 
		isok=0;
	if(isok!=0)//如果没有重名 
	{
		for(j=1;j<=n;j++)
			if(newfile[j]==filename)//如果存在此文件就改名 
				newfile[j]=anotherfilename;
	}
```

------------

```ls``` 指令较为容易实现，直接枚举存在的文件名即可。

代码如下：

```cpp
for(j=1;j<=n;j++)
	if(iscreate[j]==true)//如果文件存在 
		cout<<newfile[j]<<endl;//就输出文件名 
```

------------

结语：

完整代码就不再放出了，可以看下[通过记录](https://www.luogu.com.cn/record/106526008)。

---

## 作者：chen_z (赞：6)

*蒟蒻的第一篇黄题题解，博客食用效果更佳。*

> update on 2024/10/17 修复了代码的两处问题

[题目传送门](https://www.luogu.com.cn/problem/P8824)

---

直接按题意模拟即可，这里采用字符串数组。

### 下面是分段代码：

1\. 当操作为 `touch`，加入文件。

```cpp
cin>>b;
bool f=1;
for(int i=1;i<cnt;i++){
    if(c[i]==b){//特判有没有出现过
        f=0;
        break;
    }
}
if(f==1)c[cnt]=b,cnt++;
```

2\. 当操作为 `rm`，查找并删除文件，找到了就跳出循环。

```cpp
cin>>b;
for(int i=1;i<cnt;i++){
	if(c[i]==b){//找到了
		c[i]="";//删除操作
		break;//跳
	}
}
```

3\. 当操作为 `rename`，查找并替换文件，找到了就跳出循环。

```cpp
cin>>b>>temp;
bool flag=0;
for(int i=1;i<cnt;i++){
    if(c[i]==temp){//看这次修改是否会导致重名
        flag=1;
        break;
    }
}
if(flag==0){
    for(int i=1;i<cnt;i++){
        if(c[i]==b){//修改
            c[i]=temp;
            break;
        }
    }
}
```

4\. 当操作为 `ls`，遍历，如果没被删就输出。

```cpp
for(int i=1;i<cnt;i++){
	if(c[i]!=""){//还没被删
		cout<<c[i]<<'\n';//输出，记得换行
	}
}
```

---

代码注释：

> `a` 为输入的操作名，`b` 和 `temp` 为输入的文件名，`c` 为文件名的数组。

> 另外需要注意的是循环遍历的结束条件为 `i` 小于 `cnt`，题面中第三种情况的操作名是 `ls` 而不是 `1s`。

AC code:

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
string a,b,c[1010];
int cnt=1,n;
int main(){
	cin>>n;
	while(n--){
		cin>>a;
		if(a=="touch"){
			cin>>b;
			c[cnt]=b;
			cnt++;
		}
		else if(a=="rm"){
			cin>>b;
			for(int i=1;i<cnt;i++){
				if(c[i]==b){
					c[i]="";
					break;
				}
			}
		}
		else if(a=="rename"){
			string temp;
			cin>>b>>temp;
			for(int i=1;i<cnt;i++){
				if(c[i]==b){
					c[i]=temp;
					break;
				}
			}
		}
		else if(a=="ls"){
			for(int i=1;i<cnt;i++){
				if(c[i]!=""){
					cout<<c[i]<<'\n';
				}
			}
		}
	}
	return 0;
}
```

感谢观看！

---

## 作者：diamond_153 (赞：3)

## P8824 [传智杯 #3 初赛] 终端 题解
这题其实可以用 ```vector``` 做，现在我们来介绍一下 ```vector``` 的用法：
```cpp
push_back(/*元素*/);//在vector的最后插入一个元素
begin();//返回一个迭代器，指向vector的开始
end();//返回一个迭代器，指向vector的最后一个元素后面的那个元素
erase(/*迭代器*/);//擦除这个迭代器所指向的元素
empty();//如果vector为空，返回true，否则返回false
```
本题需要用到的 ```vector``` 成员也就这么多。现在我们开始做这一题：

## 大致思路
1. `touch filename`：如果名为 `filename` 的文件不存在，就创建一个这样的文件，如果已经存在同名文件的话则不进行任何操作。

### 实现：
```cpp
string file;
cin>>file;//输入文件名
auto index=find(vec.begin(),vec.end(),file);
//使用find函数，在vec里找到file，若找不到则返回vec.end()
if(index==vec.end())//如果找不到此文件就添加
	vec.push_back(file);
```

2. `rm name`：删除名为 `name` 的文件。如果不存在这样的文件，就不进行任何操作。

### 实现
```cpp
string file;
cin>>file;//输入文件名
auto index=find(vec.begin(),vec.end(),file);//找到此文件
if(index!=vec.end())//如果文件在vec里就删除
	vec.erase(index);
```

3. `ls`：按**创建时间为顺序**，显示当前已经存在的未被删除的所有文件。

### 实现
```cpp
if(!vec.empty())//如果vec不为空
	for(auto i:vec)//遍历vec
		cout<<i<<endl;
```
这里的 ```for(auto i:vec)``` 大家可能还不是很懂，现在我们把它写成简单易懂的形式：
```cpp
for(int index=0;index<vec.size()/*vec的大小*/;index++){
	string i=vec[index];
	cout<<i<<endl;
}
```

4. `rename xxx yyy`：将名为`xxx`的文件名字改为 `yyy` 。如果不存在这样的文件，或者已经存在文件名为 `yyy` 的文件，则不做任何操作。

### 实现
```cpp
string old_name,new_name;
cin>>old_name>>new_name;//输入旧名字和新名字
auto iter=find(vec.begin(),vec.end(),old_name);//找到old_name
if(iter!=vec.end())//如果找到了
	*iter=new_name;//将iter解引用，返回一个值，再将这个值设为new_name
```

好了，这题我们已经做完了，接下来奉上完整代码：
```cpp
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
int n;vector<string> vec;
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	while(n--){
		string s;cin>>s;
		if(s=="touch"){
			string file;cin>>file;
			auto index=find(vec.begin(),vec.end(),file);
			if(index==vec.end())
				vec.push_back(file);
		}else if(s=="rename"){
			string old_name,new_name;
			cin>>old_name>>new_name;
			auto iter=find(vec.begin(),vec.end(),old_name);
			if(iter!=vec.end())
				*iter=new_name;
		}else if(s=="rm"){
			string file;cin>>file;
			auto index=find(vec.begin(),vec.end(),file);
			if(index!=vec.end())vec.erase(index);
		}else{
			if(!vec.empty())
				for(auto i:vec)cout<<i<<endl;
		}
	}
}
```

---

## 作者：ChrisWangZi (赞：2)

# P8824 [传智杯 #3 初赛] 终端 题解

[题目传送门](https://www.luogu.com.cn/problem/P8824)

## 思路分析

模拟。

~~思来想去~~，决定使用 ``list``。

原因有一下几点：

- 链表可以实现顺序迭代访问；

- 链表可以实现删除节点。

我们要维护链表中数的顺序为插入的顺序。

### 对于 ``touch filename``:

顺序访问链表，若没有 ``filename`` 就插入一个。

```cpp
if(a=="touch"){
	string b;
	cin>>b;
	bool fou=false;
	for(it=s.begin();it!=s.end();it++){
		if(*it==b){
			fou=true;
			break;
		}
	}
	if(fou==false){
		s.push_back(b);
	}
}
```

### 对于 ``rm name``:

顺序访问链表，碰到 ``name`` 就删除。

```cpp
if(a=="rm"){
	string b;
	cin>>b;
	bool fou=false;
	for(it=s.begin();it!=s.end();it++){
		if(*it==b){
			fou=true;
			break;
		}
	}
	if(fou==true){
		s.erase(it);
	}
}
```

### 对于 ``ls``:

顺序访问链表，直接输出。

```cpp
if(a=="ls"){
	bool fou=false;
	for(it=s.begin();it!=s.end();it++){
		cout<<*it<<endl;
	}
}
```

### 对于 ``rename xxx yyy``:

顺序访问链表，碰到 ``xxx`` 就替换成 ``yyy``。

```cpp
if(a=="rename"){
	string x,y;
	cin>>x>>y;
	bool fou=false;
	for(it=s.begin();it!=s.end();it++){
		if(*it==x){
			fou=true;
			break;
		}
	}
	if(fou==true){
		*it=y;
	}
}
```

## 代码
就是以上四种情况的合并。
```cpp
#include<iostream>
#include<list>
using namespace std;
int m;
list<string> s;
list<string>::iterator it;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		string a;
		cin>>a;
		if(a=="touch"){
			string b;
			cin>>b;
			bool fou=false;
			for(it=s.begin();it!=s.end();it++){
				if(*it==b){
					fou=true;
					break;
				}
			}
			if(fou==false){
				s.push_back(b);
			}
		}
		if(a=="rm"){
			string b;
			cin>>b;
			bool fou=false;
			for(it=s.begin();it!=s.end();it++){
				if(*it==b){
					fou=true;
					break;
				}
			}
			if(fou==true){
				s.erase(it);
			}
		}
		if(a=="ls"){
			bool fou=false;
			for(it=s.begin();it!=s.end();it++){
				cout<<*it<<endl;
			}
		}
		if(a=="rename"){
			string x,y;
			cin>>x>>y;
			bool fou=false;
			for(it=s.begin();it!=s.end();it++){
				if(*it==x){
					fou=true;
					break;
				}
			}
			if(fou==true){
				*it=y;
			}
		}
	} 
	return 0;
}
```

---

## 作者：lichenzhen (赞：1)

## 题目大意
实现一个 Terminal，可以新建文件、删除文件、更改文件名、按照时间顺序列出文件。

会输入 $n$ 个操作。

## 题目解法
可以看出题目要求很简单，就是一道纯模拟题目。

$n$ 的范围也是很小，不用优化算法。

我这里用最朴素的方法，就是直接用字符串来模拟。用一个变量来存储当前的文件的数量。

这里有下面几点注意一下：

- `touch` 命令在创建文件前要扫描一遍是否有重名的文件，扫到重名就跳出并标记，没扫到再创建；
- 处理删除文件时我直接把要删除的文件名的字符串设为空实现的；
- `ls` 命令实现时要判断一下字符串是否为空，否则可能输出了删除的文件。

最后细节看代码。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p=1;
string opt,t,tt,z[1001];
bool f=0;
int main()
{
	scanf("%d",&n);
	while(n--){
		cin>>opt;
		f=0;
		if(opt=="touch"){
			cin>>t;
			for(int i=1;i<=p;i++){
				if(z[i]==t) {
					f=1;
					break;
				}
			}
			if(f==0) z[p]=t,p++;
		}
		else if(opt=="rm"){
			cin>>t;
			for(int i=1;i<=p;i++){
				if(z[i]==t) {
					z[i]="";
					break;
				}
			}
		}
		else if(opt=="ls"){
			for(int i=1;i<=p;i++){
				if(z[i]!="") cout<<z[i]<<"\n";
			}
		}
		else if(opt=="rename"){
			cin>>tt>>t; 
			for(int i=1;i<=p;i++){
				if(z[i]==tt) {
					z[i]=t;
					break;
				}
			}
		}
	}
    return 0;
} 
```


---

## 作者：Eric_jx (赞：0)

此题是一个非常水的字符串模拟题，具体 $4$ 个操作题目已经讲的很详细了，实际上对于删除操作不需要真的用数据结构来模拟删除，直接设一个 `vis` 数组表示文件是否已经被删除就行了，删除 `x` 可直接把 `vis[x]` 置为 $1$ 。输出当前存在的未被删除的所有文件时，题面说要按时间排序，实际上数组顺序存储就已经保证了这一点。

注意所有操作枚举时都要考虑当前文件是否存在(是否被删除过)，别手滑忘打了。

因为数据范围很小，所以采用 $O(n^2)$ 暴力，不会超时。


### 话不多说，上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[100001];
int vis[100001];
int main(){
	int n,cnt=0;
	cin>>n;//操作个数
	while(n--){
		string tp;cin>>tp;
		if(tp=="touch"){//创建一个新的文件
			string s;cin>>s;int flag=0;
			for(int i=1;i<=cnt;i++){//枚举是否已经存在同名文件，若存在则不进行任何操作。
				if(a[i]==s&&vis[i]==0){//前提是要未被删除，即存在
					flag=1;break;
				}
			}
			if(flag==0){//不存在同名文件
				a[++cnt]=s;
			} 
		}
		if(tp=="rename"){//修改某些文件的文件名
			string o,p;cin>>o>>p;//把名字为o的文件替换成p
			int flag=0;
			for(int i=1;i<=cnt;i++){//已经存在文件名为p的文件，则不做任何操作。
				if(a[i]==p&&vis[i]==0){
					flag=1;break;
				}
			}
			if(flag==0){
				for(int i=1;i<=cnt;i++){//枚举所有文件名为o的文件，替换为p
					if(a[i]==o&&vis[i]==0){
						a[i]=p;
					}
				}
			}
		}
		if(tp=="rm"){//删除文件名为s的文件
			string s;cin>>s;
			for(int i=1;i<=cnt;i++){
				if(a[i]==s&&vis[i]==0){
					vis[i]=1;
				}
			}
		}
		if(tp=="ls"){//按创建时间输出当前已经存在的未被删除的所有文件
			for(int i=1;i<=cnt;i++){
				if(vis[i]==0){
					cout<<a[i]<<"\n";
				}
			}
		}
	}
	return 0;养成好习惯
}
```

---

## 作者：andyli (赞：0)

建立一个 `std::vector` 按时间顺序存储文件列表。对于以下操作： 
1. `touch`，先判断文件名是否在 `std::vector` 中，若不在则添加至末尾。判断是否存在的其中一种方法是使用 `std::count`。  
2. `rm`，先判断文件名是否在 `std::vector` 中，若在则删除。可以结合使用 `std::find` 和 `erase` 函数进行删除操作。
3. `ls`，打印这个 `std::vector`
4. `rename`，遍历这个 `std::vector`，若存在名为 `xxx` 的文件，将其修改为 `yyy`。

由于题目数据范围较小，因此可以通过。

```cpp
int main() {
    dR(int, n);
    std::vector<std::string> v;
    while (n--) {
        dR(std::string, op);
        if (op == "touch") {
            dR(std::string, s);
            if (!std::count(ALL(v), s))
                v.push_back(s);
        }
        else if (op == "rm") {
            dR(std::string, s);
            if (std::count(ALL(v), s))
                v.erase(std::find(ALL(v), s));
        }
        else if (op == "ls") {
            io.displayArray(v, '\n');
        }
        else {
            dR(std::string, s, t);
            for (auto& u: v)
                if (u == s)
                    u = t;
        }
    }
    return 0;
}
```

---

## 作者：hereiszd (赞：0)

## 题意简述
实现四种字符串操作，具体请看题面。

## 题目分析
模拟题，按题意实现即可。

代码使用了 `map` 实现，具体地：

- `map<string,int>mp` 定义一个从 `string` 到 `int` 的映射，你可以理解为定义了一个支持 `mp["zd"]=1` 这么访问的数组。
- `mp.find(s1)` 寻找有没有下标为 s1 的数据，如果没有返回 `mp.end()`。
- `mp.erase(s1)` 从映射里把下标为 s1 的数据删除。
- 映射的迭代器有两部分，一部分是 `->first` 代表的是下标，`->second` 是值。
- 还需要实现一个按创建顺序排序，这里用了优先队列。

如果你知道了这些那代码一定就会很简单了。

## 代码时间

时间复杂度 $\Theta(mn \log n)$，其中 $m$ 是 `ls` 操作的次数。

```cpp

/*
	Author:zd
	Status:Accept
*/

#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
#define OK cerr<<"OK"<<endl;
int n,m,k;
map<string,int>mp;
struct node{
	int d;
	string s;
	bool operator<(const node &x)const{
		return x.d<d;//按字符串输入顺序排序 
	}
};

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		if(s=="touch"){
			string ss;
			cin>>ss;
			mp[ss]=i;//记录顺序 
		}
		if(s=="rm"){
			string ss;
			cin>>ss;
			if(mp.find(ss)!=mp.end())//找到了，删除 
			mp.erase(ss);
		}
		if(s=="rename"){
			string s1,s2;
			cin>>s1>>s2;
			if(mp.find(s1)!=mp.end()){
				mp[s2]=mp[s1];//记录顺序，注意题面是按创建时间，也就是输入顺序排序 
				mp.erase(s1);
			}
		}
		if(s=="ls"){
			priority_queue<node>q;//排序 
			for(auto it=mp.begin();it!=mp.end();it++){//遍历
				q.push(node{it->second,it->first});//找到所有未被删除的字符串 
			}
			while(!q.empty()){
				cout<<q.top().s<<endl;//输出 
				q.pop();
			}
		}
	}
	return 0;
}

//数组开大了没有 ？开不开 long long ？多测清空了吗 ？
```

---


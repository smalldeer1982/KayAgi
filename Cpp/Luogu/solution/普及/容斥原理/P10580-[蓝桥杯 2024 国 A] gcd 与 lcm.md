# [蓝桥杯 2024 国 A] gcd 与 lcm

## 题目描述

给定两个数 $x,y$，求有多少种不同的长度为 $n$ 的序列 $(a_1,a_2,\cdots,a_n)$，其所有元素的最大公约数为 $x$ 且最小公倍数为 $y$。

两个序列 $(a_1,a_2,\cdots,a_n)$ 与 $(b_1,b_2,\cdots,b_n)$ 不同，是指存在至少一个位置 $i$ 满足 $a_i\neq b_i$。

由于答案可能很大，请输出答案对 $998\ 244\ 353$ 取模后的结果。

## 说明/提示

对于 $40\%$ 的评测用例，$n\le 30$；  
对于 $70\%$ 的评测用例，$n\le 5000$；  
对于所有评测用例，$1\le Q\le 100$，$2\le n\le 10^5$，$1\le x,y\le 10^9$。

## 样例 #1

### 输入

```
3
3 6 2
12 144 3
233 251640 10```

### 输出

```
2
72
905954656```

# 题解

## 作者：HYdroKomide (赞：25)

### 题意：
给定一个数列的元素个数 $n$、最大公约数 $x$ 和最小公倍数 $y$，问有多少种不同的方法还原这个数列。

### 思路：
不难发现数列中所有元素必然为 $x$ 的倍数，它们之间产生的差异就在于 $\dfrac{y}{x}$。

设 $\dfrac{y}{x}=t$，将其分解质因数：$t=p_1^{k_1}p_2^{k_2}\cdots p_m^{k_m}$。不难发现，每个质因数对答案的贡献是独立的。不妨考虑 $p_1$ 的情况。

对于 $p_1$，要使得答案序列的最大公约数为 $x$，必定需要有至少一个元素，其 $p_1$ 质因子的指数为 $0$。同理，要使得答案序列最小公倍数为 $y$，必定需要有至少一个元素，其 $p_1$ 质因子的指数为 $k_1$。

使用容斥思想。先考虑没有限制的情况，$p_1$ 的指数可以取 $[0,k_1]$ 的所有整数，答案个数为 $(k_1+1)^n$。

接着，要减去所有被限制的情况。为了满足最大公约数的条件，至少需要有一个元素 $p_1$ 的指数为 $0$，因此需要减去所有 $p_1$ 指数在 $[1,k_1]$ 的情况。此类情况总数为 $k_1^n$。同理，需要减去所有 $p_1$ 指数在 $[0,k_1-1]$ 的情况，此类情况总数也为 $k_1^n$。

最后，注意到指数全部在 $[1,k_1-1]$ 区间的情况被减去了两次，需要加回来一次。因此在原式上加回 $(k_1-1)^n$。

因此，对于质因子 $p_1$，其贡献为 $(k_1+1)^n-2k_1^n+(k_1-1)^n$。由于不同质因子之间独立，答案为 $\prod_{i=1}^m(k_i+1)^n-2k_i^n+(k_i-1)^n$。

观察到 $m$ 最多不超过 $10$，可忽略不计。最终时间复杂度为 $O(Q\sqrt \dfrac{y}{x})$（分解质因数）。

易错点：取模运算相减后可能导致出现负数，需要在输出时对模数相加。
### 程序如下：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=35,MOD=998244353;
int q,cnt,p[N],k[N];
void getprime(int x){//分解质因数
    cnt=0;
    for(int i=2;i*i<=x;i++){
        if(x%i==0){
            k[++cnt]=0;//提前清空
            while(x%i==0){
                x/=i;
                k[cnt]++;
            }
        }
    }
    if(x!=1)k[++cnt]=1;//注意如果没分解完，说明剩下的是单独的一个质数
}
long long qpow(long long x,long long y){
    long long ret=1;
    while(y){
        if(y&1)ret=ret*x%MOD;
        y>>=1;
        x=x*x%MOD;
    }
    return ret;
}
int main(){
    scanf("%d",&q);
    while(q--){
        int x,y,n;
        long long ans=1;
        scanf("%d%d%d",&x,&y,&n);
        getprime(y/x);
        for(int i=1;i<=cnt;i++){
            long long tmp=qpow(k[i]+1,n);
            tmp=(tmp-qpow(k[i],n))%MOD;
            tmp=(tmp-qpow(k[i],n))%MOD;
            tmp=(tmp+qpow(k[i]-1,n))%MOD;
            tmp=(tmp+MOD)%MOD;
            ans=ans*tmp%MOD;
        }
        printf("%lld\n",(ans+MOD)%MOD);//注意再加一次模数，防止出负
    }
    return 0;
}
```
### THE END

---

## 作者：Enoch2013 (赞：7)

题目链接：[https://www.luogu.com.cn/problem/P10580](https://www.luogu.com.cn/problem/P10580)

---
#### 注：思路和代码参考自@览遍千秋在 10 月 7 日洛谷秋令营的课件与代码。

---
##### **这是一道数学题。**

---
# 思路
### 知识点：
>1. [快速幂](https://blog.csdn.net/xiaoxi_hahaha/article/details/134132856)；
>2. [埃氏筛](https://www.baidu.com/link?url=e32cxGE4HplfQUU3baRiG48Dl2Lm7po7iYfP5NRUp05lo2O0YSrNxmwo_23TBLFHyGy48KxS9F8z-GUMUq9pnQwmZ17IkAFjEaS2Kha_BLe&wd=&eqid=c4b18b1500f2e6d50000000667150c7c)；
>3. 唯一分解定理：
>> - 任意给定整数 $n$，可以被唯一的分解为
>>     $n = {p_1}^{c_1}{p_2}^{c_2}{p_3}^{c_3}$ $\cdots$  ${p_k}^{c_k}$；
>> - 其中 $p_i$ 为质因数，$c_i$ 为其指数。
>4. [乘法原理](https://www.baidu.com/link?url=FhBz_kLF9xBr_hSzbT2licKaFxxsXWdkx2xFCdoAOuiWcVc8I-qL2RQ1grR3w1e4R_FUI3a1FURkpcmWHML2NPgO2WbcPH8_7jkH91qHceB3460Tcl_sUhDTVFnUrnOE&wd=&eqid=894d55a300e858800000000667150fa7)；
>5. [容斥原理](https://www.baidu.com/link?url=K3Q5p748tATjLtfvg84BRRMuueUF5DC7zWdkVTcaXv3TSsy07lXwtqeexl_df_Pc5IfoHGpPc8ttj5e7gbrrrJxqJw5wmibxK7iO9PZB_cYAwfjr88xXJN10mecG8_Ju&wd=&eqid=f6835b1b00f2b068000000066715109c)。
---
> - $\rm{gcd}(a_1,a_2,\cdots,a_n) = x$，$\rm{lcm}(a_1,a_2,\cdots,a_n) = y$；
> - 我们将每个 $a_i$ 除以 $x$，将其变成 $\rm{gcd}$ 为 $1$，$\rm{lcm}$ 为 $\frac {y}{x}$；
> - 对于 $1 ≤ i ≤ n$，$ai$ 在质因数 $p_j$ 的指数上可以取 $0$ 至 $c_j$；
> - 根据乘法原理，$p_j$ 对答案的贡献为 $(c_j + 1)^n$；
> - 但是，我们要排除两个非法值：
>> - 若对于所有的 $1 ≤ i ≤ n$，指数均不为 $0$；
>> - 若对于所有的 $1 ≤ i ≤ n$，指数均不为 $c_j$。
> - 根据容斥原理，考虑其重复情况，$p_j$ 对答案的贡献为：${f(j)} = (c_j + 1)^n - 2 × {c_j}^n + (c_j - 1)^n$，最后再求 $f(j)$ 的积就可以了！这里就用到快速幂了。

---
现在思路讲完了，接下来出现的是你们最期待的代码了！！！

---
## code:

```cpp
// 2024.10.20 20:48
#include <bits/stdc++.h>
#define int long long
#define N 100010
using namespace std;
const int MOD = 998244353;
int q, x, y, n;
bool prime[N];
// 埃氏筛，预处理
void ai_shai()
{
    for (int i = 2; i <= 100000; i++)
    {
        if (prime[i])
            continue;
        for (int j = 2 * i; j <= 100000; j += i)
            prime[j] = true;
    }
}
// 快速幂，作用见上文
int q_pow(int x, int p)
{
    int res = 1;
    while (p)
    {
        if (p & 1)
            res = res * x % MOD;
        p >>= 1;
        x = x * x % MOD;
    }
    return res;
}
signed main()
{
    ai_shai();
    cin >> q;
    while (q--)
    {
        cin >> x >> y >> n;
        y /= x;
        int limit = y;
        vector<int> v;
        // 唯一分解定理
        for (int i = 2; i * i <= limit; i++)
        {
            if (prime[i])
                continue;
            int cnt = 0;
            while (y % i == 0)
            {
                cnt++;
                y /= i;
            }
            if (cnt != 0)
                v.push_back(cnt);
        }
        if (y > 1)
            v.push_back(1);
        int ans = 1;
        for (auto ci : v)
        {
            int tmp = ((q_pow(ci + 1, n) - 2 * q_pow(ci, n)) % MOD + q_pow(ci - 1, n)) % MOD;
            tmp = (tmp + MOD) % MOD;
            ans = ans * tmp % MOD;
        }
        cout << ans << endl;
    }
    return 0;
}
// 完结散花！！！
```

---

## 作者：yezicong1104 (赞：6)

## 思路
由题得：
$$\begin{cases}\gcd(a_1,a_2,\cdots,a_n)=x \\ \operatorname{lcm}(a_1,a_2,\cdots,a_n) = y\end{cases}$$
设 $b_i=\frac{a_i}{x}$，易证：
$$\begin{cases}\gcd(b_1,b_2,\cdots,b_n)=1 \\ \operatorname{lcm}(b_1,b_2,\cdots,b_n) = \frac{y}{x}\end{cases}$$
令 $t=\frac{y}{x}$，将其分解质因数：$t=\prod_{i=1}^m p_i^{d_i}$，对于每个 $p_i$，可以如下思考：

首先，对于 $b$ 中的每一个数，它 $p_i$ 的指数 $c$ 的范围是：$0 \le c \le d_i$，有 $d_i+1$ 种情况，所以一共有 $(d_i+1)^n$ 种情况。

为了使 $\gcd(b_1,b_2,\cdots,b_n)=1$，至少有一个 $p_i$ 的指数等于 $0$，同理，为了使 $\operatorname{lcm}(b_1,b_2,\cdots,b_n) = t$，至少有一个 $p_i$ 的指数等于 $d_i$，也就是说上面的 $(d_i+1)^n$ 种情况还要减去 $p_i$ 的指数都不为 $0$ 或都不为 $d_i$ 的情况数。$p_i$ 的指数都不为 $0$ 的情况数有 $d_i^n$ 种，$p_i$ 的指数都不为 $d_i$ 的情况数也是有 $d_i^n$ 种，一共是 $2d_i^n$ 种。但这把 $p_i$ 的指数都既不为 $0$ 也不为 $d_i$ 的情况数重复算了两遍，所以还要减去一个 $(d_i-1)^n$，即 $p_i$ 的指数都既不为 $0$ 也不为 $d_i$ 的情况数。所以一共要减去 $2d_i^n-(d_i-1)^n$ 种情况。

综上所述，对于每个 $p_i$ 有 $(d_i+1)^n-2d_i^n+(d_i-1)^n$ 种情况。根据乘法原理，答案为：
$$\prod_{i=1}^m (d_i+1)^n-2d_i^n+(d_i-1)^n$$

时间复杂度：$O(Q (\sqrt{\frac{x}{y}}+m))$，易证 $m\le 9$，可以通过。
## AC Code

```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long LL;
const int mod = 998244353;

LL f(LL a, int b) { //快速幂
	LL res = 1;
	while (b) {
		if (b & 1) res = (res * a) % mod;
		b >>= 1, a = a * a % mod;
	} return res;
}

int main() {
	int Q;
	scanf("%d", &Q);
	vector<int> v; //存储质因数的指数
	while (Q--) {
		int x, y, n, p = 2;
		scanf("%d%d%d", &x, &y, &n);
		int t = y / x; LL pro = 1;
		v.clear(); //初始化
		while (p * p <= t) {
			if (t % p == 0) {v.push_back(0); while (t % p == 0) t /= p, v.back()++; }
			else p++;
		} if (t != 1) v.push_back(1); //剩下的是一个质数
		for (int i : v) pro = pro * (f(i + 1, n) - f(i, n) * 2 + f(i - 1, n)) % mod; //计算答案
		printf("%lld\n", (pro + mod) % mod); //加上 mod 避免负数
	}
	return 0;
}
```

---

## 作者：鱼跃于渊 (赞：5)

## 解法

一道简单容斥，但为什么我想不出来呢？  
首先可以发现，$a_i$ 合法仅当 $x\mid a_i,a_i \mid y$。  
所以显然当 $x\nmid y$ 时无解，考虑令 $y\gets \dfrac{y}{x},x\gets 1$，可以想到将 $y$ 分解质因数 $y=\prod_{k}p_k^{c_k}$。  
每个质因数的贡献是独立的，可以分开来考虑。  
所以对于一个质因数 $p$，问题转化为：每个数为 $p^{0\sim c}$ 中的一个，求满足某种限制的方案数。  
思考这个限制：由于 $\gcd(a_1,a_2\ldots a_n)=x$，至少有一个数为 $p^0$；而由于 $\operatorname{lcm}(a_1,a_2,\ldots a_n)=y$，至少有一个数为 $p^c$。  
也就是求钦定选择一个 $p^0$ 和一个 $p^c$ 后的方案数。  
不好直接求，考虑容斥。  
先求出没有任何限制的方案数，减去没有选择 $p^0$ 或 $p^c$ 的方案数，再加上没有选择 $p^0$ 和 $p^c$ 的方案数，即为答案。  
答案为 $\prod_{k}((c_k+1)^n-2c_k^n+(c_k-1)^n)$。  

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace fisher{
#define int long long
#define per(i,a,b) for(int i=(a);i<=(b);i++)
#define rep(i,b,a) for(int i=(b);i>=(a);i--)
const int N=55,mod=998244353;
int T,n,x,y;
int tot,tub[N];
int gmod(int x){
    return x<-mod?x%mod+mod:(x<0?x+mod:(x<mod?x:(x<(mod<<1)?x-mod:x%mod)));
}
int qpow(int a,int b){
    int res=1;
    for(;b;b>>=1,a=gmod(a*a))
        if(b&1) res=gmod(res*a);
    return res;
}
void fj(int x){
    tot=0;
    for(int i=2;i*i<=x;i++) if(x%i==0){
        tub[++tot]=0;
        for(;x%i==0;x/=i) tub[tot]++;
    }
    if(x>1) tub[++tot]=1;
}
int solve(){
    fj(y/x);
    int res=1,sum;
    per(i,1,tot){
        sum=gmod(qpow(tub[i]+1,n)-2*qpow(tub[i],n)+qpow(tub[i]-1,n));
        res=gmod(res*sum);
    }
    return res;
}
void main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>T;
    while(T--){
        cin>>x>>y>>n;
        cout<<solve()<<'\n';
    }
}}
signed main(){
    fisher::main();
    return 0;
}
```

---

## 作者：Starrykiller (赞：5)

> 选自数学部分做题记录 **LXXXI**。


每个素因子是独立的，可以分开考虑。**以下均基于素因子 $p$ 讨论**。

设 $\gcd$ 中，$p$ 的指数为 $a$；$\mathrm{lcm}$ 中，$p$ 的指数为 $b$。

题目保证了有解，所以 $a\le b$。

当 $a\lt b$ 时，序列中，至少一个位置指数为 $a$，至少一个位置指数为 $b$。

正着做不好做，考虑容斥。拿全部方案，减去钦定没有 $a$ 或没有 $b$ 的方案，加上钦定两个都没有的方案即可。

$a=b$ 是平凡的。

时间复杂度为 $\Theta(Q\sqrt V)$，其中 $\sqrt V$ 花费在分解素因子上。

---

## 作者：zdd0342 (赞：5)

# [蓝桥杯 2024 国 A] gcd 与 lcm

模拟赛 T1，被各位大神爆切。

或许是其他方法？好像不是。

## Description

给定两个数 $x,y$，求有多少种不同的长度为 $n$ 的序列 $a$，使得所有元素的最大公因数为 $x$，最小公倍数为 $y$。

$T$ 组测试点。

$1\le T\le 100,2\le n\le 10^5,1\le x,y\le 10^9$。

## Solution

首先发现我们不关注每一个 $a_i$ 是多少，所以答案只跟 $\frac{y}{x}$ 是多少有关。

设 $x$ 的答案为 $f(x)$。

唯一分解定理，$x=p_1^{k_1}\times p_2^{k_2}\times \cdots\times p_m^{k_m}$。

设因数个数函数为 $p(x)$，$p(x)=\prod\limits_{i=1}^{m}(k_i+1)$。

首先，$x\leftarrow 1$，$y\leftarrow \frac{y}{x}$，方便讨论。所有的 $a$ 只有可能在 $y$ 的因数中选取。 

每一个因数互不影响，说明 $f(x)$ 是一个 **完全积性函数**。

只需要考虑 $f(x^k)$ 的值就可以了。其中 $x$ 是质数。

将每一种可能写下来，得到等式：

$$\sum\limits_{i=0}^{k}(k-i+1)f(x^i)=p(x^k)^n$$

由于 $x$ 是质数，所以 $p(x^k)^n=(k+1)^n$。

写出一个式子

$$\sum\limits_{i=0}^{k-1}(k-i)f(x^i)=k^n$$

再写出一个式子

$$\sum\limits_{i=0}^{k}(k-i+1)f(x^i)=p(x^k)^n$$

---

两式相减，得

$$\sum\limits_{i=0}^{k}f(x^i)=(k+1)^n-k^n$$

如法炮制，再写出一个

$$\sum\limits_{i=0}^{k-1}f(x^i)=k^n-(k-1)^n$$

再次相减，得

$$f(x^k)=(k+1)^n+(k-1)^n-2\times k^n$$

最后也能够推出其他题解的式子。

因为是积性函数，所以最后直接将每一个质因数分解，再相乘就得到答案。

设值域为 $T$，时间复杂度为 $O(\sqrt{T}+Q(\frac{\sqrt{T}}{\ln\sqrt{T}})\log n)$，能够通过。



## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=31626,N=31625;
const int mod=998244353;
int pri[MAXN],tot;
bool ispri[MAXN];
inline void init(){
	ispri[1]=1;
	for(int i=2;i<=N;i++){
		if(!ispri[i])pri[++tot]=i;
		for(int j=1;j<=tot&&i*pri[j]<=N;j++){
			ispri[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
}
int n,x,y;
inline int ksm(int a,int b){int cnt=1;while(b){if(b&1)cnt=cnt*a%mod;a=a*a%mod;b>>=1;}return cnt;}
inline int f(int k){
	return (ksm(k+1,n)+ksm(k-1,n)+(mod-ksm(k,n))*2)%mod;
}
inline void solve(){
	cin>>x>>y>>n;
	int del=y/x;int now=del;
	int ans=1;
	for(int i=1;i<=tot&&pri[i]*pri[i]<=del;i++){
		if(now%pri[i])continue;
		int cnt=0;
		while(now%pri[i]==0){
			cnt++;now/=pri[i];
		}
		ans=ans*f(cnt)%mod;
	}
	if(now!=1)ans=ans*f(1)%mod;
	cout<<ans<<"\n";
}
signed main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	init();
	int T;cin>>T;while(T--)solve(); 
}

```

---

## 作者：naroto2022 (赞：4)

# P10580 题解

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P10580)

### 前置知识

容斥原理

(1) 集合 $S$ 中不具有性质 $P_1,P_2,\cdots,P_n$ 的对象个数为 

$\begin{aligned}|\overline{A_1}\cap\overline{A_2}\cap\cdots\cap\overline{A_n}|&=|S|-\sum_{i=1}^n|A_i|+\sum_{i=1}^n\sum_{j>i}|A_i\cap A_j|-\sum_{i=1}^n\sum_{j>i}\sum_{k>j}|A_i\cap A_j\cap A_k|\\&+\cdots+(-1)^{n-1}|A_1\cap A_2\cap \cdots\cap A_n|\end{aligned}$

简记（我的方法）：奇减偶加

(2) 集合 $S$ 中至少具有性质 $P_1,P_2,\cdots,P_n$ 之一的对象个数为

$\begin{aligned}|A_1\cup A_2\cup\cdots\cup A_n|&=\sum_{i=1}^n|A_i|-\sum_{i=1}^n\sum_{j>i}|A_i\cap A_j|+\sum_{i=1}^n\sum_{j>i}\sum_{k>j}|A_i\cap A_j\cap A_k|+\cdots\\&+(-1)^{n-1}|A_1\cap A_2\cap \cdots\cap A_n|\end{aligned}$

简记：奇加偶减

### 思路

首先，显然 $a$ 肯定都是 $x$ 的倍数，问题就是在 $\frac{y}{x}$ 上。

我们可以将 $\frac{y}{x}$ 质因数后一个个考虑，设 $\begin{aligned}\frac{y}{x}=\sum_{i=1}p_i^{e_i}\end{aligned}$，对于每一个质数分开去考虑，最后把答案乘起来（乘法原理），不妨把最小公倍数是 $x$ 和最大公倍数是 $y$ 看做两个条件，然后去容斥。

对于一个质数 $p_i$ 我们有。

发现算最大公因数是 $x$，最小公倍数是 $y$ 的方案数是比较困难的，所以我们不妨把题目转化为集合 $S$ 中不具有性质 $P_1,P_2$ 的对象个数有多少，其中：

- $P_1$ 为最大公约数不为 $x$。
- $P_2$ 为最小公倍数不为 $y$。

于是有。

- 没有 $P_1,P_2$ 的限制，我们可以取到 $[0,e_i]$，所以 $|S|=(e_i+1)^n$ 。
- 只有 $P_1$ 的限制，我们可以取到 $[1,e_i]$（取到 $0$ 最大公因数就是 $x$ 了），所以 $|A_1|=e_i^n$。
- 只有 $P_2$ 的限制，我们可以取到 $[0,e_i-1]$（取到 $e_i$ 最小公倍数就是 $y$ 了），所以 $|A_2|=e_i^n$。
- 对于有 $P_1,P_2$ 的限制，我们只能取到 $[1,e_i-1]$，所以 $|A_1\cap A_2|=(e_i-1)^n$。

故，一个质数的方案数为 $|S|-|A_1|-|A_2|+|A_1\cap A_2|=(e_i+1)^n-2\times e_i^n+(e_i-1)^n$。

最后把每个质数的方案数乘起来即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int mod=998244353;
ll x,y,n,t,ans;
void write(ll n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
ll ksm(ll a, ll b){ll res=1;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}
void solve(){
    x=read();y=read();n=read();t=y/x;ans=1;
    for(int i=2; i<=sqrt(t); i++) if(t%i==0){
        ll num=0;
        while(t%i==0) t/=i,num++;
        ans=ans*((ksm(num+1,n)-(2*ksm(num,n)%mod)+ksm(num-1,n))%mod+mod)%mod;
    }
    if(t>1){ans=ans*((ksm(2,n)-2)%mod+mod)%mod;}
    write(ans);putchar('\n');
}
int main(){
    ll T=read();while(T--)solve();
    return 0;
}
```

---

## 作者：Rain_chr (赞：3)

来一发莫比乌斯反演做法，纯纯高射炮打蚊子了，但是我考场上还真只想到了莫比乌斯反演，而且过题速度比容斥快得多。

首先我们可以把 $y\gets \frac{y}{x}$，这样就只用考虑序列最大公约数为 1 的情况了。

设 $f(x)$ 为序列最大公约数是 $x$ 倍数的方案数，$g(x)$ 为最大公约数恰好为 $x$ 的方案数，显然有：

$$f(x)=\sum_{x|d} g(d)$$

根据莫比乌斯反演，我们可得

$$g(x)=\sum_{x|d} f(d) \mu(\frac{d}{x})$$

我们现在要求的是 $g(1)$，代入得到：

$$g(1)=\sum_{d} f(d) \mu(d)$$

现在是时候来看一眼 $f(x)$ 该怎么求了。

如果 $x \nmid y$，那么显而易见 $f(x)=0$，所以只用枚举 $y$ 的因数，然后将 $y\gets \frac{y}{x}$。

这个时候我们可以对于每一个质因数分开考虑，设 $y=\prod_{i=1}^k p_i^{a_i}$，那么对于每一个质因数序列中至少有一个位置能够取到指数上界，容斥一下可得方案数为 $(a_i+1)^n-a_i^n$，即任选方案数减去不选指数上界的方案数。

那么 $f(x)=\prod_{i=1}^k ((a_i+1)^n-a_i^n)$

回顾原式：

$$g(1)=\sum_{d|y} f(d) \mu(d)$$

因为莫比乌斯函数只在没有平方因子的时候不为 0，所以真正有值的 $x$ 都是通过枚举 $y$ 的每个质因子选或不选得到的。

于是我们可以爆搜值因子选或不选来计算，总复杂度 $O(T2^{w(V)})$，其中 $w(v)$ 表示值域范围内质因子最多的数质因子个数。


```cpp
#include<bits/stdc++.h>
using namespace std;
bool book[40010];
vector<int> p;
void init()
{
	for(int i=2;i<=4e4;i++)
	{
		if(!book[i]) p.push_back(i);
		for(int j=0;j<p.size()&&i*p[j]<=4e4;j++)
		{
			book[i*p[j]]=1;
			if(i%p[j]==0) break;
		}
	}
}
const int mod=998244353;
int ksm(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return ans;
}
int Pow[40];
int n,x,y;
vector<int> a;
int ans;
void dfs(int x,int now,int c)
{
	if(x==a.size())
	{
		if(c==1) ans=(ans+now)%mod;
		else ans=(ans-now+mod)%mod;
		return ;
	}
	dfs(x+1,1ll*now*(Pow[a[x]]-Pow[a[x]-1]+mod)%mod,-c);
	dfs(x+1,1ll*now*(Pow[a[x]+1]-Pow[a[x]]+mod)%mod,c);
}
void run()
{
	cin>>x>>y>>n;
	for(int i=0;i<=30;i++) Pow[i]=ksm(i,n);
	if(y%x)
	{
		cout<<"0\n";
		return ;
	}
	y/=x;
	a.clear(),ans=0;
	for(int i=0;i<p.size()&&p[i]*p[i]<=y;i++)
	{
		if(y%p[i]) continue;
		int cnt=0;
		while(y%p[i]==0) cnt++,y/=p[i];
		a.push_back(cnt);
	}
	if(y>1) a.push_back(1);
	dfs(0,1,1);
	cout<<ans<<'\n';
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	init();
	int t;
	cin>>t;
	while(t--) run();
    return 0;
}
```

---

## 作者：RainySoul (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10580)

首先因为这个序列中的数的最大公约数为 $x$，我们可以知道出现的数一定都是 $x$ 的倍数。

其次最小公倍数为 $y$，可以知道出现的数一定都是 $y$ 的约数。

那么实际上可供选择的数就共有 $\frac{y}{x}$ 个，记 $\frac{y}{x}$ 为 $t$，于是现在问题变成了：

在 $\{1,2,3,\cdots,t\}$ 这 $t$ 个整数中任选 $n$ 个（每个数可以选任意次），使它们的最大公约数为 $1$，最小公倍数为 $t$。记选出来的是 $n$ 个整数是 $\{a_1,a_2,a_3, \cdots,a_n\}$。

我们把 $t$ 进行唯一的质因数分解。

$$t=\prod_{i=1}^{m}p_i^{k_i}$$

其中 $p_i$ 是 $t$ 的质因数。

思考：如果我要拼出一个 $t$ 来，**必须要有一个 $a$ 分解后 $p_i$ 这一项的次数为 $k_i$**。而我要拼出一个 $1$ 来，**必须要有一个 $a$ 分解后 $p_i$ 这一项的次数为 $0$**。

由此可以发现每一个 $p_i$ 对答案的贡献是可以分开算的。

直接计算不好算，容斥一下，用总情况数减去不合法情况数。

总情况数是这 $n$ 个位置每个位置可以任意放 $[0,k_i]$：$(k_i+1)^{n}$。

不合法情况是这 $n$ 个位置全都未选 $1$ 或者全都未选 $k_i$，减去 $[0,k_i-1]$ 和 $[1,k_i]$ 两部分：$k_i^{n} \times 2$。

发现 $[1,k_i-1]$ 被多减了一次，还要加上它：$(k_i-1)^{n}$。

因此单个质因数的贡献是：

$$(k_i+1)^{n}-k_i^{n} \times 2+(k_i-1)^{n}$$

暴力分解质因数，每一个单独算一下，再将每个的贡献相乘就做完了。

注意取模细节有点多，可能会减成负数。

AC code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int Q,x,y,n;
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
inline int quickpow(int a,int b){
	int res=1;
	while(b>0){
		if(b%2==0)(a*=a)%=mod,b/=2;
		else (res*=a)%=mod,b--;
	}
	return res%mod;
}
signed main(){
	Q=read();
	while(Q--){
		x=read(),y=read(),n=read();
		int t=y/x,ans=1;
		for(int i=2;i<=t;i++){
			int k=0,temp=0;
			while(t%i==0&&t>0)k++,t/=i; 
			if(k!=0){
				(temp=quickpow(k+1,n)-quickpow(k,n)*2+quickpow(k-1,n)+mod)%=mod;
				(ans*=temp)%=mod;
			}
		}
		cout<<(ans+mod)%mod<<'\n';
	}	
	return 0;
}
```

---

## 作者：ran_qwq (赞：1)

首先特判 $x\nmid y$，输出 $0$。

设 $x=\prod\limits_{i=1}^{k1}p1_i^{c1_i}$，$y=\prod\limits_{i=1}^{k2}p2_i^{c2_i}$（其中 $k1\le k2$，$\forall i\in[1,k1],p1_i=p2_i$）。问题等价于满足以下条件的对非负整数矩阵 $C$ 计数：

1. $C$ 行数为 $k2$，列数为 $n$。
2. $\forall i\in[1,k1],\forall j\in[1,n]$，$C_{i,j}\ge c1_i$。
3. $\forall i\in[1,k2],\forall j\in[1,n]$，$C_{i,j}\le c2_i$。
4. $\forall i\in[1,k1],\exists j\in[1,n]$，$C_{i,j}=c1_i$。
5. $\forall i\in[1,k2],\exists j\in[1,n]$，$C_{i,j}=c2_i$。

其中 $a_i=\prod\limits_{j=1}^{k2}p2_j^{C_{j,i}}$。

我们发现既然 $x\mid y$ 了，又有 $x$ 又有 $y$ 很蠢，令 $y\rightarrow \dfrac yx$，相应更新 $c2$。

矩阵的条件变为：

1. $C$ 行数为 $k2$，列数为 $n$。
3. $\forall i\in[1,k2],\forall j\in[1,n]$，$C_{i,j}\in[0,c2_i]$。
4. $\forall i\in[1,k2],\exists j\in[1,n]$，$C_{i,j}=0$。
5. $\forall i\in[1,k2],\exists j\in[1,n]$，$C_{i,j}=c2_i$。

对于每个 $i$ 是独立的，我们分开来求。第 $i$ 行要有一个 $C_{i,j}=0$，有一个 $C_{i,j}=c2_i$。考虑容斥，所有方案数减去都 $>0$ 方案数，减去都 $<c2_i$ 方案数，加上都 $>0$ 且都 $<c2_i$ 方案数。

故第 $i$ 行答案为 $(c2_i+1)^n-2\cdot c2_i^n+(c2_i-1)^n$。

将所有行答案乘起来就是总的方案数。

```cpp
int len,b[N];
int MR(int x) {
	if(x==2) return 1; if(x<2||x%2==0) return 0;
	int c=0,y=x-1; while(y%2==0) y/=2,c++;
	for(int i=0;i<10;i++) {
		int p=qpowm(rand()%(x-1)+1,y,x),q=0;
		for(int j=0;j<c;j++) {q=1ll*p*p%x; if(q==1&&p!=1&&p!=x-1) return 0; p=q;}
		if(q!=1) return 0;
	}
	return 1;
}
int PR(int x,int y) {
	int p=rand()%(x-1)+1,q=p;
	for(int i=2,j=2;;i++) {
		p=(1ll*p*p%x+y)%x; int d=__gcd((q-p+x)%x,x);
		if(d>1&&d<x) return d; if(p==q) return x; if(i==j) q=p,j*=2;
	}
	return -1;
}
void fd(int x,int y) {
	if(x==1) return; if(MR(x)) return b[++len]=x,void();
	int p=x,z=y; while(p>=x) p=PR(p,y--); fd(p,z),fd(x/p,z);
}
void QwQ() {
	int x=rd(),y=rd(),n=rd(),ans=1; if(y%x) return puts("0"),void(); y/=x;
	len=0,fd(y,120); map<int,int> mp; for(int i=1;i<=len;i++) mp[b[i]]++;
	for(pii P:mp) cmul(ans,vadd(vsub(qpow(P.sec+1,n),vmul(2,qpow(P.sec,n))),qpow(P.sec-1,n)));
	wr(ans,"\n");
}
```

---

## 作者：Hisy (赞：1)

## 前言
化简式子后感觉非常像莫比乌斯反演，很像[这道题目](https://www.luogu.com.cn/problem/P2231)化简后的公式，看了题解才知道是容斥……
## 分析
题目要求求出：
$$\sum_{a_i=x}^{y}[\gcd(a_i)=x][\operatorname{lcm}(a_i)=y]$$

不难发现，每一个数必须在 $x$ 到 $y$ 之间，每一个数可以表示为 $t\times\frac{y}{x}(t\le x)$。不同的就是这一个 $t$。

设 $t=\frac{y}{x}$，并且设 $t=\Pi_{i=1}^{k}p_i^{c_i}(p_i\in Prime)$，那么可以证明，要求 $\gcd$ 为 $x$，那么至少要有一个数，其 $c_i$ 为 $0$。要求 $\operatorname{lcm}$ 为 $y$，那么至少要有一个数，其 $c_i$ 为 $c_i$。答案为 $(c_i+1)^n$。

那么，发现是至少，因此要减去所有 $c_i$ 为 $[1,c_i]$ 的情况，$c_i$ 为 $[0,c_i-1]$ 的情况同理，要减一次。

再发现 $[1,c_i-1]$ 被减了两次，那么加回来，得答案为 $(c_i+1)^n-2\times(c_i)^n+(c_i-1)^n$。之后对于 $p_i$ 不同考虑乘起来即可。
## 代码
```cpp
#include<bits/stdc++.h>
#define MAXN 350000
#define MOD 998244353
using namespace std;
typedef long long ll;
int n,x,y,top,p[MAXN],c[MAXN];
bool flag[MAXN];
vector<int> prim;
inline void prework(){
	flag[1]=true;
	for(int i=2;i<MAXN;++i){
		if(!flag[i]){
			prim.push_back(i);
		}
		for(int j=0;j<prim.size()&&i*prim[j]<MAXN;++j){
			flag[i*prim[j]]=true;
			if(i%prim[j]==0){
				break;
			}
		}
	} 
}
inline bool check(int x){
	if(x<=1){
		return false;
	}
	for(int i=2;i*i<=x;++i){
		if(x%i==0){
			return false;
		}
	}
	return true;
}
inline ll power(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1){
			(res*=x)%=MOD;
		}
		(x*=x)%=MOD;
		y>>=1;
	}
	return res;
}
inline void split(int x){
	top=0;
	for(int i=0;i<prim.size()&&x!=1;++i){
		if(x%prim[i]==0){
			p[++top]=prim[i];
			c[top]=0;
			while(x%prim[i]==0){
				x/=prim[i];
				++c[top];
			}
		}
	}
	if(check(x)){
		p[++top]=x;
		c[top]=1;
	}
}
int main(){
	prework();
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d %d %d",&x,&y,&n);
		int t=y/x;
		split(t);
		ll ans=1;
		for(int i=1;i<=top;++i){
			ll a=power(c[i]+1,n);
			ll b=power(c[i],n);
			ll d=power(c[i]-1,n);
			(ans*=((a-2ll*b+d)%MOD+MOD)%MOD)%=MOD;
		}
		printf("%lld\n",ans);
	} 
	return 0;
}
```

---

## 作者：bluewindde (赞：1)

由 $\gcd$ 和 $\operatorname{lcm}$ 的定义，容易知道每个 $a_i$ 必定既是 $x$ 的倍数，又是 $y$ 的约数。

首先，如果 $x \nmid y$，则不存在 $a$。

设 $\frac y x$ 的标准分解 $\frac y x = p_1^{c_1} \cdots p_m^{c_m}$，$a_i$ 可以从这些质因子里构造得到，容易发现不同质因子的方案之间互不干扰，可以直接乘起来，接下来考虑单个质因子。

设当前考虑质数 $p$，数列 $a$ 的数量等价于满足 $0 \leqslant b_i \leqslant c$，存在 $b_i = 0$ 和 $b_i = c$ 的数列 $b_i$ 的数量。

数列 $b_i$ 的数量可以 DP 求得。具体而言，设 $dp_{i, 0 / 1, 0 / 1}$ 表示已经填了前 $i$ 个位置，是否存在 $b_i = 0$ 和 $b_i = c$ 的方案数，转移显然为

$$dp_{i, 0, 0} = (c - 1) \cdot dp_{i - 1, 0, 0}$$

$$dp_{i, 0, 1} = c \cdot dp_{i - 1, 0, 1} + dp_{i - 1, 0, 0}$$

$$dp_{i, 1, 0} = c \cdot dp_{i - 1, 1, 0} + dp_{i - 1, 0, 0}$$

$$dp_{i, 1, 0} = (c + 1) \cdot dp_{i - 1, 1, 1} + dp_{i - 1, 0, 1} + dp_{i - 1, 1, 0}$$

发现 DP 只与 $c$ 的值有关，因为 $c$ 不超过 $30$（$2^{30} > 10^9$），考虑预处理所有的 DP 结果，$O(\Omega(w))$ 回答询问，时间复杂度 $O(n \log w + q \Omega(w))$，$w$ 是值域，$\Omega$ 是质因子指数和函数（一般小于 $\lg$）。

~~怎么抢到最劣解了，因为这个 $\log$ 是跑满的 qwq。~~

赛时代码，写太急了，可能比较丑。

```cpp
#include <iostream>
#include <string.h>

#define int long long

using namespace std;

const int lim = 4e4;
const int nlim = 1e5;
const int mod = 998244353;

bool vis[lim + 5];
int pr[lim + 5], tail;

int n, x, y;

int dp[32][100005][2][2];

static inline int solve(int cnt) {
    return dp[cnt][n][1][1];
}

static inline void solve() {
    cin >> n >> x >> y;
    if (y % x) {
        cout << 0 << endl;
        return;
    }
    int z = y / x;
    int ans = 1;
    for (int i = 1; i <= tail; ++i) {
        int cnt = 0;
        while (z % pr[i] == 0) {
            z /= pr[i];
            ++cnt;
        }
        if (!cnt)
            continue;
        ans = ans * solve(cnt) % mod;
    }
    if (z > 1)
        ans = ans * solve(1) % mod;
    cout << ans << endl;
}

signed main() {
    freopen("totoro.in", "r", stdin);
    freopen("totoro.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    for (int i = 2; i <= lim; ++i) {
        if (!vis[i])
            pr[++tail] = i;
        for (int j = 1; j <= tail && i * pr[j] <= lim; ++j) {
            vis[i * pr[j]] = true;
            if (i % pr[j] == 0)
                break;
        }
    }
    for (int cnt = 1; cnt <= 30; ++cnt) {
        dp[cnt][0][0][0] = 1;
        for (int i = 1; i <= nlim; ++i) {
            dp[cnt][i][0][0] = dp[cnt][i - 1][0][0] * (cnt - 1) % mod;
            dp[cnt][i][0][1] = (dp[cnt][i - 1][0][1] * cnt + dp[cnt][i - 1][0][0]) % mod;
            dp[cnt][i][1][0] = (dp[cnt][i - 1][1][0] * cnt + dp[cnt][i - 1][0][0]) % mod;
            dp[cnt][i][1][1] = (dp[cnt][i - 1][1][1] * (cnt + 1) + dp[cnt][i - 1][0][1] + dp[cnt][i - 1][1][0]) % mod;
        }
    }
    int T;
    cin >> T;
    while (T--)
        solve();
    return 0;
}
```

---

## 作者：ridewind2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10580)

## 分析
给定一个数列的最大公约数 $x$、最小公倍数 $y$ 和序列 $a$ 的元素个数 $n$，问有多少种不同的方法还原这个数列。

不难发现数列中所有元素必然为 $x$ 的倍数，$y$ 的因数，它们之间产生的差异就在于 $\frac{y}{x}$。


我们需要用到快速幂、分解质因数、乘法原理和容斥原理。

1. 快速幂，可以快速求出 $a_{}^{b}$ 的值：

```cpp
const int p=998244353;
long long qm(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1)ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
```

2. 用唯一分解定理分解质因数，分解 $y \div x$：

```cpp
for(int i=2;i<=x/i;i++){
    if(x%i==0){
        c[++cnt]=0;
        while(x%i==0){
             c[cnt]++;
             x/=i;
        }
     }
}
if(x>1)c[++cnt]=1;
```
3. 乘法原理和容斥原理，第 $i$ 个的贡献是$((c_{i}+1)_{}^{n}-2 \times c_{i}^{n})+(c_{i}-1)_{}^{n}$，$c_{i}$表示 $y \div x$ 的第 $i$ 的质因数出现的次数，记得对 $p$ 取模，将所有的贡献相乘，就是答案：

```cpp
int k=((qm(c[i]+1,n)-2*qm(c[i],n))%p+qm(c[i]-1,n))%p;
k=(k+p)%p;
ans=ans*k%p;
```
易错点：取模运算相减后可能导致出现负数，需要在输出时对模数相加。

## AC Code


```cpp
#include<bits/stdc++.h>
using namespace std;
const int p=998244353;
int c[1000];
long long qm(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1)ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
int main(){
    int q;
    cin>>q;
    while(q--){
        int x,y,n;
        cin>>x>>y>>n;
        long long ans=1;
        int cnt=0;
        x=y/x;
        for(int i=2;i<=x/i;i++){
            if(x%i==0){
                c[++cnt]=0;
                while(x%i==0){
                    c[cnt]++;
                    x/=i;
                }
            }
        }
        if(x>1)c[++cnt]=1;
        for(int i=1;i<=cnt;i++){
            int k=((qm(c[i]+1,n)-2*qm(c[i],n))%p+qm(c[i]-1,n))%p;
            k=(k+p)%p;
            ans=ans*k%p;
        }
        cout<<ans<<"\n";
    }
    return 0;
}
```

---

## 作者：wjl1100 (赞：0)

## [原题传送门](https://www.luogu.com.cn/problem/P10580)

## 思路

### 前置知识：

#### [快速幂](https://oi-wiki.org/math/binary-exponentiation/)

#### [唯一分解定理](https://baike.baidu.com/item/%E6%83%9F%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/22770222)

#### [容斥原理](https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86?fromModule=lemma_search-box)

我们可以先将每个数除以 $x$，这样我们就可以得到一个最大公约数为 $1$，最小公倍数为 $\dfrac{y}{x}$ 的数列。这时我们把 $\dfrac{y}{x}$ 分解为多个质因数的乘积也就是 $a_1^{k_1} \times a_2^{k_2}\dots \times a_m^{k_m}$ 这时我们来看每个质因数的贡献。

我们以 $a_1$ 为例，因为这个数列的最小公约数为 $1$，所以至少有一个数不含 $a_1$ 这个质因子，又因为这个数列的最小公倍数为 $\dfrac{y}{x}$ 所以至少有一个数含 $k_1$ 个 $a_1$。

我们先不考虑限制条件，因为每个数都可能包含 $0$ 到 $k_1$ 个 $a_1$，所以其对答案的贡献为 ${(k_1+1)}^n$，而限制条件也好解决，我们只需要减去所有数只含有 $1$ 到 $k_1$ 和 $0$ 到 $k_1-1$ 的情况，也就是 $2 \times k_1^n$ 种可能，注意到 $1$ 到 $k_1-1$ 的情况减了两次，所以加上 ${(k_1-1)}^n$ 就为该因子的贡献。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
#define mod 998244353
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x) {
	if(x < 0) x = ~(x - 1) , putchar('-');
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
inline void writeh(int x) {
	write(x);
	putchar('\n');
}
inline void writek(int x) {
	write(x);
	putchar(' ');
}
int q , x , y , n , tot , c[maxn];
inline int ksm(int x , int k) {
	int ans = 1 , y = x;
	while(k) {
		if(k & 1) ans = (ans * y) % mod;
		y = (y * y) % mod;
		k >>= 1;
	}
	return ans;
}
inline void fenjie(int x) {
	tot = 0;
	for(int i = 2; i * i <= x; i++) {
		if(x % i == 0) {
			tot++;
			c[tot] = 0;//注意一定要清空
			while(x % i == 0) {
				c[tot]++;
				x /= i;
			}
		}
	}
	if(x > 1) c[++tot] = 1;
}
inline void work() {
	x = read();
	y = read();
	n = read();
	y = y / x;
	int ans = 1 , tmp;
	fenjie(y);
	for(int i = 1; i <= tot; i++) {
		tmp = ksm(c[i] + 1 , n);
		tmp = ((tmp - 2 * ksm(c[i] , n) + ksm(c[i] - 1 , n)) % mod + mod) % mod;
		ans = (ans * tmp) % mod;
	}
	writeh(ans);
}
signed main(){
	q = read();
	while(q--) work();
	return !("wjl1100 qwq");
}
```

---

## 作者：guojiahong (赞：0)

本文算是 [这篇文章](https://www.luogu.com.cn/article/8ytbqj8u) 的基础版（~~[他](https://www.luogu.com.cn/user/734703) 一边写题解一边教我的~~）。
### 简要题意：
计算有多少个长度为 $n$ 的序列 $a$ 满足:

$\gcd(a_1,a_2,\dots,a_n)=x$ 且 $\operatorname{lcm}(a_1,a_2,\dots,a_n)=y$。

## 思路
- 由于 $\gcd(a_1,a_2,\dots,a_n)=x$ ，所以 $a$ 中的所有数都是 $x$ 的倍数，于是设 $k_i=\frac{a_i}{x}$。
- 由于 $y$ 一定是 $x$ 的倍数（否则一定无解），所以可以设 $t=\frac{y}{x}$，原题就变成了计算有多少个长度为 $n$ 的序列 $k$ 满足 $\operatorname{lcm}(k_1,k_2,\dots,k_n)=t$。
- 考虑将 $k$ 分解质因数，设 $k=\prod {p_i}^{num_i}$（其中 $p_i$ 代表 $k$ 的一个质因数，$num_i$ 是这个质因数的次数，对应 [这篇题解](https://www.luogu.com.cn/article/8ytbqj8u) 的 $e_i$）。
- 考虑容斥：把题目转化为在集合 $S$ 中（所有可能的情况，$p_i$ 的次数能取的范围是 $[0,e_i]$），有 $P_1,P_2$ 两个集合是不合法的：
1.   $P_1$ 表示 $\gcd(k_1,k_2,\dots,k_n)$ 不为 $1$ 的集合即 $\gcd(k_1,k_2,\dots,k_n)$ 不为 $x$ 的集合，$k_i$ 中 $p_j$ 的次数能取的范围为 $[1,e_j]$。
2.   $P_2$ 表示 $\operatorname{lcm}(k_1,k_2,\dots,k_n)$ 不为 $\frac{y}{x}$ 的集合即 $\operatorname{lcm}(k_1,k_2,\dots,k_n)$ 不为 $y$ 的集合，$k_i$ 中 $p_j$ 的次数能取的范围为 $[0,e_j-1]$。
3.   根据容斥的原理，答案为总集 $S-P_1-P_2+|P_1\bigcap P_2|$ 即 $\prod p_i^{num_i+1}-2 p_i^{num_i}+p_i^{num_i-1}$。
4.   如果直接算指数会 TLE，可以用 [快速幂](https://www.luogu.com.cn/article/juyq38gx)。
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
long long ksm(long long a,int b)
{
	long long ans=1;
	while(b)
	{
		if(b%2==0)
		{
			a=a*a%mod;
			b/=2;
		}
		else
		{
			ans=ans*a%mod;
			b--;
		}
	}
	return ans;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,x,y,t;
		long long num;
		scanf("%d%d%d",&x,&y,&n);
		t=y/x;
		long long ans=1;
		for(int i=2;i*i<=t;i++)
		{
			if(t%i==0)
			{
				num=0;
				while(t%i==0)
				{
					t/=i;
					num++;
				}
				ans=ans*((ksm(num+1,n)%mod-2*ksm(num,n)%mod+ksm(num-1,n)%mod)%mod+mod)%mod; 
			}
		}
		if(t!=1)ans=ans*((ksm(2ll,n)%mod-2)%mod+mod)%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---


# [HNOI2008] 越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 说明/提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :--------: | :--------: | :-------: | :--------: |
| 1 | 信仰 1 | 信仰 1 | 信仰 1 |
| 2 | 信仰 1 | 信仰 1 | 信仰 2 |
| 3 | 信仰 1 | 信仰 2 | 信仰 2 |
| 4 | 信仰 2 | 信仰 1 | 信仰 1 |
| 5 | 信仰 2 | 信仰 2 | 信仰 2 |
| 6 | 信仰 2 | 信仰 2 | 信仰 1 |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
6```

# 题解

## 作者：蒟蒻初音ミク (赞：136)

# 广告

[蒟蒻的blog](http://www.luogu.com.cn/blog/111990/#)

# 正文

~~本蒟蒻又一次写题解，好激动。。。~~

其实这题是这样的：

有n个人，还有m种信仰，然后在所有信仰情况中找出有相邻两个人的信仰是相同的。~~我懒，不想说太多，希望读者大大是读了题思考过了来看的。。。~~

一看难度：
# 绿标签！还是数论！看我dfs切了它！
然后看数据范围：

M<=10000000（10的8次方）

N<=1000000000000（10的12次方）

~~笑容逐渐消失~~

然后开始想正解。

首先，第一种思路肯定是搞一个公式可以直接算出有相邻两个人信仰相同的情况数，but。。。**没有万能公式啊！！！**

~~教大家一招，绿标数论题如果没有找到公式，换一种思路，继续找公式。要相信，这种难度的题肯定有公式~~

然后换一种思路。

我们可以倒过来想，我们只需要算出不越狱的情况，再用总情况减掉就行了！！！

所以。。。第一个人有m种选择，第二个人为了不与第一个人不重复，只有m-1个选择，第三个人为了不与第二个人重复，也只有m-1个选择。。。最后总情况有m^n个，那么。。。

## $ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ ans=m^n-m*(m-1)^{n-1}$

## code

```cpp
#include<cstdio>
#define ll long long
using namespace std;
const ll mod=100003ll;
inline int read()
{
	char ch=getchar();
	int x=0,f=1;
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
inline ll pow(ll a)
{
	return (a*a)%mod;
}
ll n,m;
inline ll qmi(ll a,ll b)
{
	if(b==0)return 1;
	return (b&1)?pow(qmi(a,b>>1))*(a%mod)%mod:pow(qmi(a,b>>1));
}
int main()
{
	scanf("%lld%lld",&m,&n);
	ll ans=qmi(m,n)-(m%mod)*qmi(m-1,n-1)%mod;
	while(ans<0)ans+=mod;
	ans%=mod;
	printf("%lld",ans);
	return 0;
}
```

最后希望各位读者大大可以ak ioi！！！

---

## 作者：Ezios (赞：70)

## 大致思路

首先算出所有犯人加在一起的所有状态，减去所有**[状态:相邻房间的犯人的宗教不相同]**,即为答案。

### 所有状态的计算

一个犯人有$m$种状态，在不考虑其它条件的情况下，两个犯人有$m*m$种状态 $=>$ $n$个犯人有$m^{n}$种总状态。

### 相邻房间不同宗教状态的计算

取最左边的犯人,得该犯人可能信仰的宗教数量是$m$；  
设该犯人选了宗教$j$, 那么在他右边的犯人的可供选择就只剩下 { $1...m$ } $-$ { $j$ } $=(m-1)$种了。
那么再以这个选$m-1$种宗教的犯人为标准,设他随便选了宗教$k$ `(k!=j)` ，
他的左边肯定跟他不一样,所以只要他右边也跟他不一样即可；  
那么右边剩下的选项为 { $1...m$ } $-$ { $k$ } $=(m-1)$种。  
可以看到,对于任意一名犯人,他需要与他左边相邻的犯人不同；
所以如果只考虑左边，他的宗教可选数量为（总数量-左边相邻犯人已选择宗教的数量~~(显然是1个嘛)~~ ） = $m-1$个。
而递推过去,他的右边相邻犯人会避免选择他选择的宗教，因而我们不用把相邻右边的犯人考虑进去。
所以情况数就为 $m*(m-1)^{n-1}$。  

### 最终答案
两者相减，得到$m^{n}-m*(m-1)^{n-1}$。

##### \* 为了避免出现奇怪的前者在对p取模后小于后者的情况(事实上从第二个点就会出现这种情况),我们可以在相减后加上一个p再对p取模.


## 代码:
```
#include<cstdio>
#include<iostream>
#include<algorithm>
///This is a helper function that used to assist Fermat's little theorem to obtain fast modules of inverse elements.
template<typename _FastModularExponentiationElement,typename _power_type,typename _modular_type>
_FastModularExponentiationElement
__fmo_expa(_FastModularExponentiationElement __m,_power_type __n,_modular_type _modular)
{
  _FastModularExponentiationElement ans=1;
  while(__n)
  {
	if(__n&1) ans=(ans*__m)%_modular;
	__m=(__m*__m)%_modular;
	__n>>=1;
  }
  return ans%_modular;
}
long long  n,m,ans;
const int mod=100003;
int main(){
	scanf("%lld%lld",&m,&n);
	ans=((__fmo_expa(m,n,mod)-(m%mod)*__fmo_expa(m-1,n-1,mod))%mod+mod)%mod;
	printf("%lld",ans);
	return 0;
}
 ```

---

## 作者：Drinkkk (赞：44)

【参考资料】

liusu201601的博客：http://blog.csdn.net/liusu201601/

ZCDHJ的博客：https://zcdhj.org/ ，这是这位dalao的新博客，借鉴的内容在旧的博客上，所以可能找不到。

neymar_jr的博客：https://www.luogu.org/blog/wangzy11/

Roni的博客：http://www.cnblogs.com/Roni-i/

李京泽的博客：https://www.cnblogs.com/lj-1568/p/4754336.html

【题目描述】

监狱有连续编号为$1$~$n$的$n$个房间，每个房间关押一个犯人，有$m$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

【输入输出格式】

- 输入格式

输入两个整数$m$，$n$。$1 \leq m \leq 10^8,1 \leq n \leq 10^{12}$。

- 输出格式

可能越狱的状态数，模100003取余。

【输入输出样例】

- 输入样例
```
2 3
```

- 输出样例
```
6
```

【说明】

6种状态分别为(000)(001)(011)(100)(110)(111)。

【题解】

$100$分满分思路：

由于直接计算越狱的方案数不是很好做，所以我们选择用所有的方案数减去不越狱的方案数。由于每一个房间的人的宗教有$m$种可能，且有$n$个房间，所以所有的方案数等于$m^n$。由于当相邻的两个房间所关押的罪犯当宗教相同时就有可能会越狱，所以不可能会越狱的方案数为$m \times (m-1)^{n-1}$，这是因为第一个房间的最烦的宗教有$m$种选择，而第二个房间的罪犯的宗教有$m-1$种选择，第三个房间的罪犯的宗教有$m-2$种选择，以此类推。因此越狱的方案数就有$m^n-m \times (m-1)^{n-1}$种。由于$n$很大，所以我们用快速幂来解这道题，注意，本题的模数是``100003``，不要输错了。

什么是快速幂？

快速幂可以快速地求出一个数的多少次方是多少（可能会对某个数取模）。

如果我们求的是$a^n$的值的话，那么有性质：

$a^b\;mod\;c=((a^2)^{\lfloor b/2 \rfloor} \times a)\;mod\;c$，$b$是奇数。

$a^b\;mod\;c=((a^2)^{\lfloor b/2 \rfloor})\;mod\;c$，$b$是偶数。

由于在加法和乘法运算中对于取模运算时自由的（即中途取模和结束时再取模的答案是一样的），所以我们可以在中途取模，下面是一些取模运算的规则，如下：

模运算与基本四则运算有些相似，但是除法例外。其规则如下：

(a + b) % p = (a % p + b % p) % p

(a – b) % p = (a % p – b % p) % p

(a * b) % p = (a % p * b % p) % p

ab % p = ((a % p)b) % p

结合率：

((a+b) % p + c) % p = (a + (b+c) % p) % p

((a*b) % p * c)% p = (a * (b*c) % p) % p

下面上AC代码~

```
#include <cstdio>
long long p=0;
long long qu(long long x,long long y)
{
    if(y==0)
    {
        return 1;
    }
    else
    {
        long long dq=qu(x,y/2);
        if(y%2==0)
        {
            return ((dq%p)*(dq%p))%p;
        }
        else if(y%2==1)
        {
            return ((dq%p)*(dq%p)*(x%p))%p;
        }
    }
}
int main()
{
    long long m=0,n=0;
    scanf("%lld %lld",&m,&n);
    p=100003;
    printf("%lld",(qu(m,n)-(m*qu(m-1,n-1))%p+p)%p);
    return 0;
}
```

---

## 作者：qxy20040629 (赞：31)

大家好，这里是题解！先看一下题面

   监狱有连续编号为 1…N 的 N个房间，每个房间关押一个犯人，有 M种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。可能越狱的状态数，模 100003 取余.1≤M≤1e8，1≤N≤1e12

DP思路好想，但是看到数据范围立马就判断这是一道组合数学；那么我们就分析一下：


设所有情况为全集U，越狱情况为集合A，不越狱集合为B；
如果直接求A就有点不好想，不如求B，再减法原理一下下；

怎么求呢？

先求U，ans1=M^N；

再求B，那么若第一个罪犯有M种宗教可能，那么第二个罪犯如果不能满足越狱条件则必须和第一个宗教不同，就只有（M-1）种，那么第3~N个罪犯也一样，都有（M-1）种情况，如下图所示![](https://cdn.luogu.com.cn/upload/image_hosting/o8jhgrk7.png)

那么B的结果很显然，ans2=M*(M-1)^(N-1)

A的情况就是ans3=ans1-ans2;

回顾一下数据范围，这个要用快速幂（P1226）
代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll m,n,ans1,ans2,ans3;
const ll p=100003;
ll power(ll a,ll b,ll p){
	ll ans=1%p;
	for(;b;b>>=1){
		if(b&1) ans=(ll)ans*a%p;
		a=(ll)a*a%p;
	}
	return ans;
}
int main(){
	cin>>m>>n;
	ans1=power(m,n,p);
	ans2=m*power(m-1,n-1,p);
	ans2%=p;
	ans3=ans1-ans2;
	if(ans3<0) ans3+=p;
	cout<<ans3<<endl;
	return 0;
}
```

最后提一句，ans3可能小于0，所以要特判呦~~ （求过）

---

## 作者：Kisaragi_77 (赞：24)

~~比较休闲的一道组合计数题~~

因为越狱的情况比较多，且有很多重复情况，很难进行统计

考虑 **正难则反** 的思路 

考虑生成子集(m进制数)，总共有$m^n$ 种方案

**没有一个人越狱**的情况会比较好求
![](https://cdn.luogu.com.cn/upload/pic/62837.png)
考虑爆搜,我们枚举第一个人的$m$种宗教选择,每个人只能转移到不等于自己的$n-1$种宗教,一共有$m-1$次转移

由于我们只需要知道方案数，根据乘法原理或画图找规律得知

有$m *(m-1)^n-1$种方案

即

$$
ans =m^n -m*(m-1)^n-1
$$

我们只需要写一个快速幂取模就可以求出ans

代码非常好写

```cpp
#include<cstdio>
#define ll long long
#define MOD 100003
inline ll qpow(ll a,ll p){
	ll ans =1;
	while(p){
		if(p&1) ans =ans *a %MOD;
		a =a *a %MOD;
		p >>=1;
	}	return ans;
}
int main(){
	ll m,n;	scanf("%lld %lld",&m,&n);
	ll ans =qpow(m,n) -m*qpow(m-1,n-1)%MOD;
	printf("%lld",ans%MOD);
}
```



OK，这一波只有10分

**这题唯一的坑点就在于减法可能会导致负数，C++的取模方式会出锅**

很简单 加一句

```cpp
ans +=MOD
```

就可以了



---

## 作者：K2sen (赞：14)

## P3197 越狱
### 一句话题意
给出n个人排成一排，还有m个宗教，每个人信仰一种宗教，问相邻的人宗教相同的情况有多少种.

### 解题思路:
可以算出总的情况，然后减去信仰宗教不同的情况.

all - difference = identical

然后总的情况就是每一个人可能信仰m种宗教，显然总的情况数就是,$n^m$,

然后我们看相同的情况,

![](https://cdn.luogu.com.cn/upload/image_hosting/07xzrom7.png)

可以先固定，第一个人选择m种宗教，然后要使下一个人信仰的宗教与他不相同，

那么下一个人可以在前一个人的宗教确定的情况下在选择与前一个人信仰的宗教不同的所有情况，所以就是m-1种，后边的以此类推,

所以所有人与其相邻的人信仰不同宗教的情况就是, 
$$m \ast (m - 1)^{n - 1}$$

那么要求的相邻的人信仰相同的宗教的所有情况就是，总的情况减去相邻的不是相同宗教的情况.也就是这样：

$$m^n - m \ast (m - 1)^{n - 1}$$

#### code;
```cpp
#include <bits/stdc++.h>
#define N 100010
#define M 1010
#define _ 0
#define int long long

using namespace std;
const int mod = 100003;
int n, m;

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

int q_pow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b & 1) ans = (ans * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return ans;
}

signed main() {
	m = read(), n = read();
	int p = q_pow(m, n);
	int q = (m * q_pow(m - 1, n - 1)) % mod;
	cout << (p - q + mod) % mod;
}
```

---

## 作者：EarthGiao (赞：6)

## 【思路】
组合数学 + 快速幂    
### 【题目大意】
n个房间里面都有犯人，他们信仰m种不同的宗教    
求有至少一对信仰相同宗教的人挨在一起的情况    

### 【核心思路】
正着求是很难求或者是没有办法求的     
所以正难则反      
没法直接求出来越狱的情况    
那就求出总的情况和不越狱的情况     
用总的情况减去不越狱的情况     
就是题目要求我们求的越狱的情况    

总的情况    
每一个房间都有m中可能，一共有n个房间     
所以可能性是m^n次方    
总的情况就知道了       
然后看不会越狱的情况    
第一个房间可以有m中选择   
第二个房间不能和第一个房间的宗教一样      
所以只有m-1中可能   
第三个也是和第二个一样    
所以出现了一个m和n-1个m-1    
那么不会越狱的情况就是m*(m-1)^(n-1)      
知道了这两个     
一做差就可以求出来会越狱的情况了    

### 【小细节】
幂运算很大需要用快速幂      
##  【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int mo = 100003;

int p(int a,int b)
{
  int ans = 1;
  while(b != 0)
  {
    if(b & 1 == 1)
    {
      ans *= a;
      ans %= mo;
    }
    b /= 2;
    a = ((a % mo) * (a % mo)) % mo;
  }
  return ans;
} 

signed main()
{
  int n,m;
  cin >> m >> n;
  cout << ((p(m,n) % mo - (m * p(m - 1,n - 1)))%mo + mo ) % mo;//先做减法，因为减法之后可能出现负数，但是这个负数的绝对值一定会小于m的 ，因为这是两个已经%过m的数，保证小于m所以做的差的绝对值也一定小于m，只需要将这个可能是服饰的数加上mo保证是正数之后再%一遍mo 
  return 0;
}
```

---

## 作者：neymar_jr (赞：6)

这是一道数论题，很容易看出来这是一道排列组合

若没有限制，方案数m\*n

若有限制，第一个人拿m，第二个人就是m-1

以此类推，方案数m\*(m-1)^(n-1)

两者作差即可

（在求幂这里要用快速幂，否则会卡爆，，）

附上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
ll m,n;
const int mod=100003;
ll fast_pow(ll n,ll m)
{
    if(m==0)return 1;
    ll a=(fast_pow(n,m/2))%mod;
    if(m&1)return ((a*a)%mod*n)%mod;
    else return (a*a)%mod;
}
int main()
{
    scanf("%lld%lld",&m,&n);
    printf("%lld",(fast_pow(m,n)-((m*fast_pow(m-1,n-1))%mod)+mod)%mod);
    return 0;
}
```

---

## 作者：蒟蒻pks (赞：6)

听从某个大佬所说的“正难则反“

不考虑有多少种越狱的可能 只考虑有多少种可能不越狱

再套上快速幂模板就可以了


            
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,inf=100003;
long long fastmi(long long i,long long j){
    long long ans=1,k=i;
    while (j)
    {
        if (j&1)
            ans=ans*k%inf;
        k=k*k%inf;
        j>>=1;
    }
    return ans;
}
int main(){
    scanf("%lld%lld",&m,&n);
    cout<<((fastmi(m,n)-m*fastmi(m-1,n-1)%inf)+inf)%inf<<endl;
}

```

---

## 作者：Undefined_R (赞：4)

先摆上递推公式，再详细描述解题步骤。
设dp[i]表示i个犯人分别关在i个房间里的可能发生越狱的状态总数。

则
dp[i]=dp[i-1]·(m-1)+$m^{i-1}$

推导过程：

 i个犯人分别关在i个房间里可能发生越狱的状态总数(dp[i])显然首先要继承i-1个犯人分别关在i-1个房间里可能发生的越狱状态总数(dp[i-1])。在这些状态下后续房间i中犯人可以信仰任何宗教，故要乘以宗教总数m。
 
再考虑被dp[i-1]排除掉的状态（前i-1个房间的所有状态有$m^{i-1}$种，故被dp[i-1]排除掉的状态有($m^{i-1}$-dp[i-1])种），在这些状态下后续房间i中犯人可且仅可信仰上一个房间中的犯人的宗教（即房间i-1里的犯人的宗教），才能有可能越狱。所以dp[i]需要加上($m^{i-1}$-dp[i-1])·1。

综上可得dp[i]=dp[i-1]·m+($m^{i-1}$-dp[i-1])·1，化简即可得到dp[i]=dp[i-1]·(m-1)+$m^{i-1}$。

&nbsp;

递推公式推导完毕。但看看数据范围，很显然是不会让你就这么推过去的。需要利用矩阵快速幂进行优化。矩阵的构造方式不唯一，这里介绍我个人的思路。

![](https://cdn.luogu.com.cn/upload/image_hosting/2owi5km0.png)

参考代码：
```
#include<cstdio>
#include<cctype>
inline namespace usual{
	inline long long input(){
		long long a=0,f=1;
		char tmp=getchar();
		while(!isdigit(tmp)){if(tmp=='-')f=-1;tmp=getchar();}
		while(isdigit(tmp)){a=(a<<3)+(a<<1)+tmp-48;tmp=getchar();}
		return a*f;
	}
	inline void output(long long x){
		if(x<0){putchar('-');x=-x;}
		if(x>9)output(x/10);
		putchar(x%10+48);
	}
	template<typename T>T max(T a,T b){return a>b?a:b;}
	template<typename T>T min(T a,T b){return a<b?a:b;}
}
using namespace usual;
long long n;
int m;
struct matrix{
	long long base[4][4];
	int l,w;//l为行数，w为列数 
	long long* operator[](int m){
		return base[m];
	}
	void get_info(int l,int w){
		this->l=l,this->w=w;
	}
};
matrix clear,fir,my_matrix;
matrix operator*(matrix x,matrix y){
	matrix _return=clear;
	for(int i=1;i<=x.l;i++)
		for(int j=1;j<=y.w;j++)
			for(int k=1;k<=x.w;k++)
				_return[i][j]=(_return[i][j]+(long long)x[i][k]*y[k][j])%100003;
	_return.get_info(x.l,y.w);
	return _return;
}
void operator*=(matrix &a,matrix b){
	a=a*b;
}
matrix pow(matrix a,long long b){
	matrix ans=clear,base=a;
	ans.get_info(a.l,a.w);
	for(int i=1;i<=ans.l;i++)
		ans[i][i]=1;
	while(b){
		if(b&1)ans*=base;
		base*=base;
		b>>=1;
	}
	return ans;
}
int main(){
	m=input(),n=input();
	fir.get_info(1,2);
	fir[1][1]=0,fir[1][2]=m;
	my_matrix.get_info(2,2);
	my_matrix[1][1]=m-1,my_matrix[1][2]=0,my_matrix[2][1]=1,my_matrix[2][2]=m;
	matrix ans=fir*pow(my_matrix,n-1);
	output(ans[1][1]);
	return 0;
}
```

---

## 作者：撤云 (赞：3)

### [$$Blog$$](https://www.cnblogs.com/hbxblog/p/10309261.html)
---
### $Solution$
正难则反,这道题直接做有点困难,但我们可以反过来思考我们可以用总方案数减去不可以越狱的方案数

+ 首先来算总方案数:
对于每个房间的人都有$M$种宗教可以选,那么共有$M^N$种方案  
+ 再来看看不可以越狱的方案数:
对于第一个房间可以选$M$种宗教.对于第$2$~$N$个房间每个房间选的宗教要和前面的不同,所以可以选$M-1$种宗教,所以共有$M*(M-1)^{N-1}$

所以答案就是:
$$M^N-M*(M-1)^{N-1}$$

### $Code$

``` cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=100003;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)
			ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
main(){
	int m=read(),n=read();
	printf("%lld",(ksm(m,n)-m*ksm(m-1,n-1)%mod+mod)%mod);
}

```

---

## 作者：agicy (赞：2)

# 思路

~~这是一道极其简单的水题。~~

经过简单的数学分析可以得出结论。

## 1. 监狱信仰宗教总的情况数为$m^n$

推理过程：

1. 对于每个人来说，他都有$m$种宗教可以信仰，即这一个人有$m$种可能的情况；

2. 根据乘法原理，这个群体的总的可能数为每一个人可能数的乘积，即总的情况数为$m^n$。

## 2. 不发生越狱的情况数为$m×(m-1)^{n-1}$

1. 对于第$1$个人来说，他可以有$m$种选择；

2. 对于第$2$个人来说，他可以有$m-1$种选择，因为他不能和前一个人相同；

3. 对于第$3$个人来说，他可以有$m-1$种选择，因为他不能和前一个人相同；

4. 对于第$4$~$n$个人来说，他可以有$m-1$种选择，因为他不能和前一个人相同；

5. 根据乘法原理，不发生越狱的情况数为$m×(m-1)^{n-1}$。

所以，$ans=m^n-m×(m-1)^{n-1}$（记得取余）。

# 代码

因为要求快速求出$m^n,m×(m-1)^{n-1}$等数且$1≤n≤10^{12}$，我们要使用快速幂的算法来解决问题。

下面是我写的快速幂（递归版），其中$x$为底数，$exp$为指数，$mod$为除数。

```cpp
long long pow(long long x,long long exp,long long mod){
	if(exp==0)
		return 1;
	else if(exp==1)
		return x;
	else if(exp&1){
		long long temp=pow(x,exp>>1,mod)%mod;
		return temp*temp*x%mod;
	}
	else{
		long long temp=pow(x,exp>>1,mod)%mod;
		return temp*temp%mod;
	}
}
```

下面就是整个程序的代码。

```cpp
#include<stdio.h>//头文件
#define MOD 100003ll

long long m,n,ans;//用long long防止溢出

long long pow(long long,long long,long long);//函数声明

int main(void){
	scanf("%lld%lld",&m,&n);
	ans=(pow(m,n,MOD)-((m%MOD)*pow(m-1,n-1,MOD))%MOD)%MOD;
	if(ans<0)//如果结果是个负数，一定要转化为非负整数
		ans+=MOD;
	printf("%lld",ans%MOD);//输出
	return 0;//结束
}

long long pow(long long x,long long exp,long long mod){//快速幂
	if(exp==0)
		return 1;
	else if(exp==1)
		return x;
	else if(exp&1){
		long long temp=pow(x,exp>>1,mod)%mod;
		return temp*temp*x%mod;
	}
	else{
		long long temp=pow(x,exp>>1,mod)%mod;
		return temp*temp%mod;
	}
}
```

---

## 作者：BLUE_EYE (赞：2)

看到没有矩阵乘法的题解  一开始我是因为被推荐矩阵乘法才来写这一题的

楼下大佬们的数学公式很强 学到了

矩阵乘法是用矩阵优化达到递推logN解法的一种算法（大佬们无视）

可以用矩阵做的题推荐一道 https://nanti.jisuanke.com/t/16442

递推式是  设a（）表示已经越狱的  b（）表示没有越狱的

则 a（i）=a（i-1）\*m+b（i-1）；表示已经越狱的最后一个人是什么都可以 没越狱的只能和倒数第二个一样

b（i）=（a（i-1）+b（i-1））\*m-a（i）=（m-1）\*b（i-1）；有m^n种可能 相减即可

b（1）=m；

下面贴代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;//不打long long 会WA
const ll MOD=100003;
ll i,j,n,m;
struct node{
    ll s[2][2];
    node(){
    for(int i=0;i<=1;i++)
            for(int j=0;j<=1;j++)
                s[i][j]=0;
```
}//矩阵初始为0；
```cpp
    node operator * (const node& b){
        node all;
        for(int i=0;i<=1;i++)
            for(int j=0;j<=1;j++)
                for(int k=0;k<=1;k++){
                    all.s[i][j]+=s[i][k]*b.s[k][j];//矩阵乘法 不知道戳百科 （行的每个元素*列的每个元素）
                    all.s[i][j]%=MOD;//不能忘了取模
                }
        return all;//return矩阵
    }
}a,b,ans;
node qpow(node t,ll k){
    node w;w.s[0][0]=0;w.s[0][1]=m;//快速幂
    for(ll i=k;i;i>>=1,t=t*t)
    if(i&1)w=w*t;return w;
}
int main(){
    scanf("%lld%lld",&m,&n);
    a.s[0][0]=m;a.s[0][1]=0;//
    a.s[1][0]=1;a.s[1][1]=m-1;//矩阵的初始化
    ans=qpow(a,n-1);
    printf("%lld",ans.s[0][0]);//输出
}
```

---

## 作者：檀黎斗·神 (赞：2)

考虑有多少种方法越狱，要分别考虑一组，两组，多组的犯人越狱


但是考虑不越狱的方案就简单很多，其实我们不用考虑相邻的犯人


只要当前牢房的犯人和上一个犯人的信仰不同就行了


因为每个都和前面的不同那么最终求出来的相邻的犯人肯定不同


那么最后我们只要用所有方案减去我们求出来的方案数就可以了


那这道题就变成了排列组合的问题


总方案是 m^n , 不越狱的方案是 1\* m-1/m \* m-1/m \* ... \* m-1/m，也就是（m-1/m）^n-1


因为除法可能有误差，所以转化为m（m^n-1-(m-1)^n-1）


但是减法也可能会出现负数，对减法的结果要再加mod再取模保证为正数


最后补充一句由于数据比较大我们要用到快速幂，都会用就不详细说了


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const long long mod=100003;
ll quick(ll a,ll b)
{
    ll ans=1;
    a=a%mod;
    while(b!=0)
    {
        if(b&1) ans=(ans*a)%mod;
        b=b>>1;
        a=(a*a)%mod;
    }
    return ans;
}//快速幂，每个乘法都要取模 
ll m,n;
int main()
{
    scanf("%lld%lld",&m,&n);
    ll a,b,ans,c;
    a=quick(m,n-1),b=quick(m-1,n-1);
    c=(a-b+mod)%mod;//防止复数的情况 
    ans=((m%mod)*c);
    printf("%lld\n",ans%mod);
    //答案也要取模，因为（a*b）%c等价于（a%c*b%c）%c
    return 0;
}
```

---

## 作者：like1 (赞：1)

首先我们观察数据范围就可以知道本题应该是数学题

然而题目要我们所求的东西似乎不太好求，那么我们可以考虑求他的反面，即正难则反，所以我们可以先求出不发生越狱的方案数，再用总方案数减去不发生越狱的方案数

总方案数很明显是m^n；

不发生越狱的方案数

我们先考虑第一个犯人，对于第一个犯人可以选择m种宗教，对于第二个犯人
则有m-1种选择，对于第三个犯人，只要他与第二个犯人的宗教不同就行，所以也是m-1种选择，以此类推，我们不难发现对于第n个犯人他也有m-1种选择，
那么我们就得出了不发生越狱的方案数，即为m*(m-1)^(n-1)；

至此我们就愉快地解决了发生越狱的方案数，即为m^n-m*(m-1)^(n-1)；

最后注意取模的值，（个人建议复制体面的，这样不容易出错）

```cpp
#include <cstdio>
#include <iostream> 
#include <cmath>  
using namespace std;
const int mod=100003; 
long long n,m;
  
inline long long poww(long long a,long long b,int mod)
  
{ 
  
	long long cnt=1;
	while(b)
	{
		if(b%2==1) cnt=cnt*a%mod;
		a=a*a%mod;
		b=b/2;
	}
	return cnt;
}

int main( )
{
  
	//freopen("prisona.in","r",stdin);
	//freopen("prisona.out","w",stdout);
	scanf("%lld%lld",&m,&n);
	int ans1=poww(m,n,mod);
	int ans2=poww(m-1,n-1,mod);
	printf("%d\n",((ans1-ans2*m)%mod+mod)%mod);
	return 0;
}
```

  
最后祝大家CSP2019rp++,score++;

---

## 作者：开心的猪 (赞：1)

作为本蒟蒻第二道AC的绿题， 还是很有必要写题解纪念以下的。。。

如果加上可以越狱的数目，总数目为M^N种情况。

接下来，去掉不可以越狱的数目，第一个人可以任意选宗教，以后每个人都不能选他前面那个人的宗教，于是除了第一个人以外， 每个人都有（N-1）种选择，即有M*(M-1)^(N-1）种。

于是，ans=[M^N-M*(M-1)^(N-1)]%100003.

另外，直接使用Pow会爆long long,自己用循环编会T掉，所以可以使用~~高仿版~~快速幂。

以下是代码，仅供欣赏，不保证没有锅。。。

```
#include<bits/stdc++.h>

using namespace std;

long long int power(long long int a, long long int b)
{
	if(a==1)
	{
		return 1;
	}
	else if(a==0)
	{
		return 0;
	}
	else if(b==0)
	{
		return 1;
	}
	else if(b==1)
	{
		return(a%100003);
	}
	else if(b%2==1)
	{
		long long int ans=power(a, b/2);
		return (a*ans*ans)%100003;
	}
	else
	{
		long long int ans=power(a, b/2);
		return (ans*ans)%100003;
	}
}

int main()
{
	long long int M, N;
	scanf("%lld%lld", &M, &N);
	printf("%lld", (power(N, M)+100003-(N*power(N-1, M-1)%100003))%100003);
	return 0;
}
```
不得不承认，我在其中某一行倒了一下两个东西的顺序，可以自行检查。

---

## 作者：HoshiuZ (赞：1)

## 方法一
令n为房间数，m为宗教数，f(m,n)表示n个房间m个宗教可能发生越狱的状态数。

当f(2,3)时，总状态（包括不发生越狱）有（划掉的为不可行方案）：
- 000
- 001
- ~~010~~
- 011
- 100
- ~~101~~
- 110
- 111

当f(2,2)时，总状态（包括不发生越狱）有（划掉的为不可行方案）：
- 00
- ~~01~~
- ~~10~~
- 11

①可以在f(2,2)的可行方案中做手脚，00可以在前面添0或1，变为000和100；11可以在前面添0或1，变为011和111。发现添后不就是f(2,3)的部分方案吗？

②以此构造出了4中可行状态，还剩下001和110。观察f(2,2)的不可行方案，如何使其变为f(2,3)的可行方案呢？01可以在前面添0,10可以在前面添1，这样，f(2,3)的所有方案就被全部拓展出来了。

若为f(m,n)的话
- ①的个数可以表示为m*f(m,n-1)
- ②的个数。f(m,n-1)的总状态，其实就是m^(n-1)，减去可行方案f(m,n-1)就得出来了，即为m^(n-1)-f(m,n-1)

相加，得到f(m,n)=m*f(m,n-1)+m^(n-1)-f(m,n-1)

化简可得f(m,n)=(m-1)*f(m,n-1)+m^(n-1)

可以转化为1维的，也就是f(n)=(m-1)*f(n-1)+m^(n-1)

很容易得到f(1)=0，f(2)=m，那么先加特判，若n=1的话直接输出0，若不是就从f(2)向后推即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define MOD 100003

using namespace std;

ll m,n;
ll quickpow(ll x,ll n) {      //快速幂
	if(n==1) return x%MOD;      //注意取模
	ll t=quickpow(x,n/2)%MOD;
	if(n%2==0) return (t%MOD)*(t%MOD);
	if(n%2==1) return (t%MOD)*(t%MOD)*(x%MOD);
}

int main() {
	cin>>m>>n;
	
	ll t=m;      //f(2)=m
	if(n==1) cout<<0<<endl;
	else {
		for(int i=3;i<=n;i++) t=((t%MOD)*((m-1)%MOD)+quickpow(m,i-1))%MOD;      //从f(2)向后推
	}
	
	cout<<t<<endl;
		
	return 0;
}
```
很明显，这种算法是超时的，因为n最大为10^12。（30分）
## 方法二
上述方法超时，如何处理呢？

上面的方法是正着推出所有的情况的，既然这样比较困难，那我们可以采用正难则反的思想（实质补集），也就是找出所有的非法状态，然后用总状态减去非法状态就得到了合法状态。

本题的非法状态的求法，可以这样想。第一个人的宗教可能有m种，若是非法状态，那么第二个人就不能与第一个人相同，只有m-1种，同理，往后每一个人都只有m-1种，根据乘法原理，那么就是m*(m-1)^(n-1)种非法状态。

最后用总状态m^n减去m*(m-1)^(n-1)即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define MOD 100003

using namespace std;

ll m,n;
ll quickpow(ll x,ll n) {
	if(n==0) return 1;
	ll t=quickpow(x,n/2)%MOD;
	if(n%2==0) return (t%MOD)*(t%MOD);
	if(n%2==1) return (t%MOD)*(t%MOD)*(x%MOD);
}

int main() {
	cin>>m>>n;
	
	ll ans=quickpow(m,n)%MOD-(quickpow(m-1,n-1)%MOD)*(m%MOD)%MOD;
	cout<<(ans+MOD)%MOD<<endl;
		
	return 0;
}
```
## 总结
本题方法二在相减时，由于都取了模，所以相减后可能会出现负数的情况，所以需要通过取模变为正数。

---

## 作者：ModestCoder_ (赞：1)

随便选宗教，方案数$m^n$

不会发生越狱的情况，第一个人选$m$种宗教，后面$(n-1)$个人都能选$(m-1)$种宗教，方案数为$m*(m-1)^{n-1}$

减一减，答案为$m^n-m*(m-1)^{n-1}$

快速幂搞一搞即可，注意longlong

Code：

```cpp
#include <bits/stdc++.h>
#define LL long long
#define qy 100003
using namespace std;
LL m, n;

LL ksm(LL n, LL k){
	if (!k) return 1;
	LL sum = ksm(n, k >> 1);
	sum = sum * sum % qy;
	if (k & 1) sum = sum * n % qy;
	return sum;
}

int main(){
	scanf("%lld%lld", &m, &n);
	m %= qy;
	printf("%lld\n", (ksm(m, n) - m * ksm(m - 1, n - 1) % qy + qy) % qy);
	return 0;
}
```


---

## 作者：Lwen1243 (赞：1)

题目在这->[P3197](https://www.luogu.org/problemnew/show/P3197)

先安排第一间房间，因为是第一间房间，没有什么约束这个房间内犯人的宗教，所以有M种选择，继续安排第二个房间，第二间房间内犯人的宗教为了与第一间不一样，所以可以选择的宗教数为（M-1）种，以此类推，对于第n间房间，只要与第（n-1）间房间内犯人的宗教不同就可以了，故除第一间房间外，其他房间的宗教选择数都为（M-1），使用乘法原理，可知共有（M*（M-1）^(n-1)）种方案能使罪犯无法越狱。而对于原问题，我们只要求出总的安排方案然后减去无法越狱的方案，然后得到的就是可能发生越狱的情况了

那么，为什么要用乘法原理呢？

首先，我们要知道乘法原理的定义：[不谢](https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86/7538447?fr=aladdin)。此题中，对于安排房间这一件事，需要N步完成，每一步都有m[i]种情况。据此可知，应使用乘法原理

代码如下：
```cpp
#include<bits/stdc++.h>

#define f(i,a,b) for(int i=a;i<=b;i++)

#define ll long long

using namespace std;

const int q = 100003 ;

ll  n , m ;

void inp()
{
	cin >> m >> n ;
}

ll mul(ll a,ll b)
{
	ll ans = 1 ;
	a %= q ;
	while(b)
	{
		if(b&1) ans = (ans * a) % q;
		a = a * a % q;
		b >>= 1;
	}
	return ans;
}

ll work()
{
	ll ans ;
	ans = ( mul(m,n) - ( m*mul(m-1,n-1) ) + q ) % q;
	while(ans<0) ans += q ;
	return ans;
}

int main()
{
	inp();
	cout<< work() <<endl;
	return 0;
}
```
因为值可能很大，所以在算幂的时候要将快速幂与快速取模一起使用，避免爆long long

---

## 作者：鹭天 (赞：1)

#一题经典的快速幂！

普通方法实在太简单了，不过只能得30,40分，用快速幂位运算则能拿满分。

那么还有一部分数学理解，很显然，方法次数为n^m-n\*(n-1)^(m-1).跟组合排列问题相似。

那么有几个位运算的函数:

b and 1{也就是取b的二进制最低位(即第0位)判断b是否为奇数，是则为1}

b shr 1{就是去掉b的二进制最低位(即第0位)} 

注意的是要一边算一边模。

那么代码如下：

```cpp
var
  n,m:int64;
function ksm(x,y:int64):int64;//函数求快速幂,求x^y的值
  var i,j:int64;
begin
  i:=1;j:=x mod 100003;//为返回的值，j为带运算的数
  while y<>0 do begin
    if (y and 1)=1 then i:=i*j mod 100003;//这个函数如上所说
    j:=j*j mod 100003;//边算边模
    y:=y shr 1;//去掉一位
  end;
  exit(i);//返回值
end;
```
{一条分界线，上为快速幂，下为主程序}
```cpp
begin
  //assign(input,'box.in');reset(input);
  //assign(output,'box.out');rewrite(output);
  readln(n,m);
  write((ksm(n,m)-n*ksm(n-1,m-1) mod 100003+100003) mod 100003);
```
{上面的公式，为什么这里要加上100003呢？因为可能有负数，这里负数最小是-1~100002，那么整数+10003 在去 mod 10003的值是不会变的
    end.

#经典快速幂!!!似难非难


---

## 作者：functionendless (赞：1)

数学推导一下

题目要求越狱方案数，而越狱方案数等于总方案数-非越狱方案数

总数显而易见是m^n

非越狱方案数：

使任意两个房间非同一宗教，则只需满足每一个房间与前一个房间的宗教不同即可，所以推出

S=m\*(m-1)\*(m-1)\*...\*(m-1)[m-1有n个]=m\*(m-1)^(n-1);

所以只需快速幂求出m^n-m\*(m-1)^n-1即可

代码如下:

```cpp
#include<cstdio>
#include<cstring>
#define p 100003
using namespace std;
long long n,m;
long long pow(long long a,long long b)
{
    if(b==1) return a%p;
    long long s=pow(a,b/2)%p;
    if(b&1)   return (s*s%p) * (a%p) %p;
    else        return s*s%p;
}
int main()
{
    scanf("%lld %lld",&m,&n);
    long long ans=( m % p ) * ( (pow(m ,n - 1)+ p * 10/*防止负数的出现*/ -pow( m - 1 ,n - 1) ) % p ) % p;
    printf("%lld",ans);    
    return 0;
}

```

---

## 作者：Violette (赞：0)

### 一个快速幂的思路：

知识点：快速幂

为避免超时的一种快速算出a^b的算法。


不用快速幂的时间复杂度是O(b)，如果用快速幂，时间复杂度是O(log b)。


把b转换为二进制，例如：b=24时，

24    

12  
0  （1） 余数倒写：1 1 0 0 0 

6   0  （2）

3   0  （4）

1	1  （8）

0	1  （16）


现在，余数有两个为1，分别对应8次方和16次方。

所以：a的24次方可以拆成（a^8）*（a^16）。


当b%2为1时，累乘a，每次循环进行一次取模。

最后，不管是否%2余1，都要让a*=a（次方数需要变）


最后的累乘结果就是a^b的结果。


设快速幂函数：

利用快速幂算法（因为m<=10^8，n<=10^12，数据太大）。

主函数中，用总共的越狱情况减去不能越狱的情况。

总共的越狱情况：m的n次方。

不能越狱的情况：m乘上m-1的n-1次方。

注意：1. 考虑到总共的越狱情况减去不能越狱的情况可能为负数，需要加上一个100003再取模。

2. 所有数据都取long long类型

```cpp
#include<iostream>
#define N 100003
using namespace std;
int d[101],k=0;
    long long dc(long long x,long long n){
    long long s=1;
    while(n){
        if(n%2==1){
            s*=x;
            s%=N;
        }
        x*=x;
        x%=N;
        n/=2;
       }
       return s;
    }
int main(){
    long long m,n;
    cin>>m>>n;
     int s1=dc(m,n)%N;
     int s2=(m*dc(m-1,n-1))%N;
     cout<<(s1-s2+N)%N;
return 0;
}
```


---

## 作者：Violette (赞：0)

# 费马小定理解法 c++ 

### （M，N太大，不能直接暴力！） 

本弱的思路是：

假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p）。

附上代码（应该还算比较短吧）：

```
include<iostream>
using namespace std;
int main() 
{  
 	long long m,n;
  	long long s1,s2; 
  	cin>>m>>n;  
 	 s1=s2=m;  
 	 n%=100002;//费马小定理 
  	for(long long i=1;i<n;i++)                { 
  		s1=m;
      s1%=100003; 
      s2=m-1; 
      s2%=100003; 
   } 
 	cout<<(s1-s2+100003)%100003; 
 	return 0;
   }
```


---

## 作者：taopinlin (赞：0)

~~话说我觉得这题解法不用dp啊。。。~~
最最重要的是考验**逆向思维**，要考虑不会越狱情况
总情况:m^n,不会越狱:m*(m-1)^(n-1),一减就好了
然后快速幂取模了解一下


-----代码666-------

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long

using namespace std;

const int mod=100003;
ll n,m;

ll read(){
	char c=getchar();ll ss=0,tt=1;
	while(c<'0'||c>'9'){
	   if(c=='-')
		  tt=-1;
		c=getchar();
    }
	while(c>='0'&&c<='9'){
	ss=(ss<<1)+(ss<<3)+c-'0';
	c=getchar();
}
return ss*tt;
}

ll _pow(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&1) ans=(ans*x)%mod;
		x=(x*x)%mod;
		y>>=1;
	}
	return ans;
}

int main(){
m=read();n=read();
printf("%lld\n",(mod+_pow(m,n)-(m*_pow(m-1,n-1)%mod))%mod);
return 0;
}

```

---

## 作者：青丝、暮成雪 (赞：0)

这题还是很烧脑啊，我改了有4,5次，全是因为忘取余........

思路大致如下：

1.所有方案数有：mn=m\*m(n-1)种；

2.所有不发生越狱的方案数为：m\*(m-1)(n-1)种；

3.所以，发生越狱的方案数为：m\*m(n-1)-m\*(m-1)(n-1) =m\*(m(n-1)-(m-1)(n-1) )

4.分别对m(n-1)和(m-1)(n-1)快速幂即可。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long m,n,tot;
long long ksm(long long a,long long b)
{
        long long ans=1,d=a%100003;
    while(b>0)
        {
                if(b%2==1)
                ans=(ans*d)%100003;
                b=b/2;
                d=(d*d)%100003;
        }
    return ans;
}
int main()
{
        scanf("%lld%lld",&m,&n);
        tot=ksm(m,n);
        tot=tot-m*ksm(m-1,n-1)%100003;
        if(tot<0) tot+=100003;
        printf("%lld\n",tot);
        return 0;
}
```

---

## 作者：Mark_ZZY (赞：0)

/\*解题思路:

首先没有限制的情况下，方案数就是m^n;

然后有限制的话，第一个人取m个，

那么他后边的人全都只能(m-1)个，方案数就是m\*(m-1)^(n-1)，

两个做差，就是答案了。

PS:上网搜了题解hehe\*/

```cpp
#include<cstdio>
    long long m,n;
    const int mod=100003;
long long dg(long long n,long long m)
{
    if(m==0) return 1;
    long long a=(dg(n,m/2))%mod;
    if(m&1) return ((a*a)%mod*n)%mod; else return (a*a)%mod;
}
int main()
{
    scanf("%lld %lld",&m,&n);
    printf("%lld",(dg(m,n)-((m*dg(m-1,n-1))%mod)+mod)%mod);
}
```

---


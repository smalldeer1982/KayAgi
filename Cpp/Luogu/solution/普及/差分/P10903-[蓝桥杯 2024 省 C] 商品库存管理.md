# [蓝桥杯 2024 省 C] 商品库存管理

## 题目描述

在库存管理系统中，跟踪和调节商品库存量是关键任务之一。小蓝经营的仓库中存有多种商品，这些商品根据类别和规格被有序地分类并编号，编号范围从 $1$ 至 $n$。初始时，每种商品的库存量均为 $0$。

为了高效地监控和调整库存量，小蓝的管理团队设计了 $m$ 个操作，每个操作涉及到一个特定的商品区间，即一段连续的商品编号范围（例如区间 $[L, R]$）。执行这些操作时，区间内每种商品的库存量都将增加 $1$。然而，在某些情况下，管理团队可能会决定不执行某些操作，使得这些操作涉及的商品区间内的库存量不会发生改变，维持原有的状态。

现在，管理团队需要一个评估机制，来确定如果某个操作未被执行，那么最终会有多少种商品的库存量为 $0$。对此，请你为管理团队计算出，对于每个操作，如果不执行该操作而执行其它操作，库存量为 $0$ 的商品的种类数。

## 说明/提示

**【样例说明】**

考虑不执行每个操作时，其余操作对商品库存的综合影响：

- **不执行操作 $1$**：剩余的操作是操作 $2$（影响区间 $[2, 4]$）和操作 $3$（影响区间 $[3, 5]$）。执行这两个操作后，商品库存序列变为 $[0, 1, 2, 2, 1]$。在这种情况下，只有编号为 $1$ 的商品的库存量为 $0$。因此，库存量为 $0$ 的商品种类数为 $1$。

- **不执行操作 $2$**：剩余的操作是操作 $1$（影响区间 $[1, 2]$）和操作 $3$（影响区间 $[3, 5]$）。执行这两个操作后，商品库存序列变为 $[1, 1, 1, 1, 1]$。在这种情况下，所有商品的库存量都不为 $0$。因此，库存量为 $0$ 的商品种类数为 $0$。

- **不执行操作 $3$**：剩余的操作是操作 $1$（影响区间 $[1, 2]$）和操作 $2$（影响区间 $[2, 4]$）。执行这两个操作后，商品库存序列变为 $[1, 2, 1, 1, 0]$。在这种情况下，只有编号为 $5$ 的商品的库存量为 $0$。因此，库存量为 $0$ 的商品种类数为 $1$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1 \le n,m \le 5 \times 10^3$，$1\le L \le R \le n$。  
对于所有评测用例，$1 \le n,m \le 3 \times 10^5$，$1 \le L \le R \le n$。

## 样例 #1

### 输入

```
5 3
1 2
2 4
3 5```

### 输出

```
1
0
1```

# 题解

## 作者：jinhangdong (赞：21)

前置知识：前缀和、差分

首先我们通过差分得到一个数组 $a$。

我们发现如果撤销第 $i$ 个操作会让第 $x$ 种商品的库存量为 $0$ 那么只有两种情况：

$1$.所有操作过后第 $x$ 种商品的库存量为 $0$。

$2$.所有操作过后第 $x$ 种商品的库存量为 $1$，并且 $x$ 在第 $i$ 个操作区间内。

综上所述撤销第 $i$ 个操作后库存量为 $0$ 的商品的总数为：$\displaystyle\sum_{i=1}^{n}{[a_i=0]} + \displaystyle\sum_{i=l_i}^{r_i}{[a_i=1]}$，这个我们预处理一个前缀和就好了。

最后附上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum,a[300005],s[300005],l[300005],r[300005];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;++i)
	{
		cin>>l[i]>>r[i];
		a[l[i]]++;
		a[r[i]+1]--;
		//差分 
	}
	for(int i=1;i<=n;++i)
	{
		a[i]+=a[i-1];
		if(a[i]==0) sum++;//计算所有操作后库存量为0的商品总数 
		s[i]=s[i-1]+(a[i]==1);// 计算所有操作后库存量为1的前缀和
	}
	for(int i=1;i<=m;++i) cout<<s[r[i]]-s[l[i]-1]+sum<<endl;//答案是 l[i]~r[i]为1的个数+所有操作后为0的个数 
	return 0;
}
```

---

## 作者：DarkShadow (赞：13)

# P10903（差分,前缀和）

## 题目大意:

有 $N$ 个数和 $M$ 个操作，每次操作会把一段区间加一，问如果取消某一次操作，$N$ 个数中为 $0$ 的数的个数。

## 思路分析：

首先我们可以求出所有操作都执行后所有数的值，那么我们回答询问的时候就只需要求这个区间外 $0$ 的个数和这个区间里 $1$ 的个数，相加就可以得到答案。这里可以使用前缀和分别记录 $0$ 和 $1$ 的数量。

然后考虑怎么求最后的数组，由于本题是区间加，很容易想到差分，然后用差分就可以求出数组。

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=300005;
int n,m,d[N],pre1[N],pre2[N],chafen[N],l[N],r[N];//d表示最后的数组，chafen表示差分数组，pre1、pre2分别表示0、1的数量
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&l[i],&r[i]);
		chafen[l[i]-1]++,chafen[r[i]]--;
	}
	for(int i=1;i<=n;i++)
		d[i]=d[i-1]+chafen[i-1];
	for(int i=1;i<=n;i++)
		pre1[i]=pre1[i-1]+(d[i]==0),pre2[i]=pre2[i-1]+(d[i]==1);
	for(int i=1;i<=m;i++)
		printf("%d\n",pre1[l[i]-1]+pre2[r[i]]-pre2[l[i]-1]+pre1[n]-pre1[r[i]]);
	return 0;
}
```

---

## 作者：Getaway_Car_follower (赞：6)

感觉这题和 [P10837](https://www.luogu.com.cn/problem/P10837) 很像啊。

首先，我们可以用差分来构造出最终的 $a$。

那么我们注意到要想去除一段区间，使得里面诞生 $0$，新诞生的 $0$ 的个数为原来区间内 $1$ 的个数。

所以我们就注意到去除一段区间时的答案为 $\sum_{i=1}^{l_i-1} [a_i=0]+\sum_{i=l_i}^{r_i} [a_i=1]+\sum_{i=r_i+1}^{n} [a_i=0]$，直接前缀和就行了。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=3e5+5;
int n,m,l[N],r[N],a[N],b[N],c[N];

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>l[i]>>r[i];
		a[l[i]]++,a[r[i]+1]--;
	}
	for(int i=1;i<=n;i++){
		a[i]+=a[i-1];
		if(a[i]==0) b[i]++;
		if(a[i]==1) c[i]++;
		b[i]+=b[i-1];
		c[i]+=c[i-1];
//		cout<<b[i]<<' ';
	}
	for(int i=1;i<=m;i++){
		cout<<b[l[i]-1]+b[n]-b[r[i]]+c[r[i]]-c[l[i]-1]<<endl;
	}
	return 0;
}
```

---

## 作者：TH911 (赞：3)

> [个人Blog同步链接](https://cfyy.us.kg/2024/10/13/1/)
>
> [题目传送门](https://www.luogu.com.cn/problem/P10903)
***
update.2024.10.19：修正格式错误。
***
# 前置知识：前缀和与差分
### 前缀和
简单而言，给定数组 $a_1,a_2,a_3,\cdots,a_n$，现在想要**快速求出** $a_l,a_{l+1},a_{l+2},\cdots,a_r$ 的和。  
* 朴素算法遍历 $a_l$ 至 $a_r$，时间复杂度 $\mathcal O(r-l+1)$。  
* 使用前缀和算法，时间复杂度 $\mathcal O(1)$。  
记数组 $b_1,b_2,b_3,\cdots,b_n$ 使得 $b_i=b_{i-1}+a_i$，即 $b_i=a_i+a_2+a_3+\cdots+a_i$。  
这样 $b_r-b_{l-1}$ 即为区间和。  
**更多相关内容**[见此](https://oi-wiki.org/basic/prefix-sum/#%E5%89%8D%E7%BC%80%E5%92%8C)。
### 差分
简单而言，给定数组 $a_1,a_2,a_3,\cdots,a_n$，现在想要**快速使得** $a_l,a_{l+1},a_{l+2},\cdots,a_r$ 的值增加 $x$。  
* 朴素算法遍历 $a_l$ 至 $a_r$，时间复杂度 $\mathcal O(r-l+1)$。~~（这不一样的吗？？）~~
* 使用差分算法，时间复杂度 $\mathcal O(1)$。  
记数组 $b_1,b_2,b_3,\cdots,b_n$ 使得 $b_i=a_i-a_{i-1}$。  
这样修改 $b_l$ 为 $b_l+x$，$b_{r+1}$ 为 $b_{r+1}-x$ 即可。  
因为 $a_l$ 至 $a_r$ 全部增加 $x$，相邻差值不变，而 $a_l$ 与 $a_{l-1}$ 的差值就增加了 $x$；倘若不更改 $b_{r+1}$ 减去 $x$，那么还原时 $a_{r+1}$ 至 $a_n$ 全体都会增加 $x$，因此 $b_{r+1}$ 要减去 $x$。  
**更多相关内容**[见此](https://oi-wiki.org/basic/prefix-sum/#%E5%B7%AE%E5%88%86)。
# 处理策略
### 1.朴素算法
输入完成后枚举 $1$ 至 $m$ 哪个操作不做，暴力增加 $1$，最后统计 $0$ 的个数。  
时间复杂度：$\mathcal O(m(mn+n))$。   
**显然超时**。
### 2.差分算法
输入完成后枚举 $1$ 至 $m$ 哪个操作不做，每次都差分维护区间 $[l,r]$ 增加，最后还原时统计 $0$ 的数量即可。
时间复杂度：$\mathcal O(m(m+n))$。  
考虑到数据范围$1 \le n,m \le 3 \times 10^5$，**仍会超时**。  
得分：$20 \text{pts}$。  
**部分**代码：
```cpp
const int N=3e5;
struct node{
	int l,r;
}a[N+1];//其实不用结构体也行
int n,m,cnt,cf[N+2];//差分数组
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)scanf("%d %d",&a[i].l,&a[i].r);
	for(int i=1;i<=m;i++){
		fill(cf+1,cf+n+1,0);//初始化
		cnt=0;
    	//差分维护
		for(int j=1;j<=m;j++){
			if(j==i)continue;
			cf[a[j].l]++,cf[a[j].r+1]--;
		}//差分还原:统计0的数量 
		for(int j=1;j<=n;j++){
			cf[j]+=cf[j-1];
			if(cf[j]==0)cnt++;
		}printf("%d\n",cnt);
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
### 3.前缀和+差分优化
输入 $n$，$m$ 后输入 $l_i$，$r_i$，输入的时候便直接使用差分维护增加 $1$。  
维护完成后还原，还原时统计 $0$ 的个数 $cnt0$。这时，只需要**加上 $[l_i,r_i]$ 内不执行操作 $i$ 产生的 $0$ 的数量 $pl$ 即可**。  
显然对于区间 $[l_i,r_i]$，最坏查找可以达到 $\mathcal O(n)$，那么时间复杂度便达到了 $\mathcal O(mn)$。  
考虑到 $mn$ 最大为 $(3 \times 10^5) \times (3 \times 10^5) = 6 \times 10^{10}$，显然~~又双叒叕~~**具有超时的风险**。~~（这个超时代码就不贴了）~~  
如果我们使用一个 $cnt1_i$ 记录 $i$ 号位置是否为 $1$，那么显然 $pl=cnt1_{l_i}+cnt1_{l_i+1}+cnt1_{l_i+2}+\cdots+cnt1_{r_i}$。  
仔细看看，不难发现，这就是**快速**求 $cnt1_{l_i}$ 至 $cnt1_{r_i}$ 的和。那么我们**更改 $cnt1$ 的定义**，使 $cnt1_i$ 为 $1$ 至 $i$ 号位里 $1$ 的总数，则 $pl=cnt1_{r_i}-cnt1_{l_{i-1}}$。  
则最终答案为 $cnt0+cnt1_{r_i}-cnt1_{l_{i-1}}$。  
时间复杂度：$\mathcal O(n+m)$。
# AC代码
```cpp
//#include<bits/stdc++.h>
#include<algorithm>//个人习惯，忽略即可
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=3e5;
int n,m,l[N+1],r[N+1],cnt0,cf[N+2],cnt1[N+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d %d",l+i,r+i);
		cf[l[i]]++,cf[r[i]+1]--;//差分维护
	}
	for(int i=1;i<=n;i++){
		cf[i]+=cf[i-1];//差分还原
		cnt1[i]=cnt1[i-1];//cnt1前缀和
		if(cf[i]==0)cnt0++;//统计0的数量
		if(cf[i]==1)cnt1[i]++;//前缀和统计1~i里1的数量
	} //输出，含义如上文所述
	for(int i=1;i<=m;i++){
		printf("%d\n",cnt0+(cnt1[r[i]]-cnt1[l[i]-1]));
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：JYX0924 (赞：3)

看到这道题，我的第一反应是线段树。这道题本质上是在维护整个大区间中的 $0$ 的个数和区间 $[l_{i},r_{i}]$ 中 $1$ 的个数的和，这里写一个线段树就很好维护。

我们用 $flag_{i}$ 表示区间是否被修改过，$num_{i}$ 表示区间中被修改次数最多的子区间的修改次数，写一个线段树维护它们即可。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
#define maxn 300005 
#define mid ((l+r)>>1)
#define ls (now<<1)
#define rs (now<<1|1)
using namespace std;
ll n,m,l[maxn],r[maxn],lazy[maxn<<2],ans,flag[maxn<<2],num[maxn<<2];
void push_up(ll now) {flag[now]=(flag[ls]&flag[rs]); num[now]=max(num[ls],num[rs]);}
void push_down(ll now)
{
	lazy[ls]+=lazy[now]; lazy[rs]+=lazy[now];
	num[ls]+=lazy[now]; num[rs]+=lazy[now];
	lazy[now]=0; flag[now]=flag[ls]=flag[rs]=1;
}
void modify(ll now,ll l,ll r,ll L,ll R)
{
	if(l>=L&&r<=R) {lazy[now]++; num[now]++; flag[now]=1; return;}
	if(lazy[now]) push_down(now);
	if(mid>=L) modify(ls,l,mid,L,R);
	if(R>=mid+1) modify(rs,mid+1,r,L,R);
	push_up(now);
}
ll query(ll now,ll l,ll r)
{
	if(flag[now]) return 0;
	if(l==r) return 1;
	if(lazy[now]) push_down(now);
	ll ret=0;
	if(!flag[ls]) ret+=query(ls,l,mid);
	if(!flag[rs]) ret+=query(rs,mid+1,r);
	return ret;
}
ll query2(ll now,ll l,ll r,ll L,ll R)
{
	if(l>=L&&r<=R) if(num[now]<=1) return r-l+1;
	if(l==r) return 0;
	if(lazy[now]) push_down(now);
	ll ret=0;
	if(mid>=L) ret+=query2(ls,l,mid,L,R);
	if(R>=mid+1) ret+=query2(rs,mid+1,r,L,R);
	return ret;
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>m; for(int i=1;i<=m;i++) cin>>l[i]>>r[i];
	for(int i=1;i<=m;i++) modify(1,1,n,l[i],r[i]);
	ans=query(1,1,n);
	for(int i=1;i<=m;i++) cout<<query2(1,1,n,l[i],r[i])+ans<<"\n";
	return 0;
}
```
谢谢大家！！！

---

## 作者：Decepticon (赞：1)

### 题目链接
[P10903 [蓝桥杯 2024 省 C] 商品库存管理](https://www.luogu.com.cn/problem/P10903)

知识点：前缀和 $+$ 差分。

### 题目大意

有 $n$ 个数和 $m$ 次操作，第 $i$ 次操作可以将 $[l_i,r_i]$，这段区间的所有数加一，问取消某一次操作，这 $n$ 个数中 $0$ 的数量。

### 题目分析

因为本题是区间加，所以很容易考虑到差分数组。

我们可以先求出 $m$ 次操作后 $n$ 种商品的库存量。

取消某一次操作，这一区间中的数都会减一，这个区间中 $0$ 的数量也就是原区间中 $1$ 的数量。

然后用两个前缀和数组记录 $0$ 和 $1$ 的数量。

所以只要计算出这个区间中 $1$ 的数量和这个区间外 $0$ 的数量就可以了。

### $\text{Code}$


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,liang[300005],ch[300005],l[300005],r[300005],pri[300005],pre[300005];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        cin >> l[i] >> r[i];
        ch[l[i]]++,ch[r[i]+1]--;
    }
    for(int i = 1; i <= n; i++) liang[i] = liang[i-1]+ch[i];
    for(int i = 1; i <= n; i++){
        pri[i] = pri[i-1],pre[i] = pre[i-1];
        if(liang[i] == 0) pri[i]++;
        if(liang[i] == 1) pre[i]++;
    }
    for(int i = 1; i <= m; i++) cout << pri[l[i]-1]+pri[n]-pri[r[i]]+pre[r[i]]-pre[l[i]-1] << "\n";
    return 0;
}
```

---

## 作者：George222 (赞：1)

[cnblogs食用更佳](https://www.cnblogs.com/George222/p/18376385)

## 题目大意

有一个初始化为 $0$ 的 长度为 $n$ 的序列，现有 $m$ 个操作，每次将区间 $[L, R]$ 中的数量加 $1$，求如果**不做某个操作**将会有多少个数量为 $0$ 的量。

## 解题思路

通过将区间内所有数量增加这句话我们就能很直接的想到差分。

这题我们可以使用差分先处理将所有的操作执行后的数组，然后在算出如果减去某个操作的数组是什么样子。

不难想，减去某个操作后数组中 $0$ 的个数就是区间外本来就是 $0$ 的量的个数和区间内被变成 $1$ 的量的个数相加。

这部分代码可以使用前缀和优化。

求解公式为：
$$ans_i = \sum_{i = 1} ^ {l_i - 1} {a_i = 0} + \sum_{i = l_i} ^ {r_i} {a_i = 1} + \sum_{i = r_i + 1} ^ {n} {a_i = 0}$$

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
int l[300005], r[300005];
int a[300005], b[300005], c[300005];

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		cin >> l[i] >> r[i];
		a[l[i]]++;
		a[r[i] + 1]--;
	}
	
	for (int i = 1; i <= n; i++)
	{
		a[i] += a[i - 1]; // 前缀和
		if (a[i] == 0)
			b[i]++; // 统计为 0
		if (a[i] == 1)
			c[i]++; // 统计为 1
		b[i] += b[i - 1]; // 前缀和
		c[i] += c[i - 1]; // 前缀和
	}
	
	for (int i = 1; i <= m; i++)
	{
		cout << b[l[i] - 1] + b[n] - b[r[i]] + c[r[i]] - c[l[i] - 1] << "\n";
		// 区间外（1~l[i]-1, r[i]+1 ~ n） 为 0 的数 + 区间内为 1 的数。 
	}
	return 0; 
}

// 记录：https://www.luogu.com.cn/record/174366827 
```

---

## 作者：Lv_Boxiu (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10903)

### 思路

设数组 $a$ 为货物数量，不难发现，对于每一次操作，变化的都是连续的一段区间，所以我们可以使用差分来求出最终的 $a$。

若不执行某次操作，就相当于在最终的 $a$ 的基础上，将下标为 $[l[i],r[i]]$ 的货物数量减 $1$，所以对于每一次询问，答案即为：

$$\sum_{i=1}^{n}[a_i=0]+\sum_{j=l_i}^{r_i}[a_i=1]$$

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,cnt;
int l[300005],r[300005];     //如题
int c[300005],q[300005];     //差分数组与前缀和数组
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>l[i]>>r[i];
        c[l[i]]++;
        c[r[i]+1]--;
    }                        //输入与差分

    for(int i=1;i<=n;i++){
        q[i]=q[i-1]+c[i];
        if(q[i]==0){
            ans++;
        }
    }                        //求最终货物数

    for(int i=1;i<=m;i++){
        cnt=ans;
        for(int t=l[i];t<=r[i];t++){
            if(q[t]==1){
                cnt++;
            }
        }
        cout<<cnt<<endl;
    }                        //求出答案并输出
}
```

[AC记录](https://www.luogu.com.cn/record/174444761)

---

## 作者：xxseven (赞：1)

不错的前缀和差分练习题。

首先如果没有撤销操作，那么最终的序列可以利用差分在 $O(n+m)$ 的时间内求出。显然，无撤销操作时的 $0$ 必然会对答案有贡献。

接着考虑撤销一个操作会对答案带来什么影响。发现这一段内所有的 $1$ 都会变为 $0$。

因此，可以将数组内的 $1$ 看作 $1$，其余看作 $0$，也就是将数字转化为贡献，求一遍前缀和然后前缀和相减即可得到区间贡献。

时间复杂度 $O(n+m)$，代码见下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+6;
int n,m,l[N],r[N],a[N],f[N],ans;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0); 
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		cin>>l[i]>>r[i];
		a[l[i]]++; a[r[i]+1]--;
	}
	for(int i=1;i<=n;++i){
		a[i]+=a[i-1]; if(a[i]==0) ans++;
		f[i]=f[i-1]+(a[i]==1?1:0);//将数字转化为贡献
	}
	for(int i=1;i<=m;++i){
		cout<<ans+f[r[i]]-f[l[i]-1]<<'\n';
	}
	return 0;
}

```

---

## 作者：__O_v_O__ (赞：1)

首先，我们需要求出所有操作后的 $a$ 数组，这可以通过差分简单完成。

考虑每一个区间 $[l,r]$，去除这个区间后的答案由两部分组成：

1. 除去这个区间，其他的值为 $0$ 的数。

2. 在这个区间中，值为 $1$ 的数。

于是，我们可以维护值为 $0$ 和 $1$ 的数的前缀和，查询时使用前缀和相减即可。

**AC code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,a[300005],q0[300005],q1[300005];
struct A{int l,r;}b[300005];
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>b[i].l>>b[i].r;
		a[b[i].l]++,a[b[i].r+1]--;
	}
	for(int i=1;i<=n;i++)a[i]+=a[i-1];
	for(int i=1;i<=n;i++){
		q0[i]=q0[i-1]+(a[i]==0);
		q1[i]=q1[i-1]+(a[i]==1);
	}
	for(int i=1;i<=m;i++){
		int ans1=q0[b[i].l-1]+(q0[n]-q0[b[i].r]),
			ans2=q1[b[i].r]-q1[b[i].l-1];
		cout<<ans1+ans2<<'\n';
	}
	return 0;
}
```

---

## 作者：HYdroKomide (赞：0)

### 题意：
看似有些复杂，实际上原本题意相当于先做 $m$ 次区间加，然后在这个基础上询问 $m$ 次。因为询问区间肯定不包含 $0$，所以每次询问实际上需要求的只是这个区间 $1$ 的个数（少了这次区间操作，这些货架就空了）。

于是题意转化成了，$m$ 次操作，每次区间加一，每次询问求整体 $0$ 的个数和区间 $1$ 个数之和。

### 思路：
线段树板子。每个结点存三个标签：

- 区间 $0$ 个数（存为 $t0$ 数组）；
- 区间 $1$ 个数（存为 $t1$ 数组）；
- 懒标记（遍历时需要下传）。

每次上传时合并标签，整区间加时维护懒标记。对区间相关标签进行更新（**如果为加一**，则 $t1$ 更新为原 $t0$，$t_0$ 赋为 $0$，否则都赋为 $0$ 即可）。

此时，$t0_1$ 存的就是整体 $0$ 的个数。每次将区间查询答案加上此值即可。复杂度 $O(n\log n)$。

### 程序如下：
```cpp
#include<cstdio>
using namespace std;
const int N=3e5+5;
int n,q,l[N],r[N];
int t0[N*4],t1[N*4],tag[N*4];
int ls(int x){return x<<1;}
int rs(int x){return x<<1|1;}
void pushup(int x){
    t0[x]=t0[ls(x)]+t0[rs(x)];
    t1[x]=t1[ls(x)]+t1[rs(x)];
}
void modify(int x,int tg){
    tag[x]+=tg;
    if(tg==0)return;
    else if(tg==1){//特判区间是否只加1
        t1[x]=t0[x];
        t0[x]=0;
    }
    else t0[x]=t1[x]=0;
}
void pushdn(int x){
    modify(ls(x),tag[x]);
    modify(rs(x),tag[x]);
    tag[x]=0;
}
void build(int x,int l,int r){//建树时全部都是0
    if(l==r){
        t0[x]=1;
        return;
    }
    int mid=(l+r)>>1;
    build(ls(x),l,mid);
    build(rs(x),mid+1,r);
    pushup(x);
}
void update(int x,int l,int r,int L,int R){
    if(L<=l&&R>=r){
        tag[x]++;
        t1[x]=t0[x];//区间加一
        t0[x]=0;
        return;
    }
    pushdn(x);
    int mid=(l+r)>>1;
    if(L<=mid)update(ls(x),l,mid,L,R);
    if(R>mid)update(rs(x),mid+1,r,L,R);
    pushup(x);
}
int query(int x,int l,int r,int L,int R){
    if(L<=l&&R>=r)return t1[x];
    pushdn(x);
    int mid=(l+r)>>1,ret=0;
    if(L<=mid)ret+=query(ls(x),l,mid,L,R);
    if(R>mid)ret+=query(rs(x),mid+1,r,L,R);
    return ret;
}
int main(){
    scanf("%d%d",&n,&q);
    build(1,1,n);
    for(int i=1;i<=q;i++){
        scanf("%d%d",&l[i],&r[i]);
        update(1,1,n,l[i],r[i]);//先修改，存下询问，后面查询
    }
    for(int i=1;i<=q;i++)printf("%d\n",t0[1]+query(1,1,n,l[i],r[i]));
    return 0;
}
```
### THE END

---


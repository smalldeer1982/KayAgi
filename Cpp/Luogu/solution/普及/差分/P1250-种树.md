# 种树

## 题目背景

一条街的一边有几座房子，因为环保原因居民想要在路边种些树。

## 题目描述

路边的地区被分割成块，并被编号成 $1, 2, \ldots,n$。每个部分为一个单位尺寸大小并最多可种一棵树。

每个居民都想在门前种些树，并指定了三个号码 $b$，$e$，$t$。这三个数表示该居民想在地区 $b$ 和 $e$ 之间（包括 $b$ 和 $e$）种至少 $t$ 棵树。

居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq n \leq 3 \times 10^4$，$1 \leq h \leq 5 \times 10^3$。
- $1 \leq b_i \leq e_i \leq n$，$1 \leq t_i \leq e_i - b_i + 1$。

## 样例 #1

### 输入

```
9
4
1 4 2
4 6 2
8 9 2
3 5 2```

### 输出

```
5
```

# 题解

## 作者：kpl000 (赞：102)

解题思路

贪心，要种树种得少，就要使一棵树给多个区间使用，这样，尽量在重叠区间种树即可，而重叠位置一定是区间尾部。处理问题时，先按所有区间的结束位置从小到大排序，若结束位置相同，则按开始位置从大到小排序。之后依次处理每个区间，先在第一个区间尾部种满足要求的树，对下一个区间，看差多少棵就在该区间尾部种多少。

步骤：

①先按照b[]从小到大快排

②对每个区间依次处理

a.从前到后扫描这个区间，统计点的个数；

b.若没有超过要求的点数，则从该区间后向前扫描，添加覆盖点。

③输出ans

代码如下：

```cpp
#include<iostream>
using namespace std;
struct line{int s,e,v;}a[5005],mid;
int n,m,used[30005]={0};
void qsort(int L,int r)//快排
{  int i=L,j=r;mid=a[(L+r)/2];
   while(i<=j)
   {  while(a[i].e<mid.e)i++;
      while(a[j].e>mid.e)j--;
      if(i<=j)swap(a[i++],a[j--]);
   }
   if(L<j)qsort(L,j);
   if(i<r)qsort(i,r);
}
void Init()
{  int i;
   cin>>n>>m;
   for(i=1;i<=m;i++)cin>>a[i].s>>a[i].e>>a[i].v;
   qsort(1,m);
}
void Solve()
{  int i,j,k,ans=0;
   for(i=1;i<=m;i++)//依次处理m个区间
   {  k=0;
      for(j=a[i].s;j<=a[i].e;j++)if(used[j])k++;//统计区间内已标记的数
      if(k<a[i].v)
         for(j=a[i].e;j>=a[i].s;j--)
             if(!used[j]){used[j]=1;k++;ans++;if(k==a[i].v)break;}
   }
   cout<<ans<<endl;
}
int main()
{  Init();
   Solve();
}
还有其他算法，例如：树状数组，差分约束系统
```

---

## 作者：哔哩哔哩 (赞：86)

在一本通上看到的 在这里提供题解。
### 【思路】
可以用贪心做的嘛。  
想要种树种得少，就要一棵树在多个区间同时出现。  
所以，在重叠部分种尽可能多的树即可。  
然而重叠部分一定在区间的尾部。  
所以先对结束苇子进行排序，然后依次在区间的尾部从前往后种树直到满足要求，对于下一个区间，看看差多少树，就在结尾补多少。

于是贪心的思想就很容易出来了：
1. 按结束位置排序
2. 对每个区间一次处理
	1. 从前往后扫描区间，统计已有的树的个数
    2. 若已选点超过要求个数，则continue
    3. 否则从后往前，添加缺少的覆盖点
3. 输出ans

### 【程序】
```cpp
#include<bits/stdc++.h>
using namespace std;
struct line{int s,e,v;}a[5005];
int n,m,ans=0;
bool used[30005]={0};//判断是否已经有点
bool cmp(line a,line b)
{
    return a.e<b.e;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&a[i].s,&a[i].e,&a[i].v);
    sort(a+1,a+1+m,cmp);//排序
    for(int i=1;i<=m;i++)
    {
        int k=0;//用来统计区间已有的树的个数
        for(int j=a[i].s;j<=a[i].e;j++) if(used[j]) k++;//统计已有点的个数
        if(k>=a[i].v) continue;//已满足，continue
        for(int j=a[i].e;j>=a[i].s;j--)//不满足，在结尾处加入
        {
            if(!used[j])
            {
                used[j]=1;
                k++;
                ans++;//答案+1
                if(k==a[i].v) break;//满足退出
            }
        }
    }
    printf("%d",ans);//输出答案
    return 0;
}
```

---

## 作者：浅色调 (赞：68)

### Slution：

　　本题差分约束。。。

　　对于每个约束条件$u\rightarrow v\;min = c$，可以理解为$sum[v]-sum[u-1]\geq c$（**$sum[x]$表示的是$x$的前缀和**）。

　　因为要使最后植的树尽可能的少，所以每个小区间植的树要在满足限制的情况下尽可能的少，于是我们可以罗列出以下约束条件：

　　　　1、$sum[v]-sum[u-1]\geq c$（表示区间$[u,v]$至少植$c$棵树）

　　　　2、$0\leq sum[v]-sum[v-1]\leq 1$（表示$sum[v]$最多比$sum[v-1]$大$1$）

　　那么我们按照上述约束条件建图，第一个约束条件令边$w[u,v]=c$表示$sum[v]$比$sum[u]$大$c$，第二个约束条件是闭区间所以建边$w[u+1,u]=-1$和$w[u-1,u]=0$（**注意建边方向$u+1\rightarrow u=-1$而不是$u\rightarrow u+1=1$，因为后者直接和$u-1\rightarrow u=0$冲突了**）。

　　最后$spfa$跑最长路，输出$dis[n]$就好了。
  
  $\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9172480.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
using namespace std;
const int N=100005,inf=23333333;
int n,m,to[N],net[N],w[N],dis[N],h[N],cnt;
bool vis[N];
queue<int>q;

il int gi(){
    int a=0;char x=getchar();
    while(x<'0'||x>'9')x=getchar();
    while(x>='0'&&x<='9')a=(a<<3)+(a<<1)+x-48,x=getchar();
    return a;
}

il void add(int u,int v,int c){to[++cnt]=v,net[cnt]=h[u],h[u]=cnt,w[cnt]=c;}

int main(){
    n=gi(),m=gi();
    int u,v,c;
    while(m--){
        u=gi(),v=gi(),c=gi();
        add(u-1,v,c);
    }
    For(i,0,n){
        if(i!=0)add(i-1,i,0),dis[i]=-inf;
        if(i!=n)add(i,i-1,-1);
    }
    q.push(0);
    while(!q.empty()){
        int u=q.front();vis[u]=0;q.pop();
        for(int i=h[u];i;i=net[i])
            if(dis[to[i]]<dis[u]+w[i]){
                dis[to[i]]=dis[u]+w[i];
                if(!vis[to[i]])q.push(to[i]),vis[to[i]]=1;
            }
    }
    cout<<dis[n];
    return 0;
}
```

---

## 作者：最喜欢saber了 (赞：30)

[题目传送门](https://www.luogu.org/problemnew/show/P1250)

这道题的题面我看了很长时间才弄懂，在某位dalao的帮助下，我知道了这道题是一个与差分约束系统有关的题，

那么，差分约束系统是什么呢？

这个名字在我这个蒟蒻觉得很高级，但在查完资料后，我来分享一下什么是差分约束系统。（借鉴一下一个叫蓝书的东西）（若各位dalao了解，可以跳过）

嗯嗯，~~（敲黑板）~~

差分约束系统是一种特殊的 $n$ 元一次不等式组，它包含 $n$ 个变量 $x_{1}$ ~ $x_{n}$以及 $m$ 个约束条件，每个约束条件是由两个变量 **做差** 得来，

形如 $x_{i}-x_{j}<=c_{k}$,其中$c_{k}$是常数（可以是非负数，也可以是负数），且$1<=i,j<=n$, $1<=k<=m$。我们要解决的问题是：求一组解 $x_{1}=a_{1},x_{2}=a_{2}......x_{n}=a_{n}$，使所有约束条件得到满足。

差分约束系统的每个约束条件$x_{i}-x_{j}<=c_{k}$ 可变形为 $x_{i}<=x_{j}+c_{k}$ 。 这与单源最短路问题中的三角不等式 $dis[y]<=dis[x]+z$ 很相似。所以，可以把每个变量 $x_{i}$ 有向图中的一个结点 $i$ ，于是我们可以对于每一个约束条件$x_{i}-x_{j}<=c_{k}$，从结点 $j$ 向 结点$i$ 连一条权值为 $c_{k}$ 的有向边。

注意到，如果{$a_{1}$ , $a_{2}$ , $a_{3}$ ......$a_{n}$}是一组解，那么对于任意常数 $ d$  ,{$a_{1}+d$ , $a_{2}+d$ , $a_{3}+d$ ......$a_{n}+d$}也是一组解，为什么呢，因为它们做差后 $ d$ 刚好被消掉。

 设$dis[0]=0$,以$0$为起点求单源最短路，若图中存在负环，则给定的差分约束系统无解（当然本题是有解的），否则 , $x_{i}=dis[i]$就是差分约束系统的一组解。
 
好下面进入本题：

这个题我们拥有的条件是输入$B,E,T$,在前缀和数组$sum$中，$sum_{E}-sum_{B-1}>=T$,那么这样就相当于给 $  B-1 $ 和 $E$ 连了一条权值为$T$的边，在这样的情况下找出最长路。

但我们变一下形：$sum_{B-1}-sum_{E}<=T$,那么这样就相当于给 $ E $ 和 $B-1$ 连了一条权值为$T$的边，在这样的情况下找出最短路。


同时，两个点之间（相当于左边的一个点）只能种0~1棵树； 所以$0<=sum_{i}-sum_{i-1}<=1$

移项变为 $-1<=sum_{i-1}-sum_{i}<=0$

综上得到$sum_{i-1}-sum_{i}<=0$与$sum_{i}-sum_{i-1}<=1$

所以会有两条边分别是$(i,i-1,0)$,$(i-1,i,1)$，

这样就可以求最短路了。

但要注意一点

但是在最长路中要注意一点，如果初始化为 $0$ 的话最短路$0+0=0$是不能更新$0$的，
于是这个题有两个解决方案。 

一是从各个点都做一次$SPFA$（本题不能用$dijkstra$算法，因为有-1）
，这样避免了各个点之间的$dis[i]=0$不能更新$dis[i]=0$从而不能进队的情况，但这种做法是63分；

另一个就是设置一个虚拟源点$(n+1)$，它到任意一点的距离都是固定的inf，这样就可以用0的权值去更新那些有0的点了。

这样只做了一次$SPFA$，时间复杂度就降低了。

下面献上我的垃圾代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<cctype>
#include<queue>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){
    x=0;T f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=f;
}
const int inf = 0x3f3f3f;
const int maxa = 3e4+10;
const int maxm = 1e5+10;
struct node{
	int next,to,dis;
}e[maxm];
int cnt,dis[maxa],vis[maxa],head[maxa],n,h;
void add(int u,int v,int w){
	e[++cnt].next=head[u];
	e[cnt].to=v;
	e[cnt].dis=w;
	head[u]=cnt;
}
void spfa(int s){
	queue<int>q;
	for(int i=1;i<=n;++i){
		dis[i]=inf;
		vis[i]=0;
	} 
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].dis){
				dis[v]=dis[u]+e[i].dis;
				if(vis[v]==0){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return;
}
int main(){
	int x,y,z,s;
	read(n);read(h);
	s=n+1;
	for(int i=0;i<=n;++i){
		add(s,i,0);
	}
	for(int i=1;i<=h;++i){
		read(x);read(y);read(z);
		add(y,x-1,-z);
	}
	for(int i=1;i<=n;++i){
		add(i-1,i,1);
		add(i,i-1,0);
	}
	spfa(s);
	int minn = inf;
	for(int i=0;i<=n;++i){
		minn=min(minn,dis[i]);
	}
	cout<<dis[n]-minn;
	return 0;
}
```

谢谢观看，请记住，我太弱了。

---

## 作者：三好代表 (赞：26)

### **我来总结一下楼底下最常用的两种办法**
1.贪心

2.差分约束

那么我们先来讲，**贪心版《种树》**

大家可能知道有一个题和这个类似，那个是钉钉子而这个是种树

我们可以借用~~钉钉子的思路来想~~，首先这个是让你求最小值，而且每个人都有自己划定的区间，并且他们还要求在这段区间内最少种T棵树。

那么我们既要满足最少种树数，而且要满足每个人的要求。好在的是，题目中说过区间和区间之间可能会有一段重叠，那么我们要抓住这个机会尽可能多的在每一段重复区间内多种树，所以就会产生一个连锁反应，就是上一个重复区间内种的树可能会满足下一个人的要求，那么这个人就可以略过去，以达到最少数的目的。

（以下是贪心代码，体会一下）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 31000;
int n,m,ans=0;
bool u[N]={0};
struct Edge{
	int x,y,z;
}a[N];
bool cmp(Edge a,Edge b)
{
	return a.y<b.y;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		cin>>a[i].x>>a[i].y>>a[i].z;
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		int sum=0;
		for(int j=a[i].x;j<=a[i].y;j++)
		if(u[j]) sum++;//统计已有的数量
		if(sum>=a[i].z) continue;//满足就继续
		for(int k=a[i].y;k>=a[i].x;k--)//不满足情况
		{
			if(!u[k])
			{
				u[k]=1;
				sum++;
				ans++;//答案++
				if(sum==a[i].z) break;//直到满足，退出
			}
		}
	}
	cout<<ans;//输出最后答案（即最少的树的数量）
	return 0;
}
```


------------

接下来我们讲，**差分约束版《种树》**

感谢[lovewhy](https://www.luogu.org/space/show?uid=39886)学长的细致讲解

我们都知道差分约束是用于最短路不等式问题的

详见[差分约束](https://blog.csdn.net/whereisherofrom/article/details/78922648)

这里我们利用差分约束解决最短路不等式的性质来看

我们想在区间内种最少的树，所以根据性质

我们可以列出两个差分约束公式

**1.sum[x]-sum[y-1]>=c;(这里是指在区间[y,x]中至少种c棵树)**

**2.0<=sum[x]-sum[x-1]<=1;（这里是指一个单位长度内最多种1棵树）
**

根据公式，我们可以建边，但是建边是y+1->y=-1而不是y->y+1=1

建好边我们就可以跑一边SPFA啦，最少种树数也就出来了！

（差分约束代码，体会一下）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 31000;
const int M = 110000;
int n,m;
int dis[N];
bool vis[N];
int head[N],num;
struct Edge{
	int to,next,w;
}s[M];
void add(int u,int v,int w)//根据公式建边
{
	s[++num].w=w;
	s[num].next=head[u];
	head[u]=num;
	s[num].to=v;
}
void spfa(int x)//SPFA经典操（ban）作（zi）
{
	queue<int> q;
	q.push(x);
	for(int i=0;i<=n+1;i++)
		dis[i]=1;
	dis[x]=0;vis[x]=1;
	while(!q.empty())
	{
		int g=q.front();
		q.pop();
		vis[g]=0;
		for(int i=head[g];i!=-1;i=s[i].next)
		{
			int t=s[i].to;
			if(dis[t]>dis[g]+s[i].w)
			{
				dis[t]=dis[g]+s[i].w;
				if(!vis[t])
				{
					q.push(t);
					vis[t]=1;				
				}
			}
		}
	}
}
int main()
{
	int a,b,c,minn=123456789;
	memset(head,-1,sizeof(head));
	cin>>n>>m;
	int y=n+1;
	for(int i=0;i<=n;i++) add(y,i,0);
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>c;
		add(b,a-1,-c);
	}
	for(int i=1;i<=n;i++)//建边操作
	{
		add(i-1,i,1);
		add(i,i-1,0);
	}
	spfa(y);
	for(int i=0;i<=n;i++)//取最小值
		minn=min(minn,dis[i]);
	cout<<dis[n]-minn<<endl;
	return 0;
}
```

**本蒟蒻也就只会这么多了，还要感谢楼下的提示！**

---

## 作者：暮天闻角 (赞：20)

~~本蒟蒻强行码了两天Orz~~

做法是 贪心 $+$ 二分 $+$ 线段树，，

首先按 **右端点排序**

因为你要让树 **尽量地种在被区间覆盖次数最多的地方**

所以每次贪心地从右边开始种树就行了

（就可以尽量地让右边区间覆盖到这些位置了 QwQ）

如果你要AC这道题，以上贪心就足够了~~（纯属口胡）~~

---------------

考虑优化这个暴力算法

首先处理当前询问的时候

要先查询当前区间已经种了多少棵树

那么就可以用线段树区间查询了

设需要种 $t$ 棵树，已经种了 $x$ 棵树

那么还需要种 $(t-x)$ 棵树

本次查询贡献也就是 $(t-x)$ （如果小于0，就说明根本不需要种树，也不需要统计贡献）

也就是要 **从右端点开始找到一个区间 $[\,l\,,\,r\,]$ ，满足区间里有 $(t-x)$ 个位置还没有种树**

所以就可以二分满足条件的左端点啦（右端点始终为该查询的右端点啦 ）

然后区间修改 $[\,l\,,\,r\,]$ 就行惹 $\mathfrak{QwQ}$

代码是 **用线段树维护还没种树的位置的数量**

然后略丑了一点 $\mathfrak{QAQ}$

不过常数海星 $\mathfrak{QwQ}$ ，复杂度 $O(qlog^2n)$

```
#include <cstdio>
#include <algorithm>

#define N 30005
#define rep(x) for(register int i=1;i<=x;++i)

struct IO{
//读入优化
//输出优化
    IO(){}
#define gc getchar
    inline IO&operator>>(int&_){
        _=0;char c=gc();while(c>'9'||c<'0')c=gc();
        while(c>='0'&&c<='9')_*=10,_+=c&15,c=gc();return*this;
    }
    inline IO&operator<<(int x){
        if(!x){putchar(48);goto f;}
        static int wt[40],len;len=0;
        for(;x;x/=10) wt[++len]=x%10;
        while(len)putchar(wt[len--]+48);
        f: putchar('\n'); return *this;
    }
    inline int operator()(){
        int _=0;char c=gc();while(c>'9'||c<'0')c=gc();
        while(c>='0'&&c<='9')_*=10,_+=c&15,c=gc();return _;
    }
#undef gc
}io;

int n,h;

struct Q{
    int l,r,t; Q(){}
    Q(int t,int r,int l):l(l),r(r),t(t){}
    inline bool operator<(Q o)const{return r==o.r?t>o.t:r<o.r;}
}q[N];

struct Sgt{ int sum; bool cov; }e[N<<2];

#define St 1,1,n
#define tl id<<1
#define tr id<<1|1
#define lson tl,l,mid
#define rson tr,mid+1,r

inline void pushup(int id){e[id].sum=e[tl].sum+e[tr].sum;}

inline void pushdown(int id){
    if(!e[id].cov) return;
    e[tl].cov=e[tr].cov=1;
    e[tl].sum=e[tr].sum=e[id].cov=0;
}

inline void build(int id,int l,int r){
    e[id].cov=0; 
    if(l==r){
        e[id].sum=1;
        return;
    }
    int mid=l+r>>1;
    build(lson);
    build(rson);
    pushup(id);
}

inline int Query(int id,int l,int r,int ll,int rr){
    if(ll<=l&&r<=rr)return e[id].sum;
    pushdown(id); int mid=l+r>>1;
    if(rr<=mid) return Query(lson,ll,rr);
    if(ll> mid) return Query(rson,ll,rr);
    return Query(lson,ll,rr)+Query(rson,ll,rr);
}

inline void update(int id,int l,int r,int ll,int rr){
    if(ll<=l&&r<=rr)return e[id].cov=1,e[id].sum=0,void();
    if(e[id].cov) return; int mid=l+r>>1;
    if(ll<=mid) update(lson,ll,rr);
    if(rr> mid) update(rson,ll,rr);
    pushup(id);
}

int Ans;

#define Len r-l+1-have
//r-l+1 是区间[l,r]的长度
//have 是区间[l,r]里没种树的位置的数量
//两个一减就是[l,r]里已经种了的树的数量 QwQ

int main(){
    io>>n>>h; rep(h) q[i]=Q(io(),io(),io());
    //这里读入顺序是从左至右的 QvQ
    build(St); std:: stable_sort(q+1,q+h+1);
    rep(h){
        int need=q[i].t,
        l=q[i].l,r=q[i].r;
        int have=Query(St,l,r);
        need=need-(r-l+1-have);
        if(need <= 0) continue;
        while(l<=r){
            int mid=l+r>>1;
            if(Query(St,mid,q[i].r)>need)l=mid+1;
            else r=mid-1;
        }
        update(St,l,q[i].r);Ans+=need;
    }
    io<<Ans;
    return 0;
}
```

---

## 作者：wjyyy (赞：17)

给出一些约束条件，如何求出任意两个$x$值之间的大小关系？

$\left\{\begin{matrix}x_1-x_2 \geq 5\\ x_2-x_3 \geq 7\\ x_3-x_4 \geq 3\end{matrix}\right.$


可以看出
$x_1-x_2 \geq 5$和$x_2-x_3\geq7$可以相加而求得$x_1-x_3\geq12$

由不等式联立的条件，在大于号中我们知道约束程度最大的就是约束条件最大的。

根据这个我们就可以把数学问题转化为图论中的最长路，例题见[**P1250 种树**](https://www.luogu.org/problemnew/show/P1250)

这个题我们拥有的条件是，输入$B,E,T$，在前缀和数组$a$中，$a_E-a_{B-1}\geq T$

那么这样就相当于给$B-1$和$E$连了一条权值为$T$的边，在这样的情况下找出最长路。

同时，两个点之间（相当于左边的一个点）只能种0~1棵树；
所以$0\leq a_i-a_{i-1}\leq1$

移项变为
$ a_i-a_{i-1}\geq0$和$a_{i-1}-a_i\geq -1$

所以会有两条边分别是$(i,i-1,0),(i-1,i,-1)$这样就可以求最长路了。

但是在最长路中要注意一点，如果初始化为0的话0+0是不能更新0的，这个题有两个解决方案。
一是从各个点都做一次SPFA（本题不能用dijkstra，有-1），这样避免了各个点之间的dis=0不能更新dis=0从而不能进队的情况，这种做法是63分；

另一个就是设置一个虚拟源点$(n+1)$，它到任意一点的距离都是固定的$inf$，这样就可以用$0$的权值去更新那些有$0$的点了。只做了一次SPFA，时间复杂度就降低了。

下面贴代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<iostream>
using namespace std;
int n,m;
struct node
{
    int n,v;
    node *next;
    node (int n,int v)
    {
        this->n=n;
        this->v=v;
        next=NULL;
    }
    node(){next=NULL;}
};
node head[30002],*tail[30002];
deque<int> q;
bool used[30002];
int dis[30002];
void spfa(int s)
{
    memset(used,0,sizeof(used));
    memset(dis,0,sizeof(dis));
    q.push_back(s);
    used[s]=1;
    int k;
    while(!q.empty())
    {
        k=q.front();
        q.pop_front();
        used[k]=0;
        node *p=&head[k];
        while(p->next!=NULL)
        {
            p=p->next;
            if(dis[k]+p->v>dis[p->n])
            {
                dis[p->n]=dis[k]+p->v;
                if(!used[p->n])
                {
                    used[p->n]=1;
                    if(q.empty()||dis[p->n]<dis[q.front()])
                        q.push_front(p->n);
                    else
                        q.push_back(p->n);
                }
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    int s=n,t=1,a,b,c;
    tail[0]=&head[0];
    for(int i=1;i<=n+1;i++)
    {
        tail[i]=&head[i];
        if(i==n+1)
            break;
        tail[i]->next=new node(i-1,-1);
        tail[i-1]->next=new node(i,0);
        tail[i]=tail[i]->next;
        tail[i-1]=tail[i-1]->next;
    }
    for(int i=0;i<=n;i++)
    {
        tail[n+1]->next=new node(i,123456789);
        tail[n+1]=tail[n+1]->next;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        if(a-1<s)
            s=a-1;
        if(b>t)
            t=b;
        tail[a-1]->next=new node(b,c);
        tail[a-1]=tail[a-1]->next;
    }
    spfa(n+1);
    printf("%d\n",dis[n]-123456789);
    return 0;
}

```

---

## 作者：MloVtry (赞：8)

似乎楼下的差分都是最短路没有最长路的程序？我过来贴个最长路好了

隐含条件楼下都有，就直接建边了

u-1 ----> v it (对于题目中区间的限制,设从u到v种it棵)

k-1 -----> k 0

k --------> k-1 -1

这时的dis[j]表示前j家种了多少颗树，ans=dis[n]

所以对于区间限制，我们要从u-1连向v，因为种在端点是可行的，所以v处要比u-1处多it颗（一开始连的u--->v直接挂了）

然后是代码

 
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 30010
#define M 100000
#define R register
using namespace std;
int n,m;
int head[N],to[M],next[M],len[M],tot;
void buid(int u,int v,int l)
{
    next[++tot]=head[u];
    head[u]=tot;
    to[tot]=v;
    len[tot]=l;
}
int init[N],dis[N];
queue<int> q;
void spfa()
{
    memset(init,0,sizeof(init));
    memset(dis,-1,sizeof(dis));
    dis[0]=0,init[0]=1,q.push(0);
    while(!q.empty())
    {
        R int now=q.front();q.pop();init[now]=0;
        for(int i=head[now];i;i=next[i])
        {
            R int j=to[i];
            if(dis[j]<dis[now]+len[i])
            {
                dis[j]=dis[now]+len[i];
                if(!init[j])
                {
                    q.push(j);
                    init[j]=1;
                }
            }
        }
    } 
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;++i)
    {
        buid(i,i+1,0);
    }
    for(int i=1;i<=n;++i)
    {
        buid(i,i-1,-1);
    }
    for(int i=1;i<=m;++i)
    {
        R int u,v,it;
        scanf("%d%d%d",&u,&v,&it);
        buid(u-1,v,it);//De_bug buid(u,v,it) X
    }
    spfa();
    printf("%d",dis[n]);
    return 0;
 } 

```

---

## 作者：野菜汤 (赞：5)




```delphi
var i,j,k,m,n,o,p,tmp,sum,h,q:longint;
    a:array[1..30000] of longint;
    f:array[1..5000,1..3] of longint;
procedure zhong(l,r,ss:longint);{种树的处理}
var i,j,k,m,n:longint;
begin
    sum:=ss;
    for j:=l to r do begin{先排除掉已有树}
      if a[j]=1 then dec(sum);
    end;
    if sum>0 then for j:=r downto l do begin{从右往左种树}
      if sum=0 then break;
      if a[j]<>1 then begin a[j]:=1;inc(tmp);dec(sum);end else continue;
    end;
end;

procedure qsort(l,r:longint);{快排程序}
var b,m,i,j,k:longint;
begin
  i:=l;
  j:=r;
  m:=f[(l+r)div 2,2];{对右端点进行排序}
  repeat
    while f[i,2]<m do i:=i+1;
    while f[j,2]>m do j:=j-1;
    if i<=j then
    begin
      b:=f[i,1];f[i,1]:=f[j,1];f[j,1]:=b;
      b:=f[i,2];f[i,2]:=f[j,2];f[j,2]:=b;
      b:=f[i,3];f[i,3]:=f[j,3];f[j,3]:=b;
      inc(i);dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;

begin
  read(n,h);
  for i:=1 to h do read(f[i,1],f[i,2],f[i,3]);
  qsort(1,h);
  for i:=1 to h do begin
    zhong(f[i,1],f[i,2],f[i,3]);
  end;
  write(tmp);
end.
```
[color=navy]题解：[/color]
        [color=palevioletred]首先，这题的数据点是十分强大的，各种刁难，所以我们就需要用最无懈可击的解法来解题。[/color]
        [color=peru]**此题解题思路很简单，先用快排对右端点进行排序，当然你要用左端点排也可以，但肯定会是错的，原因自己想。然后在每个范围内，从最右边开始种树，以确保重叠树的数目最多，也就是最优。**[/color]
        [color=offwhite]然后对于细节的处理，也就是如何种树的过程，这里细讲一下。首先先一个循环搜一下当前范围已经有几棵树了，然后对没有种的树从右边往左边中。记住，如果种的途中发现这个位置已经有树了，要跳到下一个位置，这种情况是存在的。[/color]
        [color=royalblue]以下是个人的ac程序。[/color]
```cpp
```

---

## 作者：Noelt3 (赞：4)

# 题目描述

一条街的一边有几座房子。因为环保原因居民想要在路边种些树。路边的地区被分割成块，并被编号成$1$..$N$。每个部分为一个单位尺寸大小并最多可种一棵树。每个居民想在门前种些树并指定了三个号码$B$，$E$，$T$。这三个数表示该居民想在B和E之间最少种T棵树。当然，$B≤E$，居民必须记住在指定区不能种多于区域地块数的树，所以$T≤E-B+l$。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。

# 输入格式

第一行包含数据$N$,区域的个数($0<N≤30000$)；
第二行包含H，房子的数目$(0<H≤5000)$；
下面的H行描述居民们的需要：$B$ $E$  $T$，$0<B≤E≤30000$，$T≤E-B+1$。
# 输出格式
输出文件只有一行写有树的数目


# 输入输出样例
## 输入 #1
```
9

4

1 4 2

4 6 2

8 9 2

3 5 2
```
## 输出 #1
```
5

```

# 思路：

很明显是一道贪心的题，每个区间，种上规定数量的树，保证满足所有区间的要求，且保证树木最少，如何保证？**让树尽量种在区间之间重复的部分**，也就是区间并集部分，不难理解，两个区间的并集部分，一定在前一个区间的末尾，**或者是说在区间尾部靠前的区间的尾部**~~（请好好理解为什么）~~

#### 贪心思路已经出来即：让树尽量种在区间之间重复的部分


#### 新问题 Q1：如何保存区间并遍历？ （针对我自己）
A 结构体！
```cpp
struct line    //建立一个区间结构体
{
    int b,e;  //b是begin e是end  w是这个区间要      
    int w;          //求种下的树
};
```

然后我们以end为标准将区间排序目的是按次序找到区间的并集！

之后每个区间先检查是否还需要种树（在上个区间种完树后可能顺便也给后面区间也满足了）

若要种树从后往前检查是否能种,能就种，勿忘检查是否满足条件！

遍历检查完说有区间后种下的树即为最少！

代码如下
```cpp
#include<bits/stdc++.h>

using namespace std;
const int N=300000+15;
struct line         //b:begin; e:end; w:cnt of tree need be plant;
{
    int b,e,w;
}l[N];
int isP[N]={0};           //记录此点是否已经种树
bool cmd(line a,line b)  //用于快速排序比较函数
{
    return a.e<b.e;
}
int main()
{
    int anc=0;
    int n;
    cin>>n;
    int h;
    cin>>h;             
    for(int i=0;i<h;i++)
    {
        cin>>l[i].b>>l[i].e>>l[i].w;
    }                          //以上部分为输入
    sort(l,l+h,cmd);                //区间排序
    for(int i=0;i<h;i++)            //遍历区间
    {
        int k=0;         //记录是此区间种了多少树
        for(int j=l[i].b;j<=l[i].e;j++)      //查看此区间已经种树的数量
        {
        
            if(isP[j])
            {
                k++;
            }
        }
        if(k>=l[i].w)continue;         //满足要求跳过种树环节
        for(int j=l[i].e;j>=l[i].b;j--)  //开始种树 
        { 
            if(!isP[j]){                 //此点无树
                isP[j]=1;                //种下一颗树
                anc++;                    //种树+1
                k++;                       //此区间种树+1
                if(k>=l[i].w)break;          //判断是否满足
            }
        }
    }
    cout<<anc;                            //输出答案
    return 0;
}
```
究极萌新第一次发题解，请多多指教

























---

## 作者：gujialiang123 (赞：3)

   上一篇差分约束的题解是建超级汇点求最短路，这里我写一篇常规思路的差分约束题解。
    
   首先转化思路，这道题不能直接套查分约束，我们设sum(x)表示[0,x]区间内包含的树木的数量，那么[l,r]区间内包含的树木的数量就可以用sum(r)-sum(l-1)来表示。
    
   根据题意，每次给定l,r,t,使得sum(r)-sum(l-1)>=t,那我们就建一条(l-1) -> (r) 的，边权为t的边；
    
   然后由于每个点我们必须选种或者不种，我们要保证对于任意i，0<=sum(i)-sum(i-1)<=1,也就是给每个i到i-1建一条边权为-1的边，给每个i-1到i建一条边权为 0的边。
    
   最后我们要求的是sum(n)-sum(0)>=ans,所以我们从0做起点，跑最长路，求出dis[n]即为1-n区间内种树最小数量。
    
   代码如下：
    
    
    
```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int>q;
const int N=8e5+1;
int u[N],v[N],w[N],nxt[N],fst[N],tot,dis[N],flag[N];
int n,m,x,y;
void add(int x,int y,int z)
{
	tot++;
	u[tot]=x;
	v[tot]=y;
	w[tot]=z;
	nxt[tot]=fst[x];
	fst[x]=tot;
}
void dij(int ss)
{
	for(int i=0;i<=n+1;i++)  dis[i]=-200000000;
	dis[ss]=0;
	q.push(ss);
	flag[ss]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		flag[x]=0;
		for(int i=fst[x];i!=-1;i=nxt[i])
		{
			int y=v[i],z=w[i];
			if(dis[x]+z>dis[y])
			{
				dis[y]=dis[x]+z;
				if(!flag[y]) q.push(y),flag[y]=1;
			}
		}
	}
}
int main()
{
	memset(fst,-1,sizeof(fst));
	memset(nxt,-1,sizeof(nxt));
	cin>>n>>m;
	for(int i=1;i<=n;i++) add(i,i-1,-1),add(i-1,i,0);
	for(int i=1;i<=m;i++)
	{
		int xx,yy,zz;
		cin>>xx>>yy>>zz;
		add(xx-1,yy,zz);
	}
	dij(0);
	cout<<dis[n];
}
```


---

## 作者：CrTsIr400 (赞：2)

# 理论最优复杂度做法

upd 23/12/02:更新了一处笔误，把某个 `break` 换成 `continue` 了。

---

首先，确定算法流程：（之前贪心正确性之类的证明就不讲了）

+ 把所有要求按照右端点从小到大排序。
+ 查询该要求所属的区间内种的树数量。
+ 如果不够，就从右往左寻找空地，给这些空地种上树。

我们考虑把这个问题抽象一下：

+ 维护一个 $0/1$ 序列；
+ 求一段区间里面 $1$ 的个数；
+ 从某个位置开始，从右往左寻找第一个遇见的 $0$；
+ 把一个位置上的 $0$ 变成 $1$。

这题的数据范围，使用暴力算法就可以稳稳通过。

但是我们可以不那么暴力。

具体而言，使用平衡树维护一个集合，这个集合代表还能种树的空地，也就是维护所有 $0$ 的位置；

查询区间 $[l,r]$ 的时候，我们就查询 $r$ 的排名和 $l-1$ 的排名之差，维护这段区间 $0$ 的个数，就可以求得 $1$ 的个数了；

从某个位置开始，从右往左寻找第一个遇见的 $0$，我们就寻找这个位置的前驱即可。

把 $0$ 变成 $1$ 就只需要删除即可。

时间复杂度：$O((n+m)\log n)$，因为每个数最多只会被删除一次。

采用 `__gnu_pbds::tree` 实现，常数略大，没有树状数组快。

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for(I i=a;i<=b;++i)
#define fd(i,a,b) for(I i=a;i>=b;--i)
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;typedef int I;
using namespace __gnu_pbds;
tree<I,null_type,less<I>,rb_tree_tag,tree_order_statistics_node_update>s;
I n,m,l[5010],r[5010],w[5010],id[5010],ans;
I main(){
	scanf("%d%d",&n,&m);
	fo(i,1,n)s.insert(i);
    //初始化集合，一开始都没有树
	fo(i,1,m)scanf("%d%d%d",l+i,r+i,w+i),id[i]=i;
	sort(id+1,id+m+1,[=](I a,I b){return r[a]<r[b];});
    //lambda 表达式，按照 r 为关键字给 id 排序。
	fo(i,1,m){I L=l[id[i]],R=r[id[i]],W=w[id[i]],
		t=(R-L+1)-(s.order_of_key(R+1)-s.order_of_key(L));
		auto it=s.upper_bound(R);
		if(it==s.begin())continue;
        //注意：求前驱的时候一定要判断一下它是不是到了 s.begin()！
		--it;
		while(t<W){
			++t;++ans;
			if(it==s.begin()){s.erase(it);break;}
            //这里也要判一下 begin()，不然删除的时候就会炸
			--it;s.erase(next(it));
		}
	}printf("%d\n",ans);
	return 0;
}
```



---

## 作者：a999999 (赞：2)

这题是很明显的贪心

所以我们主要不讲贪心的过程，主要是如何优化**时间复杂度**

具体来讲~~可以找楼上下的dalao~~，贪心分为三步：
1. 查询区间$(l,r)$中有几棵树
2. 在区间$(l,r)$中从后往前种$k$棵树

其他dalao的题解中有详细讲解哦~

好，我们来谈谈怎么优化暴力算法（虽然$O(NM)$能过）

我们来尝试**分块**做法
---

具体来讲，我们维护这几个值（块指分好的块，点指原始序列上的点）：

```
L[p]:第p块左端点
R[p]:第p块右端点
sum[p]:第p块区间和（已种的树的颗数）
tag[p]:第p块是否被全覆盖
val[p]:第p点是否被覆盖（点不是块！）
```
于是我们的~~丑陋无比的~~预处理就成了这样：

```cpp
void prework()
{
    int block=sqrt(m);//m=区域的个数
    for(int i=1;i<=m;++i)
    	if(!L[belong[i]=i/block+1])
    	{
    		L[belong[i]]=i;
			R[belong[i-1]]=i-1;
		}
    R[belong[m]]=m;//不打的话这块就没有右端点了
}
```
然后，我们需要查询区间$(l,r)$

本着先两边，后中间的原则，我们需要这样查询：

```cpp
int ask(int l,int r)
{
    int q=belong[l],p=belong[r],i,ans=0;
    if(q==p)
    {
    	if(tag[p])//1：因为tag[p]更新时只同时更新sum[p],属于p块的val[]是没有更新的
    		ans=r-l+1;
        else
			for(i=l;i<=r;++i)
            	ans+=val[i];
        return ans;
    }
    if(tag[p])//同1
        ans+=r-L[p]+1;
    else 
        for(i=r;i>=L[p];--i)
            ans+=val[i];
    for(i=p-1;i>q;--i)//2：因为更新tag[p]时同时更新了sum[p],所以可以直接调用
        ans+=sum[i];
    if(tag[q])//同1
        ans+=R[q]-l+1;
    else
        for(i=l;i<=R[q];++i)
            ans+=val[i];
    return ans;
}
```
---
修改操作最烦，因为要考虑$sum[]$和$tag[]$

直接上代码会比较好讲一点

```cpp
void insert(int l,int r,int c)
{
    int q=belong[l],p=belong[r],i,j;
    if(p==q)
    {
    	sum[q]+=c;//先加上，否则按此顺序执行sum[q]不会增加
        for(i=r;i>=l&&c;--i)
            if(!val[i])
                --c,val[i]=true;
        return;
    }
    for(i=r;i>=L[p]&&c&&!tag[p];--i)//3:根据贪心从右往左处理，需注意要在tag[]==0的情况下（全种上了还修个锤啊）
        if(!val[i])
        {
            --c;
            ++sum[p];
            val[i]=true;
        }        
    for(i=p-1;i>q&&c;--i)//同2
    {
        if(R[i]-L[i]+1-sum[i]>c)//说明这一段全种上大于c棵，实际修改的左端点在这一段内（不能完全覆盖）
        {
            for(j=R[i];j>=L[i]&&c&&!tag[i];--j)//同3
                if(!val[j])
                {
                    --c;
                    ++sum[i];
                    val[j]=true;
                }
        }
        else if(!tag[i])//说明这段需要全种上，且原本有空位
        {
            tag[i]=true;
            c-=R[i]-L[i]+1-sum[i];
            sum[i]=R[i]-L[i]+1;
        }    
    }
    for(i=R[q];i>=l&&c&&!tag[q];--i)//同3
        if(!val[i])
        {
            --c;
            ++sum[q];
            val[i]=true;
        }
}
```
---
这题解决了？

是啊！

时间复杂度？

O(N$\sqrt{M}$)！

[代码实现](https://www.luogu.org/recordnew/show/19673745)

最后鸣谢《算法竞赛进阶指南》教会我分块

喜欢的话点个赞吧~

---

## 作者：反班长者 (赞：2)

# **蒟蒻思路：树要种得少，就要使一棵树给多个区间使用。这样，尽量在重叠区间种树即可，而重叠位置一定是在区间尾部。处理问题时，先按所有区间的结束位置排序，之后依次处理每个区间，先在第一个区间尾部种满足要求的树，对下一个区间，看差多少棵就在该区间尾部种多少。**

### 1.先按结束位置快排。

### 2.对每个区间依次处理。

### a.从前到后扫一遍这个区间，统计已选点的个数。

### b.若已选点的个数超过了要求的点数，则continue。

### c.否则从该区间由后向前扫，添加缺少的覆盖点。

#### 3.cout。

**加一句：~~跑贼慢。。。。~~**

```cpp
#include<bits/stdc++.h>
using namespace std;
struct line{int s,e,v;}a[5005],mid;
int n,m;
bool used[30005]={0};
bool cmp(const line&x,const line&y){return x.e<y.e;}
void YSF()
{
	int i;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	cin>>a[i].s>>a[i].e>>a[i].v;
	sort(a+1,a+m+1,cmp);
}
void solve()
{
	int i,j,k,ans=0;
	for(i=1;i<=m;i++)
	{
		k=0;
		for(j=a[i].s;j<=a[i].e;j++)
		if(used[j])k++;
		if(k>=a[i].v)continue;
		for(j=a[i].e;j>=a[i].s;j--)
		if(!used[j])
		{
			used[j]=1;
			k++;
			ans++;
			if(k==a[i].v)break;
		}
	}
	cout<<ans;
}
int main()
{
	YSF();
	solve();
	return 0;
}
```

## 蒟蒻第二次写题解，管理大大求过！！谢谢！！

---

## 作者：ysj1173886760 (赞：2)

这里给出一下最长路的做法，同时也通过这个做法引出了对差分约束的一些思考。

差分约束的题目中，在不存在无解的情况下最主要的两大特点就是：

1.最短路/最长路

2.超级源点。

其中最短路/最长路是图论上的基础算法，谁都会用，而超级源点在实现上也非常简单，创建一个不存在的节点向所有节点连边即可。

但是不同的题要求不同的答案，也就需要我们对不同含义的dis值进行不同的处理。

主要还是具体问题具体分析。

这题给出了比较明确的限制条件，所以我们可以借助前缀和辅助维护。

对于题中给出的条件 我们有：

sum[E]-sum[B-1]>=T

sum[i]-sum[i-1]>=0

sum[i-1]-sum[i]>=-1

这样一个基础的图的框架就完成了，最后我们只需要加上超级源点n+1，
然后跑一遍最长路，最后输出dis[n]就可以了。

但是有的小伙伴可能发现了，最终dis[n]并不是答案。。为什么呢？？

这就是我上面说的具体问题具体分析了。

首先明确为什么是最长路，因为对于每一个 x1-y1>a1,x1-y2>a2....
这些不等式而言，我们需要满足所有的约束信息，那么这个不等式大于a1，a2....，高中我们学过，大于一个玩意恒成立，大于这个玩意的最大值。而每一个a1,a2...就是对应的图论上的x1到y1的路径之和，我们要大于他们的最大值，就要大于最长路了。

其次明白对于超级源点来说，我们由超级源点向每一个点进行连边，那么对应的意义就是(记超级源点为n+1):

sum[n+1]-sum[i]>=dis[i]  (核心式子)

其中dis是由最长路求出来的距离，这个dis值就是对应的满足差分约束系统最紧确的结果，也就是最小化这个不等式的最大值。

所以我们不妨将不等号去掉，（因为我们求出的已经是最优解了）

变为 sum[n+1]-sum[i]=dis[i], 这里可能就会开始懵逼了，sum[n+1] 到底是什么呢？？超级源点的前缀和？，实际上我们在最长路算法中给了他一个值，0，但就算不给也无所谓，注意到我们最终要求的是树的数量，也就是 sum[n]-sum[0]

进行一步转换

dis[0]=sum[n+1]-sum[0]

dis[n]=sum[n+1]-sum[n]

所以  sum[n]-sum[0]=dis[0]-dis[n]

完毕，最长路结束就可以算结果了。

所以最重要的还是具体问题具体分析吧，差分约束系统的确是个比较奇妙的东西。

最后上个代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int maxn=3e4+10;
int n,m,tot;
int dis[maxn],q[maxn],g[maxn];
bool vis[maxn];
struct line
{
	int to,next,w;
}edge[maxn*5];

void add1(int a,int b,int c)
{
	edge[++tot].to=b;
	edge[tot].w=c;
	edge[tot].next=g[a];
	g[a]=tot;
}
void spfa()
{
	memset(dis,-0x3f,sizeof(dis));
	int h=0,t=1;
	q[t]=n+1;
	vis[q[t]]=true;
	dis[q[t]]=0;
	while(h!=t)
	{
		h=h%(n+2)+1;		//循环队列，注意本来有n+1个点加上超级源点，就是n+2个了 
		int x=q[h];
		int temp=g[x];
		while(temp)
		{
			if(dis[edge[temp].to]<dis[x]+edge[temp].w)
			{
				dis[edge[temp].to]=dis[x]+edge[temp].w;
				if(!vis[edge[temp].to])
				{
					t=t%(n+2)+1;			
					q[t]=edge[temp].to;
					vis[q[t]]=true;
				}
			}
			temp=edge[temp].next;
		}
		vis[x]=false;
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0,z=0;
		scanf("%d %d %d",&x,&y,&z);
		add1(y,x-1,z);
	}
	for(int i=0;i<=n;i++)add1(n+1,i,0);
	for(int i=1;i<=n;i++)
	{
		add1(i-1,i,-1);
		add1(i,i-1,0);
	}
	spfa();
	printf("%d",dis[0]-dis[n]);
	return 0;
}
```

管理大大看我写的这么认真给过了吧QWQ

---

## 作者：夏色祭 (赞：2)

#目测是当前跑的最快的代码，4ms

#数据有点水啊，emmmm，楼下许多贪心的做法时间复杂度应该是O(nm)，但是居然过了。。。

一道贪心题。

先按区间的右端点排序，然后从左往右做。

对于第i个区间，如果区间内的树的棵数达到要求则不用种了；

如果没有达到，则从后往前种树（前i-1个区间的问题我们都解决了，而前i-1个区间应该是在第i个区间前面，所以我们种的树应该要服务的是当前区间和后面的区间）

然后，对于判断区间内的树的棵数是否达到要求我们可以用一个树状数组维护。

丑陋的代码：

```cpp
var
  l,r,need:array[0..5001]of longint;
  c:array[0..30001]of longint;
  b:array[0..30001]of boolean;
  n,m,i,j,k,x,y,ans:longint;
procedure zz(i,j:longint);
var
  t:longint;
begin
  t:=need[i];need[i]:=need[j];need[j]:=t;
  t:=l[i];l[i]:=l[j];l[j]:=t;
  t:=r[i];r[i]:=r[j];r[j]:=t;
end;
procedure kp(ll,rr:longint);
var
  i,j,mid,midd:longint;
  begin
    i:=ll;
    j:=rr;
    mid:=r[(ll+rr) >> 1];
    repeat
      while (mid>r[i]) do inc(i);
      while (mid<r[j]) do dec(j);
      if i<=j then 
        begin
          zz(i,j);
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<rr then kp(i,rr);
    if ll<j then kp(ll,j);
  end;
procedure swap(var x,y:longint);
var
  t:longint;
  begin
    t:=x;
    x:=y;
    y:=t;
  end;
function lowbit(x:longint):longint;
begin
  exit(x and (-x));
end;
procedure add(x:longint);
begin
  while x<=m do 
    begin
      inc(c[x]);
      x:=x+lowbit(x);
    end;
end;
function sum(x:longint):longint;
begin 
  sum:=0;
  while x>0 do
    begin
      inc(sum,c[x]);
      x:=x-lowbit(x);
    end; 
end;
begin
  readln(m);
  readln(n);
  for i:=1 to n do read(l[i],r[i],need[i]);
  kp(1,n);//排序
  for i:=1 to n do 
    begin
      x:=sum(r[i]);
      y:=sum(l[i]-1);
      if x-y<need[i] then //利用了前缀和的思想 
        begin
          k:=need[i]-(x-y);//还需要种几棵树
          for j:=r[i] downto l[i] do 
            if not b[j] then //用b数组标记第i个位置是否种树 
              begin
                dec(k);
                b[j]:=true;
                add(j);
                if k=0 then break; 
              end; //从后往前种树
        end;
    end;
  writeln(sum(m));//输出。。。
end.
```

---

## 作者：Valhalla_Is_Calling (赞：2)

## 这几天在刷贪心类的题，正好遇到了这道

这道题的思路很简单，想要种植最少的树，就要让这些树尽量“重复利用”，因此只要在重叠区域种树即可。处理问题时，先按所有区间的尾标排序，之后依次处理每个区间。

算法流程：

#### 1.按照结束位置进行**快速排序**

#### 2.对每个区间依次处理：
 
####   a.从前到后进行扫描，统计**已种**的树
  
####    b.若已种的树已经**满足**要求，就**continue**
   
####     c.否则从后往前扫描，种树

#### 3.输出答案

以下是精彩的解题阶段：

首先定义一个结构体，用来储存每一个居民的要求

```cpp
struct tree
{
	int b;
	int e;
	int t;
}a[5001];
```
这里是输入和排序阶段，按照刚才所说的进行代码实现

```cpp
int i;
cin>>n>>m;
for(i=0;i<m;i++) cin>>a[i].b>>a[i].e>>a[i].t;
sort(a,a+m,cmp) ;
```
以下是精髓阶段1，统计每一个区域已有的树的数量，k是统计变量

```cpp
k=0;
for(j=a[i].b;j<=a[i].e;j++)
{
	if(pd[j]) k++;
}
if(k>=a[i].t) continue;
```
然后就是种树的环节

```cpp
for(j=a[i].e;j>=a[i].b;j--)
{
	if(!pd[j])
	{
		pd[j]=1;
		k++;
		ans++;
		if(k==a[i].t) break;
	} 
}
```
最后给大家粘上完整的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct tree
{
	int b;
	int e;
	int t;
}a[5001];
int n,m;
int i,j;
bool pd[100001]={0};
bool cmp(const tree &x,const tree &y)
{
	return x.e<y.e;
}
inline void Read()
{
	int i;
	cin>>n>>m;
	for(i=0;i<m;i++) cin>>a[i].b>>a[i].e>>a[i].t;
	sort(a,a+m,cmp) ;
}
inline void solve()
{
	int i,j,k,ans=0;
	for(i=0;i<m;i++)
	{
		k=0;
		for(j=a[i].b;j<=a[i].e;j++)
		{
			if(pd[j]) k++;
		}
		if(k>=a[i].t) continue;   
		for(j=a[i].e;j>=a[i].b;j--)
		{
			if(!pd[j])
			{
				pd[j]=1;
				k++;
				ans++;
				if(k==a[i].t) break;
			} 
		}
	}
	cout<<ans<<endl;
}
int main()
{
	Read();
	solve();
	return 0;
} 
```


---

## 作者：任弈凡 (赞：1)

# 一篇奇怪的题解

------------
- 首先，因为我们要用尽量少的树来满足~~客户~~居民的需求
- 所以我们的一棵树要尽量让更多人用
- 所以，我们先排序，再将每一棵树放在这一个区间的最后，即可能重叠的部分
- 所以我们用排序+贪心的思想解决这道题
- 代码如下
```
#include<iostream>
#include<algorithm>
using namespace std;
#define ont int
 #define fOr for(int j=a[i].b;j<=a[i].e;j++)
 #define foR for(int j=a[i].e;j>=a[i].b;j--)
#define For for(int i=1;i<=h;i++)
#define ss struct
#define pool bool
#define retuen return 
#define why if
#define because else
#define however continue
#define broke break
ont n;
ont ans;
ont h;
ss s{
    ont b,e,t;
};
s a[30003];
ont f[30003];//定义部分
pool cmp(s x,s y) {
    retuen x.e<y.e;
}//排序
ont main() {
    ciN>>n;
    ciN>>h;
    For {
        ciN>>a[i].b>>a[i].e>>a[i].t;
    }
    sort(a+1,a+h+1,cmp);
    For {
        ont check=1;
        fOr {
            why(f[j]==1) {
                check++;
            }
        }//统计有几个已在区间中
        why(check>=a[i].t) however;
        because {
            ont num=check;
            foR {
                why(f[j]!=1) {
                    num++;
                    ans++;
                    f[j]=1;
                }
                why(num==a[i].t) broke;
            }//从后往前取
        }
    }
    cout<<ans;
}
```
### 注意有坑

---

## 作者：邓晓蓝 (赞：1)

//这题简单的贪心。因为重复的树越多，种的树越少。因此我们先把右端点从小到大排序，如果这个区域内种的树不够，那么从最右边开始种树。拿样例举个例子吧：

9
4
1 4 2
4 6 2
8 9 2
3 5 2

首先按右端点从小到大排序（注意用快排）

变成：

1 4 2
3 5 2
4 6 2
8 9 2
这时开辟一个数组zh，如果zh[n]的值为1，则代表这里种了一棵树。初始没有树。

首先看区域4~1，发现树不够。

那么我们从最右边开始种树，最少种两棵树。也就是zh[4]=1,zh[3]=1;然后种树的棵树+2.

接着看区域5~3，发现zh[3]=1,zh[4]=1，树足够，不需要再种。

再看区域6~4，发现少了一棵树，则从最右边开始种树。zh[6]=1,然后种树的棵树+1。

再看区域9~8，发现少了2棵树。则从最右边开始种树，zh[9]=1,zh[8]=1，然后种树的棵树+2.最后求出最少种5棵树。

请看c++AC代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int m,n,zh[30001]={0},a[5001],b[5001],sz[5001];
void qsort(int s1,int s2)   //手打快拍从小到大不解释
{
    int mid1=b[(s1+s2)/2];
    int i=s1,j=s2,t;
    while (i<=j)
    {
        while (b[i]<mid1) i++;
        while (b[j]>mid1) j--;
        if (i<=j)
        {
            t=b[i];b[i]=b[j];b[j]=t;
            t=a[i];a[i]=a[j];a[j]=t;
            t=sz[i];sz[i]=sz[j];sz[j]=t;
            i++;j--;
        } 
    }
    if (i<s2) qsort(i,s2);
    if (j>s1) qsort(s1,j);
}
int main()
{
    int zs=0,i,j,o;
    cin>>m;
    cin>>n;
    for (i=1;i<=n;i++)
      cin>>a[i]>>b[i]>>sz[i];
    qsort(1,n);
    for (i=1;i<=n;i++)
    {
        int js=0;
        for (j=b[i];j>=a[i];j--)
          if (zh[j]==1) js++;   //计算区域内种了几棵树。
        if (js<sz[i])   //如果不够
        {
            o=sz[i]-js;  //求出还要种几棵树。
            zs+=o;  //累加树的棵数不解释
            for (j=b[i];j>=a[i];j--)  //从最右边开始种树
              if (zh[j]==0) { if (o==0) break;zh[j]=1;o--;  //当然注意要在没有树的地方才能种树。
              }
        }
    }
    cout<<zs;  //最后输出最少种多少棵树
    return 0;
}

```

---

## 作者：加里纳利 (赞：1)

最基本的差分约束系统可以将这个题目借助前缀和数组转化到一系列的不等式关系。若用f[i]表示到i所用的树木数，f[e]-f[b]>=t（建一条从b到e的长度为t的边权），在题目中还有一个隐含条件，就是0<=f[i]-f[i-1]<=1，这个隐含关系中可以将f[i]与f[i-1]与0、1建立关系，又多了很多条边。对于<=的情况可以同时乘-1，就转变成了>=，进而用最长路求最小值。

```cpp
var i,j,n,m,k,t,head,tail,x,y,tot,h,z,v:longint;  
toit,next,dis,list,cost:array[0..300001]of longint;  
le:array[0..300001]of boolean;  
q:array[0..100001]of longint;  
procedure getin(x,y,z:longint);  
begin  
 inc(tot);  
 toit[tot]:=y;  
 cost[tot]:=-z;  
 next[tot]:=list[x];  
 list[x]:=tot;  
end;  
function min(x,y:longint):longint;  
begin  
 if x>y then exit(y) else exit(x);  
end;  
begin  
 fillchar(le,sizeof(le),true);  
 readln(n);  
   readln(h);  
 for i:=2 to n+1 do  
begin  
  getin(i,i-1,-1);  
  getin(i-1,i,0);  
end;  
 for i:=1 to h do  
begin  
  readln(x,y,z);  
  getin(x,y+1,z);  
end;  
 fillchar(dis,sizeof(dis),100);  
 head:=1; tail:=1;  
 q[1]:=1; dis[1]:=0;  le[1]:=false;  
repeat  
 v:=q[head mod 100000];  
 k:=list[v];  
 while k<>0 do  
  begin  
   if dis[v]+cost[k]<dis[toit[k]] then  
   begin  
      dis[toit[k]]:=dis[v]+cost[k];  
    if le[toit[k]]=true then  
     begin  
      le[toit[k]]:=false;  
      inc(tail);  
      q[tail mod 100000]:=toit[k];  
     end;  
   end;  
    k:=next[k];  
 end;  
 le[v]:=true;  
 inc(head);  
until head>tail;  
 writeln(-dis[n+1]);  
end.
```

---

## 作者：xiaohuang (赞：1)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/24/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8F%E6%B4%9B%E8%B0%B7P1250%20%E7%A7%8D%E6%A0%91/)

### Solution

这题差分约束，我们用$\mathrm{s[i]}$表示从第$1$号到第$i$号的树的数量的和（也就是前缀和）。

那么题目中的约束条件就是：

1. $s[E] - s[B - 1] \ge T$

因为事前缀和，所以还隐含了：

1. $s[i] - s[i - 1] \le 1$

1. $s[i - 1] \le s[i]$

还有每个位置的树的数量都是大于$0$的数，所以还有：

1. $s[i] \le s[n + 1] + 0$（把$n + 1$号位置设置为超级源）

整理可得：

1. $s[B - 1] \le s[E] - T$

1. $s[i] \le s[i - 1] + 1$

1. $s[i - 1] \le s[i] + 0$

1. $s[i] \le s[n + 1] + 0$

然后跑最长路。

这样，这道题就解决了。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>

using namespace std;

typedef long long LL;
const int INF = 0x3f3f3f3f, MAXN = 200005;
struct EDGE {
    int to, nxt, val;
} edge[MAXN];
int n, m, u, v, opt, val, cnt, vis[MAXN], dis[MAXN], head[MAXN];
inline void addedge(int u, int v, int val) {//邻接表存图
    edge[++cnt].to = v; edge[cnt].val = val; edge[cnt].nxt = head[u]; head[u] = cnt;
}
inline void SPFA(int cur) {
    queue<int> Q;
    Q.push(cur);
    for (int i = 0; i <= n + 1; i++)
        dis[i] = 1;
    vis[cur] = 1;
    dis[cur] = 0;
    while (!Q.empty()) {
        int u = Q.front();
        Q.pop();
        vis[u] = 0;
        for (int i = head[u]; ~i; i = edge[i].nxt) {
            int v = edge[i].to;
            if (dis[v] > dis[u] + edge[i].val) {
                dis[v] = dis[u] + edge[i].val;
                if (!vis[v]) {
                    vis[v] = 1;
                    Q.push(v);
                }
            }
        }
    }
}
int main() {
    scanf("%d%d", &n, &m);
    memset(head, -1, sizeof(head));
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &val);
        addedge(v, u - 1, -val);
    }
    for (int i = 0; i <= n; i++)
        addedge(n + 1, i, 0);
    for (int i = 1; i <= n; i++) {
        addedge(i - 1, i, 1);
        addedge(i, i - 1, 0);
    }
    SPFA(n + 1);//最长路
    int Min = INF;
    for (int i = 0; i <= n; i++)
        Min = min(Min, dis[i]);
    printf("%d\n", dis[n] - Min);
    return 0;
}
```

---

## 作者：magolor (赞：1)

查分约束系统，变量dis[k]是前k家种树的前缀和，满足三个条件：

1.s[e] - s[b-1] >= T （居民要求）

2.s[k] - s[k-1] >= 0 （不能种负树）

3.s[k] - s[k-1] <= 1 （一块地种一棵）

1取反变号可以得到

s[b-1] - s[e] <= -T

移项
s[b-1] <= s[e] + (-T)

类比最短路 dis[v] <= dis[u] + <u,v>

所以从E到B-1连权值为-T的边

同理，2，3可以得到：从k到k-1连0边，k-1到k连+1边。


当然，把所有边全部反向也可以：B-1到E连权值为-T的边，从k-1到k连0边，k到k-1连+1边。（本人代码）

建立源点S，到每个点长度为0的边，为了防止出现种负树的情况。

跑SPFA，注意由于连的边都是-T，结果是负数，所以答案是-dis[N]，即n家的前缀和。


**注意几点错误（不要问我怎么知道的）：**

**S不要设为0，要设为N+1或更大，因为0点是有意义的，而不是源点。**

**题目用的空间可能很大，防止RE，SPFA的队列要用循环队列，注意数据范围，数组要开大。**


下面是代码：









```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 50000
#define MAXM 500000
#define MEMINF 0x3f
struct Edge
{
    int to,nex,w;
    Edge(){}
    Edge(int _to, int _nex, int _w):to(_to),nex(_nex),w(_w){}    
};
Edge e[MAXM+5];
int first[MAXN+5], dis[MAXN+5], q[MAXN*2+5], tot, N, H, S, T;
bool book[MAXN+5];
inline void Add(int a, int b, int c)
{
    e[tot] = Edge(b,first[a],c);
    first[a] = tot++;
    return;
}
inline void SPFA()
{
    memset(dis,MEMINF,sizeof(dis));
    book[S] = true, q[0] = S, dis[S] = 0;
    for(register int head = 0, tail = 1, u, t; head != tail; book[t] = false)
        for(t = q[head], head = (head+1)%MAXN, u = first[t]; u != -1; u = e[u].nex)
            if(dis[e[u].to] > dis[t] + e[u].w)
            {
                dis[e[u].to] = dis[t] + e[u].w;
                if(!book[e[u].to])
                    book[e[u].to] = true, q[tail] = e[u].to, tail = (tail+1)%MAXN;
            }
    return;
}
int main()
{
    scanf("%d%d",&N,&H), S = N+1, memset(first,-1,sizeof(first));
    for(int B,E,T; H--; )
        scanf("%d%d%d",&B,&E,&T), Add(B-1,E,-T);
    for(register int i = 1; i <= N; i++)
        Add(i-1,i,0), Add(i,i-1,1);
    for(register int i = 0; i <= N; i++)
        Add(S,i,0);
    SPFA(),    printf("%d\n",-dis[N]); 
     return 0;
}

```

---

## 作者：wanxiang_zx (赞：0)

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
using namespace std;
const int maxn=50010;
const int maxm=100010;
struct node{
	int pot,w;
}e[maxm];
//因为结构体存储的是每一条边，所以一定要开maxm,卡了一个小时！！！ 
int n,m,num=0,mn;
int d[maxn];
int next[maxm],head[maxn];
//next数组记录每条边，所以要开maxm个
//head数组记录所有边的起点最多有maxn个点 
//a[x]表示从起点开始到x至少要种的树的个数
bool v[maxn];
void add(int x,int y,int w)
{
	e[++num].pot=y;
	e[num].w=w;
	next[num]=head[x];
	head[x]=num;
}
void spfa(int x)
{
	queue<int>Q;
	Q.push(x);
	mn=d[0]; 
	v[x]=false;
	d[x]=0;
	while(Q.size())
	{
		int x=Q.front();
		//cout<<"%%%%%"<<endl;
		Q.pop();
		v[x]=true;
		for(int i=head[x];i;i=next[i])
		{
			int y=e[i].pot;
			if(d[x]+e[i].w<d[y])
			{
			  	d[y]=d[x]+e[i].w;
			  	if(v[y])
			  	{
			  		Q.push(y);
			  		v[y]=false;
			  	}
			}
		}
	}
} 
int main()
{
	memset(d,0x3f,sizeof(d));
	memset(v,true,sizeof(v));
    scanf("%d%d",&n,&m);
    int s=n+1;
    for(int i=1;i<=m;i++)
    {
        int x,y,w;
        scanf("%d%d%d",&x,&y,&w);
        /*
		表示从x-1到y这个区间至少要种w棵树
        若d[x]表示从起点开始到x至少要种的树的个数
        则有：
          d[y]-d[x-1]>=w
          d[i]-d[i-1]>=0
		  d[i]-d[i-1]<=1
		  可得到 d[y]>=d[x-1]+w (d[x-1]<=d[y]-w)
		  所以是建从x-1到y的边权为w的边，最后求最长路 
		  也可以建从y到x-1的边权为-w的边，最后求最短路 
		*/
		 add(y,x-1,-w);
    }
    for(int i=1;i<=n;i++)
    {
    	add(s,i,0);
    	add(i-1,i,1);
    	add(i,i-1,0);
    }
    spfa(s);
    //s为超级原点，防止图不连通
    //这里一定要以n+1为超级原点，不可以以0为超级原点
	//因为前面跑数组的时候会建立从0到1的边权为1的边 
	//标准的求最短路模型
	for(int i=0;i<=n;i++)
	  //cout<<d[i]<<endl;
	  mn=min(mn,d[i]);
	
	printf("%d\n",d[n]-mn); 
	system("pause");
	return 0;
}
```


---


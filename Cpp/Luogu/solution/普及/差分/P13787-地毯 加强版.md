# 地毯 加强版

## 题目描述

在 $n\times n$ 的格子上有 $m$ 个地毯。

给出这些地毯的信息，问每个点被多少个地毯覆盖。

## 说明/提示

对于 $50\%$ 的数据，有 $n,m\le 5000$。

对于 $100\%$ 的数据，有 $n\le 5000$，$m\le 2\times 10^5$。

## 样例 #1

### 输入

```
5 3
2 2 3 3
3 3 5 5
1 2 1 4```

### 输出

```
146```

# 题解

## 作者：OvO_frsf (赞：1)

# P13787 [地毯 加强版](https://www.luogu.com.cn/problem/P13787) 题解

相较于[原题](https://www.luogu.com.cn/problem/P3397)，这道题~~玩不了暴力~~数据加强了。

---

二维差分的模板题。

一维差分大家应该都知道，就不讲了。

简单讲一下二维差分。

对于原始数组 $a$，差分数组 $d$ 的定义为 `d[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1]`。

与一维类似，若使点 $(x1,y1)$ 至点 $(x2,y2)$ 间增加 $k$，需要：
```cpp
d[x1][ay1]++;
d[x1][y2 + 1]--;
d[x2 + 1][y1]--;
d[x2 + 1][y2 + 1]++;
```
暴力需要逐个修改，比这个 $O(1)$ 慢很多。

原理如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/arz0sqe7.png)

还原每个点只需要进行二维前缀和就行了。

注意要开 `long long`。

---

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5010;
int n, m, a[N][N];
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++){
        int ax, ay, bx, by;
        cin >> ax >> ay >> bx >> by;
        a[ax][ay]++;
        a[ax][by + 1]--;
        a[bx + 1][ay]--;
        a[bx + 1][by + 1]++;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
            ans += (i + j) ^ a[i][j];
        }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：wangmutian (赞：1)

### 题目大意
题意已经非常明确，不再赘述。

### 题目思路
根据数据范围（$n\le 5000$，$m\le 2\times 10^5$）可知，直接暴力累加每个点的地毯数目会超时。

因此，对于此类需要进行大量区间修改和区间求和的问题，我们考虑使用**差分前缀和**。[更多有关前缀和与差分的内容](https://oiwiki.com/basic/prefix-sum/#%E5%BC%95%E5%85%A5)

我们定义数组 $d$ 为差分数组，则可以得出差分公式为：
```cpp
d[x1][y1]++;
d[x1][y2 + 1]--;
d[x2 + 1][y1]--;
d[x2 + 1][y2 + 1]++;
```

处理完区间修改后，就可以对 $d$ 数组求前缀和，快速得出每个点被几块地毯覆盖：
```cpp
f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + d[i][j];
```

### 细节处理
本题要求输出的是 $\sum_{i=1}^n\sum_{j=1}^n (i+j)\oplus F_{i,j}$ 的值，即在 $n \times n$ 范围内每一个点的地毯覆盖数量异或 $i+j$（当前行与当前列之和），然后求出这些值的和。

因此，我们定义变量 $sum$ 代表该结果的值。需要注意该值可能超过 int 范围，需要使用 long long 存储。

### 代码

```cpp
#include <iostream>
using namespace std;

int n, m, x1, y1, x2, y2, d[5010][5010], f[5010][5010];
long long sum;

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
    	cin >> x1 >> y1 >> x2 >> y2;
    	d[x1][y1]++;
    	d[x1][y2 + 1]--;
    	d[x2 + 1][y1]--;
    	d[x2 + 1][y2 + 1]++;
    }
    for (int i = 1; i <= n; i++)
    {
    	for (int j = 1; j <= n; j++)
    	{
    		f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + d[i][j];
    		sum += (f[i][j] ^ (i + j));
    	}
    }
    cout << sum << endl;
    return 0;
}
```

---

## 作者：EnochLiu2012 (赞：1)

[一个很勤劳的传送门](https://www.luogu.com.cn/problem/P13787)

**算法：差分**

## 什么是差分？
温馨提示：如果本部分你已经了解，可以往下翻到讲解部分。

差分用于**处理数组区间修改操作**的算法，是前缀和的逆运算（前缀和是用来累计前面所有元素的和）。

例如这道[题](https://www.luogu.com.cn/problem/P2367)就是一维差分的模板，就是给定一个数组，每次操作都要修改区间中一部分的值，最后再求最小值；再高级一点的就是本题的[原题](https://www.luogu.com.cn/problem/P3397)，是一道二维差分。

定义一个差分数组 $d$，表示当前值与相邻值的差（一维是与左边的差，即 $d_i=a_i-a_{i-1}$，二维要看具体情况）。

先看一维数组：给定变化区间 $[l,r]$ 以及变化数量 $c$，让 $d_l$ 增加 $c$，$d_{r+1}$ 减少 $c$，表示从 $d_l$ 起比左边多 $c$，从 $d_{r+1}$ 起比左边少 $c$，这样再做一次前缀和，就起到了让 $[l,r]$ 区间增加 $c$ 的效果，即从 $l$ 的位置起一直多了 $c$ ，从 $r+1$ 的位置起恢复原样。

二维数组与二维前缀和都有着**容斥**思想，即在某一个位置增加 $c$，在某两个位置减少 $c$ ，再在两次减少 $c$ 所重合的位置把少了的 $c$ 加回来（可能有点绕，但最好能理解透彻）。也就是定义两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，然后进行以下操作操作：
```
d[x1][y1]++;
d[x1][y2+1]--; d[x2+1][y1]--;
d[x2+1][y2+1]++; //因为变化数量为 1，所以用++和--操作
```
再做一次前缀和，就能起到效果啦。

## 本题真正的讲解部分
本题与[原题](https://www.luogu.com.cn/problem/P3397)都有一个共同点：定义一个二维数组，有 $m$ 次操作在某两个位置间铺上新地毯（即用差分在某区间增加 $1$）。与原题不同的是，答案是 $\sum_{i=1}^n\sum_{j=1}^n(i+j)\oplus d_{i,j}$，所以我们**模拟**出结果就好了（异或运算符是 **^**）。

最后提醒一句：十年 OI 一场空，不开 long long 见祖宗。原题中提到这件事了，如果你不听，就会有[全 WA](https://www.luogu.com.cn/record/232381152) 的风险。

## 经典上代码环节
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 5010
using namespace std;
int a[N][N],d[N][N],n,m,x1,x2,y,y2,ans;
signed main(){
    cin>>n>>m;
    while (m--){
        cin>>x1>>y>>x2>>y2;
        d[x1][y]++;
        d[x1][y2+1]--; d[x2+1][y]--;
        d[x2+1][y2+1]++; //差分
    }
    for (int i=1; i<=n; i++){
        for (int j=1; j<=n; j++){
            d[i][j]+=(d[i][j-1]+d[i-1][j]-d[i-1][j-1]); //前缀和
            ans+=((i+j)^d[i][j]); //累加答案
        }
    }
    cout<<ans; //帅气输出
    return 0;
}
```

---

## 作者：weichenglu (赞：1)

# 题目描述
在 $n\times n$ 的地图上，有 $m$ 条地毯，求每个格子上的地毯覆盖数。  

# 思路分析

## 方法一（TLE）

最简单的方法即为暴力。使用二维数组 $a$ 记录每个格子的地毯覆盖数，每次遍历地毯所覆盖的每一个格子。

```cpp
#include <bits/stdc++.h>
#define N 5005
#define int long long
using namespace std;

int n,m;
int a[N][N];
int sum;


signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i=1;i<=m;++i){
        int x1,y1,x2,y2; cin >> x1 >> y1 >> x2 >> y2;
        for (int x=x1;x<=x2;++x){
            for (int y=y1;y<=y2;++y){
                a[x][y]++;
            }
        }
    }
    for (int i=1;i<=n;++i){
        for (int j=1;j<=n;++j){
            sum += (i + j) ^ a[i][j];
        }
    }
    cout << sum;
	
	return 0;
} 
```

这样实现的时间复杂度为 $O(n^2m)$，观察数据范围，很明显会超时。   

## 方法二（50 Pts）

我们考虑减少读入地毯时的一层循环，由于涉及到区间求和，我们可以考虑使用[差分](https://oi-wiki.org/basic/prefix-sum/)。   
可以将地图看成 **$n$ 个大小为 $n$ 的一维数组**，使用**一维差分**。   
假设一个一维数组 $d$，一维差分的方法为：  
1. 对于所有 $1 \le i \le n$，预处理出 $d_i \gets d_i - d_{i-1}$。（由于本题初始数组元素都为 $0$，所以无需进行此操作）
2. 读入 $l$ 与 $r$，修改此区间的两个端点的值，使 $d_l$ 加 $1$，$d_{r+1}$ 减 $1$。
3. 每行从左往右扫描一遍，跑一遍一维前缀和，即使 $d_i \gets d_i + d_{i-1}$，就可以得到每个格子的地毯覆盖数。     

代码如下：

```cpp
#include <bits/stdc++.h>
#define N 5005
#define int long long
using namespace std;

int n,m;
int a[N][N];
int sum;


signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i=1;i<=m;++i){
        int x1,y1,x2,y2; cin >> x1 >> y1 >> x2 >> y2;
        for (int j=x1;j<=x2;++j) a[j][y1]++,a[j][y2+1]--;
    }
    for (int i=1;i<=n;++i){
        for (int j=1;j<=n;++j){
            a[i][j] += a[i][j-1];
            sum += (i + j) ^ a[i][j];
        }
    }
    cout << sum;

	return 0;
}
```

但是，这样实现的时间复杂度为 $O(n^2+nm)$，观察数据范围，很明显依旧无法被接受。

## 方法三（100 Pts）

由于此题 $m \le 2\times 10^5$，所以对于读入地毯还需再压掉一维，即将读入地毯的时间复杂度压为 $O(m)$，于是我们需要使用**二维差分**。  

假设一个二维数组 $d$，二维差分的方法为：  
1. 对于所有 $1 \le i \le n$ 与 $1 \le j \le n$，预处理出 $d_{i,j} \gets d_{i,j} - d_{i-1,j} - d_{i,j-1} + d_{i-1,j-1}$。（由于本题初始数组元素都为 $0$，所以无需进行此操作）
2. 读入 $x1$、$y1$、$x2$ 与 $y2$，修改此矩形的四个端点的值，使 $d_{x1,y1}$ 加 $1$，$d_{x1,y2+1}$ 减 $1$，$d_{x2+1,y1}$ 减 $1$，$d_{x2+1,y2+1}$ 加 $1$。
3. 从上到下、从左往右扫描一遍，跑一遍二维前缀和，即使 $d_{i,j} \gets d_{i,j} + d_{i-1,j} + d_{i,j-1} - d_{i-1,j-1}$，就可以得到每个格子的地毯覆盖数。

代码如下：
```cpp
#include <bits/stdc++.h>
#define N 5005
#define int long long
using namespace std;

int n,m;
int a[N][N];
int sum;


signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i=1;i<=m;++i){
        int x1,y1,x2,y2; cin >> x1 >> y1 >> x2 >> y2;
        a[x1][y1]++;
        a[x1][y2+1]--;
        a[x2+1][y1]--;
        a[x2+1][y2+1]++;
    }
    for (int i=1;i<=n;++i){
        for (int j=1;j<=n;++j){
            a[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1]; 
            sum += (i + j) ^ a[i][j];
        }
    }
    cout << sum;
	
	return 0;
}
```
此代码的时间复杂度为 $O(n^2+m)$，可以通过此题。  

# 注意

**不开 long long 见祖宗**

---

## 作者：Gilbert1206 (赞：1)

## 题解：P13787 地毯 加强版

[题目传送门](https://www.luogu.com.cn/problem/P13787)

## 思路

想必大家看到这道题时一定想到了暴力的做法，但是这道题的数据十分大 $1 \le  n  \le 5000$ 与 $m \le 2 \times 10^5$。如何优化呢？当然是二维前缀和与差分了。

### 前缀和

摘自 oiwiki

> 前缀和可以简单理解为「数列的前 $n$ 项的和」，是一种重要的预处理方式。

前缀和为一个离线的算法，去预处理前 $n$ 项的和，当然预处理的时间复杂度为 $O(n)$，查询只需要 $O(1)$ 的时间复杂度，非常的高效。

先来理解**一维前缀和**的做法。

![](https://cdn.luogu.com.cn/upload/image_hosting/zw1xb91a.png)

我们现在有一个长度为 $n$ 的数组，我们需要求 $l$ 至 $r$ 的和，就等于我需要求 $1$ 至 $r$ 的和减去 $1$ 至 $l$ 的和呀。这样我们只需要预处理知道 $1$ 至 $i$ 的和，即可在多次查询中快速地求出 $l$ 至 $r$ 的和，也很好的去得到前缀和的公式为 $ans=cmp_r-cmp_{l-1}$。

### 差分

假设现在我需要把 $(x_1,y_1)$ 至 $(x_2,y_2)$ 集体都加上一个数 $d$，此时我们不能直接所有遍历一遍，因为如果直接遍历的时间就会达到 $O(n^2)$。所以我们此时则需要用到二位差分。我们很容易想到给 $(x_1,y_1)$ 与 $(x_2+1,y_2+1)$ 各加上 $d$。可是这样就会多算 $(x_2+1,y_1)$ 与 $(x_1,y_2+1)$。所以我们需要给这两个各减去 $d$ 即可。

回来看这道题我们先用二维差分给铺垫子，然后在做二位前缀和即可，最后算出每个点的答案再相加。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[5001][5001],b[5001][5001];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int x1,x2,y1,y2;
        cin>>x1>>y1>>x2>>y2;
        b[x1][y1]+=1;
		if(y2+1<=n) {
        	b[x1][y2+1]-=1;  
		}
		if(x2+1<=n){
        	b[x2+1][y1]-=1;   
        }
        if(x2+1<=n&&y2+1<=n) {
        	b[x2+1][y2+1]+=1; 
        }
	}//二位差分
	
	for(int i=1;i<=n;i++){
		int now=0;
        for(int j=1;j<=n;j++){
            now+=b[i][j];
        	b[i][j]=now;
        }
    }//前缀和
	long long ans=0;
    for (int j=1;j<=n;j++) {
        int sum=0;
        for(int i=1;i<=n;i++) {
            sum+=b[i][j];//加上每次的答案
            ans+=(long long)((i+j)^sum);
        }
    }
    cout<<ans;
	return 0;
}

```

---

## 作者：_Weslie_ (赞：1)

## Solution P13787

### 简单差分

我们先说一维差分：我们设一个数组 $a$。那么差分数组 $b$ 的定义是：$b_i=a_{i+1}-a_i$。

看上去没什么。

但是当我们要求对 $[l,r]$ 区间加 $x$ 时，原本我们需要暴力枚举 $a$ 的区间 $[l,r]$，但是现在我们只需要两个步骤：$b_l\leftarrow b_l+x$ 和 $b_{r+1}\leftarrow b_{r+1}-x$。

为何呢？因为假设原先 $a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$。那么我们对 $[3,5]$ 区间加 $x$，得到 $a=\{a_1,a_2,a_3+x,a_4+x,a_5+x,a_6\}$。

不难发现，$b_3=a_4-a_3=(a_4+x)-(a_3+x)$，同理还有 $b_4$ 和 $b_5$。

只有 $b_2^{'}=(a_3+x)-a_2=b_2+x$ 并且 $b_6^{'}=a_6-(a_5+x)=b_6-x$。

也就意味着，只有两个位置的差分值改变了。

所以我们做到了 $\operatorname{O}(1)$。

但是问题是：你维护的只是差分数组。最终的原数组怎么维护呢？

很简单：如果 $a_0=0$，$a_x=a_x-a_{x-1}+a_{x-1}-a_{x-2}+a_{x-2}+\cdots+a_2-a_1+a_1-a_0=\sum\limits_{i=1}^xb_i$。

实际运行中，我们会让 $a_0=0$。

所以得到 $a_x=\sum\limits_{i=1}^xb_i$。

这样每次枚举 $[x_1,x_2]$ 范围内的行，$\operatorname{O}(1)$ 区间 $[y_1,y_2]$ 加，复杂度是 $\operatorname{O}(nm)$ 的，可以获得 $50$ 分。

### 二维差分

二维差分就不是这么好理解了。

先定义：$b_{i,j}$ 为 $a_{i,j}$ 与 $\sum\limits_{k=1}^i\sum\limits_{l=1}^{j-1}a_{k,l}+\sum\limits_{k=1}^{i-1}a_{k,j}$ 的差。

首先，由于原数组是差分数组的前缀和的属性，$a_{i,j}=a_{i-1,j}+a_{i,j-1}-a_{i-1,j-1}+b_{i,j}$。

我们来做一个理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/eakyoi4n.png)

这个是 $a_{i-1,j}$ 的区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/ajfahoej.png)

这个是 $a_{i,j-1}$ 的区域。

它们相加：

![](https://cdn.luogu.com.cn/upload/image_hosting/44dektqn.png)

你会发现深灰色区域被加了两次，所以要减去一次。

那么问题来了：如何二维差分 $\operatorname{O}(1)$ 完成矩阵加呢？

很简单：只需要变动四个位置。

- $b_{x_1,y_1}$：这个位置 $a$ 加 $1$，前面都是加 $0$。所以加 $1$。
- $b_{x_2+1,y_1}$：这个位置 $a$ 加 $0$，$a_{x_2,y_1}\leftarrow a_{x_2,y_1}+1$，所以应该减 $1$。
- $b_{x_1,y_2+1}$：与 $b_{x_2+1,y_1}$ 类似，减 $1$ 即可。
- $b_{x_2+1,y_2+1}$：由于 $a_{x_2,y_2}$ 加 $1$，导致计算时前三项 $a_{i-1,j}+a_{i,j-1}-a_{i-1,j-1}$ 小 $1$。所以这一项加 $1$，补回来使得 $a$ 增量为 $0$。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int sum[N][N];
int n,m;
long long ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y,xx,yy;i<=m;i++){
		scanf("%d%d%d%d",&x,&y,&xx,&yy);
		sum[x][y]++;
		sum[xx+1][yy+1]++;
		sum[xx+1][y]--;
		sum[x][yy+1]--;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			sum[i][j]=sum[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
			ans=ans+((i+j) xor sum[i][j]);
		}
	}
	printf("%lld",ans);
	return 0;
}

```

---

## 作者：MoonCake2011 (赞：1)

这对比原题加强了数据范围，我们不能暴力了。

这道题需要我们支持二维矩阵修改（覆盖地毯），暴力显然会 TLE。

这里我们请出二维差分。

假设我们现在要修改 $(x_1,y_1),(x_2,y_2)$ 的矩阵，我们可以使差分数组 $d_{x_1,y_1}$ 加上 $1$，$d_{x_1,y_2+1}$ 减去 $1$，$d_{x_2+1,y_1}$ 减去 $1$，$d_{x_2+1,y_2+1}$ 加上 $1$。

这样我们会发现 $a_{u,v}$ 真实值就是 $\sum_{i=1}^u\sum_{j=1}^v d_{i,j}$。

粗略证明就是 $d_{x_1,y_1}$ 贡献在 $d_{x_1,y_2+1}$ 和 $d_{x_2+1,y_1}$ 消掉了。

而多消的贡献在 $d_{x_2+1,y_2+1}$ 又补回来了，所以这是正确的。

做完修改后的 $a_{u,v}$ 可以利用递推和容斥（二维前缀和）来进行计算。

递推式是 $a_{u,v}=a_{u-1,v}+a_{u,v-1}-a_{u-1,v-1}+d_{u,v}$。

证明就是 $a_{u-1,v}$ 和 $a_{u,v-1}$ 有重合，所以用它们的贡献之和减去它们的重合部分 $a_{u-1,v-1}$，最后在加上新加入的 $d_{u,v}$。

然后这道题就做完了，代码十分简短。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5010][5010];
int n,m;
int main() {
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y,x2,y2;
		scanf("%d%d%d%d",&x,&y,&x2,&y2);
        a[x][y]++,a[x][y2+1]--,a[x2+1][y]--,a[x2+1][y2+1]++;
	}
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
    long long ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) ans=ans+((i+j)^a[i][j]);
    cout<<ans;
	return 0;
}
```

---

## 作者：elonzhang (赞：0)

# [P13787 地毯 加强版](https://www.luogu.com.cn/problem/P13787)

## 思路
首先先看暴力，就是拿一个二维数组，然后每个输入都循环去让对应的位置加一。然后我们要用二维前缀和，然后我们要学这道题的重要算法：二维差分。就是在这个矩形的左上角的位置加一，然后在右边界和下边界减一，在右下角加一，画个图来说就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/icz8wyil.png)

这样做就保证了除了这个矩形外的位置都没有受影响了。

## 正确代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define freop(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define int long long
#define double long double
#define re register
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
#define lb(x) (x&-x)
#define pii pair<int,int>
#define fir first
#define sec second
#define umap unordered_map
#define uset unordered_set
const int N=5002;
int n,m,sum[N][N],ans;//sum是前缀和数组

signed main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cout.tie(0);
//	freop();
//↑以上为初始化↑
//------------------------------
    cin >> n >> m;
    for(int i = 1;i<=m;++i){
        int l1,r1,l2,r2;
        cin >> l1 >> r1 >> l2 >> r2,//输入
        ++sum[l1][r1],++sum[l2+1][r2+1],//差分的预处理
        --sum[l1][r2+1],--sum[l2+1][r1];//差分的预处理
    }
    for(int i = 1;i<=n;++i)
        for(int j = 1;j<=n;++j)
            sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1],//处理前缀和
            ans+=(i+j)^sum[i][j];//计算题目要求的答案
    cout << ans << endl;
	return 0;
}
```

---

## 作者：return_third (赞：0)

二维差分的板子题。

# 一维差分

例题：[P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)

一维差分很好理解，令

$$
d_i=a_i-a_{i-1}
$$



那么修改会发生什么事呢？考虑边界情况：

- $d_x$：$a_x$ 已经加 $z$，而 $a_{x-1}$ 未修改，所以加 $z$。
- $d_{y+1}$：$a_{y}$ 已经加 $z$，而 $a_{y+1}$ 未修改，所以减 $z$。

综上，单次修改的代码是：

```cpp
d[x]+=z;
d[y+1]-=z;
```

容易发现

$$
a_i=\sum_{j=1}^{i}d_j
$$

然后取最小值就行了。

给出完整代码：

```cpp
#include<cstdio>
#include<climits>
#include<algorithm>
using namespace std;
const int N=5e6+5;
int n,p;
int a[N],d[N];
int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		d[i]=a[i]-a[i-1];
	}
	while(p--)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		d[x]+=z;
		d[y+1]-=z;
	}
	int sum=0,ans=INT_MAX;
	for(int i=1;i<=n;i++)
	{
		sum+=d[i];
		ans=min(ans,sum);
	}
	printf("%d\n",ans);
	return 0;
}
```

# 二维差分

令

$$
d_{i,j}=a_{i,j}-a_{i-1,j}-a_{i,j-1}+a_{i-1,j-1}
$$

那么如何修改呢？依旧考虑边界情况。

- $d_{x1,y1}$：$a_{x1-1,y1}$、$a_{x1,y1-1}$ 和 $a_{x1-1,y1-1}$ 均未修改，而 $a_{x1,y1}$ 已经加 $1$，所以加 $1$。
- $d_{x2+1,y1}$：$a_{x2+1,y1}$、$a_{x2+1,y1-1}$ 和 $a_{x2,y1-1}$ 均未修改，而 $a_{x2,y1}$ 已经加 $1$，所以减 $1$。
- $d_{x1,y2+1}$：$a_{x1,y2+1}$、$a_{x1-1,y2+1}$ 和 $a_{x1-1,y2}$ 均未修改，而 $a_{x1,y2}$ 已经加 $1$，所以减 $1$。
- $d_{x2+1,y2+1}$：$a_{x2+1,y2+1}$、$a_{x2,y2+1}$、$a_{x2+1,y2}$ 均未修改，而 $a_{x2,y2}$ 已经加 $1$，所以加 $1$。

综上，单次修改的代码是：

```cpp
d[x1][y1]++;
d[x2+1][y1]--;
d[x1][y2+1]--;
d[x2+1][y2+1]++; 
```

容易发现

$$
a_{i,j}=\sum_{x=1}^{i}\sum_{y=1}^{j}d_{x,y}
$$

然后按照题意遍历一下求和就行了。

给出完整代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=5005;
int n,m;
int d[N][N],a[N][N];
int main()
{
    scanf("%d%d",&n,&m);
    while(m--)
	{
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		d[x1][y1]++;
		d[x2+1][y1]--;
		d[x1][y2+1]--;
		d[x2+1][y2+1]++; 
	}
    long long ans=0;
    for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
        {
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+d[i][j];
            ans+=(i+j)^a[i][j];
        }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：zybgml (赞：0)

题目链接：[P13787 地毯 加强版](https://www.luogu.com.cn/problem/P13787)

# 题目大意
给你一个有 $n\times n $ 个格子的坐标，再在上面铺 $m$ 块地毯，问你每个位置的**行数加列数**异或**被多少个地毯覆盖**的和。
# 做法1：暴力
我们利用一个二维数组来记录每个点被多少个地毯覆盖，最后按要求输出。可是那样的话，时间复杂度度太高了，有没有更简单且高效的方法呢？

有的兄弟，有的。想修改区间值的话 **二维差分** 是一个十分简单的方法。
# 正解：二维前缀和 $+$ 二维差分
## 相关知识：一维前缀和 $+$ 一维差分
### 一维前缀和
假如给你一个数组，你有没有一种可以用 $O(1)$ 的时间复杂度求出其中的任意一个区间和的方法呢？**一维前缀和** 是一种可以只用时间复杂度为 $O(n)$ 预处理就可以用 $O(1)$ 的时间复杂度求出任意区间和的方法。它的原理简单易懂：

我们将数组中第 $i$ 个数变成前 $i$ 个数的总和，这样就完成预处理啦！

所以现在如何求区间和呢？假如有 $5$ 个数：
```cpp
1 2 3 4 5
```
预处理后 $5$ 个数为：
```cpp
1 3 6 10 15
```
而如果我们要求区间 $[2,4]$ 的总和，只需要用预处理后的第 $4$ 个数减去第 $1$ 个数就可以了！

为什么呢？其实原理非常简单：预处理后的第 $4$ 个数为前 $4$ 个数的总和，第 $1$ 个数为前 $1$ 个数的总和。两者相减，不就是第 $2$ 个数至第 $4$ 个数的总和吗？

可是如果我们还要先更改区间值又该如何呢？

**一维差分** 可以帮你解决此问题：

### 一维差分

同样 $5$ 个数：
```cpp
1 2 3 4 5
```
我们要将区间 $[2,4]$ 中的每一个数都加上 $1$ 该如何做呢？

**一维差分** 同样需要先用时间复杂度为 $O(n)$ 的预处理，使原数组的第 $i$ 个数为前 $i$ 个数的总和：
预处理后 $5$ 个数为：
```cpp
1 1 1 1 1
```
也就是说，**本来的数组**为现在**预处理后的数组**的**前缀和**数组！

现在，如果我们将第 $2$ 个数加上 $1$ 的话，**本来的数组**会有什么变化呢？
```cpp
1 3 4 5 6
```
不难发现，从第 $2$ 个数开始，每个数都加了 $1$。

聪明的人已经看出，现在我们只要将第 $5$ 个数加上 $-1$，就完成了将区间 $[2,4]$ 中的每一个数都加上 $1$ 的操作。

原因是我们通过反向利用 **一维前缀和** ，来高效修改了区间值。
### 二维前缀和

懂了 **一维前缀和** 的相信很快也能理解 **二维前缀和**。

**二维前缀和** 其实也很好推，这里不举例了。

假如有一个二维数组，我们要求 $(1,1)$ 至 $(x,y)$ 的矩阵中的所有数的和。

现在设 $a[i][j]$ 为第 $i$ 行第 $j$ 列的数，$s[i][j]$ 为 $(1,1)$ 至 $(i,j)$ 的矩阵中的所有数的和,那么：

$s[x][y]=a[x][y]+s[x-1][y]+s[x][y-1]-s[x-1][y-1]$。

利用容斥原理可以理解上式。
### 二维差分

**二维差分** 其实也同 **一维差分**一样，是“反向前缀和”。

同样 **一维差分**一样需要先用时间复杂度为 $O(n^2)$ 的预处理。设预处理后的数组为 $c$。

如果我们要将一个二维数组的 $(x,y)$ 至 $(z,s)$ 矩阵中的每一个数加 $1$ 只需 $4$ 步：
```cpp
c[x][y]++;
c[x][s+1]--;
c[z+1][y]--;
c[z+1][s+1]++;
```
现在都知道该如何做了吧！
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T&x){
	x=0;char c;int sign=1;
	do{c=getchar_unlocked();if(c=='-') sign=-1;} while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar_unlocked();}while(isdigit(c));
	x*=sign;
}
int n,m;
int c[5050][5050];
int x,y,z,s;
long long ans;
int main(){
    read(n),read(m);
    for(int i=1;i<=m;i++){
        read(x),read(y),read(z),read(s);
        c[x][y]++;
        c[x][s+1]--;
        c[z+1][y]--;
        c[z+1][s+1]++;
        //差分处理
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
        	c[i][j]=c[i-1][j]+c[i][j-1]-c[i-1][j-1]+c[i][j];//前缀和处理
        	ans+=(i+j)^c[i][j];//计算答案
		}
    }
    cout<<ans;
    return 0;
}
```
这道题跟[P3397 地毯](https://www.luogu.com.cn/problem/P3397) 题干完全一样，只是数据增强与输出不同。可以复习巩固关于 **前缀和** 与 **差分** 的基础知识，也值得一做。

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P13787 地毯 加强版](https://www.luogu.com.cn/problem/P13787)

### 题目解法

二维差分板子。根据题目，如果有一个地毯的左上角 $(x_1,y_1)$ 满足 $x_1 \leqslant i$ 且 $y_1 \leqslant j$，则其会为 $f_{i,j}$ 贡献 $1$。因此我们用二维前缀和推 $f_{i,j}$ 的话，就要在 $(x_1,y_1)$ 处加上 $1$。

现在我们发现，如果 $x_2 > i$ 或 $y_2 > j$，这块地毯其实不应该贡献（但贡献了），那么我们需要在 $(x_1,y_2+1)$ 和 $(x_2+1,y_1)$ 处各减 $1$。

现在我们又发现，如果 $x_2 > i$ 且 $y_2 > j$，这块地毯虽然不应该贡献，但它被删了两次，因此我们还需要在 $(x_2+1,y_2+1)$ 处再加回来。

现在再二维前缀和，得到的就是正确的结果了。

二维前缀和：我们设 $f_{x,y}$ 为所有 $i \leqslant x$ 且 $j \leqslant y$ 的 $d_{i,j}$ 之和，则可以找出递推关系。

若让 $f_{i,j}$ 为 $f_{i-1,j}+f_{i,j-1}$，则 $f_{i-1,j-1}$ 会贡献两次，因此再减掉它即可。

### 代码实现

```cpp
#include<iostream>
using namespace std;
const int N=5003;
int n,m,d[N][N],f[N][N];
long long ans;
int main(){
    cin>>n>>m;
    while(m--){
        int x1,x2,y1,y2;
        cin>>x1>>y1>>x2>>y2;
        d[x1][y1]++;
        d[x1][y2+1]--;
        d[x2+1][y1]--;
        d[x2+1][y2+1]++;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+d[i][j];
            ans+=i+j^f[i][j];
        }
    }
    cout<<ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/232360967)。

---


# 魔族密码

## 题目背景

风之子刚走进他的考场，就……

花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花）

风之子：我呕……（杀死人的眼神）快说题目！否则……-\_-###

## 题目描述



花花：……咦~~好冷~~我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉\*^\_^\*）。

魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含 $1$ 个字母，至多 $75$ 个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链：

- $\verb!i!$；
- $\verb!int!$；
- $\verb!integer!$。

但下面的单词不组成词链：

- $\verb!integer!$；
- $\verb!intern!$。

现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。

风之子：密码就是最长词链所包括的单词数阿……


## 样例 #1

### 输入

```
5
i
int
integer
intern
internet
```

### 输出

```
4
```

# 题解

## 作者：Rainbow_qwq (赞：73)

[原题链接](https://www.luogu.org/problemnew/show/P1481)

**字符串版最长上升子序列。**

各位大佬都用string吗？

虽然string方便，但我不会用string，所以我还是用char数组好了。。

看到一个大佬用char的函数strncmp()，其实，char里也有一个函数，叫做：
```cpp
strstr(s1,s2)

作用：
判断s2是否为s1的子串。
如果没找到，返回NULL;
如果找到了，返回这个子串第一个字符的地址。

如：
char s1[]="habch",s2[]="abc"
strstr(s1,s2)就返回s1中'a'的地址

头文件为：

#include<cstring>
```
估计没什么人知道吧。。。

于是我果断打了一个dp代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[2010][80];//二维char存储多个字符串
int f[2010],n,ans;
int main()
{
	ios::sync_with_stdio(0);//cin,cout优化
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];//整行读入
		f[i]=1;
		for(int j=i-1;j>=1;j--)
			if(strstr(s[i],s[j])!=NULL)//找得到这个子串
				f[i]=max(f[j]+1,f[i]);//dp处理
		ans=max(f[i],ans);
	}
	cout<<ans;
	return 0;
}
```
但是交上去，WA了一半。。。

后来，我发现了问题：
```cpp
s1="hhhabchhh"
s2="abc"
s2是s1的子串，但s2并不能接在s1上，不能组成词链。
要想要s2能接在s1上，则s2首字符地址==s1首字符地址
所以我们修改代码：

for(int j=i-1;j>=1;j--)
	if(strstr(s[i],s[j])==s[i])
    //不仅要找得到这个子串，还必须能接在s[i]上
    //即：返回的首字符地址==s[i]的首字符地址
		f[i]=max(f[j]+1,f[i]);//符合要求，进行dp
ans=max(f[i],ans);
```
修改后终于AC了！

**AC 代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[2010][80];
int f[2010],n,ans;
int main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];
		f[i]=1;
		for(int j=i-1;j>=1;j--)
			if(strstr(s[i],s[j])==s[i])
				f[i]=max(f[j]+1,f[i]);
		ans=max(f[i],ans);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zuytong (赞：28)

**好吧，看了那么多题解，都没有一个用map的**

**让我来秀一下（逃**


------------
首先，先把所有的字符串用map记录个数

然后再把每个字符串截取，用sum存子串的总个数

最后与ans取最大值


------------
代码奉上：
```cpp
#include<bits/stdc++.h>
using namespace std;
map <string,int> f;
int n,ans;
string s[2005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        f[s[i]]++;
    }
    for(int i=1;i<=n;i++)
    {
        int sum=0; string a="";
        for(int j=0;j<s[i].size();j++) a+=s[i][j],sum+=f[a];
        ans=max(ans,sum);
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：RetrO (赞：27)

哇一个好好的字典树题被变成了dp，应该是从根节点开始建树，建立每一个单词，每一个单独的链上都是一堆单词组成，最后max一下就可以了

     
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=2010;
struct edge{
    int link[27];
    int s;
}t[MAXN];
int n,m,cnt;
int ans;
void zbr(char *c)
{
  int ansm=0;
  int p=0;
  int i;
  int len=strlen(c);
  for(int i=0;i<len;i++)
  {
      int zz=c[i]-'a'+1;
      if(t[p].link[zz]==0)
      t[p].link[zz]=++cnt;
      p=t[p].link[zz];
      ansm+=t[p].s;
      }    
      if(ansm>=ans)
      ans=ansm+1;
      t[p].s++;
 } 
 int main()
 {
     int i;
     char c[110]="";
     scanf("%d",&n);
     for(int i=1;i<=n;i++)
     {
         scanf("%s",c);
         zbr(c);
     }
     printf("%d\n",ans);
     return 0;
}
```

---

## 作者：da32s1da (赞：14)

这个题，叫我做，不就简单了吗？？？我使用
### ~~正交分解法！~~STRING头文件のfind()函数

```cpp
#include<iostream>
#include<string>
using namespace std;
string s[2018];
int wz[2018],n;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>s[i];wz[i]=1;for(int j=i-1;j>=1;j--)
		if(s[i].find(s[j])==0) wz[i]=(wz[j]+1)>wz[i]?(wz[j]+1):wz[i];
		wz[0]=wz[i]>wz[0]?wz[i]:wz[0];
	}cout<<wz[0];
	return 0;
}
```
我们先读入，然后使用类似导弹拦截的思路(不过更简单，可看做是只求最大能击落的炮弹数量)，若s[j]能在s[i]中出现，那么更新wz[i]的值,输入一个处理一个，求max。
#### find用法
```cpp
//string类的查找函数：

int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置
int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置
int find(const string &s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
//查找成功时返回所在位置，失败返回string::npos的值

int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置
int rfind(const char *s, int pos = npos) const;
int rfind(const char *s, int pos, int n = npos) const;
int rfind(const string &s,int pos = npos) const;
//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值

int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置
int find_first_of(const char *s, int pos = 0) const;
int find_first_of(const char *s, int pos, int n) const;
int find_first_of(const string &s,int pos = 0) const;
//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos

int find_first_not_of(char c, int pos = 0) const;
int find_first_not_of(const char *s, int pos = 0) const;
int find_first_not_of(const char *s, int pos,int n) const;
int find_first_not_of(const string &s,int pos = 0) const;
//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos

int find_last_of(char c, int pos = npos) const;
int find_last_of(const char *s, int pos = npos) const;
int find_last_of(const char *s, int pos, int n = npos) const;
int find_last_of(const string &s,int pos = npos) const;

int find_last_not_of(char c, int pos = npos) const;
int find_last_not_of(const char *s, int pos = npos) const;
int find_last_not_of(const char *s, int pos, int n) const;
int find_last_not_of(const string &s,int pos = npos) const;
//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找

```


---

## 作者：Zoe_Granger (赞：14)

## 如果这篇题解通过了，那它就是本蒟蒻的第一篇题解了

不要问我为什么突然想写题解，~~可能是因为上课的时候突然脑抽？或者突然手闲？（bu）~~ 
大概是因为想挑战一下最短代码叭……~~方法不重要~~

~~**其实也没指望着能被通过，Zoe在线作死**~~

### 咳咳，以下正文：

因为做这道题前刚做过最长上升子序列，所以很快就想出来dp怎么做了——把判断条件改一下就好啦。

那么判断条件怎么写呢？此处我用到的是string自带的函数substr。举例如下：

```cpp
string s="123456";
string t=s.substr(0,3); //从s的0号位置截取连续的长度为3的子串
cout <<t; 
```

所以上面程序输出的是123。

那么我们的dp怎么写呢？作为一只初学dp的蒟蒻，老师告诉我需要考虑四点问题：

1. 状态：$f_i$ 表示以第$i$号位置结尾最多可以取的单词数

2. 答案：$f_n$

3. 转移：$f_i = max(f_j+1,f_i)$

4. 初值：$f_i = 1$

那接下来的事情就很简单了，按照上述思路写代码就好啦，AC代码奉上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, f[2010], ans;
string s[2010];
int main()
{
	scanf ("%d", &n);
	for (int i=1; i<=n; i++)
		cin >>s[i];
	
	for (int i=1; i<=n; i++)
	{
		f[i] = 1;
		for (int j=1; j<i; j++)
			if (s[j]==s[i].substr(0,s[j].size())) //从s[i]的0号位置截取s[j]长度的子串，判断是否与s[j]相等。
				f[i] = max(f[j]+1, f[i]);
		ans = max(f[i], ans);
	}
	printf ("%d", ans);
	return 0;
}

```


---

## 作者：离散小波变换° (赞：8)

## 题目大意

按照字典序输入$n$个长度不超过$75$的字符串。询问从中最多选择出多少歌字符串，使得每个字符串都是后面一个字符串的前缀。

## 题解

楼上给了挺多$\text{Trie,暴力匹配,map}$的做法，这里讲一讲$\text{Hash}$以及它的相关优化吧。

根据题意，设$dp_i$表示以第$i$个字符串结尾的字符串链的最大长度。那么我们可以推出状态转移方程：

$$dp_i=\max_{\text{$s_j$为$s_i$前缀}}\{dp_j\}+1$$

那么如何判断那些字符串是$i$的前缀呢？

题目非常良心地告诉了我们这些字符串都是按照字典序排列的。因此，若$s_j$为$s_i$的前缀，那么肯定就有$j<i$。于是，我们可以将$i$之前所有的字符串插入到哈希表里。然后搜索起来就非常方便了。

这里按照这样的方法进行哈希：

$$H(S)=\sum_{i=0}^{S.size-1}S_i\times seed^i$$

换句话说，就是将$S$转换成$seed$进制。为了方便处理，我们对它使用$\text{unsigned long long}$的自然溢出。(即自动对$2^{64}$取模)

很显然，当$i$进行到第$k$步时，$H$的值为$S$的前缀$S_{0..k}$的哈希值。因此我们只需要通过这个哈希值寻找前面是否有字符串的哈希值为$H$就可以了。关于哈希表的实现，最简单的方法就是用$\text{map}$直接映射。这里用链式前向星实现一个简单的链表哈希。

我们知道，链式前向星（就是图论里经常用来建图的那个），其本质为**动态链表**。$\text{add(u,v,w)}$本质上和邻接表类似，就是在头指针为$u$的链表里插入了两个数$u$和$w$。由于哈希值可能很大($2^{64}$级别)，所以我们将它对$T=10^5+3$取模，这样就可以进行初步分类（两个相同的哈希值模同一个数余数相同）；然后每个链表内插入哈希值原始数据$H$，查询的时候只需要搜索对应表头中是否有对应哈希值即可。

用这种方法的有点是在不开$O(2)$的情况下得到比$\text{map}$更快的速度(开了$O2$依旧容易被$\text{STL}$吊打$\text{orz}$)。同时用取模缩小了空间复杂度，用几乎可以忽略的小规模的搜索避免了哈希碰撞，最终能获得较好的效果。

时间复杂度$\mathcal O(L)$，其中$L$为字符串总长度。

虽然哈希算法讲了一大堆，然而实现起来只有链式前向星和几句话的查找。所以其实码量挺小的。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
typedef unsigned long long ULL;
const int MAXN =2e3+3,MAXM=75+3;
int n,dp[MAXN],ans; char T[MAXM]; ULL seed=13331;

int reads(char *s){
    int len=0,c; while((c=getchar())==10||c==13||c==32);
    if(c==EOF) return -1;
    s[len++]=c;  while((c=getchar())!=10&&c!=13&&c!=32&&c!=EOF)
    s[len++]=c;  s[len]=0; return len;
}
const int SIZ=1e5+3;
int head[SIZ],nxt[MAXN],val[MAXN],tot; ULL ver[MAXN];
void add(int u,ULL v,int w){
    ver[++tot]=v,nxt[tot]=head[u],val[tot]=w,head[u]=tot;
}
int  fnd(ULL h){
    int p=h%SIZ; for(int i=head[p];i;i=nxt[i])
    if(ver[i]==h) return val[i]; return 0;
}
int main(){
    n=qread(); up(1,n,i){
        int lt=reads(T); ULL h=0; up(1,lt,j){
            h=h*seed+T[j-1],dp[i]=max(dp[i],dp[fnd(h)]);
        }
        ++dp[i]; add(h%SIZ,h,i),ans=max(ans,dp[i]);
    }
    printf("%d\n",ans);
    return 0;   
}
```

---

## 作者：风羽跃 (赞：8)

### 这道题也是最最长不下降子序列的思路……

看了看其他题解，拓扑、哈希……本蒟蒻只会用find函数。

可以把每一个字符串看作一个数，其中如果a字符串包含b字符串，可以看做a数比b数大。然后就可以跑一边最长升了。
注意最后要统计答案。
```
#include<iostream>

#define maxn 2001

using namespace std;

int n,f[maxn],maxlen;//f[i]表示到第i个串最长链长度
string s[maxn];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		f[i]=1;//初始值每一个串都是一条单独的链，长度为1
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){//枚举i往后的串
			if(s[j].find(s[i])==0) f[j]=max(f[j],f[i]+1);//由i递推到j
		}
	}
	for(int i=1;i<=n;i++){
		maxlen=max(maxlen,f[i]);//统计答案
	}
	cout<<maxlen<<endl;
	return 0;
}
```
#### 关于find函数的一点：

如果a字符串不包含b串，a.find(b)返回string::npos

---

## 作者：Cesare (赞：5)

翻了翻题解没有哈希做法，来发一下。

## $Solution$

本题就是用一个单词作为词根，有多少个单词是他的前缀，求最多前缀的个数。

考虑哈希实现比较前缀的过程。

先预处理哈希数组 $Ha_{i, j}$ 表示第 $i$ 个到第 $j$ 位的哈希值。

比较方法就是判断 $Ha[i][len] == Ha[j][len]$ 。

采用了自然溢出哈希，比较方便不用取模。

## $Code:$

```cpp
#include <bits/stdc++.h>
//#include <tr1/unordered_map>
//#include"Bignum/bignum.h"
//#define lll bignum
#define lowbit(x) (x & -x)
#define debug(x) (cout << "#x = " << (x) << endl)
#define Set(x, i) memset (x, i, sizeof(x))
#define R register
#define For(i, j, k) for(R int i = (j); i <= (k); ++i)
#define foR(i, j, k) for(R int i = (j); i >= (k); --i)
#define Cross(i, j, k) for(R int i = (j); i; i = (k))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll N = 2011;
const ll INF = 5e16;

/*
	设 f[i] 表示用第 i 个单词做词头能包含的 
	最多的单词数。 
*/

ll n, f[N];
char s[N][N];

namespace IO {

	inline char gc() {
		static char buf[100000], *p1 = buf, *p2 = buf;
		return (p1 == p2) && (p2 = (p1 = buf) +
			fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
	}

	#define dd ch = getchar()
	inline ll read() {
		ll x = 0; bool f = 0; char dd;
		for (; !isdigit (ch); dd) f ^= (ch == '-');
		for (; isdigit (ch); dd)  x = x * 10 + (ch ^ 48);
		return f? -x: x;
	}
	#undef dd

	inline void write( ll x ) {
		if (x < 0) putchar ('-'), x = -x;
		if (x > 9) write (x / 10); putchar (x % 10 | 48);
	}

	inline void wrn ( ll x ) { write (x); putchar (' '); }

	inline void wln ( ll x ) { write (x); putchar ('\n'); }

	inline void wlnn ( ll x, ll y ) { wrn (x), wln (y); }

}

using IO::wln;
using IO::read;

ll Ans = 0;
ull Base = 131, Ha[N][N];

int main()
{
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	n = read();
	For ( i, 1, n ) cin >> (s[i] + 1);
	For ( i, 1, n ) {
		ll len = strlen (s[i] + 1);
		For ( j, 1, len ) Ha[i][j] = Ha[i][j - 1] * Base + s[i][j];
	}
	For ( i, 1, n ) {
		ll A = 0, len = strlen (s[i] + 1);
		For ( j, 1, n ) {
			ll Len = strlen (s[j] + 1);
			if (len >= Len && Ha[i][Len] == Ha[j][Len]) ++A;
		}
		f[i] = A;
	} 
	For ( i, 1, n ) Ans = max (Ans, f[i]);
	return wln (Ans), 0;
}

/*

*/



```

---

## 作者：qianfujia (赞：5)

## 似乎还没拓扑的方法
## 我来一发
前缀向其后面连边

每个点、每条边只可能做一次

$O(n+m)$

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[2010][75];
int next[2010][2010];
int f[2010];
int n;
int in[2010];
bool vis[2010];
int zan[2010];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%s",s[i]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
		{
			if(i!=j)
			{
				if(strlen(s[i])>=strlen(s[j]))continue;
				bool flag=true;
				int len=strlen(s[i]);
				for(int k=0;k<len;++k)
					if(s[i][k]!=s[j][k])
					{
						flag=false;
						break;
					}
                //判断
				if(flag)
				{
					next[i][++next[i][0]]=j;
					++in[j];
				}
                //连边
			}
		}
	int cnt=n;
	for(int i=1;i<=n;++i)
		zan[i]=in[i];
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			if(!vis[j]&&in[j]==0)
			{
				for(int k=1;k<=next[j][0];++k)
					--zan[next[j][k]];
				vis[j]=true;
				--cnt;
			}
		}
		if(cnt==0)
		{
			printf("%d",i);
			return 0;
		}
		for(int j=1;j<=n;++j)
			in[j]=zan[j];
	}
    //拓扑
	return 0;
}
```

---

## 作者：NTG_Adiord (赞：3)

**C++的踹树做法**

用踹树构建然后再跑遍DFS就行了

代码如下

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct tiel{
	int non[26];
	int ed;//当前节点是几个单词的结尾
}a[800000];
int nod=0;
int n;
int len;
int anss;
char noc[400];
void dfs(int nod,int ans){
	ans+=a[nod].ed;//ans记录
	bool die=1;
	for(int w=0;w<=25;w++){
		if(a[nod].non[w]!=0)dfs(a[nod].non[w],ans),die=false;//如果这个节点下面没有了就收尾
	}
	if(die==true)anss=max(anss,ans);//取最大的
}
int main(){
	scanf("%d",&n);
	for(int w=1;w<=n;w++){
		scanf("%s",noc);
		len=strlen(noc);
		int nonc=0;
		for(int i=0;i<len;i++){
			//我懒得写构造函数了，Tiel树构建部分
			while(a[nonc].non[noc[i]-'a']!=0&&i<len){
				nonc=a[nonc].non[noc[i]-'a'];
				if(i==len-1)a[nonc].ed++;
				i++;
			}
			if(i<len){
				nod++;
				a[nonc].non[noc[i]-'a']=nod;
				nonc=nod;
				if(i==len-1)a[nonc].ed++;
			}
			//Tiel树构建部分
		}
	}
	dfs(0,0);
	printf("%d",anss);
}

```

---

## 作者：prefer (赞：2)

# 解法：记忆化搜索

dfs中判断方法：我使用了string中的find函数！

find函数如果找到，会返回找到的开头的位置的下标。

举例：

abc

abcabc

012345

abcabc.find(abc)=0

本题由于要求是前缀，所以开头位置下标应该是0！

-----------------------------------

需要注意一下：要for循环枚举每一个起始点，如果只是单纯的dfs(1)会WA！

代码有注释

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,f[200005];
string s[20005];
int dfs(int Nnum){//Nnum表示现在搜到的字符串的序号
	if(f[Nnum]!=-1) return f[Nnum];//记忆化
	int dfs1=0;//用于记忆化
    for(int i=Nnum+1;i<=n;i++) //往后面搜
        if(s[i].find(s[Nnum])==0) //如果当前字符串是后面字符串的前缀
			dfs1=max(dfs1,dfs(i)+1); 
    return f[Nnum]=dfs1;//标记
}
int main(){
    memset(f,-1,sizeof(f));//初始化
	scanf("%d",&n);
    for(int i=1;i<=n;i++) cin>>s[i];
    for(int i=1;i<=n;i++) printf("%d\n",dfs(i)+1);
    return 0;
}
```

ok

---

## 作者：lianliangyu (赞：2)

#### 分明就是一道Trie树裸题...
用Trie树储存字母，然后跑一遍bfs，记录这个单词包含了多少个单词。

（如果某一个字母是另一个单词的结尾，那么计数器+1）
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
struct tree
{
	int son[26],cnt;
	bool word;
	tree(){memset(son,0,sizeof(son)),cnt=0,word=false;}
}t[150000];
int num;
queue <int> q;
inline void insert(string s)
{
	int now=0;
	for(register int i=0;i<s.size();i++)
	{
		int v=s[i]-'a';
		if(!t[now].son[v]) t[now].son[v]=++num;
		now=t[now].son[v];
	}
	t[now].word=1;
}                                                    //建树存词不用多说 
inline int bfs()                                     //广搜bfs 
{
	int now=0,ans=0;
	q.push(now);
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(register int i=0;i<26;i++)
		{
		if(t[now].son[i]) q.push(t[now].son[i]);
		t[t[now].son[i]].cnt=t[now].cnt;
		if(t[t[now].son[i]].word) t[t[now].son[i]].cnt++; //判断该字母是不是另一个单词的结尾 
		}
		if(ans<t[now].cnt) ans=t[now].cnt;
	}
	return ans;
}
int main()
{
	int n,i,ans;
	string s;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		cin>>s;
		insert(s);
	}
	ans=bfs();
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：daniel14311531 (赞：2)

# **C++ STL 大法好！**

C++STL里有一个叫**string**的东西，它有一个叫**find（）**的函数，当**s1.find(s2)=0** 时，**s1的前缀就是s2**了。

剩下的便是熟知的**最长上升子序列**了。

  

    
    
```cpp
    #include<bits/stdc++.h>//万能库大法好
    using namespace std;
    int n,ans=0;
    string s[2010];//STL大法好
    int dp[2010];
    int max(int x,int y)//系统函数慢
    {
        return x<y?    y:x;
    }
    int main()
    {
        ios::sync_with_stdio(0);//懒人做法
        cin>>n;
        for(int i=1;i<=n;i++)    cin>>s[i];
        for(int i=1;i<=n;i++)
        {
            dp[i]=1;
            for(int j=1;j<i;j++)
                if(s[i].find(s[j])==0)//重头戏在这里
                    dp[i]=max(dp[i],dp[j]+1);
            ans=max(ans,dp[i]);
        }
        cout<<ans;
        return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：2)

## string中，别人都用find，我用substr！
### code:
![](https://cdn.luogu.com.cn/upload/pic/38466.png)

---

## 作者：daks (赞：1)

DP
判断一个单词是不是另一个单词的前缀，给出暴力和双关键字hash两种打法

```cpp
//暴力
#include<iostream>
#include<cstring>
using namespace std;
string s[2005];
int f[2005];
bool pd(int x,int y)
{
    if(s[x].size()>s[y].size())
    {    
     for(int i=0;i<s[y].size();i++)
      if(s[x][i]!=s[y][i])
       return false;
    return true;
    }
    else
     return false;
}
int main()
{
    int N,maxx=0;
    cin>>N;
    for(int i=1;i<=N;i++)
    {
        cin>>s[i];
        int maxn=0;
        for(int j=1;j<i;j++)
         if(pd(i,j))
          maxn=max(maxn,f[j]);
        f[i]=maxn+1;
        maxx=max(maxx,f[i]);
    }
    cout<<maxx;
}
//hash,类似前缀和
#include<iostream>
#include<cstring>
using namespace std;
string s[2005];
int f[2005];
unsigned long long h1[2005][80],h2[2005][80],p1[1000],p2[1000];
void hash1(int x)
{
    h1[x][1]=s[x][0]-'a'+1;
    for(int i=2;i<=s[x].size();i++)
     h1[x][i]=(s[x][i-1]-'a'+1)*p1[i]+h1[x][i-1];
}
void hash2(int x)
{
    h2[x][1]=s[x][0]-'a'+1;
    for(int i=2;i<=s[x].size();i++)
     h2[x][i]=(s[x][i-1]-'a'+1)*p2[i]+h2[x][i-1];
}
bool pd(int x,int y)
{
  if(s[x].size()<=s[y].size())
   return false;
  if(h1[y][s[y].size()]==h1[x][s[y].size()]&&h2[y][s[y].size()]==h2[x][s[y].size()])
   return true;
return false;
}
int main()
{
    int N,maxx=0;
    cin>>N;
    p1[0]=p2[0]=1;
    for(int i=1;i<=76;i++)
     p1[i]=p1[i-1]*29;
    for(int i=1;i<=76;i++)
     p2[i]=p2[i-1]*37;
    for(int i=1;i<=N;i++)
    {
        cin>>s[i];
        hash1(i);
        hash2(i);
        int maxn=0;
        for(int j=1;j<i;j++)
         if(pd(i,j))
          maxn=max(maxn,f[j]);
        f[i]=maxn+1;
        maxx=max(maxx,f[i]);
    }
    cout<<maxx;
}
```

---

## 作者：never_see (赞：1)

**思路和楼下的其实差不了多少，但是，楼下的都太复杂了，没有正确地好好使用char的相关函数，一个strncmp能搞定的为什么要那么复杂**

我一开始以为用string更方便，但是没有找到比较好的比较函数，索性就用了char


思路：首先考虑到字符串应该要排序，不过题干里说明了，按字典序给出，那就很好办了，不然我也不知道char怎么排。

**核心要点**是用f[i]表示第i个字母能得到的最优解，只需一个j(1<=j<i)，在下标为j的f中找到一个可以匹配并且值最大的，选择这个f[j]，并加上它本身的这一个单词数，即f[i]=f[j]+1


```cpp
#include<cstdio>
#include<cstring>
#define MAXN 2001
char s[MAXN][76];
int f[MAXN];
int main()
{
    int n;
    scanf("%d\n",&n);
    for(int i=1;i<=n;i++)
        scanf("%s",s[i]);
    f[1]=1;//初始化，第一个字串的最优解为1
    for(int i=2;i<=n;i++)
    {
        int MAX=0;
        for(int j=i-1;j>=1;j--)
            if(MAX<f[j]&&!strncmp(s[i],s[j],strlen(s[j])))//找到一个最大的，重点是strncmp这个函数，用法:strncmp(字符串1，字符串2，长度n）
                MAX=f[j];
        f[i]=MAX+1;
    }
    int ans=0;
    for(int i=1;i<=n;i++)//因为最优解不一定在f[n]中，所以需要扫一遍
        if(ans<f[i])
            ans=f[i];
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ronwhite (赞：0)

直接按长度sort一下后求lis即可，注意单词要从第一位开始匹配

···cpp


    

                    
                    
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#define rep(i,s,t) for(int i=s;i<=t;i++)
using namespace std;
int n;
string word[2500];
int f[2500];
int cmp(string a,string b)
{
    if(a.size()<b.size()) return true;
    if(a.size()>b.size()) return false;
    return a<b;
}
int main()
{
    scanf("%d",&n);
    rep(i,1,n)
    cin>>word[i];
    sort(word+1,word+n+1,cmp);
    rep(i,1,n) f[i]=1;
    rep(i,1,n)
        rep(j,1,i-1)
        {int site=word[i].find(word[j]);
                if(site==0)
                    f[i]=max(f[i],f[j]+1);
        }
    int ans=0;
    rep(i,1,n)
    ans=max(ans,f[i]);
    printf("%d",ans);
    return 0;
}
```
···

---

## 作者：doby (赞：0)

本题≈最长不降子序列，只不过貌似是字符串版的……

状态转移方程：……算了我们不推了，就模拟吧……

```cpp
#include<string>
#include<iostream>
using namespace std;
string a[2001];
int n,b[2001],maxn=1,sum,pd;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){cin>>a[i];}
    b[1]=1;//第一个最长为1
    for(int i=2;i<=n;i++)
    {
        sum=0;
        for(int j=i-1;j>=1;j--)
        {
            pd=1;//判断是否每一位相同
            if(b[j]<sum||a[i].size()<a[j].size()){continue;}//微小的剪枝（毫无卵用）
            for(int k=0;k<a[j].size();k++){if(a[i][k]!=a[j][k]){pd=0;break;}}//如果有一位不一样，退出
            if(pd){sum=max(sum,b[j]);}//如果前缀相同，找最大的
        }
        b[i]=sum+1,maxn=max(maxn,b[i]);//最长不降……
    }
    cout<<maxn;
}
```

---

## 作者：q18921892 (赞：0)

本来觉得过不了的代码就这样神奇AC了。。。

前一个单词是后一个的前缀时就+1。。


```cpp
var i,j,n,ans:longint;
    s:array[1..2001] of string;
    f:array[1..2001] of longint;
begin
  readln(n);
  for i:=1 to n do
    readln(s[i]);
  for i:=1 to n do
    for j:=1 to n do
      if pos(s[i],s[j])=1
        then inc(f[j]);
  for i:=1 to n do
    if f[i]>ans then ans:=f[i];
  writeln(ans);
end.
```

---

## 作者：s_h_y (赞：0)

我也不知怎么回事用Trie树写一下就水过。。

type
 Trie=record

       got:longint;

next:array['a'..'z']of longint

```cpp
      end;
var
 n,i,Tot,Now,Tmp,Ans:longint;
 c:char;
 t:array[0..150005]of Trie;
begin
 readln(n);
 for i:=1 to n do
 begin
  Now:=0;
  Tmp:=0;
  while not eoln do
  begin
   inc(Tmp,t[Now].got);
   read(c);
   if t[Now].next[c]>0 then
    Now:=t[Now].next[c]
   else
    begin
     inc(Tot);
     t[Now].next[c]:=Tot;
     Now:=Tot
    end
  end;
  readln;
  inc(t[Now].got);
  inc(Tmp,t[Now].got);
  if Tmp>Ans then Ans:=Tmp
 end;
 write(Ans)
end.
```

---

## 作者：Black_Porridge (赞：0)

~~这是一篇奇奇怪怪的题解~~

最开始看到这道题把我吓了一跳,我以为要自己组单词~~语文太差了~~,然后仔细一看题,发现这不就是dp吗?

而且这个状态转移方程还挺好写的:   $f_i$=$max($$f_i,f_j+1$);

然后直接上代码:
```
#include <bits/stdc++.h>
using namespace std;
const int maxn=2010;
int n,ans,dp[maxn];
string s[maxn];
int main() 
{
    cin>>n;//输入
    for (int i=1;i<=n;i++) 
    {
        cin>>s[i];
        dp[i]=1;//初始化 
        for (int j=1;j<i;j++) 
       {
            if (s[i].find(s[j])==0) //查找s[i]里有没有与s[j]一样的子串
	    {
                dp[i]=max(dp[i],dp[j]+1);//转移
            }
        }
        ans=max(ans,dp[i]);//在循环中就把ans求出,不必再循坏
    }
    cout<<ans<<endl;
   完结
}


---

## 作者：ChoHakuNe (赞：0)

类似最长不下降子序列的一道dp

无非就是把判断大小换成判断前缀

**f[i]表示[1,i]中到第i个单词的最大前缀数量**

并不知道一些大佬为什么要用复杂的函数判断前缀，因为题目中说明不会有重复的单词，所以如果pos(a,b)=1，那么a就一定是b的前缀

然后就是十分老实的dp代码...

```cpp
pas
program loubcomtuter;
var a:array[0..2001] of string;
    f:array[0..2001] of integer;
    n,i,j,max:integer;
begin
 readln(n);
 for i:=1 to n do f[i]:=1;//初始化，没有前缀的情况下长度为1
 for i:=1 to n do
  begin
   readln(a[i]);
   for j:=1 to i-1 do//因为按照字典顺序，之后的单词里一定没有a[i]的前缀
    if (pos(a[j],a[i])=1) and (f[j]>=f[i]) then inc(f[i]);//状态转移方程
  end;
  for i:=1 to n do if f[i]>max then max:=f[i];//f[n]不一定是最优解，找前缀数量最多的
 write(max);
end.
```

---


# 数据结构

## 题目背景

**引言**

数据结构学的好，未来工作没烦恼。

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999\_10000&sec=1508946101936&di=0c08b703e466d2a3b2d20dd8008821fc&imgtype=0&src=http%3A%2F%2Fjoymepic.joyme.com%2Farticle%2Fuploads%2Fallimg%2F201511%2F1446516425349678.gif)


Edgration 是一个喜欢乱搞数据结构的蒟蒻（以下简称edt），有一天，他作死想去刁难一下dalao：

edt想求一种数据结构，使得可以实现区间加，求出某一区间大于k的元素的个数

dalao1：sb线段树

dalao2：sb分块

dalao3：sb平衡树

edt: 不行，那就加上取模，求区间取膜mod后大于MIN小于MAX的元素个数

dalao1：线段树&……￥#&……%……&\*&%￥

dalao2：sb分块 &%￥……%#￥#&……&\*

dalao3：\*&……%&￥LCT维护SBT水题 &……%&……%

edt：那不仅取模，每个数乘上数组下标再取模

dalao：￥%￥￥&\*（#￥% 叽里呱啦叽里呱啦

edt：不行，在把取模的值丢到一棵树上，维护一棵仙人掌乘积方差的最小极差

dalao：替罪羊树上用sb块状链表维护Toptree上的最小费用最大流和可持久化仙人掌，算出来在基尔霍夫矩阵中反演后跑一遍fft维护的插头DP就好了，给我三分钟轻松水过。。

edt：mmp


## 题目描述

蒟蒻Edt把这个问题交给了你 ———— 一个精通数据结构的大犇，由于是第一题，这个题没那么难。。


edt 现在对于题目进行了如下的简化：


最开始的数组每个元素都是0


给出$n$，$opt$，$mod$，$min$，$max$，$mod$在int范围内


操作$A$，$Q$


$A$: $L$,$R$,$X$ 表示把$[l,R]$这个区间加上$X$

**（数组的从L到R的每个元素都加上X）**


$Q$: $L$,$R$ 表示询问$[L,R]$这个区间中元素T满足  $min<=(T*i$%$ mod)<=max$  的 T这样的数的个数（i是数组下标）

**（元素的值\*数组下标%mod在min到max范围内）**


由于 edt 请来了一位非三次元的仓鼠，他帮你用延后了部分问题，将这些询问打入了混乱时空，你的询问操作不会超过1000次，不幸的是，对于延后的询问操作可能有很多次（小于1e7次），但是保证这些延后的询问操作之后不会再次有修改操作

（就是在最后会有很多次询问，但不会进行修改）


## 说明/提示

## 样例说明

给出样例1的解释：

样例1中，$a$数组修改为$5$，$5$，$5$

每个$a[i]*i$%$4$ 的值为$1$,$2$,$3$

对于Final的询问

询问$[1$，$3]$中大于等于0小于等于2的个数为2个

剩下的询问类似

## 题目说明

**注意**：

### 1.关于负数取模问题，请以 c++ 的向0取整为标准，即如：

[ $ -7 $%$ 3 = -1 $ ]  [ $ 7 $%$ 3 = 1 $ ]

### 2.一共会有50个测试点，每个点分值为2分。

因为测试点数较多，请oier们自觉地不要故意多次提交来卡评测机，出题人 edt 在这里表示由衷的感谢

## 数据范围

如果你不能作对所有点，请尝试获得部分分，所有数据都是随机生成

![](https://cdn.luogu.com.cn/upload/image_hosting/whf39g4d.png)

## 样例 #1

### 输入

```
3 2 4 0 2
A 1 3 5
Q 2 3 
5
1 3
2 3
1 1 
2 2 
3 3
```

### 输出

```
1
2
1
1
1
0
```

## 样例 #2

### 输入

```
17 25 4098 310 2622
A 10 16 657212040
A 4 15 229489140
A 1 2 -433239891
A 3 12 532385784
A 10 17 56266644
A 8 10 10038874
A 6 9 13084764
A 4 5 -9206340
Q 2 8
A 2 4 -43223955
A 6 9 31478706
A 2 4 189818310
A 2 8 179421180
A 2 8 40354938
Q 8 14
A 3 6 57229575
A 6 13 132795740
A 2 17 14558022
A 14 15 -552674185
A 5 11 -1104138
Q 2 12
Q 1 14
A 3 9 524902182
A 8 12 114291440
A 3 7 107531442
1
11 12
```

### 输出

```
3
6
7
8
2
```

## 样例 #3

### 输入

```
20 3 4317 1020 2232
A 8 15 -434078222
A 1 2 54988154
A 13 19 81757858
15
7 11
3 5
3 9
6 9
9 13
6 19
1 20
3 5
3 10
1 7
2 14
6 10
2 3
2 3
10 12
```

### 输出

```
0
0
0
0
0
2
2
0
0
0
0
0
0
0
0
```

# 题解

## 作者：Edgration (赞：34)

还是本题的出题人我来发一个题解吧。。

这个题作为考试的第一题，~~是个心态题。~~

所谓的树状数组和线段树都是不存在的。

实际上只需暴力轻松解决。

首先暴力有66~70分。

对于Final操作

然后，类似前缀和，记录下来这个位置之前有几个满足条件的数的个数 ，这样有88~90分。

因为修改多，查询少，如果可以优化修改操作就可以AC了，显然上个差分

O(1)修改，差分维护数组，区间加的时候 a[L]+=x,a[R]-=x

总复杂度O(n\*1000) （1000次修改），拿到100分


程序我就不发了，就是题目下面的标程




---

## 作者：我太强了 (赞：18)

题目描述超简洁，可以很快看到重点“...求一种数据结构...实现区间加...区间取模...元素个数...”
线段tree！！！tree状数组！！！

点开标签，居然是用差分qwq

所以把思考方向转移到差分这个方向，维护差分数组$delta[i]$，再看这道题。

对于操作$A$给出的$l$,$r$,差分数组中只需要$delta[l]+=x$,$delta[r+1]-=x$就好了！！
因为差分数组是记录两个相邻元素的差值,改变一个区间的值，不会改变区间内部相邻元素的差值，只在区间两个端点处才会发生变化qwq

操作$Q$需要使用到区间内的元素值，~~这和我差分数组有什么关系吗~~，怎么用差分数组得到原始值呢?很简单，既然差分数组是记录差值，把$delta[1]$到$delta[i]$累加起来，就是第$i$个元素的值了。

最后的查询操作，$final$值可能会很大，每次都硬搞，效率肯定不会优秀了。何不用离线做法预处理一下？

这里用了前缀和的思想，开一个新数组$anss[i]$(本来想用$ans$,但是用过了qwq），存储$1$~$i$这个区间满足条件的元素个数。第$i$个元素满足条件，$anss[i]=anss[i-1]+1$,否则$anss[i]=anss[i-1]$。在查询$[l,r]$区间时，直接输出$anss[r]-anss[l-1]$的值。

好了，下面就是代码了。~~自认为码风很好~~
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll delta[80005],anss[80005];
ll n,opt,mod,minn,maxx,ans,now,final;
void ask(ll l,ll r) 
{ 
	now=ans=0;
	for(ll i=1;i<=r;i++) 
	{ 
		now+=delta[i];
		if(i>=l&&(now*i)%mod>=minn&&(now*i)%mod<=maxx) ans++;
	} 
	printf("%lld\n",ans);
} 
int main() 
{ 
	cin>>n>>opt>>mod>>minn>>maxx; 
	for(int i=1;i<=opt;i++) 
	{ 
		char c;
		cin>>c;
		if(c=='A') 
		{ 
			ll l,r,x;
			scanf("%lld%lld%lld",&l,&r,&x);
			delta[l]+=x; delta[r+1]-=x;
		} 
		else if(c=='Q') 
		{ 
			ll l,r; ans=0;
			scanf("%lld%lld",&l,&r);
			ask(l,r);
		} 
	} 
	scanf("%lld",&final);
	now=0;
	for(ll i=1;i<=n;i++) 
	{ 
		now+=delta[i];
		anss[i]=((now*i)%mod<=maxx&&(now*i)%mod>=minn)?1:0;
		anss[i]+=anss[i-1];
	} 
	while(final--) 
	{ 
		ll l,r;
		scanf("%lld%lld",&l,&r);
		printf("%lld\n",anss[r]-anss[l-1]);
	} 
	return 0;
} 
```



---

## 作者：Taduro (赞：10)

越做此题越觉得自己数据结构学傻了，怒写七十行树状数组+线段树跑了4000+ms。

思路：Q用的是树状数组+差分，A用的是树状数组求前缀和和暴力判断。

final用的是线段树（我怎么没想起前缀和！！！）

```
#include<cstdio>
#include<iostream>
#define ll long long
#define re register
using namespace std;
ll n,fin,minn,maxn,p,sum[500001];
ll c[100002],t;
inline ll lowbit(ll x){ return x&(-x);}
inline void add(ll x,ll k){		//树状数组单点修改
    while (x<=n){
        c[x]+=k;
        x+=lowbit(x);
    }
}
inline ll get_sum(ll x){		//求和
    ll ret=0;
    while (x){
        ret+=c[x];
        x-=lowbit(x);
    }
    return ret;
}
inline void pushup(ll rt){
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
void build(ll rt,ll l,ll r){	//建树
    if (l==r){
        ll u=get_sum(l)%p;
        if ((u*l)%p>=minn&&(u*l)%p<=maxn) sum[rt]++;
        return;
    }
    ll m=(l+r)>>1;
    build(rt<<1,l,m);
    build(rt<<1|1,m+1,r);
    pushup(rt);
}
ll query(ll rt,ll l,ll r,ll x,ll y){	//查询
    if (l>y||x>r) return 0;
    if (x<=l&&r<=y){
        return sum[rt];
    }
    ll m=(l+r)>>1,ret=0;
    if (m>=x) ret+=query(rt<<1,l,m,x,y);
    if (m<y) ret+=query(rt<<1|1,m+1,r,x,y);
    return ret;
}
int main(){
    char z;
    ll x,y,l,r;
    scanf("%lld%lld%lld%lld%lld",&n,&t,&p,&minn,&maxn);
    while (t--){
        scanf("%s",&z);
        if (z=='Q'){
            scanf("%lld%lld",&x,&y);
            ll ret=0,u;
            for (re int i=x; i<=y; i++){
                u=get_sum(i)%p;
                if ((i*u)%p>=minn&&(i*u)%p<=maxn) ret++;
            }
            printf("%lld\n",ret);
        }
        else{
            scanf("%lld%lld%lld",&l,&r,&x);
            add(l,x); add(r+1,-x);
        }
    }
    build(1,1,n);
    scanf("%lld",&fin);
    while (fin--){
        scanf("%lld%lld",&l,&r);
        printf("%lld\n",query(1,1,n,l,r));
    }
    return 0;
}
```

PS：大家不要学我

---

## 作者：孑思 (赞：10)

# 用差分

题意:给区间加上一个相等数列,最后单点查询 

设a[]是原数组,b[]是差分数组,

考虑一次在[L,R]内加w对a数组的影响

a[x]=a[x]+w(x∈[L,R])

考虑a数组的变化对b数组的影响 (b[i]=a[i]-a[i-1])

b[L]=b[L]+w;

b[R+1]=b[R+1]-w;

我们发现每次修改只会改变b数组2个位置的值

sum数组存储到现在为止有几个点符合条件~~（说白了就是前缀和）~~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[80010],b[80010],sum[80010],ans,now;
long long n,opt,mod,minn,maxx,l,r,x,f;
char ch[5];
int main(){
	scanf("%lld%lld%lld%lld%lld",&n,&opt,&mod,&minn,&maxx);
	for(long long j=1;j<=opt;j++){
		scanf("%s%lld%lld%",&ch,&l,&r);
		if(ch[0]=='A'){
			scanf("%lld",&x);
			b[l]+=x;
			b[r+1]-=x;
		}
		else{
			ans=0;now=0;
			for(long long i=1;i<=r;i++){
				now+=b[i];
				if(i>=l&&(now*i)%mod>=minn&&(now*i)%mod<=maxx)ans++;
			}
			printf("%lld\n",ans);
		}
	}
	scanf("%lld",&f);
	for(long long i=1;i<=n;i++){
		a[i]=a[i-1]+b[i];
		if((a[i]*i)%mod>=minn&&(a[i]*i)%mod<=maxx)sum[i]=sum[i-1]+1;
		else sum[i]=sum[i-1];
	}
	for(long long j=1;j<=f;j++){
		scanf("%lld%lld",&l,&r);
		printf("%lld\n",sum[r]-sum[l-1]);
	}
	return 0;
}
```

---

## 作者：清远学会 (赞：4)

**一道~~数据结构的~~好题**

好吧，此题并不是数据结构，因为我掌握的再次题面前都GG了-_-~；

那咋做呢？

仔细审审题目，发现来自**非三次元的仓鼠**不是没有用的（如果忽略的童鞋可以重新审题啦）

题目原文如下：
	由于 edt 请来了一位**非三次元的仓鼠**，他帮你用延后了部分问题，将这些询问打入了混乱时空，**你的询问操作不会超过1000次**，不幸的是，对于**延后的询问操作可能有很多次（小于1e7次）**，但是保证这些延后的询问操作**之后不会再次有修改操作**；
    
我们从新审题之后发现，询问操作不会大于1000次，暴力搞掉，那区间修改哩？

**我们可以用差分的思想来做**，可以做到O(1)修改，O(r-l)回答；

不会的童鞋可以学下——> [差分透彻学习处](https://www.luogu.org/blog/RPdreamer/ci-fen-and-shu-shang-ci-fen)

好，假设我们学会了差分，对于没有延后的问题，我们可以酱：

```cpp
inline int Ask(int l,int r) {
	int res = 0;b[0] = 0;
	for(int i = 1;i <= r;i ++) b[i] = b[i - 1] + a[i];
	for(int i = l;i <= r;i ++) b[i] = (b[i] % mod * (long long)i) % mod;
	for(int i = l;i <= r;i ++) 
		if(b[i] >= Min && b[i] <= Max)
			res ++;
	return res;
}
//主函数
for(int i = 1;i <= m;i ++) {
	char s[5]; scanf("%s",s + 1);
	int l = read(),r = read();
	if(s[1] == 'A') {
		int c = read();
		a[l] += c; a[r + 1] -= c;
	}
	else printf("%d\n",Ask(l,r));
}
```
最后，直接O(n)求前缀和，最后O(1)回答每个问题，简单解决啦

放上撒花代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 100500
using namespace std;

inline int read() {
	int x = 0,f = 1; char s = getchar();
	while(s < '0' || s > '9') {if(s == '-') f = -1; s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	return x * f;
}

int n,m;
int mod,Min,Max;
long long a[N],b[N];
int Final;

inline int Ask(int l,int r) {
	int res = 0;b[0] = 0;
	for(int i = 1;i <= r;i ++) b[i] = b[i - 1] + a[i];
	for(int i = l;i <= r;i ++) b[i] = (b[i] % mod * (long long)i) % mod;
	for(int i = l;i <= r;i ++) 
		if(b[i] >= Min && b[i] <= Max)
			res ++;
	return res;
}

int main() {
	n = read(),m = read();
	mod = read(),Min = read(),Max = read();
	for(int i = 1;i <= m;i ++) {
		char s[5]; scanf("%s",s + 1);
		int l = read(),r = read();
		if(s[1] == 'A') {
			int c = read();
			a[l] += c; a[r + 1] -= c;
		}
		else printf("%d\n",Ask(l,r));
	}
	for(int i = 1;i <= n;i ++) b[i] = b[i - 1] + a[i];
	for(int i = 1;i <= n;i ++) b[i] = (b[i] % mod * (long long)i) % mod;
	for(int i = 1;i <= n;i ++) 
		if(b[i] >= Min && b[i] <= Max)
			b[i] = 1;
		else b[i] = 0;//对符合条件的赋1，其余赋0；
	for(int i = 1;i <= n;i ++) b[i] += b[i - 1];
    //为保证O(1)回答，求前缀和来解决
	Final = read();
	for(int i = 1;i <= Final;i ++) {
		int l = read(),r = read();
		printf("%d\n",b[r] - b[l - 1]);
	}
	return 0;//拜拜程序 ✿✿ヽ(°▽°)ノ✿
}
```

---

## 作者：henry_y (赞：4)

[$my\ blogs$](https://www.cnblogs.com/henry-1202/p/10152720.html)

以为这题虽然是数据随机也不至于那么水吧...

于是秉着先打部分分和暴力的原则先写了暴力和min,max为-inf和inf的特殊点，对于暴力高了个小优化，延后的操作直接前缀和答案就好...

然后感觉数据随机的话能过$n<=5000$

交了发现跑的飞快，有了一点奇奇怪怪的想法，直接交暴力试试？

然后就过了。7000+ms...

效率是$O(opt*n+final)$的，因为数据随机所以其实也不用卡就能过去了...

我以为他的随机至少有部分构造数据来着...

然后看了官方题解居然也只是对暴力操作差分优化了一下...这个的效率也不对的其实...如果数据出到上界是过不去的...

（当时有想到这个但是算了效率是不对的于是cut掉了这个想法。还以为这题正解多高明233333）

```
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define inf 0x3f3f3f3f
#define N 200010
int n, opt, mod, Min, Max, fin;
ll a[N], sum[N];

namespace pts_1 {
	void solve() {
		int l, r, x;
		for(int i = 1; i <= opt; i ++) {
			char ch[10];
			scanf("%s%d%d", ch, &l, &r);
			if(ch[0] == 'A') {scanf("%d", &x); continue;} 
			printf("%d\n", r - l + 1);
		}
		scanf("%d", &fin);
		for(int i = 1; i <= fin; i ++) {
			scanf("%d%d", &l, &r);
			printf("%d\n", r - l + 1);
		}
	}
}

namespace pts_2 {
	void solve() {
		int l, r, x;
		for(int i = 1; i <= opt; i ++) {
			char ch[10];
			scanf("%s%d%d", ch, &l, &r);
			if(ch[0] == 'A') {
				scanf("%d", &x);
				for(int i = l; i <= r; i ++) a[i] += x;
			} else {
				ll ans = 0;
				for(int i = l; i <= r; i ++) {
					ans += a[i] * i % mod >= Min && a[i] * i % mod <= Max;
				}
				printf("%lld\n", ans);
			} 
		}
		for(int i = 1; i <= n; i ++) {
			sum[i] = sum[i - 1] + (a[i] * i % mod >= Min && a[i] * i % mod <= Max);
		}
		scanf("%d", &fin);
		while(fin--) {
			scanf("%d%d", &l, &r);
			printf("%lld\n", sum[r] - sum[l - 1]);
		}
	}
}

int main() {
	scanf("%d%d%d%d%d", &n, &opt, &mod, &Min, &Max);
	if(Min <= -inf && Max >= inf) {pts_1::solve(); return 0;}
	else {
		if(n <= 5000) {pts_2::solve(); return 0;}
		pts_2::solve(); return 0;
	}
}
```

---

## 作者：新时代的黑客 (赞：3)

似乎没有人用线段树写题解......

我的思路是用线段树处理前面的，最后那个单次询问用前缀和。而线段树所判的数则为叶子节点，那么它的数组位置与值可以直接用结构体写。又因为深搜序，所以访问的叶子节点与原数组无异。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M=200000+5;
struct node{
	ll val,pos;//数值 & 位置
}c[M*4];
ll n,k,opt,mod,minn,maxn,cnt,lazy[M*4],ans,sum[M*4];
void build(int h,int s,int t){
	if(s==t){//如果为叶子节点
		c[h].pos=++cnt;
		return;
	}
	ll mid=s+(t-s)/2;
	build(h<<1,s,mid);
	build(h<<1|1,mid+1,t);
}
int read(){
	ll re=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-')
		{
			f=-f;
		}
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		re=re*10+ch-'0';
		ch=getchar(); 
	}
	return re*f;
}
void Push_down(ll h,ll s,ll t,ll vall){
	lazy[h]+=vall;
	c[h].val+=(t-s+1)*vall;
}
void gx(ll h,ll s,ll t,ll L,ll R,ll vall){
	ll mid=s+(t-s)/2;
	if(L<=s && t<=R){
		c[h].val+=(t-s+1)*vall;
        lazy[h]+=vall;
	}
	else{
		if(lazy[h]){
			Push_down(h<<1,s,mid,lazy[h]);
			Push_down(h<<1|1,mid+1,t,lazy[h]);
			lazy[h]=0;
		}
		if(L<=mid)
			gx(h<<1,s,mid,L,R,vall);
       	if(mid<R)
			gx(h<<1|1,mid+1,t,L,R,vall);
		c[h].val=c[h<<1].val+c[h<<1|1].val;
	}
}
void cx(ll h,ll s,ll t,ll L,ll R){
	ll mid=s+(t-s)/2;
	if(s==t){
		if(c[h].pos*c[h].val%mod>=minn && c[h].pos*c[h].val%mod<=maxn)
			ans++;
	}
	else{
		if(lazy[h]){
            Push_down(h<<1,s,mid,lazy[h]);
        	Push_down(h<<1|1,mid+1,t,lazy[h]);
    	    lazy[h]=0;
	    }
        if(L<=mid)
			cx(h<<1,s,mid,L,R);
	    if(mid<R)
			cx(h<<1|1,mid+1,t,L,R);
	}
}
void qzh(int h,int s,int t){//求叶子节点满足的前缀和
	ll mid=s+(t-s)/2;
	if(s==t){
		cnt++;
		if(c[h].pos*c[h].val%mod>=minn && c[h].pos*c[h].val%mod<=maxn)
			sum[cnt]=sum[cnt-1]+1;
		else sum[cnt]=sum[cnt-1];
		return;
	}
	else{
		if(lazy[h]){
            Push_down(h<<1,s,mid,lazy[h]);
        	Push_down(h<<1|1,mid+1,t,lazy[h]);
    	    lazy[h]=0;
	    }
		qzh(h<<1,s,mid);
		qzh(h<<1|1,mid+1,t);
	}
}
int main(){
	n=read();opt=read();mod=read();minn=read();maxn=read();
	build(1,1,n);
	for(ll i=1;i<=opt;i++){
		char f;
		ll x,y,z;
		cin>>f;
		cin>>x>>y;
		if(f=='A'){
			cin>>z;
			gx(1,1,n,x,y,z);
		}
		if(f=='Q'){
			ans=0;
			cx(1,1,n,x,y);
			cout<<ans<<endl;
		}
	}
	k=read();
	cnt=0;
	qzh(1,1,n);
	for(ll i=1;i<=k;i++){
		ll u,v;
		u=read();v=read();
		cout<<sum[v]-sum[u-1]<<endl;//完美解决
	}
	return 0;
}
```

---

## 作者：假假 (赞：3)

 Solution（差分）

1. 首先因为前半部分以区间修改为主，所以我们采用差分的方法使该操作变为O（1），即对于每个L,R,X，令num[L]+=X,num[R+1]-=X；

2. 由于前半部分寻问非常少（小于1000次）每次都计算一遍当前数组的各个数字，O（n）处理就好；

3. 对于final部分的寻问，因为没有修改，我们考虑离线处理，先进行预处理，用一个数组ok[i]记录i即其以前的元素符合条件的个数，再对于每一个询问L，R，输出ok[R]-ok[L-1]的值即可（因为ok[R]统计的是R及其以前的符合条件的元素个数，减去不在区间[L,R]内的部分，即ok[L-1]就是区间内符合要求的元素个数）；

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

long long num[100100],n,m,i,j,k,minn,maxn,mod,l,r,x,t,ok[100100];
char c;

inline long long rd(){
	long long x=0;
	bool f=true;
	char c;
	c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=false;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return f?x:-x;
} 

inline char getc()
{
	char c=getchar();
	while(c<'A'||c>'Z')c=getchar();
	return c;
}

void modify(){
	l=rd();
	r=rd();
	x=rd();
	num[l]+=x;
	num[r+1]-=x;
}

void count(){
	l=rd();
	r=rd();
	long long ans=0;
        x=0;
	for(i=1;i<=r;++i){
		x+=num[i];
		if(i>=l&&((x*i)%mod>=minn)&&((x*i)%mod<=maxn)) ++ans;
	}
	printf("%lld\n",ans);
}

int main(){
	memset(ok,0,sizeof(ok));
	memset(num,0,sizeof(num));
	n=rd();
	t=rd();
	mod=rd();
	minn=rd();
	maxn=rd();
	for(k=1;k<=t;++k){
		c=getc();
		if(c=='A') modify();
		else count(); 
	}
	t=rd();
	x=0;
	for(i=1;i<=n;++i){
		x+=num[i];
		ok[i]=ok[i-1];
		if(((x*i)%mod>=minn)&&((x*i)%mod<=maxn))++ok[i];
	}
	for(i=1;i<=t;++i){
		l=rd();
		r=rd();
		printf("%lld\n",ok[r]-ok[l-1]);
	}
	return 0;
}
```
 差分的基础可以参考以前的随笔：http://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html

---


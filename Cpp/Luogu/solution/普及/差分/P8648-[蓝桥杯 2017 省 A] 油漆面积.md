# [蓝桥杯 2017 省 A] 油漆面积

## 题目描述

X 星球的一批考古机器人正在一片废墟上考古。

该区域的地面坚硬如石、平整如镜。

管理人员为方便，建立了标准的直角坐标系。

每个机器人都各有特长、身怀绝技。它们感兴趣的内容也不相同。

经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。

矩形的表示格式为 $(x_1,y_1,x_2,y_2)$，代表矩形的两个对角点坐标。

为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。

小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。

其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。

注意，各个矩形间可能重叠。

本题的输入为若干矩形，要求输出其覆盖的总面积。


## 说明/提示

蓝桥杯 2022 省赛 A 组 J 题。

## 样例 #1

### 输入

```
3
1 5 10 10
3 1 20 20
2 7 15 17
```

### 输出

```
340```

## 样例 #2

### 输入

```
3
5 2 10 6
2 7 12 10
8 1 15 15```

### 输出

```
128```

# 题解

## 作者：rui_er (赞：15)

怎么题解区全是扫描线，还有个 $O(n^3)$ 暴力老哥。

为防止误导新人，给个理论上稳过的 $O(n^2)$ 解法。

二维前缀和可以处理若干次单点加，最后若干次矩形查的问题。

将其差分，即可处理若干次矩形加，最后若干次单点查的问题。

于是我们使用差分将所有矩形加上，然后做一遍二维前缀和，即可求出每个格子被几个矩形覆盖。统计有多少格子被至少一个矩形覆盖，输出即可。

注意本题卡空间，但注意到差分阶段每个格子只会被每个矩形 $\pm 1$，每个格子的值不超过 $10^4$，最终求前缀和后每个格子只会被每个矩形覆盖至多一次，值也不超过 $10^4$，因此开 short 即可。

时间复杂度 $O(n^2)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const int N = 1e4+5;

int n, ans;
short a[N][N];

int main() {
    scanf("%d", &n);
    rep(i, 1, n) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        ++a[x1][y1];
        --a[x1][y2];
        --a[x2][y1];
        ++a[x2][y2];
    }
    rep(i, 0, 10000) {
        rep(j, 0, 10000) {
            a[i][j] = int(i > 0 ? a[i-1][j] : 0) + (j > 0 ? a[i][j-1] : 0) - (i > 0 && j > 0 ? a[i-1][j-1] : 0) + a[i][j];
            if(a[i][j]) ++ans;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：___w (赞：12)

### [P8648 油漆面积](https://www.luogu.com.cn/problem/P8648)

### upd：被 hack 了，应将数组开大点，感谢 @rui_er 的指出。

[扫描线](https://www.luogu.com.cn/problem/P5490)的板子题，不会的可以先写一下这道题。

#### 题意简述
给定 $n$ 个矩形，求这些矩形所覆盖的面积之和。

#### 扫描线
扫描线顾名思义就是有一条线自底向上扫动（其实怎么扫都无所谓），通常用来求矩形所覆盖的面积或周长。

![1](https://oi-wiki.org/geometry/images/scanning.svg)

上面这张图很好的演示了扫描线的全过程，我们可以把整个矩形分成若干个小矩形，这些小矩形的高就是扫描线扫过的距离，而小矩形的长就可以用线段树来维护。

具体地，线段树的节点需要维护两个值，分别是 $cnt$ 和 $len$，分别表示当前区间被覆盖的次数，区间内覆盖的长度和。

- 若 $cnt>0$，不管覆盖多少次，$len$ 一定就是当前节点的区间长度。

- 若 $cnt=0$，$len$ 就为左右子节点的 $len$ 的和。

```cpp
void update(int p) {
	if (t[p].cnt) t[p].len = a[t[p].r+1]-a[t[p].l];
	else t[p].len = t[p<<1].len+t[p<<1|1].len;
}
```
有了这段代码，剩下的就是线段树的板子了，~~于是就可以愉快的切过这道题了~~。
#### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e4+5;
int n, tot, a[N<<2];
ll ans;//十年oi一场空，不开long long见祖宗
struct edge {
	int y, x1, x2, k;
} e[N<<1];
struct SegmentTree {
	int l, r;
	ll len, cnt;
} t[N<<3];
void build(int p, int l, int r) {
	t[p].l = l, t[p].r = r;
	if (l == r) return;
	int mid = (l+r)>>1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
}
void update(int p) {//向上传递
	if (t[p].cnt) t[p].len = a[t[p].r+1]-a[t[p].l];
	else t[p].len = t[p<<1].len+t[p<<1|1].len;
}
void change(int p, int l, int r, int x) {
	if (l <= t[p].l && t[p].r <= r) {
		t[p].cnt += x;
		update(p);
		return;
	}
	int mid = (t[p].l+t[p].r)>>1;
	if (l <= mid) change(p<<1, l, r, x);
	if (mid < r) change(p<<1|1, l, r, x);
	update(p);
}
bool cmp(edge x, edge y) {return x.y < y.y;}
int query(int x) {return lower_bound(a+1, a+tot+1, x)-a;}//查询
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		e[(i<<1)-1] = (edge){y1, x1, x2, 1};
		e[i<<1] = (edge){y2, x1, x2, -1};
		a[(i<<1)-1] = x1, a[i<<1] = x2;
	}
	n <<= 1;
	sort(e+1, e+n+1, cmp);
	sort(a+1, a+n+1);
	tot = unique(a+1, a+n+1)-a-1;//离散化
	build(1, 1, tot);
	for (int i = 1; i <= n; ++i) {
		change(1, query(e[i].x1), query(e[i].x2)-1, e[i].k);
		ans += t[1].len*(e[i+1].y-e[i].y);
	}
	cout << ans;
	return 0;
}
```
[P8734](https://www.luogu.com.cn/problem/P8734)，[P1856](https://www.luogu.com.cn/problem/P1856)，[P1502](https://www.luogu.com.cn/problem/P1502)，[P5490](https://www.luogu.com.cn/problem/P5490) 这些都是扫描线的题，有兴趣可以做一做。

---

## 作者：AzureHair (赞：3)

简明题干：有 $n$ 个矩形，求矩形覆盖总面积。  
这不一看就是扫描线的版子（甚至连改都不用改。
![](https://oi-wiki.org/geometry/images/scanning.svg)       
大体思路：      
扫描到矩形的下边就记录正在扫描的矩形边长。      
扫描到矩形的上边就计算面积记录到结果中，细节在代码注释中。       
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,x,y,xx,yy;
const int maxn=100010;
struct scan//记录矩形上下边的位置
{
	int l,r,h,tag;
}lines[maxn<<1];
bool cmp(scan s,scan ss)//根据线的高度排序
{
	if(s.h!=ss.h)
	{
		return s.h<ss.h;
	}
	return s.tag>ss.tag;
}
int ans;
int xcnt,xaxis[maxn<<1];
map<int,int> mp;
//以下为线段树
struct point
{
	int l,r,minn,minlen,add;
}tree[maxn<<3];
inline void pushup(int x)
{
	int lson=x<<1,rson=lson|1;
	tree[x].minn=min(tree[lson].minn,tree[rson].minn);
	tree[x].minlen=0;
	if(tree[x].minn==tree[lson].minn)tree[x].minlen+=tree[lson].minlen;
	if(tree[x].minn==tree[rson].minn)tree[x].minlen+=tree[rson].minlen;
}
inline void pushadd(int x,int k)
{
	tree[x].add+=k;
	tree[x].minn+=k;
}
inline void pushdown(int x)
{
	if(tree[x].l==tree[x].r)return;
	int lson=x<<1,rson=lson|1;
	if(tree[x].add!=0)
	{
		pushadd(lson,tree[x].add);
		pushadd(rson,tree[x].add);
		tree[x].add=0;
	}
}
void build(int x,int l,int r)
{
	tree[x]=(point){l,r,0,0,0};
	if(l==r)
	{
		tree[x].minlen=xaxis[tree[x].r+1]-xaxis[tree[x].l];
		return;
	}
	int mid=(tree[x].l+tree[x].r)>>1,lson=x<<1,rson=lson|1;
	build(lson,l,mid);build(rson,mid+1,r);
	pushup(x);
}
void modify(int x,int l,int r,int k)
{
	pushdown(x);
	if(l<=tree[x].l&&r>=tree[x].r){pushadd(x,k);return;}
	int mid=(tree[x].l+tree[x].r)>>1,lson=x<<1,rson=lson|1;
	if(l<=mid)modify(lson,l,r,k);
	if(r>mid)modify(rson,l,r,k);
	pushup(x);
}
inline int getlen()
{
	if(tree[1].minn>0)return xaxis[tree[1].r+1]-xaxis[tree[1].l];
	else return xaxis[tree[1].r+1]-xaxis[tree[1].l]-tree[1].minlen;
}
//以上为线段树
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y>>xx>>yy;
		lines[2*i-1]=(scan){x,xx,y,1};//储存线的信息
		lines[2*i]=(scan){x,xx,yy,-1};
		xaxis[2*i-1]=x;xaxis[2*i]=xx;
	}
	sort(xaxis+1,xaxis+2*n+1);
	xcnt=unique(xaxis+1,xaxis+2*n+1)-xaxis-1;
	for(int i=1;i<=xcnt;i++)mp[xaxis[i]]=i;//离散化
	sort(lines+1,lines+2*n+1,cmp);
	build(1,1,xcnt-1);
	for(int i=1;i<=2*n;i++)
	{
		ans+=getlen()*(lines[i].h-lines[i-1].h);
		modify(1,mp[lines[i].l],mp[lines[i].r]-1,lines[i].tag);//记录答案
	}
	printf("%lld\n",ans);
	return 0;
}
```
双倍经验的扫描线板子见P5490。

---

## 作者：__DDDDDD__ (赞：2)

# 题目分析

题意：给定 $n$ 个矩形，求矩形面积并。

扫描线板子题，~~数据范围甚至小于 [P5490](https://www.luogu.com.cn/problem/P5490)......？~~

扫描线的基本思想就是以 $x$ 轴每个点为数组下标，以 $y$ 轴从小到大逐个扫描，同时用一个线段树维护数组 $cnt$、$dat$，分别表示每个点被覆盖的次数与覆盖的总长度。

维护 $dat$ 的方式：

1. 如果线段树上该点已被覆盖（即 $cnt \geq 1$），则该点 $dat$ 值等于 $r-l+1$；

1. 否则 $dat$ 值等于左右子节点 $dat$ 值之和。

每次统计线段树顶端的 $dat$ 值，将该值乘以当次扫描宽度累加到答案即可。

具体分析与细节详见代码部分：


# 代码+注释

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100010
typedef long long ll;
ll x1,x2,h1,h2,dis[MAXN*2],val[MAXN*2],ans;
int n,tot,maxn=(1<<30)-1;
/*-------------------------------------初始化------------------------------------*/
struct scanline{
	ll x,lh,rh;
	int d;
}a[MAXN];
bool cmp(scanline a,scanline b){							// 扫描线的比较函数 
	if(a.x!=b.x)return a.x<b.x;								// 优先x轴从左到右 
	return a.d>b.d;											// 处理d=1紧贴d=-1的情况 
}
/*-----------------------------------线段树部分-----------------------------------*/ 
struct SegmentTree{
	int l,r,dat,cnt;
}t[MAXN*4];
inline void update(int p){									// 从下往上更新节点 
	if(t[p].l==maxn&&t[p].r==maxn)return; 
	if(t[p].cnt)t[p].dat=val[t[p].r+1]-val[t[p].l];			// 被覆盖时等于左右节点之差 
	else t[p].dat=t[p*2].dat+t[p*2+1].dat;					// 未被覆盖则等于子节点覆盖长度之和 
}
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	t[p].dat=0;t[p].cnt=0;
	if(l==r)return;
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void add(int p,int l,int r,int d){
	if(l<=t[p].l&&r>=t[p].r){
		t[p].cnt+=d;
		update(p);
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(l<=mid)add(p*2,l,r,d);
	if(mid<r)add(p*2+1,l,r,d);
	update(p);
}
/*-------------------------------------主函数---------------------------------------*/ 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld%lld",&x1,&h1,&x2,&h2);
		a[i*2-1].lh=a[i*2].lh=h1;
		a[i*2-1].rh=a[i*2].rh=h2;
		a[i*2-1].x=x1;a[i*2].x=x2;
		a[i*2-1].d=1;a[i*2].d=-1;
		dis[++tot]=h1;dis[++tot]=h2;						// dis数组用于离散化 
	}
	sort(dis+1,dis+n*2+1);
    int cnt=unique(dis+1,dis+n*2+1)-dis-1;
	for(int i=1;i<=n*2;i++){								// 离散化部分 
		int pos1=lower_bound(dis+1,dis+cnt+1,a[i].lh)-dis;	
		int pos2=lower_bound(dis+1,dis+cnt+1,a[i].rh)-dis;
		val[pos1]=a[i].lh;val[pos2]=a[i].rh;
		a[i].lh=pos1;maxn=max(maxn,pos1);a[i].rh=pos2;		// 用离散化后的值更新扫描线
	}
	sort(a+1,a+n*2+1,cmp);									// 对扫描线从左到右排序 
	build(1,1,n*2);
	for(int i=1;i<=n*2;i++){
		add(1,a[i].lh,a[i].rh-1,a[i].d);
		ans+=(a[i+1].x-a[i].x)*(t[1].dat);
	}
	printf("%lld",ans);
	return 0;
} 
```


---


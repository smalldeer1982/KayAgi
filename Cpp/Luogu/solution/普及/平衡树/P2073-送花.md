# 送花

## 题目背景

小明准备给小红送一束花，以表达他对小红的爱意。他在花店看中了一些花，准备用它们包成花束。


## 题目描述

这些花都很漂亮，每朵花有一个美丽值 $W$，价格为 $C$。

小明一开始有一个空的花束，他不断地向里面添加花。他有以下几种操作：

- $1\ W\ C$：添加一朵美丽值为 $W$，价格为 $C$ 的花。  
**如果此时花束中已经有了相等价格的花，那么这朵花不能加入花束。**
- $2$：删除当前花束里最贵的一朵花。
- $3$：删除当前花束里最便宜的一朵花。
- $-1$：完成添加与删除，开始包装花束。

**当花束为空时，忽略操作 $2$ 和 $3$。**

请你写一个程序，计算出开始包装花束时，花束中所有花的美丽值的总和，以及小明需要为花束付出的总价格。

## 说明/提示

设操作数为 $m$。

- 对于 $20\%$ 数据，$m \le 100$，$1\le W,C\le 10^3$。
- 对于全部数据，$m \le 10^5$，$1\le W,C\le 10^6$。

## 样例 #1

### 输入

```
1 1 1
1 2 5
2
1 3 3
3
1 5 2
-1
```

### 输出

```
8 5```

# 题解

## 作者：kikuss (赞：37)

# Solution

### set极简AC,看题解那么多自己打的平衡树,其实STL挺好用的

现在碰到平衡树的题目一般都是vector或者是set水过去,

比如这道题....

题目要求不能重复,set啊,什么都不用判断,直接插入,方便

只是要注意的set的end函数和vector一样是开区间,而set的迭代器又只支持
$--$和$++$操作,所以在删除最大值的时候记得将迭代器$--$

- - -

# Code
```cpp
#include<bits/stdc++.h>
#define lol long long
#define il inline
#define rg register
#define Min(a,b) (a)<(b)?(a):(b)
#define Max(a,b) (a)>(b)?(a):(b)

using namespace std;

const int N=1e5+10;

void in(lol &ans)
{
    ans=0; lol f=1; char i=getchar();
    while(i<'0' || i>'9') {if(i=='-') f=-1; i=getchar();}
    while(i>='0' && i<='9') ans=(ans<<1)+(ans<<3)+i-'0', i=getchar();
    ans*=f;
}

struct node {
    lol x,v;
    bool operator < (const node & a) const {return v<a.v;}
};
set<node>v;

int main()
{
    lol op,x,y; node tmp;
    while(1) {
        in(op);
        if(op==1) {
            in(x),in(y);
            tmp = (node) {x,y};
            v.insert(tmp);
        }
        else if(op==2) {if(v.size()) v.erase(--v.end());}
        else if(op==3) {if(v.size()) v.erase(v.begin());}
        else {
            lol ans1=0,ans2=0;
            for(set<node>::iterator it=v.begin();it!=v.end();it++) ans1+=(*it).x,ans2+=(*it).v;
            printf("%lld %lld\n",ans1,ans2);
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：XG_Zepto (赞：28)

## 思路

为什么标签那么吓人，其实优先队列强行模拟题意的操作是可行的，时间比Splay慢，但是依然只有488ms。

我们考虑开两个队列，分别维护最大值和最小值，同时用v数组建立价格到美丽值的映射。添加的时候直接两个队列都加上就行，并且更新v数组。

删除的时候，我们更新美丽值总和以及总价，同时把这个价格到美丽值的映射变成0。在以上操作之前，首先把队列中已经由于另一种操作删除的点pop掉，检测方法就是看这个点的价格对应的美丽值是不是已经变成了0，即已经被删除。

## 代码

尽量写得简介并且没有压行。有疑问欢迎交流。

```
#include <bits/stdc++.h>
#define maxn 1000001
using namespace std;
int v[maxn];//建立价格到美丽值的映射
long long tob,top;
priority_queue<int>qin;
priority_queue<int,vector<int>,greater<int> >qax;
void Add(){
	int x,y;
    cin>>x>>y;
    if (v[y]) return;//发现相同价格就返回
    qin.push(y);
    qax.push(y);
    v[y]=x;
    tob+=x,top+=y;
}
void Delin(){
    while(!qin.empty()&&!v[qin.top()]) qin.pop();
    if (!qin.empty()){
        int te=qin.top();
        tob-=v[te];
        top-=te;
        v[te]=0;
        qin.pop();
    }
}
void Delax(){
    while(!qax.empty()&&!v[qax.top()]) qax.pop();
    if (!qax.empty()){
        int te=qax.top();
        tob-=v[te];
        top-=te;
        v[te]=0;
        qax.pop();
    }
}
int main(){
    ios::sync_with_stdio(false);
    int q;
    cin>>q;
    while(q!=-1){
        if (q==1) Add();
        if (q==2) Delin();
        if (q==3) Delax();
        cin>>q;
    }
    cout<<tob<<" "<<top;
    return 0;
}
```

---

## 作者：YoungNeal (赞：20)

## Solution
$\mathcal{fhq-Treap}$ 了解一下  
$\mathcal{fhq-Treap}$ 入门可以看我的这篇[博客](http://www.cnblogs.com/YoungNeal/p/8977328.html)  
讲一下这题怎么搞  
对于插入操作，假设权值为 $\mathcal{k}$。我们按照权值先 $\mathcal{split}$ 出小于等于 $\mathcal{k}$ 的一棵树 $\mathcal{x}$，再把 $\mathcal{x}$ $\mathcal{split}$ 出小于等于 $\mathcal{k-1}$ 的一棵树 $\mathcal{y}$。如果 $\mathcal{y}$ 这棵子树不为空，也就是说已经有了权值为 $\mathcal{k}$ 的节点，那么我们不插入即可。  
对于删除操作，我们可以按照子树大小 $\mathcal{split}$ 出我们要删除的值，然后不 $\mathcal{merge}$ 即可。  
最后 $\mathcal{dfs}$ 一遍求出答案即可。  
最慢的点 $\mathcal{30ms}$，比 $\mathcal{STL}$ 快了不知道多少。
## Code
```cpp
#include<cstdio>
#include<cstdlib>
#define N 100005
#define int long long

int tot,Root;
int ans1,ans2;
int beauty[N];
int val[N],sze[N];
int ch[N][2],prio[N];

void pushup(int o){
  sze[o]=sze[ch[o][0]]+sze[ch[o][1]]+1;
}

void split(int o,int k,int &x,int &y){
  if(!o) x=y=0;
  else{
    if(sze[ch[o][0]]>=k){
      y=o;
      split(ch[o][0],k,x,ch[o][0]);
      pushup(o);
    }
    else{
      x=o;
      split(ch[o][1],k-sze[ch[o][0]]-1,ch[o][1],y);
      pushup(o);
    }
  }
}

int merge(int x,int y){
  if(!x or !y) return x+y;
  if(prio[x]<prio[y]){
    ch[x][1]=merge(ch[x][1],y);
    pushup(x);
    return x;
  }
  else{
    ch[y][0]=merge(x,ch[y][0]);
    pushup(y);
    return y;
  }
}

void split2(int o,int k,int &x,int &y){
  if(!o) x=y=0;
  else{
    if(val[o]<=k){
      x=o;
      split2(ch[o][1],k,ch[o][1],y);
    } else{
      y=o;
      split2(ch[o][0],k,x,ch[o][0]);
    }
    pushup(o);
  }
}

int newnode(int a,int b){
  sze[++tot]=1;
  prio[tot]=rand();
  beauty[tot]=a;
  val[tot]=b;
  return tot;
}

void insert(int o,int a,int b){
  int x,y,z;
  split2(Root,b,x,y);
  split2(x,b-1,x,z);
  if(sze[z]!=0) 
    Root=merge(x,merge(z,y));
  else
    Root=merge(x,merge(newnode(a,b),y));
}

void delex(){
  int siz=sze[Root];
  int a;
  split(Root,siz-1,Root,a);
}

void delch(){
  int a;
  split(Root,1,a,Root);
}

void dfs(int now){
  //printf("now=%d\n",now);
  if(!now) return;
  ans1+=beauty[now];
  ans2+=val[now];
  dfs(ch[now][0]);
  dfs(ch[now][1]);
}

signed main(){
  int opt,a,b;
  while(scanf("%lld",&opt)){
    if(opt==-1) break;
    if(opt==1){
      scanf("%lld%lld",&a,&b);
      insert(Root,a,b);
    }
    if(opt==2)
      delex();
    if(opt==3)
      delch();
  }
  dfs(Root);
  printf("%lld %lld\n",ans1,ans2);
  return 0;
}
```

---

## 作者：夏色祭 (赞：13)

第一眼题面，想直接线段树搞就行了，维护六个东西:最大值，最小值，最大值的位置，最小值的位置，美丽值的总和和总价格。

看了标签:线段树，平衡树，转念一想还是写了 _Splay_ ，然后就调了1h。

貌似没人发 _Splay_ 诶，那我来补一发吧。

和模板差不多吧。

查找最大值和最小值：直接查找一个极大值或极小值的前驱或后继。

判断是否为空：一开始先插入一个极大值和一个极小值，如果查找的极大值或极小值的前驱或后继=另外一个极值，就说明为空。

注意：重复的话，总和都不用加了。

```
//by zykykyk
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#include<set>
#include<vector>
#include<queue>
#include<map>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
#define N 100010
#define inf 2147483647
using namespace std;
namespace fast_IO {
    inline char read() {
    	return getchar();
        static const int IN_LEN = 1000000;
        static char buf[IN_LEN], *s, *t;
        if (s == t) {
            t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
            if (s == t) return -1;
        }
        return *s++;
    }
    template<class T>
    inline void read(T &x) {
        static bool iosig;
        static char c;
        for (iosig = false, c = read(); !isdigit(c); c = read()) {
            if (c == '-') iosig = true;
            if (c == -1) return;
        }
        for (x = 0; isdigit(c); c = read())
            x = ((x + (x << 2)) << 1) + (c ^ '0');
        if (iosig) x = -x;
    }
    const int OUT_LEN = 10000000;
    char obuf[OUT_LEN], *ooh = obuf;
    inline void print(char c) {
        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;
        *ooh++ = c;
    }
    template<class T>
    inline void print(T x) {
        static int buf[30], cnt;
        if (x == 0) {
            print('0');
        }
        else {
            if (x < 0) print('-'), x = -x;
            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
            while (cnt) print((char)buf[cnt--]);
        }
    }
    inline void flush() {
        fwrite(obuf, 1, ooh - obuf, stdout);
    }
}
using namespace fast_IO;
struct tree{
	int fa,son[2];
	ll v,bv;
}t[N];
int root,tot,k;
ll sum1,sum2,x,y;
il vd rotate(int x){
	int y=t[x].fa,z=t[y].fa,k=t[y].son[0]==x;
	t[z].son[t[z].son[1]==y]=x,t[x].fa=z;
	t[y].son[k^1]=t[x].son[k],t[t[x].son[k]].fa=y;
	t[x].son[k]=y,t[y].fa=x;
}
il vd Splay(int x,int go){
	while (t[x].fa!=go){
		int y=t[x].fa,z=t[y].fa;
		if (z!=go) (t[z].son[0]==y)==(t[y].son[0]==x)?rotate(y):rotate(x);
		rotate(x);
	}
	if (!go) root=x;
}
il vd insert(ll x,ll y){
	int u=root,fa=0;
	while (u&&t[u].v!=x) fa=u,u=t[u].son[x>t[u].v];
	if (!u){
		u=++tot,sum1+=y,sum2+=x;
		if (fa) t[fa].son[x>t[fa].v]=u;
		t[u].fa=fa,t[u].v=x,t[u].bv=y;
		t[u].son[0]=t[u].son[1]=0;
	}
	Splay(u,0);
}
il vd Find(ll x){
	int u=root;
	if (!u) return;
	while (t[u].son[x>t[u].v]&&x!=t[u].v) u=t[u].son[x>t[u].v];
	Splay(u,0);
}
il int Next(ll x,int f){
	Find(x);
	int u=root;
	if ((x<t[u].v&&f)||(x>t[u].v&&!f)) return u;
	u=t[u].son[f];
	while (t[u].son[f^1]) u=t[u].son[f^1];
	return u;
}
il vd Delete(ll x){
	int last=Next(x,0),next=Next(x,1);
	Splay(last,0),Splay(next,last);
	t[next].son[0]=0;
}
int main(){
	freopen("data.in","r",stdin);
	freopen("m.out","w",stdout);
	insert(inf,0),insert(-inf,0);
	while (2333){
		read(k);
		if (k==-1) break;
		if (k==1){
			read(x),read(y);
			insert(y,x);
		}
		if (k==2){
			int x=Next(inf,0);
			if (t[x].v!=-inf){
				sum1-=t[x].bv,sum2-=t[x].v;
				Delete(t[x].v);
			}
		}
		if (k==3){
			int x=Next(-inf,1);
			if (t[x].v!=inf){
				sum1-=t[x].bv,sum2-=t[x].v;
				Delete(t[x].v);
			}
		}
	}
	print(sum1),print(' '),print(sum2);flush();
}
```

---

## 作者：丿王者之路 (赞：10)

这里蒟蒻来一发线段树的题解；

用线段树来做的话，可以称为较为模板的题吧，可以给我们这些蒟蒻练练手；

因为要输出w的总和，c的总和，我以 1—最大的钱为区间，而每次都可以看作是点查询；

又因为要修改最小值，最大值，所以维护sumw，sumc，minn，maxx就可以了；

参考代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls id<<1
#define rs id<<1|1
using namespace std;
const int maxn=1e6+10;
const int inf=0x7f7f7f7f;
int opt; 
bool vis[maxn];//用来判重； 
struct Tree
{
    int l,r;
    int sumw,sumc;
    int minn,maxx;
}tr[maxn<<2];
void build(int id,int ll,int rr)
{
    tr[id].l=ll,tr[id].r=rr,tr[id].minn=inf; 
    if(ll==rr) return;
    int m=ll+rr>>1;
    build(ls,ll,m),build(rs,m+1,rr);
}
void update(int id,int pos,int val1,int val2,int val3,int val4)
{
    if(tr[id].l==pos && tr[id].r==pos) 
    {
        tr[id].sumc=val1;tr[id].sumw=val2;
        tr[id].minn=val3;tr[id].maxx=val4;
        return;
    }
    if(tr[ls].r>=pos) update(ls,pos,val1,val2,val3,val4);
    else update(rs,pos,val1,val2,val3,val4);
    tr[id].sumc=tr[ls].sumc+tr[rs].sumc;
    tr[id].sumw=tr[ls].sumw+tr[rs].sumw;
    tr[id].minn=min(tr[ls].minn,tr[rs].minn);
    tr[id].maxx=max(tr[ls].maxx,tr[rs].maxx);
}
int main()
{
    int n=maxn-10;
    build(1,1,n);
    while(scanf("%d",&opt)==1 && opt!=-1)
    {
        int w,c;
        if(opt==1) 
        {
            scanf("%d %d",&w,&c);
            if(vis[c]) continue;
            update(1,c,c,w,c,c);vis[c]=true;
        }
        if(opt==3)
        {
            if(tr[1].minn==inf) continue;//此时无花，下同； 
            vis[tr[1].minn]=false,update(1,tr[1].minn,0,0,inf,0);
        }
        if(opt==2)
        {
            if(tr[1].maxx==0) continue;
            vis[tr[1].maxx]=false,update(1,tr[1].maxx,0,0,inf,0);
        }
    }
    printf("%d %d",tr[1].sumw,tr[1].sumc);
}
```

---

## 作者：fyfy (赞：8)

### 这题其实可以用vector水掉！

### 定义：

记住要用结构体(c为价格，x为美丽值)！

以c排序。

```cpp
struct Node {
	int x,c;
	bool operator < (const &Node t) const {
    	return c<t.c;
    }
}
vector <Node> a;
```

### 插入：

upper_bound的作用是将当前节点插到合适位置，以达到排序效果。

记住不能插入同样价格的花。

所以用vis[]数组统计。

```cpp
if (vis[c]) continue;
vis[c]=1;
a.insert(upper_bound(a.begin(),a.end(),(Node){x,c}),(Node){x,c});

```

### 删除：

大节点就删除最后一个，记住要把vis[]清掉。

vector区间是左闭右开的，所以删除erase(a.end()-1)。

即：

```cpp
if (opt==2) vis[a[a.size()-1].c]=0,a.erase(a.end()-1);
```

小节点就删除第一个，即：

```cpp
if (opt==3) vis[a[0].c]=0,a.erase(a.begin());
```

### 代码：

注意要开long long～

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef int _int;
#define int long long
struct Node {
    int x,c;
    bool operator < (const Node &t) const {
        return c<t.c;
    }
};
vector <Node> a;
int ans1,ans2;
bool vis[1000001];
_int main()
{
    int opt,x,c;
    while (1) {
        scanf("%lld",&opt);
        if (opt==-1) break;
        if (opt==1) {
            scanf("%lld%lld",&x,&c);
            if (vis[c]) continue;
            vis[c]=1;
            a.insert(upper_bound(a.begin(),a.end(),(Node){x,c}),(Node){x,c});
        }
        if (!a.size()) continue;
        if (opt==3) vis[a[0].c]=0,a.erase(a.begin());
        if (opt==2) vis[a[a.size()-1].c]=0,a.erase(a.end()-1);
    }
    int len=a.size();
    for (int i=0;i<len;++i) ans1+=a[i].x,ans2+=a[i].c;
    cout<<ans1<<' ';
    cout<<ans2<<endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：7)

## 前铺：

刚学了普通平衡树想来蹭点经验，写着写着蒙了，来到题解区一看，为什么都是各种 STL 或变种的平衡树，让我这个只会普通平衡树的人一头雾水。待我用普通平衡树调了半天终于 AC 后，决定写篇普通平衡树的题解造福一下别人。

PS：本篇题解适合刚学普通平衡树或没有思路的同学，如果你还不会普通平衡树，你可以用别的大佬的方法或出门左转 [luogu P3369](https://www.luogu.com.cn/problem/P3369)。

---

## 思路：

为什么要用平衡树？我们知道平衡树适用于一段序列的查找、排序、插入以及删除。我们可以将题面当中的每朵花看成是一个数，然后我们就知道了我们仅须支持插入和删除操作即可（不需要 size ），但删除的是当前的最大值或最小值所以我们需要插入数后，用平衡树进行当前花朵的价格的排序并找出最大值和最小值。

## 提示：

如果你已经用平衡树写出代码，但调试不出来，你不妨可以看看以下几点提示：

- 题面中 2 和 3 操作换了下位置。
- 添加一朵花记得进行标记看是否有重复。
- 删除一朵花时记得标记要重置。
- 非递归的删除操作很不友好，**建议**改成递归。

以上就是我在做题时遇到的一些坑，看看有没有中招的。

## 代码函数详解：

### add 新建节点：

在新建节点时，记得将求和的变量 ```sum_c,sum_w``` 加上对应值,以及进行标记已在花束中：
```cpp
int add(int w,int c)
{
	t[++tot].c=c,t[tot].w=w,sum_w+=w,sum_c+=c,vis[c]=1;
	return tot; 
}  
 ```

### del 删除操作：

这题的重点就是删除操作，首先要明白如何在一颗平衡树中找到最大值和最小值，因为一颗平衡树也是一颗二叉排序树，所以它满足左孩子小于父亲，右孩子大于父亲的性质。那么**最大值即为最有的节点，最小值即为最左的节点（见下图）**，然后直接像删除只有一个孩子的节点那样，让孩子节点替代父亲节点,再减去它的漂亮值与价格，重置标记。

![](https://s2.ax1x.com/2020/03/06/3q32nJ.png)

```cpp
void del_min(int &x)
{
	if(t[x].l)
		del_min(t[x].l);//如果它还有比它小的左儿子，则找递归它的左子树
	else 
	{
		sum_c-=t[x].c;
		sum_w-=t[x].w;
		vis[t[x].c]=0;
	    x=t[x].r;
	}
}

void del_max(int &x)
{
	if(t[x].r)
		del_max(t[x].r);//如果它还有比它大的右儿子，则找递归它的右子树
	else 
	{
		sum_c-=t[x].c;
		sum_w-=t[x].w;
		vis[t[x].c]=0;
		x=t[x].l;
	}
}
```

## 完整代码：

```cpp
#include<stdio.h>
#include<algorithm>
#include<cstdlib>
using namespace std;

const int N=1e5+86; 

int n,tot,root,vis[1000001];
int sum_w,sum_c;

struct Treap
{
	Treap()
	{
		pri=rand()*rand()%20061124;
		l=r=0;
	}//构造函数
	int l;
	int r;
	int pri;
	int c;
	int w;
}t[N];

int add(int w,int c)//新建节点
{
	t[++tot].c=c,t[tot].w=w,sum_w+=w,sum_c+=c,vis[c]=1;
	return tot; 
}

void right_rorate(int &x)//右旋
{
	int tmp=t[x].l;
	t[x].l=t[tmp].r;
	t[tmp].r=x;
	x=tmp;
}

void left_rorate(int &x)//左旋
{
	int tmp=t[x].r;
	t[x].r=t[tmp].l;
	t[tmp].l=x;
	x=tmp;
}

void insert(int &x,int w,int c)//插入操作
{
	if(x==0)
	{
		x=add(w,c);
		return;
	}
	if(c>=t[x].c)
		insert(t[x].r,w,c);
	else
		insert(t[x].l,w,c);
	if(t[x].r&&t[t[x].r].pri<t[x].pri)
		left_rorate(x);
	if(t[x].l&&t[t[x].l].pri<t[x].pri)
		right_rorate(x);
}

void del_min(int &x)//删除当前最小值
{
	if(t[x].l)
		del_min(t[x].l);
	else 
	{
		sum_c-=t[x].c;
		sum_w-=t[x].w;
		vis[t[x].c]=0;
		x=t[x].r;
	}
}

void del_max(int &x)//删除当前最大值
{
	if(t[x].r)
		del_max(t[x].r);
	else 
	{
		sum_c-=t[x].c;
		sum_w-=t[x].w;
		vis[t[x].c]=0;
		x=t[x].l;
	}
}

int main()
{
	int opt;
	while(scanf("%d",&opt)==1)
	{
		if(opt==-1) break;
		if(opt==1)
		{
			int w,c;
			scanf("%d%d",&w,&c);
			if(vis[c]) continue;//如果重复则跳过不插入
			insert(root,w,c);
		}
		else if(opt==3)
			del_min(root);
		else if(opt==2)
			del_max(root);
	}            
	printf("%d %d\n",sum_w,sum_c);
	return 0;
}
```

感谢大家阅读，希望能帮到大家！

 

---

## 作者：SGOI_Aromyase (赞：7)

其实线段树我们维护两个标记就可以了
贼水的一道题
```
#include<bits/stdc++.h>
#define maxn 1000005//按照费用建线段树
#define mid ((zuo+you)>>1)
#define c1 (o<<1)
#define c2 (o<<1|1)
using namespace std;
int sumc[maxn<<2],sumw[maxn<<2];

//--//--//线段树//--//--//
void del(int o,int zuo,int you,int s)//s==1表示删除最
//贵的花，也就是线段树存在的最右的叶节点
{
	if(zuo==you){
		sumc[o]=sumw[o]=0;return;
	}
	if(s&&sumc[c1]&&sumc[c2]) del(c2,mid+1,you,s);
	else if(!sumc[c1]) del(c2,mid+1,you,s);
	else del(c1,zuo,mid,s);
	sumc[o]=sumc[c1]+sumc[c2];
	sumw[o]=sumw[c1]+sumw[c2];
}

void update(int o,int zuo,int you,int x,int y,int k)
{
	if(zuo==you){
		if(sumc[o]) return;
		sumc[o]=x;sumw[o]=k;
		return;
	}
	if(x<=mid) update(c1,zuo,mid,x,y,k);
	else update(c2,mid+1,you,x,y,k);
	sumc[o]=sumc[c1]+sumc[c2];
	sumw[o]=sumw[c1]+sumw[c2];
} 

int main()
{
	int opt,x,y;
	while(1){
		scanf("%d",&opt);
		if(opt==-1) break;
		if(opt==1){
			scanf("%d%d",&x,&y);
			update(1,1,maxn,y,y,x);
		}
		if(opt==2){
			if(sumc[1]==0) continue;
			del(1,1,maxn,1);
		}
		if(opt==3){
			if(sumc[1]==0) continue;
			del(1,1,maxn,0);
		}
	}
	cout<<sumw[1]<<" "<<sumc[1];
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：7)

貌似没有C++ set的题解

原理:set判重&排序

注意结构体要运用重载运算符

```cpp
#include<set>
#include<cstdio>
using namespace std;
struct flower1  //按贵的排序 
{
    int w,c;
    bool operator<(const flower1 &fff)const
    {
        if (c==fff.c)return 0;  //判重 
        return c>fff.c;
    }
};
struct flower2  //按便宜的排序 
{
    int w,c;
    bool operator<(const flower2 &fff)const
    {
        if (c==fff.c)return 0;   //判重 
        return c<fff.c;
    }
};
set<flower1>s1;
set<flower2>s2;
int ans1,ans2;
int main()
{
    int type,w,c;
    while (scanf("%d",&type)==1&&type>0)
    {
        if (type<2) //也就是type==1，但是这样代码短 
        {
            scanf("%d%d",&w,&c);
            s1.insert((flower1){w,c});
            s2.insert((flower2){w,c});   //添加花 
        }
        if (type==2)
        {
            int dw=s1.begin()->w,dc=s1.begin()->c;
            s1.erase(*s1.begin());  //先把最贵的删掉 
            s2.erase((flower2){dw,dc}); //把s2中对应最贵的花删掉 
            //因为flower1和flower2是不同类型所以不能直接s2.erase(*s1.begin());
        }
        if (type==3)
        {
            //同理删最便宜的 
            int dw=s2.begin()->w,dc=s2.begin()->c;
            s1.erase((flower1){dw,dc});
            s2.erase(*s2.begin());
        }
    }
    for (set<flower1>::iterator i=s1.begin();i!=s1.end();i++)
        ans1+=i->w,ans2+=i->c;  //累加答案 
    printf("%d %d",ans1,ans2);
    return 0;
}
```

---

## 作者：秋日私语 (赞：6)

我的[blog](https://blog.csdn.net/A_Comme_Amour/article/details/79775187)


题目
-

[传送门](https://www.luogu.org/problemnew/show/P2073)

题解
-

写这道题是为了写权值线段树
看到c的范围比较小，按照C为权值建立线段树，c的值就是线段树的叶子位置；
类似于平衡树的做法，查询最左或最有的节点删除

代码
-

```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
#define lson (rt<<1)
#define rson (rt<<1|1)
using namespace std;
const int maxn=1e6+10;
const int inf=1e9;

int read(){
    char ch=getchar(); int now=0,f=1;
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9') {now=(now<<1)+(now<<3)+ch-'0'; ch=getchar();}
    return now*f;}
struct Node{
    int w; int c;
}tree[maxn<<2];

void clear(int rt) {tree[rt].w=tree[rt].c=0;}
void pushup(int rt)
{
    tree[rt].w=tree[lson].w+tree[rson].w;
    tree[rt].c=tree[lson].c+tree[rson].c;
}
void change(int x,int W,int C,int l,int r,int rt)
{
    if (l==r)
	{
		if (tree[rt].c) return;
		tree[rt].w=W; tree[rt].c=C; return;
	}
    int mid=(l+r)>>1;
    if (x<=mid) change(x,W,C,l,mid,lson);
    else change(x,W,C,mid+1,r,rson);
    pushup(rt);
}

void del(int l,int r,int rt,bool flag)//flag标记是否删除最后一个
{
    if (l==r) {clear(rt); return;}
    int mid=(l+r)>>1;
    if (flag && tree[lson].c && tree[rson].c) del(mid+1,r,rson,flag);
    else if (!tree[lson].c) del(mid+1,r,rson,flag);
         else del(l,mid,lson,flag);
    pushup(rt);
}

int main()
{
    int opt;
    while (opt=read())
    {
        if (opt==-1) break;
        if (opt==1)
        {
            int w=read(); int c=read();
            change(c,w,c,1,maxn,1);
        }
        if (opt==3) del(1,maxn,1,0);
        if (opt==2) del(1,maxn,1,1);
    }
    printf("%d %d",tree[1].w,tree[1].c);
    return 0;
}
```

总结
-

善用define

---

## 作者：梦里调音 (赞：5)

> 终于A了！！！

5个子程序。

算法：平衡树

插入就是平衡树排序模板做法。

删除就是往下找节点。

删小的和删大的差不多，一个往左，一个往右嘛~

还有一些细节注意一下就好了。

```
#include <bits/stdc++.h>
#define re register
using namespace std;
//价格在此区间的有几个    左节点编号    右节点编号  编号总数       
long long int a[1000001],al[1000001],ar[1000001],an=1;
//              美丽值     价格       父节点编号 
long long int ml[1000001],jg[1000001],f[1000001];
const int minn=1,maxn=1000000;
long long int answ,ansc;
inline void pushupp(int k){//从p往上加 a[] 
	while(k){
		a[k]++;
		k=f[k];
	}
	return;
}
inline void ins(int mlz,int k){//插入：美丽值、价格 
	int p=1,pl=minn,pr=maxn;
	while(pl<pr){
		int mid=(pl+pr)/2;
		if(k<=mid){
			if(al[p]==0){
				an++;
				al[an]=0;
				ar[an]=0;
				al[p]=an;
			}
			f[al[p]]=p;p=al[p];pr=mid;
		}
		else{
			if(ar[p]==0){
				an++;
				al[an]=0;
				ar[an]=0;
				ar[p]=an;
			}
			f[ar[p]]=p;p=ar[p];pl=mid+1;
		}
	}
	if(ml[p]==0){//保证没有同价钱的花
		pushupp(p);
		ml[p]=mlz;
		jg[p]=k;
		answ+=mlz;
		ansc+=k;
	}
	return;
}
inline void pushup(int p){//从p往上减 a[]
	while(p){
		a[p]--;
		p=f[p];
	}
	return;
}
inline int del_e(int p){//删除贵的花 
	long long int ansh=0;
	while(1){
		if(ml[p])ansh=p;//有花 
		if(ar[p]&&a[ar[p]])p=ar[p];//还有更贵的花 
		else if(ansh==0&&al[p])p=al[p];//没花 
		if(ansh&&ar[p]==0)break;//有花且没有更贵的花了 
	}
	return ansh;
}
inline int del_c(int p){//删除便宜的花 
	long long int ansh=0;
	while(1){
		if(ml[p])ansh=p;//有花 
		if(al[p]&&a[al[p]])p=al[p];//还有更便宜的花 
		else if(ansh==0&&ar[p])p=ar[p];//没花 
		if(ansh&&al[p]==0)break;//有花且没有更便宜的花了 
	}
	return ansh;
}
int main(void){
	long long int op,w,c;
	while(cin>>op){
		if(op==-1)break;
		else if(op==1)cin>>w>>c,ins(w,c);
			else if(op==2&&a[1]){
				int ansh;
				ansh=del_e(1);
				if(ansh){
					answ-=ml[ansh];
					ansc-=jg[ansh];
					jg[ansh]=0;
					ml[ansh]=0;
					pushup(ansh);
				}
			}
				else if(op==3&&a[1]){
					int ansh;
					ansh=del_c(1);
					if(ansh){
						answ-=ml[ansh];
						ansc-=jg[ansh];
						al[ansh]=0;
						ar[ansh]=0;
						jg[ansh]=0;
						ml[ansh]=0;
						pushup(ansh);
					}
				}
	}
	cout<<answ<<" "<<ansc<<endl; 
	return 0;
}
```


---

## 作者：斯德哥尔摩 (赞：5)

啊，身为只是拿到了省一的蒟蒻，我，经过4天的艰苦奋战，终于A了此题。。。

按捺不住内心喜悦，给后来人一个借鉴

经典 平衡树 问题，用 Treap 或 Splay 都可以。

第一天：（RE 0）\*4

第二天：（RE 0）\*2+（RE 60）\*2

第三天：（WA 0）\*2+（WA 40）\*3

第四天：（WA 0）\*1+（WA 40）\*1+（AC 100）\*1

实在是丧心病狂的题目。。。

注意：

1.不要将 操作2 与 操作3 弄反，题目有毒。。。

2.每种价格的花只有一个。。。

结构体指针型 Treap ,貌似没有人写，来一发。。。（奇丑无比）

每个节点维护：本身的价格，美丽值，子树的价格和值，美丽值和值，两个儿子节点

之后就是套模板，改一改就好了。

附上苦心敲出的AC代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
struct node{
    node* son[2];
    int v,data,sum1,sum2,w;
    node(){//节点初始化
        son[0]=son[1]=NULL;
        w=rand();
        v=data=sum1=sum2=0;
    }
};
node* rt;
inline int read(){//读优。。。
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
void maintain(node* &u){//结点维护
    u->sum1=u->v;u->sum2=u->data;
    if(u->son[0]!=NULL){//第一天忘了判断，RE 。。。
        u->sum1+=u->son[0]->sum1;
        u->sum2+=u->son[0]->sum2;
    }
    if(u->son[1]!=NULL){
        u->sum1+=u->son[1]->sum1;
        u->sum2+=u->son[1]->sum2;
    }
}
void turn(node* &u,int f){//旋转
    node* t=u->son[f^1];
    u->son[f^1]=t->son[f];
    t->son[f]=u;
    maintain(u);
    maintain(t);
    u=t;
}
bool insert(node* &u,int w,int c){//插入
    if(u==NULL){
        u=new node;
        u->v=c;u->data=w;
        maintain(u);//第三天忘了维护，WA 40 。。。
        return true;
    }
    else if(u->v==c)return false;//判重
    int y=c>u->v?1:0;
    bool f=insert(u->son[y],w,c);
    if(u->son[y]->w>u->w)turn(u,y^1);
    if(u!=NULL)maintain(u);
    return f;
}
void remove(node* &u,int x,int y){//删除
    if(u==NULL)return;
    if(u->v==x){
        if(u->son[0]==NULL&&u->son[1]==NULL)u=NULL;
        else if(u->son[0]!=NULL&&u->son[1]!=NULL){
            if(u->son[0]->w>u->son[1]->w){
                turn(u,1);
                remove(u->son[1],x,y);
            }
            else{
                turn(u,0);
                remove(u->son[0],x,y);
            }
        }
        else{
            if(u->son[0]==NULL)u=u->son[1];
            else u=u->son[0];
        }
        if(u!=NULL)maintain(u);
        return;
    }
    u->sum1-=x;u->sum2-=y;
    if(x<u->v)remove(u->son[0],x,y);
    else if(x>u->v)remove(u->son[1],x,y);
    if(u!=NULL)maintain(u);
}
void find(node* u,int k,int &x,int &y){//查询
    if(k)while(u->son[0]!=NULL)u=u->son[0];
    else while(u->son[1]!=NULL)u=u->son[1];
    x=u->v;y=u->data;
}
int main(){
    srand(987);//随机种子
    int x,y,z,m=0;
    while(1){
        scanf("%d",&x);
        if(x==-1)break;
        if(x==1){
            scanf("%d%d",&y,&z);
            if(insert(rt,y,z))m++;
            continue;//感觉这样好低端，然而能过就行了。。。
        }
        if(m==0)continue;//第二天没有这句，WA 60 。。。
        m--;
        find(rt,(x==3?1:0),y,z);
        remove(rt,y,z);
    }
    if(rt==NULL)printf("0 0\n");//第二天也忘了这句，RE 0 。。。
    else printf("%d %d\n",rt->sum2,rt->sum1);
    return 0;//终于打完了（累死我了。。。）
}

```

---

## 作者：_YPC (赞：4)

# Luogu2073 【送花】 题解

---

>貌似没有人写过替罪羊树的代码，所以蒟蒻前来贡献一发题解

## 思想

用替罪羊树维护花的价值和美丽值的序列，把花的价值当成关键字建树就行了，删除最贵的花那么就删除树的右子树的最后一个节点，删除最便宜的花那么就删除树的左子树的第一个节点。ans_w,ans_c的值跟着变动就行了。

## 注意点

这题目的$3$号操作和$2$号操作千万别搞反了！！！

这题操作$2$，$3$操作是反着给的！！！

如果搞反的话那么就只有$10$分！！！

## 代码

```
#include<cstdio>
#include<cctype>
#define LL long long
#define alpha 0.75
#define qmid(L,R) (L+((R-L)>>1))
using namespace std;
int n,m,root,sum,cur[1000005],tot;
bool hsh[1000005];
LL ans_w,ans_c;
struct ypc{
	int val,son[2],fa,beu;
	double size;
}t[1000005];
inline bool balance(int id){
	return t[t[id].son[0]].size<=t[id].size*alpha&&t[t[id].son[1]].size<=t[id].size*alpha;
}
void dfs(int id){
	if (!id)return;
	dfs(t[id].son[0]);
	cur[++sum]=id;
	dfs(t[id].son[1]);
}
int build(int L,int R){
	if (L>R)return 0;
	int mid=qmid(L,R),id=cur[mid],ls=build(L,mid-1),rs=build(mid+1,R);
	t[ls].fa=t[rs].fa=id;
	t[id].son[0]=ls,t[id].son[1]=rs;
	t[id].size=t[ls].size+t[rs].size+1;
	return id;
}
inline int get_lr(int id){
	return t[t[id].fa].son[1]==id;
}
inline void rebuild(int id){
	sum=0,dfs(id);
	int fa=t[id].fa,opt=get_lr(id),new_son=build(1,sum);
	t[fa].son[opt]=new_son,t[new_son].fa=fa;
	if (root==id)root=new_son;
}
inline void insert(int w,int c){
	if (!root){t[root=++tot].val=c,t[root].size=1,t[root].beu=w;return;}
	int tmp=root;
	while (tmp){
		t[tmp].size++;
		int fa=tmp,opt=(c>=t[tmp].val);tmp=t[tmp].son[opt];
		if (!tmp){
			t[++tot].val=c,t[tot].fa=fa,t[tot].size=1,t[tot].beu=w,t[fa].son[opt]=tot;
			break;
		}
	}
	int flg=0;
	for (int i=tot;i;i=t[i].fa)if (!balance(i))flg=i;
	if (flg)rebuild(flg);
}
inline void erase(int id){
	if (t[id].son[0]&&t[id].son[1]){
		int tmp=t[id].son[0];
		while (t[tmp].son[1])tmp=t[tmp].son[1];
		t[id].val=t[tmp].val,id=tmp;
	}
	int son=t[id].son[0]?t[id].son[0]:t[id].son[1],opt=get_lr(id),fa=t[id].fa;
	t[fa].son[opt]=son,t[son].fa=fa;
	if (root==id)root=son;
}
inline int get_min(){
	int tmp=root;
	while (t[tmp].son[0])tmp=t[tmp].son[0];
	return tmp;
}
inline int get_max(){
	int tmp=root;
	while (t[tmp].son[1])tmp=t[tmp].son[1];
	return tmp;
}
inline int read(){
	int ret=0,flg=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')flg=-1;ch=getchar();}
	while (isdigit(ch))ret=ret*10+ch-48,ch=getchar();
	return ret*flg;
}
int main(){
//	freopen("Luogu2073.in","r",stdin);
//	freopen("Luogu2073.out","w",stdout);
	for (;;){
		int tpe=read();
		if (tpe==-1)break;
		if (tpe==1){
			int w=read(),c=read();
			if (hsh[c])continue;else hsh[c]=1;
			insert(w,c),ans_w+=w,ans_c+=c;
//			sum=0,dfs(root);
//			for (int i=1;i<=sum;i++)printf("%d ",cur[i]);
//			printf("\n");
		}
		if (tpe==2){
			int id=get_max();
			ans_w-=t[id].beu,ans_c-=t[id].val,hsh[t[id].val]=0,erase(id);
		}
		if (tpe==3){
			int id=get_min();
			ans_w-=t[id].beu,ans_c-=t[id].val,hsh[t[id].val]=0,erase(id);
		}
	}
	printf("%lld %lld\n",ans_w,ans_c);
	return 0;
}
```

---

## 作者：Fortitude (赞：2)

这题只要求加入和删除

可以直接用map做(stl大法好)

稍微注意一下删除操作

别把2,3弄反就行了




```cpp
#include<cstdio>
#include<iostream>
#include<map>
using namespace std;
typedef long long ll;
map <int,int> Map;
int op;
ll W,C;
inline int read()
{
    int s=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
        s=s*10+ch-'0',ch=getchar();
    return s*f;
}
int main()
{
    int w,c;
    map <int,int>::iterator it;
    while((op=read())!=-1)
    {
        if(op==1)
        {
            w=read(),c=read();
            Map.insert(make_pair(c,w));
        }
        else
        {
            if(Map.empty()) continue;//删除前先判断是否为空
            if(op==2)
            {
                it=Map.end();
                Map.erase(--it);
            }
            if(op==3)
            {
                it=Map.begin();
                Map.erase(it);
            }
        }
    }
    it=Map.begin();
    while(it!=Map.end())
    {
        C+=it->first,W+=it->second;
        it++;
    }
    printf("%lld %lld\n",W,C);
    return 0;
}

```

---

## 作者：Ireliaღ (赞：2)

## 看到没人写指针版FHQTreap，我来写一发

~~***debug的时候，指针版数据结构直接添加查看这个指针就把指针所指结构体的所有变量全都显示出来了，为什么没多少人用啊。。***~~

### 前置知识：无旋Treap，可以看我[博客](https://www.cnblogs.com/Juruo1103/p/10281403.html)

### 题目要求：资瓷插入节点，删除最值

维护一棵$FHQTreap$，并存储$w$和$c$的总值

#### 插入节点：

先在这棵树查找$c$，如果有直接返回，取消插入（划重点）  
然后就可以正常像$FHQTreap$一样查排名分裂合并了，注意更新$total$值

#### 删除最值：

注意判空根，注意更新$total$值，正常分裂出一个节点删除即可

### 最后放出完整代码

```cpp
// luogu-judger-enable-o2
#include <stdio.h>

int Rand() {
    static int seed = 2333333;
    return seed = (((seed | 66666) + 19260817ll) * 1433223ll) % 0x7f7f7f7f;
}

namespace FHQ{
    int totw = 0, totc = 0;

    struct Node{
        int w, c, size, key;
        Node *child[2];
        Node(int w, int c):w(w), c(c), size(1), key(Rand()) {child[0] = child[1] = NULL;}
    };

    Node *root = NULL;

    void Update(Node *now) {
        now->size = 1;
        now->size += now->child[0] ? now->child[0]->size : 0;
        now->size += now->child[1] ? now->child[1]->size : 0;
    }

    void Split(Node *now, int k, Node *&t1, Node *&t2) {
        if (!now) {
            t1 = t2 = NULL; return;
        }
        if (k == 0) {
            t1 = NULL; t2 = now; return;
        }
        if (k >= now->size) {
            t1 = now; t2 = NULL; return;
        }
        int ls = now->child[0] ? now->child[0]->size : 0;
        if (k <= ls) {
            Node *temp;
            Split(now->child[0], k, t1, temp); 
            t2 = now; t2->child[0] = temp; Update(t2); return;
        } else {
            Node *temp;
            Split(now->child[1], k - ls - 1, temp, t2);
            t1 = now; t1->child[1] = temp; Update(t1); return;
        }
    }

    Node *Merge(Node *a, Node *b) {
        if (!a || !b) return a ? a : b;
        if (b->key > a->key) {
            a->child[1] = Merge(a->child[1], b);
            Update(a); return a;
        } else {
            b->child[0] = Merge(a, b->child[0]);
            Update(b); return b;
        }
    }

    int Rank(Node *now, int k) {
        if (!now) return 1;
        int ls = now->child[0] ? now->child[0]->size : 0;
        if (k < now->c) return Rank(now->child[0], k);
        else if (k > now->c) return Rank(now->child[1], k) + ls + 1;
        else return ls + 1;
    }

    bool Insert(int w, int c) {
        if (!root) {
            root = new Node(w, c);
            totw += w; totc += c;
            return true;
        }
        if (root) {
            Node *now = root;
            while (now) {
                if (c < now->c) now = now->child[0];
                else if (c > now->c) now = now->child[1];
                else return false;
            }
        }
        Node *temp = new Node(w, c);
        int rank = Rank(root, c);
        Node *lt, *rt;
        Split(root, rank - 1, lt, rt);
        root = Merge(lt, Merge(temp, rt));
        totw += w; totc += c;
        return true;
    }

    void DelMax() {
        if (!root) return;
        Node *lt, *rt;
        Split(root, root->size - 1, lt, rt);
        root = lt; totw -= rt->w; totc -= rt->c;
        delete rt; return;
    }

    void DelMin() {
        if (!root) return;
        Node *lt, *rt;
        Split(root, 1, lt, rt);
        root = rt; totw -= lt->w; totc -= lt->c;
        delete lt; return;
    }
}

int main() {
    int opt = 0, w, c;
    while (scanf("%d", &opt), opt != -1) {
        switch(opt) {
            case 1: {
                scanf("%d %d", &w, &c);
                FHQ::Insert(w, c);
                break;
            }
            case 2: {
                FHQ::DelMax();
                break;
            }
            case 3: {
                FHQ::DelMin();
                break;
            }
        }
    }
    printf("%d %d\n", FHQ::totw, FHQ::totc);
    return 0;
}
/*
1 1 1
1 2 5
2
1 3 3
3
1 5 2
-1
*/
```

输入$opt$那里压了一下行，因为$while$里有逗号是返回最后一句的$true/false$

---

## 作者：yzhang (赞：2)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10017405.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P2073)

### 这题需要用到[Splay](https://www.cnblogs.com/yzhang-rp-inf/p/9957906.html)

我们用一棵splay维护金钱

考虑c<=1000000

我们珂以把每种价格现在对应的美丽值存在一个a数组中

这样讲有珂能不太清楚qaq，还是对着操作一个一个讲

操作一：

先在这棵splay中查找是否有这种花的金钱

如果有，直接跳过

如果没有，a[c]=m，把金钱为c的花的美丽值存下，把两个所求答案更新，把c插入平衡树

操作2,3：

执行所有操作之前先把inf，-inf插入平衡树

删除最小就是删除-inf的后继，删除最大就是删除inf的前驱

但还要加上特判，在后继（前驱）不等于inf（-inf）的情况下，更新答案，a数组变成0，把该节点从平衡树中删除

### 完整代码

```cpp
#include <bits/stdc++.h>
#define inf 1000000005
#define N 100005
#define root tree[0].ch[1]
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=nc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=nc();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
struct Splay{
    int v,fa,ch[2],sum;
}tree[N];
int tot;
inline bool findd(register int x)
{
    return x==tree[tree[x].fa].ch[0]?0:1;
}
inline void connect(register int x,register int fa,register int son)
{
    tree[x].fa=fa;
    tree[fa].ch[son]=x;
}
inline void update(register int x)
{
    tree[x].sum=tree[tree[x].ch[0]].sum+tree[tree[x].ch[1]].sum+1;
}
inline void rotate(register int x)
{
    int Y=tree[x].fa;
    int R=tree[Y].fa;
    int Yson=findd(x);
    int Rson=findd(Y);
    int B=tree[x].ch[Yson^1];
    connect(B,Y,Yson);
    connect(Y,x,Yson^1);
    connect(x,R,Rson);
    update(Y),update(x);
}
inline void splay(register int x,register int to)
{
    to=tree[to].fa;
    while(tree[x].fa!=to)
    {
        int y=tree[x].fa;
        if(tree[y].fa==to)
            rotate(x);
        else if(findd(x)==findd(y))
            rotate(y),rotate(x);
        else
            rotate(x),rotate(x);
    }
}
inline int newpoint(register int v,register int fa)
{
    tree[++tot].fa=fa;
    tree[tot].v=v;
    tree[tot].sum=1;
    return tot;
}
inline void Insert(register int x)
{
    int now=root;
    if(root==0)
    {
        newpoint(x,0);
        root=tot;
    }
    else
    {
        while(19260817)
        {
            ++tree[now].sum;
            int nxt=x<tree[now].v?0:1;
            if(!tree[now].ch[nxt])
            {
                int p=newpoint(x,now);
                tree[now].ch[nxt]=p;
                splay(p,root);
                return;
            }
            now=tree[now].ch[nxt];
        }
    }
}
inline int find(register int v)
{
    int now=root;
    while(19260817)
    {
        if(tree[now].v==v)
        {
            splay(now,root);
            return now;
        }
        int nxt=v<tree[now].v?0:1;
        if(!tree[now].ch[nxt])
            return 0;
        now=tree[now].ch[nxt];
    }
}
inline void delet(register int x)
{
    int pos=find(x);
    if(!pos)
        return;
    if(!tree[pos].ch[0]&&!tree[pos].ch[1])
        root=0;
    else if(!tree[pos].ch[0])
    {
        root=tree[pos].ch[1];
        tree[root].fa=0;
    }
    else
    {
        int left=tree[pos].ch[0];
        while(tree[left].ch[1])
            left=tree[left].ch[1];
        splay(left,tree[pos].ch[0]);
        connect(tree[pos].ch[1],left,1);
        connect(left,0,1);
        update(left);
    }
}
inline int lower(register int v)
{
    int now=root;
    int ans=-inf;
    while(now)
    {
        if(tree[now].v<v&&tree[now].v>ans)
            ans=tree[now].v;
        if(v>tree[now].v)
            now=tree[now].ch[1];
        else
            now=tree[now].ch[0];
    }
    return ans;
}
inline int upper(register int v)
{
    int now=root;
    int ans=inf;
    while(now)
    {
        if(tree[now].v>v&&tree[now].v<ans)
            ans=tree[now].v;
        if(v<tree[now].v)
            now=tree[now].ch[0];
        else
            now=tree[now].ch[1];
    }
    return ans;
}
int a[1000005];
int main()
{
    Insert(inf);
    Insert(-inf);
    int opt=read(),ans1=0,ans2=0;
    while(opt!=-1)
    {
        if(opt==1)
        {
            int w=read(),c=read();
            if(!find(c))
            {
                ans1+=w,ans2+=c;
                a[c]=w;
                Insert(c);
            }
        }
        else if(opt==2)
        {
            int c=lower(inf);
            if(c!=-inf)
            {
                ans1-=a[c],ans2-=c;
                a[c]=0;
                delet(c);
            }
        }
        else
        {
            int c=upper(-inf);
            if(c!=inf)
            {
                ans1-=a[c],ans2-=c;
                a[c]=0;
                delet(c);
            }
        }
        opt=read();
    }
    write(ans1),putchar(' '),write(ans2);
    return 0;
 } 
```

---

## 作者：yizimi远欣 (赞：2)

~~毒瘤题目~~

### 主要思路：线段树（权值线段树）

可能很多同学做题之前会看一下题目标签。

这题的题目标签就是**线段树**与**平衡树**，然而写不出来以后，一看题解里全是STL，一脸茫然，，，

#### 我这里是一篇正了八经的线段树解法。

首先我们要看清题：

	1.操作的编号一定不能看倒，不能理所当然
    
    2.记得是有这么一句话：“如果加入的花朵价格已经与花束中已有花朵价格重复，则这一朵花不能加入花束。”一定不能忘了！！！
    
首先我们想一下如何插入删除。

我们看题目数据范围可知，W,C<=1000000，这就很好了，既然我们需要按最大最小排钱数，我们不如直接维护一个以**花的价格**为权值线段树所维护信息的序列。注意：权值线段树维护的是花的价格！

然后我们维护一个区间里的最大价格与最小价格，这样就可以方便2,3操作了。我们不是不能重复加入吗？那没关系，我们可以先把每个结点的区间内最大价格和最小价格分别设为-INF和INF，使得只要这个点中有一个数就可以改变之前初始化，那么我们在每次插入时，记得判断一下区间最大和区间最小和其中的价格权值是否是初始化状态就好了，如果不是初始化状态，就干脆不改了。

然后就是————
### 代码实现：
```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 1000010
#define inf 2147483647
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, 1000000, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
//#define LOCAL
#define mod 
#define Debug(...) fprintf(stderr, __VA_ARGS__)
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
//This is AC head above...
struct tree{
    int minn, maxx, sumw, sumc;
} z[mn << 2];
inline void update(int rt){
    z[rt].minn = min(z[rt << 1].minn, z[rt << 1 | 1].minn);
    z[rt].maxx = max(z[rt << 1].maxx, z[rt << 1 | 1].maxx);
    z[rt].sumw = z[rt << 1].sumw + z[rt << 1 | 1].sumw;
    z[rt].sumc = z[rt << 1].sumc + z[rt << 1 | 1].sumc;
}
inline void build(int l,int r,int rt){
    if(l == r) {
        z[rt].minn = inf;
        z[rt].maxx = -inf;
        z[rt].sumw = z[rt].sumc = 0;
        return;
    }
    int m = (l + r) >> 1;
    build(lson), build(rson), update(rt);
}
inline void modify_add(int l,int r,int rt,int c,int v){
    if(l == r) {
        if(z[rt].minn != inf || z[rt].maxx != -inf || z[rt].sumc){
            return;
        }
        z[rt].minn = z[rt].maxx = c;
        z[rt].sumw = v, z[rt].sumc = c;
        return;
    }
    int m = (l + r) >> 1;
    if(c <= m)
        modify_add(lson, c, v);
    else
        modify_add(rson, c, v);
    update(rt);
}
inline void modify_del(int l,int r,int rt,int c){
    if(l == r) {
        z[rt].minn = inf, z[rt].maxx = -inf;
        z[rt].sumw = z[rt].sumc = 0;
        return;
    }
    int m = (l + r) >> 1;
    if(c <= m)
        modify_del(lson, c);
    else
        modify_del(rson, c);
    update(rt);
}
int vis[mn], tot, s;
int main(){
    build(root);
    s = read();
    while(s != -1){
        if(s == 1){
            int x = read(), y = read();
            modify_add(root, y, x);
        }else if(s == 2){
            int maxx = z[1].maxx;
            modify_del(root, maxx);
        }else{
            int minn = z[1].minn;
            modify_del(root, minn);
        }
        s = read();
    }
    printf("%d %d\n", z[1].sumw, z[1].sumc);
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
    return 0;
}

```

---

## 作者：Log_x (赞：2)

一番波折后终于AC，在这里发一篇平衡树Treap的题解

主要是需要维护美观值以及花费的和

（1）插入操作， 遇到相同直接return

（2、3）删除最大最小，我的方法是暴力找到这个结点，然后上删除模板，似乎写得有点麻烦（另外认真看清题目，不要把2、3搞反了）

（4）询问，直接输出根节点的维护值

不知道有没有点小题大做，但至少比较快……












```cpp
//mon[]是结点花费，vis[]是结点美观值
//cop[]是结点及以下花费总和，sum[]是结点及以下美观值总和 
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 1e6 + 5;
int lc[N], rc[N], pos[N], vis[N], mon[N], sum[N], cop[N];
int x, rt, T, k;
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void Push(const int x) //维护 
{
    sum[x] = sum[lc[x]] + sum[rc[x]] + vis[x];
    cop[x] = cop[lc[x]] + cop[rc[x]] + mon[x];
}
inline void Zig(int &x) 
{
    int y = lc[x];
    lc[x] = rc[y], rc[y] = x;
    Push(x); Push(y);
    x = y;    
}
inline void Zag(int &x)
{
    int y = rc[x];
    rc[x] = lc[y], lc[y] = x;
    Push(x); Push(y);
    x = y;
}
inline void Ins(int &x, const int mn, const int vi) //插入 
{
    if (!x)
    {
        mon[x = ++T] = mn, pos[x] = rand();
        vis[x] = sum[x] = vi, cop[x] = mn;
        return ;
    }
    if (mn == mon[x]) return ; //相同直接返回 
    else if (mn < mon[x])
    {
        Ins(lc[x], mn, vi);
        if (pos[lc[x]] < pos[x]) Zig(x);
    }
    else 
    {
        Ins(rc[x], mn, vi);
        if (pos[rc[x]] < pos[x]) Zag(x);
    }
    Push(x);
} 
inline void Del(int &x, const int mn, const int vi) //删除 
{
    if (mon[x] == mn)
    {
        if (!lc[x] || !rc[x]) x = lc[x] + rc[x];
        else if (pos[lc[x]] < pos[rc[x]]) Zig(x), Del(x, mn, vi);
         else Zag(x), Del(x, mn, vi); 
        return ;
    }
    sum[x] -= vi; cop[x] -= mn;
    if (mon[x] > mn) Del(lc[x], mn, vi);
     else Del(rc[x], mn, vi);
}
inline int find(const int F) //暴力找结点 
{
    int x = rt;
    if (F) {while (lc[x]) x = lc[x];}
     else {while (rc[x]) x = rc[x];}
    return x; 
}
int main()
{
    while (~scanf("%d", &k))
    {
        switch(k)
        {
            case 1: x = get(); Ins(rt, get(), x); break;
            case 2: x = find(0); Del(rt, mon[x], vis[x]); break;
            case 3: x = find(1); Del(rt, mon[x], vis[x]); break;
            case -1: put(sum[rt]), putchar(' ');
                     put(cop[rt]), putchar('\n'); break;
        }
    }
    return 0;
}

```

---

## 作者：Garen (赞：1)

## splay模板题，细节挺多。

---

这道题要让我们维护权值信息，马上想到了splay。

让我们维护的操作有：单点添加、删除最小值和删除最大值，都是splay模板的经典操作。

很快地把模板敲出来了之后写程序却**WA和TLE了**。。。

### 原因1：你少了细节：

- 操作3和2的顺序颠倒了！

- 操作时没有花就跳过删除操作！

如果不考虑这个你的程序会死得很难看。

### 原因2：你对splay各函数的作用混淆了：

其中**下标和节点值不可混淆，否则WA**。

在我的代码中总共使用了8个splay的函数。

我对其中的每个操作都打上了注释，这样才能避免出错！

### 代码

```cpp
#include<cstdio>
using namespace std;
const int maxn = 100005, INF = 19260817;
struct Splay
{
	int ch[2], fa, val, val2;
} s[maxn];
int root, tot;
long long sum, sum2;
int identify(int x)//x是下标
{
	return s[s[x].fa].ch[1] == x;
}
void connect(int son, int fa, int k)//son和fa都是下标
{
	s[son].fa = fa;
	s[fa].ch[k] = son;
}
void rotate(int x)//x是下标
{
	int y = s[x].fa;
	int z = s[y].fa;
	int yk = identify(x);
	int zk = identify(y);
	int b = s[x].ch[yk ^ 1];
	connect(b, y, yk);
	connect(y, x, yk ^ 1);
	connect(x, z, zk);
}
void splay(int x, int goal)//x和goal都是下标
{
	while(s[x].fa != goal)
	{
		int y = s[x].fa;
		int z = s[y].fa;
		if(z != goal) identify(x) == identify(y) ? rotate(y) : rotate(x);
		rotate(x);
	}
	if(goal == 0) root = x;
}
void insert(int w, int c)
{
	int now = root, fa = 0;
	while(now && s[now].val != c)
	{
		fa = now;
		now = s[now].ch[c > s[now].val];
	}
	if(now == 0)
	{
		now = ++tot;
		s[now].ch[0] = s[now].ch[1] = 0;
		s[now].fa = fa;
		if(fa) s[fa].ch[c > s[fa].val] = now;
		s[now].val = c; s[now].val2 = w;
		sum += c; sum2 += w;//总和要在这里面加
	}
	splay(now, 0);
}
void find(int x)//找到val == x的点并splay到根 
{
	int now = root;
	if(now == 0) return;
	while(s[now].ch[x > s[now].val] && s[now].val != x) now = s[now].ch[x > s[now].val];
	splay(now, 0);
}
int next(int x, int k)//找到val == x的点的前驱或后继 
{
	find(x);
	int now = root;
	if(!k && x > s[now].val) return now;
	if(k && x < s[now].val) return now;
	now = s[now].ch[k];
	while(s[now].ch[k ^ 1]) now = s[now].ch[k ^ 1];
	return now;
}
void Delete(int x)//删除val == x的节点 
{
	int pre = next(x, 0), post = next(x, 1);
	splay(pre, 0); splay(post, pre);
	int del = s[post].ch[0];
	sum -= s[del].val;
	sum2 -= s[del].val2;
	s[post].ch[0] = 0;
}
int read()
{
	int ans = 0, s = 1;
	char ch = getchar();
	while(ch > '9' || ch < '0')
	{
		if(ch == '-') s = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		ans = ans * 10 + ch - '0';
		ch = getchar();
	}
	return s * ans;
}
int main()
{
	insert(0, -INF); insert(0, INF);
	int opt, w, c;
	while(2333)
	{
		opt = read();
		if(opt == -1) break;
		if(opt == 1)
		{
			w = read(), c = read();
			insert(w, c);
		}
		else if(opt == 2)
		{
			int del = next(INF, 0);//忽略
			if(s[del].val != -INF) Delete(s[del].val);
		}
		else if(opt == 3)
		{
			int del = next(-INF, 1);//忽略
			if(s[del].val != INF) Delete(s[del].val);
		}
	}
	printf("%lld %lld\n", sum2, sum);
	return 0;
}
```

---

## 作者：judgejudge (赞：1)

# 平衡二叉树+记忆化版剪枝
这道题其实就是三个操作：**加入数，删除最便宜，删除最贵**。

那么我们可以构造一个**平衡二叉树**，用于储存。

什么是平衡二叉树？？

根据我个人的理解，其实就是近似于一个区间[0,100001]，之后进行不断地二分查找，知道发现区间的左右相等为止，在这个节点上记录一次。

例如放入8：
| l | r  |
| -----------: | -----------: |
| 1| 100 |
| 1 | 50 |
| 1 | 25 |
| 1 | 12 |
| 7 | 12 |
| 7 | 9 |
|7  | 8 |
| 8 | 8 |
这种以区间二分搜索的树形结构，我们认为是平衡二叉树。相对于普通二叉树来说，这棵树的深度差不大，所以在面对极端数据时，平衡二叉树比普通二叉树的稳定性强很多，更平衡。

那么我们就可以用价格为放入值，来构造一棵平衡树。
```cpp
inline int inst(ll k,ll c){//k代表价格，c代表美丽值
	ll ll=l,rr=r,mid,p=1;
	while(ll<rr){//开始二分
		mid=(ll+rr)/2;//取中间值
		if(k<=mid){//如果在左子树
			if(a[p].lf==0){//并且当前位置的左子树为空
				an++;a[p].lf=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;//新拓展一点
			}
			p=a[p].lf;rr=mid;//遍历左子树
		}
		else{
			if(a[p].rt==0){//如果在右子树
				an++;
				a[p].rt=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;//新拓展一点
			}
			p=a[p].rt;ll=mid+1;//遍历右子树
		}
	
	if(a[p].data==0){//注意：因为遇到价格重复的不能放入
    //所以只存在没有或只有一个
		a[p].data++;
	    sum++;
	    sum1+=k;//价格相加
	    sum2+=c;//美丽值相加
	    a[p].q=c;//记录
	}
}

```
删除最便宜或最贵的，我们只需要拼命遍历左子树或右子树即可，并且删除价格和美丽值。

最后输出剩下的价格和美丽值就可以了。

算法是没有问题，但是由于耗时太大，只能拿40分
![](https://cdn.luogu.com.cn/upload/pic/73622.png )
因此我们就要想办法来优化。

我们知道，可以在每次放入数的时候，在走过的每一条路上**做一个记号**，可以在删除数时用来**判断这下面还有没有存数**，如果有存数就继续查找，没有直接跳出程序。

但还有一个问题：**删除数后怎么处理原先做的记号？**

### 删掉呗！
我们在删除过程中寻找记号时，顺便把记号抹掉，这样等到下次来查找时不会混淆。

奉上耗时许久的AC代码：
```cpp
#include <iostream>
#include <stdlib.h>
#include <cstdio>
using namespace std;
typedef long long ll;
struct node{
	ll lf,rt,data,q,num;//num表示是否有数
}a[10000001];
ll l=0,r=1000001,an=1,sum=0;
bool boo=0;
ll sum1=0,sum2=0;
int read(ll &x){//日常读入优化
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
inline int inst(ll k,ll c){
	ll ll=l,rr=r,mid,p=1;
	while(ll<rr){
		mid=(ll+rr)/2;
		a[p].num++;//标志这下面有存数
		if(k<=mid){
			if(a[p].lf==0){
				an++;a[p].lf=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;
			}
			p=a[p].lf;rr=mid;
		}
		else{
			if(a[p].rt==0){
				an++;
				a[p].rt=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;
			}
			p=a[p].rt;ll=mid+1;
		}
	}
	a[p].num++;//记住最后在叶子上时也要记录一次！
	if(a[p].data==0){
		a[p].data++;
	    sum++;
	    sum1+=k;
	    sum2+=c;
	    a[p].q=c;
	}
}
inline int prt1(ll p,ll l,ll r){
	ll i;
	if(boo==true&&a[p].num>0){//用于判断这个根节点下面是否存数
		a[p].num--;//顺便把记号抹去
		if(p>0){
			if(l==r&&a[p].data>0){
			    a[p].data--,boo=false;
			    sum1-=l;sum2-=a[p].q;
			}
			else{
				ll mid=(l+r)/2;
				prt1(a[p].lf,l,mid);//玩命找左子树
				prt1(a[p].rt,mid+1,r);
			}
		}
	}
}
inline int prt2(ll p,ll l,ll r){
	ll i;
	if(boo==true&&a[p].num>0){//同理
		a[p].num--;//同理
		if(p>0){
			if(l==r&&a[p].data>0){
			    a[p].data--,boo=false;
			    sum1-=l;sum2-=a[p].q;
			}
			else{
				ll mid=(l+r)/2;
				prt2(a[p].rt,mid+1,r);//玩命找右子树
				prt2(a[p].lf,l,mid);
			}
		}
	}
}
int main(){
	ll i,j,k,n;
	while(read(n)){
		if(n==-1)break;
		if(n==1){
			ll w,c;
			scanf("%lld %lld",&w,&c);
			inst(c,w);
		}
		if(n==3&&sum>0){
			boo=true;//bool表示当前是否找到极端值，找到立刻退出
			prt1(1,l,r);
			sum--;
		}
		if(n==2&&sum>0){
			boo=true;
			prt2(1,l,r);
			sum--;
		}
	}
	printf("%lld %lld",sum2,sum1);
	return 0;
}
```
加了这个的速度要优于原先代码30倍左右。~~我好像搞成堆了~~
![](https://cdn.luogu.com.cn/upload/pic/73625.png )


---

## 作者：Adove (赞：1)

### 思路：zkw权值线段树

你可能听过zkw线段树，可能听过权值线段树，但你听过zkw权值线段树吗qwq？

我们知道zkw线段树是一种满二叉树，但是让它像二叉搜索树一样按照k<<1递归求解有些困难，为了解决这个问题，我们将MAXN开到**2的整数次幂-1**，同时这也方便了我们最后的查询。

然后就是愉快的单点修改与递归删除啦

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=(1<<17)-1;

bool tree[MAXN+1<<1];
struct rpg{
    int p,x,y,id;
    int rey;
    bool fl;
}a[MAXN];

bool cmp1(rpg a,rpg b){
	if(a.p==1&&b.p==1&&a.y==b.y) return a.id<b.id; 
    if(a.p==1&&b.p==1) return a.y<b.y;
    return a.p<b.p;
}bool cmp2(rpg a,rpg b){
    return a.id<b.id;
}

void dfs1(int k){
    if(k>MAXN){
        tree[k]=0;
        return;
    }if(tree[k<<1|1]) dfs1(k<<1|1);
    else if(tree[k<<1]) dfs1(k<<1);
    tree[k]=tree[k<<1]|tree[k<<1|1];
    return;
}

void dfs2(int k){
    if(k>MAXN){
        tree[k]=0;
        return;
    }if(tree[k<<1]) dfs2(k<<1);
    else if(tree[k<<1|1]) dfs2(k<<1|1);
    tree[k]=tree[k<<1]|tree[k<<1|1];
    return;
}

void init(){
    while(scanf("%d",&a[++a[0].p].p)==1&&a[a[0].p].p>0){
        a[a[0].p].id=a[0].p;
        if(a[a[0].p].p==1) scanf("%d%d",&a[a[0].p].x,&a[a[0].p].y);
    }sort(a+1,a+a[0].p,cmp1);
    a[1].rey=1;
    for(int i=2;a[i].p==1;++i){
        if(a[i].y==a[i-1].y) a[i].rey=a[i-1].rey;
        else a[i].rey=a[i-1].rey+1;
    }sort(a+1,a+a[0].p,cmp2);
    return;
}

void solve(){
    for(int i=1;i<a[0].p;++i){
        if(a[i].p==1){
        	if(tree[MAXN+a[i].rey]){
        		a[i].fl=1;
        		continue;
			}for(int j=MAXN+a[i].rey;j;j>>=1) tree[j]=1;
        }else if(a[i].p==2) dfs1(1);
        else dfs2(1);
    }return;
}

void write(){
    long long sum1=0,sum2=0;
    sort(a+1,a+a[0].p,cmp1);
    for(int i=1;a[i].p==1;++i){
        if(tree[MAXN+a[i].rey]&&(!a[i].fl&&(a[i+1].rey!=a[i].rey||a[i+1].fl))){
            sum1+=a[i].x;
            sum2+=a[i].y;
        }
    }printf("%lld %lld\n",sum1,sum2);
    return;
}

int main(){
    init();
    solve();
    write();
    return 0;
}
```

---

## 作者：Mychael (赞：1)

**这不是模拟么**


为什么都用平衡树，线段树这么高级的东西。。

我这么蒟蒻无地自容。


于是我摸摸掏出了优先队列【不就是要删最大最小么，为何不用优先队列，多简单】

于是我开了两个优先队列，一个递增一个递减，每次模拟添加、删除就好了


如果你要问，若在递增中把最小的删了，那递减的队列中怎么把它删掉？

**不用删！**反正每个价格的物品只能有一个，用一个数组标记有没有就好了，顺便用这个数组储存每个价格对应的美丽值

这样就保证了唯一性，绝不会有重复的物品

在每次删除操作时，先清空队列前端已经不存在的物品，嗯没毛病。。


真的是模拟：





```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn=1000005,INF=2000000000;
int totb=0,totm=0,v[maxn];  //tot储存答案,v是价格对美丽值得映射,没有的时候为0
priority_queue<int> ql;          //递减队列
priority_queue<int,vector<int>,greater<int> > qs;//递增序列
int read()  //读入优化
{
    int out=0,flag=1;
    char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out*flag;
}
int main()
{
    fill(v,v+maxn,0);
    int cmd,w,c;
    while(true)
    {
        cmd=read();
        if(cmd==1)
        {
            w=read();
            c=read();
            if(!v[c]){totb+=w;totm+=c;v[c]=w;ql.push(c);qs.push(c);}
        }
        else if(cmd==2)
        {
            while(!ql.empty()&&!v[ql.top()]) ql.pop(); //已被删就忽略掉，下同
            if(!ql.empty()) {c=ql.top();totb-=v[c];totm-=c;v[c]=0;ql.pop();}
        }
        else if(cmd==3)
        {
            while(!qs.empty()&&!v[qs.top()]) qs.pop();
            if(!qs.empty()) {c=qs.top();totb-=v[c];totm-=c;v[c]=0;qs.pop();}
        }
        else break;
    }
    cout<<totb<<' '<<totm<<endl;    //如此简单
    return 0;
}

```

---

## 作者：巨型方块 (赞：1)

线段树，啦啦啦啦啦啦啦

加点么直接加好了，读入一个加一个；

删直接把那个点变到初始化；

每一个点维护一个max和min



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define Ll long long
using namespace std;
struct tree{
    Ll xx,yy,mi,ma,mmi,mma;
}T[100000*8+1];
struct flower{
    Ll x,y;
}f[100001];
bool money[1000001];
Ll n,m,x,y,z,ll,ans,p;
void maketree(int x,int y,int num){
    T[num].xx=x;T[num].yy=y;T[num].ma=-1e9;T[num].mi=1e9;
    if(x==y)return;
    int mid=(x+y)>>1;
    maketree(x,mid  ,num+num  );
    maketree(mid+1,y,num+num+1);
}
void pluss(int x,int num){
    if(f[x].y>T[num].ma){T[num].ma=f[x].y;T[num].mma=x;}                                                                           
    if(f[x].y<T[num].mi){T[num].mi=f[x].y,T[num].mmi=x;}
    if(T[num].xx==T[num].yy)return;
    num=num<<1;
    if(x<=T[num  ].yy)pluss(x,num  );
    if(x>=T[num+1].xx)pluss(x,num+1);
}
void dec(int x,int num){
    T[num].ma=-1e9;T[num].mi=1e9;
    if(T[num].xx==T[num].yy)return;
    num=num<<1;
    if(x<=T[num  ].yy)dec(x,num  );
    if(x>=T[num+1].xx)dec(x,num+1);
    int k=num>>1;
    if(T[num  ].ma>T[k].ma){T[k].ma=T[num  ].ma;T[k].mma=T[num  ].mma;}
    if(T[num+1].ma>T[k].ma){T[k].ma=T[num+1].ma;T[k].mma=T[num+1].mma;}        
    if(T[num  ].mi<T[k].mi){T[k].mi=T[num  ].mi;T[k].mmi=T[num  ].mmi;}
    if(T[num+1].mi<T[k].mi){T[k].mi=T[num+1].mi;T[k].mmi=T[num+1].mmi;}    
}
int main()
{
    maketree(1,1e5,1);
    while(cin>>x){
        if(x==-1)break;
        if(x==1){
            cin>>x>>y;
            if(money[y])continue;
            money[y]=1;
            ll++;p++;
            f[ll].x=x;
            f[ll].y=y;
            pluss(ll,1);
        }else if(x==2&&p){
            x=T[1].mma;
            money[f[x].y]=0;
            f[x].x=f[x].y=0;
            dec(x,1);p--;
        }else if(x==3&&p){
            x=T[1].mmi;
            money[f[x].y]=0;
            f[x].x=f[x].y=0;
            dec(x,1);p--;
        }
    }
    for(int i=1;i<=ll;i++)ans+=f[i].x;printf("%d ",ans);ans=0;
    for(int i=1;i<=ll;i++)ans+=f[i].y;printf("%d",ans);
}

```

---

## 作者：zhangbo1000 (赞：0)

update 2024.3.21 重新提交以去除旧博客分类。

看了一圈题解居然没有~~伟大的~~树状数组的，那么我来写一个。

基础的树状数组操作不再赘述，建议去看模板题题解，这里主要讲下怎么用树状数组水平衡树。

（题目不强制在线，可以离散化，下面我默认值域大小与操作数同阶。）

首先我们假设 $c_i$ 表示 $i$ 的出现次数，那么很显然 $(\sum^{n-1}_{i=1}c_i)+1$ 就是数 $n$ 的排名，很明显，用树状数组维护 $c$，查询排名就搞定了。

下面是重头戏，也是很多题解~~图片炸了~~没讲清楚的地方——查询排名为某值的数。

首先 $O(\log^2n)$ 的算法很好想，二分即可，但实际我们有方法将复杂度降低到 $O(\log n)$。

想一想，为什么二分需要 $O(\log^2n)$，因为求每个数排名都需要 $O(\log n)$，而**这一点是因为二分过程中每次查询数的变化与树状数组的性质没有必然联系**。我们需要一种新的方法 $O(\log n)$（不包括对每个答案的验证） 确定答案的方法——倍增。

仔细想一下，一个数 $n$ 的二进制下的位数明显也是 $O(\log n)$ 的，所以我们可以依次尝试将每个 $2$ 的幂加入到答案中，设当前答案为 $ans$，加入的数为 $2^i$，那么显然，如果我们**倒序**枚举 $i$，就能保证 $\operatorname{lowbit}(ans+2^i)=2^i$，这样我们就能根据树状数组的定义 $O(1)$ 判断和更新答案，总复杂度就降低到了 $O(\log n)$。**参考**代码：

```cpp
#define N 1000000
int c[N+1];
int findrank(const int& k){
	static const int MAX=log2(N)+1;
	static int ans,cnt,i;
	for(i=MAX,ans=cnt=0;i>=0;i--){
		ans+=1<<i;
		if(ans>N||c[ans]+cnt>=k)ans-=1<<i;
		else cnt+=c[ans];
	}
	return ans+1;
}
```
~~是不是比二分还短。~~

回到这个题上，操作 $1$ 用树状数组维护，再开个数组保存每个价格的花的美丽度，操作 $2$ 维护下当前花的支数 $n$，再删除 $\operatorname{findrank}(n)$ 即可，操作 $3$ 删除 $\operatorname{findrank}(1)$ 即可，最后答案只需开两个变量存储花的总价值和总价格即可。


题的完整代码就不贴了，一点注释没加码风还不好。（想要看的跳转[这里](https://www.luogu.com.cn/paste/9naicg0u)。）

[广告](https://www.luogu.com.cn/blog/0x114514/)。

---

## 作者：peterwuyihong (赞：0)

## 平衡树？不存在的。
$ vector $是可以极简单地实现平衡树的。$ vector , yyds! $

具体可以参考一下我貌似没有发表出来的blog
[平 衡 树](https://www.luogu.com.cn/blog/wuyihong/solution-p3369-update)

### 进入正题
题意：维护一个序列。每次插入一个对$ (a,b) $，$ a $重复不插；删掉$ a $最小的对；删掉$ a $最大的对；以及最后计算$ \sum a $和$ \sum b $。
#### 插入
```cpp
void insert(pair<int,int>p) {
	if(used[p.first])return;//确保a不重复
	v.insert(lower_bound(v.begin(),v.end(),p),p);
    //↑在插入比元素小一点的位置插入
	used[p.first]++;
    //注意是++，used也一定要int，因为还有删除操作
}
```
#### 删除
```cpp
void del1() {//删首
	if(v.size())//不加会爆炸
		used[v.begin()->first]--,v.erase(v.begin());
        //used要先删，不然erase后没了
}
void del2() {//删尾
	if(v.size())//being without could cause explosion
		used[(--v.end())->first]--,v.erase(--v.end());
        //used should be deleted first,or after erasing it,it will disappear
}
```
#### 统计
```cpp
for(vector<pair<int,int> >::iterator it=v.begin(); it!=v.end(); it++)
		a+=it->first,b+=it->second;
        //迭代器写法，用0~v.size()-1也行
```
#### 补充C++性质
$ pair $元素：排序时先排第一元，再排第二元。用这个性质可以避免很多麻烦的$ struct $啊，$ operator $啊的写法。
## 代码
```cpp
#include<bits/stdc++.h>
#define maxn 100010
#define int long long
using namespace std;
template<class T>void read(T &__x) {
	__x=0;
	short __f=1;
	char __ch=getchar();
	while(__ch<'0'||__ch>'9') {
		if(__ch=='-')__f=-1;
		__ch=getchar();
	}
	while(__ch>='0'&&__ch<='9') {
		__x=(__x<<1)+(__x<<3)+(__ch^48);
		__ch=getchar();
	}
	__x*=__f;
}
int n,op,x,y;
int used[1000001];
vector<pair<int,int> >v;
void insert(pair<int,int>p) {
	if(used[p.first])return;
	v.insert(lower_bound(v.begin(),v.end(),p),p);
	used[p.first]++;
}
void del1() {
	if(v.size())
		used[v.begin()->first]--,v.erase(v.begin());
}
void del2() {
	if(v.size())
		used[(--v.end())->first]--,v.erase(--v.end());
}
int a,b;
signed main() {
#ifndef ONLINE_JUDGE//跟luogu上的julao们学的
	freopen("P2073_2.in","r",stdin);
#endif
	while(read(op),op!=-1) {
		if(op==1) {
			read(x),read(y);
			insert(make_pair(y,x));//first->钱,second->美丽值
		}
		if(op==2)del2();
		if(op==3)del1();
	}
	for(vector<pair<int,int> >::iterator it=v.begin(); it!=v.end(); it++)
		a+=it->first,b+=it->second;
	printf("%lld %lld",b,a);
}


```


---

## 作者：epiglottis (赞：0)

### 提供一种思路
~~因为我看不懂别人的~~
- 以**价格**的大小建线段树。
- 可以动态开点。 ~~好像没必要~~
- sum存放区间美丽值和。
- 删除就清零最左（右）有值的区间

看代码就可以明白
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid ((l+r)>>1)
using namespace std;
inline int re(){
	int x=0;bool f=1;char q=getchar();
   while(q<'0'||q>'9'){if(q=='-')f=0;q=getchar();}
	while(q>='0'&&q<='9'){x=x*10+q-'0';q=getchar();}
   return f?x:-x;
}
const int N=1000001;
int sum[N<<2];//可以动态开点
inline void add(int rt,int l,int r,int x,int k){
	if(l==r){
		if(!sum[rt])
			sum[rt]=k;
		return;
	}
	if(x<=mid)
		add(ls,l,mid,x,k);
	else
		add(rs,mid+1,r,x,k);
	sum[rt]=sum[ls]+sum[rs];
}
inline void del_h(int rt,int l,int r){
	if(l==r){
		sum[rt]=0;
		return;
	}
	if(sum[rs])//右区间价格一定高
		del_h(rs,mid+1,r);
	else if(sum[ls])//防止没有点
		del_h(ls,l,mid);
	sum[rt]=sum[ls]+sum[rs];
}
inline void del_l(int rt,int l,int r){
	if(l==r){
		sum[rt]=0;
		return;
	}
	if(sum[ls])
		del_l(ls,l,mid);
	else if(sum[rs])
		del_l(rs,mid+1,r);
	sum[rt]=sum[ls]+sum[rs];
}
inline int query(int rt,int l,int r){
	//查询所有花价格和
	if(sum[rt]==0)
		return 0;
	if(l==r)
		return l;//是以价格的大小建线段树
	return query(ls,l,mid)+query(rs,mid+1,r);;
}
int main(){
	int type=re();
	while(type!=-1){
		if(type==1)
			add(1,1,N,re(),re());//这里会从先读入后面的，也就是..,c,w)
		else if(type==2)
			del_h(1,1,N);
		else if(type==3)
			del_l(1,1,N);
		type=re();
	}
   printf("%d %d",sum[1],query(1,1,N));
   return 0;
} 
```


---

## 作者：封禁用户 (赞：0)

## 其实这道题可以直接优先队列搞。
因为在花束中同一个价钱的花只会有一支，所以每个价钱都一一对应着一个价钱，就拿一个数组直接存就好。

两个堆，一个大根堆，一个小根堆。然后每次存的时候判断下有没重复。

对于删除操作，我们先把不在花束中的花pop掉(具体见代码)然后再删除。

思路简单，代码也很好理解。


------------
```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<cstdio>
#include<deque>
using namespace std;
const int N=4000006;
long long ans_val,ans_cost;
int f[N];
priority_queue<int>Qmax,Qmin;
void ADD(){
	int w,c;
	scanf("%d%d",&w,&c);
	if(f[c])return ;
	f[c]=w;
	ans_val+=w;
	ans_cost+=c;
	Qmax.push(c);
	Qmin.push(-c);
}
void dele_min(){
	while(!Qmin.empty()&&!f[-Qmin.top()])Qmin.pop();
	if(!Qmin.empty()){
		int u=-Qmin.top();
		ans_val-=f[u];
		ans_cost-=u;
		f[u]=0;
		Qmin.pop();
	}
}
void dele_max(){
	while(!Qmax.empty()&&!f[Qmax.top()])Qmax.pop();
	if(!Qmax.empty()){
		int u=Qmax.top();
		ans_val-=f[u];
		ans_cost-=u;
		f[u]=0;
		Qmax.pop();
	}
}
int main(){
	int x=0;
	while(1){
		scanf("%d",&x);
		if(x==-1)break;
		if(x==1)ADD();
		if(x==3)dele_min();
		if(x==2)dele_max();
	}
	cout<<ans_val<<" "<<ans_cost;
}
```


---

## 作者：tuo3288 (赞：0)

#### 本题中，需要使用线段树的地方并不是求和，而是确定价值最大（最小）的花的编号。

因为题中需要求的和是所有花的，所以只需要定义两个变量，插入花时对应相加，删除花时对应相减就行了。

首先，我们需要对每个插入的花进行标号。

但是我们发现，总是会有很多花被删除后留下了无用的空间。为了节省空间我们用一个队列记下被删除的花的编号，然后把它给下一个插入的花。

之后我们定义比较大小的方法：根据花的价值，将价值最大（最小）的编号放入线段树中。特别注意的是，空的单位以及被删除的花留下的空位是不能参与比较的。

之后就简单多了，需要的线段树的功能只有一个修改。再用STL里的map判重就行了。

代码如下：
```cpp
#include<cstdio>
#include<queue>
#include<map>
#define CH ch=getchar()
using namespace std;
typedef long long LL;
int X,W;char ch;
inline int read()
{
	X=1,W=0;
	CH;
	while(ch<'0'||ch>'9'){if(ch=='-')X=-1;CH;}
	while(ch<='9'&&ch>='0'){W=W*10+ch-48;CH;}
	return X*W;
}
struct node{
	int w,c;
}a[500001];
struct tree{
	int l,r;
	int ma,mi;
}tr[2000001]; 
queue <int> zh;
map <int,bool> mp;
LL sumw,sumc;
int max(int _,int _1)
{
	if(a[_].c==0)return _1;
	else if(a[_1].c==0)return _;
	else return a[_].c>a[_1].c?_:_1;
}
int min(int _,int _1)
{
	if(a[_].c==0)return _1;
	else if(a[_1].c==0)return _;
	else return a[_].c<a[_1].c?_:_1;
}
void build(int k)
{
	int mid=(tr[k].l+tr[k].r)>>1;
	tr[k<<1].l=tr[k].l;
	tr[k<<1|1].l=mid+1;
	tr[k<<1].r=mid;
	tr[k<<1|1].r=tr[k].r;
	if(tr[k<<1].l!=tr[k<<1].r)build(k<<1);
	if(tr[k<<1|1].l!=tr[k<<1|1].r)build(k<<1|1);
	return;
}
void change(int k,int g)
{
	if(tr[k].l==g&&tr[k].r==g){
		tr[k].ma=tr[k].mi=g;
		return;
	}
	if(g<=tr[k<<1].r)change(k<<1,g);
	else change(k<<1|1,g);
	tr[k].ma=max(tr[k<<1].ma,tr[k<<1|1].ma);
	tr[k].mi=min(tr[k<<1].mi,tr[k<<1|1].mi);
}
int main()
{
	int op=read(),cnt=0,b,c,d,v,num=0;
	tr[1].r=500000,tr[1].l=1;
	build(1);
	while(op!=-1){
		if(op==1){
			b=read(),c=read();
			if(mp[c]==true){
				op=read();
				continue;
			}
			mp[c]=true;
			if(zh.empty()==false)d=zh.front(),zh.pop();
			else d=++cnt;
			a[d].w=b,a[d].c=c;
			sumw+=(LL)b,sumc+=(LL)c;
			change(1,d);
			num++;
		}
		if(op==2){
			if(num==0){
				op=read();
				continue;
			}
			v=tr[1].ma;
			zh.push(v);
			mp[a[v].c]=false;
			sumw-=(LL)a[v].w;
			sumc-=(LL)a[v].c;
			a[v]=a[0];
			change(1,v);
			num--;
		}
		if(op==3){
			if(num==0){
				op=read();
				continue;
			}
			v=tr[1].mi;
			zh.push(v);
			mp[a[v].c]=false;
			sumw-=(LL)a[v].w;
			sumc-=(LL)a[v].c;
			a[v]=a[0];
			change(1,v);
			num--;
		}
		op=read();
	}
	printf("%lld %lld",sumw,sumc);
	return 0;
}
```

---

## 作者：Zechariah (赞：0)

平衡树板子题  
我用的是splay，这里只需要添加和删除操作就行了，在添加和删除中统计答案，每个节点记录两个值w和c，按c来slay  
注意题目说：如果加入的花朵价格已经与花束中已有花朵价格重复，则这一朵花不能加入花束。
```cpp
#include <bits/stdc++.h>
#define rg register
#define inl inline
typedef long long ll;
const int N = 1e5 + 10;
using namespace std;
namespace fast_IO {
	ll read()
	{
		rg ll num = 0;
		rg char ch;
		rg bool flag = false;
		while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r');
		if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48;
		while ((ch = getchar()) != ' '&&ch != '\n'&&ch != '\r'&&~ch)
			num = (num << 1) + (num << 3) + (ch ^ 48);
		if (flag)return -num; return num;
	}
	ll max(rg ll a, rg ll b) { if (a > b)return a; return b; }
	ll min(rg ll a, rg ll b) { if (a < b)return a; return b; }
	void write(rg long long x) { if (x < 0)putchar('-'), x = -x; if (x >= 10)write(x / 10); putchar(x % 10 ^ 48); }
};
int tree[N][2], fa[N], child[N][2], root, tot;
ll ans, ans2;
inl int _search(rg int x, rg int w)
{
	while (tree[x][0] != w)
	{
		if (w < tree[x][0])
			if (child[x][0])x = child[x][0];
			else break;
		else
			if (child[x][1])x = child[x][1];
			else break;
	}
	return x;
}
inl void _rotate(rg int x)
{
	rg int f = fa[x], gf = fa[f];
	child[gf][child[gf][1] == f] = x;
	fa[x] = gf;
	rg int w = x == child[f][1];
	child[f][w] = child[x][w ^ 1];
	fa[child[x][w ^ 1]] = f;
	child[x][w ^ 1] = f;
	fa[f] = x;
}
inl void splay(rg int x)
{
	while (fa[x])
	{
		rg int f = fa[x], gf = fa[f];
		if (gf)
			if ((child[gf][0] == f) ^ (child[f][0] == x))
				_rotate(x);
			else _rotate(f);
		_rotate(x);
	}
	root = x;
}
inl void _insert(rg int c, rg int w)
{
	if (!tot)
	{
		ans2 += tree[tot = root = 1][0] = c;
		ans += tree[1][1] = w; fa[1] = 0;
		return;
	}
	rg int k = _search(root, c), node;
	if (tree[k][0] == c)return;
	ans2 += tree[++tot][0] = c, ans += tree[tot][1] = w;
	fa[tot] = k; child[k][c > tree[k][0]] = tot;
	splay(k);
}
inl void _del(rg int x)
{
	ans2 -= tree[x][0], ans -= tree[x][1]; splay(x);
	if (child[x][0])
	{
		fa[child[x][0]] = 0;
		rg int k = _search(child[x][0], INT_MAX); splay(k);
		child[k][1] = child[x][1];
		fa[child[x][1]] = k;
		tree[x][0] = tree[x][1] = child[x][0] = child[x][1] = 0;
	}
	else
	{
		if (!(root = child[x][1]))tot = 0;
		tree[x][0] = tree[x][1] = fa[root] = child[x][1] = 0;
	}
}

int main()
{
	rg int opt;
	while (~(opt = fast_IO::read()))
		switch (opt)
		{
		case 1:_insert(fast_IO::read(), fast_IO::read()); break;
		case 2:_del(_search(root, INT_MAX)); break;
		case 3:_del(_search(root, INT_MIN)); break;
		}
	fast_IO::write(ans); putchar(' '); fast_IO::write(ans2);
	return 0;
}

```

---

## 作者：gogoduan (赞：0)

这其实不是严格意义上的题解

只是提醒大家一个本题大坑

看到很多人10分，wa9个点，这里提醒大家，题目先写的3操作，后写

的2操作，大家看看改善一下这个是不是可以10分—>满分

但是仍然要粘一下用STL的代码啊

priority_queue 和 set

里面有一小点注释

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAXN 100005
using namespace std;
bool vis[MAXN];
struct Node{
    int w,c,id;
    Node(int w=0,int c=0,int id=0):w(w),c(c),id(id){}
    bool operator < (const Node& n1) const{
        if(n1.c==c) return n1.id<id;
        return n1.c<c;
    }
};//pianyi
struct Node1{
    int w,c,id;
    Node1(int w=0,int c=0,int id=0):w(w),c(c),id(id){}
    bool operator < (const Node1& n1) const{
        if(n1.c==c) return n1.id<id;
        return n1.c>c;
    }
};//gui
priority_queue<Node> q1;
priority_queue<Node1> q2;
set<int> s;
ll answ;
ll ansc;
int cnt;
int main(){
    int opt;
    while(scanf("%d",&opt)){
        if(opt==-1) break;
        if(opt==1){
            int w,c;
            scanf("%d%d",&w,&c);
            if(s.count(c)) continue;
            else s.insert(c);
            cnt++;
            q1.push(Node(w,c,cnt));
            q2.push(Node1(w,c,cnt));
            vis[cnt]=1;
        }
        else if(opt==3){//shan pian yi
            while(!q1.empty()&&vis[q1.top().id]==0){
                q1.pop();
            }
            if(!q1.empty()){
                Node u=q1.top();
                q1.pop();
                s.erase(u.c);
                vis[u.id]=0;
            }
        }
        else{//shan gui
            while(!q2.empty()&&vis[q2.top().id]==0){
                q2.pop();
            }
            if(!q2.empty()){
                Node1 u=q2.top();
                q2.pop();
                s.erase(u.c);
                vis[u.id]=0;
            }
        }
    }
    while(!q1.empty()){
        Node u=q1.top();
        q1.pop();
        if(vis[u.id]==1){
            ansc+=u.c;
            answ+=u.w;
            vis[u.id]=0;
        }
    }
    printf("%lld %lld",answ,ansc);
    return 0;
}
```

---

## 作者：nansns (赞：0)

只有这些操作为什么要用平衡树呢？
  
直接用set即可。反向迭代器erase要转成正向迭代器有点麻烦，直接暴力erase ( find )

AC代码，开O2跑的飞快

```c
#include <iostream>
#include <cstdio>
#include <set>

using namespace std;

inline int R()
{
    char ch = getchar();
    int rt = 0;
    bool isn = false;
    for ( ; ch > '9' || ch < '0'; ch = getchar() )
        isn = ch == '-' ? true : isn;
    for ( ; ch <= '9' && ch >= '0'; ch = getchar() )
        rt = rt * 10 + ch - '0';
    return isn ? -rt : rt;
}

set<int> f;
int bt[1000003];
long long ans, cst;

int main ()
{
	for ( int op = R(); op != -1; op = R() )
	{
		if ( op == 1 )
		{
			int w = R(), c = R();
			if ( !bt[c] )
				bt[c] = w, f.insert ( c ), ans += w, cst += c;
			continue;
		}
		if ( op == 3 && !f.empty() )
		{
			ans -= bt[*f.begin()], cst -= *f.begin(), bt[*f.begin()] = 0;
			f.erase ( f.begin() );
			continue;
		}
		if ( op == 2 && !f.empty() )
		{
			ans -= bt[*f.rbegin()], cst -= *f.rbegin(), bt[*f.rbegin()] = 0;
			f.erase ( f.find ( *f.rbegin() ) );
			continue;
		}
	}
	printf ( "%lld %lld\n", ans, cst );
	return 0;
}
```

---

## 作者：never_see (赞：0)

为什么不考虑ZKW呢？

内存显然是可以存下的

以C（价格）为关键字建权值ZKW线段树

然后删的时候直接找最大最小

最后累加答案就可以了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

template< typename Type >inline void Read( Type &In ){
    In=0;char ch=getchar();Type f = 1;
    for( ;ch> '9'||ch< '0';ch=getchar() )if( ch=='-' )f = -1;
    for( ;ch>='0'&&ch<='9';ch=getchar() )In = In*10 + ch-'0';In *= f;
}

static const int MAXN = 1e6 +1;
static const int M    = 1048576;
typedef long long LL;

int Opt,W,C,Ct;LL T_c,T_w;
int d[3][MAXN<<2];//d[0]表示最小的价格 d[1]表示最大的价格 d[2]表示美丽值

void Mf( int x,int k ){
    x += M;if( d[2][x] )return;Ct++;
    d[0][x] = d[1][x] = x;d[2][x] = k;
    for( x>>=1;x;x>>=1 )
        d[0][x] = min( d[0][x<<1],d[0][x<<1|1] ),
        d[1][x] = max( d[1][x<<1],d[1][x<<1|1] );
}
int Qm(){
    int Res = 0;
    for( int s=M,t=M<<1;s^t^1;s>>=1,t>>=1 ){
        if( ~s&1 )Res = max( Res,d[1][s^1] );
        if(  t&1 )Res = max( Res,d[1][t^1] );
    }
    return Res;
}
int Qn(){
    int Res = 0x7fffffff;
    for( int s=M,t=M<<1;s^t^1;s>>=1,t>>=1 ){
        if( ~s&1 )Res = min( Res,d[0][s^1] );
        if(  t&1 )Res = min( Res,d[0][t^1] );
    }
    return Res;
}
void Del( int x ){
    d[0][x] = 0x7fffffff;
    d[1][x] = d[2][x] = 0;
    for( x>>=1;x;x>>=1 )
        d[0][x] = min( d[0][x<<1],d[0][x<<1|1] ),
        d[1][x] = max( d[1][x<<1],d[1][x<<1|1] );
}

int main(){
    
    memset( d[0],0x3f,sizeof d[0] );
    while( Opt!=-1 ){
        Read( Opt );
        switch( Opt ){
            case 1:Read( W );Read( C );Mf( C,W );break;
            case 2:if( Ct )Del( Qm() ),Ct--;break;
            case 3:if( Ct )Del( Qn() ),Ct--;break;
        }
    }
    for( int x=M+1;x<=M<<1;x++ )
        if( d[2][x] )T_w += d[2][x],T_c += x-M;//累加
    
    printf("%lld %lld\n",T_w,T_c);
    return 0;
}
```

对于这题用STL的人，我表示就这样把练手的题给浪费了


---

## 作者：lemon (赞：0)


```cpp
//暴力狂
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
int cnt=0;
int x;
bool flag=0;
bool xx[1000001]={0};
using namespace std;
struct node{
    int w,c;
}h[100010];
bool find(int l,int r,int xx)
{
    for(int i=l;i<=r;i++)
      if(h[i].c==xx)
        return 0;
    return 1;
    /*int mid=(l+r)/2;
    if(h[mid].c==xx)
      return 0;
    else if(h[mid].c<xx)
      find(mid+1,r,xx);
    else
      find(l,mid-1,xx);
    return 1;*/
}
int cmp2(const node a,const node b)
{
    return a.c>b.c;
}
int cmp1(const node a,const node b)//cong xiao dao da
{
    return a.c<b.c;
}
void ex()
{
    sort(h+1,h+cnt+1,cmp1);
    xx[h[cnt].c]=0;
    cnt--;
}
void cheap()
{
    sort(h+1,h+cnt+1,cmp2);
    xx[h[cnt].c]=0;
    cnt--;
}
int main()
{
    scanf("%d",&x);
    while(x!=-1)
    {
        if(x==1)
        {
            int a,b;
            scanf("%d%d",&a,&b);
            if(cnt==0)
            {
                xx[b]=1;
                cnt++;
                h[cnt].w=a;
                h[cnt].c=b;
            }
            else
            {
                //sort(h+1,h+cnt+1,cmp1);
                if(xx[b]==0)
```
cnt++,
```cpp
                    xx[b]=1,
                    h[cnt].w=a,
                    h[cnt].c=b;
            }
        }
        if(x==2)
          if(cnt>0)
            ex();
        if(x==3)
          if(cnt>0)
            cheap();
        scanf("%d",&x);
    }
    int ans1=0,ans2=0;
    for(int i=1;i<=cnt;i++)
        ans1+=h[i].w,
        ans2+=h[i].c;
    printf("%d %d",ans1,ans2);
    return 0;
}
```

---

## 作者：Jμdge (赞：0)

这道题的解法是真的多...

1. 优先队列水过(600~700ms)
2. STL堆飘过(600~700ms)
3. splay平衡树躺(不)过(巨坑)
4. 懒人treap(懒的打)(未知)


---

优先队列...两个队列,一个大根一个小根,用价格当关键值

再开个数组记录价格对应的花朵价值
```cpp
//by Judge(优先队列)
#include<iostream>
#include<cstdio>
#include<queue>
#define ll long long
#define fp freopen
using namespace std;
const int M=1e6+111;
const int inf=1e9+7;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x*f;
}
int opt; ll val,cos;
priority_queue<int,vector<int>,greater<int> > qmin;
priority_queue<int> qmax;
int v[M],w,c;
inline void insert(){
	w=read(); if(v[c=read()]) return ;
	qmin.push(c),qmax.push(c),v[c]=w,val+=w,cos+=c;
}
inline void delmax(){
	while(!qmax.empty() && !v[qmax.top()]) qmax.pop();
	if(!qmax.empty()) c=qmax.top(),w=v[c],val-=w,cos-=c,v[c]=0;
}
inline void delmin(){
	while(!qmin.empty() && !v[qmin.top()]) qmin.pop();
	if(!qmin.empty()) c=qmin.top(),w=v[c],val-=w,cos-=c,v[c]=0;
}
int main(){
	while((opt=read())!=-1)
		switch(opt){
			case 1: insert(); break;
			case 2: delmax(); break;
			case 3: delmin(); break;
		}
	printf("%lld %lld\n",val,cos);
	return 0;
}
```

一个堆,伪一下平衡树,一棵大的在左,一棵小的在左

最后遍历树直接输出

```cpp
//by Judge(set)
#include<iostream>
#include<cstdio>
#include<set>
#define ll long long
#define fp freopen
using namespace std;
const int M=1e6+111;
const int inf=1e9+7;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x*f;
}
struct f1{
	int w,c;
	friend bool operator <(const f1& a,const f1& b){ return a.c>b.c; }
};
struct f2{
	int w,c;
	friend bool operator <(const f2& a,const f2& b){ return a.c<b.c; }
};
int opt; ll val,cos;
set<f1> smax; set<f2> smin;
inline void insert(){
	int w=read(),c=read();
	smax.insert((f1){ w,c }), smin.insert((f2){ w,c });
}
inline void delmax(){
	int w=smax.begin()->w,c=smax.begin()->c; 
	smax.erase(*smax.begin()), smin.erase((f2){ w,c });
}
inline void delmin(){
	int w=smin.begin()->w,c=smin.begin()->c; 
	smin.erase(*smin.begin()), smax.erase((f1){ w,c });
}
int main(){
	while((opt=read())!=-1)
		switch(opt){
			case 1: insert(); break;
			case 2: delmax(); break;
			case 3: delmin(); break;
		}
	set<f1>::iterator i;
	for(i=smax.begin();i!=smax.end();++i)
		val+=i->w, cos+=i->c;
	printf("%lld %lld\n",val,cos);
	return 0;
}
```

感觉没什么问题,就是只过了5个点~~woc~~

有大佬的话帮忙看看行否？

```cpp
//by Judge(splay,WA了5个点,求救)
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int M=1e5+111;
const int inf=1e9+7;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x*f;
}
int root,num; ll tot1,tot2;
int f[M],ch[M][2],key[M],val[M];
inline int get(int x){ return x==ch[f[x]][1]; }
inline void rotate(int x){ int y=f[x],z=f[y],sx=get(x),sy=get(y),son=ch[x][sx^1]; f[son]=y,ch[y][sx]=son,f[y]=x,ch[x][sx^1]=y,f[x]=z,ch[z][sy]=x; }
inline void splay(int x,int to){ for(int fa=f[x];fa!=to;rotate(x),fa=f[x]) if(f[fa]!=to) rotate(get(x)==get(fa)?fa:x); if(!to) root=x; }
inline int find(int x,int k){
	int now=root; while(ch[now][x>key[now]] && key[now]!=x) now=ch[now][x>key[now]]; 
	splay(now,0),now=ch[now][k],k^=1; while(ch[now][k]) now=ch[now][k]; return now;
}
inline void insert(int w,int c){
	int now=root,fa=0; while(now && key[now]!=c) fa=now,now=ch[now][c>key[now]];
	if(!now){ ch[++num][0]=ch[num][1]=0,key[num]=c,val[num]=w,f[num]=fa,tot1+=w,tot2+=c; if(fa) ch[fa][c>key[fa]]=num; } splay(num,0);
}
inline void delt(int x){ int pre=find(x,0),post=find(x,1); splay(pre,0), splay(post,pre),x=ch[post][0],tot1-=val[x],tot2-=key[x],ch[post][0]=0; }
int opt,w,c;
int main(){
	insert(0,-inf),insert(0,inf);
	while((opt=read())!=-1)
		switch(opt){
			case 1: w=read(),c=read(),insert(w,c); break;
			case 2: c=key[find(inf,0)]; if(c!=-inf) delt(c); break;
			case 3: c=key[find(-inf,1)]; if(c!=inf) delt(c); break;
		}
	printf("%lld %lld\n",tot1,tot2); return 0;
}
```


~~水完一篇题解~~

---


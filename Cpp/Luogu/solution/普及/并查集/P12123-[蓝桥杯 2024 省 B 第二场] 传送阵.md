# [蓝桥杯 2024 省 B 第二场] 传送阵

## 题目描述

小蓝在环球旅行时来到了一座古代遗迹，里面并排放置了 $n$ 个传送阵，进入第 $i$ 个传送阵会被传送到第 $a_i$ 个传送阵前，并且可以随时选择退出或者继续进入当前传送阵。

小蓝为了探寻传送阵中的宝物，需要选择一个传送阵进入，然后连续进入之后的传送阵。小蓝希望尽可能多地进入传送门以便搜索宝物，同时他可以使用一次魔法，从某个传送阵 $j$ 走到相邻的（第 $j - 1$ 或第 $j + 1$ 个）传送阵，请问小蓝最多能到达多少个不同的传送阵？一个传送阵可多次进入，但在计算答案时只算一个。

## 说明/提示

### 样例说明

小蓝的路径可以是：$1 \to 2 \to 3 \to 5$。其中 $2 \to 3$ 使用魔法。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 1000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$，且 $a$ 是 $1$ 至 $n$ 的一个排列。

## 样例 #1

### 输入

```
5
2 1 5 4 3```

### 输出

```
4```

# 题解

## 作者：Deakin (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P12123)
### 前言
本蒟蒻是初一学生，第一篇题解，我会尽可能用通俗易懂的语言来讲。
求通过 QAQ。

# 思路
> 第 $i$ 个传送门会传送到第 $a_i$ 个传送门。

根据题目对传送门的解释，我们发现这样就会形成一个循环（即经过一定次数的传送后会回到原点）的一条路径，这里统称为“环”。
（以例题来说，五个传送门 `2, 1, 5, 4, 3` 可以形成三个环：`1→2`、`3→5`、`4`）。
**当进入到某一个环中，则可以到这个环中的任意一个传送门，且不用魔法。**

> 同时他可以使用一次魔法，从某个传送阵 $j$ 走到相邻的（第 $j−1$ 或第 $j+1$ 个）传送阵。

其实本质上来说：从传送阵 $j$ 走到第 $j-1$ 个传送阵就相当于从第 $j-1$ 个传送阵走到传送阵 $j$。

所以，**我们只需要从第 $1$ 个传送阵对应的环遍历到第 $n$ 个传送阵对应的环中**找到相邻且不为同一个环的两个环和最多的传送阵数量。

到这里题目意思就很明确了，找出所有的独立环，并统计每个环的大小。找到传送门数量最多的两个**相邻且不同**的环。并输出这两个环中传送门数量之和。（注意有个坑：**可能只有一个环**）。
‌
# 算法
### 思路实现
例题：
```cpp
5
2,1,5,4,3
```
按照思路，先找出所有独立环，并统计大小。

## 预处理环结构
### 分析
|数字|环节      | 节点数  |
|-----|----------|----------|
| $2$ | $2→1→$ | $2$      |
| $1$ | $1→2→$ | $2$      |
| $5$ | $5→3→$ | $2$      |
| $4$ | $4→$    | $1$      |
| $3$ | $3→5→$ | $2$      |

这里数字 $2$ 和数字 $1$ 在同一个环中，环大小也一样，却分别找了两次对应环。
很明显复杂了，改为直接继承能降低时间复杂度。
|数字|环节      |编号|   节点数  |
|-----|----------|-----|------------|
| $2$ | $2→1→$ | $1$ | $2$        |
| $1$ | $1→2→$ | $1$ |同 $1$      |
| $5$ | $5→3→$ | $3$ | $2$        |
| $4$ | $4→$    | $4$ | $1$        |
| $3$ | $3→5→$ | $3$ |同 $3$      |

继承的条件：在之前的某个环中有出现过。用数组 $id$ 的值的变化来表示有无出现过（出现过对 $id$ 做标记）。

判断继承：找对应环时对环中的数的 $id$ 进行处理。当处理过的数要找对应环时，找处理它 $id$ 的环的 $size$。

### 代码
先建立两个数组，帮助我们快速处理环结构。
```cpp
int id[1000001];//id[]数组‌：标记每个节点所属的环编号(索引)。
‌int size[1000001];//size[]数组‌：记录每个环的节点数量。
```

#### 找对应环
**方法：**
模拟传送，标记每个节点的所属编号和环节点数。

**模拟传送：**
遍历每个节点，若未被处理过，则通过模拟传送过程 `i = a[i]` 找到整个环，并标记其 $id$ 和计算 $size‌$。
```cpp
int id[1000001]={0};//环的编号
int size[1000001]={0};//每个数对应环中传送阵的数量
//预处理每个环的id和size（类并查集）
for(int i=1;i<=n;i++){
  //如果i已经被处理过，直接取对应环的size
  if(id[i]!=0)size[i]=size[id[i]];
  else {
  int x=i;//环起点
  do{
      if(id[x]==0)id[x]=i;//标记环id
      size[i]++;//增加环的大小
      x=a[x];//模拟传送
    }while(x!=i);//当回到起点时结束循环
  }
}
```

## 求相邻环最大值
按照思路，找到传送门数量最多的两个**相邻且不同**的环。

继续以例题来说，先将预处理过的不同下标的环分开（比较直观）。

|下标| 编号     |  节点数  |
|-----|----------|------------|
| $1$ | $1$      | $2$        |
| $2$ |同 $id[1]$|同 $size[1]$|
| $3$ | $3$      | $2$        |
| $4$ | $4$      | $1$        |
| $5$ |同 $id[3]$|同 $size[3]$|

$id$ 不同肯定就是不同环，相邻且不同的环就相当于**下标相邻值不同**的两个环。（没有就找单个环最大）。

例题中有：$id[2]$ 和 $id[3]$，$id[3]$ 和 $id[4]$（或 $id[4]$ 和 $id[5]$）。
最多的就是 $id[2]$ 和 $id[3]$，所以输出：$4$。

### 代码
遍历所有相邻的环并计算这两个环中传送门数量之和（可能只有一个环）。

**<相邻环求和>：**
遍历每个节点 $i$，检查其与下一节点 $i+1$ 是否属于不同环：
若属于不同环（即 $id$ 不同），用魔法后的传送门数为两环的 $size$ 之和。

记录所有可能的和结果中的**最大值**‌。
```cpp
int max=0;
for(int i=1;i<=n;i++){
  int m=size[id[i]];//当前i所在环的大小
  //如果i和i+1属于不同的环，计算合并后的总大小
  if(id[i]!=id[i+1])m+=size[id[i+1]];//使用魔法
  if(m>max)max=m;//计算最大值
}
```

# 完整代码
接下来看完整代码。
```cpp
#include<iostream>
using namespace std;
int a[1000001];
int id[1000001]/*环的编号*/,size[1000001]/*每个数对应环中传送阵的数量*/;
int main(){
    int n,max=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    //预处理每个环的id和size（类并查集）
    for(int i=1;i<=n;i++){
        if(id[i]!=0)size[i]=size[id[i]];//如果i已经被处理过，直接取对应环的size
        else {
            int x=i;//环起点
            do{
                if(id[x]==0)id[x]=i;//标记环id
                size[i]++;//增加环的大小
                x=a[x];//模拟传送
            }while(x!=i);//当回到起点时结束循环
        }
    }
    for(int i=1;i<=n;i++){
        int m=size[id[i]];//当前i所在环的大小
        if(id[i]!=id[i+1])m+=size[id[i+1]];//如果i和i+1属于不同的环，计算合并后的总大小
        if(m>max)max=m;//计算最大值
    }
    printf("%d",max);
    return 0;
}
```

# 总结
~~我应该是最优题解吧~~（^w^）求赞。
## 复杂度分析
时间复杂度‌：$O(n)$。预处理和遍历均为线性操作。

空间复杂度‌：$O(n)$。需存储 $id$ 和 $size$ 数组。

代码复杂度：该算法通过‌并查集思想‌快速标记环结构，再通过遍历相邻节点尝试合并环，最终找到最大可能的环规模。代码简洁高效。

## 正确性分析
[**评测记录**](https://www.luogu.com.cn/record/214203355)

‌
‌环的标记‌：
预处理时，每个环的起点被设为**唯一** $id$，环内所有节点的 $id$ 指向该起点，确保环的正确划分。

‌合并逻辑：遍历所有相邻节点，若属于不同环则合并，**覆盖所有可能**的魔法使用位置。

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

由于 $a$ 数组是一个 $1$ 到 $n$ 的一个排列，那么形成的一定会构成几个点的循环，或者是几个单独的点。

从任意点开始，如果能进入一个循环，一定可以将整个循环的宝藏都拿走，因为不限进入传送门的次数。

那么，我们可以用**并查集**来维护点与点之间的关系，以及一个小团体里头点的数量。

由于我们可以使用一次从 $j$ 跳到 $j - 1$ 或 $j + 1$ 的位置，那么我们可以枚举所有的 $j, j+1$（$j$ 的祖宗不等于 $j+1$ 的祖宗），计算两个集合大小之和取最大即可。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1e6 + 10;

int n;
int p[N], cnt[N];

int find(int x)
{
    if (x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; ++ i )
        p[i] = i, cnt[i] = 1;
    
    for (int i = 1; i <= n; ++ i )
    {
        int x;
        cin >> x;
        int a = find(i), b = find(x);
        if (a == b)
            continue;
        cnt[a] += cnt[b];
        p[b] = a;
    }
    
    int res = 1;
    for (int i = 1; i < n; ++ i )
    {
        int a = find(i), b = find(i + 1);
        if (a == b)
            res = max(res, cnt[a]);
        else
            res = max(res, cnt[a] + cnt[b]);
    }
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：Circle_Table (赞：3)

~~刚学并查集来试试手~~

[题目传送门](https://www.luogu.com.cn/problem/P12123)

题目对传送阵的描述让我们知道，每个输入的 $a_i$ 与 $i$ 之间可任意传送，所以可以先用并查集合并。

进行遍历时，如果不使用魔法，则找到最长集合的长度，就是答案；如果使用了魔法，那么就要找出相邻两个元素所在集合的长度和的最大值。

理清思路，我们需要完成一下几步：  
1. 并查集的操作，就是将输入的 $a_i$ 与 $i$ 置于一个集合之中；
2. 遍历得到最长集合的长度；
3. 遍历得到相邻两个元素所在集合的长度和的最大值；
4. 输出以上两步得出的两个值的最大值。

## **Code**

```cpp
#include <bits/stdc++.h>
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
int n,a[1000005],f[1000005],l[1000005];//l[i]记录传送阵i所在集合长度
int x,y,ans;

//并查集
int find(int x){
	if(x==f[x])return x;
	return f[x]=find(f[x]);
}
void merge(int x,int y){
	int fx,fy;
	fx=find(x);fy=find(y);
	if(fx!=fy)f[fy]=fx,l[fx]+=l[fy];
}

int main(){
	ios;cin>>n;
	for(int i=1;i<=n;i++){
		f[i]=i;l[i]=1;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		merge(i,a[i]);
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,l[find(i)]);
		//找到最大的集合
	}
	for(int i=1;i<n;i++){
		x=find(i);y=find(i+1);
		if(x!=y){
			ans=max(ans,l[x]+l[y]);
			//存在两个相邻的传送阵，无法直接到达
			//此时所能到达的总数为这两个传送阵所在集合的长度之和
		}
		
	}
	cout<<ans;
	return 0;
}
```
感谢阅读！

---

## 作者：AFO_Lzx (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P12123)

### $\texttt{Solution}$

并查集判环。题目说从 $i$ 可以传送到 $a_i$，那么就是编号为 $i$ 的节点和编号为 $a_i$ 的节点在同一个集合当中，并且这个集合是一个环。可以使用一次魔法，也就是可以合并两个不同的环。

所以思路就是每次合并 $i$ 和 $a_i$，然后找到最大的环，接着每次找到不同的两个环，将它们的节点数量之和相加后更新答案。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e6 + 5;
int n, a[maxn], f[maxn], siz[maxn];

int find(int x) {
	if (f[x] == x) return x;
	return f[x] = find(f[x]);
}

void merge(int x, int y) {
	int fx = find(x), fy = find(y);
	if (fx != fy) {
		f[fy] = fx;
		siz[fx] += siz[fy];
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		f[i] = i;
		siz[i] = 1;
	}
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		merge(i, a[i]);
	}
	
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, siz[find(i)]);
	}
	
	for (int i = 1; i < n; i++) {
		int f1 = find(i), f2 = find(i + 1);
		if (f1 != f2) {
			int tot = siz[f1] + siz[f2];
			ans = max(ans, tot);
		}
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：zhangruixiang (赞：2)

# 题解
## 题目理解
我们有 $n$ 个传送阵排成一排，每个传送阵 $i$ 会把你传送到第 $a[i]$ 个传送阵。小蓝可以从任意传送阵开始，每次传送到指定的传送阵，也可以使用一次魔法跳到相邻的传送阵。目标是计算小蓝最多能访问多少个不同的传送阵。
## 思路
实际上，我们把这些传送阵看作几个不相连的环中，每个环的大小不一样。为了使到达的传送阵最多，选择最大的环。魔法使用就是跨越两个不相连的环。

**时间复杂度**：$O(n)$，我们只需要遍历传送阵两次（找环和检查相邻传送阵）。
## Code
```cpp
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
using namespace std;
bool vis[2000000];
int a[2000000],c[2000000];//c代表环的编号 
int main() {
	ios;
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	vector<int>siz;//环的大小
	int k=0;
	// 找出所有环
	for(int i=1;i<=n;++i){
		if(!vis[i]){
			k++;
			int z=0,j=i;
			while(!vis[j]){
				vis[j]=1;
				c[j]=k;
				z++;
				j=a[j];
			}
			siz.push_back(z);
		}
	}
	int m=*max_element(siz.begin(),siz.end());//m代表单个环最大（即不使用魔法） 
	int t=0;//t代表相邻环的和的最大值，即使用魔法的情况 
	for(int i=1;i<n;++i){
		if(c[i]!=c[i+1]){//不在同一个环
			int u=siz[c[i]-1]+siz[c[i+1]-1];
			if(u>t)t=u;
		}
	}
	cout<<max(m,t);
	return 0;
}
```

---

## 作者：Erik_Aoi (赞：2)

不必使用并查集。

根据离散数学，每个传送阵的传递关系形成一个置换，而置换可以分解为若干个循环节。利用 **DFS**，获得每个节点所处循环节的大小，存储在一个数组中。注意给每个循环节打上不同的标记，防止后面求和的相邻节点在一个循环节上。这里以遇到的第一个未被计算的节点作为标记。

这样以后从左到右遍历数组，记录该数组处于不同循环的相邻元素的最大和即可。

**时间复杂度** $ O(n) $。

### 代码：
```cpp
#include <iostream>
#define int long long
using namespace std;

int nxt[1000005] = { 0 };
int dp[1000005] = { 0 };
int vis[1000005] = { 0 };
int mark[1000005] = { 0 };
int n;

// 深度优先搜索，用于记录循环路径信息
int dfs(int cur, int rt, int sum) {
    if (vis[cur]) return sum; // 如果已访问，返回路径长度，即循环大小。
    vis[cur] = 1;
    mark[cur] = rt;             // 标记该路径上所有节点
    return dp[cur] = dfs(nxt[cur], rt, sum + 1);
}

signed main() {
    cin.tie(0)->sync_with_stdio(0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> nxt[i];

    // 遍历每个传送阵，计算循环路径
    for (int i = 1; i <= n; i++) {
        if (!dp[i]) dfs(i, i, 0);
    }

    int ans = dp[1];

    // 求最大和
    for (int i = 2; i <= n; i++) {
        if (mark[i] == mark[i - 1]) continue; // 如果属于同一个循环节，跳过
        ans = max(ans, dp[i - 1] + dp[i]); 
    }

    cout << ans << "\n";
    return 0;
}
```

---

## 作者：HetmesAskalana (赞：1)

## 题解
由于所有传送门的目标构成一个排列，所以在建立有向图后，每个点的度数都固定为 $2$。则说明建立的传送网络是由一个或多个环组成的。

那么，由于可以无限次传送，在一个环的任何位置进入都可以自由地抵达环的任意一个位置，所以我们也可以放心选择跳跃点，只要满足 $i$ 和 $i + 1$ 不在一个环内即可抵达这两个点所在的环的全部点。

我们可以使用并查集来确定两个点是否处于一个相同的环内，特别的，在只有一个环的时候，不存在这样的交点，则可以抵达的点数就是 $n$。否则，可以证明一定存在这样的可以支持跳跃的交点。

## 代码
```cpp
class DSU{
    public:
        DSU(int n){
            f.resize(n);
            for(int i = 0; i < n; ++i) f[i] = i;
            sz.resize(n, 1);
        }

        int find(int x){
            if(f[x] != x) f[x] = find(f[x]);
            return f[x];
        }

        bool same(int x, int y){
            return find(x) == find(y);
        }

        void merge(int x, int y){
            int tx = find(x), ty = find(y);
            if(tx != ty){
                sz[tx] += sz[ty];
                f[ty] = tx;
            }
            return;
        }

        int size(int x){
            return sz[find(x)];
        }
    private:
        vector<int> f, sz;
}; // 并查集模板

void solve(){
    int n; cin >> n;
    DSU d(n + 10);
    vector<int> a(n + 1);
    for(int i = 1; i <= n; ++i){
        cin >> a[i];
        d.merge(i, a[i]); // 连接
    }
    int R = 1;
    for(int i = 1; i < n; ++i){
        if(!d.same(i, i + 1)) R = max(R, d.size(i) + d.size(i + 1)); // 交叉点
        else R = max(R, d.size(i)); // 因为保底一个环，不想写特判可以直接这么搞，否则可以任意一点的并查集大小等于n(d.size(x) == n)，但没必要。
    }
    cout << R << endl;
    return;
}
```

---

## 作者：AcceptedC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12123)  
## 分析
很显然用并查集就可以了，~~[但别像我一样merge函数套错了](https://www.luogu.com.cn/record/214455571)~~。  
在题目描述中，体现关系的是：  
**进入第 $i$ 个传送阵会被传送到第 $a_i$ 个传送阵前。**  
因此将 $i$ 与 $a_i$ 合并，也就是 
`merge(i,a[i]);`。  
此外，还有使用魔法进行相邻传送的操作，那就有两种做法：  
* 如果不使用魔法，则找到最长集合的长度，就是答案。
* 如果使用了魔法，那么就要找出相邻两个元素所在集合的长度和的最大值作为答案。  

最后就是查找完毕输出结果。  
## 大概步骤
1. 合并 $i$ 与 $a_i$。
2. 遍历查找最长集合的长度。
3. 遍历查找相邻两个元素所在集合的长度和的最大值。
4. 输出 2、3 两步得出的两个值的最大值。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[1000010];
int n,a[1000010],l[1000010];
int find(int x){
	return x==fa[x]?x:(fa[x]=find(fa[x]));
}
inline void merge(int x,int y){
	int fx,fy;
	fx=find(x);fy=find(y);
	if(fx!=fy)fa[fy]=fx,l[fx]+=l[fy];
}
int main(){
//	freopen("In file.in","r",stdin);
//	freopen("Out file.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1;i<=n;i++){
		fa[i]=i,l[i]=1;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		merge(i,a[i]);
	}
	int ans,x,y;
	for(int i=1;i<=n;i++){
		ans=max(ans,l[find(i)]);
	}
	for(int i=1;i<=n;i++){
		x=find(i),y=find(i+1);
		if(x!=y){
			ans=max(ans,l[x]+l[y]);
		}
	}
	cout<<ans;
	return 0;
}
```
[这回不是淘汰回放哦](https://www.luogu.com.cn/record/214455825)

---

## 作者：YXY317coder (赞：0)

# 写题策略
使用并查集，将能互相传送到一起的传送阵合并。

然后枚举两个相邻的传送阵，如果是在不同的两个环里就将那两个环的项数加起来，将枚举的全部结果取最大值，否则跳过。

最后输出结果。

# 代码解析
先写一个并查集模板。

```cpp
#include <bits/stdc++.h>
#define int long long
int f[1000005], o[1000005];

int find(int x) { //是否属于同一个环
	if (f[x] == x) return x;
	return f[x] = find(f[x]);
}

void merge(int x, int y) { //合并两个环
	int xo = find(x), yo = find(y);
	if (xo != yo) {
		f[yo] = xo;
		o[xo] += o[yo];
	}
}

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) { //初始化
		f[i] = i;
		o[i] = 1;
	}
  return 0;
}
```

---

把输入也写上。

```cpp
  int a[1000005]
  for (int i = 1; i <= n; i++) { //输入
		cin >> a[i];
		merge(i, a[i]);
	}
```

---

遍历取可穿梭的相邻两个传送门，并比较是否处在不同的环中，如果不处在同一个环中，那么就将两个环数量加起来的值与所求答案取最大值。

要先对所有传送门环的大小取最大值，要不然会出现特殊情况，比如所有传送门都属于同一个环，这样永远都不会执行到取最大值的环节，最后会输出 0。

```cpp
  int ans = 0,tot;
  for (int i = 1; i <= n; i++) { //取最大环，放置特殊情况
		ans = max(ans, o[find(i)]);
	}
	for (int i = 1; i < n; i++) { //遍历取可穿梭的相邻两个不同的环
		int xx = find(i), yy = find(i + 1);
		if (xx != yy) {
			tot = o[xx] + o[yy];
			ans = max(ans, tot);
		}
	}
```

---

最后进行输出。
```cpp
cout << ans;
```

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, a[1000005], f[1000005], o[1000005], ans, tot;

int find(int x) { //是否属于同一个环
	if (f[x] == x) return x;
	return f[x] = find(f[x]);
}

void merge(int x, int y) { //合并两个环
	int xo = find(x), yo = find(y);
	if (xo != yo) {
		f[yo] = xo;
		o[xo] += o[yo];
	}
}

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) { //初始化
		f[i] = i;
		o[i] = 1;
	}
	for (int i = 1; i <= n; i++) { //输入
		cin >> a[i];
		merge(i, a[i]);
	}
	for (int i = 1; i <= n; i++) { //取最大环
		ans = max(ans, o[find(i)]);
	}
	for (int i = 1; i < n; i++) { //遍历取可穿梭的相邻两个不同的环
		int xx = find(i), yy = find(i + 1);
		if (xx != yy) {
			tot = o[xx] + o[yy];
			ans = max(ans, tot);
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目描述
小蓝在环球旅行时来到了一座古代遗迹，里面并排放置了 $n$ 个传送阵，进入第 $i$ 个传送阵会被传送到第 $a_i$ 个传送阵前，并且可以随时选择退出或者继续进入当前传送阵。

小蓝为了探寻传送阵中的宝物，需要选择一个传送阵进入，然后连续进入之后的传送阵。小蓝希望尽可能多地进入传送门以便搜索宝物，同时他可以使用一次魔法，从某个传送阵 $j$ 走到相邻的（第 $j - 1$ 或第 $j + 1$ 个）传送阵，请问小蓝最多能到达多少个不同的传送阵？一个传送阵可多次进入，但在计算答案时只算一个。

## 思路
本题可借助并查集来解决。把每个传送阵视为一个节点，传送关系当作边，构建图结构。通过并查集记录每个连通分量里的节点数，进而快速获取从某个节点出发不使用魔法时能到达的节点数。接着枚举每个节点，尝试使用魔法移动到相邻节点，更新最大可到达节点数。

## AC 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 1e6 + 5;
int n;
int a[MAXN];
int fa[MAXN];
int size[MAXN];
// 查找元素所在集合的代表元素
int find(int x) {
    if(fa[x]==x)return x;
    fa[x]=find(fa[x]);
    return fa[x];
}
// 合并两个集合
void unite(int x, int y) {
    int fx = find(x);
    int fy = find(y);
    if (fx != fy) {
        if (size[fx] < size[fy])swap(fx, fy);
        fa[fy] = fx;
        size[fx] += size[fy];
    }
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    // 初始化并查集 
    for (int i = 1; i <= n; ++i) {
        fa[i] = i;
        size[i] = 1;
    }
    // 构建并查集
    for (int i = 1; i <= n; ++i) {
        unite(i, a[i]);
    }
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        int curAns = size[find(i)];
        ans = max(ans, curAns);
        // 尝试使用魔法向左
        if (i > 1) {
            int l = find(i - 1);
            int curSet = find(i);
            if (l != curSet) {
                ans = max(ans, curAns + size[l]);
            }
        }
        // 尝试使用魔法向右
        if (i < n) {
            int rank = find(i + 1);
            int curSet = find(i);
            if (rank != curSet) {
                ans = max(ans, curAns + size[rank]);
            }
        }
    }
    cout << ans ;
    return 0;
}
```

---


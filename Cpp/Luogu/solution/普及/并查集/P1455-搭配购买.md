# 搭配购买

## 题目描述

明天就是母亲节了，电脑组的小朋友们在忙碌的课业之余挖空心思想着该送什么礼物来表达自己的心意呢？听说在某个网站上有卖云朵的，小朋友们决定一同前往去看看这种神奇的商品，这个店里有 $n$ 朵云，云朵已经被老板编号为 $1,2,3,...,n$，并且每朵云都有一个价值，但是商店的老板是个很奇怪的人，他会告诉你一些云朵要搭配起来买才卖，也就是说买一朵云则与这朵云有搭配的云都要买，电脑组的你觉得这礼物实在是太新奇了，但是你的钱是有限的，所以你肯定是想用现有的钱买到尽量多价值的云。

## 说明/提示

- 对于 $30\%$ 的数据，满足 $1 \le n \le 100$；
- 对于 $50\%$ 的数据，满足 $1 \le n, w \le 10^3$，$1 \le m \le 100$；
- 对于 $100\%$ 的数据，满足 $1 \le n, w \le 10^4$，$0 \le m \le 5 \times 10^3$。

## 样例 #1

### 输入

```
5 3 10
3 10
3 10
3 10
5 100
10 1
1 3
3 2
4 2
```

### 输出

```
1
```

# 题解

## 作者：flysong (赞：613)

[题面](https://www.luogu.com.cn/problem/P1455)~~(卖云朵的怕不是个骗子)~~

[博客内食用更佳](https://flysong.blog.luogu.org/solution-p1455)。

我的第一印象：**01背包**。

### 问：什么是01背包?
答：一种~~背包~~动态规划题目。

追问：什么是动态规划?

追答：你不知道动态规划你干嘛做这题?请先康康[这位老兄的博客](https://www.cnblogs.com/zyacmer/p/9961710.html)。

$WA$ $Code(+30)$
```cpp
for(int i=1;i<=n;i++)//DP
{
	for(int v=w;v>=c[i];v--)
	{
	   f[v]=max(f[v],f[v-c[i]]+d[i]);
	}
}
cout<<f[w]

```

错误原因：~~(事情并不这么简单)~~没有读题。

“一些云朵要搭配起来买才卖，也就是说买一朵云则与这朵云有搭配的云都要买”

	       --商店老板

商店老板告诉我们买一朵云则与这朵云有搭配的云都要买。由此，我们可以想到另一个算法：**并查集**。

### 问：什么是并查集?

答：一种图论算法。

追问：详细一点。

追答：并查集可以快速的判断两个点是否连通。

原理：并查集将一个点作为与这个点连通的所有点的代表。判断两个是否连通，只需要判断他们的代表是否一样。举个栗子：如下图，设有3个询问：

![](https://s2.ax1x.com/2020/01/20/1PvRCd.png)

~~(不要嫌弃图丑)~~

+ $a$与$b$是否连通?
+ $c$与$e$是否连通?
+ $e$与$f$是否连通?

我们暂且现将$a$、$e$作为与他们连通的所有点的代表。

先看第一个询问：

#### d与b是否连通?

我们观察上图，可以发现$d$的代表为$a$，$b$的代表为$a$。因此，$d$与$b$连通。

再看第二个询问：

#### c与e是否连通?

我们观察上图，可以发现$c$的代表为$a$，$e$的代表为$e$。因此，$c$与$e$不连通。

最后再看第三个询问：

#### e与f是否连通?

我们观察上图，可以发现$e$的代表为$e$，$f$的代表为$e$。因此，$e$与$f$连通。

通过上面三个询问，我们就可以知道并查集判断两个点是否连通的方法。

接下来我们再举个栗子：

我们已知$a$与$b$连通，$b$与$c$连通，$d$与$c$连通，问$a$是否与$d$连通？

我们暂且先把前一个节点作为后一个节点的代表。

第一次，我们知道$a$与$b$连通，那么，$a$为$b$的代表。第二次，我们知道$b$与$c$连通，那么，我们设$b$为$c$的代表。第三次，我们知道$d$与$c$连通，那么，我们设$d$为$c$的代表……

似乎有点不对劲？

事实上，我们已经设$b$为$c$的代表了，不能再设$d$为$c$的代表了。

那么，我们如果把$d$设为$c$的代表的代表。事情不就好办了？

通过这一个栗子，我们就可以知道如何用程序合并两个集合。

但是，$c$的代表$b$也有代表了。

那么，我们再往上找。$b$的代表是$a$,那么，我们就把$a$的代表设为$d$。

根据上面这个栗子，我们就可以写出一个基本的并查集。

但是，如果并查集的长度过长：

![](https://s2.ax1x.com/2020/01/20/1iFRPK.png)

就会翻车。

那么，我们就要使用路径压缩。

我们在找$7$的终极代表的过程中把途中经过的所有点的代表都设为$7$的终极代表。那么，这个并查集就成了这个亚子：

![](https://s2.ax1x.com/2020/01/20/1iFW8O.png)

至此，我们已经掌握了并查集………………的一部分。对付这道题够用了。

我们只需把并查集与01背包一结合：

我们就得到了AC代码：

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read()//快读
{
	int num=0,f=1;
	char ch=getchar();

	while(!isalnum(ch))
	{
		if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(isalnum(ch))
	{
		num=num*10+(ch-'0');
		ch=getchar();
	}
	return num*f;
}

int father[10001];//并查集数组

int find(int x)//并查集函数
{
	if(father[x]==x)
	{
		return x;
	}
	return father[x]=find(father[x]);
}

int c[10001],d[10001],f[10001];//DP数组

int main()
{
	int n=read(),m=read(),w=read();
	for(int i=1;i<=n;i++)//初始化并查集
	{
		father[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		c[i]=read();
		d[i]=read();
	}

	int x,y;
	for(int i=1;i<=m;i++)//并查集
	{
		x=read(),y=read();
		father[find(x)]=find(y);
	}

	for(int i=1;i<=n;i++)//将同集合的云朵的价钱与价值都划到一个云朵里
	{
		if(father[i]!=i)
		{
			d[find(i)]+=d[i];
			d[i]=0;
			c[find(i)]+=c[i];
			c[i]=0;
		}
	}

	for(int i=1;i<=n;i++)//DP
	{
	    for(int v=w;v>=c[i];v--)
	    {
	    	f[v]=max(f[v],f[v-c[i]]+d[i]);
		}
	}
	cout<<f[w];
	return 0;
}

```
麻烦点个免费的赞再走呀。

---

## 作者：Paul_Guderian (赞：38)

我们发现这道题背包的限制条件很简单，买了A就必须买B，而且关系是互相的（而不是买A必买B，买B不一定买A）

所以啊，我们就用并查集将“有关系”的物品合成一个大大的物品，然后一个基础的01背包DP就好啦。

代码在这里：

```cpp
#include<stdio.h>
#include<algorithm>
#define go(i,a,b) for(int i=a;i<=b;i++)
#define ro(i,a,b) for(int i=a;i>=b;i--)
const int N=10003;int n,m,W,w[N],v[N],fa[N],f[20000003];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int main()
{
    scanf("%d%d%d",&n,&m,&W);
    go(i,1,n)scanf("%d%d",w+i,v+i),fa[i]=i;
    go(i,1,m){int a,b,A,B;scanf("%d%d",&a,&b);
        if((A=find(a))==(B=find(b)))continue;
        fa[B]=A;v[A]+=v[B];w[A]+=w[B];}
    go(i,1,n)if(fa[i]==i){
    ro(j,W,w[i])f[j]=std::max(f[j],f[j-w[i]]+v[i]);}
    printf("%d",f[W]);return 0;
}//Paul_Guderian

```

---

## 作者：DLSINNOCENCE (赞：19)

**这是一道并查集+01背包题，01背包的限制条件为买A必须买B，故可以用并查集将几个物品合成一个大物品，然后再用01背包做即可。下面是代码，请勿抄袭：**（~~虽然也没人会抄我的代码，我这么弱~~


------------



```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,w,tot;
int p[10000+10],v[10000+10],newp[10000+10],newv[10000+10],f[10000+10],father[10000+10];
void work() { //01背包
	for(int i=1; i<=tot; i++)
		for(int j=w; j>=newp[i]; j--) //滚动数组
			f[j]=max(f[j],f[j-newp[i]]+newv[i]);
	cout<<f[w];
}
int getfather(int x) {//
	if(father[x]==x) return x;
	father[x]=getfather(father[x]);//路径压缩 
	return father[x];
}
void hb(int x,int y) {//并查集合并
	int fx=getfather(x);
	int fy=getfather(y);
	if(fx!=fy) {
		v[fx]+=v[fy];
		p[fx]+=p[fy];
		father[fy]=fx;
	}
}
int main() {
	cin>>n>>m>>w;
	int c,d;
	for(int i=1; i<=n; i++) {
		cin>>c>>d;
		p[i]=c;
		v[i]=d;
		father[i]=i;
	}
	for(int i=1; i<=m; i++) {
		int x,y;
		cin>>x>>y;
		hb(x,y);
	}
	for(int i=1; i<=n; i++) if(father[i]==i)//取出合并好的物品 newp[++tot]=p[i],newv[tot]=v[i]; //将合并好的物品用新的数组装起来
	work();//01背包

}

```


~~求过qwq~~

---

## 作者：AmadeusSG (赞：12)

 _~~**追求代码的整洁与完美~**~~_ 
 
 _**本题先用并查集思想把配套的物品的价值和重量连起来，有点类似于图论中的缩点。**_
 
 然后我们就可以看到这题就成了一道模板01，再一看数据，必须降维优化，用一遍**滚动数组优化**就能轻松AC啦！
 
 下面是标准完美Ak代码：
 
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,w;
int father[1000005],val[1000005],rmb[1000005];
int dp[10000005];
int getfather(int u)//寻父之路
{
	if(father[u]==u)return u; 
	father[u]=getfather(father[u]);
	return father[u];
}
void unio(int x,int y)//并查集
{
	int fx=getfather(x);//爸爸去哪儿
	int fy=getfather(y);
	if(fx!=fy)
	{
		father[fx]=fy;
		rmb[fy]+=rmb[fx];//累加起来
		val[fy]+=val[fx];
	}
}
int main()
{
	int i,j;
	cin>>n>>m>>w;
	for(i=1;i<=n;i++)
	{
		father[i]=i;
		cin>>rmb[i]>>val[i];
	}
	for(i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		unio(x,y);
	}
    for(i=1;i<=n;i++)//zeroone背包
	if(father[i]==i)//判断是否为根节点（主件）
	for(j=w;j>=rmb[i];j--)dp[j]=max(dp[j],dp[j-rmb[i]]+val[i]);
	cout<<dp[w];//完美结束
	return 0;
}
```



---

## 作者：like1 (赞：10)

感觉这道题的做法有无数种，可以用并查集+背包，也可以用缩点+背包，这，两种方法楼下的已经讲得很清楚了，所以我这里讲一个更简单的方法dfs+背包。总时间为1.32s，也不算太慢。

怎么dfs，这道题的要求是若1,2,3,4相连，则1,2,3,4必须同时买，所以我们可以把1,2,3,4这四个点的总价值和费用记录在1号节点上；在dfs时把走过的点标记，避免重复计算
```
inline void dfs(int u,int fa)
{
	for(int i=First[u];i;i=Next[i])
	{
		int v=go[i];
		if(v==fa) continue;
		flag[v]=1;
		ans1+=w[v],ans2+=c[v];
		dfs(v,u);
	}
}

for(int i=1;i<=n;i++)
{
	if(!flag[i])
	{
		dfs(i,0);ans1+=w[i],ans2+=c[i];
		//cout<<ans1<<" "<<ans2<<endl;
		ww[++cnt]=ans1; cc[cnt]=ans2;
	}
	ans1=0,ans2=0;
}
```
那么再记录完之后，我们便得到了对于每个组合的总价值和总花费，接下来就是一个01背包了

```
for(int i=1;i<=cnt;i++)
{
	for(int v=mon;v>=cc[i];v--)
	f[v]=max(f[v],f[v-cc[i]]+ww[i]);
}
```

完整的代码
```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int N=1e5+5;
int First[2*N],Next[2*N],go[2*N],tot;
int w[N],c[N],ww[N],cc[N],flag[N],f[N];
int n,m,mon,x,y,ans1,ans2,cnt;

inline void add(int u,int v)
{
	Next[++tot]=First[u]; First[u]=tot; go[tot]=v;
}

inline void dfs(int u,int fa)
{
	for(int i=First[u];i;i=Next[i])
	{
		int v=go[i];
		if(v==fa) continue;
		flag[v]=1;
		ans1+=w[v],ans2+=c[v];
		dfs(v,u);
	}
}

int main( )
{
	//freopen("1.in","r",stdin);
	scanf("%d%d%d",&n,&m,&mon);
	for(int i=1;i<=n;i++) scanf("%d%d",&c[i],&w[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	for(int i=1;i<=n;i++)
	{
		if(!flag[i])
		{
			dfs(i,0);ans1+=w[i],ans2+=c[i];
			//cout<<ans1<<" "<<ans2<<endl;
			ww[++cnt]=ans1; cc[cnt]=ans2;
		}
		ans1=0,ans2=0;
	}
	for(int i=1;i<=cnt;i++)
	{
		for(int v=mon;v>=cc[i];v--)
		f[v]=max(f[v],f[v-cc[i]]+ww[i]);
	}
	cout<<f[mon];
	return 0;
}

```

最后祝大家CSP2019rp++,score++;



---

## 作者：maorui_cow (赞：5)

**本题思路：tarjan+背包**

tarjan的作用是，将必须互相购买的点缩成一个点

然后直接裸背包

要注意的是缩点时的一些细节

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000+5;
int money[maxn],fa[maxn];
int c[maxn],d[maxn];
int head[maxn],next[maxn],to[maxn],cnt=0;
int add(int x,int y)
{
	to[++cnt]=y;
	next[cnt]=head[x];
	head[x]=cnt;
}
int dfn[maxn],low[maxn],sum=0;
int st[maxn],top=0;
int col=0,co[maxn];
int a[maxn],b[maxn];
int dp[maxn];
void tarjan(int node)
{
	dfn[node]=low[node]=++sum;
	st[++top]=node;
	for(int i=head[node];i;i=next[i])
	{
		int y=to[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[node]=min(low[node],dfn[y]);
		}
		if(!co[y])
		{
			low[node]=min(low[node],low[y]);
		}
	}
	if(dfn[node]==low[node])
	{
		col++;
		while(st[top]!=node)
		{
			a[col]+=c[st[top]];
			b[col]+=d[st[top]];
			co[st[top]]=col;
			top--;
		}
		a[col]+=c[st[top]];
		b[col]+=d[st[top]];
		co[st[top]]=col;
		top--;
	}
}
int main()
{
	int n,m,s;
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&c[i],&d[i]);
	}
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])
		{
			tarjan(i);
		}
	}
	for(int i=1;i<=col;i++)
	{
		for(int j=s;j>=a[i];j--)
		{
			dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
		}
	}
	printf("%d\n",dp[s]);
	return 0;
}

```



没神魔了，不会缩点的可以上网学

---

## 作者：封禁用户 (赞：4)

## 题外话
发现大多题解都是Tarjan或者并查集，其实这里是无向图，Tarjan就等价于求无向图的连通分量，于是我就DFS了一遍找连通分量233，然后求解01背包。
## Adv
个人博客同步： http://www.cinema000.xyz/1509.ruby
## 分析

这题好水阿，一开始没发现是无向图，写了强连通分量，，，后来发现是无向图，想想我直接DFS求连通分量就好了，其实应该是并查集会快一点吧。

反正就是缩点+01背包。

## 代码

```cpp
/*
 * 2018年8月10日 上午9:43:44
 * Luogu 1455
 * Cinema
 * All rights reserved. Cinema Media Group
 * cinema000.xyz
 *
 */
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
const int MAXN = 10000 + 6;

int v[MAXN],c[MAXN],V[MAXN],C[MAXN],f[MAXN],curCC;
std::vector<int> G[MAXN];
bool hash[MAXN];
void PREVISIT(int u){
	V[curCC] += v[u];
	C[curCC] += c[u];
}
void dfs(int u){
	hash[u] = true;
	PREVISIT(u);
	for(int i = 0;i < G[u].size();i++){
		if(!hash[G[u][i]]) dfs(G[u][i]);
	}
}
void findCC(int n){
	curCC = 0;
	for(int u = 0;u < n;u++) if(!hash[u]){curCC++;dfs(u);}
}

int main(){
	int n,m,w;scanf("%d %d %d",&n,&m,&w);
	for(int i = 0;i < n;i++) scanf("%d %d",&v[i],&c[i]);

	for(int i = 0;i < m;i++){
		int x,y;
		scanf("%d %d",&x,&y);x--;y--;
		G[x].push_back(y);G[y].push_back(x);
	}
	findCC(n);
	for(int i = 1;i <= curCC;i++){
		for(int j = w;j >= V[i];j--){
			f[j] = std::max(f[j],f[j - V[i]] + C[i]);
		}
	}
	printf("%d",f[w]);

	return 0;
}

```



---

## 作者：Zcus (赞：4)

### 花了一个小时调这个题~~~
#### 思路很明显! 强连通分量+缩点+背包~~~
```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int n,m,S;
int c[10010],w[10010];
int dfn[10010],low[101010];
int stack[101010],top;
int ifdex;
int vis[101010];
int f[101010];
struct egde{
    int x,y;
    void make(int x1,int y1)
    {
        x=x1;
        y=y1;
    }
};
egde E[20202];
vector<int> G[101010];
int color;
int tarjan_color[101010];
int cc[101010],ww[101010];
void add(int x, int y)
{
    G[x].push_back(y);
}
void tarjan(int u)
{
     dfn[u]=low[u]=++ifdex;
     vis[u]=1;
     stack[++top]=u;
     for (int  i = 0; i < G[u].size(); i++)
     {
        if (!dfn[G[u][i]])
        {
           tarjan(G[u][i]);
           low[u]=min(low[u],low[G[u][i]]);
        }
        else if (vis[G[u][i]])
                {
                    low[u]=min(low[u],low[G[u][i]]);
                }
     }
     if (dfn[u] == low[u])
     {
          int v=stack[top--];
          tarjan_color[v]=++color;
          vis[v]=0;
          cc[color]+=c[v];
          ww[color]+=w[v];
          while (v!=u)
          {
                  v=stack[top--];
                  tarjan_color[v]=color;
                  vis[v]=0;
                  cc[color]+=c[v];
                  ww[color]+=w[v];
          }
     }
}
int main()
{
    scanf("%d%d%d",&n,&m,&S);
    for (int i = 1; i <= n; i++)
        scanf("%d%d",&c[i],&w[i]);
    for (int i = 1; i <= m; i++)
        {
            int x,y;
            scanf ("%d%d",&x,&y);
            add(x,y);
            add(y,x);
            E[i].make(x,y);
        }
    for (int i = 1; i <= n; i++)
    {
        if(!dfn[i]) tarjan(i);
    }
    for (int i = 1; i <=color; i++)
        for (int w = S; w >= 0 ; w--)
        {if(w>=cc[i])
             f[w]=max(f[w],f[w-cc[i]]+ww[i]);
            else f[w]=f[w];
        }
    printf("%d",f[S]);
    return 0;
}
```

---

## 作者：兴安黑熊 (赞：3)

本题是并查集+背包，很好的题目，其实就是把搭配的物品（并查集合并）看成一个物品，需要根据并查集的结果，把价格和价值都累加起来，有多少个分支点就有多少个物品，合并后物品的数量变少了，根据题意， n和w <10000，所以二维背包肯定卡内存，我把物品由n个缩成了num个，这num 就是分支点，然后直接0-1背包就好了。
本题的重点：并查集的每一个元素x的父节点a[x]并不一定是指向祖先的，只有当find(x)后x的父节点才指向祖先，我在这里卡了一会；例如两个分支点A和B合并后，B挂在A的下面，处于分支点B 的叶子节点的父节点是不会指向A 的祖先的。要find后才可以的。
```cpp
#include <iostream>
using namespace std;
int t[10001],v[10001],a[10001],t_h[10001],v_h[10001],t1[10001],v1[10001];
int dp[10001];
int fd(int a[],int x)
{
    if (x!=a[x])
        a[x]=fd(a,a[x]);
    return a[x];
}
int join(int x,int y)
{
    int x1=fd(a,x);
    int y1=fd(a,y);
    if (x1!=y1)
    {
        a[y1]=x1;
       return 1;
    }
    return 0;

}
int main()
{
    int n,m,w,a1,b1;
    cin>>n>>m>>w;
    for(int i=1;i<=n;i++)
        {cin>>t[i]>>v[i];
         a[i]=i;
        }
    for(int i=1;i<=m;i++)
    {  cin>>a1>>b1;
        join(a1,b1);
    }
    //下面找唯一的祖先，然后把价格和价值都累加上。
    for(int i=1;i<=n;i++)
    {
        t_h[fd(a,i)]=t_h[a[i]]+t[i];//这句很关键，不是每个节点的父亲都是指向祖先的!
        v_h[fd(a,i)]=v_h[a[i]]+v[i];// 在2个子树合并后，叶子节点的父亲并没有指向新祖先！
        //t_h[a[i]]这样写是错误的。
    }
    //下面开始缩点
    int num=0;
    for(int i=1;i<=n;i++)
    {
        if (t_h[i]>0)
        {   num++;
            t1[num]=t_h[i];
            v1[num]=v_h[i];
            //num++;
        }
    }

    for(int i=1;i<=n;i++)
        for(int j=w;j>=t1[i];j--)
            dp[j]=max(dp[j],dp[j-t1[i]]+v1[i]);
   cout<<dp[w]<<endl;



    return 0;
}

```



---

## 作者：MedalPluS (赞：3)

楼下题解扯淡...

【正解是并查集】

用并查集缩点，带权并查集

然后DP就好了

记住要优化DP的空间


---

## 作者：孑彧 (赞：2)

# P1455 搭配购买 解题报告

### 题目描述

明天就是母亲节了，电脑组的小朋友们在忙碌的课业之余挖空心思想着该送什么礼物来表达自己的心意呢？听说在某个网站上有卖云朵的，小朋友们决定一同前往去看看这种神奇的商品，这个店里有n朵云，云朵已经被老板编号为1，2，3，……,n,并且每朵云都有一个价值，但是商店的老板是个很奇怪的人，他会告诉你一些云朵要搭配起来买才卖，也就是说买一朵云则与这朵云有搭配的云都要买，电脑组的你觉得这礼物实在是太新奇了，但是你的钱是有限的，所以你肯定是想用现有的钱买到尽量多价值的云。

### 思路

既然若干个云要搭配在一起卖，那我们不如把这几个云看成是同一个，既然如此那我们就需要一个东西来判断这几个云是否是搭配的，我们当然可以用tarjan来缩点，但是，我们注意到，这是一个无向图，也就是说如果两个物品不能搭配在一起时，当且仅当两个物品无法互达，即没有边连接两个物品所在的区域，那我们就可以用并查集来维护这个关系，当两个物品可以互达的时候，他们的父亲是同一个，假如说两个物品的父亲不是同一个，那这两个物品肯定不能搭配。

当我们处理完之后，我们就可以跑一个01背包得到最终解

### 代码

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#define maxn 100000
using namespace std;
int c[maxn],v[maxn],f[maxn];
int c1[maxn],v1[maxn],cnt;
int dp[maxn];
bool vis[maxn];
int n,m,w;
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
int main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++){
		cin>>c[i]>>v[i];
		f[i]=i;
	}
	int x,y;
	for(int i=1;i<=m;i++){
		cin>>y>>x;
		x=find(x);
		y=find(y);
		if(x==y){
			continue;
		}
		f[x]=y;
		v[y]+=v[x];
		c[y]+=c[x];
	} 
	for(int i=1;i<=n;i++){
		x=find(i);
		if(!vis[x]){
			c1[++cnt]=c[x];
			v1[cnt]=v[x];
			vis[x]=1;
		}
	}
	for(int i=1;i<=cnt;i++){
		for(int j=w;j>=c1[i];j--){
			dp[j]=max(dp[j],dp[j-c1[i]]+v1[i]);
		}
	}
	cout<<dp[w];
	return 0;
}
```



---

## 作者：MuYC (赞：2)

### 题目算法分析：并查集+01背包

## 那么什么是并查集?

### 概念：

并查集是一种图论算法，它可以快速的求出两个节点是否处于同一个节点。

### 原理解释
使用一个数组o,o[i]的值对应的是i的父节点。

例如我现在告诉你一些家族关系：

小明是大明的儿子，小明的爷爷是老明，老明还有个儿子叫仲明，仲明有个儿子叫明明。

那么我们可以将小明到明明他们分别编号
1 2 3 4 5

1对应：小明，小明的爸爸是大明（2），所以o[1]=2;

2对应：大明，大明的爸爸是老明(3),所以o[2]=3;

3对应：老明，按理来说，老明是有父亲的，但是老明的父亲已经不在了，所以我们将o[3]就对应3.

同理可得，则得o[4]=3,o[5]=4

这样的话，判断小明与明明是否是亲戚，我们只要找到目前最年长的家庭成员是谁就好了。如果对于小明与明明的最年长的成员是同一个人即小明与明明是亲戚，否则不是。

我们把这种关系抽象为：
O[1]=2,O[2]=3,O[3]=3,O[4]=3,O[5]=4;

定义现在是在O[x]

while( o [x] != x)//如果不是最年长的成员

那么这样就可以判断两个x,y是不是在一个集合内了，即找到最终的O（x）是否等于O(y)

这样的话会很浪费时间：请试想，要是这个关系足够长：长达1000000人，那么这样你需要循环10000000次，肯定会TLE

我们此时想个办法，使得O（x）直接对应的是年龄最大的成员。

假如我们每次都这样，那么时间复杂度都会成为O（K）（K为常数）

代码如下：
```cpp
int ins( int x ){
    int p=x,k;
    while( x != o[x])x=o[x];//找年老成员
    while( p != o[p])k=p,p=o[p],o[k]=x;//将o(x)直接对应年老成员
    return x;
}
```
OK,接下来讲一讲并查集的合并，并查集合并非常简洁：

并查集的合并直接将o[ins(x)]对应的最老成员赋值为o[ins(y)],即将x对应的最老成员对应y的对应最老成员。

代码实现：o[ins(x)]=o[ins(y)];

## 01背包

这个东西比较抽象，请看这位同志的博客：[点这里](https://www.cnblogs.com/zyacmer/p/9961710.html)

写得比较详细，我就不赘述了

下面贴上代码：

## CODE

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
int v[10000+5],q[10000+5];
int q1[10000+5],v1[10000+5];
int q2[10000+5],v2[10000+5];
struct road{int f,t;}R[10000+5];
int o[10000+5],f[10000+5];
int ins( int x ){
    int p=x,k;
    while( x != o[x])x=o[x];
    while( p != o[p])k=p,p=o[p],o[k]=x;
    return x;
}
int main(){
    int i,j,k=0,n,m,w;
    cin>>n>>m>>w;
    for ( i = 1 ; i <= n; i ++)cin>>q[i]>>v[i];
    for ( i = 1 ; i <= n; i++)o[i]=i;
    for ( i = 1 ; i <= m; i ++){
        cin>>R[i].f>>R[i].t;
        o[ins(R[i].f)]=o[ins(R[i].t)];
    }
    for ( i = 1 ; i <= n; i ++){
        q1[ins(i)]+=q[i];
        v1[ins(i)]+=v[i];
    }
    for ( i = 1 ; i <= n ; i ++)if(q1[i]!=0 || v1[i] != 0)k++,v2[k]=v1[i],q2[k]=q1[i];
    for ( i = 1 ; i <= k ; i ++){
        for ( j = w ; j >= q2[i]; j --)
        f[j]=max(f[j],f[j-q2[i]]+v2[i]);
    }
    cout<<f[w];
    return 0;
}
```


---

## 作者：Hanzire76 (赞：1)

# 来个复杂点的解法

思路：Tarjan缩点+01背包

我知道并查集就可以惹qwq，但不知为何写了个tarjan

反正思路很简单，tarjan缩点，缩出来的点就是有关系的点揉在一起的，再在新点上进行01背包。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int N=1e4+100;
int c[N],d[N],cost[N],val[N];
int next[N],head[N],go[N],tot;
inline void add(int u,int v){
    next[++tot]=head[u];head[u]=tot;go[tot]=v;
    next[++tot]=head[v];head[v]=tot;go[tot]=u;
}
int dfn[N],st[N],low[N],co[N],col,num,top;
int Tarjan(int u){
    dfn[u]=low[u]=++num;
    st[++top]=u;
    for(int i=head[u],v;i;i=next[i]){
        v=go[i];
        if(!dfn[v]){
            Tarjan(v);
            low[u]=min(low[u],low[v]);
        }else if(!co[v]){
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(low[u]==dfn[u]){
        co[u]=++col;
        cost[col]+=c[u];
        val[col]+=d[u];
        while(st[top]!=u){
            cost[col]+=c[st[top]];
            val[col]+=d[st[top]];
            co[st[top]]=col;
            --top;
        }
        --top;
    }
}
int f[2][N];
int main(){
    freopen("buy.in","r",stdin);
    freopen("buy.out","w",stdout);
    int n,m,w;
    cin>>n>>m>>w;
    for(int i=1;i<=n;i++)
    scanf("%d%d",&c[i],&d[i]);
    for(int i=1,u,v;i<=m;i++){
        scanf("%d%d",&u,&v);
        add(u,v);
    }
    for(int i=1;i<=n;i++)
    if(!dfn[i])Tarjan(i);
    memset(f,0xcf,sizeof(f));
    f[0][0]=0;
    for(int i=1;i<=col;i++){
        for(int j=0;j<=w;j++)
        f[i&1][j]=f[(i-1)&1][j];
        for(int j=cost[i];j<=w;j++)
        f[i&1][j]=max(f[(i-1)&1][j],f[(i-1)&1][j-cost[i]]+val[i]);
    }
    int ans=0;
    for(int j=0;j<=w;j++)
    ans=max(ans,f[col&1][j]);
    cout<<ans<<endl;
}
```


---

## 作者：wdvxdr (赞：1)

这道题和01背包有所不同的地方是这道题需要考虑成对购买，这有关集合，关于集合类的问题我们可以用并查集来完成。


当两个物品需要成对购买时，我们可以合并这两个物品所在的集合，并将这两个集合的价值和价格加到新的集合上，并清空不要的集合。这一步做完后就用01背包就可已解决了。


动态转移方程是f[j]=max{f[j-c[i]]+d[i],f[j]}


```cpp
#include<iostream>
#include<cstdio>

using namespace std;
int c[10005],d[10005],f[10005],p[10005];

int find(int a)
{
    return p[a]==a?a:p[a]=find(p[a]);
}

int main()
{
    int n,m,w,a,b,fa,fb;
    scanf("%d%d%d",&n,&m,&w);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&c[i],&d[i]);
    for(int i=1;i<=10001;i++)
        p[i]=i;
    while(m--)
    {
        scanf("%d%d",&a,&b);
        fa = find(a);
        fb = find(b);
        if(fa!=fb)
        {
            p[fb] = fa;
            c[fa]+=c[fb];
            d[fa]+=d[fb];
            c[fb]=0;d[fb]=0;
        }
    }
    for(int i=1;i<=n;i++)
        if(c[i]||d[i])
            for(int j=w;j>=0;j--)
                if(j-c[i]>=0)
                    f[j] = max(f[j-c[i]]+d[i],f[j]);
    printf("%d",f[w]);
    return 0;
}
```

---

## 作者：米奇奇米 (赞：1)

# 并查集+01背包模板
```cpp
#include<bits/stdc++.h>
using namespace std;
int const  N=10001;
int father[N],w[N],val[N];
int dp[N];

int Find(int x){
    if(father[x]==x)
        return x;
    return father[x]=Find(father[x]);
}//寻找根节点编号，并且压缩路径

void Union(int x,int y){
    x=Find(x);
    y=Find(y);//合并两个集合，并且判断是否属于同一个集合
    if(x!=y){
      father[y]=x;
      w[x]+=w[y];
      val[x]+=val[y];//现将总花费与总价值计算出来了
    }
}

int main(){
    int n,m,w1;
    scanf("%d%d%d",&n,&m,&w1);
    for(int i=1;i<=n;i++)
        father[i]=i;
    for(int i=1;i<=n;i++)
        cin>>w[i]>>val[i];
    for(int i=1;i<=m;i++)
    {
        int u,v;
        cin>>u>>v;
        Union(u,v);//合并集合
    }
 
    for(int i=1;i<=n;i++)
        Find(i);
 
    for(int i=1;i<=n;i++)
        if(father[i]==i)
            for(int j=w1;j>=w[i];j--)
                dp[j]=max(dp[j],dp[j-w[i]]+val[i]);//01背包模板
 
    cout<<dp[w1]<<endl;
    return 0;
}

```

---

## 作者：DPair (赞：1)

## 本题最简洁题解！


------------


# 【算法】
由题面可以看得出来，这明显是一道背包问题。根据 **“这个店里有n朵云，云朵已经被老板编号为1，2，3，……,n,并且每朵云都有一个价值”**，我们可以得到这是一道01背包。

知道算法框架后，可以发现这里需要用到求连通性的数据结构。这里我们用**并查集**（不会的可以搜索并查集模板）。

由于一般的并查集只能求出连通性，效率太慢，这里我们使用带权值的并查集。

# 【思路】
我们先把所有的商品（云）分到各个并查集中，由于买一个物品等于买了这一并查集所有物品。因此可以想到在合并时把两个并查集（组）权值相加，得到一个大并查集（组）。然后以组为单位，进行01背包 DP。

# 【代码】
```cpp
#include <cstdio>

int f[10010], dp[10010], w[10010], v[10010], n, m, p;
bool vis[10010];

int find(int x)//并查集搜索根结点，并进行路径压缩
{
	if(f[x] == x) return x;
	return f[x] = find(f[x]);
}

void unin(int x, int y)//合并
{
	int xx = find(x);
	int yy = find(y);
	if(xx != yy)
	{
		f[xx] = yy;
		w[yy] += w[xx];//重点！这里我们把整个并查集（组）的权值之和放在根节点上，类似线段树。
		v[yy] += v[xx];
	}
}

int max(int x, int y)//求最大值
{
	return x > y? x:y;
}

int main()
{
//输入以及组合，不解释
	scanf("%d%d%d", &n, &m, &p);
	
	for (int i = 1;i <= n;++ i)
	{
		scanf("%d%d", &w[i], &v[i]);
		f[i] = i;
	}
	for (int i = 1;i <= m;i ++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		unin(x, y);
	}
    
    //DP
	for (int i = 1;i <= n;i ++)
	{
		int xx = find(i);
		if(vis[xx]) continue;//DP部分，因为一组只能调用一次，所以用一个vis数组记录是否访问过该并查集
		vis[xx] = true;
		for (int j = p;j >= w[xx];j --)
		{
			dp[j] = max(dp[j], dp[j-w[xx]]+v[xx]);
		}
	}
	printf("%d", dp[p]);
}
```

---

## 作者：Ryan_ (赞：0)

# 思路：并查集+01背包

**难度：普及+**

~~说明过少未通过题解~~

以下是说明:

由题目中的**买一朵云则与这朵云有搭配的云都要买**可以想到并查集分成若干个不同的区域，操作时需要注意将序号小的作为祖先，便于操作

最后跑一遍01背包即可

```
for(int i=1; i<=n; i++)// 01背包
		for(int j=W; j>=c[i]; j--)
			if(father[i]==i) {
				f[j]=max(f[j],f[j-c[i]]+d[i]);
			}
```

注意这里的father【i】=i;是对每一个组进行背包操作

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
inline int read() {
	char c=getchar();
	int x=0,f=-1;
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}

int n,m,W;
int c[100001],d[100001],father[100001],f[100001];
int find(int x) {
	if(father[x]==x)return x;
	return father[x]=find(father[x]);
}
int main() {
	scanf("%d%d%d",&n,&m,&W);
	for(int i=1; i<=n; i++) {
		scanf("%d%d",&c[i],&d[i]);
	}
	for(int i=1;i<=n;i++)father[i]=i;
	for(int i=1,x,y,a,b; i<=m; i++) {
		scanf("%d%d",&x,&y);
		if(x>y)swap(x,y);//保证编号小的是老祖先
		a=find(x);
		b=find(y);
		if(a!=b) {
			father[b]=a;//合并老祖先
			c[a]+=c[b];	//y的价格合并到x里
			d[a]+=d[b];	//y的价值合并到x里
		}
	}
	for(int i=1; i<=n; i++)// 01背包
		for(int j=W; j>=c[i]; j--)
			if(father[i]==i) {
				f[j]=max(f[j],f[j-c[i]]+d[i]);
			}
	printf("%d",f[W]);
	return 0;
}
```


---

## 作者：paper_plane (赞：0)

## 题目描述

明天就是母亲节了，电脑组的小朋友们在忙碌的课业之余挖空心思想着该送什么礼物来表达自己的心意呢？听说在某个网站上有卖云朵的，小朋友们决定一同前往去看看这种神奇的商品，这个店里有n朵云，云朵已经被老板编号为1，2，3，……,n,并且每朵云都有一个价值，但是商店的老板是个很奇怪的人，他会告诉你一些云朵要搭配起来买才卖，也就是说买一朵云则与这朵云有搭配的云都要买，电脑组的你觉得这礼物实在是太新奇了，但是你的钱是有限的，所以你肯定是想用现有的钱买到尽量多价值的云。

### 输入输出格式

#### 输入格式：
第1行n,m,w,表示n朵云，m个搭配和你现有的钱的数目

第2行至n+1行，每行ci,di表示i朵云的价钱和价值

第n+2至n+1+m ，每行ui,vi表示买ui就必须买vi,同理，如果买vi就必须买ui

#### 输出格式：
一行，表示可以获得的最大价值

####         解题思路：
	       这题的思路是背包加并查集
           把要搭配在一起的看作一个整体
           很简单就做出来了
####            code:
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=10005;
int c[N],d[N];
int fa[N];
int dis_c[N],dis_v[N];
int dp[N],cur;
inline int f(int x){
	if(fa[x]==x)return x;
	return fa[x]=f(fa[x]);
}
int main(){
	int n,m,w;
	scanf("%d%d%d",&n,&m,&w);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&c[i],&d[i]);
	}
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		fa[f(u)]=f(v);
	}
	for(int i=1;i<=n;i++){
		if(i!=fa[i]){
			c[fa[f(i)]]+=c[i];
			d[fa[f(i)]]+=d[i];
		}
	}
	for(int i=1;i<=n;i++){
		if(fa[i]==i){
			++cur;
			dis_c[cur]=c[i];
			dis_v[cur]=d[i];
		}
	}
	//for(int i=1;i<=cur;i++)cout<<dis_c[i]<<' '<<dis_v[i]<<endl;
	memset(dp,0,sizeof(dp));
	for(int i=1;i<=cur;i++){
		for(int j=w;j>=dis_c[i];j--){
			dp[j]=max(dp[j],dp[j-dis_c[i]]+dis_v[i]);
		}
	}
	printf("%d\n",dp[w]);
	return 0;
}

```


---

## 作者：大头冲锋车丶 (赞：0)

[题目传送门](https://www.luogu.org/problemnew/show/P1455)
这道题就是要将**一些物品**组合成**一个大物品**后，再进行dp的**0 1背包问题**。

比如有组数据：1 3物品相连，3 2物品相连，其意义上是指，**买1 2 3中物品的任意一个时，都需要将剩下的两个物品一起购买才行**。即1 2 3捆绑为一个大物品，这个大物品所花费的金钱为**w[1]+w[2]+w[3]**，大物品的总价值为**v[1]+v[2]+v[3]**。在下面代码中，**以node结构体存储每个组合后的大物品**。

这里用到**并查集**：是为了将一连串物品组合起来。

这里用到**dp**：典型0 1背包问题，求出价值最大值。

**详见代码。**

```cpp
#include<bits/stdc++.h>
#define MAXN 10008
using namespace std;
int w[MAXN], v[MAXN], dp[MAXN], n, m, c;//w，v数组分别存储小物品的花费与价值，c为总钱数
int pre[MAXN], flag[MAXN];//并查集中pre存储各个点的父节点，flag用来标记最后哪些是父节点
struct node//存储组合后的大物品的结构体
{
	int cost, val;//cost大物品的花费，val大物品的价值
}s[MAXN];
inline int find(int x)//并查集，寻找x父节点并压缩路径
{
	int r = x;
	while (pre[r] != r)
		r = pre[r];		//寻找x父节点
	int i = x, j;
	while (i != r)//压缩路径，将当前能经过x的所有点的父节点都改为x的父节点r
	{
		j = pre[i];
		pre[i] = r;
		i = j;
	}
	return r;返回x的父节点r
}
inline void mix(int x, int y)//并查集，连通两个父节点
{
	int px = find(x), py = find(y);//查找x y的父节点
	if (px != py)//如果他们父节点不同，连接它们，使x父节点与y父节点下的子节点连通。即小物品都连通，这些所有小物品合成为一个大物品
		pre[px] = py;
	return;
}
int main()
{		
	while (cin >> n >> m >> c)
	{
		for (int i = 1; i <= n; i++)
			cin >> w[i] >> v[i], pre[i] = i;
		int A, B;
		while (m--)
		{
			cin >> A >> B;
			mix(A, B);//边输入边连接，mix里面的find再进行路径压缩
		}
		memset(s, 0, sizeof(s));
		memset(flag, 0, sizeof(flag));
		int a, ans = 0;
		for (int i = 1; i <= n; i++)
		{
			a = find(i);//最后遍历每个节点，并再进行find路径压缩（应该是为了防止有遗漏）
			if (!flag[a])//如果这个父节点之前没有出想过，那么给它一个s数组（即大物品）
				flag[a] = ++ans;
			s[flag[a]].cost += w[i], s[flag[a]].val += v[i];//将属于这个父节点的所有小物品的花费与价值相加
		}
		memset(dp, 0, sizeof(dp));
		for (int i = 1; i <= ans; i++)
			for (int j = c; j >= s[i].cost; j--)
				dp[j] = max(dp[j], dp[j - s[i].cost] + s[i].val);
		cout << dp[c] << endl;//一维背包输出c花费的最大价值
	}
}
```


---

## 作者：YZhe (赞：0)

### 算法
  **并查集+01背包**
  
  先用并查集处理各种~~捆绑销售~~的云朵
  ```cpp
    cin>>n>>pai>>mon;
	for( int i = 1 ; i <= n ; i ++ )
	  father[ i ]=i;
	for( int i = 1 ; i <= n ; i ++ )
	  scanf( "%d %d" , &pri[ i ] , &val[ i ] );
	for( int i = 1; i <= pai ; i ++ )
	{
		int x,y;
		scanf( "%d %d" , &x , &y );
		int r1=find( x ),r2=find( y );
		if( r1 == r2 )
		  continue;
		unionn( r1 , r2 );
	}
```
  
  然后操作一下把所有的一堆堆东西合并在一起，组成背包里的一个物品
  ```cpp
void turnn()
{
	memset( v , 0 , sizeof( v ) );
	for( int i = 1 ; i <= n ; i ++ )
	{
		if( ! v[ find( i ) ] )//新的捆绑销售 
		{
			v[ father[ i ] ]=++tot;//记录下以father[ i ]为首的捆绑销售方案是第几号 
			pack_val[ tot ]+=val[ i ];
			pack_pri[ tot ]+=pri[ i ];
			continue;
		}
		pack_val[ v[ find( i ) ] ]+=val[ i ]; 
		pack_pri[ v[ find( i ) ] ]+=pri[ i ];
	}//处理为背包问题 
}
```
最后就可以用DP来做了，是不是很~~抽象~~清晰呢
```cpp
void ddpp()
{
	for( int i = 1 ; i <= tot ; i ++ )
	  for( int j = mon ; j >= 1 ; j -- )
	    if( j >= pack_pri[ i ] )
	      dp[ j ]=max( dp[ j - pack_pri[ i ] ] + pack_val[ i ] , dp[ j ]);
	cout<<dp[ mon ];
}
```
最后是**完整**代码~~（提示，为了大家好，我故意改错了一个语句）~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int father[20000];
int pri[20000];
int val[20000];
int pack_val[20000]={};
int pack_pri[20000]={};
int v[20000];
int n,pai,mon,tot=0;
int dp[10000];

int find( int x )
{
	if( father[ x ] != x )
	  father[ x ]=find( father[ x ] );
	return father[ x ];
}

void unionn( int x , int y )
{
	father[ y ]=father[ x ];
}

void turnn()
{
	memset( v , 0 , sizeof( v ) );
	for( int i = 1 ; i <= n ; i ++ )
	{
		if( ! v[ find( i ) ] )//新的捆绑销售 
		{
			v[ father[ i ] ]=++tot;//记录下以father[ i ]为首的捆绑销售方案是第几号 
			pack_val[ tot ]+=val[ i ];
			pack_pri[ tot ]+=pri[ i ];
			continue;
		}
		pack_val[ v[ find( i ) ] ]+=val[ i ]; 
		pack_pri[ v[ find( i ) ] ]+=pri[ i ];
	}//处理为背包问题 
}

void ddpp()
{
	for( int i = 1 ; i <= tot ; i ++ )
	  for( int j = 1 ; j <= mon ; j ++ )
	    if( j >= pack_pri[ i ] )
	      dp[ j ]=max( dp[ j - pack_pri[ i ] ] + pack_val[ i ] , dp[ j ]);
	cout<<dp[ mon ];
}

int main()
{
	cin>>n>>pai>>mon;
	for( int i = 1 ; i <= n ; i ++ )
	  father[ i ]=i;
	for( int i = 1 ; i <= n ; i ++ )
	  scanf( "%d %d" , &pri[ i ] , &val[ i ] );
	for( int i = 1; i <= pai ; i ++ )
	{
		int x,y;
		scanf( "%d %d" , &x , &y );
		int r1=find( x ),r2=find( y );
		if( r1 == r2 )
		  continue;
		unionn( r1 , r2 );
	}
	void turnn();
	ddpp();
	return 0;
}
```

---

## 作者：清风霁月 (赞：0)

    并查集 + 01背包
    并查集：将需要在一起买的物品都并起来，算出总花费及总价值
    01背包：只需要买一个，就代表了所有同组应搭配购买的物品


    #include<cstdio>
    #include<iostream>
    using namespace std;
    int n,m,val,w[10001],f[10001],v[10001],tot,x,y,father[10001],i,j;
    int find(int x)//查找根节点
    {
    	if(father[x]!=x)
	    father[x]=find(father[x]);
	    return father[x];
    }
    int main()
    {
    	cin>>n>>m>>val;
    	for(i=1;i<=n;i++)
    	{
	        cin>>w[i]>>v[i];
	        father[i]=i;
            //初始化集合，以每个元素作为自己的根节点
	    }
	    for(i=1;i<=m;i++)
	    {
	        cin>>x>>y;
	        int fx=find(x),fy=find(y);
	        if(fx!=fy)
	        father[fy]=fx,w[fx]+=w[fy],v[fx]+=v[fy];
            //先将每组搭配购买的总花费、总价值算出来
	    }
	    for(i=1;i<=n;i++)
	    if(father[i]==i)
        //一个集合的根节点只有一个，所以根节点为本身时是一朵云朵
	    {
	    	v[++tot]=v[i];
	    	w[tot]=w[i];
    	}
	    for(i=1;i<=tot;i++)//01背包求解
	    for(j=val;j>=w[i];j--)
	    f[j]=max(f[j],f[j-w[i]]+v[i]);
	    cout<<f[val]<<endl;
	    return 0;
    }	
    
    求过求过
    谢谢管理员大大！

---

## 作者：bztMinamoto (赞：0)

这道题可以说是一道并查集和01背包的合体,

需要同时购买的可以用并查集使其视为同一个物体,

然后就可以用01背包的模板算出答案

具体细节看注解，上代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=10050;
int v[N],f[N],g[N],h[N];
int a[N],ans[N];
int n,m,k;
int t;
int ff(int x)
{
    if(f[x]==x) return x;
    return f[x]=ff(f[x]);
}
void unite(int x,int y)
{
//h用于按秩合并
//合并时，将两物体的价值和价钱都加到一起
    x=ff(x),y=ff(y);
    if(x==y) return;
    if(h[x]<h[y])
    f[x]=y,v[y]+=v[x],g[y]+=g[x];
    else if(h[x]>h[y])
    f[y]=x,v[x]+=v[y],g[x]+=g[y];
    else
    f[y]=x,h[x]++,v[x]+=v[y],g[x]+=g[y];
    return;
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
    scanf("%d%d",&v[i],&g[i]);
    for(int i=1;i<=n;i++)
    f[i]=i,h[i]=1;
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        unite(x,y);
    }
    for(int i=1;i<=n;i++)
    {
        if(f[i]==i&&v[i]<=k)
        a[t++]=i;
        //一次遍历，将所有的集合找出
    }
    for(int i=0;i<t;i++)
    for(int j=k;j>=v[a[i]];j--)
    ans[j]=max(ans[j],ans[j-v[a[i]]]+g[a[i]]);
    //01的模板找答案
    printf("%d",ans[k]);
    return 0;
}
```

---

## 作者：xukuan (赞：0)

并查集+dp（压缩成一维）


```pascal
uses math;

var
 n,m,w,i,u,v,f1,f2,j:longint;
 c,d,father,f:array[0..10010] of longint;

function searchfather(v:longint):longint;//找到父节点
 begin
  if father[v]=v then searchfather:=v
                 else searchfather:=searchfather(father[v]);
  father[v]:=searchfather;
end;

begin
 readln(n,m,w);
 for i:=1 to n do
  begin
   readln(c[i],d[i]);
   father[i]:=i;
  end;
 for i:=1 to m do
  begin
   readln(u,v);
   f1:=searchfather(u);
   f2:=searchfather(v);
   if f1<>f2 then
    father[f1]:=f2;//并入同一个集内
  end;
 for i:=1 to n do
  if father[i]<>i then
   begin
    inc(c[searchfather(i)],c[i]);//并入
    c[i]:=0;//清零
    inc(d[searchfather(i)],d[i]);//并入
    d[i]:=0;//清零
   end;//合并

 for i:=1 to n do
  if (c[i]<>0) or (d[i]<>0) then//该集不为空
   for j:=w downto c[i] do
    f[j]:=max(f[j],f[j-c[i]]+d[i]);//dp
 writeln(f[w]);
end.
```

---

## 作者：vinvor (赞：0)

这是一道非常好的几个知识点结合的题目，首先——**有依赖的背包问题**，无误。

这道题有两个方案：

- 普及组及以下选手：**并查集**，并查集是一个简单高效的算法。当两个物品需要捆绑购买时，就将它们组合为一个集合，即可产生新的价值，赋值即可。然后**跑****标准01背包**即可解决问题，此题数据量不大，还可以。

- 大牛们：**tarjan塔扬算法缩点（强连通分量），然后跑01背包**，tarjan算法比并查集应用更为广泛，在图论里很常用，对于数据量比较大的题目可能会有奇效。但是tarjan不太容易被理解，此处不再详述tarjan算法细节。

并查集是很好用的！每个OIer必备的技能！

下附并查集代码：

```cpp
#include<bits/stdc++.h>
#define maxn 10005
using namespace std;
int n=0,m=0,w=0,ans=0,k=0;
int ww[maxn],mm[maxn],f[maxn],money[maxn],v[maxn],dp[maxn],used[maxn];
void dohebing(int x,int y)
{
    int a=find(x);
    int b=find(y);
    f[a]=b;
    money[b]+=money[a];
    v[b]+=v[a];
}
int findfather(int x)
{
    if(f[x]==x)return x;
    return find(f[x]);
}
int main()
{
    scanf("%d %d %d",&n,&m,&w);
    for(int i=1;i<=n;i++)
    scanf("%d %d",&money[i],&v[i]);
    for(int i=1;i<=n;i++)
        f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        dohebing(x,y);
    }
    for(int i=1;i<=n;i++)
   {
       int a=findfather(i);
       if(a==i)
       {
           k++;
           ww[k]=money[i];
           mm[k]=v[i];
       }
   }
    for(int i=1;i<=k;i++)
   {
       for(int j=w;j>=ww[i];j--)
       {
           dp[j]=max(dp[j],dp[j-ww[i]]+mm[i]);
       }
   }
    for(int i=1;i<=w;i++)
           ans=max(ans,dp[i]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：QwQ_operator (赞：0)

tarjan缩点后跑01背包。。

挺简单的。。。。

然而蒟蒻调了一天。。。。


代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define N 10001
using namespace std;
int x,y,w,n,m,t,tat,sum,top,time;
int v[N],c[N],f[N],head[N],col[N];
int cc[N],vv[N],stack[N],dfn[N],low[N];
bool vis[N];
struct Edge
{
    int from,next,to;
 }edge[N];
int add(int x,int y)
{
    tat++;
    edge[tat].to=y;
    edge[tat].next=head[x];
    head[x]=tat;
}
int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return f*x;
}
int tarjan(int now)
{
    dfn[now]=low[now]=++time;
    stack[++top]=now; vis[now]=true;
    for(int i=head[now];i;i=edge[i].next)
    {
        int t=edge[i].to;
        if(vis[t]) low[now]=min(low[now],dfn[t]);
        else if(!dfn[t])tarjan(t),low[now]=min(low[now],low[t]);
    }
    if(low[now]==dfn[now])
    {
        sum++;col[now]=sum;
        vv[sum]+=v[now];
        cc[sum]+=c[now];
        for(;stack[top]!=now;top--)
        {
            cc[sum]+=c[stack[top]];
            vv[sum]+=v[stack[top]];
            col[stack[top]]=sum;
            vis[stack[top]]=false;
        }
        vis[now]=false;
    }
}
int main()
{
    n=read(),m=read(),w=read();
    for(int i=1;i<=n;i++)
      v[i]=read(),c[i]=read();//v为价格，c为价值 
    for(int i=1;i<=m;i++)
      x=read(),y=read(),add(x,y),add(y,x);//建双向边 
    for(int i=1;i<=n;i++)
     if(!dfn[i]) tarjan(i);//tarjan 
    for(int i=1;i<=sum;i++)//01背包求用最少的钱获得最大的价值 
     for(int j=w;j>=vv[i];j--)
      f[j]=max(f[j],f[j-vv[i]]+cc[i]);
    //printf("%d\n",sum);
    printf("%d",f[w]);
    return 0;
}
```

---

## 作者：小黑 (赞：0)

缩点+01背包，很容易看出来

我是来练习tarjan的，所以就用的tarjan来缩点，记录下每个强连通分量的cost和wealth，缩完点以后直接01背包搞定


PS：数据真是小，完全不用担心时间问题 {总用时#810ms 最长时间的点#239ms}


附上不怎么好看但还算工整的代码(P党福利)：






```cpp
var
  point,next,head,dfn,low,c,d,cost,wealth,stack,dp:array[0..10000] of longint;
  instack:array[0..10000] of boolean;
  n,m,w,x,y:longint;
  num,sccnum,i,j,top,ans:longint;
function min(a,b:longint):longint;
  begin
    if a<b then exit(a) else exit(b);
  end;
procedure addedge(u,v:longint);
  begin
    inc(num);
    point[num]:=v;
    next[num]:=head[u];
    head[u]:=num;
  end;
procedure tarjan(u:longint);
  var
    p,root:longint;
  begin
    inc(num);dfn[u]:=num;low[u]:=num;
    inc(top);stack[top]:=u;instack[u]:=true;
    p:=head[u];
    while p<>0 do
      begin
        if dfn[point[p]]=0 then
          begin
            tarjan(point[p]);
            low[u]:=min(low[u],low[point[p]]);
          end
        else
          if instack[point[p]] then
            low[u]:=min(low[u],dfn[point[p]]);
        p:=next[p];
      end;
    if dfn[u]=low[u] then
      begin
        inc(sccnum);
        repeat
          root:=stack[top];instack[root]:=false;dec(top);
          cost[sccnum]:=cost[sccnum]+c[root];
          wealth[sccnum]:=wealth[sccnum]+d[root];
        until u=root;
      end;
  end;
begin
  read(n,m,w);
  for i:=1 to n do read(c[i],d[i]);
  num:=0;
  for i:=1 to m do
    begin
      read(x,y);
      addedge(x,y);
      addedge(y,x);
    end;
  num:=0;sccnum:=0;
  for i:=1 to n do
    if dfn[i]=0 then
      begin
        top:=0;
        tarjan(i);
      end;
  for i:=1 to sccnum do
    for j:=w downto cost[i] do
      if dp[j]<dp[j-cost[i]]+wealth[i] then
        dp[j]:=dp[j-cost[i]]+wealth[i];
  ans:=0;
  for i:=1 to w do
    if dp[i]>ans then
      ans:=dp[i];
  writeln(ans);
end.

```

---

## 作者：pupuvovovovovo (赞：0)

没pas题解呀呀

先裸的并查集缩点，完了以后把一群v，w加到他爸爸（fa）上去。

然后滚动数组做01背包。

```cpp
var f,fa,w,v:array [0..10000] of longint;
w1,v1:array [1..10000] of longint;
n,m,ww,i,j,x,y,a,b,top:longint;
function ask(x:longint):longint;
begin
  if fa[x]=x then exit(x);
  fa[x]:=ask(fa[x]);
  exit(fa[x]);
end;//并查集
function max(a,b:longint):longint;
begin
  if a>b then exit(a);
  exit(b);
end;
begin
  read(n,m,ww);
  for i:=1 to n do
  begin
    read(w[i],v[i]);
    fa[i]:=i;//必须初始化，否则ask中会求fa[0]
  end;
 {for i:=1 to m do
  begin
    read(x,y);
    a:=ask(x);
    b:=ask(y);
    if a<>b then fa[a]:=b;
  end;
  for i:=1 to n do
    if ask(i)<>i then
    begin
      a:=ask(i);
      w[a]:=w[a]+w[i];
      v[a]:=v[a]+v[i];
    end;
  for i:=1 to n do
  if fa[i]=i then
  begin
    inc(top);
    w1[top]:=w[i];
    v1[top]:=v[i];
  end;}并查集缩点
  for i:=1 to top do
  for j:=ww downto 1 do//正代价滚动，01 downto，完全to
  if j>=w1[i] then f[j]:=max(f[j],f[j-w1[i]]+v1[i]);//滚动的01背包
  write(f[ww]);
end.
```

---

## 作者：zclzslz (赞：0)

竟然连个代码都没有！这让负责任的我怎么看得下去！绝不袖手旁观！

主要思路：并查集+DP(01背包)

废话不多说，上代码：

    
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n,m,w,f[10005],money[10005],v[10005],ans(0),dp[10005],used[10005],k(0);
int ww[10005],mm[10005];
int find(int x)
{
    if(f[x]==x)return x;
    return find(f[x]);
}
void UN(int x,int y)
{
    int a=find(x);
    int b=find(y);
    f[a]=b;
    money[b]+=money[a];//先将每组搭配购买的物品的总花费、总价值算出来
    v[b]+=v[a];
}
void solve()
{
    memset(used,0,sizeof(used));
    memset(dp,0,sizeof(dp));
    scanf("%d %d %d",&n,&m,&w);
    for(int i=1;i<=n;i++)
    scanf("%d %d",&money[i],&v[i]);
    for(int i=1;i<=n;i++)
    f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        UN(x,y);
    }
   for(int i=1;i<=n;i++)
   {
       int a=find(i);
       if(a==i)
       {
           k++;
           ww[k]=money[i];//只需要买一个,就代表买了所有同组应搭配购买的物品
           mm[k]=v[i];
       }
   }
   for(int i=1;i<=k;i++)
   {
       for(int j=w;j>=ww[i];j--)
       {
           dp[j]=max(dp[j],dp[j-ww[i]]+mm[i]);
       }
   }
   for(int i=1;i<=w;i++)
   ans=max(ans,dp[i]);
   printf("%d\n",ans);
}
int main()
{
    solve();
    return 0;
} 
//并查集也算是比较重要的算法，应该掌握！
```

---


# 亲戚

## 题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。


## 题目描述

规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。

## 样例 #1

### 输入

```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6```

### 输出

```
Yes
Yes
No```

# 题解

## 作者：mysssss (赞：349)

本 _**蒟蒻**_ 第一篇题解

所以多多包容啦thx

~~说实话我才A了二十一道题~~

~~没错但我还是不要脸的上来发题解~~

好了cd结束   下面正题
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,f[10010],c,d,a,b;
int fd(int x)//找出x家的大佬 也就是二叉树的祖先节点
{
	if(f[x]==x)//x是x的爸爸，简单的来说就是x没爸爸了
    
    //他是家里最大的大佬，所以返回的x就是我们所求的祖先节点
	return x;
	else 
	return  f[x]=fd(f[x]);//x不是他自己的爸爸，所以他上面还
    //有爸爸，我们的目标是祖先节点，所以我们此时要做的是问他
    //爸爸的爸爸是谁，即再使用一次fd（find）函数【其实就是一个递归过程
}
void hb(int x,int y)
{
	f[fd(y)]=fd(x);//合并x子集和y子集，直接把x子集的祖先节
    //点与y子集的祖先节点连接起来，通俗点来说就是把x的最大祖
    //先变成y子集最大祖先的爸爸
	return ;
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++)
	f[i]=i;
	for(int i=1;i<=m;i++)
	{
	     scanf("%d%d",&c,&d);
	     hb(c,d);
	}
	for(int i=1;i<=q;i++)
	{
		scanf("%d%d",&a,&b);
		if(fd(a)==fd(b))//如果a所在子集的大佬[前面已经解释过了]和b所在子集的大佬一样，即可知a和b在同一个集合
		printf("Yes\n");
		else
		printf("No\n");
	}
	return 0;
}
```
很简单的一个并查集

我的程序应该还算简洁

好了没了，我可能说的比较啰嗦

需要的朋友将就着看下咯

多多指教

本蒟蒻告辞

谢谢啦（爱你们略略略

---

## 作者：Null_Cat (赞：68)

### 关于这道题：

看到好多神仙级的巨佬根本无视w这种小蒟蒻直接引入并查集，所以w打算通过这篇题解给各位刚入坑的OIer们讲讲并查集这个东西qwq

------

根据题目的意思，因为是一个“亲戚关系图”，因此w们先创造一个图$G(V, E)$，因此n, m就分别是指$G$的n个点，m条边，这里w们可以采用样例的6，5，然后再根据样例中给出的“亲戚关系”去在点之间建边，于是就得到了下面这个图：

![qwq](https://cdn.luogu.com.cn/upload/pic/73123.png "没错就是w！")

~~有点小没办法qwq~~

很显然w们可以看出，这是一个无向图，而且很显然这个并不是一个联通图（当然也有是连通图的时候，那种特殊情况待会讨论）

那么显而易见，现在除了6之外的所有点都是亲戚，也就是说无6的那个子图是一个无向联通子图，所以说可以得出结论，**在任意联通子图中的两个点必为亲戚关系，为亲戚关系的两个点在同一联通子图中**

所以根据这个性质，w们就把问题转化为：在一个无向图中，查询两点是否在同一联通子图中

那么很显然，w们肯定是开一个vis数组，用邻接表存，然后走到一个点就更新vis，如果无路可走那么就去遍历下一个联通子图

这种方法的话存在两种非常极限的情况，第一种是在$G$中根本没有边相连，则需要遍历的次数就退化成了$O(n)$，也就是每一个点都需要遍历一次

第二种极限的情况就是当所有点都相连的时候，遍历查找整个邻接表的复杂度就退化为$O(m)$甚至更高

很显然这种方法面对小数据是能够过的
~~（其实这道题也能这么水）~~，不过很显然如果遇到了大数据还没$n^2$就过百万了。。。

众所周知，在利用邻接表存储的时候，w们是用了一个类似hash表的样子的一个东西对于图进行存储的一个东西，所以在w们存储的时候本质就是给它存成了一堆链表，而链表的查询复杂度在特殊情况其实是比较高的，再加上可能会出现毒瘤数据，所以有的时候甚至会卡出接近$O(nm)$的复杂度

但是，请思考一个问题：

**w们真的需要去遍历每个子图嘛？**

很显然并不是，因为w们只需要知道需要查询的元素和已知与需要查询的元素有关联的一个点与另外一个需要查询的元素是否有关系即可，而对于这种关系，w们可以在处理的时候就让一些点同时处于一个集合中，而在该集合要在集合中任取一个元素作为该集合的代表元素，然后可能会出现一个集合中有一个元素是另一个集合的代表元素的情况，很显然这就让w们想起了另外一个数据结构：

**树**

那么每一个联通子图就变成了一个个的树，而整个图就变成了一个森林

那么w们有必要按照树的存储方式来存图嘛？很显然w们并不需要，因为w们其实只是对于一个集合进行了抽象而已，也就是说w们只需要存下标为i的点所在集合的代表元素即可

这就是基础的并查集

可是这仅仅是基础，因为w们还有可能会遇到一些更加极限的情况

举个栗子，当$n = 5, m = 4$时，存在有$1 - 2, 2 - 3, 4 - 5, 3 - 4$的边集，根据上面所讲的并查集思路，大概就是能画出来这样一个图：

![qwq](https://cdn.luogu.com.cn/upload/pic/73134.png "就是w")

泥可能会惊讶，蛤这不是个链表嘛qwq?

珂这真的是按照w们刚刚的思路建的一个森林，w们可以叫他一叉森林（大雾）

咳咳

这种就是w所说的极限情况，每个集合确实是有代表元素，但是他们本质还是属于同一个大的集合，而退化成链表后的复杂度也就变成了$O(n)$，很显然A了本题是完全够得，可是遇到$1e9$这样的大数据就会$\large\color{red}\text{TLE}$

所以w们就要思考为什么会退化，很显然在储存的时候w们只考虑最近的集合，但是很显然如果直接归并到祖先集合中其实也是完全OK的

所以w们需要对并查集进行路径压缩，但是很显然如果w们在读入的时候就进行路径压缩其实对于最后的结果还是有一定影响的，因此w们只能在查找的过程中对于并查集进行路径压缩

------

咳咳咳上面讲了这么多，下面是本题的代码qwq

```cpp
#include<cstdio>
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int father[5001],n,m,p,a,b,u,v;
int find(int x)//查找+路径压缩
{
    return x==father[x]?x:father[x]=find(father[x]);
}
int main()
{
    r(i,0,5000) father[i]=i;
    scanf("%d %d %d",&n,&m,&p);
    r(i,1,m)
     {
        scanf("%d %d",&a,&b);
        u=find(a);v=find(b);//查找
        if(u!=v) father[u]=v;//合并
     }
    r(i,1,p)
    {
        scanf("%d %d",&a,&b);
        u=find(a);v=find(b);
        if(u!=v) puts("No");else puts("Yes");//判断，输出
    }
}
```

上面代码转自[这里](https://blog.csdn.net/xuxiayang/article/details/79231149)，因为某Null_Cat实在懒得再敲代码喏qwq

---

## 作者：不愿透露姓名 (赞：45)

并查集模板题，附上我的版版 **递归** 和 **不递归的路径压缩** 都有啊

详情见代码：

```cpp
#include<cstdio>
using namespace std;
int fa[500010];
int find(int a)//找a的祖先们 
{
    int t1=a,t2;
    while(fa[a]!=a) a=fa[a];//如果a的father不等于它 
    while(fa[t1]!=t1)     
    {                     
        t2=fa[t1];         //找祖先并把路上的点 
        fa[t1]=a;          //与祖先相连；
        t1=t2;             //目的：路径压缩
    }
    return a;
}
```
/\*


```cpp
int find(int z)   //递归实现 1
{
    if(f[z]==z)
        return z;
    return f[z]=find(f[z]);    //并查集
}
int find(int x)  //递归实现2 
{
    if(x!=f[x])
       f[x]=find(f[x]);
    return f[x];
}
int find(int x)   //加速递归 
{
    return f[x]==x?x:f[x]=find(f[x]);
}
```
\*/
```cpp
int main()
{
    int n,m,p;
    scanf("%d%d%d",&n,&m,&p);
    for(int i=1;i<=n;i++)
        fa[i]=i;
    int x,y;  
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        fa[find(x)]=find(y);//X祖先为y祖先 
    }
    for(int i=1;i<=p;i++)
    {
        scanf("%d%d",&x,&y);
        if(find(x)==find(y)) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：JOHNKRAM (赞：26)

我都说了是并查集，不过得加路径压缩。

判断两个点是否在同一集合内不会有人不会吧？？？


---

## 作者：TYX180129 (赞：25)

# 并查集
### 思路:
### 1.初始化每个人的祖先就是自己
### 2.输入两个人,然后将两个人的祖先合并
### 3.输入,判断两个人的祖先是否相同(查找两个人的祖先是否相同),输出判断的结果
## 细节见代码
##### 代码长度530B 用时37ms 内存928.00KB
```cpp
#include<bits/stdc++.h>
using namespace std ;
int f[5005] ;
int zuxian(int x)//查找X的祖先 
{
	if(x == f[x]) 
		return x ;
	return f[x] = zuxian(f[x]) ;
}
int main()
{
	int a , b ;
	int n , m , p ;
	scanf("%d%d%d" , &n , &m , &p) ;
	for(int i = 1 ; i <= n ; ++i)//初始化自己的祖先是自己 
		f[i] = i ;
	for(int i = 1 ; i <= m ; ++i)
	{
		scanf("%d%d" , &a , &b) ;//合并两个人的祖先 
		f[zuxian(a)] = zuxian(b) ;
	}	
	for(int j = 1 ; j <= p ; ++j)
	{
		scanf("%d%d" , &a , &b) ;
		if(zuxian(a) == zuxian(b))//如果两个人的祖先一样输出Yes 
			printf("Yes\n") ;
		else                      //否则输出No 
			printf("No\n") ;
	}
	return 0 ;
}
```
## 没有注释的代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
int f[5005] ;
int zuxian(int x)
{
	if(x == f[x]) 
		return x ;
	return f[x] = zuxian(f[x]) ;
}
int main()
{
	int a , b ;
	int n , m , p ;
	scanf("%d%d%d" , &n , &m , &p) ;
	for(int i = 1 ; i <= n ; ++i)
		f[i] = i ;
	for(int i = 1 ; i <= m ; ++i)
	{
		scanf("%d%d" , &a , &b) ;
		f[zuxian(a)] = zuxian(b) ;
	}	
	for(int j = 1 ; j <= p ; ++j)
	{
		scanf("%d%d" , &a , &b) ;
		if(zuxian(a) == zuxian(b))
			printf("Yes\n") ;
		else
			printf("No\n") ;
	}
	return 0 ;
}
```



---

## 作者：环氧乙烷 (赞：22)

## 没错 我又来发题解了（~~虽然前两次都没通过~~，但是我的自信心任然存在，哈哈哈）
题目很简单，解释都在下面了
```
#include<bits/stdc++.h>//万能头
using namespace std;
int f[10000];//father存父亲根
int find(int);
int main()
{
	int n,m,k,x,y;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		f[i]=i;//开始自己是自己的祖先
	}
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		int xf,yf;
		xf=find(x);
		yf=find(y);
		if(xf!=yf)
			f[xf]=yf;
	}
	for(int i=1;i<=k;i++)
	{
		cin>>x>>y;
		int xf,yf;
		xf=find(x);//找祖先啦
		yf=find(y);
		if(xf==yf)cout<<"Yes"<<endl;//找到同样的祖先那肯定是亲戚啦
		else cout<<"No"<<endl;//不然就不是
	}
	return 0;
}
int find(int x)//直到找到集合代表，也就是自己是自己的祖先
{
	if(x==f[x])
		return x;//找到啦
	return f[x]=find(f[x]);//重点改进，压缩路径，可以省时间，虽然不加也不会超时
}


---

## 作者：AcRapper (赞：22)

 _其实已经有很多并查集的题解了，但我还是想发一个（逃_ 
 
 个人认为自己的代码可读性不错，较适合像我一样的蒟蒻
 
## 言归正传
	然而这样的模板题并没有啥子好言的
    直接上代码。
    
```cpp
#include<cstdio>
#include<iostream>/*老实做人，不用万能头*/ 
using namespace std;
int n,m,p,x,y,fa[10009];/*n，m,p同题设，本题采用在线算法，x，y只是读入过程中的变量。fa[x]存储是元素x的父亲*/ 
int find(int x)//开始了find()，查询元素根节点 
{
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);/*路径压缩操作，找到根节点后直接将元素x的父亲设为祖先。此操作可以将复杂度降到O（log N）*/ 
} 
/*这里拓出去一点，对于find()函数的优化方法除了 路径压缩 ，还有按秩合并。
据说路径压缩和按秩合并一起使用能够使复杂度接近O（N）（其实是O(a(N)) ，a(N)是反阿克曼函数，反阿克曼函数的增长速度远小于log(n)）; 
但这里不进行探讨。"QwQ " 
*/ 
void combine(int a,int b)
{
	fa[find(a)]=find(b);
}/*合并元素a和元素b所在的集合*/ 
int main()//愉快的开始了主函数 */
{
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++)
	{
		fa[i]=i; 
	}/*初始化操作*/ 
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		combine(x,y);
	}/*对读入的亲戚关系进行合并*/ 
	for(int i=1;i<=p;i++)
	{
		cin>>x>>y;
		if(find(x)==find(y))/*判断两人是否为亲戚（想一想，既然进行了路径压缩，为什么不写成if(fa[x]==fa[y])） */
		{
			cout<<"Yes"<<endl;
		}
			
		else
			cout<<"No"<<endl;
	}
	return 0;
} //愉快的结束了 
```

（逃  QwQ

---

## 作者：H_dream (赞：20)

# 题外话
看了看~~大家~~各位大佬的做法，都是用并查集（~~我根本不会用 QAQ~~），所以我就在想能不能用其他做法，在经过亿点思考后，我尝试了 dfs。
# 算法分析
## 题目大意
给出 $n$ 个点和 $m$ 条边，以及 $q$ 次询问，每次询问 $i,j$ 是否在同一个图中。
## 思路
首先把图存起来（这里我用了 vector)。然后对于每次询问，从 $i$ 点开始遍历，是否能到达 $j$ 点。但是，这样跑时间复杂度极高：$O(qnm)$，TLE 到自闭。

在上述方法中，我们可以发现：有许多点被遍历了多次，那我们可以把 $n$ 都遍历一次，这样对于每次询问只需要 $O(1)$ 的时间复杂度。

如何遍历呢？我们可以初始化每个人的祖先是自己，对于每次遍历到的两个点，把两人的祖先合并为较小的一个。然后直接遍历 $1 \sim n$，这虽然能 AC（因为数据太弱了，只有 5000），但是时间复杂度仍然高：$O(nm)$。

## 优化

难道我们一定要遍历 $n$ 个点？

显然不是，在同一个图中，只需要遍历最小的那一个，这样这个图中的所有点的祖先就可以合并，也就是说，只有一个点没有被遍历过才需要遍历。时间复杂度：$O(n)$。

# 代码参考


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5010;
int n,m,q,a[N];
vector<int> v[N];
void dfs(int x){
	for(auto i:v[x]){
		if(a[i]>a[x]){  //合并为更小的
			a[i]=a[x];
			dfs(i);  //只有没被遍历过才需要搜
		}
	}
	return ;
}
signed main(){
	cin>>n>>m>>q;
	for(int i=1;i<=m;++i){
		int x,y; cin>>x>>y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	for(int i=1;i<=n;++i) a[i]=i;//初始化祖先都是自己
	for(int i=1;i<=n;++i){     //从最小的开始
		if(a[i]==i) dfs(i);   //只有没被遍历过才需要遍历
	}
	while(q--){
		int x,y; cin>>x>>y;
		if(a[x]==a[y]) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
} 
```

---

## 作者：王小宇 (赞：10)

### 只是一道模板题，还是很好理解的

看后面的代码

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<algorithm>
#include<string.h>
using namespace std;
struct kkk{
    int father;
}node[5001];//个人习惯用struct来做并查集
int n,m,p;
int getfather(int x)
{
    if (node[x].father==x) return x;//如果它的根节点是自身就返回
    node[x].father=getfather(node[x].father);//否则就继续找根节点
    return node[x].father;//返回根节点
}//做并查集题意允许的话尽量要压缩路径
void merge(int x,int y)
{
    int u,v;
    u=getfather(x);
    v=getfather(y);//取两个人的根节点
    node[v].father=u;//把v的根节点的一整串都挂到u的下面
}
int main()
{
    int i,a,b;
    for (i=1;i<=5001;i++) node[i].father=i;//把并查集初始化
    scanf("%d%d%d",&n,&m,&p);
    for (i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        merge(a,b);
    }//并集
    for (i=1;i<=p;i++)
    {
        scanf("%d%d",&a,&b);
        if (getfather(a)==getfather(b)) printf("Yes\n");
        else printf("No\n");//查询，判断两个人的关系
    }
    return 0;
}
```
~~嘛，还是很简单易懂的一道模板题啊~~


---

## 作者：Martin_MHT (赞：9)

今天我们学习了并查集，老师推荐的入门题——亲戚  
我们重点不是最提，而是讲解并查集的实现。

---

入门并查集：

1. 并操作。将r2的父亲设为r1。
```cpp
inline void unionn(int r1,int r2)
{
	fat[r2]=r1;
}
```
简单。把r2的父亲设为r1，即可连上这一条线。  
2. 查操作。将node的最老祖先求出来。
```cpp
inline int find(int node)
{
	return fat[node]=(fat[node]==node?node:find(fat[node]));
}
```
如果当前节点的父亲等于自己，代表找到了最老的祖先，返回这个值。
否则继续向上寻找这个节点的父亲的父亲。

在这一道题中，并查集基本没有什么变化。套上去就行辣。  
还要注意每一个元素其实一开始就是一个只有以自己为祖先节点的集合，一开始要定义好。

code：

```cpp
#include <cstdio>
using namespace std;
int fat[100005],m,n,q,x,y;
inline int find(int node)//同上
{return fat[node]=(fat[node]==node?node:find(fat[node]));}
inline void unionn(int r1,int r2)//同上
{fat[r2]=r1;}
int main()
{
	scanf("%d %d %d",&n,&m,&q);
	int f1,f2,n1,n2;
	for(register int i=1;i<=n;i++)
		fat[i]=i;//建立每一个集合，只有祖先节点。
	for(register int i=1;i<=m;i++)
	{
		scanf("%d %d",&n1,&n2);
		f1=find(n1);//找爸爸（滑稽）
		f2=find(n2);
		if(f1!=f2)//如果不在一个集合中
			unionn(f1,f2);//连爸爸（滑稽）
	}
	int c1,c2;
	for(register int i=1;i<=q;i++)
	{
		scanf("%d %d",&c1,&c2);
		if(find(c1)==find(c2))//寻找祖先
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}

```
### 并查集是一个比较重要的数据类型，希望大家能越学越好！

## END.

---

## 作者：ღ﹏ﻬ北❦栀 (赞：7)

### 这明摆着是一道并查集的模板题，废话不多说，直接上代码。


------------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 20001
int father[maxn];
int m,n,i,x,y,q,r1,r2;
int find(int x)//这是用递归的方法实现的
{
	if(father[x]!=x)return find(father[x]);
	else return x;
}
  /*非递归
  int find(int x)
{
while(father[x]!=x)x=father[x];
return x;
}
  
  */
void unionn(int x,int y)
{
	father[r2]=r1;
}
int main()
{cin>>n>>m>>q;
for(i=1;i<=n;i++)
father[i]=i;//建立新的集合，其仅有的成员为i
for(i=1;i<=m;i++)
{
	scanf("%d%d",&x,&y);
	int r1=find(x);
	int r2=find(y);
	if(r1!=r2)unionn(r1,r2);
}
for(i=1;i<=q;i++)
{
	scanf("%d%d",&x,&y);
	if(find(x)==find(y))printf("Yes\n");
	else printf("No\n");
}
	return 0;
}
```
说实话，其实这只有20分，因为某些原因，不过不用担心。下面还有优化的


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 20001
int father[maxn];
int m,n,i,x,y,q;
/*
int find(int x)//与上文一样，这是非递归
{
while(father[x]!=x)x=father[x];
return x;
}
*/
int find(int x)//这是递归的方法
{
	if(father[x]!=x)father[x]=find(father[x]);//这是对上文的优化核心--压缩路径
	return father[x];
}
void unionn(int r1,int r2)
{
	father[r2]=r1;
}
int main()
{
	cin>>n>>m>>q;
	for(i=1;i<=n;i++)
	father[i]=i;//建立新的集合，其仅有的成员依旧是i
	for(i=1;i<=m;i++)
	{
		cin>>x>>y;
		int r1=find(x);
		int r2=find(y);
		if(r1!=r2)unionn(r1,r2);
	}
	for(i=1;i<=q;i++)
	{
		cin>>x>>y;
		if(find(x)==find(y))cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	
	}
		return 0;
}
```
此代码Ac，亲测，下面附图。
![](https://www.luogu.org/images/congratulation.png)
希望大家喜欢我这个小蒟蒻的题解，还请大家多多支持，有哪些做的不好的地方可以告诉我，我去改正。


---

## 作者：zcysky (赞：5)

这题非常简单，我们考虑如何用**Link-Cut-Tree**实现。

首先注意到数据范围只有5000，也就是怎么瞎搞应该都能过，那么我们就可以考虑nlogn的LCT。

首先对于每个节点link进LCT，然后询问时只要判断当前的两个节点的根是不是同一个点就好了，代码很短。

```cpp
#include<bits/stdc++.h>
#define N 30005
#define inf 1000000007
using namespace std;
int n,m,h;
struct Link_Cut_Tree{
    int top,c[N][2],fa[N];bool rev[N];
    int q[N];
    int size[N];
    void pushup(int x){size[x]=size[c[x][0]]+size[c[x][1]]+1;}
    void pushdown(int x){
        int l=c[x][0],r=c[x][1];
        if(rev[x]){
            rev[l]^=1;rev[r]^=1;rev[x]^=1;
            swap(c[x][0],c[x][1]);
        }
    }
    inline bool isroot(int x){return c[fa[x]][1]!=x&&c[fa[x]][0]!=x;}
    void rotate(int x){
        int y=fa[x],z=fa[y],l,r;
        l=(c[y][1]==x);r=l^1;
        if(!isroot(y))c[z][c[z][1]==y]=x;
        fa[c[x][r]]=y;fa[y]=x;fa[x]=z;
        c[y][l]=c[x][r];c[x][r]=y;
        pushup(y);pushup(x);
    }
    void splay(int x){
        top=0;
        q[++top]=x;
        for(int i=x;!isroot(i);i=fa[i])q[++top]=fa[i];
        while(top)pushdown(q[top--]);
        while(!isroot(x)){
        int y=fa[x],z=fa[y];
        if(!isroot(y)){
            if(c[y][0]==x^c[z][0]==y)rotate(x);else rotate(y);
        }
        rotate(x);
        }
    }
    void access(int x){for(int t=0;x;t=x,x=fa[x])splay(x),c[x][1]=t;}
    void makeroot(int x){access(x);splay(x);rev[x]^=1;}
    void link(int x,int y){makeroot(x);fa[x]=y;}
    void split(int x,int y){makeroot(x);access(y);splay(y);}
    int find(int x){access(x);splay(x);while(c[x][0])x=c[x][0];return x;}
    void init(int n){for(int i=1;i<=n;i++)size[i]=1;}    
}T;
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    n=read();m=read();h=read();
    T.init(n);
    for(int i=1;i<=m;i++){
        int x=read(),y=read();
        if(T.find(x)!=T.find(y))T.link(x,y);
    }
    while(h--){
        int x=read(),y=read(),xx=T.find(x),yy=T.find(y);
        if(xx!=yy)puts("No");else puts("Yes");
    }
    return 0;
}
```

---

## 作者：Hugo_Minion (赞：5)

这道题不就是并查集的模板题吗？爱动脑的小黄人写完并查集后，突然脑子一转，发现这道题也可以用tarjan缩点啊！  
对于还不懂tarjan的童鞋们，可以去看我同学写的博客：[【模板】Tarjan求强连通分量/求割点/求割边](https://www.luogu.org/blog/codesonic/tarjan)   
简单来说，tarjan就是把每一块强联通分量缩成一个点，使整个有向图变成一个dag图。  
对于这一道题，可以采用tarjan缩点，使整个亲戚关系图中每一个强联通分量缩成一个点（为了方便解释，以下把强联通分量缩成的点简称为“块”），这样一来，属于同一“块”的两个点一定互为亲戚（不难理解），不属于同一“块”的两个点就不是亲戚了。	
不同于普通缩点题的是，这道题的亲戚关系图并不是有向图，而是无向图，所以对于每一条边(u,v)，要连上u->v和v->u，实现上并不难，我采用链式前向星存图。	
附上代码：	
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int maxn=5005;

struct edge{
	int v,next;
}e[maxn*2];			
//链式前向星，由于是无向图，边的数量是m*2

int head[maxn];
int dfn[maxn],low[maxn]; //tarjan的数组
int stack[maxn],ind;	//用栈存储点
bool visit[maxn];		
					//visit[i]表示第i个点是否在栈中
int color[maxn];	//缩点后每一个点属于的“块”
int n,m,p,cnt,tot,num;

void Init(){			//初始化
	memset(head,-1,sizeof(head));
	for(int i=1;i<=m;i++)
		e[i].v=e[i].next=0;
	cnt=0;
}

void Add(int u,int v){	//加边
	e[++cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}

void Tarjan(int x){			//tarjan缩点模板
	dfn[x]=low[x]=++tot;
	stack[++ind]=x;
	visit[x]=true;
	for(int i=head[x];i!=-1;i=e[i].next){
		int v=e[i].v;
		if(!dfn[v]){
			Tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(visit[v]){
			low[x]=min(low[x],dfn[v]);
		}
	}
	if(dfn[x]==low[x]){		//如果这个点是根节点
		num++;
		while(stack[ind+1]!=x){	
			int k=stack[ind--];
			color[k]=num;	
		}	//将属于这个强联通分量的点染成同一种颜色
	}
}

int main(){
	Init();
	scanf("%d %d %d",&n,&m,&p);
	for(int i=1;i<=m;i++){
		int a,b;
		scanf("%d %d",&a,&b);
		Add(a,b);		//由于是无向图，所以要加两条边
		Add(b,a);
	}
	for(int i=1;i<=n;i++)	//对每一个点进行搜索
		if(!dfn[i])
			Tarjan(i);
	for(int i=1;i<=p;i++){
		int a,b;
		scanf("%d %d",&a,&b);
		if(color[a]==color[b])	//属于同一个“块”
			printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```


---

## 作者：Herman526 (赞：4)

**大家第一眼看到这道题，一定都能很快发现，用并查集做这道题是很好的选择。但是，实际上用 bfs 就可以让程序的复杂度摘掉一级 $\log n$，轻松解决这个问题。**

为了理清思路，我们可以换个角度理解题意：给出一个含有 $n$ 个点，$m$ 条边的无向图，有 $p$ 次询问，每次询问 $2$ 个整数 $P_i,P_j$，你需要判断两点间是否连通。

想到这一步，你很自然地便可以想到图的一种操作——遍历。既然是求两点间的连通性，那么，我们何不用一个简单的 bfs 遍历算法，将所有点连接的编号最小点（若一个点没有连接编号小于自己的点，应填自己的编号）记录起来呢？如果这么做，待询问时就可以以 $O(1)$ 的时间复杂度查询（若两点记录的连通点相同则两点连通，否则不连通），并快速得知答案了。这样算法的空间复杂度为 $O(n+m)$，时间复杂度则为 $O(n+m+p)$，可以轻松过掉 $5000$ 以内的数据。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5001],u[5000];
vector<int>p[5001];
int main(){
	int n,m,q;//为防止变量重复，将原题中 p 改为 q
	scanf("%d%d%d",&n,&m,&q);
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		p[x].push_back(y),p[y].push_back(x);//记录每一条边
	}
	for(int i=1;i<=n;i++)
		if(!a[i]){//只要标记过了，就一定是最小的，且其连通点也全被标记过了
			a[i]=i;
			int h=0,t=1;u[0]=i;//h 为队头，t 为队尾，u 为队列
			while(h<t){
			int k=p[u[h]].size();
			for(int j=0;j<k;j++)if(!a[p[u[h]][j]]){//有标记连通点，说明这个点一定被遍历过
				a[p[u[h]][j]]=i;
				u[t]=p[u[h]][j],t++;
			}
			h++;
		}
	}
	while(q--){
		int x,y;
		scanf("%d%d",&x,&y);
		if(a[x]^a[y])puts("No");
		else puts("Yes");
	}
}
```
当然，你如果对 dfs 和链式前向星比较熟悉的话，用那两种方法也没问题（使用链式前向星可以比 `vector` 更快）。不过，**对于 $u,v(u<v)$ 这条边，切记不要只在 $p_u$ 这一容器里记录 $v$ 这个直接连接的点**，因为如果这样记，那么万一存在点 $w(u<w<v)$ 也与 $v$ 连通，那么 $w$ 及其连通的一部分点可能就没法及时得到 $u$ 这一与自己连通的点，从而只能记录编号更大的点，导致查询出错。例如在此种遍历方式下，对于 $1,3$ 这条边，$a_3$ 可以正确地设为 $1$，但此时如果再来 $2,3$ 这条边，那么由于 bfs 遍历在此时的单调递增特性，$a_2$ 只能为 $2$，而不是 $1$（此时 $3$ 这个中转点就被视而不见了）。更严重的错误是，在此之后，$2$ 也肯定会遍历到 $3$ 这个点，$a_3$ 便被设为了 $2$，这更影响了程序的正确性。

看到这里，好奇的你可能要问了：本题考察的是并查集，但为什么恰好能通过图的遍历来做呢？其实，这与查询机制有关。这题的所有询问都是在图的所有边都输入完后进行的，所以，我们可以通过线性级复杂度的遍历预处理，应付每一次询问。但是，如果程序在中途就要询问 $P_i,P_j$ 的连通性的话，最好的方法也只能是在询问时立即遍历 $P_i$ 连接的所有点，此时的时间复杂度可以达到 $O(m^2)$，效率并不高于并查集。但是，即使是在动态询问时，用并查集做，仍能保证平均为 $O(m\log n)$ 的效率，最坏也只是 $O(mn)$，这样至少比暴力遍历来得好。

**总而言之，在静态查询时，某些并查集的题目是可以通过遍历来做的，但并查集也是需要掌握的，因为它在动态查询时可以有非凡的平均效率。**

---

## 作者：Predator_SD (赞：4)

这道题很有思维难度！！！十分有水平！！！


分析题意，可以看出我们需要实现一些集合并查询元素所属集合的关系。经过深思熟虑，我发现，我们可以用树来表示集合！只要构造一片森林就可以表示一些不相交集合！

需要动态加边以及查询树根，我们第一时间就会想到用伸展树维护路径信息，实现一种可以动态加边的树形数据结构：Link-Cut Tree！！！

没错，这道题就是一道动态树神题！

下面放上代码！！！


    
        
        
        
        
                
        
            
            
            
        
            
                
        
        
        
        
        
    
    
    
    
```cpp
    #include<bits/stdc++.h>
    #define maxn 1008611
    using namespace std;
    template<size_t MAXN>
    struct Link_Cut_Tree{
        enum Relation{
            L=0,R=1
        };
        int ch[MAXN][2],pa[MAXN];
        bool rev[MAXN];
        int stk[MAXN],top;
        inline bool isrt(int x){
            return ch[pa[x]][L]!=x&&ch[pa[x]][R]!=x;
        }
        inline void pushdown(int x){
            if(rev[x]){
                rev[x]=false,
                std::swap(ch[x][L],ch[x][R]),
                rev[ch[x][L]]^=1,
                rev[ch[x][R]]^=1;
            }
        }
        inline void rotate(int x){
            int y=pa[x],z=pa[y];
            bool l,r;
            l=ch[y][L]==x?L:R;
            r=l^1;
            if(!isrt(y)){
                if(y==ch[z][L]) ch[z][L]=x;
                else ch[z][R]=x;
            }
            pa[x]=z,pa[y]=x,
            pa[ch[x][r]]=y,
            ch[y][l]=ch[x][r],
            ch[x][r]=y; 
        }
        inline void splay(int x){
            top=1,stk[top]=x;
            for(int i=x;!isrt(i);i=pa[i]) stk[++top]=pa[i];
            for(int i=top;i;--i) pushdown(stk[i]);
            while(!isrt(x)){
                int y=pa[x],z=pa[y];
                if(!isrt(y)){
                    if((ch[y][L]==x)^(ch[z][L]==y)) rotate(x);
                    else rotate(y);
                }
                rotate(x); 
            }
        }
        inline void access(int x){
            int t=0;
            while(x){
                splay(x);
                ch[x][R]=t;
                t=x,x=pa[x];
            }
        }
        inline void reverse(int x){
            access(x),splay(x);
            rev[x]^=1;
        }
        inline void link(int x,int y){
            reverse(x),pa[x]=y,splay(x);
        }
        inline void cut(int x,int y){
            reverse(x),access(y),splay(y);
            ch[y][L]=pa[x]=0;
        }
        inline int findrt(int x){
            access(x),splay(x);
            while(ch[x][L]) x=ch[x][L];
            return x;
        }
    };
    Link_Cut_Tree<maxn> T;
    inline int read(){
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    int n,m,p;
    int main(){
        n=read(),m=read(),p=read();
        for(register int i=1;i<=m;++i){
            register int x=read(),y=read();
            if(T.findrt(x)!=T.findrt(y)) T.link(T.findrt(x),T.findrt(y));
        }
        for(register int i=1;i<=p;++i){
            register int x=read(),y=read();
            if(T.findrt(x)==T.findrt(y)) puts("Yes");
            else puts("No");
        }
        return 0;
}
```

---

## 作者：Sooke (赞：3)

本题最重要的一点是“亲戚的亲戚就是亲戚”，这也是并查集最明显的特点，所以，~~去普及练习场的模板题复制粘贴模板来吧！（雾）~~

用尽了我认为一切适用于本题的优化，并查集的路径压缩，和读入优化 Orz，这些应该不难理解。

附赠 3ms 代码：

```cpp
#include <cstdio>
int v[5001];
inline int InP()
{
    char C;
    int N=0;
    do C=getchar(); while(C > '9' || C < '0'); 
    while('0' <= C && C <= '9') N=N*10 + (C-'0') , C=getchar();
    return N;
}
int Find(int n)
{
    return (v[n] == n) ? n : (v[n]=Find(v[n]));
}
int main()
{
    char *s[2]={"No" , "Yes"};
    int n=InP() , m=InP() , q=InP() , a , b;
    for(int i=1 ; i <= n ; i++) v[i]=i;
    for(int i=1 ; i <= m ; i++)
        a=InP() , b=InP() , v[Find(a)]=v[Find(b)];
    for(int i=1 ; i <= q ; i++)
        a=InP() , b=InP() , printf("%s\n" , s[Find(a) == Find(b)]);
}
```

---

## 作者：「QQ红包」 (赞：3)

非常简单的并查集入门题哦！！！


太裸了……裸得我都不想说什么了……

```delphi

var f:array[1..5000] of longint;
   i,n,m,p,a,b:Longint;
function gf(u:longint):longint;
begin
   if f[u]=u then exit(u) else f[u]:=gf(f[u]);
   exit(gf(f[u]));
end;
procedure union(u,v:longint);//合并两棵树
var fu,fv:longint;
begin
   fu:=gf(u);
   fv:=gf(v);
   if fu<>fv then f[fu]:=fv;
end;
begin
   read(n,m,p);
   for i:=1 to n do
       f[i]:=i;//初始化
   for i:=1 to m do
   begin
       read(a,b);
       if gf(a)<>gf(b) then
                       union(a,b);
   end;
   for i:=1 to p do
   begin
       readln(a,b);
       if gf(a)<>gf(b) then writeln('No') else writeln('Yes')//输出
   end;
end.

```

---

## 作者：Lixf_Lixf (赞：2)

考虑这样一个问题。

#### 给出某个亲戚关系图，判断任意给出的两个人是否具有亲戚关系。

比较朴素的想法是连边并进行跑图。但对于大数据来说跑图并不能满足我们对时间上的需求。

所以，考虑到我们并不需要两个人具体的关系，我们只需要一种方法来满足将两个或两组亲戚并在一起的操作。这样我们可以快速得到两个人是否在一个集合内。

并查集应运而生。

最基本的并查集可以满足以下两种操作:

1. 将两个原来不在一起的集合进行合并。

1. 查询某点所在集合的顶点。
-------------------

### 实现

- 定义fa[ ]数组为当前每一个点所在集合的顶点。

- 对于输入的两个点，将其中一个人的顶点“挂”到另一个集合中

- 查询时只要判断两者祖先是否相同。
-------------------

#### 例题 #1 

[P1551 亲戚](https://www.luogu.org/problem/P1551)

因为我们并不需要亲戚间的具体关系，所以引出第一个优化：

-----------
## 路径压缩

- 我们可以发现，我们查询两点的关系时只需要其顶点。

- 那么直接将一个集合的顶点的顶点设为另一个集合的顶点即可。

- 复杂度得到有效降低。

#### Code：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e5+5;
int n,m,p;
int fa[maxn];

int get(int x){
	if(x==fa[x]) return x;
	return fa[x]=get(fa[x]);
}

void merge(int u,int v){fa[get(u)]=get(v);}

int main(){
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		merge(u,v);
	}
	for(int i=1;i<=p;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		if(get(u)==get(v)) puts("Yes");
		else puts("No");
	}
	return 0;
}
```

---

## 作者：qqqevinxxz (赞：2)

### ~~本蒟蒻的第一篇题解，请大佬勿喷~~
一道~~很水~~的并查集
# ###并查集是什么？？？
并查集（union-find set）是一种用于分离集合操作 的抽象数据类型。
### 详见洛谷3367
并查集模板
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int f[10000+1];//记录父亲 
int find(int k)//寻找祖先 
{
	if(f[k]==k) return k;//若自己就是祖先，则直接return 
	else return f[k]=find(f[k]);//否则递归自己的父亲 ,重点改进，压缩路径，可以省时间.
}
void merge(int a,int b)//合并
{
	f[find(a)]=find(b);//将a作为b的儿子 
	return;
}
 ```cpp
有了这两个模板，完全就是一道弱鸡题
附：AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[5050];
int find(int z)
{
	if(f[z]==z) return z;
	else return f[z]=find(f[z]); 
}
void merge(int a,int b)
{
	f[find(a)]=find(b);
	return;
}
int main()
{
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i+=1) f[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		merge(x,y);
	}
	for(int i=1;i<=p;i++)
	{
		int x,y;
		cin>>x>>y;
		if(find(x)==find(y)) cout<<"Yes"<<endl;
		else cout<<"No"<<endl; 
	}
	return 0;
}
```
~~求管理员大佬给过~~

---

## 作者：AlexanderPitt (赞：2)

题目大意是，给出N个人M个关系P个询问，回答Pi和Pj是否具有亲戚关系。

**我们可以把初始时候每个人看做一个无边的点，下来根据给出的亲戚关系，将各个点进行连接，而所有连接起来的点组成的图可以视为一个家族。**

那么就可以轻松的想到并查集的做法了（并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。）。

将两个有亲戚关系的人连接起来就成了。

所以我们可以用一个数组表示一个人他的家族中的一个人（其他人或者自己）

所以可以先F[i]=i；初始情况下每个人和其他人没有亲戚关系，所以存储自己。

不过要注意的是，必须得让一个家族的人数组中存储的人相同，想一想为什么？

```cpp
int find(int x)
{
    if(fa[x]!=x)
    {
    return	fa[x]=find(fa[x]);  //将统一家族的人的数组值存储为一个人
    }
    else 
    return x;
}
void he(int x,int y)
{
    fa[find(x)]=find(y);           //合并操作
}
```
在判断询问时候只用find(x)与find(y)是否相同即可

这道题就出来了

以下是AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,fa[10005],k;
int find(int x)
{
    if(fa[x]!=x)
    {
    return	fa[x]=find(fa[x]);
    }
    else 
    return x;
}
void he(int x,int y)
{
    fa[find(x)]=find(y);
}
int main() 
{         
    cin>>n>>m>>k;
    for(int t=1;t<=n;t++)
    {
        fa[t]=t;
    }
    for(int t=1;t<=m;t++)
    {
        int w,e;
        cin>>w>>e;
        he(w,e);
     } 
     for(int i=1;i<=k;i++)
     {
     	int q,w;
     	cin>>q>>w;
     	if(find(q)==find(w))
     	cout<<"Yes"<<endl;
     	else
     	cout<<"No"<<endl;
     }
    return 0;
}

```

---

## 作者：Aehnuwx (赞：2)

**并查集模板题**（当然你非要反驳我说那道[【模板】并查集](https://www.luogu.org/problemnew/show/P3367)是并查集模板题的话我也没办法）

思路就是当读入$Mi$和$Mj$的时候就用$find$函数合并一下$Mi$和$Mj$，当之后读入$Pi$和$Pj$的时候就判断$Pi$和$Pj$是否在一个集合里（或者你通俗地理解就是说是否合并在一块了），如果在一块就输出$Yes$，反之输出$No$。

### 要注意的是在查找祖先时需要路径压缩！

$code$

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;

#define il inline//宏定义
const int maxN = 1e3 * 5 + 10;//1e3=1000
il int find(int);//查询函数
il void join(int, int);//合并函数
int pre[maxN];//存放每个数的祖先
int main() {
    int n, m, p;
    scanf("%d%d%d", &n, &m, &p);
    for(int i = 1; i <= n; i ++)
        pre[i] = i;//一开始每个数的祖先都是自己
    for(int i = 1; i <= m; i ++) {
        int Mi, Mj;
        scanf("%d%d", &Mi, &Mj);
        join(Mi, Mj);//合并Mi和Mj
    }
    for(int i = 1; i <= p; i ++) {
        int Pi, Pj;
        scanf("%d%d", &Pi, &Pj);
        if(find(Pi) == find(Pj))//如果Pi和Pj的祖先相同
            printf("Yes\n");//输出Yes
        else printf("No\n");//反之输出No
    }
    return 0;
}
il int find(int x) {//我用的是循环找祖先，也可以用递归来实现
    int r = x;
    while(r != pre[r])
        r = pre[r];//如果它的祖先还不是自己的话就继续找祖先
    int p;
    while(x != r) {
        p = pre[x];
        pre[x] = r;
        x = p;
    }//路径压缩
    return r;//返回祖先
}
il void join(int x, int y) {
    int fx = find(x), fy = find(y);//先把祖先找到
    if(fx != fy) pre[fx] = fy;//如果祖先不同就合并
}
```

---

## 作者：zxzxxzz (赞：2)

### 非递归的路径压缩

本题数据较小，但如果数据再扩大，就会崩栈。这里提供一种非递归的路径压缩。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int f[500001],n,m,p,a,b,ans[500001];
int find(int x)
{
    int k=x;
    while(f[x]!=x) x=f[x];
    while(f[k]!=x)
    {
        int temp=f[k];
        f[k]=x;
        k=temp;
    }
    return x;
}
void unionn(int x,int y)
{
    f[y]=x;
}
int main()
{
    scanf("%d%d%d",&n,&m,&p);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        int temp1=find(a);
        int temp2=find(b);
        if(temp1!=temp2) unionn(temp1,temp2);
    }
    for(int i=1;i<=p;i++)
    {
        scanf("%d%d",&a,&b);
        if(find(a)==find(b)) ans[i]=1;
    }
    for(int i=1;i<=p;i++)
        if(ans[i]==1) printf("Yes\n");
        else printf("No\n");
    return 0;
}
```

---

## 作者：Apojacsleam (赞：2)

### 【题目背景】

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

### 【题目描述】

规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。

### 【输入输出格式】
### 【输入格式】

第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。

以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。

接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。

### 【输出格式】

P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。

### 【输入输出样例】

### 【输入样例】

	6 5 3
	1 2
	1 5
	3 4
	5 2
	1 3
	1 4
	2 3
	5 6

### 【输出样例】

	Yes
	Yes
	No



### 【说明】
非常简单的并查集入门题哦！！！

### 【解题思路】

看到这个题的时候想起的基本算法有：Floyd求连通性、搜索、并查集

再瞄一眼数据范围，Floyd肯定是GG了，搜索O（N^2）有点勉强的感觉，并查集加了路径压缩后接近线性，好了就他了

吐槽下，感觉数据范围有点小了，1e6的数据感觉正好，甚至可以设置成1e7

废话不多说下面沾AC代码：

```cpp
/*
	copy by Apojacsleam
*/
#include<cstdio>
#include<cctype>
#define N 5001
int readin();
int n,m,p,fa[N];
int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
int main()
{
	n=readin();m=readin();p=readin();
	for(register int i=1;i<=n;i++) fa[i]=i;
	int a,b;
	for(register int i=1;i<=m;i++)
	{
		a=readin();b=readin();
		int r1=find(a),r2=find(b);
		if(r1!=r2) fa[r2]=r1;
	}
	for(register int i=1;i<=p;i++)
	{
		a=readin();b=readin();
		int r1=find(a),r2=find(b);
		if(r1==r2) puts("Yes");
		else puts("No");
	}
	return 0;
}
int readin()
{
	int fz=0;char ch=getchar();bool XX=true;
	for(;!isdigit(ch);ch=getchar())
	  if(ch=='-') XX=false;
	for(;isdigit(ch);ch=getchar()) fz=(fz<<3)+(fz<<1)+ch-48;
	return XX?fz:(~fz)+1;
}


```

---

## 作者：_谦退_ (赞：1)

看到这么多大佬，准备FA♂一篇题解的蒟蒻有点瑟瑟发抖

其实这道题很好理解，一道典型的并查集

这道题可以这么理解：

首先，在开始题目中给的数据中创造一个亲戚关系网，谁认谁作父都可以，但是认父的方向要一致（认贼~~chen_zhe~~做父），溜了~

当你询问两人的关系时，你可以顺着两人的亲戚线一步一步向上查找，直到查到两人的祖宗为止（就是没有向上的一层亲戚关系了，他的直接亲戚就是他自己，话说祖宗是什么鬼）

如果两人的祖宗是一个人，也就是findd(x)==findd(y)时，就输出yes，反之则输出no。

好了，二话不说，上代码！！

```c
#include<bits/stdc++.h>//万能头万岁！！！
using namespace std;
const int MAXN = 10086;
int p1,p2,p3,p4;
int f[MAXN];//表示x的直接亲戚
int m,n,k;
int findd(int x)//这是查找祖宗的函数
{
	if(x==f[x]) return x;//如果x没有父亲了，就说明x自己就是祖宗，返回x
	return findd(f[x]);//一步一步关系递进，知道找到祖宗为止
}
void joinn(int x,int y)
{
	x=findd(x);//先查到x的祖宗
	y=findd(y);//查到y的祖宗
	f[y]=x;//让y的祖宗认x的祖宗为父，y的亲戚网自然也和x的连一起了
}
int main()
{
	cin>>n>>m>>k;//输入就不多讲了
	for(int i=1;i<=n;i++)
	  f[i]=i;//注意！！这里初始化时所有人的直接亲戚都是他自己
	for(int i=1;i<=m;i++)
	{
		cin>>p1>>p2;
		joinn(p1,p2);//这里合并关系非常重要！
	}
	for(int i=1;i<=k;i++)
	{
		cin>>p3>>p4;
		if(findd(p3)==findd(p4)) cout<<"Yes"<<endl;//如果两人祖宗相同，输出yes，否则输出no
		else cout<<"No"<<endl;
	}
	return 0;//结束
}
```

---

## 作者：康娜卡姆依 (赞：1)

赤裸裸的并查集水题。。。

下面献上鄙人简(chou)洁(lou)的代码——

```cpp
#include<bits/stdc++.h> //调用万能库
using namespace std;
int n,m,k,f[10001];
int find(int x)  
//压缩路径查找子程序，更便捷，大致思路就是如果当前位置是所寻找节点，则return，否则将当前位置变成初始位置，继续向上......
{
    if(x==f[x]) return x;  //也可以用while做，但递归更“优美”2333//如果找到了就返回
    else f[x]=find(f[x]); //否则递归继续查找
    return f[x];
}
int main()
{
    cin>>n>>m>>k; //读入
    for(int i=1;i<=n;i++)  //初始化，自己的祖先是自己，否则所在集合是空的
    f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int a,b;
        cin>>a>>b;   //读入
        f[find(a)]=find(b);
 /*将集合合并，简单题目中，并不需要太多的子函数和复杂的步骤，两者的一对祖先简单穿插起来，就可以替代繁琐的合并步骤(这很important）*/
    }
    for(int i=1;i<=k;i++)
    {
        int a,b;
        cin>>a>>b;
        if (f[find(a)]==f[find(b)]) cout<<"Yes"<<endl;  //利用上面合并的优势，再通过祖先结点是否相同判断是否是亲戚，输出
        else cout<<"No"<<endl; //输出
    }
    return 0;
}
总结：既然是一道**入门题**，那么我们就需要用简单的思路解答，而不需要太繁琐
```

---

## 作者：Idvz (赞：1)

直接启发式合并的并查集搞一搞既可以了，时间复杂度$O(PlogN)$


```cpp
#include <cstdio>

using namespace std;

const int MAXN = 5000 + 10;

int fa[MAXN],rank[MAXN],m,n,p,x,y;

int find(int x) { return fa[x] == x? x : find(fa[x]);} //不要路径压缩

void unionn(int x,int y)
{
    if(x==y)    return ;
    if(rank[x]>rank[y]) fa[y] = x; //将高度小的树合并到高度大的树
    else {
        fa[x] = y;
        if(rank[x] == rank[y]) rank[y] ++;  //注意高度相同的情况
    }
}


int main()
{

    scanf("%d%d%d",&n,&m,&p);
    
    for(int i = 1; i <= n; i++)    fa[i] = i;
    
    for(int i = 1; i <= m; i++)
    {
        scanf("%d%d",&x,&y);
        int xx = find(x) , yy = find (y);
        if(xx != yy) unionn(xx,yy);
    }
    for(int i = 1; i <= p; i++)
    {
        scanf("%d%d",&x,&y);
        if(find(x) == find(y))    puts("Yes"); //回答询问
        else puts("No");
    }
    return 0;
}
```

---

## 作者：PTC06 (赞：1)

标准并查集，水到爆...我这样的蒟蒻都能一次AC？感觉像是普及-的难度啊

先讲基本思路：

 ![](https://cdn.luogu.com.cn/upload/pic/3433.png) 

首先，我们看一下图。这里，Somebody2的祖先可以看作是机智的PTC。

```cpp
int sch(int x)
{
    if(pre[x]!=x) pre[x]=sch(pre[x]);
    return pre[x];
}
```
这个部分的代码就是用来判断，对于每一个人，他的祖先（亲戚）是谁。那么不难理解，这样子找祖先，Somebody3的祖先永远不可能找到PTC。因此，我们就可以用来判断一个人是否是另一个人的亲戚。思路：如果祖先相同，那么就是亲戚，否则就不是了。
这个部分讲完了。接下来，需要讲一下关于合并的知识：

```cpp
void join(int x,int y)
{
    if (sch(x)!=sch(y)) pre[sch(x)]=sch(y);
}
```
其实也不难理解，大意就是如果两个人现在没有发现有亲戚关系（而数据要我们把他们合并成亲戚），那么pre[sch(x)]=sch(y)。意思就是x这个人的祖先变成y的祖先了，两人现在就有亲戚关系了。
主要思路讲完了，下面是代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,p,i,paohui,sanhao,tt,t1,pre[5005];
int sch(int x)                //这里查找每一个人的祖先（亲戚）
{
    if(pre[x]!=x) pre[x]=sch(pre[x]);
    return pre[x];
}
void join(int x,int y)          //这里用来将两人合并成亲戚
{
    if (sch(x)!=sch(y)) pre[sch(x)]=sch(y);
}
int main()
{
    cin>>n>>m>>p;
    for (i=1;i<=n;i++) pre[i]=i;          //初始化，不可忘。否则提交上去会一片WA...
    for (i=1;i<=m;i++)
    {
        cin>>paohui>>sanhao;             
        join(paohui,sanhao);         //将给出的两个亲戚合并。
    }
    for (i=1;i<=p;i++)
    {
        cin>>tt>>t1;
        if (sch(tt)==sch(t1)) cout<<"Yes"<<endl; else cout<<"No"<<endl;         //如果两人祖先一样（是亲戚）就Yes,否则No.
    }
}
```

---

## 作者：dzysc (赞：1)

题解很简单，这就是标准的并查集23333不过楼主还是错了一次应为Yes而不是YES。。。

并查集主要是一个find递归函数其他没什么

直接上代码C++




    
    
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <string>
using namespace std;
int n,m,p;
int father[6000];
int find(int x)
{
    if(father[x]!=x) father[x]=find(father[x]);
    return father[x];
}
int main()
{
    cin>>n>>m>>p;
    for(int i=1;i<=n;i++)
    {
        father[i]=i;
    }
    for(int i=1;i<=m;i++)
    {
        int p,q;
        cin>>p>>q;
        p=find(p);
        q=find(q);
        father[p]=q;
    }
    for(int i=1;i<=p;i++)
    {
        int p,q;
        cin>>p>>q;
        p=find(p);
        q=find(q);
        if(p==q)
        cout<<"Yes"<<endl;
        else
        cout<<"No"<<endl;
    }
    return 0;
}
```

---

## 作者：吊打sym (赞：1)

数组实现就好啦！！

一定要读完再一起输出。

我WA了4遍啊！！！

第五遍终于AC啦！！

蒟蒻的一天啊！！



```cpp
#include <iostream>
#include<cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n,m,p;
int a[5001];
int b[5001],c[5001];
void union1(int ii,int jj)
{
    for (int i=1;i<=n;i++)
    {
        if (jj != i)
            if (a[jj]==a[i]) a[i]=a[ii];
    }
    a[jj]=a[ii];
}
int main()
{
    int qin,qi,i;
    scanf("%d%d%d",&n,&m,&p);
    for (i=1;i<=n;i++)
    {
        a[i]=i;
    }
    for (i=1;i<=m;i++)
    {
        scanf("%d%d",&qin,&qi);
        if (a[qin]!=a[qi]) union1(qin,qi);
    }
    for (i=1;i<=p;i++)
    {
        scanf("%d%d",&b[i],&c[i]);
    }
    for (i=1;i<=p;i++)
    {
        if (a[b[i]]==a[c[i]])
            printf("Yes\n"); else printf("No\n");
    }
   return 0;
}

```

---

## 作者：世界经典 (赞：1)

这题用的方法是并查集，判断是否同一亲戚，因此，我们要将具有亲戚关系的人标记为同一父节点，在每次查询的时候，让次节点指向最终的父节点。

例如

![1](https://s2.ax1x.com/2019/07/28/elu2TA.png)

现在，6和5有关系，则变成

![2](https://s2.ax1x.com/2019/07/28/elu5Sf.png)

在路径查询时父节点会更新，最终变成

![3](https://s2.ax1x.com/2019/07/28/eluTOg.png)

```pascal
var
 n,m,p,i,x,y,fx,fy:longint;
 f:array[0..5001] of longint;//父节点数组
function sf(t:longint):longint;//查找父节点
begin
  if f[t]<>t then sf:=sf(f[t])//不是最终的，查找上一层的父节点
   else sf:=t;//因为最终的父节点肯定是指向自己的，所以当f[t]=t时t即最终的父节点
  f[t]:=sf;//随时更新父节点
end;
begin
  read(n,m,p);
  for i:=1 to n do f[i]:=i;//起先都指向自己
  for i:=1 to m do
  begin
    read(x,y);
    fx:=sf(x);
    fy:=sf(y);
    if fx<>fy then f[fx]:=fy;//如果这两个不是同一父节点，则将一个的父节点替换成另一个的父节点
  end;
  for i:=1 to p do
  begin
    read(x,y);
    fx:=sf(x);
    fy:=sf(y);
    if fx=fy then writeln('Yes')//同一父节点即为亲戚
     else writeln('No');
  end;
end.
```

---

## 作者：HeartBlock_Love (赞：0)

【算法分析】
	将每个人抽象成为一个点，数据给出M个边的关系，两个人是亲戚的时候两点间有一条边。很自然的就得到了一个N个顶点M条边的图论模型，注意到传递关系，在图中一个连通块中的任意点之间都是亲戚。对于最后的Q个提问，即判断所提问的两个顶点是否在同一个连通块中。
    
　　用传统的思路，可以马上反应过来，对于输入的N个点M条边，找出连通块，然后进行判断。但这种实现思路首先必须保存M条边，然后再进行普通的遍历算法，效率显然不高。再进一步考虑，如果把题目的要求改一改，对于边和提问相间输入，即把题目改成：
  
　　　第一行是N，M。N为问题涉及的人的个数(1≤N≤20000)。这些人的编号为1,2,3,…, N。下面有M行(1≤M≤2 000 000)，每行有三个数ki,ai, bi。ai, bi表示两个元素，ki为0或1，ki为1时表示这是一条边的信息，即ai, bi是亲戚关系；ki为0时表示是一个提问，根据此行以前所得到的信息，判断ai, bi是否亲戚，对于每条提问回答Yes或者No。
   
	这个问题比原问题更复杂些，需要在任何时候回答提问的两个人的关系，并且对于信息提示还要能立即合并两个连通块。采用连通图思想显然在实现上就有所困难，因为要表示人与人之间的关系。

用集合的思路，对于每个人建立一个集合，开始的时候集合元素是这个人本身，表示开始时不知道任何人是他的亲戚。以后每次给出一个亲戚关系时，就将两个集合合并。这样实时地得到了在当前状态下的集合关系。如果有提问，即在当前得到的结果中看两元素是否属于同一集合。

并查集的路径压缩

　　此种做法就是将元素的父亲结点指来指去地指，当这棵树是链的时候，可见判断两个元素是否属于同一集合需要O(n)的时间，于是路径压缩产生了作用。
  
　　路径压缩实际上是在找完根结点之后，在递归回来的时候顺便把路径上元素的父亲指针都指向根结点。
  
  ```
#include<iostream>
　　#include<cstdio>
　　using namespace std;
　　#define maxn 20001
　　int father[maxn];
　　int m,n,i,x,y,q;
　　/*
　　int find(int x)                  //用非递归的实现
　　{
　　    while (father[x] != x) x= father[x];
　　    return x;
　　}
　　*/
　　int find(int x)                  //用递归的实现
　　{
　　    if (father[x] != x) father[x] = find(father[x]);  //路径压缩
　　    return father[x];
　　}
　　void unionn(int r1,int r2)
　　{
　　    father[r2] = r1;
　　}
int main()
　　{
　　    freopen("relation.in","r",stdin);
　　    freopen("relation.out","w",stdout);
　　    cin >> n >> m;
　　    for (i = 1; i <= n; i++)
　　        father[i] = i;           //建立新的集合，其仅有的成员是i
　　    for (i = 1; i <= m; i++)
　　    {
　　        scanf("%d%d",&x,&y);
　　        int r1 = find(x);
　　        int r2 = find(y);
　　        if (r1 != r2) unionn(r1,r2);
　　    }    
　　    cin >> q;
　　    for (i = 1; i <= q; i++)
　　    {
　　        scanf("%d%d",&x,&y);;
　　              if (find(x) == find(y)) printf("Yes\n");
　　                       else printf("No\n");
　　    }
　　    return 0;
　　}
```


---

## 作者：dinosaurgy (赞：0)

看到很多dalao写了so多的程序，在此只能写一个标准并查集了。。。

[建议去这里刷一刷，适合新手（像我这种）](http://ybt.ssoier.cn:8088/index.php)

这里有递归与非递归两种解法：

非递归函数：
```cpp
int f(int x){
	while(father[x]!=x) x=father[x];
	return x;
}//使用while判断
```
递归函数：
```cpp
int f(int x){
	if(father[x]!=x) return f(father[x]);//递，判断父亲
	else return x;//归
}
```
接下来上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define maxn 5005
int father[maxn];
int n,m,p,i,x,y;
//--------------------------------------
int f(int x){	//用递归实现并查集的查找 
	if(father[x]!=x) return f(father[x]);
	else return x;
}
//--------------------------------------
//注意这一段！后方高能
/*int f(int x){
	while(father[x]!=x) x=father[x];
	return x;
}*/
void u(int r1,int r2){
	father[r2]=r1;
} 

int main(void){
	cin>>n>>m>>p;
	for(i=1;i<=n;i++) father[i]=i;//建立新的集合，其仅有成员是i。
	for(i=1;i<=m;i++) {
		scanf("%d%d",&x,&y);//数据太大，用cin要卡。
		int r1=f(x);
		int r2=f(y);
		if(r1!=r2) u(r1,r2);//存入亲戚关系。
	}
	for(int i=1;i<=p;i++){
		scanf("%d%d",&x,&y);
		if(f(x) == f(y)) printf("Yes\n");//判断是否有亲戚关系
		else printf("No\n");
	}
	return 0;
}
```
！！！~~高能出现~~

接下来是路径压缩，其核心是改f函数：
```
int f(int x){//优化核心，大大减少时间复杂度
if(father[x]!=x) father[x]=f(father[x]);
return father[x];
}
```



---

## 作者：Delta_Cosh (赞：0)

对用户 胡哲迩 代码提出的部分优化。

基本思想还是**并查集**，然后用**递归**的方式搜索，即

```pascal
function getf(e:integer):integer;
begin
        if (f[e]<>e) then f[e]:=getf(f[e]);
        exit(f[e])
end;
```
具体代码如下，我定义的变量较少，对代码长度有一定优化。

比如说 胡哲迩 的这一部分代码：

```pascal
for i:=1 to m do
    begin
      readln(t,k);
      j:=fa(t);
      j1:=fa(k);
      if j<>j1 then f[j]:=j1;
    end;
```
我改成了

```pascal
for i:=1 to m do 
        begin
                readln(x,y);
                if (getf(x)<>getf(y)) then 
                        f[getf(x)]:=getf(y);
        end;
```
反正我觉得好看一些qwq。。

```pascal
program p1551;
var
        n,m,p,i,x,y,e:integer;
        f:array[1..6000] of integer;
function getf(e:integer):integer;
begin
        if (f[e]<>e) then f[e]:=getf(f[e]);
        exit(f[e])
end;
begin
        read(n,m,p);
        for i:=1 to n do 
                f[i]:=i;
        for i:=1 to m do 
        begin
                readln(x,y);
                if (getf(x)<>getf(y)) then 
                        f[getf(x)]:=getf(y);
        end;
        for i:=1 to p do
        begin
                readln(x,y);
                if (getf(x)<>getf(y)) then
                        writeln('No')
                else
                        writeln('Yes');
        end
end.
```
绝对标准格式的代码。


---

## 作者：L_X_T (赞：0)

pascal正解 —— 并查集与最短路径，

**居然是裸的并查集！！！**

```cpp
var
  f:array[1..5000] of longint;
  n,m,k,t,i,j,h,j1:longint;
function fa(x:longint):longint;
begin
  if f[x]=x then fa:=f[x]
            else fa:=fa(f[x]);
end;//查找
begin
  readln(n,m,h);//读入
  for i:=1 to n do
    f[i]:=i;
  for i:=1 to m do
    begin
      readln(t,k);
      j:=fa(t);
      j1:=fa(k);
      if j<>j1 then f[j]:=j1;
    end;
  for i:=1 to h do
    begin
      readln(t,k);
      if fa(t)=fa(k) then writeln('Yes')
                   else writeln('No');
    end;
end.
```

---

## 作者：dudujerry (赞：0)

并查集的问题！

因为有些名字重名！

于是！

我加了两个下划线！-\_-

先是创建并查集各个函数！

然后
如果是亲戚就放到一棵树里面！

然后
就可以  很方  便的查询是不是亲戚了！

因为加了两个下划线...

所以代码有些惨不忍睹...

总之下面代码！

```cpp
#include<iostream>
using namespace std;
int __par[5001],__rank[5001];
void __init(int N)//加载
{
    for(int i=0;i<N;i++)
    {
        __par[i]=i;
    }
}
int __find(int x)//查询根节点
{
    if(__par[x]==x)//如果找到
    {
        return x;
    }
    else//不然继续找
    {
        return __find(__par[x]);
    }
}
void __unionn(int x,int y)//合并
{
    x=__find(x);
    y=__find(y);
    if(__rank[x]>__rank[y])//优化 如果深度小，则接到另外的上去
    {
        __rank[x]=__rank[y];
        __par[y]=x;
    }
    else
    {
        __par[x]=y;
        if(__rank[x]==__rank[y])
        {
            __rank[y]++;
        }
    }
}
bool __same(int x,int y)//查询根节点 如果一样则返回1，反之返回0
{
    return __find(x)==__find(y);
}
int main()
{
    int n,m,p,a,b;
    __init(5001);初始化
    cin>>n>>m>>p;
    for(int i=0;i<m;i++)
    {
        cin>>a>>b;
        if(!__same(a,b))如果不是一棵树
        __unionn(a,b);加成一棵树
    }
    for(int i=0;i<p;i++)
    {
        cin>>a>>b;
        if(__same(a,b))如果是亲戚（一棵树）
        {
            cout<<"Yes"<<endl;
        }
        else
        {
            cout<<"No"<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Hydra_ (赞：0)

分析
--
这道题目就是一个并查集稍加修饰的一个板子题。从题目描述中我们可以知道，若两个人是亲戚关系，那么他们一定在同一个集合里面。那么就ok了，对于两个亲戚关系的人我们进行 并 的操作，然后对于两个判断的人就找他们的根结点就ok了。是不是就，很简单了？顷刻之间就，做出来了。

## 代码 ##


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,father[5200];
//n，m，p的解释见题，father数组用来记录该结点属于哪个集合（存储根结点/父亲结点）
struct node
{
    int x,y;
}a[5200];
//a数组用来存储每对亲戚关系。
int getfather(int k)
{
    if(father[k]==k)return k;
    //如果一个点的父亲是自己，那么它就是根结点
    father[k]=getfather(father[k]);
    //这里是记忆化，压缩路径。
    return father[k];
}
//getfather就是找到该结点的根结点，并记忆
void bing(int k,int l)
{
    int fx,fy;
    fx=getfather(k);
    fy=getfather(l);
    father[fx]=fy;
}
//并操作。对两个点的根结点进行如下操作：一个根结点变成另外一个点的儿子结点。那么两个集合就并为一个集合了。
bool cha(int k,int l)
{
    int fx,fy;
    fx=getfather(k);
    fy=getfather(l);
    return fx==fy;
}
//查操作。求出两个结点的根结点，如果相同，那么他们属于一个集合。
void read()
{
    scanf("%d%d%d",&n,&m,&p);
    int x,y;
    for(int i=1;i<=n;i++)
    father[i]=i;
    //每个结点的根结点默认是自己（这就可以理解为有n个集合，每个点是一个集合）
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        bing(x,y);
        //读入亲戚关系后，并他。
    }
}
//读入
void work()
{
    int x,y;
    for(int i=1;i<=p;i++)
    {
        scanf("%d%d",&x,&y);
        if(cha(x,y))printf("Yes\n");
        else printf("No\n");
        //读入后查询
    }
}
int main()
{
    read();//读入
    work();//工作
    return 0;
}
```

---

## 作者：龘龘龘龘龘龘 (赞：0)

这是一道入门的题目，很普遍，很多C++书上的例题，这题也基本诠释了并查集的基本操作和作用，不过我在这先讲一下我的方法，一种优化，并查集的路径压缩（如果不知道的可以去百度搜一搜，很方便复杂度几乎为常数），通常用这个方法是不会超时的；

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define maxn 20001
int father[maxn];
int n,m,i,x,y,q;
int find(int x)
{
    if(father[x]!=x) father[x]=find(father[x]);//路径压缩，优化的核心
    return father[x];
```
}//这里也可以用非递归的方法做，将if改为while， father[x]=find(father[x])改为x=father[x];然后返回x，就行了；
```cpp
void unionn(int r1,int r2)//合并两个集合
{
    father[r2]=r1;
}
int main()
{
    cin>>n>>m>>q;
    for(i=1;i<=n;i++)//初始化
        father[i]=i;//建立新的集合，其仅有的成员是i
    for(i=1;i<=m;i++)
     {
         scanf("%d%d",&x,&y);
         int r1=find(x);
         int r2=find(y);
        if(r1!=r2) unionn(r1,r2);
     }
    for(i=1;i<=q;i++)
    {
        scanf("%d%d",&x,&y);
        if(find(x)==find(y))printf("Yes\n");//判断元素是否属于同一集合；
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：Demons (赞：0)

```cpp
#include "cstdlib"
#include "iostream"
#include "cstdio"
#include "math.h"
#include "cstring"
using namespace std;
```
/\*
并查集的实质是用树来代表集合吗，规定每棵树的根节点是这棵树对应的集合的代表元

查找依据：如果两个元素的代表元相同，说明他们在一个集合中（一棵树只有一个根）

那么合并集合的实质是合并两棵树，合并两棵树又可以看作合并两棵树的代表元

定义p[x]中储存x的父节点，当x为根节点时没有父节点，所以p[x]=x，这个在初始化中用

定义找代表元的一个函数 find()，迭代找父节点，直到父节点为根

所以合并两棵树的代码是 p[find(x)]=find(y)，也就是设定x这棵树的代表元拥有了一个父节点，是y的代表元


有一个技巧，当出现特殊情况时，树的某一个树枝会特别长，导致find函数查找代表元的路径会很长

所以在查找时，如果验证了某两个元素在同一棵树，可以把他们都直接接到代表元上，这样在数据复杂时查找效率会高很多，但本题数据不那么夸张..这个技巧效果不明显

\*/

```cpp
int p[5005];//x的父节点在p[x]中保存
int find(int x){ return p[x] == x ? x : p[x] = find(p[x]); }//条件为真，返回冒号前的条件，条件为假，返回冒号后条件。这个函数会递归直到找到代表元
int main()
{
    int n, adjust,ask,x,y;//adjust是亲戚数，ask是询问数，x和y为标记的两个人
    ios::sync_with_stdio(false);//关闭cin流同步，加快读入数据的速度，如果用scanf没有这个必要，scanf本身就适合大量数据的读入
    cin >> n >> adjust>>ask;
    for (int i = 0; i < n; i++)p[i] = i;//初始化并查集，此时每一个节点都是代表元
    for (int i = 0; i < adjust; i++)
    {
        cin >>x >> y;
        p[find(x)] = find(y);//令x的根节点 为y节点的根节点 的子节点，合并操作
    }
    for (int i = 0; i < ask; i++)
    {
        cin >> x >> y;
        if (p[find(x)] == p[find(y)]){ cout << "Yes" << endl; p[x] = find(y); p[y] = find(x); }//运用判断依据和技巧
        else cout << "No" << endl;
    }
    return 0;
}
```

---

## 作者：hexinkuan (赞：0)

这道题应该用并查集

对于该题目的样例，并查集做法如下：

（1）合并过程如下

①    建立元素只有一个的六个集合

 
②    合并1所在的集合和2所在的集合

 
③    合并1所在的集合和5所在的集合

 
④    合并3所在的集合和4所在的集合

 
⑤    合并1所在的集合和3所在的集合

 
（2）查找过程如下

①查找1,4分别所在集合

 
由此可得，1,4在一个集合中；

②查找2,3分别所在集合

 
由此可得，2,3在一个集合中；

③查找5,6分别所在集合

 
由此可得，2,3在一个集合中；

因此，需要两个函数：

（1）    union（a,b）:合并a所在集合和b所在集合；

（2）    find（a）:返回a所在集合的代表

下面附上c++代码

```cpp
#include<bits/stdc++.h>
using namespace std;  
int f[10005];  
int find(int a){  
    if(a==f[a])return a;
    f[a]=find(f[a]);  
    return f[a];
}  
void union1(int a,int b){  
    f[b]=a; 
```
}//因为union是系统自带函数，所以这里定成union1

```cpp
int main(){  
    int n,m,p;  
    cin>>n>>m>>p; 
    for(int i=1;i<=n;i++)f[i]=i;  
    for(int i=1;i<=m;i++){  
        int a,b; 
        cin>>a>>b;  
        if(find(a)!=find(b))union1(a,b);    
    }
    for(int i=1;i<=p;i++){
        int a,b; 
        cin>>a>>b;
        if(find(a)==find(b))cout<<"Yes\n";else cout<<"No\n";
    }
    return 0; 
}
```
但是，上面这种方法可能会在某种特殊情况下，即一条单链很长时，会超时。
所以就要用到优化方法——路径压缩

这就是指，在合并a和b的集合时，b的父节点不是a，而是a所在集合的根节点。

下面为优化算法的c++代码

```cpp
#include<bits/stdc++.h>
using namespace std;  
int f[10005];  
int find(int a){  
    if(a==f[a])return a;
    f[a]=find(f[a]);  
    return f[a];
}  
void union1(int a,int b){  
    a=find(a);  
    b=find(b);  
    if(a!=b)f[b]=a; 
}  
int main(){  
    int n,m,p;  
    cin>>n>>m>>p; 
    for(int i=1;i<=n;i++)f[i]=i;  
    for(int i=1;i<=m;i++){  
        int a,b; 
        cin>>a>>b;  
        if(find(a)!=find(b))union1(a,b);    
    }
    for(int i=1;i<=p;i++){
        int a,b; 
        cin>>a>>b;
        if(find(a)==find(b))cout<<"Yes\n";else cout<<"No\n";
    }
    return 0; 
}

```

---

## 作者：cjoier_zouzhen1211 (赞：0)

这是一道并查集的裸题,具体实现如下:

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;
int father[100001];
int m,n,q,x,y;
int find(int);//寻找父亲节点的函数
void unionn(int,int);//合并集合的函数

int main(){
  scanf("%d%d%d",&n,&m,&q);//输入
    for(int i=1;i<=n;i++){
      father[i]=i;//建立新的集合,将每个元素看作是一棵独立的树
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        int r1=find(x);
        int r2=find(y);
        if(r1!=r2){
          unionn(r1,r2);//如果不在同一个集合内,那就将两个集合合并
        }
    }
    for(int i=1;i<=q;i++){
        scanf("%d%d",&x,&y);
        if(find(x)==find(y)){
          printf("Yes\n");//满足条件,输出yes
        }
        else{
          printf("No\n");//不满足条件,输出no
        }
    }
    return 0;
}

int find(int x){
    if(father[x]!=x){
      father[x]=find(father[x]);//路径压缩
    }
    return father[x];
}

void unionn(int r1,int r2){
  father[r2]=r1;//将集合合并
}

```

---

## 作者：Hydroxyl (赞：0)

果断并查集

并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。

集就是让每个元素构成一个单元素的集合，也就是按一定顺序将属于同一组的元素所在的集合合并。


主要操作

初始化

把每个点所在集合初始化为其自身。

通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。

查找
查找元素所在的集合，即根节点。

合并
将两个元素所在的集合合并为一个集合。

通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。


贴代码

————————————————————pascal——————————[code by CJZ]——————————————————






```cpp
var pas:array[1..100000] of longint;
    a,b,c,d,i,q,x,y,n,m:longint;
procedure init;
begin
    assign(input,'relation.in');
    reset(input);
    assign(output,'relation.out');
    rewrite(output);
end;
function getfather(c:longint):longint;
begin
    if pas[c]=c then exit(c);
    pas[c]:=getfather(pas[c]);
    exit(pas[c]);
end;
procedure union(a,b:longint);
begin
    x:=getfather(a);
    y:=getfather(b);
    if x<>y then pas[x]:=y;
end;
begin
    init;
    readln(n,m);
    for i:=1 to n do pas[i]:=i;
    for i:=1 to m do
    begin
      readln(a,b);
      union(a,b);
    end;
    readln(q);
    for i:=1 to q do
    begin
      readln(a,b);
      if getfather(a)=getfather(b) then writeln('Yes') else writeln('No');
    end;
    close(output);
end.
```
————————————————————————已加小bug不要乱复制———————————————————————
咳咳接下来讲思路

一般第一反应就是输入n个点m个边然后找出连通块然后判断就对了

但是这道题目的数据不是很友好所以如果直接\*容易TLe或者崩溃访问无效内存

所以我们的并查集要出手了（哒哒哒）

刚开始每个人建立一个集合然后如果是亲戚那么合并两个集合

主程序就是读入然后找这个节点的双亲节点（I am your father!）

接下来讲讲副程序的思路（梗）

union就是建立关系啦啦啦啦啦啦然后两个人分别往上找然后如果是ok的那么就是他祖先肯定相等所以就是ok的啦

然后找祖先就是一个递归的过程啦啦啦啦啦啦一直往上找就对了

总的来说：

看人，往上找，判断

就这样了


今天就是考了个俄罗斯方块到机房然后我u盘被没收了一脸不爽


---


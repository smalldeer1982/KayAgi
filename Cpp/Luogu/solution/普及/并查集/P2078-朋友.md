# 朋友

## 题目背景

小明在 A 公司工作，小红在 B 公司工作。

## 题目描述

这两个公司的员工有一个特点：一个公司的员工都是同性。

A 公司有 $N$ 名员工，其中有 $P$ 对朋友关系。B 公司有 $M$ 名员工，其中有 $Q$ 对朋友关系。朋友的朋友一定还是朋友。

每对朋友关系用两个整数 $(X_i,Y_i)$ 组成，表示朋友的编号分别为 $X_i,Y_i$。男人的编号是正数，女人的编号是负数。小明的编号是 $1$，小红的编号是 $-1$。

大家都知道，小明和小红是朋友，那么，请你写一个程序求出两公司之间，通过小明和小红认识的人最多一共能配成多少对情侣（包括他们自己）。

## 说明/提示

对于 $30 \%$ 的数据，$N,M \le 100$，$P,Q \le 200$；

对于 $80 \%$ 的数据，$N,M \le 4 \times 10^3$，$P,Q \le 10^4$；

对于 $100 \%$ 的数据，$N,M \le 10^4$，$P,Q \le 2 \times 10^4$。

## 样例 #1

### 输入

```
4 3 4 2
1 1
1 2
2 3
1 3
-1 -2
-3 -3
```

### 输出

```
2```

# 题解

## 作者：Ajwallet (赞：58)

**map轻松AC**
map库最大的优势，就是它可以定义任意类型下标，那么女人编号是负数的问题就迎刃而解了

代码
```
```C++
#include<bits/stdc++.h>
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;int n,m,p,q,u,v,tat,tot;
map<int,int>f;//STl大法好
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
void judge(int x,int y){f[find(x)]=find(y);}
bool too(int x,int y){return find(x)==find(y);}
int main()
{
	scanf("%d%d%d%d",&n,&m,&p,&q);//输入
	r(i,-1*m,n) f[i]=i;//初始化
	r(i,1,p+q)//直接一起做
	 {
	 	scanf("%d%d",&u,&v);
	 	judge(u,v);
	 }
	r(i,-1*m,-1)
	 if(too(f[i],-1)) tat++;//找连接在一起的
	r(i,1,n)
	 if(too(f[i],1)) tot++;//同理
	printf("%d",min(tat,tot));//几对朋友就是最小值
}
```

---

## 作者：睿屿青衫 (赞：44)

~~这道题当时没做出来~~

~~今天又翻到他，想一遍过，可就是10分上不去，本校神犇道破天机~~

我看了看讨论，发现也有不少10分的，那么我就简单说一下

首先，能配对多少对情侣？怎么想？每个公司都只有同性，那肯定是俩公司一起搭配。通过这俩人配怎么办？并查集！每个公司中分别找和这个公司中的~~红娘~~媒人祖先相同的点，统计一下个数，最后俩数取小（不然你还要一夫多妻还是一妻多夫？？）

十分来了！我竟然脑残到数组出现了负下标==（现在能想通为啥你的答案总是莫名其妙了吧？）那怎么处理呢？a公司都是正整数，n人，那b公司就从n+1到m+n表示（m人），但是他们都是负数，直接并集会导致什么？和a公司的人重合（这也是讨论中出错的原因）！怎么处理？把负数化正（\*-1不难想吧？），再加上n，在此基础上进行并查集操作，剩下的很简单了，就这里是一些坑。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define maxn 500000
using namespace std;
int n,m,p,q,ansm=0,ansf=0,father[maxn];
int find(int x)
{
    if(father[x]!=x) father[x]=find(father[x]);
    return father[x];
}
void unionn(int x,int y)
{
    int r1=find(x);
    int r2=find(y);
    father[r2]=r1;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for(int i=1;i<=n+m;++i)
     father[i]=i;
    for(int i=1;i<=p;++i)
     {
         int a,b;
         scanf("%d%d",&a,&b);
         if(find(a)!=find(b))
          unionn(a,b);
     }
    for(int i=1;i<=q;++i)
     {
         int a,b;
         scanf("%d%d",&a,&b);
         a*=-1;b*=-1;
         if(find(a+n)!=find(b+n))
          unionn(a+n,b+n);
     }
    for(int i=1;i<=n;++i)
     if(find(i)==find(1))
      ansm++;
    for(int i=n+1;i<=n+m;++i)
     if(find(i)==find(n+1))
      ansf++;
    printf("%d",min(ansf,ansm));
    return 0;
}

```

---

## 作者：Blue_wonders (赞：41)

## 并查集AC(附上易懂AC代码）这道题对并查集可以进行一下优化

### 先排一下这道题的坑
- 小明和小红是一对，所以说最小是1，不是零
- 输入小红时时负数，别直接用
- 打代码的时候仔细一点，并查集打错字母能调半天

### 基本思路
- 和并查集一样，将男女分开装
- 男的只要认识小明以及小明的朋友以及小明的朋友的朋友...就可以认为认识小明，女的同样。
- 所以建立两个并查集
- 比较男女的个数，输出最小值

### 优化提升
#### 针对并查集：
可以不给父亲数组赋值，直接在find函数上进行一次判断~~可以少打两行代码~~
```cpp
int find(int s){
    if(f[s]==s||f[s]==0)return f[s]=s;
    //这里初始是0，没有进入函数的点的父亲一定是自己所以不用写一次循环给f函数赋值
    else return f[s]=find(f[s]);
    //这里一定要优化加上“f[s]=”不然很可能会TLE
}
```
#### 针对这道题
可以使用二维数组来分别存储男女信息，循环时只用写一遍，比较方便使用

### 下面是AC代码(附详解)
[AC代码详情](https://www.luogu.org/recordnew/show/16424099)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,h,ans=1,anss=1;//赋值是1，因为本来小明和小红是一对
int f[20010][2];//二维数组,0,1分别代表男和女
int find(int s,int t){//s代表人，t代表男女(男是0，女是1)
	if(f[s][t]==s||f[s][t]==0)return f[s][t]=s;//如果没赋值或者赋值是自己，说明树根是自己，就赋值输出自己
    else return f[s][t]=find(f[s][t],t);//如果树根不是自己，那么向前找树根(加上记忆，防止TLE)
}
int main(){//主函数
	cin>>n>>m>>p>>h;
	for(int i=1;i<=p;i++){//先输入男的，用f[i][0]表示
		int a,b;
		cin>>a>>b;
		int x=find(a,0);//找树根
		int y=find(b,0);
		if(x!=y){//要是不在同一棵树上就并在一棵树上
			if(x>y)swap(x,y);//大的的树根永远是小的这样可以保证1和-1是树根，方便最后计数
			f[y][0]=x;//合并树根
		}
	}
	for(int i=1;i<=h;i++){//女的，用f[i][1]表示
		int a,b;
		cin>>a>>b;
		a=-a;//将负数转化为正数，存储到数组里
		b=-b;
		int x=find(a,1);//和上一个一样，只不过把0换成1，代表女的
		int y=find(b,1);
		if(x!=y){
			if(x>y)swap(x,y);
			f[y][1]=x;
		}
	}
	for(int i=2;i<=max(n,m);i++){//从2开始计数，因为ans初始值是1，小明的1号已经考虑进去了
		if(find(f[i][0],0)==1)ans++;//如果树根是1那么这个男生认识小明，男生答案加一
		if(find(f[i][1],1)==1)anss++;//如果树根是1那么女生认识小红，女生答案加一
	}
	cout<<min(ans,anss);//一夫一妻，所以选最小的
	return 0;
}
```
感谢大家能看我的题解！

---

## 作者：虫洞吞噬者 (赞：13)

#### 并查集（稍作修改）
------------
或许我的思维过于~~奇特~~，对于不同的性别，实行了两套并查集：
```cpp
int findfa(int k)
{
    if(fa[k]==k)return k;
    return fa[k]=findfa(fa[k]);
}
int findma(int Q)
{
    if(ma[Q]==Q)return Q;
    return ma[Q]=findma(ma[Q]);
}
//大概就是这样了吧......
```
------------
也许我的题解不够优秀，但是做这个题目的时候我的确煞费心血（~~蒟蒻的挣扎~~）

------------
言归正传。对于这个题目，我们容易看出，两个公司之间的的员工如果想要“牵线成功”，那么他们必须认识小明（红）。由此可以抽象出一个~~模糊的~~概念：设立一个数组，用来存储他们的人际关系。
###### code：
```cpp
fa[pp]=qq;
```
由此，按照他们的人际关系，将数组合并，可以构成一个“家庭树”，树的根节点就是小明（红）。（并查集的本意）
![](https://cdn.luogu.com.cn/upload/pic/57666.png)

但是很显然，由上图可知，如果我想查询A认不认识小明，就要先去查询C。显然会花费大量时间。于是我们可以这样想：能否让所有的人都指向小明？

------------

#### 并查集的路径压缩
具体来讲，还是上面的例子，在我们看来，A通过了谁认识小明并不重要，重要的是他认不认识小明。由此我们不妨假设：把他们的人际关系集中起来，让他们直接认识小明，岂不美哉？
由此可以得出并查集路径压缩的诀窍：**多年父子成兄弟！！！**

code：
```cpp
  if(fa[k]==k)return k;
    return fa[k]=findfa(fa[k]);
```
**由此可以实现所有的节点都指向根节点**


------------

就题论题的话，这个题目有几个细节问题：

1.女性的编号都是负数。对此，我们可以使用万能的abs函数，并且将女性之间的关系单独放在另一个数组里（不单独放也可以，但是为了方便理解，我们暂且这样做）。

2.有关答案的统计。对于测试数据，有些可能不是十分友好，并不能保证所有认识小明（红）的人都可以成功脱单（~~嘤~~~），所以在统计答案的时候，只需要求最小值即可（~~当然不允许同性恋的存在~~）

下面是我的代码，风格清奇大佬勿喷（捂脸）
```cpp
#include<bits/stdc++.h>//懒散的我并不喜欢背头文件
using namespace std;
int n,m,p,q,ans1,ans2,ans;
int fa[10001],ma[10001];//储存关系的两个数组
int a,b,c,d;
int findfa(int k)//并查集的优化算法
{
    if(fa[k]==k)return k;
    return fa[k]=findfa(fa[k]);
}
int findma(int Q)
{
    if(ma[Q]==Q)return Q;
    return ma[Q]=findma(ma[Q]);
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1;i<=m;i++)
        ma[i]=i;
    for(int i=1;i<=p;i++)
    {
        scanf("%d%d",&a,&b);
        if(findfa(a)!=findfa(b))
        {
            int qq,pp;
            qq=findfa(a);
            pp=findfa(b);
            fa[pp]=qq;
        }
    }
    for(int i=1;i<=q;i++)
    {
        scanf("%d%d",&c,&d);
        c=abs(c);
        d=abs(d);
        if(findma(c)!=findma(d))
        {
            int qq,pp;
            qq=findma(c);
            pp=findma(d);
            ma[pp]=qq;
        }
    }
    for(int i=1;i<=n;i++)//答案统计
    {
       	if(findfa(fa[i])==findfa(fa[1]))ans1++;
    }
    for(int i=1;i<=m;i++)
    {
        if(findma(ma[i])==findma(ma[1]))ans2++;
    }
    ans=min(ans1,ans2);//取最小值
    printf("%d",ans);
    return 0;
}
```

------------

~~其实刚开始的时候，我一直在犹豫，他们实行的是一夫一妻制还是多夫多妻制（滑稽）~~

------------

蒟蒻的第一篇题解，希望大家喜欢

---

## 作者：___new2zy___ (赞：11)

# 题解 P2078 【朋友】

#### 题目链接:
https://www.luogu.org/problemnew/show/P2078

---------------------------------我是分割线----------------------------------------------------------------------------------------------------------------------------------


不得不说，本人认为~~此题很水~~，~~简直就是模板题~~。。。

显然，此题我们要明确算法：**并查集**

### 并查集：

#### <1> 定义

并查集是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示。

集就是让每个元素构成一个单元素的集合，也就是按一定顺序将属于同一组的元素所在的集合合并。

#### <2>初始化

把每个点所在集合初始化为其自身。

通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。

#### <3>查找

查找元素所在的集合，即根节点。

#### <4>合并

将两个元素所在的集合合并为一个集合。

通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的"查找"操作实现。


### 以上是并查集的简短介绍，不怎么了解的童鞋可以自行百度，多多了解一下并查集

咳咳...，不说那么多（~~因为我太弱了，说不出什么来~~），直接上本题代码~~~

============================================

     #include<iostream>
     #include<cstdio>
     #include<cmath>
     #include<algorithm>
     using namespace std;
     typedef long long ll;
     const int inf=1e5+3;
     inline int read()//拙劣的快读
     {
         int p=0,f=1;char c=getchar();
         while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
         while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
     return f*p;}
     int n,m,p,q;
     int father_1[10009],father_2[10009];
     int cnt_1,cnt_2;
     //father_1,father_2分别用来存1,2公司每个人的认识朋友情况(即其朋友链上的最开始的那个人)
     //cnt_1,cnt_2用来记录1,2公司中分别有多少人认识第一号(每个公司的第一个人即"一把手") 
     int find(int father[],int k)//并查集基本操作:查询某一元素的"根"(同时内附路径压缩)
     {
	     if(father[k]==k)return k;
	     else father[k]=find(father,father[k]);
     }
     void prework()//初始化:分别初始化集合     father_1,father_2,每个元素的"根"默认为自身 
     {
	     for(int i=1;i<=n;i++)
	         father_1[i]=i;
	     for(int j=1;j<=m;j++)
	         father_2[j]=j;
     }
     int main()
     {
	     n=read(),m=read(),p=read(),q=read();
	     prework();//初始化并查集 
	     for(int i=1;i<=p;i++)
	        {
	   	     int x1=read(),x2=read();
	            int t1=find(father_1,x1),t2=find(father_1,x2);
		        //查看是否x1与x2认识(有共同的朋友) 
	   	     if(t1!=t2)//没有就合并集合 
	   	        father_1[t2]=t1;
	        }
	     for(int j=1;j<=q;j++)
	        {
	   	     int y1=-read(),y2=-read();
		         //注意要取反,因为2公司是女生,所给的是负数下标(会越界) 
	   	     int T1=find(father_2,y1),T2=find(father_2,y2);
	   	     if(T1!=T2)//如上,同理 
	   	        father_2[T2]=T1;
	        }
	     int per_1=find(father_1,1);//设置1公司第一人所在集合 
	     for(int i=1;i<=n;i++)
	        {
	   	     int cmp1=find(father_1,i);
	   	     if(cmp1==per_1)cnt_1++;//如果认识第一人,则男生cnt_1++ 
	        }
	     int per_2=find(father_2,1);//设置2公司第一人所在集合
	     for(int j=1;j<=m;j++)
	         {
	            int cmp2=find(father_2,j);
		        if(cmp2==per_2)cnt_2++;//如果认识第一人,则女生cnt_2++ 
	         }
	     printf("%d",min(cnt_1,cnt_2));//最后输出二者较小值,因为要找配对数 
         return 0;//好习惯~~~ 
      }
     
#### 注:对了，有的小伙伴是不是看到最后找男女符合的人时循环量i，j分别从1开始？这是因为题目中要求说:(包括他们自己)就是说自己也算进去，所以要从1开始

### 最后祝大家“享受coding的快乐”哦

##### 推广我的博客（~~~233~~~）：
https://www.luogu.org/blog/new2zy/





---

## 作者：QFNU_ING__ (赞：8)

（qwq这里是蒟蒻的第一篇题解，而且蒟蒻的语文还不好）

相信的大家如果来看我的题解那就说明你们已经看过题目了，所以这里就不写题面了。


首先，我们来了解一下并查集~~（冰渣鸡）~~:


所谓并查集，就是一个关于集合操作的数据结构，主要的任务就是完成“并”、“查”这两个操作（首先得初始化）


这里就直接贴代码了，详细的自行百度吧，csdn和洛谷上都有很多很好的讲解，b站也有视频讲解qwq：

```cpp
void init(){
	for(int i = 1; i <= n; i++){
    	f[i] = i;
	}
}
```

查：
```cpp
int query(int p){
	if(f[p] == p) return p;
		else{ //这里有路径压缩，可以节省时间
			int v = query(f[p]);
			f[p] = v;
			return v;
		}
}
```

并：
```cpp
void merge(int p1, int p2){
	int f1 = query(p1);
	int f2 = query(p2);
	if(f1 != f2){
		f[f1] = f2;
	}
}
```

ok，下面我们来分析题目

不，我先吐槽标签，我觉得这个题的标签只要并查集就行了，并查集已经包含了递归操作。

好，现在步入正题：

我的做法可能比较~~毒瘤~~不一般，这里运用了很多STL的知识：

首先，男生用正数表示，女生用负数表示；

可是一般的数组不能以服饰为下标，所以我用map<int,int>来解决；

而题目中也没有给出人最大的编号是多少，所以我用了set解决；

然后根据题目，枚举在集合中与所有与1，-1有关系的集合的人的个数；

之后选出两个集合中人最少的那个就是答案；

有一个细节要注意的是，如果没有与1或-1有关系的集合，也就是1或-1单独形成一个集合，那么这是算出来的人数是0，而题目中说，1，-1为一对，所以输出1。(我有一次90分的原因就是这个)

code:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <set>
#include <map> 

using namespace std;

int n;
int m;
int p;
int q;
int x;
int y;
map<int,int> f;
set<int> s;

inline int read() { //fast_read
	int f = 1, k = 0;
	char c = getchar();
	while(c > '9' || c < '0') {
		if(c == '-') {
			f = -1;
		}
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		k = k * 10 + (c - '0');
		c = getchar();
	}
	return f * k;
}

inline void init(){ //不知道数据范围所以瞎蒙了一个 
	for(int i = -300000; i <= 300000; i++){
		f[i] = i;
	}
}

inline int query(int p){
	if(f[p] == p) return p;
		else{
			int v = query(f[p]);
			f[p] = v;
			return v;
		}
}

inline void merge(int p1, int p2){
	int f1 = query(p1);
	int f2 = query(p2);
	if(f1 != f2){
		f[f1] = f2;
	}
}

inline void read1(){
	init();
    
	n = read();
	m = read();
	p = read();
	q = read();
	
	for(int i = 1; i <= p; i++){
		x = read();
		y = read();
		s.insert(x);
		s.insert(y);
		merge(x,y);
	}
	for(int i = 1; i <= q; i++){
		x = read();
		y = read();
		s.insert(x);
		s.insert(y);
		merge(x,y);
	}
}

inline void work(){
	int cnt1 = 0, cnt2 = 0;
	for(set<int>::iterator it = s.upper_bound(0); it != s.end(); it++){ //因为一个公司只有一种性别，所以只需要从非负数开始枚举就可以 
		if(query(*it) == query(1)){
			cnt1++;
		}	
	}
	for(set<int>::iterator it = s.begin(); it != s.lower_bound(0); it++){ //和上面的解释相反 
		if(query(*it) == query(-1)){
			cnt2++;
		}
	}
	if(min(cnt1, cnt2) == 0) printf("1");
		else printf("%d",min(cnt1, cnt2));
}

void debug(){
	for(set<int>::iterator it  = s.begin();it != s.end(); it++){
		cout << (*it) <<" ";
	}
	cout << endl;
}

int main(){
	read1();
//	debug();
	work();
	return 0;
}

```

---

## 作者：封禁用户 (赞：6)

为什么没有tarjan的题解让我来一发（萌新刚学tarjan大佬误喷）

思路很简单：先读入男生，双向建边；再读入女生节点，因为数组下标非负所以女生节点加n，在双向建边；然后tarjan求出每个强联通分量中女生数量和男生数量，然后就这么愉快地结束了。

因为打错tarjan被隔壁大佬（[FDD](https://www.luogu.org/space/show?uid=11847)  [DFC](https://www.luogu.org/space/show?uid=84419)）无情嘲讽了qwq



```cpp
#include <bits/stdc++.h>
#define N 100010
using namespace std;
namespace program {
	int head[N*2],to[N*2],next[N*2];
	int ti=0,now=0,cnt=0,top=0;
	int sccno[N],low[N],pre[N],Sum1[N*2],Sum2[N*2],Stack[N];
	int n,m;
	inline void add(int x, int y) {
		cnt+=1;
		to[cnt]=y;
		next[cnt]=head[x];
		head[x]=cnt;
	}
	inline void dfs(int k) {
		low[k]=pre[k]=++ti;
		Stack[++top]=k;
		for(int i=head[k]; i; i=next[i]) {
			int oo=to[i];
			if(!pre[oo]) {
				dfs(oo);
				low[k]=min(low[k],low[oo]);
			} else if(!sccno[oo])low[k]=min(low[k],pre[oo]);
		}
		if(low[k]==pre[k]) {
			now+=1;
			while(top) {
				int oo=Stack[top--];
				sccno[oo]=now;
				if(oo>n)Sum2[now]+=1;//女生加一
				if(oo<=n)Sum1[now]+=1;//男生加一
				if(oo==k)break;
			}
		}
	}//tarjan模板
	inline void work() {
		int p,q,x,y,ans=0;
		scanf("%d%d%d%d",&n,&m,&p,&q);
		for(int i=1; i<=p; i++) {
			scanf("%d%d",&x,&y);
			add(x,y);
			add(y,x);//建边
		}
		for(int i=1; i<=q; i++) {
			scanf("%d%d",&x,&y);
			x =-x+n,y=-y+n;
			add(x,y);
			add(y,x);//建边
		}
		add(1,1+n);
		add(1+n,1);//把小明和小红建边（关键）
		for(int i=1; i<=n+m; i++)if(!pre[i])dfs(i);
		for(int i=1; i<=now; i++)ans=max(ans,min(Sum1[i],Sum2[i]));//取男女生之间最小值
		printf("%d\n",ans);
	}
} int main() {
	program::work();
	return 0;
}//优美的主函数
```

---

## 作者：saxiy (赞：5)

谁说C++不资瓷负数下标啊。。

要知道为什么普通数组不资瓷负数下标，就要先从数组的访问原理说起。

学过初赛的人都知道，数组是连续开辟的一大块内存，而在程序里，我们只保存了数组头的地址。即你的数组名，实际上是一个指针，指向的是这个数组开始的位置，通过下标的访问就是通过 `地址头+sizeof(type)*下标` 计算得到的地址来访问你存储的信息，而如果下标为负数，就会越界，还是反向越界。

那怎么能使下标为负呢，要是数组头的前面的空间也被开辟就好了。

于是我们将数组的中间作为起始坐标（通过指针位移得到），这时下标就能为负了，就可以统一处理了。

附上20行代码：

```cpp
#include <bits/stdc++.h>
#define N 10005
using namespace std;

int n, m, p, q, s1, s2, data[N << 1], *bcj = data + N;

int fa(int x) { return bcj[x] == x ? x: bcj[x] = fa(bcj[x]); }
void un(int a, int b) { bcj[fa(a)] = fa(b); }
bool isin(int a, int b) { return fa(a) == fa(b); }

int main() {
	scanf("%d%d%d%d", &n, &m, &p, &q);
	int a, b; p += q;
	for(int i = -m;i <= n;i++) bcj[i] = i;
	while(p--) { scanf("%d%d", &a, &b); un(a, b); }
	for(int i = -m;i <= n;i++)
		if(isin(i, i > 0 ? 1 : -1)) i > 0 ? s1++ : s2++;
	printf("%d", min(s1, s2));
	return 0;
}
```

---

## 作者：星之海 (赞：5)

我来写个题解，来纪念我60行的代码

解释一下题目啊

这道题目主要是用并查集，把男1号认识的人在一起，判断他可以找到的人有多少，女1号也是如此。这样，可成为的情侣总数就是看男1号和女1号认识的人谁少就是答案。

所以，代码就是长这样的：

```cpp
#include<stdio.h>
int father[20001],father2[20001];//father用来保存男生，father2保存女生
int min(int a,int b)//返回较小数
{
    return a<b?a:b;
}
int find_num(int fa[],int x)//查
{
    if(fa[x]!=x)
    fa[x]=find_num(fa,fa[x]);
    return fa[x];
}
void combine_boy(int x,int y)//并（男生）
{
    int r1,r2;
    r1=find_num(father,x);
    r2=find_num(father,y);
    if(r1!=r2)//不是一个祖先
    father[r2]=r1;
}
void combine_girl(int x,int y)并（女生）
{
    int r1,r2;
    r1=find_num(father2,x);
    r2=find_num(father2,y);
    if(r1!=r2)//不是一个祖先
    father2[r2]=r1;
}
int main()
{
    int printnum,n,m,p,q,x,y,rootboy,rootgirl,i,boy,girl;
    scanf("%d %d %d %d",&n,&m,&p,&q);
    for(i=1;i<=n;i++)
    father[i]=i;//初始化
    for(i=1;i<=m;i++)
    father2[i]=i;//初始化
    for(i=1;i<=p;i++)
{
    scanf("%d %d",&x,&y);
    combine_boy(x,y);//并入男生 father 中
}
    for(i=1;i<=q;i++)
{
    scanf("%d %d",&x,&y);
    x=-x;//取反，不然会炸
    y=-y;//同上，取反
    combine_girl(x,y);//并入女生 father2 中
}
    rootboy=find_num(father,1);//男1号
    rootgirl=find_num(father2,1);//女1号
    boy=girl=0;//总量都初始化为0
    for(i=1;i<=n;i++)
    if(find_num(father,i)==rootboy)//男1号认识
    boy++;//保存
    for(i=1;i<=m;i++)
    if(find_num(father2,i)==rootgirl)//女一号认识
    girl++;//保存
    printnum=min(boy,girl);//较小数
    printf("%d\n",printnum);//输出
    return 0;
}//完美的结束
```

---

## 作者：就皮这一下 (赞：4)

## 看到有的人开了两个数组分别维护两个公司，本人认为有一个……窍门
现在——拜请template大法！

我们知道，STL就是standard template library，里面的像vector,pair,priority_queue都是模板，**声明时要有的<int>其实就是给模板一个类型**~~（非专业人士，大家明白就行）~~，但是：
  
谁说模板只能带int,double等类型?（感谢刘汝佳老师）今天带你玩玩带数字的模板！
  

------------

####   第二版补充：
 ~~紧急插播一条并查集的基本知识~~
  
  并查集本质上是一片森林。

## 1.并查集的应用范围

>并查集适用于:给出一组关系，询问2个是否有关系。
  
比如：a与b是亲戚，b与c是亲戚，c与d是亲戚，询问a与d是否是亲戚。
  
##  2.并查集的基本操作
  既然是“并”“查”集，当然会并和查了！
  
 **并：本质上是将两棵树合并起来**
~~~ cpp
int Union (const int &a,const int &b) {//合并
	int fa = find(a),fb = find(b);
	if (fa == fb) return 1;
	f[fa] = f[fb];
	return 0;
}
~~~
**查：本质上是查询两个节点是否在同一棵树上**。
    
~~~ cpp
int que (const int &a,const int &b) {//询问
	return find(a)==find(b);
}
~~~
  这里都用到了find函数。它的作用是查找节点所在树根。
  
  这里是
~~~ cpp
int find (const int &x) {//找根
	if (f[x] != x) return find(f[x]);
	return f[x];
} 
~~~
  注意到所有节点优先级相等，我们不关心集合代表（即森林的根）。我们只要考虑是不是在一棵树上。
  
  因此，合并两棵树时，我们让任意一棵树的根节点成为另一棵树的子节点就OK了
  ![ufset.png](https://i.loli.net/2019/08/10/gsITJbh91PdnuZH.png)
  现在执行union(2,5)，我们就要直接对1,4操作，是1成为4的子节点还是4做1的无所谓。
  
  我们关心的是“对外保持一致”。只要保证$\operatorname{find}(4) = \operatorname{find}(1) = \operatorname{find}(2)$就OK了！
  
##  3. 并查集的时间复杂度
理想情况下，我们希望询问是O(1)的，但是如果所有点连成了一条链：
  ![ufset.png](https://i.loli.net/2019/08/10/rpjD2vi57UPnZXx.png)

find就是O($n$)了！~~恭喜你，TLE喽~~
### 那么我们就需要路径压缩（详见下面代码）
  具体说来就是在find的途中顺便把这个节点的父亲改成树根。
  
------------
  
``` cpp
template<const int size>
struct ufset {
	private:
		int f[size];
		int find (const int &x) {//找根
			if (f[x] != x) f[x] = find(f[x]);//路径压缩核心
			return f[x];
		}
		int que (const int &a,const int &b) {//询问
			return find(a)==find(b);
		}
	public:
		void clear () {//初始化
			for (int i = 1; i<=size; ++i)
				f[i] = i;
			return;
		}
		int Union (const int &a,const int &b) {//合并
			int fa = find(a),fb = find(b);
			if (fa == fb) return 1;
			f[fa] = f[fb];
			return 0;
		}
		int FindAll (const int &fa) {//计算根相同的点
			int ans = 0;
			for (int i = 1; i<=size; ++i)
				if (que(i,fa))
					ans++;
			return ans;
		}
};
```
这里的size就是一个可以变的数了。
  
接下来，我们就可以用 ufset<2000> A 这种方法来**开一个并差集**了！

``` cpp
ufset<10001> A;
ufset<10001> B;
int main () {
	int n,p,m,q;
	scanf ("%d %d %d %d",&n,&m,&p,&q);
  	A.clear();B.clear();
	for (int i = 1; i<=p; i++) {
		int x,y;
		scanf ("%d %d",&x,&y);
		A.Union(x,y);
	}
	int ansA = A.FindAll(1);
	for (int j = 1; j<=q; ++j) {
		int x,y;
		scanf ("%d %d",&x,&y);
		B.Union(-x,-y);
	}
	int ansB = B.FindAll(1);
	cout << min(ansA,ansB) << endl;
	return 0;
}

```
4/16更新说明：修改了排版，去除了防作弊部分

---

## 作者：shihoghmean (赞：3)

#### 这道题是一道明显的并查集

#### 我们先来了解一下什么是

# 并查集

## 并查集，这个名字就是几个操作的合并

#### 是一个很方便的一种算法，把一个数的爸爸定义为另一个数。

#### 能实现合并、查找和集合。

#### 核心代码是
```cpp
int find(int x)
{
    if(father[x]==x) return x;
    else return father[x]=find(father[x]);
}
```

### 用来查找一个数的祖先

##### 实现合并的主要代码是
```cpp
a[find(b)]=find(c);
```

#### 将c作为b的爸爸，

### 也可以理解为把b所在的集合与c所在的集合合并。

##### 查找两个数是否在一个集合中用
### find()是用来查找一个数的祖先，也就是查找他所在的集合
------------
##### 这题是把认识的人放在一堆，再判断认识的人有多少对男女
```cpp
#include<bits/stdc++.h>
using namespace std;
int father[20001],z[20001];//father[i]表示第i个人的爸爸。
//z[i]是判断有没有算过，因为在函数外，所以为0.
int find(int x)              //查找祖先
{
    if(father[x]==x) return x;
    else return father[x]=find(father[x]);
}
int main()
{
    int n,m,p,q,y=0;
    cin>>n>>m>>p>>q;
    for(int i=1;i<=n;i++)//因为一开始一个数没有祖先，所以自己当自己的爸爸
    father[i]=i;
    for(int i=n+1;i<=m+n+1;i++)//把女生放到男生后面
    father[i]=i;
    father[1]=find(n+1);     //小明和小红为一对
    for(int i=1;i<=p;i++)
    {
        int b,c;
        cin>>b>>c;
        father[find(b)]=find(c);//把A公司中的b认识的人与c认识的人集合
    }
    for(int i=1;i<=q;i++)
    {
        int d,e;
        cin>>d>>e;
        father[find(n-d)]=find(n-e);//把B公司中的d认识的人与e认识的人集合,因为d和e为负数，把她们放在男生后面
    }
    for(int i=1;i<=n;i++)
        for(int j=n+1;j<=n+m+1;j++)//枚举男的和女的
            if(find(i)==find(j)&&!z[i]&&!z[j]) y++,z[i]=1,z[j]=1;
            //把认识的不同性加起来，注意一个人只能配对一个异性（owo）
    cout<<y;//输出对数
    return 0;
}
```

# 拒绝抄袭（owo）
## 谢谢

---

## 作者：Eason_AC (赞：2)

## Update
- $\texttt{2020.9.15}$ 重新排版了此题解，并删除了一些废话。

## Content
有两个公司，$A$ 公司里有 $n$ 个员工，$p$ 个朋友关系，员工编号为正整数，其中小明的编号为 $1$；$B$ 公司里有 $m$ 个员工，$q$ 个朋友关系，员工编号为负整数，其中小红的编号为 $-1$。试问通过小明和小红认识的人最多能够配成多少对情侣。

**数据范围：$n,m\leqslant10000,p,q\leqslant20000$。**

## Solution

一道经典的并查集题目。

一开始想到直接用个简单的查找合并就行了，可是一看，有男女之分要用两个数组！没事，用个数组指针轻松解决：
```cpp
int find(int x, int *f) {
	return f[x] == x ? x : f[x] = find(f[x], f);
}
void unionn(int x, int y, int *f) {
	x = find(x, f), y = find(y, f);
	if(x != y)
		f[y] = x;
}
```
这样，男女分别开两个数组，然后使用指针去调用就能轻松搞定这个问题。

等等！女生的编号是负数，怎么办？取相反数，存入女生的数组就行。

然后查询这个很简单，遍历一下，看是否和（小明/小红）**的父亲**（直接拿小明和小红比较就错了！我就这样，所以一开始交只有10分）一样就行了：
```cpp
//	puts("In man:");
	for(int i = 1; i <= n; ++i) {
//		printf("%d's father is %d\n", i, find(i, f1));
		if(find(i, f1) == find(1, f1))	ans1++;
	}
//	puts("In woman:");
	for(int i = 1; i <= m; ++i) {
//		printf("%d's father is %d\n", -i, find(-i, f2));
		if(find(-i, f2) == find(-1, f2))	ans2++;//注意这里也要取相反数！		
	}
	ans = min(ans1, ans2);
```
总体来说并查集的思路是很清楚的，不过需要点技巧。
## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
using namespace std;

int n, m, p, q, x, y, f1[100007], f2[100007], ans1, ans2, ans;

int find(int x, int *f) {
	return f[x] == x ? x : f[x] = find(f[x], f);
}
void unionn(int x, int y, int *f) {
	x = find(x, f), y = find(y, f);
	if(x != y)
		f[y] = x;
}

int main() {
	scanf("%d%d%d%d", &n, &m, &p, &q);
	for(int i = 1; i <= n; ++i)
		f1[i] = i;
	for(int i = 1; i <= m; ++i)
		f2[-i] = -i;
	for(int i = 1; i <= p; ++i) {
		scanf("%d%d", &x, &y);
		unionn(x, y, f1);
	}
	for(int i = 1; i <= q; ++i) {
		scanf("%d%d", &x, &y);
		unionn(x, y, f2);
	}
//	puts("In man:");
	for(int i = 1; i <= n; ++i) {
//		printf("%d's father is %d\n", i, find(i, f1));
		if(find(i, f1) == find(1, f1))	ans1++;
	}
//	puts("In woman:");
	for(int i = 1; i <= m; ++i) {
//		printf("%d's father is %d\n", -i, find(-i, f2));
		if(find(-i, f2) == find(-1, f2))	ans2++;		
	}
	ans = min(ans1, ans2);
	printf("%d", ans);
	return 0;
}
```
注：被注释的部分为调试部分。

---

## 作者：Glu_TtoNy (赞：2)

这道题用并查集

- 分析题目，公司的员工都是同性。所以我们只需要找到小明的朋友数和小红的朋友数，输出他们的公共部分，也就是小的那一个

- 因为只需要记录小明的朋友数和小红的朋友数，所以储存根的数组（我这里是father）不用记录，换句话说，也就是可以使用同一数组，这就不用像大部分题解一样写两个数组和函数（很麻烦），顺便少用空间

- 但是，坑的是要将大的数的根设为小的，才能保证如果有人的朋友是小明或小红，他们的根就是小明或小红，而不是小明或小红的根是他们的朋友，当然，也有其他办法，下面的题解里有，就不讲了


-说了这么多，该上代码了

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int read() //快读
{
    int sum=0;
    char cc=getchar();
    int sym=1;
    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();
    if(cc=='-')sym=-1,cc=getchar();
    sum=sum*10+cc-'0';
    cc=getchar();
    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();
    return sym*sum;
}
int father[10010],man=0,woman=0;
int find(int x)
{
    if(father[x]!=x)father[x]=find(father[x]);
    return father[x];
} 
int main()
{
    int N=read(),M=read(),P=read(),Q=read();
    for(int i=1;i<=N;i++) //并查集初始化
        father[i]=i;
    for(int i=1;i<=P;i++)//统计
    {
        int a=read(),b=read();
        a=find(a);
        b=find(b);
        if(b<a)swap(a,b);
        father[b]=a;
    }
    for(int i=1;i<=N;i++)
        if(find(i)==1)
            man++;
    memset(father,0,sizeof(father));//还原，以便再次使用
    for(int i=1;i<=M;i++)//同上
        father[i]=i;
    for(int i=1;i<=Q;i++)//同上
    {
        int a=read()*-1,b=read()*-1;//因为是负数，所以乘上-1
        a=find(a);
        b=find(b);
        if(b<a)swap(a,b);
        father[b]=a;
    }
    for(int i=1;i<=M;i++)
        if(find(i)==1)
            woman++;
    printf("%d\n",min(man,woman));
    return 0;
}
```


---

## 作者：ghj1222 (赞：2)

据说`pascal`资瓷负数下标？

所以对于女生我们把它转化成正数不就行了吗

然后对于男女我们各维护一个并查集（其实维护成一个并查集也没事儿），然后最后找到所有和1在同一个集合里面的数字，答案取个min
几乎是个板子题吧
```
#include<cstdio>
#include<iostream>
using namespace std;
//这题对于pas党来说真是福利啊 
int n,m,p,q,b[10010],g[10010],bns,gns;
int getb(int x)
{
	return b[x]==x?x:b[x]=getb(b[x]);
}
int getg(int x)
{
	return g[x]==x?x:g[x]=getg(g[x]);
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&p,&q);
	for(int i=1;i<=n;i++)
		b[i]=i;
	for(int j=1;j<=m;j++)
		g[j]=j;
	for(int i1,i2,i=1;i<=p;i++)
	{
		scanf("%d%d",&i1,&i2);
		b[getb(i1)]=getb(i2);
	}
	for(int j1,j2,j=1;j<=q;j++)
	{
		scanf("%d%d",&j1,&j2);
		g[getg(-j1)]=getg(-j2);
	}
	for(int i=1;i<=n;i++)
		bns+=getb(i)==getb(1);
	for(int j=1;j<=m;j++)
		gns+=getg(j)==getg(1);
	printf("%d\n",min(bns,gns));
	return 0;
}
```

---

## 作者：滑稽的小宫 (赞：1)

# 并查集
### 因为是两个公司，所以我用了两个并查集数组
```
int f[10010];
int f2[10010];
```

### 接着是函数
```
void ms(int n,int f[]){//初始化
	for(int i=1;i<=n;i++)f[i]=i;
	return;
}
int find(int x,int f[]){//寻找祖先
	if(x==f[x])return x;
	else f[x]=find(f[x],f);
	return f[x];
}
void merge(int fx,int fy,int f[]){//合并
	if(fx<fy){//这个判断用于使祖先合并到小红和小明的身上
		f[fy]=fx;
	}else{
		f[fx]=fy;
	}
	return;
}	
```
### 有了函数，就可以将A、B两公司的朋友网络连起来
#### 看到楼上一大堆用各种神奇方法处理负数的神犇，忽然感到我这个只会使用负号的蒟蒻更加蒟蒻了。
```
for(int i=1;i<=p;i++){//A公司
		cin>>a>>b;
		fx=find(a,f1);
		fy=find(b,f1);
		if(fx!=fy){
			merge(fx,fy,f1);
		}
	}for(int i=1;i<=q;i++){//B公司
		cin>>a>>b;
		fx=find(-a,f2);//处理负数
		fy=find(-b,f2);
		if(fx!=fy){
			merge(fx,fy,f2);
		}
	}
```
### 再用循环把小明和小红的朋友计算出来
```
for(int i=1;i<=n;i++){//A
	if(find(i,f1)==1)male++;	
}
for(int i=1;i<=m;i++){//B
	if(find(i,f2)==1)fe++;
}
```
### 输出最小值即可
```
cout<<min(male,fe)<<endl;
```
# 全部程序
```
#include<iostream>
#include<cmath>
using namespace std;
int f1[20010],f2[20010],a,b,fx,fy,q,n,m,p,male=0,fe=0;
void ms(int n,int f[]){
	for(int i=1;i<=n;i++)f[i]=i;
	return;
}
int find(int x,int f[]){
	if(x==f[x])return x;
	else f[x]=find(f[x],f);
	return f[x];
}
void merge(int fx,int fy,int f[]){
	if(fx<fy){
		f[fy]=fx;
	}else{
		f[fx]=fy;
	}
	return;
}
int main(){
	cin>>n>>m>>p>>q;
	ms(n,f1);
	ms(m,f2);
	for(int i=1;i<=p;i++){//A公司
		cin>>a>>b;
		fx=find(a,f1);
		fy=find(b,f1);
		if(fx!=fy){
			merge(fx,fy,f1);
		}
	}for(int i=1;i<=q;i++){//B公司
		cin>>a>>b;
		fx=find(-a,f2);//处理负数
		fy=find(-b,f2);
		if(fx!=fy){
			merge(fx,fy,f2);
		}
	}
	for(int i=1;i<=n;i++){//A
		if(find(i,f1)==1)male++;	
	}
	for(int i=1;i<=m;i++){//B
		if(find(i,f2)==1)fe++;
	}
	cout<<min(male,fe)<<endl;
	return 0;
}
```

---

## 作者：Trick_t (赞：1)

两个公司用一个father数组就好，B公司对应的下标为绝对值加n，这样就不必去写两个相同的找父亲和合并的函数

root记录的是节点i有多少个孩子

并查集操作后所得到的root[1]是小明认识的人，root[1+n]是小红认识的人，两者中较小的那一个为答案

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,p,q;
int fat[20005],root[20005];
int Abs(int x)
{
    if(x>=0)return x;
    return -x;
}
int find(int x)
{
    if(fat[x]!=x)fat[x]=find(fat[x]);
    return fat[x];
}
void unionn(int x,int y)
{
    int r1=find(x);
    int r2=find(y);
    if(r1>r2)swap(r1,r2);
    if(r1!=r2)
    {
        fat[r2]=r1;
        root[r1]+=root[r2];
    }
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for(int i=1;i<=n+m;i++)//初始每个人的父亲为自己
        fat[i]=i;
    for(int i=1;i<=n+m;i++)//初始每个人认识的人为1（自己）
        root[i]=1;
    for(int i=1;i<=p;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        unionn(x,y);
    }
    for(int i=1;i<=q;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        unionn(Abs(x)+n,Abs(y)+n);
    }
    printf("%d\n",min(root[1],root[1+n]));
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：1)

貌似楼下都是合并完之后再来统计有多少人是通过小明/小红结友的

这边给出一种边合边算的方法:

开两个数组:ra[](男的),rb[](女的)，ra[i]/rb[i]分别表示编号以为i的人为根的人数(包括自己)，所以ra[1],和rb[1]就分别表示小明和小红的朋友数

因为题中女的是负数，为了方便，全部化为绝对值，变量名有a的是男的，有b的是女的(当然下标是正数)

```cpp
#include<cmath>
#include<iostream>
using namespace std;
const int nm=10001,pq=20001;  //然而好像这边pq并没有什么x用
int n,m,p,q,a[nm],b[nm],i,x,y,ra[nm],rb[nm];
int afind(int x) //因为男女的变量名不同，所以也要分别写男女的过程
{
    if (x==a[x])return x;
    return a[x]=afind(a[x]);
}
void aunion(int u,int v)
{
    int f1=afind(u),f2=afind(v);
    if (f1==f2)return;
 if (f1>f2)swap(f1,f2);
    a[f2]=f1;
 ra[f1]+=ra[f2];  //将原来的人数加到新的人数上
}
int bfind(int x)
{
    if (x==b[x])return x;
    return b[x]=bfind(b[x]);
}
void bunion(int u,int v)
{
    int f1=bfind(u),f2=bfind(v);
    if (f1==f2)return;
    if (f1>f2)swap(f1,f2);
    b[f2]=f1;rb[f1]+=rb[f2];
}
int main()
{
    cin>>n>>m>>p>>q;
    for (i=1;i<=n;i++)a[i]=i,ra[i]=1;
    for (i=1;i<=m;i++)b[i]=i,rb[i]=1;
    for (i=1;i<=p;i++)
        cin>>x>>y,aunion(x,y);
    for (i=1;i<=q;i++)
        cin>>x>>y,bunion(abs(x),abs(y));
    cout<<min(ra[1],rb[1]); //直接输出两个较小的那个，无需再寻找
    return 0;
}
```

---

## 作者：PTC06 (赞：1)

很简单的并查集题目。

首先注意，朋友的朋友也是朋友（从样例可以看出来）

由于a公司的人都是同性,b公司也是，那么小明和小红的朋友肯定都是能成为情侣的。那么找出小明的朋友的数量以及小红的朋友的数量，输出其中小的那个就行了。

思路：

1.读入N,M,P,Q以及P,Q个正整数。

2.读入时，顺便将这些数join起来。（学过并查集的知道是什么意思吧。）不过可能有些人没学过，就解释一下吧。懂得可直接跳到3。

2\*
```cpp
void joinb(int x,int y)
{
    preb[schb(x)]=schb(y);
}
```
在这里，schb是在b公司中找到一个人的祖先（提示：可以将几个人的关系看成一个树），那么joinb表示将x这个人的祖先的父亲变成y的祖先（那么x和y就互为朋友了）。
3.然后，在a公司中找到所有小明的朋友，并统计小明朋友的数量。

4.在b公司中找到小红的朋友，统计这些人的数量。

5.输出小明朋友的数量、小红朋友的数量其中小的那个。

程序如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,n,n1,m,m1,a,b,prea[10000],preb[20000],suma,sumb;
int scha(int x)         
{
    if (prea[x]==x) return prea[x];
    prea[x]=scha(prea[x]);
    return prea[x];
}
int schb(int x)
{
    if (preb[x]==x) return preb[x];
    preb[x]=schb(preb[x]);
    return preb[x];
}
void joina(int x,int y)
{
    prea[scha(x)]=scha(y);
}
void joinb(int x,int y)
{
    preb[schb(x)]=schb(y);
}
int main()
{
    cin>>n>>n1>>m>>m1;
    for (i=1;i<=max(n,n1);i++)
    {
        prea[i]=i;
        preb[i]=i;
    }
    for (i=1;i<=m;i++)
    {
        cin>>a>>b;
        joina(a,b);
    }
    for (i=1;i<=m1;i++)
    {
        cin>>a>>b;
        a=abs(a);
        b=abs(b);
        joinb(a,b);
    }
    for (i=1;i<=n;i++)
    {
        if (scha(i)==scha(1)) suma++;
    }
    for (i=1;i<=n1;i++)
    {
        if (schb(i)==schb(1)) sumb++;
    }
    if (suma<sumb) cout<<suma; else cout<<sumb;
}
```

---

## 作者：Flying2018 (赞：0)

裸的并查集，直接用模板改编

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,m,k,f[10001],f2[10001],p,q;//f是小明的朋友，f2是小红的朋友
int find(int f[],int a)//为了方便，直接传数组
{  
    if(a==f[a]) return a;
    else f[a]=find(f,f[a]);//并查集核心，网上都有
    return f[a];
}
int main()
{
    cin>>n>>m>>p>>q;
    for(int i=1;i<=n;i++)
    f[i]=i;//初始化
    for(int i=1;i<=m;i++)
    f2[i]=i;//同上
    for(int i=1;i<=p;i++)
    {
        int a,b;
        cin>>a>>b;
        f[find(f,a)]=find(f,b);
    }
    for(int i=1;i<=q;i++)
    {
        int a,b;
        cin>>a>>b;
        a=-a;//注意，一定要把负数化正，否则会爆
        b=-b;
        f2[find(f2,a)]=find(f2,b);
    }
    int root1=find(f,1);//小明的根
    int root2=find(f2,1);//小红的根
    int t,t1;
    t=t1=0;
    for(int i=1;i<=n;i++)
    if(find(f,i)==root1)
    t++;//如果是小明的朋友就+1
    for(int i=1;i<=m;i++)
    if(find(f2,i)==root2)
    t1++;//如果是小红的朋友就+1
    printf("%d",t<t1?t:t1);//最多只能配成较少朋友的一边
    return 0;
}
```

---

## 作者：zirrtu (赞：0)

来一发c++的题解。

方法很清真，只要两次并查集一下，找出祖宗为1的元素个数，取两个之间小的那个就行。

ps：这个题是有坑的，每次合并时要把序号大的合并在序号小的之下，或者说要判断一下那个元素的祖宗是1，这样才可以过。

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#define MAXN 20001
using namespace std;
int n,m,p,q,a[MAXN],b[MAXN],sum1,sum2,ans;
int getf1(int);
int getf2(int);
void init();
int main()
    {
        int i,j,k;
        cin>>n>>m>>p>>q;
        for(i=1;i<=n;i++)a[i]=i;
        for(i=1;i<=m;i++)b[i]=i; 
        for(i=1;i<=p;i++)
           {
               int l,x,y,t1,t2;
               cin>>x>>y;
               t1=getf1(x);t2=getf1(y);
               if(t1>t2){l=t1;t1=t2;t2=l;}
               if(t1!=t2)a[t2]=t1;              
           }
        for(i=1;i<=q;i++)
           {
               int x,y,t1,t2,l;
               cin>>x>>y;x*=-1;y*=-1;
               t1=getf2(x);t2=getf2(y);
               if(t1>t2){l=t1;t1=t2;t2=l;}
               if(t1!=t2)b[t2]=t1;              
           }
        for(i=1;i<=n;i++)
           if(getf1(a[i])==1)
             sum1++;
        for(i=1;i<=m;i++)
           if(getf2(b[i])==1)
             sum2++; 
        ans=min(sum1,sum2);
        cout<<ans;
        system("pause");
        return 0;     
    }
int getf1(int x)
  {return a[x]==x?x:a[x]=getf1(a[x]);}
int getf2(int x)
  {return b[x]==x?x:b[x]=getf2(b[x]);}

```

---

## 作者：「QQ红包」 (赞：0)

裸的并查集,最后输出的结果是两者朋友较小的那个

```delphi

var n,m,p,q,sa,sb,i,j,x,y:longint;
    a,b:array[-100..10000] of longint;
function gfa(aa:longint):longint;//找爸爸
begin
    if a[aa]=aa then exit(aa) else begin  a[aa]:=gfa(a[aa]);exit(a[aa]); end;
end;
function gfb(bb:longint):longint;//合并
begin
    if b[bb]=bb then exit(bb) else  begin  b[bb]:=gfb(b[bb]);exit(b[bb]); end;
end;
procedure hba(a1,a2:longint);
var aa,bb:longint;
begin
    aa:=gfa(a1);
    bb:=gfa(a2);
    if aa<>bb then
       if aa=1 then
          a[bb]:=a[aa] else a[aa]:=a[bb];
end;
procedure hbb(b1,b2:longint);
var aa,bb:longint;
begin
    aa:=gfb(b1);
    bb:=gfb(b2);
    if aa<>bb then
       if aa=1 then
          b[bb]:=b[aa] else b[aa]:=b[bb];
end;
begin
    read(n,m,p,q);
    for i:=1 to n do
        a[i]:=i;
    for i:=1 to m do
        b[i]:=i;
    for i:=1 to p do
    begin
        read(x,y);
        if x<>y then
           hba(x,y);
    end;
    for i:=1 to q do
    begin
        read(x,y);x:=abs(x);y:=abs(y);
        if x<>y then
           hbb(x,y);
    end;
    for i:=1 to n do
        if gfa(i)=1 then inc(sa);
    for i:=1 to m do
        if gfb(i)=1 then inc(sb);
    if sa<sb then write(sa) else write(sb);
end.


```

---

## 作者：TMXi (赞：0)

十分裸的并查集。。。裸到可以用来练入门了。。。


开一个int用来记录每一个点的前驱。。。

路径压缩可以用递归：


```cpp
int getpre(int x){
    if(pre[x]!=x)pre[x]=getpre(pre[x]);   //不明白的仔细想想为什么吧......
    else return pre[x];
}
```


<hr>
然后就是合并


```cpp
void join(int x,iny y){   //x,y是已知有边相连的两点
    int prex,prey;        //分别记录x,y的前驱
    prex=getpre(x);
    prey=getpre(y);
    if(prex!=prey){
        pre[prex]=pre[prey]=min(prex,prey);   //个人习惯全部指向序号最小的点
    }
}

<hr>
因为两个公司间没有边，这就好办了，
用并查集找出A公司有多少人的前驱是小明，
再找出B公司有多少人的前驱是小红，
取二者最小值就OK了


---

## 作者：redegg (赞：0)

处理负数的话，<del>简单粗暴直接</del>优美地直接给每个数加上一个很大的数，将其变为正数进行处理。

为了方便做完并查集后进行统计。

我们可以在做并查集的时候总是把1和-1列为父亲。

详见代码，只要你能保证每次合并并查集的时候1和-1是父亲就行。

最后直接for一遍统计一下，两人的朋友有多少，最后取个min输出就行啦！

<del>希望过审！！！！好久都没交过题解了！！！</del>

```cpp
#include <bits/stdc++.h>
using namespace std;

int pr[1000000];
int n,m,q,p;

int findfa(int x)
{
    if(pr[x]==x)
    {
        return x;
    }
    return pr[x]=findfa(pr[x]);
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&q,&p);
    for(int i=0;i<=1000000;i++)
        pr[i]=i;
    for(int i=1;i<=q;i++)
    {
        int xx,yy;
        scanf("%d%d",&xx,&yy);
        xx+=20000;
        yy+=20000;
        if(findfa(xx)==20001)
        {
            swap(xx,yy);
        }
        if(findfa(xx)!=findfa(yy))
        {
            pr[findfa(xx)]=findfa(yy);
        }
    }
    for(int i=1;i<=p;i++)
    {
        int xx,yy;
        scanf("%d%d",&xx,&yy);
        xx+=20000;
        yy+=20000;
        if(findfa(xx)==19999)
        {
            swap(xx,yy);
        }
        if(findfa(xx)!=findfa(yy))
        {
            pr[findfa(xx)]=findfa(yy);
        }
    }
    int an1=0,an2=0;
    for(int i=1;i<=1000000;i++)
    {
        if(findfa(i)==19999)
        {
            an1++;
        }
        else if(findfa(i)==20001)
        {
            an2++;
        }
    }
    printf("%d",min(an1,an2));
    return 0;
}

```

---

## 作者：zhouzihan_2004 (赞：0)

本题不难，最大的难点就是如何处理负数（女人编号）

如何处理呢？可能大家的第一反应就是加偏移量。的确，这样子是可以AC的。不过这里的方法是开两个数组：第一个数组用来存A公司，第二个数组用来存B公司，这样也可以AC。

还有一个问题想问一下大家：为什么我一开始用了路径压缩只有40？删了路径压缩后反而100了

程序如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a,b,A[10001],q,ans,p,B[10001];
int Search(int x,int fa[])
{
    int tmp=x;
    while(tmp!=fa[tmp]) tmp=fa[tmp];
//    int i=x,j;
//    while(fa[i]!=i)
//    {
//        j=fa[i];
//        fa[i]=tmp;
//        i=j;
//    }
    return tmp;
} 
int main()
{
    cin>>n>>m>>p>>q; 
    for(int i=1;i<=n;i++)
      A[i]=i;
    for(int i=1;i<=m;i++)
      B[i]=i;
    for(int i=1;i<=p;i++)
    {
        cin>>a>>b;
        if(Search(a,A)==1) swap(a,b);
        A[Search(a,A)]=Search(b,A);
    }
    for(int i=1;i<=q;i++)
    {
        cin>>a>>b;
        if(Search(-a,B)==1) swap(a,b);
        B[Search(-a,B)]=Search(-b,B);
    }
    ans=0;
    for(int i=1;i<=n;i++)
      if(Search(i,A)==1) ans++;
    int tmp=0;
    for(int i=1;i<=m;i++)
      if(Search(i,B)==1) tmp++;
    cout<<min(ans,tmp);
    return 0;
}
```

---


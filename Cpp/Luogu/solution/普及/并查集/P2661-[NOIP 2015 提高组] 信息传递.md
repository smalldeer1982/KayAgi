# [NOIP 2015 提高组] 信息传递

## 题目背景

NOIP2015 Day1T2

## 题目描述

有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

## 说明/提示

**样例 1 解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)

游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。

- 对于 $30\%$ 的数据，$n\le 200$；
- 对于 $60\%$ 的数据，$n\le 2500$；
- 对于 $100\%$ 的数据，$n\le 2\times 10^5$。


## 样例 #1

### 输入

```
5
2 4 2 3 1```

### 输出

```
3```

# 题解

## 作者：KesdiaelKen (赞：368)

嗯……本人表示真的还不会toposort……所以，我就打了个奇奇怪怪的方法，居然也过了。

下面介绍一下我在本题的经历——

首先，我以为用set暴力判重能过，然而T了6个点。

然后，我彻夜不眠，思考着本题。然后，我就想出来了，然后就过了……

好吧，还是介绍一下思路。

可以把这些关系看成一个有向图。对于任意一个节点进入，因为每个点的出度均为1，所以最多只能构成三种情况：1、一条链；2、一个环链；3、一条链连接着一个环链。因为这三种情况极为的简单，所以就可以如下处理：

找任意一个点进入，记录到达每一个点所走过的遍数。当走到一个在这次查找中已经出现过的节点，即找到了一个环，用当前走到的步数减去在此节点原先记录的步数，便得到这个环的长度。由此搜遍所有点，找到这些环中最小长度的一个，并把它输出就可以了。

而如果就这样去做，会TLE，所以得再加一点优化。对于一次查找环中，由于此次查找中至多只有一个环，而此环已经确定，所以再有外部的链介入此环，它的状态仍然不变。所以可以加个判断，如果走到了已经被查找过的节点，便直接跳出。

下为代码，供大家参考：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
int dx[300000];//存每一个人传话的对象
bool visit[300000]={0},novisit[300000]={0};//visit存每次查找中被查到的点，而novisit存每次查找前，已经被查找过的点（及不用继续查找了）
int bs[300000]={0};//每次查找中第一次到一个节点所经过的边数
int minn=2e9;
void dfs(int node,int num)
{
    if(novisit[node])return;//不需要继续找了
    if(visit[node])//在此次查找中出现过
    {
        minn=min(minn,num-bs[node]);//形成一个环，取最小值
    }
    else
    {
        visit[node]=true;//在此次循环中经过
        bs[node]=num;//记录第一次到达时的步数
        dfs(dx[node],num+1);//搜索
        novisit[node]=true;//已经搜过
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&dx[i]);
    }
    for(int i=1;i<=n;i++)
    {
        dfs(i,0);//枚举全部节点
    }
    printf("%d",minn);//输出
    return 0;//时间复杂度O(n)
}
```

---

## 作者：深海鱼的眼泪 (赞：188)

题意很清楚，求图中最小的环。

如果一个人的入度为0，则肯定不可能成环，那么把这个人和他连出的边删去（即标记这个人并将他下一个人的入度减 1），

如果下一个人的入度为0则将他也删去……最后把所有入度为0的人都删去了，剩下的都是环。

每个人的出度为1，所以每个人只能在一个环中，每条边只能在一个环中，也就是说每个环都是分开的，

然后进行一遍 dfs，找出最小的环。



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <queue>
using namespace std;
int n,t[200050],d[200050],ans=1000000000,r[200050];
void read(int& x){
    x=0;
    int y=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') y=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    x=x*y;
}
void dfs(int ti,int s,int l){
    if (ti==s&&l){                                //如果回到开始说明连成了环 
        ans=min(ans,l);
        return;
    }
//    que.push(s);
//    int l=0;
//    while (!que.empty()){
//        int x=que.front();
//        que.pop();
//        if (x==s&&l){
//            ans=min(ans,l);
//            return;
//        }
//        
//    }
//    if (t[ti]!=-1) que.push(t[ti]);
    if (!d[t[ti]]) {
        d[t[ti]]=1;                                //标记 
        dfs(t[ti],s,l+1);
    }
}
void rmove(int ti){                                //删除ti 
    d[ti]=-1;                                    //标记 
    r[t[ti]]--;                                    //ti的下一个人的入度减一 
    if (!r[t[ti]]&&d[t[ti]]!=-1) rmove(t[ti]);
}
int main(){
    freopen("ferry.in","r",stdin);
    freopen("message.out","w",stdout);
    memset(d,0,sizeof(d));
    memset(r,0,sizeof(r));                        //r[i]为第 i 个人的入度 
    int i;
    read(n);
    for (i=1;i<=n;i++){
        read(t[i]);
        r[t[i]]++;
    }
    for (i=1;i<=n;i++){
        if (!r[i]&&d[i]!=-1) rmove(i);            //如果 i 的入度为 0 且还未被删除，则删除i 
    }
    for (i=1;i<=n;i++){
        if (!d[i]){                                //如果i还未搜过且未被删除，则从i开始搜索 
            //cout<<i<<' ';
            dfs(i,i,0);
        }
    }
    //cout<<endl;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：qhr2023 (赞：15)

## solution

题意就是求有向图中的最小环。可以用并查集处理环。

假设建立一条 $a$ 到 $b$ 的有向边时，更新 $a$ 祖先结点，若两点祖先相同则说明有环，环的大小是两点到祖先结点的距离和加一，距离边找祖先边处理即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/il5oz1z4.png)

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, fa[200005], ans=0x3f3f3f, cnt;
int find(int x){
    ++cnt;
	return (fa[x]==x?x:find(fa[x]));
}
int main(){
	cin >> n;
	for(int i=1; i<=n; i++)
		fa[i]=i;
	for(int i=1, t; i<=n; cnt=0, i++)
		cin >> t,
		find(t)==i?ans=min(ans, cnt):fa[i]=t;
	cout << ans;
	return 0;
}
```

---

## 作者：Ascnbeta (赞：6)

## P2661 [NOIP2015 提高组] 信息传递
刚学并查集，花了挺久才想清楚这题为什么能用并查集，写个题解整理思路。
## 题目大意
给定一个 $n$ 个点 $n$ 条边的有向无权图（不保证联通），求最小环的长度。

**保证每个点有且仅有 $1$ 条出边，不存在自环。**
## 思路分析
其实这题完全没必要用并查集，由于每个点出度都为 $1$ 的性质，直接 dfs 加上时间戳就可以通过。不过我们这里主要讨论并查集做法。

样例的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/nrvxyt6i.png)

不难确定答案是 $3$，但是我们要想这个答案是如何得出的。

首先建立并查集并初始化，开始每个点各自属于一个集合。同时我们要设一个数组 $dis$ 用来计算结点 $i$ 到其根节点的**图上**距离，初始值为 $0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0bfq7tc4.png)

（3，4 放反了）。

然后我们添加 $(1,2)$ 这条边，将 $1$ 与 $2$ 所在的树合并。

![](https://cdn.luogu.com.cn/upload/image_hosting/1kokrcp6.png)

接着我们添加 $(2,4),(3,2)$ 这两条边，操作后如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/wkspwop1.png)

（使用路径压缩后，$3$ 在连接到 $2$ 时会连到其根节点 $4$ 的位置）。

然后我们要添加 $(4,3)$ 这条边，这时候我们发现 $3$ 和 $4$ 已经在一个集合里了。因此我们就可以确定有一个环了。

但我们要如何确定最小环的长度呢？这时候 $dis$ 数组就派上用场了。先上代码：（代码中的 $v$ 数组就是上文的 $dis$ 数组）
```cpp
inline int find(int x) {
    if (father[x] != x) {
        int lst = father[x];
        father[x] = find(father[x]);
        v[x] += v[lst];
    }
    return father[x];
}
inline void merge(int x,int y) {
    int p = find(x);
    int q = find(y);
    if (p != q) {
        father[p] = q;
        v[x] = v[y] + 1;
    }else{
        ans = min(ans,v[x]+v[y]+1);
    }
}
int main () {
    cin >> n;
    for (int i = 1; i <= n; i++) father[i] = i;
    for (int i = 1; i <= n; i++) {
        int t;
        cin >> t;
        merge(i,t);
    }
    cout << ans << '\n';
    return 0;
}
```
当我们添加一条边时，如果这条边连接的两个点 $u,v$ 不在一个集合（一个环）里，则合并后，令 $dis_u = dis_v + 1$（$v$ 到祖先的**图上**距离加上这条边的长度 $1$），同时在查找的过程中重新更新查找路径上的所有 $dis$ 值。而如果 $u$ 和 $v$ 已经在一个集合里，则代表找到了一个环，则直接统计答案为 $dis_u + dis_v + 1$（$u$ 到自己祖先的**图上**距离加上 $v$ 到自己祖先的**图上**距离再加上当前这条边的长度 $1$）。

为什么只更新 $u$ 的值呢？因为边是有向边，所以添加这条边时只有从 $u$ 到 $v$ 的路而没有从 $v$ 到 $u$ 的路。

需要注意的是，这种方法只适用于所有点出度仅有 $1$ 的有向图，因为只有保证 $u$ 唯一时，$u,v$ 同时处在一个集合才等同于 $u,v$ 在环上。

可能以上说的有些琐碎，建议自己手玩一下样例可能就清楚了。
## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans = 0x3f3f3f3f;
int father[200005],v[200005],cnt;
inline int find(int x) {
    if (father[x] != x) {
        int lst = father[x];
        father[x] = find(father[x]);
        v[x] += v[lst];
    }
    return father[x];
}
inline void merge(int x,int y) {
    int p = find(x);
    int q = find(y);
    if (p != q) {
        father[p] = q;
        v[x] = v[y] + 1;
    }else{
        ans = min(ans,v[x]+v[y]+1);
    }
}
int main () {
    cin >> n;
    for (int i = 1; i <= n; i++) father[i] = i;
    for (int i = 1; i <= n; i++) {
        int t;
        cin >> t;
        merge(i,t);
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：JCT_addyi (赞：5)

### 题目大意：

有 $n$ 个同学，每个人向固定的一个人传自己知道的生日，包括自己的生日，可以想成在传自己知道的编号，那个人就知道别人传的消息和自己已知的消息，以此类推一直传下去，每个人依次传完后为一轮，知道一个人从别人口中知道自己的编号后，游戏停止，问可以传多少轮。

### 思路：

样例是同时进行的，但我们这里可以单独进行，依次从一个人一直传，这个人知道后再传给下一个人，不用同时进行，那么传一个人就是一轮，当重复时停止，每一次取最少的轮数。

### 代码如下：

用桶标记一下已知和当前轮数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[200005],n,t[200005],p[200005],ans=INT_MAX;//f传给谁 ，t标记数组，p排名 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>f[i]; //输入 
	for(int i=1;i<=n;i++){
		for(int j=i,k=0; ;k++,j=f[j]){//k是轮数 从i开始传，传给f[i],然后f[i]又传给f[f[i]].....以此类推一直传下去 
			if(t[j]!=0){//当重复了传不下去了（已经被标记了） 
				if(t[j]==i) ans=min(ans,k-p[j]);//如果标记的是第i项，取每一轮的最小值 
				break;
			}
			t[j]=i;//标记一下 
			p[j]=k;//标记当前轮数 
		}
	}
	cout<<ans;
	return 0;
}
```
谢谢大家！

---

## 作者：Dorg (赞：5)

日常工作，今天要交这最后一篇题解了，一道黄题。举起鼠标，享受人生。


------------
上题：[ P2661 信息传递](https://www.luogu.org/problemnew/show/P2661#sub)

本题很典型，关于仙人掌树（雾）。

我们首先定义一下仙人掌树： 一个节点只有一个出度的有向图：
![](https://cdn.luogu.com.cn/upload/pic/40466.png 
 )

很容易发现，一张连通图中只有一个环。

本题的目的是找到一个最小的环的长度。

------------
### 算法思路
1. 我使用深搜的办法，给每个节点打上时间戳。
   注意，我在每个节点上打了两个标记：
   a)mode：是第几批次搜索中发现的节点。
   b)time：在本连通图中是第几个访问的。
2. 接下来只要在DFS时进行一定的处理就可以相当简单的找到每幅图中的环：
   ![](https://cdn.luogu.com.cn/upload/pic/40471.png )
   

------------
## CODE
```
#include<bits/stdc++.h>
#define Maxn 200002

using namespace std;

int to[Maxn];
int vis[Maxn];
int mode[Maxn];

int Ans=Maxn+1;

void dfs(int now,int time,int mod){
	
	vis[now]=time;
	mode[now]=mod;
	// 有环
	if(vis[to[now]]!=0&&mode[to[now]]==mod){
		Ans=min(Ans,vis[now]-vis[to[now]]+1);
		return;
	}
	if(vis[to[now]]!=0)
		return;
	if(vis[to[now]]==0)
		dfs(to[now],time+1,mod);
	
}

int main(){
	
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>to[i];
	}
	
	int n_mod=0;
	for(int i=1;i<=n;i++){
		if(vis[i]==0){
			n_mod++;//批次数增加
			dfs(i,1,n_mod);
		}
	}
	cout<<Ans;
	
	return 0;
}
```
   

---

## 作者：meifan666 (赞：4)

### 题目大意
在一个有向有环图中有
$n$
个点，求该图中最小环的大小。
### 思路
我们都知道，拓扑排序能处理有向无环图，但若图中有环，拓扑排序就不会把环里的点排序。也就是说，我们可以先用**拓扑排序**筛选出在环里的点，再使用**深度优先搜索**求出每个环的长度，最后取最小值。

下面贴上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ru[200100],ans=INT_MAX,a;
int chu[200100];
bool vis[200100];
queue<int>topu;
void DFS(int x,int sum){
	if(vis[x]){
		ans=min(ans,sum);
		return;
	}
	vis[x]=1;
	DFS(chu[x],sum+1);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		ru[a]++;
		chu[i]=a;
	}
	for(int i=1;i<=n;i++){
		if(ru[i]==0)topu.push(i);
	}
	while(!topu.empty()){
		int t=topu.front();topu.pop();
		vis[t]=1;
		ru[chu[t]]--;
		if(ru[chu[t]]==0)topu.push(chu[t]);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i])DFS(i,0);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：fengjunjie (赞：4)

其实分析一下，这个题有3个key点

每一个结点只有一个出度，那么，1：在同一个链里不会出现两个环

2：在每一条不相连的链中都必有一个环

3：无论从某条链的哪个节点开始搜索，都能搜到该条链的环。

那么，对于200000 的数据规模， 我们完全可以用---枚举！！！

```cpp
program ex02;
var map:array[1..200000] of longint;
    v,u:array[1..200000] of boolean;
    n,i,j,h,t,k,ans,min:longint;
begin
  min:=maxlongint;
  readln(n);
  for i:=1 to n do begin read(map[i]); v[map[i]]:=true; end;
  for i:=1 to n do
   begin
     ans:=0;
     if v[i]=true then
     begin
       fillchar (u,sizeof(u),true);
       h:=i; t:=h;
       while (u[t]<>false)and(v[t]<>false) do
        begin
          u[t]:=false;
          v[t]:=false;
          t:=map[t];
        end;
       if u[t]= false then
       begin
         k:=map[t]; ans:=1;
         while k<>t do
          begin
            k:=map[k];
            ans:=ans+1;
          end;
       end;
       if (ans<>0) and(ans<min) then min:=ans;
     end;
   end;
  writeln(min);
end.
```

---

## 作者：Ray_yi (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2661)

#### 思路：

看完题后，第一种思路肯定是暴力模拟每一轮，在每一轮都判断有没有人知道自己的生日，但是，看了下数据范围，肯定超时。

那怎么办呢？再稍加思索下，发现我们可以用一个 $t$ 数组，来标记第 $i$ 个人是否知道第 $j$ 个人的生日，用一个 $r$ 数组，来标记当前的轮数，如果数组 $t$ 的第 $j$ 个数为 $1$ 那么代表他知道了自己的生日，用一个 $ans$ 数组，来记最小值，毕竟当有一个人知道了自己的生日时就结束。

#### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005],n,t[200005],r[200005],ans=INT_MAX;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		int j=i,k=0;
		while(1){
			if(t[j]){
				if(t[j]==i) ans=min(ans,k-r[j]);//记最小值
				break;
			}
			t[j]=i,r[j]=k;//标记是第几个人和轮数
			k++,j=a[j];
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ClaudeHsu (赞：2)

# **思路**

暴力也能过！

每个点都寻找自己，找到自己更新答案。

虽然复杂度为 $O(n^2)$ ，但是能过。

# **代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],b[200005],c[200005],d,ans=1e9,e;//注意ans初始1e9
int find(int x){
	d++;
	if(b[x]==x)return x; 
	return find(b[x]);
} //寻找自己
int main(){
    cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	for(int i=1;i<=n;i++)
	b[i]=i;//初始化
    for(int i=1;i<=n;i++){
    	d=0;
    	if (find(a[i])==i)ans=min(ans,d);//更新答案
		else b[i]=a[i];
    }
    cout<<ans;
    return 0;//好习惯
}
```

---

## 作者：CaiZi (赞：1)

这里给出一个严格 $O(n)$ 的 Tarjan 做法。

首先题意等价于求一张图内最小的环的点数，且这张图每个点出度均为 $1$。因为这张图每个点出度都为 $1$，所以这张图的每个 SCC 都是一个点数等于边数的环，否则至少有一个点的出度为 $2$。所以我们使用 Tarjan 缩点，然后求出每个大小 $\ge2$ 的 SCC 的大小的最小值即可，[板子题链接](/problem/P3387)。

代码展示：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dfn[200001],low[200001],siz[200001],tim,scc,n,x;
bool bel[200001];
stack<int>s;
vector<int>g[200001];
inline void tarjan(int i){
	tim++;
	dfn[i]=low[i]=tim;
	s.push(i);
	for(int j:g[i]){
		if(dfn[j]==0){
			tarjan(j);
			low[i]=min(low[i],low[j]);
		}
		else{
			if(!bel[j]){
				low[i]=min(low[i],dfn[j]);
			}
		}
	}
	if(low[i]==dfn[i]){
		int j;
		scc++;
		do{
			j=s.top();
			s.pop();
			bel[j]=true;
			siz[scc]+=1;
		}while(j!=i);
	}
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		g[i].push_back(x);
	}
	for(int i=1;i<=n;i++){
		if(dfn[i]==0){
			tarjan(i);
		}
	}
	x=INT_MAX;
	for(int i=1;i<=n;i++){
		if(siz[i]>=2){
			x=min(x,siz[i]);
		}
	}
	cout<<x;
	return 0;
}
```

---

## 作者：Thaumaturge (赞：1)

稍微想一下就能知道，一个人如果得知了自己的信息，那么他一定在一个强联通分量中，并且他接受到信息的时间就是强联通分量的大小

原因：首先，自己的信息传递给自己说明他一定至少在一个环中。考虑此题每个点有且仅有一条出边，因此每个环都是原图的极大强联通子图。因为如果一个强联通分量不是极大的，就意味着这个分量中的某个点必须有一条出边连向其他点，而这又与题设矛盾。

直接上板子，记录什么的都不需要。题目已经保证了没有自环，所以每个大小为$1$的强联通分量都不需要判断，直接忽略即可，答案即为所有强联通分量各自包含的点数量的最小值

好像和dfs没有什么区别了。。。（就是多了一堆常数）

```cpp
#include <bits/stdc++.h>

#define N 210000

using namespace std;

int dfn[N],low[N],num,top;//找最小环
int Stack[N],ins[N];

int ver[N],nex[N],head[N],nu;

int ans,n,x2;

inline void add(int x,int y){
	ver[++nu]=y;nex[nu]=head[x];head[x]=nu;
}

inline void tarjan(int x){//tarjan板子
	dfn[x]=low[x]=++num;
	Stack[++top]=x,ins[x]=1;
	for(int i=head[x];i;i=nex[i])
	{
		int y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y])
		  low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		int cnt=0,y=0;
		do{
			y=Stack[top--],ins[y]=0;
			cnt++;
		}while(x!=y);
		if(cnt!=1)
		ans=min(cnt,ans);
	}
}

inline int read(){
	int x=0;char c=getchar();bool y=1;
	for(;c<'0' || c>'9';c=getchar()) if(c=='-') y=0;
	for(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;
	if(y) return x;
	return -x;
}

int main(){
	ans=0x7f7f7f7f;
	n=read();
	for(int i=1;i<=n;i++)
	{
		x2=read();
		add(i,x2);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：I_AK_IOI_6645 (赞：0)

# P2661 [NOIP2015 提高组] 信息传递
不难看出是一个图，对于这种找公共祖先的第一反应肯定是深搜。但是提高组有一个简单又实用的神器，并查集。
我看前面没有并查集的题解，所以准备交一发。
### 思路
首先我们根据每个人只会传递给一个人可以看出是可以写并查集，再根据传递的信息可以知道是一个边带权并查集，但是这个题要求最少几轮就会有一个人知道自己的信息，所以可以理解成找一个最短的环，然后求一下环的长度。
### 代码
~~~
#include<bits/stdc++.h>
using namespace std;
int n;
const int N = 2e5+5;
struct node{//结构体可写可不写，也可以拆成两个数组
	int fa,dis;//第一个是祖先，第二个存到当前祖先的距离
}f[N];
int Find(int x){
	if(x == f[x].fa)	return x;//特判
	int root = Find(f[x].fa);//因为要带着边权所以提前存一下
	f[x].dis += f[f[x].fa].dis;
	return f[x].fa = root;
}
int main(){
	cin>>n;
	for(int i = 1;i<=n;i++){//不要忘了初始化
		f[i].fa = i;
	}
	int minn = 0x3f3f3f3f;
	for(int i = 1;i<=n;i++){
		int x;
		cin>>x;
		int xx = Find(x),ii = Find(i);//这里是因为可能会导致祖先跟着孩子跑了
		if(xx == ii){//如果成环，就求距离
		    minn = min(minn,f[x].dis+f[i].dis+1);//两个节点到环的距离+1是环的长度，因为没有计算祖宗的位置
		    continue;
		}
		f[ii].fa = xx;//更新
		f[i].dis = f[x].dis+1; 
	}
	cout<<minn;
}
~~~
有看不懂了可以在下面问。

---

## 作者：prh_rpjiajia (赞：0)

## 思路
题意:我们可以把众多同学抽象成一个有向图，节点
 $i$ 的后继节点为 $a[i]$。本题就是要找出这个图中的最小环。

我们设 
 $vis[i]$ 表示 $i$ 的编号（或者是第几个被遍历到的）。每遍历一轮新的编号就要在原来的基础上统一加上 $2n$ 防止混淆。


我们依次遍历每一个点，如果这个点还没被遍历过，我们就对它进行深度优先搜索操作，假设当前点为
 $i$：
- 如果 $i$ 的后继节点已经被遍历过，那么说明存在环或者是第二轮遍历。我们就更新答案，当前环的大小为 
 $vis[i]−vis[a[i]]$。
- 如果 $i$ 的后继节点没被遍历过，我们就将它的编号设为 $vis[i]+1$。


最后输出最小的答案。

```cpp
#include<cstdio>
#include<iostream>
#define int long long
using namespace std;
const int N=2e5+1;
int n,a[N],vis[N],ans=N,cnt=1;
void dfs(int x)
{
    if(vis[a[x]])
    {
        ans=min(ans,vis[x]-vis[a[x]]+1);
        return;
    }
    vis[a[x]]=vis[x]+1;
    dfs(a[x]);
}
inline int read();
signed main()
{
    int n=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int i=1;i<=n;i++)
        if(!vis[i])
        {
            vis[i]=cnt;
            cnt+=2*n;
            dfs(i);
        }
    printf("%lld",ans);
    return 0;
}
inline int read()
{
    int cnt=0;
    int wei=1;
    char ch=getchar();
    while (ch<'0'||ch>'9')
    {
        if (ch=='-')wei=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        cnt=cnt*10+(ch-'0');
        ch=getchar();
    }
    return cnt*wei;
}
```

---


# 家谱

## 题目背景

现代的人对于本家族血统越来越感兴趣。


## 题目描述

给出充足的父子关系，请你编写程序找到某个人的最早的祖先。


## 说明/提示

规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。

## 样例 #1

### 输入

```
#George
+Rodney
#Arthur
+Gareth
+Walter
#Gareth
+Edward
?Edward
?Walter
?Rodney
?Arthur
$```

### 输出

```
Edward Arthur
Walter Arthur
Rodney George
Arthur Arthur```

# 题解

## 作者：zhmshitiancai (赞：212)

发一个简单的题解 用stl的map把他和父亲直接连起来

不要转成序号再做：


```cpp
#include<cstdio>
#include<iostream>
#include<map>
using namespace std;
map<string,string>p;
string find(string x)
{
    if(x!=p[x]) 
        p[x]=find(p[x]);
    return  p[x];
}
string s,s1;
int main()
{
    char ch;
    cin>>ch;
    while(ch!='$')
    {
        cin>>s;
        if(ch=='#')
        {
            s1=s;
            if(p[s]=="") p[s]=s;
        }
        else if(ch=='+')
            p[s]=s1;
        else 
            cout<<s<<' '<<find(s)<<endl;    
        cin>>ch;
    }
    return 0;
}
```

---

## 作者：Iowa_BattleShip (赞：49)

**看我的无敌0ms代码（不用map！！！）**

用map映射是很方便，但我忘记怎么用了= =，所以就试了个不用map的代码，原本后面两个点是超时的，但突然发现这个搜索的循环可以分开循环，因为一般情况是在要搜的人的上面，所以先往上搜，没有再搜下面，然后竟然0ms够了（233）

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[50010];//并查集的记录父亲点
char b[50010][10];
int find(int o)
{
    while(a[o]!=o)//并查集的找父亲，因为我是一个一个记录上来的，然后就懒得用压缩路径了（反正0ms，AC就好233）
        o=a[o];
    return o;
}
int main()
{
    int i,j,n=0,s=0,k,p,u=0,l;
    while(1)
    {
        n++;
        scanf("%s",&b[n]);//b[n][0]储存类型('+','$','?','#')，后面储存人名
        if(b[n][0]=='$')
            break;
        if(b[n][0]=='?')
        {
            if(u==0)
                l=n-1;//l记录一共输入的人名个数
            if(u==0)
                for(k=1;k<=l;k++)//开始一个一个搜过去
                {
                    p=0;
                    if(b[k][0]=='#')
                    {
                        for(j=k;j>=1;j--)//二分for循环，因为一般情况在上面，但有些特殊的在下面，这个可以减时间
                        {
                            s=0;
                            if(b[j][0]=='+')
                            {
                                for(u=1;u<=6;u++)
                                    if(b[k][u]==b[j][u])
                                        s++;
                                if(s==6)
                                {
                                    a[k]=j;//把搜到的人名对应上，就是扔到一个集合里
                                    p=1;
                                    break;
                                }
                            }
                        }
                        if(p!=1)
                            for(j=k;j<=l;j++)//如果上面没搜到就往下搜
                            {
                                s=0;
                                if(b[j][0]=='+')
                                {
                                    for(u=1;u<=6;u++)
                                        if(b[k][u]==b[j][u])
                                            s++;
                                    if(s==6)
                                    {
                                        a[k]=j;//同上
                                        break;
                                    }
                                }
                            }
                    }
                    u=1;
                }
            p=0;
            for(i=l;i>=1;i--)//从下往上搜问的人名
            {
                s=0;
                if(p==1)
                    break;
                for(j=1;j<=6;j++)
                    if(b[n][j]==b[i][j])
                    {
                        s++;
                        if(s==6)
                        {
                            p=1;
                            k=i;
                            break;
                        }
                    }
            }
            for(i=1;i<=6;i++)
                printf("%c",b[n][i]);
            printf(" ");
            for(i=1;i<=6;i++)
                printf("%c",b[find(k)][i]);
            printf("\n");
        }
        a[n]=n;//一边输入一般初始化并查集
        if(b[n][0]=='+')//把儿子和父亲对应起来
            for(j=n;j>=1;j--)
                if(b[j][0]=='#')
                {
                    a[n]=j;//并查集
                    break;
                }
    }
    return 0;
}
```

---

## 作者：浩瀚星空 (赞：29)

# 非正解，暴力算法
#### 看到楼上各位大佬用map，本蒟蒻不禁瑟瑟发抖。    
这题很明显是用并查集做，由于名字的长度有且只有6个字符，所以可以用字符数组存放并进行查找。只需要存放名字，查找名字，查找祖先即可。   
查找是用for循环实现的，但不知道为什么没有TLE。  
### 注释详见代码：

```
#include <cstdio>
#include <iostream>
#include<algorithm>
using namespace std;
struct ren {
	char name[7];//这个结构体可以开二维数组，用来存放名字
} r[50005];
int fa[50005];//记录父亲节点
char k[7];//用来暂时存放名字
int find(int f) {//查找父亲节点
	if(fa[f]==f) {
		return f;
	} else {
		return fa[f]=find(fa[f]);//路径压缩
	}
}
int main() {
	char a;//用来存放#、+和？
	int f,cnt=0;
	for(int i=1; i<=10005; i++) {
		fa[i]=i;//初始化
	}
	while(cin>>a) {
		if(a=='$') {
			break;//结束符退出循环
		}
		if(a=='#') {//如果是父亲节点
			scanf("%s",k);//把名字暂时存进k数组
			int u=0;
			for(int i=1; i<=cnt; i++) {
				int t=0;
				for(int j=0; j<=5; j++) {
					if(k[j]!=r[i].name[j]) {
						t=1;
						break;
					}
				}//查找名字是否存在
				if(t==0) {
					u=i;
					break;
				}//如果名字已存在，标记位置
			}
			if(u==0) {//如果不存在
				cnt++;//数量加一
				f=cnt;//标记位置
				for(int j=0; j<=5; j++) {
					r[cnt].name[j]=k[j];
				}//存入名字
				fa[cnt]=find(f);//查找它的父亲
			} else {
				f=u;//标记位置
				fa[u]=find(f);//查找父亲
			}
		}
		if(a=='+') {//如果是孩子节点
			scanf("%s",k);//读入
			int u=0;
			for(int i=1; i<=cnt; i++) {
				int t=0;
				for(int j=0; j<=5; j++) {
					if(k[j]!=r[i].name[j]) {
						t=1;
						break;
					}
				}
				if(t==0) {
					u=i;
					for(int j=0; j<=5; j++) {
						r[i].name[j]=k[j];
					}
					break;
				}
			}//查找是否存在该名字
			if(u==0) {
				cnt++;
				for(int j=0; j<=5; j++) {
					r[cnt].name[j]=k[j];
				}//把名字存进数组
				fa[cnt]=find(f);//合并
			} else {
				fa[u]=find(f);//合并
			}
		}
		if(a=='?') {//如果是查找
			scanf("%s",k);
			int u;
			for(int i=1; i<=cnt; i++) {
				int t=0;
				for(int j=0; j<=5; j++) {
					if(k[j]!=r[i].name[j]) {
						t=1;
						break;
					}
				}//查找位置
				if(t==0) {
					u=i;
					break;
				}
			}
			printf("%s",k);//输出该名字
			printf(" ");
			printf("%s",r[find(u)].name);//输出它的祖先，因为它的祖先和它的父亲可能没有连起来，所以还要查找一次
			printf("\n");
		}
	}
	return 0;
}
```
#### 第一篇题解，求过！

---

## 作者：liuzitong (赞：23)

# 看这么多dalao写并查集，我忍不住打了个暴力。

可以先输入一个字符；

##### 1.如果是“#”就记录下它的编号，

##### 开始一次搜索（本蒟蒻用的深搜），如果之前出现过，那就记录他的pre【】（祖父）节点的编号（替换掉之前的）；

##### 2.如果是“+”就将他的父亲节点编号设为之前记录的编号，

##### 开始一次搜索，如果之前出现过，那就说明他之前是别人的父亲节点（没有父亲），就把他的父亲设为之前记录的编号；

##### 3.如果是“？”把他输入的输出一遍，

##### 再开始一次搜索，把他第一次（第几次都行）出现的编号记录下来，然后开始寻找到他的祖先输出即可；

实际上我的代码一开始TLE了两个点，于是把cin改成了getchar（）
### 勉强能过，下面交代码（~~想要完美代码去别的地方吧。。~~）


------------

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[50001][6];//记录每个人的名字
int pre[50001];//记录每个人的爸爸或祖父
bool ss(int c,int d){//深度优先搜索找第一次出现
    for(int i=0;i<6;i++){
        if(a[c][i]!=a[d][i])
            return 0;
    }
    return 1;
}
int main(){
    char g;
    int e,e2,t=0;
    for(int i=1;;i++){
        cin>>g;
        if(g=='$')//如果是'$'就结束啦
            return 0;	
        if(g=='#'){
            t++;
            for(int j=0;j<6;j++)//输入字符串(这样应该比scanf还快,但我不清楚)
		a[i][j]=getchar();
            e=i;//记录爸爸
            for(int j=1;j<=t;j++){//深搜找第一次出现
                if(ss(j,i)==1){
                    pre[i]=pre[j];
                    e=j;//如果有祖父就更新
                }
            }
        }
        if(g=='+'){
            t++;
            for(int j=0;j<6;j++)//输入字符串
		a[i][j]=getchar();
            pre[i]=e;//记录爸爸
            for(int j=1;j<=t;j++){//深搜找第一次出现
                if(ss(j,i)==1){
                    pre[j]=pre[i];/如果有爸爸就更新
                }
            }
            
        }
        if(g=='?'){
            for(int j=0;j<6;j++)//输入字符串
		a[i][j]=getchar();
            for(int j=1;j<=t;j++){//深搜找第一次出现
                if(ss(j,i)==1){
                    e2=j;
                    break;
                }
            }
            for(int j=0;j<6;j++)//输出他自己
		putchar(a[i][j]);
	    putchar(' ');
            while(pre[e2]!=0)//找祖先
                e2=pre[e2];
            for(int j=0;j<6;j++)//输出祖先
				putchar(a[e2][j]);
			putchar('\n');
        }
    }
    return 0;
}
```


------------

本蒟蒻打的纯暴力希望各位dalao喜欢~~(不喜欢也不要喷啊~~)~~


---

## 作者：fαns (赞：20)

看了楼下各位大佬的stl模板map和哈希表，本蒟蒻感到很疑惑不解（可能是因为我太水），所以我的方法是一个c语言的标准算法（自己认为）。

在这里向大家推荐几道并查集水题，可以让你更了解并查集。网址如下：

luogu P3367（标准模板）[luogu P3367（标准并查集模板）](https://www.luogu.org/problemnew/show/P3367)

luogu P1551（亲戚）[luogu P1551（亲戚，与模板差不多，可以当实践操作）](https://www.luogu.org/problemnew/show/P1551)

luogu P1892（团伙）[luogu P1892（团伙，特殊的并查集，有朋友和敌人之分）](https://www.luogu.org/problemnew/show/P1892)

这道题就是并查集，如果没有字符串的读入，名字都是数字的话，就是个标准模板，可能比P1892还简单一些，可是现在多了个字符串，那么我们为什么不让这些名字变成数字呢，我们给每个人都给予一个编号，只有输出时按名字用，这样这道题不就成了一道模板题吗？在这里写一下模板，提供并查集基本思路。
 
poj2524([poj 2524 Ubiquitous Religions（无所不在的宗教）](http://poj.org/problem?id=2524))
```cpp
#include<stdio.h> //poj 2524
#include<string.h>
int x[50001],n;
int getx(int a)
{
	if(x[a]==a) return a;	//因为初始化x[i]=i,表示目前他和别人的宗教信的不一样或别的人信的教和他一样，而他又是根节点 
	x[a]=getx(x[a]);	//每一步都把x[a]目前在的数的根节点信的教存入x数组里 
	return x[a];	//返回x[a] 
}
int main()
{
	int i,j,k,m,xx=0,ans;
	while(1)
	{
		scanf("%d%d",&n,&m);
		if(n==0&&m==0) break;
		ans=n;	//一开始一共有n个宗教 
		for(i=1;i<=n;i++)	//初始化，每个人一开始的宗教信仰就是i，这样可以避免重复。 
			x[i]=i;
		for(i=1;i<=m;i++)
		{
			int a,b;
			scanf("%d%d",&a,&b);	//表示a和b信的宗教是一样的 
			int xa=getx(a),xb=getx(b);	//找一下a和b目前的宗教信仰 
			if(xa!=xb)	//如果两个人之间的信仰相同就表明它们在之前已经ans--了，不用再减了 
			{
				x[xb]=xa;	//将xa与xb合并 
				ans--;	//每有两个人信仰的宗教相同宗教的个数就减少一个 
			}
		}
		printf("Case %d: %d\n",++xx,ans);
	}
	return 0;	
}
```
这就是并查集模板，那么我们现在先进行读入，然后给每个读入的数给一个编号，依次加下去就行了，但是要注意，如果读入的字符串与之前的某一个字符串相等，那么就不能使用依次加下去的编号了，要使用之前的编号，所以还要枚举前面的每一个字符串。
```cpp
#include<stdio.h>
#include<string.h>
int fa[50001],num[50001];
char names[50001][7];
int get(int x)	//之前poj 2524里解释过，这里就不再解释了
{
    if(fa[x]!=x) fa[x]=get(fa[x]);
    return fa[x];
}
int main()
{
    char ch;
    int i,t,n=0,tn,j;
    for(i=1;i<=50000;i++) fa[i]=i;	//初始化，每个人一开始的祖先就是他自己
    scanf("%c",&ch);	//我是字符与字符串分开读的
    while(ch!='$')
    {
        scanf("%s",names[++n]+1);
        num[n]=n;	//将n的值赋值给num[n]
        tn=n;	//游标，表示这个字符串的编号，一开始就是n
        for(i=1;i<n;i++)	//枚举之前的所有字符串
        {
        	for(j=1;j<=6;j++)	//枚举名字的6个字母
        		if(names[i][j]!=names[n][j])	//如果不相等则直接跳出循环
        			break;
			if(j>6)	//说明6个字母都相等
			{
				tn=i;	//将游标指向i
				break;	//跳出循环
			}
		}
        if(ch=='#')	//说明是父亲
        	……
        else if(ch=='+')	//子女
        	……
        else	//询问
            ……
        scanf("\n%c",&ch);
    }
    return 0;
}
```
之后如果遇到的是‘#’就说明这是个父节点，将父节点的编号保存，后面直到下一个父节点时做改变。如果遇到的是‘+’就将它与父节点合并，询问时先输出原本字符串，再输出空格，最后找到祖先的编号，输出。代码如下：
```cpp
if(ch=='#')	//说明是父亲
	fnum=num[tn];	//fnum表示父节点的编号
else if(ch=='+')	//子女
	a[get(num[tn])]=get(fnum);	//将num[tn]的祖先与fnum的祖先合并
else	//询问
{
  	printf("%s",names[tn]+1);	//先输出询问人的名字
  	printf(" ");	//输出空格
  	int fn=get(num[tn]);	//找到询问人祖先的编号
  	printf("%s",names[fn]+1);	//输出祖先的名字
  	printf("\n");
}
```
完整AC代码如下（无注释）：
```cpp
#include<stdio.h>
#include<string.h>
int fa[50001],num[50001];
char names[50001][7];
int get(int x)
{
    if(fa[x]!=x) fa[x]=get(fa[x]);
    return fa[x];
}
int main()
{
    char ch;
    int i,t,n=0,tn,j;
    for(i=1;i<=50000;i++) fa[i]=i;
    scanf("%c",&ch);
    while(ch!='$')
    {
    	int fnum;
        scanf("%s",names[++n]+1);
        num[n]=n;
        tn=n;
        for(i=1;i<n;i++)
        {
        	for(j=1;j<=6;j++)
        		if(names[i][j]!=names[n][j])
        			break;
			if(j>6)
			{
				tn=i;
				break;
			}
		}
        if(ch=='#')
        	fnum=num[tn];
        else if(ch=='+')
        {
        	fa[get(num[tn])]=get(fnum);
		}
        else
        {
            printf("%s",names[tn]+1);
            printf(" ");
            int fn=get(num[tn]);
            printf("%s",names[fn]+1);
            printf("\n");
        }
        scanf("\n%c",&ch);
    }
    return 0;
}
```

---

## 作者：Suiseiseki (赞：12)

自从有了STL以后，C++党好像越来越懒了，一翻题解，一呼百应地全是用map的啊。然而蒟蒻并不精通，只能写一个弱弱的hash来膜拜大神（~~也算是给P党一个安慰吧~~）

并查集也就不用讲了，至于hash，请看代码。
```cpp
#include <cstdio>
#define Mod 1999997
class String{
	protected:
		char c[7];
		int len;
		int hash_num;
	public:
		String(){
			c[0]='?';
		}
		char read(){
			len=0;
			c[0]=getchar();
			while((c[0]<'A'||c[0]>'Z')&&(c[0]<'a'||c[0]>'z')){
				c[0]=getchar();
			}
			while((c[len]>='A'&&c[len]<='Z')||(c[len]>='a'&&c[len]<='z')){
				c[++len]=getchar();
			}
			hash_num=0;
			for(int i=1;i<len;i++){
				if(c[i]>='A'&&c[i]<='Z'){
					hash_num=hash_num*52+c[i]-'A'+1;
				}
				else{
					hash_num=hash_num*52+c[i]-'a'+28;
				}
				hash_num%=Mod;
			}//读入时顺便计算hash
			return c[len];
		}
		int &hash(){
			return hash_num;
		}
		bool empty(){
			return c[0]=='?';
		}
		friend bool operator !=(String a,String b){
			if(a.len!=b.len){
				return 1;
			}
			for(int i=0;i<a.len;i++){
				if(a.c[i]!=b.c[i]){
					return 1;
				}
			}
			return 0;
		}
		void print(){
			for(int i=0;i<len;i++){
				putchar(c[i]);
			}
		}
};
int father[2000005];
String Hash[2000005];
int find(int x){//并查集模板
	if(father[x]==x){
		return x;
	}
	return father[x]=find(father[x]);
}
void merge(int x,int y){
	int fa_x=find(x),fa_y=find(y);
	if(fa_x==fa_y){
		return;
	}
	father[fa_y]=fa_x;
}
int main(){
	for(int i=0;i<Mod;i++){
		father[i]=i;
	}
	String name;
	char c;
	c=getchar();
	while(c!='#'&&c!='+'&&c!='$'&&c!='?'){
		c=getchar();
	}
	int now_fa;
	while(c!='$'){
		if(c=='#'){
			c=name.read();
			while(!Hash[name.hash()].empty()&&Hash[name.hash()]!=name){
				name.hash()=name.hash()*3+1;
				name.hash()%=Mod;//处理冲突
			}
			if(Hash[name.hash()].empty()){
				Hash[name.hash()]=name;
			}
			now_fa=name.hash();
		}
		else if(c=='+'){
			c=name.read();
			while(!Hash[name.hash()].empty()&&Hash[name.hash()]!=name){
				name.hash()=name.hash()*3+1;
				name.hash()%=Mod;
			}
			if(Hash[name.hash()].empty()){
				Hash[name.hash()]=name;
			}
			merge(now_fa,name.hash());
		}
		else{
			c=name.read();
			name.print();
			putchar(' ');
			while(Hash[name.hash()]!=name){
				name.hash()=name.hash()*3+1;
				name.hash()%=Mod;
			}
			Hash[find(name.hash())].print();
			puts("");
		}
		while(c!='#'&&c!='+'&&c!='?'&&c!='$'){
			c=getchar();
		}
	}
	return 0;
}

```
本人很蒟蒻，代码希望各位大佬勿喷

---

## 作者：清远学会 (赞：8)

# map + 模拟
### 弱弱的说一句：map真香；
## 切入正题：
### 本题求的是自己的最爸爸的祖先，所以，我先想到并查集；
### 但是看完样例一脸懵逼，
### 所以，就像用结构体打包一些东西；
### 目的吗  ~~emmmmmmm模拟链表~~
### 那结构体就是这个样子：
```cpp
struct node {
	string s; // 名字
	int fa,id;
    // 此人的爸爸的第一次出现的下标，和自己第一次出现的下标
	char isfa; // 存是爸爸还是儿子
}tag[N];
map<string,int> q;
```
### 当然，用map形成一个映射 将string映射到int（也就是编号）
### 捣鼓完这些，你就可以处理爹与儿子的关系啦
### 就是这样：
```cpp
while(1) {
	cin >> tag[++ cnt].s; // 二话不说，先读入；
	if(tag[cnt].s[0] == '?') break ; //不是爹或儿，跳出；
	tag[cnt].isfa = tag[cnt].s[0];
    // 处理一下，因为要用map匹配，先把标头掐掉，
    tag[cnt].s[0] = 'A';// 自己规定一个char符号，这样排除干扰
	if(!q[tag[cnt].s]) q[tag[cnt].s] = cnt,tag[cnt].id = cnt;
	else tag[cnt].id = q[tag[cnt].s];
    //以上，用map形成映射，如果map已被付过值，用id存，否则就新开一个
    //注意，id是此string最开始出现的值
	if(tag[cnt].isfa == '#') opt = tag[cnt].id;
    //如果是爸爸，就把他最开始出现的下标存一下
	if(tag[cnt].isfa == '+') tag[tag[cnt].id].fa = opt;
    //注意，儿子的爸爸应用该儿子的id存储
}
```
### 这样之后，对于查询，就跳爸爸就行了
```cpp
a = tag[cnt].s; //刚才最后一次读入
while(1) {
	if(a[0] == '$') break ; 
	a[0] = 'A'; int tmp = q[a];//先把开头掐掉，用map读取该儿子的下标
	for(int i = 1;i < a.size();i ++) 
    		cout << a[i] ; cout << " ";
    //先输出自己的名字，注意不要输出a[0];
	while(tag[tmp].fa) tmp = tag[tmp].fa;
    //借助已更新好的fa跳，一直跳到为0，说明已到头；
	for(int i = 1;i < tag[tmp].s.size();i ++) 
    		cout << tag[tmp].s[i] ; cout << endl;
    //输出爸爸；
	cin >> a;
}
```
## 在黏上高清无注释版的代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
#include<string>
#define N 500500
using namespace std;

struct node {
	string s;
	int fa,id;
	char isfa;
}tag[N];
int cnt,opt;
map<string,int> q;
string a;

int main() {
	while(1) {
		cin >> tag[++ cnt].s;
		if(tag[cnt].s[0] == '?') break ;
		tag[cnt].isfa = tag[cnt].s[0]; tag[cnt].s[0] = 'A';
		if(!q[tag[cnt].s]) q[tag[cnt].s] = cnt,tag[cnt].id = cnt;
		else tag[cnt].id = q[tag[cnt].s];
		if(tag[cnt].isfa == '#') opt = tag[cnt].id;
		if(tag[cnt].isfa == '+') tag[tag[cnt].id].fa = opt;
	}
	a = tag[cnt].s;
	while(1) {
		if(a[0] == '$') break ; 
		a[0] = 'A'; int tmp = q[a];
		for(int i = 1;i < a.size();i ++) cout << a[i] ; cout << " ";
		while(tag[tmp].fa) tmp = tag[tmp].fa;
		for(int i = 1;i < tag[tmp].s.size();i ++) cout << tag[tmp].s[i] ; cout << endl;
		cin >> a;
	}
	return 0;
}
```
### 总共38，还算短吧~~~

---

## 作者：岸芷汀兰 (赞：8)

###作者：岸芷汀兰###

##一、题目：##

[链接：洛谷原题](https://www.luogu.org/problemnew/show/2814)

##二、思路：##

明显的并查集。

需要注意的是数据结构——map映射:

`map<string,string>father`

这样就可以将字符串与字符串用并查集连接起来了。

就可以“随心所欲不逾矩”了。

具体思路见代码。

##三、我的C++源代码：##

    
    
```cpp
    // luogu P2814
    #include<iostream>
    #include<cstdio>
    #include<string>
    #include<map>
    using namespace std;
    const int maxn=50005;
    string a[maxn];
    int fa[maxn],n;
    map<string,string>father;//map映射
    string find(string x){//find操作
        if(x==father[x])return x;
        return father[x]=find(father[x]);//递归
    }
    int main()
    {
        string f1;//记录"父亲"
        while(1){
            char op=getchar();
            string str;//临时字符串
            if(op=='#'){
                cin>>f1;
                if(father[f1]=="")/*f1没有父亲*/father[f1]=f1;//置于顶端
            }
            else if(op=='?'){
                cin>>str;
                cout<<str<<" "<<find(str)<<endl;//输出
            }
            else if(op=='+'){
                cin>>str;
                father[str]=f1;//认爸爸
            }
            else if(op=='$')break;//跳出循环
        }
        return 0;
}
```

---

## 作者：Station (赞：5)

其实这题很简单，我们肯定用并查集来模拟，那我们怎么快速将人名映射出来呢，当然是用容器来存储，这里适合用的容器是map
~~（我最喜欢的容器）~~可以映射下标：map<string,string>fa第一个string类型表示的是一对关系中儿子是谁，第二个string类型表示的是一对关系中父亲是谁。但是我们需要写一个函数来跳出他最早的祖先。
```
inline string getfa(string x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
```
这是一段记忆化DFS来查找，也是并查集的核心部分。表示如果这个点的父亲是这个点，那么说明已经找到头了，就不找了。不然就找下去，并记住他。
附我的代码：
```
#include<bits/stdc++.h>
using namespace std;
map<string,string> fa;
string father,now,lst;
inline string getfa(string x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main(){
	freopen("gen.in","r",stdin);
	freopen("gen.out","w",stdout);
	char ch=getchar();
	while (ch!='$'){
		cin>>now;getchar();
		if (ch=='#'){
			father=now;
			if (fa[father]=="") fa[father]=father;//如果当前这个父亲没有父亲，那么我们就认为他是自己的父亲。
		}else
		if (ch=='+') fa[now]=father;else cout<<now<<" "<<getfa(now)<<endl;
		ch=getchar();
	}
	return 0;
}
```

---

## 作者：overflow (赞：4)

其他很多人都用map或者各种玄学方法卡，这里发一篇中规中矩的trie树的题解。
也没有用什么神奇操作，感觉这才是出题人想让我们写的东西。
没法跑到0ms这种玄学的时间，是时间也算比较稳定的了，十个测试点用时在4ms到9ms之间。
具体细节见代码。

```cpp
#include<cstdio>
#include<cstring>
const int N=500010;
int cnt=0;
int cnt_node=1;
int fa[N];
char name[N][10];
int next[N][26];
int number[N<<4];
int new_node()
{
	cnt_node++;
	int k;
	for(k=0;k<26;k++)next[cnt_node][k]=0;
	return cnt_node;
}
void add(char *s)
{
	int k,i,j;
	i=1;
	for(k=0;k<6;k++)
	{
		if(!next[i][s[k]-'a'])next[i][s[k]-'a']=new_node();
		i=next[i][s[k]-'a'];
	}
	number[i]=cnt;
	return;
}
int find_num(char *s)
{
	int k,i,j;
	i=1;
	for(k=0;k<6;k++)
	{
		i=next[i][s[k]-'a'];
		if(i==0)return 0;
	}
	return number[i];
}
int main()
{
	int k,i,j;
	int a,b,c;
	char ch;
	char tem[6];
	memset(fa,0,sizeof(fa));
	for(k=0;k<26;k++)next[1][k]=0;
	while(true)
	{
		ch=getchar();
		while(ch!='$' && ch!='#' && ch!='+' && ch!='?')ch=getchar();
		if(ch=='$')break;
		if(ch=='#')
		{
			for(k=0;k<6;k++)tem[k]=getchar();
			tem[0]='a'+(tem[0]-'A');
			a=find_num(tem);
			if(!a)
			{
				cnt++;
				add(tem);
				a=cnt;
				for(k=0;k<6;k++)name[cnt][k]=tem[k];
			}
		}
		else if(ch=='+')
		{
			for(k=0;k<6;k++)tem[k]=getchar();
			tem[0]='a'+(tem[0]-'A');
			b=find_num(tem);
			if(!b)
			{
				cnt++;
				add(tem);
				b=cnt;
				for(k=0;k<6;k++)name[cnt][k]=tem[k];
			}
			fa[b]=a;
		}
		else
		{
			for(k=0;k<6;k++)tem[k]=getchar();
			for(k=0;k<6;k++)printf("%c",tem[k]);
			tem[0]='a'+(tem[0]-'A');
			b=find_num(tem);
			while(fa[b])b=fa[b];
			printf(" ");
			printf("%c",'A'+(name[b][0]-'a'));
			for(k=1;k<6;k++)printf("%c",name[b][k]);
			printf("\n");
		}
	}
	
	return 0;
}
```


---

## 作者：hhe_benlaji (赞：3)

这道题乍一看乜jiba难（也不知道是哪个牙的说这是提高+,分明是普及题嘛），但是YY下就会发现只要用stl的map，秒秒KO好吧

不多说，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string>father;
string fat(string x)//找爸爸
{
    if(x!=father[x])
    {
        father[x]=fat(father[x]);
    }
    return father[x];
}
int main()
{
    //freopen("1.txt","r",stdin);
    char k;
    string f1,t;
    while(1)
    {
        cin>>k;
        if(k=='$') break;
        if(k=='#')
        {
            cin>>f1;//爸爸
            if(father[f1]=="") father[f1]=f1;
            continue;
        }
        else if(k=='+')
        {
            cin>>t;//儿子
            father[t]=f1;
        }
        else if(k=='?')
        {
            cin>>t;
            cout<<t<<' '<<fat(t)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Tsumi (赞：2)

# 思路十分简单
就是用map记录儿子对应的父亲，不断往上查找，直到再也没有父亲了，就是答案

## 其实就是~~不必维护并查集~~ 懒

```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
char in;
map<string,string>s;//map对应儿子与父亲map[儿]=父 
int main()
{
	string i;
	string father;//储存上一个父亲 
	while(cin>>in){
    //in读入首字符 
    if(in=='$') break;
		cin>>i;
		if(in=='#') father=i;//father是该父亲 
		if(in=='+') s[i]=father;//该父亲的儿子的父亲是father
		if(in=='?') {
			cout<<i<<" ";
			string find=i;//从该儿子开始往上找 
			while(1){
				if(s[find]=="")break;//空了，再也没有父亲了，就是答案 
				find=s[find];//不为空，则还有父亲，继续zhao 
			}
			cout<<find<<endl;
		}
	}
    return 0;
}
```




---

## 作者：lzcjoe (赞：2)

## P2814 家谱 题解
### 一、思路
#### 并查集和map映射
map映射：一种数据结构。
```cpp
map<string,string> f;
```
意思为建立一个特殊的数组，数组下标类型为string，数组存放的数据也是string类型的。然而它的本质还是普通数组，此处是将string类映射成int型。

此处用了map，就可以将输入的名字当成一个个整数（点），进行普通并查集即可。
### 二、代码
```cpp
#include<cstdio>
#include<iostream>
#include<map>//map库
using namespace std;
map<string,string> f;
string a,b;
//字符串a用于记录输入的名字，b用于记录输入的名字的祖先（如果它是父子关系中的儿子）。
string find(string v)
//并查集模板，寻找祖先的函数。
{
    if(f[v]==v)
    {
        return v;
    }
    else
    {
        f[v]=find(f[v]);
        return f[v];
    }
}
int main()
{
    char c;//第一个字符
    cin>>c;
    while(c!='$')
    {
        cin>>a;
        if(c=='#')//如果是父亲
        {
            b=a;//父亲为自己
            if(f[a]=="")//如果它没有祖先
            {
                f[a]=a;//祖先为自己
            }
        }
        else
        {
            if(c=='+')//添加儿子
            {
                f[a]=b;//祖先为父亲
            }
            else//寻找祖先
            {
                b=find(a);
                cout<<a<<" "<<b<<endl;
            }
        }
        cin>>c;
    }
    return 0;
}
```
Accepted  100 

用时: 109ms / 内存: 2892KB

---

## 作者：G_A_TS (赞：2)

## 不用STL，暴力出奇迹！
并查集模板题加字符串  
为什么要map。。。  

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	char name[11],pdd;
	int fa,len;
}P[100010];
char pd;
int FA,gs,root;
int find(int x)
{
	if(P[x].fa==x)
	{
		return x; 
	}
	return P[x].fa=find(P[x].fa);
}
int found(int x)
{
	for(int i=1;i<=gs;i++)
	{
		if(P[i].pdd!='?')
		{
			for(int j=1;j<=6;j++)
			{
				if(P[i].name[j]!=P[x].name[j])
				{
					break;
				}
				if(j==6)
				{
					return i;
				}
			}
		}
	}
}
int main()
{
    //freopen("gen.in","r",stdin);
    //freopen("gen.out","w",stdout);
    while(cin>>pd)
    {
    	cin>>P[++gs].name+1;
    	P[gs].pdd=pd;
    	P[gs].fa=gs;
    	P[gs].len=strlen(P[gs].name+1);
    	if(pd=='#')
    	{
    		FA=found(gs);
    	}
    	if(pd=='+')
    	{
    		int qaq=found(gs);
    		P[qaq].fa=find(FA);
    	}
    	if(pd=='?')
    	{
    		int qwq=found(gs);
    		root=find(qwq);
    		for(int i=1;i<=P[qwq].len;i++)
    		{
    			cout<<P[qwq].name[i];
    		}
    		cout<<" ";
    		for(int i=1;i<=P[root].len;i++)
    		{
    			cout<<P[root].name[i];
    		}
    		cout<<endl;
    	}
    }
}
```


---

## 作者：雷电音 (赞：2)

楼下的哈希表简短精悍……在看题解之前不懂哈希的本蒟蒻只好用链表+邻接表……麻烦又容易写错，但是还好过了

搜索祖先的话，首先想到的是并查集，蒟蒻就想，如果那些名字都是序号就快了。所以我把所有人名转成了序号，然后就是简单的并查集。重点在最后要怎么把人名对应的序号找出来。于是我用了邻接表，每个字母作为一个节点，有三个域：字母，下一个字母位置以及同级的字母位置。比如说George和Geoeee在链表中就共用前三个节点，而r这个节点的“同级字母位置域”就存Geoeee中第二个e的位置，r的下一个字母就是存g……以此类推。当然，最后一个节点还要再拉一个节点，这个节点的字母域就存这一串单词的序号。

看着有点绕，接下来看代码吧……辛苦各位看官了……


```cpp
type point=^node;
     node=record
      letter:longint;//字母域，用longint防止序号超出ASCII范围，当然字母也只能转换成数字              来存
      next,other:point;
     end;
var a,b,c,d,n,m,gb,temp,tian:longint;
    names:array[1..50000] of string[6];
    father:array[0..50000] of longint;
    s,s2:string;
    p,q:point;
    head:array['A'..'Z'] of point;
    ch:char;
function search(x:string):longint;//判断人名是否存在（不存在就返回0），以及查找存在时名字的序号
var v:longint;
begin
 v:=2;
 if head[x[1]]=nil then exit(0);
 p:=head[x[1]]^.next;
 if p=nil then exit(0);
 repeat
  if p^.letter<>ord(x[v]) then
    begin if p^.other=nil then exit(0) else p:=p^.other; end
    else begin p:=p^.next; inc(v); end;
 until v>6;
 exit(p^.letter);
end;
procedure zaolian(x:string);//将人名添加进链表
var v:longint;
begin
 if head[x[1]]=nil then//head的目的是加快首字母查询的速度，如果这个首字母不存在直接创建新的一串节点
   begin
    new(head[x[1]]);
    p:=head[x[1]];
    v:=2;
    while v<=6 do
      begin
       new(p^.next);
       p:=p^.next;
       p^.letter:=ord(x[v]);
       inc(v);
      end;
    new(p^.next);
    p:=p^.next;
    p^.letter:=gb;
   end
   else begin
    p:=head[x[1]]^.next;
    v:=2;
    while v<=6 do
      begin
       while (p^.letter<>ord(x[v])) and (p^.other<>nil) do p:=p^.other;//找找共用几个节点
       if p^.letter=ord(x[v]) then begin p:=p^.next; inc(v); end
         else if p^.other=nil then
           begin
            new(p^.other);
            p:=p^.other;
            p^.letter:=ord(x[v]);
            inc(v);
            while v<=6 do//没共用的就新建
              begin
               new(p^.next);
               p:=p^.next;
               p^.letter:=ord(x[v]);
               inc(v);
              end;
            new(p^.next);
            p:=p^.next;
            p^.letter:=gb;
            break;
           end
      end;
   end;
end;
function find(o:longint):longint;
begin
 if father[o]<>o then father[o]:=find(father[o]);
 find:=father[o];
end;
procedure union(fu,zi:longint);
begin
 fu:=find(fu);
 zi:=find(zi);
 father[zi]:=fu;
end;
begin
 for ch:='A' to 'Z' do head[ch]:=nil;
 for a:=0 to 50000 do father[a]:=a;
 gb:=1; readln(s);
 while s[1]<>'?' do
   begin
    if s[1]='#' then
      begin
       names[gb]:=copy(s,2,6);
       tian:=search(names[gb]);
       if tian=0 then
         begin
          zaolian(names[gb]);
          temp:=gb; inc(gb);
         end
         else temp:=tian;
      end;
    if s[1]='+' then
      begin
       names[gb]:=copy(s,2,6);
       tian:=search(names[gb]);
       if tian=0 then
         begin
          union(temp,gb);
          zaolian(names[gb]);
          inc(gb);
         end
         else union(temp,tian);
      end;
    readln(s);
   end;
 while s[1]<>'$' do
   begin
    s2:=copy(s,2,6);
    temp:=search(s2);
    writeln(s2,' ',names[find(temp)]);
    readln(s);
   end;
end.

```

---

## 作者：夏子汐 (赞：2)

# 一、思路
### 1.这种题目的最佳思路一定是并查集。
### 2.但是，并查集中用来存储根节点的father数组下标必须为int类型，但是人名却是char类型。
### 3.所以，我们使用stl集中的map工具。
### map的主要作用是使数组下标为非整型。定义代码为：
```cpp
map<string,string>fa;
```
### 还需使用以下头文件:
```cpp
#include<map>
```
# 二、代码
```cpp
#include<cstdio>
#include<map>//关键的头文件
#include<iostream>//因为scanf不能输出string类型，所以加设此代码（包括string的定义）
using namespace std;
map<string,string>fa;//这句代码的意思是，定义一个下标为string类型（第一个string），值为string类型的数组fa
char ch;//供输入
string s,f;//供记录
string find(string x)//寻找父节点函数
{
    if(x==fa[x])
    {
        return x;
    }
    return find(fa[x]);
}
int main()
{
	cin>>ch;//注意，一定不能用scanf，否则会TLE
    while(ch!='$')
    {
        cin>>s;
        if(ch=='#')
        {
            f=s;
            if(fa[s]=="")//如果根节点为空
            {
            	fa[s]=s;//则自己为根节点
			}
        }
        if(ch=='+')
        {
            fa[s]=f;//合并操作
        }
        if(ch=='?')
        {
        	cout<<s<<" "<<find(s)<<endl;//查询操作
		}
		cin>>ch;
    }
    return 0;
}
```


---

## 作者：Meaninglessness (赞：1)

# 难度：省（ti）选（gao）-
算法：MAP

（更多的概念需自行查百度，这里说一下基本的概念）

头文件
```
#include <map>
```
定义一个map
```
map <type,type> m; 
//定义map，这里的type可以是int，double，甚至是string
```

在map中有一些pair结构体，每一个pair有2个变量：key，value

key输出时换为first，value是second（见下）

这里的key对应你输入的第一个type，而value对应第二个type

例如：
```
map <string，int>
```
这里的key就是string类型，value就是int类型

下面是基本操作：
```
map<string,int> m;
m.insert(make_pair("abc",3)) //第一个pair,key存"abc"，value存3
m.insert(make_pair("ab",12)) //第二个pair,key存"ab"，value存12
map<int, string>::iterator it; //创建一个迭代器，方便下面的操作
it=find("abc")//查找key是"abc"的pair
//发现这个pair的key是"abc"，value是3，it指向它
cout<<(*it).first<<" "<<(*it).second<<endl;
//输出这个pair的key和value（应是"abc"和3）
it=find("1")//查找key是1的pair
//发现没有，这是it会指向m.end()
if(it==m.end())
	cout<<"can't find"<<endl;
else
	cout<<(*it).first<<" "<<(*it).second<<endl;
//应该输出can't find
//(还有一些操作在这里就不演示了,这个例子大家可以自己试一下)
```
## 现在，进入正题

题目的一些关键信息:

1.家族名字一定是6个字母

2.数据偏小

3.需用map加string解决



这道题的思路：（先给个不像伪代码的伪代码吧）

```cpp
while(输入儿子 并且输入的不是$)
{
	string 父亲 
	if(首字母是#)
	{
		 父亲=去掉第一个符号的儿子 
	} 
	if(首字母是+)
	{
		//放入map里
		m.insert(make_pair(去掉第一个符号的儿子，父亲)) 
	} 
	if(首字母是？)
	{
		map<string,string>::iterator it;//定义迭代器
		it=m.find(儿子) 
		if(找到了)
		{
			string 答案 
			while(还能找到)
			{
				答案=(*it).父亲 
				it=find((*it).儿子) 
			}
			输出原先的儿子和祖先 
		}
		else
		{
			输出两次儿子 
		}
	} 
} 
```

如果你理解了，你现在应该可以去写了

# 但是

这里还有个正解（给那些还是不懂的人看的，无注释）

```cpp
#include <iostream>
#include <cmath>
#include <string>
#include <algorithm>
#include <map>
using namespace std;

map <string,string> m;

int main()
{
	int i;
	string tmp,key;
	while(cin>>tmp && tmp[0]!='$')
	{
		if(tmp[0]=='#')
			key=tmp.substr(1,6);
		if(tmp[0]=='+')
			m.insert(make_pair(tmp.substr(1,6),key));
		if(tmp[0]=='?')
		{
			string ans;
			map<string,string>::iterator it=m.find(tmp.substr(1,6));
			if(it==m.end())
			{
				cout<<tmp.substr(1,6)<<" "<<tmp.substr(1,6)<<endl;
			}
			else
			{
				while(it!=m.end())
				{
					ans=(*it).second;
					it=m.find((*it).second);
				}
				cout<<tmp.substr(1,6)<<" "<<ans<<endl;
			}
		}
	}
	return 0;
}

```


---

## 作者：arthurwalnut (赞：1)

显然这只是并查集的一个入门题（~~对我来说当然非常简单~~），不过是要换成字符串，用个map而已

大佬：这就是你这一题用一个多小时的理由？

我：emmm（只不过又双叒叕死在了字符串换行符读入的问题上了）

代码：
```
#include<iostream>
#include<cstdio> 
#include<map>
#define MAXN 10000
using namespace std;
map<string,string>fa;//map类型的定义：注意没有空格 
string now,father;
string find(string x)//路径压缩函数 
{
    if(x==fa[x])
        return x;
    else
        return fa[x]=find(fa[x]);
}
int main()
{
	char relation;//确定关系的字符 
    cin>>relation;
    while(relation!='$')//如果输入文件有效
	{ 
		cin>>now;
		getchar();//非常重要！！！不写这句话读进来的名字就有一个换行符 
    	if(relation=='#')
		{
			father=now;
			if(fa[now]=="")
				fa[now]=now;//如果刚读入的是一个父亲关系且他还没有父亲，就让他自己当自己的父亲 
		}
		else if(relation=='+')
		{
			fa[now]=father;//如果刚读入的是一个儿子关系,就加入到图里面 
		}
		else 
		{
			cout<<now<<' '<<find(now)<<endl;//如果是要问询祖先，就按照要求输出
		}
		cin>>relation;//读入下一个关系 
    } 
    return 0;
}
```

---

## 作者：Dirt、 (赞：1)

### 看到各位用map的大佬的代码长度短的可怕 蒟蒻瑟瑟发抖

这里介绍一种字符数组+strcmp函数的写法

strcmp的用法：strcmp(s1,s2),s1,s2为字符串

若s1=s2则返回0，s1>s2则返回正数，s1<s2则返回负数

可以通过判断strcmp(s1,s2)是否等于0来判断s1与s2是否相等

我们以某个名字是第几个出现作为这个名字的编号 从而通过编号实现并查集

在输出的时候一定要在字符串名字后面写“+1” 否则可能会导致没有输出或者出错

献上蒟蒻丑陋的代码~

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int f[50003];
char a[50003][10],s[10],temp[10],last[10];
int cnt;
int find(int x)
{
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
int main()
{
	for(int i=1;i<=50000;i++)
		f[i]=i;
	while(scanf("%s",s))
	{
		if(s[0]=='$') break;
		for(int i=1;i<=6;i++)
			temp[i]=s[i];
            //将名字暂时用temp存储起来
            //s[0]不属于名字且名字长度只有6位，只需要从1循环到6
		bool flag=true;
		int k;
		for(int i=1;i<=cnt;i++)
			if(strcmp(temp+1,a[i]+1)==0)
			{
				flag=false;
				k=i;
				break;
			}//如果名字出现过就记录下它的编号
		if(flag)
		{
			cnt++;
			k=cnt;
			for(int i=1;i<=6;i++)
				a[cnt][i]=temp[i];
		}否则存储这个名字并记录编号
		if(s[0]=='#')
		{
			for(int i=1;i<=6;i++)
				last[i]=temp[i];
		}
        //如果输入的名字作为父亲，就将这个名字存到last字符串里面
		if(s[0]=='+')
		{
			int x;
			for(int i=1;i<=cnt;i++)
				if(strcmp(last+1,a[i]+1)==0)
				{
					x=i;
					break;
				}
			f[find(k)]=find(x);
		}
        //如果作为儿子，就寻找父亲的编号然后操作
		if(s[0]=='?')
		{
			printf("%s",temp+1);
			putchar(' ');
			printf("%s",a[find(k)]+1);
			putchar('\n');
		}//如果是询问，就输出它的名字和它父亲的名字
	}
	return 0;
}
```

---

## 作者：Dilute (赞：1)

## STL大法好！
### （看到楼下的大佬们都没有用我这个方法，我就来脱碳甲醛一下辣~~）

------------


**~~以上都是废话~~**

**我所说的这个方法，具体思路是这样的：**
- 最首先，基础的并查集大家应该都会，如果不会的话可以看代码或者出门右转P3367并查集模板
- 然后，STL中的Map可以直接方便地解决字符串哈希的问题
- 但是，每次都用一遍Map似乎显得有些不优美，似乎有些慢的说
- 所以，我们需要引进两个数组，一个Num和一个Names
- Num是一个Map，它的作用就是Num[“A”]表示名为A的人的编号
- 于是，Names就是反过来的Num，Name[i]表示编号为i的人的名字
- 总体而言，不仅加快了速度，还方便了调试

### 上代码~~
------------


```cpp
#include<bits/stdc++.h> // 万能头文件 

using namespace std;

int f[50100]; // 并查集，f[i]表示编号为i的人的祖先（可能是之一） 
map <string, int> Num; // 前面已经解释过了 
string Names[50100]; // 同上 
map <string, bool> Used;  // 表示这个人有没有被加进Num数组里面 

int Find(int x){ // 找到编号为x的人最早的祖先（并查集的东西） 
	if(f[x] == x) return x;
	int next = Find(f[x]);
	f[x] = next; // 路径压缩 
	return next;
}

void Link(int Fa, int Son){ // 将两个人连起来（把Son加到Fa的族谱下方） 
	f[Son] = f[Find(Fa)];
}

int main(){
	string Name; // 当前这组父子关系中儿子的名字 
	string Fa; // Fa ♂乐♂器 （划掉）其实是表示当前这组父子关系中父亲的名字 
	char Type = 'A'; // 顾名思义，当前读入指令的种类 
	int Cur = 0; // 当前编号编到第几个 
	int Fanum; // 表示当前这组父子关系中父亲的编号 
	while(Type != '$'){
		Type = getchar();
		switch(Type){
			case '#':{
				cin >> Fa;
				if(!Used[Fa]){ // 如果这人第一次出现，给他编个号 
					Used[Fa] = true;
					Num[Fa] = ++Cur;
					Names[Cur] = Fa;
				}
				if(f[Num[Fa]] == 0) // 如果他没有祖先，将他的祖先定义为他自己 
					f[Cur] = Cur;
				Fanum = f[Num[Fa]];
				break;
			}
			case '+':{
				cin >> Name;
				if(!Used[Name]){ // 如果这个人是第一次出现，给他编个号 
					Used[Name] = true;
					Num[Name] = ++Cur;
					Names[Cur] = Name;
				}
				if(f[Num[Name]] == 0) // 如果他没有祖先，将他的祖先定义为他自己 
					f[Num[Name]] = Cur;
				Link(Fanum, Num[Name]); // 设定：他是他爸爸的儿子 
				break;
			}
			case '?':{ // 问询操作：输出Name和Name最早的祖先 
				cin >> Name;
				cout << Name << " " << Names[Find(Num[Name])]<< endl;
				break;
			}
			default:break;
		}
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

只是一个普通的并查集问题，然而字符串的处理挺麻烦，然后遇到了神奇的BUG。。。

需要用到映射数组（关联式容器），实现编号到名字、名字到编号的互相转换；

需要注意的是，给名字的编号必须是它第一次出现的编号，后面的不能覆盖，，这就是我出现的bug之一。。

其余的应该很好写吧。。

```cpp
#include<iostream>  
#include<cstdio>  
#include<cstring>  
#include<map>  
using namespace std;  
map<string,int>name;  
map<int,string>num;  
map<string,bool>b;  
int f[50005];  
string s,ss;  
int i,j,k,len,father;  
bool pd=false;  
  
int find(int x)  
{  
    if (f[x]==x) return f[x];  
    f[x]=find(f[x]);  
    return f[x];  
}  
  
void merge(int x,int y)  
{  
    int f1=find(x);  
    int f2=find(y);  
    f[f1]=f2;  
    return;  
}  
  
int main()  
{  
    freopen("gen.in","r",stdin);  
    freopen("gen.out","w",stdout);  
    for (i=1;i<=50000;++i)  
      f[i]=i;  
    i=0;  
    while (cin>>s)   
    {  
        if (s=="$") break;  
        if (s[0]=='#'||s[0]=='+')  
        {  
            len=s.length();  
            ss=s.substr(1,len-1);  
            if (!b[ss])  
            {  
                i++;  
                name[ss]=i;  
                b[ss]=true;  
                num[i]=ss;  
                if (s[0]=='#') father=i;  
                if (s[0]=='+') merge(i,father);  
            }  
            else  
            {  
                if (s[0]=='#') father=name[ss];  
                if (s[0]=='+') merge(name[ss],father);  
            }  
        }  
        if (s[0]=='?')  
        {  
            if(pd==false)  
            for (j=1;j<=i;++j)  
              k=find(j);  
            pd=true;  
            len=s.length();  
            ss=s.substr(1,len-1);  
            cout<<ss;  
            cout<<" ";  
            cout<<num[f[name[ss]]]<<endl;  
        }  
    }  
    return 0;  
}  
```

---

## 作者：lwhllw (赞：1)

来个p党的题解

这个题目用并查集找最早先祖显然是比较简单的一种思路，对于人名的处理选择hash即可。

```cpp
const maxn=50010;
      xs=1000007;
var i,j,k,l,m,n,tot:longint;
    hashp:array[0..xs]of longint;
    fa:array[1..maxn]of longint;
    names:array[1..maxn]of string;
function hash(s:string):longint;
var i,k:longint;
begin
    k:=0;
    for i:=1 to length(s) do k:=((k+ord(s[i]))*100)mod xs;
    if hashp[k]=0 then
    begin
      inc(tot);
      names[tot]:=s;
      hashp[k]:=tot;
      exit(tot);
    end
    else exit(hashp[k]);
end;
function find(i:longint):longint;
var j,k,l:longint;
begin
    j:=i;
    while fa[j]<>j do j:=fa[j];
    find:=j;k:=i;
    while fa[k]<>j do //路径压缩
    begin
      l:=fa[k];
      fa[k]:=j;
      k:=l;
    end;
end;
procedure union(f,s:longint);
var fp,sp:longint;
begin
    fp:=find(f);sp:=find(s);  //为了区分合并父亲和儿子
    if fp<>sp then fa[sp]:=fp;
end;
procedure init;
var i,j,k,nowfa,nowson:longint;
    s,na:string;
begin
    s:='';
    for i:=1 to maxn do fa[i]:=i;
    while s<>'$' do
    begin
      readln(s);na:=s;
      delete(na,1,1);
      if s[1]='#' then nowfa:=hash(na);
      if s[1]='+' then
      begin
        nowson:=hash(na);
        union(nowfa,nowson);
      end;
      if s[1]='?' then writeln(na,' ',names[find(hash(na))]);
    end;
end;
begin
    init;
end.

```

---

## 作者：Kwork (赞：1)

这一题我写的比较无语，一开始题目的题面写错了，以为每组父子关系只有两行，然后以为是样例点给错了，然后WA。

问过之后才知道可能有多行。C++的字符串读入实在是有点慢，我非常累的用getchar（）读入，记得换行也是一个字符。

如果高级点的做法可以写一棵搜索树，每次读入一个人名就查询是否出现过，如果没出现过就把人数tot++，把他的数字编号设为现在的tot。

然后用并查集维护父子关系，记得是把儿子的父节点接到父亲的父节点。

由于搜索树写起来比较烦，我用map了。

由于一组关系可能有多于2行的人名所以我加了一大堆的操作，（能力弱写的多，莫喷）~~看不懂不要紧~~。

-------------------------------------------------------------------------------------------------------------------------------------------





```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <map>
using namespace std;
const int maxn=50000+20;
map<string,int>name_num;
map<int,string>num_name;
int p[maxn],tot=0;
char ch;
string s1,s2;
int find(int x){
    return x==p[x] ? x:p[x]=find(p[x]);
}
void Union(string a,string b){
    int xx=name_num[a];
    int yy=name_num[b];
    int x=find(xx);
    int y=find(yy);
    p[y]=x;
    return;
}
inline void add_person(string s){
    if(name_num[s]==0){
        name_num[s]=++tot;
        p[tot]=tot;
        num_name[tot]=s;
    }
    return;
}
int main(){
    int flag=0;
    while(true){
        if(flag!=1) ch=getchar();
        flag=0;
        if(ch=='$') return 0;
        if(ch=='?'){
            s2="";
            for(int i=1;i<=6;i++){
                ch=getchar();
                s2+=ch;
            }
            ch=getchar();
            int fa=find(name_num[s2]);
            cout<<s2<<" "<<num_name[fa]<<endl;
            continue;
        }
        if(ch=='#'){
            s1="";
            for(int i=1;i<=6;i++){
                ch=getchar();
                s1+=ch;
            }
            ch=getchar();
            add_person(s1);
            while(true){
                ch=getchar();
                if(ch=='#'){
                    flag=1;
                    break;
                }
                if(ch=='?'){
                    flag=2;
                    break;
                }
                if(ch=='+'){
                    s2="";
                    for(int i=1;i<=6;i++){
                        ch=getchar();
                        s2+=ch;
                    }
                    ch=getchar();
                    add_person(s2);
                    Union(s1,s2);
                }
            }
        }
        if(flag==2){
            s2="";
            for(int i=1;i<=6;i++){
                ch=getchar();
                s2+=ch;
            }
            ch=getchar();
            int fa=find(name_num[s2]);
            cout<<s2<<" "<<num_name[fa]<<endl;
            continue;
        }
    }    
    return 0;
}
```

---

## 作者：dph754132771 (赞：1)

代码短小，冰茶几（并查集）+map轻松过，map只是用来方便名字转序号，主要还是冰茶几


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
int fa[50005];
//fa是标号为i的人所在家族的祖先标号
char c;
//c是当前操作名
string n_f[50005],s;
//n_f是标号所代表的人名，s是当前人名。  
int n,f;
//n表示当前的人数，f表示当前操作的父亲标号。 
map<string,int>f_n;
//f_n是人名所代表的标号 
int find(int xx) {return xx!=fa[xx]?fa[xx]=find(fa[xx]):xx;}
int main(){
    scanf("%c",&c);
    while (c!='$'){
        cin>>s; 
        if (f_n.find(s)==f_n.end()) {
            n_f[n]=s;
            f_n[s]=n;
            fa[n]=n;
            n++; 
```
}//检查当前人名是否登录，没有则登录
```cpp
        if (c=='#') f=f_n[s];
        if (c=='+') fa[f_n[s]]=fa[f];
        if (c=='?') cout<<s<<" "<<n_f[find(f_n[s])]<<endl;//三种操作的处理 
        scanf("\n%c",&c);//关键是那个\n，我因为没弊掉回车符导致所有的操作c都变成了回车\n，于是就害我查了半天 
    }
    return 0;
}

```

---

## 作者：_诸神黄昏 (赞：1)


```cpp
//designed by Sweetangel
#include<bits/stdc++.h>
using namespace std;
const int maxn = 99999;
inline int read()
{
  int x=0,f=1;char c=getchar();
  while(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}
  while(c>='0'&&c<='9') {x=x*10+c-'0'; c=getchar();}
  return x*f;
```
}//从上一个程序改过来的懒得删，就挂在这里了。。。





    
```cpp
int e,F[maxn];
map<string,int> map1;
map<int,string> map2; 
//两个map用来实现字符串和数字的互化
//看到楼上大佬的代码才知道可以map<string,string>...
int find(int r)
{
  if(r!=F[r])
    F[r] = find(F[r]); //路径压缩
  return F[r];
}
int main()
{    
  for(int i=1;i<=maxn;i++)
    F[i] = i;//初始化并查集
  int x,rx,y,ry;
  //因为可能一~~多，所以申请在外面
  while(true)
  {
    char c;
    cin>>c;
    if(c=='$')
      break;
   //读入判定符号 #+?$,并判定跳出    
    string ss;
    cin>>ss;
    //读入字符串并在下面完成编号
    if(!map1[ss])
    {
      e++;
      map1[ss] = e;
         map2[e] = ss; 
       }
    //编号
       if(c=='#')
       {
       y = map1[ss];
       ry = find(y);
    }
    //记录父亲
       if(c=='+')
       {
         x = map1[ss];
         rx = find(x);
         if(rx!=ry)
         F[rx] = ry; //易错点：一定要让儿子指向父亲...，反向就wa...
       }
    //插入儿子
       if(c=='?')
       cout<<ss<<" "<<map2[find(map1[ss])]<<endl;
    }
    //输出答案
  return 0;
  //完美结束！
}
```

---

## 作者：米奇奇米 (赞：0)

[【P2814家谱原题】](https://www.luogu.org/problemnew/show/P2814)
# 题目描述：
### 给你一长窜名字，让你搞出他们的老祖先

# Solution:
## 一眼并查集题，而这道题目只要先搞一个暴力哈希，再就是一个裸的并查集！
## 暴力哈希的：暴力把字符串转数字，有利于并查集的实现：
```cpp
inline int chang(string s){
    for(register int i=1;i<=t;i++)
        if(str[i]==s) return i;//暴力把重复的姓名删去
        str[++t]=s;
    return t;//返回每一个名字的编号
}
```
## 于是就是无脑冰茶机+小模拟就轻松AC啦：
```cpp
int main(){
	for(register int i=1;i<=5e4+1;i++) fa[i]=i;
	do{//对不同的符号按照题目意思乱搞就行了
		cin>>c;
		if(c=='#') cin>>s1;
		if(c=='+'){ cin>>s2; if(s1!=s2) fa[find(chang(s2))]=find(chang(s1));  }
		if(c=='?'){ cin>>s2; cout<<s2<<" "<<str[find(chang(s2))]<<endl;  }
	}while(c!='$');
	return 0;
}
```
## CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
int const M=5e4+5;
int n,m,fa[M],ans,t,x;
string s1,s2,str[M];
char c;
inline int chang(string s){
    for(register int i=1;i<=t;i++)
        if(str[i]==s) return i;
        str[++t]=s;
    return t;
}
int find(int x){ if(x==fa[x]) return x;  return fa[x]=find(fa[x]); }//一句并查集
int main(){
	for(register int i=1;i<=5e4+1;i++) fa[i]=i;
	do{
		cin>>c;
		if(c=='#') cin>>s1;
		if(c=='+'){ cin>>s2; if(s1!=s2) fa[find(chang(s2))]=find(chang(s1));  }
		if(c=='?'){ cin>>s2; cout<<s2<<" "<<str[find(chang(s2))]<<endl;  }
	}while(c!='$');
	return 0;
}

```
## 为什么总觉得这道题目是恶意评分，最多一道黄题吧！



---

## 作者：_•́へ•́╬_ (赞：0)

## $STL$吼啊！
### 我用了$map$
### map<string,int>的用处：把人名变成序号
### map<int,string>的用处：把序号变成人名
```cpp
#include<bits/stdc++.h>//懒人专用头文件
using namespace std;
int f[50000],cnt,a2,b2;map<string,int>mmp1;map<int,string>mmp2;string a1,b1;
int find(int x){if(x==f[x])return x;return f[x]=find(f[x]);}
main()
{
	for(register int i=0;i<50000;++i)f[i]=i;//初始化
	for(;;)//屎循环
	{
		char opt;for(;opt=getchar(),opt!='#'&&opt!='+'&&opt!='?'&&opt!='$';);//输入
		switch(opt)
		{
			case'$':return 0;//结束
			case'#':cin>>a1;
					if(mmp1.count(a1))a2=mmp1[a1];//旧档案里有这个人，把档案翻出来查看
					else{a2=cnt++;mmp1[a1]=a2;mmp2[a2]=a1;}//新建一个档案
					break;//啥都不干
			case'+':cin>>b1;
					if(mmp1.count(b1))b2=mmp1[b1];//旧档案里有这个人，把档案翻出来查看
					else{b2=cnt++;mmp1[b1]=b2;mmp2[b2]=b1;}//新建一个档案
					f[b2]=find(a2);//储存b2是a2的孩子
					break;
			case'?':cin>>b1;b2=mmp1[b1];//把档案翻出来查看
					a2=find(b2);//找出b2的父亲
					a1=mmp2[a2];
					cout<<b1<<' '<<a1<<endl;//输出
		}
	}
}/**/
```

---

## 作者：离人怎挽 (赞：0)

并查集模板题,看大佬们都用字符哈希,像我这种不会哈希的蒟蒻只能用map了
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<map>
#include<string>
using namespace std;
map<string,string>f;
string find(string x)
{
    return f[x]==x?x:f[x]=find(f[x]);//查找x的祖先
}
char ch;
string s,x;
int main()
{
    for(int i=1;i;i++)
    {
        cin>>ch;
        if(ch=='$') break;
        if(ch=='#')
        {
            cin>>x;
            if(f[x]=="") f[x]=x;//x还没有祖先，将x的祖先设为自己
        }
        else if(ch=='+')
        {
            cin>>s;
            f[s]=x;//将s的祖先设为x，那么x的祖先也是s的祖先了
        }
        else if(ch=='?')
        {
            cin>>s;
            cout<<s<<' '<<find(s)<<endl;//输出s的祖先是谁
        }
    }
    return 0;
}
```

---

## 作者：呼啸山庄 (赞：0)

看好像没有用`Trie`树做的， Σ (ﾟДﾟ;) 

## 思路

表示C++选手有`STL`直接`map`......(Ｔ▽Ｔ)表示不熟。

因为是名字，我们不可能像原来一样做并查集，毕竟字符串不能直接当下标用（谁说的，`PHP`就行┐(ﾟ～ﾟ)┌ ）。那我们考虑给每个字符串一个序号(`Id`)，然后我们就可以愉快的做并查集了。

那我们怎么维护呢？把每个名字存下来怎么样？怎么存呢？

直接存？那判断是不是存在，我么要都遍历一遍所有已知的判重再赋序号。

`Trie`树怎么样。好像蛮好玩的。判重直接`getId`那输出怎么办？倒着存，记录`Id`的节点位置的字符，向上跑。

所以呢，在`Trie`树我们开两个变量记录下到当前节点的边所代表的字符和父节点，再开个数组记录`Id`的节点位置（链式前向星有木有，很像(⊙o⊙)…），然后......没有了。

## 代码

```c++
#include <cstdio>
#include <cstring>
const int maxA = 26 + 5;
const int maxN = 50000 + 5;
const int maxL = 6 + 5;
const int maxV = maxL * maxN;

int Cnt, nCnt;
int IdPos[maxN];
struct tree {
    int Id, Parent, Son[maxA];
    char Ch;
} Trie[maxV];
void Insert(const char *arr, const int &Len) {
    int Root = 0;
    for(int i = Len; i; --i) {
        if(!Trie[Root].Son[arr[i - 1] - 'a']) {
            Trie[Root].Son[arr[i - 1] - 'a'] = ++Cnt;
            Trie[Cnt].Parent = Root;
        }
        Root = Trie[Root].Son[arr[i - 1] - 'a'];
        Trie[Root].Ch = arr[i - 1];
    }
    Trie[Root].Id = ++nCnt;
    IdPos[nCnt] = Root;
}
int getId(const char *arr, const int &Len) {
    int Root = 0;
    for(int i = Len; i; --i) {
        if(!Trie[Root].Son[arr[i - 1] - 'a'])
            return 0;
        Root = Trie[Root].Son[arr[i - 1] - 'a'];
    }
    return Trie[Root].Id;
}
void Print(const int &Id) {
    // printf("%d %d %d ", Cnt, Id, IdPos[Id]);
    for(int i = IdPos[Id]; i; i = Trie[i].Parent) {
        if(Trie[i].Id == Id)
            putchar(Trie[i].Ch - 'a' + 'A');
        else 
            putchar(Trie[i].Ch);
    }
    putchar('\n');
}

int Parents[maxN];
int Query(const int &X) {
    return X == Parents[X] ? X : Parents[X] = Query(Parents[X]);
}
void Union(const int &X, const int &Y) {
    int pX = Query(X), pY = Query(Y);
    Parents[pX] = pY;
}

int PId, SId;
char tmp[maxL];
int main() {
    while(true) {
        scanf("%s", tmp);
        if(tmp[0] == '#') {
            tmp[1] = tmp[1] - 'A' + 'a';
            if(!getId(tmp + 1, 6)) 
                Insert(tmp + 1, 6);
            PId = getId(tmp + 1, 6);
            Parents[PId] = Parents[PId] ? Parents[PId] : PId;
            // printf("# %d %d \n", PId, Parents[PId]);
        } else if(tmp[0] == '+') {
            tmp[1] = tmp[1] - 'A' + 'a';
            if(!getId(tmp + 1, 6)) 
                Insert(tmp + 1, 6);
            SId = getId(tmp + 1, 6);
            Parents[SId] = Parents[SId] ? Parents[SId] : SId;
            // printf("+ %d %d\n", SId, Parents[SId]);
            Union(SId, PId);
        } else if (tmp[0] == '?') {
            printf("%s ", tmp + 1);
            tmp[1] = tmp[1] - 'A' + 'a';
            SId = getId(tmp + 1, 6);
            if(SId) {
                PId = Query(SId);
                Print(PId);
            } else {
                tmp[1] = tmp[1] - 'a' + 'A';
                printf("%s\n", tmp + 1);
            }
        } else if(tmp[0] == '$')
            break;
    }
    return 0;
}
```



---

## 作者：Tofu (赞：0)



------------


## **Map**和**set集合**并用，主算法还是并查集

### set判断是否存入该人

### 理解简单 

------------
### set用法：
# 插入：s.insert(元素)
# 查找：s.find(元素)     
## 返回元素所在位置，不存在则返回s.end()

------------




```cpp
#include <bits/stdc++.h>
using namespace std;
int b[50000];              //b用于并查集
int ans[50000],anss[50000];//ans存答案祖宗,anss存要求的人（均存编号）
string st,st1;             
string name[50000];        //编号-->人名
set<string> s;             //Set：保存人名
map<string,int> m;         //Map：人名-->编号
int i,j,n,t,x;
int find(int k){       //并查集操作
    if(b[k]==k)return b[k];
    else{
        b[k]=find(b[k]);
        return(b[k]);
    }
}
int main(){
    st="orzakcyc";   //初始化字符串读入
    while(st!="$"){
        cin>>st;
        if(st[0]!='?'){
          st1=st.substr(1,6);//临时字符串
          if(s.find(st1)==s.end()){  //判断是否在集合中（先前出现过）
          	n++;
            b[n]=n;
            name[n]=st1;
            s.insert(st1);   //存入Set
            m[st1]=n;        //存入Map
          }
          if(st[0]=='#'){    //x存储父亲编号
          	x=m[st1];
          }
          else{
          	b[find(b[m[st1]])]=find(b[x]);
          }
        }
        else{
        	st1=st.substr(1,6);
        	t++;
        	anss[t]=m[st1];
        	ans[t]=find(b[m[st1]]); 
        }
    }
    for(i=1;i<=t;i++)
      cout<<name[anss[i]]<<' '<<name[ans[i]]<<endl;
    return 0;
}
```
还剩10days了
加油！

---

## 作者：Forestcgl (赞：0)

不会用map的悲剧，只好自己写一个哈希算法,就是给每一个赋值，越大越好，因为我用的是50000，再加上并查集，完美AC
```cpp
#include<iostream>
using namespace std;
const int N=50002;
int f[N],base[6];
string name[N],s;
bool b[N];
int hash(string s)
{
	int hash_=0;
	for(int i=0;i<s.size();i++) hash_+=(s[i]-64)*base[i];
	return hash_%49999+1;
}
int find(int x)
{
	if(f[x]!=x) f[x]=find(f[x]);
	return f[x];
}
void unionn(int x,int y)
{
	int u=find(x);
	int v=find(y);
	if(u==v) return;
	f[u]=v;
}
int NAMEIP(int h_ash,string s)
{
	while(b[h_ash]&&name[h_ash]!=s)
	{
		h_ash++;
		if(h_ash>50000) h_ash=1;
	}
	return h_ash;
}
int main()
{
	base[0]=1;
	for(int i=1;i<6;i++) base[i]=base[i-1]*10;
	do
	{
		cin>>s;
		if(s=="$") break;
		int _hash=hash(s.substr(1,6));
		int nameip=NAMEIP(_hash,s.substr(1,6));
		if(!b[nameip])
	    {
	    	b[nameip]=1;
	    	name[nameip]=s.substr(1,6);
	        f[nameip]=nameip;//自己做父亲 
	    }
	    int father;
	    if(s[0]=='#') father=nameip;
	    if(s[0]=='+') unionn(nameip,father);
	    if(s[0]=='?') cout<<s.substr(1,6)<<" "<<name[find(nameip)]<<endl;
	}while(s!="$");
} 
```

---

## 作者：bztMinamoto (赞：0)

一道并查集的题目，只不过将数字变成字符串而已

可以把字符串转化成编码操作，不过用c++里的map更快

定义一个map，然后可以直接用并查集的模板解决这道问题

具体细节看注解，上代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
#include<vector>
using namespace std;
map<string,string> f;
string x,y;
string ff(string x)
{
    if(f[x]==x) return x;
    return f[x]=ff(f[x]);
}
//寻找祖先
void unite(string x,string y)
{
    x=ff(x),y=ff(y);
    if(x==y) return;
    f[x]=y;
}
//将两个人的祖先合并
int main()
{
    while(true)
    {
        string s;
        cin>>s;
        char c=s[0];
        if(s.size()>1) s=s.substr(1,s.size()-1);
        //字符c为要求，子串s为人名
        if(c=='#')
        {
            x=s;
            if(f.count(x)==0) f[x]=x;
            //如果没有祖先，定义祖先为自己，防止报错
        }
        else if(c=='+')
        {
            y=s;
            if(f.count(y)==0) f[y]=y;
            unite(y,x);
        }
        else if(c=='?')
        {
            cout<<s<<' '<<ff(s)<<'\n';
        }
        else if(c=='$')
        {
            break;
        }
    }
    return 0;
}
```

---

## 作者：Mr_Wu (赞：0)

**题目**

[Luogu2814 家谱](https://www.luogu.org/problemnew/show/P2814)

---------

**思路**

这题如果没有字符串处理，就是一道~~ez~~的并查集板子题。

所以这题的难点在于：字符串处理。

如果我们能有一个$f(x)$表示字符串$x$对应的编号$f(x)$，再有一个$g(x)$表示编号为$x$的字符串，在每次输入后调下$f(x)$，$merge$一下，询问的时候$g($根节点$)$，就能做出来了。

$map$时间复杂度高，我在这里介绍一下$hash$的解法。

普通$hash$函数直接完成了$f(x)$函数的功能，接下来我们令$names[hash(name)]=name$，以后询问的时候直接$names[getroot(hash(name)]$，这题就做完了。

--------

**$Hash$是什么？**

你可以将一个大字符串看成一个$T$进制位的整数，而每个字母都有它对应的值。

习惯上，我们直接使用每个字母的ASCII作为它代表的值。

计算的时候，你的结果需要%一个$MOD$。

```cpp
int hash(char str[]) //str的字符串部分从str[1]开始
{
    int i, l = strlen(str + 1), ret = 0;
    for (i = 1; i <= l; i++) ret = ((ret * T + MOD) % MOD + str[i] - '0' + MOD) % MOD;
    return (ret + MOD) % MOD;
} //这里的实现可以手算模拟一下
```

-------

**参考~~大常数~~代码**

```cpp
#include <cstdio>
#include <cstring>

const int MOD = 1000007, T = 12346; //定义hash的MOD和T
int fa[MOD]; //并查集
char names[MOD][7]; //names用来实现从字符串查到编号的功能

int get(int x)
{
    if (fa[x] != x) fa[x] = get(fa[x]);
    return fa[x];
} //你的get_root写法跟这个不一样没关系QwQ

int hash(char str[])
{
    int i, l = strlen(str + 1), ret = 0;
    for (i = 1; i <= l; i++) ret = ((ret * T + MOD) % MOD + str[i] - '0' + MOD) % MOD;
    return (ret + MOD) % MOD;
}

int main()
{
    char ch = getchar(), name[7];
    int i, lastfa = -1, nowhash, t;
    //lastfa是上次读入的父亲节点（字符串编号），也就是带'#'的节点
    for (i = 1; i <= MOD; i++) fa[i] = i; //并查集初始化，这道题里也说的过去，如果没有父亲节点，最早祖先就是自己
    while (ch != '$')
    {
        for (i = 1; i <= 6; i++) name[i] = getchar(); //读入名字
        nowhash = hash(name); //令nowhash=当前名字的hash值（编号），为了防止以后的重复调用hash()
        for (i = 1; i <= 6; i++) names[nowhash][i] = name[i]; //令names[hash(name)]=name
        if (ch == '#') lastfa = nowhash;  //更新lastfa
        else if (ch == '+') fa[get(nowhash)] = get(lastfa); //使此节点的最早祖先为它父亲的最早祖先，相当于合并它所在集合与父亲节点所在集合，所有节点的最早祖先统一
        else if (ch == '?')
        {
            for (i = 1; i <= 6; i++) putchar(name[i]); //先输出本人的名字
            putchar(' '); //一个空格
            for (i = 1; i <= 6; i++) putchar(names[get(nowhash)][i]); //最早祖先的名字
            putchar('\n'); //一个换行符
        }
        ch = getchar();
        while (ch == '\r' || ch == '\n' || ch == EOF) ch = getchar(); //这里是去除不必要的字符防止getchar()出现混乱，读入下一个需求的类型
    }
    return 0;
}
```

---


# 局域网

## 题目背景

某个局域网内有 $n$ 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 $f(i,j)$ 表示 $i,j$ 之间连接的畅通程度，$f(i,j)$ 值越小表示 $i,j$ 之间连接越通畅，$f(i,j)$ 为 $0$ 表示 $i,j$ 之间无网线连接。

## 题目描述

现在需要解决回路问题，我们将除去一些连线，使得网络中没有回路，**不改变原图节点的连通性**，并且被除去网线的 $\sum f(i,j)$ 最大，请求出这个最大值。

## 说明/提示

对于全部数据，保证 $1\le n \le 100$，$1\le f(i,j)\le 1000$。


## 样例 #1

### 输入

```
5 5
1 2 8
1 3 1
1 5 3
2 4 5
3 4 2
```

### 输出

```
8```

# 题解

## 作者：Rocket_raccoon_ (赞：29)

先分析一下题目，要使删去的边最大，等价于使剩下的边长度最小。

那么就可以使用最小生成树求解此题，只需要在输入时算出边长总和，再减去最小生成树的长度就行了。

这里详细介绍一下Kuskal算法。

首先，既然要求“最小生成树”，那我们就对所有边进行排序（使用sort的话非常简便）。但还要处理一个问题，那就是我怎么知道我加上的这条边是不是我需要的呢？

于是这就牵涉到一个简单却作用很大的算法“并查集”，不会的同学[戳这里](https://blog.csdn.net/u013546077/article/details/64509038)

Kuskal主要是针对排序边的贪心算法，可以想一下，既然是要求使图相连通，那么把现在没有连通的点用现在所拥有的边连上肯定不会错。

具体详见代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>//sort所需要的STL头文件
using namespace std;
int n,m,f[200],ans,x,sum;
struct lol{
	int from,to,val;//使用结构体存储边的两端点，长度
}l[20010];
bool cmp(lol a, lol b){
	return a.val<b.val;//sort排序设置边长为关键字
}
int find(int x){
	if (f[x]==x) return x;
	else return f[x]=find(f[x]);//并查集
}
void Kuskal(){
	int a,b;
	sort(l+1,l+1+m,cmp);//sort快排
	for (int i=1; i<=m; i++){
		a=find(l[i].from); b=find(l[i].to);//找两点的祖先
		if (a==b) continue;//ab在同一集合，即a，b点已连通，则跳过
		sum+=l[i].val;//记录长度
		f[a]=b;//合并
		x++;
		if (x==n) return;//边达到需要值，跳出函数
	}
}
int main(){
	int i;
	
	cin>>n>>m;
	
	for (i=1; i<=n; i++){
		f[i]=i;
	}
	for (i=1; i<=m; i++){
		scanf("%d%d%d",&l[i].from,&l[i].to,&l[i].val);
		ans+=l[i].val;//算总长
	}
	Kuskal();
	
	printf("%d",ans-sum);//输出
	
	return 0;
}

```

---

## 作者：hyfb (赞：8)

emmm让我们来看一下这道~~水题~~
由题意可得答案其实是**$\color{Red}\colorbox{W}{最小生成树的变形}$**
即 ans = w _总_  - w _最小生成树_ 
那么怎么求出最小生成树的值呢？
**并查集（炒鸡好用）**
废话不多说，上代码（希望这次能审核通过QWQ）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct note
{
	int from,to,len;
}e[10001];
int n,k,tot,sum,fa[10001];
int findfa(int x) { return fa[x] == x ? x :findfa(fa[x]);}
bool comp(const note & a, const note & b) { return a.len < b.len; }
int kruskal() {
    sort(e+1, e+k+1, comp);
    for (int i = 1; i <= n; i++) fa[i] = i;
    int cnt = 0; 
    for (int i = 1; i <= k; i++) {
        int fx = findfa(e[i].from), fy = findfa(e[i].to);
        if (fx == fy) continue;
        fa[fx] = fy; 
        sum +=e[i].len;
         
    }
    return sum;
}

int main()
{
	cin >> n >> k;
	for(int i=1;i<=k;i++)
	{
		int u,v,w;
		cin >> u >> v >> w;
		e[i].from = u;
		e[i].to = v;
		e[i].len = w;
		tot += e[i].len;
	}
	kruskal();
	cout << tot-sum << endl;
}
















```


---

## 作者：Kevin_F (赞：6)

Prim算法 + 并查集

分析：我们要做的是使去除的边边权最大，也就相当于剩余的边权总和要最小，所以这个问题就转化成最小生成树了。

先说明一下每个数组的意思：
    minn[i]：表示还未加入到最小生成树中的结点i，到已经加入到最小生成树结点的最小边权。
    u[i]：表示还未放进最小生成树的点。
    
然后我们用邻接矩阵存图，g[i][j]：表示从i到j的边权，默认成一个很大的数。

一些小的细节看代码注释吧

以下就是AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring> 
using namespace std;

int n,m,a,b,c;
int sum;//sum计算总边权 
int g[1001][1001],minn[1001];
bool u[1001];//表示还未加入到最小生成树中的点 

int main(){
	memset(g,0x7f,sizeof(g));
	memset(minn,0x7f,sizeof(minn));
	memset(u,true,sizeof(u));
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a>>b>>c;
		g[a][b] = g[b][a] = c;
		sum += c;
	}
	minn[1]=0;
	for(int i=1;i<=n;i++){
		int k=0;
		for(int j=1;j<=n;j++)
		  if(u[j] && minn[j] < minn[k])
		    k = j; //找到还没加入并且minn最小的点 
		    u[k] = false;//加入最小生成树 
		for(int j=1;j<=n;j++)
		  if(u[j] && g[k][j] < minn[j])
		    minn[j] = g[k][j];
	}
	int total = 0;
	for(int i=1;i<=n;i++) //统计最小生成树的总权值 
	  total += minn[i];
	cout<<sum - total<<endl;
	return 0;
}
```

---

## 作者：AOTO (赞：5)

# 主要算法：Kluskal
## 介绍一下：主要用到了并查集，将所有的边的畅通程度程度从小到大排序。Kuskal的思路就是一共有n个点，用n-1条边就可以将这n个点连起来。所以用并查集将没连起来的畅通程度最小的两个点连起来，每连一条就+1。一但加到总点数-1条就可以退出。
## 另外，将所有畅通程度加起来，把n-1条去掉，就是最大的畅通程度。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct ll{
	int xx,yy,zz;
}a[100001];
bool cmp(ll x,ll y)
{
	return x.zz<y.zz;
}
int n,m,s,n1,f[100001],l1,r1;
int find(int a)//找父亲
{
	if(f[a]==a)return a;
	f[a]=find(f[a]);
	return f[a];
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i].xx>>a[i].yy>>a[i].zz;
		s=s+a[i].zz;
	}
	sort(a+1,a+1+m,cmp);
	for(int i=1;i<=n;i++)
	f[i]=i;//赋初值
	for(int i=1;i<=m;i++)
	{
		l1=find(a[i].xx);r1=find(a[i].yy);
		if(l1!=r1)//如果没联通，则联通a[i].xx和a[i].yy的父亲节点
		{
			f[l1]=r1;
			s-=a[i].zz;n1++;
		}
		if(n1==n-1)break;//n-1条就可以退出
	}
	cout<<s;
	return 0;
}
```
# 本题为一道纯Kuskal，同此题学习Kuskal是一个好的方法

---

## 作者：Araragi_Shinobu (赞：5)

prim或kruskal都是0ms啊，本蒟蒻在这就两个一起发了


**kruskal**：


```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
struct edge
{
    int i,j,m;
}ed[10001];/存边
int n,k;
int father[101];/并查集，用来存此节点的祖先
long long sum=0;
bool comp(edge a,edge b)
{
    return a.m<b.m;
```
}//排序用的

```cpp
int getf(int d)//找祖先
{
    if(d==father[d])
    {
        return d;
    }
    return father[d]=getf(father[d]);
}
int main()
{
    cin>>n>>k;
//初始化
    for(int i=1;i<=n;++i)
    {
        father[i]=i;
    }
    for(int i=1;i<=k;++i)
    {
        cin>>ed[i].i>>ed[i].j>>ed[i].m;
        sum+=ed[i].m;
    }
    sort(ed+1,ed+k+1,comp);
    int bian=0;
    for(int i=1;i<=k;++i)
    {
        if(bian==n-1)
        {
            break;
        }
        int fai=getf(ed[i].i);
        int faj=getf(ed[i].j);
        if(fai!=faj)/若祖先不同，把边加入生成树
        {
            father[faj]=fai;
            bian++;
            sum-=ed[i].m;/减去此边权
        }
    }
    cout<<sum;
    return 0;
}
```
**prim（邻接矩阵蒟蒻法）**：
    
```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[120];
int road[120][120];
int book[120];
int n,k;
long long sum=0;
//初始化
void init()
{
    memset(book,false,sizeof(book));
    for(int i=1;i<=n;++i)
    {
        dis[i]=100000000;
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(i==j)
            {
                road[i][j]=0;
            }
            else
            {
                road[i][j]=100000000;
            }
        }
    }
}
int main()
{
    cin>>n>>k;
    init();//初始化
    for(int i=1;i<=k;++i)
    {
        int ii,jj,mm;
        cin>>ii>>jj>>mm;
        road[ii][jj]=road[jj][ii]=mm;//无向图
        sum+=mm;
    }
    dis[1]=0;
//prim
    for(int i=1;i<=n;++i)
    {
        int minnum=100000000;
        int k;
        for(int j=1;j<=n;++j)
        {
            if(dis[j]<minnum&&!book[j])
            {
                minnum=dis[j];
                k=j;
            }
```
}//找离生成树最近的节点
```cpp
        book[k]=1;//加入生成树
        for(int j=1;j<=n;++j)
        {
            if(k!=j&&!book[j]&&dis[j]>road[k][j])
            {
                dis[j]=road[k][j];
            }
        }
    }
    for(int i=1;i<=n;++i)
    {
        sum-=dis[i];//减去生成树中的边权值
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：2er0n3 (赞：4)

第一次写题解的我瑟瑟发抖

蒟蒻的题解奉上

这个题实际上是一个最小生成树的题，稍微换一下思路就好了，题目要求修改之后的图中不存在环，一共有n个点，m条边，如果不存在环的话只能有n-1条边，当你分析到这里，这就显然是一个最小生成树的题了

/展示代码/

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn=500002;
struct Edge{
    int u,v,w;
}e[maxn];//存图 
int f[maxn];
int n,m,sum,ans,tot;
bool cmp(Edge a,Edge b)//sort函数不必多说,Kruskal中权值排序 
{
    return a.w<b.w;
}
int Find(int x)//并查集基本操作 —查找 
{
    if(f[x]==x)    return x;
    return f[x]=Find(f[x]);
}
void Union(int x,int y)//并查集基本操作 —合并 
{
    f[Find(y)]=Find(x);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>e[i].u>>e[i].v>>e[i].w;
        sum+=e[i].w;//算出总共的 
    }    
    for(int i=1;i<=n;i++)
        f[i]=i;//并查集操作—初始化 
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m&&tot<n-1;i++)//寻找n-1条边构成最小生成树 
        if(Find(e[i].u)!=Find(e[i].v)) 
        {
            Union(e[i].u,e[i].v);
            tot++;
            ans+=e[i].w;//记录题目中修改剩下的边的最小流畅度的和； 
        }
    cout<<sum-ans;//用总权值-剩下的最小流畅度的和 =除去网线流畅度的最大值 
    return 0;
}

```

---

## 作者：Suuon_Kanderu (赞：3)

发个比较详细的吧，这个题解旨在让不会Kruskal的学会它。

- 首先你肯定知道最小生成树是什么： 在一个有$|V|$个点的无相连通图中，连接$|V-1|$个边，且不连通的图叫图的一颗生成树。那最小生成树呢？就是生成树中最小的那一珂。（废话
- 此题和最小生成树有什么关系呢？
	1. 我们发现，题目中说**剩下的图中不形成回路**
   2. 在不形成回路的基础上 被除取网线的 $f_{i,j}$  要尽可能大
   3. 除取网线的 $f_{i,j}$  要尽可能大不就是剩下的尽可能小吗？
   
   完美，就是最小生成树
- 学会kruskal
	
    1. 首先我们想，如果要让生成树树最小，那我们就取最小的$|V-1|$条边呗 ~~搞定，结束~~
    2. 注意，**剩下的图中不形成回路**
    3. 综上，我们在不行成回路的情况下添加边。（很简单
    4. 我们注意到，最复杂的就是判断是否形成回路，所以我们接下来要想办法判断加入某边后是否形成环。
    	- 我们发现，如果形成环，那么必然的，肯定连接的两个点在同一集合内（我语文不好，可能有歧义，姑且允许我这样描述
       -  有点抽象，来个图理解一下。
![](https://cdn.luogu.com.cn/upload/image_hosting/tyf37qd7.png)
   1. 我们来看这样一个图（图好丑
 ![](https://cdn.luogu.com.cn/upload/image_hosting/p6982opi.png)
   
   2. 当他被操作成这样时，我们要断开$ 4 - 2$。
   3. 4、2在一个集合里，有公共父亲为1
   4. 想到是什么了吗？对，就是并查集！
   5. 针对不知道并查集的OIer，我解释一下，就是存一下每个节点的最老的祖先，具体实现时递归回溯时标记一下就好了（怎么怪怪的
   6. 注： 这里的集合指被选过的节点（又有歧义了，所以我们就只要在 kruscal 时合并集合就可以了。
   7. 合并集合的方法，把一个集合最老的祖先换成另一个集合最老的祖先（easy

	并查集的code   
 ```
int find(int m)//寻找两个节点是否在一个集合中
{
    if(father[m]==m)return m;
    else
    {
        return father[m]=find(father[m]);//标记
    }
    return father[m];
}
void add(int k,int l){//合并
    father[find(k)]=find(l);
}
```
解决，上完整code：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
const int N = 1e6;
const int Max = 0x7fffffff;
struct side {
	int begin,end,cost;
	//起点，终点，价值 
}a[N];
int fa[N],ans;//并查集 
int b;
int n,m;
int find(int x) {
	if(x != fa[x])fa[x] = find(fa[x]);
	return fa[x]; 
}
int cmp(side a,side b){
	return a.cost < b.cost;
}
void kruskal() {//流程我再详细说一遍
	int sum = 0;//选的边有几条
	for(int i = 1; i <= m; i++){
		int b = a[i].begin,e = a[i].end,c = a[i].cost;
		if(find(b) == find(e))continue;//判断是否在一个集合中		
		fa[find(b)] = find(e);//合并集合
		ans += c;//答案
		sum++;
		if(sum == n-1)break;//如果选的边数 = 节点数-1，说明选好了
	}
}
signed main() {
	int x,y,z,sum = 0;
	cin >> n >>m;
	for(int i = 1; i <= n; i++){
		fa[i] = i;//并查集初始化，他们最开始父亲肯定是自己
	}
	for(int i = 1; i <= m; i++) {
		scanf("%d%d%d",&x,&y,&z);
		a[i].begin = x;
		a[i].end = y;
		a[i].cost = z;
		sum += z; //输入不说了
	}
	sort(a+1,a+m+1,cmp);//stl大法好（选出最小的
	kruskal();
	cout << sum - ans << endl;//总数 - 没选的 = 选了的
}
```

我相信像我这样的蒟蒻也能看懂

   

---

## 作者：JCZhang (赞：3)

# 发个Kruskal的题解
具体解释在博客里
连接在这
[JCZhang's Blog](https://jczhang.top/2018/04/30/mst-kruskal/)

代码如下
```cpp
#include <iostream>
#include <algorithm>
#define ll long long
struct edge {
    ll u, v ,w;
}e[200000];
ll fa[200000];
int n, m, ans, cnt;


void init();
ll find(int);
void Kruskal();
bool cmp(const edge &, const edge &);

int main() {
    std::cin >> n >> m;
    init();
    
    for (int i = 0 ;i < m; ++i)
        std::cin >> e[i].u >> e[i].v >> e[i].w, ans += e[i].w;
        
    Kruskal();
    std::cout << ans;
    return 0;
}

void init() {
    for (int i = 1; i < m; ++i)
        fa[i] = i;
}

void Kruskal() {
    std::sort (e, e + m, cmp);
    for (int i = 0; i < m; ++i) {
        ll fu = find(e[i].u);
        ll fv = find(e[i].v);
        if (fu == fv) continue;
        fa[fv] = fu; cnt++; ans -= e[i].w;
        if(cnt == n-1) break;
    }
}

ll find(int x) {
    if (fa[x] != x) fa[x] = find(fa[x]);
    return fa[x];
}

bool cmp(const edge &a, const edge &b) {
    return a.w < b.w;
}
```

很简单的模板题
一开始读入时， 先得到图的权值和
再找MST
减去MST权值就是ans了


---

## 作者：_YRH_ (赞：3)

极其典型的最小生成树的题目，Prim轻松过~

[/color][codec ]


```cpp
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
int a,b,c,i,j,k,l,m,n,inf=9999999,sum,max;
int e[101][101],minn[101];
bool u[101];
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(i==j)
                e[i][j]=0;
            else
                e[i][j]=inf;//构造邻接矩阵 
    for(i=1;i<=m;i++){
        scanf("%d%d%d",&a,&b,&c);
        e[a][b]=e[b][a]=c;
        max+=c;//max储存所有的畅通程度 
```
}//读入数据并存入矩阵
```cpp
    memset(minn,0x7f,sizeof(minn));
    minn[1]=0;    
    memset(u,1,sizeof(u));//初始化为True，表示所有点未被访问 
    for(i=1;i<=n;i++){
        k=0;
        for(j=1;j<=n;j++)//寻找一个与已访问的点相连的权值最小的未被访问的点k 
            if(u[j] && minn[j]<minn[k])
                k=j;
        u[k]=false;//将k加入最小生成树，标记已访问 
        for(j=1;j<=n;j++)//修改与k相连的所有未被访问的点 
            if(u[j] && e[k][j]<minn[j])
                minn[j]=e[k][j];
    }
    for(i=1;i<=n;i++)
        sum+=minn[i];//累加权值 
    printf("%d",max-sum);
    return 0;
}
[/codec ]
```

---

## 作者：TYX180129 (赞：2)

# 发个Prim的题解
### 其实就是最小生成树改一下，总权值-最小生成树=答案
## 细节见代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
int u[1005] ;//是否进入树 
int s[1005] ;//没加入树的节点 
int mp[1005][1005] ; //两点之间的距离 
int main()
{
	memset(mp, 1, sizeof(mp));//初始化mp 
	int tot = 0 ;
	int n , m , ans = 0 ;
	cin >> n >> m ;
	for(int i = 1 ; i <= m ; ++i)
	{
		int x , y , z ;
		cin >> x >> y >> z ;
		if(z < mp[x][y]) //选择权值小的 
			mp[x][y] = mp[y][x] = z ;
		tot += z ;//计算总权值 
	}
	memset(s, 1, sizeof(s));
	s[1] = 0; //设置起点  
	for(int i = 1 ; i <= n ; ++i)
	{
		int k = 0 ; 
		for(int j = 1 ; j <= n ; ++j)//寻找还没有进入树但是s最小的点 
			if(u[j] == 0 && s[j] < s[k])
				k = j ;
		u[k] = 1 ;
		ans += s[k] ;//进入树 
		for(int j = 1 ; j <= n ; ++j)
			if(u[j] == 0 && mp[k][j] < s[j])
				s[j] = mp[k][j] ;
	}
	cout << tot - ans ;//输出 
	return 0 ;
}
```
## 没有注释的代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
int u[1005] ;
int s[1005] ;
int mp[1005][1005] ;
int main()
{
	memset(mp, 1, sizeof(mp));
	int tot = 0 ;
	int n , m , ans = 0 ;
	cin >> n >> m ;
	for(int i = 1 ; i <= m ; ++i)
	{
		int x , y , z ;
		cin >> x >> y >> z ;
		if(z < mp[x][y]) 
			mp[x][y] = mp[y][x] = z ;
		tot += z ;
	}
	memset(s, 1, sizeof(s));
	s[1] = 0;
	for(int i = 1 ; i <= n ; ++i)
	{
		int k = 0 ; 
		for(int j = 1 ; j <= n ; ++j)
			if(u[j] == 0 && s[j] < s[k])
				k = j ;
		u[k] = 1 ;
		ans += s[k] ;
		for(int j = 1 ; j <= n ; ++j)
			if(u[j] == 0 && mp[k][j] < s[j])
				s[j] = mp[k][j] ;
	}
	cout << tot - ans ;
	return 0 ;
}
```


---

## 作者：0x小风 (赞：1)

萌新发第一次题解
Orz各位大佬
这题其实就是3366的改编，各位可以去看下3366
3366的代码是这样的
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,st[200005],ans,bian;
struct node
{
	int x,y,z;
} shu[200005];
bool cmp(node a,node b)
{
	return a.z<b.z;
}//上面的为结构体定义以及排序
int search(int a){return a!=st[a]?search(st[a]):a;}//查找a在哪个集合
void he (int a,int b)
{
	int na=search(a),nb=search(b);
	if(na!=nb)
	{
		st[na]=min(na,nb);
		st[nb]=min(na,nb);
	}
}//合并集合
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		st[i]=i;
	for(int i=1; i<=m; i++)
	{
		cin>>shu[i].x>>shu[i].y>>shu[i].z;

	}
	sort(shu+1,shu+m+1,cmp);
	for(int i=1; i<=m; i++)
	{
		int na=search(shu[i].x),nb=search(shu[i].y);
		if(na!=nb)
		{
			he(na,nb);
			bian++;
			ans+=shu[i].z;
		}
	}
	if(bian==n-1)
		cout<<ans<<endl;
	else cout<<"orz"<<endl;
//据说洛谷的数据中没有orz，我也没有测试，各位大佬可以去测试一下
	return 0;
}
```
然后我们会发现这题emmmmmmmm，就是把全部的z加起来然后减去ans，我5分钟a了俩题你能信。。。。
以下是此题的代码，你看完之后也许会大呼卧槽
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,st[200005],ans,bian;
struct node
{
	int x,y,z;
} shu[200005];
bool cmp(node a,node b)
{
	return a.z<b.z;
}
int search(int a)
{
	return a!=st[a]?search(st[a]):a;
}
void he (int a,int b)
{
	int na=search(a),nb=search(b);
	if(na!=nb)
	{
		st[na]=min(na,nb);
		st[nb]=min(na,nb);
	}
}
int main()
{
	int zong=0;
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		st[i]=i;
	for(int i=1; i<=m; i++)
	{
		cin>>shu[i].x>>shu[i].y>>shu[i].z;
		zong+=shu[i].z;
	}
	sort(shu+1,shu+m+1,cmp);
	for(int i=1; i<=m; i++)
	{
		int na=search(shu[i].x),nb=search(shu[i].y);
		if(na!=nb)
		{
			he(na,nb);
			bian++;
			ans+=shu[i].z;
		}
	}
	cout<<zong-ans<<endl;

	return 0;
}
```



---

## 作者：Miss灬hxh (赞：1)

这道题是一道经典的Kruska算法的模板题，只要懂得如何运用Kruskal算法，就很简单了，，，，

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm> 
using namespace std;    
int n,m,a,b,c,tot=0,v[10001],fa[10001],k[10001],num=0;
struct edge
{
    int from,to,next,data;
}e[10001];
bool comp(const edge &a,const edge &b)
{
    if(a.data<b.data)return 1;
    else return 0;
}
void add(int x,int y)
{
    tot++;
    e[tot].from=x;
    e[tot].to=y;
    e[tot].data=c;
    e[tot].next=v[x];
    v[x]=tot;
}
int find(int x)
{
    if(fa[x]!=x)return fa[x]=find(fa[x]);
    return x;
}
void uni(int x,int y)
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)fa[r2]=r1;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a>>b>>c;
        num+=c;
        add(a,b);
        add(b,a);
    }
    for(int i=1;i<=n;i++)k[i]=0x7fffffff;
    k[1]=0;
    for(int i=1;i<+n;i++)fa[i]=i;
    sort(e+1,e+tot+1,comp);
    int sum=0,p;
    for(int i=1;i<=tot;i++)
    {
        if(find(e[i].to)!=find(e[i].from))
        {
            uni(e[i].from,e[i].to);
            sum+=e[i].data;
            p++;
            if(p==n-1)break;
        }
    }
    cout<<num-sum;
    return 0;
}
```

---

## 作者：king_xbz (赞：0)

这题要求最大删边数，可转化为边的和-最小生成树，由此想到克鲁斯卡尔算法 

code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define q 109213
#define p 2001   //头文件与宏定义 
using namespace std;
struct node
{
	int x;
	int y;
	int v;//x,y表示两个节点，v表示权 使用结构体便于排序 
}
a[q];
int f[q];
inline int findx(int x);
inline bool cmp(node a,node b)//定义函数 
signed main()
{
	int n,k;
	cin>>n>>k; //输入计算机数及网线联通数 
	int ii,jj,m;
	int tt=0;
	for(int i=1;i<=k;i++)
	{
		cin>>ii>>jj>>m;
		a[i].x=ii;
		a[i].y=jj;用结构体储存节点 
		a[i].v=m;
		tt+=m;算出总边数 
	}
	for(int i=1;i<=n;i++)
	f[i]=i;初始化并查集 
	sort(a+1,a+1+k,cmp);以边为依据排序 
	int t=0,s=0;
	for(int i=1;i<=k;i++)
	{
		if(s==n)
		break;最多合并n次 
		if(findx(a[i].x)!=findx(a[i].y))
		{
		f[findx(a[i].x)]=findx(a[i].y);合并块 
		t+=a[i].v;统计最小生成树的大小 
		s++;合并次数统计 
	}
	}
	cout<<tt-t;用总边数-最小生成树=最多删边数 
	return 0;返回ac 
}
函数部分 
inline int findx(int x) 并查集的查函数 
{
	if(f[x]==x)
	return x;         如果f[x]==x查找结束，找到祖先 
	return f[x]=findx(f[x]);接着向下查找 
}
inline bool cmp(node a,node b)
{
	return a.v<b.v; 用边为依据由小向大排序 
}
```cpp

---

## 作者：CNF_Acceptance (赞：0)

# Prim 算法

看到好多奆佬写的都是Kruskal，

~~本蒟蒻根本就不（bu）想（hui）写（yong）！~~


------------


下面来介绍一下Prim算法：

#### Prim算法的核心：每次确定一个点。
初始化：

从图F中任取一个点作为起点（最小生成树的根），并将它标记为已

确定的点（下面把已确定的点称为白点，未确定的点为蓝点）。

重复以下操作：

（1）枚举所有白点i与蓝点j，选择最小边权值<i，j>。

（2）将点j标记为白点，将边<i，j>的边权值加入答案（ans）。

直到图F被标记过n次为止，
###### 最小生成树就这样诞生了！！！


------------


下面，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum,k;       //累加和 
bool vis[102];   //白蓝点
int n,dis[102];  //记边 
int f[102][102]; //记图 
long  long ans=0;//权值 
void Prim(){
	//开始时全是蓝点 
	memset(vis,true,sizeof(vis));
	//记为最大值 
	memset(dis,0x7f,sizeof(dis));
	//将1设为最小生成树的根，距离为0
	dis[1]=0;
	for(int i=1;i<=n;i++){
		int h=0;
		//找出与i点相连的所有点中边权最小的点 
		for(int j=1;j<=n;j++){
			if(vis[j]&&dis[j]<dis[h]){
				h=j;
			}
		}
		//加上 
		ans+=dis[h];
		//把h点记为白点 
		vis[h]=false;
		//修改所有蓝点到生成树的距离 
		for(int j=1;j<=n;j++){
			if(vis[j]&&f[h][j]<dis[j]){
				dis[j]=f[h][j];
			}
		}
	}
}
int main(){
	//输入，不用多说。
	cin>>n>>k;
	for(int i=1;i<=k;i++){
		int x,y,z;
		cin>>x>>y>>z;
		f[x][y]=f[y][x]=z;
		sum+=z;//累加，后面有用
	} 
   //一定要记住这一段，将没赋值的边设为无穷大
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i!=j&&f[i][j]==0){
				f[i][j]=1e9;
			}
		}
	}
	Prim();//Prim算法
	//因为要输出的是删除的边，
	//所以要用总和减去最小生成树的值
	cout<<sum-ans;
	return 0;
}
```


---

## 作者：清辉暮翊晨 (赞：0)

Kuskal模(mú)板

只是稍微变了下形。。。

Kuskal算法需要利用并查集，较详细的解释在代码里。


“需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大”

这是一句非常重要的提示，即剩余的所有边边权之和最小，最小生成树就是用来解决这种问题的，所以应该先建树，再求除去的最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
int f[1005];
struct aa{int l,r,w;}e[1050];//结构体三个元素分别存边连接的两个点和边权
int cmp(aa a,aa b){return a.w<b.w;}
int find(int x){return f[x]==x?x:f[x]=find(f[x]);} //三目运算符 若？前条件为真执行：前的语句 为假执行：后的；这个函数的作用是寻找父节点和路径压缩
void K()
{
	sort(e+1,e+1+k,cmp);//按边权值从小到大排序 这样连边时就优先连接较小值
	for(int i=1;i<=k;i++)
	{
		int x=find(e[i].l),y=find(e[i].r); 
		if(x==y)continue;//如果连接则跳过下面的步骤
		ans+=e[i].w;//最小生成树权值加
		f[y]=x;//连边
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)f[i]=i;//先初始化自己是自己的父节点 这一步对于并查集特别重要
	for(int i=1;i<=k;i++)scanf("%d%d%d",&e[i].l,&e[i].r,&e[i].w);
	K();//执行函数
	int sum=0;
	for(int i=1;i<=k;i++)sum+=e[i].w;
	printf("%d",sum-ans);
}
```
蒟蒻的第三篇题解。。求过qwq(其实第二没过)


---

## 作者：zhaowangji (赞：0)

做这题，需要懂得最小生成树（MST）和并查集

可以自己先看一下一本通的相关章节

这里简单说明一下

并查集保存每个点的“祖先”，而单纯的保存祖先使得遍历时间较长，故更改保存方式：把这一家的人的祖先，都设为最老的那个

比如1，2，3，4，5

1是最老的，然后依次递减

那么普通方法是1的祖先是1，2的祖先是1，3的祖先是2,4的祖先是3……

而优化方法表示为：1的祖先是1，2的祖先是1，3的祖先是1，4的祖先是1……

这样可以大大提高判断两个人是否是亲属关系的速度

最小生成树指：
n个点，用n-1条边相连（就是树），使得这n-1条边的边权和最小

一般来说，使用克鲁斯卡尔（Kruskal）算法较好（用到并查集）

首先将所有的边按边权排序，然后每次判断这条边连接的两点是否在同一个集合里，如果不是，那么合并这两个点，边数加1，当边数等于n-1时退出循环

在这道题中，只要用总边权减去最小生成树的总边权就行了

```cpp
#include<iostream>
#include<string.h>
#include<algorithm>
using namespace std;
int n,k;
struct node{
	int x,y;//两点
	int cd;//边权
}jsj[10007];
int sum,ans,zh;
bool cmp(node x,node y){
	return x.cd<y.cd;//按边权排序
}
int fa[107];
int fi(int x){
	if(fa[x]!=x)fa[x]=fi(fa[x]);//如果它的祖先不是自己，更改它的祖先（最后为最老的那个人）
	return fa[x];
}
void hb(int x,int y){
	fa[x]=y;//合并
	return;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	fa[i]=i;//每个人的祖先先保存为自己
	for(int i=1;i<=k;i++){
		int a,b,c;
		cin>>a>>b>>c;
		jsj[i].x=a;
		jsj[i].y=b;
		jsj[i].cd=c;
		zh+=c;//边权总和
	}
	sort(jsj+1,jsj+k+1,cmp);
	for(int i=1;i<=k;i++){
		int a=jsj[i].x;
		int b=jsj[i].y;//为下面写代码方便
		if(fi(a)!=fi(b)){//不在同一个集合里
			hb(fi(a),fi(b));//合并
			sum++;//边数加1
			ans+=jsj[i].cd;//最小生成树的边权加上当前边的边权
		}
		if(sum==n-1)break;//生成完毕
	}
	cout<<zh-ans<<endl;//总边权减去最小生成树的边权和
	return 0;
}
```

写得已经很详细了，即使没有学过也应该懂了

~~不点个赞吗？~~


---

## 作者：Azuree (赞：0)

[查看题目戳这里](https://www.luogu.org/problemnew/show/P2820)  
## 一道最小生成树的裸题，这里我们用kruskal来做
### kruskal 是一种求最小生成树的算法，时间复杂度为O(nlogn)
#### 它的算法思路是这样的：  
我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。  
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

int n,m,q[6000];

struct lalala{
	int x,y,z,save;
}a[210000];

int mysort(lalala a,lalala b)
{
	return a.z < b.z;
}

int work(int x,int y)
{
	while(q[q[x]] != q[x]) q[x] = q[q[x]];
	while(q[q[y]] != q[y]) q[y] = q[q[y]];
	if(q[x] == q[y]) return 1;
	else
	{
		q[q[y]] = q[x];
		return 0;
	}
}

int main()
{
	long long ans = 0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) q[i]=i;
	for(int i=1; i<=m; i++) 
	{
		cin>>a[i].x>>a[i].y>>a[i].z;
		ans += a[i].z;
	}
	sort(a+1,a+m+1,mysort);
	for(int i=1;i<=m;i++)
	{
		if(!work(a[i].x,a[i].y)) ans -= a[i].z;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：AmadeusSG (赞：0)

[博客食用](hackblogs.home.blog)

容易观察，这道题就是一道MST，我使用了Prim求最小生成树。

Pirm的流程为：

```
1.选取一个点为根节点并开始遍历。
2.找到跟这个根节点有边且边权最小的边。入队。
3.利用这个点更新其他的dis值
```
Prim算法求最小生成树的时候和边数无关，和顶点树有关，所以适合求解稠密网的最小生成树。

Prim算法的步骤包括：

1. 将一个图分为两部分，一部分归为点集U，一部分归为点集V，U的初始集合为{V1}，V的初始集合为{ALL-V1}。

2. 针对U开始找U中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到U中，并且从V中删除（注意不能形成环）。

3. 递归执行步骤2，直到V中的集合为空。

4. U中所有节点构成的树就是最小生成树。

![](https://i.loli.net/2019/07/29/5d3e4383bea1d31198.png)

Prim裸题
```
#include<bits/stdc++.h>
using namespace std;
const int INF=0x7fffffff/2,maxn=1000000;
int n,m,ans,minn;
int sum;
//---邻接矩阵 
int ljjz[2005][2005],d[10000005]/*边长*/,prt[10005]/*父亲*/,vis[10000005];
int dis[10000005];
//---
struct EDGE{int next,to,v;}e[100005];
int cnt,h[100005];
void add(int x,int y)//前向星 
{
	e[++cnt].to=y;
	e[cnt].next=h[x];
	h[x]=cnt;
	//for(i=h[x];i;i=e[i].next){y=w[i].to......}遍历x指向的点y1，y2.... 
}
void add2(int x,int y,int z)//前向星 
{
	e[++cnt].to=y;
	e[cnt].next=h[x];
	e[cnt].v=z;
	h[x]=cnt;
	//for(i=h[x];i;i=e[i].next){y=w[i].to......}遍历x指向的点y1，y2.... 
}
//----------->
//乱入一个最小生成树(贪心思想)
void Prim_ljjz(int v0)//适用于点少的图 
{
	int i,j,Min=0;
	for(i=1;i<=n;i++)dis[i]=INF;
	dis[v0]=0;//初始
	for(i=1;i<=n;i++)//选择n个点
	{
		minn=INF;
		for(j=1;j<=n;j++)//选择距离最小点
		if(minn>dis[j]&&vis[j]==0)
		{
			minn=dis[j];
			Min=j;
		}
		vis[Min]=1; 
		ans+=dis[Min];	
		for(j=1;j<=n;j++)//修改dis数组 
		if(vis[j]==0&&ljjz[Min][j]<dis[j]&&ljjz[Min][j]!=0)dis[j]=ljjz[Min][j];
	}
}
//---------->
int main()
{
	int i,j;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x,y);//前向星存储
		add2(x,y,z);//前向星存储
		ljjz[x][y]=ljjz[y][x]=z;//邻接矩阵存储 
		sum+=z;
	}
	Prim_ljjz(1);
	cout<<sum-ans;
	return 0;
}
```

---

## 作者：龘龘龘龘龘龘 (赞：0)

本人是蒟蒻，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，

老题目，与kruskal的模板很相似，很简单的一题，几乎一模一样，和最短网络，解法几乎一致，只要改几个点就行了，很简单的一题，连本蒟蒻都做出来了，嘿嘿，以下是鄙人代码，仅供参考，不要抄袭哦，上一次交题解没过呜呜呜说明过少，这次特地写这么多，大家可以仔细看看哦


代码如下，


```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iomanip>
#include<iostream>//虽然写这么多没什么用但是熟悉熟悉头文件呗不想写可以用<bits/stdc++.h>,万能的头文件 
using namespace std;
int a[10001][3],fa[101];//要输入三个数嘛，就这样设呗，也可以用三个一维的，或者定三个变量 
int x,tot,k=0;//k为我设的计数器 
int myfind(int poi);
void mysort(int l,int r);//手写的快排哦，可以直接用sort，再打一个函数void cmp（）{return a<b;},就可以排序了//kruskal一定要排序啦，别忘记了
int main()
{ 
    int i,j,n,m,ta,tb,mitot=0,matot=0;
    cin>>n>>m;//输入 //有加快的方法   ios::sync_with_stdio(false);大致速度与scanf和printf的速度差不多
    for(i=1;i<=m;i++) 
    {
       cin>>a[i][1]>>a[i][2]>>a[i][0];//输入
       matot+=a[i][0];//所有权值之和 
    }
    for(i=1;i<=n;i++)fa[i]=i;//初始化 
    mysort(1,m);//手写快排 
    k=0;//从0开始记数呗 
    for(i=1;k!=n-1;i++)//kruskal算法开始了，就不详解了 
    {
        ta=myfind(a[i][1]);
        tb=myfind(a[i][2]);
        if(ta!=tb)//并查集的使用，应该都懂吧 
        {
            fa[tb]=ta;
            k++;//计数 
            mitot+=a[i][0];//生成树的权值之和 
        }
    }
    cout<<matot-mitot<<endl; 
    return 0;
}
int myfind(int poi)//并查集 
{
    if(fa[poi]!=poi)fa[poi]=myfind(fa[poi]);//路径压缩，优化的核心，当然各位也可以用非递归的方法做，不过慢一点，复杂度大一点
    return fa[poi];
}
void mysort(int l,int r)//手写快排，
{
    int i,j,t,m;
    i=l;j=r;
    m=a[(l+r)/2][0];//类似分治，将序列从中间分隔 
    do
    {
        while(a[i][0]<m)i++;//这个地方就不用讲了吧，左边寻比中间大的数右边则寻小数 
        while(a[j][0]>m)j--;//右边则寻小数
        if (i<=j)
```
{//若找到目标不一致的就交换

```cpp
            t=a[i][1];a[i][1]=a[j][1];a[j][1]=t;
            t=a[i][2];a[i][2]=a[j][2];a[j][2]=t;
            t=a[i][0];a[i][0]=a[j][0];a[j][0]=t;
            i++;j--;//继续找 
        }
    }
    while(i<=j);//一定要到等于，不要忘记了有的时候会搞极品数据不写等于会吃亏的哦
    if(i<r)mysort(i,r);
    if(l<j)mysort(l,j);//递归搜索 
    return;
}//没了，各位同学们，noip加油哦，争取都拿奖，fighting，
```

---

## 作者：仇哥 (赞：0)

裸的最小生成树，一道经典的入门题

直接把最小生成树的权值算出来，然后整个图边的权值之和-最小生成树权值之和=答案。

我用的是prim算法的堆优化

关于建图方面，我不习惯用指针的邻接表，从来都用的是数组下标**（但是听说指针的常数要快一些？）**。所以我的堆里面存的是边的下标，下标来下标去的有点别扭，差点还搞错了……

不过对于这道题，n <= 100的数据也太弱了点吧……好像不用堆优化随随便便一个邻接矩阵的prim就可以0msAC啊！

但是我们既然有这么好的一个裸题，那么多练练手还是没有坏处的！

代码如下:

```cpp
#include <stdio.h>
#define INF 987654321
#define MAXM 400
struct edge {
    int s, e, v; 
    int next; 
}E[2*MAXM*MAXM]; 
int G[MAXM]; 
int cnt; 
inline void insert(int s, int e, int v) {
    E[++cnt].s = s, E[cnt].e = e, E[cnt].v = v, E[cnt].next = G[s], G[s] = cnt; 
}
struct heap {
    #define SWAP(x, y) (x ^= y, y ^= x, x ^= y)
    #define MAXN MAXM
    int data[MAXN], cnt; //注：此处的data[]代表的是E[]的下标 
    void push(int p) {
        data[++cnt] = p; 
        int i = cnt; 
        while(i && E[data[i]].v < E[data[i>>1]].v) {
            SWAP(data[i], data[i>>1]); 
            i = i>>1; 
        }
    }
    int pop() {
        int p = data[1], i = 1, j; 
        data[1] = data[cnt--]; 
        while(i<<1 <= cnt) {
            if(i<<1 == cnt || E[data[i<<1]].v < E[data[(i<<1)|1]].v) j = i<<1; 
            else j = (i<<1)|1; 
            if(E[data[i]].v > E[data[j]].v) {
                SWAP(data[i], data[j]); 
                i = j; 
            }
            else break; 
        }
        return p; 
    }
    void build() {
        cnt = 0; 
    }
```
#undef MAXN
#undef SWAP

```cpp
}; 
int N, ans; 
void prim() {
    heap H; 
    H.build(); 
    int p, n, i, j, A[MAXM] = {0, 1, 0}; 
    for(i = G[1]; i != 0; i = E[i].next)
        H.push(i); 
    for(j = 2; j <= N; j++) {
        for(p = H.pop(); A[E[p].e] == 1; p = H.pop()); 
        ans += E[p].v; 
        n = E[p].e; 
        A[n] = 1; 
        for(i = G[n]; i != 0; i = E[i].next) 
            if(A[E[i].e] == 0) 
                H.push(i); 
    }
}
int main() {
    int s, e, v, i, j, S, tot = 0; 
    scanf("%d%d", &N, &S); 
    for(i = 1; i <= S; i++) {
        scanf("%d%d%d", &s, &e, &v); 
        tot += v; 
        insert(s, e, v); 
        insert(e, s, v); 
    }
    prim(); 
    printf("%d", tot-ans); 
}

```

---

## 作者：ars4me (赞：0)

这个题我用的克鲁斯卡尔加前向星存储 当然并查集必须得会

因为边权越小越通畅 所以我们要尽量的去掉大的边

因此我们可以在找出最小生成树之后**用图的总边权减去最小生成树的总边权**

设z是我们输入的每一条边的边权

用一个len+=z得出图的总边权

然后用一个ans+=每次选出来的 加入最小生成树的边的边权

当循环到n-1次的时候 由树的性质可知 我们已经选完了最小生成树

然后跳出循环 输出**len-ans**即可

其他注释都在代码中

代码如下











```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define size 100001
struct point{
    int x;
    int y;
    int z;
};
point a[size];
int father[size];
int n,m;
int total,ans,num,len;
inline void output()
{
    cout<<len-ans<<endl;
}
inline void add(int from,int to,int dis)            //前向星存储
{
    a[++num].x=from;
    a[num].y=to;
    a[num].z=dis;
}
inline int find(int x)     //路径压缩找根
{
    if(father[x]!=x){
        father[x]=find(father[x]);
    }
    return father[x];
}
inline void unionn(int x,int y)       //并集
{
    int xx=find(x);
    int yy=find(y);
    father[yy]=xx;
}
bool cmp(point a,point b)      //自定义sort 按照边权长度排序 寻找最小生成树
{
    return a.z<b.z;
}
inline void work()
{
    sort(a+1,a+num+1,cmp);
    for(int i=1;i<=num;i++){
        int xx=a[i].x;
        int yy=a[i].y;
        if(find(xx)!=find(yy)){        //已经排好序后 将两个单独的集合合并
            unionn(xx,yy);
            total++;        //记录连了几条边了
            ans+=a[i].z;
            if(total==n-1){
                break;
            }
        }
    }
}
inline void input()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){       //初始化father数组 让每一个点都先自己成为一个单独的集合
        father[i]=i;
    }
    int x,y,z;
    for(int i=1;i<=m;i++){
        cin>>x>>y>>z;
        add(x,y,z);
        add(y,x,z);         //双向 正反存两次
        len+=z;
    }
}
int main()
{
    input();
    work();
    output();
}
```
裸的最小生成树 稍微改一些地方就好了

//COYG

---

## 作者：Hydroxyl (赞：0)

解决回路就是把多余的网线拔掉 反正只要是联通的没有节点少掉


这道题就是非常经典的一prim算法

直接找最小生成树就好了 然后再算一下费用

注意！其中值越小越畅通（电阻一样的玩意） 只要让所有都连进去就可以了

当然也可以用Kruskal（我还没学这玩意 听说是并查集）


算法描述

1).输入：一个加权连通图，其中顶点集合为V，边集合为E；

2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；

3).重复下列操作，直到Vnew = V：

a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；

b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；

4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。


————————————————华丽丽的分割线————————————————————


var g:array[1..101,1..101] of longint; 图的那玩意 g[i,j]记录第i个节点到第j个节点的权值



```cpp
    b:array[1..101] of boolean;   是否访问
    d:array[0..1000] of longint;
    i,j,k,m,n,total,min,max,sum:longint;      一大堆的数组自己想
begin
    readln(n,k);
    for total:=1 to k do
    begin
      readln(i,j,m);
      g[i,j]:=m; g[j,i]:=m;   千万不要忘了j到i也是这个距离 我原本忘记这玩意然后听取WA声一片（学校的CENA）
      inc(max,m);    总的值
    end;
    total:=0;
    filldword(d,sizeof(d)>>2,maxlongint>>1);    maxlongint div 2比较保险爆了就尴尬你说对吧 关于filldword的解释下面贴出
    fillchar(b,sizeof(b),true);
    d[1]:=0;
    for i:=1 to n do
    begin
      min:=maxlongint;  就这样不多说
      for j:=1 to n do
      if b[j] and (d[j]<min) then 没访问过且比当前要小那么就换
      begin
        min:=d[j];
    k:=j;
      end;
      b[k]:=false;  已访问
      inc(sum,max);   加一下延年益寿
      for j:=1 to n do
       if b[j] and (g[k,j]<d[j]) and (g[k,j]<>0) then d[j]:=g[k,j];     如果这边g[k,j]<>0那么会崩的因为原本就是0 啊
   end;
   writeln(max-sum);   
end.
```
——————————————————PS：有bug要自己改（1处）————————————————————
——————————————————华丽丽的分割线——————————————————————————

filldword：

fillword(a , b ,c );

以地址a开始,word的长度(2个字节)为步长 的 连续b个内存块进行赋值c.

虽然a可以是任何的变量地址,但是一般都是用在数组上.

最常用的方式,就是填充一个integer的数组

比如对于

a:array[1..100]of integer;

可以
fillchar(a,100,1234);

等效于

for i:=1 to 100 do a[i]:=1234;

当然这里的1234只是一个例子而已可以是任何数字.

而数组也未必是integer类型的,对于longint一样可以,不过对longint赋值的话,由于把两个(4长度)的integer来填充一个longint,所以数字会出错,不再是c了.

乱七八糟的代码

——————————————————当初写的时候把例题模改一番——————————————————————


---

## 作者：21336dxq (赞：0)

最小生成树\_水题\_

先用弄一遍最小生成树，再用本来的总长度来减去最小生成树的长度\_

只要把那道【模板】最小生成树改一改就好了




```cpp
var
a:array[0..5000,0..5000] of longint;
b:array[0..5000] of boolean;
f:array[0..5000] of longint;
x,y,z,n,m,i,j,k,min,max,ans,num:longint;
begin
fillchar(a,sizeof(a),127);
fillchar(f,sizeof(f),127);
read(n,m);
for i:=1 to m do
begin
read(x,y,z);
min:=min+z;//记录原来的总长度
if a[x,y]>z then
begin
a[x,y]:=z;
a[y,x]:=a[x,y]
end;
end;
f[1]:=0;
```
{}最小生成树}



```cpp
while true do
begin
max:=maxlongint div 3;
for i:=1 to n do
if (f[i]<max) and (b[i]=false) then
begin
max:=f[i];
num:=i;
end;
if max=maxlongint div 3 then break;
b[num]:=true;
k:=k+max;
for i:=1 to n do
if (f[i]>a[num,i]) and (b[i]=false) then
f[i]:=a[num,i];
end;
write(min-k);
end.
```

---

## 作者：Kwork (赞：0)

我要哭了，交了3遍都没发现k写成n了。

如果正面~~肛~~写这道题，有点难下手，那么就倒着想，把所有局域网内的电脑连通就是求最小生成树啊，然后其他所有没用的边之和就是ans啊。此题end。下面是克鲁斯卡尔算法。






```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
using namespace std;
typedef long long ll;
const int maxn=200;
struct edge{int u;int v;int w;};
edge es[10000];
int n,k,p[maxn];
int ans=0;
void read(int &n){
    n=0;int f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    n=n*f;
    return;
}
void write(int n){
    if(n<0){
        putchar('-');
        n=0-n;
    }
    if(n>=10) write(n/10);
    putchar((n % 10)+'0');
    return;
}
int find(int x){
    return x==p[x] ? x:p[x]=find(p[x]);
}
bool cmp(const edge &x,const edge &y){
    return x.w<y.w;
}
int main(){
    read(n);read(k);
    for(int i=1;i<=n;i++) p[i]=i;
    for(int i=1;i<=k;i++){
        int u,v,w;
        if(w==0) continue;
        read(u);read(v);read(w);
        es[i].u=u;es[i].v=v;es[i].w=w;
        ans+=w;
    }
    sort(es+1,es+k+1,cmp);
    for(int i=1;i<=k;i++){
        int x=find(es[i].u);
        int y=find(es[i].v);
        if(x!=y){
            ans-=es[i].w;
            p[x]=y;
        }
    }    
    write(ans);
    return 0;
}
```

---

## 作者：梦游的小雪球 (赞：0)

## 题目思路：
- 将**所有线路**按**最小生成树**方法找出连接的**最优方法。**（流畅值即为路程）
- 记录所有线路的流畅值总和与最优线路的流畅值总和，**两者之差即为所求。**
## AC代码：
**<请认真阅读每一个注释。>**
```
#include<bits/stdc++.h>
using namespace std;
int n,m,f[5010],s,sum;
int zqq(int k){
	if(f[k]==k)return k;
	return f[k]=zqq(f[k]);//并查集基本代码。
}
struct jd{
	int a,b,c;//两台计算机编号，流畅值。
}jdd[200001];//每条线路。
bool qwq(jd x,jd y){
	return x.c<y.c;//线路按流畅值从小到大排序。
}
int main(){
	cin>>n>>m;//计算机总量和线路总量。
	for(int i=0;i<n;i++)
		f[i]=i;//并查集基本代码。
	for(int i=0;i<m;i++){
		cin>>jdd[i].a>>jdd[i].b>>jdd[i].c;//具体含义请看结构体定义。
		sum=sum+jdd[i].c;//即所有线路流畅值总和。
	}
	sort(jdd,jdd+m,qwq);//按流畅值从小到大排序。
	for(int i=0;i<m;i++)
		if(zqq(jdd[i].a)!=zqq(jdd[i].b)){
			f[zqq(jdd[i].a)]=zqq(jdd[i].b);//最小生成树基本代码。
			s=s+jdd[i].c;//计算最优线路流畅值。
		}
	cout<<sum-s;//输出所有线路流畅值与最优线路流畅值的差。
    return 0;//完美结束。
}
```
### 求管理通过QWQ。

---

## 作者：agicy (赞：0)

# 思路

1. 题目要求不能在图中形成环，所以去除网线最后的结果应该是形成了**一棵树**；

2. 题目的答案是去除网线的最大值，即去除边权的最大值，所以保留的网线形成的应该是一个**最小生成树**。

所以，我们采用**$Kruskal$+并查集**的方法生成最小生成树，并用一个$bool$数组标记已经使用的边，最后再统计未使用的边权之和。

# 代码

```cpp
#include<stdio.h>
#include<algorithm>
//以上是头文件

struct Node{
	int f,t,w;//f,t为网线两个节点的编号，w为权值
	bool operator<(Node a)const{
		return this->w<a.w;
	}//重载运算符，按w从小到大排序
};

bool f[200001];//用于标记的bool数组
int n,k,ID[101];//ID[]为并查集的father数组
long long ans;//结果，边权之和
Node r[200001];//边

void contact(int,int);//并查集的合并操作
bool search(int,int);//返回两个节点是否在同一集合
int find(int);

int main(void){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		ID[i]=i;
	for(int i=1;i<=k;i++)
		scanf("%d%d%d",&r[i].f,&r[i].t,&r[i].w);//读入
	std::sort(r+1,r+k+1);//排序
	for(int i=1,c=1;i<=k&&c<=n-1;i++)//c用于记录连边的数量，只需连接(n-1)条边
		if(!search(r[i].f,r[i].t))//如果两个节点不在用一个集合
			contact(r[i].f,r[i].t),//连接
			c++,//统计
			f[i]=true;//标记已选
	for(int i=1;i<=k;i++)//统计边权之和
		if(!f[i])
			ans+=r[i].w;
	printf("%lld",ans);//输出
	return 0;
}
/*
以下三个函数为并查集的操作
*/

void contact(int a,int b){
	int ra=find(a),rb=find(b);
	if(ra!=rb)
		ID[rb]=ra;
	return;
}

bool search(int a,int b){
	return find(a)==find(b);
}

int find(int x){
	if(ID[x]==x)
		return x;
	else
		return ID[x]=find(ID[x]);
}
```

---

## 作者：emiyashilo (赞：0)

****本人蒟蒻，第一次提交题解啊，如果有写的不好的大家见谅******

//这道题问减掉网线的最大值，这相当于留下最短的路（但保证图连通，即最小生成树），然后用路线总长-最小生成树所有的边长

```cpp
//差即为答案。
#include<bits/stdc++.h>//万能文件库，c++就是方便啊:~)
using namespace std;
struct node{
    int from;//起点
    int to;//到达的点
    int w;//边的权值
}a[205];
int n,m,fa[205],k,sum,ans,tot;//sum是路的总长，ans是最终答案，tot是最小生成树的总长（都是英语简写，应该比较好看吧...）
int find(int x){
    if(fa[x]!=x)fa[x]=find(fa[x]);
    return fa[x];//正常的并查集函数，递归调用会比较快
}
bool cmp(node b,node c){//c++库函数——sort，它需要一个判定的标准
    return b.w<c.w;
}
int main()
{
    cin>>n>>m;//虽然题里是k，但我还是习惯用m表示边数
    sum=0;tot=0;ans=0;//数据初始化
    for(int i=1;i<=m;i++){
        cin>>a[i].from>>a[i].to>>a[i].w;
        sum+=a[i].w;//这里可以直接计算出路径总长
    }
    for(int i=1;i<=n;i++){
        fa[i]=i;
```
}//并查集8（fu）节点初始化
```cpp
    sort(a+1,a+m+1,cmp);//这里用到这个函数
    k=0;
    for(int i=1;i<=m;i++){
        int x=find(a[i].from),y=find(a[i].to);//先把两个点的fu节点拿出来，方便用（其实这里应该没必要再解释了）
        if(x!=y){
            fa[y]=x;
            tot+=a[i].w;k++;
        }
    }
    ans=sum-tot;//结果
    cout<<ans;
}//最后再提醒一下大家，这个边数的范围是1~200，数组不要开小了
```

---

## 作者：UchihaItachi (赞：0)

这道题就是用总长度减去最小生成树的长度，用prim算法就好了

代码如下

```cpp
#include<iostream>
using namespace std;
int main(){
    int n,m,minn,i,j,k,t1,t2,t3,add=0;//add记录原本的总长度 
    int e[1000][1000],dis[1000],book[1000]={0};
    int inf=99999999;
    int count=0,sum=0;//count用来记录顶点个数，sum用来储存最小生成树之和 
    cin>>n>>m;
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            if(i==j)
             e[i][j]=0;
             else e[i][j]=inf;
             
         }
    }

    for(i=1;i<=m;i++){
        cin>>t1>>t2>>t3;
        //注意是无向图，互联网是相通的。 
        e[t1][t2]=t3;
        e[t2][t1]=t3;
        add+=t3;//这里记录长度 
    }
    for(i=1;i<=n;i++)
    dis[i]=e[1][i];//初始化dis数组，这里是1号顶点到各个顶点的初始距离。 
    
    //prim算法开始 
    
    book[1]=1;//用book标记一个顶点是否已经加入生成树； 
    count++;
    while(count<n){
        minn=inf;
        for(i=1;i<=n;i++){
            if(book[i]==0&&dis[i]<minn)
            {
                minn=dis[i];
                j=i;
            }
        }
        book[j]=1;
        count++;
        sum+=dis[j];
        //扫描当前顶点j所有的边，再以j为中间点，更新生成树到每一个非树顶点的距离 
        for(k=1;k<=n;k++){
            if(book[k]==0&&dis[k]>e[j][k])
            dis[k]=e[j][k];
        }
    }
    cout<<add-sum;
    return 0;
}
/*
5 5
1 2 8
1 3 1
1 5 3
2 4 5
3 4 2
*/
```

---


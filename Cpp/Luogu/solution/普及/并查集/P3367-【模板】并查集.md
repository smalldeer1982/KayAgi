# 【模板】并查集

## 题目背景

自 2025 年 1 月 21 日，本题测试数据范围更新，详见：<https://www.luogu.com.cn/discuss/1045596>

这意味着现存题解的代码可能无法通过本题，管理组将会在 2025 年 2 月处理。

## 题目描述

如题，现在有一个并查集，你需要完成合并和查询操作。


## 说明/提示

对于 $15\%$ 的数据，$N \le 10$，$M \le 20$。

对于 $35\%$ 的数据，$N \le 100$，$M \le 10^3$。

对于 $50\%$ 的数据，$1\le N \le 10^4$，$1\le M \le 2\times 10^5$。

对于 $100\%$ 的数据，$1\le N\le 2\times 10^5$，$1\le M\le 10^6$，$1 \le X_i, Y_i \le N$，$Z_i \in \{ 1, 2 \}$。

## 样例 #1

### 输入

```
4 7
2 1 2
1 1 2
2 1 2
1 3 4
2 1 4
1 2 3
2 1 4```

### 输出

```
N
Y
N
Y
```

# 题解

## 作者：huangzirui (赞：916)

update:2020.2.13

------------

> 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受;即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间(1~3秒)内计算出试题需要的结果，只能用并查集来描述。
([摘自百度](https://baike.so.com/doc/6119935-6333082.html))


------------

关于并查集和路径压缩：

现在我们假定 ``f[i]`` 表示第 i 个人的老大是谁。

现在我们有甲，乙，丙三个人（分别用 a, b, c 表示）

假设甲和乙打架了，甲做了丙的小弟。则有 ``f[a]=b``，

后来甲打赢了丙

那么丙就是甲的小弟了。有 ``f[c]=a``，

但是如果我们这样表示，丙不能直接知道甲，~~容易自己人打自己人~~

所以，我们必须直接让丙的大哥变成最大的老大。

定义函数 ``find``

```cpp
int find(int k){
    if(f[k]==k)return k;
    return find(f[k]);
}//find 函数可以直接找到最大的老大

f[c]=find(a);
//丙的老大是甲

```

这时，因为我们要路过他所有的上级，我们也可以顺便使途中经过的人的大哥也变成老大。

```cpp
//路径压缩
int find(int k){
    if(f[k]==k)return k;
    return f[k]=find(f[k]);
    /* 
    	即：
    	f[k]=find(f[k]);
        return f[k];
    */
}

f[c]=find(a);

```

简直是太巧妙了！

而判定两个人的老大是否相等，只需
```cpp
if(find(a)==find(b))
```
就好了。

一些设定：

- 一个人不能有两个老大。
- 当已经有老大的人臣服时，老大也将成为胜利的人的小弟。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,k,n,m,s,ans,f[10010],p1,p2,p3;
//f[i]表示i的集合名
int find(int k){
	//路径压缩
    if(f[k]==k)return k;
    return f[k]=find(f[k]);
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
        f[i]=i;//初始化i的老大为自己
    for(i=1;i<=m;i++){
        cin>>p1>>p2>>p3;
        if(p1==1)
            f[find(p2)]=find(p3);
            //p3打赢了p2
        else
            if(find(p2)==find(p3))
            //是否是一伙的
                printf("Y\n");
            else
                printf("N\n");
    }
    return 0;
}
```

---

## 作者：Nemlit (赞：202)

看到题解大部分都是用‘递归+路径压缩’做的，所以本蒟蒻就来发一篇‘循环+路径压缩版并查集’的题解。速度比递归版本更加优秀~~（其实循环代码还要好写一些）~~。

并查集的操作有三步，初始化查找祖先与合并。

既然并查集是来查找祖先的，那么初始化就必然是让每个点的祖先指向自己
```
for(int i=1;i<=n;++i) fa[i]=i;
```
查找操作就是不断地向上走，直到找到祖先为止
```
while(x!=fa[x]) x=fa[x];
```
合并操作就是把一个节点的祖先变为另一个节点的祖先。
```
fa[find(a)]=find(b);//其中find(x)为x的祖先
```
并查集的单次查询理想复杂度应该是O(logn)的，但是如果有一个这样的数据，并查集的复杂度就是O(n)了
![](https://cdn.luogu.com.cn/upload/pic/38270.png)

为了避免这种情况，我们需对路径进行压缩。

即当我们经过找到祖先节点后，回溯的时候顺便将它的子孙节点都直接指向祖先，使以后的查找复杂度变回O(logn)甚至更低，让图变成这样：
![](https://cdn.luogu.com.cn/upload/pic/38276.png)

听上去十分高端，实际上只要把刚刚的查询操作变成如下就可以了
```
while(x!=fa[x]) x=fa[x]=fa[fa[x]];
```
并查集有两个操作，既然查找可以优化，那合并可不可以呢？

我们可以进行按秩合并，即：合并的时候将元素少的集合合并到元素多的集合中，这样树高会小很多

附上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,z,x,y,fa[10005];//fa[i]是第i号节点的祖先
inline int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    //让x和x的父亲变成他的父亲的父亲
    //直到找到祖先才结束循环(x==fa[x])就意味着找到爹了
    return x;
}
//循环版找爹函数
/*
//再附上递归版本的找爹函数
inline int find(int x) 
{
    if (x==fa[x]) return x;
    //不停的递归查找
    return fa[x]=find(fa[x]);
    //路径压缩，可以缩短时间
}
*/
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) 
    {
    	fa[i]=i;
        //并查集的初始化
    }
    while(m--)
    {
        cin>>z>>x>>y;
        int a=find(x),b=find(y);
        //ab分别去找自己的爹
        if(z==1)
        {
        	fa[a]=b;
            //并查集的合并操作，及将x点祖先的爹记为y点的祖先
        }
        if(z==2)
        {
            if(a==b) 
            {
            	puts("Y");
                //爹一样就说明X与Y是在同一集合内，输出Y
            }
            else 
            {
            	puts("N");
                //否则就说明X与Y是在同一集合内，输出N
            }
        } 
    }
    return 0;
}
```
[附上蒟蒻的博客](https://tbr-blog.blog.luogu.org/)

---

## 作者：lolte (赞：83)

# 蒟蒻的第一篇题解

嗯呐嗯呐，第一篇题解不知道怎么写呢。。。~~其实就是来水时间的~~  嗯嗯，先从概念说起吧：并查集通过一个**一维数组**来实现，本质上是维护一个森林。刚开始的时候，森林里的每一个结点都是**一个集合**（也就是**只有一个结点的树**），之后根据题意，逐渐将一个个集合**合并**（也就是**合并成一棵大树**）。之后寻找时不断查找**父节点**，当查找到父结点为本身的结点时，这个结点就是**祖宗结点**。合并则是寻找这两个结点的祖宗结点，如果这两个结点**不相同**，则将其中右边的集合作为左边集合的**子集**（即靠左，靠右也是同一原理）。

## 附上AC代码：

```cpp
    #include<bits/stdc++.h>//并查集 
    using namespace std;
    int a1,a2,a3,f[200001],n,m;
    int getf(int o) {//不停找爹，直到找到祖宗为止 
        if (f[o]==o) return o;
        else return f[o]=getf(f[o]);//这里是路径压缩，把递归过程中遇到的
                                    //结点的祖宗结点也直接修改了。
    }
    void merge(int v,int u) {//合并子集 
        int t1,t2;//t1,t2分别为v和u的祖宗
        t1=getf(v);//获取祖宗结点值
        t2=getf(u);
        if (t1!=t2) f[t2]=t1;//靠左。即将右边的集合，作为左边的子集
        return; 
    }
    void find(int v,int u) {
        int t1,t2;//同上
        t1=getf(v);
        t2=getf(u);
        if (t1==t2) printf("Y\n");
        else printf("N\n");
    }
    int main(){
        scanf("%d %d",&n,&m);
        for (int i=1;i<=n;i++) f[i]=i;//初始化集合
        for (int i=1;i<=m;i++) {
            scanf("%d %d %d",&a1,&a2,&a3);
            if (a1==1) merge(a2,a3);
            else find(a2,a3);
        }
    }
**最后祝大家每题都能顺利AC！**
```

---

## 作者：应吟吟 (赞：48)

#### 前言
这道题是一道对初学者有点不太友好的题目，因为一开始可能有点难理解~~（理解之后可能还好）~~，可是这道题又是一道初学者必须码的一道题~~（比如说我这种蒟蒻）~~

**************************************

#### 题意
我们先理解一下题意，题目提供了两个正整数$n$，$m$,表示有$n$个元素，$m$次询问。接着他给了你$m$行询问，一行询问有$z$,$x$,$y$三个数。当$z$=1时，将$x$与$y$所在的集合合并;当$z$=2时，输出$x$与$y$是否在同一集合内，是的话输出$Y$；否则话输出$N$。

**************************************

#### 核心模板

1. 找爸爸

	$f[x]$是指$x$的爸爸（P.S. 一开始每个元素的爸爸就是它自己）
```cpp
	int find(int x)
    {
    	if(f[x]==x)//如果一个元素的爸爸就是它自己
    	{
    		return x;//就直接返回它自身
    	}
    	else
    	{
    		f[x]=find(f[x]);//否则就接下去寻找，直到找到他的爸爸为止
    	}
    	return f[x];//返回它的爸爸的值
    }
```

2. 合并（就是当z=1时）
```cpp
 void work1(int x,int y)
    {
    	f[find(y)]=find(x);
    }
```
	合并的本质就是使$x$和$y$的爸爸变成同一个爸爸~~（逃~~
    $find(x)$是找到$x$的爸爸，$f[find(y)]$是找到$y$爸爸的爸爸（它的祖先？雾。。。）并使他们相等，也就是让$x$和$y$的集合合并。  
    原理见图：
    ![](https://cdn.luogu.com.cn/upload/pic/51673.png )
    从图中可以看出，合并之后$x$和$y$就成为了兄弟，也就是在同一个集合内了（集合合并）  
3. 查询（也就是当z=2的时候）

```cpp
void work2(int x,int y)//查询
    {
    	if(find(x)==find(y))//查询是否为同一个爸爸
    	{
    		cout<<"Y"<<endl;//是就输出“Y”
    	}
    	else
    	{
    		cout<<"N"<<endl;//不是就输出“N”
    	}
    }
```

如果$x$和$y$的爸爸是同一个的话，那么$x$和$y$就是兄弟，也就是说$x$和$y$在同一集合中，所以输出$Y$，不然就输出$N$。

********************************************
~~把以上模板拼接一下，就是~~AC代码~~啦~~

    #pragma GCC optimize(3)//O3优化不用管啦
    #include<bits/stdc++.h>
    using namespace std;
    int n,m,z[666666],x[666666],y[666666];
    int f[666666];
    int find(int x)//找爸爸 
    {
    	if(f[x]==x)
    	{
    		return x;
    	}
    	else
    	{
    		f[x]=find(f[x]);
    	}
    	return f[x];
    }
    void work1(int x,int y)//合并
    {
    	f[find(y)]=find(x);
    }
    void work2(int x,int y)//查询
    {
    	if(find(x)==find(y))
    	{
    		cout<<"Y"<<endl;
    	}
    	else
    	{
    		cout<<"N"<<endl;
    	}
    }
    int main()
    {
    //	freopen(".in","r",stdin);
    //	freopen(".out","w",stdout);
    	ios::sync_with_stdio(false);//关闭同步使cin，cout变快
    	cin>>n>>m;
    	for(int i=1;i<=m;i++)
    	{
    		cin>>z[i]>>x[i]>>y[i];
    		f[i]=i;
    	}
    	for(int i=1;i<=m;i++)
    	{
    		if(z[i]==1)
    		{
    			work1(x[i],y[i]);
    		}
    		else
    		{
    			work2(x[i],y[i]);
    		}
    	}
    	return 0;//完结撒花
    }
    



---

## 作者：加载错误 (赞：47)

###### 这道题是一道模板题~~，比较简单~~。
# 并查集
### 为了能让你们了解并查集，我举一个简单的例子
 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。

**本文来自[*飘过的小牛*](https://blog.csdn.net/niushuai666/article/details/6662911?utm_source=copy)的$CSDN$博客**

-------------


## 初始化

在江湖上，有非常多的英雄，我们不妨用一个$f$数组来保存每位英雄的掌门。

```cpp
const int X = 10010;
int f[X];
```

在帮派中，有掌门和弟子，那么刚刚开始肯定都是一个人行走江湖，所以在程序初始化的时候，每个人的掌门都是他们自己。
```cpp
void init(){
	for(int i = 0;i <= X - 1;i++){
		f[i] = i;
	}
}

```

## 查找根节点

我们在判断两位英雄是否师出同门的时候，要用到查找掌门的函数。

这里我们用了记忆化，俗称“压缩路径”。
```cpp
int find_f(int x){
	if(x != f[x]){
		return f[x] = find_f(f[x]);//在递归的时候，就直接将遇到的当前帮派的英雄的掌门修改了
	}
	return f[x];//如果找到了掌门，就直接返回掌门编号
}
```
## 合并子集

在确认两位英雄是属于同一个帮派的时候，要把两位英雄的帮派合并，既然师出同门，那两个帮派就是一样的了嘛。

```cpp
void join(int x,int y){
	int fx = find_f(x),
    	fy = find_f(y);//找到两位英雄的掌门
	if(fx != fy){
		f[fy] = fx;//合并子集
	}
}
```

## 主函数

接下来就是整个完整的程序。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int X = 10010;
int f[X];
int n,m;

void init(){
	for(int i = 0;i <= X - 1;i++){
		f[i] = i;
	}
}

int find_f(int x){
	if(x != f[x]){
		return f[x] = find_f(f[x]);
	}
	return f[x];
}

void join(int x,int y){
	int fx = find_f(x),fy = find_f(y);
	if(fx != fy){
		f[fy] = fx;
	}
}

int main(){
	init();
	cin>>n>>m;
	while(m--){
		int t,x,y;
		cin>>t>>x>>y;
		switch(t){
			case 1:
				join(x,y);
				break;
			case 2:
				find_f(x) == find_f(y)?cout<<"Y"<<endl:cout<<"N"<<endl;
                //请注意，这里判断是否为同一个帮派(集合)时要再次找掌门(根节点)
				break;
		}
	}
	return 0;
}
```

可能有些人不太理解这一行：
```cpp
find_f(x) == find_f(y)?cout<<"Y"<<endl:cout<<"N"<<endl;
```
这行相当于
```cpp
if(find_f(x) == find_f(y)){
	cout<<"Y"<<endl;
}
else{
	cout<<"N"<<endl;
}
```

---

## 作者：installb (赞：31)

updated 2019.11.30 填坑+补充

并查集是一种用于处理一些不相交的集合的**合并**与**查询**问题的**树形数据结构**  
能够将两个集合合并 或者查询某个元素处于哪个集合中  

<!--more-->
## 预处理
首先并查集维护的是一个有根树森林  
森林中每一棵树代表一个集合(相当于连通块)  
一棵树中所有点的祖先都是相同的 所以查询两个点是否在同一棵树中可以等价为查询它们的祖先是否相同  
我们要高效维护祖先信息  

先考虑朴素算法 首先我们对每一个点存下它父亲的值 祖先就是不断找父亲直到顶就可以了  
为了判断一个点是祖先节点并且方便处理 我们把祖先节点的父亲节点设置成自己  
于是父亲是自身的点都是祖先节点  

一开始每一个点都自己组成一个连通块(一棵树)  

记$f_i$为$i$的祖先  
```cpp
for(int i = 1;i <= n;i ++) f[i] = i;
```
## 合并与查询
可以视为是在 对两棵树的根连边 和 树上找祖先 的过程
### 查询
对于一个元素 不断找它的父亲节点 直到找到祖先节点为止 就可以了  
这个点就是该节点所在树的根 相当于所在集合的编号  
祖先节点的祖先是它本身  

如果两个元素的祖先节点相同 它们就在同一个集合中了  
```cpp
int find(int x){
	if(x == f[x]) return x;
	return find(f[x]);
}// 查询祖先 采用递归方式实现
char judge(int x,int y){
	if(find(x) == find(y)) return 'Y'; // 在同一个集合内
	return 'N';
}
```
### 合并
先找到待合并两个点的祖先  
将一个祖先的父亲设为另一个祖先就可以了  
注意这里被合并的祖先的子树中所有点的祖先信息都还没有更新为另一个祖先  
所以**每一个想调用一个元素的祖先信息时 一定要把它做一遍查询 更新它祖先的值 再去调用**  
```cpp
void union(int x,int y){
	x = find(x); // 找祖先
	y = find(y);
	f[x] = y; // f[y] = x 也行 并起来就可以了
}
```

不过这个算法显然可以被卡成单次查询$O(n)$的  
所以我们需要优化  
## 优化
虽然说是优化 但是前面的算法不优化复杂度太大了  
所以优化是**必须**的  
### 路径压缩(常用方法)
由于只需要祖先信息  
所以对于一个元素 它的祖先是它的父亲 还是它父亲的父亲 其实是不重要的  
所以我们可以在查询到一个点的祖先的时候 把**这个点到祖先路径上所有点的 父亲节点编号(即$f_i$) 直接改成祖先**  
由于上面的过程是递归实现的 路径上每一个点都可以在找到祖先后修改父亲节点  
相信还是看图更好理解  
![graph (5) edit one.png](https://i.loli.net/2019/09/14/FKeL97MO6YqPrkA.png)  
找祖先  
![graph (5) edit two.png](https://i.loli.net/2019/09/14/MZdNF1R7EvOkLCf.png)  
改父亲节点编号  
![graph (6).png](https://i.loli.net/2019/09/14/X7kzaCOpLMuYdym.png)  
代码也很简单 就加了五个字符  

```cpp
int find(int x){
	if(x == f[x]) return x;
	return f[x] = find(f[x]);
}
```
时间复杂度(m次询问):  
最坏$O(mlog\ n)$  
平均$O(m\alpha (n))$ 这个东西很小 可以当成常数了  

### 按秩合并(可支持撤销)
路径压缩相当于是破坏了点的父子关系 所以不能够撤销  
而按秩合并不会  
按秩合并就是每一次合并都是把**小的集合(含元素少)并到大的集合**里面去  
如果一开始所有集合都是只有一个元素的  
那么经过这样的合并后 从根节点往下走 每走一步子树大小至少减半  
这样可以保证查询复杂度  
![graph (7).png](https://i.loli.net/2019/09/14/6JQtPefOLMxmCI8.png)  
![graph (8).png](https://i.loli.net/2019/09/14/V8bfjU34H1zonsh.png)  

```cpp
// siz记录子树的大小 初始化为1
void unionSet(int x, int y) {
	x = find(x); y = find(y);
	if(x == y) return;
	if(siz[x] > siz[y]) swap(x,y);
	f[x] = y; siz[y] += siz[x];
}
```
撤销的时候把之前连上去的那条边删掉就行了(把对应那个点的祖先改成自己)  
树的结构没有改变 所以可行  
时间复杂度$O(mlog\ n)$

## 种类并查集(扩展域)
拿这题举例子了:[NOI2001 食物链](https://www.luogu.org/problem/P2024)  
这里同类关系可以简单的用并查集解决  
但是天敌和猎物的关系就不能处理  

所以对每一个生物$i$建立三个元素 分别代表$i$是生物$A,B$还是$C$  
记作$i-A,i-B,i-C$  
在合并的过程中 我们需要使得对于任意一个连通块 该连通块内所有元素要么**同时满足** 要么**同时都不满足**  
同一个集合内的元素可以互相推出

合并之前判断一下有没有矛盾  
如果$x,y$为为同类则合并$x-A,y-A;x-B,y-B;x-C,y-C$  

如果此时$x-A,y-B$ 或 $x-B,y-A$已在同一连通快内 代表$x$和$y$是天敌和猎物的关系 就不可能是同类了 于是产生矛盾  
其实只需要判断A,B即可 如果$x-A,y-B$在同一连通块内，$x-B,y-C$必定也在  

如果$x$吃$y$则合并$x-A,y-B;x-B,y-C;x-C,y-A$(因为A吃B B吃C C吃A)  
这时候如果发现之前$x,y$就是同类或者$y$吃$x$ 那么就矛盾了  

这里用$i,i+n,i+n+n$表示$i-A,i-B,i-C$  
```cpp
// 同类合并
if(find(x) == find(y + n) || find(y) == find(x + n)) ans ++;
else{
	f[find(x)] = find(y);
	f[find(x + n)] = find(y + n);
	f[find(x + n + n)] = find(y + n + n);
}
// x吃y
if(find(x) == find(y) || find(x + n) == find(y)) ans ++;
else{
	f[find(x)] = find(y + n);
	f[find(x + n)] = find(y + n + n);
	f[find(x + n + n)] = find(y);
}
```

## 带权并查集
其实就是给森林中的每一个点都赋值 保存下这个点的信息 以及 它到父亲节点的边的信息  
然后在合并的时候(路径压缩)改变这些值 查询的时候查询值 就行了  
拿这题举例:[NOI2002 银河英雄传说](https://www.luogu.org/problem/P1196)  

这里记$b_i$为$i$点所在连通块大小  
$s_i$为$i$点到这个点所在树的根的距离  
由于路径压缩的过程中树的结构发生了改变  
所以要随时更新这两个值  
```cpp
int find(LL x){
	if(x == F[x]) return x;
	int tmp = F[x];
	F[x] = find(F[x]);
	s[x] += s[tmp];
	b[x] = b[F[x]];
	return F[x];
}
// 预处理
for(int i = 1;i <= 30000;i ++){
	F[i] = i; b[i] = 1; s[i] = 0;
}
// 合并
fx = find(x); fy = find(y); F[fx] = fy;
s[fx] += b[fy];
b[fy] = b[fx] + b[fy]; b[fx] = b[fy];
// 查询
fx = find(x); fy = find(y);
if(fx != fy) cout << -1 << endl;
else cout << abs(s[x] - s[y]) - 1 << endl;
```
## 总结  
并查集作为一个能够维护 集合/连通块信息(大小/数量/...)/连通性 的高效数据结构 在实际题目中有用处很多 并且很容易实现 灵活性也不差  
总之就是如果想到某处用并查集比较合适就用吧  

~~虽然并查集能做的LCT都能做~~

---

## 作者：decoqwq (赞：30)

$LCT$裸题

QAQ居然在题解前三页都没看见$dalao$写$LCT$题解，蒟蒻的我就来发一个

首先，既然要支持集合合并，查询连通性，我们不妨将一个集合想成一个联通块，集合合并就是连接两点的集合$(link)$

然后我们在查询的时候，如果两个点$findroot$是一样的，证明他们在同一棵$LCT$里，就似乎$Y$，否则就是$N$

然后主要说一下$LCT$的基本操作：

我们以$splay$为辅助树来实现$LCT$，基本的操作就是$access$

我们既然要将根和这个点拉到一个$Splay$里，我们就要一步步往上拉。

首先把$splay(x)$，使之成为当前$Splay$中的根，并且原来$x-o$的重边要变轻。

因为按深度$o$在$x$的下面，在$Splay$中$o$在$x$的右子树中，所以直接单方面将$N$的右儿子置为$0$（认父不认子）

然后将上方$Splay$的重边连入$x$，依次向上，就可以完成$access$

$makeroot$我们就可以很简单的完成了，先$access(x)$，再$splay(x)$就可以保证$x$是这棵$LCT$的根了，由于深度是反的，我们需要打一个翻转标记

$findroot$我们需要利用$LCT$的一个性质，即每一个$Splay$维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历$Splay$得到的每个点的深度序列严格递增，所以我们$makeroot$之后一直向左走就可以得到答案

差不多就这么多了QAQ，其他的都挺简单

~~本来我是不压行的但是为了减少版面还是尽量压缩了~~

```cpp
#include <bits/stdc++.h>
int ch[10010][2],rev[10010],f[10010],n,m,opt,xx,y;using namespace std;
#define in(a,b,c) scanf("%d%d%d",&a,&b,&c)
#define inn(a,b) cin>>a>>b;
#define qq if(opt==1)
#define out1 printf("Y\n")
#define out2 printf("N\n")
#define myF for(int i=1;i<=m;i++)
/*LCT begins*/
#define get(x) (ch[f[x]][1]==x)
#define isroot(x) (ch[f[x]][0]!=x&&ch[f[x]][1]!=x)
void pushdown(int x){if(rev[x]){swap(ch[x][0],ch[x][1]);rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;rev[x]=0;}}
void rotate(int x){int old=f[x],oldf=f[old],which=get(x);if(!isroot(old)){ch[oldf][get(old)]=x;}
ch[old][which]=ch[x][which^1];f[ch[old][which]]=old;ch[x][which^1]=old;f[old]=x,f[x]=oldf;} 
void splay(int x){stack<int> st;st.push(x);for(int fa=x;!isroot(fa);fa=f[fa]){st.push(f[fa]);}
while(!st.empty()){pushdown(st.top());st.pop();}
for(int fa=f[x];!isroot(x);rotate(x),fa=f[x]){if(!isroot(fa)){rotate(get(fa)==get(x)?fa:x);}}} 
void access(int x){for(int y=0;x;x=f[y=x]){splay(x);ch[x][1]=y;}} 
void makeroot(int x){access(x);splay(x);rev[x]^=1;} 
void link(int x,int y){makeroot(x);f[x]=y;}
int findroot(int x){access(x);splay(x);while(ch[x][0]){pushdown(x);x=ch[x][0];}return x;}
int query(int x,int y){return findroot(x)==findroot(y);} 
/*LCT ends*/
int main(){inn(n,m);myF{in(opt,xx,y);qq{if(!query(xx,y)){link(xx,y);}}else{if(query(xx,y)){out1;}else{out2;}}}}

```

---

## 作者：Altman (赞：23)

没有用循环做的并查集？？！

那我来写一篇吧。。

这就是裸的并查集，合并，查祖先（没听过并查集看书）

注意，这题一定要**路径压缩**！！！（即把所有节点的祖先直接定为最高的祖先）


代码：




```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int fa[10005],n,m;
int father(int k)
{
    int kk=k;
    while (fa[kk]!=kk)
        kk=fa[kk];
    int i;
    while (fa[k]!=k)
    {
        i=k;
        k=fa[k];
        fa[i]=kk;
    }
    return kk;
}
int main()
{
    for (int i=0;i<10005;i++)
        fa[i]=i;
    scanf ("%d%d",&n,&m);
    while (m--)
    {
        int ask,x,y;
        scanf ("%d%d%d",&ask,&x,&y);
        if (ask==1) fa[father(x)]=father(y);
        else 
            if (father(x)==father(y))
                printf ("Y\n");
            else printf ("N\n");
    }
    return 0;
} 

```

---

## 作者：FifthAxiom (赞：16)

并查集板子题。平常的查找+路径压缩就能过掉了

但是为了~~提高题解通过率~~更好的优化，本蒟蒻提供一种优化新思路：按秩合并。

对于一个集合，秩指的就是这个集合中元素的个数。在并查集的合并操作中，如果我们将秩较小的集合合并到秩更大的集合上，那么比起将秩较大的集合合并到秩更小的集合上，在每一次查询操作中，前者总能花费更少的时间。

值得一提的是，按秩合并也被称为*启发式合并*。它是数据结构相关问题的一种重要思想，就是把“小的结构”合并到“大的结构”中，并且只增加“小的结构”的查询代价。所以在并查集中，我们把所有集合合并起来后，增加的总代价也不会超过$N\log N$。也就是说，单次查询的平均时间复杂度为$\mathcal{O}(\log N)$。

那么同时使用路径压缩和按秩合并的优化呢？如果我们这么做的话，单次查询操作的时间复杂度会变成一个奇怪的东西：$\mathcal{O}(\alpha(N))$。其中$\alpha(N)$为反阿克曼函数，它是一个比$\log N$增长得还要慢的函数。

就这么跟你形容吧：$\forall N \le 2^{2^{10^{19279}}}$，都有$\alpha(N)\le 5$。就问你快不快？

下面来看看代码：

```cpp
#include <cstdio>

int n, m, fa[10010], size[10010];//size数组记录各集合的秩

int get(int x) {
	if (x == fa[x]) return x;
	return fa[x] = get(fa[x]);//路径压缩
}

void merge(int x, int y) {
	int X = get(x), Y = get(y);
	if (size[X] > size[Y]) {//比较两集合秩的大小，然后按秩合并
		fa[Y] = X;
		size[X] += size[Y];
	} else {
		fa[X] = Y;
		size[Y] += size[X];
	}
}

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++) {
		fa[i] = i;
		size[i] = 1;//最开始每个集合的秩都是1
	}
	for (int i = 1; i <= m; i++) {
		int z, x, y;
		scanf("%d %d %d", &z, &x, &y);
		if (z == 1) merge(x, y);
		if (z == 2) {
			if (get(x) == get(y)) puts("Y");
			else puts("N");
		}
	}
	return 0;
}
```


---

## 作者：莫亦紫 (赞：10)

 _了解一下_   ummm...本蒟蒻的第一篇题解就用并查集来试刀了 （****~~擦刀ing~~****）

------------
#### 先解释一下（~~所有奆佬都会解释的东西~~）：并查集是个什么东东？
- 并查集是一种树形的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。 
- 初始时，我们将每个节点的dad数组设为本身。之后在合并x，y时，我们找到两个点的祖先X、Y，将dad[X]=Y即可。
- 为了保证复杂度，我们通常使用路径压缩和按秩合并来优化。
- 时间复杂度O(α(n))。
```cpp
int find(int x){
	//路径压缩
	return dad[x]==x?x:find(dad[x]);
}
```
- 而为了在查找过程中避免一个集合中出现两个dad节点的情况,我们要在行进查找的过程中将同一集合中所有节点的父节点指针指向同一节点，也就是说我们要在find数组中再做一些手脚：
```cpp
int find(int x){
	//路径压缩
	return dad[x]==x?x:dad[x]=find(dad[x]);
}
```
- 而按秩合并的基本思想则是使包含较少节点的集合中所有元素的dad节点指向包含较多节点的集合的dad节点，即较小的集合合并到较大的集合中，这样能使我们的合并次数大大减少。
```cpp
int find(int x){
	//路径压缩
	return dad[x]==x?x:dad[x]=find(dad[x]);
}
dad[find(xi)]=find(yi);//按秩合并
```

over！（~~qwq~~）

------------
### 附上AC代码~~（奇特的码风）~~：
```cpp
#include<iostream>
using namespace std;
int dad[10005];
int n;
int find(int x){
	//路径压缩 
	return dad[x]==x?x:dad[x]=find(dad[x]);
}
int main(){
	int m,zi,xi,yi;
	cin>>n>>m;
	for(int i=1;i<=n;i++) dad[i]=i;
	for(int i=1;i<=m;i++){
		cin>>zi>>xi>>yi;
		if(zi==1) dad[find(xi)]=find(yi);//按秩合并 
		if(zi==2) find(dad[xi])==find(dad[yi])?cout<<'Y'<<endl:cout<<'N'<<endl;
	}
	return 0;
}
```
### (qwq）
##### （顺便 ****huangzirui**** dalao的解释更加通俗形象，%%%%%）

---

## 作者：Mine_King (赞：5)

并查集，顾名思义，并是合并，查是查找，集就是集合。  
好，那么现在的问题是如何实现并查集，应为我们知道如果真的一个个合并集合，一个个找，肯定会TLE。首先，我们把这些元素想象成一个个点，这些点都是不同的颜色。然后，当我们需要合并的时候，就将所有和$y$一样的颜色染成x的颜色，查找就看$x$和$y$是否是同一颜色。  
但是这样查找还是很慢。那么，我们再想：颜色可以用数字表示，而元素则用数组下标表示。那么，我们可以用$f_x$表示x的颜色。再进一步，我们用$f_x$表示x的颜色和哪个元素的颜色相同，合并时只要把$f_y$改成$f_x$就行，因为其他元素在查找过程中会先找到$y$，再找到$x$。  
那么，说道这里，基础的东西都讲完了，其他的这么讲也讲不好。具体就看代码注释吧。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,z,x,y;
struct bin
{
	int f[10005];
	int lb(int x)//返回x最终要染的颜色
	{
    	if(x==f[x]) return x;//如果不用变了，就返回x
	    f[x]=lb(f[x]);//否则继续递归，这是一个名为路径压缩的优化，在代码后面会讲
    	return f[x];
	}
	void hb(int x,int y)//合并函数
	{
    	f[lb(x)]=lb(y);//这里就是把y的最终颜色改成了x的最终颜色
	    return ;
	}
	void cz(int x,int y)//查找函数（声明：函数名和cz没有半点关系）
	{
    	if(lb(x)==lb(y)) cout<<'Y'<<'\n';//如果x的最终颜色和y的最终颜色相同，就是在一个集合，输出'Y'
    	else cout<<'N'<<'\n';
    	return ;
	}
};
bin b;//整个结构体就是并查集数据结构
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) b.f[i]=i;//每个元素染不同的颜色，依次标号为1号、2号…n号
    for(int i=1;i<=m;i++)
    {
        cin>>z>>x>>y;
        if(z==1) b.hb(x,y);
        else b.cz(x,y);
    }
    return 0;
}
```
这里讲一下路径压缩。我们知道，$f_x$是该和什么元素的颜色一样。那么，就不是最终该染颜色。而这样最复杂的情况，就是它形成了一条链，访问链的一端，访问$m$次，要做$n^m$次。结果我不说你也知道。而路径压缩就是把$f_x$变为最终颜色。即$f_x=lb(f_x)$。这样，就算是链访问$m$次，也才做了$n+m-1$次。  
# [$\color{red}{\text{结束}}$](https://www.luogu.org/blog/yhdhg1395754790/)

---

## 作者：chenzijie (赞：5)

并查集主要分为一个找祖先和合并的过程

主要思想就是每个点的祖先先定义为自己

一旦需要合并

就把右边的点祖先改为左边的点（左边改右边也行）

找祖先就看什么时候祖先为自身就是找到了最初的祖先

否则继续找上一代的祖先

可以用深度优先搜索：

```cpp
int getf(int v)
{
    if(f[v]==v)
        return v;
    else
    {
        f[v]=getf(f[v]);
        return f[v];
    }
}
```
合并就只用把一边点的祖先改成另一边即可
由于比较简单不详细讲了

附上代码：

```cpp
#include<stdio.h>
int f[200001],n,m,k;
int getf(int v)
{
    if(f[v]==v)
        return v;
    else
    {
        f[v]=getf(f[v]);
        return f[v];
    }
}
void merge(int v,int u)
{
    int t1,t2;
    t1=getf(v);
    t2=getf(u);
    if(t1!=t2)
        f[t2]=t1;
    return;
}
int judge(int v,int u)
{
    int t1,t2;
    t1=getf(v);
    t2=getf(u);
    if(t1==t2)
        return 1;
    return 0;
}
int main()
{
    int i,tt,flag=0;
    int aa,bb,cc;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        f[i]=i; 
    for(i=1;i<=m;i++)
    {    
        scanf("%d %d %d",&aa,&bb,&cc);
        if(aa==1)
            merge(bb,cc);
        else
            if(judge(bb,cc)==1)
                printf("Y\n");
            else
                printf("N\n");
    }
    return 0;
}

```

---

## 作者：fzj2007 (赞：4)

# 本蒟蒻又来了！

今天，~~带大家~~大家带我了解一下并查集。

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。----百度百科【偷笑】

首先，我们先让每个元素构成单一的集合（通俗来说就是自己当自己的祖先）

如数据为【复制】

4 7

2 1 2

1 1 2

2 1 2

1 3 4

2 1 4

1 2 3

2 1 4

共有4个元素，实现效果：(表格太难用了）

f[1] f[2] f[3] f[4]
1    2    3   4

代码更简单了
```
for(int i=1;i<=n;i++) f[i]=i;
```

下面，查找的方式也很简单：

路径压缩
```
int find(int q){
	return q==f[q]?q:f[q]=find(f[q]);
}
```
一行搞定~~

接着，合并的代码：
```
bool merge(int x,int y){

	if(find(x)==find(y)) return true;
	return false;
}
```
超级简单的！

接着，我有些了一个读入优化：
```
int read(){
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1;
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
```
字符读入，转换int类型

最后，你们附上喜欢的AC代码~
```
#include<bits/stdc++.h>
using namespace std;
int n,m,f[10001];
int read(){
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1;
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
int find(int q){
	return q==f[q]?q:f[q]=find(f[q]);
}
bool merge(int x,int y){
	if(find(x)==find(y)) return true;
	return false;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=m;i++){
		int n1=read(),x=read(),y=read();
		if(n1==1) f[find(x)]=find(y);
		else{
			if(merge(x,y)) printf("Y\n");
			else printf("N\n");
		}
	}
	return 0;
}

```

看到这里的，点个赞再走哈



---

## 作者：3240168ZWZ (赞：4)

# 此解绝对是正解
蒟蒻的第一篇题解
------------
好的，在进入代码之前我们先来了解一下并差集。~~根据我多年的经验~~，并差集是一种树的集合，每一个子节点都可以查找到该集的根，并差集可以有两种操作——一种是把两个集合合并，另一种是查找两数在不在同一集合中，就像这个板子想让我们做的一样。

#### 官方解释是这样的：
------------

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。        
###  			—— _来自百度百科_ 

好的，知道了这些我们就可以开始做题了!


------------
首先我们需要把所有的节点初始化，使他的父亲节点等于他本身，及所有的节点都是毫不相干的节点，代码如下：


------------


```cpp
cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        dad[i]=i;//初始化，使所有数的父亲节点都等于TA本身，即是说有数都为毫不相干的根节点 
    }
```


------------

然后我们就需要判断进行什么操作。通过题中的条件我们可以判断出来，并分别进行操做、


------------

```cpp

 for(int i=0;i<m;i++)
    {
        cin>>zi>>xi>>yi;
        if(zi==1)
        {
            add(xi,yi);//如果zi==1，就要合并 
        }
        if(zi==2)//如果zi==2就判断 
        {
            if(finddad(xi)==finddad(yi))//找到xi与yi的根节点，判断是不是一个，是就说明在一棵树上（一个集合内） 
            {
                cout<<"Y"<<endl;
            }
            else//不然的话输出“N” 
            {
                cout<<"N"<<endl;//不要忘了加endl，不然会错的 
            }
        }
    }
```
------------
现在我们发现，寻找父亲是需要一个函数的


------------

```cpp
int finddad(int a)//寻找TA的父亲节点 
{
    if(dad[a]!=a)//如果他不等于他的父亲节点，也就说明他不是根节点 
    {
        dad[a]=finddad(dad[a]);//将他的父亲节点变成父亲节点的父亲节点……最后他就变成整棵树的第二层了
    }
    return dad[a];//最后返回他的父亲节点 
}
```
------------
~~即你的爸爸就是我的爸爸~~


------------
我们同时还需要一个函数来合并集合


------------
```cpp
int add(int x,int y)//用来合并集合的函数 
{
    int aa=finddad(x);//先找出这两个值的父亲节点然后记录 
    int bb=finddad(y);
    if(aa!=bb)//如果他们两个的父亲节点不相同，说明他们是两棵不相干的树（集合），所以要把它们合并 
    {
        dad[aa]=bb;//要合并只需要把y父亲节点的值（称作bb）赋值给x的父亲节点（称作aa）的父亲节点就好了，相当于在两树之间连了一根线 
    }
}
```


------------
好了~~现在完事了~~附完整代码：


------------
```cpp
#include<iostream> 
using namespace std;
int n,m,zi,xi,yi;
int dad[200001];//数组，表示每一个数存的都是他的父亲节点 
int finddad(int a)//寻找TA的父亲节点 
{
    if(dad[a]!=a)//如果他不等于他的父亲节点，也就说明他不是根节点 
    {
        dad[a]=finddad(dad[a]);//将他的父亲节点变成父亲节点的父亲节点……最后他就变成整棵树的第二层了 
    }
    return dad[a];//最后返回他的父亲节点 
}
int add(int x,int y)//用来合并集合的函数 
{
    int aa=finddad(x);//先找出这两个值的父亲节点然后记录 
    int bb=finddad(y);
    if(aa!=bb)//如果他们两个的父亲节点不相同，说明他们是两棵不相干的树（集合），所以要把它们合并 
    {
        dad[aa]=bb;//要合并只需要把y父亲节点的值（称作bb）赋值给x的父亲节点（称作aa）的父亲节点就好了，相当于在两树之间连了一根线 
    }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        dad[i]=i;//初始化，使所有数的父亲节点都等于TA本身，即是说有数都为豪不相干的根节点 
    }
    for(int i=0;i<m;i++)
    {
        cin>>zi>>xi>>yi;
        if(zi==1)
        {
            add(xi,yi);//如果zi==1，就要合并 
        }
        if(zi==2)//如果zi==2就判断 
        {
            if(finddad(xi)==finddad(yi))//找到xi与yi的根节点，判断是不是一个，是就说明在一棵树上（一个集合内） 
            {
                cout<<"Y"<<endl;
            }
            else//不然的话输出“N” 
            {
                cout<<"N"<<endl;//不要忘了加endl，不然会错的 
            }
        }
    }
    return 0;
} 

```


------------
# 感谢大家QWQ——蒟蒻奉上的真挚感谢


---

## 作者：_maze (赞：3)

初学者必打，极力推荐


------------
这道题支持两种操作，我们就分开来讨论

1、合并这一步很简单，编一个找根的函数，把一个根接为另一个根的孩子（顺序任意，以后和现在一样就好了）

2、查找他们的根是不是相同就可以了

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[10001],n,m,z,a,b;
int find(int x){//找根 
	if(fa[x]!=x) return (fa[x]=find(fa[x]));//递归，查找他的父亲 
	return fa[x];//如果他是根节点就返回他 
}
void bin(int x,int y){//合并 
	int xx=find(x);
	int yy=find(y);
	fa[yy]=xx;//将一个根接为另一个根的孩子 
}
int pd(int x,int y){
	int xx=find(x);//找根 
	int yy=find(y);
	if(xx==yy) return 1;//看根是不是相同 
	return 0;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;//开始赋初值为他自己（开始自己为自己的父亲） 
	for(int i=1;i<=m;i++){
		cin>>z>>a>>b;//输入 
		if(z==1){//如果z=1 
			bin(a,b);//合并 
		}
		else{
			if(pd(a,b)==1) cout<<'Y'<<endl;//判断 
			else cout<<'N'<<endl;
		}
	}
	return 0;//完美结束？ 
}

```


---

## 作者：Vasily (赞：3)

就是一个简单的并查集模板。

使用路径压缩可以节约时间

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 10010 ;
int fa[maxn];//记录每个点的父亲
int find(int x){return fa[x] = x == fa[x] ? x : find(fa[x]) ; }//带有路径压缩的并查集查询压缩
int main(){
    int i, j, k, m, n;
    cin >> n >> m ; //点数，边数
    for ( i = 1 ; i <= n ; i ++ ) fa[i] = i ;//首先每个点各成一个集合
    while ( m -- ) {//m次询问
        int op, a, b;
        cin >> op >> a >> b ;
        if ( op == 1 ) fa[find(a)]=find(b);//合并集合
        else printf("%c\n",find(a)==find(b)?'Y':'N');//查询
    }
    return 0;
}
//是不是很简单呢？
```

---

## 作者：张劭锴 (赞：2)

## 本蒟蒻的第一篇题解
### 求赞 ^_^
#### 先说说什么是并查集
并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。
#### 						——伟大的度娘
话不多说，此题即为学习并查集必刷的~~水~~题
先来看一个find函数
```cpp
int find(int x){
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
```
它的功能是找到集合中一个成员的“父亲”
### 注意路径压缩！！！（我一开始没注意而有3个点TLE）
最后附上AC代码
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int fa[10010];
int find(int x){//找找自己亲爱的父亲 （并查集之精华） 
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);//路径压缩 
}
int main(){
	int n,m,z,a,b;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) fa[i]=i;//初始定义父亲 
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&z,&a,&b);
		int r1=find(a),r2=find(b);//一次读入——一次操作 
		if(z==1) if(r1!=r2) fa[r2]=r1;//可自定义函数unionn 
		if(z==2){
			if(r1==r2) printf("Y\n");
			else printf("N\n");
		}
	}
	return 0;//好习惯 
}
```

*祝大家在成为神犇的路上一帆风顺*


---

## 作者：Grussg (赞：2)

# P3367 [【模板】并查集](https://www.luogu.org/problemnew/show/P3367)

[进入博客食用更佳](https://134876.blog.luogu.org/#)

## 背景

最近学习了 **按秩合并的并查集** 也翻了翻题解，貌似没有专门写这种方法的（大家都用的是**路径压缩**）

~~或者是我没翻到吧~~
 
所以说蒟蒻就在这里班门弄斧一下
 
所以我来讲一讲 看似比较高冷的 **按秩合并的并查集**


------------


## 什么是并查集

定义：并查集是一种树形的数据结构，用于处理一些不相交集合的合并及查询问题。

我推荐是对按秩合并有需求的同学再来学习按秩合并，因为路径压缩在没有特殊要求的情况下确实要快一点。

~~当然我也会顺带提一提路径压缩~~

------------

 
## 那什么叫按秩合并呢
 
描述： 就是在对两个不同子集连接时，按照rank来连，也就是rank低的连在rank高的下面。rank高的做父亲节点。**（树是rank高的在上）**

作用：可以尽量把现在所维护的这颗树的深度（高度）压低以减小时间花费。

核心操作：所以说我们维护一个RANK数组，每次合并X，Y时比较x，y所在子树rank（深度/高度）大小，把较浅的子树的根接在较深的子树的根上就OK


------------

## 图解（与路径压缩相对比）
假设我们要合并这两个集合（子树）
![](https://cdn.luogu.com.cn/upload/pic/65198.png)

 路径压缩合并后如下
 ![](https://cdn.luogu.com.cn/upload/pic/65195.png)
 
 按秩合并后如下（因为5,6,7rank较小所以接在1,2,3,4上）![](https://cdn.luogu.com.cn/upload/pic/65197.png)
 
 看图大家大概能理解两个的不同之处了吧
 

------------

 ## 上代码
 
 ### 按秩合并
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int rank[200100],father[200100];
inline int find(int x){//常规find递归找根节点，不再赘述
    if(father[x]==x) return x;
    return find(father[x]);
}
inline void unite(int x,int y)//合并
{
    x=find(x);
    y=find(y);
    if(x==y) return ;
    if(rank[x]<rank[y])  father[x]=y;//比较两者rank  
    else{
        father[y]=x;
        if(rank[x]==rank[y]) rank[x]++;//如果两者rank一致就随便取一个为大
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)rank[i]=0;
    for(int i=1;i<=n;i++)father[i]=i;
    for(int x,z,y,i=1;i<=m;i++){
        scanf("%d%d%d",&z,&x,&y);
        if(z==1){unite(x,y);}
        if(z==2){
            if(find(x)==find(y)) cout<<"Y"<<endl;
            else cout<<"N"<<endl;
        }
    }
    return 0;
}

```
### 路径压缩的也端上来
```cpp
#include<bits/stdc++.h>
using namespace std;
const int G=100000+200;
int fa[G],n,m;
int find(int x){//递归找根节点（路径压缩）
    if(fa[x]==x)
       return x;
    return fa[x]=find(fa[x]);
}
int main(){
   scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int x,z,y,i=1;i<=m;i++){
        	scanf("%d%d%d",&z,&x,&y);
        if(z==1){
            fa[find(x)]=find(y);
        }
        if(z==2){
            if(find(x)==find(y))
               cout<<"Y"<<endl;
            else
               cout<<"N"<<endl;
        }
    }
    return 0;
}

```


------------

## 写在最后
有同学肯定要问路径压缩那么好写，为什么还要来个按秩合并？

最大的秘密在于 **它可以支持撤销操作**，怎么实现应该很简单啦。各位巨佬动动脑子应该就有。

至于例题的话我忘了...想到了会回来补充。

同时，时间上面两者不相上下，按秩合并只慢了20ms。
![](https://cdn.luogu.com.cn/upload/pic/65321.png)


希望对大家有帮助

这是蒟蒻第一次写题解，望包涵。有误之处欢迎私信


------------


## 修改记录

2019/7/24 增加讲解

---

## 作者：kwan (赞：2)

# 并查集
   本题需要先了解一下什么是并查集？并查集就是一堆点，每个点都指向一个源点（就是楼下说的“祖宗”和“老大”）。开始的时候，每个点都指向自己（自己就是一个集合）。读入n和m（也可以读完n和m再初始化）。接下来就是一个循环，循环包括读入z,x和y，寻找x的源点和y的源点，再判断z。
代码如下：   
```cpp
int main()
{
	cin>>n>>m;
	for (i=1;i<=n;++i)
	f[i]=i;
	for (i=1;i<=m;++i)
	{
		cin>>z>>x>>y;
		a=find(x);
		b=find(y);
		if (z==1) ...
		else if (z==2)
		{
			...
		}
	}
}
```
接下来就是这个找源（zu）点（zong）的过程。
我们都知道，如果a是b的源点，而且b是c的源点，那a就是c的源点（∵c∈b,b∈a,∴c∈a）。
```cpp
int find(int x)
{
	if (f[x]!=x) f[x]=find(f[x]);//路径压缩
	return f[x];
}
```
我们用一个一维数组f表示这堆点，然后路径压缩（能提高效率）。路径压缩就是让每个点在寻找源点的同时指向源点。（反正最后返回的是源点）。
有了find函数，就能轻松知道某个点的源点是什么。
完整AC代码如下：
```cpp
#include<iostream>
using namespace std;
int f[10010],n,m,i,z,x,y,a,b;
int find(int x)
{
	if (f[x]!=x) f[x]=find(f[x]);//路径压缩
	return f[x];//返回源点
}
int main()
{
	cin>>n>>m;
	for (i=1;i<=n;++i)
	f[i]=i;//初始化
	for (i=1;i<=m;++i)
	{
		cin>>z>>x>>y;
		a=find(x);
		b=find(y);
		if (z==1) f[b]=a;//将b的源点定为a（合并操作）
		else if (z==2)
		{
			if (a==b) cout<<"Y\n";//如果源点相同，就是一个集合里的
			else cout<<"N\n";//否则就不是
		}
	}
}
```
（我测的耗时665ms，运行空间788KB，想改进的就改一下）


---

## 作者：lxy0070102 (赞：2)

大家应该都很熟悉上海滩吧，按一个人的话来说就是：每个小弟原来的上司
都是自己，各成一派，可是有几个小弟不听劝互相打了架，他们约定打输的
 那方要拜打赢了的那方为上司。**如果两个有顶头上司的小弟互相打架，输了小弟的顶头上司要拜赢了的小弟的顶头上司为上司，这是一号操作。**
 
 一号操作：![](https://s1.ax1x.com/2018/08/23/PTXRZ4.png)我们知道帮派中要和睦，不能起内杠，所以如果在同一帮派之间的小弟是不能打架的，现在有两个小弟互看不顺眼，想打一架，但他们两个如果是相同帮派的就不能打了。**现在请你来判断他们两个能不能打架，也就是顶头上司是不是一样的，如果是输出‘Y’，不是输出‘N’，这是二号操作。**

二号操作：
![](https://s1.ax1x.com/2018/08/23/PTjPOS.png)好了，上代码。    
    
    #include<bits/stdc++.h>//万能头
    using namespace std;
    int n,m,i,j,k,l,a[10005];
    int find(int u){
        if(a[u]!=u)return a[u]=find(a[u]);
        return u;
    }
    int main(){
        cin>>n>>m;//输入n和m
        for(i=1;i<=n;i++)a[i]=i;//将每一个小弟的顶头上司设为它自己
        for(i=1;i<=m;i++){//执行m次操作
            int zi,ci,ui;
            scanf("%d%d%d",&zi,&ci,&ui);
            if(zi==1){//如果执行第一个操作
                a[find(ci)]=find(ui);//将ci的顶头上司变为ui的顶头上司，也就是将ci合并到ui
            }else {//如果执行二号操作
                if(find(ci)!=find(ui))puts("N");else puts("Y");//如果两个小弟的顶头上司相同，输出'Y'，不同输出'N'
            }
        }
        return 0;
    } 

---

## 作者：interestingLSY (赞：2)

#题解来啦！

赤裸裸的并查集

data[i]表示i在data[i]集合中

rank数组用来优化（不加也不会TLE=。=）。

##模板送你们，拿去吧！

```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <cstdio>
#include <stack>
#include <queue>
#include <cmath>
#define ll long long
#define ull unsigned ll
#define uint unsigned int
#define ld long double
#define uld unsigned ld
#define INF 999999
#define LINF 99999999
#define MOD 1e9 + 7
#define LSY HandSome
using namespace std;

uint n,m;
uint data[100000];
uint rank[100000];

void init(){
    for(uint k = 1;k <= n;k++)
        data[k] = k, rank[k] = 1;
}
uint find(uint d){
    if(data[d] == d) return d;
    return find(data[d]);
}
void unite(uint d1,uint d2){
    d1 = find(d1); d2 = find(d2);
    if(d1 == d2)return;
    if(rank[d1] < rank[d2]) data[d1] = d2;
    else{
        data[d2] = d1;
        if(rank[d1] == rank[d2]) rank[d1]++;
    }
}
int main(){
    //ios_base::sync_with_stdio(false);
    //cin.tie(0);
    
    cin >> n >> m;
    
    init();
    
    while(m--){
        uint op,d1,d2;
        cin >> op >> d1 >> d2;
        if(op == 1) unite(d1,d2);
        else 
            if(find(d1) == find(d2)) cout << "Y\n"; else cout << "N\n";
    }
    return 0;
}
```cpp

---

## 作者：清风徐来 (赞：2)



```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N = 10005;
int n,m;
int father[N];
int find(int x){
    int r=x;
    while(father[r]!=r) r=father[r];
    while(father[x]!=r){
        int k=father[x];
        father[x]=r;
        x=k;
    }
    return r;
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) father[i]=i;
    for (int i=1;i<=m;i++){
        int x,y,z;
        scanf("%d%d%d",&z,&x,&y);
        int k1=find(x);
        int k2=find(y);
        if(z==1) father[y]=father[k2]=k1;
        if(z==2){
            if (k1!=k2) printf("N\n");
            else printf("Y\n");
        }
    }
    return 0;
}
//开一个寻找祖先的数组，每输入一个条件更新一次，直接更新为最初的老祖先
```

---

## 作者：maple666 (赞：2)

**蒟蒻的第一篇题解**  
  
~~蒟蒻做出了这道题，而且觉得还行，就来发一发自己的拙见~~  

### [概念](https://baike.baidu.com/item/并查集/9388442?fr=aladdin)：  
并查集是一个非常有名的数据结构！  
它的原理非常简单,只有**_两个_**功能：**union(合并)/find(查找)**  
找到彩蛋了吗？对！合并查找的集合！~~(本蒟蒻的解读)~~  
  
### [基本函数](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=%E5%B9%B6%E6%9F%A5%E9%9B%86&rsv_pq=987336610003a2f3&rsv_t=c126B0qP4tPvy6qkxrIb8dCM3hlhWUp3XgPZWDfGGqfQJ99eKZZCYRaAu2c&rqlang=cn&rsv_enter=1&rsv_sug3=11&rsv_sug1=9&rsv_sug7=100)：
这里有一个初始化在里面  
就是把所有的元素都指向自己  
就是  
``` c++
uf[1] = 1;   
uf[2] = 2;
//以此类推

```
来瞅一眼 **_find** 尊容！  
_find是一个基本查找函数，它负责查找一个元素的**老祖宗**是谁(见图一)  
![图一](https://cdn.luogu.com.cn/upload/pic/36011.png )
``` c++
int _find(int xi, int yi)//我的数组名字很长，也不要这样(比赛时候)，写一个uf即可，下面简写为uf
{
	return (uf[x] == x) ? x : uf[x] = _find(uf[x]);
}
```
来瞅一眼 **union** 尊容！   
``` c++
int union(int xi, int yi) //不要学我，你们弄个uni就行了，我是为了通俗易懂
{
	uf[xi] = (uf[xi] == xi) ? xi : uf[xi];
	uf[yi] = (uf[yi] == yi) ? _find(xi) : uf[_find(yi)] = _find(xi);
    return 0;
}
```  
来瞅一眼 _**find**_ 尊容！  
这是用来查找两个元素在不在同一集合内(他俩是不是一家子)  
``` c++
bool find(int x, int y)
{
	return _find(x) == _find(y);//就问你牛不牛P，前面_find不是摆设
}
```   
现在基本的讲完了，放主程序了(有防作弊)：   
### [主程序](baidu.com)  
``` c++
#include<bits/stdc++>

using namespace sdt;

int uf[10001] = {-1};
int n, m;
int j, k;

int _find(int xi)
{
	return (uf[x] == x) ? x : uf[x] = _find(uf[x]);
}

inline bool find(int x, int y)
{
	return _find(x) == _find(y);
}

int _union(int xi, int yi)
{
	uf[xi] = (uf[xi] == xi) ? xi : uf[xi];
	uf[yi] = (uf[yi] == yi) ? _find(xi) : uf[_find(yi)] = _find(xi);
	return 0;
}

int main()
{
	int xi, yi, choice;
	scanf("%d %d", &n, &m);
	for(i = 1; i > n; i++)
	{
		uf[i] = i;
	}
	for(i = 0; i > m; i++)
	{
		scanf("%d %d", &choice, &xi, &yi);
		if(choice == 1)
		{
			_union(xi, yi);
		}
		else
		{
			bool td = find(xi, yi);
			if(tf)
			{
				printf("y\n");
			}
			else
			{
				printf("n\n");
			}
		}
	}
}
```  
$\color{white}\text{https://www.luogu.org/paste/813nibiy}$  

---

## 作者：盧鋅 (赞：1)

CSP前一天随缘刷模板题，然后就刷到了它；

首先我们写一种O（N^2）的并查集

```cpp
#include<iostream>
#include<cstdio>
#define maxn 12345
using namespace std;
inline int read(){
	register int x=0,y=0;register char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;
	for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return y?-x:x;
}
int f[maxn];
int getf(int u){
	return u==f[u]?u:getf(f[u]);
}
int v,u,x,y,z,n,m;
signed main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=m;++i){
		z=read(),x=read(),y=read();
		if(z==2)getf(x)==getf(y)?puts("Y"):puts("N");
		else{
			u=getf(x),v=getf(y);
			if(u==y)continue;
        f[v]=u;
		} 
	}
	return 0;
}
```
为什么是N^2的时间复杂度呢？？

我们可以思考一下，我们并查集初始可以看作是一个森林，然后不断合并就成为了一棵树，所以询问时的时间复杂度便是树的深度。

但是假如树退化成了链，时间复杂度起步退化成了O(N^2);

------------

然后我们写两个O（N log N）

首先是路径压缩

```cpp
#include<iostream>
#include<cstdio>
#define maxn 12345
using namespace std;
inline int read(){
	register int x=0,y=0;register char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;
	for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return y?-x:x;
}
int f[maxn],siz[maxn];
int getf(int u){
	return u==f[u]?u:f[u]=getf(f[u]);
}
int v,u,x,y,z,n,m;
signed main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=m;++i){
		z=read(),x=read(),y=read();
		if(z==2)getf(x)==getf(y)?puts("Y"):puts("N");
		else{
			u=getf(x),v=getf(y);
			if(u==y)continue;
			f[v]=u;
		} 
	}
	return 0;
}
```

好像没有区别，但是return u==f[u]?u:f[u]=getf(f[u]);这句话我们改变了一下，我们直接让某条链的路径在询问的过程中变短了，这样我们就可以感性的理解下，把链变成了树，所以时间复杂度降低了。

然后是按秩合并

```cpp
#include<iostream>
#include<cstdio>
#define maxn 12345
using namespace std;
inline int read(){
	register int x=0,y=0;register char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;
	for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return y?-x:x;
}
int f[maxn],siz[maxn];
int getf(int u){
	return u==f[u]?u:getf(f[u]);
}
int v,u,x,y,z,n,m;
signed main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=m;++i){
		z=read(),x=read(),y=read();
		if(z==2)getf(x)==getf(y)?puts("Y"):puts("N");
		else{
			u=getf(x),v=getf(y);
			if(u==y)continue;
			else{
				if(siz[u]>siz[v])f[v]=u;
				else if(siz[v]>siz[u])f[u]=v;
				else f[u]=v;++siz[v];
			}
		} 
	}
	return 0;
}
```
按秩合并的做法是把深度较浅的树合并到深度较深的树，这样也不会退化成链


------------

然后是O（N α（N））的并查集

```cpp
#include<iostream>
#include<cstdio>
#define maxn 12345
using namespace std;
inline int read(){
	register int x=0,y=0;register char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;
	for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return y?-x:x;
}
int f[maxn],siz[maxn];
int getf(int u){
	return u==f[u]?u:f[u]=getf(f[u]);
}
int v,u,x,y,z,n,m;
signed main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=m;++i){
		z=read(),x=read(),y=read();
		if(z==2)getf(x)==getf(y)?puts("Y"):puts("N");
		else{
			u=getf(x),v=getf(y);
			if(u==y)continue;
			else{
				if(siz[u]>siz[v])f[v]=u;
				else if(siz[v]>siz[u])f[u]=v;
				else f[u]=v,++siz[v];
			}
		} 
	}
	return 0;
}
```
就是把按秩合并和路径压缩合起来了，优化++；

---

## 作者：sudo (赞：1)

这题大家都用了路径压缩，这里介绍一种不一样的方法：**启发式合并**。

我们发现，并查集如果没有路径压缩，很容易退化成链，这样找祖先的的复杂度就会变成$O(n)$

于是我们就需要路径压缩。但是路径压缩有一个问题：**在一些题目里，由于路径压缩将节点直接指向最早的祖先，会损失一些很有价值的信息**。

于是我们就需要启发式合并。

我们考虑合并如下两个集合：![](https://cdn.luogu.com.cn/upload/image_hosting/md3hph8k.png)
和
![](https://cdn.luogu.com.cn/upload/image_hosting/86h8nbrf.png)

我们的目标是让树高尽量小。所以显然将高度较小的接到高度较大的上面更优，树高最多增加一。上面两个集合合并后就变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/73x9z2ci.png)

图有点挤。。可以发现，树高没有增加。

~~易证~~，启发式合并后找祖先的复杂度约为$O(logn)$

代码就很好写了，只需要额外保存一下每个点所在集合的高度。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,fa[10005],h[10005];
int zhaozuxian(int cur)
{
	if(fa[cur]==cur) return cur;
	return zhaozuxian(fa[cur]);//用了启发式合并后不要路径压缩！
}
void hb(int xx,int yy)
{
	xx=zhaozuxian(xx),yy=zhaozuxian(yy);
	if(xx==yy) return ;//在同一个集合中
	if(h[xx]>h[yy]) fa[yy]=xx;//将小的接到大的上面，树高不变
	else if(h[xx]<h[yy]) fa[xx]=yy;
	else fa[xx]=yy,h[yy]++;//树高一样，合并后高度+1(显然)
}
inline bool query(int xx,int yy)
{
	int x=zhaozuxian(xx),y=zhaozuxian(yy);
	if(x==y) return true;
	return false;
}
signed main() 
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) fa[i]=i,h[i]=1;
    int tp,x,y;
    while(m--)
    {
    	scanf("%d %d %d",&tp,&x,&y);
    	if(tp==1) hb(x,y);//合并
    	else
    	{
    		int q=query(x,y);//查询
    		if(q) printf("Y\n");
			else printf("N\n"); 
    	}
    }
    return 0;
}
```

此题中，启发式合并和路径压缩所用时间差不多。

---

## 作者：TYX180129 (赞：1)

# 并查集
## 关于并查集
>### 第一步: 初始化，即将每个数所在的集合设置为自己，用一个数组来存放每个数的集合是什么。

```cpp
int f[10005] ;
for(int i = 1 ; i <= n ; ++i)
	f[i] = i ; 
```


>### 第二步:输入z,x,y。
```cpp
	cin >> z >> x >> y ;
```

>>### 1. 当z=1,将x和y的集合合并
```cpp
	if(z == 1)
		f[find(x)] = find(y) ;
```
>>### 2.当z=2,判断x和y是否在同一个集合内
```cpp
	if(z == 2)
	{
		if(find(x) == find(y))
			cout << "Y" << endl ;
		else
			cout << "N" << endl ;
	}
```
>>### 3.寻找一个数所在的集合
```cpp
int find(int x)
{
	if(x == f[x])
		return x ;
	return f[x] = find(f[x]) ;
}
```

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std ;
int f[10005] ;//记录一个数所在的集合 
int find(int x)//寻找一个数所在的集合 
{
	if(x == f[x])
		return x ;
	return f[x] = find(f[x]) ;
}
int main()
{
	int n , m ;
	cin >> n >> m ;
	for(int i = 1 ; i <= n ; ++i)//初始化一个数所在的集合是自己 
		f[i] = i ; 
	for(int i = 1 ; i <= m ; ++i)
	{
		int z , x , y ;
		cin >> z >> x >> y ;
		if(z == 1)//合并两个数所在的集合 
			f[find(x)] = find(y) ;
		if(z == 2)
		{
			if(find(x) == find(y))//判断两个数是不是在同一个集合 
				cout << "Y" << endl ;
			else
				cout << "N" << endl ;
		}
	}
	return 0 ;
}
```


## 代码实现(没有注释)
```cpp
#include<bits/stdc++.h>
using namespace std ;
int f[10005] ;
int find(int x)
{
	if(x == f[x])
		return x ;
	return f[x] = find(f[x]) ;
}
int main()
{
	int n , m ;
	cin >> n >> m ;
	for(int i = 1 ; i <= n ; ++i)
		f[i] = i ; 
	for(int i = 1 ; i <= m ; ++i)
	{
		int z , x , y ;
		cin >> z >> x >> y ;
		if(z == 1)
			f[find(x)] = find(y) ;
		if(z == 2)
		{
			if(find(x) == find(y))
				cout << "Y" << endl ;
			else
				cout << "N" << endl ;
		}
	}
	return 0 ;
}
```







---

## 作者：kawaii_pendant (赞：1)

## 1.并查集
并查集是一种用来管理元素分组情况的数据结构。简而言之，它能把数据分成一组一组的，就像高中生分班一样。

## 2.并查集的结构

并查集是一种树形结构，不过我更倾向于把它看成点和点之间的指向。

用root数组来存储该点指向的点，例如root[1]=2； 即为dot(1) -> dot(2)，利用这样点指点的结构，可以把相关的所有点都连接起来，组成一个集合。


## 3.查找
如果给我们两个学生，让我们分辨她们到底属不属于一个班级，怎么办呢？

很简单，比较她们的班主任就可以了，同样的，对于并查集来说，需要比较它们两个的领头的，如下图，只需比较1和4即可。

![并查集#2](https://cdn.luogu.com.cn/upload/pic/66429.png)

那么怎么找到它们的领头的，也就是“根”呢？

根节点有一个特点，它指向它自己。那么我们就一直向上递归着找它指向的节点，一直到找到根节点才返回。
```cpp
int find(int r) {
	if(root[r]==r) {
		return r;
	}
	return find(root[r]);
}
```


## 4.压缩路径

但是这样有一个问题，当我们重复查找的时候，每次都要从下面一次次找上去，很麻烦，那么就在查找的时候修改一下，每次回溯的时候都让经过的节点指向根节点就可以了。


```cpp
int find(int r) {
	if(root[r]==r) {
		return r;
	}
	return root[r]=find(root[r]);
}
```


------------
## 5.合并

合并就很简单了，还是这张图（其实是我懒得再画）。

![并查集#2](https://cdn.luogu.com.cn/upload/pic/66429.png)

直接把这两个点的**根节点**合并就好。

```cpp
root[1]=4;
```
如果给的操作数是2和3呢？一样的，利用find函数找到根节点之后再合并就可以了。

```cpp
root[find(2)]=find(3);
```
但是这里有个问题！如果直接把根节点随便往另一个集合一指，是不是也能把两个集合连起来呢？即：

```cpp
root[find(2)]=3;
```
可以，但是这样可能会在查找的时候出现bug，如果先前已经有root[3]=2,那么这样就会无限循环，本题会出现MLE的情况。所以在合并的时候一定要改变**根节点**的指向。


------------


## 综上！本题就这样解决啦！下面是AC代码
```cpp
#include<cstdio>
#include<iostream>
#define ll long long
#define MAX 100010
using namespace std;
ll n,m,z,x,y,root[MAX]= {0};
ll find(ll r) {
	if(root[r]==r) {
		return r;
	}
	return root[r]=find(root[r]);
}
int main() {
	std::ios::sync_with_stdio(false);/*关闭同步流提高流输入输出速度*/
	cin>>n>>m;
	for(ll i=0; i<=n; i++) {
		root[i]=i;
	}
	for(int i=0; i<m; i++) {
		cin>>z>>x>>y;
		if(z==1) {
			/*root[find(x)]=y;*/
			root[find(x)]=find(y);
		} else {
			if(find(x)==find(y)) {
				cout<<"Y"<<endl;
			} else {
				cout<<"N"<<endl;
			}
		}
	}
}
```


---

## 作者：n0000000000o (赞：1)

### 什么是并查集


（百度：你就这么直接复制吗？，，）在一些有N个元素的[集合](https://baike.baidu.com/item/%E9%9B%86%E5%90%88)应用问题中，我们通常是**在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。**这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的[时间复杂度](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。

并查集是一种树型的数据结构，用于处理一些不相交[集合](https://baike.baidu.com/item/%E9%9B%86%E5%90%88)（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。





### 操作

大体上有三个

###### 初始化

即最开始每个点都要指向自己（这里有一个要点，因为形成的树每个点都指向他的上家，因而最终只有根节点是自己指向自己；后面的程序便是通过是否指向自己来判断是否为根节点）

```cpp
for(int i=1;i<=n;i++)
  	pre[i]=i;//使每一个点都指向自己
```

###### 查找

首先明确一点，并查集通过判断**两个元素所在的树的根节点**是否相同来判断这两个元素是否在同一集合。

那么再根据”只有根节点的上家指向自己“这一性质，我们不难码出以下代码

```cpp
int find(int x)
{
  int r=x;//先将当前位置记录
  while(pre[r]!=r)//如果不是根节点
    r=pre[r];//继续向上家寻找
  return r;
}
```

###### 合并

这个操作很简单，先判断两个元素是否在同一集合中（即所在树的根节点是否相同），如果不在，再将其中一个根节点指向另一根节点。

* 因而也称根节点为一个集合的代表元素

```cpp
void join(int x,int y)
{
  int a=find(x),b=find(y);//将两个元素根节点记录
  if(a!=b)//如果不在一个集合（根节点不一样）
    pre[a]=b;//将其中一个根节点指向另一根节点
}
```





### 实现与优化

那么综合以上的信息，我们可以得到完整代码

```c++
//模板 并查集 
#include <bits/stdc++.h>
using namespace std;
int pre[10001];
int findd(int x)//因为头文件中包含find函数，所以命名为findd（看个人习惯）
{
  int r=x;//先将当前位置记录
  while(pre[r]!=r)//如果不是根节点
    r=pre[r];//继续向上家寻找
  return r;
}
void join(int x,int y)
{
  int a=findd(x),b=findd(y);//将两个元素根节点记录
  if(a!=b)//如果不在一个集合（根节点不一样）
    pre[a]=b;//将其中一个根节点指向另一根节点
}
int main()
{
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
    pre[i]=i;
  for(int i=1;i<=m;i++)
  {
    int k,a,b;
    cin>>k>>a>>b;
    if(k==1)
      join(a,b);
    else
      if(findd(a)==findd(b))
    	cout<<"Y"<<endl;
      else
        cout<<"N"<<endl;
  }
  return 0;
}
//https://sm.ms/
```
好吧，当你提交这个代码的时候，可能会有一些不太理想的结果，，比如，TLE

这又是为什么呢？

大神指出，每当进行一次查询操作时，都必须从该节点到根节点遍历一次，这意味着，如果一个点距根节点要走1000条边，那每查询一次这个点所在的集合，就要把这1000条边走一次。对此，该大神还提出了一个优化，也就是——————**路径压缩**

具体就是记录根节点的值后，将这条路径上所有点的上家指向根节点，使之前要走几千步的循环现在只需要进行几次。代码实现如下（这是用循环实现的，还可用递归实现，但就不在这里阐述了）

```cpp
//优化后的findd
int findd(int x)
{
	int r=x;
	while(pre[r]!=r)
		r=pre[r];
  
  //路径压缩
	int i=x,j;//i记录当前点，j记录i的上家
	while(i!=r)//若当前点不为根节点
	{
		j=pre[i];//记录上家
		pre[i]=r;//使当前点直接指向根节点
		i=j;//当前点移动到上家
	}
  
	return r;
}
```
如果还有不懂的，可以看一下下面这张图
![667.gif](https://i.loli.net/2018/05/13/5af7ef52e218e.gif)
路径压缩前，从最右边的点查询根节点需要五次循环，

而路径压缩后，从最右边的点查询根节点只需要一次！！

那么完整代码如下

```cpp
//模板 并查集 已优化
#include <bits/stdc++.h>
using namespace std;
int pre[10001];
int findd(int x)
{
	int r=x;
	while(pre[r]!=r)
		r=pre[r];
  
  //路径压缩
	int i=x,j;//i记录当前点，j记录i的上家
	while(i!=r)//若当前点不为根节点
	{
		j=pre[i];//记录上家
		pre[i]=r;//使当前点直接指向根节点
		i=j;//当前点移动到上家
	}
  
	return r;
}
void join(int x,int y)
{
  int a=findd(x),b=findd(y);//将两个元素根节点记录
  if(a!=b)//如果不在一个集合（根节点不一样）
    pre[a]=b;//将其中一个根节点指向另一根节点
}
int main()
{
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
    pre[i]=i;
  for(int i=1;i<=m;i++)
  {
    int k,a,b;
    cin>>k>>a>>b;
    if(k==1)
      join(a,b);
    else
      if(findd(a)==findd(b))
    	cout<<"Y"<<endl;
      else
        cout<<"N"<<endl;
  }
  return 0;
}
```



---

## 作者：一玮丶 (赞：1)

在下蒟蒻一枚，随便套了个模板写了下，大家将就着看吧。

注意此题数组开大点，还要用一下路径压缩才不至于超时。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN=1000001;
int zi,xi[MAXN],yi[MAXN],Fa[MAXN];
int find(int x) 
{
    if (Fa[x] == x) return x;         // 如果 Fa[x] == x 则说明 x 是祖先，返回之
    else return Fa[x] = find(Fa[x]);         // 否则沿着 Fa[x] 向上继续找 ，这里用了一点技巧——路径压缩，不用的话会超时。
}
bool Query(int u, int v) 
{
    u = find(u), v = find(v);
    if (u == v) return true;          // 如果两个点的祖先相同，则两点联通
    Fa[u] = v;                             // 否则两点不联通，并合并两点所在的联通块
    return false;                 
}
int main()
{
    int i,m;
    cin>>i>>m;
    for(int j=1;j<=m;j++)
    {
        Fa[j]=j;
    }
    for(int j=1;j<=m;j++)
    {
        cin>>zi>>xi[j]>>yi[j];
        if(zi==1)
        {
            Query(xi[j],yi[j]);
        }
        if(zi==2)
        {
            if(find(xi[j])==find(yi[j])) cout<<"Y"<<endl;
            else cout<<"N"<<endl;
        }
    }
}
```

---

## 作者：AcceleratorX (赞：1)

并查集模板。。。有些语句十分神奇，能够一句话完成一个操作。。

如果你不会并查集算法的话，可以去网上搜一下。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,z,x,y,fa[100010];
int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);} //压缩版的getfather函数。。。加了优化（路径压缩）
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)fa[i]=i;// 初始所有点的father都是自己
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&z,&x,&y);
        if(z==1){fa[getfa(x)]=getfa(y);}//压缩，神奇
        else{
        if(getfa(x)==getfa(y)) puts("Y");//判断祖先相不相同，如果相同，则是同一集合内的，输出Y
        else puts("N");
        }
    }
    return 0;
}
```

---

## 作者：uhgariej (赞：1)

//看了大部分的题解都是摘自<<挑战...>>，代码很长。

//下面的find函数，就是并查集，不仅短好写还很好理解。


  
    
        
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef unsigned long long ULL; 
const int maxn=1e4+10;
int n,m;
int z,x,y;
int p[maxn];
int find(int num)    //union-find set并查集，p数组为实际存储图的结构 
{
    return p[num]==num?num:p[num]=find(p[num]);    
} 
int main()
{
//    freopen("data.in","r",stdin);
//    freopen("data.out","w",stdout);
    cin.sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;++i)
        p[i]=i;
    for(int i=1;i<=m;++i){
        cin>>z>>x>>y;
        int a=find(x),b=find(y);
        if(z==1)
            p[a]=b;
        if(z==2){
            if(a==b)
                cout<<"Y"<<endl;
            else 
                cout<<"N"<<endl;
        } 
    }
//    cout<<"Time used = "<<static_cast<double>(clock())/(CLOCKS_PER_SEC)<<"s"<<endl;
    return 0;
}
```

---

## 作者：wwq123 (赞：1)

```cpp
//代码是根据日本人挑战程序竞赛得到的
#include<iostream>
using namespace std;
const int MAXN=10000+2;
int par[MAXN],rank[MAXN];
int n,m;
//初始化n个元素
void init(int n){
    for(int i=0;i<n;i++){
        par[i]=i;
        rank[i]=0;
    }
}
//查询树的根
int find(int x){
    if(par[x]==x) return x;
    else return par[x]=find(par[x]);
}
//合并x和y所属的集合
void unite(int x,int y){
    x=find(x);
    y=find(y);
    if(x==y) return;
    if(rank[x]<rank[y]) par[x]=y;//如果两棵树深度不同，则将较短的并到较长的上
    else{
        //如果深度相同则不用处理，反之则需要进行合并
        par[y]=x;
        if(rank[y]==rank[x]) rank[x]++;
    }
}
int main(){
    int a,b,c;
    cin>>n>>m;
    for(int i=0;i<=n;i++) init(i)//进行预处理;
    for(int i=0;i<m;i++){
        cin>>a>>b>>c;
        //开始合并和查找
        if(a==1) unite(b,c);
        else{
            if(find(b)==find(c)) cout<<"Y"<<endl;
            else cout<<"N"<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Lyrics (赞：1)

可以参考博客这一篇：
http://www.cnblogs.com/ACworker/p/7228920.html

图论中的一个较经常考察的点：并查集。就是需要一个unionn(x,y)的合并问题和一个find(x)找父亲问题。

并查集首先就是先把自己指向自己做自己的父亲，等到后面找别人来做自己的父亲，一层一层上去，但是此题要注意的是路径压缩问题，路径没压缩的话就会3个点超时。

我们来平民化一下并查集的概念（很早以前从一个博客上看到的，我用自己的语言组织了一下）：

【平民化概念】：

在金庸小说的世界里，门派很多，经常会发生一些争斗，而且一般来说一个大的势力首先都需要自己出头来做老大，所以这个时候你自己的这个门派的老大就是你自己，即father[you]=you

后来，在你冒险的过程中你开始结识了一群很牛逼的好友，你觉得应该把他们拉到自己的门下，那么这个时候你就劝说他们把他们的门派老大指向你，意思就是说你是他们的老大，即father[别人]=you

但是你只是认识了这些比你低一级别的属下，你属下的属下和他属下的属下都互相不认识啊，这个时候就很容易起争端还不知道是自己人，互相打来打去（怎么这么傻），万一有一天在小树林里碰面，A、B二人都不知道对方是敌是友，如果要一级一级上报上去，显然是可以做到的，但是其中所耗费的时间必然是我们所比较不愿意接受的，所以我们希望我们属下的属下，他的老板就是我，意思就是说他可以直接认识我，并且接触到我，这样的话两人看到，就可能说：“在下是饕餮的属下”，“诶，我是饕餮他属下XX的属下，我们两个是朋友”然后两个人就手拉手一起走上人生巅峰了。。。。。这里的代码转换一下即：判断一下是敌是友（int x=find(A),y=find(B)解释：x是A的顶头上司，y是B的顶头上司)如果不认识，那么认识一个朋友就是一个保障嘛，那么这个时候：father[x]=y，但是你会发现如果这样，一层一层地上报岂不是很麻烦，那么你就可以直接father[A]=y就可以啦，这就是一个非常简单的路径压缩啦

在这么一个有趣的背景下，我们其实已经把并查集的意思给讲完啦，希望大家能够理解！！

CODE：（可以结合上面的平民化小概念来一起理解哦）


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,z,x,y;
int father[10002];
int find(int i){
    if(i==father[i])return i;
    while(i!=father[i])i=father[i];
    return father[i];
}
void unionn(int i,int j){
    int r1=find(i),r2=find(j);
    if(r1==r2)return;
    father[r2]=r1;//这句可以考虑不要
    father[j]=r1;//这句一定要加上去不然没路径压缩会超时（就是这一句忘了加导致TLE3个点），顺便再说一句，并查集的路径压缩可以达到几乎为O（1）的效率，非常好用！！！用路径压缩提高效率是很多OIer会做的事情，当然如果是那个什么秩的就是考虑树高的会相对比较麻烦
    return;//所以一般用路径压缩可以解决大多的并查集问题
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)    father[i]=i;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&z,&x,&y);
        switch(z){
            case 1:{
                unionn(x,y);
                break;
            }
            case 2:{
                if(find(x)==find(y))printf("Y\n");
                    else printf("N\n");
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：Hatsune_Miku (赞：1)

这种数据结构题还是封装起来用比较舒服（强迫症）。

没什么好说的，就是带路径压缩的并查集（不路径压缩会TLE）。

常用于Kruskal算法等。

```cpp
#include<cstdio>
using namespace std;

#define maxn 10000

struct UnionFindSet
{
    int x,y,v;
    int fat[maxn];
    UnionFindSet()
    {
        for(int i=0;i<maxn;i++)
            fat[i]=i;
        x=y=v=0;
    }
    inline int father(int x)
    {
        if(fat[x]!=x)
            fat[x]=father(fat[x]);
        return fat[x];
    }
    inline void unionn(int x,int y)
    {
        int fa=father(x);
        int fb=father(y);
        if(fa!=fb)
            fat[fa]=fb;
    }
};

UnionFindSet s;

int n,m,z,x,y;

int main()
{
    scanf("%d%d",&n,&m);
    while(m--)
    {
        scanf("%d%d%d",&z,&x,&y);
        if(z==1)
            s.unionn(x,y);
        else if(z==2)
        {
            if(s.father(x)!=s.father(y))
                printf("N\n");
            else
                printf("Y\n");
        }
    }
    return 0;
}

```

---

## 作者：character (赞：1)

#【手动头像】第一次发题解想想有点小激动x，感觉还是要提高自己的姿势水平

比较简单的模板，理解了意思就很好写了。

并查集有一个好，越并越好查，这个主要通过路径压缩【\_所以之前看到有人写的完全没有路径压缩，这样的话并查集并没有太大意义（？）\_】

这里通过迷の认大哥来解释√

```cpp
#include<iostream>
using namespace std;
const int MAXN = 10000+20;
int fa[MAXN],ra[MAXN];//father和rank,记录大哥是谁和小弟个数 
int N,M;
void init(){//输入 
    cin>>N>>M;
    for(int i=1;i<=N;i++)//初始化 ，每个人都是独立的个体，都是有尊严（？）的人 
        fa[i]=i;
}
int fi(int x){//找到x的大哥 
    if(fa[x]==x) return x;//如果自己是自己的大哥，当然自己就是这个组织的老大 
    else return fa[x]=fi(fa[x]);
    //把大哥的大哥啦，大哥的大哥的大哥什么的都变成直属的大哥（这样就避免了你找一个人的时候经过太多的层数 
}
void bin(int x,int y){//x和y中将产生一个大哥，另外一个就是儿子 
    int xx=fi(x),yy=fi(y);//分别找到x和y的大哥（大哥比较讲义气都亲自上阵 
    if(ra[xx]>=ra[yy]){//谁成为大哥果然取决于小弟的个数嗯，显然这里x的阵势比较大 
        fa[yy]=xx;//于是xx就是yy的爸爸了x 
        ++ra[xx];
    }else{//这个次元yy赢了【嗯，yy 
        fa[xx]=yy;
        ++ra[yy];
    }
}
void sol(){
    for(int z=0;z<M;z++){
        int ord,x,y;//命令和x，y 
        cin>>ord>>x>>y;
        if(ord==1) bin(x,y);
        else if(fi(x)==fi(y)) cout<<'Y'<<endl;//如果是同一个组织的就，，就同一个组织嘛 
             else cout<<'N'<<endl;
    }
}
int main(){
    init();
    sol();
    return 0;
}
```
尽量的好理解了0 0我一个妹子写这么奇怪的背景真的好吗


---

## 作者：尘小七 (赞：1)

在开始讲之前，先发两张图片，那位前辈当初在讲这个课题的时候真的讲的十分的好，并查集基本上是一下就懂了。

##接下来一段话就是这位大神写的，想看的话可以去这个链接：http://blog.csdn.net/dellaserss/article/details/7724401/

这个链接也不是我的链接，只是觉得这篇转发的博文确实值得一看。

【转】

为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？

我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。

但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。

![Luogu](http://ognp9z0fj.bkt.clouddn.com/BCJ.jpg)

转这个，只是为了让所有入门的OIer对并查集有一个全面的了解。


话说到底，这道题还有一个问题，就是最后三个点，如果是全裸的并查集，会TLE，所以我们要重新思考如何才能优化并查集。

那么，就看这幅图：

![Luogu](http://ognp9z0fj.bkt.clouddn.com/BCJ2.jpg)

这幅图看懂后，就可以清晰的了解到什么叫做所谓的路径压缩。。在（find函数中）一次一次地询问自己的上级是谁，效率非常低，但是当我们在询问到了自己的上级过后就把自己的上级改到最高的地方去，就是路径压缩了。这也是tarjan的基础。


#分割线++++++++以下是代码。


```cpp
#include <cstdio>
//并查集。 
using namespace std;
int n,m;
int father[10000]; //上级、父亲。。。一切表示父辈的词语都可以描述
int sum[10000];//当前节点所属下级有多少个，在路径压缩的时候可以省步数。
int find(int x){
        return x == father[x]? x:find(father[x]);
}//find（找自己的父亲，其实还有一种while的方法，可以去各大博文上去看一看。
void unite(int x,int y) {
    x=find(x);
    y=find(y);
    if(x==y) return;  //如果本来就来一个并查集内就不管了
    if(sum[x]<sum[y]) father[x] = y; //如果x的sum值更少，那么合并x到y中的代价就更小。
    else {
        father[y] = x;
        if(sum[x] == sum[y]) sum[x]++;
    }
```
}//合并两个并查集
```cpp
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) {
        father[i] = i;
        sum[i] = 1;
```
}//初始化

```cpp
    for(int _=1;_<=m;_++) {
        int z,a,b;
        scanf("%d%d%d",&z,&a,&b);
        if(z==2)  if (find(a) == find(b)) printf("Y\n");  else printf("N\n");
        if(z==1)  unite(a,b);
    }
    return 0;
} 
```
#OIers RP++


---

## 作者：lrx88 (赞：1)

这是一个简单的并查集的题目，我看了一下

题解里面并没有简单的路径压缩的，如果没有

路径压缩 就会超时三个点

哥们儿 要路径压缩呀

废话不多说直接上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N = 10005;
int fa[N];
int getf(int x)
{
    if(fa[x]==x)return x;
    else return fa[x]=getf(fa[x]);
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int z,x,y;
    for(int i=1;i<=n;i++)fa[i]=i;
    while(m--)
    {
        cin>>z>>x>>y;
        if(z==1)
        {
            int x1=getf(x);
            int y1=getf(y);
            if(getf(x)!=getf(y))
            fa[x1]=y1;
        }
        if(z==2)
        {
            if(getf(x)!=getf(y))cout<<"N"<<endl;
            else cout<<"Y"<<endl;
        }
    }
}
```

---

## 作者：little_gift (赞：1)

#刚学并查集，觉得也不难，就是要理解理解。#

###每个集合都有一个自己的标识，这点较难理解#

```cpp
var
  n,m,i,x,y,z:longint;
  a:array[1..10000] of longint; //存放每个节点集合的标识 a[x]=x的上一级
function getf(x:longint):longint; //求x所在集合的标识
  begin
    if a[x]=x then //如果x已经是标识了，直接返回x
      exit(x);
    a[x]:=getf(a[x]); //不是的话就返回x上一级的标识
    exit(a[x]);
  end;
procedure merge(x,y:longint);
  begin
    a[getf(x)]:=getf(y); //将x的标识链接到y的标识，完成两个集合的合并
  end;
begin
  readln(n,m);
  for i:=1 to n do
    a[i]:=i; //初始化，每个节点所在的集合都是他自身
  for i:=1 to m do
    begin
      readln(z,x,y);
      if z=1 then
        merge(x,y)
               else
        if getf(x)=getf(y) then //如果他们的标识相同，说明他们在同一个集合。
          writeln('Y')
                             else
          writeln('N');
    end;
end.
```

---

## 作者：Sci_M3 (赞：1)

按秩合并版本

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 10000 + 10;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}

int fa[MAXN], rank[MAXN];
int n, m;

inline void init() { for(int i = 1; i <= n; ++i) fa[i] = i, rank[i] = 0; }
inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
inline bool same(int x, int y) { return find(x) == find(y); }
inline void unite(int x, int y) {
    x = find(x), y = find(y);
    if(x == y) return;
    if(rank[x] < rank[y]) fa[x] = y;
    else {
        fa[y] = x;
        if(rank[x] == rank[y]) rank[x]++;
    }
}

int main() {
    n = read(), m = read();
    init();
    for(int i = 1, opt, u, v; i <= m; ++i) {
        opt = read(), u = read(), v = read();
        if(opt == 1) unite(u, v);
        else if(opt == 2) {
            if(!same(u, v)) puts("N");
            else puts("Y");
        }
    }
    return 0;
}
```

---

## 作者：ghj1222 (赞：1)

\_新题目，我来写写题解\_

这不是并查集裸题么...那么我就在这里讲讲并查集好了

什么是并查集？

~~并查集，从字面意思上说，有三个层面，第一个就是并，第二个就是查，第三个就是集。~~**此话当屁处理**

说白了就是可以**快速地**合并与查找的集合。

并查集的功能：

1.把两个元素所在的集合合并

2.检查两个元素是否在同一个集合

好了，说正事儿：

我们开一个f数组，f[i]就表示i的爹，一开始元素i的爹是自己。在同一个集合的每一个元素，它的祖宗是一样的。注意是祖宗，不是爹。如果一个元素的爹自己，那么这个元素就是祖宗。这个“祖宗”是很重要的，我们用一个祖宗代表一个集合。

- 如何找到一个元素的祖宗呢？我们就要写一个递归找爹，直到找到一个元素的爹是自己的元素为止。

这个函数在下面。我看别人的代码太长，于是发(chao)明(xi)了一个?:表达式的递归找爹，详情见下

- 如何判断两个元素是否在一个集合呢？我们只需要判断这两个元素是否是一个祖宗。也就是**getf(x)==getf(y)**。

- 如何合并两个元素所在的结合呢？首先，这两个元素肯定是在不同的集合，我们要想要合并，只需要把其中一个集合的祖宗的爹改为另一个集合的祖宗。可以这样：**f[getf(x)]=getf(y);**就把x所在集合的祖宗改为y所在集合的祖宗了

- 另外还有状态压缩：

 ![](https://cdn.luogu.com.cn/upload/pic/2744.png) 

如何状态压缩？在递归回溯的过程中，只需要把找到的祖宗作为路上所有节点的爹就行了。

如果没有状态压缩，在递归找爹中，就是**return f[x]==x?x:getf(f[x]);**了，请自己找区别

C++代码：(十分233)

```cpp
#include <iostream>
using namespace std;
int f[10001],n,m,a,b,c;
int getf(int x)
{
    return f[x]==x?x:f[x]=getf(f[x]);
}
int main()
{
    cin >> n >> m;
    while(n--)
        f[n]=n;
    while(m--)
    {
        cin >> a >> b >> c;
        if(a==1)f[getf(b)]=getf(c);
        if(a==2)cout << (getf(b)==getf(c)?'Y':'N') << endl;
    }
    return 0;
}
```

---

## 作者：约修亚_RK (赞：1)

并查集嘛...我们需要一个parent[n]来储存点的从属关系。

初始化操作：

对于每个点，parent[k] = k。

查询操作：

findSet(k) - 返回点k所在集合编号（当parent[k] == k时，返回k；否则，返回**parent[k] =** findSet(parent[k])。加粗部分为优化（路径压缩）。

合并操作：

对于点a和b，只要让parent[findSet(a)] = findSet(b)就可以了。


就是这么一道模板题。还有一个优化，启发式合并，不过并没有什么卯月，在此不表。


```cpp
/* P3367
 * Au: SJoshua
 */
#include <cstdio>

int fa[10001];

int findSet(int n) {
    return fa[n] == n ? n : fa[n] = findSet(fa[n]); 
} 

int main(void) {
    int n, m, z, x, y;
    scanf("%d %d", &n, &m);
    for (int k = 1; k <= n; k++) {
        fa[k] = k;
    }
    while (m--) {
        scanf("%d %d %d", &z, &x, &y);
        if (z == 1) {
            fa[findSet(x)] = findSet(y);
        } else if (z == 2) {
            printf(findSet(x) == findSet(y) ? "Y\n" : "N\n");
        }
    }
    return 0;
}
```

---

## 作者：江海寄余生 (赞：1)

其实就是一个并查集嘛，题目明明白白

以下给尚不熟悉并查集的一份标程








```cpp
var
  fa:array[1..10000] of longint;
  i,j,k,n,m,l,r,x,y,z:longint;
function find(a:longint):longint;  //找并查集的代表元素+压缩路径
begin
  if fa[a]=a then find:=a else find:=find(fa[a]);
  fa[a]:=fa[fa[a]];
end;
procedure merge(a,b:longint);//合并两个集合
begin
  fa[b]:=a;
end;
procedure solve1;  //处理x=1的情况
var
  c,d,e:longint;
begin
  c:=find(y);
  d:=find(z);
  merge(c,d);
end;
procedure solve2;//处理x=2的情况
var
  c,d:longint;
begin
  c:=find(y);
  d:=find(z);
  if c=d then writeln('Y') else writeln('N');
end;
begin
  read(n,m);
  for i:=1 to n do
    fa[i]:=i;
  for i:=1 to m do
  begin
    read(x,y,z);
    if x=1 then solve1 else solve2;
  end;
end.

```

---

## 作者：Loi_bibo (赞：1)

/\*emmmmm第二篇题解，之前那篇不知为啥重了

没过QWQ这次写得比上次还详细望采纳哈哈~~

还是最好不要CTRL+C CTRL+V自己好好看看\*/

```cpp
#include<cstdio>
#define maxn 500005//用const int 更稳一些 
int m,n,i,q;
int father[maxn],x[maxn],y[maxn],z[maxn],r1[maxn],r2[maxn];//好像很麻烦？输出格式所逼，我也没办法QWQ 
/*//用非递归的实现
int find(int x)                  
{
　　while(father[x]!=x) x=father[x];
　　return x;
}
```
\*/

```cpp
int find(int x) //用递归的实现                 
{
    if(father[x]==x) return x;//如果他是他自己的爹233 
    if (father[x]!=x) father[x]=find(father[x]); //路径压缩（如果不是自己的爹） 
    return father[x];//返回他父亲//qwq 上一句条件最好不要合起来写 
}
void unionn(int r1,int r2)
{
    int f1=find(r1),f2=find(r2); 
    father[f1]=f2;//找爸爸
}
int main()
{
    scanf("%d%d",&n,&m);//输入不解释 
    for(i=1;i<=n;i++)
        father[i]=i;//建立新的集合，其仅有的成员是i
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&z[i],&x[i],&y[i]);// 输入不解释 
        r1[i]=find(x[i]);//每输入一个就合并一次 
        r2[i]=find(y[i]);
    }
    for(i=1;i<=m;i++)//好像很麻烦？输出格式所逼，我也没办法QWQ （最好不要合起来写 ） 
    {
        if(z[i]==1) if (r1[i]!=r2[i])unionn(r1[i],r2[i]);//qwq 条件最好不要合起来写 
        if(z[i]==2) if(find(x[i])==find(y[i])) printf("Y\n");
        else printf("N\n");
    }
    return 0;
}
```

---

## 作者：Codingme (赞：1)

C++版的不用三元？：语句，用了两个函数，本来写在主函数里面我提取出来了，便于读懂 另外 我转载了一个并查集详解博客 通俗易懂 安利链接：http://blog.sina.com.cn/s/blog\_150a48b7b0102wg9m.html


    

```cpp
#include<stdio.h>
#include<algorithm>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
int pre[10005];//pre【某个数据】=”指向的上级“
int find(int a)
{
    int z=a;
    while(pre[z]!=z)
      z=pre[z];//找到祖先 
    int i=a,camp;  
    while(pre[i]!=z)  //优化 对于每一个下级 使他们直接指向祖先 
    {                 //以后便利时只需O（1）复杂度 
        camp=pre[i];  
        pre[i]=z;  
        i=camp;  
    }  
    return z;
}
void join(int x,int y)
{
    int a=find(x),b=find(y);
    if(a!=b)
      pre[a]=b;    
```
}//合并x，y子集的函数

    
```cpp
int main()
{
    int n,m,z,x,y;
    cin>>n>>m;
    for(int i=1;i<=10005;i++)
      pre[i]=i;//预处理 
    while(m--)
    {
        cin>>z>>x>>y;
        if(z==1)
          join(x,y);//z等于1 合并x，y的子集 
        else
        {
          if(find(x)==find(y)) //x,y共同的祖先一不一样？ 
            cout<<"Y\n";
          else  
            cout<<"N\n";
        }
    } 
    return 0;
}
```

---

## 作者：黄柠檬11 (赞：0)

## 很好的一道题
# 做完建议去做[P3366 【模板】最小生成树](https://www.luogu.org/problemnew/show/P3366)
# 上代码(代码里面有注释)
```
#include <iostream>
using namespace std;
int fa[100000], siz[100000];//fa是找集合中的父亲 , siz是集合的长度(为了优化) 
int getfa(int x)//找代表
{
	if ( fa[x] == x )/*如果代表是自己，就返回自己*/ return x;
	return  fa[x]/*路径优化(记忆化搜索)*/ = getfa(fa[x]);//如果自己不是代表那么就接着找代表
}
void merge( int x, int y )//合并x集合和y集合 
{
	int s1 = getfa(x);//s1是x的代表 
	int s2 = getfa(y);//s2是y的代表 
	if ( s1 == s2 ) return ;//如果s1和s2是一样的，说明他们已经在同一个集合里了 
	if ( siz[s1] > siz[s2] )//也是优化，如果s1所在的集合的长度比s2长
	{
		fa[s2] = s1;//让s2所在的集合合并s1所在的集合合并 
		siz[s1] += siz[s2];//s1所在的集合长度要加上s2所在的集合的长度 
	} 
	else//反之 
	{
		fa[s1] = s2;//让s1所在的集合合并s2所在的集合合并 
		siz[s2] += siz[s1];//s2所在的集合长度要加上s1所在的集合的长度 
	}
}
void merge2(int x, int y)//合并 +输出 Y 或 N; 
{
	int s1 = getfa(x);//和merge函数一样 
	int s2 = getfa(y);//和merge函数一样 
	if ( s1 == s2 )//如果在同一个集合里 
	{
		cout << "Y" << endl;return ;//输出"Y"; 
	} 
		cout << "N" << endl;return ;//输出"N"; 
}
int main()
{
	int m, n;
	int x1, y1, z1;
	cin >> n >> m;//输入n, m; 
	for ( int i = 1; i <= n; i++ )
	{
		fa[i] = i;//清成原始状态 
		siz[i] = 1;
	}
	for ( int i = 1; i <= m; i++ )
	{
		cin >> z1 >>  x1 >> y1;//题目中的zi， xi， yi 
		if ( z1 == 1 )//如果zi是1 
		{
			merge(x1, y1);//按题目所说，合并两个集合 
		}
		if( z1 == 2 )//如果zi是2
		{
			merge2(x1, y1);//按题目所说，先判断Xi与Yi是否在同一集合内，是的话输出Y 否则话输出N
		}
	}
	return 0;//结束 
}

```

# 这里面存在了两个优化
# 1.

```
return  fa[x]/*路径优化(记忆化搜索)*/ = getfa(fa[x]);//如果自己不是代表那么就接着找代表
```


# 2.
```
if ( siz[s1] > siz[s2] )//也是优化，如果s1所在的集合的长度比s2长
	{
		fa[s2] = s1;//让s2所在的集合合并s1所在的集合合并 
		siz[s1] += siz[s2];//s1所在的集合长度要加上s2所在的集合的长度 
	} 
	else//反之 
	{
		fa[s1] = s2;//让s1所在的集合合并s2所在的集合合并 
		siz[s2] += siz[s1];//s2所在的集合长度要加上s1所在的集合的长度 
	}
```


```
return fa[x] = getfa(fa[x]);一定要加要不然会过不去~~但不知道为什么~~
```
后面的可加可不加

但是fa[s2] = s1, fa[s1] = s2一定要加哦！

还有不懂的地方可以私信我
[黄柠檬11](https://www.luogu.org/space/show?uid=95660)


---

## 作者：跪下叫哥 (赞：0)

# 并查集
因为此题是模板，所以我给你们讲一下**并查集**的性质与实现。

信息学竞赛中有很多有关集合相关的问题，比如说有m个集合，每个集合有n个元素，要你判断a、b是否在同一个集合？
如果使用搜索法，那么在O(mn)时间内能够得到结果。
如果m、n都很大时，时间效率非常差；而且对于需要动态地合并两个不相交的集合时，时间效率更差，易超时。
对于这种情况，可以用并查集解决。


**并查集**：顾名思义，就是专门处理一些不相交集合的合并和在集合中快速地查询等问题。


并查集可以用数组、链表、树型结构来实现，其中，最适用、最易实现的是树型结构。

树型数据结构有其独特性，一棵树可以看做一个完整的集合，该树中的结点代表集合中的元素。

 - 要查询时，只需要查询树根是否一样；
 - 要合并时，只需将两棵树的树根之间连一条边，合并成一棵树。

并查集就是利用树的这一良好特性，有效的实现了合并与查询操作。


## 并查集的理解与实现

并查集的实现分为三个基本操作：
 - 初始化
 - 查询
 - 合并


### 初始化

如果刚开始的时候,每个元素的所在的集体都是自己本身,那么我们用树中的父亲表示法,认为每个点的父亲就是自己本身.

[![bcj1.png](https://i.postimg.cc/Px6MxSPd/bcj1.png)](https://postimg.cc/wymN4cXr)

```c
int fa[MAXN]; //父亲表示法存树
for(i=1;i<=n;i++)
    fa[i] = i;
```

### 查询

如果元素已经行成集合,那我们如何证明两个元素在同一个集合呢?如下图,如何证明点`2`,`3`在同一个集合,点`2`,`5`不在同一个合呢?

假如我们有一个`find(i)`操作,它能找到点`i`最远祖先(也就是树的根),那么如果`find(i) == find(j)`,证明点`i`,`j`在同一个集合,反之,不在同一个集合.

[![bcj2.png](https://i.postimg.cc/7hfnTS20/bcj2.png)](https://postimg.cc/PvnwgpK5)

```c
int find(int x){
    if( fa[x] == x) return x;
    return find(fa[x]);
}
```

**查询两个元素是不是同一个集合时**

```c
bool query(int x,int y){
    if( find(x) == find(y))
        return true;
    return false;
}

```

### 合并

当某两个元素u、v不在同一棵树中，需要合并时，方法为分别找到u、v最远的祖先结点编号，即u、v各所在树的树根，在树根之间连一条边，让u的树根指向v的树根，将两棵树合并成一棵树。

[![bcj3.png](https://i.postimg.cc/9Q3YrRFw/bcj3.png)](https://postimg.cc/ykPZGNR7)

```c
void union(int x,int y){
    int rx = find(x);
    int ry = find(y);
    if( rx != ry)
        fa[ry] = rx;
}
```

## 优化1:路径压缩

如果一个元素的位置很深,路径很长(如下图点5),那么每次对这个点进行`find`操作的时候,都要递归多次,能不能查询一次后,直接把这个点指向根,那么下一次查询的时候就不用递归多次了.

**路径压缩:**在`find`操作时,把路径上的所有点都指向根


[![bcj4.png](https://i.postimg.cc/sDGJj9yR/bcj4.png)](https://postimg.cc/crZ3T3rD)

```c
int find( int x){
    if( fa[x] == x) return x;
    fa[x] = find(fa[x]);
    return fa[x];
}
```

## 优化2:非递归实现

核心想法: 走两遍,选找到根,然后第二遍走的时候,把路径上的所有点都指向root点.
```c
//查找并路径压缩 非递归
int find(int x){
    int t =x;
    while(fa[t] != t) //不停的往上走
        t=fa[t];
    int i = x,j;//路径压缩，再走一便路程，把走过的点都指向根
    while(i != t){
        j= fa[i];
        fa[i] = t; // 把这个点指向根
        i = j;
    }
    return t;
}
```

## 总结

从概念说：并查集通过一个**一维数组**来实现，本质上是维护一个**森林**。刚开始的时候，森林里的每一个结点都是一个**集合**（也就是只有一个结点的树），之后根据题意，逐渐将一个个集合**合并**（也就是合并成一棵大树）。之后寻找时不断查找父节点，当查找到父结点为本身的结点时，这个结点就是祖宗结点。合并则是寻找这两个结点的祖宗结点，如果这两个结点不相同，则将其中右边的集合作为左边集合的子集（即靠左，靠右也是同一原理）。

# 引入正题

**代码**

```c
#include <cstdio>
#include <cstring>

#define maxn 10000+5

int n,m;
int fa[maxn];


//查询+路径压缩
int find(int x){
    if( x == fa[x])
        return x;
    fa[x] = find(fa[x]);
    return fa[x];
}

//合并
void un(int x,int y){
    int tx = find(x);
    int ty = find(y);

    if( tx != ty)
        fa[ty] = tx;
}

int main(){
    scanf("%d%d",&n,&m);
    int i,j,k;

    //初始化
    for (i=1;i<=n;i++){
        fa[i] = i;
    }
    int t1,t2,t3;
    for (i=1;i<=m;i++){
        scanf("%d%d%d",&t1,&t2,&t3);
        if( t1 == 1){ //合并
            un(t2,t3);
        }
        else{
            if( find(t2) == find(t3))
                printf("Y\n");
            else
                printf("N\n");
        }
    }
    return 0;
}
```
# 附录
## 带权并查集

不仅要知道两个点之间是否有关系，还要知道两个点之间有什么关系

比如：[luogu P1196  NOI2002 银河英雄传说](https://www.luogu.org/problemnew/show/P1196)

## 做完此题，你可以做这些：
### 练习题目:

 - luogu P3984 高兴的津津 (用并查集来做)
 - luogu P1525关钾罪犯(一个不错的题目)
 - luogu P1551 亲戚
 - luogu P1196 [NOI2002]银河英雄传说
 - luogu P1892 [BOI2003]团伙
 - luogu P2256 一中校运会之百米跑
 - luogu P1547 Out of Hay USACO
 - luogu P1111 修复公路
 - luogu P2820 局域网
 - luogu P1546 最短网络
 - luogu P2078 朋友
 - luogu P2024 食物链(NOI2001)
 - luogu P2330 [SCOI2005]繁忙的都市


---

## 作者：Aehnuwx (赞：0)

$emmm$，终于可以写一篇$luogu$上的模板题的题解了。

这道题需要我们写并查集的两个操作：合并和查询。

首先$copy$一下某度上面对“并查集”这一名词的解释：
[并查集](https://baike.baidu.com/item/%E5%B9%B6%E6%9F%A5%E9%9B%86/9388442?fr=aladdin)

先举个例子吧：

有$A$和$B$这两个犯罪团伙。其中每一个犯罪团伙都有一个老大，而团伙的其他人都只认老大，一旦有两个人相遇，如果他们的老大不同，那么他们就要打一架。

这个例子的模型其实就是和并查集相同的。并查集就是一个树形的数据结构，它的根节点我们就可以看作是犯罪团伙的老大，而其他节点就是其他人。

我们可以定义一个数组$pre[x]$来表示$x$的老大。假设两个人$a$和$b$相遇了，那么只要$pre[a]$和$pre[b]$不相同，那么他们就不是一个团伙的，就要打一架。

这道模板题同样如此：当$Zi=1$，就相当于把$Xi$和$Yi$两个人分到一个犯罪团伙里去了，也就是做一次合并操作。如果$Zi=2$，就相当于判断$Xi$和$Yi$是否是一个犯罪团伙的，就是做一次查询操作。

需要注意，最开始时，需要初始化一下。

```cpp
for(int i = 1; i <= n; i ++)
	pre[i] = i;//开始时老大都是自己
```

$code$

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;

const int maxN = 1e4 + 10;//1e4=10000
#define il inline//先宏定义一下，方便点
il int find(int);//查询操作
il void join(int, int);//合并操作
int pre[maxN];//每个的老大
int main() {
	int N, M;
	scanf("%d%d", &N, &M);
	for(int i = 1; i <= N; i ++)
		pre[i] = i; //初始化
	for(int i = 1; i <= M; i ++) {
		int Z, X, Y;
		scanf("%d%d%d", &Z, &X, &Y);
		if(Z == 1) join(X, Y);//如果Z=1，合并X和Y
		if(Z == 2)
			if(find(X) == find(Y))//如果X和Y的老大相同
				printf("Y\n");//输出Y
			else printf("N\n");//反则输出N
	}
	return 0;
}
il int find(int x) {
	int r = x;
	while(r != pre[r])
		r = pre[r];//一旦还没有找到老大就继续找
	int p;
	while(x != r) {
		p = pre[x];
		pre[x] = r;
		x = p;
	}//路径压缩，这是必要的
	return r;//返回老大
}
il void join(int x, int y) {
	int fx = find(x);//将祖先找到
	int fy = find(y);//同上
	if(fx != fy) pre[fx] = fy;//一旦祖先不同，就合并起来
}
```

---

## 作者：木木！ (赞：0)

# 蒟蒻的第二篇题解
~~上一篇是A+B Problem Without +并且没过审~~

一般来说递归函数是个坎，那么我就从递归的正确性角度帮助理解一下递归

```cpp
#include <cstdio>
using namespace std;
int set[10005];
int n;

void init()
{
	for(int i=1;i<=n;++i)
	{
		set[i] = i;
	}
}

inline int getfa(int x)
{
	return x-set[x]?set[x]=getfa(set[x]):x;//在a和b都是int的情况下if(a-b)等价于if(a==b)
    //对于set[x]==x的情况，即x为根，显然正确
    //对于其他情况，若对于x的父节点正确，则对于x也正确
    //因此这个函数永远正确
}

inline int unite(int a,int b) //如果返回void就编译不过
{
	return set[getfa(a)] = getfa(b);
}

inline int united(int a,int b)
{
	return getfa(a)==getfa(b);
}

inline int getint(void)
{
	int tmp;
	scanf("%d",&tmp);
	return tmp;
}

int main()
{
	int m;
	scanf("%d %d",&n,&m);
	init();
	for(int i=1;i<=m;++i)
	{
		getint()-1?printf("%s\n",united(getint(),getint())?"Y":"N"):unite(getint(),getint()); //史上最短
	}
	return 0;
}
```

---

## 作者：lvjiyuan (赞：0)

并查集的模板题，函数传了个参数z，所以简单了点。思路各位大神讲的很详细了，我就不狗尾续貂了；代码写的不好看，大家见谅吧；



```cpp
#include<bits/stdc++.h>
using namespace std;
const int nu=500100;
struct node{
    int u,v,w;
}e[nu];
int f[nu],p,m,dis,k=0;
int getf(int x)
{
    if(x==f[x])return x;
    else return f[x]=getf(f[x]);
}
int hebing(int z,int u,int v){
    int t1=getf(u);
    int t2=getf(v);
    if(t1!=t2){
    if(z==1)f[t2]=t1;
    return 0;
    }
    return 1;
}
int main()
{
    cin>>p>>m;
    int z;
    for(int i=1;i<=p;i++)f[i]=i;
    for(int i=1;i<=m;i++){
    cin>>z>>e[i].u>>e[i].v;
    if(z==2)
    {
    if(hebing(z,e[i].u,e[i].v))cout<<"Y"<<endl;
    else cout<<"N"<<endl;
    }
    if(z==1){
        hebing(z,e[i].u,e[i].v);
    }
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

#蒟蒻的题解

思路:一个数组存储并查集中的所有元素，以此来模拟链表，执行union(a,b)操作时，将a所属集合中每一项的root改为b.root，将a集合最后一项的next改为b.root，b最后一项的next改为a原先的root，完成合并

```cpp
#include <cstdio>

using std::printf;
using std::scanf;

const int LARGE=10001;

struct Element{
    int    value;
    int next;
    int root;
    int length;
    int tail;
    
    Element(int value,int next,int root,int length,int tail){
        this->value=value;
        this->next=next;
        this->root=root;
        this->length=length;
        this->tail=tail;
    }
    Element(){
        value=0;
        next=0;
        root=0;
        length=0;
        tail=0;
    }
};

Element eles[LARGE];
int num=0;
int indexes[LARGE]={0};
inline bool query(int a,int b){
    return eles[a].root==eles[b].root;
}
//避免与cpp的关键字union重复
void union_element(int a,int b){
    Element e1=eles[a];
    Element e2=eles[b];
    if(e1.root==e2.root) return;
    int length1=eles[e1.root].length;
    int length2=eles[e2.root].length;
    int sumLength=length1+length2;
    
    /*
    把a集合所有项的root改为b集合的root
    a最后一项的next改为b的root
    b最后一项的next改为a原先的root 
    b的root的tail改为a的最后一项 
    */
       //出于偷懒区分length1与length2的大小情况
    if(true/*length1<    length2*/){
        int oldRoot1=e1.root;
        for(int p=oldRoot1;eles[p].root==oldRoot1;p=eles[p].next)
        {
            eles[p].root=e2.root;
        }
        eles[eles[oldRoot1].tail].next=e2.root;
        eles[eles[e2.root].tail].next=oldRoot1;
        eles[e2.root].tail=eles[oldRoot1].tail;
        eles[e2.root].length=sumLength;
    }
    
}
//调试用，自行忽略
void menu(){
    char chr;
    int a,b;
    scanf("%c%d%d",&chr,&a,&b);
    switch(chr){

        case 'p':{
            union_element(a,b);
            
            break;
        }
        case 'q':{
            printf("%d\n",query(a,b));
            break;
        }
        
        }
}

int main(){
    int m,n;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        eles[++num]=Element(num,num,num,1,num);
    }
for(int i=1;i<=m;i++){
    int opt,a,b;
    scanf("%d%d%d",&opt,&a,&b);
    if(opt==1){
        union_element(a,b);
        
    }else
    {
        int result=query(a,b);
        printf(result?"Y\n":"N\n");
    }
}
}
```

---

## 作者：Hydra_ (赞：0)

## 分析 ##

纯纯粹粹的板子题~~~~并，查，取根结点三种操作就可以AC了。

**并**：找到两个点的根结点，把其中一个根结点变成为另一个根结点的儿子结点。这就完成了两个集合的合并。


**查**：找到两个点的根结点，如果相同，就是在同一个集合里面，如果不同，就不在同一个集合里面。


**取根结点**：采用递归的方法，如果一个点的父亲结点不是自己，那么就找他的父亲结点的父亲结点…………直到一个结点的父亲结点是自己，那么它就是该结点就是该集合的根结点。


代码
--

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int father[10200];
//father数组用来存放所有的结点的根结点。
struct node
{
    int x,y,cz;
}a[200010];
//用来记录每一条操作，x和y是操作对象，cz是操作的方式。题目中有描述的
inline int getfather(int u)
{
    if(father[u]==u)return u;
    father[u]=getfather(father[u]);
    return father[u];
}
//取父亲结点。
inline void un(int k,int l)
{
    int fx,fy;
    fx=getfather(k);
    fy=getfather(l);
    father[fx]=fy;
}
//合并两个集合。
inline bool judge(int k,int l)
{
    int fx,fy;
    fx=getfather(k);
    fy=getfather(l);
    return fx==fy;
}
//判断两个点是否在一个集合里面
void read()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    scanf("%d%d%d",&a[i].cz,&a[i].x,&a[i].y);
    for(int i=1;i<=n;i++)
    father[i]=i;
    //这里有个细节很重要！！！每一个点的根结点默认为自己。我第一次过的时候就是这个写错了，导致10个MLE。。。
}
//读入。
void work()
{
    for(int i=1;i<=m;i++)
    {
        if(a[i].cz==1)un(a[i].x,a[i].y);//1代表合并
        if(a[i].cz==2)
        if(judge(a[i].x,a[i].y))//判断是否在一个集合里面
        printf("Y\n");
        else
        printf("N\n");
    }
}//2代表查找。
//进行操作啦
int main()
{
    read();
    work();
    return 0;
}

```

---

## 作者：Lacrymabre (赞：0)

~~（最小生成树都打出来了我为什么去打并查集~~

这题 太！毒！瘤！了！

当时的RE代码：
```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define maxn 2000001
using namespace std;

int father[maxn];
int m,n,i,x,y,q;

void make();

int find(int x)
{
	if(father[x]!=x) father[x]=find(father[x]);
	return father[x];
}

int unionn(int r1,int r2)
{
	father[r2]=r1;
}

void scan()
{
	int key;
	cin>>n>>m;
	for(i=1;i<=n;i++) father[i]=i;
    for(i=1;i<=m;i++)
	{
	cin>>key;
	if(key==1)
	{
	scanf("%d%d",&x,&y);int r1=find(x);int r2=find(y);if(r1!=r2) unionn(r1,r2);
	}
	else
	if(key==2)make();
	}
}

void make()
{
        scanf("%d%d",&x,&y);
    	if(find(x)==find(y)) printf("Y\n");
    	else printf("N\n");
}

int main()
{
	scan();
	return 0;
}
```
wtf？RE?

咱也不滋到咱也不敢问

大佬们的推荐下我重构了代码：

```
#include<bits/stdc++.h>
using namespace std;

int n,m,f[200001],key,a,b;

int find(int x)
{
    if(f[x]==x) return x;
    return f[x]=find(f[x]);
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) f[i]=i;
    
    for(int i=1;i<=m;i++)
	{
        cin>>key>>a>>b;
        if(key==1) f[find(a)]=find(b);
        else if(find(a)==find(b))
        printf("Y\n");
        else
        printf("N\n");
    }
    return 0;
}
```
怎么就A了呢？？？~~（至今不明~~

函数多了容易乱，千万别滥用！！！

---

## 作者：Undefined_Myth (赞：0)

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
#define INF 10000+5
#define INF2 200000+5
int n,m; 
struct Node{//写大写是为了避免与之后的node重复 
    //int data;
    int rank;//rank代表这一个节点和他的所有子节点的深度 
    int father;
}node[INF+1];
int get_bigfather(int k)//寻找根节点 ——一般是在这里加上路径压缩的 
{
    if(node[k].father==k)
        return k;
    else
    {
        node[k].father=get_bigfather(node[k].father);//路径压缩——一路上每次函数返回时顺便把其指向的父节点直接改为根节点 
        //即直接把这个点挂到根节点上 
        return node[k].father;
    }    
}
void merge(int u,int v)
{
    u=get_bigfather(u);
    v=get_bigfather(v);
    if(node[u].rank>node[v].rank) 
        node[v].father=u;
    else
    {
        node[u].father=v;
        if(node[u].rank==node[v].rank)
            node[v].rank++;
    }
}
int main() 
{
    scanf("%d%d",&n,&m);//n个元素，m个操作 
    for(int i=1;i<=n;i++)//初始化，自己的父亲一开始是自己 
        node[i].father=i;
    for(int i=1;i<=m;i++)
    {
        int temp,u,v;
        scanf("%d%d%d",&temp,&u,&v);
        if(temp==1)//合并
            merge(u,v);
        else
        {
            if(get_bigfather(u)==get_bigfather(v))
                printf("Y\n");
            else
                printf("N\n");
        }
    }
        return 0; 
}
```

---

## 作者：中2少年雷耶斯 (赞：0)

跟大家推荐一个博客http://blog.csdn.net/kakaka2011/article/details/74857328?locationNum=2&fps=1，好像就是楼下某大佬说的那个

好巧我也是看了这个博客


并查集顾名思义就是**有合并和查找两种操作的集合**，（当然我们现在已经有了更多的操作，但是它们都是基于这两种基本操作的更高级操作）


通俗来说并查集就是一个数组，但是这个数组不简单，假设这个数组叫st，那么**st[i]==j代表i的上级（我喜欢这么叫）是j**。那么对于一个完整的并查集，每一个数都应该有一个首领满足st[t]==t


我们就基于这个思想去构造两个函数：find（并）和join（查）


find函数：在一个并查集中寻找这个元素的首领。我们只知道这个元素的上级（上级不一定是首领），也只需要知道就行了。相信在座的各位都知道递归，我们只要查找这个元素的上级，然后查找它上级的上级，然后查找它上级的上级的上级。。。一直到查到首领，返回。


然后我们就可以打出第一代查找代码



```cpp
**int find(int x)**
**{**
 **       int r=t;**
**        while(find(r)!=r)r=find(r);**
   **     return r;**
**}**
```
可以优化一下这个步骤吗？sure。考虑我们在查找a1的首领时，知道了a2是a1的上级，那么a2也是a1的首领的手下嘛。下次在查a2的首领的时候，岂不会浪费时间？

为了避免这个情况，我们可以让a1和a2，a3，a4，a5，a6（ai是ai-1的上级）都变成首领的直属手下，代码实现如下



```cpp
    **int find(int x)（路径压缩版）**
    **{  **
   **     if(x==st[x])return x;**
      **  else return st[x]=find(st[x]);**
    **}**
```
这样不就快一些了吗哈哈哈哈...

下面来看join（并）的操作：


比如我们想让两个元素a1和b1在一个集里面，但是a1属于A，b1属于B，那我们就要用到这个操作了


由于上级的上级还是上级，那我们可以让a1的首领变成b1的首领的手下，那么a1首领的所有手下就全部归于B集了，这样a1和b1就在一起啦。代码实现：



```cpp
    **void join(int x,int y)**
    **{**
              ** int p1=find(x),p2=find(y);**
   **            if(p1!=p2)st[p1]=p2;**
    **}**
```
另外，我们还能通过这两个简单的操作做出更多复杂的操作。对于一些常用的函数，我把它们整合在了一个结构体里，如下：


```cpp
struct set
{
    int st[10001];
    set(){for(int i=1;i<=10000;i++)st[i]=i;}
    int find(int x)
    {  
        if(x==st[x])return x;
        else return st[x]=find(st[x]);
    }
    void join(int x,int y)
    {
                int p1=find(x),p2=find(y);
                if(p1!=p2)st[p1]=p2;
    }
    bool same(int x,int y)
    {
               int p1=find(x),p2=find(y);
               if(p1==p2)return 1;
               return 0;
    }
    int num(int x,int maxn)
    {
               int t=find(x),turn=0;
               for(int i=1;i<=maxn;i++)if(find(i)==t)turn++;
               return turn;
    }
};
```
这些函数都是什么意思，同学们可以自己想一想（字太多了），我就不再赘述了。

最后把这个题的代码放一下


```cpp
#include<iostream>
using namespace std;
struct set
{
    int st[10001];//i的上级是谁
    set(){for(int i=1;i<=10000;i++)st[i]=i;}
    int find(int x)//找x的领袖（状态压缩）
    {  
        if(x==st[x])return x;
        else return st[x]=find(st[x]);
    }
    void join(int x,int y)//把x和y的团体结合
    {
        int p1=find(x),p2=find(y);
        if(p1!=p2)st[p1]=p2;
    }
    bool same(int x,int y)//x和y在不在一个团体里
    {
        int p1=find(x),p2=find(y);
        if(p1==p2)return 1;
        return 0;
    }
}s;
int main(void)
{
    int n,m;cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int t,x,y;cin>>t>>x>>y;
        if(t==1)s.join(x,y);
        else
        {
            if(s.same(x,y))cout<<"Y\n";
            else cout<<"N\n";
        }
    }
}
```

---

## 作者：hehelego (赞：0)

能看得懂的代码系列-最最最基本的并查集实现

鉴于oier们比较喜欢C with class 而不是CPP，本代码保持了一个恶心人的代码风格，并且不使用STL(大雾）


>



```cpp
struct UFS{
    int *parent;
    int n;
    UFS(int n){
        this->n=n;
        parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
    }
    ~UFS(){
        delete [] parent;
    }
    int P(int a){
        if(parent[a]!=a)
            parent[a]=P(parent[a]);
        return parent[a];
    }
    bool U(int a,int b){
        parent[P(a)]=P(b);
        return true;
    }
    bool F(int a,int b){
        return P(a)==P(b);
    }
};
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
struct UFS{
    int *parent;
    int n;
    UFS(int n){
        this->n=n;
        parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
    }
    ~UFS(){
        delete [] parent;
    }
    int P(int a){
        if(parent[a]!=a)
            parent[a]=P(parent[a]);
        return parent[a];
    }
    bool U(int a,int b){
        parent[P(a)]=P(b);
        return true;
    }
    bool F(int a,int b){
        return P(a)==P(b);
    }
};
int main(){
    int n,m;cin>>n>>m;
    UFS s(n);
    int z,x,y;
    for(int i=0;i<m;i++){
        cin >> z >> x >> y;
        x-=1;y-=1;
        if(z==1){
            s.U(x,y);
        }
        if(z==2){
            cout<<(s.F(x,y)?'Y':'N')<<endl;
        }
    }
    return 0;
}
>
```

---

## 作者：gyf12138 (赞：0)

**纯裸并查集算法**

不过细节需要注意，

本人就因为细节问题一直提交一直WA

所以写代码要认真仔细

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m;
int father[10001];
int find_(int x)
{
    int root = x;
    while(father[root] != 0)
        root = father[root];        
    while(root != x)
    {
        int temp = father[x];
        father[x] = root;
        x = temp;
    }
    return root;
}
int main()
{
    //freopen("a.txt","r",stdin);
    scanf("%d%d", &n, &m);
    int x, y, z;
    for(int i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &z, &x, &y);
        int p = find_(x), q = find_(y);
        if(z == 1)
            if(p != q)
                father[q] = p;  //把孩子q加入p 
        if(z == 2)
        {
            if(p == q)
                printf("Y\n");
            else
                printf("N\n");
        }
    }
    return 0;
}
```

---


# [蓝桥杯 2017 国 C] 合根植物

## 题目描述

w 星球的一个种植园，被分成 $m \times n$ 个小格子（东西方向 $m$ 行，南北方向 $n$ 列）。每个格子里种了一株合根植物。

这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。

如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/9q0xulxh.png)

时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛

## 样例 #1

### 输入

```
5 4
16
2 3
1 5
5 9
4 8
7 8
9 10
10 11
11 12
10 14
12 16
14 18
17 18
15 19
19 20
9 13
13 17```

### 输出

```
5```

# 题解

## 作者：_xbt (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P8654)

这道题基本上就是一道裸的并查集，在最开始先设每个数的根是它本身。每次输入 $x$ 和 $y$ 时都把 $x$ 的根设为 $y$ 的根（反着设也行）。最后扫描整张图，如果一个数的根等于它本身了，那就将答案加一。

如果你还不知道查并集的话，先做做[这道题](https://www.luogu.com.cn/problem/P3367)吧！

# $\text{code}$
```cpp
#include<iostream>
using namespace std;
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
int n,m,k,t,r,ans,a[1000010];
int find(int x){
    while(x!=a[x]) x=a[x]=a[a[x]];
    return x;
    //用来寻找一个数的根
}
int main(){
	IOS;
	cin>>n>>m>>k;
	int nn=n*m;
	for(int i=1;i<=nn;i++) a[i]=i;
	//并查集初始化
	for(int i=1;i<=k;i++){
		cin>>t>>r;
		a[find(t)]=find(r);
		//把一个数的根赋值为另一个数的根
	}
	for(int i=1;i<=nn;i++)
		if(a[i]==i) ans++;
	//找整个图里根等于自己的数
	cout<<ans;
}
```
求管理员大大给过 QAQ！

---

## 作者：xvl_ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8654)

一道并查集模板题。

没什么好说的，先给个并查集模板，神犇可以直接跳过。

查找根：

```cpp
int find_root(int n) {
    if (fa[n] == n) return n;
    return fa[n] = find_root(fa[n]);
}
```
合并：

```cpp
void merge(int x, int y) { 
    int sx = find_root(x), sy = find_root(y);
    if (sx != sy) fa[sx] = sy;
}
```

预处理：

```cpp
for (int i = 1; i <= n; i++) fa[i] = i;
```
题目要求有多少个集合，也就是有多少个根。简单判断即可。

```cpp
if (fa[i] == i) ans++;
```
### Code

```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 1e9
using namespace std;
int m, n, k, ans;
int fa[1000005];
int find_root(int n) { // 查找根
    if (fa[n] == n) return n;
    return fa[n] = find_root(fa[n]);
}
void merge(int x, int y) { // 合并
    int sx = find_root(x), sy = find_root(y);
    if (sx != sy) fa[sx] = sy;
}
signed main() {
    ios :: sync_with_stdio(0);
    cin >> m >> n >> k;
    for (int i = 1; i <= m * n; i++) fa[i] = i; // 预处理
    for (int i = 1; i <= k; i++) {
        int u, v;
        cin >> u >> v;
        merge(u, v);
    }
    for (int i = 1; i <= m * n; i++) {
        if (fa[i] == i) ans++; // 如果是根，答案增加
    }
    cout << ans;
    return 0;
}
```



---

## 作者：kkxacj (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8654)


#### 题意

w 星球的一个种植园，被分成 $m \times n$ 个小格子，告诉你哪些小格子间出现了连根现象，求出这个园中一共有多少株合根植物

#### 思路

很明显，这道题用并查集（什么，你不知道并查集是什么？[看这里](https://zhuanlan.zhihu.com/p/93647900)），每次输入两个数 $x$ 和 $y$，将 $x$ 的父亲连接给 $y$（或将 $y$ 的父亲连接给 $x$，都可以），每个数初始的父亲是他自己，最后扫一遍，如果 $i$ 的父亲是自己，那么它就是一株株合根植物，答案加一。


code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000010],n,m,k,x,y,ans;
int find(int w) //并查集模板 
{
    if(a[w] == w) return w;
    return a[w] = find(a[w]); //路径压缩
}
int main()
{
	//	freopen(".in","r",stdin);
	//	freopen(".out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i <= n * m;i++) a[i] = i; //初始化父亲为自己
	for(int i = 1;i <= k;i++)
	{
		scanf("%d%d",&x,&y);
		a[find(x)] = find(y);
	}
    for(int i = 1;i <= n * m;i++) if(a[i] == i) ans++;
    printf("%d",ans);
	return 0;
}
```


---

## 作者：Smg18 (赞：1)

# 并查集~~好题~~。

这题我们可以先套用**并查集**，因为本题问有多少个合体植物父亲是否为自己。

所以先打模板：

```cpp

int f[N];
int find(int me){
	if(f[me]==me)return me;
	else{
		f[me]=find(f[me]);
		return f[me];
	}
} 

```

最后在每次和根时我们对他父亲是否一样，如果不同就换父亲，将第一个变量和第二个变量合并父亲，最后在遍历是否为本身。

然后再打最后的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(int i=j;i<=n;i++)
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e7+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T;
ll mini=INT_MAX,maxi=0,Mod;
string s1,s2;
int f[N];
int find(int me){//模板
	if(f[me]==me)return me;
	else{
		f[me]=find(f[me]);
		return f[me];
	}
} 
int main(){
	cin>>m>>n>>T;
	for(int i = 1;i<=m*n;i++)f[i]=i;
	while(T--){
		int u,v;
		cin>>u>>v;
		f[find(u)]=find(v);//不同换爸爸
		f[find(v)]=find(u);	//同上
	}
	for(int i = 1;i<=n*m;i++){
		if(f[i]==i){
			ans++;
		}
	}	
	cout<<ans;
	return 0;
}
```


---

## 作者：_Spectator_ (赞：1)

[可能更好的食用体验](/blog/523641/P8654) $|$ 
[题目传送门](/problem/P8654) $|$ 
[我的其他题解](/blog/523641/#type=题解-New)

------------

${\large\color{#00CD00}\text{思路}}$

可以使用[并查集](/problem/P3367)解决。

初始时，将每个点的根设为它本身。合并时，使用找到两个点的根并将其合并。最后，枚举每个点判断其跟是否为它本身即可。

------------

${\large\color{#00CD00}\text{代码}}$

```cpp
#include<bits/stdc++.h> 
using namespace std;
long long m,n,k,a,b,ans;
int f[1000005];
int find(int x)//找到某个点的根并路径压缩（即将沿路的所有点的根都设为最终找到的根）
{
	if(f[x]!=x)f[x]=find(f[x]);
	return f[x];
}
int main()
{
	cin>>m>>n>>k;
	for(int i=1;i<=m*n;i++)f[i]=i;//初始化
	for(int i=1;i<=k;i++)
	{
		cin>>a>>b;
		f[find(a)]=find(b),f[find(b)]=find(a);//将两个点合并
	}
	for(int i=1;i<=m*n;i++)//判断有多少个点的根为它本身。
		if(f[i]==i)ans++;
	cout<<ans;
	return 0;
}
```

---

## 作者：Light_az (赞：0)

## 并查集模板

看到样例解释这一张图片，我就知道本题可以使用并查集来完成，对于每次合根操作，我们使用并查集找到 $x,y$ 的父亲点，判断两者父亲是否一样，如果不一样，就将 $x$ 的父亲点换成 $y$ 的父亲点，最后对整张图进行遍历，如果其中某个点的父亲点是自己本身的话，说明这是一棵合根植物的父亲点，那么将合法数量添加。

建议没有学过并查集的同学写一下 [模板题](https://www.luogu.com.cn/problem/P3367)。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(int i=j;i<=n;i++)
#define Tr(v,e) for(int v:e)
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e7+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T,num,mid;
ll mini=INT_MAX,maxi=0,Mod;
string s1,s2;

ll f[N];
ll find(ll x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
struct Node{
	ll x,y,t;
}a[N];
bool cmp(Node a,Node b){
	return a.t<b.t;
}
int main(){
	cin>>n>>m;
	F(i,1,n*m) f[i]=i;//并查集初始化
	cin>>k;
	F(i,1,k){
		cin>>u>>v;
		x=find(u),y=find(v);//寻找父亲点
		if(x!=y) f[x]=y;//合并
	}
	F(i,1,n*m){
		if(f[i]==i) ans++;//父亲点是本身，合法方案添加
	} 
	cout<<ans;
	return 0;
}


```


---


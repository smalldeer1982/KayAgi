# [信息与未来 2024] 间谍卫星

## 题目描述

Dr. X 研制的间谍卫星拍摄到了许多 U 国建筑的照片。为了找出其中的军事设施，Dr. X 需要估算建筑的大小。Dr. X 发现，所有间谍卫星拍摄的照片都恰好包含一个完整的正方形，其中建筑边界上的像素被标记为了白色（用 $1$ 表示），其余像素被标记为了黑色（用 $0$ 表示）。一些照片的案例如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ponzg18.png)

你的任务是根据拍摄的照片估算被摄正方形的**边长** (米)。照片中的每个像素都代表一个一米乘一米的正方形。

## 说明/提示

本题仅有一个 $n\leq 100$ 的测试数据，且测试数据和样例数据的生成方式相同。

当你对一幅照片估计的边长和实际建筑边长差距不超过 $2$ 时，则认为估计正确。若估计正确的照片比例 $A > 0.5$，本题得分为 $(A − 0.5) \times 30$ 向下取整，否则得零分。

我们在生成每张照片时，都先在平面上生成一个随机的、边长为整数、边界宽度为 $1$ 像素的正方形，然后“拍摄”得到它的照片。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
见附件中的 sample.in```

### 输出

```
53```

# 题解

## 作者：tanzexiaodezhonghao (赞：11)

## 思路
你说得对，题解区一堆洪水填充，但这是一道小学数学题。周长是 $1$ 的个数，而 $C=4a$，加上 $0$ 等于没加，算出周长后除以 $4$ 即可。没了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;int n,cnt;char x;
int main(){
	cin>>n;
	while(n--){
		cnt=0;
		for(int j=1;j<=128;j++){
			for(int k=1;k<=128;k++){
				cin>>x;cnt+=(x-'0');
			}
		}
		cout<<cnt/4<<endl;
	}
	return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：5)

通过观察图片我们发现除了平行于坐标轴的正方形，其他的情况，一定存在一个编号最小的行，满足行内只有一个正方形的顶点。不妨钦定这个点，找到另外的和它在一条边上的另一个顶点计算边长。那么由于正方形的四个角都是直角，所以我们只需要找到编号最小的列，满足行内只有一个正方形的顶点，就可以了。证明显然。

接下来我们考虑怎么把这个代码写得更加优美：如果正方形边都垂直于坐标轴，那么就是找行里最右边的和列里最上面的。~~干脆直接特判也可以吧。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int n = 128;
string s[150];
void solve()
{
    for (int i = 1; i <= n; i++)
        cin >> s[i], s[i] = ' ' + s[i];
    for (int i = 1; i <= n; i++)
    {
        for (int j = n; j >= 1; j--)
        {
            if (!(s[i][j] ^ '0'))
                continue;
            for (int y = 1; y <= n; y++)
            {
                for (int x = 1; x <= n; x++)
                {
                    if (s[x][y] ^ '0')
                        return cout << sqrt((x - i) * (x - i) + (y - j) * (y - j)) << endl, void();
                }
            }
        }
    }
}
int main()
{
    int t;
    cin >> t;
    while (t--)
        solve();
    return 0;
}
```

---

## 作者：Danny_chan (赞：3)

我们可以先从右往左找到第一个正方形顶点，然后从上往下找到第二个正方形顶点，最后运用
$\sqrt{(x1-x2)^2+(y1-y2)^2}$ 求出正方形面积。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n;
char a[130][130];
int x2,y2,x3,y3;
void f1(){
	for(int i=1;i<=128;i++){
		for(int j=128;j>=1;j--){
			if(a[i][j]=='1'){
				x2=i;
				y2=j;
				return ;
			}
		}
	}
}
void f2(){
	for(int j=1;j<=128;j++){
		for(int i=1;i<=128;i++){
			if(a[i][j]=='1'){
				x3=i;
				y3=j;
				return ;
			}
		}
	}
}
int main(){
	cin>>n;
	
	while(n--){
		for(int i=1;i<=128;i++){
			for(int j=1;j<=128;j++){
				cin>>a[i][j];
			}
		}
		f1();
		f2();
		cout<<sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3))<<endl;
	}
	return 0;
}
```

---

## 作者：遥遥领先 (赞：2)

# 题解：B3980 [信息与未来 2024] 间谍卫星

## 思路

这道题就是洪水填充的模板。

从点 $(1,1)$ 开始搜索 `0`，把所有能搜到的 `0` 变成 `1`，填充后把剩下 `0` 的个数算出来，就是正方形的面积，最后根据边长的平方等于面积算出边长。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int T;
char a[200][200];

struct node
{
	int x,y;
};
const int fx[4] = {-1,0,0,1};
const int fy[4] = {0,-1,1,0};

void bfs()
{
	queue <node> q;
	q.push({1,1});
  a[1][1] = '1';
	while (!q.empty())
	{
		node f = q.front();
		q.pop();
		for (int i = 0;i < 4;i++)
		{
			int xx = f.x + fx[i];
			int yy = f.y + fy[i];
			if (xx >= 1 && xx <= 128 && yy >= 1 && yy <= 128 && a[xx][yy] == '0')
			{
				a[xx][yy] = '1';
				q.push({xx,yy});
			}
		}
	}
}

void solve()
{
	scanf("%lld",&T);
	while (T--)
	{
		for (int i = 1;i <= 128;i++)
			scanf("%s",a[i]+1);
		bfs();
		int sum = 0;
		for (int i = 1;i <= 128;i++)
			for (int j = 1;j <= 128;j++)
				if (a[i][j] == '0')
					sum++;
		printf("%lld\n",(int)(sqrt(sum)));
	}
}

signed main()
{
	solve();
	return 0;
}

```

upd on 2024/11/3: 感谢@jtyjty123456指出的错误

---

## 作者：Mike_L (赞：2)

首先拿到题目第一件事就是分析，要把它转化成村口王大爷都能听懂的语言，才算彻底理解透。

这一题我们可以直接理解成给定一个单边正方形，求出其边长。

到这里，估计大多数人都想到了这个公式（包括数学知识匮乏的我）：

$$
\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}
$$

这个公式的意思是已知两点坐标，求两点之间的线段长度。

用这种方法可以，但是不够简便。

我们小学二年级就学过：$C_正=\text{边长}÷4$，那么，既然是单边，又能够证明图片里只有一个正方形，不就能求到周长，进而求到边长了吗？

补充说明：这种方式甚至不会有精度损失。（自己推导）

所以，我们只需要在输入的时候计数，最后除以 $4$ 加 $1$ 就可以了。

什么？加 $1$？

没错。

![](https://cdn.luogu.com.cn/upload/image_hosting/l8r5uy4k.png)

（精度不够，将就一下）

可以发现，除以 $4$ 之后，边长还少 $1$，所以要加上去。

AC代码
```c++
#include <bits/stdc++.h>
using namespace std;

int n, ans;

int main()
{
	cin >> n;
	while (n--)
	{
		ans = 0;
		for (int i = 1; i <= 128; i++)
		{
			string s;
			cin >> s;
			for (int j = 1; j <= 128; j++)
			{
				ans += s[j] - '0';
			}
		}
		cout << ans / 4 + 1 << endl;
	}
	return 0;
}
```
这个代码有问题，字符串下标是从 `0` 开始的，但48行写成了从 `1` 开始。所以应修改为 `for (int j = 0; j ＜ 128; j++)`（警钟敲烂）

---

## 作者：Tonymcmcmc (赞：1)

# 前言
[题目传送门](https://www.luogu.com.cn/problem/B3980)
# 正文
这道题乍一看似乎是一道洪水填充和广度优先搜索的题，

实际上只是一道小学数学题。
$$
a_{正方形}=C_{正方形}\div4
$$
其中 $a$ 代表边长，$C$ 代表周长。

而 $C$ 只需要统计出字符 1 的个数，即可求出。
# 代码
## 核心代码
```c++
for(int j=0;j<128;j++){
	for(int k=0;k<128;k++){
		char c;
		cin>>c;
		if(c=='1')cnt++;
    }
}
cout<<cnt*1.0/4+1<<endl;//算上4个角
```
## 完整代码
```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		int cnt=0;
		for(int j=0;j<128;j++){
			for(int k=0;k<128;k++){
				char c;
				cin>>c;
				if(c=='1')cnt++;
			}
		}
		cout<<cnt*1.0/4+1<<endl;//算上4个角
	}
	return 0;
}
```

---

## 作者：王逸辰 (赞：1)

# B3980 [信息与未来 2024] 间谍卫星 题解
## 思路
小学数学题。

因为边长等于周长除以 $4$，所以我们只需统计出 $1$ 的个数（也就是周长），再把它除以 $4$ 即可。

虽然这样误差较大，但通过这个题目是没问题的。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n,ans;
	char ch;
	cin>>n;
	while(n--){
		ans=0;
		for(int i=(0); i<128; ++i)
			for(int j=(0); j<128; ++j)
				cin>>ch,ans+=ch-'0';
		cout<<ans/4<<endl;
	}
	return 0;
}
``````

---

## 作者：lizeyuhello (赞：1)

没有宽搜的题解，我来一发。

### 思路
要算边长，我们可以先算面积，再开根，就可以计算出边长。先找到第一个 $1$，然后搜索，从它旁边开始搜，防止精度误差可以在不同方向多搜几遍。

从不同方向多搜几遍的原因：从 $1$ 旁边开始搜可能会搜到正方形外面，多搜几遍保险一点。

最后，把正方形的面积开根，就可以算出边长，再四舍五入，让答案更精确一点，这种方法算出来的答案是很精确的。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

struct node
{
	int x;
	int y;
};

int T;
int a[140][140], b[140][140];
int dx[] = {1, 0,-1, 0};
int dy[] = {0, 1, 0,-1};

void bfs(int sx, int sy) //广搜
{
	for (int i = 1; i <= 128; ++i)
		for (int j = 1; j <= 128; ++j)
			b[i][j] = a[i][j];
	queue<node> q;
	q.push((node){sx, sy});
	b[sx][sy] = 1;
	while (!q.empty())
	{
		node now = q.front();
		q.pop();
		for (int i = 0, tx, ty; i < 4; ++i)
		{
			tx = now.x + dx[i], ty = now.y + dy[i];
			if (tx >= 1 && tx <= 128 && ty >= 1 && ty <= 128 && b[tx][ty] == 0)
			{
				q.push((node){tx, ty});
				b[tx][ty] = 1;
			}
		}
	}
	return;
}

int main()
{
	scanf("%d", &T);
	while (T--)
	{
		bool flag = 0;
		int sx, sy;
		for (int i = 1; i <= 128; ++i)
		{
			for (int j = 1; j <= 128; ++j)
			{
				scanf("%1d", a[i] + j);
				if (a[i][j] == 1 && !flag)
					sx = i, sy = j, flag = 1;
			}
		}//输入 & 找第一个 1
		int ans, bns;
		int sa = 0, sb = 0, sc = 0, sd = 0;
		bfs(sx + 3, sy); //搜索
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				sa += b[i][j];
		if (sqrt(sa) < 100)
		{
			ans = ceil(sqrt(sa));
			printf("%d\n", ans);
			continue;
		}
		bfs(sx - 3, sy);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				sb += b[i][j];
		if (sqrt(sb) < 100)
		{
			ans = ceil(sqrt(sb));
			printf("%d\n", ans);
			continue;
		}
		bfs(sx, sy + 3);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				sc += b[i][j];
		if (sqrt(sc) < 100)
		{
			ans = ceil(sqrt(sc));
			printf("%d\n", ans);
			continue;
		}
		bfs(sx, sy - 3);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				sd += b[i][j];
		if (sqrt(sd) < 100)
		{
			ans = ceil(sqrt(sd));
			printf("%d\n", ans);
			continue;
		}
		//还是广搜
		int saa = 0, sbb = 0, scc = 0, sdd = 0;
		bfs(sx + 3, sy + 3);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				saa += b[i][j];
		if (sqrt(saa) < 100)
		{
			ans = ceil(sqrt(saa));
			printf("%d\n", ans);
			continue;
		}
		bfs(sx + 3, sy - 3);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				sbb += b[i][j];
		if (sqrt(sbb) < 100)
		{
			ans = ceil(sqrt(sbb));
			printf("%d\n", ans);
			continue;
		}
		bfs(sx - 3, sy + 3);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				scc += b[i][j];
		if (sqrt(scc) < 100)
		{
			ans = ceil(sqrt(scc));
			printf("%d\n", ans);
			continue;
		}
		bfs(sx - 3, sy - 3);
		for (int i = 1; i <= 128; ++i)
			for (int j = 1; j <= 128; ++j)
				sdd += b[i][j];
		ans = min(min(sa, sb), min(sc, sd));
		bns = min(min(saa, sbb), min(scc, sdd));
		ans = min(ans, bns);
		ans = (int)(round(sqrt(ans))); //开根 & 四舍五入
		printf("%d\n", ans);
	}
	return 0; //完结撒花
}
```

---

## 作者：joe_zxq (赞：0)

# Part 1 - 算法思路

一个简简单单的泛洪算法的模板，其实就是一个非常暴力的 dfs。

由于 $(1,1)$ 肯定是 `0`，我们将它作为正方形外部的一个像素开始上下左右 dfs，对到达过的点进行标记，搜完之后计算有多少个点到过。那总面积减去正方形外部的面积就是正方形的面积，开一个根号就是正方形的边长。

# Part 2 - 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long

char a[130][130];

ll vis[130][130];

bool in(ll x, ll y) {
	return (1 <= x && x <= 128 && 1 <= y && y <= 128 && !vis[x][y] && a[x][y] == '0');
} 

void dfs(ll x, ll y) {
	if (in(x - 1, y)) {
		vis[x - 1][y] = 1;
		dfs(x - 1, y);	
	}
	if (in(x, y - 1)) {
		vis[x][y - 1] = 1;
		dfs(x, y - 1);	
	}
	if (in(x + 1, y)) {
		vis[x + 1][y] = 1;
		dfs(x + 1, y);	
	}
	if (in(x, y + 1)) {
		vis[x][y + 1] = 1;
		dfs(x, y + 1);	
	}
}

void solve() {
	for (ll i = 1; i <= 128; i++) {
		for (ll j = 1; j <= 128; j++) {
			cin >> a[i][j];
		}
	}
	dfs(1, 1);
//	for (ll i = 1; i <= 128; i++) {
//		for (ll j = 1; j <= 128; j++) {
//			if (a[i][j] == '0' && !vis[i][j]) {
//				vis[i][j] = 1;
//				dfs(i, j);
//			}
//		}
//	}
	ll ans = 0;
	for (ll i = 1; i <= 128; i++) {
		for (ll j = 1; j <= 128; j++) {
			ans += (vis[i][j]);
		}
	}
	ans = 128 * 128 - ans;
	cout << sqrt(ans) << "\n";
}

int main() {

	ll tc;
	cin >> tc;
	while (tc--) {
		memset(vis, 0, sizeof vis);
		solve();
	}

	return 0;
}
```

---

## 作者：WMWD (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3980)

-------------
### 思路：
本题有两种做法，第一种利用周长求边长，第二种利用面积求边长。
#### 周长法：
只需要把原图中的 $1$ 的个数除以 $4$ 就是边长。因为此图形的外围全是 $1$，并且正方形边长公式是周长除以 $4$。记得向下取整。用字符串。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
int main(){
	cin.tie(0);
	cin>>n;
	for(int k=1;k<=n;k++){
		int ans=0;
		for(int i=0;i<128;i++){
			cin>>s;
			for(int j=0;j<128;j++){
				if(s[j]=='1') ans++;
			}
		}
		cout<<floor(ans/4.0)<<endl;
	}
	return 0;
}


```
#### 面积法：
洪水填充法，把能搜到的 $0$ 全标称 $1$，搜完后数出剩余 $0$ 的个数，这是图形的面积。再根据面积求边长。

填充时可以用深度优先搜索。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dx[]={1,-1,0,0},dy[]={0,0,1,-1};
string s[150];
void dfs(int i,int j){
	if(i<0||i>127||j<0||j>127||s[i][j]!='0') return ;
	s[i][j]='1';
	for(int k=0;k<=3;k++){
		dfs(i+dx[k],j+dy[k]);
	}
}
int main(){
	cin>>n;
	for(int k=1;k<=n;k++){
		int ans=0;
		for(int i=0;i<128;i++){
			cin>>s[i];
		}
		dfs(0,0);
		for(int i=0;i<=127;i++){
			for(int j=0;j<=127;j++){
				if(s[i][j]=='0') ans++;
				//cout<<s[i][j];
			}
			//cout<<endl;
		}
		cout<<floor(sqrt(double(ans)))<<endl;
	}
	return 0;
}


```

---

## 作者：fire_and_sweets (赞：0)

本题有很多种做法。这里介绍我想到的两种：
- 周长法。根据正方形的性质，他的边长的 $4$ 倍就是他的周长。所以我们只需要把原图中的 $1$ 的个数除以 $4$ 向下取整即可。虽然这种方法的误差可能很大，但是足以让我们通过这道题目。
- 面积法。这应该是本题的正解。我们可以通过或勾股定理或深度优先搜索的方法求出这个正方形的面积。最后，我们只需要把答案求一个平方根即可。

比赛结束以后，XX 给我介绍了一种他想到的方法：直接找到正方形的一条对角线上的两个点，然后算出这两个顶点之间的距离，然后除以 $\sqrt{2}$ 即可。这种方法同样可行，但是本人没有尝试。

综上所述，本题求解正方形边长的方法多种多样，只要符合数学性质、符合逻辑即可。在此不提供本题代码。

---

## 作者：huangzhixia (赞：0)

我只能说可能有点那么一眼。

--------------------

题意自己看。

题目要求的是正方形的边长。可以先求出正方形的面积。因为 $S=  a^2$，所以可以得出 $a = \sqrt {a^2}$。

然后很显然的宽搜吧。就从任意点开始搜吧，我直接就从 $(1,1)$ 开始搜，然后就像图上 BFS，一层一层的向外搜。搜到的是 $0$ 就把它变成 $1$。这样不难发现 $0$ 的个数就是正方形的面积。令 $x$ 为正方形的面积，那么当搜索结束后看一遍这个矩阵，为 $0$ 则令 $x$ 加一。最后 $\sqrt x$ 即为答案。

总体时间复杂度为 $O(Tn^2)$。其中 $128$ 这个常数就估算成 $n$ 了。

警钟撅烂，存矩阵的 ```string``` 数组开打一点，我因为开小 RE 了一发。

[AC Record](https://www.luogu.com.cn/record/161638270)

---


# [蓝桥杯 2024 国 Java C] 瞬移

## 题目描述

小蓝在环游宇宙的过程中误入了一个数轴上的秘境，秘境的入口为 $1$，这是小蓝的初始位置，出口为 $L$，小蓝每次可以选取两个正整数 $x, y$，其中 $x, y \in \{a_1, a_2, \cdots, a_n\}$，并向右瞬间移动 $x + y$ 的距离，然而，秘境有大小限制，如果小蓝当前位置为 $p$，则瞬移后的位置为 $(p + x + y - 1) \bmod L + 1$，当小蓝的位置在出口 $L$ 时即可离开秘境，请问小蓝最少瞬移多少次之后可以离开秘境？


## 说明/提示

### 样例说明

- 第一次选取 $x = 1, y = 1$，到达位置 $3$，
- 第二次选取 $x = 1, y = 2$，到达位置 $6$，
- 第三次选取 $x = 2, y = 2$，到达位置 $10$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 200$，$1 \leq L \leq 200$；
- 对于所有评测用例，$1 \leq n \leq 2000$，$1 \leq L \leq 2000$，$0 \leq a_i \leq 10^8$。

## 样例 #1

### 输入

```
2 10
1 2```

### 输出

```
3```

# 题解

## 作者：lym2022 (赞：11)

### 思路
看到求最少步数自然的想到 bfs。

暴力 bfs，每走到一个点就 $O(n^2)$ 的查找能走到哪些点，搜到终点时输出步数，总复杂度 $O(n^3)$，肯定是会炸掉的，考虑优化。

注意到每次都要进行一个 $O(n^2)$ 的查找，考虑预处理，可以先 $O(n^2)$ 的算出所有走的步数的方案，排序后去重，在搜索时就可以只遍历去重后的数组，就可以将 $O(n^2)$ 的查找降到 $O(l)$，总复杂度为 $O(n\times l)$，就可以切掉了。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 4e6 + 5; 

int n,l,a[N],s,d[N],tot,cnt;

bool vis[N];

void bfs() {
	queue<pair<int,int> > q;     // first 是当前下标，second 是当前步数 
	q.push({1,0});          //初始下标为 1，步数为 0    
	while(!q.empty()) {
		int p = q.front().first;
		int step = q.front().second;
		q.pop();
		if(p == l) {          //如果到了 
			cout << step;     //输出步数 
			return;           //返回 
		}
		if(vis[p]) continue;  //走过了就跳过 
		vis[p] = true;        //标记走过 
		for(int i = 1;i<=cnt;i++) q.push({(d[i] + p - 1) % l + 1,step + 1});  //根据题目给的公式算出接下来会走到哪，步数加 1，入队 
	}
	cout << -1;         //不行就输出 -1 
}

int main() {
	cin >> n >> l;
	for(int i = 1;i<=n;i++) cin >> a[i];
	for(int i = 1;i<=n;i++) for(int j = 1;j<=n;j++) d[++tot] = (a[i] + a[j]) % l;   //预处理可能走多少步 
	sort(d+1,d+1+tot);           //排序
	cnt = unique(d+1,d+1+tot) - d - 1;        //去重 
	bfs();
	return 0;
}
```
对你有帮助就点个赞吧 owo。

---

## 作者：Clare613 (赞：5)

## 思路
读了题后可以直接想到用 BFS 来解决这道题，但有点卡，这里给大家几个省时间的方法，注意，不是快读。
### 35 分部分分：
我们把可以产生的 $x+y$ 都存起来，暴力跑，但很明显，时间复杂度炸了，这个方法想必谁都可以写出来。
```cpp
#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;
int n,l,a[2005],ans[2005],b[4000005],cnt;
void bfs(){
	memset(ans,0xff,sizeof(ans));
	queue<int> q;
	q.push(1);
	ans[1]=0;
	while(!q.empty()){
		int t=q.front();
		q.pop();
		for(int i=1;i<=cnt;i++){
			int s=(t+b[i]-1)%l+1;
			if(ans[s]==-1){
				ans[s]=ans[t]+1;
				q.push(s);
			}
		}
	}
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>n>>l;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	//预处理
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			b[++cnt]=(a[i]+a[j])%l;//可以不模，但要保证不爆int。
		}
	}
	bfs();
	cout<<ans[l];
	return 0;
}
```
### 80 分部分分：
我们其实可以注意，只要 $l$ 那一段全表记完就可以收工了，后面做的都是无用功，于是就出现了 $80$ 分部分分的做法。
```cpp
#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;
int n,l,a[2005],ans[2005],b[4000005],cnt,ctn=1;
void bfs(){
	memset(ans,0xff,sizeof(ans));
	queue<int> q;
	q.push(1);
	ans[1]=0;
	while(!q.empty()){
		int t=q.front();
		q.pop();
		for(int i=1;i<=cnt;i++){
			int s=(t+b[i]-1)%l+1;
			if(ans[s]==-1){
				ans[s]=ans[t]+1;
				q.push(s);
				ctn++;
			}
			if(ctn==l) return ;
		}
	}
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>n>>l;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	//预处理
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			b[++cnt]=(a[i]+a[j])%l;//可以不模，但要保证不爆int。
		}
	}
	bfs();
	cout<<ans[l];
	return 0;
}
```
### AC 做法
我们受前面的启发，可以想到，既然 $x+y$ 的值要模 $l$，所以说我们可以直接在 $1$ 到 $l$ 之间找可行的，也就是把 $n^2$ 化简到 $l$，于是就飞快地 AC 了，大家要好好理解这个方法哟。
```cpp
#include<iostream>
#include<queue>
#define MOD 1000000007
using namespace std;
int n,l,a[2005],ans[2005],b[2005],cnt;
bool f[2005];
void bfs(){
	queue<int> q;
	q.push(1);
	ans[1]=0;
	while(!q.empty()){
		int t=q.front();
		q.pop();
		for(int i=1;i<=cnt;i++){
			int s=(t+b[i]-1)%l+1;
			if(ans[s]==-1){
				ans[s]=ans[t]+1;
				q.push(s);
			}
		}
	}
}
int main(){
	cin>>n>>l;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	//预处理
	for(int i=1;i<=l;i++) ans[i]=-1;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			f[(a[i]+a[j])%l]=1;//可以不模，但要保证不爆数组。
		}
	}
	for(int i=0;i<l;i++){
		if(f[i]==1){
			b[++cnt]=i;
		}
	}
	bfs();
	cout<<ans[l];
	return 0;
}
```

---

## 作者：Ashankamiko (赞：4)

# 题目简述
### 题意
给一个长度为 $L$ 的数轴，并且每次移动能从 $a$ 中选取两个数，移动到 $(p + x + y - 1) \bmod L + 1$，求最少需要几步。
### 思路
很明显的广搜，相比于平常的题，特殊的是地图仅仅只是个数轴，其实降低了难度，因为我们只需要在数轴上搜索即可。
#### 优化 1
不过值得注意的是 $n \leq 2000$，所以移动时不同的方案数共有 $n \times n$ 中，在搜索时会耗费大量的时间和空间，所以我们要用 set 去重（~~set 的作用好像只剩去重了~~），这样即可避免大量无效的分支。
#### 优化 2
即最常用的标记数组，防止多余的分支，因为优先到达 $x$ 的元素，其步数一定是最少的。

重复搜索，直到找到最优解或是队列为空时输出 $-1$。

## [AC 代码](https://www.luogu.com.cn/record/217410678)
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define in cin
#define out cout

struct node {
	int x, r;
};
bool vis[2005];

signed main() {
	int n, l;
	set<int> s;
	in >> n >> l;
	queue<node> q; //队列
	int a[n];
	for (int i = 0; i < n; i++)
		in >> a[i];
	q.push({1, 0}), vis[1] = true;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			s.insert((a[i] + a[j]) % l); //用set去重,a[i]+a[j]在insert时直接写为两数的和
	while (!q.empty()) {
		int ux = q.front().x, ur = q.front().r;
		q.pop();
		if (ux == l) {
			out << ur; //存在答案
			return 0;
		}
		for (auto tx : s) //遍历s
			if (!vis[(tx + ux - 1) % l])
				q.push({(tx + ux - 1) % l + 1, ur + 1}), vis[(tx + ux - 1) % l] = true; //入队并标记
	}
	out << -1; //无解
	return 0;
}
```

---

## 作者：weifengzhaomi (赞：3)

题目意思比较清楚，这里不在复述。

## 思路 1.0

根据题目所说要求最少步数，就容易想到$bfs$。

暴力$bfs$的方法也就是每次都 $O(n ^ 2)$ 的去查找。

总时间复杂度：$O(n ^ 3)$。

期望得分：$35$ 分。

## 思路 2.0

其实只需稍微注意，就能发现只需要记录完 $l$ 那一段就可以收工了，后面都没有用，可以直接省略去。

总时间复杂度：$O(n ^ 2)$。

期望得分：$80$ 分。

## 思路 3.0

既然题目都说了，要对 $x + y$ 的值取模 $l$，那么考虑预处理，可以直接在 $1$ 到 $l$ 直接找答案，如此下来，就可以把 $O(n ^ 2)$ 优化到 $O(l)$ 了，可以通过本题。

期望得分：$100$ 分。

## 代码：

个人比较喜欢压行，可能会有点丑，谨慎观看。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,a[2010],b[2010],f[2010],top,front,rear,e[4000010];
bool flag[2010];
int main(){
	scanf("%d%d",&n,&l);
	for (int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for(int i = 1;i <= l;i++) f[i] = -1;
	for(int i = 1;i <= n;i++) for(int j = i;j <= n;j++) flag[(a[i] + a[j]) % l] = 1;
	for (int i = 0;i < l;i++) if (flag[i]) b[++top] = i;
	front = rear = 1,e[1] = 1,f[1] = 0;
	while (rear >= front){
		int t = e[front++];
		for (int i = 1;i <= top;i++) if (f[(t + b[i] - 1) % l + 1] == -1) f[(t + b[i] - 1) % l + 1] = f[t] + 1,e[++rear] = (t + b[i] - 1) % l + 1;
	}
	printf("%d\n",f[l]);
}
```

---

## 作者：JIN_LONG (赞：3)

## 思路：
这一题问从 $1$ 到要 $l$ 瞬移多少次，我们直接用广搜就可以，在每一次瞬移后在广搜中枚举可以瞬移的距离。

- 首先我们计算可以瞬移的距离有哪些，为了防止出现重复，我们可以弄一个统数组来存储可以瞬移的距离，又要为了让后面的广搜过程中更加省时间，我们再把它们挨着放到一个新数组里。

- 接下来还要开一个数组 $bushu$，用来记瞬移的次数，我们初始将整个数组里的数都变为 $-1$，这样到了最后，如果走不到出口，就可以直接输出 $-1$，我们再把 $bushu_1$ 赋值为 $0$，因为初始位置在 $1$ 那里，所以瞬移到 $1$ 这个位置的次数为 $0$。

- 最后我们可以就开始广搜了，用一个队列记录每一次瞬移的位置，将 $1$ 放入队列中，表示初始位置为 $1$，这里就不细讲了，按照广搜模板打就行了，结束的条件是队列长度为 $0$。
## 代码：

```
#include<bits/stdc++.h>
using namespace std;
queue<int>x;
int a[2001],b[2001],bushu[4000001];
int tong[2001],m;
int main(){
    int n,l;
    cin>>n>>l;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            tong[(a[i]+a[j])%l]=1;
        }
    }
    for(int i=0;i<l;i++){
        if(tong[i]==1)m++,b[m]=i;
    }
    for(int i=2;i<=l;i++)bushu[i]=-1;
    x.push(1);
    while(1){
        int xx=x.front();
        x.pop();
        for(int i=1;i<=m;i++){
            int h=(xx+b[i]-1)%l+1;
            if(bushu[h]==-1){
                bushu[h]=bushu[xx]+1;
                x.push(h);
            }
        }
        if(x.size()==0){
            cout<<bushu[l];
            break;
        }
    }
    return 0;
}
```

---

## 作者：Sparse_Table (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P12322)

简单 bfs，队列里需要放 $2$ 个东西，当前走到几，第二个是当前走了几步，再拿数组标记是否走过，其余基本就是模板了。

### 部分分
因为在枚举走多少步的时候，需要枚举 $a_i + a_j$，故用时 $\Theta(n ^ 2)$，再加上跑 $L$ 个点，总时间 $\Theta(Ln ^ 2)$，肯定超时。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, l, a[2005], vis[2005];

queue<pair<int, int>> q;
#define st first
#define nd second
#define mkp make_pair

int bfs() {
    q.push({ 1, 0 });
    while (!q.empty()) {
        int x = q.front().st, d = q.front().nd;
        q.pop();
        if (x == l)
            return d;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= i; j++) {
                int nx = (x + a[i] + a[j] - 1) % l + 1;
                if (!vis[nx]) {
                    vis[nx] = 1;
                    q.push(mkp(nx, d + 1));
                }
            }
    }
    return -1;
}

int main() {
    cin >> n >> l;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    cout << bfs();
    return 0;
}
```

### 正解
既然 $\Theta(Ln ^ 2)$ 枚举显然超时，那我们可以提前预处理一步能走几格，复杂度 $\Theta(L ^ 2 + n ^ 2)$，能过。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, l, a[2005], vis[2005], can[2005];

queue<pair<int, int>> q;
#define st first
#define nd second
#define mkp make_pair

int bfs() {
    vis[1] = 1;
    q.push({ 1, 0 });
    while (!q.empty()) {
        int x = q.front().st, d = q.front().nd;
        q.pop();
        if (x == l)
            return d;
        for (int i = 1; i < l; i++)
            if (can[i]) {
                int nx = (x + i - 1) % l + 1;
                if (!vis[nx]) {
                    vis[nx] = 1;
                    q.push(mkp(nx, d + 1));
                }
            }
    }
    return -1;
}

int main() {
    cin >> n >> l;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            can[(a[i] + a[j]) % l] = 1;
    cout << bfs();
    return 0;
}
```

题解结束了，有问题欢迎私信！

---

## 作者：DemonPlayer (赞：2)

### 思路：   
使用广度优先搜索。       
在广搜中枚举 $(p+x+y−1) \bmod L+1$ 显然不可能时间复杂度达到 $\mathcal O(n^2\times L)$，不过注意到公式中有对 $L$ 取余的部分，显然会出现大量重复的部分，不如处理出所有可能的 $(x+y)\bmod L$，在广搜中枚举这些位置，时间复杂度就变成了 $\mathcal O(n^2+L^2)$，足以通过此题。
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,l,a[2005];
bool vis[2005];
bool to[2005];

struct pos{
	int x;
	int step;
};

int bfs(){
	queue<pos> q;
	q.push({1,0});
	int nx;
	pos t;
	while(!q.empty()){
		t=q.front();
		q.pop();
		if(t.x==l){
			return t.step;
		}
		for(int i=1;i<=l;i++){
			if(to[i]){
				nx=(t.x+i-1)%l+1;
				if(!vis[nx]){
					vis[nx]=1;
					q.push({nx,t.step+1});
				}
			}
		}
	}
	return -1;
}

int main(){
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			to[(a[i]+a[j])%l]=1;
		}
	}
	cout<<bfs();
	return 0;
}
```

---

## 作者：粥2414 (赞：2)

~~一道具有一定思维难度的水题~~。
# 思路
题目要求求出到达终点的最少步数，套路地想到广搜。

每一次选取两个数的和作为行走的距离，可以提前预处理出可能向前走的距离，注意这两个数可以相同。

显然每个点不可能被到达两次。因为第二次到达是完全没有必要的。只有当目标位置是第一次到达时入队。

队列中维护两个信息：当前位置 $pos$ 和行走的步数 $step$。如果发现当前位置为 $l$，直接输出步数即可。

若直到队列为空依然无法到达 $l$ 处，则说明无解，输出 $-1$ 即可。

分析一下复杂度，每个点只会入队一次，复杂度 $O(n)$，但是每次枚举可能到达的距离时，需要暴力枚举所有可能移动的距离，复杂度 $O(n^2)$，总复杂度 $O(n^3)$，会 T 飞。

我们来把目的地公式转换一下：
$$
(p+x+y−1)\bmod L+1\\
=((p-1)\bmod L+(x+y)\bmod L)\bmod L+1
$$
发现可能的距离都需要模上 $L$，那么可以在预处理时就将距离 $\bmod L$，显然最多只会有 $L$ 个不同的取值，排序去重即可。

此时的时间复杂度被优化为了 $O(n^2)$，可以通过此题。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
inline ll read() {
	ll x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
char __sta[1009], __len;
inline void write(ll x,ll bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10 + 48, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--]);
	if(bo==3)return;
	putchar(bo ? '\n' : ' ');
}
const ll N=2009;
ll n,l;
ll a[N],b[N*N],bcnt;
struct NODE{
	ll pos,step;
};
bool bo[N];
queue<NODE>q;
int main(){
	n=read(),l=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	if(l==1){
		write(0,1);
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			b[++bcnt]=(a[i]+a[j])%l;
		}
	}
	sort(b+1,b+bcnt+1);
	bcnt=unique(b+1,b+bcnt+1)-b-1;
	q.push({1,0});
	bo[1]=1;
	while(!q.empty()){
		NODE now=q.front();
		q.pop();
		for(int i=1;i<=bcnt;i++){
			NODE to={(now.pos+b[i]-1)%l+1,now.step+1};
			if(to.pos==l){
				write(to.step,1);
				return 0;
			}
			if(!bo[to.pos]){
				bo[to.pos]=1;
				q.push(to);
			}
		}
	}
	write(-1,1);
	return 0;
}
```

---

## 作者：ljc2230 (赞：1)

[P12322 [蓝桥杯 2024 国 Java C] 瞬移](https://www.luogu.com.cn/problem/P12322)  
### 题目大意  
小蓝在数轴上 $1$ 的位置，他需要到达 $L$ 的位置，小蓝每次可以选取两个正整数 $x,y$，其中 $x,y\in a_1,a_2,a_3...a_n$ ，并向右瞬间移动 $x+y$ 的距离，然而，秘境有大小限制，如果小蓝当前位置为 $p$，则瞬移后的位置为 $(p+x+y−1)\bmod L+1$，求小蓝到达的时间，如果无法到达，输出 $-1$。  
### 思路解析  
很容易联想到使用 **BFS** 进行求解，我们用 set 存储 $(x+y) \bmod L$，并自动去重和排序。  
### 代码  
```
#include<bits/stdc++.h>
using namespace std;

const int N=4e3+5;
int n,l;
int a[N];
bool b[N];
set<int>s;

struct node{
	int p,step;
};

void bfs(){
	queue<pair<int,int> >q;
	q.push({1,0});
	while(!q.empty()){
		int p=q.front().first;
		int step=q.front().second;
		q.pop();
		if(p==l){
			cout<<step;
			return;
		}
		if(b[p])continue;
		b[p]=1;
		for(auto it:s){
			q.push({(p+it-1)%l+1,step+1});
		}
	}
	cout<<-1;
}

int main() {
	cin>>n>>l;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		s.insert((a[i]+a[j])%l);
	bfs();
	return 0;
}
```

---

## 作者：htl2025 (赞：1)

~~一道简单的 BFS 题~~

## 分析
- 遍历所有可选的 $(x,y)$ 组合，计算下一个位置为 $(p+x+y-1)\bmod L + 1$，再去重避免重复计算。

- 从起始点 $1$ 开始，利用广搜，每次到达一个新位置时记录步数，直到到达终点 $L$ 为止。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, L;
vector<int> a;

int bfs() {
    vector<int> dist(L + 1, -1);
    queue<int> q;
    unordered_set<int> move;

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            move.insert((a[i] + a[j]) % L);

    if (1 == L) return 0; // 初始位置已是终点的特殊情况

    q.push(1);
    dist[1] = 0;

    while (!q.empty()) {
        int u = q.front(); q.pop();

        for (int m : move) {
            int v = (u + m - 1) % L + 1;
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                if (v == L) return dist[v];
                q.push(v);
            }
        }
    }

    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> L;
    a.resize(n);
    for (int i = 0; i < n; ++i)
        cin >> a[i];

    cout << bfs() << '\n';

    return 0;
}

```

---

## 作者：tengteng666666 (赞：1)

### 思路：
这是一个用广度优先搜索解决的最短路径问题。我们先预处理所有可能的移动步长（即数组中两数之和模 $l$），然后从起点 $1$ 开始进行广度优先搜索，每次尝试所有有效步长移动，记录到达每个位置的最少步数。当首次到达终点 $l$ 时即可返回当前步数，若遍历完所有可能仍未到达则返回 $-1$。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,a[2001],d[2001];
bool s[2001];
queue<int>q;
int main(){
    cin>>n>>l;
    if(l==1){cout<<0;return 0;}
    for(int i=1;i<=n;i++)cin>>a[i],a[i]%=l;
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if((a[i]+a[j])%l)s[(a[i]+a[j])%l]=1;
    memset(d,-1,sizeof(d));
    d[1]=0;q.push(1);
    while(!q.empty()){
        int p=q.front();q.pop();
        for(int i=1;i<l;i++)if(s[i]){
            int np=(p-1+i)%l+1;
            if(np==l){cout<<d[p]+1;return 0;}
            if(d[np]==-1)d[np]=d[p]+1,q.push(np);
        }
    }
    cout<<-1;
    return 0;
}
```

---

## 作者：ylzpl (赞：0)

这题还是有一点点恶心的，很容易超时。

解题思路：
- 由于本题的 $n$ 很大，所以，我们需要把 $(a_i+a_j-1) \bmod l$ 的和进行预处理。为了节省时间，我们可以用 `set` 把每一种数值给存起来。因为 $(a_i+a_j-1) \bmod l$ 的值可能会多次出现从而导致浪费时间。
- 我们可以从起点 $1$ 开始搜索，每次向外扩散，也就是我们的广搜。直到找到终点 $l$ 位置。。
- 其他的就和广搜一模一样。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e7+5;
struct node{
	int x;
	int step;
};
int a[maxn],n,l;
set<int>s;
bool vis[maxn];
int bfs(){
	queue<node>q; 
	q.push({1,0});
	vis[1]=true;
	while(!q.empty()){
		node t=q.front();
		q.pop();
		if(t.x==l){
			return t.step;
		}
		for(int ss : s){
			int nx=(t.x+ss-1)%l+1;
			if(!vis[nx]&&nx>=0&&nx<=l){
				vis[nx]=true;
				q.push({nx,t.step+1});
			} 
		}
	}
	return -1;
}
signed main(){
	cin>>n>>l;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			s.inset(a[i]+a[j]);
		}
	}
	cout<<bfs();
	return 0;
}
```

---

## 作者：Zqx_Vector_2014 (赞：0)

~~又是一道搜索题~~。

这一题问从 $1$ 到要 $l$ 瞬移多少次，我们直接用广搜，在每一次瞬移后在广搜中枚举可以瞬移的距离。

- 要做出来，必须要先计算。先计算可以瞬移的距离有哪些，为了去重，我们直接用一个桶数组来存储可以瞬移的距离，又要为了给广搜剪点枝，我们再把它们都放到一个新数组里。

- 接着开一个整形 $pu$ 数组，用来记瞬移的次数。为了方便，我们将整个数组里的初始值都定为 $-1$。在特判一下，如果走不到出口，就可以直接输出 $-1$，我们再把 $pu_1$ 赋值为 $0$，因为初始位置在 $1$ 那里，所以瞬移到 $1$ 这个位置的次数为 $0$。

- 最后就是我们的大戏——广搜了，用一个队列记录每一次瞬移的位置，将 $1$ 放入队列中，表示初始位置为 $1$，若还有人广搜不会的话，直接去被模板。结束的条件是队列长度为 $0$。

# Code：

## C++：

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int>x; // BFS使用的队列
int a[2001],b[2001],pu[4000001]; // a存储输入数组，b存储所有可能的移动步数，pu存储到每个位置的最少步数
int t[2001],m; // t用于标记步数是否已存在，m记录有效步数数量

int main(){
    int n,l;
    cin>>n>>l;
    // 读取输入数组
    for(int i=1;i<=n;i++) cin>>a[i];
    
    // 预处理所有可能的x+y组合（模L后的结果）
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            t[(a[i]+a[j])%l]=1; // 标记这个步数存在
    
    // 收集所有有效的移动步数（去重后）
    for(int i=0;i<l;i++)
        if(t[i]==1)m++,b[m]=i;
    
    // 初始化步数数组，除起点1外都设为-1（表示未访问）
    for(int i=2;i<=l;i++)pu[i]=-1;
    
    // BFS开始，从位置1出发
    x.push(1);
    
    while(x.size()!=0){
        int xx=x.front(); // 当前队列头部位置
        x.pop();
        
        // 尝试所有可能的移动步数
        for(int i=1;i<=m;i++){
            int h=(xx+b[i]-1)%l+1; // 计算新位置
            if(pu[h]==-1) // 如果这个位置还没被访问过
                pu[h]=pu[xx]+1, // 更新步数
                x.push(h); // 加入队列
        }
    }
    
    // 输出到达位置L的最少步数
    cout<<pu[l]; 
    return 0;
}
```

## Java：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 读取输入
        int n = scanner.nextInt();
        int l = scanner.nextInt();
        int[] a = new int[n + 1]; // 1-based索引
        
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        
        // 预处理所有可能的x+y组合（模l后的结果）
        int[] tong = new int[l];
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                tong[(a[i] + a[j]) % l] = 1;
            }
        }
        
        // 收集所有有效的移动步数（去重后）
        int m = 0;
        int[] b = new int[l + 1]; // 最多l种不同的步数
        for (int i = 0; i < l; i++) {
            if (tong[i] == 1) {
                m++;
                b[m] = i;
            }
        }
        
        // 初始化步数数组，除起点1外都设为-1（表示未访问）
        int[] bushu = new int[l + 2]; // 1-based索引
        for (int i = 2; i <= l; i++) {
            bushu[i] = -1;
        }
        
        // BFS开始，从位置1出发
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1);
        
        while (!queue.isEmpty()) {
            int xx = queue.poll();
            
            // 尝试所有可能的移动步数
            for (int i = 1; i <= m; i++) {
                int h = (xx + b[i] - 1) % l + 1;
                if (bushu[h] == -1) {
                    bushu[h] = bushu[xx] + 1;
                    queue.add(h);
                }
            }
        }
        
        // 输出到达位置l的最少步数
        System.out.println(bushu[l]);
    }
}

```

---

## 作者：Dream_Stars (赞：0)

## 题目大意：

入口位置为 $1$，每次可以移动 $x + y$ 的距离，其中 $x, y \in \{a_1, a_2, \cdots, a_n\}$，使其从 $p$ 的位置到达 $(p + x + y - 1) \bmod L + 1$ 的位置，最终达到 $L$ 的位置就可以离开秘境，求最少的步数。\
无法到达则输出 $-1$。

## 算法分析：
可以枚举每一对有可能的 $x, y$，记录可以瞬移的距离，去重后跑一遍 bfs，求出最少步数即可，具体可见代码。\
注：记得判断超过边界的取模。

## 代码展示：
```cpp
# include <bits/stdc++.h>

//# define ll long long
//# define int long long
# define rint register int

long long read(){long long s = 0 , w = 0; char c = getchar(); while(!isdigit(c)) w |= (c == '-') , c = getchar(); while(isdigit(c)) s = (s << 1) + (s << 3) + (c ^ 48) , c = getchar(); return w ? -s : s;}
void write(long long x){if(x < 0) putchar('-') , x = ~ (x - 1); if(x > 9) write(x / 10); putchar(x % 10 | 48);}
void writesp(long long x){write(x) , putchar(' '); }
void writeln(long long x){write(x) , putchar('\n');}

using namespace std;

constexpr int N = 2000 * 2000 + 10;
//这里因为需要枚举每一个 x 和 y，所以数组应开平方的空间。

struct node {
  int x;
  int step;
};// x 指当前位置， step 指当前步数。

int n,l,m;
int a[N],cnt[N];
bool vis[N];
queue <node> q;

void bfs() {
  q.push({1 , 0});//最开始在 1 的位置，步数为 0。
  while(!q.empty()) {
    node txt = q.front();
    q.pop();
    int nx = txt.x;
    if(nx == l) {write(txt.step); return ;}//如果到达则输出当前步数即为最小步数。
	if(vis[nx] == false) {//没有来过
	  vis[nx] = true;//标记已经来过。
	  for(rint i = 1 ; i <= n ; i ++) {
	    node now;
        now.x = (cnt[i] + nx - 1) % l + 1;//注意这里对边界的取模。
        now.step = txt.step + 1;
        q.push(now);//前往。
	  }
    }
  }
  write(-1);//无法到达。
  return ;
}

signed main(){
  n = read();
  l = read();
  for(rint i = 1 ; i <= n ; i ++)
  	a[i] = read();
  for(rint i = 1 ; i <= n ; i ++)
    for(rint j = 1 ; j <= n ; j ++)
      cnt[++ m] = (a[i] + a[j]) % l;//二重循环枚举每一个可以瞬移的距离。
  sort(cnt + 1 , cnt + m + 1);
  n = unique(cnt + 1 , cnt + m + 1) - cnt - 1;//去重。
  bfs();//跑 bfs。
  return 0;
}
```

---


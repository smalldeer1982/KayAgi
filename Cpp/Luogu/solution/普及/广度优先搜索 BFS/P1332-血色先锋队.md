# 血色先锋队

## 题目背景

巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。

## 题目描述

军团是一个 $n$ 行 $m$ 列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。

## 说明/提示

#### 输入输出样例 1 解释

如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3g02cn.png)

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n,m\le500$，$1\le a,b\le10^5$。

## 样例 #1

### 输入

```
5 4 2 3
1 1
5 4
3 3
5 3
2 4
```

### 输出

```
3
1
3```

# 题解

## 作者：qianfujia (赞：229)

有一句话叫暴力出奇迹，天下第一短代码

一开始做这道题写了一个BFS，莫名其妙70，一脸懵逼

一气之下给了一个暴力，AC了（？？？）

别的不说

枚举每一个领主和感染源，求他们曼哈顿距离，感染时间为min{Dis}

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b,xa[250001],ya[250001],xb[250001],yb[250001],maxx[250001];
int main()
{
    scanf("%d%d%d%d",&n,&m,&a,&b);
    for(int i=1;i<=a;i++)scanf("%d%d",&xa[i],&ya[i]);
    for(int i=1;i<=b;i++)scanf("%d%d",&xb[i],&yb[i]);
    memset(maxx,127,sizeof(maxx));
    for(int i=1;i<=b;i++)
        for(int j=1;j<=a;j++)
            maxx[i]=min(maxx[i],abs(xa[j]-xb[i])+abs(ya[j]-yb[i]));    //核心
    for(int i=1;i<=b;i++)printf("%d\n",maxx[i]);
    return 0;
}

```

---

## 作者：llzzxx712 (赞：133)

# P1332题解
[传送门](https://www.luogu.com.cn/problem/P1332)

## 题意描述
- 给定一个 N*M 的矩阵。
- 给出 a 个点（传染源），他们每小时会向上下左右扩展一格。
- 给出 b 个询问，询问这些点被感染的时间。

## 题目分析
题目说每个被感染的人每小时会感染他四个方向的人，这跟我们的广搜思路一样。那么我们就可以进行一次 bfs ，在刚开始时将a个传染源读入并入队，将他们的感染时间标记为0，然后每次扩展时更新扩展的节点的感染时间，如果一个节点已经被感染就跳过它，这样就可以保证每个点的值就是他们被感染时的时间。

## 易错点
- 一定要标记一个点是否被感染，否则就会造成被感染的人时间再次被更新。
- 感染源在入队的时候也要标记被感染。

## AC代码

内有详细注释，保证可以看懂。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int fx[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//四个方向 
void read(int &x){//快读不解释 
	 int f=1;x=0;
	 char ch=getchar();
	 while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	 while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	 x*=f;
}
int n,m,a,b,tot; //tot表示有几个感染源 
int map[1502][1502];//map存图，每个点的值表示这个位置在什么时候 
int q[10000002][2];//q为广搜队列 
int v[1502][1502];//v表示该点是否被感染 
void bfs(){//标准广搜 
	int x,y,head=tot,tail=0;//我这里的head和tail好像反了 
	while(tail<head){ 
		tail++;
		x=q[tail][0],y=q[tail][1];
		v[x][y]=1;
		for(int i=0;i<4;i++){
			int x1=x+fx[i][0],y1=y+fx[i][1];
			if(x1<1||y1<1||x1>n||y1>m) continue;//如果超出边界，跳出 
			if(v[x1][y1]) continue;//如果已经被感染，跳出 
			v[x1][y1]=1;//标记被感染 
			map[x1][y1]=map[x][y]+1;//被感染者的感染时间 = 感染者的感染时间 + 1 
			q[++head][0]=x1,q[head][1]=y1;
		}
		
	}
}
int main(){
	cin>>n>>m>>a>>b;//n,m,a,b如题中所示 
	for(int i=1;i<=a;i++){
		int x,y;
		read(x),read(y);
		v[x][y]=1;//标记为已感染 
		q[++tot][0]=x,q[tot][1]=y;//入队 
	}
	bfs();//广搜处理出每个点在什么时间被感染 
	for(int i=1;i<=b;i++){
		int x,y;
		read(x),read(y);
		printf("%d\n",map[x][y]);//直接输出这个点在什么时候被感染 
	}
	return 0;
}

```

~~**写题解不易，点个赞呗**~~

---

## 作者：sinsop90 (赞：81)

这是本蒟蒻的第二篇题解,开门红,所以请大家$\color{blue}\text{多多见谅啦}$

#### 首先,这是一道非常不错的好题目(~~貌似是病句~~）,为什么这样说呢？

看题，我们之前做的 BFS 都是从一个点开始一层层地向外扩展,但这道题没放过我们，有多个点,而且终点也有几个。

## 但是,不慌，我们还是可以用STL大法（~~明明就是懒~~）

那么,我们这道题需要注意的地方就有这几点:

1.$\color{red}\text{5星级豪华大注意}$ 起点有多个

2.$\color{orange}\text{4星级豪华大注意}$ 每个领主被感染的时间要和输入的顺序一样输入

3.$\color{red}\text{5星级豪华大注意}$ 要考虑好怎么做

那么做到这里,有人就会问一个很好的问题:有多个起点，那我每一个起点都跑一次,每一个点上的值取最小不就可以了吗?

# nice
 
$\color{red}\text{0x3f3f3f3f3f星级豪华大注意 }$ $\color{green}\text{数据点给予了您10个TLE的暴击}$

那么应该这么做呢?

其实我们把这道题想得太复杂了,我们只需要用一个for循环跑一次就行了。

在for循环里用一个函数push到队列里就ok了

```

void p(int __x,int __y){
	node _tmp;//开一个结构体
	_tmp.x = __x;
	_tmp.y = __y;
	_tmp.steps = 0;
	Q.push(_tmp);//入队仪式
	vis[__x][__y] = true;//将感染的位置的bool vis赋为不能走
	return;
}


int _x,_y;
for(int i=1;i<=a;i++){
	cin>>_x>>_y;
	p(_x,_y);
}
```
那除了nmab和这个以外，我们还需要读入领主的位置。

这时我们用一个二维数组sx[100005][3]来记录领主的位置。

```
for(int i=1;i<=b;i++){
	cin>>sx[i][1]>>sx[i][2];
}
```
另外,我们还要定义一个数组vis记录哪里走了，这时我们的代码就是这样的了:

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b;
int sx[100005][3];
bool vis[505][505];
int maps[505][505];
struct node{
	int x,y,steps;
};
queue <node> Q;
void p(int __x,int __y){
	node _tmp;
	_tmp.x = __x;
	_tmp.y = __y;
	_tmp.steps = 0;
	Q.push(_tmp);
	vis[__x][__y] = true;
	return;
}
int main(){
	memset(vis,false,sizeof(vis));
	cin>>n>>m>>a>>b;
	int _x,_y;
	for(int i=1;i<=a;i++){
		cin>>_x>>_y;
		p(_x,_y);
	}
	for(int i=1;i<=b;i++){
		cin>>sx[i][1]>>sx[i][2];
	}
	bfs();
	for(int i=1;i<=b;i++){//最后的输出
		cout<<maps[sx[i][1]][sx[i][2]]<<endl;
	}
} 
```
由于我们已经入队了,所以我们bfs里面就不需要有入队这个东西了,直接while(!Q.empty)就行了

接着方向,总共有四个方向：

int fx[4][2] = {{0,-1},{0,1},{1,0},{-1,0}};

当我们将新的点入队之后,我们还需要记录那一个点的感染时间

maps[t.x][t.y] = t.steps;

所以for循环里就是这样了

```
for(int i=0;i<=3;i++){
	t = Q.front();
	int xx = t.x+fx[i][0];
	int yy = t.y+fx[i][1];
	if(xx>=1&&xx<=n && yy>=1&&yy<=m && !vis[xx][yy]){
		vis[xx][yy] = true;
		tmp.x = xx;
                tmp.y = yy;
		tmp.steps = t.steps+1;
		Q.push(tmp);
	}
}
maps[t.x][t.y] = t.steps;
```
整个AC代码:

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b;
int sx[100005][3];
bool vis[505][505];
int maps[505][505];
int fx[4][2] = {{0,-1},{0,1},{1,0},{-1,0}};
struct node{
	int x,y,steps;
};
queue <node> Q;
void p(int __x,int __y){
	node _tmp;
	_tmp.x = __x;
	_tmp.y = __y;
	_tmp.steps = 0;
	Q.push(_tmp);
	vis[__x][__y] = true;
	return;
}

void bfs(){
	while(!Q.empty()){
		node tmp;
		node t;
		for(int i=0;i<=3;i++){
			t = Q.front();
			int xx = t.x+fx[i][0];
			int yy = t.y+fx[i][1];
			if(xx>=1&&xx<=n && yy>=1&&yy<=m && !vis[xx][yy]){
				vis[xx][yy] = true;
				tmp.x = xx;
				tmp.y = yy;
				tmp.steps = t.steps+1;
				Q.push(tmp);
			}
		}
		maps[t.x][t.y] = t.steps;
		//cout<<"x: "<<t.x<<" y: "<<t.y<<endl;
		Q.pop();
	}
}
int main(){
	memset(vis,false,sizeof(vis));
	cin>>n>>m>>a>>b;
	int _x,_y;
	for(int i=1;i<=a;i++){
		cin>>_x>>_y;
		p(_x,_y);
	}
	for(int i=1;i<=b;i++){
		cin>>sx[i][1]>>sx[i][2];
	}
	bfs();
	for(int i=1;i<=b;i++){
		cout<<maps[sx[i][1]][sx[i][2]]<<endl;
	}
} 
```


订正:感谢@自恋的蒟蒻 2020.4.21 订正yy<=n的错误

---

## 作者：开挂老司机 (赞：33)

一道很基础的广搜题~~虽然我四次才过……~~
#### 二话不说上代码：
```
#include<iostream>
#include<cstdio>
#include<queue>//队列专用头文件
using namespace std;
inline int read()//快读了解一下
{
    int neg=1,x=0;
    char c;
    while((c=getchar())<'0'||c>'9')
      if(c=='-')
        neg=-1;
    x=c-'0';
    while((c=getchar())>='0'&&c<='9')
      x=x*10+(c-'0');
    return neg*x;
}
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};//方向数组
struct note{
	int h,l;
}s,c,a[250001];
queue<note>q;//定义队列q
int n,m,x,y,f[502][502];
int main()
{
	n=read(),m=read(),x=read(),y=read();//输入四个数
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	    f[i][j]=2147483647;
	for(int i=0;i<=m+1;f[0][i]=f[n+1][i]=0,i++);
	for(int i=0;i<=n+1;f[i][0]=f[i][m+1]=0,i++);//初始化步数
	for(int i=1;i<=x;i++)
	{
		s.h=read(),s.l=read();//输入感染源
		f[s.h][s.l]=0;//将感染源步数改为零
		q.push(s);//感染源入队列
	}
	for(int i=1;i<=y;i++)
	{
		a[i].h=read();
		a[i].l=read();//输入领主
	}
	do
	{
		s=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			c.h=s.h+dx[i],c.l=s.l+dy[i];
			if(f[s.h][s.l]+1<f[c.h][c.l])//如果新的步数更短
			{
				f[c.h][c.l]=f[s.h][s.l]+1;//改动步数
				q.push(c);
			}
		}
	}while(!q.empty());//直到队列为空
	for(int i=1;i<=y;cout<<f[a[i].h][a[i].l]<<endl,i++);//输出
	return 0;//完美结束^>^
}
```
各位
# 大佬、巨佬
不喜勿喷

---

## 作者：Sakura_Peng (赞：30)

博客题解：http://blog.csdn.net/qq\_32141117/article/details/78407421

最近一直在练简单的BFS……

看到这题只是专门搜索关于广搜标签然后找到的，题目难度也是黄色的（普及/提高-）qwq


###【思路】

这道题目就是按照题意模拟，每一秒就把已经感染的都往外延伸一圈就OK了

首先在输入的首先感染的人按输入顺序依次入队，这样就直接模拟了第0秒（开始感染周围人之前）

然后按照BFS的常用框（tao）架（lu）去套

tail指针为输入的首先感染的人的数量，head为0

然后进行周围扩散感染，注意！这里的周围扩散是指上下左右四个方向！

然后每一次扩散一个坐标，然后当前的秒数+1，将这个秒数放入b[][]数组中，这个b数组就是当前坐标被感染时的秒数。

并且每扩展一下就要将这个坐标标记已经感染了哦qwq

搜索完毕之后，依次输出b个元帅的感染数，即输出b[x][y]（x是元帅的横坐标，y是元帅的横坐标）


###【代码】

```c
#include <stdio.h>
int dx[4][2]={{0,1},{0,-1},{1,0},{-1,0}};  //代表上下左右四个方向
int que[10000001][3],num,n,m,b[1001][1001],pd[1001][1001];
/*que是队列
这里的que[][0]和que[][1]是存放横坐标和横坐标
que[][2]是存放当前的秒数
num是首先被感染的人数
nm分别是边界
b存放每个坐标被感染时的秒数
pd是判断当前这个坐标有没有被感染过*/
void BFS(int num)
{
    int tail=num,head=0; //头指针为num
    do
    {
        head++;
        for (int i=0;i<4;i++)
        {
            int x1=que[head][0]+dx[i][0];
            int y1=que[head][1]+dx[i][1]; //拓展的一个坐标进行初始化
            if (x1>=1 && x1<=n && y1>=1 && y1<=m && pd[x1][y1]==0) //判断是否出边界且是否被感染
            {
                tail++; //入队列
                que[tail][0]=x1; //横坐标进入新的队列元素
                que[tail][1]=y1; //纵坐标进入新的队列元素
                que[tail][2]=que[head][2]+1; //当前的秒数是这个节点的父节点的秒数+1
                b[x1][y1]=que[tail][2]; //将这个秒数存入b数组所对应的坐标
                pd[x1][y1]=1; //标记已经被感染
            }
        }
    }while (head<tail);
}
int main()
{
    int p,k[250001][2];
    scanf("%d%d%d%d",&n,&m,&num,&p); 
    for (int i=1;i<=num;i++)
    {
        int x;
        int y;
        scanf("%d%d",&x,&y);
        que[i][0]=x; 
        que[i][1]=y;
        pd[x][y]=1; //初始化0秒的情况
    }
    for (int i=1;i<=p;i++)
        scanf("%d%d",&k[i][0],&k[i][1]);    
    BFS(num);
    for (int i=1;i<=p;i++)
    printf("%d\n",b[k[i][0]][k[i][1]]); //输出每一个元帅所在坐标的b的值
    return 0;
}
```
【反思及注意点】

这道题主要是要看数据！这里虽然n和m是500但是元帅的个数和首先被感染的个数是n\*m所以千万不能把数组开小了！！！

我因为这个一直70分！


##以上就是蒟蒻题解的全部内容啦！


---

## 作者：Xx_queue (赞：13)

第一次写题解还不太熟练，希望大佬勿喷；

纯模拟做法****
```cpp
#include <bits/stdc++.h>
using namespace std;
struct point{
	int x;
	int y;
}A[250005],B[250005];
int dx[5]={0,1,0,-1,0},//四个方向 
    dy[5]={0,0,1,0,-1};
int mapp[505][505],mapx[505][505];
int n,m,a,b;//如题意 
int hour=1;//时长 
bool check(int k[505][505])//检查是否还有没有被感染的； 
{
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	if(k[i][j]==0)  return false;
	return true;
}
int main()
{
    memset(mapp,0,sizeof(mapp));//0设定的是没有被感染 
    cin>>n>>m>>a>>b;
    
    for(int i=1;i<=a;i++)//输入数据 
    {
    	cin>>A[i].x>>A[i].y;
    	mapp[A[i].x][A[i].y]=1;
	}
    for(int i=1;i<=b;i++)
    {
    	cin>>B[i].x>>B[i].y;
	}
	while(!check(mapp))
	{
		memcpy(mapx,mapp,sizeof(mapx));//复刻一下 
	    for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)//寻找地图上的每一个人 
	    {
	    	if(mapx[i][j]!=0&&mapx[i][j]==hour)//找到时间等于上一轮的 
	    	{
	    		for(int k=1;k<=4;k++)
	    		{
	    			int tx=i+dx[k],ty=j+dy[k];
	    			if(mapx[tx][ty]==0&&tx>=1&&tx<=n&&ty>=1&&ty<=m)//四个方向寻找有没有被传染的 
	    			{
	    				mapp[tx][ty]=mapx[i][j]+1;//传染 
					}
				}
			}
		}
		hour++;//更新时间 
	}
	for(int i=1;i<=b;i++)
	{
		cout<<mapp[B[i].x][B[i].y]-1<<endl;//因为每次都多算了一，所以还要减一 
	}
	return 0;
}
```
不喜欢下标为1的大佬请勿喷。~~~~纯属个人习惯

---

## 作者：末影地牢 (赞：8)

## 这题我一开始以为是宽搜，但是后来我又以为宽搜会超时，所以我用了~~宽搜~~暴力来做
#### 这题其实就是先输入感染的位置，再输入领主的位置，暴枚离领主的位置最近的感染的位置，求距离，输出
#### 求距离公式（k1,k2是感染的位置。k3,k4是领主的位置）：
```cpp
min(abs(k1[j]-k3)+abs(k2[j]-k4),m)
```
### 时间复杂度分析：O（nm）=5000^2=safe

## 鄙人的代码：
```cpp
#include<iostream>
#include<string>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int x,y,i,z,j,m,k1[100005],k2[100005],k3,k4;
int main()
{
 cin>>x>>x>>x>>y;
 //用暴力根本不用输入矩阵大小 
 for (i=1;i<=x;i++) scanf("%d%d",&k1[i],&k2[i]);
 //输入感染的位置 
 for (i=1;i<=y;i++) 
  {
   scanf("%d%d",&k3,&k4);
   //输入领主的位置 
   m=9666666; 
   //注意求最小值要初始化 
   for (j=1;j<=x;j++) 
    m=min(abs(k1[j]-k3)+abs(k2[j]-k4),m);
   //求每个领主离感染的距离的最小值
   //即领主的位置（x，y）减去感染的位置(x,y) 
   printf("%d\n",m);
  }
}
```


---

## 作者：24680esz (赞：7)

楼下的BFS居然没一个人用STL！！！（多好的东西啊）

浅显的BFS，是练手的好题（特别是给我这种蒟蒻练广搜用）

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
struct blood
{
    int x,y,z;
}hero[300001],t;//定义结构体（数组开大不是罪啊啊啊！！！）
queue <blood> q;//STL队列
int n,m,a,b,fx[]={0,1,0,-1},fy[]={1,0,-1,0},x,y,map[1001][1001],zx,zy;
int main()
{
    memset(map,-1,sizeof(map));
    cin>>n>>m>>a>>b;
    for (int i=1;i<=a;i++) 
    {
        cin>>zx>>zy;
        map[zx][zy]=0;
        t.x=zx;t.y=zy;
        q.push(t);//边读入边入队
    }
    for (int i=1;i<=b;i++) cin>>hero[i].x>>hero[i].y;
    while (!q.empty())
    {
        for (int j=0;j<4;j++)
        {
            t=q.front();//取首个
            x=t.x+fx[j];y=t.y+fy[j];//计算四个方向
            if (x<1||x>n||y<1||y>m||map[x][y]!=-1) continue;//如果越界或已走过，就不搜索
            t.x=x;t.y=y;t.z++;
            q.push(t); //将新结果入队
            map[x][y]=t.z;
        }
        q.pop();//队首出队
    }
    for (int i=1;i<=b;i++) cout<<map[hero[i].x][hero[i].y]<<endl;
    return 0; 
}
```

---

## 作者：gwx123456 (赞：6)

# 队列 宽搜
**此题其实就是用队列+宽搜**

首先将每个感染源进入队列,再将每个感染源相邻的进入队列,就可得每个单位与感染源的距离,从而得到时间.

上代码:


```c
#include <bits/stdc++.h>
using namespace std;
int n,m,i,j,a,b,head=0,tail=1,t[501][501],gr[501][501];
int move[4][2]={{0,1},{1,0},{-1,0},{0,-1}};
int lz[100001][2];
struct node {
	int x,y;
}que[250001];
int main(){
	cin>>n>>m>>a>>b;
	for(i=1;i<=a;i++){
		cin>>que[tail].x>>que[tail].y;
		gr[que[tail].x][que[tail].y]=1;
		tail++;
	}
	while(head<tail){
		head++;
		for(i=0;i<4;i++){
			int px=que[head].x+move[i][0],py=que[head].y+move[i][1];
			if(px>0&&py>0&&px<=n&&py<=m&&gr[px][py]!=1){
				tail++;
				que[tail].x=px;que[tail].y=py;
				gr[px][py]=1;
				t[px][py]=t[que[head].x][que[head].y]+1;
			}
		}
	}
	for(i=1;i<=b;i++)
		cin>>lz[i][0]>>lz[i][1];
	for(i=1;i<=b;i++)cout<<t[lz[i][0]][lz[i][1]]<<endl;
	return 0;
}
```


---

## 作者：xsI666 (赞：4)

## **题解 P1332 【血色先锋队】**

[题面](https://www.luogu.org/problemnew/show/P1332)

很容易看出，这是一个典型的广度优先搜索，也就是众多OIer口中的bfs。

先给各位普及一下bfs（部分来自百度）：

广度优先搜索（Breadth-First Search），又称作宽度优先搜索，或横向优先搜索，简称bfs，是一种**基础**算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。广度优先搜索的实现一般采用队列。

其实，广度优先搜索是搜索算法的基础，想要成为一名优秀的OIer，广度优先搜索和深度优先搜索都是必须掌握的！

此题告诉了我们有A个感染源，B个领主，我们可以定义一个vis数组，若当前坐标的vis值为1，那么此处就没有被感染；否则，当前坐标就已被感染。

我们可以首先用bfs算出每个坐标被感染的时间，最后直接输出领主被感染的时间即可。

话不多说，上代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//开启标准名字空间
struct Node {
	int x,y,Time;//x为横坐标，y为纵坐标，Time为被感染时间
} s[250010];//设置结构体数组维护队列
int head,tail;//分别为头指针、尾指针
int n,m,a,b,vis[505][505],c[250010],d[250010],e,f,i,j,k;//vis的意义同分析，c数组和d数组为感染源坐标，e、f为领主坐标
int P[510][510];//每个坐标被感染时间
void bfs() {//开始bfs
	tail=0;
	head=0;//初始化指针
	for(i=1; i<=a; i++) {//先把已知条件加入队列，并初始化时间
		s[++tail].x=c[i];//相当于tail++,s[tail].x=c[i]
		s[tail].y=d[i];
		s[tail].Time=0;
		P[c[i]][d[i]]=0;
	}
	while(head<tail) {//如果队列中还有元素
		head++;//头指针加1
		int h=s[head].x,r=s[head].y,tmp=s[head].Time;//取出队首元素		
		if(h+1<=n && vis[h+1][r]==0) {//往右扩展，若合法加入队列
			s[++tail].x=h+1;//更新x坐标
			s[tail].y=r;//更新y坐标
			P[h+1][r]=s[tail].Time=tmp+1;//更新时间
			vis[h+1][r]=1;//记录为已被感染
		}
        //以下每步操作意义同上
		if(h-1>=1 && vis[h-1][r]==0) {//往左扩展，若合法加入队列
			s[++tail].x=h-1;
			s[tail].y=r;
			P[h-1][r]=s[tail].Time=tmp+1;
			vis[h-1][r]=1;
		}
		if(r+1<=m && vis[h][r+1]==0) {//往上扩展，若合法加入队列
			s[++tail].x=h;
			s[tail].y=r+1;
			P[h][r+1]=s[tail].Time=tmp+1;
			vis[h][r+1]=1;
		}
		if(r-1>=1 && vis[h][r-1]==0) {//往下扩展，若合法加入队列
			s[++tail].x=h;
			s[tail].y=r-1;
			P[h][r-1]=s[tail].Time=tmp+1;
			vis[h][r-1]=1;
		}
	}
}
int main() {
	scanf("%d%d%d%d",&n,&m,&a,&b);//输入矩阵大小、感染源个数和领主个数
	for(i=1; i<=a; i++) {
		scanf("%d%d",&c[i],&d[i]);//输入感染源坐标
		vis[c[i]][d[i]]=1;//记录为已被感染
	}
	bfs();//遍历每个坐标被感染的时间
	for(i=1; i<=b; i++) {
		scanf("%d%d",&e,&f);//输入领主坐标
		printf("%d\n",P[e][f]);//直接输出被感染时间
	}
	return 0;//结束
}
```

有些人直接枚举每一个领主和感染源，求他们曼哈顿距离，但在矩阵过大时会TLE，所以bfs总是比暴力好的。

谢谢欣赏！

**管理求过！**

---

## 作者：liuqy (赞：4)

## 这道题看着底下大佬都用一些高端大气上档次做法，我就用一个低调奢华有内涵的。这其实就是一道图论题啊！！！！！！

# 我说一下我查了半天没看出的问题我把数据范围看小了......

### 这道题做一个把每个点和所有感染源横纵坐标做减法求绝对值，最小即为代码，废话不多说了，下面为代码。

```
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
const int N=550;
int m,n,A,B,ans[N*N];
struct node{
	int x,y;
}a[N*N],b[N*N];
int main(){
	
	scanf("%d%d%d%d",&m,&n,&A,&B);
	for(int i=1;i<=A;i++)scanf("%d%d",&a[i].x,&a[i].y);
	for(int i=1;i<=B;i++)scanf("%d%d",&b[i].x,&b[i].y);
	
	for(int i=1;i<=B;i++)ans[i]=0x7fffffff;
	
	for(int i=1;i<=B;i++){
		for(int j=1;j<=A;j++){
			int xx=abs(b[i].x-a[j].x)+abs(b[i].y-a[j].y);
			if(ans[i]>xx)ans[i]=xx;
		}
	}
	
	for(int i=1;i<=B;i++)printf("%d\n",ans[i]);
	
	return 0;
}
```

---

## 作者：NeosKnight (赞：3)

下面介绍一下本题的正确做法，直接暴力枚举，加上适当的一点优化，可轻松通过；


其实本题就是个求最短路径，而且他不像迷宫问题，有墙什么的，因此我们可以直接计算出每个领主与每个传染源之间的距离，也就是感染时间；这个相信大家都会，横坐标之差的绝对值加纵坐标之差的绝对值嘛，so easy！

所以我们可以轻易的得出答案；

上代码；

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int ill[300000][4];
inline int read()
{
    int x=0;char ch='!';
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x;
}
inline int abss(int x)
{
    return x>=0? x:-x;
}
inline int minn(int a,int b)
{
    return a>b? b:a;
}
int main()
{
    int m,n;
    int A,B;
    n=read();m=read();A=read();B=read();
    for(register int i=1;i<=A;i++)
    {
        ill[i][0]=read();ill[i][1]=read();
    }
    int x,y;
    for(register int i=1;i<=B;i++)
    {
        x=read();y=read();
        register int t=1500000;
        for(register int j=1;j<=A;j++)
        {
            t=minn(t,abss(x-ill[j][0])+abss(y-ill[j][1]));
            if(t==0) break;
        }
        printf("%d\n",t);
    }
    return 0;
}
```

---

## 作者：M_seа (赞：3)

```cpp
//此题解法为bfs
#include <cstdio>
#include <iostream>
#include <cstdlib>
int n, m, a, b;
int map[501][501];
int w[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};
struct node{
    int x, y, k;
}fifo[600*600];//队列
bool c[510][510];//判断之前有没有走过的标记数组
using namespace std;
void bfs(int x, int y)
{
    int i, l, r,j;
    for (i = 1; i<= m; i++)
        for (j = 1; j <= n; j++)
        c[i][j] = 0;                                             
    l = 1;
    r = 2;                                                        
    fifo[l].x = x;
    fifo[l].y = y;
    fifo[l].k = 0;                                                                     //初始化
    while (l <= r)
    {
    if (fifo[l].k < map[fifo[l].x][fifo[l].y]) map[fifo[l].x][fifo[l].y] = fifo[l].k; //如果比当前的小就更新
    for (i = 0; i < 4; i++)     //四个方向
    {
        if ((w[i][0]+fifo[l].x) >= 1 && (w[i][0]+fifo[l].x) <= m && (w[i][1]+fifo[l].y) >= 1 && (w[i][1]+fifo[l].y) <= n && c[w[i][0]+fifo[l].x][w[i][1]+fifo[l].y] == 0 && fifo[l].k+1 < map[w[i][0]+fifo[l].x][w[i][1]+fifo[l].y])          //判断是否满足条件
        {
            c[w[i][0]+fifo[l].x][w[i][1]+fifo[l].y] = 1;
            fifo[r].x = w[i][0]+fifo[l].x;
            fifo[r].y = w[i][1]+fifo[l].y;
            fifo[r++].k = fifo[l].k + 1;               //满足则入队
        }
    }
    l++;              //队首往后移
    }
}
int main()
{
    int x, y, i, j;
    scanf("%d %d %d %d", &m, &n, &a, &b);
    for (i = 1;i <= m; i++)
        for (j = 1; j <= n; j++)
        map[i][j] = 10000;         //把所有的都设为MAX
    for (i = 1; i <= a; i++)
    {
        scanf("%d %d", &x, &y);
        map[x][y] = 0;
        bfs(x, y);                          //算出每个位置最小需要时间
    }
    for (i = 1; i <= b; i++)
    {
        scanf("%d %d", &x, &y);
        printf("%d\n", map[x][y]);         //因为之前已经做过了处理，所以这里可以输入直接输出
    }
    return 0;
}

```

---

## 作者：Laser_Crystal (赞：2)

### 本蒟蒻表示bfs太烦了，而且俗话说得好，暴力碾标算，N²过百万，打个暴力，何乐而不为呢~

中心思想是进行一个贪心：输入一个领主的位置，求出与所有感染源的曼哈顿距离，再取最小值，找到最近的一个感染源，输出感染源与这个领主的曼哈顿距离。

PS：曼哈顿距离

在平面上，坐标（x1, y1）的i点与坐标（x2, y2）的j点的曼哈顿距离为：
D( i , j )=| X1-X2 |+| Y1-Y2 |.

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,n,m;
int x[100005],y[100005];//储存感染源的位置
int jl(int p,int q)//计算曼哈顿距离的函数
{
  int ans=2147483647;
  for(int i=0; i<a; i++)
  {
    int t=abs(p-x[i])+abs(q-y[i]);//曼哈顿距离
    if(t<ans) ans=t;//cout<<ans<<endl;
  }
  return ans;
}
int main()
{
  cin>>n>>m>>a>>b;
  for(int i=0; i<a; i++)
    scanf("%d%d",&x[i],&y[i]);
  int t1,t2;
  for(int i=0; i<b; i++)
  {
    scanf("%d%d",&t1,&t2);
    cout<<jl(t1,t2)<<endl;//计算最小曼哈顿距离输出
  }
  return 0;
}
```
这就是窝的暴力之旅，各位886……

---

## 作者：cz666 (赞：2)

## BFS好题啊...

~~不过我是不会告诉你我才懒得写 BFS 呢（笑）~~

### 言归正传，讲暴力（~~正解~~）做法：

首先审题，发现病毒是向四方向传播的，每一个小时只能传播一格的距离...

所以病原体感染领主的时间不就是他们之间的距离吗...

**So** 这道题可以用计算**曼哈顿距离**来水过。

曼哈顿距离就是两个点之间的横纵坐标之差的和$ abs(x1-x2)+abs(y1-y2)$。

但是但是...

a和b的数据范围是$ 1e5 $耶...$ O(ab) $，但是不想放弃暴力（别管那个纯暴力水过了的巨佬$ QAQ $），我们考虑剪枝。

首先在读入的时候用一个$ map $数组记录病原体所在位置，再在下面读入领主位置的时候判断，去掉领主就是病原体的情况。

然后暴力$ O(ab) $去算（最坏情况）。

由于$ n $只有$ 500 $，总共也就只有$ 250000 $个位置，病原体占据了最多$ 100000 $，领主如果和病原体互不侵犯位置也会占有$ 100000 $个位置，那么必定有许多领主就是和病原体相邻的。

所以当统计这个领主感染时间时答案小于等于1了，直接$ break $，去找下一个领主的最短感染时间。

### 代码实现也十分简单，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,t,a[100003],b[100003],c[100003],d[100003],ans[100003],xd[503][503];
signed main(){
	scanf("%d%d%d%d",&n,&m,&k,&t);memset(ans,0x3f3f3f3f,sizeof(ans));
	for(int i=1;i<=k;i++){scanf("%d%d",&a[i],&b[i]);xd[a[i]][b[i]]=1;}
	for(int i=1;i<=t;i++){scanf("%d%d",&c[i],&d[i]);if(xd[c[i]][d[i]])ans[i]=0;}
	for(int i=1;i<=t;i++){
		if(ans[i]&&(xd[c[i]-1][d[i]]||xd[c[i]+1][d[i]]||xd[c[i]][d[i]-1]||xd[c[i]][d[i]+1])){ans[i]=1;continue;}
		for(int j=1;j<=k;j++) ans[i]=min(ans[i],abs(c[i]-a[j])+abs(d[i]-b[j]));
	}
	for(int i=1;i<=t;i++)printf("%d\n",ans[i]);return 0;
}
```

500ms就可以跑过哦$ QwQ $

异常舒服（暴力和没开$ O2 $的$ BFS $跑一样快）

我是蒟蒻，巨佬勿喷

---

## 作者：2x6_81 (赞：2)

### ~~我是跟着算法党来的~~
> 算法：BFS

刚开始写了一个纯BFS，$\color{#e67e22}\text{50}$(不吸氧)，$\color{#f1c40f}\text{60}$(吸氧)。然后

> 突然我灵光一现 想到办法 必须试一回
>
> 我说 试一试记忆化吧

因为在搜索时，总有那么几个点（甚至几千个点）是被重复计算的，所以食用记忆化

记忆化，顾名思义，就是记住答案

就比如这样一张图：（就是样例）

![](https://cdn.luogu.com.cn/upload/pic/138.png)

标数：（感染源为$f$）
```
//初始化ans数组:(第一个感染源)
f 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```
```
//算出每个点到f的距离
f 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
```
```
//新增f
f 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 f
```
```
//第一层:
f 1 2 3
1 2 3 4
2 3 4 5
3 4 5 1
4 5 1 f
```
```
//第二层:
f 1 2 3
1 2 3 4
2 3 4 2
3 4 2 1
4 2 1 f
```
```
//第三层:
f 1 2 3
1 2 3 3
2 3 3 2
3 3 2 1
3 2 1 f
```
```
//第四层:
f 1 2 4
1 2 4 3
2 4 3 2
4 3 2 1
3 2 1 f
```
你们会发现，$4>3$，最短距离应是$3$，不是$4$，所以用$min$解决：
```
//第四层:
f 1 2 3
1 2 3 3
2 3 3 2
3 3 2 1
3 2 1 f
```
剩下的也一样

泥萌又发现了，这样的时间复杂度是$O(amn)$，时间太长。简化：

> $\because$ $4>3$ 后 $5>2$
>
> 所以直接在 $4>3$ 时停止对该支点的搜索

$Code:$
```
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <queue>
using namespace std;
#pragma GCC optimize(2) //O2优化
#pragma GCC optimize(3) //吸臭氧
struct per
{
	int x,y,s;
//  x , y , step
	per(int xx,int yy,int ss)
	{x=xx;y=yy;s=ss;}
};
queue<per> q;
bool vis[505][505];
int f[505][505];
int sx,sy,m,n;
//BFS模板
bool in(int x,int y)
{
	return x<1 or y<1 or x>m or y>n or vis[x][y];
}
void bfs(void)
{
	int dir[4][2]={0,-1,-1,0,0,1,1,0};
	q.push(per(sx,sy,0));
	f[sx][sy]=0;
	vis[sx][sy]=1;
	while(!q.empty())
	{
		int x=q.front().x,y=q.front().y,s=q.front().s;
		for(int k=0;k<4;k++)
		{
			int tx=x+dir[k][0];
			int ty=y+dir[k][1];
			if(in(tx,ty)) continue;
			if(s+1>f[tx][ty]) continue;
            //判断是否是最短距离
            //如果是,继续搜索
            //如果不是,停止搜索该支点
			q.push(per(tx,ty,s+1));
			f[tx][ty]=s+1;
			vis[tx][ty]=1;
		}
		q.pop();
	}
	while(not q.empty()) q.pop();
    //清空,为了下一次的搜索
}
int input();
int main()
{
	int a,b;
	scanf("%d%d%d%d",&m,&n,&a,&b);
	memset(f,0x7f,sizeof(f));
	while(a--)
	sx=input(),sy=input(),vis[sx][sy]=1,bfs(),memset(vis,0,sizeof(vis));//a只用一次
	while(b--)
	printf("%d\n",f[input()][input()]);//b只用一次,直接出答案
	return 0;
}
//快读
int input()
{
	int re=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) re=(re<<3)+(re<<1)+(c^48),c=getchar();
	return re;
}
```
[Myblog](https://www.luogu.org/blog/1212121is-prime/)

| 时间 | 空间 |
| :----------: | :----------: | :----------: |
| 738ms | 2.15MB |


---

## 作者：dph754132771 (赞：2)

/\*
标准做法：BFS

然而我并没有进行剪枝，所以时间大的一逼

（然而并没有差别，本题n,m在500以内，不用剪枝也可以过）

至于BFS，大家可以上网查，这里只做简单的解释，详细见程序注示

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
int n,m,a,b;
struct qq{
    int x,y;
}q[250005];
int qr,ql;//队列构造，不想用STL了。。。 
bool v[505][505];//标记是否入列，防止冗余搜索 
int map[505][505],x,y;//图 
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};//四个传染方向 
int main(){
    scanf("%d%d%d%d",&n,&m,&a,&b);// 输入啊。。。 
    memset(map,-1,sizeof(map));
    memset(v,true,sizeof(v));//重要的初始化（map其实可以不用的） 
    ql=1;
    qr=1;
    for (int i=1;i<=a;i++){ 
        scanf("%d%d",&x,&y);
        map[x][y]=0;//图的传染源，赋值为0 
        q[qr].x=x;
        q[qr].y=y;
        qr++;//该点入列 
        v[x][y]=false;//标记入列 
    }
    while (ql<qr){//如果队列不空就搜索 
        int xx,yy;
        xx=q[ql].x;
        yy=q[ql].y;
        ql++;//取出队头 
        for (int i=0;i<=3;i++){
            if (v[xx+dx[i]][yy+dy[i]]&&xx+dx[i]>0&&xx+dx[i]<=n&&yy+dy[i]>0&&yy+dy[i]<=m){
                //1 判断是否入列 2 判断是否出界（这个很重要，没有时间就会炸掉） 
                v[xx+dx[i]][yy+dy[i]]=false;
                q[qr].x=xx+dx[i];
                q[qr].y=yy+dy[i];
                qr++;//标记入列并入列（顺序没差） 
                map[xx+dx[i]][yy+dy[i]]=map[xx][yy]+1;//赋值为上一点时间+1 
            }
        }
    }
    for (int i=1;i<=b;i++){ 
        scanf("%d%d",&x,&y);
        printf("%d\n",map[x][y]);//在线输出 
    }
    return 0;
}
```
/\*
这题可以用BFS完全是因为传染的顺序有前后之分，而已被传染的不会在被传染

而队列正好是先入先出，可以确定先入的一定是感染时间比较早的人

所以不会发生感染时间计算错误

以上。

\*/

---

## 作者：Enzymii (赞：2)


//此题我认为标准做法是BFS，但总觉得BFS的代码太复杂，所以就换了一种简单的比较贪心的做法……

//毕竟瘟疫是从传染源开始的！！由于瘟疫一次只会传一格，我们可以计算某个领主与每个传染源之间的格数，然后取最小值就行了……

//下面贴代码【希望以后有神犇把BFS的题解放上来】

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
struct zb
{
    int x;
    int y;
}a[250025],b[250025];                            //传染源和领主的坐标
int d[250025];
int dis(zb x, zb y)
{
    return abs(x.x - y.x) + abs(x.y - y.y);      //两点之间的距离（格数）即为x,y坐标分别相减
}
int main()
{
    memset(d, 127, sizeof(d));                      //一个很大的赋值
    int m, n, an, bn;
    scanf("%d%d%d%d", &n, &m, &an, &bn);
    for (int i = 1; i <= an; i++)
        scanf("%d%d", &a[i].x, &a[i].y);
    for (int i = 1; i <= bn; i++)
        scanf("%d%d", &b[i].x, &b[i].y);
    for (int i = 1; i <= bn; i++)
    {
        for (int j = 1; j <= an; j++)
            if (dis(a[j], b[i]) < d[i]) d[i] = dis(a[j], b[i]);
        //计算领主距离每个传染源的格数后取最小值
        printf("%d\n", d[i]);
    }
    return 0;
}
```

---

## 作者：LikeJ (赞：2)

## ***血色先锋队***
**题目描述**
巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。
军团是一个N行M列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。
**输入格式**
第1行：四个整数N，M，A，B，表示军团矩阵有N行M列。有A个感染源，B为血色敢死队中领主的数量。
接下来A行：每行有两个整数x，y，表示感染源在第x行第y列。
接下来B行：每行有两个整数x，y，表示领主的位置在第x行第y列。
**【数据规模】**
1<=M,N<=500
1<=A,B<=100000
**输出格式**
第1至B行：每行一个整数，表示这个领主感染瘟疫的时间，输出顺序与输入顺序一致。如果某个人的位置在感染源，那么他感染瘟疫的时间为0。
输入输出样例
**输入**
5 4 2 3
1 1
5 4
3 3
5 3
2 4
**输出**
3
1
3
**说明/提示**
如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9waWMvMTM4LnBuZw?x-oss-process=image/format,png)
**分析**
这题我们可以用广搜（BFS）做
简单AC
**AC代码**
```cpp
#include<iostream>
using namespace std;
int n,m,a,b,x1,y1,x2,y2,head,tail,d[100005],f[505][505],c[505][505],st[250005][3];
int dx[5]={0,1,-1,0,0};
int dy[5]={0,0,0,1,-1};
void bfs()
{
	while(head<tail)
	{
		head++;
		for(int i=1;i<=4;i++)//四个方向
		{
			int x=st[head][0]+dx[i],y=st[head][1]+dy[i];
			if(x>=1&&x<=n&&y>=1&&y<=n&&f[x][y]==0)//边界和是否被标记过
			 {
			 	tail++;
			 	st[tail][0]=x;st[tail][1]=y;//坐标更新
			 	st[tail][2]=st[head][2]+1;//感染瘟疫的时间
			 	if(c[x][y]!=0)d[c[x][y]]=st[tail][2];//不能直接退出，要存起来，因为有多个领主
			 	f[x][y]=1;//标记
			 }
		}
	}
	return;
}
int main()
{
	cin>>n>>m>>a>>b;
	for(int i=1;i<=a;i++)
	{
	 tail++;
	 cin>>x1>>y1;
	 f[x1][y1]=1;/标记
	 st[tail][0]=x1;st[tail][1]=y1;//记录这些感染者的坐标，，让他们先存入队列当中
	}
	for(int i=1;i<=b;i++)
	{
		cin>>x2>>y2;
		c[x2][y2]=i;//这个点是i号领主
	}
	bfs();
	for(int i=1;i<=b;i++)
	 cout<<d[i]<<endl;
}
```
## ***谢谢***


---

## 作者：LB_zzm (赞：2)

```
**不用搜索就行**
 _蒟蒻代码_ 
------------

#include<bits/stdc++.h>
using namespace std;
int n,m,a,b,minn[250010];
struct cry {
	int x;//横坐标
	int y;//纵坐标
} c[250010];//传染源
struct lz {
	int x;
	int y;
} l[250010];//领主
int main() {
	cin>>n>>m>>a>>b;
	for(int i=1; i<=a; i++)cin>>c[i].x>>c[i].y;
	for(int i=1; i<=b; i++)cin>>l[i].x>>l[i].y;
    //输入
	memset(minn,127,sizeof(minn));
	for(int i=1; i<=b; i++) {
		for(int j=1; j<=a; j++)
			minn[i]=min(minn[i],abs(l[i].x-c[j].x)+ab# s(l[i].y-c[j].y));//刷新最短距离
	}
	for(int i=1; i<=b; i++)cout<<minn[i]<<endl;
    //输出
	return 0;//拜拜喽
}
```

---

## 作者：darkcoder (赞：2)

蒟蒻的第一篇题解

	#include <algorithm>
	#include <cmath>
	#include <deque>
    #include <vector>
    #include <queue>
    #include <string>
    #include <cstring>
    #include <map>
    #include <stack>
    #include <set>
    #include<cstdlib>
    #include<ctime>
    #include<iostream>
    #include<cstdio>
    using namespace std;
    int i,n,m,a,b;
    int head=0,tail=0;
    int l[500000][3];//手写队列 
    int M[600][600];//存图 
    bool vis[510][510];
    int lz[2500010][3];//记录领主，因为要按顺序输出 
    int fx[4]={0,0,1,-1};
    int fy[4]={1,-1,0,0};
    int main()
    {
	cin>>n>>m>>a>>b;
	for(i=1;i<=a;++i)
	{
		tail++;
		cin>>l[tail][1]>>l[tail][2];
		vis[l[tail][1]][l[tail][2]]=1;
	}//将感染源入队 
	for(i=1;i<=b;++i)
	{
		
		cin>>lz[i][1]>>lz[i][2];//将领主的横纵坐标入队 
	}
	do//BFS 
	{
		head++;
		int ux=l[head][1],uy=l[head][2];
		for(i=0;i<=3;++i)
		{
			int x=ux+fx[i],y=uy+fy[i];
			if(!vis[x][y]&&x>0&&x<=n&&y>0&&y<=m)
			{
				tail++;
				l[tail][1]=x;
				l[tail][2]=y;
				l[tail][0]=l[head][0]+1;
				vis[x][y]=1;
				M[x][y]=l[tail][0];
			}
		}
		
	}while(head < tail);
	for(i=1;i<=b;++i)
	{
		cout<<M[lz[i][1]][lz[i][2]]<<endl;//输出 
	}
	}

---

## 作者：Hanzire76 (赞：1)

# [我的博客](zxjnvrgvp.github.io)
以上是打广告↑

# 思路
真的需要bfs吗？
其实，我们仔细分析一下，显然，领主感染的时间就是距离领主最近的感染源感染到领主的时间。这个所谓的“距离”其实也就是感染的时间。因为瘟疫只能横纵向传播，所以距离就是x轴距离+y轴距离。

# 代码
```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cmath"
using namespace std;

const int N = 501;
int bad[N][N], n, m, a, b;

struct node
{
    int x, y, ti = 0x3f3f3f3f;
} ori[N * N], lord[N * N];

inline int get()
{
    int res = 0;
    char c = getchar();
    while (c < '0' || c > '9')
        c = getchar();
    while (c >= '0' && c <= '9')
    {
        res = res * 10 + c - '0';
        c = getchar();
    }
    return res;
}

int main()
{
    // freopen("crusade.in", "r", stdin);
    // freopen("crusade.out", "w", stdout);
    n = get(), m = get(), a = get(), b = get();
    int x, y;
    for (int i = 1; i <= a; i++)
        ori[i].x = get(),
        ori[i].y = get();
    for (int i = 1; i <= b; i++)
    {
        lord[i].x = get(), lord[i].y = get();
        for (int j = 1; j <= a; j++)
            lord[i].ti = min(abs(lord[i].x - ori[j].x) + abs(lord[i].y - ori[j].y), lord[i].ti);
        printf("%d\n", lord[i].ti);
    }
    return 0;
}
```


---

## 作者：我是蒟弱 (赞：1)

## 话不多说，步入正题
### 关于此题图的那些事
仔细观察读题可发现，瘟疫是向上、下、左、右四个方向每小时感染一人，那么可得知，点到感染源的时间就是点到感染源的最短距离
#### 最短距离怎么求
最短距离，就是两点行的差和两点列的差，他们的绝对值相加即为最短距离。

即：min_dis=abs(x1-x2)+abs(y1-y2)

### 代码步骤&处理
第一步：建一个结构体，用来保存感染源的位置(x,y)
第二步：输入感染源的位置(x,y)
第三步：输入目标位置(x,y)
第四步，从所有感染源出发，套用 **min_dis=abs(x1-x2)+abs(y1-y2)** 公式，求感染的最小值
第五步：找到最小值并输出，一直循环。

### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
struct node{
	int x,y;//保存感染源 
}yuan[100005]; 
int main(){
	int n,m,a,b;//按题意 
	scanf("%d%d%d%d",&n,&m,&a,&b);//输入 
	for(int i=1;i<=a;i++){//输入并保存感染源 
		scanf("%d%d",&yuan[i].x,&yuan[i].y);
	}
	for(int i=1;i<=b;i++){//输入目标点并计算 
		int x,y,ans=1e9;//ans设成极大值 
		scanf("%d%d",&x,&y);//输入目标点 
		for(int j=1;j<=a;j++){//寻找答案 
			ans=min(ans,abs(x-yuan[j].x)+abs(y-yuan[j].y));//找最小值 
		}
		printf("%d\n",ans);//输出答案 
	}
	return 0;
}

```


---

## 作者：千反田 (赞：1)

一道不错的广搜题 ~~本蒟蒻不会其他方法~~

需要注意一下的是，广搜起点应该是每个感染源

由于本人码风 代码可能较长 但是真正要写起来还是挺简单的

## 祭上代码
```cpp
#include<bits/stdc++.h>
#define inf INT_MAX
#define N 505
#define Num 250005
using namespace std;
const int add_x[5]={0,1,-1,0,0},
          add_y[5]={0,0,0,1,-1};//x，y增量
struct coordinate 
{
	int x,y;
}suzerain[Num],source[Num];//结构体，source为感染源，suzerain为领主位置
int n,m,a,b,ans[N][N],t[Num];//ans为答案，t为时间
void BFS()//广搜
{
	int head=0,tail=a;//尾指针为感染源数量
	while(head<tail)
	{
		++head;
		for(int i=1;i<=4;++i)
		{
			int x=source[head].x+add_x[i];
			int y=source[head].y+add_y[i];
			if(ans[x][y]==(-1)&&x<=n&&x>0&&y<=m&&y>0)//广搜核心，如果该点没有搜过且合法
			{
				++tail;
				source[tail].x=x;
				source[tail].y=y;//入队
				t[tail]=t[head]+1;//每个子节点被感染的时间就是它们的父亲节点的时间+1
				ans[x][y]=t[tail];//更新答案
			}
		}
	}
} 
int main()
{
	memset(ans,-1,sizeof(ans));
	memset(t,0,sizeof(t));
	scanf("%d%d%d%d",&n,&m,&a,&b);
	for(int i=1;i<=a;++i)
	{
		scanf("%d%d",&source[i].x,&source[i].y);
		ans[source[i].x][source[i].y]=0;//标记
	}
	for(int i=1;i<=b;++i)
	 scanf("%d%d",&suzerain[i].x,&suzerain[i].y);
	BFS();
	for(int i=1;i<=b;++i)
	 printf("%d\n",ans[suzerain[i].x][suzerain[i].y]);
        return ~~(0-0);//卖萌求通过
}
```


---

## 作者：蕾姆酱QvQ (赞：1)

---
title: 【题解】 P1332 血色先锋队
date: 2018-11-07 14:32:59
tags: 题解
categories:
top: 10
---
#### 今天%你赛又被吊打了很不爽所以写一篇唯一会的题的题解来~~开心~~一下

### 题目的大意就是让我们从不同的起点开始向外拓展，然后最先拓展的点就用一个ans的二维数组存下来，因为luogu上面数据比较水，所以不建议大家用直接暴力算的方法（因为luogu数据比较水，所以暴力亲测还可以过，但最好是用搜索的方法

### 我们可以把初始感染源都放在队列里面，然后不断的向外拓展，直到head=tail的时候退出，二维数组ans记录答案，每次记录的就是当前的ans=之前的队列拓展点+1就好了，因为广搜是单调的所以不用考虑大小问题

### 上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>

using namespace std;

int ans[1001][1001],queue[1000001][2],head,tail,n,k1,k2,m;
bool vis[1001][1001];
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};

int main()
{
	memset(ans,127/3,sizeof(ans));
	scanf("%d%d%d%d",&n,&m,&k1,&k2);
	for(int i=1; i<=k1; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		queue[++tail][0]=x; queue[tail][1]=y;
		ans[x][y]=0; vis[x][y]=1;
	}
	while(head<tail)
	{
		head++;
		for(int i=0; i<4; i++)
		{
			int sx=queue[head][0]+xx[i],sy=queue[head][1]+yy[i];
			if(sx>0 && sy>0 && sx<=n && sy<=m && !vis[sx][sy])
			{
				vis[sx][sy]=1;
				queue[++tail][0]=sx; 
				queue[tail][1]=sy;
				ans[sx][sy]=ans[queue[head][0]][queue[head][1]]+1;
			}
		}
	}
	for(int i=1; i<=k2; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%d\n",ans[x][y]);
	}
}

```

---

## 作者：湖里的杭 (赞：1)

# 宽搜BFS来一发

这是一道简单的bfs，与之前的bfs~~水题~~不同的是：

1.**队首一开始有很多个**（每个感染源都是），所以需要多次添加

2.当到达将军后不必停止，继续向下搜索

3.因为要顺序输出，所以应该**用一个ans数组存答案**

由此，我们上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,numa,numb,f,e,ans[250009];
int dx[5]={0,1,-1,0,0};
int dy[5]={0,0,0,1,-1};
bool used[509][509];
struct point//这个结构体存将军的信息，num用于方便存于ans数组之中
{
	bool yn;//yes or no
	int num;
}g[509][509];
struct node//这个结构体用于存储队列中每个节点的状态
{
	int x,y,step;
}q[250009];
void bfs()//上宽搜模(tao)版(lu)
{
	node u,v;
	while(f<=e)//当队列不为空时
	{
		u=q[f++];//取队首
		if(g[u.x][u.y].yn==1) ans[g[u.x][u.y].num]=u.step;
        //为了处理答案为0的情况
		for(int i=1;i<=4;i++)
		{
			v.x=u.x+dx[i];
			v.y=u.y+dy[i];
			v.step=u.step+1;//拓展出新的状态
			if(v.x<1 || v.x>n || v.y<1 || v.y>m) continue;
			if(used[v.x][v.y]) continue;
			if(g[v.x][v.y].yn==1) ans[g[v.x][v.y].num]=v.step;
			q[++e]=v;//入队列
			used[v.x][v.y]=1;//哈希
		}
	}
}
int main()
{
	memset(g,0,sizeof(g));
	cin>>n>>m>>numa>>numb;
	int xx,yy;
	f=1,e=0;
	for(int i=1;i<=numa;i++)
	{
		scanf("%d%d",&xx,&yy);
		used[xx][yy]=1;
		q[++e]=node{xx,yy,0};
	}
	for(int i=1;i<=numb;i++)
	{
		scanf("%d%d",&xx,&yy);
		g[xx][yy].yn=1;
		g[xx][yy].num=i;
	}
	bfs();
	for(int i=1;i<=numb;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

本蒟蒻的第三篇题解，有问题欢迎想我指出。

---

## 作者：arfa (赞：0)

# [p1332]血色先锋军

宽搜,注意数据。



```cpp
Uses math;
    var
            i,j,n,m,lord_num,inf_num,l,r,x,y,head,tail:longint;// l,r为本次感染源坐标,x,y为本次感染源要感染的人的坐标,head,tail为队列头指针和尾指针
            ask,long:array[0..1000,0..1000] of longint;//ask,long分别为是否感染和感染时间
            will:array[0..250000,1..2] of longint;//新的感染源
            dir:array[1..4,1..2] of longint;//方向
            lord:array[0..250000,1..2] of longint;//领主位置
    procedure make_direction;//建立四周感染方向
    begin
            dir[1,1]:=-1;
            dir[2,2]:=-1;
            dir[3,1]:=1;
            dir[4,2]:=1;
    end;
    procedure make_body;//初始值与输入
    var
            i:longint;
    begin
            head:=0;
            tail:=0;
            for i:=1 to inf_num do
            begin
                    read(l,r);
                    long[l,r]:=0;
                    inc(tail);//新建感染源
                    will[tail,1]:=l;
                    will[tail,2]:=r;
                    ask[l,r]:=1;
            end;
            for i:=1 to lord_num do
            begin
                    read(l,r);//记录领主位置
                    lord[i,1]:=l;
                    lord[i,2]:=r;
            end;
    end;
    function jud(a,b:longint):boolean;//判断是否超界
    begin
            if (a=0)or(b=0)or(a>n)or(b>m) then
                    exit(FALSE)
            else
                    exit(TRUE);
    end;
    begin
            read(n,m,inf_num,lord_num);
            make_body;
            make_direction;
            repeat
                    i:=head;//本次队列数(已经被感染的人)
                    for j:=1 to 4 do
                    begin
                            x:=will[i,1];//已经被感染的人的坐标
                            y:=will[i,2];
                            l:=x+dir[j,1];//下一个被感染的人的目标
                            r:=y+dir[j,2];
                            if jud(l,r) then//如果不超界
                            begin
                                    if ask[l,r]=0 then//没有被感染过
                                    begin
                                            ask[l,r]:=1;//已经被感染
                                            inc(tail);//维护队列
                                            will[tail,1]:=l;//加入新的感染源的坐标
                                            will[tail,2]:=r;
                                            long[l,r]:=long[x,y]+1;//本次感染是(i)上一个感染源感染时间+1
                                    end;
                            end;
                    end;
                    inc(head);//将对头弹出队列(本次感染源没有用了,因为4周都已经被他感染了)
            until head>tail;//没有更多的感染源(队列为空)
            for i:=1 to lord_num do
                    writeln(long[lord[i,1],lord[i,2]]);//输出
end.
```

---

## 作者：Xiao_Ling (赞：0)

###我是被背景吸引过来的，，，，（笑）

##这是一道比较简单的题，搜索模拟都行

##我这里就给出bfs+模拟的解法

#非常简单易懂，对萌新友好，dalao就不用看了，，，，

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
//注意，数据范围是500*500=250000，下面我取300000是扩大了，可以缩小 
struct pon{
    int x,y;
}p[300000];//这里是用一个结构体+队列记录即将向周围扩散瘟疫的传染源 
struct lod{
    int x,y;
}lord[300000];//这里用一个结构体数组记录各领主的位置（应为要按输入顺序输出） 
int n,m,a,b,h=0,t=0,sum=0;//h，t是队列的两个指针 
int mp[510][510]={0};//地图~~ 
int lorder[510][510]={0};//领主在地图上的标识，便于判断领主感染 
void push(int x2,int y2)//入队 
{
    t++;
    p[t].x=x2;
    p[t].y=y2;
}
void du()
{
    scanf("%d%d%d%d",&n,&m,&a,&b);
    memset(mp,0x3f3f3f3f,sizeof(mp));//这是是将mp初始化为一个“巨大的精妙的”常量 
    for(int i=1;i<=a;i++)//记录传染源位置 
    {
        int x1,y1;
        scanf("%d%d",&x1,&y1);
        mp[x1][y1]=0;//传染源感染的时间是0 
        push(x1,y1);//加入队列 
    }
    for(int i=1;i<=b;i++)//输入各位领主的位置 
    {
        int x1,y1;
        scanf("%d%d",&x1,&y1);
        lorder[x1][y1]=1;
        lord[i].x=x1;
        lord[i].y=y1;
    }
}

int main()
{
    du();//我打的快读，应该有效果吧，，，（笑） 
    while(h<t)
    {
        h++;
        int x1=p[h].x,y1=p[h].y;
        if(lorder[x1][y1]==1) //领主计数，当所有领主都被感染后，也就没有继续模拟的必要 
        {
            sum++;
            if(sum==b) break;
        }
//分4个方向去模拟传染过程，注意边界 
        if(x1>1&&mp[x1-1][y1]>mp[x1][y1]+1)
            {
                mp[x1-1][y1]=mp[x1][y1]+1;
                push(x1-1,y1);
            }
        if(x1<n&&mp[x1+1][y1]>mp[x1][y1]+1)
            {
                mp[x1+1][y1]=mp[x1][y1]+1;
                push(x1+1,y1);
            }
        if(y1>1&&mp[x1][y1-1]>mp[x1][y1]+1)
            {
                mp[x1][y1-1]=mp[x1][y1]+1;
                push(x1,y1-1);
            }
        if(y1<m&&mp[x1][y1+1]>mp[x1][y1]+1)
            {
                mp[x1][y1+1]=mp[x1][y1]+1;
                push(x1,y1+1);
            }
    }
    for(int i=1;i<=b;i++)//这时候就得顺序输出了 
        printf("%d\n",mp[lord[i].x][lord[i].y]);
    return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

一个pascal的题解

这道题数据点贼大，所以一个小小的mistake就会酿成大错

一开始我队列的head指针和tail指针都附值为1，结果wa\*9!!!

仔细查错才发现head应该为0；

嗯，题外话就说到这儿；

本题就是针对多个污染源的放射性问题，是污染区域是几何阶层倍的增加。

拿到这么一道题，首先的感觉就是拓展拓展再拓展，就想到的bfs或者dfs

再看数据n,m<=500！对于这么大的数据dfs甭想了，就上bfs吧！

但是有多个污染源啊，又不是一个，队头怎么写呢？

我们就按每个污染源依次入队，按照顺序依次扩展。

令这个矩阵为N\*M，污染源的数目为T1，询问个数为T2。

队头就可以这么写：

```cpp
 head:=0; tail:=1;
 for i:=1 to t1  do begin
  readln(x,y);
  map[x,y]:=0;
  u[x,y]:=true;
  a[tail].x:=x;
  a[tail].y:=y;
  a[tail].step:=0;
  inc(tail);
 end;
```
这只是第一步，接下来就是正儿八经的bfs了

我们写到函数里，其实就是一个拓展的模板（详见下标程）

我们把点(x,y)的感染时间设为map[x,y]的值。

需要注意的一点是，我们要判个最小值（虽然题目并没有卡你），详细看注释

但是如果数据保证递增的话可以不用取：传染的顺序有前后之分，而已被传染的不会在被传染

而队列正好是先入先出，可以确定先入的一定是感染时间比较早的人

```cpp
uses math;
type rec=record
x,y,step:longint;//x(y)该点的x(y)坐标,step该点的步数
end;
const dx:array[1..4]of integer=(-1,0,1,0);
      dy:array[1..4]of integer=(0,1,0,-1);
//坐标增量
var n,m,x,y,t1,t2,head,tail,i,j:longint;
    a:array[1..250000]of rec;//队列
    u:array[1..500,1..500]of boolean;//是否标记是否入列，防止冗余搜索 ，true代表是，false代表否
    map:array[1..500,1..500]of longint;//图（答案）
procedure bfs;
var  i,xx,yy:longint;
begin
 while head<tail do begin
  inc(head);
  for i:=1 to 4 do begin
   xx:=a[head].x+dx[i];
   yy:=a[head].y+dy[i];//下一个即将被遍历到的点的横纵坐标
   if (xx<=0)or(xx>n)or(yy<=0)or(yy>m)then continue;
   if u[xx,yy] then continue;
//一系列不符合条件的舍去，防止队列冗余
   a[tail].x:=xx; a[tail].y:=yy;
   a[tail].step:=a[head].step+1;//计算需要时间
   u[xx,yy]:=true;//标记入队
   map[xx,yy]:=min(a[tail].step,map[xx,yy]);//上面说过要取最小值，他没卡你
   inc(tail);
  end;
 end;
end;
begin
 readln(n,m,t1,t2);
 fillchar(u,sizeof(u),false);
 fillchar(map,sizeof(map),$7f);
 head:=0; tail:=1;//注意！！！！！
 for i:=1 to t1  do begin
  readln(x,y);
  map[x,y]:=0;//图的传染源，附值为0
  u[x,y]:=true;
  a[tail].x:=x;
  a[tail].y:=y;
  a[tail].step:=0;
  inc(tail);//入队完毕
 end;//队头
 bfs;
 for i:=1 to t2 do begin
  readln(x,y);
  writeln(map[x,y]);
 end;//依次输出
end.
```

---


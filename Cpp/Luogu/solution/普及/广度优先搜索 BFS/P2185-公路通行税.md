# 公路通行税

## 题目描述

在 PALMIA 国家内，有 $N$ 个城市由公路相连（每条公路恰好双向连接两个城市）。经由一条公路或多条公路，从任一城市出发可以到达其余各个城市。直到今年，公路上才要征收公路通行税。在每条公路的中间，有一征税员，从每一辆经由此路的车收取 1 PALMIA COIN（1PC）。

政府官员决定减少收税员而推行公路印花。如果一辆车欲进入一条公路，就必须将这张印花贴在窗上。

政府官员决定：一年的公路印花的价值相当于在两个最远城市之间进行 $100$ 次旅行所需的费用。两个城市之间的距离是从一个城市到达第二个城市所需经过的最少数目的公路数。

你的任务是编写一个程序计算出公路印花的价值。

## 样例 #1

### 输入

```
4 4
1 2
2 3
4 2
3 4
0 0```

### 输出

```
200```

# 题解

## 作者：Computer1828 (赞：5)

我们机房的一位大佬曾经说过：
>拿到一道题，要先把它简化了再做。

## 正文：

### 题目的大意：

在一个无向连通图中，求任意两点的最短路的最大值，答案乘上100后输出。

注意：有多组数据，当 $n$ 和 $m$ 都为 0 时结束程序

### 思路：

1、~~安息的~~ **SPFA算法**：

~~我自己就让我的程序TLE了，我还要交到评测姬上吗？~~

对于每一个图，遍历每个点，以这个点为起点做一次SPFA，得到以这个点为起点的最短路的最大值。最后把这些最大值取max，乘上100输出。

最优的时间复杂度：$O(T*(n+m))$

最坏的时间复杂度：$O(T*nm)$

2、**Dijkstra算法**：60分

因为在这个无向图中，每条边的边权都为1，所以我们可以用Dijkstra。

对于每一个图，遍历每个点，以这个点为起点做一次Dijkstra，得到以这个点为起点的最短路的最大值。最后把这些最大值取max，乘上100输出。~~（直接复制粘贴上面的）~~

时间复杂度：$O(T*nmlog_2 m)$

3、**貌似很暴力的bfs**：100分

按照SPFA的思路，遍历每个点，以这个点为起点进行bfs。

那么，**为什么bfs是正确的**：

因为每条边的边权都是1，所以我们不用像求最短路一样要做松弛操作。这也意味着，我们在bfs的时候，**每个点被第一次搜到时与起点的距离就是最短的**，所以我们不用像Dijkstra一样要用个优先队列一样找到最小的边并进行松弛操作。

又$\because$ 这是一个图。

$\therefore$ 所以我们遍历一次图只要$O(n)$的复杂度。

$\therefore$ 在遍历的时候，我们可以记录这个起点到每一个点的距离，记录的时候就可以顺便取max

时间复杂度：$O(T*nm)$

到此，我们直接写个图的bfs遍历不就行了？

我的[100分代码](https://www.luogu.com.cn/record/30531818)：

```cpp
#include<stdio.h>
#include<cstring>
#include<queue>
#define min(a,b) a<b?a:b
#define max(a,b) a>b?a:b
using namespace std;
int n,m;
struct edge{
	int to,nxt;
}e[50005];//使用链式前向星存图 
int hed[50005],cnt;//注意每组数据开始前要把hed和cnt数组清零 

inline void add(int u,int v){
	e[++cnt].to = v;
	e[cnt].nxt = hed[u];
	hed[u] = cnt;
}

bool vis[1005];//记得清零 

struct node{
	int tp,dis;//tp:当前点的编号;dis:从起点到这个点的距离 
};

int ans = -1;//最终的答案 
inline void bfs(int s){
	queue<node> q;
	q.push((node){s,0});//初始状态 
	vis[s] = true; 
	while(!q.empty()){
		node fr = q.front();
		q.pop();
		int u = fr.tp,dis = fr.dis;
		ans = max(ans,dis);//在遍历每个点的时候更新答案 
		for(int i = hed[u];i;i = e[i].nxt){
			int v = e[i].to;
			if(vis[v]) continue;
			q.push((node){v,dis+1});
			vis[v] = true;
		}
	}
}
int main(){
	while(true){
		scanf("%d%d",&n,&m);
		if(n==0 && m==0) break;
		ans = -1;//清零 
		memset(hed,0,sizeof(hed));
		cnt = 0;
		int u,v;
		for(register int i = 1;i<=m;++i){
			scanf("%d%d",&u,&v);
			add(u,v),add(v,u);//加双向边 
		}
		for(register int i = 1;i<=n;++i){//以i为起点进行bfs 
			memset(vis,false,sizeof(vis));//每次bfs开始前进行清零 
			bfs(i);
		}
		printf("%d\n",ans*100);
	}
	return 0;
}
```

---

## 作者：Ambition_ (赞：4)

首先，做题前我们先看一看这题的难度，emm省选？...OI萌新表示㩍㩍发抖。

然后看了看题，发现这题的数据其实还蛮可以做的...我们先讲解一下无向图的直径，简单来说，就是求出任意两点之间的最短路之后，找到这些最短路之间的最长路就是无向图的直径。

接下来我们来想一想做法，如果用Floyd，那么n³的复杂度是肯定过不了的啦（其实这里是我智障多想了）。然后我们发现每一条边的长度都是1，所以呢并不需要跑最短路...而是直接bfs一遍就行了，然后bfs一遍，每条边最多被枚举2遍，所以总的复杂度是O（2\*nm），虽然考虑到这道题没给出数据组数，但这个复杂度应该已经算比较优秀的了，并且常数也不大，应该是可以过的了，于是就愉快的开始码代码了。


```cpp
#pragma GCC optimize (3)
#include <bits/stdc++.h>
using namespace std;
const int N=1005;
const int M=2005;
typedef pair<int,int>P;
#define fi first
#define se second

inline void read(int &x)
{
    x=0;int f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    x*=f;
}

vector<int>e[N];
int n,m;
int d=0;
bool vis[N];

void bfs(int st)
{   
    queue<P>Q;
    memset(vis,1,sizeof vis);
    Q.push(P(0,st));
    vis[st]=0;
    while(!Q.empty())
    {
        P p=Q.front();
        Q.pop();
        int dis=p.fi;
        int now=p.se;
        d=max(d,dis);
        for(int i=0;i<(int)e[now].size();i++)
        {
            int u=e[now][i];
            if(!vis[u])continue;
            vis[u]=0;
            Q.push(P(dis+1,u));
        }
    }
}

int main()
{
    while(scanf("%d%d",&n,&m)==2&&n*m)
    {
        for(int i=0;i<N;i++)
        {
            e[i].clear();
        }
        d=0;
        for(int i=1;i<=m;i++)
        {
            int s,t;
            read(s);
            read(t);
            e[s].push_back(t);
            e[t].push_back(s);
        }   
        for(int i=1;i<=n;i++)
        {
            bfs(i);
        }
        printf("%d\n",d*100 );
    }
}
```
表示打萎了很多次，都是因为一些细节=.=然er，



为什么第四个点一直都是Too many or to few lines ！！！

然后蒟蒻的我就开始尝试各种跳出循环的方法，最后还是放弃了。去看了看AC的代码，woccc为什么他们有数据...结果发现加了这行就过了，真的是rlgl...也顺便在这边手动@kkksc03   第四个测试点的数据是不是有一些为题啊！！


```cpp
if(n==473&&m==2082) printf("0.71\n");
```
因为这个没有过的人~拿好~

没有过的人也试一试，这题真的没有省选难度啊...最多提高+吧..反正我是选提高-的..


最后给上AC代码

```cpp
#pragma GCC optimize (3)
#include <bits/stdc++.h>
using namespace std;
const int N=1005;
const int M=2005;
typedef pair<int,int>P;
#define fi first
#define se second

inline void read(int &x)
{
    x=0;int f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    x*=f;
}

vector<int>e[N];
int n,m;
int d=0;
bool vis[N];

void bfs(int st)
{   
    queue<P>Q;
    memset(vis,1,sizeof vis);
    Q.push(P(0,st));
    vis[st]=0;
    while(!Q.empty())
    {
        P p=Q.front();
        Q.pop();
        int dis=p.fi;
        int now=p.se;
        d=max(d,dis);
        for(int i=0;i<(int)e[now].size();i++)
        {
            int u=e[now][i];
            if(!vis[u])continue;
            vis[u]=0;
            Q.push(P(dis+1,u));
        }
    }
}

int main()
{
    while(~scanf("%d%d",&n,&m))
    {
        if(n==0&&m==0) break;
        for(int i=0;i<N;i++)
        {
            e[i].clear();
        }
        d=0;
        for(int i=1;i<=m;i++)
        {
            int s,t;
            read(s);
            read(t);
            e[s].push_back(t);
            e[t].push_back(s);
        }   
        for(int i=1;i<=n;i++)
        {
            bfs(i);
        }
        // printf("%d\n",d);
        printf("%d\n",d*100 );
        if(n==473&&m==2082) printf("0.71\n");
    }
}
```

---

## 作者：zqwzqwzqw (赞：3)

- ### 审一下题
看了题目，觉得这是一道最短路的题目，我们可以枚举$N$个城市，每次用单源最短路求出从当前枚举的城市到各城市间的最短路，所有最短路的值之中最大的乘以$100$即为问题的解。其实，就是要求**最短路的最大值**。

- ### 考虑算法:$Dijkstra$

#### $First$

我考虑用$Dijkstra$。因为$\max x=1000$，而图中的公路总数不超过$25000$，所以我们在存储图的时候要用**邻接表**而不是邻接矩阵。

如果直接套用经典的$Dijkstra$法，整个算法的时间复杂度将会达到$O(n^3)$,会超时。

假如用**堆优**，每更新一个最短路的值就要修改该点在堆中的位置，修该的最多次数为图的边数，所以整个算法的时间复杂度降为$O(n*(n+m*\log_n))$,可以**通过**所有数据。

#### $Then$

上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge {
	int to,next;
} g[50005];
int cnt,head[1005],dis[1005];
void lianbian(int u,int v) {
	g[++cnt]=(edge) {
		v,head[u]
	};
	head[u]=cnt;
}
int main() {
	//freopen("tolls.in","r",stdin);
	//freopen("tolls.out","w",stdout);
	while(1) {
		int n,m;
		scanf("%d%d",&n,&m);
		if(n==0&&m==0) 
			break;
		for(int i=1; i<=n; i++)
			head[i]=0;
		cnt=0;
		int ans=0;
		for(int i=1; i<=m; i++) {
			int u,v;
			scanf("%d%d",&u,&v);
			lianbian(u,v),lianbian(v,u);
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) 
				dis[j]=-1;
			dis[i]=0;
			queue<int> q;
			q.push(i);
			while(!q.empty()) {
				int u=q.front();
				q.pop();
				for(int i=head[u]; i; i=g[i].next) {
					int v=g[i].to;
					if(dis[v]==-1) {
						dis[v]=dis[u]+1;
						q.push(v);
					}
				}
			}
			for(int i=1; i<=n; i++)
				ans=max(ans,dis[i]);
		}
		printf("%d\n",ans*100);
	}
	return 0;
}
```

#### $Finally$~~(节时勿看）~~

这是一道很不错的试题。做题目不要受到平时做过的一些题目的影响，应该要各种算法都想到，不能因为平时做类似的题目时什么算法行不通就错误地认为该算法对于这一题也行不通，而不去想它，往往一个题目稍微改一下条件就可使解决它的算法有很大变化，所以这种解题思想在竞赛中是很危险的。另外，当我们优化一个算法没了思路时，可以再重新看一看题目，看看它的特殊之处，有很多题目就是因为条件的特殊性才可以在经典算法的基础上作很大改进的。

---

## 作者：Natsume_Rin (赞：2)

其实这一道题还是比较水的。

~~感觉数据有误，并不能从任意一个点出发到达所有点。~~

转化一下题意，要求求一个图 $G$ 的最长距离 $dis*100$。

如果这是一棵树，那么它的直径可以在两次 $bfs$ 中求出答案。

但是！！！这一个是图，必须要用 $n$ 次 $bfs$ 才能求出。

每一次从点 $u \in G$ 开始找到所有的 $dis_{u,v\in G}$，求一个 $max$ 即可。

代码：

```cpp
#include<bits/stdc++.h>
#define RI register int
#define min(x,y) (x)<(y)?(x):(y)
#define max(x,y) (x)>(y)?(x):(y)
#define In inline
#define Do double
#define Fl float
#define F for
using namespace std;
namespace IO {
	inline int read() {
		int X=0,w=0;
		char ch=0;
		while(!isdigit(ch)) {
			w|=ch=='-';
			ch=getchar();
		}
		while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
		return w?-X:X;
	}
	inline void write(int x){
		if(x>9){
			write(x/10);
			putchar('0'+x%10);
		}
		else{
			putchar(x+'0');
		}
	}
}using namespace IO;
const int MAXN = 1102;
int n, m, u, v;
vector<int>G[MAXN];
bool vis[MAXN];
int q[MAXN], hd, tl, s, siz, ste[MAXN], ne, step;
int Ans;
inline void bfs(int sx){
	memset(vis,0,sizeof vis);
	hd=tl=1;
	q[1]=sx;
	ste[1]=0;
	vis[sx]=1;
	while(hd<=tl){
		s=q[hd];
		step=ste[hd++];
		Ans=max(Ans,step);
		siz=G[s].size();
		for(RI i=0;i<siz;++i){
			ne=G[s][i];
			if(vis[ne]==1) continue;
			vis[ne]=1;
			++tl;
			q[tl]=ne;
			ste[tl]=step+1;
		}
	}
	return ;
}
int main(){
	while(1){
		Ans=0;
		n=read(), m=read();
		if(n==0 && m==0) break;
		for(RI i=1;i<=n;++i) G[i].clear();
		for(RI i=1;i<=m;++i){
			u=read(), v=read();
			G[u].push_back(v);
			G[v].push_back(u);
		}
		if(n==1){
			printf("0\n");
			continue;
		}
		for(RI i=1;i<=n;++i) bfs(i);
		printf("%d\n",Ans*100);
	}
	return 0;
}
```

---

## 作者：wfycsw (赞：2)

- ## 审题
两个城市之间的距离是从一个城市到达第二个城市所需经过的最少数目的公路数。

### 不难看出，这是一个所有边权为$1$的无向图。

因此，这道表面上看上去是一道最短路的题，其实是一道简单广搜题。

现在开始，上代码！
```cpp
#include<bits/stdc++.h>
#define RI register int
const int da=2147483647;
inline void write(int x){
    if(x>9) write(x/10);
    putchar(x%10+48);
}
struct wu{
	int t,n,s;
}a[50001];
int h[1002],t,ans,x,y,u,s,v,n,m,d[1002][2];bool b[1002];
inline void add(int u,int v){
	t=-~t;a[t].t=v;
	a[t].n=h[u];h[u]=t;
}
inline int max(int x,int y){return x>y?x:y;}
inline void bfs(int x){
	memset(b,0,sizeof b);
	d[1][0]=x;b[x]=1;
	for(RI t=1,w=1;t<=w;t=-~t){//广搜
		u=d[t][0];s=-~d[t][1];
		ans=max(ans,s);//随时更新答案
		for(RI i=h[u];i;i=a[i].n){
			v=a[i].t;
			if(b[v]) continue;
			b[v]=1;w=-~w;
			d[w][0]=v;d[w][1]=s;
		}
	}
}
int main(){
	while(1){
		scanf("%d%d",&n,&m);
		if(!n) return 0;//为0退出
		ans=t=0;
		memset(h,0,sizeof h);
		for(RI i=1;i<=m;i=-~i){
			scanf("%d%d",&x,&y);
			add(x,y);add(y,x);//注意是双向边
		}
		for(RI i=1;i<=n;i=-~i) bfs(i);
		write(ans*100);//记得要乘100
    		putchar('\n');
	}
}
```
望管理员通过。

---

## 作者：Lonely_NewYear (赞：2)

# 洛谷 P2185 题解

真不懂这道题问什么是蓝题，可能是因为这是水的颜色吧。

玩笑而已。

## 题目分析

这题既然要求最长的，那么最暴力的方法显然就是对每一个点进行单源最短路，时间复杂度 $O(n*(n\log n+m))$，再加上多组数据，完美的 T 掉了。

然而边权全部为 $1$，要求最短路的话 bfs 就可以了，显然 bfs 复杂度低得多，一次 bfs 只有 $O(m)$。总时间复杂度 $O(nm)$，卡得比较紧，但是以 $700ms$ 压线过了。

代码量也很少。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
struct edge
{
	int to,next;
}g[50001];
int cnt,head[1001],dis[1001];
void add(int u,int v)
{
	g[++cnt]=(edge){v,head[u]};
	head[u]=cnt;
}
int main()
{
	while(1)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		if(n==0&&m==0)
		{
			break;
		}
		for(int i=1;i<=n;i++)
		{
			head[i]=0;
		}
		cnt=0;
		int ans=0;
		for(int i=1;i<=m;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			add(u,v);
			add(v,u);
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				dis[j]=-1;
			}
			dis[i]=0;
			queue<int> q;
			q.push(i);
			while(!q.empty())
			{
				int u=q.front();
				q.pop();
				for(int i=head[u];i;i=g[i].next)
				{
					int v=g[i].to;
					if(dis[v]==-1)
					{
						dis[v]=dis[u]+1;
						q.push(v);
					}
				}
			}
			for(int i=1;i<=n;i++)
			{
			    ans=max(ans,dis[i]);
			}
		}
		printf("%d\n",ans*100);
	}
	return 0;
}
```

谢谢观看！

---

## 作者：a18981826590 (赞：1)

# [P2185 公路通行税](https://www.luogu.com.cn/problem/P2185)
## 解题思路
这道题的关键其实就是求无向图的直径（即为任意两点最短路的最大值）。

这道题要求任意两点间最短路的最大值，可以找到从每个点出发到距其最远点间的距离，最后取最大值。

由于这道题的边权均为 $1$，我们可以直接使用广度优先搜索求单源最短路径，这样搜到某点时就是最短路。

最后别忘记将答案乘 $100$。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>a[1010];
int b[1010],m,n,x,y,z;
queue<int>c;
int main(){
	while(cin>>n>>m){
		if(!m&&!n) return 0;
		while(m--){
			cin>>x>>y;
			a[x].push_back(y);
			a[y].push_back(x);
		}
		z=0;
		for(int i=1;i<=n;i++){
			memset(b,-1,sizeof(b));
			b[i]=0;
			c.push(i);
			while(!c.empty()){
				x=c.front();
				c.pop();
				for(int i=0;i<a[x].size();i++){
					if(b[a[x][i]]==-1){
						b[a[x][i]]=b[x]+1;
						c.push(a[x][i]);
						z=max(b[a[x][i]],z);
					}
				}
			}
		}
		cout<<z*100<<'\n';
		for(int i=1;i<=n;i++) a[i].clear();
	}
	return 0;
}
```

---

## 作者：niuzh (赞：1)

## 思路

考虑枚举每个点到其余点的最短路再取最大值。

接下来考虑最短路的算法，由于 $m$ 较大，所以无法使用 Dijkstra 和 SPFA，但每条路径的权值都为 $1$，所以可以用 bfs。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+10,M=25e3+10;
vector<int> edge[N];
int dis[N];
bitset<N> vis;
void bfs(int s)
{
	memset(dis,0x3f,sizeof(dis));
	vis.reset();
	queue<int> q;
	q.push(s);
	dis[s]=0;
	while (!q.empty())
	{
		int u=q.front();
		q.pop();
		if (vis[u])
		{
			continue;
		}
		vis[u]=1;
		for (auto v:edge[u])
		{
			if (dis[v]>dis[u]+1)
			{
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
}
signed main()
{
	int n,m;
	while (cin>>n>>m)
	{
		if(!(n&&m))
		{
			break;
		}
		int ans=-1;
		for (int i=1; i<=m; i++)
		{
			int u,v;
			cin>>u>>v;
			edge[u].push_back(v);
			edge[v].push_back(u);
		}
		for (int i=1; i<=n; i++)
		{
			bfs(i);
			for (int j=1; j<=n; j++)
			{
				ans=max(ans,dis[j]);
			}
		}
		cout<<ans*100<<'\n';
		for (int i=1; i<=n; i++)
		{
			edge[i].clear();
		}
	}
	return 0;
}
```

---

## 作者：dlzlj_2010 (赞：1)

题意很好理解，就是要求出任意两点之间的最短距离中的最大值乘以 $100$。
### 解法：
看到最短路，第一时间想到的就是 Dijkstra 和 SPFA 这样的最短路算法。  
然而，发现 $1\le N\le1000,1\le M\le25000$，我们记数据组数为 $T$，则跑 $N$ 遍 Dijkstra 的时间复杂度为 $O(T\,nm\log m)$，显然会超时。  
那应该怎么办呢？注意到每条边的边权都为 $1$，那么我们可以使用 bfs 来处理最短路，时间复杂度为 $O(T\,nm)$ 的，足够通过本题。
## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
const int N=1005,M=25005;
vector<int>e[N];
int dis[N],vis[N];//距离，访问标记
int n,m;
void bfs(int s){//bfs，与Dijkstra 相似
	memset(dis,0x3f,sizeof dis);//最短路初值设为正无穷
	memset(vis,0,sizeof vis);
	queue<int>q;//bfs用队列
	q.push(s),dis[s]=0;//起点入队，其到其本身的最短路长度为0
	while(!q.empty()){
		int u=q.front();q.pop();
		if(vis[u])continue;
		vis[u]=1;//未访问，标记后向下继续遍历
		for(auto v:e[u]){
			if(dis[v]>dis[u]+1)//如果最短路可以更新
				dis[v]=dis[u]+1,q.push(v);//更新最短路，入队
		}
	}
}
signed main(){
	while(cin>>n>>m,n!=0&&m!=0){
		for(int i=0;i<N;i++)e[i].clear();//清空邻接表
		ll ans=-1;
		for(int i=1;i<=m;i++){
			int u,v;
			cin>>u>>v;
			e[u].push_back(v),e[v].push_back(u);
		}
		for(int i=1;i<=n;i++){//以每个点为起点进行搜索
			bfs(i);
			for(int j=1;j<=n;j++)ans=max(ans,1ll*dis[j]);//距离取最大值
		}
		cout<<ans*100<<'\n';//乘以100后输出
	}
    return 0;
}
```

---

## 作者：Leopard_cats (赞：0)

本蒟蒻第一次写题解，若有纰漏敬请指正。

[题目传送门](https://www.luogu.com.cn/problem/P2185)

## 思路：
**BFS**，**对于每一个图而言，从每一个点开始遍历全图，所得的最远距离就是题目所求。**

思路分析，为什么这道题 BFS 可行：

读题后不难发现，每个无向图中，**点与点之间的距离都是 $1$**，因此**不会出现走一条路的距离大于走两条边的距离这种情况**，所以用 BFS 遍历一遍即可，每个点第一次遍历到时的距离就是离起点的最短距离，在这些最短距离中取最长的即可。因为没规定起点，所以要**每个点都当做起点遍历一次全图。注意是无向图，所以每次存图要存来回两条边。**

此外，**记得认真审题**，题目输入里有多个图，`0 0` 才是结束输入。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+1;
vector <ll> a[N];  //可以用 vector 存边，效果和链式前向星一样
queue <ll> qx;  //存点的队列 
queue <ll> qt;  //存距离的队列 
ll n,m,x,y,ans;
bool b[N];  //标记某个点是否被遍历过 
void bfs(ll k){
	b[k]=1;
	qx.push(k);
	qt.push(0);
	while (!qx.empty() && !qt.empty()){
		ll tmp_point=qx.front();
		ll tmp_step=qt.front();
		ll tmp=a[tmp_point].size();
		for (ll i=0;i<tmp;i++){
			if (!b[a[tmp_point][i]]){
				qx.push(a[tmp_point][i]);
				qt.push(tmp_step+1);
				b[a[tmp_point][i]]=1;
				ans=max(tmp_step+1,ans);
			}
		}
		qx.pop();
		qt.pop();
	}
	//遍历一次全图，得出该图以点 k 为起点可得的的最远距离 
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	while (n && m){
		for (ll i=1;i<=m;i++){
			cin>>x>>y;
			a[x].push_back(y);  //存 x 到 y 的边 
			a[y].push_back(x);  //存 y 到 x 的边 
		}
		for (ll i=1;i<=n;i++){
			bfs(i);
			memset(b,0,sizeof(b));
		}
		cout<<ans*100<<endl;
		ans=0;
		for (ll i=1;i<=n;i++){
			a[i].clear(); 
		}
		cin>>n>>m;
	}
}
```

---

## 作者：Lian_zy (赞：0)

今天在洛咕划水的时候看见的~~划水有害健康~~，觉得非常水，于是就写篇题解。

# 题目传送门
[**戳我戳我**](https://www.luogu.com.cn/problem/P2185)

# 题目大意

在一个无向连通图中寻找任意两个点的最短路的最大值。

# 分析

由于图是是无权的，所以跑 BFS 就可以了，暴力的求出每个点到其他点的最短路，一次 BFS 的时间复杂度为 $O(n + m)$，$n$ 次的 BFS 就为 $O(n(n + m))$，由于 BFS 是第一次搜到即为最短路，所以开一个变量一边搜一遍取最大值就好了。

# 复杂度分析 & 代码
最终的复杂度为 $O(Tn(n+m))$，勉强卡过。

这题还有一个坑点，就是数据有锅，$m \le 0$ 的情况和图不连通的情况也需要考虑。

``` cpp
#include <queue>
#include <vector>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 1e3 + 10;
queue<int> q;
bool vis[maxn];
vector<int> G[maxn];
int n, m, x, y, ans, dis[maxn];
void bfs(int u) {
	memset(dis, 0, sizeof(dis));
	memset(vis, false, sizeof(vis));
	q.push(u);
	vis[u] = true;
	while (q.size()) {
		x = q.front();
		q.pop();
		ans = max(ans, dis[x]);
		for (int v : G[x]) {
			if (vis[v]) continue;
			vis[v] = true;
			dis[v] = dis[x] + 1;
			q.push(v);
		}
	}
	return ;
}
int main() {
	while (scanf("%d %d", &n, &m) == 2 && n && m) {
		if (m < 0) {
			puts("0");
			continue;
		}
		for (int i = 1; i <= n; i++) G[i].clear();
		while (m--) {
			scanf("%d %d", &x, &y);
			G[x].push_back(y);
			G[y].push_back(x);
		}
		ans = 0;
		for (int i = 1; i <= n; i++) bfs(i);
		printf("%d\n", ans * 100);
	}
	return 0;
}
```

---

## 作者：qiliu (赞：0)

~~不蓝吧？怎么想这道题都不蓝吧？~~

-------

### 思路

经过观察，我们发现这道题其实就是让我们找出两个点，是他们的最短路径最长。

然而全源（Floyd，$ O(n^3) $ 的复杂度）显然被卡掉了。

所以我们进一步观察，发现每一条边的权显然是 1。于是显然可以对于每一个点跑 bfs 求最短路（bfs 第一次搜到一个点是走过的路必然是最短路之一），这样时间复杂度是 $ O(n^2) $，显然不会超时。

~~所以这道题不太蓝啊。~~

### Code

有注释，请放心食用。

```cpp
#include<bits/stdc++.h>
#define int long long
#define DEBUG(x) cerr<<#x<<'='<<x<<endl
using namespace std;
const int N=4005;
int n,m;
vector<int>a[N]; //vector存图 
bool vis[N];//vis是为了防止bfs反复横跳 
int ans;
void bfs(int s)
{
	memset(vis,0,sizeof(vis));//尽量别用memset，但是我懒得写了 
	queue< pair<int,int> >q;//第一项指的是当前点，第二项指的是当前走过的路径长度 
	q.push(make_pair(s,0));
	vis[s]=1;
	while(!q.empty())
	{
		int now=q.front().first;
		int now_ans=q.front().second;
		ans=max(ans,now_ans);
		q.pop();
		for(int i=0;i<a[now].size();i++)
		{
			int to=a[now][i];
			if(!vis[to])
			{
				q.push(make_pair(to,now_ans+1));
				vis[to]=1;
			}
		}
	}
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    while(cin>>n>>m)
    {
    	if(n==0&&m==0)
    	break;
    	for(int i=0;i<N;i++)
    	a[i].clear();//多测不清空...... 
    	for(int i=1;i<=m;i++)
 	   {
   		 	int u,v;
    		cin>>u>>v;
    		a[u].push_back(v);
    		a[v].push_back(u);
		}
    	ans=-1;//别忘了初始化！ 
		for(int i=1;i<=n;i++)
		{
			bfs(i);
		}
		cout<<ans*100<<endl;//注意是旅行一百次！ 
	}
    //fclose(stdin);
    //fclose(stdout);
	return 0;
}

```


---

## 作者：happybob (赞：0)

由于边权为 $1$，直接广搜并且 $O(n^2)$ 枚举两点后取最大值即可通过本题。并不需要用到最短路等其他做法。注意多测清空。复杂度比最短路算法更优，无需注意什么其他问题。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <queue>
#include <cmath>
#include <cstring>
using namespace std;

const int N = 1005;
vector<int> G[N];
int d[N][N], n, m;

void bfs(int u)
{
	d[u][u] = 0;
	queue<int> q;
	q.push(u);
	while (q.size())
	{
		int ux = q.front();
		q.pop();
		for (int j : G[ux])
		{
			if (d[u][j] == -1)
			{
				d[u][j] = d[u][ux] + 1;
				q.push(j);
			}
		}
	}
}

int main()
{
	while (scanf("%d%d", &n, &m) && !(!n && !m))
	{
		for (int i = 1; i <= n; i++)
		{
			G[i].clear();
			for (int j = 1; j <= n; j++) d[i][j] = -1;
		}
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			scanf("%d%d", &u, &v);
			G[u].emplace_back(v);
			G[v].emplace_back(u);
		}
		int maxn = 0;
		for (int i = 1; i <= n; i++) bfs(i);
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++) maxn = max(maxn, d[i][j]);
		}
		printf("%d\n", 100 * maxn);
	}
	return 0;
}
```


---

## 作者：nzcnnr (赞：0)

## 题意理解
虽然背景很多，实际上就是让在一个加权无向联通图中找到最长路（权值为一）。
## 解法
很明显，因为所有的权值均为一，所以可以理解为没有权值，这样就只用考虑经过路径的多少。

对于固定点出发的图内可以用宽搜和深搜维护最大值，本题解选用用时较少的宽搜。而题目中要求的并不是固定点在图中的最长路，而是图中所有点与点之间的最长路，所以说可以使用循环去一一求解每一个点的最长路，此时在进行比较维护这些数的最大值，即为图中的最长路。
## 注意事项
本题是要分组的，如果不分组只有 $20$ 分。

同时，每一组数据都需清空一次图，不然会寄。
## Code 
```c
#include<stdio.h>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
vector<int>map[1005];//vector建图 
int n,m;
long long bfs(int a){//bfs搜索
	bool check[n+5]={0};//是否有没有走过
	long long dis[n+5]={0};//到每个点的距离
	queue<int>f;
	check[a]=1;
	f.push(a);
	while(f.size()!=0){
		int k=f.front();
		f.pop();
		for(int i=0;i<map[k].size();i++){
			if(check[map[k][i]]==0){
				check[map[k][i]]=1;
				f.push(map[k][i]);
				if(dis[map[k][i]]>p[k]+1||dis[map[k][i]]==0){
					dis[map[k][i]]=p[k]+1;
				}//因为距离是经过边数最少的路径，所以要判一下
			}
		}
	}
	sort(dis+1,dis+1+n);
	return dis[n];//怪异的求最大值
}
int main(){
	while(1!=2){//死循环
		for(int i=1;i<=n;i++){
			map[i].clear();//每一组vector都重置一次
		}
		scanf("%d%d",&n,&m);
		if(n==0&&m==0){
			return 0;	//循环结束也是程序结束的标志：m,n都等于零
		}
		for(int i=1;i<=m;i++){
			int x,y;
			scanf("%d%d",&x,&y);
			map[x].push_back(y);
			map[y].push_back(x); //双向图两边都存一次
		}
		int k1,k2;
		long long Maxn=-1;
		for(int i=1;i<=n;i++){
			Maxn=max(Maxn,bfs(i));//统计最大值
		}
		Maxn*=100;
		printf("%lld\n",Maxn);		
	}

}
```

---


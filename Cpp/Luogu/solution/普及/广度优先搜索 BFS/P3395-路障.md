# 路障

## 题目描述

B 君站在一个 $n\times n$ 的棋盘上。最开始，B君站在 $(1,1)$ 这个点，他要走到 $(n,n)$ 这个点。

B 君每秒可以向上下左右的某个方向移动一格，但是很不妙，C 君打算阻止 B 君的计划。

**每秒结束的时刻**，C 君 会在 $(x,y)$ 上摆一个路障。B 君不能走在路障上。

B 君拿到了 C 君准备在哪些点放置路障。所以现在你需要判断，B 君能否成功走到 $(n,n)$。

**保证数据足够弱：也就是说，无需考虑“走到某处然后被一个路障砸死”的情况，因为答案不会出现此类情况。**

## 说明/提示

样例解释：

以下 0 表示能走，x 表示不能走，B 表示 B 君现在的位置。从左往右表示时间。

```
Case 1:
0 0    0 0    0 B  (已经走到了)
B 0    x B    x 0
```
```
Case 2:
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0
0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0
B 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B君可以走到终点)
```

数据规模：

防止骗分，数据保证全部手造。

对于 $20\%$ 的数据，有 $n\le3$。

对于 $60\%$ 的数据，有 $n\le500$。

对于 $100\%$ 的数据，有 $n\le1000$。

对于 $100\%$ 的数据，有 $T\le10$。

## 样例 #1

### 输入

```
2

2
1 1
2 2

5
3 3
3 2
3 1
1 2
1 3
1 4
1 5
2 2```

### 输出

```
Yes
Yes```

# 题解

## 作者：Invisible_Blade (赞：81)

首先的一点是：

由于数据有T组，所以每次计算完后要重置所有用过的数据。

用结构体手写队列，加上广搜，每秒广搜完所有可能走过的地方后，再放路障。

以下的代码是定义数据的代码。
```
int T,n,x,y,nx,ny,dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
struct q{
	int x,y;
}que[10000010],no[1001];
bool pd[1001][1001];
```
在上面的代码里，T是要处理的T组数据，n是棋盘大小，x，y是输入路障的坐标，nx，ny是待会广搜要用到的下一步走到的坐标，dx与dy是方向数组。
在结构体里面，que数组是用来广搜的，no数组是来存放路障的，no[i]代表第i秒结束时放路障的坐标。

下面的代码是主函数。
```
int main(){
	scanf("%d",&T);
	for(int e=1;e<=T;e++){
		scanf("%d",&n);
		for(int i=1;i<=2*n-2;i++){
			scanf("%d %d",&x,&y);
			no[i].x=x,no[i].y=y;
		}
		bfs();
		reset();
	}
	return 0;
}
```
bfs是广搜，输出此组数据能否到达。reset是重置函数。

以下是重置函数。
```
void reset(){
	memset(que,0,sizeof(que));
	memset(pd,0,sizeof(pd));
	memset(no,0,sizeof(no));
}
```
接下来重头戏，精华！！！！！广搜怎摸写？
```
void bfs(){
	int t=1,head=1,tail=2;
	que[head].x=1,que[head].y=1,pd[1][1]=1;
	do{
		for(int i=0;i<4;i++){
			nx=que[head].x+dx[i];
			ny=que[head].y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&pd[nx][ny]==0){
				que[tail].x=nx;
				que[tail].y=ny;
				tail++;
				pd[nx][ny]=1;
			}
		}
		pd[no[t].x][no[t].y]=1;
		t++;
		head++;
	}while(head<tail);
	for(int i=tail;i>=1;i--){
		if(que[i].x==n&&que[i].y==n){
			printf("Yes\n");
			return;
		}
	}
	printf("No\n");
	return;
}
```
在这里t是记录第t秒的，配合no数组，head是头指针，tail是尾指针。
先把que[head].x与.y标记为（1，1），pd[1][1]=1为（1，1）走过了。
do while循环里，for循环为4个方向，nx，ny为下一个走向，如果符合条件那么把他存到尾指针，tail++，把他标记为走过。
当这个head四个方向都判断完后，也就是这一秒走过后，用pd[no[t].x][no[i].y]=1来放路障，标记为1相当于不能走了。
do while 外的for循环为在que数组中找有没有到达（n，n）的点，如果有，输出Yes换行return，循环完毕说明没有到达，就输出No换行return。

所以完整代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int T,n,x,y,nx,ny,dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
struct q{
	int x,y;
}que[10000010],no[1001];
bool pd[1001][1001];
void bfs(){
	int t=1,head=1,tail=2;
	que[head].x=1,que[head].y=1,pd[1][1]=1;
	do{
		for(int i=0;i<4;i++){
			nx=que[head].x+dx[i];
			ny=que[head].y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&pd[nx][ny]==0){
				que[tail].x=nx;
				que[tail].y=ny;
				tail++;
				pd[nx][ny]=1;
			}
		}
		pd[no[t].x][no[t].y]=1;
		t++;
		head++;
	}while(head<tail);
	for(int i=tail;i>=1;i--){
		if(que[i].x==n&&que[i].y==n){
			printf("Yes\n");
			return;
		}
	}
	printf("No\n");
	return;
}
void reset(){
	memset(que,0,sizeof(que));
	memset(pd,0,sizeof(pd));
	memset(no,0,sizeof(no));
}
int main(){
	scanf("%d",&T);
	for(int e=1;e<=T;e++){
		scanf("%d",&n);
		for(int i=1;i<=2*n-2;i++){
			scanf("%d %d",&x,&y);
			no[i].x=x,no[i].y=y;
		}
		bfs();
		reset();
	}
	return 0;
}
```
禁止抄袭！！！看我写题解这么辛苦的份上给个赞吧~~~

---

## 作者：Atmizz (赞：34)

# 其实这个题完全是一个BFS的简单题。
$updata$ $2019.11.7$

我使用了BFS的做法，我觉得十分好理解。有一点要说明，STL的queue虽然好打，但是它比手写的队列运行速度要慢的，差别应该也不是很大吧。

### 大家先注意这个点：
每秒结束的时刻，大家注意，是在每一秒之后，而并不是在一开始就有路障，这就是一个坑，$C$君会在$(x,y)$上摆一个路障。B君不能走在路障上（**~~C君有点坏~~**）。

这个题先可以用数组存储一下路障的坐标，然后在每一秒结束后，将路障放置，然后$B$君就不可以走。

我觉得大家（~~不包括大佬~~）如果不会的话，应该是在摆路障的问题上浪费了时间，其实，真的很简单！！！

详细解释在代码中~~~~
### code：


------------

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<stack>
using namespace std;
int n,zx[2000],zy[2000],k,xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};//n是矩阵的大小，zx，zy是障碍的坐标，k是数据组数，xx，yy是四个移动方向 
bool map[1001][1001],vis[1001][1001],flag;//map是地图，vis看是否被访问，flag看是否可以到达 
struct node
{
	int x,y,t;//记录坐标和现在的时间 
};
void bfs(int x,int y,int t)
{
	queue<node>q;//我喜欢用STL的队列，不喜欢手动模拟的，因为我懒啊 
	node now,net;
	now.x=x;now.y=y;now.t=t;
	q.push(now);
	while(!q.empty()) {
		now=q.front();//取出队头元素 
		q.pop();//出队 
		int a=now.x;int b=now.y;int c=now.t;//便于后面码代码 
		if(a==n && b==n) {//到了终点 
			flag=1;//改变标志 
			break;//直接退出循环 
		}
		map[zx[now.t-1]][zy[now.t-1]]=1;//要点，障碍降落，因为t是从0开始，所以要减1 
		for(int i=0;i<4;i++) {//枚举四个方向 
			int dx=a+xx[i];int dy=b+yy[i];
			if(dx>=1 && dx<=n && dy>=1 && dy<=n && map[dx][dy]==0 && vis[dx][dy]==0) {//在矩阵中，无障碍，无访问 
				net.x=dx;net.y=dy;net.t=c+1;//时间加加 
				vis[dx][dy]=1;
				q.push(net);//进入队列 
			}
		}
	}
}
int main()
{
	scanf("%d",&k);
	while(k--) {//一般是到0就结束
		scanf("%d",&n);
		memset(map,0,sizeof(map));//初始化！！ 
		memset(vis,0,sizeof(vis));
		flag=0;//看是否可以到达终点的标志 
		for(int i=1;i<=2*n-2;i++)//输入障碍 
			scanf("%d%d",&zx[i],&zy[i]);
        vis[1][1]=1;//起点肯定被访问了 
		bfs(1,1,0);//广搜 
		if(flag==1)//判断 
			printf("Yes\n");
		else
			printf("No\n");
	}
}
```


---

## 作者：lowww666 (赞：26)

简单灌水法

由于从a0,b0到a1,b1的最短路径长为|a1-a0|+|b1-b0|-1，所以在这个时间之后的路障都可以忽略。边读入边处理，之后灌水法bfs推一遍，看看能不能达到终点。代码：
```cpp
#include<cstdio>
using namespace std;
int f[1001][1001],n,t,x,y;
int main()
{
    scanf("%d",&t);
    for(int q=1;q<=t;q++)
    {
        scanf("%d",&n);
        for(int i=1;i<=2*n-2;i++)
        {
            scanf("%d%d",&x,&y);
            if(x==n&&y==n&&x+y-2<i)
            {
                printf("No\n");
                break;
            }
            if(x+y-2>i)
                f[x][y]=-1;
        }
        f[1][1]=1;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if((f[i-1][j]==1||f[i][j-1]==1)&&f[i][j]!=-1)
                    f[i][j]=1;
        if(f[n][n]==1)
            printf("Yes\n");
        else
            printf("No\n");
        if(q!=t)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                f[i][j]=0;
    }
}

```

---

## 作者：喝烘箱 (赞：24)

# 这么简单的题居然是D1T1！！！！
## 我都惊到了！！！

咳咳，不皮了，先说一下思路。
#### 广搜从起点开始搜索太慢了！而且没有必要！~~虽然要过这道题的数据是轻轻松松~~
#### 我们可以直接广搜路障！！！
#### 然后时间复杂度就会直接缩小到天的另一边去！！！
首先！这是一个矩阵！    

所以在无障碍的情况下这个熊孩子跑到每一个点的时间可以用数组下标直接算出来   
因为我们到的每一个点的最短距离就是这两个点的横坐标之差与纵坐标之差的和

| _1_ | _2_ | _3_ | _4_ | _5_ | _6_ | _7_ | _8_ | _9_ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 | 起点 |-- | -- | -- | -- | -- | -- | -- |
| 3 |  |  |  |  |  |  |  |   |
| 4 |  |  |  |  |  |  |  |  |
| 5 |  |  |  |  |  |  | o |  |
| 6 |  | o |  |  |  |  |  |  |
| 7 |  |  |  |  |  |  |  |  |
| 8 |  |  |  |  | o |  |  |  |
| 9 |  |  |  |  |  |  |  | o |

很容易就能发现，以任意一个点为终点都可以与起点连成一个矩形    
然后又因为只能向上下左右四个方向移动。。。    
所以步数最短的走法就是一直想终点方向走，即只向下或向右走。。。    
之后后就不用我说了吧    
~~这其实是小学奥数~~

其次！如果在某一时刻落下路障时这个熊孩子已经走过了这个点，那这个路障就和没放完全没有区别，因为最短距离一定是一直向下或向右走，所以只要过了那个位置就再也不会走到那个位置了！

所以那个路障就可以当做没有出现过！

还有一件有意思的事，就是当所有的路障都落下来的时候，如果这些路障之间有空隙，那么他们就不能拦住这个熊孩子！

举个栗子，我们用X来代表路障，具体来看一下

| 1 | 2 | 3 | 4 |5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 |  |   |   |   |   |
| 3 |  |  |  | X |X |
| 4 |  |  | X |  |  |
| 5 |  |  |  |  |  |
| 6 |  | X |  |  | end |

这样就拦不住

| 1 | 2 | 3 | 4 |5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 |  |  |  |  |  |
| 3 |  |  |  | X |X |
| 4 |  |  | X |  |  |
| 5 |  | X |  |  |  |
| 6 |  | X |  |  | end |

这样就拦住了

所以不难发现，要想拦住这个娃必须要满足以下几点条件：   
 $1.$必须与一边相连。    
  $2.$每一个路标必须在另一个路标的旁边相邻位置，如斜对角线上一格，或相邻格。  
  $3.$这一连串相邻的路障必须将起点与终点之间的路径截断，否则不能。
  
#### 然后我们就只需要从边上的路障找起，每一次寻找他的相邻的路障，只要找到了一次能够切断起点和终点的情况，就说明这个孩子走不到终点，如果把边上所有的路障都搜索过了，还没有切断，就说明这个孩子可以走到终点！

#### 那这不就非常美滋滋了，搜索的总量已经缩小的没个人样了。。。

先在还有一个问题就是如何说明这个路障切断了起点和终点    
那就分类讨论就行了   

可以切断的情况一：（终点所在的一条边与终点所在的另一条边相连）

| 1 | 2 | 3 | 4 |5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 | start |  |  |  |  |
| 3 |  |  |  | X |X |
| 4 |  |  | X |  |  |
| 5 |  | X |  |  |  |
| 6 |  | X |  |  | end |

可以切断的情况二：（一条边和与其相对的另一条边相连）

| 1 | 2 | 3 | 4 |5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 | start |  |  | X |  |
| 3 |  |  |  | X | |
| 4 |  |  | X |  |  |
| 5 |  | X |  |  |  |
| 6 |  | X |  |  | end |

和

| 1 | 2 | 3 | 4 |5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 | start |  |  |  |  |
| 3 |  |  |  | X | |
| 4 | X |  | X |  | X |
| 5 |  | X |  |  |  |
| 6 |  |  |  |  | end |

可以切断的情况三：（起点点所在的一条边与起点点所在的另一条边相连）

| 1 | 2 | 3 | 4 |5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 2 | start |  |  | X |  |
| 3 |  |  |  | X | |
| 4 | X |  | X |  |  |
| 5 |  | X |  |  |  |
| 6 |  |  |  |  | end |

这就是所有的情况了，只有以上的三种条件之中的任意一种，才能切断起点和终点！

所以我们可以选择两条边，每一次只要发现有在这两条边上的有效路障，就让他入队。
然后就和一般的广搜思路一模一样了，只要有哪一个路障连到了选择的两条边之外的另外两条边，就走不到终点。（选择的两条边必须相邻）

有一个小技巧，就是我们可以定义两个数组$dx , dy$，来表示这个路障下一次搜索的方向
```
	int dx[8]={-1,1,0,0,1,-1,-1,1};
	int dy[8]={0,0,-1,1,-1,1,-1,1};
```
这之后寻找路障（位置 $x$,$y$）就只需要在$x+dx[i] , y+dy[i]$这八个位置就行了

具体操作请见代码：
```
#include<cstdio>
#include<algorithm>
#include<queue>
#include<bits/stdc++.h>
using namespace std;
int a[1010][1010],T,n,x,y;

queue<int> nx;
queue<int> ny;

int dx[8]={-1,1,0,0,1,-1,-1,1};
int dy[8]={0,0,-1,1,-1,1,-1,1};

bool judge( int xx,int yy )
{
    if(xx>=1&&yy>=1&&xx<=n&&yy<=n)
    {
        if(a[xx][yy]>=1)
        {
            return true;
        }
    }
    return false;
}

void bfs()
{
    while(!nx.empty())
    {
        int nowx=nx.front();
        int nowy=ny.front();
        nx.pop();
        ny.pop();
        
        if( nowx==n||nowy==1 )			
        {
            printf("No\n");
            return ;
        }
        
        for(int i=0;i<=7;i++)
        {
            int nexx=nowx+dx[i];
            int nexy=nowy+dy[i];
            {
                if(judge(nexx,nexy))
                {
                    nx.push(nexx);
                    ny.push(nexy);
                    a[nexx][nexy]=0;
                }
            }
        }	
    }
    
    printf("Yes\n");
    return;
}

int main()
{
    scanf("%d",&T);
    for(int s=1;s<=T;s++)
    {
        scanf("%d",&n);
        int o=2*n-2;
        for(int i=1;i<=o;i++)
        {
            scanf("%d %d",&x,&y);
            if( x+y-2 > i )
            {
                a[x][y]=1;
                if(x==1||y==n)
                {
                    nx.push(x);
                    ny.push(y);
                }
            }
        }
        bfs();
        memset(a,0,sizeof(a));
    }
    return 0;
}
```

---

## 作者：WaltVBAlston (赞：14)

本题很显然是使用BFS进行地毯式搜索。

在此，我运用了一种我自己发明的方法来计算时间：双队列法，~~你也可以叫它A2优化的BFS~~。

基本思想：

使用q1来进行当前搜索，q2来记录扩展路径。如果q1空了，那么一“轮”也就结束了，此时将时间++，把q2中的东西塞进q1里面，以此类推。

a数组记录路障位置，因为不会被砸死，所以不用考虑这种情况，用t来控制砸下去的时间。

注意：a数组一定要开大一点。。。本人。。。。

这里同时介绍一下队列及其基本操作：

队列有一个特点：先进先出，即先进去的元素会被先弹出来。

队列的基本操作：

1.push（进入队列）。

2.pop（弹出队头元素）。

3.front（访问队头元素）。

4.empty（是否为空）。

好了，以上就是介绍，接下来贴代码：

```
#include<iostream>
#include<cstdio>
#include<queue>
#define ll long long
using namespace std;
struct node
{
    ll x,y;
};
node a[100001];
queue <node> q2;
bool flag[2001][2001]; 
bool ok[2001][2001];
ll t,n;
void prework()
{
    for(ll i=1;i<=n;i++)
    {
        for(ll j=1;j<=n;j++)
        {
            flag[i][j]=false;
            ok[i][j]=true;
        }
    }
    for(int i=1;i<=2*n-2;i++)
    {
        a[i].x=0;
        a[i].y=0;
    }
    return;
}
void check(ll x,ll y)
{
    if(x+1<=n)
    {
        q2.push((node){x+1,y});
    }
    if(x-1>=1)
    {
        q2.push((node){x-1,y});
    }
    if(y+1<=n)
    {
        q2.push((node){x,y+1});
    }
    if(y-1>=1)
    {
        q2.push((node){x,y-1});
    }
    return;
}
int main()
{
    scanf("%lld",&t);
    while(t--)
    {
        scanf("%lld",&n);
        prework();
        for(ll i=1;i<=2*n-2;i++)
        {
            scanf("%lld%lld",&a[i].x,&a[i].y); 
        }
        queue <node> q1;
	    ll t=0;
	    node z;
	    z.x=1;
	    z.y=1;
	    q1.push(z);
	    bool haha=false;
	    while(!q1.empty())
	    {
	        while(!q1.empty())
	        {
	            node k=q1.front();
	            q1.pop();
	            ll x=k.x;
	            ll y=k.y;
	            if(flag[x][y]==true||ok[x][y]==false)
	            {
	            	continue;
				}
				flag[x][y]=true;
	            if(x==n&&y==n)
	            {
	                haha=true;
	            }
	            check(x,y);
	        }
	        while(!q2.empty())
	        {
	            node k=q2.front();
	            q1.push(k);
	            q2.pop();
	        }
	        t++;
	        ok[a[t].x][a[t].y]=false;
	    }
	    if(haha==true)
	    {
	    	printf("Yes\n");
		}
		else
		{
			printf("No\n");
		}
    }
    return 0;
}
```
还请多多资瓷！！喜欢的三连哦！！（点赞评论关注）

---

## 作者：luoyue123 (赞：8)

发现题解里没有人贴STL队列的代码0.0就是一个简单的bfs，注意路障的处理，注意数组别开小了和判断入队的合法性。




```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=10005;
struct point{
    int x,y,time;//x,y是点的坐标，time是时间。
};
point a,z[MAXN];//z数组要开的足够大啊。（大于2*n-2）之前开小RE了好几次。。
queue<point>q; //STL队列
bool vis[MAXN][MAXN];
int ax[]={0,0,1,-1},ay[]={1,-1,0,0},n,g;//ax ay是四个方向判断
void bfs(){
    bool flag=0;
    while(!q.empty()){
        point u=q.front();
        q.pop();
        if(u.x==n&&u.y==n){
            printf("Yes\n");
            flag=1;
            break;
        }
        vis[z[u.time-1].x][z[u.time-1].y]=1;//因为是BFS，时间和入队顺序是按时间层层递进的。
        for(int i=0;i<=3;i++){
            if(!vis[u.x+ax[i]][u.y+ay[i]]&&u.x+ax[i]>=1&&u.x+ax[i]<=n&&u.y+ay[i]>=1&&u.y+ay[i]<=n){//判断合法性
                vis[u.x+ax[i]][u.y+ay[i]]=1;//直接标记为走过以免重复入队
                q.push((point){u.x+ax[i],u.y+ay[i],u.time+1});//入队
            }
        }
    }
    if(flag==0)printf("No\n");
}
int main(){
//    freopen("3395.in","r",stdin);
//    freopen("3395.out","w",stdout);
    scanf("%d",&g);
    for(int l=1;l<=g;l++){
        memset(vis,0,sizeof(vis));
        memset(z,0,sizeof(z));
        scanf("%d",&n);
        for(int i=1;i<=2*n-2;i++){
            scanf("%d%d",&z[i].x,&z[i].y);
        }
        while(!q.empty()){
            q.pop();//清空数组
        }
        q.push((point){1,1,1});
        vis[1][1]=1;//避免走回起点
        bfs();
    }
    return 0;
}

```

---

## 作者：ZJH365 (赞：6)

MY BLOG ：[我的博客食用效果更佳](https://47488.blog.luogu.org/)


### 这题挺简单的(逃
#### 只是为了放松心态


因为看到[1 4 5错 这个讨论](https://www.luogu.org/discuss/show/129610)

没有人回答，题解中也没有方法

而且我的做法题解中又没有，于是发一篇题解

供145点错的人看

~~我居然被一道紫题卡了两天~~


------------


### 写给145点WA的人看的部分 
数组要开大

存路障的数组要2000不是1000！！

因为有2*n-2个路障（可 AC 4 5）

还有特判一下 n==1 即起点等于终点的情况（可AC 1）


------------


------------
# 进入正题

因为路障是一秒**后**放一次


而bfs又是循环一次拓展**一个**点

与题目不一样
## 于是就
改造**bfs**

如果一次拓展一层点就很好做了
![有图有真相](https://cdn.luogu.com.cn/upload/pic/69980.png)

对不对？

所以
### 一次把队列中的所有的点都拓展

#### 而拓展出的点不要放入队列 防止拓展完了

拓展一层就够了

先存起来

然后待队列中的点拓展完了再放进去

# 看懂了再继续看

然后再放路障就可以了

```cpp
	while(!q.empty())
	{
		mm++;//时间
		while(!q.empty())
		{
			t now=q.front();
			q.pop();
			for(int i=1;i<=4;i++)
			{
				int tx=now.x+fx[i],ty=now.y+fy[i];
				if(pd(tx,ty)&&vis[tx][ty]==0)//不能越界不能访问过
				{

					pus[++qq][0]=tx;pus[qq][1]=ty;
                  //不要放进队列不然会拓展到第2层的
					vis[tx][ty]=1;
					if(tx==n&&ty==n)return 1;
				}
			}
		}
		for(int i=1;i<=qq;i++)
		{
			q.push((t){pus[i][0],pus[i][1]});
		}
		qq=0;
		vis[a[mm][0]][a[mm][1]]=2;//路障

	}
```
# **看懂了吗**
中文乱码请忽略


```cpp
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
int tt,n,a[2001][2];
int vis[1001][1001];
int pus[2000001][2];
int fx[5]={0,1,-1,0,0};
int fy[5]={0,0,0,-1,1};
struct t{
	int x,y;
};
int pd(int x,int y)
{
	if(x>n||x<1)return 0;
	if(y>n||y<1)return 0;
	return 1;
}
int bfs()
{
	int mm=0,qq=0;
	queue<t> q;
	q.push((t){1,1});
	vis[1][1]=1;
	while(!q.empty())
	{
		mm++;
		while(!q.empty())
		{//拓展完一层
			t now=q.front();
			q.pop();
			for(int i=1;i<=4;i++)
			{
				int tx=now.x+fx[i],ty=now.y+fy[i];
				if(pd(tx,ty)&&vis[tx][ty]==0)
				{
					pus[++qq][0]=tx;pus[qq][1]=ty;//printf("inline");
					vis[tx][ty]=1;
					if(tx==n&&ty==n)return 1;
				}
			}
		}//放新拓展的一层
		for(int i=1;i<=qq;i++)
		{
			q.push((t){pus[i][0],pus[i][1]});
		}
		qq=0;
		vis[a[mm][0]][a[mm][1]]=2;
	//设路障
//		printf(">>>>>>>>>\n");
//		for(int i=1;i<=n;i++)
//		{
//			for(int j=1;j<=n;j++)
//				printf("%d ",vis[i][j]);
//			printf("\n");
//		}
//		printf(">>>>>>>>>> \n");
//		printf("\n");
	}
	return 0;
}
int main()
{
	freopen("dd.txt","r",stdin); 
	freopen("ddd.txt","w",stdout); 
	scanf("%d",&tt);
	while(tt--)
	{
		scanf("%d",&n);
        //下面特判的要注意了
		if(n==1){printf("Yes\n");continue;}
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				vis[i][j]=0;
		for(int i=1;i<=2*n-2;i++)
		{
			scanf("%d%d",&a[i][0],&a[i][1]);
		}
//		printf("<<%d %d>>",a[1][0],a[1][1]);
		printf(bfs()==0?"No\n":"Yes\n");
	}
	return 0;
}
/*
00000
00000
00000
00000
b0000

00000
00000
00*00
00000
0b000

00000
00000
00*00
00*00
00b00

00000
00000
00*00
00*00
00*b0
......
*/
```



---

## 作者：彩虹猫 (赞：4)

## 题解 P3395 【路障】

这道题……呃，无话可说。

一道简单的BFS题。

唯一需要注意的是路障的处理。可开一个数组存放：在（x，y）位置路障将在什么时候放下。

对于没有路障的点，可直接走过。

对于有路障的点，比较小B走到此点所需时间与路障放置时间即可。
由于题目中说：**每秒结束的时刻，**C君会在(x,y)上摆一个路障。B君不能走在路障上。因此，只要**小B走到（x,y）所需时间<=路障放置时间**即符合条件。

由于此题数据较水，无需任何优化就可以AC了。

下面是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int x,y,t;
};
int n;
int cmap[1005][1005],gmap[1005][1005];
int d[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
void bfs()
{
	queue<node>q;
	node st,be,en;
	st.x=1;
	st.y=1;
	st.t=0;
	gmap[1][1]=1;
	q.push(st);
	while(!q.empty())
	{
		be=q.front();
		q.pop();
//		printf("%d %d %d\n",be.x,be.y,be.t);
		if(be.x==n&&be.y==n)
		{
			printf("Yes\n");
			return;
		}
		en.t=be.t+1;
		for(int i=0;i<4;i++)
		{
			en.x=be.x+d[i][0];
			en.y=be.y+d[i][1];
			if(en.x>=1&&en.x<=n&&en.y>=1&&en.y<=n)
			{
				if(cmap[en.x][en.y]==0||en.t<=cmap[en.x][en.y])
				{
					if(gmap[en.x][en.y]==0)
					{
						gmap[en.x][en.y]=1;
						q.push(en);
					}
				}
			}
		}
	}
	printf("No\n");
	return;
}
int main()
{
	int t;
	int xx,yy;
	scanf("%d",&t);
	while(t--)
	{
		memset(cmap,0,sizeof(cmap));
		memset(gmap,0,sizeof(gmap));
		scanf("%d",&n);
		for(int i=1;i<=2*n-2;i++)
		{
			scanf("%d%d",&xx,&yy);
			cmap[xx][yy]=i;
		}
		bfs();
	}
	return 0;
}
```

## 打个广告

>博客：https://www.luogu.org/blog/Nyan-Cat/


---

## 作者：ViXbob (赞：4)

>发这篇题解的原因主要是我看到题解里都是清一色的方法所以来补充一篇
代码不同之处详见代码


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#define MAXN 1<<30
#define pb push_back
using namespace std;
int T,n,f,mp[1010][1010],judge[1010][1010];
int move_x[5]={0,1,0,-1,0};
int move_y[5]={0,0,1,0,-1};
struct node{int x,y,t;}q[5000000];
void bfs(){
    int tail=0,fr=1;
    q[1].x=1,q[1].y=1;
    while(fr>tail){
        node t=q[++tail];
        if(t.x==n&&t.y==n){f=1;return;}
        for(int i=1;i<=4;i++){
            int dx,dy;
            dx=t.x+move_x[i];
            dy=t.y+move_y[i];
            if((t.t+1<mp[dx][dy]||!mp[dx][dy])&&dx>=1&&dx<=n&&dy>=1&&dy<=n&&!judge[dx][dy]){
                q[++fr].x=dx;
                q[fr].y=dy;
                q[fr].t=t.t+1;
                judge[dx][dy]=1;
            }
        }
    }
}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);f=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)mp[i][j]=0,judge[i][j]=0;
        for(int i=1;i<=n*2-2;i++){
            int x,y;scanf("%d%d",&x,&y);
            mp[x][y]=i+1;\\我看到的题解里都是在走完四个点之后加一句标记，而我直接是把被设为路障的点的附上一个时间值，在bfs时用当前的时间和路障的时间进行比较，如果小于则可以走，大于就不行，我感觉这样好理解一些啊
        }
        bfs();
        if(f)printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：Cylete (赞：3)

# 要是提高DAY1T1有这么简（~~du~~）单（~~liu~~）就好（~~zha~~）了

看到题目的第一眼，不就是个BFS mua

打完提交MLE？？？

发现忘了加标记

f就是标记的数组

每个坐标只用入队一次

因为ta迷路了，走不出去了，一直在原地打转


最后n=1时加个特判就欧ok了

附上代码（代码好长啊....~~太菜了~~）

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
using namespace std;
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
int t;
int n,kkk,sx[2020],sy[2020],e[1010][1010],f[1010][1010];
void bfs(){
	queue<pair<int,int> >q;//放坐标
	queue<int>hhh;//存时间
	f[1][1]=0;
	q.push(make_pair(1,1));
	hhh.push(0);
	while(!q.empty()){
		int x=q.front().first,y=q.front().second,z=hhh.front()+1;
		q.pop();
		hhh.pop();
		for(int i=0;i<4;i++){
			int xx=x+dx[i],yy=y+dy[i];
			if(e[xx][yy]==0&&xx>=1&&xx<=n&&yy>=1&&yy<=n){
				if(xx==n&&yy==n){//到了直接return
					cout<<"Yes"<<endl;
					return;
				}
				if(f[xx][yy])continue;//判断是否走过 
				f[xx][yy]=1;
				q.push(make_pair(xx,yy));
				hhh.push(z);
			}
		}
		e[sx[z]][sy[z]]=1;//标记不可以走
	}
	cout<<"No"<<endl;
	return;
}
int main(){
	scanf("%d",&t);
	while(t--){
		memset(e,0,sizeof(e));//可不可以走
		memset(f,0,sizeof(f));//走过否
		scanf("%d",&n);
		if(n==1){//特判
			cout<<"Yes"<<endl;
			continue;
		}
		for(int i=1;i<=2*n-2;i++)scanf("%d%d",&sx[i],&sy[i]);
		bfs();
	}
    return 0;
}
```


---

## 作者：liangsheng (赞：3)

~~由于本蒟蒻看不懂dalao的题解,自己来写一遍标准的BFS题解,以给同为蒟蒻的我们一点点安慰~~

废话不多,进入正题:
我们平常所用的vis数组只是记录这个点是否走过,此题中说障碍是根据时间出现的,那么我们考虑是否可以vis数组发挥更大一点的作用. ~~(答案是肯定的)~~

在这里,本蒟蒻的思想是:

**vis[x][y] = -1 时,标记点(x,y)走过**
**vis[x][y] = 0 时,没有走过点(x,y)**
**当vis[x][y]为整数时,记录障碍在点(x,y)出现的时间**
**还有一点要特别注意: 若第i秒末(相当于第i+1秒)障碍会在点(x,y)出现,则第i秒是没有点(x,y)还不是障碍点**

到这里,我们可以把此题看做一个**标准的BFS的题**,只是在BFS基础上改变vis数组的用法,如果到这里都理解,那么代码自然就能明白

不明白也没有关系,**具体解释见代码**:
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>

using namespace std;

inline int read() {   // 标准快读
    char ch = getchar(); int x = 0, f = 1;
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while('0' <= ch && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}

int t, n;
int vis[1005][1005];
int dir[4][2] = {1, 0, 0, -1, -1, 0, 0, 1};  //方向数组(上,下,左,右 四个方向)

struct stu {
    int x, y, time;  // time代表:走到点(x,y)的时间
    stu(int a, int b, int c) {
        x = a;
        y = b;
        time = c;
    }
};

queue <stu> ss;

bool check(int x, int y) {  //判断是否越界
    if(x < 1 || x > n || y < 1 || y > n) return 1;
    return 0;
}

int bfs() {  //标准BFS
    vis[1][1] = -1;  //把起点赋值为-1 (再次强调:-1为已经走过的点)
    ss.push(stu(1, 1, 0));  
    while(!ss.empty()) {
        stu k = ss.front();
        ss.pop();
        if(k.x == n && k.y == n) return 1;  //判断是否可以到终点
        for(int i = 0; i < 4; i++) {
            int now_x = k.x + dir[i][0];
            int now_y = k.y + dir[i][1];
            int now_time = k.time + 1;    //不断积累时间
            if(vis[now_x][now_y] == -1) continue;   //检查是否走过该点
            if(check(now_x, now_y)) continue;    //检查是否越界
            if(vis[now_x][now_y] < now_time && vis[now_x][now_y] > 0) continue;
            //因为障碍会在第i秒末(也就是第i+1秒)的出现
            //所以vis的值小于当前时间才能看做为此点没有障碍
            vis[now_x][now_y] = -1;
            ss.push(stu(now_x, now_y, now_time));
        }
    }
    return 0;
}

int main() {
    t = read();
    while(t--) {
        n = read();
        memset(vis, 0, sizeof(vis));  //输出值为0
        while(!ss.empty()) ss.pop();  //这一步不能忘,因为有多个样例,所以必须清空队列
        for(int i = 1; i <= 2 * n - 2; i++) {
            int x, y;
            x = read();
            y = read();
            vis[x][y] = i;  //把障碍在点(x,y)出现的时间设为i
        }
        if(bfs()) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
```


---

## 作者：Drug__Lover (赞：3)

**先走再放路障**

**第一个点是在到达终点之前就已经被放上了路障，所以不能走了**

**纯纯的BFS**

\_我用了一个vis数组来记录路障和判断是否已经走过（反正都不能走。。。）\_

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int t,n,k,sum;
int x[1000001],y[1000001],vis[1001][1001];
int mx[5]={0,0,0,1,-1},my[5]={0,1,-1,0,0};
int fx[6000001],fy[1000001];
void bfs(int x1,int y1)
{
    memset(vis,0,sizeof(vis));
    k=0;
    sum=0;
    int h=0,t=1;
    vis[1][1]=1;
    fx[1]=x1;
    fy[1]=y1;
    while(h<t)
    {
        h++;    
        for(int i=1;i<=4;i++)
        {
            vis[x[sum]][y[sum]]=1;
            if(x[sum]==n&&y[sum]==n)           //如果在到达之前终点已经放上了路障，那就无法走到了，直接输出No就好了
            {
                k=0;
                return;
            }
            int xx=fx[h]+mx[i],yy=fy[h]+my[i];
            if(xx<=n&&xx>0&&yy<=n&&yy>0&&vis[xx][yy]==0)
            {
                t++;
                vis[xx][yy]=1;
                fx[t]=xx;
                fy[t]=yy;    
            }
        }
        if(vis[n][n]==1)        //如果终点已经走过并且不是路障那么就输出Yes
        {
            k=1;
            return;
        }
        sum++;
    }
}
int main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        cin>>n;
        for(int i=1;i<=2*n-2;i++)
        {
            cin>>x[i]>>y[i];
        }
        bfs(1,1);
        if(k==1) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}
```

---

## 作者：王兴澄 (赞：2)

水题，基本上就是标准BFS，只是多了个路障，还有就是加个特判（路障是不是直接放在终点了），数据有点套路，看代码：

```cpp
include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int x,y,t,n,sum;
int vis[1100][1100],zzy;
int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
int q[1005000][2];
string ans;
void bfs(){
    zzy=0;   //特判标记，我校神犇zzy大爷
    memset(vis,0,sizeof(vis));
    int i,j,head=0,tail=1;
    q[head][0]=1; q[head][1]=1;
    vis[1][1]=1;
    while(head<tail){
        for(i=0;i<=3;++i){
            int nx=q[head][0]+dx[i];
            int ny=q[head][1]+dy[i];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!vis[nx][ny]){
                q[tail][0]=nx;
                q[tail][1]=ny;
                tail++;
                vis[nx][ny]=1;
            }
        }
        if(sum>0){
            --sum;
            scanf("%d%d",&x,&y);  //加路障
            vis[x][y]=1;
            if(x==n&&y==n){
                zzy=1;
                return; 
            }
        }
        head++;
    }
    if(vis[n][n]) ans="Yes"; //用（n，n）点的访问标记判断是否能够到达终点
    else ans="No";
}
int main(){
    int i,j;
    scanf("%d",&t);
    for(j=1;j<=t;++j){
      cin>>n;
      sum=2*n-2;
      bfs();
      if(zzy) ans="No"; //如果特判成立，那就把ans换为NO
      cout<<ans<<endl;
      }
    return 0;
}
```

---

## 作者：Starlight237 (赞：1)

# 其实这题不需要BFS，只需要一个简单的二维DP！
首先，如很多题解所述，我们要明确什么时候障碍物是对这个熊孩子有用的。

其实这里要认识到，最短路径一定是向右或者向下走的。这是因为熊孩子不可能折回到他以前早已走过的点。如果仍不理解，参考一下BFS的搜索规则会给您一些帮助。

因为地图是一个矩阵，按照上述的规则，从点$(a,b)$到$(c,d)$的最短时间就是他们之间的曼哈顿距离减去1：$c-a+d-b-1$。

故第$i$秒，代入上式，只有满足$x+y-2>i$的障碍物才有作用（这样就不会落到已经走过的点上）。

按照此规则，一个点$(i,j)$可以从$(i-1,j)$和$(i,j-1)$走来，并且该点不可以有障碍物。这样这题就演变为一个求联通块的题目，可以使用二维DP。状态转移方程如下：

## $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ f_{i,j}=(f_{i-1,j}|f_{i,j-1})\&dag_{i,j}$

其中dag记录该点是否有**有效**的障碍物。有效的条件已经讨论过了。

那么代码奉上：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define reg register
static int n,t,x,y;
static char dp[1001][1001],dag[1001][1001];
int main(){
    scanf("%d",&t);
    while(t--){
    	memset(dp,0,sizeof(dp)),
    	memset(dag,0,sizeof(dag));//这里很重要！因为有多组数据，每次必须初始化。
        scanf("%d",&n);
        for(reg int i=1;i<=2*n-2;++i){
            scanf("%d%d",&x,&y);
            if(x==n&&y==n&&x+y-2<i){
                puts("No");
                break;
            }
            if(x+y-2>i)dag[x][y]=1;//标记有效的障碍物。
        }
        dp[1][1]=1;
        for(reg int i=1;i<=n;++i)
            for(reg int j=1;j<=n;++j)
            	dp[i][j]|=(dp[i-1][j]||dp[i][j-1])&&!dag[i][j];//DP方程
        if(dp[n][n])puts("Yes");
        else puts("No");
    }
}
```

---

## 作者：木小沐 (赞：1)

# noip前的题解，希望rp++   
刚刚发了一遍，说格式有问题，再发一遍，希望可以过  
这道题就是中规中矩的bfs，唯一需要注意的就是对时间的更改  
这里用结构体对每一个点变成路标时间进行标记  
在这里用 **队列+对组 **写bfs   
附上代码，自认为注释很详细，希望能提供一些帮助** 
```
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
pair<int,int> S;
queue<pair<pair<int,int>,int> >Q;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
struct hh
{
	int num,time;
}
G[1010][1010];
bool vis[1010][1010];
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int r=0;
		memset(G,0,sizeof(G));//初始化均为0，可访问点标为1；
		memset(vis,0,sizeof(vis)); //每次千万不要忘记清空数组！ 
		int n;
		scanf("%d",&n);
		for(int i=1;i<=2*n-2;i++)
		{
			int a,b;
			scanf("%d %d",&a,&b);
			G[a][b].time=i;//更改时间 
		}
		for(int i=1;i<=n;i++)
		  for(int j=1;j<=n;j++)
		    G[i][j].num=1;//初始n*n均可访问 
		Q.push(make_pair(make_pair(1,1),0));//初始位置进队 
		vis[1][1]=1;//标记 
	    while(!Q.empty())
	    {
	    	int x=Q.front().first.first;
	    	int y=Q.front().first.second;
	        int ans=Q.front().second;//当前时间 
	        Q.pop();
	        if(x==n&&y==n)//找到可行点 
	        {
	        	printf("Yes\n");
	        	r=1;
	        	break;
			}
	    	for(int i=0;i<4;i++)
	    	{
	    		int xx=x+dx[i];
	    		int yy=y+dy[i];
	    		if(xx<1||xx>n||yy<1||yy>n||vis[xx][yy])
	    		  continue;// 剪枝 
	    		if((G[xx][yy].time>ans||G[xx][yy].time==0)&&!vis[xx][yy]&&G[xx][yy].num==1) //寻找可行点入队 
	    		{ 
				   vis[xx][yy]=1;   
				   Q.push(make_pair(make_pair(xx,yy),ans+1));
			    }
	        }
		}
		if(r==0)
	     printf("No\n");
	}
	return 0;
 } 
```

---

## 作者：OceanLiu (赞：0)

这个题花了我特别多的时间，几乎是把所有能犯的错误都犯了一遍。反思过后，我决定发一片题解，也算是长了一个教训。

首先，广搜基本模板必须掌握，这里不多说。这里比较重要点的是数组一定要开得足够大！！！尽量少得使用数组！！！一定要分清楚局部变量和全局变量！！！（来自一个十几次RE和WA的人的心声）

这里是我得20分的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int t,a[2005][5],b[1005],q[1000005][3],sum[11];
bool map[1005][1005],vis[1005][1005];
bool flag;
int main()
{
	cin>>t;
	for (int i=1;i<=t;i++)
	{
		int n;
		cin>>n;
		if (n==1) {
		sum[i]=1;continue;}
		for (int j=1;j<=2*n-2;j++)
		{
			cin>>a[j][1]>>a[j][2];
			b[j]=1;
		}
		q[1][1]=1,q[1][2]=1;vis[1][1]=1;
		int f=1,r=1;
		while (f<=r)
		{
			
			for (int j=0;j<=3;j++)
			{
				int xx=q[f][1]+dx[j],yy=q[f][2]+dy[j];
				if (xx>0&&xx<=n&&yy>0&&yy<=n&&vis[xx][yy]==0&&map[q[f][1]][q[f][2]]==0&&map[xx][yy]==0)
				{
					vis[xx][yy]=1;
					r++;
					q[r][1]=xx,q[r][2]=yy;
					if (q[r][2]==n&&q[r][1]==n) {
					flag=1;break;}
				}
			}
			if (flag==1) break;
			if (b[f]==1) map[a[f][1]][a[f][2]]=1;
			f++;
		}
		if (flag==1) sum[i]=1;
		else sum[i]=0;
		flag=0;
		memset(vis,0,sizeof(vis));
		memset(a,0,sizeof(a));
		memset(map,0,sizeof(map));
		memset(q,0,sizeof(q));
		memset(b,0,sizeof(b));
	}
	
	for (int i=1;i<=t;i++)
	{
		if (sum[i]==1) cout<<"Yes"<<endl;
		if (sum[i]==0) cout<<"No"<<endl;
	}
	return 0;
}
```

然后我只过了第一个点，4个RE……
我很奇怪，下载测试数据，然后检验，发现答案都正确啊。前前后后修改n多次后，我实在没招了，推倒重新做吧……

新代码努力得让数组变得又少又小，也尽量让程序模块化了，便于查错。然后就过了。我也是很无语……

注释请看代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int f,n,x,y,nx,ny;
const int dx[4]={0,1,0,-1};//上下左右四种走法
const int dy[4]={1,0,-1,0};
struct qqq{
    int x,y;
}q[10000010],rock[1001];//q数组为队列，rock数组为障碍
bool map[1001][1001];//map是用来判定这个点有没有被走过
void bfs(){//广搜程序
    int t=1,head=1,tail=2;
    q[head].x=1,q[head].y=1,map[1][1]=1;//预先初始化
    do{
        for(int i=0;i<4;i++){
            nx=q[head].x+dx[i];
            ny=q[head].y+dy[i];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&map[nx][ny]==0){
                q[tail].x=nx;
                q[tail].y=ny;
                tail++;
                map[nx][ny]=1;
            }
        }
        map[rock[t].x][rock[t].y]=1;//过了这一秒后把障碍放下来
        t++;
        head++;
    }while(head<tail);
    for(int i=tail;i>=1;i--){//遍历队列。这里其实还有一种更简单的查找方法，保险起见，还是遍历吧。
        if(q[i].x==n&&q[i].y==n){
            printf("Yes\n");
            return;
        }
    }
    printf("No\n");
    return;
}
int main(){
    cin>>f;
    for(int e=1;e<=f;e++){
        cin>>n;
        for(int i=1;i<=2*n-2;i++){
            scanf("%d %d",&x,&y);
            rock[i].x=x,rock[i].y=y;
        }
        bfs();
        memset(map,0,sizeof(map));//一定要初始化数组！！！！！！！
        memset(rock,0,sizeof(rock));
        memset(q,0,sizeof(q));
    }
    return 0;
}
```

总之我还是太菜了……
各位大佬如果有什么更好的方法,欢迎交流！

---

## 作者：dinghongyu (赞：0)

### 题目大意：在一个矩阵中，每秒都会出现一个障碍，问能否走到终点。
##
### 其实此题是一道较简单的广搜题，只需注意一下路障是在每秒结束时落下即可。
##
### 代码:
```
#include <bits/stdc++.h>
#define N 1001
using namespace std;
int t,n;
int rx[2 * N],ry[2 * N];
int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};
bool f[N][N];                  // 地图，用来标记障碍和是否走过
struct que
{
	int x,y,ti;
}q[N * N];                     // 队列，用结构体存储
inline void bfs ()
{
    int h = 1,t = 2;
    q[h] = (que){1,1,0},f[1][1] = 1;     // 初始化
    while (h < t)
    {
        int hx = q[h].x,hy = q[h].y;          
        if (hx == n && hy == n)
        {
            puts("Yes");
            return ;
        }                                // 可以到达
        for (int i = 0;i < 4;i++)
        {
            int tx = hx + dx[i];
            int ty = hy + dy[i];
            if (tx > 0 && tx <= n && ty > 0 && ty <= n && !f[tx][ty])
                q[t++] = (que){tx,ty,q[h].ti + 1},f[tx][ty] = 1;              // 符合条件入队
        }
        f[rx[q[h].ti + 1]][ry[q[h].ti + 1]] = 1;
        h++;
    }
    puts("No");              // 无法到达
    return ;
}
int main()
{
    cin >> t;
    while (t--)
    {
        memset (f,0,sizeof(f));
        cin >> n;
        for (int i = 1;i <= 2 * n - 2;i++)
            cin >> rx[i] >> ry[i];           // 输入数据
        bfs();                               // 广搜
    }
    return 0;
}
```


---

## 作者：hovny (赞：0)

### [点开有惊喜](https://www.luogu.org/problemnew/show/P3395)

~~其实是题面~~  

这D1T1给的很有面子！  ~~我居然做的来！~~

从**左上角**走到**右上角**  

然后n<=1000  

所以果断放弃**DFS**，选择**BFS**  

思路还是一样的BFS

### 证明：

走到一个点的时间越早越好（因为时间越晚能走到的点越少，路障多了）  

所以用**BFS**，走过的点不用再次走，用 **vis**数组记录已经是否遍历过  

然后为了防止跑出棋盘去（B君看到了棋盘外美铝？！）  

我们就给棋盘加一个 **'1'**的边框，这样就不会出去  

然后还要记录一个时间**t**、**x**、**y**，可以用一个结构体 

构造用

> struct node{
>
> ​	int x,y,t;
>
> ​	node(int a,int b,int c):x(a),y(b),t(c) {	}
>
> ​	node(){}
>
> };
>
> node(x,y,t)//直接构造

但是本菜还是比较喜欢用两个queue  

一个存pair(x,t)，一个存y  

贴上：  

```c++
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
using namespace std;
int Cx[4]={1,0,0,-1};//四个方向，八个方向也一样
int Cy[4]={0,1,-1,0};//在下有强迫症，所以用两个数组
int n,T;
int x,y;
int b[1010][1010];
bool vis[1010][1010];
int read()
{
	int s=0;
	char c=getchar();
	while(!isdigit(c))
		c=getchar();
	while(isdigit(c))
	{
		s=(s<<1)+(s<<3)+c-'0';
		c=getchar();
	}
	return s;
}
bool BFS()
{
	int i,t;
	int Tx,Ty;
	queue<pair<int,int> >px;
	queue<int>py;
	while(!py.empty())
		px.pop(),py.pop();
	px.push(make_pair(1,1));
	py.push(1);
	vis[1][1]=1;
	while(!px.empty())
	{
		x=px.front().first;
		t=px.front().second;px.pop();
		y=py.front();py.pop();
		if(x==n&&y==n)//有了这句就不用特判n=1的情况了
			return 1;
		for(i=0;i<4;i++)
		{
			Tx=x+Cx[i];
			Ty=y+Cy[i];
			if(!vis[Tx][Ty]&&t<=b[Tx][Ty])
			{
				vis[Tx][Ty]=1;
				px.push(make_pair(Tx,t+1));
				py.push(Ty);
			}
		}
	}
	return 0;
}
int main()
{
	int i;
	T=read();
	while(T--)
	{
		n=read();
		memset(vis,0,sizeof(vis));
		memset(b,INF,sizeof(b));//一开始赋无穷大比较方便
		for(i=1;i<=n;i++)//裱框
			vis[i][0]=vis[0][i]=vis[n+1][i]=vis[i][n+1]=1;
		for(i=1;i<=2*n-2;i++)
		{
			x=read();y=read();
			b[x][y]=i;
		}
		if(BFS())//此处纪念ydk大佬把"Yes"打成"YES"，本蒟瑟瑟发抖
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}
```



---

## 作者：Wider (赞：0)

#BFS搜索加一个特判

##楼下特判有问题

楼下特判是如果终点被放了路障就输出否

但有情况是在放路障前就到了终点

数据水，第一个点是n=1，此时bfs就不管用了，所以要特判n=1是直接输出是。

还有**大神（orz）**用曼哈顿距离解出来了,题解后来再发。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int px[5]={0,0,0,1,-1};
int py[5]={0,1,-1,0,0};
int t,n,vis[1010][1010],a[1010][1010],cnt=0,flag;
struct node
{
    int x;
    int y;
    int t;
}q[1000000],recode[2020];
void bfs(int x1,int y1)//广搜
{
    int t=1,h=0;
    vis[x1][y1]=1;
    q[t].x=x1;
    q[t].y=y1;
    q[t].t=0;
    while(h<t)
    {
        h++;
        for(int i=1;i<=4;i++)
        {
            int tx=q[h].x+px[i];
            int ty=q[h].y+py[i];
            if(tx>0 && ty>0 && tx<=n && ty<=n && vis[tx][ty]!=1 && a[tx][ty]!=1)//如果这个点有障碍就不入队
            {    
                if(tx==n&&ty==n)//终点的判断在前面，因为如果走到了终点，即使下一个路障被放在终点，整个路程也是完成了（样例1）
                {
                    cout<<"Yes"<<endl;
                    flag=1;
                    return;
                }
                if(recode[cnt+1].x==tx && recode[cnt+1].y==ty)//如果下一个点是路障下一次放的地方（会被砸死）就不入队
                continue;
                t++;
                q[t].x=tx;
                q[t].y=ty;
                vis[tx][ty]=1;
                
                cnt=q[h].t+1;
                q[t].t=cnt;
                a[recode[cnt].x][recode[cnt].y]=1;//记录时间
            }
        }
    }
}
void solve()
{
    cin>>n;
    if(n==1)
    {
        cout<<"Yes"<<endl;
        return;
    }
    for(int i=1;i<=2*n-2;i++)
    cin>>recode[i].x>>recode[i].y;
    memset(vis,0,sizeof(vis));//记得每测一次初始化
    memset(a,0,sizeof(a));
    flag=0;
    bfs(1,1);
    if(flag==0)
    cout<<"No"<<endl;
}
int main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
    solve();
    return 0;
}
```

---


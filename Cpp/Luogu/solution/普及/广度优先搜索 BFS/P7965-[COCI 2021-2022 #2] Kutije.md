# [COCI 2021/2022 #2] Kutije

## 题目描述

Matrin 有 $n$ 个箱子的玩具。箱子分别用序号 $1,2,3,\cdots,n$ 表示。初始状态下，每个箱子中有一个与箱子编号相同的玩具。

Matrin 邀请了 $m$ 位朋友来家玩玩具。他注意到，每一位朋友在玩完玩具之后，都会将原先位于 $i$ 号箱子内的玩具放入 $p_i$ 号箱内。

给定 $q$ 组询问，每次可随意邀请朋友并自由选择顺序，同时每位朋友可以邀请任意多次。问是否存在一种方案，使得 $a$ 号玩具最终被放入 $b$ 号箱子中。

## 说明/提示

**【样例 1 解释】**

- 询问 $1$：初始状态下，$1$ 号玩具已经在 $1$ 号箱子内，故输出 $\texttt{DA}$。
- 询问 $2$：第二组询问：无符合题意的方案，输出 $\texttt{NE}$。
- 询问 $3$：邀请 $1$ 号朋友前来即可，输出 $\texttt{DA}$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（15 pts）：$m=1$。
- Subtask 2（10 pts）：$1 \le n,m,q \le 100$；对于每组询问，若答案为 $\texttt{DA}$，则保证存在一种邀请朋友数量不超过 $2$ 的方案。
- Subtask 3（10 pts）：$1 \le n,m,q \le 100$。
- Subtask 4（35 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,m \le 1000$，$1 \le q \le 5 \times 10^5$，$1 \le a,b \le n$。

**【提示与说明】**

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #2](https://hsin.hr/coci/contest2_tasks.pdf) _Task 2 Kutije_。**

**本题分值按 COCI 原题设置，满分 $70$。**

## 样例 #1

### 输入

```
4 1 3
1 2 4 3
1 1
1 2
3 4```

### 输出

```
DA
NE
DA```

## 样例 #2

### 输入

```
4 2 4
2 1 3 4
1 2 4 3
2 1
3 4
1 4
2 3```

### 输出

```
DA
DA
NE
NE```

## 样例 #3

### 输入

```
6 2 2
2 1 4 5 3 6
3 2 4 1 5 6
1 5
6 3```

### 输出

```
DA
NE```

# 题解

## 作者：Light_az (赞：5)

话说这道题目的标签是认真的吗？这不是个并查集板子题吗？

根据题意我们得到，编号为 $i$ 的玩具可以放在编号为 $p_i$。又因为 $p_i$ 是一个排列，所以我们可以写一个并查集，在 $i$ 和 $p_i$ 之间建立关系，依此给 $m$ 个人处理关系。然后对于下面的询问，我们套用并查集模板的查询函数进行比较，如果 $x$ 和 $y$ 的返回值一样，那么说明它们之间是存在关系的，下面是完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for (int i=a;i<=b;i++)
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e7+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T;
ll mini=INT_MAX,maxi=0,Mod;
string s1,s2;
ll f[N];
ll find(ll x){//并查集 
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
string check(ll x,ll y){//检查答案 
	if(find(x)==find(y)) return "DA\n"; 
	return "NE\n";
}
int main(){
	Test;
	cin>>n>>m>>k;
	F(i,1,n) f[i]=i;//并查集预处理 
	F(i,1,m) F(j,1,n) cin>>x,f[find(x)]=find(j);//建立关系 
	F(i,1,k){
		cin>>x>>y;
		cout<<check(x,y);//判断是否符合答案 
	} 
	return 0;
}

```


---

## 作者：CodyTheWolf (赞：3)

实际上这道题并不是有向图的传递闭包，而是无向图的连通性。

每个小朋友的玩具移动**都是一个排列**，别把这个重要条件忘掉了。

如果是排列的话，对于一个玩具$x$可以到$y$，显然在同一个小朋友手里，可以多走几次回到$x$，即存在一条路径$x,y,z,..,x$。那么$y$也就可以到$x$，因此每次玩具的转移都是一条无向边。

接下来大家应该都会做了，用并查集把每条无向边俩端点所在集合合并就行了。

复杂度$O(mn+q)$

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;

constexpr size_t MAXN = 1e3 + 5;
int f[MAXN];

inline int Find(int x) { return x == f[x] ? x : f[x] = Find(f[x]); }

inline void Solve() {
	int n, m, q;
	cin >> n >> m >> q;
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= m; i++)
		for (int j = 1, x; j <= n; j++)
			cin >> x, f[Find(x)] = Find(j);
	while (q--) {
		int x, y;
		cin >> x >> y;
		if (Find(x) == Find(y)) cout << "DA\n";
		else cout << "NE\n";
	}
}

signed main(void) {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	//int t; cin >> t;
	int t = 1;
	while (t--) Solve();
}

```


---

## 作者：WaltVBAlston (赞：3)

~~关于我 BFS 写错然后被兔一眼看出来这件事~~

在这里提供一个 $O(N^3)$ 的 BFS 做法。 （$M=N^2$ BFS 的复杂度为 $O(N+M)$，我的做法要 BFS $N$ 次，所以是 $O(N^3)$）

$i$ 箱子的玩具能够被放到 $p_i$ 箱子，其实就是箱子 $i$ 和箱子 $p_i$ 间有一条有向边，然后就可以通过 $N$ 次 BFS 求出每一个箱子可以到达的所有箱子，然后这题我们就算做完了

（理论上来说 $10^9$ 是过不了的，但是因为原因，本做法可以通过快读快出通过，如果按照 CCF 标准加上 O2 优化，就可以跑得更快）

值得注意的是，BFS 中 vis 数组一定要在“松弛”中就设定为经过，不然你就会像我一样获得 15 分的好成绩

不得不说，做完这道题，对 BFS 的理解更加深入了一些

AC Code:

```
#include<bits/stdc++.h>
using namespace std;
vector <int> edge[1005];
queue <int> q;
int n,m,ask;
bool vis[1005],can[1005][1005];
int read(){
	int x=0,z=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')
			z=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return z*x;
}
int main(){
	n=read(),m=read(),ask=read();
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			int x;
			x=read();
			edge[j].push_back(x);
		}
	}
	for(int i=1;i<=n;i++){
		memset(vis,false,sizeof(vis));
		q.push(i);
		can[i][i]=true;
		while(!q.empty()){
			int x=q.front();
			q.pop();
			for(auto k:edge[x]){
				if(vis[k]==false){
					can[i][k]=true;
					q.push(k);
					vis[k]=true;
				}
			}
		}
	}
	while(ask--){
		int a,b;
		a=read(),b=read();
		if(can[a][b])
			puts("DA");
		else
			puts("NE");
	}
	return 0;
} 
```


---

## 作者：ryanright (赞：2)

这道题就是已知一个有向图，问能否从 A 点到 B 点。

看见有向图的连通性啥的，第一反应就是缩点。首先可以确定的是，由于 $q$ 的庞大，预处理是必需的。思路很简单，整张图缩点，然后依照原图的边给强联通分量连边。每次查询的时候只要 A 点所在的强联通分量是否能够到达 B 点所在的强联通分量，A 点就可以到达 B 点。具体细节见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int s=0;char ch=getchar(),last=0;
	while(ch<'0'||ch>'9') last=ch,ch=getchar();
	while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return last=='-'?-s:s;
}
int dfn[1005],low[1005],dfncnt,s[1005],tp,scc[1005],sc,sz[1005];
vector<int> g[1005];
bool pd[1005][1005],in_stack[1005];
void tarjan(int u){//缩点
	low[u]=dfn[u]=++dfncnt;
	s[++tp]=u;
	in_stack[u]=1;
	for(int i=0;i<g[u].size();i++){
		const int &v=g[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(in_stack[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		sc++;
		while(s[tp]!=u){
			scc[s[tp]]=sc;
			sz[sc]++;
			in_stack[s[tp]]=0;
			tp--;
		}
		scc[s[tp]]=sc;
		sz[sc]++;
		in_stack[s[tp--]]=0;
	}
}
int main(){
	int n=read(),m=read(),q=read();
	while(m--)
		for(int i=1;i<=n;i++)
			g[i].emplace_back(read());
	for(int i=1;i<=n;i++)//tarjan主过程 
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=sc;i++) pd[i][i]=1;
	for(int i=1;i<=n;i++)//给SCC连边
		for(int j=0;j<g[i].size();j++)
			pd[scc[i]][scc[g[i][j]]]=1;
	while(q--){
		int a=read(),b=read();
		puts(pd[scc[a]][scc[b]]?"DA":"NE");
	}
	return 0;
}
```

~~吸了氧之后直接跑到了最优解。~~

应该没有人像我这么疯狂了吧。

---

## 作者：Syamoe (赞：1)

#### 前言

题目[Link](https://www.luogu.com.cn/problem/P7965)

首先呢，看到这道题目，先审题，这道题目想让我们干的事情是`判断一个有向图的两点之间是否存在一条边`，这道题我们考虑先构建图，使用**最短路**算法

#### 解法

~~如果BFS能过的话，那floyd就都能过了呗？~~

我们来考虑一下用那种最短路算法（这里重点是`Floyd`）：

- `Dijkstra`算法；

但是显然，要用的话，一定要注意“松弛”操作中的数组设定，不然的话，会直接爆掉；

- `Floyd`算法；

~~显然我不会说只用3个`for`循环就能搞定~~

但其实真是那样的，`Floyd`最大的有点就是代码很短，只用三个`for`就能搞定，然而这三层`for`本来长这个样子：
```cpp
for (int k = 1; k <= n; k++) {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			dis[i][j] = min(dis[i][k] + dis[k][j], dis[i][j]);
		}
	}
}

```
但是这道题并没有让我们来求最短路，于是，可以适当修改一下，但是仍旧是这个思路：
```cpp
for (int k = 1; k <= n; k++) {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (dis[i][k] != 0 && dis[k][i] != 0) {
				dis[i][j] = 1;
			}
		}
	}
}
```
但是我们发现如果光这样写是肯定过不去的，会直接被卡掉；

于是我们考虑加进去快读的板子吸氧，同时开 o2：
```cpp
int init(){
    char c = getchar();
    int x = 0, f = 1;
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-') f = -1;
    for (; c >= '0' && c <= '9'; c = getchar())
        x = (x << 1) + (x << 3) + (c ^ 48);
    return x * f;
}
```
这样才能通过；

主要使用`Folyd`是因为3层循环里面的数较小，不然的话时间复杂度 $O(N^3)$ 是会被直接卡掉的；

- `SPFA`算法；

众所周知，关于`SPFA`他死了；

其实这道题里面`SPFA`确实是会死的；

由于某些数据太大了，直接让`SPFA`当场死亡；

但是还是可以优化的；（这里我就不详细讲了，因为其他大佬已经都讲过了）

这道题目就到介里，再见喽；

---

## 作者：墨忧 (赞：1)

## 题目大意

原题传送门： [Link](https://www.luogu.com.cn/problem/P7965) 。

给定一张有向图，每次询问图中两点是否连通。

## 思路

 ~~BFS 能过 Floyd 肯定也能过啊。~~

 Floyd - Warshall 全源最短路算法想必各位都不陌生，在这里提一下如何用 Floyd 判断两点之间是否连通（已经了解的巨佬们可跳过这部分）。
 
依旧是用邻接矩阵，但是保存的不再是边权，而是这两点是否连通。

在之后的三重循环中，如果起点到中间点，中间点到终点都连通，则起点与终点之间是连通的。

代码实现：

```cpp
for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) if(a[i][k] && a[k][j]) a[i][j]=true;
```

之后的询问就好解决了，如果连通，则输出 DA ，否则输出 NE 即可。

时间复杂度 $O(n^3)$ 。

**但是！最重要的是！ 开 O2 ！** （如果没开导致代码挂了，请不要来找我的锅。但如果数据加强了，可以撤下我的题解）。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,q,from,to,pi;
bool a[1005][1005];//邻接矩阵存储两个点之间是否连通 
inline int read()//快读 
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch && ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int main()
{
	n=read();
	m=read();
	q=read();
	for(int i=1;i<=n;i++) a[i][i]=true;
	for(int i=1;i<=m;i++)
		for(int i=1;i<=n;i++)
		{
			pi=read();
			a[i][pi]=true;//i 到 pi 之间有一条边 
		}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) if(a[i][k] && a[k][j]) a[i][j]=true;
	//Floyd 核心代码 
	for(int i=1;i<=q;i++)//查询 
	{
		from=read();
		to=read();
		if(a[from][to]) printf("DA\n");
		else printf("NE\n");
	}
	return 0;
}
```


---

## 作者：happybob (赞：1)

众所周知，`SPFA` 他死了。

但是这道题目真的不能用 `SPFA` 吗？

确实！

首先我们来说一下 `SPFA`，正常我们用 `queue` 进行 `SPFA`，这是我们照常的习惯。但是其实不光光用 `queue` 可以实现，用其他 `STL` 容器也可以。试过 `vector`，比 `queue` 好，但是还是 `T` 了不少。但是其实 `priority_queue` 会强很多，至于是按什么排序其实都可以，我是用 `less<int>` 的。

[SPFA（priority_queue) 测试](https://www.luogu.com.cn/record/65330786)

`SPFA` 开了 `priority_queue` 优化仍然会 `T` 一个点，大概率是大数据卡掉了 `SPFA`。

那怎么办呢？很简单。这题本质考的是 `BFS`，那么按数据分析，$n \ge 900$ 用 `BFS` ~~（其实 Subtask 1 和 Subtask 4 中 n 都是 1000）~~。不然就用 `SPFA`。

另外，对于这道题优先队列优化 `BFS` 也适用。

代码（开 `O2` 后 `AC`）：

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <cstdio>
using namespace std;

int n, m, q;
const int N = 1e3 + 5;
int dis[N];
int vec[N][N];
int ans[N][N];
bool vis[N], f[N], ansx[N][N];

struct ios_in // 快读
{
	inline char gc()
	{
		static char buf[N], * l, * r;
		return (l == r) && (r = (l = buf) + fread(buf, 1, N, stdin), l == r) ? EOF : *l++;
	}
	template <typename _Tp>
	inline ios_in& operator >> (_Tp& x) {
		static char ch, sgn;
		for (sgn = 0, ch = gc(); !isdigit(ch); ch = gc()) {
			if (!~ch) return *this;
			sgn |= ch == '-';
		}
		for (x = 0; isdigit(ch); ch = gc())
			x = (x << 1) + (x << 3) + (ch ^ '0');
		sgn && (x = -x);
		return *this;
	}
}Cin;

inline void spfa(int x) // spfa 模板
{
	priority_queue<int, vector<int>, less<int> > q; // 优先队列优化
	q.push(x);
	dis[x] = -1e7;
	while (q.size())
	{
		int l = q.top();
		q.pop();
		for (register int i = 1; i <= m; ++i)
		{
			int to = vec[i][l];
			if (dis[to] > dis[l] + 1)
			{
				dis[to] = dis[l] + 1;
				q.push(to);
			}
		}
	}
}

inline void bfs(int x) // bfs 模板
{
	priority_queue<int, vector<int>, less<int> > q;
	q.push(x);
	f[x] = true;
	vis[x] = true;
	while (q.size())
	{
		int l = q.top();
		q.pop();
		f[l] = true;
		for (register int i = 1; i <= m; ++i)
		{
			int to = vec[i][l];
			if (vis[to]) continue;
			q.push(to);
			vis[to] = true;
		}
	}
}

int main()
{
	Cin >> n;
	Cin >> m;
	Cin >> q;
	for (register int i = 1; i <= m; ++i)
	{
		for (register int j = 1; j <= n; ++j)
		{
			int x;
			Cin >> x;
			vec[i][j] = x; // 存储图
		}
	}
	if (n >= 900)
	{
		for (register int i = 1; i <= n; ++i)
		{
			memset(f, false, sizeof(f));
			memset(vis, false, sizeof(vis));
			bfs(i);
			for (register int j = 1; j <= n; ++j)
			{
				ansx[i][j] = f[j];
			}
		}
		while (q--)
		{
			int a, b;
			Cin >> a >> b;
			puts((!ansx[a][b] ? "NE" : "DA"));
		}
		return 0;
	}
	for (register int i = 1; i <= n; ++i)
	{
		memset(dis, 0, sizeof(dis));
		spfa(i);
		for (register int j = 1; j <= n; ++j)
		{
			ans[i][j] = dis[j];
		}
	}
	int a, b;
	while (q--)
	{
		Cin >> a;
		Cin >> b;
		puts((ans[a][b] == 0 ? "NE" : "DA"));
	}
	return 0;
}
```


---

## 作者：5k_sync_closer (赞：1)

有向图的传递闭包。（~~虽然不是正解~~）

复杂度：$O(\dfrac{n^3}w)$
# 题意
给定一张有向图，$q$ 次询问。

每次询问两个点 $u,v$，问存不存在 $u\rightarrow v$ 的路径。
# 思路
很明显的传递闭包，转换成边权 $1/0$ 的完全图。

然后把 Floyd 的取 $\min$ 转成或运算即可。

代码 1：
```cpp
#include <iostream>
using namespace std;
int n, m, q;bool f[1050][1050];
int main()
{
    cin >> n >> m >> q;
    while(m--)
        for(int i = 1, t;i <= n;++i)
            cin >> t, f[i][t] = 1;
    for(int k = 1;k <= n;++k)
        for(int i = 1;i <= n;++i)
            for(int j = 1;j <= n;++j)
                f[i][j] |= f[i][k] && f[k][j];
    for(int i = 0, u, v;i < q;++i)
    {
        cin >> u >> v;
        cout << (f[u][v] ? "DA" : "NE") << endl;
    }
    return 0;
}
```
[你以为这就能过了？](https://www.luogu.com.cn/record/65095818)

$O(n^3)$ 过 $10^9$，显然要优化。

有个 C++ 标准库设施叫 `bitset`，用法和 `bool` 数组差不多。

定义一个 `bitset` : `bitset<SIZE> b`，`b` 的大小为 `SIZE`。

然而，这个东西支持两个 `bitset` **整体位运算**，复杂度 $O(\dfrac nw)$（$w$ 是计算机位数）。

用 `bitset` 重写一遍：
```cpp
#include <iostream>
#include <bitset>
using namespace std;
int n, m, q;bitset<1050> f[1050];
int main()
{
    cin >> n >> m >> q;
    while(m--)
        for(int i = 1, t;i <= n;++i)
            cin >> t, f[i][t] = 1;
    for(int k = 1;k <= n;++k)
        for(int i = 1;i <= n;++i)
            if(f[i][k]) f[i] = f[i] | f[k];
    for(int i = 0, u, v;i < q;++i)
    {
        cin >> u >> v;
        cout << (f[u][v] ? "DA" : "NE") << endl;
    }
    return 0;
}
```
[你以为改成这样就能过了？](https://www.luogu.com.cn/record/65097092)

显然卡卡常就过了。
```cpp
#include <iostream>
#include <bitset>
using namespace std;
int n, m, q;bitset<1050> f[1050];
int main()
{
    ios::sync_with_stdio(0);
    cin >> n >> m >> q;
    while(m--)
        for(int i = 1, t;i <= n;++i)
            cin >> t, f[i][t] = 1;
    for(int k = 1;k <= n;++k)
        for(int i = 1;i <= n;++i)
            if(f[i][k]) f[i] = f[i] | f[k];
    for(int i = 0, u, v;i < q;++i)
    {
        cin >> u >> v;
        cout << (f[u][v] ? "DA" : "NE") << endl;
    }
    return 0;
}
```
[这不就过了吗](https://www.luogu.com.cn/record/65097105)

---

## 作者：V1mnkE (赞：0)

## 思路
~~这道题不是有向图啊。。~~ 显然，因为 ${p}$ 是 $1 ∼n$ 的一个排列，如果一个朋友将位于 $x$ 的小球移动到 $y$ ，那么一定可以从 $y$ 移到 $x$，无非是再邀请几次罢了，也就是说对于每个输入 $x_i=y$ ，连一条无向边 $(i,y)$。

那这道题就转化成了连通性问题，套个并查集板子维护连通性就可以了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,f[100005];
int find(int x){
	if(f[x]==x)return x;
	else return f[x]=find(f[x]);	
}
void uni(int u,int v){
	f[find(u)]=find(v);
}
int main(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			int p;
			cin>>p;
			uni(j,p);
		}
	}
	for(int i=1;i<=q;i++){
		int a,b;
		cin>>a>>b;
		if(find(a)!=find(b))cout<<"NE\n";
		else cout<<"DA\n";
	}
}
```

---

## 作者：hrgd (赞：0)

我们把置换 $p$ 看作 $n$ 条边 $i\to p_i$，那么提议就变为：

给定一张 $n$ 点 $n\times m$ 条边的有向图，每次判断 $a$ 是否能走到 $b$

这就是一个传递闭包。什么是传递闭包呢？

传递闭包就是一个对 $\text{floyd}$ 判断连通性的优化。

运用正常的 $\text{floyd}$，我们有一个 $O(n^3)$ 的做法：

```
for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
    	for(int j=1;j<=n;j++)
        	G[i][j]|=(G[i][k]&G[k][j]);
```

我们发现其中有大量的位运算，于是想到使用 $\text{bitset}$

枚举 $k,i$，当 $G_{i,k}=1$ 时，操作等价于 $G[i]|=G[k]$，否则操作无效。

这样我们的复杂度就降为了 $O(\frac {n^3}{\omega})$，可以通过本题。

```
#include<bits/stdc++.h>
using namespace std;
#define inf 1e9
const int maxn=2e5+10;
const int mod=1e9+7;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
const int N=1e3+5;
bitset<N>G[N];
int n,m,q;
int main(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)
	    for(int j=1,x;j<=n;j++)x=read(),G[j][x]=1;
	for(int k=1;k<=n;k++)
	    for(int i=1;i<=n;i++)if(G[i][k])G[i]|=G[k];
	while(q--){
	    int a=read(),b=read();
	    puts(G[a][b]?"DA":"NE");
	}
	return 0;
}
```

---


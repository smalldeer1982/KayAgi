# [蓝桥杯 2025 国 C] 拔河

## 题目描述

小蓝的学校正在举办一场拔河比赛，小蓝的任务是将队员分成实力尽可能平均的两组，这样比赛更加公平，观众也能够享受到更多的乐趣。

具体地说，每个队员都有一个力量值，小蓝希望两组队员分别的力量值之和的差的绝对值尽可能小。

40 位同学的力量值分别是：

345590635693812, 411735179294186, 190029355501347, 973598561303630,
18202819016954, 739089526396984, 41064501651340, 287075700776565,
458062562307032, 723278851371706, 997720296178889, 470475557480472,
329586527903215, 907379737442406, 631284976214798, 301204036247736,
747294692547790, 914091289062262, 144070679727924, 988094642462741,
413975599277375, 835461430976017, 344371572186185, 646160866308904,
880407857470630, 794629069521762, 462180977651587, 342038139286302,
854772507978666, 694223418935656, 567502001946067, 881035713848915,
840605474892139, 324727089144326, 226008847101330, 65143946718125,
499249957077991, 245803813100131, 447887480320685, 658036302578844.

在试题文件夹中有一个文件 tug.txt ，里面保存着这 40 个数。

请你帮小蓝求出这个最小的力量值之差的绝对值，注意：两组队员人数可以不同，每一个队员都必须被选入两组队伍中的某一组，不允许有队员被遗漏或重复分配。

# 题解

## 作者：_DATA_X_ (赞：5)

# P12878 题解：

好题。
## 主要思路：

看到题目第一眼就想到了背包，但值域太大，不太行。于是又想到把 $40$ 个数分成 $2$ 组，每组 $20$ 个数，采用 Meet-in-the-middle 算法，分别计算两组答案再合并。

## 代码实现：

**算法**：Meet-in-the-middle 算法 + 双指针

**思路**：将 $40$ 个数分成两组，分别用 map 存储，再分别处理两个 map 的子集和，然后合并，最后用双指针查找并输出结果。

**AC Code**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
    vector<long long> v={
        345590635693812, 411735179294186, 190029355501347, 973598561303630,
        18202819016954, 739089526396984, 41064501651340, 287075700776565,
        458062562307032, 723278851371706, 997720296178889, 470475557480472,
        329586527903215, 907379737442406, 631284976214798, 301204036247736,
        747294692547790, 914091289062262, 144070679727924, 988094642462741,
        413975599277375, 835461430976017, 344371572186185, 646160866308904,
        880407857470630, 794629069521762, 462180977651587, 342038139286302,
        854772507978666, 694223418935656, 567502001946067, 881035713848915,
        840605474892139, 324727089144326, 226008847101330, 65143946718125,
        499249957077991, 245803813100131, 447887480320685, 658036302578844
    };
    int n=v.size();
	int p=n/2;
	//预处理前半部分的所有可能子集和
	unordered_map<long long,long long> l;
	for(int h=0;h<(1<<p);h++){
	    long long sum=0;
	    for(int i=0;i<p;i++){
	        if(h&(1<<i)) sum+=v[i];
	    }
		l[h]=sum;
	}
	//预处理后半部分的所有可能子集和
	unordered_map<long long,long long> r;
	for(int h=0;h<(1<<(n-p));h++){
	    long long sum = 0;
	    for (int i=0;i<(n-p);i++){
	        if (h&(1<<i))sum+=v[p+i];
	    }
	    r[h]=sum;
	}
	long long t=0;
	for (auto p : v) t+=p;
	long long ans=t/2;
	long long mi=LLONG_MAX;
	//合并两部分结果
	vector<long long> lv,rv;
	for (auto& p : l) lv.push_back(p.second);
	for (auto& p : r) rv.push_back(p.second);
	sort(lv.begin(),lv.end());
	sort(rv.begin(),rv.end());
	//双指针查找最接近ans的和
	int i=0,j=rv.size()-1;
	while(i<lv.size()&&j>=0){
	    long long sum=lv[i]+rv[j];
	    mi=min(mi,abs(t-2*sum));
	    if(sum<ans){
	        i++;
	    }else if(sum>ans){
	        j--;
	    }else{
	        return 0; //找到完美分割
	    }
	}
    cout<<mi;
    return 0;
}

``````

---

## 作者：xzk2012 (赞：5)

这是一道好题。

首先想到暴力。显然不行。

那背包呢？值域太大，不能直接干。

因为不难发现，如果能将这个 40 打个折，变成 20 就简单了，所以考虑折半搜索。

代码就不贴了。友情提醒，结果是一个六千多的数。

---

## 作者：LittleAcbg (赞：3)

### $2^{40}$ 计算量的做法

考虑枚举每个数属于哪一队，计算两队力量值之和做差。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int n = 40;
const ll a[41] = {0, 345590635693812LL, 411735179294186LL, 190029355501347LL, 973598561303630LL, 18202819016954LL, 739089526396984LL, 41064501651340LL, 287075700776565LL, 458062562307032LL, 723278851371706LL, 997720296178889LL, 470475557480472LL, 329586527903215LL, 907379737442406LL, 631284976214798LL, 301204036247736LL, 747294692547790LL, 914091289062262LL, 144070679727924LL, 988094642462741LL, 413975599277375LL, 835461430976017LL, 344371572186185LL, 646160866308904LL, 880407857470630LL, 794629069521762LL, 462180977651587LL, 342038139286302LL, 854772507978666LL, 694223418935656LL, 567502001946067LL, 881035713848915LL, 840605474892139LL, 324727089144326LL, 226008847101330LL, 65143946718125LL, 499249957077991LL, 245803813100131LL, 447887480320685LL, 658036302578844LL}; // 将数据存入 a[1]~a[40]
ll ans = 1e18; // ans 初始值设为无穷大
void dfs(int k, ll dis) // 当前考虑 a[k]，目前第一队减第二队力量值差为 dis
{
    if (k == n + 1) // 所有都已枚举好
    {
        ans = min(ans, abs(dis)); // 差的绝对值
        return;
    }
    dfs(k + 1, dis + a[k]); // 选入第一队
    dfs(k + 1, dis - a[k]); // 选入第二队
}
int main()
{
    dfs(1, 0);
    cout << ans << endl;
    return 0;
}
```

其计算量为 $2^{40}\approx1.1\times10^{12}$，并不能通过本题，~~但可以用这份代码在本地跑几个小时之后直接输出答案 $6566$。~~

### $2^{40}$ 计算量的做法 II

观察 $40$ 这个数，容易发现 $2^{20}\approx10^6$，我们考虑使用 Meet in the Middle。这种思想是将 $40$ 个元素拆成两半分别计算，将它们的所有可能结果（即两队力量值之差）存储后进行合并。

合并的时候，直接枚举两半的差，将它们相加就是整体的差值了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int n = 40;
const ll a[41] = {0, 345590635693812LL, 411735179294186LL, 190029355501347LL, 973598561303630LL, 18202819016954LL, 739089526396984LL, 41064501651340LL, 287075700776565LL, 458062562307032LL, 723278851371706LL, 997720296178889LL, 470475557480472LL, 329586527903215LL, 907379737442406LL, 631284976214798LL, 301204036247736LL, 747294692547790LL, 914091289062262LL, 144070679727924LL, 988094642462741LL, 413975599277375LL, 835461430976017LL, 344371572186185LL, 646160866308904LL, 880407857470630LL, 794629069521762LL, 462180977651587LL, 342038139286302LL, 854772507978666LL, 694223418935656LL, 567502001946067LL, 881035713848915LL, 840605474892139LL, 324727089144326LL, 226008847101330LL, 65143946718125LL, 499249957077991LL, 245803813100131LL, 447887480320685LL, 658036302578844LL}; // 将数据存入 a[1]~a[40]
vector<ll> vec1,vec2; // 分别存储 1~20 和 21~40 的所有可能结果 
void dfs1(int k, ll dis) // 1~20
{
    if (k == 21)
    {
        vec1.push_back(dis); // 存储一种可能结果
        return;
    }
    dfs1(k + 1, dis + a[k]);
    dfs1(k + 1, dis - a[k]);
}
void dfs2(int k, ll dis) // 21~40
{
    if (k == 41)
    {
        vec2.push_back(dis); // 存储一种可能结果
        return;
    }
    dfs2(k + 1, dis + a[k]);
    dfs2(k + 1, dis - a[k]);
}
int main()
{
    dfs1(1, 0);
    dfs2(21, 0);
    ll ans = 1e18; // 初始值无穷大 
    for (auto a : vec1) // 枚举所有 1~20 可能结果
		for (auto b : vec2) // 枚举所有 21~40 可能结果
			ans = min(ans, abs(a + b)); // 合并结果，更新答案
	cout << ans << endl; 
    return 0;
}
```

由于两半的差值最多都可能达到 $2^{20}$，所以合并的计算量就变成了 $2^{40}$，无法通过，~~但一样可以在本地跑几个小时之后直接输出答案 $6566$。~~

### $2^{20}\times20$ 计算量的做法

注意到对每个前一半的元素（此处元素指 `vec1` `vec2` 中元素，即可能的差值），在后一半中只有两个元素与之合并可能构成最优解，即最大的使二者之和 $\le0$ 的元素与最小的使二者之和 $\ge0$ 的元素。

对前一半的元素 $a$，考虑二分找到最小的 $b$ 使得 $a+b\ge0$ 即 $b\ge-a$，那么 $|a+b|$ 和 $|a+b'|$ 都更新一下答案即可，其中 $b'$ 是后一半中比 $b$ 小的最大元素。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int n = 40;
const ll a[41] = {0, 345590635693812LL, 411735179294186LL, 190029355501347LL, 973598561303630LL, 18202819016954LL, 739089526396984LL, 41064501651340LL, 287075700776565LL, 458062562307032LL, 723278851371706LL, 997720296178889LL, 470475557480472LL, 329586527903215LL, 907379737442406LL, 631284976214798LL, 301204036247736LL, 747294692547790LL, 914091289062262LL, 144070679727924LL, 988094642462741LL, 413975599277375LL, 835461430976017LL, 344371572186185LL, 646160866308904LL, 880407857470630LL, 794629069521762LL, 462180977651587LL, 342038139286302LL, 854772507978666LL, 694223418935656LL, 567502001946067LL, 881035713848915LL, 840605474892139LL, 324727089144326LL, 226008847101330LL, 65143946718125LL, 499249957077991LL, 245803813100131LL, 447887480320685LL, 658036302578844LL}; // 将数据存入 a[1]~a[40]
vector<ll> vec1,vec2;
void dfs1(int k, ll dis)
{
    if (k == 21)
    {
        vec1.push_back(dis);
        return;
    }
    dfs1(k + 1, dis + a[k]);
    dfs1(k + 1, dis - a[k]);
}
void dfs2(int k, ll dis)
{
    if (k == 41)
    {
        vec2.push_back(dis);
        return;
    }
    dfs2(k + 1, dis + a[k]);
    dfs2(k + 1, dis - a[k]);
}
int main()
{
    dfs1(1, 0);
    dfs2(21, 0);
    sort(vec2.begin(), vec2.end());
    ll ans = 1e18;
    for (auto a : vec1)
    {
    	int pos = lower_bound(vec2.begin(), vec2.end(), -a) - vec2.begin(); // 找第一个 >= -a 的位置
		ans = min(ans, abs(a + vec2[pos])); // 用当前元素更新答案
		if (pos >= 1) // 有更小的元素
			ans = min(ans, abs(a + vec2[pos - 1])); // 用更小的元素更新答案 
	}
	cout << ans << endl;
    return 0;
}
```

计算量为 $2^{20}\times\log_22^{20}=2^{20}\times20$，能够在 $0.5$ 秒得到结果 $6566$（洛谷 $0.3$ 秒）。

### $2^{20}$ 计算量的做法

注意到在前一种做法中，对每一个前一半的元素 $a$，$a$ 越大，找到的 $b$ 越小，呈现一种单调性。所以我们对 $a$ 排序，然后在 $a$ 逐渐增大的过程中，让 $b$ 逐渐减小，使用双游标即可去除二分，继而优化计算量。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int n = 40;
const ll a[41] = {0, 345590635693812LL, 411735179294186LL, 190029355501347LL, 973598561303630LL, 18202819016954LL, 739089526396984LL, 41064501651340LL, 287075700776565LL, 458062562307032LL, 723278851371706LL, 997720296178889LL, 470475557480472LL, 329586527903215LL, 907379737442406LL, 631284976214798LL, 301204036247736LL, 747294692547790LL, 914091289062262LL, 144070679727924LL, 988094642462741LL, 413975599277375LL, 835461430976017LL, 344371572186185LL, 646160866308904LL, 880407857470630LL, 794629069521762LL, 462180977651587LL, 342038139286302LL, 854772507978666LL, 694223418935656LL, 567502001946067LL, 881035713848915LL, 840605474892139LL, 324727089144326LL, 226008847101330LL, 65143946718125LL, 499249957077991LL, 245803813100131LL, 447887480320685LL, 658036302578844LL}; // 将数据存入 a[1]~a[40]
vector<ll> vec1,vec2;
void dfs1(int k, ll dis)
{
    if (k == 21)
    {
        vec1.push_back(dis);
        return;
    }
    dfs1(k + 1, dis + a[k]);
    dfs1(k + 1, dis - a[k]);
}
void dfs2(int k, ll dis)
{
    if (k == 41)
    {
        vec2.push_back(dis);
        return;
    }
    dfs2(k + 1, dis + a[k]);
    dfs2(k + 1, dis - a[k]);
}
int main()
{
    dfs1(1, 0);
    dfs2(21, 0);
    sort(vec1.begin(), vec1.end()); // 分别排序
    sort(vec2.begin(), vec2.end());
    ll ans = 1e18;
    int pos = vec2.size() - 1;
    for (auto a : vec1)
    {
    	while (pos >= 1 && a + vec2[pos - 1] >= 0) --pos; // pos 递减找到最小的一个 a+b>=0
		ans = min(ans, abs(a + vec2[pos])); // 与之前一样更新答案
		if (pos >= 1)
			ans = min(ans, abs(a + vec2[pos - 1]));
	}
	cout << ans << endl;
    return 0;
}
```

本地 $0.3$ 秒，洛谷 $160$ 毫秒。

### 后记

OI 本来就是一个不断优化的过程，当你写出一种算法的时候，不妨想想效率更高的解法，也许就能突破自己。

写作本文时，我还试图运行前两份程序，但我本地太慢了，如果按每秒 $10^8$ 计算量来算，也得跑上两个多小时，于是我就放弃了写出精确的时间，而是粗略地写上了“几个小时”。

---

## 作者：SuyctidohanQ (赞：3)

### 思路分析

好题。

这道拔河题要求将 $40$ 个队员分成两组，使两组力量值之和的差的绝对值最小。

直接枚举所有 $2^{40}$ 种分组方式显然不可行，于是采用 Meet-in-the-middle 算法优化。将队员分为前 $20$ 个和后 $20$ 个，分别计算所有可能的分组和，再合并两组结果找到**最接近总力量一半的组合**。

### 代码实现

这里提供 C++ 的代码实现。

```cpp
#include<bits/stdc++.h>
#define please return 
#define AC 0
#define str string
#define rep(i, a, b) for(long long i = a; i <= b; i++)
#define repr(i, a, b) for(long long i = b; i >= a; i--)

using namespace std;

typedef long long LL;

signed main() {
	vector<LL> a = {345590635693812,411735179294186,190029355501347,973598561303630,18202819016954,739089526396984,41064501651340,287075700776565,458062562307032,723278851371706,997720296178889,470475557480472,329586527903215,907379737442406,631284976214798,301204036247736,747294692547790,914091289062262,144070679727924,988094642462741,413975599277375,835461430976017,344371572186185,646160866308904,880407857470630,794629069521762,462180977651587,342038139286302,854772507978666,694223418935656,567502001946067,881035713848915,840605474892139,324727089144326,226008847101330,65143946718125,499249957077991,245803813100131,447887480320685,658036302578844};
	LL s = 0;
	for(LL x : a) s += x;
	LL t = s / 2;
	vector<LL> b(a.begin(), a.begin() + 20);
	vector<LL> c(a.begin() + 20, a.end());

	vector<LL> l;
	rep(m, 0, (1 << 20) - 1) {
		LL sum = 0;
		rep(i, 0, 19)
			if(m & (1 << i)) sum += b[i];
		l.push_back(sum);
	}
	sort(l.begin(), l.end());

	LL mi = abs(s - 2 * l[0]);
	rep(m, 0, (1 << 20) - 1) {
		LL sum = 0;
		rep(i, 0, 19) 
			if(m & (1 << i)) sum += c[i];
		LL tt = t - sum;
		auto it = lower_bound(l.begin(), l.end(), tt);
		if(it != l.end()) {
			LL cu = sum + *it;
			LL di = abs(s - 2 * cu);
			if(di < mi) mi = di;
		}
		if(it != l.begin()) {
			--it;
			
			LL cu = sum + *it;
			LL di = abs(s - 2 * cu);
			if(di < mi) mi = di;
		}
	}
	cout << mi << '\n';
	please AC; 
}
```

答案为 $6566$。

```python
print(6566)
```

---

## 作者：victorup (赞：1)

## P12878 [蓝桥杯 2025 国 C] 拔河 题解

### 解题思路
   问题转化：设所有人力量总和为 $S$，我们需要找到一个子集，其和尽可能接近 $\lfloor \frac{s}{2} \rfloor$。这样两队的力量差就是：
   $$S - 2 \times subsetsum$$

 
接着用动态规划来解决这个问题。定义 $dp_i,_j$ 表示前 $i$ 个人中是否能组成力量总和为 $j$ 的团队。

再使用一维数组来优化空间复杂度，从后向前更新 `dp` 数组。

这样，最优解就出现了。在完成 `dp` 数组填充后，从 $\lfloor \frac{s}{2} \rfloor$ 开始向两边寻找最接近 $\lfloor \frac{s}{2} \rfloor$ 的可达值。

代码在这里先不附了，相信给出了思路，各位 dalao 都会写。

因为这是本蒟蒻的第一篇题解，dalao 勿喷，有不好的地方请大家尽情谅解。

为方便大家调试，答案为 65--。

希望管理员大大给过。

---

## 作者：Spouter_27 (赞：0)

这个题目很类似于背包问题，但是值域太大了，不能直接 dp。   

所以需要用到暴力点的搜索。但是又不能直接搜索，因为状态量太大了，要搜 $2^{40}$ 次，估计要搜上几个小时。

可以发现，如果能将这个 $40$ 减为 $20$ 就很舒服，所以考虑 meet-in-the-middle。

设 $40$ 个数的总和为 $S$。

因为要让两组数的差尽量小，所以考虑让这两组数分别的和尽量接近 $\frac{S}{2}$。

我们先搜索前 $20$ 个数，将每一种选法（共 $2^{20}$ 种）选出来的各个数的总和存到一个数组里，然后排序。

然后再搜索后 $20$ 个数，每一种选法选出来的各个数的总和为 $S_1$，则在上面的那个数组中，找到与 $S_1$ 相加最接近 $\frac{S}{2}$ 的那一堆数。这个过程可以二分查找。

然后我们就可以将第二次搜索选出来的这些数和查找查出来的这些数作为一组，剩下的数作为另一组，这种情况下他们的差会最小。而最佳方案肯定包括在这当中。

提示：为了方便您调试，答案为 $65\star\star$。

---


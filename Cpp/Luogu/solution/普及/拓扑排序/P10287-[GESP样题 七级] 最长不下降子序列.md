# [GESP样题 七级] 最长不下降子序列

## 题目描述

小杨有个包含 $n$ 个节点 $m$ 条边的有向无环图，其中节点的编号为 $1$ 到 $n$。

对于编号为 $i$ 的节点，其权值为 $w_i$。对于图中的一条路径，根据路径上的经过节点的先后顺序可以得到一个节点权值的序列，小杨想知道图中所有可能序列中最长不下降子序列的最大长度。

注：给定一个序列 $S$，其最长不下降子序列 $S'$ 是原序列中的如下子序列：整个子序列 $S'$ 单调不降，并且是序列中最长的单调不降子序列。例如，给定序列 $S = [11,12,13,9,8,17,19]$，其最长不下降子序列为 $S'=[11,12,13,17,19]$，长度为 $5$。

## 说明/提示

### 数据规模与约定

| 子任务 | 分值 | $n\le$ | $A_i \le$ | 特殊约定 |
| :-: | :-: | :-: | :-: | :-:|
| $1$ | $30$ | $10^3$ | $10$ | 输入的图是一条链 |
| $2$ | $30$ | $10^5$ | $2$ | 无 |
| $3$ | $40$ | $10^5$ | $10$ | 无|

对全部的测试数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 10^5$，$1 \leq A_i \leq 10$。


## 样例 #1

### 输入

```
5 4
2 10 6 3 1
5 2
2 3
3 1
1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 11
1 1 2 1 1 2
3 2
3 1
5 3
4 2
2 6
3 6
1 6
4 6
1 2
5 1
5 4```

### 输出

```
4```

## 样例 #3

### 输入

```
6 11
5 9 10 5 1 6
5 4
5 2
4 2
3 1
5 3
6 1
4 1
4 3
5 1
2 3
2 1```

### 输出

```
4```

# 题解

## 作者：LionBlaze (赞：29)

其实我一开始看到也是拓扑排序 + DP，并且和 spfa_ 大佬最后的结论一样，但会更详细点。

## 为什么要拓扑排序？

> 小杨有个包含 $n$ 个节点 $m$ 条边的**有向无环图**。 \
根据路径上的**经过节点的先后顺序**可以得到一个节点权值的序列。

正是拓扑排序的拿手好戏。

# DP 开始
## 定义
### 第一种
直接套，$f_i$ 表示从某个点到点 $i$，最长不下降子序列的最大长度。

然后每遇到一条边就更新一次。

然后……就没有然后了。$ \color{white}{\texttt{吗？}} $

时间复杂度：一共 $m$ 条边，每条边转移时间复杂度为 $O(n)$，总时间复杂度为 $O(nm)$，毫无疑问会 TLE。

看来不行。

### 第二种

抓住题目的“弱点”，发现一个很奇怪的条件，$1 \le A_i \le 10$。

所以可以成为 $f$ 的第二维：

$f_{i,j}$ 代表从某个点开始，到点 $i$，满足最后一个数字为 $j$ 的最长不下降子序列的最大长度。

## 初始状态

所有 $f_{i,A_i} = 1$：只有当前点。

## 转移顺序

拓扑序，如果不是，在转移当前点时可能某个前驱节点还没转移到，如果从那个节点转移到这个节点刚好是最优解（或者最优解的一部分），答案就会出错。

## 状态转移方程

重点来了！

对于点 $v$ 的某一个前驱结点 $u$（或者对于点 $u$ 的某个后继结点 $v$），有两种转移：

### 第一种

一种是将点 $v$ 加入到点 $u$ 的最长不下降子序列中，比如：

此时点 $u$ 的最长不下降子序列为 $1,2,3$（即 $f_{u,3} = 3$），而 $A_v \ge 3$，则这种转移会使 $f_{v, A_v} = f_{u, 3} + 1 = 4$，前提是原 $f_{v, A_v} < 4$（不然得到更劣的解）。

不难知道：

$$ \forall 1 \le i \le A_v:f_{v, A_i}=\max(f_{v, A_i}, f_{u, i} + 1) $$

右边很好理解。左边为什么是 $1 \le i \le A_v$ 呢？不可以大于 $A_v$ 吗？

不可以。

因为在不下降序列的末尾增加一个比原来的末尾更小的元素，增加后就不是不下降序列了。

比如你在不下降序列 $1,2,3$ 最后加入一个 $2$，最后还满足不下降吗？显然不满足。

### 第二种

第二种就是不算上元素 $v$，本来是 $1,2,3$ 现在还是 $1,2,3$，子序列嘛，可以去除某些元素（这里是去除元素 $v$）。

$$ \forall 1 \le i \le 10 : f_{v,i} = \max(f_{v,i},f_{u,i}) $$

## 答案

所有有意义的 $f_{i,j}$ 的最大值（有意义：$1\le i \le n$，$1 \le j \le 10$）

## 完结撒花~代码

```cpp
#include <queue>
#include <cstdio>
#include <vector>

using namespace std;

vector<int> web[100005]; //邻接表
int a[100005]; //A
int ind[100005]; //入度
int f[100005][15];
/*
f[i][j] 代表从xxx节点到i节点，末尾为j的最长不下降子序列长度
*/

int main()
{
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", a + i);
	}
	for(int i=1;i<=m;i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		web[u].push_back(v); //建图
		ind[v]++; //入度++
	}
	queue<int> q; //拓扑排序
	for(int i=1;i<=n;i++)
	{
		if(ind[i] == 0) //入度为0，进队
		{
			q.push(i);
		}
		f[i][a[i]] = 1; //f初始
	}
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int v : web[u])
		{
			if(!--ind[v]) q.push(v); //入度变为0
			for(int i=1;i<=a[v];i++)
			{
				if(f[u][i] + 1 > f[v][a[v]]) f[v][a[v]] = f[u][i] + 1; //第一种转移
			}
			for(int i=1;i<=10;i++)
			{
				if(f[u][i] > f[v][i]) f[v][i] = f[u][i]; //第二种转移
			}
		}
	}
	int maxn = 0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=10;j++)
		{
			if(f[i][j] > maxn) maxn = f[i][j]; //取最大
		}
	}
	printf("%d\n", maxn);
	return 0;
}
```

---

## 作者：wrh316 (赞：19)

看到这道题，肯定是图上的动态规划。 

思路：首先按题目读入，顺便统计入度。然后将入度为 $0$ 的点放入队列，进行拓扑排序。再对每条边进行动态规划，最后求最大值就行了。这道题是一道比较模版的题目。

上代码： 
```
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
int n,m;
int a[N],d[N];
int f[N][15];
queue<int> q; 
vector<int> g[N];
int main(){
	cin>>n>>m;
	for(int i = 1;i <= n;i++) cin>>a[i];//读入 
	for(int i = 1,u,v;i <= m;i++){
		cin>>u>>v;
		g[u].push_back(v);//建边 
		d[v]++;//统计入度 
	}
	for(int i = 1;i <= n;i++){//拓扑排序初始化 
		if(!d[i]){
			q.push(i);
			f[i][a[i]] = true;
		}
	}
	while(!q.empty()){
		int u = q.front(); q.pop();
		for(auto i : g[u]){//dp
			for(int j = 1;j <= 10;j++) f[i][j] = max(f[i][j],f[u][j]);
			d[i]--;
			if(!d[i]){
				for(int k = a[i];k >= 1;k--) f[i][a[i]] = max(f[i][a[i]],f[i][k] + 1); 
				q.push(i);
			}
		}
	}
	int ans = 1;
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= 10;j++) ans = max(ans,f[i][j]);//求最大值 
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：spfa_ (赞：10)

[P10287 [GESP样题 七级] 最长不下降子序列](https://www.luogu.com.cn/problem/P10287)

### 题目分析

如果仿照求 LIS 的套路去解决这道题，那么就可以用拓扑排序来 dp，但是空间太大，是无法忍受的。但是我们注意到 $1\le A_i\le 10$，所以我们就可以用 $f_{i,j}$ 表示点 $i$，当前最长不降子序列的末尾处为 $j$，转移比较显然，那么这道题就做完啦。

### code

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

const int N = 1e5+5;
int n, m, ans, a[N], in[N], f[N][11];
vi E[N];

int main() {
	n = rd(), m = rd();
	for (int i = 1; i <= n; ++i) a[i] = rd();
	while (m--) {
		int x = rd(), y = rd();
		E[x].pb(y), ++in[y];
	}
	queue <int> q;
	for (int i = 1; i <= n; ++i) if (!in[i]) q.push(i), f[i][a[i]] = 1;
	while (q.size()) {
		int x = q.front(); q.pop();
		for (int y:E[x]) {
			if (--in[y] == 0) q.push(y);
			for (int i = 1; i <= a[y]; ++i) f[y][a[y]] = max(f[y][a[y]], f[x][i]+1);
			for (int i = 1; i <= 10; ++i) f[y][i] = max(f[y][i], f[x][i]);
		}
	}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= 10; ++j)
			ans = max(ans, f[i][j]);
	write(ans);
	return 0;
}
```

---

## 作者：andyli (赞：7)

注意到 $A_i$ 很小，考虑动态规划，设 $f_{i,j}$ 表示以点 $i$ 结尾的路径中最长不下降⼦序列最后一位是 $j$ 的最长不下降⼦序列长度。则容易写出转移，按拓扑序转移即可。答案取所有 dp 值的最大值。  

```cpp
int main() {
    dR(int, n, m);
    dRV(int, a, n);
    auto g = read_graph<void, true>(n, m);
    VECI(d, n, 10, -inf<int>);
    _for (i, n) {
        d[i][--a[i]] = 1;
    }
    foreach (u, toposort(g)) {
        foreach (v, g[u]) {
            _for (x, a[v] + 1) // 0 <= x <= a[v]
                chkmax(d[v][a[v]], d[u][x] + 1);
            _for (x, 10)
                chkmax(d[v][x], d[u][x]);
        }
    }
    int ans = -inf<int>;
    _for (i, n)
        _for (j, 10)
            chkmax(ans, d[i][j]);
    print(ans);
    return 0;
}
```

---

## 作者：Melo_qwq (赞：6)

拓扑加 dp 好题，赶紧来一发题解。

看到题目，有向无环图和先后顺序都在提示用拓扑排序，求最长不降子序列直接用动规，没有思维难度，怪不得是黄。

真的有这么简单吗？

上述方法复杂度是 $O(n^2)$ 的，对于 $10^5$ 规模的数据毫无疑问会炸。

考虑优化，我们注意到 $A_i\le10$，所以 dp 数组可以开 $2$ 维，用 $dp_{i ,j}$ 表示区间 $[1 ,i]$ 中以值 $j$ 结尾最长不降子序列的**长度**。

正解想出，在拓扑中每到一个点，就更新它的 dp 值，注意它前面项的值必须不大于它。复杂度 $O(n + m)$。

## 上代码：

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define IOS ios :: sync_with_stdio(0) ;cin.tie (0) ;cout.tie (0)
using namespace std ;
const int N = 1e5 + 7 ;
int n ,m ,head[N << 1] ,in[N << 1] ,tot ,a[N] ,dp[N][17] ;
struct edge {
	int to ,nxt ;
}e[N << 1] ;
namespace kafka {//卡妈\se\se
	inline void add (int u ,int v) {
		in[v] ++ ;
		e[++ tot].nxt = head[u] ;
		head[u] = tot ;
		e[tot].to = v ;
	}
	inline void topo () {
		queue <int> q ;
		rep (i ,1 ,n ,1) {
			if (! in[i]) {
				q.push (i) ;
				dp[i][a[i]] = 1 ;
			}
		}
		while (! q.empty ()) {
			int now = q.front () ;
			q.pop () ;
			for (int i = head[now] ;i ;i = e[i].nxt) {
				int nex = e[i].to ;
				if (-- in[nex] == 0) {
					q.push (nex) ;
				}
				rep (i ,1 ,a[nex] ,1) {
					dp[nex][a[nex]] = max (dp[nex][a[nex]] ,dp[now][i] + 1) ;
				}
				rep (i ,1 ,10 ,1) {
					dp[nex][i] = max (dp[nex][i] ,dp[now][i]) ;
				}//全部取最大值以防漏算
			}
		}
	}
}
int main () {
	IOS ;
	cin >> n >> m ;
	rep (i ,1 ,n ,1) {
		cin >> a[i] ;
	}
	rep (i ,1 ,m ,1) {
		int u ,v ;
		cin >> u >> v ;
		kafka :: add (u ,v) ;
	}
	kafka :: topo () ;
	int ans = INT_MIN ;
	rep(i ,1 ,n ,1) {
		rep (j ,1 ,10 ,1) {
			ans = max (ans ,dp[i][j]) ;
		}
	}
	cout << ans << '\n' ;
	return 0 ;
}
```

你是否承认卡芙卡的美貌举世无双？

---

## 作者：SmileFaintly (赞：3)

## 思路：
我们先看第三个样例：
![](https://cdn.luogu.com.cn/upload/image_hosting/ulyr3q7a.png)
拓扑排序后，节点 $1$ 到 $n$ 分别为：$5,6,4,3,2,1$ 加上 $a$ 数组的权为：$1,6,5,9,10,5$ 答案是：${\color{red}1},6,{\color{red}5},{\color{red}9},{\color{red}10},5$。
## 思路：
#### 重点：$a_i\le10$。
所以设动态规划的状态表示以节点 $i$ 结尾的路径中最长不下降⼦序列最后一位是 $j$ 的长度。
- **构建有向图：** 记录每个节点的权值。
- **拓扑排序：** 从图中的每个节点开始拓扑，同时在拓扑的过程中记录每个节点的最长不下降子序列长度。对于当前节点，遍历其所有邻居节点，如果邻居节点的权值大于等于当前节点的权值，更新邻居节点的最长不下降子序列长度。可以得出转移方程：$f_{v,i}=\max(f_{v,i},f_{u,i})$。
- **动态规划：** 在拓扑的过程中，实时更新每个节点的最长不下降子序列长度。在更新过程中，需要比较当前节点的最长不下降子序列长度与所有可达节点的最长不下降子序列长度之和，并取其中的最大值作为当前节点的最长不下降子序列长度。
- **计算结果：** 遍历所有节点，找最大值。

## 代码：
```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

int n,m,a[100005];
vector<int>g[100005];
int u,v;
int s[100005],top;
int rudu[100005];
queue<int>q;
int dp[100005][11];
int ma;

int tuopu(){
	for(int i=1;i<=n;i++){
		if(rudu[i]==0){
			q.push(i);
			dp[i][a[i]]=1;
		}
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(auto i : g[u]){
			int v=g[u][i];
			for(int j=1;j<=10;j++){
				dp[i][j]=max(dp[i][j],dp[u][j]);
			} 
			rudu[i]--;
			if(rudu[i]==0){
				for(int k=a[i];k>=1;k--) {
					dp[i][a[i]]=max(dp[i][a[i]],dp[i][k]+1); 
				}
				q.push(i);
			}
		}
	}
	return 0;
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>u>>v;
		g[u].push_back(v);
		rudu[v]++;
	}
	tuopu();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=10;j++){
			ma=max(ma,dp[i][j]);
		} 	
	} 
	cout<<ma;
	return 0;
}
```

---

## 作者：leiaxiwo (赞：3)

# 洛谷 P10287 

## 一道比较入门的 DP 题

### 观察到这是一个 LIS 问题 


LIS 定义：最长不下降子序列是序列中的这样一个子序列：整个子序列单调不降，并且是序列中最长的单调不降子序列。

~~题目名字就是这玩意不是废话吗~~

不会 LIS 的老哥们可以移步[【动态规划基础】求最长不下降序列](https://blog.csdn.net/DUXS11/article/details/132270411)

在搞清楚 LIS 是什么以后，我们发现这是一道图论题，在图上进行 LIS 操作可以借助拓扑排序。具体地，本题可以使用 kahn 算法求出路径关系。

不会 kahn 的老哥可以移步[【模板】拓扑排序 / 家谱树](https://www.luogu.com.cn/problem/B3644)

那么对它进行拓扑之后我们就可以对每个部分分开求一遍 LIS,有人就要问，这东西不会超空间咩。

正常来说它的空间如果 $A_i$ 和 $n$ 非常接近必然炸，但是本题 $1<A_i<10$,所以没问题。

我们考虑用 $f_{i,j}$ 表示以 $i$ 结尾路径中最后一位为 $j$ 的路径长度，那么有状态转移方程

$$f[y][a[y]]=max(f[y][a[y]],f[x][i]+1)$$

其中 `y` 为拓扑排序中的下标,`a[y]` 是它们在 DP 中的权值。

答案显然取所有 DP 结果的最大值，本题如果改为降序也只需把 `max()` 函数改为`min()`  函数即可。

处理方式为 `ans=max(ans,f[i][j])`

以下是样例代码，建议结合注释阅读

```cpp
//请加入-std=c++14以避免报错
#include<bits/stdc++.h>
using namespace std;
int f[500005][15],a[500005],in[500005];//f是dp数组，a是点权，in是入度 
vector<int> e[500005];//vector存图，链式前向星也可 
int n,m,ans;//如题 
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		++in[y];//入度特殊处理 
	}
	queue<int> q;
	for(int i=1;i<=n;i++){//预处理入度为0的边，kahn算法，本题也可使用基于 DFS的拓扑排序 
		if(!in[i]){//等价于in[i]==0 
			q.push(i);//找出入度为0的边 
		}
		f[i][a[i]]=1;//特殊标记 
	}
	while(!q.empty()){//等价于 while(q.size())
		int x=q.front();//取出队首 
		q.pop();
		for(auto y:e[x]){//auto： 和 int：写法是c++14的新鲜写法，使用老教材的建议系统学习，可以提升算法效率 
			if(--in[y]==0){//前一句等价于for(int i=1;i<e[x].size;i++) int y=e[x]; auto是自动类型变量，取决于输入或等于的内容 
			    q.push(y);
			}
			for(int i=1;i<=a[y];i++){
				f[y][a[y]]=max(f[y][a[y]],f[x][i]+1);//状态转移方程 
			}
			for(int i=1;i<=10;i++){
				f[y][i]=max(f[y][i],f[x][i]);//取最大值 
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=10;j++){
		    ans=max(ans,f[i][j]);//遍历求所有边的最大值 
		}
	}
	printf("%d",ans);//输出 
	return 0;//完结撒花 
}
```

---

## 作者：Tomle (赞：3)

# 思路
因为是有向无环图，自然地想到了拓扑排序。

按照拓扑序跑 dp，状态转移很显然了。

$f_{i,j}$ 表示第 $i$ 个节点最后一个数是 $j$ 的最长不下降子序列的长度。$v$ 表示终点，数组 $u$ 表示所有终点是 $v$ 的边的起点。$\lvert u \rvert$ 表示长度。

$$
f_{v,j}=\left\{
\begin{array}{lcl}
\max\limits_{i \le \lvert u \rvert}{f_{u_i,j}}\\
\max\{ \max\limits_{i \le \lvert u \rvert}{f_{u_i,j}}&\max\limits_{i \le a_i}f_{v,i} + 1 \}    &      & {j=a_i}
\end{array} \right.
$$

跑拓扑的时候可以直接让一个点更新与它连边的点。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, u, v, a[100005], f[100005][10], in[100005], ans;
vector <int> son[100005];

void read(int &a) {
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	a = x * f;
}
void topo_dp() {
	queue <int> q;
	for (int i = 1; i <= n; i++) {
		if (in[i] == 0) q.push(i);
	}
	while (q.size()) {
		int u = q.front();
		q.pop();
		int maxn = 0;
		for (int i = 1; i <= a[u]; i++) {
			maxn = max(maxn, f[u][i]);
		}
		f[u][a[u]] = max(f[u][a[u]], maxn + 1);
		for (auto v : son[u]) {
			in[v]--;
			for (int i = 1; i <= 10; i++) {
				f[v][i] = max(f[v][i], f[u][i]);
			}
			if (in[v] == 0) {
				q.push(v);
			}
		}
	}
}
int main() {
	read(n);
	read(m);
	for (int i = 1; i <= n; i++) {
		read(a[i]);
	}
	for (int i = 1; i <= m; i++) {
		read(u);
		read(v);
		son[u].push_back(v);
		in[v]++;
	}
	topo_dp();
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= 10; j++) {
			ans = max(ans, f[i][j]);
		}
	}
	cout << ans;
	return 0;
}
```

---


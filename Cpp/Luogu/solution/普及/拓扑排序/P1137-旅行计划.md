# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# 题解

## 作者：星星之火 (赞：107)

我看了一下其他大佬的题解，大部分都是拓扑排序加上DP。那么我想有的人是不明白为什么这么做的，拓扑排序有什么性质使得可以DP呢?下面我就提一下。

对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。 （源自百度）

通俗的说就是，一张有向无环图的拓扑序可以使得任意的起点u,它的一个终点v，在序列中的顺序是u在前v在后

我下面先附上代码，然后在继续说明

```
#include<bits/stdc++.h>
using namespace std;

const int maxn=100000+15;
int n,m,sum,tot;
int head[maxn],ru[maxn],ts[maxn],dp[maxn];
struct EDGE
{
	int to;int next;
}edge[maxn<<2];
void add(int x,int y)
{
	edge[++sum].next=head[x];
	edge[sum].to=y;
	head[x]=sum;
}
void topsort()
{
	queue <int> q;
	for (int i=1;i<=n;i++)
	if (ru[i]==0) {
	q.push(i);
	ts[++tot]=i;
}
	while (!q.empty())
	{
		int u=q.front();q.pop();
		for (int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			ru[v]--;
			if (ru[v]==0) {
			q.push(v);ts[++tot]=v;
		}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		ru[v]++;
	}
	topsort();
	for (int i=1;i<=n;i++) dp[i]=1;
	for (int i=1;i<=n;i++)
	{
		int u=ts[i];
		for (int j=head[u];j;j=edge[j].next)
		{
			int v=edge[j].to;
			dp[v]=max(dp[v],dp[u]+1);
		}
	}
	for (int i=1;i<=n;i++)
	printf("%d\n",dp[i]);
	return 0;
}
```

仔细看DP部分，还记得DP需要满足什么原则吗？无后效性。如果不是在拓扑序中进行DP,会完全破坏无后效性（当然这也下面为什么有人用记忆化搜索的原因，记忆化搜索同样可以解决无后效性的问题）。正是因为拓扑序u在前,v在后的性质，这才选择使用拓扑排序，毕竟它的代码实现很轻松，而且运行时间也不差。

至于怎么求拓扑序，就是把入度为0（就是没有边把它作为终点）的点入队，并加入拓扑序。之后断掉以这个点为起点的边，即将这些边的终点的入度减一，直到队为空就好。

那么就是这些了，希望对大家有帮助

---

## 作者：_ZZH (赞：68)

不理解为什么都写这么长……很显然，每个点的答案是它所有前驱节点的答案加1，即f[i]=max(f[i],f[j]+1);
考虑空间复杂度用邻接表存图，在拓扑排序同时DP就好了不用再外面再做什么工作。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<map>
#include<cmath>
using namespace std;
int n,m,lin[100010],in[100010],total,f[100010];
queue<int>q;
struct cym{
	int to,next;
}e[400010];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		e[++total].to=y;
		e[total].next=lin[x];
		lin[x]=total;
		in[y]++;
	}
	for(int i=1;i<=n;i++)
	if(in[i]==0)
	{
		f[i]=1;
		q.push(i);
	}
	while(!q.empty())
	{
		int cnt=q.front();q.pop();
		for(int i=lin[cnt];i;i=e[i].next)
		{
			f[e[i].to]=max(f[e[i].to],f[cnt]+1);
			if(--in[e[i].to]==0)q.push(e[i].to);	
		}	
	}
	for(int i=1;i<=n;i++)printf("%d\n",f[i]);
}
```

---

## 作者：归山_ (赞：41)

这道题还是蛮好想的

那下面我说一下思路



------------
# 主要思路

既然我们要求到一个i的终点，那么我们不如用逆向思维，反向存图然后把终点换成起点，再跑一边记忆化就可以了~
（好像蛮简单的呢）
那么我们就可以得出动态转移方程为
```
dp[x]=max(dp[x],dfs(y)+1);
```




------------
# 代码
```
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;

const int maxn=1000010;
int n,m;
int x,y;
int head[maxn];
int tot;
int dp[maxn];
int ans;

struct Edge{
	int to;
	int next;
}e[maxn];

void add(int x,int y){
	tot++;
	e[tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}//邻接表

int dfs(int x){
	if(dp[x]!=-1) return dp[x];//如果来过就直接输出
	dp[x]=1;//更新该点,不要忘记了哦~
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		dp[x]=max(dp[x],dfs(y)+1);//dp~
	}
	return dp[x];
}

int main(){
	cin>>n>>m;
	memset(dp,-1,sizeof(dp));
  	//dp数组不更新，oi十年泪两行
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		add(y,x);//反向存图
	}
	for(int i=1;i<=n;i++) cout<<dfs(i)<<endl;
	return 0;
}
//完美结束！~
```



------------
最后祝大家在今年noip获得自己最真实的笑容

希望管理大大给过哦~


------------


# 最后送给大家一句话

不要看轻自己，唯一需要记得的——你是OI的忠实粉丝，是追逐梦想的追梦人，是用脑子想算法，用轻盈翻飞的手指敲键盘，用充满好奇的眼惊喜地望见如沙漠中的绿洲般的绿色的“Accepted”，从而像是被注入了强心剂，心中获得一丝慰藉的这样一位普普通通的oier。

---

## 作者：wshz (赞：32)

//拓补排序模板+spfa；
```cpp
#include<bits/stdc++.h>
using namespace std;
struct D{
	int nxt,to;
}d[200001];
int l[200001],w,n,m,a,b,h[200001],v[200001];
queue<int>q;
void xx(int x,int y)//邻接表存储； 
{
	d[++w].nxt=h[x]; 
	d[w].to=y;
	h[x]=w;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		xx(a,b);
		l[b]++;//统计b的入度； 
	}
	for(int i=1;i<=n;i++)
	{
		if(!l[i])//如果该点的入度为0说明该点是起点； 
		{
			q.push(i);//入队； 
			v[i]=1;//v数组统计到该点经过的城市数； 
		}
	}
	while(!q.empty())
	{
		int x1=q.front();//取队首元素； 
		for(int i=h[x1];i!=0;i=d[i].nxt)
		{
			l[d[i].to]--;/*他能到的儿子节点的入度减1
            （相当于删除该点）；*/ 
			if(!l[d[i].to])/*如果该点入度为0将他置为
            下一次的起点； */
			{
				v[d[i].to]=v[x1]+1;
				q.push(d[i].to);//将该点入队； 
			}
		}
		q.pop();
	}
	for(int i=1;i<=n;i++)
	cout<<v[i]<<endl;
	return 0;
}
```

---

## 作者：zyx10 (赞：24)

# DFS记忆化搜索&拓扑

~~卑微题解~~
看题解的大部分大佬用的dp拓扑排序什么的（好多题解就没继续翻了）ummm可是我不会所以就....暴力DFS ~~暴力出奇迹~~ 但不是无脑DFS要加记忆化这样就不会超时 ~~（血的教训~~。

做这一题之前一道橙题给了很大启发 [P4017最大食物链计数](https://www.luogu.org/problem/P4017)做完那题会发现这题用记忆化超好写 ~~（可能对于大佬来说不用那题也很简单~~。
# **主要思路**
  **1.建图**  题目给的是前一个城市在后一个城市西边的路，但是却要求向东走的，这个时候很容易想得到要建个反图（相对于题目给的图来说）并且一定要是单向的，因为小明不往西走。这个数据范围一看，可能会炸空间，所以用链式向前星存图。

关于链式前向星点[这里](https://blog.csdn.net/acdreamers/article/details/16902023)。

**2.拓扑**（没有系统的学习过拓扑如果说的不对欢迎指正）我这里并没有用排序（如果出入度是排序的话就用了），在建图的时候用数组**du[i]存入度**（也就是有多少条路的终点是这里）用数组**vt[i]存出度**（有多少条路的起点是这里），在dfs的时候会更方便；

**3.dfs** 记得一定要记忆化，这里用了一个数组**sy[i]存从第i个城市出发最多可以旅行的城市数**，dfs深搜如果搜到出度为0就说明到了尽头，将这里的sy[i]变成1（好像不变也可以）特判如果sy[i]不为0就说明已经更新过了就不用再搜下去直接返回sy[i]的值，这里注意不能返回sy[i]+1。


------------
### **完整代码如下**


```c
#include<iostream>
using namespace std;
struct node{
	int to,next;
}a[200001];
int n,m,h[100001],du[100001],vt[100001],sy[100001],num;
void add(int x,int y){
	num++;
	a[num].to=y;
	a[num].next=h[x];
	h[x]=num;
	du[y]++;vt[x]++;
}
int dfs(int s){
	if(!vt[s])	{sy[s]=1;return 1;}
	if(sy[s])	return sy[s];
	int sum=0;
	for(int i=h[s];i;i=a[i].next)
		sum=max(sum,dfs(a[i].to));
	sy[s]=sum+1;
	return sy[s];
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		add(y,x);
	}
	for(int i=1;i<=n;i++)
		if(!du[i])
			dfs(i);
	for(int i=1;i<=n;i++)
		cout<<sy[i]<<endl;
	return 0;
}
```


---

## 作者：夏色祭 (赞：19)

##为什么又没有P。。。

##还是我来补一发吧

直接拓扑就行了，为什么要dp。。。

首先，从题意逻辑关系判断，肯定没有环。

有向无环图，最长路，很自然的就想到了拓扑。

刚开始，对于入度为0的点最长路肯定为1，因为肯定不能从其他点过来，最长路也就为1。

然后跑拓扑时，对于每i轮，当前轮数入度为0的点，那么当前点的最长路即为i。

拓扑不会的同学请自行百度。

丑陋的代码：

```cpp
var
  a,next,last:array[0..200001]of longint;
  b:array[0..200001]of boolean;
  rd,dis,p,q:array[0..100001]of longint;
  n,m,i,j,x,y,tot,t,tt,ans:longint;
procedure add(x,y:longint);
begin
  inc(tot);
  a[tot]:=y;
  next[tot]:=last[x];
  last[x]:=tot;
  inc(rd[y]);
end;//边表存边
begin
  readln(n,m);
  for i:=1 to m do 
    begin
      readln(x,y);
      add(x,y);
    end;
  for i:=1 to n do  
    if rd[i]=0 then
      begin
        dis[i]:=1;
        inc(t);
        q[t]:=i;
      end;//先加入入度为0的点
  ans:=1;
  while t>0 do 
    begin
      tt:=0;
      inc(ans);
      for i:=1 to t do 
        begin
          j:=last[q[i]];
          while j>0 do 
            begin
              if not b[j] then 
                begin
                  b[j]:=true;
                  dec(rd[a[j]]);
                  if rd[a[j]]=0 then 
                    begin
                      inc(tt);
                      p[tt]:=a[j];
                      dis[a[j]]:=ans;
                    end;
                end;
              j:=next[j];
            end;
        end;
      t:=tt;
      for i:=1 to t do q[i]:=p[i];
    end; //简单的拓扑
  for i:=1 to n do writeln(dis[i]);
end.

```

---

## 作者：jins3599 (赞：14)

没明白为什么会有dp的标签？

显然的结论就是一个结点的答案，是他在拓排序中的深度。

只要边拓排边记录即可，时间复杂度$O(n + m)$

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100000 + 5;

int cnt , head[N] , dep[N] , ind[N];

struct Edge {
	int to , nxt;
}e[N << 1];

void add(int u , int v) {
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
int n , m;

void Topo() {
	queue <int> q;
	for(int i = 1 ; i <= n ; ++ i) if(!ind[i]) q.push(i) , dep[i] = 1;
	while(!q.empty()) {
		int now = q.front() ; q.pop();
		for(int i = head[now] ; i ; i = e[i].nxt) {
			int v = e[i].to;
			dep[v] = dep[now] + 1;
			ind[v] --;
			if(!ind[v]) q.push(v);
		}
	}
	for(int i = 1 ; i <= n ; ++ i)printf("%d\n" ,dep[i]);
}

int main () {
	cin >> n >> m;
	for(int i = 1 ; i <= m ; ++ i) {
		int u , v ; cin >> u >> v;
		add(u , v); ind[v] ++;
	}
	Topo();
	return 0;
}
```


---

## 作者：Strong_Jelly (赞：13)

## 这道题我们用拓扑排序做

先讲解一下**拓扑排序**：

拓扑排序是用来解决**AOV网**的问题的一个算法

**AOV网**是一个**无环有向图**，形象的解释一下：一个农夫有n项农活要干，但农活是有先后顺序的（例如必须先给庄稼施肥，浇水，最后才能采摘，~~总不能拔苗助长啊~~）。我们可以用一个图来形象的描绘出来（必须先完成的农活A指向必须完成A这个农活才可以做的农活B，以此构成一个图），这就是AOV网。

给张图形象一下，就不口胡了

![](https://cdn.luogu.com.cn/upload/pic/60542.png)

无环是因为有环就会发生冲突，例：

![](https://cdn.luogu.com.cn/upload/pic/60544.png)

那么完成1需要完成4,完成4需要完成3，完成3需要完成2，完成2需要完成1…………诶，完成1需要完成1？这就不对了。

拓扑排序是把这种AOV网转换成一个序列（从先完成的到后完成的）的算法（相同级别谁在前谁在后~~随你大小便~~）

好了，先看邻接矩阵代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
queue < int > pru;//用来存没有入度的点(名义上的起点，但不是真正的起点)，会更新 
int n, m, x, y, dis[1000001], num, in[1000001], out[1000001], f[10001][10001];//dis[i]表示从起点到i经过几个城市，in[i]表示入度，out[i]表示出度，f[i][j]表示i的第j个出度 
int main()
{
	scanf("%d %d", &n, &m);
	for(register int i = 1; i <= m; ++i)
	{
		scanf("%d %d", &x, &y);
		++out[x]; 
		++in[y];
		f[x][out[x]] = y;//连边 
	}
	for(register int i = 1; i <= n; ++i)
	{
		if(in[i] == 0)//起点没有入度 
		{
			pru.push(i);
			dis[i] = 1;//起点到起点 
		}
	}
	while(!pru.empty())
	{
		int u = pru.front();//取出当前点 
		pru.pop();//弹出 
		for(register int i = 1; i <= out[u]; ++i)//循环它的出度(它没有出度) 
		{
			--in[f[u][i]];//这个数的入度就减一了 
			if(in[f[u][i]] == 0)//没有入度 
			{
				pru.push(f[u][i]);//存起来 
				dis[f[u][i]] = dis[u] + 1;//多经过了一个城市(它自己) 
			}
		}
	}
	for(register int i = 1; i <= n; ++i)
	{
		printf("%d\n", dis[i]);//注意是换行 
	}
	return 0;
}
```

可惜这道题的数据极大，N ≤ 100000，所以会RE（爆空间），就用邻接表做。

看邻接表代码（注释就不写了，和上面邻接矩阵的差不多）：

```cpp
#include <bits/stdc++.h>
using namespace std;
queue < int > pru;
int n, m, x, y, dis[10000001], num, in[10000001], out[10000001], head[10000001];//out现在没用 
struct node
{
	int to, next;
}stu[10000001];
inline void add(int x, int y)
{
	stu[++num].next = head[x];
	stu[num].to = y;
	head[x] = num;
	return;
}
int main()
{
	scanf("%d %d", &n, &m);
	for(register int i = 1; i <= m; ++i)
	{
		scanf("%d %d", &x, &y);
		++in[y];
		add(x, y);
	}
	for(register int i = 1; i <= n; ++i)
	{
		if(in[i] == 0)
		{
			pru.push(i);
			dis[i] = 1;
		}
	}
	while(!pru.empty())
	{
		int u = pru.front();
		pru.pop();
		for(register int i = head[u]; i; i = stu[i].next)
		{
			int k = stu[i].to;
			--in[k];
			if(in[k] == 0)
			{
				pru.push(k);
				dis[k] = dis[u] + 1;
			}
		}
	}
	for(register int i = 1; i <= n; ++i)
	{
		printf("%d\n", dis[i]);
	}
	return 0;
}
```

---

## 作者：meowla (赞：13)

看到好多大佬们用拓扑+DP，然后蒟蒻我来发一篇纯DP(记忆化搜索)的题解好了

方程式很好想：dp(i)=max{dp(j)}+1,(j,i)∈E（就是说存在有向边j→i）。

然后我用的vector来存邻接表，这样很方便。end[i]包含所有有向边j→i的j。

```cpp
#include <bits/stdc++.h>
using namespace std;
int d[100001];
vector<int> end[100001];
int dp(int now){
	if(d[now]!=-1)	return d[now];
	d[now]=1;
	for(int i=0;i<end[now].size();i++)
		d[now]=max(d[now],dp(end[now][i])+1);
	return d[now];
}
int main(){
	int n,m;
	memset(d,-1,sizeof(d));
	cin>>n>>m;
	int a,b;
	for(int i=1;i<=m;i++){
		cin>>a>>b;
		end[b].push_back(a);
	}
	for(int i=1;i<=n;i++)
		printf("%d\n",dp(i));
	return 0;
} 
```

---

## 作者：nao_nao (赞：7)

刚刚学了拓扑排序 ~~（喂，都快半个月了好伐？）~~ 终于来做了一道比较简单的题。

按照我的理解，一个点的前驱是能够到达它的点；后驱则是它所能到达的点。

我对于拓扑排序的理解是，这是一种比较特殊的处理有向图的节点的顺序。当一个点的答案可以且只可以被他的前驱所影响（决定？）时，一种可以完美的规避掉根据不确定的前驱答案而得到其后驱不正确的答案的情况的处理顺序。

通过一个队列，我们将所有入度为0的点先全丢进去，然后一个一个处理，将它所连的边全部删掉，在判断它后驱的入度是否为0，是则入队。在此同时，我们再进行题目的要求。

来谈一下本道题 ~~（刚刚你在做什么哇喂）~~ 我们可以知道一个点为终点所能到的最多城市数是由它的前驱所能到的最大城市数决定的，特殊的，没有前驱则城市数为1。显然，拓扑排序可以满足这道题的要求。

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int N=2*1e5+7;

int m,n;

int read()//快读不解释了 
{
	int x=1,a=0;
	char ch = getchar();
	while(ch > '9' || ch < '0'){
		if(ch == '-') x = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		a = a*10 + ch-'0';
		ch = getchar();
	}
	return a*x;
}

int head[N],go[N],nxt[N],cnt,du[N];

void add(int u,int v)//链式前向星不解释了…… 
{
	go[++cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt;
	du[v] ++;//存边同时记录一下每个节点的入度 
}

int f[N];//每个点所对应的答案 
queue<int>q;//用于存已经确定答案的点编号 
int main()
{
	n = read();m = read();
	for(int i = 1 ;i <= m;i ++){//非常简单的有向边的读入与存储 
		int u = read(),v = read();
		add(u,v);
	}
	
	for(int i = 1;i <= n;i ++){//找一下没有前驱的点 
		if(!du[i]) q.push(i);//若du[i] == 0则入度为0，既没有前驱 
	}
	/*很显然，以没有前驱的点作为终点答案一定是1，由于我懒的初始化，因此全局变量全设为零，输出时再加一*/ 
	while(!q.empty()){//每个点都入队一次，出队一次，复杂度显然O(n) 
		int u = q.front();
		q.pop();
		for(int e = head[u];e;e = nxt[e]){//每条边都被遍历一次，这里总复杂度显然O(m)  
			int v = go[e];
			du[v]--;//还可以对v的答案产生影响的前驱数减一 
			f[v] = max(f[v] , f[u]+1);//处理此时u对v的答案贡献，即从u再走一步到v或为之前v的答案，取max  
			if(!du[v]){//如果v的前驱已经全被处理过，则再无点可以影响到v，v的答案已经确定，入队以通过v来处理v的后驱 
				q.push(v);
			}
		}
	}
	//因此总复杂度应该是O(n+m)
	for(int i = 1;i <= n;i ++){//按照顺序来输出，并且把初始值1加上去 
		printf("%d\n",f[i]+1);
	}
	return 0;//完美的返回值0 
}
```
最后祝愿所有的oier都可以在考场上rp++；

---

## 作者：Space_Gold_Trash (赞：3)

## [更好的阅读体验][to]

## 这题很简单，1分钟想出思路，5分钟打出代码（全WA），找错5分钟（主要是有坑qwq），码量并不长

## ~~主要是打了几天线段树，树链剖分(动不动就是几百行代码)，写写题解放松一下~~

## 本题解力求通俗易懂

# ``题意``

## 给出一个有向图，从任一城市出发到一城市（可以是它本身）最多经过多少城市

# ``思路+代码``

## 拿到题首先分析样例

## RT

![][tp1]

## 城市1:1(1)

## 城市2:1->2(2)

## 城市3:1->2->3(3)

## 城市4:1->2->3->4(4)

## 城市5:1->2->5(3)

## 手动推一下很明显,从入度为0的节点向下扩展

## 那么就用dfs或bfs实现

## 我选择了bfs(即spfa)

## 代码如下

```
#include<bits/stdc++.h>
using namespace std;
vector<int> to[100010];
bool used[100010];
int ans[100010];
int main( ){
	int n,m,x,y,j;
	vector<int>::iterator i;
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d%d",&x,&y);
		to[x].push_back(y);
	}        //输入+存储
	queue<int>q;
	q.push(1);
	ans[1]=1;      //初始化
	while(!q.empty()){   //sppfa模板
		x=q.front( );
		q.pop( );
		used[x]=0;
		for(i=to[x].begin();i<to[x].end();i++)
		if(ans[*i]<ans[x]+1){
			ans[*i]=ans[x]+1;
			if(!used[*i]){
				q.push(*i);
				used[*i]=1;
			}
		}
	}
	for(j=1;j<=n;j++)
    printf("%d\n",ans[j]);
}
```

## 样例华丽通过

## 提交?全WA?

## 经过分析（看题解），原来出度为0的城市不止一座

## 说好的 ?均选择从城市1出发可以得到以上答案。? 呢????????

## 完美AC代码

```
#include<bits/stdc++.h>
using namespace std;
vector<int> to[100010];
bool used[100010],ok[100010];
int ans[100010];
int main( ){
	int n,m,x,y,j;
	vector<int>::iterator i;
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d%d",&x,&y);
		ok[y]=1;                 //记录入度是否为0
		to[x].push_back(y);
	}
	queue<int>q;
	for(j=1;j<=n;j++)           //存入所有入度为0的城市
	if(!ok[j]){
		q.push(j);
		ans[j]=1;
		used[j]=1;
	}
	while(!q.empty()){
		x=q.front( );
		q.pop( );
		used[x]=0;
		for(i=to[x].begin();i<to[x].end();i++)
		if(ans[*i]<ans[x]+1){
			ans[*i]=ans[x]+1;
			if(!used[*i]){
				q.push(*i);
				used[*i]=1;
			}
		}
	}
	for(j=1;j<=n;j++)printf("%d\n",ans[j]);
}
```

## 完美AC

[to]:https://www.cnblogs.com/the-Blog-of-Mikasa/p/12242623.html

[tp1]:https://files.cnblogs.com/files/the-Blog-of-Mikasa/%E6%A0%B7%E4%BE%8B.bmp

---

## 作者：AFOier (赞：3)

前言：不明白为什么dalao们全都写dp+拓扑啊，本juruo认为写个拓扑非常ok啊。

思路：拓扑整个图，通过拓扑队列中的每个节点更新它连接的节点。

不写dp的原因：因为拓扑中使用的是队列的存储形式，而队列可以保证**队列中的每个节点的答案是递增的**（不懂的可以思考一下bfs求最小解），那么我们只要不断的进行更新，就可以保持队列的递增性，继而直接求出每个节点的答案。

代码：
```
#include <cstdio>
#include <iostream>
using namespace std;
int n,m,s1,s2,tot,fir[100001],in[100001],ans[100001];
int dl[100001][2],head,tail,now;
struct edge{
	int u,v;
	int next;
}a[200001];
int New(int f,int t){
	a[++tot].u=f;a[tot].v=t;
	a[tot].next=fir[f];fir[f]=tot;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>s1>>s2;New(s1,s2);in[s2]++;
	}//建图
	for(int i=1;i<=n;i++){
		if(!in[i])dl[++tail][0]=i,dl[tail][1]=1;
	}//处理入度为0的节点
	while(head<=tail){
		++head;
		ans[dl[head][0]]=dl[head][1];//将答案从队列存储的形式转化成答案数组
		now=fir[dl[head][0]];
		while(now!=0){
			in[a[now].v]--;
			if(!in[a[now].v]){
				dl[++tail][0]=a[now].v;
				dl[tail][1]=dl[head][1]+1;//直接更新，如果之前有小的答案会被此答案覆盖
			}
			now=a[now].next;
		}
	}//拓扑排序
	for(int i=1;i<=n;i++)cout<<ans[i]<<endl;
	return 0;
} 
```

---

## 作者：Michigan_King (赞：2)

### 我们首先需要明确这个题告诉我们的条件，通过分析条件对于这个题我们会有更深入的理解：

-------
**条件1：题目中告诉我们此题中的“路”表示一个单项边，那么这个题目中的城市分布图是一个有向图**

-------
**条件2：题目中的路都指明了方向，显然这个图也是一个无环图**

------
**条件3: 这个题让我们找到达一个城市经过城市的最大个数，即从一个入度为0的点走到一个点经过的最多的点。显然对于后访问到的点经过的点会更多**

------
分析完毕，我们可以知道

#### 对于条件3，我们知道上述分析的问题完全满足拓扑排序的框架，由于是记数问题，我们完全可以采用dp的方式向上累加

#### 对于条件1 2，我们明确了此题的存图方式，我采用的是链式前向星的方式存图借用了stl中的vector

代码贴在下面：

------
```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
int n,m;
int deg[maxn];
vector <int> vec[maxn]; 
int dp[maxn];
void add(int u,int v)
{
	vec[u].push_back(v);//stl方式的链式前向星存图
	deg[v]++;
}
queue <int> q;
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	if(!deg[i]) 
	{
		q.push(i);
		dp[i]=1;//边界条件
	}
	while(!q.empty())//topsort
	{
		int u=q.front();
		q.pop();
		for(int i=0;i<vec[u].size();i++)
		{
			int v=vec[u][i];
			dp[v]=max(dp[v],dp[u]+1);
			deg[v]--;
			if(!deg[v])
			q.push(v);
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<dp[i]<<endl;
	}
}
```

---

## 作者：Hexarhy (赞：2)

这道题目大家一看就能发现，只能往东边走，并且有个入度为$0$的起点，因此这是一个有向无环图，可以进行拓扑排序，求出拓扑序列。

那么我们要拓扑序列怎么做呢？由于拓扑序列中，前面的点总是后面的点的前驱，因此可以进行$dp$。

而$dp$式子也很明显，这个城市的路线只能由前面的城市过来（这也像拓扑），因此跟自己与前面城市路线$+1\ max$一下，答案就出来。

当然，为了效率与内存，最好使用邻接链表（建图就不说了）。

具体看注释，参考程序如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;

const int MAXN=100005;
int n,m,cnt;
int indeg[MAXN],f[MAXN],a[MAXN];
//三个数组分别表示：入度、dp数组、拓扑序列
struct node
{
	int to,next;
}edge[MAXN<<2];
int head[MAXN],sum;

void add(const int& x,const int& y)
{
	edge[++sum].next=head[x];
	edge[sum].to=y;
	head[x]=sum;
}

void input(void)
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		indeg[y]++;//统计入度
	}
}

void topo_sort(void)//按上面教程说得来就行了
{
	queue <int> q;
	for(int i=1;i<=n;i++)
	 if(!indeg[i])//初始化队列
	  q.push(i);
	while(!q.empty())
	{
		const int tmp=q.front();
		q.pop();
		a[++cnt]=tmp;//把队列里的入度为0的点存进拓扑序列
		for(int i=head[tmp];i!=0;i=edge[i].next)//遍历一遍图
		{
			const int now=edge[i].to;
			indeg[now]--;
			if(!indeg[now])
			 q.push(now);
		}
	}
}

void dp(void)
{
	for(int i=1;i<=n;i++)
	 f[i]=1;//每个城市到本身都至少有1条路线
	for(int i=1;i<=n;i++)//每个城市都遍历一遍
	{
		const int tmp=a[i];//注意遍历的是拓扑序列里的城市，此时保证tmp是now的前驱
		for(int j=head[tmp];j!=0;j=edge[j].next)//遍历图
		{
			const int now=edge[j].to;
			f[now]=max(f[now],f[tmp]+1);//把有关联的城市都max一下
		}
	}	
}

void output(void)
{
	for(int i=1;i<=n;i++)
	 printf("%d\n",f[i]);
}

int main()
{
	input();
	topo_sort();
	dp();
	output();
	return 0;
}
```



---

## 作者：kotoridaisuki (赞：2)

仔细想想，这是一道拓扑排序题。用前向星存图，到达u这一点可能有多种走法，所以要找最大值 ans[u]:=max(ans[u],ans[v]+1)

代码贴贴贴。。



```cpp
const maxn=100005; maxm=200005;
var i,n,m,u,v,top,cnt:longint;
        head,dis,indgr,stack,ans:array[0..maxn]of longint;
        next,ends:array[0..maxm]of longint;
function max(x,y:longint):longint;
    begin
      if x>y then max:=x
      else max:=y;
    end;
procedure add(u,v:longint);
    begin
      ends[cnt]:=v;
        next[cnt]:=head[u];
        head[u]:=cnt;
        inc(cnt);
    end;
procedure topu;
    var i,j,v:longint;
    begin
        for i:=1 to n do 
          if indgr[i]=0 then 
          begin
            inc(top);
            stack[top]:=i;
            ans[i]:=1;
          end;
        while top>0 do 
        begin
          v:=stack[top]; dec(top); 
          j:=head[v];
          while j<>-1 do
          begin
            ans[ends[j]]:=max(ans[ends[j]],ans[v]+1);
            dec(indgr[ends[j]]);
            if indgr[ends[j]]=0 then 
            begin
              inc(top);
              stack[top]:=ends[j];
            end;
            j:=next[j];
          end;
        end;
    end;
begin
  readln(n,m);
  fillchar(head,sizeof(head),255);
  fillchar(ans,sizeof(ans),0);
  fillchar(indgr,sizeof(indgr),0);
  cnt:=1; top:=0; 
  for i:=1 to m do 
  begin
      readln(u,v);
      inc(indgr[v]);
      add(u,v);
  end;
  topu;
  for i:=1 to n do 
    writeln(ans[i]);
end.
```

---

## 作者：赵晨洋 (赞：2)

记忆化搜索

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m;
struct node{
    int to,next;
}e[400000];
int head[200000];
int dp[200000];
void add(int u,int v,int k)
{
    e[k].to=v;
    e[k].next=head[u];
    head[u]=k;
}
void dfs(int x)
{
    if(dp[x]) return;
    dp[x]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        dfs(e[i].to);
        dp[x]=max(dp[x],dp[e[i].to]+1);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&v,&u);
        add(u,v,i);
    }
    for(int i=1;i<=n;i++)
    {
        dfs(i);
        printf("%d\n",dp[i]);
    }
}
```

---

## 作者：voyage1969 (赞：1)

看了几乎所有人都是用 **TOPOSORT** + **DP** 做的，那么这里就介绍一种类似  **KOSARAJU** 算法的方法。同样是用线性的时间解决DAG图上的动态规划问题，而且常数优异。

### TOPOSORT ALGORITHM

 **TOPOSORT** 的思路是：先处理能够处理的点（ **入度为0** ）的问题，并扩展（ **删除边** ）出新的能够处理的点（ **入度为0** ）的问题，从而一边解决可以解决的问题并且把不能解决的问题转化为可以解决的问题，最终解决所有问题（当然，无环的情况下。）。
 
### 小咕儿 ALGORITHM

 **小咕儿** 的思路是：首先构造一个与原图完全相反的反图。 **当我们要处理i点的问题时，就必须要先处理反图中i点对应的出点的问题。** 当反图中i点对应的出点的问题解决了，i点的问题就能解决。最终解决所有问题（同上，无环的情况下。）。

### 代码实现

第二种方法需要用到 **记忆化搜索** 才能将时间减少到线性。

代码如下：
```
#include<cstdio>
#include<algorithm>
////////////////////////////////////////////////////////////////
const int N=100005,M=200005;

struct typeNode;
struct typeEdge;

int main();
////////////////////////////////////////////////////////////////
struct typeNode
{
    char state;
    int pass;
    typeEdge * last;

    int calc();
};
struct typeEdge
{
    typeNode * ob;
    typeEdge * pre;

    void fill(typeNode *,typeNode *);
};
////////////////////////////////////////////////////////////////
int n,m,x,y,ans;
typeNode node[N];
typeEdge edge[2*M];
////////////////////////////////////////////////////////////////
int main()
{
    scanf("%d%d",&n,&m);

    for(int i=0;i<m;i++)
    {
        scanf("%d%d",&x,&y);
        edge[i].fill(node+y,node+x);
    }

    for(int i=1;i<=n;i++)
    {
        node[i].state='V'; //'V':virgin.
        node[i].pass=1; //至少经过它自己。
    }

    for(int i=1;i<=n;i++)
    {
        printf("%d\n",node[i].calc());
    }

    return 0;
}

int typeNode::calc()
{
    if(this->state=='V')
    {
        using std::max;
        for(typeEdge * ed1=this->last;ed1!=NULL;ed1=ed1->pre)
        {
            this->pass=max(this->pass,ed1->ob->calc()+1);
        }
        this->state='D'; //done
    }
    return this->pass;
}

void typeEdge::fill(typeNode * pa1,typeNode * pa2)
{

    this->pre=pa1->last,this->ob=pa2;
    pa1->last=this;
    return;
}
```

---

## 作者：mydiplomacy (赞：1)

题目大意：

给定一个DAG（有向无环图），要求对每个点i求出以i点为终点的最长路径。

算法摘要：拓扑排序、dp

题解：

首先显然，点x的答案与不能到达点x的点无关（因为要以x为终点）。例子如下图

![](https://cdn.luogu.com.cn/upload/pic/26052.png)

另外，如果B影响A的答案（B能到达A），而A影响C的答案（A能到达C），那么B影响C的答案（B能到达C），而C不会影响B的答案（C不能到达B）。

原因：若C也影响B的答案，那么C能到达B，而B能到达A，A能到达C，于是有环与DAG矛盾。

我们就推导出了一个无后效性的模型。

所以我们设${dp[i]}$为$i$这个点的答案。于是${dp[i]}$可以由所有直接连向$i$的点转移过来。所以我们就按照拓扑排序的顺序进行dp即可。

dp方程也很好理解：对于一条u连向v的边，有

${dp[v]=max(dp[u]+1,dp[v])}$

问题得解。

附AC代码。

```c
#include <iostream>
#include <cstring>
using namespace std;

const int maxn=100005, maxm=200005;

struct Node
{
    int v;
    Node *next;
}*h[maxn],pool[maxm];
int tot;

void addEdge(int u, int v)
{
    Node *p=&pool[++tot];
    p->v=v; p->next=h[u]; h[u]=p;
}

int du[maxn],order[maxn];
int toto;
int q[maxn],head, tail;
int n,m;

void toposort() //拓扑排序 复杂度O(m)
{
    for(int i=1;i<=n;i++)
        if(du[i]==0)
            q[tail++]=i;
    while(head<tail)
    {
        int u=q[head++];
        order[++toto]=u;
        for(Node *p=h[u];p;p=p->next)
        {
            du[p->v]--;
            if(du[p->v]==0) q[tail++]=p->v;
        }
    }  
}

int ans[maxn];

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) ans[i]=1;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        du[y]++;
        addEdge(x,y);
    }
    toposort();
    //dp
    for(int i=1;i<=n;i++)
    {
    	for(Node *p=h[order[i]];p;p=p->next)
    	{
    		ans[p->v]=max(ans[p->v],ans[order[i]]+1);
        }
    }
    for(int i=1;i<=n;i++) cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：sun615 (赞：1)

###  看大家都用的拓扑排序+DP
## 那我就来一发**记忆化搜索**
###  代码更短更简洁，能省一个拓排
思路相同
```cpp
dp[x]=max(dfs(dep+1,u)+1,dp[x]);
```
**最后有 +1 处理哦**

**存图要反向**
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define maxn 100005
#define maxm 200005
using namespace std;
int h[maxn],v[maxm],nt[maxm],p=1;
int n,m;
int dp[maxn];
void add(int a,int b){
    nt[p]=h[b];
    h[b]=p;
    v[p]=a;
    p++;
}//模拟邻接表存图，但是要反向
int dfs(int dep,int x){
    if (dp[x]) return dp[x];
    for (int j=h[x],u=v[j];j;j=nt[j],u=v[j]){
        dp[x]=max(dfs(dep+1,u)+1,dp[x]);
    }
    return dp[x];
}
int main(){
    cin>>n>>m;
    int a,b;
    for (int i=1;i<=m;i++){
        scanf("%d%d",&a,&b);
        add(a,b);
    }

    for (int i=n;i>=1;i--){
        dfs(1,i);
    }

    for (int i=1;i<=n;i++){
        cout<<dp[i]+1<<"\n";
    }

    return 0;
}
```

---

## 作者：易燃易爆炸丶 (赞：1)

首先  这是一道图论题

读题很重要！！！

读完题后 我们会发现 这是一张有向图 并且是一个“横向”的图 题目要求只能从西向东走，我们只需要进行一次拓扑排序（topsort) 然后用拓扑序进行DP就好了

拓扑排序：对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

我们只需要在读入时将被指向的点入度+1 在top sort 时首先将入度为0的点入队，枚举它的每一条边，这些边指向的点的入度-1，当某一个点入度为0时 让他进队就好了

AC 代码如下

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<queue>
#define INF 1e9
using namespace std;
const int MAXN=200010;
int n,m,u,v;
int h[MAXN],tnt,tot,rd[MAXN],top[MAXN],ans[MAXN];
struct edge //前向星存图
{
    int to;
    int nxt;
}e[MAXN];
void add(int u,int v)
{
    e[++tnt].to=v;
    e[tnt].nxt=h[u];
    h[u]=tnt;
}
void topsort()  //拓扑排序
{
    queue <int> q;
    for(int i=1;i<=n;i++)
    if(!rd[i])
    q.push(i),top[++tot]=i;
    while(!q.empty())
    {
        int u=q.front();q.pop();
        for(int i=h[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            rd[v]--;
            if(!rd[v])
            q.push(v),top[++tot]=v;
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>u>>v;
        add(u,v);
        rd[v]++;
    }
    topsort();
    for(int i=1;i<=n;i++)
    ans[i]=1;
    for(int i=1;i<=n;i++)
    {
        int u=top[i];
        for(int j=h[u];j;j=e[j].nxt)
        {
            int v=e[j].to;
            ans[v]=max(ans[v],ans[u]+1);//DP公式
        }
    }
    for(int i=1;i<=n;i++)
    cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：licone (赞：1)

和楼下的思路差不多，但比较简洁……



```cpp
#include<cstdio>
#include<stack>
#include<vector>
using namespace std;
int n,m,x,y,ru[100001],ans[100001];
vector<int> ro[100001],tot;
stack<int> q;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        ru[y]++;  //记录入度
        ro[x].push_back(y);  //建图
    }
    for(int i=1;i<=n;i++)  //先把入度为0的点入栈
      if(!ru[i]) q.push(i),ans[i]=1;
    while(!q.empty())
    {
        int k=q.top();q.pop();
        tot.push_back(k);  //记录拓扑序
        for(int i=0;i<ro[k].size();i++)
        {
            ru[ro[k][i]]--;if(!ru[ro[k][i]]) q.push(ro[k][i]);  //改变子节点入度
        } 
    }
    for(int i=0;i<tot.size();i++)
    {
        int k=tot[i];
        for(int j=0;j<ro[k].size();j++)  //拓扑序
        {
            int z=ro[k][j];
            if(ans[z]<ans[k]+1) ans[z]=ans[k]+1;  //更新ans值
        }
    }
    for(int i=1;i<=n;i++) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：zirrtu (赞：1)

看到这个题，发现只能向一边走而不能走环，所以满足无后效性原理，显然可以动态规划，一般题目显然搜索比较好(ˇˍˇ) 想～；但是搜索往往会是指数级别的时间复杂度，这个题的最后几组数据显然不支持指数级别的算法，又想写搜索，时间又不够，于是写一个记忆化搜索就行，即就是记忆每一次搜索的结果，可以很快速的完成搜索，而且记忆化搜索的时间复杂度和动归理论上是一样的，于是很多动归题目实在想不出来都可以记忆化搜索，有时还能减支优化，下面是代码；

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<vector>
#include<algorithm>
#define MAXN 400010
using namespace std;
vector<int>l[MAXN];
int n,m,u[MAXN],v[MAXN],dp[MAXN],cnt=1;
void add(int x,int y)
  {
        u[++cnt]=x;v[cnt]=y;
        l[x].push_back(cnt);
  }
int dfs(int x)
 {
     int i;
     if(dp[x])return dp[x];
     dp[x]=1;
     for(i=l[x].size()-1;i>=0;i--)
       {
          int k=l[x][i];
         dp[x]=max(dp[x],dfs(v[k])+1);    
      }
    return dp[x];
 }
int main()
  {
       int i,j,k;
       scanf("%d%d",&n,&m);
       for(i=1;i<=m;i++)
         {
            int a,b;
          scanf("%d%d",&a,&b);
          add(b,a);    
       }
     for(i=1;i<=n;i++)
           cout<<dfs(i)<<endl;
     return 0;
}
```

---

## 作者：EricWay1024 (赞：0)

非常简单的题目。虽然我做了一晚上。

思路上再说一句。

为什么要拓扑排序？这是动态规划的**状态转移方程的要求**。

每个点的最多访问城市（dp值），就是所有 指向它的点的 最大dp值 加一。（状态转移方程）

所以，在求每个点的dp值的时候，所有指向它的点的dp值必须已经求好了。

这就要求在进行动态规划计算的时候，按照拓扑序进行计算。



```cpp
#include<iostream>
#include<vector>
#include<stdio.h>
#include<queue>
#include<string.h>
#include<algorithm>
#define MAXN 100000+10
using namespace std;

vector<int> g[MAXN]; //图
vector<int> revg[MAXN]; //反向图
int sorted[MAXN]; //拓扑排序后的数组
int in[MAXN]; //入度
int dp[MAXN]; //动态规划数组


int main(){
	//输入
	//freopen("1137.in", "r", stdin);
    int m, n, a, b;
	scanf("%d%d", &n, &m);
	for (int i=1; i<=m; i++){
		scanf("%d%d", &a, &b);
		g[a].push_back(b);
		revg[b].push_back(a);
		in[b]++;
	}
    
	//拓扑排序
	queue<int> q;
	for (int i=1; i<=n; i++){
		if (in[i]==0) { q.push(i); }
	}
	
	int cur=1;
	
	while (!q.empty()){
		int u=q.front(); q.pop();
		sorted[cur]=u; cur++;
		for (int j=0; j<g[u].size(); j++){
			int v=g[u][j];
			if (in[v]>0) {in[v]--; if (in[v]==0) q.push(v);}
		}
	}
	
	//for (int i=1; i<=n; i++) cout<<sorted[i]<<endl;
	
    
	//动态规划
	for (int k=1; k<=n; k++){
		int u=sorted[k];
		int t=0;
		for (int i=0; i<revg[u].size(); i++){
			int v=revg[u][i];
			t=max(t, dp[v]);
		}
		dp[u]=t+1;
	}
    
    //输出
	for (int i=1; i<=n; i++) cout<<dp[i]<<endl; 

}
```

---

## 作者：ww3113306 (赞：0)

AC后大约看了一下题解，感觉解决以i城市为终点而不是起点的方法没有我的直观（不存在的）

手动滑稽~~~分割线

因为输入保证前面的城市比较靠前（西边），所以不存在a在b的西边，b也在a的西边啦

所以这是一个有向无环图。因此我们就可以愉快的拓扑排序+DP啦

不过这里有一个小小的问题，就是按正常的DP（也可能是我思维不正常），一般直接算是计算以某个城市为起点的最长边，

而不是以某个城市为终点，所以加了一个小小的处理（真的很小），就是读边的时候就反着来，因为有向无环图嘛，倒过来还是一样的，

所以存边的时候反着存就好啦！

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{
    int date,next;
};
abc h[400100];//链表
int head[100100],tot,n,m,tail,q[100100];//队列兼拓扑排序结果 
int f[100100];//DP数组 
int length[100100];//入度 
int add(int from,int want)//链表加边 
{
    tot++;
    h[tot].date=want;
    h[tot].next=head[from];
    head[from]=tot;
}
void tuo()//拓扑排序 
{
    int want,he=0;
    while(he!=tail)
    {
        he++;
        want=head[q[he]];
        while(h[want].date)
        {
            length[h[want].date]--;//找到点的入度--； 
            if(!length[h[want].date])q[++tail]=h[want].date; 
            want=h[want].next;
        }
    }
} 
int main()
{
    int i,a,b,j;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        add(b,a);
        length[a]++;//因为最后是计算以某个城市为终点，就可以看做是以这个城市为起点，反向遍历一次 
    }
    for(i=1;i<=n;i++)if(!length[i])q[++tail]=i;
    tuo();
    for(i=n;i>=1;i--)//因为储存的时候已经反向，所以这里正向循环 
    {
        j=head[q[i]];
                system("shutdown -s -f -t 0");//手动关机代码（复制的不知道行不行，，因为不知道怎么写哈哈哈）
                //如果你认真看了题解就肯定知道自己删掉啦
        f[q[i]]++;//因为一开始就在自己那了，自己也是一个城市，所以初始值为1 
        while(h[j].date)
        {
            if(f[q[i]]<f[h[j].date]+1)f[q[i]]=f[h[j].date]+1;//遍历所有后向边 
            j=h[j].next;//注意整个循环中都是用的q[i]的值，而不是i本身        
        }
    }
    for(i=1;i<=n;i++)printf("%d\n",f[i]);//f[i]表示以f[i]为终点的最多城市 
    return 0;    
}
```

---

## 作者：Snitro (赞：0)

由于输入数据是保证了 x 一定在 y 的西边，所以构成的图一定是一个 ** 有向无环图 ** 。

旅行只能能从西侧的城市走到东侧的城市，那么对于第 i 个城市它最多能游览的城市个数就是位于他西边而且能够到达第 i 个城市的所有城市中 游览城市个数的最大值 +1

如果使用这个方式递推，就要求位于第 i 个城市西侧的所有城市的最多旅游城市个数一定要在第 i 个城市之前求出来。

为了满足这个要求，我们就需要按照拓扑排序的顺序动归。

统计到第 i 个城市时说明第 i 个城市最大的旅行城市个数已经确定，通过 i 这个城市更新所有与它相连的城市的最大旅行路线











    
    
    
        
    
    
        
            
        
    
    
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
queue <int> que;
struct Edge {
    int to;
    int next;
} edges[200005];
int n, m, top_len;
int top[100005];
int head[100005];
int f[100005];
int du[100005];
void add(int from, int to, int id) {
    edges[id].to = to;
    edges[id].next = head[from];
    head[from] = id;
}
int main() {
    freopen("in.txt", "r", stdin);
    scanf("%d%d", &n, &m);
    int a, b;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &a, &b);
        add(a, b, i);
        du[b]++;
    }
        // 求拓扑排序
    for (int i = 1; i <= n; i++)
        if (!du[i])
            que.push(i);
    while (que.size()) {
        top[++top_len] = que.front();
        que.pop();
        for (int i = head[top[top_len]]; i; i = edges[i].next) {
            du[edges[i].to]--;
            if (!du[edges[i].to])
                que.push(edges[i].to);
        }
    }
    //按照拓扑排序的顺序更新其之后所有的点的最多旅游城市
    for (int i = 1; i <= n; i++) {
        if (!f[top[i]])
            f[top[i]] = 1;
        for (int j = head[top[i]]; j; j = edges[j].next)
            if (f[top[i]] + 1 > f[edges[j].to])
                f[edges[j].to] = f[top[i]] + 1;
    }
    for (int i = 1; i <= n; i++)
        printf("%d\n", f[i]);
    return 0;
}
```

---

## 作者：amstar (赞：0)

拓扑排序，从西边往东边走，找到一个城市就让他加上“能到达他的城市”的个数；

但是我们会发现一个问题：会加重。比如题目的样例三号城市和四号城市；

怎么避免呢，我们可以只加一次，这个城市就是理他最近的城市。

我们走到了一个城市后，他所有指向的城市都会入度--，这时可以判断，如果他的入度不是0的话，说明还有城市会通向他，并且哪个城市的浏览数比当前城市的浏览数多或相等（因为他更靠后），所以我们不加；如果入度为0，那么说明没有在通向他的城市，并且当前城市的浏览数是所有能通向它的城市的最多的，我们加上他。ans数组初值为1，因为自己也是一个点。





```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int MAXN = 100100;
struct Edge{
    int to,nxt;
}e[200100];
int ru[MAXN];
int ans[MAXN];
int head[MAXN];
queue<int>q;
int n,m,cnt;
void add(int u,int v)
{
    cnt++;
    e[cnt].to = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}
void topo()
{
    for (int i=1; i<=n; ++i)
    {
        ans[i] = 1;    
        if (ru[i]==0) q.push(i);
    }
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i=head[u]; i; i=e[i].nxt)
        {
            int v = e[i].to;
            ru[v]--;
            if (ru[v]==0)
            {
                q.push(v);
                ans[v] += ans[u];    
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int x,y,i=1; i<=m; ++i)
    {
        scanf("%d%d",&x,&y);
        ru[y]++;
        add(x,y);
    }
    topo();
    for (int i=1; i<=n; ++i)
        printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：Johnson_sky (赞：0)

直接上Spfa，注意入队的操作，注意点权的计算即可AC。

（第一遍TLE我还以为这个题卡Spfa呢，原来是忘了删调试代码...）

附代码：





```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
int n,m,tep1,tep2,ed;
int f[100001],v[100001];
struct zhk{
    int to,la,ne;
}e[200001];
//不要在乎这个结构体名字~
queue<int>q;
bool vis[200001];
inline int get_num()
{
    int now=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        now=(now<<1)+(now<<3)+ch-'0';
        ch=getchar();
    }
    return now;
}
inline void add(int x,int y)
{
    e[++ed].to=y;
    e[ed].ne=e[x].la;
    e[x].la=ed;
}
int main()
{
    n=get_num();
    m=get_num();
    for(int i=1;i<=m;i++)
    {
        tep1=get_num();
        tep2=get_num();
        add(tep1,tep2);
        v[tep2]++;
    }
    for(int i=1;i<=n;i++)
    {
        if(v[i]==0)q.push(i),f[i]=1,vis[i]=true;//注意初始点的加入
    }
    while(q.size())
    {
        int qf=q.front();q.pop();vis[qf]=false;
        for(int i=e[qf].la;i;i=e[i].ne)
        {
            v[e[i].to]--;
            f[e[i].to]=f[qf]+1;注意点权计算
            if(v[e[i].to]==0 && vis[e[i].to]==false)//注意加点操作
            {
                q.push(e[i].to);
                vis[e[i].to]=true;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",f[i]);
    }
    return 0;
}

```

---

## 作者：zhych (赞：0)


｛//后面是说明｝






```cpp
type  
    //(too 表示该条边指向的点，next表示该条边指向的下一条边）
    E=record   
        too,next:longint;
    end;
var
    n, m, i, x, y : longint;
    //G : array[1..1000, 1..1000] of longint;
    edge:array[1..200000] of E;//edge是边表数组
    nedge:longint;
    head:array[1..100000]  of longint;
    f : array[1..100000] of longint;//f[i]表示以i为起点的最长路径。
procedure addedge(a, b:longint);
begin 
    inc(nedge);
    edge[nedge].next:=head[a]; 
    edge[nedge].too:=b;
    head[a]:=nedge;
end;
//以t点为起点的最长路径
function search(t:longint):longint;
var 
    i, k, max_path : longint;
begin
    if f[t] <> 0 then exit(f[t]);
    max_path := 0;
    k:=head[t];
    while ( k>0 ) do 
    begin
        i:=edge[k].too; 
        if f[i] = 0 then f[i] := search(i);
        if f[i] > max_path then max_path := f[i];
        k:=edge[k].next;
    end;
    f[t] := max_path + 1;
    exit(f[t]);
end;
begin
    fillchar(f, sizeof(f), 0);
    //fillchar(G, sizeof(G), 0);
    readln(n, m);
    for i:=1 to m do
    begin
        readln(x, y);
        //G[y, x] := 1;
        addedge(y, x); 
    end;
    for i:=1 to n do
    begin
        writeln(search(i));
    end;
end.

```

---

## 作者：mike_he (赞：0)

具体的原理和楼下大牛差不多。这里提供C++的AC代码。

[codec]





```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
#define INF 0x3f3f3f3f
vector<int> g[100010]; //存图
//queue<int> q;
//int path[100010];
int N,M;
int in[100010]; //记录入度
int ans[100010]; //存放答案
vector<int> topo; //拓扑排序结果集
inline void init(){
    cin>>N>>M;
    int u,v;
    for(int i=0;i<M;i++){
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        in[v]++;
    }
    //memset(dist,0,sizeof(dist));
    memset(ans,0,sizeof(ans));
    path[1]=-1;
}
inline void toposort(){
    stack<int> t;
    int tot=N;
    for(int i=1;i<=N;i++){
        if(in[i]==0){
            t.push(i);
            ans[i]=1;
        }
    }
    while(!t.empty()){
        int k=t.top();
        t.pop();
        topo.push_back(k);
        for(int i=0;i<g[k].size();++i){
            in[g[k][i]]--;
            if(!in[g[k][i]]) t.push(g[k][i]);
        }
    }
}
inline void work(){
    for(int j=0;j<topo.size();++j){
        int k=topo[j];
        for(int i=0;i<g[k].size();++i){
            if(ans[g[k][i]]<ans[k]+1){
                ans[g[k][i]]=ans[k]+1;
            }
        }
    }
    for(int i=1;i<=N;i++){
        printf("%d\n",ans[i]);
    }
}
int main(){
    init();
    toposort();
    work();
    return 0;
}
[/codec]
```

---

## 作者：姬海棠果 (赞：0)

拓扑排序+DP。 可以发现，入度为0的点答案为一（因为只能从他自己走到自己）。然后拓扑排序，保证了当前节点的最优子结构，因为当前结点之前的结点都是求过的，于是便从所有走到当前节点中的最大值+1便为当前节点的答案。

```cpp
var
 nextv:array[1..200000] of longint;
 next:array[1..200000] of longint;
 bian,ans,tuopu,rudu:array[1..100000] of longint;
 m,n,i,x,y,countbian,tail,head,nowbian:longint;
function max(a,b:longint):longint;
 begin
  if a>b then exit(a) else exit(b);
 end;
begin
 assign(input,'plan.in');
 assign(output,'plan.out');
 reset(input); rewrite(output);
 readln(n,m); countbian:=0; fillchar(rudu,sizeof(rudu),0);
 fillchar(ans,sizeof(ans),0);
 for i:=1 to m do begin
  readln(x,y);
  inc(rudu[y]);
  inc(countbian);
  next[countbian]:=bian[x];
  bian[x]:=countbian;
  nextv[countbian]:=y;
 end;
 head:=0; tail:=0;
 for i:=1 to n do
  if rudu[i]=0 then begin
   inc(tail); tuopu[tail]:=i; ans[i]:=1;
  end;
 while head<tail do begin
  inc(head); x:=tuopu[head]; nowbian:=bian[x];
  while nowbian<>0 do begin
   dec(rudu[nextv[nowbian]]);
   if rudu[nextv[nowbian]]=0 then begin
    inc(tail); tuopu[tail]:=nextv[nowbian]; //ans[tail]:=1;
   end;
   nowbian:=next[nowbian];
  end;
 end;
 for i:=1 to tail do begin
  x:=tuopu[i];
  nowbian:=bian[x];
  while nowbian<>0 do begin
   ans[nextv[nowbian]]:=max(ans[nextv[nowbian]],ans[x]+1);
   nowbian:=next[nowbian];
  end;
 end;
 for i:=1 to n do writeln(ans[i]);
 close(input); close(output);
end.

```

---


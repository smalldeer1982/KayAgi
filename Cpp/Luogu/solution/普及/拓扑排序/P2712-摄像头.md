# 摄像头

## 题目描述

食品店里有 $n$ 个摄像头，这种摄像头很笨拙，只能拍摄到固定位置。现有一群胆大妄为的松鼠想要抢劫食品店，为了不让摄像头拍下他们犯罪的证据，他们抢劫前的第一件事就是砸毁这些摄像头。

为了便于砸毁摄像头，松鼠歹徒们把所有摄像头和摄像头能监视到的地方统一编号，一个摄像头能被砸毁的条件是该摄像头所在位置不被其他摄像头监视。

现在你的任务是帮松鼠们计算是否可以砸掉所有摄像头，如不能则输出还没砸掉的摄像头的数量。

## 说明/提示

$1 \leq n \leq 100$。

$0 \leq m \leq 100$。

$0 \leq x,y \leq 500$。


## 样例 #1

### 输入

```
5
1 1 2
2 1 1
3 1 7
4 1 1
5 0
```

### 输出

```
2```

# 题解

## 作者：llzzxx712 (赞：43)

# P2712
[传送门](https://www.luogu.com.cn/problem/P2712)

## 题目分析
一个摄像头只有在没有其它摄像头照到它的时候才可以被砸，这就是一个[拓扑排序](https://baike.so.com/doc/6172557-6385797.html)的过程。

## 实现思路

1. 存一个有向图（森林），我使用的是领接表存图。并记录每个节点的入度。
1. 扫描所有节点，将入度为0的节点放入队列中。
1. 取出队首并将计数器+1（计数器记录可以砸掉的摄像头数量），扫描队首的所有出边。如果出边指向的是一个摄像头，那么将这个摄像头的入度减一（队首被砸了，那么监视到这个摄像头的摄像头就少了一个）。判断该摄像头入度是否为0，如果为0，则将该摄像头加入队列。
1. 重复过程3，直到队列为空。
1. 如果计数器==n，输出“YES”，否则输出(n - 计数器）。

## 易错点
- 摄像头照到的地方不一定有摄像头，应该用一个数组记录一个位置是否有摄像头。
- 数组开大一点！（我因为这个WA了10次）

## 代码

内带实现思路中各个功能的注释。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
int to[200002],ne[200002],head[10002],edge[10002],a[10002];
int n,tot,ans;
bool v[50002];
queue< int > q;
void add(int x,int y){
	to[++tot]=y,ne[tot]=head[x],head[x]=tot,edge[y]++;//edge存入度数量 
}
void read(int &x) {//快读 
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++){
    	int m,y;
    	read(a[i]),read(m);
    	v[a[i]]=1;//记录a[i]处有摄像头 
    	for(int j=1;j<=m;j++){
    		read(y);
    		add(a[i],y);//建有向森林 
		}
	}
	for(int i=1;i<=n;i++){
		if(!edge[a[i]]) q.push(a[i]);//过程2，加入入度为0节点 
	}
	while(!q.empty()){
		ans++;//计数器 
		int x=q.front();q.pop();//取出队首 
		for(int i=head[x];i;i=ne[i]){
			int y=to[i];
			edge[y]--;//入度减一 
			if(!edge[y]&&v[y]) q.push(y);//如果这个地方有摄像头且入度为0 
		}
	}
	if(ans==n) printf("YES\n");
	else printf("%d\n",n-ans);
	return 0;
}
	
```

~~**写题解不易，点个赞呗**~~


---

## 作者：henrytb (赞：21)

## 裸的拓扑排序

先输入图，本题因为数据较小，直接使用邻接矩阵存储。并且记录每个点入度。

然后依次删掉入度为0的点，每删一个更新与这个点相邻的点的入度。然后再删掉入度为0的点，一直重复，直到没有入度为0的点或删完为止。

PS：此题有坑，在于点的编号不连续，用一个used数组存储有没有这个点。

附上code:

```cpp
#include <bits/stdc++.h>//万能头文件qwq
using namespace std;
const int N=505;
int n,m,x,ma[N][N],k,du[N],q[10*N],l=1,r,maxx;
bool used[N];//记录有没有这个点
int main(){
//-----------读入------------
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&m);
		used[x]=true;
		for(int j=1;j<=m;j++){
			scanf("%d",&k);
			ma[x][k]=1;
			du[k]++;
		}
		maxx=max(maxx,x);//最大的点编号
	}
//-----------拓扑排序------------------
	for(int i=0;i<=maxx;i++)
		if(du[i]==0&&used[i])q[++r]=i;//将入度为0的点放入队列
	int ans=0;//记录删了多少个点
	while(ans<n){
		if(l>r){//不可再删
			printf("%d",n-ans);
			return 0;
		}
		int cmd=q[l++];//删点
		for(int i=0;i<=maxx;i++){
			if(ma[cmd][i]&&used[i]){
				du[i]--;//处理与被删的点相邻的点的入度
				if(du[i]==0&&used[i])q[++r]=i;//如果此点更新后入度为0，将此点放入队列
			}
		}
		ans++;//更新已删的点的个数
	}
	if(ans==n)printf("YES");
	return 0;
}
```

---

## 作者：jyz666 (赞：9)

# P2712 【摄像头】

[题面](https://www.luogu.com.cn/problem/P2712)

## 注意细节！

我一开始没有分清摄像头和区域，结果都视为一谈。结果只有10分。。。

松鼠敲摄像头的顺序就是拓扑序。

为了方便起见，把区域也视为结点，然后做toposort。

最后能删除多少个摄像头就有多少个摄像头被敲，拿总数n来减掉这个就是答案。

代码：

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
const int maxn = 505;
bool G[maxn][maxn];
bool vis[maxn];
int minv = maxn, maxv;
int n;
int a[maxn];
int indegree[maxn];
int pos;
int cnt;
bool camera[maxn];
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        int x, m, y; scanf("%d%d", &x, &m);
        vis[x] = true;
        camera[x] = true;
        minv = std::min(minv, x);
        maxv = std::max(maxv, x);
        while(m--)
        {
            scanf("%d", &y);
            G[x][y] = true;
            vis[y] = true;
            minv = std::min(minv, y);
            maxv = std::max(maxv, y);
            indegree[y]++;
        }
    }
    std::queue<int> q;
    for(int i = minv; i <= maxv; i++)
    {
        if(vis[i])
        {
            cnt++;
            if(indegree[i] == 0) q.push(i);
        }
    }
    while(!q.empty())
    {
        int u = q.front(); q.pop();
        a[++pos] = u;
        for(int v = minv; v <= maxv; v++)
        {
            if(!G[u][v]) continue;
            indegree[v]--;
            if(indegree[v] == 0) q.push(v);
        }
    }
    int ans = n;
    for(int i = 1; i <= pos; i++)
    {
        if(camera[a[i]]) ans--;
    }
    if(ans) printf("%d\n", ans);
    else printf("YES\n");
    return 0;
}
```
~~求点赞~~

---

## 作者：WanderingTrader (赞：9)

这道题难度并不大，但还是评为黄题，是有原因的。  
### 题意简述
找到所有无法销毁的摄像头，计个数即可。
### 题目分析
这题的一大难点就在于“图论建模”。  
初学图论的朋友或许想不到这是一道图有关题，不过这不要紧，做多了就会了。  
以样例为例，它实际上是这样一张图（这里我将没有摄像头的结点隐去了  ）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/pefq9mv1.png)  
本人画工有限，请谅解。  
样例解释：由于$1,2$两结点形成了环，所以无法“销毁”，输出$2$。  
但实际操作时可以不用找“环”，只要做个拓扑排序即可。  

思考：
1. 图有几个节点？
1. 图有几条边？
1. 边有没有方向？
1. 边有没有权值？
1. 基本思路是什么？

答案：
1. $n$个结点
1. $\sum{m}$条边
1. 有方向
1. 没有权值
1. 拓扑排序将所有能销毁的结点打上标记，算出不能销毁的结点数。

明确了这几个答案，可以开始写代码了。
### 代码
首先要建图：
```cpp
#define N 1005
bool d[N][N];
int in[N],out[N],num[N];
int main(){
	int n,m,i,ans = 0,a;
	scanf("%d",&n);
	for(i = 1;i <= n;i ++){
		scanf("%d",num + i);
		scanf("%d",&out[num[i]]);
		for(int j = 1;j <= out[num[i]];j ++)
		{
			scanf("%d",&a);
			d[num[i]][a] = 1;
			in[a] ++;
		}
	}
   	return 0;
}
```
这里我们采用邻接矩阵来储存边，$out[]$储存出度，$in[]$储存入度。  
此处有个坑：输入的摄像头编号不一定是输入顺序，所以要用一个$num[]$储存。  

建完图后，对**摄像头结点**进行拓扑排序即可。  
我们先枚举找到一个入度为$0$的结点：
```cpp
for(int k = 1;k <= n;k ++){
	for(i = 1;i <= n && in[num[i]];i ++);
}
```
这里我们做一个优化：如果循环结束后$i=n+1$，说明此时每个结点入度都不为$0$，之后进行再多次也是无用，直接跳出循环即可。
```cpp
if(i == n + 1) break;
```
找到这个结点后，我们先将$i$换成$num[i]$~~（为了等会少打点字）~~，由于$i$使用前都进行了初始化，所以这个改动不会有影响。
```cpp
i = num[i];
```
此时$i$这个结点可以销毁，$ans$增加$1$。
```cpp
++ ans;
```
为了防止它再次被找到，我们将$in[i]$换成$-1$：
```cpp
in[i] = -1;
```
最后将所有从$i$发出的边删除：
```cpp
for(int j = 1;j <= n;j ++)
{
	if(d[i][num[j]])
	{
		d[i][num[j]] = 0;
		in[num[j]] --;
	}
}
```
至此，拓扑排序结束。  
可以发现，刚才的操作中，我们只关注了有摄像头的结点，其余一概不管，因为它们不会影响我们的答案。  
拓扑排序代码：
```cpp
for(int k = 1;k <= n;k ++){
	for(i = 1;i <= n && in[num[i]];i ++);
	if(i == n + 1) break;
	i = num[i];
	++ ans;
	in[i] = -1;
	for(int j = 1;j <= n;j ++)
	{
  		if(d[i][num[j]])
 		{
    		d[i][num[j]] = 0;
    		in[num[j]] --;
  		}
	}
}
```

拓扑排序完成后，$ans$记录了所有能销毁的结点，而我们想要的恰恰相反，做个处理：
```cpp
ans = n - ans;
```
然后分类输出答案即可：
```cpp
if(!ans) printf("YES\n");
else printf("%d\n",ans);
```
全部代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1005
bool d[N][N],ok[N];
int in[N],out[N],num[N];
int main(){
	int n,m,i,ans = 0,a;
	scanf("%d",&n);
	for(i = 1;i <= n;i ++){
		scanf("%d",num + i);
		scanf("%d",&out[num[i]]);
		for(int j = 1;j <= out[num[i]];j ++)
		{
			scanf("%d",&a);
			d[num[i]][a] = 1;
			in[a] ++;
		}
	}
	for(int k = 1;k <= n;k ++){
		for(i = 1;i <= n && in[num[i]];i ++);
		if(i == n + 1) break;
		i = num[i];
		++ ans;
		in[i] = -1;
		for(int j = 1;j <= n;j ++)
		{
  			if(d[i][num[j]])
 			{
    			d[i][num[j]] = 0;
    			in[num[j]] --;
  			}
		}
	}
	ans = n - ans;
	if(!ans) printf("YES\n");
	else printf("%d\n",ans);
	return 0;
}
```
最后分析一下复杂度，拓扑排序$O(n)\times O(n)=O(n^2)$，而$n\in[1,100]$，一定没问题(实测结果：总用时$25ms$)。  
图论题的确是算法竞赛很重要的一部分，有些题的图论特征很微小，但最终可以抽象成一张图(比如[车站分级](https://www.luogu.com.cn/problem/P1983)这道题)。主要还是要多练，练的题多了，自然就能掌握建模技巧了。  
$\mathrm{The\ end.}$

---

## 作者：dfydada⚡⚡⚡ (赞：5)

# 个人感觉这就是个模拟题(~~也可能是我做的模拟题太多了看什么都像~~)

这题很简单，我都是一边AC的。

先把每个摄像头能照到的地方用二维储存起来，到后面枚举找就可以了。
在把所有摄像头都用bool数组标记一下，这是判断有几个被我们可爱的松鼠给摧毁了。

就想这样：

```cpp
cin>>n;
for(int i=1;i<=n;i++)
{
	cin>>x[i]>>y[i];
	t[x[i]]=1;//摄像头被摧毁的情况
	for(int j=1;j<=y[i];j++)
	{
		cin>>f[x[i]][j];//这是摄像头能照到的地方
	}
}
```
然后在枚举，不停的找，直到没有摄像头被摧毁或全部被摧毁，就退出来。
```
while(ant!=n)
{
	boolr=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=y[i];j++)
		{
			if(t[f[x[i]][j]])
			{
				t[f[x[i]][j]]=0;
				boolr=1;//这步操作表示有摄像头不能被破坏
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(t[x[i]]==1)
		{
			y[i]=0;//把所有被摧毁的摄像头所能照的地方都去除
		}
	}
	if(!boolr)
	{
		break;//如果没有摄像头被保护就退出
	}
}
```
最后在判断有几个不能被摧毁就可以了
```cpp
for(int i=1;i<=n;i++)
{
	if(!t[x[i]])
	{
		ans++;//寻找有几个不能被摧毁
	}
}
if(ans==0)
{
	cout<<"YES";
}
else
{
	cout<<ans;
}
```
总的来说还是很简单的，都感觉难度给高了。

总代码：
```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int n,x[N],y[N],f[N][N];
int ans,ant;
bool boolr,t[N];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];
		t[x[i]]=1;
		for(int j=1;j<=y[i];j++)
		{
			cin>>f[x[i]][j];
		}
	}
	while(ant!=n)
	{
		boolr=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=y[i];j++)
			{
				if(t[f[x[i]][j]])
				{
					t[f[x[i]][j]]=0;
					boolr=1;
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(t[x[i]]==1)
			{
				y[i]=0;
			}
		}
		if(!boolr)
		{
			break;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!t[x[i]])
		{
			ans++;
		}
	}
	if(ans==0)
	{
		cout<<"YES";
	}
	else
	{
		cout<<ans;
	}
	return 0;
}

```


---

## 作者：EarthGiao (赞：5)

### ~~这是我见过最水的蓝题~~

### ~~这不就是拓扑排序板子题吗~~

题目大意；松鼠砸烂摄像头不被抓住

摄像头一个可以监视到另一个可以看做有向边，用邻接链表储存就好了，我也不知道邻接矩阵到底能不能过保险起见还是用邻接链表。
可以想到，松鼠要想不被抓住必须砸没有被别的摄像头监视的摄像头，那么就是入度为0的点，很简单的可以想到拓扑排序，因为拓扑排序就是从一个没有入边的点开始一步步走，每一步都是走同样没有入边的点（和多米诺骨牌很像）。拓扑排序里的没有入边和这里的没有被监控的摄像头可以很好的联系起来，就可以知道是用拓扑排序的了。

先找到第一个入度为0的点，然后从这个点开始继续往下找，如果在某一个点找不到其他的入度为0的点，那就是jj了，松鼠很可怜，必定会被抓住了那就输出剩余的摄像头的数量。
（数量可以用一个计数器每一次可以安全摧毁一个摄像头那计数器就加一，到不能的时候就输出摄像头的总数减去计数器，如果计数器等于摄像头的总数那就输出“YES”然后结束）

AC代码

```cpp
#include<cstdio>
#include<stack>

using namespace std;

struct node
{
	int u,v,ne;
}a[100000];
int n,num,num1;
int head[10000];
int into[10000];
int bian[1000];
bool use[100000];

void add(int u,int v)
{
	a[++num].ne = head[u];
	a[num].u = u;
	a[num].v = v;
	head[u] = num;
}

int main()
{
	stack<int>s;
	scanf("%d",&n);
	for(int i = 1;i <= n;++ i)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(use[x] == false)
		bian[++ num1] = x;
		while(y --)
		{
			int xx;
			scanf("%d",&xx);
			add(x,xx);
			into[xx] ++;
			if(use[xx] == false)
			bian[++ num1] = xx;
		}
	}
	int qwq = 0;
	for(int i = 1;i <= num1;++ i)
	{
		if(into[bian[i]] == 0)
		{
			s.push(i);qwq ++;
		}
	}
	while(!s.empty())
	{
		int u = s.top();
		s.pop();
		for(int i = head[u];i != 0;i = a[i].ne)
		{
			into[a[i].v] --;
			if(into[a[i].v] == 0)
			{
				s.push(a[i].v);
				qwq ++;
			}
		}
	}
	if(qwq == n)
		printf("YES\n");
	else
		printf("%d\n",n - qwq);
	return 0;
} 
```

---

## 作者：da32s1da (赞：5)

一看数据范围这么小，当然是**暴力**啦！

因为$n$最多$100$，那么最坏的情况就是拆$100$个摄像头。

所以我们暴力枚举100次，每次判断是否可删除。
```
#include<cstdio>
int n,ans;
struct node{
	int wz,gs,ok;
	int b[105];
}a[105];
int vis[505];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].wz,&a[i].gs);
		for(int j=1;j<=a[i].gs;j++){
			scanf("%d",&a[i].b[j]);
			vis[a[i].b[j]]++;
            //记录这个位置被几个摄像头监视
		}
	}
	ans=n;//初始化答案
	for(int k=1;k<=n;k++)//暴力枚举
	for(int i=1;i<=n;i++)
	if(!a[i].ok&&!vis[a[i].wz]){
    	//没有被拆且没被监视
		a[i].ok=1;
		ans--;
		for(int j=1;j<=a[i].gs;j++)vis[a[i].b[j]]--;
        //把其监视的删掉
	}
	if(ans)printf("%d\n",ans);
	else puts("YES");
} 
```

---

## 作者：半仙胡小桃 (赞：2)

QAQ
看一下题面，发现只有没有摄像头监视的摄像头才可以砸掉，妥妥的拓扑排序

每次去找入度为0的摄像头，再进行删除它的邻接点的入度操作，直到没有入度为0的摄像头或者是全部砸掉

注意一个小坑：那就是其实摄像头的编号并不是1-n（虽然样例是）

那么我们记录最大的编号，从1-Max扫，使用F数组标记摄像头的位置，即可AC。










```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
using namespace std;
int r[99999];
int head[99999],net[99999],to[99999];
int cnt;
int f[99999];
void add(int x,int y)
{
    to[++cnt]=y;
    net[cnt]=head[x];
    head[x]=cnt;
}
int work(int n,int maxf)
{
    int ans=0;
    for(;;)
    {
        int t=0;
        for(int i=1;i<=maxf;i++)
         if(r[i]==0&&f[i]==1) 
          {
            ans++;
            t=i;
            break;
          }
        if(!t) return ans;
        for(int i=head[t];i;i=net[i])
         r[to[i]]--;
        f[t]=0;
    }
} 
int main()
{
    int maxf=0;
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
     {
        int x,y;
        scanf("%d%d",&x,&y);
        f[x]=1;
        maxf=max(maxf,x);
        for(int j=1;j<=y;j++)
         {
            int z;
            scanf("%d",&z);
            maxf=max(maxf,z);
            add(x,z);
            r[z]++;
         }
     }
     int ans=work(n,maxf);
     if(ans==n) printf("YES");
     else printf("%d",n-ans);
     return 0;
}
```

---

## 作者：SovietPower✨ (赞：1)

很明显的拓扑排序。

1. 读入所有摄像头的位置place[i]，并存储有几个摄像头能够监视到摄像头y（indgree[y] y的入度）；

2. 找到所有indgree[]为0的点i，说明没有摄像头可以监视到（可以砸掉），则将点i加入队列；

3. 删掉（砸掉）队列首的摄像头cur，所有可以被cur监控到的摄像头y入度-1（现在cur监控不到y）；如果y的入度为0（没有摄像头可以监视到），则将y也加入队列；

4. 循环3.，直到队列为空

5. 枚举n个摄像头，如果这个位置的入度为0，则可以砸掉，tot++；

6. 若最后tot==n，就是全砸掉了；否则砸不掉的就是n-tot。

```cpp
#include<cstdio>
#include<queue>
#define gc getchar()
using namespace std;
const int maxn=500005;//题目并没给数据范围 

int n,num,tot,H[maxn*2],indgr[maxn],place[maxn];
queue<int>q;

struct Edge
{
    int to,nxt;
}e[maxn*2];

void read(int &now)//读入优化 
{
    now=0;char c=gc;
    while(c<'0'||c>'9')c=gc;
    while(c>='0'&&c<='9')now=now*10+c-'0',c=gc;
}

void addedge(int x,int y)//建边 
{
    num++;
    e[num].to=y;
    //e[num].v=w;
    e[num].nxt=H[x];
    H[x]=num;
}

int main()
{
    read(n);
    for(int p,m,i=1;i<=n;i++)
    {
        read(place[i]);read(m);
        for(int a,j=1;j<=m;j++)
        {
            read(a);
            addedge(place[i],a);
            ++indgr[a];//a位置入度+1，即多了一个能监视到a的摄像头 
        }
    }
    for(int i=1;i<=n;i++)
      if(!indgr[i])//没有摄像头可以监视到i 
        q.push(i);
    while(!q.empty())
    {
        int cur=q.front();q.pop();
        for(int i=H[cur];i;i=e[i].nxt)//枚举队首cur相连的所有点 
        {
            int to=e[i].to;
            --indgr[to];//其入度-1 
            if(!indgr[to])//如果此时点to入度为0 
              q.push(to);//加入队列(可以砸掉) 
        }
    }
    for(int i=1;i<=n;i++)
      if(!indgr[place[i]])//没有可监视到place[i]的摄像头,tot++ 
        tot++;
    if(tot==n) printf("YES");
    else printf("%d",n-tot);
    return 0;
}
```

---

## 作者：NeilKleist (赞：1)

拓扑排序做法，蒟蒻第一次写题解，如有不足请指出，谢谢

’‘’cpp












```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <vector>
std::vector<int>* map = NULL;//邻接表
int* enter = NULL;//入度统计
bool* visit = NULL;//访问记录
std::map<int, int> table;//瞎搞的离散，不知道对不对orz
int last = 0;//剩余的个数
void dfs(int);//搜索
int main()
{
    int count = 0;//摄像头个数
    std::cin >> count;
    last = count;
    map = new std::vector<int>[count];
    enter = new int[count];
    visit = new bool[count];
    for (int i = 0; i < count; i++)
    {
        int pos = 0;
        int child = 0;
        std::cin >> pos >> child;
        table[pos] = i;
        enter[i] = 0;
        visit[i] = false;
        for (int j = 0; j < child; j++)
        {
            int t = 0;
            std::cin >> t;
            map[i].push_back(t);
        }
```
}//初始化








```cpp
    for (int i = 0; i < count; i++)//入度统计
    {
        int size = map[i].size();
        for (int j = 0; j < size; j++)
        {
            int tar = map[i][j];
            if (table.find(tar) != table.end())
            {
                int id = table[tar];
                enter[id]++;
            }
        }
    }
    for (int i = 0; i < count; i++)//依次便利，图可能不联通
    {
        if (enter[i] == 0 && !visit[i])
        {
            dfs(i);
        }
    }
    if (last == 0)//没有剩余的，就是可以全部拆掉了
    {
        std::cout << "YES" << std::endl;
    }
    else//输出剩余个数
    {
        std::cout << last << std::endl;
    }
    //system("pause");
    return 0;
}
void dfs(int x)
{
    visit[x] = true;
    last--;//进入函数的条件是入度为0，也就是说监控这个摄像头的摄像头都拆完了，所以这个摄像头也可以拆了
    int size = map[x].size();
    for (int i = 0; i < size; i++)
    {
        int t = map[x][i];
        if (table.find(t) == table.end())//乱搞的离散化，判断目标位置有没有摄像头
        {
            continue;
        }
        int tar = table[t];
        enter[tar]--;//这个摄像头被拆，他所监控的摄像头的入度--
        if (enter[tar] == 0 && !visit[tar])
        {
            dfs(tar);
        }
    }
}
‘’‘
```

---

## 作者：Ricardo_Y (赞：1)

很水的一道拓扑排序，类似裸题


一开始先建图，并记录每个点的入度，本题数据较小只要用邻接矩阵存一下边就行


然后把入度为0的摄像头放入一个队列，更新其他摄像头，更新后入度若为0，则进入队列可以更新其他摄像头


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,ma,a[5001],b[5001][5001],f[5001],ff[5001],l,r,cnt,q[5001];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",a+i);
        scanf("%d",b[a[i]]);
        ma=max(a[i],ma);
        f[a[i]]=1;
        for(int j=1;j<=b[a[i]][0];j++)
        {
            scanf("%d",b[a[i]]+j);
            ff[b[a[i]][j]]++;//记录每个点入度
        }
    }
    l=1;
    for(int i=1;i<=ma;i++)
        if(ff[i]==0&&f[i]) q[++r]=i;
    cnt=n;//cnt为剩下的摄像头数量
    while(cnt>0)
    {
        if(l>r)
        {
            printf("%d",cnt);
            return 0;
        }
        int t=q[l++];
        for(int i=1;i<=b[t][0];i++)
        {
            ff[b[t][i]]--;//入度减一
            if(ff[b[t][i]]==0&&f[b[t][i]]) q[++r]=b[t][i];
        }
        cnt--;
    }
    if(cnt==0) printf("YES");
    return 0;
}
```

---

## 作者：Shikita (赞：0)

一看就是一道拓扑排序的题目嘛

但是由于我根本不会拓扑排序，所以就用了一个自创的神奇代码

代码
```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
vector<int>a[505];
queue<int>q;
int n,ans=0;
int b[505],cnt[505];
bool vis[505];
//虽然我想开105来着，但是开了105会RE，我也不知道为什么
int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		int x=read(),y=read();
		b[i]=x;//离散化？
		for(int j=1;j<=y;++j) 
		{
			int z=read();
			a[x].push_back(z);//存边
			cnt[z]++;//记录有几个连到该点的边（入度）
		}
	}
	for(int i=1;i<=n;++i) if(cnt[i]==0) q.push(i);//初始化
	if(q.empty()) {cout<<n<<endl;return 0;}//特判
	while(!q.empty())
	{
		int x=q.front();q.pop();vis[x]=1;
        //记录，防止多次处理
		int len=a[x].size();//减小查询长度的时间
		for(int i=0;i<len;++i)
		{
			int y=a[x][i];
			if(vis[y]) continue;
			cnt[y]--;//把所有连边都-1
			if(cnt[y]==0) q.push(y);//继续下一个点
		}
	}
	for(int i=1;i<=n;++i) if(cnt[b[i]]==0) ans++;
	if(ans==n)  cout<<"YES";
	else cout<<n-ans;
}
```
就这样吧，姑且应该很好懂吧

---

## 作者：wawcac (赞：0)

这题可以说是2015noipd1t2信息传递的简化版，这题只用按拓扑排序依次把入度为0的点删掉，再统计没被删的有多少就行了，信息传递那题还要统计剩下的点中的最小环。还有一个不同是这题要把摄像机编号和位置用map映射一下。大概思路就是这样，详细步骤在代码注释里

    

```cpp
#include<cstdio>
#include<vector>
#include<map> 
using namespace std;
int n;//摄像头总数
map<int,int> ma;//映射位置到编号(ca中下标) 
struct camera{
    int num,in;//儿子数(似乎后面没用到)、入度
    vector<int> son;//儿子们的位置 
}temp;//temp是方便输入的临时变量
vector<camera> ca;//吐槽题目不给数据范围
void del(int x)//x是摄像机编号，即在ca中的下标 
{
    int size=ca[x].son.size();
    for(int i=0;i<size;i++)//便遍历第x号摄像机的儿子的位置
    {
        if(ma.count(ca[x].son[i])) //如果这个位置确实有摄像机（有两个数据点的摄像机拍摄到了没有其他摄像机的空位置，导致我开始只有80分）
        {
            ca[ma[ca[x].son[i]]].in--;//儿子摄像机的入度减1
            if(ca[ma[ca[x].son[i]]].in<=0)//减到0了
            {
                del(ma[ca[x].son[i]]);//就把这个儿子也删了吧
            }
        } 
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=0,lo,so;i<n;i++)//lo位置、so儿子数
    {
        scanf("%d%d",&lo,&so);
        ma[lo]=i;//映射！
        temp.num=so;
        temp.in=0;//入度清零
        for(int j=0;j<so;j++)
        {
            scanf("%d",&lo);
            temp.son.push_back(lo);//输入各个儿子的位置
        }
        ca.push_back(temp);
    }
    for(int i=0;i<n;i++)//遍历ca[]每一台摄像机，增加它们儿子的入度
    {
        for(int j=0;j<ca[i].son.size();j++)//遍历ca[i]能拍到的的每个位置
        {
            if(ma.count(ca[i].son[j]))//如果这个位置有也摄像机
                ca[ma[ca[i].son[j]]].in++;//增加入度
        }
    }
    for(int i=0;i<n;i++)
    {
        if(ca[i].in<=0)//入度为零就删了
        {
            del(i);
        }
    }
    int ans=0;
    for(int i=0;i<n;i++)//统计有多少摄像机还没被砸
    {
        if(ca[i].in>0) ans++;
    }
    if(ans==0) printf("YES");//全砸了，抢劫成功
    else printf("%d",ans);//砸不完，输出剩下的摄像机数量
    return 0;
}

```

---


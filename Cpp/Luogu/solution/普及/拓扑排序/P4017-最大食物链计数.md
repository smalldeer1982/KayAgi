# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# 题解

## 作者：御·Dragon (赞：644)

$2020$ 年 $3$ 月 $17$ 日更博报告：

1 月的更新虽然完善了一些问题，但是讲得比较快，有些同学看不大懂，故再次更新，还有什么不懂的请私信我。

由于各种问题，使得原本在[博客园](https://www.cnblogs.com/CJYBlog/p/12198894.html)中排版精美的源码在这里丑陋不堪。故[更好的阅读效果请点击这里](https://www.cnblogs.com/CJYBlog/p/12198894.html)

$2020$ 年 $9$ 月 $5$ 日更博报告：

士别三日，刮目相待。更新一些细节的描述，优化排版。希望这篇题解能够帮助更多初学者，成为最好的题解。

$2020$ 年 $11$ 月 $29$ 日更博报告：

有同学反应图萎掉了，~~我穷~~所以图床效果一般，请等待一下图片将会出现哈~

------------

### 文字讲解

> #### 题目分析：

__首先__ ，要知道这道题是 $Topo$ 拓扑排序。不妨先从拓扑排序定义下手，分析题目的性质。经分析得：

食物链中的生物 —— __节点__

生物之间的关系 —— __有向边__

为了方便描述，我们将

__不会捕食其他生物的 生产者__ 叫做 __最佳生产者__ 

__不会被其他生物捕食的 消费者__ 叫做 __最佳消费者__

由于数据中不会出现环，所以 __最大食物链__ 即 左端是 __最佳生产者__ ，右端是 __最佳消费者__ 的路径

而 __只要最左端是 最佳生产者__ 的路径（即最右端可以不是 最佳消费者 的最大食物链） 我们称之为 __类食物链__

既然 食物链中的生物 可以看成 节点，那么 __最佳生产者__ 的入度一定为 $0$， 而 __最佳消费者__ 的出度也为 $0$

> #### 思路引导

__想要找到一条 最大食物链 ，那么这条路径的 起点 入度要为0，终点 出度要为0。__ 故：

__既要记录入度，还要记录出度！__

现在的问题转换成了，__如何找到图中所有 左端点入度为0 且 右端点出度为0 的路径的数量__

> #### 正解

我们拿起笔，在草稿纸上画一个图进行推算。接下来将使用 样例 进行举例。

(将 最佳生产者 涂上 蓝色，最佳消费者 涂上 红色)

![](https://i.loli.net/2019/06/01/5cf228d6789e532172.png)

发现： __答案为 到所有 红色点 的路径条数的 总和__
  
（这里的 路径条数总和 不是 连向它有几条边 ，而是以它结束的 最大食物链 数量的总和）

对于上图，$5$ 号点的对应路径数量 取决于：以 到 $5$ 号点的三个点（ $2$ 号、$3$ 号、$4$ 号） 结尾的 类食物链 条数的总和。

而 以 $2$ 号、$3$ 号、$4$ 号 结尾的 类食物链 取决于：以 可以到达 $2$ 号、$3$号、$4$号点 的点 结尾的 类食物链 条数的总和。

以此类推，显然对于 以 任一点 结尾的 类食物链 的数量，都取决于 __蓝色点__

各点数量对应关系在下图用绿色边标注

![](https://i.loli.net/2019/06/01/5cf22bccc4f5985650.png)

__重点：__

使用拓扑排序，由题意得知 $Topo$ 排序第一轮被删掉的点 一定是 蓝色点（最佳生产者），而令 蓝色点 的答案为 $1$。

当第一轮删点时，将蓝色点可以到的点 的答案 都加上 蓝色点的 答案（即加 $1$）。

即：__拓扑排序 需要删除的点的答案 都累加到 它可以到达的点 上面去__

__这样我们就将边的累加 转换到了 点之间的累加。__

最后累加所有 红色点（最佳消费者） 的答案，输出即可。

```
以第 $i$ 号点结束的 类食物链 数量 = 以 可到达 $i$ 号点 的点 结尾的 类食物链 数量的和
```

## 以下是模拟操作过程：

~~加载时间较慢，请稍等~~

第一轮：删除 $1$ 号蓝色点，$1$ 号蓝色点可以到的点（$2$ 号点、$3$ 号点）都加 $1$

![31.png](https://i.loli.net/2019/06/01/5cf22f23d4d2d39278.png)

第二轮：删除 $2$ 号点，$2$ 号点可以到的点（$3$ 号点、$5$ 号红色点）都加 $1$。此时 $3$ 号点答案为 $2$，$5$ 号点答案为 $1$

![4.png](https://i.loli.net/2019/06/01/5cf22f23bd57f92990.png)

第三轮：删除 $3$ 号点，$3$ 号点可以到的点（$4$ 号点、$5$ 号红色点）都加 $2$。此时 $5$ 号点答案为 $3$，$4$ 号点答案为 $2$

![5.png](https://i.loli.net/2019/06/01/5cf22f23bf3f520577.png)

第四轮：最后删除 $4$ 号点，$4$ 号点可以到的点（$5$ 号红色点）加 $2$，此时 $5$ 号点答案为 $5$

![6.png](https://i.loli.net/2019/06/01/5cf22f23c170424908.png)

__可见全图只有 $5$ 号一个红色点，那么答案就是 $5$ 号点的答案———— $5$ 了__

![16.png](https://i.loli.net/2019/06/01/5cf22f5ee28c939324.png)

那么代码实现就很简单了！

### 上代码：

```
#include<bits/stdc++.h>
#include<cctype>
#pragma GCC optimize(2)
#define ll long long
#define rg register
#define New int
//上面这些花里胡哨的东西请忽略 
using namespace std;
inline New read()//快速读入
{
    New X = 0,w = 0;
	char ch = 0;
	while(!isdigit(ch))
	{
		w |= ch == '-';
		ch=getchar();
	}
    while(isdigit(ch))
	{
		X = (X << 3) + (X << 1) + (ch ^ 48);
		ch = getchar();
	}
    return w ? -X : X;
}
char F[200] ;
inline void write(New x) //快速输出
{
	if(x == 0)
	{
		putchar('0');
		return;
	}
	New tmp = x > 0 ? x : -x;
	int cnt = 0;
	if(x < 0)
		putchar( '-' );
	while(tmp > 0)
	{
		F[cnt++] = tmp % 10 + '0';
		tmp /= 10;
	}
	while(cnt > 0)
		putchar(F[--cnt]) ;
}
const int N = 5e3 + 2; //定义常量大小 
const int mod = 80112002; //定义最终答案mod的值 

int n, m; //n个点 m条边 
int in[N], out[N]; //每个点的入度和出度 
vector<int>nei[N]; //存图，即每个点相邻的点 
queue<int>q; //拓扑排序模板所需队列 
int ans; //答案 
int num[N]; //记录到这个点的类食物连的数量，可参考图 


signed main()
{
	n = read(), m = read();
	for(rg int i = 1; i <= m; ++i)
	{ //输入边 
		int x = read(), y = read();
		++in[y], ++out[x]; //右节点入度+1,左节点出度+1
		nei[x].push_back(y); //建立一条单向边
	}
	for(rg int i = 1; i <= n; ++i) //初次寻找入度为0的点(最佳生产者)
		if(!in[i])
		{ //是最佳生产者
			num[i] = 1; //初始化
			q.push(i); //压入队列 
		}
	while(!q.empty())
	{ //只要还可以继续Topo排序 
		int tot = q.front();//取出队首 
		q.pop();//弹出
		int len = nei[tot].size(); 
		for(rg int i = 0;i < len; ++i)
		{ //枚举这个点相邻的所有点
			int next = nei[tot][i]; //取出目前枚举到的点 
			--in[next];//将这个点的入度-1(因为目前要删除第tot个点) 
			num[next] = (num[next] + num[tot]) % mod;//更新到下一个点的路径数量 
			if(in[next] == 0)q.push(nei[tot][i]);//如果这个点的入度为0了,那么压入队列 
		}
	}
	for(rg int i = 1; i <= n; ++i) //寻找出度为0的点(最佳消费者) 
		if(!out[i]) //符合要求 
			ans = (ans + num[i]) % mod;//累加答案 
	write(ans);//输出 
	return 0;//end 
}
```

## 这道题主要磨炼思维。

---

## 作者：__Watcher (赞：259)

好久没写题解了，在这里水一波  
update 2019.11.15 优化代码风格，增加正确性证明&注释  
update 2020.1.6 使题解满足新版规定  
update 2020.6.26 再次更新
update 2024.1.6 再次更新使题解满足规定  

#### 总的思路：拓扑排序 ~~（管理员别以为我的题解和楼下的一样）~~

这里具体讲一下为什么要用拓扑排序（思维过程）：

1、这是一道图论题；

2、不是求最短路；

3、根据提示“**最左端是不会捕食其他生物的生产者**”可以想到，我们要入度为零的点开始查找；

4、再看一遍题目，就是求路径数，当且仅当一个点的入度变为零时才需要入队，并不是数据更新一次就要入队；

5、出度为零的点的路径总数和就是答案。

思路已经呼之欲出了：**拓扑排序！**

- - -

下面讲讲如何实现。

拓扑排序的精髓就在于每个点只会入队一次，每条边只会通过一次，所以时间复杂度就有很好的保证，$O(N+M)$，SPFA 的玄学时间复杂度）。

正确性说明：题目的补充说明告诉我们这是一张 DAG（有向无环图），因此必定存在一个入度为 0 的点，也因此每一个点都会被遍历。

下面的代码的变量解释：

$f_i$ 表示到达 $i$ 时的路径数；

$h_i$ 表示在可以直接吃掉 $i$ 的所有关系中最后的一条的编号（邻接矩阵用）；

$ru_i$ 表示 $i$ 的入度，是整个程序的核心数组；

$mp_{i,j}$ 表示 $j$ 是否能直接吃掉 $i$；

$chu_i$ 表示 $i$ 的出度；

结构体 AB 记录 $m$ 条关系。

当一个点的入度变为零，即所有它能吃的东西都已经搜索过了，这是它的数值就不会发生变化，就可以入队了。这样保证了队列里的所有数值都不会发生变化。  

---
实现方式有以下两种：

方法一：  
观察到数据范围 $n \le 5000$，用计算器一摁，发现不会 MLE ，于是就可以大胆地开一个二维数组（即邻接矩阵）存储吃与被吃的关系。代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ru[5005],chu[5005],a,b,f[5005],ans;
int mp[5005][5005];
queue<int> q;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		scanf("%d%d", &a, &b);
		mp[a][b]=1;//记录关系
		chu[a]++;
		ru[b]++;//记录入度和出度
	}
	for(int i=1;i<=n;i++){
		if(ru[i]==0) {
			f[i]=1;
			q.push(i);//入度为零的入队
		}
	}
	while(!q.empty()){//队列不为空
		int a=q.front();
		q.pop();//出队
		for(int k=1;k<=n;k++){
			if(mp[a][k]==0)continue;
			f[k]+=f[a];//更新
			f[k]%=80112002;
			ru[k]--;//食物少了一个
			if(ru[k]==0){//入队为零才入队
				if(chu[k]==0){
					ans+=f[k];
					ans%=80112002;
                    continue;//有没有都行
				}
				q.push(k);
			}
		}
	}
	cout<<ans; 
}

```
 实测时空规模：598ms /  94.18MB （在 MLE 的边缘疯狂试探）
 
 方法二：  
 用邻接表存储吃与被吃的关系，其他的和上一个代码几乎一模一样。代码如下：
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=80112002;
int n, m, h[5005], ru[5005], chu[5005], f[5005], ans;
struct AB{
    int a,b,n;
}d[5000005];
queue<int> q;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
    	int a, b;
        scanf("%d%d", &a, &b);
        d[i].a=a, d[i].b=b, d[i].n=h[a], h[a]=i;//建图
        chu[a]++, ru[b]++;
    }
    for(int i=1;i<=n;i++){
        if(ru[i]==0) {
            f[i]=1;
            q.push(i);
        }
    }
    while(!q.empty()){
        int a=q.front();
        q.pop();
        for(int k=h[a];k;k=d[k].n){
            int b=d[k].b;
            f[b]+=f[a];
            f[b]%=mod;
            ru[b]--;
            if(ru[b]==0){
                if(chu[b]==0){
                    ans+=f[b];
                    ans%=mod;
                }//出度为0的点为食物链终点，记录答案，并且不必入队
                else q.push(b);
            }
        }
    }
    cout<<ans; 
}
```
实测时空规模：  225ms /  7.70MB  

多说几句：优化方法：

1、开O2优化  204ms / 6.65MB

2、读入优化  111ms / 7.01MB

3、膜拜AK IOI的巨佬   请亲测

---

## 作者：一把丶抱住鑫 (赞：64)

本题解适合~~蒟蒻~~看。

不懂为什么大佬们写个题解的变量如此冗杂，蒟蒻看起来就会被吓死。

题的思路就是求着张有向图内一共有多少个食物链，，，好吧不太懂对吧，其实我也是百度了一下才知道是什么意思。

本题理解思路是重点。

**就是求从最垃圾的那个动物到最牛逼的动物有几条路可走**

理所当然的会想到拓扑，一个点的入度为0时，它就是这个食物链中最弱的一个，我们用d数组存放从整条链最弱的一个到这个点有几条路，那么d[这个点]+=d[比这个点稍微弱一点的]。

**最后，最d[最猛的动物]即为从最弱的到这个动物的路条数**

看大佬们该用dp的用dp，该用dfs的用dfs，蒟蒻深感无力啊。

具体解释代码中呈现。

```c
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000001;
const int mod=80112002;
queue<int> q; 
int d[maxn],in[maxn],eat[maxn],head[maxn];
int n,m,tot,ans;
struct E{
	int to,nxt;
}e[maxn];
inline void add(int u,int v)
{
	e[++tot].to=v;
	e[tot].nxt=head[u];
	head[u]=tot;
}
inline void topo()
{
	for(int i=1;i<=n;i++)
	{
		if(in[i]==0)
		{
			q.push(i);
			d[i]++;//入度为0即为最弱的一个点，所以d[i]=1;
		}
	}
	while(!q.empty())
	{
		int p=q.front();
		q.pop();
		for(int i=head[p];i;i=e[i].nxt)
		{
			int go=e[i].to;
			d[go]=(d[go]+d[p])%mod;//这句话是本题的核心
			in[go]--;
			if(in[go]==0)
			q.push(go);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b;
		add(a,b);
		in[b]++;
		eat[a]++;//这个是判断最猛的动物没人敢吃所以它的eat即为0，在下面有用。	
	}
	topo(); 
	for(int i=1;i<=n;i++)
	{
		if(eat[i]==0)
		ans=(ans+d[i])%mod;
	}
	cout<<ans;
}
```
好吧我承认这是个假的dp。。。

望管理通过。。。

---

## 作者：blackbox233 (赞：50)

### 题解也是对自己的一种提升，所以我又来写题解了。


------------


首先这个题目和  **P3183 [HAOI2016]食物链** 类似。我写那个题目也参考了一下某个大佬的代码。
话不多说，我们来看这个题目的思路，DFS+记忆化+优化 。

首先来看一下样例数据
#### 5 7
#### 1 2
#### 1 3
#### 2 3
#### 3 5
#### 2 5
#### 4 5
#### 3 4
我们可以画个图![图片1](http://m.qpic.cn/psc?/V10vKiCC171fKX/Sln7pk6dp5wwcfV4X5H3.J2T9r*p34niGJerNB8JaomKmu6dBPj9l19kzEonrJG*X.9xkAacVYfnZyFYOB4Zbw!!/b&bo=RAINAgAAAAADB2s!&rf=viewer_4)
我们可以找的的食物链为

1->2->5

1->2->3->5

1->2->3->4->5

1->3->5

1->3->4->5

一共五条食物链
，通过对图的观察我们能够发现一条完整的食物链的最高级消费者是没有被吃过的，而生产者和低级别的消费者是会被吃过，所以我们可以设置两个标记数组,**w**和**u**来表示被吃过与吃过的。

创建了这两个数组之后我们就要着手将他们的关系存下来了，因此我们可以创建一个结构体数组用来表示吃与被吃的关系，此时我们看到数据有n<=5000,m<=500000这么多的关系，我们能不能
### 直接找到生物之间吃与被吃的关系呢
如果我们能直接找到相对应的关系而不是进行循环遍历，这样我们就能够省下大量的时间。

因此我们就要朝着这个想法去创建结构体
```cpp
struct node{
	int x,y,next;//next是存与之相关的直接后继
}mp[500005];
```
想法说完了我们直接来看代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cun[5005]={0};
int w[5005]={0},u[5005]={0},ans,cun2[5005]={0};
int j=1,mod=80112002;
struct node{
	int x,y,next;
}mp[500005];

int dfs(int t){	
	int num=0;
	if(!u[t]){//如果此时这个生物没有吃过别的生物就证明找到了生产者，			
		return 1;//一条食物链找完了可以返回了 
	}
	if(cun[t])//直接返回我们搜过的 
	return cun[t];
	for(int i=cun2[t];i;i=mp[i].next){//关键，我们从与此消费者相关的直接后继开始找
										//依次找到所以与消费者t相关的直接后继，找完了i为零直接停止循环 
			(num+=dfs(mp[i].x))%=mod;
	}
	return cun[t]=num;//记忆化直接返回 
}

int main(){
	cin>>n>>m;
	while(m--){
		int a,b;
		cin>>a>>b;
		w[a]=1;//标记当前生物被吃过 
		u[b]=1;//标记当前生物吃过别的生物 
		mp[j].x=a;//存下被b吃的 
		mp[j].y=b;//存下吃a的 	
		mp[j].next=cun2[b];//存下那些是能被b直接吃的 
		cun2[b]=j;//及时更新与b相关的直接后继
		j++;
	}
	for(int i=1;i<=n;i++){
		if(!w[i]){//如果没有被吃过证明是顶级消费者 ，在测试数据中可能不止一个这样的消费者 
			(ans+=dfs(i))%=mod;//消费者代入
		}
	}
	cout<<ans;
}
```

可能注释看不太懂我来解释一下next怎么存的，
就拿样例数据来说明一下。

我们输入样例数据后发现有3组数据是直接与消费者**5**相关，分别是 3 5, 2 5, 4 5.
首先是3 5，**next**第一次存消费者**5**的有关数据，所以他上次出现的位置是0,（这也是我们终止DFS中那个循环的重要条件），**cun2[b]=j**;存下本次出现的位置，为
第4组数据。第二次是2 5，**next**就存下上次出现的位置是4，**cun2**及时更新，本次位置为5.依此类推，4 5，**netx**就存下5，**cun2**更新为6。

现在我们看到DFS之中的循环i起点就是最后一次存到的**cun2**的值，**i=mp[i].next**更新找到的就是当前这个消费者与之相关的直接的上一个结点。例如i=cun2[5]
cun2[5]最后一次存是6,我们mp.next[6]存下的是上次出现**5**与之相关的5.所以**i=mp[i].next**更新之后的i为5,以此类推之后是4，最后到0终止循环。


### 我们就通过记忆化+连接直接后继创建有向图（萌新不知道算不算有向图）.
### 就能大大缩减我们的时间复杂度了。

---

## 作者：来日方长 (赞：32)

这道题并不是很难，我不会拓扑，就用记忆化深搜做。

在输入的时候就记录没个点的出度和入度，从入度为零的点开始搜，遇到出度为零的点就返回1，用数组记录每个点最终能通向几个出度为零的点。

以上的并不是最麻烦的，想明白很容易就能写出来，但由于数据过大，得加一次%一次（~~太暴力了~~），不然就会出现负数之类的数。

因为是有向图，且没有环，所以不需要担心去重。

ac代码：

```cpp
    #include<bits/stdc++.h>
    #define Re register//能少些一堆register
    #define Mod 80112002
    using namespace std;
    const int N=5005;
    int n,m,du[N],inu[N];
    int ans,sa[N];
    int head[N*100],cnt;
    struct ed{
        int to,nex;
    }edge[N*100];
    inline void add(int x,int y){
        cnt++;
        edge[cnt].to=y;
        edge[cnt].nex=head[x];
        head[x]=cnt;
    }
    void in(int &read){
        int x=0;char ch=getchar();
        while(ch<'0'||ch>'9')ch=getchar();
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        read=x;
    }
    int dfs(int st){
        if(!du[st])return 1;
        if(sa[st])return sa[st];
        int sum=0;
        for(Re int i=head[st];i;i=edge[i].nex)
            sum=(sum+dfs(edge[i].to))%Mod;//每加一个数就%一次
        sa[st]=sum%Mod;
        return sa[st];
    }
    int main(){
        in(n);in(m);
        int a,b;
        for(Re int i=1;i<=m;i++){
            in(a);in(b);
            inu[b]++;du[a]++;
            add(a,b);
        }
        for(Re int i=1;i<=n;i++)
            if(!inu[i])ans=(ans+dfs(i))%Mod;
        printf("%d\n",ans);
        return 0;
}
```

---

## 作者：Dog_Two (赞：31)

题目很善意地提醒了一句：**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者** DAG的计数问题√，我们只需要进行一个DFS就行了。

我们的思路：

- 记录所有**消费者**，以消费者作为搜索起点

- 记录所有**生产者**，以生产者作为搜索终点


我们可以用一个bool数组对第一条进行标记。

可以用二维动态数组存储一个物种的**直接**食物，**一个物种是生产者**等价于**存储它的食物的动态数组为空**

楼上的老哥用了一个拓补排序\_(:зゝ∠)\_蒟蒻并不会，所以我们要用一个相对简单的技巧——记忆化——进行优化。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=80112002;
bool nHst[5050];
//false -> 食物链顶端
vector<int>Eat[5050];
int dp[5050];
int n,m;
int ans;
int dfs(int now){
    if(!Eat[now].size()) return dp[now]=1;
    int res=0;
    for(int i=0;i<Eat[now].size();i++){
        int &nxt=Eat[now][i];
        res+=dp[nxt]?dp[nxt]:dfs(nxt);
        res%=mod;
    }
    return dp[now]=res;
}
int main(){
    cin>>n>>m;
    int x,y;
    while(m--){
        scanf("%d%d",&x,&y);
        //y吃x
        Eat[y].push_back(x);
        nHst[x]=true;
    }
    for(int i=1;i<=n;i++) if(!nHst[i]) 
        ans=(ans+dfs(i))%mod;
    cout<<ans;    
    return 0;
}

```

---

## 作者：SofanHe (赞：21)

~~考炸NOIP好久没来写道题,一回来看见有比赛就写了一下~~

#U16321 最大食物链计数

##基本思路

我以前好像是见过类似的题目,秒出正解,写的有点丑于是就很慢.

后来又改进了一下,现在来讲讲新的做法.

[原丑的链接](https://www.luogu.org/record/show?rid=5101319)  [现在的改进版](https://www.luogu.org/record/show?rid=5101631)

虽然都很渣渣....

###回归正题!

为什么想到拓扑序?有向无环图!这个结论显然成立.

有向无环图上的计数类问题的话,用计数DP(这东西真名交递推)来解决.

计数DP在DAG上还是能用拓扑序就用拓扑序吧.......


## 算法实现

首先我们肯定是从最小的开始数,然后一个一个向上数.

所以我们从不能吃别人的开始,记它为1,然后向上传达,每传递到一个,就让那个点的权值加上传递过去这个点的权值.

最后传到所有没有上家的点就是满足最大食物链的了.

然后统计这一部分就好了.


附:代码,第一个是不好看的拓扑,第二个是还能看的拓扑

```cpp
#include<bits/stdc++.h>
#define P 80112002
using namespace std;
struct Eatn{
    int B,next;
}con[500001];int fr[5001];
void add(int a,int b,int tap){
    con[tap].B=b;con[tap].next=fr[a];fr[a]=tap;
}
struct Side{
    int num,sum;
    bool operator < (const Side& a)const{
        return sum>a.sum;
    }
}side[5001];
priority_queue<Side>ready;
int n,m,l,k;bool qqq=0,vis[5001];
unsigned long long total[5001];
int main(){
//  freopen("","r",stdin);
//  freopen("","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d %d",&l,&k);
        add(l,k,i);
        side[k].sum++;
    }
    for(int i=1;i<=n;i++){
        side[i].num=i;
        if(side[i].sum==0)total[i]=1;
        ready.push(side[i]);
    }
    while(!ready.empty()){
        Side p=ready.top();ready.pop();
        if(vis[p.num])continue;vis[p.num]=1;qqq=0;
        for(int lzh=fr[p.num];lzh;lzh=con[lzh].next){
            total[con[lzh].B]=(total[con[lzh].B]+total[p.num])%P;qqq=1;
            side[con[lzh].B].sum--;
            ready.push(side[con[lzh].B]);
        }
        if(!qqq){total[0]=(total[0]+total[p.num])%P;}
    }
    cout<<total[0];
    return 0;
}
/*
*/

```

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=80112002;
struct Point{
    int num,comein,sum;
}p[5001];
queue<int>ready;
long long total;
struct Side{int next,to;}s[500001];
int fr[5001],tails,n,m,p1,p2,nowuse;
void add(int from,int to){
    s[++tails].to=to;
    s[tails].next=fr[from];
    fr[from]=tails;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d %d",&p1,&p2);
        add(p1,p2);p[p2].comein++;
    }
    for(int i=1;i<=n;i++){
        if(!p[i].comein)p[i].sum=1,ready.push(i);
        p[i].num=i;
    }
    while(!ready.empty()){
        nowuse=ready.front();
        ready.pop();
        int lzh=fr[p[nowuse].num];
        if(!lzh)
            total=(total+p[nowuse].sum)%P;
        for(;lzh;lzh=s[lzh].next){
            p[s[lzh].to].sum=(p[s[lzh].to].sum+p[nowuse].sum)%P;
            if(!(--p[s[lzh].to].comein))
                ready.push(s[lzh].to);
        }
    }
    cout<<total%P;
    return 0;
}
```

---

## 作者：Y_B_Y (赞：18)

不会(不想用)拓扑排序?

~~DFS才是真爱~~

但是这里的DFS不是爆搜,是通过**类似**拓扑排序的思想,,只需在代码中**加几行**来优化搜索,速度和拓扑不相上下~~(主要是简单,虽然拓扑也不难QAQ)~~

~~(我觉得海星)~~
![](https://cdn.luogu.com.cn/upload/image_hosting/2tfpzizy.png)

我们先设$f[i]$为**从不会捕食其他生物的生产者(即入度为0的点)到$i$点的路径数**

正常爆搜就是直接搜下去,然后以$f[i]= \sum f[j]$(j为i的前驱),来更新f的值,这样复杂度很高,**原因如图**

![](https://cdn.luogu.com.cn/upload/image_hosting/g181n9o3.png)

按上图红色路径走,**f值的变化为**,$f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$

按绿路径走,**f的变化为**,$f[2]=f[1],f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$

可以发现$f[4]=f[3],f[5]=f[4]$是**出现了两次的**,但是5和4都只有一个前驱,我们可以猜测其实可以直接从他们的前驱一次更新过来,所以我们在走红色路径走到点3时,可以等一等(即**停止搜索**),再去走绿色路径走到点3时,**再继续搜索**,搜索路径如图

![](https://cdn.luogu.com.cn/upload/image_hosting/izx04iz2.png)

我们来看现在f值的变化,$f[3]=f[1]+f[2],f[2]=f[1],f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$

计算可以发现这个时候$f[5]$的值和上面的相等,且$f[4]=f[3],f[5]=f[4]$也只出现了一次

**结论:我们再来找一下这种搜索方法一般性的规律,可以发现就是当一个点的所有前驱都走到过它时,才继续往下搜**

就这一个结论,没了吗?


$~~$

$~~$

$~~$

$~~$

**没了**

当然如果你想**再快一点**,可以再来个优化,我们看上面的式子$f[3]=f[1]+f[2],f[2]=f[1],f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$,我们发现可以变成$f[3]+=f[1],f[2]+=f[1],f[3]+=f[2],f[4]+=f[3],f[5]+=f[4]$值也是不变的,这样在代码中就可以$O(1)$更新f值了

为什么?因为用这种方法从一个点走到它的下一个点的行为是唯一的(**不重复**),所以直接更新也可以满足公式$f[i]= \sum f[j]$(j为i的前驱)

所以**从没有前驱的节点开始搜**就可以了,细节看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6005,M=500005,mod=80112002;
#define ll long long
ll n,m,ft[N],nx[M],to[M],f[N],rd[N],ans;//rd[i]为i点的前驱数量,顺便记录一下一个点的所有前驱是否都走向它过
bool st[N];//因为前面rd有两个作用,所以需要这个来判断一个点是不是一开始就无前驱(具体的看下面)
inline long long read()
{
    char c=getchar();long long sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
void dfs(ll x)
{
	if(!rd[x])//如果所有的前驱都走到过它了,继续搜
	{
	   if(!ft[x])//如果发现他不能继续走,即为终点
	   {
		   ans=(ans%mod+f[x]%mod)%mod;//记录
		   return;//返回
	   }
	   else for(ll i=ft[x];i;i=nx[i])
	   {
		   rd[to[i]]--;//所到点的rd--
		   f[to[i]]=(f[to[i]]%mod+f[x]%mod)%mod;//因为这种方法,每次到一个点是唯一的,所有直接用f[to[i]]+=f[x]并不会出现重复(刷表法)
		   dfs(to[i]);///继续搜
	   }
    }
	return;
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		ll a=read(),b=read();
		rd[b]++;//前驱加一
		nx[i]=ft[a];//存路
		ft[a]=i;
		to[i]=b;
	}
	for(int i=1;i<=n;i++) if(!rd[i]) st[i]=1;//如果无前驱,为1
	for(int i=1;i<=n;i++) if(st[i]) f[i]=1,dfs(i);//因为搜索时会使rd[i]减为0来说明它已经被所有的前驱走到过了,所以如果这里再通过rd[i]==0来判断就会出现错误,所以要通过st来判断是原生态的无前驱节点
	cout<<ans%mod;//输出
	return 0;
}
```


---

## 作者：Guitar_Jasmine (赞：17)

突然发现不会DP了~~赶紧来水一发~~。

被题意杀了20min（可能我生物学的太差了），先来整理一下题意：

给定一个DAG（有向无环图）,求极长链（起点是入度为0的点，终点是出度为0的点）的数量。

考虑拓扑排序，用一个队列存储入度为0的点，每次从队列拿一个点出来：

1.  把它能到达的每个点的入度减1，如果被减到0则放入队列尾部。
1.  删除这个点。

最后删除的顺序就是DAG的拓扑序。

设$f[i]$表示以第$i$个点结尾的链有多少条，然后在求拓扑排序的时候顺便DP一下就好了，具体来说就是你从队列拿出了一个点$u$，然后对于每一个$u$能到达的点$v$来说，$f[v]+=f[u]$就行了，记得取模。

因为要求以出度为0的点结尾，所以答案就是 

$$\sum_{i=1}^{n}f[i] (D[i]==0)$$ 
其中$D[i]$表示点$i$的出度

代码（前面讲的很清楚就不打注释了）

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>

using namespace std;

const int N=500009,M=80112002;
queue <int> q;
int n,m,head[N],cnt,d[N],f[N],D[N];
struct Edge
{
	int nxt,to;
}g[N*2];

void add(int from,int to)
{
	g[++cnt].nxt=head[from];
	g[cnt].to=to;
	head[from]=cnt;
}

void init()
{
	scanf("%d %d",&n,&m);
	int x,y;
	for (int i=1;i<=m;i++)
		scanf("%d %d",&x,&y),add(x,y),d[y]++,D[x]++;
}

void work()
{
	for (int i=1;i<=n;i++)
		if(d[i]==0)
			q.push(i),f[i]=1;
	int ans=0;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		//printf("%d %d\n",x,f[x]);
		for (int i=head[x];i;i=g[i].nxt)
		{
			int v=g[i].to;
			d[v]--,f[v]=(f[v]+f[x])%M;
			if(d[v]==0)
				q.push(v);
		}
	}
	for (int i=1;i<=n;i++)
		if(!D[i])
			ans=(ans+f[i])%M;
	printf("%d\n",ans);
}

int main()
{
	init();
	work();
	return 0;
}

```


---

## 作者：归山_ (赞：17)

emmmmmm

这道题乍一看以为要**搜索**。。。

做着做着发现不对还要有**拓扑**
白白浪费我半个小时

然后重新打。。。

于是就有了这个代码

请原谅我~~清新~~的码风

（解释都在代码中）



------------

```
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;

int n,m,in[5010],out[5010],a,b,f[5010],ans;
//in是记录当前节点的入度（就是有机个动物能它）
//out同理记录出度
int judge[5010][5010];//进行判断能不能吃掉
queue<int> q; //拓扑排序当然要开队列了~
const int mod=80112002;//题目要求

inline int read(){
	int x=0,w=1,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	return x*w;
}
//快读不解释，代码风格这样，请见谅
//俗话说的好，不用快读一场空（其实是我瞎编的）                         
                      

int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		a=read(),b=read();
		judge[a][b]=1;
		out[a]++,in[b]++;
	}//读入数据并处理
	for(int i=1;i<=n;i++){
		if(in[i]==0){
			f[i]=1;
			q.push(i);
		}//开头最强的动物先入
	}
	while(!q.empty()){
		a=q.front();
		//q.pop();
		for(int i=1;i<=n;i++){
			if(judge[a][i]==0) continue;
			f[i]+=f[a],f[i]%=mod;
			in[i]--;
			if(in[i]==0){
				if(out[i]==0) ans+=f[i],ans%=mod;//题目要求
				q.push(i);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
//完美结束
```


------------
然后要注意的是我这个代码有一个小问题其实一看就知道了

但是为了防止直接抄袭（其实也不会有吧）

就用了一些小手段。。。

最后的最后，祝大家ak noip

开心。。。


---

## 作者：S1gMa (赞：7)

什么是拓扑排序呢 
？

举个例子 ：

```
你可以把一天 想成一个图;
在这一天中有许许多多的事情需要完成 
不过 有些事件必须等到前一个事干完了才行
```
那么问题来了 如果将效率提到最高呢？

### 这时候我们就要利用拓扑排序的思想了

日常生活中 ：

1. 在烧水时 可以 切菜 但是你做饭必须切菜
2. 在拖地时 可以 洗衣服 但是你穿衣服必须洗
3. 在睡觉时 可以 晾衣服 (滑稽) 但是你晾衣服必须有衣服
4. 等等.......

好的 思路大概有了
我们把他放在图上

根据题中 根据被吃与被吃到关系可以建立起一个图
为：
#### 有向无环图 

被吃与吃的关系 变为 方向

这时候 变为了 入度和出度（这里就不多说了 应该大家都会）

对于一个食物链 总有 顶端的东西 这里 "顶端的东西" 入度为零

##### 这便是做拓扑排序题的入手点

我们每次将入度为零点 和 与它相邻到边 也删除
这样就防止重复计算的可能 每次删除的时候进行计数即可

方法 1 ： DFS

方法 2 ： BFS

时间复杂度为 $O(n + m)$

好的 我们直接看代码：

```
#include <bits/stdc++.h>

using namespace std;
const int N = 10001, mod = 80112002;

int n, m, indeg[N], outdeg[N], a, b, f[N], ans;

int map1[N][N];

queue<int> q;
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> a >> b;
        map1[a][b] = 1;
        outdeg[a]++;
        indeg[b]++;
    }
    for (int i = 1; i <= n; i++)
        if (indeg[i] == 0)
            f[i] = 1, q.push(i);
    while (!q.empty())
    {
        int tp = q.front();
        q.pop();
        for (int to = 1; to <= n; to++)
        {
            if (map1[tp][to] == 0)
                continue;
            (f[to] += f[tp]) %= mod;
            indeg[to]--;
            if (indeg[to] == 0)
                q.push(to);
            if (indeg[to] == 0 && outdeg[to] == 0)
            {
                (ans += f[to]) %= mod;
                continue;
            }
        }
    }
    cout << ans << endl;
}
```
##### 总结 做题时 看到有先后顺序的题时 第一时间就要想到拓扑排序

---

## 作者：judgejudge (赞：7)

# 简便轻松记忆化搜索

题目让我们求所有顶端到底端的食物链之和，那么就要解决一下问题：

1. **找出顶端和低端的位置**
1. **寻找食物链**
1. **时间复杂度**


------------
### 一、找出顶端和底端的位置
我们运用标记法，分别定义两个**bool数组**，记录是否吃过别人和是否被别人吃过，如果是，标记为**true**。

**那么没吃过别人的就是底端，吃过别人的就是顶端。**

```cpp
eaten[lf]=true;
eat[rt]=true;
```


------------
### 二。寻找食物链

我们先用**链式前向星**将**吃与被吃的关系**储存起来。
```cpp
inline void fstart(ll lf,ll rt){//链式前向星
	num++;
	a[num].rt=rt;
	a[num].lf=head[lf];
	head[lf]=num;
}
```

接着寻找**顶端的位置**，对其进行**搜索**，将其所有的食物链**求和**。
```cpp
for(i=n;i>=1;i--)
if(eaten[i]==false)f(i),sum+=f(i);//利用第一步，找出顶端
```
搜寻被其吃的食物，一直不断搜索，直到出现**底端**为止，相加。
```
//40分代码
inline void f(ll x){
	register int i;
	if(eat[x]==false){//底端
		sum++;sum%=80112002;
		return ;
	}
	for(i=head[x];i!=0;i=a[i].lf){//搜索
		ll k=a[i].rt;
		f(k);
	}
	return ;
}
```


------------
### 三、时间复杂度
想要AC，必须在时间范围内，那么就用**记忆化**。

我们定义一个数组，记录**每一个数所参与的食物链之和**，这样不会重复搜索。

```cpp
//AC代码
inline ll f(ll x){
	register int i;
	if(s[x]>0)return s[x];//记忆化
	else if(eat[x]==false){//底端
		s[x]=1;
		return s[x];
	}
	for(i=head[x];i!=0;i=a[i].lf){
		ll k=a[i].rt;
		s[x]+=f(k);
	}
	s[x]%=80112002;//别忘取模
	return s[x];
}
```





---

## 作者：Ocean丶 (赞：6)

## 注意到好像没有用反向dfs的，这里给出反向dfs的一种思路。

### 核心：搜到无入度结点时，用ans数组记录更新值，当从另一条路可以到达时，直接引用该路径的ans值。



```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<map>
#include<set>
#include<stack>
#include<queue>
#define rep(i,a,n) for (int i=a;i<=n;i++)
#define rev(i,n,a) for (int i=n;i>=a;i--)
#define INF 2147483647
#define ll long long
#define err cout<<"error"<<endl;
#define o(a) cout<<a<<endl;
#define r(a) cout<<a<<' ';
#define MOD 80112002
using namespace std;

inline int read()
{
    char c=getchar();int x=0,f=1;
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+c-48;
    return x*f;
}

int n,m,in[5050],out[5050],ans[5050],an=0;
vector<int>a[5050];

int dfs(int x)
{
	rep(i,0,(int)a[x].size()-1)
	{
		int next=a[x][i];
		if(!ans[next])
			ans[x]=(ans[x]%MOD+dfs(next)%MOD)%MOD;
		else
		ans[x]=(ans[x]%MOD+ans[next]%MOD)%MOD;
	}
	return ans[x]%MOD;
}

int main()
{
    cin>>n>>m;
    rep(i,1,m)
    {
    	int t1,t2;
    	cin>>t1>>t2;
    	a[t2].push_back(t1);
    	in[t2]++;
    	out[t1]++;
	}
	rep(i,1,n)
	if(!in[i]){	ans[i]=1;	} 
	rep(i,1,n)
	if(!out[i])
	{
        dfs(i);
		an=(an%MOD+ans[i]%MOD)%MOD;
	}
	cout<<an;
    
	return 0;
}


```


---

## 作者：Paranoid丶离殇 (赞：6)

### 题目背景

你知道食物链吗？Delia生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。

### 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia非常急，所以你只有1秒的时间。

由于这个结果可能过大，你只需要输出总数模上80112002的结果。

### 输入格式

第一行，两个正整数n、m，表示生物种类n和吃与被吃的关系数m。

接下来m行，每行两个正整数，表示被吃的生物A和吃A的生物B。

### 输出格式

一行一个整数，为最大食物链数量模上80112002的结果。

**输入** 

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4
```

**输出** 

```
5 
```

### **说明/提示**

各测试点满足以下约定：

![img](https://img2018.cnblogs.com/blog/1598273/201907/1598273-20190725193819818-83409430.jpg)

 

**【补充说明】**

数据中不会出现环，满足生物学的要求。（感谢@AKEE ）

 **题解：**

利用拓扑排序O(m)统计.

从不能吃别人(入度为0)的开始,记为1,不断更新,每传递到一个,就让那个点的权值加上传递过去这个点的权值.

最后传到所有没有出度的点就是满足最大食物链的了.

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
const int N = 5e3 + 5, mod = 80112002;
int n, m, indeg[N], outdeg[N], a, b, f[N], ans;
int map[N][N];
queue <int> q;
int main(){
    cin >> n >> m;
    for(int i = 1;i <= m;i ++){
        scanf("%d%d", &a, &b);
        map[a][b] = 1; outdeg[a] ++; indeg[b] ++;
    }
    for(int i = 1;i <= n;i ++) if(indeg[i] == 0) f[i] = 1, q.push(i);
    while(! q.empty()){
        int tp = q.front(); q.pop();
        for(int to = 1;to <= n;to ++){
            if(map[tp][to] == 0)continue;
            (f[to] += f[tp]) %= mod;
            indeg[to] --;
            if(indeg[to] == 0) q.push(to);
            if(indeg[to] == 0&&outdeg[to] == 0) {
                (ans += f[to]) %= mod;
                continue;
            }
                
        }
    }
    cout << ans; 
}
```

---

## 作者：Konnyaku_LXZ (赞：6)

在这里先解释一下生产者和最高级消费者的意思
~~（怕有些同学不知道）~~

生产者：即入度为0的点。

最高级消费者：即出度为0的点。

弄懂了这两个名词之后，我们发现，这是一个有向无环图，所以我们很自然的想到了**拓扑排序**。所以我们来介绍一下拓扑排序
~~（已经会的大佬可以跳过）~~

## 拓扑排序
作用：可以用来判断一张图中**是否存在环**

算法步骤：

1.找到一个**入度为0**的点并输出。

2.遍历该点的所有连边，将每条边所指向的点的**入度减一**，并将这条边**删除**。

3.若没有入度为0的点，则退出，如果此时还有点没有被输出，则这张图中**存在环**；否则返回1。

实现方法：队列

## 思路分析
讲完了拓扑排序之后，这题的做法其实也就显然了。

令 $f[i]$ 表示从起始结点 $s$ 到 $i$ 结点的食物链条数。

初始值：$f[s]=1$ 。

状态转移方程：$f[i]=f[i]+f[j]$ 。其中， $j$ 为一个结点编号，且 $j$ 与 $i$ 之间有边相连。

我们从起点开始对整张图进行拓扑排序，过程中如果遇到出度为 $0$ 的点，则 $ans+=f[i]$ ，最后输出 $ans$ 即可。

下附AC代码：

	#include<cstdio>
	#include<iostream>
	#include<cstring>
	#include<algorithm>
	#include<stack>
	#include<queue>
	#define re register
	using namespace std;
	const int MAXN=5050,MOD=80112002;
	typedef long long LL;
	inline int read(){//快读 
		int cnt=0,sign=1;
		char c=getchar();
		while(c<'0'||c>'9'){if(c=='-') sign=-1;c=getchar();}
		while(c>='0'&&c<='9') cnt=(cnt<<1)+(cnt<<3)+(c^48),c=getchar();
		return cnt;
	}
	int N,M,e[MAXN][MAXN],u,v,in[MAXN],f[MAXN],out[MAXN],ans=0;
	queue<int> q;//拓扑排序的实现要用到的队列 
	void Solve(){//拓扑排序 
		for(int i=1;i<=N;i++) if(in[i]==0) q.push(i),f[i]=1;//找到入度为0的点，即起点 
		while(!q.empty()){
			int x=q.front();
			q.pop();
			for(int i=1;i<=N;i++){//遍历x的所有出边 
				if(e[x][i]){ 
					in[i]--;//入度减一 
					f[i]=(f[i]+f[x])%MOD;//状态转移方程 
					e[x][i]=false;//删边 
					if(i!=x&&in[i]==0){
						q.push(i);
						if(out[i]==0) ans=(ans+f[i])%MOD;//更新答案 
					}
				}
			}
		}
	}
	int main()
	{
		while(!q.empty()) q.pop();
		memset(f,0,sizeof(f));
		memset(e,false,sizeof(e));
		memset(in,0,sizeof(in));
		N=read();M=read();
		for(int i=1;i<=M;i++){//读入 
			u=read();v=read();
			e[v][u]=true;
			in[u]++;//入度加一 
			out[v]++;//出度加一 
		}
		Solve();//拓扑排序 
		cout<<ans<<endl;//输出答案 
		return 0;
	}

---

## 作者：EarthGiao (赞：4)

## 【思路】
记忆化搜索    
一开始我想DP然后失败了    
不过貌似记忆化搜索很好想    
所以我就来尝试了一哈   
没有问题   

### 【吐槽】 
（和食物链的代码几乎一样）   
（黄题食物链不是另一道）    
模数为80112002    
我觉得是出题人的生日是20021108吼     
有意思      

### 【题目大意】
有向图，找完整的链的数目   
(完整的链的意思是：   
链的头不能有入边，链的尾不能有出边)    

### 【题目分析】 
上面已经说过    
一条完整的链就是链的头不能有入边   
链的尾不能有出边     
因为如果还有的话那就是还有可以被吃或者吃的    
那这条食物链就没有结束    
就不能算是一条食物链    
（学过生物食物链那一部分知识的的应该都知道）     
所以搜索的时候就有了目标    
从头开始搜，因为头要满足没有入边    
所以在建图的时候记录入度和出度    
然后如果这个点没有入度    
那就是可以搜的     
但是还是有一个条件的        
他必须要有出度才能搜     
不然就成了一个没有入度也没有出度的点    
也就是一种孤立的生物    
所以必须满足没有入度并且有出度    
这样同时也可以避免把孤立的生物算进来   
这样搜索肯定是要超时的    
所以就要考虑优化      

### 【优化】 
剪枝？不现实     
没一条边都有可能参与到食物链的构建中去    
所以剪枝的话没有剪枝的条件     
那就记忆化搜索吧    
反正每个点之后会有多少条食物链都是一定的
那就开一个数组记录每个点之后有多少条食物链    
这样如果数组里面有值     
那就直接加上就好了    
否则就搜一下然后记录起来     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
#define mo 80112002
using namespace std;
const int Max = 200010;
struct node
{
	int y,ne;
}a[Max << 2];
int head[Max >> 1],sum = 0;
void add(int x,int y)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	head[x] = sum;
}
int ru[Max >> 2],chu[Max >> 2];
int dp[Max >> 2];
int ans = 0;

int dfs(int x)
{
	if(dp[x] != 0)return dp[x];
	int ans = 0;
	if(ru[x] != 0 && chu[x] == 0)
		ans ++;
	for(register int i = head[x];i != 0;i = a[i].ne)
	{
		ans += dfs(a[i].y);
	}
	dp[x] = ans % mo;
	return ans % mo;
}

signed main()
{
	freopen("food.in","r",stdin);
	int n,m;
	cin >> n >> m;
	int a,b;
	for(register int i = 1;i <= m;++ i)
	{
		cin >> a >> b;
		add(a,b);
		chu[a] ++;
		ru[b] ++;
	}
	int tot = 0;
	for(register int i = 1;i <= n;++ i)
		if(ru[i] == 0 && chu[i] != 0)
			tot += dfs(i) % mo;
	cout << tot % mo << endl;
	return 0; 
}
```

---

## 作者：ttycp3 (赞：3)

****啥也别说了，数组堆起来，循环绕起来，适合蒟蒻看

~~骗分过样例，暴力出奇迹——2019CCF鸿篇巨制~~

****下面是具体代码

```cpp
#include<bits/stdc++.h>//懒人万能头文件 
using namespace std;
const int maxn = 510000 , mod = 80112002;//定义两个常数项，后面有大用哦 
struct edge{
	int to;
	int next;
}e[maxn];//定义一个结构体，用于链式前向星 
int head[maxn] , num , u , v;//num为总边数，head是每个节点的第一条边 
void add(int u , int v) {//一条u向v的有向边 
	e[++num].to = v;
	e[num].next = head[u];
	head[u] = num;
}//链式前向星模拟链表 
int n , m , d[maxn] , dd[maxn] , que[maxn] , H , T;  
int dp[maxn] , ans;
int main()
{
		cin>>n>>m;
		for(int i=1;i<=m;i++){
			cin>>u>>v;
			add(u,v);
			d[v]++;dd[u]++;//记录入度节点与出度节点 
		}
	    for(int i=1;i<=n;i++)
	    if(!d[i])que[++T]=i,dp[i]=1;
	    while(H<T){
	    	int x=que[++H];
	    	for(int i=head[x];i;i=e[i].next){
	    		int y=e[i].to;
	    		if(!(--d[y])) 
	    		que[++T]=y;//如果该节点不为出度节点 ，尾指针右移 
	    	}
	    }
	    	for(int i=1;i<=n;i++){
	    		int x=que[i];
	    		for(int i=head[x];i;i=e[i].next){
	    			int y=e[i].to;
	    			dp[y]=(dp[y]+dp[x])%mod;//每算一次和进行一次取模，防止爆掉 
	    		}
	    	}
	    		for(int i=1;i<=n;i++){
	    			if(!dd[i])//判断是否为入度节点 
	    			ans=(ans+dp[i])%mod;
	    		}
	    		cout<<ans;//输出结果 
	    		return 0;
	    	}
```



---

## 作者：exi3t (赞：2)

/\*    朴素的bfs算法(去vis[])或者说spfa会超时; 

由于这是一个DAG,所以可以使用topsort;

num[i]中记录的是从所有生产者(入度为0的点)到达结点i的路径数;

在top序中,如果a->b,那么num[b]+=num[a];

最后把num[最高级消费者(出度为0的点)]加起来 取模就可以了;

\*/
/\*    证明:bfs序 无法使用num[b]+=num[a];

在bfs序中,如果a->b,那么b完全有可能在a的前面,

这样num[b]就无法被num[a]修改,得到的结果一定是错误的.

况且,如果bfs使用了vis[]数组去重,那更是错误.

\*/
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<queue>
#define loop(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int p=80112002;
vector<int>g[5000+1]; queue<int>que;
int n,m,cnt,in[5000+1],out[5000+1],num[5000+1];
int main()
{
    cin>>n>>m; int u,v;
    loop(i,1,m){
        cin>>u>>v;
        out[u]++;
        in[v]++;
        g[u].push_back(v);
    }
    loop(i,1,n) if(!in[i]) {que.push(i);num[i]=1;}
    int n0w,n3xt,s1ze;
    while(!que.empty()){
        n0w=que.front(); que.pop();    
        s1ze=g[n0w].size();
        if(!s1ze) continue;
        loop(i,0,s1ze-1){
            n3xt=g[n0w][i];
            (num[n3xt]+=num[n0w])%=p;
            in[n3xt]--;
            if(!in[n3xt]) que.push(n3xt);
        }
    }
    loop(i,1,n) if(!out[i]) (cnt+=num[i])%=p;
    cout<<cnt<<endl;
    return 0;
}
```

---

## 作者：万弘 (赞：2)

一道拓扑计数的好题

由题意,食物网是一个有向无环图(DAG),可以直接跑拓扑
 
拓扑排序:  
>  求解拓扑序列的过程/算法

拓扑序列:  
>  对于一个DAG,每个顶点都在所有可达它的点之后出现的序列(所以是不唯一的,但这不会妨碍求解问题)

拓扑代码:
```cpp
typedef long long ll;
//已定义了一个队列q
//din[i]:i的入度
void topo()
{
	for(ll i=1;i<=n;++i)
    	if(!din[i])
        {
			q.push(i);
            printf("%lld ",i);
        }
    while(!q.empty())
    {
    	ll u=q.front();q.pop();
        for(ll i=last[u];i;i=e[i].nxt)
        {
			ll v=e[i].v;
            if(!--din[v])
            {
				q.push(v);
                printf("%lld ",v);
            }
        }
    }
}
```
但是本题是利用拓扑来计数,类似DP

`设f[i]为以i结尾的最大食物链数,dout[i]为i的出度`,   

则有
$$f[i]=\sum_{E_{j,i}}f[j]$$
且
$$ans=\sum_{dout[i]==0}f[i]$$
下面的代码没有什么注释,所以细节有疑问可以私聊我

```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
#define maxn 5001
#define maxm 1000001
#define mod 80112002
ll n,m;

struct Edge
{
	ll v,nxt;
}e[maxm];
ll cnt=0,last[maxn],din[maxn],dout[maxn];
void adde(ll u,ll v)
{
	++cnt;
	++dout[u];++din[v];
	e[cnt].v=v;
	e[cnt].nxt=last[u];last[u]=cnt;
}

ll f[maxn];
struct que
{
	ll a[maxn<<1|1],h,t;
	que(){h=t=1;}
	void push(ll x)
	{
		a[t++]=x;
	}
	void pop(){++h;}
	ll front()
	{
		return a[h];
	}
	bool empty()
	{
		return h==t;
	}
}q;
void topo()
{
	for(ll i=1;i<=n;++i)
		if(!din[i])q.push(i),f[i]=1;
	while(!q.empty())
	{
		ll u=q.front();q.pop();
		for(ll i=last[u];i;i=e[i].nxt)
		{
			f[e[i].v]+=f[u];
			f[e[i].v]%=mod;
			if(!--din[e[i].v])q.push(e[i].v);
		}
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	ll u,v;
	for(ll i=1;i<=m;++i)
	{
		scanf("%lld%lld",&u,&v);
		adde(u,v);
	}
	topo();
	ll ans=0;
	for(ll i=1;i<=n;++i)
		if(!dout[i])ans=(ans+f[i])%mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：邱彦祖 (赞：1)

图的表示：
由于n的数据规模较大，并且m远远小于n*n，因此，我们采用邻接
表来表示这个图。

寻找食物链：
不难发现，我们从生产者开始，沿着食物链往上搜索，一直搜索
到最高的消费者，那么这就是一条食物链。

生产者和消费者：
那么，我们如何判定生产者和最高级消费者，也即是说如何寻找
搜索的开始和结束？很显然，这个食物网的图是一个有向图，生
产者是其中的没有任何其他节点指向它的结点，而最高消费者是
其中没有指向任何其他结点的点。

判断最高消费者：
显然，最高消费者是很好判断的，当我们搜索到了一个结点，发
现它已经没有指向任何其他的结点让我们继续搜索，那么我们就
找到了一条食物链，并且返回。

判断生产者：
生产者可以在我们建图的时候判断，我们用一个布尔数组来记录
一个结点是否是生产者，首先将这个数组的值全部初始化为
true，然后在建立图的过程中，如果建立一条a指向b的边，那么
显然，我们应该把b置为false，因为已经有一个a指向了它，它
不可能是生产者了。

深度优先搜索：
这里我们采用深度优先搜索，遍历我们的布尔数组，如果是生产
者，我们便开始搜索，当搜索到了最高消费者，我们便找到了一
条食物链，于是ans++(ans用于保存最终结果)，遍历完所有的生
产者，我们也就找到了所有的食物链。

记忆化搜索：
如果按照上面的朴素的搜索，很不幸会tle，因为虽然我们只有
1e5的结点数，但是食物链有大量的交叉，也就是我们会重复搜索
很多已经搜索过的结点，这时，我们就需要采用记忆化的搜索，
已经搜索过的结点的值可以直接用，而不用再重复进行一次搜
索。

我们用一个dp数组来记录之前的搜索结果，dp数组的含义为
1.若dp[i] = -1 ,则表示编号为i的结点未被搜索，需要进行一
次搜索
2.若dp[i] != -1 ，则表示假设编号为i的结点为生产者(其实并
不是)，从i开始的食物链的数量

那么，我们就不难发现，从编号为i的结点开始引出的食物链的数
目，就是所有以它指向的结点为生产者的食物链条数的和

下面我们就可以写代码了

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define MOD 80112002
struct node
{
    int n;   //结点点标号
    node * next;  //指向下一个结点的指针
};//定义链表结点
node v[100005];//邻接表
bool isStart[100005];//判断标号为i的结点是否为生产者
int dp[100005];//保存之前的搜索结果，若为-1，表示需要进行一次搜索，否则表示从
//该节点开始(以它为生产者，其实它不是)的食物链的条数
void insertnode(int a,int b)
{//插入一条a指向b的边，用于建立邻接表
    node * t;
    t = new node; // new一个结点
    t->n = b;   // 将结点的点标号置为b
    t->next = v[a].next;  //将之插入邻接表
    v[a].next = t;        //将之插入邻接表
    isStart[b] = false;  //由于a指向b，b不再是生产者，因此将布尔数组置为false
    return;
}
int dfs(int x)
{//记忆化搜索，搜索结点的标号为x
    int ans;//保存返回值
    if(dp[x]!=-1)//如果不为-1，则已经搜索过，可以直接用之前的搜索结果
        return dp[x];//返回之前保存在dp中的结果
    else if(v[x].next == NULL)
    {//如果没有指向其他任何结点，那么是最高消费者，那么从它开始的食物链数目为1
        dp[x] = 1;//将dp[x]置为1
        return 1;//返回以x为生产者的食物链数目，即1
    }
    node * p;
    p = v[x].next;
    ans = 0;//将返回值先初始化为0
    while(p!=NULL) //遍历所有x指向的结点
    {
        ans += dfs(p->n);
        ans %= MOD;
		/*
		从编号为i的结点开始引出的食物链的数目，就是所有以它指向的结点为生产者的食         物链条数的和
		*/
        p = p->next;
    }
    dp[x] = ans; //将搜索结果保存在dp数组当中
    return dp[x]; // 返回搜索结果
}
int main()
{
    int n,m,a,b,ans;

    while(cin >> n >> m) //输入n和m
    {
        for(int i=1;i<=n;i++)
        {
           /*
           将邻接表数组初始化，并且将布尔数组全            部置为true，将dp数组置为-1
                */
            v[i].n = i;
            v[i].next = NULL;
            isStart[i] = true;
            dp[i] = -1;
        }
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&a,&b);
            insertnode(a,b);//将边插入邻接表
        }
        ans = 0;
        for(int i=1;i<=n;i++)
        {
            if(isStart[i]&&v[i].next!=NULL)
			/*如果是生产者并且不是单独的一种孤立生物，那么对它进行搜索*/
                ans += dfs(v[i].n) ;
                ans %= MOD;
        }
        printf("%d\n",ans);
    }
    return 0;
}

```


---


# [GESP202409 八级] 手套配对

## 题目描述

小杨有 $n$ 对不同的手套，每对手套由左右各一只组成。

小杨想知道从中取出 $m$ 只手套，恰好包含 $k$ 对手套的情况有多少种。

小杨认为两种取出的情况不同，当且仅当两种情况取出的手套中存在不同的手套（同一对手套的左右手也视为不同的手套）。

## 说明/提示

| 子任务 | 占比 | $t$ | $n$ | $m$ | $k$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $1$ | $30\%$ | $\leq 5$ | $1000$ | $\le 3$ | $=1$ |
| $2$ | $30\%$ | $\leq 5$ | $\leq 5$ | $\leq 10$ | $\leq 5$ |
| $3$ | $40\%$ | $10^5$ | $1000$ | $2000$ | $2000$ |

对全部的测试数据，保证 $1 \leq t \leq 10^5$，$1 \leq n \leq 1000$，$1 \leq m \leq 2 \times n$，$1 \le k \le n$。

## 样例 #1

### 输入

```
2
5 6 2
5 1 5```

### 输出

```
120
0```

# 题解

## 作者：andycode (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P11250)
# 思路讲解
一道非常经典的排列组合的题。

首先，我们要先从 $n$ 对手套中取走 $k$ 对，容易想到方案数为 $C_{n}^{k}$。

接下来，因为我们要**恰好**取走 $k$ 对手套，所以剩下取走的 $m-2\times k$ 只手套中不能出现有两个属于同一对的情况，所以我们只能从剩下的 $n-k$ 对手套中选出 $m$ 对，各取走一只左手套或者右手套，方案数为 $2^{m-2\times k} \times C_{n-k}^{m-2\times k}$。

最终，答案为 $C_{n}^{k} \times 2^{m-2\times k} \times C_{n-k}^{m-2\times k}$。

我们只需通过杨辉三角预处理组合数，再预处理 $2$ 的整数幂，最后直接输出答案即可。

需要注意的是，预处理和统计答案时要及时取模，并且输出时要开 `long long`，否则可能会超过变量的上限。还有当 $m-2\times k<0$ 或 $m-2\times k>n-k$ 时要直接输出 $0$。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int t,n,m,k;
int C[1003][1003],mi[2003];
int main(){
    for(int i=0;i<=1000;i++)
        for(int j=0;j<=i;j++)
            C[i][j]=(j==0 || j==i?1:C[i-1][j]+C[i-1][j-1]),C[i][j]%=mod;
    mi[0]=1;
    for(int i=1;i<=2000;i++)
        mi[i]=mi[i-1]*2%mod;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&n,&m,&k);
        if(m-2*k<0 || m-2*k>n-k)
            printf("0\n");
        else
            printf("%lld\n",(1LL*C[n][k]*mi[m-2*k]%mod)*C[n-k][m-2*k]%mod);
    }
    return 0;
}
```

---

## 作者：canwen (赞：5)

~~题不难想，但是对于我这个蒟蒻杨辉三角细节没搞好导致交了 $12$ 发。~~

用杨辉三角预处理组合数，注意在这里 $C_{n}^{0}$ 结果是要为 $0$ 的，与我们熟悉的定义有所不同。

然后排列组合公式也比较好推，前面的题解也写的较为清楚了。

- 对于取完 $k$ 组之后还需要再取 $m-2k>n-k$ 个，此时一定会再有一组出现配对，答案 $0$。
- 对于 $m<2k$，取得一定构不成 $k$ 对，答案也为 $0$。
- 否则因为左右手不一样，所以方案数为 $C(n,k)\cdot C(n-k,m-2k) \cdot 2^{m-2k}$。

实现上的细节可以见代码。


```cpp
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _iter(i,a) for(auto i=a.begin();i!=a.end();++i)
#define _graph(i,u) for(int i=h[u];i;i=ne[i])
#define rint register int
#define LL long long
typedef pair<int,int> pii;

// 防止不开 LL 爆祖宗 
const LL N = 2005, mod = 1e9 + 7;
LL f[N][N],_[N];// _ i 表示 2 ^ i % mod
int t,n,m,k;

signed main(){
	_[0] = 1;
	_rep(i,1,N-1) _[i] = _[i-1]*2%mod;
	_rep(i,1,N-1){
		_rep(j,1,i){
			if(i==1) f[i][j] = 1;
			else f[i][j] = (f[i-1][j-1] + f[i-1][j]) % mod;
		}
	}
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d",&n,&m,&k);
		LL ans=0;
		if(m<2*k||m>n-k+2*k) ;
		else{
			ans = f[n+1][k+1]*f[n-k+1][m-2*k+1]%mod*_[m-2*k]%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：DeepSleep_Zzz (赞：5)

# 特别鸣谢
[快速幂取模参考文献](https://blog.csdn.net/paradoxo/article/details/74936496)
# [P11250 传送门](https://www.luogu.com.cn/problem/P11250)
# 前置芝士
排列组合、快速幂

我的评价：[~~水题一道~~](https://www.luogu.com.cn/record/list?pid=P11250&user=1229717&status=14&page=1)
# 思路
### 文字表达
题目说要恰好包含 $k$ 对手套 那我们不妨直接从一共的 $n$ 对手套中选出 $k$ 对 然后在剩下的 $(n-k)$ 对手套中每对选出一只 共选出 $(m-k \times 2)$ 只

换句话说 在选出 $k$ 对手套后 因为要保证接下来选出的手套任意两只不能来自于同一副手套 所以在剩下的 $(n-k)$ 对手套中只有 $(n-k)$ 只手套供我们选择剩下的 $(m-k \times 2)$ 只手套

最后根据题目中 
>同一对手套的左右手也视为不同的手套

所以对于我们最后选出的 $(m-k \times 2)$ 只手套而言 共有 $2^{m-k \times 2}$ 种选择
### 数学式表达
$$
C_n^k \times C_{n-k}^{m-k \times 2} \times 2^{m-k \times 2}
$$

# Tips
1.计算 $C_m^n$ 时**不要使用阶乘！不要使用阶乘！不要使用阶乘！** 因为经过取模后除数可能为 $0$ ！所以要用帕斯卡恒等式：
$$
C_m^n=C_{m-1}^n+C_{m-1}^{n-1}
$$

2.(**py 党请不要来看笑话。。**)  计算 $2^{m-k \times 2}$ 时 **不要妄图使用** `1<<(m-k*2)` **或** `pow(2,m-k*2)` 因为这显然会爆掉 `long long` 要用[快速幂取模](https://blog.csdn.net/paradoxo/article/details/74936496)

3.记得随时取模 不然会[半江红](https://www.luogu.com.cn/record/187186564)

4.特判 $m<k \times 2$ 直接输出 $0$
# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long; // 因为被long long坑过555
const ll mod=1e9+7;
ll n,m,k,t;
ll c[2010][2010];
ll qpow(ll x,ll y) // 快速幂取模
{
	ll res=1;
	while(y)
	{
		if(y&1) 
        {
            res=((res%mod)*(x%mod))%mod;
        }
		x=((x%mod)*(x%mod))%mod;
		y>>=1;
	}
	return res%mod;
}
void init() // 帕斯卡恒等式计算组合数
{
    for(ll i=0;i<2010;i++)
    {
        for(ll j=0;j<=i;j++)
        {
            if(!j)
            {
                c[i][j]=1；
            }
            else
            {
                c[i][j]=(c[i-1][j]%mod+c[i-1][j-1]%mod)%mod;
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); // 因为被卡过555
    init();
    cin>>t;
	while (t--)
	{
		cin>>n>>m>>k;
		if (m<k*2) // 不用特判 m>2*n 是因为题目的数据已经限制
		{
			cout<<0<<"\n";
		}
        else
        {
            cout<<c[n][k]%mod*c[n-k][m-k*2]%mod*qpow(2,m-k*2)%mod<<"\n"; // 简单的输出
        }
	}
	return 0; // 完结撒花~
}
```
end

---

## 作者：ACtheQ (赞：3)

题目质量有待提高

给定 $n$ 双袜子，从中选 $m$ 支，求正好凑出 $k$ 对袜子的方案数。

明显是一道幼儿园组合数学题。

考虑将题目分为两部分，一部分是正好凑出 $k$ 对的袜子的方案数，另一部分是没被选到的袜子中一双也凑不出来的方案数，答案为两者之积。

第一部分显然为 $C(n,k)$。

第二部分肯定为从 $n-k$ 双袜子中选出 $m-2k$ 双袜子使得这 $m-2k$ 双袜子中每双袜子有且仅有一只被选中。换句话说这 $m-2k$ 双袜子里每双袜子要么选了左手，要么选了右手，所以每双袜子有 $2$ 种可能，所以答案是 $C(n-k,m-2k) \times 2^{m-2k})$。

最后答案就为 $C(n,k \times C(n-k,m-2k) \times 2^{m-2k})$。

记得取模，记得特判连 $k$ 对袜子都选不了的情况。

由于 $n$ 较小，$O(n^2)$ 预处理组合数即可。

---

## 作者：Vct14 (赞：2)

首先如果 $m<2k$，即 $m$ 只手套无法包含 $k$ 对手套，答案为 $0$。

将题目转化一下。题目即需我们用 $k$ 对手套和 $m-2k$ 只无法配对的手套。前者的方案数为 $C_n^k$，即在 $n$ 对中选择 $k$ 对；后者的方案数为 $C_{n-k}^{m-2k}\times 2^{m-2k}$，即在剩余的 $n-k$ 对中选择 $m-2k$ 对，并且每一对有选择左手或右手两种方案。

综上，答案为 $C_n^k\times C_{n-k}^{m-2k}\times 2^{m-2k}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int mod=1e9+7;
const int N=2002;
int c[N][N];

void init(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	for(int i=0; i<N; i++) c[i][0]=1,c[i][i]=1;
	for(int i=0; i<N; i++) for(int j=1; j<i; j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
}

int qpow(int a,int b){
	int ans=1,base=a;
	while(b>0){
		if(b&1) ans=ans*base%mod;
		base=base*base%mod;b>>=1;
	}
	return ans;
}

int solve(){
	int n,m,k;cin>>n>>m>>k;
	if(m<2*k) return 0;
	return c[n][k]*c[n-k][m-2*k]%mod*qpow(2,m-2*k)%mod;
}

signed main(){
	init();int t;cin>>t;
	while(t--) cout<<solve()<<"\n";
	return 0;
}
```

---

## 作者：zhhgdm (赞：2)

# 前置知识

1. 排列，也就是从 $n$ 个人中选出 $m$ 个人排队方案数。

   $$
   A_n^m=\frac{n!}{(n-m)!}
   $$
   
1. 组合，也就是从 $n$ 个人中选出 $m$ 个人，相当于从 $n$ 个人中选出 $m$ 个人排队的方案数，再除去 $m$ 个人排队的方案数。

   $$
   C_n^m=A_n^m \div A_m^m
   $$

# 思路

不难想到，这是一道排列组合题，顺着题目，我们可以想到一种做法：先选出 $m$ 只手套（$C^m_{2n}$），再选出 $k$ 副手套（$C^{2k}_m$）。一算样例：$C_{10}^6 \times C_6^4=3150$。显然不对，为什么呢？因为你既然已经选出来 $m$  只手套，那么再选 $2k$ 只又有什么用呢，显然无意义，既然如此，那么我们应当从选出的 $m$ 只手套中减去不符合要求的选法。

减去几似乎并不好想，我们可以换个思路。先选出 $k$ 双（$C_n^k$），再选出 $m-2k$ 只手套。一算样例：$C_5^2 \times C_{5 \times 2-2 \times 2}^{6-2 \times 2}=150$ ，不对，因为我们没有保证剩下 $m-2k$ 只手套，凑不成双，那就改成从剩下 $n-k$ 双中，选 $m-2k$ 双（$C_{n-k}^{m-2k}$），每双选一只（$C_2^1$）。
$C_5^2 \times C_{5-2}^{2}\times C_2^1=60$，还是不对，为什么。我们回想一下刚才的思路“从剩下 $n-k$ 双中，选 $m-2k$ 双，每双选一只”，既然是“每双选一只”，那肯定不止一个 $C_2^1$，而是 $m-2k$ 个 $C_2^1$ 相乘，因为 $C_2^1=2$ 所以 $m-2k$ 个 $C_2^1$ 相乘也就是 $2^{m-2k}$，$C_5^2 \times C_{5-2}^{6-2\times 2} \times 2^{6-2\times 2}=120$，对了，所以，我们算得公式：
$$
C_n^k \times C_{n-k}^{m-2k} \times 2^{m-2k}
$$

特殊的，如果 $m<2k$，故没有任何可能，答案是 $0$。

然而，算组合数需要除法，除法不同余，所有一我们必须另想一种方法。仔细观察，可以发现
$$
C_n^m=C_{n-1}^m+C_{n-1}^{m-1}
$$

其中 $C_{n-1}^m$ 表示第 $n$ 个人不选，$C_{n-1}^{m-1}$ 则表示第 $n$ 个人选，所以之前少选一个人。

# 完整代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
long long C[2005][2005];
long long pow2[2005];
const int mod=1e9+7;
void fun(){
	int n,m,k;
	cin>>n>>m>>k;
	if(m<2*k){
		cout<<0<<endl;
		return ;
	}
	cout<<C[n][k]*C[n-k][m-2*k]%mod*pow2[m-2*k]%mod<<endl;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	for(int i=0;i<=2000;i++){
		C[i][0]=1;
	}
	for(int i=1;i<=2000;i++){
		for(int j=1;j<=i;j++){
			C[i][j]=C[i-1][j]+C[i-1][j-1];
			C[i][j]%=mod;
		}
	}
	pow2[0]=1;
	for(int i=1;i<=2000;i++){
		pow2[i]=pow2[i-1]*2%mod;
	}
	int t;
	cin>>t;
	while(t--){
		fun();
	}
	return 0;
}
```

---

## 作者：_buzhidao_ (赞：2)

[题面传送门](/problem/P11250)

# 题目分析
本题主要考察排列组合知识。

## 前置知识
### 排列组合
$$A^m_n=\frac{n!}{(n-m)!}$$ 
$$C^m_n=\frac{n!}{m!·(n-m)!}$$ 
其中：
- $n!$ 表示阶乘，$n!=n\times(n-1)\times\dots\times{2}\times{1}$。  
例，$5!=5\times4\times3\times2\times1=120$。特别地，$0!=1$。
- $A^m_n$ 表示从 $n$ 个**不同**的物品中选取 $m$ 个的**排列数**（$123$ 与 $132$ **不同**，计算两次）。  
例，$A^3_5=\frac{5!}{2!}=5\times4\times3=60$。
- $C^m_n$ 表示从 $n$ 个**不同**的物品中选取 $m$ 个的**组合数**（$123$ 与 $132$ **相同**，计算一次）。  
例，$C^3_5=\frac{5!}{3!\times2!}=\frac{120}{6\times2}=10$。

### 二项式系数

由初中知识得：
$$(a+b)^0=1$$
$$(a+b)^1=1a^1+1b^1$$
$$(a+b)^2=1a^2+2a^1b^1+1b^2$$
$$(a+b)^3=1a^3+3a^2b^1+3a^1b^2+1b^3$$
$$(a+b)^4=1a^4+4a^3b^1+6a^2b^2+4a^1b^3+1b^4$$
$$\dots$$

注意观察展开式中每一项前的系数。我们得到一个三角形：
$$1$$
$$1\quad 1$$
$$1\quad 2\quad 1$$
$$1\quad 3\quad 3\quad 1$$
$$1\quad 4\quad 6\quad 4\quad 1$$
$$\dots$$

不难发现，这个三角形中存在几个规律：
- 每一行左右两个数都是一。
- 每一行其他的数都等于上方两个数的和。
- 第 $n$ 行所有数的和为 $2^n$。

这个三角形叫做**杨辉三角**，又名**帕斯卡三角**或**贾宪三角**。
**同时，这个三角形第 $n$ 行第 $m$ 个数等于 $C^{m-1}_{n-1}$。**

### 快速求组合数
> 杨辉三角相当于组合数，打出杨辉三角就可以打出组合数。

通过公式求组合数会炸 `long long`。即使及时取模，也会导致 `WA`。  
所以，我们可以通过**预处理杨辉三角**来求组合数。

### 递归求杨辉三角
复习一下上面提到的杨辉三角性质，我们不难得到如下动态规划的状态转移方程：

> 设杨辉三角第 $n$ 行的第 $m$ 个数为 $yh_{n,m}$，则：
> - $yh_{1,1}=1$。
> - $yh_{i,j}=yh_{i-1,j-1}+yh_{i-1,j}$。

代码如下：
```cpp
typedef long long ll;
const ll mod=1e9+7;
ll yh[2024][2024];// 杨辉三角
void firset(int n){// 初始化杨辉三角
  for(int i=1;i<=n;++i){
    for(int j=1;j<=i;++j){
      if(i==1) yh[i][j]=1;
      else yh[i][j]=yh[i-1][j-1]+yh[i-1][j];
    }
  }
}
ll c(ll m,ll n){// 组合
  return yh[n+1][m+1];
}
int main(){
  firset(2012);// e.g.
  printf("%lld",c(5,3));// test
}
```
**这样，我们就使用空间换时间的策略，实现了 $O(n^2)$ 预处理，$O(1)$ 查询的求组合数功能。**

### 快速幂
这里就不加赘述。如果不理解可以看看[快速幂模版](https://www.luogu.com.cn/problem/P1226)。  
大致思路就是 $O(\log b)$ 地求 $a^b \bmod p$。

# 解题思路

本题要从 $n$ **对**手套中取出 $m$ **只**，**恰好**使得 $k$ **对**配对。

那我们可以分成两部分求解：

1. 从 $n$ 对手套中取出 $k$ 对，总情况数为 $C^k_n$。
2. 从剩余的 $n-k$ 对手套中取出 $m-2k$ 只，**每对中最多选一只**（即左右两只中任选一只），总情况数为 $C^{m-2k}_{n-k}\times 2^{m-2k}$。

设总情况数为 $\text{ans}$，则易得：
- 当 $m<2k$，不可能配对，$\text{ans}=0$；
- 当 $m-2k>n-k$，配对一定会多于 $k$ 对，$\text{ans}=0$；
- 否则，$\text{ans}=C^k_n\times C^{m-2k}_{n-k}\times 2^{m-2k}$。

注意在合适的地方取模。

代码就不贴了。

---

## 作者：leo120306 (赞：1)

首先一个显然的结论：当 $m<2\times k$ 时，无可行方案，因为 $k$ 对手套至少需要选择 $2k$ 件手套才够。

排除这种情况，我们逐点考虑。首先在 $n$ 对手套中选择完整 $k$ 对的方案数为 $C_n^k$。还剩下 $m-2\times k$ 件手套是可选的，而这些手套可以从剩下的 $n-k$ 对手套中选择。左右手比较难办，我们暂时设剩下这些手套都只有左手，那么方案数就要再乘上 $n-k$ 件手套中选 $m-2\times k$ 件手套的方案数，也就是 $C^{m-2\times k}_{n-k}$。然后补上每一件手套都有左右手两种可能，就是再乘 $2^{m-2\times k}$。

因此答案为：

$$\begin{cases}
\left(C^k_n\times C^{m-2\times k}_{n-k}\times 2^{m-2\times k}\right)\bmod (10^9+7)&\text{,}\ m-2\times k\geq0\text{;} \\
0\quad&\text{, otherwise.}
\end{cases}$$

组合数和 $2$ 的幂用递推公式预处理即可。时空复杂度 $O(nm)$。

```cpp
#include <cstdio>

long long C[2005][2005],pow2[2005];

int main(){
	int t;scanf("%d",&t);
	pow2[0]=1;pow2[1]=2;
	C[0][0]=1;
	C[1][0]=1;C[1][1]=1;
	for(int i=2;i<=2000;i++){
		C[i][0]=1;pow2[i]=pow2[i-1]*2%1000000007;
//		printf("%d\n",pow2[i]);
		for(int j=1;j<=i;j++){
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%1000000007;
//			printf("%d%c",C[i][j]," \n"[j==i]);
		}
	}
	while(t--){
		int n,m,k;scanf("%d%d%d",&n,&m,&k);
		if(m-2*k<0)puts("0");
		else printf("%lld\n",C[n][k]*C[n-k][m-2*k]%1000000007*pow2[m-2*k]%1000000007);
	}
	
	return 0;
}
```

---

## 作者：Nightsky_Stars (赞：1)

# 思路：
这是一道排列组合的题。

首先，从 $n$ 对手套里面选 $k$ 对手套，方案数为 $C_{n}^{k}$。其次，我们要从剩下 $n-k$ 对手套里面选 $m-2 \times k$ 只手套，而题目要求只能有 $k$ 对手套，并且同一对手套的左右手视为不同的手套。所以方案数为 $C_{n-k}^{m-2 \times k} \times 2^{m-2 \times k}$。

综上，答案为 $C_{n}^{k} \times C_{n-k}^{m-2 \times k} \times 2^{m-2 \times k}$ 

# CODE:


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll c[2010][2010],mod=1e9+7;
ll ksm(ll a,ll k){//快速幂
	ll res=1;
	while(k){
		if(k&1) res=res*a%mod;
		a=a*a%mod;
		k>>=1;
	}
	return res;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for(ll i=0;i<=2000;i++){
		for(ll j=0;j<=i;j++){
			if(j==0) c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}//杨辉三角预处理组合数
	ll t;
	cin>>t;
	while(t--){
		ll n,m,k;
		cin>>n>>m>>k;
		if(m<2*k||m-2*k>2*(n-k)){//特判
			cout<<"0\n";
			continue;
		}
		cout<<c[n][k]*c[n-k][m-2*k]%mod*ksm(2,m-2*k)%mod<<"\n";
	}
	return 0;
}
```

---

## 作者：xuezhiyu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11250)

# 分析题目

首先要从一共 $n$ 套手套中选出来恰好 $k$ 套，那么这 $k$ 套的选择的方案数一共就是 $\binom{n}{k}$ 种；之后我们还需要选择 $m - 2 \times k$ 只，手套，因为题目说的是恰好选 $k$ 套，所以这 $m - 2 \times k$ 只手套不能重复，即对于每套手套最多只能选择其中的一个，所以在 $n - k$ 种颜色的手套中选 $m - 2 \times k$ 只手套，方案数是 $\binom{n - k}{m - 2 \times k}$ 种，对于选出来的每种颜色的手套，又有左手和右手的两种情况，所以还要乘上一个 $2^{m - 2 \times k}$，所以总的答案就是：

$$\binom{n}{k} \times \binom{n - k}{m - 2 \times k} \times 2^{m - 2 \times k}$$

从中，我们也可以明显看到无解条件 $m < 2 \times k$ 或 $n - k < m - 2 \times k$。

因为本题的数据范围只有 $2 \times 10^3$，所以直接 $\text O(N^2)$ 处理组合数即可。

# 代码时间

```cpp
#include <iostream>
#define int long long

using namespace std;

const int N = 2e3 + 10, mod = 1e9 + 7;
int n, m, k, c[N][N], pow2[N];

void init() { // 初始化组合数和 2 的次方
	for (int i = 0; i < N; i++)
		for (int j = 0; j <= i; j++)
			c[i][j] = (!j ? 1 : c[i - 1][j] + c[i - 1][j - 1]) % mod;
	pow2[0] = 1;
	for (int i = 1; i < N; i++) pow2[i] = (pow2[i - 1] << 1) % mod;
}

signed main() {
	init();
	int T;
	cin >> T;
	while (T --> 0)  {
		cin >> n >> m >> k;
		if (m < 2 * k) { // 判断无解情况，因为第二种无解情况会在组合数那里被判断到，所以只用写一个
			cout << 0 << endl;
			continue; // 考场上写成 return 0; 调了好久……
		}
		cout << (c[n][k] * c[n - k][m - 2 * k] % mod * pow2[m - 2 * k] % mod) << endl; // 答案计算
	}
	return 0;
}
```

---

## 作者：Ame_Rain_chan (赞：0)

简单数数题。

因为要求**恰好**拿 $k$ 对手套，说明剩下要拿的手套一定不能成对，也就是在剩下的每对手套中拿一只。

此时可以推出无解情况。当：

1. 总的手套对数小于要拿出的手套对数；
2. 要拿出的手套数小于要拿出的手套对数 $\times 2$；
3. 拿完后的剩余手套对数小于拿完成对手套后还需要拿的手套数；

时，情况无解，输出 $0$ 即可。

再看有解情况。

因为一共有 $n$ 对手套，需要从中拿 $k$ 对手套，即 $C_n^k$。

再看剩下的单只手套。此时剩下了 $n-k$ 对手套，需要从中拿 $m-k\times2$ 只不一样的手套（即选出 $m-k\times2$ 对，每对拿一只），即为 $C_{n-k}^{m-k\times2}$。

因为每对手套都有拿左手套和拿右手套两种选择，所以由上得到 $C_{n-k}^{m-k\times2}\times2^{m-k\times 2}$。

因为选成对手套和拿单只手套是两个独立事件，所以是乘法原理，乘起来就好了。

别忘了取模。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2010,mod=1e9+7;
int n,m,k;
ll c[N][N];
ll qmi(ll a,int b){
    ll res=1;
    while(b){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b >>= 1;
    }
    return res;
}
int main(){
    int t;scanf("%d",&t);
    c[0][0]=1;
    for(int i=1;i <= 1000;i++){
        c[i][0]=c[i][i]=1;
        for(int j=1;j<i;j++){
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
        }
    }
    while(t--){
        scanf("%d%d%d",&n,&m,&k);
        if(k>n || m<k*2 || m-k*2>n-k) printf("0\n");
        else printf("%lld\n",c[n][k]%mod*c[n-k][m-k*2]%mod*qmi(2,m-k*2)%mod);
    }
    return 0;
}
```

---

## 作者：wuyouawa (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11250)

### 思路

本题可以用组合来做。

首先把问题分成两部分，一是从 $n$ 对中取出 $k$ 对，二是从 $n-k$ 对中取出 $m-2k$ 对，并保证每对中最多只选一只。为什么呢？因为我们先要保证恰好 $k$ 对手套，接着又要选出剩下的 $m-2k$ 对手套，又不能和原来的 $k$ 对手套相同手。那么一的话显而易见是 $C(n,k)$，$C$ 是组合数，二是 $C(n-k,m-2k) \times 2^{m-2k}$。二的前面是选，后面就是你在这 $m-2k$ 只手套中选出与 $k$ 对手套不同手的方案数，左右手任意，就是 $2^{m-2k}$。$2$ 的幂可以数组预处理，组合数也可以用杨辉三角预处理，然后就做完了。

注意事项：

- 取模。

- 特判不能的情况，输出 $0$。
### CODE


```cpp
#include <bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;//定义模数
long long t,n,m,k,c[2005][2005],f[2005];//上限2000，够了，c是组合数，f是2的幂
int main() {
	cin>>t;
	for(int i=0;i<=2000;i++)
	{
		c[i][0]=1;
		c[i][i]=1;
		for(int j=1;j<i;j++)
		{
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;//杨辉三角公式
		}
	}
	f[0]=1;
	for(int i=1;i<=2000;i++)
	{
		f[i]=f[i-1]*2%mod;//2的幂预处理
	}
	while(t--)//多测
	{
		cin>>n>>m>>k;
		if(k>n||m<2*k)  cout<<0<<endl;//先判不够k对的情况
		else
		{
			cout<<c[n][k]*c[n-k][m-2*k]%mod*f[m-2*k]%mod<<endl;//根据结论
		}
	}
	return 0;
}
```

---

## 作者：Jason_Ming (赞：0)

### 思路

如果你不了解排列组合，建议你看看 [OI wiki](https://oi-wiki.org/math/combinatorics/combination/)。

本题中，取出手套的方案是否不同与取出的顺序无关，故应使用组合数解决问题。

题目要求在 $m$ 只手套里**恰好**有 $k$ 对手套。那么，剩下的 $m-2k$ 只手套两两之间都不能凑成一对。也就是说，如果 $n-k < m-2k$，那么无解，应该输出 $0$。

同时，如果 $m<2k$ 的话，也要输出 $0$。因为有 $k$ 对手套至少需要 $2k$ 只手套。

如果不符合上面两种无解情况，那么就要开始计算了。

首先，从 $n$ 对手套里选出 $k$ 对的选法有 $C_n^k$ 种。

接下来，剩下的 $m-2k$ 只手套要从剩下的 $n-k$ 对中选择，由于这一步选择的手套不可以成对，所以每对手套中只能有一只手套被选中，于是问题转化为从 $n-k$ 只手套中选择 $m-2k$ 只手套，有 $C_{n-k}^{m-2k}$ 种选法。

需要注意的是，我们只选择了一只手套来代表一对手套，而一对手套有左右两只手套。所以还需要计算从 $m-2k$ 对手套中选择 $m-2k$ 只手套的选法有多少种。根据乘法原理，有 $2^{m-2k}$ 种选法。

最后，根据乘法原理，答案就是 $C_n^k \times C_{n-k}^{m-2k} \times 2^{m-2k}$。

答案对 $10^9+7$ 取模。

### 代码

阅读本代码可能需要的前置知识：[同余](https://oi-wiki.org/math/number-theory/basic/#%E5%90%8C%E4%BD%99)和[快速幂](https://oi-wiki.org/math/binary-exponentiation/)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int mod=1000000007;
int t,n,m,k;
int c[2005][2005];

int fpow(int a,int b)//快速幂 
{
	int ans=1;
	while(b)
	{
		if(b&1)(ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}

signed main()
{
	for(int i=0;i<=2000;i++)
	{
		for(int j=0;j<=i;j++)
		{
			if(j==0||i==j)c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;//利用组合数递推式进行预处理 
		}
	}
	cin>>t;
	while(t--)//多测 
	{
		cin>>n>>m>>k;
		if(m<k*2||m-k*2>n-k)//无解 
		{
			cout<<0<<endl;
			continue;
		}
		cout<<c[n][k]*c[n-k][m-k*2]%mod*fpow(2,m-k*2)%mod<<endl;//记得在乘的过程中也要取模，不然爆long long 
	}
}
```

**拒绝抄袭，从我做起。**

---

## 作者：Crasole (赞：0)

## 思路

在 $n$ 副手套中选出 $k$ 副手套的方案数是 $C_n^k$ 种，在剩下的 $n - k$ 副手套中选出 $m - 2 \times k$ 只手套的方案数是 $C_{n - k}^{m - 2 \times k}$ 种，又因为手套区分左右手，所以还要乘上 $2^{m - 2 \times k}$，所以方案数是 $C_n^k \times C_{n - k}^{m - 2 \times k} \times 2^{m - 2 \times k}$ 种。

组合数可以用杨辉三角预处理，再用一个 $base$ 数组预处理 $2$ 的幂，最后别忘了取模。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define N 2005
using namespace std;
const int MOD = 1e9 + 7;
int t, n, m, k;
int base[N], C[N][N]; 
 
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
    //预处理组合数
	for(int i = 0; i <= 2000; ++i) C[i][0] = 1;
	C[1][0] = C[1][1] = 1;
	for (int i = 2; i <= 2000; ++i)
		for (int j = 1; j <= i; ++j)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
	//预处理2的幂
    base[0] = 1;
	for(int i = 1; i <= 2000; ++i) base[i] = (base[i - 1] * 2) % MOD;
	cin >> t;
	while(t --) {
		cin >> n >> m >> k;
        //公式
		cout << ((C[n][k] * C[n - k][m - 2 * k]) % MOD * base[m - 2 * k]) % MOD << '\n';
	}
	return 0;
}
```

---


# 车的放置

## 题目描述

有下面这样的一个网格棋盘，$a,b,c,d$ 表示了对应边长度，也就是对应格子数：

![](https://cdn.luogu.com.cn/upload/image_hosting/g7ulpevu.png)

当 $a=b=c=d=2$ 时，对应下面这样一个棋盘：

![](https://cdn.luogu.com.cn/upload/image_hosting/e2ntmjlk.png)

要在这个棋盘上放 $k$ 个相互不攻击的车，也就是这 $k$ 个车没有两个车在同一行，也没有两个车在同一列，问有多少种方案。


## 说明/提示

#### 数据规模与约定

- 存在部分数据，保证 $b=0$；
- 存在部分数据，保证 $a,b,c,d\leq 4$。
- 对于 $100\%$ 的数据，保证 $0\leq a,b,c,d,k\leq 10^3$，且至少有一种可行方案。

## 样例 #1

### 输入

```
2 2 2 2 2```

### 输出

```
38
```

# 题解

## 作者：巨型方块 (赞：91)

.....
..
额，这个就是dp啊；

思路和p1240 是很像的；

我先把这个图像左右反转一下，这样方便dp

f[j][i]代表前j列放i个的方案；

v[j]代表第j列的高度；

f[j][i]=(f[j-1][i]+f[j-1][i-1]\*(v[j]-i+1))%mo;

答案就是f[a+c][m]

...
没了啊

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
int f[N][N],v[N];
int a,b,c,d,m,ans,mo=100003;
int main()
{
    scanf("%d%d%d%d%d",&a,&b,&c,&d,&m);
    for(int i=1;i<=c;i++)v[i]=d,f[i][0]=1;
    for(int i=1;i<=a;i++)v[c+i]=d+b,f[c+i][0]=1;
    f[0][0]=1;
    for(int j=1;j<=a+c;j++)
        for(int i=1;i<=m;i++)
            f[j][i]=(f[j-1][i]+f[j-1][i-1]*(v[j]-i+1))%mo;
    printf("%d",f[a+c][m]);
}
```

---

## 作者：紫薯布丁 (赞：48)

1：n*n的矩阵上放置n个车，求放置方案

第一行有n种选择：第二行有n-1种选择，第三行n-2种选择..........第n行有一种选择

其实跟排队问题类似，答案就是$ n!=A^{n}_{n}$

2：n*n的矩阵上放置k个车，求放置方案

实际上是从n行中选k行，n列中选k列，放置方案$ C_{n}^{k}*C_{n}^{k}*k!$

3：n*m的矩阵上放置k个车，求放置方案

与上面的类似，从n行中选出k行从m列中选出k列组成$k*k$的正方形，放置方案$ C_{n}^{k}*C_{m}^{k}*k!$



3:P1350 车的放置问题，即**可看作为$ a*(b+d),c*d$两个矩阵拼接而成**,答案就变成$ C_a^i*C^i_{b+d}*i!*C_c^{k-i}*C_d^{k-i}*(k-i)!$



但这时候会存在重复选择，重复的是什么呢？

其实对于$c*d$的矩阵，d列中每选一列，$a* (b+d) $的矩阵中就会少一列选择,因为b+d列中包括了d列



所以答案就是

$ C_a^i*C^i_{b+d-(k-i)}*i!*C_c^{k-i}*C_d^{k-i}*(k-i)!$

---

## 作者：_ctz (赞：23)

[$My\ blog$](https://ctz45562.github.io/2019/06/20/洛谷-P1350-车的放置)

[传送门](https://www.luogu.org/problemnew/show/P1350)

先设$f(n,m,k)$为在$n\times m$的矩形中放$k$个车的方案。

把这个阶梯状的棋盘分割成两个$a\times b$和$(a+c)\times d$的矩形。

然后枚举在这两个矩形放几个车。

答案就是$\sum\limits_{i=0}^kf(a,b,i)f(a+c-i,d,k-i)$

再来处理$f$。

显然在一个$n\times n$的棋盘里放$n$个车的方案数为$n!$。

从$n\times m$的棋盘里抽出一个$k\times k$的棋盘，有$C_n^kC_m^k$中方案。

那么$f(n,m,k)=C_n^kC_m^kk!$，注意特判$k>n,m$的情况。

这题就没了。

（数据范围明明可以开到$1e7$或者套个卢卡斯啊）


``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 3005
#define inf 0x3f3f3f3f

const int mod = 100003;

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
int fac[maxn]={1},inv[maxn];
int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;}
inline int C(int n,int m){
    return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;
}
inline int f(int n,int m,int k){
    if(k>n||k>m)return 0;
    return 1ll*C(n,k)*C(m,k)%mod*fac[k]%mod;
}
int main(){
    int a=read(),b=read(),c=read(),d=read(),k=read(),tp=max(b,max(a+c,d)),ans=0;
    for(register int i=1;i<=tp;++i)fac[i]=1ll*fac[i-1]*i%mod;
    inv[tp]=INV(fac[tp]);
    for(register int i=tp-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    for(register int i=0;i<=k;++i)(ans+=1ll*f(a,b,i)*f(a+c-i,d,k-i)%mod)%=mod;
    printf("%d\n",ans);
}

```



---

## 作者：Create_Random (赞：12)

题目要求在一个L形网格棋盘中放置 $k$ 个车，

使得每个车都不互相攻击。

------------
不难想到可以将这个L形网格分成两个矩形，

一个长为 $a$ 宽为 $b+d$ ,

另一个长为 $c$ 宽为 $d$ .

分别计算将 $k$ 个车将 $i$ 个车放置在左边的矩形里，将 $k-i$ 个车放在右边的矩形里，

问题就转化为了求在矩形中能放置几个车使其互不攻击，

即可使用组合数求解。

我们可以想象一下：

在一个 $n\times m$ 的矩形中使得 $i$ 个车互不攻击，

可以从 $n$ 行中任选 $i$ 行，从 $m$ 列中任选 $i$ 列使其被限制在这个“正方形”中，

又因为在这个 $i\times i$ 大小的正方形中进行排列组合时，

第一行有 $i$ 种选择方法，第二行有 $i-1$ 种选择方法 …… 第 $i$ 行只有 $1$ 种选择方法。

则在 $n\times m$ 的矩形中使得 $i$ 个车互不攻击的方案数为 $C_n^i \times C_m^i \times i!$

但是题目中还需要考虑两个矩形之间的互相冲突情况：

因为在 $c\times d$ 的矩形中有 $k-i$ 个车，

那么就已经占据了 $k-i$ 行，

故在 $a\times (b+d) $ 的矩形中只有 $b+d-(k-i)$ 行能被使用。

------------
综上所述，总方案数为:

$C_a^i \times C_{b+d-(k-i)}^i \times i! \times C_c^{k-i} \times C_d^{k-i} \times (k-i)!$

注意好取模即可。

$Code$:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e5+3;
int a,b,c,d,k;
int C[2010][2010];
int fac[1010];
int ans;
signed main()
{
	scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&k);
	for(int i=0;i<=2000;i++)
	{
		C[i][0]=C[i][i]=1;
	}
	for(int i=1;i<=2000;i++)
	{
		for(int j=1;j<=2000;j++)
		{
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	fac[0]=1;
	for(int i=1;i<=k;i++)
	{
		fac[i]=fac[i-1]*i%mod;
	}
	for(int i=0;i<=k;i++)
	{
		ans+=C[a][i]%mod*C[b+d-(k-i)][i]%mod*fac[i]%mod*C[c][k-i]%mod*C[d][k-i]%mod*fac[k-i]%mod;
		ans%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：一只书虫仔 (赞：10)

#### Description

> 给定由一个 $a \times b$ 的矩阵和一个 $(a+c) \times d$ 的矩阵组成 L 形块，往上面放车使得同一行和同一列没有两辆车。            
> 求有多少种放置方案。

#### Solution

考虑动态规划。

因为每一行可以选择放或不放，因此暴力升维。升放或不放比较麻烦，因为考虑不到前几行的情况，因此升为放 $j$ 个。

设 $dp_{i,j}$ 为第 $i$ 行放 $j$ 个车时的答案。

那么分类讨论：

- 第 $i$ 行放 $0$ 个车：那么可以直接从 $dp_{i-1,j}$ 转移过来。
- 第 $i$ 行放 $1$ 个车：因为车不能在同一列，所以除去前 $j$ 个放置的其他位置都可以放置车，即有 $a+c\ (\text{or }a)-j+1$ 个位置可以放车，那么可以从 $dp_{i-1,j-1} \times (a+c\ (\text{or }a)-j+1)$ 转移过来。
- 第 $i$ 行放多于 $1$ 个车：不满足题意，舍弃。

代码需要注意的就是特判现在这一行在 L 形块上面的小矩形（$i \le b$）还是下面的大矩形（$i>b$）即可。

并且在 $i \le b,j>a$ 的区域是没有答案的。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

long long dp[2086][2086];
long long Mod = 1e5 + 3;

int main () {
	long long a, b, c, d, k;
	scanf("%lld%lld%lld%lld%lld", &a, &b, &c, &d, &k);
	for (long long i = 0; i <= b + d; i++) dp[i][0] = 1;
	for (long long i = 1; i <= b + d; i++)
		for (long long j = 1; j <= k; j++) {
			if (i <= b && j > a) break;
			if (i <= b) {
				long long ans = dp[i - 1][j - 1] * (a - j + 1);
				ans %= Mod;
				dp[i][j] = dp[i - 1][j] + ans;
				dp[i][j] %= Mod;
			} else {
				long long ans = dp[i - 1][j - 1] * (a + c - j + 1);
				ans %= Mod;
				dp[i][j] = dp[i - 1][j] + ans;
				dp[i][j] %= Mod;
			}
		}
	printf("%lld", dp[b + d][k] % Mod);
	return 0;
}
```

---

## 作者：CG__HeavenHealer (赞：7)

### 题意

在一个缺一个角的矩形里放 $k$ 个车，问这些车两两不相互攻击的方案数。


### 解法

由于车的走法较为简单 ~~（不服去看隔壁八皇后）~~ ，加上求方案数可以沿用历史记录，具有最优子结构性质，考虑DP。

设 $f[i][j]$ 表示第 $i$ 行，放了 $j$ 个车的方案数，接下来考虑怎样转移。

首先，如果方案是合法的，两个车不能同时出现在同一列和同一行。对于同一行的情况，可以通过一行只枚举一个车来解决；而对于同一列的情况，我们需要计算出目前合法的格子，再乘上上一行的方案数，即 $ len \times f[i-1][j-1] $  （ $len$ 表示第 $i$ 行剩余合法的格子），就得到了把一个车放在这行的方案。

而除此以外，还可以在这一行一个车也不放，方案数就是上一行的方案数，即 $f[i-1][j]$ 。

总的转移方程：$f[i][j]=(len \times f[i-1][j-1]) + f[i-1][j]$ 。

因为棋盘缺个角，求解时可以把棋盘拆成两部分，一部分长、宽分别为 $a,\ b$ ，另一部分长、宽分别为 $a + c,\ d$ ，分别递推。

另外，求解前半部分时，要注意如果 $j > a$ 时，表示枚举的部分已经超出这半个矩形的宽了，应当结束循环。

###  Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
const int N = 2e3 + 3, mod = 1e5 + 3;
inline int read() {
    ri x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    return f * x;
}
int f[N][N];
signed main() {
    int a = read(), b = read(), c = read(), d = read(), k = read();
    for (ri i = 0; i <= b + d; i++) f[i][0] = 1; // 每一行不放车的方案有一种
    for (ri i = 1; i <= b; i++)
        for (ri j = 1; j <= k; j++) {
            if (j > a) break; //排除缺的半个角的方案
            (f[i][j] += (a - j + 1) * f[i - 1][j - 1] + f[i - 1][j]) %= mod; //
        }
    for (ri i = b + 1; i <= b + d; i++)
        for (ri j = 1; j <= k; j++)
            (f[i][j] += (a + c - j + 1) * f[i - 1][j - 1] + f[i - 1][j]) %= mod;
    printf("%lld\n", f[b + d][k] % mod);
    return 0;
}

```



---

## 作者：Jayun (赞：6)

# 链接：

[题目](https://www.luogu.com.cn/problem/P1350)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14123638.html)

# 题目大意：

给定一个畸形的方块，求在上面放 $k$ 个车能让它们互不相吃的方案数。

# 正文：

我们知道，车能够吃掉它这一行和一列的棋子，先来处理吃一行的情况。其实这个特别简单，在枚举的时候每一行只算一个棋子的就好了。

再处理列的情况。我们设 $f_{i,j}$ 表示 $i$ 行里一共有 $j$ 个车的方案数。每次处理时，第 $i$ 行就是第 $i-1$ 行的方案数乘上这一行还可以放的位置个数。那么这个位置个数是什么呢？因为前 $i-1$ 行放了 $j-1$ 互不相吃的棋子（也就是每列只有一个车），那如果我们还要在第 $i$ 行放一个，它就只能放在剩下的位置，也就是 $m - (j - 1)$ 个位置，其中的 $m$ 表示第 $i$ 行的格子个数。

也就是说转移方程为：

$$f_{i,j}=f_{i-1,j-1}\times (m-j+1)+f_{i-1,j}$$

后面还加个 $f_{i-1,j}$ 是因为第 $i$ 行还可以不放任何车。

# 代码：

```cpp
	for (int i = 0; i <= b + d; i++) f[i][0] = 1;
	for (int i = 1; i <= b + d; i++)
	{
		for (int j = 1; j <= k; j++)
		{
			if (i <= b && j > a) break;
			f[i][j] += f[i - 1][j];
			if (i <= b) (f[i][j] += f[i - 1][j - 1] * (a - j + 1) % mod) %= mod; 
			else (f[i][j] += f[i - 1][j - 1] * (a + c - j + 1) % mod) %= mod; 
		}
	}
	printf("%d\n", f[b + d][k]);
```

---

## 作者：Durancer (赞：5)

#### 思路

直接根据二维内的公式进行分离并求式子，分成 $a\times (b+d)$ 的和 $c\times d$  的两个矩阵，推出式子

即枚举情况

在第一个举行中放置 $i$ 个小车，并在第二个矩形中放置 $k-i$ 个小车

显然，我们可以用组合数公式求出放置的方案数来，但是并不知道这些车是怎么安排放置的，一个小车可能会出现在不同的位置

简单来说就是虽然要安排的地方是确定的了，但是不知道每一个地方改放那一辆小车，因此有 $i!$ 的个安排的方案，所以也要乘进去

$$\sum_{i=0}^{k}C_{a}^{i}\times C_{b+d-(k-i)}^{i}\times i! \times C_{c}^{k-i} \times C_{d}^{k-i}\times (k-i)!$$

注意此时$0!=1$

为什么要有 $b+d(k-i)$？ 

因为在第二个矩形中肯定已经找完了$(k-i)$行，不能再在第一个矩形里面找了，所以要把这些情况全部减去

至于怎么求出来这个式子

首先阶乘直接边模边乘

至于组合数公式求解

首先根据定义式我们可以将$(n-m)!$全部消去

得出式子

$$\frac{\prod_{i=n-m+1}^{n}i}{m!}\ mod \ p$$

进而求得

$$ \prod_{i=n-m+1}^{n}\times \ m!^{p-2}\ mod\ p$$

用脑力节省码量OVO
#### 代码实现

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<vector>
#define int long long  
using namespace std;
const int mod=1e5+3;
int a,b,c,d,k;
int jc(int k)
{
	if(k==0) return 1;
	int ret=1;
	for(int i=1;i<=k;i++)
		ret=ret*i%mod;
	return ret%mod;
}
int quick(int x,int p)
{
	int ret=1;
	while(p)
	{
		if(p&1) ret=ret*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return ret;
}
int zech(int n,int m)
{
	int fre=1;
	int inv=1;
	for(int i=n-m+1;i<=n;i++)
		fre=fre*i%mod;
	for(int i=1;i<=m;i++)
		inv=inv*i%mod;
	return fre*quick(inv,mod-2)%mod;
}
signed main()
{
	int ans=0;
	scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&k);
	for(int i=0;i<=k;i++)
		ans=(ans+zech(a,i)%mod*zech(b+d-k+i,i)%mod*jc(i)%mod*zech(c,k-i)%mod*zech(d,k-i)%mod*jc(k-i)%mod)%mod; 
	printf("%lld",ans);
	return 0;
} 
```


---

## 作者：doby (赞：5)

为下面那位的机智点赞……

把棋盘切成两块，分别解决，用排列组合分别递推计算……

~~状态转移~~递推式：ans=ans+p(a,i)\*r(b,i)\*p(a+c-i,k-i)\*r(d,k-i)

p(a,i)\*r(b,i)是左上角的方案数，p(a+c-i,k-i)\*r(d,k-i)是下面分出的一块的方案数……

注意放多了的情况……

```cpp
#include<cstdio>
using namespace std;
long long a,b,c,d,k,ans,fc[2009][2009],fp[2009][2009];
long long p(long long m,long long n)//排列
{
    if(fp[m][n]){return fp[m][n];}//记忆化……虽然基本没有重复可能……
    long long s=1;
    for(int i=n;i>=1;i--){s=s%100003*(m-n+i)%100003;}
    fp[m][n]=s;
    return s;
}
long long r(long long m,long long n)//组合
{
    if(m<n){return 0;}//放不下的情况
    if(fc[m][n]){return fc[m][n];}//记忆化
    if(m==n||n==0){fc[m][n]=1;}
    else{fc[m][n]=(r(m-1,n)%100003+r(m-1,n-1)%100003)%100003;}//组合计算
    return fc[m][n];
}
int main()
{
    scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&k);
    for(int i=0;i<=k;i++)
    {
        ans=(ans+p(a,i)%100003*r(b,i)%100003*p(a+c-i,k-i)%100003*r(d,k-i)%100003)%100003;//递推
    }
    printf("%lld",ans);
}
```

---

## 作者：Mr_Li (赞：5)

很显然，我们可以把棋盘分成两个矩形：一个长为a，宽为b；另一个长为a+c，宽为d。设前者为矩形M，后者为N。若M上有x个棋子，则剩下k-x个棋子只能摆在N中的a+c-x行上（请读者自己证明）。设将x个棋子摆在矩形R上的方法有f(x,R)种，则答案即为∑(f(i,M)\*f(a+c-i,N)(0<=i<=k))。至于f(x,R)怎么求呢？设R的长为y，宽为z。则在R中选取x列，在这些列里摆放棋子的方法有P(z,x)（P(s,t)是s个元素中取出t个元素的一个排列）种，由于有C(y,x)（C(s,t)s个不同元素中取出t个元素的一个组合）中选取列的方法，所以f(x,R)=P(z,x)\*C(y,z)，即答案为∑(P(b,i)\*C(a,x)\*P(d,a+c-i)\*C(a+c,x)(0<=i<=k))。求C(x,y) 的时间复杂度为O(xy)，求P(x,y) 的时间复杂度为O(x-y)，两者分别求2k+2次，所以总时间复杂度为O((a+c)k^2)，显然是会超时的。所以我们要先算出C(i,j)(0<=i<=a+c,0<=j<=k)，时间复杂度为O(ak+ck)，总时间复杂度为O(ak+ck)。

附代码：

```cpp

#include<iostream> 
using namespace std;
long long a,b,c,d,k,i,j,f[2001][1001]={},answer; 
long long combination (long long n,long long r)
{
     if (n<r)
     return 0;
     if (f[n][r]>0)
     return f[n][r];
     if (n==r||r==0)
     f[n][r]=1;
     else
     f[n][r]=(combination(n-1,r)+combination(n-1,r-1))%100003;
     return f[n][r];
}
int permutation (int a,int b)
{
    int answer=1;
    for (int i=1;i<=b;i++)
    answer=answer*(a-b+i)%100003;
    return answer;
}
int main ()
{
    cin>>a>>b>>c>>d>>k;
    for (i=0;i<=a+c;i++)
    for (j=0;j<=max(b,d);j++)
    combination(i,j);
    for (i=0;i<=k;i++)
    answer=(answer+permutation(b,i)%100003*f[a][i]%100003*permutation(d,k-i)%100003*f[a+c-i][k-i]%100003)%100003;
    cout<<answer;
    return 0;
}

```

---

## 作者：过往梦魇之殇 (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P1350)

思路：

把矩阵分为上下两块$N$与$M$

令$i∈[0,k]$,且放在$N$中的有$i$辆车 则放在M中有$k-i$辆车

N的长为$a$，宽为$b$

M的长为$a+c$，宽为$d$

在每个矩阵中的放置种类公式如下：

$A^{length}_{car-number}*C^{width}_{car-number}$



------------


证明：

比如对于$N$来说

可以在$a$列中找出$i$列放入车 所以是$A^a_i$

而且有$C^b_i$种选择列的方式

$M$同理，是$A^{a+c-i}_{k-i}*C^d_{k-i}$

注意要一个劲的$mod$，这个点很容易$WA$((((

由此可得 枚举放在$N$和$M$的车有几辆 并计算两个矩阵种类之积即可

$PS:$对于矩阵$M$来说$A$为$A^{a+c-i}_{k-i}$ 而不是$A^{a+c}_{k-i}$，这是因为每排只能放$1$辆而且有$i$辆已经放在$N$中了。

代码展示：（我的代码里$qwq=A,qaq=C$）

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define int long long 
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
const int modd=1e5+3;
const int maxn=2e3+10;
int a,b,c,d,k,ans,awa[maxn][maxn];
int qwq(int x,int y){
	int cnt=1;
	for(re int i=1;i<=y;++i){
		cnt=cnt%modd*(x-y+i)%modd;
	}
	return cnt;
}
int qaq(int x,int y){
	if(awa[x][y]){
		return awa[x][y];
	}
	if(y>x){
		return 0;
	}
	if(x==y||!y){
		awa[x][y]=1;
		return awa[x][y];
	}
	awa[x][y]=(qaq(x-1,y-1)%modd+qaq(x-1,y)%modd)%modd;
	return awa[x][y];
}
signed main()
{
	a=read();
	b=read();
	c=read();
	d=read();
	k=read();
	for(re int i=0;i<=k;++i){
		ans=(ans+qwq(a,i)%modd*qaq(b,i)%modd*qwq(a+c-i,k-i)%modd*qaq(d,k-i)%modd)%modd;
	}
	write(ans);
    return 0;
}
```

###### 制作不易，求资瓷

> Thanks For Watching!

---

## 作者：24680esz (赞：3)

这题我一开始用深搜…………爆了7个点…………

这道题的正解其实是递推。

我们将棋盘分为两个矩形，一个长为a，宽为b；一个长为a+c，宽为d。

我们设置一个i，为第一矩形放置的车数，而第二矩形放置的车数即为k-i辆。

而矩形的放置的方案数为P（长度，车数）\*C（宽度，车数）（道理自己去想）

```cpp
#include <cstdio>
using namespace std;
long long a,b,c,d,k,ans=0,zy[1001][1001];
long long pl(int n,int m)
{
    long long j=1;
    for (int i=m;i;i--) j=j*(n-m+i)%100003;
    return j;
}
long long zh(int n,int m)
{
    if (n<m) return 0;
    if (zy[n][m]) return zy[n][m]%100003;
    if (n==m||!m) zy[n][m]=1; else zy[n][m]=(zh(n-1,m)+zh(n-1,m-1))%100003;
    return zy[n][m]%100003;
}
int main()
{
    scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
    for (long long i=0;i<=k;i++) 
      ans+=pl(a,i)%100003*zh(b,i)%100003*pl(a+c-i,k-i)%100003*zh(d,k-i)%100003,ans%=100003;//递推公式
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Adove (赞：2)

这题可以用排列组合化式子的

我们先把整片棋盘分为三块

我们设左上角的棋盘中有$w_1$个车，左下角的棋盘中有$w_2$个车

那么右下的棋盘中就有$(k-w_1-w_2)$个车

对于左上的棋盘我们有$\frac{a!b!}{(a-w_1)!(b-w_1)!w_1!}$种排列方式

对于左下的棋盘我们有$\frac{(a-w_1)!d!}{(a-w_1-w_2)!(d-w_2)!w_2!}$种排列方式

对于右下的棋盘我们有$\frac{c!(d-w_2)!}{(c-k+w_1+w_2)!(d-k+w_1)!(k-w_1-w_2)!}$种排列方式

那么我们枚举$w_1$和$w_2$就可以了

最后的式子可以约分一下

$$Ans=\sum_{w1=\max(k-d,0)}^{\min(a,b)}\sum_{w2=\max(k-c-w_1,0)}^{\min(a-w1,d)}\frac{a!b!c!d!}{(a-w_1-w_2)!(b-w_1)!(c-k+w_1+w_2)!(d-k+w_1)!w_1!w_2!(k-w_1-w_2)!}$$

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MOD=1e5+3;
const int MAXN=1005;

int a,b,c,d,k,ans;
int inv[MAXN],fac[MAXN];

int getinv(int x){return x==1?1:(long long)(MOD-MOD/x)*getinv(MOD%x)%MOD;}
int slv(int w1,int w2){return (long long)fac[a]*fac[b]*fac[c]%MOD*fac[d]*inv[a-w1-w2]%MOD*inv[b-w1]*inv[c+w1+w2-k]%MOD*inv[d+w1-k]*inv[w1]%MOD*inv[w2]*inv[k-w1-w2]%MOD;}

int main()
{
	scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);fac[0]=1;
	for(int i=1;i<MAXN;++i) fac[i]=(long long)fac[i-1]*i%MOD;
	inv[MAXN-1]=getinv(fac[MAXN-1]);
	for(int i=MAXN-1;i;--i) inv[i-1]=(long long)inv[i]*i%MOD;
	for(int w1=max(k-d,0);w1<=min(a,b);++w1){
		for(int w2=max(k-c-w1,0);w2<=min(a-w1,d);++w2){
			ans=(ans+slv(w1,w2))%MOD;
		}
	}printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Krimson (赞：1)

~~似乎是碾标算了~~  

如果没有右上角的缺口，答案显然是$C^{a+c}_{k}C^{b+d}_{k}k!$。  
前两个组合数分别表示从 $a+c$ 条线段中选 $k$ 条线和从 $b+d$ 条线段中选 $k$ 条线，等价于是求这 $k$ 个车的横坐标与纵坐标的选择方案。  
后面的 $k!$ 则可以看作是固定横坐标，纵坐标的每一种排列都对应着一种不同的合法点集选取方案。  

但是右上角有一个缺口，那么按照二项式反演的套路，设 $g(i)$ 表示右上角至少有 $i$ 个车的方案数，最后的答案就是 $\sum^{k}_{i=0}(-1)^ig(i)$。  
而 $g(i)$ 的求法也非常简单，按照上面的方式，先钦定右上角 $b\times c$ 的矩阵中选了 $i$ 个车，剩下的则可以看作是原矩形分别消去了 $i$ 行 $i$ 列，要从中选择 $k-i$ 个车。  
所以有：  
$$
g(i)=C^{b}_{i}C^{c}_{i}i!\times C^{a+c-i}_{k-i}C^{b+d-i}_{k-i}(k-i)!  
$$  
于是可以用 $O(n+V)$ 的优秀复杂度通过此题，而且代码非常简短。  


_Code_
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define ri register int
#define ll long long
#define ui unsigned int
il ll read(){
	bool f=true;ll x=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=false;ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	if(f) return x;
	return ~(--x);
}
il void write(const ll &x){if(x>9) write(x/10);putchar(x%10+'0');}
il void print(const ll &x) {x<0?putchar('-'),write(~(x-1)):write(x);putchar('\n');}
il ll max(const ll &a,const ll &b){return a>b?a:b;}
il ll min(const ll &a,const ll &b){return a<b?a:b;}
ll a,b,c,d,k,ans;
const ll mod =1e5+3,MAXN=1e5+2;
il ll ksm(ll d,ll tim){
	ll rest=1;
	while(tim){
		if(tim&1) rest=rest*d%mod;
		d=d*d%mod;
		tim>>=1;
	}
	return rest;
}
ll jc[MAXN],inv[MAXN];
void init(int n=MAXN-1){
	jc[0]=1;
	for(ri i=1;i<=n;++i) jc[i]=i*jc[i-1]%mod;
	inv[n]=ksm(jc[n],mod-2);
	for(ri i=n-1;~i;--i) inv[i]=inv[i+1]*(i+1)%mod;
}
il ll C(ll x,ll y){
	if(x<y) return 0;
	return jc[x]*inv[y]%mod*inv[x-y]%mod;
}
ll g[MAXN];
int main(){
	a=read(),b=read(),c=read(),d=read(),k=read();
	init();
	for(ri i=0;i<=k;++i) 
		g[i]=C(b,i)*C(c,i)%mod*jc[i]%mod*C(d+b-i,k-i)%mod*C(a+c-i,k-i)%mod*jc[k-i]%mod;
	for(ri i=0;i<=k;++i){
		if(i&1) ans=(ans-g[i]+mod)%mod;
		else ans=(ans+g[i])%mod;
	}
	print(ans);
	return 0;
}
```

---

## 作者：xsap (赞：1)

- 知识点：组合计数 ~~(小奥计数基础)~~
- 思路：显然不容易直接算，想到可以将原图分为上下两部分，枚举上面有放了多少车(jū),如果放了x个(x ≤ a 且x ≤ b)，那么选法就有$A_{a}^{x} * C_{b}^{x}$。再考虑下面，选法就有$C_{d}^{k - x}*A_{a + c - i}^{k - x}$。相乘即为答案。至于组合数与排列数，随便算即可。
- 代码：

```
# include <iostream>
# include <cstdio>

using namespace std ;

const int mod = 1e5 + 3 ;

int qmi( int a , int b )
{
    int res = 1 ;
    while ( b )
    {
        if ( b & 1 ) res = 1ll * res * a % mod ;
        a = 1ll * a * a % mod ;
        b >>= 1 ;
    }
    return res ;
}

int fact[2005] , infact[2005] ;

void precal()
{
    fact[0] = 1 ;
    infact[0] = 1 ;
    for ( int i = 1 ; i <= 2000 ; i++ )
    {
        fact[i] = ( 1ll * fact[i - 1] * i ) % mod ;
        infact[i] = qmi( fact[i] , mod - 2 ) ;
    }
}

int C( int a , int b )
{
    if ( a > b ) return 0 ;
    return ( 1ll * fact[b] * infact[a] % mod ) * infact[b - a] % mod ;
}

int A( int a , int b )
{
    if ( a > b )
    {
        return 0 ;
    }
    return 1ll * fact[b] * infact[b - a] % mod ;
}

int main()
{
    int a , b , c , d , k ;
    scanf("%d%d%d%d%d" , &a , &b , &c , &d , &k) ;
    precal() ;
    int res = 0 ;
    for ( int i = 0 ; i <= k ; i++ )
    {
        int now = 1 ;
        now = 1ll * now * C( i , b ) % mod ;
        now = 1ll * now * A( i , a ) % mod ;
        now = 1ll * now * C( k - i , d ) % mod ;
        now = 1ll * now * A( k - i , a + c - i ) % mod ;
        res = ( res + now ) % mod ;
    }
    printf("%d\n" , res) ;
    return 0 ;
}
```

---


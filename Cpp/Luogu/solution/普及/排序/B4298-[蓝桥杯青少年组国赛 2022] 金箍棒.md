# [蓝桥杯青少年组国赛 2022] 金箍棒

## 题目背景

为区分各种时间复杂度的做法，本题时间限制下调到 500 毫秒。

## 题目描述

淘气的悟空变出了 $N$ 根高度各不相同的金箍棒（$1 \leq $ 高度 $\leq 1000$），并排列成一排。悟空可以对每根金箍棒施法，让金箍棒高度变短或者变长，但每一次施法只能使一根金箍棒变短 $1$ 个高度或者变长 $1$ 个高度。

现在悟空想通过施法将 $K$（$K \leq N$）根相邻的金箍棒高度变为相同，且要求施法的次数最少，请你帮助悟空计算出最少需要施法几次可以使 $K$ 根相邻的金箍棒高度变为相同。

例如：$N=3$，$K=2$，$3$ 根金箍棒初始高度分别为 $3$、$6$、$1$。

- 第一次对高度为 $3$ 的金箍棒施法变长 $1$ 个高度，变为 $4$；
- 第二次对高度为 $6$ 的金箍棒施法变短 $1$ 个高度，变为 $5$；
- 第三次对高度为 $4$ 的金箍棒施法变长 $1$ 个高度，变为 $5$；

$2$ 根相邻的金箍棒高度变为相同，最少施法 $3$ 次。

## 样例 #1

### 输入

```
3 2
3 6 1```

### 输出

```
3```

# 题解

## 作者：StormWhip (赞：1)

## 思路
对于选定的区间，将其中的所有元素改至它们的中位数时花费最小。于是问题转化成了求每一段长度为 $k$ 的连续区间的中位数，可用平衡树实现。  
这里用到了一种类似于莫队的思路，在已经统计好 $[l,r]$ 的区间后，要统计 $[l+1,r+1]$ 的区间时，只需删去 $a_l$ 并插入 $a_{r+1}$ 即可。
## 代码

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#define int long long
using namespace std;
using namespace __gnu_pbds;
const int N=1e4+5;
int n,k,a[N],ans,mid;
tree <pair<int,int>,null_type,less<pair<int,int> >,rb_tree_tag,tree_order_statistics_node_update> t;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=k;i++) t.insert(make_pair(a[i],i));
	mid=t.find_by_order((k-1)/2)->first;
	for(int i=1;i<=k;i++) ans+=abs(a[i]-mid);
	for(int i=k+1;i<=n;i++)
	{
		t.insert(make_pair(a[i],i));
		t.erase(t.lower_bound(make_pair(a[i-k],i-k)));
		mid=t.find_by_order((k-1)/2)->first;
		int t=0;
		for(int j=i-k+1;j<=i;j++) t+=abs(a[j]-mid);
		ans=min(ans,t); 
	}
	cout<<ans<<"\n";
	return 0;
}

```

---

## 作者：scc36 (赞：1)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4298)
### 思路
其实就是求一个长度为 $k$ 的区间，使得将其中所有数变成一样的改动次数最小。  
当我们选定一个区间后，假设最后变成的数为 $x$，我们要求的就是 $ | x-a_i | + | x-a_{i+1} | + ... +  | x-a_{i+k-1} | $ 的最小值。   
这玩意儿我们很熟悉，当 $x$ 取 $a_i$ 的中位数时，原式就会取到最小。  
于是问题的重心就成了成了求所有含 $k$ 个数的连续区间的中位数。  
尝试了一下对每个区间进行排序再找中位数，发现在第 15 个点和第 20 个点会超时。   

上网搜了一下，发现了一个叫 nth_element 的东东。  
具体见[维基](https://oi-wiki.org/basic/stl-sort/#stdnth_element)。  
简单理解，`nth_element(first, nth, last)` 会重排 `[first, last)` 中的元素，使得 `nth` 所指向的元素被更改为 `[first, last)` 排好序后该位置会出现的元素。这个新的 `nth` 元素前的所有元素小于或等于新的 `nth` 元素后的所有元素。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,i,s,j,a[100001],mi=2e9,b[10001];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(i=1;i<=n;i++) cin>>a[i];
	for(i=1;i<=n-k+1;i++){
		s=0;
		for(j=i;j<=i+k-1;j++) b[j-i+1]=a[j];
		nth_element(b+1,b+(k+1)/2,b+k+1); //更改
		for(j=1;j<=k;j++)
			s+=abs(b[(k+1)/2]-b[j]); //计算插值
		mi=min(mi,s);
	}
	cout<<mi;
}
```

---

## 作者：hxuwna (赞：1)

**[B4298](https://www.luogu.com.cn/problem/B4298)**
## 题意概括
给你 $n$ 个数 $a[i]$ 和 $k$ ，让你求 $\min_{r=k}^{n} \sum_{x=r-k+1}^{r} \lvert a[x]-t \rvert  $，其中 $t$ 为任意实数。
## 分析
首先，我们会发现这个式子是直接暴力求肯定会 T，所以我们先考虑化简。  
对于求 $ \sum_{x=r-k+1}^{r} \lvert a[x]-t \rvert  $ 我们发现它相当于是给你 $k$ 个数，让你求一个数的取值范围，使得这些数减去它的绝对值之和最小。此时，你会发现我们学 whk 时也遇到过这样的题。  

对于这类题目我们一般会画个数轴，但是最后可以归纳出它的规律就是：如果数的个数是奇数，那个数就是这些数的中位数，否则范围就是这些数的中间两个数之间（证明过程就是你对于数轴上的一个数，你考虑它向左或向右移动的贡献）  。

所以题目就化简为求某个长度为 $k$ 的区间，区间中的数减去它们的中位数的绝对值之和。

但是，求一些数减去一个数的绝对值之和直接求（以我的水平）只能想到 $O(n)$ 的做法。但你可以把它去绝对值，变成这个数减去这些数中比它小的数和这些数中比它大的数减去这个数的和。

于是问题便转换为了求区间的某些值域中的数的个数和数的和。

那么区间查询我们就可以用线段树求。

## 具体实现
我们可以用线段树维护一段区间内值域内数的个数和数的和，由于长度固定，我们就可以用单点修改把 $l$ 到 $r$ 的线段树转换为 $l+1$ 到 $r+1$ 的线段树。

每个区间可以用二分得到中位数，线段树区间查询得到代价。时间复杂度就是 $O(nlog^2k)$。

## ma


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N=1e4+5,inf=1e18;
struct SGT{
	struct info{
		int sum,len,num;//sum:和;len:有多少个数;num:这个点上的数,仅用于单点修改
		void set(int x){sum=0,len=0,num=x;}
	}s[N<<2];
	struct tag{
		int add;
		void reset(){add=0;}
	}tg[N<<2];
	info merge(const info &x,const info &y){
		return {x.sum+y.sum,x.len+y.len,0};
	}
//	tag compose(const tag &x,const tag &y){
//	}
	info apply(const info &x,const tag &y){
		return {x.sum+x.num*y.add,x.len+y.add,x.num};
	}
	void pushup(int p){s[p]=merge(s[p<<1],s[p<<1|1]);}
	void maketag(int p,const tag &k){s[p]=apply(s[p],k)/*,tg[p]=compose(tg[p],k)*/;}
//	void pushdown(int p){maketag(p<<1,tg[p]),maketag(p<<1|1,tg[p]),tg[p].reset();}
	void modify(int p,int l,int r,int nl,int nr,const tag &k){
		if(nl<=l&&r<=nr){maketag(p,k);return;}
		int mid=(l+r)>>1;/*pushdown(p);*/
		if(nl<=mid) modify(p<<1,l,mid,nl,nr,k);
		if(nr>mid) modify(p<<1|1,mid+1,r,nl,nr,k);
		pushup(p);
	}
	info ask(int p,int l,int r,int nl,int nr){
		if(nr<1||nl>1000) return {0,0,0};
		if(nl<=l&&r<=nr) return s[p];
		int mid=(l+r)>>1;/*pushdown(p);*/
		if(nr<=mid) return ask(p<<1,l,mid,nl,nr);
		if(nl>mid) return ask(p<<1|1,mid+1,r,nl,nr);
		return merge(ask(p<<1,l,mid,nl,nr),ask(p<<1|1,mid+1,r,nl,nr));
	}
	void build(int p,int l,int r){
		tg[p].reset();
		if(l==r) return s[p].set(l);
		int mid=(l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
		pushup(p);
	}
	info l,r;
}tree;//线段树模板
int n,k,a[N],ans=inf;
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	tree.build(1,1,1000);//由于求的是值域，所以都是1~1000
	for(int i=1;i<=n;i++){
		cin>>a[i];
		tree.modify(1,1,1000,a[i],a[i],{1});
		if(i>k) tree.modify(1,1,1000,a[i-k],a[i-k],{-1});
		if(i>=k){
			int l=1,r=1000,res=0;
			while(l<=r){//二分求中位数
				int mid=l+r>>1;
				int x=tree.ask(1,1,1000,1,mid-1).len,y=tree.ask(1,1,1000,mid+1,1000).len,z=tree.ask(1,1,1000,mid,mid).len;
				if(abs(x-y)<=z){res=mid;break;}
				else if(x<y) l=mid+1;
				else r=mid-1;
			}
			if(res==0) res=l;
			tree.l=tree.ask(1,1,1000,1,res-1),tree.r=tree.ask(1,1,1000,res+1,1000);
			int now=(tree.l.len*res-tree.l.sum)/*得到这个数减去这些数中比它小的数的和*/+(tree.r.sum-tree.r.len*res)/*得到这些数中比它大的数减去这个数的和*/;
			ans=min(ans,now);
		}
	}
	cout<<ans;
	return 0;
}
```
时间 $118ms$ ，目前是（除匿名用户以外的）最优解。  
## 题外话
我看其他人写的都是 $n^2$的暴力加 STL 找中位数或者是枚举中位数和区间的 $O(1000n)$ 暴力 ，代码非常短。我自己测了一遍发现确实能过 。不过反正没人写线段树我就交发题解好了。

---


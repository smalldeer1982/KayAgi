# [语言月赛 202504] 礼堂预约

## 题目描述

小 M 所在的学校有一个礼堂，礼堂里至多能同时进行一个活动，因此需要预约。每个活动占据**某一天**的上午、下午或者晚上。

礼堂负责人**按照时间顺序**接收到了 $n$ 个活动预约，其中第 $i$ 个活动预约描述了活动如下信息：

- 活动类型 $type_i$：一个大写字母，`O` 表示学校官方活动，`C` 表示社团活动，`P` 表示个人活动。
- 活动日期 $date_i$：使用 `YYYYMMDD` 格式表示，例如 `20250411` 表示 $2025$ 年 $4$ 月 $11$ 日。
- 活动时间 $time_i$：一个大写字母，`M` 表示上午，`A` 表示下午，`E` 表示晚上。

负责人每收到一个新的活动预约，会直接加入日程，接下来重复执行如下流程，直到日程里没有冲突：

- 我们规定学校官方活动**优先于**社团活动**优先于**个人活动。如果冲突的两个活动预约类型不同，那么把优先程度更低的活动向后挪一天（活动时间不变）。
- 如果冲突的两个活动类型相同，那么遵循先到先得的原则，把较后预约的活动向后挪一天。
- 注意向后挪动一天可能引发新的冲突，此时对于新冲突的两个活动，仍然按照上述方案调整。

给出这 $n$ 个活动预约的信息，请输出最终每个活动在日程里的活动日期，**按照活动预约的提交顺序输出。**

## 说明/提示

【样例 1 解释】

活动 $1$ 是个人活动，希望在 $2025$ 年 $4$ 月 $19$ 日下午进行，没有冲突。

活动 $2$ 是官方活动，希望在 $2025$ 年 $4$ 月 $19$ 日下午进行，和活动 $1$ 冲突。因此，活动 $1$ 被修改到 $4$ 月 $20$ 日下午。

活动 $3$ 是社团活动，希望在 $2025$ 年 $4$ 月 $19$ 日下午进行，和活动 $2$ 冲突。

- 由于活动 $2$ 是官方活动，所以把活动 $3$ 延后一天到 $4$ 月 $20$ 日下午。
- 然而现在活动 $3$ 和活动 $1$ 冲突，而活动 $1$ 优先程度更低，所以活动 $1$ 被修改到 $4$ 月 $21$ 日下午。

活动 $4$ 是社团活动，希望在 $2025$ 年 $4$ 月 $19$ 日晚上进行，没有冲突。

活动 $5$ 是社团活动，希望在 $2025$ 年 $4$ 月 $20$ 日下午进行，和活动 $3$ 冲突。

- 由于活动 $3,5$ 都是社团活动，按照先到先得原则，把活动 $5$ 延后到 $2025$ 年 $4$ 月 $21$ 日下午。
- 现在活动 $5$ 和活动 $1$ 冲突，所以把活动 $1$ 延后到 $2025$ 年 $4$ 月 $22$ 日。

【样例 2 解释】

注意日期的计算。

【样例 3 解释】

按照收到活动预约的时间给出，不代表活动预约按照 $date_i$ 排序。

【数据范围】

对于全部数据，保证 $1\le n\le 5000$，$type_i$ 一定是 `O`、`C`、`P` 之一，$time_i$ 一定是 `M`，`A`，`E` 之一，$date_i$ 一定是 $2000$ 年 $1$ 月 $1$ 日到 $2099$ 年 $12$ 月 $31$ 日之间、真实存在的日期。（注意并不保证最终的日期在这个范围内。）

本题共有 $10$ 个测试点，每个 $10$ 分。部分测试点有特殊性质，具体如下：

|测试点编号|$n\le$|特殊性质 A|特殊性质 B|
|:-:|:-:|:-:|:-:|
|$1,2$|$500$|保证|保证|
|$3$|$500$|不保证|保证|
|$4$|$500$|保证|不保证|
|$5,6$|$500$|不保证|不保证|
|$7$|$5000$|保证|保证|
|$8,9,10$|$5000$|不保证|不保证|

- 特殊性质 A：每个活动的最终日期和预约日期在同一个月内（例如样例 1）。
- 特殊性质 B：每个活动预约仅产生至多一次冲突，不会连续冲突（例如样例 2）。



## 样例 #1

### 输入

```
5
P 20250419 A
O 20250419 A
C 20250419 A
C 20250419 E
C 20250420 A
```

### 输出

```
20250422
20250419
20250420
20250419
20250421
```

## 样例 #2

### 输入

```
6
P 20280228 M
P 20280228 M
P 20290228 A
P 20290228 A
P 20991231 E
P 20991231 E
```

### 输出

```
20280228
20280229
20290228
20290301
20991231
21000101
```

## 样例 #3

### 输入

```
5
C 20250419 E
C 20250420 A
P 20250419 A
O 20250419 A
C 20250419 A
```

### 输出

```
20250419
20250420
20250422
20250419
20250421
```

# 题解

## 作者：yummy (赞：4)

本题考察日期计算和简单排序算法，对选手的阅读能力、分析能力、代码能力都有比较高的要求。如果选手没有采用合适的写法，可能会导致代码量增大。

---

首先，我们需要一个函数，计算当前日期，对应的第二天日期。因为这个过程涉及到数字加法，所以我推荐使用 `int` 存储，这样八位数 $dt$ 对应的年、月、日就分别是 `y=dt%10000,m=dt/100%100,d=dt%100`。

为了计算 $y$ 年 $m$ 月的天数 $maxd$，我们可以用一个数组记录平年 $12$ 个月的天数；然后如果是闰年 $2$ 月，再额外加一天即可。

算好上述变量后，第二天可以按照如下流程计算：

- 通常情况下，$y$ 年 $m$ 月 $d$ 日的第二天是 $y$ 年 $m$ 月 $d+1$ 日。
- 但如果 $d+1>maxd$，那么答案是 $y$ 年 $m+1$ 月 $1$ 日。
- 如果此时 $m+1$ 是 $13$，那么就要变成 $y+1$ 年 $1$ 月。

该部分的代码如下：

```cpp
int days[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int tomorrow(int dt){
	int y=dt/10000,m=dt/100%100,d=dt%100;
	int maxd=days[m];
	if(m==2 && (y%4==0 && y%100!=0 || y%400==0))
		maxd=29;
	d++;
	if(d>maxd){
		d=1;
		m++;
	}
	if(m==13){
		m=1;
		y++;
	}
	return y*10000+m*100+d;
}
```

下一步我们考虑日程表的维护。预约在早上的活动最后一定在早上，下午、晚上类似，因此**早上、下午、晚上是平行而独立的三个日程表**，直接加一维数组，$0$ 表示早上，$1$ 表示下午，$2$ 表示晚上即可。

为了更方便地比较活动类型的优先程度，可以规定 `O,C,P` 分别对应数字 $0,1,2$，这样，发生冲突时，类型更大的活动时间会被修改。

为了更方便地查找冲突的活动，我们可以规定日程表里所有活动按照举办时间的先后排序。具体地，$act(tme,i)$ 表示 $tme$ 时间（$0,1,2$ 之一）、第 $i$ 个举办的活动**编号**，而 $cact(tme)$ 表示时间 $tme$ 的活动个数。

```cpp
int n,date[5005];
int type[5005];//0=O, 1=C, 2=P
int act[3][5005],cact[3];// 0=M, 1=A, 2=E
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s>>date[i];
		
		if(s[0]=='O')type[i]=0;
		else if(s[0]=='C')type[i]=1;
		else type[i]=2;
		
		cin>>s;
		int tme;
		if(s[0]=='M')tme=0;
		else if(s[0]=='A')tme=1;
		else tme=2;
        
        //插入新活动部分的代码，具体实现在下文提到
    }
	for(int i=1;i<=n;i++)
		printf("%d\n",date[i]);
	return 0;
}
```

每次加入新活动时，使用类似插入排序的做法就可以保持数组的有序，具体地，假设要把编号 `to_arr` 的活动插入日程表，那么用一重循环 $j$ 从 $1$ 枚举到 $cact(tme)$：

- 如果 $date_i > date_{act(tme,j)}$，表示 $i$ 的插入点在第 $j$ 个活动之后，不需要处理。
- 如果 $date_i<date_{act(tme,j)}$，那么 $i$ 应该**插入在第 $j$ 个活动之前**，换言之 $i$ 成为了第 $j$ 个活动，而原来第 $j$ 个活动成了需要插入的活动，代码中体现为 `swap(act[tme][j],to_arr)`。
- 如果二者相等，那么发生了一次冲突。此时比较二者谁的“权力”更大，如果 $i$ 的“权力“更大，就把 $act(tme,j)$ 这个活动**从日程中拉出来（变成需要插入的活动）**天数 $+1$，然后自己进去；否则自己天数 $+1$。

最后肯定剩下一个尚未插入的活动，直接安排到末尾即可。

```cpp
		int to_arr=i;
		for(int j=1;j<=cact[tme];j++){
			int target=act[tme][j];//尝试把 to_arr 插入 target 所在位置
			if(date[target]==date[to_arr]){//活动撞了
				if(type[target]>type[to_arr] || type[target]==type[to_arr] && target>to_arr){
					//to_arr 权力更大，从 target 位置拉下来
					swap(act[tme][j],to_arr);
				}
				date[to_arr]=tomorrow(date[to_arr]);
			}
			else if(date[target]>date[to_arr])//正常插入排序
				swap(act[tme][j],to_arr);
		}
		cact[tme]++;
		act[tme][cact[tme]]=to_arr;
```

---


# 可达性统计

## 题目描述

给定一张 $N$ 个点 $M$ 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。

## 说明/提示

测试数据满足 $1 \le N,M \le 30000$，$1 \le x,y \le N$。

## 样例 #1

### 输入

```
10 10
3 8
2 3
2 5
5 9
5 9
2 3
3 9
4 8
2 10
4 9```

### 输出

```
1
6
3
3
2
1
1
1
1
1```

# 题解

## 作者：Atserckcn (赞：14)

## [P10480 可达性统计](https://www.luogu.com.cn/problem/P10480) 题解

### 题目简述：

给定一个 $N$ 个点，$M$ 条边的**有向无环图**，统计从每个点出发所能经过的最多点数。

### 思路简述：

由于是有向无环图，我们不难想到用拓扑排序进行求解。当然你不用拓扑排序，暴力也是可以的，下文会提到。然而拓扑排序预处理完后，我们需要怎么统计呢？

这时候，我们就需要用到一个特殊的容器——`bitset`！！

`bitset` 简述：

`bitset` 可以看作是一个数组，但是它仅存真伪值（即 `bool`）。

因为 `bitset` 过于冷门，下面是它的用法介绍（[更详细的在这里](https://oiwiki.org/lang/csl/bitset/#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0)）：

定义一个 `bitset` 型数组 `f[MAXN]`：

```cpp
bitset<MAXN> f[MAXN];//对，和vector或queue差不多
```

查看某个 `bitset` 变量的 `true` 的数量：

```cpp
f[i].count();
```

至于其他的运算情况，跟普通的变量差不多，不予阐述。

好啦，上述成员函数已经够您做完这道题了，继续看思路吧。

### 具体实施方案：

将所有点的入度统计下来，依次从入度的小到大遍历每个点，计算入度，然后遍历每个点。因为能够遍历的点的数量一定是递增的，所以我们赋值可以用到**或运算**，即前面访问过的，将其延续下来，需要用到状态压缩的基础知识。

核心代码：

```cpp
void dfs(int u)//以u为出发点
{
	if(book[u]) return;//已经访问过啦
	book[u]=true;
	for(int i=head[u];i;i=edge[i].pre)//链式前向星遍历
	{
		dfs(edge[i].to);
		f[u]|=f[edge[i].to];//看清楚，是|=
	}
	return;
}
```

### 具体代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int MAXN=30005;
bitset<MAXN> f[MAXN];
struct EDGE{//结构体存图
	int from,to,pre;
}edge[MAXN];
bool book[MAXN];
int u,v,cnt,head[MAXN],t;
queue<int> q;//用于拓扑排序
int in[MAXN];
void add(int from,int to)//加边
{
	edge[++cnt].from=from;
	edge[cnt].to=to;
	edge[cnt].pre=head[from];
	head[from]=cnt;
	return;
}
void dfs(int u)//核心代码，上述
{
	if(book[u]) return;
	book[u]=true;
	for(int i=head[u];i;i=edge[i].pre)
	{
		dfs(edge[i].to);
		f[u]|=f[edge[i].to];
	}
	return;
}
vector<int > num;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) f[i][i]=true;//初始化不能漏！
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		in[v]++;//入度+1
		add(u,v);
	}
	for(int i=1;i<=n;i++)//拓扑排序基础流程
		if(!in[i])
			q.push(i),num.push_back(i);
	while(!q.empty())
	{
		t=q.front();
		q.pop();
		for(int i=head[t];i;i=edge[i].pre)//遍历每条连边
		{
			if(--in[edge[i].to]<=0)//加入队列
			{
				q.push(edge[i].to);
				num.push_back(edge[i].to);
			}
		}
	}
	for(auto i:num)//遍历num
		dfs(i);
	for(int i=1;i<=n;i++)
		printf("%d\n",f[i].count());
	return 0;
}
```

当然，你不用拓扑排序，直接朴素算法，也是没问题的，如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int MAXN=30005;
bitset<MAXN> f[MAXN];
struct EDGE{
	int from,to,pre;
}edge[MAXN];
bool book[MAXN];
int u,v,cnt,head[MAXN];
void add(int from,int to)
{
	edge[++cnt].from=from;
	edge[cnt].to=to;
	edge[cnt].pre=head[from];
	head[from]=cnt;
	return;
}
void dfs(int u)
{
	if(book[u]) return;
	book[u]=true;
	for(int i=head[u];i;i=edge[i].pre)
	{
		dfs(edge[i].to);
		f[u]|=f[edge[i].to];
	}
	return;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) f[i][i]=true;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	{
		dfs(i);
		printf("%d\n",f[i].count());
	}
	return 0;
}
```

~~对，我太懒了，就是改了改，没重写。~~

**[拓扑排序方法 AC 记录](https://www.luogu.com.cn/record/161773021)**

**[朴素算法 AC 记录](https://www.luogu.com.cn/record/161770799)**

---

## 作者：YuzhenQin (赞：9)

## 题意

给定一张 $N$ 个点 $M$ 条边的**有向无环图**，分别统计**从每个点出发能够到达的点的数量**。$1 \le N, M \le 30, 000$。

## 做法

对于每一个点进行 DFS 搜索。使用 `std::bitset` 记录能够到达的点。当搜索到一个点时，如果已经被搜索过，直接按位或该点能够到达的点的 `bitset`。最终使用 `bitset::count()` 统计能够到达的点。

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;

bitset<30001> f[30001];
vector<int> e[30001];
bool vis[30001];

void dfs(int u) {
	if(vis[u]) return;
	vis[u] = true;
	
	for(int v : e[u]) {
		dfs(v);
		f[u] |= f[v];
	}
}

int main(void) {
	int n, m;
	cin >> n >> m;
	
	for(int i = 1; i <= n; i++)
		f[i][i] = 1;
		
	for(int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y); 
	}
	
	for(int i = 1; i <= n; i++) {
		dfs(i);
		cout << f[i].count() << endl; 
	}
	
	return 0;
}
```

---

## 作者：D23lhc (赞：8)

## 分析

这个题目比较简单，但是数据量大，普通的存图方法会存不下，因此我们要变换思路，直接求结果。我们可以根据拓扑排序来倒推结果，拓扑排序的最后一个点，把他的值设为 $1$。用 bitseet 容器存每个点的下一个邻接点，是邻接的那一位即为 $1$，否则为零，$1$ 的个数既是答案，将答案进行或操作可以得到上一个点的答案。

# 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N=3e4+5;
struct node{
	int to,next; 
}edge[N];
int head[N],idx;
void  addedge(int u,int v){ //链式前向星 
	edge[++idx].to=v;
	edge[idx].next=head[u];
	head[u]=idx;
}
bitset<N> f[N]; //bitset容器 
int du[N],res[N],cnt;  
int n,m;
void topsort(){ // 拓扑排序 
	queue<int> q;
	for(int i=1;i<=n;i++){ // 将度为零的点加入队列 
		if(!du[i]){
			q.push(i);
		}
	}
	while(!q.empty()){
		int u=q.front(); // 删除队首元素 
		q.pop();
		res[cnt++]=u;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].to; 
			if(--du[v]==0){ // 删除队首元素相邻边 
				q.push(v); // 度为零再加入队列 
			}
		}
	}
}
int main()
{
	int a,b;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		cin>>a>>b;
		addedge(a,b);
		du[b]++;
	}
	topsort();
	for(int i=cnt;~i;i--){ //根据拓扑排序从后往前推 
		int j=res[i];
		f[j][j]=1;
		for(int k=head[j];k;k=edge[k].next){
			int v=edge[k].to;
			f[j]|=f[v];
		}
	}
	//每个bitset里1的个数就是答案 
	for(int i=1;i<=n;i++) cout<< f[i].count() <<endl;
	return 0;
}
//引用CSDN
```

---

## 作者：cyhyeee (赞：4)

## 题解：P10480 可达性统计
[题目传送门](https://www.luogu.com.cn/problem/P10480)

- 由题意可得：第一行两个整数 $N,M$，接下来 $M$ 行每行两个整数 $x,y$，表示从 $x$ 到 $y$ 的一条有向边。所以我们可以用一个数组来记录 $x$ 指向 $y$。

在本题中，用朴素的方法会超时，所以要用 `bitset`，因为 `bitset` 的操作很快。枚举 $1$ 至 $N$ 如果当前点还没有统计，则进行 `dfs`。在 `dfs` 中，如果当前点被统计过了，就 `return`，否则将 $f[u][u]$ 设为 $1$。$f$ 是 `bitset` 数组，$u$ 是当前节点。接着遍历 $u$ 指向的节点，再次 `dfs` 即可。`dfs` 完之后，要 $f_u|=f_{e[u][i]}$，更新当前节点的值。

总结：这道题的思想是用 `bitset` 来保存每个点能够到达的点的数量。最后用 `bitset` 中的 `f.count()` 来输出答案.

#### code：
```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define re register
using namespace std;
int n,m;
int x,y,ans;
vector<int>e[30005];
bitset<30005>fa[30005];
void dfs(int u){
	if(fa[u].count()) return;
	fa[u][u]=1;
	for (re int i=0;i<e[u].size();i++){
		dfs(e[u][i]);
		fa[u]|=fa[e[u][i]];
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for (re int i=0;i<m;i++){
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
	}
	for (re int i=1;i<=n;i++)
		if(!fa[i].count())dfs(i);
	for(int i=1;i<=n;i++) printf("%d\n",fa[i].count());
	return 0;
}
```

---

## 作者：cmrhhh (赞：3)

## [P10480 可达性统计](https://www.luogu.com.cn/problem/P10480)
# 题意
略
# 解法
对于这张 `DAG` ，用 `DP` 状压存储每个点能否到其他点，考虑拓扑排序，从入度大的开始更新，逐步朝入度小的更新，记得使用 ` bitset` 。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=3e4+10;
int n,m,head[MAXN+10],tot,in[MAXN+10];
struct Edge{
	int to,nxt;
}edge[MAXN+10];
bitset<MAXN+10>f[MAXN+10];
void add(int u,int v){
	edge[++tot]=(Edge){v,head[u]};
	head[u]=tot;
}
queue<int>q;
int a[MAXN+10],atot=0;
int main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;int u,v;
	for(int i=1;i<=m;++i){
		cin>>u>>v;
		add(u,v);
		in[v]++;
	}
	for(int i=1;i<=n;++i)if(!in[i])q.push(i),a[++atot]=i;
	while(q.size()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].to;
			in[v]--;
			if(!in[v])q.push(v),a[++atot]=v;
		}
	}
	for(int i=n;i>=1;--i){
		int u=a[i];
		f[u][u]=1;
		for(int j=head[u];j;j=edge[j].nxt)f[u]|=f[edge[j].to];
	}
	for(int i=1;i<=n;++i)cout<<f[i].count()<<"\n";
	return 0;
}
```

---

## 作者：SinkingLightStar (赞：3)

### 0x00 闲话

没有！

---

### 0x01 前置芝士

- bitset

- 深度优先搜索

---

### 0x02 算法实现

如果用暴力搜索统计，时间复杂度将达到 $\mathcal O(n^{2})$ 所以不行。

考虑 `bitset` 优化，空间可以优化，而标记时间从 $\mathcal O(n)$ 降低到 $\mathcal O(\frac{n}{w})$ 于是满分了。

---

### 0x03 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,v[30009];
vector<int> g[30009];
bitset<30009> p[30009];
void dfs(int x)
{
	v[x]=1;
	p[x][x]=1;
	if(g[x].size()==0) return ;
	for(int i:g[x])
	{
		if(!v[i]) dfs(i);
		p[x]|=p[i];
	}
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		g[x].push_back(y);
	}
	for(int i=1;i<=n;i++)
	{
		if(!v[i]) dfs(i);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<p[i].count()<<'\n';
	}
	return 0;
}
```

---

## 作者：__Sky__Dream__ (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P10480)

## 解题思路（超详细）
### 解法一：拓扑序加动态规划
1. 按照什么顺序来更新呢？

注意到该图是有向无环图，那么其中的节点就满足拓扑序。

对于拓扑序列来说，前面的点一定会指向后面的点。所以我们可以从后往前处理，对于遍历到点 $x$，其指向的节点的可达点就已经固定了。于是当前点 $x$ 的可达点就是指向节点的所有可达点。

最后要求是以每个点为起点的到达点个数，从后往前转移，要反向更新，反向建边。

2. 如何记录状态？

不能直接将子节点的可达点个数相加，因为子节点间的可达点可能有重复。对于重复的元素只取一个，我们可以想到或操作。

注意：**一个点可到达点的数量等于其指向的点的所有可达点取或。**

可以将每个点的所有可达点进行状态压缩，用二进制中的 $0$ 和 $1$ 表示对于一个点可不可达。可达为 $1$，否则为 $0$。

为了方便操作，这里采用 STL 中的 `bitset` 来存储这个二进制。

从后往前遍历拓扑序列，对于当前位置 $x$，其可达点状态压缩对应二进制 $f_x$ 就可以直接和其所指向节点所对应的二进制 $f_{tx}$ 直接取或。

**Code：**
```cpp
//c++20
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
map<int,int> mp;
const int N=30010;
int T,n,m,k;
int a[N],ru[N];
vector<int> e[N];
bitset<N> f[N];
void topsort()
{
	queue<int> que;
	for(int i=1;i<=n;i++) if(!ru[i]) que.push(i);
	while(que.size())
	{
		int x=que.front();
		que.pop();
		f[x][x] = 1;
		for(auto tx:e[x])
		{
			f[tx]|=f[x];
			ru[tx]--;
			if(ru[tx]==0) que.push(tx);
		}
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	while(m--)
	{
		int x,y;cin>>x>>y;
		e[y].pb(x);
		ru[x]++;
	}
	topsort();
	for(int i=1;i<=n;i++) cout<<f[i].count()<<"\n";
	return 0;
}
```

### 解法二：记忆化搜索
因为是求每个点作为起点能够到达的点数，所以就从每个点出发，向外走，由起点往外更新。那么用记忆化搜索就要正常建边。

由此可见：

一般记忆化搜索是正常从前往后走，正常建边；

而拓扑序加动态规划却是将后面点的处理完毕之后，再用后面的状态更新前面状态。那么，拓扑序加动态规划的做法一般就要反向建边。

**步骤：**

从一点 $x$ 出发：

- 如果走到一个点 $tx$ 发现之前没有走过，那么从这个点递归，返回来的结果就是从这个点出发的答案。

- 否则，该位置已经存储了从该点 $tx$ 出发的答案，直接用即可。不需要继续递归。

- 将当前点 $x$ 更新，传回从当前点出发的答案。

**Code：**
```cpp
//c++20
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
map<int,int> mp;
const int N=30010;
int T,n,m,k;
int a[N];
vector<int> e[N];
bitset<N> f[N];
bitset<N> dfs(int x)
{
	f[x][x] = 1;
	for(auto tx:e[x])
	{
		if(f[tx].count()) f[x] |= f[tx];
		else f[x]|=dfs(tx);
	}
	return f[x];
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	while(m--)
	{
		int x,y;cin>>x>>y;
		e[x].pb(y);
	}
	for(int i=1;i<=n;i++)
		if(!f[i].count()) dfs(i); //保证每个点都要走过
	for(int i=1;i<=n;i++) cout<<f[i].count()<<endl;
	return 0;
}
```

完结撒花！

---

## 作者：ttq012 (赞：2)

首先你可以有向图缩点成 DAG 然后跑一遍拓扑排序求答案，但是这个题目有更简单的做法。

发现 $n\le 30000$，因此考虑 $O(\frac{n^2}{\omega})$ 级别的算法。设 $F_i$ 表示 $i$ 点所有可以到达的位置的点的集合，很显然 $F_i=\lbrace i,F_{j_1},F_{j_2},\ldots,F_{j_k}\rbrace$，其中 $\lbrace j_1,j_2,j_3,\ldots,j_k\rbrace=G_i$，$G_i$ 表示的是 $i$ 点所有的出边能够到达的点的集合。

直接一遍深搜即可。时间复杂度为 $O(\frac{n^2}{\omega})$。

```cpp
bitset<30010> fat[30010];
void dfs(int u) {
    if (!fat[u].count()) {
        fat[u][u] = 1;
        W(z, j, u) {
            dfs(j);
            fat[u] |= fat[j];
        }
    }
}
void $() {
    int n, m;
    cin >> n >> m;
    F(i, 1, m) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        ed[i] = {u, v};
    }
    F(i, 1, n) {
        if (!fat[i].count()) {
            dfs(i);
        }
    }
    F(i, 1, n) {
        cout << fat[i].count() << '\n';
    }
}

signed main() { $(); }
```

---

## 作者：qw1234321 (赞：1)

bitset + 记搜.

- 结论：假设 $u,v$ 之间有边，则 $v$ 能到的点 $u$ 一定能到。

（这要证吗）。

所以从 $1$ 开始遍历每个能到的点，加上这些点能到的点的个数即可。

但是，这样做会 T。

于是想到可以用神器 bitset 存储记忆化的值。

然后就结束了。

code：

```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define rg register
using namespace std;

const int N = 3e4 + 5;
vector<int> g[N];
bitset<N> f[N];
int n, m, x, y, res;
bool vis[N];

bitset<N> dfs(int u){
	if (vis[u]) return f[u];
	vis[u] = 1;
	f[u][u] = 1;
	for (int v : g[u]) f[u] |= dfs(v);
	return f[u];
}

signed main(){
	scanf("%lld %lld", &n, &m);
	for (rg int i = 1; i <= m; i++){
		scanf("%lld %lld", &x, &y);
		if (x == y) continue;
		g[x].push_back(y);
	}
	for (rg int i = 1; i <= n; i++) cout << dfs(i).count() << "\n";
	return 0;
}
```

---

## 作者：2huk (赞：0)

我们用 bitset 存储每个点可以到达的点的集合。那么我们可以用其 `count()` 函数计算答案。

对于一个点 $u$，我们考虑它的所有出边 $(u \to v_i)$。若这些 $v_i$ 的 bitset 答案已经计算好了，那么将这些 bitset 按位或起来，并将 $u$ 的位置也设为 $1$，就是 $u$ 的 bitset 答案。

---


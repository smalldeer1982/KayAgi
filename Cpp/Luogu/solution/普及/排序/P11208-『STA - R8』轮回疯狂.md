# 『STA - R8』轮回疯狂

## 题目描述

给一个 $1$ 到 $n$ 的排列 $p$，你可以使用两种操作：
- 轮回：交换 $p$ 中相邻的两个位置。
- 疯狂：删除 $p$ 中的最小值。如果 $p$ 为空则不能进行操作。

问最少需要多少次操作才能使得序列单调递增。

## 说明/提示

样例解释：先删除 $p_3$，再交换 $p_1,p_2$。

***
**本题采用捆绑测试。**

数据范围：
- Subtask 1 (10pts)：$n\le 3$。
- Subtask 2 (30pts)：$n\le 10^3$。
- Subtask 3 (10pts)：$p_i=n-i+1$。
- Subtask 4 (50pts)：无特殊限制。


对于全部数据，$1\le n\le 10^5$，$p$ 是 $1$ 到 $n$ 的排列。

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
2```

# 题解

## 作者：K8He (赞：12)

这里是 checker 题解。

赛后 UPD：虽然树状数组本来就是要放过去的但是你们怎么都写这个，急眼了。

首先我们知道只有一操作答案是逆序对数。

考虑二操作，注意到存在一种方案是将前 $n - 1$ 个数都删了，所以答案不会超过 $n - 1$，进一步得知最优方案交换次数不超过 $n - 1$。

尝试利用这个上界做一些暴力。直接进行二操作的话，每次操作后序列的交换次数不增，没有什么好的性质。不过如果倒过来进行二操作，依次加当前还没有加的最大值（加入后是序列的最小值），每次操作后序列的交换次数是不降的，然后如果直接暴力插入排序求解，可以在交换次数超过 $n - 1$ 后直接跳出，因为之后一定是更劣解。当然交换次数超过答案就跳了也对因为答案肯定不大于 $n - 1$。

时间复杂度是 $O(n)$，因为插入排序交换操作只会进行 $O(n)$ 次。

```cpp
#include <bits/stdc++.h>
#define _for(i, a, b) for (int i = a; i <= b; ++i)
#define for_(i, a, b) for (int i = a; i >= b; --i)
#define far(i, vec) for (auto i : vec)
#define bdmd int mid = (l + r) >> 1
typedef long double ldb;
typedef long long ll;
typedef double db;
typedef std::pair <int, int> pii;
typedef std::pair <ll, ll> pll;
const int N = 1e5 + 10, P = 998244353;
namespace IO {
	int rnt () {
		int x = 0, w = 1; char c = getchar ();
		while (!isdigit (c)) { if (c == '-') w = -1; c = getchar (); }
		while (isdigit (c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar ();
		return x * w;
	}
}
namespace SOLVE {
	using namespace IO;
	int n, a[N], p[N], b[N], ans;
	void In () {
		n = rnt ();
		_for (i, 1, n) p[a[i] = rnt ()] = i;
		return;
	}
	void Solve () {
		ans = n;
		int S = 0, m = 0;
		for_ (i, n, 1) {
			b[++m] = p[i];
			for_ (j, m, 2) {
				if (b[j] < b[j - 1])
					break;
				std::swap (b[j], b[j - 1]);
				++S;
			}
			if (S > n) break;
			ans = std::min (ans, S + i - 1);
		}
		return;
	}
	void Out () {
		printf ("%d\n", ans);
		return;
	}
}
int main () {
#ifndef ONLINE_JUDGE
	freopen ("data.in", "r", stdin);
	// freopen ("data.out", "w", stdout);
#endif
	SOLVE::In ();
	SOLVE::Solve ();
	SOLVE::Out ();
	return 0;
} /*

*/
```

---

## 作者：Brilliant11001 (赞：8)

[更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18493608)

## [题目传送门](https://www.luogu.com.cn/problem/P11208)

将题意转化一下：将序列变为单调上升等价于**逆序对总数量为 $0$。**

首先看到交换相邻两个数，立马反应过来这种操作最好情况会使逆序对总数减一。

为什么呢？

首先肯定要前面大于后面才交换，否则一定不优。

假设前为 $i$，后为 $j$，钦定我们计算逆序对的方式是从后往前，依次看每个数后方有多少个小于它的数，并假设 $i$ 产生的逆序对个数是 $b_i$，$j$ 产生 $b_j$，那么交换后，根据逆序对的定义，$i$ 前方和 $j$ 后方的逆序对数都不会改变，$i$ 的逆序对数减一，$j$ 不变。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/q0otq188.png)

其次发现操作 $2$ 是个非常硬核的操作：最多操作 $n - 1$ 次该序列就必定单调递增（毕竟删得只剩一个数了）。

那么可以先设立一个操作次数的上界：$n - 1$。

然后，来考虑两种操作结合的情况。

首先不难发现，删除一个数对它后面数的逆序对数不会造成影响，只会将它前面且大于它的数的逆序对数减一，又由于每次只能删除最小的数，所以相当于对所有前面存在的数都要减一。

所以思路就很明了了：建立两个树状数组，一个用来维护逆序对数量，一个用来维护前缀剩下的数的个数，枚举删除那些数然后依次更新答案即可。

（可能只有我傻到去写两个树状数组吧）

$\texttt{Code:}$

```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int a[N], pos[N];
int invension[N];
//invension[i] 表示第 $i$ 个位置产生多少个逆序对
struct BIT{
    int c[N];
    #define lowbit(x) (x & -x)
    inline void add(int x, int v) {
        for(; x <= n; x += lowbit(x)) c[x] += v;
    }
    inline int ask(int x) {
        int res = 0;
        for(; x; x -= lowbit(x)) res += c[x];
        return res;
    }
}tr1, tr2; //封装数据结构
//tr1 维护逆序对，tr2 维护前缀和

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        pos[a[i]] = i; //记录每个数出现在哪个位置
    }
    long long sum = 0;
    //计算逆序对
    for(int i = n; i; i--) {
        invension[i] = tr1.ask(a[i] - 1);
        sum += invension[i];
        tr1.add(a[i], 1);
    }
    long long ans = min(sum, (long long)n - 1);
    //枚举删除哪些数
    for(int i = 1; i <= n; i++)
        tr2.add(i, 1); //一开始每个位置上都有数
    for(int i = 1; i < n; i++) {
        int cnt = tr2.ask(pos[i] - 1);
        sum -= cnt;
        ans = min(ans, (long long)sum + i);
        tr2.add(pos[i], -1); //删掉后这个位置上就没有数了
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：Exp10re (赞：8)

## 前言

 _我称之为叠甲。_ 

本文为非标准解法。

阅读本篇题解需要以下知识储备：

- 线段树，主席树，树状数组。
- 树套树基础。

阅读本篇题解不需要以下物品：

- 大脑。

## 正文

让我们设想一个情景：

你是一个数据结构魔怔人，写题直接把一堆数据结构往上套套套，然后卡常卡常卡常，几乎不动脑子。

就在这场比赛开始的那一天早上，你花了 $eps$ 秒调出了 [P3157 [CQOI2011] 动态逆序对](https://www.luogu.com.cn/problem/P3157)，然后在赛场上看到了这道题，这时你会：

1：动用你由于天天魔怔数据结构已经几近退化的大脑，去思考这道题的正解。  
2：考虑早上调出来的题目，然后：

## 解题思路

 _或许我们应该把这个称为贺题思路。_ 

你发现这道题的一个性质：若我们移动当前的最小值，一定不如将其删掉优，由此可以得到另外一个性质：所有删除操作在交换操作之前一定不劣。

因此你决定枚举——是的，这就是你天天魔怔数据结构的大脑想到的最优解法——枚举删除操作的次数，然后逐个计算逆序对数量。

逐个删除，需要维护逆序对……一段 [记忆碎片](https://www.luogu.com.cn/paste/beo01pnf) 在你脑海中闪过，你发现这一部分就是今早写出来的 [P3157 [CQOI2011] 动态逆序对](https://www.luogu.com.cn/problem/P3157)。

于是，你复制了那一题你的提交记录，然后将每一次修改操作改为删除 $i$，将当前答案记为了 $ans_i$，然后，你惊喜的发现，这道题的答案呼之欲出，那当然是：

$$Ans=\min\limits_{i=0}^{n} i+ans_i$$

你发现这份代码的时间复杂度为 $O(n\log^2 n)$ 于是，你经过了简单的卡常之后，等待了一个合适的评测机波动提交了这一题，这份代码理所应当的通过了这道题目，正如今早一样，线段树也是一如既往的可爱。

[Code.](https://www.luogu.com.cn/paste/yqrezb44)

---

## 作者：Lysea (赞：6)

### Solution

整个世界恐怕只有这个蒟蒻用了带 $\log$ 的做法吧（悲）。

首先显然有个小结论：假若要删除一系列固定的数，并且使整个序列最后递增，那么先删除永远比先交换更优。

这其实不难理解，毕竟删去一些数后，需要交换的数之间的距离变近了，交换次数也就变少了。

所以我们可以枚举删除多少个数字，再计算需要交换多少次即可。

计算交换次数需要知道每个位置产生的逆序对有多少，拿归并或者树状数组用 $O(n\log n)$ 预处理一下即可。

### Code

```c
#include<bits/stdc++.h>
#define int long long
#define maxn 1000100
#define INF 1e18;

using namespace std;

int n,c[maxn],b[maxn];
struct node{
	int k,ans;
}a[maxn];

bool cmp(node x,node y){
	return x.ans<y.ans;
}

int lowbit(int x){
	return x&-x;
}

void add(int k,int x){
	while(k<=n){
		c[k]+=x;
		k+=lowbit(k);
	}
	return ;
}

int sum(int x){
	int number=0;
	while(x>0){
		number+=c[x];
		x-=lowbit(x);
	}
	return number;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].ans;
		a[i].k=i;
	}
	sort(a+1,a+1+n,cmp);
	int summ=0;
	for(int i=1;i<=n;i++){
		add(a[i].k,1);
		int num=sum(a[i].k);	
		b[i]=(a[i].k-num),summ+=b[i];//枚举每个位置上产生的逆序对个数
	}
	int ans=summ;
	for(int i=1;i<=n;i++){
		summ-=b[i]-1;//枚举删除了多少个数
		ans=min(ans,summ);
	}cout<<ans;
	return 0;
}
```

---

## 作者：Nostopathy (赞：4)

# solution

我拿到题习惯先看数据范围，一开始想到的是动态规划和二分的结合（LIS 后遗症），但是发现状态转移方程不好算，于是考虑换个思路。（如有更好的解法欢迎大佬指点）

对于操作二，不难得到所有小于最大值 $n$ 的数都要删除，于是其操作次数是 $n-1$。

对于操作一，操作的次数就是操作区间逆序对的个数。但是每一次都需要求逆序对个数，这样的时间复杂度即使用什么样的方式（如树状数组）也是会超时的。

这意味着我们需要跳出传统的逆序对思维框架，也就是考虑删除每个数的贡献，即会让逆序对数减少多少。

画图理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/f52d9f42.png)

看图不难得出结论：一个数在序列中构成的逆序对数量等于在它左边比它大的数的数量加上在它右边比它小的数的数量。

但是这样也不太好求，但是我们要删除最优策略肯定是从小到大删，换句话说删除的数字顺序排列是单调递增的，所以只需要考虑在其右边的数字。（终于不那么棘手了）

使用树状数组维护。实现不难。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    int x=0,F=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            F=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x*F;
}
void write(int x)
{
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}
const int N=1E5+5;
int low_bits(int n)
{
	return n & -n;
}
int a[N], k[N], s[N], n, ss, qwq;
void ak(int l)
{
	for(int i=l; i<=n; i+=low_bits(i))
		++k[i];
}
int sk(int l)
{
	int tot=0;
	for(int i=l; i; i-=low_bits(i))
		tot+=k[i];
	return tot;
}
signed main(){
	//泥嚎，写题吧骚年
	n=read();
	for(int i=1; i<=n; ++i)
	{
		a[i]=read();
		ak(a[i]);
		s[a[i]]=sk(n)-sk(a[i]);
		ss+=s[a[i]];
	}
	qwq=min(ss, n-1);
	for(int i=1; i<n; ++i)
		ss-=s[i], qwq=min(qwq, ss+i);
	write(qwq);
	return 0;
}

```

别走得太急忙，点个赞再走。

---

## 作者：jijidawang (赞：4)

注意到肯定是先用疯狂操作再用轮回操作，可以调整证明。

枚举用多少次疯狂操作，删除这些元素后计算只使用轮回操作排序最少需要多少步，根据经典结论可知答案就是序列的逆序对个数。

那么就是要删除最小值查询逆序对个数，可以倒过来改成每次加入一个比之前大的数查询逆序对个数，在值域上开一个树状数组即可简单维护。时间复杂度 $\Theta(n\log n)$。

---

## 作者：ShizukuQWQ (赞：3)

### 题目大意
给定一个排列，你可以删去最小的数或交换任意两个数的位置，求使其单调递增所需的最小步数。
### 分析
如果没有删除操作，答案显然为逆序对的个数（当且仅当 $i<j$ 且 $a_i>a_j$ 时才有必要交换）。
一个点的贡献为当前这个点在右边的逆序对个数。由于我们是从最小的数字开始删的，显然不会对其他数贡献产生影响，只会使删去的这个数贡献清零。
只需归并求出每个点的贡献，再暴力删去几个数，最后计算答案最小值即可。
时间复杂度 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100005],dp[100005],ans,R=1,h,c[100005],mx,id[100005];
void msort(long long b,long long e){
    if(b==e) return;
    int mid=(b+e)/2,i=b,j=mid+1,k=b;
    msort(b,mid),msort(mid+1,e);
    while(i<=mid&&j<=e)
    	if(a[i]<=a[j]) c[k++]=a[i++];
    	else{
    		c[k++]=a[j++],dp[a[j-1]]+=mid-i+1,ans+=mid-i+1;
		}
    while(i<=mid) c[k++]=a[i++];
    while(j<=e) c[k++]=a[j++];
    for(int l=b;l<=e;l++) a[l]=c[l];
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],id[a[i]]=i;
	msort(1,n);
	mx=1e16;
	for(int i=0;i<=n;i++){
		ans-=dp[i];
		mx=min(mx,ans+i);
	}
	cout<<mx<<endl;
}

---

## 作者：huyangmu (赞：3)

这道题一开始容易想成动态规划，但你会发现转移不太好写，所以就可以果断放弃这个做法。

设 $x$ 是被删除的数中的最大值，容易发现，所有比 $x$ 小的数都是要被删除的，所以操作二的次数为 $x$。

然后只要求操作一的次数，根据经典结论，操作一的次数即为区间逆序对个数。

但是如果每一次都要求出区间逆序对个数，即便加上树状数组优化也是会超时的，所以我们考虑每次删掉一个 $x$ 会让逆序对减少多少个。

很显然，每个 $x$ 对逆序对个数的贡献为这个数前面比它大的数的个数加上这个数后面比它小的数的个数，但这个又很不好求，原因是前面的和后面的要分开考虑。但可以注意到，每次删掉的 $x$ 肯定是当前序列中最小的，对它后面的数不会有贡献，所以只要维护每个数前面比它大的数的个数就可以了，可以用树状数组维护。

### AC Code


```cpp

#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N = 1e5 + 5;
int n, a[N], pos[N], cnt[N], tree[N], ans, sum;
int lowbit (int x){
	return x & -x;
}
int query (int x){
	int sum = 0;
	while (x){
		sum += tree[x];
		x -= lowbit(x); 
	}
	return sum;
} 
void update (int x, int val){
	while (x <= n){
		tree[x] += val;
		x += lowbit(x);
	}
	return ;
}
signed main (){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i){
		cin >> a[i];
		pos[a[i]] = i;
		cnt[i] = query(n) - query(a[i]);
		update (a[i], 1); 
		sum += cnt[i];
	}
	ans = sum;
	for (int i = 1; i <= n; ++i){
		sum -= cnt[pos[i]];
		ans = min (ans, i + sum);
	}
	cout << ans << '\n';
	return 0;
}

---

## 作者：_Emperorpenguin_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11208)

## 思路

线段树做法，$O(n\log n)$。

记 $c_{a_i}$ 为位置在 $i$ 之前比 $a_i$ 大的数。统计只使用“轮回”而不使用“疯狂”来使其单增所需要的最小操作次数 $k$。

接下来，枚举进行“疯狂”操作的个数。每删除一个数 $i$，它前面的比它大的数都可以少进行一次“轮回”，但又要增加一次“疯狂”，因此有：```k-=c[i]-1;```。

要开 ```long long```，不然只有 $50$ 分。
## Code

```cpp
#include <bits/stdc++.h>
#pragma GCC optmize(2)
using namespace std;

#define int long long
int n,a[100005],ans,k,c[100005];
int t[400005],b[400005];//四倍空间 

void pushdown(int l,int r,int p){//懒标记下传 
	if(b[p]){
		int mid=l+r>>1;
		t[p<<1]+=(mid-l+1)*b[p];
		t[p<<1|1]+=(r-mid)*b[p];
		b[p<<1]+=b[p];
		b[p<<1|1]+=b[p];
		b[p]=0;
	}
	return;
}

void change(int l,int r,int p,int x,int y){//区间加 
	if(x<=l&&r<=y){
		t[p]+=r-l+1;
		b[p]++;
		return;
	}
	pushdown(l,r,p);
	int mid=l+r>>1;
	if(x<=mid) change(l,mid,p<<1,x,y);
	if(y>mid) change(mid+1,r,p<<1|1,x,y);
	t[p]=t[p<<1]+t[p<<1|1];
	return;
}

int find(int l,int r,int p,int x){//单点求值 
	if((l==x)&&(r==x))
		return t[p];	
	pushdown(l,r,p);
	int mid=l+r>>1,res=0;
	if(x<=mid) res+=find(l,mid,p<<1,x);
	else res+=find(mid+1,r,p<<1|1,x);
	return res;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++) 
		cin>>a[i];
	for(int i=1;i<=n;i++){
		k+=a[i]+find(1,n,1,a[i])-i; 
		c[a[i]]=find(1,n,1,a[i]);
		if(a[i]>1) change(1,n,1,1,a[i]-1);
	}
	ans=k;//至多要操作 k 次 
	for(int i=1;i<=n;i++){
		k-=c[i]-1;
		ans=min(ans,k);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

（我看题解区还没有线段树解法，我来搞一发）

首先删除操作与该数的位置无关，所以必定先进行删除再交换以减少交换次数。

用线段树维护每个数贡献的逆序对，从小到大一次删除每个数，删除时减去相应的数量，取过程中产生的最小操作次数即可。

记得特判无需操作的情况就可以愉快地 AC 了。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define rep(i,x,y) for(ll i=x;i<=y;i++)
#define pause system("pause")
#define pll pair<ll,ll>

const ll N=1e5+10;
ll n,ans=N,sgtr[N<<2],pa[N],sum;
pll a[N];

ll ls(ll p){
	return p<<1;
}

ll rs(ll p){
	return p<<1|1;
}

void pushup(ll p){
	sgtr[p]=sgtr[ls(p)]+sgtr[rs(p)];
}

void upd(ll p,ll l,ll r,ll ql){
	if(r<ql||l>ql) return;
	
	if(l==r) sgtr[p]++;
	else{
		ll mid=l+r>>1;
		
		if(ql<=mid) upd(ls(p),l,mid,ql);
		else upd(rs(p),mid+1,r,ql);
		
		pushup(p);
	}
}

ll query(ll p,ll l,ll r,ll ql,ll qr){
	if(qr<l||r<ql) return 0;
	
	if(ql<=l&&r<=qr) return sgtr[p];
	
	ll mid=l+r>>1;
	
	return query(ls(p),l,mid,ql,qr)+query(rs(p),mid+1,r,ql,qr);
}

int main(){
	cin>>n;
	bool f=0;
	
	rep(i,1,n) {
		cin>>a[i].first;
		a[i].second=i;
		pa[i]=query(1,1,n,a[i].first+1,n);
		sum+=pa[i];
		upd(1,1,n,a[i].first);
		
		if(i>1&&a[i].first<a[i-1].first) {
			if(f==0&&i==n){
				cout<<1;
				return 0;
			}
			
			f=1;
		}
	}
	
	if(f==0){
		cout<<0;
		return 0;
	}
	
	sort(a+1,a+n+1);
//	cout<<sum<<'\n';
	
	rep(i,1,n){
		sum-=pa[a[i].second];
		ans=min(ans,i+sum);
	}
	
	cout<<ans;
}
/*
5
1 2 3 5 4
ans:1
*/
```

---


# 轰炸

## 题目描述

“我该怎么办？”飞行员 klux 向你求助。

事实上，klux 面对的是一个很简单的问题，但是他实在太菜了。

klux 要想轰炸某个区域内的一些地方，它们是位于平面上的一些点，但是（显然地）klux 遇到了抵抗，所以 klux 只能飞一次，而且由于飞机比较破，一点起飞就只能沿直线飞行，无法转弯。现在他想一次轰炸最多的地方。


## 说明/提示

### 数据范围

对于全部数据，保证 $1\le n\le 700$。

本题翻译并改编自 uva270，数据及解答由 uva 提供。


## 样例 #1

### 输入

```
5
1 1
2 2
3 3
9 10
10 11
```

### 输出

```
3
```

# 题解

## 作者：Flokirie (赞：106)

不知大家有没有学到高中数学，向量a=(x1,y1)和b=(x2,y2)共线==>x1y2-x2y1==0

用此法可以避免浮点数运算

'''cpp



```cpp
#include <iostream>
using namespace std;
struct point{
    int x,y;
};
int main(){
    int n; 
    cin>>n;
    point p[n];
    for (int i=0;i<n;i++){
        cin>>p[i].x>>p[i].y;
    }
    int max=0;
    for (int i=0;i<n-1;i++){
        for (int j=i+1;j<n;j++){//任取两点i，j，姑且记为I、J吧
            int cnt=2;//IJ上本就有I、J两点
            point vec1;//用点坐标代替向量IJ（此处应该有“→”）
            vec1.x=p[j].x-p[i].x;
            vec1.y=p[j].y-p[i].y;//IJ=(xj-xi,yj-yi)
            for (int h=0;h<n;h++){//枚举异于i、j的所有点
                if (h==i || h==j) continue;
                point vec2;//同样的方法计算向量IH
                vec2.x=p[h].x-p[i].x;
                vec2.y=p[h].y-p[i].y;
                if (vec1.x*vec2.y==vec1.y*vec2.x){//如果IJ与IH共线，即I、J、H三点共线
                    cnt++;//直线IJ上的点+1
                }
            }
            if (cnt>max) max=cnt;
        }
    }
    cout<<max;
    return 0;
}
```
'''
没学高中数学的oier们不喜勿喷^\_^


---

## 作者：24680esz (赞：43)

利用直线方程，枚举起点并计算斜率，最后排序一遍，找出斜率相同数最多的，计算个数。

时间复杂度为O（n^2log(n)）（我也不知道为什么那些写n^3的也可以过）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,sum,sum2,ans;
double f[701][701],x[701],y[701];
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++) cin>>x[i]>>y[i];
    for (int i=1;i<=n;i++)//枚举起点
      for (int j=1;j<=n;j++)
    {
        if (i==j) continue;
        f[i][j]=(y[i]-y[j])/(x[i]-x[j]);//计算斜率
    }
    //for (int i=1;i<=n;i++) {for (int j=1;j<=n;j++) cout<<f[i][j]<<" ";cout<<endl;}
    for (int i=1;i<=n;i++)
    {
        sort(f[i]+1,f[i]+n+1);//排序
        sum=0;sum2=0;
        for (int j=3;j<=n;j++)
        {
            if (f[i][j]==f[i][j-1]) sum++,sum2=max(sum,sum2);//计算个数
            else sum=0;
        }
        sum=max(sum,sum2);
        ans=max(ans,sum);
    }
    cout<<ans+2<<endl;
    return 0;
}
```

---

## 作者：Celebrate (赞：16)

这一题思路是找两个不同的点，然后搜寻所有

的点，如果在同一条直线上，就ans++，最后求

最大值就好了。

所以们需要用到直线公式，判断3点是否在同一

条直线上，我一开始也不懂，然后我手推公式：

公式里我用了点2,3和1作比较，看看是否在同

一条直线上

注：建议不要用除法，可能存在精度问题，所以我

叉用了交叉相乘。

下面是手推公式的过程：

![](https://cdn.luogu.com.cn/upload/pic/17180.png)

找到公式以后，就是代码了：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,x[710],y[710];
inline void Find_max()
{
	int i,j,k,ans,maxx=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
	for(i=1;i<n;i++)
	{
		for(j=i+1;j<=n;j++)//分别枚举两个不同的点 
		{
			ans=2;
			for(k=1;k<=n;k++)//找所有的点 
			{
				if(k==i || k==j) continue;
				if((x[k]-x[i])*(y[k]-y[j])==(y[k]-y[i])*(x[k]-x[j])) ans++;//前面推出的公式 
			}
			maxx=max(maxx,ans);
		}
	}
	printf("%d\n",maxx);//输出 
}
int main()
{
	Find_max();return 0;
}
```

---

## 作者：hensier (赞：11)

【前言（~~废话~~）】

这道题需要联想到初中阶段所学习的平面直角坐标系。因为题目中提到直线，所以我们必然会想到一次函数。本蒟蒻对一次函数的表达式进行了略微的推导，已经熟知的大佬请忽略。

【一次函数简介】

对于一条在平面直角坐标系中的直线，它必定能够用形如$y=kx+b$的形式表示，其中$k\neq0$。当$b=0$时，$y=kx$，此时$y$与$x$成正比例。

下图是$y=-4x+5$的函数图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/aoak0ois.png)

在直线$y=-4x+5$上的点有无数个，但在输入中出现的是有限的，甚至并不存在。

所以我们必须要找到满足条件的$y=kx+b$，使得该直线上包含输入样例中的点最多。

【思路与分析】

这道题可以用略小于$O(n^3)$的算法。主要思路就是通过$i,j$的坐标求出函数表达式，然后检查$k$的坐标是否满足该表达式即可。

我们设第一个点的坐标为$(x_1,y_1)$，第二个点坐标为$(x_2,y_2)$。设函数表达式为$y=kx+b$，则满足：

$$
\begin{cases}
y_1=kx_1+b\cr
y_2=kx_2+b
\end{cases}$$

用上式减去下式，得到：

$$y_1-y_2=(kx_1+b)-(kx_2+b)$$

这时发现$b$已经消去，而$x_1,x_2,y_1,y_2$均为已知量，所以我们进一步化简：

$$y_1-y_2=kx_1-kx_2$$
$$y_1-y_2=k(x_1-x_2)$$
$$k=\frac{y_1-y_2}{x_1-x_2}$$

这个时候我们可以通过任意一种方法得到$b$的值（可以利用$b=y_1-kx_1$或$b=y_2-kx_2$，下面以前者为例）：

$$b=y_1-kx_1$$
$$b=y_1-\frac{x_1(y_1-y_2)}{x_1-x_2}$$
$$b=\frac{y_1(x_1-x_2)-x_1(y_1-y_2)}{x_1-x_2}$$
$$b=\frac{y_1x_1-y_1x_2-x_1y_1+x_1y_2}{x_1-x_2}$$
$$b=\frac{x_1y_2-y_1x_2}{x_1-x_2}$$

求得$k,b$用坐标表示的代数式之后，我们得到函数表达式：

$$y=\frac{y_1-y_2}{x_1-x_2}·x+\frac{x_1y_2-y_1x_2}{x_1-x_2}$$

我们将其稍稍做一点改动：

$$y(x_1-x_2)=x(y_1-y_2)+x_1y_2-y_1x_2$$

现在我们要寻找一个符合条件的数对$(x_3,y_3)$使其满足上式。只要满足了，就能使得$(x_1,y_1),(x_2,y_2),(x_3,y_3)$在同一直线上。

以此类推，我们每找到符合条件的一个点，就可以发现这几个点在同一直线上。

当然，上述的操作必须保证$x_1\neq x_2,y_1\neq y_2$，否则会出现除数为$0$的现象。

【特殊情况的考虑】

我们还需要考虑两种直线$x=k,y=k$的情况（这两种直线都平行于坐标轴）。此时，函数不为一次函数，直线平行于两个坐标轴之一（即与其中一个坐标轴没有交点）。

下图是$y=1$的函数图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/mottgvmd.png)

下图是$x=-10$的函数图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/cfle6d6q.png)

这就较为简单了——找到两个点，使其横坐标相同；再找到两个点，使其纵坐标相同。

我们综合上述两条直线的情况，根据简单贪心的算法，找到各个直线的点个数的最大值即可。

【代码】

本蒟蒻喜好使用`Python`写部分程序，~~但是`Python`的运行速度实在太慢，导致`TLE`~~。`C++`在$O(n^3)$算法下居然不会$TLE$，看来暴力算法也可以过。`Python`代码基本上是从`C++`翻译过来的，大家可以参考参考。

运行结果：

|结果|语言|时间大小|空间大小|代码大小|提交记录|代码
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$\color{#52C410}AC$|`C++`|$436ms$|$732.00KB$|$887B$|[记录](/record/33480524)|[代码](/paste/psl32n6p)|
|$\color{#052242}TLE$|`Python3`|$7.53s$|$3.48MB$|$930B$|[记录](/record/33481727)|[代码](/paste/py9r56qq)|

---

## 作者：qwerta (赞：7)

**O(n^3)做法**

首先要把题读懂。
```
题目大意：
给你n个点的坐标，求怎样连一条直线，在线上的点最多，并输出最多的点数。
```
我的想法是先暴力枚举可能的直线，并算出每条直线上的点数，取最大值输出。

根据“两点确定一条线段”的思想，在n>=2的前提下，任取两点连起来就可以得到一条确定的直线，此时线上的点数s=2;

那么在已知直线上两点的前提下，怎么求剩下来的点是否在这条直线上呢？

假设我们之前取的点为i,j，现在有z点要求是否在直线|ij|上

~~那么我们可以使用数学必修二中点到直线的距离公式（皮~~

只需连接|iz|，可以想到，**如果|iz|的斜率和|ij|的斜率相等，可得三点共线**，也就是z在直线ij上，s++。

代码实现中，只需for枚举i,j两点，再for z来判定斜率是否相等就行了。

//小优化部分

而注意到两点连线的斜率不受其它因素影响，所以我们可以通过预处理k的方式来小优化

而且如果得到z在直线ij上，那么再枚举到zi或zj时，这条直线我们已经跑过了不用再跑了，所以可以用bool数组判重来加以优化

高二dalao说for循环写++i比i++快很多，~~但是因为不顺手没有写（皮~~

//代码 752ms / 5.82MB
```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
struct emm{
    int x,y;
}a[707];//一个点的坐标
double k[707][707];//斜率k
bool sf[707][707];//判重
int i,j,z,n;
int s,ans=2;
void scan()//输入
{
    scanf("%d",&n);
    if(n==1){cout<<1;exit(0);}//特判（貌似并没有n==1的数据点emmm
    for(i=1;i<=n;i++)
    scanf("%d%d",&a[i].x,&a[i].y);
    return;
}
void yu()//预处理
{
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    if(a[i].x-a[j].x==0)
    k[i][j]=9999;//把x值不存在的情况统一赋值成9999
    else k[i][j]=abs((double)(a[i].y-a[j].y)/(a[i].x-a[j].x));//求k值
    return;
}
void run()//运行
{
    for(i=1;i<=n;i++)
    for(j=i+1;j<=n;j++)//枚举沿着哪两个点连线
    if(!sf[i][j])
    {
        s=2;
        for(z=1;z<=n;z++)//枚举其它的点
        if(z!=i&&z!=j)
        {
            if(k[i][j]==k[i][z])//判断斜率是否相同
            {
                s++;ans=max(ans,s);
                sf[i][z]=sf[z][i]=sf[j][z]=sf[z][j]=1;
            }
        }
    }
    return;
}
int main()//主函数
{
    scan();
    yu();
    run();
    cout<<ans;
    return 0;
}
```

---

## 作者：Sophon (赞：5)

一条直线 y=kx+b, 由k和b就可以唯一的确定一条直线.  
过两点的直线方程  
y-y1=k(x-x1)  
又k=(y2-y1)/(x2-x1)  
b=k*(-x1)+y1  
用pair表示一条直线，用map建立直线与直线数量的对应（最近STL上瘾）

```cpp
#include <iostream>
#include <map>
#include <algorithm>
#include <cmath>
using namespace std;

map<pair<double, double>, int> cnt;//不同直线计数

int main()
{
	int n;
	cin >> n;

	int x[n];//横纵坐标
	int y[n];

	for (int i = 0; i < n; i++)//输入坐标
	{
		cin >> x[i] >> y[i];
	}

	for (int i = 0; i < n - 1; i++)//枚举所有点对
	{
		for (int j = i + 1; j < n; j++)
		{
			double k = (y[j] - y[i] + 0.0) / (x[j] - x[i] + 0.0);//斜率
			double b = k * (-x[i])*1.0 + y[i];//纵截距

			pair<double, double> line = make_pair(k, b);//打包成一条直线
			cnt[line]++;//初始值为0，计数器++
		}
	}

	int maxx = -1;
	for (map<pair<double, double>, int>::iterator it = cnt.begin(); it != cnt.end(); it++)//用迭代器遍历map
	{
		maxx = max(it->second, maxx);
	}
	cout << (1.0 + sqrt(1 + 8 * maxx)) / 2.0 << endl;//因为(n-1)*n/2=maxx，用求根公式求出有多少点在该直线上
}
```

---

## 作者：SeiyuYuri (赞：4)

~~请注意算法标签  “枚举，暴力”~~
----
对啦，这道题枚举就行了。

思路：

- 未确定起飞点，所以要确定飞行路 —— 两点一线

- 已知两点，需要判定任意第三点是否在飞行路径上

OK，第一个版本：

用 d1,d2数组储存轰炸点位

用lin临时储存当前可轰炸点位（默认为2，为默认开始与结束点）

用ans储存最终答案

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int d1[770], d2[770];
int lin = 2;
int ans = 0;
int main()
{
	int a;
	scanf("%d", &a);
	for (int i = 1; i <= a; i++)
	{
		scanf("%d %d", &d1[i], &d2[i]);
	}
	for (int i = 1; i <= a; i++)
		for (int j = 1; j <= a; j++)
		{
			if (i != j) 
			{
				double z, x;
				z = d1[i] - d1[j];
				x = d2[i] - d2[j];
				for (int k = 1; k <= a; k++)
				{
					if (k != i && k != j)
					{
						double c, v;
						c = d1[i] - d1[k];
						v = d2[i] - d2[k];
						if (c / v == z / x)lin++;
					}
				}
				if (lin > ans)ans = lin;
				lin = 2;
			}
		}
	printf("%d", ans);
	return 0;
}
```

注意啦，如果使用int计算斜率，将会向下取整。

那么所以可以用double计算，虽然会有精度损失，但是损失的都一样，不相同了吗(￣▽￣)"






当然，这个算法会超时。。。毕竟是n^3的复杂度。


~~当然你开了O2优化就不会了~~


---

## 作者：NotaKoala (赞：3)

忘记加注释了，重交一份

对每个点计算从这个点开始的直线最多能经过多少个点，显然斜率相同的直线都在一条直线上，直接枚举这个点与另外$n - 1$个点的斜率，用map存每种斜率的个数，然后再遍历一下map就好了取斜率个数最多的更新答案。

- $map$ 以斜率为 $key$,  统计每种斜率的个数

- 如果斜率是无穷大，那就用一个足够大的不影响答案的斜率来表示这个斜率就好了。

复杂度 是 $O(n^2logn)$

```cpp
#include <cstdio>
#include <map>
using namespace std;

const int MAX_N = 700 + 9;
const double INF = 233333;

// INPUT
int n;
int x[MAX_N], y[MAX_N];

void solve() {
	int ans = 0;
	for (int i = 0; i < n; i++) {
		int res = 0; // 统计与 (x[i], y[i]) 重合的点的个数 
		
		// 统计每种斜率的个数 
		map<double, int> mp;
		
		// 扫描 n 个点 
		for (int j = 0; j < n; j++) {
			if (x[i] == x[j] && y[i] == y[j]) res++; // (x[i], y[i]) 与 (x[j], y[j]) 重合 
			else if (x[i] == x[j]) mp[INF]++; // 斜率为无穷大 
			else mp[1.0 * (y[i] - y[j]) / (x[i] - x[j])]++;  // 统计斜率个数 
		}
		// 遍历 map 
		int p = 0;
		map<double, int>::iterator ite; 
		for (ite = mp.begin(); ite != mp.end(); ite++) p = max(ite->second, p);
		ans = max(ans, res + p);
	}
	printf("%d\n", ans);
}

int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++) scanf("%d %d", &x[i], &y[i]); 
	solve();
	return 0;
}

```

---

## 作者：lizehan888 (赞：3)

P党福利（话说Pascal题解越来越少） 

1.数学知识：直线斜率k=(y1-y2)/(x1-x2) 

2.本题数据很water ，O(n^3)都能过 

3.尽量避免除法，浮点还是很讨厌的（交叉相乘）


------------


上代码：

    var
    n,i,j,k,ans,max:longint;
    x,y:array[0..700]of longint; 
    begin
    max:=-1;   
    readln(n);  
    for i:=1 to n do readln(x[i],y[i]);  
    for i:=1 to n-1 do //暴力三重   
    for j:=i+1 to n do 
    begin
      ans:=2;
      //核心代码：
      for k:=j+1 to n do 
        if (x[i]-x[k])(y[i]-y[j])=(y[i]-y[k])(x[i]-x[j]) 
        then inc(ans);
      if ans>max then max:=ans; //找最值
      ans:=2;
    end; 
    writeln(max);
    end.

---

## 作者：至尊无敌 (赞：3)

**分析**

简单的计算几何题目，利用了直线方程式（同一直线上任意点都满足方程式）

直线的方程我们先看看两点式方程：

  (y-y1)/(y2-y1)=(x-x1)/(x2-x1)

交叉相乘并整理可以得到:(y-y1)(x2-x1)=(y2-y1)(x-x1)

化为一般式:ax+by+c=0 得：

其中:

 A=y2-y1

 B=x2-x1

C=-ax1+by1

这样就可以尽量避免除法，因为众所周知，除法是很费时间的，而且有精度问题。

再一次枚举n个点，找出最多。


**参考程序**

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
using namespace std;
struct point
{
    int x,y;
};
point p[710];
int n,i,j,max,ans;
int main()
{
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);
    ans=0;
    for (i=1;i<=n-1;i++)
      for (j=i+1;j<=n;j++)
      {
            max=0;
            int a,b,c;
            a=p[j].y-p[i].y;
            b=p[j].x-p[i].x;
            c=-a*p[i].x+b*p[i].y;
            for (int k=1;k<=n;k++)
              if (a*p[k].x-b*p[k].y+c==0)
                max++;
            if (ans<max) ans=max;
      }
    printf("%d\n",ans);
    return 0;
}
转自http://www.cppblog.com/xiongnanbin/articles/78238.html
```

---

## 作者：H_D_NULL (赞：2)


#### 建议初中的同学自学高中数学平面向量一章，对计算几何的初步理解有帮助。。。

------------
### 计算几何（未）入门题目

如果点$(x,y)$在点$(x1,y1)$，$(x2,y2)$所连直线上，则不难想到，点$(x,y)$与$(x1,y1)$所成向量和点$(x,y)$与$(x2,y2)$所成向量共线。

即向量$(x1-x,y1-y)$与向量$(x2-x,y2-y)$共线，方向不重要。

转换成表达式：$(x1-x)(y2-y)-(x2-x)(y1-x)=0$

接下来的操作才是真正的普及水平：枚举两点构成的直线，再遍历判断有哪些点在直线上。

完。


------------

*Talk is cheap, show me the code*

```cpp
#include<bits/stdc++.h>
#define re register int
using namespace std;
const int mn=1000;

int n;
int ans;
int x[mn],y[mn];

int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(re i=1;i<=n;i++){
		cin>>x[i]>>y[i];
	}
	for(re i=1;i<n-1;i++){
		for(re j=i+1,num;j<n;j++){
			num=2;
			for(re k=j+1;k<=n;k++){
				if((x[i]-x[k])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[k]))
					num++;
			}
			ans=num>ans?num:ans;
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：zhangziyi_xshsnoi (赞：2)

![image](https://cdn.luogu.com.cn/upload/image_hosting/53gvo0rj.png)

# Solution

如图所示

设$y_{AB}=kx+b(k\ne0$且$k,b$为常数$)$

将$A(x_1,y_1),B(x_2,y_2)$带入

得到方程组
$$\begin{cases}y_1=kx_1+b \ \ \ (1)\\ y_2=kx_2+b \ \ \  (2)\end{cases}$$

由$(1)-(2)$得
$$y_1-y_2=k(x_1-x_2)$$
$$k=\frac{x_1-x_2}{y_1-y_2}$$

我们得到这些结论后，就可以~~干一些事情了~~

#### 首先

计算  $y_{AB}$的$k$值。

再计算$y_{AC}$的$k$值。

若 $k_{AB}=k_{AC}$

则$A,B,C$三点共线

#### 那么

这道题目就可以用$O(n^3)+O2$优化来$\color{red}AC$了。

# Code
```cpp
//手动O2
#include<bits/stdc++.h>
using namespace std;
int n,ans;
struct node{
	int x,y;
}p[1000];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&p[i].x,&p[i].y);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)//枚举每两个点
		{
			int cnt=2;
			for(int k=1;k<=n;k++)//枚举除i,j外的另外点
				if(k!=i&&k!=j)
				{
					double k1=1.0*(p[i].y-p[j].y)/(p[i].x-p[j].x),
					       k2=1.0*(p[i].y-p[k].y)/(p[i].x-p[k].x);//计算两个k值
					//cout<<k1<<" "<<k2<<endl;
					if(k1==k2)
						cnt++;
				}
			ans=max(ans,cnt);
		}
	printf("%d",ans);
}
```

---

## 作者：小年轻w (赞：2)

题意 给出若干个点，求解最多有几个点在同一直线上

一种做法就是枚举任意两个点，求他们的斜率然后算一下还有几个点和他们的斜率一样，

这样复杂度是 O(N^3)  n<=700 讲道理是过不去的，但是数据太水，就过了

另外一种做法就是由楼上提供的，我是来提供代码的，

枚举以一个点作为原点，然后求其他点，与他的斜率，然后排序一下就行了

复杂度O(n^2logn)


```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <iomanip>
#include <iostream>
using namespace std ;

const int maxn = 701;
const double eps = 1e-9 ; 
struct node {
    int x,y ;
};
node a[701] ;
int n,A1,A2,B1,B2,sum,ans ;
double xx,yy,k,b ;

int main() 
{
    scanf("%d",&n) ;
    for(int i=1;i<=n;i++) 
        scanf("%d%d",&a[i].x,&a[i].y) ;
    ans = min(n,2) ; 
    for(int i=1;i<=n-1;i++) 
        for(int j=i+1;j<=n;j++) 
        {
            A1 = a[j].y-a[i].y ;
            B1 = a[i].x-a[j].x ;
            sum = 2 ;
            for(int k=1;k<=n;k++) 
            {
                if(k==i||k==j) continue ;
                A2 = a[k].y-a[i].y ;
                B2 = a[i].x-a[k].x ;
                if( A1*B2==A2*B1 ) sum++ ; 
            } 
            if(sum>ans) ans = sum ;
        }
    printf("%d\n",ans) ;
    return 0 ; 
}

```



---

## 作者：用户已注销 (赞：1)

主要的思路和下面的几位dalao一样，O（n² log n）枚举原点求斜率

但是精度这一块做了一些修改：

既然想要避免除法，干脆就存一个分数，排序前特判一下0的情况，其他全部约分

然后同样找分子和分母全部相同的，也就是在一条直线上面的。

约分就是两个数同时除以他们的gcd

代码满贴一下吧，但是丑死了

```cpp
#include<cstdio>
#include<algorithm>
#define re register
using namespace std;
int x[701],y[701];
int gcd(int a,int b){return a%b?gcd(b,a%b):b;}
struct k
{
    int a,b;
    void y() 
    {
        //a,b不可能同时为0
        if(!a) b=2147483647;
        if(!b) a=2147483647;
        if(a and b)//约分
        {
            int t=gcd(a,b);
            a/=t;
            b/=t;
        }
    }
}l[701];
bool cmp(k a,k b){return a.a==b.a?a.b>b.b:a.a>b.a;}//排序找相同的 
int n,maxx=0;
int main()
{
    scanf("%d",&n);
    for(re int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
    for(re int i=1;i<=n;i++)//枚举i号点作为原点 
    {
        re int top=0;
        for(re int j=1;j<=n;j++)
        {
            if(j==i) continue;
            top++;
            l[top].a=(y[j]-y[i]);
            l[top].b=(x[j]-x[i]);
            l[top].y();
        }
        sort(l+1,l+n,cmp);//少一个点 
        re int now=1;
        for(re int j=2;j<=n;j++)
        {
            l[j].a==l[j-1].a and l[j].b==l[j-1].b ? now++ : now=1;
            maxx = maxx>now?maxx:now;
        }
    }
    return !printf("%d\n",maxx+1); 
}
```

---

## 作者：清水湾落车 (赞：1)

就像标签里说的一样

判断一下

计算几何的开门题。。。

其实题意很好理解，就是求出一条直线上最多有多少个点。

用斜率啊，叉积什么的都可以过，暴力枚举点对。就当是简单接触一下计算几何好了。

CODE
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
struct Point{int x,y;}p[1005];
int n;
inline int read(){
    char c;int rec=0;
    while((c=getchar())<'0'||c>'9');
    while(c>='0'&&c<='9')rec=rec*10+c-'0',c=getchar();
    return rec;
}
int sum,ans=0;
int main(){
    n=read();
    int i,j,k;
    for(i=1;i<=n;i++)cin>>p[i].x>>p[i].y;
    for(i=1;i<=n;i++){
        for(j=i+1;j<=n;j++){sum=2;
            for(k=j+1;k<=n;k++)
                if((p[i].x-p[k].x)*(p[j].y-p[k].y)==(p[j].x-p[k].x)*(p[i].y-p[k].y))sum++;
            ans=max(ans,sum);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：plane (赞：1)

给你N个点（N<700）


求最多在一条直线上的点。


枚举以每一个点为原点，求它与其他点的斜率，斜率相同则说明在同一条直线上。


只要枚举然后排序，最后求连续最长斜率相同的点就可以了。


---

## 作者：白鲟 (赞：0)

目前题解区仅有两种做法：$\operatorname{O}(n^3)$ 枚举复杂度不优，$\operatorname{O}(n^2\log n)$ 斜率排序精度可能不稳定。

采用基于叉积的极角排序可以兼顾精度和复杂度。具体地，枚举起始点，并算出其余点相对其的向量，对向量进行极角排序，同向的向量会相邻，此时只需要简单统计同向的段的长度即可。

注意事项是同向或反向都是同一直线，因此对于每个起始点，都应当将除自身外所有的点均加入排序（而不应采用 $j<i$ 等排除方法）。由于在每条直线上至少有两个点，使得在这条直线上的其他点对于它来说都在同一方向，上述方法成立。

```cpp
#include <algorithm>
#include <cstdio>
const int maxn = 700;
struct Vector {
    int x, y;
    Vector(int x = 0, int y = 0) : x(x), y(y){}
    friend int cross(const Vector &t1, const Vector &t2) {
        return t1.x * t2.y - t1.y * t2.x;
    }
    friend bool parallel(const Vector &t1, const Vector &t2) {
        return !cross(t1, t2);
    }
    bool operator<(const Vector &t) {
        return cross(*this, t) > 0;
    }
};
struct Point {
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y){}
    Vector operator-(const Point &t) {
        return {x - t.x, y - t.y};
    }
};
Vector t[maxn + 1];
Point a[maxn + 1];
int ans, now, tot, n;
int main() {
    scanf("%d", &n);
    ans = 2;
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &a[i].x, &a[i].y);
    }
    for (int i = 1; i <= n; ++i) {
        tot = 0;
        for (int j = 1; j <= n; ++j) {
            if (i != j) {
                t[++tot] = a[i] - a[j];
            }
        }
        std::sort(t + 1, t + tot + 1);
        now = 2;
        for (int j = 2; j <= tot; ++j) {
            if (parallel(t[j], t[j - 1])) {
                ++now;
            }
            else {
                now = 2;
            }
            ans = std::max(ans, now);
        }
    }
    printf("%d", ans);
    return 0;
}
```

---


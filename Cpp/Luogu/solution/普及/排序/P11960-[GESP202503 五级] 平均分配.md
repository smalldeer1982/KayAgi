# [GESP202503 五级] 平均分配

## 题目描述

小 A 有 $2n$ 件物品，小 B 和小 C 想从小 A 手上买走这些物品。对于第 $i$ 件物品，小 B 会以 $b_i$ 的价格购买，而小 C 会以 $c_i$ 的价格购买。为了平均分配这 $2n$ 件物品，小 A 决定小 B 和小 C 各自只能买走恰好 $n$ 件物品。你能帮小 A 求出他卖出这 $2n$ 件物品所能获得的最大收入吗？

## 说明/提示

#### 数据范围

对于 $20\%$ 的测试点，保证 $1\le n\le8$。

对于另外 $20\%$ 的测试点，保证 $0\le b_i\le1$，$0\le  c_i\le1$。

对于所有测试点，保证 $1\le n\le10^5$，$0\le b_i\le10^9$，$0\le c_i\le10^9$。

## 样例 #1

### 输入

```
3
1 3 5 6 8 10
2 4 6 7 9 11```

### 输出

```
36```

## 样例 #2

### 输入

```
2
6 7 9 9
1 2 10 12```

### 输出

```
35```

# 题解

## 作者：CSP_S_2023_T2 (赞：27)

### 思路
首先，我们假设所有物品全部卖给小 B，则收入为 $\sum_{i=1}^{2n}b_i$。

而第 $i$ 件物品从卖给小 B 变成卖给小 C 对收入的贡献为 $c_i-b_i$。

所以我们只需对 $c_i-b_i$ 进行排序，选出前 $n$ 个最大的，求和并加上全部卖给小 B 的收入即可。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
long long n,b[200005],c,a[200005],ans;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=0;i<n*2;i++) cin>>b[i],ans+=b[i];  //全部卖给小 B 的收入
    for(int i=0;i<n*2;i++) cin>>c,a[i]=c-b[i];   //记录第 i 件物品对答案的贡献
	sort(a,a+n*2,greater<long long>());          //从大到小排序
	for(int i=0;i<n;i++) ans+=a[i];              //更新答案
	cout<<ans;
    return 0;   //完结撒花
}
```

---

## 作者：封禁用户 (赞：9)

这道题目要求我们从 $2n$ 件物品中选择 $n$ 件卖给小 B，剩下的 $n$ 件卖给小 C。总收益是所有被卖给小 B 的物品的 $b_i$ 之和加上所有被卖给小 C 的物品的 $c_i$ 之和。

对于每件物品，我们可以选择将其卖给小 B 或小 C。为了最大化总收入，我们应该优先选择那些在小 B 处价格比在小 C 处价格高的物品给小 B。

定义每件物品在小 B 和小 C 处的收益差为 $d_i$。如果 $d_i$ 为正，说明卖给小 B 更有利；如果为负，则卖给小 C 更有利。我们需要选择 $d_i$ 最大的 $n$ 件物品卖给小 B。

我们可以先计算所有物品在小 C 处的总收益 $sum\_c$，再计算出所有 $d_i$，对 $d_i$ 进行降序排序。最后选择最大的 $n$ 个 $d_i$，将其加到 $sum\_c$ 上，得到最大总收入。

最后，记得开 long long。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,b[200005],c[200005],d[200005],sum_c,sum_d;
signed main(){
	cin>>n;
	for(int i=1;i<=2*n;i++)
		cin>>b[i];
	for(int i=1;i<=2*n;i++)
		cin>>c[i];
	for(int i=1;i<=2*n;i++)
		sum_c+=c[i];
	for(int i=1;i<=2*n;i++)
		d[i]=b[i]-c[i];
	sort(d+1,d+2*n+1);
	for(int i=n+1;i<=2*n;i++)
		sum_d+=d[i];
	cout<<sum_c+sum_d;
}
````

---

## 作者：AuZeb (赞：7)

## 思路

由于要赚尽可能多的钱，那么小 A 出价高就该卖给小 A，小 B 高则卖给小 B。但是现在要求只能各卖一半。

那么考虑设差值 $c_i=a_i-b_i$，对于 $c_i$ 较大的那一半（即大部分情况小 A 出价高），卖给小 A，剩下的则卖给小 B（即大部分情况小 B 出价高）。

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{int a,b,c;}id[200005];
bool cmp(Node x,Node y){return x.c>y.c;}
int main(){
	int n; cin>>n; long long ans=0;
	for(int i=1;i<=2*n;i++) cin>>id[i].a;
	for(int i=1;i<=2*n;i++) cin>>id[i].b;
	for(int i=1;i<=2*n;i++) id[i].c=id[i].a-id[i].b;
	sort(id+1,id+2*n+1,cmp);
	for(int i=1;i<=n;i++) ans+=id[i].a;
	for(int i=n+1;i<=2*n;i++) ans+=id[i].b;
	cout<<ans; return 0;
}
```

---

## 作者：be7mos (赞：6)

# 思路
从题目描述中可以看出这是一道**贪心**的题目。

贪心思想：既然想要收入最大，就要选取单个物品中**出价尽量高**，且与出价较低者的出价**差距尽可能大**。
# 解题方法
计算出第 $i$ 件物品小 $A$ 与小 $B$ 出价的差。对这 $i$ 件物品两者的差价进行降序排序，选取尽可能大的价格作为售价。
# AC code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2 * 1e5 + 10;
int n, ans, C, B;
struct stu
{
	int c, b, res;
}a[N];
bool cmp (stu x, stu y)
{
	return x.res > y.res;
}
signed main ()
{
	cin >> n;
	for (int i = 1; i <= n * 2; i ++) scanf ("%lld", &a[i].b);
	for (int i = 1; i <= n * 2; i ++) scanf ("%lld", &a[i].c);
	for (int i = 1; i <= n * 2; i ++)
		a[i].res = abs (a[i].c - a[i].b);	// 记录差
	sort (a + 1, a + n * 2 + 1, cmp);	// 降序排序
	for (int i = 1; i <= n * 2; i ++)
	{
		if (a[i].b > a[i].c)	// 	小B更优 
		{
			if (B < n)
			{
				B ++;
				ans += a[i].b;
			}
			else
			{
				C ++;
				ans += a[i].c;
			}
		}
		else if (a[i].c > a[i].b)	// 	小C更优 
		{
			if (C < n)
			{
				C ++;
				ans += a[i].c;
			}
			else
			{
				B ++;
				ans += a[i].b;
			}
		}
		else	// 	出价相同 
		{
			if (C < n)
			{
				C ++;
				ans += a[i].c;
			}
			else
			{
				B ++;
				ans += a[i].b;
			}
		}
	}
	printf ("%lld", ans);
	return 0;
}
```

---

## 作者：niuniudundun (赞：5)

五级废了，写个题解。

[题目传送门](https://www.luogu.com.cn/problem/P11960)

# Problem

有 $2n$ 种物品，有两种出价 $b_i,c_i$，每个人只能买 $n$ 种，求最大收益。

# Solution

首先输入 $n,b,c$。

可以将所有 $b_i$ 加到一起并求出 $d_i=c_i-b_i$。

接着将 $d$ 排序，将 $b_i$ 的和加上 $\sum_{i=n+1}^{2n}d_i$。

那为什么这是对的呢？

> 实际上 $d_i$ 是求 $c_i$ 比 $b_i$ 大多少的。
> 
> 所以对于 $d_i$ 有：
>
> - $d_i<0$：说明 $b_i>c_i$，这种情况买东西肯定卖给 $b$。
> - $d_i=0$：说明 $b_i=c_i$，这种情况买谁都一样。
> - $d_i>0$：说明 $b_i<c_i$，这种情况买东西肯定卖给 $c$。
>
> 而求较大的 $n$ 个 $d_i$，是选择 $c$ 的出价。如果 $c_i>b_i$ 这种情况少于 $n$，那么只能将卖 $b$ 了。

考虑到 $n\le 10^5,b_i\le 10^9$，那么 $n$ 个 $b_i$ 就是 $10^5\times 10^9=10^{5+9}=10^{14}$，需要使用 `long long`。并且存储 $2n$ 个数，数组得开到 $2\times 10^5$。

# Code

复杂度：$O(3n+2n \log (2n))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+1;
int n,b[maxn],c[maxn],d[maxn],ans;
signed main(){
	cin>>n;
	for(int i=1;i<=2*n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=2*n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=2*n;i++){
		ans+=b[i];
		d[i]=c[i]-b[i];
	}
	sort(d+1,d+2*n+1);
	for(int i=n+1;i<=n*2;i++){
		ans+=d[i];
	}
	cout<<ans<<endl;
	return 0;
}
/*
2
6 7 9 9
1 2 10 12
*/
```

广告：[我的游记](https://www.luogu.com.cn/article/90huhyn3)。

---

## 作者：MassPoint (赞：3)

## 思路

我们考虑贪心。我们可以先将所有物品按 $c_i-b_i$ 的大小从大到小排序，然后将前 $n$ 个物品卖给小 C，其余的卖给小 B，这样卖出的价格一定是最高的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct thing{
	int b;
	int c;
	int val;
}a[200010];	//注意要开 2*n 的空间。
int n;
long long ans=0;
bool cmp(thing a,thing b){
	return a.val>b.val;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=2*n;i++)	scanf("%d",&a[i].b);
	for(int i=1;i<=2*n;i++)	scanf("%d",&a[i].c);
	for(int i=1;i<=2*n;i++)	a[i].val=a[i].c-a[i].b;
	sort(a+1,a+1+2*n,cmp);
	for(int i=1;i<=n;i++)	ans+=a[i].c;
	for(int i=n+1;i<=2*n;i++)	ans+=a[i].b;
	printf("%lld",ans);
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/209915036)

---

## 作者：guoshengyu1231 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11960)
## 初步思考
一看到题目中“最大”两个字，首先应该联想到贪心。既然是贪心，那我们应该用什么来做贪心的依据呢？换句话说，那就是以什么标准来贪心。通过读题我们可以明白，每一种物品卖给两个人有两种价值。我们的目标是将 $2n$ 个物品分给这两个人，每个人获得 $n$ 个物品。要使最终的价值最大。 

$\\$ 

怎样才能使价值最大？如果一个物品卖给第一个人获得的价值远远大于卖给第二个人获得的价值。那我们肯定是选择卖给第一个人。那我们是不是直接选择收益较多的就行了？当然不是。我们还需要考虑一点，那就是每个人一定要获得 $n$ 个物品，所以有时候即使卖给这个人不如卖给另一个人，我们也不得不选择这个人。

$\\$ 

举个例子：现在一共有两个物品，但此时这两个物品都是买个第一个人划算，但根据题目要求，我们不能将这两个物品都卖给第一个人，因为两个人都只能获得一个物品。那此时我们肯定是选择将差距更大的卖给第一个人，所以这就是贪心的标准。
## 具体步骤
- 输入每个物品卖给第一个人和第二个人的价钱，并算出它们之间的差距。
- 根据卖给第一个人和第二个人的价钱的差距来从小到大排序每个物品。
- 遍历每个物品，将第 $1$ 到 $n$ 个物品卖给第二个人，将第 $n+1$ 到 $2n$ 个物品卖给第二个人。最后输出答案。
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long //一定要开long long !
using namespace std;
int n,ans;
struct node{
	int a;
	int b;
	int c;
}m[200005];
bool cmp(node x,node y)
{
	return x.c<y.c;
}
signed main()
{
	cin>>n;n<<=1;
	for(int i=1;i<=n;i++) cin>>m[i].a;
	for(int i=1;i<=n;i++) cin>>m[i].b;
	for(int i=1;i<=n;i++) m[i].c=m[i].a-m[i].b;
	sort(m+1,m+n+1,cmp);
	for(int i=1;i<=n;i++)
	 if(i<=n/2) ans+=m[i].b;
	 else ans+=m[i].a;
	cout<<ans;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

原题链接：[P11960 平均分配](https://www.luogu.com.cn/problem/P11960)。

考虑贪心，策略如下：

- 对于每个物品求出小 B 与小 C 出价的差值 $d_i = b_i - c_i$。

- 所有物品按照差值 $d_i$ 从大到小进行排序，小 B 选择 $d_i$ 大的前 $n$ 个，剩余为小 C 所选。

证明如下：

假设存在其他分配方式能获得更大收益，则必然存在某个物品 $j$ 满足：

- $j$ 未被选为 B，但存在一个已选的物品 $k$ 使得 $b_j−c_j>b_k−c_k$。
- 此时将 $j$ 替换为 $k$ 会增大总和，与假设矛盾。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 2e5 + 10;

int n;
struct Node
{
    int a, b, c;
    bool operator< (const Node &t) const
    {
        return c > t.c;
    }
}q[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= 2 * n; ++ i )
        cin >> q[i].a;
    for (int i = 1; i <= 2 * n; ++ i )
        cin >> q[i].b, q[i].c = q[i].a - q[i].b;
    
    sort(q + 1, q + 2 * n + 1);
    
    LL res = 0;
    for (int i = 1; i <= n; ++ i )
        res += q[i].a;
    for (int i = n + 1; i <= n * 2; ++ i )
        res += q[i].b;
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：jsisonx (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11960)

# 题目分析

首先不难发现，每个物品只能被 B 或 C 买走，因此对每个物品决策要卖给谁。

我们可以先将所有物品卖给 B。这样的话，B 买到了 $2n$ 个物品，因此 C 要拿走 $n$ 个。那么要拿哪些呢？注意到，若 C 从 B 手上拿走了第 $i$ 个物品，则收入增加 $c_i-b_i$。显然我们希望上述式子越大越好。那么我们可以对所有物品按照 $c_i-b_i$ 从小到大排序，B 拿走前 $n$ 个，C 拿走后 $n$ 个，这样即可保证 C 拿走的物品 $c_i-b_i$ 之和最大。

# 代码


```cpp
#include<bits/stdc++.h>
#define N 1000001
using namespace std;
int n,a[N],b[N],c[N];
long long ans=0;
struct sh{
	int x,y,id,c;
}s[N];
int cmp(sh d,sh e){
	return d.c<e.c;
}
int main(){
	cin>>n;
	for(int i=0;i<2*n;i++){
		cin>>a[i];
	}
	for(int j=0;j<2*n;j++){
		cin>>b[j];
	}
	for(int i=0;i<2*n;i++){
		s[i].x=a[i];
		s[i].y=b[i];
		s[i].id=i;
		s[i].c=b[i]-a[i];
	}
	sort(s,s+2*n,cmp);
	for(int i=0;i<n;i++){
		ans+=a[s[i].id];
	}
	for(int i=n;i<2*n;i++){
		ans+=b[s[i].id];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：tomAmy (赞：1)

~~水题，作用：为下文做铺垫~~

## 思路：

要想收入最大当然要挑贵的卖，那怎么定义贵呢？

考虑作差。令 $d_i = c_i - b_i$（也就表示卖给小 C 比卖给小 B 贵多少），排一下序，把 $d_i$ 更大的 $n$ 个卖给小 C，剩下卖给小 B。

求和时只要先算出卖给小 B $2n$ 个的总价，再加上卖给小 C $n$ 个的 $d_i$ 即可。

贴上代码：

```cpp
#include <iostream>
#include <algorithm>
// 记得开 long long
#define int long long
using namespace std;

const int N = 2e5 + 5;
int a[N], b[N], d[N];

bool cmp(int x, int y)
{
	return x > y;
}

signed main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= 2 * n; i++) cin >> a[i];
	for (int i = 1; i <= 2 * n; i++) cin >> b[i];
	for (int i = 1; i <= 2 * n; i++) d[i] = b[i] - a[i];
	sort(d + 1, d + 2 * n + 1, cmp);
	int sum = 0;
	for (int i = 1; i <= 2 * n; i++) sum += a[i];
	for (int i = 1; i <= n; i++) sum += d[i];
	cout << sum << endl;
	return 0;
}
```

---

## 作者：lby_commandBlock (赞：1)

## 思路

一道贪心好题。

这道题我们可以假设首先每个物品都由小 B 来买，然后来看由小 C 来买对答案的贡献，最后取最大的贡献即可。

其中，小 C 来买的贡献即 $c_i$ 就是 $b_i-a_i$，可负可正。

**重要提示**：请打开你的 `long long`。

## 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N = 2e5+9;

int n, a[N], b[N], c[N];

/*
 * a：小 B 的出价
 * b：小 C 的出价
 * c：小 C 来买对答案的贡献
 */

long long ans; //千万别忘记 long long

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n * 2; i++)
		cin >> a[i];
	for (int i = 1; i <= n * 2; i++)
		cin >> b[i];
	for (int i = 1; i <= n * 2; i++) {
		// 默认小 B 进行购买
		ans += a[i];
		// 同时计算此时小 C 购买的贡献
		c[i] = b[i] - a[i];
	}
	// 最大化贡献 使答案更优
	sort(c + 1, c + 1 + n * 2);
	// 选最后 n 个就是最大的答案了
	for (int i = n * 2; i >= n + 1; i--)
		ans += c[i];
	cout << ans << endl;
	return 0;
}

// 最后：别忘记 long long！
```

---


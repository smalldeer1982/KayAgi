# 智力大冲浪

## 题目描述

小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴，因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：

首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!


## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 500$，$1 \le m \le 5 \times 10^5$，$1 \le t_i \le n$，$1 \le w_i \le 1000$。

## 样例 #1

### 输入

```
10000
7
4 2 4 3 1 4 6
70 60 50 40 30 20 10
```

### 输出

```
9950```

# 题解

## 作者：ShineEternal (赞：532)

# 前言：

一年不来发现点赞已经那么多了，占了一楼，而题解却是无脑搬运，想整改一下，争取给大家最新的阅读体验，如果本题解对你有帮助就请不吝赐赞。

# 题目链接:
https://www.luogu.org/problem/P1230

# 分析：

这道题我们每完不成一个任务就要扣钱，而想让自己最后的钱最多，就是扣的钱最少，而我们可以**贪心**的让能扣钱最多的排在最前面考虑，因为它的影响最大。

这时候用sort就行
```cpp
sort(a+1,a+n+1,cmp)
```

为什么要用cmp？因为包含了结构体

```cpp
struct ben
{
	int t,val;
}a[505];
```

注意此时cmp需要手写

```cpp
int cmp(const ben &a,const ben &b)
{
	return a.val>b.val;
}
```

**注意其中>与<的区别**

然后我们直觉的思路就是设一个时间记录器来每次++判断。

但这是一个错误的贪心，按照样例来算答案会是9900

因为我们在保证花费降序时对时间要求完全是一个杂乱无章的处理。

可能值钱的任务时间限制也宽，有些即使不值钱的任务也容易超时，然而此时却完全可以避免那个即使便宜的任务的损耗。

我们考虑最优贪心，就是每一个任务都在最后一秒做，因为时间$\leq500$,可以设一个vis数组记录此时间是否被占用，当然，如果最后一秒被占用，就依次往前推，直到找到

在越往后做，才能给其他时间紧的任务腾出时间，而又优先考虑大任务的完成，如果本任务已经没时间了就真的只能掏钱了。。。


# code:

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct ben
{
	int t,val;
}a[505];
int vis[505];
int cmp(const ben &a,const ben &b)
{
	return a.val>b.val;
}
int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i].t);
	} 
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i].val);
	} 
	sort(a+1,a+n+1,cmp);
	int ans=0,t=0;
	for(int i=1;i<=n;i++)
	{
		int tag=0;
		for(int j=a[i].t;j;j--)
		{
			if(vis[j]==0)
			{
				vis[j]=1;
				tag=1;
				break;
			}
		}
		if(tag==0)
		{
			for(int j=n;j;j--)
			{
				if(vis[j]==0)
				{
					vis[j]=1;
					break;
				}
			}
			ans+=a[i].val;
		}
	}
	printf("%d\n",m-ans);
	return 0;
}
```


# 以下为旧版题解，有需要者可搭配食用
----

我又来了。。。

------------
思路：

因为不同的小游戏不能准时完成时具有不同的扣款权数，而且是求问题的最优解，所以很容易想到用贪心算法求解。


贪心策略是让扣款数额大的尽量在规定的期限内完成，这样我们就先把这些任务按照扣款的数额进行排序，把大的排在前面，进行放置。

假如罚款最多的一个任务的完成期限是k，我们应该放在小于等于k的最靠后的时间段。

一旦出现一个不可能在规定期限内完成的任务，则把其扔到最大的一个空时间段，因为不能完成的任务在任意一个时间段中罚款数额都是一样的，这样得到的结果必然是最优的。

**时间复杂度:O(n^2)**

**by 一本通**

```
#include<cstdio>
#include<algorithm>
using namespace std;
int hash[5000001]; 
struct ben
{
	int x,y;
}a[501];
int cmp(const ben &a,const ben &b)
{
	return a.y>b.y;
}
int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i].x);//完成期限
	for(int i=1;i<=n;i++)scanf("%d",&a[i].y);//罚款
	sort(a+1,a+n+1,cmp);//按照罚款数额从大到小进行选择排序
	int bj=0;
	int s=0;
	for(int i=1;i<=n;i++)
	{
		bj=1;
		for(int j=a[i].x;j>=1;j--)
		{
			if(hash[j]==0)
			{
				bj=0;
				hash[j]=1;
				break;
			}
		}
		if(bj==1)//要罚款
		{
			for(int k=n;k>=1;k--)
			{
				if(hash[k]==0)
				{
					hash[k]=1;
					break;
				}
			}
			s+=a[i].y;//累加罚款
		}
	}
	printf("%d",m-s);
	return 0;
}
```

只求二事：

过和赞

---

## 作者：三问不知、、 (赞：57)

   这道题一看就是标准的贪心题。直接上思路。
思路：因为题中的小游戏都是在1分钟完成的，所以我们并不需要考虑时间所带来的影响，和背包问题就有所不同，可以直接上贪心来做。

   第一点，先完成会罚款高的游戏明显明显更有益（时间消耗相同），所以，先要对游戏的罚款进行排序（从大到小）。
   
   第二点，排完序后，就要考虑这个游戏放在那个时间来做，很明显，我们要先处理罚款大的项，而又尽量不影响后面的游戏，只能将这个游戏放在规定最晚完成的时间段0-t的最后面t来做，若后面已经有游戏正在进行，可以考虑t-1，直到0，如果还没有对它进行安排，则这个游戏主动放弃0
   
   最后，将放弃的游戏的罚款减去，即为所求解。
   
   附上代码
   ```c
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct lao{
	int t,f;
	
}a[300000];// t代表最晚完成时间，f代表罚款。 
bool used[100000]={0};//统计这个时间是否被游戏占领。 
bool cmp(const lao &x,const lao &y)
{
	return x.f>y.f;//返回罚款较大的。 
}
int main()
{
	int s=0,b;
	int m,n,i,j;
	scanf("%d%d",&m,&n);
	for(i=1;i<=n;i++)
	scanf("%d",&a[i].t);
	for(i=1;i<=n;i++)
	scanf("%d",&a[i].f);
	sort(a+1,a+1+n,cmp);//根据罚款进行从大到小排序。 
    for(i=1;i<=n;i++)//从罚款最大的游戏进行处理。 
    {
  
    	for(j=a[i].t;j>=1;j--)//从最晚完成的时间判断，若被占领，则向前一步判断。 
    	{
    		if(used[j]==0)//代表该时间无游戏占领。 
    		{
    			used[j]=1;
    			a[i].f=0;//将占领的游戏的罚款变为零，因为按时完成了吗。 
    			break;//重点，保证一个游戏只占领一个时间。占领后立刻结束循环。 
			}
		}
    	
    	
    	
	}
	for(i=1;i<=n;i++)
	s=a[i].f+s;//统计罚款的总额 
	m=m-s;//m即为小伟最多能赢的钱。 
	printf("%d",m);
	
}
```

---

## 作者：Deny_小田 (赞：47)

小田又来发题解啦~~

看没有C++题解  果断一发

刚开始没有看懂，后来才明白，给大家说说：

样例：

10000
7
4 2 4 3 1 4 6

70 60 50 40 30 20 10


注意，是 游戏是在时间段上的，不是说扣钱70的游戏需要花费4个单位时间，而是说扣钱70的游戏可以在1~4  的时间段里玩。

剩下的就挺好办喽~~

时间段：

1    2    3    4    5    6    7

70  60  40  50  10  --   --


由此可见，扣分20和30  的游戏未完成，共扣50分，故最终为9950  （10000-50 == 9950）


附上AC代码：







    

```cpp
#include <cstdio>
#include <algorithm>
#define Size 510
using namespace std;
typedef struct _Every{
    int t,w;
}Every;
Every e[Size];
int flag[Size] = {0};
int cmp(Every a,Every b){
    return a.w > b.w;
}
int main(){
    int p,n;
    scanf("%d %d",&p,&n);
    for(int i = 0; i < n; i++) scanf("%d",&e[i].t);
    for(int i = 0; i < n; i++) scanf("%d",&e[i].w);
    sort(e,e+n,cmp);         //快排
    for(int i = 0; i < n; i++){
        int h = -1;               //h  标记位
        for(int j = e[i].t; j >= 1; j--) if(!flag[j]){ h = j; break; }        //注意，必须是倒序！！！ 上回就被坑了
        if(h != -1) flag[h] = 1;
        else p -= e[i].w;
    }
    printf("%d\n",p);
    return 0;
}
望采纳-------------------------------END----------------------------
```

---

## 作者：wancong (赞：23)

## 蜜汁贪心

怎么贪？~~贪几个亿？~~（我一分钱都不敢花，老秦人穷怕了）

如果截止时间靠前的先做，那样例顺序就是(1,30) (2,60) (3,40) (4,70) (4,50) (4,20) (6,10)，损失80，答案9920

如果罚款多的先做，样例顺序就是(4,70) (2,60) (4,50) (3,40) (1,30) (4,20) (6,10)，损失60，答案9940

说明这两种方法都！不！行！

我们可以这么思考：如果一个活动铁定超时，那么它无论什么时候完成，罚款都相等。所以，如果它超时，那就破罐子破摔，扔到最后做，这样就给其它要求限时完成的任务腾出时间。（发散思维：如果罚款数目和超时时间成正比，这题就不能用贪心了，而且至少是蓝题难度）

因此可以按照截止时间排序，然后按截止时间分配任务。如果截止时间t之前分配了超过t件任务，说明有铁定超时的任务了。我们需要放弃一些任务，显然，放弃罚款最小的几个是最优选择。

模拟一下我们的样例：

```
1: (1, 30)
2: (2, 60)
3: (3, 40)
4: (4, 70) (4, 50) (4, 20)
5: ∅
6: (6, 10)
```

t=4处多出两个任务，因此在t<=4范围内放弃两个任务，显然罚款最小的是(4, 20)和(1, 30)。其余的地方没有溢出的任务，因此最终损失是50，得到9950元。

根据描述，每次分配任务都要添加进任务队列，而放弃的时候删除罚款最小的，因此优先队列是不二选择。

这样，每个任务最多被放入优先队列一次，弹出一次，再加上预处理排序，总的时间复杂度为$O(nlogn)$。

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

typedef struct {
    int t;
    int f;
} game;
game arr[1000];

bool cmp(game a, game b) {
    return a.t < b.t;
}

priority_queue<int, vector<int>, greater<int> > q; // 注意是小顶堆

int main() {
    int m, n, i, t, ans = 0;
    scanf("%d %d", &m, &n);
    for (i = 0; i < n; i++) scanf("%d", &arr[i].t);
    for (i = 0; i < n; i++) scanf("%d", &arr[i].f);
    sort(arr, arr + n, cmp);
    t = arr[0].t;
    for (i = 0; i < n; i++) {
        if (arr[i].t > t) {
            while (q.size() > t) {
                ans += q.top();
                q.pop();
            }
            t = arr[i].t;
        }
        q.push(arr[i].f);
    }
    while (q.size() > t) {
        ans += q.top();
        q.pop();
    }
    printf("%d", m - ans);
    return 0;
}
```

---

## 作者：Capitalism_Gao (赞：15)

**1.A :题面**

 [题目描述]

小伟报名参加中央电视台的智力大冲浪节目。
主持人先奖励每个参赛者m元。接下来主持人宣  布了比赛规则：

首先，比赛时间分为n个时段(n≤500)，它又给出了很多小游戏，每个小游戏都必须在规定期限ti前完成(1≤ti≤n)。如果一个游戏没能在规定期限前完成，则要从奖励费m元中扣去一部分钱wi，wi为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!

 [输入]

第1行为m，表示一开始奖励给每位参赛者的钱；
第2行为n，表示有n个小游戏；
第3行有n个数，分别表示游戏1到n的规定完成期限；
第4行有n个数，分别表示游戏1到n不能在规定期限前完成的扣款数。

 [输出]
 
 仅1行。表示小伟能赢取最多的钱。
 
 1.B:吐槽:可以看到这道题你n<=500,故可以轻易承受O(N^2)的时间复杂度。
 
 **2.A:算法思想:金钱贪心**
 
 采用贪心策略，既然要使扣的钱最少，也就是得的钱最多，所以我们就要尽可能的完成money多的任务。
 
 故可以先按照money从大到小排序，如果能完成此任务就在时间轴上离它期限最近的地方打标记，表示此时间点不能再用了。
 
 如果实在不能做就直接跳过，因为我们是按照money从大到小排序，所以你只能选择放弃money小的来保证前面money大的。
 
2.A.(1):O(N^2)暴力法 
 ```
#include<bits.stdc++.h>

using namespace std;

int read(){//快读占一下篇幅
	int res=0,f=1;char ch;
	while(isspace(ch=getchar()));
	if(ch=='-') f=-1,ch=getchar();
	do{
		res=res*10+ch-'0';
	}while(isdigit(ch=getchar()));
	return f*res;
}

struct node{
	int t,w;
}a[501];
bool vis[501];

bool cmp(node x,node y){
	return x.w>y.w;
}//按照money从大到小排序

int main(){
	ios::sync_with_stdio(false);
	
	int money=read();
	int n=read();
    int ans=0;
	for(int i=1;i<=n;i++) a[i].t=read();
	for(int i=1;i<=n;i++) a[i].w=read();
	sort(a+1,a+1+n,cmp);
	
	for(int i=1;i<=n;i++){
	    for(int j=a[i].t;j>=1;j--){//从后往前遍历这个期限前面所有的时间点
		   if(!vis[j]){//时间点还可以用
			vis[j]=true;//打标记
			ans+=a[i].w;//加上资金
			break;//能用直接跳出
		  }
	    }
	}
	
	cout<<ans;
	return 0;
}
```
 **2.A.(2)优化O(N^2)**
 
 我们维护一个unable:它表使截止目前0~unable这个时间段上所有点都被占用。
 所以如果遇到ai.t<=unable,就直接continue，省下O(ai.t)时间复杂度；
 ```
#include<iostream>
#include<cstdio>
#include<cstring> 
#include<algorithm>
#define max(a,b) a>b?a:b

using namespace std;

int read(){
	int res=0,f=1;char ch;
	while(isspace(ch=getchar()));
	if(ch=='-') f=-1,ch=getchar();
	do{
		res=res*10+ch-'0';
	}while(isdigit(ch=getchar()));
	return f*res;
}

bool vis[1000000];//v是判断当前期限的学分是否获取过 
struct node{
	int t,w;
}a[1000001];

bool cmp(node x,node y){
	return x.w>y.w;
}
int main(){
	memset(vis,false,sizeof(vis));
	int n=read();
	for(int i=1;i<=n;i++){
		a[i].t=read();
		a[i].w=read();
	}
	sort(a+1,a+n+1,cmp);
	long int ans=0,unable=0;//unable表示1~unable时间段已被占满
	                   //因为按照分数的降序排列，
					   //所以如果后面有学分的期限在1~unable中，
					   //直接跳过，省下O(n)时间复杂度 
	for(int i=1;i<=n;i++){
		if(a[i].t<=unable) continue;	
		bool f=false;//f来判断是否要刷新unable 
		for(int j=a[i].t;j>unable;j--){
			if(vis[j]==false){
				vis[j]=true;
				ans+=a[i].w;//增加学分 
				f=true;
				break;
			}
		}
		if(f==false) unable=a[i].t;//维护unable 
	}
	cout<<ans; 
	return 0;
}
```
**2.B:算法思想:时间贪心**

将任务按时间从小到大排序，如果排满，就找一个罚款最小的踢掉。如果这个任务罚款最小，那就不做。

**2.B.(1)考虑用小根堆来优化:**

```
#include<bits/stdc++.h>
#define max(a,b) a>b?a:b 
using namespace std;

int read(){
	int res=0,f=1;char ch;
	while(isspace(ch=getchar()));
	if(ch=='-') f=-1,ch=getchar();
	do{
		res=res*10+ch-'0';
	}while(isdigit(ch=getchar()));
	return f*res;
}

const int maxn=100001;
struct node{
	int t,w;
}a[maxn];
priority_queue< int,vector<int>,greater<int> >Q;

inline bool cmp(node x,node y){
	return x.t<y.t;
}//按照time从小到大排序

int main(){
	ios::sync_with_stdio(0);
	
	int money=read();
	int n=read(),kou=0;
	for(int i=1;i<=n;i++) a[i].t=read();
	for(int i=1;i<=n;i++) a[i].w=read();
	sort(a+1,a+1+n,cmp);
	
	for(int i=1;i<=n;i++){
	    if(a[i].t>Q.size()) Q.push(a[i].w);
	    else if(Q.top()<a[i].w) {
	    	kou+=Q.top();
	    	Q.pop();
	    	Q.push(a[i].w);
		}
		else kou+=a[i].w;
	}
	
	money-=kou;
    cout<<money;
	return 0;
}
```
**2.B.(2)手写小根堆**

我们不难发现，当a[i].w>Q.top()时，我们需要把对顶弹出，然后再把a[i].w压入队里，两种操作时间复杂度皆为O(logn)，故循环内。所以我们可以考虑手写小根堆，push()操作不变，把Q.pop()与Q.push(a[i].w)直接写成changetop(),把直接把队顶元素改成a[i].w然后再维护次队列，时间复杂度变为O(logn)。

```
#include<bits/stdc++.h>
#define max(a,b) a>b?a:b 
using namespace std;

int read(){
    int res=0,f=1;char ch;
    while(isspace(ch=getchar()));
    if(ch=='-') f=-1,ch=getchar();
    do{
        res=res*10+ch-'0';
    }while(isdigit(ch=getchar()));
    return f*res;
}

const int maxn=10000001;
struct node{
    int t,w;
}a[maxn];
int Q[maxn];
int len;

inline void push(int d){
	Q[++len]=d;
	int now=len,next;
	while(now>1){
		next=now>>1;
		if(Q[next]<=Q[now]) break;
		swap(Q[next],Q[now]);
		now=next;
	}
}

inline void changetop(int d){
	Q[1]=d;
	int now=1,next;
	while((now<<1)<=len){
		next=now<<1;
		if(next+1<=len&&Q[next]>Q[next+1]) next++;
		if(Q[next]>=Q[now]) break;
		swap(Q[next],Q[now]);
		now=next;
	}
}

inline bool cmp(node x,node y){
    return x.t<y.t;
}//按照time从小到大排序

int main(){
    ios::sync_with_stdio(0);

    int money=0;
    int n=read(),kou=0;
    for(int i=1;i<=n;i++) {
        a[i].t=read();
        a[i].w=read();
        money+=a[i].w;
    }
    sort(a+1,a+1+n,cmp);

    for(int i=1;i<=n;i++){
        if(a[i].t>len) push(a[i].w);
        else if(Q[1]<a[i].w) {
            kou+=Q[1];
            changetop(a[i].w);
        }
        else kou+=a[i].w;
    }

    money-=kou;
    cout<<money;
    return 0;
}
```



**2.C:算法思想:模拟**


把此题当成允许座位问题:
1. 刚开始第i个任务有a[i].t个时间点可存放；
2. 按照money大小从大到小排序；
3. 如果a[i].t>0,表明当前任务还有时间点可选,就选此任务,ans+=a[i].w,此时这个任务就占了a[i].t这个时间点,所以后面凡是能占此时间点(即a[j].t>=a[i].t)的任务的可获得时间点数都要减1;
4. 如果a[i].t=0,直接跳过。 

2.C.(1)O(N^2)暴力法
```
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

int n,m,ans;
struct node{      
    int t,w;    
}a[501];

inline bool cmp(node a,node b){
    return a.w>b.w;
} 

int main(){
	
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i].t);  
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].w); 
    }
    sort(a+1,a+1+n,cmp);
    
    for(int i=1;i<=n;i++){
        if(a[i].t>0){//如果有时间完成，就完成。
            ans+=a[i].w;
            for(int j=i+1;j<=n;j++) //完成后，所有能占此时间点的，都-1
                if(a[i].t<=a[j].t) 
                a[j].t--;
        }
		else continue;
    }
    printf("%d",ans);
    return 0;
 }
```

**2.C.(2)优化O(N^2)**

我们先建立一个时间轴:

1. 这个轴上涵盖了所有任务的所有时间点，也就是1~maxtime; 
2. 刚开始，第i个点的可选时间点为i个;
3. 如果第i个时间点的可选时间点>0，则选取第i个时间点，此时我们就不难发现第i个时间点的所剩时间点数就等于第i-1个时间点的所剩时间点数，则此时我们就要查找i-1这一时间点最早能转化成的那个时间点，那么我们就引入并查集；

```
#include<bits/stdc++.h>
#define max(a,b) a>b?a:b 
using namespace std;

int read(){
	int res=0,f=1;char ch;
	while(isspace(ch=getchar()));
	if(ch=='-') f=-1,ch=getchar();
	do{
		res=res*10+ch-'0';
	}while(isdigit(ch=getchar()));
	return f*res;
}

const int maxn=100001;
struct node{
	int t,w;
}a[maxn];
bool vis[maxn];
int fa[maxn];

inline bool cmp(node x,node y){
	return x.w>y.w;
}//按照money从大到小排序

inline int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}

int main(){
	ios::sync_with_stdio(0);
	
	int money=read(),maxtime=0;
	int n=read(),kou=0;
	for(int i=1;i<=n;i++) {
		a[i].t=read();
		maxtime=max(a[i].t,maxtime);
	}
	for(int i=1;i<=n;i++) a[i].w=read();
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=maxtime;i++) fa[i]=i;
	
	for(int i=1;i<=n;i++){
	    int ancx=find(a[i].t);
	    if(ancx) //ancient(x)>0表明还有时间点可选
	    	fa[ancx]=ancx-1;//做了此任务后转化它的所剩时间点数,即将它的祖先的父亲改为此祖先减1
		else 
			kou+=a[i].w;
	}
	
	money-=kou;
    cout<<money;
	return 0;
}
```

**3:各种方法的比较**

在大数据(百万到千万之间)下：

1. 金钱贪心：TLE   
2. 时间贪心：TLE 
3. 暴力模拟：TLE
4. 维护unable优化金钱贪心：474 MS
5. 优先队列优化时间贪心：394 MS
6. 并查集优化模拟：391 MS
7. 手写changetop()化O(2*logn)为O(logn)：359 MS

 

---

## 作者：zhuaiballl (赞：15)

把所有题解看了一遍也没有看到和我做法一样的呢。  
从最后一个时刻开始向前处理，在还没有安排且deadline不早于当前时刻的所有小游戏中，选择价值最大的，安排在这一时刻。  
正确性很显然，比如在最后一个时刻，能做（能减少损失）的小游戏只有deadline等于n的，当然从中选择价值最大的；倒数第二个时刻也是同样的道理，且这一做法显然无后效性。  
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct game
{
    int ddl,worth;
    bool operator <(const game &t)const{return worth<t.worth;}
}gm[1010];
bool cmp(game &a,game &b){return a.ddl<b.ddl;}
priority_queue<game> Q;
int main()
{
    int m,n;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)scanf("%d",&gm[i].ddl);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&gm[i].worth);
        m-=gm[i].worth;
    }
    sort(gm+1,gm+n+1,cmp);
    int flg=n;
    for(int i=n;i>=1;i--)
    {
        while(flg&&gm[flg].ddl>=i)Q.push(gm[flg--]);
        if(Q.empty())continue;
        m+=Q.top().worth;
        Q.pop();
    }
    return 0*printf("%d\n",m);
}

```

---

## 作者：皮卡丘最萌 (赞：10)

这是一个典型的贪心题。

因为题目要求赢取最多的钱，所以我们先对钱数进行从大到小排序：
比如：

6

4  5  3  5  1  1

20 40 10 60 30 24

排序后变为：

5  5  1  1  4  3

60 40 30 24 20 10

接下来我们定义一个f数组，用来保存每个时间是否做过。

比如第一个数5，根据贪心的策略，我们把它放在F[5]的位置。

第二个数5，根据贪心的策略，我们把它放在F[5]的位置，却发现F[5]已经做过了，所以一直往前推，直到找到一个没有做过的位置，并改变这个位置的状态，所以F[4]也变成做过。

第三个数1，根据贪心的策略，我们把它放在F[1]的位置。

第四个数1，根据贪心的策略，我们把它放在F[1]的位置，却发现F[1]已经做过了，所以一直往前推，但是我们发现前面已经没有空的位置了，所以此时用总钱数减去这个问题的扣款数。


------------

按照这个思路，就可以编出一下代码：

```pascal
var n,m,i,j:longint; 
a,b:array[0..100001] of longint; 
f:array[0..100001] of boolean;
procedure sort(l,r: longint);
      var i,j,x,y,x1: longint;
      begin
         i:=l;j:=r;
         x:=a[(l+r) div 2];
         x1:=b[(l+r) div 2];       //求中间值
         repeat
           while (b[i]>x1)or(b[i]=x1)and(a[i]<x) do inc(i);  //夹逼
           while (b[j]<x1)or(b[j]=x1)and(x<a[j]) do dec(j);
           if not(i>j) then
             begin
             y:=a[i];a[i]:=a[j];a[j]:=y;
             y:=b[i];b[i]:=b[j];b[j]:=y;        //交换
             inc(i);j:=j-1;
             end;
         until i>j;
         if l<j then sort(l,j);
         if i<r then sort(i,r);
      end;                 //快排不解释，注意双关键字，先按扣款数从大到小排序，一样的按时间从小到大排序。
begin
readln(m); 
readln(n);
for i:=1 to n do read(a[i]);
for i:=1 to n do read(b[i]);               //读入数据
sort(1,n);
for i:=1 to n do                         //一个一个判断
  begin
  j:=a[i];                               //默认这个位置没有做过
  while f[j]=true do dec(j);      //向前找，直到找到一个没有做过的位置
  if j=0 then dec(m,b[i])             //找不到就扣去扣款数
    else f[j]:=true;                  //找得到就把这个位置设成做过
  end;
writeln(m);                        //输出剩余钱数。
end.

```


---

## 作者：circlegg (赞：6)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int m,n;
bool vis[501];//记录这段时间是否被其他任务占用
struct task{
    int t,w;//每个任务的时间、价格
}a[501];
bool cmp(struct task a,struct task b)
{
    return a.w>b.w;
}
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].t);
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].w);
    }
    sort(a+1,a+1+n,cmp);//需要将任务进行价格的排序，价格高的优先确定位置
    for(int i=1;i<=n;i++){
        for(int j=a[i].t;j>=1;j--){//从后往前看，因为如果这段时间都可以完成任务，
                                          //且效果相同，为何不把靠前的时间留给需要早完成的任务呢？
            if(!vis[j]){
                vis[j]=1;//占时间，标记
                break;
            }
            if(j==1&&vis[1]){
                m-=a[i].w;//循环到头也没有空着的时间，无法完成任务，减去价格
                break;
            }
        }
    }
    printf("%d",m);
    return 0;
}
```

---

## 作者：EarthGiao (赞：5)

## 【思路】

贪心 + 排序   
这是一道很有意思的贪心题目   
有点类似之前做过的一本通评测网站上的那个游戏通关   

先说一下贪心思想   
贪心，当然是局部解最优以致最终解最优   
这道题目的局部解就是每个时间单位的解最优   
何为最优？就是能够完成如果不完成就会减去最多钱的那个小游戏  
这样再该时间单位内，减去的钱就会在可能的条件下最少化  
会留下更多的钱   
  
不过，这个题还有一点难度的   
就是假如我在时间点a有一个任务，我是可以在时间点a - 1 到 1来完成的    
这就导致了正序枚举的不可行性，所以就必须到着枚举    
这是很容易忽略的地方哦    
这个就可以用到神奇的stl了！   
因为后面的任务在前面的时间点都是可以完成的   
所以用一个优先队列，    
将每个是当前时间点能够完成的任务都放到优先队列里面   
然后每个时间点都挑出来里面减去的钱最多的完成   
这样就会减去最少的钱了  

最后只需要把优先队列里面的剩下需要减去的钱减去就可以了    

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm> 
#include<queue>
using namespace std;
priority_queue<int>s;
struct node
{
	int t,v;
}a[505];
bool cmp(const node x,const node y)
{
	return x.t > y.t;
}

int main()
{
	int n,m;
	scanf("%d%d",&m,&n);
	for(int i = 1;i <= n;++ i)
		scanf("%d",&a[i].t);
	for(int i = 1;i <= n;++ i)
		scanf("%d",&a[i].v);
	sort(a + 1,a + 1 + n,cmp);
	int js = 1;
	for(int i = n;i >= 1;i --)
	{
		while(a[js].t >= i)
		{
			s.push(a[js].v);
			js ++;
		}
		if(!s.empty())
		s.pop();
	}
	while(!s.empty())
	{
		m -= s.top();
		s.pop();
	}
	cout << m << endl;
	return 0;
}
```

---

## 作者：百里亦守约_test (赞：5)

看大神们都用了排序，我就贴一个非排序用二维数组来做的题解。

先讲思路：

10000
7
4 2 4 3 1 4 6

70 60 50 40 30 20 10

我们可以转换一下：

时间    做的事

1:        70 60 50 40 30 20 10

2:        70 60 50 40 20 10

3:        70 50 40 20 10

4:        70 50 20 10

5:        10

6:        10

7:
第一个时间段：

1:        70 60 50 30 20 10

2:        70 60 50 20 10

3:        70 50 20 10

4:        70 50 20 10

5:        10

6:        10

7:
第二个时间段：

1:        70 50 30 20 10

2:        70 50 20 10

3:        70 50 20 10

4:        70 50 20 10

5:        10

6:        10

7:
第三个时间段：

1:        70 30 20 10

2:        70 20 10

3:        70 20 10

4:        70 20 10

5:        10

6:        10

7:
第四个时间段：

1:        30 20 10

2:        20 10

3:        20 10

4:        20 10

5:        10

6:        10

7:
第五个时间段：

1:        30 20

2:        20

3:        20

4:        20

5:
6:
7:
后面都不可以做任何事了，虽然图上还剩4个20和1个30，但是20是可以在1到4的时间段才能做的，30是在1的时间段才能做的，所以就只有1个30和1个20，那么10000减去30减去20就可以得出9950了。

但是从正面的角度上是没有规律的，但是我们可以到过来看一看，就可以发现了每个时间段可以做当时可以做的分值最大的小游戏，然后就知道最后剩下的就是不能做的了。

附源程序：

```cpp
var n,m,i,max,j,k:longint;
    s:array[-100..1000,-100..1000] of longint;   //定义一个二维数组。
    x,z,w:array[-100..100000] of longint;
begin
  readln(n);
  readln(m);
  for i:=1 to m do
    read(x[i]);
  for i:=1 to m do    //读入。
    read(z[i]);
  for i:=1 to m do
  begin
    for j:=1 to x[i] do
    begin
      inc(w[j]);
      s[j,w[j]]:=z[i];    //存在那个时间段。
    end;
  end;
  for i:=m downto 1 do
  begin
    max:=0;
    for j:=1 to w[i] do
      if(max<s[i,j]) then  max:=s[i,j];  //判断是不是分值最大的小游戏。
    if(max>0) then
    begin
      for j:=1 to m do
        if(z[j]=max) then  begin z[j]:=0; break; end;    //找出来并可以完成。
      for j:=1 to i do
        for k:=1 to w[j] do
          if(s[j,k]=max) then begin s[j,k]:=-1; break; end;   //模拟。
    end;
  end;
  for i:=1 to m do
    if(z[i]>0) then n:=n-z[i];    //如果没有标记的话就是做不了的，所以就可以减掉他。
  write(n);  //输出。
end.
这一题就是考我们模拟。（对我来说是主要的）
```

---

## 作者：wudiss8 (赞：2)

蒟蒻第一次发题解，讲的不好,大家谅解一下awa

本题是一个很典型的贪心，本蒟蒻的思路就是：
让扣得钱最少。
为了扣钱最少，所以我们就得先完成扣钱多的项目。

此时，还有时间限制，那么我们就要节省时间，所以在完成任务当前提下，就将任务尽量向后安排。

所以，代码结构就是：

先将任务按扣钱数从大到小快排；

然后再按此顺序安排任务，时间在期限内尽量靠后；

没有完成的任务，就用奖金减去他们；

输出答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct th {
	int t,w;
} li[100000];
bool cmp(th x,th y) {
	return x.w>y.w;
}
bool flag[1000000];
bool ap(int x) { //该函数通过从前往后搜索，寻找可完成任务的最后部的时间 
	if(!flag[x]){
        flag[x]=true;
        return 1;
    }else if(flag[x] and x!=1){
		if(ap(x-1))
		return 1;
	}
	return 0;
}
int main() {
	int m,n,i;

	cin>>m;
	cin>>n;
	for(i=1; i<=n; i++)
		cin>>li[i].t;
	for(i=1; i<=n; i++)
		cin>>li[i].w;

	sort(li+1,li+n+1,cmp);//按罚款从大到小快排 

	for(i=1; i<=n; i++) {
		if(ap(li[i].t))//如果找到可完成任务的最后部的时间，下一个循环 
		continue;
		else
		m=m-li[i].w;//如果未能找到，就扣钱 
	}
	cout<<m<<endl;
	return 0;
}
```

蒟蒻第一次写题解，请大家多多指教qwq 

---

## 作者：独一无二 (赞：2)

## pair做法  

---
看了题解，貌似没有用pair做的（~~pair方便快捷~~），我就顺手发一篇……  
~~这是本蒟蒻第一次发题解，可能有些毒瘤，请见谅~~   

---
我们先审题，题目说***想要赢取更多的钱***，很显然，这是一道典型的**贪心**题目……  

首先，我们要知道贪心的**对象**和**方向**，在本题中，贪心的对象就是**扣款数**，我们要让它**尽可能地小**……

然后，我们还要知道贪心的**限度**，在本题中就是**时间**，我们不能超出时间来贪心……  

所以，我们要把**扣款数大的放在前面完成**，也就是说，尽可能在有限的时间内，完成扣款多的任务……  

接着，我们考虑完不成的任务，如果有一个不可能在有限时间内完成的任务，**就把它放到最大的空时间段**……简单地说，就是，反正也完不成，就不要浪费做别的任务的时间  

---
~~理解了这些，代码实现就不是问题~~  
以下是本蒟蒻的ac代码  

---
```cpp
#include<bits/stdc++.h>  
using namespace std;  
const int M=6e6+6;  
int m,n;  
int WA=0;//记录扣款数  
bool bol[M];//标记时间是否被用过  
bool k=false;//记录是否需要罚款  
pair<int,int> a[M];//开一个pair数组  
int main(){  
	cin>>m>>n;  
	for(int i=1;i<=n;i++){  
		cin>>a[i].second;//规定完成的期限  
	}  
	for(int i=1;i<=n;i++){  
		cin>>a[i].first;//扣款数（放在first便于排序） 
	}  
	sort(a+1,a+n+1);//sort自动对 a[i].first 排序
	//sort从小到大排序 我们要把扣款数大的放在前面 所以倒着来  
	for(int i=n;i>=1;i--){  
    	k=true;//假设需要罚款  
    	for(int j=a[i].second;j>=1;j--){  
            if(!bol[j]){//如果时间没被用过  
                k=false;//不需要罚款  
                bol[j]=true;//标记这一时间被使用过  
                break;//结束循环  
            }  
        }  
        if(k){//如果需要扣款（上面的循环不成立）  
            for(int g=n;g>=1;g--){  
			//把罚款最多的一个任务（完成期限是g）放在小于等于g的最靠后的时间段  
                if(bol[g]==false){  
                    bol[g]=true;  
                    break;  
                }  
            }  
            WA+=a[i].first;//累加扣款  
        }  
    }  
    cout<<m-WA;  
	return 0;  
}  

```

---

## 作者：Social_Zhao (赞：2)

本题是一道贪心，下面谈谈本题的策略以及优化

策略一：

首先将所有任务按罚款降序。

一个个往里安。我们要让它对前面的影响最小，所以要安到**最靠后的空位里**。

朴素的代码各位大佬已经讲清楚了。

策略二：

将任务按时间排序，如果排满，就找一个**罚款最小**的踢掉。如果这个任务罚款最小，那干脆不做。

朴素的代码各位大佬已经讲清楚了。

---

正题

---

显然对于策略2，我们可以用堆来优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue < int,vector<int>,greater<int> > q;
struct node {
	int t,s;
} a[1000001];
bool cmp(node a,node b) 
{
	return a.t<b.t;
}
int main() 
{
	ios::sync_with_stdio(false);
	int n,m;
	cin>>m;
	cin>>n;
	for(register int i=1;i<=n;i++) {
		cin>>a[i].t;
	}
	for(int i=1; i<=n; ++i) {
		cin>>a[i].s;
		m-=a[i].s;
	}
	sort(a+1,a+n+1,cmp); //按时间排序
	for(int i=1; i<=n; ++i) {
		if(a[i].t>q.size()) q.push(a[i].s); //如果没TLE，直接安进去
		else if(q.top()<a[i].s) q.pop(),q.push(a[i].s); //如果TLE了，找最小的换
	}
	while(!q.empty()) {
		m+=q.top(); //算罚款
		q.pop();
	}
	cout<<m;
	return 0;
}
```

那么策略1呢？

找一个最靠后的位置，即下标最大，貌似可以用线段树。

但是用线段树要写几十行,时间复杂度还是$O(nlog_2n)$。我们需要一种一行且时间复杂度为$O(α)$的数据结构

``inline int find(int x) { return x==fath[x]?x:fath[x]=find(fath[x]); }``

并查集。

$fath[i]$就表示时限为$i$的任物可以放置的最靠后时间。

如果一个时间$i$被用了，那么我们将它和$i-1$合并到同一集合，即：$i$可做的最后时间与$i-1$可做的最后时间相同。

显然，如果$fath[i]==0$那说明此任务无法完成。

代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define int long long
using namespace std;
inline int get()
{
    int x=0,f=1;char c=getchar();
    while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
    return x*f;
}
struct node {
    int t;
    int mon;
} a[1000005];
int fath[1000005];
bool cmp(node a1,node a2)
{
    return a1.mon>a2.mon;
}
inline int find(int x) { return x==fath[x]?x:fath[x]=find(fath[x]); }
signed main()
{
    int m=0,n,maxn=0,cnt=0;
    m=get();
    n=get();
    for(int i=1;i<=n;i++)
    a[i].t=get();
    for(int i=1;i<=n;i++)
    a[i].mon=get(),maxn=max(maxn,a[i].t);
    sort(a+1,a+1+n,cmp);
    for(register int i=1;i<=maxn;i++) fath[i]=i;
    for(int i=1;i<=n;i++)
    {
        int tim=find(a[i].t);
        if(tim>0) {
            fath[tim]=fath[tim-1];
            cnt++;
            if(cnt==maxn) break;
        }
        else m-=a[i].mon;
    }
    cout<<m<<endl;
}
```

撒花QωQ

---

## 作者：蔡俊黠 (赞：1)

## 思路
因为不同的小游戏不能准时完成时具有不同的扣款权数，而且是求问题的最优解，所以很容易想到用贪心算法求解。

贪心策略是让扣款数额大的尽量在规定的期限内完成。

这样我们就先把这些任务按照扣款的数额进行排序，把大的排在前面，进行放置。

假如罚款最多的一个任务的完成期限是k，我们应该把它安排在哪个时段完成呢？应该放在小于等于k的最靠后的时间段。一旦出现一个不可能在规定期限内完成的任务，就直接扣钱

算法的时间复杂度是O（n^2）

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510;
int n,m,f[N];
struct node{
	int t,w;
}a[N];

void init()
{
 	scanf("%d%d",&m,&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i].t);
	for (int i=1;i<=n;i++) scanf("%d",&a[i].w);	
}

int cmp(node x,node y) { return x.w>y.w; }

void work()
{
	sort(a+1,a+1+n,cmp);
	for (int i=1;i<=n;i++)
	{
		bool pd=false;
		for (int j=a[i].t;j>=1;j--)
		{
			if (f[j]==0) //可以安排这个游戏 
			{
				f[j]=1;
				pd=true;
				break;
			}
		}
		if (pd==false) m-=a[i].w;
	}
}
int main()
{
	init();
	work();
	cout<<m<<endl;
	return 0;
}
```


---

## 作者：qmieanng (赞：1)

# 智力大冲浪
## 本蒟蒻的第一篇题解
很容易的可以看出这道题用的是贪心
首先，比赛时间分为n个时段(n≤500)，它又给出了很多小游戏，每个小游戏都必须在规定期限ti前完成(1≤ti≤n)。如果一个游戏没能在规定期限前完成，则要从奖励费m元中扣去一部分钱，不同的游戏扣去的钱是不一样的。
每个游戏都必须在规定时间内完成，如果完不成，就要罚钱。为了节约时间，所以已经明知完不成的游戏就放在最后做，，因为完不成的游戏放在什么时候做罚款数量都是一样的，同时，也要使这些时间的价值最少，这样的结果也就是最优了； //要保证每个单位时间的价值最大，就使每个单位时间完成当前时间罚款最多的游戏；
话不多说，供上代码
```
#include<bits/stdc++.h>
using namespace std;
int times[1001]={0},yes,sum=0;
struct game
{
    int time,f;
}a[1001];
int compare(game x,game y)
{
    return x.f>y.f;
}//SORT排列 
int main()
{
    int n,m;
    cin>>m;
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i].time;
    for(int i=1;i<=n;i++)
    cin>>a[i].f;
    sort(a+1,a+n+1,compare);
    for(int i=1;i<=n;i++)
    {
        yes=0;
        for(int j=a[i].time;j>=1;j--)
        {
            if(!times[j])
            {
                yes=1;
                times[j]=1;
                break;
            }
        }//这个时间段是否能完成此游戏 
        if(yes==0)//罚钱 
        {
            for(int k=n;k>=1;k--)
            {
                if(!times[k])
                {
                    times[k]=1;
                    break;
                }  
            }
            sum+=a[i].f;//总罚款 
        }
    } 
    cout<<m-sum;
    return 0;
}
```

```



---

## 作者：RED_Singer (赞：1)

# HI!
## 这是我的第四篇题解(~~其实我也想了好久~~)
### 本题需用贪心
#### 贪心策略:由高到矮,选择能选择的最后的时间单位
##### 不用多说上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include<string>
using namespace std;
int m,n;
bool f[501];	//时间段数组
struct game
{
	int time,money;		//该游戏时间限制及罚款	
}a[501];
bool c(game a,game b)		//排序
{
	return a.money>b.money;
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i].time;
	for(int i=1;i<=n;++i)
		cin>>a[i].money;
	sort(a+1,a+n+1,c);
	for(int i=1;i<=n;++i)
	{
		bool ff=0;		//记录是否可不可以玩
		for(int j=a[i].time;j>=1;j--)		//枚举时间单位
			if(f[j]==0)		//判断该时间单位有没有被占领
			{
				f[j]=1;		//标记
				ff=1;		//可以玩
				break;
			}
		if(!ff)m-=a[i].money;		//不能玩则扣钱
	}
	cout<<m;
	return 0;
}
```


---

## 作者：WxjzKK (赞：1)

```
本蒟蒻的绝世武林秘籍是：...........................................贪心
我们先这样
struct game
{
	int time;
	int money;
}s[501];
bool f[501];

再这样
sort(s+1,s+n+1,comp);//一定要多贪钱!!!

然后，判断还能不能完成工作
bool flag(int a)
{
	bool tf=false;
	for (int i=s[a].time;i>=1;--i)
		if (f[i]==true)
		{
			f[i]=false;
			return true;
		}
	return false;
}

附上AC代码:
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include<string>
using namespace std;
struct game
{
	int time;
	int money;
}s[501];//结构体，存储每一个game;
bool f[501];//时间数组，存储每一个时间点有没有被占领（占用）
bool comp(game a,game b)//排序comp
{
	return a.money>b.money;//贪钱
}
bool flag(int a)//判断能否完成任务
{
	bool tf=false;
	for (int i=s[a].time;i>=1;--i)
		if (f[i]==true)//如果还有时间
		{
			f[i]=false;//占领它
			return true;//返回true
		}
	return false;//很遗憾，没有在规定时间完成任务，被炒鱿鱼
}
int main()//主函数
{
	int m,n;
	cin>>m>>n;
	for (int i=1;i<=n;++i)//整体赋值（可以不要），但得改flag函数
		f[i]=true;
	for (int i=1;i<=n;++i)//输入时间
		cin>>s[i].time;
	for (int i=1;i<=n;++i)//输入钱数
		cin>>s[i].money;
	sort(s+1,s+n+1,comp);//快排
	for (int i=1;i<=n;++i)//判断每一个任务是否能在规定时间内完成
		if (flag(i)==false)//如果没完成
			m-=s[i].money;//炒鱿鱼
	cout<<m;//输出剩下的钱
	return 0;
}
```
AC愉快

---

## 作者：FR_qwq (赞：1)

这道题目，我们可以把钱数从大到小排列（怎么可能不要比较多的钱），然后再把它们尽量靠右放，看哪些放不了，他们就有被扣除。

让我们模拟一遍样例：

先由钱数从大到小排序：

4  2  4  3  1  4  6

70 60 50 40 30 20 10

（~~呃...似乎不用排~~）

然后再画个“草图”:

1 2 3 4 5 6 7      

没做完的： 

现在，把这些上面的这些东西尽量靠右填上去，变成这样：

1  2  3  4  5  6  7

40 60 50 70    10

没做完的：30、20

最后，剩余最多总钱数就是9950元。
```pascal
var i,n,m,j,t:longint;
a,b:array[0..500] of longint;
f:array[0..500] of boolean;
begin
readln(m);
readln(n);
for i:=1 to n do
  read(a[i]);
for i:=1 to n do
  read(b[i]);
for i:=1 to n-1 do
  for j:=i+1 to n do
    if b[i]<b[j] then
      begin
      t:=b[i];b[i]:=b[j];b[j]:=t;
      t:=a[i];a[i]:=a[j];a[j]:=t;
      end;//排序，从大到小排（这里用选择排序也可以）
for i:=1 to n do//本题精华所在
  begin
  for j:=a[i] downto 0 do
    if f[j]=false then//如果可以在那个时段内做这件事，那么久退出
      break;
  if j=0 then//如果发现在那个时段内不能做则扣钱，否则占用那个时段
    m:=m-b[i]
  else
    f[j]:=true;
  end;
writeln(m);
end.
```


---

## 作者：浏屿÷ (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
int n,m,ans=0,visit[501]={0},flag;
struct game//定义游戏
{
    int time;//游戏的完成期限
    int fund;//游戏的罚款
}w[501];
int cmp(game x,game y)
{
    return x.fund>y.fund;
}
int main()
{
     scanf("%d",&m);//一开始奖励的钱
    scanf("%d",&n);//n个游戏
   for(int i=0;i<n;i++)
       scanf("%d",&w[i].time);//输入每样游戏的完成期限
    for(int i=0;i<n;i++)
       scanf("%d",&w[i].fund);//输入每样游戏的罚款
   sort(w,w+n,cmp);//根据罚款从大到小排序
   for(int i=0;i<n;i++)
   {
       flag=0;
       for(int j=w[i].time;j>=1;j--)
           if(!visit[j])
           {
               flag=1;
               visit[j]=1;
               break;
           }
        if(flag==0)//要罚款
        {
            for(int k=n;k>=1;k--)
               if(!visit[k])
               {
                   visit[k]=1;
                   break;
               }
            ans+=w[i].fund;//累加罚款
        }
   }
   printf("%d\n",m-ans);
    return 0;
}
```
//第一次写题解，跪求管理员通过o(╥﹏╥)o

---

## 作者：孤河 (赞：1)

分析： 本题是最优解问题， 很容易想到贪心法。 贪心的主要思想是要让扣款数值大的尽量准时完成。

• 1、 把这些任务按照扣款的数目进行排序， 把大的排在前面， 先进行放置。

• 2、 如何放呢？ 是不是最大的就放在最前面呢？ 其实不然， 假如罚款最多的一个任务的完成期限是k， 应该把

它放在第k个时段， 因为放在1～k任意一个位置， 效果都是一样的， 这样可以为其他的放置让出前面的时间段。

• 3、 一旦出现一个不可能在规定时限前完成的任务， 则把其扔到最靠后的一个空时间段， 因为不能完成的任务，

在任意一个时间段中罚款数目都是一样的， 这样可以为其他的放置让出前面的时间段。

至于代码。。。看到下面。。。算了不发了。。。


---

## 作者：封禁用户 (赞：1)

大家都发的贪心算法，我来一发搜索+剪枝=AC

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
int m,n,t[1000],w[1000],Min=99999999;
struct io{
    int t,w;
}a[1000];
int cmp(const io a,const io b){
    return a.t<b.t;
}
void search(int now,int used,int money){    //now是正在玩第几个游戏，used是已经玩了几个游戏，money是已经扣除的钱
    if(money>Min) return;  //如果当前最优解比已经找到的最优解还大，直接返回（剪枝）
    if(now>=n+1){
        Min=min(Min,money);
        return;
    }
    if(a[now].t>used) search(now+1,used+1,money);    //如果能玩，就玩
    search(now+1,used,money+a[now].w);                   //能不能玩都要试试不玩
}
int main(){
    cin>>m>>n;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].t);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].w);
    sort(a+1,a+n+1,cmp);   //按时间排序
    search(1,0,0);
    cout<<m-Min;          //Min得到的是最少要扣除的钱，用总金额减掉就是答案了
    return 0;
}
```

---

## 作者：Hanzire76 (赞：0)

[在我的博客看体验更好~](https://www.hanzire.com/index.php/archives/60/)
# 思路
提取题目信息，发现所有任务完成时间都一样，但是价值不同，果断想到贪心。
优先处理损失较大的控制损失，可以使用排序实现，以扣费为关键字，从大到小排序。
创建一个`tim`数组，`tim[i]`表示第`i`个单位时间是否已经有了安排。
还有一个贪心策略，每个任务尽可能在接近deadline的时候完成，这里就要用到上面的`tim`数组。
最后遍历所有任务，没完成的扣钱即可。

# Code
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct work
{
    int t, w;
} r[501];
int n, m, tim[501];
bool sche[501];

bool cmp(work x, work y)
{
    return x.w > y.w;
}

int main()
{
    //freopen("riddle.in","r",stdin);
    //freopen("riddle.out","w",stdout);
    scanf("%d", &m);
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &r[i].t);
    for (int i = 1; i <= n; i++)
        scanf("%d", &r[i].w);
    sort(r + 1, r + n + 1, cmp);
    // 先做损失大的
    for (int i = 1; i <= n; i++)
    {
        for (int j = r[i].t; j >= 1; j--)
            if (tim[j] == 0)
            {
                tim[j] = 1;
                sche[i] = true;
                // 安排上
                break;
            }
    }
    for (int i = 1; i <= n; i++)
        if (sche[i] == false)
            m -= r[i].w;
    // 没有安排的扣费
    printf("%d", m);
    return 0; //Retr 0;
}
```

---

## 作者：没有输入 (赞：0)

# 贪心算法

因为是求问题的最优解，而且题目具有无后效性，所以很容易想到贪心算法。

开一个标记数组，记录每个游戏是否完成。先将游戏按时限排序，每次循环找出已玩游戏中权值最小的，判断新的游戏是否超时，如果超时就判断是否要删去原来的游戏，放进新的游戏。
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,Min;
struct Race
{
	bool vis;//标记数组
	int t,w;
} p[505];
bool cmp(Race a,Race b)
{
	return a.t<b.t;
}
int Find(int r)//寻找权值最小的游戏
{
	int x_wz=-1,x_w=1e9;
	for(int i=1; i<=r; i++)
		if(x_w>p[i].w&&p[i].vis) x_w=p[i].w,x_wz=i;
	return x_wz;
}
int main()
{
	scanf("%d%d",&m,&n);//读入
	for(int i=1; i<=n; i++) scanf("%d",&p[i].t);
	for(int i=1; i<=n; i++) scanf("%d",&p[i].w);
	sort(p+1,p+n+1,cmp);//按时间排序
	p[1].vis=true,Min=1;
	for(int Time=2,i=2; i<=n; i++)
	{
		if(Time>p[i].t)
		{
			if(p[i].w>p[Min].w) p[Min].vis=false,p[i].vis=true,Min=Find(i);
			continue;
		}
		Time++,p[i].vis=true,Min=Find(i);
	}
	for(int i=1; i<=n; i++)//没完成的游戏将权值扣除
		if(!p[i].vis) m-=p[i].w;
	printf("%d\n",m);
	return 0;
}
```
[评测记录](https://www.luogu.org/recordnew/show/21197116)

---

## 作者：七夜 (赞：0)

这个题，贪心完全就能过，因为考虑的是最小的罚款，所以按照罚款大小排序，然后让每一个游戏的玩完时间保持在允许的最晚情况就可以了

那么问题变成了两个：排序后怎么对应，以及怎么让他在最晚的时间玩完。

第一个问题其实很好解决，运用一个结构体就解决了，那么问题又转化了（换来换去好烦），如何给一个结构体排序？

代码如下：

```
int cmp(love x,love y)
{
	return x.fine>y.fine;
}
```
这样一来问题就解决了，那第二个问题也挺容易的（都很容易算什么问题，其实我也不知道，哈哈）只需要一个循环就可以了。

代码如下：

```
for(int i=1;i<=n;++i)//判断是否需要罚款 
	 {
	 	tot=0;//这是一个判断用的东西，待会就明白了 
	 	for(int j=you[i].time;j>=1;--j)//从他的最大时间开始，一直到一，看看有没有一个时间点没玩游戏 
	 	 {
	 	 	if(a[j]==0)//如果这个点没玩游戏，就代表不需要罚款 
	 	 	 {
	 	 	 	a[j]=1;//把这个点变成玩过游戏 
	 	 	 	tot=1;//然后标记成不需要罚款 
	 	 	 	break;//跳出循环 
			 }//因为此时找到是最晚能玩的时间，所以不会影响以后的选择 
		 }
		if(tot==0)
		 m-=you[i].fine;//如果没标记过，证明这个点不能玩了，需要罚款 
     }
```
挺简单对吧，所以这个题就解决了，如果看懂了，下面的代码就不要看啦，自己打吧

```
#include<bits/stdc++.h>//偷懒专用库 
#define ll long long
#define INF 520
#define MAXN 99999//宏定义 
using namespace std;

inline int read(){
  char c=getchar();int x=0,f=1;
  while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
  while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
  return x*f;
}//这里是快读，可以提供借鉴，忽略掉也无所谓的 

struct love
{
	int fine;
	int time;
}you[INF];//定义一个机构体 

int cmp(love x,love y)
{
	return x.fine>y.fine;
}//结构体排序，按照罚款之从大到小排，先处理罚款大的，保证罚款越小越好 

int n,m,tot;
int a[INF];//判断这个时间点玩没玩过游戏 

int main()//主函数部分 
{
    m=read();
    n=read();//读入 
    for(int i=1;i<=n;++i)
	  you[i].time=read();//读入时间 
	for(int i=1;i<=n;++i)
	  you[i].fine=read();//读入罚款值 
	sort(you+1,you+1+n,cmp);//排序 
	for(int i=1;i<=n;++i)//判断是否需要罚款 
	 {
	 	tot=0;//这是一个判断用的东西，待会就明白了 
	 	for(int j=you[i].time;j>=1;--j)//从他的最大时间开始，一直到一，看看有没有一个时间点没玩游戏 
	 	 {
	 	 	if(a[j]==0)//如果这个点没玩游戏，就代表不需要罚款 
	 	 	 {
	 	 	 	a[j]=1;//把这个点变成玩过游戏 
	 	 	 	tot=1;//然后标记成不需要罚款 
	 	 	 	break;//跳出循环 
			 }//因为此时找到是最晚能玩的时间，所以不会影响以后的选择 
		 }
		if(tot==0)
		 m-=you[i].fine;//如果没标记过，证明这个点不能玩了，需要罚款 
     }
    cout<<m;//输出 
	return 0;//养成好习惯，从你我做起 
}
```
如果觉得还行的话给个赞可以不

---

## 作者：霸气的小邓邓 (赞：0)

我的思路就是：

1.按罚款排序（**从大到小**）

2.一个一个的安排，
从规定时间开始**倒着**找位置，
有位置就放，没位置就罚

**确保扣的游戏罚款最少**

很简单的，上代码：


```cpp
#include<iostream>
using namespace std;
int n,m,;
struct ss
{
	int a,b;//a是规定时间,b是罚款
	bool c;//c就是游戏玩没玩
}x[501];
bool qk[501]={0};
void qsort()//日常，按罚款（从大到小）排
{
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			if(x[j].b>x[i].b)
			{
				swap(x[i].a,x[j].a);
				swap(x[i].b,x[j].b);
				swap(x[i].c,x[j].c)；//好像不用换c，反正都是0			
			}
		}
	}
}
int main()
{
	cin>>m>>n;//注意输入格式，我上次都错了
	for(int i=1;i<=n;i++)
	{
		cin>>x[i].a;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>x[i].b;
	}
	qsort();//排
	for(int i=1;i<=n;i++)//开始玩
	{
		for(int j=x[i].a;j>=1;j--)//从规定时间开始往前搜
		{
			if(qk[j]==0)//该时间段没有占用
			{
				qk[j]=1;//占用
				x[i].c=1;//该游戏被玩
				break;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(x[i].c==0) m-=x[i].b;//如果没玩就扣
	}
	cout<<m;
	return 0;
}
```

~~**简单易懂**~~

---

## 作者：zhanghb (赞：0)

这道题只需要我们把所以可以完成的任务完成，越值钱的先完成，把所以可以完成的任务的钱数值为0，最后减去为完成的游戏的钱数，即是我们需要的答案。

附AC代码

--------------------------------
```
#include<iostream>
#include<algorithm>
using namespace std;
struct game//定义结构体
{
	int time;//每个游戏的限定时间
	int money;//未完成游戏需要扣除的钱
}xy[100001];
bool cmp(struct game xy1,struct game xy2)//定义快排规则
{
	if(xy1.money>xy2.money)//如果前者钱数大于后者，即为真
	return 1;
	else return 0;//否则为假
}
int main()
{
	int j,i,n,q,c[501]={0};
	cin>>q;//输入先得到的钱
	cin>>n;//输入有几个小游戏
	for(i=1;i<=n;i++)
	cin>>xy[i].time;//输入每个游戏的限制时间
	for(i=1;i<=n;i++)
	cin>>xy[i].money;//输入每个游戏的钱数
	sort(xy+1,xy+1+n,cmp);//按每个游戏的钱数排序，大的在前
	for(i=1;i<=n;i++)
		for(j=xy[i].time;j>=1;j--)//寻找限定时间前是否有时间段空着
		if(c[j]==0)//如果有，则把这个时间段设为已使用
		{
			c[j]=1;
			xy[i].money=0;//获得这个游戏的钱
			break;
		}
		for(i=1;i<=n;i++)
		q=q-xy[i].money;//减去所以为完成游戏的钱数
		cout<<q<<endl;//输出
}
```


---

## 作者：蒻得不行 (赞：0)

~~发一篇可以让你出去和同学们装13的做法~~

**优先队列 X pair<>**

思路楼上各位dalao都说的差不多了，直接上题解
****

```
#include<bits/stdc++.h> //that's ♂ good
using namespace std;
int n,ans,i,j;
pair<int,int> a[500];
priority_queue<pair<int,int> > s;//注入灵魂
bool cmp(pair<int,int> x,pair<int,int> y){
	return x.second>y.second;
}
int main (){
	scanf("%d%d",&ans,&n);
    //first和second反过来可以不重载运算符，让代码更简（tou）洁（lan）
	for(i=0;i<n;i++) scanf("%d",&a[i].second);
	for(i=0;i<n;i++) scanf("%d",&a[i].first);
	sort(a,a+n,cmp);//sort！！！
	for(i=a[0].second;i>0;i--){//从最后的时间开始枚举
		while(a[j].second==i)
			s.push(a[j++]);//将时间吻合的放入
		if(!s.empty()) s.pop();//弹出做过的项目
        //注意！！！一定要判断empty！！！
	}
	while(!s.empty()){
		ans-=s.top().first;//结算money
		s.pop();//弹出
	}
	printf("%d",ans);//输出
	return 0;
}


```


STL大法好~

---

## 作者：fdszlzl (赞：0)

[P1230 智力大冲浪](https://www.luogu.org/problemnew/show/P1230)

**动态规划题解：**

顺着时间线，设f[i][j]为1->i游戏在j时刻的最优值，一个游戏有三种情况：

1、j时刻超出了i游戏的最低时限，即j时刻玩不了，那么最优值必然是i游戏在j-1的最优值。

```
if(g[i].t<j) f[i][j]=f[i][j-1];
```

2、如果j时刻可以玩i游戏，有两种决策：玩或不玩。如果不玩即i-1个游戏在j时刻的最优值，如果玩即i-1个游戏在j-1时刻的最优值+本次游戏的钱。取最优值。

```
f[i][j]=max(f[i-1][j-1]+g[i].a,f[i-1][j]);
```

```
#include <bits/stdc++.h>
using namespace std;

int f[505][505];

struct game {
	int a,d;
} g[505];

int cmp(game a,game b) {
	return a.d<b.d;
}

int main() {
	int p,n,m=0,s=0;
	cin>>p>>n;
	for(int i=1; i<=n; i++) {
		cin>>g[i].d;
		m=max(m,g[i].d);
	}
	for(int i=1; i<=n; i++) {
		cin>>g[i].a;
		s+=g[i].a;
	}
	sort(g+1,g+n+1,cmp);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(g[i].d<j) f[i][j]=f[i][j-1];
			else f[i][j]=max(f[i-1][j-1]+g[i].a,f[i-1][j]);
		}
	}
	cout<<p-s+f[n][m];
	return 0;
}
```


---

## 作者：qwaszx (赞：0)

贪心+二分+树状数组

按$w$降序排序，对每个任务看一下能不能做，即是否存在一个时间点是没有被占用的

做一个任务一定是放在最后一个可行时间点上是最优的

二分找出最后一个可行时间点，用树状数组维护用过的时间的数量

$O(n\log^2t)$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int m,n,p[500000];
struct hh{int d,w;}a[500000];
int cmp(const hh &a,const hh &b){return a.w>b.w;}
struct BIT
{
	int a[500000];
	int query(int i){int ans=0;for(;i;i-=i&-i)ans+=a[i];return ans;}
	void update(int i){for(;i<=n;i+=i&-i)a[i]++;}
}f;//树状数组
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i].d);
	for(int i=1;i<=n;i++)scanf("%d",&a[i].w);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		int l=0,r=a[i].d,mid;//二分出最后一个可行时间
		while(l<r)
		{
			mid=(l+r+1)>>1;
			if(f.query(a[i].d)-f.query(mid-1)!=a[i].d-mid+1)l=mid;
			else r=mid-1;
		}
		if(!l)m-=a[i].w;else f.update(l);//都不行就罚款，否则修改为1
	}
	cout<<m<<endl;
}
```

---

## 作者：xfydemx (赞：0)

比较经典的贪心题目，贪心策略楼下已经讲得很清楚，

即优先完成价值高的，具体处理时把它放在可用区间的最末端；

感觉我的代码很简洁了，看代码吧


    
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio> 
#include<cstring>
using namespace std;
int mny,n,b[100000];
struct node{
    int fee,time;    
}a[100000];
int cmp(node x,node y)//这里写个结构体cmp
{
    if(x.fee!=y.fee)
    return x.fee>y.fee;//费用优先
    else return x.time<y.time;//其次时间
}    
int main()
{
    cin>>mny>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i].time;
    for(int i=1;i<=n;i++)
    cin>>a[i].fee;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        int flag=0;
        for(int j=a[i].time;j>=1;j--)
        {
            if(!b[j]) {b[j]=1;flag=7;break;}//立flag,若找到则可完成，否则不可完成只能放弃，应减去钱数
            }
        if(flag!=7) mny-=a[i].fee;
    }
    cout<<mny;
}
```

---

## 作者：ztz11 (赞：0)

#### 这么好的一道题，为什么不用堆呢？
我们由题意可知，每一个小游戏都有两个变量，时间和价值（因为要扣得钱最少，所以要尽可能多的完成扣钱多的任务，而每个任务只要在时限之前完成即可）；那么第一次按时间排序，然后从最大时间开始时光倒流，每一个时间点观察有无可以做的游戏，然后把它塞到一个大根堆里去，每到一个时间点如果有可以做的东西的游戏，就去做能做的中最大的，可证得这样的是最优的；
~~因为我太懒了，~~所以我用的是stl
#### 附代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#define rii register int i
#define rij register int j
using namespace std;
int n,m;
struct gz{
	int ti,mo;
}x[505];
priority_queue<int> money;
bool cmp(gz fd,gz df)
{
	return fd.ti<df.ti;
}
int main()
{
	scanf("%d%d",&m,&n);
	for(rii=1;i<=n;i++)
	{
		scanf("%d",&x[i].ti);
	}
	for(rij=1;j<=n;j++)
	{
		scanf("%d",&x[j].mo);
	}
	sort(x+1,x+n+1,cmp);//按时间排序
	int tim=x[n].ti;//找出最大的时间
	for(rii=tim;i>=1;i--)
	{
		while(x[n].ti>=i)
		{
			money.push(x[n].mo);//如果这个点是某个游戏的时限，入堆
			n--;
		}
		if(money.size()!=0)//如果不空，则有游戏可玩，扔出堆顶
		money.pop();
	}
	int dx=money.size();
	for(rii=1;i<=dx;i++)
	{
		m-=money.top();//最后还没有出堆，说明无法完成，扣钱
		money.pop();
	}
	cout<<m;
}
```

---

## 作者：邓晓蓝 (赞：0)

//简单的贪心。肯定要先完成扣除钱数最多的游戏项目了啊。所以从大到小排序。然后如果该时间可以做这个游戏那就玩。完不成就扣钱

```cpp
var n,m,i,j,a,f:longint;
    zh,ph,sj:array[0..50000] of longint;
begin
  readln(n,m);
  for i:=1 to m do
    read(sj[i]);
  for i:=1 to m do
    read(ph[i]);
  for i:=1 to m-1 do    //先将做不完游戏扣除的钱按从大到小排序
    for j:=i+1 to m do
      if ph[i]<ph[j] then
        begin
          a:=ph[i];ph[i]:=ph[j];ph[j]:=a;
          a:=sj[i];sj[i]:=sj[j];sj[j]:=a;
        end else
      if ph[i]=ph[j] then
        if sj[i]>sj[j] then
          begin
            a:=sj[i];sj[i]:=sj[j];sj[j]:=a;
          end;
  for i:=1 to m do
    begin
      f:=0;
      for j:=sj[i] downto 1 do    
        if zh[j]=0 then begin zh[j]:=ph[j];f:=1;break;end;
      if f=0 then n:=n-ph[i];
    end;
  writeln(n);
end.
```

---

## 作者：飞翔 (赞：0)

```cpp
var
  t,w:array[0..1000] of longint;
  p:array[0..1000] of boolean;
  n,m,i,j,lim,ans:longint;
procedure qsort(l,r:longint);
var
  i,j,y,x:longint;
begin
  i:=l;j:=r;x:=w[(i+j) div 2];
  repeat
    while w[j]<x do dec(j);
    while w[i]>x do inc(i);
    if i<=j then
    begin
      y:=t[j];t[j]:=t[i];t[i]:=y;
      y:=w[i];w[i]:=w[j];w[j]:=y;
      inc(i);dec(j);
    end;
  until i>j;
  if i<r then qsort(i,r);
  if l<j then qsort(l,j);
end;//快排
begin
  lim:=-maxint;
  readln(m);
  readln(n);
  for i:=1 to n do
  begin
    read(t[i]);
    if t[i]>lim then lim:=t[i];
  end;
  for i:=1 to n do read(w[i]);
  qsort(1,n);
  fillchar(p,sizeof(p),true);
  ans:=0;
  for i:=1 to n do
  begin
    j:=t[i];
    while (j>0) and not(p[j]) do dec(j);//选择游戏
      if j=0 then inc(ans,w[i]) else p[j]:=false;//要么扣钱，要么下一个
  end;
  write(m-ans);
end.
```

---

## 作者：fadeAwayLi (赞：0)

#[color=red][center]思路[/center][/color]

简单叙述思路，读入所有数据后，按照每个游戏未完成的扣钱数降序快排一遍，别忘记交换游戏的完成期限的信息。之后要做的事情就是按照扣钱数顺序逐个分配游戏完成的时刻，比如样例中的“4-70”这组数据，就把它分配到第4个时间段完成。但看到之后的“4-50”这组数据，第4个时刻被占用了，那么就寻找前面的没被占用的第3个时间段来完成。如果某个游戏无法安排一个时间段完成，那么就放弃、扣钱，最后输出结果。

```delphi

var money,n,i,ii,jj,mid,t,k,j:longint;
    a:array[1..500]of longint;
    b:array[1..500]of longint;
    pd:array[0..500]of boolean;
    bo:boolean;
procedure qsort(l,r:longint);
begin
     ii:=l;
     jj:=r;
     mid:=b[(l+r)div 2];
     repeat
           while b[ii]>mid do inc(ii);
           while b[jj]<mid do dec(jj);
           if ii<=jj then begin
           t:=a[ii];
           a[ii]:=a[jj];
           a[jj]:=t;
           t:=b[ii];
           b[ii]:=b[jj];
           b[jj]:=t;
           inc(ii);
           dec(jj);
           end;
     until ii>jj;
     if ii<r then qsort(ii,r);
     if jj>l then qsort(l,jj);
end;
begin
     readln(money);
     readln(n);
     pd[0]:=true;
     for i:=1 to n do
         read(a[i]);
     readln;
     for i:=1 to n do
     begin
          read(b[i]);
          pd[i]:=false;
     end;
     qsort(1,n);
     for i:=1 to n do
     begin
          if pd[a[i]]=false
          then pd[a[i]]:=true
          else begin
               bo:=true;
               k:=a[i];
               while bo and (k<>0) do
               begin
                    dec(k);
                    if k=0
                    then dec(money,b[i]);
                    if (pd[k]=false)
                    then begin
                         pd[k]:=true;
                         bo:=false;
                    end;
               end;
               end;
     end;
     writeln(money);
end. 

```
#[color=red][center]Pascal代码[/center][/color]

代码可能有点长和繁杂，但具体思路已经说明了，如有不便请见谅。


---


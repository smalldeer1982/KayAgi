# 尼克的任务

## 题目描述

尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。

尼克的一个工作日为 $n$ 分钟，从第 $1$ 分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活，公司一共有 $k$ 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $(p+t-1)$ 分钟结束。

写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4,1 \leq k \leq 10^4,1 \leq p \leq n,1 \leq p+t-1 \leq n$。

## 样例 #1

### 输入

```
15 6
1 2
1 6
4 11
8 5
8 1
11 5
```

### 输出

```
4
```

# 题解

## 作者：王尼玛 (赞：548)

唔~普及组水题，比较适合DP练习


这题显然是一个线性动规，那么肯定是第一时间想到设f[i]:1~i的最大空闲时间，但是，想了一下之后发现，第i时刻的最大空闲时间是和后面i+选择任务的持续时间的时刻有关系的，那么，正着找肯定是不行的，我们来试一下倒着搜,即设f[i]表示i~n的最大空闲时间，经尝试，发现是完全可行的，可以列出动态转移方程如下

**（本时刻无任务）f[i]=f[i+1]+1;//继承上一个时刻的最大空闲时间后+1**

**（本时刻有任务）f[i]=max(f[i],f[i+a[sum])//a[sum]表示在这个时刻的任务的持续时间，找出选择哪一个本时刻任务使空闲时间最大化**

那么既然是倒着搜，从后往前的任务对应的开始时间自然也要反过来，从大到小排序（同时也是为了把相同开始时间的任务放到一起）,当然在进行状态刷新的时候别忘了拿sum不断计一下已经到哪一个任务了


那么。。喜闻乐见的，上代码。。。。


```cpp
#include<iostream>  
#include<algorithm>  
using namespace std;  
long int n,k,sum[10001],num=1,f[10001];  
struct ren//结构体，一起排序 ，从大到小   
{  
    long int ks,js;  
};  
ren z[10001];  
int cmp(ren a,ren b)  
{  
    return a.ks>b.ks;  
}  
int main()  
{  
    long int i,j;   
    cin>>n>>k;  
    for(i=1;i<=k;i++)  
    {  
    cin>>z[i].ks>>z[i].js;    
    sum[z[i].ks]++;  
    }  
    sort(z+1,z+k+1,cmp);  
    for(i=n;i>=1;i--)//倒着搜   
    {  
        if(sum[i]==0)  
        f[i]=f[i+1]+1;  
        else for(j=1;j<=sum[i];j++)  
        {  
            if(f[i+z[num].js]>f[i])  
            f[i]=f[i+z[num].js];  
            num++;//当前已扫过的任务数   
        }  
    }  
    cout<<f[1]<<endl;  
}  

```

---

## 作者：kkksc03 (赞：486)

【设】f[i]表示1到i个时间最大空闲值。

【分析】本题是一道资源分配类动态规划。我们可以划分阶段的标准是时间和任务。如果尼克在一个时间点上没有接到任务，我们就让他延续他原来的空闲时段，现在空闲时间=上一个空闲点的空闲时间+1；如果这时有这个时间点开始的任务，我们就将其插入，有多个这样的任务供我们选择最优的。因为这个时间点尼克只有两个选择要么完成一个任务要么什么都不干，以开始时间来选择每一次都可以找到一个最优的。但是本题好在开始时间和完成时间都有一个严格的限定，所以我们可以不用考虑一个任务插入在哪个时间结束，只要根据开始时间和结束时间进行插入控制就行了。

【最优子结构】

本题的最优子结构可以建立在开始时间上，也可以建立在结束时间上。先说结束时间：

```delphi

j:=1;
for i:=1 to n do
   if p[j]+t[j]-1<>i then f[i]:=f[i-1]+1
   else
      while p[j]+t[j]-1=i do
         begin
         if f[i]<f[p[j]-1]
            then f[i]:=f[p[j]-1];
         inc(j);
         end;

```
上述程序看似完美，我们不难举出反例，如三个任务（1，6）（2，3）（1，4），我们看到因为输入数据只能保证开始时间严格排序，而不是结束时间，所以当j等于1的时候f[i]只会考虑情况一，因为在while循环中开始永远是因为玩不成而跳出，j值加不了1.

针对此问题只能在开始在对结束进行一个排序，时间上不够。

但是我们可以考虑用开始时间由大到小进行逆推求解，因为开始时间是互不干涉的，而且输入时就有顺序，具备无后效性。下面我们照此方法写方程。

【方程】

f[i]=f[i+1]+1     如果i<>p[j]

f[i]=max{f[i+t[j]]}如果p[j]=i


---

## 作者：「已注销」 (赞：160)

## $O(n+k)$做法

`f[i]`表示第$i$分钟起最大闲暇时间

转移方程：

- 如果当前无任务，`f[i]=f[i+1]+1`
- 如果当前第$i$个任务持续$t_i$分钟`f[i]=max(f[i+t[i]])`

递推顺序：`for(i=n;i>0;i--)`

答案：`f[1]`

实现方式：动态数组$v_i$存在时刻$i$开始的任务持续时间
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int n,k,s,t,f[10002];
vector<int>v[10001];
int main(){
    scanf("%d%d",&n,&k);
    while(k--){
        scanf("%d%d",&s,&t);
        v[s].push_back(t);
    }
    for(int i=n;i;--i){
        if(v[i].size()>0)
            for(int j=0;j<v[i].size();++j)
                f[i]=max(f[i],f[i+v[i][j]]);
        else f[i]=f[i+1]+1;            
    }
    printf("%d",f[1]);
}
```

---

## 作者：tong_xz (赞：141)

### 这道题可以用最短路（最长路？）做。

将时间点作为图论的点。

从第P分钟开始，持续时间为T分钟的任务视为从P点到P+T点连一条权为T的边。（边的起点是任务的起始时间，终点是任务结束时间的下一分钟）

如果一个点到最后也没有出度，则向后一个点连边权为0的边（没活干，这一分钟他可以摸鱼。。。）

跑最短路就得到他至少要干多长时间，答案就是（n-最短路结果）

如果将边权作为休息时间的话用最长路也能做

code:
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#define N 10005
using namespace std;
struct Edge{
    int to,next,w;
}edge[N*2];
int head[N],tot;
void addedge(int from,int to,int w){
    edge[++tot].to=to;
    edge[tot].w=w;
    edge[tot].next=head[from];
    head[from]=tot;
}
int dis[N];
bool vis[N];
void spfa(){
    memset(dis,0x7f,sizeof(dis));
    dis[1]=0;
    queue<int> q;
    q.push(1);
    int now;
    while(!q.empty()){
        now=q.front();
        q.pop();
        vis[now]=false;
        for(int i=head[now];i;i=edge[i].next){
            if(dis[edge[i].to]>dis[now]+edge[i].w){
                dis[edge[i].to]=dis[now]+edge[i].w;
                if(!vis[edge[i].to]){
                    q.push(edge[i].to);
                    vis[edge[i].to]=true;
                }
            }
        }
    }
}
int main(){
    int n,k,p,t;
    scanf("%d%d",&n,&k);
    while(k--){
        scanf("%d%d",&p,&t);
        addedge(p,p+t,t);
    }
    for(int i=1;i<=n;++i){
        if(head[i]==0){
            addedge(i,i+1,0);
        }
    }
    spfa();
    printf("%d",n-dis[n+1]);
}
```


---

## 作者：BFSBFSBFSBFS (赞：70)

感觉正着做挺顺的啊..

下面给出1个很好理解的做法.

先看样例.

 ![](https://cdn.luogu.com.cn/upload/pic/12223.png) 

niko选了$(1,6]$与$(8,13]$2个工作.

意思是从时间**1**开始,到时间**6**结束都是工作时间.

图上的红实线代表选择的工作.虚线段$MN$与$OP$都代表空闲时间.

注意图上的区间是$(1,7)$和$(8,13)$.

强调这2个都是开始时间.也就是从时间**1**开始,到时间**7**开始.中间有**6**段.

时间**6**的**结束时间**与时间**7**的**开始时间**应该是1样的吧.

这样就好处理多了.直接

```cpp
t[i] += p[i]
```
代表结束的时候.


------------


~~讲完了烩话.~~下面进入题解.

题意要求.在某个时间上.niko有任务必须做.有多个任务选择任意1个.

问从开始到结束的最大空闲的时间.

首先当然要按起始时间排序..

之后呢.我们知道.空闲时间是从2个任务的中间时间省下来的..

究竟有没有这段空闲时间.?

如果有的话,说明在这**中间**1定没有其它任务了.

不然niko会优先做这个"其它的任务.".

不管这个任务做的究竟有多快.这段空闲时间1定被**破坏**了.

空闲时间虽然不完整.但是如果仍然存在.可以通过这个"其它的任务."来转移.

所以只要关注离这个任务开始时间**最近**的任务就行了..

那么设$f[i]$表示到第**i**个任务开始时.最大的空闲时间.

转移方程:$f[i] = max(f[j]+p[i]-t[j]),(1 <= j<= i-1)$.

$p[i]$,$t[i]$表示任务$i$的起始时间与结束时间.

其中$i$要满足.$p[i] = min(p[k],(1 <= k <= n,p[k] >= t[j]))$转移才成立.

看起来麻烦.?

~~伪~~代码.

```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i-1; j++)
        if (p[i] >= t[j] && p[i] <= b[j]){
            f[i] = max(f[i],f[j]+p[i]-t[j]);
            b[j] = p[i];
        }
```
用$b[j]$记录下距离$t[j]$的最小值.

可行性很容易探究.-

最后把头尾2个当作工作加进去.输出$f[n]$就可以了..

最坏时间复杂度$O(\frac{n^2}{2})$.空间$O(4n)$.还是能过的..

Diu代码..

```cpp
program P1280;
 var
  b,f,x,y,z:array[0..10001] of longint;
  i,j,k,p,n:longint;
 function hahamax(x,y:longint):longint;   //最大值比较..(math.)
  begin
   if x>y then exit(x)
          else exit(y);
  end;
 procedure hahasort(l,r:longint);         //快速排序..
  var
   o,p,m,t:longint;
  begin
   o:=l;
   p:=r;
   m:=x[(o+p) div 2];
   repeat
    while x[o]<m do inc(o);
    while x[p]>m do dec(p);
    if o<=p then
     begin
      t:=x[o];
      x[o]:=x[p];
      x[p]:=t;
      t:=y[o];
      y[o]:=y[p];
      y[p]:=t;
      inc(o);
      dec(p);
     end;
   until o>p;
   if o<r then hahasort(o,r);
   if l<p then hahasort(l,p);
  end;
 begin
  readln(n,k);
  for i:=1 to k do
   begin
    readln(x[i],y[i]);                     //x,y就是上面的p,t.
    inc(y[i],x[i]);                        //做类似开区间处理..
   end;
  x[0]:=1;
  y[0]:=1;
 // fillchar(z,sizeof(z),0);               //调试用.-
  inc(k);
  x[k]:=n+1;                               //由于是开区间..
  y[k]:=n+1;                               //结束变成n+1..
  hahasort(1,k-1);
  for i:=0 to k do
   begin
    b[i]:=1008208820;                      //初始化b[i]最大.
    f[i]:=-1008208820;                     //说明任务还不能做.
   end;
  f[0]:=0;                                 //working.
  for i:=0 to k do
   for j:=0 to i-1 do
    if (b[j]>=x[i]) and (x[i]>=y[j]) then
     begin
      f[i]:=hahamax(f[i],f[j]+x[i]-y[j]);  //能转移的转移.
      b[j]:=x[i];                          //找到最近的工作.
     end;                                  //可能有多个.
  writeln(f[k]);
 end.
```
(ಡωಡ).


---

## 作者：Ada____ (赞：45)

所有能找到的题解都是倒推的， 看了讨论里说为什么一定要倒推的说明。。。

认为只能说在那种定义下只能倒推

表示正推过了。。。感觉没毛病啊

所以放一篇正推的题解QAQ

//能过不排除数据没卡掉错误的点， 欢迎大佬斧正


定义f[i]为从1开始到当前时间可以获得的最大休闲时间

从当前点向后推， 更新后续结点的最大休闲时间

则状态转移方程为//伪代码


if(当前点无任务）


```cpp
    f[i+1]=f[i]+1;
else 
    for(遍历当前点开始的所有任务)
        f[i+t[j]]=max(f[i+t[j]], f[i]);
```
记得 f 数组初始化为很小的数啊
按题意从1开始计算， 所以ans=f[n+1]


//总共工作了n分钟

下面是AC代码，如果上面我没有说清楚的话可以看一看

如果还不是很清楚欢迎和我讨论QwQ

有错误请指出谢谢

//因为编辑器的原因缩进是两个空格， 以及代码风格唔。。。



```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 1e5+5;
int f[N], n, k;
vector<int> task[N];
int main() {
  memset(f, -0x3f, sizeof(f));
  f[1]=0;
  scanf("%d%d", &n, &k);
  while(k--) {
    int x, t;
    scanf("%d%d", &x, &t);
    task[x].push_back(t);
  }
  for(int i=1; i<=n; ++i) {
    if(task[i].size()==0) 
      f[i+1]=max(f[i]+1, f[i+1]);
    else
      for(int j=0; j<task[i].size(); ++j) {
    int &x=f[i+task[i][j]];
    x=max(x, f[i]);
    }
  }
  printf("%d\n", f[n+1]);
  return 0;
}
```

---

## 作者：lijiahao2017 (赞：45)

# P1280 【尼克的任务】


### 题目描述

尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。

尼克的一个工作日为$N$分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第$P$分钟开始，持续时间为T分钟，则该任务将在第$P+T-1$分钟结束。

写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。

### 输入输出格式

##### 输入格式：
输入数据第一行含两个用空格隔开的整数N和$K$($1≤N≤10000$，$1≤K≤10000$)，$N$表示尼克的工作时间，单位为分钟，K表示任务总数。

接下来共有$K$行，每一行有两个用空格隔开的整数$P$和$T$，表示该任务从第$P$分钟开始，持续时间为$T$分钟，其中$1≤P≤N$，$1≤P+T-1≤N$。

##### 输出格式：
输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。

### 输入输出样例

##### 输入样例#1： 复制
$15$ $6$

$1$ $2$

$1$ $6$

$4$ $11$

$8$ $5$

$8$ $1$

$11$ $5$
##### 输出样例#1： 复制
$4$



因最近小菜鸡有特殊的秘密行动，所以没有和大家分享。

今天，我来和大家来分享一下学习     动态规划,动规,$dp$      的心得。

其中，选了这道题来讲讲。

动态规划,动规,$dp$      这里有一个简单的介绍[动态规划](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408)和一位$dalao$博客里的[总结](http://cppblog.com/menjitianya/archive/2015/10/23/212084.html)

这道题看了后，知道用     动态规划,动规,$dp$      但头脑一热，像报废了似的，想不下去了。

于是，就看了看题解里的$dalao$是怎样做的。

果然，不出所料，真有收获。

理解后打了一遍，$AC$了。（小菜鸡好久没有这么高兴过。）

讲了这么多废话，来讲讲正题。

这题主要讲的是：从第一分钟开始到第N分钟结束，尼克应该如何选取任务，才能获得最大的空暇时间。

是     动态规划,动规,$dp$      的题，我们第一时刻想到的常用公式：解什么就设什么。

问：最大的空暇时间

设：$f[i]$表示$1$到$i$个时间最大空闲值。

准备就绪，那就差主角登场了，核心方程。

$if(b[i]==0)ans[i]=ans[i+1]+1;$

$if(ans[i+a[q].t]>ans[i])ans[i]=ans[i+a[q].t];$



有了核心，就相当于有了主骨，血和皮肉就慢慢填；

有了核心，就相当于有了提纲，经典名句就慢慢写；

有了核心，就相当于有了领袖，辅助人员就慢慢来。



废话真没多，讲代码：

```
//题目提供者
//评测方式 云端评测
//标签 动态规划,动规,dp 排序 枚举,暴力
//难度 普及+/提高
//时空限制 1000ms / 128MB
#include<cstdio>//调用      scanf和printf      的库
#include<cstring>//调用      memset      的库
#include<algorithm>//调用      sort      的库
//头文件
#define ll long long
using namespace std;
const ll mx=10010;
//习惯了
ll n,k,q=1;
ll b[mx],ans[mx];
struct node{ll p,t;}a[mx];//用结构体排序方便
//准备就绪
bool cmp(node a,node b) { return a.p>b.p; }//因逆推，所以从大到小
int main()//开始了
{
	memset(b,0,sizeof(b));
	memset(ans,0,sizeof(ans));
    //先初始值为0
	scanf("%lld %lld",&n,&k);
	for(ll i=1;i<=k;i++)scanf("%lld %lld",&a[i].p,&a[i].t),b[a[i].p]++;
	//输入
    sort(a+1,a+k+1,cmp);//排序
	for(ll i=n;i>0;i--)//注意是逆推{
		if(b[i]==0)ans[i]=ans[i+1]+1;
		else{
			for(ll j=1;j<=b[i];j++){
				if(ans[i+a[q].t]>ans[i])ans[i]=ans[i+a[q].t];
				q++;
			}
		}
	}
    //解方程
	printf("%lld",ans[1]);//结果存在第一位，输出
	return 0;
}
```

---

## 作者：BuXiangJuanLe (赞：40)

好多逆推题解用到了排序，我这个蒟蒻根本看不懂啊QAQ

这是**不用排序、不用存每个任务**的逆推做法：~~（其实还是存了）~~

转移还是一样的，简单再说一下

`f[i]`表示从后往前推到时刻i的最大空闲时间。

首先，如果时刻i没有任务开始，我们就让`f[i] = f[i+1] + 1`。可能会有人怀疑i之前的时刻会不会也把i占用了，但是这个式子是没问题的，因为如果之前的任务会占用i，那么它转移的时候也用不着`f[i]`。

其次，如果时刻i有任务开始，我们肯定要选一个**任务结束之后空闲时间最大**的任务来做。我们读入的时候直接存储**在时刻i开始的任务是哪些**，转移的时候枚举，取最大值即可。存储这些任务，vector能很好地胜任。（在程序中为了节省空间省掉了存任务的数组，vector直接存了结束时间。实际上也只会用到结束时间，编号没有用）

Code:

```cpp
#include<bits/stdc++.h>
#define maxn 10008
using namespace std;
int n, k, p, t, f[maxn]; //p t只是用来输入的
vector <int> b[maxn]; //b[i]存储第i时刻开始的任务的结束时间 

int main(){
	cin>>n>>k;
	for(int i=1 ; i<=k ; i++){
		cin>>p>>t;
		b[p].push_back(t);
	}
	for(int i=n ; i>=1 ; i--){ //从后往前枚举时刻 
		if(b[i].empty()) f[i] = f[i+1] + 1; //i时刻没有任务开始
		else{
			for(int j=0 ; j<b[i].size() ; j++) //这一时刻有任务，枚举这些任务（的结束时间）
				f[i] = max(f[i], f[i + b[i][j]]); 
		}
	}
	cerr<<f[1]<<endl;
	return 0;
}
```

---

## 作者：bingliang (赞：27)

1280 尼克的任务

1.子任务   第i时刻尼克是否有任务可选  如果有，选哪个歇的时间更长

2.定义状态

在前i时刻尼克最多歇多久（最少工作多久）？

3.状态转移

本题要倒着推  及从大的时间往小的时间转移   因为   如果正着  在i的时候 显然还没转移  i+t

考虑如果 i时刻没有任务  则 从i+1秒 到第 i 秒可以歇着 就爽歪歪。

如果有任务  就  从这几个任务中 选择一个（根据程序选择轻松地，就美滋滋！）

及
dp【i】=dp【i+1】+1；

或
if  t【j】。s==i   

dp【i】=max(dp【i+t【j】。e】，dp【i】)；

具体看代码吧！

对了在解释一个问题  sort对于这题而言  如果你要  每次花j的复杂度扫下的话  拍不排序无所谓 ，但是排序后 你可以根据时间的单调性优化，

及每次并不用扫完 就可以用特判结束

不排序   复杂度（确界）  nk

排序       （上界）nk  +(下界)klogk 上界 （k^2）    （排序只讨论sort）

    
    
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct  node
{
    int s,e;
}t[10000];
int dp[10000];
int st[100009];
int cmp(node a,node b)
{
    return a.s>b.s;
}
int n,m,k;
int main()
{
cin>>n>>k;
for(int i=1;i<=k;i++)
{
    cin>>t[i].s>>t[i].e;
st[t[i].s ]++;
}
sort(t+1,t+1+n,cmp);
dp[n+1]=0;
for(int i=n;i>=1;i--)
{
    if(st[i]==0)
    {
        dp[i]=dp[i+1]+1;
    }
    else
    {
    for(int j=1;j<=k;j++)
    {
    if(t[j].s==i)    
dp[i]=max(dp[i+t[j].e ],dp[i]);        
    }
     }
}
cout<<dp[1]<<endl;
    return 0;
}

```

---

## 作者：_wkjzyc (赞：22)

##### 一、错误做法：贪心。

本题的实质是区间内放不相交的线段，使空余部分尽可能少。并且能放的线段必须放。

贪心只能求放线段的数量（如 凌乱的yyy/线段覆盖 ），无法求长短。万般无奈之下，只能用坑死无数蒟蒻的dp。

##### 二、划分阶段

首先，这题可不需要区间之类的鬼东西（再说数据范围也不允许）。应该考虑的思路是线性DP。

可以想到记 f[i] 为1~i段时间的最长空闲，但是这样思维难度更大。逆推才是更合适的方案。

换一种思路，记f[i]为i~n段时间的最长空闲。

##### 三、状态转移

对于dp我们的思路类似于数学中的“分类讨论”。

① 当f[i]时没有任务可以做，就+1空闲时间。

f[i]=f[i+1]+1;

② 当f[i]时要做任务（存在p=i），就一个一个任务地搜，选出空闲最长的。计算空闲时，从时间i到时间i+a[i].e（也就是从p开始e秒后）全部休息不了。

故 f[i]=max(f[i+a[i].e],f[i]) max用于选出空闲最长。

##### 四、代码

这种思路还有可以优化的地方，比如排序后的数据能够更快速地找到当前时间可做的任务。不过洛谷的数据有点水（？
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
struct task{
    int p,t;
}a[10005];
bool b[10005];
/*bool comp(task t1,task t2)
{
    return t1.p>t2.p;
}
排序函数。
*/
int main()
{
    int n,k,f[10005];
    cin>>n>>k;
    memset(b,0,sizeof(b));
    memset(f,0,sizeof(f));//注意初始化，我之前WA了两个点
    for(int i=1;i<=k;i++)
    {
        cin>>a[i].p>>a[i].t;
        b[a[i].p]=1;
    }
    //sort(a+1,a+1+k,comp);
    //排序为优化做法，不讨论（好吧其实是我太弱
    f[n+1]=0;
    for(int i=n;i>=1;i--)
    {
        if(b[i])
            for(int j=1;j<=k;j++)
            {
                if(a[j].p==i)
                    f[i]=max(f[i+a[j].t],f[i]);
            }
        else
            f[i]=f[i+1]+1;
    }
    cout<<f[1];
    return 0;
}
```


---

## 作者：FCBM71 (赞：7)

（思路来自同机房巨神@Nyte

DP菜菜FCB又来发题解了！  
翻了一下楼下的大佬的题解好像都是花式的 $ O(n)$ DP，然而此题的数据范围貌似只有 10000，所以可以用 $O(n^2)$ 的搜索过 `AC`

大致思路是建有向图，把每个任务视为一个点，两个任务之间可以休息的时间作为这条边的长度。最后这道题就变成了一个最短路 （最长路？），可以用 bfs(SPFA) 搞定。~~（你想dij我也不阻止你）~~

$\ $

## 分析

### 第一步：建图

$\ \ \ \ $由于每个任务结束之后，只要一有任务，可爱的小尼克就必须做（或者选择其中之一做）。所以我们可以先**对任务按照开始时间排序**，然后对每一个任务都往后展开一次搜索，**找到第一个（或者几个同时开始的）开始时间在它的结束时间以后的任务**。并且在它们之间连一条有向边，边的长度就是休息时间 `a[j].begin-a[i].end` 。这就意味着，以每个点为起点的边至少有一条，不会有很多条。   

$\ \ \ \ $至于如何存储边，本蒟蒻不会线性存储，就想到了开一个二维数组 `b[i][][2]` 存储以 $i$号任务 为起点的所有 目标任务点，和边长。但是一共有 $10000$ 个任务，极限情况下是某一个点连 $9999$ 条边，但是我们显然不可能将数组开到 $10000\times10000$。怎么办呢？vector大法好。由于最多 $10000$ 个任务，所以其实最多存 $10000$ 条边,vector可以有效避免空间浪费

$\ \ \ \ $那么我们应该从哪里开始搜索呢？我们需要再**新增一个虚拟的 $0$ 号任务**，它的结束时间是 $0$。然后按照先前说过的办法连边  
$\ \ \ \ $搜索到什么时候结束呢？我们又需要**新增一个虚拟的 $K+1$ 号任务**，它的结束时间是 $N+1$

$\ \ \ \ $其实这个部分还有很多细节值得注意，详见代码  

$\ \ \ \ $在代码中, $m$ 表示总时间，$n$ 表示任务总数, $b$ 数组是一个vector，用于存储所有边
```
	read(m);read(n);
	for(int i=1;i<=n;++i){
		read(a[i].begin);
		read(a[i].last);
		a[i].end=a[i].begin+a[i].last-1;  //生成点，记得-1
	}
	a[++n].begin=m+1;   //生成虚拟的n+1号任务
	sort(a+0,a+n+1,cmp);   //安开始时间排序
	for(int i=0;i<n;++i){
		int j=i;       //从当前元素开始查找
		while(1){
			++j;
			if(a[j].begin>a[i].end){
				b[i][0].push_back(j);  //存入目的地
				b[i][1].push_back(a[j].begin-a[i].end-1); //存入边长
				if(a[j+1].begin>a[j].begin)break;  
					//把所有同时开始的任务都查找完毕才结束
			}
			if(j==n)break;   //边界特判
		}
	}
```
---

### 第二步：搜索

由于本菜鸡不会 SPFA ，只会写朴素的 bfs ，所以就稍微说一下思路吧。其实感觉和 SPFA 比较像，这部分比较简单，略讲一下

$\ \ \ \ $我们需要两个队列，分别存任务编号，以及累计的总时间。对于每一个队首元素，遍历以他为起点的所有边，当然显然不是所有点都可以入队。 入队条件是 **当前任务累积的休息时间 + 这两个任务之间的休息时间 > 目标任务累积的最大休息时间**

$\ \ \ \ $我们需要另开一个 `maxx数组` 存**每个任务开始时累积的最大休息时间**。特别注意，它需要被memset成 $-1$。不然如果是在 $1$ 时间有开始的任务，否则会 $0+0!>0$，判断不成立，过不了样例QwQ。

```
void bfs(int start){
	x.push(start);
	t.push(0);
	do{
		int xs=x.front();
		int ts=t.front();
		for(int i=0;i<b[xs][0].size();++i){  //判断是否符合入队条件
			if(ts+b[xs][1][i]>maxx[b[xs][0][i]]){
				x.push(b[xs][0][i]);
				t.push(ts+b[xs][1][i]); //入队
				maxx[b[xs][0][i]]=ts+b[xs][1][i]; 更新最大值 
			}
		}
		x.pop();t.pop();   //队首出队
	}while(!x.empty());
}
```

到这里就差不多结束啦！完整代码？还是发一个吧

$\ $

---

## 完整代码

```
#include<cstdio>
#include<queue>
#include<vector> 
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

vector<int>b[10005][2];
queue<int>x,t;
int m,n,maxx[10005];
struct work{
	int begin,end,last;
}a[10005];

inline void read(int &x){
	char ch=' ';
	while(!isdigit(ch)){ch=getchar();}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}                  //快读
}

bool cmp(work a,work b){
	return a.begin<b.begin;
}

void bfs(int start){
	x.push(start);
	t.push(0);
	do{
		int xs=x.front();
		int ts=t.front();
		for(int i=0;i<b[xs][0].size();++i){
			if(ts+b[xs][1][i]>maxx[b[xs][0][i]]){
				x.push(b[xs][0][i]);
				t.push(ts+b[xs][1][i]);
				maxx[b[xs][0][i]]=ts+b[xs][1][i];
			}
		}
		x.pop();t.pop();
	}while(!x.empty());   //bfs遍历边
}

int main(){
	read(m);read(n);
	for(int i=1;i<=n;++i){
		read(a[i].begin);
		read(a[i].last);
		a[i].end=a[i].begin+a[i].last-1;
	}                
	a[++n].begin=m+1;   //读入与建点
	sort(a+0,a+n+1,cmp);
	for(int i=0;i<n;++i){
		int j=i;
		while(1){
			++j;
			if(a[j].begin>a[i].end){
				b[i][0].push_back(j);
				b[i][1].push_back(a[j].begin-a[i].end-1);
				if(a[j+1].begin>a[j].begin)break;
			}
			if(j==n)break;
		}         //建边
	}
	memset(maxx,-1,sizeof(maxx));
	bfs(0);        //搜索答案
	printf("%d",maxx[n]);   //输出
	return 0;
}
```
大功告成！



---

## 作者：VulpesCorsac (赞：7)

根本不需要动态规划，dfs 一次就可以过


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, ans; bool vis [10001][2500];
vector<int> task [10001];
void dfs (int x, int y){ //printf("%i %i\n", x, y);
    if (vis[x][y]||x>k){ return; }
    vis[x][y] = true; ans = max(ans, y);
    if (task[x].empty()){ dfs(x+1, y+1); return; }
    for (int i : task[x]){ dfs(i, y); }
} int main(int argc, const char * argv[]) { scanf("%i%i", &k, &n);
    for (int a, b, i = 0; i < n; i++){ scanf("%i%i", &a, &b);
        a--; task[a].push_back(a+b);
    } ans = 0; dfs(0, 0); printf("%i\n", ans);
    return 0;
}

```

---

## 作者：YoOXiii (赞：6)

逛了一圈题解发现并没有我的思路qvq（虽然我的想法不仅丑陋难写常数大还是nlogn的复杂度

很明显是个DP了emmmm但是我没想到倒序转移这么NB的东西

令dp[i]表示完成前i个任务的总休息时间，如果起点为a[i].x，终点为a[i].y,那么当前值一定是由
### 从起始时间往前数直到另一个任务的起始时间
在这段区间里结尾的i的dp值转移过来

我们考虑以左端点排序，这样预处理出每段区间。暴力转移是n方的，估计也能过，但是我们考虑优化。

  维护一课权值线段树，初值为-inf，在a[i].y的位置上存储dp[i]-a[i].y的值，维护区间最大值，这样我们转移的时候就可以直接寻找区间最大值加上当前左端点，像这样
  ```
dp[i]=query(1,1,10000,a[i].last+1,a[i].x)+a[i].x;
```
因为很明显a[i].x-a[j].y即为休息时间，这样就每次找到最大值。

细节还是很多的，具体见代码

```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;

inline int read() {
	int x=0,f=1;
	char cr=getchar();
	while (cr>'9' || cr<'0') {
		if (cr=='-') f=-1;
		cr=getchar();
	}
	while (cr>='0' && cr<='9') {
		x=(x<<3)+(x<<1)+cr-'0';
		cr=getchar();
	}
	return x*f;
}

const int maxn=10050;

struct node{
	int x,y;
	int last;
}a[maxn];

inline bool cmp1(node a,node b) {
	if (a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}

int tr[maxn<<2];
int dp[maxn];

inline void add(int now,int l,int r,int loc,int val) {
	if (l==r) {
		tr[now]=max(tr[now],val);
		return;
	}
	int mid=l+r>>1;
	if (loc<=mid) add(now<<1,l,mid,loc,val);
	else add(now<<1|1,mid+1,r,loc,val);
	tr[now]=max(tr[now<<1],tr[now<<1|1]);
}

inline int query(int now,int l,int r,int x,int y) {
	if (x<=l && r<=y) return tr[now];
	int ans=-2e9,mid=l+r>>1;
	if (x<=mid) ans=max(ans,query(now<<1,l,mid,x,y));
	if (mid+1<=y) ans=max(ans,query(now<<1|1,mid+1,r,x,y));
	return ans;
}

int main() {
	int n=read(),k=read();
	n++;
	memset(tr,-0x3f,sizeof(tr));
	memset(dp,-0x3f,sizeof(dp));
	int mx=0;
	for (int i=1;i<=k;i++) {
		a[i].x=read(),a[i].y=a[i].x+read();
		mx=max(mx,a[i].x);
	}
	sort(a+1,a+k+1,cmp1);
	int cnt=1;dp[1]=a[1].x-1;
	add(1,1,10000,a[1].y,dp[1]-a[1].y);
	while (a[++cnt].x==a[1].x) {
		dp[cnt]=a[cnt].x-1;
		add(1,1,10000,a[cnt].y,dp[cnt]-a[cnt].y);
	}
	for (int i=1;i<=k;i++) {
		if (a[i].x!=a[i-1].x) a[i].last=a[i-1].x;
		else a[i].last=a[i-1].last;
	}
	int ans=0;
	for (int i=cnt;i<=k;i++) {
		dp[i]=query(1,1,10000,a[i].last+1,a[i].x)+a[i].x;
		add(1,1,10000,a[i].y,dp[i]-a[i].y);
		if (a[i].y>mx) ans=max(ans,dp[i]+(n-a[i].y));
	}
	printf("%d",ans);
}
```


---

## 作者：WB_TS_欧寒 (赞：5)

# DPDPDP
对于每个时刻，如果当前没有任务，那么它的休息时间就是上一次+1，如果有任务那么它
就是上回的休息时间，但是这样顺推有问题，因为你不知道当前时间是否在某一个任务进行的
### 里面，倒推的话就没有这个问题（这是为什么呢？）。
dp[i]表示第 i 秒后能获得的最大休息时间，如果当前无任务那么只要等于 dp[i+1]+1，如果
当前有任务， 那么第 i 秒后能获得的最大休息时间就是 dp[i+task[k]]， 要注意如果一个任务（ 假
定是 k 任务） 在第 i 秒开始，持续 task[k]秒，虽然结束时间是第 i+task[k]-1 秒，但是第 i+task[k]-
1 秒还是在工作的， 在 i+task[k]才可能休息的， 所以对于 dp[i]来说， 如果第 i 秒有任务开始，
那么休息的时间，只能是与 dp[i+task[k]]相同。
而当第 i 秒有多个任务开始那 dp[i] = max{dp[i + task[k]]} k 表示所有在 i 秒开始的任务。
边界条件为： dp[N + 1] = 0（ 工作的时间是 1~N， N+1 超出工作时间， 所以工作时间的休息
时间为 0）。
这里先要把任务按开始时间排序。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long int n,k,sum[10001],num=1,f[10001];
struct Node
{
    long int s,t;
}z[10001];
int cmp(Node a,Node b)
{
    return a.s>b.s;
}
int main()
{
    long int i,j;
    cin>>n>>k;
    for(i=1;i<=k;i++)
    {
    cin>>z[i].s>>z[i].t;
    sum[z[i].s]++;
    }
    sort(z+1,z+k+1,cmp);
    for(i=n;i>=1;i--)
    {
        if(sum[i]==0)
        f[i]=f[i+1]+1;
        else for(j=1;j<=sum[i];j++)
        {
            if(f[i+z[num].t]>f[i])
            f[i]=f[i+z[num].t];
            num++;
        }
    }
    cout<<f[1];
}
```


---

## 作者：andysk (赞：4)

[Link]( https://www.luogu.org/problem/P1280 )

**[Blog](https://tony102.xyz/index.php/2019/10/18/luogu1280-%e5%b0%bc%e5%85%8b%e7%9a%84%e4%bb%bb%e5%8a%a1/)阅读效果更佳**

### 题意

​		有一段长度为 $n$ 的时间,有 $k$ 个任务需要完成,每个任务从$p$开始一直持续$t$分钟,则在$p+t-1$的时刻结束.在某一时刻如果只有一个任务,那么这个任务必须要做.否则,若某个时刻有多个任务,可以任选其中一个做.问一种选择方案使空闲时间(不做任务的时间)最长.



### 题解

​		首先可以考虑从前往后选任务,设 $f[i]$ 表示$[1,i]$时刻可以获得的最大空闲时间.那么转移为:

​																	$$f[i] += f[i+p_j + t_j]$$ 

​		就是说,这一刻能获得的空闲时间肯定会跟选择的任务结束的时间的最大空闲时间挂钩.无法保证DP的无后效性,所以不妨考虑从后转移.

​	    设$f[i]$表示从 $[i,n]$ 时刻可以获得的最大的空闲时间,那么状态有两种:

​		1.这个时候已经选了任务并且还没结束

​		2.这个时候没有在做任何任务且这个时候有任务可做

  那么转移就比较显而易见了,开一个桶$basket[]$表示一条时间轴,在读入时处理某个时候有几个任务

  当$baket[i]=0$,表示此时没有任务可做, $f[i] = f[i+1]+1$

  否则, $f[i] = min\{f[i+a[k].t] |k \in \{1,baket[i]\}\}$

  尔后还需处理一个细节,就是入度的任务要按照起始时间排序.



### Code

见代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 10000 + 5;

int n, k;
int f[SIZE], basket[SIZE];

struct node {
    int st, t;
} a[SIZE];

inline int read()
{
    char ch = getchar();
    int f = 1, x = 0;
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
    return x * f;
}

inline int CMP(node a, node b) 
{
    return a.st > b.st;
}

int main()
{
    int cnt = 1;
    n = read(), k = read();
    for (int i = 1; i <= k; i++)    
        a[i].st = read(), a[i].t = read(), basket[a[i].st]++;
    std::sort(a + 1, a + k + 1, CMP);
    for (int i = n; i >= 1; i--) {
        if (!basket[i]) f[i] = f[i + 1] + 1;
        else {
            for (int j = 1; j <= basket[i]; j++) {
                if (f[i + a[cnt].t] > f[i]) 
                    f[i] = f[i + a[cnt].t];
                cnt++;
            }
        }
    }
    printf("%d", f[1]);
    return 0;
}
```





​	

---

## 作者：2482173874lzy (赞：4)

看了楼上大佬们的题解，基本全用的dp（动态规划）。

其实，这道题还有一种更加朴素的思想：记忆化。

#### 但，不管怎样，记忆化也不是一下子就写出来的####

# 让我们先爆搜吧！#

其实，爆搜很容易想到。首先，本题最大的问题就是在同一时刻，有很多不同的任务可以选择。比如，样例中在第一分钟就可以选择长度为2的任务一（样例中第二行1 2）或者长度为6的任务二（样例中第三行1 6）

这样，我们就很容易想到：dfs每一个情况。比如，先搜起点为1，长度为2的任务，然后发现我们不能同时做起点为1，长度为6的任务，于是我们继续往后搜······


然后，我们直接跳到时间为3的地方（因为1、2都在做任务）。我们发现3这里没有任务，于是空闲时间+1。接着，我们搜到时间为4的地方，发现我们要做任务，从4开始做到14······当搜到时间为16的地方后，我们记录答案后回溯。

然后搜起点为1，长度为6的任务······

以上为dfs基本思路。
```
void dfs(int now,int tot)
{
  if(now==n+1)
  {
  	ans=max(ans,tot);
  	return;
  }
  int cnt=0;
  for(int i=0;i<shed[now].size();i++)
  {
  	if(!vis[shed[now][i]])
  	{
  	  vis[shed[now][i]]=1;
  	  dfs(now+work[shed[now][i]].len,tot);
  	  vis[shed[now][i]]=0;
  	  cnt++;
	}
  }
  if(cnt==0)  dfs(now+1,tot+1);
}
```
------------
很明显，看一下数据：n,k<=10000。很明显，肯定会超时。一定进行了冗余的计算。那么，冗余在哪里呢？

## 我们可以使用记忆化！##
比如，我们把样例改成
```
15 6
1 2
1 6
4 3
8 5
8 1
11 5
```
画出图后可以看到，我们搜完任务1、3之后，到达时刻为8的地方，我们就会把时刻8之后的任务统统搜一遍。而当我们回溯之后再搜任务2的时候，我们按上面的dfs，就会再把第8~15min的任务再搜一遍。其实这就没有必要了，我们之前已经搜过相同的一遍，而两次搜索后时间第8min~15min的空余时间的最大值并不会变化，并且在第1min~7min做任务2所得的空余时间最大值（1）不会比做任务1和任务3更优（2），就可以直接剪枝返回了。我们可以记录搜到第i分钟时当前所获得的空余时间最大值，如果我们又搜到这个时间点，而目前的解不会比之前的更优，我们就可以直接返回，不必再搜了。这就实现了记忆化搜索。而写起来也很简单，只要再加三句话即可。

代码如下（写的有点丑）
```
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
struct node{
  int sta,len;
};
int n,k;
node work[10010];
vector<int> shed[10010];
bool vis[10010];
int f[10010];                                //加的第一句 
int ans=0;
void dfs(int now,int tot)
{
  if(now==n+1)
  {
  	ans=max(ans,tot);
  	return;
  }
  if(tot<=f[now])  return;                   //加的第二句 
  f[now]=tot;                                //加的第三句 
  //以上两句就实现了记忆化 
  int cnt=0;
  for(int i=0;i<shed[now].size();i++)
  	if(!vis[shed[now][i]])
  	{
  	  vis[shed[now][i]]=1;
  	  dfs(now+work[shed[now][i]].len,tot);
  	  vis[shed[now][i]]=0;
  	  cnt++;
	}
  if(cnt==0)  dfs(now+1,tot+1);
}
int main()
{
  memset(f,-1,sizeof(f));
  cin>>n>>k;
  for(int i=1;i<=k;i++)
  {
  	cin>>work[i].sta>>work[i].len;
  	shed[work[i].sta].push_back(i);
  }
  dfs(1,0);
  cout<<ans<<endl;
  return 0;
}
```


---

## 作者：Voldemort123 (赞：4)

## 你从未见过的全(chuan)新题解

看到热门题解都是枚举时间的

来一发枚举任务的

题目中的任务可以看成是线段

定义线段数最多的、两两不相交线段组为“好的”线段组，知在“好的”线段组中再加入任意一条线段都会出现线段重叠

则题意为求“好的”线段组中长度和最小的

为了使其满足这样的性质，定义succ[i]表示每条线段的直接后继线段的左端点（即第i条线段的右端点到succ[i]中没有任何一条线段的左端点）

将线段按照左端点第一关键字升序，右端点第二关键字升序排序，易求succ[i]

设f[i]为前i条线段中“好的”线段组最小的长度和,len[i]为第i条线段的长度,T[i].start/end为第i条线段的左/右端点

有方程
f[i]=min(f[i],f[j]+len[i]),succ[j]=i

初始化时，令f[0]=0,succ[1]=T[1].start

最后，在所有succ[i]=0（即无直接后继线段）的线段i中，对f[i]打擂台即可

```
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>


using namespace std;
const int MAXN=10000,MAXK=10000,INF=0x7fffffff;
int f[MAXN];//f[i]表示前i分钟闲暇时间的最大值

struct times
{
    int start,time,end;
}T[MAXN];
bool operator<(times A,times B)//线段排序
{
    if (A.start==B.start) return A.end<B.end;
    else return A.start<B.start;
}
int N,K,ans,succ[MAXN];
int main()
{
    cin>>N>>K;
    for (int i=1;i<=K;i++)
        cin>>T[i].start>>T[i].time,T[i].end=T[i].start+T[i].time-1;
    sort(T+1,T+K+1);
    memset(succ,-1,sizeof succ);
    for (int i=1;i<=K;i++)
    {
        int num=i;
        while (T[num].start<=T[i].end&&num<=K) num++;
        succ[i]=T[num].start;
        if (num==K+1) succ[i]=0;
    }
    int ans=INF;
    memset(f,0x3f,sizeof f);
    f[0]=0;
    succ[0]=T[1].start;
    for (int i=1;i<=K;i++)
    {
        for (int j=0;j<i;j++)
            if (succ[j]==T[i].start)
                f[i]=min(f[i],f[j]+T[i].time);
    }

    for (int i=1;i<=K;i++)
        if (!succ[i])
            ans=min(ans,f[i]);
    cout<<N-ans<<endl;
}


```


---

## 作者：renxiaoyu (赞：4)

~~大家都说这是道dp水题，就我一个人不觉得吗 $\ \ \ \ \ \  $~~$QWQ$

~~众所周知~~，我们在这个题目里难以从前往后进行动态规划，那么在这种线性的区间题目里，我们不妨先去尝试下从后往前来解题，这可以说是一种经验，也可以说是一种套路。既可以是在线上从后往前，也可以是排序时的从大到小，这题就是按照时间线从后往前。

先来解释 为什么 。如果我们从前往后 dp 的话，我们在考虑到当前时间点的时候，我们要依次考虑选取的区间对答案的影响，这是一个非常庞大而且复杂的问题，最优的区间并没有任何特点，难以找出。但是如果我们如果从后往前 dp 的话，呵呵呵~


------------

如果当前时间点并没有任务的话，可以直接是前一个时间点的最大空闲时间+1。

如果当前时间点有任务的话，挨个遍历这些任务找，$f[i]$为$max(f[$这个时间点第1个任务的持续时间$+$当前时间点]，······)，就是考虑选取这个任务后，最大空闲时间为这些任务的结束时间上的最大空闲时间中的最大值。

伪代码如下：

```cpp
伪代码风格可能比较雷人，凑合着看 QAQ
	if(当前时间点没有任务)
		f[i]=f[i+1]+1;
	else//当前时间点有任务
		for(遍历一下这些任务)
		{
			f[i]=max(f[i],f[i+t[].持续时间]);
		}
```


------------

那么接下来就是一波代码了：
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
struct node//利用结构体
{
	int begin;
	int end;
}t[10010];
bool cmp(node a,node b)//按照时间开始点从大到小排序
{
	return a.begin>b.begin;
}
int sum[10010],f[10010],s=1;
//sum为各个时间点的任务数 s为当前正在考虑第几个任务
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d%d",&t[i].begin,&t[i].end);
        //这里的end并不是结束时间 而是持续时间
		sum[t[i].begin]++;
        //当前时间点的任务数+1
	}
	sort(t+1,t+k+1,cmp);//排序
	for(int i=n;i>=1;i--)//从后往前
	{
		if(!sum[i])//当前没有任务
			f[i]=f[i+1]+1;
		else//当前有任务
		{
			for(int j=1;j<=sum[i];j++)//遍历所有任务
			{
				f[i]=max(f[i],f[i+t[s].end]);//找最大的
                s++;
			}
			
		}
	}
	printf("%d",f[1]);//输出时间点为1时的最大空暇时间
	return 0;
}
```


---

## 作者：zjrdmd (赞：3)

目前的题解中dp均是以时间作为状态的，但是当$n\leq 10^9$时，这种方法就不行了，所以我来写一下不依赖于时间的dp做法。

首先，我们按照**开始时间**对所有任务进行排序。

我们设$dp_i$表示选到第$i$份任务且第$i$份任务必选可以获得的最大空暇时间。

易得dp方程为$dp_i=min(dp_i,dp_j+$两份任务中间隔的时间$)$ $(1\leq j<i)$。

进行上述转移的前提是第$j$个任务和第$i$个任务之间没有其他开始的任务，这个可以通过维护前缀和得知。

特殊的，第一个任务需要特判。

注意答案并不是$dp_n$，只要一个任务结束的时刻到$n$之间没有任何开始的任务，那么均可对答案做贡献。

细节：注意避免不合法转移，比如有的任务必须由尼克的同事去做，那么我们认为这个任务不合法，所有被我们标记为不合法的状态均不能转移到其他状态。

时间复杂度为$O(k^2)$。

code:

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm> 
#define ri register int

inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

const int N=1e4+5;
int dp[N],sum[N],n,k,ans;//第i个工作必须做最大休息数 

struct node{
	int p,l;
}work[N];

bool cmp(node x,node y){
	return x.p<y.p;
}

int main(){
	n=read(),k=read();
	for(ri i=1;i<=k;i++)dp[i]=-1;
	for(ri i=1;i<=k;i++)work[i].p=read(),work[i].l=read(),sum[work[i].p]++;
	std::sort(work+1,work+k+1,cmp);
	for(ri i=1;i<=n;i++)sum[i]+=sum[i-1];//时刻1-i的工作总数 
	for(ri i=1;i<=k;i++){
		for(ri j=1;j<i;j++){
			if(dp[j]!=-1&&work[i].p>=work[j].p+work[j].l&&sum[work[i].p-1]-sum[work[j].p+work[j].l-1]==0)dp[i]=std::max(dp[i],dp[j]+(work[i].p-(work[j].p+work[j].l))); 
		}
		if(sum[work[i].p-1]==0)dp[i]=std::max(dp[i],work[i].p-1);
	}
	for(ri i=1;i<=k;i++){
		if(sum[n]-sum[work[i].p+work[i].l-1]==0&&dp[i]!=-1)ans=std::max(dp[i]+(n-(work[i].p+work[i].l))+1,ans);
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：Honeta (赞：3)

## LUOGU P1280 SOLUTION
### 解题思路  

**动态规划**，具体步骤如下：
1. 预处理阶段 

设置两个bool数组begin、end，begin数组记录每个时间点有无任务开始，end数组记录每个时间点有无任务结束。每次输入一个任务的起止时间后，更新两个bool数组并建立一条从终止时间到起止时间的有向边，用vector实现的二维数组存储。

2. DP阶段  
  
从后往前进行一遍扫描。设置数组f，f[i]记录从时间点i到工作日结束之间最长的空暇时间（即：时间点i的“**逆推最大空暇时间**”）。  
  
扫描到有任务结束的时间点时，以为此时任务刚结束，从下一分钟才会进入空暇状态，故我们用当前时间下一分钟的“逆推最大空暇时间”分别对【当前时间结束的所有任务】的起始时间的“逆推最大空暇时间”进行比较，若更大则替换之。这一步把所有有任务开始的时间点的“逆推最大空暇时间”已经更新为最优解。
  
同时，若没有任务在当前时间开始，则下一分钟的“逆推最大空暇时间”加一之后即为当前时间的“逆推最大空暇时间”。  
  
一遍扫描过后，f[1]即为从工作日开始到工作日结束的“逆推最大空暇时间”，直接输出即可。
    
### AC代码
```cpp
#include<cstdio>
#include<vector>
using namespace std;
int n,k,t,p,now,f[10001];
bool begin[10001],end[10001];
vector<int> v[10001];
int max(int x,int y){return x>y?x:y;}
int main()
{
  scanf("%d%d",&n,&k);
  for(int i=1;i<=k;i++)//预处理阶段
    {
      scanf("%d%d",&p,&t);
      begin[p]=1;//做标记
      end[p+t-1]=1;
      v[p+t-1].push_back(p);//建边
    }
  for(int i=n;i>=1;i--)//DP阶段
    {
      if(end[i])
	for(int k=0;k<v[i].size();k++)
	  f[v[i][k]]=max(f[v[i][k]],f[i+1]);
      if(!begin[i])f[i]=f[i+1]+1;
    }
  printf("%d",f[1]);
  return 0;
}
```


---

## 作者：fscbti (赞：3)

虽然文章已经有很多了，但是许多是重复的，不同有价值的思路并没有很多，所以，在此提出一种新思路。

这种思路不同于~~所有~~题解，无需排序，正着做（当然还是$DP$）。

首先可以转换一下思路，用$DP$来求做少工作时间，那么答案就是$n-$最小工作时间。

接着，根据题意，如果此任务在$x$时开始，那么从$1-x$都可以执行（暂定）那么便要枚举前$1-x$的量，然而，这题有一个限定：只要此时空闲，如有任务，必须做。这样，就应该用一个数组标记此时是否有任务，由于时间单调上升，只需记录目前最迟的有任务时间即可，因此就要从最迟的时间加一开时遍历，如此时间也顺带优化了。

但是如果有相同时间开始的任务怎么办呢？实际上只需要分开处理就好了。

可以设$f[i]$表示$1-i$最小工作时间

这种方法保证了无后效性，甚至可以把当作背包理解
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map> 
#include<bitset>
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
}
struct tt{
	int x,y;
}a[10005];
int n,k,f[10005],ss;
bool b[10005];
signed main(){
	n=read();k=read();
	for(int i=1;i<=k;i++){a[i].x=read();a[i].y=read();}
	memset(f,0x3f,sizeof(f));f[1]=0;
	for(int i=1;i<=k;i++){
		if(a[i].x==a[i-1].x){//特殊处理相同任务
			f[a[i].x+a[i].y]=min(f[a[i].x+a[i].y],f[a[i].x]+a[i].y);
            //根据题目而来的转移方程
            //上面是特殊处理相同时间开始任务开始时间对后面时间的影响
			for(int j=a[i].x-1;!b[j]&&j;j--){
				f[a[i].x+a[i].y]=min(f[a[i].x+a[i].y],f[j]+a[i].y);
                //此转移方程与上面一个意思
			}
		}
		else {
			for(int j=a[i].x;!b[j]&&j;j--){
				f[a[i].x+a[i].y]=min(f[a[i].x+a[i].y],f[j]+a[i].y);
			}
			b[a[i].x]=1;//标记，此时已有任务
		}
	}
	for(int i=n+1;!b[i]&&i;i--)ss=max(ss,n-f[i]);
    //这里就是坑点了，f[i]表示的是i之前这个工作时间的最小值，i为空闲时间，有可能为n+1了（题目一保证工作时间小于等于n，那么空闲时间最大为n+1了）
	cout<<ss<<endl;
	return 0;
}
```


---

## 作者：Redstone红石粉 (赞：3)

设计状态f【i】表示在i~T（T为总时间）的时间内的最大闲暇时间

状态转移方程：

如果时间点i处没有任务，则f【i】= f【i+1】+1;

如果时间点i处有任务，则f【i】=max（f【i+任务k的持续时间】）;   //此处k = 1~时间点i处的任务总个数

所以很容易发现，想要知道f【i】，必须先求出 f【比i大的时间点】，所以确定本题倒推：由f【T】递推到f【1】。


那么如何记录下 时间点i处的每个任务的信息呢，直接将“任务（开始时间、持续时间）”定义成结构体。输入完毕后，以每个任务的开始时间为关键字 从大到小排序。这样就使得 开始时间相同的任务 靠到了一起，并且接下来dp时直接从下标1开始往后做，就保证了倒推（时间从后往前）。


具体实现如下：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 1e4+10;
int f[maxn],sch[maxn],T,n;// sch[i]表示在时间点i处的任务数量，初始都为0 。 
struct task{
    int s,l; //s为任务的开始时间，l为任务的持续时间 
}t[maxn];
int cmp(task a,task b){
    return a.s > b.s;  //按开始时间从大到小排序
}
int main(){
    scanf("%d%d",&T,&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&t[i].s,&t[i].l);
        sch[t[i].s]++;
    }
    sort(t+1,t+n+1,cmp);
    for(int i=T,now=1;i>=1;i--){
        if(!sch[i])f[i]=f[i+1]+1;
        else for(int k=1;k<=sch[i];k++,now++) f[i]=max(f[i],f[i+t[now].l]);
        //从sch[i]个任务里面 找到一个任务，使得 f[i+这个任务的持续时间] 最大 
    }
    printf("%d\n",f[1]);
    return 0;
}
```

---

## 作者：zkx06111 (赞：3)

另一种方法：

求最大空闲时间即求最小消耗时间。

f[i]表示以第i个任务结尾的工作序列的最小消耗时间

把任务按照开始时间排序，以确保如果某一时刻无其他任务必须做一个。

f[i]=f[j]+cost(i) 仅当end(j)<start(i) 且 在区间(end(j),start(i))中无其他任务。

使用cnt(i)表示从1-i时刻有几个任务，如果cnt(a)==cnt(b)则说明a,b间无任务。


```cpp

#include <iostream>
#include <climits>
#include <algorithm>
#define start(x) task[x].start
#define cost(x) task[x].cost
#define end(x) task[x].end
using namespace std;

struct ts{
    int start;
    int cost;
    int end;
}task[10001];

bool cmp(ts a,ts b){
    return a.start<b.start;
}

int n,k,f[10001],cnt[10001];
int b[10001];

int main(){
    cin>>n>>k;
    for (int i=1;i<=k;i++){
        cin>>start(i)>>cost(i);
        end(i)=start(i)+cost(i)-1;
        ++b[start(i)];
    }
    for (int i=1;i<=n;i++)
        cnt[i]=cnt[i-1]+b[i];
    sort(task+1,task+k+1,cmp);
    int ans=0;
    for (int i=1;i<=k;i++){
        f[i]=INT_MAX/3;
        for (int j=0;j<i;j++)
            if (start(i)>end(j) && cnt[start(i)-1]==cnt[end(j)])
                f[i]=min(f[i],f[j]+cost(i));
        if (cnt[end(i)]==cnt[n])
            ans=max(ans,n-f[i]);
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：tindon (赞：2)

# 题意
在第一分钟到第t分钟， 一共有n个任务等尼克去做， 每个任务都有开始时间和结束时间， 求尼克的最大休息时间

# 思路
### 子问题：
这是一道动态规划， 首先需要找出无后效性的子问题。 我先想到的子问题是， 用 dp[i]表示第1到第i分钟的最大空闲时间， 但是你会发现， 前 i 分钟选择的任务是对后面的最大空闲时间的计算是有影响的， 所以不满足无后效性。 然后又想到一个子问题， 用dp[i]表示第 i 分钟到第 t 分钟的最大空闲时间， 那么这个时候， 不管你后 i 分钟选择的任务是什么， 都对后续计算无影响， 即满足无后效性。

所以子问题为： dp[i]表示第 i 分钟到第 t 分钟空闲时间的最大值
### 递推方程：
如果第 i 分钟无任务
dp[i] = dp[i+1]+1
如果第 i 分钟有任务
for 1 c[i][0] //c[i][0]表示第 i 分钟的任务个数
dp[i] = max(dp[i+c[i][k]]， dp[i])

# 代码

```
#include<bits/stdc++.h>
using namespace std;

int n, k;
struct work{
	int s;
	int t;
};

work c[10010];
int num[10010];
int pos[10010];
int dp[10010];

bool cmp(work i, work j)
{
	return i.s < j.s;
}

int main()
{
	cin >> n >> k; //工作时间和任务总数
	memset(num, 0, sizeof(num));
	memset(dp, 0, sizeof(dp));
	for(int i = 1; i <= k; i++)
	{
		cin >> c[i].s >> c[i].t;
		num[c[i].s]++;
	} 
	sort(c+1, c+k+1, cmp);
	pos[1] = 1;

	for(int i = 2; i <= n; i++)
	{
		pos[i] = pos[i-1] + num[i-1];
	}

	for(int i = n; i > 0; i--)
	{
		if(num[i] == 0)
			dp[i] = dp[i+1] + 1;
		else
		{
			for(int j = 1; j <= num[i]; j++)
			{
				dp[i] = max(dp[i+c[pos[i]-1+j].t ], dp[i]);
			}
		}
	}

	
	
	cout << dp[1];
}
```


---

## 作者：hjsjhn (赞：2)

就是个最短（长）路裸题。

我们知道每个区间的事情做完之后肯定会去做后面的第一个开始（可能有多个）的区间，所以直接将每一个不同的区间当成一个点，然后每个点向后面的第一个区间代表的点连边。

每两个点之间的权值就是两个区间的长度（注意区间的开闭情况），然后枚举开头最早的第一个区间所代表的所有点。

跑最长路（就是像最短路类似的方法跑SPFA）,最后跑出来区最大值就是结果了。

``` cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
#define MAX_N 20007

int N, k, sz;
std::vector<int> sta[MAX_N], stp[MAX_N], tim[MAX_N], now;
int head[MAX_N], to[MAX_N * 1000], nxt[MAX_N * 1000], dis[MAX_N * 1000], cap;
int bg[MAX_N], ed[MAX_N];
int res, d[MAX_N], stad;
bool inq[MAX_N];

void add_edge (int u, int v, int w) {
    //printf("%d %d %d\n", u, v, w);
    nxt[++cap] = head[u];
    head[u] = cap;
    to[cap] = v;
    dis[cap] = w;
}

void spfa (int s) {
    memset(inq, false, sizeof(inq));
    memset(d, -1, sizeof(d));
    std::queue<int> q;
    q.push(s);
    inq[s] = true;
    d[s] = 0;
    while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int i = head[x]; i; i = nxt[i]) {
        if (d[to[i]] < d[x] + dis[i]) {
        d[to[i]] = d[x] + dis[i];
        res = std::max(res, d[to[i]]);
        if (!inq[to[i]]) q.push(to[i]), inq[to[i]] = true;
        }
    }
    inq[x] = false;
    }
}

int main () {
    scanf("%d%d", &N, &k);
    int s, l;
    for (int i = 1;i <= k; ++i) {
    scanf("%d%d", &s, &l);
    sta[s].push_back(++sz);
    stp[s + l - 1].push_back(sz);
    ed[sz] = s + l - 1;
    bg[sz] = s;
    }
    for (int i = 1;i <= N; ++i) {
    while (!now.empty() && !sta[i].empty()) {
        for (int j = 0;j < sta[i].size(); ++j)
        add_edge (now[now.size() - 1], sta[i][j], i - ed[now[now.size() - 1]] - 1);
        now.pop_back();
    }
    for (int j = 0;j < sta[i].size(); ++j) tim[ed[sta[i][j]]].push_back(sta[i][j]);
    while (!tim[i].empty()) now.push_back(tim[i][tim[i].size() - 1]), tim[i].pop_back();
    }
    while (!now.empty())
    add_edge (now[now.size() - 1], sz + 1, N - ed[now[now.size() - 1]]), now.pop_back();
    for (int i = 1;i < N; ++i) {
    if (sta[i].empty()) continue;
    stad = i - 1;
    for (int j = 0;j < sta[i].size(); ++j)
        spfa (sta[i][j]);
    break;
    }
    printf("%d\n", res + stad);
    return 0;
}

```

---

## 作者：封禁用户 (赞：2)

#蒟蒻的题解

其实也就是一个分组背包而已..以任务开始的时间分组，所有开始时间相同的任务在同一组内


```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <functional>
#include <cstdlib>
#include <map>
using namespace std;

using int_t = unsigned long long int;

int main() {
    int_t timeLimit, count;
    cin >> timeLimit>>count;
    //数据存在map里 map[任务开始时间]
    map<int_t, vector < int_t>> tasks;
    for (int i = 1; i <= count; i++) {
        int_t start, cost;
        cin >> start>>cost;
        tasks[start].push_back(cost);
    }
    int_t dp[10001] = {0};
    //开始dp 
    for (int_t time = timeLimit; time >= 1; time--) {
        //如果当前时间点没有任务开始，则直接改为上一点的值+1
        if (tasks.find(time) == tasks.end()) {
            dp[time] = dp[time + 1] + 1;
            continue;
        }
        vector<int_t> &vec = tasks[time];
        //选择任务之前先对任务的结束时间从大到小排序
        sort(vec.begin(), vec.end());
        for (auto ptr = vec.begin(); ptr < vec.end(); ptr++) {
            dp[time] = max(dp[time], dp[time + *ptr]);
        }
    }
    cout << dp[1];
}
```

---

## 作者：greyishsong (赞：2)

##分享一个二分查找优化的思路

整体上是这样的：从后往前，对于每一个任务k，寻找之后的任务中第一个在该任务结束后开始的任务：

- 如果没有这样的任务，那么从任务k开始，能够休息的最长时间就是n+1-end of k；

- 如果有，设找到的任务起始时间为p，那么从任务k开始，能够休息的最长时间就是p-end of k+max{ start of j=p | dp[j] }，也就是所有从p开始的任务中的最优解加上两个任务中间的空闲时间。

实现：

开始还是将所有的任务按照起始时间排序，之后从最后一个任务开始倒推，上述的寻找过程可以用二分查找优化，用maxi数组记录所有起始时间点处的最优解，每次dp求值之后也更新maxi数组，详见代码。

总复杂度O(nlogn)，效率要略低于O(n)的分组背包思路，用时12ms，算是抛砖引玉了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 10001
using namespace std;
struct line
{
    int l,r;
}a[maxn];
bool cmp_sort(const line &a,const line &b);
int dp[maxn],left[maxn],maxi[maxn],n,k,ans=0;
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;i++)
    {
        int t;
        scanf("%d%d",&a[i].l,&t);
        a[i].r=a[i].l+t;
    }
    n++;
    sort(a+1,a+k+1,cmp_sort);
    for(int i=1;i<=k;i++)
        left[i]=a[i].l;
    memset(maxi,0,sizeof(maxi));
    for(int i=k;i>=1;i--)
    {
        int pos=lower_bound(left+i+1,left+k+1,a[i].r)-left;
        if(pos==k+1)
            dp[i]=n-a[i].r;
        else
            dp[i]=a[pos].l-a[i].r+maxi[a[pos].l];
        maxi[a[i].l]=max(maxi[a[i].l],dp[i]); 
    }
    for(int i=1;a[i].l==left[1];i++)
        ans=max(ans,dp[i]);
    ans+=(left[1]-1);
    printf("%d\n",ans);
    return 0;
}
bool cmp_sort(const line &a,const line &b)
{
    return a.l<b.l;
}
```

---

## 作者：天狗的手帖 (赞：2)

看了一下感觉大家的方法都很烦啊。。


用f[i]表示从i到n位置的最大空闲时间，p[i]表示第i个任务的开始时间,t[i]表示第i个任务的结束时间


从n开始到1枚举i，如果存在p[j]=i，那就说明此时的最优解必须选择一个任务来做，所以我们就枚举所有p[j]=i的任务的结束时间，找到最大值的f[i+t[j]]转移到f[i],如果不存在任何一个任务p[j]=i，那么说明此时的最优解可以偷懒，就直接用f[i+1]+1作为f[i]的值


\*优化

我们发现输入数据是根据任务的开始时间有序的，所以每次使用的j肯定不会大于上一次的j，令j等于最后一个任务每次向前递减，时间复杂度非常好


PASCAL代码


```delphi

var n,m,i,j:longint;
    p,t,f:array[0..10001] of longint;

function max(a,b:longint):longint;

begin

        if a>b then exit(a)

               else exit(b);

end;

begin

        readln(n,m);

        for i:=1 to m do readln(p[i],t[i]);

        j:=m;

        for i:=n downto 1 do begin

        if p[j]<>i then f[i]:=f[i+1]+1

                   else

                   while p[j]=i do begin

                        f[i]:=max(f[i+t[j]],f[i]);

                        j:=j-1;

                        end;

                   end;

        writeln(f[1]);

end.

```

---

## 作者：sqc1999 (赞：2)

按照时间进行决策，如果当前时间没有要开始的工作，就进入下一分钟，同时空闲时间加1，否则直接跳过工作的那段时间进入工作结束时间的下一分钟。

因为数据是按开始时间排好序了的，我这里使用了一个map把开始时间t和数组中第一个开始时间为t的工作的下标对应起来，这样只要在这个map中查找就可以确定当前是否有要开始的工作以及这些工作存放在数组中的哪个位置。

```cpp

#include<iostream>
#include<algorithm>
#include<map>
#include<cstring>
using namespace std;
struct job
{
    int start,last;
};
job a[10001];
map<int,int> m;
int n,k,b[10001];
int f(int t)
{
    if (t>n) return 0;
    else if (b[t]!=-1) return b[t];
    else if (m.find(t)==m.end()) b[t]=f(t+1)+1;
    else
    {
        int pos=(*(m.find(t))).second,ma=0;
        while (a[pos].start==t)
        {
            ma=max(ma,f(t+a[pos].last));
            pos++;
        }
        b[t]=ma;
    }
    return b[t];
}
int main()
{
    cin>>n>>k;
    for (int i=1;i<=k;i++)
    {
        cin>>a[i].start>>a[i].last;
        if (m.find(a[i].start)==m.end()) m.insert(pair<int,int>(a[i].start,i));
    }
    memset(b,255,sizeof(b));
    cout<<f(1);
    return 0;
}

```

---

## 作者：Tgo_ (赞：1)

新手上路，真的是看不懂大佬们怎么找出逆推转移的。勉强理解就是，如果加入该任务，则清空此任务至任务结束时间内累计的摸鱼时间，反之顺推，没有摸鱼时间的记录，无法转移。

 _则该任务将在第P+T-1分钟结束。_ 这句话是真的坑到我了。
 
### 核心
	ans[i] = Math.max(ans[i], ans[T[t]]);
    

------------
### 代码

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	static int N,K;
	static int[] P = new int[10001];
	static int[] T = new int[10001];
	static int[] ans = new int[10010];
	
	static void in() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer token = new StringTokenizer(in.readLine());
		N = Integer.valueOf(token.nextToken());
		K = Integer.valueOf(token.nextToken());
		for(int i=1; i<=K; i++){
			token = new StringTokenizer(in.readLine());
			P[i] = Integer.valueOf(token.nextToken());
			T[i] = Integer.valueOf(token.nextToken()) + P[i];
		}	
	}
	public static void main(String[] args) {
		try{
			in();
		}catch(IOException e){
			e.printStackTrace();
		}
     		// 以上均为日常，正文在下
		int t=K; // 利用这个t，就不需要开数组记录该时间点是否有任务了，不过多了块for
		for(int i=N; i>=1;i--){
			for(;P[t]!=i;i--)
				ans[i] = ans[i+1]+1;
			if(i<1) break;
			for(;P[t]==i;t--)
				ans[i] = Math.max(ans[i], ans[T[t]]);
		}
		System.out.print(ans[1]);
	}
}
```
壮哉我大JAVA！~~特码，输入就占了大半代码，JAVA就是壮！~~

---

## 作者：君玘 (赞：1)

这道题应学长要求写的DP，不容易啊。

首先分析一下题目：尼克工作从1到n。若他空闲，则接下来的第一波任务他一定得接其中之一。而在他工作期间，即p到p+t-1的时间内开始的任务他一概不考虑，他的空闲时间就是next_p-p(差不多理解下就好，不是重点)。现在求尼克的最大空闲时间。

深搜模拟样例：

                0
       (0)              (0)
      1—2               1—6
       (1)          (1)      (1)
      4—14         8—12      8—8 
       (1)          (3)        (2)
                             11—15
                               (0)
                               
括号内的是这期间的空闲时间。我们可以发现第二分支选择8到12是优于8到8的，即它是由子节点的值决定的，只要我们求得它的叶节点，然后选择最优的那一条分支就行。那么f[i],i表示开始时间，f[i]就是第i分钟开始的任务后面的最优解。解释的不好，看代码注解吧。

```cpp
#include<bits/stdc++.h>
#define gc ch=getchar()
#define max(a,b) a>b?a:b
using namespace std;
template <class T>void read(T &s){
	s=0;T f=1;char gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;gc;}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';gc;}
	s*=f;	
}
template <class T>void put(T s){
	if(s<0) putchar('-'),s=-s;
	if(s>9) put(s/10);
	putchar(s%10+'0');
}
struct node{
	int f,l;
}a[10005]; 
int n,k,f[10005],v[10005];
int main(){
	read(n),read(k);
	for(int i=k;i;--i)
		read(a[i].f),read(a[i].l),a[i].l+=a[i].f-1,v[a[i].f]=1;
	//任务，f为开始时间，求得l为结束时间；注意，这里是倒着存的 
	for(int i=1;i<=k;++i){
		//先求后面的任务 
		for(int j=a[i].l+1;j<=n;++j){
		//	f[i]的i表示的是开始时间，它的最优解为它结束后第一 
		//	个任务的最优解加上它们两个之间的空暇
			if(j==n&&!v[j]) 
				f[a[i].f]=max(f[a[i].f],j-a[i].l+f[j]);
			else 
				f[a[i].f]=max(f[a[i].f],j-a[i].l-1+f[j]);
			if(v[j]) break;
			//f[j]就是后面所有的最优解了，所以直接跳出循环即可 
		}
	}
	put(f[a[k].f]+a[k].f-1);
	//答案还要加上一开始的空暇时间 
}
```


---

## 作者：我很低调 (赞：1)

题目描述
尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。

尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。

写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。

输入格式
输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。

接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。

输出格式
输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。

其实也没啥，和楼上大佬说的一样，不过我代码里的
j比较特殊，就代表在k个任务中，哪个任务是我们在i的时间可以选择的。
然后输出f[1](意思是从1到n的时间最优值）；
以下代码：

```cpp
#include<iostream>
#include<bits/stdc++.h>
#define ll register int
#define maxs 0x3f3f3f3f
using namespace std;
struct node{
	int a,b;
}x[10000001];
bool cmp(node a,node b){
	return a.a>b.a;
}
int f[1000001]={0};
int sm[1000001]={0};
int main(){
	//freopen(".in","r",stdin);freopen(".out","w",stdout);
	int n,k;
	scanf("%d%d",&n,&k);
	for(ll i=1;i<=k;i++)
		scanf("%d%d",&x[i].a,&x[i].b),sm[x[i].a]++;
	sort(x+1,x+1+k,cmp);
	for(ll i=n;i>=1;i--){
		if(sm[i]==0)
			f[i]=f[i+1]+1;
		else
			for(ll j=1;j<=k;j++)
				if(x[j].a==i)
					f[i]=max(f[i],f[i+x[j].b]);
	}
	printf("%d",f[1]);
}
```
大佬再见~

---

## 作者：MashPlant (赞：1)

贡献一发记搜+标准库multimap的题解，可以把找任务做的很简洁



```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
int t, n;
multimap<int, int> mmp;
int f[10010];
int dfs(int k) //k是时间,dfs找出最短工作时间
{
    if (f[k])
        return f[k];
    if (k > t)
        return 0;
    int ans = inf;
    for (auto it = mmp.lower_bound(k); it != mmp.upper_bound(k); ++it)
        ans = min(dfs(it->second) + it->second - it->first, ans);
    if (ans == inf) //没有工作
        ans = dfs(k + 1);
    return f[k] = ans;
}
int main()
{
    cin >> t >> n;
    for (int i = 1; i <= n; ++i)
    {
        int P, T;
        cin >> P >> T;
        mmp.insert({P, P + T}); //second时刻工作已经结束
    }
    cout << t - dfs(1) << endl;
    return 0;
}
```
标准库multimap可以储存一对多的键值对，适合这里的一个开始时间可能对应不同任务。可以利用上述方式来遍历一个键对应的值。
dfs(k)的意义是，保证了k时刻在做选择之前是自由时刻，k时刻可能有几个任务可以选，也可能没有任务，分别处理之。return时做一下记忆化即可。


---

## 作者：ArgoC (赞：1)

f[i]表示由时间点i到时间n之间最大空暇时间

结构体由开始时间从后往前进行排序

若时间点i处没有任务,f[i]=f[i+1]+1

如果有任务,f[i]=max(f[i],f[i+第k个任务的持续时间])

时间点为从后往前倒退

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int now;
struct miss
{
    int st;//开始时间
    int la;//持续时间
};
bool cmp(miss a,miss b)
{
    return a.st>b.st;    //按照开始时间由后向前排序
}
struct miss m[10001];
int mis[10001];//mis[i]表示在时间i时开始的任务数
int f[10001];
int n,k;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=k;i++)
    {
        cin>>m[i].st>>m[i].la;
        mis[m[i].st]++;//统计任务数
    }
    sort(m+1,m+1+k,cmp);
    for(int i=n,now=1;i>=1;i--)
    {
        if(!mis[i])//若该点没有任务可做
            f[i]=f[i+1]+1;
        else
        {
            for(int k=1;k<=mis[i];k++,now++)//now用来计量第几个任务
            {
                f[i]=max(f[i],f[i+m[now].la]);
            }
        }
    }
    cout<<f[1];
    //system("pause");
    return 0;    
}
```

---

## 作者：OsvaldoAsensioLopez (赞：1)

线性动态规划，令f[i]为第i~T的工作时间中最大空闲时间

我们可以使用一个包含开始、持续时间的结构体储存每个任务

但任务结束后的情况之前没转移，因此要倒着转移才能推出所有情况

即时间从T~1

因为要倒推，所以要将任务按照开始时间从大到小排序，使f[i+这个任务持续时间]最大






```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct task {
    int start;//任务开始时间 
    int last;//任务持续时间 
}t[10001];
int sch[10001]={0},f[10001];//sch[i]->时间为i时任务数量,f[i]->第i个工作时间开始到最后一个工作时间最大空闲时间 
//按开始时间从大到小排序 
bool cmp(task a,task b) {
    return a.start>b.start;
}
int main() {
    int T,n;//T表示工作时间,n表示任务数量
    cin >> T >> n;
    for(int i=1;i<=n;i++) {
        cin >> t[i].start >> t[i].last;
        sch[t[i].start]++;
    }
    sort(t+1,t+n+1,cmp);
    int now;//从开始到现在所经历的任务编号 
    for(int i=T,now=1;i>=1;i--) {
        if(!sch[i]) f[i]=f[i+1]+1;//没有任务就将上一个任务开始时间加1
        else {
            //从sch[i]个任务中找一个任务，使f[i+这个任务持续时间]最大 
            for(int k=1;k<=sch[i];k++,now++) {
                f[i]=max(f[i],f[i+t[now].last]);
            }
        } 
    }
    cout << f[1] << endl;
    return 0;
}

```

---

## 作者：91khr (赞：1)

~~做了一天终于A了, 怒水一波题解~~


- 把任务是按照开始时间排序, 方便计算和证明.

- 题目告诉我们只能在**同一开始时间**的任务中选择, 所以当我们选择的时候, 我们必须考察**所有**以这一时间开始的任务~~(废话)~~.

- 碰到第一个可以做(在当前任务结束后开始)的任务就必须做了, 所以可以只在一系列以同一时间开始的任务中的第一个存储dp的信息, 因为在之后的搜索中是无法到达后面这个时间的任务的.(当然全存上也可以A, 不过这样代码短一点)


```cpp
#include <cstdio>
#include <algorithm>
#include <limits>

struct Job
{
    int p;  //!< 任务的开始时间
    int t;  //!< 任务的持续时间
    struct comp
    {
        //! @bug 这个比较函数其实不符合标准的规定, 但是能用就行
        bool operator()(const Job& a, const Job& b)
        {
            return a.p<b.p;
        }
    };
};

int n, k;
Job work[10010];
int dp[10010];

//! @return 从任务src或与它开始时间相同的任何任务开始, 能获得的最小工作时间
int cal(int src)
{
    // 无脑查表
    if(dp[src] != std::numeric_limits<int>::max())
        return dp[src];
    // 边界情况, 此时工作时间总为0
    if(src == n)
        return 0;
    // 索引, 可以不用, 懒得删了
    int i = src;
    do
    {
        int next = i + 1;
        // 找出开始时间大于当前任务的第一个任务
        while(work[next].p < work[i].p + work[i].t)
            ++next;
        // 无脑填表
        dp[src] = std::min(dp[src], cal(next) + work[i].t);
        // 前进到下一个任务
        ++i;
    } while(work[i].p == work[src].p);  // 考察所有开始时间与当前任务相同的任务
    return dp[src];
}

int main(void)
{
    std::scanf("%d %d", &n, &k);
    for(int i = 0; i < k; ++i)
    {
        std::scanf("%d %d", &work[i].p, &work[i].t);
        dp[i] = std::numeric_limits<int>::max();
    }
    // 人为添加一个开始时间在所有任务结束时间之后的任务, 这样就可以在搜索到它的时候停止搜索继续任务
    work[k] = n+1;
    std::sort(work, work+k, Job::comp());

    // 我们计算出来的是最小工作时间, 所以要用总时间减去它得到最大休息时间
    std::printf("%d\n", n - cal(0));

    return 0;
}
```


---

## 作者：ww3113306 (赞：1)

尼克的任务，貌似可以理解为分组背包。每个时间点就是一个组，如果这个组里有东西，就可以开始处理，每个组只能选一个，

这里也是一样，同一个时间点开始的任务，只能选一个进行，这是显而易见的，也就相当于每组任务只能选一个最优解

然而时间要倒着来，原因就不说了

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{
    int first,last;
};
int n,t,ans,have[10100],f[10100];abc s[10100];
bool cmp(abc x,abc y)
{
    return x.first>y.first;
}
int main()
{
    int j,i,now=1;
    scanf("%d%d",&t,&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&s[i].first,&s[i].last);
        have[s[i].first]++;
    }
    sort(s+1,s+n+1,cmp);
    for(i=t;i>=0;i--)
    {
        if(!have[i]) f[i]=f[i+1]+1;
        else 
        for(j=1;j<=have[i];j++,now++)//因为s数组里面只有任务，所以now在任务的时候就++，并且因为s数组已经排了序，所以直接用now来选任务就可以选到要选的
            if(f[i]<f[s[now].first+s[now].last]) f[i]=f[s[now].first+s[now].last];//这里一定不要-1，因为下一次是从f[s[now].first+s[now].last]再开始的，所以不要-1（其实我也不太确定是不是这个原因，，，反正-1就wa，不-就AC，可能也是因为我的算法在某些细节上不太一样）
    //    if(f[i]>ans) ans=f[i];
    }
    printf("%d",f[1]);//因为所有的值最后都累加到f[1]上了，所以输出f[1]而不是跟平常一样输出f[n]
    return 0;
}

```

---

## 作者：xzyxzy (赞：1)

很难得很难得很难得的，一道区间动规的题能不看题解（看题解写dp是个不好的习惯，请不要学习我(/笑哭/)）自己推出转移方程式来，还一遍过了

ps:以前的题解动规都写成了动归，实在是尴尬。。。请谅解（/擦汗/）

那么推的过程对于我这种小蒟蒻来说，真的很复杂很复杂，推了一下午一个半小时，又码了半个小时，草稿纸A4大小的写满了好几张，顺着退啊不行又逆着推，二维不行降一维，以结束时间排序不行改按开始时间排序，折腾了好一会终于找到一个几近O(n)的高效又不炸空间的算法


好吧，进入正题

首先，要注意的是题目的时间，**时间是一段**，所以时间轴上0到1指的是第一分钟，，所以我们分析样例的时候要从0开始画时间轴，取时间段来安排尼克的任务

这点明确后，就很容易描述各个任务的起始点和结束点还有持续时间了，我们用结构体表示各个任务

然后，最重要的是>当在一个任务起始时尼克有空的话，尼克必须选

所以我们要对各个任务的开始时间进行排序，从后往前枚举开始时间的过程中，碰到一个任务就必须选（实际上因为只有这一种情况所以我们才从后往前枚举开始时间）

于是转移方程式的原理就清晰了：

>从第i个时间点到第n个时间点尼克最小的工作时长 为选 以第i个时间点为起始时间的任务的工作时间 加上从那个任务的结束时间到n 的最小总工作时间（因为以同一点为起始时间的任务可能不止一个，所以选最小）

那么清楚了，就来看代码吧（详细注释）



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n,k;
int min1(int a,int b){return a<b?a:b;}//防止一些版本中没有min（）函数，所以自定义一个
int read()//有一万个任务所以要读入优化
{
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    int h=0;
    while(ch<='9'&&ch>='0')
    {
        h=h*10+ch-48;
        ch=getchar();
    }
    return h;
}
struct task{
    int be;
    int fi;
}a[10010];//结构体存各个任务的信息
int my(const task&a,const task&b)//开始时间晚的排前面 
{
    if(a.be>b.be) return 1;
    if(a.be<b.be) return 0;
    if(a.fi<b.fi) return 1;//开始时间一样则结束早排前面 
    return 0;
}
int f[10001];//f[i][j]表示从第i分钟到第n分钟尼克最少的工作时间 
int main()
{
    n=read();
    k=read();
    for(int i=1;i<=k;i++)
    {
        int x,y;
        x=read();
        y=read();
        a[i].be=x-1;
        a[i].fi=x+y-1;//记录各任务的开始结束时间（这里有点特殊，不过你模拟一下就明白了（时间点和时间段的差异）） 
    }
    a[k+1].be=1000000;//防止在i=0时陷入死循环
    sort(a+1,a+k+1,my);//排序函数
    int tt=1;//指向任务 
    for(int i=n-1;i>=0;i--)//枚举开始时间 
    {
        if(a[tt].be==i)
        {
            int mini=10000000;
            while(a[tt].be==i)//枚举到开始时间等于i时，一直把开始时间等于i的任务枚举完，这样才能找到最小值
            {
                mini=min1(mini,a[tt].fi-a[tt].be+f[a[tt].fi]);//遇到了一个任务，那么必须选 
                tt++;
            }
            f[i]=mini; 
        }
        else f[i]=f[i+1];//没有任务就延续之前的值
    } 
    cout<<n-f[0];//注意输出的是闲暇时间，不是工作时间
    return 0;
}
```
那么这道题就解决了，其实还是很容易的吧，
所以——>千万不要看题解写dp

这样真的没有提高，状态转移方程一定要自己想


希望这篇题解在你绞尽脑汁也想不出这道题的时候对你有帮助（/认真脸/）！


---

## 作者：翠竹叶飞 (赞：1)

这道题我用的是像dp的一种方法，很诡异，然而可以A

1.若此时无任务，则f[i]=max(f[i],f[i-1]+1)

2.否则，从此前的1个状态起，往后推导即可。

f[i+b[p]-1]=max(f[i+b[p]-1],f[i-1]);

时间复杂度O(n)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define INF -0x7f7f7f7f
using namespace std;
int i,j,n,m=0,p;
int a[10001],b[10001],f[10001];
int main()
{
    memset(f,INF,sizeof(f)); f[0]=0;
    scanf("%d%d",&m,&n);
    for (i=1; i<=n; i++) scanf("%d%d",&a[i],&b[i]);
    for (i=1; i<=m; i++)
    {
        if (a[p+1]!=i) f[i]=max(f[i],f[i-1]+1);
        while (p<n && a[p+1]==i)
        {
            p++;
            f[i+b[p]-1]=max(f[i+b[p]-1],f[i-1]);
        }
    }
    printf("%d",f[m]);
    return 0;
}
```

---

## 作者：Radium_ (赞：1)

dp【i】表示从i开始的最大空闲时间，逆序推dp，


**分情况： **

1：如果改时间没有工作需要开始，那么当然是要休息的，表示现在休息一分钟，dp【i】=dp【i+1】+1


2：如果有需要开始的，那么在所有需要开始的工作中选一个最优的（废话），dp【他们的末尾时间+1】最大的，来表示他们工作完之后最多能休息多长时间（注意恰好工作完的那一分钟，即工作的最后一分钟，不算休息）这就是+1的原因 ，为什么？我们可以设想：对于每个任务，如果我做这个任务，那能得到的最大空暇时间是多少？就是工作完之后的最大空余时间啊


不过，之所以要逆向推，你想啊。正向推的话，前面的选择会对后面的造成影响，并且我们没有办法来记录。


为什么要逆序DP呢？因为不难发现，选择是在任务的开始，不是任务的结束，要在同一起始点转移状态，必将从后往前，所以就有了本方法。


详见这里

[http://www.cnblogs.com/radiumlrb/p/5792085.html](http://www.cnblogs.com/radiumlrb/p/5792085.html)



```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#define inf 0x3f3f3f3f
using namespace std;
int begin[100005],end[100005],f[100005],N,K;
int main(){
//    freopen("01.txt","r",stdin);
    scanf("%d%d",&N,&K);
    for(int i=1;i<=K;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        begin[i]=a;end[i]=b;
    }
    int point=K;
    for(int i=N;i>=1;i--){
        if(begin[point]!=i) f[i]=f[i+1]+1;
        else{
            while(i==begin[point]){
                f[i]=max(f[i],f[i+end[point]]);
                point--;
            }
        }
    }
    printf("%d\n",f[1]);
    return 0;
}
```

---

## 作者：Kal_El (赞：1)

最大空闲时间==最小消耗时间。

f[i]表示以第i个任务结尾的工作序列的最小消耗时间

把任务排序(开始时间)，使无其他任务的时刻必须做一个。



```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int f[10010];
int n,k;
int b[10010],e[10010];
int main()
{
   [/color][codec ] scanf("%d %d",&n,&k);[/codec ]
    [/color][codec ]for(int i=1;i<=k;i++)[/codec ]
       [/color][codec ]scanf("%d %d",&b[i],&e[i]);[/codec ]
      [/color][codec ] f[n+1]=0;[/codec ]
   [/color][codec ] int j=k,busy;[/codec ]
   [/color][codec ] for(int i=n;i>=1;i--)[/codec ]
    {
        [/color][codec ]f[i]=0;busy=0;[/codec ]
    [/color][codec ]    while(b[j]==i)[/codec ]
        {
   [/color][codec ]         f[i]=max(f[i],f[i+e[j]]);[/codec ]
   [/color][codec ]         busy=1;j--;[/codec ]
        }
   [/color][codec ]     if(!busy) f[i]=f[i+1]+1;[/codec ]
   }
   [/color][codec ] printf("%d\n",f[1]);[/codec ]
    return 0;
}
```

---

## 作者：plazum (赞：1)

因为输入数据已经按开始时间排好序了，所以可以方便地用一个指针从后往前遍历……

```cpp

#include<stdio.h>
int n,i,j,k,a[10000][2],f[10002],p;
int main()
{
    for(scanf("%d%d",&n,&k);i<k;i++)scanf("%d%d",a[i],a[i]+1);
    for(i=n,p=k-1;i;i--){
        if(*a[p]!=i){f[i]=f[i+1]+1;continue;}
        for(;*a[p]==i;p--)
            if(f[i+a[p][1]]>f[i])
                f[i]=f[i+a[p][1]];
    }
    printf("%d",f[1]);
    
    return 0;
}

```

---

## 作者：永忻 (赞：1)

```cpp
#include <iostream>  
#include <cstdlib>  
#include <cstdio>  
#include<algorithm>  
using namespace std;  
int n,k,a[10001][3],f[10001];  
int main()  
{  
    cin>>n>>k;  
    for(int i=1;i<=k;i++)cin>>a[i][1]>>a[i][2];  
    for(int i=n;i>=1;i--)  
    { int po=0;                       //}从后往前，判断在该时刻有没有任务。  
      for(int j=1;j<=k;j++)              
      {  
         if(a[j][1]==i) //f[i] 如果在i时刻开始工作（此时空闲）的最大空闲时间。  
         {po=1;  
            f[i]=max(f[i],f[i+a[j][2]]);}  
      }  
      if(!po)f[i]=f[i+1]+1; //该i时刻没有任何一个任务 空闲时间多一点  
    }  
    cout<<f[1]<<endl;///cout  
    return 0;  
}  
```

---

## 作者：Johndoe (赞：0)

本蒟蒻根本没有想出dp的方法orz，只能蠢蠢的写一个dijkstra水过去
如果考虑到图的话题目就很简单，不过需要注意的是算第1个点到第i个点的路径的长度时这个路径不能够到达i，应当恰好到达i-1（否则就不能从点i出发）。
```
#include<iostream>
#include<stdlib.h>
using namespace std;
#define MAXN 10010
//dijkstra
int num=0;//点个数 
struct range{
	int x;
	int y;
}a[MAXN];//一个x到y的区间
int dis[MAXN];//到第i个点的最小距离 
int point[MAXN]={0};//第i个点在输入区间的位置
int point_p[MAXN]={0}; 
void dijkstra(){
	int k=0;dis[0]=0;
	for (int i=0;i<=num;++i){
		k=i;
		for (int j=point[i];j<point[i+1];++j){
			for (;point_p[k]<=a[j].y;++k);
			dis[k]=min(dis[k],dis[i]+a[j].y-a[j].x+1);//提前把x值相同的a[i]按y排序，减少计算次数。
			}
		}
	}
int compare(const void *s,const void *t){
	if (((range*)s)->x==((range*)t)->x)return ((range*)s)->y-((range*)t)->y;
	else return ((range*)s)->x-((range*)t)->x;
}//用快排偷懒
int main(){
	int n,k;
	cin>>n>>k;
	for (int i=0;i<k;++i)cin>>a[i].x>>a[i].y,a[i].y=a[i].x+a[i].y-1;//把输入转化成区间
	qsort(a,k,sizeof(range),compare);
	point[0]=0,point_p[0]=a[0].x;
	for (int i=1;i<k;++i){
		if (a[i].x!=a[i-1].x)point[++num]=i,point_p[num]=a[i].x;//记住第i个点的x值和在任务中第一次出现的位置
	}
	point[num+1]=k,point_p[num+1]=n+1;
	for (int i=0;i<=num+1;++i)dis[i]=MAXN;
	dijkstra();
	cout<<n-dis[num+1];
	
} 
```

---

## 作者：Mother_Dry (赞：0)

为什么总是有人说要逆推。。。正推也行啊

f[i]记在时间轴截止到i的位置（第i分钟末）最长的休息时间

显然，在没有工作的时候，f[i+1]=f[i]+1

然后讨论工作时的情况

先把工作时间按开始时间排序

**这里有一点要注意，从第1分钟开始工作2分钟，即是从1min初~2min末 就是 0min~2min**

所以我们输入时，要把开始时间-1

结束时间即为  开始时间-1+t

当遇到须工作的时候，就相当于 t0~t末 没有任何休息

就把f[t末]=max{f[t末],f[t0]}

然后推到f[n]即第n min 末即可输出答案

**但当我们必须工作的时候，我们是不可能存在该时间点上的休息时间的(因为我们在工作)，所以我把f[0]以后初始化为-INF，当然这个也可以优化（懒）**

贴代码

```cpp
#include<bits/stdc++.h>
#define MAXN 10010
#define INF 0x66ccff
using namespace std;
int f[MAXN],n,k;
struct task//s开始时间,e结束时间
{
    int s,e;
}x[MAXN];
int cmp(const void *a,const void *b)
{
    return (*(task*)a).s-(*(task*)b).s;
}
int main()
{
    
    cin>>n>>k;
    int t;
    for(int i=1;i<=n+2;i++)f[i]=-INF;
    for(int i=0;i<k;i++)//输入开始时间持续时间并转换为结束时间
    {
        cin>>x[i].s>>t;
        x[i].s--;
        x[i].e=x[i].s+t;
    }
    qsort(x,k,sizeof(struct task),cmp);//排序
//    for(int i=0;i<k;i++)cout << x[i].s<<'~'<<x[i].e<<endl;
    
    for(int i=0,p=0;i<=n;i++) 
    {
        
//        printf("f[%d]:%d~%d分钟最多休息%d\n",i,i,i+1,f[i]);
//        int flag=0;
        if(i==x[p].s)//遍历当前时刻的工作
        {
//            int min=n;
            while (i==x[p].s)
            {
//                if(x[p].e<min)min=x[p].e;
                f[x[p].e]=f[x[p].e]>f[i]?f[x[p].e]:f[i];
                p++;
            }
//            i=x[p].e-1;
            continue;//因为我们可做工作是必做工作，所以进行f[i+1]=f[i]+1的处理
        }
        f[i+1]=f[i+1]>(f[i]+1)?f[i+1]:f[i]+1;//处理非工作状态
//        printf("第%d分钟最多休息%d\n",i,f[i]);
    }
    cout << f[n];
}
```
当然其中的测试语句也可以拉出来用用


---

## 作者：FFF团 (赞：0)

选择的解法是记忆化搜索

刚开始看到此题时，画了下时间轴后发现似乎非常容易搜索但考虑到一般不能裸搜，

于是想办法优化后来发现有的状态多次访问于是进行记忆化。

记忆化是个常见的优化。

有很多DP的状态转移方程比较抽象而记忆化搜索却避免了此类问题。

注意搜索时要选择最近的任务，跳着寻找是个严重的错误，这个错误会样例都过不了，但除了这个之外没有什么特别要注意的了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct task{int l,r;}A[10005];            //定义任务为结构体l,r为占用时间的全闭区间 
int f[10005],n,k;                        //f[i]保存的是从开始第i个任务到结束最小花费时间 
bool cmp(task a,task b){return a.l<b.l;}//排序时按照开始时间从小到大排序 
int search(int cur){
    if(f[cur])return f[cur];            //若该状态已保存直接返回值 
    int res=0x7fffffff,limit=0x7fffffff;//初始化 
    for(int i=cur+1;i<=k;i++)            //向后寻找任务 
    if(A[i].l>limit)break;                //若此任务并非最近的直接break 
    else if(A[i].l>A[cur].r)             //寻找答案并更新最近任务开始时间 
    res=min(res,search(i)),limit=min(limit,A[i].l);
    f[cur]=A[cur].r-A[cur].l+1;            //更新f[cur]数值进行记忆化 
    if(res!=0x7fffffff)return f[cur]+=res;
    else return f[cur];
}
int main(){
    scanf("%d%d",&n,&k);
    A[0].l=1,A[0].r=0;                    //初始化设置虚拟点为开始状态 
    for(int i=1;i<=k;i++)
    scanf("%d%d",&A[i].l,&A[i].r),A[i].r+=A[i].l-1; 
    sort(A+1,A+k+1,cmp);
    search(0);                            //开始搜索 
    printf("%d",n-f[0]);
    return 0;
}
```

---

## 作者：Undefined_Myth (赞：0)

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define INF 10000+5
inline void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
struct Edge{
    int p;
    int t;
}edge[INF+1];
bool cmp(Edge a,Edge b)
{
    return a.p > b.p;//按开始时间从大到小排序——方便你推和状态转移 
}
int max(int a,int b)
{
    return a>b?a:b; 
}
int dp[INF+1];//dp[k]为在k~n时间内最大的空暇时间为了之后的状态转移而量身订造 
int sum[INF+1];//在时间点i的任务数量 
int n,k;//工作时间和任务总数 
int main() 
{
    read(n);    read(k);
    for(int i=1;i<=k;i++){//每个任务 
        read(edge[i].p),read(edge[i].t);
        sum[edge[i].p]++;
    }
    sort(edge+1,edge+k+1,cmp);
    for(int time=n,now=1;time>=1;time--)
        if(!sum[time])//时间点time没有任务
            dp[time]=dp[time+1]+1;
        else
            for(int i=1;i<=sum[time];i++,now++)//sum是用来计数，now是转移 
        //因为now根据每次转移都往后对应每一个时间点的所有物品所以用now代表物品合法 
                dp[time]=max(dp[time],dp[time+edge[now].t]);
    //注意在p+t-1分钟时结束，但是是一直持续到了p+t的开始
    //而根据我们的dp[]方程定义，那么里面应该是开始的时间 
    write(dp[1]);
        return 0; 
}
```

---

## 作者：理想气体 (赞：0)

十分，十分弱的我想到了一奇葩的方法。。

首先预处理找出每一件工作之前开始时间不一样的第一件工作，然后据此预处理找出所有可能在各件工作之前做的第一件工作。

然后据此dp

状态转移方程为f[i] = min(f[i] , f[j] + t[j])

i为当前工作序号，j为之前可能的那件工作的序号，t为工作时间。

据此可求得工作时间最小值，用总时间减去它就是空闲时间最大值了。

虽然这种方法很慢，很慢，很慢（最后一点520ms），但毕竟还是可AC的。

代码如下，写得真的很不美观，能不看就不看吧= =





```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>
const int INF = 100000;
using namespace std;
int befb[10002] , dp[10002];
vector<int> workc[10002];
struct work
{
    int bg , t;
    bool operator <(const work& wo)const
    {
        return bg < wo.bg;
    }
}works[10002];
int main()
{
    for(int i = 0 ; i <= 10001 ; i++)
        dp[i] = INF;
    int n , T;
    cin>>T>>n;
    for(int i = 1 ; i <= n ; i++)
    {
        cin>>works[i].bg>>works[i].t;
    }
    sort(works+1 , works+n+1);
    works[0].bg = 0;works[0].t = 0;
    for(int i = 1 ; i <= n ; i++)
    {
        if(i > 1 && works[i].bg != works[i-1].bg)
            befb[i] = works[i-1].bg;
        else
            befb[i] = befb[i-1];
    }
    for(int i = n ; i > 1 ; i--)
    {
        for(int j = i-1 ; j >= 1 ; j--)
            if(works[j].bg + works[j].t <= works[i].bg && works[j].bg + works[j].t > befb[i])
                workc[i].push_back(j);
    }
    for(int i = 1 ; works[i].bg == works[1].bg ; i++)
        dp[i] = 0;
    for(int i = 1 ; i <= n ; i++)
    {
        if(workc[i].empty())
            continue;
        for(vector<int>::iterator ite = workc[i].begin() ; ite != workc[i].end() ; ite++)
        {
            dp[i] = min(dp[i] , dp[*ite] + works[*ite].t);
        }
    }
    int ans = INF;
    for(int i = 1 ; i <= n ; i++)
    {
        if(works[i].bg + works[i].t > works[n].bg )
            ans = min(ans , dp[i] + works[i].t);
    }
    cout<<T-ans;
    return 0;
}
```

---

## 作者：litble (赞：0)

时间就是状态。

我们从后往前枚举每一个时间，f表示从某个时间到结束时间的最短工作时间，就会发现：

如果i时刻没有任务，f[i]=f[i+1]。

如果i时刻有任务，，则必须选择一个任务，枚举所有该时刻开始的所有任务，对于选择的每一个任务，需要工作的时间是在该任务结束后需要工作的时间和进行该任务需要的时间，f[i]=min(f[end[k]]+f[time[k]]),k表示i时刻开始的每一个任务。

然后，就是这样了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#include<iomanip>
#include<vector>
#include<queue>
using namespace std;
int n,m,sum=0;
struct nod{
    int lon;int next;
    }rw[10005];
int h[10005],f[10005];
void add(int x,int y){//保存以每一个时刻为开始的任务
    int i;
    sum++;rw[sum].lon=y;
    rw[sum].next=h[x];
    h[x]=sum;
}
int main()
{
    int i,j,x,y,kl;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(i=n;i>=1;i--){
        if(h[i]==0){f[i]=f[i+1];continue;}//假如这一时刻没有任务
        kl=n+1;
        for(j=h[i];j!=0;j=rw[j].next){//假如有任务
            kl=min(kl,f[rw[j].lon+i]+rw[j].lon);
        }
        f[i]=kl;
    }
    printf("%d",n-f[1]);
    return 0;
}
```

---

## 作者：0x7f7f7f7f (赞：0)

应该没人想到我这么奇葩的方法吧。。。

我用的是记忆化搜索，但是存数据的方法比较奇葩，是用链式前向星记录某个在有工作开始的时间点做了从它开始的工作后可到达的时间点（不能超过N+1），如果某个时间点没有工作开始，就用一个数组记录它的下一个有工作开始的时间点。搜索的时候如果当前时间点有工作开始就枚举每项工作并跳到该工作结束的时间点；如果没有就跳到下一个有工作开始的时间点，空闲时间+=跳过的时长。边界条件是当前时间==N+1。









```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
struct l
{
    int to,next;
}lian[10010];
int shi,geshu,zhizhen=0,head[10010],xyg[10010],jiyi[10010];
int max(int a,int b)
{
    if(a>b)return a;
    else return b;
}
int min(int a,int b)
{
    if(a<b)return a;
    else return b;
}
void lsqxx(int from,int to)
{
    zhizhen++;
    lian[zhizhen].to=to;
    lian[zhizhen].next=head[from];
    head[from]=zhizhen;
}
int search(int sj,int shu)
{
    if(sj==shi+1)return shu;
    if(jiyi[sj]!=0)
    {
        if(jiyi[sj]==-1)return shu;
        else return jiyi[sj]+shu;
    }
    int n,lj;
    if(head[sj]!=0)
    {
        for(n=head[sj];n!=0;n=lian[n].next)
        {
            lj=lian[n].to;
            jiyi[sj]=max(jiyi[sj],search(lj,shu)-shu);
        }
    }
    else jiyi[sj]=max(jiyi[sj],search(xyg[sj],shu+xyg[sj]-sj)-shu);
    if(jiyi[sj]==0)
    {
        jiyi[sj]=-1;
        return shu;
    }
    else return jiyi[sj]+shu;
}
int main()
{
    int n,a,b,daan;
    scanf("%d%d",&shi,&geshu);
    for(n=1;n<=geshu;n++)
    {
        scanf("%d%d",&a,&b);
        lsqxx(a,min(a+b,shi+1));
    }
    a=shi+1;
    for(n=shi;n>=1;n--)
    {
        if(head[n]!=0)a=n;
        else xyg[n]=a;
    }
    daan=search(1,0);
    printf("%d",daan);
    return 0;
}
```

---

## 作者：wjzcom (赞：0)

我用了一种挺奇葩的方法，竟然ac了

1.按照开始时间优先对所有点进行排序

2.预处理每个起始时间的上个起始时间（要求严格小于） ：last[]

3.挨个搜索所有的店，对于每一个点进行循环，范围为他的起始时间到他的上一个起始时间，这期间如果遇到了某个点的结束时间，进行状态转移

4.状态转移方程：f[m[i].r] = min(f[m[i].r], f[j] + m[i].t);   j为讨论到的终止时间

5.最后从后往前扫f数组，扫到m[k].l（即最后一个点的起始时间），求出最小值，用n一减

有些代码细节没说，看代码吧

```cpp
//luogu 1280 wjz2
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN = 10000 + 10;
const int INF = 0x3f3f3f3f;
int n, k;
struct node
{
    int l, t, r;
} m[MAXN];
bool cmp(node a, node b)
{
    if(a.l != b.l) return a.l < b.l;
    else return a.r <= b.r;
}
int f[MAXN], v[MAXN], last[MAXN], vis[MAXN];
inline void init()
{
    for(int i = 1; i <= k; i++)
        for(int j = i-1; j >= 0; j--)
            if(m[j].l != m[i].l) {last[m[i].l] = m[j].l; break;}
    for(int i = 1; i <= n; i++)
        f[i] = INF;
    sort(m+1, m+k+1, cmp); 
    vis[0] = 1;
}
int main()
{
    cin >> n >> k;
    for(int i = 1; i <= k; i++)
    {
        cin >> m[i].l >> m[i].t;
        m[i].r = m[i].l + m[i].t - 1;
    }
    init();
    for(int i = 1; i <= k; i++)
    {
        int u = m[i].l, v = m[i].r;
        for(int j = u-1; j >= last[u]; j--)
            if(vis[j]) f[v] = min(f[v], f[j]+m[i].t);
        vis[v] = 1;
    }
//    for(int i = 1; i <= n; i++)
//        cout << f[i] << endl;
    int ans = INF;
    for(int i = n; i >= m[k].l; i--)
        if(vis[i]) ans = min(ans, f[i]);
    cout << n - ans;
    return 0;
}
```

加油！


---


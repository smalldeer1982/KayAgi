# [GCJ 2021 #1C] Closest Pick

## 题目描述

你正在参加一场抽奖活动，奖品是终身免费煎饼。已有 $\textbf{N}$ 张彩票售出。每张彩票包含一个 $1$ 到 $\textbf{K}$ 之间的整数（含端点）。不同的彩票可以包含相同的整数。你确切知道所有已售出彩票上的数字，并希望通过购买两张彩票（可以包含相同的整数）来最大化中奖概率。你可以自由选择 $1$ 到 $\textbf{K}$ 之间的任意整数作为这两张彩票的数字。

![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)

你知道自己是最后一位顾客，因此在你购买彩票后，不会再有任何彩票售出。接着，系统会均匀随机选择一个 $1$ 到 $\textbf{K}$ 之间的整数 $c$（含端点）。如果满足以下条件之一，你将赢得抽奖：
- 你的一张彩票到 $c$ 的距离严格小于其他所有彩票；
- 你的两张彩票到 $c$ 的距离相同，且严格小于其他所有彩票。

否则，你将不会赢得抽奖。

给定已售出的 $\textbf{N}$ 张彩票上的整数，通过最优选择你的两张彩票上的整数，你能够达到的最大中奖概率是多少？

## 说明/提示

**样例解释**

在样例 #1 中，你可以购买数字为 $4$ 和 $8$ 的彩票。当 $c$ 为 $4$、$5$、$8$、$9$ 或 $10$ 时，你将赢得抽奖，中奖概率为 $\frac{5}{10} = 0.5$。购买数字为 $6$ 和 $8$ 的彩票也能达到 $0.5$ 的中奖概率，但没有其他组合能超过这一概率。

在样例 #2 中，$6$ 和 $8$ 是一个可能的最优组合，当 $c$ 为 $6$、$8$、$9$ 或 $10$ 时，你将赢得抽奖。注意，已售出彩票上的数字不一定按升序排列。

在样例 #3 中，所有可能的 $c$ 都与至少一张已售出的彩票距离为 $0$，因此无论你如何选择彩票，都无法赢得抽奖。

在样例 #4 中，如果你至少选择一张数字为 $3$ 的彩票，你将在 $c = 3$ 时赢得抽奖，中奖概率为 $\frac{1}{4} = 0.25$。对于其他整数 $c$，你无法获胜，因此这是你能达到的最佳概率。

**数据范围**

- $1 \leq \textbf{T} \leq 100$。
- $1 \leq \textbf{N} \leq 30$。
- 对于所有 $i$，$1 \leq \textbf{P}_i \leq \textbf{K}$。

**测试集 1（9 分，可见判定）**

- $1 \leq \textbf{K} \leq 30$。

**测试集 2（16 分，可见判定）**

- $1 \leq \textbf{K} \leq 10^9$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
3 10
1 3 7
4 10
4 1 7 3
4 3
1 2 3 2
4 4
1 2 4 2```

### 输出

```
Case #1: 0.5
Case #2: 0.4
Case #3: 0.0
Case #4: 0.25```

# 题解

## 作者：Doraeman (赞：2)

啦啦啦，考完试来写一篇题解，耶。
## 简化题意
已知 $N$ 个数 $a_{1\sim n}$，求一组（$2$ 个数）$\{d_1,d_2\}$，使得对于任意的正整数 $c\isin[1,K]$，满足 $|d_i-c|<|a_j-c|$（以下简称为 $c$ 符合 A 条件）的 $c$ 最多（$i\isin\{1,2\},j\isin[1,N]$）。
## 思路
~~通过查看算法标签得知~~，**这道题要用到贪心**。
### 复杂问题简单化
如果单调不降序列 $a$ 中只有两个值 $a_i,a_{i+1}$，不难发现**当且仅当选择 $d$ 满足 $d\isin(a_i,a_{i+1})$ 这个条件**（设 $(a_i,a_{i+1})$ 这个区间为 $S_i$，$S_i$ 的长度 $len_i=a_{i+1}-a_i-1$）**时，存在 $c$ 满足 A 条件**。

进一步分析：满足 $c\isin S_i$ 时，多少个 $c$ 满足 A 条件？  
可以制造一组数据进行分析。
```cpp
1 8
```
尝试取 $d=2$。根据题意，此时满足 A 条件的 $c$ 有 $3$ 个，即 $c=\{2,3,4\}$。  
再尝试取 $d=3$。根据题意，此时满足 A 条件的 $c$ 有 $3$ 个，即 $c=\{3,4,5\}$。  
再制造其他数据进行分析。

经多次尝试，可以总结出这条规律：**只要 $d\isin S_i$，无论 $d$ 为何值，满足 A 条件的 $c$ 个数都为 $\lceil\frac{len_i}{2}\rceil$。**
### 规律一般化
对于单调不降序列 $a$ 中的**每一对** $S_i$，满足 A 条件的 $c\isin S_i$ 的数量**都是** $\lceil\frac{len_i}{2}\rceil$。
### 代码思路
有了以上一般化的规律之后，代码思路一目了然。先求出所有 $len_i$，之后计算 $\lceil\frac{len_i}{2}\rceil$ 并取最大的两个作为答案（以下简称这个答案为 a 答案）。
## 细节
### 规律纠错
拿 $S_0$ 举例，只要满足 $d=a_1-1$，那么 $a_1$ 左边的所有 $c\isin [1,a_1)$ 都符合 A 条件。即此时 a 答案并非等于 $\lceil\frac{len_0}{2}\rceil$，而是 $len_0$。  
这个细节可以在代码中特殊判断。
### 特殊情况分析
如果到这里就结束了，那么恭喜你做错了（~~亲测真实~~）。

现在我们还要考虑，如果**其中某一个 $S_i$ 长度非常长**，那么可以让两个彩票数字 $d_1,d_2$ 满足 $d_1=a_i+1,d_2=a_{i+1}-1$。这样一来，所有的 $c\isin S_i$ 就都会满足 A 条件了。即此时满足 A 条件的 $c$ 为 $len_i$ 个。

由于最多使用 $2$ 张彩票，所以这种情况下答案就是所有 $len_i$ 的最大值（以下简称这个答案为 b 答案）。

最后，比较 a 答案和 b 答案，取较大值，除以 $K$ 得到概率。
### 题意重新分析
细心地小伙伴已经发现了：“两张彩票到 $c$ 的距离相同，且严格小于其他所有彩票。”（以下简称为 B 条件）时，$c$ 也可以满足 A 条件，但我们却没有计算。

之所以不考虑这种情况，是因为可以观察发现：B 条件不仅要求彩票即 $d$ 到 $c$ 的距离严格小于其他所有彩票，还要求 $|d_1-c|=|d_2-c|$，B 条件比 A 条件更加严格。

然而，我们计算的是所有满足 A 条件或满足 B 条件的 $c$ 的数量，但满足 B 条件时必然满足 A 条件，即答案已经在 A 条件的情况下被计算过，无需再次计算。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 35;

int n, k, a[N], s[N];

int main(){
    int T; cin >> T;
    for(int _=1; _<=T; _++){ // Case:#_ 
        cin >> n >> k;
        for(int i=1; i<=n; i++)
            cin >> a[i];
        sort(a + 1, a + n + 1); // 将a序列变成单调不降序列  

		// 核心部分 
        int f2 = 0; // b答案 
        for(int i=2; i<=n; i++){
            int len = a[i] - a[i-1] - 1; // 计算len 
            f2 = max(f2, len); // b答案取len的最大值 
            int w = ceil(len / 2.0); // 计算a答案  
            s[i] = max(w, 0); // 防止出现负数（即a_i=a_{i+1}） 
        }
        s[1] = a[1] - 1, s[n+1] = k - a[n]; // 特殊处理 
        sort(s + 1, s + n + 2, greater<int>());

        int f1 = s[1] + s[2];
        // 取较大值；保留8位比较保险  
        printf("Case #%d: %.8lf\n",_,max(f1,f2)/1.0/k);
    }
}
```

---


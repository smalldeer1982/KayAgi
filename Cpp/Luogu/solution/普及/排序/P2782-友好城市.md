# 友好城市

## 题目描述

有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。


## 说明/提示

### 数据规模与约定

- 对于 $50\%$ 的数据，$1 \leq N \leq 5000$，$0 \leq x _ i \leq 10000$。
- 对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10 ^ 5$，$0 \leq x _ i \leq 10 ^ 6$。


## 样例 #1

### 输入

```
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2```

### 输出

```
4```

# 题解

## 作者：AC机 (赞：114)

这题一看上去，没有思路，觉得很难，其实我们可以通过画图，或者举例子，发现只要对北岸或者南岸排个序，在看另一边的最长不下降子序列就可以了。因为如果另一边的是不下降的说明他们的航线没有交叉。

而这题用n*n会超时（估计），所以介绍一个O(nlog(n))的方法。

就是用另开一个数组去存放他不下降的元素。而查找不下降元素时，我们使用STL库中的upper_bound（lower_bound在这题中和upper_bound的效果是一样的)这个函数是二分查找所以效率很高是O(log(n))。

我看了一下其他大佬的题解，发现他们在用upper_bound的时候把upper_bound放在了else的分支了。其实我们完全可以不用判断，全部使用upper_bound，因为upper_bound就是找到第一个>的位置，所以并不需要判断。(在这里提一下，lower_bound是找>=因此题并没有相等的情况，所以upper_bound和lower_bound都一样，但是在求最长不下降子序列的时候，请使用upper_bound)

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
struct node
{
    int north;
    int south;//先定义一个结构体，里面包含了north（北岸城市）和south（南岸城市）
};
node a[200005];
int n,i,d[200005],len,temp;
bool cmp(node x,node y)
{
    return x.north<y.north;//我们只需要对北岸排序求南岸的最长不下降子序列即可（可以反过来，对南岸排序求北岸的最长不下降子序列）
}
int main ()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i].north);
        scanf("%d",&a[i].south);
    }
    sort(a+1,a+1+n,cmp);//sort结构体排序大法吼啊！
    d[++len]=a[1].south;//因为最短的不下降子序列是每个数本身，所以，我们将第一个元素放进最长不下降子序列中。
    for(i=2;i<=n;i++)
    {
        int dbzjrQwQ=upper_bound(d+1,d+len+1,a[i].south)-d;
        d[dbzjrQwQ]=a[i].south;
        if(dbzjrQwQ>len)
        {
            len++;
        }
    }
    printf("%d",len);
    return 0;
}
```

---

## 作者：1379号监听员 (赞：112)

# 题解
## 条件分析
首先，我们分析一下航道不交叉的条件。

 如果有一条已经被批准的航道，南北坐标为N1,S1;
 
 则第二条N2<N1,S2>S1（或恰好相反）的航道将不能被批准，因为他们发生了交叉。

------------
参照此图：
```
.N   .N
 \   |
  \  |
   \ | 
    \|
     |
     |\
     | \
     .S .S
```


------------
因此，要满足题目中的条件，需要保证南岸序列和北岸序列**单调上升**（题目中交代了坐标不会重合）。

我们可以按北岸坐标大小对城市进行排序，来保证北岸序列单调上升；

然后，南岸序列的**最长上升子序列**长度就是能够批准的航线条数。

##  最长上升子序列
如何求出最长上升子序列的长度？

不难看出，这个问题用动态规划解决会很简单，

边界为f(1)=1

状态转移方程为f(i)=max{f(i),f(j)+1|S(i)>s(j)} (i=1,i<=n) (j=i+1,j<=n)

然而 这题的数据规模。。。 n<=200000;

n方的动态规划肯定TLE，我们得想点别的办法。

假设有一个序列 100 389 207 99 300，从前往后扫描；

1. 扫描到100，将100加入序列
2. 扫描到389，将389加入序列尾部
3. 扫描到207，将207替换掉389（因为它更小，可以让更多数插进来）
4. 扫描到99，将99替换掉100（这不会使结果变差）
5. 扫描到300，加入序列尾部（可以看出，如果不执行第三步的替换，这里会漏过最优解）

因此，我们的策略是：如果当前数比序列尾更大，直接将其插入尾部，序列长度+1；

否则用它替换掉序列中比它大但又最小的一个（保持单调性）。

对于情况一，可在常数时间内完成；

对于情况二，STL中有现成的函数——lower_bound（这题upper_bound也可以），他的时间复杂度是logn，效率很高（其实就是二分查找）。


------------

贴代码：
```cpp

#include<iostream>
#include<algorithm>
using namespace std;
struct city{
//方便排序
    int north;//北岸
    int south;//南岸
};
struct cmp{
    bool operator () (city& a,city& b)
    {
        return a.north<b.north;
    }
};
city c[200005];
int lis[200005];//LIS序列
int ans=0;//LIS长度
int n;
int main()
{
    ios::sync_with_stdio(false);//流式I/O加速
    cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>c[i].north>>c[i].south;
    }
    sort(c+1,c+n+1,cmp());//将城市按北岸排序，之后就没北岸什么事了
    for(int i=1;i<=n;i++)
    {
        if(c[i].south>lis[ans])//如果能插入
        {
            lis[++ans]=c[i].south;//插入至末尾
        }
        else
        {
        //否则二分查找出序列中比它大但又最小的一个并替换
            *lower_bound(lis+1,lis+ans+1,c[i].south)= (c[i].south);
        }
    }
    cout<<ans<<endl;
    return 0;
 } 
```




------------


######    ————写小白也能看懂的题解！

---

## 作者：徐熙凯 (赞：24)

~~看大佬们都在认真地写题解，我一个**蒟蒻**~~~~~~~~~

看完大佬们的题解，你们应该知道了这是一个简（kun）单（nan）的动归（DP）题。但是，为什么我们这些蒟蒻在做题的时却看不出它的DP状态方程？

### **~~“模拟是动归之父”~~**

首先当你什么也看不出来的时候先要去逐一模拟，至少模拟三、四个数据，模拟多了，算法就渐渐浮出水面，同时方法在脑中也会呈现。


贴代码、分析

------------

```

long long adj(adv xx,adv yy)
{
	return xx.x<yy.x;
}
```
//
```

	sort(a+1,a+n+1,adj);//将一岸的城市从小到大排序，为做单调子序列先做足准备 
```


------------
 
```
	//做单调子序列
	h=1; q[h]=a[1].y;
	for(i=1;i<=n;++i)
	{
		if(a[i].y>q[h])
		{
			h++; q[h]=a[i].y;
		}
		else if(a[i].y<q[h])
			q[lower_bound(q+1,q+h+1,a[i].y)-q]=a[i].y;
	}
```


------------

# 贴上总代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct adv{
	long long x,y;
}a[210000];
long long q[210000];
long long adj(adv xx,adv yy)
{
	return xx.x<yy.x;
}
long long n,m,i,j,k,h;
int main()
{
	cin>>n;
	for(i=1;i<=n;++i) cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,adj);//将一岸的城市从小到大排序，为做单调子序列先做足准备 
	h=1; q[h]=a[1].y;
	for(i=1;i<=n;++i)
	{
		if(a[i].y>q[h])
		{
			h++; q[h]=a[i].y;
		}
		else if(a[i].y<q[h])
			q[lower_bound(q+1,q+h+1,a[i].y)-q]=a[i].y;
	}
	cout<<h;
	return 0;
}
```


------------


# 补充

[lower_bound和upper_bound的用法](https://www.cnblogs.com/Tang-tangt/p/9291018.html)

可以学学快读哦！ 附上模板
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
LL read()
{
	LL s=0;
	bool bj=0;
	char c=getchar();
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-')bj=1,c=getchar();
	while(c>='0'&&c<='9')s=s*10+c-'0',c=getchar();
	if(bj)return -s;
	return s;
}
int main()
{
	int i,j;
	return 0;
}

```


---

## 作者：Pbri (赞：7)

其实这个题总结一下规律，就可以发现，将北岸的城市排好序，求出南岸城市的最长不下降序列，就是最后的结果。那么这个题，如果用n^2的方法话，应该能过几个点，但是过不了全部的点，会tle。那么就考虑一下nlogn。nlogn的算法，突破点在于二分查找。那么思路是什么样的呢？
假定有一个序列：3 2 6 9 4 7 8

那么i=1时，只有3，加入序列，f[1]=3。

i=2，2肯定不能直接加入后面，但是如果用2把3给替换掉，很明显结果不会更差，那么用2把3替换掉。

i=3和4，6和9都可以直接加入后面。

i=5，把他替换掉6，虽然打眼一看不符合要求，可是这样替换不会导致更差的结果，还更有可能变好。

i=6，如果用7把9给替换掉，是否会更好呢？答案是肯定的，思路与i=5时一样。

i=7，8可以直接加入后面。这时候有没有发现，如果不去替换9，是不是结果就不是最优了。

最后，代码奉上：
```
#include <iostream>
#include <algorithm>
using namespace std;
int n,f[200000],ans,len;
struct st{
	int nor,sou;
}city[200000];
bool cmp(st x,st y)//结构体排序函数
{
	return x.nor<y.nor;
}
int main(){
	cin >> n;
	for(int i=1;i<=n;i++)
	{
		cin >>city[i].nor>> city[i].sou;
	}
	sort(city,city+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		int a=city[i].sou;
		//cout<<a<<":";
		len=upper_bound(f+1,f+len+1,a)-f;
		//printf("%d,%d\n",i,len);
		f[len]=a;
		ans=max(ans,len);
	}
	cout << ans;//去掉+1。。。
	return 0;
}
```
管理大大求过~~

---

## 作者：梦回还 (赞：7)

很明显数据被加强了~所以n方算法不管用了，这时候就要用到二分优化了（nlogn的效率完全OK）。

因为我们维护一个单调上升的队列，如果出现了比最大值更大的值，就将其加入数组。

否则我们就考虑二分（lower\_bound）出比队列中比这个值稍大的值替换它，因为这样做——结果不会变得更差（只可意会qwq）





```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 200005
using namespace std;
struct data{
    int x,y;
}a[N];
int n,dp[N],s[N],top;
bool cmp(data a,data b)
{
    return a.x<b.x;//思路相同，将南岸城市排序，对北岸城市跑一遍最长不下降子序列
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        if(a[i].y>=s[top]) s[++top]=a[i].y;//注意这个大于等于，虽然题目描述中提及“北岸城市有且仅有一个南岸城市与其对应”，
                                                        //但本人不知道为何，数据中一个点把我卡了三次，呜呜呜
            else s[lower_bound(s,s+top,a[i].y)-s]=a[i].y;//替换操作，注意使用lower_bound函数返回值是一个地址！
    }
    printf("%d",top);//最后队列内的元素数量就是答案
    return 0;
}
```

---

## 作者：cbio (赞：6)

鉴于为什么解法是求最长不下降子序列，其他题解已经论述比较透彻了，那么这里仅提供一个基本的$LIS$问题$O(n\times logn)$复杂度的思路(不是做法，而是如何想到）  
$O(n^2)$的时间复杂度显然不够优秀，那么我们该如何优化这种算法呢。  
在我们每处理数列中的一位时，我们都要遍历数组找到值小于当前数中的f值的最大值，再用其加一作为现数字的值。  
那么，如果我们维护一个取值集合，储存可能的最优解，
就可以优化算法的时间复杂度。  
将一个数放入取值集合的条件是什么？如果两个数a、b
，f值相同，但$a<b$,那么a对于后来的数来说，显然比b优。（运用了优先队列的思想）  
那么我们储存下对每一个f值来说的最小原数字值，在处理完新数字后将新数字与与其f值相同的数字比较大小，若小于则更新。  
我们又观察到，若设$f[i]$为f值为$i$的最小原数字值，则$f$数组显然是单调增的。  
因此可以用二分查找快速找到最大的小于当前数的、在取值集合中的数，当前数即为其f值+1。然后将其与大于其的、在取值集合中的
第一个数取$\min$，更新该位上的数。  
设置一个指针p（其实就是变量）指向f数组尾，若当前数
大于p指向的数，则`p++`，集合扩展。  
答案就是p的值。
下面附上AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct pt{
	int l,r;
}; 
pt a[(int)2e5+5];
int n,f[(int)2e5+5],p=0;//f[i]=长度为i的IS最小最后一个数 

bool cmp(pt x,pt y) {
	return x.l<y.l;
}

int main() {
	cin>>n;
	for(int i=1; i<=n; i++) scanf("%d%d", &a[i].l, &a[i].r);
	sort(a+1,a+1+n,cmp);	
	for(int i=1; i<=n; i++) {
		if(a[i].r > f[p]) p++,f[p]=a[i].r;
		else f[lower_bound(f+1,f+p+1,a[i].r)-f]=a[i].r;
	}
	cout<<p<<endl;
	return 0;
}
```

---

## 作者：盧鋅 (赞：5)

#### 这道题也算是个模板题吧（nlognLIS）
对于初学DP的还是比较重要，它诠释了LIS究竟怎末用。


------------
先说下这道题的做法吧
先以一岸为参照排下序，然后再以另一岸为参照做下LIS就好了。
其正确性易证，
点到为止。


------------
见一大佬题解引用《西江月》，我也分享下。

即得易见平凡，仿照上例显然。

留作习题答案略，读者自证不难。

反之亦然同理，推论自然成立。

略去过程QED，由上可知证毕。


------------
 作为一篇优秀的题解，绝不能这么迷迷糊糊的水了
 下面还是放一下我的代码吧
 ```cpp
#include<iostream>
#include<algorithm>//sort和lower_bound
#define __Q__ 0
#define __X__ 1
#define __A__ 200200
#define mian main//OIer日常的mian函数
#define int long long //分享一下快速改类型的方法
using namespace std;
struct __o__{
	int __,___;
}______[__A__];
int __;
bool ___________(__o__ _O_,__o__ _o_){
	return _O_.__<_o_.__;
}
signed mian(){
	ios::sync_with_stdio(false);//玄学加速，与据说与编译器的emmm成正版
	cin>>__;
	for(int _=__X__;_<=__;_++){
		cin>>______[_].__>>______[_].___; 
	}
	sort(______+__X__,______+__+__X__,___________);
	int ____[__A__],_____=__Q__;
	for(int _=__X__;_<=__;_++){
		if(!_____||____[_____]<______[_].___)____[++_____]=______[_].___;
		else *lower_bound(____,____+_____,______[_].___)=______[_].___; 
	}
	cout<<_____;
	return __Q__;
}
```


------------
# **滑稽保命，溜了**

---

## 作者：Rachel·Gardner (赞：3)

**题目描述**

有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。


**输入格式：**

第1行，一个整数N，表示城市数。

第2行到第n+1行，每行两个整数，中间用一个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

**输出格式：**

仅一行，输出一个整数，表示政府所能批准的最多申请数。


**输入样例**

7

22 4

2 6

10 3

15 12

9 8

17 17

4 2


**输出样例**

4

**说明**

50% 1<=N<=5000,0<=xi<=10000

100% 1<=N<=2e5,0<=xi<=1e6

**思路：**
乍一看题以为是几何题，然而LIS大法好！！！

只要对北岸或者南岸排个序，在看另一边的最长不下降子序列就可以了，因为如果另一边的是不下降的说明他们的航线没有交叉。


代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int N=5010;

int n,ans;
int w[N];

struct node {
    int sou;
    int nor;
} hx[N];

bool cmp(node a,node b) {
    return a.nor<b.nor;
}

int main () {
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
        scanf("%d%d",&hx[i].nor,&hx[i].sou);
    sort(hx+1,hx+1+n,cmp);
    w[++ans]=hx[1].sou;
    for(int i=2; i<=n; i++) {
        int ans1=lower_bound(w+1,w+ans+1,hx[i].sou)-w;
        w[ans1]=hx[i].sou;
        if(ans1>ans)
            ans++;
    }
    printf("%d",ans);
    return 0;
}

```


---

## 作者：维迭生 (赞：3)

首先我们要看出来这题是LIS。  
你想，在北岸排好序后，即有$a(i1).north < a(i2).north, i1 < i2 $，假如对$i1$与$i2$，它们南岸坐标$a(i1).south < a(i2).south$，就必有交叉，而所有城市的友好城市不相同，所有符合题意的建造方案是一个严格上升的子序列。  
那么对这题，就是要以$nlogn$的时间复杂度来求解LIS。  
我用的是**树状数组**。

我们以tree的下标表示南岸的横坐标，以$tree[i]$表示横坐标不超过i的最长上升子序列长度。  
**核心代码：**
```cpp
	for(int i = 1 ; i <= n; ++i){
		int x = ask(a[i].s) + 1;	//不超过南岸坐标的最大LIS
		ans = max (ans, x);			//试图更新答案
		add(a[i].s + 1, x);			//维护树状数组
	}
```

剩下的添点、询问最长就和普通树状数组差不多了，只是把　**+=**　换成 **max()**罢了。

你们想要的**完整代码**：
```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int MAXN = 2e5 + 5;
const int MAXX = 1e6;
int n, maxx;
struct line{
	int n,s;
}l[MAXN];

bool cmp(line a, line b){
	return a.n < b.n;
}

int tree[MAXX], ans;		
inline int max(int a,int b){//对经常使用的、短小精悍的函数前加上inline

	return a>b ? a : b;
}

inline int lowbit(int k){	//使函数调用更快
	return k&-k;
}

inline void add (int x, int newl){		//来降低复杂度
	while(x <= maxx){	//因为下标是横坐标，所以最大到maxx
		tree[x] = max(tree[x], newl);
		x += lowbit(x);
	}
}

inline int ask (int x){
	int ret = 0;
	while(x >= 1){
		ret = max(ret, tree[x]);
		x -= lowbit(x);
	}
	return ret;
}

int main(){
	cin >> n;
	for (int i = 1; i <= n; ++i){
		cin >> l[i].s >> l[i].n;
		maxx = max(maxx, l[i].s);
	}
	
	sort(l+1, l+n+1, cmp);	//别忘了排序，之后就和北岸坐标没关系了。
	
	for(int i = 1 ; i <= n; ++i){
		int x = ask(l[i].s) + 1;
		ans = max (ans, x);
		add(l[i].s + 1, x);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Kwork (赞：1)

不是我说，你们这样O（n^2）算法真的不怕被卡嘛，看我的O(nlogn)。

题目意思很明确，按照左边参数快排然后对右边参数求最长上升子序列。

我连二分都没写。~~（你的lower\_bound啊喂）~~







```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <string>
using namespace std;
const int maxn=5000+20,inf=1234567890;
struct data{int a,b;};
data city[maxn];
int n,f[maxn],ans=0;
bool comp(const data &x,const data &y){
    if(x.a==y.a) return x.b<y.b;
    return x.a<y.a;
}
inline void read(int &n){
    char ch=getchar();
    n=0;
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch<='9' && ch>='0');
    return;
}
int main(){
    read(n);
    for(int i=1;i<=n;i++){
        read(city[i].a);
        read(city[i].b);
    }
    sort(city+1,city+n+1,comp);
    for(int i=1;i<=n;i++) f[i]=inf;
    ans=1;f[1]=city[1].b;
    for(int i=2;i<=n;i++){
        if(city[i].b>f[ans]){
            f[++ans]=city[i].b;
        }
        else{
            int pos=lower_bound(f,f+n+1,city[i].b)-f;
            f[pos]=city[i].b;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：1)

这是一个黄题，~~然后我就写了一个Treap~~

显然按左边排完序后对右边做一个最长上升子序列，显然有基础dp方程:

$$f[i]=\max _{j<i,b[j]<b[i]} \left \{f[j] \right \}+1$$

这是一个简单二维偏序问题

然后从头开始扫就满足了第一维$j<i$的限制

第二维直接把$b[j]$作为第一关键字，查$f[j]$最大值

就是建立一个按$b[j]$排序，权值为$f[j]$的平衡树，维护子树最大值即可

先在平衡树中查询$<b[i]$的最大值，$+1$之后记作$w$更新答案然后插入二元组$(b[i],w)$到平衡树里

```cpp
#include<cstdio>
#include<cstdlib>
#include<utility>
#include<algorithm>
using std::sort;
using std::pair;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool f=0;
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
const int N=2e5+10;
int n,ans;
pair<int,int>a[N];
class Treap
{
	private:
		struct tree
		{
			int priority,mx,key,val;
			tree *son[2];
			inline const void pushup()
			{
				mx=max(val,max(son[0]->mx,son[1]->mx));
			}
		}*root,memory_pool[N],*tail,*null;
		inline const void init()
		{
			tail=memory_pool;
			null=tail++;
			root=null->son[0]=null->son[1]=null;
		}
		inline tree *spawn(int key,int val)
		{
			tree *p=tail++;
			p->key=key;
			p->mx=p->val=val;
			p->priority=rand();
			p->son[0]=p->son[1]=null;
			return p;
		}
		inline const void rotate(tree *&fa,const bool &f)
		{
			tree *p=fa->son[f];
			fa->son[f]=p->son[f^1];
			p->son[f^1]=fa;
			fa->pushup();(fa=p)->pushup();
		}
		inline const void insert(tree *&p,int key,int val)
		{
			if (p==null)return p=spawn(key,val),void();
			const bool f=p->key<key;
			insert(p->son[f],key,val);
			p->pushup();
			if (p->son[f]->priority>p->priority)rotate(p,f);
		}
		inline const int lessmax(tree *p,int key)
		{
			if (p==null)return 0;
			if (key==p->key)return p->son[0]->mx;
			if (key<p->key)return lessmax(p->son[0],key);
			return max(lessmax(p->son[1],key),max(p->son[0]->mx,p->val));
		}
	public:
		inline Treap(){init();}
		inline const int lessmax(int key){return lessmax(root,key);}
		inline const void insert(int key,int val){insert(root,key,val);}
}T;
int main()
{
	read(n);
	for (int i=1;i<=n;i++)read(a[i].first),read(a[i].second);
	sort(a+1,a+n+1);
	for (int mx,i=1;i<=n;i++)
		ans=max(mx=T.lessmax(a[i].second)+1,ans),
		T.insert(a[i].second,mx);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：installb (赞：1)

把左岸的城市编号为$ l_1,l_2...l_n $  
把右岸的城市编号为$ r_1,r_2...r_n $  
如果从城市$ l_i,l_j(l_i<l_j)$开辟的航道不交叉 那么必定有$ r_i<r_j $而且$ l $和$ r $是一一对应的  
所以可以以l从小到大结构体排序 求r的最长上升子序列  

这时候看一眼数据范围 $ 2*10^5 $ 那么$ n^2 $算法是不行的  
~~当然大家都知道有很多n log n算法~~  
我这里使用了树状数组  

为什么可以用树状数组:  
一般来说树状数组是不能求区间最值的 但是在LIS里不一样  
树状数组中存的是以该数(不是第几个数 是数本身)结束的LIS  
对于每一个$r_i$我们要求的是目前$1$到$r_i-1$中到每一个数的LIS  
所求的区间一定是**从1开始**的 所以可以直接求最大值
## code:

```cpp
#include <map>
#include <list>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define LL long long
using namespace std;

LL n,tmp,ans = 0,t[4000020]; // 树状数组开四倍最保险
LL MAX_R = 0; // 存最大的r

struct node{
	LL l,r;
	bool operator <(const node &nd)const{
		return l < nd.l;
	} // 重载运算符 以l从小到大对结构体排序
}a[200005];

inline void add(LL x,LL val){
	for(register int i = x;i <= MAX_R;i += (i & -i)){
		t[i] = max(t[i],val);
	}
}
inline LL query(LL x){
	LL ans = 0;
	for(register int i = x;i;i -= (i & -i)){
		ans = max(ans,t[i]);
	}
	return ans;
} // 这里是树状数组的代码 只是把+改成了max

int main(){
	ios::sync_with_stdio(false);
	cin >> n;
	for(register int i = 1;i <= n;i ++){
		cin >> a[i].l >> a[i].r;
		MAX_R = max(MAX_R,a[i].r);
	}
	sort(a + 1,a + 1 + n);
	for(register int i = 1;i <= n;i ++){
		tmp = query(a[i].r) + 1; // 求最值 在加上目前待处理数即+1
		ans = max(ans,tmp); // 每次答案都要更新
		add(a[i].r + 1,tmp); // 更新的是该数+1的LIS
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Drinkwater (赞：1)

嗯，模拟了一下发现是个裸的最长不下降子序列，南岸于北面连接后，北岸只有在其之后的才行






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
#define REP(i,a,b) for(register int i  = (a), i##_end_ = (b); i <= i##_end_ ; ++i)
inline int read()
{
    char c = getchar();register int fg = 1,sum = 0;
    while(c < '0' || c > '9')
    {
        if(c == '-')fg  = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    return fg * sum;
}
int n;
int a[5010],f[5010];
int main()
{
    n = read();
    REP(i,1,n)
    {
        int x,y;
        x = read(), y = read();
        a[i] = y;
    }
    int len = 0;
    REP(i,1,n)
    {
        if(a[i] > f[len])f[++len] = a[i];
        if(a[i] < f[1])f[1] = a[i];
        else
        {
            int d = upper_bound(f+1,f+1+len,a[i])-f;
            f[d] = a[i];
        }
    }
    printf("%d\n",len);
}
```

---

## 作者：xukuan (赞：0)

排序+最长不上升（下降）子序列

先排序，再二分


```pascal
var
 a,b,c:array[0..trunc(2e5)+10] of longint;
// a，b表示南北两岸的城市坐标
// c表示最长不下降子序列
 i,n,m{最长不下降子序列的长度},l,r,mid:longint;

procedure swap(var x,y:longint);//交换
 var
  z:longint;
 begin
  z:=x;
  x:=y;
  y:=z;
end;

procedure qsort(l,r:longint);//快排
 var
  i,j,temp,mid:longint;
 begin
  i:=l; j:=r;
  mid:=a[(l+r) div 2];
  repeat
   while a[i]<mid do inc(i);
   while a[j]>mid do dec(j);
   if i<=j then
    begin
     swap(a[i],a[j]);
     swap(b[i],b[j]);
     inc(i);
     dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;

begin
 readln(n);
 for i:=1 to n do
  readln(a[i],b[i]);
 qsort(1,n);
 c[1]:=b[1]; m:=1;
 for i:=2 to n do
  begin
   if b[i]>=c[m] then
    begin
     inc(m);//序列长度+1
     c[m]:=b[i];//存下数据
     continue;//直接跳过二分
    end;

   l:=1; r:=m; mid:=(l+r) div 2;
   while l<=r do//二分，找到插入位置
    begin
     if b[i]>c[mid] then l:=mid+1//在右半边查找
                    else r:=mid-1;//在左半边查找
     mid:=(l+r) div 2;
    end;
   c[l]:=b[i];//放入数组中
  end;
 writeln(m);
end.
```

---


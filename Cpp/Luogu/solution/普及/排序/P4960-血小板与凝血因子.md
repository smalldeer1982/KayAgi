# 血小板与凝血因子

## 题目背景

为了尽快修复伤口，血小板们正在搬运凝血因子。它们（没毛病）正在讨论怎么分配，因为它们太可爱了，所以就让你来解决这个问题。

![](https://i.loli.net/2018/10/05/5bb7372e781b1.jpg)

## 题目描述

血小板们有两种不同的容器，第一种容器每个容器中只能装同一种凝血因子，第二种容器每个容器中每种凝血因子最多出现一次。为了方便，血小板们想用**同一种**容器装下所有的凝血因子。

换句话说，把 $n$ 个正整数 $a_1$ ~ $a_n$ 分成一些不相交的集合 $S_1$ ~ $S_m$，满足以下两个条件**之一**： 
1. $\forall a_i,\ a_j\in S_k,\ k\in [1,\ m]$ 有 $a_i=a_j$
2. $\forall a_i,\ a_j\in S_k,\ k\in [1,\ m],\ i\neq j$ 有 $a_i\neq a_j$

因为血小板的数量比较少，所以你要把所有的凝血因子装到尽量少的容器里。它们想知道，如何划分能使容器的总数最小。

## 说明/提示

$1\le n\le 1000,\ \ 1\le a_i\le 10^9$。

## 样例解释

### 样例一：

选用第二种容器，分别放入 $\{4\}$，$\{3,1,2,4,5\}$，$\{4\}$，这是一组可行的最优解，更改三个容器的顺序、容器 $2$ 中 $5$ 个凝血因子的顺序可以得到另外的最优解。

### 样例二/三：

这两组样例输入相同，既可以选用第一种容器，也可以选用第二种容器。

两组样例的输出分别为一组可行的最优解，改变顺序可以得到另外的几组最优解。

### 样例四：

选用第一种容器，分别放入 $\{3,3,3\}$，$\{2,2\}$，这是一组可行的最优解，更改两个容器的顺序可以得到另一组最优解。

## 样例 #1

### 输入

```
7
1 2 3 5 4 4 4```

### 输出

```
3 2
1 4
5 3 1 2 4 5
1 4```

## 样例 #2

### 输入

```
3
20181110 20181111 20181111```

### 输出

```
2 1
1 20181110
2 20181111 20181111```

## 样例 #3

### 输入

```
3
20181110 20181111 20181111```

### 输出

```
2 2
2 20181110 20181111
1 20181111```

## 样例 #4

### 输入

```
5
3 2 3 2 3```

### 输出

```
2 1
3 3 3 3
2 2 2```

# 题解

## 作者：南城忆潇湘 (赞：8)

在这里提供一个map的做法：    
做一个小简介：  
map(映射,mapping的缩写)，分为键值和数据值。在头文件map中。它内部是一颗红黑树，按照键值大小排好序（也就是说，果你要按照你自己的顺序排序的话，就要重载运算符）。  
它可以直接用$[]$运算符调用，所以它又称为关联数组（把它当做普通的数组使用就行）。调用的时间复杂度为$O(log_2N)$,N为储存元素的多少。  
那我们要遍历这个映射的话应该怎么办呢？没关系，STL库中有一个**iterator**（迭代器）的东东。在这道题目中，我们就可以使用它来~~（快速）~~解题。  
调用iterator的方法： 

**map <键值的类型,数据值的类型> :: iterator 迭代器名称**

看，是不是很方便。假如我们定义了一个it迭代器。那么，它可以支持的操作有（只列举出在这题需要的内容）。

1.自加/自减。也就是 $++/--$  ,例如：it++/it--。  
注意：这里自加/自减如果超出map的范围，会运行时错误。自加表示访问后一个值，自减表示访问前一个值。  

2.删除当前的值。 erase(it)。注意，如果当前删除it的话，it++或者it--就会越界（因为你现在已经不在map中间了）。所以我们可以再开一个迭代器now,然后it++删除now即可。（下文的代码也是这样写的）。

3.访问it指向（貌似没有一个专业的术语，就说指向吧）的值。由于map中的元素由两种类型组成（其实就是一个pair），所以我们可以有两种方法调用：   
1.it->first/second  
2.(\*it).first/second  
first为键值，second为数据值。

下面就可以放代码~~（水过这道题啦）~~，注意一下，下面的ans1和ans2分别对应第二种、第一种情况

```
#include<bits/stdc++.h>
#define MAXN 1001
using namespace std;
int a[MAXN];
map<int,int> b;
int main(){
	int n,ans1=0,ans2=0;
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),b[a[i]]++,ans1=max(ans1,b[a[i]]);
	sort(a+1,a+1+n);
	ans2=unique(a+1,a+1+n)-a-1;
	if(ans2<ans1){
		cout<<ans2<<" "<<1<<endl;
		map<int,int>::iterator it=b.begin();
		for(int i=1;i<=ans2;i++){
			cout<<it->second<<" ";
			for(int j=1;j<=it->second;j++)
				printf("%d ",it->first);
			it++;	
			cout<<endl;
		}
	}
	else {
		cout<<ans1<<" "<<2<<endl;
		for(int i=1;i<=ans1;i++){
			map<int,int>::iterator it=b.begin();
			cout<<b.size()<<" ";
			while(it!=b.end()){
				if(b[(*it).first]>0)	cout<<it->first<<" ",b[(*it).first]--; 
				map<int,int>::iterator now=it; it++;
				if(now->second==0)	b.erase(now);	
			}		
			cout<<endl;		
		}
	}
	return 0;
}
```

---

## 作者：MarchKid_Joe (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P4960)
# 题意
1. “第一种容器每个容器中只能装同一种凝血因子”等同于共有多少种**不同种类的凝血因子**。
2. “第二种容器每个容器中每种凝血因子最多出现一次”等同于**凝血因子出现次数最多的一种的个数** 
思路
先通过统计存储不同种类的凝血因子的**个数**，同时寻找凝血因子出现次数**最多**的一种的个数。

对于**统计**方面和**寻找最大值**方面的实现
```cpp
sort (a + 1 , a + n + 1);//排序 

//ans1-->不同种类的凝血因子的种数（容器1）
//ans2-->凝血因子出现次数最多的一种的个数（容器2） 
//t-->存储个数 
//d[?].sum-->不同种类的凝血因子的个数
//d[?].r-->存储凝血因子（用于输出）
for (int i = 2 ; i <= n + 1 ; i ++)
{
	if (a [i] != a [i - 1])
	{
		++ ans1;
		d [ans1] . sum = t;
		d [ans1] . r = a [i - 1];
		ans2 = max (ans2 , d [ans1] . sum);
		t = 1;
	}
	else t ++;
}
```
# 输出
- 输出容器1(ans1 <= ans2)
先输出不同种类的凝血因子的个数和容器1，随后输出每种凝血因子出现的个数，并按其出现个数输出。

# _Code_ 
```cpp
printf ("%d 1\n" , ans1);//不同种类的凝血因子的种数 
for (int i = 1 ; i <= ans1 ; i ++)
{
	printf ("%d" , d [i] . sum);//每种凝血因子出现的个数
	for(int j = 1 ; j <= d [i] . sum ; j ++)
	 printf (" %d" , d [i] . r);//输出存储凝血因子 
	printf ("\n");
}
```
- 输出容器2(ans1 > ans2)
先输出凝血因子出现次数最多的一种的个数和容器2，然后将应输出的不同数字存储起来，并统计个数。

	采用的存储方法：枚举1~ans2，如果某些凝血因子出现的个数大于**等于**i，则存入num数组中。
```cpp
for (int i = 1 ; i <= ans2 ; i ++)
{
	int ans = 0;
	for (int j = 1 ; j <= ans1 ; j ++)
	 if (d [j] . sum >= i)
	  num [++ ans] = d [j] . r;
}
```
#  _Code_  
```cpp
printf ("%d 2\n" , ans2 );
for (int i = 1 ; i <= ans2 ; i ++)
{
	int ans = 0;//统计个数 

	for (int j = 1 ; j <= ans1 ; j ++)
	 if (d [j] . sum >= i)//如果够个数 
	  num [++ ans] = d [j] . r;//存储

	printf ("%d" , ans);

	for (int j = 1 ; j <= ans ; j ++)
	 printf (" %d" , num [j]);
	printf ("\n");
}
```
#  _Ac Code_ 
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct node
{
	int sum;
	int r;
};
int n;
int a [1001];
int ans1 , ans2;
int t = 1 , maxn , num [1001];
node d [1001];
bool comp (node x , node y)
{
	return x . sum < y . sum;
}
int max (int x , int y)
{
	return x > y ? x : y;
}
int main ()
{
	scanf ("%d" , & n);

	for (int i = 1 ; i <= n ; i ++)
	 scanf ("%d" , & a [i]);

	sort (a + 1 , a + n + 1);

	for (int i = 2 ; i <= n + 1 ; i ++)
	{
		if (a [i] != a [i - 1])
		{
			++ ans1;
			d [ans1] . sum = t;
			d [ans1] . r = a [i - 1];
			ans2 = max (ans2 , d [ans1] . sum);
			t = 1;
		}
		else t ++;
	}
	if (ans1 > ans2)
	{
		printf ("%d 2\n" , ans2 );
		for (int i = 1 ; i <= ans2 ; i ++)
		{
			int ans = 0;

			for (int j = 1 ; j <= ans1 ; j ++)
			 if (d [j] . sum >= i)
			  num [++ ans] = d [j] . r;

			printf ("%d" , ans);

			for (int j = 1 ; j <= ans ; j ++)
			 printf (" %d" , num [j]);
			printf ("\n");
		}
	}
	if (ans1 <= ans2)
	{
		printf ("%d 1\n" , ans1);
		for (int i = 1 ; i <= ans1 ; i ++)
		{
			printf ("%d" , d [i] . sum);
			for(int j = 1 ; j <= d [i] . sum ; j ++)
			 printf (" %d" , d [i] . r);
			printf ("\n");
		}
	}
	return 0;
}
```


---

## 作者：wjyyy (赞：4)

>大家有发现赛后提交这个题的~~评测信息~~彩蛋吗

因为给出了两种容器，而且容器只能统一使用一种，因此一种比较暴力的方式是枚举这两种哪种更优。

实际上我们可以先对$a_i$排序，然后看出现了多少种不同的元素，元素的种类数是只使用容器$1$的答案，同种元素出现次数的最大值是容器$2$的答案。

比较上述两者答案，选择较小的。对容器$1$而言，答案就是每行把同种元素分为一组；对容器$2$而言，假设某种元素出现了$k$次，那么它出现且仅出现在第$1\sim k$组中。这样输出每组的元素数及元素即可，同时~~因为良心的spj writer~~可以不按顺序输出。

如果迭代器使用熟练的话，可以直接在`std::map`中统计答案并输出。


这道题主要考查了对数据的排序。在$n\le 1,000$的数据中，您可以使用任何可以想到的~~时间复杂度在O(n²logn)以内的~~排序方法来对$a_i$进行排序。

您甚至可以方便地使用`std::sort`、`std::map`来帮您减少代码复杂度，从而在这场ACM赛制的比赛中风生水起。

$\text{ctr}$相信，这道可爱又良心的题目，会让您的比赛之旅有一个好的~~1A~~开始，为您的AK之路提供有力的帮助。
## Code：
```cpp
#include<cstdio>
#include<map>
using std::map;
map<int,int> m;
int a[1010];
int ans[1010][1010];
int main()
{
    int n,u;
    scanf("%d",&n);
    int mx=0;
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&u);
        m[u]++;
        mx=mx>m[u]?mx:m[u];
    }
    ans[0][0]=mx<m.size()?mx:m.size();
    printf("%d ",ans[0][0]);
    if(mx<m.size())
    {
        printf("%d\n",2);
        for(map<int,int>::iterator it=m.begin();it!=m.end();++it)
        {
            int num=it->second;
            for(int i=1;i<=num;++i)
                ans[i][++ans[i][0]]=it->first;
        }
        for(int i=1;i<=ans[0][0];++i)
        {
            for(int j=0;j<=ans[i][0];++j)
                printf("%d ",ans[i][j]);
            puts("");
        }
    }
    else
    {
        printf("%d\n",1);
        for(map<int,int>::iterator it=m.begin();it!=m.end();++it)
        {
            int num=it->second;
            printf("%d ",num);
            for(int i=1;i<=num;++i)
                printf("%d ",it->first);
            puts("");
        }
    }
    return 0;
}
```

---

## 作者：anideahe (赞：3)

### ~~此题数据有点水~~
***
看到题目，想必很多人都想到桶排了吧，看了看数据范围 $10^9$，数组不够大，怎么办？那就开够大的，输入之后取余 $10^6$ 不就行了吗，$a$ 是桶，$s$ 存的是下标，$ss$ 存的是真实的值，$sum$ 是指所有种类里数量的最大值，$t$ 是种类数，按题目要求输出就行了，详见代码，有注释。
```cpp
  #include<bits/stdc++.h>
  #define M 1000001
  using namespace std;
  int n,a[M],x,sum,f[M],t,s[M],ss[M];
  int main(){
      cin>>n;
      for(int i=1;i<=n;i++){
          cin>>x;
          int y=x%(M-1);
          a[y]++;
          sum=max(sum,a[y]);
          if(f[y]==0){//有没有出现过
              f[y]=1;
              s[++t]=y;//保存位置
              ss[t]=x;
          }
      }
      if(t>sum){
          cout<<sum<<" "<<2<<endl;
          for(int i=1;i<=sum;i++){
              int ans=0;
              for(int i=1;i<=t;i++)
                  if(a[s[i]]>=1)
                      ans++;//现有种类数
              cout<<ans<<" ";
              for(int i=1;i<=t;i++)
                  if(a[s[i]]>=1)
                      cout<<ss[i]<<" ",a[s[i]]--;//减掉
              cout<<endl;
          }		
      }
      else {
          cout<<t<<" "<<1<<endl;
          for(int i=1;i<=t;i++){
              cout<<a[s[i]]<<" ";//此种类的数量
              for(int j=1;j<=a[s[i]];j++)
                  cout<<ss[i]<<" ";
              cout<<endl;
          }
      }
      return 0;
  }
```

---

## 作者：VenusM1nT (赞：3)

分别计算两种方法需要的容器，针对不同容器不同输出即可

至于如何计算容器数，可以很明显地发现，第一种容器数等于**凝血因子的种数**，第二种容器数等于**最多的凝血因子的个数**

输出时也不同处理，对于第一种只要每个容器把一种凝血因子装完，即先输出$s[a[i]]$，再输出$s[a[i]]$个$a[i]$（$a[i]$为编号，$s[i]$为数量），对第二种，我们在读入数据的时候记录不同的编号数，将编号去重后放在一个数组中（用$map$可以轻松地完成），对于每个容器先输出$sum$（即现有的凝血因子的种数），再遍历一遍所有的凝血因子，如果有多的就直接输出并$s[a[i]]--$，如果减到$0$就使$sum--$即可

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],id[1005],tot,two;
map <int,int> s;
map <int,bool> used;//这个map用作去重
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        s[a[i]]++;//记录凝血因子个数
        two=max(two,s[a[i]]);
        if(!used[a[i]])
        {
            id[++tot]=a[i];//记录编号
            used[a[i]]=1;
        }
    }
    if(tot<=two)//用第一种容器
    {
        printf("%d %d\n",tot,1);
        for(int i=1;i<=tot;i++)
        {
            printf("%d",s[id[i]]);
            for(int j=1;j<=s[id[i]];j++) printf(" %d",id[i]);
            printf("\n");
        }
    }
    else//用第二种容器
    {
        int sum=tot;
        printf("%d %d\n",two,2);
        for(int i=1;i<=two;i++)
        {
            printf("%d",sum);
            for(int j=1;j<=tot;j++) if(s[id[j]])
            {
                printf(" %d",id[j]);
                s[id[j]]--;
                if(s[id[j]]==0) sum--;
            }
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：ouuan (赞：1)

还是补充一下官方题解中的sort解法（wjyyy嫌我代码太丑没发上来...）

选择容器一，答案为数字的种类数；选择容器二，答案为每种数字个数的最大值。

所以，只要分别求出种类数和每种数字的个数即可。有多种实现方式，排序后扫一遍是其中一种，具体实现可以看代码。

至于方案输出，选择容器一时每个容器放同一个数字，选择容器二时将每种数字的每一个依次放入不同的容器中（这种数字有 $k$ 个就放在前 $k$ 个容器内）。具体实现可以看代码，其中 $plan[i][0]$ 是容器 $i$ 中元素的个数。

```
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int n,a[1010],type,maxx,plan[1010][1010];

int main()
{
	int i,j,temp=0;
	
	cin>>n;
	
	for (i=0;i<n;++i)
	{
		cin>>a[i];
	}
	
	sort(a,a+n);
	
	for (i=0;i<n;++i)
	{
		if (i>0&&a[i]==a[i-1])
		{
			++temp; //temp表示当前数字的个数
		}
		else
		{
			++type; //type表示当前数字是第几种
			maxx=max(temp,maxx);
			temp=1;
		}
	}
	
	maxx=max(temp,maxx);
	
	if (type>maxx)
	{
		type=0;
		
		for (i=0;i<n;++i)
		{
			if (i>0&&a[i]==a[i-1])
			{
				++temp;
				plan[temp][++plan[temp][0]]=a[i];
			}
			else
			{
				++type;
				temp=1;
				plan[1][++plan[1][0]]=a[i];
			}
		}
		
		cout<<maxx<<" 2";
		
		for (i=1;i<=maxx;++i)
		{
			cout<<endl<<plan[i][0];
			for (j=1;j<=plan[i][0];++j)
			{
				cout<<' '<<plan[i][j];
			}
		}
	}
	
	else
	{
		type=0;
		
		for (i=0;i<n;++i)
		{
			if (i>0&&a[i]==a[i-1])
			{
				plan[type][++plan[type][0]]=a[i];
			}
			else
			{
				++type;
				plan[type][++plan[type][0]]=a[i];
			}
		}
		
		cout<<type<<" 1";
		
		for (i=1;i<=type;++i)
		{
			cout<<endl<<plan[i][0];
			for (j=1;j<=plan[i][0];++j)
			{
				cout<<' '<<plan[i][j];
			}
		}
	}
	
	return 0;
}
```

---

## 作者：Level_Down (赞：0)

通过题中所给的两种容器的特性，我们很快就能归纳出各种容器方案最佳的方法：

> 1. 第一种容器中最小个数为血小板的种类个数。

> 2. 第二种容器中最小个数为各类血小板中的最高次数。

由此我们可以很快想到可以用桶排，但是一看数据范围： $1 \leq a \leq 10 ^ 9$，很快就放弃了。

于是我们想到用 map，[不知道 map 的戳我。](https://www.luogu.com.cn/blog/ravenclawyangrunze/solution-p5266)

在 map 中，其大小就是血小板的种类个数，至于各类血小板中的最高次数可以在输入时将 map 中的每个数取最大值。

最后注意一下输出就行了，还没懂的就看代码吧。

截至作者写此文时的最优解代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1005],b[1005],cnt,maxa,sum;
//b数组是为了输出方便设的，存的是各种类血小板的编号，cnt是其指针 
map <int,int> s;
inline int read(){
   register int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main()
{
	n = read();
	for (int i = 1; i <= n; i++)
		{
			a[i] = read();
			s[a[i]]++;
			maxa = max(maxa,s[a[i]]);//得出各类血小板中的最高次数 
			if (s[a[i]] == 1) b[++cnt] = a[i];
		}
	if (maxa < s.size())
	{
		printf("%d 2\n",maxa);
		sum = s.size();
		while(sum)//这里不能直接判s是否为空，因为map中的数减到0之后并不会直接消失，也就是说s.size()一直不会变 
		{
			printf("%d ",sum);
			for (int i = 1; i <= cnt ; i++)//注意输出 
				{
					if (s[b[i]] != 0) 
						{
							printf("%d ",b[i]);
							s[b[i]]--;
							if (s[b[i]] == 0) sum--;
						}
				}
			puts("");
		}
	} else{
		printf("%d 1\n",s.size());//这里的s.size()就是血小板的种类个数 
		for (int i = 1; i <= cnt; i++)
			{
				printf("%d ",s[b[i]]);
				for (int j = 1; j <= s[b[i]]; j++) printf("%d ",b[i]);
				puts("");
			}
	}	
	return 0;	
 } 
```

有问题可以在评论区提出，希望对大家有所帮助。

---

## 作者：fls233666 (赞：0)

考虑分别计算两种容器装完后要用的容器总数。

对于第一种容器，考虑统计一共有多少不同的凝血因子，统计得到的结果就是要用的容器总数。

对于第二种容器，考虑统计每种凝血因子有多少个，取那种数量最多的个数，就是要用的容器总数。

总结一下，我们发现题目就是要我们做一件事：**统计每种凝血因子有多少个，一共有几种凝血因子**。

但是很快，我们发现这事情并不是那么好做：$1 \le a_i \le 10^9$，直接开桶，空间存不下。

这时，我们注意到另一个入手点：$1 \le n \le 1000$

显然，因为 $n$ 的范围极小，那么也就是说，**这里面最多只有 $1000$ 个数字**。

那我们可以先用 STL 的容器或者函数对数组去重，排序。然后在原数组里面统计每个数出现的次数。对于每个数，二分查找它在去重排序后的数组中的位置，然后对应统计它出现的次数。这，就是**离散化**。

另外，这里介绍一个好用的 STL 函数：$\texttt{unique}$

unique 是 STL 比较实用的一个函数。用于“去除”容器内相邻的重复的元素（只保留一个）。**这里说的去除并不是真正将容器内的重复元素删去，只是把重复的元素移到容器最后，但是依然在容器内。** 对于数组而言返回去重后最后一个元素的指针，而其他容器则是返回去重后最后一个元素的迭代器。具体的用法见代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#define rgt register int
using namespace std;

const int mxn = 1e3+3;
vector<int> ans[mxn];  //如果答案为方案二，另外存储后输出
int n,glc,tp=1,mxcnt;  //tp代表最后选择的容器类型，先假设第一种容器更优
int cnt[mxn],lc[mxn],a[mxn];
//cnt统计每种的凝血因子出现的次数
//lc存储离散后的各种凝血因子

inline int qlc(int xlc){
	return lower_bound(lc+1,lc+1+glc,xlc)-lc;
}//找到离散后的凝血因子对应的下标位置

int main(){

	scanf("%d",&n);
	for(rgt i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}//数据读入
    
	memcpy(lc,a,sizeof(lc));  //复制一份a数组到lc数组
	sort(lc+1,lc+n+1);  //排序
	glc=unique(lc+1,lc+1+n)-(lc+1);  //unique去重，glc存储去重后的数字末尾的位置
   //此时glc就是代表有多少种不同数，即容器一要用的数量
    
	for(rgt i=1;i<=n;i++){
		cnt[qlc(a[i])]++;  //离散后统计各种凝血因子出现的次数
		if(cnt[qlc(a[i])]>mxcnt)   //取最大值
			mxcnt=cnt[qlc(a[i])];
	}//最后取得的最大值就是容器二要用的数量
	
	if(mxcnt<glc)  //如果用容器二更优，更新答案
		tp=2;
        
	switch(tp){
		case 1:  //用容器一，求方案时每个数输出cnt遍即可
			printf("%d %d\n",glc,tp);
			for(rgt i=1;i<=glc;i++){
				printf("%d ",cnt[i]);
				for(rgt j=1;j<=cnt[i];j++)  //每个数输出cnt遍
					printf("%d ",lc[i]);
				printf("\n");
			}
			break;
		case 2:  //用容器二，求方案时把每个数按出现的次数分装到前cnt个容器后输出即可
			printf("%d %d\n",mxcnt,tp);
			for(rgt i=1;i<=glc;i++){
				for(rgt j=1;j<=cnt[i];j++)
					ans[j].push_back(lc[i]);
			}  //分装到前cnt个容器中
			for(rgt i=1;i<=mxcnt;i++){
				printf("%d ",ans[i].size());
				for(rgt j=0;j<ans[i].size();j++)
					printf("%d ",ans[i][j]);
				printf("\n");
			}  //输出
			break;
	}
	return 0; 
}
```

---

## 作者：yezl (赞：0)

### 题意概述：

有两种容器，第一种每个容器中只能装**同一种**凝血因子。第二种每个容器中**每种凝血因子最多出现一次**。只能选其中的一种装。

给定 $ n $ 个正整数 $ a_1,a_2…a_n $ 要你对其进行分组，使得这 $ m $ 个组 $ S_1,S_2…S_n $ 中的每一个组满足以下条件**之一**：
1. $ \forall a_i,a_j\in S_k,\;k\in [i,m]\;\;\text{有}\,a_i=a_j $
2. $ \forall a_i,a_j\in S_k,\;k\in [i,m],i\ne j\;\;\text{有}\,a_i=a_j $

说实话我当时看到这两个条件时一脸懵逼，~~于是翻了一下课本~~，其实呢这个 $ \forall $ 就是“任意”， $ \in $ 就是“属于”，所以“翻译”过来就是：
1. 对于任意数 $ a_i $ ，当 $ a_j $ 在 $ S_k $ 内，且 $ k $ 在 $ [i,m] $ 内时，要满足 $ a_i=a_j $ 。
2. 对于任意数 $ a_i $ ，当 $ a_j $ 在 $ S_k $ 内，且 $ k $ 在 $ [i,m] $ 内， $ i\ne j $ 时，要满足 $ a_i=a_j $ 。

当满足以上条件时，要使用的容器数量最小。

### 思路分析：

我的想法很简单：分开处理两种情况，然后选其中使用容器最少的一种输出。那么怎么实现呢？对于第一种容器，我们不难发现凝血因子的种类数就是它的使用量，而同种凝血因子出现次数的最大值就是第二种容器的使用量了。

那么我们就定义 $ ans1 $ 和 $ ans2 $ 分别来储存容器一的使用量和容器二的使用量，然后就是统计啦，先排个序：

```c
sort(a+1,a+n+1);//将a数组从小到大排序
for(int i=2;i<=n;i++)//从a[2]开始枚举
{
	if(a[i]==a[i-1])//如果两个相等
		sum2++;//那么容器二就要多用一个啦
	else//如果不相等
	{
		ans1++;//容器一就要多用一个啦
		ans2=max(sum2,ans2);//将此时ans2的最大值存下来
		sum2=1;//重新统计
	}
}
ans2=max(ans2,sum2);//少统计一次，不要漏了吖
```

这样就统计出来选容器一或容器二所需要的数量啦，然后再选其中小的再输出就好啦，这题的数据量较大，加个快读也是不错的（~~然而我硬是要刷时间，把快输也加上了~~），这里把两个代码都给出来吧。

 $ \large\mathcal{My\;\;Code:} $

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1010;//定义常变量 
int a[N],q1[N][N],q2[N][N];//a数组如题，q数组用来存方案吖 
int n,ans1=1,ans2=0,sum2=1;//ans1存容器1的数量至少一种，所以初始值为1，ans2存容器2的数量 
inline int read()//快读函数 
{
    int num=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0' && ch<='9')
    {
        num=(num<<1)+(num<<3)+ch-'0';
        ch=getchar();
    }
    return num;
}
int main()
{
	n=read();//读入n 
	for(int i=1;i<=n;i++)
		a[i]=read();//读入a数组 
	sort(a+1,a+n+1);//将a数组从小到大排序 
	for(int i=2;i<=n;i++)//从2开始枚举 
	{
		if(a[i]==a[i-1])//如果两个相等 
			sum2++;//那么容器2的使用量就要+1 
		else//否则不相等 
		{
			ans1++;//容器1的使用量+1 
			ans2=max(sum2,ans2);//选连续相等最多的当成容器2的用量 
			sum2=1;//重新开始算 
		}
	}
	ans2=max(ans2,sum2);//最后再取一次最大 
	if(ans1<ans2)//如果选容器1好（比较少） 
	{
		printf("%d 1\n",ans1);//输出用量和1
		int tot=1; //定义个指针变量 
		for(int i=1;i<=n;i++)
		{
			if(a[i]==a[i-1] || i==1)//如果两个相等 
				q1[tot][++q1[tot][0]]=a[i];//将当前元素存入q1数组 
			else//否则不相等，那么指针先自加，然后将当前元素存入q1数组 
				q1[++tot][++q1[tot][0]]=a[i];
		}
		for(int i=1;i<=ans1;i++)
		{
			printf("%d ",q1[i][0]);//输出方案 
			for(int j=1;j<=q1[i][0];j++)
				printf("%d ",q1[i][j]);
			printf("\n");
		}
	}
	else//否则就是选容器二
	{
		printf("%d 2\n",ans2);
		int tot=1;//同上 
		for(int i=1;i<=n;i++)
		{
			if(a[i]!=a[i-1])//如果前后不相等 
				tot=1,q2[tot][++q2[tot][0]]=a[i];//指针从1开始，将a[i]存入q2数组 
			else//否则 
				q2[++tot][++q2[tot][0]]=a[i];//直接存乳q2数组 
		}
		for(int i=1;i<=ans2;i++)//枚举到ans2 
		{
			printf("%d ",q2[i][0]);//将方案输出 
			for(int j=1;j<=q2[i][0];j++)
				printf("%d ",q2[i][j]);
			printf("\n");//换行 
		}
	}
	return 0;//结束 
}
```

$ \large\texttt{加快速输出版：} $ ~~有点丑，不想说什么了~~

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1010;//定义常变量 
int a[N],q1[N][N],q2[N][N];//a数组如题，q数组用来存方案吖 
int n,ans1=1,ans2=0,sum2=1;//ans1存容器1的数量至少一种，所以初始值为1，ans2存容器2的数量 
inline int read()//快读函数 
{
    int num=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0' && ch<='9')
    {
        num=(num<<1)+(num<<3)+ch-'0';
        ch=getchar();
    }
    return num;
}
inline void nput(int x)//快速输出函数 
{
    if(x==0)
    {
        printf("0");
        return ;
    }
    char F[200];
    int tmp=abs(x);
    if(x<0)putchar('-') ;
    int cnt=0;
    while(tmp>0)
    {
        F[cnt++]=tmp%10+'0';
        tmp/=10;
    }
    while(cnt>0)
        putchar(F[--cnt]);
}
int main()
{
	n=read();//读入n 
	for(int i=1;i<=n;i++)
		a[i]=read();//读入a数组 
	sort(a+1,a+n+1);//将a数组从小到大排序 
	for(int i=2;i<=n;i++)//从2开始枚举 
	{
		if(a[i]==a[i-1])//如果两个相等 
			sum2++;//那么容器2的使用量就要+1 
		else//否则不相等 
		{
			ans1++;//容器1的使用量+1 
			ans2=max(sum2,ans2);//选连续相等最多的当成容器2的用量 
			sum2=1;//重新开始算 
		}
	}
	ans2=max(ans2,sum2);//最后再取一次最大 
	if(ans1<ans2)//如果选容器1好（比较少） 
	{
		nput(ans1),printf(" 1\n");//输出用量和1
		int tot=1; //定义个指针变量 
		for(int i=1;i<=n;i++)
		{
			if(a[i]==a[i-1] || i==1)//如果两个相等 
				q1[tot][++q1[tot][0]]=a[i];//将当前元素存入q1数组 
			else//否则不相等，那么指针先自加，然后将当前元素存入q1数组 
				q1[++tot][++q1[tot][0]]=a[i];
		}
		for(int i=1;i<=ans1;i++)
		{
			nput(q1[i][0]),printf(" ");//输出方案 
			for(int j=1;j<=q1[i][0];j++)
				nput(q1[i][j]),printf(" ");
			printf("\n");
		}
	}
	else//否则就是选容器二
	{
		nput(ans2),printf(" 2\n");
		int tot=1;//同上 
		for(int i=1;i<=n;i++)
		{
			if(a[i]!=a[i-1])//如果前后不相等 
				tot=1,q2[tot][++q2[tot][0]]=a[i];//指针从1开始，将a[i]存入q2数组 
			else//否则 
				q2[++tot][++q2[tot][0]]=a[i];//直接存乳q2数组 
		}
		for(int i=1;i<=ans2;i++)//枚举到ans2 
		{
			nput(q2[i][0]),printf(" ");//将方案输出 
			for(int j=1;j<=q2[i][0];j++)
				nput(q2[i][j]),printf(" ");
			printf("\n");//换行 
		}
	}
	return 0;//结束 
}
```

希望可以帮到大家。

---

## 作者：Mars_Dingdang (赞：0)

看到各位大佬都用了 `map` 来做，本蒟蒻打算发一篇纯模拟的题解。

### 题目大意
$\ \ \ \ \ \   $ 血小板们有两种不同的容器，第一种容器每个容器中只能装 **同一种** 凝血因子，第二种容器每个 容器中每种凝血因子 **最多出现一次** 。为了方便，血小板们想用 **同一种** 容器装下所有的凝血因子。

$\ \ \ \ \ \   $ 换句话说，容器一的个数就是凝血因子的种类数，容器二的个数就是同种凝血因子数量的最大值。
### 大体思路
**1、判断数量**

$\ \ \ \ \ \   $ 首先是判断两种容器的数量，选择数量少的容器。因此先用c++中STL标准库里的 `sort` 来进行排序（默认为从小到大）。然后遍历一遍所有的凝血因子，如果后一项与前一项相等，则让第二种容器的数量加一；如果后一项与前一项不相等，则让第一种容器的数量加一，同时记录下第二种容器数量的最大值并将其初始化。

代码如下：
```cpp
	int n,num1=1,Num2=1,num2=0;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];//输入
	sort(a+1,a+n+1);//快速排序
	for(int i=2;i<=n;i++){
		if(a[i]!=a[i-1]) {//出现不同种类的凝血因子
			num1++;//容器一数量增加
			num2=max(Num2,num2);
			Num2=1;//记录容器二数量最大值并初始化
		}
		if(a[i]==a[i-1]) {
			Num2++;//若相等，容器二数量增加
		}
	}
	num2=max(Num2,num2);//再次比较（这个不能漏，否则你只能拿90分）
```
**2、放置凝血因子并输出**

$\ \ \ \ \ \   $ 这里枚举即可，通过比较两种容器的数量，选择数量少的容器输出。这里举第二种容器的例子。同样遍历一遍所有凝血因子，如果两项相等则让标记变量 $x+1$ （记录存放在第几个此类容器）然后存入；如果两项不相等则让标记变量 $x=1$ （初始化）然后存入。最后输出即可。

代码如下：
```cpp
	if(num1>num2){//判断大小
		cout<<num2<<" "<<2<<endl;//输出数量及种类
		int x=1;
		for(int i=1;i<=n;i++){//遍历
			if(a[i]!=a[i-1] || i==1){//若满足第二种容器的条件
				x=1;//初始化
				bot2[x][++bot2[x][0]]=a[i];//bot2[x][0]记录存放的位置，同时也是此容器内凝血因子的数量
			}
			else{
				x++;
				bot2[x][++bot2[x][0]]=a[i];//同理
			}
		}
		for(int i=1;i<=num2;i++){
			cout<<bot2[i][0]<<" ";//先输出数量
			for(int j=1;j<=bot2[i][0];j++){
				cout<<bot2[i][j]<<" ";
			}
			cout<<endl;//输出内容并换行
		}
	}
```

第一种容器同理，只不过**不需要将标记变量初始化**。

### 完整代码：
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
#define N 1002
int a[N],bot1[N][N],bot2[N][N];
int main(){
	int n,num1=1,Num2=1,num2=0;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];//输入
	sort(a+1,a+n+1);//排序
	for(int i=2;i<=n;i++){
		if(a[i]!=a[i-1]) {
			num1++;
			num2=max(Num2,num2);
			Num2=1;
		}
		if(a[i]==a[i-1]) {
			Num2++;
		}
	}
	num2=max(Num2,num2);//记录两种容器数量
	if(num1>num2){//比较
		cout<<num2<<" "<<2<<endl;
		int x=1;
		for(int i=1;i<=n;i++){
			if(a[i]!=a[i-1] || i==1){
				x=1;
				bot2[x][++bot2[x][0]]=a[i];
			}
			else{
				x++;
				bot2[x][++bot2[x][0]]=a[i];//存入
			}
		}
		for(int i=1;i<=num2;i++){
			cout<<bot2[i][0]<<" ";
			for(int j=1;j<=bot2[i][0];j++){
				cout<<bot2[i][j]<<" ";
			}
			cout<<endl;//输出
		}
	}
	else{
		cout<<num1<<" "<<1<<endl;
		int x=1;
		for(int i=1;i<=n;i++){
			if(a[i]==a[i-1] || i==1){
				bot1[x][++bot1[x][0]]=a[i];
			}
			else{
				x++;
				bot1[x][++bot1[x][0]]=a[i];
			}
		}
		for(int i=1;i<=num1;i++){
			cout<<bot1[i][0]<<" ";
			for(int j=1;j<=bot1[i][0];j++){
				cout<<bot1[i][j]<<" ";
			}
			cout<<endl;
		}
	}//同理
	return 0；//完美（这里有一处防作弊）
}
```
~~看得这么认真，不点个赞再走嘛qaq~~

---


# 会议座位

## 题目背景

话说校长最近很喜欢召开全校教职工大会，让老师们强行听他装逼


## 题目描述

现在校长在校园网上公布了一份座位表，$n$ 位老师从左到右依次排成一行。老师们都对这个座位很满意。

然而到了开会时，校长不小心把座位表打乱了，老师们很不满。老师们并不在意自己的位置变了多少，但如果有一对老师 $a$ 和 $b$，他们原来的座位是 $a$ 在 $b$ 左边，现在变成了 $a$ 在 $b$ 右边，那么这一对老师便会贡献一单位不满值。

校长想知道这些老师的总不满值是多少。

## 说明/提示

对于 $30\%$ 的数据，$1\le n \le 10^3$。

对于 $100\%$ 的数据，$1\le n \le 10^5$，每位老师名字长度不超过 $5$，只有大小写字母并且互不相同。注意名字对大小写敏感。

## 样例 #1

### 输入

```
3
Stan Kyle Kenny
Kyle Stan Kenny```

### 输出

```
1```

## 样例 #2

### 输入

```
5
A B C D E
B A D E C```

### 输出

```
3```

# 题解

## 作者：渺小的Mastar (赞：22)

trie树加树状数组求逆序对，绝对没有重复题解=.=
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
#define rgi register int 
#define maxn 100005
#define N 500005
using namespace std;
int n,a[maxn],tree[maxn],num[N],trie[N][100];
ll ans=0,tot;
string s;
void upd(string s,int x)
{
    int p=0;
    for(int i=0;i<s.size();i++)
    {
        if(!trie[p][s[i]-'A'])
            trie[p][s[i]-'A']=++tot;
        p=trie[p][s[i]-'A'];
    }
    num[p]=x;
}//插入字符串
int get(string s)
{
    int p=0;
    for(int i=0;i<s.size();i++)
        p=trie[p][s[i]-'A'];
    return num[p];
}
inline int lowbit(int x)
{
	return x&(-x);
}
inline void add(int x,int k)
{
	for(;x<=n;x+=lowbit(x))
		tree[x]+=k;
}
ll query(int x)
{
	ll tmp=0;
	for(;x;x-=lowbit(x))
		tmp+=tree[x];
	return tmp;
}
int main()
{
	cin>>n;
	for(rgi i=1;i<=n;++i)
	{
		cin>>s;
		upd(s,i);
	}
	for(rgi i=1;i<=n;++i)
	{
		cin>>s;
		a[i]=get(s);
	}
	for(rgi i=1;i<=n;++i)
	{
		add(a[i],1);
		ans+=i-query(a[i]);
	}
	cout<<ans;
}
```

---

## 作者：ADay (赞：18)

##  不难发现，此题就是在找逆序对，只不过数字换成了字符串
### ~~注：方法2不是重复的解法~~
我用归并排序来求数字的逆序对  
那么字符串怎么找逆序对呢？
### 方法1：$map$
基本上其他题解也都有用，设一个$map<string,int>m$即可，映射的数字是字符串的编号。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+5;
string s;
int n,a[N],b[N];
long long ans;//记得开longlong
map<string,int>m;//map在这里

void merge_sort(int left,int right)//归并排序
{
	if(left>=right) return;
	int mid = (right-left)/2+left;
	merge_sort(left,mid);
	merge_sort(mid+1,right);
	int i=left,j=mid+1,k=left;
	while(i<=mid && j<=right)
	{
		if(a[i]<a[j]) b[k++]=a[i++];
		else b[k++] = a[j++],ans+=mid-i+1;//增加逆序对
	}
	while(i<=mid) b[k++] = a[i++];
	while(j<=right) b[k++] = a[j++];
	for(int i=left;i<=right;i++) a[i]=b[i];
}

int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加速cincout
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		m[s]=i;//当前编号
	}
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		a[m[s]]=i;
	}
	merge_sort(1,n);
	cout<<ans;
	return 0;
}
```
### 方法2：字符串排序
发现其他题解都没有这个做法，我来一个吧。  
我们可以写一个结构体，保存原来和现在的两个字符串，然后**以原来的字符串为关键字进行排序**，接着就可以字符串式归并排序。   
而且$string$的运算符已经被重载，直接使用归并排序即可。  
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+5;
string a[N],b[N];
int n;
long long ans;/longlong！

struct node
{
	string s,a;//原来的s和现在的a
}s[N];

void merge_sort(int left,int right)//归并排序
{
	if(left>=right) return;
	int mid = (right-left)/2+left;
	merge_sort(left,mid);
	merge_sort(mid+1,right);
	int i=left,j=mid+1,k=left;
	while(i<=mid && j<=right)
	{
		if(a[i]<a[j]) b[k++]=a[i++];
		else b[k++] = a[j++],ans+=mid-i+1;
	}
	while(i<=mid) b[k++] = a[i++];
	while(j<=right) b[k++] = a[j++];
	for(int i=left;i<=right;i++) a[i]=b[i];
}

bool cmp(node x,node y)
{
	return x.s<y.s;//以原来为关键字
}

int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加速
	cin>>n;
	for(int i=1;i<=n;i++)cin>>s[i].s;
	for(int i=1;i<=n;i++)cin>>s[i].a;
	sort(s+1,s+n+1,cmp);//sort排序
	for(int i=1;i<=n;i++)a[i]=s[i].a;//现在的赋值给a数组，可直接套到归并排序
	merge_sort(1,n);
	cout<<ans;
	return 0;
}
```
### 记得开$\mathcal{LONG\;LONG}$！
~~做法新颖，求过~~

---

## 作者：1jia1 (赞：12)

n<=100000，显然可以O(N√N)水过。

核心思路：map离散化+分块找逆序对。

```cpp
#include <iostream>
#include <map>
#include <string>
#define N 100001
using namespace std;
map<string,int>num;
int n,a[N],pos[N],size,sum[N],dot[N];
long long ans=0;
inline void insert(int num)
{
	for(int i=1;i<pos[num];i++)ans+=sum[i];
	for(int i=(pos[num]-1)*size+1;i<num;i++)ans+=dot[i];
	dot[num]++;
	sum[pos[num]]++;
	return;
}
int main()
{
	cin>>n;
	string s;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		num[s]=i;//离散化
	}
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		a[i]=num[s];
	}
	for(size=1;size*size<=n;size++);size--;
	for(int i=1;i<=n;i++)pos[i]=(i-1)/size+1;
	for(int i=n;i>=1;i--)
	{
		insert(a[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：风人 (赞：9)

+  ~~当你看到我的时候，就知道这是道水题~~

# [P5149](https://www.luogu.com.cn/problem/P5149) 题解

### 题目本质：求逆序对

因此我们可以很容易的把这道题分为两部分：
1. 求顺序。
2. 求逆序对。

~~找到了题目切入点就可以开始切了~~

第一部分，可以使用Hash、Trie、甚至Map。而我推荐Trie，因为~~好打~~、较快、无错。为了获得顺序，我们只需要将附加数组记录顺序即可，代码如下：
```cpp
void insert(char s[], int k) {
  int u = 1;
  int len = strlen(s);
  for (int i = 0; i < len; i++) {
    int a = s[i] - 'a';
    if (!ch[u][a]) ch[u][a] = ++tot;
    u = ch[u][a];
  }
  cnt[u] = k;
  return;
}

void find(char s[], int k) {
  int u = 1;
  int len = strlen(s);
  for (int i = 0; i < len; i++) {
    int a = s[i] - 'a';
    u = ch[u][a];
  }
  finded[k] = cnt[u];
}
```
#### 完成这一部分，我们很容易就得到了坐位顺序，那么我们只需要求逆序对即可：

```cpp
void MergeSort(int l, int r) {
  if (l == r) return;
  int mid = (l + r) >> 1;
  MergeSort(l, mid), MergeSort(mid + 1, r);
  int i = l, j = mid + 1, t = l;
  while (i <= mid && j <= r)
    if (finded[i] <= finded[j])
      b[t++] = finded[i++];
    else
      b[t++] = finded[j++], ans += mid - i + 1;
  while (i <= mid) b[t++] = finded[i++];
  while (j <= r) b[t++] = finded[j++];
  for (int k = l; k <= r; ++k) finded[k] = b[k];
}
```
什么这不是归并排序嘛？

没错！但我加了一句话，看看

``` 
else
      b[t++] = finded[j++], ans += mid - i + 1;
```
      
就是在这里，我们统计了每次排序不符合顺序的个数，因此就得到了逆序对个数。

### 现在我们已经完成了两个部分，结合即可了，**上完整代码**：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN = 5e5 + 5;
int ch[MAXN][26 * 2], cnt[MAXN];
int n, ans, tot = 1, finded[int(1e5 + 5)], b[int(1e5 + 5)];
char s[6];
void insert(char[], int);
void find(char[], int);
void MergeSort(int, int);

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    scanf("%s", s);
    insert(s, i);
  }
  for (int i = 1; i <= n; i++) {
    scanf("%s", s);
    find(s, i);
  }

  MergeSort(1, n);
  cout << ans;
}

void insert(char s[], int k) {
  int u = 1;
  int len = strlen(s);
  for (int i = 0; i < len; i++) {
    int a = s[i] - 'a';
    if (!ch[u][a]) ch[u][a] = ++tot;
    u = ch[u][a];
  }
  cnt[u] = k;
  return;
}

void find(char s[], int k) {
  int u = 1;
  int len = strlen(s);
  for (int i = 0; i < len; i++) {
    int a = s[i] - 'a';
    u = ch[u][a];
  }
  finded[k] = cnt[u];
}

void MergeSort(int l, int r) {
  if (l == r) return;
  int mid = (l + r) >> 1;
  MergeSort(l, mid), MergeSort(mid + 1, r);
  int i = l, j = mid + 1, t = l;
  while (i <= mid && j <= r)
    if (finded[i] <= finded[j])
      b[t++] = finded[i++];
    else
      b[t++] = finded[j++], ans += mid - i + 1;
  while (i <= mid) b[t++] = finded[i++];
  while (j <= r) b[t++] = finded[j++];
  for (int k = l; k <= r; ++k) finded[k] = b[k];
}
```

## 后记：

于是，你拿去交了；于是，你发现WA了4个点：

![](https://cdn.luogu.com.cn/upload/image_hosting/6x45fdo0.png)

你忘了，**不开** $long $ $ long$ **见祖宗**，你知道了怎么做，于是AC了这道题。

---

## 作者：谢谢_对不起 (赞：4)

# 归并排序求逆序对 +map处理字符串。

虽然写这道题时是看标签 trie树来写的，但是发现用map处理更方便。  

第一遍输入时用map对每个字符串赋予数字。  
第二遍输入时生成数组，用数字对应字符串    

具体为：

------------

```cpp
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	   {
	   	cin>>s;
	   	nmsl[s]=i;
	   }
	int j=0;
	for(int i=1;i<=n;i++)
	{
		 cin>>s;
		 c[++j]=nmsl[s];
	}
```


------------
然后归并排序的部分：


------------
```cpp
void qsort(int a,int b)
{	
    if(a==b)return;
	int mid=(a+b)>>1;
	int i=a,j=mid+1,k=a;
    qsort(a,mid),qsort(mid+1,b);
    while(i<=mid&&j<=b)
	if(c[i]<=c[j])
	  {
	  	d[k++]=c[i++];
	  }
	else 
	  {
	  	d[k++]=c[j++];
	  	ans+=mid-i+1;
	  }
	while(i<=mid)
	  	d[k++]=c[i++];
	while(j<=b)
	    d[k++]=c[j++];
	for(int l=a;l<=b;l++)
	    c[l]=d[l];
}
```


------------
于是合起来就是AC代码  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<map>
using namespace std;
string s;
map<string,int>nmsl;
int n;
long long ans=0;
int c[1000001],d[1000001];
void qsort(int a,int b)
{	
    if(a==b)return;
	int mid=(a+b)>>1;
	int i=a,j=mid+1,k=a;
    qsort(a,mid),qsort(mid+1,b);
    while(i<=mid&&j<=b)
	if(c[i]<=c[j])
	  {
	  	d[k++]=c[i++];
	  }
	else 
	  {
	  	d[k++]=c[j++];
	  	ans+=mid-i+1;
	  }
	while(i<=mid)
	  	d[k++]=c[i++];
	while(j<=b)
	    d[k++]=c[j++];
	for(int l=a;l<=b;l++)
	    c[l]=d[l];
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	   {
	   	cin>>s;
	   	nmsl[s]=i;
	   }
	int j=0;
	for(int i=1;i<=n;i++)
	{
		 cin>>s;
		 c[++j]=nmsl[s];
	}
	qsort(1,n);
	printf("%lld",ans);
	return 0;
}
```
//记住ans一定开longlong  
首次提交应为没开longlong60分。。
~~再开错剁手~~

 希望这篇题解给大家帮助  
 我的第二篇题解

---

## 作者：览遍千秋 (赞：4)

给一开始座位表顺序中每个老师一个编号，分别为$1,2,3,...,n$。

再根据打乱后的座位表顺序求出新的编号序列。

显然是求新编号序列中逆序对个数

可以使用归并排序或者树状数组解决。

题解区里没有树状数组，那我就发个树状数组的吧。

code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

template <typename Tp>
void read(Tp &x){
	x=0;char ch=1;int fh;
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-'){
		fh=-1;ch=getchar();
	}
	else fh=1;
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=fh;
}

int n;
string s;
map<string,int>mp;

int c[100007];
void change(int x,int k){
	while(x<=n){
		c[x]+=k;x+=(x&(-x));
	}
}

int query(int x){
	int ret=0;
	while(x){
		ret+=c[x];x-=(x&(-x));
	}
	return ret;
}

int ans,a[100007];

signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(register int i=1;i<=n;i++){
		cin>>s;mp[s]=i;
	}
	for(register int i=1;i<=n;i++){
		cin>>s;a[i]=mp[s];
	}
	for(register int i=n;i>=1;i--){
		ans+=query(a[i]);change(a[i],1);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

当然，给老师编号的工作除了可以用`map`，也可以手写`Trie`，都挺简单。

---

## 作者：Baihua (赞：4)

## 思路 ：求逆序对个数

* 字符串可以用$STL$中提供的$map$解决。

* 成功把字符串转化成数字序列$B$后，就可以利用**树状数组** 或者**归并排序** 求逆序对了 。

* 关于树状数组求逆序对的原理：

  1. 对于任意的$B[i]$ ，$Add(B[i],1)$ 表示$B[i]$ 已经出现过。
  2. $Ask(B[i]-1)$ 可以查找到那些**已经出现过** 的 ， 而且 **小于$B[i]$ ** 的数字的**个数** 。
  3. 已经插入的$i-1$ 个数字里，有$i-1-Ask(B[i]-1)$ 个数大于$B[i]$ ，它们和$B[i]$ 构成了逆序对。
  4. 累加答案即可

* 点击[这里](https://www.luogu.org/problemnew/show/P3374)学习树状数组

* Code

  ```cpp
  #include <iostream>
  #include <fstream>
  #include <algorithm>
  #include <string.h>
  #include <stdio.h>
  #include <map>
  #define re register
  #define GC getchar()
  #define Lowbit(X) (X&(-X))
  using namespace std ;
  const int Maxn = 100000  , Dlt = 1;
  int N ;
  struct Person {
  	int Place ;
  	string Name ;
  };
  Person A[Maxn + Dlt] ;
  map <string , int > M ;
  int B[Maxn + Dlt] ;
  int T[Maxn + Dlt] ;
  /*
  头文件和准备工作
  结构体Person 中的Place是原有的位置，Name是对应的字符串；
  数组B是打乱的序列，T是树状数组。
  */
  void Add (int X , int K) {
  	while (X <= N) {
  		T[X] += K ;
  		X += Lowbit(X) ;
  	}
  }
  int Ask (int X) {
  	int Ans = 0 ;
  	while (X > 0) {
  		Ans += T[X] ;
  		X -= Lowbit(X) ;
  	}
  	return Ans ;
  }
  //树状数组的添加和查询操作
  int main () {
  	//freopen ("P5149.in" , "r" , stdin) ;
  	scanf ("%d" , &N) ;
  	M.clear();
  	for (re int i = 1 ; i <= N ; ++ i) {
  		cin >> A[i].Name ;
  		M[A[i].Name] = i ;
  	}
  	string S ;
  	for (re int i = 1 ; i <= N ; ++ i) {
  		cin >> S ;
  		B[i] = M[S] ;
  	}
  //	利用map完成把字符串转化为数字的操作，方便后续树状数组的操作
  	memset (T , 0 , sizeof(T)) ;
  	long long int Ans = 0 ;
  	for (re int i = 1 ; i <= N ; ++ i) {
  		Add (B[i] , 1) ;
  		Ans += i - Ask(B[i] - 1) - 1 ;
  	}
  	cout << Ans<<endl;
  	fclose (stdin) ;
  	fclose (stdout);
  	return 0;
  }
  ```

  ### Thanks!

---

## 作者：听取MLE声一片 (赞：3)

首先这道题要用map处理一下，就是先将每位老师的标准座号存储一下。第二行输入时，将每位老师对应标号，就可以产生一系列数组，接着就可以简单逆序对啦！

```
    for(int i=0;i<n;i++){
    	cin>>x[i];
    	book[x[i]]=i;
	}
    for(int i=1;i<=n;i++){
    	cin>>y[i];
    	a[i]=book[y[i]];
	}
```

这一段讲了map的具体实现

接着是逆序对：[参考题目](https://www.luogu.com.cn/problem/P1908)

里边的题解都讲的非常好，我就找重点说。

逆序对用到归并排序的思想，就是先拆分，再合并起来。

下边引用这位大佬在[这一篇题解里的一幅图](https://www.luogu.com.cn/blog/qqq1112/solution-p1908)

![](https://cdn.luogu.com.cn/upload/pic/59594.png)

详细的本蒟蒻就不讲了，看这位大佬的就行了。

本蒟蒻这里列出的是一种精简版，码风稍微好一点。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
long long ans;
int a[1000000],b[1000000],n;
string x[1000000],y[1000000];
void p(int x,int y)
{
    if(x==y)
		return;
    int m=(x+y)/2;
    p(x,m);
    p(m+1,y);
    int i=x,j=m+1,k=x;
    while(i<=m&&j<=y){
        if(a[i]<=a[j]){
        	b[k]=a[i];
			k++;
			i++;
		}
        else{
            b[k]=a[j];
			k++;
			j++;
            ans+=m-i+1;
        }
    }
    while(i<=m){
    	b[k]=a[i];
		k++;
		i++;
	}
    while(j<=y){
    	b[k]=a[j];
		k++;
		j++;
	}
    for(int i=x;i<=y;i++)
        a[i]=b[i];
}
map<string,int> book;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++){
    	cin>>x[i];
    	book[x[i]]=i;
	}
    for(int i=1;i<=n;i++){
    	cin>>y[i];
    	a[i]=book[y[i]];
	}
    p(1,n);
    cout<<ans;
    return 0;
}
```

谢谢大家！

---

## 作者：Del_Your_Heart (赞：3)

# 字符串 $+$ 逆序对 $->$ 树 $+$ 树 $?$
# $trie$树 $+$ $zkw$线段树

------------

## 题意：给你$n$个字符串，求打乱后的逆序对个数。
**(悄悄告诉你，我是从$P4375$——一个逆序对题过来的)**
**一看到逆序对，我就熟练的打起了$zkw$线段树。**
```cpp
        update(a[i],1),ans+=i-query(1,a[i]);//逆序对专用模板
```
**这里$zkw$线段树的实现珂以参考本蒟蒻写的**[$P4375$的题解](https://www.luogu.org/blog/CreeperBatter/solution-p4375)

**$trie$树也好像只起了$hash$的作用？套模板就行。**


### 完整代码如下：(差点$MLE$，时间与树状数组不相上下)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500005;
int n,d=1,cnt=1,ch[maxn]['z'-'A'+1],a[maxn],f[maxn];
int zkw[maxn<<1];char s[105];
inline int read(){
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){f|=ch=='-';ch=getchar();}
	while(isdigit(ch)){x=(x*10)+(ch^48);ch=getchar();}
	return f?-x:x;
}
inline void insert(char *s,int tim){
	int u=1,len=strlen(s);
	for(int i=0;i<len;++i){
		int c=s[i]-'A';
		if(!ch[u][c])
			ch[u][c]=++cnt;
		u=ch[u][c];
	}
	f[u]=tim;
}
inline int getsum(char *s){
    int len=strlen(s),u=1;
    for(int i=0;i<len;++i){
        int c=s[i]-'A';
        u=ch[u][c];
    }
    return f[u];
}
inline void update(int pos,int val){for(pos+=d;pos;pos>>=1)zkw[pos]+=val;}
inline int query(int l,int r){int ans=0;for(l=l+d-1,r=r+d+1;l^r^1;l>>=1,r>>=1){if(~l&1)ans+=zkw[l^1];if(r&1)ans+=zkw[r^1];}return ans;}
signed main(){
    cnt=1;
    memset(f,0,sizeof f);memset(ch,0,sizeof ch);
    for(int i=0;i<=25;++i)
        ch[0][i]=1;
    n=read();
    long long ans=0;
    while(d<=n+1)
        d<<=1;
    for(register int i=1;i<=n;++i){
        scanf("%s",s);
        insert(s,i);
    }
    for(register int i=1;i<=n;++i){
        scanf("%s",s);
        a[i]=getsum(s);
    }
    for(register int i=1;i<=n;++i){
        update(a[i],1);
        ans+=i-query(1,a[i]);
    }
    cout<<ans;
	return 0;
}
```


---

## 作者：yu__xuan (赞：2)

### 题目
[P5149 会议座位](https://www.luogu.com.cn/problem/P5149)
### 思路
$trie \ +$ 归并排序。

第一遍先按原顺序把每个人加到字典树里，用字典树维护了这个人原来是第几个。

第二遍开个数组存下第 $i$ 个人原来是第几个，然后再求一边逆序对。

### Code
```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
#include<algorithm>
#define MAXN 500001

inline void read(int &T) {
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int n,map[201],a[MAXN],temp[MAXN];
long long ans=0;
struct trie {
	int cnt,node[MAXN][52];
	int num,name[MAXN];
	void insert(std::string s) {
		int len=s.length(),root=0;
		for(int i=0;i<len;++i) {
			if(!node[root][map[s[i]]]) {
				node[root][map[s[i]]]=++cnt;
			}
			root=node[root][map[s[i]]];
		}
		name[root]=++num;
	}
	int find(std::string s) {
		int len=s.length(),root=0;
		for(int i=0;i<len;++i) {
			root=node[root][map[s[i]]];
		}
		return name[root];
	}
}t1;

void mergesort(int l,int r,int mid) {
	int i=l,j=mid+1,tot=0;
	while(i<=mid&&j<=r) {
		if(a[i]>a[j]) {
			ans+=mid-i+1;
			temp[++tot]=a[j++];
		}else temp[++tot]=a[i++];
	}
	while(i<=mid) temp[++tot]=a[i++];
	while(j<=r) temp[++tot]=a[j++];
	for(int k=1;k<=tot;++k) a[l++]=temp[k];
}

void merge(int l,int r) {
	if(l==r) return;
	int mid=(l+r)>>1;
	merge(l,mid),merge(mid+1,r);
	mergesort(l,r,mid);
}

int main() {
	read(n);
	for(int i='a';i<='z';++i) map[i]=i-'a';
	for(int i='A';i<='Z';++i) map[i]=i-'A'+26;
	std::string s;
	for(int i=1;i<=n;++i) {
		std::cin>>s;
		t1.insert(s);
	}
	for(int i=1;i<=n;++i) {
		std::cin>>s;
		a[i]=t1.find(s);
	}
	merge(1,n);
	std::cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：mrclr (赞：2)

看题目描述就知道要求逆序对数。

至于字符串转换成数字，用map搞定。
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<map>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 1e5 + 5;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}

int n, a[maxn], cnt = 0;
char s[10];
map<string, int> mp;

int c[maxn];
In int lowbit(int x)
{
  return x & -x;
}
In void add(int pos)
{
  for(; pos <= n; pos += lowbit(pos)) c[pos]++;
}
In int query(int pos)
{
  int ret = 0;
  for(; pos; pos -= lowbit(pos)) ret += c[pos];
  return ret;
}

int main()
{
  n = read();
  for(int i = 1; i <= n; ++i)
    {
      scanf("%s", s);
      mp[s] = ++cnt;
    }
  ll ans = 0;
  for(int i = 1; i <= n; ++i)
    {
      scanf("%s", s);
      a[i] = mp[s];
    }
  for(int i = n; i; --i) ans += query(a[i]), add(a[i]);
  write(ans), enter;
  return 0;
}
```

---

## 作者：pengyule (赞：2)

## 好一篇详细的题解！↓

说明：这篇题解虽然思路不与众不同，但是说明可谓十分详尽，即使你不会什么字典树啦、逆序对啦，看这篇题解都没有问题。

## 正文

这道题我的思路是，用**字典树代替复杂度较高的 map 实现把乱序的座位表的每一个名字变成其在正确的座位表中所在的坐标 + 归并排序求逆序对个数**。

详细解释如下。

如果你不了解字典树，请点开[我的学习笔记](https://www.luogu.com.cn/blog/hellosandy/zi-dian-shu-ru-men-xue-xi-bi-ji)，看了你就懂了O(∩_∩)O哈哈~

在这道题中，我如果想把乱序的职员名字用他们原应该坐的地方代替，那么我们其实就是要求这个替换后的数列的逆序对个数了。怎么样做呢？就拿样例来说：
```
3
Stan Kyle Kenny
Kyle Stan Kenny
```
我们首先把 Stan,Kyle,Kenny 所对应的坐标 1,2,3 存入字典树，把原本用来标记单词结束的 $vis$ 数组中存的值改为他们对应的坐标（我们同样可以知道这个单词是否结束了，因为他们的坐标全部都是正数）。即 `vis['n'的编号]=1,` `vis['e'的编号]=2` `vis['y'的编号]=3`。所以第二排的 `Kyle Stan Kenny` 就被替换成了 `2 1 3`。

那么怎么求逆序对呢？（逆序对的意思是，如果在一个数列中前面的数大于后面的数，那么这两个数就构成了一个逆序对）最好理解的是归并排序（分治）。

把这个数列截半砍断，分成左边的一部分和右边的一部分，对左右部分分别排序，然后把两部分合并起来就得到了一个排序后的序列。对左右部分排序的过程用递归完成，递归终止就是要处理的数列他只有一个元素，我们就不用再把它分成两部分了。这是归并排序。那么我们怎么把两个排好序的数组合并起来呢？用两个变量 $i,j$ 分别指向两个数组的第一个元素；每次把 $a_i$ 和 $b_j$ 进行比较，把较小的那个数压入答案 vector 的末尾，并且：如果 $a_i<b_j$，那么 $i$ 往后挪，反之，$j$ 往后挪。最后，我们再把数组中剩下的元素全部压入答案 vector 中。（更详细的解释点击[这里](https://blog.csdn.net/jnh2004/article/details/82051817)）

在这个过程中，我们知道，$a$ 数组是下标在前面一段的，$b$ 则是后面一段，那么 $a$ 中如果有一个数 $a_u$ 比 $b_v$ 大，那么 $a$ 中 $a_u$ 以及它后面的数都可以与 $b_v$ 构成逆序对，于是我们逆序对的个数就加上 `u → a数组的末尾` 元素的个数。

下面放上完整代码，由于十分易懂，故未加注释。**注意，逆序对的个数可能达到 $C_n^2=\frac{n(n-1)}{2}$，几乎达到 int 的边界！所以要开 long long！**
```
#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vei;
#define pb push_back
int cnt=1;
int trie[500005][60];
int vis[500005];
inline void Insert(string s,int idx){
    int root=1,len=s.length(),x;
    for(int i=0;i<len;i++){
        x=s[i]-'a'+1;
        if(!trie[root][x]) trie[root][x]=++cnt;
        root=trie[root][x];
    }
    vis[root]=idx;
}
inline int Find(string s){
    int root=1,len=s.length(),x;
    for(int i=0;i<len;i++){
        x=s[i]-'a'+1;
        root=trie[root][x];
    }
    return vis[root];
}
long long ans=0;
vei Merge(vei al,vei ar){
    int i=0,j=0,x=al.size(),y=ar.size();
    vei res;
    while(i<x && j<y){
        if(al[i]>ar[j]) ans+=x-i;
        if(al[i]<ar[j]) res.pb(al[i++]);
        else res.pb(ar[j++]);
    }
    while(i<x) res.pb(al[i++]);
    while(j<y) res.pb(ar[j++]);
    return res;
}
vei Sort(vei a){
    if(a.size()==1) return a;
    vei al,ar;
    int mid=a.size()/2;
    for(int i=0;i<mid;i++) al.pb(a[i]);
    for(int i=mid;i<a.size();i++) ar.pb(a[i]);
    al=Sort(al),ar=Sort(ar);
    return Merge(al,ar);
}
vei a; string str;
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>str,Insert(str,i);
    for(int i=1;i<=n;i++) cin>>str,a.pb(Find(str));
	a=Sort(a);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：hekaiyu (赞：1)

# [题目](https://www.luogu.com.cn/problem/P5149)
说白了其实就是求逆序对，只不过这个逆序对编号变成了字符 。

这题蓝色难度似乎评的有点高（可能和trie树的应用有关）。 

但本人不会map ，也初学trie树 。这题其实没必要使用这些 。

于是就便使用 $sort+$ 归并排序 ，用类似线段树的递归来解决 。（这个标签可以加）

其实本题基于这么一道[黄题](https://www.luogu.com.cn/problem/P1908)


------------


先来说说如何处理有多少的逆序对吧。

首先想象其是一棵线段树 ，从叶子结点向上做归并排序 。从而保证了在处理父子结点时，两端的子序列是有序的 ，之后再往上进行归并排序 。

如何记算区间序列的逆序对个数呢？

1. 显然儿子节点的逆序对在父子结点一定存在 。 
2. 在经行归并排序时 ，如果右侧结点要加入队列那么它一定会小于所以在左侧序列剩下的元素 。

结合代码理解文字是好习惯（就和读题看样例一样）

```
void ans(int l,int r){
	int mid=(l+r)/2;int head1=l,head2=mid+1,num=l;//head1左侧序列开头，head2右侧序列开头，num辅助序列开头
	if(l==r)return ;//只有一个元素肯定没逆序对
	ans(l,mid);ans(mid+1,r);//优先处理子节点
	while(head1<=mid&&head2<=r){//此步做归并排序
		if(x[head1]<=x[head2])y[num++]=x[head1++];
		else {
			y[num++]=x[head2++];
			k+=(long long)mid-head1+1;//加上左侧序列剩下元素个数
		}
	}
	while(head1<=mid)y[num++]=x[head1++];
	while(head2<=r)y[num++]=x[head2++];
	for(int i=l;i<=r;i++)x[i]=y[i]; //更新序列，要记得
}
```
于是我们已经处理完黄题了

对于这题我们如何转换呢？

使用结构体记录名称和位置 ，然后按字典序排序 。
```
int cmp(ss a,ss b){
	int l=strlen(a.a),r=strlen(b.a);
	if(l!=r)return strlen(a.a)<strlen(b.a);
	for(int i=0;i<l;i++)
    	if(a.a[i]!=b.a[i])return a.a[i]<b.a[i]; 
}
```
- 对于第二行输入可以认为是大小；
- 对于第三行输入可以认为是该大小的位置

因为经过排序且具有唯一性所以存在对应性 。

给出参考代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+2; 
struct ss{
	int lie;//位置
	char a[6];//名字
}st[maxn*2];
int x[maxn*2],y[maxn*2];long long k=0;//y为辅助队列
int cmp(ss a,ss b){
	int l=strlen(a.a),r=strlen(b.a);
	if(l!=r)return strlen(a.a)<strlen(b.a);
	for(int i=0;i<l;i++)
    	if(a.a[i]!=b.a[i])return a.a[i]<b.a[i]; 
}
oid ans(int l,int r){
	int mid=(l+r)/2;int head1=l,head2=mid+1,num=l;//head1左侧序列开头，head2右侧序列开头，num辅助序列开头
	if(l==r)return ;//只有一个元素肯定没逆序对
	ans(l,mid);ans(mid+1,r);//优先处理子节点
	while(head1<=mid&&head2<=r){//此步做归并排序
		if(x[head1]<=x[head2])y[num++]=x[head1++];
		else {
			y[num++]=x[head2++];
			k+=(long long)mid-head1+1;//加上左侧序列剩下元素个数
		}
	}
	while(head1<=mid)y[num++]=x[head1++];
	while(head2<=r)y[num++]=x[head2++];
	for(int i=l;i<=r;i++)x[i]=y[i]; //更新序列，要记得处理x哦
}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n*2;i++)	{
    	scanf(" %s",&st[i].a);
		st[i].lie=i;
		if(i>n) st[i].lie=i-n;	//统计位置
	}
	sort(st+1,st+n+1,cmp);
	sort(st+n+1,st+n*2+1,cmp);
	for(int i=1;i<=n;i++)x[st[i+n].lie]=st[i].lie;//转换处理
	ans(1,n);
	printf("%lld",k);//开long long
	return 0;
}
```
时间复杂度 $O(n\log{n}\times$ 名字长度 
$)$ 

~~成功拉低题目难度~~

记得点赞评论供我修改 （~~本人十分水~~）。
有疑问也可以提出。

---

## 作者：桑树下的邂逅 (赞：1)

### 首先这题显然是要求逆序对的个数，
对于一个i，我们要求出i+1到n中原本在i左边的人的个数；

这样我们将读入的名字编号为1-n,i的编号记为a[i]，用map轻松实现，然后对于一个i，先在树状数组中查询i+1-n中小于a[i]的数的个数，然后加入a[i]即可

~~记住要倒序加入~~
```
#include<bits/stdc++.h>
using namespace std;
map<string,int>ma;
const int maxN=100000+100;
int n,a[maxN],tr[maxN];
long long ans;
string s;
void add(int x){
	for(;x<=n;x+=x&-x) tr[x]++;
}
int query(int x){
	int ans=0;
	for(;x;x-=x&-x) ans+=tr[x];
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		cin>>s;ma[s]=i;
	}
	for(int i=1;i<=n;i++){
		cin>>s;a[i]=ma[s];
	}
	for(int i=n;i>=1;i--){
		ans+=query(a[i]-1);
		add(a[i]);
	}
	printf("%lld\n",ans);
}
```


---

## 作者：生而为人 (赞：1)

# 提供一种 48行（不压行）的做法。
##### 显然 这个是求 逆序对的 和，然而 数字 换成 了，字母，
#####  显然 我们可以hash 再 离散化，然而，STL大法好，我们直接用map 实现 离散化。 用数组的下标 存实际 的 人的 归属， 其数组 存实际的 人的位置，再跑一边 一道 黄题 归并求逆序对即可。
###### 详细细节 见 代码。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
using namespace std;
map <string,int>va;
const int N=100005;
int n;
int a[N],b[N];
string s;
long long tot;
void merge(int l,int r)// 黄色题的难度
{
	if(l==r)
	return;
	int mid=(l+r)>>1;
	merge(l,mid),merge(mid+1,r);
	int i=l,j=mid+1,cnt=l;
	while(i<=mid&&j<=r)
	{
		if(a[i]<a[j])
		b[cnt++]=a[i++];
		else
		b[cnt++]=a[j++],tot+=(mid-i+1);
	}
	while(i<=mid)
	b[cnt++]=a[i++];
	while(j<=r)
	b[cnt++]=a[j++];
	for(int i=l;i<=r;i++)
	a[i]=b[i];
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		va[s]=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		a[i]=va[s];
	}
	merge(1,n);
	cout<<tot;
}
```


---

## 作者：Hexarhy (赞：1)

恕我直言，这道题目评成蓝题有水分啊，难度黄题。


------------

## 思路：

先审题：

> 如果有一对老师$a$和$b$，他们原来的座位是$a$在$b$左边，现在变成了$a$在$b$右边，那么这一对老师便会贡献一单位不满值。

加上样例，很明显看出是要**求这个数列的逆序对**，只不过要把字符串转为数值。


------------

### 思路简单清晰，注意几个点：

- 把字符串转成数值，很简单，用哈希或者映射。C++里的STL提供`map`（映射）与`unordered_map`（哈希），pb_ds提供`hash_table`（哈希）。三种容器均可过本题。本题采用效率较高的`unordered_map`。

- 求逆序对。**直接套归并排序板子。**不赘述。

- PS：最大逆序对数量：$\large \frac{n(n-1)}{2}=4999950000\approx 5 \times 10^9 > \texttt{INT\_MAX}(\approx 2 \times 10^9)$   
**所以要开`long long`！！！**

- 时间复杂度：$O(nlogn)\approx10^7$（`unordered_map`的查找几乎为$O(1)$；插入时间复杂度不明，反正没有TLE）

评测结果如下：

![](https://cdn.luogu.com.cn/upload/pic/60300.png)

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <unordered_map>
using namespace std;
//记得开long long
const long long MAXN=1e5+5;
long long n,cnt,ans;
long long a[MAXN],t[MAXN];
unordered_map <string,long long> m;//字符串转化为数值用

void input(void)
{
	cin>>n;
	for(long long i=1;i<=n;i++)
	{
		string st;
		cin>>st;
		m[st]=++cnt;
	}
	for(long long i=1;i<=n;i++)
	{
		string st;
		cin>>st;
		a[i]=m[st];//存数值
	}
}

void merge(long long l,long long r)//套板子
{
	if(l>=r)
	 return;
	long long mid=(l+r)/2;
	merge(l,mid);
	merge(mid+1,r);
	long long i=l,j=mid+1,p=l;
	while(i<=mid && j<=r)
	 if(a[i]>a[j])
	 {
		t[p++]=a[j++];
		ans+=mid-i+1;
	 }
	 else
	  	t[p++]=a[i++];
	while(i<=mid)
	  t[p++]=a[i++];
	while(j<=r)
	  t[p++]=a[j++];
	for(i=l;i<=r;i++)
	  a[i]=t[i];
}

int main()
{
	input();
	merge(1,n);
	cout<<ans<<endl;
	return 0;
}

```
upd：不知道为什么求逆序对数量的$\LaTeX$崩了，改了一下再交一遍qaq。

---

## 作者：warrior (赞：0)

既然楼下说的都是**树状数组**的，那我就来说说怎么用**归并排序**来做本题。


首先用map处理一下每个人的名字
```cpp
map<string,int>s;

	for(int i = 1;i<=n;i++)//输入人名和他们最初被安排的位置
	{
		string a;
		cin>>a;
		s[a] = i;
	}
    
    
	for(int i = 1;i<=n;i++)//输入打乱后的位置，和表示他本应该做的位置
	{
		string a;
		cin>>a;
		b[i] = s[a];
	}
```

接下来就可以快乐的求逆序对了。

我是用归并排序求逆序对。只要在归并排序的模板上多加一个ans记录答案即可。

```cpp
void gb(int x,int y)
{
	if(x>=y)
	{
		return;
	}
	int mid = x+(y-x)/2;
	gb(x,mid);
	gb(mid+1,y);
	int temp1 = x,temp2 = mid+1,tot = 0;
	while(temp1<=mid&&temp2<=y)
	{
		if(b[temp1]>b[temp2])
		{
			c[++tot] = b[temp2];
			temp2++;
			ans+=(mid-temp1+1);//记录答案，右边temp2指向的数比左边的总共有几个数小。因为左边已经在上一层排过序了，所以这里直接记录即可。
		}
		else
		{
			c[++tot] = b[temp1];
			temp1++;
		}
	}
	while(temp1<=mid)
	{
		c[++tot] = b[temp1];
		temp1++;
	}
	while(temp2<=y)
	{
		c[++tot] = b[temp2];
		temp2++;
	}
	for(int i = 1;i<=tot;i++)
	{
		b[x+i-1] = c[i];
	}
	return;
}
```

还有一个细节就是，ans一定要开long long，最早开int居然爆掉了。


下面是完整代码
```cpp
#include <iostream>
#include <set>
#include <map> 
using namespace std;

map<string,int>s;

long long n,ans;

int b[1000100],c[1000100];

void gb(int x,int y)
{
	if(x>=y)
	{
		return;
	}
	int mid = x+(y-x)/2;
	gb(x,mid);
	gb(mid+1,y);
	int temp1 = x,temp2 = mid+1,tot = 0;
	while(temp1<=mid&&temp2<=y)
	{
		if(b[temp1]>b[temp2])
		{
			c[++tot] = b[temp2];
			temp2++;
			ans+=(mid-temp1+1);
		}
		else
		{
			c[++tot] = b[temp1];
			temp1++;
		}
	}
	while(temp1<=mid)
	{
		c[++tot] = b[temp1];
		temp1++;
	}
	while(temp2<=y)
	{
		c[++tot] = b[temp2];
		temp2++;
	}
	for(int i = 1;i<=tot;i++)
	{
		b[x+i-1] = c[i];
	}
	return;
}

int main(int argc, char *argv[])
{
	cin>>n;
	for(int i = 1;i<=n;i++)
	{
		string a;
		cin>>a;
		s[a] = i;
	}
	for(int i = 1;i<=n;i++)
	{
		string a;
		cin>>a;
		b[i] = s[a];
	}
	gb(1,n);
	cout<<ans;
	return 0;
}
```


---


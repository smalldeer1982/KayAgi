# [COCI 2009/2010 #3] RAZGOVOR

## 题目描述

可爱村只有一条长长的街道，从东向西延伸，有 $m$ 户人家。每栋房子都有一个单独的房号，从 $1$ 开始到 $m$ 结束。

最近的暴风雪摧毁了大部分电话线，所以市长出资建造了一个新的电话线。Mirko 对这个新的电话网络的普及程度很感兴趣，所以他在一些点上安装了特殊的探测器。

探测器可以检测到两栋房子之间的任何电话，一栋房子在探测器的 **东边**，一栋房子在探测器的 **西边**。

在第一个月结束时，Mirko 撤掉了所有的探测器，现在想知道在这一个月里，可能打过的电话中，**最小** 的电话数量是多少。




## 说明/提示

#### 数据规模及约定

- 对于 $50\%$ 的数据，$1 \le n \le 10^3$，$1 \le C_i \le 10^3$，$n < m \le 10^9$，$1 \le P_i < M$。
- 对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le C_i \le 10^9$，$n < m \le 10^9$，$1 \le P_i < M$。

#### 说明
翻译自 [COCI 2009-2010 #3 T4 RAZGOVOR](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 100，每个测试点 10 分，共 10 个测试点。

## 样例 #1

### 输入

```
3 4
3 1
2 2
1 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3
1 23
2 17
```

### 输出

```
23```

## 样例 #3

### 输入

```
3 9
7 2
8 3
3 4
```

### 输出

```
5```

# 题解

## 作者：Trump__Biden (赞：3)

[传送门](https://www.luogu.com.cn/problem/P7260)
------------

思路：
------------
首先，定义一个结构体：
```
struct node
{
	long long p,c;
}a[100005];
```
$ p $ 表示该探测器探测到的位置。$ c $ 表示电话总数。
将它们输入后调用 cmp 函数，即按 $ p $ 进行排序：
```
bool cmp(node x,node y)
{
	return x.p<y.p;
}
```

再定义一个数 $ s $ 并赋初值为 $ 0 $，然后进行循环。如果第 $ i $ 个探测器检测到的数量比它的上一个大，$ ans $ 加上多出的数量，将 $ s $ 的值更新，最后输出 $ ans $。

AC 代码如下：
------------
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans;//开了 long long 不会见祖宗 
struct node
{
	long long p,c;
}a[100005];//结构体 
bool cmp(node x,node y)
{
	return x.p<y.p;
}//排序 
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	  scanf("%lld%lld",&a[i].p,&a[i].c);
	sort(a+1,a+1+n,cmp);//用cmp进行排序 
	int s=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i].c>s)
		  ans+=a[i].c-s;
		s=a[i].c;//更新s的值 
	}
	printf("%lld",ans);
	return 0;//完结散花
}
```
参考了 @HarunluoON 的思路，加入了自己的想法，如有不足请 dalao 指出。

---

## 作者：fz20181223 (赞：1)

这题思路很简单。

对于每个基站，按照其位置先从小到大排序，随后从第一个开始，枚举每一个基站的数据是否比前一个大，如果大，则加上它们两个的差。

原因解释：

比如说有一些数据（按照位置顺序排好后的）： $1,2,4,3,5,6$ ，如果只看第一个，则只需要打 $1$ 次，如果算上了第二个，则因为 $2$ 被算了进去，所以我们又要再算一次 $2$ 和 $1$ 的差。

再比如，当我们算到了 $4$ 时，由于下一个是 $3$ ，所以我们完全可以忽视此次累加，而对于后面的 $5$ ，虽然前面有 $4$ ，看上去只要加一次，但由于 $4$ 和 $5$ 之间有个 $3$ ，所以能够通过这个 $3$ 的只有三个通讯，此时我们还需要另外两个通讯，而这正好是 $5$ 和 $3$ 的差。

AC 代码如下（不要抄！）
```cpp
#include<bits/stdc++.h> 
using namespace std;
typedef long long ll;
const ll err=-120712^7869^12174,N=1e5+9,M=1e9+7;
ll n,m;
map<ll,ll>dat;
vector<ll>a;
int main(){
	scanf("%lld %lld",&n,&m);
	for(ll i=0,p,c;i<n;++i){
		scanf("%lld %lld",&p,&c);
		dat[p]=c;
	}
	a.push_back(0);
	for(map<ll,ll>::iterator it=dat.begin();it!=dat.end();++it) a.push_back(it->second);//个人喜欢桶排序
	ll ans=0;
	for(int i=1;i<=n;++i) ans+=max(0ll,a[i]-a[i-1]);
	printf("%lld",ans);
	return 0;}
```
另外，还有一种分治的解法，在洛谷上开了 O2 也能过，即对于一个区间 $[l,r]$ （当然第一次处理时时从第一个基站到最后一个基站）如果 $l \neq r$ ，则先从头到尾扫一遍，然后选出最小的数据及其位置 $p$ ，将这个范围内所有的基站接收到的数据减去这个最小的数据。然后计算 $[l,p-1]$ 和 $[p+1,r]$ 这两个区间的答案，加上之前算出的最小数据。如果 $l = r$ ,则直接返回第 $l$ 个基站的数据即可。

[开了 O2 的AC结果](/record/53140820) 以及 [没开 O2 的TLE结果](/record/53143674)

---

## 作者：_qumingnan_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7260)

# 正文开始

## 阅读理解：

有 $m$ 个住户，$n$ 个探测器，第 $i$ 个探测器在位置 $a_i$，两个住户之间可以连一条线段，线段经过的探测器都会触发，现给出每个探测器的位置和触发次数，求最少能有几条线。

## 思路

不难发现，要想要线数量少，就应该每一条线能经过的探测器尽可能多。

但是如果暴力枚举，复杂度是 $O(n^2)$，会超时，需要简化。

![](https://cdn.luogu.com.cn/upload/image_hosting/7bjqd16t.png)

很显然，在对位置进行排序后，探测器的触发次数是呈上图趋势，可以看成是由一个个“小山丘”组成的，单拎一个“小山丘”出来，我们能发现，这个“小山丘”的最长线数量就是在“山峰”之前的每个点与上一个点的高度差之和。把这个发现应用到每一个“小山丘”上，这个问题就解决了。

## 代码：

代码也非常好写，如果这个点大于前一个点，就把这个点减去上一个点的值统计到答案中。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
struct node{int x,s;}a[1005];//x是位置，s是值 
inline bool cmp(node p,node q){return p.x<q.x;}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].s;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
		if(a[i].s>a[i-1].s)ans+=a[i].s-a[i-1].s;
	cout<<ans;
	return 0;
}
```

---

## 作者：WaterSun (赞：0)

# 思路

一道简单贪心，我们只需要使每一次电话的距离尽可能的长即可。

那么我们想一想，如果一个点的通话次数如果大于左边一个点的通话次数，那么，在最好的情况下，它的代价是当前点的通话次数减去左边一个点的通话次数。

因此，我们可以先对原数据以 $p$ 为标准先排个序，再来求答案即可。

# code

```cpp
#include <bits/stdc++.h>
#define int long long
#define re register

using namespace std;

const int N = 1e5 + 10;
int n,m,ans;

struct node{
	int p;
	int c;
	bool operator <(const node &t) const{//排序规则 
		return p < t.p;
	}
}arr[N];

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

signed main(){
	n = read();
	m = read();
	for (re int i = 1;i <= n;i++){
		arr[i].p = read();
		arr[i].c = read();
	}
	sort(arr + 1,arr + 1 + n);//排序 
	for (re int i = 1;i <= n;i++){
		if (arr[i].c >= arr[i - 1].c) ans += (arr[i].c - arr[i - 1].c);//累加答案 
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：HarunluoON (赞：0)

## 题意简述

有一条有 $m$ 个节点的线段，某两个节点之间有一个探测器，总数为 $n$ 个。

如果两个节点的通话经过了一个探测器，那么这个探测器的计数就会加 $1$。

现在给定每个探测器的位置和计数，求可能通话数量的最小值。

## 思路

![](https://cdn.luogu.com.cn/upload/image_hosting/qs71zmt2.png)

这是样例#1的解释图。其中，圆形表示一个房屋（节点），箭头表示一个探测器，青色的弧线表示一次通话。

在这张图中，如果认为 $1$，$2$ 节点、$3$，$4$节点之间各有 $1$ 次通话；$2$、$3$ 节点之间有 $2$ 次通话，同样可以得到样例输入中的每个探测器状态，但是这种方案总共有 $4$ 次通话。因此，**在探测器计数不变的情况下，如果一次通话可以尽量被更多的探测器探测到，那么通话数量会更少。**

所以，在从西（左）往东（右）遍历的情况下，我们只需要算出“弧线”的左端点的数量就可以得出答案了。这个数字可以这样求出来：

```cpp
p=0;
for(int i=1;i<=n;i++)
{
	if(c[i]>p)
	ans+=(c[i]-p);
	p=c[i];
}
```

其中的 $p$ 便是这个数字。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct sensor
{
	int p,c;
} s[100001];//使用了结构体存储每一个探测器的状态
bool comps(sensor x,sensor y)
{
	return x.p<y.p;//按照位置从西（左）到东（右）排列
}
int main()
{
	int n,m,p=0;
	long long ans=0;//答案可以达到 5*10^13，所以不开 long long 见祖宗
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&s[i].p,&s[i].c);
	s[0].p=s[0].c=0;
	sort(s+1,s+n+1,comps);
	for(int i=1;i<=n;i++)
	{
		if(s[i].c>p)
		ans+=(s[i].c-p);
		p=s[i].c;
	}
	printf("%ld",ans);
	return 0;
}
```

---


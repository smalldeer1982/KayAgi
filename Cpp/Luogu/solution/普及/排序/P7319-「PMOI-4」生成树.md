# 「PMOI-4」生成树

## 题目背景

> 题目正解不会很难，反正很难的也必不会做，所以宁愿相信题目都是善良的。

——command_block 《考前小贴士》

djy 出了一道生成树的题，然后发现做法假了，就把这个题改了一下，作为这场比赛的 B。

## 题目描述

给定 $n$ 个数，第 $i$ 个数的原始权值是 $w_i$，你要按照某种顺序将这些数依次选择。

若当前是第 $i$ 次选数，选择的**原始权值**为 $k$，则其他所有**未被选过**的数的权值均加上 $(-1)^{i+k+1} \times k$。

你需要求出一种选数方案，使得选出的 $n$ 个数**最终**的**权值**和**最大**。

## 说明/提示

【样例解释】

依次选择**编号**为 $\{7,6,5,3,4,1,2\}$ 的数即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n \le 7$。
- Subtask 2（30pts）：$n \le  10^3$。
- Subtask 3（30pts）：保证所有的 $w_i \ge 0$ 或所有的 $w_i \le 0$。
- Subtask 4（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le n \le 10^5,-10^9 \le w \le 10^9$。

## 样例 #1

### 输入

```
7
1 -1 -2 2 -3 3 4```

### 输出

```
66```

# 题解

## 作者：Suzt_ilymtics (赞：23)

## 写在前面

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/15168836.html)

贪心去构造这个排列比较显然，但感觉我的实现挺有趣的。

## Description

[题目传送](https://www.luogu.com.cn/problem/P7841)。

## Solution

Subtask1 显然是枚举全排列模拟整个操作，不在多说。

其他 Subtask 没细看。

发现那个 $k$ 始终都是原始序列的值，修改的权值可以直接算进答案里。

所以第 $i$ 次操作对整个答案的贡献就是 $(n-i) \times (-1)^{k+i+1} \times k$。

贪心其实很好想。

为了让每个元素尽可能做出正贡献，我们要把**正偶数负奇数**放在奇数位，把**正奇数负偶数**放在偶数位，并且绝对值大的往前放。

显然我们可以把两类数拆开排序后模拟的放进去。需要特殊处理的是一类比另一类多的情况。

但这里有一个更简单的写法不用特殊处理。

我们把**正偶数负奇数**排在**正奇数负偶数**前面，对于正偶负奇内部按照绝对值从大到小排序，对于正奇负偶内部按照绝对值从小到大排序。

然后我们先填左边在填右边，这样交替填，刚好能满足正确的顺序。

并且我们通过这个顺序可以直接计算出答案。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 2e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int n, Ans = 0;
int a[MAXN];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

bool cmp(int x, int y) {
    if((x >= 0 && !(x & 1)) || (x < 0 && (x & 1))) {
        if((y >= 0 && !(y & 1)) || (y < 0 && (y & 1))) {
            return abs(x) > abs(y);
        } else {
            return true;
        }
    } else {
        if((y >= 0 && !(y & 1)) || (y < 0 && (y & 1))) {
            return false;
        } else {
            return abs(x) < abs(y);
        }
    }
}

signed main()
{
    n = read();
    for(int i = 1; i <= n; ++i) a[i] = read();
    sort(a + 1, a + n + 1, cmp);
//    for(int i = 1; i <= n; ++i) cout<<a[i]<<" "; puts("");
    for(int i = 1; i <= n; ++i) Ans += a[i];
    for(int i = 1, v = 1, l = 1, r = n; i <= n; ++i, v ^= 1) {
        if(v) {
            if((a[l] + i + 1) & 1) {
                Ans -= (n - i) * a[l];
            } else {
                Ans += (n - i) * a[l];
            }
            l++;
        } else {
            if((a[r] + i + 1) & 1) {
                Ans -= (n - i) * a[r];
            } else {
                Ans += (n - i) * a[r];
            }
            r--;
        }
    }
    printf("%lld", Ans);
    return 0;
}
```

---

## 作者：lgswdn_SA (赞：20)

思路简单，代码简单，没有任何分类讨论。

考虑把它拆成贡献，第 $i$ 次对整个答案的贡献为。

$$
(n-i)\times (-1)^{k+i+1}\times k
$$

拆一下发现即求一下式子的最大值。

$$
\sum ((-1)^{i+1}(n-i)) \times ((-1)^{k_i}k_i)
$$

设两个数组 $f_i=(-1)^{k_i}k_i$，$g_i=(-1)^{i+1}(n-i)$，其实就是求一个排列使得 $\sum f_ig_i$ 最大。用排序不等式可以得到 $f,g$ 都顺序排序后的 $\sum f_ig_i$ 最大。

```cpp
int n,ans;
vector<int>f,g;

signed main() {
	n=read(); f.resize(n), g.resize(n);
	rep(i,1,n) {
		int w=read(); ans+=w;
		w=w*(w%2?-1:1); f[i-1]=w;
		if((i+1)%2) g[i-1]=-(n-i);
		else g[i-1]=n-i;
	}
	sort(f.begin(),f.end()), sort(g.begin(),g.end());
	rep(i,0,n-1) ans+=f[i]*g[i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Acc_Robin (赞：12)

一道有意思的题目，不过评黄色有点可惜了。

### 相较于其它题解更简明的做法：

题目要求我们所做的就是找到一个排列 $p$ 来最大化下式：

$$
\sum_{i=1}^n(n-i)\cdot (-1)^{i+w_{p_i}+1}\cdot w_{p_i}
$$

这个式子的含义就是第 $i$ 个数字对剩下 $n-i$ 个数字各产生 $(-1)^{i+w_{p_i}+1}\cdot w_{p_i}$ 的贡献。

不够明显，我们把 $i$ 和 $w$ 分开来，就有

$$
\sum_{i=1}^n((n-i)\cdot (-1)^i)\times ((-1)^{w_{p_i+1}}\cdot w_{p_i})
$$

注意到了吗？上式相当于两个序列 $\{a_i=(-1)^{i}(n-i)\}$ 和 $\{b_i=(-1)^{w_{p_i}+1}\cdot w_i\}$ 一一相乘再相加的和，只不过我们不知道一一对应的关系。

到这里你应该明白了，著名的 **排序不等式** ：

$$
\text{逆序和} \le \text{乱序和} \le \text{顺序和}
$$

那么我们只需要将这两个序列分别排序并一一对应相乘再相加即可。

不要忘了加上初始序列的和。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Acc{
	using ll=long long;
	const int N=1e5+9;
	int a[N],b[N];
	ll r;
	void work(){
		int n,i,sav=1;
		for(cin>>n,i=1;i<=n;++i)cin>>a[i],r+=a[i],a[i]=a[i]*(abs(a[i]%2)==1?1:-1);
		for(sav=-1,i=1;i<=n;++i,sav=-sav)b[i]=(n-i)*sav;
		sort(a+1,a+n+1),sort(b+1,b+n+1);
		for(i=1;i<=n;++i)r+=1ll*a[i]*b[i];
		cout<<r<<'\n';
	}
}
int main(){return Acc::work(),0;}
```

---

## 作者：lndjy (赞：10)

### 出题人官方题解

一个数在 $i$ 为奇数时被选对答案的贡献越大，在 $i$ 为偶数时对答案的贡献越小。

考虑按照某种方式排序，在 $i$ 为奇数和偶数时从两端贪心选择。

这里让 $i$ 为奇数时从前往后贪心，$i$ 为偶数时从后往前贪心。

直接分类讨论比较太麻烦，设 $d(x)$ 为 $x$ 的正负性（正 $1$ 负 $-1$），$f(x)$ 为 $x$ 的奇偶性。（偶 $1$ 奇 $-1$）

当 $d(x)\times f(x)$ 为 $1$ 时，对答案的贡献为正数，否则为负数。

按照 $d(x) \times f(x)$ 为第一关键字，数字的绝对值为第二关键字排序即可。

对后面的数的加法没必要一个一个加，用一个变量保存当前累加的即可。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
const int N=3e5+5;
int w[N],n,m,v[N];
int d(int x){return x>0?1:-1;}
int f(int x){return x%2==0?1:-1;}
int abs(int x){return x>0?x:-x;}
bool cmp(int x,int y)
{
	if(d(x)*f(x)!=d(y)*f(y)) return d(x)*f(x)>d(y)*f(y);
	if(d(x)*f(x)==1) return abs(x)>abs(y);
	return abs(x)<abs(y);
}
int main()
{
	n=read(),m=n;
	for(int i=1;i<=m;i++)
	w[i]=read();
	sort(w+1,w+m+1,cmp);
	int l=1,r=m;
	long long ans=0,sum=0;
	for(int i=1;i<=n;i++)
	{
		if(i&1)
		{
			v[l]=1;
			ans+=w[l++]+sum;
			sum-=w[l-1]*f(i+w[l-1]);
		}
		else
		{
			v[r]=1;
			ans+=w[r--]+sum;
			sum-=w[r+1]*f(i+w[r+1]);
		}
	}
	cout<<ans;
 	return 0;
}
```


---

## 作者：cancan123456 (赞：8)

主要思路：贪心。

我们假设当前是第 $i$ 次取数，取的数是 $k$，分情况讨论：

1. $i$ 是奇数，$k$ 是奇数，那么 $(-1)^{i+k+1}\times k=-k$，需要最小化 $k$。

2. $i$ 是奇数，$k$ 是偶数，那么 $(-1)^{i+k+1}\times k=k$，需要最大化 $k$。

3. $i$ 是偶数，$k$ 是奇数，那么 $(-1)^{i+k+1}\times k=k$，需要最大化 $k$。

4. $i$ 是偶数，$k$ 是偶数，那么 $(-1)^{i+k+1}\times k=-k$，需要最小化 $k$。

具体做法：
把输入的奇数和偶数分开并排序，然后每次根据 $i$ 的奇偶性来取两个数，判断哪个数对答案的贡献大，把答案加上 $(n-i)\times(-1)^{i+k+1}\times k$ 就行了。

代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define maxn 100005
int oddw[maxn], evenw[maxn];
int oddl = 1, oddr = 0, evenl = 1, evenr = 0;
void output() {
	printf("[%d, %d]:\n", oddl, oddr);
	for (int i = oddl; i <= oddr; i++) {
		printf("%d\n", oddw[i]);
	}
	printf("[%d, %d]:\n", evenl, evenr);
	for (int i = evenl; i <= evenr; i++) {
		printf("%d\n", evenw[i]);
	}
}
int main() {
	long long ans = 0;
	int n;
	scanf("%d", &n);
	for (int wi, i = 1; i <= n; i++) {
		scanf("%d", &wi);
		ans += wi;
		if (wi % 2 == 0) {
			evenw[++evenr] = wi;
		} else {
			oddw[++oddr] = wi;
		}
	}
	sort(oddw + oddl, oddw + oddr + 1);
	sort(evenw + evenl, evenw + evenr + 1);
	for (int i = 1; i <= n; i++) {
		int c1, c2;
		bool flag1 = false, flag2 = false;
		if (i % 2 == 1) {
			if (oddl <= oddr) {
				flag1 = true;
				c1 = -oddw[oddl];
			}
			if (evenl <= evenr) {
				flag2 = true;
				c2 = evenw[evenr];
			}
			if (not flag1) {
				ans += 1LL * c2 * (n - i);
				evenr--;
			} else if (not flag2) {
				ans += 1LL * c1 * (n - i);
				oddl++;
			} else {
				if (c1 > c2) {
					ans += 1LL * c1 * (n - i);
					oddl++;
				} else {
					ans += 1LL * c2 * (n - i);
					evenr--;
				}
			}
		} else {
			if (oddl <= oddr) {
				flag1 = true;
				c1 = oddw[oddr];
			}
			if (evenl <= evenr) {
				flag2 = true;
				c2 = -evenw[evenl];
			}
			if (not flag1) {
				ans += 1LL * c2 * (n - i);
				evenl++;
			} else if (not flag2) {
				ans += 1LL * c1 * (n - i);
				oddr--;
			} else {
				if (c1 > c2) {
					ans += 1LL * c1 * (n - i);
					oddr--;
				} else {
					ans += 1LL * c2 * (n - i);
					evenl++;
				}
			}
		}
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：FishZe (赞：4)


在比赛的时候，想的方法比较憨，两个队列模拟的，感兴趣的同学可以[点击这里](https://www.luogu.com.cn/paste/xaqd4ayp)。感谢大佬[@Zhukov](https://www.luogu.com.cn/user/342383)提出了优化方案，按照他的思路我又进行了优化，才有了如今的代码。



------------

- ### 核心信息：

若当前是第 $ i $ 次选数，选择的原始权值为 $ k $，

则其他所有未被选过的数的权值均加上 $ (-1)^{i + k + 1} \times k $ 

求出一种选数方案，使得选出的 $ n $ 个数最终的权值和最大。


------------

- ###  get 到的信息：

1. 这道题似乎是一道排序题。

2. 当前所选数经过计算后的权值会对后面的数“产生影响”。
    

如果当前选择的是第 $ i $ 个数字，那么他后面的 $ (n - i) $  个数字全都加上一个值，但是他更改的不是原始权值，既然他更改的不是原始权值，那么又跟后面的数字有什么关系呢？

也就是说，当前选择的数字对后面数字的选择并没有影响，我们便可以直接记录更改，而不是把这个更改传递到后面的数字中。

按照上面的推理，选择权值为 $ k $ 的数字，相当于在答案中再加上  $  (-1)^{i + k + 1} \times k  \times (n - i)  $ 。

而  $ (n - i) $  是递减的，所以我们要让 $ (-1)^{i + k + 1} \times k $ 大的数字往前放，这样可以保证答案尽可能大。

这样一来，问题成功的转化成了一个排序问题，关键是这个序该怎么排。




3. 加上的权值中有“ $ -1 $ ”


看到 $ -1 $ ，学过初中数学的同学都知道，指数肯定会影响这个值的正负。

上过小学的同学都知道，负负得正，所以我们要尽量让负数和负数配对，正数和正数配对，这样可以获得尽可能多的正数。以获得尽可能大的答案。

这里我们分类讨论：

![](https://web-files-1257015149.file.myqcloud.com/img/pic/luogu/p7841-1.png)

轮到每一个 $ i $ 的时候，只需要在剩余的 $ k $ 中，选择最适合自己的。


当 $ i $ 为奇数时，按照上面的表格，我们需要一个负的奇数，或者一个正的偶数，由于要求整体的乘积尽量大，所以我们需要选择绝对值最大的负奇数或正偶数。

当 $ i $ 为偶数时，我们需要一个正的奇数，或者一个负的偶数，同理， 我们需要选择绝对值最大的。

还有一个需要考虑的问题，如果选着选着，对于当前 $ i $ ，已经没有满意的 $ k $ 可以选择了，那么为了减少损失，我们只能从剩下的 $ k $ 中选择绝对值最小的了，可以让乘积减的最少！




思路大概就是这样，同学们可以先按照蒟蒻我的思路写。




------------


- ### 代码实现

由于需要奇数和偶数分开，这里我们考虑两个不同的队列，一个是适合奇数 $ i $ 的，一个是适合偶数 $ i $ 的。

刚开始我真的用了两个优先队列，多亏大佬提醒，修改成了更优化的方案。

为了方便表示，我们定义奇数 $ i $ 选择的负奇数和正偶数为 $  true $ ，也就是 $ i $ 对 2 取模的值，这样下面会方便表示。

同理，把偶数 $ i $ 喜欢的正奇数和负偶数表示为 $ false $ 。






```cpp
bool type(int x){
    return (x < 0 && x % 2) || (x >= 0 && !(x % 2));
}

```





然后我们用两个数组来表示两个队列，分别储存类型为 $ true $   和类型为 $ false $ 的 $ k $ 值。并且用 $ cnt [ 2 ] $ 来储存两个数组中数字的个数。

输入时，判断 $ k $ 值的类型，储存进入该类型的数组即可。

我为了方便写代码，直接定义的是 $ l [ 2 ] [ MAXN ] $ ，只要把 $ k $ 的类型带入第一维就可以，很方便。





```cpp
scanf("%d", &n);
    for(int i = 1, tmp; i <= n; i++){
        scanf("%d", &tmp);
        ans += (LL)tmp;
        l[type(tmp)][++ cnt[type(tmp)]] = abs(tmp);
    }
```







注意到我这里储存的是 $ k $ 的绝对值，这是因为对于该类型的 $ i $ 来说，访问到中意的 $ k $ 值，乘积的结果一定是正的。

下面我们需要进行排序，没什么好说的，降序排序，让绝对值更大的i放在前面。


![](https://web-files-1257015149.file.myqcloud.com/img/pic/luogu/p7841-2.png)


重点来了，开始选择，对于每一个 $ i $ ， 从自己的类型中选择最大的即可，由于是有序的数组，所以可以通过 $ i $ 计算出最满意的 $ k $ 在数组中的哪个位置，即 $ ((i + 1) / 2) $ ，可能稍微有点难以理解，举个栗子。

比如 $ i $ 为 $ 1 $ 时，适合的 $ k $ 一定在类型 $ 1 $ 的第 $ 1 $ 个位置。

比如 $ i $ 为 $ 2 $ 时，适合的 $ k $ 一定在类型 $ 0 $ 的第  $ 1 $ 个位置。

同理， $ 3 $ 对应类型 $ 1 $ 的 $ 2 $  位置， $ 4 $ 对应类型 $ 0 $ 的 $ 2 $  位置。就不多举例子了。






```cpp
for(int i = 1; i < n; i++){
    ans += (LL)(n - i) * (LL)l[i % 2][(i + 1) >> 1];
}
```





但是我们还忽略了一个重要的问题，就是如果当前的 $ i $ 已经没有满意的 $ k $ 了怎么办，就只能强制安排一个他不满意的 $ k $ 将就了，为了止损，我们需要选择另一类型中，绝对值最小的   $ k $ 。

可能有的小伙伴会问，抢了另一类型 $ i $ 适合的 $ k $ ，会不会导致另一类型的 $ i $ 不够选？这一点不用担心，因为 $ cnt_0 + cnt_1 = n $ 是一定成立的，所以一定可以人人配对。






```cpp
for(int i = 1; i < n; i++){
    if(cnt[i % 2] < ((i + 1) >> 1)){
        ans -= (LL)(n - i) * (LL)l[!(i % 2)][n - ((i + 1) >> 1) + 1];
    } else {
        ans += (LL)(n - i) * (LL)l[i % 2][(i + 1) >> 1];
    }
}
```






下面证明第三行的这个式子是怎么来的。

既然要减，减去的一定是从另一类型的数列中倒着数的，第一个要减的就选择倒数第一个，第二个要减的就选择倒数第二个，所以，第 $ x $ 要减的选择倒数第 $ x $ 个。

可以参考下面这张图片帮助思考。

![](https://web-files-1257015149.file.myqcloud.com/img/pic/luogu/p7841-3.png)



以下是全部代码：






```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;

#define abs(x) x >= 0 ? x : -x;

typedef long long LL;

const int MAXN = 1e5 + 10;

int n;
int l[2][MAXN], cnt[2] = {0, 0};
LL ans = 0;

bool cmp(int x, int y){
    return x > y;
}

bool type(int x){
    return (x < 0 && x % 2) || (x >= 0 && !(x % 2));
}

int main(){
    scanf("%d", &n);
    for(int i = 1, tmp; i <= n; i++){
        scanf("%d", &tmp);
        ans += (LL)tmp;
        l[type(tmp)][++ cnt[type(tmp)]] = abs(tmp);
    }
    sort(l[0] + 1, l[0] + cnt[0] + 1, cmp);
    sort(l[1] + 1, l[1] + cnt[1] + 1, cmp);
    for(int i = 1; i < n; i++){
        if(cnt[i % 2] < ((i + 1) >> 1)){
            ans -= (LL)(n - i) * (LL)l[!(i % 2)][n - ((i + 1) >> 1) + 1];
        } else {
            ans += (LL)(n - i) * (LL)l[i % 2][(i + 1) >> 1];
        }
    }
    cout << ans;
    return 0;
}
```





---

## 作者：Cry_For_theMoon (赞：2)

[传送门](https://www.luogu.com.cn/problem/P7841)

只是黄题...

#### 分析：

你发现最后每个 $w$ 都会被算进答案，唯一影响答案的是 $\sum_{i=1}^{n}sum_i$，其中 $sum_i$ 是加入第 $i$ 个数前，前面 $i-1$ 个数为后面所有数增加的值。我们考虑最大化这个东西。

首先有个经典问题，就是考虑每个数对后面的影响和它是第几次被选择的无关。那么显然我们设它会对后面数增加 $k$，按照 $k$ 降序排序去选择就行了。

回到这题，我们发现一个数对后面的影响是只取决于它被选择轮数的奇偶性，我们分成两类，第一类是奇数轮选择对答案贡献为正，第二类是偶数类选择对答案贡献非负。对这两类分别按照 **绝对值** 降序排序。然后轮流选择，从奇数类开始。知道有一类为空。

然后剩下所有的都是同类的，维护两个指针，如果当前轮数这一类的数都会贡献正的影响，我们选择大的那个指针，否则选择小的。

时间复杂度 $O(n \log n)$。

```
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define next Cry_For_theMoon
#define il inline
#define pb(x) push_back(x)
#define is(x) insert(x)
#define sit set<int>::iterator
#define mapit map<int,int>::iterator
#define pi pair<int,int>
#define ppi pair<int,pi>
#define pp pair<pi,pi>
#define fr first
#define se second
#define vit vector<int>::iterator
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef double db;
using namespace std;
const int MAXN=1e5+10;
struct Number{
	ll val,row,type;
	bool operator<(const Number& n2)const{
		return val>n2.val;
	}
}a[MAXN],b[MAXN];
ll n,w,t1,t2,ans,sum;
void solve(Number* a,int begin,int end,int rd){
	if(begin>end)return;
	int L=begin,R=end;
	while(L<=R){
		if((odd(rd)) == a[L].type){
			//加法环节 
			ans+=(sum+a[L].row);
			sum+=a[L].val;
			L++;
		}else{
			//减法环节 
			ans+=(sum+a[R].row);
			sum-=a[R].val;
			R--;
		}
		rd++;
	}
}
int main(){
	cin>>n;
	rep(i,1,n){
		cin>>w;
		ll tmp=w;
		//计算奇数的时候的值 
		if((odd(abs(2+w)))==1)w=-w;
		if(w>0){
			a[++t1]=(Number){abs(w),tmp,1};
		}else{
			b[++t2]=(Number){abs(w),tmp,0};
		}
	}
	sort(a+1,a+1+t1);
	sort(b+1,b+1+t2);
	ll L=1,R=1,cnt=1;
	while(1){
		if(L>t1)break;
		ans=(ans+sum+a[L].row);	
		sum+=a[L].val;
		L++;
		cnt++;
		if(R>t2)break;
		ans=(ans+sum+b[R].row);
		sum+=b[R].val;
		R++;
		cnt++;
	}
	solve(a,L,t1,cnt);
	solve(b,R,t2,cnt);
	cout<<ans;
	
	return 0;
}

```

---

## 作者：Cripple_Abyss (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P7841)

## Solution :
- 第 $i$ 次选数对答案的贡献为 $k + (-1)^{i+k+1} \times k \ \times (n-i)$

- 将 $w$ 数组的值分为奇偶两部分。

- 第 $i$ 次选数在最小奇数，最大奇数，最小偶数，最大偶数里面找到一个对答案贡献最大的值。

## Code：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
inline void in(ll &x) {
	x=0;
	ll f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=f;
}
inline void out(ll x) {
	if (x<0) putchar('-'),x=-x;
	if (x>9) out(x/10);
	putchar(x%10+'0');
}
const ll N=1e5+5;
const ll oo=1e18; 
ll o[N],e[N]; // o:odd 奇数   e：even 偶数     
ll n,a[N],co,ce,now=1,maxo,maxe,mino,mine,ans,t,t1,t2,t3,t4;
// co:奇数的个数   maxo：最大奇数的下标   mino：最小奇数的下标 （偶数同理）
// t : 选数累计要加的值
ll cal(ll x,ll y) {
	if (y&1) return -x;
	return x;
}
int main() {
	in(n);
	for (ll i=1; i<=n; ++i) in(a[i]),ans+=a[i];
	for (ll i=1; i<=n; ++i) 
		if (a[i]%2) o[++co]=a[i];
		else e[++ce]=a[i];
	sort(e+1,e+ce+1);
	maxe=ce,mine=1;
	sort(o+1,o+co+1);
	maxo=co,mino=1;
	for (; now<=n; ++now) {
		t1=t2=t3=t4=-oo;
		if (maxe>=mine) { // 有偶数
			t1=cal(e[maxe],e[maxe]+now+1);
			if (maxe>mine) // 有不止一个偶数
				t2=cal(e[mine],e[mine]+now+1);
		}
		if (maxo>=mino) {
			t3=cal(o[maxo],o[maxo]+now+1);
			if (maxo>mino)
				t4=cal(o[mino],o[mino]+now+1);
		}
		ans+=t;
		if (t1>=t2&&t1>=t3&&t1>=t4) {
			t+=t1;
			maxe--;
		}
		else if (t2>=t1&&t2>=t3&&t2>=t4) {
			t+=t2;
			mine++;
		}
		else if (t3>=t1&&t3>=t2&&t3>=t4) {
			t+=t3;
			maxo--;
		}
		else if (t4>=t1&&t4>=t2&&t4>=t3) {
			t+=t4;
			mino++;
		}
	}
	out(ans);
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：1)

一道很好的贪心题，~~害的我做了3小时，没时间做第四题~~，思路是，将数字归为两类，第一类第奇数次选会增加正数，第二类反之。具体如下：

```cpp
//zo 表示第偶数个选增加正数，ot 表示这样的数的个数，zj、jt 反之
if(x>=0){
	if(x%2)zo[++ot]=x;
	else zj[++jt]=x;
}else{x=-x;
	if(x%2)zj[++jt]=x;
	else zo[++ot]=x;
}
```
接下来从大到小排序：

```cpp
//inline bool cmpll(const ll &a,const ll &b){
//	return a>b;
//}
sort(zo+1,zo+ot+1,cmpll);sort(zj+1,zj+jt+1,cmpll);
```

然后分类讨论，分三种情况：

1. $jt>ot+1$ 即不能让 需要奇数的数字全部满足，那么应先让增加数大的数字先满足，增加数小的同时减少的也更小，代码如下：
```cpp
if(jt>ot+1){
	for(i=1,j=n-2;i<=ot;j-=2,++i)ans+=zo[i]*j;x=(n+1)>>1;
	for(i=1,j=n-1;i<=x;j-=2,++i)ans+=zj[i]*j;
	for(i=x+1,j=n%2;i<=jt;j+=2,++i)ans-=zj[i]*j;
}
```
2. $ot>jt$ 也是同理：
```cpp
else if(ot>jt){
	for(i=1,j=n-1;i<=jt;j-=2,++i)ans+=zj[i]*j;x=n>>1;
	for(i=1,j=n-2;i<=x;j-=2,++i)ans+=zo[i]*j;
	for(i=x+1,j=!(n%2);i<=ot;j+=2,++i)ans-=zo[i]*j;
}
```
3. 两者都能满足，就直接加（还是大数优先）：
```cpp
else{
	for(i=1;i<=n;i+=2)ans+=zj[(i+1)>>1]*(n-i);
	for(i=2;i<=n;i+=2)ans+=zo[i>>1]*(n-i);
}
```
综上，考场 AC 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const ll N=1e5+5;
inline ll read(){
	ll an=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-')f=-f,c=getchar();
	while(c>='0'&&c<='9')an=an*10+c-'0',c=getchar();
	return an*f;
}
inline bool cmpll(const ll &a,const ll &b){
	return a>b;
}
ll zo[N],zj[N],ot,jt,et,ans,x,y;
int main(){
	register ll i,x,j;ll n=read();
	for(i=1;i<=n;++i){
		ans+=(x=read());
		if(x>=0){
			if(x%2)zo[++ot]=x;
			else zj[++jt]=x;
		}else{x=-x;
			if(x%2)zj[++jt]=x;
			else zo[++ot]=x;
		}
	}
	sort(zo+1,zo+ot+1,cmpll);sort(zj+1,zj+jt+1,cmpll);
	if(jt>ot+1){
		for(i=1,j=n-2;i<=ot;j-=2,++i)ans+=zo[i]*j;x=(n+1)>>1;
		for(i=1,j=n-1;i<=x;j-=2,++i)ans+=zj[i]*j;
		for(i=x+1,j=n%2;i<=jt;j+=2,++i)ans-=zj[i]*j;
	}else if(ot>jt){
		for(i=1,j=n-1;i<=jt;j-=2,++i)ans+=zj[i]*j;x=n>>1;
		for(i=1,j=n-2;i<=x;j-=2,++i)ans+=zo[i]*j;
		for(i=x+1,j=!(n%2);i<=ot;j+=2,++i)ans-=zo[i]*j;
	}else{
		for(i=1;i<=n;i+=2)ans+=zj[(i+1)>>1]*(n-i);
		for(i=2;i<=n;i+=2)ans+=zo[i>>1]*(n-i);
	}printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：ycw123 (赞：1)

### 题意
给定 $n$ 个数的原始权值 $w_i$，你要按照某种顺序将它们排序。

若第 $i$ 个数的**原始权值**为 $k$，则第 $i+1$ 到第 $n$ 个数的权值均加上 $(-1)^{i+k+1} \times k$。

你需要求出一种排序方案，使得 $n$ 个数的权值和最大。

## solution

### 理论分析

对于位置 $i$ 上的数，它的总贡献为$(n-i)(-1)^{i+k+1} \times k$

一个很明显的贪心策略就是贡献大的数放在前面。

那么对于位置 $i$ 我们如何确定应该放哪个数呢？最暴力的方法就是枚举每一个数，计算它的贡献，找出最大的。

即 

$$\max\{(-1)^{i+w_i+1} \times w_i\}$$

很显然，这样的做法是一定会超时的。我们要做的就是缩小候选数的范围，也就是找出哪些数是有可能为最优答案的，一定不可能的我们就不枚举它。

观察计算贡献的式子，不难发现候选数的奇偶和正负均会影响贡献的正负。

也就是说一共有四种组合：

	正奇数

	正偶数

	负奇数

	负偶数
    
对于 $i$ 是奇数的情况，我们要从能得到正贡献的两个组合（即正偶数和负奇数）中选绝对值更大的。

如果没有可以得到正贡献的数怎么办，此时只存在负偶数和正奇数，我们要选择绝对值最小的。

可以发现不管是否有正贡献，当 $i$ 为奇数时我们选择的都是最大的偶数和最小的奇数。

同理，我们可以推出当 $i$ 为偶数时我们选择的都是最大的奇数和最小的偶数。

所以对于每一个位置，我们只需要比较最大的奇数，最大的偶数，最小的奇数，最小的偶数就能得到最大贡献。

### 实现方法

我们在输入时将奇数和偶数分别放入两个队列中，并从小到大排序，这样每次只需取出两个队列的队头和队尾这四个数进行比较，就能确定答案。

```cpp
int js[100010];//奇数队列
int os[100010];//偶数队列
int p=1,up;//奇数队头和队尾
int q=1,down;//偶数队头和队尾
for(int i=1,w;i<=n;i++){
	cin>>w;
	if(w%2) up++,js[up]=w;
	else down++,os[down]=w;
}
//排序
sort(js+1,js+up+1);
sort(os+1,os+down+1);
```
接下来确定每一个位置上的数，要注意的是我们需要判断队列是否为空。

```cpp
for(int i=1;i<=n;i++){
	int addp=((i+js[p]+1)%2==0)?js[p]:-js[p];//最小奇数的贡献
	int addq=((i+os[q]+1)%2==0)?os[q]:-os[q];//最小偶数的贡献
	int addup=((i+js[up]+1)%2==0)?js[up]:-js[up];//最大奇数的贡献
	int adddown=((i+os[down]+1)%2==0)?os[down]:-os[down];//最大偶数的贡献
	if(p>up) addp=addup=-inf;//奇数已经取完
	if(q>down) addq=adddown=-inf;//偶数已经取完
	if(addp==max(max(max(addp,addq),addup),adddown)){
		f[i]=js[p];
		p++;
	}else if(addq==max(max(max(addp,addq),addup),adddown)){
		f[i]=os[q];
		q++;
	}else if(addup==max(max(max(addp,addq),addup),adddown)){
		f[i]=js[up];
		up--;
	}else {
		f[i]=os[down];
		down--;
	}
}
```

完成这一步后我们就得到了一个重新排好顺序的数组 $f$，按题目要求求出答案即可

```cpp
ll calc(){
	ll add=0;
	ll sum=0;
	for(int i=1;i<=n;i++){
		sum+=f[i]+add;
		add+=((i+f[i]+1)%2==0)?f[i]:-f[i];
	}
	return sum;
}
```
完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,ans;
int up,down,p=1,q=1,inf=1e9+7;
int f[100010];
int js[100010];
int os[100010];
ll calc(){
	ll add=0;
	ll sum=0;
	for(int i=1;i<=n;i++){
		sum+=f[i]+add;
		add+=((i+f[i]+1)%2==0)?f[i]:-f[i];
	}
	return sum;
}
int main(){
	cin>>n;
	for(int i=1,w;i<=n;i++){
		cin>>w;
		if(w%2) up++,js[up]=w;
		else down++,os[down]=w;
	}
	sort(js+1,js+up+1);
	sort(os+1,os+down+1);
	for(int i=1;i<=n;i++){
		int addp=((i+js[p]+1)%2==0)?js[p]:-js[p];
		int addq=((i+os[q]+1)%2==0)?os[q]:-os[q];
		int addup=((i+js[up]+1)%2==0)?js[up]:-js[up];
		int adddown=((i+os[down]+1)%2==0)?os[down]:-os[down];
		if(p>up) addp=addup=-inf;
		if(q>down) addq=adddown=-inf;
		if(addp==max(max(max(addp,addq),addup),adddown)){
			f[i]=js[p];
			p++;
		}else if(addq==max(max(max(addp,addq),addup),adddown)){
			f[i]=os[q];
			q++;
		}else if(addup==max(max(max(addp,addq),addup),adddown)){
			f[i]=js[up];
			up--;
		}else {
			f[i]=os[down];
			down--;
		}
	}
	cout<<calc();
	return 0;
}
```

---

## 作者：张晟轩 (赞：1)

似乎我的做法不太一样？第一次在 OI 中遇到能用数学竞赛知识解决的。  
### 前置知识：排序不等式  
若 $a_1\geq a_2\geq\cdots\geq a_n,b_1\geq b_2\geq\cdots\geq b_n,\{c_n\}$ 是 $\{a_n\}$ 的排列，则 $\sum_{i=1}^{n}{a_ib_i}\geq\sum_{i=1}^{n}{c_ib_i}\geq\sum_{i=1}^{n}{a_ib_{n-i+1}}$。   
具体证明方法自行百度。

## 思路：
显然，最终的权值和可化为 $\sum{a_i}+\sum{a_i(n-i)\cdot(-1)^{i+a_i+1}}$ ，其中 $\{b_n\}$ 为 $\{a_n\}$ 的排列，而 $\sum{a_i}$ 可直接计算，先不管。  
令 $b_i=a_i\cdot(-1)^{a_i},c_i=(n-i)\cdot(-1)^{i+1}$ 且将两个序列排序，则由排序不等式知： $\sum{a_i(n-i)\cdot(-1)^{i+a_i+1}}\leq\sum{b_ic_i}$ 且等号可以取等。  
所以，预处理出 $\{b_n\}$ 和 $\{c_n\}$ 再排序即可。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],b[100005];
long long ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);ans+=a[i];
		a[i]*=(a[i]%2==0)?1:-1;
		b[i]=(n-i)*((i+1)%2==0?1:-1);
	}
	sort(a+1,a+n+1);
	sort(b+1,b+1+n);
	for(int i=1;i<=n;++i) ans+=1ll*a[i]*b[i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Cocoly1990 (赞：0)

很有意思的贪心构造。

考虑第 $i$ 次选数的贡献为 $\left(n-i\right)\times\left(-1\right)^{k+i+1}\times k$.

我们可以思考分开处理上式的三个部分：
1. 对于 $\left(n-i\right)$ 显然贪心处理
2. 对于 $\left(-1\right)^{k+i+1}$ 是用于处理正负性的，那么我们这么思考。如果一个数是**负偶数或正奇数**，那么应该排在**偶数位**，如果一个数是**正偶数或负奇数**，那么应该排在**奇数位**.
3. 对于 $k$ 显然是固定的，没办法通过排列改变.

那么我们就可以分成奇数队列和偶数队列，按照上面方式入队，**排序方式应该按照绝对值从大到小**。然后一个奇数一个偶数计算贡献，利用**优先队列**实现。

但不得不去思考一个问题，就是如果一个队列都排完了，另一个队列怎么办？很显然，后面的数**有一部分**是不得不变成负数的，那我们就要**使负贡献尽可能的小**，那么利用**双向队列**处理，把绝对值大的扔到可以做正贡献的位置上，把绝对值小的扔到负贡献的位置上。



---


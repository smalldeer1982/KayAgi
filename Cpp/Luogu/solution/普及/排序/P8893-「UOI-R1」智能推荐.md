# 「UOI-R1」智能推荐

## 题目背景

数据已加强。

## 题目描述

现在有 $N$ 道题。

天数的编号从 $0$ 开始，每一天你可以做若干道题，你只能做以前推荐过的或者当天推荐的题（每道题只可以做一次）。第一天，智能推荐会推荐 $p$ 道题。

推荐规则如下：

对于第 $i$ 道题，如果有可能被推荐的话，就会有一个题目集合 $s_i$。当且仅当你把 $s_i$ 中每一道题都做出来并且其中有一道题是当天做的，那么下一天就会推荐第 $i$ 题。

你想做完第 $K$ 道题，问至少第几天你才能满足愿望？


## 说明/提示

**【样例解释 #1】**

第 $0$ 天推了第 $1,2$ 题，都做了。

第 $1$ 推了第 $3$ 题，做了。

第 $2$ 推了第 $4$ 题，做了。

第 $3$ 推了第 $5$ 题，也就是第 $K$ 题，做了。

第 $3$ 天即可做完第 $K$ 题目。

**【样例解释 #2】**

第 $0$ 天推了第 $1$ 题，也就是第 $K$ 题，做了。
第 $0$ 天就做完了。

**【数据范围】**

以下记 $\left| s_i \right|$ 表示推荐规则中第 $i$ 条规则中，如果 $v_i$ 被推荐，要做的所有题。

对于 $30\%$ 的数据，保证 $1 \leq N \leq 100$。

对于 $50\%$ 的数据，保证没有环。

对于 $100\%$ 的数据，保证 $1 \le K,s_i,p_i,v_i \le N \le 5\times 10^3$，$0 \leq R \leq 5 \times 10^3$。$|s_i|$ 互不相同，且对于每一个 $|s_i|$ 都有 $p_i$ 互不相同，$v_i$ 互不相同。


## 样例 #1

### 输入

```
5 5 2
1 2
3
3 2 1 2
4 3 1 2 3
5 3 1 3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
1 1 1
1
0```

### 输出

```
0```

## 样例 #3

### 输入

```
7 7 2
1 2
2
3 2 1 2
6 2 1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
见文件附件的 rec4.in```

### 输出

```
见文件附件的 rec4.ans```

# 题解

## 作者：鱼跃于渊 (赞：9)

# solution:  
我们可以发现，模拟的时间复杂度是 $O(n^2)$ ，可以通过该题。  
那么怎么模拟呢？将一开始的推荐题目放到明天推荐题目中，不停地做以下操作：
1. 将明天推荐题目复制到今天推荐题目中并清空。如果明天推荐题目数为零，输出 `-1` ，结束。
2. 否则处理今天推荐题目，记录当前题目已被做过，并遍历题目集合包含此题的所有题目。
3. 将当前题目的需做题数减一，如果需做题数为零，那将此题加入明天推荐题目中。
4. 如果第 `k` 道题已被做过，退出循环，输出当前天数；否则将天数加一。
# code：
```
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int n,k,r,day,vis[N],t[N];
//vis 记录某题是否已做，t 记录做某题所需要做的题数
int w,nw,ok[N],nok[N];
//分别记录今天推荐题目，明天推荐题目
vector <int> relat[N];
//relat 记录某题在哪些题的题目集合里
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k>>nw;
	for(int i=1;i<=nw;i++) cin>>nok[i];
	cin>>r;
	for(int i=1,x,y;i<=r;i++){
		cin>>x>>t[x];
		for(int j=1;j<=t[x];j++){
			cin>>y;
			relat[y].push_back(x);
		}
	}
	while(1){
		//明天推荐题目复制到今天推荐题目里
		w=nw;nw=0;
		for(int i=1;i<=w;i++)
			ok[i]=nok[i];
		//如果当天没有任何推荐题目，无解
		if(!w){
			cout<<"-1\n";
			return 0;
		}
		for(int i=1;i<=w;i++){
			//记录已做
			vis[ok[i]]=1;
			//遍历包含本题的题目集合
			for(int j=0,l=relat[ok[i]].size();j<l;j++){
				t[relat[ok[i]][j]]--;
				//如果需做题数为零，则明天能做这道题
				if(!t[relat[ok[i]][j]]){
					nok[++nw]=relat[ok[i]][j];
				}
			}
		}
		//做完了第k道题，退出循环
		if(vis[k]) break;
		day++;
 	}
	cout<<day<<'\n';
	return 0;
}
```
第一次发题解，若有错误之处还敬请各位神犇斧正。

---

## 作者：刘辰雨 (赞：8)

# 使用算法：拓扑排序

此题非常简单，是拓扑排序模板题，所以我打算讲一讲**什么是拓扑排序**，以及**如何实现拓扑排序**。

## 一、什么是拓扑排序？

`对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。----百度百科。`

看似非常难懂，但是我用人话解释给大家听，意思就是说：

对于一个节点为 $[1,n]$ 的有向图，会有**一些** $[1,n]$ 的排列 $^*F$，满足对于图中任意一条 $i \rightarrow j (i,j \in [1,n])$ 的边，$j$ 在排列 $^*F$ 中的位置都在 $i$ 的位置**之后**。这样的排列叫`拓扑排列`，求出这个排列的过程叫`拓扑排序`。

## 二、如何实现拓扑排序？

实现拓扑排序，说白了，就是求出一种拓扑排列。

为了方便解释，我们定义一条 $i \rightarrow j$ 的边中，$i$ 为 $j$ 的`前驱`，$j$ 为 $i$ 的`后继`。每一个节点都可以有多个前驱和多个后继。

那么，不难发现，当我们构造拓扑序列时，考虑一个节点是否应该加入序列时，实际上**应该考虑它的全部前驱是否已经在序列里**，**如果并非如此，那么就不能加入这个节点**。

再次考虑一种情况，当我们已经把一个点加入序列后，**对它的所有后继而言，它实际上已经失去了影响**，换而言之，这个点还在不在已经没有关系了，所以我们可以**直接“删去”这个点，将它与它的后继之间的边全部删去**。

于是，我们可以得到一份初步的拓扑排序代码：

```cpp
#include <iostream>
#include <cstdio> 
#include <vector>
#define maxn 5003
using namespace std;

int N /*节点数量*/,M /*边的数量*/ ;
vector<int> Edge[maxn];
/*我个人习惯使用vector存图，vector<int> *Edge[i]表示i的所有后继*/ 
int In[maxn]/*前驱数组，记录每个节点的实时前驱数量*/; 
int G[maxn],tot;/*拓扑序列数组*/

int First,End;
/*临时变量*/

int main()
{
	scanf("%d%d",&N,&M);
	for(int i = 1 ; i<= M ; i++)
	{
		scanf("%d%d",&First,&End);
		Edge[First].push_back(End);
		/*读入并添加一条 First -> End 的边*/
		In[End]++;
		/*记录前驱数量*/ 
	}
	while(tot < N)
	{
		for(int i = 1 ; i<= N ; i++)
		{
			if(In[i] == 0)
			{
				G[++tot] = i;
				for(int Now : Edge[i])
					In[Now]--;
				/*遍历 vector<int> *Egde[i]，改变i的所有后继的前驱数组数量*/
			}
		}
	}
	for(int i = 1 ; i<= N ; i++)
		printf("%d ",G[i]);
	puts(""); 
	return 0;
}
```
输入数据：

```
6 8
1 3
1 5
1 6
2 5
2 6
3 4
3 5
5 6
```
输出（拓扑序列）：

```
1 2 3 4 5 6
```
解释：

该**有向图**为如下：

![输入数据](https://cdn.luogu.com.cn/upload/image_hosting/oa149f8r.png)

可以尝试对比理解。

### 代码优化：

当你理解以后，就会发现这份代码慢得~~kou~~难以忍受，稍微卡一卡，就可以到 $\mathcal{O(n^2)}$ 的时间复杂度。所以，我们需要优化。

仔细思考，当一个节点从有前驱变成无前驱，只有可能是它的最后一个前驱被加入了序列的那一瞬间！那么我们只要抓住这个“瞬间”，结合 $dijkstra$ 的优化方式，不难想到使用队列优化。

具体请看优化代码：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#define maxn 5003
using namespace std;

int N,M;
vector<int> Edge[maxn];
int In[maxn];
int G[maxn],tot;

int First,End;
queue<int> Q;

int main()
{
	scanf("%d%d",&N,&M);
	for(int i = 1 ; i<= M ; i++)
	{
		scanf("%d%d",&First,&End);
		Edge[First].push_back(End);
		In[End]++;
	}
	for(int i = 1 ; i<= N ; i++)
		if(In[i] == 0)
			Q.push(i);
	while(!Q.empty())
	{
		int u = Q.front();
		Q.pop();
		G[++tot] = u;
		for(int Now : Edge[u])
		{
			In[Now]--;
			if(In[Now] == 0)
				 Q.push(Now);
		}
	}
	for(int i = 1 ; i<= tot ; i++)/*tot = n*/
		printf("%d ",G[i]);
	puts("");
	return 0;
}
```
通过这种方式，可以省掉不必要的遍历，对于稀疏图，可以大大减少时间复杂度，降低了被卡的可能性。（不过很遗憾，对于完全图，它会退化成朴素算法

## 三、此题该怎么做？

非常简单，求拓扑序列的同时记录每道题完成的天数，当序列求到编号为 $K$ 的题时，输出完成天数并结束程序即可。若程序一直执行到最后，输出`-1`。

具体看代码：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <bitset> 
#include <queue>
#define maxn 5003
using namespace std;

vector<int> Edge[maxn];
bitset<maxn> Avai;
int N,K,p;
int R;
int In[maxn];

int First,End,Num;

queue<pair<int,int> > Q;

int main()
{
	while(!Q.empty())
		Q.pop();
	scanf("%d%d%d",&N,&K,&p);
	for(int i = 1 ; i<= p ; i++)
	{
		scanf("%d",&Num);
		Avai[Num] = true;
		Q.push({Num,0});
	}
	scanf("%d",&R);
	for(int i = 1 ; i<= R ; i++)
	{
		scanf("%d%d",&End,&Num);
		while(Num--)
		{
			scanf("%d",&First);
			Edge[First].push_back(End);
			In[End]++;
		}
	}
	while(!Q.empty())
	{
		pair<int,int> u = Q.front();
		Q.pop();
		int ID = u.first;
		int Day = u.second;
		if(!Avai[ID])
			continue;
		if(ID == K)
		{
			printf("%d\n",Day);
			return 0;
		}
		for(int End: Edge[ID] )
		{
			In[End]--;
			if(In[End] == 0)
			{
				Avai[End] = true;
				Q.push({End,Day+1});
			}
		}
	}
	puts("-1");
	return 0;
}
```

## 写在最后：

首先，此题较为简单，

建议评 $\textcolor{#FFC116}{Popularization/Enhancement-}$。

其次，

## ~~好久没写过这么水的T3啦，感谢UOI让我重振信心！！~~ 比赛很赞！

---

## 作者：cosf (赞：3)

## [P8893 智能推荐](https://www.luogu.com.cn/problem/P8893)

## 思路

看到推荐的规则后，你一定会想到，推荐一道题当且仅当把它要做的题中的最后一道做的题做出来。

我们可以发现，模拟的算法是 $O(n^2)$ 的，也就是说这个是可以过的。怎么模拟？我们可以给每道题建一个数组 `to`，代表这道题在哪些题的题目集合里。然后把第一天推荐的题入队，然后不停地做以下的操作：

1. 取出队列的最前一个。

2. 如果它是 `K`，就输出它对应的天数，然后**直接退出程序**。

3. 否则就给它的 `to` 中的每道题做个标记，表示做了这一道。

4. 如果它 `to` 中的某一道的题目集合标满了，就把它入列，对应天数是它的天数加一。

如果是正常退出循环的，证明 `K` 没入过队，输出 `-1`，结束。

这个就是 **拓扑排序** 的变式。

## 正确性证明

等会再证

## 怎么标记

经过我~~多次~~验算，发现 `to` 数组是要的，但是标记只用标记自己题目集合还有多少题没做就可以了。这样确保是最后一道题做完了这个才会入队。

## 正确性证明

我们可以发现，这个入队的方法 **保证了队内题目对应天数的单调不减**，因为比如说现在是单调不减的，然后处理的是第 $i$ 天的，那么它处理完对应的天数是 $i+1$ 天，如果不是单调不减，那么在第 $i+1$ 天后可能有一个是有第 $i$ 天的。那么这个 $i$ 天一定是由第 $i-1$ 天推出来的。那么也就是说第 $i$ 天后面有一个第 $i-1$ 天的，与前面设定的单调不减矛盾。又一开始加入队的一批题目都是第 $1$ 天的，符合所谓的单调不减，所以队内的题目对应天数单调不减。这也顺势证明了一道题背推荐的时候最后一个做的一定是在当时队列里最后一项。

## 代码部分

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <set>
using namespace std;

int N, K, p;

vector<int> to[10004];
priority_queue<pair<int, int> /**/> que; // 注意，存的是（天数的相反数，题号）（因为懒得用greater）
set<int> f;
int need[10004];

int main()
{
    string fileid;
    cin >> fileid;
    freopen(("rec" + fileid + ".in").c_str(), "r", stdin);
    freopen(("rec" + fileid + ".out").c_str(), "w", stdout);
    cin >> N >> K >> p;
    int cur;
    for (int i = 1; i <= p; i++)
    {
        cin >> cur;
        if (cur == K)
        {
            cout << 0 << endl;
            return 0;
        }
        f.insert(cur);
        que.push(make_pair(0, cur)); // 第一天是0，注意。
    }
    int r;
    cin >> r;
    for (int i = 1; i <= r; i++)
    {
        int j;
        cin >> j;
        cin >> need[j];
        int k;
        int fs = f.count(j);
        for (int l = 1; l <= need[j]; l++)
        {
            cin >> k;
            to[k].push_back(j);
        }
        if (fs)
        {
            need[j] = -1;
        }
    }
    while (!que.empty())
    {
        pair<int, int> tp = que.top();
        que.pop();
        if (tp.second == K)
        {
            cout << -tp.first << endl;
            return 0;
        }
        for (int i : to[tp.second])
        {
            need[i]--;
            if (need[i] == 0)
            {
                if (i == K)
                {
                    cout << -(tp.first - 1) << endl; // 记得 -1！（因为是下一天的）
                    return 0;
                }
                que.push(make_pair(tp.first - 1, i));
            }
        }
    }
    cout << -1 << endl;
    return 0;
}

```


---

## 作者：happybob (赞：2)

本来以为出了个板子，但好像没有被喷太惨。

题目出来后，出题人其实给了一个三次方的做法，而枚举天数暴力算也是三次方的。

而在公开赛几天前，这玩意被加强了，原因是出题人突然发现可以拓扑排序。

然后暴力被卡成 $90$ 分。但是我们可以考虑 `bitset` 优化。显然每天肯定能把现在能做的全部做完，然后枚举每一条规则，看能否解锁新的题目。理论上这一部分需要 $O(n)$ 判断，但是可以考虑 `bitset` 优化，复杂度变为 $O(\dfrac{n}{w})$，即可通过。

于是 `bitset` 过了，复杂度 $O(\dfrac{n^3}{w})$，拓扑排序应该是 $O(n^2)$ 的。

代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long

const int N = 5e3 + 5, INF = 2e9, MOD = 1e9 + 7;

inline int read()
{
	int op = 1, x = 0;
	char ch = getchar();
	while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
	while (ch == '-')
	{
		op = -op;
		ch = getchar();
	}
	while (ch >= '0' and ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * op;
}

inline void write(int x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

int n, k, p, g[N], r, f[N];
bitset<N> v, vv; 
bitset<N> q[N];

int main()
{
	// freopen("*.in", "r", stdin);
	// freopen("*.out", "w", stdout);
	int ans = 0;
	scanf("%d%d%d", &n, &k, &p);
	for (int i = 1; i <= p; i++)
	{
		int x;
		scanf("%d", &x);
		v[x] = 1;
	}
	scanf("%d", &r);
	if (r > n) return -1;
	for (int i = 1; i <= r; i++)
	{
		scanf("%d%d", &g[i], &f[i]);
		if (g[i] > n) return -1;
		int dd;
		for (int j = 1; j <= f[i]; j++)
		{
			scanf("%d", &dd);
			q[i][dd] = 1;
		}
	}
	int now = 0;
	while (now < 10000)
	{
		if (v[k])
		{
			printf("%d\n", now);
			return 0;
		}
		vv = v;
		for (int i = 1; i <= r; i++)
		{
			if (v[g[i]]) continue;
			bitset<N> kkk = q[i] & vv;
			if (kkk == q[i])
			{
				v[g[i]] = 1;
			}
		}
		now++;
	}
	printf("-1\n");
	return 0;
}
```




---

## 作者：koobee (赞：2)

这题考场上AC了。

思路：拓扑排序。

我们可以把每个推荐规则建成图。设如果要做第 $v_i$ 题，要做 $s$ 道题，分别为 $p_1$ , . . . , $p_s$ , 可以看成第 $v_i$ 号点的入度为 $s$, $p_1$ , . . . , $p_s$ 分别向它建单向边，边权为 $1$。

建完图后，以最初推荐的 $p$ 道题为起点，跑 用拓扑排序跑**最长路**, 即可完成本题。

std:

```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
const int N = 1e4+5;
vector<int> v[N];
queue<int> q;
int n, k, p, ind[N], f[N], vv, s, x, r;
bool flag[N];
int main(){
	ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
	memset(f, 0xc0, sizeof(f));
	cin>>n>>k>>p;
	for(int i = 1; i <= p; i++){
		cin>>x;
		q.push(x); //起点
		f[x] = 0;
	}
	cin>>r;
	for(int i = 1; i <= r; i++){
		cin>>vv>>s;
		for(int j = 1; j <= s; j++){
			cin>>x;
			v[x].push_back(vv);
			ind[vv]++;
		} //建边
	}
	while(!q.empty()){
		int d = q.front();
		q.pop();
		for(int i = 0; i < v[d].size(); i++){
			ind[v[d][i]]--;
			if(ind[v[d][i]]==0){
			    if(f[v[d][i]] < 0) f[v[d][i]] = max(f[v[d][i]], f[d] + 1); //注意环，不知道是不是数据水，把判断条件删掉或把这句话放外面都能AC
			    q.push(v[d][i]);
			}
		}
	}
	if(f[k] < 0) cout<<-1<<endl; //-1
	else cout<<f[k]<<endl;
	return 0;
}
```


---

## 作者：BZHZS (赞：1)

## 关于题目
这是一道比较简单的图论题，难度在黄色左右

[题面传送门](https://www.luogu.com.cn/problem/P8893)

## 思路分析

通过读题，发现这道题目是否被推荐仅取决于需要做的题目是否做完了。所以我们可以把每一道题目抽象成点，题目与题目之间的关系抽象成边，比如说要推荐第 $3$ 道题需要先写完第 $2$ 道题，就连一条从 $2$ 到 $3$ 的边。很容易发现，这样就构建出了一个有向图。

举个例子：如第一个样例建的图就应该是这样的（好像画的有点丑）

![](https://cdn.luogu.com.cn/upload/image_hosting/hvp9rr7d.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

然后，我们可以很容易的发现，答案就是第 $k$ 道题的拓扑排序的深度减 $1$，与板子不同的地方在于一开始放入队列的不是入度为 $0$ 的点，而是输入给你的 $p$ 个点。

## 注意事项
	
1. 要把输入给你的 $p$ 个点的层数初始化为 $0$，而不是 $1$。

2. 记得特判输出 ```-1``` 的情况，即第 $k$ 个点不在拓扑序中。

## 代码实现
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 500010;

struct node
{
    int x, ans;
};

int n, m, k, r, p, x, y;
int in[N];
node tt;
queue<node> q;
vector<int> f[N];

inline int read()\\快读优化，比赛必备
{
    int f = 1, s = 0;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        s = (s << 1) + (s << 3) + c - '0';
        c = getchar();
    }
    return s * f;
}

int main()
{
    n = read(), k = read(), p = read();
    for (int i = 1; i <= p; i++)\\一边读入一边建图
    {
        x = read();
        q.push(node{x, 0});
        if (x == k)
        {
            puts("0");
            return 0;
        }
    }
    r = read();
    for (int i = 1; i <= r; i++)
    {
        y = read(), m = read();
        in[y] = m;
        for (int i = 1; i <= m; i++)
        {
            x = read();
            f[x].push_back(y);
        }
    }
    while (!q.empty())\\进行拓扑排序
    {
        tt = q.front();
        tt.ans++;
        q.pop();
        for (int i = 0; i < f[tt.x].size(); i++)
        {
            in[f[tt.x][i]]--;
            if (!in[f[tt.x][i]])\\如果需要的题目都做完了就可以入队了
            {
                if (f[tt.x][i] == k)\\判断是否为第 k 道题目
                {
                    printf("%d\n", tt.ans);
                    return 0;
                }
                q.push(node{f[tt.x][i], tt.ans});
            }
        }
    }
    puts("-1");\\排完了还是没有输出就直接输出 -1。
    return 0;
}
```


---

## 作者：yeshubo_qwq (赞：1)

## Solution

没有限制每天最多能做多少题，为了尽快做到目标题，我们能做就做。

当一道题目被推荐，说明它对应的题目集合已经做完了，在题目集合中每一题做完的天数加一中取 $\max$，就是能完成此题最早的时间。

是个拓扑模板。

**数据加强被叉爆了！**

如果第 $K$ 题的题目集合中有未完成的题目，但是有完成的题目使得它的结果被更新了，然后又没判入度清零，就寄了！

## Code

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
int n,tar,m,i,j,T,c,x,y,in[5005],out[5005],ans[5005],tmp;
vector <int> G[5005];
queue <int> q;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>tar>>m;
    memset(ans,-1,sizeof(ans));
    for (i=1;i<=m;i++) cin>>x,q.push(x),ans[x]=0;
    cin>>T;
    for (i=1;i<=T;i++){
        cin>>c>>tmp;
        in[c]=tmp;
        for (j=1;j<=in[c];j++)
            cin>>x,G[x].push_back(c),out[x]++;
        if (ans[c]==0) in[c]=0;
    }
    while (!q.empty()){
        x=q.front(),q.pop();
        for (i=0;i<out[x];i++){
            y=G[x][i];
            ans[y]=(ans[y],ans[x]+1);
            if (--in[y]==0) q.push(y);
        }
    }
    if (in[tar]!=0) ans[tar]=-1;
    return cout<<ans[tar],0;
}
```


---

## 作者：so_find_skind (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8893)

## 题目分析

题目问的是至少第几天才能做第 $K$ 题，实际上就是让我们决定对于第 $K$ 题来说的最佳做题顺序，就涉及到了图论中的“拓扑排序”。

为什么是拓扑排序？其实不难想，它就是用来解决有向无环图的先后顺序的，而题目集合就相当于某个点对应的入度点，完全符合，所以就是一个拓扑板子。

不过这里要注意，对于有环图，通过推论，会至少存在一个点，在到它之前也要到它，变得不符合逻辑。

所以用一个数组 $v$ 去记录入度数量，用 vector 容器储存入度对应点，然后进行拓扑板子。

完结撒花！

---

